{
  "module_name": "dbri.c",
  "hash_id": "afde498644e5f2213aaf1662d501827701b722c2f1ec0e86f2e421e94ebc3b2f",
  "original_prompt": "Ingested from linux-6.6.14/sound/sparc/dbri.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/gfp.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/atomic.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"Rudolf Koenig, Brent Baccala and Martin Habets\");\nMODULE_DESCRIPTION(\"Sun DBRI\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \n \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Sun DBRI soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Sun DBRI soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Sun DBRI soundcard.\");\n\n#undef DBRI_DEBUG\n\n#define D_INT\t(1<<0)\n#define D_GEN\t(1<<1)\n#define D_CMD\t(1<<2)\n#define D_MM\t(1<<3)\n#define D_USR\t(1<<4)\n#define D_DESC\t(1<<5)\n\nstatic int dbri_debug;\nmodule_param(dbri_debug, int, 0644);\nMODULE_PARM_DESC(dbri_debug, \"Debug value for Sun DBRI soundcard.\");\n\n#ifdef DBRI_DEBUG\nstatic const char * const cmds[] = {\n\t\"WAIT\", \"PAUSE\", \"JUMP\", \"IIQ\", \"REX\", \"SDP\", \"CDP\", \"DTS\",\n\t\"SSP\", \"CHI\", \"NT\", \"TE\", \"CDEC\", \"TEST\", \"CDM\", \"RESRV\"\n};\n\n#define dprintk(a, x...) if (dbri_debug & a) printk(KERN_DEBUG x)\n\n#else\n#define dprintk(a, x...) do { } while (0)\n\n#endif\t\t\t\t \n\n#define DBRI_CMD(cmd, intr, value) ((cmd << 28) |\t\\\n\t\t\t\t    (intr << 27) |\t\\\n\t\t\t\t    value)\n\n \n\nstruct cs4215 {\n\t__u8 data[4];\t\t \n\t__u8 ctrl[4];\t\t \n\t__u8 onboard;\n\t__u8 offset;\t\t \n\tvolatile __u32 status;\n\tvolatile __u32 version;\n\t__u8 precision;\t\t \n\t__u8 channels;\t\t \n};\n\n \n\n \n#define CS4215_CLB\t(1<<2)\t \n#define CS4215_OLB\t(1<<3)\t \n\t\t\t\t \n#define CS4215_MLB\t(1<<4)\t \n#define CS4215_RSRVD_1  (1<<5)\n\n \n#define CS4215_DFR_LINEAR16\t0\n#define CS4215_DFR_ULAW\t\t1\n#define CS4215_DFR_ALAW\t\t2\n#define CS4215_DFR_LINEAR8\t3\n#define CS4215_DFR_STEREO\t(1<<2)\nstatic struct {\n\tunsigned short freq;\n\tunsigned char xtal;\n\tunsigned char csval;\n} CS4215_FREQ[] = {\n\t{  8000, (1 << 4), (0 << 3) },\n\t{ 16000, (1 << 4), (1 << 3) },\n\t{ 27429, (1 << 4), (2 << 3) },\t \n\t{ 32000, (1 << 4), (3 << 3) },\n      \n      \n\t{ 48000, (1 << 4), (6 << 3) },\n\t{  9600, (1 << 4), (7 << 3) },\n\t{  5512, (2 << 4), (0 << 3) },\t \n\t{ 11025, (2 << 4), (1 << 3) },\n\t{ 18900, (2 << 4), (2 << 3) },\n\t{ 22050, (2 << 4), (3 << 3) },\n\t{ 37800, (2 << 4), (4 << 3) },\n\t{ 44100, (2 << 4), (5 << 3) },\n\t{ 33075, (2 << 4), (6 << 3) },\n\t{  6615, (2 << 4), (7 << 3) },\n\t{ 0, 0, 0}\n};\n\n#define CS4215_HPF\t(1<<7)\t \n\n#define CS4215_12_MASK\t0xfcbf\t \n\n \n#define CS4215_XEN\t(1<<0)\t \n#define CS4215_XCLK\t(1<<1)\t \n#define CS4215_BSEL_64\t(0<<2)\t \n#define CS4215_BSEL_128\t(1<<2)\n#define CS4215_BSEL_256\t(2<<2)\n#define CS4215_MCK_MAST (0<<4)\t \n#define CS4215_MCK_XTL1 (1<<4)\t \n#define CS4215_MCK_XTL2 (2<<4)\t \n#define CS4215_MCK_CLK1 (3<<4)\t \n#define CS4215_MCK_CLK2 (4<<4)\t \n\n \n#define CS4215_DAD\t(1<<0)\t \n#define CS4215_ENL\t(1<<1)\t \n\n \n \n\n \n\n \n#define CS4215_VERSION_MASK 0xf\t \n\n \n\n \n \n\n \n#define CS4215_LO(v)\tv\t \n#define CS4215_LE\t(1<<6)\t \n#define CS4215_HE\t(1<<7)\t \n\n \n#define CS4215_RO(v)\tv\t \n#define CS4215_SE\t(1<<6)\t \n#define CS4215_ADI\t(1<<7)\t \n\n \n#define CS4215_LG(v)\tv\t \n#define CS4215_IS\t(1<<4)\t \n#define CS4215_OVR\t(1<<5)\t \n#define CS4215_PIO0\t(1<<6)\t \n#define CS4215_PIO1\t(1<<7)\n\n \n#define CS4215_RG(v)\tv\t \n#define CS4215_MA(v)\t(v<<4)\t \n\n \n\n \n#define REG0\t0x00\t\t \n#define REG1\t0x04\t\t \n#define REG2\t0x08\t\t \n#define REG3\t0x0c\t\t \n#define REG8\t0x20\t\t \n#define REG9\t0x24\t\t \n\n#define DBRI_NO_CMDS\t64\n#define DBRI_INT_BLK\t64\n#define DBRI_NO_DESCS\t64\n#define DBRI_NO_PIPES\t32\n#define DBRI_MAX_PIPE\t(DBRI_NO_PIPES - 1)\n\n#define DBRI_REC\t0\n#define DBRI_PLAY\t1\n#define DBRI_NO_STREAMS\t2\n\n \n \nstruct dbri_mem {\n\tvolatile __u32 word1;\n\t__u32 ba;\t \n\t__u32 nda;\t \n\tvolatile __u32 word4;\n};\n\n \nstruct dbri_dma {\n\ts32 cmd[DBRI_NO_CMDS];\t\t\t \n\tvolatile s32 intr[DBRI_INT_BLK];\t \n\tstruct dbri_mem desc[DBRI_NO_DESCS];\t \n};\n\n#define dbri_dma_off(member, elem)\t\\\n\t((u32)(unsigned long)\t\t\\\n\t (&(((struct dbri_dma *)0)->member[elem])))\n\nenum in_or_out { PIPEinput, PIPEoutput };\n\nstruct dbri_pipe {\n\tu32 sdp;\t\t \n\tint nextpipe;\t\t \n\tint length;\t\t \n\tint first_desc;\t\t \n\tint desc;\t\t \n\tvolatile __u32 *recv_fixed_ptr;\t \n};\n\n \nstruct dbri_streaminfo {\n\tstruct snd_pcm_substream *substream;\n\tu32 dvma_buffer;\t \n\tint size;\t\t \n\tsize_t offset;\t\t \n\tint pipe;\t\t \n\tint left_gain;\t\t \n\tint right_gain;\n};\n\n \nstruct snd_dbri {\n\tint regs_size, irq;\t \n\tstruct platform_device *op;\t \n\tspinlock_t lock;\n\n\tstruct dbri_dma *dma;\t \n\tdma_addr_t dma_dvma;\t \n\n\tvoid __iomem *regs;\t \n\tint dbri_irqp;\t\t \n\n\tstruct dbri_pipe pipes[DBRI_NO_PIPES];\t \n\tint next_desc[DBRI_NO_DESCS];\t\t \n\tspinlock_t cmdlock;\t \n\ts32 *cmdptr;\t\t \n\n\tint chi_bpf;\n\n\tstruct cs4215 mm;\t \n\t\t\t\t \n\tstruct dbri_streaminfo stream_info[DBRI_NO_STREAMS];\n};\n\n#define DBRI_MAX_VOLUME\t\t63\t \n#define DBRI_MAX_GAIN\t\t15\t \n\n \n#define D_P\t\t(1<<15)\t \n#define D_G\t\t(1<<14)\t \n#define D_S\t\t(1<<13)\t \n#define D_E\t\t(1<<12)\t \n#define D_X\t\t(1<<7)\t \n#define D_T\t\t(1<<6)\t \n#define D_N\t\t(1<<5)\t \n#define D_C\t\t(1<<4)\t \n#define D_F\t\t(1<<3)\t \n#define D_D\t\t(1<<2)\t \n#define D_H\t\t(1<<1)\t \n#define D_R\t\t(1<<0)\t \n\n \n#define D_LITTLE_END\t(1<<8)\t \n#define D_BIG_END\t(0<<8)\t \n#define D_MRR\t\t(1<<4)\t \n#define D_MLE\t\t(1<<3)\t \n#define D_LBG\t\t(1<<2)\t \n#define D_MBE\t\t(1<<1)\t \n#define D_IR\t\t(1<<0)\t \n\n \n#define D_ENPIO3\t(1<<7)\t \n#define D_ENPIO2\t(1<<6)\t \n#define D_ENPIO1\t(1<<5)\t \n#define D_ENPIO0\t(1<<4)\t \n#define D_ENPIO\t\t(0xf0)\t \n#define D_PIO3\t\t(1<<3)\t \n#define D_PIO2\t\t(1<<2)\t \n#define D_PIO1\t\t(1<<1)\t \n#define D_PIO0\t\t(1<<0)\t \n\n \n#define D_WAIT\t\t0x0\t \n#define D_PAUSE\t\t0x1\t \n#define D_JUMP\t\t0x2\t \n#define D_IIQ\t\t0x3\t \n#define D_REX\t\t0x4\t \n#define D_SDP\t\t0x5\t \n#define D_CDP\t\t0x6\t \n#define D_DTS\t\t0x7\t \n#define D_SSP\t\t0x8\t \n#define D_CHI\t\t0x9\t \n#define D_NT\t\t0xa\t \n#define D_TE\t\t0xb\t \n#define D_CDEC\t\t0xc\t \n#define D_TEST\t\t0xd\t \n#define D_CDM\t\t0xe\t \n\n \n#define D_PIPE(v)      ((v)<<0)\t \n\n \n \n#define D_SDP_2SAME\t(1<<18)\t \n#define D_SDP_CHANGE\t(2<<18)\t \n#define D_SDP_EVERY\t(3<<18)\t \n#define D_SDP_EOL\t(1<<17)\t \n#define D_SDP_IDLE\t(1<<16)\t \n\n \n#define D_SDP_MEM\t(0<<13)\t \n#define D_SDP_HDLC\t(2<<13)\n#define D_SDP_HDLC_D\t(3<<13)\t \n#define D_SDP_SER\t(4<<13)\t \n#define D_SDP_FIXED\t(6<<13)\t \n#define D_SDP_MODE(v)\t((v)&(7<<13))\n\n#define D_SDP_TO_SER\t(1<<12)\t \n#define D_SDP_FROM_SER\t(0<<12)\t \n#define D_SDP_MSB\t(1<<11)\t \n#define D_SDP_LSB\t(0<<11)\t \n#define D_SDP_P\t\t(1<<10)\t \n#define D_SDP_A\t\t(1<<8)\t \n#define D_SDP_C\t\t(1<<7)\t \n\n \n#define D_DTS_VI\t(1<<17)\t \n#define D_DTS_VO\t(1<<16)\t \n#define D_DTS_INS\t(1<<15)\t \n#define D_DTS_DEL\t(0<<15)\t \n#define D_DTS_PRVIN(v) ((v)<<10)\t \n#define D_DTS_PRVOUT(v)        ((v)<<5)\t \n\n \n#define D_TS_LEN(v)\t((v)<<24)\t \n#define D_TS_CYCLE(v)\t((v)<<14)\t \n#define D_TS_DI\t\t(1<<13)\t \n#define D_TS_1CHANNEL\t(0<<10)\t \n#define D_TS_MONITOR\t(2<<10)\t \n#define D_TS_NONCONTIG\t(3<<10)\t \n#define D_TS_ANCHOR\t(7<<10)\t \n#define D_TS_MON(v)    ((v)<<5)\t \n#define D_TS_NEXT(v)   ((v)<<0)\t \n\n \n#define D_CHI_CHICM(v)\t((v)<<16)\t \n#define D_CHI_IR\t(1<<15)\t \n#define D_CHI_EN\t(1<<14)\t \n#define D_CHI_OD\t(1<<13)\t \n#define D_CHI_FE\t(1<<12)\t \n#define D_CHI_FD\t(1<<11)\t \n#define D_CHI_BPF(v)\t((v)<<0)\t \n\n \n#define D_NT_FBIT\t(1<<17)\t \n#define D_NT_NBF\t(1<<16)\t \n#define D_NT_IRM_IMM\t(1<<15)\t \n#define D_NT_IRM_EN\t(1<<14)\t \n#define D_NT_ISNT\t(1<<13)\t \n#define D_NT_FT\t\t(1<<12)\t \n#define D_NT_EZ\t\t(1<<11)\t \n#define D_NT_IFA\t(1<<10)\t \n#define D_NT_ACT\t(1<<9)\t \n#define D_NT_MFE\t(1<<8)\t \n#define D_NT_RLB(v)\t((v)<<5)\t \n#define D_NT_LLB(v)\t((v)<<2)\t \n#define D_NT_FACT\t(1<<1)\t \n#define D_NT_ABV\t(1<<0)\t \n\n \n#define D_CDEC_CK(v)\t((v)<<24)\t \n#define D_CDEC_FED(v)\t((v)<<12)\t \n#define D_CDEC_RED(v)\t((v)<<0)\t \n\n \n#define D_TEST_RAM(v)\t((v)<<16)\t \n#define D_TEST_SIZE(v)\t((v)<<11)\t \n#define D_TEST_ROMONOFF\t0x5\t \n#define D_TEST_PROC\t0x6\t \n#define D_TEST_SER\t0x7\t \n#define D_TEST_RAMREAD\t0x8\t \n#define D_TEST_RAMWRITE\t0x9\t \n#define D_TEST_RAMBIST\t0xa\t \n#define D_TEST_MCBIST\t0xb\t \n#define D_TEST_DUMP\t0xe\t \n\n \n#define D_CDM_THI\t(1 << 8)\t \n#define D_CDM_RHI\t(1 << 7)\t \n#define D_CDM_RCE\t(1 << 6)\t \n#define D_CDM_XCE\t(1 << 2)  \n#define D_CDM_XEN\t(1 << 1)\t \n#define D_CDM_REN\t(1 << 0)\t \n\n \n#define D_INTR_BRDY\t1\t \n#define D_INTR_MINT\t2\t \n#define D_INTR_IBEG\t3\t \n#define D_INTR_IEND\t4\t \n#define D_INTR_EOL\t5\t \n#define D_INTR_CMDI\t6\t \n#define D_INTR_XCMP\t8\t \n#define D_INTR_SBRI\t9\t \n#define D_INTR_FXDT\t10\t \n#define D_INTR_CHIL\t11\t \n#define D_INTR_COLL\t11\t \n#define D_INTR_DBYT\t12\t \n#define D_INTR_RBYT\t13\t \n#define D_INTR_LINT\t14\t \n#define D_INTR_UNDR\t15\t \n\n#define D_INTR_TE\t32\n#define D_INTR_NT\t34\n#define D_INTR_CHI\t36\n#define D_INTR_CMD\t38\n\n#define D_INTR_GETCHAN(v)\t(((v) >> 24) & 0x3f)\n#define D_INTR_GETCODE(v)\t(((v) >> 20) & 0xf)\n#define D_INTR_GETCMD(v)\t(((v) >> 16) & 0xf)\n#define D_INTR_GETVAL(v)\t((v) & 0xffff)\n#define D_INTR_GETRVAL(v)\t((v) & 0xfffff)\n\n#define D_P_0\t\t0\t \n#define D_P_1\t\t1\t \n#define D_P_2\t\t2\t \n#define D_P_3\t\t3\t \n#define D_P_4\t\t4\t \n#define D_P_5\t\t5\t \n#define D_P_6\t\t6\t \n#define D_P_7\t\t7\t \n#define D_P_8\t\t8\t \n#define D_P_9\t\t9\t \n#define D_P_10\t\t10\t \n#define D_P_11\t\t11\t \n#define D_P_12\t\t12\t \n#define D_P_13\t\t13\t \n#define D_P_14\t\t14\t \n#define D_P_15\t\t15\t \n#define D_P_16\t\t16\t \n#define D_P_17\t\t17\t \n#define D_P_18\t\t18\t \n#define D_P_19\t\t19\t \n#define D_P_20\t\t20\t \n#define D_P_21\t\t21\t \n#define D_P_22\t\t22\t \n#define D_P_23\t\t23\t \n#define D_P_24\t\t24\t \n#define D_P_25\t\t25\t \n#define D_P_26\t\t26\t \n#define D_P_27\t\t27\t \n#define D_P_28\t\t28\t \n#define D_P_29\t\t29\t \n#define D_P_30\t\t30\t \n#define D_P_31\t\t31\t \n\n \n#define DBRI_TD_F\t(1 << 31)\t \n#define DBRI_TD_D\t(1 << 30)\t \n#define DBRI_TD_CNT(v)\t((v) << 16)  \n#define DBRI_TD_B\t(1 << 15)\t \n#define DBRI_TD_M\t(1 << 14)\t \n#define DBRI_TD_I\t(1 << 13)\t \n#define DBRI_TD_FCNT(v)\t(v)\t\t \n#define DBRI_TD_UNR\t(1 << 3)  \n#define DBRI_TD_ABT\t(1 << 2)\t \n#define DBRI_TD_TBC\t(1 << 0)\t \n#define DBRI_TD_STATUS(v)       ((v) & 0xff)\t \n\t\t\t \n#define DBRI_TD_MAXCNT\t((1 << 13) - 4)\n\n \n#define DBRI_RD_F\t(1 << 31)\t \n#define DBRI_RD_C\t(1 << 30)\t \n#define DBRI_RD_B\t(1 << 15)\t \n#define DBRI_RD_M\t(1 << 14)\t \n#define DBRI_RD_BCNT(v)\t(v)\t\t \n#define DBRI_RD_CRC\t(1 << 7)\t \n#define DBRI_RD_BBC\t(1 << 6)\t \n#define DBRI_RD_ABT\t(1 << 5)\t \n#define DBRI_RD_OVRN\t(1 << 3)\t \n#define DBRI_RD_STATUS(v)      ((v) & 0xff)\t \n#define DBRI_RD_CNT(v) (((v) >> 16) & 0x1fff)\t \n\n \n \n#define DBRI_STREAMNO(substream)\t\t\t\t\\\n\t\t(substream->stream ==\t\t\t\t\\\n\t\t SNDRV_PCM_STREAM_PLAYBACK ? DBRI_PLAY: DBRI_REC)\n\n \n#define DBRI_STREAM(dbri, substream)\t\\\n\t\t&dbri->stream_info[DBRI_STREAMNO(substream)]\n\n \nstatic __u32 reverse_bytes(__u32 b, int len)\n{\n\tswitch (len) {\n\tcase 32:\n\t\tb = ((b & 0xffff0000) >> 16) | ((b & 0x0000ffff) << 16);\n\t\tfallthrough;\n\tcase 16:\n\t\tb = ((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8);\n\t\tfallthrough;\n\tcase 8:\n\t\tb = ((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4);\n\t\tfallthrough;\n\tcase 4:\n\t\tb = ((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2);\n\t\tfallthrough;\n\tcase 2:\n\t\tb = ((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1);\n\tcase 1:\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"DBRI reverse_bytes: unsupported length\\n\");\n\t}\n\n\treturn b;\n}\n\n \n\n#define MAXLOOPS 20\n \nstatic void dbri_cmdwait(struct snd_dbri *dbri)\n{\n\tint maxloops = MAXLOOPS;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&dbri->lock, flags);\n\twhile ((--maxloops) > 0 && (sbus_readl(dbri->regs + REG0) & D_P)) {\n\t\tspin_unlock_irqrestore(&dbri->lock, flags);\n\t\tmsleep_interruptible(1);\n\t\tspin_lock_irqsave(&dbri->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\tif (maxloops == 0)\n\t\tprintk(KERN_ERR \"DBRI: Chip never completed command buffer\\n\");\n\telse\n\t\tdprintk(D_CMD, \"Chip completed command buffer (%d)\\n\",\n\t\t\tMAXLOOPS - maxloops - 1);\n}\n \nstatic s32 *dbri_cmdlock(struct snd_dbri *dbri, int len)\n{\n\tu32 dvma_addr = (u32)dbri->dma_dvma;\n\n\t \n\tlen += 2;\n\tspin_lock(&dbri->cmdlock);\n\tif (dbri->cmdptr - dbri->dma->cmd + len < DBRI_NO_CMDS - 2)\n\t\treturn dbri->cmdptr + 2;\n\telse if (len < sbus_readl(dbri->regs + REG8) - dvma_addr)\n\t\treturn dbri->dma->cmd;\n\telse\n\t\tprintk(KERN_ERR \"DBRI: no space for commands.\");\n\n\treturn NULL;\n}\n\n \nstatic void dbri_cmdsend(struct snd_dbri *dbri, s32 *cmd, int len)\n{\n\tu32 dvma_addr = (u32)dbri->dma_dvma;\n\ts32 tmp, addr;\n\tstatic int wait_id;\n\n\twait_id++;\n\twait_id &= 0xffff;\t \n\t*(cmd) = DBRI_CMD(D_WAIT, 1, wait_id);\n\t*(cmd+1) = DBRI_CMD(D_WAIT, 1, wait_id);\n\n\t \n\taddr = dvma_addr + (cmd - len - dbri->dma->cmd) * sizeof(s32);\n\t*(dbri->cmdptr+1) = addr;\n\t*(dbri->cmdptr) = DBRI_CMD(D_JUMP, 0, 0);\n\n#ifdef DBRI_DEBUG\n\tif (cmd > dbri->cmdptr) {\n\t\ts32 *ptr;\n\n\t\tfor (ptr = dbri->cmdptr; ptr < cmd+2; ptr++)\n\t\t\tdprintk(D_CMD, \"cmd: %lx:%08x\\n\",\n\t\t\t\t(unsigned long)ptr, *ptr);\n\t} else {\n\t\ts32 *ptr = dbri->cmdptr;\n\n\t\tdprintk(D_CMD, \"cmd: %lx:%08x\\n\", (unsigned long)ptr, *ptr);\n\t\tptr++;\n\t\tdprintk(D_CMD, \"cmd: %lx:%08x\\n\", (unsigned long)ptr, *ptr);\n\t\tfor (ptr = dbri->dma->cmd; ptr < cmd+2; ptr++)\n\t\t\tdprintk(D_CMD, \"cmd: %lx:%08x\\n\",\n\t\t\t\t(unsigned long)ptr, *ptr);\n\t}\n#endif\n\n\t \n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp |= D_P;\n\tsbus_writel(tmp, dbri->regs + REG0);\n\n\tdbri->cmdptr = cmd;\n\tspin_unlock(&dbri->cmdlock);\n}\n\n \nstatic void dbri_reset(struct snd_dbri *dbri)\n{\n\tint i;\n\tu32 tmp;\n\n\tdprintk(D_GEN, \"reset 0:%x 2:%x 8:%x 9:%x\\n\",\n\t\tsbus_readl(dbri->regs + REG0),\n\t\tsbus_readl(dbri->regs + REG2),\n\t\tsbus_readl(dbri->regs + REG8), sbus_readl(dbri->regs + REG9));\n\n\tsbus_writel(D_R, dbri->regs + REG0);\t \n\tfor (i = 0; (sbus_readl(dbri->regs + REG0) & D_R) && i < 64; i++)\n\t\tudelay(10);\n\n\t \n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp |= D_G | D_E;\n\ttmp &= ~D_S;\n\tsbus_writel(tmp, dbri->regs + REG0);\n}\n\n \nstatic void dbri_initialize(struct snd_dbri *dbri)\n{\n\tu32 dvma_addr = (u32)dbri->dma_dvma;\n\ts32 *cmd;\n\tu32 dma_addr;\n\tunsigned long flags;\n\tint n;\n\n\tspin_lock_irqsave(&dbri->lock, flags);\n\n\tdbri_reset(dbri);\n\n\t \n\tfor (n = 0; n < DBRI_NO_PIPES; n++)\n\t\tdbri->pipes[n].desc = dbri->pipes[n].first_desc = -1;\n\n\tspin_lock_init(&dbri->cmdlock);\n\t \n\tdma_addr = dvma_addr + dbri_dma_off(intr, 0);\n\tdbri->dma->intr[0] = dma_addr;\n\tdbri->dbri_irqp = 1;\n\t \n\tspin_lock(&dbri->cmdlock);\n\tcmd = dbri->cmdptr = dbri->dma->cmd;\n\t*(cmd++) = DBRI_CMD(D_IIQ, 0, 0);\n\t*(cmd++) = dma_addr;\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\tdbri->cmdptr = cmd;\n\t*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);\n\t*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);\n\tdma_addr = dvma_addr + dbri_dma_off(cmd, 0);\n\tsbus_writel(dma_addr, dbri->regs + REG8);\n\tspin_unlock(&dbri->cmdlock);\n\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\tdbri_cmdwait(dbri);\n}\n\n \nstatic inline int pipe_active(struct snd_dbri *dbri, int pipe)\n{\n\treturn ((pipe >= 0) && (dbri->pipes[pipe].desc != -1));\n}\n\n \nstatic void reset_pipe(struct snd_dbri *dbri, int pipe)\n{\n\tint sdp;\n\tint desc;\n\ts32 *cmd;\n\n\tif (pipe < 0 || pipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR \"DBRI: reset_pipe called with \"\n\t\t\t\"illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tsdp = dbri->pipes[pipe].sdp;\n\tif (sdp == 0) {\n\t\tprintk(KERN_ERR \"DBRI: reset_pipe called \"\n\t\t\t\"on uninitialized pipe\\n\");\n\t\treturn;\n\t}\n\n\tcmd = dbri_cmdlock(dbri, 3);\n\t*(cmd++) = DBRI_CMD(D_SDP, 0, sdp | D_SDP_C | D_SDP_P);\n\t*(cmd++) = 0;\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\tdbri_cmdsend(dbri, cmd, 3);\n\n\tdesc = dbri->pipes[pipe].first_desc;\n\tif (desc >= 0)\n\t\tdo {\n\t\t\tdbri->dma->desc[desc].ba = 0;\n\t\t\tdbri->dma->desc[desc].nda = 0;\n\t\t\tdesc = dbri->next_desc[desc];\n\t\t} while (desc != -1 && desc != dbri->pipes[pipe].first_desc);\n\n\tdbri->pipes[pipe].desc = -1;\n\tdbri->pipes[pipe].first_desc = -1;\n}\n\n \nstatic void setup_pipe(struct snd_dbri *dbri, int pipe, int sdp)\n{\n\tif (pipe < 0 || pipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR \"DBRI: setup_pipe called \"\n\t\t\t\"with illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tif ((sdp & 0xf800) != sdp) {\n\t\tprintk(KERN_ERR \"DBRI: setup_pipe called \"\n\t\t\t\"with strange SDP value\\n\");\n\t\t \n\t}\n\n\t \n\tif (D_SDP_MODE(sdp) == D_SDP_FIXED && !(sdp & D_SDP_TO_SER))\n\t\tsdp |= D_SDP_CHANGE;\n\n\tsdp |= D_PIPE(pipe);\n\tdbri->pipes[pipe].sdp = sdp;\n\tdbri->pipes[pipe].desc = -1;\n\tdbri->pipes[pipe].first_desc = -1;\n\n\treset_pipe(dbri, pipe);\n}\n\n \nstatic void link_time_slot(struct snd_dbri *dbri, int pipe,\n\t\t\t   int prevpipe, int nextpipe,\n\t\t\t   int length, int cycle)\n{\n\ts32 *cmd;\n\tint val;\n\n\tif (pipe < 0 || pipe > DBRI_MAX_PIPE\n\t\t\t|| prevpipe < 0 || prevpipe > DBRI_MAX_PIPE\n\t\t\t|| nextpipe < 0 || nextpipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR\n\t\t    \"DBRI: link_time_slot called with illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tif (dbri->pipes[pipe].sdp == 0\n\t\t\t|| dbri->pipes[prevpipe].sdp == 0\n\t\t\t|| dbri->pipes[nextpipe].sdp == 0) {\n\t\tprintk(KERN_ERR \"DBRI: link_time_slot called \"\n\t\t\t\"on uninitialized pipe\\n\");\n\t\treturn;\n\t}\n\n\tdbri->pipes[prevpipe].nextpipe = pipe;\n\tdbri->pipes[pipe].nextpipe = nextpipe;\n\tdbri->pipes[pipe].length = length;\n\n\tcmd = dbri_cmdlock(dbri, 4);\n\n\tif (dbri->pipes[pipe].sdp & D_SDP_TO_SER) {\n\t\t \n\t\tif (prevpipe == 16 && cycle == 0)\n\t\t\tcycle = dbri->chi_bpf;\n\n\t\tval = D_DTS_VO | D_DTS_INS | D_DTS_PRVOUT(prevpipe) | pipe;\n\t\t*(cmd++) = DBRI_CMD(D_DTS, 0, val);\n\t\t*(cmd++) = 0;\n\t\t*(cmd++) =\n\t\t    D_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);\n\t} else {\n\t\tval = D_DTS_VI | D_DTS_INS | D_DTS_PRVIN(prevpipe) | pipe;\n\t\t*(cmd++) = DBRI_CMD(D_DTS, 0, val);\n\t\t*(cmd++) =\n\t\t    D_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);\n\t\t*(cmd++) = 0;\n\t}\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\n\tdbri_cmdsend(dbri, cmd, 4);\n}\n\n#if 0\n \nstatic void unlink_time_slot(struct snd_dbri *dbri, int pipe,\n\t\t\t     enum in_or_out direction, int prevpipe,\n\t\t\t     int nextpipe)\n{\n\ts32 *cmd;\n\tint val;\n\n\tif (pipe < 0 || pipe > DBRI_MAX_PIPE\n\t\t\t|| prevpipe < 0 || prevpipe > DBRI_MAX_PIPE\n\t\t\t|| nextpipe < 0 || nextpipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR\n\t\t    \"DBRI: unlink_time_slot called with illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tcmd = dbri_cmdlock(dbri, 4);\n\n\tif (direction == PIPEinput) {\n\t\tval = D_DTS_VI | D_DTS_DEL | D_DTS_PRVIN(prevpipe) | pipe;\n\t\t*(cmd++) = DBRI_CMD(D_DTS, 0, val);\n\t\t*(cmd++) = D_TS_NEXT(nextpipe);\n\t\t*(cmd++) = 0;\n\t} else {\n\t\tval = D_DTS_VO | D_DTS_DEL | D_DTS_PRVOUT(prevpipe) | pipe;\n\t\t*(cmd++) = DBRI_CMD(D_DTS, 0, val);\n\t\t*(cmd++) = 0;\n\t\t*(cmd++) = D_TS_NEXT(nextpipe);\n\t}\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\n\tdbri_cmdsend(dbri, cmd, 4);\n}\n#endif\n\n \nstatic void xmit_fixed(struct snd_dbri *dbri, int pipe, unsigned int data)\n{\n\ts32 *cmd;\n\tunsigned long flags;\n\n\tif (pipe < 16 || pipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR \"DBRI: xmit_fixed: Illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tif (D_SDP_MODE(dbri->pipes[pipe].sdp) == 0) {\n\t\tprintk(KERN_ERR \"DBRI: xmit_fixed: \"\n\t\t\t\"Uninitialized pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tif (D_SDP_MODE(dbri->pipes[pipe].sdp) != D_SDP_FIXED) {\n\t\tprintk(KERN_ERR \"DBRI: xmit_fixed: Non-fixed pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tif (!(dbri->pipes[pipe].sdp & D_SDP_TO_SER)) {\n\t\tprintk(KERN_ERR \"DBRI: xmit_fixed: Called on receive pipe %d\\n\",\n\t\t\tpipe);\n\t\treturn;\n\t}\n\n\t \n\n\tif (dbri->pipes[pipe].sdp & D_SDP_MSB)\n\t\tdata = reverse_bytes(data, dbri->pipes[pipe].length);\n\n\tcmd = dbri_cmdlock(dbri, 3);\n\n\t*(cmd++) = DBRI_CMD(D_SSP, 0, pipe);\n\t*(cmd++) = data;\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\n\tspin_lock_irqsave(&dbri->lock, flags);\n\tdbri_cmdsend(dbri, cmd, 3);\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\tdbri_cmdwait(dbri);\n\n}\n\nstatic void recv_fixed(struct snd_dbri *dbri, int pipe, volatile __u32 *ptr)\n{\n\tif (pipe < 16 || pipe > DBRI_MAX_PIPE) {\n\t\tprintk(KERN_ERR \"DBRI: recv_fixed called with \"\n\t\t\t\"illegal pipe number\\n\");\n\t\treturn;\n\t}\n\n\tif (D_SDP_MODE(dbri->pipes[pipe].sdp) != D_SDP_FIXED) {\n\t\tprintk(KERN_ERR \"DBRI: recv_fixed called on \"\n\t\t\t\"non-fixed pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tif (dbri->pipes[pipe].sdp & D_SDP_TO_SER) {\n\t\tprintk(KERN_ERR \"DBRI: recv_fixed called on \"\n\t\t\t\"transmit pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tdbri->pipes[pipe].recv_fixed_ptr = ptr;\n}\n\n \nstatic int setup_descs(struct snd_dbri *dbri, int streamno, unsigned int period)\n{\n\tstruct dbri_streaminfo *info = &dbri->stream_info[streamno];\n\tu32 dvma_addr = (u32)dbri->dma_dvma;\n\t__u32 dvma_buffer;\n\tint desc;\n\tint len;\n\tint first_desc = -1;\n\tint last_desc = -1;\n\n\tif (info->pipe < 0 || info->pipe > 15) {\n\t\tprintk(KERN_ERR \"DBRI: setup_descs: Illegal pipe number\\n\");\n\t\treturn -2;\n\t}\n\n\tif (dbri->pipes[info->pipe].sdp == 0) {\n\t\tprintk(KERN_ERR \"DBRI: setup_descs: Uninitialized pipe %d\\n\",\n\t\t       info->pipe);\n\t\treturn -2;\n\t}\n\n\tdvma_buffer = info->dvma_buffer;\n\tlen = info->size;\n\n\tif (streamno == DBRI_PLAY) {\n\t\tif (!(dbri->pipes[info->pipe].sdp & D_SDP_TO_SER)) {\n\t\t\tprintk(KERN_ERR \"DBRI: setup_descs: \"\n\t\t\t\t\"Called on receive pipe %d\\n\", info->pipe);\n\t\t\treturn -2;\n\t\t}\n\t} else {\n\t\tif (dbri->pipes[info->pipe].sdp & D_SDP_TO_SER) {\n\t\t\tprintk(KERN_ERR\n\t\t\t    \"DBRI: setup_descs: Called on transmit pipe %d\\n\",\n\t\t\t     info->pipe);\n\t\t\treturn -2;\n\t\t}\n\t\t \n\t\tif (pipe_active(dbri, info->pipe)) {\n\t\t\tprintk(KERN_ERR \"DBRI: recv_on_pipe: \"\n\t\t\t\t\"Called on active pipe %d\\n\", info->pipe);\n\t\t\treturn -2;\n\t\t}\n\n\t\t \n\t\tlen &= ~3;\n\t}\n\n\t \n\tdesc = dbri->pipes[info->pipe].first_desc;\n\tif (desc >= 0)\n\t\tdo {\n\t\t\tdbri->dma->desc[desc].ba = 0;\n\t\t\tdbri->dma->desc[desc].nda = 0;\n\t\t\tdesc = dbri->next_desc[desc];\n\t\t} while (desc != -1 &&\n\t\t\t desc != dbri->pipes[info->pipe].first_desc);\n\n\tdbri->pipes[info->pipe].desc = -1;\n\tdbri->pipes[info->pipe].first_desc = -1;\n\n\tdesc = 0;\n\twhile (len > 0) {\n\t\tint mylen;\n\n\t\tfor (; desc < DBRI_NO_DESCS; desc++) {\n\t\t\tif (!dbri->dma->desc[desc].ba)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (desc == DBRI_NO_DESCS) {\n\t\t\tprintk(KERN_ERR \"DBRI: setup_descs: No descriptors\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (len > DBRI_TD_MAXCNT)\n\t\t\tmylen = DBRI_TD_MAXCNT;\t \n\t\telse\n\t\t\tmylen = len;\n\n\t\tif (mylen > period)\n\t\t\tmylen = period;\n\n\t\tdbri->next_desc[desc] = -1;\n\t\tdbri->dma->desc[desc].ba = dvma_buffer;\n\t\tdbri->dma->desc[desc].nda = 0;\n\n\t\tif (streamno == DBRI_PLAY) {\n\t\t\tdbri->dma->desc[desc].word1 = DBRI_TD_CNT(mylen);\n\t\t\tdbri->dma->desc[desc].word4 = 0;\n\t\t\tdbri->dma->desc[desc].word1 |= DBRI_TD_F | DBRI_TD_B;\n\t\t} else {\n\t\t\tdbri->dma->desc[desc].word1 = 0;\n\t\t\tdbri->dma->desc[desc].word4 =\n\t\t\t    DBRI_RD_B | DBRI_RD_BCNT(mylen);\n\t\t}\n\n\t\tif (first_desc == -1)\n\t\t\tfirst_desc = desc;\n\t\telse {\n\t\t\tdbri->next_desc[last_desc] = desc;\n\t\t\tdbri->dma->desc[last_desc].nda =\n\t\t\t    dvma_addr + dbri_dma_off(desc, desc);\n\t\t}\n\n\t\tlast_desc = desc;\n\t\tdvma_buffer += mylen;\n\t\tlen -= mylen;\n\t}\n\n\tif (first_desc == -1 || last_desc == -1) {\n\t\tprintk(KERN_ERR \"DBRI: setup_descs: \"\n\t\t\t\" Not enough descriptors available\\n\");\n\t\treturn -1;\n\t}\n\n\tdbri->dma->desc[last_desc].nda =\n\t    dvma_addr + dbri_dma_off(desc, first_desc);\n\tdbri->next_desc[last_desc] = first_desc;\n\tdbri->pipes[info->pipe].first_desc = first_desc;\n\tdbri->pipes[info->pipe].desc = first_desc;\n\n#ifdef DBRI_DEBUG\n\tfor (desc = first_desc; desc != -1;) {\n\t\tdprintk(D_DESC, \"DESC %d: %08x %08x %08x %08x\\n\",\n\t\t\tdesc,\n\t\t\tdbri->dma->desc[desc].word1,\n\t\t\tdbri->dma->desc[desc].ba,\n\t\t\tdbri->dma->desc[desc].nda, dbri->dma->desc[desc].word4);\n\t\t\tdesc = dbri->next_desc[desc];\n\t\t\tif (desc == first_desc)\n\t\t\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\n \n\nenum master_or_slave { CHImaster, CHIslave };\n\n \nstatic void reset_chi(struct snd_dbri *dbri,\n\t\t      enum master_or_slave master_or_slave,\n\t\t      int bits_per_frame)\n{\n\ts32 *cmd;\n\tint val;\n\n\t \n\n\tcmd = dbri_cmdlock(dbri, 4);\n\tval = D_DTS_VO | D_DTS_VI | D_DTS_INS\n\t\t| D_DTS_PRVIN(16) | D_PIPE(16) | D_DTS_PRVOUT(16);\n\t*(cmd++) = DBRI_CMD(D_DTS, 0, val);\n\t*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);\n\t*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\tdbri_cmdsend(dbri, cmd, 4);\n\n\tdbri->pipes[16].sdp = 1;\n\tdbri->pipes[16].nextpipe = 16;\n\n\tcmd = dbri_cmdlock(dbri, 4);\n\n\tif (master_or_slave == CHIslave) {\n\t\t \n\t\t*(cmd++) = DBRI_CMD(D_CHI, 0, D_CHI_CHICM(0));\n\t} else {\n\t\t \n\t\tint clockrate = bits_per_frame * 8;\n\t\tint divisor = 12288 / clockrate;\n\n\t\tif (divisor > 255 || divisor * clockrate != 12288)\n\t\t\tprintk(KERN_ERR \"DBRI: illegal bits_per_frame \"\n\t\t\t\t\"in setup_chi\\n\");\n\n\t\t*(cmd++) = DBRI_CMD(D_CHI, 0, D_CHI_CHICM(divisor) | D_CHI_FD\n\t\t\t\t    | D_CHI_BPF(bits_per_frame));\n\t}\n\n\tdbri->chi_bpf = bits_per_frame;\n\n\t \n\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\t*(cmd++) = DBRI_CMD(D_CDM, 0, D_CDM_XCE | D_CDM_XEN | D_CDM_REN);\n\t*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\n\n\tdbri_cmdsend(dbri, cmd, 4);\n}\n\n \nstatic void cs4215_setup_pipes(struct snd_dbri *dbri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dbri->lock, flags);\n\t \n\n\tsetup_pipe(dbri, 4, D_SDP_MEM | D_SDP_TO_SER | D_SDP_MSB);\n\tsetup_pipe(dbri, 20, D_SDP_FIXED | D_SDP_TO_SER | D_SDP_MSB);\n\tsetup_pipe(dbri, 6, D_SDP_MEM | D_SDP_FROM_SER | D_SDP_MSB);\n\tsetup_pipe(dbri, 21, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\n\n\tsetup_pipe(dbri, 17, D_SDP_FIXED | D_SDP_TO_SER | D_SDP_MSB);\n\tsetup_pipe(dbri, 18, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\n\tsetup_pipe(dbri, 19, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\tdbri_cmdwait(dbri);\n}\n\nstatic int cs4215_init_data(struct cs4215 *mm)\n{\n\t \n\tmm->data[0] = CS4215_LO(0x20) | CS4215_HE | CS4215_LE;\n\tmm->data[1] = CS4215_RO(0x20) | CS4215_SE;\n\tmm->data[2] = CS4215_LG(0x8) | CS4215_IS | CS4215_PIO0 | CS4215_PIO1;\n\tmm->data[3] = CS4215_RG(0x8) | CS4215_MA(0xf);\n\n\t \n\tmm->ctrl[0] = CS4215_RSRVD_1 | CS4215_MLB;\n\tmm->ctrl[1] = CS4215_DFR_ULAW | CS4215_FREQ[0].csval;\n\tmm->ctrl[2] = CS4215_XCLK | CS4215_BSEL_128 | CS4215_FREQ[0].xtal;\n\tmm->ctrl[3] = 0;\n\n\tmm->status = 0;\n\tmm->version = 0xff;\n\tmm->precision = 8;\t \n\tmm->channels = 1;\n\n\treturn 0;\n}\n\nstatic void cs4215_setdata(struct snd_dbri *dbri, int muted)\n{\n\tif (muted) {\n\t\tdbri->mm.data[0] |= 63;\n\t\tdbri->mm.data[1] |= 63;\n\t\tdbri->mm.data[2] &= ~15;\n\t\tdbri->mm.data[3] &= ~15;\n\t} else {\n\t\t \n\t\tstruct dbri_streaminfo *info = &dbri->stream_info[DBRI_PLAY];\n\t\tint left_gain = info->left_gain & 0x3f;\n\t\tint right_gain = info->right_gain & 0x3f;\n\n\t\tdbri->mm.data[0] &= ~0x3f;\t \n\t\tdbri->mm.data[1] &= ~0x3f;\n\t\tdbri->mm.data[0] |= (DBRI_MAX_VOLUME - left_gain);\n\t\tdbri->mm.data[1] |= (DBRI_MAX_VOLUME - right_gain);\n\n\t\t \n\t\tinfo = &dbri->stream_info[DBRI_REC];\n\t\tleft_gain = info->left_gain & 0xf;\n\t\tright_gain = info->right_gain & 0xf;\n\t\tdbri->mm.data[2] |= CS4215_LG(left_gain);\n\t\tdbri->mm.data[3] |= CS4215_RG(right_gain);\n\t}\n\n\txmit_fixed(dbri, 20, *(int *)dbri->mm.data);\n}\n\n \nstatic void cs4215_open(struct snd_dbri *dbri)\n{\n\tint data_width;\n\tu32 tmp;\n\tunsigned long flags;\n\n\tdprintk(D_MM, \"cs4215_open: %d channels, %d bits\\n\",\n\t\tdbri->mm.channels, dbri->mm.precision);\n\n\t \n\n\tcs4215_setdata(dbri, 1);\n\tudelay(125);\n\n\t \n\tspin_lock_irqsave(&dbri->lock, flags);\n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp &= ~(D_C);\t\t \n\tsbus_writel(tmp, dbri->regs + REG0);\n\n\t \n\tsbus_writel(D_ENPIO | D_PIO1 | D_PIO3 |\n\t\t    (dbri->mm.onboard ? D_PIO0 : D_PIO2), dbri->regs + REG2);\n\n\treset_chi(dbri, CHIslave, 128);\n\n\t \n\tdata_width = dbri->mm.channels * dbri->mm.precision;\n\n\tlink_time_slot(dbri, 4, 16, 16, data_width, dbri->mm.offset);\n\tlink_time_slot(dbri, 20, 4, 16, 32, dbri->mm.offset + 32);\n\tlink_time_slot(dbri, 6, 16, 16, data_width, dbri->mm.offset);\n\tlink_time_slot(dbri, 21, 6, 16, 16, dbri->mm.offset + 40);\n\n\t \n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp |= D_C;\t\t \n\tsbus_writel(tmp, dbri->regs + REG0);\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\tcs4215_setdata(dbri, 0);\n}\n\n \nstatic int cs4215_setctrl(struct snd_dbri *dbri)\n{\n\tint i, val;\n\tu32 tmp;\n\tunsigned long flags;\n\n\t \n\n\t \n\tcs4215_setdata(dbri, 1);\n\tudelay(125);\n\n\t \n\tval = D_ENPIO | D_PIO1 | (dbri->mm.onboard ? D_PIO0 : D_PIO2);\n\tsbus_writel(val, dbri->regs + REG2);\n\tdprintk(D_MM, \"cs4215_setctrl: reg2=0x%x\\n\", val);\n\tudelay(34);\n\n\t \n\tspin_lock_irqsave(&dbri->lock, flags);\n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp &= ~D_C;\t\t \n\tsbus_writel(tmp, dbri->regs + REG0);\n\n\treset_chi(dbri, CHImaster, 128);\n\n\t \n\n\tlink_time_slot(dbri, 17, 16, 16, 32, dbri->mm.offset);\n\tlink_time_slot(dbri, 18, 16, 16, 8, dbri->mm.offset);\n\tlink_time_slot(dbri, 19, 18, 16, 8, dbri->mm.offset + 48);\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\t \n\tdbri->mm.ctrl[0] &= ~CS4215_CLB;\n\txmit_fixed(dbri, 17, *(int *)dbri->mm.ctrl);\n\n\tspin_lock_irqsave(&dbri->lock, flags);\n\ttmp = sbus_readl(dbri->regs + REG0);\n\ttmp |= D_C;\t\t \n\tsbus_writel(tmp, dbri->regs + REG0);\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\tfor (i = 10; ((dbri->mm.status & 0xe4) != 0x20); --i)\n\t\tmsleep_interruptible(1);\n\n\tif (i == 0) {\n\t\tdprintk(D_MM, \"CS4215 didn't respond to CLB (0x%02x)\\n\",\n\t\t\tdbri->mm.status);\n\t\treturn -1;\n\t}\n\n\t \n\trecv_fixed(dbri, 19, NULL);\n\n\t \n\tdbri->mm.ctrl[0] |= CS4215_CLB;\n\txmit_fixed(dbri, 17, *(int *)dbri->mm.ctrl);\n\n\t \n\tudelay(250);\n\n\tcs4215_setdata(dbri, 0);\n\n\treturn 0;\n}\n\n \nstatic int cs4215_prepare(struct snd_dbri *dbri, unsigned int rate,\n\t\t\t  snd_pcm_format_t format, unsigned int channels)\n{\n\tint freq_idx;\n\tint ret = 0;\n\n\t \n\tfor (freq_idx = 0; CS4215_FREQ[freq_idx].freq != 0; freq_idx++) {\n\t\tif (CS4215_FREQ[freq_idx].freq == rate)\n\t\t\tbreak;\n\t}\n\tif (CS4215_FREQ[freq_idx].freq != rate) {\n\t\tprintk(KERN_WARNING \"DBRI: Unsupported rate %d Hz\\n\", rate);\n\t\treturn -1;\n\t}\n\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tdbri->mm.ctrl[1] = CS4215_DFR_ULAW;\n\t\tdbri->mm.precision = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tdbri->mm.ctrl[1] = CS4215_DFR_ALAW;\n\t\tdbri->mm.precision = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_U8:\n\t\tdbri->mm.ctrl[1] = CS4215_DFR_LINEAR8;\n\t\tdbri->mm.precision = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tdbri->mm.ctrl[1] = CS4215_DFR_LINEAR16;\n\t\tdbri->mm.precision = 16;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"DBRI: Unsupported format %d\\n\", format);\n\t\treturn -1;\n\t}\n\n\t \n\tdbri->mm.ctrl[1] |= CS4215_FREQ[freq_idx].csval;\n\tdbri->mm.ctrl[2] = CS4215_XCLK |\n\t    CS4215_BSEL_128 | CS4215_FREQ[freq_idx].xtal;\n\n\tdbri->mm.channels = channels;\n\tif (channels == 2)\n\t\tdbri->mm.ctrl[1] |= CS4215_DFR_STEREO;\n\n\tret = cs4215_setctrl(dbri);\n\tif (ret == 0)\n\t\tcs4215_open(dbri);\t \n\n\treturn ret;\n}\n\n \nstatic int cs4215_init(struct snd_dbri *dbri)\n{\n\tu32 reg2 = sbus_readl(dbri->regs + REG2);\n\tdprintk(D_MM, \"cs4215_init: reg2=0x%x\\n\", reg2);\n\n\t \n\tif (reg2 & D_PIO2) {\n\t\tdprintk(D_MM, \"Onboard CS4215 detected\\n\");\n\t\tdbri->mm.onboard = 1;\n\t}\n\tif (reg2 & D_PIO0) {\n\t\tdprintk(D_MM, \"Speakerbox detected\\n\");\n\t\tdbri->mm.onboard = 0;\n\n\t\tif (reg2 & D_PIO2) {\n\t\t\tprintk(KERN_INFO \"DBRI: Using speakerbox / \"\n\t\t\t       \"ignoring onboard mmcodec.\\n\");\n\t\t\tsbus_writel(D_ENPIO2, dbri->regs + REG2);\n\t\t}\n\t}\n\n\tif (!(reg2 & (D_PIO0 | D_PIO2))) {\n\t\tprintk(KERN_ERR \"DBRI: no mmcodec found.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tcs4215_setup_pipes(dbri);\n\tcs4215_init_data(&dbri->mm);\n\n\t \n\trecv_fixed(dbri, 18, &dbri->mm.status);\n\trecv_fixed(dbri, 19, &dbri->mm.version);\n\n\tdbri->mm.offset = dbri->mm.onboard ? 0 : 8;\n\tif (cs4215_setctrl(dbri) == -1 || dbri->mm.version == 0xff) {\n\t\tdprintk(D_MM, \"CS4215 failed probe at offset %d\\n\",\n\t\t\tdbri->mm.offset);\n\t\treturn -EIO;\n\t}\n\tdprintk(D_MM, \"Found CS4215 at offset %d\\n\", dbri->mm.offset);\n\n\treturn 0;\n}\n\n \n\n \nstatic void xmit_descs(struct snd_dbri *dbri)\n{\n\tstruct dbri_streaminfo *info;\n\tu32 dvma_addr;\n\ts32 *cmd;\n\tunsigned long flags;\n\tint first_td;\n\n\tif (dbri == NULL)\n\t\treturn;\t\t \n\n\tdvma_addr = (u32)dbri->dma_dvma;\n\tinfo = &dbri->stream_info[DBRI_REC];\n\tspin_lock_irqsave(&dbri->lock, flags);\n\n\tif (info->pipe >= 0) {\n\t\tfirst_td = dbri->pipes[info->pipe].first_desc;\n\n\t\tdprintk(D_DESC, \"xmit_descs rec @ TD %d\\n\", first_td);\n\n\t\t \n\t\tif (first_td >= 0) {\n\t\t\tcmd = dbri_cmdlock(dbri, 2);\n\t\t\t*(cmd++) = DBRI_CMD(D_SDP, 0,\n\t\t\t\t\t    dbri->pipes[info->pipe].sdp\n\t\t\t\t\t    | D_SDP_P | D_SDP_EVERY | D_SDP_C);\n\t\t\t*(cmd++) = dvma_addr +\n\t\t\t\t   dbri_dma_off(desc, first_td);\n\t\t\tdbri_cmdsend(dbri, cmd, 2);\n\n\t\t\t \n\t\t\tdbri->pipes[info->pipe].desc = first_td;\n\t\t}\n\t}\n\n\tinfo = &dbri->stream_info[DBRI_PLAY];\n\n\tif (info->pipe >= 0) {\n\t\tfirst_td = dbri->pipes[info->pipe].first_desc;\n\n\t\tdprintk(D_DESC, \"xmit_descs play @ TD %d\\n\", first_td);\n\n\t\t \n\t\tif (first_td >= 0) {\n\t\t\tcmd = dbri_cmdlock(dbri, 2);\n\t\t\t*(cmd++) = DBRI_CMD(D_SDP, 0,\n\t\t\t\t\t    dbri->pipes[info->pipe].sdp\n\t\t\t\t\t    | D_SDP_P | D_SDP_EVERY | D_SDP_C);\n\t\t\t*(cmd++) = dvma_addr +\n\t\t\t\t   dbri_dma_off(desc, first_td);\n\t\t\tdbri_cmdsend(dbri, cmd, 2);\n\n\t\t\t \n\t\t\tdbri->pipes[info->pipe].desc = first_td;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n}\n\n \n\nstatic void transmission_complete_intr(struct snd_dbri *dbri, int pipe)\n{\n\tstruct dbri_streaminfo *info = &dbri->stream_info[DBRI_PLAY];\n\tint td = dbri->pipes[pipe].desc;\n\tint status;\n\n\twhile (td >= 0) {\n\t\tif (td >= DBRI_NO_DESCS) {\n\t\t\tprintk(KERN_ERR \"DBRI: invalid td on pipe %d\\n\", pipe);\n\t\t\treturn;\n\t\t}\n\n\t\tstatus = DBRI_TD_STATUS(dbri->dma->desc[td].word4);\n\t\tif (!(status & DBRI_TD_TBC))\n\t\t\tbreak;\n\n\t\tdprintk(D_INT, \"TD %d, status 0x%02x\\n\", td, status);\n\n\t\tdbri->dma->desc[td].word4 = 0;\t \n\t\tinfo->offset += DBRI_RD_CNT(dbri->dma->desc[td].word1);\n\n\t\ttd = dbri->next_desc[td];\n\t\tdbri->pipes[pipe].desc = td;\n\t}\n\n\t \n\tspin_unlock(&dbri->lock);\n\tsnd_pcm_period_elapsed(info->substream);\n\tspin_lock(&dbri->lock);\n}\n\nstatic void reception_complete_intr(struct snd_dbri *dbri, int pipe)\n{\n\tstruct dbri_streaminfo *info;\n\tint rd = dbri->pipes[pipe].desc;\n\ts32 status;\n\n\tif (rd < 0 || rd >= DBRI_NO_DESCS) {\n\t\tprintk(KERN_ERR \"DBRI: invalid rd on pipe %d\\n\", pipe);\n\t\treturn;\n\t}\n\n\tdbri->pipes[pipe].desc = dbri->next_desc[rd];\n\tstatus = dbri->dma->desc[rd].word1;\n\tdbri->dma->desc[rd].word1 = 0;\t \n\n\tinfo = &dbri->stream_info[DBRI_REC];\n\tinfo->offset += DBRI_RD_CNT(status);\n\n\t \n\n\tdprintk(D_INT, \"Recv RD %d, status 0x%02x, len %d\\n\",\n\t\trd, DBRI_RD_STATUS(status), DBRI_RD_CNT(status));\n\n\t \n\tspin_unlock(&dbri->lock);\n\tsnd_pcm_period_elapsed(info->substream);\n\tspin_lock(&dbri->lock);\n}\n\nstatic void dbri_process_one_interrupt(struct snd_dbri *dbri, int x)\n{\n\tint val = D_INTR_GETVAL(x);\n\tint channel = D_INTR_GETCHAN(x);\n\tint command = D_INTR_GETCMD(x);\n\tint code = D_INTR_GETCODE(x);\n#ifdef DBRI_DEBUG\n\tint rval = D_INTR_GETRVAL(x);\n#endif\n\n\tif (channel == D_INTR_CMD) {\n\t\tdprintk(D_CMD, \"INTR: Command: %-5s  Value:%d\\n\",\n\t\t\tcmds[command], val);\n\t} else {\n\t\tdprintk(D_INT, \"INTR: Chan:%d Code:%d Val:%#x\\n\",\n\t\t\tchannel, code, rval);\n\t}\n\n\tswitch (code) {\n\tcase D_INTR_CMDI:\n\t\tif (command != D_WAIT)\n\t\t\tprintk(KERN_ERR \"DBRI: Command read interrupt\\n\");\n\t\tbreak;\n\tcase D_INTR_BRDY:\n\t\treception_complete_intr(dbri, channel);\n\t\tbreak;\n\tcase D_INTR_XCMP:\n\tcase D_INTR_MINT:\n\t\ttransmission_complete_intr(dbri, channel);\n\t\tbreak;\n\tcase D_INTR_UNDR:\n\t\t \n\t\t{\n\t \n\t\t\tprintk(KERN_ERR \"DBRI: Underrun error\\n\");\n#if 0\n\t\t\ts32 *cmd;\n\t\t\tint pipe = channel;\n\t\t\tint td = dbri->pipes[pipe].desc;\n\n\t\t\tdbri->dma->desc[td].word4 = 0;\n\t\t\tcmd = dbri_cmdlock(dbri, NoGetLock);\n\t\t\t*(cmd++) = DBRI_CMD(D_SDP, 0,\n\t\t\t\t\t    dbri->pipes[pipe].sdp\n\t\t\t\t\t    | D_SDP_P | D_SDP_C | D_SDP_2SAME);\n\t\t\t*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, td);\n\t\t\tdbri_cmdsend(dbri, cmd);\n#endif\n\t\t}\n\t\tbreak;\n\tcase D_INTR_FXDT:\n\t\t \n\t\tif (dbri->pipes[channel].sdp & D_SDP_MSB)\n\t\t\tval = reverse_bytes(val, dbri->pipes[channel].length);\n\n\t\tif (dbri->pipes[channel].recv_fixed_ptr)\n\t\t\t*(dbri->pipes[channel].recv_fixed_ptr) = val;\n\t\tbreak;\n\tdefault:\n\t\tif (channel != D_INTR_CMD)\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"DBRI: Ignored Interrupt: %d (0x%x)\\n\", code, x);\n\t}\n}\n\n \nstatic void dbri_process_interrupt_buffer(struct snd_dbri *dbri)\n{\n\ts32 x;\n\n\twhile ((x = dbri->dma->intr[dbri->dbri_irqp]) != 0) {\n\t\tdbri->dma->intr[dbri->dbri_irqp] = 0;\n\t\tdbri->dbri_irqp++;\n\t\tif (dbri->dbri_irqp == DBRI_INT_BLK)\n\t\t\tdbri->dbri_irqp = 1;\n\n\t\tdbri_process_one_interrupt(dbri, x);\n\t}\n}\n\nstatic irqreturn_t snd_dbri_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_dbri *dbri = dev_id;\n\tstatic int errcnt;\n\tint x;\n\n\tif (dbri == NULL)\n\t\treturn IRQ_NONE;\n\tspin_lock(&dbri->lock);\n\n\t \n\tx = sbus_readl(dbri->regs + REG1);\n\n\tif (x & (D_MRR | D_MLE | D_LBG | D_MBE)) {\n\t\tu32 tmp;\n\n\t\tif (x & D_MRR)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"DBRI: Multiple Error Ack on SBus reg1=0x%x\\n\",\n\t\t\t       x);\n\t\tif (x & D_MLE)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"DBRI: Multiple Late Error on SBus reg1=0x%x\\n\",\n\t\t\t       x);\n\t\tif (x & D_LBG)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"DBRI: Lost Bus Grant on SBus reg1=0x%x\\n\", x);\n\t\tif (x & D_MBE)\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"DBRI: Burst Error on SBus reg1=0x%x\\n\", x);\n\n\t\t \n\t\tif ((++errcnt) % 10 == 0) {\n\t\t\tdprintk(D_INT, \"Interrupt errors exceeded.\\n\");\n\t\t\tdbri_reset(dbri);\n\t\t} else {\n\t\t\ttmp = sbus_readl(dbri->regs + REG0);\n\t\t\ttmp &= ~(D_D);\n\t\t\tsbus_writel(tmp, dbri->regs + REG0);\n\t\t}\n\t}\n\n\tdbri_process_interrupt_buffer(dbri);\n\n\tspin_unlock(&dbri->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const struct snd_pcm_hardware snd_dbri_pcm_hw = {\n\t.info\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t  SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t  SNDRV_PCM_INFO_BATCH,\n\t.formats\t= SNDRV_PCM_FMTBIT_MU_LAW |\n\t\t\t  SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t  SNDRV_PCM_FMTBIT_U8 |\n\t\t\t  SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates\t\t= SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_5512,\n\t.rate_min\t\t= 5512,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 64 * 1024,\n\t.period_bytes_min\t= 1,\n\t.period_bytes_max\t= DBRI_TD_MAXCNT,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 1024,\n};\n\nstatic int snd_hw_rule_format(struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask fmt;\n\n\tsnd_mask_any(&fmt);\n\tif (c->min > 1) {\n\t\tfmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_BE;\n\t\treturn snd_mask_refine(f, &fmt);\n\t}\n\treturn 0;\n}\n\nstatic int snd_hw_rule_channels(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *c = hw_param_interval(params,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_interval ch;\n\n\tsnd_interval_any(&ch);\n\tif (!(f->bits[0] & SNDRV_PCM_FMTBIT_S16_BE)) {\n\t\tch.min = 1;\n\t\tch.max = 1;\n\t\tch.integer = 1;\n\t\treturn snd_interval_refine(c, &ch);\n\t}\n\treturn 0;\n}\n\nstatic int snd_dbri_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tunsigned long flags;\n\n\tdprintk(D_USR, \"open audio output.\\n\");\n\truntime->hw = snd_dbri_pcm_hw;\n\n\tspin_lock_irqsave(&dbri->lock, flags);\n\tinfo->substream = substream;\n\tinfo->offset = 0;\n\tinfo->dvma_buffer = 0;\n\tinfo->pipe = -1;\n\tspin_unlock_irqrestore(&dbri->lock, flags);\n\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t    snd_hw_rule_format, NULL, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t    -1);\n\tsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t    snd_hw_rule_channels, NULL,\n\t\t\t    SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t    -1);\n\n\tcs4215_open(dbri);\n\n\treturn 0;\n}\n\nstatic int snd_dbri_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\n\tdprintk(D_USR, \"close audio output.\\n\");\n\tinfo->substream = NULL;\n\tinfo->offset = 0;\n\n\treturn 0;\n}\n\nstatic int snd_dbri_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tint direction;\n\tint ret;\n\n\t \n\tret = cs4215_prepare(dbri, params_rate(hw_params),\n\t\t\t     params_format(hw_params),\n\t\t\t     params_channels(hw_params));\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tif (info->dvma_buffer == 0) {\n\t\tif (DBRI_STREAMNO(substream) == DBRI_PLAY)\n\t\t\tdirection = DMA_TO_DEVICE;\n\t\telse\n\t\t\tdirection = DMA_FROM_DEVICE;\n\n\t\tinfo->dvma_buffer =\n\t\t\tdma_map_single(&dbri->op->dev,\n\t\t\t\t       runtime->dma_area,\n\t\t\t\t       params_buffer_bytes(hw_params),\n\t\t\t\t       direction);\n\t}\n\n\tdirection = params_buffer_bytes(hw_params);\n\tdprintk(D_USR, \"hw_params: %d bytes, dvma=%x\\n\",\n\t\tdirection, info->dvma_buffer);\n\treturn 0;\n}\n\nstatic int snd_dbri_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tint direction;\n\n\tdprintk(D_USR, \"hw_free.\\n\");\n\n\t \n\tif (info->dvma_buffer) {\n\t\tif (DBRI_STREAMNO(substream) == DBRI_PLAY)\n\t\t\tdirection = DMA_TO_DEVICE;\n\t\telse\n\t\t\tdirection = DMA_FROM_DEVICE;\n\n\t\tdma_unmap_single(&dbri->op->dev, info->dvma_buffer,\n\t\t\t\t substream->runtime->buffer_size, direction);\n\t\tinfo->dvma_buffer = 0;\n\t}\n\tif (info->pipe != -1) {\n\t\treset_pipe(dbri, info->pipe);\n\t\tinfo->pipe = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_dbri_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tint ret;\n\n\tinfo->size = snd_pcm_lib_buffer_bytes(substream);\n\tif (DBRI_STREAMNO(substream) == DBRI_PLAY)\n\t\tinfo->pipe = 4;\t \n\telse\n\t\tinfo->pipe = 6;\t \n\n\tspin_lock_irq(&dbri->lock);\n\tinfo->offset = 0;\n\n\t \n\tret = setup_descs(dbri, DBRI_STREAMNO(substream),\n\t\t\t  snd_pcm_lib_period_bytes(substream));\n\n\tspin_unlock_irq(&dbri->lock);\n\n\tdprintk(D_USR, \"prepare audio output. %d bytes\\n\", info->size);\n\treturn ret;\n}\n\nstatic int snd_dbri_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdprintk(D_USR, \"start audio, period is %d bytes\\n\",\n\t\t\t(int)snd_pcm_lib_period_bytes(substream));\n\t\t \n\t\txmit_descs(dbri);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdprintk(D_USR, \"stop audio.\\n\");\n\t\treset_pipe(dbri, info->pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t snd_dbri_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\n\tstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\n\tsnd_pcm_uframes_t ret;\n\n\tret = bytes_to_frames(substream->runtime, info->offset)\n\t\t% substream->runtime->buffer_size;\n\tdprintk(D_USR, \"I/O pointer: %ld frames of %ld.\\n\",\n\t\tret, substream->runtime->buffer_size);\n\treturn ret;\n}\n\nstatic const struct snd_pcm_ops snd_dbri_ops = {\n\t.open = snd_dbri_open,\n\t.close = snd_dbri_close,\n\t.hw_params = snd_dbri_hw_params,\n\t.hw_free = snd_dbri_hw_free,\n\t.prepare = snd_dbri_prepare,\n\t.trigger = snd_dbri_trigger,\n\t.pointer = snd_dbri_pointer,\n};\n\nstatic int snd_dbri_pcm(struct snd_card *card)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card,\n\t\t\t   \t    \"sun_dbri\",\n\t\t\t   \t    0,\n\t\t\t    1,\n\t\t\t     1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_dbri_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_dbri_ops);\n\n\tpcm->private_data = card->private_data;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, card->shortname);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 64 * 1024, 64 * 1024);\n\treturn 0;\n}\n\n \n\nstatic int snd_cs4215_info_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tif (kcontrol->private_value == DBRI_PLAY)\n\t\tuinfo->value.integer.max = DBRI_MAX_VOLUME;\n\telse\n\t\tuinfo->value.integer.max = DBRI_MAX_GAIN;\n\treturn 0;\n}\n\nstatic int snd_cs4215_get_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\n\tstruct dbri_streaminfo *info;\n\n\tif (snd_BUG_ON(!dbri))\n\t\treturn -EINVAL;\n\tinfo = &dbri->stream_info[kcontrol->private_value];\n\n\tucontrol->value.integer.value[0] = info->left_gain;\n\tucontrol->value.integer.value[1] = info->right_gain;\n\treturn 0;\n}\n\nstatic int snd_cs4215_put_volume(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\n\tstruct dbri_streaminfo *info =\n\t\t\t\t&dbri->stream_info[kcontrol->private_value];\n\tunsigned int vol[2];\n\tint changed = 0;\n\n\tvol[0] = ucontrol->value.integer.value[0];\n\tvol[1] = ucontrol->value.integer.value[1];\n\tif (kcontrol->private_value == DBRI_PLAY) {\n\t\tif (vol[0] > DBRI_MAX_VOLUME || vol[1] > DBRI_MAX_VOLUME)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (vol[0] > DBRI_MAX_GAIN || vol[1] > DBRI_MAX_GAIN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (info->left_gain != vol[0]) {\n\t\tinfo->left_gain = vol[0];\n\t\tchanged = 1;\n\t}\n\tif (info->right_gain != vol[1]) {\n\t\tinfo->right_gain = vol[1];\n\t\tchanged = 1;\n\t}\n\tif (changed) {\n\t\t \n\t\tcs4215_setdata(dbri, 1);\n\t\tudelay(125);\n\t\tcs4215_setdata(dbri, 0);\n\t}\n\treturn changed;\n}\n\nstatic int snd_cs4215_info_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = (mask == 1) ?\n\t    SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\treturn 0;\n}\n\nstatic int snd_cs4215_get_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\n\tint elem = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 1;\n\n\tif (snd_BUG_ON(!dbri))\n\t\treturn -EINVAL;\n\n\tif (elem < 4)\n\t\tucontrol->value.integer.value[0] =\n\t\t    (dbri->mm.data[elem] >> shift) & mask;\n\telse\n\t\tucontrol->value.integer.value[0] =\n\t\t    (dbri->mm.ctrl[elem - 4] >> shift) & mask;\n\n\tif (invert == 1)\n\t\tucontrol->value.integer.value[0] =\n\t\t    mask - ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int snd_cs4215_put_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\n\tint elem = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 1;\n\tint changed = 0;\n\tunsigned short val;\n\n\tif (snd_BUG_ON(!dbri))\n\t\treturn -EINVAL;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert == 1)\n\t\tval = mask - val;\n\tval <<= shift;\n\n\tif (elem < 4) {\n\t\tdbri->mm.data[elem] = (dbri->mm.data[elem] &\n\t\t\t\t       ~(mask << shift)) | val;\n\t\tchanged = (val != dbri->mm.data[elem]);\n\t} else {\n\t\tdbri->mm.ctrl[elem - 4] = (dbri->mm.ctrl[elem - 4] &\n\t\t\t\t\t   ~(mask << shift)) | val;\n\t\tchanged = (val != dbri->mm.ctrl[elem - 4]);\n\t}\n\n\tdprintk(D_GEN, \"put_single: mask=0x%x, changed=%d, \"\n\t\t\"mixer-value=%ld, mm-value=0x%x\\n\",\n\t\tmask, changed, ucontrol->value.integer.value[0],\n\t\tdbri->mm.data[elem & 3]);\n\n\tif (changed) {\n\t\t \n\t\tcs4215_setdata(dbri, 1);\n\t\tudelay(125);\n\t\tcs4215_setdata(dbri, 0);\n\t}\n\treturn changed;\n}\n\n \n#define CS4215_SINGLE(xname, entry, shift, mask, invert)\t\\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\t\t\\\n  .info = snd_cs4215_info_single,\t\t\t\t\\\n  .get = snd_cs4215_get_single, .put = snd_cs4215_put_single,\t\\\n  .private_value = (entry) | ((shift) << 8) | ((mask) << 16) |\t\\\n\t\t\t((invert) << 24) },\n\nstatic const struct snd_kcontrol_new dbri_controls[] = {\n\t{\n\t .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t .name  = \"Playback Volume\",\n\t .info  = snd_cs4215_info_volume,\n\t .get   = snd_cs4215_get_volume,\n\t .put   = snd_cs4215_put_volume,\n\t .private_value = DBRI_PLAY,\n\t },\n\tCS4215_SINGLE(\"Headphone switch\", 0, 7, 1, 0)\n\tCS4215_SINGLE(\"Line out switch\", 0, 6, 1, 0)\n\tCS4215_SINGLE(\"Speaker switch\", 1, 6, 1, 0)\n\t{\n\t .iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t .name  = \"Capture Volume\",\n\t .info  = snd_cs4215_info_volume,\n\t .get   = snd_cs4215_get_volume,\n\t .put   = snd_cs4215_put_volume,\n\t .private_value = DBRI_REC,\n\t },\n\t \n\tCS4215_SINGLE(\"Line in switch\", 2, 4, 1, 0)\n\tCS4215_SINGLE(\"High Pass Filter switch\", 5, 7, 1, 0)\n\tCS4215_SINGLE(\"Monitor Volume\", 3, 4, 0xf, 1)\n\tCS4215_SINGLE(\"Mic boost\", 4, 4, 1, 1)\n};\n\nstatic int snd_dbri_mixer(struct snd_card *card)\n{\n\tint idx, err;\n\tstruct snd_dbri *dbri;\n\n\tif (snd_BUG_ON(!card || !card->private_data))\n\t\treturn -EINVAL;\n\tdbri = card->private_data;\n\n\tstrcpy(card->mixername, card->shortname);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(dbri_controls); idx++) {\n\t\terr = snd_ctl_add(card,\n\t\t\t\tsnd_ctl_new1(&dbri_controls[idx], dbri));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tfor (idx = DBRI_REC; idx < DBRI_NO_STREAMS; idx++) {\n\t\tdbri->stream_info[idx].left_gain = 0;\n\t\tdbri->stream_info[idx].right_gain = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dbri_regs_read(struct snd_info_entry *entry,\n\t\t\t   struct snd_info_buffer *buffer)\n{\n\tstruct snd_dbri *dbri = entry->private_data;\n\n\tsnd_iprintf(buffer, \"REG0: 0x%x\\n\", sbus_readl(dbri->regs + REG0));\n\tsnd_iprintf(buffer, \"REG2: 0x%x\\n\", sbus_readl(dbri->regs + REG2));\n\tsnd_iprintf(buffer, \"REG8: 0x%x\\n\", sbus_readl(dbri->regs + REG8));\n\tsnd_iprintf(buffer, \"REG9: 0x%x\\n\", sbus_readl(dbri->regs + REG9));\n}\n\n#ifdef DBRI_DEBUG\nstatic void dbri_debug_read(struct snd_info_entry *entry,\n\t\t\t    struct snd_info_buffer *buffer)\n{\n\tstruct snd_dbri *dbri = entry->private_data;\n\tint pipe;\n\tsnd_iprintf(buffer, \"debug=%d\\n\", dbri_debug);\n\n\tfor (pipe = 0; pipe < 32; pipe++) {\n\t\tif (pipe_active(dbri, pipe)) {\n\t\t\tstruct dbri_pipe *pptr = &dbri->pipes[pipe];\n\t\t\tsnd_iprintf(buffer,\n\t\t\t\t    \"Pipe %d: %s SDP=0x%x desc=%d, \"\n\t\t\t\t    \"len=%d next %d\\n\",\n\t\t\t\t    pipe,\n\t\t\t\t   (pptr->sdp & D_SDP_TO_SER) ? \"output\" :\n\t\t\t\t\t\t\t\t \"input\",\n\t\t\t\t    pptr->sdp, pptr->desc,\n\t\t\t\t    pptr->length, pptr->nextpipe);\n\t\t}\n\t}\n}\n#endif\n\nstatic void snd_dbri_proc(struct snd_card *card)\n{\n\tstruct snd_dbri *dbri = card->private_data;\n\n\tsnd_card_ro_proc_new(card, \"regs\", dbri, dbri_regs_read);\n#ifdef DBRI_DEBUG\n\tsnd_card_ro_proc_new(card, \"debug\", dbri, dbri_debug_read);\n#endif\n}\n\n \nstatic void snd_dbri_free(struct snd_dbri *dbri);\n\nstatic int snd_dbri_create(struct snd_card *card,\n\t\t\t   struct platform_device *op,\n\t\t\t   int irq, int dev)\n{\n\tstruct snd_dbri *dbri = card->private_data;\n\tint err;\n\n\tspin_lock_init(&dbri->lock);\n\tdbri->op = op;\n\tdbri->irq = irq;\n\n\tdbri->dma = dma_alloc_coherent(&op->dev, sizeof(struct dbri_dma),\n\t\t\t\t       &dbri->dma_dvma, GFP_KERNEL);\n\tif (!dbri->dma)\n\t\treturn -ENOMEM;\n\n\tdprintk(D_GEN, \"DMA Cmd Block 0x%p (%pad)\\n\",\n\t\tdbri->dma, dbri->dma_dvma);\n\n\t \n\tdbri->regs_size = resource_size(&op->resource[0]);\n\tdbri->regs = of_ioremap(&op->resource[0], 0,\n\t\t\t\tdbri->regs_size, \"DBRI Registers\");\n\tif (!dbri->regs) {\n\t\tprintk(KERN_ERR \"DBRI: could not allocate registers\\n\");\n\t\tdma_free_coherent(&op->dev, sizeof(struct dbri_dma),\n\t\t\t\t  (void *)dbri->dma, dbri->dma_dvma);\n\t\treturn -EIO;\n\t}\n\n\terr = request_irq(dbri->irq, snd_dbri_interrupt, IRQF_SHARED,\n\t\t\t  \"DBRI audio\", dbri);\n\tif (err) {\n\t\tprintk(KERN_ERR \"DBRI: Can't get irq %d\\n\", dbri->irq);\n\t\tof_iounmap(&op->resource[0], dbri->regs, dbri->regs_size);\n\t\tdma_free_coherent(&op->dev, sizeof(struct dbri_dma),\n\t\t\t\t  (void *)dbri->dma, dbri->dma_dvma);\n\t\treturn err;\n\t}\n\n\t \n\tdbri_initialize(dbri);\n\terr = cs4215_init(dbri);\n\tif (err) {\n\t\tsnd_dbri_free(dbri);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void snd_dbri_free(struct snd_dbri *dbri)\n{\n\tdprintk(D_GEN, \"snd_dbri_free\\n\");\n\tdbri_reset(dbri);\n\n\tif (dbri->irq)\n\t\tfree_irq(dbri->irq, dbri);\n\n\tif (dbri->regs)\n\t\tof_iounmap(&dbri->op->resource[0], dbri->regs, dbri->regs_size);\n\n\tif (dbri->dma)\n\t\tdma_free_coherent(&dbri->op->dev,\n\t\t\t\t  sizeof(struct dbri_dma),\n\t\t\t\t  (void *)dbri->dma, dbri->dma_dvma);\n}\n\nstatic int dbri_probe(struct platform_device *op)\n{\n\tstruct snd_dbri *dbri;\n\tstruct resource *rp;\n\tstruct snd_card *card;\n\tstatic int dev;\n\tint irq;\n\tint err;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\tirq = op->archdata.irqs[0];\n\tif (irq <= 0) {\n\t\tprintk(KERN_ERR \"DBRI-%d: No IRQ.\\n\", dev);\n\t\treturn -ENODEV;\n\t}\n\n\terr = snd_card_new(&op->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct snd_dbri), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"DBRI\");\n\tstrcpy(card->shortname, \"Sun DBRI\");\n\trp = &op->resource[0];\n\tsprintf(card->longname, \"%s at 0x%02lx:0x%016Lx, irq %d\",\n\t\tcard->shortname,\n\t\trp->flags & 0xffL, (unsigned long long)rp->start, irq);\n\n\terr = snd_dbri_create(card, op, irq, dev);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\tdbri = card->private_data;\n\terr = snd_dbri_pcm(card);\n\tif (err < 0)\n\t\tgoto _err;\n\n\terr = snd_dbri_mixer(card);\n\tif (err < 0)\n\t\tgoto _err;\n\n\t \n\tsnd_dbri_proc(card);\n\tdev_set_drvdata(&op->dev, card);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto _err;\n\n\tprintk(KERN_INFO \"audio%d at %p (irq %d) is DBRI(%c)+CS4215(%d)\\n\",\n\t       dev, dbri->regs,\n\t       dbri->irq, op->dev.of_node->name[9], dbri->mm.version);\n\tdev++;\n\n\treturn 0;\n\n_err:\n\tsnd_dbri_free(dbri);\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic void dbri_remove(struct platform_device *op)\n{\n\tstruct snd_card *card = dev_get_drvdata(&op->dev);\n\n\tsnd_dbri_free(card->private_data);\n\tsnd_card_free(card);\n}\n\nstatic const struct of_device_id dbri_match[] = {\n\t{\n\t\t.name = \"SUNW,DBRIe\",\n\t},\n\t{\n\t\t.name = \"SUNW,DBRIf\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dbri_match);\n\nstatic struct platform_driver dbri_sbus_driver = {\n\t.driver = {\n\t\t.name = \"dbri\",\n\t\t.of_match_table = dbri_match,\n\t},\n\t.probe\t\t= dbri_probe,\n\t.remove_new\t= dbri_remove,\n};\n\nmodule_platform_driver(dbri_sbus_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}