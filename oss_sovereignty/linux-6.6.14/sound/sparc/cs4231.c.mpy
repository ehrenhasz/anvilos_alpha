{
  "module_name": "cs4231.c",
  "hash_id": "b29c1521cc1f3dff49f688ab46594a941458fb55b1a9e9c62340956e86425467",
  "original_prompt": "Ingested from linux-6.6.14/sound/sparc/cs4231.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/timer.h>\n#include <sound/initval.h>\n#include <sound/pcm_params.h>\n\n#ifdef CONFIG_SBUS\n#define SBUS_SUPPORT\n#endif\n\n#if defined(CONFIG_PCI) && defined(CONFIG_SPARC64)\n#define EBUS_SUPPORT\n#include <linux/pci.h>\n#include <asm/ebus_dma.h>\n#endif\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \n \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Sun CS4231 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Sun CS4231 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Sun CS4231 soundcard.\");\nMODULE_AUTHOR(\"Jaroslav Kysela, Derrick J. Brashear and David S. Miller\");\nMODULE_DESCRIPTION(\"Sun CS4231\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef SBUS_SUPPORT\nstruct sbus_dma_info {\n       spinlock_t\tlock;\t \n       int\t\tdir;\n       void __iomem\t*regs;\n};\n#endif\n\nstruct snd_cs4231;\nstruct cs4231_dma_control {\n\tvoid\t\t(*prepare)(struct cs4231_dma_control *dma_cont,\n\t\t\t\t   int dir);\n\tvoid\t\t(*enable)(struct cs4231_dma_control *dma_cont, int on);\n\tint\t\t(*request)(struct cs4231_dma_control *dma_cont,\n\t\t\t\t   dma_addr_t bus_addr, size_t len);\n\tunsigned int\t(*address)(struct cs4231_dma_control *dma_cont);\n#ifdef EBUS_SUPPORT\n\tstruct\t\tebus_dma_info\tebus_info;\n#endif\n#ifdef SBUS_SUPPORT\n\tstruct\t\tsbus_dma_info\tsbus_info;\n#endif\n};\n\nstruct snd_cs4231 {\n\tspinlock_t\t\tlock;\t \n\tvoid __iomem\t\t*port;\n\n\tstruct cs4231_dma_control\tp_dma;\n\tstruct cs4231_dma_control\tc_dma;\n\n\tu32\t\t\tflags;\n#define CS4231_FLAG_EBUS\t0x00000001\n#define CS4231_FLAG_PLAYBACK\t0x00000002\n#define CS4231_FLAG_CAPTURE\t0x00000004\n\n\tstruct snd_card\t\t*card;\n\tstruct snd_pcm\t\t*pcm;\n\tstruct snd_pcm_substream\t*playback_substream;\n\tunsigned int\t\tp_periods_sent;\n\tstruct snd_pcm_substream\t*capture_substream;\n\tunsigned int\t\tc_periods_sent;\n\tstruct snd_timer\t*timer;\n\n\tunsigned short mode;\n#define CS4231_MODE_NONE\t0x0000\n#define CS4231_MODE_PLAY\t0x0001\n#define CS4231_MODE_RECORD\t0x0002\n#define CS4231_MODE_TIMER\t0x0004\n#define CS4231_MODE_OPEN\t(CS4231_MODE_PLAY | CS4231_MODE_RECORD | \\\n\t\t\t\t CS4231_MODE_TIMER)\n\n\tunsigned char\t\timage[32];\t \n\tint\t\t\tmce_bit;\n\tint\t\t\tcalibrate_mute;\n\tstruct mutex\t\tmce_mutex;\t \n\tstruct mutex\t\topen_mutex;\t \n\n\tstruct platform_device\t*op;\n\tunsigned int\t\tirq[2];\n\tunsigned int\t\tregs_size;\n\tstruct snd_cs4231\t*next;\n};\n\n \n\n \n#include <sound/cs4231-regs.h>\n\n \n#define CS4231U(chip, x)\t((chip)->port + ((c_d_c_CS4231##x) << 2))\n\n \n\n#define APCCSR\t0x10UL\t \n#define APCCVA\t0x20UL\t \n#define APCCC\t0x24UL\t \n#define APCCNVA\t0x28UL\t \n#define APCCNC\t0x2cUL\t \n#define APCPVA\t0x30UL\t \n#define APCPC\t0x34UL\t \n#define APCPNVA\t0x38UL\t \n#define APCPNC\t0x3cUL\t \n\n \n\n#define APCVA  0x0UL\t \n#define APCC   0x4UL\t \n#define APCNVA 0x8UL\t \n#define APCNC  0xcUL\t \n#define APC_PLAY 0x30UL\t \n#define APC_RECORD 0x20UL  \n\n \n\n#define APC_INT_PENDING 0x800000  \n#define APC_PLAY_INT    0x400000  \n#define APC_CAPT_INT    0x200000  \n#define APC_GENL_INT    0x100000  \n#define APC_XINT_ENA    0x80000   \n#define APC_XINT_PLAY   0x40000   \n#define APC_XINT_CAPT   0x20000   \n#define APC_XINT_GENL   0x10000   \n#define APC_XINT_EMPT   0x8000    \n#define APC_XINT_PEMP   0x4000    \n#define APC_XINT_PNVA   0x2000    \n#define APC_XINT_PENA   0x1000    \n#define APC_XINT_COVF   0x800     \n#define APC_XINT_CNVA   0x400     \n#define APC_XINT_CEMP   0x200     \n#define APC_XINT_CENA   0x100     \n#define APC_PPAUSE      0x80      \n#define APC_CPAUSE      0x40      \n#define APC_CDC_RESET   0x20      \n#define APC_PDMA_READY  0x08      \n#define APC_CDMA_READY  0x04      \n#define APC_CHIP_RESET  0x01      \n\n \n\n#define EBDMA_CSR\t0x00UL\t \n#define EBDMA_ADDR\t0x04UL\t \n#define EBDMA_COUNT\t0x08UL\t \n\n \n\nstatic const unsigned char freq_bits[14] = {\n\t \t0x00 | CS4231_XTAL2,\n\t \t0x0E | CS4231_XTAL2,\n\t \t0x00 | CS4231_XTAL1,\n\t \t0x0E | CS4231_XTAL1,\n\t \t0x02 | CS4231_XTAL2,\n\t \t0x02 | CS4231_XTAL1,\n\t \t0x04 | CS4231_XTAL2,\n\t \t0x06 | CS4231_XTAL2,\n\t \t0x04 | CS4231_XTAL1,\n\t \t0x06 | CS4231_XTAL1,\n\t \t0x0C | CS4231_XTAL2,\n\t \t0x08 | CS4231_XTAL2,\n\t \t0x0A | CS4231_XTAL2,\n\t \t0x0C | CS4231_XTAL1\n};\n\nstatic const unsigned int rates[14] = {\n\t5510, 6620, 8000, 9600, 11025, 16000, 18900, 22050,\n\t27042, 32000, 33075, 37800, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list hw_constraints_rates = {\n\t.count\t= ARRAY_SIZE(rates),\n\t.list\t= rates,\n};\n\nstatic int snd_cs4231_xrate(struct snd_pcm_runtime *runtime)\n{\n\treturn snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &hw_constraints_rates);\n}\n\nstatic const unsigned char snd_cs4231_original_image[32] =\n{\n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0xbf,\t\t\t \n\t0xbf,\t\t\t \n\t0x20,\t\t\t \n\tCS4231_AUTOCALIB,\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\tCS4231_MODE2,\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x80,\t\t\t \n\t0x01,\t\t\t \n\t0x9f,\t\t\t \n\t0x9f,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x20,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n};\n\nstatic u8 __cs4231_readb(struct snd_cs4231 *cp, void __iomem *reg_addr)\n{\n\tif (cp->flags & CS4231_FLAG_EBUS)\n\t\treturn readb(reg_addr);\n\telse\n\t\treturn sbus_readb(reg_addr);\n}\n\nstatic void __cs4231_writeb(struct snd_cs4231 *cp, u8 val,\n\t\t\t    void __iomem *reg_addr)\n{\n\tif (cp->flags & CS4231_FLAG_EBUS)\n\t\treturn writeb(val, reg_addr);\n\telse\n\t\treturn sbus_writeb(val, reg_addr);\n}\n\n \n\nstatic void snd_cs4231_ready(struct snd_cs4231 *chip)\n{\n\tint timeout;\n\n\tfor (timeout = 250; timeout > 0; timeout--) {\n\t\tint val = __cs4231_readb(chip, CS4231U(chip, REGSEL));\n\t\tif ((val & CS4231_INIT) == 0)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n}\n\nstatic void snd_cs4231_dout(struct snd_cs4231 *chip, unsigned char reg,\n\t\t\t    unsigned char value)\n{\n\tsnd_cs4231_ready(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (__cs4231_readb(chip, CS4231U(chip, REGSEL)) & CS4231_INIT)\n\t\tsnd_printdd(\"out: auto calibration time out - reg = 0x%x, \"\n\t\t\t    \"value = 0x%x\\n\",\n\t\t\t    reg, value);\n#endif\n\t__cs4231_writeb(chip, chip->mce_bit | reg, CS4231U(chip, REGSEL));\n\twmb();\n\t__cs4231_writeb(chip, value, CS4231U(chip, REG));\n\tmb();\n}\n\nstatic inline void snd_cs4231_outm(struct snd_cs4231 *chip, unsigned char reg,\n\t\t     unsigned char mask, unsigned char value)\n{\n\tunsigned char tmp = (chip->image[reg] & mask) | value;\n\n\tchip->image[reg] = tmp;\n\tif (!chip->calibrate_mute)\n\t\tsnd_cs4231_dout(chip, reg, tmp);\n}\n\nstatic void snd_cs4231_out(struct snd_cs4231 *chip, unsigned char reg,\n\t\t\t   unsigned char value)\n{\n\tsnd_cs4231_dout(chip, reg, value);\n\tchip->image[reg] = value;\n\tmb();\n}\n\nstatic unsigned char snd_cs4231_in(struct snd_cs4231 *chip, unsigned char reg)\n{\n\tsnd_cs4231_ready(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (__cs4231_readb(chip, CS4231U(chip, REGSEL)) & CS4231_INIT)\n\t\tsnd_printdd(\"in: auto calibration time out - reg = 0x%x\\n\",\n\t\t\t    reg);\n#endif\n\t__cs4231_writeb(chip, chip->mce_bit | reg, CS4231U(chip, REGSEL));\n\tmb();\n\treturn __cs4231_readb(chip, CS4231U(chip, REG));\n}\n\n \n\nstatic void snd_cs4231_busy_wait(struct snd_cs4231 *chip)\n{\n\tint timeout;\n\n\t \n\tfor (timeout = 5; timeout > 0; timeout--)\n\t\t__cs4231_readb(chip, CS4231U(chip, REGSEL));\n\n\t \n\tfor (timeout = 500; timeout > 0; timeout--) {\n\t\tint val = __cs4231_readb(chip, CS4231U(chip, REGSEL));\n\t\tif ((val & CS4231_INIT) == 0)\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n}\n\nstatic void snd_cs4231_mce_up(struct snd_cs4231 *chip)\n{\n\tunsigned long flags;\n\tint timeout;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_ready(chip);\n#ifdef CONFIG_SND_DEBUG\n\tif (__cs4231_readb(chip, CS4231U(chip, REGSEL)) & CS4231_INIT)\n\t\tsnd_printdd(\"mce_up - auto calibration time out (0)\\n\");\n#endif\n\tchip->mce_bit |= CS4231_MCE;\n\ttimeout = __cs4231_readb(chip, CS4231U(chip, REGSEL));\n\tif (timeout == 0x80)\n\t\tsnd_printdd(\"mce_up [%p]: serious init problem - \"\n\t\t\t    \"codec still busy\\n\",\n\t\t\t    chip->port);\n\tif (!(timeout & CS4231_MCE))\n\t\t__cs4231_writeb(chip, chip->mce_bit | (timeout & 0x1f),\n\t\t\t\tCS4231U(chip, REGSEL));\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic void snd_cs4231_mce_down(struct snd_cs4231 *chip)\n{\n\tunsigned long flags, timeout;\n\tint reg;\n\n\tsnd_cs4231_busy_wait(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n#ifdef CONFIG_SND_DEBUG\n\tif (__cs4231_readb(chip, CS4231U(chip, REGSEL)) & CS4231_INIT)\n\t\tsnd_printdd(\"mce_down [%p] - auto calibration time out (0)\\n\",\n\t\t\t    CS4231U(chip, REGSEL));\n#endif\n\tchip->mce_bit &= ~CS4231_MCE;\n\treg = __cs4231_readb(chip, CS4231U(chip, REGSEL));\n\t__cs4231_writeb(chip, chip->mce_bit | (reg & 0x1f),\n\t\t\tCS4231U(chip, REGSEL));\n\tif (reg == 0x80)\n\t\tsnd_printdd(\"mce_down [%p]: serious init problem \"\n\t\t\t    \"- codec still busy\\n\", chip->port);\n\tif ((reg & CS4231_MCE) == 0) {\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(250);\n\tdo {\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\tmsleep(1);\n\t\tspin_lock_irqsave(&chip->lock, flags);\n\t\treg = snd_cs4231_in(chip, CS4231_TEST_INIT);\n\t\treg &= CS4231_CALIB_IN_PROGRESS;\n\t} while (reg && time_before(jiffies, timeout));\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tif (reg)\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"mce_down - auto calibration time out (2)\\n\");\n}\n\nstatic void snd_cs4231_advance_dma(struct cs4231_dma_control *dma_cont,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   unsigned int *periods_sent)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\twhile (1) {\n\t\tunsigned int period_size = snd_pcm_lib_period_bytes(substream);\n\t\tunsigned int offset = period_size * (*periods_sent);\n\n\t\tif (WARN_ON(period_size >= (1 << 24)))\n\t\t\treturn;\n\n\t\tif (dma_cont->request(dma_cont,\n\t\t\t\t      runtime->dma_addr + offset, period_size))\n\t\t\treturn;\n\t\t(*periods_sent) = ((*periods_sent) + 1) % runtime->periods;\n\t}\n}\n\nstatic void cs4231_dma_trigger(struct snd_pcm_substream *substream,\n\t\t\t       unsigned int what, int on)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct cs4231_dma_control *dma_cont;\n\n\tif (what & CS4231_PLAYBACK_ENABLE) {\n\t\tdma_cont = &chip->p_dma;\n\t\tif (on) {\n\t\t\tdma_cont->prepare(dma_cont, 0);\n\t\t\tdma_cont->enable(dma_cont, 1);\n\t\t\tsnd_cs4231_advance_dma(dma_cont,\n\t\t\t\tchip->playback_substream,\n\t\t\t\t&chip->p_periods_sent);\n\t\t} else {\n\t\t\tdma_cont->enable(dma_cont, 0);\n\t\t}\n\t}\n\tif (what & CS4231_RECORD_ENABLE) {\n\t\tdma_cont = &chip->c_dma;\n\t\tif (on) {\n\t\t\tdma_cont->prepare(dma_cont, 1);\n\t\t\tdma_cont->enable(dma_cont, 1);\n\t\t\tsnd_cs4231_advance_dma(dma_cont,\n\t\t\t\tchip->capture_substream,\n\t\t\t\t&chip->c_periods_sent);\n\t\t} else {\n\t\t\tdma_cont->enable(dma_cont, 0);\n\t\t}\n\t}\n}\n\nstatic int snd_cs4231_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tint result = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t{\n\t\tunsigned int what = 0;\n\t\tstruct snd_pcm_substream *s;\n\t\tunsigned long flags;\n\n\t\tsnd_pcm_group_for_each_entry(s, substream) {\n\t\t\tif (s == chip->playback_substream) {\n\t\t\t\twhat |= CS4231_PLAYBACK_ENABLE;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t} else if (s == chip->capture_substream) {\n\t\t\t\twhat |= CS4231_RECORD_ENABLE;\n\t\t\t\tsnd_pcm_trigger_done(s, substream);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&chip->lock, flags);\n\t\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\t\tcs4231_dma_trigger(substream, what, 1);\n\t\t\tchip->image[CS4231_IFACE_CTRL] |= what;\n\t\t} else {\n\t\t\tcs4231_dma_trigger(substream, what, 0);\n\t\t\tchip->image[CS4231_IFACE_CTRL] &= ~what;\n\t\t}\n\t\tsnd_cs4231_out(chip, CS4231_IFACE_CTRL,\n\t\t\t       chip->image[CS4231_IFACE_CTRL]);\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tresult = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\n \n\nstatic unsigned char snd_cs4231_get_rate(unsigned int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < 14; i++)\n\t\tif (rate == rates[i])\n\t\t\treturn freq_bits[i];\n\n\treturn freq_bits[13];\n}\n\nstatic unsigned char snd_cs4231_get_format(struct snd_cs4231 *chip, int format,\n\t\t\t\t\t   int channels)\n{\n\tunsigned char rformat;\n\n\trformat = CS4231_LINEAR_8;\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\trformat = CS4231_ULAW_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\trformat = CS4231_ALAW_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\trformat = CS4231_LINEAR_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\trformat = CS4231_LINEAR_16_BIG;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_IMA_ADPCM:\n\t\trformat = CS4231_ADPCM_16;\n\t\tbreak;\n\t}\n\tif (channels > 1)\n\t\trformat |= CS4231_STEREO;\n\treturn rformat;\n}\n\nstatic void snd_cs4231_calibrate_mute(struct snd_cs4231 *chip, int mute)\n{\n\tunsigned long flags;\n\n\tmute = mute ? 1 : 0;\n\tspin_lock_irqsave(&chip->lock, flags);\n\tif (chip->calibrate_mute == mute) {\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\treturn;\n\t}\n\tif (!mute) {\n\t\tsnd_cs4231_dout(chip, CS4231_LEFT_INPUT,\n\t\t\t\tchip->image[CS4231_LEFT_INPUT]);\n\t\tsnd_cs4231_dout(chip, CS4231_RIGHT_INPUT,\n\t\t\t\tchip->image[CS4231_RIGHT_INPUT]);\n\t\tsnd_cs4231_dout(chip, CS4231_LOOPBACK,\n\t\t\t\tchip->image[CS4231_LOOPBACK]);\n\t}\n\tsnd_cs4231_dout(chip, CS4231_AUX1_LEFT_INPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_AUX1_LEFT_INPUT]);\n\tsnd_cs4231_dout(chip, CS4231_AUX1_RIGHT_INPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_AUX1_RIGHT_INPUT]);\n\tsnd_cs4231_dout(chip, CS4231_AUX2_LEFT_INPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_AUX2_LEFT_INPUT]);\n\tsnd_cs4231_dout(chip, CS4231_AUX2_RIGHT_INPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_AUX2_RIGHT_INPUT]);\n\tsnd_cs4231_dout(chip, CS4231_LEFT_OUTPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_LEFT_OUTPUT]);\n\tsnd_cs4231_dout(chip, CS4231_RIGHT_OUTPUT,\n\t\t\tmute ? 0x80 : chip->image[CS4231_RIGHT_OUTPUT]);\n\tsnd_cs4231_dout(chip, CS4231_LEFT_LINE_IN,\n\t\t\tmute ? 0x80 : chip->image[CS4231_LEFT_LINE_IN]);\n\tsnd_cs4231_dout(chip, CS4231_RIGHT_LINE_IN,\n\t\t\tmute ? 0x80 : chip->image[CS4231_RIGHT_LINE_IN]);\n\tsnd_cs4231_dout(chip, CS4231_MONO_CTRL,\n\t\t\tmute ? 0xc0 : chip->image[CS4231_MONO_CTRL]);\n\tchip->calibrate_mute = mute;\n\tspin_unlock_irqrestore(&chip->lock, flags);\n}\n\nstatic void snd_cs4231_playback_format(struct snd_cs4231 *chip,\n\t\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t\t       unsigned char pdfr)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->mce_mutex);\n\tsnd_cs4231_calibrate_mute(chip, 1);\n\n\tsnd_cs4231_mce_up(chip);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t       (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE) ?\n\t\t       (pdfr & 0xf0) | (chip->image[CS4231_REC_FORMAT] & 0x0f) :\n\t\t       pdfr);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tsnd_cs4231_mce_down(chip);\n\n\tsnd_cs4231_calibrate_mute(chip, 0);\n\tmutex_unlock(&chip->mce_mutex);\n}\n\nstatic void snd_cs4231_capture_format(struct snd_cs4231 *chip,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      unsigned char cdfr)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->mce_mutex);\n\tsnd_cs4231_calibrate_mute(chip, 1);\n\n\tsnd_cs4231_mce_up(chip);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE)) {\n\t\tsnd_cs4231_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t\t       ((chip->image[CS4231_PLAYBK_FORMAT]) & 0xf0) |\n\t\t\t       (cdfr & 0x0f));\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\tsnd_cs4231_mce_down(chip);\n\t\tsnd_cs4231_mce_up(chip);\n\t\tspin_lock_irqsave(&chip->lock, flags);\n\t}\n\tsnd_cs4231_out(chip, CS4231_REC_FORMAT, cdfr);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tsnd_cs4231_mce_down(chip);\n\n\tsnd_cs4231_calibrate_mute(chip, 0);\n\tmutex_unlock(&chip->mce_mutex);\n}\n\n \n\nstatic unsigned long snd_cs4231_timer_resolution(struct snd_timer *timer)\n{\n\tstruct snd_cs4231 *chip = snd_timer_chip(timer);\n\n\treturn chip->image[CS4231_PLAYBK_FORMAT] & 1 ? 9969 : 9920;\n}\n\nstatic int snd_cs4231_timer_start(struct snd_timer *timer)\n{\n\tunsigned long flags;\n\tunsigned int ticks;\n\tstruct snd_cs4231 *chip = snd_timer_chip(timer);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tticks = timer->sticks;\n\tif ((chip->image[CS4231_ALT_FEATURE_1] & CS4231_TIMER_ENABLE) == 0 ||\n\t    (unsigned char)(ticks >> 8) != chip->image[CS4231_TIMER_HIGH] ||\n\t    (unsigned char)ticks != chip->image[CS4231_TIMER_LOW]) {\n\t\tsnd_cs4231_out(chip, CS4231_TIMER_HIGH,\n\t\t\t       chip->image[CS4231_TIMER_HIGH] =\n\t\t\t       (unsigned char) (ticks >> 8));\n\t\tsnd_cs4231_out(chip, CS4231_TIMER_LOW,\n\t\t\t       chip->image[CS4231_TIMER_LOW] =\n\t\t\t       (unsigned char) ticks);\n\t\tsnd_cs4231_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\t       chip->image[CS4231_ALT_FEATURE_1] |\n\t\t\t\t\tCS4231_TIMER_ENABLE);\n\t}\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_timer_stop(struct snd_timer *timer)\n{\n\tunsigned long flags;\n\tstruct snd_cs4231 *chip = snd_timer_chip(timer);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tchip->image[CS4231_ALT_FEATURE_1] &= ~CS4231_TIMER_ENABLE;\n\tsnd_cs4231_out(chip, CS4231_ALT_FEATURE_1,\n\t\t       chip->image[CS4231_ALT_FEATURE_1]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic void snd_cs4231_init(struct snd_cs4231 *chip)\n{\n\tunsigned long flags;\n\n\tsnd_cs4231_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printdd(\"init: (1)\\n\");\n#endif\n\tsnd_cs4231_mce_up(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |\n\t\t\t\t\t    CS4231_PLAYBACK_PIO |\n\t\t\t\t\t    CS4231_RECORD_ENABLE |\n\t\t\t\t\t    CS4231_RECORD_PIO |\n\t\t\t\t\t    CS4231_CALIB_MODE);\n\tchip->image[CS4231_IFACE_CTRL] |= CS4231_AUTOCALIB;\n\tsnd_cs4231_out(chip, CS4231_IFACE_CTRL, chip->image[CS4231_IFACE_CTRL]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tsnd_cs4231_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printdd(\"init: (2)\\n\");\n#endif\n\n\tsnd_cs4231_mce_up(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_ALT_FEATURE_1,\n\t\t\tchip->image[CS4231_ALT_FEATURE_1]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tsnd_cs4231_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printdd(\"init: (3) - afei = 0x%x\\n\",\n\t\t    chip->image[CS4231_ALT_FEATURE_1]);\n#endif\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_ALT_FEATURE_2,\n\t\t\tchip->image[CS4231_ALT_FEATURE_2]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tsnd_cs4231_mce_up(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_PLAYBK_FORMAT,\n\t\t\tchip->image[CS4231_PLAYBK_FORMAT]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tsnd_cs4231_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printdd(\"init: (4)\\n\");\n#endif\n\n\tsnd_cs4231_mce_up(chip);\n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_REC_FORMAT, chip->image[CS4231_REC_FORMAT]);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\tsnd_cs4231_mce_down(chip);\n\n#ifdef SNDRV_DEBUG_MCE\n\tsnd_printdd(\"init: (5)\\n\");\n#endif\n}\n\nstatic int snd_cs4231_open(struct snd_cs4231 *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->open_mutex);\n\tif ((chip->mode & mode)) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn -EAGAIN;\n\t}\n\tif (chip->mode & CS4231_MODE_OPEN) {\n\t\tchip->mode |= mode;\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn 0;\n\t}\n\t \n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, CS4231_PLAYBACK_IRQ |\n\t\t       CS4231_RECORD_IRQ |\n\t\t       CS4231_TIMER_IRQ);\n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, 0);\n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, CS4231_PLAYBACK_IRQ |\n\t\t       CS4231_RECORD_IRQ |\n\t\t       CS4231_TIMER_IRQ);\n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, 0);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tchip->mode = mode;\n\tmutex_unlock(&chip->open_mutex);\n\treturn 0;\n}\n\nstatic void snd_cs4231_close(struct snd_cs4231 *chip, unsigned int mode)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&chip->open_mutex);\n\tchip->mode &= ~mode;\n\tif (chip->mode & CS4231_MODE_OPEN) {\n\t\tmutex_unlock(&chip->open_mutex);\n\t\treturn;\n\t}\n\tsnd_cs4231_calibrate_mute(chip, 1);\n\n\t \n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, 0);\n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\n\t \n\n\tif (chip->image[CS4231_IFACE_CTRL] &\n\t    (CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\n\t     CS4231_RECORD_ENABLE | CS4231_RECORD_PIO)) {\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\tsnd_cs4231_mce_up(chip);\n\t\tspin_lock_irqsave(&chip->lock, flags);\n\t\tchip->image[CS4231_IFACE_CTRL] &=\n\t\t\t~(CS4231_PLAYBACK_ENABLE | CS4231_PLAYBACK_PIO |\n\t\t\t  CS4231_RECORD_ENABLE | CS4231_RECORD_PIO);\n\t\tsnd_cs4231_out(chip, CS4231_IFACE_CTRL,\n\t\t\t\tchip->image[CS4231_IFACE_CTRL]);\n\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\tsnd_cs4231_mce_down(chip);\n\t\tspin_lock_irqsave(&chip->lock, flags);\n\t}\n\n\t \n\tsnd_cs4231_out(chip, CS4231_IRQ_STATUS, 0);\n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\t \n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tsnd_cs4231_calibrate_mute(chip, 0);\n\n\tchip->mode = 0;\n\tmutex_unlock(&chip->open_mutex);\n}\n\n \n\nstatic int snd_cs4231_timer_open(struct snd_timer *timer)\n{\n\tstruct snd_cs4231 *chip = snd_timer_chip(timer);\n\tsnd_cs4231_open(chip, CS4231_MODE_TIMER);\n\treturn 0;\n}\n\nstatic int snd_cs4231_timer_close(struct snd_timer *timer)\n{\n\tstruct snd_cs4231 *chip = snd_timer_chip(timer);\n\tsnd_cs4231_close(chip, CS4231_MODE_TIMER);\n\treturn 0;\n}\n\nstatic const struct snd_timer_hardware snd_cs4231_timer_table = {\n\t.flags\t\t=\tSNDRV_TIMER_HW_AUTO,\n\t.resolution\t=\t9945,\n\t.ticks\t\t=\t65535,\n\t.open\t\t=\tsnd_cs4231_timer_open,\n\t.close\t\t=\tsnd_cs4231_timer_close,\n\t.c_resolution\t=\tsnd_cs4231_timer_resolution,\n\t.start\t\t=\tsnd_cs4231_timer_start,\n\t.stop\t\t=\tsnd_cs4231_timer_stop,\n};\n\n \n\nstatic int snd_cs4231_playback_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tunsigned char new_pdfr;\n\n\tnew_pdfr = snd_cs4231_get_format(chip, params_format(hw_params),\n\t\t\t\t\t params_channels(hw_params)) |\n\t\tsnd_cs4231_get_rate(params_rate(hw_params));\n\tsnd_cs4231_playback_format(chip, hw_params, new_pdfr);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_PLAYBACK_ENABLE |\n\t\t\t\t\t    CS4231_PLAYBACK_PIO);\n\n\tif (WARN_ON(runtime->period_size > 0xffff + 1)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tchip->p_periods_sent = 0;\n\nout:\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn ret;\n}\n\nstatic int snd_cs4231_capture_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tunsigned char new_cdfr;\n\n\tnew_cdfr = snd_cs4231_get_format(chip, params_format(hw_params),\n\t\t\t\t\t params_channels(hw_params)) |\n\t\tsnd_cs4231_get_rate(params_rate(hw_params));\n\tsnd_cs4231_capture_format(chip, hw_params, new_cdfr);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tchip->image[CS4231_IFACE_CTRL] &= ~(CS4231_RECORD_ENABLE |\n\t\t\t\t\t    CS4231_RECORD_PIO);\n\n\n\tchip->c_periods_sent = 0;\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic void snd_cs4231_overrange(struct snd_cs4231 *chip)\n{\n\tunsigned long flags;\n\tunsigned char res;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tres = snd_cs4231_in(chip, CS4231_TEST_INIT);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\t \n\tif (res & (0x08 | 0x02))\n\t\tchip->capture_substream->runtime->overrange++;\n}\n\nstatic void snd_cs4231_play_callback(struct snd_cs4231 *chip)\n{\n\tif (chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE) {\n\t\tsnd_pcm_period_elapsed(chip->playback_substream);\n\t\tsnd_cs4231_advance_dma(&chip->p_dma, chip->playback_substream,\n\t\t\t\t\t    &chip->p_periods_sent);\n\t}\n}\n\nstatic void snd_cs4231_capture_callback(struct snd_cs4231 *chip)\n{\n\tif (chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE) {\n\t\tsnd_pcm_period_elapsed(chip->capture_substream);\n\t\tsnd_cs4231_advance_dma(&chip->c_dma, chip->capture_substream,\n\t\t\t\t\t    &chip->c_periods_sent);\n\t}\n}\n\nstatic snd_pcm_uframes_t snd_cs4231_playback_pointer(\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct cs4231_dma_control *dma_cont = &chip->p_dma;\n\tsize_t ptr;\n\n\tif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_PLAYBACK_ENABLE))\n\t\treturn 0;\n\tptr = dma_cont->address(dma_cont);\n\tif (ptr != 0)\n\t\tptr -= substream->runtime->dma_addr;\n\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_cs4231_capture_pointer(\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct cs4231_dma_control *dma_cont = &chip->c_dma;\n\tsize_t ptr;\n\n\tif (!(chip->image[CS4231_IFACE_CTRL] & CS4231_RECORD_ENABLE))\n\t\treturn 0;\n\tptr = dma_cont->address(dma_cont);\n\tif (ptr != 0)\n\t\tptr -= substream->runtime->dma_addr;\n\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic int snd_cs4231_probe(struct snd_cs4231 *chip)\n{\n\tunsigned long flags;\n\tint i;\n\tint id = 0;\n\tint vers = 0;\n\tunsigned char *ptr;\n\n\tfor (i = 0; i < 50; i++) {\n\t\tmb();\n\t\tif (__cs4231_readb(chip, CS4231U(chip, REGSEL)) & CS4231_INIT)\n\t\t\tmsleep(2);\n\t\telse {\n\t\t\tspin_lock_irqsave(&chip->lock, flags);\n\t\t\tsnd_cs4231_out(chip, CS4231_MISC_INFO, CS4231_MODE2);\n\t\t\tid = snd_cs4231_in(chip, CS4231_MISC_INFO) & 0x0f;\n\t\t\tvers = snd_cs4231_in(chip, CS4231_VERSION);\n\t\t\tspin_unlock_irqrestore(&chip->lock, flags);\n\t\t\tif (id == 0x0a)\n\t\t\t\tbreak;\t \n\t\t}\n\t}\n\tsnd_printdd(\"cs4231: port = %p, id = 0x%x\\n\", chip->port, id);\n\tif (id != 0x0a)\n\t\treturn -ENODEV;\t \n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\t \n\t__cs4231_readb(chip, CS4231U(chip, STATUS));\n\t__cs4231_writeb(chip, 0, CS4231U(chip, STATUS));\n\tmb();\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tchip->image[CS4231_MISC_INFO] = CS4231_MODE2;\n\tchip->image[CS4231_IFACE_CTRL] =\n\t\tchip->image[CS4231_IFACE_CTRL] & ~CS4231_SINGLE_DMA;\n\tchip->image[CS4231_ALT_FEATURE_1] = 0x80;\n\tchip->image[CS4231_ALT_FEATURE_2] = 0x01;\n\tif (vers & 0x20)\n\t\tchip->image[CS4231_ALT_FEATURE_2] |= 0x02;\n\n\tptr = (unsigned char *) &chip->image;\n\n\tsnd_cs4231_mce_down(chip);\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tfor (i = 0; i < 32; i++)\t \n\t\tsnd_cs4231_out(chip, i, *ptr++);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tsnd_cs4231_mce_up(chip);\n\n\tsnd_cs4231_mce_down(chip);\n\n\tmdelay(2);\n\n\treturn 0;\t\t \n}\n\nstatic const struct snd_pcm_hardware snd_cs4231_playback = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_SYNC_START,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_MU_LAW |\n\t\t\t\t  SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t  SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t  SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates\t\t\t= SNDRV_PCM_RATE_KNOT |\n\t\t\t\t  SNDRV_PCM_RATE_8000_48000,\n\t.rate_min\t\t= 5510,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 32 * 1024,\n\t.period_bytes_min\t= 64,\n\t.period_bytes_max\t= 32 * 1024,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 1024,\n};\n\nstatic const struct snd_pcm_hardware snd_cs4231_capture = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_SYNC_START,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_MU_LAW |\n\t\t\t\t  SNDRV_PCM_FMTBIT_A_LAW |\n\t\t\t\t  SNDRV_PCM_FMTBIT_IMA_ADPCM |\n\t\t\t\t  SNDRV_PCM_FMTBIT_U8 |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S16_BE,\n\t.rates\t\t\t= SNDRV_PCM_RATE_KNOT |\n\t\t\t\t  SNDRV_PCM_RATE_8000_48000,\n\t.rate_min\t\t= 5510,\n\t.rate_max\t\t= 48000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 2,\n\t.buffer_bytes_max\t= 32 * 1024,\n\t.period_bytes_min\t= 64,\n\t.period_bytes_max\t= 32 * 1024,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 1024,\n};\n\nstatic int snd_cs4231_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->hw = snd_cs4231_playback;\n\n\terr = snd_cs4231_open(chip, CS4231_MODE_PLAY);\n\tif (err < 0)\n\t\treturn err;\n\tchip->playback_substream = substream;\n\tchip->p_periods_sent = 0;\n\tsnd_pcm_set_sync(substream);\n\tsnd_cs4231_xrate(runtime);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint err;\n\n\truntime->hw = snd_cs4231_capture;\n\n\terr = snd_cs4231_open(chip, CS4231_MODE_RECORD);\n\tif (err < 0)\n\t\treturn err;\n\tchip->capture_substream = substream;\n\tchip->c_periods_sent = 0;\n\tsnd_pcm_set_sync(substream);\n\tsnd_cs4231_xrate(runtime);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_cs4231_close(chip, CS4231_MODE_PLAY);\n\tchip->playback_substream = NULL;\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_cs4231 *chip = snd_pcm_substream_chip(substream);\n\n\tsnd_cs4231_close(chip, CS4231_MODE_RECORD);\n\tchip->capture_substream = NULL;\n\n\treturn 0;\n}\n\n \n\nstatic const struct snd_pcm_ops snd_cs4231_playback_ops = {\n\t.open\t\t=\tsnd_cs4231_playback_open,\n\t.close\t\t=\tsnd_cs4231_playback_close,\n\t.hw_params\t=\tsnd_cs4231_playback_hw_params,\n\t.prepare\t=\tsnd_cs4231_playback_prepare,\n\t.trigger\t=\tsnd_cs4231_trigger,\n\t.pointer\t=\tsnd_cs4231_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_cs4231_capture_ops = {\n\t.open\t\t=\tsnd_cs4231_capture_open,\n\t.close\t\t=\tsnd_cs4231_capture_close,\n\t.hw_params\t=\tsnd_cs4231_capture_hw_params,\n\t.prepare\t=\tsnd_cs4231_capture_prepare,\n\t.trigger\t=\tsnd_cs4231_trigger,\n\t.pointer\t=\tsnd_cs4231_capture_pointer,\n};\n\nstatic int snd_cs4231_pcm(struct snd_card *card)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\terr = snd_pcm_new(card, \"CS4231\", 0, 1, 1, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_cs4231_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t&snd_cs4231_capture_ops);\n\n\t \n\tpcm->private_data = chip;\n\tpcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\n\tstrcpy(pcm->name, \"CS4231\");\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       &chip->op->dev, 64 * 1024, 128 * 1024);\n\n\tchip->pcm = pcm;\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_timer(struct snd_card *card)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tstruct snd_timer *timer;\n\tstruct snd_timer_id tid;\n\tint err;\n\n\t \n\ttid.dev_class = SNDRV_TIMER_CLASS_CARD;\n\ttid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\n\ttid.card = card->number;\n\ttid.device = 0;\n\ttid.subdevice = 0;\n\terr = snd_timer_new(card, \"CS4231\", &tid, &timer);\n\tif (err < 0)\n\t\treturn err;\n\tstrcpy(timer->name, \"CS4231\");\n\ttimer->private_data = chip;\n\ttimer->hw = snd_cs4231_timer_table;\n\tchip->timer = timer;\n\n\treturn 0;\n}\n\n \n\nstatic int snd_cs4231_info_mux(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tstatic const char * const texts[4] = {\n\t\t\"Line\", \"CD\", \"Mic\", \"Mix\"\n\t};\n\n\treturn snd_ctl_enum_info(uinfo, 2, 4, texts);\n}\n\nstatic int snd_cs4231_get_mux(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\tucontrol->value.enumerated.item[0] =\n\t\t(chip->image[CS4231_LEFT_INPUT] & CS4231_MIXS_ALL) >> 6;\n\tucontrol->value.enumerated.item[1] =\n\t\t(chip->image[CS4231_RIGHT_INPUT] & CS4231_MIXS_ALL) >> 6;\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_put_mux(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tunsigned short left, right;\n\tint change;\n\n\tif (ucontrol->value.enumerated.item[0] > 3 ||\n\t    ucontrol->value.enumerated.item[1] > 3)\n\t\treturn -EINVAL;\n\tleft = ucontrol->value.enumerated.item[0] << 6;\n\tright = ucontrol->value.enumerated.item[1] << 6;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tleft = (chip->image[CS4231_LEFT_INPUT] & ~CS4231_MIXS_ALL) | left;\n\tright = (chip->image[CS4231_RIGHT_INPUT] & ~CS4231_MIXS_ALL) | right;\n\tchange = left != chip->image[CS4231_LEFT_INPUT] ||\n\t\t right != chip->image[CS4231_RIGHT_INPUT];\n\tsnd_cs4231_out(chip, CS4231_LEFT_INPUT, left);\n\tsnd_cs4231_out(chip, CS4231_RIGHT_INPUT, right);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn change;\n}\n\nstatic int snd_cs4231_info_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\n\tuinfo->type = (mask == 1) ?\n\t\tSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_get_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tucontrol->value.integer.value[0] = (chip->image[reg] >> shift) & mask;\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tif (invert)\n\t\tucontrol->value.integer.value[0] =\n\t\t\t(mask - ucontrol->value.integer.value[0]);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_put_single(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint reg = kcontrol->private_value & 0xff;\n\tint shift = (kcontrol->private_value >> 8) & 0xff;\n\tint mask = (kcontrol->private_value >> 16) & 0xff;\n\tint invert = (kcontrol->private_value >> 24) & 0xff;\n\tint change;\n\tunsigned short val;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tif (invert)\n\t\tval = mask - val;\n\tval <<= shift;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tval = (chip->image[reg] & ~(mask << shift)) | val;\n\tchange = val != chip->image[reg];\n\tsnd_cs4231_out(chip, reg, val);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn change;\n}\n\nstatic int snd_cs4231_info_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\n\tuinfo->type = mask == 1 ?\n\t\tSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = mask;\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_get_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tucontrol->value.integer.value[0] =\n\t\t(chip->image[left_reg] >> shift_left) & mask;\n\tucontrol->value.integer.value[1] =\n\t\t(chip->image[right_reg] >> shift_right) & mask;\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\tif (invert) {\n\t\tucontrol->value.integer.value[0] =\n\t\t\t(mask - ucontrol->value.integer.value[0]);\n\t\tucontrol->value.integer.value[1] =\n\t\t\t(mask - ucontrol->value.integer.value[1]);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_put_double(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_cs4231 *chip = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\tint left_reg = kcontrol->private_value & 0xff;\n\tint right_reg = (kcontrol->private_value >> 8) & 0xff;\n\tint shift_left = (kcontrol->private_value >> 16) & 0x07;\n\tint shift_right = (kcontrol->private_value >> 19) & 0x07;\n\tint mask = (kcontrol->private_value >> 24) & 0xff;\n\tint invert = (kcontrol->private_value >> 22) & 1;\n\tint change;\n\tunsigned short val1, val2;\n\n\tval1 = ucontrol->value.integer.value[0] & mask;\n\tval2 = ucontrol->value.integer.value[1] & mask;\n\tif (invert) {\n\t\tval1 = mask - val1;\n\t\tval2 = mask - val2;\n\t}\n\tval1 <<= shift_left;\n\tval2 <<= shift_right;\n\n\tspin_lock_irqsave(&chip->lock, flags);\n\n\tval1 = (chip->image[left_reg] & ~(mask << shift_left)) | val1;\n\tval2 = (chip->image[right_reg] & ~(mask << shift_right)) | val2;\n\tchange = val1 != chip->image[left_reg];\n\tchange |= val2 != chip->image[right_reg];\n\tsnd_cs4231_out(chip, left_reg, val1);\n\tsnd_cs4231_out(chip, right_reg, val2);\n\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn change;\n}\n\n#define CS4231_SINGLE(xname, xindex, reg, shift, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), .index = (xindex), \\\n  .info = snd_cs4231_info_single,\t\\\n  .get = snd_cs4231_get_single, .put = snd_cs4231_put_single,\t\\\n  .private_value = (reg) | ((shift) << 8) | ((mask) << 16) | ((invert) << 24) }\n\n#define CS4231_DOUBLE(xname, xindex, left_reg, right_reg, shift_left, \\\n\t\t\tshift_right, mask, invert) \\\n{ .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), .index = (xindex), \\\n  .info = snd_cs4231_info_double,\t\\\n  .get = snd_cs4231_get_double, .put = snd_cs4231_put_double,\t\\\n  .private_value = (left_reg) | ((right_reg) << 8) | ((shift_left) << 16) | \\\n\t\t   ((shift_right) << 19) | ((mask) << 24) | ((invert) << 22) }\n\nstatic const struct snd_kcontrol_new snd_cs4231_controls[] = {\nCS4231_DOUBLE(\"PCM Playback Switch\", 0, CS4231_LEFT_OUTPUT,\n\t\tCS4231_RIGHT_OUTPUT, 7, 7, 1, 1),\nCS4231_DOUBLE(\"PCM Playback Volume\", 0, CS4231_LEFT_OUTPUT,\n\t\tCS4231_RIGHT_OUTPUT, 0, 0, 63, 1),\nCS4231_DOUBLE(\"Line Playback Switch\", 0, CS4231_LEFT_LINE_IN,\n\t\tCS4231_RIGHT_LINE_IN, 7, 7, 1, 1),\nCS4231_DOUBLE(\"Line Playback Volume\", 0, CS4231_LEFT_LINE_IN,\n\t\tCS4231_RIGHT_LINE_IN, 0, 0, 31, 1),\nCS4231_DOUBLE(\"Aux Playback Switch\", 0, CS4231_AUX1_LEFT_INPUT,\n\t\tCS4231_AUX1_RIGHT_INPUT, 7, 7, 1, 1),\nCS4231_DOUBLE(\"Aux Playback Volume\", 0, CS4231_AUX1_LEFT_INPUT,\n\t\tCS4231_AUX1_RIGHT_INPUT, 0, 0, 31, 1),\nCS4231_DOUBLE(\"Aux Playback Switch\", 1, CS4231_AUX2_LEFT_INPUT,\n\t\tCS4231_AUX2_RIGHT_INPUT, 7, 7, 1, 1),\nCS4231_DOUBLE(\"Aux Playback Volume\", 1, CS4231_AUX2_LEFT_INPUT,\n\t\tCS4231_AUX2_RIGHT_INPUT, 0, 0, 31, 1),\nCS4231_SINGLE(\"Mono Playback Switch\", 0, CS4231_MONO_CTRL, 7, 1, 1),\nCS4231_SINGLE(\"Mono Playback Volume\", 0, CS4231_MONO_CTRL, 0, 15, 1),\nCS4231_SINGLE(\"Mono Output Playback Switch\", 0, CS4231_MONO_CTRL, 6, 1, 1),\nCS4231_SINGLE(\"Mono Output Playback Bypass\", 0, CS4231_MONO_CTRL, 5, 1, 0),\nCS4231_DOUBLE(\"Capture Volume\", 0, CS4231_LEFT_INPUT, CS4231_RIGHT_INPUT, 0, 0,\n\t\t15, 0),\n{\n\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name\t= \"Capture Source\",\n\t.info\t= snd_cs4231_info_mux,\n\t.get\t= snd_cs4231_get_mux,\n\t.put\t= snd_cs4231_put_mux,\n},\nCS4231_DOUBLE(\"Mic Boost\", 0, CS4231_LEFT_INPUT, CS4231_RIGHT_INPUT, 5, 5,\n\t\t1, 0),\nCS4231_SINGLE(\"Loopback Capture Switch\", 0, CS4231_LOOPBACK, 0, 1, 0),\nCS4231_SINGLE(\"Loopback Capture Volume\", 0, CS4231_LOOPBACK, 2, 63, 1),\n \nCS4231_SINGLE(\"Line Out Switch\", 0, CS4231_PIN_CTRL, 6, 1, 1),\nCS4231_SINGLE(\"Headphone Out Switch\", 0, CS4231_PIN_CTRL, 7, 1, 1)\n};\n\nstatic int snd_cs4231_mixer(struct snd_card *card)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tint err, idx;\n\n\tif (snd_BUG_ON(!chip || !chip->pcm))\n\t\treturn -EINVAL;\n\n\tstrcpy(card->mixername, chip->pcm->name);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(snd_cs4231_controls); idx++) {\n\t\terr = snd_ctl_add(card,\n\t\t\t\t snd_ctl_new1(&snd_cs4231_controls[idx], chip));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int dev;\n\nstatic int cs4231_attach_begin(struct platform_device *op,\n\t\t\t       struct snd_card **rcard)\n{\n\tstruct snd_card *card;\n\tstruct snd_cs4231 *chip;\n\tint err;\n\n\t*rcard = NULL;\n\n\tif (dev >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\n\tif (!enable[dev]) {\n\t\tdev++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&op->dev, index[dev], id[dev], THIS_MODULE,\n\t\t\t   sizeof(struct snd_cs4231), &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"CS4231\");\n\tstrcpy(card->shortname, \"Sun CS4231\");\n\n\tchip = card->private_data;\n\tchip->card = card;\n\n\t*rcard = card;\n\treturn 0;\n}\n\nstatic int cs4231_attach_finish(struct snd_card *card)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tint err;\n\n\terr = snd_cs4231_pcm(card);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = snd_cs4231_mixer(card);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = snd_cs4231_timer(card);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\tdev_set_drvdata(&chip->op->dev, chip);\n\n\tdev++;\n\treturn 0;\n\nout_err:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n#ifdef SBUS_SUPPORT\n\nstatic irqreturn_t snd_cs4231_sbus_interrupt(int irq, void *dev_id)\n{\n\tunsigned long flags;\n\tunsigned char status;\n\tu32 csr;\n\tstruct snd_cs4231 *chip = dev_id;\n\n\t \n\tif (!(__cs4231_readb(chip, CS4231U(chip, STATUS)) & CS4231_GLOBALIRQ))\n\t\treturn IRQ_NONE;\n\n\t \n\tcsr = sbus_readl(chip->port + APCCSR);\n\n\tsbus_writel(csr, chip->port + APCCSR);\n\n\tif ((csr & APC_PDMA_READY) &&\n\t    (csr & APC_PLAY_INT) &&\n\t    (csr & APC_XINT_PNVA) &&\n\t    !(csr & APC_XINT_EMPT))\n\t\t\tsnd_cs4231_play_callback(chip);\n\n\tif ((csr & APC_CDMA_READY) &&\n\t    (csr & APC_CAPT_INT) &&\n\t    (csr & APC_XINT_CNVA) &&\n\t    !(csr & APC_XINT_EMPT))\n\t\t\tsnd_cs4231_capture_callback(chip);\n\n\tstatus = snd_cs4231_in(chip, CS4231_IRQ_STATUS);\n\n\tif (status & CS4231_TIMER_IRQ) {\n\t\tif (chip->timer)\n\t\t\tsnd_timer_interrupt(chip->timer, chip->timer->sticks);\n\t}\n\n\tif ((status & CS4231_RECORD_IRQ) && (csr & APC_CDMA_READY))\n\t\tsnd_cs4231_overrange(chip);\n\n\t \n\tspin_lock_irqsave(&chip->lock, flags);\n\tsnd_cs4231_outm(chip, CS4231_IRQ_STATUS, ~CS4231_ALL_IRQS | ~status, 0);\n\tspin_unlock_irqrestore(&chip->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int sbus_dma_request(struct cs4231_dma_control *dma_cont,\n\t\t\t    dma_addr_t bus_addr, size_t len)\n{\n\tunsigned long flags;\n\tu32 test, csr;\n\tint err;\n\tstruct sbus_dma_info *base = &dma_cont->sbus_info;\n\n\tif (len >= (1 << 24))\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&base->lock, flags);\n\tcsr = sbus_readl(base->regs + APCCSR);\n\terr = -EINVAL;\n\ttest = APC_CDMA_READY;\n\tif (base->dir == APC_PLAY)\n\t\ttest = APC_PDMA_READY;\n\tif (!(csr & test))\n\t\tgoto out;\n\terr = -EBUSY;\n\ttest = APC_XINT_CNVA;\n\tif (base->dir == APC_PLAY)\n\t\ttest = APC_XINT_PNVA;\n\tif (!(csr & test))\n\t\tgoto out;\n\terr = 0;\n\tsbus_writel(bus_addr, base->regs + base->dir + APCNVA);\n\tsbus_writel(len, base->regs + base->dir + APCNC);\nout:\n\tspin_unlock_irqrestore(&base->lock, flags);\n\treturn err;\n}\n\nstatic void sbus_dma_prepare(struct cs4231_dma_control *dma_cont, int d)\n{\n\tunsigned long flags;\n\tu32 csr, test;\n\tstruct sbus_dma_info *base = &dma_cont->sbus_info;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tcsr = sbus_readl(base->regs + APCCSR);\n\ttest =  APC_GENL_INT | APC_PLAY_INT | APC_XINT_ENA |\n\t\tAPC_XINT_PLAY | APC_XINT_PEMP | APC_XINT_GENL |\n\t\t APC_XINT_PENA;\n\tif (base->dir == APC_RECORD)\n\t\ttest = APC_GENL_INT | APC_CAPT_INT | APC_XINT_ENA |\n\t\t\tAPC_XINT_CAPT | APC_XINT_CEMP | APC_XINT_GENL;\n\tcsr |= test;\n\tsbus_writel(csr, base->regs + APCCSR);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}\n\nstatic void sbus_dma_enable(struct cs4231_dma_control *dma_cont, int on)\n{\n\tunsigned long flags;\n\tu32 csr, shift;\n\tstruct sbus_dma_info *base = &dma_cont->sbus_info;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (!on) {\n\t\tsbus_writel(0, base->regs + base->dir + APCNC);\n\t\tsbus_writel(0, base->regs + base->dir + APCNVA);\n\t\tif (base->dir == APC_PLAY) {\n\t\t\tsbus_writel(0, base->regs + base->dir + APCC);\n\t\t\tsbus_writel(0, base->regs + base->dir + APCVA);\n\t\t}\n\n\t\tudelay(1200);\n\t}\n\tcsr = sbus_readl(base->regs + APCCSR);\n\tshift = 0;\n\tif (base->dir == APC_PLAY)\n\t\tshift = 1;\n\tif (on)\n\t\tcsr &= ~(APC_CPAUSE << shift);\n\telse\n\t\tcsr |= (APC_CPAUSE << shift);\n\tsbus_writel(csr, base->regs + APCCSR);\n\tif (on)\n\t\tcsr |= (APC_CDMA_READY << shift);\n\telse\n\t\tcsr &= ~(APC_CDMA_READY << shift);\n\tsbus_writel(csr, base->regs + APCCSR);\n\n\tspin_unlock_irqrestore(&base->lock, flags);\n}\n\nstatic unsigned int sbus_dma_addr(struct cs4231_dma_control *dma_cont)\n{\n\tstruct sbus_dma_info *base = &dma_cont->sbus_info;\n\n\treturn sbus_readl(base->regs + base->dir + APCVA);\n}\n\n \n\nstatic int snd_cs4231_sbus_free(struct snd_cs4231 *chip)\n{\n\tstruct platform_device *op = chip->op;\n\n\tif (chip->irq[0])\n\t\tfree_irq(chip->irq[0], chip);\n\n\tif (chip->port)\n\t\tof_iounmap(&op->resource[0], chip->port, chip->regs_size);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_sbus_dev_free(struct snd_device *device)\n{\n\tstruct snd_cs4231 *cp = device->device_data;\n\n\treturn snd_cs4231_sbus_free(cp);\n}\n\nstatic const struct snd_device_ops snd_cs4231_sbus_dev_ops = {\n\t.dev_free\t=\tsnd_cs4231_sbus_dev_free,\n};\n\nstatic int snd_cs4231_sbus_create(struct snd_card *card,\n\t\t\t\t  struct platform_device *op,\n\t\t\t\t  int dev)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tint err;\n\n\tspin_lock_init(&chip->lock);\n\tspin_lock_init(&chip->c_dma.sbus_info.lock);\n\tspin_lock_init(&chip->p_dma.sbus_info.lock);\n\tmutex_init(&chip->mce_mutex);\n\tmutex_init(&chip->open_mutex);\n\tchip->op = op;\n\tchip->regs_size = resource_size(&op->resource[0]);\n\tmemcpy(&chip->image, &snd_cs4231_original_image,\n\t       sizeof(snd_cs4231_original_image));\n\n\tchip->port = of_ioremap(&op->resource[0], 0,\n\t\t\t\tchip->regs_size, \"cs4231\");\n\tif (!chip->port) {\n\t\tsnd_printdd(\"cs4231-%d: Unable to map chip registers.\\n\", dev);\n\t\treturn -EIO;\n\t}\n\n\tchip->c_dma.sbus_info.regs = chip->port;\n\tchip->p_dma.sbus_info.regs = chip->port;\n\tchip->c_dma.sbus_info.dir = APC_RECORD;\n\tchip->p_dma.sbus_info.dir = APC_PLAY;\n\n\tchip->p_dma.prepare = sbus_dma_prepare;\n\tchip->p_dma.enable = sbus_dma_enable;\n\tchip->p_dma.request = sbus_dma_request;\n\tchip->p_dma.address = sbus_dma_addr;\n\n\tchip->c_dma.prepare = sbus_dma_prepare;\n\tchip->c_dma.enable = sbus_dma_enable;\n\tchip->c_dma.request = sbus_dma_request;\n\tchip->c_dma.address = sbus_dma_addr;\n\n\tif (request_irq(op->archdata.irqs[0], snd_cs4231_sbus_interrupt,\n\t\t\tIRQF_SHARED, \"cs4231\", chip)) {\n\t\tsnd_printdd(\"cs4231-%d: Unable to grab SBUS IRQ %d\\n\",\n\t\t\t    dev, op->archdata.irqs[0]);\n\t\tsnd_cs4231_sbus_free(chip);\n\t\treturn -EBUSY;\n\t}\n\tchip->irq[0] = op->archdata.irqs[0];\n\n\tif (snd_cs4231_probe(chip) < 0) {\n\t\tsnd_cs4231_sbus_free(chip);\n\t\treturn -ENODEV;\n\t}\n\tsnd_cs4231_init(chip);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\n\t\t\t     chip, &snd_cs4231_sbus_dev_ops);\n\tif (err < 0) {\n\t\tsnd_cs4231_sbus_free(chip);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs4231_sbus_probe(struct platform_device *op)\n{\n\tstruct resource *rp = &op->resource[0];\n\tstruct snd_card *card;\n\tint err;\n\n\terr = cs4231_attach_begin(op, &card);\n\tif (err)\n\t\treturn err;\n\n\tsprintf(card->longname, \"%s at 0x%02lx:0x%016Lx, irq %d\",\n\t\tcard->shortname,\n\t\trp->flags & 0xffL,\n\t\t(unsigned long long)rp->start,\n\t\top->archdata.irqs[0]);\n\n\terr = snd_cs4231_sbus_create(card, op, dev);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\treturn cs4231_attach_finish(card);\n}\n#endif\n\n#ifdef EBUS_SUPPORT\n\nstatic void snd_cs4231_ebus_play_callback(struct ebus_dma_info *p, int event,\n\t\t\t\t\t  void *cookie)\n{\n\tstruct snd_cs4231 *chip = cookie;\n\n\tsnd_cs4231_play_callback(chip);\n}\n\nstatic void snd_cs4231_ebus_capture_callback(struct ebus_dma_info *p,\n\t\t\t\t\t     int event, void *cookie)\n{\n\tstruct snd_cs4231 *chip = cookie;\n\n\tsnd_cs4231_capture_callback(chip);\n}\n\n \n\nstatic int _ebus_dma_request(struct cs4231_dma_control *dma_cont,\n\t\t\t     dma_addr_t bus_addr, size_t len)\n{\n\treturn ebus_dma_request(&dma_cont->ebus_info, bus_addr, len);\n}\n\nstatic void _ebus_dma_enable(struct cs4231_dma_control *dma_cont, int on)\n{\n\tebus_dma_enable(&dma_cont->ebus_info, on);\n}\n\nstatic void _ebus_dma_prepare(struct cs4231_dma_control *dma_cont, int dir)\n{\n\tebus_dma_prepare(&dma_cont->ebus_info, dir);\n}\n\nstatic unsigned int _ebus_dma_addr(struct cs4231_dma_control *dma_cont)\n{\n\treturn ebus_dma_addr(&dma_cont->ebus_info);\n}\n\n \n\nstatic int snd_cs4231_ebus_free(struct snd_cs4231 *chip)\n{\n\tstruct platform_device *op = chip->op;\n\n\tif (chip->c_dma.ebus_info.regs) {\n\t\tebus_dma_unregister(&chip->c_dma.ebus_info);\n\t\tof_iounmap(&op->resource[2], chip->c_dma.ebus_info.regs, 0x10);\n\t}\n\tif (chip->p_dma.ebus_info.regs) {\n\t\tebus_dma_unregister(&chip->p_dma.ebus_info);\n\t\tof_iounmap(&op->resource[1], chip->p_dma.ebus_info.regs, 0x10);\n\t}\n\n\tif (chip->port)\n\t\tof_iounmap(&op->resource[0], chip->port, 0x10);\n\n\treturn 0;\n}\n\nstatic int snd_cs4231_ebus_dev_free(struct snd_device *device)\n{\n\tstruct snd_cs4231 *cp = device->device_data;\n\n\treturn snd_cs4231_ebus_free(cp);\n}\n\nstatic const struct snd_device_ops snd_cs4231_ebus_dev_ops = {\n\t.dev_free\t=\tsnd_cs4231_ebus_dev_free,\n};\n\nstatic int snd_cs4231_ebus_create(struct snd_card *card,\n\t\t\t\t  struct platform_device *op,\n\t\t\t\t  int dev)\n{\n\tstruct snd_cs4231 *chip = card->private_data;\n\tint err;\n\n\tspin_lock_init(&chip->lock);\n\tspin_lock_init(&chip->c_dma.ebus_info.lock);\n\tspin_lock_init(&chip->p_dma.ebus_info.lock);\n\tmutex_init(&chip->mce_mutex);\n\tmutex_init(&chip->open_mutex);\n\tchip->flags |= CS4231_FLAG_EBUS;\n\tchip->op = op;\n\tmemcpy(&chip->image, &snd_cs4231_original_image,\n\t       sizeof(snd_cs4231_original_image));\n\tstrcpy(chip->c_dma.ebus_info.name, \"cs4231(capture)\");\n\tchip->c_dma.ebus_info.flags = EBUS_DMA_FLAG_USE_EBDMA_HANDLER;\n\tchip->c_dma.ebus_info.callback = snd_cs4231_ebus_capture_callback;\n\tchip->c_dma.ebus_info.client_cookie = chip;\n\tchip->c_dma.ebus_info.irq = op->archdata.irqs[0];\n\tstrcpy(chip->p_dma.ebus_info.name, \"cs4231(play)\");\n\tchip->p_dma.ebus_info.flags = EBUS_DMA_FLAG_USE_EBDMA_HANDLER;\n\tchip->p_dma.ebus_info.callback = snd_cs4231_ebus_play_callback;\n\tchip->p_dma.ebus_info.client_cookie = chip;\n\tchip->p_dma.ebus_info.irq = op->archdata.irqs[1];\n\n\tchip->p_dma.prepare = _ebus_dma_prepare;\n\tchip->p_dma.enable = _ebus_dma_enable;\n\tchip->p_dma.request = _ebus_dma_request;\n\tchip->p_dma.address = _ebus_dma_addr;\n\n\tchip->c_dma.prepare = _ebus_dma_prepare;\n\tchip->c_dma.enable = _ebus_dma_enable;\n\tchip->c_dma.request = _ebus_dma_request;\n\tchip->c_dma.address = _ebus_dma_addr;\n\n\tchip->port = of_ioremap(&op->resource[0], 0, 0x10, \"cs4231\");\n\tchip->p_dma.ebus_info.regs =\n\t\tof_ioremap(&op->resource[1], 0, 0x10, \"cs4231_pdma\");\n\tchip->c_dma.ebus_info.regs =\n\t\tof_ioremap(&op->resource[2], 0, 0x10, \"cs4231_cdma\");\n\tif (!chip->port || !chip->p_dma.ebus_info.regs ||\n\t    !chip->c_dma.ebus_info.regs) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\tsnd_printdd(\"cs4231-%d: Unable to map chip registers.\\n\", dev);\n\t\treturn -EIO;\n\t}\n\n\tif (ebus_dma_register(&chip->c_dma.ebus_info)) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\tsnd_printdd(\"cs4231-%d: Unable to register EBUS capture DMA\\n\",\n\t\t\t    dev);\n\t\treturn -EBUSY;\n\t}\n\tif (ebus_dma_irq_enable(&chip->c_dma.ebus_info, 1)) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\tsnd_printdd(\"cs4231-%d: Unable to enable EBUS capture IRQ\\n\",\n\t\t\t    dev);\n\t\treturn -EBUSY;\n\t}\n\n\tif (ebus_dma_register(&chip->p_dma.ebus_info)) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\tsnd_printdd(\"cs4231-%d: Unable to register EBUS play DMA\\n\",\n\t\t\t    dev);\n\t\treturn -EBUSY;\n\t}\n\tif (ebus_dma_irq_enable(&chip->p_dma.ebus_info, 1)) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\tsnd_printdd(\"cs4231-%d: Unable to enable EBUS play IRQ\\n\", dev);\n\t\treturn -EBUSY;\n\t}\n\n\tif (snd_cs4231_probe(chip) < 0) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\treturn -ENODEV;\n\t}\n\tsnd_cs4231_init(chip);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\n\t\t\t     chip, &snd_cs4231_ebus_dev_ops);\n\tif (err < 0) {\n\t\tsnd_cs4231_ebus_free(chip);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs4231_ebus_probe(struct platform_device *op)\n{\n\tstruct snd_card *card;\n\tint err;\n\n\terr = cs4231_attach_begin(op, &card);\n\tif (err)\n\t\treturn err;\n\n\tsprintf(card->longname, \"%s at 0x%llx, irq %d\",\n\t\tcard->shortname,\n\t\top->resource[0].start,\n\t\top->archdata.irqs[0]);\n\n\terr = snd_cs4231_ebus_create(card, op, dev);\n\tif (err < 0) {\n\t\tsnd_card_free(card);\n\t\treturn err;\n\t}\n\n\treturn cs4231_attach_finish(card);\n}\n#endif\n\nstatic int cs4231_probe(struct platform_device *op)\n{\n#ifdef EBUS_SUPPORT\n\tif (of_node_name_eq(op->dev.of_node->parent, \"ebus\"))\n\t\treturn cs4231_ebus_probe(op);\n#endif\n#ifdef SBUS_SUPPORT\n\tif (of_node_name_eq(op->dev.of_node->parent, \"sbus\") ||\n\t    of_node_name_eq(op->dev.of_node->parent, \"sbi\"))\n\t\treturn cs4231_sbus_probe(op);\n#endif\n\treturn -ENODEV;\n}\n\nstatic void cs4231_remove(struct platform_device *op)\n{\n\tstruct snd_cs4231 *chip = dev_get_drvdata(&op->dev);\n\n\tsnd_card_free(chip->card);\n}\n\nstatic const struct of_device_id cs4231_match[] = {\n\t{\n\t\t.name = \"SUNW,CS4231\",\n\t},\n\t{\n\t\t.name = \"audio\",\n\t\t.compatible = \"SUNW,CS4231\",\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cs4231_match);\n\nstatic struct platform_driver cs4231_driver = {\n\t.driver = {\n\t\t.name = \"audio\",\n\t\t.of_match_table = cs4231_match,\n\t},\n\t.probe\t\t= cs4231_probe,\n\t.remove_new\t= cs4231_remove,\n};\n\nmodule_platform_driver(cs4231_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}