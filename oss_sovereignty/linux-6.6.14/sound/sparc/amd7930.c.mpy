{
  "module_name": "amd7930.c",
  "hash_id": "a7e79050cb4e73404170f0c05a9616f931cfd653a240ac1a531b66f3353c262c",
  "original_prompt": "Ingested from linux-6.6.14/sound/sparc/amd7930.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/info.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n\n#include <asm/irq.h>\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t \nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t \nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;\t \n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for Sun AMD7930 soundcard.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for Sun AMD7930 soundcard.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable Sun AMD7930 soundcard.\");\nMODULE_AUTHOR(\"Thomas K. Dyas and David S. Miller\");\nMODULE_DESCRIPTION(\"Sun AMD7930\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \n#define AMD7930_CR\t0x00UL\t\t \n#define AMD7930_IR\tAMD7930_CR\t \n#define AMD7930_DR\t0x01UL\t\t \n#define AMD7930_DSR1\t0x02UL\t\t \n#define AMD7930_DER\t0x03UL\t\t \n#define AMD7930_DCTB\t0x04UL\t\t \n#define AMD7930_DCRB\tAMD7930_DCTB\t \n#define AMD7930_BBTB\t0x05UL\t\t \n#define AMD7930_BBRB\tAMD7930_BBTB\t \n#define AMD7930_BCTB\t0x06UL\t\t \n#define AMD7930_BCRB\tAMD7930_BCTB\t \n#define AMD7930_DSR2\t0x07UL\t\t \n\n \nstruct amd7930_map {\n\t__u16\tx[8];\n\t__u16\tr[8];\n\t__u16\tgx;\n\t__u16\tgr;\n\t__u16\tger;\n\t__u16\tstgr;\n\t__u16\tftgr;\n\t__u16\tatgr;\n\t__u8\tmmr1;\n\t__u8\tmmr2;\n};\n\n \n\n#define AMR_IR_DTTHRSH\t\t\t0x01  \n#define AMR_IR_DRTHRSH\t\t\t0x02  \n#define AMR_IR_DSRI\t\t\t0x04  \n#define AMR_IR_DERI\t\t\t0x08  \n#define AMR_IR_BBUF\t\t\t0x10  \n#define AMR_IR_LSRI\t\t\t0x20  \n#define AMR_IR_DSR2I\t\t\t0x40  \n#define AMR_IR_MLTFRMI\t\t\t0x80  \n\n \n\n \n#define\tAMR_INIT\t\t\t0x21\n#define\t\tAM_INIT_ACTIVE\t\t\t0x01\n#define\t\tAM_INIT_DATAONLY\t\t0x02\n#define\t\tAM_INIT_POWERDOWN\t\t0x03\n#define\t\tAM_INIT_DISABLE_INTS\t\t0x04\n#define AMR_INIT2\t\t\t0x20\n#define\t\tAM_INIT2_ENABLE_POWERDOWN\t0x20\n#define\t\tAM_INIT2_ENABLE_MULTIFRAME\t0x10\n\n \n#define\tAMR_LIU_LSR\t\t\t0xA1\n#define\t\tAM_LIU_LSR_STATE\t\t0x07\n#define\t\tAM_LIU_LSR_F3\t\t\t0x08\n#define\t\tAM_LIU_LSR_F7\t\t\t0x10\n#define\t\tAM_LIU_LSR_F8\t\t\t0x20\n#define\t\tAM_LIU_LSR_HSW\t\t\t0x40\n#define\t\tAM_LIU_LSR_HSW_CHG\t\t0x80\n#define\tAMR_LIU_LPR\t\t\t0xA2\n#define\tAMR_LIU_LMR1\t\t\t0xA3\n#define\t\tAM_LIU_LMR1_B1_ENABL\t\t0x01\n#define\t\tAM_LIU_LMR1_B2_ENABL\t\t0x02\n#define\t\tAM_LIU_LMR1_F_DISABL\t\t0x04\n#define\t\tAM_LIU_LMR1_FA_DISABL\t\t0x08\n#define\t\tAM_LIU_LMR1_REQ_ACTIV\t\t0x10\n#define\t\tAM_LIU_LMR1_F8_F3\t\t0x20\n#define\t\tAM_LIU_LMR1_LIU_ENABL\t\t0x40\n#define\tAMR_LIU_LMR2\t\t\t0xA4\n#define\t\tAM_LIU_LMR2_DECHO\t\t0x01\n#define\t\tAM_LIU_LMR2_DLOOP\t\t0x02\n#define\t\tAM_LIU_LMR2_DBACKOFF\t\t0x04\n#define\t\tAM_LIU_LMR2_EN_F3_INT\t\t0x08\n#define\t\tAM_LIU_LMR2_EN_F8_INT\t\t0x10\n#define\t\tAM_LIU_LMR2_EN_HSW_INT\t\t0x20\n#define\t\tAM_LIU_LMR2_EN_F7_INT\t\t0x40\n#define\tAMR_LIU_2_4\t\t\t0xA5\n#define\tAMR_LIU_MF\t\t\t0xA6\n#define\tAMR_LIU_MFSB\t\t\t0xA7\n#define\tAMR_LIU_MFQB\t\t\t0xA8\n\n \n#define\tAMR_MUX_MCR1\t\t\t0x41\n#define\tAMR_MUX_MCR2\t\t\t0x42\n#define\tAMR_MUX_MCR3\t\t\t0x43\n#define\t\tAM_MUX_CHANNEL_B1\t\t0x01\n#define\t\tAM_MUX_CHANNEL_B2\t\t0x02\n#define\t\tAM_MUX_CHANNEL_Ba\t\t0x03\n#define\t\tAM_MUX_CHANNEL_Bb\t\t0x04\n#define\t\tAM_MUX_CHANNEL_Bc\t\t0x05\n#define\t\tAM_MUX_CHANNEL_Bd\t\t0x06\n#define\t\tAM_MUX_CHANNEL_Be\t\t0x07\n#define\t\tAM_MUX_CHANNEL_Bf\t\t0x08\n#define\tAMR_MUX_MCR4\t\t\t0x44\n#define\t\tAM_MUX_MCR4_ENABLE_INTS\t\t0x08\n#define\t\tAM_MUX_MCR4_REVERSE_Bb\t\t0x10\n#define\t\tAM_MUX_MCR4_REVERSE_Bc\t\t0x20\n#define\tAMR_MUX_1_4\t\t\t0x45\n\n \n#define\tAMR_MAP_X\t\t\t0x61\n#define\tAMR_MAP_R\t\t\t0x62\n#define\tAMR_MAP_GX\t\t\t0x63\n#define\tAMR_MAP_GR\t\t\t0x64\n#define\tAMR_MAP_GER\t\t\t0x65\n#define\tAMR_MAP_STGR\t\t\t0x66\n#define\tAMR_MAP_FTGR_1_2\t\t0x67\n#define\tAMR_MAP_ATGR_1_2\t\t0x68\n#define\tAMR_MAP_MMR1\t\t\t0x69\n#define\t\tAM_MAP_MMR1_ALAW\t\t0x01\n#define\t\tAM_MAP_MMR1_GX\t\t\t0x02\n#define\t\tAM_MAP_MMR1_GR\t\t\t0x04\n#define\t\tAM_MAP_MMR1_GER\t\t\t0x08\n#define\t\tAM_MAP_MMR1_X\t\t\t0x10\n#define\t\tAM_MAP_MMR1_R\t\t\t0x20\n#define\t\tAM_MAP_MMR1_STG\t\t\t0x40\n#define\t\tAM_MAP_MMR1_LOOPBACK\t\t0x80\n#define\tAMR_MAP_MMR2\t\t\t0x6A\n#define\t\tAM_MAP_MMR2_AINB\t\t0x01\n#define\t\tAM_MAP_MMR2_LS\t\t\t0x02\n#define\t\tAM_MAP_MMR2_ENABLE_DTMF\t\t0x04\n#define\t\tAM_MAP_MMR2_ENABLE_TONEGEN\t0x08\n#define\t\tAM_MAP_MMR2_ENABLE_TONERING\t0x10\n#define\t\tAM_MAP_MMR2_DISABLE_HIGHPASS\t0x20\n#define\t\tAM_MAP_MMR2_DISABLE_AUTOZERO\t0x40\n#define\tAMR_MAP_1_10\t\t\t0x6B\n#define\tAMR_MAP_MMR3\t\t\t0x6C\n#define\tAMR_MAP_STRA\t\t\t0x6D\n#define\tAMR_MAP_STRF\t\t\t0x6E\n#define\tAMR_MAP_PEAKX\t\t\t0x70\n#define\tAMR_MAP_PEAKR\t\t\t0x71\n#define\tAMR_MAP_15_16\t\t\t0x72\n\n \n#define\tAMR_DLC_FRAR_1_2_3\t\t0x81\n#define\tAMR_DLC_SRAR_1_2_3\t\t0x82\n#define\tAMR_DLC_TAR\t\t\t0x83\n#define\tAMR_DLC_DRLR\t\t\t0x84\n#define\tAMR_DLC_DTCR\t\t\t0x85\n#define\tAMR_DLC_DMR1\t\t\t0x86\n#define\t\tAMR_DLC_DMR1_DTTHRSH_INT\t0x01\n#define\t\tAMR_DLC_DMR1_DRTHRSH_INT\t0x02\n#define\t\tAMR_DLC_DMR1_TAR_ENABL\t\t0x04\n#define\t\tAMR_DLC_DMR1_EORP_INT\t\t0x08\n#define\t\tAMR_DLC_DMR1_EN_ADDR1\t\t0x10\n#define\t\tAMR_DLC_DMR1_EN_ADDR2\t\t0x20\n#define\t\tAMR_DLC_DMR1_EN_ADDR3\t\t0x40\n#define\t\tAMR_DLC_DMR1_EN_ADDR4\t\t0x80\n#define\t\tAMR_DLC_DMR1_EN_ADDRS\t\t0xf0\n#define\tAMR_DLC_DMR2\t\t\t0x87\n#define\t\tAMR_DLC_DMR2_RABRT_INT\t\t0x01\n#define\t\tAMR_DLC_DMR2_RESID_INT\t\t0x02\n#define\t\tAMR_DLC_DMR2_COLL_INT\t\t0x04\n#define\t\tAMR_DLC_DMR2_FCS_INT\t\t0x08\n#define\t\tAMR_DLC_DMR2_OVFL_INT\t\t0x10\n#define\t\tAMR_DLC_DMR2_UNFL_INT\t\t0x20\n#define\t\tAMR_DLC_DMR2_OVRN_INT\t\t0x40\n#define\t\tAMR_DLC_DMR2_UNRN_INT\t\t0x80\n#define\tAMR_DLC_1_7\t\t\t0x88\n#define\tAMR_DLC_DRCR\t\t\t0x89\n#define\tAMR_DLC_RNGR1\t\t\t0x8A\n#define\tAMR_DLC_RNGR2\t\t\t0x8B\n#define\tAMR_DLC_FRAR4\t\t\t0x8C\n#define\tAMR_DLC_SRAR4\t\t\t0x8D\n#define\tAMR_DLC_DMR3\t\t\t0x8E\n#define\t\tAMR_DLC_DMR3_VA_INT\t\t0x01\n#define\t\tAMR_DLC_DMR3_EOTP_INT\t\t0x02\n#define\t\tAMR_DLC_DMR3_LBRP_INT\t\t0x04\n#define\t\tAMR_DLC_DMR3_RBA_INT\t\t0x08\n#define\t\tAMR_DLC_DMR3_LBT_INT\t\t0x10\n#define\t\tAMR_DLC_DMR3_TBE_INT\t\t0x20\n#define\t\tAMR_DLC_DMR3_RPLOST_INT\t\t0x40\n#define\t\tAMR_DLC_DMR3_KEEP_FCS\t\t0x80\n#define\tAMR_DLC_DMR4\t\t\t0x8F\n#define\t\tAMR_DLC_DMR4_RCV_1\t\t0x00\n#define\t\tAMR_DLC_DMR4_RCV_2\t\t0x01\n#define\t\tAMR_DLC_DMR4_RCV_4\t\t0x02\n#define\t\tAMR_DLC_DMR4_RCV_8\t\t0x03\n#define\t\tAMR_DLC_DMR4_RCV_16\t\t0x01\n#define\t\tAMR_DLC_DMR4_RCV_24\t\t0x02\n#define\t\tAMR_DLC_DMR4_RCV_30\t\t0x03\n#define\t\tAMR_DLC_DMR4_XMT_1\t\t0x00\n#define\t\tAMR_DLC_DMR4_XMT_2\t\t0x04\n#define\t\tAMR_DLC_DMR4_XMT_4\t\t0x08\n#define\t\tAMR_DLC_DMR4_XMT_8\t\t0x0c\n#define\t\tAMR_DLC_DMR4_XMT_10\t\t0x08\n#define\t\tAMR_DLC_DMR4_XMT_14\t\t0x0c\n#define\t\tAMR_DLC_DMR4_IDLE_MARK\t\t0x00\n#define\t\tAMR_DLC_DMR4_IDLE_FLAG\t\t0x10\n#define\t\tAMR_DLC_DMR4_ADDR_BOTH\t\t0x00\n#define\t\tAMR_DLC_DMR4_ADDR_1ST\t\t0x20\n#define\t\tAMR_DLC_DMR4_ADDR_2ND\t\t0xa0\n#define\t\tAMR_DLC_DMR4_CR_ENABLE\t\t0x40\n#define\tAMR_DLC_12_15\t\t\t0x90\n#define\tAMR_DLC_ASR\t\t\t0x91\n#define\tAMR_DLC_EFCR\t\t\t0x92\n#define\t\tAMR_DLC_EFCR_EXTEND_FIFO\t0x01\n#define\t\tAMR_DLC_EFCR_SEC_PKT_INT\t0x02\n\n#define AMR_DSR1_VADDR\t\t\t0x01\n#define AMR_DSR1_EORP\t\t\t0x02\n#define AMR_DSR1_PKT_IP\t\t\t0x04\n#define AMR_DSR1_DECHO_ON\t\t0x08\n#define AMR_DSR1_DLOOP_ON\t\t0x10\n#define AMR_DSR1_DBACK_OFF\t\t0x20\n#define AMR_DSR1_EOTP\t\t\t0x40\n#define AMR_DSR1_CXMT_ABRT\t\t0x80\n\n#define AMR_DSR2_LBRP\t\t\t0x01\n#define AMR_DSR2_RBA\t\t\t0x02\n#define AMR_DSR2_RPLOST\t\t\t0x04\n#define AMR_DSR2_LAST_BYTE\t\t0x08\n#define AMR_DSR2_TBE\t\t\t0x10\n#define AMR_DSR2_MARK_IDLE\t\t0x20\n#define AMR_DSR2_FLAG_IDLE\t\t0x40\n#define AMR_DSR2_SECOND_PKT\t\t0x80\n\n#define AMR_DER_RABRT\t\t\t0x01\n#define AMR_DER_RFRAME\t\t\t0x02\n#define AMR_DER_COLLISION\t\t0x04\n#define AMR_DER_FCS\t\t\t0x08\n#define AMR_DER_OVFL\t\t\t0x10\n#define AMR_DER_UNFL\t\t\t0x20\n#define AMR_DER_OVRN\t\t\t0x40\n#define AMR_DER_UNRN\t\t\t0x80\n\n \n#define\tAMR_PP_PPCR1\t\t\t0xC0\n#define\tAMR_PP_PPSR\t\t\t0xC1\n#define\tAMR_PP_PPIER\t\t\t0xC2\n#define\tAMR_PP_MTDR\t\t\t0xC3\n#define\tAMR_PP_MRDR\t\t\t0xC3\n#define\tAMR_PP_CITDR0\t\t\t0xC4\n#define\tAMR_PP_CIRDR0\t\t\t0xC4\n#define\tAMR_PP_CITDR1\t\t\t0xC5\n#define\tAMR_PP_CIRDR1\t\t\t0xC5\n#define\tAMR_PP_PPCR2\t\t\t0xC8\n#define\tAMR_PP_PPCR3\t\t\t0xC9\n\nstruct snd_amd7930 {\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*regs;\n\tu32\t\t\tflags;\n#define AMD7930_FLAG_PLAYBACK\t0x00000001\n#define AMD7930_FLAG_CAPTURE\t0x00000002\n\n\tstruct amd7930_map\tmap;\n\n\tstruct snd_card\t\t*card;\n\tstruct snd_pcm\t\t*pcm;\n\tstruct snd_pcm_substream\t*playback_substream;\n\tstruct snd_pcm_substream\t*capture_substream;\n\n\t \n\tunsigned char\t\t*p_orig, *p_cur;\n\tint\t\t\tp_left;\n\tunsigned char\t\t*c_orig, *c_cur;\n\tint\t\t\tc_left;\n\n\tint\t\t\trgain;\n\tint\t\t\tpgain;\n\tint\t\t\tmgain;\n\n\tstruct platform_device\t*op;\n\tunsigned int\t\tirq;\n\tstruct snd_amd7930\t*next;\n};\n\nstatic struct snd_amd7930 *amd7930_list;\n\n \nstatic __inline__ void amd7930_idle(struct snd_amd7930 *amd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\tsbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);\n\tsbus_writeb(0, amd->regs + AMD7930_DR);\n\tspin_unlock_irqrestore(&amd->lock, flags);\n}\n\n \nstatic __inline__ void amd7930_enable_ints(struct snd_amd7930 *amd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\tsbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);\n\tsbus_writeb(AM_INIT_ACTIVE, amd->regs + AMD7930_DR);\n\tspin_unlock_irqrestore(&amd->lock, flags);\n}\n\n \nstatic __inline__ void amd7930_disable_ints(struct snd_amd7930 *amd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\tsbus_writeb(AMR_INIT, amd->regs + AMD7930_CR);\n\tsbus_writeb(AM_INIT_ACTIVE | AM_INIT_DISABLE_INTS, amd->regs + AMD7930_DR);\n\tspin_unlock_irqrestore(&amd->lock, flags);\n}\n\n \nstatic void __amd7930_write_map(struct snd_amd7930 *amd)\n{\n\tstruct amd7930_map *map = &amd->map;\n\n\tsbus_writeb(AMR_MAP_GX, amd->regs + AMD7930_CR);\n\tsbus_writeb(((map->gx >> 0) & 0xff), amd->regs + AMD7930_DR);\n\tsbus_writeb(((map->gx >> 8) & 0xff), amd->regs + AMD7930_DR);\n\n\tsbus_writeb(AMR_MAP_GR, amd->regs + AMD7930_CR);\n\tsbus_writeb(((map->gr >> 0) & 0xff), amd->regs + AMD7930_DR);\n\tsbus_writeb(((map->gr >> 8) & 0xff), amd->regs + AMD7930_DR);\n\n\tsbus_writeb(AMR_MAP_STGR, amd->regs + AMD7930_CR);\n\tsbus_writeb(((map->stgr >> 0) & 0xff), amd->regs + AMD7930_DR);\n\tsbus_writeb(((map->stgr >> 8) & 0xff), amd->regs + AMD7930_DR);\n\n\tsbus_writeb(AMR_MAP_GER, amd->regs + AMD7930_CR);\n\tsbus_writeb(((map->ger >> 0) & 0xff), amd->regs + AMD7930_DR);\n\tsbus_writeb(((map->ger >> 8) & 0xff), amd->regs + AMD7930_DR);\n\n\tsbus_writeb(AMR_MAP_MMR1, amd->regs + AMD7930_CR);\n\tsbus_writeb(map->mmr1, amd->regs + AMD7930_DR);\n\n\tsbus_writeb(AMR_MAP_MMR2, amd->regs + AMD7930_CR);\n\tsbus_writeb(map->mmr2, amd->regs + AMD7930_DR);\n}\n\n \nstatic __const__ __u16 gx_coeff[256] = {\n\t0x9008, 0x8b7c, 0x8b51, 0x8b45, 0x8b42, 0x8b3b, 0x8b36, 0x8b33,\n\t0x8b32, 0x8b2a, 0x8b2b, 0x8b2c, 0x8b25, 0x8b23, 0x8b22, 0x8b22,\n\t0x9122, 0x8b1a, 0x8aa3, 0x8aa3, 0x8b1c, 0x8aa6, 0x912d, 0x912b,\n\t0x8aab, 0x8b12, 0x8aaa, 0x8ab2, 0x9132, 0x8ab4, 0x913c, 0x8abb,\n\t0x9142, 0x9144, 0x9151, 0x8ad5, 0x8aeb, 0x8a79, 0x8a5a, 0x8a4a,\n\t0x8b03, 0x91c2, 0x91bb, 0x8a3f, 0x8a33, 0x91b2, 0x9212, 0x9213,\n\t0x8a2c, 0x921d, 0x8a23, 0x921a, 0x9222, 0x9223, 0x922d, 0x9231,\n\t0x9234, 0x9242, 0x925b, 0x92dd, 0x92c1, 0x92b3, 0x92ab, 0x92a4,\n\t0x92a2, 0x932b, 0x9341, 0x93d3, 0x93b2, 0x93a2, 0x943c, 0x94b2,\n\t0x953a, 0x9653, 0x9782, 0x9e21, 0x9d23, 0x9cd2, 0x9c23, 0x9baa,\n\t0x9bde, 0x9b33, 0x9b22, 0x9b1d, 0x9ab2, 0xa142, 0xa1e5, 0x9a3b,\n\t0xa213, 0xa1a2, 0xa231, 0xa2eb, 0xa313, 0xa334, 0xa421, 0xa54b,\n\t0xada4, 0xac23, 0xab3b, 0xaaab, 0xaa5c, 0xb1a3, 0xb2ca, 0xb3bd,\n\t0xbe24, 0xbb2b, 0xba33, 0xc32b, 0xcb5a, 0xd2a2, 0xe31d, 0x0808,\n\t0x72ba, 0x62c2, 0x5c32, 0x52db, 0x513e, 0x4cce, 0x43b2, 0x4243,\n\t0x41b4, 0x3b12, 0x3bc3, 0x3df2, 0x34bd, 0x3334, 0x32c2, 0x3224,\n\t0x31aa, 0x2a7b, 0x2aaa, 0x2b23, 0x2bba, 0x2c42, 0x2e23, 0x25bb,\n\t0x242b, 0x240f, 0x231a, 0x22bb, 0x2241, 0x2223, 0x221f, 0x1a33,\n\t0x1a4a, 0x1acd, 0x2132, 0x1b1b, 0x1b2c, 0x1b62, 0x1c12, 0x1c32,\n\t0x1d1b, 0x1e71, 0x16b1, 0x1522, 0x1434, 0x1412, 0x1352, 0x1323,\n\t0x1315, 0x12bc, 0x127a, 0x1235, 0x1226, 0x11a2, 0x1216, 0x0a2a,\n\t0x11bc, 0x11d1, 0x1163, 0x0ac2, 0x0ab2, 0x0aab, 0x0b1b, 0x0b23,\n\t0x0b33, 0x0c0f, 0x0bb3, 0x0c1b, 0x0c3e, 0x0cb1, 0x0d4c, 0x0ec1,\n\t0x079a, 0x0614, 0x0521, 0x047c, 0x0422, 0x03b1, 0x03e3, 0x0333,\n\t0x0322, 0x031c, 0x02aa, 0x02ba, 0x02f2, 0x0242, 0x0232, 0x0227,\n\t0x0222, 0x021b, 0x01ad, 0x0212, 0x01b2, 0x01bb, 0x01cb, 0x01f6,\n\t0x0152, 0x013a, 0x0133, 0x0131, 0x012c, 0x0123, 0x0122, 0x00a2,\n\t0x011b, 0x011e, 0x0114, 0x00b1, 0x00aa, 0x00b3, 0x00bd, 0x00ba,\n\t0x00c5, 0x00d3, 0x00f3, 0x0062, 0x0051, 0x0042, 0x003b, 0x0033,\n\t0x0032, 0x002a, 0x002c, 0x0025, 0x0023, 0x0022, 0x001a, 0x0021,\n\t0x001b, 0x001b, 0x001d, 0x0015, 0x0013, 0x0013, 0x0012, 0x0012,\n\t0x000a, 0x000a, 0x0011, 0x0011, 0x000b, 0x000b, 0x000c, 0x000e,\n};\n\nstatic __const__ __u16 ger_coeff[] = {\n\t0x431f,  \n\t0x331f,  \n\t0x40dd,  \n\t0x11dd,  \n\t0x440f,  \n\t0x411f,  \n\t0x311f,  \n\t0x5520,  \n\t0x10dd,  \n\t0x4211,  \n\t0x410f,  \n\t0x111f,  \n\t0x600b,  \n\t0x00dd,  \n\t0x4210,  \n\t0x110f,  \n\t0x7200,  \n\t0x2110,  \n\t0x2200,  \n\t0x000b,  \n\t0x000f   \n};\n\n \nstatic void __amd7930_update_map(struct snd_amd7930 *amd)\n{\n\tstruct amd7930_map *map = &amd->map;\n\tint level;\n\n\tmap->gx = gx_coeff[amd->rgain];\n\tmap->stgr = gx_coeff[amd->mgain];\n\tlevel = (amd->pgain * (256 + ARRAY_SIZE(ger_coeff))) >> 8;\n\tif (level >= 256) {\n\t\tmap->ger = ger_coeff[level - 256];\n\t\tmap->gr = gx_coeff[255];\n\t} else {\n\t\tmap->ger = ger_coeff[0];\n\t\tmap->gr = gx_coeff[level];\n\t}\n\t__amd7930_write_map(amd);\n}\n\nstatic irqreturn_t snd_amd7930_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_amd7930 *amd = dev_id;\n\tunsigned int elapsed;\n\tu8 ir;\n\n\tspin_lock(&amd->lock);\n\n\telapsed = 0;\n\n\tir = sbus_readb(amd->regs + AMD7930_IR);\n\tif (ir & AMR_IR_BBUF) {\n\t\tu8 byte;\n\n\t\tif (amd->flags & AMD7930_FLAG_PLAYBACK) {\n\t\t\tif (amd->p_left > 0) {\n\t\t\t\tbyte = *(amd->p_cur++);\n\t\t\t\tamd->p_left--;\n\t\t\t\tsbus_writeb(byte, amd->regs + AMD7930_BBTB);\n\t\t\t\tif (amd->p_left == 0)\n\t\t\t\t\telapsed |= AMD7930_FLAG_PLAYBACK;\n\t\t\t} else\n\t\t\t\tsbus_writeb(0, amd->regs + AMD7930_BBTB);\n\t\t} else if (amd->flags & AMD7930_FLAG_CAPTURE) {\n\t\t\tbyte = sbus_readb(amd->regs + AMD7930_BBRB);\n\t\t\tif (amd->c_left > 0) {\n\t\t\t\t*(amd->c_cur++) = byte;\n\t\t\t\tamd->c_left--;\n\t\t\t\tif (amd->c_left == 0)\n\t\t\t\t\telapsed |= AMD7930_FLAG_CAPTURE;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&amd->lock);\n\n\tif (elapsed & AMD7930_FLAG_PLAYBACK)\n\t\tsnd_pcm_period_elapsed(amd->playback_substream);\n\telse\n\t\tsnd_pcm_period_elapsed(amd->capture_substream);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int snd_amd7930_trigger(struct snd_amd7930 *amd, unsigned int flag, int cmd)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\tif (cmd == SNDRV_PCM_TRIGGER_START) {\n\t\tif (!(amd->flags & flag)) {\n\t\t\tamd->flags |= flag;\n\n\t\t\t \n\t\t\tsbus_writeb(AMR_MUX_MCR4, amd->regs + AMD7930_CR);\n\t\t\tsbus_writeb(AM_MUX_MCR4_ENABLE_INTS, amd->regs + AMD7930_DR);\n\t\t}\n\t} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\n\t\tif (amd->flags & flag) {\n\t\t\tamd->flags &= ~flag;\n\n\t\t\t \n\t\t\tsbus_writeb(AMR_MUX_MCR4, amd->regs + AMD7930_CR);\n\t\t\tsbus_writeb(0, amd->regs + AMD7930_DR);\n\t\t}\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\tspin_unlock_irqrestore(&amd->lock, flags);\n\n\treturn result;\n}\n\nstatic int snd_amd7930_playback_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t\tint cmd)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\treturn snd_amd7930_trigger(amd, AMD7930_FLAG_PLAYBACK, cmd);\n}\n\nstatic int snd_amd7930_capture_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\treturn snd_amd7930_trigger(amd, AMD7930_FLAG_CAPTURE, cmd);\n}\n\nstatic int snd_amd7930_playback_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned long flags;\n\tu8 new_mmr1;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\n\tamd->flags |= AMD7930_FLAG_PLAYBACK;\n\n\t \n\tamd->p_orig = amd->p_cur = runtime->dma_area;\n\tamd->p_left = size;\n\n\t \n\tnew_mmr1 = amd->map.mmr1;\n\tif (runtime->format == SNDRV_PCM_FORMAT_A_LAW)\n\t\tnew_mmr1 |= AM_MAP_MMR1_ALAW;\n\telse\n\t\tnew_mmr1 &= ~AM_MAP_MMR1_ALAW;\n\tif (new_mmr1 != amd->map.mmr1) {\n\t\tamd->map.mmr1 = new_mmr1;\n\t\t__amd7930_update_map(amd);\n\t}\n\n\tspin_unlock_irqrestore(&amd->lock, flags);\n\n\treturn 0;\n}\n\nstatic int snd_amd7930_capture_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int size = snd_pcm_lib_buffer_bytes(substream);\n\tunsigned long flags;\n\tu8 new_mmr1;\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\n\tamd->flags |= AMD7930_FLAG_CAPTURE;\n\n\t \n\tamd->c_orig = amd->c_cur = runtime->dma_area;\n\tamd->c_left = size;\n\n\t \n\tnew_mmr1 = amd->map.mmr1;\n\tif (runtime->format == SNDRV_PCM_FORMAT_A_LAW)\n\t\tnew_mmr1 |= AM_MAP_MMR1_ALAW;\n\telse\n\t\tnew_mmr1 &= ~AM_MAP_MMR1_ALAW;\n\tif (new_mmr1 != amd->map.mmr1) {\n\t\tamd->map.mmr1 = new_mmr1;\n\t\t__amd7930_update_map(amd);\n\t}\n\n\tspin_unlock_irqrestore(&amd->lock, flags);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t snd_amd7930_playback_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(amd->flags & AMD7930_FLAG_PLAYBACK))\n\t\treturn 0;\n\tptr = amd->p_cur - amd->p_orig;\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\nstatic snd_pcm_uframes_t snd_amd7930_capture_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tsize_t ptr;\n\n\tif (!(amd->flags & AMD7930_FLAG_CAPTURE))\n\t\treturn 0;\n\n\tptr = amd->c_cur - amd->c_orig;\n\treturn bytes_to_frames(substream->runtime, ptr);\n}\n\n \nstatic const struct snd_pcm_hardware snd_amd7930_pcm_hw =\n{\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t   SNDRV_PCM_INFO_HALF_DUPLEX),\n\t.formats\t\t= SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t.rates\t\t\t= SNDRV_PCM_RATE_8000,\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 8000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= (64*1024),\n\t.period_bytes_min\t= 1,\n\t.period_bytes_max\t= (64*1024),\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 1024,\n};\n\nstatic int snd_amd7930_playback_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tamd->playback_substream = substream;\n\truntime->hw = snd_amd7930_pcm_hw;\n\treturn 0;\n}\n\nstatic int snd_amd7930_capture_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tamd->capture_substream = substream;\n\truntime->hw = snd_amd7930_pcm_hw;\n\treturn 0;\n}\n\nstatic int snd_amd7930_playback_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\n\tamd->playback_substream = NULL;\n\treturn 0;\n}\n\nstatic int snd_amd7930_capture_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_amd7930 *amd = snd_pcm_substream_chip(substream);\n\n\tamd->capture_substream = NULL;\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops snd_amd7930_playback_ops = {\n\t.open\t\t=\tsnd_amd7930_playback_open,\n\t.close\t\t=\tsnd_amd7930_playback_close,\n\t.prepare\t=\tsnd_amd7930_playback_prepare,\n\t.trigger\t=\tsnd_amd7930_playback_trigger,\n\t.pointer\t=\tsnd_amd7930_playback_pointer,\n};\n\nstatic const struct snd_pcm_ops snd_amd7930_capture_ops = {\n\t.open\t\t=\tsnd_amd7930_capture_open,\n\t.close\t\t=\tsnd_amd7930_capture_close,\n\t.prepare\t=\tsnd_amd7930_capture_prepare,\n\t.trigger\t=\tsnd_amd7930_capture_trigger,\n\t.pointer\t=\tsnd_amd7930_capture_pointer,\n};\n\nstatic int snd_amd7930_pcm(struct snd_amd7930 *amd)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\n\tif ((err = snd_pcm_new(amd->card,\n\t\t\t                     \"sun_amd7930\",\n\t\t\t                 0,\n\t\t\t         1,\n\t\t\t          1, &pcm)) < 0)\n\t\treturn err;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_amd7930_playback_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_amd7930_capture_ops);\n\n\tpcm->private_data = amd;\n\tpcm->info_flags = 0;\n\tstrcpy(pcm->name, amd->card->shortname);\n\tamd->pcm = pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 64*1024, 64*1024);\n\n\treturn 0;\n}\n\n#define VOLUME_MONITOR\t0\n#define VOLUME_CAPTURE\t1\n#define VOLUME_PLAYBACK\t2\n\nstatic int snd_amd7930_info_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 255;\n\n\treturn 0;\n}\n\nstatic int snd_amd7930_get_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_amd7930 *amd = snd_kcontrol_chip(kctl);\n\tint type = kctl->private_value;\n\tint *swval;\n\n\tswitch (type) {\n\tcase VOLUME_MONITOR:\n\t\tswval = &amd->mgain;\n\t\tbreak;\n\tcase VOLUME_CAPTURE:\n\t\tswval = &amd->rgain;\n\t\tbreak;\n\tcase VOLUME_PLAYBACK:\n\tdefault:\n\t\tswval = &amd->pgain;\n\t\tbreak;\n\t}\n\n\tucontrol->value.integer.value[0] = *swval;\n\n\treturn 0;\n}\n\nstatic int snd_amd7930_put_volume(struct snd_kcontrol *kctl, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_amd7930 *amd = snd_kcontrol_chip(kctl);\n\tunsigned long flags;\n\tint type = kctl->private_value;\n\tint *swval, change;\n\n\tswitch (type) {\n\tcase VOLUME_MONITOR:\n\t\tswval = &amd->mgain;\n\t\tbreak;\n\tcase VOLUME_CAPTURE:\n\t\tswval = &amd->rgain;\n\t\tbreak;\n\tcase VOLUME_PLAYBACK:\n\tdefault:\n\t\tswval = &amd->pgain;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\n\tif (*swval != ucontrol->value.integer.value[0]) {\n\t\t*swval = ucontrol->value.integer.value[0] & 0xff;\n\t\t__amd7930_update_map(amd);\n\t\tchange = 1;\n\t} else\n\t\tchange = 0;\n\n\tspin_unlock_irqrestore(&amd->lock, flags);\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new amd7930_controls[] = {\n\t{\n\t\t.iface\t\t=\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name\t\t=\t\"Monitor Volume\",\n\t\t.index\t\t=\t0,\n\t\t.info\t\t=\tsnd_amd7930_info_volume,\n\t\t.get\t\t=\tsnd_amd7930_get_volume,\n\t\t.put\t\t=\tsnd_amd7930_put_volume,\n\t\t.private_value\t=\tVOLUME_MONITOR,\n\t},\n\t{\n\t\t.iface\t\t=\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name\t\t=\t\"Capture Volume\",\n\t\t.index\t\t=\t0,\n\t\t.info\t\t=\tsnd_amd7930_info_volume,\n\t\t.get\t\t=\tsnd_amd7930_get_volume,\n\t\t.put\t\t=\tsnd_amd7930_put_volume,\n\t\t.private_value\t=\tVOLUME_CAPTURE,\n\t},\n\t{\n\t\t.iface\t\t=\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name\t\t=\t\"Playback Volume\",\n\t\t.index\t\t=\t0,\n\t\t.info\t\t=\tsnd_amd7930_info_volume,\n\t\t.get\t\t=\tsnd_amd7930_get_volume,\n\t\t.put\t\t=\tsnd_amd7930_put_volume,\n\t\t.private_value\t=\tVOLUME_PLAYBACK,\n\t},\n};\n\nstatic int snd_amd7930_mixer(struct snd_amd7930 *amd)\n{\n\tstruct snd_card *card;\n\tint idx, err;\n\n\tif (snd_BUG_ON(!amd || !amd->card))\n\t\treturn -EINVAL;\n\n\tcard = amd->card;\n\tstrcpy(card->mixername, card->shortname);\n\n\tfor (idx = 0; idx < ARRAY_SIZE(amd7930_controls); idx++) {\n\t\tif ((err = snd_ctl_add(card,\n\t\t\t\t       snd_ctl_new1(&amd7930_controls[idx], amd))) < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_amd7930_free(struct snd_amd7930 *amd)\n{\n\tstruct platform_device *op = amd->op;\n\n\tamd7930_idle(amd);\n\n\tif (amd->irq)\n\t\tfree_irq(amd->irq, amd);\n\n\tif (amd->regs)\n\t\tof_iounmap(&op->resource[0], amd->regs,\n\t\t\t   resource_size(&op->resource[0]));\n\n\tkfree(amd);\n\n\treturn 0;\n}\n\nstatic int snd_amd7930_dev_free(struct snd_device *device)\n{\n\tstruct snd_amd7930 *amd = device->device_data;\n\n\treturn snd_amd7930_free(amd);\n}\n\nstatic const struct snd_device_ops snd_amd7930_dev_ops = {\n\t.dev_free\t=\tsnd_amd7930_dev_free,\n};\n\nstatic int snd_amd7930_create(struct snd_card *card,\n\t\t\t      struct platform_device *op,\n\t\t\t      int irq, int dev,\n\t\t\t      struct snd_amd7930 **ramd)\n{\n\tstruct snd_amd7930 *amd;\n\tunsigned long flags;\n\tint err;\n\n\t*ramd = NULL;\n\tamd = kzalloc(sizeof(*amd), GFP_KERNEL);\n\tif (amd == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&amd->lock);\n\tamd->card = card;\n\tamd->op = op;\n\n\tamd->regs = of_ioremap(&op->resource[0], 0,\n\t\t\t       resource_size(&op->resource[0]), \"amd7930\");\n\tif (!amd->regs) {\n\t\tsnd_printk(KERN_ERR\n\t\t\t   \"amd7930-%d: Unable to map chip registers.\\n\", dev);\n\t\tkfree(amd);\n\t\treturn -EIO;\n\t}\n\n\tamd7930_idle(amd);\n\n\tif (request_irq(irq, snd_amd7930_interrupt,\n\t\t\tIRQF_SHARED, \"amd7930\", amd)) {\n\t\tsnd_printk(KERN_ERR \"amd7930-%d: Unable to grab IRQ %d\\n\",\n\t\t\t   dev, irq);\n\t\tsnd_amd7930_free(amd);\n\t\treturn -EBUSY;\n\t}\n\tamd->irq = irq;\n\n\tamd7930_enable_ints(amd);\n\n\tspin_lock_irqsave(&amd->lock, flags);\n\n\tamd->rgain = 128;\n\tamd->pgain = 200;\n\tamd->mgain = 0;\n\n\tmemset(&amd->map, 0, sizeof(amd->map));\n\tamd->map.mmr1 = (AM_MAP_MMR1_GX | AM_MAP_MMR1_GER |\n\t\t\t AM_MAP_MMR1_GR | AM_MAP_MMR1_STG);\n\tamd->map.mmr2 = (AM_MAP_MMR2_LS | AM_MAP_MMR2_AINB);\n\n\t__amd7930_update_map(amd);\n\n\t \n\tsbus_writeb(AMR_MUX_MCR1, amd->regs + AMD7930_CR);\n\tsbus_writeb(AM_MUX_CHANNEL_Ba | (AM_MUX_CHANNEL_Bb << 4),\n\t\t    amd->regs + AMD7930_DR);\n\n\tspin_unlock_irqrestore(&amd->lock, flags);\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\n\t\t\t     amd, &snd_amd7930_dev_ops);\n\tif (err < 0) {\n\t\tsnd_amd7930_free(amd);\n\t\treturn err;\n\t}\n\n\t*ramd = amd;\n\treturn 0;\n}\n\nstatic int amd7930_sbus_probe(struct platform_device *op)\n{\n\tstruct resource *rp = &op->resource[0];\n\tstatic int dev_num;\n\tstruct snd_card *card;\n\tstruct snd_amd7930 *amd;\n\tint err, irq;\n\n\tirq = op->archdata.irqs[0];\n\n\tif (dev_num >= SNDRV_CARDS)\n\t\treturn -ENODEV;\n\tif (!enable[dev_num]) {\n\t\tdev_num++;\n\t\treturn -ENOENT;\n\t}\n\n\terr = snd_card_new(&op->dev, index[dev_num], id[dev_num],\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\treturn err;\n\n\tstrcpy(card->driver, \"AMD7930\");\n\tstrcpy(card->shortname, \"Sun AMD7930\");\n\tsprintf(card->longname, \"%s at 0x%02lx:0x%08Lx, irq %d\",\n\t\tcard->shortname,\n\t\trp->flags & 0xffL,\n\t\t(unsigned long long)rp->start,\n\t\tirq);\n\n\tif ((err = snd_amd7930_create(card, op,\n\t\t\t\t      irq, dev_num, &amd)) < 0)\n\t\tgoto out_err;\n\n\terr = snd_amd7930_pcm(amd);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = snd_amd7930_mixer(amd);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\tamd->next = amd7930_list;\n\tamd7930_list = amd;\n\n\tdev_num++;\n\n\treturn 0;\n\nout_err:\n\tsnd_card_free(card);\n\treturn err;\n}\n\nstatic const struct of_device_id amd7930_match[] = {\n\t{\n\t\t.name = \"audio\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, amd7930_match);\n\nstatic struct platform_driver amd7930_sbus_driver = {\n\t.driver = {\n\t\t.name = \"audio\",\n\t\t.of_match_table = amd7930_match,\n\t},\n\t.probe\t\t= amd7930_sbus_probe,\n};\n\nstatic int __init amd7930_init(void)\n{\n\treturn platform_driver_register(&amd7930_sbus_driver);\n}\n\nstatic void __exit amd7930_exit(void)\n{\n\tstruct snd_amd7930 *p = amd7930_list;\n\n\twhile (p != NULL) {\n\t\tstruct snd_amd7930 *next = p->next;\n\n\t\tsnd_card_free(p->card);\n\n\t\tp = next;\n\t}\n\n\tamd7930_list = NULL;\n\n\tplatform_driver_unregister(&amd7930_sbus_driver);\n}\n\nmodule_init(amd7930_init);\nmodule_exit(amd7930_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}