{
  "module_name": "sh_dac_audio.c",
  "hash_id": "dcfa6f16eb7fe9873ddc2ed8a23c54a7334b6ea355c7e01b4813091a2195ebd6",
  "original_prompt": "Ingested from linux-6.6.14/sound/sh/sh_dac_audio.c",
  "human_readable_source": "\n \n\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/sh_dac_audio.h>\n#include <asm/clock.h>\n#include <asm/hd64461.h>\n#include <mach/hp6xx.h>\n#include <cpu/dac.h>\n\nMODULE_AUTHOR(\"Rafael Ignacio Zurita <rizurita@yahoo.com>\");\nMODULE_DESCRIPTION(\"SuperH DAC audio driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int index = SNDRV_DEFAULT_IDX1;\nstatic char *id = SNDRV_DEFAULT_STR1;\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for SuperH DAC audio.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for SuperH DAC audio.\");\n\n \nstruct snd_sh_dac {\n\tstruct snd_card *card;\n\tstruct snd_pcm_substream *substream;\n\tstruct hrtimer hrtimer;\n\tktime_t wakeups_per_second;\n\n\tint rate;\n\tint empty;\n\tchar *data_buffer, *buffer_begin, *buffer_end;\n\tint processed;  \n\tint buffer_size;\n\tstruct dac_audio_pdata *pdata;\n};\n\n\nstatic void dac_audio_start_timer(struct snd_sh_dac *chip)\n{\n\thrtimer_start(&chip->hrtimer, chip->wakeups_per_second,\n\t\t      HRTIMER_MODE_REL);\n}\n\nstatic void dac_audio_stop_timer(struct snd_sh_dac *chip)\n{\n\thrtimer_cancel(&chip->hrtimer);\n}\n\nstatic void dac_audio_reset(struct snd_sh_dac *chip)\n{\n\tdac_audio_stop_timer(chip);\n\tchip->buffer_begin = chip->buffer_end = chip->data_buffer;\n\tchip->processed = 0;\n\tchip->empty = 1;\n}\n\nstatic void dac_audio_set_rate(struct snd_sh_dac *chip)\n{\n\tchip->wakeups_per_second = 1000000000 / chip->rate;\n}\n\n\n \n\nstatic const struct snd_pcm_hardware snd_sh_dac_pcm_hw = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_HALF_DUPLEX),\n\t.formats\t\t= SNDRV_PCM_FMTBIT_U8,\n\t.rates\t\t\t= SNDRV_PCM_RATE_8000,\n\t.rate_min\t\t= 8000,\n\t.rate_max\t\t= 8000,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= (48*1024),\n\t.period_bytes_min\t= 1,\n\t.period_bytes_max\t= (48*1024),\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 1024,\n};\n\nstatic int snd_sh_dac_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\truntime->hw = snd_sh_dac_pcm_hw;\n\n\tchip->substream = substream;\n\tchip->buffer_begin = chip->buffer_end = chip->data_buffer;\n\tchip->processed = 0;\n\tchip->empty = 1;\n\n\tchip->pdata->start(chip->pdata);\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\n\tchip->substream = NULL;\n\n\tdac_audio_stop_timer(chip);\n\tchip->pdata->stop(chip->pdata);\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = chip->substream->runtime;\n\n\tchip->buffer_size = runtime->buffer_size;\n\tmemset(chip->data_buffer, 0, chip->pdata->buffer_size);\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdac_audio_start_timer(chip);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tchip->buffer_begin = chip->buffer_end = chip->data_buffer;\n\t\tchip->processed = 0;\n\t\tchip->empty = 1;\n\t\tdac_audio_stop_timer(chip);\n\t\tbreak;\n\tdefault:\n\t\t return -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_pcm_copy(struct snd_pcm_substream *substream,\n\t\t\t       int channel, unsigned long pos,\n\t\t\t       struct iov_iter *src, unsigned long count)\n{\n\t \n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\n\tif (copy_from_iter_toio(chip->data_buffer + pos, src, count))\n\t\treturn -EFAULT;\n\tchip->buffer_end = chip->data_buffer + pos + count;\n\n\tif (chip->empty) {\n\t\tchip->empty = 0;\n\t\tdac_audio_start_timer(chip);\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_pcm_silence(struct snd_pcm_substream *substream,\n\t\t\t\t  int channel, unsigned long pos,\n\t\t\t\t  unsigned long count)\n{\n\t \n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\n\tmemset_io(chip->data_buffer + pos, 0, count);\n\tchip->buffer_end = chip->data_buffer + pos + count;\n\n\tif (chip->empty) {\n\t\tchip->empty = 0;\n\t\tdac_audio_start_timer(chip);\n\t}\n\n\treturn 0;\n}\n\nstatic\nsnd_pcm_uframes_t snd_sh_dac_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_sh_dac *chip = snd_pcm_substream_chip(substream);\n\tint pointer = chip->buffer_begin - chip->data_buffer;\n\n\treturn pointer;\n}\n\n \nstatic const struct snd_pcm_ops snd_sh_dac_pcm_ops = {\n\t.open\t\t= snd_sh_dac_pcm_open,\n\t.close\t\t= snd_sh_dac_pcm_close,\n\t.prepare\t= snd_sh_dac_pcm_prepare,\n\t.trigger\t= snd_sh_dac_pcm_trigger,\n\t.pointer\t= snd_sh_dac_pcm_pointer,\n\t.copy\t\t= snd_sh_dac_pcm_copy,\n\t.fill_silence\t= snd_sh_dac_pcm_silence,\n\t.mmap\t\t= snd_pcm_lib_mmap_iomem,\n};\n\nstatic int snd_sh_dac_pcm(struct snd_sh_dac *chip, int device)\n{\n\tint err;\n\tstruct snd_pcm *pcm;\n\n\t \n\terr = snd_pcm_new(chip->card, \"SH_DAC PCM\", device, 1, 0, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\n\tpcm->private_data = chip;\n\tstrcpy(pcm->name, \"SH_DAC PCM\");\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sh_dac_pcm_ops);\n\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 48 * 1024, 48 * 1024);\n\n\treturn 0;\n}\n \n\n\n \nstatic void snd_sh_dac_remove(struct platform_device *devptr)\n{\n\tsnd_card_free(platform_get_drvdata(devptr));\n}\n\n \nstatic int snd_sh_dac_free(struct snd_sh_dac *chip)\n{\n\t \n\tkfree(chip->data_buffer);\n\tkfree(chip);\n\n\treturn 0;\n}\n\nstatic int snd_sh_dac_dev_free(struct snd_device *device)\n{\n\tstruct snd_sh_dac *chip = device->device_data;\n\n\treturn snd_sh_dac_free(chip);\n}\n\nstatic enum hrtimer_restart sh_dac_audio_timer(struct hrtimer *handle)\n{\n\tstruct snd_sh_dac *chip = container_of(handle, struct snd_sh_dac,\n\t\t\t\t\t       hrtimer);\n\tstruct snd_pcm_runtime *runtime = chip->substream->runtime;\n\tssize_t b_ps = frames_to_bytes(runtime, runtime->period_size);\n\n\tif (!chip->empty) {\n\t\tsh_dac_output(*chip->buffer_begin, chip->pdata->channel);\n\t\tchip->buffer_begin++;\n\n\t\tchip->processed++;\n\t\tif (chip->processed >= b_ps) {\n\t\t\tchip->processed -= b_ps;\n\t\t\tsnd_pcm_period_elapsed(chip->substream);\n\t\t}\n\n\t\tif (chip->buffer_begin == (chip->data_buffer +\n\t\t\t\t\t   chip->buffer_size - 1))\n\t\t\tchip->buffer_begin = chip->data_buffer;\n\n\t\tif (chip->buffer_begin == chip->buffer_end)\n\t\t\tchip->empty = 1;\n\n\t}\n\n\tif (!chip->empty)\n\t\thrtimer_start(&chip->hrtimer, chip->wakeups_per_second,\n\t\t\t      HRTIMER_MODE_REL);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int snd_sh_dac_create(struct snd_card *card,\n\t\t\t     struct platform_device *devptr,\n\t\t\t     struct snd_sh_dac **rchip)\n{\n\tstruct snd_sh_dac *chip;\n\tint err;\n\n\tstatic const struct snd_device_ops ops = {\n\t\t   .dev_free = snd_sh_dac_dev_free,\n\t};\n\n\t*rchip = NULL;\n\n\tchip = kzalloc(sizeof(*chip), GFP_KERNEL);\n\tif (chip == NULL)\n\t\treturn -ENOMEM;\n\n\tchip->card = card;\n\n\thrtimer_init(&chip->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tchip->hrtimer.function = sh_dac_audio_timer;\n\n\tdac_audio_reset(chip);\n\tchip->rate = 8000;\n\tdac_audio_set_rate(chip);\n\n\tchip->pdata = devptr->dev.platform_data;\n\n\tchip->data_buffer = kmalloc(chip->pdata->buffer_size, GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tkfree(chip);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\n\tif (err < 0) {\n\t\tsnd_sh_dac_free(chip);\n\t\treturn err;\n\t}\n\n\t*rchip = chip;\n\n\treturn 0;\n}\n\n \nstatic int snd_sh_dac_probe(struct platform_device *devptr)\n{\n\tstruct snd_sh_dac *chip;\n\tstruct snd_card *card;\n\tint err;\n\n\terr = snd_card_new(&devptr->dev, index, id, THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\t\tsnd_printk(KERN_ERR \"cannot allocate the card\\n\");\n\t\t\treturn err;\n\t}\n\n\terr = snd_sh_dac_create(card, devptr, &chip);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\terr = snd_sh_dac_pcm(chip, 0);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\tstrcpy(card->driver, \"snd_sh_dac\");\n\tstrcpy(card->shortname, \"SuperH DAC audio driver\");\n\tprintk(KERN_INFO \"%s %s\", card->longname, card->shortname);\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto probe_error;\n\n\tsnd_printk(KERN_INFO \"ALSA driver for SuperH DAC audio\");\n\n\tplatform_set_drvdata(devptr, card);\n\treturn 0;\n\nprobe_error:\n\tsnd_card_free(card);\n\treturn err;\n}\n\n \nstatic struct platform_driver sh_dac_driver = {\n\t.probe\t= snd_sh_dac_probe,\n\t.remove_new = snd_sh_dac_remove,\n\t.driver = {\n\t\t.name = \"dac_audio\",\n\t},\n};\n\nmodule_platform_driver(sh_dac_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}