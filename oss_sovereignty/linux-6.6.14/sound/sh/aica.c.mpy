{
  "module_name": "aica.c",
  "hash_id": "5ab6ee66d7389de67d017a5da983b1b9c130c07c96b6164454953036c7311f06",
  "original_prompt": "Ingested from linux-6.6.14/sound/sh/aica.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/info.h>\n#include <asm/dma.h>\n#include <mach/sysasic.h>\n#include \"aica.h\"\n\nMODULE_AUTHOR(\"Adrian McMenamin <adrian@mcmen.demon.co.uk>\");\nMODULE_DESCRIPTION(\"Dreamcast AICA sound (pcm) driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"aica_firmware.bin\");\n\n \n#define CARD_NAME \"AICA\"\nstatic int index = -1;\nstatic char *id;\nstatic bool enable = 1;\nmodule_param(index, int, 0444);\nMODULE_PARM_DESC(index, \"Index value for \" CARD_NAME \" soundcard.\");\nmodule_param(id, charp, 0444);\nMODULE_PARM_DESC(id, \"ID string for \" CARD_NAME \" soundcard.\");\nmodule_param(enable, bool, 0644);\nMODULE_PARM_DESC(enable, \"Enable \" CARD_NAME \" soundcard.\");\n\n \nstatic struct platform_device *pd;\nstatic struct resource aica_memory_space[2] = {\n\t{\n\t .name = \"AICA ARM CONTROL\",\n\t .start = ARM_RESET_REGISTER,\n\t .flags = IORESOURCE_MEM,\n\t .end = ARM_RESET_REGISTER + 3,\n\t },\n\t{\n\t .name = \"AICA Sound RAM\",\n\t .start = SPU_MEMORY_BASE,\n\t .flags = IORESOURCE_MEM,\n\t .end = SPU_MEMORY_BASE + 0x200000 - 1,\n\t },\n};\n\n \n \nstatic void spu_write_wait(void)\n{\n\tint time_count;\n\ttime_count = 0;\n\twhile (1) {\n\t\tif (!(readl(G2_FIFO) & 0x11))\n\t\t\tbreak;\n\t\t \n\t\ttime_count++;\n\t\tif (time_count > 0x10000) {\n\t\t\tsnd_printk\n\t\t\t    (\"WARNING: G2 FIFO appears to be blocked.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void spu_memset(u32 toi, u32 what, int length)\n{\n\tint i;\n\tunsigned long flags;\n\tif (snd_BUG_ON(length % 4))\n\t\treturn;\n\tfor (i = 0; i < length; i++) {\n\t\tif (!(i % 8))\n\t\t\tspu_write_wait();\n\t\tlocal_irq_save(flags);\n\t\twritel(what, toi + SPU_MEMORY_BASE);\n\t\tlocal_irq_restore(flags);\n\t\ttoi++;\n\t}\n}\n\n \nstatic void spu_memload(u32 toi, const void *from, int length)\n{\n\tunsigned long flags;\n\tconst u32 *froml = from;\n\tu32 __iomem *to = (u32 __iomem *) (SPU_MEMORY_BASE + toi);\n\tint i;\n\tu32 val;\n\tlength = DIV_ROUND_UP(length, 4);\n\tspu_write_wait();\n\tfor (i = 0; i < length; i++) {\n\t\tif (!(i % 8))\n\t\t\tspu_write_wait();\n\t\tval = *froml;\n\t\tlocal_irq_save(flags);\n\t\twritel(val, to);\n\t\tlocal_irq_restore(flags);\n\t\tfroml++;\n\t\tto++;\n\t}\n}\n\n \nstatic void spu_disable(void)\n{\n\tint i;\n\tunsigned long flags;\n\tu32 regval;\n\tspu_write_wait();\n\tregval = readl(ARM_RESET_REGISTER);\n\tregval |= 1;\n\tspu_write_wait();\n\tlocal_irq_save(flags);\n\twritel(regval, ARM_RESET_REGISTER);\n\tlocal_irq_restore(flags);\n\tfor (i = 0; i < 64; i++) {\n\t\tspu_write_wait();\n\t\tregval = readl(SPU_REGISTER_BASE + (i * 0x80));\n\t\tregval = (regval & ~0x4000) | 0x8000;\n\t\tspu_write_wait();\n\t\tlocal_irq_save(flags);\n\t\twritel(regval, SPU_REGISTER_BASE + (i * 0x80));\n\t\tlocal_irq_restore(flags);\n\t}\n}\n\n \nstatic void spu_enable(void)\n{\n\tunsigned long flags;\n\tu32 regval = readl(ARM_RESET_REGISTER);\n\tregval &= ~1;\n\tspu_write_wait();\n\tlocal_irq_save(flags);\n\twritel(regval, ARM_RESET_REGISTER);\n\tlocal_irq_restore(flags);\n}\n\n \nstatic void spu_reset(void)\n{\n\tunsigned long flags;\n\tspu_disable();\n\tspu_memset(0, 0, 0x200000 / 4);\n\t \n\tlocal_irq_save(flags);\n\t__raw_writel(0xea000002, SPU_MEMORY_BASE);\n\tlocal_irq_restore(flags);\n\tspu_enable();\n}\n\n \nstatic void aica_chn_start(void)\n{\n\tunsigned long flags;\n\tspu_write_wait();\n\tlocal_irq_save(flags);\n\twritel(AICA_CMD_KICK | AICA_CMD_START, (u32 *) AICA_CONTROL_POINT);\n\tlocal_irq_restore(flags);\n}\n\n \nstatic void aica_chn_halt(void)\n{\n\tunsigned long flags;\n\tspu_write_wait();\n\tlocal_irq_save(flags);\n\twritel(AICA_CMD_KICK | AICA_CMD_STOP, (u32 *) AICA_CONTROL_POINT);\n\tlocal_irq_restore(flags);\n}\n\n \nstatic const struct snd_pcm_hardware snd_pcm_aica_playback_hw = {\n\t.info = (SNDRV_PCM_INFO_NONINTERLEAVED),\n\t.formats =\n\t    (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t     SNDRV_PCM_FMTBIT_IMA_ADPCM),\n\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t.rate_min = 8000,\n\t.rate_max = 48000,\n\t.channels_min = 1,\n\t.channels_max = 2,\n\t.buffer_bytes_max = AICA_BUFFER_SIZE,\n\t.period_bytes_min = AICA_PERIOD_SIZE,\n\t.period_bytes_max = AICA_PERIOD_SIZE,\n\t.periods_min = AICA_PERIOD_NUMBER,\n\t.periods_max = AICA_PERIOD_NUMBER,\n};\n\nstatic int aica_dma_transfer(int channels, int buffer_size,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tint q, err, period_offset;\n\tstruct snd_card_aica *dreamcastcard;\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\terr = 0;\n\tdreamcastcard = substream->pcm->private_data;\n\tperiod_offset = dreamcastcard->clicks;\n\tperiod_offset %= (AICA_PERIOD_NUMBER / channels);\n\truntime = substream->runtime;\n\tfor (q = 0; q < channels; q++) {\n\t\tlocal_irq_save(flags);\n\t\terr = dma_xfer(AICA_DMA_CHANNEL,\n\t\t\t       (unsigned long) (runtime->dma_area +\n\t\t\t\t\t\t(AICA_BUFFER_SIZE * q) /\n\t\t\t\t\t\tchannels +\n\t\t\t\t\t\tAICA_PERIOD_SIZE *\n\t\t\t\t\t\tperiod_offset),\n\t\t\t       AICA_CHANNEL0_OFFSET + q * CHANNEL_OFFSET +\n\t\t\t       AICA_PERIOD_SIZE * period_offset,\n\t\t\t       buffer_size / channels, AICA_DMA_MODE);\n\t\tif (unlikely(err < 0)) {\n\t\t\tlocal_irq_restore(flags);\n\t\t\tbreak;\n\t\t}\n\t\tdma_wait_for_completion(AICA_DMA_CHANNEL);\n\t\tlocal_irq_restore(flags);\n\t}\n\treturn err;\n}\n\nstatic void startup_aica(struct snd_card_aica *dreamcastcard)\n{\n\tspu_memload(AICA_CHANNEL0_CONTROL_OFFSET,\n\t\t    dreamcastcard->channel, sizeof(struct aica_channel));\n\taica_chn_start();\n}\n\nstatic void run_spu_dma(struct work_struct *work)\n{\n\tint buffer_size;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct snd_card_aica *dreamcastcard;\n\tdreamcastcard =\n\t    container_of(work, struct snd_card_aica, spu_dma_work);\n\truntime = dreamcastcard->substream->runtime;\n\tif (unlikely(dreamcastcard->dma_check == 0)) {\n\t\tbuffer_size =\n\t\t    frames_to_bytes(runtime, runtime->buffer_size);\n\t\tif (runtime->channels > 1)\n\t\t\tdreamcastcard->channel->flags |= 0x01;\n\t\taica_dma_transfer(runtime->channels, buffer_size,\n\t\t\t\t  dreamcastcard->substream);\n\t\tstartup_aica(dreamcastcard);\n\t\tdreamcastcard->clicks =\n\t\t    buffer_size / (AICA_PERIOD_SIZE * runtime->channels);\n\t\treturn;\n\t} else {\n\t\taica_dma_transfer(runtime->channels,\n\t\t\t\t  AICA_PERIOD_SIZE * runtime->channels,\n\t\t\t\t  dreamcastcard->substream);\n\t\tsnd_pcm_period_elapsed(dreamcastcard->substream);\n\t\tdreamcastcard->clicks++;\n\t\tif (unlikely(dreamcastcard->clicks >= AICA_PERIOD_NUMBER))\n\t\t\tdreamcastcard->clicks %= AICA_PERIOD_NUMBER;\n\t\tmod_timer(&dreamcastcard->timer, jiffies + 1);\n\t}\n}\n\nstatic void aica_period_elapsed(struct timer_list *t)\n{\n\tstruct snd_card_aica *dreamcastcard = from_timer(dreamcastcard,\n\t\t\t\t\t\t\t      t, timer);\n\tstruct snd_pcm_substream *substream = dreamcastcard->substream;\n\t \n\tint play_period;\n\tstruct snd_pcm_runtime *runtime;\n\truntime = substream->runtime;\n\tdreamcastcard = substream->pcm->private_data;\n\t \n\tplay_period =\n\t    frames_to_bytes(runtime,\n\t\t\t    readl\n\t\t\t    (AICA_CONTROL_CHANNEL_SAMPLE_NUMBER)) /\n\t    AICA_PERIOD_SIZE;\n\tif (play_period == dreamcastcard->current_period) {\n\t\t \n\t\tmod_timer(&(dreamcastcard->timer), jiffies + 1);\n\t\treturn;\n\t}\n\tif (runtime->channels > 1)\n\t\tdreamcastcard->current_period = play_period;\n\tif (unlikely(dreamcastcard->dma_check == 0))\n\t\tdreamcastcard->dma_check = 1;\n\tschedule_work(&(dreamcastcard->spu_dma_work));\n}\n\nstatic void spu_begin_dma(struct snd_pcm_substream *substream)\n{\n\tstruct snd_card_aica *dreamcastcard;\n\tstruct snd_pcm_runtime *runtime;\n\truntime = substream->runtime;\n\tdreamcastcard = substream->pcm->private_data;\n\t \n\tschedule_work(&(dreamcastcard->spu_dma_work));\n\tmod_timer(&dreamcastcard->timer, jiffies + 4);\n}\n\nstatic int snd_aicapcm_pcm_open(struct snd_pcm_substream\n\t\t\t\t*substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tstruct aica_channel *channel;\n\tstruct snd_card_aica *dreamcastcard;\n\tif (!enable)\n\t\treturn -ENOENT;\n\tdreamcastcard = substream->pcm->private_data;\n\tchannel = kmalloc(sizeof(struct aica_channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn -ENOMEM;\n\t \n\tchannel->sfmt = SM_8BIT;\n\tchannel->cmd = AICA_CMD_START;\n\tchannel->vol = dreamcastcard->master_volume;\n\tchannel->pan = 0x80;\n\tchannel->pos = 0;\n\tchannel->flags = 0;\t \n\tdreamcastcard->channel = channel;\n\truntime = substream->runtime;\n\truntime->hw = snd_pcm_aica_playback_hw;\n\tspu_enable();\n\tdreamcastcard->clicks = 0;\n\tdreamcastcard->current_period = 0;\n\tdreamcastcard->dma_check = 0;\n\treturn 0;\n}\n\nstatic int snd_aicapcm_pcm_close(struct snd_pcm_substream\n\t\t\t\t *substream)\n{\n\tstruct snd_card_aica *dreamcastcard = substream->pcm->private_data;\n\tflush_work(&(dreamcastcard->spu_dma_work));\n\tdel_timer(&dreamcastcard->timer);\n\tdreamcastcard->substream = NULL;\n\tkfree(dreamcastcard->channel);\n\tspu_disable();\n\treturn 0;\n}\n\nstatic int snd_aicapcm_pcm_prepare(struct snd_pcm_substream\n\t\t\t\t   *substream)\n{\n\tstruct snd_card_aica *dreamcastcard = substream->pcm->private_data;\n\tif ((substream->runtime)->format == SNDRV_PCM_FORMAT_S16_LE)\n\t\tdreamcastcard->channel->sfmt = SM_16BIT;\n\tdreamcastcard->channel->freq = substream->runtime->rate;\n\tdreamcastcard->substream = substream;\n\treturn 0;\n}\n\nstatic int snd_aicapcm_pcm_trigger(struct snd_pcm_substream\n\t\t\t\t   *substream, int cmd)\n{\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tspu_begin_dma(substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\taica_chn_halt();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic unsigned long snd_aicapcm_pcm_pointer(struct snd_pcm_substream\n\t\t\t\t\t     *substream)\n{\n\treturn readl(AICA_CONTROL_CHANNEL_SAMPLE_NUMBER);\n}\n\nstatic const struct snd_pcm_ops snd_aicapcm_playback_ops = {\n\t.open = snd_aicapcm_pcm_open,\n\t.close = snd_aicapcm_pcm_close,\n\t.prepare = snd_aicapcm_pcm_prepare,\n\t.trigger = snd_aicapcm_pcm_trigger,\n\t.pointer = snd_aicapcm_pcm_pointer,\n};\n\n \nstatic int __init snd_aicapcmchip(struct snd_card_aica\n\t\t\t\t  *dreamcastcard, int pcm_index)\n{\n\tstruct snd_pcm *pcm;\n\tint err;\n\t \n\terr =\n\t    snd_pcm_new(dreamcastcard->card, \"AICA PCM\", pcm_index, 1, 0,\n\t\t\t&pcm);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tpcm->private_data = dreamcastcard;\n\tstrcpy(pcm->name, \"AICA PCM\");\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t&snd_aicapcm_playback_ops);\n\t \n\tsnd_pcm_set_managed_buffer_all(pcm,\n\t\t\t\t       SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL,\n\t\t\t\t       AICA_BUFFER_SIZE,\n\t\t\t\t       AICA_BUFFER_SIZE);\n\treturn 0;\n}\n\n \n#define aica_pcmswitch_info\t\tsnd_ctl_boolean_mono_info\n\nstatic int aica_pcmswitch_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.integer.value[0] = 1;\t \n\treturn 0;\n}\n\nstatic int aica_pcmswitch_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tif (ucontrol->value.integer.value[0] == 1)\n\t\treturn 0;\t \n\telse\n\t\taica_chn_halt();\n\treturn 0;\n}\n\nstatic int aica_pcmvolume_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xFF;\n\treturn 0;\n}\n\nstatic int aica_pcmvolume_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_card_aica *dreamcastcard;\n\tdreamcastcard = kcontrol->private_data;\n\tif (unlikely(!dreamcastcard->channel))\n\t\treturn -ETXTBSY;\t \n\tucontrol->value.integer.value[0] = dreamcastcard->channel->vol;\n\treturn 0;\n}\n\nstatic int aica_pcmvolume_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_card_aica *dreamcastcard;\n\tunsigned int vol;\n\tdreamcastcard = kcontrol->private_data;\n\tif (unlikely(!dreamcastcard->channel))\n\t\treturn -ETXTBSY;\n\tvol = ucontrol->value.integer.value[0];\n\tif (vol > 0xff)\n\t\treturn -EINVAL;\n\tif (unlikely(dreamcastcard->channel->vol == vol))\n\t\treturn 0;\n\tdreamcastcard->channel->vol = ucontrol->value.integer.value[0];\n\tdreamcastcard->master_volume = ucontrol->value.integer.value[0];\n\tspu_memload(AICA_CHANNEL0_CONTROL_OFFSET,\n\t\t    dreamcastcard->channel, sizeof(struct aica_channel));\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new snd_aica_pcmswitch_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Playback Switch\",\n\t.index = 0,\n\t.info = aica_pcmswitch_info,\n\t.get = aica_pcmswitch_get,\n\t.put = aica_pcmswitch_put\n};\n\nstatic const struct snd_kcontrol_new snd_aica_pcmvolume_control = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"PCM Playback Volume\",\n\t.index = 0,\n\t.info = aica_pcmvolume_info,\n\t.get = aica_pcmvolume_get,\n\t.put = aica_pcmvolume_put\n};\n\nstatic int load_aica_firmware(void)\n{\n\tint err;\n\tconst struct firmware *fw_entry;\n\tspu_reset();\n\terr = request_firmware(&fw_entry, \"aica_firmware.bin\", &pd->dev);\n\tif (unlikely(err))\n\t\treturn err;\n\t \n\tspu_disable();\n\tspu_memload(0, fw_entry->data, fw_entry->size);\n\tspu_enable();\n\trelease_firmware(fw_entry);\n\treturn err;\n}\n\nstatic int add_aicamixer_controls(struct snd_card_aica *dreamcastcard)\n{\n\tint err;\n\terr = snd_ctl_add\n\t    (dreamcastcard->card,\n\t     snd_ctl_new1(&snd_aica_pcmvolume_control, dreamcastcard));\n\tif (unlikely(err < 0))\n\t\treturn err;\n\terr = snd_ctl_add\n\t    (dreamcastcard->card,\n\t     snd_ctl_new1(&snd_aica_pcmswitch_control, dreamcastcard));\n\tif (unlikely(err < 0))\n\t\treturn err;\n\treturn 0;\n}\n\nstatic void snd_aica_remove(struct platform_device *devptr)\n{\n\tstruct snd_card_aica *dreamcastcard;\n\tdreamcastcard = platform_get_drvdata(devptr);\n\tsnd_card_free(dreamcastcard->card);\n\tkfree(dreamcastcard);\n}\n\nstatic int snd_aica_probe(struct platform_device *devptr)\n{\n\tint err;\n\tstruct snd_card_aica *dreamcastcard;\n\tdreamcastcard = kzalloc(sizeof(struct snd_card_aica), GFP_KERNEL);\n\tif (unlikely(!dreamcastcard))\n\t\treturn -ENOMEM;\n\terr = snd_card_new(&devptr->dev, index, SND_AICA_DRIVER,\n\t\t\t   THIS_MODULE, 0, &dreamcastcard->card);\n\tif (unlikely(err < 0)) {\n\t\tkfree(dreamcastcard);\n\t\treturn err;\n\t}\n\tstrcpy(dreamcastcard->card->driver, \"snd_aica\");\n\tstrcpy(dreamcastcard->card->shortname, SND_AICA_DRIVER);\n\tstrcpy(dreamcastcard->card->longname,\n\t       \"Yamaha AICA Super Intelligent Sound Processor for SEGA Dreamcast\");\n\t \n\tINIT_WORK(&(dreamcastcard->spu_dma_work), run_spu_dma);\n\ttimer_setup(&dreamcastcard->timer, aica_period_elapsed, 0);\n\t \n\terr = snd_aicapcmchip(dreamcastcard, 0);\n\tif (unlikely(err < 0))\n\t\tgoto freedreamcast;\n\t \n\terr = add_aicamixer_controls(dreamcastcard);\n\tif (unlikely(err < 0))\n\t\tgoto freedreamcast;\n\t \n\terr = snd_card_register(dreamcastcard->card);\n\tif (unlikely(err < 0))\n\t\tgoto freedreamcast;\n\tplatform_set_drvdata(devptr, dreamcastcard);\n\tsnd_printk\n\t    (\"ALSA Driver for Yamaha AICA Super Intelligent Sound Processor\\n\");\n\treturn 0;\n      freedreamcast:\n\tsnd_card_free(dreamcastcard->card);\n\tkfree(dreamcastcard);\n\treturn err;\n}\n\nstatic struct platform_driver snd_aica_driver = {\n\t.probe = snd_aica_probe,\n\t.remove_new = snd_aica_remove,\n\t.driver = {\n\t\t.name = SND_AICA_DRIVER,\n\t},\n};\n\nstatic int __init aica_init(void)\n{\n\tint err;\n\terr = platform_driver_register(&snd_aica_driver);\n\tif (unlikely(err < 0))\n\t\treturn err;\n\tpd = platform_device_register_simple(SND_AICA_DRIVER, -1,\n\t\t\t\t\t     aica_memory_space, 2);\n\tif (IS_ERR(pd)) {\n\t\tplatform_driver_unregister(&snd_aica_driver);\n\t\treturn PTR_ERR(pd);\n\t}\n\t \n\treturn load_aica_firmware();\n}\n\nstatic void __exit aica_exit(void)\n{\n\tplatform_device_unregister(pd);\n\tplatform_driver_unregister(&snd_aica_driver);\n\t \n\tspu_reset();\n}\n\nmodule_init(aica_init);\nmodule_exit(aica_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}