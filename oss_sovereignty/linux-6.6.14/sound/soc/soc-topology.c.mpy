{
  "module_name": "soc-topology.c",
  "hash_id": "6b2188684c4ea7d468f8af9ad58f6e819eb09122fda48510b1b3841130c38947",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-topology.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/list.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/soc-topology.h>\n#include <sound/tlv.h>\n\n#define SOC_TPLG_MAGIC_BIG_ENDIAN            0x436F5341  \n\n \n#define SOC_TPLG_PASS_MANIFEST\t\t0\n#define SOC_TPLG_PASS_VENDOR\t\t1\n#define SOC_TPLG_PASS_CONTROL\t\t2\n#define SOC_TPLG_PASS_WIDGET\t\t3\n#define SOC_TPLG_PASS_PCM_DAI\t\t4\n#define SOC_TPLG_PASS_GRAPH\t\t5\n#define SOC_TPLG_PASS_BE_DAI\t\t6\n#define SOC_TPLG_PASS_LINK\t\t7\n\n#define SOC_TPLG_PASS_START\tSOC_TPLG_PASS_MANIFEST\n#define SOC_TPLG_PASS_END\tSOC_TPLG_PASS_LINK\n\n \nstruct soc_tplg {\n\tconst struct firmware *fw;\n\n\t \n\tconst u8 *pos;\t\t \n\tconst u8 *hdr_pos;\t \n\tunsigned int pass;\t \n\n\t \n\tstruct device *dev;\n\tstruct snd_soc_component *comp;\n\tu32 index;\t \n\n\t \n\tconst struct snd_soc_tplg_kcontrol_ops *io_ops;\n\tint io_ops_count;\n\n\t \n\tconst struct snd_soc_tplg_bytes_ext_ops *bytes_ext_ops;\n\tint bytes_ext_ops_count;\n\n\t \n\tstruct snd_soc_tplg_ops *ops;\n};\n\n \nstatic int soc_tplg_check_elem_count(struct soc_tplg *tplg, size_t elem_size,\n\tunsigned int count, size_t bytes, const char *elem_type)\n{\n\tconst u8 *end = tplg->pos + elem_size * count;\n\n\tif (end > tplg->fw->data + tplg->fw->size) {\n\t\tdev_err(tplg->dev, \"ASoC: %s overflow end of data\\n\",\n\t\t\telem_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (elem_size * count > bytes) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: %s count %d of size %zu is bigger than chunk %zu\\n\",\n\t\t\telem_type, count, elem_size, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline bool soc_tplg_is_eof(struct soc_tplg *tplg)\n{\n\tconst u8 *end = tplg->hdr_pos;\n\n\tif (end >= tplg->fw->data + tplg->fw->size)\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline unsigned long soc_tplg_get_hdr_offset(struct soc_tplg *tplg)\n{\n\treturn (unsigned long)(tplg->hdr_pos - tplg->fw->data);\n}\n\nstatic inline unsigned long soc_tplg_get_offset(struct soc_tplg *tplg)\n{\n\treturn (unsigned long)(tplg->pos - tplg->fw->data);\n}\n\n \nstatic const struct snd_soc_tplg_kcontrol_ops io_ops[] = {\n\t{SND_SOC_TPLG_CTL_VOLSW, snd_soc_get_volsw,\n\t\tsnd_soc_put_volsw, snd_soc_info_volsw},\n\t{SND_SOC_TPLG_CTL_VOLSW_SX, snd_soc_get_volsw_sx,\n\t\tsnd_soc_put_volsw_sx, NULL},\n\t{SND_SOC_TPLG_CTL_ENUM, snd_soc_get_enum_double,\n\t\tsnd_soc_put_enum_double, snd_soc_info_enum_double},\n\t{SND_SOC_TPLG_CTL_ENUM_VALUE, snd_soc_get_enum_double,\n\t\tsnd_soc_put_enum_double, NULL},\n\t{SND_SOC_TPLG_CTL_BYTES, snd_soc_bytes_get,\n\t\tsnd_soc_bytes_put, snd_soc_bytes_info},\n\t{SND_SOC_TPLG_CTL_RANGE, snd_soc_get_volsw_range,\n\t\tsnd_soc_put_volsw_range, snd_soc_info_volsw_range},\n\t{SND_SOC_TPLG_CTL_VOLSW_XR_SX, snd_soc_get_xr_sx,\n\t\tsnd_soc_put_xr_sx, snd_soc_info_xr_sx},\n\t{SND_SOC_TPLG_CTL_STROBE, snd_soc_get_strobe,\n\t\tsnd_soc_put_strobe, NULL},\n\t{SND_SOC_TPLG_DAPM_CTL_VOLSW, snd_soc_dapm_get_volsw,\n\t\tsnd_soc_dapm_put_volsw, snd_soc_info_volsw},\n\t{SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE, snd_soc_dapm_get_enum_double,\n\t\tsnd_soc_dapm_put_enum_double, snd_soc_info_enum_double},\n\t{SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT, snd_soc_dapm_get_enum_double,\n\t\tsnd_soc_dapm_put_enum_double, NULL},\n\t{SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE, snd_soc_dapm_get_enum_double,\n\t\tsnd_soc_dapm_put_enum_double, NULL},\n\t{SND_SOC_TPLG_DAPM_CTL_PIN, snd_soc_dapm_get_pin_switch,\n\t\tsnd_soc_dapm_put_pin_switch, snd_soc_dapm_info_pin_switch},\n};\n\nstruct soc_tplg_map {\n\tint uid;\n\tint kid;\n};\n\n \nstatic const struct soc_tplg_map dapm_map[] = {\n\t{SND_SOC_TPLG_DAPM_INPUT, snd_soc_dapm_input},\n\t{SND_SOC_TPLG_DAPM_OUTPUT, snd_soc_dapm_output},\n\t{SND_SOC_TPLG_DAPM_MUX, snd_soc_dapm_mux},\n\t{SND_SOC_TPLG_DAPM_MIXER, snd_soc_dapm_mixer},\n\t{SND_SOC_TPLG_DAPM_PGA, snd_soc_dapm_pga},\n\t{SND_SOC_TPLG_DAPM_OUT_DRV, snd_soc_dapm_out_drv},\n\t{SND_SOC_TPLG_DAPM_ADC, snd_soc_dapm_adc},\n\t{SND_SOC_TPLG_DAPM_DAC, snd_soc_dapm_dac},\n\t{SND_SOC_TPLG_DAPM_SWITCH, snd_soc_dapm_switch},\n\t{SND_SOC_TPLG_DAPM_PRE, snd_soc_dapm_pre},\n\t{SND_SOC_TPLG_DAPM_POST, snd_soc_dapm_post},\n\t{SND_SOC_TPLG_DAPM_AIF_IN, snd_soc_dapm_aif_in},\n\t{SND_SOC_TPLG_DAPM_AIF_OUT, snd_soc_dapm_aif_out},\n\t{SND_SOC_TPLG_DAPM_DAI_IN, snd_soc_dapm_dai_in},\n\t{SND_SOC_TPLG_DAPM_DAI_OUT, snd_soc_dapm_dai_out},\n\t{SND_SOC_TPLG_DAPM_DAI_LINK, snd_soc_dapm_dai_link},\n\t{SND_SOC_TPLG_DAPM_BUFFER, snd_soc_dapm_buffer},\n\t{SND_SOC_TPLG_DAPM_SCHEDULER, snd_soc_dapm_scheduler},\n\t{SND_SOC_TPLG_DAPM_EFFECT, snd_soc_dapm_effect},\n\t{SND_SOC_TPLG_DAPM_SIGGEN, snd_soc_dapm_siggen},\n\t{SND_SOC_TPLG_DAPM_SRC, snd_soc_dapm_src},\n\t{SND_SOC_TPLG_DAPM_ASRC, snd_soc_dapm_asrc},\n\t{SND_SOC_TPLG_DAPM_ENCODER, snd_soc_dapm_encoder},\n\t{SND_SOC_TPLG_DAPM_DECODER, snd_soc_dapm_decoder},\n};\n\nstatic int tplg_chan_get_reg(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_channel *chan, int map)\n{\n\tint i;\n\n\tfor (i = 0; i < SND_SOC_TPLG_MAX_CHAN; i++) {\n\t\tif (le32_to_cpu(chan[i].id) == map)\n\t\t\treturn le32_to_cpu(chan[i].reg);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tplg_chan_get_shift(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_channel *chan, int map)\n{\n\tint i;\n\n\tfor (i = 0; i < SND_SOC_TPLG_MAX_CHAN; i++) {\n\t\tif (le32_to_cpu(chan[i].id) == map)\n\t\t\treturn le32_to_cpu(chan[i].shift);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int get_widget_id(int tplg_type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dapm_map); i++) {\n\t\tif (tplg_type == dapm_map[i].uid)\n\t\t\treturn dapm_map[i].kid;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic inline void soc_bind_err(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_ctl_hdr *hdr, int index)\n{\n\tdev_err(tplg->dev,\n\t\t\"ASoC: invalid control type (g,p,i) %d:%d:%d index %d at 0x%lx\\n\",\n\t\thdr->ops.get, hdr->ops.put, hdr->ops.info, index,\n\t\tsoc_tplg_get_offset(tplg));\n}\n\nstatic inline void soc_control_err(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_ctl_hdr *hdr, const char *name)\n{\n\tdev_err(tplg->dev,\n\t\t\"ASoC: no complete control IO handler for %s type (g,p,i) %d:%d:%d at 0x%lx\\n\",\n\t\tname, hdr->ops.get, hdr->ops.put, hdr->ops.info,\n\t\tsoc_tplg_get_offset(tplg));\n}\n\n \nstatic int soc_tplg_vendor_load(struct soc_tplg *tplg,\n\t\t\t\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tint ret = 0;\n\n\tif (tplg->ops && tplg->ops->vendor_load)\n\t\tret = tplg->ops->vendor_load(tplg->comp, tplg->index, hdr);\n\telse {\n\t\tdev_err(tplg->dev, \"ASoC: no vendor load callback for ID %d\\n\",\n\t\t\thdr->vendor_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: vendor load failed at hdr offset %ld/0x%lx for type %d:%d\\n\",\n\t\t\tsoc_tplg_get_hdr_offset(tplg),\n\t\t\tsoc_tplg_get_hdr_offset(tplg),\n\t\t\thdr->type, hdr->vendor_type);\n\treturn ret;\n}\n\n \nstatic int soc_tplg_widget_load(struct soc_tplg *tplg,\n\tstruct snd_soc_dapm_widget *w, struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tif (tplg->ops && tplg->ops->widget_load)\n\t\treturn tplg->ops->widget_load(tplg->comp, tplg->index, w,\n\t\t\ttplg_w);\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_widget_ready(struct soc_tplg *tplg,\n\tstruct snd_soc_dapm_widget *w, struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tif (tplg->ops && tplg->ops->widget_ready)\n\t\treturn tplg->ops->widget_ready(tplg->comp, tplg->index, w,\n\t\t\ttplg_w);\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_dai_load(struct soc_tplg *tplg,\n\tstruct snd_soc_dai_driver *dai_drv,\n\tstruct snd_soc_tplg_pcm *pcm, struct snd_soc_dai *dai)\n{\n\tif (tplg->ops && tplg->ops->dai_load)\n\t\treturn tplg->ops->dai_load(tplg->comp, tplg->index, dai_drv,\n\t\t\tpcm, dai);\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_dai_link_load(struct soc_tplg *tplg,\n\tstruct snd_soc_dai_link *link, struct snd_soc_tplg_link_config *cfg)\n{\n\tif (tplg->ops && tplg->ops->link_load)\n\t\treturn tplg->ops->link_load(tplg->comp, tplg->index, link, cfg);\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_complete(struct soc_tplg *tplg)\n{\n\tif (tplg->ops && tplg->ops->complete)\n\t\treturn tplg->ops->complete(tplg->comp);\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_add_dcontrol(struct snd_card *card, struct device *dev,\n\tconst struct snd_kcontrol_new *control_new, const char *prefix,\n\tvoid *data, struct snd_kcontrol **kcontrol)\n{\n\tint err;\n\n\t*kcontrol = snd_soc_cnew(control_new, data, control_new->name, prefix);\n\tif (*kcontrol == NULL) {\n\t\tdev_err(dev, \"ASoC: Failed to create new kcontrol %s\\n\",\n\t\tcontrol_new->name);\n\t\treturn -ENOMEM;\n\t}\n\n\terr = snd_ctl_add(card, *kcontrol);\n\tif (err < 0) {\n\t\tdev_err(dev, \"ASoC: Failed to add %s: %d\\n\",\n\t\t\tcontrol_new->name, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_add_kcontrol(struct soc_tplg *tplg,\n\tstruct snd_kcontrol_new *k, struct snd_kcontrol **kcontrol)\n{\n\tstruct snd_soc_component *comp = tplg->comp;\n\n\treturn soc_tplg_add_dcontrol(comp->card->snd_card,\n\t\t\t\ttplg->dev, k, comp->name_prefix, comp, kcontrol);\n}\n\n \nstatic void soc_tplg_remove_kcontrol(struct snd_soc_component *comp, struct snd_soc_dobj *dobj,\n\t\t\t\t     int pass)\n{\n\tstruct snd_card *card = comp->card->snd_card;\n\n\tif (pass != SOC_TPLG_PASS_CONTROL)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\tsnd_ctl_remove(card, dobj->control.kcontrol);\n\tlist_del(&dobj->list);\n}\n\n \nstatic void soc_tplg_remove_route(struct snd_soc_component *comp,\n\t\t\t struct snd_soc_dobj *dobj, int pass)\n{\n\tif (pass != SOC_TPLG_PASS_GRAPH)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\tlist_del(&dobj->list);\n}\n\n \nstatic void soc_tplg_remove_widget(struct snd_soc_component *comp,\n\tstruct snd_soc_dobj *dobj, int pass)\n{\n\tstruct snd_card *card = comp->card->snd_card;\n\tstruct snd_soc_dapm_widget *w =\n\t\tcontainer_of(dobj, struct snd_soc_dapm_widget, dobj);\n\tint i;\n\n\tif (pass != SOC_TPLG_PASS_WIDGET)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\tif (!w->kcontrols)\n\t\tgoto free_news;\n\n\tfor (i = 0; w->kcontrols && i < w->num_kcontrols; i++)\n\t\tsnd_ctl_remove(card, w->kcontrols[i]);\n\nfree_news:\n\n\tlist_del(&dobj->list);\n\n\t \n}\n\n \nstatic void soc_tplg_remove_dai(struct snd_soc_component *comp,\n\tstruct snd_soc_dobj *dobj, int pass)\n{\n\tstruct snd_soc_dai_driver *dai_drv =\n\t\tcontainer_of(dobj, struct snd_soc_dai_driver, dobj);\n\tstruct snd_soc_dai *dai, *_dai;\n\n\tif (pass != SOC_TPLG_PASS_PCM_DAI)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\tfor_each_component_dais_safe(comp, dai, _dai)\n\t\tif (dai->driver == dai_drv)\n\t\t\tsnd_soc_unregister_dai(dai);\n\n\tlist_del(&dobj->list);\n}\n\n \nstatic void soc_tplg_remove_link(struct snd_soc_component *comp,\n\tstruct snd_soc_dobj *dobj, int pass)\n{\n\tstruct snd_soc_dai_link *link =\n\t\tcontainer_of(dobj, struct snd_soc_dai_link, dobj);\n\n\tif (pass != SOC_TPLG_PASS_PCM_DAI)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\tlist_del(&dobj->list);\n\tsnd_soc_remove_pcm_runtime(comp->card,\n\t\t\tsnd_soc_get_pcm_runtime(comp->card, link));\n}\n\n \nstatic void remove_backend_link(struct snd_soc_component *comp,\n\tstruct snd_soc_dobj *dobj, int pass)\n{\n\tif (pass != SOC_TPLG_PASS_LINK)\n\t\treturn;\n\n\tif (dobj->unload)\n\t\tdobj->unload(comp, dobj);\n\n\t \n\tdobj->type = SND_SOC_DOBJ_NONE;\n\tlist_del(&dobj->list);\n}\n\n \nstatic int soc_tplg_kcontrol_bind_io(struct snd_soc_tplg_ctl_hdr *hdr,\n\tstruct snd_kcontrol_new *k,\n\tconst struct soc_tplg *tplg)\n{\n\tconst struct snd_soc_tplg_kcontrol_ops *ops;\n\tconst struct snd_soc_tplg_bytes_ext_ops *ext_ops;\n\tint num_ops, i;\n\n\tif (le32_to_cpu(hdr->ops.info) == SND_SOC_TPLG_CTL_BYTES\n\t\t&& k->iface & SNDRV_CTL_ELEM_IFACE_MIXER\n\t\t&& (k->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ\n\t\t    || k->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE)\n\t\t&& k->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\tstruct soc_bytes_ext *sbe;\n\t\tstruct snd_soc_tplg_bytes_control *be;\n\n\t\tsbe = (struct soc_bytes_ext *)k->private_value;\n\t\tbe = container_of(hdr, struct snd_soc_tplg_bytes_control, hdr);\n\n\t\t \n\t\tk->info = snd_soc_bytes_info_ext;\n\t\tk->tlv.c = snd_soc_bytes_tlv_callback;\n\n\t\t \n\t\tif (sbe->max > 512)\n\t\t\tk->access |= SNDRV_CTL_ELEM_ACCESS_SKIP_CHECK;\n\n\t\text_ops = tplg->bytes_ext_ops;\n\t\tnum_ops = tplg->bytes_ext_ops_count;\n\t\tfor (i = 0; i < num_ops; i++) {\n\t\t\tif (!sbe->put &&\n\t\t\t    ext_ops[i].id == le32_to_cpu(be->ext_ops.put))\n\t\t\t\tsbe->put = ext_ops[i].put;\n\t\t\tif (!sbe->get &&\n\t\t\t    ext_ops[i].id == le32_to_cpu(be->ext_ops.get))\n\t\t\t\tsbe->get = ext_ops[i].get;\n\t\t}\n\n\t\tif ((k->access & SNDRV_CTL_ELEM_ACCESS_TLV_READ) && !sbe->get)\n\t\t\treturn -EINVAL;\n\t\tif ((k->access & SNDRV_CTL_ELEM_ACCESS_TLV_WRITE) && !sbe->put)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\n\t \n\tops = tplg->io_ops;\n\tnum_ops = tplg->io_ops_count;\n\tfor (i = 0; i < num_ops; i++) {\n\n\t\tif (k->put == NULL && ops[i].id == le32_to_cpu(hdr->ops.put))\n\t\t\tk->put = ops[i].put;\n\t\tif (k->get == NULL && ops[i].id == le32_to_cpu(hdr->ops.get))\n\t\t\tk->get = ops[i].get;\n\t\tif (k->info == NULL && ops[i].id == le32_to_cpu(hdr->ops.info))\n\t\t\tk->info = ops[i].info;\n\t}\n\n\t \n\tif (k->put && k->get && k->info)\n\t\treturn 0;\n\n\t \n\tops = io_ops;\n\tnum_ops = ARRAY_SIZE(io_ops);\n\tfor (i = 0; i < num_ops; i++) {\n\n\t\tif (k->put == NULL && ops[i].id == le32_to_cpu(hdr->ops.put))\n\t\t\tk->put = ops[i].put;\n\t\tif (k->get == NULL && ops[i].id == le32_to_cpu(hdr->ops.get))\n\t\t\tk->get = ops[i].get;\n\t\tif (k->info == NULL && ops[i].id == le32_to_cpu(hdr->ops.info))\n\t\t\tk->info = ops[i].info;\n\t}\n\n\t \n\tif (k->put && k->get && k->info)\n\t\treturn 0;\n\n\t \n\treturn -EINVAL;\n}\n\n \nint snd_soc_tplg_widget_bind_event(struct snd_soc_dapm_widget *w,\n\t\tconst struct snd_soc_tplg_widget_events *events,\n\t\tint num_events, u16 event_type)\n{\n\tint i;\n\n\tw->event = NULL;\n\n\tfor (i = 0; i < num_events; i++) {\n\t\tif (event_type == events[i].type) {\n\n\t\t\t \n\t\t\tw->event = events[i].event_handler;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_tplg_widget_bind_event);\n\n \nstatic int soc_tplg_control_load(struct soc_tplg *tplg,\n\tstruct snd_kcontrol_new *k, struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tint ret = 0;\n\n\tif (tplg->ops && tplg->ops->control_load)\n\t\tret = tplg->ops->control_load(tplg->comp, tplg->index, k, hdr);\n\n\tif (ret)\n\t\tdev_err(tplg->dev, \"ASoC: failed to init %s\\n\", hdr->name);\n\n\treturn ret;\n}\n\n\nstatic int soc_tplg_create_tlv_db_scale(struct soc_tplg *tplg,\n\tstruct snd_kcontrol_new *kc, struct snd_soc_tplg_tlv_dbscale *scale)\n{\n\tunsigned int item_len = 2 * sizeof(unsigned int);\n\tunsigned int *p;\n\n\tp = devm_kzalloc(tplg->dev, item_len + 2 * sizeof(unsigned int), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp[0] = SNDRV_CTL_TLVT_DB_SCALE;\n\tp[1] = item_len;\n\tp[2] = le32_to_cpu(scale->min);\n\tp[3] = (le32_to_cpu(scale->step) & TLV_DB_SCALE_MASK)\n\t\t| (le32_to_cpu(scale->mute) ? TLV_DB_SCALE_MUTE : 0);\n\n\tkc->tlv.p = (void *)p;\n\treturn 0;\n}\n\nstatic int soc_tplg_create_tlv(struct soc_tplg *tplg,\n\tstruct snd_kcontrol_new *kc, struct snd_soc_tplg_ctl_hdr *tc)\n{\n\tstruct snd_soc_tplg_ctl_tlv *tplg_tlv;\n\tu32 access = le32_to_cpu(tc->access);\n\n\tif (!(access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE))\n\t\treturn 0;\n\n\tif (!(access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK)) {\n\t\ttplg_tlv = &tc->tlv;\n\t\tswitch (le32_to_cpu(tplg_tlv->type)) {\n\t\tcase SNDRV_CTL_TLVT_DB_SCALE:\n\t\t\treturn soc_tplg_create_tlv_db_scale(tplg, kc,\n\t\t\t\t\t&tplg_tlv->scale);\n\n\t\t \n\t\tdefault:\n\t\t\tdev_dbg(tplg->dev, \"Unsupported TLV type %d\\n\",\n\t\t\t\t\ttplg_tlv->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dbytes_create(struct soc_tplg *tplg, size_t size)\n{\n\tstruct snd_soc_tplg_bytes_control *be;\n\tstruct soc_bytes_ext *sbe;\n\tstruct snd_kcontrol_new kc;\n\tint ret = 0;\n\n\tif (soc_tplg_check_elem_count(tplg,\n\t\t\t\t      sizeof(struct snd_soc_tplg_bytes_control),\n\t\t\t\t      1, size, \"mixer bytes\"))\n\t\treturn -EINVAL;\n\n\tbe = (struct snd_soc_tplg_bytes_control *)tplg->pos;\n\n\t \n\tif (strnlen(be->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tsbe = devm_kzalloc(tplg->dev, sizeof(*sbe), GFP_KERNEL);\n\tif (sbe == NULL)\n\t\treturn -ENOMEM;\n\n\ttplg->pos += (sizeof(struct snd_soc_tplg_bytes_control) +\n\t\t      le32_to_cpu(be->priv.size));\n\n\tdev_dbg(tplg->dev,\n\t\t\"ASoC: adding bytes kcontrol %s with access 0x%x\\n\",\n\t\tbe->hdr.name, be->hdr.access);\n\n\tmemset(&kc, 0, sizeof(kc));\n\tkc.name = be->hdr.name;\n\tkc.private_value = (long)sbe;\n\tkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc.access = le32_to_cpu(be->hdr.access);\n\n\tsbe->max = le32_to_cpu(be->max);\n\tsbe->dobj.type = SND_SOC_DOBJ_BYTES;\n\tif (tplg->ops)\n\t\tsbe->dobj.unload = tplg->ops->control_unload;\n\tINIT_LIST_HEAD(&sbe->dobj.list);\n\n\t \n\tret = soc_tplg_kcontrol_bind_io(&be->hdr, &kc, tplg);\n\tif (ret) {\n\t\tsoc_control_err(tplg, &be->hdr, be->hdr.name);\n\t\tgoto err;\n\t}\n\n\t \n\tret = soc_tplg_control_load(tplg, &kc, &be->hdr);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = soc_tplg_add_kcontrol(tplg, &kc, &sbe->dobj.control.kcontrol);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tlist_add(&sbe->dobj.list, &tplg->comp->dobj_list);\n\nerr:\n\treturn ret;\n}\n\nstatic int soc_tplg_dmixer_create(struct soc_tplg *tplg, size_t size)\n{\n\tstruct snd_soc_tplg_mixer_control *mc;\n\tstruct soc_mixer_control *sm;\n\tstruct snd_kcontrol_new kc;\n\tint ret = 0;\n\n\tif (soc_tplg_check_elem_count(tplg,\n\t\t\t\t      sizeof(struct snd_soc_tplg_mixer_control),\n\t\t\t\t      1, size, \"mixers\"))\n\t\treturn -EINVAL;\n\n\tmc = (struct snd_soc_tplg_mixer_control *)tplg->pos;\n\n\t \n\tif (strnlen(mc->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tsm = devm_kzalloc(tplg->dev, sizeof(*sm), GFP_KERNEL);\n\tif (sm == NULL)\n\t\treturn -ENOMEM;\n\ttplg->pos += (sizeof(struct snd_soc_tplg_mixer_control) +\n\t\t      le32_to_cpu(mc->priv.size));\n\n\tdev_dbg(tplg->dev,\n\t\t\"ASoC: adding mixer kcontrol %s with access 0x%x\\n\",\n\t\tmc->hdr.name, mc->hdr.access);\n\n\tmemset(&kc, 0, sizeof(kc));\n\tkc.name = mc->hdr.name;\n\tkc.private_value = (long)sm;\n\tkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc.access = le32_to_cpu(mc->hdr.access);\n\n\t \n\tsm->reg = tplg_chan_get_reg(tplg, mc->channel, SNDRV_CHMAP_FL);\n\tsm->rreg = tplg_chan_get_reg(tplg, mc->channel, SNDRV_CHMAP_FR);\n\tsm->shift = tplg_chan_get_shift(tplg, mc->channel, SNDRV_CHMAP_FL);\n\tsm->rshift = tplg_chan_get_shift(tplg, mc->channel, SNDRV_CHMAP_FR);\n\n\tsm->max = le32_to_cpu(mc->max);\n\tsm->min = le32_to_cpu(mc->min);\n\tsm->invert = le32_to_cpu(mc->invert);\n\tsm->platform_max = le32_to_cpu(mc->platform_max);\n\tsm->dobj.index = tplg->index;\n\tsm->dobj.type = SND_SOC_DOBJ_MIXER;\n\tif (tplg->ops)\n\t\tsm->dobj.unload = tplg->ops->control_unload;\n\tINIT_LIST_HEAD(&sm->dobj.list);\n\n\t \n\tret = soc_tplg_kcontrol_bind_io(&mc->hdr, &kc, tplg);\n\tif (ret) {\n\t\tsoc_control_err(tplg, &mc->hdr, mc->hdr.name);\n\t\tgoto err;\n\t}\n\n\t \n\tret = soc_tplg_create_tlv(tplg, &kc, &mc->hdr);\n\tif (ret < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: failed to create TLV %s\\n\", mc->hdr.name);\n\t\tgoto err;\n\t}\n\n\t \n\tret = soc_tplg_control_load(tplg, &kc, &mc->hdr);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = soc_tplg_add_kcontrol(tplg, &kc, &sm->dobj.control.kcontrol);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tlist_add(&sm->dobj.list, &tplg->comp->dobj_list);\n\nerr:\n\treturn ret;\n}\n\nstatic int soc_tplg_denum_create_texts(struct soc_tplg *tplg, struct soc_enum *se,\n\t\t\t\t       struct snd_soc_tplg_enum_control *ec)\n{\n\tint i, ret;\n\n\tif (le32_to_cpu(ec->items) > ARRAY_SIZE(ec->texts))\n\t\treturn -EINVAL;\n\n\tse->dobj.control.dtexts =\n\t\tdevm_kcalloc(tplg->dev, le32_to_cpu(ec->items), sizeof(char *), GFP_KERNEL);\n\tif (se->dobj.control.dtexts == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < le32_to_cpu(ec->items); i++) {\n\n\t\tif (strnlen(ec->texts[i], SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tse->dobj.control.dtexts[i] = devm_kstrdup(tplg->dev, ec->texts[i], GFP_KERNEL);\n\t\tif (!se->dobj.control.dtexts[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tse->items = le32_to_cpu(ec->items);\n\tse->texts = (const char * const *)se->dobj.control.dtexts;\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int soc_tplg_denum_create_values(struct soc_tplg *tplg, struct soc_enum *se,\n\t\t\t\t\tstruct snd_soc_tplg_enum_control *ec)\n{\n\tint i;\n\n\t \n\tif (le32_to_cpu(ec->items) > SND_SOC_TPLG_NUM_TEXTS)\n\t\treturn -EINVAL;\n\n\tse->dobj.control.dvalues = devm_kcalloc(tplg->dev, le32_to_cpu(ec->items),\n\t\t\t\t\t   sizeof(*se->dobj.control.dvalues),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!se->dobj.control.dvalues)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(ec->items); i++) {\n\t\tse->dobj.control.dvalues[i] = le32_to_cpu(ec->values[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int soc_tplg_denum_create(struct soc_tplg *tplg, size_t size)\n{\n\tstruct snd_soc_tplg_enum_control *ec;\n\tstruct soc_enum *se;\n\tstruct snd_kcontrol_new kc;\n\tint ret = 0;\n\n\tif (soc_tplg_check_elem_count(tplg,\n\t\t\t\t      sizeof(struct snd_soc_tplg_enum_control),\n\t\t\t\t      1, size, \"enums\"))\n\t\treturn -EINVAL;\n\n\tec = (struct snd_soc_tplg_enum_control *)tplg->pos;\n\n\t \n\tif (strnlen(ec->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tse = devm_kzalloc(tplg->dev, (sizeof(*se)), GFP_KERNEL);\n\tif (se == NULL)\n\t\treturn -ENOMEM;\n\n\ttplg->pos += (sizeof(struct snd_soc_tplg_enum_control) +\n\t\t      le32_to_cpu(ec->priv.size));\n\n\tdev_dbg(tplg->dev, \"ASoC: adding enum kcontrol %s size %d\\n\",\n\t\tec->hdr.name, ec->items);\n\n\tmemset(&kc, 0, sizeof(kc));\n\tkc.name = ec->hdr.name;\n\tkc.private_value = (long)se;\n\tkc.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc.access = le32_to_cpu(ec->hdr.access);\n\n\tse->reg = tplg_chan_get_reg(tplg, ec->channel, SNDRV_CHMAP_FL);\n\tse->shift_l = tplg_chan_get_shift(tplg, ec->channel,\n\t\tSNDRV_CHMAP_FL);\n\tse->shift_r = tplg_chan_get_shift(tplg, ec->channel,\n\t\tSNDRV_CHMAP_FL);\n\n\tse->mask = le32_to_cpu(ec->mask);\n\tse->dobj.index = tplg->index;\n\tse->dobj.type = SND_SOC_DOBJ_ENUM;\n\tif (tplg->ops)\n\t\tse->dobj.unload = tplg->ops->control_unload;\n\tINIT_LIST_HEAD(&se->dobj.list);\n\n\tswitch (le32_to_cpu(ec->hdr.ops.info)) {\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\n\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\t\tret = soc_tplg_denum_create_values(tplg, se, ec);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev,\n\t\t\t\t\"ASoC: could not create values for %s\\n\",\n\t\t\t\tec->hdr.name);\n\t\t\tgoto err;\n\t\t}\n\t\tfallthrough;\n\tcase SND_SOC_TPLG_CTL_ENUM:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\n\t\tret = soc_tplg_denum_create_texts(tplg, se, ec);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev,\n\t\t\t\t\"ASoC: could not create texts for %s\\n\",\n\t\t\t\tec->hdr.name);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: invalid enum control type %d for %s\\n\",\n\t\t\tec->hdr.ops.info, ec->hdr.name);\n\t\tgoto err;\n\t}\n\n\t \n\tret = soc_tplg_kcontrol_bind_io(&ec->hdr, &kc, tplg);\n\tif (ret) {\n\t\tsoc_control_err(tplg, &ec->hdr, ec->hdr.name);\n\t\tgoto err;\n\t}\n\n\t \n\tret = soc_tplg_control_load(tplg, &kc, &ec->hdr);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = soc_tplg_add_kcontrol(tplg, &kc, &se->dobj.control.kcontrol);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tlist_add(&se->dobj.list, &tplg->comp->dobj_list);\n\nerr:\n\treturn ret;\n}\n\nstatic int soc_tplg_kcontrol_elems_load(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tint ret;\n\tint i;\n\n\tdev_dbg(tplg->dev, \"ASoC: adding %d kcontrols at 0x%lx\\n\", hdr->count,\n\t\tsoc_tplg_get_offset(tplg));\n\n\tfor (i = 0; i < le32_to_cpu(hdr->count); i++) {\n\t\tstruct snd_soc_tplg_ctl_hdr *control_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;\n\n\t\tif (le32_to_cpu(control_hdr->size) != sizeof(*control_hdr)) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid control size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (le32_to_cpu(control_hdr->ops.info)) {\n\t\tcase SND_SOC_TPLG_CTL_VOLSW:\n\t\tcase SND_SOC_TPLG_CTL_STROBE:\n\t\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\t\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\tcase SND_SOC_TPLG_CTL_RANGE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_VOLSW:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_PIN:\n\t\t\tret = soc_tplg_dmixer_create(tplg, le32_to_cpu(hdr->payload_size));\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_CTL_ENUM:\n\t\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\n\t\t\tret = soc_tplg_denum_create(tplg, le32_to_cpu(hdr->payload_size));\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\t\tret = soc_tplg_dbytes_create(tplg, le32_to_cpu(hdr->payload_size));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsoc_bind_err(tplg, control_hdr, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid control\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_add_route(struct soc_tplg *tplg,\n\tstruct snd_soc_dapm_route *route)\n{\n\tif (tplg->ops && tplg->ops->dapm_route_load)\n\t\treturn tplg->ops->dapm_route_load(tplg->comp, tplg->index,\n\t\t\troute);\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dapm_graph_elems_load(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tstruct snd_soc_dapm_context *dapm = &tplg->comp->dapm;\n\tstruct snd_soc_tplg_dapm_graph_elem *elem;\n\tstruct snd_soc_dapm_route *route;\n\tint count, i;\n\tint ret = 0;\n\n\tcount = le32_to_cpu(hdr->count);\n\n\tif (soc_tplg_check_elem_count(tplg,\n\t\t\t\t      sizeof(struct snd_soc_tplg_dapm_graph_elem),\n\t\t\t\t      count, le32_to_cpu(hdr->payload_size), \"graph\"))\n\t\treturn -EINVAL;\n\n\tdev_dbg(tplg->dev, \"ASoC: adding %d DAPM routes for index %d\\n\", count,\n\t\thdr->index);\n\n\tfor (i = 0; i < count; i++) {\n\t\troute = devm_kzalloc(tplg->dev, sizeof(*route), GFP_KERNEL);\n\t\tif (!route)\n\t\t\treturn -ENOMEM;\n\t\telem = (struct snd_soc_tplg_dapm_graph_elem *)tplg->pos;\n\t\ttplg->pos += sizeof(struct snd_soc_tplg_dapm_graph_elem);\n\n\t\t \n\t\tif (strnlen(elem->source, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\t\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (strnlen(elem->sink, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\t\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (strnlen(elem->control, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\t\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\troute->source = elem->source;\n\t\troute->sink = elem->sink;\n\n\t\t \n\t\troute->connected = NULL;\n\t\tif (strnlen(elem->control, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) == 0)\n\t\t\troute->control = NULL;\n\t\telse\n\t\t\troute->control = elem->control;\n\n\t\t \n\t\troute->dobj.type = SND_SOC_DOBJ_GRAPH;\n\t\tif (tplg->ops)\n\t\t\troute->dobj.unload = tplg->ops->dapm_route_unload;\n\t\troute->dobj.index = tplg->index;\n\t\tlist_add(&route->dobj.list, &tplg->comp->dobj_list);\n\n\t\tret = soc_tplg_add_route(tplg, route);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: topology: add_route failed: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsnd_soc_dapm_add_routes(dapm, route, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int soc_tplg_dapm_widget_dmixer_create(struct soc_tplg *tplg, struct snd_kcontrol_new *kc)\n{\n\tstruct soc_mixer_control *sm;\n\tstruct snd_soc_tplg_mixer_control *mc;\n\tint err;\n\n\tmc = (struct snd_soc_tplg_mixer_control *)tplg->pos;\n\n\t \n\tif (strnlen(mc->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tsm = devm_kzalloc(tplg->dev, sizeof(*sm), GFP_KERNEL);\n\tif (!sm)\n\t\treturn -ENOMEM;\n\n\ttplg->pos += sizeof(struct snd_soc_tplg_mixer_control) +\n\t\tle32_to_cpu(mc->priv.size);\n\n\tdev_dbg(tplg->dev, \" adding DAPM widget mixer control %s\\n\",\n\t\tmc->hdr.name);\n\n\tkc->private_value = (long)sm;\n\tkc->name = devm_kstrdup(tplg->dev, mc->hdr.name, GFP_KERNEL);\n\tif (!kc->name)\n\t\treturn -ENOMEM;\n\tkc->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc->access = le32_to_cpu(mc->hdr.access);\n\n\t \n\tsm->reg = tplg_chan_get_reg(tplg, mc->channel,\n\t\t\t\t    SNDRV_CHMAP_FL);\n\tsm->rreg = tplg_chan_get_reg(tplg, mc->channel,\n\t\t\t\t     SNDRV_CHMAP_FR);\n\tsm->shift = tplg_chan_get_shift(tplg, mc->channel,\n\t\t\t\t\tSNDRV_CHMAP_FL);\n\tsm->rshift = tplg_chan_get_shift(tplg, mc->channel,\n\t\t\t\t\t SNDRV_CHMAP_FR);\n\n\tsm->max = le32_to_cpu(mc->max);\n\tsm->min = le32_to_cpu(mc->min);\n\tsm->invert = le32_to_cpu(mc->invert);\n\tsm->platform_max = le32_to_cpu(mc->platform_max);\n\tsm->dobj.index = tplg->index;\n\tINIT_LIST_HEAD(&sm->dobj.list);\n\n\t \n\terr = soc_tplg_kcontrol_bind_io(&mc->hdr, kc, tplg);\n\tif (err) {\n\t\tsoc_control_err(tplg, &mc->hdr, mc->hdr.name);\n\t\treturn err;\n\t}\n\n\t \n\terr = soc_tplg_create_tlv(tplg, kc, &mc->hdr);\n\tif (err < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: failed to create TLV %s\\n\",\n\t\t\tmc->hdr.name);\n\t\treturn err;\n\t}\n\n\t \n\terr = soc_tplg_control_load(tplg, kc, &mc->hdr);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dapm_widget_denum_create(struct soc_tplg *tplg, struct snd_kcontrol_new *kc)\n{\n\tstruct snd_soc_tplg_enum_control *ec;\n\tstruct soc_enum *se;\n\tint err;\n\n\tec = (struct snd_soc_tplg_enum_control *)tplg->pos;\n\t \n\tif (strnlen(ec->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tse = devm_kzalloc(tplg->dev, sizeof(*se), GFP_KERNEL);\n\tif (!se)\n\t\treturn -ENOMEM;\n\n\ttplg->pos += (sizeof(struct snd_soc_tplg_enum_control) +\n\t\t      le32_to_cpu(ec->priv.size));\n\n\tdev_dbg(tplg->dev, \" adding DAPM widget enum control %s\\n\",\n\t\tec->hdr.name);\n\n\tkc->private_value = (long)se;\n\tkc->name = devm_kstrdup(tplg->dev, ec->hdr.name, GFP_KERNEL);\n\tif (!kc->name)\n\t\treturn -ENOMEM;\n\tkc->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc->access = le32_to_cpu(ec->hdr.access);\n\n\t \n\tse->reg = tplg_chan_get_reg(tplg, ec->channel, SNDRV_CHMAP_FL);\n\tse->shift_l = tplg_chan_get_shift(tplg, ec->channel,\n\t\t\t\t\t  SNDRV_CHMAP_FL);\n\tse->shift_r = tplg_chan_get_shift(tplg, ec->channel,\n\t\t\t\t\t  SNDRV_CHMAP_FR);\n\n\tse->items = le32_to_cpu(ec->items);\n\tse->mask = le32_to_cpu(ec->mask);\n\tse->dobj.index = tplg->index;\n\n\tswitch (le32_to_cpu(ec->hdr.ops.info)) {\n\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\n\t\terr = soc_tplg_denum_create_values(tplg, se, ec);\n\t\tif (err < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: could not create values for %s\\n\",\n\t\t\t\tec->hdr.name);\n\t\t\treturn err;\n\t\t}\n\t\tfallthrough;\n\tcase SND_SOC_TPLG_CTL_ENUM:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\n\t\terr = soc_tplg_denum_create_texts(tplg, se, ec);\n\t\tif (err < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: could not create texts for %s\\n\",\n\t\t\t\tec->hdr.name);\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tplg->dev, \"ASoC: invalid enum control type %d for %s\\n\",\n\t\t\tec->hdr.ops.info, ec->hdr.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = soc_tplg_kcontrol_bind_io(&ec->hdr, kc, tplg);\n\tif (err) {\n\t\tsoc_control_err(tplg, &ec->hdr, ec->hdr.name);\n\t\treturn err;\n\t}\n\n\t \n\terr = soc_tplg_control_load(tplg, kc, &ec->hdr);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dapm_widget_dbytes_create(struct soc_tplg *tplg, struct snd_kcontrol_new *kc)\n{\n\tstruct snd_soc_tplg_bytes_control *be;\n\tstruct soc_bytes_ext *sbe;\n\tint err;\n\n\tbe = (struct snd_soc_tplg_bytes_control *)tplg->pos;\n\n\t \n\tif (strnlen(be->hdr.name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t    SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tsbe = devm_kzalloc(tplg->dev, sizeof(*sbe), GFP_KERNEL);\n\tif (!sbe)\n\t\treturn -ENOMEM;\n\n\ttplg->pos += (sizeof(struct snd_soc_tplg_bytes_control) +\n\t\t      le32_to_cpu(be->priv.size));\n\n\tdev_dbg(tplg->dev,\n\t\t\"ASoC: adding bytes kcontrol %s with access 0x%x\\n\",\n\t\tbe->hdr.name, be->hdr.access);\n\n\tkc->private_value = (long)sbe;\n\tkc->name = devm_kstrdup(tplg->dev, be->hdr.name, GFP_KERNEL);\n\tif (!kc->name)\n\t\treturn -ENOMEM;\n\tkc->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc->access = le32_to_cpu(be->hdr.access);\n\n\tsbe->max = le32_to_cpu(be->max);\n\tINIT_LIST_HEAD(&sbe->dobj.list);\n\n\t \n\terr = soc_tplg_kcontrol_bind_io(&be->hdr, kc, tplg);\n\tif (err) {\n\t\tsoc_control_err(tplg, &be->hdr, be->hdr.name);\n\t\treturn err;\n\t}\n\n\t \n\terr = soc_tplg_control_load(tplg, kc, &be->hdr);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dapm_widget_create(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_context *dapm = &tplg->comp->dapm;\n\tstruct snd_soc_dapm_widget template, *widget;\n\tstruct snd_soc_tplg_ctl_hdr *control_hdr;\n\tstruct snd_soc_card *card = tplg->comp->card;\n\tunsigned int *kcontrol_type = NULL;\n\tstruct snd_kcontrol_new *kc;\n\tint mixer_count = 0;\n\tint bytes_count = 0;\n\tint enum_count = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (strnlen(w->name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\tif (strnlen(w->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) ==\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tdev_dbg(tplg->dev, \"ASoC: creating DAPM widget %s id %d\\n\",\n\t\tw->name, w->id);\n\n\tmemset(&template, 0, sizeof(template));\n\n\t \n\ttemplate.id = get_widget_id(le32_to_cpu(w->id));\n\tif ((int)template.id < 0)\n\t\treturn template.id;\n\n\t \n\ttemplate.name = kstrdup(w->name, GFP_KERNEL);\n\tif (!template.name)\n\t\treturn -ENOMEM;\n\ttemplate.sname = kstrdup(w->sname, GFP_KERNEL);\n\tif (!template.sname) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\ttemplate.reg = le32_to_cpu(w->reg);\n\ttemplate.shift = le32_to_cpu(w->shift);\n\ttemplate.mask = le32_to_cpu(w->mask);\n\ttemplate.subseq = le32_to_cpu(w->subseq);\n\ttemplate.on_val = w->invert ? 0 : 1;\n\ttemplate.off_val = w->invert ? 1 : 0;\n\ttemplate.ignore_suspend = le32_to_cpu(w->ignore_suspend);\n\ttemplate.event_flags = le16_to_cpu(w->event_flags);\n\ttemplate.dobj.index = tplg->index;\n\n\ttplg->pos +=\n\t\t(sizeof(struct snd_soc_tplg_dapm_widget) +\n\t\t le32_to_cpu(w->priv.size));\n\n\tif (w->num_kcontrols == 0) {\n\t\ttemplate.num_kcontrols = 0;\n\t\tgoto widget;\n\t}\n\n\ttemplate.num_kcontrols = le32_to_cpu(w->num_kcontrols);\n\tkc = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(*kc), GFP_KERNEL);\n\tif (!kc) {\n\t\tret = -ENOMEM;\n\t\tgoto hdr_err;\n\t}\n\n\tkcontrol_type = devm_kcalloc(tplg->dev, le32_to_cpu(w->num_kcontrols), sizeof(unsigned int),\n\t\t\t\t     GFP_KERNEL);\n\tif (!kcontrol_type) {\n\t\tret = -ENOMEM;\n\t\tgoto hdr_err;\n\t}\n\n\tfor (i = 0; i < le32_to_cpu(w->num_kcontrols); i++) {\n\t\tcontrol_hdr = (struct snd_soc_tplg_ctl_hdr *)tplg->pos;\n\t\tswitch (le32_to_cpu(control_hdr->ops.info)) {\n\t\tcase SND_SOC_TPLG_CTL_VOLSW:\n\t\tcase SND_SOC_TPLG_CTL_STROBE:\n\t\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\t\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\tcase SND_SOC_TPLG_CTL_RANGE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_VOLSW:\n\t\t\t \n\t\t\tkc[i].index = mixer_count;\n\t\t\tkcontrol_type[i] = SND_SOC_TPLG_TYPE_MIXER;\n\t\t\tmixer_count++;\n\t\t\tret = soc_tplg_dapm_widget_dmixer_create(tplg, &kc[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto hdr_err;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_CTL_ENUM:\n\t\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\n\t\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\n\t\t\t \n\t\t\tkc[i].index = enum_count;\n\t\t\tkcontrol_type[i] = SND_SOC_TPLG_TYPE_ENUM;\n\t\t\tenum_count++;\n\t\t\tret = soc_tplg_dapm_widget_denum_create(tplg, &kc[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto hdr_err;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\t\t \n\t\t\tkc[i].index = bytes_count;\n\t\t\tkcontrol_type[i] = SND_SOC_TPLG_TYPE_BYTES;\n\t\t\tbytes_count++;\n\t\t\tret = soc_tplg_dapm_widget_dbytes_create(tplg, &kc[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto hdr_err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid widget control type %d:%d:%d\\n\",\n\t\t\t\tcontrol_hdr->ops.get, control_hdr->ops.put,\n\t\t\t\tle32_to_cpu(control_hdr->ops.info));\n\t\t\tret = -EINVAL;\n\t\t\tgoto hdr_err;\n\t\t}\n\t}\n\n\ttemplate.kcontrol_news = kc;\n\tdev_dbg(tplg->dev, \"ASoC: template %s with %d/%d/%d (mixer/enum/bytes) control\\n\",\n\t\tw->name, mixer_count, enum_count, bytes_count);\n\nwidget:\n\tret = soc_tplg_widget_load(tplg, &template, w);\n\tif (ret < 0)\n\t\tgoto hdr_err;\n\n\t \n\tif (snd_soc_card_is_instantiated(card))\n\t\twidget = snd_soc_dapm_new_control(dapm, &template);\n\telse\n\t\twidget = snd_soc_dapm_new_control_unlocked(dapm, &template);\n\tif (IS_ERR(widget)) {\n\t\tret = PTR_ERR(widget);\n\t\tgoto hdr_err;\n\t}\n\n\twidget->dobj.type = SND_SOC_DOBJ_WIDGET;\n\twidget->dobj.widget.kcontrol_type = kcontrol_type;\n\tif (tplg->ops)\n\t\twidget->dobj.unload = tplg->ops->widget_unload;\n\twidget->dobj.index = tplg->index;\n\tlist_add(&widget->dobj.list, &tplg->comp->dobj_list);\n\n\tret = soc_tplg_widget_ready(tplg, widget, w);\n\tif (ret < 0)\n\t\tgoto ready_err;\n\n\tkfree(template.sname);\n\tkfree(template.name);\n\n\treturn 0;\n\nready_err:\n\tsoc_tplg_remove_widget(widget->dapm->component, &widget->dobj, SOC_TPLG_PASS_WIDGET);\n\tsnd_soc_dapm_free_widget(widget);\nhdr_err:\n\tkfree(template.sname);\nerr:\n\tkfree(template.name);\n\treturn ret;\n}\n\nstatic int soc_tplg_dapm_widget_elems_load(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tint count, i;\n\n\tcount = le32_to_cpu(hdr->count);\n\n\tdev_dbg(tplg->dev, \"ASoC: adding %d DAPM widgets\\n\", count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct snd_soc_tplg_dapm_widget *widget = (struct snd_soc_tplg_dapm_widget *) tplg->pos;\n\t\tint ret;\n\n\t\t \n\t\tif (soc_tplg_get_offset(tplg) + sizeof(*widget) >= tplg->fw->size) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid widget data size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (le32_to_cpu(widget->size) != sizeof(*widget)) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid widget size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (soc_tplg_get_offset(tplg) + le32_to_cpu(widget->priv.size) >= tplg->fw->size) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid widget private data size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = soc_tplg_dapm_widget_create(tplg, widget);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: failed to load widget %s\\n\",\n\t\t\t\twidget->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int soc_tplg_dapm_complete(struct soc_tplg *tplg)\n{\n\tstruct snd_soc_card *card = tplg->comp->card;\n\tint ret;\n\n\t \n\tif (!snd_soc_card_is_instantiated(card)) {\n\t\tdev_warn(tplg->dev, \"ASoC: Parent card not yet available, widget card binding deferred\\n\");\n\t\treturn 0;\n\t}\n\n\tret = snd_soc_dapm_new_widgets(card);\n\tif (ret < 0)\n\t\tdev_err(tplg->dev, \"ASoC: failed to create new widgets %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int set_stream_info(struct soc_tplg *tplg, struct snd_soc_pcm_stream *stream,\n\t\t\t   struct snd_soc_tplg_stream_caps *caps)\n{\n\tstream->stream_name = devm_kstrdup(tplg->dev, caps->name, GFP_KERNEL);\n\tif (!stream->stream_name)\n\t\treturn -ENOMEM;\n\n\tstream->channels_min = le32_to_cpu(caps->channels_min);\n\tstream->channels_max = le32_to_cpu(caps->channels_max);\n\tstream->rates = le32_to_cpu(caps->rates);\n\tstream->rate_min = le32_to_cpu(caps->rate_min);\n\tstream->rate_max = le32_to_cpu(caps->rate_max);\n\tstream->formats = le64_to_cpu(caps->formats);\n\tstream->sig_bits = le32_to_cpu(caps->sig_bits);\n\n\treturn 0;\n}\n\nstatic void set_dai_flags(struct snd_soc_dai_driver *dai_drv,\n\t\t\t  unsigned int flag_mask, unsigned int flags)\n{\n\tif (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_RATES)\n\t\tdai_drv->symmetric_rate =\n\t\t\t(flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_RATES) ? 1 : 0;\n\n\tif (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_CHANNELS)\n\t\tdai_drv->symmetric_channels =\n\t\t\t(flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_CHANNELS) ?\n\t\t\t1 : 0;\n\n\tif (flag_mask & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_SAMPLEBITS)\n\t\tdai_drv->symmetric_sample_bits =\n\t\t\t(flags & SND_SOC_TPLG_DAI_FLGBIT_SYMMETRIC_SAMPLEBITS) ?\n\t\t\t1 : 0;\n}\n\nstatic const struct snd_soc_dai_ops tplg_dai_ops = {\n\t.compress_new\t= snd_soc_new_compress,\n};\n\nstatic int soc_tplg_dai_create(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_pcm *pcm)\n{\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct snd_soc_pcm_stream *stream;\n\tstruct snd_soc_tplg_stream_caps *caps;\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(tplg->comp);\n\tint ret;\n\n\tdai_drv = devm_kzalloc(tplg->dev, sizeof(struct snd_soc_dai_driver), GFP_KERNEL);\n\tif (dai_drv == NULL)\n\t\treturn -ENOMEM;\n\n\tif (strlen(pcm->dai_name)) {\n\t\tdai_drv->name = devm_kstrdup(tplg->dev, pcm->dai_name, GFP_KERNEL);\n\t\tif (!dai_drv->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tdai_drv->id = le32_to_cpu(pcm->dai_id);\n\n\tif (pcm->playback) {\n\t\tstream = &dai_drv->playback;\n\t\tcaps = &pcm->caps[SND_SOC_TPLG_STREAM_PLAYBACK];\n\t\tret = set_stream_info(tplg, stream, caps);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (pcm->capture) {\n\t\tstream = &dai_drv->capture;\n\t\tcaps = &pcm->caps[SND_SOC_TPLG_STREAM_CAPTURE];\n\t\tret = set_stream_info(tplg, stream, caps);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (pcm->compress)\n\t\tdai_drv->ops = &tplg_dai_ops;\n\n\t \n\tret = soc_tplg_dai_load(tplg, dai_drv, pcm, NULL);\n\tif (ret < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: DAI loading failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdai_drv->dobj.index = tplg->index;\n\tdai_drv->dobj.type = SND_SOC_DOBJ_PCM;\n\tif (tplg->ops)\n\t\tdai_drv->dobj.unload = tplg->ops->dai_unload;\n\tlist_add(&dai_drv->dobj.list, &tplg->comp->dobj_list);\n\n\t \n\tdai = snd_soc_register_dai(tplg->comp, dai_drv, false);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\t \n\tret = snd_soc_dapm_new_dai_widgets(dapm, dai);\n\tif (ret != 0) {\n\t\tdev_err(dai->dev, \"Failed to create DAI widgets %d\\n\", ret);\n\t\tsnd_soc_unregister_dai(dai);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic void set_link_flags(struct snd_soc_dai_link *link,\n\t\tunsigned int flag_mask, unsigned int flags)\n{\n\tif (flag_mask & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_RATES)\n\t\tlink->symmetric_rate =\n\t\t\t(flags & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_RATES) ? 1 : 0;\n\n\tif (flag_mask & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_CHANNELS)\n\t\tlink->symmetric_channels =\n\t\t\t(flags & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_CHANNELS) ?\n\t\t\t1 : 0;\n\n\tif (flag_mask & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_SAMPLEBITS)\n\t\tlink->symmetric_sample_bits =\n\t\t\t(flags & SND_SOC_TPLG_LNK_FLGBIT_SYMMETRIC_SAMPLEBITS) ?\n\t\t\t1 : 0;\n\n\tif (flag_mask & SND_SOC_TPLG_LNK_FLGBIT_VOICE_WAKEUP)\n\t\tlink->ignore_suspend =\n\t\t\t(flags & SND_SOC_TPLG_LNK_FLGBIT_VOICE_WAKEUP) ?\n\t\t\t1 : 0;\n}\n\n \nstatic int soc_tplg_fe_link_create(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_pcm *pcm)\n{\n\tstruct snd_soc_dai_link *link;\n\tstruct snd_soc_dai_link_component *dlc;\n\tint ret;\n\n\t \n\tlink = devm_kzalloc(tplg->dev, sizeof(*link) + (3 * sizeof(*dlc)), GFP_KERNEL);\n\tif (link == NULL)\n\t\treturn -ENOMEM;\n\n\tdlc = (struct snd_soc_dai_link_component *)(link + 1);\n\n\tlink->cpus\t= &dlc[0];\n\tlink->num_cpus\t = 1;\n\n\tlink->dobj.index = tplg->index;\n\tlink->dobj.type = SND_SOC_DOBJ_DAI_LINK;\n\tif (tplg->ops)\n\t\tlink->dobj.unload = tplg->ops->link_unload;\n\n\tif (strlen(pcm->pcm_name)) {\n\t\tlink->name = devm_kstrdup(tplg->dev, pcm->pcm_name, GFP_KERNEL);\n\t\tlink->stream_name = devm_kstrdup(tplg->dev, pcm->pcm_name, GFP_KERNEL);\n\t\tif (!link->name || !link->stream_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tlink->id = le32_to_cpu(pcm->pcm_id);\n\n\tif (strlen(pcm->dai_name)) {\n\t\tlink->cpus->dai_name = devm_kstrdup(tplg->dev, pcm->dai_name, GFP_KERNEL);\n\t\tif (!link->cpus->dai_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tlink->codecs\t\t= &dlc[1];\t \n\tlink->codecs->name\t= \"snd-soc-dummy\";\n\tlink->codecs->dai_name\t= \"snd-soc-dummy-dai\";\n\tlink->num_codecs\t= 1;\n\n\tlink->platforms\t\t= &dlc[2];\t \n\tlink->platforms->name\t= \"snd-soc-dummy\";\n\tlink->num_platforms\t= 1;\n\n\t \n\tlink->dynamic = 1;\n\tlink->ignore_pmdown_time = 1;\n\tlink->dpcm_playback = le32_to_cpu(pcm->playback);\n\tlink->dpcm_capture = le32_to_cpu(pcm->capture);\n\tif (pcm->flag_mask)\n\t\tset_link_flags(link,\n\t\t\t       le32_to_cpu(pcm->flag_mask),\n\t\t\t       le32_to_cpu(pcm->flags));\n\n\t \n\tret = soc_tplg_dai_link_load(tplg, link, NULL);\n\tif (ret < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: FE link loading failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = snd_soc_add_pcm_runtimes(tplg->comp->card, link, 1);\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(tplg->dev, \"ASoC: adding FE link failed\\n\");\n\t\tgoto err;\n\t}\n\n\tlist_add(&link->dobj.list, &tplg->comp->dobj_list);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n \nstatic int soc_tplg_pcm_create(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_pcm *pcm)\n{\n\tint ret;\n\n\tret = soc_tplg_dai_create(tplg, pcm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn  soc_tplg_fe_link_create(tplg, pcm);\n}\n\n \nstatic void stream_caps_new_ver(struct snd_soc_tplg_stream_caps *dest,\n\t\t\t\tstruct snd_soc_tplg_stream_caps_v4 *src)\n{\n\tdest->size = cpu_to_le32(sizeof(*dest));\n\tmemcpy(dest->name, src->name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN);\n\tdest->formats = src->formats;\n\tdest->rates = src->rates;\n\tdest->rate_min = src->rate_min;\n\tdest->rate_max = src->rate_max;\n\tdest->channels_min = src->channels_min;\n\tdest->channels_max = src->channels_max;\n\tdest->periods_min = src->periods_min;\n\tdest->periods_max = src->periods_max;\n\tdest->period_size_min = src->period_size_min;\n\tdest->period_size_max = src->period_size_max;\n\tdest->buffer_size_min = src->buffer_size_min;\n\tdest->buffer_size_max = src->buffer_size_max;\n}\n\n \nstatic int pcm_new_ver(struct soc_tplg *tplg,\n\t\t       struct snd_soc_tplg_pcm *src,\n\t\t       struct snd_soc_tplg_pcm **pcm)\n{\n\tstruct snd_soc_tplg_pcm *dest;\n\tstruct snd_soc_tplg_pcm_v4 *src_v4;\n\tint i;\n\n\t*pcm = NULL;\n\n\tif (le32_to_cpu(src->size) != sizeof(*src_v4)) {\n\t\tdev_err(tplg->dev, \"ASoC: invalid PCM size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_warn(tplg->dev, \"ASoC: old version of PCM\\n\");\n\tsrc_v4 = (struct snd_soc_tplg_pcm_v4 *)src;\n\tdest = kzalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tdest->size = cpu_to_le32(sizeof(*dest));  \n\tmemcpy(dest->pcm_name, src_v4->pcm_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN);\n\tmemcpy(dest->dai_name, src_v4->dai_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN);\n\tdest->pcm_id = src_v4->pcm_id;\n\tdest->dai_id = src_v4->dai_id;\n\tdest->playback = src_v4->playback;\n\tdest->capture = src_v4->capture;\n\tdest->compress = src_v4->compress;\n\tdest->num_streams = src_v4->num_streams;\n\tfor (i = 0; i < le32_to_cpu(dest->num_streams); i++)\n\t\tmemcpy(&dest->stream[i], &src_v4->stream[i],\n\t\t       sizeof(struct snd_soc_tplg_stream));\n\n\tfor (i = 0; i < 2; i++)\n\t\tstream_caps_new_ver(&dest->caps[i], &src_v4->caps[i]);\n\n\t*pcm = dest;\n\treturn 0;\n}\n\nstatic int soc_tplg_pcm_elems_load(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tstruct snd_soc_tplg_pcm *pcm, *_pcm;\n\tint count;\n\tint size;\n\tint i;\n\tbool abi_match;\n\tint ret;\n\n\tcount = le32_to_cpu(hdr->count);\n\n\t \n\tpcm = (struct snd_soc_tplg_pcm *)tplg->pos;\n\tsize = le32_to_cpu(pcm->size);\n\tif (size > sizeof(struct snd_soc_tplg_pcm)\n\t\t|| size < sizeof(struct snd_soc_tplg_pcm_v4)) {\n\t\tdev_err(tplg->dev, \"ASoC: invalid size %d for PCM elems\\n\",\n\t\t\tsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_tplg_check_elem_count(tplg,\n\t\t\t\t      size, count,\n\t\t\t\t      le32_to_cpu(hdr->payload_size),\n\t\t\t\t      \"PCM DAI\"))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpcm = (struct snd_soc_tplg_pcm *)tplg->pos;\n\t\tsize = le32_to_cpu(pcm->size);\n\n\t\t \n\t\tif (size == sizeof(*pcm)) {\n\t\t\tabi_match = true;\n\t\t\t_pcm = pcm;\n\t\t} else {\n\t\t\tabi_match = false;\n\t\t\tret = pcm_new_ver(tplg, pcm, &_pcm);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = soc_tplg_pcm_create(tplg, _pcm);\n\t\tif (ret < 0) {\n\t\t\tif (!abi_match)\n\t\t\t\tkfree(_pcm);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\ttplg->pos += size + le32_to_cpu(_pcm->priv.size);\n\n\t\tif (!abi_match)\n\t\t\tkfree(_pcm);  \n\t}\n\n\tdev_dbg(tplg->dev, \"ASoC: adding %d PCM DAIs\\n\", count);\n\n\treturn 0;\n}\n\n \nstatic void set_link_hw_format(struct snd_soc_dai_link *link,\n\t\t\tstruct snd_soc_tplg_link_config *cfg)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config;\n\tunsigned char bclk_provider, fsync_provider;\n\tunsigned char invert_bclk, invert_fsync;\n\tint i;\n\n\tfor (i = 0; i < le32_to_cpu(cfg->num_hw_configs); i++) {\n\t\thw_config = &cfg->hw_config[i];\n\t\tif (hw_config->id != cfg->default_hw_config_id)\n\t\t\tcontinue;\n\n\t\tlink->dai_fmt = le32_to_cpu(hw_config->fmt) &\n\t\t\tSND_SOC_DAIFMT_FORMAT_MASK;\n\n\t\t \n\t\tswitch (hw_config->clock_gated) {\n\t\tcase SND_SOC_TPLG_DAI_CLK_GATE_GATED:\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_GATED;\n\t\t\tbreak;\n\n\t\tcase SND_SOC_TPLG_DAI_CLK_GATE_CONT:\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_CONT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tinvert_bclk = hw_config->invert_bclk;\n\t\tinvert_fsync = hw_config->invert_fsync;\n\t\tif (!invert_bclk && !invert_fsync)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_NB_NF;\n\t\telse if (!invert_bclk && invert_fsync)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_NB_IF;\n\t\telse if (invert_bclk && !invert_fsync)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_IB_NF;\n\t\telse\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_IB_IF;\n\n\t\t \n\t\tbclk_provider = (hw_config->bclk_provider ==\n\t\t\t       SND_SOC_TPLG_BCLK_CP);\n\t\tfsync_provider = (hw_config->fsync_provider ==\n\t\t\t\tSND_SOC_TPLG_FSYNC_CP);\n\t\tif (bclk_provider && fsync_provider)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t\telse if (!bclk_provider && fsync_provider)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_CBC_CFP;\n\t\telse if (bclk_provider && !fsync_provider)\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_CBP_CFC;\n\t\telse\n\t\t\tlink->dai_fmt |= SND_SOC_DAIFMT_CBC_CFC;\n\t}\n}\n\n \nstatic int link_new_ver(struct soc_tplg *tplg,\n\t\t\tstruct snd_soc_tplg_link_config *src,\n\t\t\tstruct snd_soc_tplg_link_config **link)\n{\n\tstruct snd_soc_tplg_link_config *dest;\n\tstruct snd_soc_tplg_link_config_v4 *src_v4;\n\tint i;\n\n\t*link = NULL;\n\n\tif (le32_to_cpu(src->size) !=\n\t    sizeof(struct snd_soc_tplg_link_config_v4)) {\n\t\tdev_err(tplg->dev, \"ASoC: invalid physical link config size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_warn(tplg->dev, \"ASoC: old version of physical link config\\n\");\n\n\tsrc_v4 = (struct snd_soc_tplg_link_config_v4 *)src;\n\tdest = kzalloc(sizeof(*dest), GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tdest->size = cpu_to_le32(sizeof(*dest));\n\tdest->id = src_v4->id;\n\tdest->num_streams = src_v4->num_streams;\n\tfor (i = 0; i < le32_to_cpu(dest->num_streams); i++)\n\t\tmemcpy(&dest->stream[i], &src_v4->stream[i],\n\t\t       sizeof(struct snd_soc_tplg_stream));\n\n\t*link = dest;\n\treturn 0;\n}\n\n \nstatic struct snd_soc_dai_link *snd_soc_find_dai_link(struct snd_soc_card *card,\n\t\t\t\t\t\t      int id, const char *name,\n\t\t\t\t\t\t      const char *stream_name)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tstruct snd_soc_dai_link *link = rtd->dai_link;\n\n\t\tif (link->id != id)\n\t\t\tcontinue;\n\n\t\tif (name && (!link->name || !strstr(link->name, name)))\n\t\t\tcontinue;\n\n\t\tif (stream_name && (!link->stream_name ||\n\t\t\t\t    !strstr(link->stream_name, stream_name)))\n\t\t\tcontinue;\n\n\t\treturn link;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int soc_tplg_link_config(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_link_config *cfg)\n{\n\tstruct snd_soc_dai_link *link;\n\tconst char *name, *stream_name;\n\tsize_t len;\n\tint ret;\n\n\tlen = strnlen(cfg->name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN);\n\tif (len == SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\telse if (len)\n\t\tname = cfg->name;\n\telse\n\t\tname = NULL;\n\n\tlen = strnlen(cfg->stream_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN);\n\tif (len == SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\treturn -EINVAL;\n\telse if (len)\n\t\tstream_name = cfg->stream_name;\n\telse\n\t\tstream_name = NULL;\n\n\tlink = snd_soc_find_dai_link(tplg->comp->card, le32_to_cpu(cfg->id),\n\t\t\t\t     name, stream_name);\n\tif (!link) {\n\t\tdev_err(tplg->dev, \"ASoC: physical link %s (id %d) not exist\\n\",\n\t\t\tname, cfg->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cfg->num_hw_configs)\n\t\tset_link_hw_format(link, cfg);\n\n\t \n\tif (cfg->flag_mask)\n\t\tset_link_flags(link,\n\t\t\t       le32_to_cpu(cfg->flag_mask),\n\t\t\t       le32_to_cpu(cfg->flags));\n\n\t \n\tret = soc_tplg_dai_link_load(tplg, link, cfg);\n\tif (ret < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: physical link loading failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tlink->dobj.index = tplg->index;\n\tlink->dobj.type = SND_SOC_DOBJ_BACKEND_LINK;\n\tif (tplg->ops)\n\t\tlink->dobj.unload = tplg->ops->link_unload;\n\tlist_add(&link->dobj.list, &tplg->comp->dobj_list);\n\n\treturn 0;\n}\n\n\n \nstatic int soc_tplg_link_elems_load(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tstruct snd_soc_tplg_link_config *link, *_link;\n\tint count;\n\tint size;\n\tint i, ret;\n\tbool abi_match;\n\n\tcount = le32_to_cpu(hdr->count);\n\n\t \n\tlink = (struct snd_soc_tplg_link_config *)tplg->pos;\n\tsize = le32_to_cpu(link->size);\n\tif (size > sizeof(struct snd_soc_tplg_link_config)\n\t\t|| size < sizeof(struct snd_soc_tplg_link_config_v4)) {\n\t\tdev_err(tplg->dev, \"ASoC: invalid size %d for physical link elems\\n\",\n\t\t\tsize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_tplg_check_elem_count(tplg, size, count,\n\t\t\t\t      le32_to_cpu(hdr->payload_size),\n\t\t\t\t      \"physical link config\"))\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tlink = (struct snd_soc_tplg_link_config *)tplg->pos;\n\t\tsize = le32_to_cpu(link->size);\n\t\tif (size == sizeof(*link)) {\n\t\t\tabi_match = true;\n\t\t\t_link = link;\n\t\t} else {\n\t\t\tabi_match = false;\n\t\t\tret = link_new_ver(tplg, link, &_link);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = soc_tplg_link_config(tplg, _link);\n\t\tif (ret < 0) {\n\t\t\tif (!abi_match)\n\t\t\t\tkfree(_link);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\ttplg->pos += size + le32_to_cpu(_link->priv.size);\n\n\t\tif (!abi_match)\n\t\t\tkfree(_link);  \n\t}\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_dai_config(struct soc_tplg *tplg,\n\t\t\t       struct snd_soc_tplg_dai *d)\n{\n\tstruct snd_soc_dai_link_component dai_component;\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct snd_soc_pcm_stream *stream;\n\tstruct snd_soc_tplg_stream_caps *caps;\n\tint ret;\n\n\tmemset(&dai_component, 0, sizeof(dai_component));\n\n\tdai_component.dai_name = d->dai_name;\n\tdai = snd_soc_find_dai(&dai_component);\n\tif (!dai) {\n\t\tdev_err(tplg->dev, \"ASoC: physical DAI %s not registered\\n\",\n\t\t\td->dai_name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(d->dai_id) != dai->id) {\n\t\tdev_err(tplg->dev, \"ASoC: physical DAI %s id mismatch\\n\",\n\t\t\td->dai_name);\n\t\treturn -EINVAL;\n\t}\n\n\tdai_drv = dai->driver;\n\tif (!dai_drv)\n\t\treturn -EINVAL;\n\n\tif (d->playback) {\n\t\tstream = &dai_drv->playback;\n\t\tcaps = &d->caps[SND_SOC_TPLG_STREAM_PLAYBACK];\n\t\tret = set_stream_info(tplg, stream, caps);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (d->capture) {\n\t\tstream = &dai_drv->capture;\n\t\tcaps = &d->caps[SND_SOC_TPLG_STREAM_CAPTURE];\n\t\tret = set_stream_info(tplg, stream, caps);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tif (d->flag_mask)\n\t\tset_dai_flags(dai_drv,\n\t\t\t      le32_to_cpu(d->flag_mask),\n\t\t\t      le32_to_cpu(d->flags));\n\n\t \n\tret = soc_tplg_dai_load(tplg, dai_drv, NULL, dai);\n\tif (ret < 0) {\n\t\tdev_err(tplg->dev, \"ASoC: DAI loading failed\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\n \nstatic int soc_tplg_dai_elems_load(struct soc_tplg *tplg,\n\t\t\t\t   struct snd_soc_tplg_hdr *hdr)\n{\n\tint count;\n\tint i;\n\n\tcount = le32_to_cpu(hdr->count);\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tstruct snd_soc_tplg_dai *dai = (struct snd_soc_tplg_dai *)tplg->pos;\n\t\tint ret;\n\n\t\tif (le32_to_cpu(dai->size) != sizeof(*dai)) {\n\t\t\tdev_err(tplg->dev, \"ASoC: invalid physical DAI size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = soc_tplg_dai_config(tplg, dai);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tplg->dev, \"ASoC: failed to configure DAI\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\ttplg->pos += (sizeof(*dai) + le32_to_cpu(dai->priv.size));\n\t}\n\n\tdev_dbg(tplg->dev, \"ASoC: Configure %d BE DAIs\\n\", count);\n\treturn 0;\n}\n\n \nstatic int manifest_new_ver(struct soc_tplg *tplg,\n\t\t\t    struct snd_soc_tplg_manifest *src,\n\t\t\t    struct snd_soc_tplg_manifest **manifest)\n{\n\tstruct snd_soc_tplg_manifest *dest;\n\tstruct snd_soc_tplg_manifest_v4 *src_v4;\n\tint size;\n\n\t*manifest = NULL;\n\n\tsize = le32_to_cpu(src->size);\n\tif (size != sizeof(*src_v4)) {\n\t\tdev_warn(tplg->dev, \"ASoC: invalid manifest size %d\\n\",\n\t\t\t size);\n\t\tif (size)\n\t\t\treturn -EINVAL;\n\t\tsrc->size = cpu_to_le32(sizeof(*src_v4));\n\t}\n\n\tdev_warn(tplg->dev, \"ASoC: old version of manifest\\n\");\n\n\tsrc_v4 = (struct snd_soc_tplg_manifest_v4 *)src;\n\tdest = kzalloc(sizeof(*dest) + le32_to_cpu(src_v4->priv.size),\n\t\t       GFP_KERNEL);\n\tif (!dest)\n\t\treturn -ENOMEM;\n\n\tdest->size = cpu_to_le32(sizeof(*dest));  \n\tdest->control_elems = src_v4->control_elems;\n\tdest->widget_elems = src_v4->widget_elems;\n\tdest->graph_elems = src_v4->graph_elems;\n\tdest->pcm_elems = src_v4->pcm_elems;\n\tdest->dai_link_elems = src_v4->dai_link_elems;\n\tdest->priv.size = src_v4->priv.size;\n\tif (dest->priv.size)\n\t\tmemcpy(dest->priv.data, src_v4->priv.data,\n\t\t       le32_to_cpu(src_v4->priv.size));\n\n\t*manifest = dest;\n\treturn 0;\n}\n\nstatic int soc_tplg_manifest_load(struct soc_tplg *tplg,\n\t\t\t\t  struct snd_soc_tplg_hdr *hdr)\n{\n\tstruct snd_soc_tplg_manifest *manifest, *_manifest;\n\tbool abi_match;\n\tint ret = 0;\n\n\tmanifest = (struct snd_soc_tplg_manifest *)tplg->pos;\n\n\t \n\tif (le32_to_cpu(manifest->size) == sizeof(*manifest)) {\n\t\tabi_match = true;\n\t\t_manifest = manifest;\n\t} else {\n\t\tabi_match = false;\n\n\t\tret = manifest_new_ver(tplg, manifest, &_manifest);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (tplg->ops && tplg->ops->manifest)\n\t\tret = tplg->ops->manifest(tplg->comp, tplg->index, _manifest);\n\n\tif (!abi_match)\t \n\t\tkfree(_manifest);\n\n\treturn ret;\n}\n\n \nstatic int soc_tplg_valid_header(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tif (le32_to_cpu(hdr->size) != sizeof(*hdr)) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: invalid header size for type %d at offset 0x%lx size 0x%zx.\\n\",\n\t\t\tle32_to_cpu(hdr->type), soc_tplg_get_hdr_offset(tplg),\n\t\t\ttplg->fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_tplg_get_hdr_offset(tplg) + le32_to_cpu(hdr->payload_size) >= tplg->fw->size) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: invalid header of type %d at offset %ld payload_size %d\\n\",\n\t\t\tle32_to_cpu(hdr->type), soc_tplg_get_hdr_offset(tplg),\n\t\t\thdr->payload_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(hdr->magic) == SOC_TPLG_MAGIC_BIG_ENDIAN) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: pass %d big endian not supported header got %x at offset 0x%lx size 0x%zx.\\n\",\n\t\t\ttplg->pass, hdr->magic,\n\t\t\tsoc_tplg_get_hdr_offset(tplg), tplg->fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(hdr->magic) != SND_SOC_TPLG_MAGIC) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: pass %d does not have a valid header got %x at offset 0x%lx size 0x%zx.\\n\",\n\t\t\ttplg->pass, hdr->magic,\n\t\t\tsoc_tplg_get_hdr_offset(tplg), tplg->fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(hdr->abi) > SND_SOC_TPLG_ABI_VERSION ||\n\t    le32_to_cpu(hdr->abi) < SND_SOC_TPLG_ABI_VERSION_MIN) {\n\t\tdev_err(tplg->dev,\n\t\t\t\"ASoC: pass %d invalid ABI version got 0x%x need 0x%x at offset 0x%lx size 0x%zx.\\n\",\n\t\t\ttplg->pass, hdr->abi,\n\t\t\tSND_SOC_TPLG_ABI_VERSION, soc_tplg_get_hdr_offset(tplg),\n\t\t\ttplg->fw->size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->payload_size == 0) {\n\t\tdev_err(tplg->dev, \"ASoC: header has 0 size at offset 0x%lx.\\n\",\n\t\t\tsoc_tplg_get_hdr_offset(tplg));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_load_header(struct soc_tplg *tplg,\n\tstruct snd_soc_tplg_hdr *hdr)\n{\n\tint (*elem_load)(struct soc_tplg *tplg,\n\t\t\t struct snd_soc_tplg_hdr *hdr);\n\tunsigned int hdr_pass;\n\n\ttplg->pos = tplg->hdr_pos + sizeof(struct snd_soc_tplg_hdr);\n\n\ttplg->index = le32_to_cpu(hdr->index);\n\n\tswitch (le32_to_cpu(hdr->type)) {\n\tcase SND_SOC_TPLG_TYPE_MIXER:\n\tcase SND_SOC_TPLG_TYPE_ENUM:\n\tcase SND_SOC_TPLG_TYPE_BYTES:\n\t\thdr_pass = SOC_TPLG_PASS_CONTROL;\n\t\telem_load = soc_tplg_kcontrol_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_DAPM_GRAPH:\n\t\thdr_pass = SOC_TPLG_PASS_GRAPH;\n\t\telem_load = soc_tplg_dapm_graph_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_DAPM_WIDGET:\n\t\thdr_pass = SOC_TPLG_PASS_WIDGET;\n\t\telem_load = soc_tplg_dapm_widget_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_PCM:\n\t\thdr_pass = SOC_TPLG_PASS_PCM_DAI;\n\t\telem_load = soc_tplg_pcm_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_DAI:\n\t\thdr_pass = SOC_TPLG_PASS_BE_DAI;\n\t\telem_load = soc_tplg_dai_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_DAI_LINK:\n\tcase SND_SOC_TPLG_TYPE_BACKEND_LINK:\n\t\t \n\t\thdr_pass = SOC_TPLG_PASS_LINK;\n\t\telem_load = soc_tplg_link_elems_load;\n\t\tbreak;\n\tcase SND_SOC_TPLG_TYPE_MANIFEST:\n\t\thdr_pass = SOC_TPLG_PASS_MANIFEST;\n\t\telem_load = soc_tplg_manifest_load;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thdr_pass = SOC_TPLG_PASS_VENDOR;\n\t\telem_load = soc_tplg_vendor_load;\n\t\tbreak;\n\t}\n\n\tif (tplg->pass == hdr_pass) {\n\t\tdev_dbg(tplg->dev,\n\t\t\t\"ASoC: Got 0x%x bytes of type %d version %d vendor %d at pass %d\\n\",\n\t\t\thdr->payload_size, hdr->type, hdr->version,\n\t\t\thdr->vendor_type, tplg->pass);\n\t\treturn elem_load(tplg, hdr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int soc_tplg_process_headers(struct soc_tplg *tplg)\n{\n\tint ret;\n\n\t \n\tfor (tplg->pass = SOC_TPLG_PASS_START; tplg->pass <= SOC_TPLG_PASS_END; tplg->pass++) {\n\t\tstruct snd_soc_tplg_hdr *hdr;\n\n\t\ttplg->hdr_pos = tplg->fw->data;\n\t\thdr = (struct snd_soc_tplg_hdr *)tplg->hdr_pos;\n\n\t\twhile (!soc_tplg_is_eof(tplg)) {\n\n\t\t\t \n\t\t\tret = soc_tplg_valid_header(tplg, hdr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tret = soc_tplg_load_header(tplg, hdr);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -EPROBE_DEFER) {\n\t\t\t\t\tdev_err(tplg->dev,\n\t\t\t\t\t\t\"ASoC: topology: could not load header: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\ttplg->hdr_pos += le32_to_cpu(hdr->payload_size) +\n\t\t\t\tsizeof(struct snd_soc_tplg_hdr);\n\t\t\thdr = (struct snd_soc_tplg_hdr *)tplg->hdr_pos;\n\t\t}\n\n\t}\n\n\t \n\tret = soc_tplg_dapm_complete(tplg);\n\n\treturn ret;\n}\n\nstatic int soc_tplg_load(struct soc_tplg *tplg)\n{\n\tint ret;\n\n\tret = soc_tplg_process_headers(tplg);\n\tif (ret == 0)\n\t\treturn soc_tplg_complete(tplg);\n\n\treturn ret;\n}\n\n \nint snd_soc_tplg_component_load(struct snd_soc_component *comp,\n\tstruct snd_soc_tplg_ops *ops, const struct firmware *fw)\n{\n\tstruct soc_tplg tplg;\n\tint ret;\n\n\t \n\tif (!comp || !comp->card || !comp->card->dev || !fw)\n\t\treturn -EINVAL;\n\n\t \n\tmemset(&tplg, 0, sizeof(tplg));\n\ttplg.fw = fw;\n\ttplg.dev = comp->card->dev;\n\ttplg.comp = comp;\n\tif (ops) {\n\t\ttplg.ops = ops;\n\t\ttplg.io_ops = ops->io_ops;\n\t\ttplg.io_ops_count = ops->io_ops_count;\n\t\ttplg.bytes_ext_ops = ops->bytes_ext_ops;\n\t\ttplg.bytes_ext_ops_count = ops->bytes_ext_ops_count;\n\t}\n\n\tret = soc_tplg_load(&tplg);\n\t \n\tif (ret)\n\t\tsnd_soc_tplg_component_remove(comp);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_tplg_component_load);\n\n \nint snd_soc_tplg_component_remove(struct snd_soc_component *comp)\n{\n\tstruct snd_soc_dobj *dobj, *next_dobj;\n\tint pass;\n\n\t \n\tfor (pass = SOC_TPLG_PASS_END; pass >= SOC_TPLG_PASS_START; pass--) {\n\n\t\t \n\t\tlist_for_each_entry_safe(dobj, next_dobj, &comp->dobj_list,\n\t\t\tlist) {\n\n\t\t\tswitch (dobj->type) {\n\t\t\tcase SND_SOC_DOBJ_BYTES:\n\t\t\tcase SND_SOC_DOBJ_ENUM:\n\t\t\tcase SND_SOC_DOBJ_MIXER:\n\t\t\t\tsoc_tplg_remove_kcontrol(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_DOBJ_GRAPH:\n\t\t\t\tsoc_tplg_remove_route(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_DOBJ_WIDGET:\n\t\t\t\tsoc_tplg_remove_widget(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_DOBJ_PCM:\n\t\t\t\tsoc_tplg_remove_dai(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_DOBJ_DAI_LINK:\n\t\t\t\tsoc_tplg_remove_link(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_DOBJ_BACKEND_LINK:\n\t\t\t\t \n\t\t\t\tremove_backend_link(comp, dobj, pass);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(comp->dev, \"ASoC: invalid component type %d for removal\\n\",\n\t\t\t\t\tdobj->type);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn !list_empty(&comp->dobj_list);\n}\nEXPORT_SYMBOL_GPL(snd_soc_tplg_component_remove);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}