{
  "module_name": "mxs-sgtl5000.c",
  "hash_id": "3b4ecdde532602abdbd933e4945606777d643dd25cbdc2976ab3c4dd6169b6b4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mxs/mxs-sgtl5000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/soc-dapm.h>\n\n#include \"../codecs/sgtl5000.h\"\n#include \"mxs-saif.h\"\n\nstatic int mxs_sgtl5000_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tunsigned int rate = params_rate(params);\n\tu32 mclk;\n\tint ret;\n\n\t \n\tswitch (rate) {\n\tcase 96000:\n\t\tmclk = 256 * rate;\n\t\tbreak;\n\tdefault:\n\t\tmclk = 512 * rate;\n\t\tbreak;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, SGTL5000_SYSCLK, mclk, 0);\n\tif (ret) {\n\t\tdev_err(codec_dai->dev, \"Failed to set sysclk to %u.%03uMHz\\n\",\n\t\t\tmclk / 1000000, mclk / 1000 % 1000);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(cpu_dai, MXS_SAIF_MCLK, mclk, 0);\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev, \"Failed to set sysclk to %u.%03uMHz\\n\",\n\t\t\tmclk / 1000000, mclk / 1000 % 1000);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops mxs_sgtl5000_hifi_ops = {\n\t.hw_params = mxs_sgtl5000_hw_params,\n};\n\n#define MXS_SGTL5000_DAI_FMT (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | \\\n\tSND_SOC_DAIFMT_CBS_CFS)\n\n\nSND_SOC_DAILINK_DEFS(hifi_tx,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"sgtl5000\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(hifi_rx,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"sgtl5000\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link mxs_sgtl5000_dai[] = {\n\t{\n\t\t.name\t\t= \"HiFi Tx\",\n\t\t.stream_name\t= \"HiFi Playback\",\n\t\t.dai_fmt\t= MXS_SGTL5000_DAI_FMT,\n\t\t.ops\t\t= &mxs_sgtl5000_hifi_ops,\n\t\t.playback_only\t= true,\n\t\tSND_SOC_DAILINK_REG(hifi_tx),\n\t}, {\n\t\t.name\t\t= \"HiFi Rx\",\n\t\t.stream_name\t= \"HiFi Capture\",\n\t\t.dai_fmt\t= MXS_SGTL5000_DAI_FMT,\n\t\t.ops\t\t= &mxs_sgtl5000_hifi_ops,\n\t\t.capture_only\t= true,\n\t\tSND_SOC_DAILINK_REG(hifi_rx),\n\t},\n};\n\nstatic const struct snd_soc_dapm_widget mxs_sgtl5000_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In Jack\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Line Out Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n};\n\nstatic struct snd_soc_card mxs_sgtl5000 = {\n\t.name\t\t= \"mxs_sgtl5000\",\n\t.owner\t\t= THIS_MODULE,\n\t.dai_link\t= mxs_sgtl5000_dai,\n\t.num_links\t= ARRAY_SIZE(mxs_sgtl5000_dai),\n};\n\nstatic int mxs_sgtl5000_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = &mxs_sgtl5000;\n\tint ret, i;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *saif_np[2], *codec_np;\n\n\tsaif_np[0] = of_parse_phandle(np, \"saif-controllers\", 0);\n\tsaif_np[1] = of_parse_phandle(np, \"saif-controllers\", 1);\n\tcodec_np = of_parse_phandle(np, \"audio-codec\", 0);\n\tif (!saif_np[0] || !saif_np[1] || !codec_np) {\n\t\tdev_err(&pdev->dev, \"phandle missing or invalid\\n\");\n\t\tof_node_put(codec_np);\n\t\tof_node_put(saif_np[0]);\n\t\tof_node_put(saif_np[1]);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tmxs_sgtl5000_dai[i].codecs->name = NULL;\n\t\tmxs_sgtl5000_dai[i].codecs->of_node = codec_np;\n\t\tmxs_sgtl5000_dai[i].cpus->dai_name = NULL;\n\t\tmxs_sgtl5000_dai[i].cpus->of_node = saif_np[i];\n\t\tmxs_sgtl5000_dai[i].platforms->name = NULL;\n\t\tmxs_sgtl5000_dai[i].platforms->of_node = saif_np[i];\n\t}\n\n\tof_node_put(codec_np);\n\tof_node_put(saif_np[0]);\n\tof_node_put(saif_np[1]);\n\n\t \n\tret = mxs_saif_get_mclk(0, 44100 * 256, 44100);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get mclk\\n\");\n\t\treturn ret;\n\t}\n\n\tcard->dev = &pdev->dev;\n\n\tif (of_property_present(np, \"audio-routing\")) {\n\t\tcard->dapm_widgets = mxs_sgtl5000_dapm_widgets;\n\t\tcard->num_dapm_widgets = ARRAY_SIZE(mxs_sgtl5000_dapm_widgets);\n\n\t\tret = snd_soc_of_parse_audio_routing(card, \"audio-routing\");\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse audio-routing (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"snd_soc_register_card failed\\n\");\n\n\treturn 0;\n}\n\nstatic void mxs_sgtl5000_remove(struct platform_device *pdev)\n{\n\tmxs_saif_put_mclk(0);\n}\n\nstatic const struct of_device_id mxs_sgtl5000_dt_ids[] = {\n\t{ .compatible = \"fsl,mxs-audio-sgtl5000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_sgtl5000_dt_ids);\n\nstatic struct platform_driver mxs_sgtl5000_audio_driver = {\n\t.driver = {\n\t\t.name = \"mxs-sgtl5000\",\n\t\t.of_match_table = mxs_sgtl5000_dt_ids,\n\t},\n\t.probe = mxs_sgtl5000_probe,\n\t.remove_new = mxs_sgtl5000_remove,\n};\n\nmodule_platform_driver(mxs_sgtl5000_audio_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"MXS ALSA SoC Machine driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxs-sgtl5000\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}