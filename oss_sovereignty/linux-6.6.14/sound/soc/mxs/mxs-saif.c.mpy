{
  "module_name": "mxs-saif.c",
  "hash_id": "9a03d4bc3b3e27e01013cba39da00083cbfe944fb5c3ff375f2bc966576b92c4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mxs/mxs-saif.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"mxs-saif.h\"\n\n#define MXS_SET_ADDR\t0x4\n#define MXS_CLR_ADDR\t0x8\n\nstatic struct mxs_saif *mxs_saif[2];\n\n \n\nstatic int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tswitch (clk_id) {\n\tcase MXS_SAIF_MCLK:\n\t\tsaif->mclk = freq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic inline struct mxs_saif *mxs_saif_get_master(struct mxs_saif * saif)\n{\n\treturn mxs_saif[saif->master_id];\n}\n\n \nstatic int mxs_saif_set_clk(struct mxs_saif *saif,\n\t\t\t\t  unsigned int mclk,\n\t\t\t\t  unsigned int rate)\n{\n\tu32 scr;\n\tint ret;\n\tstruct mxs_saif *master_saif;\n\n\tdev_dbg(saif->dev, \"mclk %d rate %d\\n\", mclk, rate);\n\n\t \n\tmaster_saif = mxs_saif_get_master(saif);\n\tif (!master_saif)\n\t\treturn -EINVAL;\n\n\tdev_dbg(saif->dev, \"master saif%d\\n\", master_saif->id);\n\n\t \n\tif (master_saif->ongoing && rate != master_saif->cur_rate) {\n\t\tdev_err(saif->dev,\n\t\t\t\"can not change clock, master saif%d(rate %d) is ongoing\\n\",\n\t\t\tmaster_saif->id, master_saif->cur_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tscr = __raw_readl(master_saif->base + SAIF_CTRL);\n\tscr &= ~BM_SAIF_CTRL_BITCLK_MULT_RATE;\n\tscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\n\n\t \n\tret = clk_prepare_enable(master_saif->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (master_saif->mclk_in_use) {\n\t\tswitch (mclk / rate) {\n\t\tcase 32:\n\t\tcase 64:\n\t\tcase 128:\n\t\tcase 256:\n\t\tcase 512:\n\t\t\tscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\n\t\t\tret = clk_set_rate(master_saif->clk, 512 * rate);\n\t\t\tbreak;\n\t\tcase 48:\n\t\tcase 96:\n\t\tcase 192:\n\t\tcase 384:\n\t\t\tscr |= BM_SAIF_CTRL_BITCLK_BASE_RATE;\n\t\t\tret = clk_set_rate(master_saif->clk, 384 * rate);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tclk_disable_unprepare(master_saif->clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tret = clk_set_rate(master_saif->clk, 512 * rate);\n\t\tscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\n\t}\n\n\tclk_disable_unprepare(master_saif->clk);\n\n\tif (ret)\n\t\treturn ret;\n\n\tmaster_saif->cur_rate = rate;\n\n\tif (!master_saif->mclk_in_use) {\n\t\t__raw_writel(scr, master_saif->base + SAIF_CTRL);\n\t\treturn 0;\n\t}\n\n\t \n\tswitch (mclk / rate) {\n\tcase 32:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(4);\n\t\tbreak;\n\tcase 64:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);\n\t\tbreak;\n\tcase 128:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);\n\t\tbreak;\n\tcase 256:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);\n\t\tbreak;\n\tcase 512:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);\n\t\tbreak;\n\tcase 48:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);\n\t\tbreak;\n\tcase 96:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);\n\t\tbreak;\n\tcase 192:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);\n\t\tbreak;\n\tcase 384:\n\t\tscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__raw_writel(scr, master_saif->base + SAIF_CTRL);\n\n\treturn 0;\n}\n\n \nint mxs_saif_put_mclk(unsigned int saif_id)\n{\n\tstruct mxs_saif *saif = mxs_saif[saif_id];\n\tu32 stat;\n\n\tif (!saif)\n\t\treturn -EINVAL;\n\n\tstat = __raw_readl(saif->base + SAIF_STAT);\n\tif (stat & BM_SAIF_STAT_BUSY) {\n\t\tdev_err(saif->dev, \"error: busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tclk_disable_unprepare(saif->clk);\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_CLKGATE,\n\t\tsaif->base + SAIF_CTRL + MXS_SET_ADDR);\n\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\n\tsaif->mclk_in_use = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mxs_saif_put_mclk);\n\n \nint mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,\n\t\t\t\t\tunsigned int rate)\n{\n\tstruct mxs_saif *saif = mxs_saif[saif_id];\n\tu32 stat;\n\tint ret;\n\tstruct mxs_saif *master_saif;\n\n\tif (!saif)\n\t\treturn -EINVAL;\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_SFTRST,\n\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_CLKGATE,\n\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\n\tmaster_saif = mxs_saif_get_master(saif);\n\tif (saif != master_saif) {\n\t\tdev_err(saif->dev, \"can not get mclk from a non-master saif\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstat = __raw_readl(saif->base + SAIF_STAT);\n\tif (stat & BM_SAIF_STAT_BUSY) {\n\t\tdev_err(saif->dev, \"error: busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tsaif->mclk_in_use = 1;\n\tret = mxs_saif_set_clk(saif, mclk, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(saif->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\tsaif->base + SAIF_CTRL + MXS_SET_ADDR);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mxs_saif_get_mclk);\n\n \nstatic int mxs_saif_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tu32 scr, stat;\n\tu32 scr0;\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tstat = __raw_readl(saif->base + SAIF_STAT);\n\tif (stat & BM_SAIF_STAT_BUSY) {\n\t\tdev_err(cpu_dai->dev, \"error: busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (saif->id != saif->master_id) {\n\t\t__raw_writel(BM_SAIF_CTRL_SFTRST,\n\t\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\t\t__raw_writel(BM_SAIF_CTRL_CLKGATE,\n\t\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\t}\n\n\tscr0 = __raw_readl(saif->base + SAIF_CTRL);\n\tscr0 = scr0 & ~BM_SAIF_CTRL_BITCLK_EDGE & ~BM_SAIF_CTRL_LRCLK_POLARITY \\\n\t\t& ~BM_SAIF_CTRL_JUSTIFY & ~BM_SAIF_CTRL_DELAY;\n\tscr = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tscr |= BM_SAIF_CTRL_DELAY;\n\t\tscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\tscr &= ~BM_SAIF_CTRL_DELAY;\n\t\tscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tscr &= ~BM_SAIF_CTRL_JUSTIFY;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tscr |= BM_SAIF_CTRL_BITCLK_EDGE;\n\t\tscr |= BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tscr |= BM_SAIF_CTRL_BITCLK_EDGE;\n\t\tscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tscr &= ~BM_SAIF_CTRL_BITCLK_EDGE;\n\t\tscr |= BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tscr &= ~BM_SAIF_CTRL_BITCLK_EDGE;\n\t\tscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tif (saif->id == saif->master_id)\n\t\t\tscr &= ~BM_SAIF_CTRL_SLAVE_MODE;\n\t\telse\n\t\t\tscr |= BM_SAIF_CTRL_SLAVE_MODE;\n\n\t\t__raw_writel(scr | scr0, saif->base + SAIF_CTRL);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mxs_saif_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\t \n\tsaif->fifo_underrun = 0;\n\tsaif->fifo_overrun = 0;\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_SFTRST,\n\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_CLKGATE,\n\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\n\tret = clk_prepare(saif->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void mxs_saif_shutdown(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *cpu_dai)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tclk_unprepare(saif->clk);\n}\n\n \nstatic int mxs_saif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct mxs_saif *master_saif;\n\tu32 scr, stat;\n\tint ret;\n\n\tmaster_saif = mxs_saif_get_master(saif);\n\tif (!master_saif)\n\t\treturn -EINVAL;\n\n\t \n\tif (!saif->mclk && saif->mclk_in_use) {\n\t\tdev_err(cpu_dai->dev, \"set mclk first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstat = __raw_readl(saif->base + SAIF_STAT);\n\tif (!saif->mclk_in_use && (stat & BM_SAIF_STAT_BUSY)) {\n\t\tdev_err(cpu_dai->dev, \"error: busy\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = mxs_saif_set_clk(saif, saif->mclk, params_rate(params));\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev, \"unable to get proper clk\\n\");\n\t\treturn ret;\n\t}\n\n\tif (saif != master_saif) {\n\t\t \n\t\tret = clk_enable(saif->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_set_rate(saif->clk, 24000000);\n\t\tclk_disable(saif->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare(master_saif->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tscr = __raw_readl(saif->base + SAIF_CTRL);\n\n\tscr &= ~BM_SAIF_CTRL_WORD_LENGTH;\n\tscr &= ~BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tscr |= BF_SAIF_CTRL_WORD_LENGTH(0);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tscr |= BF_SAIF_CTRL_WORD_LENGTH(4);\n\t\tscr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tscr |= BF_SAIF_CTRL_WORD_LENGTH(8);\n\t\tscr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\tscr &= ~BM_SAIF_CTRL_READ_MODE;\n\t} else {\n\t\t \n\t\tscr |= BM_SAIF_CTRL_READ_MODE;\n\t}\n\n\t__raw_writel(scr, saif->base + SAIF_CTRL);\n\treturn 0;\n}\n\nstatic int mxs_saif_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\n\t \n\t__raw_writel(BM_SAIF_CTRL_FIFO_ERROR_IRQ_EN,\n\t\tsaif->base + SAIF_CTRL + MXS_SET_ADDR);\n\n\treturn 0;\n}\n\nstatic int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct mxs_saif *master_saif;\n\tu32 delay;\n\tint ret;\n\n\tmaster_saif = mxs_saif_get_master(saif);\n\tif (!master_saif)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (saif->state == MXS_SAIF_STATE_RUNNING)\n\t\t\treturn 0;\n\n\t\tdev_dbg(cpu_dai->dev, \"start\\n\");\n\n\t\tret = clk_enable(master_saif->clk);\n\t\tif (ret) {\n\t\t\tdev_err(saif->dev, \"Failed to enable master clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (saif != master_saif) {\n\t\t\tret = clk_enable(saif->clk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(saif->dev, \"Failed to enable master clock\\n\");\n\t\t\t\tclk_disable(master_saif->clk);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\t\t\tsaif->base + SAIF_CTRL + MXS_SET_ADDR);\n\t\t}\n\n\t\tif (!master_saif->mclk_in_use)\n\t\t\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\t\t\tmaster_saif->base + SAIF_CTRL + MXS_SET_ADDR);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t \n\t\t\t__raw_writel(0, saif->base + SAIF_DATA);\n\t\t\t__raw_writel(0, saif->base + SAIF_DATA);\n\t\t} else {\n\t\t\t \n\t\t\t__raw_readl(saif->base + SAIF_DATA);\n\t\t\t__raw_readl(saif->base + SAIF_DATA);\n\t\t}\n\n\t\tmaster_saif->ongoing = 1;\n\t\tsaif->state = MXS_SAIF_STATE_RUNNING;\n\n\t\tdev_dbg(saif->dev, \"CTRL 0x%x STAT 0x%x\\n\",\n\t\t\t__raw_readl(saif->base + SAIF_CTRL),\n\t\t\t__raw_readl(saif->base + SAIF_STAT));\n\n\t\tdev_dbg(master_saif->dev, \"CTRL 0x%x STAT 0x%x\\n\",\n\t\t\t__raw_readl(master_saif->base + SAIF_CTRL),\n\t\t\t__raw_readl(master_saif->base + SAIF_STAT));\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (saif->state == MXS_SAIF_STATE_STOPPED)\n\t\t\treturn 0;\n\n\t\tdev_dbg(cpu_dai->dev, \"stop\\n\");\n\n\t\t \n\t\tdelay = USEC_PER_SEC / master_saif->cur_rate;\n\n\t\tif (!master_saif->mclk_in_use) {\n\t\t\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\t\t\tmaster_saif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\t\t\tudelay(delay);\n\t\t}\n\t\tclk_disable(master_saif->clk);\n\n\t\tif (saif != master_saif) {\n\t\t\t__raw_writel(BM_SAIF_CTRL_RUN,\n\t\t\t\tsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\n\t\t\tudelay(delay);\n\t\t\tclk_disable(saif->clk);\n\t\t}\n\n\t\tmaster_saif->ongoing = 0;\n\t\tsaif->state = MXS_SAIF_STATE_STOPPED;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define MXS_SAIF_RATES\t\tSNDRV_PCM_RATE_8000_192000\n#define MXS_SAIF_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops mxs_saif_dai_ops = {\n\t.startup = mxs_saif_startup,\n\t.shutdown = mxs_saif_shutdown,\n\t.trigger = mxs_saif_trigger,\n\t.prepare = mxs_saif_prepare,\n\t.hw_params = mxs_saif_hw_params,\n\t.set_sysclk = mxs_saif_set_dai_sysclk,\n\t.set_fmt = mxs_saif_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver mxs_saif_dai = {\n\t.name = \"mxs-saif\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = MXS_SAIF_RATES,\n\t\t.formats = MXS_SAIF_FORMATS,\n\t},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = MXS_SAIF_RATES,\n\t\t.formats = MXS_SAIF_FORMATS,\n\t},\n\t.ops = &mxs_saif_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver mxs_saif_component = {\n\t.name\t\t\t= \"mxs-saif\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic irqreturn_t mxs_saif_irq(int irq, void *dev_id)\n{\n\tstruct mxs_saif *saif = dev_id;\n\tunsigned int stat;\n\n\tstat = __raw_readl(saif->base + SAIF_STAT);\n\tif (!(stat & (BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ |\n\t\t\tBM_SAIF_STAT_FIFO_OVERFLOW_IRQ)))\n\t\treturn IRQ_NONE;\n\n\tif (stat & BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ) {\n\t\tdev_dbg(saif->dev, \"underrun!!! %d\\n\", ++saif->fifo_underrun);\n\t\t__raw_writel(BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ,\n\t\t\t\tsaif->base + SAIF_STAT + MXS_CLR_ADDR);\n\t}\n\n\tif (stat & BM_SAIF_STAT_FIFO_OVERFLOW_IRQ) {\n\t\tdev_dbg(saif->dev, \"overrun!!! %d\\n\", ++saif->fifo_overrun);\n\t\t__raw_writel(BM_SAIF_STAT_FIFO_OVERFLOW_IRQ,\n\t\t\t\tsaif->base + SAIF_STAT + MXS_CLR_ADDR);\n\t}\n\n\tdev_dbg(saif->dev, \"SAIF_CTRL %x SAIF_STAT %x\\n\",\n\t       __raw_readl(saif->base + SAIF_CTRL),\n\t       __raw_readl(saif->base + SAIF_STAT));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxs_saif_mclk_init(struct platform_device *pdev)\n{\n\tstruct mxs_saif *saif = platform_get_drvdata(pdev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk *clk;\n\tint ret;\n\n\tclk = clk_register_divider(&pdev->dev, \"mxs_saif_mclk\",\n\t\t\t\t   __clk_get_name(saif->clk), 0,\n\t\t\t\t   saif->base + SAIF_CTRL,\n\t\t\t\t   BP_SAIF_CTRL_BITCLK_MULT_RATE, 3,\n\t\t\t\t   0, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tif (ret == -EEXIST)\n\t\t\treturn 0;\n\t\tdev_err(&pdev->dev, \"failed to register mclk: %d\\n\", ret);\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tret = of_clk_add_provider(np, of_clk_src_simple_get, clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int mxs_saif_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mxs_saif *saif;\n\tint irq, ret;\n\tstruct device_node *master;\n\n\tsaif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);\n\tif (!saif)\n\t\treturn -ENOMEM;\n\n\tret = of_alias_get_id(np, \"saif\");\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\tsaif->id = ret;\n\n\tif (saif->id >= ARRAY_SIZE(mxs_saif)) {\n\t\tdev_err(&pdev->dev, \"get wrong saif id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmaster = of_parse_phandle(np, \"fsl,saif-master\", 0);\n\tif (!master) {\n\t\tsaif->master_id = saif->id;\n\t} else {\n\t\tret = of_alias_get_id(master, \"saif\");\n\t\tof_node_put(master);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse\n\t\t\tsaif->master_id = ret;\n\n\t\tif (saif->master_id >= ARRAY_SIZE(mxs_saif)) {\n\t\t\tdev_err(&pdev->dev, \"get wrong master id\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmxs_saif[saif->id] = saif;\n\n\tsaif->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(saif->clk)) {\n\t\tret = PTR_ERR(saif->clk);\n\t\tdev_err(&pdev->dev, \"Cannot get the clock: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tsaif->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(saif->base))\n\t\treturn PTR_ERR(saif->base);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tsaif->dev = &pdev->dev;\n\tret = devm_request_irq(&pdev->dev, irq, mxs_saif_irq, 0,\n\t\t\t       dev_name(&pdev->dev), saif);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to request irq\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, saif);\n\n\t \n\tif (saif->id == 0) {\n\t\tret = mxs_saif_mclk_init(pdev);\n\t\tif (ret)\n\t\t\tdev_warn(&pdev->dev, \"failed to init clocks\\n\");\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &mxs_saif_component,\n\t\t\t\t\t      &mxs_saif_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"register DAI failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = mxs_pcm_platform_register(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"register PCM failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id mxs_saif_dt_ids[] = {\n\t{ .compatible = \"fsl,imx28-saif\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_saif_dt_ids);\n\nstatic struct platform_driver mxs_saif_driver = {\n\t.probe = mxs_saif_probe,\n\n\t.driver = {\n\t\t.name = \"mxs-saif\",\n\t\t.of_match_table = mxs_saif_dt_ids,\n\t},\n};\n\nmodule_platform_driver(mxs_saif_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"MXS ASoC SAIF driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxs-saif\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}