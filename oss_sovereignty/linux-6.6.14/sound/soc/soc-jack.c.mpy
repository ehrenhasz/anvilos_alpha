{
  "module_name": "soc-jack.c",
  "hash_id": "cce9aa709fe28324e65683fcca2446d37bcc597996eda8c5fb5d6e6f722401bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-jack.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/jack.h>\n#include <sound/soc.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <trace/events/asoc.h>\n\n \nvoid snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct snd_soc_jack_pin *pin;\n\tunsigned int sync = 0;\n\n\tif (!jack || !jack->jack)\n\t\treturn;\n\ttrace_snd_soc_jack_report(jack, mask, status);\n\n\tdapm = &jack->card->dapm;\n\n\tmutex_lock(&jack->mutex);\n\n\tjack->status &= ~mask;\n\tjack->status |= status & mask;\n\n\ttrace_snd_soc_jack_notify(jack, status);\n\n\tlist_for_each_entry(pin, &jack->pins, list) {\n\t\tint enable = pin->mask & jack->status;\n\n\t\tif (pin->invert)\n\t\t\tenable = !enable;\n\n\t\tif (enable)\n\t\t\tsnd_soc_dapm_enable_pin(dapm, pin->pin);\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin(dapm, pin->pin);\n\n\t\t \n\t\tsync = 1;\n\t}\n\n\t \n\tblocking_notifier_call_chain(&jack->notifier, jack->status, jack);\n\n\tif (sync)\n\t\tsnd_soc_dapm_sync(dapm);\n\n\tsnd_jack_report(jack->jack, jack->status);\n\n\tmutex_unlock(&jack->mutex);\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_report);\n\n \nint snd_soc_jack_add_zones(struct snd_soc_jack *jack, int count,\n\t\t\t  struct snd_soc_jack_zone *zones)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tINIT_LIST_HEAD(&zones[i].list);\n\t\tlist_add(&(zones[i].list), &jack->jack_zones);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_add_zones);\n\n \nint snd_soc_jack_get_type(struct snd_soc_jack *jack, int micbias_voltage)\n{\n\tstruct snd_soc_jack_zone *zone;\n\n\tlist_for_each_entry(zone, &jack->jack_zones, list) {\n\t\tif (micbias_voltage >= zone->min_mv &&\n\t\t\tmicbias_voltage < zone->max_mv)\n\t\t\t\treturn zone->jack_type;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_get_type);\n\n \nint snd_soc_jack_add_pins(struct snd_soc_jack *jack, int count,\n\t\t\t  struct snd_soc_jack_pin *pins)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!pins[i].pin) {\n\t\t\tdev_err(jack->card->dev, \"ASoC: No name for pin %d\\n\",\n\t\t\t\ti);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!pins[i].mask) {\n\t\t\tdev_err(jack->card->dev, \"ASoC: No mask for pin %d\"\n\t\t\t\t\" (%s)\\n\", i, pins[i].pin);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&pins[i].list);\n\t\tlist_add(&(pins[i].list), &jack->pins);\n\t\tsnd_jack_add_new_kctl(jack->jack, pins[i].pin, pins[i].mask);\n\t}\n\n\t \n\tsnd_soc_jack_report(jack, 0, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_add_pins);\n\n \nvoid snd_soc_jack_notifier_register(struct snd_soc_jack *jack,\n\t\t\t\t    struct notifier_block *nb)\n{\n\tblocking_notifier_chain_register(&jack->notifier, nb);\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_notifier_register);\n\n \nvoid snd_soc_jack_notifier_unregister(struct snd_soc_jack *jack,\n\t\t\t\t      struct notifier_block *nb)\n{\n\tblocking_notifier_chain_unregister(&jack->notifier, nb);\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_notifier_unregister);\n\n#ifdef CONFIG_GPIOLIB\nstruct jack_gpio_tbl {\n\tint count;\n\tstruct snd_soc_jack *jack;\n\tstruct snd_soc_jack_gpio *gpios;\n};\n\n \nstatic void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)\n{\n\tstruct snd_soc_jack *jack = gpio->jack;\n\tint enable;\n\tint report;\n\n\tenable = gpiod_get_value_cansleep(gpio->desc);\n\tif (gpio->invert)\n\t\tenable = !enable;\n\n\tif (enable)\n\t\treport = gpio->report;\n\telse\n\t\treport = 0;\n\n\tif (gpio->jack_status_check)\n\t\treport = gpio->jack_status_check(gpio->data);\n\n\tsnd_soc_jack_report(jack, report, gpio->report);\n}\n\n \nstatic irqreturn_t gpio_handler(int irq, void *data)\n{\n\tstruct snd_soc_jack_gpio *gpio = data;\n\tstruct device *dev = gpio->jack->card->dev;\n\n\ttrace_snd_soc_jack_irq(gpio->name);\n\n\tif (device_may_wakeup(dev))\n\t\tpm_wakeup_event(dev, gpio->debounce_time + 50);\n\n\tqueue_delayed_work(system_power_efficient_wq, &gpio->work,\n\t\t\t      msecs_to_jiffies(gpio->debounce_time));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void gpio_work(struct work_struct *work)\n{\n\tstruct snd_soc_jack_gpio *gpio;\n\n\tgpio = container_of(work, struct snd_soc_jack_gpio, work.work);\n\tsnd_soc_jack_gpio_detect(gpio);\n}\n\nstatic int snd_soc_jack_pm_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long action, void *data)\n{\n\tstruct snd_soc_jack_gpio *gpio =\n\t\t\tcontainer_of(nb, struct snd_soc_jack_gpio, pm_notifier);\n\n\tswitch (action) {\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\t \n\t\tqueue_delayed_work(system_power_efficient_wq, &gpio->work, 0);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void jack_free_gpios(struct snd_soc_jack *jack, int count,\n\t\t\t    struct snd_soc_jack_gpio *gpios)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgpiod_unexport(gpios[i].desc);\n\t\tunregister_pm_notifier(&gpios[i].pm_notifier);\n\t\tfree_irq(gpiod_to_irq(gpios[i].desc), &gpios[i]);\n\t\tcancel_delayed_work_sync(&gpios[i].work);\n\t\tgpiod_put(gpios[i].desc);\n\t\tgpios[i].jack = NULL;\n\t}\n}\n\nstatic void jack_devres_free_gpios(struct device *dev, void *res)\n{\n\tstruct jack_gpio_tbl *tbl = res;\n\n\tjack_free_gpios(tbl->jack, tbl->count, tbl->gpios);\n}\n\n \nint snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,\n\t\t\tstruct snd_soc_jack_gpio *gpios)\n{\n\tint i, ret;\n\tstruct jack_gpio_tbl *tbl;\n\n\ttbl = devres_alloc(jack_devres_free_gpios, sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl)\n\t\treturn -ENOMEM;\n\ttbl->jack = jack;\n\ttbl->count = count;\n\ttbl->gpios = gpios;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (!gpios[i].name) {\n\t\t\tdev_err(jack->card->dev,\n\t\t\t\t\"ASoC: No name for gpio at index %d\\n\", i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto undo;\n\t\t}\n\n\t\tif (gpios[i].desc) {\n\t\t\t \n\t\t\tgoto got_gpio;\n\t\t} else if (gpios[i].gpiod_dev) {\n\t\t\t \n\t\t\tgpios[i].desc = gpiod_get_index(gpios[i].gpiod_dev,\n\t\t\t\t\t\t\tgpios[i].name,\n\t\t\t\t\t\t\tgpios[i].idx, GPIOD_IN);\n\t\t\tif (IS_ERR(gpios[i].desc)) {\n\t\t\t\tret = PTR_ERR(gpios[i].desc);\n\t\t\t\tdev_err(gpios[i].gpiod_dev,\n\t\t\t\t\t\"ASoC: Cannot get gpio at index %d: %d\",\n\t\t\t\t\ti, ret);\n\t\t\t\tgoto undo;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!gpio_is_valid(gpios[i].gpio)) {\n\t\t\t\tdev_err(jack->card->dev,\n\t\t\t\t\t\"ASoC: Invalid gpio %d\\n\",\n\t\t\t\t\tgpios[i].gpio);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto undo;\n\t\t\t}\n\n\t\t\tret = gpio_request_one(gpios[i].gpio, GPIOF_IN,\n\t\t\t\t\t       gpios[i].name);\n\t\t\tif (ret)\n\t\t\t\tgoto undo;\n\n\t\t\tgpios[i].desc = gpio_to_desc(gpios[i].gpio);\n\t\t}\ngot_gpio:\n\t\tINIT_DELAYED_WORK(&gpios[i].work, gpio_work);\n\t\tgpios[i].jack = jack;\n\n\t\tret = request_any_context_irq(gpiod_to_irq(gpios[i].desc),\n\t\t\t\t\t      gpio_handler,\n\t\t\t\t\t      IRQF_SHARED |\n\t\t\t\t\t      IRQF_TRIGGER_RISING |\n\t\t\t\t\t      IRQF_TRIGGER_FALLING,\n\t\t\t\t\t      gpios[i].name,\n\t\t\t\t\t      &gpios[i]);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (gpios[i].wake) {\n\t\t\tret = irq_set_irq_wake(gpiod_to_irq(gpios[i].desc), 1);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(jack->card->dev,\n\t\t\t\t\t\"ASoC: Failed to mark GPIO at index %d as wake source: %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t}\n\n\t\t \n\t\tgpios[i].pm_notifier.notifier_call = snd_soc_jack_pm_notifier;\n\t\tregister_pm_notifier(&gpios[i].pm_notifier);\n\n\t\t \n\t\tgpiod_export(gpios[i].desc, false);\n\n\t\t \n\t\tschedule_delayed_work(&gpios[i].work,\n\t\t\t\t      msecs_to_jiffies(gpios[i].debounce_time));\n\t}\n\n\tdevres_add(jack->card->dev, tbl);\n\treturn 0;\n\nerr:\n\tgpio_free(gpios[i].gpio);\nundo:\n\tjack_free_gpios(jack, i, gpios);\n\tdevres_free(tbl);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_add_gpios);\n\n \nint snd_soc_jack_add_gpiods(struct device *gpiod_dev,\n\t\t\t    struct snd_soc_jack *jack,\n\t\t\t    int count, struct snd_soc_jack_gpio *gpios)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tgpios[i].gpiod_dev = gpiod_dev;\n\n\treturn snd_soc_jack_add_gpios(jack, count, gpios);\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_add_gpiods);\n\n \nvoid snd_soc_jack_free_gpios(struct snd_soc_jack *jack, int count,\n\t\t\tstruct snd_soc_jack_gpio *gpios)\n{\n\tjack_free_gpios(jack, count, gpios);\n\tdevres_destroy(jack->card->dev, jack_devres_free_gpios, NULL, NULL);\n}\nEXPORT_SYMBOL_GPL(snd_soc_jack_free_gpios);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}