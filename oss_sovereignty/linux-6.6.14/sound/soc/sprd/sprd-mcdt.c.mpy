{
  "module_name": "sprd-mcdt.c",
  "hash_id": "e3f946466192a8b5b6d615f3ee1369e00b313d06abbaacbeb4b062d859825750",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sprd/sprd-mcdt.c",
  "human_readable_source": "\n\n\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include \"sprd-mcdt.h\"\n\n \n#define MCDT_CH0_TXD\t\t0x0\n#define MCDT_CH0_RXD\t\t0x28\n#define MCDT_DAC0_WTMK\t\t0x60\n#define MCDT_ADC0_WTMK\t\t0x88\n#define MCDT_DMA_EN\t\t0xb0\n\n#define MCDT_INT_EN0\t\t0xb4\n#define MCDT_INT_EN1\t\t0xb8\n#define MCDT_INT_EN2\t\t0xbc\n\n#define MCDT_INT_CLR0\t\t0xc0\n#define MCDT_INT_CLR1\t\t0xc4\n#define MCDT_INT_CLR2\t\t0xc8\n\n#define MCDT_INT_RAW1\t\t0xcc\n#define MCDT_INT_RAW2\t\t0xd0\n#define MCDT_INT_RAW3\t\t0xd4\n\n#define MCDT_INT_MSK1\t\t0xd8\n#define MCDT_INT_MSK2\t\t0xdc\n#define MCDT_INT_MSK3\t\t0xe0\n\n#define MCDT_DAC0_FIFO_ADDR_ST\t0xe4\n#define MCDT_ADC0_FIFO_ADDR_ST\t0xe8\n\n#define MCDT_CH_FIFO_ST0\t0x134\n#define MCDT_CH_FIFO_ST1\t0x138\n#define MCDT_CH_FIFO_ST2\t0x13c\n\n#define MCDT_INT_MSK_CFG0\t0x140\n#define MCDT_INT_MSK_CFG1\t0x144\n\n#define MCDT_DMA_CFG0\t\t0x148\n#define MCDT_FIFO_CLR\t\t0x14c\n#define MCDT_DMA_CFG1\t\t0x150\n#define MCDT_DMA_CFG2\t\t0x154\n#define MCDT_DMA_CFG3\t\t0x158\n#define MCDT_DMA_CFG4\t\t0x15c\n#define MCDT_DMA_CFG5\t\t0x160\n\n \n#define MCDT_CH_FIFO_AE_SHIFT\t16\n#define MCDT_CH_FIFO_AE_MASK\tGENMASK(24, 16)\n#define MCDT_CH_FIFO_AF_MASK\tGENMASK(8, 0)\n\n \n#define MCDT_DMA_CH0_SEL_MASK\tGENMASK(3, 0)\n#define MCDT_DMA_CH0_SEL_SHIFT\t0\n#define MCDT_DMA_CH1_SEL_MASK\tGENMASK(7, 4)\n#define MCDT_DMA_CH1_SEL_SHIFT\t4\n#define MCDT_DMA_CH2_SEL_MASK\tGENMASK(11, 8)\n#define MCDT_DMA_CH2_SEL_SHIFT\t8\n#define MCDT_DMA_CH3_SEL_MASK\tGENMASK(15, 12)\n#define MCDT_DMA_CH3_SEL_SHIFT\t12\n#define MCDT_DMA_CH4_SEL_MASK\tGENMASK(19, 16)\n#define MCDT_DMA_CH4_SEL_SHIFT\t16\n#define MCDT_DAC_DMA_SHIFT\t16\n\n \n#define MCDT_DMA_ACK_SEL_MASK\tGENMASK(3, 0)\n\n \n#define MCDT_CH_FIFO_ADDR_SHIFT\t16\n#define MCDT_CH_FIFO_ADDR_MASK\tGENMASK(9, 0)\n#define MCDT_ADC_FIFO_SHIFT\t16\n#define MCDT_FIFO_LENGTH\t512\n\n#define MCDT_ADC_CHANNEL_NUM\t10\n#define MCDT_DAC_CHANNEL_NUM\t10\n#define MCDT_CHANNEL_NUM\t(MCDT_ADC_CHANNEL_NUM + MCDT_DAC_CHANNEL_NUM)\n\nenum sprd_mcdt_fifo_int {\n\tMCDT_ADC_FIFO_AE_INT,\n\tMCDT_ADC_FIFO_AF_INT,\n\tMCDT_DAC_FIFO_AE_INT,\n\tMCDT_DAC_FIFO_AF_INT,\n\tMCDT_ADC_FIFO_OV_INT,\n\tMCDT_DAC_FIFO_OV_INT\n};\n\nenum sprd_mcdt_fifo_sts {\n\tMCDT_ADC_FIFO_REAL_FULL,\n\tMCDT_ADC_FIFO_REAL_EMPTY,\n\tMCDT_ADC_FIFO_AF,\n\tMCDT_ADC_FIFO_AE,\n\tMCDT_DAC_FIFO_REAL_FULL,\n\tMCDT_DAC_FIFO_REAL_EMPTY,\n\tMCDT_DAC_FIFO_AF,\n\tMCDT_DAC_FIFO_AE\n};\n\nstruct sprd_mcdt_dev {\n\tstruct device *dev;\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tstruct sprd_mcdt_chan chan[MCDT_CHANNEL_NUM];\n};\n\nstatic LIST_HEAD(sprd_mcdt_chan_list);\nstatic DEFINE_MUTEX(sprd_mcdt_list_mutex);\n\nstatic void sprd_mcdt_update(struct sprd_mcdt_dev *mcdt, u32 reg, u32 val,\n\t\t\t     u32 mask)\n{\n\tu32 orig = readl_relaxed(mcdt->base + reg);\n\tu32 tmp;\n\n\ttmp = (orig & ~mask) | val;\n\twritel_relaxed(tmp, mcdt->base + reg);\n}\n\nstatic void sprd_mcdt_dac_set_watermark(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\tu32 full, u32 empty)\n{\n\tu32 reg = MCDT_DAC0_WTMK + channel * 4;\n\tu32 water_mark =\n\t\t(empty << MCDT_CH_FIFO_AE_SHIFT) & MCDT_CH_FIFO_AE_MASK;\n\n\twater_mark |= full & MCDT_CH_FIFO_AF_MASK;\n\tsprd_mcdt_update(mcdt, reg, water_mark,\n\t\t\t MCDT_CH_FIFO_AE_MASK | MCDT_CH_FIFO_AF_MASK);\n}\n\nstatic void sprd_mcdt_adc_set_watermark(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\tu32 full, u32 empty)\n{\n\tu32 reg = MCDT_ADC0_WTMK + channel * 4;\n\tu32 water_mark =\n\t\t(empty << MCDT_CH_FIFO_AE_SHIFT) & MCDT_CH_FIFO_AE_MASK;\n\n\twater_mark |= full & MCDT_CH_FIFO_AF_MASK;\n\tsprd_mcdt_update(mcdt, reg, water_mark,\n\t\t\t MCDT_CH_FIFO_AE_MASK | MCDT_CH_FIFO_AF_MASK);\n}\n\nstatic void sprd_mcdt_dac_dma_enable(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t     bool enable)\n{\n\tu32 shift = MCDT_DAC_DMA_SHIFT + channel;\n\n\tif (enable)\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_EN, BIT(shift), BIT(shift));\n\telse\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_EN, 0, BIT(shift));\n}\n\nstatic void sprd_mcdt_adc_dma_enable(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t     bool enable)\n{\n\tif (enable)\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_EN, BIT(channel), BIT(channel));\n\telse\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_EN, 0, BIT(channel));\n}\n\nstatic void sprd_mcdt_ap_int_enable(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t    bool enable)\n{\n\tif (enable)\n\t\tsprd_mcdt_update(mcdt, MCDT_INT_MSK_CFG0, BIT(channel),\n\t\t\t\t BIT(channel));\n\telse\n\t\tsprd_mcdt_update(mcdt, MCDT_INT_MSK_CFG0, 0, BIT(channel));\n}\n\nstatic void sprd_mcdt_dac_write_fifo(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t     u32 val)\n{\n\tu32 reg = MCDT_CH0_TXD + channel * 4;\n\n\twritel_relaxed(val, mcdt->base + reg);\n}\n\nstatic void sprd_mcdt_adc_read_fifo(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t    u32 *val)\n{\n\tu32 reg = MCDT_CH0_RXD + channel * 4;\n\n\t*val = readl_relaxed(mcdt->base + reg);\n}\n\nstatic void sprd_mcdt_dac_dma_chn_select(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\t enum sprd_mcdt_dma_chan dma_chan)\n{\n\tswitch (dma_chan) {\n\tcase SPRD_MCDT_DMA_CH0:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG0,\n\t\t\t\t channel << MCDT_DMA_CH0_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH0_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH1:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG0,\n\t\t\t\t channel << MCDT_DMA_CH1_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH1_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH2:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG0,\n\t\t\t\t channel << MCDT_DMA_CH2_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH2_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH3:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG0,\n\t\t\t\t channel << MCDT_DMA_CH3_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH3_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH4:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG0,\n\t\t\t\t channel << MCDT_DMA_CH4_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH4_SEL_MASK);\n\t\tbreak;\n\t}\n}\n\nstatic void sprd_mcdt_adc_dma_chn_select(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\t enum sprd_mcdt_dma_chan dma_chan)\n{\n\tswitch (dma_chan) {\n\tcase SPRD_MCDT_DMA_CH0:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG1,\n\t\t\t\t channel << MCDT_DMA_CH0_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH0_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH1:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG1,\n\t\t\t\t channel << MCDT_DMA_CH1_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH1_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH2:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG1,\n\t\t\t\t channel << MCDT_DMA_CH2_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH2_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH3:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG1,\n\t\t\t\t channel << MCDT_DMA_CH3_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH3_SEL_MASK);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DMA_CH4:\n\t\tsprd_mcdt_update(mcdt, MCDT_DMA_CFG1,\n\t\t\t\t channel << MCDT_DMA_CH4_SEL_SHIFT,\n\t\t\t\t MCDT_DMA_CH4_SEL_MASK);\n\t\tbreak;\n\t}\n}\n\nstatic u32 sprd_mcdt_dma_ack_shift(u8 channel)\n{\n\tswitch (channel) {\n\tdefault:\n\tcase 0:\n\tcase 8:\n\t\treturn 0;\n\tcase 1:\n\tcase 9:\n\t\treturn 4;\n\tcase 2:\n\t\treturn 8;\n\tcase 3:\n\t\treturn 12;\n\tcase 4:\n\t\treturn 16;\n\tcase 5:\n\t\treturn 20;\n\tcase 6:\n\t\treturn 24;\n\tcase 7:\n\t\treturn 28;\n\t}\n}\n\nstatic void sprd_mcdt_dac_dma_ack_select(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\t enum sprd_mcdt_dma_chan dma_chan)\n{\n\tu32 reg, shift = sprd_mcdt_dma_ack_shift(channel), ack = dma_chan;\n\n\tswitch (channel) {\n\tcase 0 ... 7:\n\t\treg = MCDT_DMA_CFG2;\n\t\tbreak;\n\n\tcase 8 ... 9:\n\t\treg = MCDT_DMA_CFG3;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tsprd_mcdt_update(mcdt, reg, ack << shift,\n\t\t\t MCDT_DMA_ACK_SEL_MASK << shift);\n}\n\nstatic void sprd_mcdt_adc_dma_ack_select(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t\t enum sprd_mcdt_dma_chan dma_chan)\n{\n\tu32 reg, shift = sprd_mcdt_dma_ack_shift(channel), ack = dma_chan;\n\n\tswitch (channel) {\n\tcase 0 ... 7:\n\t\treg = MCDT_DMA_CFG4;\n\t\tbreak;\n\n\tcase 8 ... 9:\n\t\treg = MCDT_DMA_CFG5;\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tsprd_mcdt_update(mcdt, reg, ack << shift,\n\t\t\t MCDT_DMA_ACK_SEL_MASK << shift);\n}\n\nstatic bool sprd_mcdt_chan_fifo_sts(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t    enum sprd_mcdt_fifo_sts fifo_sts)\n{\n\tu32 reg, shift;\n\n\tswitch (channel) {\n\tcase 0 ... 3:\n\t\treg = MCDT_CH_FIFO_ST0;\n\t\tbreak;\n\tcase 4 ... 7:\n\t\treg = MCDT_CH_FIFO_ST1;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\treg = MCDT_CH_FIFO_ST2;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tswitch (channel) {\n\tcase 0:\n\tcase 4:\n\tcase 8:\n\t\tshift = fifo_sts;\n\t\tbreak;\n\n\tcase 1:\n\tcase 5:\n\tcase 9:\n\t\tshift = 8 + fifo_sts;\n\t\tbreak;\n\n\tcase 2:\n\tcase 6:\n\t\tshift = 16 + fifo_sts;\n\t\tbreak;\n\n\tcase 3:\n\tcase 7:\n\t\tshift = 24 + fifo_sts;\n\t\tbreak;\n\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn !!(readl_relaxed(mcdt->base + reg) & BIT(shift));\n}\n\nstatic void sprd_mcdt_dac_fifo_clear(struct sprd_mcdt_dev *mcdt, u8 channel)\n{\n\tsprd_mcdt_update(mcdt, MCDT_FIFO_CLR, BIT(channel), BIT(channel));\n}\n\nstatic void sprd_mcdt_adc_fifo_clear(struct sprd_mcdt_dev *mcdt, u8 channel)\n{\n\tu32 shift = MCDT_ADC_FIFO_SHIFT + channel;\n\n\tsprd_mcdt_update(mcdt, MCDT_FIFO_CLR, BIT(shift), BIT(shift));\n}\n\nstatic u32 sprd_mcdt_dac_fifo_avail(struct sprd_mcdt_dev *mcdt, u8 channel)\n{\n\tu32 reg = MCDT_DAC0_FIFO_ADDR_ST + channel * 8;\n\tu32 r_addr = (readl_relaxed(mcdt->base + reg) >>\n\t\t      MCDT_CH_FIFO_ADDR_SHIFT) & MCDT_CH_FIFO_ADDR_MASK;\n\tu32 w_addr = readl_relaxed(mcdt->base + reg) & MCDT_CH_FIFO_ADDR_MASK;\n\n\tif (w_addr >= r_addr)\n\t\treturn 4 * (MCDT_FIFO_LENGTH - w_addr + r_addr);\n\telse\n\t\treturn 4 * (r_addr - w_addr);\n}\n\nstatic u32 sprd_mcdt_adc_fifo_avail(struct sprd_mcdt_dev *mcdt, u8 channel)\n{\n\tu32 reg = MCDT_ADC0_FIFO_ADDR_ST + channel * 8;\n\tu32 r_addr = (readl_relaxed(mcdt->base + reg) >>\n\t\t      MCDT_CH_FIFO_ADDR_SHIFT) & MCDT_CH_FIFO_ADDR_MASK;\n\tu32 w_addr = readl_relaxed(mcdt->base + reg) & MCDT_CH_FIFO_ADDR_MASK;\n\n\tif (w_addr >= r_addr)\n\t\treturn 4 * (w_addr - r_addr);\n\telse\n\t\treturn 4 * (MCDT_FIFO_LENGTH - r_addr + w_addr);\n}\n\nstatic u32 sprd_mcdt_int_type_shift(u8 channel,\n\t\t\t\t    enum sprd_mcdt_fifo_int int_type)\n{\n\tswitch (channel) {\n\tcase 0:\n\tcase 4:\n\tcase 8:\n\t\treturn int_type;\n\n\tcase 1:\n\tcase 5:\n\tcase 9:\n\t\treturn  8 + int_type;\n\n\tcase 2:\n\tcase 6:\n\t\treturn 16 + int_type;\n\n\tcase 3:\n\tcase 7:\n\t\treturn 24 + int_type;\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void sprd_mcdt_chan_int_en(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t  enum sprd_mcdt_fifo_int int_type, bool enable)\n{\n\tu32 reg, shift = sprd_mcdt_int_type_shift(channel, int_type);\n\n\tswitch (channel) {\n\tcase 0 ... 3:\n\t\treg = MCDT_INT_EN0;\n\t\tbreak;\n\tcase 4 ... 7:\n\t\treg = MCDT_INT_EN1;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\treg = MCDT_INT_EN2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tsprd_mcdt_update(mcdt, reg, BIT(shift), BIT(shift));\n\telse\n\t\tsprd_mcdt_update(mcdt, reg, 0, BIT(shift));\n}\n\nstatic void sprd_mcdt_chan_int_clear(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t     enum sprd_mcdt_fifo_int int_type)\n{\n\tu32 reg, shift = sprd_mcdt_int_type_shift(channel, int_type);\n\n\tswitch (channel) {\n\tcase 0 ... 3:\n\t\treg = MCDT_INT_CLR0;\n\t\tbreak;\n\tcase 4 ... 7:\n\t\treg = MCDT_INT_CLR1;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\treg = MCDT_INT_CLR2;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tsprd_mcdt_update(mcdt, reg, BIT(shift), BIT(shift));\n}\n\nstatic bool sprd_mcdt_chan_int_sts(struct sprd_mcdt_dev *mcdt, u8 channel,\n\t\t\t\t   enum sprd_mcdt_fifo_int int_type)\n{\n\tu32 reg, shift = sprd_mcdt_int_type_shift(channel, int_type);\n\n\tswitch (channel) {\n\tcase 0 ... 3:\n\t\treg = MCDT_INT_MSK1;\n\t\tbreak;\n\tcase 4 ... 7:\n\t\treg = MCDT_INT_MSK2;\n\t\tbreak;\n\tcase 8 ... 9:\n\t\treg = MCDT_INT_MSK3;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn !!(readl_relaxed(mcdt->base + reg) & BIT(shift));\n}\n\nstatic irqreturn_t sprd_mcdt_irq_handler(int irq, void *dev_id)\n{\n\tstruct sprd_mcdt_dev *mcdt = (struct sprd_mcdt_dev *)dev_id;\n\tint i;\n\n\tspin_lock(&mcdt->lock);\n\n\tfor (i = 0; i < MCDT_ADC_CHANNEL_NUM; i++) {\n\t\tif (sprd_mcdt_chan_int_sts(mcdt, i, MCDT_ADC_FIFO_AF_INT)) {\n\t\t\tstruct sprd_mcdt_chan *chan = &mcdt->chan[i];\n\n\t\t\tsprd_mcdt_chan_int_clear(mcdt, i, MCDT_ADC_FIFO_AF_INT);\n\t\t\tif (chan->cb)\n\t\t\t\tchan->cb->notify(chan->cb->data);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MCDT_DAC_CHANNEL_NUM; i++) {\n\t\tif (sprd_mcdt_chan_int_sts(mcdt, i, MCDT_DAC_FIFO_AE_INT)) {\n\t\t\tstruct sprd_mcdt_chan *chan =\n\t\t\t\t&mcdt->chan[i + MCDT_ADC_CHANNEL_NUM];\n\n\t\t\tsprd_mcdt_chan_int_clear(mcdt, i, MCDT_DAC_FIFO_AE_INT);\n\t\t\tif (chan->cb)\n\t\t\t\tchan->cb->notify(chan->cb->data);\n\t\t}\n\t}\n\n\tspin_unlock(&mcdt->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint sprd_mcdt_chan_write(struct sprd_mcdt_chan *chan, char *tx_buf, u32 size)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\tint avail, i = 0, words = size / 4;\n\tu32 *buf = (u32 *)tx_buf;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (chan->dma_enable) {\n\t\tdev_err(mcdt->dev,\n\t\t\t\"Can not write data when DMA mode enabled\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sprd_mcdt_chan_fifo_sts(mcdt, chan->id, MCDT_DAC_FIFO_REAL_FULL)) {\n\t\tdev_err(mcdt->dev, \"Channel fifo is full now\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tavail = sprd_mcdt_dac_fifo_avail(mcdt, chan->id);\n\tif (size > avail) {\n\t\tdev_err(mcdt->dev,\n\t\t\t\"Data size is larger than the available fifo size\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\twhile (i++ < words)\n\t\tsprd_mcdt_dac_write_fifo(mcdt, chan->id, *buf++);\n\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_write);\n\n \nint sprd_mcdt_chan_read(struct sprd_mcdt_chan *chan, char *rx_buf, u32 size)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\tint i = 0, avail, words = size / 4;\n\tu32 *buf = (u32 *)rx_buf;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (chan->dma_enable) {\n\t\tdev_err(mcdt->dev, \"Can not read data when DMA mode enabled\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sprd_mcdt_chan_fifo_sts(mcdt, chan->id, MCDT_ADC_FIFO_REAL_EMPTY)) {\n\t\tdev_err(mcdt->dev, \"Channel fifo is empty\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tavail = sprd_mcdt_adc_fifo_avail(mcdt, chan->id);\n\tif (size > avail)\n\t\twords = avail / 4;\n\n\twhile (i++ < words)\n\t\tsprd_mcdt_adc_read_fifo(mcdt, chan->id, buf++);\n\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\treturn words * 4;\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_read);\n\n \nint sprd_mcdt_chan_int_enable(struct sprd_mcdt_chan *chan, u32 water_mark,\n\t\t\t      struct sprd_mcdt_chan_callback *cb)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (chan->dma_enable || chan->int_enable) {\n\t\tdev_err(mcdt->dev, \"Failed to set interrupt mode.\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chan->type) {\n\tcase SPRD_MCDT_ADC_CHAN:\n\t\tsprd_mcdt_adc_fifo_clear(mcdt, chan->id);\n\t\tsprd_mcdt_adc_set_watermark(mcdt, chan->id, water_mark,\n\t\t\t\t\t    MCDT_FIFO_LENGTH - 1);\n\t\tsprd_mcdt_chan_int_en(mcdt, chan->id,\n\t\t\t\t      MCDT_ADC_FIFO_AF_INT, true);\n\t\tsprd_mcdt_ap_int_enable(mcdt, chan->id, true);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DAC_CHAN:\n\t\tsprd_mcdt_dac_fifo_clear(mcdt, chan->id);\n\t\tsprd_mcdt_dac_set_watermark(mcdt, chan->id,\n\t\t\t\t\t    MCDT_FIFO_LENGTH - 1, water_mark);\n\t\tsprd_mcdt_chan_int_en(mcdt, chan->id,\n\t\t\t\t      MCDT_DAC_FIFO_AE_INT, true);\n\t\tsprd_mcdt_ap_int_enable(mcdt, chan->id, true);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mcdt->dev, \"Unsupported channel type\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret) {\n\t\tchan->cb = cb;\n\t\tchan->int_enable = true;\n\t}\n\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_int_enable);\n\n \nvoid sprd_mcdt_chan_int_disable(struct sprd_mcdt_chan *chan)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (!chan->int_enable) {\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (chan->type) {\n\tcase SPRD_MCDT_ADC_CHAN:\n\t\tsprd_mcdt_chan_int_en(mcdt, chan->id,\n\t\t\t\t      MCDT_ADC_FIFO_AF_INT, false);\n\t\tsprd_mcdt_chan_int_clear(mcdt, chan->id, MCDT_ADC_FIFO_AF_INT);\n\t\tsprd_mcdt_ap_int_enable(mcdt, chan->id, false);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DAC_CHAN:\n\t\tsprd_mcdt_chan_int_en(mcdt, chan->id,\n\t\t\t\t      MCDT_DAC_FIFO_AE_INT, false);\n\t\tsprd_mcdt_chan_int_clear(mcdt, chan->id, MCDT_DAC_FIFO_AE_INT);\n\t\tsprd_mcdt_ap_int_enable(mcdt, chan->id, false);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tchan->int_enable = false;\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_int_disable);\n\n \nint sprd_mcdt_chan_dma_enable(struct sprd_mcdt_chan *chan,\n\t\t\t      enum sprd_mcdt_dma_chan dma_chan,\n\t\t\t      u32 water_mark)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (chan->dma_enable || chan->int_enable ||\n\t    dma_chan > SPRD_MCDT_DMA_CH4) {\n\t\tdev_err(mcdt->dev, \"Failed to set DMA mode\\n\");\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (chan->type) {\n\tcase SPRD_MCDT_ADC_CHAN:\n\t\tsprd_mcdt_adc_fifo_clear(mcdt, chan->id);\n\t\tsprd_mcdt_adc_set_watermark(mcdt, chan->id,\n\t\t\t\t\t    water_mark, MCDT_FIFO_LENGTH - 1);\n\t\tsprd_mcdt_adc_dma_enable(mcdt, chan->id, true);\n\t\tsprd_mcdt_adc_dma_chn_select(mcdt, chan->id, dma_chan);\n\t\tsprd_mcdt_adc_dma_ack_select(mcdt, chan->id, dma_chan);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DAC_CHAN:\n\t\tsprd_mcdt_dac_fifo_clear(mcdt, chan->id);\n\t\tsprd_mcdt_dac_set_watermark(mcdt, chan->id,\n\t\t\t\t\t    MCDT_FIFO_LENGTH - 1, water_mark);\n\t\tsprd_mcdt_dac_dma_enable(mcdt, chan->id, true);\n\t\tsprd_mcdt_dac_dma_chn_select(mcdt, chan->id, dma_chan);\n\t\tsprd_mcdt_dac_dma_ack_select(mcdt, chan->id, dma_chan);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mcdt->dev, \"Unsupported channel type\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tchan->dma_enable = true;\n\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_dma_enable);\n\n \nvoid sprd_mcdt_chan_dma_disable(struct sprd_mcdt_chan *chan)\n{\n\tstruct sprd_mcdt_dev *mcdt = chan->mcdt;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcdt->lock, flags);\n\n\tif (!chan->dma_enable) {\n\t\tspin_unlock_irqrestore(&mcdt->lock, flags);\n\t\treturn;\n\t}\n\n\tswitch (chan->type) {\n\tcase SPRD_MCDT_ADC_CHAN:\n\t\tsprd_mcdt_adc_dma_enable(mcdt, chan->id, false);\n\t\tsprd_mcdt_adc_fifo_clear(mcdt, chan->id);\n\t\tbreak;\n\n\tcase SPRD_MCDT_DAC_CHAN:\n\t\tsprd_mcdt_dac_dma_enable(mcdt, chan->id, false);\n\t\tsprd_mcdt_dac_fifo_clear(mcdt, chan->id);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tchan->dma_enable = false;\n\tspin_unlock_irqrestore(&mcdt->lock, flags);\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_chan_dma_disable);\n\n \nstruct sprd_mcdt_chan *sprd_mcdt_request_chan(u8 channel,\n\t\t\t\t\t      enum sprd_mcdt_channel_type type)\n{\n\tstruct sprd_mcdt_chan *temp;\n\n\tmutex_lock(&sprd_mcdt_list_mutex);\n\n\tlist_for_each_entry(temp, &sprd_mcdt_chan_list, list) {\n\t\tif (temp->type == type && temp->id == channel) {\n\t\t\tlist_del_init(&temp->list);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (list_entry_is_head(temp, &sprd_mcdt_chan_list, list))\n\t\ttemp = NULL;\n\n\tmutex_unlock(&sprd_mcdt_list_mutex);\n\n\treturn temp;\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_request_chan);\n\n \nvoid sprd_mcdt_free_chan(struct sprd_mcdt_chan *chan)\n{\n\tstruct sprd_mcdt_chan *temp;\n\n\tsprd_mcdt_chan_dma_disable(chan);\n\tsprd_mcdt_chan_int_disable(chan);\n\n\tmutex_lock(&sprd_mcdt_list_mutex);\n\n\tlist_for_each_entry(temp, &sprd_mcdt_chan_list, list) {\n\t\tif (temp == chan) {\n\t\t\tmutex_unlock(&sprd_mcdt_list_mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_add_tail(&chan->list, &sprd_mcdt_chan_list);\n\tmutex_unlock(&sprd_mcdt_list_mutex);\n}\nEXPORT_SYMBOL_GPL(sprd_mcdt_free_chan);\n\nstatic void sprd_mcdt_init_chans(struct sprd_mcdt_dev *mcdt,\n\t\t\t\t struct resource *res)\n{\n\tint i;\n\n\tfor (i = 0; i < MCDT_CHANNEL_NUM; i++) {\n\t\tstruct sprd_mcdt_chan *chan = &mcdt->chan[i];\n\n\t\tif (i < MCDT_ADC_CHANNEL_NUM) {\n\t\t\tchan->id = i;\n\t\t\tchan->type = SPRD_MCDT_ADC_CHAN;\n\t\t\tchan->fifo_phys = res->start + MCDT_CH0_RXD + i * 4;\n\t\t} else {\n\t\t\tchan->id = i - MCDT_ADC_CHANNEL_NUM;\n\t\t\tchan->type = SPRD_MCDT_DAC_CHAN;\n\t\t\tchan->fifo_phys = res->start + MCDT_CH0_TXD +\n\t\t\t\t(i - MCDT_ADC_CHANNEL_NUM) * 4;\n\t\t}\n\n\t\tchan->mcdt = mcdt;\n\t\tINIT_LIST_HEAD(&chan->list);\n\n\t\tmutex_lock(&sprd_mcdt_list_mutex);\n\t\tlist_add_tail(&chan->list, &sprd_mcdt_chan_list);\n\t\tmutex_unlock(&sprd_mcdt_list_mutex);\n\t}\n}\n\nstatic int sprd_mcdt_probe(struct platform_device *pdev)\n{\n\tstruct sprd_mcdt_dev *mcdt;\n\tstruct resource *res;\n\tint ret, irq;\n\n\tmcdt = devm_kzalloc(&pdev->dev, sizeof(*mcdt), GFP_KERNEL);\n\tif (!mcdt)\n\t\treturn -ENOMEM;\n\n\tmcdt->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(mcdt->base))\n\t\treturn PTR_ERR(mcdt->base);\n\n\tmcdt->dev = &pdev->dev;\n\tspin_lock_init(&mcdt->lock);\n\tplatform_set_drvdata(pdev, mcdt);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, sprd_mcdt_irq_handler,\n\t\t\t       0, \"sprd-mcdt\", mcdt);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request MCDT IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tsprd_mcdt_init_chans(mcdt, res);\n\n\treturn 0;\n}\n\nstatic void sprd_mcdt_remove(struct platform_device *pdev)\n{\n\tstruct sprd_mcdt_chan *chan, *temp;\n\n\tmutex_lock(&sprd_mcdt_list_mutex);\n\n\tlist_for_each_entry_safe(chan, temp, &sprd_mcdt_chan_list, list)\n\t\tlist_del(&chan->list);\n\n\tmutex_unlock(&sprd_mcdt_list_mutex);\n}\n\nstatic const struct of_device_id sprd_mcdt_of_match[] = {\n\t{ .compatible = \"sprd,sc9860-mcdt\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sprd_mcdt_of_match);\n\nstatic struct platform_driver sprd_mcdt_driver = {\n\t.probe = sprd_mcdt_probe,\n\t.remove_new = sprd_mcdt_remove,\n\t.driver = {\n\t\t.name = \"sprd-mcdt\",\n\t\t.of_match_table = sprd_mcdt_of_match,\n\t},\n};\n\nmodule_platform_driver(sprd_mcdt_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum Multi-Channel Data Transfer Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}