{
  "module_name": "sprd-pcm-compress.c",
  "hash_id": "4413f20ce3dfb222b950bb99e52c211865de4580f0cb9695d54e85f207618628",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sprd/sprd-pcm-compress.c",
  "human_readable_source": "\n\n\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/sprd-dma.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/compress_driver.h>\n\n#include \"sprd-pcm-dma.h\"\n\n#define SPRD_COMPR_DMA_CHANS\t\t2\n\n \n#define SPRD_COMPR_MIN_FRAGMENT_SIZE\tSZ_8K\n#define SPRD_COMPR_MAX_FRAGMENT_SIZE\tSZ_128K\n#define SPRD_COMPR_MIN_NUM_FRAGMENTS\t4\n#define SPRD_COMPR_MAX_NUM_FRAGMENTS\t64\n\n \n#define SPRD_COMPR_MCDT_EMPTY_WMK\t0\n#define SPRD_COMPR_MCDT_FIFO_SIZE\t512\n\n \n#define SPRD_COMPR_IRAM_BUF_SIZE\tSZ_32K\n#define SPRD_COMPR_IRAM_INFO_SIZE\t(sizeof(struct sprd_compr_playinfo))\n#define SPRD_COMPR_IRAM_LINKLIST_SIZE\t(1024 - SPRD_COMPR_IRAM_INFO_SIZE)\n#define SPRD_COMPR_IRAM_SIZE\t\t(SPRD_COMPR_IRAM_BUF_SIZE + \\\n\t\t\t\t\t SPRD_COMPR_IRAM_INFO_SIZE + \\\n\t\t\t\t\t SPRD_COMPR_IRAM_LINKLIST_SIZE)\n\n \n#define SPRD_COMPR_AREA_BUF_SIZE\tSZ_2M\n#define SPRD_COMPR_AREA_LINKLIST_SIZE\t1024\n#define SPRD_COMPR_AREA_SIZE\t\t(SPRD_COMPR_AREA_BUF_SIZE + \\\n\t\t\t\t\t SPRD_COMPR_AREA_LINKLIST_SIZE)\n\nstruct sprd_compr_dma {\n\tstruct dma_chan *chan;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tdma_addr_t phys;\n\tvoid *virt;\n\tint trans_len;\n};\n\n \nstruct sprd_compr_stream {\n\tstruct snd_compr_stream *cstream;\n\tstruct sprd_compr_ops *compr_ops;\n\tstruct sprd_compr_dma dma[SPRD_COMPR_DMA_CHANS];\n\n\t \n\tint num_channels;\n\n\t \n\tstruct snd_dma_buffer iram_buffer;\n\t \n\tstruct snd_dma_buffer compr_buffer;\n\n\t \n\tdma_addr_t info_phys;\n\tvoid *info_area;\n\tint info_size;\n\n\t \n\tint copied_total;\n\t \n\tint received_total;\n\t \n\tint received_stage0;\n\t \n\tint received_stage1;\n\t \n\tint stage1_pointer;\n};\n\nstatic int sprd_platform_compr_trigger(struct snd_soc_component *component,\n\t\t\t\t       struct snd_compr_stream *cstream,\n\t\t\t\t       int cmd);\n\nstatic void sprd_platform_compr_drain_notify(void *arg)\n{\n\tstruct snd_compr_stream *cstream = arg;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\n\tmemset(stream->info_area, 0, sizeof(struct sprd_compr_playinfo));\n\n\tsnd_compr_drain_notify(cstream);\n}\n\nstatic void sprd_platform_compr_dma_complete(void *data)\n{\n\tstruct snd_compr_stream *cstream = data;\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct sprd_compr_dma *dma = &stream->dma[1];\n\n\t \n\tstream->copied_total += dma->trans_len;\n\tif (stream->copied_total > stream->received_total)\n\t\tstream->copied_total = stream->received_total;\n\n\tsnd_compr_fragment_elapsed(cstream);\n}\n\nstatic int sprd_platform_compr_dma_config(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t\t\t  struct snd_compr_params *params,\n\t\t\t\t\t  int channel)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct device *dev = component->dev;\n\tstruct sprd_compr_data *data = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct sprd_pcm_dma_params *dma_params = data->dma_params;\n\tstruct sprd_compr_dma *dma = &stream->dma[channel];\n\tstruct dma_slave_config config = { };\n\tstruct sprd_dma_linklist link = { };\n\tenum dma_transfer_direction dir;\n\tstruct scatterlist *sg, *sgt;\n\tenum dma_slave_buswidth bus_width;\n\tint period, period_cnt, sg_num = 2;\n\tdma_addr_t src_addr, dst_addr;\n\tunsigned long flags;\n\tint ret, j;\n\n\tif (!dma_params) {\n\t\tdev_err(dev, \"no dma parameters setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdma->chan = dma_request_slave_channel(dev,\n\t\t\t\t\t      dma_params->chan_name[channel]);\n\tif (!dma->chan) {\n\t\tdev_err(dev, \"failed to request dma channel\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsgt = sg = devm_kcalloc(dev, sg_num, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto sg_err;\n\t}\n\n\tswitch (channel) {\n\tcase 0:\n\t\tbus_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tperiod = (SPRD_COMPR_MCDT_FIFO_SIZE - SPRD_COMPR_MCDT_EMPTY_WMK) * 4;\n\t\tperiod_cnt = params->buffer.fragment_size / period;\n\t\tsrc_addr = stream->iram_buffer.addr;\n\t\tdst_addr = dma_params->dev_phys[channel];\n\t\tflags = SPRD_DMA_FLAGS(SPRD_DMA_SRC_CHN1,\n\t\t\t\t       SPRD_DMA_TRANS_DONE_TRG,\n\t\t\t\t       SPRD_DMA_FRAG_REQ,\n\t\t\t\t       SPRD_DMA_TRANS_INT);\n\t\tbreak;\n\n\tcase 1:\n\t\tbus_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tperiod = params->buffer.fragment_size;\n\t\tperiod_cnt = params->buffer.fragments;\n\t\tsrc_addr = stream->compr_buffer.addr;\n\t\tdst_addr = stream->iram_buffer.addr;\n\t\tflags = SPRD_DMA_FLAGS(SPRD_DMA_DST_CHN1,\n\t\t\t\t       SPRD_DMA_TRANS_DONE_TRG,\n\t\t\t\t       SPRD_DMA_FRAG_REQ,\n\t\t\t\t       SPRD_DMA_TRANS_INT);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto config_err;\n\t}\n\n\tdma->trans_len = period * period_cnt;\n\n\tconfig.src_maxburst = period;\n\tconfig.src_addr_width = bus_width;\n\tconfig.dst_addr_width = bus_width;\n\tif (cstream->direction == SND_COMPRESS_PLAYBACK) {\n\t\tconfig.src_addr = src_addr;\n\t\tconfig.dst_addr = dst_addr;\n\t\tdir = DMA_MEM_TO_DEV;\n\t} else {\n\t\tconfig.src_addr = dst_addr;\n\t\tconfig.dst_addr = src_addr;\n\t\tdir = DMA_DEV_TO_MEM;\n\t}\n\n\tsg_init_table(sgt, sg_num);\n\tfor (j = 0; j < sg_num; j++, sgt++) {\n\t\tsg_dma_len(sgt) = dma->trans_len;\n\t\tsg_dma_address(sgt) = dst_addr;\n\t}\n\n\t \n\tlink.virt_addr = (unsigned long)dma->virt;\n\tlink.phy_addr = dma->phys;\n\n\tret = dmaengine_slave_config(dma->chan, &config);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"failed to set slave configuration: %d\\n\", ret);\n\t\tgoto config_err;\n\t}\n\n\t \n\tdma->desc = dma->chan->device->device_prep_slave_sg(dma->chan, sg,\n\t\t\t\t\t\t\t    sg_num, dir,\n\t\t\t\t\t\t\t    flags, &link);\n\tif (!dma->desc) {\n\t\tdev_err(dev, \"failed to prepare slave sg\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto config_err;\n\t}\n\n\t \n\tif (!params->no_wake_mode && channel == 1) {\n\t\tdma->desc->callback = sprd_platform_compr_dma_complete;\n\t\tdma->desc->callback_param = cstream;\n\t}\n\n\tdevm_kfree(dev, sg);\n\n\treturn 0;\n\nconfig_err:\n\tdevm_kfree(dev, sg);\nsg_err:\n\tdma_release_channel(dma->chan);\n\treturn ret;\n}\n\nstatic int sprd_platform_compr_set_params(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t\t\t  struct snd_compr_params *params)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tstruct sprd_compr_params compr_params = { };\n\tint ret;\n\n\t \n\tret = sprd_platform_compr_dma_config(component, cstream, params, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to config stage 1 DMA: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sprd_platform_compr_dma_config(component, cstream, params, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to config stage 0 DMA: %d\\n\", ret);\n\t\tgoto config_err;\n\t}\n\n\tcompr_params.direction = cstream->direction;\n\tcompr_params.sample_rate = params->codec.sample_rate;\n\tcompr_params.channels = stream->num_channels;\n\tcompr_params.info_phys = stream->info_phys;\n\tcompr_params.info_size = stream->info_size;\n\tcompr_params.rate = params->codec.bit_rate;\n\tcompr_params.format = params->codec.id;\n\n\tret = stream->compr_ops->set_params(cstream->direction, &compr_params);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set parameters: %d\\n\", ret);\n\t\tgoto params_err;\n\t}\n\n\treturn 0;\n\nparams_err:\n\tdma_release_channel(stream->dma[0].chan);\nconfig_err:\n\tdma_release_channel(stream->dma[1].chan);\n\treturn ret;\n}\n\nstatic int sprd_platform_compr_open(struct snd_soc_component *component,\n\t\t\t\t    struct snd_compr_stream *cstream)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct device *dev = component->dev;\n\tstruct sprd_compr_data *data = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct sprd_compr_stream *stream;\n\tstruct sprd_compr_callback cb;\n\tint stream_id = cstream->direction, ret;\n\n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tstream = devm_kzalloc(dev, sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tstream->cstream = cstream;\n\tstream->num_channels = 2;\n\tstream->compr_ops = data->ops;\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_IRAM, dev,\n\t\t\t\t  SPRD_COMPR_IRAM_SIZE, &stream->iram_buffer);\n\tif (ret < 0)\n\t\tgoto err_iram;\n\n\t \n\tstream->dma[0].virt = stream->iram_buffer.area + SPRD_COMPR_IRAM_SIZE;\n\tstream->dma[0].phys = stream->iram_buffer.addr + SPRD_COMPR_IRAM_SIZE;\n\n\t \n\tstream->info_phys = stream->iram_buffer.addr + SPRD_COMPR_IRAM_SIZE +\n\t\tSPRD_COMPR_IRAM_LINKLIST_SIZE;\n\tstream->info_area = stream->iram_buffer.area + SPRD_COMPR_IRAM_SIZE +\n\t\tSPRD_COMPR_IRAM_LINKLIST_SIZE;\n\tstream->info_size = SPRD_COMPR_IRAM_INFO_SIZE;\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dev,\n\t\t\t\t  SPRD_COMPR_AREA_SIZE, &stream->compr_buffer);\n\tif (ret < 0)\n\t\tgoto err_compr;\n\n\t \n\tstream->dma[1].virt = stream->compr_buffer.area + SPRD_COMPR_AREA_SIZE;\n\tstream->dma[1].phys = stream->compr_buffer.addr + SPRD_COMPR_AREA_SIZE;\n\n\tcb.drain_notify = sprd_platform_compr_drain_notify;\n\tcb.drain_data = cstream;\n\tret = stream->compr_ops->open(stream_id, &cb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to open compress platform: %d\\n\", ret);\n\t\tgoto err_open;\n\t}\n\n\truntime->private_data = stream;\n\treturn 0;\n\nerr_open:\n\tsnd_dma_free_pages(&stream->compr_buffer);\nerr_compr:\n\tsnd_dma_free_pages(&stream->iram_buffer);\nerr_iram:\n\tdevm_kfree(dev, stream);\n\n\treturn ret;\n}\n\nstatic int sprd_platform_compr_free(struct snd_soc_component *component,\n\t\t\t\t    struct snd_compr_stream *cstream)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tint stream_id = cstream->direction, i;\n\n\tfor (i = 0; i < stream->num_channels; i++) {\n\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\tif (dma->chan) {\n\t\t\tdma_release_channel(dma->chan);\n\t\t\tdma->chan = NULL;\n\t\t}\n\t}\n\n\tsnd_dma_free_pages(&stream->compr_buffer);\n\tsnd_dma_free_pages(&stream->iram_buffer);\n\n\tstream->compr_ops->close(stream_id);\n\n\tdevm_kfree(dev, stream);\n\treturn 0;\n}\n\nstatic int sprd_platform_compr_trigger(struct snd_soc_component *component,\n\t\t\t\t       struct snd_compr_stream *cstream,\n\t\t\t\t       int cmd)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tint channels = stream->num_channels, ret = 0, i;\n\tint stream_id = cstream->direction;\n\n\tif (cstream->direction != SND_COMPRESS_PLAYBACK) {\n\t\tdev_err(dev, \"unsupported compress direction\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tfor (i = channels - 1; i >= 0; i--) {\n\t\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\t\tif (!dma->desc)\n\t\t\t\tcontinue;\n\n\t\t\tdma->cookie = dmaengine_submit(dma->desc);\n\t\t\tret = dma_submit_error(dma->cookie);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"failed to submit request: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = channels - 1; i >= 0; i--) {\n\t\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\t\tif (dma->chan)\n\t\t\t\tdma_async_issue_pending(dma->chan);\n\t\t}\n\n\t\tret = stream->compr_ops->start(stream_id);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tfor (i = channels - 1; i >= 0; i--) {\n\t\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\t\tif (dma->chan)\n\t\t\t\tdmaengine_terminate_async(dma->chan);\n\t\t}\n\n\t\tstream->copied_total = 0;\n\t\tstream->stage1_pointer  = 0;\n\t\tstream->received_total = 0;\n\t\tstream->received_stage0 = 0;\n\t\tstream->received_stage1 = 0;\n\n\t\tret = stream->compr_ops->stop(stream_id);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor (i = channels - 1; i >= 0; i--) {\n\t\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\t\tif (dma->chan)\n\t\t\t\tdmaengine_pause(dma->chan);\n\t\t}\n\n\t\tret = stream->compr_ops->pause(stream_id);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor (i = channels - 1; i >= 0; i--) {\n\t\t\tstruct sprd_compr_dma *dma = &stream->dma[i];\n\n\t\t\tif (dma->chan)\n\t\t\t\tdmaengine_resume(dma->chan);\n\t\t}\n\n\t\tret = stream->compr_ops->pause_release(stream_id);\n\t\tbreak;\n\n\tcase SND_COMPR_TRIGGER_PARTIAL_DRAIN:\n\tcase SND_COMPR_TRIGGER_DRAIN:\n\t\tret = stream->compr_ops->drain(stream->received_total);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int sprd_platform_compr_pointer(struct snd_soc_component *component,\n\t\t\t\t       struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tstruct sprd_compr_playinfo *info =\n\t\t(struct sprd_compr_playinfo *)stream->info_area;\n\n\ttstamp->copied_total = stream->copied_total;\n\ttstamp->pcm_io_frames = info->current_data_offset;\n\n\treturn 0;\n}\n\nstatic int sprd_platform_compr_copy(struct snd_soc_component *component,\n\t\t\t\t    struct snd_compr_stream *cstream,\n\t\t\t\t    char __user *buf, size_t count)\n{\n\tstruct snd_compr_runtime *runtime = cstream->runtime;\n\tstruct sprd_compr_stream *stream = runtime->private_data;\n\tint avail_bytes, data_count = count;\n\tvoid *dst;\n\n\t \n\tif (stream->received_stage0 < runtime->fragment_size) {\n\t\tavail_bytes = runtime->fragment_size - stream->received_stage0;\n\t\tdst = stream->iram_buffer.area + stream->received_stage0;\n\n\t\tif (avail_bytes >= data_count) {\n\t\t\t \n\t\t\tif (copy_from_user(dst, buf, data_count))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tstream->received_stage0 += data_count;\n\t\t\tstream->copied_total += data_count;\n\t\t\tgoto copy_done;\n\t\t} else {\n\t\t\t \n\t\t\tif (copy_from_user(dst, buf, avail_bytes))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tdata_count -= avail_bytes;\n\t\t\tstream->received_stage0 += avail_bytes;\n\t\t\tstream->copied_total += avail_bytes;\n\t\t\tbuf += avail_bytes;\n\t\t}\n\t}\n\n\t \n\tdst = stream->compr_buffer.area + stream->stage1_pointer;\n\tif (data_count < stream->compr_buffer.bytes - stream->stage1_pointer) {\n\t\tif (copy_from_user(dst, buf, data_count))\n\t\t\treturn -EFAULT;\n\n\t\tstream->stage1_pointer += data_count;\n\t} else {\n\t\tavail_bytes = stream->compr_buffer.bytes - stream->stage1_pointer;\n\n\t\tif (copy_from_user(dst, buf, avail_bytes))\n\t\t\treturn -EFAULT;\n\n\t\tif (copy_from_user(stream->compr_buffer.area, buf + avail_bytes,\n\t\t\t\t   data_count - avail_bytes))\n\t\t\treturn -EFAULT;\n\n\t\tstream->stage1_pointer = data_count - avail_bytes;\n\t}\n\n\tstream->received_stage1 += data_count;\n\ncopy_done:\n\t \n\tstream->received_total += count;\n\treturn count;\n}\n\nstatic int sprd_platform_compr_get_caps(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_compr_stream *cstream,\n\t\t\t\t\tstruct snd_compr_caps *caps)\n{\n\tcaps->direction = cstream->direction;\n\tcaps->min_fragment_size = SPRD_COMPR_MIN_FRAGMENT_SIZE;\n\tcaps->max_fragment_size = SPRD_COMPR_MAX_FRAGMENT_SIZE;\n\tcaps->min_fragments = SPRD_COMPR_MIN_NUM_FRAGMENTS;\n\tcaps->max_fragments = SPRD_COMPR_MAX_NUM_FRAGMENTS;\n\tcaps->num_codecs = 2;\n\tcaps->codecs[0] = SND_AUDIOCODEC_MP3;\n\tcaps->codecs[1] = SND_AUDIOCODEC_AAC;\n\n\treturn 0;\n}\n\nstatic int\nsprd_platform_compr_get_codec_caps(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *cstream,\n\t\t\t\t   struct snd_compr_codec_caps *codec)\n{\n\tswitch (codec->codec) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\tcodec->num_descriptors = 2;\n\t\tcodec->descriptor[0].max_ch = 2;\n\t\tcodec->descriptor[0].bit_rate[0] = 320;\n\t\tcodec->descriptor[0].bit_rate[1] = 128;\n\t\tcodec->descriptor[0].num_bitrates = 2;\n\t\tcodec->descriptor[0].profiles = 0;\n\t\tcodec->descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO;\n\t\tcodec->descriptor[0].formats = 0;\n\t\tbreak;\n\n\tcase SND_AUDIOCODEC_AAC:\n\t\tcodec->num_descriptors = 2;\n\t\tcodec->descriptor[1].max_ch = 2;\n\t\tcodec->descriptor[1].bit_rate[0] = 320;\n\t\tcodec->descriptor[1].bit_rate[1] = 128;\n\t\tcodec->descriptor[1].num_bitrates = 2;\n\t\tcodec->descriptor[1].profiles = 0;\n\t\tcodec->descriptor[1].modes = 0;\n\t\tcodec->descriptor[1].formats = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nconst struct snd_compress_ops sprd_platform_compress_ops = {\n\t.open = sprd_platform_compr_open,\n\t.free = sprd_platform_compr_free,\n\t.set_params = sprd_platform_compr_set_params,\n\t.trigger = sprd_platform_compr_trigger,\n\t.pointer = sprd_platform_compr_pointer,\n\t.copy = sprd_platform_compr_copy,\n\t.get_caps = sprd_platform_compr_get_caps,\n\t.get_codec_caps = sprd_platform_compr_get_codec_caps,\n};\n\nMODULE_DESCRIPTION(\"Spreadtrum ASoC Compress Platform Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:compress-platform\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}