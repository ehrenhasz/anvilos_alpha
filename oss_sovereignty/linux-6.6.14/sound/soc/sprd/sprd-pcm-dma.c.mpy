{
  "module_name": "sprd-pcm-dma.c",
  "hash_id": "d22a0282195c23571c78dd1810cb736c59a09a8c4081d891dd4de419dc525a37",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sprd/sprd-pcm-dma.c",
  "human_readable_source": "\n\n\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/sprd-dma.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"sprd-pcm-dma.h\"\n\n#define SPRD_PCM_DMA_LINKLIST_SIZE\t64\n#define SPRD_PCM_DMA_BRUST_LEN\t\t640\n\nstruct sprd_pcm_dma_data {\n\tstruct dma_chan *chan;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tdma_addr_t phys;\n\tvoid *virt;\n\tint pre_pointer;\n};\n\nstruct sprd_pcm_dma_private {\n\tstruct snd_pcm_substream *substream;\n\tstruct sprd_pcm_dma_params *params;\n\tstruct sprd_pcm_dma_data data[SPRD_PCM_CHANNEL_MAX];\n\tint hw_chan;\n\tint dma_addr_offset;\n};\n\nstatic const struct snd_pcm_hardware sprd_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_RESUME | SNDRV_PCM_INFO_NO_PERIOD_WAKEUP,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t.period_bytes_min = 1,\n\t.period_bytes_max = 64 * 1024,\n\t.periods_min = 1,\n\t.periods_max = PAGE_SIZE / SPRD_PCM_DMA_LINKLIST_SIZE,\n\t.buffer_bytes_max = 64 * 1024,\n};\n\nstatic int sprd_pcm_open(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = component->dev;\n\tstruct sprd_pcm_dma_private *dma_private;\n\tint hw_chan = SPRD_PCM_CHANNEL_MAX;\n\tint size, ret, i;\n\n\tsnd_soc_set_runtime_hwparams(substream, &sprd_pcm_hardware);\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t SPRD_PCM_DMA_BRUST_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t SPRD_PCM_DMA_BRUST_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdma_private = devm_kzalloc(dev, sizeof(*dma_private), GFP_KERNEL);\n\tif (!dma_private)\n\t\treturn -ENOMEM;\n\n\tsize = runtime->hw.periods_max * SPRD_PCM_DMA_LINKLIST_SIZE;\n\n\tfor (i = 0; i < hw_chan; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tdata->virt = dmam_alloc_coherent(dev, size, &data->phys,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!data->virt) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdma_private->hw_chan = hw_chan;\n\truntime->private_data = dma_private;\n\tdma_private->substream = substream;\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < hw_chan; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tif (data->virt)\n\t\t\tdmam_free_coherent(dev, size, data->virt, data->phys);\n\t}\n\n\tdevm_kfree(dev, dma_private);\n\treturn ret;\n}\n\nstatic int sprd_pcm_close(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sprd_pcm_dma_private *dma_private = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tint size = runtime->hw.periods_max * SPRD_PCM_DMA_LINKLIST_SIZE;\n\tint i;\n\n\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tdmam_free_coherent(dev, size, data->virt, data->phys);\n\t}\n\n\tdevm_kfree(dev, dma_private);\n\n\treturn 0;\n}\n\nstatic void sprd_pcm_dma_complete(void *data)\n{\n\tstruct sprd_pcm_dma_private *dma_private = data;\n\tstruct snd_pcm_substream *substream = dma_private->substream;\n\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic void sprd_pcm_release_dma_channel(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sprd_pcm_dma_private *dma_private = runtime->private_data;\n\tint i;\n\n\tfor (i = 0; i < SPRD_PCM_CHANNEL_MAX; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tif (data->chan) {\n\t\t\tdma_release_channel(data->chan);\n\t\t\tdata->chan = NULL;\n\t\t}\n\t}\n}\n\nstatic int sprd_pcm_request_dma_channel(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\t\tint channels)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sprd_pcm_dma_private *dma_private = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tstruct sprd_pcm_dma_params *dma_params = dma_private->params;\n\tint i;\n\n\tif (channels > SPRD_PCM_CHANNEL_MAX) {\n\t\tdev_err(dev, \"invalid dma channel number:%d\\n\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < channels; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tdata->chan = dma_request_slave_channel(dev,\n\t\t\t\t\t\t       dma_params->chan_name[i]);\n\t\tif (!data->chan) {\n\t\t\tdev_err(dev, \"failed to request dma channel:%s\\n\",\n\t\t\t\tdma_params->chan_name[i]);\n\t\t\tsprd_pcm_release_dma_channel(substream);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sprd_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sprd_pcm_dma_private *dma_private = runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sprd_pcm_dma_params *dma_params;\n\tsize_t totsize = params_buffer_bytes(params);\n\tsize_t period = params_period_bytes(params);\n\tint channels = params_channels(params);\n\tint is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct scatterlist *sg;\n\tunsigned long flags;\n\tint ret, i, j, sg_num;\n\n\tdma_params = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tif (!dma_params) {\n\t\tdev_warn(component->dev, \"no dma parameters setting\\n\");\n\t\tdma_private->params = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!dma_private->params) {\n\t\tdma_private->params = dma_params;\n\t\tret = sprd_pcm_request_dma_channel(component,\n\t\t\t\t\t\t   substream, channels);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsg_num = totsize / period;\n\tdma_private->dma_addr_offset = totsize / channels;\n\n\tsg = devm_kcalloc(component->dev, sg_num, sizeof(*sg), GFP_KERNEL);\n\tif (!sg) {\n\t\tret = -ENOMEM;\n\t\tgoto sg_err;\n\t}\n\n\tfor (i = 0; i < channels; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\t\tstruct dma_chan *chan = data->chan;\n\t\tstruct dma_slave_config config = { };\n\t\tstruct sprd_dma_linklist link = { };\n\t\tenum dma_transfer_direction dir;\n\t\tstruct scatterlist *sgt = sg;\n\n\t\tconfig.src_maxburst = dma_params->fragment_len[i];\n\t\tconfig.src_addr_width = dma_params->datawidth[i];\n\t\tconfig.dst_addr_width = dma_params->datawidth[i];\n\t\tif (is_playback) {\n\t\t\tconfig.src_addr = runtime->dma_addr +\n\t\t\t\ti * dma_private->dma_addr_offset;\n\t\t\tconfig.dst_addr = dma_params->dev_phys[i];\n\t\t\tdir = DMA_MEM_TO_DEV;\n\t\t} else {\n\t\t\tconfig.src_addr = dma_params->dev_phys[i];\n\t\t\tconfig.dst_addr = runtime->dma_addr +\n\t\t\t\ti * dma_private->dma_addr_offset;\n\t\t\tdir = DMA_DEV_TO_MEM;\n\t\t}\n\n\t\tsg_init_table(sgt, sg_num);\n\t\tfor (j = 0; j < sg_num; j++, sgt++) {\n\t\t\tu32 sg_len = period / channels;\n\n\t\t\tsg_dma_len(sgt) = sg_len;\n\t\t\tsg_dma_address(sgt) = runtime->dma_addr +\n\t\t\t\ti * dma_private->dma_addr_offset + sg_len * j;\n\t\t}\n\n\t\t \n\t\tlink.virt_addr = (unsigned long)data->virt;\n\t\tlink.phy_addr = data->phys;\n\n\t\tret = dmaengine_slave_config(chan, &config);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"failed to set slave configuration: %d\\n\", ret);\n\t\t\tgoto config_err;\n\t\t}\n\n\t\t \n\t\tflags = SPRD_DMA_FLAGS(SPRD_DMA_CHN_MODE_NONE, SPRD_DMA_NO_TRG,\n\t\t\t\t       SPRD_DMA_FRAG_REQ, SPRD_DMA_TRANS_INT);\n\t\tdata->desc = chan->device->device_prep_slave_sg(chan, sg,\n\t\t\t\t\t\t\t\tsg_num, dir,\n\t\t\t\t\t\t\t\tflags, &link);\n\t\tif (!data->desc) {\n\t\t\tdev_err(component->dev, \"failed to prepare slave sg\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto config_err;\n\t\t}\n\n\t\tif (!runtime->no_period_wakeup) {\n\t\t\tdata->desc->callback = sprd_pcm_dma_complete;\n\t\t\tdata->desc->callback_param = dma_private;\n\t\t}\n\t}\n\n\tdevm_kfree(component->dev, sg);\n\n\treturn 0;\n\nconfig_err:\n\tdevm_kfree(component->dev, sg);\nsg_err:\n\tsprd_pcm_release_dma_channel(substream);\n\treturn ret;\n}\n\nstatic int sprd_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tsprd_pcm_release_dma_channel(substream);\n\n\treturn 0;\n}\n\nstatic int sprd_pcm_trigger(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct sprd_pcm_dma_private *dma_private =\n\t\tsubstream->runtime->private_data;\n\tint ret = 0, i;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\t\tif (!data->desc)\n\t\t\t\tcontinue;\n\n\t\t\tdata->cookie = dmaengine_submit(data->desc);\n\t\t\tret = dma_submit_error(data->cookie);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"failed to submit dma request: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdma_async_issue_pending(data->chan);\n\t\t}\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\t\tif (data->chan)\n\t\t\t\tdmaengine_resume(data->chan);\n\t\t}\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\t\tif (data->chan)\n\t\t\t\tdmaengine_terminate_async(data->chan);\n\t\t}\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\t\tif (data->chan)\n\t\t\t\tdmaengine_pause(data->chan);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t sprd_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sprd_pcm_dma_private *dma_private = runtime->private_data;\n\tint pointer[SPRD_PCM_CHANNEL_MAX];\n\tint bytes_of_pointer = 0, sel_max = 0, i;\n\tsnd_pcm_uframes_t x;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\n\tfor (i = 0; i < dma_private->hw_chan; i++) {\n\t\tstruct sprd_pcm_dma_data *data = &dma_private->data[i];\n\n\t\tif (!data->chan)\n\t\t\tcontinue;\n\n\t\tstatus = dmaengine_tx_status(data->chan, data->cookie, &state);\n\t\tif (status == DMA_ERROR) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"failed to get dma channel %d status\\n\", i);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tpointer[i] = state.residue - runtime->dma_addr -\n\t\t\ti * dma_private->dma_addr_offset;\n\n\t\tif (i == 0) {\n\t\t\tbytes_of_pointer = pointer[i];\n\t\t\tsel_max = pointer[i] < data->pre_pointer ? 1 : 0;\n\t\t} else {\n\t\t\tsel_max ^= pointer[i] < data->pre_pointer ? 1 : 0;\n\n\t\t\tif (sel_max)\n\t\t\t\tbytes_of_pointer =\n\t\t\t\t\tmax(pointer[i], pointer[i - 1]) << 1;\n\t\t\telse\n\t\t\t\tbytes_of_pointer =\n\t\t\t\t\tmin(pointer[i], pointer[i - 1]) << 1;\n\t\t}\n\n\t\tdata->pre_pointer = pointer[i];\n\t}\n\n\tx = bytes_to_frames(runtime, bytes_of_pointer);\n\tif (x == runtime->buffer_size)\n\t\tx = 0;\n\n\treturn x;\n}\n\nstatic int sprd_pcm_new(struct snd_soc_component *component,\n\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    card->dev,\n\t\t\t\t\t    sprd_pcm_hardware.buffer_bytes_max);\n}\n\nstatic const struct snd_soc_component_driver sprd_soc_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= sprd_pcm_open,\n\t.close\t\t= sprd_pcm_close,\n\t.hw_params\t= sprd_pcm_hw_params,\n\t.hw_free\t= sprd_pcm_hw_free,\n\t.trigger\t= sprd_pcm_trigger,\n\t.pointer\t= sprd_pcm_pointer,\n\t.pcm_construct\t= sprd_pcm_new,\n\t.compress_ops\t= &sprd_platform_compress_ops,\n};\n\nstatic int sprd_soc_platform_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tint ret;\n\n\tret = of_reserved_mem_device_init_by_idx(&pdev->dev, np, 0);\n\tif (ret)\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"no reserved DMA memory for audio platform device\\n\");\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &sprd_soc_component,\n\t\t\t\t\t      NULL, 0);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"could not register platform:%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id sprd_pcm_of_match[] = {\n\t{ .compatible = \"sprd,pcm-platform\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sprd_pcm_of_match);\n\nstatic struct platform_driver sprd_pcm_driver = {\n\t.driver = {\n\t\t.name = \"sprd-pcm-audio\",\n\t\t.of_match_table = sprd_pcm_of_match,\n\t},\n\n\t.probe = sprd_soc_platform_probe,\n};\n\nmodule_platform_driver(sprd_pcm_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum ASoC PCM DMA\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sprd-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}