{
  "module_name": "soc-pcm.c",
  "hash_id": "2385f60b3d0f6f47dcfbfebb86949d1326e0cfa5f8df6270bf39affa10b99f57",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dpcm.h>\n#include <sound/soc-link.h>\n#include <sound/initval.h>\n\n#define soc_pcm_ret(rtd, ret) _soc_pcm_ret(rtd, __func__, ret)\nstatic inline int _soc_pcm_ret(struct snd_soc_pcm_runtime *rtd,\n\t\t\t       const char *func, int ret)\n{\n\t \n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\tswitch (ret) {\n\tcase -EPROBE_DEFER:\n\tcase -ENOTSUPP:\n\tcase -EINVAL:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->dev,\n\t\t\t\"ASoC: error at %s on %s: %d\\n\",\n\t\t\tfunc, rtd->dai_link->name, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void snd_soc_dpcm_stream_lock_irq(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t\tint stream)\n{\n\tsnd_pcm_stream_lock_irq(snd_soc_dpcm_get_substream(rtd, stream));\n}\n\n#define snd_soc_dpcm_stream_lock_irqsave_nested(rtd, stream, flags) \\\n\tsnd_pcm_stream_lock_irqsave_nested(snd_soc_dpcm_get_substream(rtd, stream), flags)\n\nstatic inline void snd_soc_dpcm_stream_unlock_irq(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t\t  int stream)\n{\n\tsnd_pcm_stream_unlock_irq(snd_soc_dpcm_get_substream(rtd, stream));\n}\n\n#define snd_soc_dpcm_stream_unlock_irqrestore(rtd, stream, flags) \\\n\tsnd_pcm_stream_unlock_irqrestore(snd_soc_dpcm_get_substream(rtd, stream), flags)\n\n#define DPCM_MAX_BE_USERS\t8\n\nstatic inline const char *soc_cpu_dai_name(struct snd_soc_pcm_runtime *rtd)\n{\n\treturn (rtd)->dai_link->num_cpus == 1 ? asoc_rtd_to_cpu(rtd, 0)->name : \"multicpu\";\n}\nstatic inline const char *soc_codec_dai_name(struct snd_soc_pcm_runtime *rtd)\n{\n\treturn (rtd)->dai_link->num_codecs == 1 ? asoc_rtd_to_codec(rtd, 0)->name : \"multicodec\";\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic const char *dpcm_state_string(enum snd_soc_dpcm_state state)\n{\n\tswitch (state) {\n\tcase SND_SOC_DPCM_STATE_NEW:\n\t\treturn \"new\";\n\tcase SND_SOC_DPCM_STATE_OPEN:\n\t\treturn \"open\";\n\tcase SND_SOC_DPCM_STATE_HW_PARAMS:\n\t\treturn \"hw_params\";\n\tcase SND_SOC_DPCM_STATE_PREPARE:\n\t\treturn \"prepare\";\n\tcase SND_SOC_DPCM_STATE_START:\n\t\treturn \"start\";\n\tcase SND_SOC_DPCM_STATE_STOP:\n\t\treturn \"stop\";\n\tcase SND_SOC_DPCM_STATE_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SND_SOC_DPCM_STATE_PAUSED:\n\t\treturn \"paused\";\n\tcase SND_SOC_DPCM_STATE_HW_FREE:\n\t\treturn \"hw_free\";\n\tcase SND_SOC_DPCM_STATE_CLOSE:\n\t\treturn \"close\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic ssize_t dpcm_show_state(struct snd_soc_pcm_runtime *fe,\n\t\t\t       int stream, char *buf, size_t size)\n{\n\tstruct snd_pcm_hw_params *params = &fe->dpcm[stream].hw_params;\n\tstruct snd_soc_dpcm *dpcm;\n\tssize_t offset = 0;\n\n\t \n\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t   \"[%s - %s]\\n\", fe->dai_link->name,\n\t\t\t   stream ? \"Capture\" : \"Playback\");\n\n\toffset += scnprintf(buf + offset, size - offset, \"State: %s\\n\",\n\t\t\t   dpcm_state_string(fe->dpcm[stream].state));\n\n\tif ((fe->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t    (fe->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\n\t\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t\t   \"Hardware Params: \"\n\t\t\t\t   \"Format = %s, Channels = %d, Rate = %d\\n\",\n\t\t\t\t   snd_pcm_format_name(params_format(params)),\n\t\t\t\t   params_channels(params),\n\t\t\t\t   params_rate(params));\n\n\t \n\toffset += scnprintf(buf + offset, size - offset, \"Backends:\\n\");\n\n\tif (list_empty(&fe->dpcm[stream].be_clients)) {\n\t\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t\t   \" No active DSP links\\n\");\n\t\tgoto out;\n\t}\n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tparams = &be->dpcm[stream].hw_params;\n\n\t\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t\t   \"- %s\\n\", be->dai_link->name);\n\n\t\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t\t   \"   State: %s\\n\",\n\t\t\t\t   dpcm_state_string(be->dpcm[stream].state));\n\n\t\tif ((be->dpcm[stream].state >= SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t\t    (be->dpcm[stream].state <= SND_SOC_DPCM_STATE_STOP))\n\t\t\toffset += scnprintf(buf + offset, size - offset,\n\t\t\t\t\t   \"   Hardware Params: \"\n\t\t\t\t\t   \"Format = %s, Channels = %d, Rate = %d\\n\",\n\t\t\t\t\t   snd_pcm_format_name(params_format(params)),\n\t\t\t\t\t   params_channels(params),\n\t\t\t\t\t   params_rate(params));\n\t}\nout:\n\treturn offset;\n}\n\nstatic ssize_t dpcm_state_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct snd_soc_pcm_runtime *fe = file->private_data;\n\tssize_t out_count = PAGE_SIZE, offset = 0, ret = 0;\n\tint stream;\n\tchar *buf;\n\n\tif (fe->dai_link->num_cpus > 1) {\n\t\tdev_err(fe->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = kmalloc(out_count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tfor_each_pcm_streams(stream)\n\t\tif (snd_soc_dai_stream_valid(asoc_rtd_to_cpu(fe, 0), stream))\n\t\t\toffset += dpcm_show_state(fe, stream,\n\t\t\t\t\t\t  buf + offset,\n\t\t\t\t\t\t  out_count - offset);\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, offset);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations dpcm_state_fops = {\n\t.open = simple_open,\n\t.read = dpcm_state_read_file,\n\t.llseek = default_llseek,\n};\n\nvoid soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd)\n{\n\tif (!rtd->dai_link->dynamic)\n\t\treturn;\n\n\tif (!rtd->card->debugfs_card_root)\n\t\treturn;\n\n\trtd->debugfs_dpcm_root = debugfs_create_dir(rtd->dai_link->name,\n\t\t\t\t\t\t    rtd->card->debugfs_card_root);\n\n\tdebugfs_create_file(\"state\", 0444, rtd->debugfs_dpcm_root,\n\t\t\t    rtd, &dpcm_state_fops);\n}\n\nstatic void dpcm_create_debugfs_state(struct snd_soc_dpcm *dpcm, int stream)\n{\n\tchar *name;\n\n\tname = kasprintf(GFP_KERNEL, \"%s:%s\", dpcm->be->dai_link->name,\n\t\t\t stream ? \"capture\" : \"playback\");\n\tif (name) {\n\t\tdpcm->debugfs_state = debugfs_create_dir(\n\t\t\tname, dpcm->fe->debugfs_dpcm_root);\n\t\tdebugfs_create_u32(\"state\", 0644, dpcm->debugfs_state,\n\t\t\t\t   &dpcm->state);\n\t\tkfree(name);\n\t}\n}\n\nstatic void dpcm_remove_debugfs_state(struct snd_soc_dpcm *dpcm)\n{\n\tdebugfs_remove_recursive(dpcm->debugfs_state);\n}\n\n#else\nstatic inline void dpcm_create_debugfs_state(struct snd_soc_dpcm *dpcm,\n\t\t\t\t\t     int stream)\n{\n}\n\nstatic inline void dpcm_remove_debugfs_state(struct snd_soc_dpcm *dpcm)\n{\n}\n#endif\n\n \nstatic int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd);\nstatic void dpcm_set_fe_update_state(struct snd_soc_pcm_runtime *fe,\n\t\t\t\t     int stream, enum snd_soc_dpcm_update state)\n{\n\tstruct snd_pcm_substream *substream =\n\t\tsnd_soc_dpcm_get_substream(fe, stream);\n\n\tsnd_soc_dpcm_stream_lock_irq(fe, stream);\n\tif (state == SND_SOC_DPCM_UPDATE_NO && fe->dpcm[stream].trigger_pending) {\n\t\tdpcm_fe_dai_do_trigger(substream,\n\t\t\t\t       fe->dpcm[stream].trigger_pending - 1);\n\t\tfe->dpcm[stream].trigger_pending = 0;\n\t}\n\tfe->dpcm[stream].runtime_update = state;\n\tsnd_soc_dpcm_stream_unlock_irq(fe, stream);\n}\n\nstatic void dpcm_set_be_update_state(struct snd_soc_pcm_runtime *be,\n\t\t\t\t     int stream, enum snd_soc_dpcm_update state)\n{\n\tbe->dpcm[stream].runtime_update = state;\n}\n\n \nvoid snd_soc_runtime_action(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    int stream, int action)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\tfor_each_rtd_dais(rtd, i, dai)\n\t\tsnd_soc_dai_action(dai, stream, action);\n}\nEXPORT_SYMBOL_GPL(snd_soc_runtime_action);\n\n \nbool snd_soc_runtime_ignore_pmdown_time(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component;\n\tbool ignore = true;\n\tint i;\n\n\tif (!rtd->pmdown_time || rtd->dai_link->ignore_pmdown_time)\n\t\treturn true;\n\n\tfor_each_rtd_components(rtd, i, component)\n\t\tignore &= !component->driver->use_pmdown_time;\n\n\treturn ignore;\n}\n\n \nint snd_soc_set_runtime_hwparams(struct snd_pcm_substream *substream,\n\tconst struct snd_pcm_hardware *hw)\n{\n\tsubstream->runtime->hw = *hw;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_set_runtime_hwparams);\n\n \nint dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,\n\tint event)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\n\tsnd_soc_dpcm_mutex_assert_held(fe);\n\n\tfor_each_dpcm_be(fe, dir, dpcm) {\n\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\n\t\tdev_dbg(be->dev, \"ASoC: BE %s event %d dir %d\\n\",\n\t\t\t\tbe->dai_link->name, event, dir);\n\n\t\tif ((event == SND_SOC_DAPM_STREAM_STOP) &&\n\t\t    (be->dpcm[dir].users >= 1))\n\t\t\tcontinue;\n\n\t\tsnd_soc_dapm_stream_event(be, dir, event);\n\t}\n\n\tsnd_soc_dapm_stream_event(fe, dir, event);\n\n\treturn 0;\n}\n\nstatic void soc_pcm_set_dai_params(struct snd_soc_dai *dai,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tif (params) {\n\t\tdai->rate\t = params_rate(params);\n\t\tdai->channels\t = params_channels(params);\n\t\tdai->sample_bits = snd_pcm_format_physical_width(params_format(params));\n\t} else {\n\t\tdai->rate\t = 0;\n\t\tdai->channels\t = 0;\n\t\tdai->sample_bits = 0;\n\t}\n}\n\nstatic int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_soc_dai *soc_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tif (!snd_soc_dai_active(soc_dai))\n\t\treturn 0;\n\n#define __soc_pcm_apply_symmetry(name, NAME)\t\t\t\t\\\n\tif (soc_dai->name && (soc_dai->driver->symmetric_##name ||\t\\\n\t\t\t      rtd->dai_link->symmetric_##name)) {\t\\\n\t\tdev_dbg(soc_dai->dev, \"ASoC: Symmetry forces %s to %d\\n\",\\\n\t\t\t#name, soc_dai->name);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tret = snd_pcm_hw_constraint_single(substream->runtime,\t\\\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_##NAME,\\\n\t\t\t\t\t\t   soc_dai->name);\t\\\n\t\tif (ret < 0) {\t\t\t\t\t\t\\\n\t\t\tdev_err(soc_dai->dev,\t\t\t\t\\\n\t\t\t\t\"ASoC: Unable to apply %s constraint: %d\\n\",\\\n\t\t\t\t#name, ret);\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\n\n\t__soc_pcm_apply_symmetry(rate,\t\tRATE);\n\t__soc_pcm_apply_symmetry(channels,\tCHANNELS);\n\t__soc_pcm_apply_symmetry(sample_bits,\tSAMPLE_BITS);\n\n\treturn 0;\n}\n\nstatic int soc_pcm_params_symmetry(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai d;\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_dai *cpu_dai;\n\tunsigned int symmetry, i;\n\n\td.name = __func__;\n\tsoc_pcm_set_dai_params(&d, params);\n\n#define __soc_pcm_params_symmetry(xxx)\t\t\t\t\t\\\n\tsymmetry = rtd->dai_link->symmetric_##xxx;\t\t\t\\\n\tfor_each_rtd_dais(rtd, i, dai)\t\t\t\t\t\\\n\t\tsymmetry |= dai->driver->symmetric_##xxx;\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (symmetry)\t\t\t\t\t\t\t\\\n\t\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai)\t\t\t\\\n\t\t\tif (!snd_soc_dai_is_dummy(cpu_dai) &&\t\t\\\n\t\t\t    cpu_dai->xxx && cpu_dai->xxx != d.xxx) {\t\\\n\t\t\t\tdev_err(rtd->dev, \"ASoC: unmatched %s symmetry: %s:%d - %s:%d\\n\", \\\n\t\t\t\t\t#xxx, cpu_dai->name, cpu_dai->xxx, d.name, d.xxx); \\\n\t\t\t\treturn -EINVAL;\t\t\t\t\\\n\t\t\t}\n\n\t \n\t__soc_pcm_params_symmetry(rate);\n\t__soc_pcm_params_symmetry(channels);\n\t__soc_pcm_params_symmetry(sample_bits);\n\n\treturn 0;\n}\n\nstatic void soc_pcm_update_symmetry(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai_link *link = rtd->dai_link;\n\tstruct snd_soc_dai *dai;\n\tunsigned int symmetry, i;\n\n\tsymmetry = link->symmetric_rate ||\n\t\tlink->symmetric_channels ||\n\t\tlink->symmetric_sample_bits;\n\n\tfor_each_rtd_dais(rtd, i, dai)\n\t\tsymmetry = symmetry ||\n\t\t\tdai->driver->symmetric_rate ||\n\t\t\tdai->driver->symmetric_channels ||\n\t\t\tdai->driver->symmetric_sample_bits;\n\n\tif (symmetry)\n\t\tsubstream->runtime->hw.info |= SNDRV_PCM_INFO_JOINT_DUPLEX;\n}\n\nstatic void soc_pcm_set_msb(struct snd_pcm_substream *substream, int bits)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tif (!bits)\n\t\treturn;\n\n\tret = snd_pcm_hw_constraint_msbits(substream->runtime, 0, 0, bits);\n\tif (ret != 0)\n\t\tdev_warn(rtd->dev, \"ASoC: Failed to set MSB %d: %d\\n\",\n\t\t\t\t bits, ret);\n}\n\nstatic void soc_pcm_apply_msb(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct snd_soc_dai *codec_dai;\n\tint stream = substream->stream;\n\tint i;\n\tunsigned int bits = 0, cpu_bits = 0;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tstruct snd_soc_pcm_stream *pcm_codec = snd_soc_dai_get_pcm_stream(codec_dai, stream);\n\n\t\tif (pcm_codec->sig_bits == 0) {\n\t\t\tbits = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbits = max(pcm_codec->sig_bits, bits);\n\t}\n\n\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\tstruct snd_soc_pcm_stream *pcm_cpu = snd_soc_dai_get_pcm_stream(cpu_dai, stream);\n\n\t\tif (pcm_cpu->sig_bits == 0) {\n\t\t\tcpu_bits = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcpu_bits = max(pcm_cpu->sig_bits, cpu_bits);\n\t}\n\n\tsoc_pcm_set_msb(substream, bits);\n\tsoc_pcm_set_msb(substream, cpu_bits);\n}\n\nstatic void soc_pcm_hw_init(struct snd_pcm_hardware *hw)\n{\n\thw->rates\t\t= UINT_MAX;\n\thw->rate_min\t\t= 0;\n\thw->rate_max\t\t= UINT_MAX;\n\thw->channels_min\t= 0;\n\thw->channels_max\t= UINT_MAX;\n\thw->formats\t\t= ULLONG_MAX;\n}\n\nstatic void soc_pcm_hw_update_rate(struct snd_pcm_hardware *hw,\n\t\t\t\t   struct snd_soc_pcm_stream *p)\n{\n\thw->rates = snd_pcm_rate_mask_intersect(hw->rates, p->rates);\n\n\t \n\tsnd_pcm_hw_limit_rates(hw);\n\n\t \n\thw->rate_min = max(hw->rate_min, p->rate_min);\n\thw->rate_max = min_not_zero(hw->rate_max, p->rate_max);\n}\n\nstatic void soc_pcm_hw_update_chan(struct snd_pcm_hardware *hw,\n\t\t\t\t   struct snd_soc_pcm_stream *p)\n{\n\thw->channels_min = max(hw->channels_min, p->channels_min);\n\thw->channels_max = min(hw->channels_max, p->channels_max);\n}\n\nstatic void soc_pcm_hw_update_format(struct snd_pcm_hardware *hw,\n\t\t\t\t     struct snd_soc_pcm_stream *p)\n{\n\thw->formats &= p->formats;\n}\n\n \nint snd_soc_runtime_calc_hw(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    struct snd_pcm_hardware *hw, int stream)\n{\n\tstruct snd_soc_dai *codec_dai;\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct snd_soc_pcm_stream *codec_stream;\n\tstruct snd_soc_pcm_stream *cpu_stream;\n\tunsigned int cpu_chan_min = 0, cpu_chan_max = UINT_MAX;\n\tint i;\n\n\tsoc_pcm_hw_init(hw);\n\n\t \n\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(cpu_dai, stream))\n\t\t\tcontinue;\n\n\t\tcpu_stream = snd_soc_dai_get_pcm_stream(cpu_dai, stream);\n\n\t\tsoc_pcm_hw_update_chan(hw, cpu_stream);\n\t\tsoc_pcm_hw_update_rate(hw, cpu_stream);\n\t\tsoc_pcm_hw_update_format(hw, cpu_stream);\n\t}\n\tcpu_chan_min = hw->channels_min;\n\tcpu_chan_max = hw->channels_max;\n\n\t \n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(codec_dai, stream))\n\t\t\tcontinue;\n\n\t\tcodec_stream = snd_soc_dai_get_pcm_stream(codec_dai, stream);\n\n\t\tsoc_pcm_hw_update_chan(hw, codec_stream);\n\t\tsoc_pcm_hw_update_rate(hw, codec_stream);\n\t\tsoc_pcm_hw_update_format(hw, codec_stream);\n\t}\n\n\t \n\tif (!hw->channels_min)\n\t\treturn -EINVAL;\n\n\t \n\tif (rtd->dai_link->num_codecs > 1) {\n\t\thw->channels_min = cpu_chan_min;\n\t\thw->channels_max = cpu_chan_max;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_runtime_calc_hw);\n\nstatic void soc_pcm_init_runtime_hw(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_hardware *hw = &substream->runtime->hw;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tu64 formats = hw->formats;\n\n\t \n\tsnd_soc_runtime_calc_hw(rtd, hw, substream->stream);\n\n\tif (formats)\n\t\thw->formats &= formats;\n}\n\nstatic int soc_pcm_components_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret = 0;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tret = snd_soc_component_module_get_when_open(component, substream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tret = snd_soc_component_open(component, substream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int soc_pcm_components_close(struct snd_pcm_substream *substream,\n\t\t\t\t    int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint i, ret = 0;\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tint r = snd_soc_component_close(component, substream, rollback);\n\t\tif (r < 0)\n\t\t\tret = r;  \n\n\t\tsnd_soc_component_module_put_when_close(component, substream, rollback);\n\t}\n\n\treturn ret;\n}\n\nstatic int soc_pcm_clean(struct snd_soc_pcm_runtime *rtd,\n\t\t\t struct snd_pcm_substream *substream, int rollback)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\tif (!rollback) {\n\t\tsnd_soc_runtime_deactivate(rtd, substream->stream);\n\n\t\t \n\t\tfor_each_rtd_dais(rtd, i, dai)\n\t\t\tif (snd_soc_dai_active(dai) == 0 &&\n\t\t\t    (dai->rate || dai->channels || dai->sample_bits))\n\t\t\t\tsoc_pcm_set_dai_params(dai, NULL);\n\t}\n\n\tfor_each_rtd_dais(rtd, i, dai)\n\t\tsnd_soc_dai_shutdown(dai, substream, rollback);\n\n\tsnd_soc_link_shutdown(substream, rollback);\n\n\tsoc_pcm_components_close(substream, rollback);\n\n\tsnd_soc_pcm_component_pm_runtime_put(rtd, substream, rollback);\n\n\tfor_each_rtd_components(rtd, i, component)\n\t\tif (!snd_soc_component_active(component))\n\t\t\tpinctrl_pm_select_sleep_state(component->dev);\n\n\treturn 0;\n}\n\n \nstatic int __soc_pcm_close(struct snd_soc_pcm_runtime *rtd,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\treturn soc_pcm_clean(rtd, substream, 0);\n}\n\n \nstatic int soc_pcm_close(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\t__soc_pcm_close(rtd, substream);\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn 0;\n}\n\nstatic int soc_hw_sanity_check(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_hardware *hw = &substream->runtime->hw;\n\tconst char *name_cpu = soc_cpu_dai_name(rtd);\n\tconst char *name_codec = soc_codec_dai_name(rtd);\n\tconst char *err_msg;\n\tstruct device *dev = rtd->dev;\n\n\terr_msg = \"rates\";\n\tif (!hw->rates)\n\t\tgoto config_err;\n\n\terr_msg = \"formats\";\n\tif (!hw->formats)\n\t\tgoto config_err;\n\n\terr_msg = \"channels\";\n\tif (!hw->channels_min || !hw->channels_max ||\n\t     hw->channels_min  >  hw->channels_max)\n\t\tgoto config_err;\n\n\tdev_dbg(dev, \"ASoC: %s <-> %s info:\\n\",\t\tname_codec,\n\t\t\t\t\t\t\tname_cpu);\n\tdev_dbg(dev, \"ASoC: rate mask 0x%x\\n\",\t\thw->rates);\n\tdev_dbg(dev, \"ASoC: ch   min %d max %d\\n\",\thw->channels_min,\n\t\t\t\t\t\t\thw->channels_max);\n\tdev_dbg(dev, \"ASoC: rate min %d max %d\\n\",\thw->rate_min,\n\t\t\t\t\t\t\thw->rate_max);\n\n\treturn 0;\n\nconfig_err:\n\tdev_err(dev, \"ASoC: %s <-> %s No matching %s\\n\",\n\t\tname_codec, name_cpu, err_msg);\n\treturn -EINVAL;\n}\n\n \nstatic int __soc_pcm_open(struct snd_soc_pcm_runtime *rtd,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *dai;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\tfor_each_rtd_components(rtd, i, component)\n\t\tpinctrl_pm_select_default_state(component->dev);\n\n\tret = snd_soc_pcm_component_pm_runtime_get(rtd, substream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = soc_pcm_components_open(substream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = snd_soc_link_startup(substream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tret = snd_soc_dai_startup(dai, substream);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (rtd->dai_link->dynamic || rtd->dai_link->no_pcm)\n\t\tgoto dynamic;\n\n\t \n\tsoc_pcm_init_runtime_hw(substream);\n\n\tsoc_pcm_update_symmetry(substream);\n\n\tret = soc_hw_sanity_check(substream);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsoc_pcm_apply_msb(substream);\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tret = soc_pcm_apply_symmetry(substream, dai);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\ndynamic:\n\tsnd_soc_runtime_activate(rtd, substream->stream);\n\tret = 0;\nerr:\n\tif (ret < 0)\n\t\tsoc_pcm_clean(rtd, substream, 1);\n\n\treturn soc_pcm_ret(rtd, ret);\n}\n\n \nstatic int soc_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\tret = __soc_pcm_open(rtd, substream);\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\n \nstatic int __soc_pcm_prepare(struct snd_soc_pcm_runtime *rtd,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_dai *dai;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\tret = snd_soc_link_prepare(substream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_pcm_component_prepare(substream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = snd_soc_pcm_dai_prepare(substream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    rtd->pop_wait) {\n\t\trtd->pop_wait = 0;\n\t\tcancel_delayed_work(&rtd->delayed_work);\n\t}\n\n\tsnd_soc_dapm_stream_event(rtd, substream->stream,\n\t\t\tSND_SOC_DAPM_STREAM_START);\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (dai->driver->ops && !dai->driver->ops->mute_unmute_on_trigger)\n\t\t\tsnd_soc_dai_digital_mute(dai, 0, substream->stream);\n\t}\n\nout:\n\treturn soc_pcm_ret(rtd, ret);\n}\n\n \nstatic int soc_pcm_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\tret = __soc_pcm_prepare(rtd, substream);\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\nstatic void soc_pcm_codec_params_fixup(struct snd_pcm_hw_params *params,\n\t\t\t\t       unsigned int mask)\n{\n\tstruct snd_interval *interval;\n\tint channels = hweight_long(mask);\n\n\tinterval = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tinterval->min = channels;\n\tinterval->max = channels;\n}\n\nstatic int soc_pcm_hw_clean(struct snd_soc_pcm_runtime *rtd,\n\t\t\t    struct snd_pcm_substream *substream, int rollback)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (snd_soc_dai_active(dai) == 1)\n\t\t\tsoc_pcm_set_dai_params(dai, NULL);\n\n\t\tif (snd_soc_dai_stream_active(dai, substream->stream) == 1) {\n\t\t\tif (dai->driver->ops && !dai->driver->ops->mute_unmute_on_trigger)\n\t\t\t\tsnd_soc_dai_digital_mute(dai, 1, substream->stream);\n\t\t}\n\t}\n\n\t \n\tsnd_soc_dapm_stream_stop(rtd, substream->stream);\n\n\t \n\tsnd_soc_link_hw_free(substream, rollback);\n\n\t \n\tsnd_soc_pcm_component_hw_free(substream, rollback);\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai)\n\t\tif (snd_soc_dai_stream_valid(dai, substream->stream))\n\t\t\tsnd_soc_dai_hw_free(dai, substream, rollback);\n\n\treturn 0;\n}\n\n \nstatic int __soc_pcm_hw_free(struct snd_soc_pcm_runtime *rtd,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\treturn soc_pcm_hw_clean(rtd, substream, 0);\n}\n\n \nstatic int soc_pcm_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\tret = __soc_pcm_hw_free(rtd, substream);\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\n \nstatic int __soc_pcm_hw_params(struct snd_soc_pcm_runtime *rtd,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct snd_soc_dai *codec_dai;\n\tstruct snd_pcm_hw_params tmp_params;\n\tint i, ret = 0;\n\n\tsnd_soc_dpcm_mutex_assert_held(rtd);\n\n\tret = soc_pcm_params_symmetry(substream, params);\n\tif (ret)\n\t\tgoto out;\n\n\tret = snd_soc_link_hw_params(substream, params);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tunsigned int tdm_mask = snd_soc_dai_tdm_mask_get(codec_dai, substream->stream);\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(codec_dai, substream->stream))\n\t\t\tcontinue;\n\n\t\t \n\t\ttmp_params = *params;\n\n\t\t \n\t\tif (tdm_mask)\n\t\t\tsoc_pcm_codec_params_fixup(&tmp_params, tdm_mask);\n\n\t\tret = snd_soc_dai_hw_params(codec_dai, substream,\n\t\t\t\t\t    &tmp_params);\n\t\tif(ret < 0)\n\t\t\tgoto out;\n\n\t\tsoc_pcm_set_dai_params(codec_dai, &tmp_params);\n\t\tsnd_soc_dapm_update_dai(substream, &tmp_params, codec_dai);\n\t}\n\n\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\tunsigned int ch_mask = 0;\n\t\tint j;\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(cpu_dai, substream->stream))\n\t\t\tcontinue;\n\n\t\t \n\t\ttmp_params = *params;\n\n\t\tif (!rtd->dai_link->codec_ch_maps)\n\t\t\tgoto hw_params;\n\t\t \n\t\tfor_each_rtd_codec_dais(rtd, j, codec_dai) {\n\t\t\tif (rtd->dai_link->codec_ch_maps[j].connected_cpu_id == i)\n\t\t\t\tch_mask |= rtd->dai_link->codec_ch_maps[j].ch_mask;\n\t\t}\n\n\t\t \n\t\tif (ch_mask)\n\t\t\tsoc_pcm_codec_params_fixup(&tmp_params, ch_mask);\n\nhw_params:\n\t\tret = snd_soc_dai_hw_params(cpu_dai, substream, &tmp_params);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tsoc_pcm_set_dai_params(cpu_dai, &tmp_params);\n\t\tsnd_soc_dapm_update_dai(substream, &tmp_params, cpu_dai);\n\t}\n\n\tret = snd_soc_pcm_component_hw_params(substream, params);\nout:\n\tif (ret < 0)\n\t\tsoc_pcm_hw_clean(rtd, substream, 1);\n\n\treturn soc_pcm_ret(rtd, ret);\n}\n\n \nstatic int soc_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\tret = __soc_pcm_hw_params(rtd, substream, params);\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n\treturn ret;\n}\n\n#define TRIGGER_MAX 3\nstatic int (* const trigger[][TRIGGER_MAX])(struct snd_pcm_substream *substream, int cmd, int rollback) = {\n\t[SND_SOC_TRIGGER_ORDER_DEFAULT] = {\n\t\tsnd_soc_link_trigger,\n\t\tsnd_soc_pcm_component_trigger,\n\t\tsnd_soc_pcm_dai_trigger,\n\t},\n\t[SND_SOC_TRIGGER_ORDER_LDC] = {\n\t\tsnd_soc_link_trigger,\n\t\tsnd_soc_pcm_dai_trigger,\n\t\tsnd_soc_pcm_component_trigger,\n\t},\n};\n\nstatic int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component;\n\tint ret = 0, r = 0, i;\n\tint rollback = 0;\n\tint start = 0, stop = 0;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (component->driver->trigger_start)\n\t\t\tstart = component->driver->trigger_start;\n\t\tif (component->driver->trigger_stop)\n\t\t\tstop = component->driver->trigger_stop;\n\t}\n\tif (rtd->dai_link->trigger_start)\n\t\tstart = rtd->dai_link->trigger_start;\n\tif (rtd->dai_link->trigger_stop)\n\t\tstop  = rtd->dai_link->trigger_stop;\n\n\tif (start < 0 || start >= SND_SOC_TRIGGER_ORDER_MAX ||\n\t    stop  < 0 || stop  >= SND_SOC_TRIGGER_ORDER_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor (i = 0; i < TRIGGER_MAX; i++) {\n\t\t\tr = trigger[start][i](substream, cmd, 0);\n\t\t\tif (r < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (r < 0) {\n\t\trollback = 1;\n\t\tret = r;\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\tcmd = SNDRV_PCM_TRIGGER_STOP;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t\tcmd = SNDRV_PCM_TRIGGER_SUSPEND;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\tcmd = SNDRV_PCM_TRIGGER_PAUSE_PUSH;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor (i = TRIGGER_MAX; i > 0; i--) {\n\t\t\tr = trigger[stop][i - 1](substream, cmd, rollback);\n\t\t\tif (r < 0)\n\t\t\t\tret = r;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic snd_pcm_uframes_t soc_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tsnd_pcm_uframes_t offset = 0;\n\tsnd_pcm_sframes_t codec_delay = 0;\n\tsnd_pcm_sframes_t cpu_delay = 0;\n\n\toffset = snd_soc_pcm_component_pointer(substream);\n\n\t \n\tsnd_soc_pcm_dai_delay(substream, &cpu_delay, &codec_delay);\n\tsnd_soc_pcm_component_delay(substream, &cpu_delay, &codec_delay);\n\n\truntime->delay = cpu_delay + codec_delay;\n\n\treturn offset;\n}\n\n \nstatic int dpcm_be_connect(struct snd_soc_pcm_runtime *fe,\n\t\tstruct snd_soc_pcm_runtime *be, int stream)\n{\n\tstruct snd_pcm_substream *fe_substream;\n\tstruct snd_pcm_substream *be_substream;\n\tstruct snd_soc_dpcm *dpcm;\n\n\tsnd_soc_dpcm_mutex_assert_held(fe);\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tif (dpcm->be == be && dpcm->fe == fe)\n\t\t\treturn 0;\n\t}\n\n\tfe_substream = snd_soc_dpcm_get_substream(fe, stream);\n\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\n\tif (!fe_substream->pcm->nonatomic && be_substream->pcm->nonatomic) {\n\t\tdev_err(be->dev, \"%s: FE is atomic but BE is nonatomic, invalid configuration\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tif (fe_substream->pcm->nonatomic && !be_substream->pcm->nonatomic) {\n\t\tdev_dbg(be->dev, \"FE is nonatomic but BE is not, forcing BE as nonatomic\\n\");\n\t\tbe_substream->pcm->nonatomic = 1;\n\t}\n\n\tdpcm = kzalloc(sizeof(struct snd_soc_dpcm), GFP_KERNEL);\n\tif (!dpcm)\n\t\treturn -ENOMEM;\n\n\tdpcm->be = be;\n\tdpcm->fe = fe;\n\tdpcm->state = SND_SOC_DPCM_LINK_STATE_NEW;\n\tsnd_soc_dpcm_stream_lock_irq(fe, stream);\n\tlist_add(&dpcm->list_be, &fe->dpcm[stream].be_clients);\n\tlist_add(&dpcm->list_fe, &be->dpcm[stream].fe_clients);\n\tsnd_soc_dpcm_stream_unlock_irq(fe, stream);\n\n\tdev_dbg(fe->dev, \"connected new DPCM %s path %s %s %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\",  fe->dai_link->name,\n\t\t\tstream ? \"<-\" : \"->\", be->dai_link->name);\n\n\tdpcm_create_debugfs_state(dpcm, stream);\n\n\treturn 1;\n}\n\n \nstatic void dpcm_be_reparent(struct snd_soc_pcm_runtime *fe,\n\t\t\tstruct snd_soc_pcm_runtime *be, int stream)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct snd_pcm_substream *fe_substream, *be_substream;\n\n\t \n\tif (!be->dpcm[stream].users)\n\t\treturn;\n\n\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\tif (!be_substream)\n\t\treturn;\n\n\tfor_each_dpcm_fe(be, stream, dpcm) {\n\t\tif (dpcm->fe == fe)\n\t\t\tcontinue;\n\n\t\tdev_dbg(fe->dev, \"reparent %s path %s %s %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\tdpcm->fe->dai_link->name,\n\t\t\tstream ? \"<-\" : \"->\", dpcm->be->dai_link->name);\n\n\t\tfe_substream = snd_soc_dpcm_get_substream(dpcm->fe, stream);\n\t\tbe_substream->runtime = fe_substream->runtime;\n\t\tbreak;\n\t}\n}\n\n \nvoid dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_soc_dpcm *dpcm, *d;\n\tLIST_HEAD(deleted_dpcms);\n\n\tsnd_soc_dpcm_mutex_assert_held(fe);\n\n\tsnd_soc_dpcm_stream_lock_irq(fe, stream);\n\tfor_each_dpcm_be_safe(fe, stream, dpcm, d) {\n\t\tdev_dbg(fe->dev, \"ASoC: BE %s disconnect check for %s\\n\",\n\t\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\t\tdpcm->be->dai_link->name);\n\n\t\tif (dpcm->state != SND_SOC_DPCM_LINK_STATE_FREE)\n\t\t\tcontinue;\n\n\t\tdev_dbg(fe->dev, \"freed DSP %s path %s %s %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\", fe->dai_link->name,\n\t\t\tstream ? \"<-\" : \"->\", dpcm->be->dai_link->name);\n\n\t\t \n\t\tdpcm_be_reparent(fe, dpcm->be, stream);\n\n\t\tlist_del(&dpcm->list_be);\n\t\tlist_move(&dpcm->list_fe, &deleted_dpcms);\n\t}\n\tsnd_soc_dpcm_stream_unlock_irq(fe, stream);\n\n\twhile (!list_empty(&deleted_dpcms)) {\n\t\tdpcm = list_first_entry(&deleted_dpcms, struct snd_soc_dpcm,\n\t\t\t\t\tlist_fe);\n\t\tlist_del(&dpcm->list_fe);\n\t\tdpcm_remove_debugfs_state(dpcm);\n\t\tkfree(dpcm);\n\t}\n}\n\n \nstatic struct snd_soc_pcm_runtime *dpcm_get_be(struct snd_soc_card *card,\n\t\tstruct snd_soc_dapm_widget *widget, int stream)\n{\n\tstruct snd_soc_pcm_runtime *be;\n\tstruct snd_soc_dapm_widget *w;\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tdev_dbg(card->dev, \"ASoC: find BE for widget %s\\n\", widget->name);\n\n\tfor_each_card_rtds(card, be) {\n\n\t\tif (!be->dai_link->no_pcm)\n\t\t\tcontinue;\n\n\t\tif (!snd_soc_dpcm_get_substream(be, stream))\n\t\t\tcontinue;\n\n\t\tfor_each_rtd_dais(be, i, dai) {\n\t\t\tw = snd_soc_dai_get_widget(dai, stream);\n\n\t\t\tdev_dbg(card->dev, \"ASoC: try BE : %s\\n\",\n\t\t\t\tw ? w->name : \"(not set)\");\n\n\t\t\tif (w == widget)\n\t\t\t\treturn be;\n\t\t}\n\t}\n\n\t \n\treturn NULL;\n}\n\nint widget_in_list(struct snd_soc_dapm_widget_list *list,\n\t\tstruct snd_soc_dapm_widget *widget)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tint i;\n\n\tfor_each_dapm_widgets(list, i, w)\n\t\tif (widget == w)\n\t\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(widget_in_list);\n\nbool dpcm_end_walk_at_be(struct snd_soc_dapm_widget *widget, enum snd_soc_dapm_direction dir)\n{\n\tstruct snd_soc_card *card = widget->dapm->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint stream;\n\n\t \n\tif (dir == SND_SOC_DAPM_DIR_OUT)\n\t\tstream = SNDRV_PCM_STREAM_PLAYBACK;\n\telse\n\t\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\n\trtd = dpcm_get_be(card, widget, stream);\n\tif (rtd)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(dpcm_end_walk_at_be);\n\nint dpcm_path_get(struct snd_soc_pcm_runtime *fe,\n\tint stream, struct snd_soc_dapm_widget_list **list)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(fe, 0);\n\tint paths;\n\n\tif (fe->dai_link->num_cpus > 1) {\n\t\tdev_err(fe->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpaths = snd_soc_dapm_dai_get_connected_widgets(cpu_dai, stream, list,\n\t\t\tfe->card->component_chaining ?\n\t\t\t\tNULL : dpcm_end_walk_at_be);\n\n\tif (paths > 0)\n\t\tdev_dbg(fe->dev, \"ASoC: found %d audio %s paths\\n\", paths,\n\t\t\tstream ? \"capture\" : \"playback\");\n\telse if (paths == 0)\n\t\tdev_dbg(fe->dev, \"ASoC: %s no valid %s path\\n\", fe->dai_link->name,\n\t\t\t stream ? \"capture\" : \"playback\");\n\n\treturn paths;\n}\n\nvoid dpcm_path_put(struct snd_soc_dapm_widget_list **list)\n{\n\tsnd_soc_dapm_dai_free_widgets(list);\n}\n\nstatic bool dpcm_be_is_active(struct snd_soc_dpcm *dpcm, int stream,\n\t\t\t      struct snd_soc_dapm_widget_list *list)\n{\n\tstruct snd_soc_dai *dai;\n\tunsigned int i;\n\n\t \n\tfor_each_rtd_dais(dpcm->be, i, dai) {\n\t\tstruct snd_soc_dapm_widget *widget = snd_soc_dai_get_widget(dai, stream);\n\n\t\t \n\t\tif (widget && widget_in_list(list, widget))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int dpcm_prune_paths(struct snd_soc_pcm_runtime *fe, int stream,\n\t\t\t    struct snd_soc_dapm_widget_list **list_)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\tint prune = 0;\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tif (dpcm_be_is_active(dpcm, stream, *list_))\n\t\t\tcontinue;\n\n\t\tdev_dbg(fe->dev, \"ASoC: pruning %s BE %s for %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\tdpcm->be->dai_link->name, fe->dai_link->name);\n\t\tdpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\n\t\tdpcm_set_be_update_state(dpcm->be, stream, SND_SOC_DPCM_UPDATE_BE);\n\t\tprune++;\n\t}\n\n\tdev_dbg(fe->dev, \"ASoC: found %d old BE paths for pruning\\n\", prune);\n\treturn prune;\n}\n\nstatic int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream,\n\tstruct snd_soc_dapm_widget_list **list_)\n{\n\tstruct snd_soc_card *card = fe->card;\n\tstruct snd_soc_dapm_widget_list *list = *list_;\n\tstruct snd_soc_pcm_runtime *be;\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct snd_pcm_substream *fe_substream = snd_soc_dpcm_get_substream(fe, stream);\n\tint i, new = 0, err;\n\n\t \n\tif (!fe_substream->runtime && !fe->fe_compr)\n\t\treturn new;\n\n\t \n\tfor_each_dapm_widgets(list, i, widget) {\n\n\t\tswitch (widget->id) {\n\t\tcase snd_soc_dapm_dai_in:\n\t\t\tif (stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_dai_out:\n\t\t\tif (stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbe = dpcm_get_be(card, widget, stream);\n\t\tif (!be) {\n\t\t\tdev_dbg(fe->dev, \"ASoC: no BE found for %s\\n\",\n\t\t\t\twidget->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (fe->card->component_chaining &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_NEW) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_CLOSE))\n\t\t\tcontinue;\n\n\t\t \n\t\terr = dpcm_be_connect(fe, be, stream);\n\t\tif (err < 0) {\n\t\t\tdev_err(fe->dev, \"ASoC: can't connect %s\\n\",\n\t\t\t\twidget->name);\n\t\t\tbreak;\n\t\t} else if (err == 0)  \n\t\t\tcontinue;\n\n\t\t \n\t\tdpcm_set_be_update_state(be, stream, SND_SOC_DPCM_UPDATE_BE);\n\t\tnew++;\n\t}\n\n\tdev_dbg(fe->dev, \"ASoC: found %d new BE paths\\n\", new);\n\treturn new;\n}\n\n \nint dpcm_process_paths(struct snd_soc_pcm_runtime *fe,\n\tint stream, struct snd_soc_dapm_widget_list **list, int new)\n{\n\tif (new)\n\t\treturn dpcm_add_paths(fe, stream, list);\n\telse\n\t\treturn dpcm_prune_paths(fe, stream, list);\n}\n\nvoid dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\n\tfor_each_dpcm_be(fe, stream, dpcm)\n\t\tdpcm_set_be_update_state(dpcm->be, stream, SND_SOC_DPCM_UPDATE_NO);\n}\n\nvoid dpcm_be_dai_stop(struct snd_soc_pcm_runtime *fe, int stream,\n\t\t      int do_hw_free, struct snd_soc_dpcm *last)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_pcm_substream *be_substream =\n\t\t\tsnd_soc_dpcm_get_substream(be, stream);\n\n\t\tif (dpcm == last)\n\t\t\treturn;\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif (be->dpcm[stream].users == 0) {\n\t\t\tdev_err(be->dev, \"ASoC: no users %s at close - state %d\\n\",\n\t\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\t\tbe->dpcm[stream].state);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (--be->dpcm[stream].users != 0)\n\t\t\tcontinue;\n\n\t\tif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) {\n\t\t\tif (!do_hw_free)\n\t\t\t\tcontinue;\n\n\t\t\tif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) {\n\t\t\t\t__soc_pcm_hw_free(be, be_substream);\n\t\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\n\t\t\t}\n\t\t}\n\n\t\t__soc_pcm_close(be, be_substream);\n\t\tbe_substream->runtime = NULL;\n\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\n\t}\n}\n\nint dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_pcm_substream *fe_substream = snd_soc_dpcm_get_substream(fe, stream);\n\tstruct snd_soc_pcm_runtime *be;\n\tstruct snd_soc_dpcm *dpcm;\n\tint err, count = 0;\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_pcm_substream *be_substream;\n\n\t\tbe = dpcm->be;\n\t\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\n\t\tif (!be_substream) {\n\t\t\tdev_err(be->dev, \"ASoC: no backend %s stream\\n\",\n\t\t\t\tstream ? \"capture\" : \"playback\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (be->dpcm[stream].users == DPCM_MAX_BE_USERS) {\n\t\t\tdev_err(be->dev, \"ASoC: too many users %s at open %d\\n\",\n\t\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\t\tbe->dpcm[stream].state);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (be->dpcm[stream].users++ != 0)\n\t\t\tcontinue;\n\n\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_NEW) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_CLOSE))\n\t\t\tcontinue;\n\n\t\tdev_dbg(be->dev, \"ASoC: open %s BE %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\", be->dai_link->name);\n\n\t\tbe_substream->runtime = fe_substream->runtime;\n\t\terr = __soc_pcm_open(be, be_substream);\n\t\tif (err < 0) {\n\t\t\tbe->dpcm[stream].users--;\n\t\t\tif (be->dpcm[stream].users < 0)\n\t\t\t\tdev_err(be->dev, \"ASoC: no users %s at unwind %d\\n\",\n\t\t\t\t\tstream ? \"capture\" : \"playback\",\n\t\t\t\t\tbe->dpcm[stream].state);\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\n\t\t\tgoto unwind;\n\t\t}\n\t\tbe->dpcm[stream].be_start = 0;\n\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\n\t\tcount++;\n\t}\n\n\treturn count;\n\nunwind:\n\tdpcm_be_dai_startup_rollback(fe, stream, dpcm);\n\n\treturn soc_pcm_ret(fe, err);\n}\n\nstatic void dpcm_runtime_setup_fe(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tstruct snd_soc_dai *dai;\n\tint stream = substream->stream;\n\tu64 formats = hw->formats;\n\tint i;\n\n\tsoc_pcm_hw_init(hw);\n\n\tif (formats)\n\t\thw->formats &= formats;\n\n\tfor_each_rtd_cpu_dais(fe, i, dai) {\n\t\tstruct snd_soc_pcm_stream *cpu_stream;\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(dai, stream))\n\t\t\tcontinue;\n\n\t\tcpu_stream = snd_soc_dai_get_pcm_stream(dai, stream);\n\n\t\tsoc_pcm_hw_update_rate(hw, cpu_stream);\n\t\tsoc_pcm_hw_update_chan(hw, cpu_stream);\n\t\tsoc_pcm_hw_update_format(hw, cpu_stream);\n\t}\n\n}\n\nstatic void dpcm_runtime_setup_be_format(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct snd_soc_dai *dai;\n\tint stream = substream->stream;\n\n\tif (!fe->dai_link->dpcm_merged_format)\n\t\treturn;\n\n\t \n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_soc_pcm_stream *codec_stream;\n\t\tint i;\n\n\t\tfor_each_rtd_codec_dais(be, i, dai) {\n\t\t\t \n\t\t\tif (!snd_soc_dai_stream_valid(dai, stream))\n\t\t\t\tcontinue;\n\n\t\t\tcodec_stream = snd_soc_dai_get_pcm_stream(dai, stream);\n\n\t\t\tsoc_pcm_hw_update_format(hw, codec_stream);\n\t\t}\n\t}\n}\n\nstatic void dpcm_runtime_setup_be_chan(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tstruct snd_soc_dpcm *dpcm;\n\tint stream = substream->stream;\n\n\tif (!fe->dai_link->dpcm_merged_chan)\n\t\treturn;\n\n\t \n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_soc_pcm_stream *cpu_stream;\n\t\tstruct snd_soc_dai *dai;\n\t\tint i;\n\n\t\tfor_each_rtd_cpu_dais(be, i, dai) {\n\t\t\t \n\t\t\tif (!snd_soc_dai_stream_valid(dai, stream))\n\t\t\t\tcontinue;\n\n\t\t\tcpu_stream = snd_soc_dai_get_pcm_stream(dai, stream);\n\n\t\t\tsoc_pcm_hw_update_chan(hw, cpu_stream);\n\t\t}\n\n\t\t \n\t\tif (be->dai_link->num_codecs == 1) {\n\t\t\tstruct snd_soc_pcm_stream *codec_stream = snd_soc_dai_get_pcm_stream(\n\t\t\t\tasoc_rtd_to_codec(be, 0), stream);\n\n\t\t\tsoc_pcm_hw_update_chan(hw, codec_stream);\n\t\t}\n\t}\n}\n\nstatic void dpcm_runtime_setup_be_rate(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_pcm_hardware *hw = &runtime->hw;\n\tstruct snd_soc_dpcm *dpcm;\n\tint stream = substream->stream;\n\n\tif (!fe->dai_link->dpcm_merged_rate)\n\t\treturn;\n\n\t \n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_soc_pcm_stream *pcm;\n\t\tstruct snd_soc_dai *dai;\n\t\tint i;\n\n\t\tfor_each_rtd_dais(be, i, dai) {\n\t\t\t \n\t\t\tif (!snd_soc_dai_stream_valid(dai, stream))\n\t\t\t\tcontinue;\n\n\t\t\tpcm = snd_soc_dai_get_pcm_stream(dai, stream);\n\n\t\t\tsoc_pcm_hw_update_rate(hw, pcm);\n\t\t}\n\t}\n}\n\nstatic int dpcm_apply_symmetry(struct snd_pcm_substream *fe_substream,\n\t\t\t       int stream)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(fe_substream);\n\tstruct snd_soc_dai *fe_cpu_dai;\n\tint err = 0;\n\tint i;\n\n\t \n\tsoc_pcm_update_symmetry(fe_substream);\n\n\tfor_each_rtd_cpu_dais (fe, i, fe_cpu_dai) {\n\t\t \n\t\terr = soc_pcm_apply_symmetry(fe_substream, fe_cpu_dai);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t}\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_pcm_substream *be_substream =\n\t\t\tsnd_soc_dpcm_get_substream(be, stream);\n\t\tstruct snd_soc_pcm_runtime *rtd;\n\t\tstruct snd_soc_dai *dai;\n\n\t\t \n\t\tif (!be_substream)\n\t\t\tcontinue;\n\n\t\trtd = asoc_substream_to_rtd(be_substream);\n\t\tif (rtd->dai_link->be_hw_params_fixup)\n\t\t\tcontinue;\n\n\t\tsoc_pcm_update_symmetry(be_substream);\n\n\t\t \n\t\tfor_each_rtd_dais(rtd, i, dai) {\n\t\t\terr = soc_pcm_apply_symmetry(fe_substream, dai);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\nerror:\n\treturn soc_pcm_ret(fe, err);\n}\n\nstatic int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(fe_substream);\n\tint stream = fe_substream->stream, ret = 0;\n\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\n\n\tret = dpcm_be_dai_startup(fe, stream);\n\tif (ret < 0)\n\t\tgoto be_err;\n\n\tdev_dbg(fe->dev, \"ASoC: open FE %s\\n\", fe->dai_link->name);\n\n\t \n\tret = __soc_pcm_open(fe, fe_substream);\n\tif (ret < 0)\n\t\tgoto unwind;\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;\n\n\tdpcm_runtime_setup_fe(fe_substream);\n\n\tdpcm_runtime_setup_be_format(fe_substream);\n\tdpcm_runtime_setup_be_chan(fe_substream);\n\tdpcm_runtime_setup_be_rate(fe_substream);\n\n\tret = dpcm_apply_symmetry(fe_substream, stream);\n\nunwind:\n\tif (ret < 0)\n\t\tdpcm_be_dai_startup_unwind(fe, stream);\nbe_err:\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\n\treturn soc_pcm_ret(fe, ret);\n}\n\nstatic int dpcm_fe_dai_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\n\tsnd_soc_dpcm_mutex_assert_held(fe);\n\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\n\n\t \n\tdpcm_be_dai_shutdown(fe, stream);\n\n\tdev_dbg(fe->dev, \"ASoC: close FE %s\\n\", fe->dai_link->name);\n\n\t \n\t__soc_pcm_close(fe, substream);\n\n\t \n\tdpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\treturn 0;\n}\n\nvoid dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_pcm_substream *be_substream =\n\t\t\tsnd_soc_dpcm_get_substream(be, stream);\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\n\t\t\t\tcontinue;\n\n\t\t \n\t\tif (be->dpcm[stream].users > 1)\n\t\t\tcontinue;\n\n\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\n\t\t\tcontinue;\n\n\t\tdev_dbg(be->dev, \"ASoC: hw_free BE %s\\n\",\n\t\t\tbe->dai_link->name);\n\n\t\t__soc_pcm_hw_free(be, be_substream);\n\n\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\n\t}\n}\n\nstatic int dpcm_fe_dai_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\n\n\tdev_dbg(fe->dev, \"ASoC: hw_free FE %s\\n\", fe->dai_link->name);\n\n\t \n\tsoc_pcm_hw_clean(fe, substream, 0);\n\n\t \n\tdpcm_be_dai_hw_free(fe, stream);\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_FREE;\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\treturn 0;\n}\n\nint dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_soc_pcm_runtime *be;\n\tstruct snd_pcm_substream *be_substream;\n\tstruct snd_soc_dpcm *dpcm;\n\tint ret;\n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_pcm_hw_params hw_params;\n\n\t\tbe = dpcm->be;\n\t\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\t \n\t\tmemcpy(&hw_params, &fe->dpcm[stream].hw_params,\n\t\t\t\tsizeof(struct snd_pcm_hw_params));\n\n\t\t \n\t\tret = snd_soc_link_be_hw_params_fixup(be, &hw_params);\n\t\tif (ret < 0)\n\t\t\tgoto unwind;\n\n\t\t \n\t\tmemcpy(&be->dpcm[stream].hw_params, &hw_params,\n\t\t       sizeof(struct snd_pcm_hw_params));\n\n\t\t \n\t\tif (!snd_soc_dpcm_can_be_params(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE))\n\t\t\tcontinue;\n\n\t\tdev_dbg(be->dev, \"ASoC: hw_params BE %s\\n\",\n\t\t\tbe->dai_link->name);\n\n\t\tret = __soc_pcm_hw_params(be, be_substream, &hw_params);\n\t\tif (ret < 0)\n\t\t\tgoto unwind;\n\n\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\n\t}\n\treturn 0;\n\nunwind:\n\tdev_dbg(fe->dev, \"ASoC: %s() failed at %s (%d)\\n\",\n\t\t__func__, be->dai_link->name, ret);\n\n\t \n\tfor_each_dpcm_be_rollback(fe, stream, dpcm) {\n\t\tbe = dpcm->be;\n\t\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!snd_soc_dpcm_can_be_free_stop(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_OPEN) &&\n\t\t   (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t\t   (be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &&\n\t\t   (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))\n\t\t\tcontinue;\n\n\t\t__soc_pcm_hw_free(be, be_substream);\n\t}\n\n\treturn ret;\n}\n\nstatic int dpcm_fe_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint ret, stream = substream->stream;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\n\n\tmemcpy(&fe->dpcm[stream].hw_params, params,\n\t\t\tsizeof(struct snd_pcm_hw_params));\n\tret = dpcm_be_dai_hw_params(fe, stream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdev_dbg(fe->dev, \"ASoC: hw_params FE %s rate %d chan %x fmt %d\\n\",\n\t\t\tfe->dai_link->name, params_rate(params),\n\t\t\tparams_channels(params), params_format(params));\n\n\t \n\tret = __soc_pcm_hw_params(fe, substream, params);\n\tif (ret < 0)\n\t\tdpcm_be_dai_hw_free(fe, stream);\n\telse\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;\n\nout:\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\n\treturn soc_pcm_ret(fe, ret);\n}\n\nint dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,\n\t\t\t       int cmd)\n{\n\tstruct snd_soc_pcm_runtime *be;\n\tbool pause_stop_transition;\n\tstruct snd_soc_dpcm *dpcm;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_pcm_substream *be_substream;\n\n\t\tbe = dpcm->be;\n\t\tbe_substream = snd_soc_dpcm_get_substream(be, stream);\n\n\t\tsnd_soc_dpcm_stream_lock_irqsave_nested(be, stream, flags);\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tgoto next;\n\n\t\tdev_dbg(be->dev, \"ASoC: trigger BE %s cmd %d\\n\",\n\t\t\tbe->dai_link->name, cmd);\n\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\t\tif (!be->dpcm[stream].be_start &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\n\t\t\t\tgoto next;\n\n\t\t\tbe->dpcm[stream].be_start++;\n\t\t\tif (be->dpcm[stream].be_start != 1)\n\t\t\t\tgoto next;\n\n\t\t\tif (be->dpcm[stream].state == SND_SOC_DPCM_STATE_PAUSED)\n\t\t\t\tret = soc_pcm_trigger(be_substream,\n\t\t\t\t\t\t      SNDRV_PCM_TRIGGER_PAUSE_RELEASE);\n\t\t\telse\n\t\t\t\tret = soc_pcm_trigger(be_substream,\n\t\t\t\t\t\t      SNDRV_PCM_TRIGGER_START);\n\t\t\tif (ret) {\n\t\t\t\tbe->dpcm[stream].be_start--;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))\n\t\t\t\tgoto next;\n\n\t\t\tbe->dpcm[stream].be_start++;\n\t\t\tif (be->dpcm[stream].be_start != 1)\n\t\t\t\tgoto next;\n\n\t\t\tret = soc_pcm_trigger(be_substream, cmd);\n\t\t\tif (ret) {\n\t\t\t\tbe->dpcm[stream].be_start--;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\tif (!be->dpcm[stream].be_start &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START) &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\n\t\t\t\tgoto next;\n\n\t\t\tfe->dpcm[stream].fe_pause = false;\n\t\t\tbe->dpcm[stream].be_pause--;\n\n\t\t\tbe->dpcm[stream].be_start++;\n\t\t\tif (be->dpcm[stream].be_start != 1)\n\t\t\t\tgoto next;\n\n\t\t\tret = soc_pcm_trigger(be_substream, cmd);\n\t\t\tif (ret) {\n\t\t\t\tbe->dpcm[stream].be_start--;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_START) &&\n\t\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\n\t\t\t\tgoto next;\n\n\t\t\tif (be->dpcm[stream].state == SND_SOC_DPCM_STATE_START)\n\t\t\t\tbe->dpcm[stream].be_start--;\n\n\t\t\tif (be->dpcm[stream].be_start != 0)\n\t\t\t\tgoto next;\n\n\t\t\tpause_stop_transition = false;\n\t\t\tif (fe->dpcm[stream].fe_pause) {\n\t\t\t\tpause_stop_transition = true;\n\t\t\t\tfe->dpcm[stream].fe_pause = false;\n\t\t\t\tbe->dpcm[stream].be_pause--;\n\t\t\t}\n\n\t\t\tif (be->dpcm[stream].be_pause != 0)\n\t\t\t\tret = soc_pcm_trigger(be_substream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);\n\t\t\telse\n\t\t\t\tret = soc_pcm_trigger(be_substream, SNDRV_PCM_TRIGGER_STOP);\n\n\t\t\tif (ret) {\n\t\t\t\tif (be->dpcm[stream].state == SND_SOC_DPCM_STATE_START)\n\t\t\t\t\tbe->dpcm[stream].be_start++;\n\t\t\t\tif (pause_stop_transition) {\n\t\t\t\t\tfe->dpcm[stream].fe_pause = true;\n\t\t\t\t\tbe->dpcm[stream].be_pause++;\n\t\t\t\t}\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tif (be->dpcm[stream].be_pause != 0)\n\t\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\n\t\t\telse\n\t\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\n\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\t\tif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\n\t\t\t\tgoto next;\n\n\t\t\tbe->dpcm[stream].be_start--;\n\t\t\tif (be->dpcm[stream].be_start != 0)\n\t\t\t\tgoto next;\n\n\t\t\tret = soc_pcm_trigger(be_substream, cmd);\n\t\t\tif (ret) {\n\t\t\t\tbe->dpcm[stream].be_start++;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_SUSPEND;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tif (be->dpcm[stream].state != SND_SOC_DPCM_STATE_START)\n\t\t\t\tgoto next;\n\n\t\t\tfe->dpcm[stream].fe_pause = true;\n\t\t\tbe->dpcm[stream].be_pause++;\n\n\t\t\tbe->dpcm[stream].be_start--;\n\t\t\tif (be->dpcm[stream].be_start != 0)\n\t\t\t\tgoto next;\n\n\t\t\tret = soc_pcm_trigger(be_substream, cmd);\n\t\t\tif (ret) {\n\t\t\t\tbe->dpcm[stream].be_start++;\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\n\t\t\tbreak;\n\t\t}\nnext:\n\t\tsnd_soc_dpcm_stream_unlock_irqrestore(be, stream, flags);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn soc_pcm_ret(fe, ret);\n}\nEXPORT_SYMBOL_GPL(dpcm_be_dai_trigger);\n\nstatic int dpcm_dai_trigger_fe_be(struct snd_pcm_substream *substream,\n\t\t\t\t  int cmd, bool fe_first)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\t \n\tif (fe_first) {\n\t\tdev_dbg(fe->dev, \"ASoC: pre trigger FE %s cmd %d\\n\",\n\t\t\tfe->dai_link->name, cmd);\n\n\t\tret = soc_pcm_trigger(substream, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\n\t\treturn ret;\n\t}\n\n\t \n\tret = dpcm_be_dai_trigger(fe, substream->stream, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(fe->dev, \"ASoC: post trigger FE %s cmd %d\\n\",\n\t\tfe->dai_link->name, cmd);\n\n\tret = soc_pcm_trigger(substream, cmd);\n\n\treturn ret;\n}\n\nstatic int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\tint ret = 0;\n\tenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\n\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;\n\n\tswitch (trigger) {\n\tcase SND_SOC_DPCM_TRIGGER_PRE:\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tcase SNDRV_PCM_TRIGGER_DRAIN:\n\t\t\tret = dpcm_dai_trigger_fe_be(substream, cmd, true);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tret = dpcm_dai_trigger_fe_be(substream, cmd, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DPCM_TRIGGER_POST:\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tcase SNDRV_PCM_TRIGGER_DRAIN:\n\t\t\tret = dpcm_dai_trigger_fe_be(substream, cmd, false);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\tret = dpcm_dai_trigger_fe_be(substream, cmd, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DPCM_TRIGGER_BESPOKE:\n\t\t \n\n\t\tdev_dbg(fe->dev, \"ASoC: bespoke trigger FE %s cmd %d\\n\",\n\t\t\t\tfe->dai_link->name, cmd);\n\n\t\tret = snd_soc_pcm_dai_bespoke_trigger(substream, cmd);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(fe->dev, \"ASoC: invalid trigger cmd %d for %s\\n\", cmd,\n\t\t\t\tfe->dai_link->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(fe->dev, \"ASoC: trigger FE cmd: %d failed: %d\\n\",\n\t\t\tcmd, ret);\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;\n\t\tbreak;\n\t}\n\nout:\n\tfe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;\n\treturn ret;\n}\n\nstatic int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\n\t \n\tif (fe->dpcm[stream].runtime_update != SND_SOC_DPCM_UPDATE_NO) {\n\t\tfe->dpcm[stream].trigger_pending = cmd + 1;\n\t\treturn 0;  \n\t}\n\n\t \n\treturn dpcm_fe_dai_do_trigger(substream, cmd);\n}\n\nint dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\tint ret = 0;\n\n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_pcm_substream *be_substream =\n\t\t\tsnd_soc_dpcm_get_substream(be, stream);\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif (!snd_soc_dpcm_can_be_prepared(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif ((be->dpcm[stream].state != SND_SOC_DPCM_STATE_HW_PARAMS) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND) &&\n\t\t    (be->dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED))\n\t\t\tcontinue;\n\n\t\tdev_dbg(be->dev, \"ASoC: prepare BE %s\\n\",\n\t\t\tbe->dai_link->name);\n\n\t\tret = __soc_pcm_prepare(be, be_substream);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tbe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\n\t}\n\n\treturn soc_pcm_ret(fe, ret);\n}\n\nstatic int dpcm_fe_dai_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream, ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\n\tdev_dbg(fe->dev, \"ASoC: prepare FE %s\\n\", fe->dai_link->name);\n\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);\n\n\t \n\tif (list_empty(&fe->dpcm[stream].be_clients)) {\n\t\t \n\t\tdev_err_once(fe->dev, \"ASoC: no backend DAIs enabled for %s, possibly missing ALSA mixer-based routing or UCM profile\\n\",\n\t\t\t     fe->dai_link->name);\n\t\tdev_dbg(fe->dev, \"ASoC: no backend DAIs enabled for %s\\n\",\n\t\t\tfe->dai_link->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = dpcm_be_dai_prepare(fe, stream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tret = __soc_pcm_prepare(fe, substream);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;\n\nout:\n\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\n\treturn soc_pcm_ret(fe, ret);\n}\n\nstatic int dpcm_run_update_shutdown(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_pcm_substream *substream =\n\t\tsnd_soc_dpcm_get_substream(fe, stream);\n\tenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\n\tint err;\n\n\tdev_dbg(fe->dev, \"ASoC: runtime %s close on FE %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\", fe->dai_link->name);\n\n\tif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\n\t\t \n\t\tdev_dbg(fe->dev, \"ASoC: bespoke trigger FE %s cmd stop\\n\",\n\t\t\t\tfe->dai_link->name);\n\n\t\terr = snd_soc_pcm_dai_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_STOP);\n\t} else {\n\t\tdev_dbg(fe->dev, \"ASoC: trigger FE %s cmd stop\\n\",\n\t\t\tfe->dai_link->name);\n\n\t\terr = dpcm_be_dai_trigger(fe, stream, SNDRV_PCM_TRIGGER_STOP);\n\t}\n\n\tdpcm_be_dai_hw_free(fe, stream);\n\n\tdpcm_be_dai_shutdown(fe, stream);\n\n\t \n\tdpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\n\n\treturn soc_pcm_ret(fe, err);\n}\n\nstatic int dpcm_run_update_startup(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tstruct snd_pcm_substream *substream =\n\t\tsnd_soc_dpcm_get_substream(fe, stream);\n\tstruct snd_soc_dpcm *dpcm;\n\tenum snd_soc_dpcm_trigger trigger = fe->dai_link->trigger[stream];\n\tint ret = 0;\n\n\tdev_dbg(fe->dev, \"ASoC: runtime %s open on FE %s\\n\",\n\t\t\tstream ? \"capture\" : \"playback\", fe->dai_link->name);\n\n\t \n\tif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_FREE ||\n\t\tfe->dpcm[stream].state == SND_SOC_DPCM_STATE_CLOSE) {\n\t\tdev_err(fe->dev, \"ASoC: FE %s is not ready %d\\n\",\n\t\t\tfe->dai_link->name, fe->dpcm[stream].state);\n\t\tret = -EINVAL;\n\t\tgoto disconnect;\n\t}\n\n\t \n\tret = dpcm_be_dai_startup(fe, stream);\n\tif (ret < 0)\n\t\tgoto disconnect;\n\n\t \n\tif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_OPEN)\n\t\treturn 0;\n\n\tret = dpcm_be_dai_hw_params(fe, stream);\n\tif (ret < 0)\n\t\tgoto close;\n\n\t \n\tif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_HW_PARAMS)\n\t\treturn 0;\n\n\tret = dpcm_be_dai_prepare(fe, stream);\n\tif (ret < 0)\n\t\tgoto hw_free;\n\n\t \n\tdpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_NOP);\n\n\t \n\tif (fe->dpcm[stream].state == SND_SOC_DPCM_STATE_PREPARE ||\n\t\tfe->dpcm[stream].state == SND_SOC_DPCM_STATE_STOP)\n\t\treturn 0;\n\n\tif (trigger == SND_SOC_DPCM_TRIGGER_BESPOKE) {\n\t\t \n\t\tdev_dbg(fe->dev, \"ASoC: bespoke trigger FE %s cmd start\\n\",\n\t\t\t\tfe->dai_link->name);\n\n\t\tret = snd_soc_pcm_dai_bespoke_trigger(substream, SNDRV_PCM_TRIGGER_START);\n\t\tif (ret < 0)\n\t\t\tgoto hw_free;\n\t} else {\n\t\tdev_dbg(fe->dev, \"ASoC: trigger FE %s cmd start\\n\",\n\t\t\tfe->dai_link->name);\n\n\t\tret = dpcm_be_dai_trigger(fe, stream,\n\t\t\t\t\tSNDRV_PCM_TRIGGER_START);\n\t\tif (ret < 0)\n\t\t\tgoto hw_free;\n\t}\n\n\treturn 0;\n\nhw_free:\n\tdpcm_be_dai_hw_free(fe, stream);\nclose:\n\tdpcm_be_dai_shutdown(fe, stream);\ndisconnect:\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\n\t\t \n\t\tif (!snd_soc_dpcm_be_can_update(fe, be, stream))\n\t\t\tcontinue;\n\n\t\tif (be->dpcm[stream].state == SND_SOC_DPCM_STATE_CLOSE ||\n\t\t\tbe->dpcm[stream].state == SND_SOC_DPCM_STATE_NEW)\n\t\t\t\tdpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\n\t}\n\n\treturn soc_pcm_ret(fe, ret);\n}\n\nstatic int soc_dpcm_fe_runtime_update(struct snd_soc_pcm_runtime *fe, int new)\n{\n\tstruct snd_soc_dapm_widget_list *list;\n\tint stream;\n\tint count, paths;\n\n\tif (!fe->dai_link->dynamic)\n\t\treturn 0;\n\n\tif (fe->dai_link->num_cpus > 1) {\n\t\tdev_err(fe->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!snd_soc_dai_active(asoc_rtd_to_cpu(fe, 0)))\n\t\treturn 0;\n\n\t \n\tdev_dbg(fe->dev, \"ASoC: DPCM %s runtime update for FE %s\\n\",\n\t\tnew ? \"new\" : \"old\", fe->dai_link->name);\n\n\tfor_each_pcm_streams(stream) {\n\n\t\t \n\t\tif (!snd_soc_dai_stream_valid(asoc_rtd_to_cpu(fe, 0),   stream) ||\n\t\t    !snd_soc_dai_stream_valid(asoc_rtd_to_codec(fe, 0), stream))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!snd_soc_dai_stream_active(asoc_rtd_to_cpu(fe, 0), stream) ||\n\t\t    !snd_soc_dai_stream_active(asoc_rtd_to_codec(fe, 0), stream))\n\t\t\tcontinue;\n\n\t\tpaths = dpcm_path_get(fe, stream, &list);\n\t\tif (paths < 0)\n\t\t\treturn paths;\n\n\t\t \n\t\tcount = dpcm_process_paths(fe, stream, &list, new);\n\t\tif (count) {\n\t\t\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_BE);\n\t\t\tif (new)\n\t\t\t\tdpcm_run_update_startup(fe, stream);\n\t\t\telse\n\t\t\t\tdpcm_run_update_shutdown(fe, stream);\n\t\t\tdpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_NO);\n\n\t\t\tdpcm_clear_pending_state(fe, stream);\n\t\t\tdpcm_be_disconnect(fe, stream);\n\t\t}\n\n\t\tdpcm_path_put(&list);\n\t}\n\n\treturn 0;\n}\n\n \nint snd_soc_dpcm_runtime_update(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *fe;\n\tint ret = 0;\n\n\tsnd_soc_dpcm_mutex_lock(card);\n\t \n\tfor_each_card_rtds(card, fe) {\n\t\tret = soc_dpcm_fe_runtime_update(fe, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tfor_each_card_rtds(card, fe) {\n\t\tret = soc_dpcm_fe_runtime_update(fe, 1);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\nout:\n\tsnd_soc_dpcm_mutex_unlock(card);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_runtime_update);\n\nstatic void dpcm_fe_dai_cleanup(struct snd_pcm_substream *fe_substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(fe_substream);\n\tstruct snd_soc_dpcm *dpcm;\n\tint stream = fe_substream->stream;\n\n\tsnd_soc_dpcm_mutex_assert_held(fe);\n\n\t \n\tfor_each_dpcm_be(fe, stream, dpcm)\n\t\tdpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;\n\n\tdpcm_be_disconnect(fe, stream);\n}\n\nstatic int dpcm_fe_dai_close(struct snd_pcm_substream *fe_substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(fe_substream);\n\tint ret;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\tret = dpcm_fe_dai_shutdown(fe_substream);\n\n\tdpcm_fe_dai_cleanup(fe_substream);\n\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\treturn ret;\n}\n\nstatic int dpcm_fe_dai_open(struct snd_pcm_substream *fe_substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(fe_substream);\n\tstruct snd_soc_dapm_widget_list *list;\n\tint ret;\n\tint stream = fe_substream->stream;\n\n\tsnd_soc_dpcm_mutex_lock(fe);\n\n\tret = dpcm_path_get(fe, stream, &list);\n\tif (ret < 0)\n\t\tgoto open_end;\n\n\t \n\tdpcm_process_paths(fe, stream, &list, 1);\n\n\tret = dpcm_fe_dai_startup(fe_substream);\n\tif (ret < 0)\n\t\tdpcm_fe_dai_cleanup(fe_substream);\n\n\tdpcm_clear_pending_state(fe, stream);\n\tdpcm_path_put(&list);\nopen_end:\n\tsnd_soc_dpcm_mutex_unlock(fe);\n\treturn ret;\n}\n\nstatic int soc_get_playback_capture(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t    int *playback, int *capture)\n{\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tstruct snd_soc_dai *cpu_dai;\n\tint has_playback = 0;\n\tint has_capture  = 0;\n\tint i;\n\n\tif (dai_link->dynamic && dai_link->num_cpus > 1) {\n\t\tdev_err(rtd->dev, \"DPCM doesn't support Multi CPU for Front-Ends yet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dai_link->dynamic || dai_link->no_pcm) {\n\t\tint stream;\n\n\t\tif (dai_link->dpcm_playback) {\n\t\t\tstream = SNDRV_PCM_STREAM_PLAYBACK;\n\n\t\t\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\t\t\tif (snd_soc_dai_stream_valid(cpu_dai, stream)) {\n\t\t\t\t\thas_playback = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!has_playback) {\n\t\t\t\tdev_err(rtd->card->dev,\n\t\t\t\t\t\"No CPU DAIs support playback for stream %s\\n\",\n\t\t\t\t\tdai_link->stream_name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (dai_link->dpcm_capture) {\n\t\t\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\n\t\t\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\t\t\tif (snd_soc_dai_stream_valid(cpu_dai, stream)) {\n\t\t\t\t\thas_capture = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!has_capture) {\n\t\t\t\tdev_err(rtd->card->dev,\n\t\t\t\t\t\"No CPU DAIs support capture for stream %s\\n\",\n\t\t\t\t\tdai_link->stream_name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct snd_soc_dai *codec_dai;\n\n\t\t \n\t\tint cpu_capture  = snd_soc_get_stream_cpu(dai_link, SNDRV_PCM_STREAM_CAPTURE);\n\t\tint cpu_playback = snd_soc_get_stream_cpu(dai_link, SNDRV_PCM_STREAM_PLAYBACK);\n\n\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t\tif (dai_link->num_cpus == 1) {\n\t\t\t\tcpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\t\t\t} else if (dai_link->num_cpus == dai_link->num_codecs) {\n\t\t\t\tcpu_dai = asoc_rtd_to_cpu(rtd, i);\n\t\t\t} else if (rtd->dai_link->num_codecs > rtd->dai_link->num_cpus) {\n\t\t\t\tint cpu_id;\n\n\t\t\t\tif (!rtd->dai_link->codec_ch_maps) {\n\t\t\t\t\tdev_err(rtd->card->dev, \"%s: no codec channel mapping table provided\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tcpu_id = rtd->dai_link->codec_ch_maps[i].connected_cpu_id;\n\t\t\t\tcpu_dai = asoc_rtd_to_cpu(rtd, cpu_id);\n\t\t\t} else {\n\t\t\t\tdev_err(rtd->card->dev,\n\t\t\t\t\t\"%s codec number %d < cpu number %d is not supported\\n\",\n\t\t\t\t\t__func__, rtd->dai_link->num_codecs,\n\t\t\t\t\trtd->dai_link->num_cpus);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (snd_soc_dai_stream_valid(codec_dai, SNDRV_PCM_STREAM_PLAYBACK) &&\n\t\t\t    snd_soc_dai_stream_valid(cpu_dai,   cpu_playback))\n\t\t\t\thas_playback = 1;\n\t\t\tif (snd_soc_dai_stream_valid(codec_dai, SNDRV_PCM_STREAM_CAPTURE) &&\n\t\t\t    snd_soc_dai_stream_valid(cpu_dai,   cpu_capture))\n\t\t\t\thas_capture = 1;\n\t\t}\n\t}\n\n\tif (dai_link->playback_only)\n\t\thas_capture = 0;\n\n\tif (dai_link->capture_only)\n\t\thas_playback = 0;\n\n\tif (!has_playback && !has_capture) {\n\t\tdev_err(rtd->dev, \"substream %s has no playback, no capture\\n\",\n\t\t\tdai_link->stream_name);\n\n\t\treturn -EINVAL;\n\t}\n\n\t*playback = has_playback;\n\t*capture  = has_capture;\n\n\treturn 0;\n}\n\nstatic int soc_create_pcm(struct snd_pcm **pcm,\n\t\t\t  struct snd_soc_pcm_runtime *rtd,\n\t\t\t  int playback, int capture, int num)\n{\n\tchar new_name[64];\n\tint ret;\n\n\t \n\tif (rtd->dai_link->c2c_params) {\n\t\tsnprintf(new_name, sizeof(new_name), \"codec2codec(%s)\",\n\t\t\t rtd->dai_link->stream_name);\n\n\t\tret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\n\t\t\t\t\t   playback, capture, pcm);\n\t} else if (rtd->dai_link->no_pcm) {\n\t\tsnprintf(new_name, sizeof(new_name), \"(%s)\",\n\t\t\trtd->dai_link->stream_name);\n\n\t\tret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,\n\t\t\t\tplayback, capture, pcm);\n\t} else {\n\t\tif (rtd->dai_link->dynamic)\n\t\t\tsnprintf(new_name, sizeof(new_name), \"%s (*)\",\n\t\t\t\trtd->dai_link->stream_name);\n\t\telse\n\t\t\tsnprintf(new_name, sizeof(new_name), \"%s %s-%d\",\n\t\t\t\trtd->dai_link->stream_name,\n\t\t\t\tsoc_codec_dai_name(rtd), num);\n\n\t\tret = snd_pcm_new(rtd->card->snd_card, new_name, num, playback,\n\t\t\tcapture, pcm);\n\t}\n\tif (ret < 0) {\n\t\tdev_err(rtd->card->dev, \"ASoC: can't create pcm %s for dailink %s: %d\\n\",\n\t\t\tnew_name, rtd->dai_link->name, ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(rtd->card->dev, \"ASoC: registered pcm #%d %s\\n\",num, new_name);\n\n\treturn 0;\n}\n\n \nint soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_pcm *pcm;\n\tint ret = 0, playback = 0, capture = 0;\n\tint i;\n\n\tret = soc_get_playback_capture(rtd, &playback, &capture);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = soc_create_pcm(&pcm, rtd, playback, capture, num);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tif (!rtd->dai_link->c2c_params)\n\t\trtd->close_delayed_work_func = snd_soc_close_delayed_work;\n\n\trtd->pcm = pcm;\n\tpcm->nonatomic = rtd->dai_link->nonatomic;\n\tpcm->private_data = rtd;\n\tpcm->no_device_suspend = true;\n\n\tif (rtd->dai_link->no_pcm || rtd->dai_link->c2c_params) {\n\t\tif (playback)\n\t\t\tpcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;\n\t\tif (capture)\n\t\t\tpcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;\n\t\tgoto out;\n\t}\n\n\t \n\tif (rtd->dai_link->dynamic) {\n\t\trtd->ops.open\t\t= dpcm_fe_dai_open;\n\t\trtd->ops.hw_params\t= dpcm_fe_dai_hw_params;\n\t\trtd->ops.prepare\t= dpcm_fe_dai_prepare;\n\t\trtd->ops.trigger\t= dpcm_fe_dai_trigger;\n\t\trtd->ops.hw_free\t= dpcm_fe_dai_hw_free;\n\t\trtd->ops.close\t\t= dpcm_fe_dai_close;\n\t\trtd->ops.pointer\t= soc_pcm_pointer;\n\t} else {\n\t\trtd->ops.open\t\t= soc_pcm_open;\n\t\trtd->ops.hw_params\t= soc_pcm_hw_params;\n\t\trtd->ops.prepare\t= soc_pcm_prepare;\n\t\trtd->ops.trigger\t= soc_pcm_trigger;\n\t\trtd->ops.hw_free\t= soc_pcm_hw_free;\n\t\trtd->ops.close\t\t= soc_pcm_close;\n\t\trtd->ops.pointer\t= soc_pcm_pointer;\n\t}\n\n\tfor_each_rtd_components(rtd, i, component) {\n\t\tconst struct snd_soc_component_driver *drv = component->driver;\n\n\t\tif (drv->ioctl)\n\t\t\trtd->ops.ioctl\t\t= snd_soc_pcm_component_ioctl;\n\t\tif (drv->sync_stop)\n\t\t\trtd->ops.sync_stop\t= snd_soc_pcm_component_sync_stop;\n\t\tif (drv->copy)\n\t\t\trtd->ops.copy\t\t= snd_soc_pcm_component_copy;\n\t\tif (drv->page)\n\t\t\trtd->ops.page\t\t= snd_soc_pcm_component_page;\n\t\tif (drv->mmap)\n\t\t\trtd->ops.mmap\t\t= snd_soc_pcm_component_mmap;\n\t\tif (drv->ack)\n\t\t\trtd->ops.ack            = snd_soc_pcm_component_ack;\n\t}\n\n\tif (playback)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &rtd->ops);\n\n\tif (capture)\n\t\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &rtd->ops);\n\n\tret = snd_soc_pcm_component_new(rtd);\n\tif (ret < 0)\n\t\treturn ret;\nout:\n\tdev_dbg(rtd->card->dev, \"%s <-> %s mapping ok\\n\",\n\t\tsoc_codec_dai_name(rtd), soc_cpu_dai_name(rtd));\n\treturn ret;\n}\n\n \nint snd_soc_dpcm_fe_can_update(struct snd_soc_pcm_runtime *fe, int stream)\n{\n\tif (fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE)\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_fe_can_update);\n\n \nint snd_soc_dpcm_be_can_update(struct snd_soc_pcm_runtime *fe,\n\t\tstruct snd_soc_pcm_runtime *be, int stream)\n{\n\tif ((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_FE) ||\n\t   ((fe->dpcm[stream].runtime_update == SND_SOC_DPCM_UPDATE_BE) &&\n\t\t  be->dpcm[stream].runtime_update))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_be_can_update);\n\n \nstruct snd_pcm_substream *\n\tsnd_soc_dpcm_get_substream(struct snd_soc_pcm_runtime *be, int stream)\n{\n\treturn be->pcm->streams[stream].substream;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_get_substream);\n\nstatic int snd_soc_dpcm_check_state(struct snd_soc_pcm_runtime *fe,\n\t\t\t\t    struct snd_soc_pcm_runtime *be,\n\t\t\t\t    int stream,\n\t\t\t\t    const enum snd_soc_dpcm_state *states,\n\t\t\t\t    int num_states)\n{\n\tstruct snd_soc_dpcm *dpcm;\n\tint state;\n\tint ret = 1;\n\tint i;\n\n\tfor_each_dpcm_fe(be, stream, dpcm) {\n\n\t\tif (dpcm->fe == fe)\n\t\t\tcontinue;\n\n\t\tstate = dpcm->fe->dpcm[stream].state;\n\t\tfor (i = 0; i < num_states; i++) {\n\t\t\tif (state == states[i]) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn ret;\n}\n\n \nint snd_soc_dpcm_can_be_free_stop(struct snd_soc_pcm_runtime *fe,\n\t\tstruct snd_soc_pcm_runtime *be, int stream)\n{\n\tconst enum snd_soc_dpcm_state state[] = {\n\t\tSND_SOC_DPCM_STATE_START,\n\t\tSND_SOC_DPCM_STATE_PAUSED,\n\t\tSND_SOC_DPCM_STATE_SUSPEND,\n\t};\n\n\treturn snd_soc_dpcm_check_state(fe, be, stream, state, ARRAY_SIZE(state));\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_can_be_free_stop);\n\n \nint snd_soc_dpcm_can_be_params(struct snd_soc_pcm_runtime *fe,\n\t\tstruct snd_soc_pcm_runtime *be, int stream)\n{\n\tconst enum snd_soc_dpcm_state state[] = {\n\t\tSND_SOC_DPCM_STATE_START,\n\t\tSND_SOC_DPCM_STATE_PAUSED,\n\t\tSND_SOC_DPCM_STATE_SUSPEND,\n\t\tSND_SOC_DPCM_STATE_PREPARE,\n\t};\n\n\treturn snd_soc_dpcm_check_state(fe, be, stream, state, ARRAY_SIZE(state));\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_can_be_params);\n\n \nint snd_soc_dpcm_can_be_prepared(struct snd_soc_pcm_runtime *fe,\n\t\t\t\t struct snd_soc_pcm_runtime *be, int stream)\n{\n\tconst enum snd_soc_dpcm_state state[] = {\n\t\tSND_SOC_DPCM_STATE_START,\n\t\tSND_SOC_DPCM_STATE_PAUSED,\n\t\tSND_SOC_DPCM_STATE_PREPARE,\n\t};\n\n\treturn snd_soc_dpcm_check_state(fe, be, stream, state, ARRAY_SIZE(state));\n}\nEXPORT_SYMBOL_GPL(snd_soc_dpcm_can_be_prepared);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}