{
  "module_name": "tegra210_mvc.c",
  "hash_id": "ce5f77a08d545ea8e26ac39743e2a13307b4a4a18720e64c8adbfb3fbc2286ed",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_mvc.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"tegra210_mvc.h\"\n#include \"tegra_cif.h\"\n\nstatic const struct reg_default tegra210_mvc_reg_defaults[] = {\n\t{ TEGRA210_MVC_RX_INT_MASK, 0x00000001},\n\t{ TEGRA210_MVC_RX_CIF_CTRL, 0x00007700},\n\t{ TEGRA210_MVC_TX_INT_MASK, 0x00000001},\n\t{ TEGRA210_MVC_TX_CIF_CTRL, 0x00007700},\n\t{ TEGRA210_MVC_CG, 0x1},\n\t{ TEGRA210_MVC_CTRL, TEGRA210_MVC_CTRL_DEFAULT},\n\t{ TEGRA210_MVC_INIT_VOL, 0x00800000},\n\t{ TEGRA210_MVC_TARGET_VOL, 0x00800000},\n\t{ TEGRA210_MVC_DURATION, 0x000012c0},\n\t{ TEGRA210_MVC_DURATION_INV, 0x0006d3a0},\n\t{ TEGRA210_MVC_POLY_N1, 0x0000007d},\n\t{ TEGRA210_MVC_POLY_N2, 0x00000271},\n\t{ TEGRA210_MVC_PEAK_CTRL, 0x000012c0},\n\t{ TEGRA210_MVC_CFG_RAM_CTRL, 0x00004000},\n};\n\nstatic const struct tegra210_mvc_gain_params gain_params = {\n\t.poly_coeff = { 23738319, 659403, -3680,\n\t\t\t15546680, 2530732, -120985,\n\t\t\t12048422, 5527252, -785042 },\n\t.poly_n1 = 16,\n\t.poly_n2 = 63,\n\t.duration = 150,\n\t.duration_inv = 14316558,\n};\n\nstatic int __maybe_unused tegra210_mvc_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_mvc *mvc = dev_get_drvdata(dev);\n\n\tregmap_read(mvc->regmap, TEGRA210_MVC_CTRL, &(mvc->ctrl_value));\n\n\tregcache_cache_only(mvc->regmap, true);\n\tregcache_mark_dirty(mvc->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_mvc_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_mvc *mvc = dev_get_drvdata(dev);\n\n\tregcache_cache_only(mvc->regmap, false);\n\tregcache_sync(mvc->regmap);\n\n\tregmap_write(mvc->regmap, TEGRA210_MVC_CTRL, mvc->ctrl_value);\n\tregmap_update_bits(mvc->regmap,\n\t\t\t   TEGRA210_MVC_SWITCH,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_MASK,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_TRIGGER);\n\n\treturn 0;\n}\n\nstatic void tegra210_mvc_write_ram(struct regmap *regmap)\n{\n\tint i;\n\n\tregmap_write(regmap, TEGRA210_MVC_CFG_RAM_CTRL,\n\t\t     TEGRA210_MVC_CFG_RAM_CTRL_SEQ_ACCESS_EN |\n\t\t     TEGRA210_MVC_CFG_RAM_CTRL_ADDR_INIT_EN |\n\t\t     TEGRA210_MVC_CFG_RAM_CTRL_RW_WRITE);\n\n\tfor (i = 0; i < NUM_GAIN_POLY_COEFFS; i++)\n\t\tregmap_write(regmap, TEGRA210_MVC_CFG_RAM_DATA,\n\t\t\t     gain_params.poly_coeff[i]);\n}\n\nstatic void tegra210_mvc_conv_vol(struct tegra210_mvc *mvc, u8 chan, s32 val)\n{\n\t \n\tif (mvc->curve_type == CURVE_POLY) {\n\t\tif (val > 10000)\n\t\t\tval = 10000;\n\t\tmvc->volume[chan] = ((val * (1<<8)) / 100) << 16;\n\t} else {\n\t\tval -= 12000;\n\t\tmvc->volume[chan] = (val * (1<<8)) / 100;\n\t}\n}\n\nstatic u32 tegra210_mvc_get_ctrl_reg(struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tu32 val;\n\n\tpm_runtime_get_sync(cmpnt->dev);\n\tregmap_read(mvc->regmap, TEGRA210_MVC_CTRL, &val);\n\tpm_runtime_put(cmpnt->dev);\n\n\treturn val;\n}\n\nstatic int tegra210_mvc_get_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tu32 val = tegra210_mvc_get_ctrl_reg(kcontrol);\n\tu8 mute_mask = TEGRA210_GET_MUTE_VAL(val);\n\n\t \n\tif (val & TEGRA210_MVC_PER_CHAN_CTRL_EN) {\n\t\tucontrol->value.integer.value[0] = mute_mask;\n\t} else {\n\t\tif (mute_mask & TEGRA210_MVC_CH0_MUTE_EN)\n\t\t\tucontrol->value.integer.value[0] =\n\t\t\t\tTEGRA210_MUTE_MASK_EN;\n\t\telse\n\t\t\tucontrol->value.integer.value[0] = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_get_master_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tu32 val = tegra210_mvc_get_ctrl_reg(kcontrol);\n\tu8 mute_mask = TEGRA210_GET_MUTE_VAL(val);\n\n\t \n\tif (!(val & TEGRA210_MVC_PER_CHAN_CTRL_EN)) {\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmute_mask & TEGRA210_MVC_CH0_MUTE_EN;\n\t} else {\n\t\tif (mute_mask == TEGRA210_MUTE_MASK_EN)\n\t\t\tucontrol->value.integer.value[0] =\n\t\t\t\tTEGRA210_MVC_CH0_MUTE_EN;\n\t\telse\n\t\t\tucontrol->value.integer.value[0] = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_volume_switch_timeout(struct snd_soc_component *cmpnt)\n{\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tu32 value;\n\tint err;\n\n\terr = regmap_read_poll_timeout(mvc->regmap, TEGRA210_MVC_SWITCH,\n\t\t\tvalue, !(value & TEGRA210_MVC_VOLUME_SWITCH_MASK),\n\t\t\t10, 10000);\n\tif (err < 0)\n\t\tdev_err(cmpnt->dev,\n\t\t\t\"Volume switch trigger is still active, err = %d\\n\",\n\t\t\terr);\n\n\treturn err;\n}\n\nstatic int tegra210_mvc_update_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t    bool per_chan_ctrl)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tu32 mute_val = ucontrol->value.integer.value[0];\n\tu32 per_ch_ctrl_val;\n\tbool change = false;\n\tint err;\n\n\tpm_runtime_get_sync(cmpnt->dev);\n\n\terr = tegra210_mvc_volume_switch_timeout(cmpnt);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (per_chan_ctrl) {\n\t\tper_ch_ctrl_val = TEGRA210_MVC_PER_CHAN_CTRL_EN;\n\t} else {\n\t\tper_ch_ctrl_val = 0;\n\n\t\tif (mute_val)\n\t\t\tmute_val = TEGRA210_MUTE_MASK_EN;\n\t}\n\n\tregmap_update_bits_check(mvc->regmap, TEGRA210_MVC_CTRL,\n\t\t\t\t TEGRA210_MVC_MUTE_MASK,\n\t\t\t\t mute_val << TEGRA210_MVC_MUTE_SHIFT,\n\t\t\t\t &change);\n\n\tif (change) {\n\t\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_CTRL,\n\t\t\t\t   TEGRA210_MVC_PER_CHAN_CTRL_EN_MASK,\n\t\t\t\t   per_ch_ctrl_val);\n\n\t\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_SWITCH,\n\t\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_MASK,\n\t\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_TRIGGER);\n\t}\n\nend:\n\tpm_runtime_put(cmpnt->dev);\n\n\tif (err < 0)\n\t\treturn err;\n\n\tif (change)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_put_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\treturn tegra210_mvc_update_mute(kcontrol, ucontrol, true);\n}\n\nstatic int tegra210_mvc_put_master_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\treturn tegra210_mvc_update_mute(kcontrol, ucontrol, false);\n}\n\nstatic int tegra210_mvc_get_vol(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tu8 chan = TEGRA210_MVC_GET_CHAN(mc->reg, TEGRA210_MVC_TARGET_VOL);\n\ts32 val = mvc->volume[chan];\n\n\tif (mvc->curve_type == CURVE_POLY) {\n\t\tval = ((val >> 16) * 100) >> 8;\n\t} else {\n\t\tval = (val * 100) >> 8;\n\t\tval += 12000;\n\t}\n\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_get_master_vol(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\treturn tegra210_mvc_get_vol(kcontrol, ucontrol);\n}\n\nstatic int tegra210_mvc_update_vol(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol,\n\t\t\t\t   bool per_ch_enable)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tu8 chan = TEGRA210_MVC_GET_CHAN(mc->reg, TEGRA210_MVC_TARGET_VOL);\n\tint old_volume = mvc->volume[chan];\n\tint err, i;\n\n\tpm_runtime_get_sync(cmpnt->dev);\n\n\terr = tegra210_mvc_volume_switch_timeout(cmpnt);\n\tif (err < 0)\n\t\tgoto end;\n\n\ttegra210_mvc_conv_vol(mvc, chan, ucontrol->value.integer.value[0]);\n\n\tif (mvc->volume[chan] == old_volume) {\n\t\terr = 0;\n\t\tgoto end;\n\t}\n\n\tif (per_ch_enable) {\n\t\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_CTRL,\n\t\t\t\t   TEGRA210_MVC_PER_CHAN_CTRL_EN_MASK,\n\t\t\t\t   TEGRA210_MVC_PER_CHAN_CTRL_EN);\n\t} else {\n\t\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_CTRL,\n\t\t\t\t   TEGRA210_MVC_PER_CHAN_CTRL_EN_MASK, 0);\n\n\t\tfor (i = 1; i < TEGRA210_MVC_MAX_CHAN_COUNT; i++)\n\t\t\tmvc->volume[i] = mvc->volume[chan];\n\t}\n\n\t \n\tregmap_write(mvc->regmap,\n\t\tTEGRA210_MVC_REG_OFFSET(TEGRA210_MVC_INIT_VOL, chan),\n\t\tmvc->volume[chan]);\n\n\tregmap_write(mvc->regmap, mc->reg, mvc->volume[chan]);\n\n\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_SWITCH,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_MASK,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_TRIGGER);\n\n\terr = 1;\n\nend:\n\tpm_runtime_put(cmpnt->dev);\n\n\treturn err;\n}\n\nstatic int tegra210_mvc_put_vol(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\treturn tegra210_mvc_update_vol(kcontrol, ucontrol, true);\n}\n\nstatic int tegra210_mvc_put_master_vol(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\treturn tegra210_mvc_update_vol(kcontrol, ucontrol, false);\n}\n\nstatic void tegra210_mvc_reset_vol_settings(struct tegra210_mvc *mvc,\n\t\t\t\t\t    struct device *dev)\n{\n\tint i;\n\n\t \n\tif (mvc->curve_type == CURVE_POLY) {\n\t\tfor (i = 0; i < TEGRA210_MVC_MAX_CHAN_COUNT; i++)\n\t\t\tmvc->volume[i] = TEGRA210_MVC_INIT_VOL_DEFAULT_POLY;\n\t} else {\n\t\tfor (i = 0; i < TEGRA210_MVC_MAX_CHAN_COUNT; i++)\n\t\t\tmvc->volume[i] = TEGRA210_MVC_INIT_VOL_DEFAULT_LINEAR;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_CTRL,\n\t\t\t   TEGRA210_MVC_CURVE_TYPE_MASK,\n\t\t\t   mvc->curve_type <<\n\t\t\t   TEGRA210_MVC_CURVE_TYPE_SHIFT);\n\n\t \n\tfor (i = 0; i < TEGRA210_MVC_MAX_CHAN_COUNT; i++) {\n\t\tregmap_write(mvc->regmap,\n\t\t\tTEGRA210_MVC_REG_OFFSET(TEGRA210_MVC_INIT_VOL, i),\n\t\t\tmvc->volume[i]);\n\t\tregmap_write(mvc->regmap,\n\t\t\tTEGRA210_MVC_REG_OFFSET(TEGRA210_MVC_TARGET_VOL, i),\n\t\t\tmvc->volume[i]);\n\t}\n\n\t \n\tregmap_update_bits(mvc->regmap, TEGRA210_MVC_SWITCH,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_MASK,\n\t\t\t   TEGRA210_MVC_VOLUME_SWITCH_TRIGGER);\n\n\tpm_runtime_put(dev);\n}\n\nstatic int tegra210_mvc_get_curve_type(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\n\tucontrol->value.enumerated.item[0] = mvc->curve_type;\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_put_curve_type(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_mvc *mvc = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned int value;\n\n\tregmap_read(mvc->regmap, TEGRA210_MVC_ENABLE, &value);\n\tif (value & TEGRA210_MVC_EN) {\n\t\tdev_err(cmpnt->dev,\n\t\t\t\"Curve type can't be set when MVC is running\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mvc->curve_type == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tmvc->curve_type = ucontrol->value.enumerated.item[0];\n\n\ttegra210_mvc_reset_vol_settings(mvc, cmpnt->dev);\n\n\treturn 1;\n}\n\nstatic int tegra210_mvc_set_audio_cif(struct tegra210_mvc *mvc,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      unsigned int reg)\n{\n\tunsigned int channels, audio_bits;\n\tstruct tegra_cif_conf cif_conf;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tchannels = params_channels(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcif_conf.audio_ch = channels;\n\tcif_conf.client_ch = channels;\n\tcif_conf.audio_bits = audio_bits;\n\tcif_conf.client_bits = audio_bits;\n\n\ttegra_set_cif(mvc->regmap, reg, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra210_mvc_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->dev;\n\tstruct tegra210_mvc *mvc = snd_soc_dai_get_drvdata(dai);\n\tint err, val;\n\n\t \n\tregmap_write(mvc->regmap, TEGRA210_MVC_SOFT_RESET, 1);\n\n\terr = regmap_read_poll_timeout(mvc->regmap, TEGRA210_MVC_SOFT_RESET,\n\t\t\t\t       val, !val, 10, 10000);\n\tif (err < 0) {\n\t\tdev_err(dev, \"SW reset failed, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = tegra210_mvc_set_audio_cif(mvc, params, TEGRA210_MVC_RX_CIF_CTRL);\n\tif (err) {\n\t\tdev_err(dev, \"Can't set MVC RX CIF: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = tegra210_mvc_set_audio_cif(mvc, params, TEGRA210_MVC_TX_CIF_CTRL);\n\tif (err) {\n\t\tdev_err(dev, \"Can't set MVC TX CIF: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra210_mvc_write_ram(mvc->regmap);\n\n\t \n\tregmap_write(mvc->regmap, TEGRA210_MVC_POLY_N1, gain_params.poly_n1);\n\tregmap_write(mvc->regmap, TEGRA210_MVC_POLY_N2, gain_params.poly_n2);\n\tregmap_write(mvc->regmap, TEGRA210_MVC_DURATION, gain_params.duration);\n\n\t \n\tregmap_write(mvc->regmap, TEGRA210_MVC_DURATION_INV,\n\t\t     gain_params.duration_inv);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tegra210_mvc_dai_ops = {\n\t.hw_params\t= tegra210_mvc_hw_params,\n};\n\nstatic const char * const tegra210_mvc_curve_type_text[] = {\n\t\"Poly\",\n\t\"Linear\",\n};\n\nstatic const struct soc_enum tegra210_mvc_curve_type_ctrl =\n\tSOC_ENUM_SINGLE_EXT(2, tegra210_mvc_curve_type_text);\n\n#define TEGRA210_MVC_VOL_CTRL(chan)\t\t\t\t\t\\\n\tSOC_SINGLE_EXT(\"Channel\" #chan \" Volume\",\t\t\t\\\n\t\t       TEGRA210_MVC_REG_OFFSET(TEGRA210_MVC_TARGET_VOL, \\\n\t\t\t\t\t       (chan - 1)),\t\t\\\n\t\t       0, 16000, 0, tegra210_mvc_get_vol,\t\t\\\n\t\t       tegra210_mvc_put_vol)\n\nstatic const struct snd_kcontrol_new tegra210_mvc_vol_ctrl[] = {\n\t \n\tTEGRA210_MVC_VOL_CTRL(1),\n\tTEGRA210_MVC_VOL_CTRL(2),\n\tTEGRA210_MVC_VOL_CTRL(3),\n\tTEGRA210_MVC_VOL_CTRL(4),\n\tTEGRA210_MVC_VOL_CTRL(5),\n\tTEGRA210_MVC_VOL_CTRL(6),\n\tTEGRA210_MVC_VOL_CTRL(7),\n\tTEGRA210_MVC_VOL_CTRL(8),\n\n\t \n\tSOC_SINGLE_EXT(\"Per Chan Mute Mask\",\n\t\t       TEGRA210_MVC_CTRL, 0, TEGRA210_MUTE_MASK_EN, 0,\n\t\t       tegra210_mvc_get_mute, tegra210_mvc_put_mute),\n\n\t \n\tSOC_SINGLE_EXT(\"Volume\", TEGRA210_MVC_TARGET_VOL, 0, 16000, 0,\n\t\t       tegra210_mvc_get_master_vol,\n\t\t       tegra210_mvc_put_master_vol),\n\n\t \n\tSOC_SINGLE_EXT(\"Mute\", TEGRA210_MVC_CTRL, 0, 1, 0,\n\t\t       tegra210_mvc_get_master_mute,\n\t\t       tegra210_mvc_put_master_mute),\n\n\tSOC_ENUM_EXT(\"Curve Type\", tegra210_mvc_curve_type_ctrl,\n\t\t     tegra210_mvc_get_curve_type, tegra210_mvc_put_curve_type),\n};\n\nstatic struct snd_soc_dai_driver tegra210_mvc_dais[] = {\n\t \n\t{\n\t\t.name = \"MVC-RX-CIF\",\n\t\t.playback = {\n\t\t\t.stream_name = \"RX-CIF-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"RX-CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t},\n\n\t \n\t{\n\t\t.name = \"MVC-TX-CIF\",\n\t\t.playback = {\n\t\t\t.stream_name = \"TX-CIF-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"TX-CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &tegra210_mvc_dai_ops,\n\t}\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_mvc_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"RX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX\", NULL, 0, TEGRA210_MVC_ENABLE,\n\t\t\t     TEGRA210_MVC_EN_SHIFT, 0),\n};\n\n#define MVC_ROUTES(sname)\t\t\t\t\t\\\n\t{ \"RX XBAR-\" sname,\tNULL,\t\"XBAR-TX\" },\t\t\\\n\t{ \"RX-CIF-\" sname,\tNULL,\t\"RX XBAR-\" sname },\t\\\n\t{ \"RX\",\t\t\tNULL,\t\"RX-CIF-\" sname },\t\\\n\t{ \"TX-CIF-\" sname,\tNULL,\t\"TX\" },\t\t\t\\\n\t{ \"TX XBAR-\" sname,\tNULL,\t\"TX-CIF-\" sname },\t\\\n\t{ \"XBAR-RX\",            NULL,   \"TX XBAR-\" sname }\n\nstatic const struct snd_soc_dapm_route tegra210_mvc_routes[] = {\n\t{ \"TX\", NULL, \"RX\" },\n\tMVC_ROUTES(\"Playback\"),\n\tMVC_ROUTES(\"Capture\"),\n};\n\nstatic const struct snd_soc_component_driver tegra210_mvc_cmpnt = {\n\t.dapm_widgets\t\t= tegra210_mvc_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_mvc_widgets),\n\t.dapm_routes\t\t= tegra210_mvc_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_mvc_routes),\n\t.controls\t\t= tegra210_mvc_vol_ctrl,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_mvc_vol_ctrl),\n};\n\nstatic bool tegra210_mvc_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_MVC_RX_STATUS ... TEGRA210_MVC_CONFIG_ERR_TYPE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t};\n}\n\nstatic bool tegra210_mvc_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_MVC_RX_INT_MASK ... TEGRA210_MVC_RX_CIF_CTRL:\n\tcase TEGRA210_MVC_TX_INT_MASK ... TEGRA210_MVC_TX_CIF_CTRL:\n\tcase TEGRA210_MVC_ENABLE ... TEGRA210_MVC_CG:\n\tcase TEGRA210_MVC_CTRL ... TEGRA210_MVC_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_mvc_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_MVC_RX_STATUS:\n\tcase TEGRA210_MVC_RX_INT_STATUS:\n\tcase TEGRA210_MVC_RX_INT_SET:\n\n\tcase TEGRA210_MVC_TX_STATUS:\n\tcase TEGRA210_MVC_TX_INT_STATUS:\n\tcase TEGRA210_MVC_TX_INT_SET:\n\n\tcase TEGRA210_MVC_SOFT_RESET:\n\tcase TEGRA210_MVC_STATUS:\n\tcase TEGRA210_MVC_INT_STATUS:\n\tcase TEGRA210_MVC_SWITCH:\n\tcase TEGRA210_MVC_CFG_RAM_CTRL:\n\tcase TEGRA210_MVC_CFG_RAM_DATA:\n\tcase TEGRA210_MVC_PEAK_VALUE:\n\tcase TEGRA210_MVC_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tegra210_mvc_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_MVC_CONFIG_ERR_TYPE,\n\t.writeable_reg\t\t= tegra210_mvc_wr_reg,\n\t.readable_reg\t\t= tegra210_mvc_rd_reg,\n\t.volatile_reg\t\t= tegra210_mvc_volatile_reg,\n\t.reg_defaults\t\t= tegra210_mvc_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_mvc_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic const struct of_device_id tegra210_mvc_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-mvc\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_mvc_of_match);\n\nstatic int tegra210_mvc_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_mvc *mvc;\n\tvoid __iomem *regs;\n\tint err;\n\n\tmvc = devm_kzalloc(dev, sizeof(*mvc), GFP_KERNEL);\n\tif (!mvc)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, mvc);\n\n\tmvc->curve_type = CURVE_LINEAR;\n\tmvc->ctrl_value = TEGRA210_MVC_CTRL_DEFAULT;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tmvc->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t    &tegra210_mvc_regmap_config);\n\tif (IS_ERR(mvc->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(mvc->regmap);\n\t}\n\n\tregcache_cache_only(mvc->regmap, true);\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_mvc_cmpnt,\n\t\t\t\t\t      tegra210_mvc_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_mvc_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register MVC component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\ttegra210_mvc_reset_vol_settings(mvc, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_mvc_platform_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra210_mvc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_mvc_runtime_suspend,\n\t\t\t   tegra210_mvc_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra210_mvc_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-mvc\",\n\t\t.of_match_table = tegra210_mvc_of_match,\n\t\t.pm = &tegra210_mvc_pm_ops,\n\t},\n\t.probe = tegra210_mvc_platform_probe,\n\t.remove_new = tegra210_mvc_platform_remove,\n};\nmodule_platform_driver(tegra210_mvc_driver)\n\nMODULE_AUTHOR(\"Arun Shamanna Lakshmi <aruns@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 MVC ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}