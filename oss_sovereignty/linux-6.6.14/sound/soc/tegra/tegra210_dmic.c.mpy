{
  "module_name": "tegra210_dmic.c",
  "hash_id": "bc2b4884fe3f8f88278869ce150c01ada0d12b85b3ee138cd289023b8f097f06",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_dmic.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"tegra210_dmic.h\"\n#include \"tegra_cif.h\"\n\nstatic const struct reg_default tegra210_dmic_reg_defaults[] = {\n\t{ TEGRA210_DMIC_TX_INT_MASK, 0x00000001 },\n\t{ TEGRA210_DMIC_TX_CIF_CTRL, 0x00007700 },\n\t{ TEGRA210_DMIC_CG, 0x1 },\n\t{ TEGRA210_DMIC_CTRL, 0x00000301 },\n\t \n\t{ TEGRA210_DMIC_DBG_CTRL, 0xe },\n\t \n\t{ TEGRA210_DMIC_DCR_BIQUAD_0_COEF_4, 0x0 },\n\t \n\t{ TEGRA210_DMIC_LP_BIQUAD_0_COEF_0, 0x00800000 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_0_COEF_1, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_0_COEF_2, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_0_COEF_3, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_0_COEF_4, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_1_COEF_0, 0x00800000 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_1_COEF_1, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_1_COEF_2, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_1_COEF_3, 0x0 },\n\t{ TEGRA210_DMIC_LP_BIQUAD_1_COEF_4, 0x0 },\n};\n\nstatic int __maybe_unused tegra210_dmic_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_dmic *dmic = dev_get_drvdata(dev);\n\n\tregcache_cache_only(dmic->regmap, true);\n\tregcache_mark_dirty(dmic->regmap);\n\n\tclk_disable_unprepare(dmic->clk_dmic);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_dmic_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_dmic *dmic = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(dmic->clk_dmic);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable DMIC clock, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tregcache_cache_only(dmic->regmap, false);\n\tregcache_sync(dmic->regmap);\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct tegra210_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\tunsigned int srate, clk_rate, channels;\n\tstruct tegra_cif_conf cif_conf;\n\tunsigned long long gain_q23 = DEFAULT_GAIN_Q23;\n\tint err;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tchannels = params_channels(params);\n\n\tcif_conf.audio_ch = channels;\n\n\tswitch (dmic->ch_select) {\n\tcase DMIC_CH_SELECT_LEFT:\n\tcase DMIC_CH_SELECT_RIGHT:\n\t\tcif_conf.client_ch = 1;\n\t\tbreak;\n\tcase DMIC_CH_SELECT_STEREO:\n\t\tcif_conf.client_ch = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"invalid DMIC client channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsrate = params_rate(params);\n\n\t \n\tclk_rate = (DMIC_OSR_FACTOR << dmic->osr_val) * srate;\n\n\terr = clk_set_rate(dmic->clk_dmic, clk_rate);\n\tif (err) {\n\t\tdev_err(dai->dev, \"can't set DMIC clock rate %u, err: %d\\n\",\n\t\t\tclk_rate, err);\n\t\treturn err;\n\t}\n\n\tregmap_update_bits(dmic->regmap,\n\t\t\t    \n\t\t\t   TEGRA210_DMIC_CTRL,\n\t\t\t    \n\t\t\t   TEGRA210_DMIC_CTRL_LRSEL_POLARITY_MASK |\n\t\t\t   TEGRA210_DMIC_CTRL_OSR_MASK |\n\t\t\t   TEGRA210_DMIC_CTRL_CHANNEL_SELECT_MASK,\n\t\t\t    \n\t\t\t   (dmic->lrsel << LRSEL_POL_SHIFT) |\n\t\t\t   (dmic->osr_val << OSR_SHIFT) |\n\t\t\t   ((dmic->ch_select + 1) << CH_SEL_SHIFT));\n\n\t \n\tif (dmic->boost_gain)\n\t\tgain_q23 = div_u64(gain_q23 * dmic->boost_gain, 100);\n\n\tregmap_write(dmic->regmap, TEGRA210_DMIC_LP_FILTER_GAIN,\n\t\t     (unsigned int)gain_q23);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"unsupported format!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcif_conf.client_bits = TEGRA_ACIF_BITS_24;\n\tcif_conf.mono_conv = dmic->mono_to_stereo;\n\tcif_conf.stereo_conv = dmic->stereo_to_mono;\n\n\ttegra_set_cif(dmic->regmap, TEGRA210_DMIC_TX_CIF_CTRL, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_get_boost_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.integer.value[0] = dmic->boost_gain;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_boost_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (value == dmic->boost_gain)\n\t\treturn 0;\n\n\tdmic->boost_gain = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_dmic_get_ch_select(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = dmic->ch_select;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_ch_select(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == dmic->ch_select)\n\t\treturn 0;\n\n\tdmic->ch_select = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_dmic_get_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = dmic->mono_to_stereo;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == dmic->mono_to_stereo)\n\t\treturn 0;\n\n\tdmic->mono_to_stereo = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_dmic_get_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = dmic->stereo_to_mono;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == dmic->stereo_to_mono)\n\t\treturn 0;\n\n\tdmic->stereo_to_mono = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_dmic_get_osr_val(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = dmic->osr_val;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_osr_val(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == dmic->osr_val)\n\t\treturn 0;\n\n\tdmic->osr_val = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_dmic_get_pol_sel(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = dmic->lrsel;\n\n\treturn 0;\n}\n\nstatic int tegra210_dmic_put_pol_sel(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_dmic *dmic = snd_soc_component_get_drvdata(comp);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == dmic->lrsel)\n\t\treturn 0;\n\n\tdmic->lrsel = value;\n\n\treturn 1;\n}\n\nstatic const struct snd_soc_dai_ops tegra210_dmic_dai_ops = {\n\t.hw_params\t= tegra210_dmic_hw_params,\n};\n\nstatic struct snd_soc_dai_driver tegra210_dmic_dais[] = {\n\t{\n\t\t.name = \"DMIC-CIF\",\n\t\t.capture = {\n\t\t\t.stream_name = \"CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t},\n\t{\n\t\t.name = \"DMIC-DAP\",\n\t\t.capture = {\n\t\t\t.stream_name = \"DAP-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &tegra210_dmic_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_dmic_widgets[] = {\n\tSND_SOC_DAPM_AIF_OUT(\"TX\", NULL, 0, TEGRA210_DMIC_ENABLE, 0, 0),\n\tSND_SOC_DAPM_MIC(\"MIC\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route tegra210_dmic_routes[] = {\n\t{ \"XBAR-RX\",\t\tNULL,\t\"XBAR-Capture\" },\n\t{ \"XBAR-Capture\",\tNULL,\t\"CIF-Capture\" },\n\t{ \"CIF-Capture\",\tNULL,\t\"TX\" },\n\t{ \"TX\",\t\t\tNULL,\t\"DAP-Capture\" },\n\t{ \"DAP-Capture\",\tNULL,\t\"MIC\" },\n};\n\nstatic const char * const tegra210_dmic_ch_select[] = {\n\t\"Left\", \"Right\", \"Stereo\",\n};\n\nstatic const struct soc_enum tegra210_dmic_ch_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_dmic_ch_select),\n\t\t\ttegra210_dmic_ch_select);\n\nstatic const char * const tegra210_dmic_mono_conv_text[] = {\n\t\"Zero\", \"Copy\",\n};\n\nstatic const char * const tegra210_dmic_stereo_conv_text[] = {\n\t\"CH0\", \"CH1\", \"AVG\",\n};\n\nstatic const struct soc_enum tegra210_dmic_mono_conv_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_dmic_mono_conv_text),\n\t\t\ttegra210_dmic_mono_conv_text);\n\nstatic const struct soc_enum tegra210_dmic_stereo_conv_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_dmic_stereo_conv_text),\n\t\t\ttegra210_dmic_stereo_conv_text);\n\nstatic const char * const tegra210_dmic_osr_text[] = {\n\t\"OSR_64\", \"OSR_128\", \"OSR_256\",\n};\n\nstatic const struct soc_enum tegra210_dmic_osr_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_dmic_osr_text),\n\t\t\ttegra210_dmic_osr_text);\n\nstatic const char * const tegra210_dmic_lrsel_text[] = {\n\t\"Left\", \"Right\",\n};\n\nstatic const struct soc_enum tegra210_dmic_lrsel_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_dmic_lrsel_text),\n\t\t\ttegra210_dmic_lrsel_text);\n\nstatic const struct snd_kcontrol_new tegra210_dmic_controls[] = {\n\tSOC_SINGLE_EXT(\"Boost Gain Volume\", 0, 0, MAX_BOOST_GAIN, 0,\n\t\t       tegra210_dmic_get_boost_gain,\n\t\t       tegra210_dmic_put_boost_gain),\n\tSOC_ENUM_EXT(\"Channel Select\", tegra210_dmic_ch_enum,\n\t\t     tegra210_dmic_get_ch_select, tegra210_dmic_put_ch_select),\n\tSOC_ENUM_EXT(\"Mono To Stereo\",\n\t\t     tegra210_dmic_mono_conv_enum,\n\t\t     tegra210_dmic_get_mono_to_stereo,\n\t\t     tegra210_dmic_put_mono_to_stereo),\n\tSOC_ENUM_EXT(\"Stereo To Mono\",\n\t\t     tegra210_dmic_stereo_conv_enum,\n\t\t     tegra210_dmic_get_stereo_to_mono,\n\t\t     tegra210_dmic_put_stereo_to_mono),\n\tSOC_ENUM_EXT(\"OSR Value\", tegra210_dmic_osr_enum,\n\t\t     tegra210_dmic_get_osr_val, tegra210_dmic_put_osr_val),\n\tSOC_ENUM_EXT(\"LR Polarity Select\", tegra210_dmic_lrsel_enum,\n\t\t     tegra210_dmic_get_pol_sel, tegra210_dmic_put_pol_sel),\n};\n\nstatic const struct snd_soc_component_driver tegra210_dmic_compnt = {\n\t.dapm_widgets\t\t= tegra210_dmic_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_dmic_widgets),\n\t.dapm_routes\t\t= tegra210_dmic_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_dmic_routes),\n\t.controls\t\t= tegra210_dmic_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_dmic_controls),\n};\n\nstatic bool tegra210_dmic_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_DMIC_TX_INT_MASK ... TEGRA210_DMIC_TX_CIF_CTRL:\n\tcase TEGRA210_DMIC_ENABLE ... TEGRA210_DMIC_CG:\n\tcase TEGRA210_DMIC_CTRL:\n\tcase TEGRA210_DMIC_DBG_CTRL:\n\tcase TEGRA210_DMIC_DCR_BIQUAD_0_COEF_4 ... TEGRA210_DMIC_LP_BIQUAD_1_COEF_4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_dmic_rd_reg(struct device *dev, unsigned int reg)\n{\n\tif (tegra210_dmic_wr_reg(dev, reg))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase TEGRA210_DMIC_TX_STATUS:\n\tcase TEGRA210_DMIC_TX_INT_STATUS:\n\tcase TEGRA210_DMIC_STATUS:\n\tcase TEGRA210_DMIC_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_dmic_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_DMIC_TX_STATUS:\n\tcase TEGRA210_DMIC_TX_INT_STATUS:\n\tcase TEGRA210_DMIC_TX_INT_SET:\n\tcase TEGRA210_DMIC_SOFT_RESET:\n\tcase TEGRA210_DMIC_STATUS:\n\tcase TEGRA210_DMIC_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tegra210_dmic_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = TEGRA210_DMIC_LP_BIQUAD_1_COEF_4,\n\t.writeable_reg = tegra210_dmic_wr_reg,\n\t.readable_reg = tegra210_dmic_rd_reg,\n\t.volatile_reg = tegra210_dmic_volatile_reg,\n\t.reg_defaults = tegra210_dmic_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(tegra210_dmic_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int tegra210_dmic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_dmic *dmic;\n\tvoid __iomem *regs;\n\tint err;\n\n\tdmic = devm_kzalloc(dev, sizeof(*dmic), GFP_KERNEL);\n\tif (!dmic)\n\t\treturn -ENOMEM;\n\n\tdmic->osr_val = DMIC_OSR_64;\n\tdmic->ch_select = DMIC_CH_SELECT_STEREO;\n\tdmic->lrsel = DMIC_LRSEL_LEFT;\n\tdmic->boost_gain = 0;\n\tdmic->stereo_to_mono = 0;  \n\n\tdev_set_drvdata(dev, dmic);\n\n\tdmic->clk_dmic = devm_clk_get(dev, \"dmic\");\n\tif (IS_ERR(dmic->clk_dmic)) {\n\t\tdev_err(dev, \"can't retrieve DMIC clock\\n\");\n\t\treturn PTR_ERR(dmic->clk_dmic);\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tdmic->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t     &tegra210_dmic_regmap_config);\n\tif (IS_ERR(dmic->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(dmic->regmap);\n\t}\n\n\tregcache_cache_only(dmic->regmap, true);\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_dmic_compnt,\n\t\t\t\t\t      tegra210_dmic_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_dmic_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register DMIC component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_dmic_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra210_dmic_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_dmic_runtime_suspend,\n\t\t\t   tegra210_dmic_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct of_device_id tegra210_dmic_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-dmic\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_dmic_of_match);\n\nstatic struct platform_driver tegra210_dmic_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-dmic\",\n\t\t.of_match_table = tegra210_dmic_of_match,\n\t\t.pm = &tegra210_dmic_pm_ops,\n\t},\n\t.probe = tegra210_dmic_probe,\n\t.remove_new = tegra210_dmic_remove,\n};\nmodule_platform_driver(tegra210_dmic_driver)\n\nMODULE_AUTHOR(\"Rahul Mittal <rmittal@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 ASoC DMIC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}