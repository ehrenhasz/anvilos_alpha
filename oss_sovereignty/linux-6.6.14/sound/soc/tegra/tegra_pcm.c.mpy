{
  "module_name": "tegra_pcm.c",
  "hash_id": "0189101ca15125e612686b43c711517cd765a56850760d2f1aec74568bd4c58b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra_pcm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n#include \"tegra_pcm.h\"\n\nstatic const struct snd_pcm_hardware tegra_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED,\n\t.period_bytes_min\t= 1024,\n\t.period_bytes_max\t= PAGE_SIZE,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 8,\n\t.buffer_bytes_max\t= PAGE_SIZE * 8,\n\t.fifo_size\t\t= 4,\n};\n\nstatic const struct snd_dmaengine_pcm_config tegra_dmaengine_pcm_config = {\n\t.pcm_hardware = &tegra_pcm_hardware,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n\t.prealloc_buffer_size = PAGE_SIZE * 8,\n};\n\nint tegra_pcm_platform_register(struct device *dev)\n{\n\treturn snd_dmaengine_pcm_register(dev, &tegra_dmaengine_pcm_config, 0);\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_platform_register);\n\nint devm_tegra_pcm_platform_register(struct device *dev)\n{\n\treturn devm_snd_dmaengine_pcm_register(dev, &tegra_dmaengine_pcm_config, 0);\n}\nEXPORT_SYMBOL_GPL(devm_tegra_pcm_platform_register);\n\nint tegra_pcm_platform_register_with_chan_names(struct device *dev,\n\t\t\t\tstruct snd_dmaengine_pcm_config *config,\n\t\t\t\tchar *txdmachan, char *rxdmachan)\n{\n\t*config = tegra_dmaengine_pcm_config;\n\tconfig->dma_dev = dev->parent;\n\tconfig->chan_names[0] = txdmachan;\n\tconfig->chan_names[1] = rxdmachan;\n\n\treturn snd_dmaengine_pcm_register(dev, config, 0);\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_platform_register_with_chan_names);\n\nvoid tegra_pcm_platform_unregister(struct device *dev)\n{\n\treturn snd_dmaengine_pcm_unregister(dev);\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_platform_unregister);\n\nint tegra_pcm_open(struct snd_soc_component *component,\n\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_dmaengine_dai_dma_data *dmap;\n\tstruct dma_chan *chan;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tdmap = snd_soc_dai_get_dma_data(cpu_dai, substream);\n\n\t \n\tsnd_soc_set_runtime_hwparams(substream, &tegra_pcm_hardware);\n\n\t \n\tret = snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 0x8);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"failed to set constraint %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchan = dma_request_slave_channel(cpu_dai->dev, dmap->chan_name);\n\tif (!chan) {\n\t\tdev_err(cpu_dai->dev,\n\t\t\t\"dmaengine request slave channel failed! (%s)\\n\",\n\t\t\tdmap->chan_name);\n\t\treturn -ENODEV;\n\t}\n\n\tret = snd_dmaengine_pcm_open(substream, chan);\n\tif (ret) {\n\t\tdev_err(rtd->dev,\n\t\t\t\"dmaengine pcm open failed with err %d (%s)\\n\", ret,\n\t\t\tdmap->chan_name);\n\n\t\tdma_release_channel(chan);\n\n\t\treturn ret;\n\t}\n\n\t \n\tsubstream->wait_time = 500;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_open);\n\nint tegra_pcm_close(struct snd_soc_component *component,\n\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tsnd_dmaengine_pcm_close_release_chan(substream);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_close);\n\nint tegra_pcm_hw_params(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_dmaengine_dai_dma_data *dmap;\n\tstruct dma_slave_config slave_config;\n\tstruct dma_chan *chan;\n\tint ret;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tdmap = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tif (!dmap)\n\t\treturn 0;\n\n\tchan = snd_dmaengine_pcm_get_chan(substream);\n\n\tret = snd_hwparams_to_dma_slave_config(substream, params,\n\t\t\t\t\t       &slave_config);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"hw params config failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tslave_config.dst_addr = dmap->addr;\n\t\tslave_config.dst_maxburst = 8;\n\t} else {\n\t\tslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tslave_config.src_addr = dmap->addr;\n\t\tslave_config.src_maxburst = 8;\n\t}\n\n\tret = dmaengine_slave_config(chan, &slave_config);\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"dma slave config failed with err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_hw_params);\n\nsnd_pcm_uframes_t tegra_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\treturn snd_dmaengine_pcm_pointer(substream);\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_pointer);\n\nstatic int tegra_pcm_dma_allocate(struct device *dev, struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t  size_t size)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC, dev, size);\n}\n\nint tegra_pcm_construct(struct snd_soc_component *component,\n\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct device *dev = component->dev;\n\n\t \n\tif (!of_get_property(dev->of_node, \"iommus\", NULL))\n\t\tdev = rtd->card->snd_card->dev;\n\n\treturn tegra_pcm_dma_allocate(dev, rtd, tegra_pcm_hardware.buffer_bytes_max);\n}\nEXPORT_SYMBOL_GPL(tegra_pcm_construct);\n\nMODULE_AUTHOR(\"Stephen Warren <swarren@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra PCM ASoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}