{
  "module_name": "tegra30_ahub.c",
  "hash_id": "366bba392ef380b0bb8df1f0a6c17a7088938d550ec062b14cc0119061058872",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra30_ahub.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include \"tegra30_ahub.h\"\n\n#define DRV_NAME \"tegra30-ahub\"\n\nstatic struct tegra30_ahub *ahub;\n\nstatic inline void tegra30_apbif_write(u32 reg, u32 val)\n{\n\tregmap_write(ahub->regmap_apbif, reg, val);\n}\n\nstatic inline u32 tegra30_apbif_read(u32 reg)\n{\n\tu32 val;\n\n\tregmap_read(ahub->regmap_apbif, reg, &val);\n\treturn val;\n}\n\nstatic inline void tegra30_audio_write(u32 reg, u32 val)\n{\n\tregmap_write(ahub->regmap_ahub, reg, val);\n}\n\nstatic __maybe_unused int tegra30_ahub_runtime_suspend(struct device *dev)\n{\n\tregcache_cache_only(ahub->regmap_apbif, true);\n\tregcache_cache_only(ahub->regmap_ahub, true);\n\n\tclk_bulk_disable_unprepare(ahub->nclocks, ahub->clocks);\n\n\treturn 0;\n}\n\n \nstatic __maybe_unused int tegra30_ahub_runtime_resume(struct device *dev)\n{\n\tint ret;\n\n\tret = reset_control_bulk_assert(ahub->nresets, ahub->resets);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(ahub->nclocks, ahub->clocks);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10, 100);\n\n\tret = reset_control_bulk_deassert(ahub->nresets, ahub->resets);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\tregcache_cache_only(ahub->regmap_apbif, false);\n\tregcache_cache_only(ahub->regmap_ahub, false);\n\tregcache_mark_dirty(ahub->regmap_apbif);\n\tregcache_mark_dirty(ahub->regmap_ahub);\n\n\tret = regcache_sync(ahub->regmap_apbif);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\tret = regcache_sync(ahub->regmap_ahub);\n\tif (ret)\n\t\tgoto disable_clocks;\n\n\treturn 0;\n\ndisable_clocks:\n\tclk_bulk_disable_unprepare(ahub->nclocks, ahub->clocks);\n\n\treturn ret;\n}\n\nint tegra30_ahub_allocate_rx_fifo(enum tegra30_ahub_rxcif *rxcif,\n\t\t\t\t  char *dmachan, int dmachan_len,\n\t\t\t\t  dma_addr_t *fiforeg)\n{\n\tint channel;\n\tu32 reg, val;\n\tstruct tegra30_ahub_cif_conf cif_conf;\n\n\tchannel = find_first_zero_bit(ahub->rx_usage,\n\t\t\t\t      TEGRA30_AHUB_CHANNEL_CTRL_COUNT);\n\tif (channel >= TEGRA30_AHUB_CHANNEL_CTRL_COUNT)\n\t\treturn -EBUSY;\n\n\t__set_bit(channel, ahub->rx_usage);\n\n\t*rxcif = TEGRA30_AHUB_RXCIF_APBIF_RX0 + channel;\n\tsnprintf(dmachan, dmachan_len, \"rx%d\", channel);\n\t*fiforeg = ahub->apbif_addr + TEGRA30_AHUB_CHANNEL_RXFIFO +\n\t\t   (channel * TEGRA30_AHUB_CHANNEL_RXFIFO_STRIDE);\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval &= ~(TEGRA30_AHUB_CHANNEL_CTRL_RX_THRESHOLD_MASK |\n\t\t TEGRA30_AHUB_CHANNEL_CTRL_RX_PACK_MASK);\n\tval |= (7 << TEGRA30_AHUB_CHANNEL_CTRL_RX_THRESHOLD_SHIFT) |\n\t       TEGRA30_AHUB_CHANNEL_CTRL_RX_PACK_EN |\n\t       TEGRA30_AHUB_CHANNEL_CTRL_RX_PACK_16;\n\ttegra30_apbif_write(reg, val);\n\n\tcif_conf.threshold = 0;\n\tcif_conf.audio_channels = 2;\n\tcif_conf.client_channels = 2;\n\tcif_conf.audio_bits = TEGRA30_AUDIOCIF_BITS_16;\n\tcif_conf.client_bits = TEGRA30_AUDIOCIF_BITS_16;\n\tcif_conf.expand = 0;\n\tcif_conf.stereo_conv = 0;\n\tcif_conf.replicate = 0;\n\tcif_conf.direction = TEGRA30_AUDIOCIF_DIRECTION_RX;\n\tcif_conf.truncate = 0;\n\tcif_conf.mono_conv = 0;\n\n\treg = TEGRA30_AHUB_CIF_RX_CTRL +\n\t      (channel * TEGRA30_AHUB_CIF_RX_CTRL_STRIDE);\n\tahub->soc_data->set_audio_cif(ahub->regmap_apbif, reg, &cif_conf);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_allocate_rx_fifo);\n\nint tegra30_ahub_enable_rx_fifo(enum tegra30_ahub_rxcif rxcif)\n{\n\tint channel = rxcif - TEGRA30_AHUB_RXCIF_APBIF_RX0;\n\tint reg, val;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval |= TEGRA30_AHUB_CHANNEL_CTRL_RX_EN;\n\ttegra30_apbif_write(reg, val);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_enable_rx_fifo);\n\nint tegra30_ahub_disable_rx_fifo(enum tegra30_ahub_rxcif rxcif)\n{\n\tint channel = rxcif - TEGRA30_AHUB_RXCIF_APBIF_RX0;\n\tint reg, val;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval &= ~TEGRA30_AHUB_CHANNEL_CTRL_RX_EN;\n\ttegra30_apbif_write(reg, val);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_disable_rx_fifo);\n\nint tegra30_ahub_free_rx_fifo(enum tegra30_ahub_rxcif rxcif)\n{\n\tint channel = rxcif - TEGRA30_AHUB_RXCIF_APBIF_RX0;\n\n\t__clear_bit(channel, ahub->rx_usage);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_free_rx_fifo);\n\nint tegra30_ahub_allocate_tx_fifo(enum tegra30_ahub_txcif *txcif,\n\t\t\t\t  char *dmachan, int dmachan_len,\n\t\t\t\t  dma_addr_t *fiforeg)\n{\n\tint channel;\n\tu32 reg, val;\n\tstruct tegra30_ahub_cif_conf cif_conf;\n\n\tchannel = find_first_zero_bit(ahub->tx_usage,\n\t\t\t\t      TEGRA30_AHUB_CHANNEL_CTRL_COUNT);\n\tif (channel >= TEGRA30_AHUB_CHANNEL_CTRL_COUNT)\n\t\treturn -EBUSY;\n\n\t__set_bit(channel, ahub->tx_usage);\n\n\t*txcif = TEGRA30_AHUB_TXCIF_APBIF_TX0 + channel;\n\tsnprintf(dmachan, dmachan_len, \"tx%d\", channel);\n\t*fiforeg = ahub->apbif_addr + TEGRA30_AHUB_CHANNEL_TXFIFO +\n\t\t   (channel * TEGRA30_AHUB_CHANNEL_TXFIFO_STRIDE);\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval &= ~(TEGRA30_AHUB_CHANNEL_CTRL_TX_THRESHOLD_MASK |\n\t\t TEGRA30_AHUB_CHANNEL_CTRL_TX_PACK_MASK);\n\tval |= (7 << TEGRA30_AHUB_CHANNEL_CTRL_TX_THRESHOLD_SHIFT) |\n\t       TEGRA30_AHUB_CHANNEL_CTRL_TX_PACK_EN |\n\t       TEGRA30_AHUB_CHANNEL_CTRL_TX_PACK_16;\n\ttegra30_apbif_write(reg, val);\n\n\tcif_conf.threshold = 0;\n\tcif_conf.audio_channels = 2;\n\tcif_conf.client_channels = 2;\n\tcif_conf.audio_bits = TEGRA30_AUDIOCIF_BITS_16;\n\tcif_conf.client_bits = TEGRA30_AUDIOCIF_BITS_16;\n\tcif_conf.expand = 0;\n\tcif_conf.stereo_conv = 0;\n\tcif_conf.replicate = 0;\n\tcif_conf.direction = TEGRA30_AUDIOCIF_DIRECTION_TX;\n\tcif_conf.truncate = 0;\n\tcif_conf.mono_conv = 0;\n\n\treg = TEGRA30_AHUB_CIF_TX_CTRL +\n\t      (channel * TEGRA30_AHUB_CIF_TX_CTRL_STRIDE);\n\tahub->soc_data->set_audio_cif(ahub->regmap_apbif, reg, &cif_conf);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_allocate_tx_fifo);\n\nint tegra30_ahub_enable_tx_fifo(enum tegra30_ahub_txcif txcif)\n{\n\tint channel = txcif - TEGRA30_AHUB_TXCIF_APBIF_TX0;\n\tint reg, val;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval |= TEGRA30_AHUB_CHANNEL_CTRL_TX_EN;\n\ttegra30_apbif_write(reg, val);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_enable_tx_fifo);\n\nint tegra30_ahub_disable_tx_fifo(enum tegra30_ahub_txcif txcif)\n{\n\tint channel = txcif - TEGRA30_AHUB_TXCIF_APBIF_TX0;\n\tint reg, val;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_CHANNEL_CTRL +\n\t      (channel * TEGRA30_AHUB_CHANNEL_CTRL_STRIDE);\n\tval = tegra30_apbif_read(reg);\n\tval &= ~TEGRA30_AHUB_CHANNEL_CTRL_TX_EN;\n\ttegra30_apbif_write(reg, val);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_disable_tx_fifo);\n\nint tegra30_ahub_free_tx_fifo(enum tegra30_ahub_txcif txcif)\n{\n\tint channel = txcif - TEGRA30_AHUB_TXCIF_APBIF_TX0;\n\n\t__clear_bit(channel, ahub->tx_usage);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_free_tx_fifo);\n\nint tegra30_ahub_set_rx_cif_source(enum tegra30_ahub_rxcif rxcif,\n\t\t\t\t   enum tegra30_ahub_txcif txcif)\n{\n\tint channel = rxcif - TEGRA30_AHUB_RXCIF_APBIF_RX0;\n\tint reg;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_AUDIO_RX +\n\t      (channel * TEGRA30_AHUB_AUDIO_RX_STRIDE);\n\ttegra30_audio_write(reg, 1 << txcif);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_set_rx_cif_source);\n\nint tegra30_ahub_unset_rx_cif_source(enum tegra30_ahub_rxcif rxcif)\n{\n\tint channel = rxcif - TEGRA30_AHUB_RXCIF_APBIF_RX0;\n\tint reg;\n\n\tpm_runtime_get_sync(ahub->dev);\n\n\treg = TEGRA30_AHUB_AUDIO_RX +\n\t      (channel * TEGRA30_AHUB_AUDIO_RX_STRIDE);\n\ttegra30_audio_write(reg, 0);\n\n\tpm_runtime_put(ahub->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_unset_rx_cif_source);\n\nstatic const struct reset_control_bulk_data tegra30_ahub_resets_data[] = {\n\t{ \"d_audio\" },\n\t{ \"apbif\" },\n\t{ \"i2s0\" },\n\t{ \"i2s1\" },\n\t{ \"i2s2\" },\n\t{ \"i2s3\" },\n\t{ \"i2s4\" },\n\t{ \"dam0\" },\n\t{ \"dam1\" },\n\t{ \"dam2\" },\n\t{ \"spdif\" },\n\t{ \"amx\" },  \n\t{ \"adx\" },  \n\t{ \"amx1\" },  \n\t{ \"adx1\" },  \n\t{ \"afc0\" },  \n\t{ \"afc1\" },  \n\t{ \"afc2\" },  \n\t{ \"afc3\" },  \n\t{ \"afc4\" },  \n\t{ \"afc5\" },  \n};\n\n#define LAST_REG(name) \\\n\t(TEGRA30_AHUB_##name + \\\n\t (TEGRA30_AHUB_##name##_STRIDE * TEGRA30_AHUB_##name##_COUNT) - 4)\n\n#define REG_IN_ARRAY(reg, name) \\\n\t((reg >= TEGRA30_AHUB_##name) && \\\n\t (reg <= LAST_REG(name) && \\\n\t (!((reg - TEGRA30_AHUB_##name) % TEGRA30_AHUB_##name##_STRIDE))))\n\nstatic bool tegra30_ahub_apbif_wr_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA30_AHUB_CONFIG_LINK_CTRL:\n\tcase TEGRA30_AHUB_MISC_CTRL:\n\tcase TEGRA30_AHUB_APBDMA_LIVE_STATUS:\n\tcase TEGRA30_AHUB_I2S_LIVE_STATUS:\n\tcase TEGRA30_AHUB_SPDIF_LIVE_STATUS:\n\tcase TEGRA30_AHUB_I2S_INT_MASK:\n\tcase TEGRA30_AHUB_DAM_INT_MASK:\n\tcase TEGRA30_AHUB_SPDIF_INT_MASK:\n\tcase TEGRA30_AHUB_APBIF_INT_MASK:\n\tcase TEGRA30_AHUB_I2S_INT_STATUS:\n\tcase TEGRA30_AHUB_DAM_INT_STATUS:\n\tcase TEGRA30_AHUB_SPDIF_INT_STATUS:\n\tcase TEGRA30_AHUB_APBIF_INT_STATUS:\n\tcase TEGRA30_AHUB_I2S_INT_SOURCE:\n\tcase TEGRA30_AHUB_DAM_INT_SOURCE:\n\tcase TEGRA30_AHUB_SPDIF_INT_SOURCE:\n\tcase TEGRA30_AHUB_APBIF_INT_SOURCE:\n\tcase TEGRA30_AHUB_I2S_INT_SET:\n\tcase TEGRA30_AHUB_DAM_INT_SET:\n\tcase TEGRA30_AHUB_SPDIF_INT_SET:\n\tcase TEGRA30_AHUB_APBIF_INT_SET:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (REG_IN_ARRAY(reg, CHANNEL_CTRL) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_CLEAR) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_STATUS) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_TXFIFO) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_RXFIFO) ||\n\t    REG_IN_ARRAY(reg, CIF_TX_CTRL) ||\n\t    REG_IN_ARRAY(reg, CIF_RX_CTRL) ||\n\t    REG_IN_ARRAY(reg, DAM_LIVE_STATUS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool tegra30_ahub_apbif_volatile_reg(struct device *dev,\n\t\t\t\t\t    unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA30_AHUB_CONFIG_LINK_CTRL:\n\tcase TEGRA30_AHUB_MISC_CTRL:\n\tcase TEGRA30_AHUB_APBDMA_LIVE_STATUS:\n\tcase TEGRA30_AHUB_I2S_LIVE_STATUS:\n\tcase TEGRA30_AHUB_SPDIF_LIVE_STATUS:\n\tcase TEGRA30_AHUB_I2S_INT_STATUS:\n\tcase TEGRA30_AHUB_DAM_INT_STATUS:\n\tcase TEGRA30_AHUB_SPDIF_INT_STATUS:\n\tcase TEGRA30_AHUB_APBIF_INT_STATUS:\n\tcase TEGRA30_AHUB_I2S_INT_SET:\n\tcase TEGRA30_AHUB_DAM_INT_SET:\n\tcase TEGRA30_AHUB_SPDIF_INT_SET:\n\tcase TEGRA30_AHUB_APBIF_INT_SET:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (REG_IN_ARRAY(reg, CHANNEL_CLEAR) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_STATUS) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_TXFIFO) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_RXFIFO) ||\n\t    REG_IN_ARRAY(reg, DAM_LIVE_STATUS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool tegra30_ahub_apbif_precious_reg(struct device *dev,\n\t\t\t\t\t    unsigned int reg)\n{\n\tif (REG_IN_ARRAY(reg, CHANNEL_TXFIFO) ||\n\t    REG_IN_ARRAY(reg, CHANNEL_RXFIFO))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra30_ahub_apbif_regmap_config = {\n\t.name = \"apbif\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = TEGRA30_AHUB_APBIF_INT_SET,\n\t.writeable_reg = tegra30_ahub_apbif_wr_rd_reg,\n\t.readable_reg = tegra30_ahub_apbif_wr_rd_reg,\n\t.volatile_reg = tegra30_ahub_apbif_volatile_reg,\n\t.precious_reg = tegra30_ahub_apbif_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic bool tegra30_ahub_ahub_wr_rd_reg(struct device *dev, unsigned int reg)\n{\n\tif (REG_IN_ARRAY(reg, AUDIO_RX))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra30_ahub_ahub_regmap_config = {\n\t.name = \"ahub\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = LAST_REG(AUDIO_RX),\n\t.writeable_reg = tegra30_ahub_ahub_wr_rd_reg,\n\t.readable_reg = tegra30_ahub_ahub_wr_rd_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic struct tegra30_ahub_soc_data soc_data_tegra30 = {\n\t.num_resets = 11,\n\t.set_audio_cif = tegra30_ahub_set_cif,\n};\n\nstatic struct tegra30_ahub_soc_data soc_data_tegra114 = {\n\t.num_resets = 13,\n\t.set_audio_cif = tegra30_ahub_set_cif,\n};\n\nstatic struct tegra30_ahub_soc_data soc_data_tegra124 = {\n\t.num_resets = 21,\n\t.set_audio_cif = tegra124_ahub_set_cif,\n};\n\nstatic const struct of_device_id tegra30_ahub_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-ahub\", .data = &soc_data_tegra124 },\n\t{ .compatible = \"nvidia,tegra114-ahub\", .data = &soc_data_tegra114 },\n\t{ .compatible = \"nvidia,tegra30-ahub\",  .data = &soc_data_tegra30 },\n\t{},\n};\n\nstatic int tegra30_ahub_probe(struct platform_device *pdev)\n{\n\tconst struct tegra30_ahub_soc_data *soc_data;\n\tstruct resource *res0;\n\tvoid __iomem *regs_apbif, *regs_ahub;\n\tint ret = 0;\n\n\tsoc_data = of_device_get_match_data(&pdev->dev);\n\tif (!soc_data)\n\t\treturn -EINVAL;\n\n\tahub = devm_kzalloc(&pdev->dev, sizeof(struct tegra30_ahub),\n\t\t\t    GFP_KERNEL);\n\tif (!ahub)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(&pdev->dev, ahub);\n\n\tBUILD_BUG_ON(sizeof(ahub->resets) != sizeof(tegra30_ahub_resets_data));\n\tmemcpy(ahub->resets, tegra30_ahub_resets_data, sizeof(ahub->resets));\n\n\tahub->nresets = soc_data->num_resets;\n\tahub->soc_data = soc_data;\n\tahub->dev = &pdev->dev;\n\n\tahub->clocks[ahub->nclocks++].id = \"apbif\";\n\tahub->clocks[ahub->nclocks++].id = \"d_audio\";\n\n\tret = devm_clk_bulk_get(&pdev->dev, ahub->nclocks, ahub->clocks);\n\tif (ret)\n\t\tgoto err_unset_ahub;\n\n\tret = devm_reset_control_bulk_get_exclusive(&pdev->dev, ahub->nresets,\n\t\t\t\t\t\t    ahub->resets);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't get resets: %d\\n\", ret);\n\t\tgoto err_unset_ahub;\n\t}\n\n\tregs_apbif = devm_platform_get_and_ioremap_resource(pdev, 0, &res0);\n\tif (IS_ERR(regs_apbif)) {\n\t\tret = PTR_ERR(regs_apbif);\n\t\tgoto err_unset_ahub;\n\t}\n\n\tahub->apbif_addr = res0->start;\n\n\tahub->regmap_apbif = devm_regmap_init_mmio(&pdev->dev, regs_apbif,\n\t\t\t\t\t&tegra30_ahub_apbif_regmap_config);\n\tif (IS_ERR(ahub->regmap_apbif)) {\n\t\tdev_err(&pdev->dev, \"apbif regmap init failed\\n\");\n\t\tret = PTR_ERR(ahub->regmap_apbif);\n\t\tgoto err_unset_ahub;\n\t}\n\tregcache_cache_only(ahub->regmap_apbif, true);\n\n\tregs_ahub = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(regs_ahub)) {\n\t\tret = PTR_ERR(regs_ahub);\n\t\tgoto err_unset_ahub;\n\t}\n\n\tahub->regmap_ahub = devm_regmap_init_mmio(&pdev->dev, regs_ahub,\n\t\t\t\t\t&tegra30_ahub_ahub_regmap_config);\n\tif (IS_ERR(ahub->regmap_ahub)) {\n\t\tdev_err(&pdev->dev, \"ahub regmap init failed\\n\");\n\t\tret = PTR_ERR(ahub->regmap_ahub);\n\t\tgoto err_unset_ahub;\n\t}\n\tregcache_cache_only(ahub->regmap_ahub, true);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\tof_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\n\n\treturn 0;\n\nerr_unset_ahub:\n\tahub = NULL;\n\n\treturn ret;\n}\n\nstatic void tegra30_ahub_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\n\tahub = NULL;\n}\n\nstatic const struct dev_pm_ops tegra30_ahub_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra30_ahub_runtime_suspend,\n\t\t\t   tegra30_ahub_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra30_ahub_driver = {\n\t.probe = tegra30_ahub_probe,\n\t.remove_new = tegra30_ahub_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = tegra30_ahub_of_match,\n\t\t.pm = &tegra30_ahub_pm_ops,\n\t},\n};\nmodule_platform_driver(tegra30_ahub_driver);\n\nvoid tegra30_ahub_set_cif(struct regmap *regmap, unsigned int reg,\n\t\t\t  struct tegra30_ahub_cif_conf *conf)\n{\n\tunsigned int value;\n\n\tvalue = (conf->threshold <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_FIFO_THRESHOLD_SHIFT) |\n\t\t((conf->audio_channels - 1) <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_AUDIO_CHANNELS_SHIFT) |\n\t\t((conf->client_channels - 1) <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_CLIENT_CHANNELS_SHIFT) |\n\t\t(conf->audio_bits <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_AUDIO_BITS_SHIFT) |\n\t\t(conf->client_bits <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_CLIENT_BITS_SHIFT) |\n\t\t(conf->expand <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_EXPAND_SHIFT) |\n\t\t(conf->stereo_conv <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_STEREO_CONV_SHIFT) |\n\t\t(conf->replicate <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_REPLICATE_SHIFT) |\n\t\t(conf->direction <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_DIRECTION_SHIFT) |\n\t\t(conf->truncate <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_TRUNCATE_SHIFT) |\n\t\t(conf->mono_conv <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_MONO_CONV_SHIFT);\n\n\tregmap_write(regmap, reg, value);\n}\nEXPORT_SYMBOL_GPL(tegra30_ahub_set_cif);\n\nvoid tegra124_ahub_set_cif(struct regmap *regmap, unsigned int reg,\n\t\t\t   struct tegra30_ahub_cif_conf *conf)\n{\n\tunsigned int value;\n\n\tvalue = (conf->threshold <<\n\t\t\tTEGRA124_AUDIOCIF_CTRL_FIFO_THRESHOLD_SHIFT) |\n\t\t((conf->audio_channels - 1) <<\n\t\t\tTEGRA124_AUDIOCIF_CTRL_AUDIO_CHANNELS_SHIFT) |\n\t\t((conf->client_channels - 1) <<\n\t\t\tTEGRA124_AUDIOCIF_CTRL_CLIENT_CHANNELS_SHIFT) |\n\t\t(conf->audio_bits <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_AUDIO_BITS_SHIFT) |\n\t\t(conf->client_bits <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_CLIENT_BITS_SHIFT) |\n\t\t(conf->expand <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_EXPAND_SHIFT) |\n\t\t(conf->stereo_conv <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_STEREO_CONV_SHIFT) |\n\t\t(conf->replicate <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_REPLICATE_SHIFT) |\n\t\t(conf->direction <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_DIRECTION_SHIFT) |\n\t\t(conf->truncate <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_TRUNCATE_SHIFT) |\n\t\t(conf->mono_conv <<\n\t\t\tTEGRA30_AUDIOCIF_CTRL_MONO_CONV_SHIFT);\n\n\tregmap_write(regmap, reg, value);\n}\nEXPORT_SYMBOL_GPL(tegra124_ahub_set_cif);\n\nMODULE_AUTHOR(\"Stephen Warren <swarren@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra30 AHUB driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_DEVICE_TABLE(of, tegra30_ahub_of_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}