{
  "module_name": "tegra210_i2s.c",
  "hash_id": "f86cdb4c815c1f021261245f18efaaf293e5c7bb59c9fe34d3a5e166703dd530",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_i2s.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"tegra210_i2s.h\"\n#include \"tegra_cif.h\"\n\nstatic const struct reg_default tegra210_i2s_reg_defaults[] = {\n\t{ TEGRA210_I2S_RX_INT_MASK, 0x00000003 },\n\t{ TEGRA210_I2S_RX_CIF_CTRL, 0x00007700 },\n\t{ TEGRA210_I2S_TX_INT_MASK, 0x00000003 },\n\t{ TEGRA210_I2S_TX_CIF_CTRL, 0x00007700 },\n\t{ TEGRA210_I2S_CG, 0x1 },\n\t{ TEGRA210_I2S_TIMING, 0x0000001f },\n\t{ TEGRA210_I2S_ENABLE, 0x1 },\n\t \n\t{ TEGRA210_I2S_CYA, 0x1 },\n};\n\nstatic void tegra210_i2s_set_slot_ctrl(struct regmap *regmap,\n\t\t\t\t       unsigned int total_slots,\n\t\t\t\t       unsigned int tx_slot_mask,\n\t\t\t\t       unsigned int rx_slot_mask)\n{\n\tregmap_write(regmap, TEGRA210_I2S_SLOT_CTRL, total_slots - 1);\n\tregmap_write(regmap, TEGRA210_I2S_TX_SLOT_CTRL, tx_slot_mask);\n\tregmap_write(regmap, TEGRA210_I2S_RX_SLOT_CTRL, rx_slot_mask);\n}\n\nstatic int tegra210_i2s_set_clock_rate(struct device *dev,\n\t\t\t\t       unsigned int clock_rate)\n{\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint err;\n\n\tregmap_read(i2s->regmap, TEGRA210_I2S_CTRL, &val);\n\n\t \n\tif (!(val & I2S_CTRL_MASTER_EN))\n\t\treturn 0;\n\n\terr = clk_set_rate(i2s->clk_i2s, clock_rate);\n\tif (err) {\n\t\tdev_err(dev, \"can't set I2S bit clock rate %u, err: %d\\n\",\n\t\t\tclock_rate, err);\n\t\treturn err;\n\t}\n\n\tif (!IS_ERR(i2s->clk_sync_input)) {\n\t\t \n\t\terr = clk_set_rate(i2s->clk_sync_input, clock_rate);\n\t\tif (err) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"can't set I2S sync input rate %u, err = %d\\n\",\n\t\t\t\tclock_rate, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_sw_reset(struct snd_soc_component *compnt,\n\t\t\t\t bool is_playback)\n{\n\tstruct device *dev = compnt->dev;\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\tunsigned int reset_mask = I2S_SOFT_RESET_MASK;\n\tunsigned int reset_en = I2S_SOFT_RESET_EN;\n\tunsigned int reset_reg, cif_reg, stream_reg;\n\tunsigned int cif_ctrl, stream_ctrl, i2s_ctrl, val;\n\tint err;\n\n\tif (is_playback) {\n\t\treset_reg = TEGRA210_I2S_RX_SOFT_RESET;\n\t\tcif_reg = TEGRA210_I2S_RX_CIF_CTRL;\n\t\tstream_reg = TEGRA210_I2S_RX_CTRL;\n\t} else {\n\t\treset_reg = TEGRA210_I2S_TX_SOFT_RESET;\n\t\tcif_reg = TEGRA210_I2S_TX_CIF_CTRL;\n\t\tstream_reg = TEGRA210_I2S_TX_CTRL;\n\t}\n\n\t \n\tregmap_read(i2s->regmap, cif_reg, &cif_ctrl);\n\tregmap_read(i2s->regmap, stream_reg, &stream_ctrl);\n\tregmap_read(i2s->regmap, TEGRA210_I2S_CTRL, &i2s_ctrl);\n\n\t \n\tregmap_update_bits(i2s->regmap, reset_reg, reset_mask, reset_en);\n\n\terr = regmap_read_poll_timeout(i2s->regmap, reset_reg, val,\n\t\t\t\t       !(val & reset_mask & reset_en),\n\t\t\t\t       10, 10000);\n\tif (err) {\n\t\tdev_err(dev, \"timeout: failed to reset I2S for %s\\n\",\n\t\t\tis_playback ? \"playback\" : \"capture\");\n\t\treturn err;\n\t}\n\n\t \n\tregmap_write(i2s->regmap, cif_reg, cif_ctrl);\n\tregmap_write(i2s->regmap, stream_reg, stream_ctrl);\n\tregmap_write(i2s->regmap, TEGRA210_I2S_CTRL, i2s_ctrl);\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_init(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *compnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct device *dev = compnt->dev;\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\tunsigned int val, status_reg;\n\tbool is_playback;\n\tint err;\n\n\tswitch (w->reg) {\n\tcase TEGRA210_I2S_RX_ENABLE:\n\t\tis_playback = true;\n\t\tstatus_reg = TEGRA210_I2S_RX_STATUS;\n\t\tbreak;\n\tcase TEGRA210_I2S_TX_ENABLE:\n\t\tis_playback = false;\n\t\tstatus_reg = TEGRA210_I2S_TX_STATUS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = regmap_read_poll_timeout(i2s->regmap, status_reg, val,\n\t\t\t\t       !(val & I2S_EN_MASK & I2S_EN),\n\t\t\t\t       10, 10000);\n\tif (err) {\n\t\tdev_err(dev, \"timeout: previous I2S %s is still active\\n\",\n\t\t\tis_playback ? \"playback\" : \"capture\");\n\t\treturn err;\n\t}\n\n\treturn tegra210_i2s_sw_reset(compnt, is_playback);\n}\n\nstatic int __maybe_unused tegra210_i2s_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s->regmap, true);\n\tregcache_mark_dirty(i2s->regmap);\n\n\tclk_disable_unprepare(i2s->clk_i2s);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_i2s_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(i2s->clk_i2s);\n\tif (err) {\n\t\tdev_err(dev, \"failed to enable I2S bit clock, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tregcache_cache_only(i2s->regmap, false);\n\tregcache_sync(i2s->regmap);\n\n\treturn 0;\n}\n\nstatic void tegra210_i2s_set_data_offset(struct tegra210_i2s *i2s,\n\t\t\t\t\t unsigned int data_offset)\n{\n\t \n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_TX_CTRL,\n\t\t\t   I2S_CTRL_DATA_OFFSET_MASK,\n\t\t\t   data_offset << I2S_DATA_SHIFT);\n\n\t \n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_RX_CTRL,\n\t\t\t   I2S_CTRL_DATA_OFFSET_MASK,\n\t\t\t   data_offset << I2S_DATA_SHIFT);\n}\n\nstatic int tegra210_i2s_set_fmt(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int fmt)\n{\n\tstruct tegra210_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tunsigned int mask, val;\n\n\tmask = I2S_CTRL_MASTER_EN_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tval = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tval = I2S_CTRL_MASTER_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask |= I2S_CTRL_FRAME_FMT_MASK | I2S_CTRL_LRCK_POL_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tval |= I2S_CTRL_FRAME_FMT_FSYNC_MODE;\n\t\tval |= I2S_CTRL_LRCK_POL_HIGH;\n\t\ttegra210_i2s_set_data_offset(i2s, 1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tval |= I2S_CTRL_FRAME_FMT_FSYNC_MODE;\n\t\tval |= I2S_CTRL_LRCK_POL_HIGH;\n\t\ttegra210_i2s_set_data_offset(i2s, 0);\n\t\tbreak;\n\t \n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= I2S_CTRL_FRAME_FMT_LRCK_MODE;\n\t\tval |= I2S_CTRL_LRCK_POL_LOW;\n\t\ttegra210_i2s_set_data_offset(i2s, 1);\n\t\tbreak;\n\t \n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval |= I2S_CTRL_FRAME_FMT_LRCK_MODE;\n\t\tval |= I2S_CTRL_LRCK_POL_HIGH;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval |= I2S_CTRL_FRAME_FMT_LRCK_MODE;\n\t\tval |= I2S_CTRL_LRCK_POL_HIGH;\n\t\ttegra210_i2s_set_data_offset(i2s, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask |= I2S_CTRL_EDGE_CTRL_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval |= I2S_CTRL_EDGE_CTRL_POS_EDGE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval |= I2S_CTRL_EDGE_CTRL_POS_EDGE;\n\t\tval ^= I2S_CTRL_LRCK_POL_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval |= I2S_CTRL_EDGE_CTRL_NEG_EDGE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval |= I2S_CTRL_EDGE_CTRL_NEG_EDGE;\n\t\tval ^= I2S_CTRL_LRCK_POL_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_CTRL, mask, val);\n\n\ti2s->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t     unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t     int slots, int slot_width)\n{\n\tstruct tegra210_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\t \n\ti2s->tx_mask = (tx_mask > DEFAULT_I2S_SLOT_MASK) ?\n\t\t       DEFAULT_I2S_SLOT_MASK : tx_mask;\n\ti2s->rx_mask = (rx_mask > DEFAULT_I2S_SLOT_MASK) ?\n\t\t       DEFAULT_I2S_SLOT_MASK : rx_mask;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_get_loopback(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.integer.value[0] = i2s->loopback;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_put_loopback(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (value == i2s->loopback)\n\t\treturn 0;\n\n\ti2s->loopback = value;\n\n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_CTRL, I2S_CTRL_LPBK_MASK,\n\t\t\t   i2s->loopback << I2S_CTRL_LPBK_SHIFT);\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_get_fsync_width(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.integer.value[0] = i2s->fsync_width;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_put_fsync_width(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (value == i2s->fsync_width)\n\t\treturn 0;\n\n\ti2s->fsync_width = value;\n\n\t \n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_CTRL,\n\t\t\t   I2S_CTRL_FSYNC_WIDTH_MASK,\n\t\t\t   i2s->fsync_width << I2S_FSYNC_WIDTH_SHIFT);\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_cget_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.enumerated.item[0] = i2s->stereo_to_mono[I2S_TX_PATH];\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_cput_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == i2s->stereo_to_mono[I2S_TX_PATH])\n\t\treturn 0;\n\n\ti2s->stereo_to_mono[I2S_TX_PATH] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_cget_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.enumerated.item[0] = i2s->mono_to_stereo[I2S_TX_PATH];\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_cput_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == i2s->mono_to_stereo[I2S_TX_PATH])\n\t\treturn 0;\n\n\ti2s->mono_to_stereo[I2S_TX_PATH] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_pget_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.enumerated.item[0] = i2s->stereo_to_mono[I2S_RX_PATH];\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_pput_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == i2s->stereo_to_mono[I2S_RX_PATH])\n\t\treturn 0;\n\n\ti2s->stereo_to_mono[I2S_RX_PATH] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_pget_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.enumerated.item[0] = i2s->mono_to_stereo[I2S_RX_PATH];\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_pput_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == i2s->mono_to_stereo[I2S_RX_PATH])\n\t\treturn 0;\n\n\ti2s->mono_to_stereo[I2S_RX_PATH] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_pget_fifo_th(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.integer.value[0] = i2s->rx_fifo_th;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_pput_fifo_th(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (value == i2s->rx_fifo_th)\n\t\treturn 0;\n\n\ti2s->rx_fifo_th = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_get_bclk_ratio(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\n\tucontrol->value.integer.value[0] = i2s->bclk_ratio;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_put_bclk_ratio(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *compnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_i2s *i2s = snd_soc_component_get_drvdata(compnt);\n\tint value = ucontrol->value.integer.value[0];\n\n\tif (value == i2s->bclk_ratio)\n\t\treturn 0;\n\n\ti2s->bclk_ratio = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_i2s_set_dai_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t\t   unsigned int ratio)\n{\n\tstruct tegra210_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\ti2s->bclk_ratio = ratio;\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_set_timing_params(struct device *dev,\n\t\t\t\t\t  unsigned int sample_size,\n\t\t\t\t\t  unsigned int srate,\n\t\t\t\t\t  unsigned int channels)\n{\n\tstruct tegra210_i2s *i2s = dev_get_drvdata(dev);\n\tunsigned int val, bit_count, bclk_rate, num_bclk = sample_size;\n\tint err;\n\n\tif (i2s->bclk_ratio)\n\t\tnum_bclk *= i2s->bclk_ratio;\n\n\tif (i2s->dai_fmt == SND_SOC_DAIFMT_RIGHT_J)\n\t\ttegra210_i2s_set_data_offset(i2s, num_bclk - sample_size);\n\n\t \n\tbclk_rate = srate * channels * num_bclk;\n\n\terr = tegra210_i2s_set_clock_rate(dev, bclk_rate);\n\tif (err) {\n\t\tdev_err(dev, \"can't set I2S bit clock rate %u, err: %d\\n\",\n\t\t\tbclk_rate, err);\n\t\treturn err;\n\t}\n\n\tregmap_read(i2s->regmap, TEGRA210_I2S_CTRL, &val);\n\n\t \n\tswitch (val & I2S_CTRL_FRAME_FMT_MASK) {\n\tcase I2S_CTRL_FRAME_FMT_LRCK_MODE:\n\t\tbit_count = (bclk_rate / (srate * 2)) - 1;\n\t\tbreak;\n\tcase I2S_CTRL_FRAME_FMT_FSYNC_MODE:\n\t\tbit_count = (bclk_rate / srate) - 1;\n\n\t\ttegra210_i2s_set_slot_ctrl(i2s->regmap, channels,\n\t\t\t\t\t   i2s->tx_mask, i2s->rx_mask);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid I2S frame format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (bit_count > I2S_TIMING_CH_BIT_CNT_MASK) {\n\t\tdev_err(dev, \"invalid I2S channel bit count %u\\n\", bit_count);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(i2s->regmap, TEGRA210_I2S_TIMING,\n\t\t     bit_count << I2S_TIMING_CH_BIT_CNT_SHIFT);\n\n\treturn 0;\n}\n\nstatic int tegra210_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->dev;\n\tstruct tegra210_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tunsigned int sample_size, channels, srate, val, reg, path;\n\tstruct tegra_cif_conf cif_conf;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tchannels = params_channels(params);\n\tif (channels < 1) {\n\t\tdev_err(dev, \"invalid I2S %d channel configuration\\n\",\n\t\t\tchannels);\n\t\treturn -EINVAL;\n\t}\n\n\tcif_conf.audio_ch = channels;\n\tcif_conf.client_ch = channels;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tval = I2S_BITS_8;\n\t\tsample_size = 8;\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_8;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tval = I2S_BITS_16;\n\t\tsample_size = 16;\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_16;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval = I2S_BITS_32;\n\t\tsample_size = 32;\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_32;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported format!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tregmap_update_bits(i2s->regmap, TEGRA210_I2S_CTRL,\n\t\t\t   I2S_CTRL_BIT_SIZE_MASK, val);\n\n\tsrate = params_rate(params);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tpath = I2S_RX_PATH;\n\telse\n\t\tpath = I2S_TX_PATH;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tunsigned int max_th;\n\n\t\t \n\t\tmax_th = (I2S_RX_FIFO_DEPTH / cif_conf.audio_ch) - 1;\n\n\t\tif (i2s->rx_fifo_th > max_th)\n\t\t\ti2s->rx_fifo_th = max_th;\n\n\t\tcif_conf.threshold = i2s->rx_fifo_th;\n\n\t\treg = TEGRA210_I2S_RX_CIF_CTRL;\n\t} else {\n\t\treg = TEGRA210_I2S_TX_CIF_CTRL;\n\t}\n\n\tcif_conf.mono_conv = i2s->mono_to_stereo[path];\n\tcif_conf.stereo_conv = i2s->stereo_to_mono[path];\n\n\ttegra_set_cif(i2s->regmap, reg, &cif_conf);\n\n\treturn tegra210_i2s_set_timing_params(dev, sample_size, srate,\n\t\t\t\t\t      cif_conf.client_ch);\n}\n\nstatic const struct snd_soc_dai_ops tegra210_i2s_dai_ops = {\n\t.set_fmt\t= tegra210_i2s_set_fmt,\n\t.hw_params\t= tegra210_i2s_hw_params,\n\t.set_bclk_ratio\t= tegra210_i2s_set_dai_bclk_ratio,\n\t.set_tdm_slot\t= tegra210_i2s_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver tegra210_i2s_dais[] = {\n\t{\n\t\t.name = \"I2S-CIF\",\n\t\t.playback = {\n\t\t\t.stream_name = \"CIF-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t},\n\t{\n\t\t.name = \"I2S-DAP\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DAP-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAP-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &tegra210_i2s_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic const char * const tegra210_i2s_stereo_conv_text[] = {\n\t\"CH0\", \"CH1\", \"AVG\",\n};\n\nstatic const char * const tegra210_i2s_mono_conv_text[] = {\n\t\"Zero\", \"Copy\",\n};\n\nstatic const struct soc_enum tegra210_i2s_mono_conv_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_i2s_mono_conv_text),\n\t\t\ttegra210_i2s_mono_conv_text);\n\nstatic const struct soc_enum tegra210_i2s_stereo_conv_enum =\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(tegra210_i2s_stereo_conv_text),\n\t\t\ttegra210_i2s_stereo_conv_text);\n\nstatic const struct snd_kcontrol_new tegra210_i2s_controls[] = {\n\tSOC_SINGLE_EXT(\"Loopback\", 0, 0, 1, 0, tegra210_i2s_get_loopback,\n\t\t       tegra210_i2s_put_loopback),\n\tSOC_SINGLE_EXT(\"FSYNC Width\", 0, 0, 255, 0,\n\t\t       tegra210_i2s_get_fsync_width,\n\t\t       tegra210_i2s_put_fsync_width),\n\tSOC_ENUM_EXT(\"Capture Stereo To Mono\", tegra210_i2s_stereo_conv_enum,\n\t\t     tegra210_i2s_cget_stereo_to_mono,\n\t\t     tegra210_i2s_cput_stereo_to_mono),\n\tSOC_ENUM_EXT(\"Capture Mono To Stereo\", tegra210_i2s_mono_conv_enum,\n\t\t     tegra210_i2s_cget_mono_to_stereo,\n\t\t     tegra210_i2s_cput_mono_to_stereo),\n\tSOC_ENUM_EXT(\"Playback Stereo To Mono\", tegra210_i2s_stereo_conv_enum,\n\t\t     tegra210_i2s_pget_mono_to_stereo,\n\t\t     tegra210_i2s_pput_mono_to_stereo),\n\tSOC_ENUM_EXT(\"Playback Mono To Stereo\", tegra210_i2s_mono_conv_enum,\n\t\t     tegra210_i2s_pget_stereo_to_mono,\n\t\t     tegra210_i2s_pput_stereo_to_mono),\n\tSOC_SINGLE_EXT(\"Playback FIFO Threshold\", 0, 0, I2S_RX_FIFO_DEPTH - 1,\n\t\t       0, tegra210_i2s_pget_fifo_th, tegra210_i2s_pput_fifo_th),\n\tSOC_SINGLE_EXT(\"BCLK Ratio\", 0, 0, INT_MAX, 0,\n\t\t       tegra210_i2s_get_bclk_ratio,\n\t\t       tegra210_i2s_put_bclk_ratio),\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_i2s_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN_E(\"RX\", NULL, 0, TEGRA210_I2S_RX_ENABLE,\n\t\t\t      0, 0, tegra210_i2s_init, SND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_AIF_OUT_E(\"TX\", NULL, 0, TEGRA210_I2S_TX_ENABLE,\n\t\t\t       0, 0, tegra210_i2s_init, SND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_MIC(\"MIC\", NULL),\n\tSND_SOC_DAPM_SPK(\"SPK\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route tegra210_i2s_routes[] = {\n\t \n\t{ \"XBAR-Playback\",\tNULL,\t\"XBAR-TX\" },\n\t{ \"CIF-Playback\",\tNULL,\t\"XBAR-Playback\" },\n\t{ \"RX\",\t\t\tNULL,\t\"CIF-Playback\" },\n\t{ \"DAP-Playback\",\tNULL,\t\"RX\" },\n\t{ \"SPK\",\t\tNULL,\t\"DAP-Playback\" },\n\t \n\t{ \"XBAR-RX\",\t\tNULL,\t\"XBAR-Capture\" },\n\t{ \"XBAR-Capture\",\tNULL,\t\"CIF-Capture\" },\n\t{ \"CIF-Capture\",\tNULL,\t\"TX\" },\n\t{ \"TX\",\t\t\tNULL,\t\"DAP-Capture\" },\n\t{ \"DAP-Capture\",\tNULL,\t\"MIC\" },\n};\n\nstatic const struct snd_soc_component_driver tegra210_i2s_cmpnt = {\n\t.dapm_widgets\t\t= tegra210_i2s_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_i2s_widgets),\n\t.dapm_routes\t\t= tegra210_i2s_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_i2s_routes),\n\t.controls\t\t= tegra210_i2s_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_i2s_controls),\n};\n\nstatic bool tegra210_i2s_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_I2S_RX_ENABLE ... TEGRA210_I2S_RX_SOFT_RESET:\n\tcase TEGRA210_I2S_RX_INT_MASK ... TEGRA210_I2S_RX_CLK_TRIM:\n\tcase TEGRA210_I2S_TX_ENABLE ... TEGRA210_I2S_TX_SOFT_RESET:\n\tcase TEGRA210_I2S_TX_INT_MASK ... TEGRA210_I2S_TX_CLK_TRIM:\n\tcase TEGRA210_I2S_ENABLE ... TEGRA210_I2S_CG:\n\tcase TEGRA210_I2S_CTRL ... TEGRA210_I2S_CYA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_i2s_rd_reg(struct device *dev, unsigned int reg)\n{\n\tif (tegra210_i2s_wr_reg(dev, reg))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase TEGRA210_I2S_RX_STATUS:\n\tcase TEGRA210_I2S_RX_INT_STATUS:\n\tcase TEGRA210_I2S_RX_CIF_FIFO_STATUS:\n\tcase TEGRA210_I2S_TX_STATUS:\n\tcase TEGRA210_I2S_TX_INT_STATUS:\n\tcase TEGRA210_I2S_TX_CIF_FIFO_STATUS:\n\tcase TEGRA210_I2S_STATUS:\n\tcase TEGRA210_I2S_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_I2S_RX_STATUS:\n\tcase TEGRA210_I2S_RX_INT_STATUS:\n\tcase TEGRA210_I2S_RX_CIF_FIFO_STATUS:\n\tcase TEGRA210_I2S_TX_STATUS:\n\tcase TEGRA210_I2S_TX_INT_STATUS:\n\tcase TEGRA210_I2S_TX_CIF_FIFO_STATUS:\n\tcase TEGRA210_I2S_STATUS:\n\tcase TEGRA210_I2S_INT_STATUS:\n\tcase TEGRA210_I2S_RX_SOFT_RESET:\n\tcase TEGRA210_I2S_TX_SOFT_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tegra210_i2s_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_I2S_CYA,\n\t.writeable_reg\t\t= tegra210_i2s_wr_reg,\n\t.readable_reg\t\t= tegra210_i2s_rd_reg,\n\t.volatile_reg\t\t= tegra210_i2s_volatile_reg,\n\t.reg_defaults\t\t= tegra210_i2s_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_i2s_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic int tegra210_i2s_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_i2s *i2s;\n\tvoid __iomem *regs;\n\tint err;\n\n\ti2s = devm_kzalloc(dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\n\ti2s->rx_fifo_th = DEFAULT_I2S_RX_FIFO_THRESHOLD;\n\ti2s->tx_mask = DEFAULT_I2S_SLOT_MASK;\n\ti2s->rx_mask = DEFAULT_I2S_SLOT_MASK;\n\ti2s->loopback = false;\n\n\tdev_set_drvdata(dev, i2s);\n\n\ti2s->clk_i2s = devm_clk_get(dev, \"i2s\");\n\tif (IS_ERR(i2s->clk_i2s)) {\n\t\tdev_err(dev, \"can't retrieve I2S bit clock\\n\");\n\t\treturn PTR_ERR(i2s->clk_i2s);\n\t}\n\n\t \n\ti2s->clk_sync_input = devm_clk_get(dev, \"sync_input\");\n\tif (IS_ERR(i2s->clk_sync_input))\n\t\tdev_dbg(dev, \"can't retrieve I2S sync input clock\\n\");\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\ti2s->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t    &tegra210_i2s_regmap_config);\n\tif (IS_ERR(i2s->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(i2s->regmap);\n\t}\n\n\tregcache_cache_only(i2s->regmap, true);\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_i2s_cmpnt,\n\t\t\t\t\t      tegra210_i2s_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_i2s_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register I2S component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_i2s_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra210_i2s_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_i2s_runtime_suspend,\n\t\t\t   tegra210_i2s_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct of_device_id tegra210_i2s_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-i2s\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_i2s_of_match);\n\nstatic struct platform_driver tegra210_i2s_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-i2s\",\n\t\t.of_match_table = tegra210_i2s_of_match,\n\t\t.pm = &tegra210_i2s_pm_ops,\n\t},\n\t.probe = tegra210_i2s_probe,\n\t.remove_new = tegra210_i2s_remove,\n};\nmodule_platform_driver(tegra210_i2s_driver)\n\nMODULE_AUTHOR(\"Songhee Baek <sbaek@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 ASoC I2S driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}