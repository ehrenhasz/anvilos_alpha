{
  "module_name": "tegra210_amx.c",
  "hash_id": "c74e65e270b2ab42ffb1d5c536409fe0ef99465de4b32d30bfe26087bc628bcc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_amx.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"tegra210_amx.h\"\n#include \"tegra_cif.h\"\n\n \n#define TEGRA194_MAX_FRAME_IDLE_COUNT\t0x1800\n\n#define AMX_CH_REG(id, reg) ((reg) + ((id) * TEGRA210_AMX_AUDIOCIF_CH_STRIDE))\n\nstatic const struct reg_default tegra210_amx_reg_defaults[] = {\n\t{ TEGRA210_AMX_RX_INT_MASK, 0x0000000f},\n\t{ TEGRA210_AMX_RX1_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_AMX_RX2_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_AMX_RX3_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_AMX_RX4_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_AMX_TX_INT_MASK, 0x00000001},\n\t{ TEGRA210_AMX_TX_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_AMX_CG, 0x1},\n\t{ TEGRA210_AMX_CFG_RAM_CTRL, 0x00004000},\n};\n\nstatic void tegra210_amx_write_map_ram(struct tegra210_amx *amx)\n{\n\tint i;\n\n\tregmap_write(amx->regmap, TEGRA210_AMX_CFG_RAM_CTRL,\n\t\t     TEGRA210_AMX_CFG_RAM_CTRL_SEQ_ACCESS_EN |\n\t\t     TEGRA210_AMX_CFG_RAM_CTRL_ADDR_INIT_EN |\n\t\t     TEGRA210_AMX_CFG_RAM_CTRL_RW_WRITE);\n\n\tfor (i = 0; i < TEGRA210_AMX_RAM_DEPTH; i++)\n\t\tregmap_write(amx->regmap, TEGRA210_AMX_CFG_RAM_DATA,\n\t\t\t     amx->map[i]);\n\n\tregmap_write(amx->regmap, TEGRA210_AMX_OUT_BYTE_EN0, amx->byte_mask[0]);\n\tregmap_write(amx->regmap, TEGRA210_AMX_OUT_BYTE_EN1, amx->byte_mask[1]);\n}\n\nstatic int tegra210_amx_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct tegra210_amx *amx = snd_soc_dai_get_drvdata(dai);\n\tunsigned int val;\n\tint err;\n\n\t \n\terr = regmap_read_poll_timeout(amx->regmap, TEGRA210_AMX_STATUS, val,\n\t\t\t\t       !(val & 0x1), 10, 10000);\n\tif (err < 0) {\n\t\tdev_err(dai->dev, \"failed to stop AMX, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tregmap_update_bits(amx->regmap, TEGRA210_AMX_SOFT_RESET,\n\t\t\t   TEGRA210_AMX_SOFT_RESET_SOFT_RESET_MASK,\n\t\t\t   TEGRA210_AMX_SOFT_RESET_SOFT_EN);\n\n\terr = regmap_read_poll_timeout(amx->regmap, TEGRA210_AMX_SOFT_RESET,\n\t\t\t\t       val, !(val & 0x1), 10, 10000);\n\tif (err < 0) {\n\t\tdev_err(dai->dev, \"failed to reset AMX, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_amx_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_amx *amx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(amx->regmap, true);\n\tregcache_mark_dirty(amx->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_amx_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_amx *amx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(amx->regmap, false);\n\tregcache_sync(amx->regmap);\n\n\tregmap_update_bits(amx->regmap,\n\t\tTEGRA210_AMX_CTRL,\n\t\tTEGRA210_AMX_CTRL_RX_DEP_MASK,\n\t\tTEGRA210_AMX_WAIT_ON_ANY << TEGRA210_AMX_CTRL_RX_DEP_SHIFT);\n\n\ttegra210_amx_write_map_ram(amx);\n\n\treturn 0;\n}\n\nstatic int tegra210_amx_set_audio_cif(struct snd_soc_dai *dai,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      unsigned int reg)\n{\n\tstruct tegra210_amx *amx = snd_soc_dai_get_drvdata(dai);\n\tint channels, audio_bits;\n\tstruct tegra_cif_conf cif_conf;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tchannels = params_channels(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\taudio_bits = TEGRA_ACIF_BITS_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcif_conf.audio_ch = channels;\n\tcif_conf.client_ch = channels;\n\tcif_conf.audio_bits = audio_bits;\n\tcif_conf.client_bits = audio_bits;\n\n\ttegra_set_cif(amx->regmap, reg, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra210_amx_in_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct tegra210_amx *amx = snd_soc_dai_get_drvdata(dai);\n\n\tif (amx->soc_data->auto_disable) {\n\t\tregmap_write(amx->regmap,\n\t\t\t     AMX_CH_REG(dai->id, TEGRA194_AMX_RX1_FRAME_PERIOD),\n\t\t\t     TEGRA194_MAX_FRAME_IDLE_COUNT);\n\t\tregmap_write(amx->regmap, TEGRA210_AMX_CYA, 1);\n\t}\n\n\treturn tegra210_amx_set_audio_cif(dai, params,\n\t\t\tAMX_CH_REG(dai->id, TEGRA210_AMX_RX1_CIF_CTRL));\n}\n\nstatic int tegra210_amx_out_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\treturn tegra210_amx_set_audio_cif(dai, params,\n\t\t\t\t\t  TEGRA210_AMX_TX_CIF_CTRL);\n}\n\nstatic int tegra210_amx_get_byte_map(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct tegra210_amx *amx = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned char *bytes_map = (unsigned char *)&amx->map;\n\tint reg = mc->reg;\n\tint enabled;\n\n\tif (reg > 31)\n\t\tenabled = amx->byte_mask[1] & (1 << (reg - 32));\n\telse\n\t\tenabled = amx->byte_mask[0] & (1 << reg);\n\n\t \n\tif (enabled)\n\t\tucontrol->value.integer.value[0] = bytes_map[reg];\n\telse\n\t\tucontrol->value.integer.value[0] = 256;\n\n\treturn 0;\n}\n\nstatic int tegra210_amx_put_byte_map(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_amx *amx = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned char *bytes_map = (unsigned char *)&amx->map;\n\tint reg = mc->reg;\n\tint value = ucontrol->value.integer.value[0];\n\tunsigned int mask_val = amx->byte_mask[reg / 32];\n\n\tif (value >= 0 && value <= 255)\n\t\tmask_val |= (1 << (reg % 32));\n\telse\n\t\tmask_val &= ~(1 << (reg % 32));\n\n\tif (mask_val == amx->byte_mask[reg / 32])\n\t\treturn 0;\n\n\t \n\tbytes_map[reg] = value % 256;\n\tamx->byte_mask[reg / 32] = mask_val;\n\n\treturn 1;\n}\n\nstatic const struct snd_soc_dai_ops tegra210_amx_out_dai_ops = {\n\t.hw_params\t= tegra210_amx_out_hw_params,\n\t.startup\t= tegra210_amx_startup,\n};\n\nstatic const struct snd_soc_dai_ops tegra210_amx_in_dai_ops = {\n\t.hw_params\t= tegra210_amx_in_hw_params,\n};\n\n#define IN_DAI(id)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = \"AMX-RX-CIF\" #id,\t\t\t\\\n\t\t.playback = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"RX\" #id \"-CIF-Playback\",\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"RX\" #id \"-CIF-Capture\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.ops = &tegra210_amx_in_dai_ops,\t\t\\\n\t}\n\n#define OUT_DAI\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = \"AMX-TX-CIF\",\t\t\t\t\\\n\t\t.playback = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"TX-CIF-Playback\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"TX-CIF-Capture\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.ops = &tegra210_amx_out_dai_ops,\t\t\\\n\t}\n\nstatic struct snd_soc_dai_driver tegra210_amx_dais[] = {\n\tIN_DAI(1),\n\tIN_DAI(2),\n\tIN_DAI(3),\n\tIN_DAI(4),\n\tOUT_DAI,\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_amx_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"RX1\", NULL, 0, TEGRA210_AMX_CTRL, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"RX2\", NULL, 0, TEGRA210_AMX_CTRL, 1, 0),\n\tSND_SOC_DAPM_AIF_IN(\"RX3\", NULL, 0, TEGRA210_AMX_CTRL, 2, 0),\n\tSND_SOC_DAPM_AIF_IN(\"RX4\", NULL, 0, TEGRA210_AMX_CTRL, 3, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX\", NULL, 0, TEGRA210_AMX_ENABLE,\n\t\t\t     TEGRA210_AMX_ENABLE_SHIFT, 0),\n};\n\n#define STREAM_ROUTES(id, sname)\t\t\t\t\t  \\\n\t{ \"RX\" #id \" XBAR-\" sname,\tNULL,\t\"RX\" #id \" XBAR-TX\" },\t  \\\n\t{ \"RX\" #id \"-CIF-\" sname,\tNULL,\t\"RX\" #id \" XBAR-\" sname },\\\n\t{ \"RX\" #id,\t\t\tNULL,\t\"RX\" #id \"-CIF-\" sname }, \\\n\t{ \"TX\",\t\t\t\tNULL,\t\"RX\" #id },\t\t  \\\n\t{ \"TX-CIF-\" sname,\t\tNULL,\t\"TX\" },\t\t\t  \\\n\t{ \"XBAR-\" sname,\t\tNULL,\t\"TX-CIF-\" sname },\t  \\\n\t{ \"XBAR-RX\",\t\t\tNULL,\t\"XBAR-\" sname }\n\n#define AMX_ROUTES(id)\t\t\t\\\n\tSTREAM_ROUTES(id, \"Playback\"),\t\\\n\tSTREAM_ROUTES(id, \"Capture\")\n\nstatic const struct snd_soc_dapm_route tegra210_amx_routes[] = {\n\tAMX_ROUTES(1),\n\tAMX_ROUTES(2),\n\tAMX_ROUTES(3),\n\tAMX_ROUTES(4),\n};\n\n#define TEGRA210_AMX_BYTE_MAP_CTRL(reg)\t\t\t\t\t\\\n\tSOC_SINGLE_EXT(\"Byte Map \" #reg, reg, 0, 256, 0,\t\t\\\n\t\t       tegra210_amx_get_byte_map,\t\t\t\\\n\t\t       tegra210_amx_put_byte_map)\n\nstatic struct snd_kcontrol_new tegra210_amx_controls[] = {\n\tTEGRA210_AMX_BYTE_MAP_CTRL(0),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(1),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(2),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(3),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(4),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(5),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(6),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(7),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(8),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(9),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(10),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(11),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(12),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(13),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(14),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(15),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(16),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(17),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(18),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(19),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(20),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(21),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(22),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(23),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(24),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(25),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(26),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(27),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(28),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(29),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(30),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(31),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(32),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(33),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(34),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(35),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(36),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(37),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(38),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(39),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(40),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(41),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(42),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(43),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(44),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(45),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(46),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(47),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(48),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(49),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(50),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(51),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(52),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(53),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(54),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(55),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(56),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(57),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(58),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(59),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(60),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(61),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(62),\n\tTEGRA210_AMX_BYTE_MAP_CTRL(63),\n};\n\nstatic const struct snd_soc_component_driver tegra210_amx_cmpnt = {\n\t.dapm_widgets\t\t= tegra210_amx_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_amx_widgets),\n\t.dapm_routes\t\t= tegra210_amx_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_amx_routes),\n\t.controls\t\t= tegra210_amx_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_amx_controls),\n};\n\nstatic bool tegra210_amx_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_AMX_RX_INT_MASK ... TEGRA210_AMX_RX4_CIF_CTRL:\n\tcase TEGRA210_AMX_TX_INT_MASK ... TEGRA210_AMX_CG:\n\tcase TEGRA210_AMX_CTRL ... TEGRA210_AMX_CYA:\n\tcase TEGRA210_AMX_CFG_RAM_CTRL ... TEGRA210_AMX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra194_amx_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA194_AMX_RX1_FRAME_PERIOD ... TEGRA194_AMX_RX4_FRAME_PERIOD:\n\t\treturn true;\n\tdefault:\n\t\treturn tegra210_amx_wr_reg(dev, reg);\n\t}\n}\n\nstatic bool tegra210_amx_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_AMX_RX_STATUS ... TEGRA210_AMX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra194_amx_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA194_AMX_RX1_FRAME_PERIOD ... TEGRA194_AMX_RX4_FRAME_PERIOD:\n\t\treturn true;\n\tdefault:\n\t\treturn tegra210_amx_rd_reg(dev, reg);\n\t}\n}\n\nstatic bool tegra210_amx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_AMX_RX_STATUS:\n\tcase TEGRA210_AMX_RX_INT_STATUS:\n\tcase TEGRA210_AMX_RX_INT_SET:\n\tcase TEGRA210_AMX_TX_STATUS:\n\tcase TEGRA210_AMX_TX_INT_STATUS:\n\tcase TEGRA210_AMX_TX_INT_SET:\n\tcase TEGRA210_AMX_SOFT_RESET:\n\tcase TEGRA210_AMX_STATUS:\n\tcase TEGRA210_AMX_INT_STATUS:\n\tcase TEGRA210_AMX_CFG_RAM_CTRL:\n\tcase TEGRA210_AMX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra210_amx_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_AMX_CFG_RAM_DATA,\n\t.writeable_reg\t\t= tegra210_amx_wr_reg,\n\t.readable_reg\t\t= tegra210_amx_rd_reg,\n\t.volatile_reg\t\t= tegra210_amx_volatile_reg,\n\t.reg_defaults\t\t= tegra210_amx_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_amx_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config tegra194_amx_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA194_AMX_RX4_LAST_FRAME_PERIOD,\n\t.writeable_reg\t\t= tegra194_amx_wr_reg,\n\t.readable_reg\t\t= tegra194_amx_rd_reg,\n\t.volatile_reg\t\t= tegra210_amx_volatile_reg,\n\t.reg_defaults\t\t= tegra210_amx_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_amx_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic const struct tegra210_amx_soc_data soc_data_tegra210 = {\n\t.regmap_conf\t= &tegra210_amx_regmap_config,\n};\n\nstatic const struct tegra210_amx_soc_data soc_data_tegra194 = {\n\t.regmap_conf\t= &tegra194_amx_regmap_config,\n\t.auto_disable\t= true,\n};\n\nstatic const struct of_device_id tegra210_amx_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-amx\", .data = &soc_data_tegra210 },\n\t{ .compatible = \"nvidia,tegra194-amx\", .data = &soc_data_tegra194 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_amx_of_match);\n\nstatic int tegra210_amx_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_amx *amx;\n\tvoid __iomem *regs;\n\tint err;\n\tconst struct of_device_id *match;\n\tstruct tegra210_amx_soc_data *soc_data;\n\n\tmatch = of_match_device(tegra210_amx_of_match, dev);\n\n\tsoc_data = (struct tegra210_amx_soc_data *)match->data;\n\n\tamx = devm_kzalloc(dev, sizeof(*amx), GFP_KERNEL);\n\tif (!amx)\n\t\treturn -ENOMEM;\n\n\tamx->soc_data = soc_data;\n\n\tdev_set_drvdata(dev, amx);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tamx->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t    soc_data->regmap_conf);\n\tif (IS_ERR(amx->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(amx->regmap);\n\t}\n\n\tregcache_cache_only(amx->regmap, true);\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_amx_cmpnt,\n\t\t\t\t\t      tegra210_amx_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_amx_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register AMX component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_amx_platform_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra210_amx_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_amx_runtime_suspend,\n\t\t\t   tegra210_amx_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra210_amx_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-amx\",\n\t\t.of_match_table = tegra210_amx_of_match,\n\t\t.pm = &tegra210_amx_pm_ops,\n\t},\n\t.probe = tegra210_amx_platform_probe,\n\t.remove_new = tegra210_amx_platform_remove,\n};\nmodule_platform_driver(tegra210_amx_driver);\n\nMODULE_AUTHOR(\"Songhee Baek <sbaek@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 AMX ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}