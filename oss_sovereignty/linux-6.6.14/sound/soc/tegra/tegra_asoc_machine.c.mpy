{
  "module_name": "tegra_asoc_machine.c",
  "hash_id": "8e99d412a13c9006317592fb351cc3a5afde4eff26855bb892b4c1528790cb37",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra_asoc_machine.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"tegra_asoc_machine.h\"\n\n \n\nstatic struct snd_soc_jack tegra_machine_hp_jack;\n\nstatic struct snd_soc_jack_pin tegra_machine_hp_jack_pins[] = {\n\t{ .pin = \"Headphone\",  .mask = SND_JACK_HEADPHONE },\n\t{ .pin = \"Headphones\", .mask = SND_JACK_HEADPHONE },\n};\n\nstatic struct snd_soc_jack_gpio tegra_machine_hp_jack_gpio = {\n\t.name = \"Headphones detection\",\n\t.report = SND_JACK_HEADPHONE,\n\t.debounce_time = 150,\n};\n\n \n\nstatic struct snd_soc_jack tegra_machine_headset_jack;\n\nstatic struct snd_soc_jack_pin tegra_machine_headset_jack_pins[] = {\n\t{ .pin = \"Headset Mic\", .mask = SND_JACK_MICROPHONE },\n\t{ .pin = \"Headset Stereophone\", .mask = SND_JACK_HEADPHONE },\n};\n\nstatic struct snd_soc_jack_gpio tegra_machine_headset_jack_gpio = {\n\t.name = \"Headset detection\",\n\t.report = SND_JACK_HEADSET,\n\t.debounce_time = 150,\n};\n\n \nstatic int coupled_mic_hp_check(void *data)\n{\n\tstruct tegra_machine *machine = (struct tegra_machine *)data;\n\n\t \n\tif (gpiod_get_value_cansleep(machine->gpiod_hp_det) &&\n\t    gpiod_get_value_cansleep(machine->gpiod_mic_det))\n\t\treturn SND_JACK_MICROPHONE;\n\n\treturn 0;\n}\n\nstatic struct snd_soc_jack tegra_machine_mic_jack;\n\nstatic struct snd_soc_jack_pin tegra_machine_mic_jack_pins[] = {\n\t{ .pin = \"Mic Jack\",    .mask = SND_JACK_MICROPHONE },\n\t{ .pin = \"Headset Mic\", .mask = SND_JACK_MICROPHONE },\n};\n\nstatic struct snd_soc_jack_gpio tegra_machine_mic_jack_gpio = {\n\t.name = \"Mic detection\",\n\t.report = SND_JACK_MICROPHONE,\n\t.debounce_time = 150,\n};\n\nstatic int tegra_machine_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *k, int event)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct tegra_machine *machine = snd_soc_card_get_drvdata(dapm->card);\n\n\tif (!strcmp(w->name, \"Int Spk\") || !strcmp(w->name, \"Speakers\"))\n\t\tgpiod_set_value_cansleep(machine->gpiod_spkr_en,\n\t\t\t\t\t SND_SOC_DAPM_EVENT_ON(event));\n\n\tif (!strcmp(w->name, \"Mic Jack\") || !strcmp(w->name, \"Headset Mic\"))\n\t\tgpiod_set_value_cansleep(machine->gpiod_ext_mic_en,\n\t\t\t\t\t SND_SOC_DAPM_EVENT_ON(event));\n\n\tif (!strcmp(w->name, \"Int Mic\") || !strcmp(w->name, \"Internal Mic 2\"))\n\t\tgpiod_set_value_cansleep(machine->gpiod_int_mic_en,\n\t\t\t\t\t SND_SOC_DAPM_EVENT_ON(event));\n\n\tif (!strcmp(w->name, \"Headphone\") || !strcmp(w->name, \"Headphone Jack\"))\n\t\tgpiod_set_value_cansleep(machine->gpiod_hp_mute,\n\t\t\t\t\t !SND_SOC_DAPM_EVENT_ON(event));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget tegra_machine_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", tegra_machine_event),\n\tSND_SOC_DAPM_HP(\"Headphone\", tegra_machine_event),\n\tSND_SOC_DAPM_HP(\"Headset Stereophone\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphones\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speakers\", tegra_machine_event),\n\tSND_SOC_DAPM_SPK(\"Int Spk\", tegra_machine_event),\n\tSND_SOC_DAPM_SPK(\"Earpiece\", NULL),\n\tSND_SOC_DAPM_MIC(\"Int Mic\", tegra_machine_event),\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", tegra_machine_event),\n\tSND_SOC_DAPM_MIC(\"Internal Mic 1\", NULL),\n\tSND_SOC_DAPM_MIC(\"Internal Mic 2\", tegra_machine_event),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", tegra_machine_event),\n\tSND_SOC_DAPM_MIC(\"Digital Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Mic\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In\", NULL),\n\tSND_SOC_DAPM_LINE(\"LineIn\", NULL),\n};\n\nstatic const struct snd_kcontrol_new tegra_machine_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Speakers\"),\n\tSOC_DAPM_PIN_SWITCH(\"Int Spk\"),\n\tSOC_DAPM_PIN_SWITCH(\"Earpiece\"),\n\tSOC_DAPM_PIN_SWITCH(\"Int Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n\tSOC_DAPM_PIN_SWITCH(\"Internal Mic 1\"),\n\tSOC_DAPM_PIN_SWITCH(\"Internal Mic 2\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headphones\"),\n\tSOC_DAPM_PIN_SWITCH(\"Mic Jack\"),\n};\n\nint tegra_asoc_machine_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct tegra_machine *machine = snd_soc_card_get_drvdata(card);\n\tconst char *jack_name;\n\tint err;\n\n\tif (machine->gpiod_hp_det && machine->asoc->add_hp_jack) {\n\t\tif (machine->asoc->hp_jack_name)\n\t\t\tjack_name = machine->asoc->hp_jack_name;\n\t\telse\n\t\t\tjack_name = \"Headphones Jack\";\n\n\t\terr = snd_soc_card_jack_new_pins(card, jack_name,\n\t\t\t\t\t\t SND_JACK_HEADPHONE,\n\t\t\t\t\t\t &tegra_machine_hp_jack,\n\t\t\t\t\t\t tegra_machine_hp_jack_pins,\n\t\t\t\t\t\t ARRAY_SIZE(tegra_machine_hp_jack_pins));\n\t\tif (err) {\n\t\t\tdev_err(rtd->dev,\n\t\t\t\t\"Headphones Jack creation failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\ttegra_machine_hp_jack_gpio.desc = machine->gpiod_hp_det;\n\n\t\terr = snd_soc_jack_add_gpios(&tegra_machine_hp_jack, 1,\n\t\t\t\t\t     &tegra_machine_hp_jack_gpio);\n\t\tif (err)\n\t\t\tdev_err(rtd->dev, \"HP GPIOs not added: %d\\n\", err);\n\t}\n\n\tif (machine->gpiod_hp_det && machine->asoc->add_headset_jack) {\n\t\terr = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t\t SND_JACK_HEADSET,\n\t\t\t\t\t\t &tegra_machine_headset_jack,\n\t\t\t\t\t\t tegra_machine_headset_jack_pins,\n\t\t\t\t\t\t ARRAY_SIZE(tegra_machine_headset_jack_pins));\n\t\tif (err) {\n\t\t\tdev_err(rtd->dev,\n\t\t\t\t\"Headset Jack creation failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\ttegra_machine_headset_jack_gpio.desc = machine->gpiod_hp_det;\n\n\t\terr = snd_soc_jack_add_gpios(&tegra_machine_headset_jack, 1,\n\t\t\t\t\t     &tegra_machine_headset_jack_gpio);\n\t\tif (err)\n\t\t\tdev_err(rtd->dev, \"Headset GPIOs not added: %d\\n\", err);\n\t}\n\n\tif (machine->gpiod_mic_det && machine->asoc->add_mic_jack) {\n\t\terr = snd_soc_card_jack_new_pins(rtd->card, \"Mic Jack\",\n\t\t\t\t\t\t SND_JACK_MICROPHONE,\n\t\t\t\t\t\t &tegra_machine_mic_jack,\n\t\t\t\t\t\t tegra_machine_mic_jack_pins,\n\t\t\t\t\t\t ARRAY_SIZE(tegra_machine_mic_jack_pins));\n\t\tif (err) {\n\t\t\tdev_err(rtd->dev, \"Mic Jack creation failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\ttegra_machine_mic_jack_gpio.data = machine;\n\t\ttegra_machine_mic_jack_gpio.desc = machine->gpiod_mic_det;\n\n\t\tif (of_property_read_bool(card->dev->of_node,\n\t\t\t\t\t  \"nvidia,coupled-mic-hp-det\")) {\n\t\t\ttegra_machine_mic_jack_gpio.desc = machine->gpiod_hp_det;\n\t\t\ttegra_machine_mic_jack_gpio.jack_status_check = coupled_mic_hp_check;\n\t\t}\n\n\t\terr = snd_soc_jack_add_gpios(&tegra_machine_mic_jack, 1,\n\t\t\t\t\t     &tegra_machine_mic_jack_gpio);\n\t\tif (err)\n\t\t\tdev_err(rtd->dev, \"Mic GPIOs not added: %d\\n\", err);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_asoc_machine_init);\n\nstatic unsigned int tegra_machine_mclk_rate_128(unsigned int srate)\n{\n\treturn 128 * srate;\n}\n\nstatic unsigned int tegra_machine_mclk_rate_256(unsigned int srate)\n{\n\treturn 256 * srate;\n}\n\nstatic unsigned int tegra_machine_mclk_rate_512(unsigned int srate)\n{\n\treturn 512 * srate;\n}\n\nstatic unsigned int tegra_machine_mclk_rate_12mhz(unsigned int srate)\n{\n\tunsigned int mclk;\n\n\tswitch (srate) {\n\tcase 8000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\tcase 64000:\n\tcase 96000:\n\t\tmclk = 12288000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\t\tmclk = 11289600;\n\t\tbreak;\n\tdefault:\n\t\tmclk = 12000000;\n\t\tbreak;\n\t}\n\n\treturn mclk;\n}\n\nstatic unsigned int tegra_machine_mclk_rate_6mhz(unsigned int srate)\n{\n\tunsigned int mclk;\n\n\tswitch (srate) {\n\tcase 8000:\n\tcase 16000:\n\tcase 64000:\n\t\tmclk = 8192000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\tcase 88200:\n\t\tmclk = 11289600;\n\t\tbreak;\n\tcase 96000:\n\t\tmclk = 12288000;\n\t\tbreak;\n\tdefault:\n\t\tmclk = 256 * srate;\n\t\tbreak;\n\t}\n\n\treturn mclk;\n}\n\nstatic int tegra_machine_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct tegra_machine *machine = snd_soc_card_get_drvdata(card);\n\tunsigned int srate = params_rate(params);\n\tunsigned int mclk = machine->asoc->mclk_rate(srate);\n\tunsigned int clk_id = machine->asoc->mclk_id;\n\tunsigned int new_baseclock;\n\tint err;\n\n\tswitch (srate) {\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\t\tif (of_machine_is_compatible(\"nvidia,tegra20\"))\n\t\t\tnew_baseclock = 56448000;\n\t\telse if (of_machine_is_compatible(\"nvidia,tegra30\"))\n\t\t\tnew_baseclock = 564480000;\n\t\telse\n\t\t\tnew_baseclock = 282240000;\n\t\tbreak;\n\tcase 8000:\n\tcase 16000:\n\tcase 32000:\n\tcase 48000:\n\tcase 64000:\n\tcase 96000:\n\t\tif (of_machine_is_compatible(\"nvidia,tegra20\"))\n\t\t\tnew_baseclock = 73728000;\n\t\telse if (of_machine_is_compatible(\"nvidia,tegra30\"))\n\t\t\tnew_baseclock = 552960000;\n\t\telse\n\t\t\tnew_baseclock = 368640000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(card->dev, \"Invalid sound rate: %u\\n\", srate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_baseclock != machine->set_baseclock ||\n\t    mclk != machine->set_mclk) {\n\t\tmachine->set_baseclock = 0;\n\t\tmachine->set_mclk = 0;\n\n\t\tclk_disable_unprepare(machine->clk_cdev1);\n\n\t\terr = clk_set_rate(machine->clk_pll_a, new_baseclock);\n\t\tif (err) {\n\t\t\tdev_err(card->dev, \"Can't set pll_a rate: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = clk_set_rate(machine->clk_pll_a_out0, mclk);\n\t\tif (err) {\n\t\t\tdev_err(card->dev, \"Can't set pll_a_out0 rate: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\n\t\terr = clk_prepare_enable(machine->clk_cdev1);\n\t\tif (err) {\n\t\t\tdev_err(card->dev, \"Can't enable cdev1: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tmachine->set_baseclock = new_baseclock;\n\t\tmachine->set_mclk = mclk;\n\t}\n\n\terr = snd_soc_dai_set_sysclk(codec_dai, clk_id, mclk, SND_SOC_CLOCK_IN);\n\tif (err < 0) {\n\t\tdev_err(card->dev, \"codec_dai clock not set: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops tegra_machine_snd_ops = {\n\t.hw_params = tegra_machine_hw_params,\n};\n\nstatic void tegra_machine_node_release(void *of_node)\n{\n\tof_node_put(of_node);\n}\n\nstatic struct device_node *\ntegra_machine_parse_phandle(struct device *dev, const char *name)\n{\n\tstruct device_node *np;\n\tint err;\n\n\tnp = of_parse_phandle(dev->of_node, name, 0);\n\tif (!np) {\n\t\tdev_err(dev, \"Property '%s' missing or invalid\\n\", name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\terr = devm_add_action_or_reset(dev, tegra_machine_node_release, np);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn np;\n}\n\nstatic void tegra_machine_unregister_codec(void *pdev)\n{\n\tplatform_device_unregister(pdev);\n}\n\nstatic int tegra_machine_register_codec(struct device *dev, const char *name)\n{\n\tstruct platform_device *pdev;\n\tint err;\n\n\tif (!name)\n\t\treturn 0;\n\n\tpdev = platform_device_register_simple(name, -1, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\terr = devm_add_action_or_reset(dev, tegra_machine_unregister_codec,\n\t\t\t\t       pdev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nint tegra_asoc_machine_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np_codec, *np_i2s, *np_ac97;\n\tconst struct tegra_asoc_data *asoc;\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra_machine *machine;\n\tstruct snd_soc_card *card;\n\tstruct gpio_desc *gpiod;\n\tint err;\n\n\tmachine = devm_kzalloc(dev, sizeof(*machine), GFP_KERNEL);\n\tif (!machine)\n\t\treturn -ENOMEM;\n\n\tasoc = of_device_get_match_data(dev);\n\tcard = asoc->card;\n\tcard->dev = dev;\n\n\tmachine->asoc = asoc;\n\tmachine->mic_jack = &tegra_machine_mic_jack;\n\tmachine->hp_jack_gpio = &tegra_machine_hp_jack_gpio;\n\tsnd_soc_card_set_drvdata(card, machine);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,hp-mute\", GPIOD_OUT_HIGH);\n\tmachine->gpiod_hp_mute = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,hp-det\", GPIOD_IN);\n\tmachine->gpiod_hp_det = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,mic-det\", GPIOD_IN);\n\tmachine->gpiod_mic_det = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,spkr-en\", GPIOD_OUT_LOW);\n\tmachine->gpiod_spkr_en = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,int-mic-en\", GPIOD_OUT_LOW);\n\tmachine->gpiod_int_mic_en = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod = devm_gpiod_get_optional(dev, \"nvidia,ext-mic-en\", GPIOD_OUT_LOW);\n\tmachine->gpiod_ext_mic_en = gpiod;\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\terr = snd_soc_of_parse_card_name(card, \"nvidia,model\");\n\tif (err)\n\t\treturn err;\n\n\tif (!card->dapm_routes) {\n\t\terr = snd_soc_of_parse_audio_routing(card, \"nvidia,audio-routing\");\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (asoc->set_ac97) {\n\t\terr = tegra_machine_register_codec(dev, asoc->codec_dev_name);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnp_ac97 = tegra_machine_parse_phandle(dev, \"nvidia,ac97-controller\");\n\t\tif (IS_ERR(np_ac97))\n\t\t\treturn PTR_ERR(np_ac97);\n\n\t\tcard->dai_link->cpus->of_node = np_ac97;\n\t\tcard->dai_link->platforms->of_node = np_ac97;\n\t} else {\n\t\tnp_codec = tegra_machine_parse_phandle(dev, \"nvidia,audio-codec\");\n\t\tif (IS_ERR(np_codec))\n\t\t\treturn PTR_ERR(np_codec);\n\n\t\tnp_i2s = tegra_machine_parse_phandle(dev, \"nvidia,i2s-controller\");\n\t\tif (IS_ERR(np_i2s))\n\t\t\treturn PTR_ERR(np_i2s);\n\n\t\tcard->dai_link->cpus->of_node = np_i2s;\n\t\tcard->dai_link->codecs->of_node = np_codec;\n\t\tcard->dai_link->platforms->of_node = np_i2s;\n\t}\n\n\tif (asoc->add_common_controls) {\n\t\tcard->controls = tegra_machine_controls;\n\t\tcard->num_controls = ARRAY_SIZE(tegra_machine_controls);\n\t}\n\n\tif (asoc->add_common_dapm_widgets) {\n\t\tcard->dapm_widgets = tegra_machine_dapm_widgets;\n\t\tcard->num_dapm_widgets = ARRAY_SIZE(tegra_machine_dapm_widgets);\n\t}\n\n\tif (asoc->add_common_snd_ops)\n\t\tcard->dai_link->ops = &tegra_machine_snd_ops;\n\n\tif (!card->owner)\n\t\tcard->owner = THIS_MODULE;\n\tif (!card->driver_name)\n\t\tcard->driver_name = \"tegra\";\n\n\tmachine->clk_pll_a = devm_clk_get(dev, \"pll_a\");\n\tif (IS_ERR(machine->clk_pll_a)) {\n\t\tdev_err(dev, \"Can't retrieve clk pll_a\\n\");\n\t\treturn PTR_ERR(machine->clk_pll_a);\n\t}\n\n\tmachine->clk_pll_a_out0 = devm_clk_get(dev, \"pll_a_out0\");\n\tif (IS_ERR(machine->clk_pll_a_out0)) {\n\t\tdev_err(dev, \"Can't retrieve clk pll_a_out0\\n\");\n\t\treturn PTR_ERR(machine->clk_pll_a_out0);\n\t}\n\n\tmachine->clk_cdev1 = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(machine->clk_cdev1)) {\n\t\tdev_err(dev, \"Can't retrieve clk cdev1\\n\");\n\t\treturn PTR_ERR(machine->clk_cdev1);\n\t}\n\n\t \n\tif (!of_property_present(dev->of_node, \"assigned-clock-parents\") &&\n\t    !of_machine_is_compatible(\"nvidia,tegra20\")) {\n\t\tstruct clk *clk_out_1, *clk_extern1;\n\n\t\tdev_warn(dev, \"Configuring clocks for a legacy device-tree\\n\");\n\t\tdev_warn(dev, \"Please update DT to use assigned-clock-parents\\n\");\n\n\t\tclk_extern1 = devm_clk_get(dev, \"extern1\");\n\t\tif (IS_ERR(clk_extern1)) {\n\t\t\tdev_err(dev, \"Can't retrieve clk extern1\\n\");\n\t\t\treturn PTR_ERR(clk_extern1);\n\t\t}\n\n\t\terr = clk_set_parent(clk_extern1, machine->clk_pll_a_out0);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"Set parent failed for clk extern1\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tclk_out_1 = devm_clk_get(dev, \"pmc_clk_out_1\");\n\t\tif (IS_ERR(clk_out_1)) {\n\t\t\tdev_err(dev, \"Can't retrieve pmc_clk_out_1\\n\");\n\t\t\treturn PTR_ERR(clk_out_1);\n\t\t}\n\n\t\terr = clk_set_parent(clk_out_1, clk_extern1);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"Set parent failed for pmc_clk_out_1\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tmachine->clk_cdev1 = clk_out_1;\n\t}\n\n\tif (asoc->set_ac97) {\n\t\t \n\t\terr = clk_set_rate(machine->clk_pll_a, 73728000);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Can't set pll_a rate: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = clk_set_rate(machine->clk_pll_a_out0, 24576000);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Can't set pll_a_out0 rate: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tmachine->set_baseclock = 73728000;\n\t\tmachine->set_mclk = 24576000;\n\t}\n\n\t \n\terr = clk_prepare_enable(machine->clk_cdev1);\n\tif (err) {\n\t\tdev_err(dev, \"Can't enable cdev1: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_snd_soc_register_card(dev, card);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tegra_asoc_machine_probe);\n\n \n\nSND_SOC_DAILINK_DEFS(wm8753_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"wm8753-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_wm8753_dai = {\n\t.name = \"WM8753\",\n\t.stream_name = \"WM8753 PCM\",\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(wm8753_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_wm8753 = {\n\t.components = \"codec:wm8753\",\n\t.dai_link = &tegra_wm8753_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_wm8753_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_12mhz,\n\t.card = &snd_soc_tegra_wm8753,\n\t.add_common_dapm_widgets = true,\n\t.add_common_snd_ops = true,\n};\n\n \n\nstatic int tegra_wm9712_init(struct snd_soc_pcm_runtime *rtd)\n{\n\treturn snd_soc_dapm_force_enable_pin(&rtd->card->dapm, \"Mic Bias\");\n}\n\nSND_SOC_DAILINK_DEFS(wm9712_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"wm9712-codec\", \"wm9712-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_wm9712_dai = {\n\t.name = \"AC97 HiFi\",\n\t.stream_name = \"AC97 HiFi\",\n\t.init = tegra_wm9712_init,\n\tSND_SOC_DAILINK_REG(wm9712_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_wm9712 = {\n\t.components = \"codec:wm9712\",\n\t.dai_link = &tegra_wm9712_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_wm9712_data = {\n\t.card = &snd_soc_tegra_wm9712,\n\t.add_common_dapm_widgets = true,\n\t.codec_dev_name = \"wm9712-codec\",\n\t.set_ac97 = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(max98090_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"HiFi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_max98090_dai = {\n\t.name = \"max98090\",\n\t.stream_name = \"max98090 PCM\",\n\t.init = tegra_asoc_machine_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(max98090_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_max98090 = {\n\t.components = \"codec:max98090\",\n\t.dai_link = &tegra_max98090_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_max98090_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_12mhz,\n\t.card = &snd_soc_tegra_max98090,\n\t.hp_jack_name = \"Headphones\",\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_mic_jack = true,\n\t.add_hp_jack = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(max98088_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"HiFi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_max98088_dai = {\n\t.name = \"MAX98088\",\n\t.stream_name = \"MAX98088 PCM\",\n\t.init = tegra_asoc_machine_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(max98088_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_max98088 = {\n\t.components = \"codec:max98088\",\n\t.dai_link = &tegra_max98088_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_max98088_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_12mhz,\n\t.card = &snd_soc_tegra_max98088,\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_mic_jack = true,\n\t.add_hp_jack = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(sgtl5000_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"sgtl5000\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_sgtl5000_dai = {\n\t.name = \"sgtl5000\",\n\t.stream_name = \"HiFi\",\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(sgtl5000_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_sgtl5000 = {\n\t.components = \"codec:sgtl5000\",\n\t.dai_link = &tegra_sgtl5000_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_sgtl5000_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_12mhz,\n\t.card = &snd_soc_tegra_sgtl5000,\n\t.add_common_dapm_widgets = true,\n\t.add_common_snd_ops = true,\n};\n\n \n\nstatic const struct snd_soc_dapm_widget trimslice_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Line Out\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route trimslice_audio_map[] = {\n\t{\"Line Out\", NULL, \"LOUT\"},\n\t{\"Line Out\", NULL, \"ROUT\"},\n\n\t{\"LLINEIN\", NULL, \"Line In\"},\n\t{\"RLINEIN\", NULL, \"Line In\"},\n};\n\nSND_SOC_DAILINK_DEFS(tlv320aic23_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"tlv320aic23-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_tlv320aic23_dai = {\n\t.name = \"TLV320AIC23\",\n\t.stream_name = \"AIC23\",\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(tlv320aic23_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_trimslice = {\n\t.name = \"tegra-trimslice\",\n\t.components = \"codec:tlv320aic23\",\n\t.dai_link = &tegra_tlv320aic23_dai,\n\t.num_links = 1,\n\t.dapm_widgets = trimslice_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(trimslice_dapm_widgets),\n\t.dapm_routes = trimslice_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(trimslice_audio_map),\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_trimslice_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_128,\n\t.card = &snd_soc_tegra_trimslice,\n\t.add_common_snd_ops = true,\n};\n\n \n\nstatic int tegra_rt5677_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tint err;\n\n\terr = tegra_asoc_machine_init(rtd);\n\tif (err)\n\t\treturn err;\n\n\tsnd_soc_dapm_force_enable_pin(&card->dapm, \"MICBIAS1\");\n\n\treturn 0;\n}\n\nSND_SOC_DAILINK_DEFS(rt5677_aif1,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"rt5677-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_rt5677_dai = {\n\t.name = \"RT5677\",\n\t.stream_name = \"RT5677 PCM\",\n\t.init = tegra_rt5677_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(rt5677_aif1),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_rt5677 = {\n\t.components = \"codec:rt5677\",\n\t.dai_link = &tegra_rt5677_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_rt5677_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_256,\n\t.card = &snd_soc_tegra_rt5677,\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_mic_jack = true,\n\t.add_hp_jack = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(rt5640_aif1,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"rt5640-aif1\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_rt5640_dai = {\n\t.name = \"RT5640\",\n\t.stream_name = \"RT5640 PCM\",\n\t.init = tegra_asoc_machine_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(rt5640_aif1),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_rt5640 = {\n\t.components = \"codec:rt5640\",\n\t.dai_link = &tegra_rt5640_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_rt5640_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_256,\n\t.card = &snd_soc_tegra_rt5640,\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_hp_jack = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(rt5632_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"alc5632-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_rt5632_dai = {\n\t.name = \"ALC5632\",\n\t.stream_name = \"ALC5632 PCM\",\n\t.init = tegra_rt5677_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(rt5632_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_rt5632 = {\n\t.components = \"codec:rt5632\",\n\t.dai_link = &tegra_rt5632_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_rt5632_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_512,\n\t.card = &snd_soc_tegra_rt5632,\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_headset_jack = true,\n};\n\n \n\nSND_SOC_DAILINK_DEFS(rt5631_hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"rt5631-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link tegra_rt5631_dai = {\n\t.name = \"RT5631\",\n\t.stream_name = \"RT5631 PCM\",\n\t.init = tegra_asoc_machine_init,\n\t.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t   SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBS_CFS,\n\tSND_SOC_DAILINK_REG(rt5631_hifi),\n};\n\nstatic struct snd_soc_card snd_soc_tegra_rt5631 = {\n\t.components = \"codec:rt5631\",\n\t.dai_link = &tegra_rt5631_dai,\n\t.num_links = 1,\n\t.fully_routed = true,\n};\n\nstatic const struct tegra_asoc_data tegra_rt5631_data = {\n\t.mclk_rate = tegra_machine_mclk_rate_6mhz,\n\t.card = &snd_soc_tegra_rt5631,\n\t.add_common_dapm_widgets = true,\n\t.add_common_controls = true,\n\t.add_common_snd_ops = true,\n\t.add_mic_jack = true,\n\t.add_hp_jack = true,\n};\n\nstatic const struct of_device_id tegra_machine_of_match[] = {\n\t{ .compatible = \"nvidia,tegra-audio-trimslice\", .data = &tegra_trimslice_data },\n\t{ .compatible = \"nvidia,tegra-audio-max98090\", .data = &tegra_max98090_data },\n\t{ .compatible = \"nvidia,tegra-audio-max98088\", .data = &tegra_max98088_data },\n\t{ .compatible = \"nvidia,tegra-audio-max98089\", .data = &tegra_max98088_data },\n\t{ .compatible = \"nvidia,tegra-audio-sgtl5000\", .data = &tegra_sgtl5000_data },\n\t{ .compatible = \"nvidia,tegra-audio-wm9712\", .data = &tegra_wm9712_data },\n\t{ .compatible = \"nvidia,tegra-audio-wm8753\", .data = &tegra_wm8753_data },\n\t{ .compatible = \"nvidia,tegra-audio-rt5677\", .data = &tegra_rt5677_data },\n\t{ .compatible = \"nvidia,tegra-audio-rt5640\", .data = &tegra_rt5640_data },\n\t{ .compatible = \"nvidia,tegra-audio-alc5632\", .data = &tegra_rt5632_data },\n\t{ .compatible = \"nvidia,tegra-audio-rt5631\", .data = &tegra_rt5631_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_machine_of_match);\n\nstatic struct platform_driver tegra_asoc_machine_driver = {\n\t.driver = {\n\t\t.name = \"tegra-audio\",\n\t\t.of_match_table = tegra_machine_of_match,\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = tegra_asoc_machine_probe,\n};\nmodule_platform_driver(tegra_asoc_machine_driver);\n\nMODULE_AUTHOR(\"Anatol Pomozov <anatol@google.com>\");\nMODULE_AUTHOR(\"Andrey Danin <danindrey@mail.ru>\");\nMODULE_AUTHOR(\"Dmitry Osipenko <digetx@gmail.com>\");\nMODULE_AUTHOR(\"Ion Agorria <ion@agorria.com>\");\nMODULE_AUTHOR(\"Leon Romanovsky <leon@leon.nu>\");\nMODULE_AUTHOR(\"Lucas Stach <dev@lynxeye.de>\");\nMODULE_AUTHOR(\"Marc Dietrich <marvin24@gmx.de>\");\nMODULE_AUTHOR(\"Marcel Ziswiler <marcel@ziswiler.com>\");\nMODULE_AUTHOR(\"Mike Rapoport <mike@compulab.co.il>\");\nMODULE_AUTHOR(\"Stephen Warren <swarren@nvidia.com>\");\nMODULE_AUTHOR(\"Svyatoslav Ryhel <clamor95@gmail.com>\");\nMODULE_DESCRIPTION(\"Tegra machine ASoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}