{
  "module_name": "tegra210_ope.c",
  "hash_id": "a7b884546335509c586c13c2e67153e67bdb9619f84d997b8d7157c0bdef357e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_ope.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"tegra210_mbdrc.h\"\n#include \"tegra210_ope.h\"\n#include \"tegra210_peq.h\"\n#include \"tegra_cif.h\"\n\nstatic const struct reg_default tegra210_ope_reg_defaults[] = {\n\t{ TEGRA210_OPE_RX_INT_MASK, 0x00000001},\n\t{ TEGRA210_OPE_RX_CIF_CTRL, 0x00007700},\n\t{ TEGRA210_OPE_TX_INT_MASK, 0x00000001},\n\t{ TEGRA210_OPE_TX_CIF_CTRL, 0x00007700},\n\t{ TEGRA210_OPE_CG, 0x1},\n};\n\nstatic int tegra210_ope_set_audio_cif(struct tegra210_ope *ope,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      unsigned int reg)\n{\n\tint channels, audio_bits;\n\tstruct tegra_cif_conf cif_conf;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tchannels = params_channels(params);\n\tif (channels < 2)\n\t\treturn -EINVAL;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcif_conf.audio_ch = channels;\n\tcif_conf.client_ch = channels;\n\tcif_conf.audio_bits = audio_bits;\n\tcif_conf.client_bits = audio_bits;\n\n\ttegra_set_cif(ope->regmap, reg, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra210_ope_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->dev;\n\tstruct tegra210_ope *ope = snd_soc_dai_get_drvdata(dai);\n\tint err;\n\n\t \n\terr = tegra210_ope_set_audio_cif(ope, params,\n\t\t\t\t\t TEGRA210_OPE_RX_CIF_CTRL);\n\tif (err) {\n\t\tdev_err(dev, \"Can't set OPE RX CIF: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra210_ope_set_audio_cif(ope, params,\n\t\t\t\t\t TEGRA210_OPE_TX_CIF_CTRL);\n\tif (err) {\n\t\tdev_err(dev, \"Can't set OPE TX CIF: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra210_mbdrc_hw_params(dai->component);\n\n\treturn err;\n}\n\nstatic int tegra210_ope_component_probe(struct snd_soc_component *cmpnt)\n{\n\tstruct tegra210_ope *ope = dev_get_drvdata(cmpnt->dev);\n\n\ttegra210_peq_component_init(cmpnt);\n\ttegra210_mbdrc_component_init(cmpnt);\n\n\t \n\tsnd_soc_component_init_regmap(cmpnt, ope->regmap);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tegra210_ope_dai_ops = {\n\t.hw_params\t= tegra210_ope_hw_params,\n};\n\nstatic struct snd_soc_dai_driver tegra210_ope_dais[] = {\n\t{\n\t\t.name = \"OPE-RX-CIF\",\n\t\t.playback = {\n\t\t\t.stream_name = \"RX-CIF-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"RX-CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t},\n\t{\n\t\t.name = \"OPE-TX-CIF\",\n\t\t.playback = {\n\t\t\t.stream_name = \"TX-CIF-Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"TX-CIF-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &tegra210_ope_dai_ops,\n\t}\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_ope_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"RX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX\", NULL, 0, TEGRA210_OPE_ENABLE,\n\t\t\t     TEGRA210_OPE_EN_SHIFT, 0),\n};\n\n#define OPE_ROUTES(sname)\t\t\t\t\t\\\n\t{ \"RX XBAR-\" sname,\tNULL,\t\"XBAR-TX\" },\t\t\\\n\t{ \"RX-CIF-\" sname,\tNULL,\t\"RX XBAR-\" sname },\t\\\n\t{ \"RX\",\t\t\tNULL,\t\"RX-CIF-\" sname },\t\\\n\t{ \"TX-CIF-\" sname,\tNULL,\t\"TX\" },\t\t\t\\\n\t{ \"TX XBAR-\" sname,\tNULL,\t\"TX-CIF-\" sname },\t\\\n\t{ \"XBAR-RX\",\t\tNULL,\t\"TX XBAR-\" sname }\n\nstatic const struct snd_soc_dapm_route tegra210_ope_routes[] = {\n\t{ \"TX\", NULL, \"RX\" },\n\tOPE_ROUTES(\"Playback\"),\n\tOPE_ROUTES(\"Capture\"),\n};\n\nstatic const char * const tegra210_ope_data_dir_text[] = {\n\t\"MBDRC to PEQ\",\n\t\"PEQ to MBDRC\"\n};\n\nstatic const struct soc_enum tegra210_ope_data_dir_enum =\n\tSOC_ENUM_SINGLE(TEGRA210_OPE_DIR, TEGRA210_OPE_DIR_SHIFT,\n\t\t\t2, tegra210_ope_data_dir_text);\n\nstatic int tegra210_ope_get_data_dir(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_ope *ope = snd_soc_component_get_drvdata(cmpnt);\n\n\tucontrol->value.enumerated.item[0] = ope->data_dir;\n\n\treturn 0;\n}\n\nstatic int tegra210_ope_put_data_dir(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_ope *ope = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == ope->data_dir)\n\t\treturn 0;\n\n\tope->data_dir = value;\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new tegra210_ope_controls[] = {\n\tSOC_ENUM_EXT(\"Data Flow Direction\", tegra210_ope_data_dir_enum,\n\t\t     tegra210_ope_get_data_dir, tegra210_ope_put_data_dir),\n};\n\nstatic const struct snd_soc_component_driver tegra210_ope_cmpnt = {\n\t.probe\t\t\t= tegra210_ope_component_probe,\n\t.dapm_widgets\t\t= tegra210_ope_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_ope_widgets),\n\t.dapm_routes\t\t= tegra210_ope_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_ope_routes),\n\t.controls\t\t= tegra210_ope_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_ope_controls),\n};\n\nstatic bool tegra210_ope_wr_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_OPE_RX_INT_MASK ... TEGRA210_OPE_RX_CIF_CTRL:\n\tcase TEGRA210_OPE_TX_INT_MASK ... TEGRA210_OPE_TX_CIF_CTRL:\n\tcase TEGRA210_OPE_ENABLE ... TEGRA210_OPE_CG:\n\tcase TEGRA210_OPE_DIR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_ope_rd_reg(struct device *dev, unsigned int reg)\n{\n\tif (tegra210_ope_wr_reg(dev, reg))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase TEGRA210_OPE_RX_STATUS:\n\tcase TEGRA210_OPE_RX_INT_STATUS:\n\tcase TEGRA210_OPE_TX_STATUS:\n\tcase TEGRA210_OPE_TX_INT_STATUS:\n\tcase TEGRA210_OPE_STATUS:\n\tcase TEGRA210_OPE_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_ope_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_OPE_RX_STATUS:\n\tcase TEGRA210_OPE_RX_INT_STATUS:\n\tcase TEGRA210_OPE_TX_STATUS:\n\tcase TEGRA210_OPE_TX_INT_STATUS:\n\tcase TEGRA210_OPE_SOFT_RESET:\n\tcase TEGRA210_OPE_STATUS:\n\tcase TEGRA210_OPE_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tegra210_ope_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_OPE_DIR,\n\t.writeable_reg\t\t= tegra210_ope_wr_reg,\n\t.readable_reg\t\t= tegra210_ope_rd_reg,\n\t.volatile_reg\t\t= tegra210_ope_volatile_reg,\n\t.reg_defaults\t\t= tegra210_ope_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_ope_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic int tegra210_ope_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_ope *ope;\n\tvoid __iomem *regs;\n\tint err;\n\n\tope = devm_kzalloc(dev, sizeof(*ope), GFP_KERNEL);\n\tif (!ope)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tope->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t    &tegra210_ope_regmap_config);\n\tif (IS_ERR(ope->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(ope->regmap);\n\t}\n\n\tregcache_cache_only(ope->regmap, true);\n\n\tdev_set_drvdata(dev, ope);\n\n\terr = tegra210_peq_regmap_init(pdev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"PEQ init failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = tegra210_mbdrc_regmap_init(pdev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"MBDRC init failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_ope_cmpnt,\n\t\t\t\t\t      tegra210_ope_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_ope_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register OPE component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_ope_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int __maybe_unused tegra210_ope_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_ope *ope = dev_get_drvdata(dev);\n\n\ttegra210_peq_save(ope->peq_regmap, ope->peq_biquad_gains,\n\t\t\t  ope->peq_biquad_shifts);\n\n\tregcache_cache_only(ope->mbdrc_regmap, true);\n\tregcache_cache_only(ope->peq_regmap, true);\n\tregcache_cache_only(ope->regmap, true);\n\n\tregcache_mark_dirty(ope->regmap);\n\tregcache_mark_dirty(ope->peq_regmap);\n\tregcache_mark_dirty(ope->mbdrc_regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_ope_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_ope *ope = dev_get_drvdata(dev);\n\n\tregcache_cache_only(ope->regmap, false);\n\tregcache_cache_only(ope->peq_regmap, false);\n\tregcache_cache_only(ope->mbdrc_regmap, false);\n\n\tregcache_sync(ope->regmap);\n\tregcache_sync(ope->peq_regmap);\n\tregcache_sync(ope->mbdrc_regmap);\n\n\ttegra210_peq_restore(ope->peq_regmap, ope->peq_biquad_gains,\n\t\t\t     ope->peq_biquad_shifts);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra210_ope_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_ope_runtime_suspend,\n\t\t\t   tegra210_ope_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct of_device_id tegra210_ope_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-ope\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_ope_of_match);\n\nstatic struct platform_driver tegra210_ope_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-ope\",\n\t\t.of_match_table = tegra210_ope_of_match,\n\t\t.pm = &tegra210_ope_pm_ops,\n\t},\n\t.probe = tegra210_ope_probe,\n\t.remove_new = tegra210_ope_remove,\n};\nmodule_platform_driver(tegra210_ope_driver)\n\nMODULE_AUTHOR(\"Sumit Bhattacharya <sumitb@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 OPE ASoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}