{
  "module_name": "tegra20_ac97.c",
  "hash_id": "268b3c7e8ae2f4435d0a7c98c40782fb89ec88f7582a2cb55d9dae157895c02b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra20_ac97.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"tegra20_ac97.h\"\n\n#define DRV_NAME \"tegra20-ac97\"\n\nstatic struct tegra20_ac97 *workdata;\n\nstatic void tegra20_ac97_codec_reset(struct snd_ac97 *ac97)\n{\n\tu32 readback;\n\tunsigned long timeout;\n\n\t \n\tgpio_set_value(workdata->reset_gpio, 0);\n\tudelay(2);\n\n\tgpio_set_value(workdata->reset_gpio, 1);\n\tudelay(2);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\tdo {\n\t\tregmap_read(workdata->regmap, TEGRA20_AC97_STATUS1, &readback);\n\t\tif (readback & TEGRA20_AC97_STATUS1_CODEC1_RDY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (!time_after(jiffies, timeout));\n}\n\nstatic void tegra20_ac97_codec_warm_reset(struct snd_ac97 *ac97)\n{\n\tu32 readback;\n\tunsigned long timeout;\n\n\t \n\tgpio_request(workdata->sync_gpio, \"codec-sync\");\n\n\tgpio_direction_output(workdata->sync_gpio, 1);\n\n\tudelay(2);\n\tgpio_set_value(workdata->sync_gpio, 0);\n\tudelay(2);\n\tgpio_free(workdata->sync_gpio);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\tdo {\n\t\tregmap_read(workdata->regmap, TEGRA20_AC97_STATUS1, &readback);\n\t\tif (readback & TEGRA20_AC97_STATUS1_CODEC1_RDY)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (!time_after(jiffies, timeout));\n}\n\nstatic unsigned short tegra20_ac97_codec_read(struct snd_ac97 *ac97_snd,\n\t\t\t\t\t      unsigned short reg)\n{\n\tu32 readback;\n\tunsigned long timeout;\n\n\tregmap_write(workdata->regmap, TEGRA20_AC97_CMD,\n\t\t     (((reg | 0x80) << TEGRA20_AC97_CMD_CMD_ADDR_SHIFT) &\n\t\t      TEGRA20_AC97_CMD_CMD_ADDR_MASK) |\n\t\t     TEGRA20_AC97_CMD_BUSY);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\tdo {\n\t\tregmap_read(workdata->regmap, TEGRA20_AC97_STATUS1, &readback);\n\t\tif (readback & TEGRA20_AC97_STATUS1_STA_VALID1)\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (!time_after(jiffies, timeout));\n\n\treturn ((readback & TEGRA20_AC97_STATUS1_STA_DATA1_MASK) >>\n\t\tTEGRA20_AC97_STATUS1_STA_DATA1_SHIFT);\n}\n\nstatic void tegra20_ac97_codec_write(struct snd_ac97 *ac97_snd,\n\t\t\t\t     unsigned short reg, unsigned short val)\n{\n\tu32 readback;\n\tunsigned long timeout;\n\n\tregmap_write(workdata->regmap, TEGRA20_AC97_CMD,\n\t\t     ((reg << TEGRA20_AC97_CMD_CMD_ADDR_SHIFT) &\n\t\t      TEGRA20_AC97_CMD_CMD_ADDR_MASK) |\n\t\t     ((val << TEGRA20_AC97_CMD_CMD_DATA_SHIFT) &\n\t\t      TEGRA20_AC97_CMD_CMD_DATA_MASK) |\n\t\t     TEGRA20_AC97_CMD_BUSY);\n\n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\tdo {\n\t\tregmap_read(workdata->regmap, TEGRA20_AC97_CMD, &readback);\n\t\tif (!(readback & TEGRA20_AC97_CMD_BUSY))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t} while (!time_after(jiffies, timeout));\n}\n\nstatic struct snd_ac97_bus_ops tegra20_ac97_ops = {\n\t.read\t\t= tegra20_ac97_codec_read,\n\t.write\t\t= tegra20_ac97_codec_write,\n\t.reset\t\t= tegra20_ac97_codec_reset,\n\t.warm_reset\t= tegra20_ac97_codec_warm_reset,\n};\n\nstatic inline void tegra20_ac97_start_playback(struct tegra20_ac97 *ac97)\n{\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_FIFO1_SCR,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_PB_QRT_MT_EN,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_PB_QRT_MT_EN);\n\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_CTRL,\n\t\t\t   TEGRA20_AC97_CTRL_PCM_DAC_EN |\n\t\t\t   TEGRA20_AC97_CTRL_STM_EN,\n\t\t\t   TEGRA20_AC97_CTRL_PCM_DAC_EN |\n\t\t\t   TEGRA20_AC97_CTRL_STM_EN);\n}\n\nstatic inline void tegra20_ac97_stop_playback(struct tegra20_ac97 *ac97)\n{\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_FIFO1_SCR,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_PB_QRT_MT_EN, 0);\n\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_CTRL,\n\t\t\t   TEGRA20_AC97_CTRL_PCM_DAC_EN, 0);\n}\n\nstatic inline void tegra20_ac97_start_capture(struct tegra20_ac97 *ac97)\n{\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_FIFO1_SCR,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_REC_FULL_EN,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_REC_FULL_EN);\n}\n\nstatic inline void tegra20_ac97_stop_capture(struct tegra20_ac97 *ac97)\n{\n\tregmap_update_bits(ac97->regmap, TEGRA20_AC97_FIFO1_SCR,\n\t\t\t   TEGRA20_AC97_FIFO_SCR_REC_FULL_EN, 0);\n}\n\nstatic int tegra20_ac97_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct tegra20_ac97 *ac97 = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ttegra20_ac97_start_playback(ac97);\n\t\telse\n\t\t\ttegra20_ac97_start_capture(ac97);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\ttegra20_ac97_stop_playback(ac97);\n\t\telse\n\t\t\ttegra20_ac97_stop_capture(ac97);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra20_ac97_probe(struct snd_soc_dai *dai)\n{\n\tstruct tegra20_ac97 *ac97 = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai,\t&ac97->playback_dma_data,\n\t\t\t\t\t&ac97->capture_dma_data);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tegra20_ac97_dai_ops = {\n\t.probe\t\t= tegra20_ac97_probe,\n\t.trigger\t= tegra20_ac97_trigger,\n};\n\nstatic struct snd_soc_dai_driver tegra20_ac97_dai = {\n\t.name = \"tegra-ac97-pcm\",\n\t.playback = {\n\t\t.stream_name = \"PCM Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"PCM Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &tegra20_ac97_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver tegra20_ac97_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic bool tegra20_ac97_wr_rd_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA20_AC97_CTRL:\n\tcase TEGRA20_AC97_CMD:\n\tcase TEGRA20_AC97_STATUS1:\n\tcase TEGRA20_AC97_FIFO1_SCR:\n\tcase TEGRA20_AC97_FIFO_TX1:\n\tcase TEGRA20_AC97_FIFO_RX1:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool tegra20_ac97_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA20_AC97_STATUS1:\n\tcase TEGRA20_AC97_FIFO1_SCR:\n\tcase TEGRA20_AC97_FIFO_TX1:\n\tcase TEGRA20_AC97_FIFO_RX1:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool tegra20_ac97_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA20_AC97_FIFO_TX1:\n\tcase TEGRA20_AC97_FIFO_RX1:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra20_ac97_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = TEGRA20_AC97_FIFO_RX1,\n\t.writeable_reg = tegra20_ac97_wr_rd_reg,\n\t.readable_reg = tegra20_ac97_wr_rd_reg,\n\t.volatile_reg = tegra20_ac97_volatile_reg,\n\t.precious_reg = tegra20_ac97_precious_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int tegra20_ac97_platform_probe(struct platform_device *pdev)\n{\n\tstruct tegra20_ac97 *ac97;\n\tstruct resource *mem;\n\tvoid __iomem *regs;\n\tint ret = 0;\n\n\tac97 = devm_kzalloc(&pdev->dev, sizeof(struct tegra20_ac97),\n\t\t\t    GFP_KERNEL);\n\tif (!ac97) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev_set_drvdata(&pdev->dev, ac97);\n\n\tac97->reset = devm_reset_control_get_exclusive(&pdev->dev, \"ac97\");\n\tif (IS_ERR(ac97->reset)) {\n\t\tdev_err(&pdev->dev, \"Can't retrieve ac97 reset\\n\");\n\t\tret = PTR_ERR(ac97->reset);\n\t\tgoto err;\n\t}\n\n\tac97->clk_ac97 = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ac97->clk_ac97)) {\n\t\tdev_err(&pdev->dev, \"Can't retrieve ac97 clock\\n\");\n\t\tret = PTR_ERR(ac97->clk_ac97);\n\t\tgoto err;\n\t}\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\tgoto err_clk_put;\n\t}\n\n\tac97->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t    &tegra20_ac97_regmap_config);\n\tif (IS_ERR(ac97->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\tret = PTR_ERR(ac97->regmap);\n\t\tgoto err_clk_put;\n\t}\n\n\tac97->reset_gpio = of_get_named_gpio(pdev->dev.of_node,\n\t\t\t\t\t     \"nvidia,codec-reset-gpio\", 0);\n\tif (gpio_is_valid(ac97->reset_gpio)) {\n\t\tret = devm_gpio_request_one(&pdev->dev, ac97->reset_gpio,\n\t\t\t\t\t    GPIOF_OUT_INIT_HIGH, \"codec-reset\");\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not get codec-reset GPIO\\n\");\n\t\t\tgoto err_clk_put;\n\t\t}\n\t} else {\n\t\tdev_err(&pdev->dev, \"no codec-reset GPIO supplied\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_put;\n\t}\n\n\tac97->sync_gpio = of_get_named_gpio(pdev->dev.of_node,\n\t\t\t\t\t    \"nvidia,codec-sync-gpio\", 0);\n\tif (!gpio_is_valid(ac97->sync_gpio)) {\n\t\tdev_err(&pdev->dev, \"no codec-sync GPIO supplied\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clk_put;\n\t}\n\n\tac97->capture_dma_data.addr = mem->start + TEGRA20_AC97_FIFO_RX1;\n\tac97->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tac97->capture_dma_data.maxburst = 4;\n\n\tac97->playback_dma_data.addr = mem->start + TEGRA20_AC97_FIFO_TX1;\n\tac97->playback_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tac97->playback_dma_data.maxburst = 4;\n\n\tret = reset_control_assert(ac97->reset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to assert AC'97 reset: %d\\n\", ret);\n\t\tgoto err_clk_put;\n\t}\n\n\tret = clk_prepare_enable(ac97->clk_ac97);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"clk_enable failed: %d\\n\", ret);\n\t\tgoto err_clk_put;\n\t}\n\n\tusleep_range(10, 100);\n\n\tret = reset_control_deassert(ac97->reset);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to deassert AC'97 reset: %d\\n\", ret);\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tret = snd_soc_set_ac97_ops(&tegra20_ac97_ops);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to set AC'97 ops: %d\\n\", ret);\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tret = snd_soc_register_component(&pdev->dev, &tegra20_ac97_component,\n\t\t\t\t\t &tegra20_ac97_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register DAI: %d\\n\", ret);\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tret = tegra_pcm_platform_register(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register PCM: %d\\n\", ret);\n\t\tgoto err_unregister_component;\n\t}\n\n\t \n\tworkdata = ac97;\n\n\treturn 0;\n\nerr_unregister_component:\n\tsnd_soc_unregister_component(&pdev->dev);\nerr_clk_disable_unprepare:\n\tclk_disable_unprepare(ac97->clk_ac97);\nerr_clk_put:\nerr:\n\tsnd_soc_set_ac97_ops(NULL);\n\treturn ret;\n}\n\nstatic void tegra20_ac97_platform_remove(struct platform_device *pdev)\n{\n\tstruct tegra20_ac97 *ac97 = dev_get_drvdata(&pdev->dev);\n\n\ttegra_pcm_platform_unregister(&pdev->dev);\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\tclk_disable_unprepare(ac97->clk_ac97);\n\n\tsnd_soc_set_ac97_ops(NULL);\n}\n\nstatic const struct of_device_id tegra20_ac97_of_match[] = {\n\t{ .compatible = \"nvidia,tegra20-ac97\", },\n\t{},\n};\n\nstatic struct platform_driver tegra20_ac97_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = tegra20_ac97_of_match,\n\t},\n\t.probe = tegra20_ac97_platform_probe,\n\t.remove_new = tegra20_ac97_platform_remove,\n};\nmodule_platform_driver(tegra20_ac97_driver);\n\nMODULE_AUTHOR(\"Lucas Stach\");\nMODULE_DESCRIPTION(\"Tegra20 AC97 ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_DEVICE_TABLE(of, tegra20_ac97_of_match);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}