{
  "module_name": "tegra210_admaif.c",
  "hash_id": "e3ec085fa395a29662164944f17e9bab522a13ae866c3aae1e617300e0f52f1a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_admaif.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include \"tegra210_admaif.h\"\n#include \"tegra_cif.h\"\n#include \"tegra_pcm.h\"\n\n#define CH_REG(offset, reg, id)\t\t\t\t\t\t       \\\n\t((offset) + (reg) + (TEGRA_ADMAIF_CHANNEL_REG_STRIDE * (id)))\n\n#define CH_TX_REG(reg, id) CH_REG(admaif->soc_data->tx_base, reg, id)\n\n#define CH_RX_REG(reg, id) CH_REG(admaif->soc_data->rx_base, reg, id)\n\n#define REG_DEFAULTS(id, rx_ctrl, tx_ctrl, tx_base, rx_base)\t\t       \\\n\t{ CH_REG(rx_base, TEGRA_ADMAIF_RX_INT_MASK, id), 0x00000001 },\t       \\\n\t{ CH_REG(rx_base, TEGRA_ADMAIF_CH_ACIF_RX_CTRL, id), 0x00007700 },     \\\n\t{ CH_REG(rx_base, TEGRA_ADMAIF_RX_FIFO_CTRL, id), rx_ctrl },\t       \\\n\t{ CH_REG(tx_base, TEGRA_ADMAIF_TX_INT_MASK, id), 0x00000001 },\t       \\\n\t{ CH_REG(tx_base, TEGRA_ADMAIF_CH_ACIF_TX_CTRL, id), 0x00007700 },     \\\n\t{ CH_REG(tx_base, TEGRA_ADMAIF_TX_FIFO_CTRL, id), tx_ctrl }\n\n#define ADMAIF_REG_DEFAULTS(id, chip)\t\t\t\t\t       \\\n\tREG_DEFAULTS((id) - 1,\t\t\t\t\t\t       \\\n\t\tchip ## _ADMAIF_RX ## id ## _FIFO_CTRL_REG_DEFAULT,\t       \\\n\t\tchip ## _ADMAIF_TX ## id ## _FIFO_CTRL_REG_DEFAULT,\t       \\\n\t\tchip ## _ADMAIF_TX_BASE,\t\t\t\t       \\\n\t\tchip ## _ADMAIF_RX_BASE)\n\nstatic const struct reg_default tegra186_admaif_reg_defaults[] = {\n\t{(TEGRA_ADMAIF_GLOBAL_CG_0 + TEGRA186_ADMAIF_GLOBAL_BASE), 0x00000003},\n\tADMAIF_REG_DEFAULTS(1, TEGRA186),\n\tADMAIF_REG_DEFAULTS(2, TEGRA186),\n\tADMAIF_REG_DEFAULTS(3, TEGRA186),\n\tADMAIF_REG_DEFAULTS(4, TEGRA186),\n\tADMAIF_REG_DEFAULTS(5, TEGRA186),\n\tADMAIF_REG_DEFAULTS(6, TEGRA186),\n\tADMAIF_REG_DEFAULTS(7, TEGRA186),\n\tADMAIF_REG_DEFAULTS(8, TEGRA186),\n\tADMAIF_REG_DEFAULTS(9, TEGRA186),\n\tADMAIF_REG_DEFAULTS(10, TEGRA186),\n\tADMAIF_REG_DEFAULTS(11, TEGRA186),\n\tADMAIF_REG_DEFAULTS(12, TEGRA186),\n\tADMAIF_REG_DEFAULTS(13, TEGRA186),\n\tADMAIF_REG_DEFAULTS(14, TEGRA186),\n\tADMAIF_REG_DEFAULTS(15, TEGRA186),\n\tADMAIF_REG_DEFAULTS(16, TEGRA186),\n\tADMAIF_REG_DEFAULTS(17, TEGRA186),\n\tADMAIF_REG_DEFAULTS(18, TEGRA186),\n\tADMAIF_REG_DEFAULTS(19, TEGRA186),\n\tADMAIF_REG_DEFAULTS(20, TEGRA186)\n};\n\nstatic const struct reg_default tegra210_admaif_reg_defaults[] = {\n\t{(TEGRA_ADMAIF_GLOBAL_CG_0 + TEGRA210_ADMAIF_GLOBAL_BASE), 0x00000003},\n\tADMAIF_REG_DEFAULTS(1, TEGRA210),\n\tADMAIF_REG_DEFAULTS(2, TEGRA210),\n\tADMAIF_REG_DEFAULTS(3, TEGRA210),\n\tADMAIF_REG_DEFAULTS(4, TEGRA210),\n\tADMAIF_REG_DEFAULTS(5, TEGRA210),\n\tADMAIF_REG_DEFAULTS(6, TEGRA210),\n\tADMAIF_REG_DEFAULTS(7, TEGRA210),\n\tADMAIF_REG_DEFAULTS(8, TEGRA210),\n\tADMAIF_REG_DEFAULTS(9, TEGRA210),\n\tADMAIF_REG_DEFAULTS(10, TEGRA210)\n};\n\nstatic bool tegra_admaif_wr_reg(struct device *dev, unsigned int reg)\n{\n\tstruct tegra_admaif *admaif = dev_get_drvdata(dev);\n\tunsigned int ch_stride = TEGRA_ADMAIF_CHANNEL_REG_STRIDE;\n\tunsigned int num_ch = admaif->soc_data->num_ch;\n\tunsigned int rx_base = admaif->soc_data->rx_base;\n\tunsigned int tx_base = admaif->soc_data->tx_base;\n\tunsigned int global_base = admaif->soc_data->global_base;\n\tunsigned int reg_max = admaif->soc_data->regmap_conf->max_register;\n\tunsigned int rx_max = rx_base + (num_ch * ch_stride);\n\tunsigned int tx_max = tx_base + (num_ch * ch_stride);\n\n\tif ((reg >= rx_base) && (reg < rx_max)) {\n\t\treg = (reg - rx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_RX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_FIFO_CTRL) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_SOFT_RESET) ||\n\t\t    (reg == TEGRA_ADMAIF_CH_ACIF_RX_CTRL))\n\t\t\treturn true;\n\t} else if ((reg >= tx_base) && (reg < tx_max)) {\n\t\treg = (reg - tx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_TX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_FIFO_CTRL) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_SOFT_RESET) ||\n\t\t    (reg == TEGRA_ADMAIF_CH_ACIF_TX_CTRL))\n\t\t\treturn true;\n\t} else if ((reg >= global_base) && (reg < reg_max)) {\n\t\tif (reg == (global_base + TEGRA_ADMAIF_GLOBAL_ENABLE))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool tegra_admaif_rd_reg(struct device *dev, unsigned int reg)\n{\n\tstruct tegra_admaif *admaif = dev_get_drvdata(dev);\n\tunsigned int ch_stride = TEGRA_ADMAIF_CHANNEL_REG_STRIDE;\n\tunsigned int num_ch = admaif->soc_data->num_ch;\n\tunsigned int rx_base = admaif->soc_data->rx_base;\n\tunsigned int tx_base = admaif->soc_data->tx_base;\n\tunsigned int global_base = admaif->soc_data->global_base;\n\tunsigned int reg_max = admaif->soc_data->regmap_conf->max_register;\n\tunsigned int rx_max = rx_base + (num_ch * ch_stride);\n\tunsigned int tx_max = tx_base + (num_ch * ch_stride);\n\n\tif ((reg >= rx_base) && (reg < rx_max)) {\n\t\treg = (reg - rx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_RX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_INT_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_FIFO_CTRL) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_SOFT_RESET) ||\n\t\t    (reg == TEGRA_ADMAIF_CH_ACIF_RX_CTRL))\n\t\t\treturn true;\n\t} else if ((reg >= tx_base) && (reg < tx_max)) {\n\t\treg = (reg - tx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_TX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_INT_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_FIFO_CTRL) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_SOFT_RESET) ||\n\t\t    (reg == TEGRA_ADMAIF_CH_ACIF_TX_CTRL))\n\t\t\treturn true;\n\t} else if ((reg >= global_base) && (reg < reg_max)) {\n\t\tif ((reg == (global_base + TEGRA_ADMAIF_GLOBAL_ENABLE)) ||\n\t\t    (reg == (global_base + TEGRA_ADMAIF_GLOBAL_CG_0)) ||\n\t\t    (reg == (global_base + TEGRA_ADMAIF_GLOBAL_STATUS)) ||\n\t\t    (reg == (global_base +\n\t\t\t\tTEGRA_ADMAIF_GLOBAL_RX_ENABLE_STATUS)) ||\n\t\t    (reg == (global_base +\n\t\t\t\tTEGRA_ADMAIF_GLOBAL_TX_ENABLE_STATUS)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool tegra_admaif_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tstruct tegra_admaif *admaif = dev_get_drvdata(dev);\n\tunsigned int ch_stride = TEGRA_ADMAIF_CHANNEL_REG_STRIDE;\n\tunsigned int num_ch = admaif->soc_data->num_ch;\n\tunsigned int rx_base = admaif->soc_data->rx_base;\n\tunsigned int tx_base = admaif->soc_data->tx_base;\n\tunsigned int global_base = admaif->soc_data->global_base;\n\tunsigned int reg_max = admaif->soc_data->regmap_conf->max_register;\n\tunsigned int rx_max = rx_base + (num_ch * ch_stride);\n\tunsigned int tx_max = tx_base + (num_ch * ch_stride);\n\n\tif ((reg >= rx_base) && (reg < rx_max)) {\n\t\treg = (reg - rx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_RX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_INT_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_RX_SOFT_RESET))\n\t\t\treturn true;\n\t} else if ((reg >= tx_base) && (reg < tx_max)) {\n\t\treg = (reg - tx_base) % ch_stride;\n\t\tif ((reg == TEGRA_ADMAIF_TX_ENABLE) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_INT_STATUS) ||\n\t\t    (reg == TEGRA_ADMAIF_TX_SOFT_RESET))\n\t\t\treturn true;\n\t} else if ((reg >= global_base) && (reg < reg_max)) {\n\t\tif ((reg == (global_base + TEGRA_ADMAIF_GLOBAL_STATUS)) ||\n\t\t    (reg == (global_base +\n\t\t\t\tTEGRA_ADMAIF_GLOBAL_RX_ENABLE_STATUS)) ||\n\t\t    (reg == (global_base +\n\t\t\t\tTEGRA_ADMAIF_GLOBAL_TX_ENABLE_STATUS)))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra210_admaif_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_ADMAIF_LAST_REG,\n\t.writeable_reg\t\t= tegra_admaif_wr_reg,\n\t.readable_reg\t\t= tegra_admaif_rd_reg,\n\t.volatile_reg\t\t= tegra_admaif_volatile_reg,\n\t.reg_defaults\t\t= tegra210_admaif_reg_defaults,\n\t.num_reg_defaults\t= TEGRA210_ADMAIF_CHANNEL_COUNT * 6 + 1,\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config tegra186_admaif_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA186_ADMAIF_LAST_REG,\n\t.writeable_reg\t\t= tegra_admaif_wr_reg,\n\t.readable_reg\t\t= tegra_admaif_rd_reg,\n\t.volatile_reg\t\t= tegra_admaif_volatile_reg,\n\t.reg_defaults\t\t= tegra186_admaif_reg_defaults,\n\t.num_reg_defaults\t= TEGRA186_ADMAIF_CHANNEL_COUNT * 6 + 1,\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic int __maybe_unused tegra_admaif_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_admaif *admaif = dev_get_drvdata(dev);\n\n\tregcache_cache_only(admaif->regmap, true);\n\tregcache_mark_dirty(admaif->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_admaif_runtime_resume(struct device *dev)\n{\n\tstruct tegra_admaif *admaif = dev_get_drvdata(dev);\n\n\tregcache_cache_only(admaif->regmap, false);\n\tregcache_sync(admaif->regmap);\n\n\treturn 0;\n}\n\nstatic int tegra_admaif_set_pack_mode(struct regmap *map, unsigned int reg,\n\t\t\t\t      int valid_bit)\n{\n\tswitch (valid_bit) {\n\tcase DATA_8BIT:\n\t\tregmap_update_bits(map, reg, PACK8_EN_MASK, PACK8_EN);\n\t\tregmap_update_bits(map, reg, PACK16_EN_MASK, 0);\n\t\tbreak;\n\tcase DATA_16BIT:\n\t\tregmap_update_bits(map, reg, PACK16_EN_MASK, PACK16_EN);\n\t\tregmap_update_bits(map, reg, PACK8_EN_MASK, 0);\n\t\tbreak;\n\tcase DATA_32BIT:\n\t\tregmap_update_bits(map, reg, PACK16_EN_MASK, 0);\n\t\tregmap_update_bits(map, reg, PACK8_EN_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_admaif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->dev;\n\tstruct tegra_admaif *admaif = snd_soc_dai_get_drvdata(dai);\n\tstruct tegra_cif_conf cif_conf;\n\tunsigned int reg, path;\n\tint valid_bit, channels;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_8;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_8;\n\t\tvalid_bit = DATA_8BIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_16;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_16;\n\t\tvalid_bit = DATA_16BIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tcif_conf.audio_bits = TEGRA_ACIF_BITS_32;\n\t\tcif_conf.client_bits = TEGRA_ACIF_BITS_32;\n\t\tvalid_bit  = DATA_32BIT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported format!\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tchannels = params_channels(params);\n\tcif_conf.client_ch = channels;\n\tcif_conf.audio_ch = channels;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tpath = ADMAIF_TX_PATH;\n\t\treg = CH_TX_REG(TEGRA_ADMAIF_CH_ACIF_TX_CTRL, dai->id);\n\t} else {\n\t\tpath = ADMAIF_RX_PATH;\n\t\treg = CH_RX_REG(TEGRA_ADMAIF_CH_ACIF_RX_CTRL, dai->id);\n\t}\n\n\tcif_conf.mono_conv = admaif->mono_to_stereo[path][dai->id];\n\tcif_conf.stereo_conv = admaif->stereo_to_mono[path][dai->id];\n\n\ttegra_admaif_set_pack_mode(admaif->regmap, reg, valid_bit);\n\n\ttegra_set_cif(admaif->regmap, reg, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra_admaif_start(struct snd_soc_dai *dai, int direction)\n{\n\tstruct tegra_admaif *admaif = snd_soc_dai_get_drvdata(dai);\n\tunsigned int reg, mask, val;\n\n\tswitch (direction) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tmask = TX_ENABLE_MASK;\n\t\tval = TX_ENABLE;\n\t\treg = CH_TX_REG(TEGRA_ADMAIF_TX_ENABLE, dai->id);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tmask = RX_ENABLE_MASK;\n\t\tval = RX_ENABLE;\n\t\treg = CH_RX_REG(TEGRA_ADMAIF_RX_ENABLE, dai->id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(admaif->regmap, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int tegra_admaif_stop(struct snd_soc_dai *dai, int direction)\n{\n\tstruct tegra_admaif *admaif = snd_soc_dai_get_drvdata(dai);\n\tunsigned int enable_reg, status_reg, reset_reg, mask, val;\n\tchar *dir_name;\n\tint err, enable;\n\n\tswitch (direction) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tmask = TX_ENABLE_MASK;\n\t\tenable = TX_ENABLE;\n\t\tdir_name = \"TX\";\n\t\tenable_reg = CH_TX_REG(TEGRA_ADMAIF_TX_ENABLE, dai->id);\n\t\tstatus_reg = CH_TX_REG(TEGRA_ADMAIF_TX_STATUS, dai->id);\n\t\treset_reg = CH_TX_REG(TEGRA_ADMAIF_TX_SOFT_RESET, dai->id);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tmask = RX_ENABLE_MASK;\n\t\tenable = RX_ENABLE;\n\t\tdir_name = \"RX\";\n\t\tenable_reg = CH_RX_REG(TEGRA_ADMAIF_RX_ENABLE, dai->id);\n\t\tstatus_reg = CH_RX_REG(TEGRA_ADMAIF_RX_STATUS, dai->id);\n\t\treset_reg = CH_RX_REG(TEGRA_ADMAIF_RX_SOFT_RESET, dai->id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_update_bits(admaif->regmap, enable_reg, mask, ~enable);\n\n\t \n\terr = regmap_read_poll_timeout_atomic(admaif->regmap, status_reg, val,\n\t\t\t\t\t      !(val & enable), 10, 10000);\n\tif (err < 0)\n\t\tdev_warn(dai->dev, \"timeout: failed to disable ADMAIF%d_%s\\n\",\n\t\t\t dai->id + 1, dir_name);\n\n\t \n\tregmap_update_bits(admaif->regmap, reset_reg, SW_RESET_MASK, SW_RESET);\n\n\t \n\terr = regmap_read_poll_timeout_atomic(admaif->regmap, reset_reg, val,\n\t\t\t\t\t      !(val & SW_RESET_MASK & SW_RESET),\n\t\t\t\t\t      10, 10000);\n\tif (err) {\n\t\tdev_err(dai->dev, \"timeout: SW reset failed for ADMAIF%d_%s\\n\",\n\t\t\tdai->id + 1, dir_name);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_admaif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tint err;\n\n\terr = snd_dmaengine_pcm_trigger(substream, cmd);\n\tif (err)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\treturn tegra_admaif_start(dai, substream->stream);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\treturn tegra_admaif_stop(dai, substream->stream);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int tegra210_admaif_pget_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\n\tucontrol->value.enumerated.item[0] =\n\t\tadmaif->mono_to_stereo[ADMAIF_TX_PATH][ec->reg];\n\n\treturn 0;\n}\n\nstatic int tegra210_admaif_pput_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == admaif->mono_to_stereo[ADMAIF_TX_PATH][ec->reg])\n\t\treturn 0;\n\n\tadmaif->mono_to_stereo[ADMAIF_TX_PATH][ec->reg] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_admaif_cget_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\n\tucontrol->value.enumerated.item[0] =\n\t\tadmaif->mono_to_stereo[ADMAIF_RX_PATH][ec->reg];\n\n\treturn 0;\n}\n\nstatic int tegra210_admaif_cput_mono_to_stereo(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == admaif->mono_to_stereo[ADMAIF_RX_PATH][ec->reg])\n\t\treturn 0;\n\n\tadmaif->mono_to_stereo[ADMAIF_RX_PATH][ec->reg] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_admaif_pget_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\n\tucontrol->value.enumerated.item[0] =\n\t\tadmaif->stereo_to_mono[ADMAIF_TX_PATH][ec->reg];\n\n\treturn 0;\n}\n\nstatic int tegra210_admaif_pput_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == admaif->stereo_to_mono[ADMAIF_TX_PATH][ec->reg])\n\t\treturn 0;\n\n\tadmaif->stereo_to_mono[ADMAIF_TX_PATH][ec->reg] = value;\n\n\treturn 1;\n}\n\nstatic int tegra210_admaif_cget_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\n\tucontrol->value.enumerated.item[0] =\n\t\tadmaif->stereo_to_mono[ADMAIF_RX_PATH][ec->reg];\n\n\treturn 0;\n}\n\nstatic int tegra210_admaif_cput_stereo_to_mono(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra_admaif *admaif = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *ec = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int value = ucontrol->value.enumerated.item[0];\n\n\tif (value == admaif->stereo_to_mono[ADMAIF_RX_PATH][ec->reg])\n\t\treturn 0;\n\n\tadmaif->stereo_to_mono[ADMAIF_RX_PATH][ec->reg] = value;\n\n\treturn 1;\n}\n\nstatic int tegra_admaif_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct tegra_admaif *admaif = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai,\t&admaif->playback_dma_data[dai->id],\n\t\t\t\t\t&admaif->capture_dma_data[dai->id]);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tegra_admaif_dai_ops = {\n\t.probe\t\t= tegra_admaif_dai_probe,\n\t.hw_params\t= tegra_admaif_hw_params,\n\t.trigger\t= tegra_admaif_trigger,\n};\n\n#define DAI(dai_name)\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = dai_name,\t\t\t\t\\\n\t\t.playback = {\t\t\t\t\t\\\n\t\t\t.stream_name = dai_name \" Playback\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\\\n\t\t\t.stream_name = dai_name \" Capture\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.ops = &tegra_admaif_dai_ops,\t\t\t\\\n\t}\n\nstatic struct snd_soc_dai_driver tegra210_admaif_cmpnt_dais[] = {\n\tDAI(\"ADMAIF1\"),\n\tDAI(\"ADMAIF2\"),\n\tDAI(\"ADMAIF3\"),\n\tDAI(\"ADMAIF4\"),\n\tDAI(\"ADMAIF5\"),\n\tDAI(\"ADMAIF6\"),\n\tDAI(\"ADMAIF7\"),\n\tDAI(\"ADMAIF8\"),\n\tDAI(\"ADMAIF9\"),\n\tDAI(\"ADMAIF10\"),\n};\n\nstatic struct snd_soc_dai_driver tegra186_admaif_cmpnt_dais[] = {\n\tDAI(\"ADMAIF1\"),\n\tDAI(\"ADMAIF2\"),\n\tDAI(\"ADMAIF3\"),\n\tDAI(\"ADMAIF4\"),\n\tDAI(\"ADMAIF5\"),\n\tDAI(\"ADMAIF6\"),\n\tDAI(\"ADMAIF7\"),\n\tDAI(\"ADMAIF8\"),\n\tDAI(\"ADMAIF9\"),\n\tDAI(\"ADMAIF10\"),\n\tDAI(\"ADMAIF11\"),\n\tDAI(\"ADMAIF12\"),\n\tDAI(\"ADMAIF13\"),\n\tDAI(\"ADMAIF14\"),\n\tDAI(\"ADMAIF15\"),\n\tDAI(\"ADMAIF16\"),\n\tDAI(\"ADMAIF17\"),\n\tDAI(\"ADMAIF18\"),\n\tDAI(\"ADMAIF19\"),\n\tDAI(\"ADMAIF20\"),\n};\n\nstatic const char * const tegra_admaif_stereo_conv_text[] = {\n\t\"CH0\", \"CH1\", \"AVG\",\n};\n\nstatic const char * const tegra_admaif_mono_conv_text[] = {\n\t\"Zero\", \"Copy\",\n};\n\n \n#define NV_SOC_ENUM_EXT(xname, xreg, xhandler_get, xhandler_put, xenum_text)   \\\n{\t\t\t\t\t\t\t\t\t       \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\t\t\t\t       \\\n\t.info = snd_soc_info_enum_double,\t\t\t\t       \\\n\t.name = xname,\t\t\t\t\t\t\t       \\\n\t.get = xhandler_get,\t\t\t\t\t\t       \\\n\t.put = xhandler_put,\t\t\t\t\t\t       \\\n\t.private_value = (unsigned long)&(struct soc_enum)\t\t       \\\n\t\tSOC_ENUM_SINGLE(xreg, 0, ARRAY_SIZE(xenum_text), xenum_text)   \\\n}\n\n#define TEGRA_ADMAIF_CIF_CTRL(reg)\t\t\t\t\t       \\\n\tNV_SOC_ENUM_EXT(\"ADMAIF\" #reg \" Playback Mono To Stereo\", reg - 1,     \\\n\t\t\ttegra210_admaif_pget_mono_to_stereo,\t\t       \\\n\t\t\ttegra210_admaif_pput_mono_to_stereo,\t\t       \\\n\t\t\ttegra_admaif_mono_conv_text),\t\t\t       \\\n\tNV_SOC_ENUM_EXT(\"ADMAIF\" #reg \" Playback Stereo To Mono\", reg - 1,     \\\n\t\t\ttegra210_admaif_pget_stereo_to_mono,\t\t       \\\n\t\t\ttegra210_admaif_pput_stereo_to_mono,\t\t       \\\n\t\t\ttegra_admaif_stereo_conv_text),\t\t\t       \\\n\tNV_SOC_ENUM_EXT(\"ADMAIF\" #reg \" Capture Mono To Stereo\", reg - 1,      \\\n\t\t\ttegra210_admaif_cget_mono_to_stereo,\t\t       \\\n\t\t\ttegra210_admaif_cput_mono_to_stereo,\t\t       \\\n\t\t\ttegra_admaif_mono_conv_text),\t\t\t       \\\n\tNV_SOC_ENUM_EXT(\"ADMAIF\" #reg \" Capture Stereo To Mono\", reg - 1,      \\\n\t\t\ttegra210_admaif_cget_stereo_to_mono,\t\t       \\\n\t\t\ttegra210_admaif_cput_stereo_to_mono,\t\t       \\\n\t\t\ttegra_admaif_stereo_conv_text)\n\nstatic struct snd_kcontrol_new tegra210_admaif_controls[] = {\n\tTEGRA_ADMAIF_CIF_CTRL(1),\n\tTEGRA_ADMAIF_CIF_CTRL(2),\n\tTEGRA_ADMAIF_CIF_CTRL(3),\n\tTEGRA_ADMAIF_CIF_CTRL(4),\n\tTEGRA_ADMAIF_CIF_CTRL(5),\n\tTEGRA_ADMAIF_CIF_CTRL(6),\n\tTEGRA_ADMAIF_CIF_CTRL(7),\n\tTEGRA_ADMAIF_CIF_CTRL(8),\n\tTEGRA_ADMAIF_CIF_CTRL(9),\n\tTEGRA_ADMAIF_CIF_CTRL(10),\n};\n\nstatic struct snd_kcontrol_new tegra186_admaif_controls[] = {\n\tTEGRA_ADMAIF_CIF_CTRL(1),\n\tTEGRA_ADMAIF_CIF_CTRL(2),\n\tTEGRA_ADMAIF_CIF_CTRL(3),\n\tTEGRA_ADMAIF_CIF_CTRL(4),\n\tTEGRA_ADMAIF_CIF_CTRL(5),\n\tTEGRA_ADMAIF_CIF_CTRL(6),\n\tTEGRA_ADMAIF_CIF_CTRL(7),\n\tTEGRA_ADMAIF_CIF_CTRL(8),\n\tTEGRA_ADMAIF_CIF_CTRL(9),\n\tTEGRA_ADMAIF_CIF_CTRL(10),\n\tTEGRA_ADMAIF_CIF_CTRL(11),\n\tTEGRA_ADMAIF_CIF_CTRL(12),\n\tTEGRA_ADMAIF_CIF_CTRL(13),\n\tTEGRA_ADMAIF_CIF_CTRL(14),\n\tTEGRA_ADMAIF_CIF_CTRL(15),\n\tTEGRA_ADMAIF_CIF_CTRL(16),\n\tTEGRA_ADMAIF_CIF_CTRL(17),\n\tTEGRA_ADMAIF_CIF_CTRL(18),\n\tTEGRA_ADMAIF_CIF_CTRL(19),\n\tTEGRA_ADMAIF_CIF_CTRL(20),\n};\n\nstatic const struct snd_soc_component_driver tegra210_admaif_cmpnt = {\n\t.controls\t\t= tegra210_admaif_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_admaif_controls),\n\t.pcm_construct\t\t= tegra_pcm_construct,\n\t.open\t\t\t= tegra_pcm_open,\n\t.close\t\t\t= tegra_pcm_close,\n\t.hw_params\t\t= tegra_pcm_hw_params,\n\t.pointer\t\t= tegra_pcm_pointer,\n};\n\nstatic const struct snd_soc_component_driver tegra186_admaif_cmpnt = {\n\t.controls\t\t= tegra186_admaif_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra186_admaif_controls),\n\t.pcm_construct\t\t= tegra_pcm_construct,\n\t.open\t\t\t= tegra_pcm_open,\n\t.close\t\t\t= tegra_pcm_close,\n\t.hw_params\t\t= tegra_pcm_hw_params,\n\t.pointer\t\t= tegra_pcm_pointer,\n};\n\nstatic const struct tegra_admaif_soc_data soc_data_tegra210 = {\n\t.num_ch\t\t= TEGRA210_ADMAIF_CHANNEL_COUNT,\n\t.cmpnt\t\t= &tegra210_admaif_cmpnt,\n\t.dais\t\t= tegra210_admaif_cmpnt_dais,\n\t.regmap_conf\t= &tegra210_admaif_regmap_config,\n\t.global_base\t= TEGRA210_ADMAIF_GLOBAL_BASE,\n\t.tx_base\t= TEGRA210_ADMAIF_TX_BASE,\n\t.rx_base\t= TEGRA210_ADMAIF_RX_BASE,\n};\n\nstatic const struct tegra_admaif_soc_data soc_data_tegra186 = {\n\t.num_ch\t\t= TEGRA186_ADMAIF_CHANNEL_COUNT,\n\t.cmpnt\t\t= &tegra186_admaif_cmpnt,\n\t.dais\t\t= tegra186_admaif_cmpnt_dais,\n\t.regmap_conf\t= &tegra186_admaif_regmap_config,\n\t.global_base\t= TEGRA186_ADMAIF_GLOBAL_BASE,\n\t.tx_base\t= TEGRA186_ADMAIF_TX_BASE,\n\t.rx_base\t= TEGRA186_ADMAIF_RX_BASE,\n};\n\nstatic const struct of_device_id tegra_admaif_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-admaif\", .data = &soc_data_tegra210 },\n\t{ .compatible = \"nvidia,tegra186-admaif\", .data = &soc_data_tegra186 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra_admaif_of_match);\n\nstatic int tegra_admaif_probe(struct platform_device *pdev)\n{\n\tstruct tegra_admaif *admaif;\n\tvoid __iomem *regs;\n\tstruct resource *res;\n\tint err, i;\n\n\tadmaif = devm_kzalloc(&pdev->dev, sizeof(*admaif), GFP_KERNEL);\n\tif (!admaif)\n\t\treturn -ENOMEM;\n\n\tadmaif->soc_data = of_device_get_match_data(&pdev->dev);\n\n\tdev_set_drvdata(&pdev->dev, admaif);\n\n\tadmaif->capture_dma_data =\n\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t     admaif->soc_data->num_ch,\n\t\t\t     sizeof(struct snd_dmaengine_dai_dma_data),\n\t\t\t     GFP_KERNEL);\n\tif (!admaif->capture_dma_data)\n\t\treturn -ENOMEM;\n\n\tadmaif->playback_dma_data =\n\t\tdevm_kcalloc(&pdev->dev,\n\t\t\t     admaif->soc_data->num_ch,\n\t\t\t     sizeof(struct snd_dmaengine_dai_dma_data),\n\t\t\t     GFP_KERNEL);\n\tif (!admaif->playback_dma_data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ADMAIF_PATHS; i++) {\n\t\tadmaif->mono_to_stereo[i] =\n\t\t\tdevm_kcalloc(&pdev->dev, admaif->soc_data->num_ch,\n\t\t\t\t     sizeof(unsigned int), GFP_KERNEL);\n\t\tif (!admaif->mono_to_stereo[i])\n\t\t\treturn -ENOMEM;\n\n\t\tadmaif->stereo_to_mono[i] =\n\t\t\tdevm_kcalloc(&pdev->dev, admaif->soc_data->num_ch,\n\t\t\t\t     sizeof(unsigned int), GFP_KERNEL);\n\t\tif (!admaif->stereo_to_mono[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tadmaif->regmap = devm_regmap_init_mmio(&pdev->dev, regs,\n\t\t\t\t\t       admaif->soc_data->regmap_conf);\n\tif (IS_ERR(admaif->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(admaif->regmap);\n\t}\n\n\tregcache_cache_only(admaif->regmap, true);\n\n\tregmap_update_bits(admaif->regmap, admaif->soc_data->global_base +\n\t\t\t   TEGRA_ADMAIF_GLOBAL_ENABLE, 1, 1);\n\n\tfor (i = 0; i < admaif->soc_data->num_ch; i++) {\n\t\tadmaif->playback_dma_data[i].addr = res->start +\n\t\t\tCH_TX_REG(TEGRA_ADMAIF_TX_FIFO_WRITE, i);\n\n\t\tadmaif->capture_dma_data[i].addr = res->start +\n\t\t\tCH_RX_REG(TEGRA_ADMAIF_RX_FIFO_READ, i);\n\n\t\tadmaif->playback_dma_data[i].addr_width = 32;\n\n\t\tif (of_property_read_string_index(pdev->dev.of_node,\n\t\t\t\t\"dma-names\", (i * 2) + 1,\n\t\t\t\t&admaif->playback_dma_data[i].chan_name) < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"missing property nvidia,dma-names\\n\");\n\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tadmaif->capture_dma_data[i].addr_width = 32;\n\n\t\tif (of_property_read_string_index(pdev->dev.of_node,\n\t\t\t\t\"dma-names\",\n\t\t\t\t(i * 2),\n\t\t\t\t&admaif->capture_dma_data[i].chan_name) < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"missing property nvidia,dma-names\\n\");\n\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\terr = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      admaif->soc_data->cmpnt,\n\t\t\t\t\t      admaif->soc_data->dais,\n\t\t\t\t\t      admaif->soc_data->num_ch);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"can't register ADMAIF component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void tegra_admaif_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra_admaif_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_admaif_runtime_suspend,\n\t\t\t   tegra_admaif_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra_admaif_driver = {\n\t.probe = tegra_admaif_probe,\n\t.remove_new = tegra_admaif_remove,\n\t.driver = {\n\t\t.name = \"tegra210-admaif\",\n\t\t.of_match_table = tegra_admaif_of_match,\n\t\t.pm = &tegra_admaif_pm_ops,\n\t},\n};\nmodule_platform_driver(tegra_admaif_driver);\n\nMODULE_AUTHOR(\"Songhee Baek <sbaek@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 ASoC ADMAIF driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}