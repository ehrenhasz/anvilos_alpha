{
  "module_name": "tegra210_adx.c",
  "hash_id": "177bfcd7381dff3a7914a7ad18278a09b6fc06c9815c1f6ae8890dd3f008744d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/tegra/tegra210_adx.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"tegra210_adx.h\"\n#include \"tegra_cif.h\"\n\nstatic const struct reg_default tegra210_adx_reg_defaults[] = {\n\t{ TEGRA210_ADX_RX_INT_MASK, 0x00000001},\n\t{ TEGRA210_ADX_RX_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_ADX_TX_INT_MASK, 0x0000000f },\n\t{ TEGRA210_ADX_TX1_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_ADX_TX2_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_ADX_TX3_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_ADX_TX4_CIF_CTRL, 0x00007000},\n\t{ TEGRA210_ADX_CG, 0x1},\n\t{ TEGRA210_ADX_CFG_RAM_CTRL, 0x00004000},\n};\n\nstatic void tegra210_adx_write_map_ram(struct tegra210_adx *adx)\n{\n\tint i;\n\n\tregmap_write(adx->regmap, TEGRA210_ADX_CFG_RAM_CTRL,\n\t\t     TEGRA210_ADX_CFG_RAM_CTRL_SEQ_ACCESS_EN |\n\t\t     TEGRA210_ADX_CFG_RAM_CTRL_ADDR_INIT_EN |\n\t\t     TEGRA210_ADX_CFG_RAM_CTRL_RW_WRITE);\n\n\tfor (i = 0; i < TEGRA210_ADX_RAM_DEPTH; i++)\n\t\tregmap_write(adx->regmap, TEGRA210_ADX_CFG_RAM_DATA,\n\t\t\t     adx->map[i]);\n\n\tregmap_write(adx->regmap, TEGRA210_ADX_IN_BYTE_EN0, adx->byte_mask[0]);\n\tregmap_write(adx->regmap, TEGRA210_ADX_IN_BYTE_EN1, adx->byte_mask[1]);\n}\n\nstatic int tegra210_adx_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct tegra210_adx *adx = snd_soc_dai_get_drvdata(dai);\n\tunsigned int val;\n\tint err;\n\n\t \n\terr = regmap_read_poll_timeout_atomic(adx->regmap, TEGRA210_ADX_STATUS,\n\t\t\t\t\t      val, !(val & 0x1), 10, 10000);\n\tif (err < 0) {\n\t\tdev_err(dai->dev, \"failed to stop ADX, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tregmap_update_bits(adx->regmap, TEGRA210_ADX_SOFT_RESET,\n\t\t\t   TEGRA210_ADX_SOFT_RESET_SOFT_RESET_MASK,\n\t\t\t   TEGRA210_ADX_SOFT_RESET_SOFT_EN);\n\n\terr = regmap_read_poll_timeout(adx->regmap, TEGRA210_ADX_SOFT_RESET,\n\t\t\t\t       val, !(val & 0x1), 10, 10000);\n\tif (err < 0) {\n\t\tdev_err(dai->dev, \"failed to reset ADX, err = %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_adx_runtime_suspend(struct device *dev)\n{\n\tstruct tegra210_adx *adx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(adx->regmap, true);\n\tregcache_mark_dirty(adx->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra210_adx_runtime_resume(struct device *dev)\n{\n\tstruct tegra210_adx *adx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(adx->regmap, false);\n\tregcache_sync(adx->regmap);\n\n\ttegra210_adx_write_map_ram(adx);\n\n\treturn 0;\n}\n\nstatic int tegra210_adx_set_audio_cif(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int channels,\n\t\t\t\t      snd_pcm_format_t format,\n\t\t\t\t      unsigned int reg)\n{\n\tstruct tegra210_adx *adx = snd_soc_dai_get_drvdata(dai);\n\tstruct tegra_cif_conf cif_conf;\n\tint audio_bits;\n\n\tmemset(&cif_conf, 0, sizeof(struct tegra_cif_conf));\n\n\tif (channels < 1 || channels > 16)\n\t\treturn -EINVAL;\n\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\taudio_bits = TEGRA_ACIF_BITS_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\taudio_bits = TEGRA_ACIF_BITS_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcif_conf.audio_ch = channels;\n\tcif_conf.client_ch = channels;\n\tcif_conf.audio_bits = audio_bits;\n\tcif_conf.client_bits = audio_bits;\n\n\ttegra_set_cif(adx->regmap, reg, &cif_conf);\n\n\treturn 0;\n}\n\nstatic int tegra210_adx_out_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\treturn tegra210_adx_set_audio_cif(dai, params_channels(params),\n\t\t\tparams_format(params),\n\t\t\tTEGRA210_ADX_TX1_CIF_CTRL + ((dai->id - 1) * TEGRA210_ADX_AUDIOCIF_CH_STRIDE));\n}\n\nstatic int tegra210_adx_in_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\treturn tegra210_adx_set_audio_cif(dai, params_channels(params),\n\t\t\t\t\t  params_format(params),\n\t\t\t\t\t  TEGRA210_ADX_RX_CIF_CTRL);\n}\n\nstatic int tegra210_adx_get_byte_map(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_adx *adx = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_mixer_control *mc;\n\tunsigned char *bytes_map = (unsigned char *)&adx->map;\n\tint enabled;\n\n\tmc = (struct soc_mixer_control *)kcontrol->private_value;\n\tenabled = adx->byte_mask[mc->reg / 32] & (1 << (mc->reg % 32));\n\n\t \n\tif (enabled)\n\t\tucontrol->value.integer.value[0] = bytes_map[mc->reg];\n\telse\n\t\tucontrol->value.integer.value[0] = 256;\n\n\treturn 0;\n}\n\nstatic int tegra210_adx_put_byte_map(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct tegra210_adx *adx = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned char *bytes_map = (unsigned char *)&adx->map;\n\tint value = ucontrol->value.integer.value[0];\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int mask_val = adx->byte_mask[mc->reg / 32];\n\n\tif (value >= 0 && value <= 255)\n\t\tmask_val |= (1 << (mc->reg % 32));\n\telse\n\t\tmask_val &= ~(1 << (mc->reg % 32));\n\n\tif (mask_val == adx->byte_mask[mc->reg / 32])\n\t\treturn 0;\n\n\t \n\tbytes_map[mc->reg] = value % 256;\n\tadx->byte_mask[mc->reg / 32] = mask_val;\n\n\treturn 1;\n}\n\nstatic const struct snd_soc_dai_ops tegra210_adx_in_dai_ops = {\n\t.hw_params\t= tegra210_adx_in_hw_params,\n\t.startup\t= tegra210_adx_startup,\n};\n\nstatic const struct snd_soc_dai_ops tegra210_adx_out_dai_ops = {\n\t.hw_params\t= tegra210_adx_out_hw_params,\n};\n\n#define IN_DAI\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = \"ADX-RX-CIF\",\t\t\t\t\\\n\t\t.playback = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"RX-CIF-Playback\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"RX-CIF-Capture\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.ops = &tegra210_adx_in_dai_ops,\t\t\\\n\t}\n\n#define OUT_DAI(id)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.name = \"ADX-TX\" #id \"-CIF\",\t\t\t\\\n\t\t.playback = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"TX\" #id \"-CIF-Playback\",\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\\\n\t\t\t.stream_name = \"TX\" #id \"-CIF-Capture\",\t\\\n\t\t\t.channels_min = 1,\t\t\t\\\n\t\t\t.channels_max = 16,\t\t\t\\\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\t\\\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\t\\\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.ops = &tegra210_adx_out_dai_ops,\t\t\\\n\t}\n\nstatic struct snd_soc_dai_driver tegra210_adx_dais[] = {\n\tIN_DAI,\n\tOUT_DAI(1),\n\tOUT_DAI(2),\n\tOUT_DAI(3),\n\tOUT_DAI(4),\n};\n\nstatic const struct snd_soc_dapm_widget tegra210_adx_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"RX\", NULL, 0, TEGRA210_ADX_ENABLE,\n\t\t\t    TEGRA210_ADX_ENABLE_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX1\", NULL, 0, TEGRA210_ADX_CTRL, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX2\", NULL, 0, TEGRA210_ADX_CTRL, 1, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX3\", NULL, 0, TEGRA210_ADX_CTRL, 2, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"TX4\", NULL, 0, TEGRA210_ADX_CTRL, 3, 0),\n};\n\n#define STREAM_ROUTES(id, sname)\t\t\t\t\t  \\\n\t{ \"XBAR-\" sname,\t\tNULL,\t\"XBAR-TX\" },\t\t  \\\n\t{ \"RX-CIF-\" sname,\t\tNULL,\t\"XBAR-\" sname },\t  \\\n\t{ \"RX\",\t\t\t\tNULL,\t\"RX-CIF-\" sname },\t  \\\n\t{ \"TX\" #id,\t\t\tNULL,\t\"RX\" },\t\t\t  \\\n\t{ \"TX\" #id \"-CIF-\" sname,\tNULL,\t\"TX\" #id },\t\t  \\\n\t{ \"TX\" #id \" XBAR-\" sname,\tNULL,\t\"TX\" #id \"-CIF-\" sname }, \\\n\t{ \"TX\" #id \" XBAR-RX\",\t\tNULL,\t\"TX\" #id \" XBAR-\" sname }\n\n#define ADX_ROUTES(id)\t\t\t\\\n\tSTREAM_ROUTES(id, \"Playback\"),\t\\\n\tSTREAM_ROUTES(id, \"Capture\")\n\n#define STREAM_ROUTES(id, sname)\t\t\t\t\t  \\\n\t{ \"XBAR-\" sname,\t\tNULL,\t\"XBAR-TX\" },\t\t  \\\n\t{ \"RX-CIF-\" sname,\t\tNULL,\t\"XBAR-\" sname },\t  \\\n\t{ \"RX\",\t\t\t\tNULL,\t\"RX-CIF-\" sname },\t  \\\n\t{ \"TX\" #id,\t\t\tNULL,\t\"RX\" },\t\t\t  \\\n\t{ \"TX\" #id \"-CIF-\" sname,\tNULL,\t\"TX\" #id },\t\t  \\\n\t{ \"TX\" #id \" XBAR-\" sname,\tNULL,\t\"TX\" #id \"-CIF-\" sname }, \\\n\t{ \"TX\" #id \" XBAR-RX\",\t\tNULL,\t\"TX\" #id \" XBAR-\" sname }\n\n#define ADX_ROUTES(id)\t\t\t\\\n\tSTREAM_ROUTES(id, \"Playback\"),\t\\\n\tSTREAM_ROUTES(id, \"Capture\")\n\nstatic const struct snd_soc_dapm_route tegra210_adx_routes[] = {\n\tADX_ROUTES(1),\n\tADX_ROUTES(2),\n\tADX_ROUTES(3),\n\tADX_ROUTES(4),\n};\n\n#define TEGRA210_ADX_BYTE_MAP_CTRL(reg)\t\t\t \\\n\tSOC_SINGLE_EXT(\"Byte Map \" #reg, reg, 0, 256, 0, \\\n\t\t       tegra210_adx_get_byte_map,\t \\\n\t\t       tegra210_adx_put_byte_map)\n\nstatic struct snd_kcontrol_new tegra210_adx_controls[] = {\n\tTEGRA210_ADX_BYTE_MAP_CTRL(0),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(1),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(2),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(3),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(4),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(5),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(6),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(7),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(8),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(9),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(10),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(11),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(12),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(13),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(14),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(15),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(16),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(17),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(18),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(19),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(20),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(21),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(22),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(23),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(24),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(25),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(26),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(27),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(28),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(29),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(30),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(31),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(32),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(33),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(34),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(35),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(36),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(37),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(38),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(39),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(40),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(41),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(42),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(43),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(44),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(45),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(46),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(47),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(48),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(49),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(50),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(51),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(52),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(53),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(54),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(55),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(56),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(57),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(58),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(59),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(60),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(61),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(62),\n\tTEGRA210_ADX_BYTE_MAP_CTRL(63),\n};\n\nstatic const struct snd_soc_component_driver tegra210_adx_cmpnt = {\n\t.dapm_widgets\t\t= tegra210_adx_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tegra210_adx_widgets),\n\t.dapm_routes\t\t= tegra210_adx_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tegra210_adx_routes),\n\t.controls\t\t= tegra210_adx_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tegra210_adx_controls),\n};\n\nstatic bool tegra210_adx_wr_reg(struct device *dev,\n\t\t\t\tunsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_ADX_TX_INT_MASK ... TEGRA210_ADX_TX4_CIF_CTRL:\n\tcase TEGRA210_ADX_RX_INT_MASK ... TEGRA210_ADX_RX_CIF_CTRL:\n\tcase TEGRA210_ADX_ENABLE ... TEGRA210_ADX_CG:\n\tcase TEGRA210_ADX_CTRL ... TEGRA210_ADX_IN_BYTE_EN1:\n\tcase TEGRA210_ADX_CFG_RAM_CTRL ... TEGRA210_ADX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_adx_rd_reg(struct device *dev,\n\t\t\t\tunsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_ADX_RX_STATUS ... TEGRA210_ADX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tegra210_adx_volatile_reg(struct device *dev,\n\t\t\t\tunsigned int reg)\n{\n\tswitch (reg) {\n\tcase TEGRA210_ADX_RX_STATUS:\n\tcase TEGRA210_ADX_RX_INT_STATUS:\n\tcase TEGRA210_ADX_RX_INT_SET:\n\tcase TEGRA210_ADX_TX_STATUS:\n\tcase TEGRA210_ADX_TX_INT_STATUS:\n\tcase TEGRA210_ADX_TX_INT_SET:\n\tcase TEGRA210_ADX_SOFT_RESET:\n\tcase TEGRA210_ADX_STATUS:\n\tcase TEGRA210_ADX_INT_STATUS:\n\tcase TEGRA210_ADX_CFG_RAM_CTRL:\n\tcase TEGRA210_ADX_CFG_RAM_DATA:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config tegra210_adx_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TEGRA210_ADX_CFG_RAM_DATA,\n\t.writeable_reg\t\t= tegra210_adx_wr_reg,\n\t.readable_reg\t\t= tegra210_adx_rd_reg,\n\t.volatile_reg\t\t= tegra210_adx_volatile_reg,\n\t.reg_defaults\t\t= tegra210_adx_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tegra210_adx_reg_defaults),\n\t.cache_type\t\t= REGCACHE_FLAT,\n};\n\nstatic const struct of_device_id tegra210_adx_of_match[] = {\n\t{ .compatible = \"nvidia,tegra210-adx\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tegra210_adx_of_match);\n\nstatic int tegra210_adx_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct tegra210_adx *adx;\n\tvoid __iomem *regs;\n\tint err;\n\n\tadx = devm_kzalloc(dev, sizeof(*adx), GFP_KERNEL);\n\tif (!adx)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, adx);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tadx->regmap = devm_regmap_init_mmio(dev, regs,\n\t\t\t\t\t    &tegra210_adx_regmap_config);\n\tif (IS_ERR(adx->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(adx->regmap);\n\t}\n\n\tregcache_cache_only(adx->regmap, true);\n\n\terr = devm_snd_soc_register_component(dev, &tegra210_adx_cmpnt,\n\t\t\t\t\t      tegra210_adx_dais,\n\t\t\t\t\t      ARRAY_SIZE(tegra210_adx_dais));\n\tif (err) {\n\t\tdev_err(dev, \"can't register ADX component, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void tegra210_adx_platform_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops tegra210_adx_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra210_adx_runtime_suspend,\n\t\t\t   tegra210_adx_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver tegra210_adx_driver = {\n\t.driver = {\n\t\t.name = \"tegra210-adx\",\n\t\t.of_match_table = tegra210_adx_of_match,\n\t\t.pm = &tegra210_adx_pm_ops,\n\t},\n\t.probe = tegra210_adx_platform_probe,\n\t.remove_new = tegra210_adx_platform_remove,\n};\nmodule_platform_driver(tegra210_adx_driver);\n\nMODULE_AUTHOR(\"Arun Shamanna Lakshmi <aruns@nvidia.com>\");\nMODULE_DESCRIPTION(\"Tegra210 ADX ASoC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}