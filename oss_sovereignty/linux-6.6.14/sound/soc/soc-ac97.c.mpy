{
  "module_name": "soc-ac97.c",
  "hash_id": "4447b1c2546b963c5a79ee1bfbefc251bbd3acf3f59917e9cc1877e5a6b35bda",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-ac97.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/slab.h>\n#include <sound/ac97_codec.h>\n#include <sound/soc.h>\n\nstruct snd_ac97_reset_cfg {\n\tstruct pinctrl *pctl;\n\tstruct pinctrl_state *pstate_reset;\n\tstruct pinctrl_state *pstate_warm_reset;\n\tstruct pinctrl_state *pstate_run;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *sdata_gpio;\n\tstruct gpio_desc *sync_gpio;\n};\n\nstatic struct snd_ac97_bus soc_ac97_bus = {\n\t.ops = NULL,  \n};\n\nstatic void soc_ac97_device_release(struct device *dev)\n{\n\tkfree(to_ac97_t(dev));\n}\n\n#ifdef CONFIG_GPIOLIB\nstruct snd_ac97_gpio_priv {\n\tstruct gpio_chip gpio_chip;\n\tunsigned int gpios_set;\n\tstruct snd_soc_component *component;\n};\n\nstatic inline struct snd_soc_component *gpio_to_component(struct gpio_chip *chip)\n{\n\tstruct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);\n\n\treturn gpio_priv->component;\n}\n\nstatic int snd_soc_ac97_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tif (offset >= AC97_NUM_GPIOS)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int snd_soc_ac97_gpio_direction_in(struct gpio_chip *chip,\n\t\t\t\t\t  unsigned int offset)\n{\n\tstruct snd_soc_component *component = gpio_to_component(chip);\n\n\tdev_dbg(component->dev, \"set gpio %d to output\\n\", offset);\n\treturn snd_soc_component_update_bits(component, AC97_GPIO_CFG,\n\t\t\t\t   1 << offset, 1 << offset);\n}\n\nstatic int snd_soc_ac97_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct snd_soc_component *component = gpio_to_component(chip);\n\tint ret;\n\n\tret = snd_soc_component_read(component, AC97_GPIO_STATUS);\n\n\tdev_dbg(component->dev, \"get gpio %d : %d\\n\", offset,\n\t\tret & (1 << offset));\n\n\treturn !!(ret & (1 << offset));\n}\n\nstatic void snd_soc_ac97_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t\t  int value)\n{\n\tstruct snd_ac97_gpio_priv *gpio_priv = gpiochip_get_data(chip);\n\tstruct snd_soc_component *component = gpio_to_component(chip);\n\n\tgpio_priv->gpios_set &= ~(1 << offset);\n\tgpio_priv->gpios_set |= (!!value) << offset;\n\tsnd_soc_component_write(component, AC97_GPIO_STATUS,\n\t\t\t\tgpio_priv->gpios_set);\n\tdev_dbg(component->dev, \"set gpio %d to %d\\n\", offset, !!value);\n}\n\nstatic int snd_soc_ac97_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct snd_soc_component *component = gpio_to_component(chip);\n\n\tdev_dbg(component->dev, \"set gpio %d to output\\n\", offset);\n\tsnd_soc_ac97_gpio_set(chip, offset, value);\n\treturn snd_soc_component_update_bits(component, AC97_GPIO_CFG,\n\t\t\t\t\t     1 << offset, 0);\n}\n\nstatic const struct gpio_chip snd_soc_ac97_gpio_chip = {\n\t.label\t\t\t= \"snd_soc_ac97\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= snd_soc_ac97_gpio_request,\n\t.direction_input\t= snd_soc_ac97_gpio_direction_in,\n\t.get\t\t\t= snd_soc_ac97_gpio_get,\n\t.direction_output\t= snd_soc_ac97_gpio_direction_out,\n\t.set\t\t\t= snd_soc_ac97_gpio_set,\n\t.can_sleep\t\t= 1,\n};\n\nstatic int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,\n\t\t\t\t  struct snd_soc_component *component)\n{\n\tstruct snd_ac97_gpio_priv *gpio_priv;\n\tint ret;\n\n\tgpio_priv = devm_kzalloc(component->dev, sizeof(*gpio_priv), GFP_KERNEL);\n\tif (!gpio_priv)\n\t\treturn -ENOMEM;\n\tac97->gpio_priv = gpio_priv;\n\tgpio_priv->component = component;\n\tgpio_priv->gpio_chip = snd_soc_ac97_gpio_chip;\n\tgpio_priv->gpio_chip.ngpio = AC97_NUM_GPIOS;\n\tgpio_priv->gpio_chip.parent = component->dev;\n\tgpio_priv->gpio_chip.base = -1;\n\n\tret = gpiochip_add_data(&gpio_priv->gpio_chip, gpio_priv);\n\tif (ret != 0)\n\t\tdev_err(component->dev, \"Failed to add GPIOs: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)\n{\n\tgpiochip_remove(&ac97->gpio_priv->gpio_chip);\n}\n#else\nstatic int snd_soc_ac97_init_gpio(struct snd_ac97 *ac97,\n\t\t\t\t  struct snd_soc_component *component)\n{\n\treturn 0;\n}\n\nstatic void snd_soc_ac97_free_gpio(struct snd_ac97 *ac97)\n{\n}\n#endif\n\n \nstruct snd_ac97 *snd_soc_alloc_ac97_component(struct snd_soc_component *component)\n{\n\tstruct snd_ac97 *ac97;\n\n\tac97 = kzalloc(sizeof(struct snd_ac97), GFP_KERNEL);\n\tif (ac97 == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tac97->bus = &soc_ac97_bus;\n\tac97->num = 0;\n\n\tac97->dev.bus = &ac97_bus_type;\n\tac97->dev.parent = component->card->dev;\n\tac97->dev.release = soc_ac97_device_release;\n\n\tdev_set_name(&ac97->dev, \"%d-%d:%s\",\n\t\t     component->card->snd_card->number, 0,\n\t\t     component->name);\n\n\tdevice_initialize(&ac97->dev);\n\n\treturn ac97;\n}\nEXPORT_SYMBOL(snd_soc_alloc_ac97_component);\n\n \nstruct snd_ac97 *snd_soc_new_ac97_component(struct snd_soc_component *component,\n\tunsigned int id, unsigned int id_mask)\n{\n\tstruct snd_ac97 *ac97;\n\tint ret;\n\n\tac97 = snd_soc_alloc_ac97_component(component);\n\tif (IS_ERR(ac97))\n\t\treturn ac97;\n\n\tif (id) {\n\t\tret = snd_ac97_reset(ac97, false, id, id_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to reset AC97 device: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_put_device;\n\t\t}\n\t}\n\n\tret = device_add(&ac97->dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tret = snd_soc_ac97_init_gpio(ac97, component);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\treturn ac97;\n\nerr_put_device:\n\tput_device(&ac97->dev);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_new_ac97_component);\n\n \nvoid snd_soc_free_ac97_component(struct snd_ac97 *ac97)\n{\n\tsnd_soc_ac97_free_gpio(ac97);\n\tdevice_del(&ac97->dev);\n\tac97->bus = NULL;\n\tput_device(&ac97->dev);\n}\nEXPORT_SYMBOL_GPL(snd_soc_free_ac97_component);\n\nstatic struct snd_ac97_reset_cfg snd_ac97_rst_cfg;\n\nstatic void snd_soc_ac97_warm_reset(struct snd_ac97 *ac97)\n{\n\tstruct pinctrl *pctl = snd_ac97_rst_cfg.pctl;\n\n\tpinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_warm_reset);\n\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.sync_gpio, 1);\n\n\tudelay(10);\n\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.sync_gpio, 0);\n\n\tpinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);\n\tmsleep(2);\n}\n\nstatic void snd_soc_ac97_reset(struct snd_ac97 *ac97)\n{\n\tstruct pinctrl *pctl = snd_ac97_rst_cfg.pctl;\n\n\tpinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_reset);\n\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.sync_gpio, 0);\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.sdata_gpio, 0);\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.reset_gpio, 0);\n\n\tudelay(10);\n\n\tgpiod_direction_output_raw(snd_ac97_rst_cfg.reset_gpio, 1);\n\n\tpinctrl_select_state(pctl, snd_ac97_rst_cfg.pstate_run);\n\tmsleep(2);\n}\n\nstatic int snd_soc_ac97_parse_pinctl(struct device *dev,\n\t\tstruct snd_ac97_reset_cfg *cfg)\n{\n\tstruct pinctrl *p;\n\tstruct pinctrl_state *state;\n\n\tp = devm_pinctrl_get(dev);\n\tif (IS_ERR(p)) {\n\t\tdev_err(dev, \"Failed to get pinctrl\\n\");\n\t\treturn PTR_ERR(p);\n\t}\n\tcfg->pctl = p;\n\n\tstate = pinctrl_lookup_state(p, \"ac97-reset\");\n\tif (IS_ERR(state)) {\n\t\tdev_err(dev, \"Can't find pinctrl state ac97-reset\\n\");\n\t\treturn PTR_ERR(state);\n\t}\n\tcfg->pstate_reset = state;\n\n\tstate = pinctrl_lookup_state(p, \"ac97-warm-reset\");\n\tif (IS_ERR(state)) {\n\t\tdev_err(dev, \"Can't find pinctrl state ac97-warm-reset\\n\");\n\t\treturn PTR_ERR(state);\n\t}\n\tcfg->pstate_warm_reset = state;\n\n\tstate = pinctrl_lookup_state(p, \"ac97-running\");\n\tif (IS_ERR(state)) {\n\t\tdev_err(dev, \"Can't find pinctrl state ac97-running\\n\");\n\t\treturn PTR_ERR(state);\n\t}\n\tcfg->pstate_run = state;\n\n\tcfg->sync_gpio = devm_gpiod_get_index(dev, \"ac97\", 0, GPIOD_ASIS);\n\tif (IS_ERR(cfg->sync_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(cfg->sync_gpio), \"Can't find ac97-sync gpio\\n\");\n\tgpiod_set_consumer_name(cfg->sync_gpio, \"AC97 link sync\");\n\n\tcfg->sdata_gpio = devm_gpiod_get_index(dev, \"ac97\", 1, GPIOD_ASIS);\n\tif (IS_ERR(cfg->sdata_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(cfg->sdata_gpio), \"Can't find ac97-sdata gpio\\n\");\n\tgpiod_set_consumer_name(cfg->sdata_gpio, \"AC97 link sdata\");\n\n\tcfg->reset_gpio = devm_gpiod_get_index(dev, \"ac97\", 2, GPIOD_ASIS);\n\tif (IS_ERR(cfg->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(cfg->reset_gpio), \"Can't find ac97-reset gpio\\n\");\n\tgpiod_set_consumer_name(cfg->reset_gpio, \"AC97 link reset\");\n\n\treturn 0;\n}\n\nstruct snd_ac97_bus_ops *soc_ac97_ops;\nEXPORT_SYMBOL_GPL(soc_ac97_ops);\n\nint snd_soc_set_ac97_ops(struct snd_ac97_bus_ops *ops)\n{\n\tif (ops == soc_ac97_ops)\n\t\treturn 0;\n\n\tif (soc_ac97_ops && ops)\n\t\treturn -EBUSY;\n\n\tsoc_ac97_ops = ops;\n\tsoc_ac97_bus.ops = ops;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops);\n\n \nint snd_soc_set_ac97_ops_of_reset(struct snd_ac97_bus_ops *ops,\n\t\tstruct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_ac97_reset_cfg cfg;\n\tint ret;\n\n\tret = snd_soc_ac97_parse_pinctl(dev, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_set_ac97_ops(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tops->warm_reset = snd_soc_ac97_warm_reset;\n\tops->reset = snd_soc_ac97_reset;\n\n\tsnd_ac97_rst_cfg = cfg;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_set_ac97_ops_of_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}