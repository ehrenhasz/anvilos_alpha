{
  "module_name": "xlnx_spdif.c",
  "hash_id": "eb6b56c21515a3d3af31ced89876cc76a94732d9de68e4b717520ced24e58e3e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/xilinx/xlnx_spdif.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#define XLNX_SPDIF_RATES \\\n\t(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \\\n\tSNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \\\n\tSNDRV_PCM_RATE_192000)\n\n#define XLNX_SPDIF_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\n#define XSPDIF_IRQ_STS_REG\t\t0x20\n#define XSPDIF_IRQ_ENABLE_REG\t\t0x28\n#define XSPDIF_SOFT_RESET_REG\t\t0x40\n#define XSPDIF_CONTROL_REG\t\t0x44\n#define XSPDIF_CHAN_0_STS_REG\t\t0x4C\n#define XSPDIF_GLOBAL_IRQ_ENABLE_REG\t0x1C\n#define XSPDIF_CH_A_USER_DATA_REG_0\t0x64\n\n#define XSPDIF_CORE_ENABLE_MASK\t\tBIT(0)\n#define XSPDIF_FIFO_FLUSH_MASK\t\tBIT(1)\n#define XSPDIF_CH_STS_MASK\t\tBIT(5)\n#define XSPDIF_GLOBAL_IRQ_ENABLE\tBIT(31)\n#define XSPDIF_CLOCK_CONFIG_BITS_MASK\tGENMASK(5, 2)\n#define XSPDIF_CLOCK_CONFIG_BITS_SHIFT\t2\n#define XSPDIF_SOFT_RESET_VALUE\t\t0xA\n\n#define MAX_CHANNELS\t\t\t2\n#define AES_SAMPLE_WIDTH\t\t32\n#define CH_STATUS_UPDATE_TIMEOUT\t40\n\nstruct spdif_dev_data {\n\tu32 mode;\n\tu32 aclk;\n\tbool rx_chsts_updated;\n\tvoid __iomem *base;\n\tstruct clk *axi_clk;\n\twait_queue_head_t chsts_q;\n};\n\nstatic irqreturn_t xlnx_spdifrx_irq_handler(int irq, void *arg)\n{\n\tu32 val;\n\tstruct spdif_dev_data *ctx = arg;\n\n\tval = readl(ctx->base + XSPDIF_IRQ_STS_REG);\n\tif (val & XSPDIF_CH_STS_MASK) {\n\t\twritel(val & XSPDIF_CH_STS_MASK,\n\t\t       ctx->base + XSPDIF_IRQ_STS_REG);\n\t\tval = readl(ctx->base +\n\t\t\t    XSPDIF_IRQ_ENABLE_REG);\n\t\twritel(val & ~XSPDIF_CH_STS_MASK,\n\t\t       ctx->base + XSPDIF_IRQ_ENABLE_REG);\n\n\t\tctx->rx_chsts_updated = true;\n\t\twake_up_interruptible(&ctx->chsts_q);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int xlnx_spdif_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tu32 val;\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);\n\n\tval = readl(ctx->base + XSPDIF_CONTROL_REG);\n\tval |= XSPDIF_FIFO_FLUSH_MASK;\n\twritel(val, ctx->base + XSPDIF_CONTROL_REG);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\twritel(XSPDIF_CH_STS_MASK,\n\t\t       ctx->base + XSPDIF_IRQ_ENABLE_REG);\n\t\twritel(XSPDIF_GLOBAL_IRQ_ENABLE,\n\t\t       ctx->base + XSPDIF_GLOBAL_IRQ_ENABLE_REG);\n\t}\n\n\treturn 0;\n}\n\nstatic void xlnx_spdif_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);\n\n\twritel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);\n}\n\nstatic int xlnx_spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tu32 val, clk_div, clk_cfg;\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);\n\n\tclk_div = DIV_ROUND_CLOSEST(ctx->aclk, MAX_CHANNELS * AES_SAMPLE_WIDTH *\n\t\t\t\t    params_rate(params));\n\n\tswitch (clk_div) {\n\tcase 4:\n\t\tclk_cfg = 0;\n\t\tbreak;\n\tcase 8:\n\t\tclk_cfg = 1;\n\t\tbreak;\n\tcase 16:\n\t\tclk_cfg = 2;\n\t\tbreak;\n\tcase 24:\n\t\tclk_cfg = 3;\n\t\tbreak;\n\tcase 32:\n\t\tclk_cfg = 4;\n\t\tbreak;\n\tcase 48:\n\t\tclk_cfg = 5;\n\t\tbreak;\n\tcase 64:\n\t\tclk_cfg = 6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = readl(ctx->base + XSPDIF_CONTROL_REG);\n\tval &= ~XSPDIF_CLOCK_CONFIG_BITS_MASK;\n\tval |= clk_cfg << XSPDIF_CLOCK_CONFIG_BITS_SHIFT;\n\twritel(val, ctx->base + XSPDIF_CONTROL_REG);\n\n\treturn 0;\n}\n\nstatic int rx_stream_detect(struct snd_soc_dai *dai)\n{\n\tint err;\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);\n\tunsigned long jiffies = msecs_to_jiffies(CH_STATUS_UPDATE_TIMEOUT);\n\n\t \n\terr = wait_event_interruptible_timeout(ctx->chsts_q,\n\t\t\t\t\t       ctx->rx_chsts_updated,\n\t\t\t\t\t       jiffies);\n\tif (!err) {\n\t\tdev_err(dai->dev, \"No streaming audio detected!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tctx->rx_chsts_updated = false;\n\n\treturn 0;\n}\n\nstatic int xlnx_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tu32 val;\n\tint ret = 0;\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(dai->dev);\n\n\tval = readl(ctx->base + XSPDIF_CONTROL_REG);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval |= XSPDIF_CORE_ENABLE_MASK;\n\t\twritel(val, ctx->base + XSPDIF_CONTROL_REG);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tret = rx_stream_detect(dai);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tval &= ~XSPDIF_CORE_ENABLE_MASK;\n\t\twritel(val, ctx->base + XSPDIF_CONTROL_REG);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops xlnx_spdif_dai_ops = {\n\t.startup = xlnx_spdif_startup,\n\t.shutdown = xlnx_spdif_shutdown,\n\t.trigger = xlnx_spdif_trigger,\n\t.hw_params = xlnx_spdif_hw_params,\n};\n\nstatic struct snd_soc_dai_driver xlnx_spdif_tx_dai = {\n\t.name = \"xlnx_spdif_tx\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = XLNX_SPDIF_RATES,\n\t\t.formats = XLNX_SPDIF_FORMATS,\n\t},\n\t.ops = &xlnx_spdif_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver xlnx_spdif_rx_dai = {\n\t.name = \"xlnx_spdif_rx\",\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = XLNX_SPDIF_RATES,\n\t\t.formats = XLNX_SPDIF_FORMATS,\n\t},\n\t.ops = &xlnx_spdif_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver xlnx_spdif_component = {\n\t.name = \"xlnx-spdif\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct of_device_id xlnx_spdif_of_match[] = {\n\t{ .compatible = \"xlnx,spdif-2.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xlnx_spdif_of_match);\n\nstatic int xlnx_spdif_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct spdif_dev_data *ctx;\n\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\n\tctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->axi_clk = devm_clk_get(dev, \"s_axi_aclk\");\n\tif (IS_ERR(ctx->axi_clk)) {\n\t\tret = PTR_ERR(ctx->axi_clk);\n\t\tdev_err(dev, \"failed to get s_axi_aclk(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(ctx->axi_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable s_axi_aclk(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctx->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctx->base)) {\n\t\tret = PTR_ERR(ctx->base);\n\t\tgoto clk_err;\n\t}\n\tret = of_property_read_u32(node, \"xlnx,spdif-mode\", &ctx->mode);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get SPDIF mode\\n\");\n\t\tgoto clk_err;\n\t}\n\tif (ctx->mode) {\n\t\tdai_drv = &xlnx_spdif_tx_dai;\n\t} else {\n\t\tret = platform_get_irq(pdev, 0);\n\t\tif (ret < 0)\n\t\t\tgoto clk_err;\n\t\tret = devm_request_irq(dev, ret,\n\t\t\t\t       xlnx_spdifrx_irq_handler,\n\t\t\t\t       0, \"XLNX_SPDIF_RX\", ctx);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"spdif rx irq request failed\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto clk_err;\n\t\t}\n\n\t\tinit_waitqueue_head(&ctx->chsts_q);\n\t\tdai_drv = &xlnx_spdif_rx_dai;\n\t}\n\n\tret = of_property_read_u32(node, \"xlnx,aud_clk_i\", &ctx->aclk);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get aud_clk_i value\\n\");\n\t\tgoto clk_err;\n\t}\n\n\tdev_set_drvdata(dev, ctx);\n\n\tret = devm_snd_soc_register_component(dev, &xlnx_spdif_component,\n\t\t\t\t\t      dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"SPDIF component registration failed\\n\");\n\t\tgoto clk_err;\n\t}\n\n\twritel(XSPDIF_SOFT_RESET_VALUE, ctx->base + XSPDIF_SOFT_RESET_REG);\n\tdev_info(dev, \"%s DAI registered\\n\", dai_drv->name);\n\nclk_err:\n\tclk_disable_unprepare(ctx->axi_clk);\n\treturn ret;\n}\n\nstatic void xlnx_spdif_remove(struct platform_device *pdev)\n{\n\tstruct spdif_dev_data *ctx = dev_get_drvdata(&pdev->dev);\n\n\tclk_disable_unprepare(ctx->axi_clk);\n}\n\nstatic struct platform_driver xlnx_spdif_driver = {\n\t.driver = {\n\t\t.name = \"xlnx-spdif\",\n\t\t.of_match_table = xlnx_spdif_of_match,\n\t},\n\t.probe = xlnx_spdif_probe,\n\t.remove_new = xlnx_spdif_remove,\n};\nmodule_platform_driver(xlnx_spdif_driver);\n\nMODULE_AUTHOR(\"Maruthi Srinivas Bayyavarapu <maruthis@xilinx.com>\");\nMODULE_DESCRIPTION(\"XILINX SPDIF driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}