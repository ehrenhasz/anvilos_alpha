{
  "module_name": "xlnx_i2s.c",
  "hash_id": "cf1ed76c6034ce20478ce2aa8f98a1e0a8c024c028623cb0170cd3baf8ae930c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/xilinx/xlnx_i2s.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#define DRV_NAME \"xlnx_i2s\"\n\n#define I2S_CORE_CTRL_OFFSET\t\t0x08\n#define I2S_CORE_CTRL_32BIT_LRCLK\tBIT(3)\n#define I2S_CORE_CTRL_ENABLE\t\tBIT(0)\n#define I2S_I2STIM_OFFSET\t\t0x20\n#define I2S_CH0_OFFSET\t\t\t0x30\n#define I2S_I2STIM_VALID_MASK\t\tGENMASK(7, 0)\n\nstruct xlnx_i2s_drv_data {\n\tstruct snd_soc_dai_driver dai_drv;\n\tvoid __iomem *base;\n\tunsigned int sysclk;\n\tu32 data_width;\n\tu32 channels;\n\tbool is_32bit_lrclk;\n\tstruct snd_ratnum ratnum;\n\tstruct snd_pcm_hw_constraint_ratnums rate_constraints;\n};\n\nstatic int xlnx_i2s_set_sclkout_div(struct snd_soc_dai *cpu_dai,\n\t\t\t\t    int div_id, int div)\n{\n\tstruct xlnx_i2s_drv_data *drv_data = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (!div || (div & ~I2S_I2STIM_VALID_MASK))\n\t\treturn -EINVAL;\n\n\tdrv_data->sysclk = 0;\n\n\twritel(div, drv_data->base + I2S_I2STIM_OFFSET);\n\n\treturn 0;\n}\n\nstatic int xlnx_i2s_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t       int clk_id, unsigned int freq, int dir)\n{\n\tstruct xlnx_i2s_drv_data *drv_data = snd_soc_dai_get_drvdata(dai);\n\n\tdrv_data->sysclk = freq;\n\tif (freq) {\n\t\tunsigned int bits_per_sample;\n\n\t\tif (drv_data->is_32bit_lrclk)\n\t\t\tbits_per_sample = 32;\n\t\telse\n\t\t\tbits_per_sample = drv_data->data_width;\n\n\t\tdrv_data->ratnum.num = freq / (bits_per_sample * drv_data->channels) / 2;\n\t\tdrv_data->ratnum.den_step = 1;\n\t\tdrv_data->ratnum.den_min = 1;\n\t\tdrv_data->ratnum.den_max = 255;\n\t\tdrv_data->rate_constraints.rats = &drv_data->ratnum;\n\t\tdrv_data->rate_constraints.nrats = 1;\n\t}\n\treturn 0;\n}\n\nstatic int xlnx_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct xlnx_i2s_drv_data *drv_data = snd_soc_dai_get_drvdata(dai);\n\n\tif (drv_data->sysclk)\n\t\treturn snd_pcm_hw_constraint_ratnums(substream->runtime, 0,\n\t\t\t\t\t\t     SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t     &drv_data->rate_constraints);\n\n\treturn 0;\n}\n\nstatic int xlnx_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *i2s_dai)\n{\n\tu32 reg_off, chan_id;\n\tstruct xlnx_i2s_drv_data *drv_data = snd_soc_dai_get_drvdata(i2s_dai);\n\n\tif (drv_data->sysclk) {\n\t\tunsigned int bits_per_sample, sclk, sclk_div;\n\n\t\tif (drv_data->is_32bit_lrclk)\n\t\t\tbits_per_sample = 32;\n\t\telse\n\t\t\tbits_per_sample = drv_data->data_width;\n\n\t\tsclk = params_rate(params) * bits_per_sample * params_channels(params);\n\t\tsclk_div = drv_data->sysclk / sclk / 2;\n\n\t\tif ((drv_data->sysclk % sclk != 0) ||\n\t\t    !sclk_div || (sclk_div & ~I2S_I2STIM_VALID_MASK)) {\n\t\t\tdev_warn(i2s_dai->dev, \"invalid SCLK divisor for sysclk %u and sclk %u\\n\",\n\t\t\t\t drv_data->sysclk, sclk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twritel(sclk_div, drv_data->base + I2S_I2STIM_OFFSET);\n\t}\n\n\tchan_id = params_channels(params) / 2;\n\n\twhile (chan_id > 0) {\n\t\treg_off = I2S_CH0_OFFSET + ((chan_id - 1) * 4);\n\t\twritel(chan_id, drv_data->base + reg_off);\n\t\tchan_id--;\n\t}\n\n\treturn 0;\n}\n\nstatic int xlnx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *i2s_dai)\n{\n\tstruct xlnx_i2s_drv_data *drv_data = snd_soc_dai_get_drvdata(i2s_dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\twritel(I2S_CORE_CTRL_ENABLE, drv_data->base + I2S_CORE_CTRL_OFFSET);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\twritel(0, drv_data->base + I2S_CORE_CTRL_OFFSET);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops xlnx_i2s_dai_ops = {\n\t.trigger = xlnx_i2s_trigger,\n\t.set_sysclk = xlnx_i2s_set_sysclk,\n\t.set_clkdiv = xlnx_i2s_set_sclkout_div,\n\t.startup = xlnx_i2s_startup,\n\t.hw_params = xlnx_i2s_hw_params\n};\n\nstatic const struct snd_soc_component_driver xlnx_i2s_component = {\n\t.name = DRV_NAME,\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct of_device_id xlnx_i2s_of_match[] = {\n\t{ .compatible = \"xlnx,i2s-transmitter-1.0\", },\n\t{ .compatible = \"xlnx,i2s-receiver-1.0\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xlnx_i2s_of_match);\n\nstatic int xlnx_i2s_probe(struct platform_device *pdev)\n{\n\tstruct xlnx_i2s_drv_data *drv_data;\n\tint ret;\n\tu32 format;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\n\tdrv_data = devm_kzalloc(&pdev->dev, sizeof(*drv_data), GFP_KERNEL);\n\tif (!drv_data)\n\t\treturn -ENOMEM;\n\n\tdrv_data->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(drv_data->base))\n\t\treturn PTR_ERR(drv_data->base);\n\n\tret = of_property_read_u32(node, \"xlnx,num-channels\", &drv_data->channels);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get supported channels\\n\");\n\t\treturn ret;\n\t}\n\tdrv_data->channels *= 2;\n\n\tret = of_property_read_u32(node, \"xlnx,dwidth\", &drv_data->data_width);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot get data width\\n\");\n\t\treturn ret;\n\t}\n\tswitch (drv_data->data_width) {\n\tcase 16:\n\t\tformat = SNDRV_PCM_FMTBIT_S16_LE;\n\t\tbreak;\n\tcase 24:\n\t\tformat = SNDRV_PCM_FMTBIT_S24_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_device_is_compatible(node, \"xlnx,i2s-transmitter-1.0\")) {\n\t\tdrv_data->dai_drv.name = \"xlnx_i2s_playback\";\n\t\tdrv_data->dai_drv.playback.stream_name = \"Playback\";\n\t\tdrv_data->dai_drv.playback.formats = format;\n\t\tdrv_data->dai_drv.playback.channels_min = drv_data->channels;\n\t\tdrv_data->dai_drv.playback.channels_max = drv_data->channels;\n\t\tdrv_data->dai_drv.playback.rates\t= SNDRV_PCM_RATE_8000_192000;\n\t\tdrv_data->dai_drv.ops = &xlnx_i2s_dai_ops;\n\t} else if (of_device_is_compatible(node, \"xlnx,i2s-receiver-1.0\")) {\n\t\tdrv_data->dai_drv.name = \"xlnx_i2s_capture\";\n\t\tdrv_data->dai_drv.capture.stream_name = \"Capture\";\n\t\tdrv_data->dai_drv.capture.formats = format;\n\t\tdrv_data->dai_drv.capture.channels_min = drv_data->channels;\n\t\tdrv_data->dai_drv.capture.channels_max = drv_data->channels;\n\t\tdrv_data->dai_drv.capture.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tdrv_data->dai_drv.ops = &xlnx_i2s_dai_ops;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\tdrv_data->is_32bit_lrclk = readl(drv_data->base + I2S_CORE_CTRL_OFFSET) &\n\t\t\t\t   I2S_CORE_CTRL_32BIT_LRCLK;\n\n\tdev_set_drvdata(&pdev->dev, drv_data);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &xlnx_i2s_component,\n\t\t\t\t\t      &drv_data->dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"i2s component registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(&pdev->dev, \"%s DAI registered\\n\", drv_data->dai_drv.name);\n\n\treturn ret;\n}\n\nstatic struct platform_driver xlnx_i2s_aud_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = xlnx_i2s_of_match,\n\t},\n\t.probe = xlnx_i2s_probe,\n};\n\nmodule_platform_driver(xlnx_i2s_aud_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Praveen Vuppala  <praveenv@xilinx.com>\");\nMODULE_AUTHOR(\"Maruthi Srinivas Bayyavarapu <maruthis@xilinx.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}