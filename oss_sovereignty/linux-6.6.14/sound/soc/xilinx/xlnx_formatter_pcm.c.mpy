{
  "module_name": "xlnx_formatter_pcm.c",
  "hash_id": "3518d8f23a4b7ee2bb4607b872236867760c78179c327c6986cf6a5bf913793b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/xilinx/xlnx_formatter_pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/sizes.h>\n\n#include <sound/asoundef.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#define DRV_NAME \"xlnx_formatter_pcm\"\n\n#define XLNX_S2MM_OFFSET\t0\n#define XLNX_MM2S_OFFSET\t0x100\n\n#define XLNX_AUD_CORE_CONFIG\t0x4\n#define XLNX_AUD_CTRL\t\t0x10\n#define XLNX_AUD_STS\t\t0x14\n\n#define AUD_CTRL_RESET_MASK\tBIT(1)\n#define AUD_CFG_MM2S_MASK\tBIT(15)\n#define AUD_CFG_S2MM_MASK\tBIT(31)\n\n#define XLNX_AUD_FS_MULTIPLIER\t0x18\n#define XLNX_AUD_PERIOD_CONFIG\t0x1C\n#define XLNX_AUD_BUFF_ADDR_LSB\t0x20\n#define XLNX_AUD_BUFF_ADDR_MSB\t0x24\n#define XLNX_AUD_XFER_COUNT\t0x28\n#define XLNX_AUD_CH_STS_START\t0x2C\n#define XLNX_BYTES_PER_CH\t0x44\n#define XLNX_AUD_ALIGN_BYTES\t64\n\n#define AUD_STS_IOC_IRQ_MASK\tBIT(31)\n#define AUD_STS_CH_STS_MASK\tBIT(29)\n#define AUD_CTRL_IOC_IRQ_MASK\tBIT(13)\n#define AUD_CTRL_TOUT_IRQ_MASK\tBIT(14)\n#define AUD_CTRL_DMA_EN_MASK\tBIT(0)\n\n#define CFG_MM2S_CH_MASK\tGENMASK(11, 8)\n#define CFG_MM2S_CH_SHIFT\t8\n#define CFG_MM2S_XFER_MASK\tGENMASK(14, 13)\n#define CFG_MM2S_XFER_SHIFT\t13\n#define CFG_MM2S_PKG_MASK\tBIT(12)\n\n#define CFG_S2MM_CH_MASK\tGENMASK(27, 24)\n#define CFG_S2MM_CH_SHIFT\t24\n#define CFG_S2MM_XFER_MASK\tGENMASK(30, 29)\n#define CFG_S2MM_XFER_SHIFT\t29\n#define CFG_S2MM_PKG_MASK\tBIT(28)\n\n#define AUD_CTRL_DATA_WIDTH_SHIFT\t16\n#define AUD_CTRL_ACTIVE_CH_SHIFT\t19\n#define PERIOD_CFG_PERIODS_SHIFT\t16\n\n#define PERIODS_MIN\t\t2\n#define PERIODS_MAX\t\t6\n#define PERIOD_BYTES_MIN\t192\n#define PERIOD_BYTES_MAX\t(50 * 1024)\n#define XLNX_PARAM_UNKNOWN\t0\n\nenum bit_depth {\n\tBIT_DEPTH_8,\n\tBIT_DEPTH_16,\n\tBIT_DEPTH_20,\n\tBIT_DEPTH_24,\n\tBIT_DEPTH_32,\n};\n\nstruct xlnx_pcm_drv_data {\n\tvoid __iomem *mmio;\n\tbool s2mm_presence;\n\tbool mm2s_presence;\n\tint s2mm_irq;\n\tint mm2s_irq;\n\tstruct snd_pcm_substream *play_stream;\n\tstruct snd_pcm_substream *capture_stream;\n\tstruct clk *axi_clk;\n\tunsigned int sysclk;\n};\n\n \nstruct xlnx_pcm_stream_param {\n\tvoid __iomem *mmio;\n\tbool interleaved;\n\tu32 xfer_mode;\n\tu32 ch_limit;\n\tu64 buffer_size;\n};\n\nstatic const struct snd_pcm_hardware xlnx_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH | SNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\n\t\t   SNDRV_PCM_FMTBIT_S24_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t.rate_min = 8000,\n\t.rate_max = 192000,\n\t.buffer_bytes_max = PERIODS_MAX * PERIOD_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = PERIOD_BYTES_MAX,\n\t.periods_min = PERIODS_MIN,\n\t.periods_max = PERIODS_MAX,\n};\n\nenum {\n\tAES_TO_AES,\n\tAES_TO_PCM,\n\tPCM_TO_PCM,\n\tPCM_TO_AES\n};\n\nstatic void xlnx_parse_aes_params(u32 chsts_reg1_val, u32 chsts_reg2_val,\n\t\t\t\t  struct device *dev)\n{\n\tu32 padded, srate, bit_depth, status[2];\n\n\tif (chsts_reg1_val & IEC958_AES0_PROFESSIONAL) {\n\t\tstatus[0] = chsts_reg1_val & 0xff;\n\t\tstatus[1] = (chsts_reg1_val >> 16) & 0xff;\n\n\t\tswitch (status[0] & IEC958_AES0_PRO_FS) {\n\t\tcase IEC958_AES0_PRO_FS_44100:\n\t\t\tsrate = 44100;\n\t\t\tbreak;\n\t\tcase IEC958_AES0_PRO_FS_48000:\n\t\t\tsrate = 48000;\n\t\t\tbreak;\n\t\tcase IEC958_AES0_PRO_FS_32000:\n\t\t\tsrate = 32000;\n\t\t\tbreak;\n\t\tcase IEC958_AES0_PRO_FS_NOTID:\n\t\tdefault:\n\t\t\tsrate = XLNX_PARAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (status[1] & IEC958_AES2_PRO_SBITS) {\n\t\tcase IEC958_AES2_PRO_WORDLEN_NOTID:\n\t\tcase IEC958_AES2_PRO_SBITS_20:\n\t\t\tpadded = 0;\n\t\t\tbreak;\n\t\tcase IEC958_AES2_PRO_SBITS_24:\n\t\t\tpadded = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbit_depth = XLNX_PARAM_UNKNOWN;\n\t\t\tgoto log_params;\n\t\t}\n\n\t\tswitch (status[1] & IEC958_AES2_PRO_WORDLEN) {\n\t\tcase IEC958_AES2_PRO_WORDLEN_20_16:\n\t\t\tbit_depth = 16 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES2_PRO_WORDLEN_22_18:\n\t\t\tbit_depth = 18 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES2_PRO_WORDLEN_23_19:\n\t\t\tbit_depth = 19 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES2_PRO_WORDLEN_24_20:\n\t\t\tbit_depth = 20 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES2_PRO_WORDLEN_NOTID:\n\t\tdefault:\n\t\t\tbit_depth = XLNX_PARAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t} else {\n\t\tstatus[0] = (chsts_reg1_val >> 24) & 0xff;\n\t\tstatus[1] = chsts_reg2_val & 0xff;\n\n\t\tswitch (status[0] & IEC958_AES3_CON_FS) {\n\t\tcase IEC958_AES3_CON_FS_44100:\n\t\t\tsrate = 44100;\n\t\t\tbreak;\n\t\tcase IEC958_AES3_CON_FS_48000:\n\t\t\tsrate = 48000;\n\t\t\tbreak;\n\t\tcase IEC958_AES3_CON_FS_32000:\n\t\t\tsrate = 32000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsrate = XLNX_PARAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status[1] & IEC958_AES4_CON_MAX_WORDLEN_24)\n\t\t\tpadded = 4;\n\t\telse\n\t\t\tpadded = 0;\n\n\t\tswitch (status[1] & IEC958_AES4_CON_WORDLEN) {\n\t\tcase IEC958_AES4_CON_WORDLEN_20_16:\n\t\t\tbit_depth = 16 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES4_CON_WORDLEN_22_18:\n\t\t\tbit_depth = 18 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES4_CON_WORDLEN_23_19:\n\t\t\tbit_depth = 19 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES4_CON_WORDLEN_24_20:\n\t\t\tbit_depth = 20 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES4_CON_WORDLEN_21_17:\n\t\t\tbit_depth = 17 + padded;\n\t\t\tbreak;\n\t\tcase IEC958_AES4_CON_WORDLEN_NOTID:\n\t\tdefault:\n\t\t\tbit_depth = XLNX_PARAM_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\nlog_params:\n\tif (srate != XLNX_PARAM_UNKNOWN)\n\t\tdev_info(dev, \"sample rate = %d\\n\", srate);\n\telse\n\t\tdev_info(dev, \"sample rate = unknown\\n\");\n\n\tif (bit_depth != XLNX_PARAM_UNKNOWN)\n\t\tdev_info(dev, \"bit_depth = %d\\n\", bit_depth);\n\telse\n\t\tdev_info(dev, \"bit_depth = unknown\\n\");\n}\n\nstatic int xlnx_formatter_pcm_reset(void __iomem *mmio_base)\n{\n\tu32 val, retries = 0;\n\n\tval = readl(mmio_base + XLNX_AUD_CTRL);\n\tval |= AUD_CTRL_RESET_MASK;\n\twritel(val, mmio_base + XLNX_AUD_CTRL);\n\n\tval = readl(mmio_base + XLNX_AUD_CTRL);\n\t \n\twhile ((val & AUD_CTRL_RESET_MASK) && (retries < 100)) {\n\t\tmdelay(1);\n\t\tretries++;\n\t\tval = readl(mmio_base + XLNX_AUD_CTRL);\n\t}\n\tif (val & AUD_CTRL_RESET_MASK)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void xlnx_formatter_disable_irqs(void __iomem *mmio_base, int stream)\n{\n\tu32 val;\n\n\tval = readl(mmio_base + XLNX_AUD_CTRL);\n\tval &= ~AUD_CTRL_IOC_IRQ_MASK;\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tval &= ~AUD_CTRL_TOUT_IRQ_MASK;\n\n\twritel(val, mmio_base + XLNX_AUD_CTRL);\n}\n\nstatic irqreturn_t xlnx_mm2s_irq_handler(int irq, void *arg)\n{\n\tu32 val;\n\tvoid __iomem *reg;\n\tstruct device *dev = arg;\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(dev);\n\n\treg = adata->mmio + XLNX_MM2S_OFFSET + XLNX_AUD_STS;\n\tval = readl(reg);\n\tif (val & AUD_STS_IOC_IRQ_MASK) {\n\t\twritel(val & AUD_STS_IOC_IRQ_MASK, reg);\n\t\tif (adata->play_stream)\n\t\t\tsnd_pcm_period_elapsed(adata->play_stream);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t xlnx_s2mm_irq_handler(int irq, void *arg)\n{\n\tu32 val;\n\tvoid __iomem *reg;\n\tstruct device *dev = arg;\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(dev);\n\n\treg = adata->mmio + XLNX_S2MM_OFFSET + XLNX_AUD_STS;\n\tval = readl(reg);\n\tif (val & AUD_STS_IOC_IRQ_MASK) {\n\t\twritel(val & AUD_STS_IOC_IRQ_MASK, reg);\n\t\tif (adata->capture_stream)\n\t\t\tsnd_pcm_period_elapsed(adata->capture_stream);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int xlnx_formatter_set_sysclk(struct snd_soc_component *component,\n\t\t\t\t     int clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);\n\n\tadata->sysclk = freq;\n\treturn 0;\n}\n\nstatic int xlnx_formatter_pcm_open(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tint err;\n\tu32 val, data_format_mode;\n\tu32 ch_count_mask, ch_count_shift, data_xfer_mode, data_xfer_shift;\n\tstruct xlnx_pcm_stream_param *stream_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    !adata->mm2s_presence)\n\t\treturn -ENODEV;\n\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t\t !adata->s2mm_presence)\n\t\treturn -ENODEV;\n\n\tstream_data = kzalloc(sizeof(*stream_data), GFP_KERNEL);\n\tif (!stream_data)\n\t\treturn -ENOMEM;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tch_count_mask = CFG_MM2S_CH_MASK;\n\t\tch_count_shift = CFG_MM2S_CH_SHIFT;\n\t\tdata_xfer_mode = CFG_MM2S_XFER_MASK;\n\t\tdata_xfer_shift = CFG_MM2S_XFER_SHIFT;\n\t\tdata_format_mode = CFG_MM2S_PKG_MASK;\n\t\tstream_data->mmio = adata->mmio + XLNX_MM2S_OFFSET;\n\t\tadata->play_stream = substream;\n\n\t} else {\n\t\tch_count_mask = CFG_S2MM_CH_MASK;\n\t\tch_count_shift = CFG_S2MM_CH_SHIFT;\n\t\tdata_xfer_mode = CFG_S2MM_XFER_MASK;\n\t\tdata_xfer_shift = CFG_S2MM_XFER_SHIFT;\n\t\tdata_format_mode = CFG_S2MM_PKG_MASK;\n\t\tstream_data->mmio = adata->mmio + XLNX_S2MM_OFFSET;\n\t\tadata->capture_stream = substream;\n\t}\n\n\tval = readl(adata->mmio + XLNX_AUD_CORE_CONFIG);\n\n\tif (!(val & data_format_mode))\n\t\tstream_data->interleaved = true;\n\n\tstream_data->xfer_mode = (val & data_xfer_mode) >> data_xfer_shift;\n\tstream_data->ch_limit = (val & ch_count_mask) >> ch_count_shift;\n\tdev_info(component->dev,\n\t\t \"stream %d : format = %d mode = %d ch_limit = %d\\n\",\n\t\t substream->stream, stream_data->interleaved,\n\t\t stream_data->xfer_mode, stream_data->ch_limit);\n\n\tsnd_soc_set_runtime_hwparams(substream, &xlnx_pcm_hardware);\n\truntime->private_data = stream_data;\n\n\t \n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t XLNX_AUD_ALIGN_BYTES);\n\tif (err) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unable to set constraint on period bytes\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = snd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t XLNX_AUD_ALIGN_BYTES);\n\tif (err) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unable to set constraint on buffer bytes\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (err < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unable to set constraint on periods to be integer\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tval = readl(stream_data->mmio + XLNX_AUD_CTRL);\n\tval |= AUD_CTRL_IOC_IRQ_MASK;\n\twritel(val, stream_data->mmio + XLNX_AUD_CTRL);\n\n\treturn 0;\n}\n\nstatic int xlnx_formatter_pcm_close(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tint ret;\n\tstruct xlnx_pcm_stream_param *stream_data =\n\t\t\tsubstream->runtime->private_data;\n\n\tret = xlnx_formatter_pcm_reset(stream_data->mmio);\n\tif (ret) {\n\t\tdev_err(component->dev, \"audio formatter reset failed\\n\");\n\t\tgoto err_reset;\n\t}\n\txlnx_formatter_disable_irqs(stream_data->mmio, substream->stream);\n\nerr_reset:\n\tkfree(stream_data);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nxlnx_formatter_pcm_pointer(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tu32 pos;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xlnx_pcm_stream_param *stream_data = runtime->private_data;\n\n\tpos = readl(stream_data->mmio + XLNX_AUD_XFER_COUNT);\n\n\tif (pos >= stream_data->buffer_size)\n\t\tpos = 0;\n\n\treturn bytes_to_frames(runtime, pos);\n}\n\nstatic int xlnx_formatter_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tu32 low, high, active_ch, val, bytes_per_ch, bits_per_sample;\n\tu32 aes_reg1_val, aes_reg2_val;\n\tu64 size;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct xlnx_pcm_stream_param *stream_data = runtime->private_data;\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(component->dev);\n\n\tactive_ch = params_channels(params);\n\tif (active_ch > stream_data->ch_limit)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    adata->sysclk) {\n\t\tunsigned int mclk_fs = adata->sysclk / params_rate(params);\n\n\t\tif (adata->sysclk % params_rate(params) != 0) {\n\t\t\tdev_warn(component->dev, \"sysclk %u not divisible by rate %u\\n\",\n\t\t\t\t adata->sysclk, params_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twritel(mclk_fs, stream_data->mmio + XLNX_AUD_FS_MULTIPLIER);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t    stream_data->xfer_mode == AES_TO_PCM) {\n\t\tval = readl(stream_data->mmio + XLNX_AUD_STS);\n\t\tif (val & AUD_STS_CH_STS_MASK) {\n\t\t\taes_reg1_val = readl(stream_data->mmio +\n\t\t\t\t\t     XLNX_AUD_CH_STS_START);\n\t\t\taes_reg2_val = readl(stream_data->mmio +\n\t\t\t\t\t     XLNX_AUD_CH_STS_START + 0x4);\n\n\t\t\txlnx_parse_aes_params(aes_reg1_val, aes_reg2_val,\n\t\t\t\t\t      component->dev);\n\t\t}\n\t}\n\n\tsize = params_buffer_bytes(params);\n\n\tstream_data->buffer_size = size;\n\n\tlow = lower_32_bits(runtime->dma_addr);\n\thigh = upper_32_bits(runtime->dma_addr);\n\twritel(low, stream_data->mmio + XLNX_AUD_BUFF_ADDR_LSB);\n\twritel(high, stream_data->mmio + XLNX_AUD_BUFF_ADDR_MSB);\n\n\tval = readl(stream_data->mmio + XLNX_AUD_CTRL);\n\tbits_per_sample = params_width(params);\n\tswitch (bits_per_sample) {\n\tcase 8:\n\t\tval |= (BIT_DEPTH_8 << AUD_CTRL_DATA_WIDTH_SHIFT);\n\t\tbreak;\n\tcase 16:\n\t\tval |= (BIT_DEPTH_16 << AUD_CTRL_DATA_WIDTH_SHIFT);\n\t\tbreak;\n\tcase 20:\n\t\tval |= (BIT_DEPTH_20 << AUD_CTRL_DATA_WIDTH_SHIFT);\n\t\tbreak;\n\tcase 24:\n\t\tval |= (BIT_DEPTH_24 << AUD_CTRL_DATA_WIDTH_SHIFT);\n\t\tbreak;\n\tcase 32:\n\t\tval |= (BIT_DEPTH_32 << AUD_CTRL_DATA_WIDTH_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval |= active_ch << AUD_CTRL_ACTIVE_CH_SHIFT;\n\twritel(val, stream_data->mmio + XLNX_AUD_CTRL);\n\n\tval = (params_periods(params) << PERIOD_CFG_PERIODS_SHIFT)\n\t\t| params_period_bytes(params);\n\twritel(val, stream_data->mmio + XLNX_AUD_PERIOD_CONFIG);\n\tbytes_per_ch = DIV_ROUND_UP(params_period_bytes(params), active_ch);\n\twritel(bytes_per_ch, stream_data->mmio + XLNX_BYTES_PER_CH);\n\n\treturn 0;\n}\n\nstatic int xlnx_formatter_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t\t      int cmd)\n{\n\tu32 val;\n\tstruct xlnx_pcm_stream_param *stream_data =\n\t\t\tsubstream->runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tval = readl(stream_data->mmio + XLNX_AUD_CTRL);\n\t\tval |= AUD_CTRL_DMA_EN_MASK;\n\t\twritel(val, stream_data->mmio + XLNX_AUD_CTRL);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tval = readl(stream_data->mmio + XLNX_AUD_CTRL);\n\t\tval &= ~AUD_CTRL_DMA_EN_MASK;\n\t\twritel(val, stream_data->mmio + XLNX_AUD_CTRL);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int xlnx_formatter_pcm_new(struct snd_soc_component *component,\n\t\t\t\t  struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm,\n\t\t\tSNDRV_DMA_TYPE_DEV, component->dev,\n\t\t\txlnx_pcm_hardware.buffer_bytes_max,\n\t\t\txlnx_pcm_hardware.buffer_bytes_max);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver xlnx_asoc_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.set_sysclk\t\t= xlnx_formatter_set_sysclk,\n\t.open\t\t\t= xlnx_formatter_pcm_open,\n\t.close\t\t\t= xlnx_formatter_pcm_close,\n\t.hw_params\t\t= xlnx_formatter_pcm_hw_params,\n\t.trigger\t\t= xlnx_formatter_pcm_trigger,\n\t.pointer\t\t= xlnx_formatter_pcm_pointer,\n\t.pcm_construct\t\t= xlnx_formatter_pcm_new,\n};\n\nstatic int xlnx_formatter_pcm_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 val;\n\tstruct xlnx_pcm_drv_data *aud_drv_data;\n\tstruct device *dev = &pdev->dev;\n\n\taud_drv_data = devm_kzalloc(dev, sizeof(*aud_drv_data), GFP_KERNEL);\n\tif (!aud_drv_data)\n\t\treturn -ENOMEM;\n\n\taud_drv_data->axi_clk = devm_clk_get(dev, \"s_axi_lite_aclk\");\n\tif (IS_ERR(aud_drv_data->axi_clk)) {\n\t\tret = PTR_ERR(aud_drv_data->axi_clk);\n\t\tdev_err(dev, \"failed to get s_axi_lite_aclk(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(aud_drv_data->axi_clk);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"failed to enable s_axi_lite_aclk(%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\taud_drv_data->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(aud_drv_data->mmio)) {\n\t\tdev_err(dev, \"audio formatter ioremap failed\\n\");\n\t\tret = PTR_ERR(aud_drv_data->mmio);\n\t\tgoto clk_err;\n\t}\n\n\tval = readl(aud_drv_data->mmio + XLNX_AUD_CORE_CONFIG);\n\tif (val & AUD_CFG_MM2S_MASK) {\n\t\taud_drv_data->mm2s_presence = true;\n\t\tret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +\n\t\t\t\t\t       XLNX_MM2S_OFFSET);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"audio formatter reset failed\\n\");\n\t\t\tgoto clk_err;\n\t\t}\n\t\txlnx_formatter_disable_irqs(aud_drv_data->mmio +\n\t\t\t\t\t    XLNX_MM2S_OFFSET,\n\t\t\t\t\t    SNDRV_PCM_STREAM_PLAYBACK);\n\n\t\taud_drv_data->mm2s_irq = platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t\t \"irq_mm2s\");\n\t\tif (aud_drv_data->mm2s_irq < 0) {\n\t\t\tret = aud_drv_data->mm2s_irq;\n\t\t\tgoto clk_err;\n\t\t}\n\t\tret = devm_request_irq(dev, aud_drv_data->mm2s_irq,\n\t\t\t\t       xlnx_mm2s_irq_handler, 0,\n\t\t\t\t       \"xlnx_formatter_pcm_mm2s_irq\", dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"xlnx audio mm2s irq request failed\\n\");\n\t\t\tgoto clk_err;\n\t\t}\n\t}\n\tif (val & AUD_CFG_S2MM_MASK) {\n\t\taud_drv_data->s2mm_presence = true;\n\t\tret = xlnx_formatter_pcm_reset(aud_drv_data->mmio +\n\t\t\t\t\t       XLNX_S2MM_OFFSET);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"audio formatter reset failed\\n\");\n\t\t\tgoto clk_err;\n\t\t}\n\t\txlnx_formatter_disable_irqs(aud_drv_data->mmio +\n\t\t\t\t\t    XLNX_S2MM_OFFSET,\n\t\t\t\t\t    SNDRV_PCM_STREAM_CAPTURE);\n\n\t\taud_drv_data->s2mm_irq = platform_get_irq_byname(pdev,\n\t\t\t\t\t\t\t\t \"irq_s2mm\");\n\t\tif (aud_drv_data->s2mm_irq < 0) {\n\t\t\tret = aud_drv_data->s2mm_irq;\n\t\t\tgoto clk_err;\n\t\t}\n\t\tret = devm_request_irq(dev, aud_drv_data->s2mm_irq,\n\t\t\t\t       xlnx_s2mm_irq_handler, 0,\n\t\t\t\t       \"xlnx_formatter_pcm_s2mm_irq\",\n\t\t\t\t       dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"xlnx audio s2mm irq request failed\\n\");\n\t\t\tgoto clk_err;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, aud_drv_data);\n\n\tret = devm_snd_soc_register_component(dev, &xlnx_asoc_component,\n\t\t\t\t\t      NULL, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"pcm platform device register failed\\n\");\n\t\tgoto clk_err;\n\t}\n\n\treturn 0;\n\nclk_err:\n\tclk_disable_unprepare(aud_drv_data->axi_clk);\n\treturn ret;\n}\n\nstatic void xlnx_formatter_pcm_remove(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tstruct xlnx_pcm_drv_data *adata = dev_get_drvdata(&pdev->dev);\n\n\tif (adata->s2mm_presence)\n\t\tret = xlnx_formatter_pcm_reset(adata->mmio + XLNX_S2MM_OFFSET);\n\n\t \n\tif (adata->mm2s_presence)\n\t\tret = xlnx_formatter_pcm_reset(adata->mmio + XLNX_MM2S_OFFSET);\n\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"audio formatter reset failed\\n\");\n\n\tclk_disable_unprepare(adata->axi_clk);\n}\n\nstatic const struct of_device_id xlnx_formatter_pcm_of_match[] = {\n\t{ .compatible = \"xlnx,audio-formatter-1.0\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xlnx_formatter_pcm_of_match);\n\nstatic struct platform_driver xlnx_formatter_pcm_driver = {\n\t.probe\t= xlnx_formatter_pcm_probe,\n\t.remove_new = xlnx_formatter_pcm_remove,\n\t.driver\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table\t= xlnx_formatter_pcm_of_match,\n\t},\n};\n\nmodule_platform_driver(xlnx_formatter_pcm_driver);\nMODULE_AUTHOR(\"Maruthi Srinivas Bayyavarapu <maruthis@xilinx.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}