{
  "module_name": "sdm845.c",
  "hash_id": "8783fa459549586475a9dd2c84dde3f38679ac8e7c9bce1aaeb51212e6c24f69",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/sdm845.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/jack.h>\n#include <sound/soc.h>\n#include <linux/soundwire/sdw.h>\n#include <uapi/linux/input-event-codes.h>\n#include \"common.h\"\n#include \"qdsp6/q6afe.h\"\n#include \"../codecs/rt5663.h\"\n\n#define DRIVER_NAME\t\"sdm845\"\n#define DEFAULT_SAMPLE_RATE_48K\t\t48000\n#define DEFAULT_MCLK_RATE\t\t24576000\n#define TDM_BCLK_RATE\t\t6144000\n#define MI2S_BCLK_RATE\t\t1536000\n#define LEFT_SPK_TDM_TX_MASK    0x30\n#define RIGHT_SPK_TDM_TX_MASK   0xC0\n#define SPK_TDM_RX_MASK         0x03\n#define NUM_TDM_SLOTS           8\n#define SLIM_MAX_TX_PORTS 16\n#define SLIM_MAX_RX_PORTS 13\n#define WCD934X_DEFAULT_MCLK_RATE\t9600000\n\nstruct sdm845_snd_data {\n\tstruct snd_soc_jack jack;\n\tbool jack_setup;\n\tbool slim_port_setup;\n\tbool stream_prepared[AFE_PORT_MAX];\n\tstruct snd_soc_card *card;\n\tuint32_t pri_mi2s_clk_count;\n\tuint32_t sec_mi2s_clk_count;\n\tuint32_t quat_tdm_clk_count;\n\tstruct sdw_stream_runtime *sruntime[AFE_PORT_MAX];\n};\n\nstatic struct snd_soc_jack_pin sdm845_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic unsigned int tdm_slot_offset[8] = {0, 4, 8, 12, 16, 20, 24, 28};\n\nstatic int sdm845_slim_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai;\n\tstruct sdm845_snd_data *pdata = snd_soc_card_get_drvdata(rtd->card);\n\tu32 rx_ch[SLIM_MAX_RX_PORTS], tx_ch[SLIM_MAX_TX_PORTS];\n\tstruct sdw_stream_runtime *sruntime;\n\tu32 rx_ch_cnt = 0, tx_ch_cnt = 0;\n\tint ret = 0, i;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tsruntime = snd_soc_dai_get_stream(codec_dai,\n\t\t\t\t\t\t  substream->stream);\n\t\tif (sruntime != ERR_PTR(-ENOTSUPP))\n\t\t\tpdata->sruntime[cpu_dai->id] = sruntime;\n\n\t\tret = snd_soc_dai_get_channel_map(codec_dai,\n\t\t\t\t&tx_ch_cnt, tx_ch, &rx_ch_cnt, rx_ch);\n\n\t\tif (ret != 0 && ret != -ENOTSUPP) {\n\t\t\tpr_err(\"failed to get codec chan map, err:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t} else if (ret == -ENOTSUPP) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = snd_soc_dai_set_channel_map(cpu_dai, 0, NULL,\n\t\t\t\t\t\t\t  rx_ch_cnt, rx_ch);\n\t\telse\n\t\t\tret = snd_soc_dai_set_channel_map(cpu_dai, tx_ch_cnt,\n\t\t\t\t\t\t\t  tx_ch, 0, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int sdm845_tdm_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai;\n\tint ret = 0, j;\n\tint channels, slot_width;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tslot_width = 16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid param format 0x%x\\n\",\n\t\t\t\t__func__, params_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = params_channels(params);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0, 0x3,\n\t\t\t\t8, slot_width);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->dev, \"%s: failed to set tdm slot, err:%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = snd_soc_dai_set_channel_map(cpu_dai, 0, NULL,\n\t\t\t\tchannels, tdm_slot_offset);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->dev, \"%s: failed to set channel map, err:%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0xf, 0,\n\t\t\t\t8, slot_width);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->dev, \"%s: failed to set tdm slot, err:%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto end;\n\t\t}\n\n\t\tret = snd_soc_dai_set_channel_map(cpu_dai, channels,\n\t\t\t\ttdm_slot_offset, 0, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(rtd->dev, \"%s: failed to set channel map, err:%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tfor_each_rtd_codec_dais(rtd, j, codec_dai) {\n\n\t\tif (!strcmp(codec_dai->component->name_prefix, \"Left\")) {\n\t\t\tret = snd_soc_dai_set_tdm_slot(\n\t\t\t\t\tcodec_dai, LEFT_SPK_TDM_TX_MASK,\n\t\t\t\t\tSPK_TDM_RX_MASK, NUM_TDM_SLOTS,\n\t\t\t\t\tslot_width);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(rtd->dev,\n\t\t\t\t\t\"DEV0 TDM slot err:%d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (!strcmp(codec_dai->component->name_prefix, \"Right\")) {\n\t\t\tret = snd_soc_dai_set_tdm_slot(\n\t\t\t\t\tcodec_dai, RIGHT_SPK_TDM_TX_MASK,\n\t\t\t\t\tSPK_TDM_RX_MASK, NUM_TDM_SLOTS,\n\t\t\t\t\tslot_width);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(rtd->dev,\n\t\t\t\t\t\"DEV1 TDM slot err:%d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\treturn ret;\n}\n\nstatic int sdm845_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret = 0;\n\n\tswitch (cpu_dai->id) {\n\tcase PRIMARY_MI2S_RX:\n\tcase PRIMARY_MI2S_TX:\n\t\t \n\t\trt5663_sel_asrc_clk_src(\n\t\t\tcodec_dai->component,\n\t\t\tRT5663_DA_STEREO_FILTER | RT5663_AD_STEREO_FILTER,\n\t\t\tRT5663_CLK_SEL_I2S1_ASRC);\n\t\tret = snd_soc_dai_set_sysclk(\n\t\t\tcodec_dai, RT5663_SCLK_S_MCLK, DEFAULT_MCLK_RATE,\n\t\t\tSND_SOC_CLOCK_IN);\n\t\tif (ret < 0)\n\t\t\tdev_err(rtd->dev,\n\t\t\t\t\"snd_soc_dai_set_sysclk err = %d\\n\", ret);\n\t\tbreak;\n\tcase QUATERNARY_TDM_RX_0:\n\tcase QUATERNARY_TDM_TX_0:\n\t\tret = sdm845_tdm_snd_hw_params(substream, params);\n\t\tbreak;\n\tcase SLIMBUS_0_RX...SLIMBUS_6_TX:\n\t\tret = sdm845_slim_snd_hw_params(substream, params);\n\t\tbreak;\n\tcase QUATERNARY_MI2S_RX:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid dai id 0x%x\\n\", __func__, cpu_dai->id);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic void sdm845_jack_free(struct snd_jack *jack)\n{\n\tstruct snd_soc_component *component = jack->private_data;\n\n\tsnd_soc_component_set_jack(component, NULL, NULL);\n}\n\nstatic int sdm845_dai_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdm845_snd_data *pdata = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *link = rtd->dai_link;\n\tstruct snd_jack *jack;\n\t \n\tunsigned int rx_ch[SLIM_MAX_RX_PORTS] = {144, 145, 146, 147, 148, 149,\n\t\t\t\t\t150, 151, 152, 153, 154, 155, 156};\n\tunsigned int tx_ch[SLIM_MAX_TX_PORTS] = {128, 129, 130, 131, 132, 133,\n\t\t\t\t\t    134, 135, 136, 137, 138, 139,\n\t\t\t\t\t    140, 141, 142, 143};\n\tint rval, i;\n\n\n\tif (!pdata->jack_setup) {\n\t\trval = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t\t  SND_JACK_HEADSET |\n\t\t\t\t\t\t  SND_JACK_HEADPHONE |\n\t\t\t\t\t\t  SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t  SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t\t  &pdata->jack,\n\t\t\t\t\t\t  sdm845_jack_pins,\n\t\t\t\t\t\t  ARRAY_SIZE(sdm845_jack_pins));\n\n\t\tif (rval < 0) {\n\t\t\tdev_err(card->dev, \"Unable to add Headphone Jack\\n\");\n\t\t\treturn rval;\n\t\t}\n\n\t\tjack = pdata->jack.jack;\n\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\t\tpdata->jack_setup = true;\n\t}\n\n\tswitch (cpu_dai->id) {\n\tcase PRIMARY_MI2S_RX:\n\t\tjack  = pdata->jack.jack;\n\t\tcomponent = codec_dai->component;\n\n\t\tjack->private_data = component;\n\t\tjack->private_free = sdm845_jack_free;\n\t\trval = snd_soc_component_set_jack(component,\n\t\t\t\t\t\t  &pdata->jack, NULL);\n\t\tif (rval != 0 && rval != -ENOTSUPP) {\n\t\t\tdev_warn(card->dev, \"Failed to set jack: %d\\n\", rval);\n\t\t\treturn rval;\n\t\t}\n\t\tbreak;\n\tcase SLIMBUS_0_RX...SLIMBUS_6_TX:\n\t\t \n\t\tif (pdata->slim_port_setup || !link->no_pcm)\n\t\t\treturn 0;\n\n\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t\trval = snd_soc_dai_set_channel_map(codec_dai,\n\t\t\t\t\t\t\t  ARRAY_SIZE(tx_ch),\n\t\t\t\t\t\t\t  tx_ch,\n\t\t\t\t\t\t\t  ARRAY_SIZE(rx_ch),\n\t\t\t\t\t\t\t  rx_ch);\n\t\t\tif (rval != 0 && rval != -ENOTSUPP)\n\t\t\t\treturn rval;\n\n\t\t\tsnd_soc_dai_set_sysclk(codec_dai, 0,\n\t\t\t\t\t       WCD934X_DEFAULT_MCLK_RATE,\n\t\t\t\t\t       SNDRV_PCM_STREAM_PLAYBACK);\n\n\t\t\trval = snd_soc_component_set_jack(codec_dai->component,\n\t\t\t\t\t\t\t  &pdata->jack, NULL);\n\t\t\tif (rval != 0 && rval != -ENOTSUPP) {\n\t\t\t\tdev_warn(card->dev, \"Failed to set jack: %d\\n\", rval);\n\t\t\t\treturn rval;\n\t\t\t}\n\t\t}\n\n\t\tpdata->slim_port_setup = true;\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int sdm845_snd_startup(struct snd_pcm_substream *substream)\n{\n\tunsigned int fmt = SND_SOC_DAIFMT_BP_FP;\n\tunsigned int codec_dai_fmt = SND_SOC_DAIFMT_BC_FC;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sdm845_snd_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint j;\n\tint ret;\n\n\tswitch (cpu_dai->id) {\n\tcase PRIMARY_MI2S_RX:\n\tcase PRIMARY_MI2S_TX:\n\t\tcodec_dai_fmt |= SND_SOC_DAIFMT_NB_NF;\n\t\tif (++(data->pri_mi2s_clk_count) == 1) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_MCLK_1,\n\t\t\t\tDEFAULT_MCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_PRI_MI2S_IBIT,\n\t\t\t\tMI2S_BCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\t\tsnd_soc_dai_set_fmt(cpu_dai, fmt);\n\t\tsnd_soc_dai_set_fmt(codec_dai, codec_dai_fmt);\n\t\tbreak;\n\n\tcase SECONDARY_MI2S_TX:\n\t\tcodec_dai_fmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_I2S;\n\t\tif (++(data->sec_mi2s_clk_count) == 1) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_SEC_MI2S_IBIT,\n\t\t\t\tMI2S_BCLK_RATE,\tSNDRV_PCM_STREAM_CAPTURE);\n\t\t}\n\t\tsnd_soc_dai_set_fmt(cpu_dai, fmt);\n\t\tsnd_soc_dai_set_fmt(codec_dai, codec_dai_fmt);\n\t\tbreak;\n\tcase QUATERNARY_MI2S_RX:\n\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\tQ6AFE_LPASS_CLK_ID_QUAD_MI2S_IBIT,\n\t\t\tMI2S_BCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\t\tsnd_soc_dai_set_fmt(cpu_dai, fmt);\n\n\n\t\tbreak;\n\n\tcase QUATERNARY_TDM_RX_0:\n\tcase QUATERNARY_TDM_TX_0:\n\t\tif (++(data->quat_tdm_clk_count) == 1) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_QUAD_TDM_IBIT,\n\t\t\t\tTDM_BCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\n\t\tcodec_dai_fmt |= SND_SOC_DAIFMT_IB_NF | SND_SOC_DAIFMT_DSP_B;\n\n\t\tfor_each_rtd_codec_dais(rtd, j, codec_dai) {\n\n\t\t\tif (!strcmp(codec_dai->component->name_prefix,\n\t\t\t\t    \"Left\")) {\n\t\t\t\tret = snd_soc_dai_set_fmt(\n\t\t\t\t\t\tcodec_dai, codec_dai_fmt);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(rtd->dev,\n\t\t\t\t\t\t\"Left TDM fmt err:%d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!strcmp(codec_dai->component->name_prefix,\n\t\t\t\t    \"Right\")) {\n\t\t\t\tret = snd_soc_dai_set_fmt(\n\t\t\t\t\t\tcodec_dai, codec_dai_fmt);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(rtd->dev,\n\t\t\t\t\t\t\"Right TDM slot err:%d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SLIMBUS_0_RX...SLIMBUS_6_TX:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: invalid dai id 0x%x\\n\", __func__, cpu_dai->id);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void  sdm845_snd_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sdm845_snd_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase PRIMARY_MI2S_RX:\n\tcase PRIMARY_MI2S_TX:\n\t\tif (--(data->pri_mi2s_clk_count) == 0) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_MCLK_1,\n\t\t\t\t0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_PRI_MI2S_IBIT,\n\t\t\t\t0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\t\tbreak;\n\n\tcase SECONDARY_MI2S_TX:\n\t\tif (--(data->sec_mi2s_clk_count) == 0) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_SEC_MI2S_IBIT,\n\t\t\t\t0, SNDRV_PCM_STREAM_CAPTURE);\n\t\t}\n\t\tbreak;\n\n\tcase QUATERNARY_TDM_RX_0:\n\tcase QUATERNARY_TDM_TX_0:\n\t\tif (--(data->quat_tdm_clk_count) == 0) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\tQ6AFE_LPASS_CLK_ID_QUAD_TDM_IBIT,\n\t\t\t\t0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\t\tbreak;\n\tcase SLIMBUS_0_RX...SLIMBUS_6_TX:\n\tcase QUATERNARY_MI2S_RX:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: invalid dai id 0x%x\\n\", __func__, cpu_dai->id);\n\t\tbreak;\n\t}\n}\n\nstatic int sdm845_snd_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sdm845_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\tint ret;\n\n\tif (!sruntime)\n\t\treturn 0;\n\n\tif (data->stream_prepared[cpu_dai->id]) {\n\t\tsdw_disable_stream(sruntime);\n\t\tsdw_deprepare_stream(sruntime);\n\t\tdata->stream_prepared[cpu_dai->id] = false;\n\t}\n\n\tret = sdw_prepare_stream(sruntime);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = sdw_enable_stream(sruntime);\n\tif (ret) {\n\t\tsdw_deprepare_stream(sruntime);\n\t\treturn ret;\n\t}\n\tdata->stream_prepared[cpu_dai->id] = true;\n\n\treturn ret;\n}\n\nstatic int sdm845_snd_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sdm845_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\tif (sruntime && data->stream_prepared[cpu_dai->id]) {\n\t\tsdw_disable_stream(sruntime);\n\t\tsdw_deprepare_stream(sruntime);\n\t\tdata->stream_prepared[cpu_dai->id] = false;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops sdm845_be_ops = {\n\t.hw_params = sdm845_snd_hw_params,\n\t.hw_free = sdm845_snd_hw_free,\n\t.prepare = sdm845_snd_prepare,\n\t.startup = sdm845_snd_startup,\n\t.shutdown = sdm845_snd_shutdown,\n};\n\nstatic int sdm845_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\n\trate->min = rate->max = DEFAULT_SAMPLE_RATE_48K;\n\tchannels->min = channels->max = 2;\n\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget sdm845_snd_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_SPK(\"Left Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"Right Spk\", NULL),\n\tSND_SOC_DAPM_MIC(\"Int Mic\", NULL),\n};\n\nstatic const struct snd_kcontrol_new sdm845_snd_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic void sdm845_add_ops(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *link;\n\tint i;\n\n\tfor_each_card_prelinks(card, i, link) {\n\t\tif (link->no_pcm == 1) {\n\t\t\tlink->ops = &sdm845_be_ops;\n\t\t\tlink->be_hw_params_fixup = sdm845_be_hw_params_fixup;\n\t\t}\n\t\tlink->init = sdm845_dai_init;\n\t}\n}\n\nstatic int sdm845_snd_platform_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct sdm845_snd_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\t \n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcard->driver_name = DRIVER_NAME;\n\tcard->dapm_widgets = sdm845_snd_widgets;\n\tcard->num_dapm_widgets = ARRAY_SIZE(sdm845_snd_widgets);\n\tcard->controls = sdm845_snd_controls;\n\tcard->num_controls = ARRAY_SIZE(sdm845_snd_controls);\n\tcard->dev = dev;\n\tcard->owner = THIS_MODULE;\n\tdev_set_drvdata(dev, card);\n\tret = qcom_snd_parse_of(card);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->card = card;\n\tsnd_soc_card_set_drvdata(card, data);\n\n\tsdm845_add_ops(card);\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic const struct of_device_id sdm845_snd_device_id[]  = {\n\t{ .compatible = \"qcom,sdm845-sndcard\" },\n\t \n\t{ .compatible = \"qcom,db845c-sndcard\" },\n\t{ .compatible = \"lenovo,yoga-c630-sndcard\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdm845_snd_device_id);\n\nstatic struct platform_driver sdm845_snd_driver = {\n\t.probe = sdm845_snd_platform_probe,\n\t.driver = {\n\t\t.name = \"msm-snd-sdm845\",\n\t\t.of_match_table = sdm845_snd_device_id,\n\t},\n};\nmodule_platform_driver(sdm845_snd_driver);\n\nMODULE_DESCRIPTION(\"sdm845 ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}