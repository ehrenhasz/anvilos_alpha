{
  "module_name": "lpass-apq8016.c",
  "hash_id": "ad47c1d6bdc05626debaeaaa03d01eb76ca999dde125dd3126bd39545e0f5c07",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-apq8016.c",
  "human_readable_source": "\n \n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/apq8016-lpass.h>\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\nstatic struct snd_soc_dai_driver apq8016_lpass_cpu_dai_driver[] = {\n\t[MI2S_PRIMARY] =  {\n\t\t.id = MI2S_PRIMARY,\n\t\t.name = \"Primary MI2S\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"Primary Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t\t.rate_min\t= 8000,\n\t\t\t.rate_max\t= 96000,\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 8,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n\t},\n\t[MI2S_SECONDARY] =  {\n\t\t.id = MI2S_SECONDARY,\n\t\t.name = \"Secondary MI2S\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"Secondary Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t\t.rate_min\t= 8000,\n\t\t\t.rate_max\t= 96000,\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 8,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n\t},\n\t[MI2S_TERTIARY] =  {\n\t\t.id = MI2S_TERTIARY,\n\t\t.name = \"Tertiary MI2S\",\n\t\t.capture = {\n\t\t\t.stream_name\t= \"Tertiary Capture\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t\t.rate_min\t= 8000,\n\t\t\t.rate_max\t= 96000,\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 8,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n\t},\n\t[MI2S_QUATERNARY] =  {\n\t\t.id = MI2S_QUATERNARY,\n\t\t.name = \"Quatenary MI2S\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"Quatenary Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t\t.rate_min\t= 8000,\n\t\t\t.rate_max\t= 96000,\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 8,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name\t= \"Quatenary Capture\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t\t.rate_min\t= 8000,\n\t\t\t.rate_max\t= 96000,\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 8,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n\t},\n};\n\nstatic int apq8016_lpass_alloc_dma_channel(struct lpass_data *drvdata,\n\t\t\t\t\t   int direction, unsigned int dai_id)\n{\n\tstruct lpass_variant *v = drvdata->variant;\n\tint chan = 0;\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tchan = find_first_zero_bit(&drvdata->dma_ch_bit_map,\n\t\t\t\t\tv->rdma_channels);\n\n\t\tif (chan >= v->rdma_channels)\n\t\t\treturn -EBUSY;\n\t} else {\n\t\tchan = find_next_zero_bit(&drvdata->dma_ch_bit_map,\n\t\t\t\t\tv->wrdma_channel_start +\n\t\t\t\t\tv->wrdma_channels,\n\t\t\t\t\tv->wrdma_channel_start);\n\n\t\tif (chan >=  v->wrdma_channel_start + v->wrdma_channels)\n\t\t\treturn -EBUSY;\n\t}\n\n\tset_bit(chan, &drvdata->dma_ch_bit_map);\n\n\treturn chan;\n}\n\nstatic int apq8016_lpass_free_dma_channel(struct lpass_data *drvdata, int chan, unsigned int dai_id)\n{\n\tclear_bit(chan, &drvdata->dma_ch_bit_map);\n\n\treturn 0;\n}\n\nstatic int apq8016_lpass_init(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\tstruct lpass_variant *variant = drvdata->variant;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i;\n\n\n\tdrvdata->clks = devm_kcalloc(dev, variant->num_clks,\n\t\t\t\t     sizeof(*drvdata->clks), GFP_KERNEL);\n\tif (!drvdata->clks)\n\t\treturn -ENOMEM;\n\tdrvdata->num_clks = variant->num_clks;\n\n\tfor (i = 0; i < drvdata->num_clks; i++)\n\t\tdrvdata->clks[i].id = variant->clk_name[i];\n\n\tret = devm_clk_bulk_get(dev, drvdata->num_clks, drvdata->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get clocks %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(drvdata->num_clks, drvdata->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"apq8016 clk_enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdrvdata->ahbix_clk = devm_clk_get(dev, \"ahbix-clk\");\n\tif (IS_ERR(drvdata->ahbix_clk)) {\n\t\tdev_err(dev, \"error getting ahbix-clk: %ld\\n\",\n\t\t\t\tPTR_ERR(drvdata->ahbix_clk));\n\t\tret = PTR_ERR(drvdata->ahbix_clk);\n\t\tgoto err_ahbix_clk;\n\t}\n\n\tret = clk_set_rate(drvdata->ahbix_clk, LPASS_AHBIX_CLOCK_FREQUENCY);\n\tif (ret) {\n\t\tdev_err(dev, \"error setting rate on ahbix_clk: %d\\n\", ret);\n\t\tgoto err_ahbix_clk;\n\t}\n\tdev_dbg(dev, \"set ahbix_clk rate to %lu\\n\",\n\t\t\tclk_get_rate(drvdata->ahbix_clk));\n\n\tret = clk_prepare_enable(drvdata->ahbix_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling ahbix_clk: %d\\n\", ret);\n\t\tgoto err_ahbix_clk;\n\t}\n\n\treturn 0;\n\nerr_ahbix_clk:\n\tclk_bulk_disable_unprepare(drvdata->num_clks, drvdata->clks);\n\treturn ret;\n}\n\nstatic int apq8016_lpass_exit(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\n\tclk_bulk_disable_unprepare(drvdata->num_clks, drvdata->clks);\n\tclk_disable_unprepare(drvdata->ahbix_clk);\n\n\treturn 0;\n}\n\n\nstatic struct lpass_variant apq8016_data = {\n\t.i2sctrl_reg_base\t= 0x1000,\n\t.i2sctrl_reg_stride\t= 0x1000,\n\t.i2s_ports\t\t= 4,\n\t.irq_reg_base\t\t= 0x6000,\n\t.irq_reg_stride\t\t= 0x1000,\n\t.irq_ports\t\t= 3,\n\t.rdma_reg_base\t\t= 0x8400,\n\t.rdma_reg_stride\t= 0x1000,\n\t.rdma_channels\t\t= 2,\n\t.dmactl_audif_start\t= 1,\n\t.wrdma_reg_base\t\t= 0xB000,\n\t.wrdma_reg_stride\t= 0x1000,\n\t.wrdma_channel_start\t= 5,\n\t.wrdma_channels\t\t= 2,\n\t.loopback\t\t= REG_FIELD_ID(0x1000, 15, 15, 4, 0x1000),\n\t.spken\t\t\t= REG_FIELD_ID(0x1000, 14, 14, 4, 0x1000),\n\t.spkmode\t\t= REG_FIELD_ID(0x1000, 10, 13, 4, 0x1000),\n\t.spkmono\t\t= REG_FIELD_ID(0x1000, 9, 9, 4, 0x1000),\n\t.micen\t\t\t= REG_FIELD_ID(0x1000, 8, 8, 4, 0x1000),\n\t.micmode\t\t= REG_FIELD_ID(0x1000, 4, 7, 4, 0x1000),\n\t.micmono\t\t= REG_FIELD_ID(0x1000, 3, 3, 4, 0x1000),\n\t.wssrc\t\t\t= REG_FIELD_ID(0x1000, 2, 2, 4, 0x1000),\n\t.bitwidth\t\t= REG_FIELD_ID(0x1000, 0, 1, 4, 0x1000),\n\n\t.rdma_dyncclk\t\t= REG_FIELD_ID(0x8400, 12, 12, 2, 0x1000),\n\t.rdma_bursten\t\t= REG_FIELD_ID(0x8400, 11, 11, 2, 0x1000),\n\t.rdma_wpscnt\t\t= REG_FIELD_ID(0x8400, 8, 10, 2, 0x1000),\n\t.rdma_intf\t\t= REG_FIELD_ID(0x8400, 4, 7, 2, 0x1000),\n\t.rdma_fifowm\t\t= REG_FIELD_ID(0x8400, 1, 3, 2, 0x1000),\n\t.rdma_enable\t\t= REG_FIELD_ID(0x8400, 0, 0, 2, 0x1000),\n\n\t.wrdma_dyncclk\t\t= REG_FIELD_ID(0xB000, 12, 12, 2, 0x1000),\n\t.wrdma_bursten\t\t= REG_FIELD_ID(0xB000, 11, 11, 2, 0x1000),\n\t.wrdma_wpscnt\t\t= REG_FIELD_ID(0xB000, 8, 10, 2, 0x1000),\n\t.wrdma_intf\t\t= REG_FIELD_ID(0xB000, 4, 7, 2, 0x1000),\n\t.wrdma_fifowm\t\t= REG_FIELD_ID(0xB000, 1, 3, 2, 0x1000),\n\t.wrdma_enable\t\t= REG_FIELD_ID(0xB000, 0, 0, 2, 0x1000),\n\n\t.clk_name\t\t= (const char*[]) {\n\t\t\t\t   \"pcnoc-mport-clk\",\n\t\t\t\t   \"pcnoc-sway-clk\",\n\t\t\t\t  },\n\t.num_clks\t\t= 2,\n\t.dai_driver\t\t= apq8016_lpass_cpu_dai_driver,\n\t.num_dai\t\t= ARRAY_SIZE(apq8016_lpass_cpu_dai_driver),\n\t.dai_osr_clk_names\t= (const char *[]) {\n\t\t\t\t\"mi2s-osr-clk0\",\n\t\t\t\t\"mi2s-osr-clk1\",\n\t\t\t\t\"mi2s-osr-clk2\",\n\t\t\t\t\"mi2s-osr-clk3\",\n\t\t\t\t},\n\t.dai_bit_clk_names\t= (const char *[]) {\n\t\t\t\t\"mi2s-bit-clk0\",\n\t\t\t\t\"mi2s-bit-clk1\",\n\t\t\t\t\"mi2s-bit-clk2\",\n\t\t\t\t\"mi2s-bit-clk3\",\n\t\t\t\t},\n\t.init\t\t\t= apq8016_lpass_init,\n\t.exit\t\t\t= apq8016_lpass_exit,\n\t.alloc_dma_channel\t= apq8016_lpass_alloc_dma_channel,\n\t.free_dma_channel\t= apq8016_lpass_free_dma_channel,\n};\n\nstatic const struct of_device_id apq8016_lpass_cpu_device_id[] __maybe_unused = {\n\t{ .compatible = \"qcom,lpass-cpu-apq8016\", .data = &apq8016_data },\n\t{ .compatible = \"qcom,apq8016-lpass-cpu\", .data = &apq8016_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, apq8016_lpass_cpu_device_id);\n\nstatic struct platform_driver apq8016_lpass_cpu_platform_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"apq8016-lpass-cpu\",\n\t\t.of_match_table\t= of_match_ptr(apq8016_lpass_cpu_device_id),\n\t},\n\t.probe\t= asoc_qcom_lpass_cpu_platform_probe,\n\t.remove\t= asoc_qcom_lpass_cpu_platform_remove,\n};\nmodule_platform_driver(apq8016_lpass_cpu_platform_driver);\n\nMODULE_DESCRIPTION(\"APQ8016 LPASS CPU Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}