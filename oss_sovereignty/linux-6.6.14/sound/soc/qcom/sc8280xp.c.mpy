{
  "module_name": "sc8280xp.c",
  "hash_id": "f63efefa2c03b59dcf3fc1e599128a6877a636f7393debee9886af596c42199f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/sc8280xp.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include <linux/soundwire/sdw.h>\n#include <sound/jack.h>\n#include <linux/input-event-codes.h>\n#include \"qdsp6/q6afe.h\"\n#include \"common.h\"\n#include \"sdw.h\"\n\n#define DRIVER_NAME\t\t\"sc8280xp\"\n\nstruct sc8280xp_snd_data {\n\tbool stream_prepared[AFE_PORT_MAX];\n\tstruct snd_soc_card *card;\n\tstruct sdw_stream_runtime *sruntime[AFE_PORT_MAX];\n\tstruct snd_soc_jack jack;\n\tbool jack_setup;\n};\n\nstatic int sc8280xp_snd_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct sc8280xp_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\n\tswitch (cpu_dai->id) {\n\tcase WSA_CODEC_DMA_RX_0:\n\tcase WSA_CODEC_DMA_RX_1:\n\t\t \n\t\tsnd_soc_limit_volume(card, \"WSA_RX0 Digital Volume\", 84);\n\t\tsnd_soc_limit_volume(card, \"WSA_RX1 Digital Volume\", 84);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn qcom_snd_wcd_jack_setup(rtd, &data->jack, &data->jack_setup);\n}\n\nstatic int sc8280xp_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\n\trate->min = rate->max = 48000;\n\tchannels->min = 2;\n\tchannels->max = 2;\n\tswitch (cpu_dai->id) {\n\tcase TX_CODEC_DMA_TX_0:\n\tcase TX_CODEC_DMA_TX_1:\n\tcase TX_CODEC_DMA_TX_2:\n\tcase TX_CODEC_DMA_TX_3:\n\t\tchannels->min = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int sc8280xp_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sc8280xp_snd_data *pdata = snd_soc_card_get_drvdata(rtd->card);\n\n\treturn qcom_snd_sdw_hw_params(substream, params, &pdata->sruntime[cpu_dai->id]);\n}\n\nstatic int sc8280xp_snd_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sc8280xp_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\treturn qcom_snd_sdw_prepare(substream, sruntime,\n\t\t\t\t    &data->stream_prepared[cpu_dai->id]);\n}\n\nstatic int sc8280xp_snd_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sc8280xp_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\treturn qcom_snd_sdw_hw_free(substream, sruntime,\n\t\t\t\t    &data->stream_prepared[cpu_dai->id]);\n}\n\nstatic const struct snd_soc_ops sc8280xp_be_ops = {\n\t.hw_params = sc8280xp_snd_hw_params,\n\t.hw_free = sc8280xp_snd_hw_free,\n\t.prepare = sc8280xp_snd_prepare,\n};\n\nstatic void sc8280xp_add_be_ops(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *link;\n\tint i;\n\n\tfor_each_card_prelinks(card, i, link) {\n\t\tif (link->no_pcm == 1) {\n\t\t\tlink->init = sc8280xp_snd_init;\n\t\t\tlink->be_hw_params_fixup = sc8280xp_be_hw_params_fixup;\n\t\t\tlink->ops = &sc8280xp_be_ops;\n\t\t}\n\t}\n}\n\nstatic int sc8280xp_platform_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct sc8280xp_snd_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tcard->owner = THIS_MODULE;\n\t \n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcard->dev = dev;\n\tdev_set_drvdata(dev, card);\n\tsnd_soc_card_set_drvdata(card, data);\n\tret = qcom_snd_parse_of(card);\n\tif (ret)\n\t\treturn ret;\n\n\tcard->driver_name = DRIVER_NAME;\n\tsc8280xp_add_be_ops(card);\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic const struct of_device_id snd_sc8280xp_dt_match[] = {\n\t{.compatible = \"qcom,sc8280xp-sndcard\",},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, snd_sc8280xp_dt_match);\n\nstatic struct platform_driver snd_sc8280xp_driver = {\n\t.probe  = sc8280xp_platform_probe,\n\t.driver = {\n\t\t.name = \"snd-sc8280xp\",\n\t\t.of_match_table = snd_sc8280xp_dt_match,\n\t},\n};\nmodule_platform_driver(snd_sc8280xp_driver);\nMODULE_AUTHOR(\"Srinivas Kandagatla <srinivas.kandagatla@linaro.org\");\nMODULE_DESCRIPTION(\"SC8280XP ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}