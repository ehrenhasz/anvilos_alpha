{
  "module_name": "lpass-cpu.c",
  "hash_id": "7ac48bbb4ace2ed7f6db0bd8803e233f320a55028c5874bfe15e140f5f1c63c7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-cpu.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\n#define LPASS_CPU_MAX_MI2S_LINES\t4\n#define LPASS_CPU_I2S_SD0_MASK\t\tBIT(0)\n#define LPASS_CPU_I2S_SD1_MASK\t\tBIT(1)\n#define LPASS_CPU_I2S_SD2_MASK\t\tBIT(2)\n#define LPASS_CPU_I2S_SD3_MASK\t\tBIT(3)\n#define LPASS_CPU_I2S_SD0_1_MASK\tGENMASK(1, 0)\n#define LPASS_CPU_I2S_SD2_3_MASK\tGENMASK(3, 2)\n#define LPASS_CPU_I2S_SD0_1_2_MASK\tGENMASK(2, 0)\n#define LPASS_CPU_I2S_SD0_1_2_3_MASK\tGENMASK(3, 0)\n#define LPASS_REG_READ 1\n#define LPASS_REG_WRITE 0\n\n \nstatic struct snd_pcm_chmap_elem lpass_quad_chmaps[] = {\n\t\t{ .channels = 4,\n\t\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_RL,\n\t\t\t\tSNDRV_CHMAP_FR, SNDRV_CHMAP_RR } },\n\t\t{ }\n};\nstatic int lpass_cpu_init_i2sctl_bitfields(struct device *dev,\n\t\t\tstruct lpaif_i2sctl *i2sctl, struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\n\ti2sctl->loopback = devm_regmap_field_alloc(dev, map, v->loopback);\n\ti2sctl->spken = devm_regmap_field_alloc(dev, map, v->spken);\n\ti2sctl->spkmode = devm_regmap_field_alloc(dev, map, v->spkmode);\n\ti2sctl->spkmono = devm_regmap_field_alloc(dev, map, v->spkmono);\n\ti2sctl->micen = devm_regmap_field_alloc(dev, map, v->micen);\n\ti2sctl->micmode = devm_regmap_field_alloc(dev, map, v->micmode);\n\ti2sctl->micmono = devm_regmap_field_alloc(dev, map, v->micmono);\n\ti2sctl->wssrc = devm_regmap_field_alloc(dev, map, v->wssrc);\n\ti2sctl->bitwidth = devm_regmap_field_alloc(dev, map, v->bitwidth);\n\n\tif (IS_ERR(i2sctl->loopback) || IS_ERR(i2sctl->spken) ||\n\t    IS_ERR(i2sctl->spkmode) || IS_ERR(i2sctl->spkmono) ||\n\t    IS_ERR(i2sctl->micen) || IS_ERR(i2sctl->micmode) ||\n\t    IS_ERR(i2sctl->micmono) || IS_ERR(i2sctl->wssrc) ||\n\t    IS_ERR(i2sctl->bitwidth))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lpass_cpu_daiops_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\tunsigned int freq, int dir)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = clk_set_rate(drvdata->mi2s_osr_clk[dai->driver->id], freq);\n\tif (ret)\n\t\tdev_err(dai->dev, \"error setting mi2s osrclk to %u: %d\\n\",\n\t\t\tfreq, ret);\n\n\treturn ret;\n}\n\nstatic int lpass_cpu_daiops_startup(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = clk_prepare_enable(drvdata->mi2s_osr_clk[dai->driver->id]);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error in enabling mi2s osr clk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare(drvdata->mi2s_bit_clk[dai->driver->id]);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error in enabling mi2s bit clk: %d\\n\", ret);\n\t\tclk_disable_unprepare(drvdata->mi2s_osr_clk[dai->driver->id]);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void lpass_cpu_daiops_shutdown(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct lpaif_i2sctl *i2sctl = drvdata->i2sctl;\n\tunsigned int id = dai->driver->id;\n\n\tclk_disable_unprepare(drvdata->mi2s_osr_clk[dai->driver->id]);\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregmap_fields_write(i2sctl->spken, id, LPAIF_I2SCTL_SPKEN_DISABLE);\n\telse\n\t\tregmap_fields_write(i2sctl->micen, id, LPAIF_I2SCTL_MICEN_DISABLE);\n\n\t \n\tif (drvdata->mi2s_was_prepared[dai->driver->id]) {\n\t\tdrvdata->mi2s_was_prepared[dai->driver->id] = false;\n\t\tclk_disable(drvdata->mi2s_bit_clk[dai->driver->id]);\n\t}\n\n\tclk_unprepare(drvdata->mi2s_bit_clk[dai->driver->id]);\n}\n\nstatic int lpass_cpu_daiops_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct lpaif_i2sctl *i2sctl = drvdata->i2sctl;\n\tunsigned int id = dai->driver->id;\n\tsnd_pcm_format_t format = params_format(params);\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tunsigned int mode;\n\tunsigned int regval;\n\tint bitwidth, ret;\n\n\tbitwidth = snd_pcm_format_width(format);\n\tif (bitwidth < 0) {\n\t\tdev_err(dai->dev, \"invalid bit width given: %d\\n\", bitwidth);\n\t\treturn bitwidth;\n\t}\n\n\tret = regmap_fields_write(i2sctl->loopback, id,\n\t\t\t\t LPAIF_I2SCTL_LOOPBACK_DISABLE);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error updating loopback field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_fields_write(i2sctl->wssrc, id,\n\t\t\t\t LPAIF_I2SCTL_WSSRC_INTERNAL);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error updating wssrc field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (bitwidth) {\n\tcase 16:\n\t\tregval = LPAIF_I2SCTL_BITWIDTH_16;\n\t\tbreak;\n\tcase 24:\n\t\tregval = LPAIF_I2SCTL_BITWIDTH_24;\n\t\tbreak;\n\tcase 32:\n\t\tregval = LPAIF_I2SCTL_BITWIDTH_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"invalid bitwidth given: %d\\n\", bitwidth);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_fields_write(i2sctl->bitwidth, id, regval);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error updating bitwidth field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmode = drvdata->mi2s_playback_sd_mode[id];\n\telse\n\t\tmode = drvdata->mi2s_capture_sd_mode[id];\n\n\tif (!mode) {\n\t\tdev_err(dai->dev, \"no line is assigned\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (channels) {\n\tcase 1:\n\tcase 2:\n\t\tswitch (mode) {\n\t\tcase LPAIF_I2SCTL_MODE_QUAD01:\n\t\tcase LPAIF_I2SCTL_MODE_6CH:\n\t\tcase LPAIF_I2SCTL_MODE_8CH:\n\t\t\tmode = LPAIF_I2SCTL_MODE_SD0;\n\t\t\tbreak;\n\t\tcase LPAIF_I2SCTL_MODE_QUAD23:\n\t\t\tmode = LPAIF_I2SCTL_MODE_SD2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 4:\n\t\tif (mode < LPAIF_I2SCTL_MODE_QUAD01) {\n\t\t\tdev_err(dai->dev, \"cannot configure 4 channels with mode %d\\n\",\n\t\t\t\tmode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase LPAIF_I2SCTL_MODE_6CH:\n\t\tcase LPAIF_I2SCTL_MODE_8CH:\n\t\t\tmode = LPAIF_I2SCTL_MODE_QUAD01;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 6:\n\t\tif (mode < LPAIF_I2SCTL_MODE_6CH) {\n\t\t\tdev_err(dai->dev, \"cannot configure 6 channels with mode %d\\n\",\n\t\t\t\tmode);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (mode) {\n\t\tcase LPAIF_I2SCTL_MODE_8CH:\n\t\t\tmode = LPAIF_I2SCTL_MODE_6CH;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 8:\n\t\tif (mode < LPAIF_I2SCTL_MODE_8CH) {\n\t\t\tdev_err(dai->dev, \"cannot configure 8 channels with mode %d\\n\",\n\t\t\t\tmode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"invalid channels given: %u\\n\", channels);\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = regmap_fields_write(i2sctl->spkmode, id,\n\t\t\t\t\t LPAIF_I2SCTL_SPKMODE(mode));\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"error writing to i2sctl spkr mode: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (channels >= 2)\n\t\t\tret = regmap_fields_write(i2sctl->spkmono, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_SPKMONO_STEREO);\n\t\telse\n\t\t\tret = regmap_fields_write(i2sctl->spkmono, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_SPKMONO_MONO);\n\t} else {\n\t\tret = regmap_fields_write(i2sctl->micmode, id,\n\t\t\t\t\t LPAIF_I2SCTL_MICMODE(mode));\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"error writing to i2sctl mic mode: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (channels >= 2)\n\t\t\tret = regmap_fields_write(i2sctl->micmono, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_MICMONO_STEREO);\n\t\telse\n\t\t\tret = regmap_fields_write(i2sctl->micmono, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_MICMONO_MONO);\n\t}\n\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error writing to i2sctl channels mode: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(drvdata->mi2s_bit_clk[id],\n\t\t\t   rate * bitwidth * 2);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error setting mi2s bitclk to %u: %d\\n\",\n\t\t\trate * bitwidth * 2, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpass_cpu_daiops_trigger(struct snd_pcm_substream *substream,\n\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct lpaif_i2sctl *i2sctl = drvdata->i2sctl;\n\tunsigned int id = dai->driver->id;\n\tint ret = -EINVAL;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tret = regmap_fields_write(i2sctl->spken, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_SPKEN_ENABLE);\n\t\t} else  {\n\t\t\tret = regmap_fields_write(i2sctl->micen, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_MICEN_ENABLE);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_err(dai->dev, \"error writing to i2sctl reg: %d\\n\",\n\t\t\t\tret);\n\n\t\tret = clk_enable(drvdata->mi2s_bit_clk[id]);\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"error in enabling mi2s bit clk: %d\\n\", ret);\n\t\t\tclk_disable(drvdata->mi2s_osr_clk[id]);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tret = regmap_fields_write(i2sctl->spken, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_SPKEN_DISABLE);\n\t\t} else  {\n\t\t\tret = regmap_fields_write(i2sctl->micen, id,\n\t\t\t\t\t\t LPAIF_I2SCTL_MICEN_DISABLE);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_err(dai->dev, \"error writing to i2sctl reg: %d\\n\",\n\t\t\t\tret);\n\n\t\tclk_disable(drvdata->mi2s_bit_clk[dai->driver->id]);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int lpass_cpu_daiops_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct lpaif_i2sctl *i2sctl = drvdata->i2sctl;\n\tunsigned int id = dai->driver->id;\n\tint ret;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tret = regmap_fields_write(i2sctl->spken, id, LPAIF_I2SCTL_SPKEN_ENABLE);\n\telse\n\t\tret = regmap_fields_write(i2sctl->micen, id, LPAIF_I2SCTL_MICEN_ENABLE);\n\n\tif (ret) {\n\t\tdev_err(dai->dev, \"error writing to i2sctl reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!drvdata->mi2s_was_prepared[dai->driver->id]) {\n\t\tret = clk_enable(drvdata->mi2s_bit_clk[id]);\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"error in enabling mi2s bit clk: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdrvdata->mi2s_was_prepared[dai->driver->id] = true;\n\t}\n\treturn 0;\n}\n\nstatic int lpass_cpu_daiops_pcm_new(struct snd_soc_pcm_runtime *rtd, struct snd_soc_dai *dai)\n{\n\tint ret;\n\tstruct snd_soc_dai_driver *drv = dai->driver;\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\n\tif (drvdata->mi2s_playback_sd_mode[dai->id] == LPAIF_I2SCTL_MODE_QUAD01) {\n\t\tret =  snd_pcm_add_chmap_ctls(rtd->pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\tlpass_quad_chmaps, drv->playback.channels_max, 0,\n\t\t\t\tNULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpass_cpu_daiops_probe(struct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\t \n\tret = regmap_write(drvdata->lpaif_map,\n\t\t\tLPAIF_I2SCTL_REG(drvdata->variant, dai->driver->id), 0);\n\tif (ret)\n\t\tdev_err(dai->dev, \"error writing to i2sctl reg: %d\\n\", ret);\n\n\treturn ret;\n}\n\nconst struct snd_soc_dai_ops asoc_qcom_lpass_cpu_dai_ops = {\n\t.probe\t\t= lpass_cpu_daiops_probe,\n\t.set_sysclk\t= lpass_cpu_daiops_set_sysclk,\n\t.startup\t= lpass_cpu_daiops_startup,\n\t.shutdown\t= lpass_cpu_daiops_shutdown,\n\t.hw_params\t= lpass_cpu_daiops_hw_params,\n\t.trigger\t= lpass_cpu_daiops_trigger,\n\t.prepare\t= lpass_cpu_daiops_prepare,\n};\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cpu_dai_ops);\n\nconst struct snd_soc_dai_ops asoc_qcom_lpass_cpu_dai_ops2 = {\n\t.pcm_new\t= lpass_cpu_daiops_pcm_new,\n\t.probe\t\t= lpass_cpu_daiops_probe,\n\t.set_sysclk\t= lpass_cpu_daiops_set_sysclk,\n\t.startup\t= lpass_cpu_daiops_startup,\n\t.shutdown\t= lpass_cpu_daiops_shutdown,\n\t.hw_params\t= lpass_cpu_daiops_hw_params,\n\t.trigger\t= lpass_cpu_daiops_trigger,\n\t.prepare\t= lpass_cpu_daiops_prepare,\n};\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cpu_dai_ops2);\n\nstatic int asoc_qcom_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t   const struct of_phandle_args *args,\n\t\t\t\t   const char **dai_name)\n{\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct lpass_variant *variant = drvdata->variant;\n\tint id = args->args[0];\n\tint ret = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i  < variant->num_dai; i++) {\n\t\tif (variant->dai_driver[i].id == id) {\n\t\t\t*dai_name = variant->dai_driver[i].name;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver lpass_cpu_comp_driver = {\n\t.name = \"lpass-cpu\",\n\t.of_xlate_dai_name = asoc_qcom_of_xlate_dai_name,\n\t.legacy_dai_naming = 1,\n};\n\nstatic bool lpass_cpu_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->i2s_ports; ++i)\n\t\tif (reg == LPAIF_I2SCTL_REG(v, i))\n\t\t\treturn true;\n\n\tfor (i = 0; i < v->irq_ports; ++i) {\n\t\tif (reg == LPAIF_IRQEN_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rdma_channels; ++i) {\n\t\tif (reg == LPAIF_RDMACTL_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMABASE_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMABUFF_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMAPER_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->wrdma_channels; ++i) {\n\t\tif (reg == LPAIF_WRDMACTL_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMABASE_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMABUFF_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMAPER_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool lpass_cpu_regmap_readable(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->i2s_ports; ++i)\n\t\tif (reg == LPAIF_I2SCTL_REG(v, i))\n\t\t\treturn true;\n\n\tfor (i = 0; i < v->irq_ports; ++i) {\n\t\tif (reg == LPAIF_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_IRQEN_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rdma_channels; ++i) {\n\t\tif (reg == LPAIF_RDMACTL_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMABASE_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMABUFF_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMACURR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RDMAPER_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->wrdma_channels; ++i) {\n\t\tif (reg == LPAIF_WRDMACTL_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMABASE_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMABUFF_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMACURR_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_WRDMAPER_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool lpass_cpu_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->irq_ports; ++i) {\n\t\tif (reg == LPAIF_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rdma_channels; ++i)\n\t\tif (reg == LPAIF_RDMACURR_REG(v, i))\n\t\t\treturn true;\n\n\tfor (i = 0; i < v->wrdma_channels; ++i)\n\t\tif (reg == LPAIF_WRDMACURR_REG(v, i + v->wrdma_channel_start))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct regmap_config lpass_cpu_regmap_config = {\n\t.name = \"lpass_cpu\",\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.writeable_reg = lpass_cpu_regmap_writeable,\n\t.readable_reg = lpass_cpu_regmap_readable,\n\t.volatile_reg = lpass_cpu_regmap_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int lpass_hdmi_init_bitfields(struct device *dev, struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int i;\n\tstruct lpass_hdmi_tx_ctl *tx_ctl;\n\tstruct regmap_field *legacy_en;\n\tstruct lpass_vbit_ctrl *vbit_ctl;\n\tstruct regmap_field *tx_parity;\n\tstruct lpass_dp_metadata_ctl *meta_ctl;\n\tstruct lpass_sstream_ctl *sstream_ctl;\n\tstruct regmap_field *ch_msb;\n\tstruct regmap_field *ch_lsb;\n\tstruct lpass_hdmitx_dmactl *tx_dmactl;\n\tint rval;\n\n\ttx_ctl = devm_kzalloc(dev, sizeof(*tx_ctl), GFP_KERNEL);\n\tif (!tx_ctl)\n\t\treturn -ENOMEM;\n\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->soft_reset, tx_ctl->soft_reset);\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->force_reset, tx_ctl->force_reset);\n\tdrvdata->tx_ctl = tx_ctl;\n\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->legacy_en, legacy_en);\n\tdrvdata->hdmitx_legacy_en = legacy_en;\n\n\tvbit_ctl = devm_kzalloc(dev, sizeof(*vbit_ctl), GFP_KERNEL);\n\tif (!vbit_ctl)\n\t\treturn -ENOMEM;\n\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->replace_vbit, vbit_ctl->replace_vbit);\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->vbit_stream, vbit_ctl->vbit_stream);\n\tdrvdata->vbit_ctl = vbit_ctl;\n\n\n\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->calc_en, tx_parity);\n\tdrvdata->hdmitx_parity_calc_en = tx_parity;\n\n\tmeta_ctl = devm_kzalloc(dev, sizeof(*meta_ctl), GFP_KERNEL);\n\tif (!meta_ctl)\n\t\treturn -ENOMEM;\n\n\trval = devm_regmap_field_bulk_alloc(dev, map, &meta_ctl->mute, &v->mute, 7);\n\tif (rval)\n\t\treturn rval;\n\tdrvdata->meta_ctl = meta_ctl;\n\n\tsstream_ctl = devm_kzalloc(dev, sizeof(*sstream_ctl), GFP_KERNEL);\n\tif (!sstream_ctl)\n\t\treturn -ENOMEM;\n\n\trval = devm_regmap_field_bulk_alloc(dev, map, &sstream_ctl->sstream_en, &v->sstream_en, 9);\n\tif (rval)\n\t\treturn rval;\n\n\tdrvdata->sstream_ctl = sstream_ctl;\n\n\tfor (i = 0; i < LPASS_MAX_HDMI_DMA_CHANNELS; i++) {\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->msb_bits, ch_msb);\n\t\tdrvdata->hdmitx_ch_msb[i] = ch_msb;\n\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->lsb_bits, ch_lsb);\n\t\tdrvdata->hdmitx_ch_lsb[i] = ch_lsb;\n\n\t\ttx_dmactl = devm_kzalloc(dev, sizeof(*tx_dmactl), GFP_KERNEL);\n\t\tif (!tx_dmactl)\n\t\t\treturn -ENOMEM;\n\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->use_hw_chs, tx_dmactl->use_hw_chs);\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->use_hw_usr, tx_dmactl->use_hw_usr);\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->hw_chs_sel, tx_dmactl->hw_chs_sel);\n\t\tQCOM_REGMAP_FIELD_ALLOC(dev, map, v->hw_usr_sel, tx_dmactl->hw_usr_sel);\n\t\tdrvdata->hdmi_tx_dmactl[i] = tx_dmactl;\n\t}\n\treturn 0;\n}\n\nstatic bool lpass_hdmi_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tif (reg == LPASS_HDMI_TX_CTL_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_LEGACY_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_VBIT_CTL_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_PARITY_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_DP_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_SSTREAM_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMITX_APP_IRQEN_REG(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMITX_APP_IRQCLEAR_REG(v))\n\t\treturn true;\n\n\tfor (i = 0; i < v->hdmi_rdma_channels; i++) {\n\t\tif (reg == LPASS_HDMI_TX_CH_LSB_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_CH_MSB_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_DMA_ADDR(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->hdmi_rdma_channels; ++i) {\n\t\tif (reg == LPAIF_HDMI_RDMACTL_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMABASE_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMABUFF_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMAPER_REG(v, i))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool lpass_hdmi_regmap_readable(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tif (reg == LPASS_HDMI_TX_CTL_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_LEGACY_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_VBIT_CTL_ADDR(v))\n\t\treturn true;\n\n\tfor (i = 0; i < v->hdmi_rdma_channels; i++) {\n\t\tif (reg == LPASS_HDMI_TX_CH_LSB_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_CH_MSB_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_DMA_ADDR(v, i))\n\t\t\treturn true;\n\t}\n\n\tif (reg == LPASS_HDMI_TX_PARITY_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_DP_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_SSTREAM_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMITX_APP_IRQEN_REG(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMITX_APP_IRQSTAT_REG(v))\n\t\treturn true;\n\n\tfor (i = 0; i < v->hdmi_rdma_channels; ++i) {\n\t\tif (reg == LPAIF_HDMI_RDMACTL_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMABASE_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMABUFF_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMAPER_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_HDMI_RDMACURR_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool lpass_hdmi_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tif (reg == LPASS_HDMITX_APP_IRQSTAT_REG(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_LEGACY_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_VBIT_CTL_ADDR(v))\n\t\treturn true;\n\tif (reg == LPASS_HDMI_TX_PARITY_ADDR(v))\n\t\treturn true;\n\n\tfor (i = 0; i < v->hdmi_rdma_channels; ++i) {\n\t\tif (reg == LPAIF_HDMI_RDMACURR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_DMA_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_CH_LSB_ADDR(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPASS_HDMI_TX_CH_MSB_ADDR(v, i))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic struct regmap_config lpass_hdmi_regmap_config = {\n\t.name = \"lpass_hdmi\",\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.writeable_reg = lpass_hdmi_regmap_writeable,\n\t.readable_reg = lpass_hdmi_regmap_readable,\n\t.volatile_reg = lpass_hdmi_regmap_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic bool __lpass_rxtx_regmap_accessible(struct device *dev, unsigned int reg, bool rw)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->rxtx_irq_ports; ++i) {\n\t\tif (reg == LPAIF_RXTX_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RXTX_IRQEN_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RXTX_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rxtx_rdma_channels; ++i) {\n\t\tif (reg == LPAIF_CDC_RXTX_RDMACTL_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_RDMABASE_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_RDMABUFF_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\t\tif (rw == LPASS_REG_READ) {\n\t\t\tif (reg == LPAIF_CDC_RXTX_RDMACURR_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\t\treturn true;\n\t\t}\n\t\tif (reg == LPAIF_CDC_RXTX_RDMAPER_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_RDMA_INTF_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rxtx_wrdma_channels; ++i) {\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMACTL_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMABASE_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMABUFF_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\t\tif (rw == LPASS_REG_READ) {\n\t\t\tif (reg == LPAIF_CDC_RXTX_WRDMACURR_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\t\treturn true;\n\t\t}\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMAPER_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMA_INTF_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool lpass_rxtx_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\treturn __lpass_rxtx_regmap_accessible(dev, reg, LPASS_REG_WRITE);\n}\n\nstatic bool lpass_rxtx_regmap_readable(struct device *dev, unsigned int reg)\n{\n\treturn __lpass_rxtx_regmap_accessible(dev, reg, LPASS_REG_READ);\n}\n\nstatic bool lpass_rxtx_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->rxtx_irq_ports; ++i) {\n\t\tif (reg == LPAIF_RXTX_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_RXTX_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->rxtx_rdma_channels; ++i)\n\t\tif (reg == LPAIF_CDC_RXTX_RDMACURR_REG(v, i, LPASS_CDC_DMA_RX0))\n\t\t\treturn true;\n\n\tfor (i = 0; i < v->rxtx_wrdma_channels; ++i)\n\t\tif (reg == LPAIF_CDC_RXTX_WRDMACURR_REG(v, i + v->rxtx_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_TX3))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool __lpass_va_regmap_accessible(struct device *dev, unsigned int reg, bool rw)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->va_irq_ports; ++i) {\n\t\tif (reg == LPAIF_VA_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_VA_IRQEN_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_VA_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->va_wrdma_channels; ++i) {\n\t\tif (reg == LPAIF_CDC_VA_WRDMACTL_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_VA_WRDMABASE_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_VA_WRDMABUFF_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t\tif (rw == LPASS_REG_READ) {\n\t\t\tif (reg == LPAIF_CDC_VA_WRDMACURR_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\t\treturn true;\n\t\t}\n\t\tif (reg == LPAIF_CDC_VA_WRDMAPER_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_CDC_VA_WRDMA_INTF_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool lpass_va_regmap_writeable(struct device *dev, unsigned int reg)\n{\n\treturn __lpass_va_regmap_accessible(dev, reg, LPASS_REG_WRITE);\n}\n\nstatic bool lpass_va_regmap_readable(struct device *dev, unsigned int reg)\n{\n\treturn __lpass_va_regmap_accessible(dev, reg, LPASS_REG_READ);\n}\n\nstatic bool lpass_va_regmap_volatile(struct device *dev, unsigned int reg)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint i;\n\n\tfor (i = 0; i < v->va_irq_ports; ++i) {\n\t\tif (reg == LPAIF_VA_IRQCLEAR_REG(v, i))\n\t\t\treturn true;\n\t\tif (reg == LPAIF_VA_IRQSTAT_REG(v, i))\n\t\t\treturn true;\n\t}\n\n\tfor (i = 0; i < v->va_wrdma_channels; ++i) {\n\t\tif (reg == LPAIF_CDC_VA_WRDMACURR_REG(v, i + v->va_wrdma_channel_start,\n\t\t\t\t\t\t\tLPASS_CDC_DMA_VA_TX0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic struct regmap_config lpass_rxtx_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.writeable_reg = lpass_rxtx_regmap_writeable,\n\t.readable_reg = lpass_rxtx_regmap_readable,\n\t.volatile_reg = lpass_rxtx_regmap_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic struct regmap_config lpass_va_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.writeable_reg = lpass_va_regmap_writeable,\n\t.readable_reg = lpass_va_regmap_readable,\n\t.volatile_reg = lpass_va_regmap_volatile,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic unsigned int of_lpass_cpu_parse_sd_lines(struct device *dev,\n\t\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\t\tconst char *name)\n{\n\tunsigned int lines[LPASS_CPU_MAX_MI2S_LINES];\n\tunsigned int sd_line_mask = 0;\n\tint num_lines, i;\n\n\tnum_lines = of_property_read_variable_u32_array(node, name, lines, 0,\n\t\t\t\t\t\t\tLPASS_CPU_MAX_MI2S_LINES);\n\tif (num_lines < 0)\n\t\treturn LPAIF_I2SCTL_MODE_NONE;\n\n\tfor (i = 0; i < num_lines; i++)\n\t\tsd_line_mask |= BIT(lines[i]);\n\n\tswitch (sd_line_mask) {\n\tcase LPASS_CPU_I2S_SD0_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_SD0;\n\tcase LPASS_CPU_I2S_SD1_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_SD1;\n\tcase LPASS_CPU_I2S_SD2_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_SD2;\n\tcase LPASS_CPU_I2S_SD3_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_SD3;\n\tcase LPASS_CPU_I2S_SD0_1_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_QUAD01;\n\tcase LPASS_CPU_I2S_SD2_3_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_QUAD23;\n\tcase LPASS_CPU_I2S_SD0_1_2_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_6CH;\n\tcase LPASS_CPU_I2S_SD0_1_2_3_MASK:\n\t\treturn LPAIF_I2SCTL_MODE_8CH;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported SD line mask: %#x\\n\", sd_line_mask);\n\t\treturn LPAIF_I2SCTL_MODE_NONE;\n\t}\n}\n\nstatic void of_lpass_cpu_parse_dai_data(struct device *dev,\n\t\t\t\t\tstruct lpass_data *data)\n{\n\tstruct device_node *node;\n\tint ret, i, id;\n\n\t \n\tfor (i = 0; i < data->variant->num_dai; i++) {\n\t\tid = data->variant->dai_driver[i].id;\n\t\tdata->mi2s_playback_sd_mode[id] = LPAIF_I2SCTL_MODE_8CH;\n\t\tdata->mi2s_capture_sd_mode[id] = LPAIF_I2SCTL_MODE_8CH;\n\t}\n\n\tfor_each_child_of_node(dev->of_node, node) {\n\t\tret = of_property_read_u32(node, \"reg\", &id);\n\t\tif (ret || id < 0) {\n\t\t\tdev_err(dev, \"valid dai id not found: %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\t\tif (id == LPASS_DP_RX) {\n\t\t\tdata->hdmi_port_enable = 1;\n\t\t} else if (is_cdc_dma_port(id)) {\n\t\t\tdata->codec_dma_enable = 1;\n\t\t} else {\n\t\t\tdata->mi2s_playback_sd_mode[id] =\n\t\t\t\tof_lpass_cpu_parse_sd_lines(dev, node,\n\t\t\t\t\t\t\t    \"qcom,playback-sd-lines\");\n\t\t\tdata->mi2s_capture_sd_mode[id] =\n\t\t\t\tof_lpass_cpu_parse_sd_lines(dev, node,\n\t\t\t\t\t\t    \"qcom,capture-sd-lines\");\n\t\t}\n\t}\n}\n\nstatic int of_lpass_cdc_dma_clks_parse(struct device *dev,\n\t\t\t\t\tstruct lpass_data *data)\n{\n\tdata->codec_mem0 = devm_clk_get(dev, \"audio_cc_codec_mem0\");\n\tif (IS_ERR(data->codec_mem0))\n\t\treturn PTR_ERR(data->codec_mem0);\n\n\tdata->codec_mem1 = devm_clk_get(dev, \"audio_cc_codec_mem1\");\n\tif (IS_ERR(data->codec_mem1))\n\t\treturn PTR_ERR(data->codec_mem1);\n\n\tdata->codec_mem2 = devm_clk_get(dev, \"audio_cc_codec_mem2\");\n\tif (IS_ERR(data->codec_mem2))\n\t\treturn PTR_ERR(data->codec_mem2);\n\n\tdata->va_mem0 = devm_clk_get(dev, \"aon_cc_va_mem0\");\n\tif (IS_ERR(data->va_mem0))\n\t\treturn PTR_ERR(data->va_mem0);\n\n\treturn 0;\n}\n\nint asoc_qcom_lpass_cpu_platform_probe(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata;\n\tstruct device_node *dsp_of_node;\n\tstruct resource *res;\n\tstruct lpass_variant *variant;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tint ret, i, dai_id;\n\n\tdsp_of_node = of_parse_phandle(pdev->dev.of_node, \"qcom,adsp\", 0);\n\tif (dsp_of_node) {\n\t\tdev_err(dev, \"DSP exists and holds audio resources\\n\");\n\t\tof_node_put(dsp_of_node);\n\t\treturn -EBUSY;\n\t}\n\n\tdrvdata = devm_kzalloc(dev, sizeof(struct lpass_data), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, drvdata);\n\n\tmatch = of_match_device(dev->driver->of_match_table, dev);\n\tif (!match || !match->data)\n\t\treturn -EINVAL;\n\n\tif (of_device_is_compatible(dev->of_node, \"qcom,lpass-cpu-apq8016\")) {\n\t\tdev_warn(dev, \"%s compatible is deprecated\\n\",\n\t\t\t match->compatible);\n\t}\n\n\tdrvdata->variant = (struct lpass_variant *)match->data;\n\tvariant = drvdata->variant;\n\n\tof_lpass_cpu_parse_dai_data(dev, drvdata);\n\n\tif (drvdata->codec_dma_enable) {\n\t\tdrvdata->rxtx_lpaif =\n\t\t\t\tdevm_platform_ioremap_resource_byname(pdev, \"lpass-rxtx-lpaif\");\n\t\tif (IS_ERR(drvdata->rxtx_lpaif))\n\t\t\treturn PTR_ERR(drvdata->rxtx_lpaif);\n\n\t\tdrvdata->va_lpaif = devm_platform_ioremap_resource_byname(pdev, \"lpass-va-lpaif\");\n\t\tif (IS_ERR(drvdata->va_lpaif))\n\t\t\treturn PTR_ERR(drvdata->va_lpaif);\n\n\t\tlpass_rxtx_regmap_config.max_register = LPAIF_CDC_RXTX_WRDMAPER_REG(variant,\n\t\t\t\t\tvariant->rxtx_wrdma_channels +\n\t\t\t\t\tvariant->rxtx_wrdma_channel_start, LPASS_CDC_DMA_TX3);\n\n\t\tdrvdata->rxtx_lpaif_map = devm_regmap_init_mmio(dev, drvdata->rxtx_lpaif,\n\t\t\t\t\t&lpass_rxtx_regmap_config);\n\t\tif (IS_ERR(drvdata->rxtx_lpaif_map))\n\t\t\treturn PTR_ERR(drvdata->rxtx_lpaif_map);\n\n\t\tlpass_va_regmap_config.max_register = LPAIF_CDC_VA_WRDMAPER_REG(variant,\n\t\t\t\t\tvariant->va_wrdma_channels +\n\t\t\t\t\tvariant->va_wrdma_channel_start, LPASS_CDC_DMA_VA_TX0);\n\n\t\tdrvdata->va_lpaif_map = devm_regmap_init_mmio(dev, drvdata->va_lpaif,\n\t\t\t\t\t&lpass_va_regmap_config);\n\t\tif (IS_ERR(drvdata->va_lpaif_map))\n\t\t\treturn PTR_ERR(drvdata->va_lpaif_map);\n\n\t\tret = of_lpass_cdc_dma_clks_parse(dev, drvdata);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to get cdc dma clocks %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"lpass-rxtx-cdc-dma-lpm\");\n\t\tdrvdata->rxtx_cdc_dma_lpm_buf = res->start;\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"lpass-va-cdc-dma-lpm\");\n\t\tdrvdata->va_cdc_dma_lpm_buf = res->start;\n\t}\n\n\tdrvdata->lpaif = devm_platform_ioremap_resource_byname(pdev, \"lpass-lpaif\");\n\tif (IS_ERR(drvdata->lpaif))\n\t\treturn PTR_ERR(drvdata->lpaif);\n\n\tlpass_cpu_regmap_config.max_register = LPAIF_WRDMAPER_REG(variant,\n\t\t\t\t\t\tvariant->wrdma_channels +\n\t\t\t\t\t\tvariant->wrdma_channel_start);\n\n\tdrvdata->lpaif_map = devm_regmap_init_mmio(dev, drvdata->lpaif,\n\t\t\t&lpass_cpu_regmap_config);\n\tif (IS_ERR(drvdata->lpaif_map)) {\n\t\tdev_err(dev, \"error initializing regmap: %ld\\n\",\n\t\t\tPTR_ERR(drvdata->lpaif_map));\n\t\treturn PTR_ERR(drvdata->lpaif_map);\n\t}\n\n\tif (drvdata->hdmi_port_enable) {\n\t\tdrvdata->hdmiif = devm_platform_ioremap_resource_byname(pdev, \"lpass-hdmiif\");\n\t\tif (IS_ERR(drvdata->hdmiif))\n\t\t\treturn PTR_ERR(drvdata->hdmiif);\n\n\t\tlpass_hdmi_regmap_config.max_register = LPAIF_HDMI_RDMAPER_REG(variant,\n\t\t\t\t\tvariant->hdmi_rdma_channels - 1);\n\t\tdrvdata->hdmiif_map = devm_regmap_init_mmio(dev, drvdata->hdmiif,\n\t\t\t\t\t&lpass_hdmi_regmap_config);\n\t\tif (IS_ERR(drvdata->hdmiif_map)) {\n\t\t\tdev_err(dev, \"error initializing regmap: %ld\\n\",\n\t\t\tPTR_ERR(drvdata->hdmiif_map));\n\t\t\treturn PTR_ERR(drvdata->hdmiif_map);\n\t\t}\n\t}\n\n\tif (variant->init) {\n\t\tret = variant->init(pdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"error initializing variant: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < variant->num_dai; i++) {\n\t\tdai_id = variant->dai_driver[i].id;\n\t\tif (dai_id == LPASS_DP_RX || is_cdc_dma_port(dai_id))\n\t\t\tcontinue;\n\n\t\tdrvdata->mi2s_osr_clk[dai_id] = devm_clk_get_optional(dev,\n\t\t\t\t\t     variant->dai_osr_clk_names[i]);\n\t\tdrvdata->mi2s_bit_clk[dai_id] = devm_clk_get(dev,\n\t\t\t\t\t\tvariant->dai_bit_clk_names[i]);\n\t\tif (IS_ERR(drvdata->mi2s_bit_clk[dai_id])) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"error getting %s: %ld\\n\",\n\t\t\t\tvariant->dai_bit_clk_names[i],\n\t\t\t\tPTR_ERR(drvdata->mi2s_bit_clk[dai_id]));\n\t\t\treturn PTR_ERR(drvdata->mi2s_bit_clk[dai_id]);\n\t\t}\n\t\tif (drvdata->mi2s_playback_sd_mode[dai_id] ==\n\t\t\tLPAIF_I2SCTL_MODE_QUAD01) {\n\t\t\tvariant->dai_driver[dai_id].playback.channels_min = 4;\n\t\t\tvariant->dai_driver[dai_id].playback.channels_max = 4;\n\t\t}\n\t}\n\n\t \n\tdrvdata->i2sctl = devm_kzalloc(&pdev->dev, sizeof(struct lpaif_i2sctl),\n\t\t\t\t\tGFP_KERNEL);\n\n\t \n\tret = lpass_cpu_init_i2sctl_bitfields(dev, drvdata->i2sctl,\n\t\t\t\t\t\tdrvdata->lpaif_map);\n\tif (ret) {\n\t\tdev_err(dev, \"error init i2sctl field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->hdmi_port_enable) {\n\t\tret = lpass_hdmi_init_bitfields(dev, drvdata->hdmiif_map);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s error  hdmi init failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t\t\t      &lpass_cpu_comp_driver,\n\t\t\t\t\t      variant->dai_driver,\n\t\t\t\t\t      variant->num_dai);\n\tif (ret) {\n\t\tdev_err(dev, \"error registering cpu driver: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = asoc_qcom_lpass_platform_register(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"error registering platform driver: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cpu_platform_probe);\n\nint asoc_qcom_lpass_cpu_platform_remove(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\n\tif (drvdata->variant->exit)\n\t\tdrvdata->variant->exit(pdev);\n\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cpu_platform_remove);\n\nvoid asoc_qcom_lpass_cpu_platform_shutdown(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\n\tif (drvdata->variant->exit)\n\t\tdrvdata->variant->exit(pdev);\n\n}\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cpu_platform_shutdown);\n\nMODULE_DESCRIPTION(\"QTi LPASS CPU Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}