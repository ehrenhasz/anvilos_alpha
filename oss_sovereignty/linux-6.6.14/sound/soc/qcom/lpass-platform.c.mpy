{
  "module_name": "lpass-platform.c",
  "hash_id": "07a9b0a7d60ee0248a1d79a971b02e57d2c010392fc23bb60ffe3d4849594404",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-platform.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\n#define DRV_NAME \"lpass-platform\"\n\n#define LPASS_PLATFORM_BUFFER_SIZE\t(24 *  2 * 1024)\n#define LPASS_PLATFORM_PERIODS\t\t2\n#define LPASS_RXTX_CDC_DMA_LPM_BUFF_SIZE (8 * 1024)\n#define LPASS_VA_CDC_DMA_LPM_BUFF_SIZE (12 * 1024)\n#define LPASS_CDC_DMA_REGISTER_FIELDS_MAX 15\n\nstatic const struct snd_pcm_hardware lpass_platform_pcm_hardware = {\n\t.info\t\t\t=\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats\t\t=\tSNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t.rates\t\t\t=\tSNDRV_PCM_RATE_8000_192000,\n\t.rate_min\t\t=\t8000,\n\t.rate_max\t\t=\t192000,\n\t.channels_min\t\t=\t1,\n\t.channels_max\t\t=\t8,\n\t.buffer_bytes_max\t=\tLPASS_PLATFORM_BUFFER_SIZE,\n\t.period_bytes_max\t=\tLPASS_PLATFORM_BUFFER_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.period_bytes_min\t=\tLPASS_PLATFORM_BUFFER_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.periods_min\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.periods_max\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.fifo_size\t\t=\t0,\n};\n\nstatic const struct snd_pcm_hardware lpass_platform_rxtx_hardware = {\n\t.info\t\t\t=\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats\t\t=\tSNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t.rates\t\t\t=\tSNDRV_PCM_RATE_8000_192000,\n\t.rate_min\t\t=\t8000,\n\t.rate_max\t\t=\t192000,\n\t.channels_min\t\t=\t1,\n\t.channels_max\t\t=\t8,\n\t.buffer_bytes_max\t=\tLPASS_RXTX_CDC_DMA_LPM_BUFF_SIZE,\n\t.period_bytes_max\t=\tLPASS_RXTX_CDC_DMA_LPM_BUFF_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.period_bytes_min\t=\tLPASS_RXTX_CDC_DMA_LPM_BUFF_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.periods_min\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.periods_max\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.fifo_size\t\t=\t0,\n};\n\nstatic const struct snd_pcm_hardware lpass_platform_va_hardware = {\n\t.info\t\t\t=\tSNDRV_PCM_INFO_MMAP |\n\t\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\t\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats\t\t=\tSNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t.rates\t\t\t=\tSNDRV_PCM_RATE_8000_192000,\n\t.rate_min\t\t=\t8000,\n\t.rate_max\t\t=\t192000,\n\t.channels_min\t\t=\t1,\n\t.channels_max\t\t=\t8,\n\t.buffer_bytes_max\t=\tLPASS_VA_CDC_DMA_LPM_BUFF_SIZE,\n\t.period_bytes_max\t=\tLPASS_VA_CDC_DMA_LPM_BUFF_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.period_bytes_min\t=\tLPASS_VA_CDC_DMA_LPM_BUFF_SIZE /\n\t\t\t\t\t\tLPASS_PLATFORM_PERIODS,\n\t.periods_min\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.periods_max\t\t=\tLPASS_PLATFORM_PERIODS,\n\t.fifo_size\t\t=\t0,\n};\n\nstatic int lpass_platform_alloc_rxtx_dmactl_fields(struct device *dev,\n\t\t\t\t\t struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *rd_dmactl, *wr_dmactl;\n\tint rval;\n\n\trd_dmactl = devm_kzalloc(dev, sizeof(*rd_dmactl), GFP_KERNEL);\n\tif (!rd_dmactl)\n\t\treturn -ENOMEM;\n\n\twr_dmactl = devm_kzalloc(dev, sizeof(*wr_dmactl), GFP_KERNEL);\n\tif (!wr_dmactl)\n\t\treturn -ENOMEM;\n\n\tdrvdata->rxtx_rd_dmactl = rd_dmactl;\n\tdrvdata->rxtx_wr_dmactl = wr_dmactl;\n\n\trval = devm_regmap_field_bulk_alloc(dev, map, &rd_dmactl->intf,\n\t\t\t\t\t    &v->rxtx_rdma_intf, LPASS_CDC_DMA_REGISTER_FIELDS_MAX);\n\tif (rval)\n\t\treturn rval;\n\n\treturn devm_regmap_field_bulk_alloc(dev, map, &wr_dmactl->intf,\n\t\t\t\t\t    &v->rxtx_wrdma_intf, LPASS_CDC_DMA_REGISTER_FIELDS_MAX);\n}\n\nstatic int lpass_platform_alloc_va_dmactl_fields(struct device *dev,\n\t\t\t\t\t struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *wr_dmactl;\n\n\twr_dmactl = devm_kzalloc(dev, sizeof(*wr_dmactl), GFP_KERNEL);\n\tif (!wr_dmactl)\n\t\treturn -ENOMEM;\n\n\tdrvdata->va_wr_dmactl = wr_dmactl;\n\treturn devm_regmap_field_bulk_alloc(dev, map, &wr_dmactl->intf,\n\t\t\t\t\t    &v->va_wrdma_intf, LPASS_CDC_DMA_REGISTER_FIELDS_MAX);\n}\n\n\nstatic int lpass_platform_alloc_dmactl_fields(struct device *dev,\n\t\t\t\t\t struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *rd_dmactl, *wr_dmactl;\n\tint rval;\n\n\tdrvdata->rd_dmactl = devm_kzalloc(dev, sizeof(struct lpaif_dmactl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (drvdata->rd_dmactl == NULL)\n\t\treturn -ENOMEM;\n\n\tdrvdata->wr_dmactl = devm_kzalloc(dev, sizeof(struct lpaif_dmactl),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (drvdata->wr_dmactl == NULL)\n\t\treturn -ENOMEM;\n\n\trd_dmactl = drvdata->rd_dmactl;\n\twr_dmactl = drvdata->wr_dmactl;\n\n\trval = devm_regmap_field_bulk_alloc(dev, map, &rd_dmactl->intf,\n\t\t\t\t\t    &v->rdma_intf, 6);\n\tif (rval)\n\t\treturn rval;\n\n\treturn devm_regmap_field_bulk_alloc(dev, map, &wr_dmactl->intf,\n\t\t\t\t\t    &v->wrdma_intf, 6);\n}\n\nstatic int lpass_platform_alloc_hdmidmactl_fields(struct device *dev,\n\t\t\t\t\t struct regmap *map)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *rd_dmactl;\n\n\trd_dmactl = devm_kzalloc(dev, sizeof(struct lpaif_dmactl), GFP_KERNEL);\n\tif (rd_dmactl == NULL)\n\t\treturn -ENOMEM;\n\n\tdrvdata->hdmi_rd_dmactl = rd_dmactl;\n\n\treturn devm_regmap_field_bulk_alloc(dev, map, &rd_dmactl->bursten,\n\t\t\t\t\t    &v->hdmi_rdma_bursten, 8);\n}\n\nstatic int lpass_platform_pcmops_open(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint ret, dma_ch, dir = substream->stream;\n\tstruct lpass_pcm_data *data;\n\tstruct regmap *map;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tcomponent->id = dai_id;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->i2s_port = cpu_dai->driver->id;\n\truntime->private_data = data;\n\n\tif (v->alloc_dma_channel)\n\t\tdma_ch = v->alloc_dma_channel(drvdata, dir, dai_id);\n\telse\n\t\tdma_ch = 0;\n\n\tif (dma_ch < 0) {\n\t\tkfree(data);\n\t\treturn dma_ch;\n\t}\n\n\tswitch (dai_id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\t\tmap = drvdata->lpaif_map;\n\t\tdrvdata->substream[dma_ch] = substream;\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tmap = drvdata->hdmiif_map;\n\t\tdrvdata->hdmi_substream[dma_ch] = substream;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tmap = drvdata->rxtx_lpaif_map;\n\t\tdrvdata->rxtx_substream[dma_ch] = substream;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tmap = drvdata->va_lpaif_map;\n\t\tdrvdata->va_substream[dma_ch] = substream;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata->dma_ch = dma_ch;\n\tswitch (dai_id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\tcase LPASS_DP_RX:\n\t\tret = regmap_write(map, LPAIF_DMACTL_REG(v, dma_ch, dir, data->i2s_port), 0);\n\t\tif (ret) {\n\t\t\tkfree(data);\n\t\t\tdev_err(soc_runtime->dev, \"error writing to rdmactl reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tsnd_soc_set_runtime_hwparams(substream, &lpass_platform_pcm_hardware);\n\t\truntime->dma_bytes = lpass_platform_pcm_hardware.buffer_bytes_max;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tsnd_soc_set_runtime_hwparams(substream, &lpass_platform_rxtx_hardware);\n\t\truntime->dma_bytes = lpass_platform_rxtx_hardware.buffer_bytes_max;\n\t\tsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tsnd_soc_set_runtime_hwparams(substream, &lpass_platform_va_hardware);\n\t\truntime->dma_bytes = lpass_platform_va_hardware.buffer_bytes_max;\n\t\tsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tkfree(data);\n\t\tdev_err(soc_runtime->dev, \"setting constraints failed: %d\\n\",\n\t\t\tret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpass_platform_pcmops_close(struct snd_soc_component *component,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpass_pcm_data *data;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tdata = runtime->private_data;\n\n\tswitch (dai_id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\t\tdrvdata->substream[data->dma_ch] = NULL;\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tdrvdata->hdmi_substream[data->dma_ch] = NULL;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tdrvdata->rxtx_substream[data->dma_ch] = NULL;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tdrvdata->va_substream[data->dma_ch] = NULL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (v->free_dma_channel)\n\t\tv->free_dma_channel(drvdata, data->dma_ch, dai_id);\n\n\tkfree(data);\n\treturn 0;\n}\n\nstatic struct lpaif_dmactl *__lpass_get_dmactl_handle(const struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_component *component)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct lpaif_dmactl *dmactl = NULL;\n\n\tswitch (cpu_dai->driver->id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tdmactl = drvdata->rd_dmactl;\n\t\telse\n\t\t\tdmactl = drvdata->wr_dmactl;\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tdmactl = drvdata->hdmi_rd_dmactl;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\tdmactl = drvdata->rxtx_rd_dmactl;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tdmactl = drvdata->rxtx_wr_dmactl;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tdmactl = drvdata->va_wr_dmactl;\n\t\tbreak;\n\t}\n\n\treturn dmactl;\n}\n\nstatic int __lpass_get_id(const struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_component *component)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tint id;\n\n\tswitch (cpu_dai->driver->id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tid = pcm_data->dma_ch;\n\t\telse\n\t\t\tid = pcm_data->dma_ch - v->wrdma_channel_start;\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tid = pcm_data->dma_ch;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\tid = pcm_data->dma_ch;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tid = pcm_data->dma_ch - v->rxtx_wrdma_channel_start;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tid = pcm_data->dma_ch - v->va_wrdma_channel_start;\n\t\tbreak;\n\t}\n\n\treturn id;\n}\n\nstatic struct regmap *__lpass_get_regmap_handle(const struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_component *component)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map = NULL;\n\n\tswitch (cpu_dai->driver->id) {\n\tcase MI2S_PRIMARY ... MI2S_QUINARY:\n\t\tmap = drvdata->lpaif_map;\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tmap = drvdata->hdmiif_map;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tmap = drvdata->rxtx_lpaif_map;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tmap = drvdata->va_lpaif_map;\n\t\tbreak;\n\t}\n\n\treturn map;\n}\n\nstatic int lpass_platform_pcmops_hw_params(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tsnd_pcm_format_t format = params_format(params);\n\tunsigned int channels = params_channels(params);\n\tunsigned int regval;\n\tstruct lpaif_dmactl *dmactl;\n\tint id;\n\tint bitwidth;\n\tint ret, dma_port = pcm_data->i2s_port + v->dmactl_audif_start;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tdmactl = __lpass_get_dmactl_handle(substream, component);\n\tid = __lpass_get_id(substream, component);\n\n\tbitwidth = snd_pcm_format_width(format);\n\tif (bitwidth < 0) {\n\t\tdev_err(soc_runtime->dev, \"invalid bit width given: %d\\n\",\n\t\t\t\tbitwidth);\n\t\treturn bitwidth;\n\t}\n\n\tret = regmap_fields_write(dmactl->bursten, id, LPAIF_DMACTL_BURSTEN_INCR4);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error updating bursten field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_fields_write(dmactl->fifowm, id, LPAIF_DMACTL_FIFOWM_8);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error updating fifowm field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (dai_id) {\n\tcase LPASS_DP_RX:\n\t\tret = regmap_fields_write(dmactl->burst8, id,\n\t\t\t\t\t\t\tLPAIF_DMACTL_BURSTEN_INCR4);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error updating burst8en field: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_fields_write(dmactl->burst16, id,\n\t\t\t\t\t\t\tLPAIF_DMACTL_BURSTEN_INCR4);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error updating burst16en field: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_fields_write(dmactl->dynburst, id,\n\t\t\t\t\t\t\tLPAIF_DMACTL_BURSTEN_INCR4);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error updating dynbursten field: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase MI2S_PRIMARY:\n\tcase MI2S_SECONDARY:\n\tcase MI2S_TERTIARY:\n\tcase MI2S_QUATERNARY:\n\tcase MI2S_QUINARY:\n\t\tret = regmap_fields_write(dmactl->intf, id,\n\t\t\t\t\t\tLPAIF_DMACTL_AUDINTF(dma_port));\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error updating audio interface field: %d\\n\",\n\t\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX0:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"%s: invalid  interface: %d\\n\", __func__, dai_id);\n\t\tbreak;\n\t}\n\tswitch (bitwidth) {\n\tcase 16:\n\t\tswitch (channels) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tregval = LPAIF_DMACTL_WPSCNT_ONE;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tregval = LPAIF_DMACTL_WPSCNT_TWO;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tregval = LPAIF_DMACTL_WPSCNT_THREE;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tregval = LPAIF_DMACTL_WPSCNT_FOUR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(soc_runtime->dev, \"invalid PCM config given: bw=%d, ch=%u\\n\",\n\t\t\t\tbitwidth, channels);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tswitch (channels) {\n\t\tcase 1:\n\t\t\tregval = LPAIF_DMACTL_WPSCNT_ONE;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tregval = (dai_id == LPASS_DP_RX ?\n\t\t\tLPAIF_DMACTL_WPSCNT_ONE :\n\t\t\tLPAIF_DMACTL_WPSCNT_TWO);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tregval = (dai_id == LPASS_DP_RX ?\n\t\t\tLPAIF_DMACTL_WPSCNT_TWO :\n\t\t\tLPAIF_DMACTL_WPSCNT_FOUR);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tregval = (dai_id == LPASS_DP_RX ?\n\t\t\tLPAIF_DMACTL_WPSCNT_THREE :\n\t\t\tLPAIF_DMACTL_WPSCNT_SIX);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tregval = (dai_id == LPASS_DP_RX ?\n\t\t\tLPAIF_DMACTL_WPSCNT_FOUR :\n\t\t\tLPAIF_DMACTL_WPSCNT_EIGHT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(soc_runtime->dev, \"invalid PCM config given: bw=%d, ch=%u\\n\",\n\t\t\t\tbitwidth, channels);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"invalid PCM config given: bw=%d, ch=%u\\n\",\n\t\t\tbitwidth, channels);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_fields_write(dmactl->wpscnt, id, regval);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error writing to dmactl reg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpass_platform_pcmops_hw_free(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int reg;\n\tint ret;\n\tstruct regmap *map;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tif (is_cdc_dma_port(dai_id))\n\t\treturn 0;\n\tmap = __lpass_get_regmap_handle(substream, component);\n\n\treg = LPAIF_DMACTL_REG(v, pcm_data->dma_ch, substream->stream, dai_id);\n\tret = regmap_write(map, reg, 0);\n\tif (ret)\n\t\tdev_err(soc_runtime->dev, \"error writing to rdmactl reg: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic int lpass_platform_pcmops_prepare(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *dmactl;\n\tstruct regmap *map;\n\tint ret, id, ch, dir = substream->stream;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tch = pcm_data->dma_ch;\n\n\tdmactl = __lpass_get_dmactl_handle(substream, component);\n\tid = __lpass_get_id(substream, component);\n\tmap = __lpass_get_regmap_handle(substream, component);\n\n\tret = regmap_write(map, LPAIF_DMABASE_REG(v, ch, dir, dai_id),\n\t\t\t\truntime->dma_addr);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error writing to rdmabase reg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(map, LPAIF_DMABUFF_REG(v, ch, dir, dai_id),\n\t\t\t(snd_pcm_lib_buffer_bytes(substream) >> 2) - 1);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error writing to rdmabuff reg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(map, LPAIF_DMAPER_REG(v, ch, dir, dai_id),\n\t\t\t(snd_pcm_lib_period_bytes(substream) >> 2) - 1);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error writing to rdmaper reg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (is_cdc_dma_port(dai_id)) {\n\t\tret = regmap_fields_write(dmactl->fifowm, id, LPAIF_DMACTL_FIFOWM_8);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error writing fifowm field to dmactl reg: %d, id: %d\\n\",\n\t\t\t\tret, id);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = regmap_fields_write(dmactl->enable, id, LPAIF_DMACTL_ENABLE_ON);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev, \"error writing to rdmactl reg: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lpass_platform_pcmops_trigger(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t\t int cmd)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tstruct lpaif_dmactl *dmactl;\n\tstruct regmap *map;\n\tint ret, ch, id;\n\tunsigned int reg_irqclr = 0, val_irqclr = 0;\n\tunsigned int  reg_irqen = 0, val_irqen = 0, val_mask = 0;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tch = pcm_data->dma_ch;\n\tdmactl = __lpass_get_dmactl_handle(substream, component);\n\tid = __lpass_get_id(substream, component);\n\tmap = __lpass_get_regmap_handle(substream, component);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = regmap_fields_write(dmactl->enable, id,\n\t\t\t\t\t\t LPAIF_DMACTL_ENABLE_ON);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to rdmactl reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tswitch (dai_id) {\n\t\tcase LPASS_DP_RX:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id,\n\t\t\t\t\t LPAIF_DMACTL_DYNCLK_ON);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treg_irqclr = LPASS_HDMITX_APP_IRQCLEAR_REG(v);\n\t\t\tval_irqclr = (LPAIF_IRQ_ALL(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_REQ_ON_PRELOAD(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\t\t\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(ch));\n\n\t\t\treg_irqen = LPASS_HDMITX_APP_IRQEN_REG(v);\n\t\t\tval_mask = (LPAIF_IRQ_ALL(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_REQ_ON_PRELOAD(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\t\t\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(ch));\n\t\t\tval_irqen = (LPAIF_IRQ_ALL(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_REQ_ON_PRELOAD(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\t\t\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(ch));\n\t\t\tbreak;\n\t\tcase MI2S_PRIMARY:\n\t\tcase MI2S_SECONDARY:\n\t\tcase MI2S_TERTIARY:\n\t\tcase MI2S_QUATERNARY:\n\t\tcase MI2S_QUINARY:\n\t\t\treg_irqclr = LPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_irqclr = LPAIF_IRQ_ALL(ch);\n\n\n\t\t\treg_irqen = LPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = LPAIF_IRQ_ALL(ch);\n\t\t\tbreak;\n\t\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id, LPAIF_DMACTL_DYNCLK_ON);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg field: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treg_irqclr = LPAIF_RXTX_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_irqclr = LPAIF_IRQ_ALL(ch);\n\n\t\t\treg_irqen = LPAIF_RXTX_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = LPAIF_IRQ_ALL(ch);\n\t\t\tbreak;\n\t\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id, LPAIF_DMACTL_DYNCLK_ON);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg field: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treg_irqclr = LPAIF_VA_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_irqclr = LPAIF_IRQ_ALL(ch);\n\n\t\t\treg_irqen = LPAIF_VA_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = LPAIF_IRQ_ALL(ch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(soc_runtime->dev, \"%s: invalid %d interface\\n\", __func__, dai_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = regmap_write_bits(map, reg_irqclr, val_irqclr, val_irqclr);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error writing to irqclear reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_update_bits(map, reg_irqen, val_mask, val_irqen);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev, \"error writing to irqen reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = regmap_fields_write(dmactl->enable, id,\n\t\t\t\t\t LPAIF_DMACTL_ENABLE_OFF);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to rdmactl reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tswitch (dai_id) {\n\t\tcase LPASS_DP_RX:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id,\n\t\t\t\t\t LPAIF_DMACTL_DYNCLK_OFF);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treg_irqen = LPASS_HDMITX_APP_IRQEN_REG(v);\n\t\t\tval_mask = (LPAIF_IRQ_ALL(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_REQ_ON_PRELOAD(ch) |\n\t\t\t\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\t\t\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(ch));\n\t\t\tval_irqen = 0;\n\t\t\tbreak;\n\t\tcase MI2S_PRIMARY:\n\t\tcase MI2S_SECONDARY:\n\t\tcase MI2S_TERTIARY:\n\t\tcase MI2S_QUATERNARY:\n\t\tcase MI2S_QUINARY:\n\t\t\treg_irqen = LPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = 0;\n\t\t\tbreak;\n\t\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id, LPAIF_DMACTL_DYNCLK_OFF);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg field: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treg_irqclr = LPAIF_RXTX_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_irqclr = LPAIF_IRQ_ALL(ch);\n\n\t\t\treg_irqen = LPAIF_RXTX_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = LPAIF_IRQ_ALL(ch);\n\t\t\tbreak;\n\t\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\t\tret = regmap_fields_write(dmactl->dyncclk, id, LPAIF_DMACTL_DYNCLK_OFF);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\t\"error writing to rdmactl reg field: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treg_irqclr = LPAIF_VA_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_irqclr = LPAIF_IRQ_ALL(ch);\n\n\t\t\treg_irqen = LPAIF_VA_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\t\tval_mask = LPAIF_IRQ_ALL(ch);\n\t\t\tval_irqen = LPAIF_IRQ_ALL(ch);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(soc_runtime->dev, \"%s: invalid %d interface\\n\", __func__, dai_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = regmap_update_bits(map, reg_irqen, val_mask, val_irqen);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to irqen reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t lpass_platform_pcmops_pointer(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int base_addr, curr_addr;\n\tint ret, ch, dir = substream->stream;\n\tstruct regmap *map;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tmap = __lpass_get_regmap_handle(substream, component);\n\tch = pcm_data->dma_ch;\n\n\tret = regmap_read(map,\n\t\t\tLPAIF_DMABASE_REG(v, ch, dir, dai_id), &base_addr);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev,\n\t\t\t\"error reading from rdmabase reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(map,\n\t\t\tLPAIF_DMACURR_REG(v, ch, dir, dai_id), &curr_addr);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev,\n\t\t\t\"error reading from rdmacurr reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn bytes_to_frames(substream->runtime, curr_addr - base_addr);\n}\n\nstatic int lpass_platform_cdc_dma_mmap(struct snd_pcm_substream *substream,\n\t\t\t\t       struct vm_area_struct *vma)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned long size, offset;\n\n\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\tsize = vma->vm_end - vma->vm_start;\n\toffset = vma->vm_pgoff << PAGE_SHIFT;\n\treturn io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t(runtime->dma_addr + offset) >> PAGE_SHIFT,\n\t\t\tsize, vma->vm_page_prot);\n\n}\n\nstatic int lpass_platform_pcmops_mmap(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t\t      struct vm_area_struct *vma)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tif (is_cdc_dma_port(dai_id))\n\t\treturn lpass_platform_cdc_dma_mmap(substream, vma);\n\n\treturn snd_pcm_lib_default_mmap(substream, vma);\n}\n\nstatic irqreturn_t lpass_dma_interrupt_handler(\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct lpass_data *drvdata,\n\t\t\tint chan, u32 interrupts)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_variant *v = drvdata->variant;\n\tirqreturn_t ret = IRQ_NONE;\n\tint rv;\n\tunsigned int reg, val, mask;\n\tstruct regmap *map;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tmask = LPAIF_IRQ_ALL(chan);\n\tswitch (dai_id) {\n\tcase LPASS_DP_RX:\n\t\tmap = drvdata->hdmiif_map;\n\t\treg = LPASS_HDMITX_APP_IRQCLEAR_REG(v);\n\t\tval = (LPAIF_IRQ_HDMI_REQ_ON_PRELOAD(chan) |\n\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(chan));\n\tbreak;\n\tcase MI2S_PRIMARY:\n\tcase MI2S_SECONDARY:\n\tcase MI2S_TERTIARY:\n\tcase MI2S_QUATERNARY:\n\tcase MI2S_QUINARY:\n\t\tmap = drvdata->lpaif_map;\n\t\treg = LPAIF_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\tval = 0;\n\tbreak;\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tmap = drvdata->rxtx_lpaif_map;\n\t\treg = LPAIF_RXTX_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\tval = 0;\n\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tmap = drvdata->va_lpaif_map;\n\t\treg = LPAIF_VA_IRQCLEAR_REG(v, LPAIF_IRQ_PORT_HOST);\n\t\tval = 0;\n\tbreak;\n\tdefault:\n\tdev_err(soc_runtime->dev, \"%s: invalid  %d interface\\n\", __func__, dai_id);\n\treturn -EINVAL;\n\t}\n\tif (interrupts & LPAIF_IRQ_PER(chan)) {\n\t\trv = regmap_write_bits(map, reg, mask, (LPAIF_IRQ_PER(chan) | val));\n\t\tif (rv) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to irqclear reg: %d\\n\", rv);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (interrupts & LPAIF_IRQ_XRUN(chan)) {\n\t\trv = regmap_write_bits(map, reg, mask, (LPAIF_IRQ_XRUN(chan) | val));\n\t\tif (rv) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to irqclear reg: %d\\n\", rv);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t\tdev_warn_ratelimited(soc_runtime->dev, \"xrun warning\\n\");\n\n\t\tsnd_pcm_stop_xrun(substream);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (interrupts & LPAIF_IRQ_ERR(chan)) {\n\t\trv = regmap_write_bits(map, reg, mask, (LPAIF_IRQ_ERR(chan) | val));\n\t\tif (rv) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to irqclear reg: %d\\n\", rv);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t\tdev_err(soc_runtime->dev, \"bus access error\\n\");\n\t\tsnd_pcm_stop(substream, SNDRV_PCM_STATE_DISCONNECTED);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (interrupts & val) {\n\t\trv = regmap_write(map, reg, val);\n\t\tif (rv) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\"error writing to irqclear reg: %d\\n\", rv);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t lpass_platform_lpaif_irq(int irq, void *data)\n{\n\tstruct lpass_data *drvdata = data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int irqs;\n\tint rv, chan;\n\n\trv = regmap_read(drvdata->lpaif_map,\n\t\t\tLPAIF_IRQSTAT_REG(v, LPAIF_IRQ_PORT_HOST), &irqs);\n\tif (rv) {\n\t\tpr_err(\"error reading from irqstat reg: %d\\n\", rv);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tfor (chan = 0; chan < LPASS_MAX_DMA_CHANNELS; chan++) {\n\t\tif (irqs & LPAIF_IRQ_ALL(chan) && drvdata->substream[chan]) {\n\t\t\trv = lpass_dma_interrupt_handler(\n\t\t\t\t\t\tdrvdata->substream[chan],\n\t\t\t\t\t\tdrvdata, chan, irqs);\n\t\t\tif (rv != IRQ_HANDLED)\n\t\t\t\treturn rv;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lpass_platform_hdmiif_irq(int irq, void *data)\n{\n\tstruct lpass_data *drvdata = data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int irqs;\n\tint rv, chan;\n\n\trv = regmap_read(drvdata->hdmiif_map,\n\t\t\tLPASS_HDMITX_APP_IRQSTAT_REG(v), &irqs);\n\tif (rv) {\n\t\tpr_err(\"error reading from irqstat reg: %d\\n\", rv);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tfor (chan = 0; chan < LPASS_MAX_HDMI_DMA_CHANNELS; chan++) {\n\t\tif (irqs & (LPAIF_IRQ_ALL(chan) | LPAIF_IRQ_HDMI_REQ_ON_PRELOAD(chan) |\n\t\t\t\tLPAIF_IRQ_HDMI_METADONE |\n\t\t\t\tLPAIF_IRQ_HDMI_SDEEP_AUD_DIS(chan))\n\t\t\t&& drvdata->hdmi_substream[chan]) {\n\t\t\trv = lpass_dma_interrupt_handler(\n\t\t\t\t\t\tdrvdata->hdmi_substream[chan],\n\t\t\t\t\t\tdrvdata, chan, irqs);\n\t\t\tif (rv != IRQ_HANDLED)\n\t\t\t\treturn rv;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lpass_platform_rxtxif_irq(int irq, void *data)\n{\n\tstruct lpass_data *drvdata = data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int irqs;\n\tirqreturn_t rv;\n\tint chan;\n\n\trv = regmap_read(drvdata->rxtx_lpaif_map,\n\t\t\tLPAIF_RXTX_IRQSTAT_REG(v, LPAIF_IRQ_PORT_HOST), &irqs);\n\n\t \n\tfor (chan = 0; chan < LPASS_MAX_CDC_DMA_CHANNELS; chan++) {\n\t\tif (irqs & LPAIF_IRQ_ALL(chan) && drvdata->rxtx_substream[chan]) {\n\t\t\trv = lpass_dma_interrupt_handler(\n\t\t\t\t\t\tdrvdata->rxtx_substream[chan],\n\t\t\t\t\t\tdrvdata, chan, irqs);\n\t\t\tif (rv != IRQ_HANDLED)\n\t\t\t\treturn rv;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lpass_platform_vaif_irq(int irq, void *data)\n{\n\tstruct lpass_data *drvdata = data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int irqs;\n\tirqreturn_t rv;\n\tint chan;\n\n\trv = regmap_read(drvdata->va_lpaif_map,\n\t\t\tLPAIF_VA_IRQSTAT_REG(v, LPAIF_IRQ_PORT_HOST), &irqs);\n\n\t \n\tfor (chan = 0; chan < LPASS_MAX_VA_CDC_DMA_CHANNELS; chan++) {\n\t\tif (irqs & LPAIF_IRQ_ALL(chan) && drvdata->va_substream[chan]) {\n\t\t\trv = lpass_dma_interrupt_handler(\n\t\t\t\t\t\tdrvdata->va_substream[chan],\n\t\t\t\t\t\tdrvdata, chan, irqs);\n\t\t\tif (rv != IRQ_HANDLED)\n\t\t\t\treturn rv;\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpass_platform_prealloc_cdc_dma_buffer(struct snd_soc_component *component,\n\t\t\t\t\t\t  struct snd_pcm *pcm, int dai_id)\n{\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_dma_buffer *buf;\n\n\tif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)\n\t\tsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\telse\n\t\tsubstream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\n\tbuf = &substream->dma_buffer;\n\tbuf->dev.dev = pcm->card->dev;\n\tbuf->private_data = NULL;\n\n\t \n\tbuf->dev.type = SNDRV_DMA_TYPE_CONTINUOUS;\n\n\tswitch (dai_id) {\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\tbuf->bytes = lpass_platform_rxtx_hardware.buffer_bytes_max;\n\t\tbuf->addr = drvdata->rxtx_cdc_dma_lpm_buf;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tbuf->bytes = lpass_platform_rxtx_hardware.buffer_bytes_max;\n\t\tbuf->addr = drvdata->rxtx_cdc_dma_lpm_buf + LPASS_RXTX_CDC_DMA_LPM_BUFF_SIZE;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\tbuf->bytes = lpass_platform_va_hardware.buffer_bytes_max;\n\t\tbuf->addr = drvdata->va_cdc_dma_lpm_buf;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbuf->area = (unsigned char * __force)memremap(buf->addr, buf->bytes, MEMREMAP_WC);\n\n\treturn 0;\n}\n\nstatic int lpass_platform_pcm_new(struct snd_soc_component *component,\n\t\t\t\t  struct snd_soc_pcm_runtime *soc_runtime)\n{\n\tstruct snd_pcm *pcm = soc_runtime->pcm;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tsize_t size = lpass_platform_pcm_hardware.buffer_bytes_max;\n\n\t \n\tif (is_cdc_dma_port(dai_id))\n\t\treturn lpass_platform_prealloc_cdc_dma_buffer(component, pcm, dai_id);\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_NONCOHERENT,\n\t\t\t\t\t    component->dev, size);\n}\n\nstatic int lpass_platform_pcmops_suspend(struct snd_soc_component *component)\n{\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map;\n\tunsigned int dai_id = component->id;\n\n\tif (dai_id == LPASS_DP_RX)\n\t\tmap = drvdata->hdmiif_map;\n\telse\n\t\tmap = drvdata->lpaif_map;\n\n\tregcache_cache_only(map, true);\n\tregcache_mark_dirty(map);\n\n\treturn 0;\n}\n\nstatic int lpass_platform_pcmops_resume(struct snd_soc_component *component)\n{\n\tstruct lpass_data *drvdata = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map;\n\tunsigned int dai_id = component->id;\n\n\tif (dai_id == LPASS_DP_RX)\n\t\tmap = drvdata->hdmiif_map;\n\telse\n\t\tmap = drvdata->lpaif_map;\n\n\tregcache_cache_only(map, false);\n\treturn regcache_sync(map);\n}\n\nstatic int lpass_platform_copy(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream, int channel,\n\t\t\t       unsigned long pos, struct iov_iter *buf,\n\t\t\t       unsigned long bytes)\n{\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tunsigned int dai_id = component->id;\n\tint ret = 0;\n\n\tvoid __iomem *dma_buf = (void __iomem *) (rt->dma_area + pos +\n\t\t\t\tchannel * (rt->dma_bytes / rt->channels));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (is_cdc_dma_port(dai_id)) {\n\t\t\tret = copy_from_iter_toio(dma_buf, buf, bytes);\n\t\t} else {\n\t\t\tif (copy_from_iter((void __force *)dma_buf, bytes, buf) != bytes)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tif (is_cdc_dma_port(dai_id)) {\n\t\t\tret = copy_to_iter_fromio(buf, dma_buf, bytes);\n\t\t} else {\n\t\t\tif (copy_to_iter((void __force *)dma_buf, bytes, buf) != bytes)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver lpass_component_driver = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= lpass_platform_pcmops_open,\n\t.close\t\t= lpass_platform_pcmops_close,\n\t.hw_params\t= lpass_platform_pcmops_hw_params,\n\t.hw_free\t= lpass_platform_pcmops_hw_free,\n\t.prepare\t= lpass_platform_pcmops_prepare,\n\t.trigger\t= lpass_platform_pcmops_trigger,\n\t.pointer\t= lpass_platform_pcmops_pointer,\n\t.mmap\t\t= lpass_platform_pcmops_mmap,\n\t.pcm_construct\t= lpass_platform_pcm_new,\n\t.suspend\t\t= lpass_platform_pcmops_suspend,\n\t.resume\t\t\t= lpass_platform_pcmops_resume,\n\t.copy\t\t= lpass_platform_copy,\n\n};\n\nint asoc_qcom_lpass_platform_register(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\tstruct lpass_variant *v = drvdata->variant;\n\tint ret;\n\n\tdrvdata->lpaif_irq = platform_get_irq_byname(pdev, \"lpass-irq-lpaif\");\n\tif (drvdata->lpaif_irq < 0)\n\t\treturn -ENODEV;\n\n\t \n\tret = regmap_write(drvdata->lpaif_map,\n\t\t\tLPAIF_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST), 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"error writing to irqen reg: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, drvdata->lpaif_irq,\n\t\t\tlpass_platform_lpaif_irq, IRQF_TRIGGER_RISING,\n\t\t\t\"lpass-irq-lpaif\", drvdata);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = lpass_platform_alloc_dmactl_fields(&pdev->dev,\n\t\t\t\t\t\t drvdata->lpaif_map);\n\tif (ret) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"error initializing dmactl fields: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (drvdata->codec_dma_enable) {\n\t\tret = regmap_write(drvdata->rxtx_lpaif_map,\n\t\t\tLPAIF_RXTX_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST), 0x0);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"error writing to rxtx irqen reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_write(drvdata->va_lpaif_map,\n\t\t\tLPAIF_VA_IRQEN_REG(v, LPAIF_IRQ_PORT_HOST), 0x0);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"error writing to rxtx irqen reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdrvdata->rxtxif_irq = platform_get_irq_byname(pdev, \"lpass-irq-rxtxif\");\n\t\tif (drvdata->rxtxif_irq < 0)\n\t\t\treturn -ENODEV;\n\n\t\tret = devm_request_irq(&pdev->dev, drvdata->rxtxif_irq,\n\t\t\t\tlpass_platform_rxtxif_irq, 0, \"lpass-irq-rxtxif\", drvdata);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"rxtx irq request failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lpass_platform_alloc_rxtx_dmactl_fields(&pdev->dev,\n\t\t\t\t\t\t drvdata->rxtx_lpaif_map);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"error initializing rxtx dmactl fields: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdrvdata->vaif_irq = platform_get_irq_byname(pdev, \"lpass-irq-vaif\");\n\t\tif (drvdata->vaif_irq < 0)\n\t\t\treturn -ENODEV;\n\n\t\tret = devm_request_irq(&pdev->dev, drvdata->vaif_irq,\n\t\t\t\tlpass_platform_vaif_irq, 0, \"lpass-irq-vaif\", drvdata);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"va irq request failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lpass_platform_alloc_va_dmactl_fields(&pdev->dev,\n\t\t\t\t\t\t drvdata->va_lpaif_map);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"error initializing va dmactl fields: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (drvdata->hdmi_port_enable) {\n\t\tdrvdata->hdmiif_irq = platform_get_irq_byname(pdev, \"lpass-irq-hdmi\");\n\t\tif (drvdata->hdmiif_irq < 0)\n\t\t\treturn -ENODEV;\n\n\t\tret = devm_request_irq(&pdev->dev, drvdata->hdmiif_irq,\n\t\t\t\tlpass_platform_hdmiif_irq, 0, \"lpass-irq-hdmi\", drvdata);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"irq hdmi request failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_write(drvdata->hdmiif_map,\n\t\t\t\tLPASS_HDMITX_APP_IRQEN_REG(v), 0);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"error writing to hdmi irqen reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = lpass_platform_alloc_hdmidmactl_fields(&pdev->dev,\n\t\t\t\t\t\t\t drvdata->hdmiif_map);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"error initializing hdmidmactl fields: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&lpass_component_driver, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_platform_register);\n\nMODULE_DESCRIPTION(\"QTi LPASS Platform Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}