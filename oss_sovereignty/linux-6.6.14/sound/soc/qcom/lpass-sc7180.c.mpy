{
  "module_name": "lpass-sc7180.c",
  "hash_id": "2f46e71ca8925338e1c611b96405eb956407063db9e0532c001e650f08b33043",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-sc7180.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <dt-bindings/sound/sc7180-lpass.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\nstatic struct snd_soc_dai_driver sc7180_lpass_cpu_dai_driver[] = {\n\t{\n\t\t.id = MI2S_PRIMARY,\n\t\t.name = \"Primary MI2S\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Primary Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16,\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min\t= 48000,\n\t\t\t.rate_max\t= 48000,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Primary Capture\",\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min\t= 48000,\n\t\t\t.rate_max\t= 48000,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n\t}, {\n\t\t.id = MI2S_SECONDARY,\n\t\t.name = \"Secondary MI2S\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Secondary Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16,\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min\t= 48000,\n\t\t\t.rate_max\t= 48000,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_cpu_dai_ops2,\n\t}, {\n\t\t.id = LPASS_DP_RX,\n\t\t.name = \"Hdmi\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Hdmi Playback\",\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S24,\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.rate_min\t= 48000,\n\t\t\t.rate_max\t= 48000,\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t},\n\t\t.ops    = &asoc_qcom_lpass_hdmi_dai_ops,\n\t},\n};\n\nstatic int sc7180_lpass_alloc_dma_channel(struct lpass_data *drvdata,\n\t\t\t\t\t   int direction, unsigned int dai_id)\n{\n\tstruct lpass_variant *v = drvdata->variant;\n\tint chan = 0;\n\n\tif (dai_id == LPASS_DP_RX) {\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tchan = find_first_zero_bit(&drvdata->hdmi_dma_ch_bit_map,\n\t\t\t\t\t\tv->hdmi_rdma_channels);\n\n\t\t\tif (chan >= v->hdmi_rdma_channels)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tset_bit(chan, &drvdata->hdmi_dma_ch_bit_map);\n\t} else {\n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tchan = find_first_zero_bit(&drvdata->dma_ch_bit_map,\n\t\t\t\t\t\tv->rdma_channels);\n\n\t\t\tif (chan >= v->rdma_channels)\n\t\t\t\treturn -EBUSY;\n\t\t} else {\n\t\t\tchan = find_next_zero_bit(&drvdata->dma_ch_bit_map,\n\t\t\t\t\tv->wrdma_channel_start +\n\t\t\t\t\tv->wrdma_channels,\n\t\t\t\t\tv->wrdma_channel_start);\n\n\t\t\tif (chan >=  v->wrdma_channel_start + v->wrdma_channels)\n\t\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tset_bit(chan, &drvdata->dma_ch_bit_map);\n\t}\n\treturn chan;\n}\n\nstatic int sc7180_lpass_free_dma_channel(struct lpass_data *drvdata, int chan, unsigned int dai_id)\n{\n\tif (dai_id == LPASS_DP_RX)\n\t\tclear_bit(chan, &drvdata->hdmi_dma_ch_bit_map);\n\telse\n\t\tclear_bit(chan, &drvdata->dma_ch_bit_map);\n\n\treturn 0;\n}\n\nstatic int sc7180_lpass_init(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\tstruct lpass_variant *variant = drvdata->variant;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i;\n\n\tdrvdata->clks = devm_kcalloc(dev, variant->num_clks,\n\t\t\t\t     sizeof(*drvdata->clks), GFP_KERNEL);\n\tif (!drvdata->clks)\n\t\treturn -ENOMEM;\n\n\tdrvdata->num_clks = variant->num_clks;\n\n\tfor (i = 0; i < drvdata->num_clks; i++)\n\t\tdrvdata->clks[i].id = variant->clk_name[i];\n\n\tret = devm_clk_bulk_get(dev, drvdata->num_clks, drvdata->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get clocks %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(drvdata->num_clks, drvdata->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"sc7180 clk_enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc7180_lpass_exit(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\n\tclk_bulk_disable_unprepare(drvdata->num_clks, drvdata->clks);\n\treturn 0;\n}\n\nstatic int __maybe_unused sc7180_lpass_dev_resume(struct device *dev)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\n\treturn clk_bulk_prepare_enable(drvdata->num_clks, drvdata->clks);\n}\n\nstatic int __maybe_unused sc7180_lpass_dev_suspend(struct device *dev)\n{\n\tstruct lpass_data *drvdata = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(drvdata->num_clks, drvdata->clks);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops sc7180_lpass_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sc7180_lpass_dev_suspend, sc7180_lpass_dev_resume)\n};\n\nstatic struct lpass_variant sc7180_data = {\n\t.i2sctrl_reg_base\t= 0x1000,\n\t.i2sctrl_reg_stride\t= 0x1000,\n\t.i2s_ports\t\t= 3,\n\t.irq_reg_base\t\t= 0x9000,\n\t.irq_reg_stride\t\t= 0x1000,\n\t.irq_ports\t\t= 3,\n\t.rdma_reg_base\t\t= 0xC000,\n\t.rdma_reg_stride\t= 0x1000,\n\t.rdma_channels\t\t= 5,\n\t.hdmi_rdma_reg_base\t\t= 0x64000,\n\t.hdmi_rdma_reg_stride\t= 0x1000,\n\t.hdmi_rdma_channels\t\t= 4,\n\t.dmactl_audif_start\t= 1,\n\t.wrdma_reg_base\t\t= 0x18000,\n\t.wrdma_reg_stride\t= 0x1000,\n\t.wrdma_channel_start\t= 5,\n\t.wrdma_channels\t\t= 4,\n\n\t.loopback\t\t= REG_FIELD_ID(0x1000, 17, 17, 3, 0x1000),\n\t.spken\t\t\t= REG_FIELD_ID(0x1000, 16, 16, 3, 0x1000),\n\t.spkmode\t\t= REG_FIELD_ID(0x1000, 11, 15, 3, 0x1000),\n\t.spkmono\t\t= REG_FIELD_ID(0x1000, 10, 10, 3, 0x1000),\n\t.micen\t\t\t= REG_FIELD_ID(0x1000, 9, 9, 3, 0x1000),\n\t.micmode\t\t= REG_FIELD_ID(0x1000, 4, 8, 3, 0x1000),\n\t.micmono\t\t= REG_FIELD_ID(0x1000, 3, 3, 3, 0x1000),\n\t.wssrc\t\t\t= REG_FIELD_ID(0x1000, 2, 2, 3, 0x1000),\n\t.bitwidth\t\t= REG_FIELD_ID(0x1000, 0, 1, 3, 0x1000),\n\n\t.rdma_dyncclk\t\t= REG_FIELD_ID(0xC000, 21, 21, 5, 0x1000),\n\t.rdma_bursten\t\t= REG_FIELD_ID(0xC000, 20, 20, 5, 0x1000),\n\t.rdma_wpscnt\t\t= REG_FIELD_ID(0xC000, 16, 19, 5, 0x1000),\n\t.rdma_intf\t\t\t= REG_FIELD_ID(0xC000, 12, 15, 5, 0x1000),\n\t.rdma_fifowm\t\t= REG_FIELD_ID(0xC000, 1, 5, 5, 0x1000),\n\t.rdma_enable\t\t= REG_FIELD_ID(0xC000, 0, 0, 5, 0x1000),\n\n\t.wrdma_dyncclk\t\t= REG_FIELD_ID(0x18000, 22, 22, 4, 0x1000),\n\t.wrdma_bursten\t\t= REG_FIELD_ID(0x18000, 21, 21, 4, 0x1000),\n\t.wrdma_wpscnt\t\t= REG_FIELD_ID(0x18000, 17, 20, 4, 0x1000),\n\t.wrdma_intf\t\t= REG_FIELD_ID(0x18000, 12, 16, 4, 0x1000),\n\t.wrdma_fifowm\t\t= REG_FIELD_ID(0x18000, 1, 5, 4, 0x1000),\n\t.wrdma_enable\t\t= REG_FIELD_ID(0x18000, 0, 0, 4, 0x1000),\n\n\t.hdmi_tx_ctl_addr\t= 0x1000,\n\t.hdmi_legacy_addr\t= 0x1008,\n\t.hdmi_vbit_addr\t\t= 0x610c0,\n\t.hdmi_ch_lsb_addr\t= 0x61048,\n\t.hdmi_ch_msb_addr\t= 0x6104c,\n\t.ch_stride\t\t= 0x8,\n\t.hdmi_parity_addr\t= 0x61034,\n\t.hdmi_dmactl_addr\t= 0x61038,\n\t.hdmi_dma_stride\t= 0x4,\n\t.hdmi_DP_addr\t\t= 0x610c8,\n\t.hdmi_sstream_addr\t= 0x6101c,\n\t.hdmi_irq_reg_base\t\t= 0x63000,\n\t.hdmi_irq_ports\t\t= 1,\n\n\t.hdmi_rdma_dyncclk\t\t= REG_FIELD_ID(0x64000, 14, 14, 4, 0x1000),\n\t.hdmi_rdma_bursten\t\t= REG_FIELD_ID(0x64000, 13, 13, 4, 0x1000),\n\t.hdmi_rdma_burst8\t\t= REG_FIELD_ID(0x64000, 15, 15, 4, 0x1000),\n\t.hdmi_rdma_burst16\t\t= REG_FIELD_ID(0x64000, 16, 16, 4, 0x1000),\n\t.hdmi_rdma_dynburst\t\t= REG_FIELD_ID(0x64000, 18, 18, 4, 0x1000),\n\t.hdmi_rdma_wpscnt\t\t= REG_FIELD_ID(0x64000, 10, 12, 4, 0x1000),\n\t.hdmi_rdma_fifowm\t\t= REG_FIELD_ID(0x64000, 1, 5, 4, 0x1000),\n\t.hdmi_rdma_enable\t\t= REG_FIELD_ID(0x64000, 0, 0, 4, 0x1000),\n\n\t.sstream_en\t\t= REG_FIELD(0x6101c, 0, 0),\n\t.dma_sel\t\t\t= REG_FIELD(0x6101c, 1, 2),\n\t.auto_bbit_en\t= REG_FIELD(0x6101c, 3, 3),\n\t.layout\t\t\t= REG_FIELD(0x6101c, 4, 4),\n\t.layout_sp\t\t= REG_FIELD(0x6101c, 5, 8),\n\t.set_sp_on_en\t= REG_FIELD(0x6101c, 10, 10),\n\t.dp_audio\t\t= REG_FIELD(0x6101c, 11, 11),\n\t.dp_staffing_en\t= REG_FIELD(0x6101c, 12, 12),\n\t.dp_sp_b_hw_en\t= REG_FIELD(0x6101c, 13, 13),\n\n\t.mute\t\t\t= REG_FIELD(0x610c8, 0, 0),\n\t.as_sdp_cc\t\t= REG_FIELD(0x610c8, 1, 3),\n\t.as_sdp_ct\t\t= REG_FIELD(0x610c8, 4, 7),\n\t.aif_db4\t\t\t= REG_FIELD(0x610c8, 8, 15),\n\t.frequency\t\t= REG_FIELD(0x610c8, 16, 21),\n\t.mst_index\t\t= REG_FIELD(0x610c8, 28, 29),\n\t.dptx_index\t\t= REG_FIELD(0x610c8, 30, 31),\n\n\t.soft_reset\t\t= REG_FIELD(0x1000, 31, 31),\n\t.force_reset\t= REG_FIELD(0x1000, 30, 30),\n\n\t.use_hw_chs\t\t= REG_FIELD(0x61038, 0, 0),\n\t.use_hw_usr\t\t= REG_FIELD(0x61038, 1, 1),\n\t.hw_chs_sel\t\t= REG_FIELD(0x61038, 2, 4),\n\t.hw_usr_sel\t\t= REG_FIELD(0x61038, 5, 6),\n\n\t.replace_vbit\t= REG_FIELD(0x610c0, 0, 0),\n\t.vbit_stream\t= REG_FIELD(0x610c0, 1, 1),\n\n\t.legacy_en\t\t=  REG_FIELD(0x1008, 0, 0),\n\t.calc_en\t\t=  REG_FIELD(0x61034, 0, 0),\n\t.lsb_bits\t\t=  REG_FIELD(0x61048, 0, 31),\n\t.msb_bits\t\t=  REG_FIELD(0x6104c, 0, 31),\n\n\n\t.clk_name\t\t= (const char*[]) {\n\t\t\t\t   \"pcnoc-sway-clk\",\n\t\t\t\t   \"audio-core\",\n\t\t\t\t   \"pcnoc-mport-clk\",\n\t\t\t\t},\n\t.num_clks\t\t= 3,\n\t.dai_driver\t\t= sc7180_lpass_cpu_dai_driver,\n\t.num_dai\t\t= ARRAY_SIZE(sc7180_lpass_cpu_dai_driver),\n\t.dai_osr_clk_names      = (const char *[]) {\n\t\t\t\t   \"mclk0\",\n\t\t\t\t   \"null\",\n\t\t\t\t},\n\t.dai_bit_clk_names      = (const char *[]) {\n\t\t\t\t   \"mi2s-bit-clk0\",\n\t\t\t\t   \"mi2s-bit-clk1\",\n\t\t\t\t},\n\t.init\t\t\t= sc7180_lpass_init,\n\t.exit\t\t\t= sc7180_lpass_exit,\n\t.alloc_dma_channel\t= sc7180_lpass_alloc_dma_channel,\n\t.free_dma_channel\t= sc7180_lpass_free_dma_channel,\n};\n\nstatic const struct of_device_id sc7180_lpass_cpu_device_id[] __maybe_unused = {\n\t{.compatible = \"qcom,sc7180-lpass-cpu\", .data = &sc7180_data},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sc7180_lpass_cpu_device_id);\n\nstatic struct platform_driver sc7180_lpass_cpu_platform_driver = {\n\t.driver = {\n\t\t.name = \"sc7180-lpass-cpu\",\n\t\t.of_match_table = of_match_ptr(sc7180_lpass_cpu_device_id),\n\t\t.pm = &sc7180_lpass_pm_ops,\n\t},\n\t.probe = asoc_qcom_lpass_cpu_platform_probe,\n\t.remove = asoc_qcom_lpass_cpu_platform_remove,\n\t.shutdown = asoc_qcom_lpass_cpu_platform_shutdown,\n};\n\nmodule_platform_driver(sc7180_lpass_cpu_platform_driver);\n\nMODULE_DESCRIPTION(\"SC7180 LPASS CPU DRIVER\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}