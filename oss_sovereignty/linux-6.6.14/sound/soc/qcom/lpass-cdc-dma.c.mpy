{
  "module_name": "lpass-cdc-dma.c",
  "hash_id": "d5395f281c66845027204fb6d4d74e7c3648bbc8faa4ec50aea01fdbb4e25f01",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-cdc-dma.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/export.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\n#define CODEC_MEM_HZ_NORMAL 153600000\n\nenum codec_dma_interfaces {\n\tLPASS_CDC_DMA_INTERFACE1 = 1,\n\tLPASS_CDC_DMA_INTERFACE2,\n\tLPASS_CDC_DMA_INTERFACE3,\n\tLPASS_CDC_DMA_INTERFACE4,\n\tLPASS_CDC_DMA_INTERFACE5,\n\tLPASS_CDC_DMA_INTERFACE6,\n\tLPASS_CDC_DMA_INTERFACE7,\n\tLPASS_CDC_DMA_INTERFACE8,\n\tLPASS_CDC_DMA_INTERFACE9,\n\tLPASS_CDC_DMA_INTERFACE10,\n};\n\nstatic void __lpass_get_dmactl_handle(struct snd_pcm_substream *substream, struct snd_soc_dai *dai,\n\t\t\t\t      struct lpaif_dmactl **dmactl, int *id)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tstruct lpass_pcm_data *pcm_data = rt->private_data;\n\tstruct lpass_variant *v = drvdata->variant;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tswitch (dai_id) {\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\t\t*dmactl = drvdata->rxtx_rd_dmactl;\n\t\t*id = pcm_data->dma_ch;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\t*dmactl = drvdata->rxtx_wr_dmactl;\n\t\t*id = pcm_data->dma_ch - v->rxtx_wrdma_channel_start;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX8:\n\t\t*dmactl = drvdata->va_wr_dmactl;\n\t\t*id = pcm_data->dma_ch - v->va_wrdma_channel_start;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"invalid dai id for dma ctl: %d\\n\", dai_id);\n\t\tbreak;\n\t}\n}\n\nstatic int __lpass_get_codec_dma_intf_type(int dai_id)\n{\n\tint ret;\n\n\tswitch (dai_id) {\n\tcase LPASS_CDC_DMA_RX0:\n\tcase LPASS_CDC_DMA_TX0:\n\tcase LPASS_CDC_DMA_VA_TX0:\n\t\tret = LPASS_CDC_DMA_INTERFACE1;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX1:\n\tcase LPASS_CDC_DMA_TX1:\n\tcase LPASS_CDC_DMA_VA_TX1:\n\t\tret = LPASS_CDC_DMA_INTERFACE2;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX2:\n\tcase LPASS_CDC_DMA_TX2:\n\tcase LPASS_CDC_DMA_VA_TX2:\n\t\tret = LPASS_CDC_DMA_INTERFACE3;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX3:\n\tcase LPASS_CDC_DMA_TX3:\n\tcase LPASS_CDC_DMA_VA_TX3:\n\t\tret = LPASS_CDC_DMA_INTERFACE4;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX4:\n\tcase LPASS_CDC_DMA_TX4:\n\tcase LPASS_CDC_DMA_VA_TX4:\n\t\tret = LPASS_CDC_DMA_INTERFACE5;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX5:\n\tcase LPASS_CDC_DMA_TX5:\n\tcase LPASS_CDC_DMA_VA_TX5:\n\t\tret = LPASS_CDC_DMA_INTERFACE6;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX6:\n\tcase LPASS_CDC_DMA_TX6:\n\tcase LPASS_CDC_DMA_VA_TX6:\n\t\tret = LPASS_CDC_DMA_INTERFACE7;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX7:\n\tcase LPASS_CDC_DMA_TX7:\n\tcase LPASS_CDC_DMA_VA_TX7:\n\t\tret = LPASS_CDC_DMA_INTERFACE8;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX8:\n\tcase LPASS_CDC_DMA_TX8:\n\tcase LPASS_CDC_DMA_VA_TX8:\n\t\tret = LPASS_CDC_DMA_INTERFACE9;\n\t\tbreak;\n\tcase LPASS_CDC_DMA_RX9:\n\t\tret  = LPASS_CDC_DMA_INTERFACE10;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int __lpass_platform_codec_intf_init(struct snd_soc_dai *dai,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_runtime, 0);\n\tstruct lpaif_dmactl *dmactl = NULL;\n\tstruct device *dev = soc_runtime->dev;\n\tint ret, id, codec_intf;\n\tunsigned int dai_id = cpu_dai->driver->id;\n\n\tcodec_intf = __lpass_get_codec_dma_intf_type(dai_id);\n\tif (codec_intf < 0) {\n\t\tdev_err(dev, \"failed to get codec_intf: %d\\n\", codec_intf);\n\t\treturn codec_intf;\n\t}\n\n\t__lpass_get_dmactl_handle(substream, dai, &dmactl, &id);\n\tif (!dmactl)\n\t\treturn -EINVAL;\n\n\tret = regmap_fields_write(dmactl->codec_intf, id, codec_intf);\n\tif (ret) {\n\t\tdev_err(dev, \"error writing to dmactl codec_intf reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regmap_fields_write(dmactl->codec_fs_sel, id, 0x0);\n\tif (ret) {\n\t\tdev_err(dev, \"error writing to dmactl codec_fs_sel reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regmap_fields_write(dmactl->codec_fs_delay, id, 0x0);\n\tif (ret) {\n\t\tdev_err(dev, \"error writing to dmactl codec_fs_delay reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regmap_fields_write(dmactl->codec_pack, id, 0x1);\n\tif (ret) {\n\t\tdev_err(dev, \"error writing to dmactl codec_pack reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regmap_fields_write(dmactl->codec_enable, id, LPAIF_DMACTL_ENABLE_ON);\n\tif (ret) {\n\t\tdev_err(dev, \"error writing to dmactl codec_enable reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int lpass_cdc_dma_daiops_startup(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\n\tswitch (dai->id) {\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tclk_set_rate(drvdata->codec_mem0, CODEC_MEM_HZ_NORMAL);\n\t\tclk_prepare_enable(drvdata->codec_mem0);\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX0:\n\t\tclk_set_rate(drvdata->va_mem0, CODEC_MEM_HZ_NORMAL);\n\t\tclk_prepare_enable(drvdata->va_mem0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"%s: invalid  interface: %d\\n\", __func__, dai->id);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void lpass_cdc_dma_daiops_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct lpass_data *drvdata = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\n\tswitch (dai->id) {\n\tcase LPASS_CDC_DMA_RX0 ... LPASS_CDC_DMA_RX9:\n\tcase LPASS_CDC_DMA_TX0 ... LPASS_CDC_DMA_TX8:\n\t\tclk_disable_unprepare(drvdata->codec_mem0);\n\t\tbreak;\n\tcase LPASS_CDC_DMA_VA_TX0 ... LPASS_CDC_DMA_VA_TX0:\n\t\tclk_disable_unprepare(drvdata->va_mem0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"%s: invalid  interface: %d\\n\", __func__, dai->id);\n\t\tbreak;\n\t}\n}\n\nstatic int lpass_cdc_dma_daiops_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct lpaif_dmactl *dmactl = NULL;\n\tunsigned int ret, regval;\n\tunsigned int channels = params_channels(params);\n\tint id;\n\n\tswitch (channels) {\n\tcase 1:\n\t\tregval = LPASS_CDC_DMA_INTF_ONE_CHANNEL;\n\t\tbreak;\n\tcase 2:\n\t\tregval = LPASS_CDC_DMA_INTF_TWO_CHANNEL;\n\t\tbreak;\n\tcase 4:\n\t\tregval = LPASS_CDC_DMA_INTF_FOUR_CHANNEL;\n\t\tbreak;\n\tcase 6:\n\t\tregval = LPASS_CDC_DMA_INTF_SIX_CHANNEL;\n\t\tbreak;\n\tcase 8:\n\t\tregval = LPASS_CDC_DMA_INTF_EIGHT_CHANNEL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(soc_runtime->dev, \"invalid PCM config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t__lpass_get_dmactl_handle(substream, dai, &dmactl, &id);\n\tif (!dmactl)\n\t\treturn -EINVAL;\n\n\tret = regmap_fields_write(dmactl->codec_channel, id, regval);\n\tif (ret) {\n\t\tdev_err(soc_runtime->dev,\n\t\t\t\"error writing to dmactl codec_channel reg field: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int lpass_cdc_dma_daiops_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *soc_runtime = asoc_substream_to_rtd(substream);\n\tstruct lpaif_dmactl *dmactl;\n\tint ret = 0, id;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t__lpass_platform_codec_intf_init(dai, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t__lpass_get_dmactl_handle(substream, dai, &dmactl, &id);\n\t\tif (!dmactl)\n\t\t\treturn -EINVAL;\n\n\t\tret = regmap_fields_write(dmactl->codec_enable, id, LPAIF_DMACTL_ENABLE_OFF);\n\t\tif (ret) {\n\t\t\tdev_err(soc_runtime->dev,\n\t\t\t\t\"error writing to dmactl codec_enable reg: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(soc_runtime->dev, \"%s: invalid %d interface\\n\", __func__, cmd);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nconst struct snd_soc_dai_ops asoc_qcom_lpass_cdc_dma_dai_ops = {\n\t.startup\t= lpass_cdc_dma_daiops_startup,\n\t.shutdown\t= lpass_cdc_dma_daiops_shutdown,\n\t.hw_params\t= lpass_cdc_dma_daiops_hw_params,\n\t.trigger\t= lpass_cdc_dma_daiops_trigger,\n};\nEXPORT_SYMBOL_GPL(asoc_qcom_lpass_cdc_dma_dai_ops);\n\nMODULE_DESCRIPTION(\"QTi LPASS CDC DMA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}