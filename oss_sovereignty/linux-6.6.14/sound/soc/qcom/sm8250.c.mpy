{
  "module_name": "sm8250.c",
  "hash_id": "5d233f86380026909de869382b88ac8e26ae4870c8da57fe49b08de0086c611e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/sm8250.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include <linux/soundwire/sdw.h>\n#include <sound/jack.h>\n#include <linux/input-event-codes.h>\n#include \"qdsp6/q6afe.h\"\n#include \"common.h\"\n#include \"sdw.h\"\n\n#define DRIVER_NAME\t\t\"sm8250\"\n#define MI2S_BCLK_RATE\t\t1536000\n\nstruct sm8250_snd_data {\n\tbool stream_prepared[AFE_PORT_MAX];\n\tstruct snd_soc_card *card;\n\tstruct sdw_stream_runtime *sruntime[AFE_PORT_MAX];\n\tstruct snd_soc_jack jack;\n\tbool jack_setup;\n};\n\nstatic int sm8250_snd_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct sm8250_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\n\treturn qcom_snd_wcd_jack_setup(rtd, &data->jack, &data->jack_setup);\n}\n\nstatic int sm8250_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\n\trate->min = rate->max = 48000;\n\tchannels->min = channels->max = 2;\n\n\treturn 0;\n}\n\nstatic int sm8250_snd_startup(struct snd_pcm_substream *substream)\n{\n\tunsigned int fmt = SND_SOC_DAIFMT_BP_FP;\n\tunsigned int codec_dai_fmt = SND_SOC_DAIFMT_BC_FC;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase TERTIARY_MI2S_RX:\n\t\tcodec_dai_fmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_I2S;\n\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\tQ6AFE_LPASS_CLK_ID_TER_MI2S_IBIT,\n\t\t\tMI2S_BCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\t\tsnd_soc_dai_set_fmt(cpu_dai, fmt);\n\t\tsnd_soc_dai_set_fmt(codec_dai, codec_dai_fmt);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int sm8250_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sm8250_snd_data *pdata = snd_soc_card_get_drvdata(rtd->card);\n\n\treturn qcom_snd_sdw_hw_params(substream, params, &pdata->sruntime[cpu_dai->id]);\n}\n\nstatic int sm8250_snd_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sm8250_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\treturn qcom_snd_sdw_prepare(substream, sruntime,\n\t\t\t\t    &data->stream_prepared[cpu_dai->id]);\n}\n\nstatic int sm8250_snd_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sm8250_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\treturn qcom_snd_sdw_hw_free(substream, sruntime,\n\t\t\t\t    &data->stream_prepared[cpu_dai->id]);\n}\n\nstatic const struct snd_soc_ops sm8250_be_ops = {\n\t.startup = sm8250_snd_startup,\n\t.hw_params = sm8250_snd_hw_params,\n\t.hw_free = sm8250_snd_hw_free,\n\t.prepare = sm8250_snd_prepare,\n};\n\nstatic void sm8250_add_be_ops(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *link;\n\tint i;\n\n\tfor_each_card_prelinks(card, i, link) {\n\t\tif (link->no_pcm == 1) {\n\t\t\tlink->init = sm8250_snd_init;\n\t\t\tlink->be_hw_params_fixup = sm8250_be_hw_params_fixup;\n\t\t\tlink->ops = &sm8250_be_ops;\n\t\t}\n\t}\n}\n\nstatic int sm8250_platform_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct sm8250_snd_data *data;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->owner = THIS_MODULE;\n\t \n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcard->dev = dev;\n\tdev_set_drvdata(dev, card);\n\tsnd_soc_card_set_drvdata(card, data);\n\tret = qcom_snd_parse_of(card);\n\tif (ret)\n\t\treturn ret;\n\n\tcard->driver_name = DRIVER_NAME;\n\tsm8250_add_be_ops(card);\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic const struct of_device_id snd_sm8250_dt_match[] = {\n\t{.compatible = \"qcom,sm8250-sndcard\"},\n\t{.compatible = \"qcom,qrb5165-rb5-sndcard\"},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, snd_sm8250_dt_match);\n\nstatic struct platform_driver snd_sm8250_driver = {\n\t.probe  = sm8250_platform_probe,\n\t.driver = {\n\t\t.name = \"snd-sm8250\",\n\t\t.of_match_table = snd_sm8250_dt_match,\n\t},\n};\nmodule_platform_driver(snd_sm8250_driver);\nMODULE_AUTHOR(\"Srinivas Kandagatla <srinivas.kandagatla@linaro.org\");\nMODULE_DESCRIPTION(\"SM8250 ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}