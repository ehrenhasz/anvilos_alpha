{
  "module_name": "sc7180.c",
  "hash_id": "76bb7677af779fe0e8c402657c35f06d728c79a8b3ca40f244a194f55e3f9f19",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/sc7180.c",
  "human_readable_source": "\n\n\n\n\n\n#include <dt-bindings/sound/sc7180-lpass.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <uapi/linux/input-event-codes.h>\n\n#include \"../codecs/rt5682.h\"\n#include \"../codecs/rt5682s.h\"\n#include \"common.h\"\n#include \"lpass.h\"\n\n#define DEFAULT_MCLK_RATE\t\t19200000\n#define RT5682_PLL1_FREQ (48000 * 512)\n\n#define DRIVER_NAME \"SC7180\"\n\nstruct sc7180_snd_data {\n\tstruct snd_soc_card card;\n\tu32 pri_mi2s_clk_count;\n\tstruct snd_soc_jack hs_jack;\n\tstruct snd_soc_jack hdmi_jack;\n\tstruct gpio_desc *dmic_sel;\n\tint dmic_switch;\n};\n\nstatic void sc7180_jack_free(struct snd_jack *jack)\n{\n\tstruct snd_soc_component *component = jack->private_data;\n\n\tsnd_soc_component_set_jack(component, NULL, NULL);\n}\n\nstatic struct snd_soc_jack_pin sc7180_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int sc7180_headset_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7180_snd_data *pdata = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_jack *jack;\n\tint rval;\n\n\trval = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t  SND_JACK_HEADSET |\n\t\t\t\t\t  SND_JACK_HEADPHONE |\n\t\t\t\t\t  SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t  SND_JACK_BTN_2 | SND_JACK_BTN_3,\n\t\t\t\t\t  &pdata->hs_jack,\n\t\t\t\t\t  sc7180_jack_pins,\n\t\t\t\t\t  ARRAY_SIZE(sc7180_jack_pins));\n\n\tif (rval < 0) {\n\t\tdev_err(card->dev, \"Unable to add Headset Jack\\n\");\n\t\treturn rval;\n\t}\n\n\tjack = pdata->hs_jack.jack;\n\n\tsnd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tjack->private_data = component;\n\tjack->private_free = sc7180_jack_free;\n\n\treturn snd_soc_component_set_jack(component, &pdata->hs_jack, NULL);\n}\n\nstatic int sc7180_hdmi_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7180_snd_data *pdata = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_jack *jack;\n\tint rval;\n\n\trval = snd_soc_card_jack_new(\n\t\t\tcard, \"HDMI Jack\",\n\t\t\tSND_JACK_LINEOUT,\n\t\t\t&pdata->hdmi_jack);\n\n\tif (rval < 0) {\n\t\tdev_err(card->dev, \"Unable to add HDMI Jack\\n\");\n\t\treturn rval;\n\t}\n\n\tjack = pdata->hdmi_jack.jack;\n\tjack->private_data = component;\n\tjack->private_free = sc7180_jack_free;\n\n\treturn snd_soc_component_set_jack(component, &pdata->hdmi_jack, NULL);\n}\n\nstatic int sc7180_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\treturn sc7180_headset_init(rtd);\n\tcase MI2S_SECONDARY:\n\t\treturn 0;\n\tcase LPASS_DP_RX:\n\t\treturn sc7180_hdmi_init(rtd);\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__,\n\t\t\tcpu_dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int sc7180_snd_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7180_snd_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint pll_id, pll_source, pll_in, pll_out, clk_id, ret;\n\n\tif (!strcmp(codec_dai->name, \"rt5682-aif1\")) {\n\t\tpll_source = RT5682_PLL1_S_MCLK;\n\t\tpll_id = 0;\n\t\tclk_id = RT5682_SCLK_S_PLL1;\n\t\tpll_out = RT5682_PLL1_FREQ;\n\t\tpll_in = DEFAULT_MCLK_RATE;\n\t} else if (!strcmp(codec_dai->name, \"rt5682s-aif1\")) {\n\t\tpll_source = RT5682S_PLL_S_MCLK;\n\t\tpll_id = RT5682S_PLL2;\n\t\tclk_id = RT5682S_SCLK_S_PLL2;\n\t\tpll_out = RT5682_PLL1_FREQ;\n\t\tpll_in = DEFAULT_MCLK_RATE;\n\t}\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\tif (++data->pri_mi2s_clk_count == 1) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\t\t       LPASS_MCLK0,\n\t\t\t\t\t       DEFAULT_MCLK_RATE,\n\t\t\t\t\t       SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\n\t\tsnd_soc_dai_set_fmt(codec_dai,\n\t\t\t\t    SND_SOC_DAIFMT_BC_FC |\n\t\t\t\t    SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t    SND_SOC_DAIFMT_I2S);\n\n\t\t \n\t\tret = snd_soc_dai_set_pll(codec_dai, pll_id, pll_source,\n\t\t\t\t\t  pll_in, pll_out);\n\t\tif (ret) {\n\t\t\tdev_err(rtd->dev, \"can't set codec pll: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = snd_soc_dai_set_sysclk(codec_dai, clk_id, pll_out,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret)\n\t\t\tdev_err(rtd->dev, \"snd_soc_dai_set_sysclk err = %d\\n\",\n\t\t\t\tret);\n\n\t\tbreak;\n\tcase MI2S_SECONDARY:\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__,\n\t\t\tcpu_dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dmic_get(struct snd_kcontrol *kcontrol,\n\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct sc7180_snd_data *data = snd_soc_card_get_drvdata(dapm->card);\n\n\tucontrol->value.integer.value[0] = data->dmic_switch;\n\treturn 0;\n}\n\nstatic int dmic_set(struct snd_kcontrol *kcontrol,\n\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct sc7180_snd_data *data = snd_soc_card_get_drvdata(dapm->card);\n\n\tdata->dmic_switch = ucontrol->value.integer.value[0];\n\tgpiod_set_value(data->dmic_sel, data->dmic_switch);\n\treturn 0;\n}\n\nstatic void sc7180_snd_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7180_snd_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\tif (--data->pri_mi2s_clk_count == 0) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\t\t       LPASS_MCLK0,\n\t\t\t\t\t       0,\n\t\t\t\t\t       SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\t\tbreak;\n\tcase MI2S_SECONDARY:\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__,\n\t\t\tcpu_dai->id);\n\t\tbreak;\n\t}\n}\n\nstatic int sc7180_adau7002_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\treturn 0;\n\tcase MI2S_SECONDARY:\n\t\treturn 0;\n\tcase LPASS_DP_RX:\n\t\treturn sc7180_hdmi_init(rtd);\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__,\n\t\t\tcpu_dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int sc7180_adau7002_snd_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\tsnd_soc_dai_set_fmt(codec_dai,\n\t\t\t\t    SND_SOC_DAIFMT_CBS_CFS |\n\t\t\t\t    SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t    SND_SOC_DAIFMT_I2S);\n\t\truntime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;\n\t\tsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 32);\n\n\t\tbreak;\n\tcase MI2S_SECONDARY:\n\t\tbreak;\n\tcase LPASS_DP_RX:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__,\n\t\t\tcpu_dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops sc7180_ops = {\n\t.startup = sc7180_snd_startup,\n\t.shutdown = sc7180_snd_shutdown,\n};\n\nstatic const struct snd_soc_ops sc7180_adau7002_ops = {\n\t.startup = sc7180_adau7002_snd_startup,\n};\n\nstatic const struct snd_soc_dapm_widget sc7180_snd_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_kcontrol_new sc7180_snd_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_widget sc7180_adau7002_snd_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"DMIC\", NULL),\n};\n\nstatic const char * const dmic_mux_text[] = {\n\t\"Front Mic\",\n\t\"Rear Mic\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(sc7180_dmic_enum,\n\t\t\t    SND_SOC_NOPM, 0, dmic_mux_text);\n\nstatic const struct snd_kcontrol_new sc7180_dmic_mux_control =\n\tSOC_DAPM_ENUM_EXT(\"DMIC Select Mux\", sc7180_dmic_enum,\n\t\t\t  dmic_get, dmic_set);\n\nstatic const struct snd_soc_dapm_widget sc7180_snd_dual_mic_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"DMIC\", NULL),\n\tSND_SOC_DAPM_MUX(\"Dmic Mux\", SND_SOC_NOPM, 0, 0, &sc7180_dmic_mux_control),\n};\n\nstatic const struct snd_kcontrol_new sc7180_snd_dual_mic_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic const struct snd_soc_dapm_route sc7180_snd_dual_mic_audio_route[] = {\n\t{\"Dmic Mux\", \"Front Mic\", \"DMIC\"},\n\t{\"Dmic Mux\", \"Rear Mic\", \"DMIC\"},\n};\n\nstatic int sc7180_snd_platform_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct sc7180_snd_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_dai_link *link;\n\tint ret;\n\tint i;\n\tbool no_headphone = false;\n\n\t \n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcard = &data->card;\n\tsnd_soc_card_set_drvdata(card, data);\n\n\tcard->owner = THIS_MODULE;\n\tcard->driver_name = DRIVER_NAME;\n\tcard->dev = dev;\n\tcard->dapm_widgets = sc7180_snd_widgets;\n\tcard->num_dapm_widgets = ARRAY_SIZE(sc7180_snd_widgets);\n\tcard->controls = sc7180_snd_controls;\n\tcard->num_controls = ARRAY_SIZE(sc7180_snd_controls);\n\n\tif (of_property_read_bool(dev->of_node, \"dmic-gpios\")) {\n\t\tcard->dapm_widgets = sc7180_snd_dual_mic_widgets,\n\t\tcard->num_dapm_widgets = ARRAY_SIZE(sc7180_snd_dual_mic_widgets),\n\t\tcard->controls = sc7180_snd_dual_mic_controls,\n\t\tcard->num_controls = ARRAY_SIZE(sc7180_snd_dual_mic_controls),\n\t\tcard->dapm_routes = sc7180_snd_dual_mic_audio_route,\n\t\tcard->num_dapm_routes = ARRAY_SIZE(sc7180_snd_dual_mic_audio_route),\n\t\tdata->dmic_sel = devm_gpiod_get(&pdev->dev, \"dmic\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(data->dmic_sel)) {\n\t\t\tdev_err(&pdev->dev, \"DMIC gpio failed err=%ld\\n\", PTR_ERR(data->dmic_sel));\n\t\t\treturn PTR_ERR(data->dmic_sel);\n\t\t}\n\t}\n\n\tif (of_device_is_compatible(dev->of_node, \"google,sc7180-coachz\")) {\n\t\tno_headphone = true;\n\t\tcard->dapm_widgets = sc7180_adau7002_snd_widgets;\n\t\tcard->num_dapm_widgets = ARRAY_SIZE(sc7180_adau7002_snd_widgets);\n\t}\n\n\tret = qcom_snd_parse_of(card);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_card_prelinks(card, i, link) {\n\t\tif (no_headphone) {\n\t\t\tlink->ops = &sc7180_adau7002_ops;\n\t\t\tlink->init = sc7180_adau7002_init;\n\t\t} else {\n\t\t\tlink->ops = &sc7180_ops;\n\t\t\tlink->init = sc7180_init;\n\t\t}\n\t}\n\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic const struct of_device_id sc7180_snd_device_id[]  = {\n\t{.compatible = \"google,sc7180-trogdor\"},\n\t{.compatible = \"google,sc7180-coachz\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sc7180_snd_device_id);\n\nstatic struct platform_driver sc7180_snd_driver = {\n\t.probe = sc7180_snd_platform_probe,\n\t.driver = {\n\t\t.name = \"msm-snd-sc7180\",\n\t\t.of_match_table = sc7180_snd_device_id,\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\nmodule_platform_driver(sc7180_snd_driver);\n\nMODULE_DESCRIPTION(\"sc7180 ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}