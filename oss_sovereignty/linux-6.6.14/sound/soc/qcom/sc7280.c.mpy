{
  "module_name": "sc7280.c",
  "hash_id": "e0c9c7a166d110479dfad61138c5e43a95d8033a08fc0b31ccef7cf05163ffde",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/sc7280.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/rt5682s.h>\n#include <linux/soundwire/sdw.h>\n#include <sound/pcm_params.h>\n\n#include \"../codecs/rt5682.h\"\n#include \"../codecs/rt5682s.h\"\n#include \"common.h\"\n#include \"lpass.h\"\n#include \"qdsp6/q6afe.h\"\n\n#define DEFAULT_MCLK_RATE              19200000\n#define RT5682_PLL_FREQ (48000 * 512)\n#define MI2S_BCLK_RATE\t\t1536000\n\nstruct sc7280_snd_data {\n\tstruct snd_soc_card card;\n\tstruct sdw_stream_runtime *sruntime[LPASS_MAX_PORTS];\n\tu32 pri_mi2s_clk_count;\n\tstruct snd_soc_jack hs_jack;\n\tstruct snd_soc_jack hdmi_jack;\n\tbool jack_setup;\n\tbool stream_prepared[LPASS_MAX_PORTS];\n};\n\nstatic void sc7280_jack_free(struct snd_jack *jack)\n{\n\tstruct snd_soc_component *component = jack->private_data;\n\n\tsnd_soc_component_set_jack(component, NULL, NULL);\n}\n\nstatic struct snd_soc_jack_pin sc7280_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone Jack\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int sc7280_headset_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7280_snd_data *pdata = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_jack *jack;\n\tint rval, i;\n\n\tif (!pdata->jack_setup) {\n\t\trval = snd_soc_card_jack_new_pins(card, \"Headset Jack\",\n\t\t\t\t\t\t  SND_JACK_HEADSET | SND_JACK_LINEOUT |\n\t\t\t\t\t\t  SND_JACK_MECHANICAL |\n\t\t\t\t\t\t  SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\t\t\t\t  SND_JACK_BTN_2 | SND_JACK_BTN_3 |\n\t\t\t\t\t\t  SND_JACK_BTN_4 | SND_JACK_BTN_5,\n\t\t\t\t\t\t  &pdata->hs_jack,\n\t\t\t\t\t\t  sc7280_jack_pins,\n\t\t\t\t\t\t  ARRAY_SIZE(sc7280_jack_pins));\n\n\t\tif (rval < 0) {\n\t\t\tdev_err(card->dev, \"Unable to add Headset Jack\\n\");\n\t\t\treturn rval;\n\t\t}\n\n\t\tjack = pdata->hs_jack.jack;\n\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\t\tsnd_jack_set_key(jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\t\tjack->private_data = component;\n\t\tjack->private_free = sc7280_jack_free;\n\t\tpdata->jack_setup = true;\n\t}\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\tcase LPASS_CDC_DMA_RX0:\n\tcase LPASS_CDC_DMA_TX3:\n\tcase TX_CODEC_DMA_TX_3:\n\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t\trval = snd_soc_component_set_jack(component, &pdata->hs_jack, NULL);\n\t\t\tif (rval != 0 && rval != -ENOTSUPP) {\n\t\t\t\tdev_err(card->dev, \"Failed to set jack: %d\\n\", rval);\n\t\t\t\treturn rval;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc7280_hdmi_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7280_snd_data *pdata = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_jack *jack;\n\tint rval;\n\n\trval = snd_soc_card_jack_new(card, \"HDMI Jack\",\tSND_JACK_LINEOUT,\n\t\t\t\t     &pdata->hdmi_jack);\n\n\tif (rval < 0) {\n\t\tdev_err(card->dev, \"Unable to add HDMI Jack\\n\");\n\t\treturn rval;\n\t}\n\n\tjack = pdata->hdmi_jack.jack;\n\tjack->private_data = component;\n\tjack->private_free = sc7280_jack_free;\n\n\treturn snd_soc_component_set_jack(component, &pdata->hdmi_jack, NULL);\n}\n\nstatic int sc7280_rt5682_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7280_snd_data *data = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\tif (++data->pri_mi2s_clk_count == 1) {\n\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\tLPASS_MCLK0,\n\t\t\tDEFAULT_MCLK_RATE,\n\t\t\tSNDRV_PCM_STREAM_PLAYBACK);\n\t}\n\tsnd_soc_dai_set_fmt(codec_dai,\n\t\t\t\tSND_SOC_DAIFMT_CBC_CFC |\n\t\t\t\tSND_SOC_DAIFMT_NB_NF |\n\t\t\t\tSND_SOC_DAIFMT_I2S);\n\n\tret = snd_soc_dai_set_pll(codec_dai, RT5682S_PLL2, RT5682S_PLL_S_MCLK,\n\t\t\t\t\tDEFAULT_MCLK_RATE, RT5682_PLL_FREQ);\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"can't set codec pll: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, RT5682S_SCLK_S_PLL2,\n\t\t\t\t\tRT5682_PLL_FREQ,\n\t\t\t\t\tSND_SOC_CLOCK_IN);\n\n\tif (ret) {\n\t\tdev_err(rtd->dev, \"snd_soc_dai_set_sysclk err = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc7280_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\tcase LPASS_CDC_DMA_TX3:\n\tcase TX_CODEC_DMA_TX_3:\n\t\treturn sc7280_headset_init(rtd);\n\tcase LPASS_CDC_DMA_RX0:\n\tcase LPASS_CDC_DMA_VA_TX0:\n\tcase MI2S_SECONDARY:\n\tcase RX_CODEC_DMA_RX_0:\n\tcase SECONDARY_MI2S_RX:\n\tcase VA_CODEC_DMA_TX_0:\n\t\treturn 0;\n\tcase LPASS_DP_RX:\n\t\treturn sc7280_hdmi_init(rtd);\n\tdefault:\n\t\tdev_err(rtd->dev, \"%s: invalid dai id 0x%x\\n\", __func__, cpu_dai->id);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sc7280_snd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *codec_dai;\n\tconst struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sc7280_snd_data *pdata = snd_soc_card_get_drvdata(rtd->card);\n\tstruct sdw_stream_runtime *sruntime;\n\tint i;\n\n\tif (!rtd->dai_link->no_pcm) {\n\t\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_CHANNELS, 2, 2);\n\t\tsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE, 48000, 48000);\n\t}\n\n\tswitch (cpu_dai->id) {\n\tcase LPASS_CDC_DMA_TX3:\n\tcase LPASS_CDC_DMA_RX0:\n\tcase RX_CODEC_DMA_RX_0:\n\tcase SECONDARY_MI2S_RX:\n\tcase TX_CODEC_DMA_TX_3:\n\tcase VA_CODEC_DMA_TX_0:\n\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t\tsruntime = snd_soc_dai_get_stream(codec_dai, substream->stream);\n\t\t\tif (sruntime != ERR_PTR(-ENOTSUPP))\n\t\t\t\tpdata->sruntime[cpu_dai->id] = sruntime;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc7280_snd_swr_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tconst struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sc7280_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\tint ret;\n\n\tif (!sruntime)\n\t\treturn 0;\n\n\tif (data->stream_prepared[cpu_dai->id]) {\n\t\tsdw_disable_stream(sruntime);\n\t\tsdw_deprepare_stream(sruntime);\n\t\tdata->stream_prepared[cpu_dai->id] = false;\n\t}\n\n\tret = sdw_prepare_stream(sruntime);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdw_enable_stream(sruntime);\n\tif (ret) {\n\t\tsdw_deprepare_stream(sruntime);\n\t\treturn ret;\n\t}\n\tdata->stream_prepared[cpu_dai->id] = true;\n\n\treturn ret;\n}\n\nstatic int sc7280_snd_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tconst struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase LPASS_CDC_DMA_RX0:\n\tcase LPASS_CDC_DMA_TX3:\n\tcase RX_CODEC_DMA_RX_0:\n\tcase TX_CODEC_DMA_TX_3:\n\tcase VA_CODEC_DMA_TX_0:\n\t\treturn sc7280_snd_swr_prepare(substream);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sc7280_snd_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sc7280_snd_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tconst struct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sdw_stream_runtime *sruntime = data->sruntime[cpu_dai->id];\n\n\tswitch (cpu_dai->id) {\n\tcase LPASS_CDC_DMA_RX0:\n\tcase LPASS_CDC_DMA_TX3:\n\tcase RX_CODEC_DMA_RX_0:\n\tcase TX_CODEC_DMA_TX_3:\n\tcase VA_CODEC_DMA_TX_0:\n\t\tif (sruntime && data->stream_prepared[cpu_dai->id]) {\n\t\t\tsdw_disable_stream(sruntime);\n\t\t\tsdw_deprepare_stream(sruntime);\n\t\t\tdata->stream_prepared[cpu_dai->id] = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void sc7280_snd_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct sc7280_snd_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\tif (--data->pri_mi2s_clk_count == 0) {\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\t\t       LPASS_MCLK0,\n\t\t\t\t\t       0,\n\t\t\t\t\t       SNDRV_PCM_STREAM_PLAYBACK);\n\t\t}\n\t\tbreak;\n\tcase SECONDARY_MI2S_RX:\n\t\tsnd_soc_dai_set_sysclk(cpu_dai, Q6AFE_LPASS_CLK_ID_SEC_MI2S_IBIT,\n\t\t\t\t\t       0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int sc7280_snd_startup(struct snd_pcm_substream *substream)\n{\n\tunsigned int fmt = SND_SOC_DAIFMT_CBS_CFS;\n\tunsigned int codec_dai_fmt = SND_SOC_DAIFMT_CBS_CFS;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint ret = 0;\n\n\tswitch (cpu_dai->id) {\n\tcase MI2S_PRIMARY:\n\t\tret = sc7280_rt5682_init(rtd);\n\t\tbreak;\n\tcase SECONDARY_MI2S_RX:\n\t\tcodec_dai_fmt |= SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_I2S;\n\n\t\tsnd_soc_dai_set_sysclk(cpu_dai, Q6AFE_LPASS_CLK_ID_SEC_MI2S_IBIT,\n\t\t\tMI2S_BCLK_RATE, SNDRV_PCM_STREAM_PLAYBACK);\n\n\t\tsnd_soc_dai_set_fmt(cpu_dai, fmt);\n\t\tsnd_soc_dai_set_fmt(codec_dai, codec_dai_fmt);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops sc7280_ops = {\n\t.startup = sc7280_snd_startup,\n\t.hw_params = sc7280_snd_hw_params,\n\t.hw_free = sc7280_snd_hw_free,\n\t.prepare = sc7280_snd_prepare,\n\t.shutdown = sc7280_snd_shutdown,\n};\n\nstatic const struct snd_soc_dapm_widget sc7280_snd_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n};\n\nstatic const struct snd_kcontrol_new sc7280_snd_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone Jack\"),\n\tSOC_DAPM_PIN_SWITCH(\"Headset Mic\"),\n};\n\nstatic int sc7280_snd_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\n\trate->min = rate->max = 48000;\n\tchannels->min = channels->max = 2;\n\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);\n\n\treturn 0;\n}\n\nstatic int sc7280_snd_platform_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card;\n\tstruct sc7280_snd_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_dai_link *link;\n\tint ret, i;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tcard = &data->card;\n\tsnd_soc_card_set_drvdata(card, data);\n\n\tcard->owner = THIS_MODULE;\n\tcard->driver_name = \"SC7280\";\n\tcard->dev = dev;\n\n\tcard->dapm_widgets = sc7280_snd_widgets;\n\tcard->num_dapm_widgets = ARRAY_SIZE(sc7280_snd_widgets);\n\tcard->controls = sc7280_snd_controls;\n\tcard->num_controls = ARRAY_SIZE(sc7280_snd_controls);\n\n\tret = qcom_snd_parse_of(card);\n\tif (ret)\n\t\treturn ret;\n\n\tfor_each_card_prelinks(card, i, link) {\n\t\tlink->init = sc7280_init;\n\t\tlink->ops = &sc7280_ops;\n\t\tif (link->no_pcm == 1)\n\t\t\tlink->be_hw_params_fixup = sc7280_snd_be_hw_params_fixup;\n\t}\n\n\treturn devm_snd_soc_register_card(dev, card);\n}\n\nstatic const struct of_device_id sc7280_snd_device_id[]  = {\n\t{ .compatible = \"google,sc7280-herobrine\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sc7280_snd_device_id);\n\nstatic struct platform_driver sc7280_snd_driver = {\n\t.probe = sc7280_snd_platform_probe,\n\t.driver = {\n\t\t.name = \"msm-snd-sc7280\",\n\t\t.of_match_table = sc7280_snd_device_id,\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\nmodule_platform_driver(sc7280_snd_driver);\n\nMODULE_DESCRIPTION(\"sc7280 ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}