{
  "module_name": "q6apm-lpass-dais.c",
  "hash_id": "0a4dc85b9a318253668d12dae9f61bdbbe2815f3938c527245ac28fc755c3860",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6apm-lpass-dais.c",
  "human_readable_source": "\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include \"q6dsp-lpass-ports.h\"\n#include \"q6dsp-common.h\"\n#include \"audioreach.h\"\n#include \"q6apm.h\"\n\n#define AUDIOREACH_BE_PCM_BASE\t16\n\nstruct q6apm_lpass_dai_data {\n\tstruct q6apm_graph *graph[APM_PORT_MAX];\n\tbool is_port_started[APM_PORT_MAX];\n\tstruct audioreach_module_config module_config[APM_PORT_MAX];\n};\n\nstatic int q6dma_set_channel_map(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int tx_num, unsigned int *tx_ch_mask,\n\t\t\t\t unsigned int rx_num, unsigned int *rx_ch_mask)\n{\n\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct audioreach_module_config *cfg = &dai_data->module_config[dai->id];\n\tint ch_mask;\n\n\tswitch (dai->id) {\n\tcase WSA_CODEC_DMA_TX_0:\n\tcase WSA_CODEC_DMA_TX_1:\n\tcase WSA_CODEC_DMA_TX_2:\n\tcase VA_CODEC_DMA_TX_0:\n\tcase VA_CODEC_DMA_TX_1:\n\tcase VA_CODEC_DMA_TX_2:\n\tcase TX_CODEC_DMA_TX_0:\n\tcase TX_CODEC_DMA_TX_1:\n\tcase TX_CODEC_DMA_TX_2:\n\tcase TX_CODEC_DMA_TX_3:\n\tcase TX_CODEC_DMA_TX_4:\n\tcase TX_CODEC_DMA_TX_5:\n\t\tif (!tx_ch_mask) {\n\t\t\tdev_err(dai->dev, \"tx slot not found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tx_num > AR_PCM_MAX_NUM_CHANNEL) {\n\t\t\tdev_err(dai->dev, \"invalid tx num %d\\n\",\n\t\t\t\ttx_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tch_mask = *tx_ch_mask;\n\n\t\tbreak;\n\tcase WSA_CODEC_DMA_RX_0:\n\tcase WSA_CODEC_DMA_RX_1:\n\tcase RX_CODEC_DMA_RX_0:\n\tcase RX_CODEC_DMA_RX_1:\n\tcase RX_CODEC_DMA_RX_2:\n\tcase RX_CODEC_DMA_RX_3:\n\tcase RX_CODEC_DMA_RX_4:\n\tcase RX_CODEC_DMA_RX_5:\n\tcase RX_CODEC_DMA_RX_6:\n\tcase RX_CODEC_DMA_RX_7:\n\t\t \n\t\tif (!rx_ch_mask) {\n\t\t\tdev_err(dai->dev, \"rx slot not found\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rx_num > APM_PORT_MAX_AUDIO_CHAN_CNT) {\n\t\t\tdev_err(dai->dev, \"invalid rx num %d\\n\",\n\t\t\t\trx_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tch_mask = *rx_ch_mask;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"%s: invalid dai id 0x%x\\n\",\n\t\t\t__func__, dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->active_channels_mask = ch_mask;\n\n\treturn 0;\n}\n\nstatic int q6hdmi_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct audioreach_module_config *cfg = &dai_data->module_config[dai->id];\n\tint channels = params_channels(params);\n\tint ret;\n\n\tcfg->bit_width = params_width(params);\n\tcfg->sample_rate = params_rate(params);\n\tcfg->num_channels = channels;\n\n\tswitch (dai->id) {\n\tcase DISPLAY_PORT_RX_0:\n\t\tcfg->dp_idx = 0;\n\t\tbreak;\n\tcase DISPLAY_PORT_RX_1 ... DISPLAY_PORT_RX_7:\n\t\tcfg->dp_idx = dai->id - DISPLAY_PORT_RX_1 + 1;\n\t\tbreak;\n\t}\n\n\tret = q6dsp_get_channel_allocation(channels);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcfg->channel_allocation = ret;\n\n\treturn 0;\n}\n\nstatic int q6dma_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct audioreach_module_config *cfg = &dai_data->module_config[dai->id];\n\n\tcfg->bit_width = params_width(params);\n\tcfg->sample_rate = params_rate(params);\n\tcfg->num_channels = params_channels(params);\n\n\treturn 0;\n}\n\nstatic void q6apm_lpass_dai_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tint rc;\n\n\tif (!dai_data->is_port_started[dai->id])\n\t\treturn;\n\trc = q6apm_graph_stop(dai_data->graph[dai->id]);\n\tif (rc < 0)\n\t\tdev_err(dai->dev, \"fail to close APM port (%d)\\n\", rc);\n\n\tq6apm_graph_close(dai_data->graph[dai->id]);\n\tdai_data->is_port_started[dai->id] = false;\n}\n\nstatic int q6apm_lpass_dai_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct audioreach_module_config *cfg = &dai_data->module_config[dai->id];\n\tstruct q6apm_graph *graph;\n\tint graph_id = dai->id;\n\tint rc;\n\n\tif (dai_data->is_port_started[dai->id]) {\n\t\tq6apm_graph_stop(dai_data->graph[dai->id]);\n\t\tdai_data->is_port_started[dai->id] = false;\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tq6apm_graph_close(dai_data->graph[dai->id]);\n\t}\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tgraph = q6apm_graph_open(dai->dev, NULL, dai->dev, graph_id);\n\t\tif (IS_ERR(graph)) {\n\t\t\tdev_err(dai->dev, \"Failed to open graph (%d)\\n\", graph_id);\n\t\t\trc = PTR_ERR(graph);\n\t\t\treturn rc;\n\t\t}\n\t\tdai_data->graph[graph_id] = graph;\n\t}\n\n\tcfg->direction = substream->stream;\n\trc = q6apm_graph_media_format_pcm(dai_data->graph[dai->id], cfg);\n\n\tif (rc) {\n\t\tdev_err(dai->dev, \"Failed to set media format %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = q6apm_graph_prepare(dai_data->graph[dai->id]);\n\tif (rc) {\n\t\tdev_err(dai->dev, \"Failed to prepare Graph %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = q6apm_graph_start(dai_data->graph[dai->id]);\n\tif (rc < 0) {\n\t\tdev_err(dai->dev, \"fail to start APM port %x\\n\", dai->id);\n\t\treturn rc;\n\t}\n\tdai_data->is_port_started[dai->id] = true;\n\n\treturn 0;\n}\n\nstatic int q6apm_lpass_dai_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct q6apm_graph *graph;\n\tint graph_id = dai->id;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tgraph = q6apm_graph_open(dai->dev, NULL, dai->dev, graph_id);\n\t\tif (IS_ERR(graph)) {\n\t\t\tdev_err(dai->dev, \"Failed to open graph (%d)\\n\", graph_id);\n\t\t\treturn PTR_ERR(graph);\n\t\t}\n\t\tdai_data->graph[graph_id] = graph;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct q6apm_lpass_dai_data *dai_data = dev_get_drvdata(dai->dev);\n\tstruct audioreach_module_config *cfg = &dai_data->module_config[dai->id];\n\n\tcfg->fmt = fmt;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops q6dma_ops = {\n\t.prepare\t= q6apm_lpass_dai_prepare,\n\t.startup\t= q6apm_lpass_dai_startup,\n\t.shutdown\t= q6apm_lpass_dai_shutdown,\n\t.set_channel_map  = q6dma_set_channel_map,\n\t.hw_params        = q6dma_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops q6i2s_ops = {\n\t.prepare\t= q6apm_lpass_dai_prepare,\n\t.startup\t= q6apm_lpass_dai_startup,\n\t.shutdown\t= q6apm_lpass_dai_shutdown,\n\t.set_channel_map  = q6dma_set_channel_map,\n\t.hw_params        = q6dma_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops q6hdmi_ops = {\n\t.prepare\t= q6apm_lpass_dai_prepare,\n\t.startup\t= q6apm_lpass_dai_startup,\n\t.shutdown\t= q6apm_lpass_dai_shutdown,\n\t.hw_params\t= q6hdmi_hw_params,\n\t.set_fmt\t= q6i2s_set_fmt,\n};\n\nstatic const struct snd_soc_component_driver q6apm_lpass_dai_component = {\n\t.name = \"q6apm-be-dai-component\",\n\t.of_xlate_dai_name = q6dsp_audio_ports_of_xlate_dai_name,\n\t.be_pcm_base = AUDIOREACH_BE_PCM_BASE,\n\t.use_dai_pcm_id = true,\n};\n\nstatic int q6apm_lpass_dai_dev_probe(struct platform_device *pdev)\n{\n\tstruct q6dsp_audio_port_dai_driver_config cfg;\n\tstruct q6apm_lpass_dai_data *dai_data;\n\tstruct snd_soc_dai_driver *dais;\n\tstruct device *dev = &pdev->dev;\n\tint num_dais;\n\n\tdai_data = devm_kzalloc(dev, sizeof(*dai_data), GFP_KERNEL);\n\tif (!dai_data)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, dai_data);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.q6i2s_ops = &q6i2s_ops;\n\tcfg.q6dma_ops = &q6dma_ops;\n\tcfg.q6hdmi_ops = &q6hdmi_ops;\n\tdais = q6dsp_audio_ports_set_config(dev, &cfg, &num_dais);\n\n\treturn devm_snd_soc_register_component(dev, &q6apm_lpass_dai_component, dais, num_dais);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6apm_lpass_dai_device_id[] = {\n\t{ .compatible = \"qcom,q6apm-lpass-dais\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6apm_lpass_dai_device_id);\n#endif\n\nstatic struct platform_driver q6apm_lpass_dai_platform_driver = {\n\t.driver = {\n\t\t.name = \"q6apm-lpass-dais\",\n\t\t.of_match_table = of_match_ptr(q6apm_lpass_dai_device_id),\n\t},\n\t.probe = q6apm_lpass_dai_dev_probe,\n};\nmodule_platform_driver(q6apm_lpass_dai_platform_driver);\n\nMODULE_DESCRIPTION(\"AUDIOREACH APM LPASS dai driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}