{
  "module_name": "q6adm.c",
  "hash_id": "7d1470580033d93bb6b2a004389aed64b558c16999a14f0cb027e23415347bcd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6adm.c",
  "human_readable_source": "\n\n\n\n#include <linux/device.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kref.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/apr.h>\n#include <linux/wait.h>\n#include <sound/asound.h>\n#include \"q6adm.h\"\n#include \"q6afe.h\"\n#include \"q6core.h\"\n#include \"q6dsp-common.h\"\n#include \"q6dsp-errno.h\"\n\n#define ADM_CMD_DEVICE_OPEN_V5\t\t0x00010326\n#define ADM_CMDRSP_DEVICE_OPEN_V5\t0x00010329\n#define ADM_CMD_DEVICE_CLOSE_V5\t\t0x00010327\n#define ADM_CMD_MATRIX_MAP_ROUTINGS_V5\t0x00010325\n\n#define TIMEOUT_MS 1000\n#define RESET_COPP_ID 99\n#define INVALID_COPP_ID 0xFF\n \n#define ADM_LEGACY_DEVICE_SESSION\t0\n#define ADM_MATRIX_ID_AUDIO_RX\t\t0\n#define ADM_MATRIX_ID_AUDIO_TX\t\t1\n\nstruct q6copp {\n\tint afe_port;\n\tint copp_idx;\n\tint id;\n\tint topology;\n\tint mode;\n\tint rate;\n\tint bit_width;\n\tint channels;\n\tint app_type;\n\tint acdb_id;\n\n\tstruct aprv2_ibasic_rsp_result_t result;\n\tstruct kref refcount;\n\twait_queue_head_t wait;\n\tstruct list_head node;\n\tstruct q6adm *adm;\n};\n\nstruct q6adm {\n\tstruct apr_device *apr;\n\tstruct device *dev;\n\tstruct q6core_svc_api_info ainfo;\n\tunsigned long copp_bitmap[AFE_MAX_PORTS];\n\tstruct list_head copps_list;\n\tspinlock_t copps_list_lock;\n\tstruct aprv2_ibasic_rsp_result_t result;\n\tstruct mutex lock;\n\twait_queue_head_t matrix_map_wait;\n};\n\nstruct q6adm_cmd_device_open_v5 {\n\tu16 flags;\n\tu16 mode_of_operation;\n\tu16 endpoint_id_1;\n\tu16 endpoint_id_2;\n\tu32 topology_id;\n\tu16 dev_num_channel;\n\tu16 bit_width;\n\tu32 sample_rate;\n\tu8 dev_channel_mapping[8];\n} __packed;\n\nstruct q6adm_cmd_matrix_map_routings_v5 {\n\tu32 matrix_id;\n\tu32 num_sessions;\n} __packed;\n\nstruct q6adm_session_map_node_v5 {\n\tu16 session_id;\n\tu16 num_copps;\n} __packed;\n\nstatic struct q6copp *q6adm_find_copp(struct q6adm *adm, int port_idx,\n\t\t\t\t  int copp_idx)\n{\n\tstruct q6copp *c;\n\tstruct q6copp *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adm->copps_list_lock, flags);\n\tlist_for_each_entry(c, &adm->copps_list, node) {\n\t\tif ((port_idx == c->afe_port) && (copp_idx == c->copp_idx)) {\n\t\t\tret = c;\n\t\t\tkref_get(&c->refcount);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&adm->copps_list_lock, flags);\n\n\treturn ret;\n\n}\n\nstatic void q6adm_free_copp(struct kref *ref)\n{\n\tstruct q6copp *c = container_of(ref, struct q6copp, refcount);\n\tstruct q6adm *adm = c->adm;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adm->copps_list_lock, flags);\n\tclear_bit(c->copp_idx, &adm->copp_bitmap[c->afe_port]);\n\tlist_del(&c->node);\n\tspin_unlock_irqrestore(&adm->copps_list_lock, flags);\n\tkfree(c);\n}\n\nstatic int q6adm_callback(struct apr_device *adev, struct apr_resp_pkt *data)\n{\n\tstruct aprv2_ibasic_rsp_result_t *result = data->payload;\n\tint port_idx, copp_idx;\n\tstruct apr_hdr *hdr = &data->hdr;\n\tstruct q6copp *copp;\n\tstruct q6adm *adm = dev_get_drvdata(&adev->dev);\n\n\tif (!data->payload_size)\n\t\treturn 0;\n\n\tcopp_idx = (hdr->token) & 0XFF;\n\tport_idx = ((hdr->token) >> 16) & 0xFF;\n\tif (port_idx < 0 || port_idx >= AFE_MAX_PORTS) {\n\t\tdev_err(&adev->dev, \"Invalid port idx %d token %d\\n\",\n\t\t       port_idx, hdr->token);\n\t\treturn 0;\n\t}\n\tif (copp_idx < 0 || copp_idx >= MAX_COPPS_PER_PORT) {\n\t\tdev_err(&adev->dev, \"Invalid copp idx %d token %d\\n\",\n\t\t\tcopp_idx, hdr->token);\n\t\treturn 0;\n\t}\n\n\tswitch (hdr->opcode) {\n\tcase APR_BASIC_RSP_RESULT: {\n\t\tif (result->status != 0) {\n\t\t\tdev_err(&adev->dev, \"cmd = 0x%x return error = 0x%x\\n\",\n\t\t\t\tresult->opcode, result->status);\n\t\t}\n\t\tswitch (result->opcode) {\n\t\tcase ADM_CMD_DEVICE_OPEN_V5:\n\t\tcase ADM_CMD_DEVICE_CLOSE_V5:\n\t\t\tcopp = q6adm_find_copp(adm, port_idx, copp_idx);\n\t\t\tif (!copp)\n\t\t\t\treturn 0;\n\n\t\t\tcopp->result = *result;\n\t\t\twake_up(&copp->wait);\n\t\t\tkref_put(&copp->refcount, q6adm_free_copp);\n\t\t\tbreak;\n\t\tcase ADM_CMD_MATRIX_MAP_ROUTINGS_V5:\n\t\t\tadm->result = *result;\n\t\t\twake_up(&adm->matrix_map_wait);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&adev->dev, \"Unknown Cmd: 0x%x\\n\",\n\t\t\t\tresult->opcode);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase ADM_CMDRSP_DEVICE_OPEN_V5: {\n\t\tstruct adm_cmd_rsp_device_open_v5 {\n\t\t\tu32 status;\n\t\t\tu16 copp_id;\n\t\t\tu16 reserved;\n\t\t} __packed *open = data->payload;\n\n\t\tcopp = q6adm_find_copp(adm, port_idx, copp_idx);\n\t\tif (!copp)\n\t\t\treturn 0;\n\n\t\tif (open->copp_id == INVALID_COPP_ID) {\n\t\t\tdev_err(&adev->dev, \"Invalid coppid rxed %d\\n\",\n\t\t\t\topen->copp_id);\n\t\t\tcopp->result.status = ADSP_EBADPARAM;\n\t\t\twake_up(&copp->wait);\n\t\t\tkref_put(&copp->refcount, q6adm_free_copp);\n\t\t\tbreak;\n\t\t}\n\t\tcopp->result.opcode = hdr->opcode;\n\t\tcopp->id = open->copp_id;\n\t\twake_up(&copp->wait);\n\t\tkref_put(&copp->refcount, q6adm_free_copp);\n\t}\n\tbreak;\n\tdefault:\n\t\tdev_err(&adev->dev, \"Unknown cmd:0x%x\\n\",\n\t\t       hdr->opcode);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct q6copp *q6adm_alloc_copp(struct q6adm *adm, int port_idx)\n{\n\tstruct q6copp *c;\n\tint idx;\n\n\tidx = find_first_zero_bit(&adm->copp_bitmap[port_idx],\n\t\t\t\t  MAX_COPPS_PER_PORT);\n\n\tif (idx >= MAX_COPPS_PER_PORT)\n\t\treturn ERR_PTR(-EBUSY);\n\n\tc = kzalloc(sizeof(*c), GFP_ATOMIC);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_bit(idx, &adm->copp_bitmap[port_idx]);\n\tc->copp_idx = idx;\n\tc->afe_port = port_idx;\n\tc->adm = adm;\n\n\tinit_waitqueue_head(&c->wait);\n\n\treturn c;\n}\n\nstatic int q6adm_apr_send_copp_pkt(struct q6adm *adm, struct q6copp *copp,\n\t\t\t\t   struct apr_pkt *pkt, uint32_t rsp_opcode)\n{\n\tstruct device *dev = adm->dev;\n\tuint32_t opcode = pkt->hdr.opcode;\n\tint ret;\n\n\tmutex_lock(&adm->lock);\n\tcopp->result.opcode = 0;\n\tcopp->result.status = 0;\n\tret = apr_send_pkt(adm->apr, pkt);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to send APR packet\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (rsp_opcode)\n\t\tret = wait_event_timeout(copp->wait,\n\t\t\t\t\t (copp->result.opcode == opcode) ||\n\t\t\t\t\t (copp->result.opcode == rsp_opcode),\n\t\t\t\t\t msecs_to_jiffies(TIMEOUT_MS));\n\telse\n\t\tret = wait_event_timeout(copp->wait,\n\t\t\t\t\t (copp->result.opcode == opcode),\n\t\t\t\t\t msecs_to_jiffies(TIMEOUT_MS));\n\n\tif (!ret) {\n\t\tdev_err(dev, \"ADM copp cmd timedout\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (copp->result.status > 0) {\n\t\tdev_err(dev, \"DSP returned error[%d]\\n\",\n\t\t\tcopp->result.status);\n\t\tret = -EINVAL;\n\t}\n\nerr:\n\tmutex_unlock(&adm->lock);\n\treturn ret;\n}\n\nstatic int q6adm_device_close(struct q6adm *adm, struct q6copp *copp,\n\t\t\t      int port_id, int copp_idx)\n{\n\tstruct apr_pkt close;\n\n\tclose.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t\tAPR_HDR_LEN(APR_HDR_SIZE),\n\t\t\t\t\tAPR_PKT_VER);\n\tclose.hdr.pkt_size = sizeof(close);\n\tclose.hdr.src_port = port_id;\n\tclose.hdr.dest_port = copp->id;\n\tclose.hdr.token = port_id << 16 | copp_idx;\n\tclose.hdr.opcode = ADM_CMD_DEVICE_CLOSE_V5;\n\n\treturn q6adm_apr_send_copp_pkt(adm, copp, &close, 0);\n}\n\nstatic struct q6copp *q6adm_find_matching_copp(struct q6adm *adm,\n\t\t\t\t\t       int port_id, int topology,\n\t\t\t\t\t       int mode, int rate,\n\t\t\t\t\t       int channel_mode, int bit_width,\n\t\t\t\t\t       int app_type)\n{\n\tstruct q6copp *c;\n\tstruct q6copp *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adm->copps_list_lock, flags);\n\n\tlist_for_each_entry(c, &adm->copps_list, node) {\n\t\tif ((port_id == c->afe_port) && (topology == c->topology) &&\n\t\t    (mode == c->mode) && (rate == c->rate) &&\n\t\t    (bit_width == c->bit_width) && (app_type == c->app_type)) {\n\t\t\tret = c;\n\t\t\tkref_get(&c->refcount);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&adm->copps_list_lock, flags);\n\n\treturn ret;\n}\n\nstatic int q6adm_device_open(struct q6adm *adm, struct q6copp *copp,\n\t\t\t     int port_id, int path, int topology,\n\t\t\t     int channel_mode, int bit_width, int rate)\n{\n\tstruct q6adm_cmd_device_open_v5 *open;\n\tint afe_port = q6afe_get_port_id(port_id);\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint ret, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*open);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\topen = p + APR_HDR_SIZE;\n\tpkt->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t\t   APR_HDR_LEN(APR_HDR_SIZE),\n\t\t\t\t\t   APR_PKT_VER);\n\tpkt->hdr.pkt_size = pkt_size;\n\tpkt->hdr.src_port = afe_port;\n\tpkt->hdr.dest_port = afe_port;\n\tpkt->hdr.token = port_id << 16 | copp->copp_idx;\n\tpkt->hdr.opcode = ADM_CMD_DEVICE_OPEN_V5;\n\topen->flags = ADM_LEGACY_DEVICE_SESSION;\n\topen->mode_of_operation = path;\n\topen->endpoint_id_1 = afe_port;\n\topen->topology_id = topology;\n\topen->dev_num_channel = channel_mode & 0x00FF;\n\topen->bit_width = bit_width;\n\topen->sample_rate = rate;\n\n\tret = q6dsp_map_channels(&open->dev_channel_mapping[0],\n\t\t\t\t channel_mode);\n\tif (ret)\n\t\tgoto err;\n\n\tret = q6adm_apr_send_copp_pkt(adm, copp, pkt,\n\t\t\t\t      ADM_CMDRSP_DEVICE_OPEN_V5);\n\nerr:\n\tkfree(pkt);\n\treturn ret;\n}\n\n \nstruct q6copp *q6adm_open(struct device *dev, int port_id, int path, int rate,\n\t       int channel_mode, int topology, int perf_mode,\n\t       uint16_t bit_width, int app_type, int acdb_id)\n{\n\tstruct q6adm *adm = dev_get_drvdata(dev->parent);\n\tstruct q6copp *copp;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (port_id < 0) {\n\t\tdev_err(dev, \"Invalid port_id %d\\n\", port_id);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcopp = q6adm_find_matching_copp(adm, port_id, topology, perf_mode,\n\t\t\t\t      rate, channel_mode, bit_width, app_type);\n\tif (copp) {\n\t\tdev_err(dev, \"Found Matching Copp 0x%x\\n\", copp->copp_idx);\n\t\treturn copp;\n\t}\n\n\tspin_lock_irqsave(&adm->copps_list_lock, flags);\n\tcopp = q6adm_alloc_copp(adm, port_id);\n\tif (IS_ERR(copp)) {\n\t\tspin_unlock_irqrestore(&adm->copps_list_lock, flags);\n\t\treturn ERR_CAST(copp);\n\t}\n\n\tlist_add_tail(&copp->node, &adm->copps_list);\n\tspin_unlock_irqrestore(&adm->copps_list_lock, flags);\n\n\tkref_init(&copp->refcount);\n\tcopp->topology = topology;\n\tcopp->mode = perf_mode;\n\tcopp->rate = rate;\n\tcopp->channels = channel_mode;\n\tcopp->bit_width = bit_width;\n\tcopp->app_type = app_type;\n\n\tret = q6adm_device_open(adm, copp, port_id, path, topology,\n\t\t\t\tchannel_mode, bit_width, rate);\n\tif (ret < 0) {\n\t\tkref_put(&copp->refcount, q6adm_free_copp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn copp;\n}\nEXPORT_SYMBOL_GPL(q6adm_open);\n\n \nint q6adm_get_copp_id(struct q6copp *copp)\n{\n\tif (!copp)\n\t\treturn -EINVAL;\n\n\treturn copp->copp_idx;\n}\nEXPORT_SYMBOL_GPL(q6adm_get_copp_id);\n\n \nint q6adm_matrix_map(struct device *dev, int path,\n\t\t     struct route_payload payload_map, int perf_mode)\n{\n\tstruct q6adm *adm = dev_get_drvdata(dev->parent);\n\tstruct q6adm_cmd_matrix_map_routings_v5 *route;\n\tstruct q6adm_session_map_node_v5 *node;\n\tstruct apr_pkt *pkt;\n\tuint16_t *copps_list;\n\tint pkt_size, ret, i, copp_idx;\n\tvoid *matrix_map;\n\tstruct q6copp *copp;\n\n\t \n\tpkt_size = (APR_HDR_SIZE + sizeof(*route) +  sizeof(*node) +\n\t\t    (sizeof(uint32_t) * payload_map.num_copps));\n\n\tmatrix_map = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!matrix_map)\n\t\treturn -ENOMEM;\n\n\tpkt = matrix_map;\n\troute = matrix_map + APR_HDR_SIZE;\n\tnode = matrix_map + APR_HDR_SIZE + sizeof(*route);\n\tcopps_list = matrix_map + APR_HDR_SIZE + sizeof(*route) + sizeof(*node);\n\n\tpkt->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t\t   APR_HDR_LEN(APR_HDR_SIZE),\n\t\t\t\t\t   APR_PKT_VER);\n\tpkt->hdr.pkt_size = pkt_size;\n\tpkt->hdr.token = 0;\n\tpkt->hdr.opcode = ADM_CMD_MATRIX_MAP_ROUTINGS_V5;\n\troute->num_sessions = 1;\n\n\tswitch (path) {\n\tcase ADM_PATH_PLAYBACK:\n\t\troute->matrix_id = ADM_MATRIX_ID_AUDIO_RX;\n\t\tbreak;\n\tcase ADM_PATH_LIVE_REC:\n\t\troute->matrix_id = ADM_MATRIX_ID_AUDIO_TX;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Wrong path set[%d]\\n\", path);\n\t\tbreak;\n\t}\n\n\tnode->session_id = payload_map.session_id;\n\tnode->num_copps = payload_map.num_copps;\n\n\tfor (i = 0; i < payload_map.num_copps; i++) {\n\t\tint port_idx = payload_map.port_id[i];\n\n\t\tif (port_idx < 0) {\n\t\t\tdev_err(dev, \"Invalid port_id %d\\n\",\n\t\t\t\tpayload_map.port_id[i]);\n\t\t\tkfree(pkt);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcopp_idx = payload_map.copp_idx[i];\n\n\t\tcopp = q6adm_find_copp(adm, port_idx, copp_idx);\n\t\tif (!copp) {\n\t\t\tkfree(pkt);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcopps_list[i] = copp->id;\n\t\tkref_put(&copp->refcount, q6adm_free_copp);\n\t}\n\n\tmutex_lock(&adm->lock);\n\tadm->result.status = 0;\n\tadm->result.opcode = 0;\n\n\tret = apr_send_pkt(adm->apr, pkt);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"routing for stream %d failed ret %d\\n\",\n\t\t       payload_map.session_id, ret);\n\t\tgoto fail_cmd;\n\t}\n\tret = wait_event_timeout(adm->matrix_map_wait,\n\t\t\t\t adm->result.opcode == pkt->hdr.opcode,\n\t\t\t\t msecs_to_jiffies(TIMEOUT_MS));\n\tif (!ret) {\n\t\tdev_err(dev, \"routing for stream %d failed\\n\",\n\t\t       payload_map.session_id);\n\t\tret = -ETIMEDOUT;\n\t\tgoto fail_cmd;\n\t} else if (adm->result.status > 0) {\n\t\tdev_err(dev, \"DSP returned error[%d]\\n\",\n\t\t\tadm->result.status);\n\t\tret = -EINVAL;\n\t\tgoto fail_cmd;\n\t}\n\nfail_cmd:\n\tmutex_unlock(&adm->lock);\n\tkfree(pkt);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(q6adm_matrix_map);\n\n \nint q6adm_close(struct device *dev, struct q6copp *copp)\n{\n\tstruct q6adm *adm = dev_get_drvdata(dev->parent);\n\tint ret = 0;\n\n\tret = q6adm_device_close(adm, copp, copp->afe_port, copp->copp_idx);\n\tif (ret < 0) {\n\t\tdev_err(adm->dev, \"Failed to close copp %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkref_put(&copp->refcount, q6adm_free_copp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(q6adm_close);\n\nstatic int q6adm_probe(struct apr_device *adev)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct q6adm *adm;\n\n\tadm = devm_kzalloc(dev, sizeof(*adm), GFP_KERNEL);\n\tif (!adm)\n\t\treturn -ENOMEM;\n\n\tadm->apr = adev;\n\tdev_set_drvdata(dev, adm);\n\tadm->dev = dev;\n\tq6core_get_svc_api_info(adev->svc_id, &adm->ainfo);\n\tmutex_init(&adm->lock);\n\tinit_waitqueue_head(&adm->matrix_map_wait);\n\n\tINIT_LIST_HEAD(&adm->copps_list);\n\tspin_lock_init(&adm->copps_list_lock);\n\n\treturn devm_of_platform_populate(dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6adm_device_id[]  = {\n\t{ .compatible = \"qcom,q6adm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6adm_device_id);\n#endif\n\nstatic struct apr_driver qcom_q6adm_driver = {\n\t.probe = q6adm_probe,\n\t.callback = q6adm_callback,\n\t.driver = {\n\t\t.name = \"qcom-q6adm\",\n\t\t.of_match_table = of_match_ptr(q6adm_device_id),\n\t},\n};\n\nmodule_apr_driver(qcom_q6adm_driver);\nMODULE_DESCRIPTION(\"Q6 Audio Device Manager\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}