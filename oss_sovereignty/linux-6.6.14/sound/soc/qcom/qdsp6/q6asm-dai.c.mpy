{
  "module_name": "q6asm-dai.c",
  "hash_id": "1e124b3cb6e75647538c8e00fdaddd3356a81fb8effb09161b6d31e3afa94d31",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6asm-dai.c",
  "human_readable_source": "\n\n\n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include <linux/spinlock.h>\n#include <sound/compress_driver.h>\n#include <asm/dma.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_device.h>\n#include <sound/pcm_params.h>\n#include \"q6asm.h\"\n#include \"q6routing.h\"\n#include \"q6dsp-errno.h\"\n\n#define DRV_NAME\t\"q6asm-fe-dai\"\n\n#define PLAYBACK_MIN_NUM_PERIODS    2\n#define PLAYBACK_MAX_NUM_PERIODS   8\n#define PLAYBACK_MAX_PERIOD_SIZE    65536\n#define PLAYBACK_MIN_PERIOD_SIZE    128\n#define CAPTURE_MIN_NUM_PERIODS     2\n#define CAPTURE_MAX_NUM_PERIODS     8\n#define CAPTURE_MAX_PERIOD_SIZE     4096\n#define CAPTURE_MIN_PERIOD_SIZE     320\n#define SID_MASK_DEFAULT\t0xF\n\n \n#define COMPR_PLAYBACK_MIN_FRAGMENT_SIZE (8 * 1024)\n#define COMPR_PLAYBACK_MAX_FRAGMENT_SIZE (128 * 1024)\n#define COMPR_PLAYBACK_MIN_NUM_FRAGMENTS (4)\n#define COMPR_PLAYBACK_MAX_NUM_FRAGMENTS (16 * 4)\n\n#define ALAC_CH_LAYOUT_MONO   ((101 << 16) | 1)\n#define ALAC_CH_LAYOUT_STEREO ((101 << 16) | 2)\n\nenum stream_state {\n\tQ6ASM_STREAM_IDLE = 0,\n\tQ6ASM_STREAM_STOPPED,\n\tQ6ASM_STREAM_RUNNING,\n};\n\nstruct q6asm_dai_rtd {\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_compr_stream *cstream;\n\tstruct snd_codec codec;\n\tstruct snd_dma_buffer dma_buffer;\n\tspinlock_t lock;\n\tphys_addr_t phys;\n\tunsigned int pcm_size;\n\tunsigned int pcm_count;\n\tunsigned int pcm_irq_pos;        \n\tunsigned int periods;\n\tunsigned int bytes_sent;\n\tunsigned int bytes_received;\n\tunsigned int copied_total;\n\tuint16_t bits_per_sample;\n\tuint16_t source;  \n\tstruct audio_client *audio_client;\n\tuint32_t next_track_stream_id;\n\tbool next_track;\n\tuint32_t stream_id;\n\tuint16_t session_id;\n\tenum stream_state state;\n\tuint32_t initial_samples_drop;\n\tuint32_t trailing_samples_drop;\n\tbool notify_on_drain;\n};\n\nstruct q6asm_dai_data {\n\tstruct snd_soc_dai_driver *dais;\n\tint num_dais;\n\tlong long int sid;\n};\n\nstatic const struct snd_pcm_hardware q6asm_dai_hardware_capture = {\n\t.info =                 (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_BATCH |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),\n\t.formats =              (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE),\n\t.rates =                SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =             8000,\n\t.rate_max =             48000,\n\t.channels_min =         1,\n\t.channels_max =         4,\n\t.buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS *\n\t\t\t\tCAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min =\tCAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min =          CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max =          CAPTURE_MAX_NUM_PERIODS,\n\t.fifo_size =            0,\n};\n\nstatic struct snd_pcm_hardware q6asm_dai_hardware_playback = {\n\t.info =                 (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_BATCH |\n\t\t\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),\n\t.formats =              (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE),\n\t.rates =                SNDRV_PCM_RATE_8000_192000,\n\t.rate_min =             8000,\n\t.rate_max =             192000,\n\t.channels_min =         1,\n\t.channels_max =         8,\n\t.buffer_bytes_max =     (PLAYBACK_MAX_NUM_PERIODS *\n\t\t\t\tPLAYBACK_MAX_PERIOD_SIZE),\n\t.period_bytes_min =\tPLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max =     PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min =          PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max =          PLAYBACK_MAX_NUM_PERIODS,\n\t.fifo_size =            0,\n};\n\n#define Q6ASM_FEDAI_DRIVER(num) { \\\n\t\t.playback = {\t\t\t\t\t\t\\\n\t\t\t.stream_name = \"MultiMedia\"#num\" Playback\",\t\\\n\t\t\t.rates = (SNDRV_PCM_RATE_8000_192000|\t\t\\\n\t\t\t\t\tSNDRV_PCM_RATE_KNOT),\t\t\\\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\t\t\\\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE),\t\\\n\t\t\t.channels_min = 1,\t\t\t\t\\\n\t\t\t.channels_max = 8,\t\t\t\t\\\n\t\t\t.rate_min =     8000,\t\t\t\t\\\n\t\t\t.rate_max =\t192000,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.capture = {\t\t\t\t\t\t\\\n\t\t\t.stream_name = \"MultiMedia\"#num\" Capture\",\t\\\n\t\t\t.rates = (SNDRV_PCM_RATE_8000_48000|\t\t\\\n\t\t\t\t\tSNDRV_PCM_RATE_KNOT),\t\t\\\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\t\t\\\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE),\t\t\\\n\t\t\t.channels_min = 1,\t\t\t\t\\\n\t\t\t.channels_max = 4,\t\t\t\t\\\n\t\t\t.rate_min =     8000,\t\t\t\t\\\n\t\t\t.rate_max =\t48000,\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t\t.name = \"MultiMedia\"#num,\t\t\t\t\\\n\t\t.id = MSM_FRONTEND_DAI_MULTIMEDIA##num,\t\t\t\\\n\t}\n\n \nstatic unsigned int supported_sample_rates[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,\n\t88200, 96000, 176400, 192000\n};\n\nstatic struct snd_pcm_hw_constraint_list constraints_sample_rates = {\n\t.count = ARRAY_SIZE(supported_sample_rates),\n\t.list = supported_sample_rates,\n\t.mask = 0,\n};\n\nstatic const struct snd_compr_codec_caps q6asm_compr_caps = {\n\t.num_descriptors = 1,\n\t.descriptor[0].max_ch = 2,\n\t.descriptor[0].sample_rates = {\t8000, 11025, 12000, 16000, 22050,\n\t\t\t\t\t24000, 32000, 44100, 48000, 88200,\n\t\t\t\t\t96000, 176400, 192000 },\n\t.descriptor[0].num_sample_rates = 13,\n\t.descriptor[0].bit_rate[0] = 320,\n\t.descriptor[0].bit_rate[1] = 128,\n\t.descriptor[0].num_bitrates = 2,\n\t.descriptor[0].profiles = 0,\n\t.descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO,\n\t.descriptor[0].formats = 0,\n};\n\nstatic void event_handler(uint32_t opcode, uint32_t token,\n\t\t\t  void *payload, void *priv)\n{\n\tstruct q6asm_dai_rtd *prtd = priv;\n\tstruct snd_pcm_substream *substream = prtd->substream;\n\n\tswitch (opcode) {\n\tcase ASM_CLIENT_EVENT_CMD_RUN_DONE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tq6asm_write_async(prtd->audio_client, prtd->stream_id,\n\t\t\t\t   prtd->pcm_count, 0, 0, 0);\n\t\tbreak;\n\tcase ASM_CLIENT_EVENT_CMD_EOS_DONE:\n\t\tprtd->state = Q6ASM_STREAM_STOPPED;\n\t\tbreak;\n\tcase ASM_CLIENT_EVENT_DATA_WRITE_DONE: {\n\t\tprtd->pcm_irq_pos += prtd->pcm_count;\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tif (prtd->state == Q6ASM_STREAM_RUNNING)\n\t\t\tq6asm_write_async(prtd->audio_client, prtd->stream_id,\n\t\t\t\t\t   prtd->pcm_count, 0, 0, 0);\n\n\t\tbreak;\n\t\t}\n\tcase ASM_CLIENT_EVENT_DATA_READ_DONE:\n\t\tprtd->pcm_irq_pos += prtd->pcm_count;\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tif (prtd->state == Q6ASM_STREAM_RUNNING)\n\t\t\tq6asm_read(prtd->audio_client, prtd->stream_id);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int q6asm_dai_prepare(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_prtd = asoc_substream_to_rtd(substream);\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tstruct q6asm_dai_data *pdata;\n\tstruct device *dev = component->dev;\n\tint ret, i;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tif (!prtd || !prtd->audio_client) {\n\t\tdev_err(dev, \"%s: private data null or audio client freed\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tprtd->pcm_count = snd_pcm_lib_period_bytes(substream);\n\tprtd->pcm_irq_pos = 0;\n\t \n\tif (prtd->state) {\n\t\t \n\t\tq6asm_cmd(prtd->audio_client, prtd->stream_id, CMD_CLOSE);\n\t\tq6asm_unmap_memory_regions(substream->stream,\n\t\t\t\t\t   prtd->audio_client);\n\t\tq6routing_stream_close(soc_prtd->dai_link->id,\n\t\t\t\t\t substream->stream);\n\t}\n\n\tret = q6asm_map_memory_regions(substream->stream, prtd->audio_client,\n\t\t\t\t       prtd->phys,\n\t\t\t\t       (prtd->pcm_size / prtd->periods),\n\t\t\t\t       prtd->periods);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Audio Start: Buffer Allocation failed rc = %d\\n\",\n\t\t\t\t\t\t\tret);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = q6asm_open_write(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       FORMAT_LINEAR_PCM,\n\t\t\t\t       0, prtd->bits_per_sample, false);\n\t} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tret = q6asm_open_read(prtd->audio_client, prtd->stream_id,\n\t\t\t\t      FORMAT_LINEAR_PCM,\n\t\t\t\t      prtd->bits_per_sample);\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: q6asm_open_write failed\\n\", __func__);\n\t\tgoto open_err;\n\t}\n\n\tprtd->session_id = q6asm_get_session_id(prtd->audio_client);\n\tret = q6routing_stream_open(soc_prtd->dai_link->id, LEGACY_PCM_MODE,\n\t\t\t      prtd->session_id, substream->stream);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: stream reg failed ret:%d\\n\", __func__, ret);\n\t\tgoto routing_err;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = q6asm_media_format_block_multi_ch_pcm(\n\t\t\t\tprtd->audio_client, prtd->stream_id,\n\t\t\t\truntime->rate, runtime->channels, NULL,\n\t\t\t\tprtd->bits_per_sample);\n\t} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tret = q6asm_enc_cfg_blk_pcm_format_support(prtd->audio_client,\n\t\t\t\t\t\t\t   prtd->stream_id,\n\t\t\t\t\t\t\t   runtime->rate,\n\t\t\t\t\t\t\t   runtime->channels,\n\t\t\t\t\t\t\t   prtd->bits_per_sample);\n\n\t\t \n\t\tfor (i = 0; i < runtime->periods; i++)\n\t\t\tq6asm_read(prtd->audio_client, prtd->stream_id);\n\n\t}\n\tif (ret < 0)\n\t\tdev_info(dev, \"%s: CMD Format block failed\\n\", __func__);\n\telse\n\t\tprtd->state = Q6ASM_STREAM_RUNNING;\n\n\treturn ret;\n\nrouting_err:\n\tq6asm_cmd(prtd->audio_client, prtd->stream_id,  CMD_CLOSE);\nopen_err:\n\tq6asm_unmap_memory_regions(substream->stream, prtd->audio_client);\n\tq6asm_audio_client_free(prtd->audio_client);\n\tprtd->audio_client = NULL;\n\n\treturn ret;\n}\n\nstatic int q6asm_dai_trigger(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret = 0;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = q6asm_run_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       0, 0, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tprtd->state = Q6ASM_STREAM_STOPPED;\n\t\tret = q6asm_cmd_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       CMD_EOS);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = q6asm_cmd_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       CMD_PAUSE);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6asm_dai_open(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_prtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_prtd, 0);\n\tstruct q6asm_dai_rtd *prtd;\n\tstruct q6asm_dai_data *pdata;\n\tstruct device *dev = component->dev;\n\tint ret = 0;\n\tint stream_id;\n\n\tstream_id = cpu_dai->driver->id;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Drv data not found ..\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprtd = kzalloc(sizeof(struct q6asm_dai_rtd), GFP_KERNEL);\n\tif (prtd == NULL)\n\t\treturn -ENOMEM;\n\n\tprtd->substream = substream;\n\tprtd->audio_client = q6asm_audio_client_alloc(dev,\n\t\t\t\t(q6asm_cb)event_handler, prtd, stream_id,\n\t\t\t\tLEGACY_PCM_MODE);\n\tif (IS_ERR(prtd->audio_client)) {\n\t\tdev_info(dev, \"%s: Could not allocate memory\\n\", __func__);\n\t\tret = PTR_ERR(prtd->audio_client);\n\t\tkfree(prtd);\n\t\treturn ret;\n\t}\n\n\t \n\tprtd->stream_id = 1;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = q6asm_dai_hardware_playback;\n\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\truntime->hw = q6asm_dai_hardware_capture;\n\n\tret = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t&constraints_sample_rates);\n\tif (ret < 0)\n\t\tdev_info(dev, \"snd_pcm_hw_constraint_list failed\\n\");\n\t \n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\tdev_info(dev, \"snd_pcm_hw_constraint_integer failed\\n\");\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\tPLAYBACK_MIN_NUM_PERIODS * PLAYBACK_MIN_PERIOD_SIZE,\n\t\t\tPLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"constraint for buffer bytes min max ret = %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"constraint for period bytes step ret = %d\\n\",\n\t\t\t\t\t\t\t\tret);\n\t}\n\tret = snd_pcm_hw_constraint_step(runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"constraint for buffer bytes step ret = %d\\n\",\n\t\t\t\t\t\t\t\tret);\n\t}\n\n\truntime->private_data = prtd;\n\n\tsnd_soc_set_runtime_hwparams(substream, &q6asm_dai_hardware_playback);\n\n\truntime->dma_bytes = q6asm_dai_hardware_playback.buffer_bytes_max;\n\n\n\tif (pdata->sid < 0)\n\t\tprtd->phys = substream->dma_buffer.addr;\n\telse\n\t\tprtd->phys = substream->dma_buffer.addr | (pdata->sid << 32);\n\n\treturn 0;\n}\n\nstatic int q6asm_dai_close(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_prtd = asoc_substream_to_rtd(substream);\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\n\tif (prtd->audio_client) {\n\t\tif (prtd->state)\n\t\t\tq6asm_cmd(prtd->audio_client, prtd->stream_id,\n\t\t\t\t  CMD_CLOSE);\n\n\t\tq6asm_unmap_memory_regions(substream->stream,\n\t\t\t\t\t   prtd->audio_client);\n\t\tq6asm_audio_client_free(prtd->audio_client);\n\t\tprtd->audio_client = NULL;\n\t}\n\tq6routing_stream_close(soc_prtd->dai_link->id,\n\t\t\t\t\t\tsubstream->stream);\n\tkfree(prtd);\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t q6asm_dai_pointer(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\n\tif (prtd->pcm_irq_pos >= prtd->pcm_size)\n\t\tprtd->pcm_irq_pos = 0;\n\n\treturn bytes_to_frames(runtime, (prtd->pcm_irq_pos));\n}\n\nstatic int q6asm_dai_hw_params(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\n\tprtd->pcm_size = params_buffer_bytes(params);\n\tprtd->periods = params_periods(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tprtd->bits_per_sample = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tprtd->bits_per_sample = 24;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void compress_event_handler(uint32_t opcode, uint32_t token,\n\t\t\t\t   void *payload, void *priv)\n{\n\tstruct q6asm_dai_rtd *prtd = priv;\n\tstruct snd_compr_stream *substream = prtd->cstream;\n\tunsigned long flags;\n\tu32 wflags = 0;\n\tuint64_t avail;\n\tuint32_t bytes_written, bytes_to_write;\n\tbool is_last_buffer = false;\n\n\tswitch (opcode) {\n\tcase ASM_CLIENT_EVENT_CMD_RUN_DONE:\n\t\tspin_lock_irqsave(&prtd->lock, flags);\n\t\tif (!prtd->bytes_sent) {\n\t\t\tq6asm_stream_remove_initial_silence(prtd->audio_client,\n\t\t\t\t\t\t    prtd->stream_id,\n\t\t\t\t\t\t    prtd->initial_samples_drop);\n\n\t\t\tq6asm_write_async(prtd->audio_client, prtd->stream_id,\n\t\t\t\t\t  prtd->pcm_count, 0, 0, 0);\n\t\t\tprtd->bytes_sent += prtd->pcm_count;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tbreak;\n\n\tcase ASM_CLIENT_EVENT_CMD_EOS_DONE:\n\t\tspin_lock_irqsave(&prtd->lock, flags);\n\t\tif (prtd->notify_on_drain) {\n\t\t\tif (substream->partial_drain) {\n\t\t\t\t \n\t\t\t\tq6asm_cmd_nowait(prtd->audio_client,\n\t\t\t\t\t\t prtd->stream_id,\n\t\t\t\t\t\t CMD_CLOSE);\n\t\t\t\t \n\t\t\t\tprtd->stream_id = (prtd->stream_id == 1 ? 2 : 1);\n\t\t\t}\n\n\t\t\tsnd_compr_drain_notify(prtd->cstream);\n\t\t\tprtd->notify_on_drain = false;\n\n\t\t} else {\n\t\t\tprtd->state = Q6ASM_STREAM_STOPPED;\n\t\t}\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tbreak;\n\n\tcase ASM_CLIENT_EVENT_DATA_WRITE_DONE:\n\t\tspin_lock_irqsave(&prtd->lock, flags);\n\n\t\tbytes_written = token >> ASM_WRITE_TOKEN_LEN_SHIFT;\n\t\tprtd->copied_total += bytes_written;\n\t\tsnd_compr_fragment_elapsed(substream);\n\n\t\tif (prtd->state != Q6ASM_STREAM_RUNNING) {\n\t\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tavail = prtd->bytes_received - prtd->bytes_sent;\n\t\tif (avail > prtd->pcm_count) {\n\t\t\tbytes_to_write = prtd->pcm_count;\n\t\t} else {\n\t\t\tif (substream->partial_drain || prtd->notify_on_drain)\n\t\t\t\tis_last_buffer = true;\n\t\t\tbytes_to_write = avail;\n\t\t}\n\n\t\tif (bytes_to_write) {\n\t\t\tif (substream->partial_drain && is_last_buffer) {\n\t\t\t\twflags |= ASM_LAST_BUFFER_FLAG;\n\t\t\t\tq6asm_stream_remove_trailing_silence(prtd->audio_client,\n\t\t\t\t\t\t     prtd->stream_id,\n\t\t\t\t\t\t     prtd->trailing_samples_drop);\n\t\t\t}\n\n\t\t\tq6asm_write_async(prtd->audio_client, prtd->stream_id,\n\t\t\t\t\t  bytes_to_write, 0, 0, wflags);\n\n\t\t\tprtd->bytes_sent += bytes_to_write;\n\t\t}\n\n\t\tif (prtd->notify_on_drain && is_last_buffer)\n\t\t\tq6asm_cmd_nowait(prtd->audio_client,\n\t\t\t\t\t prtd->stream_id, CMD_EOS);\n\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int q6asm_dai_compr_open(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = stream->private_data;\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct q6asm_dai_data *pdata;\n\tstruct device *dev = component->dev;\n\tstruct q6asm_dai_rtd *prtd;\n\tint stream_id, size, ret;\n\n\tstream_id = cpu_dai->driver->id;\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Drv data not found ..\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (!prtd)\n\t\treturn -ENOMEM;\n\n\t \n\tprtd->stream_id = 1;\n\n\tprtd->cstream = stream;\n\tprtd->audio_client = q6asm_audio_client_alloc(dev,\n\t\t\t\t\t(q6asm_cb)compress_event_handler,\n\t\t\t\t\tprtd, stream_id, LEGACY_PCM_MODE);\n\tif (IS_ERR(prtd->audio_client)) {\n\t\tdev_err(dev, \"Could not allocate memory\\n\");\n\t\tret = PTR_ERR(prtd->audio_client);\n\t\tgoto free_prtd;\n\t}\n\n\tsize = COMPR_PLAYBACK_MAX_FRAGMENT_SIZE *\n\t\t\tCOMPR_PLAYBACK_MAX_NUM_FRAGMENTS;\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dev, size,\n\t\t\t\t  &prtd->dma_buffer);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot allocate buffer(s)\\n\");\n\t\tgoto free_client;\n\t}\n\n\tif (pdata->sid < 0)\n\t\tprtd->phys = prtd->dma_buffer.addr;\n\telse\n\t\tprtd->phys = prtd->dma_buffer.addr | (pdata->sid << 32);\n\n\tsnd_compr_set_runtime_buffer(stream, &prtd->dma_buffer);\n\tspin_lock_init(&prtd->lock);\n\truntime->private_data = prtd;\n\n\treturn 0;\n\nfree_client:\n\tq6asm_audio_client_free(prtd->audio_client);\nfree_prtd:\n\tkfree(prtd);\n\n\treturn ret;\n}\n\nstatic int q6asm_dai_compr_free(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = stream->private_data;\n\n\tif (prtd->audio_client) {\n\t\tif (prtd->state) {\n\t\t\tq6asm_cmd(prtd->audio_client, prtd->stream_id,\n\t\t\t\t  CMD_CLOSE);\n\t\t\tif (prtd->next_track_stream_id) {\n\t\t\t\tq6asm_cmd(prtd->audio_client,\n\t\t\t\t\t  prtd->next_track_stream_id,\n\t\t\t\t\t  CMD_CLOSE);\n\t\t\t}\n\t\t}\n\n\t\tsnd_dma_free_pages(&prtd->dma_buffer);\n\t\tq6asm_unmap_memory_regions(stream->direction,\n\t\t\t\t\t   prtd->audio_client);\n\t\tq6asm_audio_client_free(prtd->audio_client);\n\t\tprtd->audio_client = NULL;\n\t}\n\tq6routing_stream_close(rtd->dai_link->id, stream->direction);\n\tkfree(prtd);\n\n\treturn 0;\n}\n\nstatic int __q6asm_dai_compr_set_codec_params(struct snd_soc_component *component,\n\t\t\t\t\t      struct snd_compr_stream *stream,\n\t\t\t\t\t      struct snd_codec *codec,\n\t\t\t\t\t      int stream_id)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tstruct q6asm_flac_cfg flac_cfg;\n\tstruct q6asm_wma_cfg wma_cfg;\n\tstruct q6asm_alac_cfg alac_cfg;\n\tstruct q6asm_ape_cfg ape_cfg;\n\tunsigned int wma_v9 = 0;\n\tstruct device *dev = component->dev;\n\tint ret;\n\tunion snd_codec_options *codec_options;\n\tstruct snd_dec_flac *flac;\n\tstruct snd_dec_wma *wma;\n\tstruct snd_dec_alac *alac;\n\tstruct snd_dec_ape *ape;\n\n\tcodec_options = &(prtd->codec.options);\n\n\tmemcpy(&prtd->codec, codec, sizeof(*codec));\n\n\tswitch (codec->id) {\n\tcase SND_AUDIOCODEC_FLAC:\n\n\t\tmemset(&flac_cfg, 0x0, sizeof(struct q6asm_flac_cfg));\n\t\tflac = &codec_options->flac_d;\n\n\t\tflac_cfg.ch_cfg = codec->ch_in;\n\t\tflac_cfg.sample_rate = codec->sample_rate;\n\t\tflac_cfg.stream_info_present = 1;\n\t\tflac_cfg.sample_size = flac->sample_size;\n\t\tflac_cfg.min_blk_size = flac->min_blk_size;\n\t\tflac_cfg.max_blk_size = flac->max_blk_size;\n\t\tflac_cfg.max_frame_size = flac->max_frame_size;\n\t\tflac_cfg.min_frame_size = flac->min_frame_size;\n\n\t\tret = q6asm_stream_media_format_block_flac(prtd->audio_client,\n\t\t\t\t\t\t\t   stream_id,\n\t\t\t\t\t\t\t   &flac_cfg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"FLAC CMD Format block failed:%d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase SND_AUDIOCODEC_WMA:\n\t\twma = &codec_options->wma_d;\n\n\t\tmemset(&wma_cfg, 0x0, sizeof(struct q6asm_wma_cfg));\n\n\t\twma_cfg.sample_rate =  codec->sample_rate;\n\t\twma_cfg.num_channels = codec->ch_in;\n\t\twma_cfg.bytes_per_sec = codec->bit_rate / 8;\n\t\twma_cfg.block_align = codec->align;\n\t\twma_cfg.bits_per_sample = prtd->bits_per_sample;\n\t\twma_cfg.enc_options = wma->encoder_option;\n\t\twma_cfg.adv_enc_options = wma->adv_encoder_option;\n\t\twma_cfg.adv_enc_options2 = wma->adv_encoder_option2;\n\n\t\tif (wma_cfg.num_channels == 1)\n\t\t\twma_cfg.channel_mask = 4;  \n\t\telse if (wma_cfg.num_channels == 2)\n\t\t\twma_cfg.channel_mask = 3;  \n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tswitch (codec->profile) {\n\t\tcase SND_AUDIOPROFILE_WMA9:\n\t\t\twma_cfg.fmtag = 0x161;\n\t\t\twma_v9 = 1;\n\t\t\tbreak;\n\n\t\tcase SND_AUDIOPROFILE_WMA10:\n\t\t\twma_cfg.fmtag = 0x166;\n\t\t\tbreak;\n\n\t\tcase SND_AUDIOPROFILE_WMA9_PRO:\n\t\t\twma_cfg.fmtag = 0x162;\n\t\t\tbreak;\n\n\t\tcase SND_AUDIOPROFILE_WMA9_LOSSLESS:\n\t\t\twma_cfg.fmtag = 0x163;\n\t\t\tbreak;\n\n\t\tcase SND_AUDIOPROFILE_WMA10_LOSSLESS:\n\t\t\twma_cfg.fmtag = 0x167;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unknown WMA profile:%x\\n\",\n\t\t\t\tcodec->profile);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (wma_v9)\n\t\t\tret = q6asm_stream_media_format_block_wma_v9(\n\t\t\t\t\tprtd->audio_client, stream_id,\n\t\t\t\t\t&wma_cfg);\n\t\telse\n\t\t\tret = q6asm_stream_media_format_block_wma_v10(\n\t\t\t\t\tprtd->audio_client, stream_id,\n\t\t\t\t\t&wma_cfg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"WMA9 CMD failed:%d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase SND_AUDIOCODEC_ALAC:\n\t\tmemset(&alac_cfg, 0x0, sizeof(alac_cfg));\n\t\talac = &codec_options->alac_d;\n\n\t\talac_cfg.sample_rate = codec->sample_rate;\n\t\talac_cfg.avg_bit_rate = codec->bit_rate;\n\t\talac_cfg.bit_depth = prtd->bits_per_sample;\n\t\talac_cfg.num_channels = codec->ch_in;\n\n\t\talac_cfg.frame_length = alac->frame_length;\n\t\talac_cfg.pb = alac->pb;\n\t\talac_cfg.mb = alac->mb;\n\t\talac_cfg.kb = alac->kb;\n\t\talac_cfg.max_run = alac->max_run;\n\t\talac_cfg.compatible_version = alac->compatible_version;\n\t\talac_cfg.max_frame_bytes = alac->max_frame_bytes;\n\n\t\tswitch (codec->ch_in) {\n\t\tcase 1:\n\t\t\talac_cfg.channel_layout_tag = ALAC_CH_LAYOUT_MONO;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\talac_cfg.channel_layout_tag = ALAC_CH_LAYOUT_STEREO;\n\t\t\tbreak;\n\t\t}\n\t\tret = q6asm_stream_media_format_block_alac(prtd->audio_client,\n\t\t\t\t\t\t\t   stream_id,\n\t\t\t\t\t\t\t   &alac_cfg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"ALAC CMD Format block failed:%d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tcase SND_AUDIOCODEC_APE:\n\t\tmemset(&ape_cfg, 0x0, sizeof(ape_cfg));\n\t\tape = &codec_options->ape_d;\n\n\t\tape_cfg.sample_rate = codec->sample_rate;\n\t\tape_cfg.num_channels = codec->ch_in;\n\t\tape_cfg.bits_per_sample = prtd->bits_per_sample;\n\n\t\tape_cfg.compatible_version = ape->compatible_version;\n\t\tape_cfg.compression_level = ape->compression_level;\n\t\tape_cfg.format_flags = ape->format_flags;\n\t\tape_cfg.blocks_per_frame = ape->blocks_per_frame;\n\t\tape_cfg.final_frame_blocks = ape->final_frame_blocks;\n\t\tape_cfg.total_frames = ape->total_frames;\n\t\tape_cfg.seek_table_present = ape->seek_table_present;\n\n\t\tret = q6asm_stream_media_format_block_ape(prtd->audio_client,\n\t\t\t\t\t\t\t  stream_id,\n\t\t\t\t\t\t\t  &ape_cfg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"APE CMD Format block failed:%d\\n\", ret);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6asm_dai_compr_set_params(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *stream,\n\t\t\t\t      struct snd_compr_params *params)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = stream->private_data;\n\tint dir = stream->direction;\n\tstruct q6asm_dai_data *pdata;\n\tstruct device *dev = component->dev;\n\tint ret;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tif (!prtd || !prtd->audio_client) {\n\t\tdev_err(dev, \"private data null or audio client freed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprtd->periods = runtime->fragments;\n\tprtd->pcm_count = runtime->fragment_size;\n\tprtd->pcm_size = runtime->fragments * runtime->fragment_size;\n\tprtd->bits_per_sample = 16;\n\n\tif (dir == SND_COMPRESS_PLAYBACK) {\n\t\tret = q6asm_open_write(prtd->audio_client, prtd->stream_id, params->codec.id,\n\t\t\t\tparams->codec.profile, prtd->bits_per_sample,\n\t\t\t\ttrue);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"q6asm_open_write failed\\n\");\n\t\t\tq6asm_audio_client_free(prtd->audio_client);\n\t\t\tprtd->audio_client = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tprtd->session_id = q6asm_get_session_id(prtd->audio_client);\n\tret = q6routing_stream_open(rtd->dai_link->id, LEGACY_PCM_MODE,\n\t\t\t      prtd->session_id, dir);\n\tif (ret) {\n\t\tdev_err(dev, \"Stream reg failed ret:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = __q6asm_dai_compr_set_codec_params(component, stream,\n\t\t\t\t\t\t &params->codec,\n\t\t\t\t\t\t prtd->stream_id);\n\tif (ret) {\n\t\tdev_err(dev, \"codec param setup failed ret:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = q6asm_map_memory_regions(dir, prtd->audio_client, prtd->phys,\n\t\t\t\t       (prtd->pcm_size / prtd->periods),\n\t\t\t\t       prtd->periods);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Buffer Mapping failed ret:%d\\n\", ret);\n\t\treturn -ENOMEM;\n\t}\n\n\tprtd->state = Q6ASM_STREAM_RUNNING;\n\n\treturn 0;\n}\n\nstatic int q6asm_dai_compr_set_metadata(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_compr_stream *stream,\n\t\t\t\t\tstruct snd_compr_metadata *metadata)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (metadata->key) {\n\tcase SNDRV_COMPRESS_ENCODER_PADDING:\n\t\tprtd->trailing_samples_drop = metadata->value[0];\n\t\tbreak;\n\tcase SNDRV_COMPRESS_ENCODER_DELAY:\n\t\tprtd->initial_samples_drop = metadata->value[0];\n\t\tif (prtd->next_track_stream_id) {\n\t\t\tret = q6asm_open_write(prtd->audio_client,\n\t\t\t\t\t       prtd->next_track_stream_id,\n\t\t\t\t\t       prtd->codec.id,\n\t\t\t\t\t       prtd->codec.profile,\n\t\t\t\t\t       prtd->bits_per_sample,\n\t\t\t\t       true);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev, \"q6asm_open_write failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tret = __q6asm_dai_compr_set_codec_params(component, stream,\n\t\t\t\t\t\t\t\t &prtd->codec,\n\t\t\t\t\t\t\t\t prtd->next_track_stream_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev, \"q6asm_open_write failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = q6asm_stream_remove_initial_silence(prtd->audio_client,\n\t\t\t\t\t\t    prtd->next_track_stream_id,\n\t\t\t\t\t\t    prtd->initial_samples_drop);\n\t\t\tprtd->next_track_stream_id = 0;\n\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6asm_dai_compr_trigger(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *stream, int cmd)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = q6asm_run_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       0, 0, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tprtd->state = Q6ASM_STREAM_STOPPED;\n\t\tret = q6asm_cmd_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       CMD_EOS);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = q6asm_cmd_nowait(prtd->audio_client, prtd->stream_id,\n\t\t\t\t       CMD_PAUSE);\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_NEXT_TRACK:\n\t\tprtd->next_track = true;\n\t\tprtd->next_track_stream_id = (prtd->stream_id == 1 ? 2 : 1);\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_DRAIN:\n\tcase SND_COMPR_TRIGGER_PARTIAL_DRAIN:\n\t\tprtd->notify_on_drain = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6asm_dai_compr_pointer(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *stream,\n\t\t\t\t   struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\n\ttstamp->copied_total = prtd->copied_total;\n\ttstamp->byte_offset = prtd->copied_total % prtd->pcm_size;\n\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn 0;\n}\n\nstatic int q6asm_compr_copy(struct snd_soc_component *component,\n\t\t\t    struct snd_compr_stream *stream, char __user *buf,\n\t\t\t    size_t count)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tunsigned long flags;\n\tu32 wflags = 0;\n\tint avail, bytes_in_flight = 0;\n\tvoid *dstn;\n\tsize_t copy;\n\tu32 app_pointer;\n\tu32 bytes_received;\n\n\tbytes_received = prtd->bytes_received;\n\n\t \n\tif (prtd->next_track)\n\t\tbytes_received = ALIGN(prtd->bytes_received, prtd->pcm_count);\n\n\tapp_pointer = bytes_received/prtd->pcm_size;\n\tapp_pointer = bytes_received -  (app_pointer * prtd->pcm_size);\n\tdstn = prtd->dma_buffer.area + app_pointer;\n\n\tif (count < prtd->pcm_size - app_pointer) {\n\t\tif (copy_from_user(dstn, buf, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tcopy = prtd->pcm_size - app_pointer;\n\t\tif (copy_from_user(dstn, buf, copy))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(prtd->dma_buffer.area, buf + copy,\n\t\t\t\t   count - copy))\n\t\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\n\tbytes_in_flight = prtd->bytes_received - prtd->copied_total;\n\n\tif (prtd->next_track) {\n\t\tprtd->next_track = false;\n\t\tprtd->copied_total = ALIGN(prtd->copied_total, prtd->pcm_count);\n\t\tprtd->bytes_sent = ALIGN(prtd->bytes_sent, prtd->pcm_count);\n\t}\n\n\tprtd->bytes_received = bytes_received + count;\n\n\t \n\tif (prtd->state == Q6ASM_STREAM_RUNNING && (bytes_in_flight == 0)) {\n\t\tuint32_t bytes_to_write = prtd->pcm_count;\n\n\t\tavail = prtd->bytes_received - prtd->bytes_sent;\n\n\t\tif (avail < prtd->pcm_count)\n\t\t\tbytes_to_write = avail;\n\n\t\tq6asm_write_async(prtd->audio_client, prtd->stream_id,\n\t\t\t\t  bytes_to_write, 0, 0, wflags);\n\t\tprtd->bytes_sent += bytes_to_write;\n\t}\n\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn count;\n}\n\nstatic int q6asm_dai_compr_mmap(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6asm_dai_rtd *prtd = runtime->private_data;\n\tstruct device *dev = component->dev;\n\n\treturn dma_mmap_coherent(dev, vma,\n\t\t\tprtd->dma_buffer.area, prtd->dma_buffer.addr,\n\t\t\tprtd->dma_buffer.bytes);\n}\n\nstatic int q6asm_dai_compr_get_caps(struct snd_soc_component *component,\n\t\t\t\t    struct snd_compr_stream *stream,\n\t\t\t\t    struct snd_compr_caps *caps)\n{\n\tcaps->direction = SND_COMPRESS_PLAYBACK;\n\tcaps->min_fragment_size = COMPR_PLAYBACK_MIN_FRAGMENT_SIZE;\n\tcaps->max_fragment_size = COMPR_PLAYBACK_MAX_FRAGMENT_SIZE;\n\tcaps->min_fragments = COMPR_PLAYBACK_MIN_NUM_FRAGMENTS;\n\tcaps->max_fragments = COMPR_PLAYBACK_MAX_NUM_FRAGMENTS;\n\tcaps->num_codecs = 5;\n\tcaps->codecs[0] = SND_AUDIOCODEC_MP3;\n\tcaps->codecs[1] = SND_AUDIOCODEC_FLAC;\n\tcaps->codecs[2] = SND_AUDIOCODEC_WMA;\n\tcaps->codecs[3] = SND_AUDIOCODEC_ALAC;\n\tcaps->codecs[4] = SND_AUDIOCODEC_APE;\n\n\treturn 0;\n}\n\nstatic int q6asm_dai_compr_get_codec_caps(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_compr_stream *stream,\n\t\t\t\t\t  struct snd_compr_codec_caps *codec)\n{\n\tswitch (codec->codec) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\t*codec = q6asm_compr_caps;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_compress_ops q6asm_dai_compress_ops = {\n\t.open\t\t= q6asm_dai_compr_open,\n\t.free\t\t= q6asm_dai_compr_free,\n\t.set_params\t= q6asm_dai_compr_set_params,\n\t.set_metadata\t= q6asm_dai_compr_set_metadata,\n\t.pointer\t= q6asm_dai_compr_pointer,\n\t.trigger\t= q6asm_dai_compr_trigger,\n\t.get_caps\t= q6asm_dai_compr_get_caps,\n\t.get_codec_caps\t= q6asm_dai_compr_get_codec_caps,\n\t.mmap\t\t= q6asm_dai_compr_mmap,\n\t.copy\t\t= q6asm_compr_copy,\n};\n\nstatic int q6asm_dai_pcm_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tsize_t size = q6asm_dai_hardware_playback.buffer_bytes_max;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    component->dev, size);\n}\n\nstatic const struct snd_soc_dapm_widget q6asm_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL1\", \"MultiMedia1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL2\", \"MultiMedia2 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL3\", \"MultiMedia3 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL4\", \"MultiMedia4 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL5\", \"MultiMedia5 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL6\", \"MultiMedia6 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL7\", \"MultiMedia7 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"MM_DL8\", \"MultiMedia8 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL1\", \"MultiMedia1 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL2\", \"MultiMedia2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL3\", \"MultiMedia3 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL4\", \"MultiMedia4 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL5\", \"MultiMedia5 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL6\", \"MultiMedia6 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL7\", \"MultiMedia7 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"MM_UL8\", \"MultiMedia8 Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_component_driver q6asm_fe_dai_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.open\t\t\t= q6asm_dai_open,\n\t.hw_params\t\t= q6asm_dai_hw_params,\n\t.close\t\t\t= q6asm_dai_close,\n\t.prepare\t\t= q6asm_dai_prepare,\n\t.trigger\t\t= q6asm_dai_trigger,\n\t.pointer\t\t= q6asm_dai_pointer,\n\t.pcm_construct\t\t= q6asm_dai_pcm_new,\n\t.compress_ops\t\t= &q6asm_dai_compress_ops,\n\t.dapm_widgets\t\t= q6asm_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(q6asm_dapm_widgets),\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic struct snd_soc_dai_driver q6asm_fe_dais_template[] = {\n\tQ6ASM_FEDAI_DRIVER(1),\n\tQ6ASM_FEDAI_DRIVER(2),\n\tQ6ASM_FEDAI_DRIVER(3),\n\tQ6ASM_FEDAI_DRIVER(4),\n\tQ6ASM_FEDAI_DRIVER(5),\n\tQ6ASM_FEDAI_DRIVER(6),\n\tQ6ASM_FEDAI_DRIVER(7),\n\tQ6ASM_FEDAI_DRIVER(8),\n};\n\nstatic const struct snd_soc_dai_ops q6asm_dai_ops = {\n\t.compress_new = snd_soc_new_compress,\n};\n\nstatic int of_q6asm_parse_dai_data(struct device *dev,\n\t\t\t\t    struct q6asm_dai_data *pdata)\n{\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct snd_soc_pcm_stream empty_stream;\n\tstruct device_node *node;\n\tint ret, id, dir, idx = 0;\n\n\n\tpdata->num_dais = of_get_child_count(dev->of_node);\n\tif (!pdata->num_dais) {\n\t\tdev_err(dev, \"No dais found in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->dais = devm_kcalloc(dev, pdata->num_dais, sizeof(*dai_drv),\n\t\t\t\t   GFP_KERNEL);\n\tif (!pdata->dais)\n\t\treturn -ENOMEM;\n\n\tmemset(&empty_stream, 0, sizeof(empty_stream));\n\n\tfor_each_child_of_node(dev->of_node, node) {\n\t\tret = of_property_read_u32(node, \"reg\", &id);\n\t\tif (ret || id >= MAX_SESSIONS || id < 0) {\n\t\t\tdev_err(dev, \"valid dai id not found:%d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdai_drv = &pdata->dais[idx++];\n\t\t*dai_drv = q6asm_fe_dais_template[id];\n\n\t\tret = of_property_read_u32(node, \"direction\", &dir);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (dir == Q6ASM_DAI_RX)\n\t\t\tdai_drv->capture = empty_stream;\n\t\telse if (dir == Q6ASM_DAI_TX)\n\t\t\tdai_drv->playback = empty_stream;\n\n\t\tif (of_property_read_bool(node, \"is-compress-dai\"))\n\t\t\tdai_drv->ops = &q6asm_dai_ops;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6asm_dai_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct q6asm_dai_data *pdata;\n\tint rc;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\trc = of_parse_phandle_with_fixed_args(node, \"iommus\", 1, 0, &args);\n\tif (rc < 0)\n\t\tpdata->sid = -1;\n\telse\n\t\tpdata->sid = args.args[0] & SID_MASK_DEFAULT;\n\n\tdev_set_drvdata(dev, pdata);\n\n\trc = of_q6asm_parse_dai_data(dev, pdata);\n\tif (rc)\n\t\treturn rc;\n\n\treturn devm_snd_soc_register_component(dev, &q6asm_fe_dai_component,\n\t\t\t\t\t       pdata->dais, pdata->num_dais);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6asm_dai_device_id[] = {\n\t{ .compatible = \"qcom,q6asm-dais\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6asm_dai_device_id);\n#endif\n\nstatic struct platform_driver q6asm_dai_platform_driver = {\n\t.driver = {\n\t\t.name = \"q6asm-dai\",\n\t\t.of_match_table = of_match_ptr(q6asm_dai_device_id),\n\t},\n\t.probe = q6asm_dai_probe,\n};\nmodule_platform_driver(q6asm_dai_platform_driver);\n\nMODULE_DESCRIPTION(\"Q6ASM dai driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}