{
  "module_name": "topology.c",
  "hash_id": "59c7c8e707d6a28e1d22f2090abe0f31999284e52be1018caa9c0a2c971ebe7c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/topology.c",
  "human_readable_source": "\n\n\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include <sound/control.h>\n#include <sound/asound.h>\n#include <linux/firmware.h>\n#include <sound/soc-topology.h>\n#include <sound/soc-dpcm.h>\n#include <uapi/sound/snd_ar_tokens.h>\n#include <linux/kernel.h>\n#include <linux/wait.h>\n#include \"q6apm.h\"\n#include \"audioreach.h\"\n\nstruct snd_ar_control {\n\tu32 graph_id;  \n\tu32 sgid;  \n\tu32 module_instance_id;  \n\tstruct snd_soc_dapm_widget *w;\n\tstruct list_head node;\n\tstruct snd_soc_component *scomp;\n};\n\nstatic struct audioreach_graph_info *audioreach_tplg_alloc_graph_info(struct q6apm *apm,\n\t\t\t\t\t\t\t\t      uint32_t graph_id,\n\t\t\t\t\t\t\t\t      bool *found)\n{\n\tstruct audioreach_graph_info *info;\n\tint ret;\n\n\tmutex_lock(&apm->lock);\n\tinfo = idr_find(&apm->graph_info_idr, graph_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (info) {\n\t\t*found = true;\n\t\treturn info;\n\t}\n\n\t*found = false;\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&info->sg_list);\n\n\tmutex_lock(&apm->lock);\n\tret = idr_alloc_u32(&apm->graph_info_idr, info, &graph_id, graph_id, GFP_KERNEL);\n\tmutex_unlock(&apm->lock);\n\n\tif (ret < 0) {\n\t\tdev_err(apm->dev, \"Failed to allocate Graph ID (%x)\\n\", graph_id);\n\t\tkfree(info);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tinfo->id = graph_id;\n\n\treturn info;\n}\n\nstatic void audioreach_tplg_add_sub_graph(struct audioreach_sub_graph *sg,\n\t\t\t\t\t  struct audioreach_graph_info *info)\n{\n\tlist_add_tail(&sg->node, &info->sg_list);\n\tsg->info = info;\n\tinfo->num_sub_graphs++;\n}\n\nstatic struct audioreach_sub_graph *audioreach_tplg_alloc_sub_graph(struct q6apm *apm,\n\t\t\t\t\t\t\t\t    uint32_t sub_graph_id,\n\t\t\t\t\t\t\t\t    bool *found)\n{\n\tstruct audioreach_sub_graph *sg;\n\tint ret;\n\n\tif (!sub_graph_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tmutex_lock(&apm->lock);\n\tsg = idr_find(&apm->sub_graphs_idr, sub_graph_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (sg) {\n\t\t*found = true;\n\t\treturn sg;\n\t}\n\n\t*found = false;\n\tsg = kzalloc(sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&sg->container_list);\n\n\tmutex_lock(&apm->lock);\n\tret = idr_alloc_u32(&apm->sub_graphs_idr, sg, &sub_graph_id, sub_graph_id, GFP_KERNEL);\n\tmutex_unlock(&apm->lock);\n\n\tif (ret < 0) {\n\t\tdev_err(apm->dev, \"Failed to allocate Sub-Graph Instance ID (%x)\\n\", sub_graph_id);\n\t\tkfree(sg);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tsg->sub_graph_id = sub_graph_id;\n\n\treturn sg;\n}\n\nstatic struct audioreach_container *audioreach_tplg_alloc_container(struct q6apm *apm,\n\t\t\t\t\t\t\t    struct audioreach_sub_graph *sg,\n\t\t\t\t\t\t\t    uint32_t container_id,\n\t\t\t\t\t\t\t    bool *found)\n{\n\tstruct audioreach_container *cont;\n\tint ret;\n\n\tif (!container_id)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmutex_lock(&apm->lock);\n\tcont = idr_find(&apm->containers_idr, container_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (cont) {\n\t\t*found = true;\n\t\treturn cont;\n\t}\n\t*found = false;\n\n\tcont = kzalloc(sizeof(*cont), GFP_KERNEL);\n\tif (!cont)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&cont->modules_list);\n\n\tmutex_lock(&apm->lock);\n\tret = idr_alloc_u32(&apm->containers_idr, cont, &container_id, container_id, GFP_KERNEL);\n\tmutex_unlock(&apm->lock);\n\n\tif (ret < 0) {\n\t\tdev_err(apm->dev, \"Failed to allocate Container Instance ID (%x)\\n\", container_id);\n\t\tkfree(cont);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tcont->container_id = container_id;\n\tcont->sub_graph = sg;\n\t \n\tlist_add_tail(&cont->node, &sg->container_list);\n\tsg->num_containers++;\n\n\treturn cont;\n}\n\nstatic struct audioreach_module *audioreach_tplg_alloc_module(struct q6apm *apm,\n\t\t\t\t\t\t\t      struct audioreach_container *cont,\n\t\t\t\t\t\t\t      struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\t\t      uint32_t module_id, bool *found)\n{\n\tstruct audioreach_module *mod;\n\tint ret;\n\n\tmutex_lock(&apm->lock);\n\tmod = idr_find(&apm->modules_idr, module_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (mod) {\n\t\t*found = true;\n\t\treturn mod;\n\t}\n\t*found = false;\n\tmod = kzalloc(sizeof(*mod), GFP_KERNEL);\n\tif (!mod)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&apm->lock);\n\tif (!module_id) {  \n\t\tret = idr_alloc_cyclic(&apm->modules_idr, mod,\n\t\t\t\t       AR_MODULE_DYNAMIC_INSTANCE_ID_START,\n\t\t\t\t       AR_MODULE_DYNAMIC_INSTANCE_ID_END, GFP_KERNEL);\n\t} else {\n\t\tret = idr_alloc_u32(&apm->modules_idr, mod, &module_id, module_id, GFP_KERNEL);\n\t}\n\tmutex_unlock(&apm->lock);\n\n\tif (ret < 0) {\n\t\tdev_err(apm->dev, \"Failed to allocate Module Instance ID (%x)\\n\", module_id);\n\t\tkfree(mod);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmod->instance_id = module_id;\n\t \n\tlist_add_tail(&mod->node, &cont->modules_list);\n\tmod->container = cont;\n\tmod->widget = w;\n\tcont->num_modules++;\n\n\treturn mod;\n}\n\nstatic struct snd_soc_tplg_vendor_array *audioreach_get_sg_array(\n\t\t\t\t\t\t\tstruct snd_soc_tplg_private *private)\n{\n\tstruct snd_soc_tplg_vendor_array *sg_array = NULL;\n\tbool found = false;\n\tint sz;\n\n\tfor (sz = 0; !found && (sz < le32_to_cpu(private->size)); ) {\n\t\tstruct snd_soc_tplg_vendor_value_elem *sg_elem;\n\t\tint tkn_count = 0;\n\n\t\tsg_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);\n\t\tsg_elem = sg_array->value;\n\t\tsz = sz + le32_to_cpu(sg_array->size);\n\t\twhile (!found && tkn_count <= (le32_to_cpu(sg_array->num_elems) - 1)) {\n\t\t\tswitch (le32_to_cpu(sg_elem->token)) {\n\t\t\tcase AR_TKN_U32_SUB_GRAPH_INSTANCE_ID:\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttkn_count++;\n\t\t\tsg_elem++;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn sg_array;\n\n\treturn NULL;\n}\n\nstatic struct snd_soc_tplg_vendor_array *audioreach_get_cont_array(\n\t\t\t\t\t\t\tstruct snd_soc_tplg_private *private)\n{\n\tstruct snd_soc_tplg_vendor_array *cont_array = NULL;\n\tbool found = false;\n\tint sz;\n\n\tfor (sz = 0; !found && (sz < le32_to_cpu(private->size)); ) {\n\t\tstruct snd_soc_tplg_vendor_value_elem *cont_elem;\n\t\tint tkn_count = 0;\n\n\t\tcont_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);\n\t\tcont_elem = cont_array->value;\n\t\tsz = sz + le32_to_cpu(cont_array->size);\n\t\twhile (!found && tkn_count <= (le32_to_cpu(cont_array->num_elems) - 1)) {\n\t\t\tswitch (le32_to_cpu(cont_elem->token)) {\n\t\t\tcase AR_TKN_U32_CONTAINER_INSTANCE_ID:\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttkn_count++;\n\t\t\tcont_elem++;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn cont_array;\n\n\treturn NULL;\n}\n\nstatic struct snd_soc_tplg_vendor_array *audioreach_get_module_array(\n\t\t\t\t\t\t\t     struct snd_soc_tplg_private *private)\n{\n\tstruct snd_soc_tplg_vendor_array *mod_array = NULL;\n\tbool found = false;\n\tint sz = 0;\n\n\tfor (sz = 0; !found && (sz < le32_to_cpu(private->size)); ) {\n\t\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\t\tint tkn_count = 0;\n\n\t\tmod_array = (struct snd_soc_tplg_vendor_array *)((u8 *)private->array + sz);\n\t\tmod_elem = mod_array->value;\n\t\tsz = sz + le32_to_cpu(mod_array->size);\n\t\twhile (!found && tkn_count <= (le32_to_cpu(mod_array->num_elems) - 1)) {\n\t\t\tswitch (le32_to_cpu(mod_elem->token)) {\n\t\t\tcase AR_TKN_U32_MODULE_INSTANCE_ID:\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttkn_count++;\n\t\t\tmod_elem++;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn mod_array;\n\n\treturn NULL;\n}\n\nstatic struct audioreach_sub_graph *audioreach_parse_sg_tokens(struct q6apm *apm,\n\t\t\t\t\t\t       struct snd_soc_tplg_private *private)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *sg_elem;\n\tstruct snd_soc_tplg_vendor_array *sg_array;\n\tstruct audioreach_graph_info *info = NULL;\n\tint graph_id, sub_graph_id, tkn_count = 0;\n\tstruct audioreach_sub_graph *sg;\n\tbool found;\n\n\tsg_array = audioreach_get_sg_array(private);\n\tsg_elem = sg_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(sg_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(sg_elem->token)) {\n\t\tcase AR_TKN_U32_SUB_GRAPH_INSTANCE_ID:\n\t\t\tsub_graph_id = le32_to_cpu(sg_elem->value);\n\t\t\tsg = audioreach_tplg_alloc_sub_graph(apm, sub_graph_id, &found);\n\t\t\tif (IS_ERR(sg)) {\n\t\t\t\treturn sg;\n\t\t\t} else if (found) {\n\t\t\t\t \n\t\t\t\treturn sg;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AR_TKN_DAI_INDEX:\n\t\t\t \n\t\t\tgraph_id = le32_to_cpu(sg_elem->value);\n\t\t\tinfo = audioreach_tplg_alloc_graph_info(apm, graph_id, &found);\n\t\t\tif (IS_ERR(info))\n\t\t\t\treturn ERR_CAST(info);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_SUB_GRAPH_PERF_MODE:\n\t\t\tsg->perf_mode = le32_to_cpu(sg_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_SUB_GRAPH_DIRECTION:\n\t\t\tsg->direction = le32_to_cpu(sg_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_SUB_GRAPH_SCENARIO_ID:\n\t\t\tsg->scenario_id = le32_to_cpu(sg_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(apm->dev, \"Not a valid token %d for graph\\n\", sg_elem->token);\n\t\t\tbreak;\n\n\t\t}\n\t\ttkn_count++;\n\t\tsg_elem++;\n\t}\n\n\t \n\tif (info)\n\t\taudioreach_tplg_add_sub_graph(sg, info);\n\n\treturn sg;\n}\n\nstatic struct audioreach_container *audioreach_parse_cont_tokens(struct q6apm *apm,\n\t\t\t\t\t\t\t struct audioreach_sub_graph *sg,\n\t\t\t\t\t\t\t struct snd_soc_tplg_private *private)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *cont_elem;\n\tstruct snd_soc_tplg_vendor_array *cont_array;\n\tstruct audioreach_container *cont;\n\tint container_id, tkn_count = 0;\n\tbool found = false;\n\n\tcont_array = audioreach_get_cont_array(private);\n\tcont_elem = cont_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(cont_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(cont_elem->token)) {\n\t\tcase AR_TKN_U32_CONTAINER_INSTANCE_ID:\n\t\t\tcontainer_id = le32_to_cpu(cont_elem->value);\n\t\t\tcont = audioreach_tplg_alloc_container(apm, sg, container_id, &found);\n\t\t\tif (IS_ERR(cont) || found) \n\t\t\t\treturn cont;\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_CONTAINER_CAPABILITY_ID:\n\t\t\tcont->capability_id = le32_to_cpu(cont_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_CONTAINER_STACK_SIZE:\n\t\t\tcont->stack_size = le32_to_cpu(cont_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_CONTAINER_GRAPH_POS:\n\t\t\tcont->graph_pos = le32_to_cpu(cont_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_CONTAINER_PROC_DOMAIN:\n\t\t\tcont->proc_domain = le32_to_cpu(cont_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(apm->dev, \"Not a valid token %d for graph\\n\", cont_elem->token);\n\t\t\tbreak;\n\n\t\t}\n\t\ttkn_count++;\n\t\tcont_elem++;\n\t}\n\n\treturn cont;\n}\n\nstatic struct audioreach_module *audioreach_parse_common_tokens(struct q6apm *apm,\n\t\t\t\t\t\t\tstruct audioreach_container *cont,\n\t\t\t\t\t\t\tstruct snd_soc_tplg_private *private,\n\t\t\t\t\t\t\tstruct snd_soc_dapm_widget *w)\n{\n\tuint32_t max_ip_port = 0, max_op_port = 0, in_port = 0, out_port = 0;\n\tuint32_t src_mod_op_port_id[AR_MAX_MOD_LINKS] = { 0, };\n\tuint32_t dst_mod_inst_id[AR_MAX_MOD_LINKS] = { 0, };\n\tuint32_t dst_mod_ip_port_id[AR_MAX_MOD_LINKS] = { 0, };\n\tuint32_t src_mod_inst_id = 0;\n\n\tint module_id = 0, instance_id = 0, tkn_count = 0;\n\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\tstruct snd_soc_tplg_vendor_array *mod_array;\n\tstruct audioreach_module *mod = NULL;\n\tuint32_t token;\n\tbool found;\n\tint max_tokens;\n\n\tmod_array = audioreach_get_module_array(private);\n\tmod_elem = mod_array->value;\n\tmax_tokens = le32_to_cpu(mod_array->num_elems);\n\twhile (tkn_count <= (max_tokens - 1)) {\n\t\ttoken = le32_to_cpu(mod_elem->token);\n\t\tswitch (token) {\n\t\t \n\t\tcase AR_TKN_U32_MODULE_ID:\n\t\t\tmodule_id = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_INSTANCE_ID:\n\t\t\tinstance_id = le32_to_cpu(mod_elem->value);\n\t\t\tmod = audioreach_tplg_alloc_module(apm, cont, w,\n\t\t\t\t\t\t\t   instance_id, &found);\n\t\t\tif (IS_ERR(mod)) {\n\t\t\t\treturn mod;\n\t\t\t} else if (found) {\n\t\t\t\tdev_err(apm->dev, \"Duplicate Module Instance ID 0x%08x found\\n\",\n\t\t\t\t\tinstance_id);\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_MAX_IP_PORTS:\n\t\t\tmax_ip_port = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_MAX_OP_PORTS:\n\t\t\tmax_op_port = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_IN_PORTS:\n\t\t\tin_port = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_OUT_PORTS:\n\t\t\tout_port = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_INSTANCE_ID:\n\t\t\tsrc_mod_inst_id = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID:\n\t\t\tsrc_mod_op_port_id[0] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID1:\n\t\t\tsrc_mod_op_port_id[1] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID2:\n\t\t\tsrc_mod_op_port_id[2] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID3:\n\t\t\tsrc_mod_op_port_id[3] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID4:\n\t\t\tsrc_mod_op_port_id[4] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID5:\n\t\t\tsrc_mod_op_port_id[5] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID6:\n\t\t\tsrc_mod_op_port_id[6] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SRC_OP_PORT_ID7:\n\t\t\tsrc_mod_op_port_id[7] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID:\n\t\t\tdst_mod_inst_id[0] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID1:\n\t\t\tdst_mod_inst_id[1] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID2:\n\t\t\tdst_mod_inst_id[2] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID3:\n\t\t\tdst_mod_inst_id[3] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID4:\n\t\t\tdst_mod_inst_id[4] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID5:\n\t\t\tdst_mod_inst_id[5] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID6:\n\t\t\tdst_mod_inst_id[6] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_INSTANCE_ID7:\n\t\t\tdst_mod_inst_id[7] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID:\n\t\t\tdst_mod_ip_port_id[0] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID1:\n\t\t\tdst_mod_ip_port_id[1] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID2:\n\t\t\tdst_mod_ip_port_id[2] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID3:\n\t\t\tdst_mod_ip_port_id[3] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID4:\n\t\t\tdst_mod_ip_port_id[4] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID5:\n\t\t\tdst_mod_ip_port_id[5] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID6:\n\t\t\tdst_mod_ip_port_id[6] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_DST_IN_PORT_ID7:\n\t\t\tdst_mod_ip_port_id[7] = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\n\t\t}\n\t\ttkn_count++;\n\t\tmod_elem++;\n\t}\n\n\tif (mod) {\n\t\tint pn, id = 0;\n\t\tmod->module_id = module_id;\n\t\tmod->max_ip_port = max_ip_port;\n\t\tmod->max_op_port = max_op_port;\n\t\tmod->in_port = in_port;\n\t\tmod->out_port = out_port;\n\t\tmod->src_mod_inst_id = src_mod_inst_id;\n\t\tfor (pn = 0; pn < mod->max_op_port; pn++) {\n\t\t\tif (src_mod_op_port_id[pn] && dst_mod_inst_id[pn] &&\n\t\t\t    dst_mod_ip_port_id[pn]) {\n\t\t\t\tmod->src_mod_op_port_id[id] = src_mod_op_port_id[pn];\n\t\t\t\tmod->dst_mod_inst_id[id] = dst_mod_inst_id[pn];\n\t\t\t\tmod->dst_mod_ip_port_id[id] = dst_mod_ip_port_id[pn];\n\t\t\t\tid++;\n\t\t\t\tmod->num_connections = id;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mod;\n}\n\nstatic int audioreach_widget_load_module_common(struct snd_soc_component *component,\n\t\t\t\t\t\tint index, struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\tstruct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tstruct q6apm *apm = dev_get_drvdata(component->dev);\n\tstruct audioreach_container *cont;\n\tstruct audioreach_sub_graph *sg;\n\tstruct audioreach_module *mod;\n\tstruct snd_soc_dobj *dobj;\n\n\tsg = audioreach_parse_sg_tokens(apm, &tplg_w->priv);\n\tif (IS_ERR(sg))\n\t\treturn PTR_ERR(sg);\n\n\tcont = audioreach_parse_cont_tokens(apm, sg, &tplg_w->priv);\n\tif (IS_ERR(cont))\n\t\treturn PTR_ERR(cont);\n\n\tmod = audioreach_parse_common_tokens(apm, cont, &tplg_w->priv, w);\n\tif (IS_ERR(mod))\n\t\treturn PTR_ERR(mod);\n\n\tdobj = &w->dobj;\n\tdobj->private = mod;\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_load_enc_dec_cnv(struct snd_soc_component *component,\n\t\t\t\t\t      int index, struct snd_soc_dapm_widget *w,\n\t\t\t\t\t      struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\tstruct snd_soc_tplg_vendor_array *mod_array;\n\tstruct audioreach_module *mod;\n\tstruct snd_soc_dobj *dobj;\n\tint tkn_count = 0;\n\tint ret;\n\n\tret = audioreach_widget_load_module_common(component, index, w, tplg_w);\n\tif (ret)\n\t\treturn ret;\n\n\tdobj = &w->dobj;\n\tmod = dobj->private;\n\tmod_array = audioreach_get_module_array(&tplg_w->priv);\n\tmod_elem = mod_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(mod_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(mod_elem->token)) {\n\t\tcase AR_TKN_U32_MODULE_FMT_INTERLEAVE:\n\t\t\tmod->interleave_type = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_FMT_SAMPLE_RATE:\n\t\t\tmod->rate = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_FMT_BIT_DEPTH:\n\t\t\tmod->bit_depth = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttkn_count++;\n\t\tmod_elem++;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_log_module_load(struct audioreach_module *mod,\n\t\t\t\t\t     struct snd_soc_tplg_vendor_array *mod_array)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\tint tkn_count = 0;\n\n\tmod_elem = mod_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(mod_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(mod_elem->token)) {\n\n\t\tcase AR_TKN_U32_MODULE_LOG_CODE:\n\t\t\tmod->log_code = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_LOG_TAP_POINT_ID:\n\t\t\tmod->log_tap_point_id = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_LOG_MODE:\n\t\t\tmod->log_mode = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttkn_count++;\n\t\tmod_elem++;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_dma_module_load(struct audioreach_module *mod,\n\t\t\t\t\t     struct snd_soc_tplg_vendor_array *mod_array)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\tint tkn_count = 0;\n\n\tmod_elem = mod_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(mod_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(mod_elem->token)) {\n\t\tcase AR_TKN_U32_MODULE_HW_IF_IDX:\n\t\t\tmod->hw_interface_idx = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_FMT_DATA:\n\t\t\tmod->data_format = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_HW_IF_TYPE:\n\t\t\tmod->hw_interface_type = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttkn_count++;\n\t\tmod_elem++;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_i2s_module_load(struct audioreach_module *mod,\n\t\t\t\t\t     struct snd_soc_tplg_vendor_array *mod_array)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *mod_elem;\n\tint tkn_count = 0;\n\n\tmod_elem = mod_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(mod_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(mod_elem->token)) {\n\t\tcase AR_TKN_U32_MODULE_HW_IF_IDX:\n\t\t\tmod->hw_interface_idx = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_FMT_DATA:\n\t\t\tmod->data_format = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_HW_IF_TYPE:\n\t\t\tmod->hw_interface_type = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_SD_LINE_IDX:\n\t\t\tmod->sd_line_idx = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_U32_MODULE_WS_SRC:\n\t\t\tmod->ws_src = le32_to_cpu(mod_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ttkn_count++;\n\t\tmod_elem++;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_load_buffer(struct snd_soc_component *component,\n\t\t\t\t\t int index, struct snd_soc_dapm_widget *w,\n\t\t\t\t\t struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tstruct snd_soc_tplg_vendor_array *mod_array;\n\tstruct audioreach_module *mod;\n\tstruct snd_soc_dobj *dobj;\n\tint ret;\n\n\tret = audioreach_widget_load_module_common(component, index, w, tplg_w);\n\tif (ret)\n\t\treturn ret;\n\n\tdobj = &w->dobj;\n\tmod = dobj->private;\n\n\tmod_array = audioreach_get_module_array(&tplg_w->priv);\n\n\tswitch (mod->module_id) {\n\tcase MODULE_ID_CODEC_DMA_SINK:\n\tcase MODULE_ID_CODEC_DMA_SOURCE:\n\t\taudioreach_widget_dma_module_load(mod, mod_array);\n\t\tbreak;\n\tcase MODULE_ID_DATA_LOGGING:\n\t\taudioreach_widget_log_module_load(mod, mod_array);\n\t\tbreak;\n\tcase MODULE_ID_I2S_SINK:\n\tcase MODULE_ID_I2S_SOURCE:\n\t\taudioreach_widget_i2s_module_load(mod, mod_array);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_load_mixer(struct snd_soc_component *component,\n\t\t\t\t\tint index, struct snd_soc_dapm_widget *w,\n\t\t\t\t\tstruct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *w_elem;\n\tstruct snd_soc_tplg_vendor_array *w_array;\n\tstruct snd_ar_control *scontrol;\n\tstruct q6apm *data = dev_get_drvdata(component->dev);\n\tstruct snd_soc_dobj *dobj;\n\tint tkn_count = 0;\n\n\tw_array = &tplg_w->priv.array[0];\n\n\tscontrol = kzalloc(sizeof(*scontrol), GFP_KERNEL);\n\tif (!scontrol)\n\t\treturn -ENOMEM;\n\n\tscontrol->scomp = component;\n\tdobj = &w->dobj;\n\tdobj->private = scontrol;\n\n\tw_elem = w_array->value;\n\twhile (tkn_count <= (le32_to_cpu(w_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(w_elem->token)) {\n\t\tcase AR_TKN_U32_SUB_GRAPH_INSTANCE_ID:\n\t\t\tscontrol->sgid = le32_to_cpu(w_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_DAI_INDEX:\n\t\t\tscontrol->graph_id = le32_to_cpu(w_elem->value);\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\tbreak;\n\t\t}\n\t\ttkn_count++;\n\t\tw_elem++;\n\t}\n\n\tscontrol->w = w;\n\tlist_add_tail(&scontrol->node, &data->widget_list);\n\n\treturn 0;\n}\n\nstatic int audioreach_pga_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(dapm);\n\tstruct audioreach_module *mod = w->dobj.private;\n\tstruct q6apm *apm = dev_get_drvdata(c->dev);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\taudioreach_gain_set_vol_ctrl(apm, mod, mod->gain);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_tplg_widget_events audioreach_widget_ops[] = {\n\t{ AR_PGA_DAPM_EVENT, audioreach_pga_event },\n};\n\nstatic int audioreach_widget_load_pga(struct snd_soc_component *component,\n\t\t\t\t      int index, struct snd_soc_dapm_widget *w,\n\t\t\t\t      struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tstruct audioreach_module *mod;\n\tstruct snd_soc_dobj *dobj;\n\tint ret;\n\n\tret = audioreach_widget_load_module_common(component, index, w, tplg_w);\n\tif (ret)\n\t\treturn ret;\n\n\tdobj = &w->dobj;\n\tmod = dobj->private;\n\tmod->gain = VOL_CTRL_DEFAULT_GAIN;\n\n\tret = snd_soc_tplg_widget_bind_event(w, audioreach_widget_ops,\n\t\t\t\t\t     ARRAY_SIZE(audioreach_widget_ops),\n\t\t\t\t\t     le16_to_cpu(tplg_w->event_type));\n\tif (ret) {\n\t\tdev_err(component->dev, \"matching event handlers NOT found for %d\\n\",\n\t\t\tle16_to_cpu(tplg_w->event_type));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_ready(struct snd_soc_component *component,\n\t\t\t\t   int index, struct snd_soc_dapm_widget *w,\n\t\t\t\t   struct snd_soc_tplg_dapm_widget *tplg_w)\n{\n\tswitch (w->id) {\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\t\taudioreach_widget_load_buffer(component, index, w, tplg_w);\n\t\tbreak;\n\tcase snd_soc_dapm_decoder:\n\tcase snd_soc_dapm_encoder:\n\tcase snd_soc_dapm_src:\n\t\taudioreach_widget_load_enc_dec_cnv(component, index, w, tplg_w);\n\t\tbreak;\n\tcase snd_soc_dapm_buffer:\n\t\taudioreach_widget_load_buffer(component, index, w, tplg_w);\n\t\tbreak;\n\tcase snd_soc_dapm_mixer:\n\t\treturn audioreach_widget_load_mixer(component, index, w, tplg_w);\n\tcase snd_soc_dapm_pga:\n\t\treturn audioreach_widget_load_pga(component, index, w, tplg_w);\n\tcase snd_soc_dapm_dai_link:\n\tcase snd_soc_dapm_scheduler:\n\tcase snd_soc_dapm_out_drv:\n\tdefault:\n\t\tdev_err(component->dev, \"Widget type (0x%x) not yet supported\\n\", w->id);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_widget_unload(struct snd_soc_component *scomp,\n\t\t\t\t    struct snd_soc_dobj *dobj)\n{\n\tstruct snd_soc_dapm_widget *w = container_of(dobj, struct snd_soc_dapm_widget, dobj);\n\tstruct q6apm *apm = dev_get_drvdata(scomp->dev);\n\tstruct audioreach_container *cont;\n\tstruct audioreach_module *mod;\n\n\tmod = dobj->private;\n\tcont = mod->container;\n\n\tif (w->id == snd_soc_dapm_mixer) {\n\t\t \n\t\tstruct snd_ar_control *scontrol = dobj->private;\n\n\t\tlist_del(&scontrol->node);\n\t\tkfree(scontrol);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apm->lock);\n\tidr_remove(&apm->modules_idr, mod->instance_id);\n\tcont->num_modules--;\n\n\tlist_del(&mod->node);\n\tkfree(mod);\n\t \n\tif (list_empty(&cont->modules_list)) {  \n\t\tstruct audioreach_sub_graph *sg = cont->sub_graph;\n\n\t\tidr_remove(&apm->containers_idr, cont->container_id);\n\t\tlist_del(&cont->node);\n\t\tsg->num_containers--;\n\t\tkfree(cont);\n\t\t \n\t\tif (list_empty(&sg->container_list)) {\n\t\t\tstruct audioreach_graph_info *info = sg->info;\n\n\t\t\tidr_remove(&apm->sub_graphs_idr, sg->sub_graph_id);\n\t\t\tlist_del(&sg->node);\n\t\t\tinfo->num_sub_graphs--;\n\t\t\tkfree(sg);\n\t\t\t \n\t\t\tif (list_empty(&info->sg_list)) {\n\t\t\t\tidr_remove(&apm->graph_info_idr, info->id);\n\t\t\t\tkfree(info);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&apm->lock);\n\n\treturn 0;\n}\n\nstatic struct snd_ar_control *audioreach_find_widget(struct snd_soc_component *comp,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct q6apm *apm = dev_get_drvdata(comp->dev);\n\tstruct snd_ar_control *control;\n\n\tlist_for_each_entry(control, &apm->widget_list, node) {\n\t\tif (control->w && !strcmp(name, control->w->name))\n\t\t\treturn control;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct audioreach_module *audioreach_find_module(struct snd_soc_component *comp,\n\t\t\t\t\t\t\tconst char *name)\n{\n\tstruct q6apm *apm = dev_get_drvdata(comp->dev);\n\tstruct audioreach_module *module;\n\tint id;\n\n\tidr_for_each_entry(&apm->modules_idr, module, id) {\n\t\tif (!strcmp(name, module->widget->name))\n\t\t\treturn module;\n\t}\n\n\treturn NULL;\n}\n\nstatic int audioreach_route_load(struct snd_soc_component *scomp, int index,\n\t\t\t\t struct snd_soc_dapm_route *route)\n{\n\tstruct audioreach_module *src_module, *sink_module;\n\tstruct snd_ar_control *control;\n\tstruct snd_soc_dapm_widget *w;\n\tint i;\n\n\t \n\tsrc_module = audioreach_find_module(scomp, route->source);\n\tsink_module = audioreach_find_module(scomp, route->sink);\n\n\tif (sink_module && !src_module) {\n\t\tcontrol = audioreach_find_widget(scomp, route->source);\n\t\tif (control)\n\t\t\tcontrol->module_instance_id = sink_module->instance_id;\n\n\t} else if (!sink_module && src_module && route->control) {\n\t\t \n\t\tcontrol = audioreach_find_widget(scomp, route->sink);\n\t\tif (!control || !control->w)\n\t\t\treturn 0;\n\n\t\tw = control->w;\n\n\t\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\t\tif (!strcmp(route->control, w->kcontrol_news[i].name)) {\n\t\t\t\tstruct soc_mixer_control *sm;\n\t\t\t\tstruct snd_soc_dobj *dobj;\n\t\t\t\tstruct snd_ar_control *scontrol;\n\n\t\t\t\tsm = (struct soc_mixer_control *)w->kcontrol_news[i].private_value;\n\t\t\t\tdobj = &sm->dobj;\n\t\t\t\tscontrol = dobj->private;\n\t\t\t\tscontrol->module_instance_id = src_module->instance_id;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_route_unload(struct snd_soc_component *scomp,\n\t\t\t\t   struct snd_soc_dobj *dobj)\n{\n\treturn 0;\n}\n\nstatic int audioreach_tplg_complete(struct snd_soc_component *component)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int audioreach_link_load(struct snd_soc_component *component, int index,\n\t\t\t\tstruct snd_soc_dai_link *link,\n\t\t\t\tstruct snd_soc_tplg_link_config *cfg)\n{\n\tlink->nonatomic = true;\n\tlink->dynamic = true;\n\tlink->platforms->name = NULL;\n\tlink->platforms->of_node = of_get_compatible_child(component->dev->of_node,\n\t\t\t\t\t\t\t   \"qcom,q6apm-dais\");\n\treturn 0;\n}\n\nstatic void audioreach_connect_sub_graphs(struct q6apm *apm,\n\t\t\t\t\t  struct snd_ar_control *m1,\n\t\t\t\t\t  struct snd_ar_control *m2,\n\t\t\t\t\t  bool connect)\n{\n\tstruct audioreach_graph_info *info;\n\n\tmutex_lock(&apm->lock);\n\tinfo = idr_find(&apm->graph_info_idr, m2->graph_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (connect) {\n\t\tinfo->src_mod_inst_id = m1->module_instance_id;\n\t\tinfo->src_mod_op_port_id = 1;\n\t\tinfo->dst_mod_inst_id = m2->module_instance_id;\n\t\tinfo->dst_mod_ip_port_id = 2;\n\n\t} else {\n\t\tinfo->src_mod_inst_id = 0;\n\t\tinfo->src_mod_op_port_id = 0;\n\t\tinfo->dst_mod_inst_id = 0;\n\t\tinfo->dst_mod_ip_port_id = 0;\n\t}\n}\n\nstatic bool audioreach_is_vmixer_connected(struct q6apm *apm,\n\t\t\t\t\t   struct snd_ar_control *m1,\n\t\t\t\t\t   struct snd_ar_control *m2)\n{\n\tstruct audioreach_graph_info *info;\n\n\tmutex_lock(&apm->lock);\n\tinfo = idr_find(&apm->graph_info_idr, m2->graph_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (info->dst_mod_inst_id == m2->module_instance_id &&\n\t    info->src_mod_inst_id == m1->module_instance_id)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int audioreach_get_audio_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_dapm_widget *dw = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(dapm);\n\tstruct snd_ar_control *dapm_scontrol = dw->dobj.private;\n\tstruct snd_ar_control *scontrol = mc->dobj.private;\n\tstruct q6apm *data = dev_get_drvdata(c->dev);\n\tbool connected;\n\n\tconnected = audioreach_is_vmixer_connected(data, scontrol, dapm_scontrol);\n\tif (connected)\n\t\tucontrol->value.integer.value[0] = 1;\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\n\treturn 0;\n}\n\nstatic int audioreach_put_audio_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_dapm_widget *dw = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(dapm);\n\tstruct snd_ar_control *dapm_scontrol = dw->dobj.private;\n\tstruct snd_ar_control *scontrol = mc->dobj.private;\n\tstruct q6apm *data = dev_get_drvdata(c->dev);\n\n\tif (ucontrol->value.integer.value[0]) {\n\t\taudioreach_connect_sub_graphs(data, scontrol, dapm_scontrol, true);\n\t\tsnd_soc_dapm_mixer_update_power(dapm, kcontrol, 1, NULL);\n\t} else {\n\t\taudioreach_connect_sub_graphs(data, scontrol, dapm_scontrol, false);\n\t\tsnd_soc_dapm_mixer_update_power(dapm, kcontrol, 0, NULL);\n\t}\n\treturn 0;\n}\n\nstatic int audioreach_get_vol_ctrl_audio_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *dw = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct audioreach_module *mod = dw->dobj.private;\n\n\tucontrol->value.integer.value[0] = mod->gain;\n\n\treturn 0;\n}\n\nstatic int audioreach_put_vol_ctrl_audio_mixer(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *dw = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct audioreach_module *mod = dw->dobj.private;\n\n\tmod->gain = ucontrol->value.integer.value[0];\n\n\treturn 1;\n}\n\nstatic int audioreach_control_load_mix(struct snd_soc_component *scomp,\n\t\t\t\t       struct snd_ar_control *scontrol,\n\t\t\t\t       struct snd_kcontrol_new *kc,\n\t\t\t\t       struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *c_elem;\n\tstruct snd_soc_tplg_vendor_array *c_array;\n\tstruct snd_soc_tplg_mixer_control *mc;\n\tint tkn_count = 0;\n\n\tmc = container_of(hdr, struct snd_soc_tplg_mixer_control, hdr);\n\tc_array = (struct snd_soc_tplg_vendor_array *)mc->priv.data;\n\n\tc_elem = c_array->value;\n\n\twhile (tkn_count <= (le32_to_cpu(c_array->num_elems) - 1)) {\n\t\tswitch (le32_to_cpu(c_elem->token)) {\n\t\tcase AR_TKN_U32_SUB_GRAPH_INSTANCE_ID:\n\t\t\tscontrol->sgid = le32_to_cpu(c_elem->value);\n\t\t\tbreak;\n\t\tcase AR_TKN_DAI_INDEX:\n\t\t\tscontrol->graph_id = le32_to_cpu(c_elem->value);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tc_elem++;\n\t\ttkn_count++;\n\t}\n\n\treturn 0;\n}\n\nstatic int audioreach_control_load(struct snd_soc_component *scomp, int index,\n\t\t\t\t   struct snd_kcontrol_new *kc,\n\t\t\t\t   struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_ar_control *scontrol;\n\tstruct soc_mixer_control *sm;\n\tstruct snd_soc_dobj *dobj;\n\tint ret = 0;\n\n\tscontrol = kzalloc(sizeof(*scontrol), GFP_KERNEL);\n\tif (!scontrol)\n\t\treturn -ENOMEM;\n\n\tscontrol->scomp = scomp;\n\n\tswitch (le32_to_cpu(hdr->ops.get)) {\n\tcase SND_SOC_AR_TPLG_FE_BE_GRAPH_CTL_MIX:\n\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\tdobj = &sm->dobj;\n\t\tret = audioreach_control_load_mix(scomp, scontrol, kc, hdr);\n\t\tbreak;\n\tcase SND_SOC_AR_TPLG_VOL_CTL:\n\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\tdobj = &sm->dobj;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(scomp->dev, \"control type not supported %d:%d:%d\\n\",\n\t\t\t hdr->ops.get, hdr->ops.put, hdr->ops.info);\n\t\tkfree(scontrol);\n\t\treturn -EINVAL;\n\t}\n\n\tdobj->private = scontrol;\n\treturn ret;\n}\n\nstatic int audioreach_control_unload(struct snd_soc_component *scomp,\n\t\t\t\t     struct snd_soc_dobj *dobj)\n{\n\tstruct snd_ar_control *scontrol = dobj->private;\n\n\tkfree(scontrol);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_tplg_kcontrol_ops audioreach_io_ops[] = {\n\t{SND_SOC_AR_TPLG_FE_BE_GRAPH_CTL_MIX, audioreach_get_audio_mixer,\n\t\taudioreach_put_audio_mixer, snd_soc_info_volsw},\n\t{SND_SOC_AR_TPLG_VOL_CTL, audioreach_get_vol_ctrl_audio_mixer,\n\t\taudioreach_put_vol_ctrl_audio_mixer, snd_soc_info_volsw},\n};\n\nstatic struct snd_soc_tplg_ops audioreach_tplg_ops  = {\n\t.io_ops = audioreach_io_ops,\n\t.io_ops_count = ARRAY_SIZE(audioreach_io_ops),\n\n\t.control_load\t= audioreach_control_load,\n\t.control_unload\t= audioreach_control_unload,\n\n\t.widget_ready = audioreach_widget_ready,\n\t.widget_unload = audioreach_widget_unload,\n\n\t.complete = audioreach_tplg_complete,\n\t.link_load = audioreach_link_load,\n\n\t.dapm_route_load\t= audioreach_route_load,\n\t.dapm_route_unload\t= audioreach_route_unload,\n};\n\nint audioreach_tplg_init(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = component->card;\n\tstruct device *dev = component->dev;\n\tconst struct firmware *fw;\n\tchar *tplg_fw_name;\n\tint ret;\n\n\t \n\ttplg_fw_name = kasprintf(GFP_KERNEL, \"qcom/%s/%s-tplg.bin\", card->driver_name, card->name);\n\tif (!tplg_fw_name)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, tplg_fw_name, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"tplg firmware loading %s failed %d \\n\", tplg_fw_name, ret);\n\t\tgoto err;\n\t}\n\n\tret = snd_soc_tplg_component_load(component, &audioreach_tplg_ops, fw);\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"tplg component load failed: %d\\n\", ret);\n\t}\n\n\trelease_firmware(fw);\nerr:\n\tkfree(tplg_fw_name);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(audioreach_tplg_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}