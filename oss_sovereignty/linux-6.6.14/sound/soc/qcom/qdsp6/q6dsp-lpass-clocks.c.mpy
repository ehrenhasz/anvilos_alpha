{
  "module_name": "q6dsp-lpass-clocks.c",
  "hash_id": "604604378dcba15d36e61d613058bbb0670fba2d75eaff5bd7dfe05cadd5df64",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6dsp-lpass-clocks.c",
  "human_readable_source": "\n\n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <dt-bindings/sound/qcom,q6dsp-lpass-ports.h>\n#include \"q6dsp-lpass-clocks.h\"\n\n#define Q6DSP_MAX_CLK_ID\t\t\t104\n#define Q6DSP_LPASS_CLK_ROOT_DEFAULT\t\t0\n\n\nstruct q6dsp_clk {\n\tstruct device *dev;\n\tint q6dsp_clk_id;\n\tint attributes;\n\tint rate;\n\tuint32_t handle;\n\tstruct clk_hw hw;\n};\n\n#define to_q6dsp_clk(_hw) container_of(_hw, struct q6dsp_clk, hw)\n\nstruct q6dsp_cc {\n\tstruct device *dev;\n\tstruct q6dsp_clk *clks[Q6DSP_MAX_CLK_ID];\n\tconst struct q6dsp_clk_desc *desc;\n};\n\nstatic int clk_q6dsp_prepare(struct clk_hw *hw)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\tstruct q6dsp_cc *cc = dev_get_drvdata(clk->dev);\n\n\treturn cc->desc->lpass_set_clk(clk->dev, clk->q6dsp_clk_id, clk->attributes,\n\t\t\t\t     Q6DSP_LPASS_CLK_ROOT_DEFAULT, clk->rate);\n}\n\nstatic void clk_q6dsp_unprepare(struct clk_hw *hw)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\tstruct q6dsp_cc *cc = dev_get_drvdata(clk->dev);\n\n\tcc->desc->lpass_set_clk(clk->dev, clk->q6dsp_clk_id, clk->attributes,\n\t\t\t      Q6DSP_LPASS_CLK_ROOT_DEFAULT, 0);\n}\n\nstatic int clk_q6dsp_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t      unsigned long parent_rate)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\n\tclk->rate = rate;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_q6dsp_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\n\treturn clk->rate;\n}\n\nstatic long clk_q6dsp_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t unsigned long *parent_rate)\n{\n\treturn rate;\n}\n\nstatic const struct clk_ops clk_q6dsp_ops = {\n\t.prepare\t= clk_q6dsp_prepare,\n\t.unprepare\t= clk_q6dsp_unprepare,\n\t.set_rate\t= clk_q6dsp_set_rate,\n\t.round_rate\t= clk_q6dsp_round_rate,\n\t.recalc_rate\t= clk_q6dsp_recalc_rate,\n};\n\nstatic int clk_vote_q6dsp_block(struct clk_hw *hw)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\tstruct q6dsp_cc *cc = dev_get_drvdata(clk->dev);\n\n\treturn cc->desc->lpass_vote_clk(clk->dev, clk->q6dsp_clk_id,\n\t\t\t\t  clk_hw_get_name(&clk->hw), &clk->handle);\n}\n\nstatic void clk_unvote_q6dsp_block(struct clk_hw *hw)\n{\n\tstruct q6dsp_clk *clk = to_q6dsp_clk(hw);\n\tstruct q6dsp_cc *cc = dev_get_drvdata(clk->dev);\n\n\tcc->desc->lpass_unvote_clk(clk->dev, clk->q6dsp_clk_id, clk->handle);\n}\n\nstatic const struct clk_ops clk_vote_q6dsp_ops = {\n\t.prepare\t= clk_vote_q6dsp_block,\n\t.unprepare\t= clk_unvote_q6dsp_block,\n};\n\n\nstatic struct clk_hw *q6dsp_of_clk_hw_get(struct of_phandle_args *clkspec,\n\t\t\t\t\t  void *data)\n{\n\tstruct q6dsp_cc *cc = data;\n\tunsigned int idx = clkspec->args[0];\n\tunsigned int attr = clkspec->args[1];\n\n\tif (idx >= Q6DSP_MAX_CLK_ID || attr > LPASS_CLK_ATTRIBUTE_COUPLE_DIVISOR) {\n\t\tdev_err(cc->dev, \"Invalid clk specifier (%d, %d)\\n\", idx, attr);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (cc->clks[idx]) {\n\t\tcc->clks[idx]->attributes = attr;\n\t\treturn &cc->clks[idx]->hw;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nint q6dsp_clock_dev_probe(struct platform_device *pdev)\n{\n\tstruct q6dsp_cc *cc;\n\tstruct device *dev = &pdev->dev;\n\tconst struct q6dsp_clk_init *q6dsp_clks;\n\tconst struct q6dsp_clk_desc *desc;\n\tint i, ret;\n\n\tcc = devm_kzalloc(dev, sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tcc->desc = desc;\n\tcc->dev = dev;\n\tq6dsp_clks = desc->clks;\n\n\tfor (i = 0; i < desc->num_clks; i++) {\n\t\tunsigned int id = q6dsp_clks[i].clk_id;\n\t\tstruct clk_init_data init = {\n\t\t\t.name =  q6dsp_clks[i].name,\n\t\t};\n\t\tstruct q6dsp_clk *clk;\n\n\t\tclk = devm_kzalloc(dev, sizeof(*clk), GFP_KERNEL);\n\t\tif (!clk)\n\t\t\treturn -ENOMEM;\n\n\t\tclk->dev = dev;\n\t\tclk->q6dsp_clk_id = q6dsp_clks[i].q6dsp_clk_id;\n\t\tclk->rate = q6dsp_clks[i].rate;\n\t\tclk->hw.init = &init;\n\n\t\tif (clk->rate)\n\t\t\tinit.ops = &clk_q6dsp_ops;\n\t\telse\n\t\t\tinit.ops = &clk_vote_q6dsp_ops;\n\n\t\tcc->clks[id] = clk;\n\n\t\tret = devm_clk_hw_register(dev, &clk->hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_of_clk_add_hw_provider(dev, q6dsp_of_clk_hw_get, cc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, cc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(q6dsp_clock_dev_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}