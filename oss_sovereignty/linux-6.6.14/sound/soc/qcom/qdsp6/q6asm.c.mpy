{
  "module_name": "q6asm.c",
  "hash_id": "973e86ea4576668aab77b49af85bdc47ee9f7b1fc37aefb24917143766f2a186",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6asm.c",
  "human_readable_source": "\n\n\n\n#include <linux/mutex.h>\n#include <linux/wait.h>\n#include <linux/module.h>\n#include <linux/soc/qcom/apr.h>\n#include <linux/device.h>\n#include <linux/of_platform.h>\n#include <linux/spinlock.h>\n#include <linux/kref.h>\n#include <linux/of.h>\n#include <uapi/sound/asound.h>\n#include <uapi/sound/compress_params.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include \"q6asm.h\"\n#include \"q6core.h\"\n#include \"q6dsp-errno.h\"\n#include \"q6dsp-common.h\"\n\n#define ASM_STREAM_CMD_CLOSE\t\t\t0x00010BCD\n#define ASM_STREAM_CMD_FLUSH\t\t\t0x00010BCE\n#define ASM_SESSION_CMD_PAUSE\t\t\t0x00010BD3\n#define ASM_DATA_CMD_EOS\t\t\t0x00010BDB\n#define ASM_DATA_EVENT_RENDERED_EOS\t\t0x00010C1C\n#define ASM_NULL_POPP_TOPOLOGY\t\t\t0x00010C68\n#define ASM_STREAM_CMD_FLUSH_READBUFS\t\t0x00010C09\n#define ASM_STREAM_CMD_SET_ENCDEC_PARAM\t\t0x00010C10\n#define ASM_STREAM_POSTPROC_TOPO_ID_NONE\t0x00010C68\n#define ASM_CMD_SHARED_MEM_MAP_REGIONS\t\t0x00010D92\n#define ASM_CMDRSP_SHARED_MEM_MAP_REGIONS\t0x00010D93\n#define ASM_CMD_SHARED_MEM_UNMAP_REGIONS\t0x00010D94\n#define ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2\t0x00010D98\n#define ASM_DATA_EVENT_WRITE_DONE_V2\t\t0x00010D99\n#define ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2\t0x00010DA3\n#define ASM_SESSION_CMD_RUN_V2\t\t\t0x00010DAA\n#define ASM_MEDIA_FMT_MULTI_CHANNEL_PCM_V2\t0x00010DA5\n#define ASM_MEDIA_FMT_MP3\t\t\t0x00010BE9\n#define ASM_MEDIA_FMT_FLAC\t\t\t0x00010C16\n#define ASM_MEDIA_FMT_WMA_V9\t\t\t0x00010DA8\n#define ASM_MEDIA_FMT_WMA_V10\t\t\t0x00010DA7\n#define ASM_DATA_CMD_WRITE_V2\t\t\t0x00010DAB\n#define ASM_DATA_CMD_READ_V2\t\t\t0x00010DAC\n#define ASM_SESSION_CMD_SUSPEND\t\t\t0x00010DEC\n#define ASM_STREAM_CMD_OPEN_WRITE_V3\t\t0x00010DB3\n#define ASM_STREAM_CMD_OPEN_READ_V3                 0x00010DB4\n#define ASM_DATA_EVENT_READ_DONE_V2 0x00010D9A\n#define ASM_STREAM_CMD_OPEN_READWRITE_V2        0x00010D8D\n#define ASM_MEDIA_FMT_ALAC\t\t\t0x00012f31\n#define ASM_MEDIA_FMT_APE\t\t\t0x00012f32\n#define ASM_DATA_CMD_REMOVE_INITIAL_SILENCE\t0x00010D67\n#define ASM_DATA_CMD_REMOVE_TRAILING_SILENCE\t0x00010D68\n\n\n#define ASM_LEGACY_STREAM_SESSION\t0\n \n#define ASM_SHIFT_STREAM_PERF_MODE_FLAG_IN_OPEN_READ              29\n#define ASM_END_POINT_DEVICE_MATRIX\t0\n#define ASM_DEFAULT_APP_TYPE\t\t0\n#define ASM_SYNC_IO_MODE\t\t0x0001\n#define ASM_ASYNC_IO_MODE\t\t0x0002\n#define ASM_TUN_READ_IO_MODE\t\t0x0004\t \n#define ASM_TUN_WRITE_IO_MODE\t\t0x0008\t \n#define ASM_SHIFT_GAPLESS_MODE_FLAG\t31\n#define ADSP_MEMORY_MAP_SHMEM8_4K_POOL\t3\n\nstruct avs_cmd_shared_mem_map_regions {\n\tu16 mem_pool_id;\n\tu16 num_regions;\n\tu32 property_flag;\n} __packed;\n\nstruct avs_shared_map_region_payload {\n\tu32 shm_addr_lsw;\n\tu32 shm_addr_msw;\n\tu32 mem_size_bytes;\n} __packed;\n\nstruct avs_cmd_shared_mem_unmap_regions {\n\tu32 mem_map_handle;\n} __packed;\n\nstruct asm_data_cmd_media_fmt_update_v2 {\n\tu32 fmt_blk_size;\n} __packed;\n\nstruct asm_multi_channel_pcm_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu16 num_channels;\n\tu16 bits_per_sample;\n\tu32 sample_rate;\n\tu16 is_signed;\n\tu16 reserved;\n\tu8 channel_mapping[PCM_MAX_NUM_CHANNEL];\n} __packed;\n\nstruct asm_flac_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu16 is_stream_info_present;\n\tu16 num_channels;\n\tu16 min_blk_size;\n\tu16 max_blk_size;\n\tu16 md5_sum[8];\n\tu32 sample_rate;\n\tu32 min_frame_size;\n\tu32 max_frame_size;\n\tu16 sample_size;\n\tu16 reserved;\n} __packed;\n\nstruct asm_wmastdv9_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu16          fmtag;\n\tu16          num_channels;\n\tu32          sample_rate;\n\tu32          bytes_per_sec;\n\tu16          blk_align;\n\tu16          bits_per_sample;\n\tu32          channel_mask;\n\tu16          enc_options;\n\tu16          reserved;\n} __packed;\n\nstruct asm_wmaprov10_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu16          fmtag;\n\tu16          num_channels;\n\tu32          sample_rate;\n\tu32          bytes_per_sec;\n\tu16          blk_align;\n\tu16          bits_per_sample;\n\tu32          channel_mask;\n\tu16          enc_options;\n\tu16          advanced_enc_options1;\n\tu32          advanced_enc_options2;\n} __packed;\n\nstruct asm_alac_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu32 frame_length;\n\tu8 compatible_version;\n\tu8 bit_depth;\n\tu8 pb;\n\tu8 mb;\n\tu8 kb;\n\tu8 num_channels;\n\tu16 max_run;\n\tu32 max_frame_bytes;\n\tu32 avg_bit_rate;\n\tu32 sample_rate;\n\tu32 channel_layout_tag;\n} __packed;\n\nstruct asm_ape_fmt_blk_v2 {\n\tstruct asm_data_cmd_media_fmt_update_v2 fmt_blk;\n\tu16 compatible_version;\n\tu16 compression_level;\n\tu32 format_flags;\n\tu32 blocks_per_frame;\n\tu32 final_frame_blocks;\n\tu32 total_frames;\n\tu16 bits_per_sample;\n\tu16 num_channels;\n\tu32 sample_rate;\n\tu32 seek_table_present;\n} __packed;\n\nstruct asm_stream_cmd_set_encdec_param {\n\tu32                  param_id;\n\tu32                  param_size;\n} __packed;\n\nstruct asm_enc_cfg_blk_param_v2 {\n\tu32                  frames_per_buf;\n\tu32                  enc_cfg_blk_size;\n} __packed;\n\nstruct asm_multi_channel_pcm_enc_cfg_v2 {\n\tstruct asm_stream_cmd_set_encdec_param  encdec;\n\tstruct asm_enc_cfg_blk_param_v2\tencblk;\n\tuint16_t  num_channels;\n\tuint16_t  bits_per_sample;\n\tuint32_t  sample_rate;\n\tuint16_t  is_signed;\n\tuint16_t  reserved;\n\tuint8_t   channel_mapping[8];\n} __packed;\n\nstruct asm_data_cmd_read_v2 {\n\tu32                  buf_addr_lsw;\n\tu32                  buf_addr_msw;\n\tu32                  mem_map_handle;\n\tu32                  buf_size;\n\tu32                  seq_id;\n} __packed;\n\nstruct asm_data_cmd_read_v2_done {\n\tu32\tstatus;\n\tu32\tbuf_addr_lsw;\n\tu32\tbuf_addr_msw;\n};\n\nstruct asm_stream_cmd_open_read_v3 {\n\tu32                    mode_flags;\n\tu32                    src_endpointype;\n\tu32                    preprocopo_id;\n\tu32                    enc_cfg_id;\n\tu16                    bits_per_sample;\n\tu16                    reserved;\n} __packed;\n\nstruct asm_data_cmd_write_v2 {\n\tu32 buf_addr_lsw;\n\tu32 buf_addr_msw;\n\tu32 mem_map_handle;\n\tu32 buf_size;\n\tu32 seq_id;\n\tu32 timestamp_lsw;\n\tu32 timestamp_msw;\n\tu32 flags;\n} __packed;\n\nstruct asm_stream_cmd_open_write_v3 {\n\tuint32_t mode_flags;\n\tuint16_t sink_endpointype;\n\tuint16_t bits_per_sample;\n\tuint32_t postprocopo_id;\n\tuint32_t dec_fmt_id;\n} __packed;\n\nstruct asm_session_cmd_run_v2 {\n\tu32 flags;\n\tu32 time_lsw;\n\tu32 time_msw;\n} __packed;\n\nstruct audio_buffer {\n\tphys_addr_t phys;\n\tuint32_t size;\t\t \n};\n\nstruct audio_port_data {\n\tstruct audio_buffer *buf;\n\tuint32_t num_periods;\n\tuint32_t dsp_buf;\n\tuint32_t mem_map_handle;\n};\n\nstruct q6asm {\n\tstruct apr_device *adev;\n\tstruct device *dev;\n\tstruct q6core_svc_api_info ainfo;\n\twait_queue_head_t mem_wait;\n\tspinlock_t slock;\n\tstruct audio_client *session[MAX_SESSIONS + 1];\n};\n\nstruct audio_client {\n\tint session;\n\tq6asm_cb cb;\n\tvoid *priv;\n\tuint32_t io_mode;\n\tstruct apr_device *adev;\n\tstruct mutex cmd_lock;\n\tspinlock_t lock;\n\tstruct kref refcount;\n\t \n\tstruct audio_port_data port[2];\n\twait_queue_head_t cmd_wait;\n\tstruct aprv2_ibasic_rsp_result_t result;\n\tint perf_mode;\n\tstruct q6asm *q6asm;\n\tstruct device *dev;\n};\n\nstatic inline void q6asm_add_hdr(struct audio_client *ac, struct apr_hdr *hdr,\n\t\t\t\t uint32_t pkt_size, bool cmd_flg,\n\t\t\t\t uint32_t stream_id)\n{\n\thdr->hdr_field = APR_SEQ_CMD_HDR_FIELD;\n\thdr->src_port = ((ac->session << 8) & 0xFF00) | (stream_id);\n\thdr->dest_port = ((ac->session << 8) & 0xFF00) | (stream_id);\n\thdr->pkt_size = pkt_size;\n\tif (cmd_flg)\n\t\thdr->token = ac->session;\n}\n\nstatic int q6asm_apr_send_session_pkt(struct q6asm *a, struct audio_client *ac,\n\t\t\t\t      struct apr_pkt *pkt, uint32_t rsp_opcode)\n{\n\tstruct apr_hdr *hdr = &pkt->hdr;\n\tint rc;\n\n\tmutex_lock(&ac->cmd_lock);\n\tac->result.opcode = 0;\n\tac->result.status = 0;\n\trc = apr_send_pkt(a->adev, pkt);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif (rsp_opcode)\n\t\trc = wait_event_timeout(a->mem_wait,\n\t\t\t\t\t(ac->result.opcode == hdr->opcode) ||\n\t\t\t\t\t(ac->result.opcode == rsp_opcode),\n\t\t\t\t\t5 * HZ);\n\telse\n\t\trc = wait_event_timeout(a->mem_wait,\n\t\t\t\t\t(ac->result.opcode == hdr->opcode),\n\t\t\t\t\t5 * HZ);\n\n\tif (!rc) {\n\t\tdev_err(a->dev, \"CMD %x timeout\\n\", hdr->opcode);\n\t\trc = -ETIMEDOUT;\n\t} else if (ac->result.status > 0) {\n\t\tdev_err(a->dev, \"DSP returned error[%x]\\n\",\n\t\t\tac->result.status);\n\t\trc = -EINVAL;\n\t}\n\nerr:\n\tmutex_unlock(&ac->cmd_lock);\n\treturn rc;\n}\n\nstatic int __q6asm_memory_unmap(struct audio_client *ac,\n\t\t\t\tphys_addr_t buf_add, int dir)\n{\n\tstruct avs_cmd_shared_mem_unmap_regions *mem_unmap;\n\tstruct q6asm *a = dev_get_drvdata(ac->dev->parent);\n\tstruct apr_pkt *pkt;\n\tint rc, pkt_size;\n\tvoid *p;\n\n\tif (ac->port[dir].mem_map_handle == 0) {\n\t\tdev_err(ac->dev, \"invalid mem handle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*mem_unmap);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tmem_unmap = p + APR_HDR_SIZE;\n\n\tpkt->hdr.hdr_field = APR_SEQ_CMD_HDR_FIELD;\n\tpkt->hdr.src_port = 0;\n\tpkt->hdr.dest_port = 0;\n\tpkt->hdr.pkt_size = pkt_size;\n\tpkt->hdr.token = ((ac->session << 8) | dir);\n\n\tpkt->hdr.opcode = ASM_CMD_SHARED_MEM_UNMAP_REGIONS;\n\tmem_unmap->mem_map_handle = ac->port[dir].mem_map_handle;\n\n\trc = q6asm_apr_send_session_pkt(a, ac, pkt, 0);\n\tif (rc < 0) {\n\t\tkfree(pkt);\n\t\treturn rc;\n\t}\n\n\tac->port[dir].mem_map_handle = 0;\n\n\tkfree(pkt);\n\treturn 0;\n}\n\n\nstatic void q6asm_audio_client_free_buf(struct audio_client *ac,\n\t\t\t\t\tstruct audio_port_data *port)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tport->num_periods = 0;\n\tkfree(port->buf);\n\tport->buf = NULL;\n\tspin_unlock_irqrestore(&ac->lock, flags);\n}\n\n \nint q6asm_unmap_memory_regions(unsigned int dir, struct audio_client *ac)\n{\n\tstruct audio_port_data *port;\n\tint cnt = 0;\n\tint rc = 0;\n\n\tport = &ac->port[dir];\n\tif (!port->buf) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcnt = port->num_periods - 1;\n\tif (cnt >= 0) {\n\t\trc = __q6asm_memory_unmap(ac, port->buf[dir].phys, dir);\n\t\tif (rc < 0) {\n\t\t\tdev_err(ac->dev, \"%s: Memory_unmap_regions failed %d\\n\",\n\t\t\t\t__func__, rc);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tq6asm_audio_client_free_buf(ac, port);\n\nerr:\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_unmap_memory_regions);\n\nstatic int __q6asm_memory_map_regions(struct audio_client *ac, int dir,\n\t\t\t\t      size_t period_sz, unsigned int periods,\n\t\t\t\t      bool is_contiguous)\n{\n\tstruct avs_cmd_shared_mem_map_regions *cmd = NULL;\n\tstruct avs_shared_map_region_payload *mregions = NULL;\n\tstruct q6asm *a = dev_get_drvdata(ac->dev->parent);\n\tstruct audio_port_data *port = NULL;\n\tstruct audio_buffer *ab = NULL;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tunsigned long flags;\n\tuint32_t num_regions, buf_sz;\n\tint rc, i, pkt_size;\n\n\tif (is_contiguous) {\n\t\tnum_regions = 1;\n\t\tbuf_sz = period_sz * periods;\n\t} else {\n\t\tbuf_sz = period_sz;\n\t\tnum_regions = periods;\n\t}\n\n\t \n\tbuf_sz = ALIGN(buf_sz, 4096);\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*cmd) +\n\t\t   (sizeof(*mregions) * num_regions);\n\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tcmd = p + APR_HDR_SIZE;\n\tmregions = p + APR_HDR_SIZE +  sizeof(*cmd);\n\n\tpkt->hdr.hdr_field = APR_SEQ_CMD_HDR_FIELD;\n\tpkt->hdr.src_port = 0;\n\tpkt->hdr.dest_port = 0;\n\tpkt->hdr.pkt_size = pkt_size;\n\tpkt->hdr.token = ((ac->session << 8) | dir);\n\tpkt->hdr.opcode = ASM_CMD_SHARED_MEM_MAP_REGIONS;\n\n\tcmd->mem_pool_id = ADSP_MEMORY_MAP_SHMEM8_4K_POOL;\n\tcmd->num_regions = num_regions;\n\tcmd->property_flag = 0x00;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tport = &ac->port[dir];\n\n\tfor (i = 0; i < num_regions; i++) {\n\t\tab = &port->buf[i];\n\t\tmregions->shm_addr_lsw = lower_32_bits(ab->phys);\n\t\tmregions->shm_addr_msw = upper_32_bits(ab->phys);\n\t\tmregions->mem_size_bytes = buf_sz;\n\t\t++mregions;\n\t}\n\tspin_unlock_irqrestore(&ac->lock, flags);\n\n\trc = q6asm_apr_send_session_pkt(a, ac, pkt,\n\t\t\t\t\tASM_CMDRSP_SHARED_MEM_MAP_REGIONS);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\n \nint q6asm_map_memory_regions(unsigned int dir, struct audio_client *ac,\n\t\t\t     phys_addr_t phys,\n\t\t\t     size_t period_sz, unsigned int periods)\n{\n\tstruct audio_buffer *buf;\n\tunsigned long flags;\n\tint cnt;\n\tint rc;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tif (ac->port[dir].buf) {\n\t\tdev_err(ac->dev, \"Buffer already allocated\\n\");\n\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\treturn 0;\n\t}\n\n\tbuf = kcalloc(periods, sizeof(*buf), GFP_ATOMIC);\n\tif (!buf) {\n\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\n\tac->port[dir].buf = buf;\n\n\tbuf[0].phys = phys;\n\tbuf[0].size = period_sz;\n\n\tfor (cnt = 1; cnt < periods; cnt++) {\n\t\tif (period_sz > 0) {\n\t\t\tbuf[cnt].phys = buf[0].phys + (cnt * period_sz);\n\t\t\tbuf[cnt].size = period_sz;\n\t\t}\n\t}\n\tac->port[dir].num_periods = periods;\n\n\tspin_unlock_irqrestore(&ac->lock, flags);\n\n\trc = __q6asm_memory_map_regions(ac, dir, period_sz, periods, 1);\n\tif (rc < 0) {\n\t\tdev_err(ac->dev, \"Memory_map_regions failed\\n\");\n\t\tq6asm_audio_client_free_buf(ac, &ac->port[dir]);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_map_memory_regions);\n\nstatic void q6asm_audio_client_release(struct kref *ref)\n{\n\tstruct audio_client *ac;\n\tstruct q6asm *a;\n\tunsigned long flags;\n\n\tac = container_of(ref, struct audio_client, refcount);\n\ta = ac->q6asm;\n\n\tspin_lock_irqsave(&a->slock, flags);\n\ta->session[ac->session] = NULL;\n\tspin_unlock_irqrestore(&a->slock, flags);\n\n\tkfree(ac);\n}\n\n \nvoid q6asm_audio_client_free(struct audio_client *ac)\n{\n\tkref_put(&ac->refcount, q6asm_audio_client_release);\n}\nEXPORT_SYMBOL_GPL(q6asm_audio_client_free);\n\nstatic struct audio_client *q6asm_get_audio_client(struct q6asm *a,\n\t\t\t\t\t\t   int session_id)\n{\n\tstruct audio_client *ac = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&a->slock, flags);\n\tif ((session_id <= 0) || (session_id > MAX_SESSIONS)) {\n\t\tdev_err(a->dev, \"invalid session: %d\\n\", session_id);\n\t\tgoto err;\n\t}\n\n\t \n\tif (!a->session[session_id])\n\t\tgoto err;\n\telse if (a->session[session_id]->session != session_id)\n\t\tgoto err;\n\n\tac = a->session[session_id];\n\tkref_get(&ac->refcount);\nerr:\n\tspin_unlock_irqrestore(&a->slock, flags);\n\treturn ac;\n}\n\nstatic int32_t q6asm_stream_callback(struct apr_device *adev,\n\t\t\t\t     struct apr_resp_pkt *data,\n\t\t\t\t     int session_id)\n{\n\tstruct q6asm *q6asm = dev_get_drvdata(&adev->dev);\n\tstruct aprv2_ibasic_rsp_result_t *result;\n\tstruct apr_hdr *hdr = &data->hdr;\n\tstruct audio_port_data *port;\n\tstruct audio_client *ac;\n\tuint32_t client_event = 0;\n\tint ret = 0;\n\n\tac = q6asm_get_audio_client(q6asm, session_id);\n\tif (!ac) \n\t\treturn 0;\n\n\tresult = data->payload;\n\n\tswitch (hdr->opcode) {\n\tcase APR_BASIC_RSP_RESULT:\n\t\tswitch (result->opcode) {\n\t\tcase ASM_SESSION_CMD_PAUSE:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_PAUSE_DONE;\n\t\t\tbreak;\n\t\tcase ASM_SESSION_CMD_SUSPEND:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_SUSPEND_DONE;\n\t\t\tbreak;\n\t\tcase ASM_STREAM_CMD_FLUSH:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_FLUSH_DONE;\n\t\t\tbreak;\n\t\tcase ASM_SESSION_CMD_RUN_V2:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_RUN_DONE;\n\t\t\tbreak;\n\t\tcase ASM_STREAM_CMD_CLOSE:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_CLOSE_DONE;\n\t\t\tbreak;\n\t\tcase ASM_STREAM_CMD_FLUSH_READBUFS:\n\t\t\tclient_event = ASM_CLIENT_EVENT_CMD_OUT_FLUSH_DONE;\n\t\t\tbreak;\n\t\tcase ASM_STREAM_CMD_OPEN_WRITE_V3:\n\t\tcase ASM_STREAM_CMD_OPEN_READ_V3:\n\t\tcase ASM_STREAM_CMD_OPEN_READWRITE_V2:\n\t\tcase ASM_STREAM_CMD_SET_ENCDEC_PARAM:\n\t\tcase ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2:\n\t\tcase ASM_DATA_CMD_REMOVE_INITIAL_SILENCE:\n\t\tcase ASM_DATA_CMD_REMOVE_TRAILING_SILENCE:\n\t\t\tif (result->status != 0) {\n\t\t\t\tdev_err(ac->dev,\n\t\t\t\t\t\"cmd = 0x%x returned error = 0x%x\\n\",\n\t\t\t\t\tresult->opcode, result->status);\n\t\t\t\tac->result = *result;\n\t\t\t\twake_up(&ac->cmd_wait);\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ac->dev, \"command[0x%x] not expecting rsp\\n\",\n\t\t\t\tresult->opcode);\n\t\t\tbreak;\n\t\t}\n\n\t\tac->result = *result;\n\t\twake_up(&ac->cmd_wait);\n\n\t\tif (ac->cb)\n\t\t\tac->cb(client_event, hdr->token,\n\t\t\t       data->payload, ac->priv);\n\n\t\tret = 0;\n\t\tgoto done;\n\n\tcase ASM_DATA_EVENT_WRITE_DONE_V2:\n\t\tclient_event = ASM_CLIENT_EVENT_DATA_WRITE_DONE;\n\t\tif (ac->io_mode & ASM_SYNC_IO_MODE) {\n\t\t\tphys_addr_t phys;\n\t\t\tunsigned long flags;\n\t\t\tint token = hdr->token & ASM_WRITE_TOKEN_MASK;\n\n\t\t\tspin_lock_irqsave(&ac->lock, flags);\n\n\t\t\tport =  &ac->port[SNDRV_PCM_STREAM_PLAYBACK];\n\n\t\t\tif (!port->buf) {\n\t\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tphys = port->buf[token].phys;\n\n\t\t\tif (lower_32_bits(phys) != result->opcode ||\n\t\t\t    upper_32_bits(phys) != result->status) {\n\t\t\t\tdev_err(ac->dev, \"Expected addr %pa\\n\",\n\t\t\t\t\t&port->buf[token].phys);\n\t\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t}\n\t\tbreak;\n\tcase ASM_DATA_EVENT_READ_DONE_V2:\n\t\tclient_event = ASM_CLIENT_EVENT_DATA_READ_DONE;\n\t\tif (ac->io_mode & ASM_SYNC_IO_MODE) {\n\t\t\tstruct asm_data_cmd_read_v2_done *done = data->payload;\n\t\t\tunsigned long flags;\n\t\t\tphys_addr_t phys;\n\n\t\t\tspin_lock_irqsave(&ac->lock, flags);\n\t\t\tport =  &ac->port[SNDRV_PCM_STREAM_CAPTURE];\n\t\t\tif (!port->buf) {\n\t\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tphys = port->buf[hdr->token].phys;\n\n\t\t\tif (upper_32_bits(phys) != done->buf_addr_msw ||\n\t\t\t    lower_32_bits(phys) != done->buf_addr_lsw) {\n\t\t\t\tdev_err(ac->dev, \"Expected addr %pa %08x-%08x\\n\",\n\t\t\t\t\t&port->buf[hdr->token].phys,\n\t\t\t\t\tdone->buf_addr_lsw,\n\t\t\t\t\tdone->buf_addr_msw);\n\t\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ac->lock, flags);\n\t\t}\n\n\t\tbreak;\n\tcase ASM_DATA_EVENT_RENDERED_EOS:\n\t\tclient_event = ASM_CLIENT_EVENT_CMD_EOS_DONE;\n\t\tbreak;\n\t}\n\n\tif (ac->cb)\n\t\tac->cb(client_event, hdr->token, data->payload, ac->priv);\n\ndone:\n\tkref_put(&ac->refcount, q6asm_audio_client_release);\n\treturn ret;\n}\n\nstatic int q6asm_srvc_callback(struct apr_device *adev,\n\t\t\t       struct apr_resp_pkt *data)\n{\n\tstruct q6asm *q6asm = dev_get_drvdata(&adev->dev);\n\tstruct aprv2_ibasic_rsp_result_t *result;\n\tstruct audio_port_data *port;\n\tstruct audio_client *ac = NULL;\n\tstruct apr_hdr *hdr = &data->hdr;\n\tstruct q6asm *a;\n\tuint32_t sid = 0;\n\tuint32_t dir = 0;\n\tint session_id;\n\n\tsession_id = (hdr->dest_port >> 8) & 0xFF;\n\tif (session_id)\n\t\treturn q6asm_stream_callback(adev, data, session_id);\n\n\tsid = (hdr->token >> 8) & 0x0F;\n\tac = q6asm_get_audio_client(q6asm, sid);\n\tif (!ac) {\n\t\tdev_err(&adev->dev, \"Audio Client not active\\n\");\n\t\treturn 0;\n\t}\n\n\ta = dev_get_drvdata(ac->dev->parent);\n\tdir = (hdr->token & 0x0F);\n\tport = &ac->port[dir];\n\tresult = data->payload;\n\n\tswitch (hdr->opcode) {\n\tcase APR_BASIC_RSP_RESULT:\n\t\tswitch (result->opcode) {\n\t\tcase ASM_CMD_SHARED_MEM_MAP_REGIONS:\n\t\tcase ASM_CMD_SHARED_MEM_UNMAP_REGIONS:\n\t\t\tac->result = *result;\n\t\t\twake_up(&a->mem_wait);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&adev->dev, \"command[0x%x] not expecting rsp\\n\",\n\t\t\t\t result->opcode);\n\t\t\tbreak;\n\t\t}\n\t\tgoto done;\n\tcase ASM_CMDRSP_SHARED_MEM_MAP_REGIONS:\n\t\tac->result.status = 0;\n\t\tac->result.opcode = hdr->opcode;\n\t\tport->mem_map_handle = result->opcode;\n\t\twake_up(&a->mem_wait);\n\t\tbreak;\n\tcase ASM_CMD_SHARED_MEM_UNMAP_REGIONS:\n\t\tac->result.opcode = hdr->opcode;\n\t\tac->result.status = 0;\n\t\tport->mem_map_handle = 0;\n\t\twake_up(&a->mem_wait);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&adev->dev, \"command[0x%x]success [0x%x]\\n\",\n\t\t\tresult->opcode, result->status);\n\t\tbreak;\n\t}\n\n\tif (ac->cb)\n\t\tac->cb(hdr->opcode, hdr->token, data->payload, ac->priv);\n\ndone:\n\tkref_put(&ac->refcount, q6asm_audio_client_release);\n\n\treturn 0;\n}\n\n \nint q6asm_get_session_id(struct audio_client *c)\n{\n\treturn c->session;\n}\nEXPORT_SYMBOL_GPL(q6asm_get_session_id);\n\n \nstruct audio_client *q6asm_audio_client_alloc(struct device *dev, q6asm_cb cb,\n\t\t\t\t\t      void *priv, int session_id,\n\t\t\t\t\t      int perf_mode)\n{\n\tstruct q6asm *a = dev_get_drvdata(dev->parent);\n\tstruct audio_client *ac;\n\tunsigned long flags;\n\n\tac = q6asm_get_audio_client(a, session_id + 1);\n\tif (ac) {\n\t\tdev_err(dev, \"Audio Client already active\\n\");\n\t\treturn ac;\n\t}\n\n\tac = kzalloc(sizeof(*ac), GFP_KERNEL);\n\tif (!ac)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_irqsave(&a->slock, flags);\n\ta->session[session_id + 1] = ac;\n\tspin_unlock_irqrestore(&a->slock, flags);\n\tac->session = session_id + 1;\n\tac->cb = cb;\n\tac->dev = dev;\n\tac->q6asm = a;\n\tac->priv = priv;\n\tac->io_mode = ASM_SYNC_IO_MODE;\n\tac->perf_mode = perf_mode;\n\tac->adev = a->adev;\n\tkref_init(&ac->refcount);\n\n\tinit_waitqueue_head(&ac->cmd_wait);\n\tmutex_init(&ac->cmd_lock);\n\tspin_lock_init(&ac->lock);\n\n\treturn ac;\n}\nEXPORT_SYMBOL_GPL(q6asm_audio_client_alloc);\n\nstatic int q6asm_ac_send_cmd_sync(struct audio_client *ac, struct apr_pkt *pkt)\n{\n\tstruct apr_hdr *hdr = &pkt->hdr;\n\tint rc;\n\n\tmutex_lock(&ac->cmd_lock);\n\tac->result.opcode = 0;\n\tac->result.status = 0;\n\n\trc = apr_send_pkt(ac->adev, pkt);\n\tif (rc < 0)\n\t\tgoto err;\n\n\trc = wait_event_timeout(ac->cmd_wait,\n\t\t\t\t(ac->result.opcode == hdr->opcode), 5 * HZ);\n\tif (!rc) {\n\t\tdev_err(ac->dev, \"CMD %x timeout\\n\", hdr->opcode);\n\t\trc =  -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tif (ac->result.status > 0) {\n\t\tdev_err(ac->dev, \"DSP returned error[%x]\\n\",\n\t\t\tac->result.status);\n\t\trc = -EINVAL;\n\t} else {\n\t\trc = 0;\n\t}\n\n\nerr:\n\tmutex_unlock(&ac->cmd_lock);\n\treturn rc;\n}\n\n \nint q6asm_open_write(struct audio_client *ac, uint32_t stream_id,\n\t\t     uint32_t format, u32 codec_profile,\n\t\t     uint16_t bits_per_sample, bool is_gapless)\n{\n\tstruct asm_stream_cmd_open_write_v3 *open;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*open);\n\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\topen = p + APR_HDR_SIZE;\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_STREAM_CMD_OPEN_WRITE_V3;\n\topen->mode_flags = 0x00;\n\topen->mode_flags |= ASM_LEGACY_STREAM_SESSION;\n\tif (is_gapless)\n\t\topen->mode_flags |= BIT(ASM_SHIFT_GAPLESS_MODE_FLAG);\n\n\t \n\topen->sink_endpointype = ASM_END_POINT_DEVICE_MATRIX;\n\topen->bits_per_sample = bits_per_sample;\n\topen->postprocopo_id = ASM_NULL_POPP_TOPOLOGY;\n\n\tswitch (format) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\topen->dec_fmt_id = ASM_MEDIA_FMT_MP3;\n\t\tbreak;\n\tcase FORMAT_LINEAR_PCM:\n\t\topen->dec_fmt_id = ASM_MEDIA_FMT_MULTI_CHANNEL_PCM_V2;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_FLAC:\n\t\topen->dec_fmt_id = ASM_MEDIA_FMT_FLAC;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_WMA:\n\t\tswitch (codec_profile) {\n\t\tcase SND_AUDIOPROFILE_WMA9:\n\t\t\topen->dec_fmt_id = ASM_MEDIA_FMT_WMA_V9;\n\t\t\tbreak;\n\t\tcase SND_AUDIOPROFILE_WMA10:\n\t\tcase SND_AUDIOPROFILE_WMA9_PRO:\n\t\tcase SND_AUDIOPROFILE_WMA9_LOSSLESS:\n\t\tcase SND_AUDIOPROFILE_WMA10_LOSSLESS:\n\t\t\topen->dec_fmt_id = ASM_MEDIA_FMT_WMA_V10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(ac->dev, \"Invalid codec profile 0x%x\\n\",\n\t\t\t\tcodec_profile);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SND_AUDIOCODEC_ALAC:\n\t\topen->dec_fmt_id = ASM_MEDIA_FMT_ALAC;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_APE:\n\t\topen->dec_fmt_id = ASM_MEDIA_FMT_APE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ac->dev, \"Invalid format 0x%x\\n\", format);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tac->io_mode |= ASM_TUN_WRITE_IO_MODE;\n\nerr:\n\tkfree(pkt);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_open_write);\n\nstatic int __q6asm_run(struct audio_client *ac, uint32_t stream_id,\n\t\t       uint32_t flags, uint32_t msw_ts, uint32_t lsw_ts,\n\t\t       bool wait)\n{\n\tstruct asm_session_cmd_run_v2 *run;\n\tstruct apr_pkt *pkt;\n\tint pkt_size, rc;\n\tvoid *p;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*run);\n\tp = kzalloc(pkt_size, GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\trun = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_SESSION_CMD_RUN_V2;\n\trun->flags = flags;\n\trun->time_lsw = lsw_ts;\n\trun->time_msw = msw_ts;\n\tif (wait) {\n\t\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\t} else {\n\t\trc = apr_send_pkt(ac->adev, pkt);\n\t\tif (rc == pkt_size)\n\t\t\trc = 0;\n\t}\n\n\tkfree(pkt);\n\treturn rc;\n}\n\n \nint q6asm_run(struct audio_client *ac, uint32_t stream_id, uint32_t flags,\n\t      uint32_t msw_ts, uint32_t lsw_ts)\n{\n\treturn __q6asm_run(ac, stream_id, flags, msw_ts, lsw_ts, true);\n}\nEXPORT_SYMBOL_GPL(q6asm_run);\n\n \nint q6asm_run_nowait(struct audio_client *ac, uint32_t stream_id,\n\t\t     uint32_t flags, uint32_t msw_ts, uint32_t lsw_ts)\n{\n\treturn __q6asm_run(ac, stream_id, flags, msw_ts, lsw_ts, false);\n}\nEXPORT_SYMBOL_GPL(q6asm_run_nowait);\n\n \nint q6asm_media_format_block_multi_ch_pcm(struct audio_client *ac,\n\t\t\t\t\t  uint32_t stream_id,\n\t\t\t\t\t  uint32_t rate, uint32_t channels,\n\t\t\t\t\t  u8 channel_map[PCM_MAX_NUM_CHANNEL],\n\t\t\t\t\t  uint16_t bits_per_sample)\n{\n\tstruct asm_multi_channel_pcm_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tu8 *channel_mapping;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\tfmt->num_channels = channels;\n\tfmt->bits_per_sample = bits_per_sample;\n\tfmt->sample_rate = rate;\n\tfmt->is_signed = 1;\n\n\tchannel_mapping = fmt->channel_mapping;\n\n\tif (channel_map) {\n\t\tmemcpy(channel_mapping, channel_map, PCM_MAX_NUM_CHANNEL);\n\t} else {\n\t\tif (q6dsp_map_channels(channel_mapping, channels)) {\n\t\t\tdev_err(ac->dev, \" map channels failed %d\\n\", channels);\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\nerr:\n\tkfree(pkt);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_media_format_block_multi_ch_pcm);\n\nint q6asm_stream_media_format_block_flac(struct audio_client *ac,\n\t\t\t\t\t uint32_t stream_id,\n\t\t\t\t\t struct q6asm_flac_cfg *cfg)\n{\n\tstruct asm_flac_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\tfmt->is_stream_info_present = cfg->stream_info_present;\n\tfmt->num_channels = cfg->ch_cfg;\n\tfmt->min_blk_size = cfg->min_blk_size;\n\tfmt->max_blk_size = cfg->max_blk_size;\n\tfmt->sample_rate = cfg->sample_rate;\n\tfmt->min_frame_size = cfg->min_frame_size;\n\tfmt->max_frame_size = cfg->max_frame_size;\n\tfmt->sample_size = cfg->sample_size;\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_media_format_block_flac);\n\nint q6asm_stream_media_format_block_wma_v9(struct audio_client *ac,\n\t\t\t\t\t   uint32_t stream_id,\n\t\t\t\t\t   struct q6asm_wma_cfg *cfg)\n{\n\tstruct asm_wmastdv9_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\tfmt->fmtag = cfg->fmtag;\n\tfmt->num_channels = cfg->num_channels;\n\tfmt->sample_rate = cfg->sample_rate;\n\tfmt->bytes_per_sec = cfg->bytes_per_sec;\n\tfmt->blk_align = cfg->block_align;\n\tfmt->bits_per_sample = cfg->bits_per_sample;\n\tfmt->channel_mask = cfg->channel_mask;\n\tfmt->enc_options = cfg->enc_options;\n\tfmt->reserved = 0;\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_media_format_block_wma_v9);\n\nint q6asm_stream_media_format_block_wma_v10(struct audio_client *ac,\n\t\t\t\t\t    uint32_t stream_id,\n\t\t\t\t\t    struct q6asm_wma_cfg *cfg)\n{\n\tstruct asm_wmaprov10_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\tfmt->fmtag = cfg->fmtag;\n\tfmt->num_channels = cfg->num_channels;\n\tfmt->sample_rate = cfg->sample_rate;\n\tfmt->bytes_per_sec = cfg->bytes_per_sec;\n\tfmt->blk_align = cfg->block_align;\n\tfmt->bits_per_sample = cfg->bits_per_sample;\n\tfmt->channel_mask = cfg->channel_mask;\n\tfmt->enc_options = cfg->enc_options;\n\tfmt->advanced_enc_options1 = cfg->adv_enc_options;\n\tfmt->advanced_enc_options2 = cfg->adv_enc_options2;\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_media_format_block_wma_v10);\n\nint q6asm_stream_media_format_block_alac(struct audio_client *ac,\n\t\t\t\t\t uint32_t stream_id,\n\t\t\t\t\t struct q6asm_alac_cfg *cfg)\n{\n\tstruct asm_alac_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\n\tfmt->frame_length = cfg->frame_length;\n\tfmt->compatible_version = cfg->compatible_version;\n\tfmt->bit_depth =  cfg->bit_depth;\n\tfmt->num_channels = cfg->num_channels;\n\tfmt->max_run = cfg->max_run;\n\tfmt->max_frame_bytes = cfg->max_frame_bytes;\n\tfmt->avg_bit_rate = cfg->avg_bit_rate;\n\tfmt->sample_rate = cfg->sample_rate;\n\tfmt->channel_layout_tag = cfg->channel_layout_tag;\n\tfmt->pb = cfg->pb;\n\tfmt->mb = cfg->mb;\n\tfmt->kb = cfg->kb;\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_media_format_block_alac);\n\nint q6asm_stream_media_format_block_ape(struct audio_client *ac,\n\t\t\t\t\tuint32_t stream_id,\n\t\t\t\t\tstruct q6asm_ape_cfg *cfg)\n{\n\tstruct asm_ape_fmt_blk_v2 *fmt;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*fmt);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tfmt = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_DATA_CMD_MEDIA_FMT_UPDATE_V2;\n\tfmt->fmt_blk.fmt_blk_size = sizeof(*fmt) - sizeof(fmt->fmt_blk);\n\n\tfmt->compatible_version = cfg->compatible_version;\n\tfmt->compression_level = cfg->compression_level;\n\tfmt->format_flags = cfg->format_flags;\n\tfmt->blocks_per_frame = cfg->blocks_per_frame;\n\tfmt->final_frame_blocks = cfg->final_frame_blocks;\n\tfmt->total_frames = cfg->total_frames;\n\tfmt->bits_per_sample = cfg->bits_per_sample;\n\tfmt->num_channels = cfg->num_channels;\n\tfmt->sample_rate = cfg->sample_rate;\n\tfmt->seek_table_present = cfg->seek_table_present;\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_media_format_block_ape);\n\nstatic int q6asm_stream_remove_silence(struct audio_client *ac, uint32_t stream_id,\n\t\t\t\t       uint32_t cmd,\n\t\t\t\t       uint32_t num_samples)\n{\n\tuint32_t *samples;\n\tstruct apr_pkt *pkt;\n\tvoid *p;\n\tint rc, pkt_size;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(uint32_t);\n\tp = kzalloc(pkt_size, GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tsamples = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = cmd;\n\t*samples = num_samples;\n\trc = apr_send_pkt(ac->adev, pkt);\n\tif (rc == pkt_size)\n\t\trc = 0;\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint q6asm_stream_remove_initial_silence(struct audio_client *ac,\n\t\t\t\t\tuint32_t stream_id,\n\t\t\t\t\tuint32_t initial_samples)\n{\n\treturn q6asm_stream_remove_silence(ac, stream_id,\n\t\t\t\t\t   ASM_DATA_CMD_REMOVE_INITIAL_SILENCE,\n\t\t\t\t\t   initial_samples);\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_remove_initial_silence);\n\nint q6asm_stream_remove_trailing_silence(struct audio_client *ac, uint32_t stream_id,\n\t\t\t\t\t uint32_t trailing_samples)\n{\n\treturn q6asm_stream_remove_silence(ac, stream_id,\n\t\t\t\t   ASM_DATA_CMD_REMOVE_TRAILING_SILENCE,\n\t\t\t\t   trailing_samples);\n}\nEXPORT_SYMBOL_GPL(q6asm_stream_remove_trailing_silence);\n\n \nint q6asm_enc_cfg_blk_pcm_format_support(struct audio_client *ac,\n\t\t\t\t\t uint32_t stream_id, uint32_t rate,\n\t\t\t\t\t uint32_t channels,\n\t\t\t\t\t uint16_t bits_per_sample)\n{\n\tstruct asm_multi_channel_pcm_enc_cfg_v2  *enc_cfg;\n\tstruct apr_pkt *pkt;\n\tu8 *channel_mapping;\n\tu32 frames_per_buf = 0;\n\tint pkt_size, rc;\n\tvoid *p;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*enc_cfg);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tenc_cfg = p + APR_HDR_SIZE;\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, true, stream_id);\n\n\tpkt->hdr.opcode = ASM_STREAM_CMD_SET_ENCDEC_PARAM;\n\tenc_cfg->encdec.param_id = ASM_PARAM_ID_ENCDEC_ENC_CFG_BLK_V2;\n\tenc_cfg->encdec.param_size = sizeof(*enc_cfg) - sizeof(enc_cfg->encdec);\n\tenc_cfg->encblk.frames_per_buf = frames_per_buf;\n\tenc_cfg->encblk.enc_cfg_blk_size  = enc_cfg->encdec.param_size -\n\t\t\t\t\tsizeof(struct asm_enc_cfg_blk_param_v2);\n\n\tenc_cfg->num_channels = channels;\n\tenc_cfg->bits_per_sample = bits_per_sample;\n\tenc_cfg->sample_rate = rate;\n\tenc_cfg->is_signed = 1;\n\tchannel_mapping = enc_cfg->channel_mapping;\n\n\tif (q6dsp_map_channels(channel_mapping, channels)) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\nerr:\n\tkfree(pkt);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_enc_cfg_blk_pcm_format_support);\n\n\n \nint q6asm_read(struct audio_client *ac, uint32_t stream_id)\n{\n\tstruct asm_data_cmd_read_v2 *read;\n\tstruct audio_port_data *port;\n\tstruct audio_buffer *ab;\n\tstruct apr_pkt *pkt;\n\tunsigned long flags;\n\tint pkt_size;\n\tint rc = 0;\n\tvoid *p;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*read);\n\tp = kzalloc(pkt_size, GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tread = p + APR_HDR_SIZE;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tport = &ac->port[SNDRV_PCM_STREAM_CAPTURE];\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, false, stream_id);\n\tab = &port->buf[port->dsp_buf];\n\tpkt->hdr.opcode = ASM_DATA_CMD_READ_V2;\n\tread->buf_addr_lsw = lower_32_bits(ab->phys);\n\tread->buf_addr_msw = upper_32_bits(ab->phys);\n\tread->mem_map_handle = port->mem_map_handle;\n\n\tread->buf_size = ab->size;\n\tread->seq_id = port->dsp_buf;\n\tpkt->hdr.token = port->dsp_buf;\n\n\tport->dsp_buf++;\n\n\tif (port->dsp_buf >= port->num_periods)\n\t\tport->dsp_buf = 0;\n\n\tspin_unlock_irqrestore(&ac->lock, flags);\n\trc = apr_send_pkt(ac->adev, pkt);\n\tif (rc == pkt_size)\n\t\trc = 0;\n\telse\n\t\tpr_err(\"read op[0x%x]rc[%d]\\n\", pkt->hdr.opcode, rc);\n\n\tkfree(pkt);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_read);\n\nstatic int __q6asm_open_read(struct audio_client *ac, uint32_t stream_id,\n\t\tuint32_t format, uint16_t bits_per_sample)\n{\n\tstruct asm_stream_cmd_open_read_v3 *open;\n\tstruct apr_pkt *pkt;\n\tint pkt_size, rc;\n\tvoid *p;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*open);\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\topen = p + APR_HDR_SIZE;\n\n\tq6asm_add_hdr(ac, &pkt->hdr,  pkt_size, true, stream_id);\n\tpkt->hdr.opcode = ASM_STREAM_CMD_OPEN_READ_V3;\n\t \n\topen->src_endpointype = ASM_END_POINT_DEVICE_MATRIX;\n\n\topen->preprocopo_id = ASM_STREAM_POSTPROC_TOPO_ID_NONE;\n\topen->bits_per_sample = bits_per_sample;\n\topen->mode_flags = 0x0;\n\n\topen->mode_flags |= ASM_LEGACY_STREAM_SESSION <<\n\t\t\t\tASM_SHIFT_STREAM_PERF_MODE_FLAG_IN_OPEN_READ;\n\n\tswitch (format) {\n\tcase FORMAT_LINEAR_PCM:\n\t\topen->mode_flags |= 0x00;\n\t\topen->enc_cfg_id = ASM_MEDIA_FMT_MULTI_CHANNEL_PCM_V2;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid format[%d]\\n\", format);\n\t}\n\n\trc = q6asm_ac_send_cmd_sync(ac, pkt);\n\n\tkfree(pkt);\n\treturn rc;\n}\n\n \nint q6asm_open_read(struct audio_client *ac, uint32_t stream_id,\n\t\t    uint32_t format, uint16_t bits_per_sample)\n{\n\treturn __q6asm_open_read(ac, stream_id, format, bits_per_sample);\n}\nEXPORT_SYMBOL_GPL(q6asm_open_read);\n\n \nint q6asm_write_async(struct audio_client *ac, uint32_t stream_id, uint32_t len,\n\t\t      uint32_t msw_ts, uint32_t lsw_ts, uint32_t wflags)\n{\n\tstruct asm_data_cmd_write_v2 *write;\n\tstruct audio_port_data *port;\n\tstruct audio_buffer *ab;\n\tunsigned long flags;\n\tstruct apr_pkt *pkt;\n\tint pkt_size;\n\tint rc = 0;\n\tvoid *p;\n\n\tpkt_size = APR_HDR_SIZE + sizeof(*write);\n\tp = kzalloc(pkt_size, GFP_ATOMIC);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\twrite = p + APR_HDR_SIZE;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tport = &ac->port[SNDRV_PCM_STREAM_PLAYBACK];\n\tq6asm_add_hdr(ac, &pkt->hdr, pkt_size, false, stream_id);\n\n\tab = &port->buf[port->dsp_buf];\n\tpkt->hdr.token = port->dsp_buf | (len << ASM_WRITE_TOKEN_LEN_SHIFT);\n\tpkt->hdr.opcode = ASM_DATA_CMD_WRITE_V2;\n\twrite->buf_addr_lsw = lower_32_bits(ab->phys);\n\twrite->buf_addr_msw = upper_32_bits(ab->phys);\n\twrite->buf_size = len;\n\twrite->seq_id = port->dsp_buf;\n\twrite->timestamp_lsw = lsw_ts;\n\twrite->timestamp_msw = msw_ts;\n\twrite->mem_map_handle =\n\t    ac->port[SNDRV_PCM_STREAM_PLAYBACK].mem_map_handle;\n\n\twrite->flags = wflags;\n\n\tport->dsp_buf++;\n\n\tif (port->dsp_buf >= port->num_periods)\n\t\tport->dsp_buf = 0;\n\n\tspin_unlock_irqrestore(&ac->lock, flags);\n\trc = apr_send_pkt(ac->adev, pkt);\n\tif (rc == pkt_size)\n\t\trc = 0;\n\n\tkfree(pkt);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6asm_write_async);\n\nstatic void q6asm_reset_buf_state(struct audio_client *ac)\n{\n\tstruct audio_port_data *port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ac->lock, flags);\n\tport = &ac->port[SNDRV_PCM_STREAM_PLAYBACK];\n\tport->dsp_buf = 0;\n\tport = &ac->port[SNDRV_PCM_STREAM_CAPTURE];\n\tport->dsp_buf = 0;\n\tspin_unlock_irqrestore(&ac->lock, flags);\n}\n\nstatic int __q6asm_cmd(struct audio_client *ac, uint32_t stream_id, int cmd,\n\t\t       bool wait)\n{\n\tstruct apr_pkt pkt;\n\tint rc;\n\n\tq6asm_add_hdr(ac, &pkt.hdr, APR_HDR_SIZE, true, stream_id);\n\n\tswitch (cmd) {\n\tcase CMD_PAUSE:\n\t\tpkt.hdr.opcode = ASM_SESSION_CMD_PAUSE;\n\t\tbreak;\n\tcase CMD_SUSPEND:\n\t\tpkt.hdr.opcode = ASM_SESSION_CMD_SUSPEND;\n\t\tbreak;\n\tcase CMD_FLUSH:\n\t\tpkt.hdr.opcode = ASM_STREAM_CMD_FLUSH;\n\t\tbreak;\n\tcase CMD_OUT_FLUSH:\n\t\tpkt.hdr.opcode = ASM_STREAM_CMD_FLUSH_READBUFS;\n\t\tbreak;\n\tcase CMD_EOS:\n\t\tpkt.hdr.opcode = ASM_DATA_CMD_EOS;\n\t\tbreak;\n\tcase CMD_CLOSE:\n\t\tpkt.hdr.opcode = ASM_STREAM_CMD_CLOSE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (wait)\n\t\trc = q6asm_ac_send_cmd_sync(ac, &pkt);\n\telse\n\t\treturn apr_send_pkt(ac->adev, &pkt);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (cmd == CMD_FLUSH)\n\t\tq6asm_reset_buf_state(ac);\n\n\treturn 0;\n}\n\n \nint q6asm_cmd(struct audio_client *ac, uint32_t stream_id, int cmd)\n{\n\treturn __q6asm_cmd(ac, stream_id, cmd, true);\n}\nEXPORT_SYMBOL_GPL(q6asm_cmd);\n\n \nint q6asm_cmd_nowait(struct audio_client *ac, uint32_t stream_id, int cmd)\n{\n\treturn __q6asm_cmd(ac, stream_id, cmd, false);\n}\nEXPORT_SYMBOL_GPL(q6asm_cmd_nowait);\n\nstatic int q6asm_probe(struct apr_device *adev)\n{\n\tstruct device *dev = &adev->dev;\n\tstruct q6asm *q6asm;\n\n\tq6asm = devm_kzalloc(dev, sizeof(*q6asm), GFP_KERNEL);\n\tif (!q6asm)\n\t\treturn -ENOMEM;\n\n\tq6core_get_svc_api_info(adev->svc_id, &q6asm->ainfo);\n\n\tq6asm->dev = dev;\n\tq6asm->adev = adev;\n\tinit_waitqueue_head(&q6asm->mem_wait);\n\tspin_lock_init(&q6asm->slock);\n\tdev_set_drvdata(dev, q6asm);\n\n\treturn devm_of_platform_populate(dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6asm_device_id[]  = {\n\t{ .compatible = \"qcom,q6asm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6asm_device_id);\n#endif\n\nstatic struct apr_driver qcom_q6asm_driver = {\n\t.probe = q6asm_probe,\n\t.callback = q6asm_srvc_callback,\n\t.driver = {\n\t\t.name = \"qcom-q6asm\",\n\t\t.of_match_table = of_match_ptr(q6asm_device_id),\n\t},\n};\n\nmodule_apr_driver(qcom_q6asm_driver);\nMODULE_DESCRIPTION(\"Q6 Audio Stream Manager driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}