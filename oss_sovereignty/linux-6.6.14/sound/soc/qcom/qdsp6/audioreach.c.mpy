{
  "module_name": "audioreach.c",
  "hash_id": "3bd8489ac38d82e256939474bec84ea7f3df5d62c1cb379580d977cfe0eb74e1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/audioreach.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/apr.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <dt-bindings/soc/qcom,gpr.h>\n#include \"q6apm.h\"\n#include \"audioreach.h\"\n\n \nstruct apm_sub_graph_data {\n\tstruct apm_sub_graph_cfg sub_graph_cfg;\n\tstruct apm_prop_data perf_data;\n\tstruct apm_sg_prop_id_perf_mode perf;\n\tstruct apm_prop_data dir_data;\n\tstruct apm_sg_prop_id_direction dir;\n\tstruct apm_prop_data sid_data;\n\tstruct apm_sg_prop_id_scenario_id sid;\n\n} __packed;\n\n#define APM_SUB_GRAPH_CFG_NPROP\t3\n\nstruct apm_sub_graph_params  {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_sub_graphs;\n\tstruct apm_sub_graph_data sg_cfg[];\n} __packed;\n\n#define APM_SUB_GRAPH_PSIZE(p, n) ALIGN(struct_size(p, sg_cfg, n), 8)\n\n \nstruct apm_container_obj  {\n\tstruct apm_container_cfg container_cfg;\n\t \n\tstruct apm_prop_data cap_data;\n\tuint32_t num_capability_id;\n\tuint32_t capability_id;\n\n\t \n\tstruct apm_prop_data pos_data;\n\tstruct apm_cont_prop_id_graph_pos pos;\n\n\t \n\tstruct apm_prop_data stack_data;\n\tstruct apm_cont_prop_id_stack_size stack;\n\n\t \n\tstruct apm_prop_data domain_data;\n\tstruct apm_cont_prop_id_domain domain;\n} __packed;\n\nstruct apm_container_params  {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_containers;\n\tstruct apm_container_obj cont_obj[];\n} __packed;\n\n#define APM_CONTAINER_PSIZE(p, n) ALIGN(struct_size(p, cont_obj, n), 8)\n\n \nstruct apm_mod_list_obj {\n\t \n\tuint32_t sub_graph_id;\n\tuint32_t container_id;\n\tuint32_t num_modules;\n\tstruct apm_module_obj mod_cfg[];\n} __packed;\n\n#define APM_MOD_LIST_OBJ_PSIZE(p, n) struct_size(p, mod_cfg, n)\n\nstruct apm_module_list_params {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_modules_list;\n\t \n\tstruct apm_mod_list_obj mod_list_obj[];\n} __packed;\n\n\n \nstruct apm_mod_prop_obj {\n\tu32 instance_id;\n\tu32 num_props;\n\tstruct apm_prop_data prop_data_1;\n\tstruct apm_module_prop_id_port_info prop_id_port;\n} __packed;\n\nstruct apm_prop_list_params {\n\tstruct apm_module_param_data param_data;\n\tu32 num_modules_prop_cfg;\n\tstruct apm_mod_prop_obj mod_prop_obj[];\n\n} __packed;\n\n#define APM_MOD_PROP_PSIZE(p, n) ALIGN(struct_size(p, mod_prop_obj, n), 8)\n\n \nstruct apm_mod_conn_list_params {\n\tstruct apm_module_param_data param_data;\n\tu32 num_connections;\n\tstruct apm_module_conn_obj conn_obj[];\n\n} __packed;\n\n#define APM_MOD_CONN_PSIZE(p, n) ALIGN(struct_size(p, conn_obj, n), 8)\n\nstruct apm_graph_open_params {\n\tstruct apm_cmd_header *cmd_header;\n\tstruct apm_sub_graph_params *sg_data;\n\tstruct apm_container_params *cont_data;\n\tstruct apm_module_list_params *mod_list_data;\n\tstruct apm_prop_list_params *mod_prop_data;\n\tstruct apm_mod_conn_list_params *mod_conn_list_data;\n} __packed;\n\nstruct apm_pcm_module_media_fmt_cmd {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_pcm_output_format_cfg header;\n\tstruct payload_pcm_output_format_cfg media_cfg;\n} __packed;\n\nstruct apm_rd_shmem_module_config_cmd {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_rd_sh_mem_cfg cfg;\n} __packed;\n\nstruct apm_sh_module_media_fmt_cmd {\n\tstruct media_format header;\n\tstruct payload_media_fmt_pcm cfg;\n} __packed;\n\n#define APM_SHMEM_FMT_CFG_PSIZE(ch) ALIGN( \\\n\t\t\t\tsizeof(struct apm_sh_module_media_fmt_cmd) + \\\n\t\t\t\tch * sizeof(uint8_t), 8)\n\n \n#define APM_PCM_MODULE_FMT_CMD_PSIZE(ch) ALIGN( \\\n\t\t\t\tsizeof(struct apm_pcm_module_media_fmt_cmd) + \\\n\t\t\t\tch * sizeof(uint8_t), 8)\n\n#define APM_PCM_OUT_FMT_CFG_PSIZE(p, n) ALIGN(struct_size(p, channel_mapping, n), 4)\n\nstruct apm_i2s_module_intf_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_i2s_intf_cfg cfg;\n} __packed;\n\n#define APM_I2S_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_i2s_module_intf_cfg), 8)\n\nstruct apm_module_hw_ep_mf_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_hw_ep_mf mf;\n} __packed;\n\n#define APM_HW_EP_CFG_PSIZE ALIGN(sizeof(struct apm_module_hw_ep_mf_cfg), 8)\n\n#define APM_MFC_CFG_PSIZE(p, n) ALIGN(struct_size(p, channel_mapping, n), 4)\n\nstruct apm_module_frame_size_factor_cfg {\n\tstruct apm_module_param_data param_data;\n\tuint32_t frame_size_factor;\n} __packed;\n\n#define APM_FS_CFG_PSIZE ALIGN(sizeof(struct apm_module_frame_size_factor_cfg), 8)\n\nstruct apm_module_hw_ep_power_mode_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_hw_ep_power_mode_cfg power_mode;\n} __packed;\n\n#define APM_HW_EP_PMODE_CFG_PSIZE ALIGN(sizeof(struct apm_module_hw_ep_power_mode_cfg),\t8)\n\nstruct apm_module_hw_ep_dma_data_align_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_hw_ep_dma_data_align align;\n} __packed;\n\n#define APM_HW_EP_DALIGN_CFG_PSIZE ALIGN(sizeof(struct apm_module_hw_ep_dma_data_align_cfg), 8)\n\nstruct apm_gain_module_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_gain_cfg gain_cfg;\n} __packed;\n\n#define APM_GAIN_CFG_PSIZE ALIGN(sizeof(struct apm_gain_module_cfg), 8)\n\nstruct apm_codec_dma_module_intf_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_codec_dma_intf_cfg cfg;\n} __packed;\n\n#define APM_CDMA_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_codec_dma_module_intf_cfg), 8)\n\nstruct apm_display_port_module_intf_cfg {\n\tstruct apm_module_param_data param_data;\n\tstruct param_id_display_port_intf_cfg cfg;\n} __packed;\n#define APM_DP_INTF_CFG_PSIZE ALIGN(sizeof(struct apm_display_port_module_intf_cfg), 8)\n\nstatic void *__audioreach_alloc_pkt(int payload_size, uint32_t opcode, uint32_t token,\n\t\t\t\t    uint32_t src_port, uint32_t dest_port, bool has_cmd_hdr)\n{\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\tint pkt_size = GPR_HDR_SIZE + payload_size;\n\n\tif (has_cmd_hdr)\n\t\tpkt_size += APM_CMD_HDR_SIZE;\n\n\tp = kzalloc(pkt_size, GFP_KERNEL);\n\tif (!p)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpkt = p;\n\tpkt->hdr.version = GPR_PKT_VER;\n\tpkt->hdr.hdr_size = GPR_PKT_HEADER_WORD_SIZE;\n\tpkt->hdr.pkt_size = pkt_size;\n\tpkt->hdr.dest_port = dest_port;\n\tpkt->hdr.src_port = src_port;\n\n\tpkt->hdr.dest_domain = GPR_DOMAIN_ID_ADSP;\n\tpkt->hdr.src_domain = GPR_DOMAIN_ID_APPS;\n\tpkt->hdr.token = token;\n\tpkt->hdr.opcode = opcode;\n\n\tif (has_cmd_hdr) {\n\t\tstruct apm_cmd_header *cmd_header;\n\n\t\tp = p + GPR_HDR_SIZE;\n\t\tcmd_header = p;\n\t\tcmd_header->payload_size = payload_size;\n\t}\n\n\treturn pkt;\n}\n\nvoid *audioreach_alloc_pkt(int payload_size, uint32_t opcode, uint32_t token,\n\t\t\t   uint32_t src_port, uint32_t dest_port)\n{\n\treturn __audioreach_alloc_pkt(payload_size, opcode, token, src_port, dest_port, false);\n}\nEXPORT_SYMBOL_GPL(audioreach_alloc_pkt);\n\nvoid *audioreach_alloc_apm_pkt(int pkt_size, uint32_t opcode, uint32_t token, uint32_t src_port)\n{\n\treturn __audioreach_alloc_pkt(pkt_size, opcode, token, src_port, APM_MODULE_INSTANCE_ID,\n\t\t\t\t      false);\n}\nEXPORT_SYMBOL_GPL(audioreach_alloc_apm_pkt);\n\nvoid *audioreach_alloc_cmd_pkt(int payload_size, uint32_t opcode, uint32_t token,\n\t\t\t       uint32_t src_port, uint32_t dest_port)\n{\n\treturn __audioreach_alloc_pkt(payload_size, opcode, token, src_port, dest_port, true);\n}\nEXPORT_SYMBOL_GPL(audioreach_alloc_cmd_pkt);\n\nvoid *audioreach_alloc_apm_cmd_pkt(int pkt_size, uint32_t opcode, uint32_t token)\n{\n\treturn __audioreach_alloc_pkt(pkt_size, opcode, token, GPR_APM_MODULE_IID,\n\t\t\t\t       APM_MODULE_INSTANCE_ID, true);\n}\nEXPORT_SYMBOL_GPL(audioreach_alloc_apm_cmd_pkt);\n\nstatic void apm_populate_container_config(struct apm_container_obj *cfg,\n\t\t\t\t\t  struct audioreach_container *cont)\n{\n\n\t \n\tcfg->container_cfg.container_id = cont->container_id;\n\tcfg->container_cfg.num_prop = 4;\n\n\t \n\tcfg->cap_data.prop_id = APM_CONTAINER_PROP_ID_CAPABILITY_LIST;\n\tcfg->cap_data.prop_size = APM_CONTAINER_PROP_ID_CAPABILITY_SIZE;\n\tcfg->num_capability_id = 1;\n\tcfg->capability_id = cont->capability_id;\n\n\t \n\tcfg->pos_data.prop_id = APM_CONTAINER_PROP_ID_GRAPH_POS;\n\tcfg->pos_data.prop_size = sizeof(struct apm_cont_prop_id_graph_pos);\n\tcfg->pos.graph_pos = cont->graph_pos;\n\n\t \n\tcfg->stack_data.prop_id = APM_CONTAINER_PROP_ID_STACK_SIZE;\n\tcfg->stack_data.prop_size = sizeof(struct apm_cont_prop_id_stack_size);\n\tcfg->stack.stack_size = cont->stack_size;\n\n\t \n\tcfg->domain_data.prop_id = APM_CONTAINER_PROP_ID_PROC_DOMAIN;\n\tcfg->domain_data.prop_size = sizeof(struct apm_cont_prop_id_domain);\n\tcfg->domain.proc_domain = cont->proc_domain;\n}\n\nstatic void apm_populate_sub_graph_config(struct apm_sub_graph_data *cfg,\n\t\t\t\t\t  struct audioreach_sub_graph *sg)\n{\n\tcfg->sub_graph_cfg.sub_graph_id = sg->sub_graph_id;\n\tcfg->sub_graph_cfg.num_sub_graph_prop = APM_SUB_GRAPH_CFG_NPROP;\n\n\t \n\tcfg->perf_data.prop_id = APM_SUB_GRAPH_PROP_ID_PERF_MODE;\n\tcfg->perf_data.prop_size = APM_SG_PROP_ID_PERF_MODE_SIZE;\n\tcfg->perf.perf_mode = sg->perf_mode;\n\n\t \n\tcfg->dir_data.prop_id = APM_SUB_GRAPH_PROP_ID_DIRECTION;\n\tcfg->dir_data.prop_size = APM_SG_PROP_ID_DIR_SIZE;\n\tcfg->dir.direction = sg->direction;\n\n\t \n\tcfg->sid_data.prop_id = APM_SUB_GRAPH_PROP_ID_SCENARIO_ID;\n\tcfg->sid_data.prop_size = APM_SG_PROP_ID_SID_SIZE;\n\tcfg->sid.scenario_id = sg->scenario_id;\n}\n\nstatic void apm_populate_module_prop_obj(struct apm_mod_prop_obj *obj,\n\t\t\t\t\t struct audioreach_module *module)\n{\n\n\tobj->instance_id = module->instance_id;\n\tobj->num_props = 1;\n\tobj->prop_data_1.prop_id = APM_MODULE_PROP_ID_PORT_INFO;\n\tobj->prop_data_1.prop_size = APM_MODULE_PROP_ID_PORT_INFO_SZ;\n\tobj->prop_id_port.max_ip_port = module->max_ip_port;\n\tobj->prop_id_port.max_op_port = module->max_op_port;\n}\n\nstatic void apm_populate_module_list_obj(struct apm_mod_list_obj *obj,\n\t\t\t\t\t struct audioreach_container *container,\n\t\t\t\t\t int sub_graph_id)\n{\n\tstruct audioreach_module *module;\n\tint i;\n\n\tobj->sub_graph_id = sub_graph_id;\n\tobj->container_id = container->container_id;\n\tobj->num_modules = container->num_modules;\n\ti = 0;\n\tlist_for_each_entry(module, &container->modules_list, node) {\n\t\tobj->mod_cfg[i].module_id = module->module_id;\n\t\tobj->mod_cfg[i].instance_id = module->instance_id;\n\t\ti++;\n\t}\n}\n\nstatic void audioreach_populate_graph(struct q6apm *apm, struct audioreach_graph_info *info,\n\t\t\t\t      struct apm_graph_open_params *open,\n\t\t\t\t      struct list_head *sg_list,\n\t\t\t\t      int num_sub_graphs)\n{\n\tstruct apm_mod_conn_list_params *mc_data = open->mod_conn_list_data;\n\tstruct apm_module_list_params *ml_data = open->mod_list_data;\n\tstruct apm_prop_list_params *mp_data = open->mod_prop_data;\n\tstruct apm_container_params *c_data = open->cont_data;\n\tstruct apm_sub_graph_params *sg_data = open->sg_data;\n\tint ncontainer = 0, nmodule = 0, nconn = 0;\n\tstruct apm_mod_prop_obj *module_prop_obj;\n\tstruct audioreach_container *container;\n\tstruct apm_module_conn_obj *conn_obj;\n\tstruct audioreach_module *module;\n\tstruct audioreach_sub_graph *sg;\n\tstruct apm_container_obj *cobj;\n\tstruct apm_mod_list_obj *mlobj;\n\tint i = 0;\n\n\tmlobj = &ml_data->mod_list_obj[0];\n\n\n\tif (info->dst_mod_inst_id && info->src_mod_inst_id) {\n\t\tconn_obj = &mc_data->conn_obj[nconn];\n\t\tconn_obj->src_mod_inst_id = info->src_mod_inst_id;\n\t\tconn_obj->src_mod_op_port_id = info->src_mod_op_port_id;\n\t\tconn_obj->dst_mod_inst_id = info->dst_mod_inst_id;\n\t\tconn_obj->dst_mod_ip_port_id = info->dst_mod_ip_port_id;\n\t\tnconn++;\n\t}\n\n\tlist_for_each_entry(sg, sg_list, node) {\n\t\tstruct apm_sub_graph_data *sg_cfg = &sg_data->sg_cfg[i++];\n\n\t\tapm_populate_sub_graph_config(sg_cfg, sg);\n\n\t\tlist_for_each_entry(container, &sg->container_list, node) {\n\t\t\tcobj = &c_data->cont_obj[ncontainer];\n\n\t\t\tapm_populate_container_config(cobj, container);\n\t\t\tapm_populate_module_list_obj(mlobj, container, sg->sub_graph_id);\n\n\t\t\tlist_for_each_entry(module, &container->modules_list, node) {\n\t\t\t\tint pn;\n\n\t\t\t\tmodule_prop_obj = &mp_data->mod_prop_obj[nmodule++];\n\t\t\t\tapm_populate_module_prop_obj(module_prop_obj, module);\n\n\t\t\t\tif (!module->max_op_port)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (pn = 0; pn < module->max_op_port; pn++) {\n\t\t\t\t\tif (module->dst_mod_inst_id[pn]) {\n\t\t\t\t\t\tconn_obj = &mc_data->conn_obj[nconn];\n\t\t\t\t\t\tconn_obj->src_mod_inst_id = module->instance_id;\n\t\t\t\t\t\tconn_obj->src_mod_op_port_id =\n\t\t\t\t\t\t\t\tmodule->src_mod_op_port_id[pn];\n\t\t\t\t\t\tconn_obj->dst_mod_inst_id =\n\t\t\t\t\t\t\t\tmodule->dst_mod_inst_id[pn];\n\t\t\t\t\t\tconn_obj->dst_mod_ip_port_id =\n\t\t\t\t\t\t\t\tmodule->dst_mod_ip_port_id[pn];\n\t\t\t\t\t\tnconn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlobj = (void *) mlobj + APM_MOD_LIST_OBJ_PSIZE(mlobj,\n\t\t\t\t\t\t\t\t\tcontainer->num_modules);\n\n\t\t\tncontainer++;\n\t\t}\n\t}\n}\n\nvoid *audioreach_alloc_graph_pkt(struct q6apm *apm, struct audioreach_graph_info *info)\n{\n\tint payload_size, sg_sz, cont_sz, ml_sz, mp_sz, mc_sz;\n\tstruct apm_module_param_data  *param_data;\n\tstruct apm_container_params *cont_params;\n\tstruct audioreach_container *container;\n\tstruct apm_sub_graph_params *sg_params;\n\tstruct apm_mod_conn_list_params *mcon;\n\tstruct apm_graph_open_params params;\n\tstruct apm_prop_list_params *mprop;\n\tstruct audioreach_module *module;\n\tstruct audioreach_sub_graph *sgs;\n\tstruct apm_mod_list_obj *mlobj;\n\tstruct list_head *sg_list;\n\tint num_connections = 0;\n\tint num_containers = 0;\n\tint num_sub_graphs = 0;\n\tint num_modules = 0;\n\tint num_modules_list;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tsg_list = &info->sg_list;\n\tml_sz = 0;\n\n\t \n\tif (info->dst_mod_inst_id && info->src_mod_inst_id)\n\t\tnum_connections++;\n\n\tlist_for_each_entry(sgs, sg_list, node) {\n\t\tnum_sub_graphs++;\n\t\tlist_for_each_entry(container, &sgs->container_list, node) {\n\t\t\tnum_containers++;\n\t\t\tnum_modules += container->num_modules;\n\t\t\tml_sz = ml_sz + sizeof(struct apm_module_list_params) +\n\t\t\t\tAPM_MOD_LIST_OBJ_PSIZE(mlobj, container->num_modules);\n\n\t\t\tlist_for_each_entry(module, &container->modules_list, node) {\n\t\t\t\tnum_connections += module->num_connections;\n\t\t\t}\n\t\t}\n\t}\n\n\tnum_modules_list = num_containers;\n\tsg_sz = APM_SUB_GRAPH_PSIZE(sg_params, num_sub_graphs);\n\tcont_sz = APM_CONTAINER_PSIZE(cont_params, num_containers);\n\n\tml_sz = ALIGN(ml_sz, 8);\n\n\tmp_sz = APM_MOD_PROP_PSIZE(mprop, num_modules);\n\tmc_sz =\tAPM_MOD_CONN_PSIZE(mcon, num_connections);\n\n\tpayload_size = sg_sz + cont_sz + ml_sz + mp_sz + mc_sz;\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_GRAPH_OPEN, 0);\n\tif (IS_ERR(pkt))\n\t\treturn pkt;\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\t \n\tparams.sg_data = p;\n\tparam_data = &params.sg_data->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_SUB_GRAPH_CONFIG;\n\tparam_data->param_size = sg_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tparams.sg_data->num_sub_graphs = num_sub_graphs;\n\tp += sg_sz;\n\n\t \n\tparams.cont_data = p;\n\tparam_data = &params.cont_data->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_CONTAINER_CONFIG;\n\tparam_data->param_size = cont_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tparams.cont_data->num_containers = num_containers;\n\tp += cont_sz;\n\n\t \n\tparams.mod_list_data = p;\n\tparam_data = &params.mod_list_data->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_MODULE_LIST;\n\tparam_data->param_size = ml_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tparams.mod_list_data->num_modules_list = num_modules_list;\n\tp += ml_sz;\n\n\t \n\tparams.mod_prop_data = p;\n\tparam_data = &params.mod_prop_data->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_MODULE_PROP;\n\tparam_data->param_size = mp_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tparams.mod_prop_data->num_modules_prop_cfg = num_modules;\n\tp += mp_sz;\n\n\t \n\tparams.mod_conn_list_data = p;\n\tparam_data = &params.mod_conn_list_data->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_MODULE_CONN;\n\tparam_data->param_size = mc_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tparams.mod_conn_list_data->num_connections = num_connections;\n\tp += mc_sz;\n\n\taudioreach_populate_graph(apm, info, &params, sg_list, num_sub_graphs);\n\n\treturn pkt;\n}\nEXPORT_SYMBOL_GPL(audioreach_alloc_graph_pkt);\n\nint audioreach_send_cmd_sync(struct device *dev, gpr_device_t *gdev,\n\t\t\t     struct gpr_ibasic_rsp_result_t *result, struct mutex *cmd_lock,\n\t\t\t     gpr_port_t *port, wait_queue_head_t *cmd_wait,\n\t\t\t     struct gpr_pkt *pkt, uint32_t rsp_opcode)\n{\n\n\tstruct gpr_hdr *hdr = &pkt->hdr;\n\tint rc;\n\n\tmutex_lock(cmd_lock);\n\tresult->opcode = 0;\n\tresult->status = 0;\n\n\tif (port)\n\t\trc = gpr_send_port_pkt(port, pkt);\n\telse if (gdev)\n\t\trc = gpr_send_pkt(gdev, pkt);\n\telse\n\t\trc = -EINVAL;\n\n\tif (rc < 0)\n\t\tgoto err;\n\n\tif (rsp_opcode)\n\t\trc = wait_event_timeout(*cmd_wait, (result->opcode == hdr->opcode) ||\n\t\t\t\t\t(result->opcode == rsp_opcode),\t5 * HZ);\n\telse\n\t\trc = wait_event_timeout(*cmd_wait, (result->opcode == hdr->opcode), 5 * HZ);\n\n\tif (!rc) {\n\t\tdev_err(dev, \"CMD timeout for [%x] opcode\\n\", hdr->opcode);\n\t\trc = -ETIMEDOUT;\n\t} else if (result->status > 0) {\n\t\tdev_err(dev, \"DSP returned error[%x] %x\\n\", hdr->opcode, result->status);\n\t\trc = -EINVAL;\n\t} else {\n\t\t \n\t\trc = 0;\n\t}\n\nerr:\n\tmutex_unlock(cmd_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_send_cmd_sync);\n\nint audioreach_graph_send_cmd_sync(struct q6apm_graph *graph, struct gpr_pkt *pkt,\n\t\t\t\t   uint32_t rsp_opcode)\n{\n\n\treturn audioreach_send_cmd_sync(graph->dev, NULL,  &graph->result, &graph->lock,\n\t\t\t\t\tgraph->port, &graph->cmd_wait, pkt, rsp_opcode);\n}\nEXPORT_SYMBOL_GPL(audioreach_graph_send_cmd_sync);\n\nstatic int audioreach_display_port_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t\t    struct audioreach_module *module,\n\t\t\t\t\t\t    struct audioreach_module_config *cfg)\n{\n\tstruct apm_display_port_module_intf_cfg *intf_cfg;\n\tstruct apm_module_frame_size_factor_cfg *fs_cfg;\n\tstruct apm_module_param_data *param_data;\n\tstruct apm_module_hw_ep_mf_cfg *hw_cfg;\n\tint ic_sz, ep_sz, fs_sz, dl_sz;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tic_sz = APM_DP_INTF_CFG_PSIZE;\n\tep_sz = APM_HW_EP_CFG_PSIZE;\n\tfs_sz = APM_FS_CFG_PSIZE;\n\tdl_sz = 0;\n\n\tpayload_size = ic_sz + ep_sz + fs_sz + dl_sz;\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\thw_cfg = p;\n\tparam_data = &hw_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_MF_CFG;\n\tparam_data->param_size = ep_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\thw_cfg->mf.sample_rate = cfg->sample_rate;\n\thw_cfg->mf.bit_width = cfg->bit_width;\n\thw_cfg->mf.num_channels = cfg->num_channels;\n\thw_cfg->mf.data_format = module->data_format;\n\tp += ep_sz;\n\n\tfs_cfg = p;\n\tparam_data = &fs_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_FRAME_SIZE_FACTOR;\n\tparam_data->param_size = fs_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tfs_cfg->frame_size_factor = 1;\n\tp += fs_sz;\n\n\tintf_cfg = p;\n\tparam_data = &intf_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_DISPLAY_PORT_INTF_CFG;\n\tparam_data->param_size = ic_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\tintf_cfg->cfg.channel_allocation = cfg->channel_allocation;\n\tintf_cfg->cfg.mst_idx = 0;\n\tintf_cfg->cfg.dptx_idx = cfg->dp_idx;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\n \nstatic int audioreach_codec_dma_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t\t struct audioreach_module *module,\n\t\t\t\t\t\t struct audioreach_module_config *cfg)\n{\n\tstruct apm_codec_dma_module_intf_cfg *intf_cfg;\n\tstruct apm_module_frame_size_factor_cfg *fs_cfg;\n\tstruct apm_module_hw_ep_power_mode_cfg *pm_cfg;\n\tstruct apm_module_param_data *param_data;\n\tstruct apm_module_hw_ep_mf_cfg *hw_cfg;\n\tint ic_sz, ep_sz, fs_sz, pm_sz, dl_sz;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tic_sz = APM_CDMA_INTF_CFG_PSIZE;\n\tep_sz = APM_HW_EP_CFG_PSIZE;\n\tfs_sz = APM_FS_CFG_PSIZE;\n\tpm_sz = APM_HW_EP_PMODE_CFG_PSIZE;\n\tdl_sz = 0;\n\n\tpayload_size = ic_sz + ep_sz + fs_sz + pm_sz + dl_sz;\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\thw_cfg = p;\n\tparam_data = &hw_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_MF_CFG;\n\tparam_data->param_size = ep_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\thw_cfg->mf.sample_rate = cfg->sample_rate;\n\thw_cfg->mf.bit_width = cfg->bit_width;\n\thw_cfg->mf.num_channels = cfg->num_channels;\n\thw_cfg->mf.data_format = module->data_format;\n\tp += ep_sz;\n\n\tfs_cfg = p;\n\tparam_data = &fs_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_FRAME_SIZE_FACTOR;\n\tparam_data->param_size = fs_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tfs_cfg->frame_size_factor = 1;\n\tp += fs_sz;\n\n\tintf_cfg = p;\n\tparam_data = &intf_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_CODEC_DMA_INTF_CFG;\n\tparam_data->param_size = ic_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\tintf_cfg->cfg.lpaif_type = module->hw_interface_type;\n\tintf_cfg->cfg.intf_index = module->hw_interface_idx;\n\tintf_cfg->cfg.active_channels_mask = (1 << cfg->num_channels) - 1;\n\tp += ic_sz;\n\n\tpm_cfg = p;\n\tparam_data = &pm_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_POWER_MODE_CFG;\n\tparam_data->param_size = pm_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tpm_cfg->power_mode.power_mode = 0;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint audioreach_send_u32_param(struct q6apm_graph *graph, struct audioreach_module *module,\n\t\t\t      uint32_t param_id, uint32_t param_val)\n{\n\tstruct apm_module_param_data *param_data;\n\tstruct gpr_pkt *pkt;\n\tuint32_t *param;\n\tint rc, payload_size;\n\tvoid *p;\n\n\tpayload_size = sizeof(uint32_t) + APM_MODULE_PARAM_DATA_SIZE;\n\tp = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(p))\n\t\treturn -ENOMEM;\n\n\tpkt = p;\n\tp = p + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = p;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = param_id;\n\tparam_data->param_size = sizeof(uint32_t);\n\n\tp = p + APM_MODULE_PARAM_DATA_SIZE;\n\tparam = p;\n\t*param = param_val;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_send_u32_param);\n\nstatic int audioreach_sal_limiter_enable(struct q6apm_graph *graph,\n\t\t\t\t\t struct audioreach_module *module, bool enable)\n{\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_SAL_LIMITER_ENABLE, enable);\n}\n\nstatic int audioreach_sal_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t   struct audioreach_module *module,\n\t\t\t\t\t   struct audioreach_module_config *cfg)\n{\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_SAL_OUTPUT_CFG,  cfg->bit_width);\n}\n\nstatic int audioreach_module_enable(struct q6apm_graph *graph,\n\t\t\t\t    struct audioreach_module *module,\n\t\t\t\t    bool enable)\n{\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_MODULE_ENABLE, enable);\n}\n\nstatic int audioreach_gapless_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t       struct audioreach_module *module,\n\t\t\t\t\t       struct audioreach_module_config *cfg)\n{\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_EARLY_EOS_DELAY,\n\t\t\t\t\t EARLY_EOS_DELAY_MS);\n}\n\nstatic int audioreach_mfc_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t   struct audioreach_module *module,\n\t\t\t\t\t   struct audioreach_module_config *cfg)\n{\n\tstruct apm_module_param_data *param_data;\n\tstruct param_id_mfc_media_format *media_format;\n\tuint32_t num_channels = cfg->num_channels;\n\tint payload_size;\n\tstruct gpr_pkt *pkt;\n\tint rc;\n\tvoid *p;\n\n\tpayload_size = APM_MFC_CFG_PSIZE(media_format, num_channels) +\n\t\tAPM_MODULE_PARAM_DATA_SIZE;\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = p;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_MFC_OUTPUT_MEDIA_FORMAT;\n\tparam_data->param_size = APM_MFC_CFG_PSIZE(media_format, num_channels);\n\tp = p + APM_MODULE_PARAM_DATA_SIZE;\n\tmedia_format = p;\n\n\tmedia_format->sample_rate = cfg->sample_rate;\n\tmedia_format->bit_width = cfg->bit_width;\n\tmedia_format->num_channels = cfg->num_channels;\n\n\tif (num_channels == 1) {\n\t\tmedia_format->channel_mapping[0] = PCM_CHANNEL_L;\n\t} else if (num_channels == 2) {\n\t\tmedia_format->channel_mapping[0] = PCM_CHANNEL_L;\n\t\tmedia_format->channel_mapping[1] = PCM_CHANNEL_R;\n\t}\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int audioreach_set_compr_media_format(struct media_format *media_fmt_hdr,\n\t\t\t\t\t     void *p, struct audioreach_module_config *mcfg)\n{\n\tstruct payload_media_fmt_aac_t *aac_cfg;\n\tstruct payload_media_fmt_pcm *mp3_cfg;\n\tstruct payload_media_fmt_flac_t *flac_cfg;\n\n\tswitch (mcfg->fmt) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\tmedia_fmt_hdr->data_format = DATA_FORMAT_RAW_COMPRESSED;\n\t\tmedia_fmt_hdr->fmt_id = MEDIA_FMT_ID_MP3;\n\t\tmedia_fmt_hdr->payload_size = 0;\n\t\tp = p + sizeof(*media_fmt_hdr);\n\t\tmp3_cfg = p;\n\t\tmp3_cfg->sample_rate = mcfg->sample_rate;\n\t\tmp3_cfg->bit_width = mcfg->bit_width;\n\t\tmp3_cfg->alignment = PCM_LSB_ALIGNED;\n\t\tmp3_cfg->bits_per_sample = mcfg->bit_width;\n\t\tmp3_cfg->q_factor = mcfg->bit_width - 1;\n\t\tmp3_cfg->endianness = PCM_LITTLE_ENDIAN;\n\t\tmp3_cfg->num_channels = mcfg->num_channels;\n\n\t\tif (mcfg->num_channels == 1) {\n\t\t\tmp3_cfg->channel_mapping[0] =  PCM_CHANNEL_L;\n\t\t} else if (mcfg->num_channels == 2) {\n\t\t\tmp3_cfg->channel_mapping[0] =  PCM_CHANNEL_L;\n\t\t\tmp3_cfg->channel_mapping[1] =  PCM_CHANNEL_R;\n\t\t}\n\t\tbreak;\n\tcase SND_AUDIOCODEC_AAC:\n\t\tmedia_fmt_hdr->data_format = DATA_FORMAT_RAW_COMPRESSED;\n\t\tmedia_fmt_hdr->fmt_id = MEDIA_FMT_ID_AAC;\n\t\tmedia_fmt_hdr->payload_size = sizeof(struct payload_media_fmt_aac_t);\n\t\tp = p + sizeof(*media_fmt_hdr);\n\t\taac_cfg = p;\n\t\taac_cfg->aac_fmt_flag = 0;\n\t\taac_cfg->audio_obj_type = 5;\n\t\taac_cfg->num_channels = mcfg->num_channels;\n\t\taac_cfg->total_size_of_PCE_bits = 0;\n\t\taac_cfg->sample_rate = mcfg->sample_rate;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_FLAC:\n\t\tmedia_fmt_hdr->data_format = DATA_FORMAT_RAW_COMPRESSED;\n\t\tmedia_fmt_hdr->fmt_id = MEDIA_FMT_ID_FLAC;\n\t\tmedia_fmt_hdr->payload_size = sizeof(struct payload_media_fmt_flac_t);\n\t\tp = p + sizeof(*media_fmt_hdr);\n\t\tflac_cfg = p;\n\t\tflac_cfg->sample_size = mcfg->codec.options.flac_d.sample_size;\n\t\tflac_cfg->num_channels = mcfg->num_channels;\n\t\tflac_cfg->min_blk_size = mcfg->codec.options.flac_d.min_blk_size;\n\t\tflac_cfg->max_blk_size = mcfg->codec.options.flac_d.max_blk_size;\n\t\tflac_cfg->sample_rate = mcfg->sample_rate;\n\t\tflac_cfg->min_frame_size = mcfg->codec.options.flac_d.min_frame_size;\n\t\tflac_cfg->max_frame_size = mcfg->codec.options.flac_d.max_frame_size;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint audioreach_compr_set_param(struct q6apm_graph *graph, struct audioreach_module_config *mcfg)\n{\n\tstruct media_format *header;\n\tstruct gpr_pkt *pkt;\n\tint iid, payload_size, rc;\n\tvoid *p;\n\n\tpayload_size = sizeof(struct apm_sh_module_media_fmt_cmd);\n\n\tiid = q6apm_graph_get_rx_shmem_module_iid(graph);\n\tpkt = audioreach_alloc_cmd_pkt(payload_size, DATA_CMD_WR_SH_MEM_EP_MEDIA_FORMAT,\n\t\t\t0, graph->port->id, iid);\n\n\tif (IS_ERR(pkt))\n\t\treturn -ENOMEM;\n\n\tp = (void *)pkt + GPR_HDR_SIZE;\n\theader = p;\n\trc = audioreach_set_compr_media_format(header, p, mcfg);\n\tif (rc) {\n\t\tkfree(pkt);\n\t\treturn rc;\n\t}\n\n\trc = gpr_send_port_pkt(graph->port, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_compr_set_param);\n\nstatic int audioreach_i2s_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t   struct audioreach_module *module,\n\t\t\t\t\t   struct audioreach_module_config *cfg)\n{\n\tstruct apm_module_frame_size_factor_cfg *fs_cfg;\n\tstruct apm_module_param_data *param_data;\n\tstruct apm_i2s_module_intf_cfg *intf_cfg;\n\tstruct apm_module_hw_ep_mf_cfg *hw_cfg;\n\tint ic_sz, ep_sz, fs_sz;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tic_sz = APM_I2S_INTF_CFG_PSIZE;\n\tep_sz = APM_HW_EP_CFG_PSIZE;\n\tfs_sz = APM_FS_CFG_PSIZE;\n\n\tpayload_size = ic_sz + ep_sz + fs_sz;\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\tintf_cfg = p;\n\n\tparam_data = &intf_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_I2S_INTF_CFG;\n\tparam_data->param_size = ic_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\tintf_cfg->cfg.intf_idx = module->hw_interface_idx;\n\tintf_cfg->cfg.sd_line_idx = module->sd_line_idx;\n\n\tswitch (cfg->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tintf_cfg->cfg.ws_src = CONFIG_I2S_WS_SRC_INTERNAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tintf_cfg->cfg.ws_src = CONFIG_I2S_WS_SRC_EXTERNAL;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tp += ic_sz;\n\thw_cfg = p;\n\tparam_data = &hw_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_MF_CFG;\n\tparam_data->param_size = ep_sz - APM_MODULE_PARAM_DATA_SIZE;\n\n\thw_cfg->mf.sample_rate = cfg->sample_rate;\n\thw_cfg->mf.bit_width = cfg->bit_width;\n\thw_cfg->mf.num_channels = cfg->num_channels;\n\thw_cfg->mf.data_format = module->data_format;\n\n\tp += ep_sz;\n\tfs_cfg = p;\n\tparam_data = &fs_cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_HW_EP_FRAME_SIZE_FACTOR;\n\tparam_data->param_size = fs_sz - APM_MODULE_PARAM_DATA_SIZE;\n\tfs_cfg->frame_size_factor = 1;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int audioreach_logging_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t       struct audioreach_module *module)\n{\n\tstruct apm_module_param_data *param_data;\n\tstruct data_logging_config *cfg;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tpayload_size = sizeof(*cfg) + APM_MODULE_PARAM_DATA_SIZE;\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = p;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_DATA_LOGGING_CONFIG;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\n\tp = p + APM_MODULE_PARAM_DATA_SIZE;\n\tcfg = p;\n\tcfg->log_code = module->log_code;\n\tcfg->log_tap_point_id = module->log_tap_point_id;\n\tcfg->mode = module->log_mode;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int audioreach_pcm_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t   struct audioreach_module *module,\n\t\t\t\t\t   struct audioreach_module_config *mcfg)\n{\n\tstruct payload_pcm_output_format_cfg *media_cfg;\n\tuint32_t num_channels = mcfg->num_channels;\n\tstruct apm_pcm_module_media_fmt_cmd *cfg;\n\tstruct apm_module_param_data *param_data;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\n\tif (num_channels > 2) {\n\t\tdev_err(graph->dev, \"Error: Invalid channels (%d)!\\n\", num_channels);\n\t\treturn -EINVAL;\n\t}\n\n\tpayload_size = APM_PCM_MODULE_FMT_CMD_PSIZE(num_channels);\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tcfg = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = &cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_PCM_OUTPUT_FORMAT_CFG;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\n\tcfg->header.data_format = DATA_FORMAT_FIXED_POINT;\n\tcfg->header.fmt_id = MEDIA_FMT_ID_PCM;\n\tcfg->header.payload_size = APM_PCM_OUT_FMT_CFG_PSIZE(media_cfg, num_channels);\n\n\tmedia_cfg = &cfg->media_cfg;\n\tmedia_cfg->alignment = PCM_LSB_ALIGNED;\n\tmedia_cfg->bit_width = mcfg->bit_width;\n\tmedia_cfg->endianness = PCM_LITTLE_ENDIAN;\n\tmedia_cfg->interleaved = module->interleave_type;\n\tmedia_cfg->num_channels = mcfg->num_channels;\n\tmedia_cfg->q_factor = mcfg->bit_width - 1;\n\tmedia_cfg->bits_per_sample = mcfg->bit_width;\n\n\tif (num_channels == 1) {\n\t\tmedia_cfg->channel_mapping[0] = PCM_CHANNEL_L;\n\t} else if (num_channels == 2) {\n\t\tmedia_cfg->channel_mapping[0] = PCM_CHANNEL_L;\n\t\tmedia_cfg->channel_mapping[1] = PCM_CHANNEL_R;\n\n\t}\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int audioreach_shmem_set_media_format(struct q6apm_graph *graph,\n\t\t\t\t\t     struct audioreach_module *module,\n\t\t\t\t\t     struct audioreach_module_config *mcfg)\n{\n\tuint32_t num_channels = mcfg->num_channels;\n\tstruct apm_module_param_data *param_data;\n\tstruct payload_media_fmt_pcm *cfg;\n\tstruct media_format *header;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tif (num_channels > 2) {\n\t\tdev_err(graph->dev, \"Error: Invalid channels (%d)!\\n\", num_channels);\n\t\treturn -EINVAL;\n\t}\n\n\tpayload_size = APM_SHMEM_FMT_CFG_PSIZE(num_channels) + APM_MODULE_PARAM_DATA_SIZE;\n\n\tpkt = audioreach_alloc_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0,\n\t\t\t\t     graph->port->id, module->instance_id);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = p;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_MEDIA_FORMAT;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\tp = p + APM_MODULE_PARAM_DATA_SIZE;\n\n\theader = p;\n\tif (mcfg->fmt == SND_AUDIOCODEC_PCM) {\n\t\theader->data_format = DATA_FORMAT_FIXED_POINT;\n\t\theader->fmt_id =  MEDIA_FMT_ID_PCM;\n\t\theader->payload_size = payload_size - sizeof(*header);\n\n\t\tp = p + sizeof(*header);\n\t\tcfg = p;\n\t\tcfg->sample_rate = mcfg->sample_rate;\n\t\tcfg->bit_width = mcfg->bit_width;\n\t\tcfg->alignment = PCM_LSB_ALIGNED;\n\t\tcfg->bits_per_sample = mcfg->bit_width;\n\t\tcfg->q_factor = mcfg->bit_width - 1;\n\t\tcfg->endianness = PCM_LITTLE_ENDIAN;\n\t\tcfg->num_channels = mcfg->num_channels;\n\n\t\tif (mcfg->num_channels == 1)\n\t\t\tcfg->channel_mapping[0] =  PCM_CHANNEL_L;\n\t\telse if (num_channels == 2) {\n\t\t\tcfg->channel_mapping[0] =  PCM_CHANNEL_L;\n\t\t\tcfg->channel_mapping[1] =  PCM_CHANNEL_R;\n\t\t}\n\t} else {\n\t\trc = audioreach_set_compr_media_format(header, p, mcfg);\n\t\tif (rc) {\n\t\t\tkfree(pkt);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = audioreach_graph_send_cmd_sync(graph, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint audioreach_gain_set_vol_ctrl(struct q6apm *apm, struct audioreach_module *module, int vol)\n{\n\tstruct param_id_vol_ctrl_master_gain *cfg;\n\tstruct apm_module_param_data *param_data;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\n\tpayload_size = sizeof(*cfg) + APM_MODULE_PARAM_DATA_SIZE;\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = p;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_VOL_CTRL_MASTER_GAIN;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\n\tp = p + APM_MODULE_PARAM_DATA_SIZE;\n\tcfg = p;\n\tcfg->master_gain =  vol;\n\trc = q6apm_send_cmd_sync(apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_gain_set_vol_ctrl);\n\nstatic int audioreach_gain_set(struct q6apm_graph *graph, struct audioreach_module *module)\n{\n\tstruct apm_module_param_data *param_data;\n\tstruct apm_gain_module_cfg *cfg;\n\tint rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\n\tpayload_size = APM_GAIN_CFG_PSIZE;\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, APM_CMD_SET_CFG, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tcfg = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = &cfg->param_data;\n\tparam_data->module_instance_id = module->instance_id;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = APM_PARAM_ID_GAIN;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\n\tcfg->gain_cfg.gain = module->gain;\n\n\trc = q6apm_send_cmd_sync(graph->apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint audioreach_set_media_format(struct q6apm_graph *graph, struct audioreach_module *module,\n\t\t\t\tstruct audioreach_module_config *cfg)\n{\n\tint rc;\n\n\tswitch (module->module_id) {\n\tcase MODULE_ID_DATA_LOGGING:\n\t\trc = audioreach_module_enable(graph, module, true);\n\t\tif (!rc)\n\t\t\trc = audioreach_logging_set_media_format(graph, module);\n\t\tbreak;\n\tcase MODULE_ID_PCM_DEC:\n\tcase MODULE_ID_PCM_ENC:\n\tcase MODULE_ID_PCM_CNV:\n\tcase MODULE_ID_PLACEHOLDER_DECODER:\n\tcase MODULE_ID_PLACEHOLDER_ENCODER:\n\t\trc = audioreach_pcm_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_DISPLAY_PORT_SINK:\n\t\trc = audioreach_display_port_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_I2S_SOURCE:\n\tcase MODULE_ID_I2S_SINK:\n\t\trc = audioreach_i2s_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_WR_SHARED_MEM_EP:\n\t\trc = audioreach_shmem_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_GAIN:\n\t\trc = audioreach_gain_set(graph, module);\n\t\tbreak;\n\tcase MODULE_ID_CODEC_DMA_SINK:\n\tcase MODULE_ID_CODEC_DMA_SOURCE:\n\t\trc = audioreach_codec_dma_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_SAL:\n\t\trc = audioreach_sal_set_media_format(graph, module, cfg);\n\t\tif (!rc)\n\t\t\trc = audioreach_sal_limiter_enable(graph, module, true);\n\t\tbreak;\n\tcase MODULE_ID_MFC:\n\t\trc = audioreach_mfc_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tcase MODULE_ID_GAPLESS:\n\t\trc = audioreach_gapless_set_media_format(graph, module, cfg);\n\t\tbreak;\n\tdefault:\n\t\trc = 0;\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_set_media_format);\n\nvoid audioreach_graph_free_buf(struct q6apm_graph *graph)\n{\n\tstruct audioreach_graph_data *port;\n\n\tmutex_lock(&graph->lock);\n\tport = &graph->rx_data;\n\tport->num_periods = 0;\n\tkfree(port->buf);\n\tport->buf = NULL;\n\n\tport = &graph->tx_data;\n\tport->num_periods = 0;\n\tkfree(port->buf);\n\tport->buf = NULL;\n\tmutex_unlock(&graph->lock);\n}\nEXPORT_SYMBOL_GPL(audioreach_graph_free_buf);\n\nint audioreach_map_memory_regions(struct q6apm_graph *graph, unsigned int dir, size_t period_sz,\n\t\t\t\t  unsigned int periods, bool is_contiguous)\n{\n\tstruct apm_shared_map_region_payload *mregions;\n\tstruct apm_cmd_shared_mem_map_regions *cmd;\n\tuint32_t num_regions, buf_sz, payload_size;\n\tstruct audioreach_graph_data *data;\n\tstruct gpr_pkt *pkt;\n\tvoid *p;\n\tint rc, i;\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdata = &graph->rx_data;\n\telse\n\t\tdata = &graph->tx_data;\n\n\tif (is_contiguous) {\n\t\tnum_regions = 1;\n\t\tbuf_sz = period_sz * periods;\n\t} else {\n\t\tbuf_sz = period_sz;\n\t\tnum_regions = periods;\n\t}\n\n\t \n\tbuf_sz = ALIGN(buf_sz, 4096);\n\n\tpayload_size = sizeof(*cmd) + (sizeof(*mregions) * num_regions);\n\n\tpkt = audioreach_alloc_apm_pkt(payload_size, APM_CMD_SHARED_MEM_MAP_REGIONS, dir,\n\t\t\t\t     graph->port->id);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tp = (void *)pkt + GPR_HDR_SIZE;\n\tcmd = p;\n\tcmd->mem_pool_id = APM_MEMORY_MAP_SHMEM8_4K_POOL;\n\tcmd->num_regions = num_regions;\n\n\tcmd->property_flag = 0x0;\n\n\tmregions = p + sizeof(*cmd);\n\n\tmutex_lock(&graph->lock);\n\n\tfor (i = 0; i < num_regions; i++) {\n\t\tstruct audio_buffer *ab;\n\n\t\tab = &data->buf[i];\n\t\tmregions->shm_addr_lsw = lower_32_bits(ab->phys);\n\t\tmregions->shm_addr_msw = upper_32_bits(ab->phys);\n\t\tmregions->mem_size_bytes = buf_sz;\n\t\t++mregions;\n\t}\n\tmutex_unlock(&graph->lock);\n\n\trc = audioreach_graph_send_cmd_sync(graph, pkt, APM_CMD_RSP_SHARED_MEM_MAP_REGIONS);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_map_memory_regions);\n\nint audioreach_shared_memory_send_eos(struct q6apm_graph *graph)\n{\n\tstruct data_cmd_wr_sh_mem_ep_eos *eos;\n\tstruct gpr_pkt *pkt;\n\tint rc = 0, iid;\n\n\tiid = q6apm_graph_get_rx_shmem_module_iid(graph);\n\tpkt = audioreach_alloc_cmd_pkt(sizeof(*eos), DATA_CMD_WR_SH_MEM_EP_EOS, 0,\n\t\t\t\t       graph->port->id, iid);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\teos = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\teos->policy = WR_SH_MEM_EP_EOS_POLICY_LAST;\n\n\trc = gpr_send_port_pkt(graph->port, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(audioreach_shared_memory_send_eos);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}