{
  "module_name": "q6apm.c",
  "hash_id": "fce0f19910354b63986226e5ca585d4fd1103283599feac0f0ef2df76bfdf6ba",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6apm.c",
  "human_readable_source": "\n\n\n#include <dt-bindings/soc/qcom,gpr.h>\n#include <linux/delay.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/apr.h>\n#include <linux/wait.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm.h>\n#include \"audioreach.h\"\n#include \"q6apm.h\"\n\n \nstruct apm_graph_mgmt_cmd {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_sub_graphs;\n\tuint32_t sub_graph_id_list[];\n} __packed;\n\n#define APM_GRAPH_MGMT_PSIZE(p, n) ALIGN(struct_size(p, sub_graph_id_list, n), 8)\n\nstatic struct q6apm *g_apm;\n\nint q6apm_send_cmd_sync(struct q6apm *apm, struct gpr_pkt *pkt, uint32_t rsp_opcode)\n{\n\tgpr_device_t *gdev = apm->gdev;\n\n\treturn audioreach_send_cmd_sync(&gdev->dev, gdev, &apm->result, &apm->lock,\n\t\t\t\t\tNULL, &apm->wait, pkt, rsp_opcode);\n}\n\nstatic struct audioreach_graph *q6apm_get_audioreach_graph(struct q6apm *apm, uint32_t graph_id)\n{\n\tstruct audioreach_graph_info *info;\n\tstruct audioreach_graph *graph;\n\tint id;\n\n\tmutex_lock(&apm->lock);\n\tgraph = idr_find(&apm->graph_idr, graph_id);\n\tmutex_unlock(&apm->lock);\n\n\tif (graph) {\n\t\tkref_get(&graph->refcount);\n\t\treturn graph;\n\t}\n\n\tinfo = idr_find(&apm->graph_info_idr, graph_id);\n\n\tif (!info)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tgraph = kzalloc(sizeof(*graph), GFP_KERNEL);\n\tif (!graph)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgraph->apm = apm;\n\tgraph->info = info;\n\tgraph->id = graph_id;\n\n\tgraph->graph = audioreach_alloc_graph_pkt(apm, info);\n\tif (IS_ERR(graph->graph)) {\n\t\tvoid *err = graph->graph;\n\n\t\tkfree(graph);\n\t\treturn ERR_CAST(err);\n\t}\n\n\tmutex_lock(&apm->lock);\n\tid = idr_alloc(&apm->graph_idr, graph, graph_id, graph_id + 1, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(apm->dev, \"Unable to allocate graph id (%d)\\n\", graph_id);\n\t\tkfree(graph->graph);\n\t\tkfree(graph);\n\t\tmutex_unlock(&apm->lock);\n\t\treturn ERR_PTR(id);\n\t}\n\tmutex_unlock(&apm->lock);\n\n\tkref_init(&graph->refcount);\n\n\tq6apm_send_cmd_sync(apm, graph->graph, 0);\n\n\treturn graph;\n}\n\nstatic int audioreach_graph_mgmt_cmd(struct audioreach_graph *graph, uint32_t opcode)\n{\n\tstruct audioreach_graph_info *info = graph->info;\n\tint num_sub_graphs = info->num_sub_graphs;\n\tstruct apm_module_param_data *param_data;\n\tstruct apm_graph_mgmt_cmd *mgmt_cmd;\n\tstruct audioreach_sub_graph *sg;\n\tstruct q6apm *apm = graph->apm;\n\tint i = 0, rc, payload_size;\n\tstruct gpr_pkt *pkt;\n\n\tpayload_size = APM_GRAPH_MGMT_PSIZE(mgmt_cmd, num_sub_graphs);\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(payload_size, opcode, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tmgmt_cmd = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tmgmt_cmd->num_sub_graphs = num_sub_graphs;\n\n\tparam_data = &mgmt_cmd->param_data;\n\tparam_data->module_instance_id = APM_MODULE_INSTANCE_ID;\n\tparam_data->param_id = APM_PARAM_ID_SUB_GRAPH_LIST;\n\tparam_data->param_size = payload_size - APM_MODULE_PARAM_DATA_SIZE;\n\n\tlist_for_each_entry(sg, &info->sg_list, node)\n\t\tmgmt_cmd->sub_graph_id_list[i++] = sg->sub_graph_id;\n\n\trc = q6apm_send_cmd_sync(apm, pkt, 0);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic void q6apm_put_audioreach_graph(struct kref *ref)\n{\n\tstruct audioreach_graph *graph;\n\tstruct q6apm *apm;\n\n\tgraph = container_of(ref, struct audioreach_graph, refcount);\n\tapm = graph->apm;\n\n\taudioreach_graph_mgmt_cmd(graph, APM_CMD_GRAPH_CLOSE);\n\n\tmutex_lock(&apm->lock);\n\tgraph = idr_remove(&apm->graph_idr, graph->id);\n\tmutex_unlock(&apm->lock);\n\n\tkfree(graph->graph);\n\tkfree(graph);\n}\n\n\nstatic int q6apm_get_apm_state(struct q6apm *apm)\n{\n\tstruct gpr_pkt *pkt;\n\n\tpkt = audioreach_alloc_apm_cmd_pkt(0, APM_CMD_GET_SPF_STATE, 0);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tq6apm_send_cmd_sync(apm, pkt, APM_CMD_RSP_GET_SPF_STATE);\n\n\tkfree(pkt);\n\n\treturn apm->state;\n}\n\nbool q6apm_is_adsp_ready(void)\n{\n\tif (g_apm)\n\t\treturn q6apm_get_apm_state(g_apm);\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(q6apm_is_adsp_ready);\n\nstatic struct audioreach_module *__q6apm_find_module_by_mid(struct q6apm *apm,\n\t\t\t\t\t\t    struct audioreach_graph_info *info,\n\t\t\t\t\t\t    uint32_t mid)\n{\n\tstruct audioreach_container *container;\n\tstruct audioreach_sub_graph *sgs;\n\tstruct audioreach_module *module;\n\n\tlist_for_each_entry(sgs, &info->sg_list, node) {\n\t\tlist_for_each_entry(container, &sgs->container_list, node) {\n\t\t\tlist_for_each_entry(module, &container->modules_list, node) {\n\t\t\t\tif (mid == module->module_id)\n\t\t\t\t\treturn module;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nint q6apm_graph_media_format_shmem(struct q6apm_graph *graph,\n\t\t\t\t   struct audioreach_module_config *cfg)\n{\n\tstruct audioreach_module *module;\n\n\tif (cfg->direction == SNDRV_PCM_STREAM_CAPTURE)\n\t\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_RD_SHARED_MEM_EP);\n\telse\n\t\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_WR_SHARED_MEM_EP);\n\n\tif (!module)\n\t\treturn -ENODEV;\n\n\taudioreach_set_media_format(graph, module, cfg);\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_media_format_shmem);\n\nint q6apm_map_memory_regions(struct q6apm_graph *graph, unsigned int dir, phys_addr_t phys,\n\t\t\t     size_t period_sz, unsigned int periods)\n{\n\tstruct audioreach_graph_data *data;\n\tstruct audio_buffer *buf;\n\tint cnt;\n\tint rc;\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdata = &graph->rx_data;\n\telse\n\t\tdata = &graph->tx_data;\n\n\tmutex_lock(&graph->lock);\n\n\tif (data->buf) {\n\t\tmutex_unlock(&graph->lock);\n\t\treturn 0;\n\t}\n\n\tbuf = kzalloc(((sizeof(struct audio_buffer)) * periods), GFP_KERNEL);\n\tif (!buf) {\n\t\tmutex_unlock(&graph->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdata = &graph->rx_data;\n\telse\n\t\tdata = &graph->tx_data;\n\n\tdata->buf = buf;\n\n\tbuf[0].phys = phys;\n\tbuf[0].size = period_sz;\n\n\tfor (cnt = 1; cnt < periods; cnt++) {\n\t\tif (period_sz > 0) {\n\t\t\tbuf[cnt].phys = buf[0].phys + (cnt * period_sz);\n\t\t\tbuf[cnt].size = period_sz;\n\t\t}\n\t}\n\tdata->num_periods = periods;\n\n\tmutex_unlock(&graph->lock);\n\n\trc = audioreach_map_memory_regions(graph, dir, period_sz, periods, 1);\n\tif (rc < 0) {\n\t\tdev_err(graph->dev, \"Memory_map_regions failed\\n\");\n\t\taudioreach_graph_free_buf(graph);\n\t}\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6apm_map_memory_regions);\n\nint q6apm_unmap_memory_regions(struct q6apm_graph *graph, unsigned int dir)\n{\n\tstruct apm_cmd_shared_mem_unmap_regions *cmd;\n\tstruct audioreach_graph_data *data;\n\tstruct gpr_pkt *pkt;\n\tint rc;\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdata = &graph->rx_data;\n\telse\n\t\tdata = &graph->tx_data;\n\n\tif (!data->mem_map_handle)\n\t\treturn 0;\n\n\tpkt = audioreach_alloc_apm_pkt(sizeof(*cmd), APM_CMD_SHARED_MEM_UNMAP_REGIONS, dir,\n\t\t\t\t     graph->port->id);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tcmd = (void *)pkt + GPR_HDR_SIZE;\n\tcmd->mem_map_handle = data->mem_map_handle;\n\n\trc = audioreach_graph_send_cmd_sync(graph, pkt, APM_CMD_SHARED_MEM_UNMAP_REGIONS);\n\tkfree(pkt);\n\n\taudioreach_graph_free_buf(graph);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6apm_unmap_memory_regions);\n\nint q6apm_remove_initial_silence(struct device *dev, struct q6apm_graph *graph, uint32_t samples)\n{\n\tstruct audioreach_module *module;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_PLACEHOLDER_DECODER);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_REMOVE_INITIAL_SILENCE, samples);\n}\nEXPORT_SYMBOL_GPL(q6apm_remove_initial_silence);\n\nint q6apm_remove_trailing_silence(struct device *dev, struct q6apm_graph *graph, uint32_t samples)\n{\n\tstruct audioreach_module *module;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_PLACEHOLDER_DECODER);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_REMOVE_TRAILING_SILENCE, samples);\n}\nEXPORT_SYMBOL_GPL(q6apm_remove_trailing_silence);\n\nint q6apm_enable_compress_module(struct device *dev, struct q6apm_graph *graph, bool en)\n{\n\tstruct audioreach_module *module;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_PLACEHOLDER_DECODER);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_MODULE_ENABLE, en);\n}\nEXPORT_SYMBOL_GPL(q6apm_enable_compress_module);\n\nint q6apm_set_real_module_id(struct device *dev, struct q6apm_graph *graph,\n\t\t\t     uint32_t codec_id)\n{\n\tstruct audioreach_module *module;\n\tuint32_t module_id;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_PLACEHOLDER_DECODER);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\tswitch (codec_id) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\tmodule_id = MODULE_ID_MP3_DECODE;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_AAC:\n\t\tmodule_id = MODULE_ID_AAC_DEC;\n\t\tbreak;\n\tcase SND_AUDIOCODEC_FLAC:\n\t\tmodule_id = MODULE_ID_FLAC_DEC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn audioreach_send_u32_param(graph, module, PARAM_ID_REAL_MODULE_ID,\n\t\t\t\t\t module_id);\n}\nEXPORT_SYMBOL_GPL(q6apm_set_real_module_id);\n\nint q6apm_graph_media_format_pcm(struct q6apm_graph *graph, struct audioreach_module_config *cfg)\n{\n\tstruct audioreach_graph_info *info = graph->info;\n\tstruct audioreach_sub_graph *sgs;\n\tstruct audioreach_container *container;\n\tstruct audioreach_module *module;\n\n\tlist_for_each_entry(sgs, &info->sg_list, node) {\n\t\tlist_for_each_entry(container, &sgs->container_list, node) {\n\t\t\tlist_for_each_entry(module, &container->modules_list, node) {\n\t\t\t\tif ((module->module_id == MODULE_ID_WR_SHARED_MEM_EP) ||\n\t\t\t\t\t(module->module_id == MODULE_ID_RD_SHARED_MEM_EP))\n\t\t\t\t\tcontinue;\n\n\t\t\t\taudioreach_set_media_format(graph, module, cfg);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_media_format_pcm);\n\nstatic int q6apm_graph_get_tx_shmem_module_iid(struct q6apm_graph *graph)\n{\n\tstruct audioreach_module *module;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_RD_SHARED_MEM_EP);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\treturn module->instance_id;\n\n}\n\nint q6apm_graph_get_rx_shmem_module_iid(struct q6apm_graph *graph)\n{\n\tstruct audioreach_module *module;\n\n\tmodule = q6apm_find_module_by_mid(graph, MODULE_ID_WR_SHARED_MEM_EP);\n\tif (!module)\n\t\treturn -ENODEV;\n\n\treturn module->instance_id;\n\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_get_rx_shmem_module_iid);\n\nint q6apm_write_async(struct q6apm_graph *graph, uint32_t len, uint32_t msw_ts,\n\t\t      uint32_t lsw_ts, uint32_t wflags)\n{\n\tstruct apm_data_cmd_wr_sh_mem_ep_data_buffer_v2 *write_buffer;\n\tstruct audio_buffer *ab;\n\tstruct gpr_pkt *pkt;\n\tint rc, iid;\n\n\tiid = q6apm_graph_get_rx_shmem_module_iid(graph);\n\tpkt = audioreach_alloc_pkt(sizeof(*write_buffer), DATA_CMD_WR_SH_MEM_EP_DATA_BUFFER_V2,\n\t\t\t\t   graph->rx_data.dsp_buf | (len << APM_WRITE_TOKEN_LEN_SHIFT),\n\t\t\t\t   graph->port->id, iid);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\twrite_buffer = (void *)pkt + GPR_HDR_SIZE;\n\n\tmutex_lock(&graph->lock);\n\tab = &graph->rx_data.buf[graph->rx_data.dsp_buf];\n\n\twrite_buffer->buf_addr_lsw = lower_32_bits(ab->phys);\n\twrite_buffer->buf_addr_msw = upper_32_bits(ab->phys);\n\twrite_buffer->buf_size = len;\n\twrite_buffer->timestamp_lsw = lsw_ts;\n\twrite_buffer->timestamp_msw = msw_ts;\n\twrite_buffer->mem_map_handle = graph->rx_data.mem_map_handle;\n\twrite_buffer->flags = wflags;\n\n\tgraph->rx_data.dsp_buf++;\n\n\tif (graph->rx_data.dsp_buf >= graph->rx_data.num_periods)\n\t\tgraph->rx_data.dsp_buf = 0;\n\n\tmutex_unlock(&graph->lock);\n\n\trc = gpr_send_port_pkt(graph->port, pkt);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6apm_write_async);\n\nint q6apm_read(struct q6apm_graph *graph)\n{\n\tstruct data_cmd_rd_sh_mem_ep_data_buffer_v2 *read_buffer;\n\tstruct audioreach_graph_data *port;\n\tstruct audio_buffer *ab;\n\tstruct gpr_pkt *pkt;\n\tint rc, iid;\n\n\tiid = q6apm_graph_get_tx_shmem_module_iid(graph);\n\tpkt = audioreach_alloc_pkt(sizeof(*read_buffer), DATA_CMD_RD_SH_MEM_EP_DATA_BUFFER_V2,\n\t\t\t\t   graph->tx_data.dsp_buf, graph->port->id, iid);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\tread_buffer = (void *)pkt + GPR_HDR_SIZE;\n\n\tmutex_lock(&graph->lock);\n\tport = &graph->tx_data;\n\tab = &port->buf[port->dsp_buf];\n\n\tread_buffer->buf_addr_lsw = lower_32_bits(ab->phys);\n\tread_buffer->buf_addr_msw = upper_32_bits(ab->phys);\n\tread_buffer->mem_map_handle = port->mem_map_handle;\n\tread_buffer->buf_size = ab->size;\n\n\tport->dsp_buf++;\n\n\tif (port->dsp_buf >= port->num_periods)\n\t\tport->dsp_buf = 0;\n\n\tmutex_unlock(&graph->lock);\n\n\trc = gpr_send_port_pkt(graph->port, pkt);\n\tkfree(pkt);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(q6apm_read);\n\nstatic int graph_callback(struct gpr_resp_pkt *data, void *priv, int op)\n{\n\tstruct data_cmd_rsp_rd_sh_mem_ep_data_buffer_done_v2 *rd_done;\n\tstruct data_cmd_rsp_wr_sh_mem_ep_data_buffer_done_v2 *done;\n\tstruct apm_cmd_rsp_shared_mem_map_regions *rsp;\n\tstruct gpr_ibasic_rsp_result_t *result;\n\tstruct q6apm_graph *graph = priv;\n\tstruct gpr_hdr *hdr = &data->hdr;\n\tstruct device *dev = graph->dev;\n\tuint32_t client_event;\n\tphys_addr_t phys;\n\tint token;\n\n\tresult = data->payload;\n\n\tswitch (hdr->opcode) {\n\tcase DATA_CMD_RSP_WR_SH_MEM_EP_DATA_BUFFER_DONE_V2:\n\t\tif (!graph->ar_graph)\n\t\t\tbreak;\n\t\tclient_event = APM_CLIENT_EVENT_DATA_WRITE_DONE;\n\t\tmutex_lock(&graph->lock);\n\t\ttoken = hdr->token & APM_WRITE_TOKEN_MASK;\n\n\t\tdone = data->payload;\n\t\tphys = graph->rx_data.buf[token].phys;\n\t\tmutex_unlock(&graph->lock);\n\n\t\tif (lower_32_bits(phys) == done->buf_addr_lsw &&\n\t\t    upper_32_bits(phys) == done->buf_addr_msw) {\n\t\t\tgraph->result.opcode = hdr->opcode;\n\t\t\tgraph->result.status = done->status;\n\t\t\tif (graph->cb)\n\t\t\t\tgraph->cb(client_event, hdr->token, data->payload, graph->priv);\n\t\t} else {\n\t\t\tdev_err(dev, \"WR BUFF Unexpected addr %08x-%08x\\n\", done->buf_addr_lsw,\n\t\t\t\tdone->buf_addr_msw);\n\t\t}\n\n\t\tbreak;\n\tcase APM_CMD_RSP_SHARED_MEM_MAP_REGIONS:\n\t\tgraph->result.opcode = hdr->opcode;\n\t\tgraph->result.status = 0;\n\t\trsp = data->payload;\n\n\t\tif (hdr->token == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tgraph->rx_data.mem_map_handle = rsp->mem_map_handle;\n\t\telse\n\t\t\tgraph->tx_data.mem_map_handle = rsp->mem_map_handle;\n\n\t\twake_up(&graph->cmd_wait);\n\t\tbreak;\n\tcase DATA_CMD_RSP_RD_SH_MEM_EP_DATA_BUFFER_V2:\n\t\tif (!graph->ar_graph)\n\t\t\tbreak;\n\t\tclient_event = APM_CLIENT_EVENT_DATA_READ_DONE;\n\t\tmutex_lock(&graph->lock);\n\t\trd_done = data->payload;\n\t\tphys = graph->tx_data.buf[hdr->token].phys;\n\t\tmutex_unlock(&graph->lock);\n\n\t\tif (upper_32_bits(phys) == rd_done->buf_addr_msw &&\n\t\t    lower_32_bits(phys) == rd_done->buf_addr_lsw) {\n\t\t\tgraph->result.opcode = hdr->opcode;\n\t\t\tgraph->result.status = rd_done->status;\n\t\t\tif (graph->cb)\n\t\t\t\tgraph->cb(client_event, hdr->token, data->payload, graph->priv);\n\t\t} else {\n\t\t\tdev_err(dev, \"RD BUFF Unexpected addr %08x-%08x\\n\", rd_done->buf_addr_lsw,\n\t\t\t\trd_done->buf_addr_msw);\n\t\t}\n\t\tbreak;\n\tcase DATA_CMD_WR_SH_MEM_EP_EOS_RENDERED:\n\t\tclient_event = APM_CLIENT_EVENT_CMD_EOS_DONE;\n\t\tif (graph->cb)\n\t\t\tgraph->cb(client_event, hdr->token, data->payload, graph->priv);\n\t\tbreak;\n\tcase GPR_BASIC_RSP_RESULT:\n\t\tswitch (result->opcode) {\n\t\tcase APM_CMD_SHARED_MEM_UNMAP_REGIONS:\n\t\t\tgraph->result.opcode = result->opcode;\n\t\t\tgraph->result.status = 0;\n\t\t\tif (hdr->token == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tgraph->rx_data.mem_map_handle = 0;\n\t\t\telse\n\t\t\t\tgraph->tx_data.mem_map_handle = 0;\n\n\t\t\twake_up(&graph->cmd_wait);\n\t\t\tbreak;\n\t\tcase APM_CMD_SHARED_MEM_MAP_REGIONS:\n\t\tcase DATA_CMD_WR_SH_MEM_EP_MEDIA_FORMAT:\n\t\tcase APM_CMD_SET_CFG:\n\t\t\tgraph->result.opcode = result->opcode;\n\t\t\tgraph->result.status = result->status;\n\t\t\tif (result->status)\n\t\t\t\tdev_err(dev, \"Error (%d) Processing 0x%08x cmd\\n\",\n\t\t\t\t\tresult->status, result->opcode);\n\t\t\twake_up(&graph->cmd_wait);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstruct q6apm_graph *q6apm_graph_open(struct device *dev, q6apm_cb cb,\n\t\t\t\t     void *priv, int graph_id)\n{\n\tstruct q6apm *apm = dev_get_drvdata(dev->parent);\n\tstruct audioreach_graph *ar_graph;\n\tstruct q6apm_graph *graph;\n\tint ret;\n\n\tar_graph = q6apm_get_audioreach_graph(apm, graph_id);\n\tif (IS_ERR(ar_graph)) {\n\t\tdev_err(dev, \"No graph found with id %d\\n\", graph_id);\n\t\treturn ERR_CAST(ar_graph);\n\t}\n\n\tgraph = kzalloc(sizeof(*graph), GFP_KERNEL);\n\tif (!graph) {\n\t\tret = -ENOMEM;\n\t\tgoto put_ar_graph;\n\t}\n\n\tgraph->apm = apm;\n\tgraph->priv = priv;\n\tgraph->cb = cb;\n\tgraph->info = ar_graph->info;\n\tgraph->ar_graph = ar_graph;\n\tgraph->id = ar_graph->id;\n\tgraph->dev = dev;\n\n\tmutex_init(&graph->lock);\n\tinit_waitqueue_head(&graph->cmd_wait);\n\n\tgraph->port = gpr_alloc_port(apm->gdev, dev, graph_callback, graph);\n\tif (IS_ERR(graph->port)) {\n\t\tret = PTR_ERR(graph->port);\n\t\tgoto free_graph;\n\t}\n\n\treturn graph;\n\nfree_graph:\n\tkfree(graph);\nput_ar_graph:\n\tkref_put(&ar_graph->refcount, q6apm_put_audioreach_graph);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_open);\n\nint q6apm_graph_close(struct q6apm_graph *graph)\n{\n\tstruct audioreach_graph *ar_graph = graph->ar_graph;\n\n\tgraph->ar_graph = NULL;\n\tkref_put(&ar_graph->refcount, q6apm_put_audioreach_graph);\n\tgpr_free_port(graph->port);\n\tkfree(graph);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_close);\n\nint q6apm_graph_prepare(struct q6apm_graph *graph)\n{\n\treturn audioreach_graph_mgmt_cmd(graph->ar_graph, APM_CMD_GRAPH_PREPARE);\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_prepare);\n\nint q6apm_graph_start(struct q6apm_graph *graph)\n{\n\tstruct audioreach_graph *ar_graph = graph->ar_graph;\n\tint ret = 0;\n\n\tif (ar_graph->start_count == 0)\n\t\tret = audioreach_graph_mgmt_cmd(ar_graph, APM_CMD_GRAPH_START);\n\n\tar_graph->start_count++;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_start);\n\nint q6apm_graph_stop(struct q6apm_graph *graph)\n{\n\tstruct audioreach_graph *ar_graph = graph->ar_graph;\n\n\tif (--ar_graph->start_count > 0)\n\t\treturn 0;\n\n\treturn audioreach_graph_mgmt_cmd(ar_graph, APM_CMD_GRAPH_STOP);\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_stop);\n\nint q6apm_graph_flush(struct q6apm_graph *graph)\n{\n\treturn audioreach_graph_mgmt_cmd(graph->ar_graph, APM_CMD_GRAPH_FLUSH);\n}\nEXPORT_SYMBOL_GPL(q6apm_graph_flush);\n\nstatic int q6apm_audio_probe(struct snd_soc_component *component)\n{\n\treturn audioreach_tplg_init(component);\n}\n\nstatic void q6apm_audio_remove(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_tplg_component_remove(component);\n}\n\n#define APM_AUDIO_DRV_NAME \"q6apm-audio\"\n\nstatic const struct snd_soc_component_driver q6apm_audio_component = {\n\t.name\t\t= APM_AUDIO_DRV_NAME,\n\t.probe\t\t= q6apm_audio_probe,\n\t.remove\t\t= q6apm_audio_remove,\n};\n\nstatic int apm_probe(gpr_device_t *gdev)\n{\n\tstruct device *dev = &gdev->dev;\n\tstruct q6apm *apm;\n\tint ret;\n\n\tapm = devm_kzalloc(dev, sizeof(*apm), GFP_KERNEL);\n\tif (!apm)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, apm);\n\n\tmutex_init(&apm->lock);\n\tapm->dev = dev;\n\tapm->gdev = gdev;\n\tinit_waitqueue_head(&apm->wait);\n\n\tINIT_LIST_HEAD(&apm->widget_list);\n\tidr_init(&apm->graph_idr);\n\tidr_init(&apm->graph_info_idr);\n\tidr_init(&apm->sub_graphs_idr);\n\tidr_init(&apm->containers_idr);\n\n\tidr_init(&apm->modules_idr);\n\n\tg_apm = apm;\n\n\tq6apm_get_apm_state(apm);\n\n\tret = devm_snd_soc_register_component(dev, &q6apm_audio_component, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register q6apm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn of_platform_populate(dev->of_node, NULL, NULL, dev);\n}\n\nstruct audioreach_module *q6apm_find_module_by_mid(struct q6apm_graph *graph, uint32_t mid)\n{\n\tstruct audioreach_graph_info *info = graph->info;\n\tstruct q6apm *apm = graph->apm;\n\n\treturn __q6apm_find_module_by_mid(apm, info, mid);\n\n}\n\nstatic int apm_callback(struct gpr_resp_pkt *data, void *priv, int op)\n{\n\tgpr_device_t *gdev = priv;\n\tstruct q6apm *apm = dev_get_drvdata(&gdev->dev);\n\tstruct device *dev = &gdev->dev;\n\tstruct gpr_ibasic_rsp_result_t *result;\n\tstruct gpr_hdr *hdr = &data->hdr;\n\n\tresult = data->payload;\n\n\tswitch (hdr->opcode) {\n\tcase APM_CMD_RSP_GET_SPF_STATE:\n\t\tapm->result.opcode = hdr->opcode;\n\t\tapm->result.status = 0;\n\t\t \n\t\tapm->state = result->opcode;\n\t\twake_up(&apm->wait);\n\t\tbreak;\n\tcase GPR_BASIC_RSP_RESULT:\n\t\tswitch (result->opcode) {\n\t\tcase APM_CMD_GRAPH_START:\n\t\tcase APM_CMD_GRAPH_OPEN:\n\t\tcase APM_CMD_GRAPH_PREPARE:\n\t\tcase APM_CMD_GRAPH_CLOSE:\n\t\tcase APM_CMD_GRAPH_FLUSH:\n\t\tcase APM_CMD_GRAPH_STOP:\n\t\tcase APM_CMD_SET_CFG:\n\t\t\tapm->result.opcode = result->opcode;\n\t\t\tapm->result.status = result->status;\n\t\t\tif (result->status)\n\t\t\t\tdev_err(dev, \"Error (%d) Processing 0x%08x cmd\\n\", result->status,\n\t\t\t\t\tresult->opcode);\n\t\t\twake_up(&apm->wait);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id apm_device_id[]  = {\n\t{ .compatible = \"qcom,q6apm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, apm_device_id);\n#endif\n\nstatic gpr_driver_t apm_driver = {\n\t.probe = apm_probe,\n\t.gpr_callback = apm_callback,\n\t.driver = {\n\t\t.name = \"qcom-apm\",\n\t\t.of_match_table = of_match_ptr(apm_device_id),\n\t},\n};\n\nmodule_gpr_driver(apm_driver);\nMODULE_DESCRIPTION(\"Audio Process Manager\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}