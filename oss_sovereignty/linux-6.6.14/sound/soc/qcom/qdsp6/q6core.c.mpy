{
  "module_name": "q6core.c",
  "hash_id": "2d75a00912665f5e1a38868ee5ad0778ee649c280c02439bcc85d297f355ca13",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6core.c",
  "human_readable_source": "\n\n\n\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/jiffies.h>\n#include <linux/soc/qcom/apr.h>\n#include \"q6core.h\"\n#include \"q6dsp-errno.h\"\n\n#define ADSP_STATE_READY_TIMEOUT_MS    3000\n#define Q6_READY_TIMEOUT_MS 100\n#define AVCS_CMD_ADSP_EVENT_GET_STATE\t\t0x0001290C\n#define AVCS_CMDRSP_ADSP_EVENT_GET_STATE\t0x0001290D\n#define AVCS_GET_VERSIONS       0x00012905\n#define AVCS_GET_VERSIONS_RSP   0x00012906\n#define AVCS_CMD_GET_FWK_VERSION\t0x001292c\n#define AVCS_CMDRSP_GET_FWK_VERSION\t0x001292d\n\nstruct avcs_svc_info {\n\tuint32_t service_id;\n\tuint32_t version;\n} __packed;\n\nstruct avcs_cmdrsp_get_version {\n\tuint32_t build_id;\n\tuint32_t num_services;\n\tstruct avcs_svc_info svc_api_info[];\n} __packed;\n\n \nstruct avcs_svc_api_info {\n\tuint32_t service_id;\n\tuint32_t api_version;\n\tuint32_t api_branch_version;\n} __packed;\n\nstruct avcs_cmdrsp_get_fwk_version {\n\tuint32_t build_major_version;\n\tuint32_t build_minor_version;\n\tuint32_t build_branch_version;\n\tuint32_t build_subbranch_version;\n\tuint32_t num_services;\n\tstruct avcs_svc_api_info svc_api_info[];\n} __packed;\n\nstruct q6core {\n\tstruct apr_device *adev;\n\twait_queue_head_t wait;\n\tuint32_t avcs_state;\n\tstruct mutex lock;\n\tbool resp_received;\n\tuint32_t num_services;\n\tstruct avcs_cmdrsp_get_fwk_version *fwk_version;\n\tstruct avcs_cmdrsp_get_version *svc_version;\n\tbool fwk_version_supported;\n\tbool get_state_supported;\n\tbool get_version_supported;\n\tbool is_version_requested;\n};\n\nstatic struct q6core *g_core;\n\nstatic int q6core_callback(struct apr_device *adev, struct apr_resp_pkt *data)\n{\n\tstruct q6core *core = dev_get_drvdata(&adev->dev);\n\tstruct aprv2_ibasic_rsp_result_t *result;\n\tstruct apr_hdr *hdr = &data->hdr;\n\n\tresult = data->payload;\n\tswitch (hdr->opcode) {\n\tcase APR_BASIC_RSP_RESULT:{\n\t\tresult = data->payload;\n\t\tswitch (result->opcode) {\n\t\tcase AVCS_GET_VERSIONS:\n\t\t\tif (result->status == ADSP_EUNSUPPORTED)\n\t\t\t\tcore->get_version_supported = false;\n\t\t\tcore->resp_received = true;\n\t\t\tbreak;\n\t\tcase AVCS_CMD_GET_FWK_VERSION:\n\t\t\tif (result->status == ADSP_EUNSUPPORTED)\n\t\t\t\tcore->fwk_version_supported = false;\n\t\t\tcore->resp_received = true;\n\t\t\tbreak;\n\t\tcase AVCS_CMD_ADSP_EVENT_GET_STATE:\n\t\t\tif (result->status == ADSP_EUNSUPPORTED)\n\t\t\t\tcore->get_state_supported = false;\n\t\t\tcore->resp_received = true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase AVCS_CMDRSP_GET_FWK_VERSION: {\n\t\tstruct avcs_cmdrsp_get_fwk_version *fwk;\n\n\t\tfwk = data->payload;\n\n\t\tcore->fwk_version = kmemdup(data->payload,\n\t\t\t\t\t    struct_size(fwk, svc_api_info,\n\t\t\t\t\t\t\tfwk->num_services),\n\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!core->fwk_version)\n\t\t\treturn -ENOMEM;\n\n\t\tcore->fwk_version_supported = true;\n\t\tcore->resp_received = true;\n\n\t\tbreak;\n\t}\n\tcase AVCS_GET_VERSIONS_RSP: {\n\t\tstruct avcs_cmdrsp_get_version *v;\n\n\t\tv = data->payload;\n\n\t\tcore->svc_version = kmemdup(data->payload,\n\t\t\t\t\t    struct_size(v, svc_api_info,\n\t\t\t\t\t\t\tv->num_services),\n\t\t\t\t\t    GFP_ATOMIC);\n\t\tif (!core->svc_version)\n\t\t\treturn -ENOMEM;\n\n\t\tcore->get_version_supported = true;\n\t\tcore->resp_received = true;\n\n\t\tbreak;\n\t}\n\tcase AVCS_CMDRSP_ADSP_EVENT_GET_STATE:\n\t\tcore->get_state_supported = true;\n\t\tcore->avcs_state = result->opcode;\n\n\t\tcore->resp_received = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&adev->dev, \"Message id from adsp core svc: 0x%x\\n\",\n\t\t\thdr->opcode);\n\t\tbreak;\n\t}\n\n\tif (core->resp_received)\n\t\twake_up(&core->wait);\n\n\treturn 0;\n}\n\nstatic int q6core_get_fwk_versions(struct q6core *core)\n{\n\tstruct apr_device *adev = core->adev;\n\tstruct apr_pkt pkt;\n\tint rc;\n\n\tpkt.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t      APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);\n\tpkt.hdr.pkt_size = APR_HDR_SIZE;\n\tpkt.hdr.opcode = AVCS_CMD_GET_FWK_VERSION;\n\n\trc = apr_send_pkt(adev, &pkt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = wait_event_timeout(core->wait, (core->resp_received),\n\t\t\t\tmsecs_to_jiffies(Q6_READY_TIMEOUT_MS));\n\tif (rc > 0 && core->resp_received) {\n\t\tcore->resp_received = false;\n\n\t\tif (!core->fwk_version_supported)\n\t\t\treturn -ENOTSUPP;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\n\treturn rc;\n}\n\nstatic int q6core_get_svc_versions(struct q6core *core)\n{\n\tstruct apr_device *adev = core->adev;\n\tstruct apr_pkt pkt;\n\tint rc;\n\n\tpkt.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t      APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);\n\tpkt.hdr.pkt_size = APR_HDR_SIZE;\n\tpkt.hdr.opcode = AVCS_GET_VERSIONS;\n\n\trc = apr_send_pkt(adev, &pkt);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = wait_event_timeout(core->wait, (core->resp_received),\n\t\t\t\tmsecs_to_jiffies(Q6_READY_TIMEOUT_MS));\n\tif (rc > 0 && core->resp_received) {\n\t\tcore->resp_received = false;\n\t\treturn 0;\n\t}\n\n\treturn rc;\n}\n\nstatic bool __q6core_is_adsp_ready(struct q6core *core)\n{\n\tstruct apr_device *adev = core->adev;\n\tstruct apr_pkt pkt;\n\tint rc;\n\n\tcore->get_state_supported = false;\n\n\tpkt.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,\n\t\t\t\t      APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);\n\tpkt.hdr.pkt_size = APR_HDR_SIZE;\n\tpkt.hdr.opcode = AVCS_CMD_ADSP_EVENT_GET_STATE;\n\n\trc = apr_send_pkt(adev, &pkt);\n\tif (rc < 0)\n\t\treturn false;\n\n\trc = wait_event_timeout(core->wait, (core->resp_received),\n\t\t\t\tmsecs_to_jiffies(Q6_READY_TIMEOUT_MS));\n\tif (rc > 0 && core->resp_received) {\n\t\tcore->resp_received = false;\n\n\t\tif (core->avcs_state)\n\t\t\treturn true;\n\t}\n\n\t \n\tif (!core->get_state_supported)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint q6core_get_svc_api_info(int svc_id, struct q6core_svc_api_info *ainfo)\n{\n\tint i;\n\tint ret = -ENOTSUPP;\n\n\tif (!g_core || !ainfo)\n\t\treturn 0;\n\n\tmutex_lock(&g_core->lock);\n\tif (!g_core->is_version_requested) {\n\t\tif (q6core_get_fwk_versions(g_core) == -ENOTSUPP)\n\t\t\tq6core_get_svc_versions(g_core);\n\t\tg_core->is_version_requested = true;\n\t}\n\n\tif (g_core->fwk_version_supported) {\n\t\tfor (i = 0; i < g_core->fwk_version->num_services; i++) {\n\t\t\tstruct avcs_svc_api_info *info;\n\n\t\t\tinfo = &g_core->fwk_version->svc_api_info[i];\n\t\t\tif (svc_id != info->service_id)\n\t\t\t\tcontinue;\n\n\t\t\tainfo->api_version = info->api_version;\n\t\t\tainfo->api_branch_version = info->api_branch_version;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t} else if (g_core->get_version_supported) {\n\t\tfor (i = 0; i < g_core->svc_version->num_services; i++) {\n\t\t\tstruct avcs_svc_info *info;\n\n\t\t\tinfo = &g_core->svc_version->svc_api_info[i];\n\t\t\tif (svc_id != info->service_id)\n\t\t\t\tcontinue;\n\n\t\t\tainfo->api_version = info->version;\n\t\t\tainfo->api_branch_version = 0;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&g_core->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(q6core_get_svc_api_info);\n\n \nbool q6core_is_adsp_ready(void)\n{\n\tunsigned long  timeout;\n\tbool ret = false;\n\n\tif (!g_core)\n\t\treturn false;\n\n\tmutex_lock(&g_core->lock);\n\ttimeout = jiffies + msecs_to_jiffies(ADSP_STATE_READY_TIMEOUT_MS);\n\tfor (;;) {\n\t\tif (__q6core_is_adsp_ready(g_core)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!time_after(timeout, jiffies)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&g_core->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(q6core_is_adsp_ready);\n\nstatic int q6core_probe(struct apr_device *adev)\n{\n\tg_core = kzalloc(sizeof(*g_core), GFP_KERNEL);\n\tif (!g_core)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&adev->dev, g_core);\n\n\tmutex_init(&g_core->lock);\n\tg_core->adev = adev;\n\tinit_waitqueue_head(&g_core->wait);\n\treturn 0;\n}\n\nstatic void q6core_exit(struct apr_device *adev)\n{\n\tstruct q6core *core = dev_get_drvdata(&adev->dev);\n\n\tif (core->fwk_version_supported)\n\t\tkfree(core->fwk_version);\n\tif (core->get_version_supported)\n\t\tkfree(core->svc_version);\n\n\tg_core = NULL;\n\tkfree(core);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6core_device_id[]  = {\n\t{ .compatible = \"qcom,q6core\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6core_device_id);\n#endif\n\nstatic struct apr_driver qcom_q6core_driver = {\n\t.probe = q6core_probe,\n\t.remove = q6core_exit,\n\t.callback = q6core_callback,\n\t.driver = {\n\t\t.name = \"qcom-q6core\",\n\t\t.of_match_table = of_match_ptr(q6core_device_id),\n\t},\n};\n\nmodule_apr_driver(qcom_q6core_driver);\nMODULE_DESCRIPTION(\"q6 core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}