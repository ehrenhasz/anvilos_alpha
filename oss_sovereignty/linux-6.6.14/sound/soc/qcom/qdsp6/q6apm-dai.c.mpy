{
  "module_name": "q6apm-dai.c",
  "hash_id": "f39af27f9f09392abcc7d773015082f5fa8f4b9e9a74d44c038001f1497866ae",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6apm-dai.c",
  "human_readable_source": "\n\n\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <linux/spinlock.h>\n#include <sound/pcm.h>\n#include <asm/dma.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_device.h>\n#include <sound/pcm_params.h>\n#include \"q6apm.h\"\n\n#define DRV_NAME \"q6apm-dai\"\n\n#define PLAYBACK_MIN_NUM_PERIODS\t2\n#define PLAYBACK_MAX_NUM_PERIODS\t8\n#define PLAYBACK_MAX_PERIOD_SIZE\t65536\n#define PLAYBACK_MIN_PERIOD_SIZE\t128\n#define CAPTURE_MIN_NUM_PERIODS\t\t2\n#define CAPTURE_MAX_NUM_PERIODS\t\t8\n#define CAPTURE_MAX_PERIOD_SIZE\t\t4096\n#define CAPTURE_MIN_PERIOD_SIZE\t\t320\n#define BUFFER_BYTES_MAX (PLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE)\n#define BUFFER_BYTES_MIN (PLAYBACK_MIN_NUM_PERIODS * PLAYBACK_MIN_PERIOD_SIZE)\n#define COMPR_PLAYBACK_MAX_FRAGMENT_SIZE (128 * 1024)\n#define COMPR_PLAYBACK_MAX_NUM_FRAGMENTS (16 * 4)\n#define COMPR_PLAYBACK_MIN_FRAGMENT_SIZE (8 * 1024)\n#define COMPR_PLAYBACK_MIN_NUM_FRAGMENTS (4)\n#define SID_MASK_DEFAULT\t0xF\n\nstatic const struct snd_compr_codec_caps q6apm_compr_caps = {\n\t.num_descriptors = 1,\n\t.descriptor[0].max_ch = 2,\n\t.descriptor[0].sample_rates = {\t8000, 11025, 12000, 16000, 22050,\n\t\t\t\t\t24000, 32000, 44100, 48000, 88200,\n\t\t\t\t\t96000, 176400, 192000 },\n\t.descriptor[0].num_sample_rates = 13,\n\t.descriptor[0].bit_rate[0] = 320,\n\t.descriptor[0].bit_rate[1] = 128,\n\t.descriptor[0].num_bitrates = 2,\n\t.descriptor[0].profiles = 0,\n\t.descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO,\n\t.descriptor[0].formats = 0,\n};\n\nenum stream_state {\n\tQ6APM_STREAM_IDLE = 0,\n\tQ6APM_STREAM_STOPPED,\n\tQ6APM_STREAM_RUNNING,\n};\n\nstruct q6apm_dai_rtd {\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_compr_stream *cstream;\n\tstruct snd_codec codec;\n\tstruct snd_compr_params codec_param;\n\tstruct snd_dma_buffer dma_buffer;\n\tphys_addr_t phys;\n\tunsigned int pcm_size;\n\tunsigned int pcm_count;\n\tunsigned int pos;        \n\tunsigned int periods;\n\tunsigned int bytes_sent;\n\tunsigned int bytes_received;\n\tunsigned int copied_total;\n\tuint16_t bits_per_sample;\n\tuint16_t source;  \n\tuint16_t session_id;\n\tbool next_track;\n\tenum stream_state state;\n\tstruct q6apm_graph *graph;\n\tspinlock_t lock;\n\tuint32_t initial_samples_drop;\n\tuint32_t trailing_samples_drop;\n\tbool notify_on_drain;\n};\n\nstruct q6apm_dai_data {\n\tlong long sid;\n};\n\nstatic struct snd_pcm_hardware q6apm_dai_hardware_capture = {\n\t.info =                 (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_BATCH),\n\t.formats =              (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),\n\t.rates =                SNDRV_PCM_RATE_8000_48000,\n\t.rate_min =             8000,\n\t.rate_max =             48000,\n\t.channels_min =         2,\n\t.channels_max =         4,\n\t.buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,\n\t.period_bytes_min =\tCAPTURE_MIN_PERIOD_SIZE,\n\t.period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,\n\t.periods_min =          CAPTURE_MIN_NUM_PERIODS,\n\t.periods_max =          CAPTURE_MAX_NUM_PERIODS,\n\t.fifo_size =            0,\n};\n\nstatic struct snd_pcm_hardware q6apm_dai_hardware_playback = {\n\t.info =                 (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t\t\t SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME |\n\t\t\t\t SNDRV_PCM_INFO_BATCH),\n\t.formats =              (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE),\n\t.rates =                SNDRV_PCM_RATE_8000_192000,\n\t.rate_min =             8000,\n\t.rate_max =             192000,\n\t.channels_min =         2,\n\t.channels_max =         8,\n\t.buffer_bytes_max =     (PLAYBACK_MAX_NUM_PERIODS * PLAYBACK_MAX_PERIOD_SIZE),\n\t.period_bytes_min =\tPLAYBACK_MIN_PERIOD_SIZE,\n\t.period_bytes_max =     PLAYBACK_MAX_PERIOD_SIZE,\n\t.periods_min =          PLAYBACK_MIN_NUM_PERIODS,\n\t.periods_max =          PLAYBACK_MAX_NUM_PERIODS,\n\t.fifo_size =            0,\n};\n\nstatic void event_handler(uint32_t opcode, uint32_t token, uint32_t *payload, void *priv)\n{\n\tstruct q6apm_dai_rtd *prtd = priv;\n\tstruct snd_pcm_substream *substream = prtd->substream;\n\tunsigned long flags;\n\n\tswitch (opcode) {\n\tcase APM_CLIENT_EVENT_CMD_EOS_DONE:\n\t\tprtd->state = Q6APM_STREAM_STOPPED;\n\t\tbreak;\n\tcase APM_CLIENT_EVENT_DATA_WRITE_DONE:\n\t        spin_lock_irqsave(&prtd->lock, flags);\n\t\tprtd->pos += prtd->pcm_count;\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tif (prtd->state == Q6APM_STREAM_RUNNING)\n\t\t\tq6apm_write_async(prtd->graph, prtd->pcm_count, 0, 0, 0);\n\n\t\tbreak;\n\tcase APM_CLIENT_EVENT_DATA_READ_DONE:\n\t        spin_lock_irqsave(&prtd->lock, flags);\n\t\tprtd->pos += prtd->pcm_count;\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tsnd_pcm_period_elapsed(substream);\n\t\tif (prtd->state == Q6APM_STREAM_RUNNING)\n\t\t\tq6apm_read(prtd->graph);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void event_handler_compr(uint32_t opcode, uint32_t token,\n\t\t\t\tuint32_t *payload, void *priv)\n{\n\tstruct q6apm_dai_rtd *prtd = priv;\n\tstruct snd_compr_stream *substream = prtd->cstream;\n\tunsigned long flags;\n\tuint32_t wflags = 0;\n\tuint64_t avail;\n\tuint32_t bytes_written, bytes_to_write;\n\tbool is_last_buffer = false;\n\n\tswitch (opcode) {\n\tcase APM_CLIENT_EVENT_CMD_EOS_DONE:\n\t\tspin_lock_irqsave(&prtd->lock, flags);\n\t\tif (prtd->notify_on_drain) {\n\t\t\tsnd_compr_drain_notify(prtd->cstream);\n\t\t\tprtd->notify_on_drain = false;\n\t\t} else {\n\t\t\tprtd->state = Q6APM_STREAM_STOPPED;\n\t\t}\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tbreak;\n\tcase APM_CLIENT_EVENT_DATA_WRITE_DONE:\n\t\tspin_lock_irqsave(&prtd->lock, flags);\n\t\tbytes_written = token >> APM_WRITE_TOKEN_LEN_SHIFT;\n\t\tprtd->copied_total += bytes_written;\n\t\tsnd_compr_fragment_elapsed(substream);\n\n\t\tif (prtd->state != Q6APM_STREAM_RUNNING) {\n\t\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tavail = prtd->bytes_received - prtd->bytes_sent;\n\n\t\tif (avail > prtd->pcm_count) {\n\t\t\tbytes_to_write = prtd->pcm_count;\n\t\t} else {\n\t\t\tif (substream->partial_drain || prtd->notify_on_drain)\n\t\t\t\tis_last_buffer = true;\n\t\t\tbytes_to_write = avail;\n\t\t}\n\n\t\tif (bytes_to_write) {\n\t\t\tif (substream->partial_drain && is_last_buffer)\n\t\t\t\twflags |= APM_LAST_BUFFER_FLAG;\n\n\t\t\tq6apm_write_async(prtd->graph,\n\t\t\t\t\t\tbytes_to_write, 0, 0, wflags);\n\n\t\t\tprtd->bytes_sent += bytes_to_write;\n\n\t\t\tif (prtd->notify_on_drain && is_last_buffer)\n\t\t\t\taudioreach_shared_memory_send_eos(prtd->graph);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&prtd->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int q6apm_dai_prepare(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tstruct audioreach_module_config cfg;\n\tstruct device *dev = component->dev;\n\tstruct q6apm_dai_data *pdata;\n\tint ret;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tif (!prtd || !prtd->graph) {\n\t\tdev_err(dev, \"%s: private data null or audio client freed\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcfg.direction = substream->stream;\n\tcfg.sample_rate = runtime->rate;\n\tcfg.num_channels = runtime->channels;\n\tcfg.bit_width = prtd->bits_per_sample;\n\tcfg.fmt = SND_AUDIOCODEC_PCM;\n\n\tif (prtd->state) {\n\t\t \n\t\tq6apm_graph_stop(prtd->graph);\n\t\tq6apm_unmap_memory_regions(prtd->graph, substream->stream);\n\t}\n\n\tprtd->pcm_count = snd_pcm_lib_period_bytes(substream);\n\tprtd->pos = 0;\n\t \n\tret = q6apm_graph_media_format_shmem(prtd->graph, &cfg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: q6apm_open_write failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = q6apm_graph_media_format_pcm(prtd->graph, &cfg);\n\tif (ret < 0)\n\t\tdev_err(dev, \"%s: CMD Format block failed\\n\", __func__);\n\n\tret = q6apm_map_memory_regions(prtd->graph, substream->stream, prtd->phys,\n\t\t\t\t       (prtd->pcm_size / prtd->periods), prtd->periods);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Audio Start: Buffer Allocation failed rc = %d\\n\",\tret);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = q6apm_graph_prepare(prtd->graph);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to prepare Graph %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = q6apm_graph_start(prtd->graph);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to Start Graph %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < runtime->periods; i++)\n\t\t\tq6apm_read(prtd->graph);\n\n\t}\n\n\t \n\tprtd->state = Q6APM_STREAM_RUNNING;\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_trigger(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t  \n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = q6apm_write_async(prtd->graph, prtd->pcm_count, 0, 0, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t \n\t\tprtd->state = Q6APM_STREAM_STOPPED;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6apm_dai_open(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *soc_prtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(soc_prtd, 0);\n\tstruct device *dev = component->dev;\n\tstruct q6apm_dai_data *pdata;\n\tstruct q6apm_dai_rtd *prtd;\n\tint graph_id, ret;\n\n\tgraph_id = cpu_dai->driver->id;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata) {\n\t\tdev_err(dev, \"Drv data not found ..\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (prtd == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&prtd->lock);\n\tprtd->substream = substream;\n\tprtd->graph = q6apm_graph_open(dev, (q6apm_cb)event_handler, prtd, graph_id);\n\tif (IS_ERR(prtd->graph)) {\n\t\tdev_err(dev, \"%s: Could not allocate memory\\n\", __func__);\n\t\tret = PTR_ERR(prtd->graph);\n\t\tgoto err;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\truntime->hw = q6apm_dai_hardware_playback;\n\telse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\truntime->hw = q6apm_dai_hardware_capture;\n\n\t \n\tret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"snd_pcm_hw_constraint_integer failed\\n\");\n\t\tgoto err;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t\t   BUFFER_BYTES_MIN, BUFFER_BYTES_MAX);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"constraint for buffer bytes min max ret = %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"constraint for period bytes step ret = %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"constraint for buffer bytes step ret = %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\truntime->private_data = prtd;\n\truntime->dma_bytes = BUFFER_BYTES_MAX;\n\tif (pdata->sid < 0)\n\t\tprtd->phys = substream->dma_buffer.addr;\n\telse\n\t\tprtd->phys = substream->dma_buffer.addr | (pdata->sid << 32);\n\n\treturn 0;\nerr:\n\tkfree(prtd);\n\n\treturn ret;\n}\n\nstatic int q6apm_dai_close(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\n\tif (prtd->state) {  \n\t\tq6apm_graph_stop(prtd->graph);\n\t\tq6apm_unmap_memory_regions(prtd->graph, substream->stream);\n\t}\n\n\tq6apm_graph_close(prtd->graph);\n\tprtd->graph = NULL;\n\tkfree(prtd);\n\truntime->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t q6apm_dai_pointer(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tsnd_pcm_uframes_t ptr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\tif (prtd->pos == prtd->pcm_size)\n\t\tprtd->pos = 0;\n\n\tptr =  bytes_to_frames(runtime, prtd->pos);\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn ptr;\n}\n\nstatic int q6apm_dai_hw_params(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\n\tprtd->pcm_size = params_buffer_bytes(params);\n\tprtd->periods = params_periods(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tprtd->bits_per_sample = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tprtd->bits_per_sample = 24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_pcm_new(struct snd_soc_component *component, struct snd_soc_pcm_runtime *rtd)\n{\n\tint size = BUFFER_BYTES_MAX;\n\n\treturn snd_pcm_set_fixed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV, component->dev, size);\n}\n\nstatic int q6apm_dai_compr_open(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = stream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd;\n\tstruct q6apm_dai_data *pdata;\n\tstruct device *dev = component->dev;\n\tint ret, size;\n\tint graph_id;\n\n\tgraph_id = cpu_dai->driver->id;\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (prtd == NULL)\n\t\treturn -ENOMEM;\n\n\tprtd->cstream = stream;\n\tprtd->graph = q6apm_graph_open(dev, (q6apm_cb)event_handler_compr, prtd, graph_id);\n\tif (IS_ERR(prtd->graph)) {\n\t\tret = PTR_ERR(prtd->graph);\n\t\tkfree(prtd);\n\t\treturn ret;\n\t}\n\n\truntime->private_data = prtd;\n\truntime->dma_bytes = BUFFER_BYTES_MAX;\n\tsize = COMPR_PLAYBACK_MAX_FRAGMENT_SIZE * COMPR_PLAYBACK_MAX_NUM_FRAGMENTS;\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dev, size, &prtd->dma_buffer);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata->sid < 0)\n\t\tprtd->phys = prtd->dma_buffer.addr;\n\telse\n\t\tprtd->phys = prtd->dma_buffer.addr | (pdata->sid << 32);\n\n\tsnd_compr_set_runtime_buffer(stream, &prtd->dma_buffer);\n\tspin_lock_init(&prtd->lock);\n\n\tq6apm_enable_compress_module(dev, prtd->graph, true);\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_free(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\n\tq6apm_graph_stop(prtd->graph);\n\tq6apm_unmap_memory_regions(prtd->graph, SNDRV_PCM_STREAM_PLAYBACK);\n\tq6apm_graph_close(prtd->graph);\n\tsnd_dma_free_pages(&prtd->dma_buffer);\n\tprtd->graph = NULL;\n\tkfree(prtd);\n\truntime->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_get_caps(struct snd_soc_component *component,\n\t\t\t\t    struct snd_compr_stream *stream,\n\t\t\t\t    struct snd_compr_caps *caps)\n{\n\tcaps->direction = SND_COMPRESS_PLAYBACK;\n\tcaps->min_fragment_size = COMPR_PLAYBACK_MIN_FRAGMENT_SIZE;\n\tcaps->max_fragment_size = COMPR_PLAYBACK_MAX_FRAGMENT_SIZE;\n\tcaps->min_fragments = COMPR_PLAYBACK_MIN_NUM_FRAGMENTS;\n\tcaps->max_fragments = COMPR_PLAYBACK_MAX_NUM_FRAGMENTS;\n\tcaps->num_codecs = 3;\n\tcaps->codecs[0] = SND_AUDIOCODEC_MP3;\n\tcaps->codecs[1] = SND_AUDIOCODEC_AAC;\n\tcaps->codecs[2] = SND_AUDIOCODEC_FLAC;\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_get_codec_caps(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_compr_stream *stream,\n\t\t\t\t\t  struct snd_compr_codec_caps *codec)\n{\n\tswitch (codec->codec) {\n\tcase SND_AUDIOCODEC_MP3:\n\t\t*codec = q6apm_compr_caps;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_pointer(struct snd_soc_component *component,\n\t\t\t\t   struct snd_compr_stream *stream,\n\t\t\t\t   struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\ttstamp->copied_total = prtd->copied_total;\n\ttstamp->byte_offset = prtd->copied_total % prtd->pcm_size;\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_trigger(struct snd_soc_component *component,\n\t\t\t    struct snd_compr_stream *stream, int cmd)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = q6apm_write_async(prtd->graph, prtd->pcm_count, 0, 0, NO_TIMESTAMP);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_NEXT_TRACK:\n\t\tprtd->next_track = true;\n\t\tbreak;\n\tcase SND_COMPR_TRIGGER_DRAIN:\n\tcase SND_COMPR_TRIGGER_PARTIAL_DRAIN:\n\t\tprtd->notify_on_drain = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6apm_dai_compr_ack(struct snd_soc_component *component, struct snd_compr_stream *stream,\n\t\t\tsize_t count)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\tprtd->bytes_received += count;\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn count;\n}\n\nstatic int q6apm_dai_compr_set_params(struct snd_soc_component *component,\n\t\t\t\t      struct snd_compr_stream *stream,\n\t\t\t\t      struct snd_compr_params *params)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tstruct q6apm_dai_data *pdata;\n\tstruct audioreach_module_config cfg;\n\tstruct snd_codec *codec = &params->codec;\n\tint dir = stream->direction;\n\tint ret;\n\n\tpdata = snd_soc_component_get_drvdata(component);\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tprtd->periods = runtime->fragments;\n\tprtd->pcm_count = runtime->fragment_size;\n\tprtd->pcm_size = runtime->fragments * runtime->fragment_size;\n\tprtd->bits_per_sample = 16;\n\n\tprtd->pos = 0;\n\n\tif (prtd->next_track != true) {\n\t\tmemcpy(&prtd->codec, codec, sizeof(*codec));\n\n\t\tret = q6apm_set_real_module_id(component->dev, prtd->graph, codec->id);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcfg.direction = dir;\n\t\tcfg.sample_rate = codec->sample_rate;\n\t\tcfg.num_channels = 2;\n\t\tcfg.bit_width = prtd->bits_per_sample;\n\t\tcfg.fmt = codec->id;\n\t\tmemcpy(&cfg.codec, codec, sizeof(*codec));\n\n\t\tret = q6apm_graph_media_format_shmem(prtd->graph, &cfg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = q6apm_graph_media_format_pcm(prtd->graph, &cfg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = q6apm_map_memory_regions(prtd->graph, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t       prtd->phys, (prtd->pcm_size / prtd->periods),\n\t\t\t\t\t       prtd->periods);\n\t\tif (ret < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tret = q6apm_graph_prepare(prtd->graph);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = q6apm_graph_start(prtd->graph);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} else {\n\t\tcfg.direction = dir;\n\t\tcfg.sample_rate = codec->sample_rate;\n\t\tcfg.num_channels = 2;\n\t\tcfg.bit_width = prtd->bits_per_sample;\n\t\tcfg.fmt = codec->id;\n\t\tmemcpy(&cfg.codec, codec, sizeof(*codec));\n\n\t\tret = audioreach_compr_set_param(prtd->graph,  &cfg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tprtd->state = Q6APM_STREAM_RUNNING;\n\n\treturn 0;\n}\n\nstatic int q6apm_dai_compr_set_metadata(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_compr_stream *stream,\n\t\t\t\t\tstruct snd_compr_metadata *metadata)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (metadata->key) {\n\tcase SNDRV_COMPRESS_ENCODER_PADDING:\n\t\tprtd->trailing_samples_drop = metadata->value[0];\n\t\tq6apm_remove_trailing_silence(component->dev, prtd->graph,\n\t\t\t\t\t      prtd->trailing_samples_drop);\n\t\tbreak;\n\tcase SNDRV_COMPRESS_ENCODER_DELAY:\n\t\tprtd->initial_samples_drop = metadata->value[0];\n\t\tq6apm_remove_initial_silence(component->dev, prtd->graph,\n\t\t\t\t\t     prtd->initial_samples_drop);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6apm_dai_compr_mmap(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *stream,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tstruct device *dev = component->dev;\n\n\treturn dma_mmap_coherent(dev, vma, prtd->dma_buffer.area, prtd->dma_buffer.addr,\n\t\t\t\t prtd->dma_buffer.bytes);\n}\n\nstatic int q6apm_compr_copy(struct snd_soc_component *component,\n\t\t\t    struct snd_compr_stream *stream, char __user *buf,\n\t\t\t    size_t count)\n{\n\tstruct snd_compr_runtime *runtime = stream->runtime;\n\tstruct q6apm_dai_rtd *prtd = runtime->private_data;\n\tvoid *dstn;\n\tunsigned long flags;\n\tsize_t copy;\n\tu32 wflags = 0;\n\tu32 app_pointer;\n\tu32 bytes_received;\n\tuint32_t bytes_to_write;\n\tint avail, bytes_in_flight = 0;\n\n\tbytes_received = prtd->bytes_received;\n\n\t \n\tif (prtd->next_track)\n\t\tbytes_received = ALIGN(prtd->bytes_received, prtd->pcm_count);\n\n\tapp_pointer = bytes_received/prtd->pcm_size;\n\tapp_pointer = bytes_received -  (app_pointer * prtd->pcm_size);\n\tdstn = prtd->dma_buffer.area + app_pointer;\n\n\tif (count < prtd->pcm_size - app_pointer) {\n\t\tif (copy_from_user(dstn, buf, count))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tcopy = prtd->pcm_size - app_pointer;\n\t\tif (copy_from_user(dstn, buf, copy))\n\t\t\treturn -EFAULT;\n\t\tif (copy_from_user(prtd->dma_buffer.area, buf + copy, count - copy))\n\t\t\treturn -EFAULT;\n\t}\n\n\tspin_lock_irqsave(&prtd->lock, flags);\n\tbytes_in_flight = prtd->bytes_received - prtd->copied_total;\n\n\tif (prtd->next_track) {\n\t\tprtd->next_track = false;\n\t\tprtd->copied_total = ALIGN(prtd->copied_total, prtd->pcm_count);\n\t\tprtd->bytes_sent = ALIGN(prtd->bytes_sent, prtd->pcm_count);\n\t}\n\n\tprtd->bytes_received = bytes_received + count;\n\n\t \n\tif (prtd->state == Q6APM_STREAM_RUNNING && (bytes_in_flight == 0)) {\n\t\tbytes_to_write = prtd->pcm_count;\n\t\tavail = prtd->bytes_received - prtd->bytes_sent;\n\n\t\tif (avail < prtd->pcm_count)\n\t\t\tbytes_to_write = avail;\n\n\t\tq6apm_write_async(prtd->graph, bytes_to_write, 0, 0, wflags);\n\t\tprtd->bytes_sent += bytes_to_write;\n\t}\n\n\tspin_unlock_irqrestore(&prtd->lock, flags);\n\n\treturn count;\n}\n\nstatic const struct snd_compress_ops q6apm_dai_compress_ops = {\n\t.open\t\t= q6apm_dai_compr_open,\n\t.free\t\t= q6apm_dai_compr_free,\n\t.get_caps\t= q6apm_dai_compr_get_caps,\n\t.get_codec_caps\t= q6apm_dai_compr_get_codec_caps,\n\t.pointer\t= q6apm_dai_compr_pointer,\n\t.trigger\t= q6apm_dai_compr_trigger,\n\t.ack\t\t= q6apm_dai_compr_ack,\n\t.set_params\t= q6apm_dai_compr_set_params,\n\t.set_metadata\t= q6apm_dai_compr_set_metadata,\n\t.mmap\t\t= q6apm_dai_compr_mmap,\n\t.copy\t\t= q6apm_compr_copy,\n};\n\nstatic const struct snd_soc_component_driver q6apm_fe_dai_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= q6apm_dai_open,\n\t.close\t\t= q6apm_dai_close,\n\t.prepare\t= q6apm_dai_prepare,\n\t.pcm_construct\t= q6apm_dai_pcm_new,\n\t.hw_params\t= q6apm_dai_hw_params,\n\t.pointer\t= q6apm_dai_pointer,\n\t.trigger\t= q6apm_dai_trigger,\n\t.compress_ops\t= &q6apm_dai_compress_ops,\n\t.use_dai_pcm_id = true,\n};\n\nstatic int q6apm_dai_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct q6apm_dai_data *pdata;\n\tstruct of_phandle_args args;\n\tint rc;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\trc = of_parse_phandle_with_fixed_args(node, \"iommus\", 1, 0, &args);\n\tif (rc < 0)\n\t\tpdata->sid = -1;\n\telse\n\t\tpdata->sid = args.args[0] & SID_MASK_DEFAULT;\n\n\tdev_set_drvdata(dev, pdata);\n\n\treturn devm_snd_soc_register_component(dev, &q6apm_fe_dai_component, NULL, 0);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id q6apm_dai_device_id[] = {\n\t{ .compatible = \"qcom,q6apm-dais\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, q6apm_dai_device_id);\n#endif\n\nstatic struct platform_driver q6apm_dai_platform_driver = {\n\t.driver = {\n\t\t.name = \"q6apm-dai\",\n\t\t.of_match_table = of_match_ptr(q6apm_dai_device_id),\n\t},\n\t.probe = q6apm_dai_probe,\n};\nmodule_platform_driver(q6apm_dai_platform_driver);\n\nMODULE_DESCRIPTION(\"Q6APM dai driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}