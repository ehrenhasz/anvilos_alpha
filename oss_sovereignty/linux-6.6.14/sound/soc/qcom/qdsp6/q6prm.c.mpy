{
  "module_name": "q6prm.c",
  "hash_id": "4d1c3f2fa3dcea9c3e0f5ceef83a54a015c9e6771d9fe02aa480f0cfe5cd0882",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/qdsp6/q6prm.c",
  "human_readable_source": "\n\n\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/of_platform.h>\n#include <linux/jiffies.h>\n#include <linux/soc/qcom/apr.h>\n#include <dt-bindings/soc/qcom,gpr.h>\n#include <dt-bindings/sound/qcom,q6dsp-lpass-ports.h>\n#include \"q6apm.h\"\n#include \"q6prm.h\"\n#include \"audioreach.h\"\n\nstruct q6prm {\n\tstruct device *dev;\n\tgpr_device_t *gdev;\n\twait_queue_head_t wait;\n\tstruct gpr_ibasic_rsp_result_t result;\n\tstruct mutex lock;\n};\n\n#define PRM_CMD_REQUEST_HW_RSC\t\t0x0100100F\n#define PRM_CMD_RSP_REQUEST_HW_RSC\t0x02001002\n#define PRM_CMD_RELEASE_HW_RSC\t\t0x01001010\n#define PRM_CMD_RSP_RELEASE_HW_RSC\t0x02001003\n#define PARAM_ID_RSC_HW_CORE\t\t0x08001032\n#define PARAM_ID_RSC_LPASS_CORE\t\t0x0800102B\n#define PARAM_ID_RSC_AUDIO_HW_CLK\t0x0800102C\n\nstruct prm_cmd_request_hw_core {\n\tstruct apm_module_param_data param_data;\n\tuint32_t hw_clk_id;\n} __packed;\n\nstruct prm_cmd_request_rsc {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_clk_id;\n\tstruct audio_hw_clk_cfg clock_id;\n} __packed;\n\nstruct prm_cmd_release_rsc {\n\tstruct apm_module_param_data param_data;\n\tuint32_t num_clk_id;\n\tstruct audio_hw_clk_rel_cfg clock_id;\n} __packed;\n\nstatic int q6prm_send_cmd_sync(struct q6prm *prm, struct gpr_pkt *pkt, uint32_t rsp_opcode)\n{\n\treturn audioreach_send_cmd_sync(prm->dev, prm->gdev, &prm->result, &prm->lock,\n\t\t\t\t\tNULL, &prm->wait, pkt, rsp_opcode);\n}\n\nstatic int q6prm_set_hw_core_req(struct device *dev, uint32_t hw_block_id, bool enable)\n{\n\tstruct q6prm *prm = dev_get_drvdata(dev->parent);\n\tstruct apm_module_param_data *param_data;\n\tstruct prm_cmd_request_hw_core *req;\n\tgpr_device_t *gdev = prm->gdev;\n\tuint32_t opcode, rsp_opcode;\n\tstruct gpr_pkt *pkt;\n\tint rc;\n\n\tif (enable) {\n\t\topcode = PRM_CMD_REQUEST_HW_RSC;\n\t\trsp_opcode = PRM_CMD_RSP_REQUEST_HW_RSC;\n\t} else {\n\t\topcode = PRM_CMD_RELEASE_HW_RSC;\n\t\trsp_opcode = PRM_CMD_RSP_RELEASE_HW_RSC;\n\t}\n\n\tpkt = audioreach_alloc_cmd_pkt(sizeof(*req), opcode, 0, gdev->svc.id, GPR_PRM_MODULE_IID);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\treq = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = &req->param_data;\n\n\tparam_data->module_instance_id = GPR_PRM_MODULE_IID;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_RSC_HW_CORE;\n\tparam_data->param_size = sizeof(*req) - APM_MODULE_PARAM_DATA_SIZE;\n\n\treq->hw_clk_id = hw_block_id;\n\n\trc = q6prm_send_cmd_sync(prm, pkt, rsp_opcode);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint q6prm_vote_lpass_core_hw(struct device *dev, uint32_t hw_block_id,\n\t\t\t     const char *client_name, uint32_t *client_handle)\n{\n\treturn q6prm_set_hw_core_req(dev, hw_block_id, true);\n\n}\nEXPORT_SYMBOL_GPL(q6prm_vote_lpass_core_hw);\n\nint q6prm_unvote_lpass_core_hw(struct device *dev, uint32_t hw_block_id, uint32_t client_handle)\n{\n\treturn q6prm_set_hw_core_req(dev, hw_block_id, false);\n}\nEXPORT_SYMBOL_GPL(q6prm_unvote_lpass_core_hw);\n\nstatic int q6prm_request_lpass_clock(struct device *dev, int clk_id, int clk_attr, int clk_root,\n\t\t\t\t     unsigned int freq)\n{\n\tstruct q6prm *prm = dev_get_drvdata(dev->parent);\n\tstruct apm_module_param_data *param_data;\n\tstruct prm_cmd_request_rsc *req;\n\tgpr_device_t *gdev = prm->gdev;\n\tstruct gpr_pkt *pkt;\n\tint rc;\n\n\tpkt = audioreach_alloc_cmd_pkt(sizeof(*req), PRM_CMD_REQUEST_HW_RSC, 0, gdev->svc.id,\n\t\t\t\t       GPR_PRM_MODULE_IID);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\treq = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = &req->param_data;\n\n\tparam_data->module_instance_id = GPR_PRM_MODULE_IID;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_RSC_AUDIO_HW_CLK;\n\tparam_data->param_size = sizeof(*req) - APM_MODULE_PARAM_DATA_SIZE;\n\n\treq->num_clk_id = 1;\n\treq->clock_id.clock_id = clk_id;\n\treq->clock_id.clock_freq = freq;\n\treq->clock_id.clock_attri = clk_attr;\n\treq->clock_id.clock_root = clk_root;\n\n\trc = q6prm_send_cmd_sync(prm, pkt, PRM_CMD_RSP_REQUEST_HW_RSC);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nstatic int q6prm_release_lpass_clock(struct device *dev, int clk_id, int clk_attr, int clk_root,\n\t\t\t  unsigned int freq)\n{\n\tstruct q6prm *prm = dev_get_drvdata(dev->parent);\n\tstruct apm_module_param_data *param_data;\n\tstruct prm_cmd_release_rsc *rel;\n\tgpr_device_t *gdev = prm->gdev;\n\tstruct gpr_pkt *pkt;\n\tint rc;\n\n\tpkt = audioreach_alloc_cmd_pkt(sizeof(*rel), PRM_CMD_RELEASE_HW_RSC, 0, gdev->svc.id,\n\t\t\t\t       GPR_PRM_MODULE_IID);\n\tif (IS_ERR(pkt))\n\t\treturn PTR_ERR(pkt);\n\n\trel = (void *)pkt + GPR_HDR_SIZE + APM_CMD_HDR_SIZE;\n\n\tparam_data = &rel->param_data;\n\n\tparam_data->module_instance_id = GPR_PRM_MODULE_IID;\n\tparam_data->error_code = 0;\n\tparam_data->param_id = PARAM_ID_RSC_AUDIO_HW_CLK;\n\tparam_data->param_size = sizeof(*rel) - APM_MODULE_PARAM_DATA_SIZE;\n\n\trel->num_clk_id = 1;\n\trel->clock_id.clock_id = clk_id;\n\n\trc = q6prm_send_cmd_sync(prm, pkt, PRM_CMD_RSP_RELEASE_HW_RSC);\n\n\tkfree(pkt);\n\n\treturn rc;\n}\n\nint q6prm_set_lpass_clock(struct device *dev, int clk_id, int clk_attr, int clk_root,\n\t\t\t  unsigned int freq)\n{\n\tif (freq)\n\t\treturn q6prm_request_lpass_clock(dev, clk_id, clk_attr, clk_root, freq);\n\n\treturn q6prm_release_lpass_clock(dev, clk_id, clk_attr, clk_root, freq);\n}\nEXPORT_SYMBOL_GPL(q6prm_set_lpass_clock);\n\nstatic int prm_callback(struct gpr_resp_pkt *data, void *priv, int op)\n{\n\tgpr_device_t *gdev = priv;\n\tstruct q6prm *prm = dev_get_drvdata(&gdev->dev);\n\tstruct gpr_ibasic_rsp_result_t *result;\n\tstruct gpr_hdr *hdr = &data->hdr;\n\n\tswitch (hdr->opcode) {\n\tcase PRM_CMD_RSP_REQUEST_HW_RSC:\n\tcase PRM_CMD_RSP_RELEASE_HW_RSC:\n\t\tresult = data->payload;\n\t\tprm->result.opcode = hdr->opcode;\n\t\tprm->result.status = result->status;\n\t\twake_up(&prm->wait);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int prm_probe(gpr_device_t *gdev)\n{\n\tstruct device *dev = &gdev->dev;\n\tstruct q6prm *cc;\n\n\tcc = devm_kzalloc(dev, sizeof(*cc), GFP_KERNEL);\n\tif (!cc)\n\t\treturn -ENOMEM;\n\n\tcc->dev = dev;\n\tcc->gdev = gdev;\n\tmutex_init(&cc->lock);\n\tinit_waitqueue_head(&cc->wait);\n\tdev_set_drvdata(dev, cc);\n\n\tif (!q6apm_is_adsp_ready())\n\t\treturn -EPROBE_DEFER;\n\n\treturn devm_of_platform_populate(dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id prm_device_id[]  = {\n\t{ .compatible = \"qcom,q6prm\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, prm_device_id);\n#endif\n\nstatic gpr_driver_t prm_driver = {\n\t.probe = prm_probe,\n\t.gpr_callback = prm_callback,\n\t.driver = {\n\t\t.name = \"qcom-prm\",\n\t\t.of_match_table = of_match_ptr(prm_device_id),\n\t},\n};\n\nmodule_gpr_driver(prm_driver);\nMODULE_DESCRIPTION(\"Q6 Proxy Resource Manager\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}