{
  "module_name": "lpass-ipq806x.c",
  "hash_id": "d10516adde97f477f67a5b66398291387a7f45004acbf883508ecd528f9d82be",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/qcom/lpass-ipq806x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"lpass-lpaif-reg.h\"\n#include \"lpass.h\"\n\nenum lpaif_i2s_ports {\n\tIPQ806X_LPAIF_I2S_PORT_CODEC_SPK,\n\tIPQ806X_LPAIF_I2S_PORT_CODEC_MIC,\n\tIPQ806X_LPAIF_I2S_PORT_SEC_SPK,\n\tIPQ806X_LPAIF_I2S_PORT_SEC_MIC,\n\tIPQ806X_LPAIF_I2S_PORT_MI2S,\n};\n\nenum lpaif_dma_channels {\n\tIPQ806X_LPAIF_RDMA_CHAN_MI2S,\n\tIPQ806X_LPAIF_RDMA_CHAN_PCM0,\n\tIPQ806X_LPAIF_RDMA_CHAN_PCM1,\n};\n\nstatic struct snd_soc_dai_driver ipq806x_lpass_cpu_dai_driver = {\n\t.id\t= IPQ806X_LPAIF_I2S_PORT_MI2S,\n\t.playback = {\n\t\t.stream_name\t= \"lpass-cpu-playback\",\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S24 |\n\t\t\t\t\tSNDRV_PCM_FMTBIT_S32,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000 |\n\t\t\t\t\tSNDRV_PCM_RATE_16000 |\n\t\t\t\t\tSNDRV_PCM_RATE_32000 |\n\t\t\t\t\tSNDRV_PCM_RATE_48000 |\n\t\t\t\t\tSNDRV_PCM_RATE_96000,\n\t\t.rate_min\t= 8000,\n\t\t.rate_max\t= 96000,\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t},\n\t.ops    = &asoc_qcom_lpass_cpu_dai_ops,\n};\n\nstatic int ipq806x_lpass_init(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tdrvdata->ahbix_clk = devm_clk_get(dev, \"ahbix-clk\");\n\tif (IS_ERR(drvdata->ahbix_clk)) {\n\t\tdev_err(dev, \"error getting ahbix-clk: %ld\\n\",\n\t\t\t\tPTR_ERR(drvdata->ahbix_clk));\n\t\tret = PTR_ERR(drvdata->ahbix_clk);\n\t\tgoto err_ahbix_clk;\n\t}\n\n\tret = clk_set_rate(drvdata->ahbix_clk, LPASS_AHBIX_CLOCK_FREQUENCY);\n\tif (ret) {\n\t\tdev_err(dev, \"error setting rate on ahbix_clk: %d\\n\", ret);\n\t\tgoto err_ahbix_clk;\n\t}\n\tdev_dbg(dev, \"set ahbix_clk rate to %lu\\n\",\n\t\t\tclk_get_rate(drvdata->ahbix_clk));\n\n\tret = clk_prepare_enable(drvdata->ahbix_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"error enabling ahbix_clk: %d\\n\", ret);\n\t\tgoto err_ahbix_clk;\n\t}\n\nerr_ahbix_clk:\n\treturn ret;\n}\n\nstatic int ipq806x_lpass_exit(struct platform_device *pdev)\n{\n\tstruct lpass_data *drvdata = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(drvdata->ahbix_clk);\n\n\treturn 0;\n}\n\nstatic int ipq806x_lpass_alloc_dma_channel(struct lpass_data *drvdata, int dir, unsigned int dai_id)\n{\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn IPQ806X_LPAIF_RDMA_CHAN_MI2S;\n\telse\t \n\t\treturn -EINVAL;\n}\n\nstatic int ipq806x_lpass_free_dma_channel(struct lpass_data *drvdata, int chan, unsigned int dai_id)\n{\n\treturn 0;\n}\n\nstatic struct lpass_variant ipq806x_data = {\n\t.i2sctrl_reg_base\t= 0x0010,\n\t.i2sctrl_reg_stride\t= 0x04,\n\t.i2s_ports\t\t= 5,\n\t.irq_reg_base\t\t= 0x3000,\n\t.irq_reg_stride\t\t= 0x1000,\n\t.irq_ports\t\t= 3,\n\t.rdma_reg_base\t\t= 0x6000,\n\t.rdma_reg_stride\t= 0x1000,\n\t.rdma_channels\t\t= 4,\n\t.wrdma_reg_base\t\t= 0xB000,\n\t.wrdma_reg_stride\t= 0x1000,\n\t.wrdma_channel_start\t= 5,\n\t.wrdma_channels\t\t= 4,\n\t.loopback\t\t= REG_FIELD_ID(0x0010, 15, 15, 5, 0x4),\n\t.spken\t\t\t= REG_FIELD_ID(0x0010, 14, 14, 5, 0x4),\n\t.spkmode\t\t= REG_FIELD_ID(0x0010, 10, 13, 5, 0x4),\n\t.spkmono\t\t= REG_FIELD_ID(0x0010, 9, 9, 5, 0x4),\n\t.micen\t\t\t= REG_FIELD_ID(0x0010, 8, 8, 5, 0x4),\n\t.micmode\t\t= REG_FIELD_ID(0x0010, 4, 7, 5, 0x4),\n\t.micmono\t\t= REG_FIELD_ID(0x0010, 3, 3, 5, 0x4),\n\t.wssrc\t\t\t= REG_FIELD_ID(0x0010, 2, 2, 5, 0x4),\n\t.bitwidth\t\t= REG_FIELD_ID(0x0010, 0, 1, 5, 0x4),\n\n\t.rdma_dyncclk\t\t= REG_FIELD_ID(0x6000, 12, 12, 4, 0x1000),\n\t.rdma_bursten\t\t= REG_FIELD_ID(0x6000, 11, 11, 4, 0x1000),\n\t.rdma_wpscnt\t\t= REG_FIELD_ID(0x6000, 8, 10, 4, 0x1000),\n\t.rdma_intf\t\t= REG_FIELD_ID(0x6000, 4, 7, 4, 0x1000),\n\t.rdma_fifowm\t\t= REG_FIELD_ID(0x6000, 1, 3, 4, 0x1000),\n\t.rdma_enable\t\t= REG_FIELD_ID(0x6000, 0, 0, 4, 0x1000),\n\n\t.wrdma_dyncclk\t\t= REG_FIELD_ID(0xB000, 12, 12, 4, 0x1000),\n\t.wrdma_bursten\t\t= REG_FIELD_ID(0xB000, 11, 11, 4, 0x1000),\n\t.wrdma_wpscnt\t\t= REG_FIELD_ID(0xB000, 8, 10, 4, 0x1000),\n\t.wrdma_intf\t\t= REG_FIELD_ID(0xB000, 4, 7, 4, 0x1000),\n\t.wrdma_fifowm\t\t= REG_FIELD_ID(0xB000, 1, 3, 4, 0x1000),\n\t.wrdma_enable\t\t= REG_FIELD_ID(0xB000, 0, 0, 4, 0x1000),\n\n\t.dai_driver\t\t= &ipq806x_lpass_cpu_dai_driver,\n\t.num_dai\t\t= 1,\n\t.dai_osr_clk_names\t= (const char *[]) {\n\t\t\t\t\"mi2s-osr-clk\",\n\t\t\t\t},\n\t.dai_bit_clk_names\t= (const char *[]) {\n\t\t\t\t\"mi2s-bit-clk\",\n\t\t\t\t},\n\t.init\t\t\t= ipq806x_lpass_init,\n\t.exit\t\t\t= ipq806x_lpass_exit,\n\t.alloc_dma_channel\t= ipq806x_lpass_alloc_dma_channel,\n\t.free_dma_channel\t= ipq806x_lpass_free_dma_channel,\n};\n\nstatic const struct of_device_id ipq806x_lpass_cpu_device_id[] __maybe_unused = {\n\t{ .compatible = \"qcom,lpass-cpu\", .data = &ipq806x_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ipq806x_lpass_cpu_device_id);\n\nstatic struct platform_driver ipq806x_lpass_cpu_platform_driver = {\n\t.driver\t= {\n\t\t.name\t\t= \"lpass-cpu\",\n\t\t.of_match_table\t= of_match_ptr(ipq806x_lpass_cpu_device_id),\n\t},\n\t.probe\t= asoc_qcom_lpass_cpu_platform_probe,\n\t.remove\t= asoc_qcom_lpass_cpu_platform_remove,\n};\nmodule_platform_driver(ipq806x_lpass_cpu_platform_driver);\n\nMODULE_DESCRIPTION(\"QTi LPASS CPU Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}