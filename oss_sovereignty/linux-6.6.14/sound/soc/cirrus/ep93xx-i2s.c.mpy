{
  "module_name": "ep93xx-i2s.c",
  "hash_id": "c10af075b1f240493589ecbd9553134750ceb4c15942fe68f8e2f1f68a7f4ea8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/cirrus/ep93xx-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\n#include <linux/platform_data/dma-ep93xx.h>\n#include <linux/soc/cirrus/ep93xx.h>\n\n#include \"ep93xx-pcm.h\"\n\n#define EP93XX_I2S_TXCLKCFG\t\t0x00\n#define EP93XX_I2S_RXCLKCFG\t\t0x04\n#define EP93XX_I2S_GLSTS\t\t0x08\n#define EP93XX_I2S_GLCTRL\t\t0x0C\n\n#define EP93XX_I2S_I2STX0LFT\t\t0x10\n#define EP93XX_I2S_I2STX0RT\t\t0x14\n\n#define EP93XX_I2S_TXLINCTRLDATA\t0x28\n#define EP93XX_I2S_TXCTRL\t\t0x2C\n#define EP93XX_I2S_TXWRDLEN\t\t0x30\n#define EP93XX_I2S_TX0EN\t\t0x34\n\n#define EP93XX_I2S_RXLINCTRLDATA\t0x58\n#define EP93XX_I2S_RXCTRL\t\t0x5C\n#define EP93XX_I2S_RXWRDLEN\t\t0x60\n#define EP93XX_I2S_RX0EN\t\t0x64\n\n#define EP93XX_I2S_WRDLEN_16\t\t(0 << 0)\n#define EP93XX_I2S_WRDLEN_24\t\t(1 << 0)\n#define EP93XX_I2S_WRDLEN_32\t\t(2 << 0)\n\n#define EP93XX_I2S_RXLINCTRLDATA_R_JUST\tBIT(1)  \n\n#define EP93XX_I2S_TXLINCTRLDATA_R_JUST\tBIT(2)  \n\n \n#define EP93XX_I2S_TXCTRL_TXEMPTY_LVL\tBIT(0)\n#define EP93XX_I2S_TXCTRL_TXUFIE\tBIT(1)  \n\n#define EP93XX_I2S_CLKCFG_LRS\t\t(1 << 0)  \n#define EP93XX_I2S_CLKCFG_CKP\t\t(1 << 1)  \n#define EP93XX_I2S_CLKCFG_REL\t\t(1 << 2)  \n#define EP93XX_I2S_CLKCFG_MASTER\t(1 << 3)  \n#define EP93XX_I2S_CLKCFG_NBCG\t\t(1 << 4)  \n\n#define EP93XX_I2S_GLSTS_TX0_FIFO_FULL\tBIT(12)\n\nstruct ep93xx_i2s_info {\n\tstruct clk\t\t\t*mclk;\n\tstruct clk\t\t\t*sclk;\n\tstruct clk\t\t\t*lrclk;\n\tvoid __iomem\t\t\t*regs;\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n\tstruct snd_dmaengine_dai_dma_data dma_params_tx;\n};\n\nstatic struct ep93xx_dma_data ep93xx_i2s_dma_data[] = {\n\t[SNDRV_PCM_STREAM_PLAYBACK] = {\n\t\t.name\t\t= \"i2s-pcm-out\",\n\t\t.port\t\t= EP93XX_DMA_I2S1,\n\t\t.direction\t= DMA_MEM_TO_DEV,\n\t},\n\t[SNDRV_PCM_STREAM_CAPTURE] = {\n\t\t.name\t\t= \"i2s-pcm-in\",\n\t\t.port\t\t= EP93XX_DMA_I2S1,\n\t\t.direction\t= DMA_DEV_TO_MEM,\n\t},\n};\n\nstatic inline void ep93xx_i2s_write_reg(struct ep93xx_i2s_info *info,\n\t\t\t\t\tunsigned reg, unsigned val)\n{\n\t__raw_writel(val, info->regs + reg);\n}\n\nstatic inline unsigned ep93xx_i2s_read_reg(struct ep93xx_i2s_info *info,\n\t\t\t\t\t   unsigned reg)\n{\n\treturn __raw_readl(info->regs + reg);\n}\n\nstatic void ep93xx_i2s_enable(struct ep93xx_i2s_info *info, int stream)\n{\n\tunsigned base_reg;\n\n\tif ((ep93xx_i2s_read_reg(info, EP93XX_I2S_TX0EN) & 0x1) == 0 &&\n\t    (ep93xx_i2s_read_reg(info, EP93XX_I2S_RX0EN) & 0x1) == 0) {\n\t\t \n\t\tclk_prepare_enable(info->mclk);\n\t\tclk_prepare_enable(info->sclk);\n\t\tclk_prepare_enable(info->lrclk);\n\n\t\t \n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_GLCTRL, 1);\n\t}\n\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tbase_reg = EP93XX_I2S_TX0EN;\n\telse\n\t\tbase_reg = EP93XX_I2S_RX0EN;\n\tep93xx_i2s_write_reg(info, base_reg, 1);\n\n\t \n\tif (IS_ENABLED(CONFIG_SND_EP93XX_SOC_I2S_WATCHDOG) &&\n\t    stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_TXCTRL,\n\t\t\t\t     EP93XX_I2S_TXCTRL_TXEMPTY_LVL |\n\t\t\t\t     EP93XX_I2S_TXCTRL_TXUFIE);\n}\n\nstatic void ep93xx_i2s_disable(struct ep93xx_i2s_info *info, int stream)\n{\n\tunsigned base_reg;\n\n\t \n\tif (IS_ENABLED(CONFIG_SND_EP93XX_SOC_I2S_WATCHDOG) &&\n\t    stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_TXCTRL, 0);\n\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tbase_reg = EP93XX_I2S_TX0EN;\n\telse\n\t\tbase_reg = EP93XX_I2S_RX0EN;\n\tep93xx_i2s_write_reg(info, base_reg, 0);\n\n\tif ((ep93xx_i2s_read_reg(info, EP93XX_I2S_TX0EN) & 0x1) == 0 &&\n\t    (ep93xx_i2s_read_reg(info, EP93XX_I2S_RX0EN) & 0x1) == 0) {\n\t\t \n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_GLCTRL, 0);\n\n\t\t \n\t\tclk_disable_unprepare(info->lrclk);\n\t\tclk_disable_unprepare(info->sclk);\n\t\tclk_disable_unprepare(info->mclk);\n\t}\n}\n\n \nstatic irqreturn_t ep93xx_i2s_interrupt(int irq, void *dev_id)\n{\n\tstruct ep93xx_i2s_info *info = dev_id;\n\n\t \n\tep93xx_i2s_write_reg(info, EP93XX_I2S_TX0EN, 0);\n\t \n\twhile (!(ep93xx_i2s_read_reg(info, EP93XX_I2S_GLSTS) &\n\t\t EP93XX_I2S_GLSTS_TX0_FIFO_FULL)) {\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_I2STX0LFT, 0);\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_I2STX0RT, 0);\n\t}\n\t \n\tep93xx_i2s_write_reg(info, EP93XX_I2S_TX0EN, 1);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ep93xx_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);\n\n\tinfo->dma_params_tx.filter_data =\n\t\t&ep93xx_i2s_dma_data[SNDRV_PCM_STREAM_PLAYBACK];\n\tinfo->dma_params_rx.filter_data =\n\t\t&ep93xx_i2s_dma_data[SNDRV_PCM_STREAM_CAPTURE];\n\n\tsnd_soc_dai_init_dma_data(dai,\t&info->dma_params_tx,\n\t\t\t\t\t&info->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic int ep93xx_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);\n\n\tep93xx_i2s_enable(info, substream->stream);\n\n\treturn 0;\n}\n\nstatic void ep93xx_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);\n\n\tep93xx_i2s_disable(info, substream->stream);\n}\n\nstatic int ep93xx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int clk_cfg;\n\tunsigned int txlin_ctrl = 0;\n\tunsigned int rxlin_ctrl = 0;\n\n\tclk_cfg  = ep93xx_i2s_read_reg(info, EP93XX_I2S_RXCLKCFG);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tclk_cfg |= EP93XX_I2S_CLKCFG_REL;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tclk_cfg &= ~EP93XX_I2S_CLKCFG_REL;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tclk_cfg &= ~EP93XX_I2S_CLKCFG_REL;\n\t\trxlin_ctrl |= EP93XX_I2S_RXLINCTRLDATA_R_JUST;\n\t\ttxlin_ctrl |= EP93XX_I2S_TXLINCTRLDATA_R_JUST;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tclk_cfg |= EP93XX_I2S_CLKCFG_MASTER;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tclk_cfg &= ~EP93XX_I2S_CLKCFG_MASTER;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tclk_cfg &= ~(EP93XX_I2S_CLKCFG_CKP | EP93XX_I2S_CLKCFG_LRS);\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t \n\t\tclk_cfg &= ~EP93XX_I2S_CLKCFG_CKP;\n\t\tclk_cfg |= EP93XX_I2S_CLKCFG_LRS;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tclk_cfg |= EP93XX_I2S_CLKCFG_CKP;\n\t\tclk_cfg &= ~EP93XX_I2S_CLKCFG_LRS;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\tclk_cfg |= EP93XX_I2S_CLKCFG_CKP | EP93XX_I2S_CLKCFG_LRS;\n\t\tbreak;\n\t}\n\n\t \n\tep93xx_i2s_write_reg(info, EP93XX_I2S_RXCLKCFG, clk_cfg);\n\tep93xx_i2s_write_reg(info, EP93XX_I2S_TXCLKCFG, clk_cfg);\n\tep93xx_i2s_write_reg(info, EP93XX_I2S_RXLINCTRLDATA, rxlin_ctrl);\n\tep93xx_i2s_write_reg(info, EP93XX_I2S_TXLINCTRLDATA, txlin_ctrl);\n\treturn 0;\n}\n\nstatic int ep93xx_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(dai);\n\tunsigned word_len, div, sdiv, lrdiv;\n\tint err;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tword_len = EP93XX_I2S_WRDLEN_16;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tword_len = EP93XX_I2S_WRDLEN_24;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tword_len = EP93XX_I2S_WRDLEN_32;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_TXWRDLEN, word_len);\n\telse\n\t\tep93xx_i2s_write_reg(info, EP93XX_I2S_RXWRDLEN, word_len);\n\n\t \n\tdiv = clk_get_rate(info->mclk) / params_rate(params);\n\tsdiv = 4;\n\tif (div > (256 + 512) / 2) {\n\t\tlrdiv = 128;\n\t} else {\n\t\tlrdiv = 64;\n\t\tif (div < (128 + 256) / 2)\n\t\t\tsdiv = 2;\n\t}\n\n\terr = clk_set_rate(info->sclk, clk_get_rate(info->mclk) / sdiv);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_set_rate(info->lrclk, clk_get_rate(info->sclk) / lrdiv);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ep93xx_i2s_set_sysclk(struct snd_soc_dai *cpu_dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (dir == SND_SOC_CLOCK_IN || clk_id != 0)\n\t\treturn -EINVAL;\n\tif (!freq)\n\t\treturn 0;\n\n\treturn clk_set_rate(info->mclk, freq);\n}\n\n#ifdef CONFIG_PM\nstatic int ep93xx_i2s_suspend(struct snd_soc_component *component)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_component_get_drvdata(component);\n\n\tif (!snd_soc_component_active(component))\n\t\treturn 0;\n\n\tep93xx_i2s_disable(info, SNDRV_PCM_STREAM_PLAYBACK);\n\tep93xx_i2s_disable(info, SNDRV_PCM_STREAM_CAPTURE);\n\n\treturn 0;\n}\n\nstatic int ep93xx_i2s_resume(struct snd_soc_component *component)\n{\n\tstruct ep93xx_i2s_info *info = snd_soc_component_get_drvdata(component);\n\n\tif (!snd_soc_component_active(component))\n\t\treturn 0;\n\n\tep93xx_i2s_enable(info, SNDRV_PCM_STREAM_PLAYBACK);\n\tep93xx_i2s_enable(info, SNDRV_PCM_STREAM_CAPTURE);\n\n\treturn 0;\n}\n#else\n#define ep93xx_i2s_suspend\tNULL\n#define ep93xx_i2s_resume\tNULL\n#endif\n\nstatic const struct snd_soc_dai_ops ep93xx_i2s_dai_ops = {\n\t.probe\t\t= ep93xx_i2s_dai_probe,\n\t.startup\t= ep93xx_i2s_startup,\n\t.shutdown\t= ep93xx_i2s_shutdown,\n\t.hw_params\t= ep93xx_i2s_hw_params,\n\t.set_sysclk\t= ep93xx_i2s_set_sysclk,\n\t.set_fmt\t= ep93xx_i2s_set_dai_fmt,\n};\n\n#define EP93XX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver ep93xx_i2s_dai = {\n\t.symmetric_rate\t= 1,\n\t.playback\t= {\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= EP93XX_I2S_FORMATS,\n\t},\n\t.capture\t= {\n\t\t .channels_min\t= 2,\n\t\t .channels_max\t= 2,\n\t\t .rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t .formats\t= EP93XX_I2S_FORMATS,\n\t},\n\t.ops\t\t= &ep93xx_i2s_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver ep93xx_i2s_component = {\n\t.name\t\t\t= \"ep93xx-i2s\",\n\t.suspend\t\t= ep93xx_i2s_suspend,\n\t.resume\t\t\t= ep93xx_i2s_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int ep93xx_i2s_probe(struct platform_device *pdev)\n{\n\tstruct ep93xx_i2s_info *info;\n\tint err;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(info->regs))\n\t\treturn PTR_ERR(info->regs);\n\n\tif (IS_ENABLED(CONFIG_SND_EP93XX_SOC_I2S_WATCHDOG)) {\n\t\tint irq = platform_get_irq(pdev, 0);\n\t\tif (irq <= 0)\n\t\t\treturn irq < 0 ? irq : -ENODEV;\n\n\t\terr = devm_request_irq(&pdev->dev, irq, ep93xx_i2s_interrupt, 0,\n\t\t\t\t       pdev->name, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tinfo->mclk = clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(info->mclk)) {\n\t\terr = PTR_ERR(info->mclk);\n\t\tgoto fail;\n\t}\n\n\tinfo->sclk = clk_get(&pdev->dev, \"sclk\");\n\tif (IS_ERR(info->sclk)) {\n\t\terr = PTR_ERR(info->sclk);\n\t\tgoto fail_put_mclk;\n\t}\n\n\tinfo->lrclk = clk_get(&pdev->dev, \"lrclk\");\n\tif (IS_ERR(info->lrclk)) {\n\t\terr = PTR_ERR(info->lrclk);\n\t\tgoto fail_put_sclk;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, info);\n\n\terr = devm_snd_soc_register_component(&pdev->dev, &ep93xx_i2s_component,\n\t\t\t\t\t &ep93xx_i2s_dai, 1);\n\tif (err)\n\t\tgoto fail_put_lrclk;\n\n\terr = devm_ep93xx_pcm_platform_register(&pdev->dev);\n\tif (err)\n\t\tgoto fail_put_lrclk;\n\n\treturn 0;\n\nfail_put_lrclk:\n\tclk_put(info->lrclk);\nfail_put_sclk:\n\tclk_put(info->sclk);\nfail_put_mclk:\n\tclk_put(info->mclk);\nfail:\n\treturn err;\n}\n\nstatic void ep93xx_i2s_remove(struct platform_device *pdev)\n{\n\tstruct ep93xx_i2s_info *info = dev_get_drvdata(&pdev->dev);\n\n\tclk_put(info->lrclk);\n\tclk_put(info->sclk);\n\tclk_put(info->mclk);\n}\n\nstatic const struct of_device_id ep93xx_i2s_of_ids[] = {\n\t{ .compatible = \"cirrus,ep9301-i2s\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ep93xx_i2s_of_ids);\n\nstatic struct platform_driver ep93xx_i2s_driver = {\n\t.probe\t= ep93xx_i2s_probe,\n\t.remove_new = ep93xx_i2s_remove,\n\t.driver\t= {\n\t\t.name\t= \"ep93xx-i2s\",\n\t\t.of_match_table = ep93xx_i2s_of_ids,\n\t},\n};\n\nmodule_platform_driver(ep93xx_i2s_driver);\n\nMODULE_ALIAS(\"platform:ep93xx-i2s\");\nMODULE_AUTHOR(\"Ryan Mallon\");\nMODULE_DESCRIPTION(\"EP93XX I2S driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}