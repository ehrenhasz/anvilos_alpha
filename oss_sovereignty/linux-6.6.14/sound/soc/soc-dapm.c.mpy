{
  "module_name": "soc-dapm.c",
  "hash_id": "bd9fb6c7fd856914e9bfd16e912c8e065e92fdd2870f8faee2db0bd4483404c4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-dapm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/async.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/platform_device.h>\n#include <linux/jiffies.h>\n#include <linux/debugfs.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include <trace/events/asoc.h>\n\n#define DAPM_UPDATE_STAT(widget, val) widget->dapm->card->dapm_stats.val++;\n\n#define SND_SOC_DAPM_DIR_REVERSE(x) ((x == SND_SOC_DAPM_DIR_IN) ? \\\n\tSND_SOC_DAPM_DIR_OUT : SND_SOC_DAPM_DIR_IN)\n\n#define snd_soc_dapm_for_each_direction(dir) \\\n\tfor ((dir) = SND_SOC_DAPM_DIR_IN; (dir) <= SND_SOC_DAPM_DIR_OUT; \\\n\t\t(dir)++)\n\nstatic int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,\n\tconst char *control,\n\tint (*connected)(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink));\n\nstruct snd_soc_dapm_widget *\nsnd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,\n\t\t\t const struct snd_soc_dapm_widget *widget);\n\nstruct snd_soc_dapm_widget *\nsnd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t const struct snd_soc_dapm_widget *widget);\n\nstatic unsigned int soc_dapm_read(struct snd_soc_dapm_context *dapm, int reg);\n\n \nstatic int dapm_up_seq[] = {\n\t[snd_soc_dapm_pre] = 1,\n\t[snd_soc_dapm_regulator_supply] = 2,\n\t[snd_soc_dapm_pinctrl] = 2,\n\t[snd_soc_dapm_clock_supply] = 2,\n\t[snd_soc_dapm_supply] = 3,\n\t[snd_soc_dapm_dai_link] = 3,\n\t[snd_soc_dapm_micbias] = 4,\n\t[snd_soc_dapm_vmid] = 4,\n\t[snd_soc_dapm_dai_in] = 5,\n\t[snd_soc_dapm_dai_out] = 5,\n\t[snd_soc_dapm_aif_in] = 5,\n\t[snd_soc_dapm_aif_out] = 5,\n\t[snd_soc_dapm_mic] = 6,\n\t[snd_soc_dapm_siggen] = 6,\n\t[snd_soc_dapm_input] = 6,\n\t[snd_soc_dapm_output] = 6,\n\t[snd_soc_dapm_mux] = 7,\n\t[snd_soc_dapm_demux] = 7,\n\t[snd_soc_dapm_dac] = 8,\n\t[snd_soc_dapm_switch] = 9,\n\t[snd_soc_dapm_mixer] = 9,\n\t[snd_soc_dapm_mixer_named_ctl] = 9,\n\t[snd_soc_dapm_pga] = 10,\n\t[snd_soc_dapm_buffer] = 10,\n\t[snd_soc_dapm_scheduler] = 10,\n\t[snd_soc_dapm_effect] = 10,\n\t[snd_soc_dapm_src] = 10,\n\t[snd_soc_dapm_asrc] = 10,\n\t[snd_soc_dapm_encoder] = 10,\n\t[snd_soc_dapm_decoder] = 10,\n\t[snd_soc_dapm_adc] = 11,\n\t[snd_soc_dapm_out_drv] = 12,\n\t[snd_soc_dapm_hp] = 12,\n\t[snd_soc_dapm_line] = 12,\n\t[snd_soc_dapm_sink] = 12,\n\t[snd_soc_dapm_spk] = 13,\n\t[snd_soc_dapm_kcontrol] = 14,\n\t[snd_soc_dapm_post] = 15,\n};\n\nstatic int dapm_down_seq[] = {\n\t[snd_soc_dapm_pre] = 1,\n\t[snd_soc_dapm_kcontrol] = 2,\n\t[snd_soc_dapm_adc] = 3,\n\t[snd_soc_dapm_spk] = 4,\n\t[snd_soc_dapm_hp] = 5,\n\t[snd_soc_dapm_line] = 5,\n\t[snd_soc_dapm_out_drv] = 5,\n\t[snd_soc_dapm_sink] = 6,\n\t[snd_soc_dapm_pga] = 6,\n\t[snd_soc_dapm_buffer] = 6,\n\t[snd_soc_dapm_scheduler] = 6,\n\t[snd_soc_dapm_effect] = 6,\n\t[snd_soc_dapm_src] = 6,\n\t[snd_soc_dapm_asrc] = 6,\n\t[snd_soc_dapm_encoder] = 6,\n\t[snd_soc_dapm_decoder] = 6,\n\t[snd_soc_dapm_switch] = 7,\n\t[snd_soc_dapm_mixer_named_ctl] = 7,\n\t[snd_soc_dapm_mixer] = 7,\n\t[snd_soc_dapm_dac] = 8,\n\t[snd_soc_dapm_mic] = 9,\n\t[snd_soc_dapm_siggen] = 9,\n\t[snd_soc_dapm_input] = 9,\n\t[snd_soc_dapm_output] = 9,\n\t[snd_soc_dapm_micbias] = 10,\n\t[snd_soc_dapm_vmid] = 10,\n\t[snd_soc_dapm_mux] = 11,\n\t[snd_soc_dapm_demux] = 11,\n\t[snd_soc_dapm_aif_in] = 12,\n\t[snd_soc_dapm_aif_out] = 12,\n\t[snd_soc_dapm_dai_in] = 12,\n\t[snd_soc_dapm_dai_out] = 12,\n\t[snd_soc_dapm_dai_link] = 13,\n\t[snd_soc_dapm_supply] = 14,\n\t[snd_soc_dapm_clock_supply] = 15,\n\t[snd_soc_dapm_pinctrl] = 15,\n\t[snd_soc_dapm_regulator_supply] = 15,\n\t[snd_soc_dapm_post] = 16,\n};\n\nstatic void dapm_assert_locked(struct snd_soc_dapm_context *dapm)\n{\n\tif (snd_soc_card_is_instantiated(dapm->card))\n\t\tsnd_soc_dapm_mutex_assert_held(dapm);\n}\n\nstatic void pop_wait(u32 pop_time)\n{\n\tif (pop_time)\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(pop_time));\n}\n\n__printf(3, 4)\nstatic void pop_dbg(struct device *dev, u32 pop_time, const char *fmt, ...)\n{\n\tva_list args;\n\tchar *buf;\n\n\tif (!pop_time)\n\t\treturn;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(buf, PAGE_SIZE, fmt, args);\n\tdev_info(dev, \"%s\", buf);\n\tva_end(args);\n\n\tkfree(buf);\n}\n\nstatic bool dapm_dirty_widget(struct snd_soc_dapm_widget *w)\n{\n\treturn !list_empty(&w->dirty);\n}\n\nstatic void dapm_mark_dirty(struct snd_soc_dapm_widget *w, const char *reason)\n{\n\tdapm_assert_locked(w->dapm);\n\n\tif (!dapm_dirty_widget(w)) {\n\t\tdev_vdbg(w->dapm->dev, \"Marking %s dirty due to %s\\n\",\n\t\t\t w->name, reason);\n\t\tlist_add_tail(&w->dirty, &w->dapm->card->dapm_dirty);\n\t}\n}\n\n \nstatic __always_inline void dapm_widget_invalidate_paths(\n\tstruct snd_soc_dapm_widget *w, enum snd_soc_dapm_direction dir)\n{\n\tenum snd_soc_dapm_direction rdir = SND_SOC_DAPM_DIR_REVERSE(dir);\n\tstruct snd_soc_dapm_widget *node;\n\tstruct snd_soc_dapm_path *p;\n\tLIST_HEAD(list);\n\n\tdapm_assert_locked(w->dapm);\n\n\tif (w->endpoints[dir] == -1)\n\t\treturn;\n\n\tlist_add_tail(&w->work_list, &list);\n\tw->endpoints[dir] = -1;\n\n\tlist_for_each_entry(w, &list, work_list) {\n\t\tsnd_soc_dapm_widget_for_each_path(w, dir, p) {\n\t\t\tif (p->is_supply || p->weak || !p->connect)\n\t\t\t\tcontinue;\n\t\t\tnode = p->node[rdir];\n\t\t\tif (node->endpoints[dir] != -1) {\n\t\t\t\tnode->endpoints[dir] = -1;\n\t\t\t\tlist_add_tail(&node->work_list, &list);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void dapm_widget_invalidate_input_paths(struct snd_soc_dapm_widget *w)\n{\n\tdapm_widget_invalidate_paths(w, SND_SOC_DAPM_DIR_IN);\n}\n\n \nstatic void dapm_widget_invalidate_output_paths(struct snd_soc_dapm_widget *w)\n{\n\tdapm_widget_invalidate_paths(w, SND_SOC_DAPM_DIR_OUT);\n}\n\n \nstatic void dapm_path_invalidate(struct snd_soc_dapm_path *p)\n{\n\t \n\tif (p->weak || p->is_supply)\n\t\treturn;\n\n\t \n\tif (p->source->endpoints[SND_SOC_DAPM_DIR_IN] != 0)\n\t\tdapm_widget_invalidate_input_paths(p->sink);\n\tif (p->sink->endpoints[SND_SOC_DAPM_DIR_OUT] != 0)\n\t\tdapm_widget_invalidate_output_paths(p->source);\n}\n\nvoid dapm_mark_endpoints_dirty(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tsnd_soc_dapm_mutex_lock_root(card);\n\n\tfor_each_card_widgets(card, w) {\n\t\tif (w->is_ep) {\n\t\t\tdapm_mark_dirty(w, \"Rechecking endpoints\");\n\t\t\tif (w->is_ep & SND_SOC_DAPM_EP_SINK)\n\t\t\t\tdapm_widget_invalidate_output_paths(w);\n\t\t\tif (w->is_ep & SND_SOC_DAPM_EP_SOURCE)\n\t\t\t\tdapm_widget_invalidate_input_paths(w);\n\t\t}\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(card);\n}\nEXPORT_SYMBOL_GPL(dapm_mark_endpoints_dirty);\n\n \nstatic inline struct snd_soc_dapm_widget *dapm_cnew_widget(\n\tconst struct snd_soc_dapm_widget *_widget)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tw = kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);\n\tif (!w)\n\t\treturn NULL;\n\n\t \n\tif (_widget->sname) {\n\t\tw->sname = kstrdup_const(_widget->sname, GFP_KERNEL);\n\t\tif (!w->sname) {\n\t\t\tkfree(w);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn w;\n}\n\nstruct dapm_kcontrol_data {\n\tunsigned int value;\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct list_head paths;\n\tstruct snd_soc_dapm_widget_list *wlist;\n};\n\nstatic int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,\n\tstruct snd_kcontrol *kcontrol, const char *ctrl_name)\n{\n\tstruct dapm_kcontrol_data *data;\n\tstruct soc_mixer_control *mc;\n\tstruct soc_enum *e;\n\tconst char *name;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&data->paths);\n\n\tswitch (widget->id) {\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_mixer:\n\tcase snd_soc_dapm_mixer_named_ctl:\n\t\tmc = (struct soc_mixer_control *)kcontrol->private_value;\n\n\t\tif (mc->autodisable) {\n\t\t\tstruct snd_soc_dapm_widget template;\n\n\t\t\tif (snd_soc_volsw_is_stereo(mc))\n\t\t\t\tdev_warn(widget->dapm->dev,\n\t\t\t\t\t \"ASoC: Unsupported stereo autodisable control '%s'\\n\",\n\t\t\t\t\t ctrl_name);\n\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s %s\", ctrl_name,\n\t\t\t\t\t \"Autodisable\");\n\t\t\tif (!name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_data;\n\t\t\t}\n\n\t\t\tmemset(&template, 0, sizeof(template));\n\t\t\ttemplate.reg = mc->reg;\n\t\t\ttemplate.mask = (1 << fls(mc->max)) - 1;\n\t\t\ttemplate.shift = mc->shift;\n\t\t\tif (mc->invert)\n\t\t\t\ttemplate.off_val = mc->max;\n\t\t\telse\n\t\t\t\ttemplate.off_val = 0;\n\t\t\ttemplate.on_val = template.off_val;\n\t\t\ttemplate.id = snd_soc_dapm_kcontrol;\n\t\t\ttemplate.name = name;\n\n\t\t\tdata->value = template.on_val;\n\n\t\t\tdata->widget =\n\t\t\t\tsnd_soc_dapm_new_control_unlocked(widget->dapm,\n\t\t\t\t&template);\n\t\t\tkfree(name);\n\t\t\tif (IS_ERR(data->widget)) {\n\t\t\t\tret = PTR_ERR(data->widget);\n\t\t\t\tgoto err_data;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase snd_soc_dapm_demux:\n\tcase snd_soc_dapm_mux:\n\t\te = (struct soc_enum *)kcontrol->private_value;\n\n\t\tif (e->autodisable) {\n\t\t\tstruct snd_soc_dapm_widget template;\n\n\t\t\tname = kasprintf(GFP_KERNEL, \"%s %s\", ctrl_name,\n\t\t\t\t\t \"Autodisable\");\n\t\t\tif (!name) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_data;\n\t\t\t}\n\n\t\t\tmemset(&template, 0, sizeof(template));\n\t\t\ttemplate.reg = e->reg;\n\t\t\ttemplate.mask = e->mask;\n\t\t\ttemplate.shift = e->shift_l;\n\t\t\ttemplate.off_val = snd_soc_enum_item_to_val(e, 0);\n\t\t\ttemplate.on_val = template.off_val;\n\t\t\ttemplate.id = snd_soc_dapm_kcontrol;\n\t\t\ttemplate.name = name;\n\n\t\t\tdata->value = template.on_val;\n\n\t\t\tdata->widget = snd_soc_dapm_new_control_unlocked(\n\t\t\t\t\t\twidget->dapm, &template);\n\t\t\tkfree(name);\n\t\t\tif (IS_ERR(data->widget)) {\n\t\t\t\tret = PTR_ERR(data->widget);\n\t\t\t\tgoto err_data;\n\t\t\t}\n\n\t\t\tsnd_soc_dapm_add_path(widget->dapm, data->widget,\n\t\t\t\t\t      widget, NULL, NULL);\n\t\t} else if (e->reg != SND_SOC_NOPM) {\n\t\t\tdata->value = soc_dapm_read(widget->dapm, e->reg) &\n\t\t\t\t      (e->mask << e->shift_l);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkcontrol->private_data = data;\n\n\treturn 0;\n\nerr_data:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic void dapm_kcontrol_free(struct snd_kcontrol *kctl)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kctl);\n\n\tlist_del(&data->paths);\n\tkfree(data->wlist);\n\tkfree(data);\n}\n\nstatic struct snd_soc_dapm_widget_list *dapm_kcontrol_get_wlist(\n\tconst struct snd_kcontrol *kcontrol)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\treturn data->wlist;\n}\n\nstatic int dapm_kcontrol_add_widget(struct snd_kcontrol *kcontrol,\n\tstruct snd_soc_dapm_widget *widget)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_widget_list *new_wlist;\n\tunsigned int n;\n\n\tif (data->wlist)\n\t\tn = data->wlist->num_widgets + 1;\n\telse\n\t\tn = 1;\n\n\tnew_wlist = krealloc(data->wlist,\n\t\t\t     struct_size(new_wlist, widgets, n),\n\t\t\t     GFP_KERNEL);\n\tif (!new_wlist)\n\t\treturn -ENOMEM;\n\n\tnew_wlist->widgets[n - 1] = widget;\n\tnew_wlist->num_widgets = n;\n\n\tdata->wlist = new_wlist;\n\n\treturn 0;\n}\n\nstatic void dapm_kcontrol_add_path(const struct snd_kcontrol *kcontrol,\n\tstruct snd_soc_dapm_path *path)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\tlist_add_tail(&path->list_kcontrol, &data->paths);\n}\n\nstatic bool dapm_kcontrol_is_powered(const struct snd_kcontrol *kcontrol)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\tif (!data->widget)\n\t\treturn true;\n\n\treturn data->widget->power;\n}\n\nstatic struct list_head *dapm_kcontrol_get_path_list(\n\tconst struct snd_kcontrol *kcontrol)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\treturn &data->paths;\n}\n\n#define dapm_kcontrol_for_each_path(path, kcontrol) \\\n\tlist_for_each_entry(path, dapm_kcontrol_get_path_list(kcontrol), \\\n\t\tlist_kcontrol)\n\nunsigned int dapm_kcontrol_get_value(const struct snd_kcontrol *kcontrol)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\treturn data->value;\n}\nEXPORT_SYMBOL_GPL(dapm_kcontrol_get_value);\n\nstatic bool dapm_kcontrol_set_value(const struct snd_kcontrol *kcontrol,\n\tunsigned int value)\n{\n\tstruct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol);\n\n\tif (data->value == value)\n\t\treturn false;\n\n\tif (data->widget) {\n\t\tswitch (dapm_kcontrol_get_wlist(kcontrol)->widgets[0]->id) {\n\t\tcase snd_soc_dapm_switch:\n\t\tcase snd_soc_dapm_mixer:\n\t\tcase snd_soc_dapm_mixer_named_ctl:\n\t\t\tdata->widget->on_val = value & data->widget->mask;\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_demux:\n\t\tcase snd_soc_dapm_mux:\n\t\t\tdata->widget->on_val = value >> data->widget->shift;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdata->widget->on_val = value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdata->value = value;\n\n\treturn true;\n}\n\n \nstruct snd_soc_dapm_widget *snd_soc_dapm_kcontrol_widget(\n\t\t\t\tstruct snd_kcontrol *kcontrol)\n{\n\treturn dapm_kcontrol_get_wlist(kcontrol)->widgets[0];\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_widget);\n\n \nstruct snd_soc_dapm_context *snd_soc_dapm_kcontrol_dapm(\n\tstruct snd_kcontrol *kcontrol)\n{\n\treturn dapm_kcontrol_get_wlist(kcontrol)->widgets[0]->dapm;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_dapm);\n\nstatic void dapm_reset(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tsnd_soc_dapm_mutex_assert_held(card);\n\n\tmemset(&card->dapm_stats, 0, sizeof(card->dapm_stats));\n\n\tfor_each_card_widgets(card, w) {\n\t\tw->new_power = w->power;\n\t\tw->power_checked = false;\n\t}\n}\n\nstatic const char *soc_dapm_prefix(struct snd_soc_dapm_context *dapm)\n{\n\tif (!dapm->component)\n\t\treturn NULL;\n\treturn dapm->component->name_prefix;\n}\n\nstatic unsigned int soc_dapm_read(struct snd_soc_dapm_context *dapm, int reg)\n{\n\tif (!dapm->component)\n\t\treturn -EIO;\n\treturn  snd_soc_component_read(dapm->component, reg);\n}\n\nstatic int soc_dapm_update_bits(struct snd_soc_dapm_context *dapm,\n\tint reg, unsigned int mask, unsigned int value)\n{\n\tif (!dapm->component)\n\t\treturn -EIO;\n\treturn snd_soc_component_update_bits(dapm->component, reg,\n\t\t\t\t\t     mask, value);\n}\n\nstatic int soc_dapm_test_bits(struct snd_soc_dapm_context *dapm,\n\tint reg, unsigned int mask, unsigned int value)\n{\n\tif (!dapm->component)\n\t\treturn -EIO;\n\treturn snd_soc_component_test_bits(dapm->component, reg, mask, value);\n}\n\nstatic void soc_dapm_async_complete(struct snd_soc_dapm_context *dapm)\n{\n\tif (dapm->component)\n\t\tsnd_soc_component_async_complete(dapm->component);\n}\n\nstatic struct snd_soc_dapm_widget *\ndapm_wcache_lookup(struct snd_soc_dapm_widget *w, const char *name)\n{\n\tif (w) {\n\t\tstruct list_head *wlist = &w->dapm->card->widgets;\n\t\tconst int depth = 2;\n\t\tint i = 0;\n\n\t\tlist_for_each_entry_from(w, wlist, list) {\n\t\t\tif (!strcmp(name, w->name))\n\t\t\t\treturn w;\n\n\t\t\tif (++i == depth)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nint snd_soc_dapm_force_bias_level(struct snd_soc_dapm_context *dapm,\n\tenum snd_soc_bias_level level)\n{\n\tint ret = 0;\n\n\tif (dapm->component)\n\t\tret = snd_soc_component_set_bias_level(dapm->component, level);\n\n\tif (ret == 0)\n\t\tdapm->bias_level = level;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_force_bias_level);\n\n \nstatic int snd_soc_dapm_set_bias_level(struct snd_soc_dapm_context *dapm,\n\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tstruct snd_soc_card *card = dapm->card;\n\tint ret = 0;\n\n\ttrace_snd_soc_bias_level_start(card, level);\n\n\tret = snd_soc_card_set_bias_level(card, dapm, level);\n\tif (ret != 0)\n\t\tgoto out;\n\n\tif (!card || dapm != &card->dapm)\n\t\tret = snd_soc_dapm_force_bias_level(dapm, level);\n\n\tif (ret != 0)\n\t\tgoto out;\n\n\tret = snd_soc_card_set_bias_level_post(card, dapm, level);\nout:\n\ttrace_snd_soc_bias_level_done(card, level);\n\n\treturn ret;\n}\n\n \nstatic int dapm_connect_mux(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_path *path, const char *control_name,\n\tstruct snd_soc_dapm_widget *w)\n{\n\tconst struct snd_kcontrol_new *kcontrol = &w->kcontrol_news[0];\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int item;\n\tint i;\n\n\tif (e->reg != SND_SOC_NOPM) {\n\t\tunsigned int val;\n\t\tval = soc_dapm_read(dapm, e->reg);\n\t\tval = (val >> e->shift_l) & e->mask;\n\t\titem = snd_soc_enum_val_to_item(e, val);\n\t} else {\n\t\t \n\t\titem = 0;\n\t}\n\n\ti = match_string(e->texts, e->items, control_name);\n\tif (i < 0)\n\t\treturn -ENODEV;\n\n\tpath->name = e->texts[i];\n\tpath->connect = (i == item);\n\treturn 0;\n\n}\n\n \nstatic void dapm_set_mixer_path_status(struct snd_soc_dapm_path *p, int i,\n\t\t\t\t       int nth_path)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)\n\t\tp->sink->kcontrol_news[i].private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int invert = mc->invert;\n\n\tif (reg != SND_SOC_NOPM) {\n\t\tunsigned int shift = mc->shift;\n\t\tunsigned int max = mc->max;\n\t\tunsigned int mask = (1 << fls(max)) - 1;\n\t\tunsigned int val = soc_dapm_read(p->sink->dapm, reg);\n\n\t\t \n\t\tif (snd_soc_volsw_is_stereo(mc) && nth_path > 0) {\n\t\t\tif (reg != mc->rreg)\n\t\t\t\tval = soc_dapm_read(p->sink->dapm, mc->rreg);\n\t\t\tval = (val >> mc->rshift) & mask;\n\t\t} else {\n\t\t\tval = (val >> shift) & mask;\n\t\t}\n\t\tif (invert)\n\t\t\tval = max - val;\n\t\tp->connect = !!val;\n\t} else {\n\t\t \n\t\tp->connect = invert;\n\t}\n}\n\n \nstatic int dapm_connect_mixer(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_path *path, const char *control_name)\n{\n\tint i, nth_path = 0;\n\n\t \n\tfor (i = 0; i < path->sink->num_kcontrols; i++) {\n\t\tif (!strcmp(control_name, path->sink->kcontrol_news[i].name)) {\n\t\t\tpath->name = path->sink->kcontrol_news[i].name;\n\t\t\tdapm_set_mixer_path_status(path, i, nth_path++);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENODEV;\n}\n\nstatic int dapm_is_shared_kcontrol(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_widget *kcontrolw,\n\tconst struct snd_kcontrol_new *kcontrol_new,\n\tstruct snd_kcontrol **kcontrol)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tint i;\n\n\t*kcontrol = NULL;\n\n\tfor_each_card_widgets(dapm->card, w) {\n\t\tif (w == kcontrolw || w->dapm != kcontrolw->dapm)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\t\tif (&w->kcontrol_news[i] == kcontrol_new) {\n\t\t\t\tif (w->kcontrols)\n\t\t\t\t\t*kcontrol = w->kcontrols[i];\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dapm_create_or_share_kcontrol(struct snd_soc_dapm_widget *w,\n\tint kci)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct snd_card *card = dapm->card->snd_card;\n\tconst char *prefix;\n\tsize_t prefix_len;\n\tint shared;\n\tstruct snd_kcontrol *kcontrol;\n\tbool wname_in_long_name, kcname_in_long_name;\n\tchar *long_name = NULL;\n\tconst char *name;\n\tint ret = 0;\n\n\tprefix = soc_dapm_prefix(dapm);\n\tif (prefix)\n\t\tprefix_len = strlen(prefix) + 1;\n\telse\n\t\tprefix_len = 0;\n\n\tshared = dapm_is_shared_kcontrol(dapm, w, &w->kcontrol_news[kci],\n\t\t\t\t\t &kcontrol);\n\n\tif (!kcontrol) {\n\t\tif (shared) {\n\t\t\twname_in_long_name = false;\n\t\t\tkcname_in_long_name = true;\n\t\t} else {\n\t\t\tswitch (w->id) {\n\t\t\tcase snd_soc_dapm_switch:\n\t\t\tcase snd_soc_dapm_mixer:\n\t\t\tcase snd_soc_dapm_pga:\n\t\t\tcase snd_soc_dapm_effect:\n\t\t\tcase snd_soc_dapm_out_drv:\n\t\t\t\twname_in_long_name = true;\n\t\t\t\tkcname_in_long_name = true;\n\t\t\t\tbreak;\n\t\t\tcase snd_soc_dapm_mixer_named_ctl:\n\t\t\t\twname_in_long_name = false;\n\t\t\t\tkcname_in_long_name = true;\n\t\t\t\tbreak;\n\t\t\tcase snd_soc_dapm_demux:\n\t\t\tcase snd_soc_dapm_mux:\n\t\t\t\twname_in_long_name = true;\n\t\t\t\tkcname_in_long_name = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (w->no_wname_in_kcontrol_name)\n\t\t\twname_in_long_name = false;\n\n\t\tif (wname_in_long_name && kcname_in_long_name) {\n\t\t\t \n\t\t\tlong_name = kasprintf(GFP_KERNEL, \"%s %s\",\n\t\t\t\t w->name + prefix_len,\n\t\t\t\t w->kcontrol_news[kci].name);\n\t\t\tif (long_name == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tname = long_name;\n\t\t} else if (wname_in_long_name) {\n\t\t\tlong_name = NULL;\n\t\t\tname = w->name + prefix_len;\n\t\t} else {\n\t\t\tlong_name = NULL;\n\t\t\tname = w->kcontrol_news[kci].name;\n\t\t}\n\n\t\tkcontrol = snd_soc_cnew(&w->kcontrol_news[kci], NULL, name,\n\t\t\t\t\tprefix);\n\t\tif (!kcontrol) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tkcontrol->private_free = dapm_kcontrol_free;\n\n\t\tret = dapm_kcontrol_data_alloc(w, kcontrol, name);\n\t\tif (ret) {\n\t\t\tsnd_ctl_free_one(kcontrol);\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tret = snd_ctl_add(card, kcontrol);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dapm->dev,\n\t\t\t\t\"ASoC: failed to add widget %s dapm kcontrol %s: %d\\n\",\n\t\t\t\tw->name, name, ret);\n\t\t\tgoto exit_free;\n\t\t}\n\t}\n\n\tret = dapm_kcontrol_add_widget(kcontrol, w);\n\tif (ret == 0)\n\t\tw->kcontrols[kci] = kcontrol;\n\nexit_free:\n\tkfree(long_name);\n\n\treturn ret;\n}\n\n \nstatic int dapm_new_mixer(struct snd_soc_dapm_widget *w)\n{\n\tint i, ret;\n\tstruct snd_soc_dapm_path *path;\n\tstruct dapm_kcontrol_data *data;\n\n\t \n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\t \n\t\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\t\t \n\t\t\tif (path->name != (char *)w->kcontrol_news[i].name)\n\t\t\t\tcontinue;\n\n\t\t\tif (!w->kcontrols[i]) {\n\t\t\t\tret = dapm_create_or_share_kcontrol(w, i);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdapm_kcontrol_add_path(w->kcontrols[i], path);\n\n\t\t\tdata = snd_kcontrol_chip(w->kcontrols[i]);\n\t\t\tif (data->widget)\n\t\t\t\tsnd_soc_dapm_add_path(data->widget->dapm,\n\t\t\t\t\t\t      data->widget,\n\t\t\t\t\t\t      path->source,\n\t\t\t\t\t\t      NULL, NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dapm_new_mux(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tenum snd_soc_dapm_direction dir;\n\tstruct snd_soc_dapm_path *path;\n\tconst char *type;\n\tint ret;\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_mux:\n\t\tdir = SND_SOC_DAPM_DIR_OUT;\n\t\ttype = \"mux\";\n\t\tbreak;\n\tcase snd_soc_dapm_demux:\n\t\tdir = SND_SOC_DAPM_DIR_IN;\n\t\ttype = \"demux\";\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (w->num_kcontrols != 1) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"ASoC: %s %s has incorrect number of controls\\n\", type,\n\t\t\tw->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (list_empty(&w->edges[dir])) {\n\t\tdev_err(dapm->dev, \"ASoC: %s %s has no paths\\n\", type, w->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dapm_create_or_share_kcontrol(w, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnd_soc_dapm_widget_for_each_path(w, dir, path) {\n\t\tif (path->name)\n\t\t\tdapm_kcontrol_add_path(w->kcontrols[0], path);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dapm_new_pga(struct snd_soc_dapm_widget *w)\n{\n\tint i;\n\n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tint ret = dapm_create_or_share_kcontrol(w, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dapm_new_dai_link(struct snd_soc_dapm_widget *w)\n{\n\tint i;\n\tstruct snd_soc_pcm_runtime *rtd = w->priv;\n\n\t \n\tif (rtd->dai_link->num_c2c_params <= 1)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < w->num_kcontrols; i++) {\n\t\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\t\tstruct snd_card *card = dapm->card->snd_card;\n\t\tstruct snd_kcontrol *kcontrol = snd_soc_cnew(&w->kcontrol_news[i],\n\t\t\t\t\t\t\t     w, w->name, NULL);\n\t\tint ret = snd_ctl_add(card, kcontrol);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(dapm->dev,\n\t\t\t\t\"ASoC: failed to add widget %s dapm kcontrol %s: %d\\n\",\n\t\t\t\tw->name, w->kcontrol_news[i].name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tkcontrol->private_data = w;\n\t\tw->kcontrols[i] = kcontrol;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int snd_soc_dapm_suspend_check(struct snd_soc_dapm_widget *widget)\n{\n\tint level = snd_power_get_state(widget->dapm->card->snd_card);\n\n\tswitch (level) {\n\tcase SNDRV_CTL_POWER_D3hot:\n\tcase SNDRV_CTL_POWER_D3cold:\n\t\tif (widget->ignore_suspend)\n\t\t\tdev_dbg(widget->dapm->dev, \"ASoC: %s ignoring suspend\\n\",\n\t\t\t\twidget->name);\n\t\treturn widget->ignore_suspend;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void dapm_widget_list_free(struct snd_soc_dapm_widget_list **list)\n{\n\tkfree(*list);\n}\n\nstatic int dapm_widget_list_create(struct snd_soc_dapm_widget_list **list,\n\tstruct list_head *widgets)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tstruct list_head *it;\n\tunsigned int size = 0;\n\tunsigned int i = 0;\n\n\tlist_for_each(it, widgets)\n\t\tsize++;\n\n\t*list = kzalloc(struct_size(*list, widgets, size), GFP_KERNEL);\n\tif (*list == NULL)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(w, widgets, work_list)\n\t\t(*list)->widgets[i++] = w;\n\n\t(*list)->num_widgets = i;\n\n\treturn 0;\n}\n\n \nstatic void invalidate_paths_ep(struct snd_soc_dapm_widget *widget,\n\tenum snd_soc_dapm_direction dir)\n{\n\tenum snd_soc_dapm_direction rdir = SND_SOC_DAPM_DIR_REVERSE(dir);\n\tstruct snd_soc_dapm_path *path;\n\n\twidget->endpoints[dir] = -1;\n\n\tsnd_soc_dapm_widget_for_each_path(widget, rdir, path) {\n\t\tif (path->weak || path->is_supply)\n\t\t\tcontinue;\n\n\t\tif (path->walking)\n\t\t\treturn;\n\n\t\tif (path->connect) {\n\t\t\tpath->walking = 1;\n\t\t\tinvalidate_paths_ep(path->node[dir], dir);\n\t\t\tpath->walking = 0;\n\t\t}\n\t}\n}\n\n \nstatic __always_inline int is_connected_ep(struct snd_soc_dapm_widget *widget,\n\tstruct list_head *list, enum snd_soc_dapm_direction dir,\n\tint (*fn)(struct snd_soc_dapm_widget *, struct list_head *,\n\t\t  bool (*custom_stop_condition)(struct snd_soc_dapm_widget *,\n\t\t\t\t\t\tenum snd_soc_dapm_direction)),\n\tbool (*custom_stop_condition)(struct snd_soc_dapm_widget *,\n\t\t\t\t      enum snd_soc_dapm_direction))\n{\n\tenum snd_soc_dapm_direction rdir = SND_SOC_DAPM_DIR_REVERSE(dir);\n\tstruct snd_soc_dapm_path *path;\n\tint con = 0;\n\n\tif (widget->endpoints[dir] >= 0)\n\t\treturn widget->endpoints[dir];\n\n\tDAPM_UPDATE_STAT(widget, path_checks);\n\n\t \n\tif (list)\n\t\tlist_add_tail(&widget->work_list, list);\n\n\tif (custom_stop_condition && custom_stop_condition(widget, dir)) {\n\t\tlist = NULL;\n\t\tcustom_stop_condition = NULL;\n\t}\n\n\tif ((widget->is_ep & SND_SOC_DAPM_DIR_TO_EP(dir)) && widget->connected) {\n\t\twidget->endpoints[dir] = snd_soc_dapm_suspend_check(widget);\n\t\treturn widget->endpoints[dir];\n\t}\n\n\tsnd_soc_dapm_widget_for_each_path(widget, rdir, path) {\n\t\tDAPM_UPDATE_STAT(widget, neighbour_checks);\n\n\t\tif (path->weak || path->is_supply)\n\t\t\tcontinue;\n\n\t\tif (path->walking)\n\t\t\treturn 1;\n\n\t\ttrace_snd_soc_dapm_path(widget, dir, path);\n\n\t\tif (path->connect) {\n\t\t\tpath->walking = 1;\n\t\t\tcon += fn(path->node[dir], list, custom_stop_condition);\n\t\t\tpath->walking = 0;\n\t\t}\n\t}\n\n\twidget->endpoints[dir] = con;\n\n\treturn con;\n}\n\n \nstatic int is_connected_output_ep(struct snd_soc_dapm_widget *widget,\n\tstruct list_head *list,\n\tbool (*custom_stop_condition)(struct snd_soc_dapm_widget *i,\n\t\t\t\t      enum snd_soc_dapm_direction))\n{\n\treturn is_connected_ep(widget, list, SND_SOC_DAPM_DIR_OUT,\n\t\t\tis_connected_output_ep, custom_stop_condition);\n}\n\n \nstatic int is_connected_input_ep(struct snd_soc_dapm_widget *widget,\n\tstruct list_head *list,\n\tbool (*custom_stop_condition)(struct snd_soc_dapm_widget *i,\n\t\t\t\t      enum snd_soc_dapm_direction))\n{\n\treturn is_connected_ep(widget, list, SND_SOC_DAPM_DIR_IN,\n\t\t\tis_connected_input_ep, custom_stop_condition);\n}\n\n \nint snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,\n\tstruct snd_soc_dapm_widget_list **list,\n\tbool (*custom_stop_condition)(struct snd_soc_dapm_widget *,\n\t\t\t\t      enum snd_soc_dapm_direction))\n{\n\tstruct snd_soc_card *card = dai->component->card;\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, stream);\n\tLIST_HEAD(widgets);\n\tint paths;\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tinvalidate_paths_ep(w, SND_SOC_DAPM_DIR_OUT);\n\t\tpaths = is_connected_output_ep(w, &widgets,\n\t\t\t\tcustom_stop_condition);\n\t} else {\n\t\tinvalidate_paths_ep(w, SND_SOC_DAPM_DIR_IN);\n\t\tpaths = is_connected_input_ep(w, &widgets,\n\t\t\t\tcustom_stop_condition);\n\t}\n\n\t \n\tlist_del(widgets.next);\n\n\tret = dapm_widget_list_create(list, &widgets);\n\tif (ret)\n\t\tpaths = ret;\n\n\ttrace_snd_soc_dapm_connected(paths, stream);\n\tsnd_soc_dapm_mutex_unlock(card);\n\n\treturn paths;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_dai_get_connected_widgets);\n\nvoid snd_soc_dapm_dai_free_widgets(struct snd_soc_dapm_widget_list **list)\n{\n\tdapm_widget_list_free(list);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_dai_free_widgets);\n\n \nint dapm_regulator_event(struct snd_soc_dapm_widget *w,\n\t\t   struct snd_kcontrol *kcontrol, int event)\n{\n\tint ret;\n\n\tsoc_dapm_async_complete(w->dapm);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\n\t\t\tret = regulator_allow_bypass(w->regulator, false);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_warn(w->dapm->dev,\n\t\t\t\t\t \"ASoC: Failed to unbypass %s: %d\\n\",\n\t\t\t\t\t w->name, ret);\n\t\t}\n\n\t\treturn regulator_enable(w->regulator);\n\t} else {\n\t\tif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\n\t\t\tret = regulator_allow_bypass(w->regulator, true);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_warn(w->dapm->dev,\n\t\t\t\t\t \"ASoC: Failed to bypass %s: %d\\n\",\n\t\t\t\t\t w->name, ret);\n\t\t}\n\n\t\treturn regulator_disable_deferred(w->regulator, w->shift);\n\t}\n}\nEXPORT_SYMBOL_GPL(dapm_regulator_event);\n\n \nint dapm_pinctrl_event(struct snd_soc_dapm_widget *w,\n\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_dapm_pinctrl_priv *priv = w->priv;\n\tstruct pinctrl *p = w->pinctrl;\n\tstruct pinctrl_state *s;\n\n\tif (!p || !priv)\n\t\treturn -EIO;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\ts = pinctrl_lookup_state(p, priv->active_state);\n\telse\n\t\ts = pinctrl_lookup_state(p, priv->sleep_state);\n\n\tif (IS_ERR(s))\n\t\treturn PTR_ERR(s);\n\n\treturn pinctrl_select_state(p, s);\n}\nEXPORT_SYMBOL_GPL(dapm_pinctrl_event);\n\n \nint dapm_clock_event(struct snd_soc_dapm_widget *w,\n\t\t   struct snd_kcontrol *kcontrol, int event)\n{\n\tif (!w->clk)\n\t\treturn -EIO;\n\n\tsoc_dapm_async_complete(w->dapm);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\treturn clk_prepare_enable(w->clk);\n\t} else {\n\t\tclk_disable_unprepare(w->clk);\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dapm_clock_event);\n\nstatic int dapm_widget_power_check(struct snd_soc_dapm_widget *w)\n{\n\tif (w->power_checked)\n\t\treturn w->new_power;\n\n\tif (w->force)\n\t\tw->new_power = 1;\n\telse\n\t\tw->new_power = w->power_check(w);\n\n\tw->power_checked = true;\n\n\treturn w->new_power;\n}\n\n \nstatic int dapm_generic_check_power(struct snd_soc_dapm_widget *w)\n{\n\tint in, out;\n\n\tDAPM_UPDATE_STAT(w, power_checks);\n\n\tin = is_connected_input_ep(w, NULL, NULL);\n\tout = is_connected_output_ep(w, NULL, NULL);\n\treturn out != 0 && in != 0;\n}\n\n \nstatic int dapm_supply_check_power(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *path;\n\n\tDAPM_UPDATE_STAT(w, power_checks);\n\n\t \n\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\tDAPM_UPDATE_STAT(w, neighbour_checks);\n\n\t\tif (path->weak)\n\t\t\tcontinue;\n\n\t\tif (path->connected &&\n\t\t    !path->connected(path->source, path->sink))\n\t\t\tcontinue;\n\n\t\tif (dapm_widget_power_check(path->sink))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dapm_always_on_check_power(struct snd_soc_dapm_widget *w)\n{\n\treturn w->connected;\n}\n\nstatic int dapm_seq_compare(struct snd_soc_dapm_widget *a,\n\t\t\t    struct snd_soc_dapm_widget *b,\n\t\t\t    bool power_up)\n{\n\tint *sort;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(dapm_up_seq) != SND_SOC_DAPM_TYPE_COUNT);\n\tBUILD_BUG_ON(ARRAY_SIZE(dapm_down_seq) != SND_SOC_DAPM_TYPE_COUNT);\n\n\tif (power_up)\n\t\tsort = dapm_up_seq;\n\telse\n\t\tsort = dapm_down_seq;\n\n\tWARN_ONCE(sort[a->id] == 0, \"offset a->id %d not initialized\\n\", a->id);\n\tWARN_ONCE(sort[b->id] == 0, \"offset b->id %d not initialized\\n\", b->id);\n\n\tif (sort[a->id] != sort[b->id])\n\t\treturn sort[a->id] - sort[b->id];\n\tif (a->subseq != b->subseq) {\n\t\tif (power_up)\n\t\t\treturn a->subseq - b->subseq;\n\t\telse\n\t\t\treturn b->subseq - a->subseq;\n\t}\n\tif (a->reg != b->reg)\n\t\treturn a->reg - b->reg;\n\tif (a->dapm != b->dapm)\n\t\treturn (unsigned long)a->dapm - (unsigned long)b->dapm;\n\n\treturn 0;\n}\n\n \nstatic void dapm_seq_insert(struct snd_soc_dapm_widget *new_widget,\n\t\t\t    struct list_head *list,\n\t\t\t    bool power_up)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tlist_for_each_entry(w, list, power_list)\n\t\tif (dapm_seq_compare(new_widget, w, power_up) < 0) {\n\t\t\tlist_add_tail(&new_widget->power_list, &w->power_list);\n\t\t\treturn;\n\t\t}\n\n\tlist_add_tail(&new_widget->power_list, list);\n}\n\nstatic void dapm_seq_check_event(struct snd_soc_card *card,\n\t\t\t\t struct snd_soc_dapm_widget *w, int event)\n{\n\tconst char *ev_name;\n\tint power;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tev_name = \"PRE_PMU\";\n\t\tpower = 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tev_name = \"POST_PMU\";\n\t\tpower = 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tev_name = \"PRE_PMD\";\n\t\tpower = 0;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tev_name = \"POST_PMD\";\n\t\tpower = 0;\n\t\tbreak;\n\tcase SND_SOC_DAPM_WILL_PMU:\n\t\tev_name = \"WILL_PMU\";\n\t\tpower = 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_WILL_PMD:\n\t\tev_name = \"WILL_PMD\";\n\t\tpower = 0;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unknown event %d\\n\", event);\n\t\treturn;\n\t}\n\n\tif (w->new_power != power)\n\t\treturn;\n\n\tif (w->event && (w->event_flags & event)) {\n\t\tint ret;\n\n\t\tpop_dbg(w->dapm->dev, card->pop_time, \"pop test : %s %s\\n\",\n\t\t\tw->name, ev_name);\n\t\tsoc_dapm_async_complete(w->dapm);\n\t\ttrace_snd_soc_dapm_widget_event_start(w, event);\n\t\tret = w->event(w, NULL, event);\n\t\ttrace_snd_soc_dapm_widget_event_done(w, event);\n\t\tif (ret < 0)\n\t\t\tdev_err(w->dapm->dev, \"ASoC: %s: %s event failed: %d\\n\",\n\t\t\t       ev_name, w->name, ret);\n\t}\n}\n\n \nstatic void dapm_seq_run_coalesced(struct snd_soc_card *card,\n\t\t\t\t   struct list_head *pending)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct snd_soc_dapm_widget *w;\n\tint reg;\n\tunsigned int value = 0;\n\tunsigned int mask = 0;\n\n\tw = list_first_entry(pending, struct snd_soc_dapm_widget, power_list);\n\treg = w->reg;\n\tdapm = w->dapm;\n\n\tlist_for_each_entry(w, pending, power_list) {\n\t\tWARN_ON(reg != w->reg || dapm != w->dapm);\n\t\tw->power = w->new_power;\n\n\t\tmask |= w->mask << w->shift;\n\t\tif (w->power)\n\t\t\tvalue |= w->on_val << w->shift;\n\t\telse\n\t\t\tvalue |= w->off_val << w->shift;\n\n\t\tpop_dbg(dapm->dev, card->pop_time,\n\t\t\t\"pop test : Queue %s: reg=0x%x, 0x%x/0x%x\\n\",\n\t\t\tw->name, reg, value, mask);\n\n\t\t \n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMU);\n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_PRE_PMD);\n\t}\n\n\tif (reg >= 0) {\n\t\t \n\n\t\tpop_dbg(dapm->dev, card->pop_time,\n\t\t\t\"pop test : Applying 0x%x/0x%x to %x in %dms\\n\",\n\t\t\tvalue, mask, reg, card->pop_time);\n\t\tpop_wait(card->pop_time);\n\t\tsoc_dapm_update_bits(dapm, reg, mask, value);\n\t}\n\n\tlist_for_each_entry(w, pending, power_list) {\n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMU);\n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_POST_PMD);\n\t}\n}\n\n \nstatic void dapm_seq_run(struct snd_soc_card *card,\n\tstruct list_head *list, int event, bool power_up)\n{\n\tstruct snd_soc_dapm_widget *w, *n;\n\tstruct snd_soc_dapm_context *d;\n\tLIST_HEAD(pending);\n\tint cur_sort = -1;\n\tint cur_subseq = -1;\n\tint cur_reg = SND_SOC_NOPM;\n\tstruct snd_soc_dapm_context *cur_dapm = NULL;\n\tint i;\n\tint *sort;\n\n\tif (power_up)\n\t\tsort = dapm_up_seq;\n\telse\n\t\tsort = dapm_down_seq;\n\n\tlist_for_each_entry_safe(w, n, list, power_list) {\n\t\tint ret = 0;\n\n\t\t \n\t\tif (sort[w->id] != cur_sort || w->reg != cur_reg ||\n\t\t    w->dapm != cur_dapm || w->subseq != cur_subseq) {\n\t\t\tif (!list_empty(&pending))\n\t\t\t\tdapm_seq_run_coalesced(card, &pending);\n\n\t\t\tif (cur_dapm && cur_dapm->component) {\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)\n\t\t\t\t\tif (sort[i] == cur_sort)\n\t\t\t\t\t\tsnd_soc_component_seq_notifier(\n\t\t\t\t\t\t\tcur_dapm->component,\n\t\t\t\t\t\t\ti, cur_subseq);\n\t\t\t}\n\n\t\t\tif (cur_dapm && w->dapm != cur_dapm)\n\t\t\t\tsoc_dapm_async_complete(cur_dapm);\n\n\t\t\tINIT_LIST_HEAD(&pending);\n\t\t\tcur_sort = -1;\n\t\t\tcur_subseq = INT_MIN;\n\t\t\tcur_reg = SND_SOC_NOPM;\n\t\t\tcur_dapm = NULL;\n\t\t}\n\n\t\tswitch (w->id) {\n\t\tcase snd_soc_dapm_pre:\n\t\t\tif (!w->event)\n\t\t\t\tcontinue;\n\n\t\t\tif (event == SND_SOC_DAPM_STREAM_START)\n\t\t\t\tret = w->event(w,\n\t\t\t\t\t       NULL, SND_SOC_DAPM_PRE_PMU);\n\t\t\telse if (event == SND_SOC_DAPM_STREAM_STOP)\n\t\t\t\tret = w->event(w,\n\t\t\t\t\t       NULL, SND_SOC_DAPM_PRE_PMD);\n\t\t\tbreak;\n\n\t\tcase snd_soc_dapm_post:\n\t\t\tif (!w->event)\n\t\t\t\tcontinue;\n\n\t\t\tif (event == SND_SOC_DAPM_STREAM_START)\n\t\t\t\tret = w->event(w,\n\t\t\t\t\t       NULL, SND_SOC_DAPM_POST_PMU);\n\t\t\telse if (event == SND_SOC_DAPM_STREAM_STOP)\n\t\t\t\tret = w->event(w,\n\t\t\t\t\t       NULL, SND_SOC_DAPM_POST_PMD);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tcur_sort = sort[w->id];\n\t\t\tcur_subseq = w->subseq;\n\t\t\tcur_reg = w->reg;\n\t\t\tcur_dapm = w->dapm;\n\t\t\tlist_move(&w->power_list, &pending);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tdev_err(w->dapm->dev,\n\t\t\t\t\"ASoC: Failed to apply widget power: %d\\n\", ret);\n\t}\n\n\tif (!list_empty(&pending))\n\t\tdapm_seq_run_coalesced(card, &pending);\n\n\tif (cur_dapm && cur_dapm->component) {\n\t\tfor (i = 0; i < ARRAY_SIZE(dapm_up_seq); i++)\n\t\t\tif (sort[i] == cur_sort)\n\t\t\t\tsnd_soc_component_seq_notifier(\n\t\t\t\t\tcur_dapm->component,\n\t\t\t\t\ti, cur_subseq);\n\t}\n\n\tfor_each_card_dapms(card, d)\n\t\tsoc_dapm_async_complete(d);\n}\n\nstatic void dapm_widget_update(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_update *update = card->update;\n\tstruct snd_soc_dapm_widget_list *wlist;\n\tstruct snd_soc_dapm_widget *w = NULL;\n\tunsigned int wi;\n\tint ret;\n\n\tif (!update || !dapm_kcontrol_is_powered(update->kcontrol))\n\t\treturn;\n\n\twlist = dapm_kcontrol_get_wlist(update->kcontrol);\n\n\tfor_each_dapm_widgets(wlist, wi, w) {\n\t\tif (w->event && (w->event_flags & SND_SOC_DAPM_PRE_REG)) {\n\t\t\tret = w->event(w, update->kcontrol, SND_SOC_DAPM_PRE_REG);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(w->dapm->dev, \"ASoC: %s DAPM pre-event failed: %d\\n\",\n\t\t\t\t\t   w->name, ret);\n\t\t}\n\t}\n\n\tif (!w)\n\t\treturn;\n\n\tret = soc_dapm_update_bits(w->dapm, update->reg, update->mask,\n\t\tupdate->val);\n\tif (ret < 0)\n\t\tdev_err(w->dapm->dev, \"ASoC: %s DAPM update failed: %d\\n\",\n\t\t\tw->name, ret);\n\n\tif (update->has_second_set) {\n\t\tret = soc_dapm_update_bits(w->dapm, update->reg2,\n\t\t\t\t\t   update->mask2, update->val2);\n\t\tif (ret < 0)\n\t\t\tdev_err(w->dapm->dev,\n\t\t\t\t\"ASoC: %s DAPM update failed: %d\\n\",\n\t\t\t\tw->name, ret);\n\t}\n\n\tfor_each_dapm_widgets(wlist, wi, w) {\n\t\tif (w->event && (w->event_flags & SND_SOC_DAPM_POST_REG)) {\n\t\t\tret = w->event(w, update->kcontrol, SND_SOC_DAPM_POST_REG);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_err(w->dapm->dev, \"ASoC: %s DAPM post-event failed: %d\\n\",\n\t\t\t\t\t   w->name, ret);\n\t\t}\n\t}\n}\n\n \nstatic void dapm_pre_sequence_async(void *data, async_cookie_t cookie)\n{\n\tstruct snd_soc_dapm_context *d = data;\n\tint ret;\n\n\t \n\tif (d->bias_level == SND_SOC_BIAS_OFF &&\n\t    d->target_bias_level != SND_SOC_BIAS_OFF) {\n\t\tif (d->dev && cookie)\n\t\t\tpm_runtime_get_sync(d->dev);\n\n\t\tret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);\n\t\tif (ret != 0)\n\t\t\tdev_err(d->dev,\n\t\t\t\t\"ASoC: Failed to turn on bias: %d\\n\", ret);\n\t}\n\n\t \n\tif ((d->target_bias_level == SND_SOC_BIAS_ON &&\n\t     d->bias_level != SND_SOC_BIAS_ON) ||\n\t    (d->target_bias_level != SND_SOC_BIAS_ON &&\n\t     d->bias_level == SND_SOC_BIAS_ON)) {\n\t\tret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_PREPARE);\n\t\tif (ret != 0)\n\t\t\tdev_err(d->dev,\n\t\t\t\t\"ASoC: Failed to prepare bias: %d\\n\", ret);\n\t}\n}\n\n \nstatic void dapm_post_sequence_async(void *data, async_cookie_t cookie)\n{\n\tstruct snd_soc_dapm_context *d = data;\n\tint ret;\n\n\t \n\tif (d->bias_level == SND_SOC_BIAS_PREPARE &&\n\t    (d->target_bias_level == SND_SOC_BIAS_STANDBY ||\n\t     d->target_bias_level == SND_SOC_BIAS_OFF)) {\n\t\tret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_STANDBY);\n\t\tif (ret != 0)\n\t\t\tdev_err(d->dev, \"ASoC: Failed to apply standby bias: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\t \n\tif (d->bias_level == SND_SOC_BIAS_STANDBY &&\n\t    d->target_bias_level == SND_SOC_BIAS_OFF) {\n\t\tret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_OFF);\n\t\tif (ret != 0)\n\t\t\tdev_err(d->dev, \"ASoC: Failed to turn off bias: %d\\n\",\n\t\t\t\tret);\n\n\t\tif (d->dev && cookie)\n\t\t\tpm_runtime_put(d->dev);\n\t}\n\n\t \n\tif (d->bias_level == SND_SOC_BIAS_PREPARE &&\n\t    d->target_bias_level == SND_SOC_BIAS_ON) {\n\t\tret = snd_soc_dapm_set_bias_level(d, SND_SOC_BIAS_ON);\n\t\tif (ret != 0)\n\t\t\tdev_err(d->dev, \"ASoC: Failed to apply active bias: %d\\n\",\n\t\t\t\tret);\n\t}\n}\n\nstatic void dapm_widget_set_peer_power(struct snd_soc_dapm_widget *peer,\n\t\t\t\t       bool power, bool connect)\n{\n\t \n\tif (!connect)\n\t\treturn;\n\n\t \n\tif (power != peer->power)\n\t\tdapm_mark_dirty(peer, \"peer state change\");\n}\n\nstatic void dapm_power_one_widget(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct list_head *up_list,\n\t\t\t\t  struct list_head *down_list)\n{\n\tstruct snd_soc_dapm_path *path;\n\tint power;\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_pre:\n\t\tpower = 0;\n\t\tgoto end;\n\tcase snd_soc_dapm_post:\n\t\tpower = 1;\n\t\tgoto end;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpower = dapm_widget_power_check(w);\n\n\tif (w->power == power)\n\t\treturn;\n\n\ttrace_snd_soc_dapm_widget_power(w, power);\n\n\t \n\tsnd_soc_dapm_widget_for_each_source_path(w, path)\n\t\tdapm_widget_set_peer_power(path->source, power, path->connect);\n\n\t \n\tif (!w->is_supply)\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path)\n\t\t\tdapm_widget_set_peer_power(path->sink, power, path->connect);\n\nend:\n\tif (power)\n\t\tdapm_seq_insert(w, up_list, true);\n\telse\n\t\tdapm_seq_insert(w, down_list, false);\n}\n\nstatic bool dapm_idle_bias_off(struct snd_soc_dapm_context *dapm)\n{\n\tif (dapm->idle_bias_off)\n\t\treturn true;\n\n\tswitch (snd_power_get_state(dapm->card->snd_card)) {\n\tcase SNDRV_CTL_POWER_D3hot:\n\tcase SNDRV_CTL_POWER_D3cold:\n\t\treturn dapm->suspend_bias_off;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\n \nstatic int dapm_power_widgets(struct snd_soc_card *card, int event)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tstruct snd_soc_dapm_context *d;\n\tLIST_HEAD(up_list);\n\tLIST_HEAD(down_list);\n\tASYNC_DOMAIN_EXCLUSIVE(async_domain);\n\tenum snd_soc_bias_level bias;\n\tint ret;\n\n\tsnd_soc_dapm_mutex_assert_held(card);\n\n\ttrace_snd_soc_dapm_start(card);\n\n\tfor_each_card_dapms(card, d) {\n\t\tif (dapm_idle_bias_off(d))\n\t\t\td->target_bias_level = SND_SOC_BIAS_OFF;\n\t\telse\n\t\t\td->target_bias_level = SND_SOC_BIAS_STANDBY;\n\t}\n\n\tdapm_reset(card);\n\n\t \n\tlist_for_each_entry(w, &card->dapm_dirty, dirty) {\n\t\tdapm_power_one_widget(w, &up_list, &down_list);\n\t}\n\n\tfor_each_card_widgets(card, w) {\n\t\tswitch (w->id) {\n\t\tcase snd_soc_dapm_pre:\n\t\tcase snd_soc_dapm_post:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlist_del_init(&w->dirty);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (w->new_power) {\n\t\t\td = w->dapm;\n\n\t\t\t \n\t\t\tswitch (w->id) {\n\t\t\tcase snd_soc_dapm_siggen:\n\t\t\tcase snd_soc_dapm_vmid:\n\t\t\t\tbreak;\n\t\t\tcase snd_soc_dapm_supply:\n\t\t\tcase snd_soc_dapm_regulator_supply:\n\t\t\tcase snd_soc_dapm_pinctrl:\n\t\t\tcase snd_soc_dapm_clock_supply:\n\t\t\tcase snd_soc_dapm_micbias:\n\t\t\t\tif (d->target_bias_level < SND_SOC_BIAS_STANDBY)\n\t\t\t\t\td->target_bias_level = SND_SOC_BIAS_STANDBY;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\td->target_bias_level = SND_SOC_BIAS_ON;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t \n\tbias = SND_SOC_BIAS_OFF;\n\tfor_each_card_dapms(card, d)\n\t\tif (d->target_bias_level > bias)\n\t\t\tbias = d->target_bias_level;\n\tfor_each_card_dapms(card, d)\n\t\tif (!dapm_idle_bias_off(d))\n\t\t\td->target_bias_level = bias;\n\n\ttrace_snd_soc_dapm_walk_done(card);\n\n\t \n\tdapm_pre_sequence_async(&card->dapm, 0);\n\t \n\tfor_each_card_dapms(card, d) {\n\t\tif (d != &card->dapm && d->bias_level != d->target_bias_level)\n\t\t\tasync_schedule_domain(dapm_pre_sequence_async, d,\n\t\t\t\t\t\t&async_domain);\n\t}\n\tasync_synchronize_full_domain(&async_domain);\n\n\tlist_for_each_entry(w, &down_list, power_list) {\n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMD);\n\t}\n\n\tlist_for_each_entry(w, &up_list, power_list) {\n\t\tdapm_seq_check_event(card, w, SND_SOC_DAPM_WILL_PMU);\n\t}\n\n\t \n\tdapm_seq_run(card, &down_list, event, false);\n\n\tdapm_widget_update(card);\n\n\t \n\tdapm_seq_run(card, &up_list, event, true);\n\n\t \n\tfor_each_card_dapms(card, d) {\n\t\tif (d != &card->dapm && d->bias_level != d->target_bias_level)\n\t\t\tasync_schedule_domain(dapm_post_sequence_async, d,\n\t\t\t\t\t\t&async_domain);\n\t}\n\tasync_synchronize_full_domain(&async_domain);\n\t \n\tdapm_post_sequence_async(&card->dapm, 0);\n\n\t \n\tfor_each_card_dapms(card, d) {\n\t\tif (!d->component)\n\t\t\tcontinue;\n\n\t\tret = snd_soc_component_stream_event(d->component, event);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tpop_dbg(card->dev, card->pop_time,\n\t\t\"DAPM sequencing finished, waiting %dms\\n\", card->pop_time);\n\tpop_wait(card->pop_time);\n\n\ttrace_snd_soc_dapm_done(card);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic ssize_t dapm_widget_power_read_file(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct snd_soc_dapm_widget *w = file->private_data;\n\tenum snd_soc_dapm_direction dir, rdir;\n\tchar *buf;\n\tint in, out;\n\tssize_t ret;\n\tstruct snd_soc_dapm_path *p = NULL;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_dapm_mutex_lock_root(w->dapm);\n\n\t \n\tif (w->is_supply) {\n\t\tin = 0;\n\t\tout = 0;\n\t} else {\n\t\tin = is_connected_input_ep(w, NULL, NULL);\n\t\tout = is_connected_output_ep(w, NULL, NULL);\n\t}\n\n\tret = scnprintf(buf, PAGE_SIZE, \"%s: %s%s  in %d out %d\",\n\t\t       w->name, w->power ? \"On\" : \"Off\",\n\t\t       w->force ? \" (forced)\" : \"\", in, out);\n\n\tif (w->reg >= 0)\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\" - R%d(0x%x) mask 0x%x\",\n\t\t\t\tw->reg, w->reg, w->mask << w->shift);\n\n\tret += scnprintf(buf + ret, PAGE_SIZE - ret, \"\\n\");\n\n\tif (w->sname)\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret, \" stream %s %s\\n\",\n\t\t\t\tw->sname,\n\t\t\t\tw->active ? \"active\" : \"inactive\");\n\n\tsnd_soc_dapm_for_each_direction(dir) {\n\t\trdir = SND_SOC_DAPM_DIR_REVERSE(dir);\n\t\tsnd_soc_dapm_widget_for_each_path(w, dir, p) {\n\t\t\tif (p->connected && !p->connected(p->source, p->sink))\n\t\t\t\tcontinue;\n\n\t\t\tif (!p->connect)\n\t\t\t\tcontinue;\n\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t\" %s  \\\"%s\\\" \\\"%s\\\"\\n\",\n\t\t\t\t\t(rdir == SND_SOC_DAPM_DIR_IN) ? \"in\" : \"out\",\n\t\t\t\t\tp->name ? p->name : \"static\",\n\t\t\t\t\tp->node[rdir]->name);\n\t\t}\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(w->dapm);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations dapm_widget_power_fops = {\n\t.open = simple_open,\n\t.read = dapm_widget_power_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t dapm_bias_read_file(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct snd_soc_dapm_context *dapm = file->private_data;\n\tchar *level;\n\n\tswitch (dapm->bias_level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tlevel = \"On\\n\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tlevel = \"Prepare\\n\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tlevel = \"Standby\\n\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tlevel = \"Off\\n\";\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unknown bias_level %d\\n\", dapm->bias_level);\n\t\tlevel = \"Unknown\\n\";\n\t\tbreak;\n\t}\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, level,\n\t\t\t\t       strlen(level));\n}\n\nstatic const struct file_operations dapm_bias_fops = {\n\t.open = simple_open,\n\t.read = dapm_bias_read_file,\n\t.llseek = default_llseek,\n};\n\nvoid snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,\n\tstruct dentry *parent)\n{\n\tif (!parent || IS_ERR(parent))\n\t\treturn;\n\n\tdapm->debugfs_dapm = debugfs_create_dir(\"dapm\", parent);\n\n\tdebugfs_create_file(\"bias_level\", 0444, dapm->debugfs_dapm, dapm,\n\t\t\t    &dapm_bias_fops);\n}\n\nstatic void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\n\tif (!dapm->debugfs_dapm || !w->name)\n\t\treturn;\n\n\tdebugfs_create_file(w->name, 0444, dapm->debugfs_dapm, w,\n\t\t\t    &dapm_widget_power_fops);\n}\n\nstatic void dapm_debugfs_free_widget(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\n\tif (!dapm->debugfs_dapm || !w->name)\n\t\treturn;\n\n\tdebugfs_lookup_and_remove(w->name, dapm->debugfs_dapm);\n}\n\nstatic void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)\n{\n\tdebugfs_remove_recursive(dapm->debugfs_dapm);\n\tdapm->debugfs_dapm = NULL;\n}\n\n#else\nvoid snd_soc_dapm_debugfs_init(struct snd_soc_dapm_context *dapm,\n\tstruct dentry *parent)\n{\n}\n\nstatic inline void dapm_debugfs_add_widget(struct snd_soc_dapm_widget *w)\n{\n}\n\nstatic inline void dapm_debugfs_free_widget(struct snd_soc_dapm_widget *w)\n{\n}\n\nstatic inline void dapm_debugfs_cleanup(struct snd_soc_dapm_context *dapm)\n{\n}\n\n#endif\n\n \nstatic void soc_dapm_connect_path(struct snd_soc_dapm_path *path,\n\tbool connect, const char *reason)\n{\n\tif (path->connect == connect)\n\t\treturn;\n\n\tpath->connect = connect;\n\tdapm_mark_dirty(path->source, reason);\n\tdapm_mark_dirty(path->sink, reason);\n\tdapm_path_invalidate(path);\n}\n\n \nstatic int soc_dapm_mux_update_power(struct snd_soc_card *card,\n\t\t\t\t struct snd_kcontrol *kcontrol, int mux, struct soc_enum *e)\n{\n\tstruct snd_soc_dapm_path *path;\n\tint found = 0;\n\tbool connect;\n\n\tsnd_soc_dapm_mutex_assert_held(card);\n\n\t \n\tdapm_kcontrol_for_each_path(path, kcontrol) {\n\t\tfound = 1;\n\t\t \n\t\tif (e && !(strcmp(path->name, e->texts[mux])))\n\t\t\tconnect = true;\n\t\telse\n\t\t\tconnect = false;\n\n\t\tsoc_dapm_connect_path(path, connect, \"mux update\");\n\t}\n\n\tif (found)\n\t\tdapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\n\n\treturn found;\n}\n\nint snd_soc_dapm_mux_update_power(struct snd_soc_dapm_context *dapm,\n\tstruct snd_kcontrol *kcontrol, int mux, struct soc_enum *e,\n\tstruct snd_soc_dapm_update *update)\n{\n\tstruct snd_soc_card *card = dapm->card;\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\tcard->update = update;\n\tret = soc_dapm_mux_update_power(card, kcontrol, mux, e);\n\tcard->update = NULL;\n\tsnd_soc_dapm_mutex_unlock(card);\n\tif (ret > 0)\n\t\tsnd_soc_dpcm_runtime_update(card);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_mux_update_power);\n\n \nstatic int soc_dapm_mixer_update_power(struct snd_soc_card *card,\n\t\t\t\t       struct snd_kcontrol *kcontrol,\n\t\t\t\t       int connect, int rconnect)\n{\n\tstruct snd_soc_dapm_path *path;\n\tint found = 0;\n\n\tsnd_soc_dapm_mutex_assert_held(card);\n\n\t \n\tdapm_kcontrol_for_each_path(path, kcontrol) {\n\t\t \n\t\tif (found && rconnect >= 0)\n\t\t\tsoc_dapm_connect_path(path, rconnect, \"mixer update\");\n\t\telse\n\t\t\tsoc_dapm_connect_path(path, connect, \"mixer update\");\n\t\tfound = 1;\n\t}\n\n\tif (found)\n\t\tdapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\n\n\treturn found;\n}\n\nint snd_soc_dapm_mixer_update_power(struct snd_soc_dapm_context *dapm,\n\tstruct snd_kcontrol *kcontrol, int connect,\n\tstruct snd_soc_dapm_update *update)\n{\n\tstruct snd_soc_card *card = dapm->card;\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\tcard->update = update;\n\tret = soc_dapm_mixer_update_power(card, kcontrol, connect, -1);\n\tcard->update = NULL;\n\tsnd_soc_dapm_mutex_unlock(card);\n\tif (ret > 0)\n\t\tsnd_soc_dpcm_runtime_update(card);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_mixer_update_power);\n\nstatic ssize_t dapm_widget_show_component(struct snd_soc_component *cmpnt,\n\t\t\t\t\t  char *buf, int count)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(cmpnt);\n\tstruct snd_soc_dapm_widget *w;\n\tchar *state = \"not set\";\n\n\t \n\tif (!cmpnt->card)\n\t\treturn 0;\n\n\tfor_each_card_widgets(cmpnt->card, w) {\n\t\tif (w->dapm != dapm)\n\t\t\tcontinue;\n\n\t\t \n\t\tswitch (w->id) {\n\t\tcase snd_soc_dapm_hp:\n\t\tcase snd_soc_dapm_mic:\n\t\tcase snd_soc_dapm_spk:\n\t\tcase snd_soc_dapm_line:\n\t\tcase snd_soc_dapm_micbias:\n\t\tcase snd_soc_dapm_dac:\n\t\tcase snd_soc_dapm_adc:\n\t\tcase snd_soc_dapm_pga:\n\t\tcase snd_soc_dapm_effect:\n\t\tcase snd_soc_dapm_out_drv:\n\t\tcase snd_soc_dapm_mixer:\n\t\tcase snd_soc_dapm_mixer_named_ctl:\n\t\tcase snd_soc_dapm_supply:\n\t\tcase snd_soc_dapm_regulator_supply:\n\t\tcase snd_soc_dapm_pinctrl:\n\t\tcase snd_soc_dapm_clock_supply:\n\t\t\tif (w->name)\n\t\t\t\tcount += sysfs_emit_at(buf, count, \"%s: %s\\n\",\n\t\t\t\t\tw->name, w->power ? \"On\":\"Off\");\n\t\tbreak;\n\t\tdefault:\n\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (snd_soc_dapm_get_bias_level(dapm)) {\n\tcase SND_SOC_BIAS_ON:\n\t\tstate = \"On\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tstate = \"Prepare\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tstate = \"Standby\";\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tstate = \"Off\";\n\t\tbreak;\n\t}\n\tcount += sysfs_emit_at(buf, count, \"PM State: %s\\n\", state);\n\n\treturn count;\n}\n\n \nstatic ssize_t dapm_widget_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);\n\tstruct snd_soc_dai *codec_dai;\n\tint i, count = 0;\n\n\tsnd_soc_dapm_mutex_lock_root(rtd->card);\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tstruct snd_soc_component *cmpnt = codec_dai->component;\n\n\t\tcount = dapm_widget_show_component(cmpnt, buf, count);\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(rtd->card);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RO(dapm_widget);\n\nstruct attribute *soc_dapm_dev_attrs[] = {\n\t&dev_attr_dapm_widget.attr,\n\tNULL\n};\n\nstatic void dapm_free_path(struct snd_soc_dapm_path *path)\n{\n\tlist_del(&path->list_node[SND_SOC_DAPM_DIR_IN]);\n\tlist_del(&path->list_node[SND_SOC_DAPM_DIR_OUT]);\n\tlist_del(&path->list_kcontrol);\n\tlist_del(&path->list);\n\tkfree(path);\n}\n\n \nvoid snd_soc_dapm_free_widget(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *p, *next_p;\n\tenum snd_soc_dapm_direction dir;\n\n\tif (!w)\n\t\treturn;\n\n\tlist_del(&w->list);\n\tlist_del(&w->dirty);\n\t \n\tsnd_soc_dapm_for_each_direction(dir) {\n\t\tsnd_soc_dapm_widget_for_each_path_safe(w, dir, p, next_p)\n\t\t\tdapm_free_path(p);\n\t}\n\n\tdapm_debugfs_free_widget(w);\n\n\tkfree(w->kcontrols);\n\tkfree_const(w->name);\n\tkfree_const(w->sname);\n\tkfree(w);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_free_widget);\n\n \nstatic void dapm_free_widgets(struct snd_soc_dapm_context *dapm)\n{\n\tstruct snd_soc_dapm_widget *w, *next_w;\n\n\tfor_each_card_widgets_safe(dapm->card, w, next_w) {\n\t\tif (w->dapm != dapm)\n\t\t\tcontinue;\n\t\tsnd_soc_dapm_free_widget(w);\n\t}\n\n\tdapm->wcache_sink\t= NULL;\n\tdapm->wcache_source\t= NULL;\n}\n\nstatic struct snd_soc_dapm_widget *dapm_find_widget(\n\t\t\tstruct snd_soc_dapm_context *dapm, const char *pin,\n\t\t\tbool search_other_contexts)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tstruct snd_soc_dapm_widget *fallback = NULL;\n\tchar prefixed_pin[80];\n\tconst char *pin_name;\n\tconst char *prefix = soc_dapm_prefix(dapm);\n\n\tif (prefix) {\n\t\tsnprintf(prefixed_pin, sizeof(prefixed_pin), \"%s %s\",\n\t\t\t prefix, pin);\n\t\tpin_name = prefixed_pin;\n\t} else {\n\t\tpin_name = pin;\n\t}\n\n\tfor_each_card_widgets(dapm->card, w) {\n\t\tif (!strcmp(w->name, pin_name)) {\n\t\t\tif (w->dapm == dapm)\n\t\t\t\treturn w;\n\t\t\telse\n\t\t\t\tfallback = w;\n\t\t}\n\t}\n\n\tif (search_other_contexts)\n\t\treturn fallback;\n\n\treturn NULL;\n}\n\n \nstatic int __snd_soc_dapm_set_pin(struct snd_soc_dapm_context *dapm,\n\t\t\t\t  const char *pin, int status)\n{\n\tstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\n\tint ret = 0;\n\n\tdapm_assert_locked(dapm);\n\n\tif (!w) {\n\t\tdev_err(dapm->dev, \"ASoC: DAPM unknown pin %s\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tif (w->connected != status) {\n\t\tdapm_mark_dirty(w, \"pin configuration\");\n\t\tdapm_widget_invalidate_input_paths(w);\n\t\tdapm_widget_invalidate_output_paths(w);\n\t\tret = 1;\n\t}\n\n\tw->connected = status;\n\tif (status == 0)\n\t\tw->force = 0;\n\n\treturn ret;\n}\n\n \nstatic int snd_soc_dapm_set_pin(struct snd_soc_dapm_context *dapm,\n\t\t\t\tconst char *pin, int status)\n{\n\tint ret = __snd_soc_dapm_set_pin(dapm, pin, status);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n \nint snd_soc_dapm_sync_unlocked(struct snd_soc_dapm_context *dapm)\n{\n\t \n\tif (!snd_soc_card_is_instantiated(dapm->card))\n\t\treturn 0;\n\n\treturn dapm_power_widgets(dapm->card, SND_SOC_DAPM_STREAM_NOP);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_sync_unlocked);\n\n \nint snd_soc_dapm_sync(struct snd_soc_dapm_context *dapm)\n{\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tret = snd_soc_dapm_sync_unlocked(dapm);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_sync);\n\nstatic int dapm_update_dai_chan(struct snd_soc_dapm_path *p,\n\t\t\t\tstruct snd_soc_dapm_widget *w,\n\t\t\t\tint channels)\n{\n\tswitch (w->id) {\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_aif_in:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tdev_dbg(w->dapm->dev, \"%s DAI route %s -> %s\\n\",\n\t\tw->channel < channels ? \"Connecting\" : \"Disconnecting\",\n\t\tp->source->name, p->sink->name);\n\n\tif (w->channel < channels)\n\t\tsoc_dapm_connect_path(p, true, \"dai update\");\n\telse\n\t\tsoc_dapm_connect_path(p, false, \"dai update\");\n\n\treturn 0;\n}\n\nstatic int dapm_update_dai_unlocked(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tint dir = substream->stream;\n\tint channels = params_channels(params);\n\tstruct snd_soc_dapm_path *p;\n\tstruct snd_soc_dapm_widget *w;\n\tint ret;\n\n\tw = snd_soc_dai_get_widget(dai, dir);\n\n\tif (!w)\n\t\treturn 0;\n\n\tdev_dbg(dai->dev, \"Update DAI routes for %s %s\\n\", dai->name,\n\t\tdir == SNDRV_PCM_STREAM_PLAYBACK ? \"playback\" : \"capture\");\n\n\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\tret = dapm_update_dai_chan(p, p->sink, channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\tret = dapm_update_dai_chan(p, p->source, channels);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint snd_soc_dapm_update_dai(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(rtd->card);\n\tret = dapm_update_dai_unlocked(substream, params, dai);\n\tsnd_soc_dapm_mutex_unlock(rtd->card);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_update_dai);\n\nint snd_soc_dapm_widget_name_cmp(struct snd_soc_dapm_widget *widget, const char *s)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(widget->dapm);\n\tconst char *wname = widget->name;\n\n\tif (component->name_prefix)\n\t\twname += strlen(component->name_prefix) + 1;  \n\n\treturn strcmp(wname, s);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_widget_name_cmp);\n\n \nstatic void dapm_update_widget_flags(struct snd_soc_dapm_widget *w)\n{\n\tenum snd_soc_dapm_direction dir;\n\tstruct snd_soc_dapm_path *p;\n\tunsigned int ep;\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_input:\n\t\t \n\t\tif (w->dapm->card->fully_routed)\n\t\t\treturn;\n\t\tep = SND_SOC_DAPM_EP_SOURCE;\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\t\tif (p->source->id == snd_soc_dapm_micbias ||\n\t\t\t\tp->source->id == snd_soc_dapm_mic ||\n\t\t\t\tp->source->id == snd_soc_dapm_line ||\n\t\t\t\tp->source->id == snd_soc_dapm_output) {\n\t\t\t\t\tep = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase snd_soc_dapm_output:\n\t\t \n\t\tif (w->dapm->card->fully_routed)\n\t\t\treturn;\n\t\tep = SND_SOC_DAPM_EP_SINK;\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\t\tif (p->sink->id == snd_soc_dapm_spk ||\n\t\t\t\tp->sink->id == snd_soc_dapm_hp ||\n\t\t\t\tp->sink->id == snd_soc_dapm_line ||\n\t\t\t\tp->sink->id == snd_soc_dapm_input) {\n\t\t\t\t\tep = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase snd_soc_dapm_line:\n\t\tep = 0;\n\t\tsnd_soc_dapm_for_each_direction(dir) {\n\t\t\tif (!list_empty(&w->edges[dir]))\n\t\t\t\tep |= SND_SOC_DAPM_DIR_TO_EP(dir);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tw->is_ep = ep;\n}\n\nstatic int snd_soc_dapm_check_dynamic_path(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_widget *source, struct snd_soc_dapm_widget *sink,\n\tconst char *control)\n{\n\tbool dynamic_source = false;\n\tbool dynamic_sink = false;\n\n\tif (!control)\n\t\treturn 0;\n\n\tswitch (source->id) {\n\tcase snd_soc_dapm_demux:\n\t\tdynamic_source = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (sink->id) {\n\tcase snd_soc_dapm_mux:\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_mixer:\n\tcase snd_soc_dapm_mixer_named_ctl:\n\t\tdynamic_sink = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dynamic_source && dynamic_sink) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"Direct connection between demux and mixer/mux not supported for path %s -> [%s] -> %s\\n\",\n\t\t\tsource->name, control, sink->name);\n\t\treturn -EINVAL;\n\t} else if (!dynamic_source && !dynamic_sink) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"Control not supported for path %s -> [%s] -> %s\\n\",\n\t\t\tsource->name, control, sink->name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm,\n\tstruct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,\n\tconst char *control,\n\tint (*connected)(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink))\n{\n\tenum snd_soc_dapm_direction dir;\n\tstruct snd_soc_dapm_path *path;\n\tint ret;\n\n\tif (wsink->is_supply && !wsource->is_supply) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"Connecting non-supply widget to supply widget is not supported (%s -> %s)\\n\",\n\t\t\twsource->name, wsink->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (connected && !wsource->is_supply) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"connected() callback only supported for supply widgets (%s -> %s)\\n\",\n\t\t\twsource->name, wsink->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wsource->is_supply && control) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"Conditional paths are not supported for supply widgets (%s -> [%s] -> %s)\\n\",\n\t\t\twsource->name, control, wsink->name);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_dapm_check_dynamic_path(dapm, wsource, wsink, control);\n\tif (ret)\n\t\treturn ret;\n\n\tpath = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->node[SND_SOC_DAPM_DIR_IN] = wsource;\n\tpath->node[SND_SOC_DAPM_DIR_OUT] = wsink;\n\n\tpath->connected = connected;\n\tINIT_LIST_HEAD(&path->list);\n\tINIT_LIST_HEAD(&path->list_kcontrol);\n\n\tif (wsource->is_supply || wsink->is_supply)\n\t\tpath->is_supply = 1;\n\n\t \n\tif (control == NULL) {\n\t\tpath->connect = 1;\n\t} else {\n\t\tswitch (wsource->id) {\n\t\tcase snd_soc_dapm_demux:\n\t\t\tret = dapm_connect_mux(dapm, path, control, wsource);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (wsink->id) {\n\t\tcase snd_soc_dapm_mux:\n\t\t\tret = dapm_connect_mux(dapm, path, control, wsink);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_switch:\n\t\tcase snd_soc_dapm_mixer:\n\t\tcase snd_soc_dapm_mixer_named_ctl:\n\t\t\tret = dapm_connect_mixer(dapm, path, control);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_add(&path->list, &dapm->card->paths);\n\n\tsnd_soc_dapm_for_each_direction(dir)\n\t\tlist_add(&path->list_node[dir], &path->node[dir]->edges[dir]);\n\n\tsnd_soc_dapm_for_each_direction(dir) {\n\t\tdapm_update_widget_flags(path->node[dir]);\n\t\tdapm_mark_dirty(path->node[dir], \"Route added\");\n\t}\n\n\tif (snd_soc_card_is_instantiated(dapm->card) && path->connect)\n\t\tdapm_path_invalidate(path);\n\n\treturn 0;\nerr:\n\tkfree(path);\n\treturn ret;\n}\n\nstatic int snd_soc_dapm_add_route(struct snd_soc_dapm_context *dapm,\n\t\t\t\t  const struct snd_soc_dapm_route *route)\n{\n\tstruct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w;\n\tstruct snd_soc_dapm_widget *wtsource = NULL, *wtsink = NULL;\n\tconst char *sink;\n\tconst char *source;\n\tchar prefixed_sink[80];\n\tchar prefixed_source[80];\n\tconst char *prefix;\n\tunsigned int sink_ref = 0;\n\tunsigned int source_ref = 0;\n\tint ret;\n\n\tprefix = soc_dapm_prefix(dapm);\n\tif (prefix) {\n\t\tsnprintf(prefixed_sink, sizeof(prefixed_sink), \"%s %s\",\n\t\t\t prefix, route->sink);\n\t\tsink = prefixed_sink;\n\t\tsnprintf(prefixed_source, sizeof(prefixed_source), \"%s %s\",\n\t\t\t prefix, route->source);\n\t\tsource = prefixed_source;\n\t} else {\n\t\tsink = route->sink;\n\t\tsource = route->source;\n\t}\n\n\twsource\t= dapm_wcache_lookup(dapm->wcache_source, source);\n\twsink\t= dapm_wcache_lookup(dapm->wcache_sink,   sink);\n\n\tif (wsink && wsource)\n\t\tgoto skip_search;\n\n\t \n\tfor_each_card_widgets(dapm->card, w) {\n\t\tif (!wsink && !(strcmp(w->name, sink))) {\n\t\t\twtsink = w;\n\t\t\tif (w->dapm == dapm) {\n\t\t\t\twsink = w;\n\t\t\t\tif (wsource)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsink_ref++;\n\t\t\tif (sink_ref > 1)\n\t\t\t\tdev_warn(dapm->dev,\n\t\t\t\t\t\"ASoC: sink widget %s overwritten\\n\",\n\t\t\t\t\tw->name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!wsource && !(strcmp(w->name, source))) {\n\t\t\twtsource = w;\n\t\t\tif (w->dapm == dapm) {\n\t\t\t\twsource = w;\n\t\t\t\tif (wsink)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsource_ref++;\n\t\t\tif (source_ref > 1)\n\t\t\t\tdev_warn(dapm->dev,\n\t\t\t\t\t\"ASoC: source widget %s overwritten\\n\",\n\t\t\t\t\tw->name);\n\t\t}\n\t}\n\t \n\tif (!wsink)\n\t\twsink = wtsink;\n\tif (!wsource)\n\t\twsource = wtsource;\n\n\tret = -ENODEV;\n\tif (!wsource)\n\t\tgoto err;\n\tif (!wsink)\n\t\tgoto err;\n\nskip_search:\n\t \n\tdapm->wcache_sink\t= wsink;\n\tdapm->wcache_source\t= wsource;\n\n\tret = snd_soc_dapm_add_path(dapm, wsource, wsink, route->control,\n\t\troute->connected);\nerr:\n\tif (ret)\n\t\tdev_err(dapm->dev, \"ASoC: Failed to add route %s%s -%s%s%s> %s%s\\n\",\n\t\t\tsource, !wsource ? \"(*)\" : \"\",\n\t\t\t!route->control ? \"\" : \"> [\",\n\t\t\t!route->control ? \"\" : route->control,\n\t\t\t!route->control ? \"\" : \"] -\",\n\t\t\tsink,  !wsink ? \"(*)\" : \"\");\n\treturn ret;\n}\n\nstatic int snd_soc_dapm_del_route(struct snd_soc_dapm_context *dapm,\n\t\t\t\t  const struct snd_soc_dapm_route *route)\n{\n\tstruct snd_soc_dapm_path *path, *p;\n\tconst char *sink;\n\tconst char *source;\n\tchar prefixed_sink[80];\n\tchar prefixed_source[80];\n\tconst char *prefix;\n\n\tif (route->control) {\n\t\tdev_err(dapm->dev,\n\t\t\t\"ASoC: Removal of routes with controls not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprefix = soc_dapm_prefix(dapm);\n\tif (prefix) {\n\t\tsnprintf(prefixed_sink, sizeof(prefixed_sink), \"%s %s\",\n\t\t\t prefix, route->sink);\n\t\tsink = prefixed_sink;\n\t\tsnprintf(prefixed_source, sizeof(prefixed_source), \"%s %s\",\n\t\t\t prefix, route->source);\n\t\tsource = prefixed_source;\n\t} else {\n\t\tsink = route->sink;\n\t\tsource = route->source;\n\t}\n\n\tpath = NULL;\n\tlist_for_each_entry(p, &dapm->card->paths, list) {\n\t\tif (strcmp(p->source->name, source) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(p->sink->name, sink) != 0)\n\t\t\tcontinue;\n\t\tpath = p;\n\t\tbreak;\n\t}\n\n\tif (path) {\n\t\tstruct snd_soc_dapm_widget *wsource = path->source;\n\t\tstruct snd_soc_dapm_widget *wsink = path->sink;\n\n\t\tdapm_mark_dirty(wsource, \"Route removed\");\n\t\tdapm_mark_dirty(wsink, \"Route removed\");\n\t\tif (path->connect)\n\t\t\tdapm_path_invalidate(path);\n\n\t\tdapm_free_path(path);\n\n\t\t \n\t\tdapm_update_widget_flags(wsource);\n\t\tdapm_update_widget_flags(wsink);\n\t} else {\n\t\tdev_warn(dapm->dev, \"ASoC: Route %s->%s does not exist\\n\",\n\t\t\t source, sink);\n\t}\n\n\treturn 0;\n}\n\n \nint snd_soc_dapm_add_routes(struct snd_soc_dapm_context *dapm,\n\t\t\t    const struct snd_soc_dapm_route *route, int num)\n{\n\tint i, ret = 0;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tfor (i = 0; i < num; i++) {\n\t\tint r = snd_soc_dapm_add_route(dapm, route);\n\t\tif (r < 0)\n\t\t\tret = r;\n\t\troute++;\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_add_routes);\n\n \nint snd_soc_dapm_del_routes(struct snd_soc_dapm_context *dapm,\n\t\t\t    const struct snd_soc_dapm_route *route, int num)\n{\n\tint i;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tfor (i = 0; i < num; i++) {\n\t\tsnd_soc_dapm_del_route(dapm, route);\n\t\troute++;\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_del_routes);\n\nstatic int snd_soc_dapm_weak_route(struct snd_soc_dapm_context *dapm,\n\t\t\t\t   const struct snd_soc_dapm_route *route)\n{\n\tstruct snd_soc_dapm_widget *source = dapm_find_widget(dapm,\n\t\t\t\t\t\t\t      route->source,\n\t\t\t\t\t\t\t      true);\n\tstruct snd_soc_dapm_widget *sink = dapm_find_widget(dapm,\n\t\t\t\t\t\t\t    route->sink,\n\t\t\t\t\t\t\t    true);\n\tstruct snd_soc_dapm_path *path;\n\tint count = 0;\n\n\tif (!source) {\n\t\tdev_err(dapm->dev, \"ASoC: Unable to find source %s for weak route\\n\",\n\t\t\troute->source);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!sink) {\n\t\tdev_err(dapm->dev, \"ASoC: Unable to find sink %s for weak route\\n\",\n\t\t\troute->sink);\n\t\treturn -ENODEV;\n\t}\n\n\tif (route->control || route->connected)\n\t\tdev_warn(dapm->dev, \"ASoC: Ignoring control for weak route %s->%s\\n\",\n\t\t\t route->source, route->sink);\n\n\tsnd_soc_dapm_widget_for_each_sink_path(source, path) {\n\t\tif (path->sink == sink) {\n\t\t\tpath->weak = 1;\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0)\n\t\tdev_err(dapm->dev, \"ASoC: No path found for weak route %s->%s\\n\",\n\t\t\troute->source, route->sink);\n\tif (count > 1)\n\t\tdev_warn(dapm->dev, \"ASoC: %d paths found for weak route %s->%s\\n\",\n\t\t\t count, route->source, route->sink);\n\n\treturn 0;\n}\n\n \nint snd_soc_dapm_weak_routes(struct snd_soc_dapm_context *dapm,\n\t\t\t     const struct snd_soc_dapm_route *route, int num)\n{\n\tint i;\n\tint ret = 0;\n\n\tsnd_soc_dapm_mutex_lock_root(dapm);\n\tfor (i = 0; i < num; i++) {\n\t\tint err = snd_soc_dapm_weak_route(dapm, route);\n\t\tif (err)\n\t\t\tret = err;\n\t\troute++;\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_weak_routes);\n\n \nint snd_soc_dapm_new_widgets(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_widget *w;\n\tunsigned int val;\n\n\tsnd_soc_dapm_mutex_lock_root(card);\n\n\tfor_each_card_widgets(card, w)\n\t{\n\t\tif (w->new)\n\t\t\tcontinue;\n\n\t\tif (w->num_kcontrols) {\n\t\t\tw->kcontrols = kcalloc(w->num_kcontrols,\n\t\t\t\t\t\tsizeof(struct snd_kcontrol *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!w->kcontrols) {\n\t\t\t\tsnd_soc_dapm_mutex_unlock(card);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tswitch(w->id) {\n\t\tcase snd_soc_dapm_switch:\n\t\tcase snd_soc_dapm_mixer:\n\t\tcase snd_soc_dapm_mixer_named_ctl:\n\t\t\tdapm_new_mixer(w);\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_mux:\n\t\tcase snd_soc_dapm_demux:\n\t\t\tdapm_new_mux(w);\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_pga:\n\t\tcase snd_soc_dapm_effect:\n\t\tcase snd_soc_dapm_out_drv:\n\t\t\tdapm_new_pga(w);\n\t\t\tbreak;\n\t\tcase snd_soc_dapm_dai_link:\n\t\t\tdapm_new_dai_link(w);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (w->reg >= 0) {\n\t\t\tval = soc_dapm_read(w->dapm, w->reg);\n\t\t\tval = val >> w->shift;\n\t\t\tval &= w->mask;\n\t\t\tif (val == w->on_val)\n\t\t\t\tw->power = 1;\n\t\t}\n\n\t\tw->new = 1;\n\n\t\tdapm_mark_dirty(w, \"new widget\");\n\t\tdapm_debugfs_add_widget(w);\n\t}\n\n\tdapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);\n\tsnd_soc_dapm_mutex_unlock(card);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_new_widgets);\n\n \nint snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tint max = mc->max;\n\tunsigned int width = fls(max);\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned int reg_val, val, rval = 0;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tif (dapm_kcontrol_is_powered(kcontrol) && reg != SND_SOC_NOPM) {\n\t\treg_val = soc_dapm_read(dapm, reg);\n\t\tval = (reg_val >> shift) & mask;\n\n\t\tif (reg != mc->rreg)\n\t\t\treg_val = soc_dapm_read(dapm, mc->rreg);\n\n\t\tif (snd_soc_volsw_is_stereo(mc))\n\t\t\trval = (reg_val >> mc->rshift) & mask;\n\t} else {\n\t\treg_val = dapm_kcontrol_get_value(kcontrol);\n\t\tval = reg_val & mask;\n\n\t\tif (snd_soc_volsw_is_stereo(mc))\n\t\t\trval = (reg_val >> width) & mask;\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = max - val;\n\telse\n\t\tucontrol->value.integer.value[0] = val;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\tif (invert)\n\t\t\tucontrol->value.integer.value[1] = max - rval;\n\t\telse\n\t\t\tucontrol->value.integer.value[1] = rval;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_get_volsw);\n\n \nint snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tint max = mc->max;\n\tunsigned int width = fls(max);\n\tunsigned int mask = (1 << width) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned int val, rval = 0;\n\tint connect, rconnect = -1, change, reg_change = 0;\n\tstruct snd_soc_dapm_update update = {};\n\tint ret = 0;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tconnect = !!val;\n\n\tif (invert)\n\t\tval = max - val;\n\n\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\trval = (ucontrol->value.integer.value[1] & mask);\n\t\trconnect = !!rval;\n\t\tif (invert)\n\t\t\trval = max - rval;\n\t}\n\n\tsnd_soc_dapm_mutex_lock(card);\n\n\t \n\tif (width > sizeof(unsigned int) * 8 / 2)\n\t\tdev_warn(dapm->dev,\n\t\t\t \"ASoC: control %s field width limit exceeded\\n\",\n\t\t\t kcontrol->id.name);\n\tchange = dapm_kcontrol_set_value(kcontrol, val | (rval << width));\n\n\tif (reg != SND_SOC_NOPM) {\n\t\tval = val << shift;\n\t\trval = rval << mc->rshift;\n\n\t\treg_change = soc_dapm_test_bits(dapm, reg, mask << shift, val);\n\n\t\tif (snd_soc_volsw_is_stereo(mc))\n\t\t\treg_change |= soc_dapm_test_bits(dapm, mc->rreg,\n\t\t\t\t\t\t\t mask << mc->rshift,\n\t\t\t\t\t\t\t rval);\n\t}\n\n\tif (change || reg_change) {\n\t\tif (reg_change) {\n\t\t\tif (snd_soc_volsw_is_stereo(mc)) {\n\t\t\t\tupdate.has_second_set = true;\n\t\t\t\tupdate.reg2 = mc->rreg;\n\t\t\t\tupdate.mask2 = mask << mc->rshift;\n\t\t\t\tupdate.val2 = rval;\n\t\t\t}\n\t\t\tupdate.kcontrol = kcontrol;\n\t\t\tupdate.reg = reg;\n\t\t\tupdate.mask = mask << shift;\n\t\t\tupdate.val = val;\n\t\t\tcard->update = &update;\n\t\t}\n\n\t\tret = soc_dapm_mixer_update_power(card, kcontrol, connect,\n\t\t\t\t\t\t  rconnect);\n\n\t\tcard->update = NULL;\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(card);\n\n\tif (ret > 0)\n\t\tsnd_soc_dpcm_runtime_update(card);\n\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_put_volsw);\n\n \nint snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int reg_val, val;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tif (e->reg != SND_SOC_NOPM && dapm_kcontrol_is_powered(kcontrol)) {\n\t\treg_val = soc_dapm_read(dapm, e->reg);\n\t} else {\n\t\treg_val = dapm_kcontrol_get_value(kcontrol);\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\tval = (reg_val >> e->shift_l) & e->mask;\n\tucontrol->value.enumerated.item[0] = snd_soc_enum_val_to_item(e, val);\n\tif (e->shift_l != e->shift_r) {\n\t\tval = (reg_val >> e->shift_r) & e->mask;\n\t\tval = snd_soc_enum_val_to_item(e, val);\n\t\tucontrol->value.enumerated.item[1] = val;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_get_enum_double);\n\n \nint snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, change, reg_change = 0;\n\tunsigned int mask;\n\tstruct snd_soc_dapm_update update = {};\n\tint ret = 0;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\tmask = e->mask << e->shift_l;\n\tif (e->shift_l != e->shift_r) {\n\t\tif (item[1] > e->items)\n\t\t\treturn -EINVAL;\n\t\tval |= snd_soc_enum_item_to_val(e, item[1]) << e->shift_r;\n\t\tmask |= e->mask << e->shift_r;\n\t}\n\n\tsnd_soc_dapm_mutex_lock(card);\n\n\tchange = dapm_kcontrol_set_value(kcontrol, val);\n\n\tif (e->reg != SND_SOC_NOPM)\n\t\treg_change = soc_dapm_test_bits(dapm, e->reg, mask, val);\n\n\tif (change || reg_change) {\n\t\tif (reg_change) {\n\t\t\tupdate.kcontrol = kcontrol;\n\t\t\tupdate.reg = e->reg;\n\t\t\tupdate.mask = mask;\n\t\t\tupdate.val = val;\n\t\t\tcard->update = &update;\n\t\t}\n\n\t\tret = soc_dapm_mux_update_power(card, kcontrol, item[0], e);\n\n\t\tcard->update = NULL;\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(card);\n\n\tif (ret > 0)\n\t\tsnd_soc_dpcm_runtime_update(card);\n\n\treturn change;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_put_enum_double);\n\n \nint snd_soc_dapm_info_pin_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_info_pin_switch);\n\n \nint snd_soc_dapm_get_pin_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tconst char *pin = (const char *)kcontrol->private_value;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\n\tucontrol->value.integer.value[0] =\n\t\tsnd_soc_dapm_get_pin_status(&card->dapm, pin);\n\n\tsnd_soc_dapm_mutex_unlock(card);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_switch);\n\n \nint snd_soc_dapm_put_pin_switch(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tconst char *pin = (const char *)kcontrol->private_value;\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\tret = __snd_soc_dapm_set_pin(&card->dapm, pin,\n\t\t\t\t     !!ucontrol->value.integer.value[0]);\n\tsnd_soc_dapm_mutex_unlock(card);\n\n\tsnd_soc_dapm_sync(&card->dapm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_put_pin_switch);\n\nstruct snd_soc_dapm_widget *\nsnd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t const struct snd_soc_dapm_widget *widget)\n{\n\tenum snd_soc_dapm_direction dir;\n\tstruct snd_soc_dapm_widget *w;\n\tconst char *prefix;\n\tint ret = -ENOMEM;\n\n\tif ((w = dapm_cnew_widget(widget)) == NULL)\n\t\tgoto cnew_failed;\n\n\tprefix = soc_dapm_prefix(dapm);\n\tif (prefix)\n\t\tw->name = kasprintf(GFP_KERNEL, \"%s %s\", prefix, widget->name);\n\telse\n\t\tw->name = kstrdup_const(widget->name, GFP_KERNEL);\n\tif (!w->name)\n\t\tgoto name_failed;\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_regulator_supply:\n\t\tw->regulator = devm_regulator_get(dapm->dev, widget->name);\n\t\tif (IS_ERR(w->regulator)) {\n\t\t\tret = PTR_ERR(w->regulator);\n\t\t\tgoto request_failed;\n\t\t}\n\n\t\tif (w->on_val & SND_SOC_DAPM_REGULATOR_BYPASS) {\n\t\t\tret = regulator_allow_bypass(w->regulator, true);\n\t\t\tif (ret != 0)\n\t\t\t\tdev_warn(dapm->dev,\n\t\t\t\t\t \"ASoC: Failed to bypass %s: %d\\n\",\n\t\t\t\t\t w->name, ret);\n\t\t}\n\t\tbreak;\n\tcase snd_soc_dapm_pinctrl:\n\t\tw->pinctrl = devm_pinctrl_get(dapm->dev);\n\t\tif (IS_ERR(w->pinctrl)) {\n\t\t\tret = PTR_ERR(w->pinctrl);\n\t\t\tgoto request_failed;\n\t\t}\n\n\t\t \n\t\tdapm_pinctrl_event(w, NULL, SND_SOC_DAPM_POST_PMD);\n\t\tbreak;\n\tcase snd_soc_dapm_clock_supply:\n\t\tw->clk = devm_clk_get(dapm->dev, widget->name);\n\t\tif (IS_ERR(w->clk)) {\n\t\t\tret = PTR_ERR(w->clk);\n\t\t\tgoto request_failed;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (w->id) {\n\tcase snd_soc_dapm_mic:\n\t\tw->is_ep = SND_SOC_DAPM_EP_SOURCE;\n\t\tw->power_check = dapm_generic_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_input:\n\t\tif (!dapm->card->fully_routed)\n\t\t\tw->is_ep = SND_SOC_DAPM_EP_SOURCE;\n\t\tw->power_check = dapm_generic_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_spk:\n\tcase snd_soc_dapm_hp:\n\t\tw->is_ep = SND_SOC_DAPM_EP_SINK;\n\t\tw->power_check = dapm_generic_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_output:\n\t\tif (!dapm->card->fully_routed)\n\t\t\tw->is_ep = SND_SOC_DAPM_EP_SINK;\n\t\tw->power_check = dapm_generic_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_vmid:\n\tcase snd_soc_dapm_siggen:\n\t\tw->is_ep = SND_SOC_DAPM_EP_SOURCE;\n\t\tw->power_check = dapm_always_on_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_sink:\n\t\tw->is_ep = SND_SOC_DAPM_EP_SINK;\n\t\tw->power_check = dapm_always_on_check_power;\n\t\tbreak;\n\n\tcase snd_soc_dapm_mux:\n\tcase snd_soc_dapm_demux:\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_mixer:\n\tcase snd_soc_dapm_mixer_named_ctl:\n\tcase snd_soc_dapm_adc:\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_dac:\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_pga:\n\tcase snd_soc_dapm_buffer:\n\tcase snd_soc_dapm_scheduler:\n\tcase snd_soc_dapm_effect:\n\tcase snd_soc_dapm_src:\n\tcase snd_soc_dapm_asrc:\n\tcase snd_soc_dapm_encoder:\n\tcase snd_soc_dapm_decoder:\n\tcase snd_soc_dapm_out_drv:\n\tcase snd_soc_dapm_micbias:\n\tcase snd_soc_dapm_line:\n\tcase snd_soc_dapm_dai_link:\n\tcase snd_soc_dapm_dai_out:\n\tcase snd_soc_dapm_dai_in:\n\t\tw->power_check = dapm_generic_check_power;\n\t\tbreak;\n\tcase snd_soc_dapm_supply:\n\tcase snd_soc_dapm_regulator_supply:\n\tcase snd_soc_dapm_pinctrl:\n\tcase snd_soc_dapm_clock_supply:\n\tcase snd_soc_dapm_kcontrol:\n\t\tw->is_supply = 1;\n\t\tw->power_check = dapm_supply_check_power;\n\t\tbreak;\n\tdefault:\n\t\tw->power_check = dapm_always_on_check_power;\n\t\tbreak;\n\t}\n\n\tw->dapm = dapm;\n\tINIT_LIST_HEAD(&w->list);\n\tINIT_LIST_HEAD(&w->dirty);\n\t \n\tlist_add_tail(&w->list, &dapm->card->widgets);\n\n\tsnd_soc_dapm_for_each_direction(dir) {\n\t\tINIT_LIST_HEAD(&w->edges[dir]);\n\t\tw->endpoints[dir] = -1;\n\t}\n\n\t \n\tw->connected = 1;\n\treturn w;\n\nrequest_failed:\n\tdev_err_probe(dapm->dev, ret, \"ASoC: Failed to request %s\\n\",\n\t\t      w->name);\n\tkfree_const(w->name);\nname_failed:\n\tkfree_const(w->sname);\n\tkfree(w);\ncnew_failed:\n\treturn ERR_PTR(ret);\n}\n\n \nstruct snd_soc_dapm_widget *\nsnd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,\n\t\t\t const struct snd_soc_dapm_widget *widget)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tw = snd_soc_dapm_new_control_unlocked(dapm, widget);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn w;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_new_control);\n\n \nint snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm,\n\tconst struct snd_soc_dapm_widget *widget,\n\tint num)\n{\n\tint i;\n\tint ret = 0;\n\n\tsnd_soc_dapm_mutex_lock_root(dapm);\n\tfor (i = 0; i < num; i++) {\n\t\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_new_control_unlocked(dapm, widget);\n\t\tif (IS_ERR(w)) {\n\t\t\tret = PTR_ERR(w);\n\t\t\tbreak;\n\t\t}\n\t\twidget++;\n\t}\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_new_controls);\n\nstatic int\nsnd_soc_dai_link_event_pre_pmu(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_dapm_path *path;\n\tstruct snd_soc_dai *source, *sink;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_hw_params *params = NULL;\n\tconst struct snd_soc_pcm_stream *config = NULL;\n\tstruct snd_pcm_runtime *runtime = NULL;\n\tunsigned int fmt;\n\tint ret = 0;\n\n\t \n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\truntime = kzalloc(sizeof(*runtime), GFP_KERNEL);\n\tif (!runtime) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsubstream->runtime = runtime;\n\n\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\tsource = path->source->priv;\n\n\t\tret = snd_soc_dai_startup(source, substream);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tsnd_soc_dai_activate(source, substream->stream);\n\t}\n\n\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\tsink = path->sink->priv;\n\n\t\tret = snd_soc_dai_startup(sink, substream);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tsnd_soc_dai_activate(sink, substream->stream);\n\t}\n\n\tsubstream->hw_opened = 1;\n\n\t \n\tconfig = rtd->dai_link->c2c_params + rtd->c2c_params_select;\n\tif (!config) {\n\t\tdev_err(w->dapm->dev, \"ASoC: link config missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!config->formats) {\n\t\tdev_warn(w->dapm->dev, \"ASoC: Invalid format was specified\\n\");\n\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfmt = ffs(config->formats) - 1;\n\n\tsnd_mask_set(hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT), fmt);\n\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min =\n\t\tconfig->rate_min;\n\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max =\n\t\tconfig->rate_max;\n\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->min\n\t\t= config->channels_min;\n\thw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS)->max\n\t\t= config->channels_max;\n\n\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\tsource = path->source->priv;\n\n\t\tret = snd_soc_dai_hw_params(source, substream, params);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tdapm_update_dai_unlocked(substream, params, source);\n\t}\n\n\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\tsink = path->sink->priv;\n\n\t\tret = snd_soc_dai_hw_params(sink, substream, params);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tdapm_update_dai_unlocked(substream, params, sink);\n\t}\n\n\truntime->format = params_format(params);\n\truntime->subformat = params_subformat(params);\n\truntime->channels = params_channels(params);\n\truntime->rate = params_rate(params);\n\nout:\n\t \n\tkfree(params);\n\n\treturn ret;\n}\n\nstatic int snd_soc_dai_link_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_dapm_path *path;\n\tstruct snd_soc_dai *source, *sink;\n\tstruct snd_pcm_substream *substream = w->priv;\n\tint ret = 0, saved_stream = substream->stream;\n\n\tif (WARN_ON(list_empty(&w->edges[SND_SOC_DAPM_DIR_OUT]) ||\n\t\t    list_empty(&w->edges[SND_SOC_DAPM_DIR_IN])))\n\t\treturn -EINVAL;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = snd_soc_dai_link_event_pre_pmu(w, substream);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\n\t\t\tsnd_soc_dai_digital_mute(sink, 0, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\n\t\t\tsnd_soc_dai_digital_mute(sink, 1, SNDRV_PCM_STREAM_PLAYBACK);\n\t\t\tret = 0;\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\t\tsource = path->source->priv;\n\t\t\tsnd_soc_dai_hw_free(source, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\t\t\tsnd_soc_dai_hw_free(sink, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_CAPTURE;\n\t\tsnd_soc_dapm_widget_for_each_source_path(w, path) {\n\t\t\tsource = path->source->priv;\n\t\t\tsnd_soc_dai_deactivate(source, substream->stream);\n\t\t\tsnd_soc_dai_shutdown(source, substream, 0);\n\t\t}\n\n\t\tsubstream->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\t\tsnd_soc_dapm_widget_for_each_sink_path(w, path) {\n\t\t\tsink = path->sink->priv;\n\t\t\tsnd_soc_dai_deactivate(sink, substream->stream);\n\t\t\tsnd_soc_dai_shutdown(sink, substream, 0);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tkfree(substream->runtime);\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Unknown event %d\\n\", event);\n\t\tret = -EINVAL;\n\t}\n\nout:\n\t \n\tsubstream->stream = saved_stream;\n\treturn ret;\n}\n\nstatic int snd_soc_dapm_dai_link_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_pcm_runtime *rtd = w->priv;\n\n\tucontrol->value.enumerated.item[0] = rtd->c2c_params_select;\n\n\treturn 0;\n}\n\nstatic int snd_soc_dapm_dai_link_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *w = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_pcm_runtime *rtd = w->priv;\n\n\t \n\tif (w->power)\n\t\treturn -EBUSY;\n\n\tif (ucontrol->value.enumerated.item[0] == rtd->c2c_params_select)\n\t\treturn 0;\n\n\tif (ucontrol->value.enumerated.item[0] >= rtd->dai_link->num_c2c_params)\n\t\treturn -EINVAL;\n\n\trtd->c2c_params_select = ucontrol->value.enumerated.item[0];\n\n\treturn 1;\n}\n\nstatic void\nsnd_soc_dapm_free_kcontrol(struct snd_soc_card *card,\n\t\t\tunsigned long *private_value,\n\t\t\tint num_c2c_params,\n\t\t\tconst char **w_param_text)\n{\n\tint count;\n\n\tdevm_kfree(card->dev, (void *)*private_value);\n\n\tif (!w_param_text)\n\t\treturn;\n\n\tfor (count = 0 ; count < num_c2c_params; count++)\n\t\tdevm_kfree(card->dev, (void *)w_param_text[count]);\n\tdevm_kfree(card->dev, w_param_text);\n}\n\nstatic struct snd_kcontrol_new *\nsnd_soc_dapm_alloc_kcontrol(struct snd_soc_card *card,\n\t\t\tchar *link_name,\n\t\t\tconst struct snd_soc_pcm_stream *c2c_params,\n\t\t\tint num_c2c_params, const char **w_param_text,\n\t\t\tunsigned long *private_value)\n{\n\tstruct soc_enum w_param_enum[] = {\n\t\tSOC_ENUM_SINGLE(0, 0, 0, NULL),\n\t};\n\tstruct snd_kcontrol_new kcontrol_dai_link[] = {\n\t\tSOC_ENUM_EXT(NULL, w_param_enum[0],\n\t\t\t     snd_soc_dapm_dai_link_get,\n\t\t\t     snd_soc_dapm_dai_link_put),\n\t};\n\tstruct snd_kcontrol_new *kcontrol_news;\n\tconst struct snd_soc_pcm_stream *config = c2c_params;\n\tint count;\n\n\tfor (count = 0 ; count < num_c2c_params; count++) {\n\t\tif (!config->stream_name) {\n\t\t\tdev_warn(card->dapm.dev,\n\t\t\t\t\"ASoC: anonymous config %d for dai link %s\\n\",\n\t\t\t\tcount, link_name);\n\t\t\tw_param_text[count] =\n\t\t\t\tdevm_kasprintf(card->dev, GFP_KERNEL,\n\t\t\t\t\t       \"Anonymous Configuration %d\",\n\t\t\t\t\t       count);\n\t\t} else {\n\t\t\tw_param_text[count] = devm_kmemdup(card->dev,\n\t\t\t\t\t\tconfig->stream_name,\n\t\t\t\t\t\tstrlen(config->stream_name) + 1,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t}\n\t\tif (!w_param_text[count])\n\t\t\tgoto outfree_w_param;\n\t\tconfig++;\n\t}\n\n\tw_param_enum[0].items = num_c2c_params;\n\tw_param_enum[0].texts = w_param_text;\n\n\t*private_value =\n\t\t(unsigned long) devm_kmemdup(card->dev,\n\t\t\t(void *)(kcontrol_dai_link[0].private_value),\n\t\t\tsizeof(struct soc_enum), GFP_KERNEL);\n\tif (!*private_value) {\n\t\tdev_err(card->dev, \"ASoC: Failed to create control for %s widget\\n\",\n\t\t\tlink_name);\n\t\tgoto outfree_w_param;\n\t}\n\tkcontrol_dai_link[0].private_value = *private_value;\n\t \n\tkcontrol_news = devm_kmemdup(card->dev, &kcontrol_dai_link[0],\n\t\t\t\t\tsizeof(struct snd_kcontrol_new),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!kcontrol_news) {\n\t\tdev_err(card->dev, \"ASoC: Failed to create control for %s widget\\n\",\n\t\t\tlink_name);\n\t\tgoto outfree_w_param;\n\t}\n\treturn kcontrol_news;\n\noutfree_w_param:\n\tsnd_soc_dapm_free_kcontrol(card, private_value, num_c2c_params, w_param_text);\n\treturn NULL;\n}\n\nstatic struct snd_soc_dapm_widget *\nsnd_soc_dapm_new_dai(struct snd_soc_card *card,\n\t\t     struct snd_pcm_substream *substream,\n\t\t     char *id)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dapm_widget template;\n\tstruct snd_soc_dapm_widget *w;\n\tconst struct snd_kcontrol_new *kcontrol_news;\n\tint num_kcontrols;\n\tconst char **w_param_text;\n\tunsigned long private_value = 0;\n\tchar *link_name;\n\tint ret = -ENOMEM;\n\n\tlink_name = devm_kasprintf(card->dev, GFP_KERNEL, \"%s-%s\",\n\t\t\t\t   rtd->dai_link->name, id);\n\tif (!link_name)\n\t\tgoto name_fail;\n\n\t \n\tw_param_text\t= NULL;\n\tkcontrol_news\t= NULL;\n\tnum_kcontrols\t= 0;\n\tif (rtd->dai_link->num_c2c_params > 1) {\n\t\tw_param_text = devm_kcalloc(card->dev,\n\t\t\t\t\t    rtd->dai_link->num_c2c_params,\n\t\t\t\t\t    sizeof(char *), GFP_KERNEL);\n\t\tif (!w_param_text)\n\t\t\tgoto param_fail;\n\n\t\tnum_kcontrols = 1;\n\t\tkcontrol_news = snd_soc_dapm_alloc_kcontrol(card, link_name,\n\t\t\t\t\t\t\t    rtd->dai_link->c2c_params,\n\t\t\t\t\t\t\t    rtd->dai_link->num_c2c_params,\n\t\t\t\t\t\t\t    w_param_text, &private_value);\n\t\tif (!kcontrol_news)\n\t\t\tgoto param_fail;\n\t}\n\n\tmemset(&template, 0, sizeof(template));\n\ttemplate.reg\t\t= SND_SOC_NOPM;\n\ttemplate.id\t\t= snd_soc_dapm_dai_link;\n\ttemplate.name\t\t= link_name;\n\ttemplate.event\t\t= snd_soc_dai_link_event;\n\ttemplate.event_flags\t= SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t\t  SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD;\n\ttemplate.kcontrol_news\t= kcontrol_news;\n\ttemplate.num_kcontrols\t= num_kcontrols;\n\n\tdev_dbg(card->dev, \"ASoC: adding %s widget\\n\", link_name);\n\n\tw = snd_soc_dapm_new_control_unlocked(&card->dapm, &template);\n\tif (IS_ERR(w)) {\n\t\tret = PTR_ERR(w);\n\t\tgoto outfree_kcontrol_news;\n\t}\n\n\tw->priv = substream;\n\n\treturn w;\n\noutfree_kcontrol_news:\n\tdevm_kfree(card->dev, (void *)template.kcontrol_news);\n\tsnd_soc_dapm_free_kcontrol(card, &private_value,\n\t\t\t\t   rtd->dai_link->num_c2c_params, w_param_text);\nparam_fail:\n\tdevm_kfree(card->dev, link_name);\nname_fail:\n\tdev_err(rtd->dev, \"ASoC: Failed to create %s-%s widget: %d\\n\",\n\t\trtd->dai_link->name, id, ret);\n\treturn ERR_PTR(ret);\n}\n\n \nint snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dapm_widget template;\n\tstruct snd_soc_dapm_widget *w;\n\n\tWARN_ON(dapm->dev != dai->dev);\n\n\tmemset(&template, 0, sizeof(template));\n\ttemplate.reg = SND_SOC_NOPM;\n\n\tif (dai->driver->playback.stream_name) {\n\t\ttemplate.id = snd_soc_dapm_dai_in;\n\t\ttemplate.name = dai->driver->playback.stream_name;\n\t\ttemplate.sname = dai->driver->playback.stream_name;\n\n\t\tdev_dbg(dai->dev, \"ASoC: adding %s widget\\n\",\n\t\t\ttemplate.name);\n\n\t\tw = snd_soc_dapm_new_control_unlocked(dapm, &template);\n\t\tif (IS_ERR(w))\n\t\t\treturn PTR_ERR(w);\n\n\t\tw->priv = dai;\n\t\tsnd_soc_dai_set_widget_playback(dai, w);\n\t}\n\n\tif (dai->driver->capture.stream_name) {\n\t\ttemplate.id = snd_soc_dapm_dai_out;\n\t\ttemplate.name = dai->driver->capture.stream_name;\n\t\ttemplate.sname = dai->driver->capture.stream_name;\n\n\t\tdev_dbg(dai->dev, \"ASoC: adding %s widget\\n\",\n\t\t\ttemplate.name);\n\n\t\tw = snd_soc_dapm_new_control_unlocked(dapm, &template);\n\t\tif (IS_ERR(w))\n\t\t\treturn PTR_ERR(w);\n\n\t\tw->priv = dai;\n\t\tsnd_soc_dai_set_widget_capture(dai, w);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_new_dai_widgets);\n\nint snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_widget *dai_w, *w;\n\tstruct snd_soc_dapm_widget *src, *sink;\n\tstruct snd_soc_dai *dai;\n\n\t \n\tfor_each_card_widgets(card, dai_w) {\n\t\tswitch (dai_w->id) {\n\t\tcase snd_soc_dapm_dai_in:\n\t\tcase snd_soc_dapm_dai_out:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!dai_w->priv) {\n\t\t\tdev_dbg(card->dev, \"dai widget %s has no DAI\\n\",\n\t\t\t\tdai_w->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdai = dai_w->priv;\n\n\t\t \n\t\tfor_each_card_widgets(card, w) {\n\t\t\tif (w->dapm != dai_w->dapm)\n\t\t\t\tcontinue;\n\n\t\t\tswitch (w->id) {\n\t\t\tcase snd_soc_dapm_dai_in:\n\t\t\tcase snd_soc_dapm_dai_out:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!w->sname || !strstr(w->sname, dai_w->sname))\n\t\t\t\tcontinue;\n\n\t\t\tif (dai_w->id == snd_soc_dapm_dai_in) {\n\t\t\t\tsrc = dai_w;\n\t\t\t\tsink = w;\n\t\t\t} else {\n\t\t\t\tsrc = w;\n\t\t\t\tsink = dai_w;\n\t\t\t}\n\t\t\tdev_dbg(dai->dev, \"%s -> %s\\n\", src->name, sink->name);\n\t\t\tsnd_soc_dapm_add_path(w->dapm, src, sink, NULL, NULL);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dapm_connect_dai_routes(struct snd_soc_dapm_context *dapm,\n\t\t\t\t    struct snd_soc_dai *src_dai,\n\t\t\t\t    struct snd_soc_dapm_widget *src,\n\t\t\t\t    struct snd_soc_dapm_widget *dai,\n\t\t\t\t    struct snd_soc_dai *sink_dai,\n\t\t\t\t    struct snd_soc_dapm_widget *sink)\n{\n\tdev_dbg(dapm->dev, \"connected DAI link %s:%s -> %s:%s\\n\",\n\t\tsrc_dai->component->name, src->name,\n\t\tsink_dai->component->name, sink->name);\n\n\tif (dai) {\n\t\tsnd_soc_dapm_add_path(dapm, src, dai, NULL, NULL);\n\t\tsrc = dai;\n\t}\n\n\tsnd_soc_dapm_add_path(dapm, src, sink, NULL, NULL);\n}\n\nstatic void dapm_connect_dai_pair(struct snd_soc_card *card,\n\t\t\t\t  struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t  struct snd_soc_dai *codec_dai,\n\t\t\t\t  struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tstruct snd_soc_dapm_widget *codec, *cpu;\n\tstruct snd_soc_dai *src_dai[]\t\t= { cpu_dai,\tcodec_dai };\n\tstruct snd_soc_dai *sink_dai[]\t\t= { codec_dai,\tcpu_dai };\n\tstruct snd_soc_dapm_widget **src[]\t= { &cpu,\t&codec };\n\tstruct snd_soc_dapm_widget **sink[]\t= { &codec,\t&cpu };\n\tchar *widget_name[]\t\t\t= { \"playback\",\t\"capture\" };\n\tint stream;\n\n\tfor_each_pcm_streams(stream) {\n\t\tint stream_cpu, stream_codec;\n\n\t\tstream_cpu\t= snd_soc_get_stream_cpu(dai_link, stream);\n\t\tstream_codec\t= stream;\n\n\t\t \n\t\tcpu\t= snd_soc_dai_get_widget(cpu_dai,\tstream_cpu);\n\t\tcodec\t= snd_soc_dai_get_widget(codec_dai,\tstream_codec);\n\n\t\tif (!cpu || !codec)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dai_link->c2c_params && !rtd->c2c_widget[stream]) {\n\t\t\tstruct snd_pcm_substream *substream = rtd->pcm->streams[stream].substream;\n\t\t\tstruct snd_soc_dapm_widget *dai = snd_soc_dapm_new_dai(card, substream,\n\t\t\t\t\t\t\t\t\t       widget_name[stream]);\n\n\t\t\tif (IS_ERR(dai))\n\t\t\t\tcontinue;\n\n\t\t\trtd->c2c_widget[stream] = dai;\n\t\t}\n\n\t\tdapm_connect_dai_routes(&card->dapm, src_dai[stream], *src[stream],\n\t\t\t\t\trtd->c2c_widget[stream],\n\t\t\t\t\tsink_dai[stream], *sink[stream]);\n\t}\n}\n\nstatic void soc_dapm_dai_stream_event(struct snd_soc_dai *dai, int stream,\n\tint event)\n{\n\tstruct snd_soc_dapm_widget *w;\n\n\tw = snd_soc_dai_get_widget(dai, stream);\n\n\tif (w) {\n\t\tunsigned int ep;\n\n\t\tdapm_mark_dirty(w, \"stream event\");\n\n\t\tif (w->id == snd_soc_dapm_dai_in) {\n\t\t\tep = SND_SOC_DAPM_EP_SOURCE;\n\t\t\tdapm_widget_invalidate_input_paths(w);\n\t\t} else {\n\t\t\tep = SND_SOC_DAPM_EP_SINK;\n\t\t\tdapm_widget_invalidate_output_paths(w);\n\t\t}\n\n\t\tswitch (event) {\n\t\tcase SND_SOC_DAPM_STREAM_START:\n\t\t\tw->active = 1;\n\t\t\tw->is_ep = ep;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAPM_STREAM_STOP:\n\t\t\tw->active = 0;\n\t\t\tw->is_ep = 0;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAPM_STREAM_SUSPEND:\n\t\tcase SND_SOC_DAPM_STREAM_RESUME:\n\t\tcase SND_SOC_DAPM_STREAM_PAUSE_PUSH:\n\t\tcase SND_SOC_DAPM_STREAM_PAUSE_RELEASE:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid snd_soc_dapm_connect_dai_link_widgets(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *codec_dai;\n\tint i;\n\n\t \n\tfor_each_card_rtds(card, rtd)  {\n\t\t \n\t\tif (rtd->dai_link->dynamic)\n\t\t\tcontinue;\n\n\t\tif (rtd->dai_link->num_cpus == 1) {\n\t\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai)\n\t\t\t\tdapm_connect_dai_pair(card, rtd, codec_dai,\n\t\t\t\t\t\t      asoc_rtd_to_cpu(rtd, 0));\n\t\t} else if (rtd->dai_link->num_codecs == rtd->dai_link->num_cpus) {\n\t\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai)\n\t\t\t\tdapm_connect_dai_pair(card, rtd, codec_dai,\n\t\t\t\t\t\t      asoc_rtd_to_cpu(rtd, i));\n\t\t} else if (rtd->dai_link->num_codecs > rtd->dai_link->num_cpus) {\n\t\t\tint cpu_id;\n\n\t\t\tif (!rtd->dai_link->codec_ch_maps) {\n\t\t\t\tdev_err(card->dev, \"%s: no codec channel mapping table provided\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\t\t\tcpu_id = rtd->dai_link->codec_ch_maps[i].connected_cpu_id;\n\t\t\t\tif (cpu_id >= rtd->dai_link->num_cpus) {\n\t\t\t\t\tdev_err(card->dev,\n\t\t\t\t\t\t\"%s: dai_link %s cpu_id %d too large, num_cpus is %d\\n\",\n\t\t\t\t\t\t__func__, rtd->dai_link->name, cpu_id,\n\t\t\t\t\t\trtd->dai_link->num_cpus);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdapm_connect_dai_pair(card, rtd, codec_dai,\n\t\t\t\t\t\t      asoc_rtd_to_cpu(rtd, cpu_id));\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"%s: codec number %d < cpu number %d is not supported\\n\",\n\t\t\t\t__func__, rtd->dai_link->num_codecs, rtd->dai_link->num_cpus);\n\t\t}\n\t}\n}\n\nstatic void soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,\n\tint event)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tfor_each_rtd_dais(rtd, i, dai)\n\t\tsoc_dapm_dai_stream_event(dai, stream, event);\n\n\tdapm_power_widgets(rtd->card, event);\n}\n\n \nvoid snd_soc_dapm_stream_event(struct snd_soc_pcm_runtime *rtd, int stream,\n\t\t\t      int event)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\n\tsnd_soc_dapm_mutex_lock(card);\n\tsoc_dapm_stream_event(rtd, stream, event);\n\tsnd_soc_dapm_mutex_unlock(card);\n}\n\nvoid snd_soc_dapm_stream_stop(struct snd_soc_pcm_runtime *rtd, int stream)\n{\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (snd_soc_runtime_ignore_pmdown_time(rtd)) {\n\t\t\t \n\t\t\tsnd_soc_dapm_stream_event(rtd,\n\t\t\t\t\t\t  SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t\t  SND_SOC_DAPM_STREAM_STOP);\n\t\t} else {\n\t\t\t \n\t\t\trtd->pop_wait = 1;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t   &rtd->delayed_work,\n\t\t\t\t\t   msecs_to_jiffies(rtd->pmdown_time));\n\t\t}\n\t} else {\n\t\t \n\t\tsnd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t  SND_SOC_DAPM_STREAM_STOP);\n\t}\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_stream_stop);\n\n \nint snd_soc_dapm_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t\t   const char *pin)\n{\n\treturn snd_soc_dapm_set_pin(dapm, pin, 1);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_enable_pin_unlocked);\n\n \nint snd_soc_dapm_enable_pin(struct snd_soc_dapm_context *dapm, const char *pin)\n{\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tret = snd_soc_dapm_set_pin(dapm, pin, 1);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_enable_pin);\n\n \nint snd_soc_dapm_force_enable_pin_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t\t\t const char *pin)\n{\n\tstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\n\n\tif (!w) {\n\t\tdev_err(dapm->dev, \"ASoC: unknown pin %s\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(w->dapm->dev, \"ASoC: force enable pin %s\\n\", pin);\n\tif (!w->connected) {\n\t\t \n\t\tdapm_widget_invalidate_input_paths(w);\n\t\tdapm_widget_invalidate_output_paths(w);\n\t\tw->connected = 1;\n\t}\n\tw->force = 1;\n\tdapm_mark_dirty(w, \"force enable\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_force_enable_pin_unlocked);\n\n \nint snd_soc_dapm_force_enable_pin(struct snd_soc_dapm_context *dapm,\n\t\t\t\t  const char *pin)\n{\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tret = snd_soc_dapm_force_enable_pin_unlocked(dapm, pin);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_force_enable_pin);\n\n \nint snd_soc_dapm_disable_pin_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t\t    const char *pin)\n{\n\treturn snd_soc_dapm_set_pin(dapm, pin, 0);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_disable_pin_unlocked);\n\n \nint snd_soc_dapm_disable_pin(struct snd_soc_dapm_context *dapm,\n\t\t\t     const char *pin)\n{\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tret = snd_soc_dapm_set_pin(dapm, pin, 0);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_disable_pin);\n\n \nint snd_soc_dapm_nc_pin_unlocked(struct snd_soc_dapm_context *dapm,\n\t\t\t       const char *pin)\n{\n\treturn snd_soc_dapm_set_pin(dapm, pin, 0);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_nc_pin_unlocked);\n\n \nint snd_soc_dapm_nc_pin(struct snd_soc_dapm_context *dapm, const char *pin)\n{\n\tint ret;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tret = snd_soc_dapm_set_pin(dapm, pin, 0);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_nc_pin);\n\n \nint snd_soc_dapm_get_pin_status(struct snd_soc_dapm_context *dapm,\n\t\t\t\tconst char *pin)\n{\n\tstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, true);\n\n\tif (w)\n\t\treturn w->connected;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_status);\n\n \nint snd_soc_dapm_ignore_suspend(struct snd_soc_dapm_context *dapm,\n\t\t\t\tconst char *pin)\n{\n\tstruct snd_soc_dapm_widget *w = dapm_find_widget(dapm, pin, false);\n\n\tif (!w) {\n\t\tdev_err(dapm->dev, \"ASoC: unknown pin %s\\n\", pin);\n\t\treturn -EINVAL;\n\t}\n\n\tw->ignore_suspend = 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_ignore_suspend);\n\n \nvoid snd_soc_dapm_free(struct snd_soc_dapm_context *dapm)\n{\n\tdapm_debugfs_cleanup(dapm);\n\tdapm_free_widgets(dapm);\n\tlist_del(&dapm->list);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_free);\n\nvoid snd_soc_dapm_init(struct snd_soc_dapm_context *dapm,\n\t\t       struct snd_soc_card *card,\n\t\t       struct snd_soc_component *component)\n{\n\tdapm->card\t\t= card;\n\tdapm->component\t\t= component;\n\tdapm->bias_level\t= SND_SOC_BIAS_OFF;\n\n\tif (component) {\n\t\tdapm->dev\t\t= component->dev;\n\t\tdapm->idle_bias_off\t= !component->driver->idle_bias_on;\n\t\tdapm->suspend_bias_off\t= component->driver->suspend_bias_off;\n\t} else {\n\t\tdapm->dev\t\t= card->dev;\n\t}\n\n\tINIT_LIST_HEAD(&dapm->list);\n\t \n\tlist_add(&dapm->list, &card->dapm_list);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dapm_init);\n\nstatic void soc_dapm_shutdown_dapm(struct snd_soc_dapm_context *dapm)\n{\n\tstruct snd_soc_card *card = dapm->card;\n\tstruct snd_soc_dapm_widget *w;\n\tLIST_HEAD(down_list);\n\tint powerdown = 0;\n\n\tsnd_soc_dapm_mutex_lock_root(card);\n\n\tfor_each_card_widgets(dapm->card, w) {\n\t\tif (w->dapm != dapm)\n\t\t\tcontinue;\n\t\tif (w->power) {\n\t\t\tdapm_seq_insert(w, &down_list, false);\n\t\t\tw->new_power = 0;\n\t\t\tpowerdown = 1;\n\t\t}\n\t}\n\n\t \n\tif (powerdown) {\n\t\tif (dapm->bias_level == SND_SOC_BIAS_ON)\n\t\t\tsnd_soc_dapm_set_bias_level(dapm,\n\t\t\t\t\t\t    SND_SOC_BIAS_PREPARE);\n\t\tdapm_seq_run(card, &down_list, 0, false);\n\t\tif (dapm->bias_level == SND_SOC_BIAS_PREPARE)\n\t\t\tsnd_soc_dapm_set_bias_level(dapm,\n\t\t\t\t\t\t    SND_SOC_BIAS_STANDBY);\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(card);\n}\n\n \nvoid snd_soc_dapm_shutdown(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\n\tfor_each_card_dapms(card, dapm) {\n\t\tif (dapm != &card->dapm) {\n\t\t\tsoc_dapm_shutdown_dapm(dapm);\n\t\t\tif (dapm->bias_level == SND_SOC_BIAS_STANDBY)\n\t\t\t\tsnd_soc_dapm_set_bias_level(dapm,\n\t\t\t\t\t\t\t    SND_SOC_BIAS_OFF);\n\t\t}\n\t}\n\n\tsoc_dapm_shutdown_dapm(&card->dapm);\n\tif (card->dapm.bias_level == SND_SOC_BIAS_STANDBY)\n\t\tsnd_soc_dapm_set_bias_level(&card->dapm,\n\t\t\t\t\t    SND_SOC_BIAS_OFF);\n}\n\n \nMODULE_AUTHOR(\"Liam Girdwood, lrg@slimlogic.co.uk\");\nMODULE_DESCRIPTION(\"Dynamic Audio Power Management core for ALSA SoC\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}