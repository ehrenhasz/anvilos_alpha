{
  "module_name": "ipc4-control.c",
  "hash_id": "e1e53e8e3ff381161b75ec4b37dc857054c7abad2f458faa43ddb822a65508c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc4-control.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc4-priv.h\"\n#include \"ipc4-topology.h\"\n\nstatic int sof_ipc4_set_get_kcontrol_data(struct snd_sof_control *scontrol,\n\t\t\t\t\t  bool set, bool lock)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tstruct sof_ipc4_msg *msg = &cdata->msg;\n\tstruct snd_sof_widget *swidget;\n\tbool widget_found = false;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->comp_id == scontrol->comp_id) {\n\t\t\twidget_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!widget_found) {\n\t\tdev_err(scomp->dev, \"Failed to find widget for kcontrol %s\\n\", scontrol->name);\n\t\treturn -ENOENT;\n\t}\n\n\tif (lock)\n\t\tmutex_lock(&swidget->setup_mutex);\n\telse\n\t\tlockdep_assert_held(&swidget->setup_mutex);\n\n\t \n\tif (!swidget->use_count)\n\t\tgoto unlock;\n\n\tmsg->primary &= ~SOF_IPC4_MOD_INSTANCE_MASK;\n\tmsg->primary |= SOF_IPC4_MOD_INSTANCE(swidget->instance_id);\n\n\tret = iops->set_get_data(sdev, msg, msg->data_size, set);\n\tif (!set)\n\t\tgoto unlock;\n\n\t \n\tif (ret < 0) {\n\t\tif (!scontrol->old_ipc_control_data)\n\t\t\tgoto unlock;\n\t\t \n\t\tmemcpy(scontrol->ipc_control_data, scontrol->old_ipc_control_data,\n\t\t       scontrol->max_size);\n\t\tkfree(scontrol->old_ipc_control_data);\n\t\tscontrol->old_ipc_control_data = NULL;\n\t\t \n\t\tret = iops->set_get_data(sdev, msg, msg->data_size, set);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tif (lock)\n\t\tmutex_unlock(&swidget->setup_mutex);\n\n\treturn ret;\n}\n\nstatic int\nsof_ipc4_set_volume_data(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,\n\t\t\t struct snd_sof_control *scontrol, bool lock)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct sof_ipc4_gain *gain = swidget->private;\n\tstruct sof_ipc4_msg *msg = &cdata->msg;\n\tstruct sof_ipc4_gain_params params;\n\tbool all_channels_equal = true;\n\tu32 value;\n\tint ret, i;\n\n\t \n\tvalue = cdata->chanv[0].value;\n\tfor (i = 1; i < scontrol->num_channels; i++) {\n\t\tif (cdata->chanv[i].value != value) {\n\t\t\tall_channels_equal = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < scontrol->num_channels; i++) {\n\t\tif (all_channels_equal) {\n\t\t\tparams.channels = SOF_IPC4_GAIN_ALL_CHANNELS_MASK;\n\t\t\tparams.init_val = cdata->chanv[0].value;\n\t\t} else {\n\t\t\tparams.channels = cdata->chanv[i].channel;\n\t\t\tparams.init_val = cdata->chanv[i].value;\n\t\t}\n\n\t\t \n\t\tparams.curve_duration_l = gain->data.params.curve_duration_l;\n\t\tparams.curve_duration_h = gain->data.params.curve_duration_h;\n\t\tparams.curve_type = gain->data.params.curve_type;\n\n\t\tmsg->data_ptr = &params;\n\t\tmsg->data_size = sizeof(params);\n\n\t\tret = sof_ipc4_set_get_kcontrol_data(scontrol, true, lock);\n\t\tmsg->data_ptr = NULL;\n\t\tmsg->data_size = 0;\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Failed to set volume update for %s\\n\",\n\t\t\t\tscontrol->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (all_channels_equal)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic bool sof_ipc4_volume_put(struct snd_sof_control *scontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tunsigned int channels = scontrol->num_channels;\n\tstruct snd_sof_widget *swidget;\n\tbool widget_found = false;\n\tbool change = false;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tu32 value = mixer_to_ipc(ucontrol->value.integer.value[i],\n\t\t\t\t\t scontrol->volume_table, scontrol->max + 1);\n\n\t\tchange = change || (value != cdata->chanv[i].value);\n\t\tcdata->chanv[i].channel = i;\n\t\tcdata->chanv[i].value = value;\n\t}\n\n\tif (!pm_runtime_active(scomp->dev))\n\t\treturn change;\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->comp_id == scontrol->comp_id) {\n\t\t\twidget_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!widget_found) {\n\t\tdev_err(scomp->dev, \"Failed to find widget for kcontrol %s\\n\", scontrol->name);\n\t\treturn false;\n\t}\n\n\tret = sof_ipc4_set_volume_data(sdev, swidget, scontrol, true);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn change;\n}\n\nstatic int sof_ipc4_volume_get(struct snd_sof_control *scontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\n\tfor (i = 0; i < channels; i++)\n\t\tucontrol->value.integer.value[i] = ipc_to_mixer(cdata->chanv[i].value,\n\t\t\t\t\t\t\t\tscontrol->volume_table,\n\t\t\t\t\t\t\t\tscontrol->max + 1);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_set_get_bytes_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct snd_sof_control *scontrol,\n\t\t\t\t       bool set, bool lock)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct sof_abi_hdr *data = cdata->data;\n\tstruct sof_ipc4_msg *msg = &cdata->msg;\n\tint ret = 0;\n\n\t \n\tif (set && !pm_runtime_active(sdev->dev))\n\t\treturn 0;\n\n\tmsg->extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(data->type);\n\n\tmsg->data_ptr = data->data;\n\tmsg->data_size = data->size;\n\n\tret = sof_ipc4_set_get_kcontrol_data(scontrol, set, lock);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"Failed to %s for %s\\n\",\n\t\t\tset ? \"set bytes update\" : \"get bytes\",\n\t\t\tscontrol->name);\n\n\tmsg->data_ptr = NULL;\n\tmsg->data_size = 0;\n\n\treturn ret;\n}\n\nstatic int sof_ipc4_bytes_put(struct snd_sof_control *scontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_abi_hdr *data = cdata->data;\n\tsize_t size;\n\n\tif (scontrol->max_size > sizeof(ucontrol->value.bytes.data)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"data max %zu exceeds ucontrol data array size\\n\",\n\t\t\t\t    scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->size > scontrol->max_size - sizeof(*data)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"data size too big %u bytes max is %zu\\n\",\n\t\t\t\t    data->size, scontrol->max_size - sizeof(*data));\n\t\treturn -EINVAL;\n\t}\n\n\tsize = data->size + sizeof(*data);\n\n\t \n\tmemcpy(data, ucontrol->value.bytes.data, size);\n\n\tsof_ipc4_set_get_bytes_data(sdev, scontrol, true, true);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_bytes_get(struct snd_sof_control *scontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct sof_abi_hdr *data = cdata->data;\n\tsize_t size;\n\n\tif (scontrol->max_size > sizeof(ucontrol->value.bytes.data)) {\n\t\tdev_err_ratelimited(scomp->dev, \"data max %zu exceeds ucontrol data array size\\n\",\n\t\t\t\t    scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (data->size > scontrol->max_size - sizeof(*data)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"%u bytes of control data is invalid, max is %zu\\n\",\n\t\t\t\t    data->size, scontrol->max_size - sizeof(*data));\n\t\treturn -EINVAL;\n\t}\n\n\tsize = data->size + sizeof(*data);\n\n\t \n\tmemcpy(ucontrol->value.bytes.data, data, size);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_bytes_ext_put(struct snd_sof_control *scontrol,\n\t\t\t\t  const unsigned int __user *binary_data,\n\t\t\t\t  unsigned int size)\n{\n\tstruct snd_ctl_tlv __user *tlvd = (struct snd_ctl_tlv __user *)binary_data;\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_abi_hdr *data = cdata->data;\n\tstruct sof_abi_hdr abi_hdr;\n\tstruct snd_ctl_tlv header;\n\n\t \n\tif (copy_from_user(&header, tlvd, sizeof(struct snd_ctl_tlv)))\n\t\treturn -EFAULT;\n\n\t \n\tif (header.length + sizeof(struct snd_ctl_tlv) > size) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"Inconsistent TLV, data %d + header %zu > %d\\n\",\n\t\t\t\t    header.length, sizeof(struct snd_ctl_tlv), size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (header.length > scontrol->max_size) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"Bytes data size %d exceeds max %zu\\n\",\n\t\t\t\t    header.length, scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (copy_from_user(&abi_hdr, tlvd->tlv, sizeof(abi_hdr)))\n\t\treturn -EFAULT;\n\n\tif (abi_hdr.magic != SOF_IPC4_ABI_MAGIC) {\n\t\tdev_err_ratelimited(scomp->dev, \"Wrong ABI magic 0x%08x\\n\",\n\t\t\t\t    abi_hdr.magic);\n\t\treturn -EINVAL;\n\t}\n\n\tif (abi_hdr.size > scontrol->max_size - sizeof(abi_hdr)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"%u bytes of control data is invalid, max is %zu\\n\",\n\t\t\t\t    abi_hdr.size, scontrol->max_size - sizeof(abi_hdr));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!scontrol->old_ipc_control_data) {\n\t\t \n\t\tscontrol->old_ipc_control_data = kmemdup(scontrol->ipc_control_data,\n\t\t\t\t\t\t\t scontrol->max_size, GFP_KERNEL);\n\t\tif (!scontrol->old_ipc_control_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (copy_from_user(data, tlvd->tlv, header.length)) {\n\t\tmemcpy(scontrol->ipc_control_data, scontrol->old_ipc_control_data,\n\t\t       scontrol->max_size);\n\t\tkfree(scontrol->old_ipc_control_data);\n\t\tscontrol->old_ipc_control_data = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\treturn sof_ipc4_set_get_bytes_data(sdev, scontrol, true, true);\n}\n\nstatic int _sof_ipc4_bytes_ext_get(struct snd_sof_control *scontrol,\n\t\t\t\t   const unsigned int __user *binary_data,\n\t\t\t\t   unsigned int size, bool from_dsp)\n{\n\tstruct snd_ctl_tlv __user *tlvd = (struct snd_ctl_tlv __user *)binary_data;\n\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct sof_abi_hdr *data = cdata->data;\n\tstruct snd_ctl_tlv header;\n\tsize_t data_size;\n\n\t \n\tif (size < sizeof(struct snd_ctl_tlv))\n\t\treturn -ENOSPC;\n\n\tsize -= sizeof(struct snd_ctl_tlv);\n\n\t \n\tif (from_dsp) {\n\t\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\t\tint ret = sof_ipc4_set_get_bytes_data(sdev, scontrol, false, true);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tdata->magic = SOF_IPC4_ABI_MAGIC;\n\t}\n\n\tif (data->size > scontrol->max_size - sizeof(*data)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"%u bytes of control data is invalid, max is %zu\\n\",\n\t\t\t\t    data->size, scontrol->max_size - sizeof(*data));\n\t\treturn -EINVAL;\n\t}\n\n\tdata_size = data->size + sizeof(struct sof_abi_hdr);\n\n\t \n\tif (data_size > size)\n\t\treturn -ENOSPC;\n\n\theader.numid = scontrol->comp_id;\n\theader.length = data_size;\n\n\tif (copy_to_user(tlvd, &header, sizeof(struct snd_ctl_tlv)))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(tlvd->tlv, data, data_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_bytes_ext_get(struct snd_sof_control *scontrol,\n\t\t\t\t  const unsigned int __user *binary_data,\n\t\t\t\t  unsigned int size)\n{\n\treturn _sof_ipc4_bytes_ext_get(scontrol, binary_data, size, false);\n}\n\nstatic int sof_ipc4_bytes_ext_volatile_get(struct snd_sof_control *scontrol,\n\t\t\t\t\t   const unsigned int __user *binary_data,\n\t\t\t\t\t   unsigned int size)\n{\n\treturn _sof_ipc4_bytes_ext_get(scontrol, binary_data, size, true);\n}\n\n \nstatic int sof_ipc4_widget_kcontrol_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tstruct snd_sof_control *scontrol;\n\tint ret = 0;\n\n\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list) {\n\t\tif (scontrol->comp_id == swidget->comp_id) {\n\t\t\tswitch (scontrol->info_type) {\n\t\t\tcase SND_SOC_TPLG_CTL_VOLSW:\n\t\t\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\t\t\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\t\t\tret = sof_ipc4_set_volume_data(sdev, swidget,\n\t\t\t\t\t\t\t       scontrol, false);\n\t\t\t\tbreak;\n\t\t\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\t\t\tret = sof_ipc4_set_get_bytes_data(sdev, scontrol,\n\t\t\t\t\t\t\t\t  true, false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev,\n\t\t\t\t\t\"kcontrol %d set up failed for widget %s\\n\",\n\t\t\t\t\tscontrol->comp_id, swidget->widget->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsof_ipc4_set_up_volume_table(struct snd_sof_control *scontrol, int tlv[SOF_TLV_ITEMS], int size)\n{\n\tint i;\n\n\t \n\tscontrol->volume_table = kcalloc(size, sizeof(u32), GFP_KERNEL);\n\tif (!scontrol->volume_table)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < size ; i++) {\n\t\tu32 val = vol_compute_gain(i, tlv);\n\t\tu64 q31val = ((u64)val) << 15;  \n\n\t\tscontrol->volume_table[i] = q31val > SOF_IPC4_VOL_ZERO_DB ?\n\t\t\t\t\t\tSOF_IPC4_VOL_ZERO_DB : q31val;\n\t}\n\n\treturn 0;\n}\n\nconst struct sof_ipc_tplg_control_ops tplg_ipc4_control_ops = {\n\t.volume_put = sof_ipc4_volume_put,\n\t.volume_get = sof_ipc4_volume_get,\n\t.bytes_put = sof_ipc4_bytes_put,\n\t.bytes_get = sof_ipc4_bytes_get,\n\t.bytes_ext_put = sof_ipc4_bytes_ext_put,\n\t.bytes_ext_get = sof_ipc4_bytes_ext_get,\n\t.bytes_ext_volatile_get = sof_ipc4_bytes_ext_volatile_get,\n\t.widget_kcontrol_setup = sof_ipc4_widget_kcontrol_setup,\n\t.set_up_volume_table = sof_ipc4_set_up_volume_table,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}