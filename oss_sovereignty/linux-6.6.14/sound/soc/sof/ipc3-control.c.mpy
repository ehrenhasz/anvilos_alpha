{
  "module_name": "ipc3-control.c",
  "hash_id": "ae9fa1abd8b11d1f66fa419a101c07eb68bf3de574ff71b3b7a08a96f914bed5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3-control.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc3-priv.h\"\n\n \nstatic int sof_ipc3_set_get_kcontrol_data(struct snd_sof_control *scontrol,\n\t\t\t\t\t  bool set, bool lock)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scontrol->scomp);\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tenum sof_ipc_ctrl_type ctrl_type;\n\tstruct snd_sof_widget *swidget;\n\tbool widget_found = false;\n\tu32 ipc_cmd, msg_bytes;\n\tint ret = 0;\n\n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->comp_id == scontrol->comp_id) {\n\t\t\twidget_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!widget_found) {\n\t\tdev_err(sdev->dev, \"%s: can't find widget with id %d\\n\", __func__,\n\t\t\tscontrol->comp_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (lock)\n\t\tmutex_lock(&swidget->setup_mutex);\n\telse\n\t\tlockdep_assert_held(&swidget->setup_mutex);\n\n\t \n\tif (!swidget->use_count)\n\t\tgoto unlock;\n\n\t \n\tif (cdata->cmd == SOF_CTRL_CMD_BINARY) {\n\t\tipc_cmd = set ? SOF_IPC_COMP_SET_DATA : SOF_IPC_COMP_GET_DATA;\n\t\tctrl_type = set ? SOF_CTRL_TYPE_DATA_SET : SOF_CTRL_TYPE_DATA_GET;\n\t} else {\n\t\tipc_cmd = set ? SOF_IPC_COMP_SET_VALUE : SOF_IPC_COMP_GET_VALUE;\n\t\tctrl_type = set ? SOF_CTRL_TYPE_VALUE_CHAN_SET : SOF_CTRL_TYPE_VALUE_CHAN_GET;\n\t}\n\n\tcdata->rhdr.hdr.cmd = SOF_IPC_GLB_COMP_MSG | ipc_cmd;\n\tcdata->type = ctrl_type;\n\tcdata->comp_id = scontrol->comp_id;\n\tcdata->msg_index = 0;\n\n\t \n\tswitch (cdata->type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\tcdata->num_elems = scontrol->num_channels;\n\n\t\tmsg_bytes = scontrol->num_channels *\n\t\t\t    sizeof(struct sof_ipc_ctrl_value_chan);\n\t\tmsg_bytes += sizeof(struct sof_ipc_ctrl_data);\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\tcdata->num_elems = cdata->data->size;\n\n\t\tmsg_bytes = cdata->data->size;\n\t\tmsg_bytes += sizeof(struct sof_ipc_ctrl_data) +\n\t\t\t     sizeof(struct sof_abi_hdr);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tcdata->rhdr.hdr.size = msg_bytes;\n\tcdata->elems_remaining = 0;\n\n\tret = iops->set_get_data(sdev, cdata, cdata->rhdr.hdr.size, set);\n\tif (!set)\n\t\tgoto unlock;\n\n\t \n\tif (ret < 0) {\n\t\tif (!scontrol->old_ipc_control_data)\n\t\t\tgoto unlock;\n\t\t \n\t\tmemcpy(scontrol->ipc_control_data, scontrol->old_ipc_control_data,\n\t\t       scontrol->max_size);\n\t\tkfree(scontrol->old_ipc_control_data);\n\t\tscontrol->old_ipc_control_data = NULL;\n\t\t \n\t\tret = iops->set_get_data(sdev, cdata, cdata->rhdr.hdr.size, set);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tif (lock)\n\t\tmutex_unlock(&swidget->setup_mutex);\n\n\treturn ret;\n}\n\nstatic void sof_ipc3_refresh_control(struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tint ret;\n\n\tif (!scontrol->comp_data_dirty)\n\t\treturn;\n\n\tif (!pm_runtime_active(scomp->dev))\n\t\treturn;\n\n\t \n\tcdata->data->magic = SOF_ABI_MAGIC;\n\tcdata->data->abi = SOF_ABI_VERSION;\n\n\t \n\tscontrol->comp_data_dirty = false;\n\tret = sof_ipc3_set_get_kcontrol_data(scontrol, false, true);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"Failed to get control data: %d\\n\", ret);\n\n\t\t \n\t\tscontrol->comp_data_dirty = true;\n\t}\n}\n\nstatic int sof_ipc3_volume_get(struct snd_sof_control *scontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\n\tsof_ipc3_refresh_control(scontrol);\n\n\t \n\tfor (i = 0; i < channels; i++)\n\t\tucontrol->value.integer.value[i] = ipc_to_mixer(cdata->chanv[i].value,\n\t\t\t\t\t\t\t\tscontrol->volume_table,\n\t\t\t\t\t\t\t\tscontrol->max + 1);\n\n\treturn 0;\n}\n\nstatic bool sof_ipc3_volume_put(struct snd_sof_control *scontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\tbool change = false;\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tu32 value = mixer_to_ipc(ucontrol->value.integer.value[i],\n\t\t\t\t\t scontrol->volume_table, scontrol->max + 1);\n\n\t\tchange = change || (value != cdata->chanv[i].value);\n\t\tcdata->chanv[i].channel = i;\n\t\tcdata->chanv[i].value = value;\n\t}\n\n\t \n\tif (pm_runtime_active(scomp->dev)) {\n\t\tint ret = sof_ipc3_set_get_kcontrol_data(scontrol, true, true);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"Failed to set mixer updates for %s\\n\",\n\t\t\t\tscontrol->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic int sof_ipc3_switch_get(struct snd_sof_control *scontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\n\tsof_ipc3_refresh_control(scontrol);\n\n\t \n\tfor (i = 0; i < channels; i++)\n\t\tucontrol->value.integer.value[i] = cdata->chanv[i].value;\n\n\treturn 0;\n}\n\nstatic bool sof_ipc3_switch_put(struct snd_sof_control *scontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\tbool change = false;\n\tu32 value;\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tvalue = ucontrol->value.integer.value[i];\n\t\tchange = change || (value != cdata->chanv[i].value);\n\t\tcdata->chanv[i].channel = i;\n\t\tcdata->chanv[i].value = value;\n\t}\n\n\t \n\tif (pm_runtime_active(scomp->dev)) {\n\t\tint ret = sof_ipc3_set_get_kcontrol_data(scontrol, true, true);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"Failed to set mixer updates for %s\\n\",\n\t\t\t\tscontrol->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic int sof_ipc3_enum_get(struct snd_sof_control *scontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\n\tsof_ipc3_refresh_control(scontrol);\n\n\t \n\tfor (i = 0; i < channels; i++)\n\t\tucontrol->value.enumerated.item[i] = cdata->chanv[i].value;\n\n\treturn 0;\n}\n\nstatic bool sof_ipc3_enum_put(struct snd_sof_control *scontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tunsigned int channels = scontrol->num_channels;\n\tunsigned int i;\n\tbool change = false;\n\tu32 value;\n\n\t \n\tfor (i = 0; i < channels; i++) {\n\t\tvalue = ucontrol->value.enumerated.item[i];\n\t\tchange = change || (value != cdata->chanv[i].value);\n\t\tcdata->chanv[i].channel = i;\n\t\tcdata->chanv[i].value = value;\n\t}\n\n\t \n\tif (pm_runtime_active(scomp->dev)) {\n\t\tint ret = sof_ipc3_set_get_kcontrol_data(scontrol, true, true);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"Failed to set enum updates for %s\\n\",\n\t\t\t\tscontrol->name);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn change;\n}\n\nstatic int sof_ipc3_bytes_get(struct snd_sof_control *scontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct sof_abi_hdr *data = cdata->data;\n\tsize_t size;\n\n\tsof_ipc3_refresh_control(scontrol);\n\n\tif (scontrol->max_size > sizeof(ucontrol->value.bytes.data)) {\n\t\tdev_err_ratelimited(scomp->dev, \"data max %zu exceeds ucontrol data array size\\n\",\n\t\t\t\t    scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->size > scontrol->max_size - sizeof(*data)) {\n\t\tdev_err_ratelimited(scomp->dev,\n\t\t\t\t    \"%u bytes of control data is invalid, max is %zu\\n\",\n\t\t\t\t    data->size, scontrol->max_size - sizeof(*data));\n\t\treturn -EINVAL;\n\t}\n\n\tsize = data->size + sizeof(*data);\n\n\t \n\tmemcpy(ucontrol->value.bytes.data, data, size);\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_bytes_put(struct snd_sof_control *scontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct sof_abi_hdr *data = cdata->data;\n\tsize_t size;\n\n\tif (scontrol->max_size > sizeof(ucontrol->value.bytes.data)) {\n\t\tdev_err_ratelimited(scomp->dev, \"data max %zu exceeds ucontrol data array size\\n\",\n\t\t\t\t    scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (data->size > scontrol->max_size - sizeof(*data)) {\n\t\tdev_err_ratelimited(scomp->dev, \"data size too big %u bytes max is %zu\\n\",\n\t\t\t\t    data->size, scontrol->max_size - sizeof(*data));\n\t\treturn -EINVAL;\n\t}\n\n\tsize = data->size + sizeof(*data);\n\n\t \n\tmemcpy(data, ucontrol->value.bytes.data, size);\n\n\t \n\tif (pm_runtime_active(scomp->dev))\n\t\treturn sof_ipc3_set_get_kcontrol_data(scontrol, true, true);\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_bytes_ext_put(struct snd_sof_control *scontrol,\n\t\t\t\t  const unsigned int __user *binary_data,\n\t\t\t\t  unsigned int size)\n{\n\tconst struct snd_ctl_tlv __user *tlvd = (const struct snd_ctl_tlv __user *)binary_data;\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_ctl_tlv header;\n\tint ret = -EINVAL;\n\n\t \n\tif (copy_from_user(&header, tlvd, sizeof(struct snd_ctl_tlv)))\n\t\treturn -EFAULT;\n\n\t \n\tif (header.length + sizeof(struct snd_ctl_tlv) > size) {\n\t\tdev_err_ratelimited(scomp->dev, \"Inconsistent TLV, data %d + header %zu > %d\\n\",\n\t\t\t\t    header.length, sizeof(struct snd_ctl_tlv), size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (header.length > scontrol->max_size) {\n\t\tdev_err_ratelimited(scomp->dev, \"Bytes data size %d exceeds max %zu\\n\",\n\t\t\t\t    header.length, scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (header.numid != cdata->cmd) {\n\t\tdev_err_ratelimited(scomp->dev, \"Incorrect command for bytes put %d\\n\",\n\t\t\t\t    header.numid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!scontrol->old_ipc_control_data) {\n\t\t \n\t\tscontrol->old_ipc_control_data = kmemdup(scontrol->ipc_control_data,\n\t\t\t\t\t\t\t scontrol->max_size, GFP_KERNEL);\n\t\tif (!scontrol->old_ipc_control_data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (copy_from_user(cdata->data, tlvd->tlv, header.length)) {\n\t\tret = -EFAULT;\n\t\tgoto err_restore;\n\t}\n\n\tif (cdata->data->magic != SOF_ABI_MAGIC) {\n\t\tdev_err_ratelimited(scomp->dev, \"Wrong ABI magic 0x%08x\\n\", cdata->data->magic);\n\t\tgoto err_restore;\n\t}\n\n\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, cdata->data->abi)) {\n\t\tdev_err_ratelimited(scomp->dev, \"Incompatible ABI version 0x%08x\\n\",\n\t\t\t\t    cdata->data->abi);\n\t\tgoto err_restore;\n\t}\n\n\t \n\tif (cdata->data->size > scontrol->max_size - sizeof(struct sof_abi_hdr)) {\n\t\tdev_err_ratelimited(scomp->dev, \"Mismatch in ABI data size (truncated?)\\n\");\n\t\tgoto err_restore;\n\t}\n\n\t \n\tif (pm_runtime_active(scomp->dev)) {\n\t\t \n\t\treturn sof_ipc3_set_get_kcontrol_data(scontrol, true, true);\n\t}\n\n\treturn 0;\n\nerr_restore:\n\t \n\tif (scontrol->old_ipc_control_data) {\n\t\tmemcpy(cdata->data, scontrol->old_ipc_control_data, scontrol->max_size);\n\t\tkfree(scontrol->old_ipc_control_data);\n\t\tscontrol->old_ipc_control_data = NULL;\n\t}\n\treturn ret;\n}\n\nstatic int _sof_ipc3_bytes_ext_get(struct snd_sof_control *scontrol,\n\t\t\t\t   const unsigned int __user *binary_data,\n\t\t\t\t   unsigned int size, bool from_dsp)\n{\n\tstruct snd_ctl_tlv __user *tlvd = (struct snd_ctl_tlv __user *)binary_data;\n\tstruct sof_ipc_ctrl_data *cdata = scontrol->ipc_control_data;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_ctl_tlv header;\n\tsize_t data_size;\n\n\t \n\tif (size < sizeof(struct snd_ctl_tlv))\n\t\treturn -ENOSPC;\n\n\tsize -= sizeof(struct snd_ctl_tlv);\n\n\t \n\tcdata->data->magic = SOF_ABI_MAGIC;\n\tcdata->data->abi = SOF_ABI_VERSION;\n\n\t \n\tif (from_dsp) {\n\t\tint ret = sof_ipc3_set_get_kcontrol_data(scontrol, false, true);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (cdata->data->size > scontrol->max_size - sizeof(struct sof_abi_hdr)) {\n\t\tdev_err_ratelimited(scomp->dev, \"User data size %d exceeds max size %zu\\n\",\n\t\t\t\t    cdata->data->size,\n\t\t\t\t    scontrol->max_size - sizeof(struct sof_abi_hdr));\n\t\treturn -EINVAL;\n\t}\n\n\tdata_size = cdata->data->size + sizeof(struct sof_abi_hdr);\n\n\t \n\tif (data_size > size)\n\t\treturn -ENOSPC;\n\n\theader.numid = cdata->cmd;\n\theader.length = data_size;\n\tif (copy_to_user(tlvd, &header, sizeof(struct snd_ctl_tlv)))\n\t\treturn -EFAULT;\n\n\tif (copy_to_user(tlvd->tlv, cdata->data, data_size))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_bytes_ext_get(struct snd_sof_control *scontrol,\n\t\t\t\t  const unsigned int __user *binary_data, unsigned int size)\n{\n\treturn _sof_ipc3_bytes_ext_get(scontrol, binary_data, size, false);\n}\n\nstatic int sof_ipc3_bytes_ext_volatile_get(struct snd_sof_control *scontrol,\n\t\t\t\t\t   const unsigned int __user *binary_data,\n\t\t\t\t\t   unsigned int size)\n{\n\treturn _sof_ipc3_bytes_ext_get(scontrol, binary_data, size, true);\n}\n\nstatic void snd_sof_update_control(struct snd_sof_control *scontrol,\n\t\t\t\t   struct sof_ipc_ctrl_data *cdata)\n{\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct sof_ipc_ctrl_data *local_cdata;\n\tint i;\n\n\tlocal_cdata = scontrol->ipc_control_data;\n\n\tif (cdata->cmd == SOF_CTRL_CMD_BINARY) {\n\t\tif (cdata->num_elems != local_cdata->data->size) {\n\t\t\tdev_err(scomp->dev, \"cdata binary size mismatch %u - %u\\n\",\n\t\t\t\tcdata->num_elems, local_cdata->data->size);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tmemcpy(local_cdata->data, cdata->data, cdata->num_elems);\n\t} else if (cdata->num_elems != scontrol->num_channels) {\n\t\tdev_err(scomp->dev, \"cdata channel count mismatch %u - %d\\n\",\n\t\t\tcdata->num_elems, scontrol->num_channels);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < cdata->num_elems; i++)\n\t\t\tlocal_cdata->chanv[i].value = cdata->chanv[i].value;\n\t}\n}\n\nstatic void sof_ipc3_control_update(struct snd_sof_dev *sdev, void *ipc_control_message)\n{\n\tstruct sof_ipc_ctrl_data *cdata = ipc_control_message;\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct snd_sof_control *scontrol;\n\tstruct snd_sof_widget *swidget;\n\tstruct snd_kcontrol *kc = NULL;\n\tstruct soc_mixer_control *sm;\n\tstruct soc_bytes_ext *be;\n\tsize_t expected_size;\n\tstruct soc_enum *se;\n\tbool found = false;\n\tint i, type;\n\n\tif (cdata->type == SOF_CTRL_TYPE_VALUE_COMP_GET ||\n\t    cdata->type == SOF_CTRL_TYPE_VALUE_COMP_SET) {\n\t\tdev_err(sdev->dev, \"Component data is not supported in control notification\\n\");\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->comp_id == cdata->comp_id) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn;\n\n\t \n\tswitch (cdata->cmd) {\n\tcase SOF_CTRL_CMD_VOLUME:\n\tcase SOF_CTRL_CMD_SWITCH:\n\t\ttype = SND_SOC_TPLG_TYPE_MIXER;\n\t\tbreak;\n\tcase SOF_CTRL_CMD_BINARY:\n\t\ttype = SND_SOC_TPLG_TYPE_BYTES;\n\t\tbreak;\n\tcase SOF_CTRL_CMD_ENUM:\n\t\ttype = SND_SOC_TPLG_TYPE_ENUM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"Unknown cmd %u in %s\\n\", cdata->cmd, __func__);\n\t\treturn;\n\t}\n\n\twidget = swidget->widget;\n\tfor (i = 0; i < widget->num_kcontrols; i++) {\n\t\t \n\t\tif (widget->dobj.widget.kcontrol_type[i] == type &&\n\t\t    widget->kcontrol_news[i].index == cdata->index) {\n\t\t\tkc = widget->kcontrols[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!kc)\n\t\treturn;\n\n\tswitch (cdata->cmd) {\n\tcase SOF_CTRL_CMD_VOLUME:\n\tcase SOF_CTRL_CMD_SWITCH:\n\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\tscontrol = sm->dobj.private;\n\t\tbreak;\n\tcase SOF_CTRL_CMD_BINARY:\n\t\tbe = (struct soc_bytes_ext *)kc->private_value;\n\t\tscontrol = be->dobj.private;\n\t\tbreak;\n\tcase SOF_CTRL_CMD_ENUM:\n\t\tse = (struct soc_enum *)kc->private_value;\n\t\tscontrol = se->dobj.private;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\texpected_size = sizeof(struct sof_ipc_ctrl_data);\n\tswitch (cdata->type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\texpected_size += cdata->num_elems *\n\t\t\t\t sizeof(struct sof_ipc_ctrl_value_chan);\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\texpected_size += cdata->num_elems + sizeof(struct sof_abi_hdr);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (cdata->rhdr.hdr.size != expected_size) {\n\t\tdev_err(sdev->dev, \"Component notification size mismatch\\n\");\n\t\treturn;\n\t}\n\n\tif (cdata->num_elems)\n\t\t \n\t\tsnd_sof_update_control(scontrol, cdata);\n\telse\n\t\t \n\t\tscontrol->comp_data_dirty = true;\n\n\tsnd_ctl_notify_one(swidget->scomp->card->snd_card, SNDRV_CTL_EVENT_MASK_VALUE, kc, 0);\n}\n\nstatic int sof_ipc3_widget_kcontrol_setup(struct snd_sof_dev *sdev,\n\t\t\t\t\t  struct snd_sof_widget *swidget)\n{\n\tstruct snd_sof_control *scontrol;\n\tint ret;\n\n\t \n\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list)\n\t\tif (scontrol->comp_id == swidget->comp_id) {\n\t\t\t \n\t\t\tret = sof_ipc3_set_get_kcontrol_data(scontrol, true, false);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev,\n\t\t\t\t\t\"kcontrol %d set up failed for widget %s\\n\",\n\t\t\t\t\tscontrol->comp_id, swidget->widget->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (swidget->dynamic_pipeline_widget)\n\t\t\t\tcontinue;\n\n\t\t\tret = sof_ipc3_set_get_kcontrol_data(scontrol, false, false);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(sdev->dev,\n\t\t\t\t\t \"kcontrol %d read failed for widget %s\\n\",\n\t\t\t\t\t scontrol->comp_id, swidget->widget->name);\n\t\t}\n\n\treturn 0;\n}\n\nstatic int\nsof_ipc3_set_up_volume_table(struct snd_sof_control *scontrol, int tlv[SOF_TLV_ITEMS], int size)\n{\n\tint i;\n\n\t \n\tscontrol->volume_table = kcalloc(size, sizeof(u32), GFP_KERNEL);\n\tif (!scontrol->volume_table)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < size ; i++)\n\t\tscontrol->volume_table[i] = vol_compute_gain(i, tlv);\n\n\treturn 0;\n}\n\nconst struct sof_ipc_tplg_control_ops tplg_ipc3_control_ops = {\n\t.volume_put = sof_ipc3_volume_put,\n\t.volume_get = sof_ipc3_volume_get,\n\t.switch_put = sof_ipc3_switch_put,\n\t.switch_get = sof_ipc3_switch_get,\n\t.enum_put = sof_ipc3_enum_put,\n\t.enum_get = sof_ipc3_enum_get,\n\t.bytes_put = sof_ipc3_bytes_put,\n\t.bytes_get = sof_ipc3_bytes_get,\n\t.bytes_ext_put = sof_ipc3_bytes_ext_put,\n\t.bytes_ext_get = sof_ipc3_bytes_ext_get,\n\t.bytes_ext_volatile_get = sof_ipc3_bytes_ext_volatile_get,\n\t.update = sof_ipc3_control_update,\n\t.widget_kcontrol_setup = sof_ipc3_widget_kcontrol_setup,\n\t.set_up_volume_table = sof_ipc3_set_up_volume_table,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}