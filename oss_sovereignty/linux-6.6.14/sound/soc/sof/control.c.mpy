{
  "module_name": "control.c",
  "hash_id": "d5f1d51352875d2446d04174560558a3322820cc98cdc976963c34669fd91f4e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/control.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/pm_runtime.h>\n#include <linux/leds.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n\nint snd_sof_volume_get(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *sm = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = sm->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->volume_get)\n\t\treturn tplg_ops->control->volume_get(scontrol, ucontrol);\n\n\treturn 0;\n}\n\nint snd_sof_volume_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *sm = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = sm->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->volume_put)\n\t\treturn tplg_ops->control->volume_put(scontrol, ucontrol);\n\n\treturn false;\n}\n\nint snd_sof_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mixer_control *sm = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = sm->dobj.private;\n\tunsigned int channels = scontrol->num_channels;\n\tint platform_max;\n\n\tif (!sm->platform_max)\n\t\tsm->platform_max = sm->max;\n\tplatform_max = sm->platform_max;\n\n\tif (platform_max == 1 && !strstr(kcontrol->id.name, \" Volume\"))\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\n\tuinfo->count = channels;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = platform_max - sm->min;\n\treturn 0;\n}\n\nint snd_sof_switch_get(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *sm = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = sm->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->switch_get)\n\t\treturn tplg_ops->control->switch_get(scontrol, ucontrol);\n\n\treturn 0;\n}\n\nint snd_sof_switch_put(struct snd_kcontrol *kcontrol,\n\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *sm = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = sm->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->switch_put)\n\t\treturn tplg_ops->control->switch_put(scontrol, ucontrol);\n\n\treturn false;\n}\n\nint snd_sof_enum_get(struct snd_kcontrol *kcontrol,\n\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_enum *se = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = se->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->enum_get)\n\t\treturn tplg_ops->control->enum_get(scontrol, ucontrol);\n\n\treturn 0;\n}\n\nint snd_sof_enum_put(struct snd_kcontrol *kcontrol,\n\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_enum *se = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = se->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->enum_put)\n\t\treturn tplg_ops->control->enum_put(scontrol, ucontrol);\n\n\treturn false;\n}\n\nint snd_sof_bytes_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = be->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->bytes_get)\n\t\treturn tplg_ops->control->bytes_get(scontrol, ucontrol);\n\n\treturn 0;\n}\n\nint snd_sof_bytes_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = be->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->bytes_put)\n\t\treturn tplg_ops->control->bytes_put(scontrol, ucontrol);\n\n\treturn 0;\n}\n\nint snd_sof_bytes_ext_put(struct snd_kcontrol *kcontrol,\n\t\t\t  const unsigned int __user *binary_data,\n\t\t\t  unsigned int size)\n{\n\tstruct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = be->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\t \n\tif (size < sizeof(struct snd_ctl_tlv))\n\t\treturn -EINVAL;\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->bytes_ext_put)\n\t\treturn tplg_ops->control->bytes_ext_put(scontrol, binary_data, size);\n\n\treturn 0;\n}\n\nint snd_sof_bytes_ext_volatile_get(struct snd_kcontrol *kcontrol, unsigned int __user *binary_data,\n\t\t\t\t   unsigned int size)\n{\n\tstruct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = be->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tint ret, err;\n\n\tret = pm_runtime_resume_and_get(scomp->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(scomp->dev, \"%s: failed to resume %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->bytes_ext_volatile_get)\n\t\tret = tplg_ops->control->bytes_ext_volatile_get(scontrol, binary_data, size);\n\n\tpm_runtime_mark_last_busy(scomp->dev);\n\terr = pm_runtime_put_autosuspend(scomp->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(scomp->dev, \"%s: failed to idle %d\\n\", __func__, err);\n\n\treturn ret;\n}\n\nint snd_sof_bytes_ext_get(struct snd_kcontrol *kcontrol,\n\t\t\t  unsigned int __user *binary_data,\n\t\t\t  unsigned int size)\n{\n\tstruct soc_bytes_ext *be = (struct soc_bytes_ext *)kcontrol->private_value;\n\tstruct snd_sof_control *scontrol = be->dobj.private;\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->bytes_ext_get)\n\t\treturn tplg_ops->control->bytes_ext_get(scontrol, binary_data, size);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}