{
  "module_name": "sof-client-ipc-flood-test.c",
  "hash_id": "ad8bc74129455ca12d75a6c7e9787ef6f3587f0946b13eff4f2217d7b12c6220",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-client-ipc-flood-test.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <sound/sof/header.h>\n\n#include \"sof-client.h\"\n\n#define MAX_IPC_FLOOD_DURATION_MS\t1000\n#define MAX_IPC_FLOOD_COUNT\t\t10000\n#define IPC_FLOOD_TEST_RESULT_LEN\t512\n#define SOF_IPC_CLIENT_SUSPEND_DELAY_MS\t3000\n\n#define DEBUGFS_IPC_FLOOD_COUNT\t\t\"ipc_flood_count\"\n#define DEBUGFS_IPC_FLOOD_DURATION\t\"ipc_flood_duration_ms\"\n\nstruct sof_ipc_flood_priv {\n\tstruct dentry *dfs_root;\n\tstruct dentry *dfs_link[2];\n\tchar *buf;\n};\n\nstatic int sof_ipc_flood_dfs_open(struct inode *inode, struct file *file)\n{\n\tstruct sof_client_dev *cdev = inode->i_private;\n\tint ret;\n\n\tif (sof_client_get_fw_state(cdev) == SOF_FW_CRASHED)\n\t\treturn -ENODEV;\n\n\tret = debugfs_file_get(file->f_path.dentry);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = simple_open(inode, file);\n\tif (ret)\n\t\tdebugfs_file_put(file->f_path.dentry);\n\n\treturn ret;\n}\n\n \nstatic int sof_debug_ipc_flood_test(struct sof_client_dev *cdev,\n\t\t\t\t    bool flood_duration_test,\n\t\t\t\t    unsigned long ipc_duration_ms,\n\t\t\t\t    unsigned long ipc_count)\n{\n\tstruct sof_ipc_flood_priv *priv = cdev->data;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tstruct sof_ipc_cmd_hdr hdr;\n\tu64 min_response_time = U64_MAX;\n\tktime_t start, end, test_end;\n\tu64 avg_response_time = 0;\n\tu64 max_response_time = 0;\n\tu64 ipc_response_time;\n\tint i = 0;\n\tint ret;\n\n\t \n\thdr.cmd = SOF_IPC_GLB_TEST_MSG | SOF_IPC_TEST_IPC_FLOOD;\n\thdr.size = sizeof(hdr);\n\n\t \n\tif (flood_duration_test)\n\t\ttest_end = ktime_get_ns() + ipc_duration_ms * NSEC_PER_MSEC;\n\n\t \n\twhile (1) {\n\t\tstart = ktime_get();\n\t\tret = sof_client_ipc_tx_message_no_reply(cdev, &hdr);\n\t\tend = ktime_get();\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tipc_response_time = ktime_to_ns(ktime_sub(end, start));\n\t\tmin_response_time = min(min_response_time, ipc_response_time);\n\t\tmax_response_time = max(max_response_time, ipc_response_time);\n\n\t\t \n\t\tavg_response_time += ipc_response_time;\n\t\ti++;\n\n\t\t \n\t\tif (flood_duration_test) {\n\t\t\tif (ktime_to_ns(end) >= test_end)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (i == ipc_count)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tdev_err(dev, \"ipc flood test failed at %d iterations\\n\", i);\n\n\t \n\tif (!i)\n\t\treturn ret;\n\n\t \n\tdo_div(avg_response_time, i);\n\n\t \n\tmemset(priv->buf, 0, IPC_FLOOD_TEST_RESULT_LEN);\n\n\tif (!ipc_count) {\n\t\tdev_dbg(dev, \"IPC Flood test duration: %lums\\n\", ipc_duration_ms);\n\t\tsnprintf(priv->buf, IPC_FLOOD_TEST_RESULT_LEN,\n\t\t\t \"IPC Flood test duration: %lums\\n\", ipc_duration_ms);\n\t}\n\n\tdev_dbg(dev, \"IPC Flood count: %d, Avg response time: %lluns\\n\",\n\t\ti, avg_response_time);\n\tdev_dbg(dev, \"Max response time: %lluns\\n\", max_response_time);\n\tdev_dbg(dev, \"Min response time: %lluns\\n\", min_response_time);\n\n\t \n\tsnprintf(priv->buf + strlen(priv->buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(priv->buf),\n\t\t \"IPC Flood count: %d\\nAvg response time: %lluns\\n\",\n\t\t i, avg_response_time);\n\n\tsnprintf(priv->buf + strlen(priv->buf),\n\t\t IPC_FLOOD_TEST_RESULT_LEN - strlen(priv->buf),\n\t\t \"Max response time: %lluns\\nMin response time: %lluns\\n\",\n\t\t max_response_time, min_response_time);\n\n\treturn ret;\n}\n\n \nstatic ssize_t sof_ipc_flood_dfs_write(struct file *file, const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tunsigned long ipc_duration_ms = 0;\n\tbool flood_duration_test = false;\n\tunsigned long ipc_count = 0;\n\tstruct dentry *dentry;\n\tint err;\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count + 1, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\n\t \n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, DEBUGFS_IPC_FLOOD_COUNT) &&\n\t    strcmp(dentry->d_name.name, DEBUGFS_IPC_FLOOD_DURATION)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, DEBUGFS_IPC_FLOOD_DURATION))\n\t\tflood_duration_test = true;\n\n\t \n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (flood_duration_test) {\n\t\tif (!ipc_duration_ms) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS)\n\t\t\tipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS;\n\t} else {\n\t\tif (!ipc_count) {\n\t\t\tret = size;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (ipc_count > MAX_IPC_FLOOD_COUNT)\n\t\t\tipc_count = MAX_IPC_FLOOD_COUNT;\n\t}\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to resume %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = sof_debug_ipc_flood_test(cdev, flood_duration_test,\n\t\t\t\t       ipc_duration_ms, ipc_count);\n\n\tpm_runtime_mark_last_busy(dev);\n\terr = pm_runtime_put_autosuspend(dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to idle %d\\n\", err);\n\n\t \n\tif (ret >= 0)\n\t\tret = size;\nout:\n\tkfree(string);\n\treturn ret;\n}\n\n \nstatic ssize_t sof_ipc_flood_dfs_read(struct file *file, char __user *buffer,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_ipc_flood_priv *priv = cdev->data;\n\tsize_t size_ret;\n\n\tstruct dentry *dentry;\n\n\tdentry = file->f_path.dentry;\n\tif (!strcmp(dentry->d_name.name, DEBUGFS_IPC_FLOOD_COUNT) ||\n\t    !strcmp(dentry->d_name.name, DEBUGFS_IPC_FLOOD_DURATION)) {\n\t\tif (*ppos)\n\t\t\treturn 0;\n\n\t\tcount = min_t(size_t, count, strlen(priv->buf));\n\t\tsize_ret = copy_to_user(buffer, priv->buf, count);\n\t\tif (size_ret)\n\t\t\treturn -EFAULT;\n\n\t\t*ppos += count;\n\t\treturn count;\n\t}\n\treturn count;\n}\n\nstatic int sof_ipc_flood_dfs_release(struct inode *inode, struct file *file)\n{\n\tdebugfs_file_put(file->f_path.dentry);\n\n\treturn 0;\n}\n\nstatic const struct file_operations sof_ipc_flood_fops = {\n\t.open = sof_ipc_flood_dfs_open,\n\t.read = sof_ipc_flood_dfs_read,\n\t.llseek = default_llseek,\n\t.write = sof_ipc_flood_dfs_write,\n\t.release = sof_ipc_flood_dfs_release,\n\n\t.owner = THIS_MODULE,\n};\n\n \nstatic int sof_ipc_flood_probe(struct auxiliary_device *auxdev,\n\t\t\t       const struct auxiliary_device_id *id)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct dentry *debugfs_root = sof_client_get_debugfs_root(cdev);\n\tstruct device *dev = &auxdev->dev;\n\tstruct sof_ipc_flood_priv *priv;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->buf = devm_kmalloc(dev, IPC_FLOOD_TEST_RESULT_LEN, GFP_KERNEL);\n\tif (!priv->buf)\n\t\treturn -ENOMEM;\n\n\tcdev->data = priv;\n\n\t \n\tpriv->dfs_root = debugfs_create_dir(dev_name(dev), debugfs_root);\n\tif (!IS_ERR_OR_NULL(priv->dfs_root)) {\n\t\t \n\t\tdebugfs_create_file(DEBUGFS_IPC_FLOOD_COUNT, 0644, priv->dfs_root,\n\t\t\t\t    cdev, &sof_ipc_flood_fops);\n\n\t\t \n\t\tdebugfs_create_file(DEBUGFS_IPC_FLOOD_DURATION, 0644,\n\t\t\t\t    priv->dfs_root, cdev, &sof_ipc_flood_fops);\n\n\t\tif (auxdev->id == 0) {\n\t\t\t \n\t\t\tchar target[100];\n\n\t\t\tsnprintf(target, 100, \"%s/\" DEBUGFS_IPC_FLOOD_COUNT,\n\t\t\t\t dev_name(dev));\n\t\t\tpriv->dfs_link[0] =\n\t\t\t\tdebugfs_create_symlink(DEBUGFS_IPC_FLOOD_COUNT,\n\t\t\t\t\t\t       debugfs_root, target);\n\n\t\t\tsnprintf(target, 100, \"%s/\" DEBUGFS_IPC_FLOOD_DURATION,\n\t\t\t\t dev_name(dev));\n\t\t\tpriv->dfs_link[1] =\n\t\t\t\tdebugfs_create_symlink(DEBUGFS_IPC_FLOOD_DURATION,\n\t\t\t\t\t\t       debugfs_root, target);\n\t\t}\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SOF_IPC_CLIENT_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_idle(dev);\n\n\treturn 0;\n}\n\nstatic void sof_ipc_flood_remove(struct auxiliary_device *auxdev)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct sof_ipc_flood_priv *priv = cdev->data;\n\n\tpm_runtime_disable(&auxdev->dev);\n\n\tif (auxdev->id == 0) {\n\t\tdebugfs_remove(priv->dfs_link[0]);\n\t\tdebugfs_remove(priv->dfs_link[1]);\n\t}\n\n\tdebugfs_remove_recursive(priv->dfs_root);\n}\n\nstatic const struct auxiliary_device_id sof_ipc_flood_client_id_table[] = {\n\t{ .name = \"snd_sof.ipc_flood\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, sof_ipc_flood_client_id_table);\n\n \nstatic struct auxiliary_driver sof_ipc_flood_client_drv = {\n\t.probe = sof_ipc_flood_probe,\n\t.remove = sof_ipc_flood_remove,\n\n\t.id_table = sof_ipc_flood_client_id_table,\n};\n\nmodule_auxiliary_driver(sof_ipc_flood_client_drv);\n\nMODULE_DESCRIPTION(\"SOF IPC Flood Test Client Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_CLIENT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}