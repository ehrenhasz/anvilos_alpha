{
  "module_name": "compress.c",
  "hash_id": "af366b1284bba3be800bde1f760d7be6739303095bdd7f8932d25a3a2ba14c9b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/compress.c",
  "human_readable_source": "\n\n\n\n\n\n#include <sound/soc.h>\n#include <sound/sof.h>\n#include <sound/compress_driver.h>\n#include \"sof-audio.h\"\n#include \"sof-priv.h\"\n#include \"sof-utils.h\"\n#include \"ops.h\"\n\nstatic void sof_set_transferred_bytes(struct sof_compr_stream *sstream,\n\t\t\t\t      u64 host_pos, u64 buffer_size)\n{\n\tu64 prev_pos;\n\tunsigned int copied;\n\n\tdiv64_u64_rem(sstream->copied_total, buffer_size, &prev_pos);\n\n\tif (host_pos < prev_pos)\n\t\tcopied = (buffer_size - prev_pos) + host_pos;\n\telse\n\t\tcopied = host_pos - prev_pos;\n\n\tsstream->copied_total += copied;\n}\n\nstatic void snd_sof_compr_fragment_elapsed_work(struct work_struct *work)\n{\n\tstruct snd_sof_pcm_stream *sps =\n\t\tcontainer_of(work, struct snd_sof_pcm_stream,\n\t\t\t     period_elapsed_work);\n\n\tsnd_compr_fragment_elapsed(sps->cstream);\n}\n\nvoid snd_sof_compr_init_elapsed_work(struct work_struct *work)\n{\n\tINIT_WORK(work, snd_sof_compr_fragment_elapsed_work);\n}\n\n \nvoid snd_sof_compr_fragment_elapsed(struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_compr_runtime *crtd;\n\tstruct snd_soc_component *component;\n\tstruct sof_compr_stream *sstream;\n\tstruct snd_sof_pcm *spcm;\n\n\tif (!cstream)\n\t\treturn;\n\n\trtd = cstream->private_data;\n\tcrtd = cstream->runtime;\n\tsstream = crtd->private_data;\n\tcomponent = snd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm) {\n\t\tdev_err(component->dev,\n\t\t\t\"fragment elapsed called for unknown stream!\\n\");\n\t\treturn;\n\t}\n\n\tsof_set_transferred_bytes(sstream, spcm->stream[cstream->direction].posn.host_posn,\n\t\t\t\t  crtd->buffer_size);\n\n\t \n\tschedule_work(&spcm->stream[cstream->direction].period_elapsed_work);\n}\n\nstatic int create_page_table(struct snd_soc_component *component,\n\t\t\t     struct snd_compr_stream *cstream,\n\t\t\t     unsigned char *dma_area, size_t size)\n{\n\tstruct snd_dma_buffer *dmab = cstream->runtime->dma_buffer_p;\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tint dir = cstream->direction;\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\treturn snd_sof_create_page_table(component->dev, dmab,\n\t\t\t\t\t spcm->stream[dir].page_table.area, size);\n}\n\nstatic int sof_compr_open(struct snd_soc_component *component,\n\t\t\t  struct snd_compr_stream *cstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *crtd = cstream->runtime;\n\tstruct sof_compr_stream *sstream;\n\tstruct snd_sof_pcm *spcm;\n\tint dir;\n\n\tsstream = kzalloc(sizeof(*sstream), GFP_KERNEL);\n\tif (!sstream)\n\t\treturn -ENOMEM;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm) {\n\t\tkfree(sstream);\n\t\treturn -EINVAL;\n\t}\n\n\tdir = cstream->direction;\n\n\tif (spcm->stream[dir].cstream) {\n\t\tkfree(sstream);\n\t\treturn -EBUSY;\n\t}\n\n\tspcm->stream[dir].cstream = cstream;\n\tspcm->stream[dir].posn.host_posn = 0;\n\tspcm->stream[dir].posn.dai_posn = 0;\n\tspcm->prepared[dir] = false;\n\n\tcrtd->private_data = sstream;\n\n\treturn 0;\n}\n\nstatic int sof_compr_free(struct snd_soc_component *component,\n\t\t\t  struct snd_compr_stream *cstream)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct sof_compr_stream *sstream = cstream->runtime->private_data;\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct sof_ipc_stream stream;\n\tstruct snd_sof_pcm *spcm;\n\tint ret = 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_FREE;\n\tstream.comp_id = spcm->stream[cstream->direction].comp_id;\n\n\tif (spcm->prepared[cstream->direction]) {\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &stream, sizeof(stream));\n\t\tif (!ret)\n\t\t\tspcm->prepared[cstream->direction] = false;\n\t}\n\n\tcancel_work_sync(&spcm->stream[cstream->direction].period_elapsed_work);\n\tspcm->stream[cstream->direction].cstream = NULL;\n\tkfree(sstream);\n\n\treturn ret;\n}\n\nstatic int sof_compr_set_params(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *cstream, struct snd_compr_params *params)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct snd_compr_runtime *crtd = cstream->runtime;\n\tstruct sof_ipc_pcm_params_reply ipc_params_reply;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tstruct sof_compr_stream *sstream;\n\tstruct sof_ipc_pcm_params *pcm;\n\tstruct snd_sof_pcm *spcm;\n\tsize_t ext_data_size;\n\tint ret;\n\n\tif (v->abi_version < SOF_ABI_VER(3, 22, 0)) {\n\t\tdev_err(component->dev,\n\t\t\t\"Compress params not supported with FW ABI version %d:%d:%d\\n\",\n\t\t\tSOF_ABI_VERSION_MAJOR(v->abi_version),\n\t\t\tSOF_ABI_VERSION_MINOR(v->abi_version),\n\t\t\tSOF_ABI_VERSION_PATCH(v->abi_version));\n\t\treturn -EINVAL;\n\t}\n\n\tsstream = crtd->private_data;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\text_data_size = sizeof(params->codec);\n\n\tif (sizeof(*pcm) + ext_data_size > sdev->ipc->max_payload_size)\n\t\treturn -EINVAL;\n\n\tpcm = kzalloc(sizeof(*pcm) + ext_data_size, GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\n\tcstream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV_SG;\n\tcstream->dma_buffer.dev.dev = sdev->dev;\n\tret = snd_compr_malloc_pages(cstream, crtd->buffer_size);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = create_page_table(component, cstream, crtd->dma_area, crtd->dma_bytes);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpcm->params.buffer.pages = PFN_UP(crtd->dma_bytes);\n\tpcm->hdr.size = sizeof(*pcm) + ext_data_size;\n\tpcm->hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;\n\n\tpcm->comp_id = spcm->stream[cstream->direction].comp_id;\n\tpcm->params.hdr.size = sizeof(pcm->params) + ext_data_size;\n\tpcm->params.buffer.phy_addr = spcm->stream[cstream->direction].page_table.addr;\n\tpcm->params.buffer.size = crtd->dma_bytes;\n\tpcm->params.direction = cstream->direction;\n\tpcm->params.channels = params->codec.ch_out;\n\tpcm->params.rate = params->codec.sample_rate;\n\tpcm->params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;\n\tpcm->params.frame_fmt = SOF_IPC_FRAME_S32_LE;\n\tpcm->params.sample_container_bytes =\n\t\tsnd_pcm_format_physical_width(SNDRV_PCM_FORMAT_S32) >> 3;\n\tpcm->params.host_period_bytes = params->buffer.fragment_size;\n\tpcm->params.ext_data_length = ext_data_size;\n\n\tmemcpy((u8 *)pcm->params.ext_data, &params->codec, ext_data_size);\n\n\tret = sof_ipc_tx_message(sdev->ipc, pcm, sizeof(*pcm) + ext_data_size,\n\t\t\t\t &ipc_params_reply, sizeof(ipc_params_reply));\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"error ipc failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = snd_sof_set_stream_data_offset(sdev, &spcm->stream[cstream->direction],\n\t\t\t\t\t     ipc_params_reply.posn_offset);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Invalid stream data offset for Compr %d\\n\",\n\t\t\tspcm->pcm.pcm_id);\n\t\tgoto out;\n\t}\n\n\tsstream->sampling_rate = params->codec.sample_rate;\n\tsstream->channels = params->codec.ch_out;\n\tsstream->sample_container_bytes = pcm->params.sample_container_bytes;\n\n\tspcm->prepared[cstream->direction] = true;\n\nout:\n\tkfree(pcm);\n\n\treturn ret;\n}\n\nstatic int sof_compr_get_params(struct snd_soc_component *component,\n\t\t\t\tstruct snd_compr_stream *cstream, struct snd_codec *params)\n{\n\t \n\treturn 0;\n}\n\nstatic int sof_compr_trigger(struct snd_soc_component *component,\n\t\t\t     struct snd_compr_stream *cstream, int cmd)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct sof_ipc_stream stream;\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG;\n\tstream.comp_id = spcm->stream[cstream->direction].comp_id;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_START;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_STOP;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_PAUSE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_RELEASE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"error: unhandled trigger cmd %d\\n\", cmd);\n\t\tbreak;\n\t}\n\n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &stream, sizeof(stream));\n}\n\nstatic int sof_compr_copy_playback(struct snd_compr_runtime *rtd,\n\t\t\t\t   char __user *buf, size_t count)\n{\n\tvoid *ptr;\n\tunsigned int offset, n;\n\tint ret;\n\n\tdiv_u64_rem(rtd->total_bytes_available, rtd->buffer_size, &offset);\n\tptr = rtd->dma_area + offset;\n\tn = rtd->buffer_size - offset;\n\n\tif (count < n) {\n\t\tret = copy_from_user(ptr, buf, count);\n\t} else {\n\t\tret = copy_from_user(ptr, buf, n);\n\t\tret += copy_from_user(rtd->dma_area, buf + n, count - n);\n\t}\n\n\treturn count - ret;\n}\n\nstatic int sof_compr_copy_capture(struct snd_compr_runtime *rtd,\n\t\t\t\t  char __user *buf, size_t count)\n{\n\tvoid *ptr;\n\tunsigned int offset, n;\n\tint ret;\n\n\tdiv_u64_rem(rtd->total_bytes_transferred, rtd->buffer_size, &offset);\n\tptr = rtd->dma_area + offset;\n\tn = rtd->buffer_size - offset;\n\n\tif (count < n) {\n\t\tret = copy_to_user(buf, ptr, count);\n\t} else {\n\t\tret = copy_to_user(buf, ptr, n);\n\t\tret += copy_to_user(buf + n, rtd->dma_area, count - n);\n\t}\n\n\treturn count - ret;\n}\n\nstatic int sof_compr_copy(struct snd_soc_component *component,\n\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t  char __user *buf, size_t count)\n{\n\tstruct snd_compr_runtime *rtd = cstream->runtime;\n\n\tif (count > rtd->buffer_size)\n\t\tcount = rtd->buffer_size;\n\n\tif (cstream->direction == SND_COMPRESS_PLAYBACK)\n\t\treturn sof_compr_copy_playback(rtd, buf, count);\n\telse\n\t\treturn sof_compr_copy_capture(rtd, buf, count);\n}\n\nstatic int sof_compr_pointer(struct snd_soc_component *component,\n\t\t\t     struct snd_compr_stream *cstream,\n\t\t\t     struct snd_compr_tstamp *tstamp)\n{\n\tstruct snd_sof_pcm *spcm;\n\tstruct snd_soc_pcm_runtime *rtd = cstream->private_data;\n\tstruct sof_compr_stream *sstream = cstream->runtime->private_data;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\ttstamp->sampling_rate = sstream->sampling_rate;\n\ttstamp->copied_total = sstream->copied_total;\n\ttstamp->pcm_io_frames = div_u64(spcm->stream[cstream->direction].posn.dai_posn,\n\t\t\t\t\tsstream->channels * sstream->sample_container_bytes);\n\n\treturn 0;\n}\n\nstruct snd_compress_ops sof_compressed_ops = {\n\t.open\t\t= sof_compr_open,\n\t.free\t\t= sof_compr_free,\n\t.set_params\t= sof_compr_set_params,\n\t.get_params\t= sof_compr_get_params,\n\t.trigger\t= sof_compr_trigger,\n\t.pointer\t= sof_compr_pointer,\n\t.copy\t\t= sof_compr_copy,\n};\nEXPORT_SYMBOL(sof_compressed_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}