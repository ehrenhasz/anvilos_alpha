{
  "module_name": "sof-acpi-dev.c",
  "hash_id": "a0bcaf84273190af3f9abce5eef2d13f1d2e33f04b9d55f01f872a5ae1bcea44",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-acpi-dev.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/sof.h>\n#include \"../intel/common/soc-intel-quirks.h\"\n#include \"ops.h\"\n#include \"sof-acpi-dev.h\"\n\n \n#include \"intel/shim.h\"\n\nstatic char *fw_path;\nmodule_param(fw_path, charp, 0444);\nMODULE_PARM_DESC(fw_path, \"alternate path for SOF firmware.\");\n\nstatic char *tplg_path;\nmodule_param(tplg_path, charp, 0444);\nMODULE_PARM_DESC(tplg_path, \"alternate path for SOF topology.\");\n\nstatic int sof_acpi_debug;\nmodule_param_named(sof_acpi_debug, sof_acpi_debug, int, 0444);\nMODULE_PARM_DESC(sof_acpi_debug, \"SOF ACPI debug options (0x0 all off)\");\n\n#define SOF_ACPI_DISABLE_PM_RUNTIME BIT(0)\n\nconst struct dev_pm_ops sof_acpi_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_sof_suspend, snd_sof_resume)\n\tSET_RUNTIME_PM_OPS(snd_sof_runtime_suspend, snd_sof_runtime_resume,\n\t\t\t   snd_sof_runtime_idle)\n};\nEXPORT_SYMBOL_NS(sof_acpi_pm, SND_SOC_SOF_ACPI_DEV);\n\nstatic void sof_acpi_probe_complete(struct device *dev)\n{\n\tdev_dbg(dev, \"Completing SOF ACPI probe\");\n\n\tif (sof_acpi_debug & SOF_ACPI_DISABLE_PM_RUNTIME)\n\t\treturn;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SND_SOF_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n}\n\nint sof_acpi_probe(struct platform_device *pdev, const struct sof_dev_desc *desc)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_sof_pdata *sof_pdata;\n\n\tdev_dbg(dev, \"ACPI DSP detected\");\n\n\tsof_pdata = devm_kzalloc(dev, sizeof(*sof_pdata), GFP_KERNEL);\n\tif (!sof_pdata)\n\t\treturn -ENOMEM;\n\n\tif (!desc->ops) {\n\t\tdev_err(dev, \"error: no matching ACPI descriptor ops\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsof_pdata->desc = desc;\n\tsof_pdata->dev = &pdev->dev;\n\tsof_pdata->fw_filename = desc->default_fw_filename[SOF_IPC];\n\n\t \n\tif (fw_path)\n\t\tsof_pdata->fw_filename_prefix = fw_path;\n\telse\n\t\tsof_pdata->fw_filename_prefix =\n\t\t\tsof_pdata->desc->default_fw_path[SOF_IPC];\n\n\tif (tplg_path)\n\t\tsof_pdata->tplg_filename_prefix = tplg_path;\n\telse\n\t\tsof_pdata->tplg_filename_prefix =\n\t\t\tsof_pdata->desc->default_tplg_path[SOF_IPC];\n\n\t \n\tsof_pdata->sof_probe_complete = sof_acpi_probe_complete;\n\n\t \n\treturn snd_sof_device_probe(dev, sof_pdata);\n}\nEXPORT_SYMBOL_NS(sof_acpi_probe, SND_SOC_SOF_ACPI_DEV);\n\nint sof_acpi_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tif (!(sof_acpi_debug & SOF_ACPI_DISABLE_PM_RUNTIME))\n\t\tpm_runtime_disable(dev);\n\n\t \n\tsnd_sof_device_remove(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(sof_acpi_remove, SND_SOC_SOF_ACPI_DEV);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}