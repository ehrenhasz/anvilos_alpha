{
  "module_name": "core.c",
  "hash_id": "45a3dab4bfc421dabfc2269f88a18a5aa8346e5e46bae4e7043cae5a78fbf2dc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <sound/soc.h>\n#include <sound/sof.h>\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/sof.h>\n\n \nstatic int sof_core_debug =  IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_FIRMWARE_TRACE);\nmodule_param_named(sof_debug, sof_core_debug, int, 0444);\nMODULE_PARM_DESC(sof_debug, \"SOF core debug options (0x0 all off)\");\n\n \n#define TIMEOUT_DEFAULT_IPC_MS  500\n#define TIMEOUT_DEFAULT_BOOT_MS 2000\n\n \nbool sof_debug_check_flag(int mask)\n{\n\tif ((sof_core_debug & mask) == mask)\n\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL(sof_debug_check_flag);\n\n \n\nstruct sof_panic_msg {\n\tu32 id;\n\tconst char *msg;\n};\n\n \nstatic const struct sof_panic_msg panic_msg[] = {\n\t{SOF_IPC_PANIC_MEM, \"out of memory\"},\n\t{SOF_IPC_PANIC_WORK, \"work subsystem init failed\"},\n\t{SOF_IPC_PANIC_IPC, \"IPC subsystem init failed\"},\n\t{SOF_IPC_PANIC_ARCH, \"arch init failed\"},\n\t{SOF_IPC_PANIC_PLATFORM, \"platform init failed\"},\n\t{SOF_IPC_PANIC_TASK, \"scheduler init failed\"},\n\t{SOF_IPC_PANIC_EXCEPTION, \"runtime exception\"},\n\t{SOF_IPC_PANIC_DEADLOCK, \"deadlock\"},\n\t{SOF_IPC_PANIC_STACK, \"stack overflow\"},\n\t{SOF_IPC_PANIC_IDLE, \"can't enter idle\"},\n\t{SOF_IPC_PANIC_WFI, \"invalid wait state\"},\n\t{SOF_IPC_PANIC_ASSERT, \"assertion failed\"},\n};\n\n \nvoid sof_print_oops_and_stack(struct snd_sof_dev *sdev, const char *level,\n\t\t\t      u32 panic_code, u32 tracep_code, void *oops,\n\t\t\t      struct sof_ipc_panic_info *panic_info,\n\t\t\t      void *stack, size_t stack_words)\n{\n\tu32 code;\n\tint i;\n\n\t \n\tif ((panic_code & SOF_IPC_PANIC_MAGIC_MASK) != SOF_IPC_PANIC_MAGIC) {\n\t\tdev_printk(level, sdev->dev, \"unexpected fault %#010x trace %#010x\\n\",\n\t\t\t   panic_code, tracep_code);\n\t\treturn;  \n\t}\n\n\tcode = panic_code & (SOF_IPC_PANIC_MAGIC_MASK | SOF_IPC_PANIC_CODE_MASK);\n\n\tfor (i = 0; i < ARRAY_SIZE(panic_msg); i++) {\n\t\tif (panic_msg[i].id == code) {\n\t\t\tdev_printk(level, sdev->dev, \"reason: %s (%#x)\\n\",\n\t\t\t\t   panic_msg[i].msg, code & SOF_IPC_PANIC_CODE_MASK);\n\t\t\tdev_printk(level, sdev->dev, \"trace point: %#010x\\n\", tracep_code);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tdev_printk(level, sdev->dev, \"unknown panic code: %#x\\n\",\n\t\t   code & SOF_IPC_PANIC_CODE_MASK);\n\tdev_printk(level, sdev->dev, \"trace point: %#010x\\n\", tracep_code);\n\nout:\n\tdev_printk(level, sdev->dev, \"panic at %s:%d\\n\", panic_info->filename,\n\t\t   panic_info->linenum);\n\tsof_oops(sdev, level, oops);\n\tsof_stack(sdev, level, oops, stack, stack_words);\n}\nEXPORT_SYMBOL(sof_print_oops_and_stack);\n\n \nvoid sof_set_fw_state(struct snd_sof_dev *sdev, enum sof_fw_state new_state)\n{\n\tif (sdev->fw_state == new_state)\n\t\treturn;\n\n\tdev_dbg(sdev->dev, \"fw_state change: %d -> %d\\n\", sdev->fw_state, new_state);\n\tsdev->fw_state = new_state;\n\n\tswitch (new_state) {\n\tcase SOF_FW_BOOT_NOT_STARTED:\n\tcase SOF_FW_BOOT_COMPLETE:\n\tcase SOF_FW_CRASHED:\n\t\tsof_client_fw_state_dispatcher(sdev);\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(sof_set_fw_state);\n\n \n\nstatic int sof_probe_continue(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tint ret;\n\n\t \n\tret = snd_sof_probe(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to probe DSP %d\\n\", ret);\n\t\tgoto probe_err;\n\t}\n\n\tsof_set_fw_state(sdev, SOF_FW_BOOT_PREPARE);\n\n\t \n\tret = sof_machine_check(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to get machine info %d\\n\",\n\t\t\tret);\n\t\tgoto dsp_err;\n\t}\n\n\t \n\tsnd_sof_new_platform_drv(sdev);\n\n\tif (sdev->dspless_mode_selected) {\n\t\tsof_set_fw_state(sdev, SOF_DSPLESS_MODE);\n\t\tgoto skip_dsp_init;\n\t}\n\n\t \n\tret = snd_sof_dbg_init(sdev);\n\tif (ret < 0) {\n\t\t \n\t\tdev_err(sdev->dev, \"error: failed to init DSP trace/debug %d\\n\",\n\t\t\tret);\n\t\tgoto dbg_err;\n\t}\n\n\t \n\tsdev->ipc = snd_sof_ipc_init(sdev);\n\tif (!sdev->ipc) {\n\t\tret = -ENOMEM;\n\t\tdev_err(sdev->dev, \"error: failed to init DSP IPC %d\\n\", ret);\n\t\tgoto ipc_err;\n\t}\n\n\t \n\tret = snd_sof_load_firmware(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to load DSP firmware %d\\n\",\n\t\t\tret);\n\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_FAILED);\n\t\tgoto fw_load_err;\n\t}\n\n\tsof_set_fw_state(sdev, SOF_FW_BOOT_IN_PROGRESS);\n\n\t \n\tret = snd_sof_run_firmware(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to boot DSP firmware %d\\n\",\n\t\t\tret);\n\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_FAILED);\n\t\tgoto fw_run_err;\n\t}\n\n\tif (sof_debug_check_flag(SOF_DBG_ENABLE_TRACE)) {\n\t\tsdev->fw_trace_is_supported = true;\n\n\t\t \n\t\tret = sof_fw_trace_init(sdev);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_warn(sdev->dev, \"failed to initialize firmware tracing %d\\n\",\n\t\t\t\t ret);\n\t\t}\n\t} else {\n\t\tdev_dbg(sdev->dev, \"SOF firmware trace disabled\\n\");\n\t}\n\nskip_dsp_init:\n\t \n\tsdev->first_boot = false;\n\n\t \n\tret = devm_snd_soc_register_component(sdev->dev, &sdev->plat_drv,\n\t\t\t\t\t      sof_ops(sdev)->drv,\n\t\t\t\t\t      sof_ops(sdev)->num_drv);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to register DSP DAI driver %d\\n\", ret);\n\t\tgoto fw_trace_err;\n\t}\n\n\tret = snd_sof_machine_register(sdev, plat_data);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to register machine driver %d\\n\", ret);\n\t\tgoto fw_trace_err;\n\t}\n\n\tret = sof_register_clients(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to register clients %d\\n\", ret);\n\t\tgoto sof_machine_err;\n\t}\n\n\t \n\tif (!sof_ops(sdev)->runtime_suspend || !sof_ops(sdev)->runtime_resume)\n\t\tpm_runtime_get_noresume(sdev->dev);\n\n\tif (plat_data->sof_probe_complete)\n\t\tplat_data->sof_probe_complete(sdev->dev);\n\n\tsdev->probe_completed = true;\n\n\treturn 0;\n\nsof_machine_err:\n\tsnd_sof_machine_unregister(sdev, plat_data);\nfw_trace_err:\n\tsof_fw_trace_free(sdev);\nfw_run_err:\n\tsnd_sof_fw_unload(sdev);\nfw_load_err:\n\tsnd_sof_ipc_free(sdev);\nipc_err:\ndbg_err:\n\tsnd_sof_free_debug(sdev);\ndsp_err:\n\tsnd_sof_remove(sdev);\nprobe_err:\n\tsof_ops_free(sdev);\n\n\t \n\tsof_set_fw_state(sdev, SOF_FW_BOOT_NOT_STARTED);\n\tsdev->first_boot = true;\n\n\treturn ret;\n}\n\nstatic void sof_probe_work(struct work_struct *work)\n{\n\tstruct snd_sof_dev *sdev =\n\t\tcontainer_of(work, struct snd_sof_dev, probe_work);\n\tint ret;\n\n\tret = sof_probe_continue(sdev);\n\tif (ret < 0) {\n\t\t \n\t\tdev_err(sdev->dev, \"error: %s failed err: %d\\n\", __func__, ret);\n\t}\n}\n\nint snd_sof_device_probe(struct device *dev, struct snd_sof_pdata *plat_data)\n{\n\tstruct snd_sof_dev *sdev;\n\tint ret;\n\n\tsdev = devm_kzalloc(dev, sizeof(*sdev), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\t \n\tsdev->dev = dev;\n\n\t \n\tsdev->dsp_power_state.state = SOF_DSP_PM_D0;\n\n\tsdev->pdata = plat_data;\n\tsdev->first_boot = true;\n\tdev_set_drvdata(dev, sdev);\n\n\tif (sof_core_debug)\n\t\tdev_info(dev, \"sof_debug value: %#x\\n\", sof_core_debug);\n\n\tif (sof_debug_check_flag(SOF_DBG_DSPLESS_MODE)) {\n\t\tif (plat_data->desc->dspless_mode_supported) {\n\t\t\tdev_info(dev, \"Switching to DSPless mode\\n\");\n\t\t\tsdev->dspless_mode_selected = true;\n\t\t} else {\n\t\t\tdev_info(dev, \"DSPless mode is not supported by the platform\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!(BIT(plat_data->ipc_type) & plat_data->desc->ipc_supported_mask)) {\n\t\tdev_err(dev, \"ipc_type %d is not supported on this platform, mask is %#x\\n\",\n\t\t\tplat_data->ipc_type, plat_data->desc->ipc_supported_mask);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = sof_ops_init(sdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!sof_ops(sdev) || !sof_ops(sdev)->probe) {\n\t\tsof_ops_free(sdev);\n\t\tdev_err(dev, \"missing mandatory ops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!sdev->dspless_mode_selected &&\n\t    (!sof_ops(sdev)->run || !sof_ops(sdev)->block_read ||\n\t     !sof_ops(sdev)->block_write || !sof_ops(sdev)->send_msg ||\n\t     !sof_ops(sdev)->load_firmware || !sof_ops(sdev)->ipc_msg_data)) {\n\t\tsof_ops_free(sdev);\n\t\tdev_err(dev, \"missing mandatory DSP ops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tINIT_LIST_HEAD(&sdev->pcm_list);\n\tINIT_LIST_HEAD(&sdev->kcontrol_list);\n\tINIT_LIST_HEAD(&sdev->widget_list);\n\tINIT_LIST_HEAD(&sdev->pipeline_list);\n\tINIT_LIST_HEAD(&sdev->dai_list);\n\tINIT_LIST_HEAD(&sdev->dai_link_list);\n\tINIT_LIST_HEAD(&sdev->route_list);\n\tINIT_LIST_HEAD(&sdev->ipc_client_list);\n\tINIT_LIST_HEAD(&sdev->ipc_rx_handler_list);\n\tINIT_LIST_HEAD(&sdev->fw_state_handler_list);\n\tspin_lock_init(&sdev->ipc_lock);\n\tspin_lock_init(&sdev->hw_lock);\n\tmutex_init(&sdev->power_state_access);\n\tmutex_init(&sdev->ipc_client_mutex);\n\tmutex_init(&sdev->client_event_handler_mutex);\n\n\t \n\tif (plat_data->desc->ipc_timeout == 0)\n\t\tsdev->ipc_timeout = TIMEOUT_DEFAULT_IPC_MS;\n\telse\n\t\tsdev->ipc_timeout = plat_data->desc->ipc_timeout;\n\tif (plat_data->desc->boot_timeout == 0)\n\t\tsdev->boot_timeout = TIMEOUT_DEFAULT_BOOT_MS;\n\telse\n\t\tsdev->boot_timeout = plat_data->desc->boot_timeout;\n\n\tsof_set_fw_state(sdev, SOF_FW_BOOT_NOT_STARTED);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_PROBE_WORK_QUEUE)) {\n\t\tINIT_WORK(&sdev->probe_work, sof_probe_work);\n\t\tschedule_work(&sdev->probe_work);\n\t\treturn 0;\n\t}\n\n\treturn sof_probe_continue(sdev);\n}\nEXPORT_SYMBOL(snd_sof_device_probe);\n\nbool snd_sof_device_probe_completed(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\n\treturn sdev->probe_completed;\n}\nEXPORT_SYMBOL(snd_sof_device_probe_completed);\n\nint snd_sof_device_remove(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tint ret;\n\tbool aborted = false;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_PROBE_WORK_QUEUE))\n\t\taborted = cancel_work_sync(&sdev->probe_work);\n\n\t \n\tsof_unregister_clients(sdev);\n\n\t \n\tsnd_sof_machine_unregister(sdev, pdata);\n\n\tif (sdev->fw_state > SOF_FW_BOOT_NOT_STARTED) {\n\t\tsof_fw_trace_free(sdev);\n\t\tret = snd_sof_dsp_power_down_notify(sdev);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"error: %d failed to prepare DSP for device removal\",\n\t\t\t\t ret);\n\n\t\tsnd_sof_ipc_free(sdev);\n\t\tsnd_sof_free_debug(sdev);\n\t\tsnd_sof_remove(sdev);\n\t\tsof_ops_free(sdev);\n\t} else if (aborted) {\n\t\t \n\t\tsof_ops_free(sdev);\n\t}\n\n\t \n\tsnd_sof_fw_unload(sdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_device_remove);\n\nint snd_sof_device_shutdown(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_PROBE_WORK_QUEUE))\n\t\tcancel_work_sync(&sdev->probe_work);\n\n\tif (sdev->fw_state == SOF_FW_BOOT_COMPLETE) {\n\t\tsof_fw_trace_free(sdev);\n\t\treturn snd_sof_shutdown(sdev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_device_shutdown);\n\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_DESCRIPTION(\"Sound Open Firmware (SOF) Core\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:sof-audio\");\nMODULE_IMPORT_NS(SND_SOC_SOF_CLIENT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}