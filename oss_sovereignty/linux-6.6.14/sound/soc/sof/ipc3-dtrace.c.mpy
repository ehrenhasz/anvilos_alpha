{
  "module_name": "ipc3-dtrace.c",
  "hash_id": "f9e6ee5ba1bbc79b43011c1f15be10a3cc3efb5cf91612dfb2e7edd975012c1e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3-dtrace.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/sched/signal.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ops.h\"\n#include \"sof-utils.h\"\n#include \"ipc3-priv.h\"\n\n#define TRACE_FILTER_ELEMENTS_PER_ENTRY 4\n#define TRACE_FILTER_MAX_CONFIG_STRING_LENGTH 1024\n\nenum sof_dtrace_state {\n\tSOF_DTRACE_DISABLED,\n\tSOF_DTRACE_STOPPED,\n\tSOF_DTRACE_INITIALIZING,\n\tSOF_DTRACE_ENABLED,\n};\n\nstruct sof_dtrace_priv {\n\tstruct snd_dma_buffer dmatb;\n\tstruct snd_dma_buffer dmatp;\n\tint dma_trace_pages;\n\twait_queue_head_t trace_sleep;\n\tu32 host_offset;\n\tbool dtrace_error;\n\tbool dtrace_draining;\n\tenum sof_dtrace_state dtrace_state;\n};\n\nstatic bool trace_pos_update_expected(struct sof_dtrace_priv *priv)\n{\n\tif (priv->dtrace_state == SOF_DTRACE_ENABLED ||\n\t    priv->dtrace_state == SOF_DTRACE_INITIALIZING)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int trace_filter_append_elem(struct snd_sof_dev *sdev, u32 key, u32 value,\n\t\t\t\t    struct sof_ipc_trace_filter_elem *elem_list,\n\t\t\t\t    int capacity, int *counter)\n{\n\tif (*counter >= capacity)\n\t\treturn -ENOMEM;\n\n\telem_list[*counter].key = key;\n\telem_list[*counter].value = value;\n\t++*counter;\n\n\treturn 0;\n}\n\nstatic int trace_filter_parse_entry(struct snd_sof_dev *sdev, const char *line,\n\t\t\t\t    struct sof_ipc_trace_filter_elem *elem,\n\t\t\t\t    int capacity, int *counter)\n{\n\tint log_level, pipe_id, comp_id, read, ret;\n\tint len = strlen(line);\n\tint cnt = *counter;\n\tu32 uuid_id;\n\n\t \n\tret = sscanf(line, \" %n\", &read);\n\tif (!ret && read == len)\n\t\treturn len;\n\n\tret = sscanf(line, \" %d %x %d %d %n\", &log_level, &uuid_id, &pipe_id, &comp_id, &read);\n\tif (ret != TRACE_FILTER_ELEMENTS_PER_ENTRY || read != len) {\n\t\tdev_err(sdev->dev, \"Invalid trace filter entry '%s'\\n\", line);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uuid_id > 0) {\n\t\tret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_UUID,\n\t\t\t\t\t       uuid_id, elem, capacity, &cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (pipe_id >= 0) {\n\t\tret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_PIPE,\n\t\t\t\t\t       pipe_id, elem, capacity, &cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (comp_id >= 0) {\n\t\tret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_BY_COMP,\n\t\t\t\t\t       comp_id, elem, capacity, &cnt);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = trace_filter_append_elem(sdev, SOF_IPC_TRACE_FILTER_ELEM_SET_LEVEL |\n\t\t\t\t       SOF_IPC_TRACE_FILTER_ELEM_FIN,\n\t\t\t\t       log_level, elem, capacity, &cnt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*counter = cnt;\n\n\treturn len;\n}\n\nstatic int trace_filter_parse(struct snd_sof_dev *sdev, char *string,\n\t\t\t      int *out_elem_cnt,\n\t\t\t      struct sof_ipc_trace_filter_elem **out)\n{\n\tstatic const char entry_delimiter[] = \";\";\n\tchar *entry = string;\n\tint capacity = 0;\n\tint entry_len;\n\tint cnt = 0;\n\n\t \n\twhile (entry) {\n\t\tcapacity += TRACE_FILTER_ELEMENTS_PER_ENTRY;\n\t\tentry = strchr(entry + 1, entry_delimiter[0]);\n\t}\n\t*out = kmalloc(capacity * sizeof(**out), GFP_KERNEL);\n\tif (!*out)\n\t\treturn -ENOMEM;\n\n\t \n\twhile ((entry = strsep(&string, entry_delimiter))) {\n\t\tentry_len = trace_filter_parse_entry(sdev, entry, *out, capacity, &cnt);\n\t\tif (entry_len < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"Parsing filter entry '%s' failed with %d\\n\",\n\t\t\t\tentry, entry_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t*out_elem_cnt = cnt;\n\n\treturn 0;\n}\n\nstatic int ipc3_trace_update_filter(struct snd_sof_dev *sdev, int num_elems,\n\t\t\t\t    struct sof_ipc_trace_filter_elem *elems)\n{\n\tstruct sof_ipc_trace_filter *msg;\n\tsize_t size;\n\tint ret;\n\n\tsize = struct_size(msg, elems, num_elems);\n\tif (size > SOF_IPC_MSG_MAX_SIZE)\n\t\treturn -EINVAL;\n\n\tmsg = kmalloc(size, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.size = size;\n\tmsg->hdr.cmd = SOF_IPC_GLB_TRACE_MSG | SOF_IPC_TRACE_FILTER_UPDATE;\n\tmsg->elem_cnt = num_elems;\n\tmemcpy(&msg->elems[0], elems, num_elems * sizeof(*elems));\n\n\tret = pm_runtime_resume_and_get(sdev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err(sdev->dev, \"enabling device failed: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, msg, msg->hdr.size);\n\tpm_runtime_mark_last_busy(sdev->dev);\n\tpm_runtime_put_autosuspend(sdev->dev);\n\nerror:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic ssize_t dfsentry_trace_filter_write(struct file *file, const char __user *from,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct sof_ipc_trace_filter_elem *elems = NULL;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tint num_elems;\n\tchar *string;\n\tint ret;\n\n\tif (count > TRACE_FILTER_MAX_CONFIG_STRING_LENGTH) {\n\t\tdev_err(sdev->dev, \"%s too long input, %zu > %d\\n\", __func__, count,\n\t\t\tTRACE_FILTER_MAX_CONFIG_STRING_LENGTH);\n\t\treturn -EINVAL;\n\t}\n\n\tstring = memdup_user_nul(from, count);\n\tif (IS_ERR(string))\n\t\treturn PTR_ERR(string);\n\n\tret = trace_filter_parse(sdev, string, &num_elems, &elems);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (num_elems) {\n\t\tret = ipc3_trace_update_filter(sdev, num_elems, elems);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Filter update failed: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = count;\nerror:\n\tkfree(string);\n\tkfree(elems);\n\treturn ret;\n}\n\nstatic const struct file_operations sof_dfs_trace_filter_fops = {\n\t.open = simple_open,\n\t.write = dfsentry_trace_filter_write,\n\t.llseek = default_llseek,\n};\n\nstatic int debugfs_create_trace_filter(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->sdev = sdev;\n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\n\tdebugfs_create_file(\"filter\", 0200, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_trace_filter_fops);\n\t \n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\n\nstatic bool sof_dtrace_set_host_offset(struct sof_dtrace_priv *priv, u32 new_offset)\n{\n\tu32 host_offset = READ_ONCE(priv->host_offset);\n\n\tif (host_offset != new_offset) {\n\t\t \n\t\tu32 ret = cmpxchg(&priv->host_offset, host_offset, new_offset);\n\n\t\tif (ret == host_offset)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic size_t sof_dtrace_avail(struct snd_sof_dev *sdev,\n\t\t\t       loff_t pos, size_t buffer_size)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\tloff_t host_offset = READ_ONCE(priv->host_offset);\n\n\t \n\tif (host_offset < pos)\n\t\treturn buffer_size - pos;\n\n\t \n\tif (host_offset > pos)\n\t\treturn host_offset - pos;\n\n\treturn 0;\n}\n\nstatic size_t sof_wait_dtrace_avail(struct snd_sof_dev *sdev, loff_t pos,\n\t\t\t\t    size_t buffer_size)\n{\n\tsize_t ret = sof_dtrace_avail(sdev, pos, buffer_size);\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\twait_queue_entry_t wait;\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->dtrace_draining && !trace_pos_update_expected(priv)) {\n\t\t \n\t\tpriv->dtrace_draining = false;\n\t\treturn 0;\n\t}\n\n\t \n\tinit_waitqueue_entry(&wait, current);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&priv->trace_sleep, &wait);\n\n\tif (!signal_pending(current)) {\n\t\t \n\t\tschedule_timeout(MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&priv->trace_sleep, &wait);\n\n\treturn sof_dtrace_avail(sdev, pos, buffer_size);\n}\n\nstatic ssize_t dfsentry_dtrace_read(struct file *file, char __user *buffer,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\tunsigned long rem;\n\tloff_t lpos = *ppos;\n\tsize_t avail, buffer_size = dfse->size;\n\tu64 lpos_64;\n\n\t \n\tpriv->dtrace_error = false;\n\n\t \n\tif (lpos < 0)\n\t\treturn -EINVAL;\n\tif (!count)\n\t\treturn 0;\n\n\t \n\tlpos_64 = lpos;\n\tlpos = do_div(lpos_64, buffer_size);\n\n\t \n\tavail = sof_wait_dtrace_avail(sdev, lpos, buffer_size);\n\tif (priv->dtrace_error) {\n\t\tdev_err(sdev->dev, \"trace IO error\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (!avail)\n\t\treturn 0;\n\n\t \n\tif (count > avail)\n\t\tcount = avail;\n\n\t \n\tsnd_dma_buffer_sync(&priv->dmatb, SNDRV_DMA_SYNC_CPU);\n\t \n\trem = copy_to_user(buffer, ((u8 *)(dfse->buf) + lpos), count);\n\tif (rem)\n\t\treturn -EFAULT;\n\n\t*ppos += count;\n\n\t \n\treturn count;\n}\n\nstatic int dfsentry_dtrace_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_sof_dfsentry *dfse = inode->i_private;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\n\t \n\tif (priv->dtrace_state != SOF_DTRACE_ENABLED)\n\t\tsof_dtrace_set_host_offset(priv, 0);\n\n\treturn 0;\n}\n\nstatic const struct file_operations sof_dfs_dtrace_fops = {\n\t.open = simple_open,\n\t.read = dfsentry_dtrace_read,\n\t.llseek = default_llseek,\n\t.release = dfsentry_dtrace_release,\n};\n\nstatic int debugfs_create_dtrace(struct snd_sof_dev *sdev)\n{\n\tstruct sof_dtrace_priv *priv;\n\tstruct snd_sof_dfsentry *dfse;\n\tint ret;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tpriv = sdev->fw_trace_data;\n\n\tret = debugfs_create_trace_filter(sdev);\n\tif (ret < 0)\n\t\tdev_warn(sdev->dev, \"failed to create filter debugfs file: %d\", ret);\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\tdfse->buf = priv->dmatb.area;\n\tdfse->size = priv->dmatb.bytes;\n\tdfse->sdev = sdev;\n\n\tdebugfs_create_file(\"trace\", 0444, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_dtrace_fops);\n\n\treturn 0;\n}\n\nstatic int ipc3_dtrace_enable(struct snd_sof_dev *sdev)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tstruct sof_ipc_dma_trace_params_ext params;\n\tint ret;\n\n\tif (!sdev->fw_trace_is_supported)\n\t\treturn 0;\n\n\tif (priv->dtrace_state == SOF_DTRACE_ENABLED || !priv->dma_trace_pages)\n\t\treturn -EINVAL;\n\n\tif (priv->dtrace_state == SOF_DTRACE_STOPPED)\n\t\tgoto start;\n\n\t \n\tparams.hdr.cmd = SOF_IPC_GLB_TRACE_MSG;\n\t \n\tif (v->abi_version >= SOF_ABI_VER(3, 7, 0)) {\n\t\tparams.hdr.size = sizeof(struct sof_ipc_dma_trace_params_ext);\n\t\tparams.hdr.cmd |= SOF_IPC_TRACE_DMA_PARAMS_EXT;\n\t\tparams.timestamp_ns = ktime_get();  \n\t} else {\n\t\tparams.hdr.size = sizeof(struct sof_ipc_dma_trace_params);\n\t\tparams.hdr.cmd |= SOF_IPC_TRACE_DMA_PARAMS;\n\t}\n\tparams.buffer.phy_addr = priv->dmatp.addr;\n\tparams.buffer.size = priv->dmatb.bytes;\n\tparams.buffer.pages = priv->dma_trace_pages;\n\tparams.stream_tag = 0;\n\n\tsof_dtrace_set_host_offset(priv, 0);\n\tpriv->dtrace_draining = false;\n\n\tret = sof_dtrace_host_init(sdev, &priv->dmatb, &params);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"Host dtrace init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(sdev->dev, \"stream_tag: %d\\n\", params.stream_tag);\n\n\t \n\tpriv->dtrace_state = SOF_DTRACE_INITIALIZING;\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &params, sizeof(params));\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"can't set params for DMA for trace %d\\n\", ret);\n\t\tgoto trace_release;\n\t}\n\nstart:\n\tpriv->dtrace_state = SOF_DTRACE_ENABLED;\n\n\tret = sof_dtrace_host_trigger(sdev, SNDRV_PCM_TRIGGER_START);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"Host dtrace trigger start failed: %d\\n\", ret);\n\t\tgoto trace_release;\n\t}\n\n\treturn 0;\n\ntrace_release:\n\tpriv->dtrace_state = SOF_DTRACE_DISABLED;\n\tsof_dtrace_host_release(sdev);\n\treturn ret;\n}\n\nstatic int ipc3_dtrace_init(struct snd_sof_dev *sdev)\n{\n\tstruct sof_dtrace_priv *priv;\n\tint ret;\n\n\t \n\tif (sdev->pdata->ipc_type != SOF_IPC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sdev->fw_trace_data) {\n\t\tdev_err(sdev->dev, \"fw_trace_data has been already allocated\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpriv = devm_kzalloc(sdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsdev->fw_trace_data = priv;\n\n\t \n\tpriv->dtrace_state = SOF_DTRACE_DISABLED;\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,\n\t\t\t\t  PAGE_SIZE, &priv->dmatp);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"can't alloc page table for trace %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_dma_alloc_dir_pages(SNDRV_DMA_TYPE_DEV_SG, sdev->dev,\n\t\t\t\t      DMA_FROM_DEVICE, DMA_BUF_SIZE_FOR_TRACE,\n\t\t\t\t      &priv->dmatb);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"can't alloc buffer for trace %d\\n\", ret);\n\t\tgoto page_err;\n\t}\n\n\t \n\tret = snd_sof_create_page_table(sdev->dev, &priv->dmatb,\n\t\t\t\t\tpriv->dmatp.area, priv->dmatb.bytes);\n\tif (ret < 0)\n\t\tgoto table_err;\n\n\tpriv->dma_trace_pages = ret;\n\tdev_dbg(sdev->dev, \"dma_trace_pages: %d\\n\", priv->dma_trace_pages);\n\n\tif (sdev->first_boot) {\n\t\tret = debugfs_create_dtrace(sdev);\n\t\tif (ret < 0)\n\t\t\tgoto table_err;\n\t}\n\n\tinit_waitqueue_head(&priv->trace_sleep);\n\n\tret = ipc3_dtrace_enable(sdev);\n\tif (ret < 0)\n\t\tgoto table_err;\n\n\treturn 0;\ntable_err:\n\tpriv->dma_trace_pages = 0;\n\tsnd_dma_free_pages(&priv->dmatb);\npage_err:\n\tsnd_dma_free_pages(&priv->dmatp);\n\treturn ret;\n}\n\nint ipc3_dtrace_posn_update(struct snd_sof_dev *sdev,\n\t\t\t    struct sof_ipc_dma_trace_posn *posn)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\n\tif (!sdev->fw_trace_is_supported)\n\t\treturn 0;\n\n\tif (trace_pos_update_expected(priv) &&\n\t    sof_dtrace_set_host_offset(priv, posn->host_offset))\n\t\twake_up(&priv->trace_sleep);\n\n\tif (posn->overflow != 0)\n\t\tdev_err(sdev->dev,\n\t\t\t\"DSP trace buffer overflow %u bytes. Total messages %d\\n\",\n\t\t\tposn->overflow, posn->messages);\n\n\treturn 0;\n}\n\n \nstatic void ipc3_dtrace_fw_crashed(struct snd_sof_dev *sdev)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\n\tif (priv->dtrace_state == SOF_DTRACE_ENABLED) {\n\t\tpriv->dtrace_error = true;\n\t\twake_up(&priv->trace_sleep);\n\t}\n}\n\nstatic void ipc3_dtrace_release(struct snd_sof_dev *sdev, bool only_stop)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tstruct sof_ipc_cmd_hdr hdr;\n\tint ret;\n\n\tif (!sdev->fw_trace_is_supported || priv->dtrace_state == SOF_DTRACE_DISABLED)\n\t\treturn;\n\n\tret = sof_dtrace_host_trigger(sdev, SNDRV_PCM_TRIGGER_STOP);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"Host dtrace trigger stop failed: %d\\n\", ret);\n\tpriv->dtrace_state = SOF_DTRACE_STOPPED;\n\n\t \n\tif (v->abi_version >= SOF_ABI_VER(3, 20, 0)) {\n\t\thdr.size = sizeof(hdr);\n\t\thdr.cmd = SOF_IPC_GLB_TRACE_MSG | SOF_IPC_TRACE_DMA_FREE;\n\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &hdr, hdr.size);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"DMA_TRACE_FREE failed with error: %d\\n\", ret);\n\t}\n\n\tif (only_stop)\n\t\tgoto out;\n\n\tret = sof_dtrace_host_release(sdev);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"Host dtrace release failed %d\\n\", ret);\n\n\tpriv->dtrace_state = SOF_DTRACE_DISABLED;\n\nout:\n\tpriv->dtrace_draining = true;\n\twake_up(&priv->trace_sleep);\n}\n\nstatic void ipc3_dtrace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state)\n{\n\tipc3_dtrace_release(sdev, pm_state.event == SOF_DSP_PM_D0);\n}\n\nstatic int ipc3_dtrace_resume(struct snd_sof_dev *sdev)\n{\n\treturn ipc3_dtrace_enable(sdev);\n}\n\nstatic void ipc3_dtrace_free(struct snd_sof_dev *sdev)\n{\n\tstruct sof_dtrace_priv *priv = sdev->fw_trace_data;\n\n\t \n\tipc3_dtrace_release(sdev, false);\n\n\tif (priv->dma_trace_pages) {\n\t\tsnd_dma_free_pages(&priv->dmatb);\n\t\tsnd_dma_free_pages(&priv->dmatp);\n\t\tpriv->dma_trace_pages = 0;\n\t}\n}\n\nconst struct sof_ipc_fw_tracing_ops ipc3_dtrace_ops = {\n\t.init = ipc3_dtrace_init,\n\t.free = ipc3_dtrace_free,\n\t.fw_crashed = ipc3_dtrace_fw_crashed,\n\t.suspend = ipc3_dtrace_suspend,\n\t.resume = ipc3_dtrace_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}