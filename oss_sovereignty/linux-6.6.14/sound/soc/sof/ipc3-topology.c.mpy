{
  "module_name": "ipc3-topology.c",
  "hash_id": "d1396d76620e5895013518823ee9107acc30da16aa411fd6c887a9ec14b39940",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3-topology.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <uapi/sound/sof/tokens.h>\n#include <sound/pcm_params.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc3-priv.h\"\n#include \"ops.h\"\n\n \n#define VOL_ZERO_DB\tBIT(VOLUME_FWL)\n\n \n#define SOF_IPC3_TPLG_ABI_SIZE 3\n\nstruct sof_widget_data {\n\tint ctrl_type;\n\tint ipc_cmd;\n\tvoid *pdata;\n\tsize_t pdata_size;\n\tstruct snd_sof_control *control;\n};\n\nstruct sof_process_types {\n\tconst char *name;\n\tenum sof_ipc_process_type type;\n\tenum sof_comp_type comp_type;\n};\n\nstatic const struct sof_process_types sof_process[] = {\n\t{\"EQFIR\", SOF_PROCESS_EQFIR, SOF_COMP_EQ_FIR},\n\t{\"EQIIR\", SOF_PROCESS_EQIIR, SOF_COMP_EQ_IIR},\n\t{\"KEYWORD_DETECT\", SOF_PROCESS_KEYWORD_DETECT, SOF_COMP_KEYWORD_DETECT},\n\t{\"KPB\", SOF_PROCESS_KPB, SOF_COMP_KPB},\n\t{\"CHAN_SELECTOR\", SOF_PROCESS_CHAN_SELECTOR, SOF_COMP_SELECTOR},\n\t{\"MUX\", SOF_PROCESS_MUX, SOF_COMP_MUX},\n\t{\"DEMUX\", SOF_PROCESS_DEMUX, SOF_COMP_DEMUX},\n\t{\"DCBLOCK\", SOF_PROCESS_DCBLOCK, SOF_COMP_DCBLOCK},\n\t{\"SMART_AMP\", SOF_PROCESS_SMART_AMP, SOF_COMP_SMART_AMP},\n};\n\nstatic enum sof_ipc_process_type find_process(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sof_process); i++) {\n\t\tif (strcmp(name, sof_process[i].name) == 0)\n\t\t\treturn sof_process[i].type;\n\t}\n\n\treturn SOF_PROCESS_NONE;\n}\n\nstatic int get_token_process_type(void *elem, void *object, u32 offset)\n{\n\tu32 *val = (u32 *)((u8 *)object + offset);\n\n\t*val = find_process((const char *)elem);\n\treturn 0;\n}\n\n \nstatic const struct sof_topology_token buffer_tokens[] = {\n\t{SOF_TKN_BUF_SIZE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_buffer, size)},\n\t{SOF_TKN_BUF_CAPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_buffer, caps)},\n};\n\n \nstatic const struct sof_topology_token dai_tokens[] = {\n\t{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,\n\t\toffsetof(struct sof_ipc_comp_dai, type)},\n\t{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_dai, dai_index)},\n\t{SOF_TKN_DAI_DIRECTION, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_dai, direction)},\n};\n\n \nstatic const struct sof_topology_token dai_link_tokens[] = {\n\t{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,\n\t\toffsetof(struct sof_ipc_dai_config, type)},\n\t{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_config, dai_index)},\n};\n\n \nstatic const struct sof_topology_token sched_tokens[] = {\n\t{SOF_TKN_SCHED_PERIOD, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, period)},\n\t{SOF_TKN_SCHED_PRIORITY, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, priority)},\n\t{SOF_TKN_SCHED_MIPS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, period_mips)},\n\t{SOF_TKN_SCHED_CORE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, core)},\n\t{SOF_TKN_SCHED_FRAMES, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, frames_per_sched)},\n\t{SOF_TKN_SCHED_TIME_DOMAIN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_pipe_new, time_domain)},\n};\n\nstatic const struct sof_topology_token pipeline_tokens[] = {\n\t{SOF_TKN_SCHED_DYNAMIC_PIPELINE, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct snd_sof_widget, dynamic_pipeline_widget)},\n\n};\n\n \nstatic const struct sof_topology_token volume_tokens[] = {\n\t{SOF_TKN_VOLUME_RAMP_STEP_TYPE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_volume, ramp)},\n\t{SOF_TKN_VOLUME_RAMP_STEP_MS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_volume, initial_ramp)},\n};\n\n \nstatic const struct sof_topology_token src_tokens[] = {\n\t{SOF_TKN_SRC_RATE_IN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_src, source_rate)},\n\t{SOF_TKN_SRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_src, sink_rate)},\n};\n\n \nstatic const struct sof_topology_token asrc_tokens[] = {\n\t{SOF_TKN_ASRC_RATE_IN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_asrc, source_rate)},\n\t{SOF_TKN_ASRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_asrc, sink_rate)},\n\t{SOF_TKN_ASRC_ASYNCHRONOUS_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_asrc, asynchronous_mode)},\n\t{SOF_TKN_ASRC_OPERATION_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_asrc, operation_mode)},\n};\n\n \nstatic const struct sof_topology_token process_tokens[] = {\n\t{SOF_TKN_PROCESS_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_process_type,\n\t\toffsetof(struct sof_ipc_comp_process, type)},\n};\n\n \nstatic const struct sof_topology_token pcm_tokens[] = {\n\t{SOF_TKN_PCM_DMAC_CONFIG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_host, dmac_config)},\n};\n\n \nstatic const struct sof_topology_token comp_tokens[] = {\n\t{SOF_TKN_COMP_PERIOD_SINK_COUNT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_config, periods_sink)},\n\t{SOF_TKN_COMP_PERIOD_SOURCE_COUNT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp_config, periods_source)},\n\t{SOF_TKN_COMP_FORMAT,\n\t\tSND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_comp_format,\n\t\toffsetof(struct sof_ipc_comp_config, frame_fmt)},\n};\n\n \nstatic const struct sof_topology_token ssp_tokens[] = {\n\t{SOF_TKN_INTEL_SSP_CLKS_CONTROL, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, clks_control)},\n\t{SOF_TKN_INTEL_SSP_MCLK_ID, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, mclk_id)},\n\t{SOF_TKN_INTEL_SSP_SAMPLE_BITS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, sample_valid_bits)},\n\t{SOF_TKN_INTEL_SSP_FRAME_PULSE_WIDTH, SND_SOC_TPLG_TUPLE_TYPE_SHORT,\tget_token_u16,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, frame_pulse_width)},\n\t{SOF_TKN_INTEL_SSP_QUIRKS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, quirks)},\n\t{SOF_TKN_INTEL_SSP_TDM_PADDING_PER_SLOT, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, tdm_per_slot_padding_flag)},\n\t{SOF_TKN_INTEL_SSP_BCLK_DELAY, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_ssp_params, bclk_delay)},\n};\n\n \nstatic const struct sof_topology_token alh_tokens[] = {\n\t{SOF_TKN_INTEL_ALH_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_alh_params, rate)},\n\t{SOF_TKN_INTEL_ALH_CH,\tSND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_alh_params, channels)},\n};\n\n \nstatic const struct sof_topology_token dmic_tokens[] = {\n\t{SOF_TKN_INTEL_DMIC_DRIVER_VERSION, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, driver_ipc_version)},\n\t{SOF_TKN_INTEL_DMIC_CLK_MIN, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, pdmclk_min)},\n\t{SOF_TKN_INTEL_DMIC_CLK_MAX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, pdmclk_max)},\n\t{SOF_TKN_INTEL_DMIC_SAMPLE_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, fifo_fs)},\n\t{SOF_TKN_INTEL_DMIC_DUTY_MIN, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, duty_min)},\n\t{SOF_TKN_INTEL_DMIC_DUTY_MAX, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, duty_max)},\n\t{SOF_TKN_INTEL_DMIC_NUM_PDM_ACTIVE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, num_pdm_active)},\n\t{SOF_TKN_INTEL_DMIC_FIFO_WORD_LENGTH, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, fifo_bits)},\n\t{SOF_TKN_INTEL_DMIC_UNMUTE_RAMP_TIME_MS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_dmic_params, unmute_ramp_time)},\n};\n\n \nstatic const struct sof_topology_token esai_tokens[] = {\n\t{SOF_TKN_IMX_ESAI_MCLK_ID, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_esai_params, mclk_id)},\n};\n\n \nstatic const struct sof_topology_token sai_tokens[] = {\n\t{SOF_TKN_IMX_SAI_MCLK_ID, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_sai_params, mclk_id)},\n};\n\n \nstatic const struct sof_topology_token dmic_pdm_tokens[] = {\n\t{SOF_TKN_INTEL_DMIC_PDM_CTRL_ID, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, id)},\n\t{SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, enable_mic_a)},\n\t{SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, enable_mic_b)},\n\t{SOF_TKN_INTEL_DMIC_PDM_POLARITY_A, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, polarity_mic_a)},\n\t{SOF_TKN_INTEL_DMIC_PDM_POLARITY_B, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, polarity_mic_b)},\n\t{SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, clk_edge)},\n\t{SOF_TKN_INTEL_DMIC_PDM_SKEW, SND_SOC_TPLG_TUPLE_TYPE_SHORT, get_token_u16,\n\t\toffsetof(struct sof_ipc_dai_dmic_pdm_ctrl, skew)},\n};\n\n \nstatic const struct sof_topology_token hda_tokens[] = {\n\t{SOF_TKN_INTEL_HDA_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_hda_params, rate)},\n\t{SOF_TKN_INTEL_HDA_CH, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_hda_params, channels)},\n};\n\n \nstatic const struct sof_topology_token afe_tokens[] = {\n\t{SOF_TKN_MEDIATEK_AFE_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_mtk_afe_params, rate)},\n\t{SOF_TKN_MEDIATEK_AFE_CH, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_mtk_afe_params, channels)},\n\t{SOF_TKN_MEDIATEK_AFE_FORMAT, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_comp_format,\n\t\toffsetof(struct sof_ipc_dai_mtk_afe_params, format)},\n};\n\n \nstatic const struct sof_topology_token acpdmic_tokens[] = {\n\t{SOF_TKN_AMD_ACPDMIC_RATE,\n\t\tSND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_acpdmic_params, pdm_rate)},\n\t{SOF_TKN_AMD_ACPDMIC_CH,\n\t\tSND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_acpdmic_params, pdm_ch)},\n};\n\n \nstatic const struct sof_topology_token acpi2s_tokens[] = {\n\t{SOF_TKN_AMD_ACPI2S_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_acp_params, fsync_rate)},\n\t{SOF_TKN_AMD_ACPI2S_CH, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_acp_params, tdm_slots)},\n\t{SOF_TKN_AMD_ACPI2S_TDM_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_dai_acp_params, tdm_mode)},\n};\n\n \nstatic const struct sof_topology_token core_tokens[] = {\n\t{SOF_TKN_COMP_CORE_ID, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc_comp, core)},\n};\n\n \nstatic const struct sof_topology_token comp_ext_tokens[] = {\n\t{SOF_TKN_COMP_UUID, SND_SOC_TPLG_TUPLE_TYPE_UUID, get_token_uuid,\n\t\toffsetof(struct snd_sof_widget, uuid)},\n};\n\nstatic const struct sof_token_info ipc3_token_list[SOF_TOKEN_COUNT] = {\n\t[SOF_PCM_TOKENS] = {\"PCM tokens\", pcm_tokens, ARRAY_SIZE(pcm_tokens)},\n\t[SOF_PIPELINE_TOKENS] = {\"Pipeline tokens\", pipeline_tokens, ARRAY_SIZE(pipeline_tokens)},\n\t[SOF_SCHED_TOKENS] = {\"Scheduler tokens\", sched_tokens, ARRAY_SIZE(sched_tokens)},\n\t[SOF_COMP_TOKENS] = {\"Comp tokens\", comp_tokens, ARRAY_SIZE(comp_tokens)},\n\t[SOF_CORE_TOKENS] = {\"Core tokens\", core_tokens, ARRAY_SIZE(core_tokens)},\n\t[SOF_COMP_EXT_TOKENS] = {\"AFE tokens\", comp_ext_tokens, ARRAY_SIZE(comp_ext_tokens)},\n\t[SOF_BUFFER_TOKENS] = {\"Buffer tokens\", buffer_tokens, ARRAY_SIZE(buffer_tokens)},\n\t[SOF_VOLUME_TOKENS] = {\"Volume tokens\", volume_tokens, ARRAY_SIZE(volume_tokens)},\n\t[SOF_SRC_TOKENS] = {\"SRC tokens\", src_tokens, ARRAY_SIZE(src_tokens)},\n\t[SOF_ASRC_TOKENS] = {\"ASRC tokens\", asrc_tokens, ARRAY_SIZE(asrc_tokens)},\n\t[SOF_PROCESS_TOKENS] = {\"Process tokens\", process_tokens, ARRAY_SIZE(process_tokens)},\n\t[SOF_DAI_TOKENS] = {\"DAI tokens\", dai_tokens, ARRAY_SIZE(dai_tokens)},\n\t[SOF_DAI_LINK_TOKENS] = {\"DAI link tokens\", dai_link_tokens, ARRAY_SIZE(dai_link_tokens)},\n\t[SOF_HDA_TOKENS] = {\"HDA tokens\", hda_tokens, ARRAY_SIZE(hda_tokens)},\n\t[SOF_SSP_TOKENS] = {\"SSP tokens\", ssp_tokens, ARRAY_SIZE(ssp_tokens)},\n\t[SOF_ALH_TOKENS] = {\"ALH tokens\", alh_tokens, ARRAY_SIZE(alh_tokens)},\n\t[SOF_DMIC_TOKENS] = {\"DMIC tokens\", dmic_tokens, ARRAY_SIZE(dmic_tokens)},\n\t[SOF_DMIC_PDM_TOKENS] = {\"DMIC PDM tokens\", dmic_pdm_tokens, ARRAY_SIZE(dmic_pdm_tokens)},\n\t[SOF_ESAI_TOKENS] = {\"ESAI tokens\", esai_tokens, ARRAY_SIZE(esai_tokens)},\n\t[SOF_SAI_TOKENS] = {\"SAI tokens\", sai_tokens, ARRAY_SIZE(sai_tokens)},\n\t[SOF_AFE_TOKENS] = {\"AFE tokens\", afe_tokens, ARRAY_SIZE(afe_tokens)},\n\t[SOF_ACPDMIC_TOKENS] = {\"ACPDMIC tokens\", acpdmic_tokens, ARRAY_SIZE(acpdmic_tokens)},\n\t[SOF_ACPI2S_TOKENS]   = {\"ACPI2S tokens\", acpi2s_tokens, ARRAY_SIZE(acpi2s_tokens)},\n};\n\n \nstatic void *sof_comp_alloc(struct snd_sof_widget *swidget, size_t *ipc_size,\n\t\t\t    int index)\n{\n\tstruct sof_ipc_comp *comp;\n\tsize_t total_size = *ipc_size;\n\tsize_t ext_size = sizeof(swidget->uuid);\n\n\t \n\tif (!guid_is_null(&swidget->uuid))\n\t\ttotal_size += ext_size;\n\n\tcomp = kzalloc(total_size, GFP_KERNEL);\n\tif (!comp)\n\t\treturn NULL;\n\n\t \n\tcomp->hdr.size = total_size;\n\tcomp->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_NEW;\n\tcomp->id = swidget->comp_id;\n\tcomp->pipeline_id = index;\n\tcomp->core = swidget->core;\n\n\t \n\tif (total_size > *ipc_size) {\n\t\t \n\t\tmemcpy((u8 *)comp + *ipc_size, &swidget->uuid, ext_size);\n\t\tcomp->ext_data_length = ext_size;\n\t}\n\n\t \n\t*ipc_size = total_size;\n\treturn comp;\n}\n\nstatic void sof_dbg_comp_config(struct snd_soc_component *scomp, struct sof_ipc_comp_config *config)\n{\n\tdev_dbg(scomp->dev, \" config: periods snk %d src %d fmt %d\\n\",\n\t\tconfig->periods_sink, config->periods_source,\n\t\tconfig->frame_fmt);\n}\n\nstatic int sof_ipc3_widget_setup_comp_host(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_host *host;\n\tsize_t ipc_size = sizeof(*host);\n\tint ret;\n\n\thost = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!host)\n\t\treturn -ENOMEM;\n\tswidget->private = host;\n\n\t \n\thost->comp.type = SOF_COMP_HOST;\n\thost->config.hdr.size = sizeof(host->config);\n\n\tif (swidget->id == snd_soc_dapm_aif_out)\n\t\thost->direction = SOF_IPC_STREAM_CAPTURE;\n\telse\n\t\thost->direction = SOF_IPC_STREAM_PLAYBACK;\n\n\t \n\tret = sof_update_ipc_object(scomp, host, SOF_PCM_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*host), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = sof_update_ipc_object(scomp, &host->config, SOF_COMP_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(host->config), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(scomp->dev, \"loaded host %s\\n\", swidget->widget->name);\n\tsof_dbg_comp_config(scomp, &host->config);\n\n\treturn 0;\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n\n\treturn ret;\n}\n\nstatic void sof_ipc3_widget_free_comp(struct snd_sof_widget *swidget)\n{\n\tkfree(swidget->private);\n}\n\nstatic int sof_ipc3_widget_setup_comp_tone(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_tone *tone;\n\tsize_t ipc_size = sizeof(*tone);\n\tint ret;\n\n\ttone = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!tone)\n\t\treturn -ENOMEM;\n\n\tswidget->private = tone;\n\n\t \n\ttone->comp.type = SOF_COMP_TONE;\n\ttone->config.hdr.size = sizeof(tone->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, &tone->config, SOF_COMP_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(tone->config), 1);\n\tif (ret < 0) {\n\t\tkfree(swidget->private);\n\t\tswidget->private = NULL;\n\t\treturn ret;\n\t}\n\n\tdev_dbg(scomp->dev, \"tone %s: frequency %d amplitude %d\\n\",\n\t\tswidget->widget->name, tone->frequency, tone->amplitude);\n\tsof_dbg_comp_config(scomp, &tone->config);\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_widget_setup_comp_mixer(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_mixer *mixer;\n\tsize_t ipc_size = sizeof(*mixer);\n\tint ret;\n\n\tmixer = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\n\tswidget->private = mixer;\n\n\t \n\tmixer->comp.type = SOF_COMP_MIXER;\n\tmixer->config.hdr.size = sizeof(mixer->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, &mixer->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples,\n\t\t\t\t    sizeof(mixer->config), 1);\n\tif (ret < 0) {\n\t\tkfree(swidget->private);\n\t\tswidget->private = NULL;\n\n\t\treturn ret;\n\t}\n\n\tdev_dbg(scomp->dev, \"loaded mixer %s\\n\", swidget->widget->name);\n\tsof_dbg_comp_config(scomp, &mixer->config);\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_widget_setup_comp_pipeline(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tstruct sof_ipc_pipe_new *pipeline;\n\tstruct snd_sof_widget *comp_swidget;\n\tint ret;\n\n\tpipeline = kzalloc(sizeof(*pipeline), GFP_KERNEL);\n\tif (!pipeline)\n\t\treturn -ENOMEM;\n\n\t \n\tpipeline->hdr.size = sizeof(*pipeline);\n\tpipeline->hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_NEW;\n\tpipeline->pipeline_id = swidget->pipeline_id;\n\tpipeline->comp_id = swidget->comp_id;\n\n\tswidget->private = pipeline;\n\n\t \n\tcomp_swidget = snd_sof_find_swidget(scomp, swidget->widget->sname);\n\tif (!comp_swidget) {\n\t\tdev_err(scomp->dev, \"scheduler %s refers to non existent widget %s\\n\",\n\t\t\tswidget->widget->name, swidget->widget->sname);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tpipeline->sched_id = comp_swidget->comp_id;\n\n\t \n\tret = sof_update_ipc_object(scomp, pipeline, SOF_SCHED_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*pipeline), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = sof_update_ipc_object(scomp, swidget, SOF_PIPELINE_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*swidget), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tif (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE))\n\t\tpipeline->core = SOF_DSP_PRIMARY_CORE;\n\n\tif (sof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_OVERRIDE))\n\t\tswidget->dynamic_pipeline_widget =\n\t\t\tsof_debug_check_flag(SOF_DBG_DYNAMIC_PIPELINES_ENABLE);\n\n\tdev_dbg(scomp->dev, \"pipeline %s: period %d pri %d mips %d core %d frames %d dynamic %d\\n\",\n\t\tswidget->widget->name, pipeline->period, pipeline->priority,\n\t\tpipeline->period_mips, pipeline->core, pipeline->frames_per_sched,\n\t\tswidget->dynamic_pipeline_widget);\n\n\tswidget->core = pipeline->core;\n\tspipe->core_mask |= BIT(pipeline->core);\n\n\treturn 0;\n\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_widget_setup_comp_buffer(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_buffer *buffer;\n\tint ret;\n\n\tbuffer = kzalloc(sizeof(*buffer), GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tswidget->private = buffer;\n\n\t \n\tbuffer->comp.hdr.size = sizeof(*buffer);\n\tbuffer->comp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_BUFFER_NEW;\n\tbuffer->comp.id = swidget->comp_id;\n\tbuffer->comp.type = SOF_COMP_BUFFER;\n\tbuffer->comp.pipeline_id = swidget->pipeline_id;\n\tbuffer->comp.core = swidget->core;\n\n\t \n\tret = sof_update_ipc_object(scomp, buffer, SOF_BUFFER_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*buffer), 1);\n\tif (ret < 0) {\n\t\tkfree(swidget->private);\n\t\tswidget->private = NULL;\n\t\treturn ret;\n\t}\n\n\tdev_dbg(scomp->dev, \"buffer %s: size %d caps 0x%x\\n\",\n\t\tswidget->widget->name, buffer->size, buffer->caps);\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_widget_setup_comp_src(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_src *src;\n\tsize_t ipc_size = sizeof(*src);\n\tint ret;\n\n\tsrc = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\tswidget->private = src;\n\n\t \n\tsrc->comp.type = SOF_COMP_SRC;\n\tsrc->config.hdr.size = sizeof(src->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, src, SOF_SRC_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*src), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = sof_update_ipc_object(scomp, &src->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples, sizeof(src->config), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(scomp->dev, \"src %s: source rate %d sink rate %d\\n\",\n\t\tswidget->widget->name, src->source_rate, src->sink_rate);\n\tsof_dbg_comp_config(scomp, &src->config);\n\n\treturn 0;\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_widget_setup_comp_asrc(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_asrc *asrc;\n\tsize_t ipc_size = sizeof(*asrc);\n\tint ret;\n\n\tasrc = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!asrc)\n\t\treturn -ENOMEM;\n\n\tswidget->private = asrc;\n\n\t \n\tasrc->comp.type = SOF_COMP_ASRC;\n\tasrc->config.hdr.size = sizeof(asrc->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, asrc, SOF_ASRC_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*asrc), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = sof_update_ipc_object(scomp, &asrc->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples, sizeof(asrc->config), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(scomp->dev, \"asrc %s: source rate %d sink rate %d asynch %d operation %d\\n\",\n\t\tswidget->widget->name, asrc->source_rate, asrc->sink_rate,\n\t\tasrc->asynchronous_mode, asrc->operation_mode);\n\n\tsof_dbg_comp_config(scomp, &asrc->config);\n\n\treturn 0;\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n\n\treturn ret;\n}\n\n \nstatic int sof_ipc3_widget_setup_comp_mux(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_mux *mux;\n\tsize_t ipc_size = sizeof(*mux);\n\tint ret;\n\n\tmux = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tswidget->private = mux;\n\n\t \n\tmux->comp.type = SOF_COMP_MUX;\n\tmux->config.hdr.size = sizeof(mux->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, &mux->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples, sizeof(mux->config), 1);\n\tif (ret < 0) {\n\t\tkfree(swidget->private);\n\t\tswidget->private = NULL;\n\t\treturn ret;\n\t}\n\n\tdev_dbg(scomp->dev, \"loaded mux %s\\n\", swidget->widget->name);\n\tsof_dbg_comp_config(scomp, &mux->config);\n\n\treturn 0;\n}\n\n \n\nstatic int sof_ipc3_widget_setup_comp_pga(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc_comp_volume *volume;\n\tstruct snd_sof_control *scontrol;\n\tsize_t ipc_size = sizeof(*volume);\n\tint min_step, max_step;\n\tint ret;\n\n\tvolume = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!volume)\n\t\treturn -ENOMEM;\n\n\tswidget->private = volume;\n\n\t \n\tvolume->comp.type = SOF_COMP_VOLUME;\n\tvolume->config.hdr.size = sizeof(volume->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, volume, SOF_VOLUME_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*volume), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = sof_update_ipc_object(scomp, &volume->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples,\n\t\t\t\t    sizeof(volume->config), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(scomp->dev, \"loaded PGA %s\\n\", swidget->widget->name);\n\tsof_dbg_comp_config(scomp, &volume->config);\n\n\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list) {\n\t\tif (scontrol->comp_id == swidget->comp_id &&\n\t\t    scontrol->volume_table) {\n\t\t\tmin_step = scontrol->min_volume_step;\n\t\t\tmax_step = scontrol->max_volume_step;\n\t\t\tvolume->min_value = scontrol->volume_table[min_step];\n\t\t\tvolume->max_value = scontrol->volume_table[max_step];\n\t\t\tvolume->channels = scontrol->num_channels;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n\n\treturn ret;\n}\n\nstatic int sof_get_control_data(struct snd_soc_component *scomp,\n\t\t\t\tstruct snd_soc_dapm_widget *widget,\n\t\t\t\tstruct sof_widget_data *wdata, size_t *size)\n{\n\tconst struct snd_kcontrol_new *kc;\n\tstruct sof_ipc_ctrl_data *cdata;\n\tstruct soc_mixer_control *sm;\n\tstruct soc_bytes_ext *sbe;\n\tstruct soc_enum *se;\n\tint i;\n\n\t*size = 0;\n\n\tfor (i = 0; i < widget->num_kcontrols; i++) {\n\t\tkc = &widget->kcontrol_news[i];\n\n\t\tswitch (widget->dobj.widget.kcontrol_type[i]) {\n\t\tcase SND_SOC_TPLG_TYPE_MIXER:\n\t\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\t\twdata[i].control = sm->dobj.private;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TYPE_BYTES:\n\t\t\tsbe = (struct soc_bytes_ext *)kc->private_value;\n\t\t\twdata[i].control = sbe->dobj.private;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TYPE_ENUM:\n\t\t\tse = (struct soc_enum *)kc->private_value;\n\t\t\twdata[i].control = se->dobj.private;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(scomp->dev, \"Unknown kcontrol type %u in widget %s\\n\",\n\t\t\t\twidget->dobj.widget.kcontrol_type[i], widget->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!wdata[i].control) {\n\t\t\tdev_err(scomp->dev, \"No scontrol for widget %s\\n\", widget->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcdata = wdata[i].control->ipc_control_data;\n\n\t\tif (widget->dobj.widget.kcontrol_type[i] == SND_SOC_TPLG_TYPE_BYTES) {\n\t\t\t \n\t\t\tif (cdata->data->magic != SOF_ABI_MAGIC)\n\t\t\t\treturn -EINVAL;\n\n\t\t\twdata[i].pdata = cdata->data->data;\n\t\t\twdata[i].pdata_size = cdata->data->size;\n\t\t} else {\n\t\t\t \n\t\t\twdata[i].pdata = cdata->chanv;\n\t\t\t \n\t\t\twdata[i].pdata_size = wdata[i].control->size -\n\t\t\t\t\t      sizeof(struct sof_ipc_ctrl_data);\n\t\t}\n\n\t\t*size += wdata[i].pdata_size;\n\n\t\t \n\t\tswitch (cdata->cmd) {\n\t\tcase SOF_CTRL_CMD_VOLUME:\n\t\tcase SOF_CTRL_CMD_ENUM:\n\t\tcase SOF_CTRL_CMD_SWITCH:\n\t\t\twdata[i].ipc_cmd = SOF_IPC_COMP_SET_VALUE;\n\t\t\twdata[i].ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;\n\t\t\tbreak;\n\t\tcase SOF_CTRL_CMD_BINARY:\n\t\t\twdata[i].ipc_cmd = SOF_IPC_COMP_SET_DATA;\n\t\t\twdata[i].ctrl_type = SOF_CTRL_TYPE_DATA_SET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_process_load(struct snd_soc_component *scomp,\n\t\t\t    struct snd_sof_widget *swidget, int type)\n{\n\tstruct snd_soc_dapm_widget *widget = swidget->widget;\n\tstruct sof_ipc_comp_process *process;\n\tstruct sof_widget_data *wdata = NULL;\n\tsize_t ipc_data_size = 0;\n\tsize_t ipc_size;\n\tint offset = 0;\n\tint ret;\n\tint i;\n\n\t \n\tif (widget->num_kcontrols) {\n\t\twdata = kcalloc(widget->num_kcontrols, sizeof(*wdata), GFP_KERNEL);\n\t\tif (!wdata)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tret = sof_get_control_data(scomp, widget, wdata, &ipc_data_size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tipc_size = sizeof(struct sof_ipc_comp_process) + ipc_data_size;\n\n\t \n\tif (ipc_size > SOF_IPC_MSG_MAX_SIZE) {\n\t\tipc_size -= ipc_data_size;\n\t\tipc_data_size = 0;\n\t}\n\n\tprocess = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!process) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tswidget->private = process;\n\n\t \n\tprocess->comp.type = type;\n\tprocess->config.hdr.size = sizeof(process->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, &process->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples,\n\t\t\t\t    sizeof(process->config), 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdev_dbg(scomp->dev, \"loaded process %s\\n\", swidget->widget->name);\n\tsof_dbg_comp_config(scomp, &process->config);\n\n\t \n\tif (ipc_data_size) {\n\t\tfor (i = 0; i < widget->num_kcontrols; i++) {\n\t\t\tif (!wdata[i].pdata_size)\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(&process->data[offset], wdata[i].pdata,\n\t\t\t       wdata[i].pdata_size);\n\t\t\toffset += wdata[i].pdata_size;\n\t\t}\n\t}\n\n\tprocess->size = ipc_data_size;\n\n\tkfree(wdata);\n\n\treturn 0;\nerr:\n\tkfree(swidget->private);\n\tswidget->private = NULL;\nout:\n\tkfree(wdata);\n\treturn ret;\n}\n\nstatic enum sof_comp_type find_process_comp_type(enum sof_ipc_process_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sof_process); i++) {\n\t\tif (sof_process[i].type == type)\n\t\t\treturn sof_process[i].comp_type;\n\t}\n\n\treturn SOF_COMP_NONE;\n}\n\n \n\nstatic int sof_widget_update_ipc_comp_process(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc_comp_process config;\n\tint ret;\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.comp.core = swidget->core;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config, SOF_PROCESS_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(config), 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn sof_process_load(scomp, swidget, find_process_comp_type(config.type));\n}\n\nstatic int sof_link_hda_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t     struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tmemset(&config->hda, 0, sizeof(config->hda));\n\tconfig->hdr.size = size;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->hda, SOF_HDA_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(scomp->dev, \"HDA config rate %d channels %d\\n\",\n\t\tconfig->hda.rate, config->hda.channels);\n\n\tconfig->hda.link_dma_ch = DMA_CHAN_INVALID;\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void sof_dai_set_format(struct snd_soc_tplg_hw_config *hw_config,\n\t\t\t       struct sof_ipc_dai_config *config)\n{\n\t \n\tconfig->format &= ~SOF_DAI_FMT_CLOCK_PROVIDER_MASK;\n\tif (hw_config->bclk_provider == SND_SOC_TPLG_BCLK_CP) {\n\t\t \n\t\tif (hw_config->fsync_provider == SND_SOC_TPLG_FSYNC_CP)\n\t\t\tconfig->format |= SOF_DAI_FMT_CBP_CFP;\n\t\telse\n\t\t\tconfig->format |= SOF_DAI_FMT_CBP_CFC;\n\t} else {\n\t\t \n\t\tif (hw_config->fsync_provider == SND_SOC_TPLG_FSYNC_CP)\n\t\t\tconfig->format |= SOF_DAI_FMT_CBC_CFP;\n\t\telse\n\t\t\tconfig->format |= SOF_DAI_FMT_CBC_CFC;\n\t}\n\n\t \n\tconfig->format &= ~SOF_DAI_FMT_INV_MASK;\n\tif (hw_config->invert_bclk) {\n\t\tif (hw_config->invert_fsync)\n\t\t\tconfig->format |= SOF_DAI_FMT_IB_IF;\n\t\telse\n\t\t\tconfig->format |= SOF_DAI_FMT_IB_NF;\n\t} else {\n\t\tif (hw_config->invert_fsync)\n\t\t\tconfig->format |= SOF_DAI_FMT_NB_IF;\n\t\telse\n\t\t\tconfig->format |= SOF_DAI_FMT_NB_NF;\n\t}\n}\n\nstatic int sof_link_sai_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t     struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tsof_dai_set_format(hw_config, config);\n\n\t \n\tmemset(&config->sai, 0, sizeof(config->sai));\n\tconfig->hdr.size = size;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->sai, SOF_SAI_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconfig->sai.mclk_rate = le32_to_cpu(hw_config->mclk_rate);\n\tconfig->sai.bclk_rate = le32_to_cpu(hw_config->bclk_rate);\n\tconfig->sai.fsync_rate = le32_to_cpu(hw_config->fsync_rate);\n\tconfig->sai.mclk_direction = hw_config->mclk_direction;\n\n\tconfig->sai.tdm_slots = le32_to_cpu(hw_config->tdm_slots);\n\tconfig->sai.tdm_slot_width = le32_to_cpu(hw_config->tdm_slot_width);\n\tconfig->sai.rx_slots = le32_to_cpu(hw_config->rx_slots);\n\tconfig->sai.tx_slots = le32_to_cpu(hw_config->tx_slots);\n\n\tdev_info(scomp->dev,\n\t\t \"tplg: config SAI%d fmt 0x%x mclk %d width %d slots %d mclk id %d\\n\",\n\t\tconfig->dai_index, config->format,\n\t\tconfig->sai.mclk_rate, config->sai.tdm_slot_width,\n\t\tconfig->sai.tdm_slots, config->sai.mclk_id);\n\n\tif (config->sai.tdm_slots < 1 || config->sai.tdm_slots > 8) {\n\t\tdev_err(scomp->dev, \"Invalid channel count for SAI%d\\n\", config->dai_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_esai_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t      struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tsof_dai_set_format(hw_config, config);\n\n\t \n\tmemset(&config->esai, 0, sizeof(config->esai));\n\tconfig->hdr.size = size;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->esai, SOF_ESAI_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconfig->esai.mclk_rate = le32_to_cpu(hw_config->mclk_rate);\n\tconfig->esai.bclk_rate = le32_to_cpu(hw_config->bclk_rate);\n\tconfig->esai.fsync_rate = le32_to_cpu(hw_config->fsync_rate);\n\tconfig->esai.mclk_direction = hw_config->mclk_direction;\n\tconfig->esai.tdm_slots = le32_to_cpu(hw_config->tdm_slots);\n\tconfig->esai.tdm_slot_width = le32_to_cpu(hw_config->tdm_slot_width);\n\tconfig->esai.rx_slots = le32_to_cpu(hw_config->rx_slots);\n\tconfig->esai.tx_slots = le32_to_cpu(hw_config->tx_slots);\n\n\tdev_info(scomp->dev,\n\t\t \"tplg: config ESAI%d fmt 0x%x mclk %d width %d slots %d mclk id %d\\n\",\n\t\tconfig->dai_index, config->format,\n\t\tconfig->esai.mclk_rate, config->esai.tdm_slot_width,\n\t\tconfig->esai.tdm_slots, config->esai.mclk_id);\n\n\tif (config->esai.tdm_slots < 1 || config->esai.tdm_slots > 8) {\n\t\tdev_err(scomp->dev, \"Invalid channel count for ESAI%d\\n\", config->dai_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_acp_dmic_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t\t  struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n        \n\tsof_dai_set_format(hw_config, config);\n\n\tconfig->hdr.size = size;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->acpdmic, SOF_ACPDMIC_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(scomp->dev, \"ACP_DMIC config ACP%d channel %d rate %d\\n\",\n\t\t config->dai_index, config->acpdmic.pdm_ch,\n\t\t config->acpdmic.pdm_rate);\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_acp_bt_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t\tstruct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\n\t \n\tsof_dai_set_format(hw_config, config);\n\n\t \n\tmemset(&config->acpbt, 0, sizeof(config->acpbt));\n\tconfig->hdr.size = size;\n\n\tconfig->acpbt.fsync_rate = le32_to_cpu(hw_config->fsync_rate);\n\tconfig->acpbt.tdm_slots = le32_to_cpu(hw_config->tdm_slots);\n\n\tdev_info(scomp->dev, \"ACP_BT config ACP%d channel %d rate %d\\n\",\n\t\t config->dai_index, config->acpbt.tdm_slots,\n\t\t config->acpbt.fsync_rate);\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_acp_sp_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t\tstruct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tsof_dai_set_format(hw_config, config);\n\n\t \n\tmemset(&config->acpsp, 0, sizeof(config->acpsp));\n\tconfig->hdr.size = size;\n\n\tret = sof_update_ipc_object(scomp, &config->acpsp, SOF_ACPI2S_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\n\tdev_info(scomp->dev, \"ACP_SP config ACP%d channel %d rate %d tdm_mode %d\\n\",\n\t\t config->dai_index, config->acpsp.tdm_slots,\n\t\t config->acpsp.fsync_rate, config->acpsp.tdm_mode);\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_acp_hs_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t\tstruct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tsof_dai_set_format(hw_config, config);\n\n\t \n\tmemset(&config->acphs, 0, sizeof(config->acphs));\n\tconfig->hdr.size = size;\n\n\tret = sof_update_ipc_object(scomp, &config->acphs, SOF_ACPI2S_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(scomp->dev, \"ACP_HS config ACP%d channel %d rate %d tdm_mode %d\\n\",\n\t\t config->dai_index, config->acphs.tdm_slots,\n\t\t config->acphs.fsync_rate, config->acphs.tdm_mode);\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_afe_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t     struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\tconfig->hdr.size = size;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->afe, SOF_AFE_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(scomp->dev, \"AFE config rate %d channels %d format:%d\\n\",\n\t\tconfig->afe.rate, config->afe.channels, config->afe.format);\n\n\tconfig->afe.stream_id = DMA_CHAN_INVALID;\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_ssp_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t     struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_soc_tplg_hw_config *hw_config = slink->hw_configs;\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint current_config = 0;\n\tint i, ret;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->ssp, SOF_SSP_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < slink->num_hw_configs; i++) {\n\t\tif (le32_to_cpu(hw_config[i].id) == slink->default_hw_cfg_id)\n\t\t\tcurrent_config = i;\n\n\t\t \n\t\tsof_dai_set_format(&hw_config[i], &config[i]);\n\n\t\tconfig[i].hdr.size = size;\n\n\t\tif (sdev->mclk_id_override) {\n\t\t\tdev_dbg(scomp->dev, \"tplg: overriding topology mclk_id %d by quirk %d\\n\",\n\t\t\t\tconfig[i].ssp.mclk_id, sdev->mclk_id_quirk);\n\t\t\tconfig[i].ssp.mclk_id = sdev->mclk_id_quirk;\n\t\t}\n\n\t\t \n\t\tconfig[i].ssp.mclk_rate = le32_to_cpu(hw_config[i].mclk_rate);\n\t\tconfig[i].ssp.bclk_rate = le32_to_cpu(hw_config[i].bclk_rate);\n\t\tconfig[i].ssp.fsync_rate = le32_to_cpu(hw_config[i].fsync_rate);\n\t\tconfig[i].ssp.tdm_slots = le32_to_cpu(hw_config[i].tdm_slots);\n\t\tconfig[i].ssp.tdm_slot_width = le32_to_cpu(hw_config[i].tdm_slot_width);\n\t\tconfig[i].ssp.mclk_direction = hw_config[i].mclk_direction;\n\t\tconfig[i].ssp.rx_slots = le32_to_cpu(hw_config[i].rx_slots);\n\t\tconfig[i].ssp.tx_slots = le32_to_cpu(hw_config[i].tx_slots);\n\n\t\tdev_dbg(scomp->dev, \"tplg: config SSP%d fmt %#x mclk %d bclk %d fclk %d width (%d)%d slots %d mclk id %d quirks %d clks_control %#x\\n\",\n\t\t\tconfig[i].dai_index, config[i].format,\n\t\t\tconfig[i].ssp.mclk_rate, config[i].ssp.bclk_rate,\n\t\t\tconfig[i].ssp.fsync_rate, config[i].ssp.sample_valid_bits,\n\t\t\tconfig[i].ssp.tdm_slot_width, config[i].ssp.tdm_slots,\n\t\t\tconfig[i].ssp.mclk_id, config[i].ssp.quirks, config[i].ssp.clks_control);\n\n\t\t \n\t\tif (config[i].ssp.fsync_rate < 8000 || config[i].ssp.fsync_rate > 192000) {\n\t\t\tdev_err(scomp->dev, \"Invalid fsync rate for SSP%d\\n\", config[i].dai_index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (config[i].ssp.tdm_slots < 1 || config[i].ssp.tdm_slots > 8) {\n\t\t\tdev_err(scomp->dev, \"Invalid channel count for SSP%d\\n\",\n\t\t\t\tconfig[i].dai_index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdai->number_configs = slink->num_hw_configs;\n\tdai->current_config = current_config;\n\tprivate->dai_config = kmemdup(config, size * slink->num_hw_configs, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_dmic_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t      struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_dai_private_data *private = dai->private;\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\tsize_t size = sizeof(*config);\n\tint i, ret;\n\n\t \n\tmemset(&config->dmic, 0, sizeof(config->dmic));\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->dmic, SOF_DMIC_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->dmic.pdm[0], SOF_DMIC_PDM_TOKENS,\n\t\t\t\t    slink->tuples, slink->num_tuples,\n\t\t\t\t    sizeof(struct sof_ipc_dai_dmic_pdm_ctrl),\n\t\t\t\t    config->dmic.num_pdm_active);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tconfig->hdr.size = size;\n\n\t \n\tdev_dbg(scomp->dev, \"tplg: config DMIC%d driver version %d\\n\",\n\t\tconfig->dai_index, config->dmic.driver_ipc_version);\n\tdev_dbg(scomp->dev, \"pdmclk_min %d pdm_clkmax %d duty_min %d\\n\",\n\t\tconfig->dmic.pdmclk_min, config->dmic.pdmclk_max,\n\t\tconfig->dmic.duty_min);\n\tdev_dbg(scomp->dev, \"duty_max %d fifo_fs %d num_pdms active %d\\n\",\n\t\tconfig->dmic.duty_max, config->dmic.fifo_fs,\n\t\tconfig->dmic.num_pdm_active);\n\tdev_dbg(scomp->dev, \"fifo word length %d\\n\", config->dmic.fifo_bits);\n\n\tfor (i = 0; i < config->dmic.num_pdm_active; i++) {\n\t\tdev_dbg(scomp->dev, \"pdm %d mic a %d mic b %d\\n\",\n\t\t\tconfig->dmic.pdm[i].id,\n\t\t\tconfig->dmic.pdm[i].enable_mic_a,\n\t\t\tconfig->dmic.pdm[i].enable_mic_b);\n\t\tdev_dbg(scomp->dev, \"pdm %d polarity a %d polarity b %d\\n\",\n\t\t\tconfig->dmic.pdm[i].id,\n\t\t\tconfig->dmic.pdm[i].polarity_mic_a,\n\t\t\tconfig->dmic.pdm[i].polarity_mic_b);\n\t\tdev_dbg(scomp->dev, \"pdm %d clk_edge %d skew %d\\n\",\n\t\t\tconfig->dmic.pdm[i].id,\n\t\t\tconfig->dmic.pdm[i].clk_edge,\n\t\t\tconfig->dmic.pdm[i].skew);\n\t}\n\n\t \n\tif (SOF_ABI_VER(v->major, v->minor, v->micro) < SOF_ABI_VER(3, 0, 1))\n\t\tconfig->dmic.fifo_bits_b = config->dmic.fifo_bits;\n\n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_link_alh_load(struct snd_soc_component *scomp, struct snd_sof_dai_link *slink,\n\t\t\t     struct sof_ipc_dai_config *config, struct snd_sof_dai *dai)\n{\n\tstruct sof_dai_private_data *private = dai->private;\n\tu32 size = sizeof(*config);\n\tint ret;\n\n\t \n\tret = sof_update_ipc_object(scomp, &config->alh, SOF_ALH_TOKENS, slink->tuples,\n\t\t\t\t    slink->num_tuples, size, slink->num_hw_configs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tconfig->hdr.size = size;\n\n\t \n\tdai->number_configs = 1;\n\tdai->current_config = 0;\n\tprivate->dai_config = kmemdup(config, size, GFP_KERNEL);\n\tif (!private->dai_config)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_widget_setup_comp_dai(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_dai *dai = swidget->private;\n\tstruct sof_dai_private_data *private;\n\tstruct sof_ipc_comp_dai *comp_dai;\n\tsize_t ipc_size = sizeof(*comp_dai);\n\tstruct sof_ipc_dai_config *config;\n\tstruct snd_sof_dai_link *slink;\n\tint ret;\n\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tdai->private = private;\n\n\tprivate->comp_dai = sof_comp_alloc(swidget, &ipc_size, swidget->pipeline_id);\n\tif (!private->comp_dai) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\t \n\tcomp_dai = private->comp_dai;\n\tcomp_dai->comp.type = SOF_COMP_DAI;\n\tcomp_dai->config.hdr.size = sizeof(comp_dai->config);\n\n\t \n\tret = sof_update_ipc_object(scomp, comp_dai, SOF_DAI_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*comp_dai), 1);\n\tif (ret < 0)\n\t\tgoto free;\n\n\t \n\tret = sof_update_ipc_object(scomp, &comp_dai->config, SOF_COMP_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples,\n\t\t\t\t    sizeof(comp_dai->config), 1);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tdev_dbg(scomp->dev, \"dai %s: type %d index %d\\n\",\n\t\tswidget->widget->name, comp_dai->type, comp_dai->dai_index);\n\tsof_dbg_comp_config(scomp, &comp_dai->config);\n\n\t \n\tlist_for_each_entry(slink, &sdev->dai_link_list, list) {\n\t\tstruct sof_ipc_dai_config common_config;\n\t\tint i;\n\n\t\tif (strcmp(slink->link->name, dai->name))\n\t\t\tcontinue;\n\n\t\t \n\t\tconfig = kcalloc(slink->num_hw_configs, sizeof(*config), GFP_KERNEL);\n\t\tif (!config) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_comp;\n\t\t}\n\n\t\t \n\t\tret = sof_update_ipc_object(scomp, &common_config, SOF_DAI_LINK_TOKENS,\n\t\t\t\t\t    slink->tuples, slink->num_tuples,\n\t\t\t\t\t    sizeof(common_config), 1);\n\t\tif (ret < 0)\n\t\t\tgoto free_config;\n\n\t\tfor (i = 0; i < slink->num_hw_configs; i++) {\n\t\t\tconfig[i].hdr.cmd = SOF_IPC_GLB_DAI_MSG | SOF_IPC_DAI_CONFIG;\n\t\t\tconfig[i].format = le32_to_cpu(slink->hw_configs[i].fmt);\n\t\t\tconfig[i].type = common_config.type;\n\t\t\tconfig[i].dai_index = comp_dai->dai_index;\n\t\t}\n\n\t\tswitch (common_config.type) {\n\t\tcase SOF_DAI_INTEL_SSP:\n\t\t\tret = sof_link_ssp_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_INTEL_DMIC:\n\t\t\tret = sof_link_dmic_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_INTEL_HDA:\n\t\t\tret = sof_link_hda_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_INTEL_ALH:\n\t\t\tret = sof_link_alh_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_IMX_SAI:\n\t\t\tret = sof_link_sai_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_IMX_ESAI:\n\t\t\tret = sof_link_esai_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_AMD_BT:\n\t\t\tret = sof_link_acp_bt_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_AMD_SP:\n\t\tcase SOF_DAI_AMD_SP_VIRTUAL:\n\t\t\tret = sof_link_acp_sp_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_AMD_HS:\n\t\tcase SOF_DAI_AMD_HS_VIRTUAL:\n\t\t\tret = sof_link_acp_hs_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_AMD_DMIC:\n\t\t\tret = sof_link_acp_dmic_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tcase SOF_DAI_MEDIATEK_AFE:\n\t\t\tret = sof_link_afe_load(scomp, slink, config, dai);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"failed to load config for dai %s\\n\", dai->name);\n\t\t\tgoto free_config;\n\t\t}\n\n\t\tkfree(config);\n\t}\n\n\treturn 0;\nfree_config:\n\tkfree(config);\nfree_comp:\n\tkfree(comp_dai);\nfree:\n\tkfree(private);\n\tdai->private = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc3_widget_free_comp_dai(struct snd_sof_widget *swidget)\n{\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t{\n\t\tstruct snd_sof_dai *dai = swidget->private;\n\t\tstruct sof_dai_private_data *dai_data;\n\n\t\tif (!dai)\n\t\t\treturn;\n\n\t\tdai_data = dai->private;\n\t\tif (dai_data) {\n\t\t\tkfree(dai_data->comp_dai);\n\t\t\tkfree(dai_data->dai_config);\n\t\t\tkfree(dai_data);\n\t\t}\n\t\tkfree(dai);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int sof_ipc3_route_setup(struct snd_sof_dev *sdev, struct snd_sof_route *sroute)\n{\n\tstruct sof_ipc_pipe_comp_connect connect;\n\tint ret;\n\n\tconnect.hdr.size = sizeof(connect);\n\tconnect.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_CONNECT;\n\tconnect.source_id = sroute->src_widget->comp_id;\n\tconnect.sink_id = sroute->sink_widget->comp_id;\n\n\tdev_dbg(sdev->dev, \"setting up route %s -> %s\\n\",\n\t\tsroute->src_widget->widget->name,\n\t\tsroute->sink_widget->widget->name);\n\n\t \n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &connect, sizeof(connect));\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"%s: route %s -> %s failed\\n\", __func__,\n\t\t\tsroute->src_widget->widget->name, sroute->sink_widget->widget->name);\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_control_load_bytes(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata;\n\tsize_t priv_size_check;\n\tint ret;\n\n\tif (scontrol->max_size < (sizeof(*cdata) + sizeof(struct sof_abi_hdr))) {\n\t\tdev_err(sdev->dev, \"%s: insufficient size for a bytes control: %zu.\\n\",\n\t\t\t__func__, scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (scontrol->priv_size > scontrol->max_size - sizeof(*cdata)) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: bytes data size %zu exceeds max %zu.\\n\", __func__,\n\t\t\tscontrol->priv_size, scontrol->max_size - sizeof(*cdata));\n\t\treturn -EINVAL;\n\t}\n\n\tscontrol->ipc_control_data = kzalloc(scontrol->max_size, GFP_KERNEL);\n\tif (!scontrol->ipc_control_data)\n\t\treturn -ENOMEM;\n\n\tscontrol->size = sizeof(struct sof_ipc_ctrl_data) + scontrol->priv_size;\n\n\tcdata = scontrol->ipc_control_data;\n\tcdata->cmd = SOF_CTRL_CMD_BINARY;\n\tcdata->index = scontrol->index;\n\n\tif (scontrol->priv_size > 0) {\n\t\tmemcpy(cdata->data, scontrol->priv, scontrol->priv_size);\n\t\tkfree(scontrol->priv);\n\t\tscontrol->priv = NULL;\n\n\t\tif (cdata->data->magic != SOF_ABI_MAGIC) {\n\t\t\tdev_err(sdev->dev, \"Wrong ABI magic 0x%08x.\\n\", cdata->data->magic);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, cdata->data->abi)) {\n\t\t\tdev_err(sdev->dev, \"Incompatible ABI version 0x%08x.\\n\",\n\t\t\t\tcdata->data->abi);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tpriv_size_check = cdata->data->size + sizeof(struct sof_abi_hdr);\n\t\tif (priv_size_check != scontrol->priv_size) {\n\t\t\tdev_err(sdev->dev, \"Conflict in bytes (%zu) vs. priv size (%zu).\\n\",\n\t\t\t\tpriv_size_check, scontrol->priv_size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tkfree(scontrol->ipc_control_data);\n\tscontrol->ipc_control_data = NULL;\n\treturn ret;\n}\n\nstatic int sof_ipc3_control_load_volume(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata;\n\tint i;\n\n\t \n\tscontrol->size = struct_size(cdata, chanv, scontrol->num_channels);\n\n\tscontrol->ipc_control_data = kzalloc(scontrol->size, GFP_KERNEL);\n\tif (!scontrol->ipc_control_data)\n\t\treturn -ENOMEM;\n\n\tcdata = scontrol->ipc_control_data;\n\tcdata->index = scontrol->index;\n\n\t \n\tif (scontrol->max == 1) {\n\t\tcdata->cmd = SOF_CTRL_CMD_SWITCH;\n\t\treturn 0;\n\t}\n\n\tcdata->cmd = SOF_CTRL_CMD_VOLUME;\n\n\t \n\tfor (i = 0; i < scontrol->num_channels; i++) {\n\t\tcdata->chanv[i].channel = i;\n\t\tcdata->chanv[i].value = VOL_ZERO_DB;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_control_load_enum(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc_ctrl_data *cdata;\n\n\t \n\tscontrol->size = struct_size(cdata, chanv, scontrol->num_channels);\n\n\tscontrol->ipc_control_data = kzalloc(scontrol->size, GFP_KERNEL);\n\tif (!scontrol->ipc_control_data)\n\t\treturn -ENOMEM;\n\n\tcdata = scontrol->ipc_control_data;\n\tcdata->index = scontrol->index;\n\tcdata->cmd = SOF_CTRL_CMD_ENUM;\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_control_setup(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tswitch (scontrol->info_type) {\n\tcase SND_SOC_TPLG_CTL_VOLSW:\n\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\treturn sof_ipc3_control_load_volume(sdev, scontrol);\n\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\treturn sof_ipc3_control_load_bytes(sdev, scontrol);\n\tcase SND_SOC_TPLG_CTL_ENUM:\n\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\t\treturn sof_ipc3_control_load_enum(sdev, scontrol);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_control_free(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc_free fcomp;\n\n\tfcomp.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_COMP_FREE;\n\tfcomp.hdr.size = sizeof(fcomp);\n\tfcomp.id = scontrol->comp_id;\n\n\t \n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &fcomp, sizeof(fcomp));\n}\n\n \nstatic int sof_ipc3_keyword_detect_pcm_params(struct snd_sof_widget *swidget, int dir)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_pcm_hw_params *params;\n\tstruct sof_ipc_pcm_params pcm;\n\tstruct snd_sof_pcm *spcm;\n\tint ret;\n\n\t \n\tspcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);\n\tif (!spcm) {\n\t\tdev_err(scomp->dev, \"Cannot find PCM for %s\\n\", swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\tparams = &spcm->params[dir];\n\n\t \n\tmemset(&pcm, 0, sizeof(pcm));\n\tpcm.hdr.size = sizeof(pcm);\n\tpcm.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;\n\tpcm.comp_id = swidget->comp_id;\n\tpcm.params.hdr.size = sizeof(pcm.params);\n\tpcm.params.direction = dir;\n\tpcm.params.sample_valid_bytes = params_width(params) >> 3;\n\tpcm.params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;\n\tpcm.params.rate = params_rate(params);\n\tpcm.params.channels = params_channels(params);\n\tpcm.params.host_period_bytes = params_period_bytes(params);\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S16_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S24_4LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &pcm, sizeof(pcm));\n\tif (ret < 0)\n\t\tdev_err(scomp->dev, \"%s: PCM params failed for %s\\n\", __func__,\n\t\t\tswidget->widget->name);\n\n\treturn ret;\n}\n\n  \nstatic int sof_ipc3_keyword_detect_trigger(struct snd_sof_widget *swidget, int cmd)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc_stream stream;\n\tint ret;\n\n\t \n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | cmd;\n\tstream.comp_id = swidget->comp_id;\n\n\t \n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &stream, sizeof(stream));\n\tif (ret < 0)\n\t\tdev_err(scomp->dev, \"%s: Failed to trigger %s\\n\", __func__, swidget->widget->name);\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_keyword_dapm_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t       struct snd_kcontrol *k, int event)\n{\n\tstruct snd_sof_widget *swidget = w->dobj.private;\n\tstruct snd_soc_component *scomp;\n\tint stream = SNDRV_PCM_STREAM_CAPTURE;\n\tstruct snd_sof_pcm *spcm;\n\tint ret = 0;\n\n\tif (!swidget)\n\t\treturn 0;\n\n\tscomp = swidget->scomp;\n\n\tdev_dbg(scomp->dev, \"received event %d for widget %s\\n\",\n\t\tevent, w->name);\n\n\t \n\tspcm = snd_sof_find_spcm_name(scomp, swidget->widget->sname);\n\tif (!spcm) {\n\t\tdev_err(scomp->dev, \"%s: Cannot find PCM for %s\\n\", __func__,\n\t\t\tswidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (spcm->stream[stream].suspend_ignored) {\n\t\t\tdev_dbg(scomp->dev, \"PRE_PMU event ignored, KWD pipeline is already RUNNING\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret = sof_ipc3_keyword_detect_pcm_params(swidget, stream);\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"%s: Failed to set pcm params for widget %s\\n\",\n\t\t\t\t__func__, swidget->widget->name);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = sof_ipc3_keyword_detect_trigger(swidget, SOF_IPC_STREAM_TRIG_START);\n\t\tif (ret < 0)\n\t\t\tdev_err(scomp->dev, \"%s: Failed to trigger widget %s\\n\", __func__,\n\t\t\t\tswidget->widget->name);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (spcm->stream[stream].suspend_ignored) {\n\t\t\tdev_dbg(scomp->dev,\n\t\t\t\t\"POST_PMD event ignored, KWD pipeline will remain RUNNING\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret = sof_ipc3_keyword_detect_trigger(swidget, SOF_IPC_STREAM_TRIG_STOP);\n\t\tif (ret < 0)\n\t\t\tdev_err(scomp->dev, \"%s: Failed to trigger widget %s\\n\", __func__,\n\t\t\t\tswidget->widget->name);\n\n\t\t \n\t\tret = sof_ipc3_keyword_detect_trigger(swidget, SOF_IPC_STREAM_PCM_FREE);\n\t\tif (ret < 0)\n\t\t\tdev_err(scomp->dev, \"%s: Failed to free PCM for widget %s\\n\", __func__,\n\t\t\t\tswidget->widget->name);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic const struct snd_soc_tplg_widget_events sof_kwd_events[] = {\n\t{SOF_KEYWORD_DETECT_DAPM_EVENT, sof_ipc3_keyword_dapm_event},\n};\n\nstatic int sof_ipc3_widget_bind_event(struct snd_soc_component *scomp,\n\t\t\t\t      struct snd_sof_widget *swidget, u16 event_type)\n{\n\tstruct sof_ipc_comp *ipc_comp;\n\n\t \n\tswitch (event_type) {\n\tcase SOF_KEYWORD_DETECT_DAPM_EVENT:\n\t\t \n\t\tif (swidget->id != snd_soc_dapm_effect)\n\t\t\tbreak;\n\n\t\tipc_comp = swidget->private;\n\t\tif (ipc_comp && ipc_comp->type != SOF_COMP_KEYWORD_DETECT)\n\t\t\tbreak;\n\n\t\t \n\t\treturn snd_soc_tplg_widget_bind_event(swidget->widget, sof_kwd_events,\n\t\t\t\t\t\t      ARRAY_SIZE(sof_kwd_events), event_type);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_err(scomp->dev, \"Invalid event type %d for widget %s\\n\", event_type,\n\t\tswidget->widget->name);\n\n\treturn -EINVAL;\n}\n\nstatic int sof_ipc3_complete_pipeline(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc_pipe_ready ready;\n\tint ret;\n\n\tdev_dbg(sdev->dev, \"tplg: complete pipeline %s id %d\\n\",\n\t\tswidget->widget->name, swidget->comp_id);\n\n\tmemset(&ready, 0, sizeof(ready));\n\tready.hdr.size = sizeof(ready);\n\tready.hdr.cmd = SOF_IPC_GLB_TPLG_MSG | SOF_IPC_TPLG_PIPE_COMPLETE;\n\tready.comp_id = swidget->comp_id;\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &ready, sizeof(ready));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 1;\n}\n\nstatic int sof_ipc3_widget_free(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc_free ipc_free = {\n\t\t.hdr = {\n\t\t\t.size = sizeof(ipc_free),\n\t\t\t.cmd = SOF_IPC_GLB_TPLG_MSG,\n\t\t},\n\t\t.id = swidget->comp_id,\n\t};\n\tint ret;\n\n\tif (!swidget->private)\n\t\treturn 0;\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_scheduler:\n\t{\n\t\tipc_free.hdr.cmd |= SOF_IPC_TPLG_PIPE_FREE;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_buffer:\n\t\tipc_free.hdr.cmd |= SOF_IPC_TPLG_BUFFER_FREE;\n\t\tbreak;\n\tdefault:\n\t\tipc_free.hdr.cmd |= SOF_IPC_TPLG_COMP_FREE;\n\t\tbreak;\n\t}\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &ipc_free, sizeof(ipc_free));\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"failed to free widget %s\\n\", swidget->widget->name);\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_dai_config(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,\n\t\t\t       unsigned int flags, struct snd_sof_dai_config_data *data)\n{\n\tstruct sof_ipc_fw_version *v = &sdev->fw_ready.version;\n\tstruct snd_sof_dai *dai = swidget->private;\n\tstruct sof_dai_private_data *private;\n\tstruct sof_ipc_dai_config *config;\n\tint ret = 0;\n\n\tif (!dai || !dai->private) {\n\t\tdev_err(sdev->dev, \"No private data for DAI %s\\n\", swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\tprivate = dai->private;\n\tif (!private->dai_config) {\n\t\tdev_err(sdev->dev, \"No config for DAI %s\\n\", dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = &private->dai_config[dai->current_config];\n\tif (!config) {\n\t\tdev_err(sdev->dev, \"Invalid current config for DAI %s\\n\", dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (config->type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\t \n\t\tif (v->abi_version < SOF_ABI_VER(3, 18, 0) &&\n\t\t    ((flags & SOF_DAI_CONFIG_FLAGS_HW_PARAMS) ||\n\t\t     (flags & SOF_DAI_CONFIG_FLAGS_HW_FREE)))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase SOF_DAI_INTEL_HDA:\n\t\tif (data)\n\t\t\tconfig->hda.link_dma_ch = data->dai_data;\n\t\tbreak;\n\tcase SOF_DAI_INTEL_ALH:\n\t\tif (data) {\n\t\t\t \n\t\t\tif (flags & SOF_DAI_CONFIG_FLAGS_HW_PARAMS)\n\t\t\t\tconfig->dai_index = data->dai_index;\n\t\t\tconfig->alh.stream_id = data->dai_data;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\n\tif (flags & SOF_DAI_CONFIG_FLAGS_HW_PARAMS) {\n\t\t \n\t\tconfig->flags &= ~SOF_DAI_CONFIG_FLAGS_CMD_MASK;\n\t\tconfig->flags |= flags;\n\t} else {\n\t\tconfig->flags = flags;\n\t}\n\n\t \n\tif (swidget->use_count > 0) {\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, config, config->hdr.size);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"Failed to set dai config for %s\\n\", dai->name);\n\n\t\t \n\t\tconfig->flags = SOF_DAI_CONFIG_FLAGS_NONE;\n\t}\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_widget_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tint ret;\n\n\tif (!swidget->private)\n\t\treturn 0;\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t{\n\t\tstruct snd_sof_dai *dai = swidget->private;\n\t\tstruct sof_dai_private_data *dai_data = dai->private;\n\t\tstruct sof_ipc_comp *comp = &dai_data->comp_dai->comp;\n\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, dai_data->comp_dai, comp->hdr.size);\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_scheduler:\n\t{\n\t\tstruct sof_ipc_pipe_new *pipeline;\n\n\t\tpipeline = swidget->private;\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, pipeline, sizeof(*pipeline));\n\t\tbreak;\n\t}\n\tdefault:\n\t{\n\t\tstruct sof_ipc_cmd_hdr *hdr;\n\n\t\thdr = swidget->private;\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, swidget->private, hdr->size);\n\t\tbreak;\n\t}\n\t}\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"Failed to setup widget %s\\n\", swidget->widget->name);\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_set_up_all_pipelines(struct snd_sof_dev *sdev, bool verify)\n{\n\tstruct sof_ipc_fw_version *v = &sdev->fw_ready.version;\n\tstruct snd_sof_widget *swidget;\n\tstruct snd_sof_route *sroute;\n\tint ret;\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\t \n\t\tif (!verify && swidget->dynamic_pipeline_widget)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (v->abi_version < SOF_ABI_VER(3, 19, 0) &&\n\t\t    swidget->id == snd_soc_dapm_scheduler)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WIDGET_IS_DAI(swidget->id)) {\n\t\t\tstruct snd_sof_dai *dai = swidget->private;\n\t\t\tstruct sof_dai_private_data *private;\n\t\t\tstruct sof_ipc_dai_config *config;\n\n\t\t\tif (!dai || !dai->private)\n\t\t\t\tcontinue;\n\t\t\tprivate = dai->private;\n\t\t\tif (!private->dai_config)\n\t\t\t\tcontinue;\n\n\t\t\tconfig = private->dai_config;\n\t\t\t \n\t\t\tif (config->type == SOF_DAI_INTEL_HDA)\n\t\t\t\tconfig->hda.link_dma_ch = DMA_CHAN_INVALID;\n\t\t}\n\n\t\tret = sof_widget_setup(sdev, swidget);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tlist_for_each_entry(sroute, &sdev->route_list, list) {\n\t\t \n\t\tif (!verify && (sroute->src_widget->dynamic_pipeline_widget ||\n\t\t\t\tsroute->sink_widget->dynamic_pipeline_widget))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (sroute->src_widget->id != snd_soc_dapm_buffer &&\n\t\t    sroute->sink_widget->id != snd_soc_dapm_buffer)\n\t\t\tcontinue;\n\n\t\tret = sof_route_setup(sdev, sroute->src_widget->widget,\n\t\t\t\t      sroute->sink_widget->widget);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: route set up failed\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tswitch (swidget->id) {\n\t\tcase snd_soc_dapm_scheduler:\n\t\t\t \n\t\t\tif (!verify && swidget->dynamic_pipeline_widget)\n\t\t\t\tcontinue;\n\n\t\t\tif (v->abi_version < SOF_ABI_VER(3, 19, 0)) {\n\t\t\t\tret = sof_widget_setup(sdev, swidget);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tswidget->spipe->complete = sof_ipc3_complete_pipeline(sdev, swidget);\n\t\t\tif (swidget->spipe->complete < 0)\n\t\t\t\treturn swidget->spipe->complete;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_tear_down_left_over_pipelines(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_widget *swidget;\n\tstruct snd_sof_pcm *spcm;\n\tint dir, ret;\n\n\t \n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tfor_each_pcm_streams(dir) {\n\t\t\tstruct snd_pcm_substream *substream = spcm->stream[dir].substream;\n\n\t\t\tif (!substream || !substream->runtime || spcm->stream[dir].suspend_ignored)\n\t\t\t\tcontinue;\n\n\t\t\tif (spcm->stream[dir].list) {\n\t\t\t\tret = sof_pcm_stream_free(sdev, substream, spcm, dir, true);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list)\n\t\tif (WIDGET_IS_DAI(swidget->id) && swidget->use_count == 1) {\n\t\t\tret = sof_widget_free(sdev, swidget);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_ipc3_tear_down_all_pipelines(struct snd_sof_dev *sdev, bool verify)\n{\n\tstruct sof_ipc_fw_version *v = &sdev->fw_ready.version;\n\tstruct snd_sof_widget *swidget;\n\tstruct snd_sof_route *sroute;\n\tbool dyn_widgets = false;\n\tint ret;\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->dynamic_pipeline_widget) {\n\t\t\tdyn_widgets = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!verify && !swidget->dynamic_pipeline_widget &&\n\t\t    SOF_FW_VER(v->major, v->minor, v->micro) < SOF_FW_VER(2, 2, 0)) {\n\t\t\tmutex_lock(&swidget->setup_mutex);\n\t\t\tswidget->use_count = 0;\n\t\t\tmutex_unlock(&swidget->setup_mutex);\n\t\t\tif (swidget->spipe)\n\t\t\t\tswidget->spipe->complete = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = sof_widget_free(sdev, swidget);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!verify && (dyn_widgets || SOF_FW_VER(v->major, v->minor, v->micro) >=\n\t    SOF_FW_VER(2, 2, 0))) {\n\t\tret = sof_tear_down_left_over_pipelines(sdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"failed to tear down paused pipelines\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_for_each_entry(sroute, &sdev->route_list, list)\n\t\tsroute->setup = false;\n\n\t \n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (swidget->use_count != 0) {\n\t\t\tdev_err(sdev->dev, \"%s: widget %s is still in use: count %d\\n\",\n\t\t\t\t__func__, swidget->widget->name, swidget->use_count);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_dai_get_clk(struct snd_sof_dev *sdev, struct snd_sof_dai *dai, int clk_type)\n{\n\tstruct sof_dai_private_data *private = dai->private;\n\n\tif (!private || !private->dai_config)\n\t\treturn 0;\n\n\tswitch (private->dai_config->type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\tswitch (clk_type) {\n\t\tcase SOF_DAI_CLK_INTEL_SSP_MCLK:\n\t\t\treturn private->dai_config->ssp.mclk_rate;\n\t\tcase SOF_DAI_CLK_INTEL_SSP_BCLK:\n\t\t\treturn private->dai_config->ssp.bclk_rate;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tdev_err(sdev->dev, \"fail to get SSP clk %d rate\\n\", clk_type);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(sdev->dev, \"DAI type %d not supported yet!\\n\", private->dai_config->type);\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sof_ipc3_parse_manifest(struct snd_soc_component *scomp, int index,\n\t\t\t\t   struct snd_soc_tplg_manifest *man)\n{\n\tu32 size = le32_to_cpu(man->priv.size);\n\tu32 abi_version;\n\n\t \n\tif (!size) {\n\t\tdev_dbg(scomp->dev, \"No topology ABI info\\n\");\n\t\treturn 0;\n\t}\n\n\tif (size != SOF_IPC3_TPLG_ABI_SIZE) {\n\t\tdev_err(scomp->dev, \"%s: Invalid topology ABI size: %u\\n\",\n\t\t\t__func__, size);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(scomp->dev,\n\t\t \"Topology: ABI %d:%d:%d Kernel ABI %d:%d:%d\\n\",\n\t\t man->priv.data[0], man->priv.data[1], man->priv.data[2],\n\t\t SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);\n\n\tabi_version = SOF_ABI_VER(man->priv.data[0], man->priv.data[1], man->priv.data[2]);\n\n\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, abi_version)) {\n\t\tdev_err(scomp->dev, \"%s: Incompatible topology ABI version\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_STRICT_ABI_CHECKS) &&\n\t    SOF_ABI_VERSION_MINOR(abi_version) > SOF_ABI_MINOR) {\n\t\tdev_err(scomp->dev, \"%s: Topology ABI is more recent than kernel\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_link_setup(struct snd_sof_dev *sdev, struct snd_soc_dai_link *link)\n{\n\tif (link->no_pcm)\n\t\treturn 0;\n\n\t \n\tlink->trigger[SNDRV_PCM_STREAM_PLAYBACK] = SND_SOC_DPCM_TRIGGER_PRE;\n\tlink->trigger[SNDRV_PCM_STREAM_CAPTURE] = SND_SOC_DPCM_TRIGGER_POST;\n\n\treturn 0;\n}\n\n \nstatic enum sof_tokens host_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_PCM_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic enum sof_tokens comp_generic_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic enum sof_tokens buffer_token_list[] = {\n\tSOF_BUFFER_TOKENS,\n};\n\nstatic enum sof_tokens pipeline_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_PIPELINE_TOKENS,\n\tSOF_SCHED_TOKENS,\n};\n\nstatic enum sof_tokens asrc_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_ASRC_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic enum sof_tokens src_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_SRC_TOKENS,\n\tSOF_COMP_TOKENS\n};\n\nstatic enum sof_tokens pga_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_VOLUME_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic enum sof_tokens dai_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_DAI_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic enum sof_tokens process_token_list[] = {\n\tSOF_CORE_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n\tSOF_PROCESS_TOKENS,\n\tSOF_COMP_TOKENS,\n};\n\nstatic const struct sof_ipc_tplg_widget_ops tplg_ipc3_widget_ops[SND_SOC_DAPM_TYPE_COUNT] = {\n\t[snd_soc_dapm_aif_in] =  {sof_ipc3_widget_setup_comp_host, sof_ipc3_widget_free_comp,\n\t\t\t\t  host_token_list, ARRAY_SIZE(host_token_list), NULL},\n\t[snd_soc_dapm_aif_out] = {sof_ipc3_widget_setup_comp_host, sof_ipc3_widget_free_comp,\n\t\t\t\t  host_token_list, ARRAY_SIZE(host_token_list), NULL},\n\n\t[snd_soc_dapm_dai_in] = {sof_ipc3_widget_setup_comp_dai, sof_ipc3_widget_free_comp_dai,\n\t\t\t\t dai_token_list, ARRAY_SIZE(dai_token_list), NULL},\n\t[snd_soc_dapm_dai_out] = {sof_ipc3_widget_setup_comp_dai, sof_ipc3_widget_free_comp_dai,\n\t\t\t\t  dai_token_list, ARRAY_SIZE(dai_token_list), NULL},\n\t[snd_soc_dapm_buffer] = {sof_ipc3_widget_setup_comp_buffer, sof_ipc3_widget_free_comp,\n\t\t\t\t buffer_token_list, ARRAY_SIZE(buffer_token_list), NULL},\n\t[snd_soc_dapm_mixer] = {sof_ipc3_widget_setup_comp_mixer, sof_ipc3_widget_free_comp,\n\t\t\t\tcomp_generic_token_list, ARRAY_SIZE(comp_generic_token_list),\n\t\t\t\tNULL},\n\t[snd_soc_dapm_src] = {sof_ipc3_widget_setup_comp_src, sof_ipc3_widget_free_comp,\n\t\t\t      src_token_list, ARRAY_SIZE(src_token_list), NULL},\n\t[snd_soc_dapm_asrc] = {sof_ipc3_widget_setup_comp_asrc, sof_ipc3_widget_free_comp,\n\t\t\t       asrc_token_list, ARRAY_SIZE(asrc_token_list), NULL},\n\t[snd_soc_dapm_siggen] = {sof_ipc3_widget_setup_comp_tone, sof_ipc3_widget_free_comp,\n\t\t\t\t comp_generic_token_list, ARRAY_SIZE(comp_generic_token_list),\n\t\t\t\t NULL},\n\t[snd_soc_dapm_scheduler] = {sof_ipc3_widget_setup_comp_pipeline, sof_ipc3_widget_free_comp,\n\t\t\t\t    pipeline_token_list, ARRAY_SIZE(pipeline_token_list), NULL},\n\t[snd_soc_dapm_pga] = {sof_ipc3_widget_setup_comp_pga, sof_ipc3_widget_free_comp,\n\t\t\t      pga_token_list, ARRAY_SIZE(pga_token_list), NULL},\n\t[snd_soc_dapm_mux] = {sof_ipc3_widget_setup_comp_mux, sof_ipc3_widget_free_comp,\n\t\t\t      comp_generic_token_list, ARRAY_SIZE(comp_generic_token_list), NULL},\n\t[snd_soc_dapm_demux] = {sof_ipc3_widget_setup_comp_mux, sof_ipc3_widget_free_comp,\n\t\t\t\t comp_generic_token_list, ARRAY_SIZE(comp_generic_token_list),\n\t\t\t\t NULL},\n\t[snd_soc_dapm_effect] = {sof_widget_update_ipc_comp_process, sof_ipc3_widget_free_comp,\n\t\t\t\t process_token_list, ARRAY_SIZE(process_token_list),\n\t\t\t\t sof_ipc3_widget_bind_event},\n};\n\nconst struct sof_ipc_tplg_ops ipc3_tplg_ops = {\n\t.widget = tplg_ipc3_widget_ops,\n\t.control = &tplg_ipc3_control_ops,\n\t.route_setup = sof_ipc3_route_setup,\n\t.control_setup = sof_ipc3_control_setup,\n\t.control_free = sof_ipc3_control_free,\n\t.pipeline_complete = sof_ipc3_complete_pipeline,\n\t.token_list = ipc3_token_list,\n\t.widget_free = sof_ipc3_widget_free,\n\t.widget_setup = sof_ipc3_widget_setup,\n\t.dai_config = sof_ipc3_dai_config,\n\t.dai_get_clk = sof_ipc3_dai_get_clk,\n\t.set_up_all_pipelines = sof_ipc3_set_up_all_pipelines,\n\t.tear_down_all_pipelines = sof_ipc3_tear_down_all_pipelines,\n\t.parse_manifest = sof_ipc3_parse_manifest,\n\t.link_setup = sof_ipc3_link_setup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}