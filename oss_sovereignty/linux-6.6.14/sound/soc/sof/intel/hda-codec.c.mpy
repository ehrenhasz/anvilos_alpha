{
  "module_name": "hda-codec.c",
  "hash_id": "6c75a676ca1f4af0f938bed73143cbafe163a5f51f0e25137cdb33ffa7fc26ad",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-codec.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_i915.h>\n#include <sound/sof.h>\n#include \"../ops.h\"\n#include \"hda.h\"\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC)\n#include \"../../codecs/hdac_hda.h\"\n\n#define CODEC_PROBE_RETRIES\t3\n\n#define IDISP_VID_INTEL\t0x80860000\n\nstatic int hda_codec_mask = -1;\nmodule_param_named(codec_mask, hda_codec_mask, int, 0444);\nMODULE_PARM_DESC(codec_mask, \"SOF HDA codec mask for probing\");\n\n \nstatic int request_codec_module(struct hda_codec *codec)\n{\n#ifdef MODULE\n\tchar alias[MODULE_NAME_LEN];\n\tconst char *mod = NULL;\n\n\tswitch (codec->probe_id) {\n\tcase HDA_CODEC_ID_GENERIC:\n#if IS_MODULE(CONFIG_SND_HDA_GENERIC)\n\t\tmod = \"snd-hda-codec-generic\";\n#endif\n\t\tbreak;\n\tdefault:\n\t\tsnd_hdac_codec_modalias(&codec->core, alias, sizeof(alias));\n\t\tmod = alias;\n\t\tbreak;\n\t}\n\n\tif (mod) {\n\t\tdev_dbg(&codec->core.dev, \"loading codec module: %s\\n\", mod);\n\t\trequest_module(mod);\n\t}\n#endif  \n\treturn device_attach(hda_codec_dev(codec));\n}\n\nstatic int hda_codec_load_module(struct hda_codec *codec)\n{\n\tint ret;\n\n\tret = snd_hdac_device_register(&codec->core);\n\tif (ret) {\n\t\tdev_err(&codec->core.dev, \"failed to register hdac device\\n\");\n\t\tput_device(&codec->core.dev);\n\t\treturn ret;\n\t}\n\n\tret = request_codec_module(codec);\n\tif (ret <= 0) {\n\t\tcodec->probe_id = HDA_CODEC_ID_GENERIC;\n\t\tret = request_codec_module(codec);\n\t}\n\n\treturn ret;\n}\n\n \nvoid hda_codec_jack_wake_enable(struct snd_sof_dev *sdev, bool enable)\n{\n\tstruct hda_bus *hbus = sof_to_hbus(sdev);\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hda_codec *codec;\n\tunsigned int mask = 0;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\tif (enable) {\n\t\tlist_for_each_codec(codec, hbus)\n\t\t\tif (codec->jacktbl.used)\n\t\t\t\tmask |= BIT(codec->core.addr);\n\t}\n\n\tsnd_hdac_chip_updatew(bus, WAKEEN, STATESTS_INT_MASK, mask);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_jack_wake_enable, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\n \nvoid hda_codec_jack_check(struct snd_sof_dev *sdev)\n{\n\tstruct hda_bus *hbus = sof_to_hbus(sdev);\n\tstruct hda_codec *codec;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\tlist_for_each_codec(codec, hbus)\n\t\t \n\t\tif (codec->jacktbl.used)\n\t\t\tpm_request_resume(&codec->core.dev);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_jack_check, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\n#if IS_ENABLED(CONFIG_SND_HDA_GENERIC)\n#define is_generic_config(bus) \\\n\t((bus)->modelname && !strcmp((bus)->modelname, \"generic\"))\n#else\n#define is_generic_config(x)\t0\n#endif\n\nstatic struct hda_codec *hda_codec_device_init(struct hdac_bus *bus, int addr, int type)\n{\n\tstruct hda_codec *codec;\n\n\tcodec = snd_hda_codec_device_init(to_hda_bus(bus), addr, \"ehdaudio%dD%d\", bus->idx, addr);\n\tif (IS_ERR(codec)) {\n\t\tdev_err(bus->dev, \"device init failed for hdac device\\n\");\n\t\treturn codec;\n\t}\n\n\tcodec->core.type = type;\n\n\treturn codec;\n}\n\n \nstatic int hda_codec_probe(struct snd_sof_dev *sdev, int address)\n{\n\tstruct hdac_hda_priv *hda_priv;\n\tstruct hda_bus *hbus = sof_to_hbus(sdev);\n\tstruct hda_codec *codec;\n\tu32 hda_cmd = (address << 28) | (AC_NODE_ROOT << 20) |\n\t\t(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;\n\tu32 resp = -1;\n\tint ret, retry = 0;\n\n\tdo {\n\t\tmutex_lock(&hbus->core.cmd_mutex);\n\t\tsnd_hdac_bus_send_cmd(&hbus->core, hda_cmd);\n\t\tsnd_hdac_bus_get_response(&hbus->core, address, &resp);\n\t\tmutex_unlock(&hbus->core.cmd_mutex);\n\t} while (resp == -1 && retry++ < CODEC_PROBE_RETRIES);\n\n\tif (resp == -1)\n\t\treturn -EIO;\n\tdev_dbg(sdev->dev, \"HDA codec #%d probed OK: response: %x\\n\",\n\t\taddress, resp);\n\n\thda_priv = devm_kzalloc(sdev->dev, sizeof(*hda_priv), GFP_KERNEL);\n\tif (!hda_priv)\n\t\treturn -ENOMEM;\n\n\tcodec = hda_codec_device_init(&hbus->core, address, HDA_DEV_LEGACY);\n\tret = PTR_ERR_OR_ZERO(codec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thda_priv->codec = codec;\n\tdev_set_drvdata(&codec->core.dev, hda_priv);\n\n\tif ((resp & 0xFFFF0000) == IDISP_VID_INTEL) {\n\t\tif (!hbus->core.audio_component) {\n\t\t\tdev_dbg(sdev->dev,\n\t\t\t\t\"iDisp hw present but no driver\\n\");\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\thda_priv->need_display_power = true;\n\t}\n\n\tif (is_generic_config(hbus))\n\t\tcodec->probe_id = HDA_CODEC_ID_GENERIC;\n\telse\n\t\tcodec->probe_id = 0;\n\n\tret = hda_codec_load_module(codec);\n\t \n\tif (ret == 0)\n\t\tret = -ENOENT;\n\nout:\n\tif (ret < 0) {\n\t\tsnd_hdac_device_unregister(&codec->core);\n\t\tput_device(&codec->core.dev);\n\t}\n\n\treturn ret;\n}\n\n \nvoid hda_codec_probe_bus(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tint i, ret;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < HDA_MAX_CODECS; i++) {\n\n\t\tif (!(bus->codec_mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = hda_codec_probe(sdev, i);\n\t\tif (ret < 0) {\n\t\t\tdev_warn(bus->dev, \"codec #%d probe error, ret: %d\\n\",\n\t\t\t\t i, ret);\n\t\t\tbus->codec_mask &= ~BIT(i);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_probe_bus, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_check_for_state_change(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tunsigned int codec_mask;\n\n\tcodec_mask = snd_hdac_chip_readw(bus, STATESTS);\n\tif (codec_mask) {\n\t\thda_codec_jack_check(sdev);\n\t\tsnd_hdac_chip_writew(bus, STATESTS, codec_mask);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_check_for_state_change, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_detect_mask(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tsnd_hdac_chip_updatel(bus, GCTL, AZX_GCTL_UNSOL, AZX_GCTL_UNSOL);\n\n\t \n\tif (!bus->codec_mask) {\n\t\tbus->codec_mask = snd_hdac_chip_readw(bus, STATESTS);\n\t\tdev_dbg(bus->dev, \"codec_mask = 0x%lx\\n\", bus->codec_mask);\n\t}\n\n\tif (hda_codec_mask != -1) {\n\t\tbus->codec_mask &= hda_codec_mask;\n\t\tdev_dbg(bus->dev, \"filtered codec_mask = 0x%lx\\n\",\n\t\t\tbus->codec_mask);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_detect_mask, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_init_cmd_io(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tsnd_hdac_bus_init_cmd_io(bus);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_init_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_resume_cmd_io(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tif (bus->cmd_dma_state)\n\t\tsnd_hdac_bus_init_cmd_io(bus);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_resume_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_stop_cmd_io(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tsnd_hdac_bus_stop_cmd_io(bus);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_stop_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_suspend_cmd_io(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tif (bus->cmd_dma_state)\n\t\tsnd_hdac_bus_stop_cmd_io(bus);\n\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_suspend_cmd_io, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_rirb_status_clear(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tsnd_hdac_chip_writeb(bus, RIRBSTS, RIRB_INT_MASK);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_rirb_status_clear, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_set_codec_wakeup(struct snd_sof_dev *sdev, bool status)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\tsnd_hdac_set_codec_wakeup(bus, status);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_set_codec_wakeup, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nbool hda_codec_check_rirb_status(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tbool active = false;\n\tu32 rirb_status;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn false;\n\n\trirb_status = snd_hdac_chip_readb(bus, RIRBSTS);\n\tif (rirb_status & RIRB_INT_MASK) {\n\t\t \n\t\tsnd_hdac_chip_writeb(bus, RIRBSTS,\n\t\t\t\t     RIRB_INT_MASK);\n\t\tactive = true;\n\t\tif (rirb_status & RIRB_INT_RESPONSE)\n\t\t\tsnd_hdac_bus_update_rirb(bus);\n\t}\n\treturn active;\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_check_rirb_status, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\nvoid hda_codec_device_remove(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\t \n\tsnd_hdac_ext_bus_device_remove(bus);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_device_remove, SND_SOC_SOF_HDA_AUDIO_CODEC);\n\n#endif  \n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC) && IS_ENABLED(CONFIG_SND_HDA_CODEC_HDMI)\n\nvoid hda_codec_i915_display_power(struct snd_sof_dev *sdev, bool enable)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn;\n\n\tif (HDA_IDISP_CODEC(bus->codec_mask)) {\n\t\tdev_dbg(bus->dev, \"Turning i915 HDAC power %d\\n\", enable);\n\t\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, enable);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_i915_display_power, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);\n\nint hda_codec_i915_init(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tint ret;\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn 0;\n\n\t \n\tret = snd_hdac_i915_init(bus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_i915_init, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);\n\nint hda_codec_i915_exit(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\treturn 0;\n\n\tif (!bus->audio_component)\n\t\treturn 0;\n\n\t \n\tsnd_hdac_display_power(bus, HDA_CODEC_IDX_CONTROLLER, false);\n\n\treturn snd_hdac_i915_exit(bus);\n}\nEXPORT_SYMBOL_NS_GPL(hda_codec_i915_exit, SND_SOC_SOF_HDA_AUDIO_CODEC_I915);\n\n#endif\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}