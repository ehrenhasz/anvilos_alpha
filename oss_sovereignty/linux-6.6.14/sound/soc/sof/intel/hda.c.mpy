{
  "module_name": "hda.c",
  "hash_id": "ed3cae5664a53d1e65be7d21c505c8b626d68b3be44ada26283719c03400c2ed",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_intel.h>\n#include <sound/intel-dsp-config.h>\n#include <sound/intel-nhlt.h>\n#include <sound/sof.h>\n#include <sound/sof/xtensa.h>\n#include <sound/hda-mlink.h>\n#include \"../sof-audio.h\"\n#include \"../sof-pci-dev.h\"\n#include \"../ops.h\"\n#include \"hda.h\"\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/sof_intel.h>\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)\n#include <sound/soc-acpi-intel-match.h>\n#endif\n\n \n#include \"shim.h\"\n\n#define EXCEPT_MAX_HDR_SIZE\t0x400\n#define HDA_EXT_ROM_STATUS_SIZE 8\n\nstatic u32 hda_get_interface_mask(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\tu32 interface_mask[2] = { 0 };\n\n\tchip = get_chip_info(sdev->pdata);\n\tswitch (chip->hw_ip_version) {\n\tcase SOF_INTEL_TANGIER:\n\tcase SOF_INTEL_BAYTRAIL:\n\tcase SOF_INTEL_BROADWELL:\n\t\tinterface_mask[0] =  BIT(SOF_DAI_INTEL_SSP);\n\t\tbreak;\n\tcase SOF_INTEL_CAVS_1_5:\n\tcase SOF_INTEL_CAVS_1_5_PLUS:\n\t\tinterface_mask[0] = BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC) |\n\t\t\t\t    BIT(SOF_DAI_INTEL_HDA);\n\t\tinterface_mask[1] = BIT(SOF_DAI_INTEL_HDA);\n\t\tbreak;\n\tcase SOF_INTEL_CAVS_1_8:\n\tcase SOF_INTEL_CAVS_2_0:\n\tcase SOF_INTEL_CAVS_2_5:\n\tcase SOF_INTEL_ACE_1_0:\n\t\tinterface_mask[0] = BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC) |\n\t\t\t\t    BIT(SOF_DAI_INTEL_HDA) | BIT(SOF_DAI_INTEL_ALH);\n\t\tinterface_mask[1] = BIT(SOF_DAI_INTEL_HDA);\n\t\tbreak;\n\tcase SOF_INTEL_ACE_2_0:\n\t\tinterface_mask[0] = BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC) |\n\t\t\t\t    BIT(SOF_DAI_INTEL_HDA) | BIT(SOF_DAI_INTEL_ALH);\n\t\tinterface_mask[1] = interface_mask[0];  \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn interface_mask[sdev->dspless_mode_selected];\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)\n\n \nstatic int sdw_clock_stop_quirks = SDW_INTEL_CLK_STOP_BUS_RESET;\nmodule_param(sdw_clock_stop_quirks, int, 0444);\nMODULE_PARM_DESC(sdw_clock_stop_quirks, \"SOF SoundWire clock stop quirks\");\n\nstatic int sdw_params_stream(struct device *dev,\n\t\t\t     struct sdw_intel_stream_params_data *params_data)\n{\n\tstruct snd_soc_dai *d = params_data->dai;\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(d, params_data->substream->stream);\n\tstruct snd_sof_dai_config_data data = { 0 };\n\n\tdata.dai_index = (params_data->link_id << 8) | d->id;\n\tdata.dai_data = params_data->alh_stream_id;\n\n\treturn hda_dai_config(w, SOF_DAI_CONFIG_FLAGS_HW_PARAMS, &data);\n}\n\nstruct sdw_intel_ops sdw_callback = {\n\t.params_stream = sdw_params_stream,\n};\n\nstatic int sdw_ace2x_params_stream(struct device *dev,\n\t\t\t\t   struct sdw_intel_stream_params_data *params_data)\n{\n\treturn sdw_hda_dai_hw_params(params_data->substream,\n\t\t\t\t     params_data->hw_params,\n\t\t\t\t     params_data->dai,\n\t\t\t\t     params_data->link_id);\n}\n\nstatic int sdw_ace2x_free_stream(struct device *dev,\n\t\t\t\t struct sdw_intel_stream_free_data *free_data)\n{\n\treturn sdw_hda_dai_hw_free(free_data->substream,\n\t\t\t\t   free_data->dai,\n\t\t\t\t   free_data->link_id);\n}\n\nstatic int sdw_ace2x_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\treturn sdw_hda_dai_trigger(substream, cmd, dai);\n}\n\nstatic struct sdw_intel_ops sdw_ace2x_callback = {\n\t.params_stream = sdw_ace2x_params_stream,\n\t.free_stream = sdw_ace2x_free_stream,\n\t.trigger = sdw_ace2x_trigger,\n};\n\nvoid hda_common_enable_sdw_irq(struct snd_sof_dev *sdev, bool enable)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\n\thdev = sdev->pdata->hw_pdata;\n\n\tif (!hdev->sdw)\n\t\treturn;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIC2,\n\t\t\t\tHDA_DSP_REG_ADSPIC2_SNDW,\n\t\t\t\tenable ? HDA_DSP_REG_ADSPIC2_SNDW : 0);\n}\n\nvoid hda_sdw_int_enable(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\treturn;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip && chip->enable_sdw_irq)\n\t\tchip->enable_sdw_irq(sdev, enable);\n}\n\nstatic int hda_sdw_acpi_scan(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tstruct sof_intel_hda_dev *hdev;\n\tacpi_handle handle;\n\tint ret;\n\n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\treturn -EINVAL;\n\n\thandle = ACPI_HANDLE(sdev->dev);\n\n\t \n\thdev = sdev->pdata->hw_pdata;\n\n\tret = sdw_intel_acpi_scan(handle, &hdev->info);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hda_sdw_probe(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\tstruct sof_intel_hda_dev *hdev;\n\tstruct sdw_intel_res res;\n\tvoid *sdw;\n\n\thdev = sdev->pdata->hw_pdata;\n\n\tmemset(&res, 0, sizeof(res));\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip->hw_ip_version < SOF_INTEL_ACE_2_0) {\n\t\tres.mmio_base = sdev->bar[HDA_DSP_BAR];\n\t\tres.hw_ops = &sdw_intel_cnl_hw_ops;\n\t\tres.shim_base = hdev->desc->sdw_shim_base;\n\t\tres.alh_base = hdev->desc->sdw_alh_base;\n\t\tres.ext = false;\n\t\tres.ops = &sdw_callback;\n\t} else {\n\t\t \n\t\tres.eml_lock = hdac_bus_eml_get_mutex(sof_to_bus(sdev), true,\n\t\t\t\t\t\t      AZX_REG_ML_LEPTR_ID_SDW);\n\t\tif (!res.eml_lock)\n\t\t\treturn -ENODEV;\n\n\t\tres.mmio_base = sdev->bar[HDA_DSP_HDA_BAR];\n\t\t \n\t\tres.hw_ops = &sdw_intel_lnl_hw_ops;\n\t\tres.ext = true;\n\t\tres.ops = &sdw_ace2x_callback;\n\n\t}\n\tres.irq = sdev->ipc_irq;\n\tres.handle = hdev->info.handle;\n\tres.parent = sdev->dev;\n\n\tres.dev = sdev->dev;\n\tres.clock_stop_quirks = sdw_clock_stop_quirks;\n\tres.hbus = sof_to_bus(sdev);\n\n\t \n\n\t \n\tres.count = hdev->info.count;\n\tres.link_mask = hdev->info.link_mask;\n\n\tsdw = sdw_intel_probe(&res);\n\tif (!sdw) {\n\t\tdev_err(sdev->dev, \"error: SoundWire probe failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thdev->sdw = sdw;\n\n\treturn 0;\n}\n\nint hda_sdw_check_lcount_common(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\tstruct sdw_intel_ctx *ctx;\n\tu32 caps;\n\n\thdev = sdev->pdata->hw_pdata;\n\tctx = hdev->sdw;\n\n\tcaps = snd_sof_dsp_read(sdev, HDA_DSP_BAR, ctx->shim_base + SDW_SHIM_LCAP);\n\tcaps &= SDW_SHIM_LCAP_LCOUNT_MASK;\n\n\t \n\tif (caps < ctx->count) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: BIOS master count %d is larger than hardware capabilities %d\\n\",\n\t\t\t__func__, ctx->count, caps);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hda_sdw_check_lcount_ext(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\tstruct sdw_intel_ctx *ctx;\n\tstruct hdac_bus *bus;\n\tu32 slcount;\n\n\tbus = sof_to_bus(sdev);\n\n\thdev = sdev->pdata->hw_pdata;\n\tctx = hdev->sdw;\n\n\tslcount = hdac_bus_eml_get_count(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n\n\t \n\tif (slcount < ctx->count) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: BIOS master count %d is larger than hardware capabilities %d\\n\",\n\t\t\t__func__, ctx->count, slcount);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hda_sdw_check_lcount(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip && chip->read_sdw_lcount)\n\t\treturn chip->read_sdw_lcount(sdev);\n\n\treturn 0;\n}\n\nint hda_sdw_startup(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tint ret;\n\n\thdev = sdev->pdata->hw_pdata;\n\n\tif (!hdev->sdw)\n\t\treturn 0;\n\n\tif (pdata->machine && !pdata->machine->mach_params.link_mask)\n\t\treturn 0;\n\n\tret = hda_sdw_check_lcount(sdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sdw_intel_startup(hdev->sdw);\n}\n\nstatic int hda_sdw_exit(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\n\thdev = sdev->pdata->hw_pdata;\n\n\thda_sdw_int_enable(sdev, false);\n\n\tif (hdev->sdw)\n\t\tsdw_intel_exit(hdev->sdw);\n\thdev->sdw = NULL;\n\n\treturn 0;\n}\n\nbool hda_common_check_sdw_irq(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\tbool ret = false;\n\tu32 irq_status;\n\n\thdev = sdev->pdata->hw_pdata;\n\n\tif (!hdev->sdw)\n\t\treturn ret;\n\n\t \n\tirq_status = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIS2);\n\n\t \n\tif (irq_status == 0xffffffff)\n\t\tgoto out;\n\n\t \n\tif (irq_status & HDA_DSP_REG_ADSPIS2_SNDW)\n\t\tret = true;\n\nout:\n\treturn ret;\n}\n\nstatic bool hda_dsp_check_sdw_irq(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\treturn false;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip && chip->check_sdw_irq)\n\t\treturn chip->check_sdw_irq(sdev);\n\n\treturn false;\n}\n\nstatic irqreturn_t hda_dsp_sdw_thread(int irq, void *context)\n{\n\treturn sdw_intel_thread(irq, context);\n}\n\nbool hda_sdw_check_wakeen_irq_common(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev;\n\n\thdev = sdev->pdata->hw_pdata;\n\tif (hdev->sdw &&\n\t    snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t     hdev->desc->sdw_shim_base + SDW_SHIM_WAKESTS))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool hda_sdw_check_wakeen_irq(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\treturn false;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip && chip->check_sdw_wakeen_irq)\n\t\treturn chip->check_sdw_wakeen_irq(sdev);\n\n\treturn false;\n}\n\nvoid hda_sdw_process_wakeen(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tstruct sof_intel_hda_dev *hdev;\n\n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\treturn;\n\n\thdev = sdev->pdata->hw_pdata;\n\tif (!hdev->sdw)\n\t\treturn;\n\n\tsdw_intel_process_wakeen_event(hdev->sdw);\n}\n\n#else  \nstatic inline int hda_sdw_acpi_scan(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline int hda_sdw_probe(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline int hda_sdw_exit(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline bool hda_dsp_check_sdw_irq(struct snd_sof_dev *sdev)\n{\n\treturn false;\n}\n\nstatic inline irqreturn_t hda_dsp_sdw_thread(int irq, void *context)\n{\n\treturn IRQ_HANDLED;\n}\n\nstatic inline bool hda_sdw_check_wakeen_irq(struct snd_sof_dev *sdev)\n{\n\treturn false;\n}\n\n#endif  \n\n \n\nstruct hda_dsp_msg_code {\n\tu32 code;\n\tconst char *text;\n};\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG)\nstatic bool hda_use_msi = true;\nmodule_param_named(use_msi, hda_use_msi, bool, 0444);\nMODULE_PARM_DESC(use_msi, \"SOF HDA use PCI MSI mode\");\n#else\n#define hda_use_msi\t(1)\n#endif\n\nint sof_hda_position_quirk = SOF_HDA_POSITION_QUIRK_USE_DPIB_REGISTERS;\nmodule_param_named(position_quirk, sof_hda_position_quirk, int, 0444);\nMODULE_PARM_DESC(position_quirk, \"SOF HDaudio position quirk\");\n\nstatic char *hda_model;\nmodule_param(hda_model, charp, 0444);\nMODULE_PARM_DESC(hda_model, \"Use the given HDA board model.\");\n\nstatic int dmic_num_override = -1;\nmodule_param_named(dmic_num, dmic_num_override, int, 0444);\nMODULE_PARM_DESC(dmic_num, \"SOF HDA DMIC number\");\n\nstatic int mclk_id_override = -1;\nmodule_param_named(mclk_id, mclk_id_override, int, 0444);\nMODULE_PARM_DESC(mclk_id, \"SOF SSP mclk_id\");\n\nstatic const struct hda_dsp_msg_code hda_dsp_rom_fw_error_texts[] = {\n\t{HDA_DSP_ROM_CSE_ERROR, \"error: cse error\"},\n\t{HDA_DSP_ROM_CSE_WRONG_RESPONSE, \"error: cse wrong response\"},\n\t{HDA_DSP_ROM_IMR_TO_SMALL, \"error: IMR too small\"},\n\t{HDA_DSP_ROM_BASE_FW_NOT_FOUND, \"error: base fw not found\"},\n\t{HDA_DSP_ROM_CSE_VALIDATION_FAILED, \"error: signature verification failed\"},\n\t{HDA_DSP_ROM_IPC_FATAL_ERROR, \"error: ipc fatal error\"},\n\t{HDA_DSP_ROM_L2_CACHE_ERROR, \"error: L2 cache error\"},\n\t{HDA_DSP_ROM_LOAD_OFFSET_TO_SMALL, \"error: load offset too small\"},\n\t{HDA_DSP_ROM_API_PTR_INVALID, \"error: API ptr invalid\"},\n\t{HDA_DSP_ROM_BASEFW_INCOMPAT, \"error: base fw incompatible\"},\n\t{HDA_DSP_ROM_UNHANDLED_INTERRUPT, \"error: unhandled interrupt\"},\n\t{HDA_DSP_ROM_MEMORY_HOLE_ECC, \"error: ECC memory hole\"},\n\t{HDA_DSP_ROM_KERNEL_EXCEPTION, \"error: kernel exception\"},\n\t{HDA_DSP_ROM_USER_EXCEPTION, \"error: user exception\"},\n\t{HDA_DSP_ROM_UNEXPECTED_RESET, \"error: unexpected reset\"},\n\t{HDA_DSP_ROM_NULL_FW_ENTRY,\t\"error: null FW entry point\"},\n};\n\n#define FSR_ROM_STATE_ENTRY(state)\t{FSR_STATE_ROM_##state, #state}\nstatic const struct hda_dsp_msg_code fsr_rom_state_names[] = {\n\tFSR_ROM_STATE_ENTRY(INIT),\n\tFSR_ROM_STATE_ENTRY(INIT_DONE),\n\tFSR_ROM_STATE_ENTRY(CSE_MANIFEST_LOADED),\n\tFSR_ROM_STATE_ENTRY(FW_MANIFEST_LOADED),\n\tFSR_ROM_STATE_ENTRY(FW_FW_LOADED),\n\tFSR_ROM_STATE_ENTRY(FW_ENTERED),\n\tFSR_ROM_STATE_ENTRY(VERIFY_FEATURE_MASK),\n\tFSR_ROM_STATE_ENTRY(GET_LOAD_OFFSET),\n\tFSR_ROM_STATE_ENTRY(FETCH_ROM_EXT),\n\tFSR_ROM_STATE_ENTRY(FETCH_ROM_EXT_DONE),\n\t \n\tFSR_ROM_STATE_ENTRY(CSE_IMR_REQUEST),\n\tFSR_ROM_STATE_ENTRY(CSE_IMR_GRANTED),\n\tFSR_ROM_STATE_ENTRY(CSE_VALIDATE_IMAGE_REQUEST),\n\tFSR_ROM_STATE_ENTRY(CSE_IMAGE_VALIDATED),\n\tFSR_ROM_STATE_ENTRY(CSE_IPC_IFACE_INIT),\n\tFSR_ROM_STATE_ENTRY(CSE_IPC_RESET_PHASE_1),\n\tFSR_ROM_STATE_ENTRY(CSE_IPC_OPERATIONAL_ENTRY),\n\tFSR_ROM_STATE_ENTRY(CSE_IPC_OPERATIONAL),\n\tFSR_ROM_STATE_ENTRY(CSE_IPC_DOWN),\n};\n\n#define FSR_BRINGUP_STATE_ENTRY(state)\t{FSR_STATE_BRINGUP_##state, #state}\nstatic const struct hda_dsp_msg_code fsr_bringup_state_names[] = {\n\tFSR_BRINGUP_STATE_ENTRY(INIT),\n\tFSR_BRINGUP_STATE_ENTRY(INIT_DONE),\n\tFSR_BRINGUP_STATE_ENTRY(HPSRAM_LOAD),\n\tFSR_BRINGUP_STATE_ENTRY(UNPACK_START),\n\tFSR_BRINGUP_STATE_ENTRY(IMR_RESTORE),\n\tFSR_BRINGUP_STATE_ENTRY(FW_ENTERED),\n};\n\n#define FSR_WAIT_STATE_ENTRY(state)\t{FSR_WAIT_FOR_##state, #state}\nstatic const struct hda_dsp_msg_code fsr_wait_state_names[] = {\n\tFSR_WAIT_STATE_ENTRY(IPC_BUSY),\n\tFSR_WAIT_STATE_ENTRY(IPC_DONE),\n\tFSR_WAIT_STATE_ENTRY(CACHE_INVALIDATION),\n\tFSR_WAIT_STATE_ENTRY(LP_SRAM_OFF),\n\tFSR_WAIT_STATE_ENTRY(DMA_BUFFER_FULL),\n\tFSR_WAIT_STATE_ENTRY(CSE_CSR),\n};\n\n#define FSR_MODULE_NAME_ENTRY(mod)\t[FSR_MOD_##mod] = #mod\nstatic const char * const fsr_module_names[] = {\n\tFSR_MODULE_NAME_ENTRY(ROM),\n\tFSR_MODULE_NAME_ENTRY(ROM_BYP),\n\tFSR_MODULE_NAME_ENTRY(BASE_FW),\n\tFSR_MODULE_NAME_ENTRY(LP_BOOT),\n\tFSR_MODULE_NAME_ENTRY(BRNGUP),\n\tFSR_MODULE_NAME_ENTRY(ROM_EXT),\n};\n\nstatic const char *\nhda_dsp_get_state_text(u32 code, const struct hda_dsp_msg_code *msg_code,\n\t\t       size_t array_size)\n{\n\tint i;\n\n\tfor (i = 0; i < array_size; i++) {\n\t\tif (code == msg_code[i].code)\n\t\t\treturn msg_code[i].text;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hda_dsp_get_state(struct snd_sof_dev *sdev, const char *level)\n{\n\tconst struct sof_intel_dsp_desc *chip = get_chip_info(sdev->pdata);\n\tconst char *state_text, *error_text, *module_text;\n\tu32 fsr, state, wait_state, module, error_code;\n\n\tfsr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->rom_status_reg);\n\tstate = FSR_TO_STATE_CODE(fsr);\n\twait_state = FSR_TO_WAIT_STATE_CODE(fsr);\n\tmodule = FSR_TO_MODULE_CODE(fsr);\n\n\tif (module > FSR_MOD_ROM_EXT)\n\t\tmodule_text = \"unknown\";\n\telse\n\t\tmodule_text = fsr_module_names[module];\n\n\tif (module == FSR_MOD_BRNGUP)\n\t\tstate_text = hda_dsp_get_state_text(state, fsr_bringup_state_names,\n\t\t\t\t\t\t    ARRAY_SIZE(fsr_bringup_state_names));\n\telse\n\t\tstate_text = hda_dsp_get_state_text(state, fsr_rom_state_names,\n\t\t\t\t\t\t    ARRAY_SIZE(fsr_rom_state_names));\n\n\t \n\tif (!state_text) {\n\t\tdev_printk(level, sdev->dev, \"%#010x: unknown ROM status value\\n\", fsr);\n\t\treturn;\n\t}\n\n\tif (wait_state) {\n\t\tconst char *wait_state_text;\n\n\t\twait_state_text = hda_dsp_get_state_text(wait_state, fsr_wait_state_names,\n\t\t\t\t\t\t\t ARRAY_SIZE(fsr_wait_state_names));\n\t\tif (!wait_state_text)\n\t\t\twait_state_text = \"unknown\";\n\n\t\tdev_printk(level, sdev->dev,\n\t\t\t   \"%#010x: module: %s, state: %s, waiting for: %s, %s\\n\",\n\t\t\t   fsr, module_text, state_text, wait_state_text,\n\t\t\t   fsr & FSR_HALTED ? \"not running\" : \"running\");\n\t} else {\n\t\tdev_printk(level, sdev->dev, \"%#010x: module: %s, state: %s, %s\\n\",\n\t\t\t   fsr, module_text, state_text,\n\t\t\t   fsr & FSR_HALTED ? \"not running\" : \"running\");\n\t}\n\n\terror_code = snd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->rom_status_reg + 4);\n\tif (!error_code)\n\t\treturn;\n\n\terror_text = hda_dsp_get_state_text(error_code, hda_dsp_rom_fw_error_texts,\n\t\t\t\t\t    ARRAY_SIZE(hda_dsp_rom_fw_error_texts));\n\tif (!error_text)\n\t\terror_text = \"unknown\";\n\n\tif (state == FSR_STATE_FW_ENTERED)\n\t\tdev_printk(level, sdev->dev, \"status code: %#x (%s)\\n\", error_code,\n\t\t\t   error_text);\n\telse\n\t\tdev_printk(level, sdev->dev, \"error code: %#x (%s)\\n\", error_code,\n\t\t\t   error_text);\n}\n\nstatic void hda_dsp_get_registers(struct snd_sof_dev *sdev,\n\t\t\t\t  struct sof_ipc_dsp_oops_xtensa *xoops,\n\t\t\t\t  struct sof_ipc_panic_info *panic_info,\n\t\t\t\t  u32 *stack, size_t stack_words)\n{\n\tu32 offset = sdev->dsp_oops_offset;\n\n\t \n\tsof_mailbox_read(sdev, offset, xoops, sizeof(*xoops));\n\n\t \n\n\t \n\tif (xoops->arch_hdr.totalsize > EXCEPT_MAX_HDR_SIZE) {\n\t\tdev_err(sdev->dev, \"invalid header size 0x%x. FW oops is bogus\\n\",\n\t\t\txoops->arch_hdr.totalsize);\n\t\treturn;\n\t}\n\toffset += xoops->arch_hdr.totalsize;\n\tsof_block_read(sdev, sdev->mmio_bar, offset,\n\t\t       panic_info, sizeof(*panic_info));\n\n\t \n\toffset += sizeof(*panic_info);\n\tsof_block_read(sdev, sdev->mmio_bar, offset, stack,\n\t\t       stack_words * sizeof(u32));\n}\n\n \nstatic void hda_dsp_dump_ext_rom_status(struct snd_sof_dev *sdev, const char *level,\n\t\t\t\t\tu32 flags)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\tchar msg[128];\n\tint len = 0;\n\tu32 value;\n\tint i;\n\n\tchip = get_chip_info(sdev->pdata);\n\tfor (i = 0; i < HDA_EXT_ROM_STATUS_SIZE; i++) {\n\t\tvalue = snd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->rom_status_reg + i * 0x4);\n\t\tlen += scnprintf(msg + len, sizeof(msg) - len, \" 0x%x\", value);\n\t}\n\n\tdev_printk(level, sdev->dev, \"extended rom status: %s\", msg);\n\n}\n\nvoid hda_dsp_dump(struct snd_sof_dev *sdev, u32 flags)\n{\n\tchar *level = (flags & SOF_DBG_DUMP_OPTIONAL) ? KERN_DEBUG : KERN_ERR;\n\tstruct sof_ipc_dsp_oops_xtensa xoops;\n\tstruct sof_ipc_panic_info panic_info;\n\tu32 stack[HDA_DSP_STACK_DUMP_SIZE];\n\n\t \n\thda_dsp_get_state(sdev, level);\n\n\t \n\tif (flags & SOF_DBG_DUMP_REGS && sdev->pdata->ipc_type == SOF_IPC) {\n\t\tu32 status = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_SRAM_REG_FW_STATUS);\n\t\tu32 panic = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_SRAM_REG_FW_TRACEP);\n\n\t\thda_dsp_get_registers(sdev, &xoops, &panic_info, stack,\n\t\t\t\t      HDA_DSP_STACK_DUMP_SIZE);\n\t\tsof_print_oops_and_stack(sdev, level, status, panic, &xoops,\n\t\t\t\t\t &panic_info, stack, HDA_DSP_STACK_DUMP_SIZE);\n\t} else {\n\t\thda_dsp_dump_ext_rom_status(sdev, level, flags);\n\t}\n}\n\nstatic bool hda_check_ipc_irq(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (chip && chip->check_ipc_irq)\n\t\treturn chip->check_ipc_irq(sdev);\n\n\treturn false;\n}\n\nvoid hda_ipc_irq_dump(struct snd_sof_dev *sdev)\n{\n\tu32 adspis;\n\tu32 intsts;\n\tu32 intctl;\n\tu32 ppsts;\n\tu8 rirbsts;\n\n\t \n\tadspis = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIS);\n\tintsts = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS);\n\tintctl = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL);\n\tppsts = snd_sof_dsp_read(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPSTS);\n\trirbsts = snd_sof_dsp_read8(sdev, HDA_DSP_HDA_BAR, AZX_REG_RIRBSTS);\n\n\tdev_err(sdev->dev, \"hda irq intsts 0x%8.8x intlctl 0x%8.8x rirb %2.2x\\n\",\n\t\tintsts, intctl, rirbsts);\n\tdev_err(sdev->dev, \"dsp irq ppsts 0x%8.8x adspis 0x%8.8x\\n\", ppsts, adspis);\n}\n\nvoid hda_ipc_dump(struct snd_sof_dev *sdev)\n{\n\tu32 hipcie;\n\tu32 hipct;\n\tu32 hipcctl;\n\n\thda_ipc_irq_dump(sdev);\n\n\t \n\thipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE);\n\thipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);\n\thipcctl = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL);\n\n\t \n\t \n\tdev_err(sdev->dev, \"host status 0x%8.8x dsp status 0x%8.8x mask 0x%8.8x\\n\",\n\t\thipcie, hipct, hipcctl);\n}\n\nvoid hda_ipc4_dump(struct snd_sof_dev *sdev)\n{\n\tu32 hipci, hipcie, hipct, hipcte, hipcctl;\n\n\thda_ipc_irq_dump(sdev);\n\n\thipci = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCI);\n\thipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE);\n\thipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);\n\thipcte = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCTE);\n\thipcctl = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL);\n\n\t \n\t \n\tdev_err(sdev->dev, \"Host IPC initiator: %#x|%#x, target: %#x|%#x, ctl: %#x\\n\",\n\t\thipci, hipcie, hipct, hipcte, hipcctl);\n}\n\nbool hda_ipc4_tx_is_busy(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tu32 val;\n\n\tval = snd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->ipc_req);\n\n\treturn !!(val & chip->ipc_req_mask);\n}\n\nstatic int hda_init(struct snd_sof_dev *sdev)\n{\n\tstruct hda_bus *hbus;\n\tstruct hdac_bus *bus;\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tint ret;\n\n\thbus = sof_to_hbus(sdev);\n\tbus = sof_to_bus(sdev);\n\n\t \n\tsof_hda_bus_init(sdev, &pci->dev);\n\n\tif (sof_hda_position_quirk == SOF_HDA_POSITION_QUIRK_USE_DPIB_REGISTERS)\n\t\tbus->use_posbuf = 0;\n\telse\n\t\tbus->use_posbuf = 1;\n\tbus->bdl_pos_adj = 0;\n\tbus->sync_write = 1;\n\n\tmutex_init(&hbus->prepare_mutex);\n\thbus->pci = pci;\n\thbus->mixer_assigned = -1;\n\thbus->modelname = hda_model;\n\n\t \n\tbus->addr = pci_resource_start(pci, 0);\n\tbus->remap_addr = pci_ioremap_bar(pci, 0);\n\tif (!bus->remap_addr) {\n\t\tdev_err(bus->dev, \"error: ioremap error\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\t \n\tsdev->bar[HDA_DSP_HDA_BAR] = bus->remap_addr;\n\n\t \n\tret = hda_codec_i915_init(sdev);\n\tif (ret < 0)\n\t\tdev_warn(sdev->dev, \"init of i915 and HDMI codec failed\\n\");\n\n\t \n\tret = hda_dsp_ctrl_get_caps(sdev);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"error: get caps error\\n\");\n\n\treturn ret;\n}\n\nstatic int check_dmic_num(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tstruct nhlt_acpi_table *nhlt;\n\tint dmic_num = 0;\n\n\tnhlt = hdev->nhlt;\n\tif (nhlt)\n\t\tdmic_num = intel_nhlt_get_dmic_geo(sdev->dev, nhlt);\n\n\t \n\tif (dmic_num_override != -1) {\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"overriding DMICs detected in NHLT tables %d by kernel param %d\\n\",\n\t\t\tdmic_num, dmic_num_override);\n\t\tdmic_num = dmic_num_override;\n\t}\n\n\tif (dmic_num < 0 || dmic_num > 4) {\n\t\tdev_dbg(sdev->dev, \"invalid dmic_number %d\\n\", dmic_num);\n\t\tdmic_num = 0;\n\t}\n\n\treturn dmic_num;\n}\n\nstatic int check_nhlt_ssp_mask(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tstruct nhlt_acpi_table *nhlt;\n\tint ssp_mask = 0;\n\n\tnhlt = hdev->nhlt;\n\tif (!nhlt)\n\t\treturn ssp_mask;\n\n\tif (intel_nhlt_has_endpoint_type(nhlt, NHLT_LINK_SSP)) {\n\t\tssp_mask = intel_nhlt_ssp_endpoint_mask(nhlt, NHLT_DEVICE_I2S);\n\t\tif (ssp_mask)\n\t\t\tdev_info(sdev->dev, \"NHLT_DEVICE_I2S detected, ssp_mask %#x\\n\", ssp_mask);\n\t}\n\n\treturn ssp_mask;\n}\n\nstatic int check_nhlt_ssp_mclk_mask(struct snd_sof_dev *sdev, int ssp_num)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tstruct nhlt_acpi_table *nhlt;\n\n\tnhlt = hdev->nhlt;\n\tif (!nhlt)\n\t\treturn 0;\n\n\treturn intel_nhlt_ssp_mclk_mask(nhlt, ssp_num);\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC) || IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)\n\nstatic const char *fixup_tplg_name(struct snd_sof_dev *sdev,\n\t\t\t\t   const char *sof_tplg_filename,\n\t\t\t\t   const char *idisp_str,\n\t\t\t\t   const char *dmic_str)\n{\n\tconst char *tplg_filename = NULL;\n\tchar *filename, *tmp;\n\tconst char *split_ext;\n\n\tfilename = kstrdup(sof_tplg_filename, GFP_KERNEL);\n\tif (!filename)\n\t\treturn NULL;\n\n\t \n\ttmp = filename;\n\tsplit_ext = strsep(&tmp, \".\");\n\tif (split_ext)\n\t\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t\t       \"%s%s%s.tplg\",\n\t\t\t\t\t       split_ext, idisp_str, dmic_str);\n\tkfree(filename);\n\n\treturn tplg_filename;\n}\n\nstatic int dmic_detect_topology_fixup(struct snd_sof_dev *sdev,\n\t\t\t\t      const char **tplg_filename,\n\t\t\t\t      const char *idisp_str,\n\t\t\t\t      int *dmic_found,\n\t\t\t\t      bool tplg_fixup)\n{\n\tconst char *dmic_str;\n\tint dmic_num;\n\n\t \n\tdmic_num = check_dmic_num(sdev);\n\n\tswitch (dmic_num) {\n\tcase 1:\n\t\tdmic_str = \"-1ch\";\n\t\tbreak;\n\tcase 2:\n\t\tdmic_str = \"-2ch\";\n\t\tbreak;\n\tcase 3:\n\t\tdmic_str = \"-3ch\";\n\t\tbreak;\n\tcase 4:\n\t\tdmic_str = \"-4ch\";\n\t\tbreak;\n\tdefault:\n\t\tdmic_num = 0;\n\t\tdmic_str = \"\";\n\t\tbreak;\n\t}\n\n\tif (tplg_fixup) {\n\t\tconst char *default_tplg_filename = *tplg_filename;\n\t\tconst char *fixed_tplg_filename;\n\n\t\tfixed_tplg_filename = fixup_tplg_name(sdev, default_tplg_filename,\n\t\t\t\t\t\t      idisp_str, dmic_str);\n\t\tif (!fixed_tplg_filename)\n\t\t\treturn -ENOMEM;\n\t\t*tplg_filename = fixed_tplg_filename;\n\t}\n\n\tdev_info(sdev->dev, \"DMICs detected in NHLT tables: %d\\n\", dmic_num);\n\t*dmic_found = dmic_num;\n\n\treturn 0;\n}\n#endif\n\nstatic int hda_init_caps(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tstruct sof_intel_hda_dev *hdev = pdata->hw_pdata;\n\tu32 link_mask;\n\tint ret = 0;\n\n\t \n\tif (bus->ppcap)\n\t\tdev_dbg(sdev->dev, \"PP capability, will probe DSP later.\\n\");\n\n\t \n\tret = hda_dsp_ctrl_init_chip(sdev);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"error: init chip failed with ret: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\thda_bus_ml_init(bus);\n\n\t \n\tif (!(interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\tgoto skip_soundwire;\n\n\t \n\tret = hda_sdw_acpi_scan(sdev);\n\tif (ret < 0) {\n\t\tdev_dbg(sdev->dev, \"skipping SoundWire, not detected with ACPI scan\\n\");\n\t\tgoto skip_soundwire;\n\t}\n\n\tlink_mask = hdev->info.link_mask;\n\tif (!link_mask) {\n\t\tdev_dbg(sdev->dev, \"skipping SoundWire, no links enabled\\n\");\n\t\tgoto skip_soundwire;\n\t}\n\n\t \n\tret = hda_sdw_probe(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: SoundWire probe error\\n\");\n\t\treturn ret;\n\t}\n\nskip_soundwire:\n\n\t \n\thda_codec_probe_bus(sdev);\n\n\tif (!HDA_IDISP_CODEC(bus->codec_mask))\n\t\thda_codec_i915_display_power(sdev, false);\n\n\thda_bus_ml_put_all(bus);\n\n\treturn 0;\n}\n\nstatic irqreturn_t hda_dsp_interrupt_handler(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\n\t \n\tif (snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS) &\n\t    SOF_HDA_INTSTS_GIS) {\n\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tSOF_HDA_INTCTL,\n\t\t\t\t\tSOF_HDA_INT_GLOBAL_EN,\n\t\t\t\t\t0);\n\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t hda_dsp_interrupt_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t \n\tif (hda_dsp_check_stream_irq(sdev)) {\n\t\ttrace_sof_intel_hda_irq(sdev, \"stream\");\n\t\thda_dsp_stream_threaded_handler(irq, sdev);\n\t}\n\n\tif (hda_check_ipc_irq(sdev)) {\n\t\ttrace_sof_intel_hda_irq(sdev, \"ipc\");\n\t\tsof_ops(sdev)->irq_thread(irq, sdev);\n\t}\n\n\tif (hda_dsp_check_sdw_irq(sdev)) {\n\t\ttrace_sof_intel_hda_irq(sdev, \"sdw\");\n\t\thda_dsp_sdw_thread(irq, hdev->sdw);\n\t}\n\n\tif (hda_sdw_check_wakeen_irq(sdev)) {\n\t\ttrace_sof_intel_hda_irq(sdev, \"wakeen\");\n\t\thda_sdw_process_wakeen(sdev);\n\t}\n\n\thda_codec_check_for_state_change(sdev);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tSOF_HDA_INTCTL,\n\t\t\t\tSOF_HDA_INT_GLOBAL_EN,\n\t\t\t\tSOF_HDA_INT_GLOBAL_EN);\n\n\treturn IRQ_HANDLED;\n}\n\nint hda_dsp_probe(struct snd_sof_dev *sdev)\n{\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tstruct sof_intel_hda_dev *hdev;\n\tstruct hdac_bus *bus;\n\tconst struct sof_intel_dsp_desc *chip;\n\tint ret = 0;\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\tif (pci->class == 0x040300) {\n\t\t\tdev_err(sdev->dev, \"the DSP is not enabled on this platform, aborting probe\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else if (pci->class != 0x040100 && pci->class != 0x040380) {\n\t\t\tdev_err(sdev->dev, \"unknown PCI class/subclass/prog-if 0x%06x found, aborting probe\\n\",\n\t\t\t\tpci->class);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tdev_info(sdev->dev, \"DSP detected with PCI class/subclass/prog-if 0x%06x\\n\",\n\t\t\t pci->class);\n\t}\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (!chip) {\n\t\tdev_err(sdev->dev, \"error: no such device supported, chip id:%x\\n\",\n\t\t\tpci->device);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tsdev->num_cores = chip->cores_num;\n\n\thdev = devm_kzalloc(sdev->dev, sizeof(*hdev), GFP_KERNEL);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\tsdev->pdata->hw_pdata = hdev;\n\thdev->desc = chip;\n\n\thdev->dmic_dev = platform_device_register_data(sdev->dev, \"dmic-codec\",\n\t\t\t\t\t\t       PLATFORM_DEVID_NONE,\n\t\t\t\t\t\t       NULL, 0);\n\tif (IS_ERR(hdev->dmic_dev)) {\n\t\tdev_err(sdev->dev, \"error: failed to create DMIC device\\n\");\n\t\treturn PTR_ERR(hdev->dmic_dev);\n\t}\n\n\t \n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_FORCE_IPC_POSITION)\n\thdev->no_ipc_position = 0;\n#else\n\thdev->no_ipc_position = sof_ops(sdev)->pcm_pointer ? 1 : 0;\n#endif\n\n\tif (sdev->dspless_mode_selected)\n\t\thdev->no_ipc_position = 1;\n\n\t \n\tbus = sof_to_bus(sdev);\n\tret = hda_init(sdev);\n\tif (ret < 0)\n\t\tgoto hdac_bus_unmap;\n\n\tif (sdev->dspless_mode_selected)\n\t\tgoto skip_dsp_setup;\n\n\t \n\tsdev->bar[HDA_DSP_BAR] = pci_ioremap_bar(pci, HDA_DSP_BAR);\n\tif (!sdev->bar[HDA_DSP_BAR]) {\n\t\tdev_err(sdev->dev, \"error: ioremap error\\n\");\n\t\tret = -ENXIO;\n\t\tgoto hdac_bus_unmap;\n\t}\n\n\tsdev->mmio_bar = HDA_DSP_BAR;\n\tsdev->mailbox_bar = HDA_DSP_BAR;\nskip_dsp_setup:\n\n\t \n\tif (dma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(sdev->dev, \"DMA mask is 32 bit\\n\");\n\t\tdma_set_mask_and_coherent(&pci->dev, DMA_BIT_MASK(32));\n\t}\n\tdma_set_max_seg_size(&pci->dev, UINT_MAX);\n\n\t \n\tret = hda_dsp_stream_init(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to init streams\\n\");\n\t\t \n\t\tgoto free_streams;\n\t}\n\n\t \n\tif (hda_use_msi && pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_MSI) > 0) {\n\t\tdev_info(sdev->dev, \"use msi interrupt mode\\n\");\n\t\tsdev->ipc_irq = pci_irq_vector(pci, 0);\n\t\t \n\t\tsdev->msi_enabled = true;\n\t}\n\n\tif (!sdev->msi_enabled) {\n\t\tdev_info(sdev->dev, \"use legacy interrupt mode\\n\");\n\t\t \n\t\tsdev->ipc_irq = pci->irq;\n\t}\n\n\tdev_dbg(sdev->dev, \"using IPC IRQ %d\\n\", sdev->ipc_irq);\n\tret = request_threaded_irq(sdev->ipc_irq, hda_dsp_interrupt_handler,\n\t\t\t\t   hda_dsp_interrupt_thread,\n\t\t\t\t   IRQF_SHARED, \"AudioDSP\", sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to register IPC IRQ %d\\n\",\n\t\t\tsdev->ipc_irq);\n\t\tgoto free_irq_vector;\n\t}\n\n\tpci_set_master(pci);\n\tsynchronize_irq(pci->irq);\n\n\t \n\tsnd_sof_pci_update_bits(sdev, PCI_TCSEL, 0x07, 0);\n\n\t \n\tret = hda_init_caps(sdev);\n\tif (ret < 0)\n\t\tgoto free_ipc_irq;\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\thda_dsp_ctrl_ppcap_enable(sdev, true);\n\t\thda_dsp_ctrl_ppcap_int_enable(sdev, true);\n\n\t\t \n\t\tsdev->dsp_box.offset = HDA_DSP_MBOX_UPLINK_OFFSET;\n\n\t\tINIT_DELAYED_WORK(&hdev->d0i3_work, hda_dsp_d0i3_work);\n\t}\n\n\tinit_waitqueue_head(&hdev->waitq);\n\n\thdev->nhlt = intel_nhlt_init(sdev->dev);\n\n\treturn 0;\n\nfree_ipc_irq:\n\tfree_irq(sdev->ipc_irq, sdev);\nfree_irq_vector:\n\tif (sdev->msi_enabled)\n\t\tpci_free_irq_vectors(pci);\nfree_streams:\n\thda_dsp_stream_free(sdev);\n \n\tif (!sdev->dspless_mode_selected)\n\t\tiounmap(sdev->bar[HDA_DSP_BAR]);\nhdac_bus_unmap:\n\tplatform_device_unregister(hdev->dmic_dev);\n\tiounmap(bus->remap_addr);\n\thda_codec_i915_exit(sdev);\nerr:\n\treturn ret;\n}\n\nint hda_dsp_remove(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tstruct nhlt_acpi_table *nhlt = hda->nhlt;\n\n\tif (nhlt)\n\t\tintel_nhlt_free(nhlt);\n\n\tif (!sdev->dspless_mode_selected)\n\t\t \n\t\tcancel_delayed_work_sync(&hda->d0i3_work);\n\n\thda_codec_device_remove(sdev);\n\n\thda_sdw_exit(sdev);\n\n\tif (!IS_ERR_OR_NULL(hda->dmic_dev))\n\t\tplatform_device_unregister(hda->dmic_dev);\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\t\tSOF_HDA_PPCTL_PIE, 0);\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\tSOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN, 0);\n\n\tif (sdev->dspless_mode_selected)\n\t\tgoto skip_disable_dsp;\n\n\t \n\tif (chip && chip->power_down_dsp)\n\t\tchip->power_down_dsp(sdev);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\tSOF_HDA_PPCTL_GPROCEN, 0);\n\nskip_disable_dsp:\n\tfree_irq(sdev->ipc_irq, sdev);\n\tif (sdev->msi_enabled)\n\t\tpci_free_irq_vectors(pci);\n\n\thda_dsp_stream_free(sdev);\n\n\thda_bus_ml_free(sof_to_bus(sdev));\n\n\tif (!sdev->dspless_mode_selected)\n\t\tiounmap(sdev->bar[HDA_DSP_BAR]);\n\n\tiounmap(bus->remap_addr);\n\n\tsof_hda_bus_exit(sdev);\n\n\thda_codec_i915_exit(sdev);\n\n\treturn 0;\n}\n\nint hda_power_down_dsp(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\n\treturn hda_dsp_core_reset_power_down(sdev, chip->host_managed_cores_mask);\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC)\nstatic void hda_generic_machine_select(struct snd_sof_dev *sdev,\n\t\t\t\t       struct snd_soc_acpi_mach **mach)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct snd_soc_acpi_mach_params *mach_params;\n\tstruct snd_soc_acpi_mach *hda_mach;\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst char *tplg_filename;\n\tconst char *idisp_str;\n\tint dmic_num = 0;\n\tint codec_num = 0;\n\tint ret;\n\tint i;\n\n\t \n\tif (!bus->codec_mask) {\n\t\tdev_info(bus->dev, \"no hda codecs found!\\n\");\n\t} else {\n\t\tdev_info(bus->dev, \"hda codecs found, mask %lx\\n\",\n\t\t\t bus->codec_mask);\n\n\t\tfor (i = 0; i < HDA_MAX_CODECS; i++) {\n\t\t\tif (bus->codec_mask & (1 << i))\n\t\t\t\tcodec_num++;\n\t\t}\n\n\t\t \n\t\tif (!*mach && codec_num <= 2) {\n\t\t\tbool tplg_fixup;\n\n\t\t\thda_mach = snd_soc_acpi_intel_hda_machines;\n\n\t\t\tdev_info(bus->dev, \"using HDA machine driver %s now\\n\",\n\t\t\t\t hda_mach->drv_name);\n\n\t\t\tif (codec_num == 1 && HDA_IDISP_CODEC(bus->codec_mask))\n\t\t\t\tidisp_str = \"-idisp\";\n\t\t\telse\n\t\t\t\tidisp_str = \"\";\n\n\t\t\t \n\t\t\tif (pdata->tplg_filename) {\n\t\t\t\ttplg_fixup = false;\n\t\t\t\ttplg_filename = pdata->tplg_filename;\n\t\t\t} else {\n\t\t\t\ttplg_fixup = true;\n\t\t\t\ttplg_filename = hda_mach->sof_tplg_filename;\n\t\t\t}\n\t\t\tret = dmic_detect_topology_fixup(sdev, &tplg_filename, idisp_str, &dmic_num,\n\t\t\t\t\t\t\t tplg_fixup);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\n\t\t\thda_mach->mach_params.dmic_num = dmic_num;\n\t\t\tpdata->tplg_filename = tplg_filename;\n\n\t\t\tif (codec_num == 2 ||\n\t\t\t    (codec_num == 1 && !HDA_IDISP_CODEC(bus->codec_mask))) {\n\t\t\t\t \n\t\t\t\thda_mach->mach_params.link_mask = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t\t\t\thda_mach->mach_params.link_mask = hdev->info.link_mask;\n\t\t\t}\n\n\t\t\t*mach = hda_mach;\n\t\t}\n\t}\n\n\t \n\tif (*mach) {\n\t\tmach_params = &(*mach)->mach_params;\n\t\tmach_params->codec_mask = bus->codec_mask;\n\t\tmach_params->common_hdmi_codec_drv = true;\n\t}\n}\n#else\nstatic void hda_generic_machine_select(struct snd_sof_dev *sdev,\n\t\t\t\t       struct snd_soc_acpi_mach **mach)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)\n\nstatic struct snd_soc_acpi_mach *hda_sdw_machine_select(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct snd_soc_acpi_link_adr *link;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct sof_intel_hda_dev *hdev;\n\tu32 link_mask;\n\tint i;\n\n\thdev = pdata->hw_pdata;\n\tlink_mask = hdev->info.link_mask;\n\n\t \n\tif (link_mask) {\n\t\tfor (mach = pdata->desc->alt_machines;\n\t\t     mach && mach->link_mask; mach++) {\n\t\t\t \n\t\t\tif (~link_mask & mach->link_mask)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!mach->links)\n\t\t\t\tbreak;\n\n\t\t\tlink = mach->links;\n\t\t\tfor (i = 0; i < hdev->info.count && link->num_adr;\n\t\t\t     i++, link++) {\n\t\t\t\t \n\t\t\t\tif (!snd_soc_acpi_sdw_link_slaves_found(sdev->dev, link,\n\t\t\t\t\t\t\t\t\thdev->sdw->ids,\n\t\t\t\t\t\t\t\t\thdev->sdw->num_slaves))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (i == hdev->info.count || !link->num_adr)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (mach && mach->link_mask) {\n\t\t\tint dmic_num = 0;\n\t\t\tbool tplg_fixup;\n\t\t\tconst char *tplg_filename;\n\n\t\t\tmach->mach_params.links = mach->links;\n\t\t\tmach->mach_params.link_mask = mach->link_mask;\n\t\t\tmach->mach_params.platform = dev_name(sdev->dev);\n\n\t\t\tif (pdata->tplg_filename) {\n\t\t\t\ttplg_fixup = false;\n\t\t\t} else {\n\t\t\t\ttplg_fixup = true;\n\t\t\t\ttplg_filename = mach->sof_tplg_filename;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (hweight_long(mach->link_mask) <= 2) {\n\t\t\t\tint ret;\n\n\t\t\t\tret = dmic_detect_topology_fixup(sdev, &tplg_filename, \"\",\n\t\t\t\t\t\t\t\t &dmic_num, tplg_fixup);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (tplg_fixup)\n\t\t\t\tpdata->tplg_filename = tplg_filename;\n\t\t\tmach->mach_params.dmic_num = dmic_num;\n\n\t\t\tdev_dbg(sdev->dev,\n\t\t\t\t\"SoundWire machine driver %s topology %s\\n\",\n\t\t\t\tmach->drv_name,\n\t\t\t\tpdata->tplg_filename);\n\n\t\t\treturn mach;\n\t\t}\n\n\t\tdev_info(sdev->dev, \"No SoundWire machine driver found\\n\");\n\t}\n\n\treturn NULL;\n}\n#else\nstatic struct snd_soc_acpi_mach *hda_sdw_machine_select(struct snd_sof_dev *sdev)\n{\n\treturn NULL;\n}\n#endif\n\nvoid hda_set_mach_params(struct snd_soc_acpi_mach *mach,\n\t\t\t struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct snd_soc_acpi_mach_params *mach_params;\n\n\tmach_params = &mach->mach_params;\n\tmach_params->platform = dev_name(sdev->dev);\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\tmach_params->num_dai_drivers = SOF_SKL_NUM_DAIS_NOCODEC;\n\telse\n\t\tmach_params->num_dai_drivers = desc->ops->num_drv;\n\tmach_params->dai_drivers = desc->ops->drv;\n}\n\nstruct snd_soc_acpi_mach *hda_machine_select(struct snd_sof_dev *sdev)\n{\n\tu32 interface_mask = hda_get_interface_mask(sdev);\n\tstruct snd_sof_pdata *sof_pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = sof_pdata->desc;\n\tstruct snd_soc_acpi_mach *mach = NULL;\n\tconst char *tplg_filename;\n\n\t \n\tif (interface_mask & (BIT(SOF_DAI_INTEL_SSP) | BIT(SOF_DAI_INTEL_DMIC)))\n\t\tmach = snd_soc_acpi_find_machine(desc->machines);\n\n\tif (mach) {\n\t\tbool add_extension = false;\n\t\tbool tplg_fixup = false;\n\n\t\t \n\t\tif (!sof_pdata->tplg_filename) {\n\t\t\tsof_pdata->tplg_filename = mach->sof_tplg_filename;\n\t\t\ttplg_fixup = true;\n\t\t}\n\n\t\t \n\t\tmach->mach_params.dmic_num = check_dmic_num(sdev);\n\n\t\tif (tplg_fixup &&\n\t\t    mach->tplg_quirk_mask & SND_SOC_ACPI_TPLG_INTEL_DMIC_NUMBER &&\n\t\t    mach->mach_params.dmic_num) {\n\t\t\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t       \"%s%s%d%s\",\n\t\t\t\t\t\t       sof_pdata->tplg_filename,\n\t\t\t\t\t\t       \"-dmic\",\n\t\t\t\t\t\t       mach->mach_params.dmic_num,\n\t\t\t\t\t\t       \"ch\");\n\t\t\tif (!tplg_filename)\n\t\t\t\treturn NULL;\n\n\t\t\tsof_pdata->tplg_filename = tplg_filename;\n\t\t\tadd_extension = true;\n\t\t}\n\n\t\tif (mach->link_mask) {\n\t\t\tmach->mach_params.links = mach->links;\n\t\t\tmach->mach_params.link_mask = mach->link_mask;\n\t\t}\n\n\t\t \n\t\tmach->mach_params.i2s_link_mask = check_nhlt_ssp_mask(sdev);\n\n\t\tif (tplg_fixup &&\n\t\t    mach->tplg_quirk_mask & SND_SOC_ACPI_TPLG_INTEL_SSP_NUMBER &&\n\t\t    mach->mach_params.i2s_link_mask) {\n\t\t\tconst struct sof_intel_dsp_desc *chip = get_chip_info(sdev->pdata);\n\t\t\tint ssp_num;\n\t\t\tint mclk_mask;\n\n\t\t\tif (hweight_long(mach->mach_params.i2s_link_mask) > 1 &&\n\t\t\t    !(mach->tplg_quirk_mask & SND_SOC_ACPI_TPLG_INTEL_SSP_MSB))\n\t\t\t\tdev_warn(sdev->dev, \"More than one SSP exposed by NHLT, choosing MSB\\n\");\n\n\t\t\t \n\t\t\tssp_num = fls(mach->mach_params.i2s_link_mask) - 1;\n\n\t\t\tif (ssp_num >= chip->ssp_count) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid SSP %d, max on this platform is %d\\n\",\n\t\t\t\t\tssp_num, chip->ssp_count);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t       \"%s%s%d\",\n\t\t\t\t\t\t       sof_pdata->tplg_filename,\n\t\t\t\t\t\t       \"-ssp\",\n\t\t\t\t\t\t       ssp_num);\n\t\t\tif (!tplg_filename)\n\t\t\t\treturn NULL;\n\n\t\t\tsof_pdata->tplg_filename = tplg_filename;\n\t\t\tadd_extension = true;\n\n\t\t\tmclk_mask = check_nhlt_ssp_mclk_mask(sdev, ssp_num);\n\n\t\t\tif (mclk_mask < 0) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid MCLK configuration\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tdev_dbg(sdev->dev, \"MCLK mask %#x found in NHLT\\n\", mclk_mask);\n\n\t\t\tif (mclk_mask) {\n\t\t\t\tdev_info(sdev->dev, \"Overriding topology with MCLK mask %#x from NHLT\\n\", mclk_mask);\n\t\t\t\tsdev->mclk_id_override = true;\n\t\t\t\tsdev->mclk_id_quirk = (mclk_mask & BIT(0)) ? 0 : 1;\n\t\t\t}\n\t\t}\n\n\t\tif (tplg_fixup && add_extension) {\n\t\t\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t\t\t       \"%s%s\",\n\t\t\t\t\t\t       sof_pdata->tplg_filename,\n\t\t\t\t\t\t       \".tplg\");\n\t\t\tif (!tplg_filename)\n\t\t\t\treturn NULL;\n\n\t\t\tsof_pdata->tplg_filename = tplg_filename;\n\t\t}\n\n\t\t \n\t\tif (mclk_id_override >= 0) {\n\t\t\tdev_info(sdev->dev, \"Overriding topology with MCLK %d from kernel_parameter\\n\", mclk_id_override);\n\t\t\tsdev->mclk_id_override = true;\n\t\t\tsdev->mclk_id_quirk = mclk_id_override;\n\t\t}\n\t}\n\n\t \n\tif (!mach && (interface_mask & BIT(SOF_DAI_INTEL_ALH)))\n\t\tmach = hda_sdw_machine_select(sdev);\n\n\t \n\thda_generic_machine_select(sdev, &mach);\n\tif (!mach)\n\t\tdev_warn(sdev->dev, \"warning: No matching ASoC machine driver found\\n\");\n\n\treturn mach;\n}\n\nint hda_pci_intel_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tint ret;\n\n\tret = snd_intel_dsp_driver_probe(pci);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_SOF) {\n\t\tdev_dbg(&pci->dev, \"SOF PCI driver not selected, aborting probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn sof_pci_probe(pci, pci_id);\n}\nEXPORT_SYMBOL_NS(hda_pci_intel_probe, SND_SOC_SOF_INTEL_HDA_COMMON);\n\nint hda_register_clients(struct snd_sof_dev *sdev)\n{\n\treturn hda_probes_register(sdev);\n}\n\nvoid hda_unregister_clients(struct snd_sof_dev *sdev)\n{\n\thda_probes_unregister(sdev);\n}\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_PCI_DEV);\nMODULE_IMPORT_NS(SND_SOC_SOF_HDA_AUDIO_CODEC);\nMODULE_IMPORT_NS(SND_SOC_SOF_HDA_AUDIO_CODEC_I915);\nMODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);\nMODULE_IMPORT_NS(SND_INTEL_SOUNDWIRE_ACPI);\nMODULE_IMPORT_NS(SOUNDWIRE_INTEL_INIT);\nMODULE_IMPORT_NS(SOUNDWIRE_INTEL);\nMODULE_IMPORT_NS(SND_SOC_SOF_HDA_MLINK);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}