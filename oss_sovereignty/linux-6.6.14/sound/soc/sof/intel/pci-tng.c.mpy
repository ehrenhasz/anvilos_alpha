{
  "module_name": "pci-tng.c",
  "hash_id": "ac589571388a07df9675009343b2e5c829c0e52f9d3f64231ac8fef778125eb8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/pci-tng.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/sof.h>\n#include \"../ops.h\"\n#include \"atom.h\"\n#include \"../sof-pci-dev.h\"\n#include \"../sof-audio.h\"\n\n \n#include \"shim.h\"\n\nstatic struct snd_soc_acpi_mach sof_tng_machines[] = {\n\t{\n\t\t.id = \"INT343A\",\n\t\t.drv_name = \"edison\",\n\t\t.sof_tplg_filename = \"sof-byt.tplg\",\n\t},\n\t{}\n};\n\nstatic const struct snd_sof_debugfs_map tng_debugfs[] = {\n\t{\"dmac0\", DSP_BAR, DMAC0_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dmac1\", DSP_BAR, DMAC1_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp0\", DSP_BAR, SSP0_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp1\", DSP_BAR, SSP1_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp2\", DSP_BAR, SSP2_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"iram\", DSP_BAR, IRAM_OFFSET, IRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"dram\", DSP_BAR, DRAM_OFFSET, DRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"shim\", DSP_BAR, SHIM_OFFSET, SHIM_SIZE_BYT,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n};\n\nstatic int tangier_pci_probe(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tconst struct sof_intel_dsp_desc *chip;\n\tu32 base, size;\n\tint ret;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (!chip) {\n\t\tdev_err(sdev->dev, \"error: no such device supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsdev->num_cores = chip->cores_num;\n\n\t \n\tret = dma_coerce_mask_and_coherent(&pci->dev, DMA_BIT_MASK(31));\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to set DMA mask %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tbase = pci_resource_start(pci, desc->resindex_lpe_base) - IRAM_OFFSET;\n\tsize = PCI_BAR_SIZE;\n\n\tdev_dbg(sdev->dev, \"LPE PHY base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[DSP_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[DSP_BAR]) {\n\t\tdev_err(sdev->dev, \"error: failed to ioremap LPE base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"LPE VADDR %p\\n\", sdev->bar[DSP_BAR]);\n\n\t \n\tif (desc->resindex_imr_base == -1)\n\t\tgoto irq;\n\n\tbase = pci_resource_start(pci, desc->resindex_imr_base);\n\tsize = pci_resource_len(pci, desc->resindex_imr_base);\n\n\t \n\tif (base == 0x55aa55aa || base == 0x0) {\n\t\tdev_info(sdev->dev, \"IMR not set by BIOS. Ignoring\\n\");\n\t\tgoto irq;\n\t}\n\n\tdev_dbg(sdev->dev, \"IMR base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[IMR_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[IMR_BAR]) {\n\t\tdev_err(sdev->dev, \"error: failed to ioremap IMR base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"IMR VADDR %p\\n\", sdev->bar[IMR_BAR]);\n\nirq:\n\t \n\tsdev->ipc_irq = pci->irq;\n\tdev_dbg(sdev->dev, \"using IRQ %d\\n\", sdev->ipc_irq);\n\tret = devm_request_threaded_irq(sdev->dev, sdev->ipc_irq,\n\t\t\t\t\tatom_irq_handler, atom_irq_thread,\n\t\t\t\t\t0, \"AudioDSP\", sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to register IRQ %d\\n\",\n\t\t\tsdev->ipc_irq);\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_IMRX,\n\t\t\t\t  SHIM_IMRX_BUSY | SHIM_IMRX_DONE,\n\t\t\t\t  SHIM_IMRX_DONE);\n\n\t \n\tsdev->dsp_box.offset = MBOX_OFFSET;\n\n\treturn ret;\n}\n\nstruct snd_sof_dsp_ops sof_tng_ops = {\n\t \n\t.probe\t\t= tangier_pci_probe,\n\n\t \n\t.run\t\t= atom_run,\n\t.reset\t\t= atom_reset,\n\n\t \n\n\t \n\t.block_read\t= sof_block_read,\n\t.block_write\t= sof_block_write,\n\n\t \n\t.mailbox_read\t= sof_mailbox_read,\n\t.mailbox_write\t= sof_mailbox_write,\n\n\t \n\t.irq_handler\t= atom_irq_handler,\n\t.irq_thread\t= atom_irq_thread,\n\n\t \n\t.send_msg\t= atom_send_msg,\n\t.get_mailbox_offset = atom_get_mailbox_offset,\n\t.get_window_offset = atom_get_window_offset,\n\n\t.ipc_msg_data\t= sof_ipc_msg_data,\n\t.set_stream_data_offset = sof_set_stream_data_offset,\n\n\t \n\t.machine_select = atom_machine_select,\n\t.machine_register = sof_machine_register,\n\t.machine_unregister = sof_machine_unregister,\n\t.set_mach_params = atom_set_mach_params,\n\n\t \n\t.debug_map\t= tng_debugfs,\n\t.debug_map_count\t= ARRAY_SIZE(tng_debugfs),\n\t.dbg_dump\t= atom_dump,\n\t.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,\n\n\t \n\t.pcm_open\t= sof_stream_pcm_open,\n\t.pcm_close\t= sof_stream_pcm_close,\n\n\t \n\t.load_firmware\t= snd_sof_load_firmware_memcpy,\n\n\t \n\t.drv = atom_dai,\n\t.num_drv = 3,  \n\n\t \n\t.hw_info =\tSNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.dsp_arch_ops = &sof_xtensa_arch_ops,\n};\n\nconst struct sof_intel_dsp_desc tng_chip_info = {\n\t.cores_num = 1,\n\t.host_managed_cores_mask = 1,\n\t.hw_ip_version = SOF_INTEL_TANGIER,\n};\n\nstatic const struct sof_dev_desc tng_desc = {\n\t.machines\t\t= sof_tng_machines,\n\t.resindex_lpe_base\t= 3,\t \n\t.resindex_pcicfg_base\t= -1,\n\t.resindex_imr_base\t= 0,\n\t.irqindex_host_ipc\t= -1,\n\t.chip_info = &tng_chip_info,\n\t.ipc_supported_mask\t= BIT(SOF_IPC),\n\t.ipc_default\t\t= SOF_IPC,\n\t.default_fw_path = {\n\t\t[SOF_IPC] = \"intel/sof\",\n\t},\n\t.default_tplg_path = {\n\t\t[SOF_IPC] = \"intel/sof-tplg\",\n\t},\n\t.default_fw_filename = {\n\t\t[SOF_IPC] = \"sof-byt.ri\",\n\t},\n\t.nocodec_tplg_filename = \"sof-byt.tplg\",\n\t.ops = &sof_tng_ops,\n};\n\n \nstatic const struct pci_device_id sof_pci_ids[] = {\n\t{ PCI_DEVICE_DATA(INTEL, SST_TNG, &tng_desc) },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, sof_pci_ids);\n\n \nstatic struct pci_driver snd_sof_pci_intel_tng_driver = {\n\t.name = \"sof-audio-pci-intel-tng\",\n\t.id_table = sof_pci_ids,\n\t.probe = sof_pci_probe,\n\t.remove = sof_pci_remove,\n\t.shutdown = sof_pci_shutdown,\n\t.driver = {\n\t\t.pm = &sof_pci_pm,\n\t},\n};\nmodule_pci_driver(snd_sof_pci_intel_tng_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_INTEL_HIFI_EP_IPC);\nMODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);\nMODULE_IMPORT_NS(SND_SOC_SOF_PCI_DEV);\nMODULE_IMPORT_NS(SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}