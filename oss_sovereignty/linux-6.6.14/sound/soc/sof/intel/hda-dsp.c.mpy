{
  "module_name": "hda-dsp.c",
  "hash_id": "ba484b3dc7bf46ca41d43cc29b18291c4385d2d975072058dc103004aef69e99",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-dsp.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/hda-mlink.h>\n#include <trace/events/sof_intel.h>\n#include \"../sof-audio.h\"\n#include \"../ops.h\"\n#include \"hda.h\"\n#include \"hda-ipc.h\"\n\nstatic bool hda_enable_trace_D0I3_S0;\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG)\nmodule_param_named(enable_trace_D0I3_S0, hda_enable_trace_D0I3_S0, bool, 0444);\nMODULE_PARM_DESC(enable_trace_D0I3_S0,\n\t\t \"SOF HDA enable trace when the DSP is in D0I3 in S0\");\n#endif\n\n \n\nstatic int hda_dsp_core_reset_enter(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tu32 adspcs;\n\tu32 reset;\n\tint ret;\n\n\t \n\treset = HDA_DSP_ADSPCS_CRST_MASK(core_mask);\n\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t HDA_DSP_REG_ADSPCS,\n\t\t\t\t\t reset, reset);\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\tHDA_DSP_REG_ADSPCS, adspcs,\n\t\t\t\t\t((adspcs & reset) == reset),\n\t\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\tHDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: %s: timeout on HDA_DSP_REG_ADSPCS read\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tadspcs = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t  HDA_DSP_REG_ADSPCS);\n\tif ((adspcs & HDA_DSP_ADSPCS_CRST_MASK(core_mask)) !=\n\t\tHDA_DSP_ADSPCS_CRST_MASK(core_mask)) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: reset enter failed: core_mask %x adspcs 0x%x\\n\",\n\t\t\tcore_mask, adspcs);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int hda_dsp_core_reset_leave(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tunsigned int crst;\n\tu32 adspcs;\n\tint ret;\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t HDA_DSP_REG_ADSPCS,\n\t\t\t\t\t HDA_DSP_ADSPCS_CRST_MASK(core_mask),\n\t\t\t\t\t 0);\n\n\t \n\tcrst = HDA_DSP_ADSPCS_CRST_MASK(core_mask);\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\t    HDA_DSP_REG_ADSPCS, adspcs,\n\t\t\t\t\t    !(adspcs & crst),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_RESET_TIMEOUT_US);\n\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: %s: timeout on HDA_DSP_REG_ADSPCS read\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tadspcs = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t  HDA_DSP_REG_ADSPCS);\n\tif ((adspcs & HDA_DSP_ADSPCS_CRST_MASK(core_mask)) != 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: reset leave failed: core_mask %x adspcs 0x%x\\n\",\n\t\t\tcore_mask, adspcs);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nint hda_dsp_core_stall_reset(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t HDA_DSP_REG_ADSPCS,\n\t\t\t\t\t HDA_DSP_ADSPCS_CSTALL_MASK(core_mask),\n\t\t\t\t\t HDA_DSP_ADSPCS_CSTALL_MASK(core_mask));\n\n\t \n\treturn hda_dsp_core_reset_enter(sdev, core_mask);\n}\n\nbool hda_dsp_core_is_enabled(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tint val;\n\tbool is_enable;\n\n\tval = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPCS);\n\n#define MASK_IS_EQUAL(v, m, field) ({\t\\\n\tu32 _m = field(m);\t\t\\\n\t((v) & _m) == _m;\t\t\\\n})\n\n\tis_enable = MASK_IS_EQUAL(val, core_mask, HDA_DSP_ADSPCS_CPA_MASK) &&\n\t\tMASK_IS_EQUAL(val, core_mask, HDA_DSP_ADSPCS_SPA_MASK) &&\n\t\t!(val & HDA_DSP_ADSPCS_CRST_MASK(core_mask)) &&\n\t\t!(val & HDA_DSP_ADSPCS_CSTALL_MASK(core_mask));\n\n#undef MASK_IS_EQUAL\n\n\tdev_dbg(sdev->dev, \"DSP core(s) enabled? %d : core_mask %x\\n\",\n\t\tis_enable, core_mask);\n\n\treturn is_enable;\n}\n\nint hda_dsp_core_run(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tint ret;\n\n\t \n\tret = hda_dsp_core_reset_leave(sdev, core_mask);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdev_dbg(sdev->dev, \"unstall/run core: core_mask = %x\\n\", core_mask);\n\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t HDA_DSP_REG_ADSPCS,\n\t\t\t\t\t HDA_DSP_ADSPCS_CSTALL_MASK(core_mask),\n\t\t\t\t\t 0);\n\n\t \n\tif (!hda_dsp_core_is_enabled(sdev, core_mask)) {\n\t\thda_dsp_core_stall_reset(sdev, core_mask);\n\t\tdev_err(sdev->dev, \"error: DSP start core failed: core_mask %x\\n\",\n\t\t\tcore_mask);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n \n\nint hda_dsp_core_power_up(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tunsigned int cpa;\n\tu32 adspcs;\n\tint ret;\n\n\t \n\tcore_mask &= chip->host_managed_cores_mask;\n\t \n\tif (!core_mask)\n\t\treturn 0;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPCS,\n\t\t\t\tHDA_DSP_ADSPCS_SPA_MASK(core_mask),\n\t\t\t\tHDA_DSP_ADSPCS_SPA_MASK(core_mask));\n\n\t \n\tcpa = HDA_DSP_ADSPCS_CPA_MASK(core_mask);\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\t    HDA_DSP_REG_ADSPCS, adspcs,\n\t\t\t\t\t    (adspcs & cpa) == cpa,\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: %s: timeout on HDA_DSP_REG_ADSPCS read\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tadspcs = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t  HDA_DSP_REG_ADSPCS);\n\tif ((adspcs & HDA_DSP_ADSPCS_CPA_MASK(core_mask)) !=\n\t\tHDA_DSP_ADSPCS_CPA_MASK(core_mask)) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: power up core failed core_mask %xadspcs 0x%x\\n\",\n\t\t\tcore_mask, adspcs);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int hda_dsp_core_power_down(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tu32 adspcs;\n\tint ret;\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t HDA_DSP_REG_ADSPCS,\n\t\t\t\t\t HDA_DSP_ADSPCS_SPA_MASK(core_mask), 0);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\tHDA_DSP_REG_ADSPCS, adspcs,\n\t\t\t\t!(adspcs & HDA_DSP_ADSPCS_CPA_MASK(core_mask)),\n\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\tHDA_DSP_PD_TIMEOUT * USEC_PER_MSEC);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: %s: timeout on HDA_DSP_REG_ADSPCS read\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nint hda_dsp_enable_core(struct snd_sof_dev *sdev, unsigned int core_mask)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tint ret;\n\n\t \n\tcore_mask &= chip->host_managed_cores_mask;\n\n\t \n\tif (!core_mask || hda_dsp_core_is_enabled(sdev, core_mask))\n\t\treturn 0;\n\n\t \n\tret = hda_dsp_core_power_up(sdev, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: dsp core power up failed: core_mask %x\\n\",\n\t\t\tcore_mask);\n\t\treturn ret;\n\t}\n\n\treturn hda_dsp_core_run(sdev, core_mask);\n}\n\nint hda_dsp_core_reset_power_down(struct snd_sof_dev *sdev,\n\t\t\t\t  unsigned int core_mask)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tint ret;\n\n\t \n\tcore_mask &= chip->host_managed_cores_mask;\n\n\t \n\tif (!core_mask)\n\t\treturn 0;\n\n\t \n\tret = hda_dsp_core_stall_reset(sdev, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: dsp core reset failed: core_mask %x\\n\",\n\t\t\tcore_mask);\n\t\treturn ret;\n\t}\n\n\t \n\tret = hda_dsp_core_power_down(sdev, core_mask);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: dsp core power down fail mask %x: %d\\n\",\n\t\t\tcore_mask, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (hda_dsp_core_is_enabled(sdev, core_mask)) {\n\t\tdev_err(sdev->dev, \"error: dsp core disable fail mask %x: %d\\n\",\n\t\t\tcore_mask, ret);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nvoid hda_dsp_ipc_int_enable(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\tHDA_DSP_REG_HIPCCTL_DONE | HDA_DSP_REG_HIPCCTL_BUSY,\n\t\t\tHDA_DSP_REG_HIPCCTL_DONE | HDA_DSP_REG_HIPCCTL_BUSY);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIC,\n\t\t\t\tHDA_DSP_ADSPIC_IPC, HDA_DSP_ADSPIC_IPC);\n}\n\nvoid hda_dsp_ipc_int_disable(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIC,\n\t\t\t\tHDA_DSP_ADSPIC_IPC, 0);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\tHDA_DSP_REG_HIPCCTL_BUSY | HDA_DSP_REG_HIPCCTL_DONE, 0);\n}\n\nstatic int hda_dsp_wait_d0i3c_done(struct snd_sof_dev *sdev)\n{\n\tint retry = HDA_DSP_REG_POLL_RETRY_COUNT;\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_intel_dsp_desc *chip;\n\n\tchip = get_chip_info(pdata);\n\twhile (snd_sof_dsp_read8(sdev, HDA_DSP_HDA_BAR, chip->d0i3_offset) &\n\t\tSOF_HDA_VS_D0I3C_CIP) {\n\t\tif (!retry--)\n\t\t\treturn -ETIMEDOUT;\n\t\tusleep_range(10, 15);\n\t}\n\n\treturn 0;\n}\n\nstatic int hda_dsp_send_pm_gate_ipc(struct snd_sof_dev *sdev, u32 flags)\n{\n\tconst struct sof_ipc_pm_ops *pm_ops = sof_ipc_get_ops(sdev, pm);\n\n\tif (pm_ops && pm_ops->set_pm_gate)\n\t\treturn pm_ops->set_pm_gate(sdev, flags);\n\n\treturn 0;\n}\n\nstatic int hda_dsp_update_d0i3c_register(struct snd_sof_dev *sdev, u8 value)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_intel_dsp_desc *chip;\n\tint ret;\n\tu8 reg;\n\n\tchip = get_chip_info(pdata);\n\n\t \n\tret = hda_dsp_wait_d0i3c_done(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"CIP timeout before D0I3C update!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update8(sdev, HDA_DSP_HDA_BAR, chip->d0i3_offset,\n\t\t\t    SOF_HDA_VS_D0I3C_I3, value);\n\n\t \n\tusleep_range(30, 40);\n\n\t \n\tret = hda_dsp_wait_d0i3c_done(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"CIP timeout after D0I3C update!\\n\");\n\t\treturn ret;\n\t}\n\n\treg = snd_sof_dsp_read8(sdev, HDA_DSP_HDA_BAR, chip->d0i3_offset);\n\t \n\tif ((reg ^ value) & SOF_HDA_VS_D0I3C_I3) {\n\t\tdev_err(sdev->dev, \"failed to update D0I3C!\\n\");\n\t\treturn -EIO;\n\t}\n\n\ttrace_sof_intel_D0I3C_updated(sdev, reg);\n\n\treturn 0;\n}\n\n \nstatic bool hda_dsp_d0i3_streaming_applicable(struct snd_sof_dev *sdev)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_sof_pcm *spcm;\n\tbool playback_active = false;\n\tint dir;\n\n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tfor_each_pcm_streams(dir) {\n\t\t\tsubstream = spcm->stream[dir].substream;\n\t\t\tif (!substream || !substream->runtime)\n\t\t\t\tcontinue;\n\n\t\t\tif (!spcm->stream[dir].d0i3_compatible)\n\t\t\t\treturn false;\n\n\t\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tplayback_active = true;\n\t\t}\n\t}\n\n\treturn playback_active;\n}\n\nstatic int hda_dsp_set_D0_state(struct snd_sof_dev *sdev,\n\t\t\t\tconst struct sof_dsp_power_state *target_state)\n{\n\tu32 flags = 0;\n\tint ret;\n\tu8 value = 0;\n\n\t \n\tswitch (sdev->dsp_power_state.state) {\n\tcase SOF_DSP_PM_D0:\n\t\t \n\t\tbreak;\n\tcase SOF_DSP_PM_D3:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: transition from %d to %d not allowed\\n\",\n\t\t\tsdev->dsp_power_state.state, target_state->state);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (target_state->substate == SOF_HDA_DSP_PM_D0I3) {\n\t\tvalue = SOF_HDA_VS_D0I3C_I3;\n\n\t\t \n\t\tif (!sdev->fw_trace_is_supported ||\n\t\t    !hda_enable_trace_D0I3_S0 ||\n\t\t    sdev->system_suspend_target != SOF_SUSPEND_NONE)\n\t\t\tflags = HDA_PM_NO_DMA_TRACE;\n\n\t\tif (hda_dsp_d0i3_streaming_applicable(sdev))\n\t\t\tflags |= HDA_PM_PG_STREAMING;\n\t} else {\n\t\t \n\t\tflags = HDA_PM_PPG;\n\t}\n\n\t \n\tret = hda_dsp_update_d0i3c_register(sdev, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = hda_dsp_send_pm_gate_ipc(sdev, flags);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: PM_GATE ipc error %d\\n\", ret);\n\t\tgoto revert;\n\t}\n\n\treturn ret;\n\nrevert:\n\t \n\tvalue = value ? 0 : SOF_HDA_VS_D0I3C_I3;\n\n\t \n\thda_dsp_update_d0i3c_register(sdev, value);\n\n\treturn ret;\n}\n\n \nstatic void hda_dsp_state_log(struct snd_sof_dev *sdev)\n{\n\tswitch (sdev->dsp_power_state.state) {\n\tcase SOF_DSP_PM_D0:\n\t\tswitch (sdev->dsp_power_state.substate) {\n\t\tcase SOF_HDA_DSP_PM_D0I0:\n\t\t\tdev_dbg(sdev->dev, \"Current DSP power state: D0I0\\n\");\n\t\t\tbreak;\n\t\tcase SOF_HDA_DSP_PM_D0I3:\n\t\t\tdev_dbg(sdev->dev, \"Current DSP power state: D0I3\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(sdev->dev, \"Unknown DSP D0 substate: %d\\n\",\n\t\t\t\tsdev->dsp_power_state.substate);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOF_DSP_PM_D1:\n\t\tdev_dbg(sdev->dev, \"Current DSP power state: D1\\n\");\n\t\tbreak;\n\tcase SOF_DSP_PM_D2:\n\t\tdev_dbg(sdev->dev, \"Current DSP power state: D2\\n\");\n\t\tbreak;\n\tcase SOF_DSP_PM_D3:\n\t\tdev_dbg(sdev->dev, \"Current DSP power state: D3\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sdev->dev, \"Unknown DSP power state: %d\\n\",\n\t\t\tsdev->dsp_power_state.state);\n\t\tbreak;\n\t}\n}\n\n \nstatic int hda_dsp_set_power_state(struct snd_sof_dev *sdev,\n\t\t\t\t   const struct sof_dsp_power_state *target_state)\n{\n\tint ret = 0;\n\n\tswitch (target_state->state) {\n\tcase SOF_DSP_PM_D0:\n\t\tret = hda_dsp_set_D0_state(sdev, target_state);\n\t\tbreak;\n\tcase SOF_DSP_PM_D3:\n\t\t \n\t\tif (sdev->dsp_power_state.state == SOF_DSP_PM_D0 &&\n\t\t    sdev->dsp_power_state.substate == SOF_HDA_DSP_PM_D0I0)\n\t\t\tbreak;\n\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: transition from %d to %d not allowed\\n\",\n\t\t\tsdev->dsp_power_state.state, target_state->state);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: target state unsupported %d\\n\",\n\t\t\ttarget_state->state);\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"failed to set requested target DSP state %d substate %d\\n\",\n\t\t\ttarget_state->state, target_state->substate);\n\t\treturn ret;\n\t}\n\n\tsdev->dsp_power_state = *target_state;\n\thda_dsp_state_log(sdev);\n\treturn ret;\n}\n\nint hda_dsp_set_power_state_ipc3(struct snd_sof_dev *sdev,\n\t\t\t\t const struct sof_dsp_power_state *target_state)\n{\n\t \n\tif (target_state->substate == SOF_HDA_DSP_PM_D0I3 &&\n\t    sdev->system_suspend_target == SOF_SUSPEND_S0IX)\n\t\treturn hda_dsp_set_power_state(sdev, target_state);\n\n\t \n\tif (target_state->state == sdev->dsp_power_state.state &&\n\t    target_state->substate == sdev->dsp_power_state.substate)\n\t\treturn 0;\n\n\treturn hda_dsp_set_power_state(sdev, target_state);\n}\n\nint hda_dsp_set_power_state_ipc4(struct snd_sof_dev *sdev,\n\t\t\t\t const struct sof_dsp_power_state *target_state)\n{\n\t \n\tif (target_state->state == sdev->dsp_power_state.state &&\n\t    target_state->substate == sdev->dsp_power_state.substate)\n\t\treturn 0;\n\n\treturn hda_dsp_set_power_state(sdev, target_state);\n}\n\n \n\nstatic int hda_suspend(struct snd_sof_dev *sdev, bool runtime_suspend)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tint ret, j;\n\n\t \n\tif (sdev->system_suspend_target > SOF_SUSPEND_S3 ||\n\t    sdev->fw_state == SOF_FW_CRASHED ||\n\t    sdev->fw_state == SOF_FW_BOOT_FAILED)\n\t\thda->skip_imr_boot = true;\n\n\tret = chip->disable_interrupts(sdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thda_codec_jack_wake_enable(sdev, runtime_suspend);\n\n\t \n\thda_bus_ml_suspend(bus);\n\n\tif (sdev->dspless_mode_selected)\n\t\tgoto skip_dsp;\n\n\tret = chip->power_down_dsp(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to power down DSP during suspend\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (j = 0; j < chip->cores_num; j++)\n\t\tsdev->dsp_core_ref_count[j] = 0;\n\n\t \n\thda_dsp_ctrl_ppcap_enable(sdev, false);\n\thda_dsp_ctrl_ppcap_int_enable(sdev, false);\nskip_dsp:\n\n\t \n\thda_dsp_ctrl_stop_chip(sdev);\n\n\t \n\tsnd_sof_pci_update_bits(sdev, PCI_PGCTL,\n\t\t\t\tPCI_PGCTL_LSRMD_MASK, PCI_PGCTL_LSRMD_MASK);\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, true);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to reset controller during suspend\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\thda_codec_i915_display_power(sdev, false);\n\n\treturn 0;\n}\n\nstatic int hda_resume(struct snd_sof_dev *sdev, bool runtime_resume)\n{\n\tint ret;\n\n\t \n\thda_codec_i915_display_power(sdev, true);\n\n\t \n\tsnd_sof_pci_update_bits(sdev, PCI_TCSEL, 0x07, 0);\n\n\t \n\tret = hda_dsp_ctrl_init_chip(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to start controller after resume\\n\");\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (runtime_resume) {\n\t\thda_codec_jack_wake_enable(sdev, false);\n\t\tif (sdev->system_suspend_target == SOF_SUSPEND_NONE)\n\t\t\thda_codec_jack_check(sdev);\n\t}\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\thda_dsp_ctrl_ppcap_enable(sdev, true);\n\t\thda_dsp_ctrl_ppcap_int_enable(sdev, true);\n\t}\n\ncleanup:\n\t \n\thda_codec_i915_display_power(sdev, false);\n\n\treturn 0;\n}\n\nint hda_dsp_resume(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tconst struct sof_dsp_power_state target_state = {\n\t\t.state = SOF_DSP_PM_D0,\n\t\t.substate = SOF_HDA_DSP_PM_D0I0,\n\t};\n\tint ret;\n\n\t \n\tif (sdev->dsp_power_state.state == SOF_DSP_PM_D0) {\n\t\tret = hda_bus_ml_resume(bus);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error %d in %s: failed to power up links\",\n\t\t\t\tret, __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\thda_codec_resume_cmd_io(sdev);\n\n\t\t \n\t\tret = snd_sof_dsp_set_power_state(sdev, &target_state);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: setting dsp state %d substate %d\\n\",\n\t\t\t\ttarget_state.state, target_state.substate);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (hda->l1_disabled)\n\t\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t\tHDA_VS_INTEL_EM2,\n\t\t\t\t\t\tHDA_VS_INTEL_EM2_L1SEN, 0);\n\n\t\t \n\t\tpci_restore_state(pci);\n\t\tdisable_irq_wake(pci->irq);\n\t\treturn 0;\n\t}\n\n\t \n\tret = hda_resume(sdev, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_sof_dsp_set_power_state(sdev, &target_state);\n}\n\nint hda_dsp_runtime_resume(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_dsp_power_state target_state = {\n\t\t.state = SOF_DSP_PM_D0,\n\t};\n\tint ret;\n\n\t \n\tret = hda_resume(sdev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_sof_dsp_set_power_state(sdev, &target_state);\n}\n\nint hda_dsp_runtime_idle(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *hbus = sof_to_bus(sdev);\n\n\tif (hbus->codec_powered) {\n\t\tdev_dbg(sdev->dev, \"some codecs still powered (%08X), not idle\\n\",\n\t\t\t(unsigned int)hbus->codec_powered);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint hda_dsp_runtime_suspend(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_dsp_power_state target_state = {\n\t\t.state = SOF_DSP_PM_D3,\n\t};\n\tint ret;\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\tcancel_delayed_work_sync(&hda->d0i3_work);\n\t}\n\n\t \n\tret = hda_suspend(sdev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_sof_dsp_set_power_state(sdev, &target_state);\n}\n\nint hda_dsp_suspend(struct snd_sof_dev *sdev, u32 target_state)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tconst struct sof_dsp_power_state target_dsp_state = {\n\t\t.state = target_state,\n\t\t.substate = target_state == SOF_DSP_PM_D0 ?\n\t\t\t\tSOF_HDA_DSP_PM_D0I3 : 0,\n\t};\n\tint ret;\n\n\tif (!sdev->dspless_mode_selected) {\n\t\t \n\t\tcancel_delayed_work_sync(&hda->d0i3_work);\n\t}\n\n\tif (target_state == SOF_DSP_PM_D0) {\n\t\t \n\t\tret = snd_sof_dsp_set_power_state(sdev, &target_dsp_state);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: setting dsp state %d substate %d\\n\",\n\t\t\t\ttarget_dsp_state.state,\n\t\t\t\ttarget_dsp_state.substate);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (hda->l1_disabled)\n\t\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_EM2,\n\t\t\t\t\t\tHDA_VS_INTEL_EM2_L1SEN, HDA_VS_INTEL_EM2_L1SEN);\n\n\t\t \n\t\thda_codec_suspend_cmd_io(sdev);\n\n\t\t \n\t\tret = hda_bus_ml_suspend(bus);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error %d in %s: failed to power down links\",\n\t\t\t\tret, __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tenable_irq_wake(pci->irq);\n\t\tpci_save_state(pci);\n\t\treturn 0;\n\t}\n\n\t \n\tret = hda_suspend(sdev, false);\n\tif (ret < 0) {\n\t\tdev_err(bus->dev, \"error: suspending dsp\\n\");\n\t\treturn ret;\n\t}\n\n\treturn snd_sof_dsp_set_power_state(sdev, &target_dsp_state);\n}\n\nstatic unsigned int hda_dsp_check_for_dma_streams(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_stream *s;\n\tunsigned int active_streams = 0;\n\tint sd_offset;\n\tu32 val;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tsd_offset = SOF_STREAM_SD_OFFSET(s);\n\t\tval = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t       sd_offset);\n\t\tif (val & SOF_HDA_SD_CTL_DMA_START)\n\t\t\tactive_streams |= BIT(s->index);\n\t}\n\n\treturn active_streams;\n}\n\nstatic int hda_dsp_s5_quirk(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\t \n\tusleep_range(500, 1000);\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(500, 1000);\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nint hda_dsp_shutdown_dma_flush(struct snd_sof_dev *sdev)\n{\n\tunsigned int active_streams;\n\tint ret, ret2;\n\n\t \n\tactive_streams = hda_dsp_check_for_dma_streams(sdev);\n\n\tsdev->system_suspend_target = SOF_SUSPEND_S3;\n\tret = snd_sof_suspend(sdev->dev);\n\n\tif (active_streams) {\n\t\tdev_warn(sdev->dev,\n\t\t\t \"There were active DSP streams (%#x) at shutdown, trying to recover\\n\",\n\t\t\t active_streams);\n\t\tret2 = hda_dsp_s5_quirk(sdev);\n\t\tif (ret2 < 0)\n\t\t\tdev_err(sdev->dev, \"shutdown recovery failed (%d)\\n\", ret2);\n\t}\n\n\treturn ret;\n}\n\nint hda_dsp_shutdown(struct snd_sof_dev *sdev)\n{\n\tsdev->system_suspend_target = SOF_SUSPEND_S3;\n\treturn snd_sof_suspend(sdev->dev);\n}\n\nint hda_dsp_set_hw_params_upon_resume(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\t \n\tret = hda_dsp_dais_suspend(sdev);\n\tif (ret < 0)\n\t\tdev_warn(sdev->dev, \"%s: failure in hda_dsp_dais_suspend\\n\", __func__);\n\n\treturn ret;\n}\n\nvoid hda_dsp_d0i3_work(struct work_struct *work)\n{\n\tstruct sof_intel_hda_dev *hdev = container_of(work,\n\t\t\t\t\t\t      struct sof_intel_hda_dev,\n\t\t\t\t\t\t      d0i3_work.work);\n\tstruct hdac_bus *bus = &hdev->hbus.core;\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(bus->dev);\n\tstruct sof_dsp_power_state target_state = {\n\t\t.state = SOF_DSP_PM_D0,\n\t\t.substate = SOF_HDA_DSP_PM_D0I3,\n\t};\n\tint ret;\n\n\t \n\tif (!snd_sof_dsp_only_d0i3_compatible_stream_active(sdev))\n\t\t \n\t\treturn;\n\n\t \n\tret = snd_sof_dsp_set_power_state(sdev, &target_state);\n\tif (ret < 0)\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"error: failed to set DSP state %d substate %d\\n\",\n\t\t\t\t    target_state.state, target_state.substate);\n}\n\nint hda_dsp_core_get(struct snd_sof_dev *sdev, int core)\n{\n\tconst struct sof_ipc_pm_ops *pm_ops = sdev->ipc->ops->pm;\n\tint ret, ret1;\n\n\t \n\tret = hda_dsp_enable_core(sdev, BIT(core));\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to power up core %d with err: %d\\n\",\n\t\t\tcore, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (sdev->fw_state != SOF_FW_BOOT_COMPLETE || core == SOF_DSP_PRIMARY_CORE)\n\t\treturn 0;\n\n\t \n\tif (!pm_ops->set_core_state)\n\t\treturn 0;\n\n\t \n\tret = pm_ops->set_core_state(sdev, core, true);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to enable secondary core '%d' failed with %d\\n\",\n\t\t\tcore, ret);\n\t\tgoto power_down;\n\t}\n\n\treturn ret;\n\npower_down:\n\t \n\tret1 = hda_dsp_core_reset_power_down(sdev, BIT(core));\n\tif (ret1 < 0)\n\t\tdev_err(sdev->dev, \"failed to power down core: %d with err: %d\\n\", core, ret1);\n\n\treturn ret;\n}\n\nint hda_dsp_disable_interrupts(struct snd_sof_dev *sdev)\n{\n\thda_sdw_int_enable(sdev, false);\n\thda_dsp_ipc_int_disable(sdev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}