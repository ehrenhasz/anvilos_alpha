{
  "module_name": "hda-pcm.c",
  "hash_id": "626c0c32b1039ed2c8a0f17efbb61f0d93e4a6c3ee5c5f13799c5737109bd965",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/moduleparam.h>\n#include <sound/hda_register.h>\n#include <sound/pcm_params.h>\n#include <trace/events/sof_intel.h>\n#include \"../sof-audio.h\"\n#include \"../ops.h\"\n#include \"hda.h\"\n\n#define SDnFMT_BASE(x)\t((x) << 14)\n#define SDnFMT_MULT(x)\t(((x) - 1) << 11)\n#define SDnFMT_DIV(x)\t(((x) - 1) << 8)\n#define SDnFMT_BITS(x)\t((x) << 4)\n#define SDnFMT_CHAN(x)\t((x) << 0)\n\nstatic bool hda_always_enable_dmi_l1;\nmodule_param_named(always_enable_dmi_l1, hda_always_enable_dmi_l1, bool, 0444);\nMODULE_PARM_DESC(always_enable_dmi_l1, \"SOF HDA always enable DMI l1\");\n\nstatic bool hda_disable_rewinds;\nmodule_param_named(disable_rewinds, hda_disable_rewinds, bool, 0444);\nMODULE_PARM_DESC(disable_rewinds, \"SOF HDA disable rewinds\");\n\nu32 hda_dsp_get_mult_div(struct snd_sof_dev *sdev, int rate)\n{\n\tswitch (rate) {\n\tcase 8000:\n\t\treturn SDnFMT_DIV(6);\n\tcase 9600:\n\t\treturn SDnFMT_DIV(5);\n\tcase 11025:\n\t\treturn SDnFMT_BASE(1) | SDnFMT_DIV(4);\n\tcase 16000:\n\t\treturn SDnFMT_DIV(3);\n\tcase 22050:\n\t\treturn SDnFMT_BASE(1) | SDnFMT_DIV(2);\n\tcase 32000:\n\t\treturn SDnFMT_DIV(3) | SDnFMT_MULT(2);\n\tcase 44100:\n\t\treturn SDnFMT_BASE(1);\n\tcase 48000:\n\t\treturn 0;\n\tcase 88200:\n\t\treturn SDnFMT_BASE(1) | SDnFMT_MULT(2);\n\tcase 96000:\n\t\treturn SDnFMT_MULT(2);\n\tcase 176400:\n\t\treturn SDnFMT_BASE(1) | SDnFMT_MULT(4);\n\tcase 192000:\n\t\treturn SDnFMT_MULT(4);\n\tdefault:\n\t\tdev_warn(sdev->dev, \"can't find div rate %d using 48kHz\\n\",\n\t\t\t rate);\n\t\treturn 0;  \n\t}\n};\n\nu32 hda_dsp_get_bits(struct snd_sof_dev *sdev, int sample_bits)\n{\n\tswitch (sample_bits) {\n\tcase 8:\n\t\treturn SDnFMT_BITS(0);\n\tcase 16:\n\t\treturn SDnFMT_BITS(1);\n\tcase 20:\n\t\treturn SDnFMT_BITS(2);\n\tcase 24:\n\t\treturn SDnFMT_BITS(3);\n\tcase 32:\n\t\treturn SDnFMT_BITS(4);\n\tdefault:\n\t\tdev_warn(sdev->dev, \"can't find %d bits using 16bit\\n\",\n\t\t\t sample_bits);\n\t\treturn SDnFMT_BITS(1);  \n\t}\n};\n\nint hda_dsp_pcm_hw_params(struct snd_sof_dev *sdev,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  struct snd_sof_platform_stream_params *platform_params)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct hdac_ext_stream *hext_stream = stream_to_hdac_ext_stream(hstream);\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct snd_dma_buffer *dmab;\n\tint ret;\n\n\thstream->substream = substream;\n\n\tdmab = substream->runtime->dma_buffer_p;\n\n\t \n\tif (!sdev->dspless_mode_selected) {\n\t\tu32 rate = hda_dsp_get_mult_div(sdev, params_rate(params));\n\t\tu32 bits = hda_dsp_get_bits(sdev, params_width(params));\n\n\t\thstream->format_val = rate | bits | (params_channels(params) - 1);\n\t}\n\n\thstream->bufsize = params_buffer_bytes(params);\n\thstream->period_bytes = params_period_bytes(params);\n\thstream->no_period_wakeup  =\n\t\t\t(params->info & SNDRV_PCM_INFO_NO_PERIOD_WAKEUP) &&\n\t\t\t(params->flags & SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP);\n\n\tret = hda_dsp_stream_hw_params(sdev, hext_stream, dmab, params);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: hdac prepare failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (hda_disable_rewinds)\n\t\thda_dsp_stream_spib_config(sdev, hext_stream, HDA_DSP_SPIB_ENABLE, 0);\n\telse\n\t\thda_dsp_stream_spib_config(sdev, hext_stream, HDA_DSP_SPIB_DISABLE, 0);\n\n\tif (hda)\n\t\tplatform_params->no_ipc_position = hda->no_ipc_position;\n\n\tplatform_params->stream_tag = hstream->stream_tag;\n\n\treturn 0;\n}\n\n \nint hda_dsp_pcm_ack(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tssize_t appl_pos, buf_size;\n\tu32 spib;\n\n\tappl_pos = frames_to_bytes(runtime, runtime->control->appl_ptr);\n\tbuf_size = frames_to_bytes(runtime, runtime->buffer_size);\n\n\tspib = appl_pos % buf_size;\n\n\t \n\tif (!spib)\n\t\tspib = buf_size;\n\n\tsof_io_write(sdev, hstream->spib_addr, spib);\n\n\treturn 0;\n}\n\nint hda_dsp_pcm_trigger(struct snd_sof_dev *sdev,\n\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct hdac_ext_stream *hext_stream = stream_to_hdac_ext_stream(hstream);\n\n\treturn hda_dsp_stream_trigger(sdev, hext_stream, cmd);\n}\n\nsnd_pcm_uframes_t hda_dsp_pcm_pointer(struct snd_sof_dev *sdev,\n\t\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *scomp = sdev->component;\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct snd_sof_pcm *spcm;\n\tsnd_pcm_uframes_t pos;\n\n\tspcm = snd_sof_find_spcm_dai(scomp, rtd);\n\tif (!spcm) {\n\t\tdev_warn_ratelimited(sdev->dev, \"warn: can't find PCM with DAI ID %d\\n\",\n\t\t\t\t     rtd->dai_link->id);\n\t\treturn 0;\n\t}\n\n\tif (hda && !hda->no_ipc_position) {\n\t\t \n\t\tpos = spcm->stream[substream->stream].posn.host_posn;\n\t\tgoto found;\n\t}\n\n\tpos = hda_dsp_stream_get_position(hstream, substream->stream, true);\nfound:\n\tpos = bytes_to_frames(substream->runtime, pos);\n\n\ttrace_sof_intel_hda_dsp_pcm(sdev, hstream, substream, pos);\n\treturn pos;\n}\n\nint hda_dsp_pcm_open(struct snd_sof_dev *sdev,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_component *scomp = sdev->component;\n\tstruct hdac_ext_stream *dsp_stream;\n\tstruct snd_sof_pcm *spcm;\n\tint direction = substream->stream;\n\tu32 flags = 0;\n\n\tspcm = snd_sof_find_spcm_dai(scomp, rtd);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev, \"error: can't find PCM with DAI ID %d\\n\", rtd->dai_link->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (hda_disable_rewinds)\n\t\truntime->hw.info |= SNDRV_PCM_INFO_NO_REWINDS | SNDRV_PCM_INFO_SYNC_APPLPTR;\n\n\t \n\tif (hda_always_enable_dmi_l1 && direction == SNDRV_PCM_STREAM_CAPTURE)\n\t\truntime->hw.info &= ~SNDRV_PCM_INFO_PAUSE;\n\n\tif (hda_always_enable_dmi_l1 ||\n\t    direction == SNDRV_PCM_STREAM_PLAYBACK ||\n\t    spcm->stream[substream->stream].d0i3_compatible)\n\t\tflags |= SOF_HDA_STREAM_DMI_L1_COMPATIBLE;\n\n\tdsp_stream = hda_dsp_stream_get(sdev, direction, flags);\n\tif (!dsp_stream) {\n\t\tdev_err(sdev->dev, \"error: no stream available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsnd_pcm_hw_constraint_step(substream->runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);\n\n\t \n\tsnd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t      SNDRV_PCM_HW_PARAM_PERIODS);\n\n\t \n\tif (sdev->dspless_mode_selected)\n\t\tsnd_pcm_hw_constraint_mask64(substream->runtime, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t     SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S32);\n\n\t \n\tsubstream->runtime->private_data = &dsp_stream->hstream;\n\treturn 0;\n}\n\nint hda_dsp_pcm_close(struct snd_sof_dev *sdev,\n\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tint direction = substream->stream;\n\tint ret;\n\n\tret = hda_dsp_stream_put(sdev, direction, hstream->stream_tag);\n\n\tif (ret) {\n\t\tdev_dbg(sdev->dev, \"stream %s not opened!\\n\", substream->name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tsubstream->runtime->private_data = NULL;\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}