{
  "module_name": "hda-loader.c",
  "hash_id": "29682779748cb6d8e9e26fc5d16469fd9204feeab5a5ddebaadbe5b45d64e852",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/firmware.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/sof.h>\n#include <sound/sof/ipc4/header.h>\n#include \"ext_manifest.h\"\n#include \"../ipc4-priv.h\"\n#include \"../ops.h\"\n#include \"../sof-priv.h\"\n#include \"hda.h\"\n\nstatic void hda_ssp_set_cbp_cfp(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tint i;\n\n\t \n\tfor (i = 0; i < chip->ssp_count; i++) {\n\t\tsnd_sof_dsp_update_bits_unlocked(sdev, HDA_DSP_BAR,\n\t\t\t\t\t\t chip->ssp_base_offset\n\t\t\t\t\t\t + i * SSP_DEV_MEM_SIZE\n\t\t\t\t\t\t + SSP_SSC1_OFFSET,\n\t\t\t\t\t\t SSP_SET_CBP_CFP,\n\t\t\t\t\t\t SSP_SET_CBP_CFP);\n\t}\n}\n\nstruct hdac_ext_stream *hda_cl_stream_prepare(struct snd_sof_dev *sdev, unsigned int format,\n\t\t\t\t\t      unsigned int size, struct snd_dma_buffer *dmab,\n\t\t\t\t\t      int direction)\n{\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *hstream;\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tint ret;\n\n\thext_stream = hda_dsp_stream_get(sdev, direction, 0);\n\n\tif (!hext_stream) {\n\t\tdev_err(sdev->dev, \"error: no stream available\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\thstream = &hext_stream->hstream;\n\thstream->substream = NULL;\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG, &pci->dev, size, dmab);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: memory alloc failed: %d\\n\", ret);\n\t\tgoto out_put;\n\t}\n\n\thstream->period_bytes = 0; \n\thstream->format_val = format;\n\thstream->bufsize = size;\n\n\tif (direction == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tret = hda_dsp_iccmax_stream_hw_params(sdev, hext_stream, dmab, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: iccmax stream prepare failed: %d\\n\", ret);\n\t\t\tgoto out_free;\n\t\t}\n\t} else {\n\t\tret = hda_dsp_stream_hw_params(sdev, hext_stream, dmab, NULL);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: hdac prepare failed: %d\\n\", ret);\n\t\t\tgoto out_free;\n\t\t}\n\t\thda_dsp_stream_spib_config(sdev, hext_stream, HDA_DSP_SPIB_ENABLE, size);\n\t}\n\n\treturn hext_stream;\n\nout_free:\n\tsnd_dma_free_pages(dmab);\nout_put:\n\thda_dsp_stream_put(sdev, direction, hstream->stream_tag);\n\treturn ERR_PTR(ret);\n}\n\n \nint cl_dsp_init(struct snd_sof_dev *sdev, int stream_tag, bool imr_boot)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tunsigned int status, target_status;\n\tu32 flags, ipc_hdr, j;\n\tunsigned long mask;\n\tchar *dump_msg;\n\tint ret;\n\n\t \n\tret = hda_dsp_core_power_up(sdev, chip->host_managed_cores_mask);\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev, \"error: dsp core 0/1 power up failed\\n\");\n\t\tgoto err;\n\t}\n\n\thda_ssp_set_cbp_cfp(sdev);\n\n\t \n\tipc_hdr = chip->ipc_req_mask | HDA_DSP_ROM_IPC_CONTROL;\n\tif (!imr_boot)\n\t\tipc_hdr |= HDA_DSP_ROM_IPC_PURGE_FW | ((stream_tag - 1) << 9);\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, chip->ipc_req, ipc_hdr);\n\n\t \n\tret = hda_dsp_core_run(sdev, chip->init_core_mask);\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: dsp core start failed %d\\n\", ret);\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\t    chip->ipc_ack, status,\n\t\t\t\t\t    ((status & chip->ipc_ack_mask)\n\t\t\t\t\t\t    == chip->ipc_ack_mask),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_INIT_TIMEOUT_US);\n\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: %s: timeout for HIPCIE done\\n\",\n\t\t\t\t__func__);\n\t\tgoto err;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR,\n\t\t\t\t       chip->ipc_ack,\n\t\t\t\t       chip->ipc_ack_mask,\n\t\t\t\t       chip->ipc_ack_mask);\n\n\t \n\tret = hda_dsp_core_reset_power_down(sdev, chip->host_managed_cores_mask &\n\t\t\t\t\t   ~(chip->init_core_mask));\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: dsp core x power down failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\thda_dsp_ipc_int_enable(sdev);\n\n\t \n\tif (imr_boot)\n\t\ttarget_status = FSR_STATE_FW_ENTERED;\n\telse\n\t\ttarget_status = FSR_STATE_INIT_DONE;\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\tchip->rom_status_reg, status,\n\t\t\t\t\t(FSR_TO_STATE_CODE(status) == target_status),\n\t\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\tchip->rom_init_timeout *\n\t\t\t\t\tUSEC_PER_MSEC);\n\tif (!ret) {\n\t\t \n\t\tsdev->enabled_cores_mask |= chip->init_core_mask;\n\t\tmask = sdev->enabled_cores_mask;\n\t\tfor_each_set_bit(j, &mask, SOF_MAX_DSP_NUM_CORES)\n\t\t\tsdev->dsp_core_ref_count[j]++;\n\t\treturn 0;\n\t}\n\n\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: timeout with rom_status_reg (%#x) read\\n\",\n\t\t\t__func__, chip->rom_status_reg);\n\nerr:\n\tflags = SOF_DBG_DUMP_PCI | SOF_DBG_DUMP_MBOX | SOF_DBG_DUMP_OPTIONAL;\n\n\t \n\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\tflags &= ~SOF_DBG_DUMP_OPTIONAL;\n\n\tdump_msg = kasprintf(GFP_KERNEL, \"Boot iteration failed: %d/%d\",\n\t\t\t     hda->boot_iteration, HDA_FW_BOOT_ATTEMPTS);\n\tsnd_sof_dsp_dbg_dump(sdev, dump_msg, flags);\n\thda_dsp_core_reset_power_down(sdev, chip->host_managed_cores_mask);\n\n\tkfree(dump_msg);\n\treturn ret;\n}\n\nstatic int cl_trigger(struct snd_sof_dev *sdev,\n\t\t      struct hdac_ext_stream *hext_stream, int cmd)\n{\n\tstruct hdac_stream *hstream = &hext_stream->hstream;\n\tint sd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\t\t1 << hstream->index,\n\t\t\t\t\t1 << hstream->index);\n\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tsd_offset,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START |\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START |\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK);\n\n\t\thstream->running = true;\n\t\treturn 0;\n\tdefault:\n\t\treturn hda_dsp_stream_trigger(sdev, hext_stream, cmd);\n\t}\n}\n\nint hda_cl_cleanup(struct snd_sof_dev *sdev, struct snd_dma_buffer *dmab,\n\t\t   struct hdac_ext_stream *hext_stream)\n{\n\tstruct hdac_stream *hstream = &hext_stream->hstream;\n\tint sd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\tint ret = 0;\n\n\tif (hstream->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tret = hda_dsp_stream_spib_config(sdev, hext_stream, HDA_DSP_SPIB_DISABLE, 0);\n\telse\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START, 0);\n\n\thda_dsp_stream_put(sdev, hstream->direction, hstream->stream_tag);\n\thstream->running = 0;\n\thstream->substream = NULL;\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL, 0);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU, 0);\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, sd_offset, 0);\n\tsnd_dma_free_pages(dmab);\n\tdmab->area = NULL;\n\thstream->bufsize = 0;\n\thstream->format_val = 0;\n\n\treturn ret;\n}\n\nint hda_cl_copy_fw(struct snd_sof_dev *sdev, struct hdac_ext_stream *hext_stream)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tunsigned int reg;\n\tint ret, status;\n\n\tret = cl_trigger(sdev, hext_stream, SNDRV_PCM_TRIGGER_START);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: DMA trigger start failed\\n\");\n\t\treturn ret;\n\t}\n\n\tstatus = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\tchip->rom_status_reg, reg,\n\t\t\t\t\t(FSR_TO_STATE_CODE(reg) == FSR_STATE_FW_ENTERED),\n\t\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\tHDA_DSP_BASEFW_TIMEOUT_US);\n\n\t \n\n\tif (status < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: timeout with rom_status_reg (%#x) read\\n\",\n\t\t\t__func__, chip->rom_status_reg);\n\t}\n\n\tret = cl_trigger(sdev, hext_stream, SNDRV_PCM_TRIGGER_STOP);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: DMA trigger stop failed\\n\");\n\t\tif (!status)\n\t\t\tstatus = ret;\n\t}\n\n\treturn status;\n}\n\nint hda_dsp_cl_boot_firmware_iccmax(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_ext_stream *iccmax_stream;\n\tstruct snd_dma_buffer dmab_bdl;\n\tint ret, ret1;\n\tu8 original_gb;\n\n\t \n\toriginal_gb = snd_sof_dsp_read8(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_LTRP) &\n\t\tHDA_VS_INTEL_LTRP_GB_MASK;\n\n\t \n\ticcmax_stream = hda_cl_stream_prepare(sdev, HDA_CL_STREAM_FORMAT, PAGE_SIZE,\n\t\t\t\t\t      &dmab_bdl, SNDRV_PCM_STREAM_CAPTURE);\n\tif (IS_ERR(iccmax_stream)) {\n\t\tdev_err(sdev->dev, \"error: dma prepare for ICCMAX stream failed\\n\");\n\t\treturn PTR_ERR(iccmax_stream);\n\t}\n\n\tret = hda_dsp_cl_boot_firmware(sdev);\n\n\t \n\tret1 = hda_cl_cleanup(sdev, &dmab_bdl, iccmax_stream);\n\tif (ret1 < 0) {\n\t\tdev_err(sdev->dev, \"error: ICCMAX stream cleanup failed\\n\");\n\n\t\t \n\t\tif (!ret)\n\t\t\tret = ret1;\n\t}\n\n\t \n\tsnd_sof_dsp_update8(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_LTRP,\n\t\t\t    HDA_VS_INTEL_LTRP_GB_MASK, original_gb);\n\n\treturn ret;\n}\n\nstatic int hda_dsp_boot_imr(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_intel_dsp_desc *chip_info;\n\tint ret;\n\n\tchip_info = get_chip_info(sdev->pdata);\n\tif (chip_info->cl_init)\n\t\tret = chip_info->cl_init(sdev, 0, true);\n\telse\n\t\tret = -EINVAL;\n\n\tif (!ret)\n\t\thda_sdw_process_wakeen(sdev);\n\n\treturn ret;\n}\n\nint hda_dsp_cl_boot_firmware(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tconst struct sof_dev_desc *desc = plat_data->desc;\n\tconst struct sof_intel_dsp_desc *chip_info;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct firmware stripped_firmware;\n\tstruct snd_dma_buffer dmab;\n\tint ret, ret1, i;\n\n\tif (hda->imrboot_supported && !sdev->first_boot && !hda->skip_imr_boot) {\n\t\tdev_dbg(sdev->dev, \"IMR restore supported, booting from IMR directly\\n\");\n\t\thda->boot_iteration = 0;\n\t\tret = hda_dsp_boot_imr(sdev);\n\t\tif (!ret) {\n\t\t\thda->booted_from_imr = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_warn(sdev->dev, \"IMR restore failed, trying to cold boot\\n\");\n\t}\n\n\thda->booted_from_imr = false;\n\n\tchip_info = desc->chip_info;\n\n\tif (sdev->basefw.fw->size <= sdev->basefw.payload_offset) {\n\t\tdev_err(sdev->dev, \"error: firmware size must be greater than firmware offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstripped_firmware.data = sdev->basefw.fw->data + sdev->basefw.payload_offset;\n\tstripped_firmware.size = sdev->basefw.fw->size - sdev->basefw.payload_offset;\n\n\t \n\tinit_waitqueue_head(&sdev->boot_wait);\n\n\t \n\thext_stream = hda_cl_stream_prepare(sdev, HDA_CL_STREAM_FORMAT,\n\t\t\t\t\t    stripped_firmware.size,\n\t\t\t\t\t    &dmab, SNDRV_PCM_STREAM_PLAYBACK);\n\tif (IS_ERR(hext_stream)) {\n\t\tdev_err(sdev->dev, \"error: dma prepare for fw loading failed\\n\");\n\t\treturn PTR_ERR(hext_stream);\n\t}\n\n\tmemcpy(dmab.area, stripped_firmware.data,\n\t       stripped_firmware.size);\n\n\t \n\tfor (i = 0; i < HDA_FW_BOOT_ATTEMPTS; i++) {\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"Attempting iteration %d of Core En/ROM load...\\n\", i);\n\n\t\thda->boot_iteration = i + 1;\n\t\tif (chip_info->cl_init)\n\t\t\tret = chip_info->cl_init(sdev, hext_stream->hstream.stream_tag, false);\n\t\telse\n\t\t\tret = -EINVAL;\n\n\t\t \n\t\tif (!ret)\n\t\t\tbreak;\n\t}\n\n\tif (i == HDA_FW_BOOT_ATTEMPTS) {\n\t\tdev_err(sdev->dev, \"error: dsp init failed after %d attempts with err: %d\\n\",\n\t\t\ti, ret);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tif (!sdev->first_boot)\n\t\thda_sdw_process_wakeen(sdev);\n\n\t \n\thda->boot_iteration = HDA_FW_BOOT_ATTEMPTS;\n\tret = hda_cl_copy_fw(sdev, hext_stream);\n\tif (!ret) {\n\t\tdev_dbg(sdev->dev, \"Firmware download successful, booting...\\n\");\n\t\thda->skip_imr_boot = false;\n\t} else {\n\t\tsnd_sof_dsp_dbg_dump(sdev, \"Firmware download failed\",\n\t\t\t\t     SOF_DBG_DUMP_PCI | SOF_DBG_DUMP_MBOX);\n\t\thda->skip_imr_boot = true;\n\t}\n\ncleanup:\n\t \n\tret1 = hda_cl_cleanup(sdev, &dmab, hext_stream);\n\tif (ret1 < 0) {\n\t\tdev_err(sdev->dev, \"error: Code loader DSP cleanup failed\\n\");\n\n\t\t \n\t\tif (!ret)\n\t\t\tret = ret1;\n\t}\n\n\t \n\tif (!ret)\n\t\treturn chip_info->init_core_mask;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR,\n\t\t\t\tSOF_HDA_REG_PP_PPCTL,\n\t\t\t\tSOF_HDA_PPCTL_GPROCEN, 0);\n\treturn ret;\n}\n\nint hda_dsp_ipc4_load_library(struct snd_sof_dev *sdev,\n\t\t\t      struct sof_ipc4_fw_library *fw_lib, bool reload)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct firmware stripped_firmware;\n\tstruct sof_ipc4_msg msg = {};\n\tstruct snd_dma_buffer dmab;\n\tint ret, ret1;\n\n\t \n\tif (reload && hda->booted_from_imr)\n\t\treturn 0;\n\n\t \n\tstripped_firmware.data = fw_lib->sof_fw.fw->data + fw_lib->sof_fw.payload_offset;\n\tstripped_firmware.size = fw_lib->sof_fw.fw->size - fw_lib->sof_fw.payload_offset;\n\n\t \n\thext_stream = hda_cl_stream_prepare(sdev, HDA_CL_STREAM_FORMAT,\n\t\t\t\t\t    stripped_firmware.size,\n\t\t\t\t\t    &dmab, SNDRV_PCM_STREAM_PLAYBACK);\n\tif (IS_ERR(hext_stream)) {\n\t\tdev_err(sdev->dev, \"%s: DMA prepare failed\\n\", __func__);\n\t\treturn PTR_ERR(hext_stream);\n\t}\n\n\tmemcpy(dmab.area, stripped_firmware.data, stripped_firmware.size);\n\n\tmsg.primary = hext_stream->hstream.stream_tag - 1;\n\tmsg.primary |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_LOAD_LIBRARY);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\tmsg.primary |= SOF_IPC4_GLB_LOAD_LIBRARY_LIB_ID(fw_lib->id);\n\n\tret = cl_trigger(sdev, hext_stream, SNDRV_PCM_TRIGGER_START);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: DMA trigger start failed\\n\", __func__);\n\t\tgoto cleanup;\n\t}\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n\n\tret1 = cl_trigger(sdev, hext_stream, SNDRV_PCM_TRIGGER_STOP);\n\tif (ret1 < 0) {\n\t\tdev_err(sdev->dev, \"%s: DMA trigger stop failed\\n\", __func__);\n\t\tif (!ret)\n\t\t\tret = ret1;\n\t}\n\ncleanup:\n\t \n\tret1 = hda_cl_cleanup(sdev, &dmab, hext_stream);\n\tif (ret1 < 0) {\n\t\tdev_err(sdev->dev, \"%s: Code loader DSP cleanup failed\\n\", __func__);\n\n\t\t \n\t\tif (!ret)\n\t\t\tret = ret1;\n\t}\n\n\treturn ret;\n}\n\n \nint hda_dsp_pre_fw_run(struct snd_sof_dev *sdev)\n{\n\t \n\treturn hda_dsp_ctrl_clock_power_gating(sdev, false);\n}\n\n \nint hda_dsp_post_fw_run(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\tif (sdev->first_boot) {\n\t\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t\tret = hda_sdw_startup(sdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: could not startup SoundWire links\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!sof_debug_check_flag(SOF_DBG_IGNORE_D3_PERSISTENT) &&\n\t\t    (sdev->fw_ready.flags & SOF_IPC_INFO_D3_PERSISTENT ||\n\t\t     sdev->pdata->ipc_type == SOF_INTEL_IPC4))\n\t\t\thdev->imrboot_supported = true;\n\t}\n\n\thda_sdw_int_enable(sdev, true);\n\n\t \n\treturn hda_dsp_ctrl_clock_power_gating(sdev, true);\n}\n\nint hda_dsp_ext_man_get_cavs_config_data(struct snd_sof_dev *sdev,\n\t\t\t\t\t const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct sof_ext_man_cavs_config_data *config_data =\n\t\tcontainer_of(hdr, struct sof_ext_man_cavs_config_data, hdr);\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tint i, elem_num;\n\n\t \n\telem_num = (hdr->size - sizeof(struct sof_ext_man_elem_header))\n\t\t   / sizeof(struct sof_config_elem);\n\tif (elem_num <= 0) {\n\t\tdev_err(sdev->dev, \"cavs config data is inconsistent: %d\\n\", elem_num);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < elem_num; i++)\n\t\tswitch (config_data->elems[i].token) {\n\t\tcase SOF_EXT_MAN_CAVS_CONFIG_EMPTY:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_CAVS_CONFIG_CAVS_LPRO:\n\t\t\thda->clk_config_lpro = config_data->elems[i].value;\n\t\t\tdev_dbg(sdev->dev, \"FW clock config: %s\\n\",\n\t\t\t\thda->clk_config_lpro ? \"LPRO\" : \"HPRO\");\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_CAVS_CONFIG_OUTBOX_SIZE:\n\t\tcase SOF_EXT_MAN_CAVS_CONFIG_INBOX_SIZE:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(sdev->dev, \"unsupported token type: %d\\n\",\n\t\t\t\t config_data->elems[i].token);\n\t\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}