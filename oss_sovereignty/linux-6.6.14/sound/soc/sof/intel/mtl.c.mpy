{
  "module_name": "mtl.c",
  "hash_id": "dbeb61a2e526465272bba5e5137c86180cfb1f639cb09ae54f54d07040386e48",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/mtl.c",
  "human_readable_source": "\n\n\n\n\n\n\n \n\n#include <linux/firmware.h>\n#include <sound/sof/ipc4/header.h>\n#include <trace/events/sof_intel.h>\n#include \"../ipc4-priv.h\"\n#include \"../ops.h\"\n#include \"hda.h\"\n#include \"hda-ipc.h\"\n#include \"../sof-audio.h\"\n#include \"mtl.h\"\n\nstatic const struct snd_sof_debugfs_map mtl_dsp_debugfs[] = {\n\t{\"hda\", HDA_DSP_HDA_BAR, 0, 0x4000, SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"pp\", HDA_DSP_PP_BAR,  0, 0x1000, SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dsp\", HDA_DSP_BAR,  0, 0x10000, SOF_DEBUGFS_ACCESS_ALWAYS},\n};\n\nstatic void mtl_ipc_host_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDR,\n\t\t\t\t       MTL_DSP_REG_HFIPCXTDR_BUSY, MTL_DSP_REG_HFIPCXTDR_BUSY);\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDA,\n\t\t\t\t       MTL_DSP_REG_HFIPCXTDA_BUSY, 0);\n}\n\nstatic void mtl_ipc_dsp_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDA,\n\t\t\t\t       MTL_DSP_REG_HFIPCXIDA_DONE, MTL_DSP_REG_HFIPCXIDA_DONE);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXCTL,\n\t\t\t\tMTL_DSP_REG_HFIPCXCTL_DONE, MTL_DSP_REG_HFIPCXCTL_DONE);\n}\n\n \nbool mtl_dsp_check_ipc_irq(struct snd_sof_dev *sdev)\n{\n\tu32 irq_status;\n\tu32 hfintipptr;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn false;\n\n\t \n\thfintipptr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_HFINTIPPTR) & MTL_HFINTIPPTR_PTR_MASK;\n\tirq_status = snd_sof_dsp_read(sdev, HDA_DSP_BAR, hfintipptr + MTL_DSP_IRQSTS);\n\n\ttrace_sof_intel_hda_irq_ipc_check(sdev, irq_status);\n\n\tif (irq_status != U32_MAX && (irq_status & MTL_DSP_IRQSTS_IPC))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool mtl_dsp_check_sdw_irq(struct snd_sof_dev *sdev)\n{\n\tu32 irq_status;\n\tu32 hfintipptr;\n\n\t \n\thfintipptr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_HFINTIPPTR) & MTL_HFINTIPPTR_PTR_MASK;\n\tirq_status = snd_sof_dsp_read(sdev, HDA_DSP_BAR, hfintipptr + MTL_DSP_IRQSTS);\n\n\tif (irq_status != U32_MAX && (irq_status & MTL_DSP_IRQSTS_SDW))\n\t\treturn true;\n\n\treturn false;\n}\n\nint mtl_ipc_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tstruct sof_ipc4_msg *msg_data = msg->msg_data;\n\n\tif (hda_ipc4_tx_is_busy(sdev)) {\n\t\thdev->delayed_ipc_tx_msg = msg;\n\t\treturn 0;\n\t}\n\n\thdev->delayed_ipc_tx_msg = NULL;\n\n\t \n\tif (msg_data->data_size)\n\t\tsof_mailbox_write(sdev, sdev->host_box.offset, msg_data->data_ptr,\n\t\t\t\t  msg_data->data_size);\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDDY,\n\t\t\t  msg_data->extension);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDR,\n\t\t\t  msg_data->primary | MTL_DSP_REG_HFIPCXIDR_BUSY);\n\n\thda_dsp_ipc4_schedule_d0i3_work(hdev, msg);\n\n\treturn 0;\n}\n\nvoid mtl_enable_ipc_interrupts(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\t\tMTL_DSP_REG_HFIPCXCTL_BUSY | MTL_DSP_REG_HFIPCXCTL_DONE,\n\t\t\t\tMTL_DSP_REG_HFIPCXCTL_BUSY | MTL_DSP_REG_HFIPCXCTL_DONE);\n}\n\nvoid mtl_disable_ipc_interrupts(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\t\tMTL_DSP_REG_HFIPCXCTL_BUSY | MTL_DSP_REG_HFIPCXCTL_DONE, 0);\n}\n\nstatic void mtl_enable_sdw_irq(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 hipcie;\n\tu32 mask;\n\tu32 val;\n\tint ret;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn;\n\n\t \n\tmask = MTL_DSP_REG_HfSNDWIE_IE_MASK;\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP_REG_HfSNDWIE, mask, val);\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_DSP_REG_HfSNDWIE, hipcie,\n\t\t\t\t\t    (hipcie & mask) == val,\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US, HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"failed to set SoundWire IPC interrupt %s\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n}\n\nint mtl_enable_interrupts(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 hfintipptr;\n\tu32 irqinten;\n\tu32 hipcie;\n\tu32 mask;\n\tu32 val;\n\tint ret;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn 0;\n\n\t \n\thfintipptr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_HFINTIPPTR) & MTL_HFINTIPPTR_PTR_MASK;\n\n\t \n\tmask = MTL_IRQ_INTEN_L_HOST_IPC_MASK | MTL_IRQ_INTEN_L_SOUNDWIRE_MASK;\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, hfintipptr, mask, val);\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, hfintipptr, irqinten,\n\t\t\t\t\t    (irqinten & mask) == val,\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US, HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to %s Host IPC and/or SOUNDWIRE\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n\t\treturn ret;\n\t}\n\n\t \n\tmask = MTL_DSP_REG_HfHIPCIE_IE_MASK;\n\tif (enable)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP_REG_HfHIPCIE, mask, val);\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_DSP_REG_HfHIPCIE, hipcie,\n\t\t\t\t\t    (hipcie & mask) == val,\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US, HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to set Host IPC interrupt %s\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nint mtl_dsp_pre_fw_run(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tu32 dsphfpwrsts;\n\tu32 dsphfdsscs;\n\tu32 cpa;\n\tu32 pgs;\n\tint ret;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_HFDSSCS,\n\t\t\t\tMTL_HFDSSCS_SPA_MASK, MTL_HFDSSCS_SPA_MASK);\n\n\t \n\tusleep_range(1000, 1010);\n\n\t \n\tcpa = MTL_HFDSSCS_CPA_MASK;\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_HFDSSCS, dsphfdsscs,\n\t\t\t\t\t    (dsphfdsscs & cpa) == cpa, HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to enable DSP subsystem\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_HFPWRCTL,\n\t\t\t\tMTL_HFPWRCTL_WPDSPHPXPG, MTL_HFPWRCTL_WPDSPHPXPG);\n\n\tusleep_range(1000, 1010);\n\n\t \n\tpgs = MTL_HFPWRSTS_DSPHPXPGS_MASK;\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_HFPWRSTS, dsphfpwrsts,\n\t\t\t\t\t    (dsphfpwrsts & pgs) == pgs,\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"failed to power up gated DSP domain\\n\");\n\n\t \n\tif (hdev->info.handle && hdev->info.link_mask > 0)\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_HFPWRCTL,\n\t\t\t\t\tMTL_HfPWRCTL_WPIOXPG(1), MTL_HfPWRCTL_WPIOXPG(1));\n\n\treturn ret;\n}\n\nint mtl_dsp_post_fw_run(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\tif (sdev->first_boot) {\n\t\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t\tret = hda_sdw_startup(sdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"could not startup SoundWire links\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!sof_debug_check_flag(SOF_DBG_IGNORE_D3_PERSISTENT))\n\t\t\thdev->imrboot_supported = true;\n\t}\n\n\thda_sdw_int_enable(sdev, true);\n\treturn 0;\n}\n\nvoid mtl_dsp_dump(struct snd_sof_dev *sdev, u32 flags)\n{\n\tchar *level = (flags & SOF_DBG_DUMP_OPTIONAL) ? KERN_DEBUG : KERN_ERR;\n\tu32 romdbgsts;\n\tu32 romdbgerr;\n\tu32 fwsts;\n\tu32 fwlec;\n\n\tfwsts = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_ROM_STS);\n\tfwlec = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_ROM_ERROR);\n\tromdbgsts = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFFLGPXQWY);\n\tromdbgerr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFFLGPXQWY_ERROR);\n\n\tdev_err(sdev->dev, \"ROM status: %#x, ROM error: %#x\\n\", fwsts, fwlec);\n\tdev_err(sdev->dev, \"ROM debug status: %#x, ROM debug error: %#x\\n\", romdbgsts,\n\t\tromdbgerr);\n\tromdbgsts = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFFLGPXQWY + 0x8 * 3);\n\tdev_printk(level, sdev->dev, \"ROM feature bit%s enabled\\n\",\n\t\t   romdbgsts & BIT(24) ? \"\" : \" not\");\n}\n\nstatic bool mtl_dsp_primary_core_is_enabled(struct snd_sof_dev *sdev)\n{\n\tint val;\n\n\tval = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE);\n\tif (val != U32_MAX && val & MTL_DSP2CXCTL_PRIMARY_CORE_CPA_MASK)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int mtl_dsp_core_power_up(struct snd_sof_dev *sdev, int core)\n{\n\tunsigned int cpa;\n\tu32 dspcxctl;\n\tint ret;\n\n\t \n\tif (core != SOF_DSP_PRIMARY_CORE || mtl_dsp_primary_core_is_enabled(sdev))\n\t\treturn 0;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE,\n\t\t\t\tMTL_DSP2CXCTL_PRIMARY_CORE_OSEL,\n\t\t\t\t0x2 << MTL_DSP2CXCTL_PRIMARY_CORE_OSEL_SHIFT);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE,\n\t\t\t\tMTL_DSP2CXCTL_PRIMARY_CORE_SPA_MASK,\n\t\t\t\tMTL_DSP2CXCTL_PRIMARY_CORE_SPA_MASK);\n\n\t \n\tusleep_range(1000, 1010);\n\n\t \n\tcpa = MTL_DSP2CXCTL_PRIMARY_CORE_CPA_MASK;\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE, dspcxctl,\n\t\t\t\t\t    (dspcxctl & cpa) == cpa, HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_RESET_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: timeout on MTL_DSP2CXCTL_PRIMARY_CORE read\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tsdev->enabled_cores_mask = BIT(SOF_DSP_PRIMARY_CORE);\n\tsdev->dsp_core_ref_count[SOF_DSP_PRIMARY_CORE] = 1;\n\n\treturn 0;\n}\n\nstatic int mtl_dsp_core_power_down(struct snd_sof_dev *sdev, int core)\n{\n\tu32 dspcxctl;\n\tint ret;\n\n\t \n\tif (core != SOF_DSP_PRIMARY_CORE || !mtl_dsp_primary_core_is_enabled(sdev))\n\t\treturn 0;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE,\n\t\t\t\tMTL_DSP2CXCTL_PRIMARY_CORE_SPA_MASK, 0);\n\n\t \n\tusleep_range(1000, 1010);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_DSP2CXCTL_PRIMARY_CORE, dspcxctl,\n\t\t\t\t\t    !(dspcxctl & MTL_DSP2CXCTL_PRIMARY_CORE_CPA_MASK),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_PD_TIMEOUT * USEC_PER_MSEC);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to power down primary core\\n\");\n\t\treturn ret;\n\t}\n\n\tsdev->enabled_cores_mask = 0;\n\tsdev->dsp_core_ref_count[SOF_DSP_PRIMARY_CORE] = 0;\n\n\treturn 0;\n}\n\nint mtl_power_down_dsp(struct snd_sof_dev *sdev)\n{\n\tu32 dsphfdsscs, cpa;\n\tint ret;\n\n\t \n\tret = mtl_dsp_core_power_down(sdev, SOF_DSP_PRIMARY_CORE);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"mtl dsp power down error, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_HFDSSCS,\n\t\t\t\tMTL_HFDSSCS_SPA_MASK, 0);\n\n\t \n\tusleep_range(1000, 1010);\n\n\t \n\tcpa = MTL_HFDSSCS_CPA_MASK;\n\tdsphfdsscs = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_HFDSSCS);\n\treturn snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, MTL_HFDSSCS, dsphfdsscs,\n\t\t\t\t\t     (dsphfdsscs & cpa) == 0, HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t     HDA_DSP_RESET_TIMEOUT_US);\n}\n\nint mtl_dsp_cl_init(struct snd_sof_dev *sdev, int stream_tag, bool imr_boot)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tunsigned int status;\n\tu32 ipc_hdr;\n\tint ret;\n\n\t \n\tipc_hdr = chip->ipc_req_mask | HDA_DSP_ROM_IPC_CONTROL;\n\tif (!imr_boot)\n\t\tipc_hdr |= HDA_DSP_ROM_IPC_PURGE_FW | ((stream_tag - 1) << 9);\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, chip->ipc_req, ipc_hdr);\n\n\t \n\tret = mtl_dsp_core_power_up(sdev, SOF_DSP_PRIMARY_CORE);\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev, \"dsp core 0/1 power up failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_dbg(sdev->dev, \"Primary core power up successful\\n\");\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR, chip->ipc_ack, status,\n\t\t\t\t\t    ((status & chip->ipc_ack_mask) == chip->ipc_ack_mask),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US, HDA_DSP_INIT_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev, \"timeout waiting for purge IPC done\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR, chip->ipc_ack, chip->ipc_ack_mask,\n\t\t\t\t       chip->ipc_ack_mask);\n\n\t \n\tret = mtl_enable_interrupts(sdev, true);\n\tif (ret < 0) {\n\t\tif (hda->boot_iteration == HDA_FW_BOOT_ATTEMPTS)\n\t\t\tdev_err(sdev->dev, \"%s: failed to enable interrupts\\n\", __func__);\n\t\tgoto err;\n\t}\n\n\tmtl_enable_ipc_interrupts(sdev);\n\n\t \n\n\treturn 0;\n\nerr:\n\tsnd_sof_dsp_dbg_dump(sdev, \"MTL DSP init fail\", 0);\n\tmtl_dsp_core_power_down(sdev, SOF_DSP_PRIMARY_CORE);\n\treturn ret;\n}\n\nirqreturn_t mtl_ipc_irq_thread(int irq, void *context)\n{\n\tstruct sof_ipc4_msg notification_data = {{ 0 }};\n\tstruct snd_sof_dev *sdev = context;\n\tbool ack_received = false;\n\tbool ipc_irq = false;\n\tu32 hipcida;\n\tu32 hipctdr;\n\n\thipcida = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDA);\n\thipctdr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDR);\n\n\t \n\tif (hipcida & MTL_DSP_REG_HFIPCXIDA_DONE) {\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXCTL,\n\t\t\t\t\tMTL_DSP_REG_HFIPCXCTL_DONE, 0);\n\n\t\tmtl_ipc_dsp_done(sdev);\n\n\t\tipc_irq = true;\n\t\tack_received = true;\n\t}\n\n\tif (hipctdr & MTL_DSP_REG_HFIPCXTDR_BUSY) {\n\t\t \n\t\tu32 extension = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDDY);\n\t\tu32 primary = hipctdr & MTL_DSP_REG_HFIPCXTDR_MSG_MASK;\n\n\t\t \n\t\tif (primary & SOF_IPC4_MSG_DIR_MASK) {\n\t\t\t \n\t\t\tif (likely(sdev->fw_state == SOF_FW_BOOT_COMPLETE)) {\n\t\t\t\tstruct sof_ipc4_msg *data = sdev->ipc->msg.reply_data;\n\n\t\t\t\tdata->primary = primary;\n\t\t\t\tdata->extension = extension;\n\n\t\t\t\tspin_lock_irq(&sdev->ipc_lock);\n\n\t\t\t\tsnd_sof_ipc_get_reply(sdev);\n\t\t\t\tmtl_ipc_host_done(sdev);\n\t\t\t\tsnd_sof_ipc_reply(sdev, data->primary);\n\n\t\t\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t\t\t} else {\n\t\t\t\tdev_dbg_ratelimited(sdev->dev,\n\t\t\t\t\t\t    \"IPC reply before FW_READY: %#x|%#x\\n\",\n\t\t\t\t\t\t    primary, extension);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tnotification_data.primary = primary;\n\t\t\tnotification_data.extension = extension;\n\n\t\t\tsdev->ipc->msg.rx_data = &notification_data;\n\t\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\t\tsdev->ipc->msg.rx_data = NULL;\n\n\t\t\tmtl_ipc_host_done(sdev);\n\t\t}\n\n\t\tipc_irq = true;\n\t}\n\n\tif (!ipc_irq) {\n\t\t \n\t\tdev_dbg_ratelimited(sdev->dev, \"nothing to do in IPC IRQ thread\\n\");\n\t}\n\n\tif (ack_received) {\n\t\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t\tif (hdev->delayed_ipc_tx_msg)\n\t\t\tmtl_ipc_send_msg(sdev, hdev->delayed_ipc_tx_msg);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint mtl_dsp_ipc_get_mailbox_offset(struct snd_sof_dev *sdev)\n{\n\treturn MTL_DSP_MBOX_UPLINK_OFFSET;\n}\n\nint mtl_dsp_ipc_get_window_offset(struct snd_sof_dev *sdev, u32 id)\n{\n\treturn MTL_SRAM_WINDOW_OFFSET(id);\n}\n\nvoid mtl_ipc_dump(struct snd_sof_dev *sdev)\n{\n\tu32 hipcidr, hipcidd, hipcida, hipctdr, hipctdd, hipctda, hipcctl;\n\n\thipcidr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDR);\n\thipcidd = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDDY);\n\thipcida = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXIDA);\n\thipctdr = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDR);\n\thipctdd = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDDY);\n\thipctda = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXTDA);\n\thipcctl = snd_sof_dsp_read(sdev, HDA_DSP_BAR, MTL_DSP_REG_HFIPCXCTL);\n\n\tdev_err(sdev->dev,\n\t\t\"Host IPC initiator: %#x|%#x|%#x, target: %#x|%#x|%#x, ctl: %#x\\n\",\n\t\thipcidr, hipcidd, hipcida, hipctdr, hipctdd, hipctda, hipcctl);\n}\n\nstatic int mtl_dsp_disable_interrupts(struct snd_sof_dev *sdev)\n{\n\tmtl_enable_sdw_irq(sdev, false);\n\tmtl_disable_ipc_interrupts(sdev);\n\treturn mtl_enable_interrupts(sdev, false);\n}\n\nu64 mtl_dsp_get_stream_hda_link_position(struct snd_sof_dev *sdev,\n\t\t\t\t\t struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tu32 llp_l, llp_u;\n\n\tllp_l = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, MTL_PPLCLLPL(hstream->index));\n\tllp_u = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, MTL_PPLCLLPU(hstream->index));\n\treturn ((u64)llp_u << 32) | llp_l;\n}\n\nstatic int mtl_dsp_core_get(struct snd_sof_dev *sdev, int core)\n{\n\tconst struct sof_ipc_pm_ops *pm_ops = sdev->ipc->ops->pm;\n\n\tif (core == SOF_DSP_PRIMARY_CORE)\n\t\treturn mtl_dsp_core_power_up(sdev, SOF_DSP_PRIMARY_CORE);\n\n\tif (pm_ops->set_core_state)\n\t\treturn pm_ops->set_core_state(sdev, core, true);\n\n\treturn 0;\n}\n\nstatic int mtl_dsp_core_put(struct snd_sof_dev *sdev, int core)\n{\n\tconst struct sof_ipc_pm_ops *pm_ops = sdev->ipc->ops->pm;\n\tint ret;\n\n\tif (pm_ops->set_core_state) {\n\t\tret = pm_ops->set_core_state(sdev, core, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (core == SOF_DSP_PRIMARY_CORE)\n\t\treturn mtl_dsp_core_power_down(sdev, SOF_DSP_PRIMARY_CORE);\n\n\treturn 0;\n}\n\n \nstruct snd_sof_dsp_ops sof_mtl_ops;\nEXPORT_SYMBOL_NS(sof_mtl_ops, SND_SOC_SOF_INTEL_HDA_COMMON);\n\nint sof_mtl_ops_init(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data;\n\n\t \n\tmemcpy(&sof_mtl_ops, &sof_hda_common_ops, sizeof(struct snd_sof_dsp_ops));\n\n\t \n\tsof_mtl_ops.shutdown = hda_dsp_shutdown;\n\n\t \n\tsof_mtl_ops.irq_thread = mtl_ipc_irq_thread;\n\n\t \n\tsof_mtl_ops.send_msg = mtl_ipc_send_msg;\n\tsof_mtl_ops.get_mailbox_offset = mtl_dsp_ipc_get_mailbox_offset;\n\tsof_mtl_ops.get_window_offset = mtl_dsp_ipc_get_window_offset;\n\n\t \n\tsof_mtl_ops.debug_map = mtl_dsp_debugfs;\n\tsof_mtl_ops.debug_map_count = ARRAY_SIZE(mtl_dsp_debugfs);\n\tsof_mtl_ops.dbg_dump = mtl_dsp_dump;\n\tsof_mtl_ops.ipc_dump = mtl_ipc_dump;\n\n\t \n\tsof_mtl_ops.pre_fw_run = mtl_dsp_pre_fw_run;\n\tsof_mtl_ops.post_fw_run = mtl_dsp_post_fw_run;\n\n\t \n\tsof_mtl_ops.parse_platform_ext_manifest = NULL;\n\n\t \n\tsof_mtl_ops.core_get = mtl_dsp_core_get;\n\tsof_mtl_ops.core_put = mtl_dsp_core_put;\n\n\tsof_mtl_ops.get_stream_position = mtl_dsp_get_stream_hda_link_position;\n\n\tsdev->private = devm_kzalloc(sdev->dev, sizeof(struct sof_ipc4_fw_data), GFP_KERNEL);\n\tif (!sdev->private)\n\t\treturn -ENOMEM;\n\n\tipc4_data = sdev->private;\n\tipc4_data->manifest_fw_hdr_offset = SOF_MAN4_FW_HDR_OFFSET;\n\n\tipc4_data->mtrace_type = SOF_IPC4_MTRACE_INTEL_CAVS_2;\n\n\t \n\tipc4_data->load_library = hda_dsp_ipc4_load_library;\n\n\t \n\thda_set_dai_drv_ops(sdev, &sof_mtl_ops);\n\n\tsof_mtl_ops.set_power_state = hda_dsp_set_power_state_ipc4;\n\n\treturn 0;\n};\nEXPORT_SYMBOL_NS(sof_mtl_ops_init, SND_SOC_SOF_INTEL_HDA_COMMON);\n\nconst struct sof_intel_dsp_desc mtl_chip_info = {\n\t.cores_num = 3,\n\t.init_core_mask = BIT(0),\n\t.host_managed_cores_mask = BIT(0),\n\t.ipc_req = MTL_DSP_REG_HFIPCXIDR,\n\t.ipc_req_mask = MTL_DSP_REG_HFIPCXIDR_BUSY,\n\t.ipc_ack = MTL_DSP_REG_HFIPCXIDA,\n\t.ipc_ack_mask = MTL_DSP_REG_HFIPCXIDA_DONE,\n\t.ipc_ctl = MTL_DSP_REG_HFIPCXCTL,\n\t.rom_status_reg = MTL_DSP_ROM_STS,\n\t.rom_init_timeout\t= 300,\n\t.ssp_count = MTL_SSP_COUNT,\n\t.ssp_base_offset = CNL_SSP_BASE_OFFSET,\n\t.sdw_shim_base = SDW_SHIM_BASE_ACE,\n\t.sdw_alh_base = SDW_ALH_BASE_ACE,\n\t.d0i3_offset = MTL_HDA_VS_D0I3C,\n\t.read_sdw_lcount =  hda_sdw_check_lcount_common,\n\t.enable_sdw_irq = mtl_enable_sdw_irq,\n\t.check_sdw_irq = mtl_dsp_check_sdw_irq,\n\t.check_sdw_wakeen_irq = hda_sdw_check_wakeen_irq_common,\n\t.check_ipc_irq = mtl_dsp_check_ipc_irq,\n\t.cl_init = mtl_dsp_cl_init,\n\t.power_down_dsp = mtl_power_down_dsp,\n\t.disable_interrupts = mtl_dsp_disable_interrupts,\n\t.hw_ip_version = SOF_INTEL_ACE_1_0,\n};\nEXPORT_SYMBOL_NS(mtl_chip_info, SND_SOC_SOF_INTEL_HDA_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}