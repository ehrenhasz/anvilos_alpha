{
  "module_name": "hda-loader-skl.c",
  "hash_id": "ef88947c89e57ae8dcb9b99e2ceb0f5882d6ee12a84dbf8835ec7dd781c4d25b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-loader-skl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/fs.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/sof.h>\n#include <sound/pcm_params.h>\n\n#include \"../sof-priv.h\"\n#include \"../ops.h\"\n#include \"hda.h\"\n\n#define HDA_SKL_WAIT_TIMEOUT\t\t500\t \n#define HDA_SKL_CLDMA_MAX_BUFFER_SIZE\t(32 * PAGE_SIZE)\n\n \n#define HDA_CL_SD_CTL_SRST_SHIFT\t0\n#define HDA_CL_SD_CTL_SRST(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_SRST_SHIFT)\n\n \n#define HDA_CL_SD_CTL_RUN_SHIFT\t\t1\n#define HDA_CL_SD_CTL_RUN(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_RUN_SHIFT)\n\n \n#define HDA_CL_SD_CTL_IOCE_SHIFT\t2\n#define HDA_CL_SD_CTL_IOCE(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_IOCE_SHIFT)\n\n \n#define HDA_CL_SD_CTL_FEIE_SHIFT\t3\n#define HDA_CL_SD_CTL_FEIE(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_FEIE_SHIFT)\n\n \n#define HDA_CL_SD_CTL_DEIE_SHIFT\t4\n#define HDA_CL_SD_CTL_DEIE(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_DEIE_SHIFT)\n\n \n#define HDA_CL_SD_CTL_FIFOLC_SHIFT\t5\n#define HDA_CL_SD_CTL_FIFOLC(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_FIFOLC_SHIFT)\n\n \n#define HDA_CL_SD_CTL_STRIPE_SHIFT\t16\n#define HDA_CL_SD_CTL_STRIPE(x)\t\t(((x) & 0x3) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_STRIPE_SHIFT)\n\n \n#define HDA_CL_SD_CTL_TP_SHIFT\t\t18\n#define HDA_CL_SD_CTL_TP(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_TP_SHIFT)\n\n \n#define HDA_CL_SD_CTL_DIR_SHIFT\t\t19\n#define HDA_CL_SD_CTL_DIR(x)\t\t(((x) & 0x1) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_DIR_SHIFT)\n\n \n#define HDA_CL_SD_CTL_STRM_SHIFT\t20\n#define HDA_CL_SD_CTL_STRM(x)\t\t(((x) & 0xf) << \\\n\t\t\t\t\tHDA_CL_SD_CTL_STRM_SHIFT)\n\n#define HDA_CL_SD_CTL_INT(x)\t\\\n\t\t(HDA_CL_SD_CTL_IOCE(x) | \\\n\t\tHDA_CL_SD_CTL_FEIE(x) | \\\n\t\tHDA_CL_SD_CTL_DEIE(x))\n\n#define HDA_CL_SD_CTL_INT_MASK\t\\\n\t\t(HDA_CL_SD_CTL_IOCE(1) | \\\n\t\tHDA_CL_SD_CTL_FEIE(1) | \\\n\t\tHDA_CL_SD_CTL_DEIE(1))\n\n#define DMA_ADDRESS_128_BITS_ALIGNMENT\t7\n#define BDL_ALIGN(x)\t\t\t((x) >> DMA_ADDRESS_128_BITS_ALIGNMENT)\n\n \n#define HDA_CL_SD_BDLPLBA_SHIFT\t\t7\n#define HDA_CL_SD_BDLPLBA_MASK\t\tGENMASK(31, 7)\n#define HDA_CL_SD_BDLPLBA(x)\t\t\\\n\t((BDL_ALIGN(lower_32_bits(x)) << HDA_CL_SD_BDLPLBA_SHIFT) & \\\n\t HDA_CL_SD_BDLPLBA_MASK)\n\n \n#define HDA_CL_SD_BDLPUBA(x)\t\t\\\n\t\t\t(upper_32_bits(x))\n\n \n#define HDA_CL_SPBFIFO_SPBFCCTL_SPIBE_SHIFT\t0\n#define HDA_CL_SPBFIFO_SPBFCCTL_SPIBE_MASK\t\\\n\t\t\t(1 << HDA_CL_SPBFIFO_SPBFCCTL_SPIBE_SHIFT)\n\n#define HDA_CL_SPBFIFO_SPBFCCTL_SPIBE(x)\t\\\n\t\t\t(((x) << HDA_CL_SPBFIFO_SPBFCCTL_SPIBE_SHIFT) & \\\n\t\t\t HDA_CL_SPBFIFO_SPBFCCTL_SPIBE_MASK)\n\n#define HDA_CL_DMA_SD_INT_COMPLETE\t\t0x4\n\nstatic int cl_skl_cldma_setup_bdle(struct snd_sof_dev *sdev,\n\t\t\t\t   struct snd_dma_buffer *dmab_data,\n\t\t\t\t   __le32 **bdlp, int size, int with_ioc)\n{\n\tphys_addr_t addr = virt_to_phys(dmab_data->area);\n\t__le32 *bdl = *bdlp;\n\n\t \n\tbdl[0] = cpu_to_le32(lower_32_bits(addr));\n\tbdl[1] = cpu_to_le32(upper_32_bits(addr));\n\tbdl[2] = cpu_to_le32(size);\n\tbdl[3] = (!with_ioc) ? 0 : cpu_to_le32(0x01);\n\n\treturn 1;  \n}\n\nstatic void cl_skl_cldma_stream_run(struct snd_sof_dev *sdev, bool enable)\n{\n\tint sd_offset = SOF_HDA_ADSP_LOADER_BASE;\n\tunsigned char val;\n\tint retries;\n\tu32 run = enable ? 0x1 : 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\tHDA_CL_SD_CTL_RUN(1), HDA_CL_SD_CTL_RUN(run));\n\n\tretries = 300;\n\tdo {\n\t\tudelay(3);\n\n\t\t \n\t\tval = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t       sd_offset + SOF_HDA_ADSP_REG_SD_CTL);\n\t\tval &= HDA_CL_SD_CTL_RUN(1);\n\t\tif (enable && val)\n\t\t\tbreak;\n\t\telse if (!enable && !val)\n\t\t\tbreak;\n\t} while (--retries);\n\n\tif (retries == 0)\n\t\tdev_err(sdev->dev, \"%s: failed to set Run bit=%d enable=%d\\n\",\n\t\t\t__func__, val, enable);\n}\n\nstatic void cl_skl_cldma_stream_clear(struct snd_sof_dev *sdev)\n{\n\tint sd_offset = SOF_HDA_ADSP_LOADER_BASE;\n\n\t \n\tcl_skl_cldma_stream_run(sdev, 0);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\tHDA_CL_SD_CTL_INT_MASK, HDA_CL_SD_CTL_INT(0));\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\tHDA_CL_SD_CTL_STRM(0xf), HDA_CL_SD_CTL_STRM(0));\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL, HDA_CL_SD_BDLPLBA(0));\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU, 0);\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_CBL, 0);\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_LVI, 0);\n}\n\nstatic void cl_skl_cldma_setup_spb(struct snd_sof_dev *sdev,\n\t\t\t\t   unsigned int size, bool enable)\n{\n\tint sd_offset = SOF_DSP_REG_CL_SPBFIFO;\n\n\tif (enable)\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCCTL,\n\t\t\t\t\tHDA_CL_SPBFIFO_SPBFCCTL_SPIBE_MASK,\n\t\t\t\t\tHDA_CL_SPBFIFO_SPBFCCTL_SPIBE(1));\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_CL_SPBFIFO_SPIB, size);\n}\n\nstatic void cl_skl_cldma_set_intr(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 val = enable ? HDA_DSP_ADSPIC_CL_DMA : 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIC,\n\t\t\t\tHDA_DSP_ADSPIC_CL_DMA, val);\n}\n\nstatic void cl_skl_cldma_cleanup_spb(struct snd_sof_dev *sdev)\n{\n\tint sd_offset = SOF_DSP_REG_CL_SPBFIFO;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCCTL,\n\t\t\t\tHDA_CL_SPBFIFO_SPBFCCTL_SPIBE_MASK,\n\t\t\t\tHDA_CL_SPBFIFO_SPBFCCTL_SPIBE(0));\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_CL_SPBFIFO_SPIB, 0);\n}\n\nstatic void cl_skl_cldma_setup_controller(struct snd_sof_dev *sdev,\n\t\t\t\t\t  struct snd_dma_buffer *dmab_bdl,\n\t\t\t\t\t  unsigned int max_size, u32 count)\n{\n\tint sd_offset = SOF_HDA_ADSP_LOADER_BASE;\n\n\t \n\tcl_skl_cldma_stream_clear(sdev);\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL,\n\t\t\t  HDA_CL_SD_BDLPLBA(dmab_bdl->addr));\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU,\n\t\t\t  HDA_CL_SD_BDLPUBA(dmab_bdl->addr));\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_CBL, max_size);\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_LVI, count - 1);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\tHDA_CL_SD_CTL_INT_MASK, HDA_CL_SD_CTL_INT(1));\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\tHDA_CL_SD_CTL_STRM(0xf),\n\t\t\t\tHDA_CL_SD_CTL_STRM(1));\n}\n\nstatic int cl_stream_prepare_skl(struct snd_sof_dev *sdev,\n\t\t\t\t struct snd_dma_buffer *dmab,\n\t\t\t\t struct snd_dma_buffer *dmab_bdl)\n\n{\n\tunsigned int bufsize = HDA_SKL_CLDMA_MAX_BUFFER_SIZE;\n\t__le32 *bdl;\n\tint frags;\n\tint ret;\n\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev, bufsize, dmab);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: failed to alloc fw buffer: %x\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev, bufsize, dmab_bdl);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: failed to alloc blde: %x\\n\", __func__, ret);\n\t\tsnd_dma_free_pages(dmab);\n\t\treturn ret;\n\t}\n\n\tbdl = (__le32 *)dmab_bdl->area;\n\tfrags = cl_skl_cldma_setup_bdle(sdev, dmab, &bdl, bufsize, 1);\n\tcl_skl_cldma_setup_controller(sdev, dmab_bdl, bufsize, frags);\n\n\treturn ret;\n}\n\nstatic void cl_cleanup_skl(struct snd_sof_dev *sdev,\n\t\t\t   struct snd_dma_buffer *dmab,\n\t\t\t   struct snd_dma_buffer *dmab_bdl)\n{\n\tcl_skl_cldma_cleanup_spb(sdev);\n\tcl_skl_cldma_stream_clear(sdev);\n\tsnd_dma_free_pages(dmab);\n\tsnd_dma_free_pages(dmab_bdl);\n}\n\nstatic int cl_dsp_init_skl(struct snd_sof_dev *sdev,\n\t\t\t   struct snd_dma_buffer *dmab,\n\t\t\t   struct snd_dma_buffer *dmab_bdl)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tunsigned int status;\n\tu32 flags;\n\tint ret;\n\n\t \n\tif (hda_dsp_core_is_enabled(sdev, chip->init_core_mask)) {\n\t\t \n\t\tret = hda_dsp_core_stall_reset(sdev, chip->init_core_mask);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = hda_dsp_core_run(sdev, chip->init_core_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: dsp core start failed %d\\n\", __func__, ret);\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\t \n\t\tret = hda_dsp_core_reset_power_down(sdev, chip->init_core_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: dsp core0 disable fail: %d\\n\", __func__, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tret = hda_dsp_enable_core(sdev, chip->init_core_mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: dsp core0 enable fail: %d\\n\", __func__, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tret = cl_stream_prepare_skl(sdev, dmab, dmab_bdl);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: dma prepare fw loading err: %x\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIC,\n\t\t\t\tHDA_DSP_ADSPIC_IPC, HDA_DSP_ADSPIC_IPC);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, chip->ipc_ctl,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY);\n\n\t \n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\t    chip->rom_status_reg, status,\n\t\t\t\t\t    (FSR_TO_STATE_CODE(status)\n\t\t\t\t\t     == FSR_STATE_INIT_DONE),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    chip->rom_init_timeout *\n\t\t\t\t\t    USEC_PER_MSEC);\n\tif (ret < 0)\n\t\tgoto err;\n\n\treturn ret;\n\nerr:\n\tflags = SOF_DBG_DUMP_PCI | SOF_DBG_DUMP_MBOX;\n\n\tsnd_sof_dsp_dbg_dump(sdev, \"Boot failed\\n\", flags);\n\tcl_cleanup_skl(sdev, dmab, dmab_bdl);\n\thda_dsp_core_reset_power_down(sdev, chip->init_core_mask);\n\treturn ret;\n}\n\nstatic void cl_skl_cldma_fill_buffer(struct snd_sof_dev *sdev,\n\t\t\t\t     struct snd_dma_buffer *dmab,\n\t\t\t\t     unsigned int bufsize,\n\t\t\t\t     unsigned int copysize,\n\t\t\t\t     const void *curr_pos,\n\t\t\t\t     bool intr_enable)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\n\t \n\tunsigned int size = (bufsize == copysize) ? bufsize : copysize;\n\n\tmemcpy(dmab->area, curr_pos, size);\n\n\t \n\thda->code_loading = 1;\n\n\t \n\tif (intr_enable)\n\t\tcl_skl_cldma_set_intr(sdev, true);\n\n\t \n\tcl_skl_cldma_setup_spb(sdev, size, true);\n\n\t \n\tcl_skl_cldma_stream_run(sdev, true);\n}\n\nstatic int cl_skl_cldma_wait_interruptible(struct snd_sof_dev *sdev,\n\t\t\t\t\t   bool intr_wait)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tint sd_offset = SOF_HDA_ADSP_LOADER_BASE;\n\tu8 cl_dma_intr_status;\n\n\t \n\tif (!wait_event_timeout(hda->waitq, !hda->code_loading,\n\t\t\t\tmsecs_to_jiffies(HDA_SKL_WAIT_TIMEOUT))) {\n\t\tdev_err(sdev->dev, \"cldma copy timeout\\n\");\n\t\tdev_err(sdev->dev, \"ROM code=%#x: FW status=%#x\\n\",\n\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_SRAM_REG_ROM_ERROR),\n\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->rom_status_reg));\n\t\treturn -EIO;\n\t}\n\n\t \n\tcl_dma_intr_status = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t\t      sd_offset + SOF_HDA_ADSP_REG_SD_STS);\n\n\tif (!(cl_dma_intr_status & HDA_CL_DMA_SD_INT_COMPLETE)) {\n\t\tdev_err(sdev->dev, \"cldma copy failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(sdev->dev, \"cldma buffer copy complete\\n\");\n\treturn 0;\n}\n\nstatic int\ncl_skl_cldma_copy_to_buf(struct snd_sof_dev *sdev,\n\t\t\t struct snd_dma_buffer *dmab,\n\t\t\t const void *bin,\n\t\t\t u32 total_size, u32 bufsize)\n{\n\tunsigned int bytes_left = total_size;\n\tconst void *curr_pos = bin;\n\tint ret;\n\n\tif (total_size <= 0)\n\t\treturn -EINVAL;\n\n\twhile (bytes_left > 0) {\n\t\tif (bytes_left > bufsize) {\n\t\t\tdev_dbg(sdev->dev, \"cldma copy %#x bytes\\n\", bufsize);\n\n\t\t\tcl_skl_cldma_fill_buffer(sdev, dmab, bufsize, bufsize, curr_pos, true);\n\n\t\t\tret = cl_skl_cldma_wait_interruptible(sdev, false);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"%s: fw failed to load. %#x bytes remaining\\n\",\n\t\t\t\t\t__func__, bytes_left);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tbytes_left -= bufsize;\n\t\t\tcurr_pos += bufsize;\n\t\t} else {\n\t\t\tdev_dbg(sdev->dev, \"cldma copy %#x bytes\\n\", bytes_left);\n\n\t\t\tcl_skl_cldma_set_intr(sdev, false);\n\t\t\tcl_skl_cldma_fill_buffer(sdev, dmab, bufsize, bytes_left, curr_pos, false);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn bytes_left;\n}\n\nstatic int cl_copy_fw_skl(struct snd_sof_dev *sdev,\n\t\t\t  struct snd_dma_buffer *dmab)\n\n{\n\tconst struct firmware *fw =  sdev->basefw.fw;\n\tstruct firmware stripped_firmware;\n\tunsigned int bufsize = HDA_SKL_CLDMA_MAX_BUFFER_SIZE;\n\tint ret;\n\n\tstripped_firmware.data = fw->data + sdev->basefw.payload_offset;\n\tstripped_firmware.size = fw->size - sdev->basefw.payload_offset;\n\n\tdev_dbg(sdev->dev, \"firmware size: %#zx buffer size %#x\\n\", fw->size, bufsize);\n\n\tret = cl_skl_cldma_copy_to_buf(sdev, dmab, stripped_firmware.data,\n\t\t\t\t       stripped_firmware.size, bufsize);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"%s: fw copy failed %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nint hda_dsp_cl_boot_firmware_skl(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tconst struct sof_intel_dsp_desc *chip = hda->desc;\n\tstruct snd_dma_buffer dmab_bdl;\n\tstruct snd_dma_buffer dmab;\n\tunsigned int reg;\n\tu32 flags;\n\tint ret;\n\n\tret = cl_dsp_init_skl(sdev, &dmab, &dmab_bdl);\n\n\t \n\tif (ret < 0) {\n\t\tret = cl_dsp_init_skl(sdev, &dmab, &dmab_bdl);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Error code=%#x: FW status=%#x\\n\",\n\t\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_SRAM_REG_ROM_ERROR),\n\t\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_BAR, chip->rom_status_reg));\n\t\t\tdev_err(sdev->dev, \"Core En/ROM load fail:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_dbg(sdev->dev, \"ROM init successful\\n\");\n\n\t \n\tret = cl_copy_fw_skl(sdev, &dmab);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"%s: load firmware failed : %d\\n\", __func__, ret);\n\t\tgoto err;\n\t}\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_BAR,\n\t\t\t\t\t    chip->rom_status_reg, reg,\n\t\t\t\t\t    (FSR_TO_STATE_CODE(reg)\n\t\t\t\t\t     == FSR_STATE_ROM_BASEFW_ENTERED),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_BASEFW_TIMEOUT_US);\n\n\tdev_dbg(sdev->dev, \"Firmware download successful, booting...\\n\");\n\n\tcl_skl_cldma_stream_run(sdev, false);\n\tcl_cleanup_skl(sdev, &dmab, &dmab_bdl);\n\n\tif (!ret)\n\t\treturn chip->init_core_mask;\n\n\treturn ret;\n\nerr:\n\tflags = SOF_DBG_DUMP_PCI | SOF_DBG_DUMP_MBOX;\n\n\tsnd_sof_dsp_dbg_dump(sdev, \"Boot failed\\n\", flags);\n\n\t \n\thda_dsp_core_reset_power_down(sdev, chip->init_core_mask);\n\tcl_skl_cldma_stream_run(sdev, false);\n\tcl_cleanup_skl(sdev, &dmab, &dmab_bdl);\n\n\tdev_err(sdev->dev, \"%s: load fw failed err: %d\\n\", __func__, ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}