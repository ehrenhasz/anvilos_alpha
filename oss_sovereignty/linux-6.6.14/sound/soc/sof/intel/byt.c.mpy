{
  "module_name": "byt.c",
  "hash_id": "66f85ed97148bb6cc2fb4796e41eed69af24598466ee71fcb12adc531d8f6727",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/byt.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include <sound/sof.h>\n#include <sound/sof/xtensa.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/intel-dsp-config.h>\n#include \"../ops.h\"\n#include \"atom.h\"\n#include \"shim.h\"\n#include \"../sof-acpi-dev.h\"\n#include \"../sof-audio.h\"\n#include \"../../intel/common/soc-intel-quirks.h\"\n\nstatic const struct snd_sof_debugfs_map byt_debugfs[] = {\n\t{\"dmac0\", DSP_BAR, DMAC0_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dmac1\", DSP_BAR, DMAC1_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp0\", DSP_BAR, SSP0_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp1\", DSP_BAR, SSP1_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp2\", DSP_BAR, SSP2_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"iram\", DSP_BAR, IRAM_OFFSET, IRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"dram\", DSP_BAR, DRAM_OFFSET, DRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"shim\", DSP_BAR, SHIM_OFFSET, SHIM_SIZE_BYT,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n};\n\nstatic const struct snd_sof_debugfs_map cht_debugfs[] = {\n\t{\"dmac0\", DSP_BAR, DMAC0_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dmac1\", DSP_BAR, DMAC1_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dmac2\", DSP_BAR, DMAC2_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp0\", DSP_BAR, SSP0_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp1\", DSP_BAR, SSP1_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp2\", DSP_BAR, SSP2_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp3\", DSP_BAR, SSP3_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp4\", DSP_BAR, SSP4_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp5\", DSP_BAR, SSP5_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"iram\", DSP_BAR, IRAM_OFFSET, IRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"dram\", DSP_BAR, DRAM_OFFSET, DRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"shim\", DSP_BAR, SHIM_OFFSET, SHIM_SIZE_CHT,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n};\n\nstatic void byt_reset_dsp_disable_int(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_IMRX, 0x3, 0x3);\n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_IMRD, 0x3, 0x3);\n\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_CSR,\n\t\t\t\t  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL,\n\t\t\t\t  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL);\n}\n\nstatic int byt_suspend(struct snd_sof_dev *sdev, u32 target_state)\n{\n\tbyt_reset_dsp_disable_int(sdev);\n\n\treturn 0;\n}\n\nstatic int byt_resume(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_IMRX,\n\t\t\t\t  SHIM_IMRX_BUSY | SHIM_IMRX_DONE,\n\t\t\t\t  SHIM_IMRX_DONE);\n\n\treturn 0;\n}\n\nstatic int byt_remove(struct snd_sof_dev *sdev)\n{\n\tbyt_reset_dsp_disable_int(sdev);\n\n\treturn 0;\n}\n\nstatic int byt_acpi_probe(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct platform_device *pdev =\n\t\tcontainer_of(sdev->dev, struct platform_device, dev);\n\tconst struct sof_intel_dsp_desc *chip;\n\tstruct resource *mmio;\n\tu32 base, size;\n\tint ret;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (!chip) {\n\t\tdev_err(sdev->dev, \"error: no such device supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsdev->num_cores = chip->cores_num;\n\n\t \n\tret = dma_coerce_mask_and_coherent(sdev->dev, DMA_BIT_MASK(31));\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to set DMA mask %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmmio = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t     desc->resindex_lpe_base);\n\tif (mmio) {\n\t\tbase = mmio->start;\n\t\tsize = resource_size(mmio);\n\t} else {\n\t\tdev_err(sdev->dev, \"error: failed to get LPE base at idx %d\\n\",\n\t\t\tdesc->resindex_lpe_base);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(sdev->dev, \"LPE PHY base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[DSP_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[DSP_BAR]) {\n\t\tdev_err(sdev->dev, \"error: failed to ioremap LPE base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"LPE VADDR %p\\n\", sdev->bar[DSP_BAR]);\n\n\t \n\tsdev->mmio_bar = DSP_BAR;\n\tsdev->mailbox_bar = DSP_BAR;\n\n\t \n\tif (desc->resindex_imr_base == -1)\n\t\tgoto irq;\n\n\tmmio = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t     desc->resindex_imr_base);\n\tif (mmio) {\n\t\tbase = mmio->start;\n\t\tsize = resource_size(mmio);\n\t} else {\n\t\tdev_err(sdev->dev, \"error: failed to get IMR base at idx %d\\n\",\n\t\t\tdesc->resindex_imr_base);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (base == 0x55aa55aa || base == 0x0) {\n\t\tdev_info(sdev->dev, \"IMR not set by BIOS. Ignoring\\n\");\n\t\tgoto irq;\n\t}\n\n\tdev_dbg(sdev->dev, \"IMR base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[IMR_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[IMR_BAR]) {\n\t\tdev_err(sdev->dev, \"error: failed to ioremap IMR base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"IMR VADDR %p\\n\", sdev->bar[IMR_BAR]);\n\nirq:\n\t \n\tsdev->ipc_irq = platform_get_irq(pdev, desc->irqindex_host_ipc);\n\tif (sdev->ipc_irq < 0)\n\t\treturn sdev->ipc_irq;\n\n\tdev_dbg(sdev->dev, \"using IRQ %d\\n\", sdev->ipc_irq);\n\tret = devm_request_threaded_irq(sdev->dev, sdev->ipc_irq,\n\t\t\t\t\tatom_irq_handler, atom_irq_thread,\n\t\t\t\t\tIRQF_SHARED, \"AudioDSP\", sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to register IRQ %d\\n\",\n\t\t\tsdev->ipc_irq);\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_IMRX,\n\t\t\t\t  SHIM_IMRX_BUSY | SHIM_IMRX_DONE,\n\t\t\t\t  SHIM_IMRX_DONE);\n\n\t \n\tsdev->dsp_box.offset = MBOX_OFFSET;\n\n\treturn ret;\n}\n\n \nstatic struct snd_sof_dsp_ops sof_byt_ops = {\n\t \n\t.probe\t\t= byt_acpi_probe,\n\t.remove\t\t= byt_remove,\n\n\t \n\t.run\t\t= atom_run,\n\t.reset\t\t= atom_reset,\n\n\t \n\n\t \n\t.block_read\t= sof_block_read,\n\t.block_write\t= sof_block_write,\n\n\t \n\t.mailbox_read\t= sof_mailbox_read,\n\t.mailbox_write\t= sof_mailbox_write,\n\n\t \n\t.irq_handler\t= atom_irq_handler,\n\t.irq_thread\t= atom_irq_thread,\n\n\t \n\t.send_msg\t= atom_send_msg,\n\t.get_mailbox_offset = atom_get_mailbox_offset,\n\t.get_window_offset = atom_get_window_offset,\n\n\t.ipc_msg_data\t= sof_ipc_msg_data,\n\t.set_stream_data_offset = sof_set_stream_data_offset,\n\n\t \n\t.machine_select = atom_machine_select,\n\t.machine_register = sof_machine_register,\n\t.machine_unregister = sof_machine_unregister,\n\t.set_mach_params = atom_set_mach_params,\n\n\t \n\t.debug_map\t= byt_debugfs,\n\t.debug_map_count\t= ARRAY_SIZE(byt_debugfs),\n\t.dbg_dump\t= atom_dump,\n\t.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,\n\n\t \n\t.pcm_open\t= sof_stream_pcm_open,\n\t.pcm_close\t= sof_stream_pcm_close,\n\n\t \n\t.load_firmware\t= snd_sof_load_firmware_memcpy,\n\n\t \n\t.suspend = byt_suspend,\n\t.resume = byt_resume,\n\n\t \n\t.drv = atom_dai,\n\t.num_drv = 3,  \n\n\t \n\t.hw_info =\tSNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.dsp_arch_ops = &sof_xtensa_arch_ops,\n};\n\nstatic const struct sof_intel_dsp_desc byt_chip_info = {\n\t.cores_num = 1,\n\t.host_managed_cores_mask = 1,\n\t.hw_ip_version = SOF_INTEL_BAYTRAIL,\n};\n\n \nstatic struct snd_sof_dsp_ops sof_cht_ops = {\n\t \n\t.probe\t\t= byt_acpi_probe,\n\t.remove\t\t= byt_remove,\n\n\t \n\t.run\t\t= atom_run,\n\t.reset\t\t= atom_reset,\n\n\t \n\n\t \n\t.block_read\t= sof_block_read,\n\t.block_write\t= sof_block_write,\n\n\t \n\t.mailbox_read\t= sof_mailbox_read,\n\t.mailbox_write\t= sof_mailbox_write,\n\n\t \n\t.irq_handler\t= atom_irq_handler,\n\t.irq_thread\t= atom_irq_thread,\n\n\t \n\t.send_msg\t= atom_send_msg,\n\t.get_mailbox_offset = atom_get_mailbox_offset,\n\t.get_window_offset = atom_get_window_offset,\n\n\t.ipc_msg_data\t= sof_ipc_msg_data,\n\t.set_stream_data_offset = sof_set_stream_data_offset,\n\n\t \n\t.machine_select = atom_machine_select,\n\t.machine_register = sof_machine_register,\n\t.machine_unregister = sof_machine_unregister,\n\t.set_mach_params = atom_set_mach_params,\n\n\t \n\t.debug_map\t= cht_debugfs,\n\t.debug_map_count\t= ARRAY_SIZE(cht_debugfs),\n\t.dbg_dump\t= atom_dump,\n\t.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,\n\n\t \n\t.pcm_open\t= sof_stream_pcm_open,\n\t.pcm_close\t= sof_stream_pcm_close,\n\n\t \n\t.load_firmware\t= snd_sof_load_firmware_memcpy,\n\n\t \n\t.suspend = byt_suspend,\n\t.resume = byt_resume,\n\n\t \n\t.drv = atom_dai,\n\t \n\t.num_drv = 6,\n\n\t \n\t.hw_info =\tSNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.dsp_arch_ops = &sof_xtensa_arch_ops,\n};\n\nstatic const struct sof_intel_dsp_desc cht_chip_info = {\n\t.cores_num = 1,\n\t.host_managed_cores_mask = 1,\n\t.hw_ip_version = SOF_INTEL_BAYTRAIL,\n};\n\n \nstatic const struct sof_dev_desc sof_acpi_baytrailcr_desc = {\n\t.machines = snd_soc_acpi_intel_baytrail_machines,\n\t.resindex_lpe_base = 0,\n\t.resindex_pcicfg_base = 1,\n\t.resindex_imr_base = 2,\n\t.irqindex_host_ipc = 0,\n\t.chip_info = &byt_chip_info,\n\t.ipc_supported_mask = BIT(SOF_IPC),\n\t.ipc_default = SOF_IPC,\n\t.default_fw_path = {\n\t\t[SOF_IPC] = \"intel/sof\",\n\t},\n\t.default_tplg_path = {\n\t\t[SOF_IPC] = \"intel/sof-tplg\",\n\t},\n\t.default_fw_filename = {\n\t\t[SOF_IPC] = \"sof-byt.ri\",\n\t},\n\t.nocodec_tplg_filename = \"sof-byt-nocodec.tplg\",\n\t.ops = &sof_byt_ops,\n};\n\nstatic const struct sof_dev_desc sof_acpi_baytrail_desc = {\n\t.machines = snd_soc_acpi_intel_baytrail_machines,\n\t.resindex_lpe_base = 0,\n\t.resindex_pcicfg_base = 1,\n\t.resindex_imr_base = 2,\n\t.irqindex_host_ipc = 5,\n\t.chip_info = &byt_chip_info,\n\t.ipc_supported_mask = BIT(SOF_IPC),\n\t.ipc_default = SOF_IPC,\n\t.default_fw_path = {\n\t\t[SOF_IPC] = \"intel/sof\",\n\t},\n\t.default_tplg_path = {\n\t\t[SOF_IPC] = \"intel/sof-tplg\",\n\t},\n\t.default_fw_filename = {\n\t\t[SOF_IPC] = \"sof-byt.ri\",\n\t},\n\t.nocodec_tplg_filename = \"sof-byt-nocodec.tplg\",\n\t.ops = &sof_byt_ops,\n};\n\nstatic const struct sof_dev_desc sof_acpi_cherrytrail_desc = {\n\t.machines = snd_soc_acpi_intel_cherrytrail_machines,\n\t.resindex_lpe_base = 0,\n\t.resindex_pcicfg_base = 1,\n\t.resindex_imr_base = 2,\n\t.irqindex_host_ipc = 5,\n\t.chip_info = &cht_chip_info,\n\t.ipc_supported_mask = BIT(SOF_IPC),\n\t.ipc_default = SOF_IPC,\n\t.default_fw_path = {\n\t\t[SOF_IPC] = \"intel/sof\",\n\t},\n\t.default_tplg_path = {\n\t\t[SOF_IPC] = \"intel/sof-tplg\",\n\t},\n\t.default_fw_filename = {\n\t\t[SOF_IPC] = \"sof-cht.ri\",\n\t},\n\t.nocodec_tplg_filename = \"sof-cht-nocodec.tplg\",\n\t.ops = &sof_cht_ops,\n};\n\nstatic const struct acpi_device_id sof_baytrail_match[] = {\n\t{ \"80860F28\", (unsigned long)&sof_acpi_baytrail_desc },\n\t{ \"808622A8\", (unsigned long)&sof_acpi_cherrytrail_desc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, sof_baytrail_match);\n\nstatic int sof_baytrail_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct sof_dev_desc *desc;\n\tconst struct acpi_device_id *id;\n\tint ret;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = snd_intel_acpi_dsp_driver_probe(dev, id->id);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_SOF) {\n\t\tdev_dbg(dev, \"SOF ACPI driver not selected, aborting probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdesc = (const struct sof_dev_desc *)id->driver_data;\n\tif (desc == &sof_acpi_baytrail_desc && soc_intel_is_byt_cr(pdev))\n\t\tdesc = &sof_acpi_baytrailcr_desc;\n\n\treturn sof_acpi_probe(pdev, desc);\n}\n\n \nstatic struct platform_driver snd_sof_acpi_intel_byt_driver = {\n\t.probe = sof_baytrail_probe,\n\t.remove = sof_acpi_remove,\n\t.driver = {\n\t\t.name = \"sof-audio-acpi-intel-byt\",\n\t\t.pm = &sof_acpi_pm,\n\t\t.acpi_match_table = sof_baytrail_match,\n\t},\n};\nmodule_platform_driver(snd_sof_acpi_intel_byt_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_INTEL_HIFI_EP_IPC);\nMODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);\nMODULE_IMPORT_NS(SND_SOC_SOF_ACPI_DEV);\nMODULE_IMPORT_NS(SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}