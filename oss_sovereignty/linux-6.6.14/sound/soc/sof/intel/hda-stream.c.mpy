{
  "module_name": "hda-stream.c",
  "hash_id": "d42f5a5bc76dd2a4ccc0ef135ad11eb479ab57afafbe4ccd6fb5f23776686116",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-stream.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/sof.h>\n#include <trace/events/sof_intel.h>\n#include \"../ops.h\"\n#include \"../sof-audio.h\"\n#include \"hda.h\"\n\n#define HDA_LTRP_GB_VALUE_US\t95\n\nstatic inline const char *hda_hstream_direction_str(struct hdac_stream *hstream)\n{\n\tif (hstream->direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn \"Playback\";\n\telse\n\t\treturn \"Capture\";\n}\n\nstatic char *hda_hstream_dbg_get_stream_info_str(struct hdac_stream *hstream)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tif (hstream->substream)\n\t\trtd = asoc_substream_to_rtd(hstream->substream);\n\telse if (hstream->cstream)\n\t\trtd = hstream->cstream->private_data;\n\telse\n\t\t \n\t\treturn kasprintf(GFP_KERNEL, \"-- (%s, stream_tag: %u)\",\n\t\t\t\t hda_hstream_direction_str(hstream),\n\t\t\t\t hstream->stream_tag);\n\n\treturn kasprintf(GFP_KERNEL, \"dai_link \\\"%s\\\" (%s, stream_tag: %u)\",\n\t\t\t rtd->dai_link->name, hda_hstream_direction_str(hstream),\n\t\t\t hstream->stream_tag);\n}\n\n \nstatic int hda_setup_bdle(struct snd_sof_dev *sdev,\n\t\t\t  struct snd_dma_buffer *dmab,\n\t\t\t  struct hdac_stream *hstream,\n\t\t\t  struct sof_intel_dsp_bdl **bdlp,\n\t\t\t  int offset, int size, int ioc)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct sof_intel_dsp_bdl *bdl = *bdlp;\n\n\twhile (size > 0) {\n\t\tdma_addr_t addr;\n\t\tint chunk;\n\n\t\tif (hstream->frags >= HDA_DSP_MAX_BDL_ENTRIES) {\n\t\t\tdev_err(sdev->dev, \"error: stream frags exceeded\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddr = snd_sgbuf_get_addr(dmab, offset);\n\t\t \n\t\tbdl->addr_l = cpu_to_le32(lower_32_bits(addr));\n\t\tbdl->addr_h = cpu_to_le32(upper_32_bits(addr));\n\t\t \n\t\tchunk = snd_sgbuf_get_chunk_size(dmab, offset, size);\n\t\t \n\t\tif (bus->align_bdle_4k) {\n\t\t\tu32 remain = 0x1000 - (offset & 0xfff);\n\n\t\t\tif (chunk > remain)\n\t\t\t\tchunk = remain;\n\t\t}\n\t\tbdl->size = cpu_to_le32(chunk);\n\t\t \n\t\tsize -= chunk;\n\t\tbdl->ioc = (size || !ioc) ? 0 : cpu_to_le32(0x01);\n\t\tbdl++;\n\t\thstream->frags++;\n\t\toffset += chunk;\n\t}\n\n\t*bdlp = bdl;\n\treturn offset;\n}\n\n \nint hda_dsp_stream_setup_bdl(struct snd_sof_dev *sdev,\n\t\t\t     struct snd_dma_buffer *dmab,\n\t\t\t     struct hdac_stream *hstream)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct sof_intel_dsp_bdl *bdl;\n\tint i, offset, period_bytes, periods;\n\tint remain, ioc;\n\n\tperiod_bytes = hstream->period_bytes;\n\tdev_dbg(sdev->dev, \"period_bytes:0x%x\\n\", period_bytes);\n\tif (!period_bytes)\n\t\tperiod_bytes = hstream->bufsize;\n\n\tperiods = hstream->bufsize / period_bytes;\n\n\tdev_dbg(sdev->dev, \"periods:%d\\n\", periods);\n\n\tremain = hstream->bufsize % period_bytes;\n\tif (remain)\n\t\tperiods++;\n\n\t \n\tbdl = (struct sof_intel_dsp_bdl *)hstream->bdl.area;\n\toffset = 0;\n\thstream->frags = 0;\n\n\t \n\tioc = hda->no_ipc_position ?\n\t      !hstream->no_period_wakeup : 0;\n\n\tfor (i = 0; i < periods; i++) {\n\t\tif (i == (periods - 1) && remain)\n\t\t\t \n\t\t\toffset = hda_setup_bdle(sdev, dmab,\n\t\t\t\t\t\thstream, &bdl, offset,\n\t\t\t\t\t\tremain, 0);\n\t\telse\n\t\t\toffset = hda_setup_bdle(sdev, dmab,\n\t\t\t\t\t\thstream, &bdl, offset,\n\t\t\t\t\t\tperiod_bytes, ioc);\n\t}\n\n\treturn offset;\n}\n\nint hda_dsp_stream_spib_config(struct snd_sof_dev *sdev,\n\t\t\t       struct hdac_ext_stream *hext_stream,\n\t\t\t       int enable, u32 size)\n{\n\tstruct hdac_stream *hstream = &hext_stream->hstream;\n\tu32 mask;\n\n\tif (!sdev->bar[HDA_DSP_SPIB_BAR]) {\n\t\tdev_err(sdev->dev, \"error: address of spib capability is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmask = (1 << hstream->index);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_SPIB_BAR,\n\t\t\t\tSOF_HDA_ADSP_REG_CL_SPBFIFO_SPBFCCTL, mask,\n\t\t\t\tenable << hstream->index);\n\n\t \n\tsof_io_write(sdev, hstream->spib_addr, size);\n\n\treturn 0;\n}\n\n \nstruct hdac_ext_stream *\nhda_dsp_stream_get(struct snd_sof_dev *sdev, int direction, u32 flags)\n{\n\tconst struct sof_intel_dsp_desc *chip_info =  get_chip_info(sdev->pdata);\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct sof_intel_hda_stream *hda_stream;\n\tstruct hdac_ext_stream *hext_stream = NULL;\n\tstruct hdac_stream *s;\n\n\tspin_lock_irq(&bus->reg_lock);\n\n\t \n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tif (s->direction == direction && !s->opened) {\n\t\t\thext_stream = stream_to_hdac_ext_stream(s);\n\t\t\thda_stream = container_of(hext_stream,\n\t\t\t\t\t\t  struct sof_intel_hda_stream,\n\t\t\t\t\t\t  hext_stream);\n\t\t\t \n\t\t\tif (hda_stream->host_reserved)\n\t\t\t\tcontinue;\n\n\t\t\ts->opened = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&bus->reg_lock);\n\n\t \n\tif (!hext_stream) {\n\t\tdev_err(sdev->dev, \"error: no free %s streams\\n\",\n\t\t\tdirection == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\t\"playback\" : \"capture\");\n\t\treturn hext_stream;\n\t}\n\n\thda_stream->flags = flags;\n\n\t \n\tif (chip_info->hw_ip_version < SOF_INTEL_ACE_1_0 &&\n\t    !(flags & SOF_HDA_STREAM_DMI_L1_COMPATIBLE)) {\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tHDA_VS_INTEL_EM2,\n\t\t\t\t\tHDA_VS_INTEL_EM2_L1SEN, 0);\n\t\thda->l1_disabled = true;\n\t}\n\n\treturn hext_stream;\n}\n\n \nint hda_dsp_stream_put(struct snd_sof_dev *sdev, int direction, int stream_tag)\n{\n\tconst struct sof_intel_dsp_desc *chip_info =  get_chip_info(sdev->pdata);\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct sof_intel_hda_stream *hda_stream;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *s;\n\tbool dmi_l1_enable = true;\n\tbool found = false;\n\n\tspin_lock_irq(&bus->reg_lock);\n\n\t \n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\thext_stream = stream_to_hdac_ext_stream(s);\n\t\thda_stream = container_of(hext_stream, struct sof_intel_hda_stream, hext_stream);\n\n\t\tif (!s->opened)\n\t\t\tcontinue;\n\n\t\tif (s->direction == direction && s->stream_tag == stream_tag) {\n\t\t\ts->opened = false;\n\t\t\tfound = true;\n\t\t} else if (!(hda_stream->flags & SOF_HDA_STREAM_DMI_L1_COMPATIBLE)) {\n\t\t\tdmi_l1_enable = false;\n\t\t}\n\t}\n\n\tspin_unlock_irq(&bus->reg_lock);\n\n\t \n\tif (chip_info->hw_ip_version < SOF_INTEL_ACE_1_0 && dmi_l1_enable) {\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_EM2,\n\t\t\t\t\tHDA_VS_INTEL_EM2_L1SEN, HDA_VS_INTEL_EM2_L1SEN);\n\t\thda->l1_disabled = false;\n\t}\n\n\tif (!found) {\n\t\tdev_err(sdev->dev, \"%s: stream_tag %d not opened!\\n\",\n\t\t\t__func__, stream_tag);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int hda_dsp_stream_reset(struct snd_sof_dev *sdev, struct hdac_stream *hstream)\n{\n\tint sd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\tint timeout = HDA_DSP_STREAM_RESET_TIMEOUT;\n\tu32 val;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset, SOF_STREAM_SD_OFFSET_CRST,\n\t\t\t\tSOF_STREAM_SD_OFFSET_CRST);\n\tdo {\n\t\tval = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, sd_offset);\n\t\tif (val & SOF_STREAM_SD_OFFSET_CRST)\n\t\t\tbreak;\n\t} while (--timeout);\n\tif (timeout == 0) {\n\t\tdev_err(sdev->dev, \"timeout waiting for stream reset\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\ttimeout = HDA_DSP_STREAM_RESET_TIMEOUT;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset, SOF_STREAM_SD_OFFSET_CRST, 0x0);\n\n\t \n\tudelay(3);\n\tdo {\n\t\tval = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, sd_offset);\n\t\tif ((val & SOF_STREAM_SD_OFFSET_CRST) == 0)\n\t\t\tbreak;\n\t} while (--timeout);\n\tif (timeout == 0) {\n\t\tdev_err(sdev->dev, \"timeout waiting for stream to exit reset\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint hda_dsp_stream_trigger(struct snd_sof_dev *sdev,\n\t\t\t   struct hdac_ext_stream *hext_stream, int cmd)\n{\n\tstruct hdac_stream *hstream = &hext_stream->hstream;\n\tint sd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\tu32 dma_start = SOF_HDA_SD_CTL_DMA_START;\n\tint ret = 0;\n\tu32 run;\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (!sdev->dspless_mode_selected)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (hstream->running)\n\t\t\tbreak;\n\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\t\t1 << hstream->index,\n\t\t\t\t\t1 << hstream->index);\n\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tsd_offset,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START |\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START |\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK);\n\n\t\tret = snd_sof_dsp_read_poll_timeout(sdev,\n\t\t\t\t\tHDA_DSP_HDA_BAR,\n\t\t\t\t\tsd_offset, run,\n\t\t\t\t\t((run &\tdma_start) == dma_start),\n\t\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\tHDA_DSP_STREAM_RUN_TIMEOUT);\n\n\t\tif (ret >= 0)\n\t\t\thstream->running = true;\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (!sdev->dspless_mode_selected)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tsd_offset,\n\t\t\t\t\tSOF_HDA_SD_CTL_DMA_START |\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK, 0x0);\n\n\t\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t\tsd_offset, run,\n\t\t\t\t\t\t!(run &\tdma_start),\n\t\t\t\t\t\tHDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t\tHDA_DSP_STREAM_RUN_TIMEOUT);\n\n\t\tif (ret >= 0) {\n\t\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_STS,\n\t\t\t\t\t  SOF_HDA_CL_DMA_SD_INT_MASK);\n\n\t\t\thstream->running = false;\n\t\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t\tSOF_HDA_INTCTL,\n\t\t\t\t\t\t1 << hstream->index, 0x0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"error: unknown command: %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0) {\n\t\tchar *stream_name = hda_hstream_dbg_get_stream_info_str(hstream);\n\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: cmd %d on %s: timeout on STREAM_SD_OFFSET read\\n\",\n\t\t\t__func__, cmd, stream_name ? stream_name : \"unknown stream\");\n\t\tkfree(stream_name);\n\t}\n\n\treturn ret;\n}\n\n \nint hda_dsp_iccmax_stream_hw_params(struct snd_sof_dev *sdev, struct hdac_ext_stream *hext_stream,\n\t\t\t\t    struct snd_dma_buffer *dmab,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct hdac_stream *hstream = &hext_stream->hstream;\n\tint sd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\tint ret;\n\tu32 mask = 0x1 << hstream->index;\n\n\tif (!hext_stream) {\n\t\tdev_err(sdev->dev, \"error: no stream available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dmab) {\n\t\tdev_err(sdev->dev, \"error: no dma buffer allocated!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (hstream->posbuf)\n\t\t*hstream->posbuf = 0;\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL,\n\t\t\t  0x0);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU,\n\t\t\t  0x0);\n\n\thstream->frags = 0;\n\n\tret = hda_dsp_stream_setup_bdl(sdev, dmab, hstream);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: set up of BDL failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL,\n\t\t\t  (u32)hstream->bdl.addr);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU,\n\t\t\t  upper_32_bits(hstream->bdl.addr));\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_CBL,\n\t\t\t  hstream->bufsize);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_LVI,\n\t\t\t\t0xffff, (hstream->frags - 1));\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\tmask, mask);\n\n\t \n\tsnd_sof_dsp_update8(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_LTRP,\n\t\t\t    HDA_VS_INTEL_LTRP_GB_MASK, HDA_LTRP_GB_VALUE_US);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\tSOF_HDA_SD_CTL_DMA_START, SOF_HDA_SD_CTL_DMA_START);\n\n\treturn 0;\n}\n\n \nint hda_dsp_stream_hw_params(struct snd_sof_dev *sdev,\n\t\t\t     struct hdac_ext_stream *hext_stream,\n\t\t\t     struct snd_dma_buffer *dmab,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tconst struct sof_intel_dsp_desc *chip = get_chip_info(sdev->pdata);\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_stream *hstream;\n\tint sd_offset, ret;\n\tu32 dma_start = SOF_HDA_SD_CTL_DMA_START;\n\tu32 mask;\n\tu32 run;\n\n\tif (!hext_stream) {\n\t\tdev_err(sdev->dev, \"error: no stream available\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dmab) {\n\t\tdev_err(sdev->dev, \"error: no dma buffer allocated!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thstream = &hext_stream->hstream;\n\tsd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\tmask = BIT(hstream->index);\n\n\t \n\tif (!sdev->dspless_mode_selected)\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\t\tmask, mask);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK |\n\t\t\t\tSOF_HDA_SD_CTL_DMA_START, 0);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t    sd_offset, run,\n\t\t\t\t\t    !(run & dma_start),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_STREAM_RUN_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tchar *stream_name = hda_hstream_dbg_get_stream_info_str(hstream);\n\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: on %s: timeout on STREAM_SD_OFFSET read1\\n\",\n\t\t\t__func__, stream_name ? stream_name : \"unknown stream\");\n\t\tkfree(stream_name);\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_STS,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK);\n\n\t \n\tret = hda_dsp_stream_reset(sdev, hstream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (hstream->posbuf)\n\t\t*hstream->posbuf = 0;\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL,\n\t\t\t  0x0);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU,\n\t\t\t  0x0);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK |\n\t\t\t\tSOF_HDA_SD_CTL_DMA_START, 0);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t    sd_offset, run,\n\t\t\t\t\t    !(run & dma_start),\n\t\t\t\t\t    HDA_DSP_REG_POLL_INTERVAL_US,\n\t\t\t\t\t    HDA_DSP_STREAM_RUN_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tchar *stream_name = hda_hstream_dbg_get_stream_info_str(hstream);\n\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: on %s: timeout on STREAM_SD_OFFSET read1\\n\",\n\t\t\t__func__, stream_name ? stream_name : \"unknown stream\");\n\t\tkfree(stream_name);\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_STS,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK);\n\n\thstream->frags = 0;\n\n\tret = hda_dsp_stream_setup_bdl(sdev, dmab, hstream);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: set up of BDL failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\tSOF_HDA_CL_SD_CTL_STREAM_TAG_MASK,\n\t\t\t\thstream->stream_tag <<\n\t\t\t\tSOF_HDA_CL_SD_CTL_STREAM_TAG_SHIFT);\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_CBL,\n\t\t\t  hstream->bufsize);\n\n\t \n\n\tif (!sdev->dspless_mode_selected && (chip->quirks & SOF_INTEL_PROCEN_FMT_QUIRK))\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\t\tmask, 0);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tsd_offset +\n\t\t\t\tSOF_HDA_ADSP_REG_SD_FORMAT,\n\t\t\t\t0xffff, hstream->format_val);\n\n\tif (!sdev->dspless_mode_selected && (chip->quirks & SOF_INTEL_PROCEN_FMT_QUIRK))\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\t\tmask, mask);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\tsd_offset + SOF_HDA_ADSP_REG_SD_LVI,\n\t\t\t\t0xffff, (hstream->frags - 1));\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPL,\n\t\t\t  (u32)hstream->bdl.addr);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_BDLPU,\n\t\t\t  upper_32_bits(hstream->bdl.addr));\n\n\t \n\tif (bus->use_posbuf && bus->posbuf.addr &&\n\t    !(snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_ADSP_DPLBASE)\n\t      & SOF_HDA_ADSP_DPLBASE_ENABLE)) {\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_ADSP_DPUBASE,\n\t\t\t\t  upper_32_bits(bus->posbuf.addr));\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_ADSP_DPLBASE,\n\t\t\t\t  (u32)bus->posbuf.addr |\n\t\t\t\t  SOF_HDA_ADSP_DPLBASE_ENABLE);\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, sd_offset,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK);\n\n\t \n\tif (hstream->direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\thstream->fifo_size =\n\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t sd_offset +\n\t\t\t\t\t SOF_HDA_ADSP_REG_SD_FIFOSIZE);\n\t\thstream->fifo_size &= 0xffff;\n\t\thstream->fifo_size += 1;\n\t} else {\n\t\thstream->fifo_size = 0;\n\t}\n\n\treturn ret;\n}\n\nint hda_dsp_stream_hw_free(struct snd_sof_dev *sdev,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct hdac_ext_stream *hext_stream = container_of(hstream,\n\t\t\t\t\t\t\t struct hdac_ext_stream,\n\t\t\t\t\t\t\t hstream);\n\tint ret;\n\n\tret = hda_dsp_stream_reset(sdev, hstream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!sdev->dspless_mode_selected) {\n\t\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\t\tu32 mask = BIT(hstream->index);\n\n\t\tspin_lock_irq(&bus->reg_lock);\n\t\t \n\t\tif (!hext_stream->link_locked)\n\t\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR,\n\t\t\t\t\t\tSOF_HDA_REG_PP_PPCTL, mask, 0);\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t}\n\n\thda_dsp_stream_spib_config(sdev, hext_stream, HDA_DSP_SPIB_DISABLE, 0);\n\n\thstream->substream = NULL;\n\n\treturn 0;\n}\n\nbool hda_dsp_check_stream_irq(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tbool ret = false;\n\tu32 status;\n\n\t \n\tspin_lock_irq(&bus->reg_lock);\n\n\tstatus = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS);\n\n\ttrace_sof_intel_hda_dsp_check_stream_irq(sdev, status);\n\n\t \n\tif (status != 0xffffffff)\n\t\tret = true;\n\n\tspin_unlock_irq(&bus->reg_lock);\n\n\treturn ret;\n}\n\nstatic void\nhda_dsp_compr_bytes_transferred(struct hdac_stream *hstream, int direction)\n{\n\tu64 buffer_size = hstream->bufsize;\n\tu64 prev_pos, pos, num_bytes;\n\n\tdiv64_u64_rem(hstream->curr_pos, buffer_size, &prev_pos);\n\tpos = hda_dsp_stream_get_position(hstream, direction, false);\n\n\tif (pos < prev_pos)\n\t\tnum_bytes = (buffer_size - prev_pos) +  pos;\n\telse\n\t\tnum_bytes = pos - prev_pos;\n\n\thstream->curr_pos += num_bytes;\n}\n\nstatic bool hda_dsp_stream_check(struct hdac_bus *bus, u32 status)\n{\n\tstruct sof_intel_hda_dev *sof_hda = bus_to_sof_hda(bus);\n\tstruct hdac_stream *s;\n\tbool active = false;\n\tu32 sd_status;\n\n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\t\tif (status & BIT(s->index) && s->opened) {\n\t\t\tsd_status = readb(s->sd_addr + SOF_HDA_ADSP_REG_SD_STS);\n\n\t\t\ttrace_sof_intel_hda_dsp_stream_status(bus->dev, s, sd_status);\n\n\t\t\twriteb(sd_status, s->sd_addr + SOF_HDA_ADSP_REG_SD_STS);\n\n\t\t\tactive = true;\n\t\t\tif ((!s->substream && !s->cstream) ||\n\t\t\t    !s->running ||\n\t\t\t    (sd_status & SOF_HDA_CL_DMA_SD_INT_COMPLETE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (s->substream && sof_hda->no_ipc_position) {\n\t\t\t\tsnd_sof_pcm_period_elapsed(s->substream);\n\t\t\t} else if (s->cstream) {\n\t\t\t\thda_dsp_compr_bytes_transferred(s, s->cstream->direction);\n\t\t\t\tsnd_compr_fragment_elapsed(s->cstream);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn active;\n}\n\nirqreturn_t hda_dsp_stream_threaded_handler(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tbool active;\n\tu32 status;\n\tint i;\n\n\t \n\tfor (i = 0, active = true; i < 10 && active; i++) {\n\t\tspin_lock_irq(&bus->reg_lock);\n\n\t\tstatus = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS);\n\n\t\t \n\t\tactive = hda_dsp_stream_check(bus, status);\n\n\t\t \n\t\tif (status & AZX_INT_CTRL_EN) {\n\t\t\tactive |= hda_codec_check_rirb_status(sdev);\n\t\t}\n\t\tspin_unlock_irq(&bus->reg_lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint hda_dsp_stream_init(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *hstream;\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tstruct sof_intel_hda_dev *sof_hda = bus_to_sof_hda(bus);\n\tint sd_offset;\n\tint i, num_playback, num_capture, num_total, ret;\n\tu32 gcap;\n\n\tgcap = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCAP);\n\tdev_dbg(sdev->dev, \"hda global caps = 0x%x\\n\", gcap);\n\n\t \n\tnum_capture = (gcap >> 8) & 0x0f;\n\tnum_playback = (gcap >> 12) & 0x0f;\n\tnum_total = num_playback + num_capture;\n\n\tdev_dbg(sdev->dev, \"detected %d playback and %d capture streams\\n\",\n\t\tnum_playback, num_capture);\n\n\tif (num_playback >= SOF_HDA_PLAYBACK_STREAMS) {\n\t\tdev_err(sdev->dev, \"error: too many playback streams %d\\n\",\n\t\t\tnum_playback);\n\t\treturn -EINVAL;\n\t}\n\n\tif (num_capture >= SOF_HDA_CAPTURE_STREAMS) {\n\t\tdev_err(sdev->dev, \"error: too many capture streams %d\\n\",\n\t\t\tnum_playback);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\t  SOF_HDA_DPIB_ENTRY_SIZE * num_total,\n\t\t\t\t  &bus->posbuf);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: posbuffer dma alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\t  PAGE_SIZE, &bus->rb);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: RB alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < num_total; i++) {\n\t\tstruct sof_intel_hda_stream *hda_stream;\n\n\t\thda_stream = devm_kzalloc(sdev->dev, sizeof(*hda_stream),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!hda_stream)\n\t\t\treturn -ENOMEM;\n\n\t\thda_stream->sdev = sdev;\n\n\t\thext_stream = &hda_stream->hext_stream;\n\n\t\tif (sdev->bar[HDA_DSP_PP_BAR]) {\n\t\t\thext_stream->pphc_addr = sdev->bar[HDA_DSP_PP_BAR] +\n\t\t\t\tSOF_HDA_PPHC_BASE + SOF_HDA_PPHC_INTERVAL * i;\n\n\t\t\thext_stream->pplc_addr = sdev->bar[HDA_DSP_PP_BAR] +\n\t\t\t\tSOF_HDA_PPLC_BASE + SOF_HDA_PPLC_MULTI * num_total +\n\t\t\t\tSOF_HDA_PPLC_INTERVAL * i;\n\t\t}\n\n\t\thstream = &hext_stream->hstream;\n\n\t\t \n\t\tif (sdev->bar[HDA_DSP_SPIB_BAR]) {\n\t\t\thstream->spib_addr = sdev->bar[HDA_DSP_SPIB_BAR] +\n\t\t\t\tSOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +\n\t\t\t\tSOF_HDA_SPIB_SPIB;\n\n\t\t\thstream->fifo_addr = sdev->bar[HDA_DSP_SPIB_BAR] +\n\t\t\t\tSOF_HDA_SPIB_BASE + SOF_HDA_SPIB_INTERVAL * i +\n\t\t\t\tSOF_HDA_SPIB_MAXFIFO;\n\t\t}\n\n\t\thstream->bus = bus;\n\t\thstream->sd_int_sta_mask = 1 << i;\n\t\thstream->index = i;\n\t\tsd_offset = SOF_STREAM_SD_OFFSET(hstream);\n\t\thstream->sd_addr = sdev->bar[HDA_DSP_HDA_BAR] + sd_offset;\n\t\thstream->opened = false;\n\t\thstream->running = false;\n\n\t\tif (i < num_capture) {\n\t\t\thstream->stream_tag = i + 1;\n\t\t\thstream->direction = SNDRV_PCM_STREAM_CAPTURE;\n\t\t} else {\n\t\t\thstream->stream_tag = i - num_capture + 1;\n\t\t\thstream->direction = SNDRV_PCM_STREAM_PLAYBACK;\n\t\t}\n\n\t\t \n\t\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, &pci->dev,\n\t\t\t\t\t  HDA_DSP_BDL_SIZE, &hstream->bdl);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: stream bdl dma alloc failed\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\thstream->posbuf = (__le32 *)(bus->posbuf.area +\n\t\t\t(hstream->index) * 8);\n\n\t\tlist_add_tail(&hstream->list, &bus->stream_list);\n\t}\n\n\t \n\tsof_hda->stream_max = num_total;\n\n\treturn 0;\n}\n\nvoid hda_dsp_stream_free(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_stream *s, *_s;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct sof_intel_hda_stream *hda_stream;\n\n\t \n\tif (bus->posbuf.area)\n\t\tsnd_dma_free_pages(&bus->posbuf);\n\n\t \n\tif (bus->rb.area)\n\t\tsnd_dma_free_pages(&bus->rb);\n\n\tlist_for_each_entry_safe(s, _s, &bus->stream_list, list) {\n\t\t \n\n\t\t \n\t\tif (s->bdl.area)\n\t\t\tsnd_dma_free_pages(&s->bdl);\n\t\tlist_del(&s->list);\n\t\thext_stream = stream_to_hdac_ext_stream(s);\n\t\thda_stream = container_of(hext_stream, struct sof_intel_hda_stream,\n\t\t\t\t\t  hext_stream);\n\t\tdevm_kfree(sdev->dev, hda_stream);\n\t}\n}\n\nsnd_pcm_uframes_t hda_dsp_stream_get_position(struct hdac_stream *hstream,\n\t\t\t\t\t      int direction, bool can_sleep)\n{\n\tstruct hdac_ext_stream *hext_stream = stream_to_hdac_ext_stream(hstream);\n\tstruct sof_intel_hda_stream *hda_stream = hstream_to_sof_hda_stream(hext_stream);\n\tstruct snd_sof_dev *sdev = hda_stream->sdev;\n\tsnd_pcm_uframes_t pos;\n\n\tswitch (sof_hda_position_quirk) {\n\tcase SOF_HDA_POSITION_QUIRK_USE_SKYLAKE_LEGACY:\n\t\t \n\n\t\t \n\t\tif (direction == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tpos = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t       AZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t\t       (AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\t\t\thstream->index));\n\t\t} else {\n\t\t\t \n\t\t\tif (can_sleep)\n\t\t\t\tusleep_range(20, 21);\n\n\t\t\tsnd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\t AZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t\t (AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\t\t  hstream->index));\n\t\t\tpos = snd_hdac_stream_get_pos_posbuf(hstream);\n\t\t}\n\t\tbreak;\n\tcase SOF_HDA_POSITION_QUIRK_USE_DPIB_REGISTERS:\n\t\t \n\t\tpos = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t       AZX_REG_VS_SDXDPIB_XBASE +\n\t\t\t\t       (AZX_REG_VS_SDXDPIB_XINTERVAL *\n\t\t\t\t\thstream->index));\n\t\tbreak;\n\tcase SOF_HDA_POSITION_QUIRK_USE_DPIB_DDR_UPDATE:\n\t\t \n\t\tpos = snd_hdac_stream_get_pos_posbuf(hstream);\n\t\tbreak;\n\tdefault:\n\t\tdev_err_once(sdev->dev, \"hda_position_quirk value %d not supported\\n\",\n\t\t\t     sof_hda_position_quirk);\n\t\tpos = 0;\n\t\tbreak;\n\t}\n\n\tif (pos >= hstream->bufsize)\n\t\tpos = 0;\n\n\treturn pos;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}