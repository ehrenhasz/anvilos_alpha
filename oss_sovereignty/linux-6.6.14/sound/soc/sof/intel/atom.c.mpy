{
  "module_name": "atom.c",
  "hash_id": "13530ab06564f87311536f153b72e2eef6a86941689942254556b47f3b8eb5a7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/atom.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include <sound/sof.h>\n#include <sound/sof/xtensa.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/intel-dsp-config.h>\n#include \"../ops.h\"\n#include \"shim.h\"\n#include \"atom.h\"\n#include \"../sof-acpi-dev.h\"\n#include \"../sof-audio.h\"\n#include \"../../intel/common/soc-intel-quirks.h\"\n\nstatic void atom_host_done(struct snd_sof_dev *sdev);\nstatic void atom_dsp_done(struct snd_sof_dev *sdev);\n\n \n\nstatic void atom_get_registers(struct snd_sof_dev *sdev,\n\t\t\t       struct sof_ipc_dsp_oops_xtensa *xoops,\n\t\t\t       struct sof_ipc_panic_info *panic_info,\n\t\t\t       u32 *stack, size_t stack_words)\n{\n\tu32 offset = sdev->dsp_oops_offset;\n\n\t \n\tsof_mailbox_read(sdev, offset, xoops, sizeof(*xoops));\n\n\t \n\n\t \n\tif (xoops->arch_hdr.totalsize > EXCEPT_MAX_HDR_SIZE) {\n\t\tdev_err(sdev->dev, \"invalid header size 0x%x. FW oops is bogus\\n\",\n\t\t\txoops->arch_hdr.totalsize);\n\t\treturn;\n\t}\n\toffset += xoops->arch_hdr.totalsize;\n\tsof_mailbox_read(sdev, offset, panic_info, sizeof(*panic_info));\n\n\t \n\toffset += sizeof(*panic_info);\n\tsof_mailbox_read(sdev, offset, stack, stack_words * sizeof(u32));\n}\n\nvoid atom_dump(struct snd_sof_dev *sdev, u32 flags)\n{\n\tstruct sof_ipc_dsp_oops_xtensa xoops;\n\tstruct sof_ipc_panic_info panic_info;\n\tu32 stack[STACK_DUMP_SIZE];\n\tu64 status, panic, imrd, imrx;\n\n\t \n\tstatus = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCD);\n\tpanic = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCX);\n\tatom_get_registers(sdev, &xoops, &panic_info, stack,\n\t\t\t   STACK_DUMP_SIZE);\n\tsof_print_oops_and_stack(sdev, KERN_ERR, status, panic, &xoops,\n\t\t\t\t &panic_info, stack, STACK_DUMP_SIZE);\n\n\t \n\timrx = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IMRX);\n\timrd = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IMRD);\n\tdev_err(sdev->dev,\n\t\t\"error: ipc host -> DSP: pending %s complete %s raw 0x%llx\\n\",\n\t\t(panic & SHIM_IPCX_BUSY) ? \"yes\" : \"no\",\n\t\t(panic & SHIM_IPCX_DONE) ? \"yes\" : \"no\", panic);\n\tdev_err(sdev->dev,\n\t\t\"error: mask host: pending %s complete %s raw 0x%llx\\n\",\n\t\t(imrx & SHIM_IMRX_BUSY) ? \"yes\" : \"no\",\n\t\t(imrx & SHIM_IMRX_DONE) ? \"yes\" : \"no\", imrx);\n\tdev_err(sdev->dev,\n\t\t\"error: ipc DSP -> host: pending %s complete %s raw 0x%llx\\n\",\n\t\t(status & SHIM_IPCD_BUSY) ? \"yes\" : \"no\",\n\t\t(status & SHIM_IPCD_DONE) ? \"yes\" : \"no\", status);\n\tdev_err(sdev->dev,\n\t\t\"error: mask DSP: pending %s complete %s raw 0x%llx\\n\",\n\t\t(imrd & SHIM_IMRD_BUSY) ? \"yes\" : \"no\",\n\t\t(imrd & SHIM_IMRD_DONE) ? \"yes\" : \"no\", imrd);\n\n}\nEXPORT_SYMBOL_NS(atom_dump, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\n \n\nirqreturn_t atom_irq_handler(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tu64 ipcx, ipcd;\n\tint ret = IRQ_NONE;\n\n\tipcx = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCX);\n\tipcd = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCD);\n\n\tif (ipcx & SHIM_BYT_IPCX_DONE) {\n\n\t\t \n\t\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR,\n\t\t\t\t\t\t   SHIM_IMRX,\n\t\t\t\t\t\t   SHIM_IMRX_DONE,\n\t\t\t\t\t\t   SHIM_IMRX_DONE);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (ipcd & SHIM_BYT_IPCD_BUSY) {\n\n\t\t \n\t\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR,\n\t\t\t\t\t\t   SHIM_IMRX,\n\t\t\t\t\t\t   SHIM_IMRX_BUSY,\n\t\t\t\t\t\t   SHIM_IMRX_BUSY);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(atom_irq_handler, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nirqreturn_t atom_irq_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tu64 ipcx, ipcd;\n\n\tipcx = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCX);\n\tipcd = snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_IPCD);\n\n\t \n\tif (ipcx & SHIM_BYT_IPCX_DONE) {\n\n\t\tspin_lock_irq(&sdev->ipc_lock);\n\n\t\t \n\t\tsnd_sof_ipc_process_reply(sdev, ipcx);\n\n\t\tatom_dsp_done(sdev);\n\n\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t}\n\n\t \n\tif (ipcd & SHIM_BYT_IPCD_BUSY) {\n\n\t\t \n\t\tif ((ipcd & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {\n\t\t\tsnd_sof_dsp_panic(sdev, PANIC_OFFSET(ipcd) + MBOX_OFFSET,\n\t\t\t\t\t  true);\n\t\t} else {\n\t\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\t}\n\n\t\tatom_host_done(sdev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_NS(atom_irq_thread, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nint atom_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\t \n\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR, SHIM_IMRX,\n\t\t\t\t\t   SHIM_IMRX_DONE, 0);\n\n\t \n\tsof_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,\n\t\t\t  msg->msg_size);\n\tsnd_sof_dsp_write64(sdev, DSP_BAR, SHIM_IPCX, SHIM_BYT_IPCX_BUSY);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(atom_send_msg, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nint atom_get_mailbox_offset(struct snd_sof_dev *sdev)\n{\n\treturn MBOX_OFFSET;\n}\nEXPORT_SYMBOL_NS(atom_get_mailbox_offset, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nint atom_get_window_offset(struct snd_sof_dev *sdev, u32 id)\n{\n\treturn MBOX_OFFSET;\n}\nEXPORT_SYMBOL_NS(atom_get_window_offset, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nstatic void atom_host_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR, SHIM_IPCD,\n\t\t\t\t\t   SHIM_BYT_IPCD_BUSY |\n\t\t\t\t\t   SHIM_BYT_IPCD_DONE,\n\t\t\t\t\t   SHIM_BYT_IPCD_DONE);\n\n\t \n\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR, SHIM_IMRX,\n\t\t\t\t\t   SHIM_IMRX_BUSY, 0);\n}\n\nstatic void atom_dsp_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits64_unlocked(sdev, DSP_BAR, SHIM_IPCX,\n\t\t\t\t\t   SHIM_BYT_IPCX_DONE, 0);\n}\n\n \n\nint atom_run(struct snd_sof_dev *sdev)\n{\n\tint tries = 10;\n\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_CSR,\n\t\t\t\t  SHIM_BYT_CSR_STALL, 0x0);\n\twhile (tries--) {\n\t\tif (!(snd_sof_dsp_read64(sdev, DSP_BAR, SHIM_CSR) &\n\t\t      SHIM_BYT_CSR_PWAITMODE))\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\tif (tries < 0)\n\t\treturn -ENODEV;\n\n\t \n\treturn 1;\n}\nEXPORT_SYMBOL_NS(atom_run, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nint atom_reset(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_CSR,\n\t\t\t\t  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL |\n\t\t\t\t  SHIM_BYT_CSR_STALL,\n\t\t\t\t  SHIM_BYT_CSR_RST | SHIM_BYT_CSR_VECTOR_SEL |\n\t\t\t\t  SHIM_BYT_CSR_STALL);\n\n\tusleep_range(10, 15);\n\n\t \n\tsnd_sof_dsp_update_bits64(sdev, DSP_BAR, SHIM_CSR,\n\t\t\t\t  SHIM_BYT_CSR_RST, 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(atom_reset, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nstatic const char *fixup_tplg_name(struct snd_sof_dev *sdev,\n\t\t\t\t   const char *sof_tplg_filename,\n\t\t\t\t   const char *ssp_str)\n{\n\tconst char *tplg_filename = NULL;\n\tconst char *split_ext;\n\tchar *filename, *tmp;\n\n\tfilename = kstrdup(sof_tplg_filename, GFP_KERNEL);\n\tif (!filename)\n\t\treturn NULL;\n\n\t \n\ttmp = filename;\n\tsplit_ext = strsep(&tmp, \".\");\n\tif (split_ext)\n\t\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t\t       \"%s-%s.tplg\",\n\t\t\t\t\t       split_ext, ssp_str);\n\tkfree(filename);\n\n\treturn tplg_filename;\n}\n\nstruct snd_soc_acpi_mach *atom_machine_select(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *sof_pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = sof_pdata->desc;\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct platform_device *pdev;\n\tconst char *tplg_filename;\n\n\tmach = snd_soc_acpi_find_machine(desc->machines);\n\tif (!mach) {\n\t\tdev_warn(sdev->dev, \"warning: No matching ASoC machine driver found\\n\");\n\t\treturn NULL;\n\t}\n\n\tpdev = to_platform_device(sdev->dev);\n\tif (soc_intel_is_byt_cr(pdev)) {\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"BYT-CR detected, SSP0 used instead of SSP2\\n\");\n\n\t\ttplg_filename = fixup_tplg_name(sdev,\n\t\t\t\t\t\tmach->sof_tplg_filename,\n\t\t\t\t\t\t\"ssp0\");\n\t} else {\n\t\ttplg_filename = mach->sof_tplg_filename;\n\t}\n\n\tif (!tplg_filename) {\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"error: no topology filename\\n\");\n\t\treturn NULL;\n\t}\n\n\tsof_pdata->tplg_filename = tplg_filename;\n\tmach->mach_params.acpi_ipc_irq_index = desc->irqindex_host_ipc;\n\n\treturn mach;\n}\nEXPORT_SYMBOL_NS(atom_machine_select, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\n \nstruct snd_soc_dai_driver atom_dai[] = {\n{\n\t.name = \"ssp0-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"ssp1-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"ssp2-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t}\n},\n{\n\t.name = \"ssp3-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"ssp4-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"ssp5-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n};\nEXPORT_SYMBOL_NS(atom_dai, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nvoid atom_set_mach_params(struct snd_soc_acpi_mach *mach,\n\t\t\t  struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct snd_soc_acpi_mach_params *mach_params;\n\n\tmach_params = &mach->mach_params;\n\tmach_params->platform = dev_name(sdev->dev);\n\tmach_params->num_dai_drivers = desc->ops->num_drv;\n\tmach_params->dai_drivers = desc->ops->drv;\n}\nEXPORT_SYMBOL_NS(atom_set_mach_params, SND_SOC_SOF_INTEL_ATOM_HIFI_EP);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}