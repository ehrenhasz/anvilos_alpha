{
  "module_name": "hda-ipc.c",
  "hash_id": "bdf5ec26de33f42c90b7602751907698eef32d4f52e8b04353ecb5c95d607591",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-ipc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <sound/sof/ipc4/header.h>\n#include <trace/events/sof_intel.h>\n#include \"../ops.h\"\n#include \"hda.h\"\n\nstatic void hda_dsp_ipc_host_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR,\n\t\t\t\t       HDA_DSP_REG_HIPCT,\n\t\t\t\t       HDA_DSP_REG_HIPCT_BUSY,\n\t\t\t\t       HDA_DSP_REG_HIPCT_BUSY);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tHDA_DSP_REG_HIPCCTL,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY);\n}\n\nstatic void hda_dsp_ipc_dsp_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_forced(sdev, HDA_DSP_BAR,\n\t\t\t\t       HDA_DSP_REG_HIPCIE,\n\t\t\t\t       HDA_DSP_REG_HIPCIE_DONE,\n\t\t\t\t       HDA_DSP_REG_HIPCIE_DONE);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\tHDA_DSP_REG_HIPCCTL,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE,\n\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE);\n}\n\nint hda_dsp_ipc_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\t \n\tsof_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,\n\t\t\t  msg->msg_size);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCI,\n\t\t\t  HDA_DSP_REG_HIPCI_BUSY);\n\n\treturn 0;\n}\n\nstatic inline bool hda_dsp_ipc4_pm_msg(u32 primary)\n{\n\t \n\tif (SOF_IPC4_MSG_IS_MODULE_MSG(primary) != SOF_IPC4_MODULE_MSG)\n\t\treturn false;\n\n\tif (SOF_IPC4_MSG_TYPE_GET(primary) == SOF_IPC4_MOD_SET_DX ||\n\t    SOF_IPC4_MSG_TYPE_GET(primary) == SOF_IPC4_MOD_SET_D0IX)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid hda_dsp_ipc4_schedule_d0i3_work(struct sof_intel_hda_dev *hdev,\n\t\t\t\t     struct snd_sof_ipc_msg *msg)\n{\n\tstruct sof_ipc4_msg *msg_data = msg->msg_data;\n\n\t \n\tif (hda_dsp_ipc4_pm_msg(msg_data->primary))\n\t\treturn;\n\n\tmod_delayed_work(system_wq, &hdev->d0i3_work,\n\t\t\t msecs_to_jiffies(SOF_HDA_D0I3_WORK_DELAY_MS));\n}\n\nint hda_dsp_ipc4_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\tstruct sof_ipc4_msg *msg_data = msg->msg_data;\n\n\tif (hda_ipc4_tx_is_busy(sdev)) {\n\t\thdev->delayed_ipc_tx_msg = msg;\n\t\treturn 0;\n\t}\n\n\thdev->delayed_ipc_tx_msg = NULL;\n\n\t \n\tif (msg_data->data_size)\n\t\tsof_mailbox_write(sdev, sdev->host_box.offset, msg_data->data_ptr,\n\t\t\t\t  msg_data->data_size);\n\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE, msg_data->extension);\n\tsnd_sof_dsp_write(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCI,\n\t\t\t  msg_data->primary | HDA_DSP_REG_HIPCI_BUSY);\n\n\thda_dsp_ipc4_schedule_d0i3_work(hdev, msg);\n\n\treturn 0;\n}\n\nvoid hda_dsp_ipc_get_reply(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc_msg *msg = sdev->msg;\n\tstruct sof_ipc_reply reply;\n\tstruct sof_ipc_cmd_hdr *hdr;\n\n\t \n\tif (!msg) {\n\t\tdev_warn(sdev->dev, \"unexpected ipc interrupt raised!\\n\");\n\t\treturn;\n\t}\n\n\thdr = msg->msg_data;\n\tif (hdr->cmd == (SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_CTX_SAVE) ||\n\t    hdr->cmd == (SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_GATE)) {\n\t\t \n\t\treply.error = 0;\n\t\treply.hdr.cmd = SOF_IPC_GLB_REPLY;\n\t\treply.hdr.size = sizeof(reply);\n\t\tmemcpy(msg->reply_data, &reply, sizeof(reply));\n\n\t\tmsg->reply_error = 0;\n\t} else {\n\t\tsnd_sof_ipc_get_reply(sdev);\n\t}\n}\n\nirqreturn_t hda_dsp_ipc4_irq_thread(int irq, void *context)\n{\n\tstruct sof_ipc4_msg notification_data = {{ 0 }};\n\tstruct snd_sof_dev *sdev = context;\n\tbool ack_received = false;\n\tbool ipc_irq = false;\n\tu32 hipcie, hipct;\n\n\thipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCIE);\n\thipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);\n\n\tif (hipcie & HDA_DSP_REG_HIPCIE_DONE) {\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE, 0);\n\t\thda_dsp_ipc_dsp_done(sdev);\n\n\t\tipc_irq = true;\n\t\tack_received = true;\n\t}\n\n\tif (hipct & HDA_DSP_REG_HIPCT_BUSY) {\n\t\t \n\t\tu32 hipcte = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t\t      HDA_DSP_REG_HIPCTE);\n\t\tu32 primary = hipct & HDA_DSP_REG_HIPCT_MSG_MASK;\n\t\tu32 extension = hipcte & HDA_DSP_REG_HIPCTE_MSG_MASK;\n\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCCTL,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY, 0);\n\n\t\tif (primary & SOF_IPC4_MSG_DIR_MASK) {\n\t\t\t \n\t\t\tif (likely(sdev->fw_state == SOF_FW_BOOT_COMPLETE)) {\n\t\t\t\tstruct sof_ipc4_msg *data = sdev->ipc->msg.reply_data;\n\n\t\t\t\tdata->primary = primary;\n\t\t\t\tdata->extension = extension;\n\n\t\t\t\tspin_lock_irq(&sdev->ipc_lock);\n\n\t\t\t\tsnd_sof_ipc_get_reply(sdev);\n\t\t\t\thda_dsp_ipc_host_done(sdev);\n\t\t\t\tsnd_sof_ipc_reply(sdev, data->primary);\n\n\t\t\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t\t\t} else {\n\t\t\t\tdev_dbg_ratelimited(sdev->dev,\n\t\t\t\t\t\t    \"IPC reply before FW_READY: %#x|%#x\\n\",\n\t\t\t\t\t\t    primary, extension);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\n\t\t\tnotification_data.primary = primary;\n\t\t\tnotification_data.extension = extension;\n\t\t\tsdev->ipc->msg.rx_data = &notification_data;\n\t\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\t\tsdev->ipc->msg.rx_data = NULL;\n\n\t\t\t \n\t\t\thda_dsp_ipc_host_done(sdev);\n\t\t}\n\n\t\tipc_irq = true;\n\t}\n\n\tif (!ipc_irq)\n\t\t \n\t\tdev_dbg_ratelimited(sdev->dev, \"nothing to do in IPC IRQ thread\\n\");\n\n\tif (ack_received) {\n\t\tstruct sof_intel_hda_dev *hdev = sdev->pdata->hw_pdata;\n\n\t\tif (hdev->delayed_ipc_tx_msg)\n\t\t\thda_dsp_ipc4_send_msg(sdev, hdev->delayed_ipc_tx_msg);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nirqreturn_t hda_dsp_ipc_irq_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tu32 hipci;\n\tu32 hipcie;\n\tu32 hipct;\n\tu32 hipcte;\n\tu32 msg;\n\tu32 msg_ext;\n\tbool ipc_irq = false;\n\n\t \n\thipcie = snd_sof_dsp_read(sdev, HDA_DSP_BAR,\n\t\t\t\t  HDA_DSP_REG_HIPCIE);\n\thipct = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCT);\n\thipci = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCI);\n\thipcte = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_HIPCTE);\n\n\t \n\tif (hipcie & HDA_DSP_REG_HIPCIE_DONE) {\n\t\tmsg = hipci & HDA_DSP_REG_HIPCI_MSG_MASK;\n\t\tmsg_ext = hipcie & HDA_DSP_REG_HIPCIE_MSG_MASK;\n\n\t\ttrace_sof_intel_ipc_firmware_response(sdev, msg, msg_ext);\n\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL_DONE, 0);\n\n\t\t \n\t\tif (likely(sdev->fw_state == SOF_FW_BOOT_COMPLETE)) {\n\t\t\tspin_lock_irq(&sdev->ipc_lock);\n\n\t\t\t \n\t\t\thda_dsp_ipc_get_reply(sdev);\n\t\t\tsnd_sof_ipc_reply(sdev, msg);\n\n\t\t\t \n\t\t\thda_dsp_ipc_dsp_done(sdev);\n\n\t\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t\t} else {\n\t\t\tdev_dbg_ratelimited(sdev->dev, \"IPC reply before FW_READY: %#x\\n\",\n\t\t\t\t\t    msg);\n\t\t}\n\n\t\tipc_irq = true;\n\t}\n\n\t \n\tif (hipct & HDA_DSP_REG_HIPCT_BUSY) {\n\t\tmsg = hipct & HDA_DSP_REG_HIPCT_MSG_MASK;\n\t\tmsg_ext = hipcte & HDA_DSP_REG_HIPCTE_MSG_MASK;\n\n\t\ttrace_sof_intel_ipc_firmware_initiated(sdev, msg, msg_ext);\n\n\t\t \n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_BAR,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL,\n\t\t\t\t\tHDA_DSP_REG_HIPCCTL_BUSY, 0);\n\n\t\t \n\t\tif ((hipct & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {\n\t\t\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\t\t\tbool non_recoverable = true;\n\n\t\t\t \n\t\t\tif (sdev->fw_state == SOF_FW_BOOT_IN_PROGRESS &&\n\t\t\t    hda->boot_iteration < HDA_FW_BOOT_ATTEMPTS)\n\t\t\t\tnon_recoverable = false;\n\n\t\t\tsnd_sof_dsp_panic(sdev, HDA_DSP_PANIC_OFFSET(msg_ext),\n\t\t\t\t\t  non_recoverable);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\t}\n\n\t\thda_dsp_ipc_host_done(sdev);\n\n\t\tipc_irq = true;\n\t}\n\n\tif (!ipc_irq) {\n\t\t \n\t\tdev_dbg_ratelimited(sdev->dev,\n\t\t\t\t    \"nothing to do in IPC IRQ thread\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nbool hda_dsp_check_ipc_irq(struct snd_sof_dev *sdev)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tbool ret = false;\n\tu32 irq_status;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn false;\n\n\t \n\tirq_status = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_REG_ADSPIS);\n\ttrace_sof_intel_hda_irq_ipc_check(sdev, irq_status);\n\n\t \n\tif (irq_status == 0xffffffff)\n\t\tgoto out;\n\n\t \n\tif (irq_status & HDA_DSP_ADSPIS_IPC)\n\t\tret = true;\n\n\t \n\tif (irq_status & HDA_DSP_ADSPIS_CL_DMA) {\n\t\thda->code_loading = 0;\n\t\twake_up(&hda->waitq);\n\t\tret = false;\n\t}\n\nout:\n\treturn ret;\n}\n\nint hda_dsp_ipc_get_mailbox_offset(struct snd_sof_dev *sdev)\n{\n\treturn HDA_DSP_MBOX_UPLINK_OFFSET;\n}\n\nint hda_dsp_ipc_get_window_offset(struct snd_sof_dev *sdev, u32 id)\n{\n\treturn SRAM_WINDOW_OFFSET(id);\n}\n\nint hda_ipc_msg_data(struct snd_sof_dev *sdev,\n\t\t     struct snd_sof_pcm_stream *sps,\n\t\t     void *p, size_t sz)\n{\n\tif (!sps || !sdev->stream_box.size) {\n\t\tsof_mailbox_read(sdev, sdev->dsp_box.offset, p, sz);\n\t} else {\n\t\tstruct snd_pcm_substream *substream = sps->substream;\n\t\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\t\tstruct sof_intel_hda_stream *hda_stream;\n\n\t\thda_stream = container_of(hstream,\n\t\t\t\t\t  struct sof_intel_hda_stream,\n\t\t\t\t\t  hext_stream.hstream);\n\n\t\t \n\t\tif (!hstream)\n\t\t\treturn -ESTRPIPE;\n\n\t\tsof_mailbox_read(sdev, hda_stream->sof_intel_stream.posn_offset, p, sz);\n\t}\n\n\treturn 0;\n}\n\nint hda_set_stream_data_offset(struct snd_sof_dev *sdev,\n\t\t\t       struct snd_sof_pcm_stream *sps,\n\t\t\t       size_t posn_offset)\n{\n\tstruct snd_pcm_substream *substream = sps->substream;\n\tstruct hdac_stream *hstream = substream->runtime->private_data;\n\tstruct sof_intel_hda_stream *hda_stream;\n\n\thda_stream = container_of(hstream, struct sof_intel_hda_stream,\n\t\t\t\t  hext_stream.hstream);\n\n\t \n\tif (posn_offset > sdev->stream_box.size ||\n\t    posn_offset % sizeof(struct sof_ipc_stream_posn) != 0)\n\t\treturn -EINVAL;\n\n\thda_stream->sof_intel_stream.posn_offset = sdev->stream_box.offset + posn_offset;\n\n\tdev_dbg(sdev->dev, \"pcm: stream dir %d, posn mailbox offset is %zu\",\n\t\tsubstream->stream, hda_stream->sof_intel_stream.posn_offset);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}