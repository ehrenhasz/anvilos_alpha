{
  "module_name": "bdw.c",
  "hash_id": "a2ba453fd23d3760e9d1420c5093cc859232b849621bc2e7b517cf80c7e5c161",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/bdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include <sound/sof.h>\n#include <sound/sof/xtensa.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/intel-dsp-config.h>\n#include \"../ops.h\"\n#include \"shim.h\"\n#include \"../sof-acpi-dev.h\"\n#include \"../sof-audio.h\"\n\n \n#define BDW_DSP_BAR 0\n#define BDW_PCI_BAR 1\n\n \n\n \n#define IRAM_OFFSET     0xA0000\n#define BDW_IRAM_SIZE       (10 * 32 * 1024)\n#define DRAM_OFFSET     0x00000\n#define BDW_DRAM_SIZE       (20 * 32 * 1024)\n#define SHIM_OFFSET     0xFB000\n#define SHIM_SIZE       0x100\n#define MBOX_OFFSET     0x9E000\n#define MBOX_SIZE       0x1000\n#define MBOX_DUMP_SIZE 0x30\n#define EXCEPT_OFFSET\t0x800\n#define EXCEPT_MAX_HDR_SIZE\t0x400\n\n \n#define DMAC0_OFFSET    0xFE000\n#define DMAC1_OFFSET    0xFF000\n#define DMAC_SIZE       0x420\n#define SSP0_OFFSET     0xFC000\n#define SSP1_OFFSET     0xFD000\n#define SSP_SIZE\t0x100\n\n#define BDW_STACK_DUMP_SIZE\t32\n\n#define BDW_PANIC_OFFSET(x)\t((x) & 0xFFFF)\n\nstatic const struct snd_sof_debugfs_map bdw_debugfs[] = {\n\t{\"dmac0\", BDW_DSP_BAR, DMAC0_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"dmac1\", BDW_DSP_BAR, DMAC1_OFFSET, DMAC_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp0\", BDW_DSP_BAR, SSP0_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"ssp1\", BDW_DSP_BAR, SSP1_OFFSET, SSP_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n\t{\"iram\", BDW_DSP_BAR, IRAM_OFFSET, BDW_IRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"dram\", BDW_DSP_BAR, DRAM_OFFSET, BDW_DRAM_SIZE,\n\t SOF_DEBUGFS_ACCESS_D0_ONLY},\n\t{\"shim\", BDW_DSP_BAR, SHIM_OFFSET, SHIM_SIZE,\n\t SOF_DEBUGFS_ACCESS_ALWAYS},\n};\n\nstatic void bdw_host_done(struct snd_sof_dev *sdev);\nstatic void bdw_dsp_done(struct snd_sof_dev *sdev);\n\n \n\nstatic int bdw_run(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_HMDC,\n\t\t\t\tSHIM_HMDC_HDDA_E0_ALLCH |\n\t\t\t\tSHIM_HMDC_HDDA_E1_ALLCH, 0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,\n\t\t\t\t\t SHIM_CSR_STALL, 0x0);\n\n\t \n\treturn 1;\n}\n\nstatic int bdw_reset(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,\n\t\t\t\t\t SHIM_CSR_RST | SHIM_CSR_STALL,\n\t\t\t\t\t SHIM_CSR_RST | SHIM_CSR_STALL);\n\n\t \n\tmdelay(10);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,\n\t\t\t\t\t SHIM_CSR_RST | SHIM_CSR_STALL,\n\t\t\t\t\t SHIM_CSR_STALL);\n\n\treturn 0;\n}\n\nstatic int bdw_set_dsp_D0(struct snd_sof_dev *sdev)\n{\n\tint tries = 10;\n\tu32 reg;\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,\n\t\t\t\t\t PCI_VDRTCL2_DCLCGE |\n\t\t\t\t\t PCI_VDRTCL2_DTCGE, 0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL0,\n\t\t\t\t\t PCI_VDRTCL0_D3PGD, PCI_VDRTCL0_D3PGD);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_PMCS,\n\t\t\t\t\t PCI_PMCS_PS_MASK, 0);\n\n\t \n\twhile (tries--) {\n\t\treg = readl(sdev->bar[BDW_PCI_BAR] + PCI_PMCS)\n\t\t\t& PCI_PMCS_PS_MASK;\n\t\tif (reg == 0)\n\t\t\tgoto finish;\n\n\t\tmsleep(20);\n\t}\n\n\treturn -ENODEV;\n\nfinish:\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CSR,\n\t\t\t\t\t SHIM_CSR_S1IOCS | SHIM_CSR_SBCS1 |\n\t\t\t\t\t SHIM_CSR_LPCS, 0x0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,\n\t\t\t\t\t SHIM_CSR, SHIM_CSR_STALL |\n\t\t\t\t\t SHIM_CSR_DCS_MASK,\n\t\t\t\t\t SHIM_CSR_STALL |\n\t\t\t\t\t SHIM_CSR_DCS(4));\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_CLKCTL,\n\t\t\t\t\t SHIM_CLKCTL_MASK |\n\t\t\t\t\t SHIM_CLKCTL_DCPLCG |\n\t\t\t\t\t SHIM_CLKCTL_SCOE0,\n\t\t\t\t\t SHIM_CLKCTL_MASK |\n\t\t\t\t\t SHIM_CLKCTL_DCPLCG |\n\t\t\t\t\t SHIM_CLKCTL_SCOE0);\n\n\t \n\tbdw_reset(sdev);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,\n\t\t\t\t\t PCI_VDRTCL2_DCLCGE |\n\t\t\t\t\t PCI_VDRTCL2_DTCGE,\n\t\t\t\t\t PCI_VDRTCL2_DCLCGE |\n\t\t\t\t\t PCI_VDRTCL2_DTCGE);\n\n\tusleep_range(50, 55);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL2,\n\t\t\t\t\t PCI_VDRTCL2_APLLSE_MASK, 0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_PCI_BAR, PCI_VDRTCTL0,\n\t\t\t\t\t 0xfffffffC, 0x0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,  SHIM_CSR2,\n\t\t\t\t\t SHIM_CSR2_SDFD_SSP1,\n\t\t\t\t\t SHIM_CSR2_SDFD_SSP1);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_HMDC,\n\t\t\t\tSHIM_HMDC_HDDA_E0_ALLCH |\n\t\t\t\tSHIM_HMDC_HDDA_E1_ALLCH,\n\t\t\t\tSHIM_HMDC_HDDA_E0_ALLCH |\n\t\t\t\tSHIM_HMDC_HDDA_E1_ALLCH);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_IMRX,\n\t\t\t\t(SHIM_IMRX_BUSY | SHIM_IMRX_DONE), 0x0);\n\tsnd_sof_dsp_update_bits(sdev, BDW_DSP_BAR, SHIM_IMRD,\n\t\t\t\t(SHIM_IMRD_DONE | SHIM_IMRD_BUSY |\n\t\t\t\tSHIM_IMRD_SSP0 | SHIM_IMRD_DMAC), 0x0);\n\n\t \n\tsnd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCX, 0x0);\n\tsnd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCD, 0x0);\n\tsnd_sof_dsp_write(sdev, BDW_DSP_BAR, 0x80, 0x6);\n\tsnd_sof_dsp_write(sdev, BDW_DSP_BAR, 0xe0, 0x300a);\n\n\treturn 0;\n}\n\nstatic void bdw_get_registers(struct snd_sof_dev *sdev,\n\t\t\t      struct sof_ipc_dsp_oops_xtensa *xoops,\n\t\t\t      struct sof_ipc_panic_info *panic_info,\n\t\t\t      u32 *stack, size_t stack_words)\n{\n\tu32 offset = sdev->dsp_oops_offset;\n\n\t \n\tsof_mailbox_read(sdev, offset, xoops, sizeof(*xoops));\n\n\t \n\n\t \n\tif (xoops->arch_hdr.totalsize > EXCEPT_MAX_HDR_SIZE) {\n\t\tdev_err(sdev->dev, \"invalid header size 0x%x. FW oops is bogus\\n\",\n\t\t\txoops->arch_hdr.totalsize);\n\t\treturn;\n\t}\n\toffset += xoops->arch_hdr.totalsize;\n\tsof_mailbox_read(sdev, offset, panic_info, sizeof(*panic_info));\n\n\t \n\toffset += sizeof(*panic_info);\n\tsof_mailbox_read(sdev, offset, stack, stack_words * sizeof(u32));\n}\n\nstatic void bdw_dump(struct snd_sof_dev *sdev, u32 flags)\n{\n\tstruct sof_ipc_dsp_oops_xtensa xoops;\n\tstruct sof_ipc_panic_info panic_info;\n\tu32 stack[BDW_STACK_DUMP_SIZE];\n\tu32 status, panic, imrx, imrd;\n\n\t \n\tstatus = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCD);\n\tpanic = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCX);\n\tbdw_get_registers(sdev, &xoops, &panic_info, stack,\n\t\t\t  BDW_STACK_DUMP_SIZE);\n\tsof_print_oops_and_stack(sdev, KERN_ERR, status, panic, &xoops,\n\t\t\t\t &panic_info, stack, BDW_STACK_DUMP_SIZE);\n\n\t \n\timrx = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IMRX);\n\timrd = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IMRD);\n\tdev_err(sdev->dev,\n\t\t\"error: ipc host -> DSP: pending %s complete %s raw 0x%8.8x\\n\",\n\t\t(panic & SHIM_IPCX_BUSY) ? \"yes\" : \"no\",\n\t\t(panic & SHIM_IPCX_DONE) ? \"yes\" : \"no\", panic);\n\tdev_err(sdev->dev,\n\t\t\"error: mask host: pending %s complete %s raw 0x%8.8x\\n\",\n\t\t(imrx & SHIM_IMRX_BUSY) ? \"yes\" : \"no\",\n\t\t(imrx & SHIM_IMRX_DONE) ? \"yes\" : \"no\", imrx);\n\tdev_err(sdev->dev,\n\t\t\"error: ipc DSP -> host: pending %s complete %s raw 0x%8.8x\\n\",\n\t\t(status & SHIM_IPCD_BUSY) ? \"yes\" : \"no\",\n\t\t(status & SHIM_IPCD_DONE) ? \"yes\" : \"no\", status);\n\tdev_err(sdev->dev,\n\t\t\"error: mask DSP: pending %s complete %s raw 0x%8.8x\\n\",\n\t\t(imrd & SHIM_IMRD_BUSY) ? \"yes\" : \"no\",\n\t\t(imrd & SHIM_IMRD_DONE) ? \"yes\" : \"no\", imrd);\n}\n\n \n\nstatic irqreturn_t bdw_irq_handler(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tu32 isr;\n\tint ret = IRQ_NONE;\n\n\t \n\tisr = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_ISRX);\n\tif (isr & (SHIM_ISRX_DONE | SHIM_ISRX_BUSY))\n\t\tret = IRQ_WAKE_THREAD;\n\n\treturn ret;\n}\n\nstatic irqreturn_t bdw_irq_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tu32 ipcx, ipcd, imrx;\n\n\timrx = snd_sof_dsp_read64(sdev, BDW_DSP_BAR, SHIM_IMRX);\n\tipcx = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCX);\n\n\t \n\tif (ipcx & SHIM_IPCX_DONE &&\n\t    !(imrx & SHIM_IMRX_DONE)) {\n\t\t \n\t\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,\n\t\t\t\t\t\t SHIM_IMRX, SHIM_IMRX_DONE,\n\t\t\t\t\t\t SHIM_IMRX_DONE);\n\n\t\tspin_lock_irq(&sdev->ipc_lock);\n\n\t\t \n\t\tsnd_sof_ipc_process_reply(sdev, ipcx);\n\n\t\tbdw_dsp_done(sdev);\n\n\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t}\n\n\tipcd = snd_sof_dsp_read(sdev, BDW_DSP_BAR, SHIM_IPCD);\n\n\t \n\tif (ipcd & SHIM_IPCD_BUSY &&\n\t    !(imrx & SHIM_IMRX_BUSY)) {\n\t\t \n\t\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR,\n\t\t\t\t\t\t SHIM_IMRX, SHIM_IMRX_BUSY,\n\t\t\t\t\t\t SHIM_IMRX_BUSY);\n\n\t\t \n\t\tif ((ipcd & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {\n\t\t\tsnd_sof_dsp_panic(sdev, BDW_PANIC_OFFSET(ipcx) + MBOX_OFFSET,\n\t\t\t\t\t  true);\n\t\t} else {\n\t\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\t}\n\n\t\tbdw_host_done(sdev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int bdw_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\t \n\tsof_mailbox_write(sdev, sdev->host_box.offset, msg->msg_data,\n\t\t\t  msg->msg_size);\n\tsnd_sof_dsp_write(sdev, BDW_DSP_BAR, SHIM_IPCX, SHIM_IPCX_BUSY);\n\n\treturn 0;\n}\n\nstatic int bdw_get_mailbox_offset(struct snd_sof_dev *sdev)\n{\n\treturn MBOX_OFFSET;\n}\n\nstatic int bdw_get_window_offset(struct snd_sof_dev *sdev, u32 id)\n{\n\treturn MBOX_OFFSET;\n}\n\nstatic void bdw_host_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IPCD,\n\t\t\t\t\t SHIM_IPCD_BUSY | SHIM_IPCD_DONE,\n\t\t\t\t\t SHIM_IPCD_DONE);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IMRX,\n\t\t\t\t\t SHIM_IMRX_BUSY, 0);\n}\n\nstatic void bdw_dsp_done(struct snd_sof_dev *sdev)\n{\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IPCX,\n\t\t\t\t\t SHIM_IPCX_DONE, 0);\n\n\t \n\tsnd_sof_dsp_update_bits_unlocked(sdev, BDW_DSP_BAR, SHIM_IMRX,\n\t\t\t\t\t SHIM_IMRX_DONE, 0);\n}\n\n \nstatic int bdw_probe(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct platform_device *pdev =\n\t\tcontainer_of(sdev->dev, struct platform_device, dev);\n\tconst struct sof_intel_dsp_desc *chip;\n\tstruct resource *mmio;\n\tu32 base, size;\n\tint ret;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (!chip) {\n\t\tdev_err(sdev->dev, \"error: no such device supported\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsdev->num_cores = chip->cores_num;\n\n\t \n\tmmio = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t     desc->resindex_lpe_base);\n\tif (mmio) {\n\t\tbase = mmio->start;\n\t\tsize = resource_size(mmio);\n\t} else {\n\t\tdev_err(sdev->dev, \"error: failed to get LPE base at idx %d\\n\",\n\t\t\tdesc->resindex_lpe_base);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(sdev->dev, \"LPE PHY base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[BDW_DSP_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[BDW_DSP_BAR]) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to ioremap LPE base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"LPE VADDR %p\\n\", sdev->bar[BDW_DSP_BAR]);\n\n\t \n\tsdev->mmio_bar = BDW_DSP_BAR;\n\tsdev->mailbox_bar = BDW_DSP_BAR;\n\tsdev->dsp_oops_offset = MBOX_OFFSET;\n\n\t \n\tmmio = platform_get_resource(pdev, IORESOURCE_MEM,\n\t\t\t\t     desc->resindex_pcicfg_base);\n\tif (mmio) {\n\t\tbase = mmio->start;\n\t\tsize = resource_size(mmio);\n\t} else {\n\t\tdev_err(sdev->dev, \"error: failed to get PCI base at idx %d\\n\",\n\t\t\tdesc->resindex_pcicfg_base);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(sdev->dev, \"PCI base at 0x%x size 0x%x\", base, size);\n\tsdev->bar[BDW_PCI_BAR] = devm_ioremap(sdev->dev, base, size);\n\tif (!sdev->bar[BDW_PCI_BAR]) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to ioremap PCI base 0x%x size 0x%x\\n\",\n\t\t\tbase, size);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(sdev->dev, \"PCI VADDR %p\\n\", sdev->bar[BDW_PCI_BAR]);\n\n\t \n\tsdev->ipc_irq = platform_get_irq(pdev, desc->irqindex_host_ipc);\n\tif (sdev->ipc_irq < 0)\n\t\treturn sdev->ipc_irq;\n\n\tdev_dbg(sdev->dev, \"using IRQ %d\\n\", sdev->ipc_irq);\n\tret = devm_request_threaded_irq(sdev->dev, sdev->ipc_irq,\n\t\t\t\t\tbdw_irq_handler, bdw_irq_thread,\n\t\t\t\t\tIRQF_SHARED, \"AudioDSP\", sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to register IRQ %d\\n\",\n\t\t\tsdev->ipc_irq);\n\t\treturn ret;\n\t}\n\n\t \n\tret = bdw_set_dsp_D0(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to set DSP D0\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = dma_coerce_mask_and_coherent(sdev->dev, DMA_BIT_MASK(31));\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to set DMA mask %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsdev->dsp_box.offset = MBOX_OFFSET;\n\n\treturn ret;\n}\n\nstatic struct snd_soc_acpi_mach *bdw_machine_select(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *sof_pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = sof_pdata->desc;\n\tstruct snd_soc_acpi_mach *mach;\n\n\tmach = snd_soc_acpi_find_machine(desc->machines);\n\tif (!mach) {\n\t\tdev_warn(sdev->dev, \"warning: No matching ASoC machine driver found\\n\");\n\t\treturn NULL;\n\t}\n\n\tsof_pdata->tplg_filename = mach->sof_tplg_filename;\n\tmach->mach_params.acpi_ipc_irq_index = desc->irqindex_host_ipc;\n\n\treturn mach;\n}\n\nstatic void bdw_set_mach_params(struct snd_soc_acpi_mach *mach,\n\t\t\t\tstruct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = pdata->desc;\n\tstruct snd_soc_acpi_mach_params *mach_params;\n\n\tmach_params = &mach->mach_params;\n\tmach_params->platform = dev_name(sdev->dev);\n\tmach_params->num_dai_drivers = desc->ops->num_drv;\n\tmach_params->dai_drivers = desc->ops->drv;\n}\n\n \nstatic struct snd_soc_dai_driver bdw_dai[] = {\n{\n\t.name = \"ssp0-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"ssp1-port\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n};\n\n \nstatic struct snd_sof_dsp_ops sof_bdw_ops = {\n\t \n\t.probe          = bdw_probe,\n\n\t \n\t.run            = bdw_run,\n\t.reset          = bdw_reset,\n\n\t \n\n\t \n\t.block_read\t= sof_block_read,\n\t.block_write\t= sof_block_write,\n\n\t \n\t.mailbox_read\t= sof_mailbox_read,\n\t.mailbox_write\t= sof_mailbox_write,\n\n\t \n\t.send_msg\t= bdw_send_msg,\n\t.get_mailbox_offset = bdw_get_mailbox_offset,\n\t.get_window_offset = bdw_get_window_offset,\n\n\t.ipc_msg_data\t= sof_ipc_msg_data,\n\t.set_stream_data_offset = sof_set_stream_data_offset,\n\n\t \n\t.machine_select = bdw_machine_select,\n\t.machine_register = sof_machine_register,\n\t.machine_unregister = sof_machine_unregister,\n\t.set_mach_params = bdw_set_mach_params,\n\n\t \n\t.debug_map  = bdw_debugfs,\n\t.debug_map_count    = ARRAY_SIZE(bdw_debugfs),\n\t.dbg_dump   = bdw_dump,\n\t.debugfs_add_region_item = snd_sof_debugfs_add_region_item_iomem,\n\n\t \n\t.pcm_open\t= sof_stream_pcm_open,\n\t.pcm_close\t= sof_stream_pcm_close,\n\n\t \n\t.load_firmware\t= snd_sof_load_firmware_memcpy,\n\n\t \n\t.drv = bdw_dai,\n\t.num_drv = ARRAY_SIZE(bdw_dai),\n\n\t \n\t.hw_info =\tSNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_PAUSE |\n\t\t\tSNDRV_PCM_INFO_BATCH,\n\n\t.dsp_arch_ops = &sof_xtensa_arch_ops,\n};\n\nstatic const struct sof_intel_dsp_desc bdw_chip_info = {\n\t.cores_num = 1,\n\t.host_managed_cores_mask = 1,\n\t.hw_ip_version = SOF_INTEL_BROADWELL,\n};\n\nstatic const struct sof_dev_desc sof_acpi_broadwell_desc = {\n\t.machines = snd_soc_acpi_intel_broadwell_machines,\n\t.resindex_lpe_base = 0,\n\t.resindex_pcicfg_base = 1,\n\t.resindex_imr_base = -1,\n\t.irqindex_host_ipc = 0,\n\t.chip_info = &bdw_chip_info,\n\t.ipc_supported_mask = BIT(SOF_IPC),\n\t.ipc_default = SOF_IPC,\n\t.default_fw_path = {\n\t\t[SOF_IPC] = \"intel/sof\",\n\t},\n\t.default_tplg_path = {\n\t\t[SOF_IPC] = \"intel/sof-tplg\",\n\t},\n\t.default_fw_filename = {\n\t\t[SOF_IPC] = \"sof-bdw.ri\",\n\t},\n\t.nocodec_tplg_filename = \"sof-bdw-nocodec.tplg\",\n\t.ops = &sof_bdw_ops,\n};\n\nstatic const struct acpi_device_id sof_broadwell_match[] = {\n\t{ \"INT3438\", (unsigned long)&sof_acpi_broadwell_desc },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, sof_broadwell_match);\n\nstatic int sof_broadwell_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct acpi_device_id *id;\n\tconst struct sof_dev_desc *desc;\n\tint ret;\n\n\tid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = snd_intel_acpi_dsp_driver_probe(dev, id->id);\n\tif (ret != SND_INTEL_DSP_DRIVER_ANY && ret != SND_INTEL_DSP_DRIVER_SOF) {\n\t\tdev_dbg(dev, \"SOF ACPI driver not selected, aborting probe\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdesc = (const struct sof_dev_desc *)id->driver_data;\n\treturn sof_acpi_probe(pdev, desc);\n}\n\n \nstatic struct platform_driver snd_sof_acpi_intel_bdw_driver = {\n\t.probe = sof_broadwell_probe,\n\t.remove = sof_acpi_remove,\n\t.driver = {\n\t\t.name = \"sof-audio-acpi-intel-bdw\",\n\t\t.pm = &sof_acpi_pm,\n\t\t.acpi_match_table = sof_broadwell_match,\n\t},\n};\nmodule_platform_driver(snd_sof_acpi_intel_bdw_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_INTEL_HIFI_EP_IPC);\nMODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);\nMODULE_IMPORT_NS(SND_SOC_SOF_ACPI_DEV);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}