{
  "module_name": "hda-dai.c",
  "hash_id": "fe0a7286823babe09c22d0021c5aa22f3eb6b820943debd0aea60b0d87019887",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-dai.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <sound/pcm_params.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda-mlink.h>\n#include <sound/hda_register.h>\n#include <sound/intel-nhlt.h>\n#include <sound/sof/ipc4/header.h>\n#include <uapi/sound/sof/header.h>\n#include \"../ipc4-priv.h\"\n#include \"../ipc4-topology.h\"\n#include \"../sof-priv.h\"\n#include \"../sof-audio.h\"\n#include \"hda.h\"\n\n \nstatic bool hda_use_tplg_nhlt;\nmodule_param_named(sof_use_tplg_nhlt, hda_use_tplg_nhlt, bool, 0444);\nMODULE_PARM_DESC(sof_use_tplg_nhlt, \"SOF topology nhlt override\");\n\nstatic struct snd_sof_dev *widget_to_sdev(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_sof_widget *swidget = w->dobj.private;\n\tstruct snd_soc_component *component = swidget->scomp;\n\n\treturn snd_soc_component_get_drvdata(component);\n}\n\nint hda_dai_config(struct snd_soc_dapm_widget *w, unsigned int flags,\n\t\t   struct snd_sof_dai_config_data *data)\n{\n\tstruct snd_sof_widget *swidget = w->dobj.private;\n\tconst struct sof_ipc_tplg_ops *tplg_ops;\n\tstruct snd_sof_dev *sdev;\n\tint ret;\n\n\tif (!swidget)\n\t\treturn 0;\n\n\tsdev = widget_to_sdev(w);\n\ttplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->dai_config) {\n\t\tret = tplg_ops->dai_config(sdev, swidget, flags, data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"DAI config with flags %x failed for widget %s\\n\",\n\t\t\t\tflags, w->name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_LINK)\n\nstatic struct snd_sof_dev *dai_to_sdev(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, substream->stream);\n\n\treturn widget_to_sdev(w);\n}\n\nstatic const struct hda_dai_widget_dma_ops *\nhda_dai_get_ops(struct snd_pcm_substream *substream, struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, substream->stream);\n\tstruct snd_sof_widget *swidget = w->dobj.private;\n\tstruct snd_sof_dev *sdev;\n\tstruct snd_sof_dai *sdai;\n\n\tsdev = widget_to_sdev(w);\n\n\t \n\tif (sdev->dspless_mode_selected)\n\t\treturn hda_select_dai_widget_ops(sdev, NULL);\n\n\tsdai = swidget->private;\n\n\t \n\tif (!sdai->platform_private) {\n\t\tconst struct hda_dai_widget_dma_ops *ops =\n\t\t\thda_select_dai_widget_ops(sdev, swidget);\n\t\tif (!ops)\n\t\t\treturn NULL;\n\n\t\t \n\t\tif (!ops || !ops->get_hext_stream)\n\t\t\treturn NULL;\n\n\t\tsdai->platform_private = ops;\n\t}\n\n\treturn sdai->platform_private;\n}\n\nint hda_link_dma_cleanup(struct snd_pcm_substream *substream, struct hdac_ext_stream *hext_stream,\n\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tconst struct hda_dai_widget_dma_ops *ops = hda_dai_get_ops(substream, cpu_dai);\n\tstruct sof_intel_hda_stream *hda_stream;\n\tstruct hdac_ext_link *hlink;\n\tstruct snd_sof_dev *sdev;\n\tint stream_tag;\n\n\tif (!ops) {\n\t\tdev_err(cpu_dai->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdev = dai_to_sdev(substream, cpu_dai);\n\n\thlink = ops->get_hlink(sdev, substream);\n\tif (!hlink)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tstream_tag = hdac_stream(hext_stream)->stream_tag;\n\t\tsnd_hdac_ext_bus_link_clear_stream_id(hlink, stream_tag);\n\t}\n\n\tif (ops->release_hext_stream)\n\t\tops->release_hext_stream(sdev, cpu_dai, substream);\n\n\thext_stream->link_prepared = 0;\n\n\t \n\thda_stream = hstream_to_sof_hda_stream(hext_stream);\n\thda_stream->host_reserved = 0;\n\n\treturn 0;\n}\n\nstatic int hda_link_dma_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params, struct snd_soc_dai *cpu_dai)\n{\n\tconst struct hda_dai_widget_dma_ops *ops = hda_dai_get_ops(substream, cpu_dai);\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *hstream;\n\tstruct hdac_ext_link *hlink;\n\tstruct snd_sof_dev *sdev;\n\tint stream_tag;\n\n\tif (!ops) {\n\t\tdev_err(cpu_dai->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdev = dai_to_sdev(substream, cpu_dai);\n\n\thlink = ops->get_hlink(sdev, substream);\n\tif (!hlink)\n\t\treturn -EINVAL;\n\n\thext_stream = ops->get_hext_stream(sdev, cpu_dai, substream);\n\n\tif (!hext_stream) {\n\t\tif (ops->assign_hext_stream)\n\t\t\thext_stream = ops->assign_hext_stream(sdev, cpu_dai, substream);\n\t}\n\n\tif (!hext_stream)\n\t\treturn -EBUSY;\n\n\thstream = &hext_stream->hstream;\n\tstream_tag = hstream->stream_tag;\n\n\tif (hext_stream->hstream.direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_hdac_ext_bus_link_set_stream_id(hlink, stream_tag);\n\n\t \n\tif (ops->codec_dai_set_stream)\n\t\tops->codec_dai_set_stream(sdev, substream, hstream);\n\n\tif (ops->reset_hext_stream)\n\t\tops->reset_hext_stream(sdev, hext_stream);\n\n\tif (ops->calc_stream_format && ops->setup_hext_stream) {\n\t\tunsigned int format_val = ops->calc_stream_format(sdev, substream, params);\n\n\t\tops->setup_hext_stream(sdev, hext_stream, format_val);\n\t}\n\n\thext_stream->link_prepared = 1;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hda_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t\t  struct snd_soc_dai *cpu_dai)\n{\n\tconst struct hda_dai_widget_dma_ops *ops = hda_dai_get_ops(substream, cpu_dai);\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct snd_sof_dev *sdev = dai_to_sdev(substream, cpu_dai);\n\n\tif (!ops) {\n\t\tdev_err(cpu_dai->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thext_stream = ops->get_hext_stream(sdev, cpu_dai, substream);\n\tif (!hext_stream)\n\t\treturn 0;\n\n\treturn hda_link_dma_cleanup(substream, hext_stream, cpu_dai);\n}\n\nstatic int __maybe_unused hda_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(dai, substream->stream);\n\tconst struct hda_dai_widget_dma_ops *ops = hda_dai_get_ops(substream, dai);\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct snd_sof_dai_config_data data = { 0 };\n\tunsigned int flags = SOF_DAI_CONFIG_FLAGS_HW_PARAMS;\n\tstruct snd_sof_dev *sdev = widget_to_sdev(w);\n\tint ret;\n\n\tif (!ops) {\n\t\tdev_err(sdev->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thext_stream = ops->get_hext_stream(sdev, dai, substream);\n\tif (hext_stream && hext_stream->link_prepared)\n\t\treturn 0;\n\n\tret = hda_link_dma_hw_params(substream, params, dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thext_stream = ops->get_hext_stream(sdev, dai, substream);\n\n\tflags |= SOF_DAI_CONFIG_FLAGS_2_STEP_STOP << SOF_DAI_CONFIG_FLAGS_QUIRK_SHIFT;\n\tdata.dai_data = hdac_stream(hext_stream)->stream_tag - 1;\n\n\treturn hda_dai_config(w, flags, &data);\n}\n\n \nstatic int __maybe_unused hda_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tconst struct hda_dai_widget_dma_ops *ops = hda_dai_get_ops(substream, dai);\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct snd_sof_dev *sdev;\n\tint ret;\n\n\tif (!ops) {\n\t\tdev_err(dai->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"cmd=%d dai %s direction %d\\n\", cmd,\n\t\tdai->name, substream->stream);\n\n\tsdev = dai_to_sdev(substream, dai);\n\n\thext_stream = ops->get_hext_stream(sdev, dai, substream);\n\tif (!hext_stream)\n\t\treturn -EINVAL;\n\n\tif (ops->pre_trigger) {\n\t\tret = ops->pre_trigger(sdev, dai, substream, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ops->trigger) {\n\t\tret = ops->trigger(sdev, dai, substream, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (ops->post_trigger) {\n\t\tret = ops->post_trigger(sdev, dai, substream, cmd);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tret = hda_link_dma_cleanup(substream, hext_stream, dai);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: failed to clean up link DMA\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC)\n\nstatic int hda_dai_prepare(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\n\treturn hda_dai_hw_params(substream, &rtd->dpcm[stream].hw_params, dai);\n}\n\nstatic const struct snd_soc_dai_ops hda_dai_ops = {\n\t.hw_params = hda_dai_hw_params,\n\t.hw_free = hda_dai_hw_free,\n\t.trigger = hda_dai_trigger,\n\t.prepare = hda_dai_prepare,\n};\n\n#endif\n\nstatic struct sof_ipc4_copier *widget_to_copier(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_sof_widget *swidget = w->dobj.private;\n\tstruct snd_sof_dai *sdai = swidget->private;\n\tstruct sof_ipc4_copier *ipc4_copier = (struct sof_ipc4_copier *)sdai->private;\n\n\treturn ipc4_copier;\n}\n\nstatic int non_hda_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, substream->stream);\n\tstruct sof_ipc4_dma_config_tlv *dma_config_tlv;\n\tconst struct hda_dai_widget_dma_ops *ops;\n\tstruct sof_ipc4_dma_config *dma_config;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *hstream;\n\tstruct snd_sof_dev *sdev;\n\tint stream_id;\n\tint ret;\n\n\tops = hda_dai_get_ops(substream, cpu_dai);\n\tif (!ops) {\n\t\tdev_err(cpu_dai->dev, \"DAI widget ops not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = hda_dai_hw_params(substream, params, cpu_dai);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"%s: hda_dai_hw_params failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsdev = widget_to_sdev(w);\n\thext_stream = ops->get_hext_stream(sdev, cpu_dai, substream);\n\n\tif (!hext_stream) {\n\t\tdev_err(cpu_dai->dev, \"%s: no hext_stream found\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\thstream = &hext_stream->hstream;\n\tstream_id = hstream->stream_tag;\n\n\tif (!stream_id) {\n\t\tdev_err(cpu_dai->dev, \"%s: no stream_id allocated\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tipc4_copier = widget_to_copier(w);\n\n\tdma_config_tlv = &ipc4_copier->dma_config_tlv;\n\tdma_config_tlv->type = SOF_IPC4_GTW_DMA_CONFIG_ID;\n\t \n\tdma_config_tlv->length = sizeof(dma_config_tlv->dma_config);\n\n\tdma_config = &dma_config_tlv->dma_config;\n\n\tdma_config->dma_method = SOF_IPC4_DMA_METHOD_HDA;\n\tdma_config->pre_allocated_by_host = 1;\n\tdma_config->dma_channel_id = stream_id - 1;\n\tdma_config->stream_id = stream_id;\n\tdma_config->dma_stream_channel_map.device_count = 0;  \n\tdma_config->dma_priv_config_size = 0;\n\n\treturn 0;\n}\n\nstatic int non_hda_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint stream = substream->stream;\n\n\treturn non_hda_dai_hw_params(substream, &rtd->dpcm[stream].hw_params, cpu_dai);\n}\n\nstatic const struct snd_soc_dai_ops ssp_dai_ops = {\n\t.hw_params = non_hda_dai_hw_params,\n\t.hw_free = hda_dai_hw_free,\n\t.trigger = hda_dai_trigger,\n\t.prepare = non_hda_dai_prepare,\n};\n\nstatic const struct snd_soc_dai_ops dmic_dai_ops = {\n\t.hw_params = non_hda_dai_hw_params,\n\t.hw_free = hda_dai_hw_free,\n\t.trigger = hda_dai_trigger,\n\t.prepare = non_hda_dai_prepare,\n};\n\nint sdw_hda_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  struct snd_soc_dai *cpu_dai,\n\t\t\t  int link_id)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, substream->stream);\n\tconst struct hda_dai_widget_dma_ops *ops;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct snd_sof_dev *sdev;\n\tint ret;\n\n\tret = non_hda_dai_hw_params(substream, params, cpu_dai);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"%s: non_hda_dai_hw_params failed %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tops = hda_dai_get_ops(substream, cpu_dai);\n\tsdev = widget_to_sdev(w);\n\thext_stream = ops->get_hext_stream(sdev, cpu_dai, substream);\n\n\tif (!hext_stream)\n\t\treturn -ENODEV;\n\n\t \n\tret = hdac_bus_eml_sdw_map_stream_ch(sof_to_bus(sdev), link_id, cpu_dai->id,\n\t\t\t\t\t     GENMASK(params_channels(params) - 1, 0),\n\t\t\t\t\t     hdac_stream(hext_stream)->stream_tag,\n\t\t\t\t\t     substream->stream);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"%s:  hdac_bus_eml_sdw_map_stream_ch failed %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint sdw_hda_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *cpu_dai,\n\t\t\tint link_id)\n{\n\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, substream->stream);\n\tstruct snd_sof_dev *sdev;\n\tint ret;\n\n\tret = hda_dai_hw_free(substream, cpu_dai);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"%s: non_hda_dai_hw_free failed %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tsdev = widget_to_sdev(w);\n\n\t \n\tret = hdac_bus_eml_sdw_map_stream_ch(sof_to_bus(sdev), link_id, cpu_dai->id,\n\t\t\t\t\t     0, 0, substream->stream);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"%s:  hdac_bus_eml_sdw_map_stream_ch failed %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint sdw_hda_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\treturn hda_dai_trigger(substream, cmd, cpu_dai);\n}\n\nstatic int hda_dai_suspend(struct hdac_bus *bus)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct hdac_ext_stream *hext_stream;\n\tstruct hdac_stream *s;\n\tint ret;\n\n\t \n\tlist_for_each_entry(s, &bus->stream_list, list) {\n\n\t\thext_stream = stream_to_hdac_ext_stream(s);\n\n\t\t \n\t\tif (hext_stream->link_substream) {\n\t\t\tconst struct hda_dai_widget_dma_ops *ops;\n\t\t\tstruct snd_sof_widget *swidget;\n\t\t\tstruct snd_soc_dapm_widget *w;\n\t\t\tstruct snd_soc_dai *cpu_dai;\n\t\t\tstruct snd_sof_dev *sdev;\n\t\t\tstruct snd_sof_dai *sdai;\n\n\t\t\trtd = asoc_substream_to_rtd(hext_stream->link_substream);\n\t\t\tcpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\t\t\tw = snd_soc_dai_get_widget(cpu_dai, hdac_stream(hext_stream)->direction);\n\t\t\tswidget = w->dobj.private;\n\t\t\tsdev = widget_to_sdev(w);\n\t\t\tsdai = swidget->private;\n\t\t\tops = sdai->platform_private;\n\n\t\t\tret = hda_link_dma_cleanup(hext_stream->link_substream,\n\t\t\t\t\t\t   hext_stream,\n\t\t\t\t\t\t   cpu_dai);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tif (ops->post_trigger) {\n\t\t\t\tret = ops->post_trigger(sdev, cpu_dai,\n\t\t\t\t\t\t\thext_stream->link_substream,\n\t\t\t\t\t\t\tSNDRV_PCM_TRIGGER_SUSPEND);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ssp_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\tint i;\n\n\tchip = get_chip_info(sdev->pdata);\n\n\tif (chip->hw_ip_version >= SOF_INTEL_ACE_2_0) {\n\t\tfor (i = 0; i < ops->num_drv; i++) {\n\t\t\tif (strstr(ops->drv[i].name, \"SSP\"))\n\t\t\t\tops->drv[i].ops = &ssp_dai_ops;\n\t\t}\n\t}\n}\n\nstatic void dmic_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops)\n{\n\tconst struct sof_intel_dsp_desc *chip;\n\tint i;\n\n\tchip = get_chip_info(sdev->pdata);\n\n\tif (chip->hw_ip_version >= SOF_INTEL_ACE_2_0) {\n\t\tfor (i = 0; i < ops->num_drv; i++) {\n\t\t\tif (strstr(ops->drv[i].name, \"DMIC\"))\n\t\t\t\tops->drv[i].ops = &dmic_dai_ops;\n\t\t}\n\t}\n}\n\n#else\n\nstatic inline void ssp_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops) {}\nstatic inline void dmic_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops) {}\n\n#endif  \n\nvoid hda_set_dai_drv_ops(struct snd_sof_dev *sdev, struct snd_sof_dsp_ops *ops)\n{\n\tint i;\n\n\tfor (i = 0; i < ops->num_drv; i++) {\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC)\n\t\tif (strstr(ops->drv[i].name, \"iDisp\") ||\n\t\t    strstr(ops->drv[i].name, \"Analog\") ||\n\t\t    strstr(ops->drv[i].name, \"Digital\"))\n\t\t\tops->drv[i].ops = &hda_dai_ops;\n#endif\n\t}\n\n\tssp_set_dai_drv_ops(sdev, ops);\n\tdmic_set_dai_drv_ops(sdev, ops);\n\n\tif (sdev->pdata->ipc_type == SOF_INTEL_IPC4 && !hda_use_tplg_nhlt) {\n\t\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\n\t\tipc4_data->nhlt = intel_nhlt_init(sdev->dev);\n\t}\n}\n\nvoid hda_ops_free(struct snd_sof_dev *sdev)\n{\n\tif (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {\n\t\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\n\t\tif (!hda_use_tplg_nhlt)\n\t\t\tintel_nhlt_free(ipc4_data->nhlt);\n\t}\n}\nEXPORT_SYMBOL_NS(hda_ops_free, SND_SOC_SOF_INTEL_HDA_COMMON);\n\n \nstruct snd_soc_dai_driver skl_dai[] = {\n{\n\t.name = \"SSP0 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"SSP1 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"SSP2 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"SSP3 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"SSP4 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"SSP5 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"DMIC01 Pin\",\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 4,\n\t},\n},\n{\n\t.name = \"DMIC16k Pin\",\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 4,\n\t},\n},\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_AUDIO_CODEC)\n{\n\t.name = \"iDisp1 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"iDisp2 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"iDisp3 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"iDisp4 Pin\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t},\n},\n{\n\t.name = \"Analog CPU DAI\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n},\n{\n\t.name = \"Digital CPU DAI\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n},\n{\n\t.name = \"Alt Analog CPU DAI\",\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t},\n},\n#endif\n};\n\nint hda_dsp_dais_suspend(struct snd_sof_dev *sdev)\n{\n\t \n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_LINK)\n\tint ret;\n\n\tret = hda_dai_suspend(sof_to_bus(sdev));\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}