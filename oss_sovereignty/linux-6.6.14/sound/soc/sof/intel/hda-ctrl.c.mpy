{
  "module_name": "hda-ctrl.c",
  "hash_id": "d175b4682ec7df949ae40eed09f90ae1fe27ba84f29ed7493b1cb164d5ff904f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-ctrl.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/hda_component.h>\n#include <sound/hda-mlink.h>\n#include \"../ops.h\"\n#include \"hda.h\"\n\n \n\nint hda_dsp_ctrl_link_reset(struct snd_sof_dev *sdev, bool reset)\n{\n\tunsigned long timeout;\n\tu32 gctl = 0;\n\tu32 val;\n\n\t \n\tval = reset ? 0 : SOF_HDA_GCTL_RESET;\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL,\n\t\t\t\tSOF_HDA_GCTL_RESET, val);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(HDA_DSP_CTRL_RESET_TIMEOUT);\n\twhile (time_before(jiffies, timeout)) {\n\t\tgctl = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_GCTL);\n\t\tif ((gctl & SOF_HDA_GCTL_RESET) == val)\n\t\t\treturn 0;\n\t\tusleep_range(500, 1000);\n\t}\n\n\t \n\tdev_err(sdev->dev, \"error: failed to %s HDA controller gctl 0x%x\\n\",\n\t\treset ? \"reset\" : \"ready\", gctl);\n\treturn -EIO;\n}\n\nint hda_dsp_ctrl_get_caps(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tu32 cap, offset, feature;\n\tint count = 0;\n\tint ret;\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, true);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = hda_dsp_ctrl_link_reset(sdev, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffset = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, SOF_HDA_LLCH);\n\n\tdo {\n\t\tdev_dbg(sdev->dev, \"checking for capabilities at offset 0x%x\\n\",\n\t\t\toffset & SOF_HDA_CAP_NEXT_MASK);\n\n\t\tcap = snd_sof_dsp_read(sdev, HDA_DSP_HDA_BAR, offset);\n\n\t\tif (cap == -1) {\n\t\t\tdev_dbg(bus->dev, \"Invalid capability reg read\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfeature = (cap & SOF_HDA_CAP_ID_MASK) >> SOF_HDA_CAP_ID_OFF;\n\n\t\tswitch (feature) {\n\t\tcase SOF_HDA_PP_CAP_ID:\n\t\t\tdev_dbg(sdev->dev, \"found DSP capability at 0x%x\\n\",\n\t\t\t\toffset);\n\t\t\tbus->ppcap = bus->remap_addr + offset;\n\t\t\tsdev->bar[HDA_DSP_PP_BAR] = bus->ppcap;\n\t\t\tbreak;\n\t\tcase SOF_HDA_SPIB_CAP_ID:\n\t\t\tdev_dbg(sdev->dev, \"found SPIB capability at 0x%x\\n\",\n\t\t\t\toffset);\n\t\t\tbus->spbcap = bus->remap_addr + offset;\n\t\t\tsdev->bar[HDA_DSP_SPIB_BAR] = bus->spbcap;\n\t\t\tbreak;\n\t\tcase SOF_HDA_DRSM_CAP_ID:\n\t\t\tdev_dbg(sdev->dev, \"found DRSM capability at 0x%x\\n\",\n\t\t\t\toffset);\n\t\t\tbus->drsmcap = bus->remap_addr + offset;\n\t\t\tsdev->bar[HDA_DSP_DRSM_BAR] = bus->drsmcap;\n\t\t\tbreak;\n\t\tcase SOF_HDA_GTS_CAP_ID:\n\t\t\tdev_dbg(sdev->dev, \"found GTS capability at 0x%x\\n\",\n\t\t\t\toffset);\n\t\t\tbus->gtscap = bus->remap_addr + offset;\n\t\t\tbreak;\n\t\tcase SOF_HDA_ML_CAP_ID:\n\t\t\tdev_dbg(sdev->dev, \"found ML capability at 0x%x\\n\",\n\t\t\t\toffset);\n\t\t\tbus->mlcap = bus->remap_addr + offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(sdev->dev, \"found capability %d at 0x%x\\n\",\n\t\t\t\tfeature, offset);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = cap & SOF_HDA_CAP_NEXT_MASK;\n\t} while (count++ <= SOF_HDA_MAX_CAPS && offset);\n\n\treturn 0;\n}\n\nvoid hda_dsp_ctrl_ppcap_enable(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 val = enable ? SOF_HDA_PPCTL_GPROCEN : 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\tSOF_HDA_PPCTL_GPROCEN, val);\n}\n\nvoid hda_dsp_ctrl_ppcap_int_enable(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 val\t= enable ? SOF_HDA_PPCTL_PIE : 0;\n\n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_PP_BAR, SOF_HDA_REG_PP_PPCTL,\n\t\t\t\tSOF_HDA_PPCTL_PIE, val);\n}\n\nvoid hda_dsp_ctrl_misc_clock_gating(struct snd_sof_dev *sdev, bool enable)\n{\n\tu32 val = enable ? PCI_CGCTL_MISCBDCGE_MASK : 0;\n\n\tsnd_sof_pci_update_bits(sdev, PCI_CGCTL, PCI_CGCTL_MISCBDCGE_MASK, val);\n}\n\n \nint hda_dsp_ctrl_clock_power_gating(struct snd_sof_dev *sdev, bool enable)\n{\n\tstruct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;\n\tu32 val;\n\n\t \n\tval = enable ? PCI_CGCTL_ADSPDCGE : 0;\n\tsnd_sof_pci_update_bits(sdev, PCI_CGCTL, PCI_CGCTL_ADSPDCGE, val);\n\n\t \n\tval = enable ? HDA_VS_INTEL_EM2_L1SEN : 0;\n\tif (!enable || !hda->l1_disabled)\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, HDA_VS_INTEL_EM2,\n\t\t\t\t\tHDA_VS_INTEL_EM2_L1SEN, val);\n\n\t \n\tval = enable ? 0 : PCI_PGCTL_ADSPPGD;\n\tsnd_sof_pci_update_bits(sdev, PCI_PGCTL, PCI_PGCTL_ADSPPGD, val);\n\n\treturn 0;\n}\n\nint hda_dsp_ctrl_init_chip(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_stream *stream;\n\tint sd_offset, ret = 0;\n\n\tif (bus->chip_init)\n\t\treturn 0;\n\n\thda_codec_set_codec_wakeup(sdev, true);\n\n\thda_dsp_ctrl_misc_clock_gating(sdev, false);\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, true);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to reset HDA controller\\n\");\n\t\tgoto err;\n\t}\n\n\tusleep_range(500, 1000);\n\n\t \n\tret = hda_dsp_ctrl_link_reset(sdev, false);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"error: failed to exit HDA controller reset\\n\");\n\t\tgoto err;\n\t}\n\tusleep_range(1000, 1200);\n\n\thda_codec_detect_mask(sdev);\n\n\t \n\tlist_for_each_entry(stream, &bus->stream_list, list) {\n\t\tsd_offset = SOF_STREAM_SD_OFFSET(stream);\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_STS,\n\t\t\t\t  SOF_HDA_CL_DMA_SD_INT_MASK);\n\t}\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_WAKESTS,\n\t\t\t  SOF_HDA_WAKESTS_INT_MASK);\n\n\thda_codec_rirb_status_clear(sdev);\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS,\n\t\t\t  SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_ALL_STREAM);\n\n\thda_codec_init_cmd_io(sdev);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\tSOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN,\n\t\t\t\tSOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN);\n\n\t \n\tif (bus->use_posbuf && bus->posbuf.addr) {\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_ADSP_DPLBASE,\n\t\t\t\t  (u32)bus->posbuf.addr);\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_ADSP_DPUBASE,\n\t\t\t\t  upper_32_bits(bus->posbuf.addr));\n\t}\n\n\thda_bus_ml_reset_losidv(bus);\n\n\tbus->chip_init = true;\n\nerr:\n\thda_dsp_ctrl_misc_clock_gating(sdev, true);\n\n\thda_codec_set_codec_wakeup(sdev, false);\n\n\treturn ret;\n}\n\nvoid hda_dsp_ctrl_stop_chip(struct snd_sof_dev *sdev)\n{\n\tstruct hdac_bus *bus = sof_to_bus(sdev);\n\tstruct hdac_stream *stream;\n\tint sd_offset;\n\n\tif (!bus->chip_init)\n\t\treturn;\n\n\t \n\tlist_for_each_entry(stream, &bus->stream_list, list) {\n\t\tsd_offset = SOF_STREAM_SD_OFFSET(stream);\n\t\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t\tsd_offset +\n\t\t\t\t\tSOF_HDA_ADSP_REG_SD_CTL,\n\t\t\t\t\tSOF_HDA_CL_DMA_SD_INT_MASK,\n\t\t\t\t\t0);\n\t}\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\tSOF_HDA_INT_ALL_STREAM,\t0);\n\n\t \n\tsnd_sof_dsp_update_bits(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTCTL,\n\t\t\t\tSOF_HDA_INT_CTRL_EN | SOF_HDA_INT_GLOBAL_EN,\n\t\t\t\t0);\n\n\t \n\tlist_for_each_entry(stream, &bus->stream_list, list) {\n\t\tsd_offset = SOF_STREAM_SD_OFFSET(stream);\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t  sd_offset + SOF_HDA_ADSP_REG_SD_STS,\n\t\t\t\t  SOF_HDA_CL_DMA_SD_INT_MASK);\n\t}\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_WAKESTS,\n\t\t\t  SOF_HDA_WAKESTS_INT_MASK);\n\n\thda_codec_rirb_status_clear(sdev);\n\n\t \n\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR, SOF_HDA_INTSTS,\n\t\t\t  SOF_HDA_INT_CTRL_EN | SOF_HDA_INT_ALL_STREAM);\n\n\thda_codec_stop_cmd_io(sdev);\n\n\t \n\tif (bus->use_posbuf && bus->posbuf.addr) {\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t  SOF_HDA_ADSP_DPLBASE, 0);\n\t\tsnd_sof_dsp_write(sdev, HDA_DSP_HDA_BAR,\n\t\t\t\t  SOF_HDA_ADSP_DPUBASE, 0);\n\t}\n\n\tbus->chip_init = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}