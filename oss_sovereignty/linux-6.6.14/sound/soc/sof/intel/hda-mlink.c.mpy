{
  "module_name": "hda-mlink.c",
  "hash_id": "f33b1ba9b6ba74eab8330655147276310277c2aab5cbd85436e45bef1d55ee0b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/intel/hda-mlink.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n \n\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_register.h>\n#include <sound/hda-mlink.h>\n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA_MLINK)\n\n \n#define HDAML_MAX_SUBLINKS (AZX_ML_LCTL_CPA_SHIFT - AZX_ML_LCTL_SPA_SHIFT)\n\n \nstruct hdac_ext2_link {\n\tstruct hdac_ext_link hext_link;\n\n\t \n\tbool alt;\n\tbool intc;\n\tbool ofls;\n\tbool lss;\n\tint slcount;\n\tint elid;\n\tint elver;\n\tu32 leptr;\n\n\tstruct mutex eml_lock;  \n\tint sublink_ref_count[HDAML_MAX_SUBLINKS];\n\n\t \n\tvoid __iomem *base_ptr;\n\tu32 instance_offset;\n\tu32 shim_offset;\n\tu32 ip_offset;\n\tu32 shim_vs_offset;\n};\n\n#define hdac_ext_link_to_ext2(h) container_of(h, struct hdac_ext2_link, hext_link)\n\n#define AZX_REG_SDW_INSTANCE_OFFSET\t\t\t0x8000\n#define AZX_REG_SDW_SHIM_OFFSET\t\t\t\t0x0\n#define AZX_REG_SDW_IP_OFFSET\t\t\t\t0x100\n#define AZX_REG_SDW_VS_SHIM_OFFSET\t\t\t0x6000\n#define AZX_REG_SDW_SHIM_PCMSyCM(y)\t\t\t(0x16 + 0x4 * (y))\n\n \n#define AZX_REG_INTEL_DMIC_SHIM_OFFSET\t\t\t0x0\n#define AZX_REG_INTEL_DMIC_IP_OFFSET\t\t\t0x100\n#define AZX_REG_INTEL_DMIC_VS_SHIM_OFFSET\t\t0x6000\n\n#define AZX_REG_INTEL_SSP_INSTANCE_OFFSET\t\t0x1000\n#define AZX_REG_INTEL_SSP_SHIM_OFFSET\t\t\t0x0\n#define AZX_REG_INTEL_SSP_IP_OFFSET\t\t\t0x100\n#define AZX_REG_INTEL_SSP_VS_SHIM_OFFSET\t\t0xC00\n\n \n#define AZX_REG_INTEL_UAOL_SHIM_OFFSET\t\t\t0x0\n#define AZX_REG_INTEL_UAOL_IP_OFFSET\t\t\t0x100\n#define AZX_REG_INTEL_UAOL_VS_SHIM_OFFSET\t\t0xC00\n\n \n\nstatic int hdaml_lnk_enum(struct device *dev, struct hdac_ext2_link *h2link,\n\t\t\t  void __iomem *remap_addr, void __iomem *ml_addr, int link_idx)\n{\n\tstruct hdac_ext_link *hlink = &h2link->hext_link;\n\tu32 base_offset;\n\n\thlink->lcaps  = readl(ml_addr + AZX_REG_ML_LCAP);\n\n\th2link->alt = FIELD_GET(AZX_ML_HDA_LCAP_ALT, hlink->lcaps);\n\n\t \n\tif (!h2link->alt) {\n\t\th2link->slcount = 1;\n\n\t\t \n\t\thlink->lsdiid = readw(ml_addr + AZX_REG_ML_LSDIID);\n\n\t\tdev_dbg(dev, \"Link %d: HDAudio - lsdiid=%d\\n\",\n\t\t\tlink_idx, hlink->lsdiid);\n\n\t\treturn 0;\n\t}\n\n\th2link->intc = FIELD_GET(AZX_ML_HDA_LCAP_INTC, hlink->lcaps);\n\th2link->ofls = FIELD_GET(AZX_ML_HDA_LCAP_OFLS, hlink->lcaps);\n\th2link->lss = FIELD_GET(AZX_ML_HDA_LCAP_LSS, hlink->lcaps);\n\n\t \n\th2link->slcount = FIELD_GET(AZX_ML_HDA_LCAP_SLCOUNT, hlink->lcaps) + 1;\n\tdev_dbg(dev, \"Link %d: HDAudio extended - sublink count %d\\n\",\n\t\tlink_idx, h2link->slcount);\n\n\t \n\th2link->leptr = readl(ml_addr + AZX_REG_ML_LEPTR);\n\n\th2link->elid = FIELD_GET(AZX_REG_ML_LEPTR_ID, h2link->leptr);\n\n\tbase_offset = FIELD_GET(AZX_REG_ML_LEPTR_PTR, h2link->leptr);\n\th2link->base_ptr = remap_addr + base_offset;\n\n\tswitch (h2link->elid) {\n\tcase AZX_REG_ML_LEPTR_ID_SDW:\n\t\th2link->instance_offset = AZX_REG_SDW_INSTANCE_OFFSET;\n\t\th2link->shim_offset = AZX_REG_SDW_SHIM_OFFSET;\n\t\th2link->ip_offset = AZX_REG_SDW_IP_OFFSET;\n\t\th2link->shim_vs_offset = AZX_REG_SDW_VS_SHIM_OFFSET;\n\t\tdev_dbg(dev, \"Link %d: HDAudio extended - SoundWire alternate link, leptr.ptr %#x\\n\",\n\t\t\tlink_idx, base_offset);\n\t\tbreak;\n\tcase AZX_REG_ML_LEPTR_ID_INTEL_DMIC:\n\t\th2link->shim_offset = AZX_REG_INTEL_DMIC_SHIM_OFFSET;\n\t\th2link->ip_offset = AZX_REG_INTEL_DMIC_IP_OFFSET;\n\t\th2link->shim_vs_offset = AZX_REG_INTEL_DMIC_VS_SHIM_OFFSET;\n\t\tdev_dbg(dev, \"Link %d: HDAudio extended - INTEL DMIC alternate link, leptr.ptr %#x\\n\",\n\t\t\tlink_idx, base_offset);\n\t\tbreak;\n\tcase AZX_REG_ML_LEPTR_ID_INTEL_SSP:\n\t\th2link->instance_offset = AZX_REG_INTEL_SSP_INSTANCE_OFFSET;\n\t\th2link->shim_offset = AZX_REG_INTEL_SSP_SHIM_OFFSET;\n\t\th2link->ip_offset = AZX_REG_INTEL_SSP_IP_OFFSET;\n\t\th2link->shim_vs_offset = AZX_REG_INTEL_SSP_VS_SHIM_OFFSET;\n\t\tdev_dbg(dev, \"Link %d: HDAudio extended - INTEL SSP alternate link, leptr.ptr %#x\\n\",\n\t\t\tlink_idx, base_offset);\n\t\tbreak;\n\tcase AZX_REG_ML_LEPTR_ID_INTEL_UAOL:\n\t\th2link->shim_offset = AZX_REG_INTEL_UAOL_SHIM_OFFSET;\n\t\th2link->ip_offset = AZX_REG_INTEL_UAOL_IP_OFFSET;\n\t\th2link->shim_vs_offset = AZX_REG_INTEL_UAOL_VS_SHIM_OFFSET;\n\t\tdev_dbg(dev, \"Link %d: HDAudio extended - INTEL UAOL alternate link, leptr.ptr %#x\\n\",\n\t\t\tlink_idx, base_offset);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Link %d: HDAudio extended - Unsupported alternate link, leptr.id=%#02x value\\n\",\n\t\t\tlink_idx, h2link->elid);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \n#define HDAML_POLL_DELAY_MIN_US 10\n#define HDAML_POLL_DELAY_SLACK_US 5\n#define HDAML_POLL_DELAY_RETRY  100\n\nstatic int check_sublink_power(u32 __iomem *lctl, int sublink, bool enabled)\n{\n\tint mask = BIT(sublink) << AZX_ML_LCTL_CPA_SHIFT;\n\tint retry = HDAML_POLL_DELAY_RETRY;\n\tu32 val;\n\n\tusleep_range(HDAML_POLL_DELAY_MIN_US,\n\t\t     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);\n\tdo {\n\t\tval = readl(lctl);\n\t\tif (enabled) {\n\t\t\tif (val & mask)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!(val & mask))\n\t\t\t\treturn 0;\n\t\t}\n\t\tusleep_range(HDAML_POLL_DELAY_MIN_US,\n\t\t\t     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);\n\n\t} while (--retry);\n\n\treturn -EIO;\n}\n\nstatic int hdaml_link_init(u32 __iomem *lctl, int sublink)\n{\n\tu32 val;\n\tu32 mask = BIT(sublink) << AZX_ML_LCTL_SPA_SHIFT;\n\n\tval = readl(lctl);\n\tval |= mask;\n\n\twritel(val, lctl);\n\n\treturn check_sublink_power(lctl, sublink, true);\n}\n\nstatic int hdaml_link_shutdown(u32 __iomem *lctl, int sublink)\n{\n\tu32 val;\n\tu32 mask;\n\n\tval = readl(lctl);\n\tmask = BIT(sublink) << AZX_ML_LCTL_SPA_SHIFT;\n\tval &= ~mask;\n\n\twritel(val, lctl);\n\n\treturn check_sublink_power(lctl, sublink, false);\n}\n\nstatic void hdaml_link_enable_interrupt(u32 __iomem *lctl, bool enable)\n{\n\tu32 val;\n\n\tval = readl(lctl);\n\tif (enable)\n\t\tval |= AZX_ML_LCTL_INTEN;\n\telse\n\t\tval &= ~AZX_ML_LCTL_INTEN;\n\n\twritel(val, lctl);\n}\n\nstatic bool hdaml_link_check_interrupt(u32 __iomem *lctl)\n{\n\tu32 val;\n\n\tval = readl(lctl);\n\n\treturn val & AZX_ML_LCTL_INTSTS;\n}\n\nstatic int hdaml_wait_bit(void __iomem *base, int offset, u32 mask, u32 target)\n{\n\tint timeout = HDAML_POLL_DELAY_RETRY;\n\tu32 reg_read;\n\n\tdo {\n\t\treg_read = readl(base + offset);\n\t\tif ((reg_read & mask) == target)\n\t\t\treturn 0;\n\n\t\ttimeout--;\n\t\tusleep_range(HDAML_POLL_DELAY_MIN_US,\n\t\t\t     HDAML_POLL_DELAY_MIN_US + HDAML_POLL_DELAY_SLACK_US);\n\t} while (timeout != 0);\n\n\treturn -EAGAIN;\n}\n\nstatic void hdaml_link_set_syncprd(u32 __iomem *lsync, u32 syncprd)\n{\n\tu32 val;\n\n\tval = readl(lsync);\n\tval &= ~AZX_REG_ML_LSYNC_SYNCPRD;\n\tval |= (syncprd & AZX_REG_ML_LSYNC_SYNCPRD);\n\n\t \n\tval |= AZX_REG_ML_LSYNC_SYNCPU;\n\n\twritel(val, lsync);\n}\n\nstatic int hdaml_link_wait_syncpu(u32 __iomem *lsync)\n{\n\treturn hdaml_wait_bit(lsync, 0, AZX_REG_ML_LSYNC_SYNCPU, 0);\n}\n\nstatic void hdaml_link_sync_arm(u32 __iomem *lsync, int sublink)\n{\n\tu32 val;\n\n\tval = readl(lsync);\n\tval |= (AZX_REG_ML_LSYNC_CMDSYNC << sublink);\n\n\twritel(val, lsync);\n}\n\nstatic void hdaml_link_sync_go(u32 __iomem *lsync)\n{\n\tu32 val;\n\n\tval = readl(lsync);\n\tval |= AZX_REG_ML_LSYNC_SYNCGO;\n\n\twritel(val, lsync);\n}\n\nstatic bool hdaml_link_check_cmdsync(u32 __iomem *lsync, u32 cmdsync_mask)\n{\n\tu32 val;\n\n\tval = readl(lsync);\n\n\treturn !!(val & cmdsync_mask);\n}\n\nstatic u16 hdaml_link_get_lsdiid(u16 __iomem *lsdiid)\n{\n\treturn readw(lsdiid);\n}\n\nstatic void hdaml_link_set_lsdiid(u16 __iomem *lsdiid, int dev_num)\n{\n\tu16 val;\n\n\tval = readw(lsdiid);\n\tval |= BIT(dev_num);\n\n\twritew(val, lsdiid);\n}\n\nstatic void hdaml_shim_map_stream_ch(u16 __iomem *pcmsycm, int lchan, int hchan,\n\t\t\t\t     int stream_id, int dir)\n{\n\tu16 val;\n\n\tval = readw(pcmsycm);\n\n\tu16p_replace_bits(&val, lchan, GENMASK(3, 0));\n\tu16p_replace_bits(&val, hchan, GENMASK(7, 4));\n\tu16p_replace_bits(&val, stream_id, GENMASK(13, 8));\n\tu16p_replace_bits(&val, dir, BIT(15));\n\n\twritew(val, pcmsycm);\n}\n\nstatic void hdaml_lctl_offload_enable(u32 __iomem *lctl, bool enable)\n{\n\tu32 val = readl(lctl);\n\n\tif (enable)\n\t\tval |=  AZX_ML_LCTL_OFLEN;\n\telse\n\t\tval &=  ~AZX_ML_LCTL_OFLEN;\n\n\twritel(val, lctl);\n}\n\n \n\nstatic int hda_ml_alloc_h2link(struct hdac_bus *bus, int index)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\th2link  = kzalloc(sizeof(*h2link), GFP_KERNEL);\n\tif (!h2link)\n\t\treturn -ENOMEM;\n\n\t \n\thlink = &h2link->hext_link;\n\n\thlink->index = index;\n\thlink->bus = bus;\n\thlink->ml_addr = bus->mlcap + AZX_ML_BASE + (AZX_ML_INTERVAL * index);\n\n\tret = hdaml_lnk_enum(bus->dev, h2link, bus->remap_addr, hlink->ml_addr, index);\n\tif (ret < 0) {\n\t\tkfree(h2link);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&h2link->eml_lock);\n\n\tlist_add_tail(&hlink->list, &bus->hlink_list);\n\n\t \n\tif (!h2link->alt)\n\t\thlink->ref_count = 1;\n\n\treturn 0;\n}\n\nint hda_bus_ml_init(struct hdac_bus *bus)\n{\n\tu32 link_count;\n\tint ret;\n\tint i;\n\n\tif (!bus->mlcap)\n\t\treturn 0;\n\n\tlink_count = readl(bus->mlcap + AZX_REG_ML_MLCD) + 1;\n\n\tdev_dbg(bus->dev, \"HDAudio Multi-Link count: %d\\n\", link_count);\n\n\tfor (i = 0; i < link_count; i++) {\n\t\tret = hda_ml_alloc_h2link(bus, i);\n\t\tif (ret < 0) {\n\t\t\thda_bus_ml_free(bus);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_init, SND_SOC_SOF_HDA_MLINK);\n\nvoid hda_bus_ml_free(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink, *_h;\n\tstruct hdac_ext2_link *h2link;\n\n\tif (!bus->mlcap)\n\t\treturn;\n\n\tlist_for_each_entry_safe(hlink, _h, &bus->hlink_list, list) {\n\t\tlist_del(&hlink->list);\n\t\th2link = hdac_ext_link_to_ext2(hlink);\n\n\t\tmutex_destroy(&h2link->eml_lock);\n\t\tkfree(h2link);\n\t}\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_free, SND_SOC_SOF_HDA_MLINK);\n\nstatic struct hdac_ext2_link *\nfind_ext2_link(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext_link *hlink;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tstruct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);\n\n\t\tif (h2link->alt == alt && h2link->elid == elid)\n\t\t\treturn h2link;\n\t}\n\n\treturn NULL;\n}\n\nint hdac_bus_eml_get_count(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn 0;\n\n\treturn h2link->slcount;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_get_count, SND_SOC_SOF_HDA_MLINK);\n\nvoid hdac_bus_eml_enable_interrupt(struct hdac_bus *bus, bool alt, int elid, bool enable)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn;\n\n\tif (!h2link->intc)\n\t\treturn;\n\n\thlink = &h2link->hext_link;\n\n\tmutex_lock(&h2link->eml_lock);\n\n\thdaml_link_enable_interrupt(hlink->ml_addr + AZX_REG_ML_LCTL, enable);\n\n\tmutex_unlock(&h2link->eml_lock);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_enable_interrupt, SND_SOC_SOF_HDA_MLINK);\n\nbool hdac_bus_eml_check_interrupt(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn false;\n\n\tif (!h2link->intc)\n\t\treturn false;\n\n\thlink = &h2link->hext_link;\n\n\treturn hdaml_link_check_interrupt(hlink->ml_addr + AZX_REG_ML_LCTL);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_check_interrupt, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_set_syncprd_unlocked(struct hdac_bus *bus, bool alt, int elid, u32 syncprd)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn 0;\n\n\tif (!h2link->lss)\n\t\treturn 0;\n\n\thlink = &h2link->hext_link;\n\n\thdaml_link_set_syncprd(hlink->ml_addr + AZX_REG_ML_LSYNC, syncprd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_set_syncprd_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_set_syncprd_unlocked(struct hdac_bus *bus, u32 syncprd)\n{\n\treturn hdac_bus_eml_set_syncprd_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, syncprd);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_set_syncprd_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_wait_syncpu_unlocked(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn 0;\n\n\tif (!h2link->lss)\n\t\treturn 0;\n\n\thlink = &h2link->hext_link;\n\n\treturn hdaml_link_wait_syncpu(hlink->ml_addr + AZX_REG_ML_LSYNC);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_wait_syncpu_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_wait_syncpu_unlocked(struct hdac_bus *bus)\n{\n\treturn hdac_bus_eml_wait_syncpu_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_wait_syncpu_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nvoid hdac_bus_eml_sync_arm_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn;\n\n\tif (!h2link->lss)\n\t\treturn;\n\n\thlink = &h2link->hext_link;\n\n\thdaml_link_sync_arm(hlink->ml_addr + AZX_REG_ML_LSYNC, sublink);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sync_arm_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nvoid hdac_bus_eml_sdw_sync_arm_unlocked(struct hdac_bus *bus, int sublink)\n{\n\thdac_bus_eml_sync_arm_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, sublink);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_sync_arm_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sync_go_unlocked(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn 0;\n\n\tif (!h2link->lss)\n\t\treturn 0;\n\n\thlink = &h2link->hext_link;\n\n\thdaml_link_sync_go(hlink->ml_addr + AZX_REG_ML_LSYNC);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sync_go_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_sync_go_unlocked(struct hdac_bus *bus)\n{\n\treturn hdac_bus_eml_sync_go_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_sync_go_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nbool hdac_bus_eml_check_cmdsync_unlocked(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\tu32 cmdsync_mask;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn 0;\n\n\tif (!h2link->lss)\n\t\treturn 0;\n\n\thlink = &h2link->hext_link;\n\n\tcmdsync_mask = GENMASK(AZX_REG_ML_LSYNC_CMDSYNC_SHIFT + h2link->slcount - 1,\n\t\t\t       AZX_REG_ML_LSYNC_CMDSYNC_SHIFT);\n\n\treturn hdaml_link_check_cmdsync(hlink->ml_addr + AZX_REG_ML_LSYNC,\n\t\t\t\t\tcmdsync_mask);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_check_cmdsync_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nbool hdac_bus_eml_sdw_check_cmdsync_unlocked(struct hdac_bus *bus)\n{\n\treturn hdac_bus_eml_check_cmdsync_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_check_cmdsync_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nstatic int hdac_bus_eml_power_up_base(struct hdac_bus *bus, bool alt, int elid, int sublink,\n\t\t\t\t      bool eml_lock)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\tint ret = 0;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\tif (sublink >= h2link->slcount)\n\t\treturn -EINVAL;\n\n\thlink = &h2link->hext_link;\n\n\tif (eml_lock)\n\t\tmutex_lock(&h2link->eml_lock);\n\n\tif (!alt) {\n\t\tif (++hlink->ref_count > 1)\n\t\t\tgoto skip_init;\n\t} else {\n\t\tif (++h2link->sublink_ref_count[sublink] > 1)\n\t\t\tgoto skip_init;\n\t}\n\n\tret = hdaml_link_init(hlink->ml_addr + AZX_REG_ML_LCTL, sublink);\n\nskip_init:\n\tif (eml_lock)\n\t\tmutex_unlock(&h2link->eml_lock);\n\n\treturn ret;\n}\n\nint hdac_bus_eml_power_up(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn hdac_bus_eml_power_up_base(bus, alt, elid, sublink, true);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_power_up, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_power_up_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn hdac_bus_eml_power_up_base(bus, alt, elid, sublink, false);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_power_up_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nstatic int hdac_bus_eml_power_down_base(struct hdac_bus *bus, bool alt, int elid, int sublink,\n\t\t\t\t\tbool eml_lock)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\tint ret = 0;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\tif (sublink >= h2link->slcount)\n\t\treturn -EINVAL;\n\n\thlink = &h2link->hext_link;\n\n\tif (eml_lock)\n\t\tmutex_lock(&h2link->eml_lock);\n\n\tif (!alt) {\n\t\tif (--hlink->ref_count > 0)\n\t\t\tgoto skip_shutdown;\n\t} else {\n\t\tif (--h2link->sublink_ref_count[sublink] > 0)\n\t\t\tgoto skip_shutdown;\n\t}\n\tret = hdaml_link_shutdown(hlink->ml_addr + AZX_REG_ML_LCTL, sublink);\n\nskip_shutdown:\n\tif (eml_lock)\n\t\tmutex_unlock(&h2link->eml_lock);\n\n\treturn ret;\n}\n\nint hdac_bus_eml_power_down(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn hdac_bus_eml_power_down_base(bus, alt, elid, sublink, true);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_power_down, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_power_down_unlocked(struct hdac_bus *bus, bool alt, int elid, int sublink)\n{\n\treturn hdac_bus_eml_power_down_base(bus, alt, elid, sublink, false);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_power_down_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_power_up_unlocked(struct hdac_bus *bus, int sublink)\n{\n\treturn hdac_bus_eml_power_up_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, sublink);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_power_up_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_power_down_unlocked(struct hdac_bus *bus, int sublink)\n{\n\treturn hdac_bus_eml_power_down_unlocked(bus, true, AZX_REG_ML_LEPTR_ID_SDW, sublink);\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_power_down_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_get_lsdiid_unlocked(struct hdac_bus *bus, int sublink, u16 *lsdiid)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\thlink = &h2link->hext_link;\n\n\t*lsdiid = hdaml_link_get_lsdiid(hlink->ml_addr + AZX_REG_ML_LSDIID_OFFSET(sublink));\n\n\treturn 0;\n} EXPORT_SYMBOL_NS(hdac_bus_eml_sdw_get_lsdiid_unlocked, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_sdw_set_lsdiid(struct hdac_bus *bus, int sublink, int dev_num)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\thlink = &h2link->hext_link;\n\n\tmutex_lock(&h2link->eml_lock);\n\n\thdaml_link_set_lsdiid(hlink->ml_addr + AZX_REG_ML_LSDIID_OFFSET(sublink), dev_num);\n\n\tmutex_unlock(&h2link->eml_lock);\n\n\treturn 0;\n} EXPORT_SYMBOL_NS(hdac_bus_eml_sdw_set_lsdiid, SND_SOC_SOF_HDA_MLINK);\n\n \nint hdac_bus_eml_sdw_map_stream_ch(struct hdac_bus *bus, int sublink, int y,\n\t\t\t\t   int channel_mask, int stream_id, int dir)\n{\n\tstruct hdac_ext2_link *h2link;\n\tu16 __iomem *pcmsycm;\n\tint hchan;\n\tint lchan;\n\tu16 val;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\tpcmsycm = h2link->base_ptr + h2link->shim_offset +\n\t\th2link->instance_offset * sublink +\n\t\tAZX_REG_SDW_SHIM_PCMSyCM(y);\n\n\tif (channel_mask) {\n\t\thchan = __fls(channel_mask);\n\t\tlchan = __ffs(channel_mask);\n\t} else {\n\t\thchan = 0;\n\t\tlchan = 0;\n\t}\n\n\tmutex_lock(&h2link->eml_lock);\n\n\thdaml_shim_map_stream_ch(pcmsycm, lchan, hchan,\n\t\t\t\t stream_id, dir);\n\n\tmutex_unlock(&h2link->eml_lock);\n\n\tval = readw(pcmsycm);\n\n\tdev_dbg(bus->dev, \"sublink %d channel_mask %#x stream_id %d dir %d pcmscm %#x\\n\",\n\t\tsublink, channel_mask, stream_id, dir, val);\n\n\treturn 0;\n} EXPORT_SYMBOL_NS(hdac_bus_eml_sdw_map_stream_ch, SND_SOC_SOF_HDA_MLINK);\n\nvoid hda_bus_ml_put_all(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tstruct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);\n\n\t\tif (!h2link->alt)\n\t\t\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\t}\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_put_all, SND_SOC_SOF_HDA_MLINK);\n\nvoid hda_bus_ml_reset_losidv(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink;\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list)\n\t\twritel(0, hlink->ml_addr + AZX_REG_ML_LOSIDV);\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_reset_losidv, SND_SOC_SOF_HDA_MLINK);\n\nint hda_bus_ml_resume(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\t \n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tstruct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);\n\n\t\tif (!h2link->alt && hlink->ref_count) {\n\t\t\tret = snd_hdac_ext_bus_link_power_up(hlink);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_resume, SND_SOC_SOF_HDA_MLINK);\n\nint hda_bus_ml_suspend(struct hdac_bus *bus)\n{\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\tlist_for_each_entry(hlink, &bus->hlink_list, list) {\n\t\tstruct hdac_ext2_link *h2link = hdac_ext_link_to_ext2(hlink);\n\n\t\tif (!h2link->alt) {\n\t\t\tret = snd_hdac_ext_bus_link_power_down(hlink);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hda_bus_ml_suspend, SND_SOC_SOF_HDA_MLINK);\n\nstruct mutex *hdac_bus_eml_get_mutex(struct hdac_bus *bus, bool alt, int elid)\n{\n\tstruct hdac_ext2_link *h2link;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn NULL;\n\n\treturn &h2link->eml_lock;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_get_mutex, SND_SOC_SOF_HDA_MLINK);\n\nstruct hdac_ext_link *hdac_bus_eml_ssp_get_hlink(struct hdac_bus *bus)\n{\n\tstruct hdac_ext2_link *h2link;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_INTEL_SSP);\n\tif (!h2link)\n\t\treturn NULL;\n\n\treturn &h2link->hext_link;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_ssp_get_hlink, SND_SOC_SOF_HDA_MLINK);\n\nstruct hdac_ext_link *hdac_bus_eml_dmic_get_hlink(struct hdac_bus *bus)\n{\n\tstruct hdac_ext2_link *h2link;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_INTEL_DMIC);\n\tif (!h2link)\n\t\treturn NULL;\n\n\treturn &h2link->hext_link;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_dmic_get_hlink, SND_SOC_SOF_HDA_MLINK);\n\nstruct hdac_ext_link *hdac_bus_eml_sdw_get_hlink(struct hdac_bus *bus)\n{\n\tstruct hdac_ext2_link *h2link;\n\n\th2link = find_ext2_link(bus, true, AZX_REG_ML_LEPTR_ID_SDW);\n\tif (!h2link)\n\t\treturn NULL;\n\n\treturn &h2link->hext_link;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_sdw_get_hlink, SND_SOC_SOF_HDA_MLINK);\n\nint hdac_bus_eml_enable_offload(struct hdac_bus *bus, bool alt, int elid, bool enable)\n{\n\tstruct hdac_ext2_link *h2link;\n\tstruct hdac_ext_link *hlink;\n\n\th2link = find_ext2_link(bus, alt, elid);\n\tif (!h2link)\n\t\treturn -ENODEV;\n\n\tif (!h2link->ofls)\n\t\treturn 0;\n\n\thlink = &h2link->hext_link;\n\n\tmutex_lock(&h2link->eml_lock);\n\n\thdaml_lctl_offload_enable(hlink->ml_addr + AZX_REG_ML_LCTL, enable);\n\n\tmutex_unlock(&h2link->eml_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(hdac_bus_eml_enable_offload, SND_SOC_SOF_HDA_MLINK);\n\n#endif\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}