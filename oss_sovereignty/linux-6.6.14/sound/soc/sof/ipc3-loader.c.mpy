{
  "module_name": "ipc3-loader.c",
  "hash_id": "d6b4d10d99939302981dd64d888f3e353fa4d9cb0c62197b080af6e0fa74e9c3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3-loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc3-priv.h\"\n#include \"ops.h\"\n\nstatic int ipc3_fw_ext_man_get_version(struct snd_sof_dev *sdev,\n\t\t\t\t       const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct sof_ext_man_fw_version *v =\n\t\tcontainer_of(hdr, struct sof_ext_man_fw_version, hdr);\n\n\tmemcpy(&sdev->fw_ready.version, &v->version, sizeof(v->version));\n\tsdev->fw_ready.flags = v->flags;\n\n\t \n\treturn sof_ipc3_validate_fw_version(sdev);\n}\n\nstatic int ipc3_fw_ext_man_get_windows(struct snd_sof_dev *sdev,\n\t\t\t\t       const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct sof_ext_man_window *w;\n\n\tw = container_of(hdr, struct sof_ext_man_window, hdr);\n\n\treturn sof_ipc3_get_ext_windows(sdev, &w->ipc_window.ext_hdr);\n}\n\nstatic int ipc3_fw_ext_man_get_cc_info(struct snd_sof_dev *sdev,\n\t\t\t\t       const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct sof_ext_man_cc_version *cc;\n\n\tcc = container_of(hdr, struct sof_ext_man_cc_version, hdr);\n\n\treturn sof_ipc3_get_cc_info(sdev, &cc->cc_version.ext_hdr);\n}\n\nstatic int ipc3_fw_ext_man_get_dbg_abi_info(struct snd_sof_dev *sdev,\n\t\t\t\t\t    const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct ext_man_dbg_abi *dbg_abi =\n\t\tcontainer_of(hdr, struct ext_man_dbg_abi, hdr);\n\n\tif (sdev->first_boot)\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"Firmware: DBG_ABI %d:%d:%d\\n\",\n\t\t\tSOF_ABI_VERSION_MAJOR(dbg_abi->dbg_abi.abi_dbg_version),\n\t\t\tSOF_ABI_VERSION_MINOR(dbg_abi->dbg_abi.abi_dbg_version),\n\t\t\tSOF_ABI_VERSION_PATCH(dbg_abi->dbg_abi.abi_dbg_version));\n\n\treturn 0;\n}\n\nstatic int ipc3_fw_ext_man_get_config_data(struct snd_sof_dev *sdev,\n\t\t\t\t\t   const struct sof_ext_man_elem_header *hdr)\n{\n\tconst struct sof_ext_man_config_data *config =\n\t\tcontainer_of(hdr, struct sof_ext_man_config_data, hdr);\n\tconst struct sof_config_elem *elem;\n\tint elems_counter;\n\tint elems_size;\n\tint ret = 0;\n\tint i;\n\n\t \n\telems_size = config->hdr.size - sizeof(struct sof_ext_man_elem_header);\n\telems_counter = elems_size / sizeof(struct sof_config_elem);\n\n\tdev_dbg(sdev->dev, \"manifest can hold up to %d config elements\\n\", elems_counter);\n\n\tfor (i = 0; i < elems_counter; ++i) {\n\t\telem = &config->elems[i];\n\t\tdev_dbg(sdev->dev, \"get index %d token %d val %d\\n\",\n\t\t\ti, elem->token, elem->value);\n\t\tswitch (elem->token) {\n\t\tcase SOF_EXT_MAN_CONFIG_EMPTY:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_CONFIG_IPC_MSG_SIZE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_CONFIG_MEMORY_USAGE_SCAN:\n\t\t\tif (sdev->first_boot && elem->value)\n\t\t\t\tret = snd_sof_dbg_memory_info_init(sdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Unknown firmware configuration token %d value %d\",\n\t\t\t\t elem->token, elem->value);\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"%s: processing failed for token %d value %#x, %d\\n\",\n\t\t\t\t__func__, elem->token, elem->value, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ipc3_fw_ext_man_size(struct snd_sof_dev *sdev, const struct firmware *fw)\n{\n\tconst struct sof_ext_man_header *head;\n\n\thead = (struct sof_ext_man_header *)fw->data;\n\n\t \n\tif (fw->size < sizeof(*head))\n\t\treturn -EINVAL;\n\n\t \n\tif (head->magic == SOF_EXT_MAN_MAGIC_NUMBER)\n\t\treturn head->full_size;\n\n\t \n\tdev_dbg(sdev->dev, \"Unexpected extended manifest magic number: %#x\\n\",\n\t\thead->magic);\n\treturn 0;\n}\n\nstatic size_t sof_ipc3_fw_parse_ext_man(struct snd_sof_dev *sdev)\n{\n\tconst struct firmware *fw = sdev->basefw.fw;\n\tconst struct sof_ext_man_elem_header *elem_hdr;\n\tconst struct sof_ext_man_header *head;\n\tssize_t ext_man_size;\n\tssize_t remaining;\n\tuintptr_t iptr;\n\tint ret = 0;\n\n\thead = (struct sof_ext_man_header *)fw->data;\n\tremaining = head->full_size - head->header_size;\n\text_man_size = ipc3_fw_ext_man_size(sdev, fw);\n\n\t \n\tif (ext_man_size <= 0)\n\t\treturn ext_man_size;\n\n\t \n\tif (SOF_EXT_MAN_VERSION_INCOMPATIBLE(SOF_EXT_MAN_VERSION,\n\t\t\t\t\t     head->header_version)) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"extended manifest version %#x differ from used %#x\\n\",\n\t\t\thead->header_version, SOF_EXT_MAN_VERSION);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tiptr = (uintptr_t)fw->data + head->header_size;\n\n\twhile (remaining > sizeof(*elem_hdr)) {\n\t\telem_hdr = (struct sof_ext_man_elem_header *)iptr;\n\n\t\tdev_dbg(sdev->dev, \"found sof_ext_man header type %d size %#x\\n\",\n\t\t\telem_hdr->type, elem_hdr->size);\n\n\t\tif (elem_hdr->size < sizeof(*elem_hdr) ||\n\t\t    elem_hdr->size > remaining) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"invalid sof_ext_man header size, type %d size %#x\\n\",\n\t\t\t\telem_hdr->type, elem_hdr->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tswitch (elem_hdr->type) {\n\t\tcase SOF_EXT_MAN_ELEM_FW_VERSION:\n\t\t\tret = ipc3_fw_ext_man_get_version(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_ELEM_WINDOW:\n\t\t\tret = ipc3_fw_ext_man_get_windows(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_ELEM_CC_VERSION:\n\t\t\tret = ipc3_fw_ext_man_get_cc_info(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_ELEM_DBG_ABI:\n\t\t\tret = ipc3_fw_ext_man_get_dbg_abi_info(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_ELEM_CONFIG_DATA:\n\t\t\tret = ipc3_fw_ext_man_get_config_data(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tcase SOF_EXT_MAN_ELEM_PLATFORM_CONFIG_DATA:\n\t\t\tret = snd_sof_dsp_parse_platform_ext_manifest(sdev, elem_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"unknown sof_ext_man header type %d size %#x\\n\",\n\t\t\t\t elem_hdr->type, elem_hdr->size);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"failed to parse sof_ext_man header type %d size %#x\\n\",\n\t\t\t\telem_hdr->type, elem_hdr->size);\n\t\t\treturn ret;\n\t\t}\n\n\t\tremaining -= elem_hdr->size;\n\t\tiptr += elem_hdr->size;\n\t}\n\n\tif (remaining) {\n\t\tdev_err(sdev->dev, \"error: sof_ext_man header is inconsistent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ext_man_size;\n}\n\n \nstatic int sof_ipc3_parse_module_memcpy(struct snd_sof_dev *sdev,\n\t\t\t\t\tstruct snd_sof_mod_hdr *module)\n{\n\tstruct snd_sof_blk_hdr *block;\n\tint count, ret;\n\tu32 offset;\n\tsize_t remaining;\n\n\tdev_dbg(sdev->dev, \"new module size %#x blocks %#x type %#x\\n\",\n\t\tmodule->size, module->num_blocks, module->type);\n\n\tblock = (struct snd_sof_blk_hdr *)((u8 *)module + sizeof(*module));\n\n\t \n\tremaining = module->size;\n\tfor (count = 0; count < module->num_blocks; count++) {\n\t\t \n\t\tif (remaining < sizeof(*block)) {\n\t\t\tdev_err(sdev->dev, \"not enough data remaining\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tremaining -= sizeof(*block);\n\n\t\tif (block->size == 0) {\n\t\t\tdev_warn(sdev->dev,\n\t\t\t\t \"warning: block %d size zero\\n\", count);\n\t\t\tdev_warn(sdev->dev, \" type %#x offset %#x\\n\",\n\t\t\t\t block->type, block->offset);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (block->type) {\n\t\tcase SOF_FW_BLK_TYPE_RSRVD0:\n\t\tcase SOF_FW_BLK_TYPE_ROM...SOF_FW_BLK_TYPE_RSRVD14:\n\t\t\tcontinue;\t \n\t\tcase SOF_FW_BLK_TYPE_IRAM:\n\t\tcase SOF_FW_BLK_TYPE_DRAM:\n\t\tcase SOF_FW_BLK_TYPE_SRAM:\n\t\t\toffset = block->offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sdev->dev, \"%s: bad type %#x for block %#x\\n\",\n\t\t\t\t__func__, block->type, count);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(sdev->dev, \"block %d type %#x size %#x ==>  offset %#x\\n\",\n\t\t\tcount, block->type, block->size, offset);\n\n\t\t \n\t\tif (block->size % sizeof(u32)) {\n\t\t\tdev_err(sdev->dev, \"%s: invalid block size %#x\\n\",\n\t\t\t\t__func__, block->size);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = snd_sof_dsp_block_write(sdev, block->type, offset,\n\t\t\t\t\t      block + 1, block->size);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: write to block type %#x failed\\n\",\n\t\t\t\t__func__, block->type);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (remaining < block->size) {\n\t\t\tdev_err(sdev->dev, \"%s: not enough data remaining\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tremaining -= block->size;\n\t\t \n\t\tblock = (struct snd_sof_blk_hdr *)((u8 *)block + sizeof(*block)\n\t\t\t+ block->size);\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_load_fw_to_dsp(struct snd_sof_dev *sdev)\n{\n\tu32 payload_offset = sdev->basefw.payload_offset;\n\tconst struct firmware *fw = sdev->basefw.fw;\n\tstruct snd_sof_fw_header *header;\n\tstruct snd_sof_mod_hdr *module;\n\tint (*load_module)(struct snd_sof_dev *sof_dev, struct snd_sof_mod_hdr *hdr);\n\tsize_t remaining;\n\tint ret, count;\n\n\tif (!fw)\n\t\treturn -EINVAL;\n\n\theader = (struct snd_sof_fw_header *)(fw->data + payload_offset);\n\tload_module = sof_ops(sdev)->load_module;\n\tif (!load_module) {\n\t\tdev_dbg(sdev->dev, \"Using generic module loading\\n\");\n\t\tload_module = sof_ipc3_parse_module_memcpy;\n\t} else {\n\t\tdev_dbg(sdev->dev, \"Using custom module loading\\n\");\n\t}\n\n\t \n\tmodule = (struct snd_sof_mod_hdr *)(fw->data + payload_offset + sizeof(*header));\n\tremaining = fw->size - sizeof(*header) - payload_offset;\n\t \n\tif (remaining > fw->size) {\n\t\tdev_err(sdev->dev, \"%s: fw size smaller than header size\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (count = 0; count < header->num_modules; count++) {\n\t\t \n\t\tif (remaining < sizeof(*module)) {\n\t\t\tdev_err(sdev->dev, \"%s: not enough data for a module\\n\",\n\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tremaining -= sizeof(*module);\n\n\t\t \n\t\tret = load_module(sdev, module);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: invalid module %d\\n\", __func__, count);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (remaining < module->size) {\n\t\t\tdev_err(sdev->dev, \"%s: not enough data remaining\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tremaining -=  module->size;\n\t\tmodule = (struct snd_sof_mod_hdr *)((u8 *)module +\n\t\t\t sizeof(*module) + module->size);\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc3_validate_firmware(struct snd_sof_dev *sdev)\n{\n\tu32 payload_offset = sdev->basefw.payload_offset;\n\tconst struct firmware *fw = sdev->basefw.fw;\n\tstruct snd_sof_fw_header *header;\n\tsize_t fw_size = fw->size - payload_offset;\n\n\tif (fw->size <= payload_offset) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"firmware size must be greater than firmware offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\theader = (struct snd_sof_fw_header *)(fw->data + payload_offset);\n\n\t \n\tif (strncmp(header->sig, SND_SOF_FW_SIG, SND_SOF_FW_SIG_SIZE) != 0) {\n\t\tdev_err(sdev->dev, \"invalid firmware signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fw_size != header->file_size + sizeof(*header)) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"invalid filesize mismatch got 0x%zx expected 0x%zx\\n\",\n\t\t\tfw_size, header->file_size + sizeof(*header));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(sdev->dev, \"header size=0x%x modules=0x%x abi=0x%x size=%zu\\n\",\n\t\theader->file_size, header->num_modules,\n\t\theader->abi, sizeof(*header));\n\n\treturn 0;\n}\n\nconst struct sof_ipc_fw_loader_ops ipc3_loader_ops = {\n\t.validate = sof_ipc3_validate_firmware,\n\t.parse_ext_manifest = sof_ipc3_fw_parse_ext_man,\n\t.load_fw_to_dsp = sof_ipc3_load_fw_to_dsp,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}