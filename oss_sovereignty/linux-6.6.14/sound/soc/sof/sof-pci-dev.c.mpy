{
  "module_name": "sof-pci-dev.c",
  "hash_id": "e587331685b175357df6a05425bc852e16267452ac9c3c82819d25b1a49c3597",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-pci-dev.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_data/x86/soc.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc-acpi.h>\n#include <sound/soc-acpi-intel-match.h>\n#include <sound/sof.h>\n#include \"ops.h\"\n#include \"sof-pci-dev.h\"\n\nstatic char *fw_path;\nmodule_param(fw_path, charp, 0444);\nMODULE_PARM_DESC(fw_path, \"alternate path for SOF firmware.\");\n\nstatic char *fw_filename;\nmodule_param(fw_filename, charp, 0444);\nMODULE_PARM_DESC(fw_filename, \"alternate filename for SOF firmware.\");\n\nstatic char *lib_path;\nmodule_param(lib_path, charp, 0444);\nMODULE_PARM_DESC(lib_path, \"alternate path for SOF firmware libraries.\");\n\nstatic char *tplg_path;\nmodule_param(tplg_path, charp, 0444);\nMODULE_PARM_DESC(tplg_path, \"alternate path for SOF topology.\");\n\nstatic char *tplg_filename;\nmodule_param(tplg_filename, charp, 0444);\nMODULE_PARM_DESC(tplg_filename, \"alternate filename for SOF topology.\");\n\nstatic int sof_pci_debug;\nmodule_param_named(sof_pci_debug, sof_pci_debug, int, 0444);\nMODULE_PARM_DESC(sof_pci_debug, \"SOF PCI debug options (0x0 all off)\");\n\nstatic int sof_pci_ipc_type = -1;\nmodule_param_named(ipc_type, sof_pci_ipc_type, int, 0444);\nMODULE_PARM_DESC(ipc_type, \"SOF IPC type (0): SOF, (1) Intel CAVS\");\n\nstatic const char *sof_dmi_override_tplg_name;\nstatic bool sof_dmi_use_community_key;\n\n#define SOF_PCI_DISABLE_PM_RUNTIME BIT(0)\n\nstatic int sof_tplg_cb(const struct dmi_system_id *id)\n{\n\tsof_dmi_override_tplg_name = id->driver_data;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id sof_tplg_table[] = {\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google_Volteer\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO-MAX98373_ALC5682I_I2S_UP4\"),\n\t\t},\n\t\t.driver_data = \"sof-tgl-rt5682-ssp0-max98373-ssp2.tplg\",\n\t},\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Alder Lake Client Platform\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO-ADL_MAX98373_ALC5682I_I2S\"),\n\t\t},\n\t\t.driver_data = \"sof-adl-rt5682-ssp0-max98373-ssp2.tplg\",\n\t},\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google_Brya\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO-MAX98390_ALC5682I_I2S\"),\n\t\t},\n\t\t.driver_data = \"sof-adl-max98390-ssp2-rt5682-ssp0.tplg\",\n\t},\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google_Brya\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO_AMP-MAX98360_ALC5682VS_I2S_2WAY\"),\n\t\t},\n\t\t.driver_data = \"sof-adl-max98360a-rt5682-2way.tplg\",\n\t},\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google_Brya\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO-AUDIO_MAX98357_ALC5682I_I2S_2WAY\"),\n\t\t},\n\t\t.driver_data = \"sof-adl-max98357a-rt5682-2way.tplg\",\n\t},\n\t{\n\t\t.callback = sof_tplg_cb,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google_Brya\"),\n\t\t\tDMI_MATCH(DMI_OEM_STRING, \"AUDIO-MAX98360_ALC5682I_I2S_AMP_SSP2\"),\n\t\t},\n\t\t.driver_data = \"sof-adl-max98357a-rt5682.tplg\",\n\t},\n\t{}\n};\n\n \nstatic int up_use_community_key(const struct dmi_system_id *id)\n{\n\tsof_dmi_use_community_key = true;\n\treturn 1;\n}\n\n \nstatic int chromebook_use_community_key(const struct dmi_system_id *id)\n{\n\tif (!soc_intel_is_apl())\n\t\tsof_dmi_use_community_key = true;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id community_key_platforms[] = {\n\t{\n\t\t.ident = \"Up boards\",\n\t\t.callback = up_use_community_key,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"AAEON\"),\n\t\t}\n\t},\n\t{\n\t\t.ident = \"Google Chromebooks\",\n\t\t.callback = chromebook_use_community_key,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Google\"),\n\t\t}\n\t},\n\t{\n\t\t.ident = \"Google firmware\",\n\t\t.callback = chromebook_use_community_key,\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Google\"),\n\t\t}\n\t},\n\t{},\n};\n\nconst struct dev_pm_ops sof_pci_pm = {\n\t.prepare = snd_sof_prepare,\n\t.complete = snd_sof_complete,\n\tSET_SYSTEM_SLEEP_PM_OPS(snd_sof_suspend, snd_sof_resume)\n\tSET_RUNTIME_PM_OPS(snd_sof_runtime_suspend, snd_sof_runtime_resume,\n\t\t\t   snd_sof_runtime_idle)\n};\nEXPORT_SYMBOL_NS(sof_pci_pm, SND_SOC_SOF_PCI_DEV);\n\nstatic void sof_pci_probe_complete(struct device *dev)\n{\n\tdev_dbg(dev, \"Completing SOF PCI probe\");\n\n\tif (sof_pci_debug & SOF_PCI_DISABLE_PM_RUNTIME)\n\t\treturn;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SND_SOF_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_allow(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\t \n\tpm_runtime_put_noidle(dev);\n}\n\nint sof_pci_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\n{\n\tstruct device *dev = &pci->dev;\n\tconst struct sof_dev_desc *desc =\n\t\t(const struct sof_dev_desc *)pci_id->driver_data;\n\tstruct snd_sof_pdata *sof_pdata;\n\tint ret;\n\n\tdev_dbg(&pci->dev, \"PCI DSP detected\");\n\n\tif (!desc) {\n\t\tdev_err(dev, \"error: no matching PCI descriptor\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!desc->ops) {\n\t\tdev_err(dev, \"error: no matching PCI descriptor ops\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tsof_pdata = devm_kzalloc(dev, sizeof(*sof_pdata), GFP_KERNEL);\n\tif (!sof_pdata)\n\t\treturn -ENOMEM;\n\n\tret = pcim_enable_device(pci);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pci_request_regions(pci, \"Audio DSP\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsof_pdata->name = pci_name(pci);\n\n\t \n\tif (pci->subsystem_vendor != 0xFFFF) {\n\t\tsof_pdata->subsystem_vendor = pci->subsystem_vendor;\n\t\tsof_pdata->subsystem_device = pci->subsystem_device;\n\t\tsof_pdata->subsystem_id_set = true;\n\t}\n\n\tsof_pdata->desc = desc;\n\tsof_pdata->dev = dev;\n\n\tsof_pdata->ipc_type = desc->ipc_default;\n\n\tif (sof_pci_ipc_type < 0) {\n\t\tsof_pdata->ipc_type = desc->ipc_default;\n\t} else {\n\t\tdev_info(dev, \"overriding default IPC %d to requested %d\\n\",\n\t\t\t desc->ipc_default, sof_pci_ipc_type);\n\t\tif (sof_pci_ipc_type >= SOF_IPC_TYPE_COUNT) {\n\t\t\tdev_err(dev, \"invalid request value %d\\n\", sof_pci_ipc_type);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(BIT(sof_pci_ipc_type) & desc->ipc_supported_mask)) {\n\t\t\tdev_err(dev, \"invalid request value %d, supported mask is %#x\\n\",\n\t\t\t\tsof_pci_ipc_type, desc->ipc_supported_mask);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tsof_pdata->ipc_type = sof_pci_ipc_type;\n\t}\n\n\tif (fw_filename) {\n\t\tsof_pdata->fw_filename = fw_filename;\n\n\t\tdev_dbg(dev, \"Module parameter used, changed fw filename to %s\\n\",\n\t\t\tsof_pdata->fw_filename);\n\t} else {\n\t\tsof_pdata->fw_filename = desc->default_fw_filename[sof_pdata->ipc_type];\n\t}\n\n\t \n\n\t \n\tif (fw_path) {\n\t\tsof_pdata->fw_filename_prefix = fw_path;\n\n\t\tdev_dbg(dev,\n\t\t\t\"Module parameter used, changed fw path to %s\\n\",\n\t\t\tsof_pdata->fw_filename_prefix);\n\n\t} else if (dmi_check_system(community_key_platforms) && sof_dmi_use_community_key) {\n\t\tsof_pdata->fw_filename_prefix =\n\t\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%s/%s\",\n\t\t\t\t       sof_pdata->desc->default_fw_path[sof_pdata->ipc_type],\n\t\t\t\t       \"community\");\n\n\t\tdev_dbg(dev,\n\t\t\t\"Platform uses community key, changed fw path to %s\\n\",\n\t\t\tsof_pdata->fw_filename_prefix);\n\t} else {\n\t\tsof_pdata->fw_filename_prefix =\n\t\t\tsof_pdata->desc->default_fw_path[sof_pdata->ipc_type];\n\t}\n\n\tif (lib_path) {\n\t\tsof_pdata->fw_lib_prefix = lib_path;\n\n\t\tdev_dbg(dev, \"Module parameter used, changed fw_lib path to %s\\n\",\n\t\t\tsof_pdata->fw_lib_prefix);\n\n\t} else if (sof_pdata->desc->default_lib_path[sof_pdata->ipc_type]) {\n\t\tif (dmi_check_system(community_key_platforms) && sof_dmi_use_community_key) {\n\t\t\tsof_pdata->fw_lib_prefix =\n\t\t\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%s/%s\",\n\t\t\t\t\tsof_pdata->desc->default_lib_path[sof_pdata->ipc_type],\n\t\t\t\t\t\"community\");\n\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"Platform uses community key, changed fw_lib path to %s\\n\",\n\t\t\t\tsof_pdata->fw_lib_prefix);\n\t\t} else {\n\t\t\tsof_pdata->fw_lib_prefix =\n\t\t\t\tsof_pdata->desc->default_lib_path[sof_pdata->ipc_type];\n\t\t}\n\t}\n\n\tif (tplg_path)\n\t\tsof_pdata->tplg_filename_prefix = tplg_path;\n\telse\n\t\tsof_pdata->tplg_filename_prefix =\n\t\t\tsof_pdata->desc->default_tplg_path[sof_pdata->ipc_type];\n\n\t \n\tif (tplg_filename) {\n\t\tsof_pdata->tplg_filename = tplg_filename;\n\n\t\tdev_dbg(dev, \"Module parameter used, changed tplg filename to %s\\n\",\n\t\t\tsof_pdata->tplg_filename);\n\t} else {\n\t\tdmi_check_system(sof_tplg_table);\n\t\tif (sof_dmi_override_tplg_name)\n\t\t\tsof_pdata->tplg_filename = sof_dmi_override_tplg_name;\n\t}\n\n\t \n\tsof_pdata->sof_probe_complete = sof_pci_probe_complete;\n\n\t \n\tret = snd_sof_device_probe(dev, sof_pdata);\n\nout:\n\tif (ret)\n\t\tpci_release_regions(pci);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(sof_pci_probe, SND_SOC_SOF_PCI_DEV);\n\nvoid sof_pci_remove(struct pci_dev *pci)\n{\n\t \n\tsnd_sof_device_remove(&pci->dev);\n\n\t \n\tif (snd_sof_device_probe_completed(&pci->dev) &&\n\t    !(sof_pci_debug & SOF_PCI_DISABLE_PM_RUNTIME))\n\t\tpm_runtime_get_noresume(&pci->dev);\n\n\t \n\tpci_release_regions(pci);\n}\nEXPORT_SYMBOL_NS(sof_pci_remove, SND_SOC_SOF_PCI_DEV);\n\nvoid sof_pci_shutdown(struct pci_dev *pci)\n{\n\tsnd_sof_device_shutdown(&pci->dev);\n}\nEXPORT_SYMBOL_NS(sof_pci_shutdown, SND_SOC_SOF_PCI_DEV);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}