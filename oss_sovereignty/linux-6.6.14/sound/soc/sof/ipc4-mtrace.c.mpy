{
  "module_name": "ipc4-mtrace.c",
  "hash_id": "4caab9931fb80c8ac978e19c81b0c2b13361e6fc6380368734d1a1ccdad4d60f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc4-mtrace.c",
  "human_readable_source": "\n\n\n\n#include <linux/debugfs.h>\n#include <linux/sched/signal.h>\n#include <sound/sof/ipc4/header.h>\n#include \"sof-priv.h\"\n#include \"ipc4-priv.h\"\n\n \n\n#define SOF_MTRACE_DESCRIPTOR_SIZE\t\t12  \n\n#define FW_EPOCH_DELTA\t\t\t\t11644473600LL\n\n#define INVALID_SLOT_OFFSET\t\t\t0xffffffff\n#define MAX_ALLOWED_LIBRARIES\t\t\t16\n#define MAX_MTRACE_SLOTS\t\t\t15\n\n#define SOF_MTRACE_PAGE_SIZE\t\t\t0x1000\n#define SOF_MTRACE_SLOT_SIZE\t\t\tSOF_MTRACE_PAGE_SIZE\n\n \n#define SOF_MTRACE_SLOT_UNUSED\t\t\t0x00000000\n#define SOF_MTRACE_SLOT_CRITICAL_LOG\t\t0x54524300  \n#define SOF_MTRACE_SLOT_DEBUG_LOG\t\t0x474f4c00  \n#define SOF_MTRACE_SLOT_GDB_STUB\t\t0x42444700\n#define SOF_MTRACE_SLOT_TELEMETRY\t\t0x4c455400\n#define SOF_MTRACE_SLOT_BROKEN\t\t\t0x44414544\n  \n#define SOF_MTRACE_SLOT_CORE_MASK\t\tGENMASK(7, 0)\n#define SOF_MTRACE_SLOT_TYPE_MASK\t\tGENMASK(31, 8)\n\n#define DEFAULT_AGING_TIMER_PERIOD_MS\t\t0x100\n#define DEFAULT_FIFO_FULL_TIMER_PERIOD_MS\t0x1000\n\n \n#define SOF_MTRACE_LOG_LEVEL_CRITICAL\t\tBIT(0)\n#define SOF_MTRACE_LOG_LEVEL_ERROR\t\tBIT(1)\n#define SOF_MTRACE_LOG_LEVEL_WARNING\t\tBIT(2)\n#define SOF_MTRACE_LOG_LEVEL_INFO\t\tBIT(3)\n#define SOF_MTRACE_LOG_LEVEL_VERBOSE\t\tBIT(4)\n#define SOF_MTRACE_LOG_SOURCE_INFRA\t\tBIT(5)  \n#define SOF_MTRACE_LOG_SOURCE_HAL\t\tBIT(6)\n#define SOF_MTRACE_LOG_SOURCE_MODULE\t\tBIT(7)\n#define SOF_MTRACE_LOG_SOURCE_AUDIO\t\tBIT(8)\n#define SOF_MTRACE_LOG_SOURCE_SCHEDULER\t\tBIT(9)\n#define SOF_MTRACE_LOG_SOURCE_ULP_INFRA\t\tBIT(10)\n#define SOF_MTRACE_LOG_SOURCE_ULP_MODULE\tBIT(11)\n#define SOF_MTRACE_LOG_SOURCE_VISION\t\tBIT(12)  \n#define DEFAULT_LOGS_PRIORITIES_MASK\t(SOF_MTRACE_LOG_LEVEL_CRITICAL | \\\n\t\t\t\t\t SOF_MTRACE_LOG_LEVEL_ERROR |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_LEVEL_WARNING |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_LEVEL_INFO |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_SOURCE_INFRA |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_SOURCE_HAL |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_SOURCE_MODULE |\t \\\n\t\t\t\t\t SOF_MTRACE_LOG_SOURCE_AUDIO)\n\nstruct sof_log_state_info {\n\tu32 aging_timer_period;\n\tu32 fifo_full_timer_period;\n\tu32 enable;\n\tu32 logs_priorities_mask[MAX_ALLOWED_LIBRARIES];\n} __packed;\n\nenum sof_mtrace_state {\n\tSOF_MTRACE_DISABLED,\n\tSOF_MTRACE_INITIALIZING,\n\tSOF_MTRACE_ENABLED,\n};\n\nstruct sof_mtrace_core_data {\n\tstruct snd_sof_dev *sdev;\n\n\tint id;\n\tu32 slot_offset;\n\tvoid *log_buffer;\n\tstruct mutex buffer_lock;  \n\tu32 host_read_ptr;\n\tu32 dsp_write_ptr;\n\t \n\tbool delayed_pos_update;\n\twait_queue_head_t trace_sleep;\n};\n\nstruct sof_mtrace_priv {\n\tstruct snd_sof_dev *sdev;\n\tenum sof_mtrace_state mtrace_state;\n\tstruct sof_log_state_info state_info;\n\n\tstruct sof_mtrace_core_data cores[];\n};\n\nstatic int sof_ipc4_mtrace_dfs_open(struct inode *inode, struct file *file)\n{\n\tstruct sof_mtrace_core_data *core_data = inode->i_private;\n\tint ret;\n\n\tmutex_lock(&core_data->buffer_lock);\n\n\tif (core_data->log_buffer) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = debugfs_file_get(file->f_path.dentry);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tcore_data->log_buffer = kmalloc(SOF_MTRACE_SLOT_SIZE, GFP_KERNEL);\n\tif (!core_data->log_buffer) {\n\t\tdebugfs_file_put(file->f_path.dentry);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = simple_open(inode, file);\n\tif (ret) {\n\t\tkfree(core_data->log_buffer);\n\t\tdebugfs_file_put(file->f_path.dentry);\n\t}\n\nout:\n\tmutex_unlock(&core_data->buffer_lock);\n\n\treturn ret;\n}\n\nstatic bool sof_wait_mtrace_avail(struct sof_mtrace_core_data *core_data)\n{\n\twait_queue_entry_t wait;\n\n\t \n\tif (core_data->host_read_ptr != core_data->dsp_write_ptr)\n\t\treturn true;\n\n\t \n\tinit_waitqueue_entry(&wait, current);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tadd_wait_queue(&core_data->trace_sleep, &wait);\n\n\tif (!signal_pending(current)) {\n\t\t \n\t\tschedule_timeout(MAX_SCHEDULE_TIMEOUT);\n\t}\n\tremove_wait_queue(&core_data->trace_sleep, &wait);\n\n\tif (core_data->host_read_ptr != core_data->dsp_write_ptr)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic ssize_t sof_ipc4_mtrace_dfs_read(struct file *file, char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sof_mtrace_core_data *core_data = file->private_data;\n\tu32 log_buffer_offset, log_buffer_size, read_ptr, write_ptr;\n\tstruct snd_sof_dev *sdev = core_data->sdev;\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tvoid *log_buffer = core_data->log_buffer;\n\tloff_t lpos = *ppos;\n\tu32 avail;\n\tint ret;\n\n\t \n\tif (lpos < 0)\n\t\treturn -EINVAL;\n\tif (!count || count < sizeof(avail))\n\t\treturn 0;\n\n\t \n\tif (!sof_wait_mtrace_avail(core_data)) {\n\t\t \n\t\tavail = 0;\n\t\tif (copy_to_user(buffer, &avail, sizeof(avail)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tif (core_data->slot_offset == INVALID_SLOT_OFFSET)\n\t\treturn 0;\n\n\t \n\tlog_buffer_offset =  core_data->slot_offset + (sizeof(u32) * 2);\n\t \n\tlog_buffer_size = SOF_MTRACE_SLOT_SIZE - (sizeof(u32) * 2);\n\n\tread_ptr = core_data->host_read_ptr;\n\twrite_ptr = core_data->dsp_write_ptr;\n\n\tif (read_ptr < write_ptr)\n\t\tavail = write_ptr - read_ptr;\n\telse\n\t\tavail = log_buffer_size - read_ptr + write_ptr;\n\n\tif (!avail)\n\t\treturn 0;\n\n\tif (avail > log_buffer_size)\n\t\tavail = log_buffer_size;\n\n\t \n\tif (avail > count - sizeof(avail))\n\t\tavail = count - sizeof(avail);\n\n\tif (sof_debug_check_flag(SOF_DBG_PRINT_DMA_POSITION_UPDATE_LOGS))\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"core%d, host read: %#x, dsp write: %#x, avail: %#x\\n\",\n\t\t\tcore_data->id, read_ptr, write_ptr, avail);\n\n\tif (read_ptr < write_ptr) {\n\t\t \n\t\tsof_mailbox_read(sdev, log_buffer_offset + read_ptr, log_buffer, avail);\n\t} else {\n\t\t \n\t\tsof_mailbox_read(sdev, log_buffer_offset + read_ptr, log_buffer,\n\t\t\t\t avail - write_ptr);\n\t\t \n\t\tif (write_ptr)\n\t\t\tsof_mailbox_read(sdev, log_buffer_offset,\n\t\t\t\t\t (u8 *)(log_buffer) + avail - write_ptr,\n\t\t\t\t\t write_ptr);\n\t}\n\n\t \n\tret = copy_to_user(buffer, &avail, sizeof(avail));\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t \n\tret = copy_to_user(buffer + sizeof(avail), log_buffer, avail);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t \n\tread_ptr += avail;\n\tif (read_ptr >= log_buffer_size)\n\t\tread_ptr -= log_buffer_size;\n\tsof_mailbox_write(sdev, core_data->slot_offset, &read_ptr, sizeof(read_ptr));\n\n\t \n\tif (priv->mtrace_state != SOF_MTRACE_DISABLED)\n\t\tcore_data->host_read_ptr = read_ptr;\n\n\t \n\t*ppos += count;\n\n\treturn count;\n}\n\nstatic int sof_ipc4_mtrace_dfs_release(struct inode *inode, struct file *file)\n{\n\tstruct sof_mtrace_core_data *core_data = inode->i_private;\n\n\tdebugfs_file_put(file->f_path.dentry);\n\n\tmutex_lock(&core_data->buffer_lock);\n\tkfree(core_data->log_buffer);\n\tcore_data->log_buffer = NULL;\n\tmutex_unlock(&core_data->buffer_lock);\n\n\treturn 0;\n}\n\nstatic const struct file_operations sof_dfs_mtrace_fops = {\n\t.open = sof_ipc4_mtrace_dfs_open,\n\t.read = sof_ipc4_mtrace_dfs_read,\n\t.llseek = default_llseek,\n\t.release = sof_ipc4_mtrace_dfs_release,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t sof_ipc4_priority_mask_dfs_read(struct file *file, char __user *to,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct sof_mtrace_priv *priv = file->private_data;\n\tint i, ret, offset, remaining;\n\tchar *buf;\n\n\t \n\tbuf = kzalloc(241, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < MAX_ALLOWED_LIBRARIES; i++) {\n\t\toffset = strlen(buf);\n\t\tremaining = 241 - offset;\n\t\tsnprintf(buf + offset, remaining, \"%2d: 0x%08x\\n\", i,\n\t\t\t priv->state_info.logs_priorities_mask[i]);\n\t}\n\n\tret = simple_read_from_buffer(to, count, ppos, buf, strlen(buf));\n\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t sof_ipc4_priority_mask_dfs_write(struct file *file,\n\t\t\t\t\t\tconst char __user *from,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sof_mtrace_priv *priv = file->private_data;\n\tunsigned int id;\n\tchar *buf;\n\tu32 mask;\n\tint ret;\n\n\t \n\tbuf = memdup_user_nul(from, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = sscanf(buf, \"%u,0x%x\", &id, &mask);\n\tif (ret != 2) {\n\t\tret = sscanf(buf, \"%u,%x\", &id, &mask);\n\t\tif (ret != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (id >= MAX_ALLOWED_LIBRARIES) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->state_info.logs_priorities_mask[id] = mask;\n\tret = count;\n\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations sof_dfs_priority_mask_fops = {\n\t.open = simple_open,\n\t.read = sof_ipc4_priority_mask_dfs_read,\n\t.write = sof_ipc4_priority_mask_dfs_write,\n\t.llseek = default_llseek,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic int mtrace_debugfs_create(struct snd_sof_dev *sdev)\n{\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tstruct dentry *dfs_root;\n\tchar dfs_name[100];\n\tint i;\n\n\tdfs_root = debugfs_create_dir(\"mtrace\", sdev->debugfs_root);\n\tif (IS_ERR_OR_NULL(dfs_root))\n\t\treturn 0;\n\n\t \n\tdebugfs_create_u32(\"aging_timer_period\", 0644, dfs_root,\n\t\t\t   &priv->state_info.aging_timer_period);\n\tdebugfs_create_u32(\"fifo_full_timer_period\", 0644, dfs_root,\n\t\t\t   &priv->state_info.fifo_full_timer_period);\n\tdebugfs_create_file(\"logs_priorities_mask\", 0644, dfs_root, priv,\n\t\t\t    &sof_dfs_priority_mask_fops);\n\n\t \n\tfor (i = 0; i < sdev->num_cores; i++) {\n\t\tsnprintf(dfs_name, sizeof(dfs_name), \"core%d\", i);\n\t\tdebugfs_create_file(dfs_name, 0444, dfs_root, &priv->cores[i],\n\t\t\t\t    &sof_dfs_mtrace_fops);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipc4_mtrace_enable(struct snd_sof_dev *sdev)\n{\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tstruct sof_ipc4_msg msg;\n\tu64 system_time;\n\tktime_t kt;\n\tint ret;\n\n\tif (priv->mtrace_state != SOF_MTRACE_DISABLED)\n\t\treturn 0;\n\n\tmsg.primary = SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MOD_ID(SOF_IPC4_MOD_INIT_BASEFW_MOD_ID);\n\tmsg.primary |= SOF_IPC4_MOD_INSTANCE(SOF_IPC4_MOD_INIT_BASEFW_INSTANCE_ID);\n\tmsg.extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_FW_PARAM_SYSTEM_TIME);\n\n\t \n\tkt = ktime_add_us(ktime_get_real(), FW_EPOCH_DELTA * USEC_PER_SEC);\n\tsystem_time = ktime_to_us(kt);\n\tmsg.data_size = sizeof(system_time);\n\tmsg.data_ptr = &system_time;\n\tret = iops->set_get_data(sdev, &msg, msg.data_size, true);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg.extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_FW_PARAM_ENABLE_LOGS);\n\n\tpriv->state_info.enable = 1;\n\n\tmsg.data_size = sizeof(priv->state_info);\n\tmsg.data_ptr = &priv->state_info;\n\n\tpriv->mtrace_state = SOF_MTRACE_INITIALIZING;\n\tret = iops->set_get_data(sdev, &msg, msg.data_size, true);\n\tif (ret) {\n\t\tpriv->mtrace_state = SOF_MTRACE_DISABLED;\n\t\treturn ret;\n\t}\n\n\tpriv->mtrace_state = SOF_MTRACE_ENABLED;\n\n\treturn 0;\n}\n\nstatic void ipc4_mtrace_disable(struct snd_sof_dev *sdev)\n{\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tstruct sof_ipc4_msg msg;\n\tint i;\n\n\tif (priv->mtrace_state == SOF_MTRACE_DISABLED)\n\t\treturn;\n\n\tmsg.primary = SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MOD_ID(SOF_IPC4_MOD_INIT_BASEFW_MOD_ID);\n\tmsg.primary |= SOF_IPC4_MOD_INSTANCE(SOF_IPC4_MOD_INIT_BASEFW_INSTANCE_ID);\n\tmsg.extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_FW_PARAM_ENABLE_LOGS);\n\n\tpriv->state_info.enable = 0;\n\n\tmsg.data_size = sizeof(priv->state_info);\n\tmsg.data_ptr = &priv->state_info;\n\tiops->set_get_data(sdev, &msg, msg.data_size, true);\n\n\tpriv->mtrace_state = SOF_MTRACE_DISABLED;\n\n\tfor (i = 0; i < sdev->num_cores; i++) {\n\t\tstruct sof_mtrace_core_data *core_data = &priv->cores[i];\n\n\t\tcore_data->host_read_ptr = 0;\n\t\tcore_data->dsp_write_ptr = 0;\n\t\twake_up(&core_data->trace_sleep);\n\t}\n}\n\n \nstatic void sof_mtrace_find_core_slots(struct snd_sof_dev *sdev)\n{\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tstruct sof_mtrace_core_data *core_data;\n\tu32 slot_desc_type_offset, type, core;\n\tint i;\n\n\tfor (i = 0; i < MAX_MTRACE_SLOTS; i++) {\n\t\t \n\t\tslot_desc_type_offset = sdev->debug_box.offset;\n\t\tslot_desc_type_offset += SOF_MTRACE_DESCRIPTOR_SIZE * i + sizeof(u32);\n\t\tsof_mailbox_read(sdev, slot_desc_type_offset, &type, sizeof(type));\n\n\t\tif ((type & SOF_MTRACE_SLOT_TYPE_MASK) == SOF_MTRACE_SLOT_DEBUG_LOG) {\n\t\t\tcore = type & SOF_MTRACE_SLOT_CORE_MASK;\n\n\t\t\tif (core >= sdev->num_cores) {\n\t\t\t\tdev_dbg(sdev->dev, \"core%u is invalid for slot%d\\n\",\n\t\t\t\t\tcore, i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcore_data = &priv->cores[core];\n\t\t\t \n\t\t\tcore_data->slot_offset = sdev->debug_box.offset;\n\t\t\tcore_data->slot_offset += SOF_MTRACE_SLOT_SIZE * (i + 1);\n\t\t\tdev_dbg(sdev->dev, \"slot%d is used for core%u\\n\", i, core);\n\t\t\tif (core_data->delayed_pos_update) {\n\t\t\t\tsof_ipc4_mtrace_update_pos(sdev, core);\n\t\t\t\tcore_data->delayed_pos_update = false;\n\t\t\t}\n\t\t} else if (type) {\n\t\t\tdev_dbg(sdev->dev, \"slot%d is not a log slot (%#x)\\n\", i, type);\n\t\t}\n\t}\n}\n\nstatic int ipc4_mtrace_init(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_mtrace_priv *priv;\n\tint i, ret;\n\n\tif (sdev->fw_trace_data) {\n\t\tdev_err(sdev->dev, \"fw_trace_data has been already allocated\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (!ipc4_data->mtrace_log_bytes ||\n\t    ipc4_data->mtrace_type != SOF_IPC4_MTRACE_INTEL_CAVS_2) {\n\t\tsdev->fw_trace_is_supported = false;\n\t\treturn 0;\n\t}\n\n\tpriv = devm_kzalloc(sdev->dev, struct_size(priv, cores, sdev->num_cores),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tsdev->fw_trace_data = priv;\n\n\t \n\tpriv->state_info.aging_timer_period = DEFAULT_AGING_TIMER_PERIOD_MS;\n\tpriv->state_info.fifo_full_timer_period = DEFAULT_FIFO_FULL_TIMER_PERIOD_MS;\n\t \n\tpriv->state_info.logs_priorities_mask[0] = DEFAULT_LOGS_PRIORITIES_MASK;\n\n\tfor (i = 0; i < sdev->num_cores; i++) {\n\t\tstruct sof_mtrace_core_data *core_data = &priv->cores[i];\n\n\t\tinit_waitqueue_head(&core_data->trace_sleep);\n\t\tmutex_init(&core_data->buffer_lock);\n\t\tcore_data->sdev = sdev;\n\t\tcore_data->id = i;\n\t}\n\n\tret = ipc4_mtrace_enable(sdev);\n\tif (ret) {\n\t\t \n\t\tsdev->fw_trace_is_supported = false;\n\t\tdev_dbg(sdev->dev, \"initialization failed, fw tracing is disabled\\n\");\n\t\treturn 0;\n\t}\n\n\tsof_mtrace_find_core_slots(sdev);\n\n\tret = mtrace_debugfs_create(sdev);\n\tif (ret)\n\t\tipc4_mtrace_disable(sdev);\n\n\treturn ret;\n}\n\nstatic void ipc4_mtrace_free(struct snd_sof_dev *sdev)\n{\n\tipc4_mtrace_disable(sdev);\n}\n\nstatic int sof_ipc4_mtrace_update_pos_all_cores(struct snd_sof_dev *sdev)\n{\n\tint i;\n\n\tfor (i = 0; i < sdev->num_cores; i++)\n\t\tsof_ipc4_mtrace_update_pos(sdev, i);\n\n\treturn 0;\n}\n\nint sof_ipc4_mtrace_update_pos(struct snd_sof_dev *sdev, int core)\n{\n\tstruct sof_mtrace_priv *priv = sdev->fw_trace_data;\n\tstruct sof_mtrace_core_data *core_data;\n\n\tif (!sdev->fw_trace_is_supported ||\n\t    priv->mtrace_state == SOF_MTRACE_DISABLED)\n\t\treturn 0;\n\n\tif (core >= sdev->num_cores)\n\t\treturn -EINVAL;\n\n\tcore_data = &priv->cores[core];\n\n\tif (core_data->slot_offset == INVALID_SLOT_OFFSET) {\n\t\tcore_data->delayed_pos_update = true;\n\t\treturn 0;\n\t}\n\n\t \n\tsof_mailbox_read(sdev, core_data->slot_offset + sizeof(u32),\n\t\t\t &core_data->dsp_write_ptr, 4);\n\tcore_data->dsp_write_ptr -= core_data->dsp_write_ptr % 4;\n\n\tif (sof_debug_check_flag(SOF_DBG_PRINT_DMA_POSITION_UPDATE_LOGS))\n\t\tdev_dbg(sdev->dev, \"core%d, host read: %#x, dsp write: %#x\",\n\t\t\tcore, core_data->host_read_ptr, core_data->dsp_write_ptr);\n\n\twake_up(&core_data->trace_sleep);\n\n\treturn 0;\n}\n\nstatic void ipc4_mtrace_fw_crashed(struct snd_sof_dev *sdev)\n{\n\t \n\tsof_ipc4_mtrace_update_pos_all_cores(sdev);\n}\n\nstatic int ipc4_mtrace_resume(struct snd_sof_dev *sdev)\n{\n\treturn ipc4_mtrace_enable(sdev);\n}\n\nstatic void ipc4_mtrace_suspend(struct snd_sof_dev *sdev, pm_message_t pm_state)\n{\n\tipc4_mtrace_disable(sdev);\n}\n\nconst struct sof_ipc_fw_tracing_ops ipc4_mtrace_ops = {\n\t.init = ipc4_mtrace_init,\n\t.free = ipc4_mtrace_free,\n\t.fw_crashed = ipc4_mtrace_fw_crashed,\n\t.suspend = ipc4_mtrace_suspend,\n\t.resume = ipc4_mtrace_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}