{
  "module_name": "pcm.c",
  "hash_id": "727a010d67e0af18af359fad11b2a40661114e377cc0c94e3cad321774c305a3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/pm_runtime.h>\n#include <sound/pcm_params.h>\n#include <sound/sof.h>\n#include <trace/events/sof.h>\n#include \"sof-of-dev.h\"\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"sof-utils.h\"\n#include \"ops.h\"\n\n \nstatic int create_page_table(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     unsigned char *dma_area, size_t size)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_pcm *spcm;\n\tstruct snd_dma_buffer *dmab = snd_pcm_get_dma_buf(substream);\n\tint stream = substream->stream;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\treturn snd_sof_create_page_table(component->dev, dmab,\n\t\tspcm->stream[stream].page_table.area, size);\n}\n\n \nstatic void snd_sof_pcm_period_elapsed_work(struct work_struct *work)\n{\n\tstruct snd_sof_pcm_stream *sps =\n\t\tcontainer_of(work, struct snd_sof_pcm_stream,\n\t\t\t     period_elapsed_work);\n\n\tsnd_pcm_period_elapsed(sps->substream);\n}\n\nvoid snd_sof_pcm_init_elapsed_work(struct work_struct *work)\n{\n\t INIT_WORK(work, snd_sof_pcm_period_elapsed_work);\n}\n\n \nvoid snd_sof_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm) {\n\t\tdev_err(component->dev,\n\t\t\t\"error: period elapsed for unknown stream!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tschedule_work(&spcm->stream[substream->stream].period_elapsed_work);\n}\nEXPORT_SYMBOL(snd_sof_pcm_period_elapsed);\n\nstatic int\nsof_pcm_setup_connected_widgets(struct snd_sof_dev *sdev, struct snd_soc_pcm_runtime *rtd,\n\t\t\t\tstruct snd_sof_pcm *spcm, struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_sof_platform_stream_params *platform_params, int dir)\n{\n\tstruct snd_soc_dai *dai;\n\tint ret, j;\n\n\t \n\tfor_each_rtd_cpu_dais(rtd, j, dai) {\n\t\tstruct snd_soc_dapm_widget_list *list;\n\n\t\tret = snd_soc_dapm_dai_get_connected_widgets(dai, dir, &list,\n\t\t\t\t\t\t\t     dpcm_end_walk_at_be);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: dai %s has no valid %s path\\n\", dai->name,\n\t\t\t\tdir == SNDRV_PCM_STREAM_PLAYBACK ? \"playback\" : \"capture\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tspcm->stream[dir].list = list;\n\n\t\tret = sof_widget_list_setup(sdev, spcm, params, platform_params, dir);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"error: failed widget list set up for pcm %d dir %d\\n\",\n\t\t\t\tspcm->pcm.pcm_id, dir);\n\t\t\tspcm->stream[dir].list = NULL;\n\t\t\tsnd_soc_dapm_dai_free_widgets(&list);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tstruct snd_sof_platform_stream_params platform_params = { 0 };\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_sof_pcm *spcm;\n\tint ret;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\t \n\tif (pcm_ops && pcm_ops->hw_free && spcm->prepared[substream->stream]) {\n\t\tret = pcm_ops->hw_free(component, substream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tspcm->prepared[substream->stream] = false;\n\t}\n\n\tdev_dbg(component->dev, \"pcm: hw params stream %d dir %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream);\n\n\tret = snd_sof_pcm_platform_hw_params(sdev, substream, params, &platform_params);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"platform hw params failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!spcm->stream[substream->stream].list) {\n\t\tret = sof_pcm_setup_connected_widgets(sdev, rtd, spcm, params, &platform_params,\n\t\t\t\t\t\t      substream->stream);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (runtime->buffer_changed) {\n\t\tret = create_page_table(component, substream, runtime->dma_area,\n\t\t\t\t\truntime->dma_bytes);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (pcm_ops && pcm_ops->hw_params) {\n\t\tret = pcm_ops->hw_params(component, substream, params, &platform_params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tspcm->prepared[substream->stream] = true;\n\n\t \n\tmemcpy(&spcm->params[substream->stream], params, sizeof(*params));\n\n\treturn 0;\n}\n\nstatic int sof_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tstruct snd_sof_pcm *spcm;\n\tint ret, err = 0;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tdev_dbg(component->dev, \"pcm: free stream %d dir %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream);\n\n\tif (spcm->prepared[substream->stream]) {\n\t\t \n\t\tif (pcm_ops && pcm_ops->platform_stop_during_hw_free)\n\t\t\tsnd_sof_pcm_platform_trigger(sdev, substream, SNDRV_PCM_TRIGGER_STOP);\n\n\t\t \n\t\tif (pcm_ops && pcm_ops->hw_free) {\n\t\t\tret = pcm_ops->hw_free(component, substream);\n\t\t\tif (ret < 0)\n\t\t\t\terr = ret;\n\t\t}\n\n\t\tspcm->prepared[substream->stream] = false;\n\t}\n\n\t \n\tret = snd_sof_pcm_platform_hw_free(sdev, substream);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"error: platform hw free failed\\n\");\n\t\terr = ret;\n\t}\n\n\t \n\tret = sof_widget_list_free(sdev, spcm, substream->stream);\n\tif (ret < 0)\n\t\terr = ret;\n\n\tcancel_work_sync(&spcm->stream[substream->stream].period_elapsed_work);\n\n\treturn err;\n}\n\nstatic int sof_pcm_prepare(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_pcm *spcm;\n\tint ret;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tif (spcm->prepared[substream->stream])\n\t\treturn 0;\n\n\tdev_dbg(component->dev, \"pcm: prepare stream %d dir %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream);\n\n\t \n\tret = sof_pcm_hw_params(component,\n\t\t\t\tsubstream, &spcm->params[substream->stream]);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"error: set pcm hw_params after resume\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_pcm_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tstruct snd_sof_pcm *spcm;\n\tbool reset_hw_params = false;\n\tbool ipc_first = false;\n\tint ret = 0;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tdev_dbg(component->dev, \"pcm: trigger stream %d dir %d cmd %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tipc_first = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (pcm_ops && pcm_ops->ipc_first_on_start)\n\t\t\tipc_first = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (spcm->stream[substream->stream].suspend_ignored) {\n\t\t\t \n\t\t\tspcm->stream[substream->stream].suspend_ignored = false;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (pcm_ops && pcm_ops->ipc_first_on_start)\n\t\t\tipc_first = true;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (sdev->system_suspend_target == SOF_SUSPEND_S0IX &&\n\t\t    spcm->stream[substream->stream].d0i3_compatible) {\n\t\t\t \n\t\t\tspcm->stream[substream->stream].suspend_ignored = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (sdev->dspless_mode_selected)\n\t\t\treset_hw_params = true;\n\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tipc_first = true;\n\t\tif (pcm_ops && pcm_ops->reset_hw_params_during_stop)\n\t\t\treset_hw_params = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unhandled trigger cmd %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ipc_first)\n\t\tsnd_sof_pcm_platform_trigger(sdev, substream, cmd);\n\n\tif (pcm_ops && pcm_ops->trigger)\n\t\tret = pcm_ops->trigger(component, substream, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\t \n\t\tif (ipc_first && !ret)\n\t\t\tsnd_sof_pcm_platform_trigger(sdev, substream, cmd);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t \n\t\tif (!pcm_ops || !pcm_ops->platform_stop_during_hw_free)\n\t\t\tsnd_sof_pcm_platform_trigger(sdev, substream, cmd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!ret && reset_hw_params)\n\t\tret = sof_pcm_stream_free(sdev, substream, spcm, substream->stream, false);\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t sof_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_sof_pcm *spcm;\n\tsnd_pcm_uframes_t host, dai;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\t \n\tif (sof_ops(sdev)->pcm_pointer)\n\t\treturn sof_ops(sdev)->pcm_pointer(sdev, substream);\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\t \n\thost = bytes_to_frames(substream->runtime,\n\t\t\t       spcm->stream[substream->stream].posn.host_posn);\n\tdai = bytes_to_frames(substream->runtime,\n\t\t\t      spcm->stream[substream->stream].posn.dai_posn);\n\n\ttrace_sof_pcm_pointer_position(sdev, spcm, substream, host, dai);\n\n\treturn host;\n}\n\nstatic int sof_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_sof_dsp_ops *ops = sof_ops(sdev);\n\tstruct snd_sof_pcm *spcm;\n\tstruct snd_soc_tplg_stream_caps *caps;\n\tint ret;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tdev_dbg(component->dev, \"pcm: open stream %d dir %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream);\n\n\n\tcaps = &spcm->pcm.caps[substream->stream];\n\n\t \n\truntime->hw.info = ops->hw_info;  \n\n\t \n\truntime->hw.formats = le64_to_cpu(caps->formats);\n\truntime->hw.period_bytes_min = le32_to_cpu(caps->period_size_min);\n\truntime->hw.period_bytes_max = le32_to_cpu(caps->period_size_max);\n\truntime->hw.periods_min = le32_to_cpu(caps->periods_min);\n\truntime->hw.periods_max = le32_to_cpu(caps->periods_max);\n\n\t \n\truntime->hw.buffer_bytes_max = le32_to_cpu(caps->buffer_size_max);\n\n\tdev_dbg(component->dev, \"period min %zd max %zd bytes\\n\",\n\t\truntime->hw.period_bytes_min,\n\t\truntime->hw.period_bytes_max);\n\tdev_dbg(component->dev, \"period count %d max %d\\n\",\n\t\truntime->hw.periods_min,\n\t\truntime->hw.periods_max);\n\tdev_dbg(component->dev, \"buffer max %zd bytes\\n\",\n\t\truntime->hw.buffer_bytes_max);\n\n\t \n\tsubstream->wait_time = 500;\n\n\tspcm->stream[substream->stream].posn.host_posn = 0;\n\tspcm->stream[substream->stream].posn.dai_posn = 0;\n\tspcm->stream[substream->stream].substream = substream;\n\tspcm->prepared[substream->stream] = false;\n\n\tret = snd_sof_pcm_platform_open(sdev, substream);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"error: pcm open failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int sof_pcm_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_sof_pcm *spcm;\n\tint err;\n\n\t \n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tdev_dbg(component->dev, \"pcm: close stream %d dir %d\\n\",\n\t\tspcm->pcm.pcm_id, substream->stream);\n\n\terr = snd_sof_pcm_platform_close(sdev, substream);\n\tif (err < 0) {\n\t\tdev_err(component->dev, \"error: pcm close failed %d\\n\",\n\t\t\terr);\n\t\t \n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_pcm_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_sof_pcm *spcm;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct snd_soc_tplg_stream_caps *caps;\n\tint stream = SNDRV_PCM_STREAM_PLAYBACK;\n\n\t \n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm) {\n\t\tdev_warn(component->dev, \"warn: can't find PCM with DAI ID %d\\n\",\n\t\t\t rtd->dai_link->id);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(component->dev, \"creating new PCM %s\\n\", spcm->pcm.pcm_name);\n\n\t \n\tif (!spcm->pcm.playback)\n\t\tgoto capture;\n\n\tcaps = &spcm->pcm.caps[stream];\n\n\t \n\tdev_dbg(component->dev,\n\t\t\"spcm: allocate %s playback DMA buffer size 0x%x max 0x%x\\n\",\n\t\tcaps->name, caps->buffer_size_min, caps->buffer_size_max);\n\n\tif (!pcm->streams[stream].substream) {\n\t\tdev_err(component->dev, \"error: NULL playback substream!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_set_managed_buffer(pcm->streams[stream].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_DEV_SG, sdev->dev,\n\t\t\t\t   0, le32_to_cpu(caps->buffer_size_max));\ncapture:\n\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\n\t \n\tif (!spcm->pcm.capture)\n\t\treturn 0;\n\n\tcaps = &spcm->pcm.caps[stream];\n\n\t \n\tdev_dbg(component->dev,\n\t\t\"spcm: allocate %s capture DMA buffer size 0x%x max 0x%x\\n\",\n\t\tcaps->name, caps->buffer_size_min, caps->buffer_size_max);\n\n\tif (!pcm->streams[stream].substream) {\n\t\tdev_err(component->dev, \"error: NULL capture substream!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_set_managed_buffer(pcm->streams[stream].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_DEV_SG, sdev->dev,\n\t\t\t\t   0, le32_to_cpu(caps->buffer_size_max));\n\n\treturn 0;\n}\n\n \nint sof_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_params *params)\n{\n\tstruct snd_interval *rate = hw_param_interval(params,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\tstruct snd_sof_dai *dai =\n\t\tsnd_sof_find_dai(component, (char *)rtd->dai_link->name);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\n\t \n\tif (!dai) {\n\t\tdev_warn(component->dev,\n\t\t\t \"warning: no topology found for BE DAI %s config\\n\",\n\t\t\t rtd->dai_link->name);\n\n\t\t \n\t\trate->min = 48000;\n\t\trate->max = 48000;\n\n\t\tchannels->min = 2;\n\t\tchannels->max = 2;\n\n\t\tsnd_mask_none(fmt);\n\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);\n\n\t\treturn 0;\n\t}\n\n\tif (pcm_ops && pcm_ops->dai_link_fixup)\n\t\treturn pcm_ops->dai_link_fixup(rtd, params);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sof_pcm_dai_link_fixup);\n\nstatic int sof_pcm_probe(struct snd_soc_component *component)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tconst char *tplg_filename;\n\tint ret;\n\n\t \n\tret = pm_runtime_resume_and_get(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\t \n\tsdev->component = component;\n\n\ttplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,\n\t\t\t\t       \"%s/%s\",\n\t\t\t\t       plat_data->tplg_filename_prefix,\n\t\t\t\t       plat_data->tplg_filename);\n\tif (!tplg_filename) {\n\t\tret = -ENOMEM;\n\t\tgoto pm_error;\n\t}\n\n\tret = snd_sof_load_topology(component, tplg_filename);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"error: failed to load DSP topology %d\\n\",\n\t\t\tret);\n\npm_error:\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n\n\treturn ret;\n}\n\nstatic void sof_pcm_remove(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_tplg_component_remove(component);\n}\n\nstatic int sof_pcm_ack(struct snd_soc_component *component,\n\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\n\treturn snd_sof_pcm_platform_ack(sdev, substream);\n}\n\nstatic snd_pcm_sframes_t sof_pcm_delay(struct snd_soc_component *component,\n\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\n\tif (pcm_ops && pcm_ops->delay)\n\t\treturn pcm_ops->delay(component, substream);\n\n\treturn 0;\n}\n\nvoid snd_sof_new_platform_drv(struct snd_sof_dev *sdev)\n{\n\tstruct snd_soc_component_driver *pd = &sdev->plat_drv;\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tconst char *drv_name;\n\n\tif (plat_data->machine)\n\t\tdrv_name = plat_data->machine->drv_name;\n\telse if (plat_data->of_machine)\n\t\tdrv_name = plat_data->of_machine->drv_name;\n\telse\n\t\tdrv_name = NULL;\n\n\tpd->name = \"sof-audio-component\";\n\tpd->probe = sof_pcm_probe;\n\tpd->remove = sof_pcm_remove;\n\tpd->open = sof_pcm_open;\n\tpd->close = sof_pcm_close;\n\tpd->hw_params = sof_pcm_hw_params;\n\tpd->prepare = sof_pcm_prepare;\n\tpd->hw_free = sof_pcm_hw_free;\n\tpd->trigger = sof_pcm_trigger;\n\tpd->pointer = sof_pcm_pointer;\n\tpd->ack = sof_pcm_ack;\n\tpd->delay = sof_pcm_delay;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_COMPRESS)\n\tpd->compress_ops = &sof_compressed_ops;\n#endif\n\n\tpd->pcm_construct = sof_pcm_new;\n\tpd->ignore_machine = drv_name;\n\tpd->be_pcm_base = SOF_BE_PCM_BASE;\n\tpd->use_dai_pcm_id = true;\n\tpd->topology_name_prefix = \"sof\";\n\n\t  \n\tpd->module_get_upon_open = 1;\n\n\tpd->legacy_dai_naming = 1;\n\n\t \n\tif (!sdev->dspless_mode_selected)\n\t\tpd->be_hw_params_fixup = sof_pcm_dai_link_fixup;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}