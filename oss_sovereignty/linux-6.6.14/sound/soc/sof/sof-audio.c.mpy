{
  "module_name": "sof-audio.c",
  "hash_id": "55c6a76bfb1d5dc1f82b4669b7bd59aab12a972949788b96b872c12db52cda2f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-audio.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <trace/events/sof.h>\n#include \"sof-audio.h\"\n#include \"sof-of-dev.h\"\n#include \"ops.h\"\n\nstatic bool is_virtual_widget(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *widget,\n\t\t\t      const char *func)\n{\n\tswitch (widget->id) {\n\tcase snd_soc_dapm_out_drv:\n\tcase snd_soc_dapm_output:\n\tcase snd_soc_dapm_input:\n\t\tdev_dbg(sdev->dev, \"%s: %s is a virtual widget\\n\", func, widget->name);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void sof_reset_route_setup_status(struct snd_sof_dev *sdev, struct snd_sof_widget *widget)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_route *sroute;\n\n\tlist_for_each_entry(sroute, &sdev->route_list, list)\n\t\tif (sroute->src_widget == widget || sroute->sink_widget == widget) {\n\t\t\tif (sroute->setup && tplg_ops && tplg_ops->route_free)\n\t\t\t\ttplg_ops->route_free(sdev, sroute);\n\n\t\t\tsroute->setup = false;\n\t\t}\n}\n\nstatic int sof_widget_free_unlocked(struct snd_sof_dev *sdev,\n\t\t\t\t    struct snd_sof_widget *swidget)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tstruct snd_sof_widget *pipe_widget;\n\tint err = 0;\n\tint ret;\n\n\tif (!swidget->private)\n\t\treturn 0;\n\n\ttrace_sof_widget_free(swidget);\n\n\t \n\tif (--swidget->use_count)\n\t\treturn 0;\n\n\tpipe_widget = swidget->spipe->pipe_widget;\n\n\t \n\tsof_reset_route_setup_status(sdev, swidget);\n\n\t \n\tif (WIDGET_IS_DAI(swidget->id)) {\n\t\tstruct snd_sof_dai_config_data data;\n\t\tunsigned int flags = SOF_DAI_CONFIG_FLAGS_HW_FREE;\n\n\t\tdata.dai_data = DMA_CHAN_INVALID;\n\n\t\tif (tplg_ops && tplg_ops->dai_config) {\n\t\t\terr = tplg_ops->dai_config(sdev, swidget, flags, &data);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(sdev->dev, \"failed to free config for widget %s\\n\",\n\t\t\t\t\tswidget->widget->name);\n\t\t}\n\t}\n\n\t \n\tif (tplg_ops && tplg_ops->widget_free) {\n\t\tret = tplg_ops->widget_free(sdev, swidget);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t}\n\n\t \n\tif (swidget->id == snd_soc_dapm_scheduler) {\n\t\tint i;\n\n\t\tfor_each_set_bit(i, &spipe->core_mask, sdev->num_cores) {\n\t\t\tret = snd_sof_dsp_core_put(sdev, i);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"failed to disable target core: %d for pipeline %s\\n\",\n\t\t\t\t\ti, swidget->widget->name);\n\t\t\t\tif (!err)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tswidget->spipe->complete = 0;\n\t}\n\n\t \n\tif (swidget->dynamic_pipeline_widget && swidget->id != snd_soc_dapm_scheduler) {\n\t\tret = sof_widget_free_unlocked(sdev, pipe_widget);\n\t\tif (ret < 0 && !err)\n\t\t\terr = ret;\n\t}\n\n\tif (!err)\n\t\tdev_dbg(sdev->dev, \"widget %s freed\\n\", swidget->widget->name);\n\n\treturn err;\n}\n\nint sof_widget_free(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tint ret;\n\n\tmutex_lock(&swidget->setup_mutex);\n\tret = sof_widget_free_unlocked(sdev, swidget);\n\tmutex_unlock(&swidget->setup_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sof_widget_free);\n\nstatic int sof_widget_setup_unlocked(struct snd_sof_dev *sdev,\n\t\t\t\t     struct snd_sof_widget *swidget)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tbool use_count_decremented = false;\n\tint ret;\n\tint i;\n\n\t \n\tif (!swidget->private)\n\t\treturn 0;\n\n\ttrace_sof_widget_setup(swidget);\n\n\t \n\tif (++swidget->use_count > 1)\n\t\treturn 0;\n\n\t \n\tif (swidget->dynamic_pipeline_widget && swidget->id != snd_soc_dapm_scheduler) {\n\t\tif (!swidget->spipe || !swidget->spipe->pipe_widget) {\n\t\t\tdev_err(sdev->dev, \"No pipeline set for %s\\n\", swidget->widget->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto use_count_dec;\n\t\t}\n\n\t\tret = sof_widget_setup_unlocked(sdev, swidget->spipe->pipe_widget);\n\t\tif (ret < 0)\n\t\t\tgoto use_count_dec;\n\t}\n\n\t \n\tif (swidget->id == snd_soc_dapm_scheduler) {\n\t\tfor_each_set_bit(i, &spipe->core_mask, sdev->num_cores) {\n\t\t\tret = snd_sof_dsp_core_get(sdev, i);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"failed to enable target core %d for pipeline %s\\n\",\n\t\t\t\t\ti, swidget->widget->name);\n\t\t\t\tgoto pipe_widget_free;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (tplg_ops && tplg_ops->widget_setup) {\n\t\tret = tplg_ops->widget_setup(sdev, swidget);\n\t\tif (ret < 0)\n\t\t\tgoto pipe_widget_free;\n\t}\n\n\t \n\tif (WIDGET_IS_DAI(swidget->id)) {\n\t\tunsigned int flags = SOF_DAI_CONFIG_FLAGS_HW_PARAMS;\n\n\t\t \n\t\tif (tplg_ops && tplg_ops->dai_config) {\n\t\t\tret = tplg_ops->dai_config(sdev, swidget, flags, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto widget_free;\n\t\t}\n\t}\n\n\t \n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->widget_kcontrol_setup) {\n\t\tret = tplg_ops->control->widget_kcontrol_setup(sdev, swidget);\n\t\tif (ret < 0)\n\t\t\tgoto widget_free;\n\t}\n\n\tdev_dbg(sdev->dev, \"widget %s setup complete\\n\", swidget->widget->name);\n\n\treturn 0;\n\nwidget_free:\n\t \n\tsof_widget_free_unlocked(sdev, swidget);\n\tuse_count_decremented = true;\npipe_widget_free:\n\tif (swidget->id != snd_soc_dapm_scheduler) {\n\t\tsof_widget_free_unlocked(sdev, swidget->spipe->pipe_widget);\n\t} else {\n\t\tint j;\n\n\t\t \n\t\tfor_each_set_bit(j, &spipe->core_mask, sdev->num_cores) {\n\t\t\tif (j >= i)\n\t\t\t\tbreak;\n\t\t\tsnd_sof_dsp_core_put(sdev, j);\n\t\t}\n\t}\nuse_count_dec:\n\tif (!use_count_decremented)\n\t\tswidget->use_count--;\n\n\treturn ret;\n}\n\nint sof_widget_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tint ret;\n\n\tmutex_lock(&swidget->setup_mutex);\n\tret = sof_widget_setup_unlocked(sdev, swidget);\n\tmutex_unlock(&swidget->setup_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(sof_widget_setup);\n\nint sof_route_setup(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *wsource,\n\t\t    struct snd_soc_dapm_widget *wsink)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_widget *src_widget = wsource->dobj.private;\n\tstruct snd_sof_widget *sink_widget = wsink->dobj.private;\n\tstruct snd_sof_route *sroute;\n\tbool route_found = false;\n\n\t \n\tif (is_virtual_widget(sdev, src_widget->widget, __func__) ||\n\t    is_virtual_widget(sdev, sink_widget->widget, __func__))\n\t\treturn 0;\n\n\t \n\tlist_for_each_entry(sroute, &sdev->route_list, list)\n\t\tif (sroute->src_widget == src_widget && sroute->sink_widget == sink_widget) {\n\t\t\troute_found = true;\n\t\t\tbreak;\n\t\t}\n\n\tif (!route_found) {\n\t\tdev_err(sdev->dev, \"error: cannot find SOF route for source %s -> %s sink\\n\",\n\t\t\twsource->name, wsink->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sroute->setup)\n\t\treturn 0;\n\n\tif (tplg_ops && tplg_ops->route_setup) {\n\t\tint ret = tplg_ops->route_setup(sdev, sroute);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsroute->setup = true;\n\treturn 0;\n}\n\nstatic int sof_setup_pipeline_connections(struct snd_sof_dev *sdev,\n\t\t\t\t\t  struct snd_soc_dapm_widget_list *list, int dir)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct snd_sof_route *sroute;\n\tstruct snd_soc_dapm_path *p;\n\tint ret = 0;\n\tint i;\n\n\t \n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tfor_each_dapm_widgets(list, i, widget) {\n\t\t\tif (!widget->dobj.private)\n\t\t\t\tcontinue;\n\n\t\t\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\t\t\tif (!widget_in_list(list, p->sink))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p->sink->dobj.private) {\n\t\t\t\t\tret = sof_route_setup(sdev, widget, p->sink);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor_each_dapm_widgets(list, i, widget) {\n\t\t\tif (!widget->dobj.private)\n\t\t\t\tcontinue;\n\n\t\t\tsnd_soc_dapm_widget_for_each_source_path(widget, p) {\n\t\t\t\tif (!widget_in_list(list, p->source))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (p->source->dobj.private) {\n\t\t\t\t\tret = sof_route_setup(sdev, p->source, widget);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(sroute, &sdev->route_list, list) {\n\t\tbool src_widget_in_dapm_list, sink_widget_in_dapm_list;\n\t\tstruct snd_sof_widget *swidget;\n\n\t\tif (sroute->setup)\n\t\t\tcontinue;\n\n\t\tsrc_widget_in_dapm_list = widget_in_list(list, sroute->src_widget->widget);\n\t\tsink_widget_in_dapm_list = widget_in_list(list, sroute->sink_widget->widget);\n\n\t\t \n\t\tif (src_widget_in_dapm_list == sink_widget_in_dapm_list)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (src_widget_in_dapm_list)\n\t\t\tswidget = sroute->sink_widget;\n\t\telse\n\t\t\tswidget = sroute->src_widget;\n\n\t\tmutex_lock(&swidget->setup_mutex);\n\t\tif (!swidget->use_count) {\n\t\t\tmutex_unlock(&swidget->setup_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tplg_ops && tplg_ops->route_setup) {\n\t\t\t \n\t\t\tret = tplg_ops->route_setup(sdev, sroute);\n\t\t\tif (!ret)\n\t\t\t\tsroute->setup = true;\n\t\t}\n\n\t\tmutex_unlock(&swidget->setup_mutex);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nsof_unprepare_widgets_in_path(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *widget,\n\t\t\t      struct snd_soc_dapm_widget_list *list)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_widget *swidget = widget->dobj.private;\n\tconst struct sof_ipc_tplg_widget_ops *widget_ops;\n\tstruct snd_soc_dapm_path *p;\n\n\tif (is_virtual_widget(sdev, widget, __func__))\n\t\treturn;\n\n\t \n\tif (!swidget || !swidget->prepared || swidget->use_count > 0)\n\t\tgoto sink_unprepare;\n\n\twidget_ops = tplg_ops ? tplg_ops->widget : NULL;\n\tif (widget_ops && widget_ops[widget->id].ipc_unprepare)\n\t\t \n\t\twidget_ops[widget->id].ipc_unprepare(swidget);\n\n\tswidget->prepared = false;\n\nsink_unprepare:\n\t \n\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\tif (!widget_in_list(list, p->sink))\n\t\t\tcontinue;\n\t\tif (!p->walking && p->sink->dobj.private) {\n\t\t\tp->walking = true;\n\t\t\tsof_unprepare_widgets_in_path(sdev, p->sink, list);\n\t\t\tp->walking = false;\n\t\t}\n\t}\n}\n\nstatic int\nsof_prepare_widgets_in_path(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *widget,\n\t\t\t    struct snd_pcm_hw_params *fe_params,\n\t\t\t    struct snd_sof_platform_stream_params *platform_params,\n\t\t\t    struct snd_pcm_hw_params *pipeline_params, int dir,\n\t\t\t    struct snd_soc_dapm_widget_list *list)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_widget *swidget = widget->dobj.private;\n\tconst struct sof_ipc_tplg_widget_ops *widget_ops;\n\tstruct snd_soc_dapm_path *p;\n\tint ret;\n\n\tif (is_virtual_widget(sdev, widget, __func__))\n\t\treturn 0;\n\n\twidget_ops = tplg_ops ? tplg_ops->widget : NULL;\n\tif (!widget_ops)\n\t\treturn 0;\n\n\tif (!swidget || !widget_ops[widget->id].ipc_prepare || swidget->prepared)\n\t\tgoto sink_prepare;\n\n\t \n\tret = widget_ops[widget->id].ipc_prepare(swidget, fe_params, platform_params,\n\t\t\t\t\t     pipeline_params, dir);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to prepare widget %s\\n\", widget->name);\n\t\treturn ret;\n\t}\n\n\tswidget->prepared = true;\n\nsink_prepare:\n\t \n\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\tif (!widget_in_list(list, p->sink))\n\t\t\tcontinue;\n\t\tif (!p->walking && p->sink->dobj.private) {\n\t\t\tp->walking = true;\n\t\t\tret = sof_prepare_widgets_in_path(sdev, p->sink,  fe_params,\n\t\t\t\t\t\t\t  platform_params, pipeline_params, dir,\n\t\t\t\t\t\t\t  list);\n\t\t\tp->walking = false;\n\t\t\tif (ret < 0) {\n\t\t\t\t \n\t\t\t\tif (widget_ops[widget->id].ipc_unprepare &&\n\t\t\t\t    swidget && swidget->prepared) {\n\t\t\t\t\twidget_ops[widget->id].ipc_unprepare(swidget);\n\t\t\t\t\tswidget->prepared = false;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_free_widgets_in_path(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *widget,\n\t\t\t\t    int dir, struct snd_sof_pcm *spcm)\n{\n\tstruct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;\n\tstruct snd_soc_dapm_path *p;\n\tint err;\n\tint ret = 0;\n\n\tif (is_virtual_widget(sdev, widget, __func__))\n\t\treturn 0;\n\n\tif (widget->dobj.private) {\n\t\terr = sof_widget_free(sdev, widget->dobj.private);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\n\t \n\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\tif (!p->walking) {\n\t\t\tif (!widget_in_list(list, p->sink))\n\t\t\t\tcontinue;\n\n\t\t\tp->walking = true;\n\n\t\t\terr = sof_free_widgets_in_path(sdev, p->sink, dir, spcm);\n\t\t\tif (err < 0)\n\t\t\t\tret = err;\n\t\t\tp->walking = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sof_set_up_widgets_in_path(struct snd_sof_dev *sdev, struct snd_soc_dapm_widget *widget,\n\t\t\t\t      int dir, struct snd_sof_pcm *spcm)\n{\n\tstruct snd_sof_pcm_stream_pipeline_list *pipeline_list = &spcm->stream[dir].pipeline_list;\n\tstruct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;\n\tstruct snd_sof_widget *swidget = widget->dobj.private;\n\tstruct snd_sof_pipeline *spipe;\n\tstruct snd_soc_dapm_path *p;\n\tint ret;\n\n\tif (is_virtual_widget(sdev, widget, __func__))\n\t\treturn 0;\n\n\tif (swidget) {\n\t\tint i;\n\n\t\tret = sof_widget_setup(sdev, widget->dobj.private);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!pipeline_list->pipelines)\n\t\t\tgoto sink_setup;\n\n\t\t \n\t\tfor (i = 0; i < pipeline_list->count; i++) {\n\t\t\tspipe = pipeline_list->pipelines[i];\n\t\t\tif (spipe == swidget->spipe)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == pipeline_list->count) {\n\t\t\tpipeline_list->count++;\n\t\t\tpipeline_list->pipelines[i] = swidget->spipe;\n\t\t}\n\t}\n\nsink_setup:\n\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\tif (!p->walking) {\n\t\t\tif (!widget_in_list(list, p->sink))\n\t\t\t\tcontinue;\n\n\t\t\tp->walking = true;\n\n\t\t\tret = sof_set_up_widgets_in_path(sdev, p->sink, dir, spcm);\n\t\t\tp->walking = false;\n\t\t\tif (ret < 0) {\n\t\t\t\tif (swidget)\n\t\t\t\t\tsof_widget_free(sdev, swidget);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nsof_walk_widgets_in_order(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm,\n\t\t\t  struct snd_pcm_hw_params *fe_params,\n\t\t\t  struct snd_sof_platform_stream_params *platform_params, int dir,\n\t\t\t  enum sof_widget_op op)\n{\n\tstruct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;\n\tstruct snd_soc_dapm_widget *widget;\n\tchar *str;\n\tint ret = 0;\n\tint i;\n\n\tif (!list)\n\t\treturn 0;\n\n\tfor_each_dapm_widgets(list, i, widget) {\n\t\tif (is_virtual_widget(sdev, widget, __func__))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK && widget->id != snd_soc_dapm_aif_in)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dir == SNDRV_PCM_STREAM_CAPTURE && widget->id != snd_soc_dapm_dai_out)\n\t\t\tcontinue;\n\n\t\tswitch (op) {\n\t\tcase SOF_WIDGET_SETUP:\n\t\t\tret = sof_set_up_widgets_in_path(sdev, widget, dir, spcm);\n\t\t\tstr = \"set up\";\n\t\t\tbreak;\n\t\tcase SOF_WIDGET_FREE:\n\t\t\tret = sof_free_widgets_in_path(sdev, widget, dir, spcm);\n\t\t\tstr = \"free\";\n\t\t\tbreak;\n\t\tcase SOF_WIDGET_PREPARE:\n\t\t{\n\t\t\tstruct snd_pcm_hw_params pipeline_params;\n\n\t\t\tstr = \"prepare\";\n\t\t\t \n\t\t\tmemcpy(&pipeline_params, fe_params, sizeof(*fe_params));\n\n\t\t\tret = sof_prepare_widgets_in_path(sdev, widget, fe_params, platform_params,\n\t\t\t\t\t\t\t  &pipeline_params, dir, list);\n\t\t\tbreak;\n\t\t}\n\t\tcase SOF_WIDGET_UNPREPARE:\n\t\t\tsof_unprepare_widgets_in_path(sdev, widget, list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sdev->dev, \"Invalid widget op %d\\n\", op);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Failed to %s connected widgets\\n\", str);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint sof_widget_list_setup(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm,\n\t\t\t  struct snd_pcm_hw_params *fe_params,\n\t\t\t  struct snd_sof_platform_stream_params *platform_params,\n\t\t\t  int dir)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;\n\tstruct snd_soc_dapm_widget *widget;\n\tint i, ret;\n\n\t \n\tif (!list)\n\t\treturn 0;\n\n\t \n\tret = sof_walk_widgets_in_order(sdev, spcm, fe_params, platform_params,\n\t\t\t\t\tdir, SOF_WIDGET_PREPARE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = sof_walk_widgets_in_order(sdev, spcm, fe_params, platform_params,\n\t\t\t\t\tdir, SOF_WIDGET_SETUP);\n\tif (ret < 0) {\n\t\tsof_walk_widgets_in_order(sdev, spcm, fe_params, platform_params,\n\t\t\t\t\t  dir, SOF_WIDGET_UNPREPARE);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sof_setup_pipeline_connections(sdev, list, dir);\n\tif (ret < 0)\n\t\tgoto widget_free;\n\n\t \n\tfor_each_dapm_widgets(list, i, widget) {\n\t\tstruct snd_sof_widget *swidget = widget->dobj.private;\n\t\tstruct snd_sof_widget *pipe_widget;\n\t\tstruct snd_sof_pipeline *spipe;\n\n\t\tif (!swidget || sdev->dspless_mode_selected)\n\t\t\tcontinue;\n\n\t\tspipe = swidget->spipe;\n\t\tif (!spipe) {\n\t\t\tdev_err(sdev->dev, \"no pipeline found for %s\\n\",\n\t\t\t\tswidget->widget->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto widget_free;\n\t\t}\n\n\t\tpipe_widget = spipe->pipe_widget;\n\t\tif (!pipe_widget) {\n\t\t\tdev_err(sdev->dev, \"error: no pipeline widget found for %s\\n\",\n\t\t\t\tswidget->widget->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto widget_free;\n\t\t}\n\n\t\tif (spipe->complete)\n\t\t\tcontinue;\n\n\t\tif (tplg_ops && tplg_ops->pipeline_complete) {\n\t\t\tspipe->complete = tplg_ops->pipeline_complete(sdev, pipe_widget);\n\t\t\tif (spipe->complete < 0) {\n\t\t\t\tret = spipe->complete;\n\t\t\t\tgoto widget_free;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nwidget_free:\n\tsof_walk_widgets_in_order(sdev, spcm, fe_params, platform_params, dir,\n\t\t\t\t  SOF_WIDGET_FREE);\n\tsof_walk_widgets_in_order(sdev, spcm, NULL, NULL, dir, SOF_WIDGET_UNPREPARE);\n\n\treturn ret;\n}\n\nint sof_widget_list_free(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm, int dir)\n{\n\tstruct snd_sof_pcm_stream_pipeline_list *pipeline_list = &spcm->stream[dir].pipeline_list;\n\tstruct snd_soc_dapm_widget_list *list = spcm->stream[dir].list;\n\tint ret;\n\n\t \n\tif (!list)\n\t\treturn 0;\n\n\t \n\tret = sof_walk_widgets_in_order(sdev, spcm, NULL, NULL, dir, SOF_WIDGET_FREE);\n\n\t \n\tsof_walk_widgets_in_order(sdev, spcm, NULL, NULL, dir, SOF_WIDGET_UNPREPARE);\n\n\tsnd_soc_dapm_dai_free_widgets(&list);\n\tspcm->stream[dir].list = NULL;\n\n\tpipeline_list->count = 0;\n\n\treturn ret;\n}\n\n \nbool snd_sof_dsp_only_d0i3_compatible_stream_active(struct snd_sof_dev *sdev)\n{\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_sof_pcm *spcm;\n\tbool d0i3_compatible_active = false;\n\tint dir;\n\n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tfor_each_pcm_streams(dir) {\n\t\t\tsubstream = spcm->stream[dir].substream;\n\t\t\tif (!substream || !substream->runtime)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (!spcm->stream[dir].d0i3_compatible)\n\t\t\t\treturn false;\n\n\t\t\td0i3_compatible_active = true;\n\t\t}\n\t}\n\n\treturn d0i3_compatible_active;\n}\nEXPORT_SYMBOL(snd_sof_dsp_only_d0i3_compatible_stream_active);\n\nbool snd_sof_stream_suspend_ignored(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pcm *spcm;\n\n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tif (spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].suspend_ignored ||\n\t\t    spcm->stream[SNDRV_PCM_STREAM_CAPTURE].suspend_ignored)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint sof_pcm_stream_free(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream,\n\t\t\tstruct snd_sof_pcm *spcm, int dir, bool free_widget_list)\n{\n\tconst struct sof_ipc_pcm_ops *pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tint ret;\n\n\tif (spcm->prepared[substream->stream]) {\n\t\t \n\t\tif (pcm_ops && pcm_ops->platform_stop_during_hw_free)\n\t\t\tsnd_sof_pcm_platform_trigger(sdev, substream, SNDRV_PCM_TRIGGER_STOP);\n\n\t\t \n\t\tif (pcm_ops && pcm_ops->hw_free) {\n\t\t\tret = pcm_ops->hw_free(sdev->component, substream);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tspcm->prepared[substream->stream] = false;\n\t}\n\n\t \n\tret = snd_sof_pcm_platform_hw_free(sdev, substream);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (free_widget_list) {\n\t\tret = sof_widget_list_free(sdev, spcm, dir);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"failed to free widgets during suspend\\n\");\n\t}\n\n\treturn ret;\n}\n\n \n\nstruct snd_sof_pcm *snd_sof_find_spcm_name(struct snd_soc_component *scomp,\n\t\t\t\t\t   const char *name)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_pcm *spcm;\n\n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\t \n\t\tif (strcmp(spcm->pcm.dai_name, name) == 0)\n\t\t\treturn spcm;\n\n\t\t \n\t\tif (*spcm->pcm.caps[0].name &&\n\t\t    !strcmp(spcm->pcm.caps[0].name, name))\n\t\t\treturn spcm;\n\n\t\t \n\t\tif (*spcm->pcm.caps[1].name &&\n\t\t    !strcmp(spcm->pcm.caps[1].name, name))\n\t\t\treturn spcm;\n\t}\n\n\treturn NULL;\n}\n\nstruct snd_sof_pcm *snd_sof_find_spcm_comp(struct snd_soc_component *scomp,\n\t\t\t\t\t   unsigned int comp_id,\n\t\t\t\t\t   int *direction)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_pcm *spcm;\n\tint dir;\n\n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tfor_each_pcm_streams(dir) {\n\t\t\tif (spcm->stream[dir].comp_id == comp_id) {\n\t\t\t\t*direction = dir;\n\t\t\t\treturn spcm;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct snd_sof_widget *snd_sof_find_swidget(struct snd_soc_component *scomp,\n\t\t\t\t\t    const char *name)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_widget *swidget;\n\n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (strcmp(name, swidget->widget->name) == 0)\n\t\t\treturn swidget;\n\t}\n\n\treturn NULL;\n}\n\n \nstruct snd_sof_widget *\nsnd_sof_find_swidget_sname(struct snd_soc_component *scomp,\n\t\t\t   const char *pcm_name, int dir)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_widget *swidget;\n\tenum snd_soc_dapm_type type;\n\n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\ttype = snd_soc_dapm_aif_in;\n\telse\n\t\ttype = snd_soc_dapm_aif_out;\n\n\tlist_for_each_entry(swidget, &sdev->widget_list, list) {\n\t\tif (!strcmp(pcm_name, swidget->widget->sname) &&\n\t\t    swidget->id == type)\n\t\t\treturn swidget;\n\t}\n\n\treturn NULL;\n}\n\nstruct snd_sof_dai *snd_sof_find_dai(struct snd_soc_component *scomp,\n\t\t\t\t     const char *name)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_dai *dai;\n\n\tlist_for_each_entry(dai, &sdev->dai_list, list) {\n\t\tif (dai->name && (strcmp(name, dai->name) == 0))\n\t\t\treturn dai;\n\t}\n\n\treturn NULL;\n}\n\nstatic int sof_dai_get_clk(struct snd_soc_pcm_runtime *rtd, int clk_type)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\tstruct snd_sof_dai *dai =\n\t\tsnd_sof_find_dai(component, (char *)rtd->dai_link->name);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\t \n\tif (!dai)\n\t\treturn 0;\n\n\tif (tplg_ops && tplg_ops->dai_get_clk)\n\t\treturn tplg_ops->dai_get_clk(sdev, dai, clk_type);\n\n\treturn 0;\n}\n\n \nint sof_dai_get_mclk(struct snd_soc_pcm_runtime *rtd)\n{\n\treturn sof_dai_get_clk(rtd, SOF_DAI_CLK_INTEL_SSP_MCLK);\n}\nEXPORT_SYMBOL(sof_dai_get_mclk);\n\n \nint sof_dai_get_bclk(struct snd_soc_pcm_runtime *rtd)\n{\n\treturn sof_dai_get_clk(rtd, SOF_DAI_CLK_INTEL_SSP_BCLK);\n}\nEXPORT_SYMBOL(sof_dai_get_bclk);\n\nstatic struct snd_sof_of_mach *sof_of_machine_select(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *sof_pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = sof_pdata->desc;\n\tstruct snd_sof_of_mach *mach = desc->of_machines;\n\n\tif (!mach)\n\t\treturn NULL;\n\n\tfor (; mach->compatible; mach++) {\n\t\tif (of_machine_is_compatible(mach->compatible)) {\n\t\t\tsof_pdata->tplg_filename = mach->sof_tplg_filename;\n\t\t\tif (mach->fw_filename)\n\t\t\t\tsof_pdata->fw_filename = mach->fw_filename;\n\n\t\t\treturn mach;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nint sof_machine_check(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *sof_pdata = sdev->pdata;\n\tconst struct sof_dev_desc *desc = sof_pdata->desc;\n\tstruct snd_soc_acpi_mach *mach;\n\n\tif (!IS_ENABLED(CONFIG_SND_SOC_SOF_FORCE_NOCODEC_MODE)) {\n\t\tconst struct snd_sof_of_mach *of_mach;\n\n\t\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC_DEBUG_SUPPORT) &&\n\t\t    sof_debug_check_flag(SOF_DBG_FORCE_NOCODEC))\n\t\t\tgoto nocodec;\n\n\t\t \n\t\tmach = snd_sof_machine_select(sdev);\n\t\tif (mach) {\n\t\t\tsof_pdata->machine = mach;\n\n\t\t\tif (sof_pdata->subsystem_id_set) {\n\t\t\t\tmach->mach_params.subsystem_vendor = sof_pdata->subsystem_vendor;\n\t\t\t\tmach->mach_params.subsystem_device = sof_pdata->subsystem_device;\n\t\t\t\tmach->mach_params.subsystem_id_set = true;\n\t\t\t}\n\n\t\t\tsnd_sof_set_mach_params(mach, sdev);\n\t\t\treturn 0;\n\t\t}\n\n\t\tof_mach = sof_of_machine_select(sdev);\n\t\tif (of_mach) {\n\t\t\tsof_pdata->of_machine = of_mach;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC)) {\n\t\t\tdev_err(sdev->dev, \"error: no matching ASoC machine driver found - aborting probe\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tdev_warn(sdev->dev, \"Force to use nocodec mode\\n\");\n\t}\n\nnocodec:\n\t \n\tdev_warn(sdev->dev, \"Using nocodec machine driver\\n\");\n\tmach = devm_kzalloc(sdev->dev, sizeof(*mach), GFP_KERNEL);\n\tif (!mach)\n\t\treturn -ENOMEM;\n\n\tmach->drv_name = \"sof-nocodec\";\n\tif (!sof_pdata->tplg_filename)\n\t\tsof_pdata->tplg_filename = desc->nocodec_tplg_filename;\n\n\tsof_pdata->machine = mach;\n\tsnd_sof_set_mach_params(mach, sdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sof_machine_check);\n\nint sof_machine_register(struct snd_sof_dev *sdev, void *pdata)\n{\n\tstruct snd_sof_pdata *plat_data = pdata;\n\tconst char *drv_name;\n\tconst void *mach;\n\tint size;\n\n\tdrv_name = plat_data->machine->drv_name;\n\tmach = plat_data->machine;\n\tsize = sizeof(*plat_data->machine);\n\n\t \n\tplat_data->pdev_mach =\n\t\tplatform_device_register_data(sdev->dev, drv_name,\n\t\t\t\t\t      PLATFORM_DEVID_NONE, mach, size);\n\tif (IS_ERR(plat_data->pdev_mach))\n\t\treturn PTR_ERR(plat_data->pdev_mach);\n\n\tdev_dbg(sdev->dev, \"created machine %s\\n\",\n\t\tdev_name(&plat_data->pdev_mach->dev));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(sof_machine_register);\n\nvoid sof_machine_unregister(struct snd_sof_dev *sdev, void *pdata)\n{\n\tstruct snd_sof_pdata *plat_data = pdata;\n\n\tif (!IS_ERR_OR_NULL(plat_data->pdev_mach))\n\t\tplatform_device_unregister(plat_data->pdev_mach);\n}\nEXPORT_SYMBOL(sof_machine_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}