{
  "module_name": "pm.c",
  "hash_id": "d32e5732a53db639aa91e1f1ca3e0783cce57f39d6dbda79879f1bfa0f651c0d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/pm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include \"ops.h\"\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n\n \nstatic u32 snd_sof_dsp_power_target(struct snd_sof_dev *sdev)\n{\n\tu32 target_dsp_state;\n\n\tswitch (sdev->system_suspend_target) {\n\tcase SOF_SUSPEND_S5:\n\tcase SOF_SUSPEND_S4:\n\t\t \n\tcase SOF_SUSPEND_S3:\n\t\t \n\t\ttarget_dsp_state = SOF_DSP_PM_D3;\n\t\tbreak;\n\tcase SOF_SUSPEND_S0IX:\n\t\t \n\t\tif (snd_sof_stream_suspend_ignored(sdev))\n\t\t\ttarget_dsp_state = SOF_DSP_PM_D0;\n\t\telse\n\t\t\ttarget_dsp_state = SOF_DSP_PM_D3;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ttarget_dsp_state = SOF_DSP_PM_D3;\n\t\tbreak;\n\t}\n\n\treturn target_dsp_state;\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\nstatic void sof_cache_debugfs(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tlist_for_each_entry(dfse, &sdev->dfsentry_list, list) {\n\n\t\t \n\t\tif (dfse->type == SOF_DFSENTRY_TYPE_BUF)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dfse->access_type == SOF_DEBUGFS_ACCESS_D0_ONLY)\n\t\t\tmemcpy_fromio(dfse->cache_buf, dfse->io_mem,\n\t\t\t\t      dfse->size);\n\t}\n}\n#endif\n\nstatic int sof_resume(struct device *dev, bool runtime_resume)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\tconst struct sof_ipc_pm_ops *pm_ops = sof_ipc_get_ops(sdev, pm);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tu32 old_state = sdev->dsp_power_state.state;\n\tint ret;\n\n\t \n\tif (!runtime_resume && !sof_ops(sdev)->resume)\n\t\treturn 0;\n\n\tif (runtime_resume && !sof_ops(sdev)->runtime_resume)\n\t\treturn 0;\n\n\t \n\tif (sdev->first_boot)\n\t\treturn 0;\n\n\t \n\tif (runtime_resume)\n\t\tret = snd_sof_dsp_runtime_resume(sdev);\n\telse\n\t\tret = snd_sof_dsp_resume(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to power up DSP after resume\\n\");\n\t\treturn ret;\n\t}\n\n\tif (sdev->dspless_mode_selected) {\n\t\tsof_set_fw_state(sdev, SOF_DSPLESS_MODE);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!runtime_resume && sof_ops(sdev)->set_power_state &&\n\t    old_state == SOF_DSP_PM_D0) {\n\t\tret = sof_fw_trace_resume(sdev);\n\t\tif (ret < 0)\n\t\t\t \n\t\t\tdev_warn(sdev->dev,\n\t\t\t\t \"failed to enable trace after resume %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tsof_set_fw_state(sdev, SOF_FW_BOOT_PREPARE);\n\n\t \n\tret = snd_sof_load_firmware(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to load DSP firmware after resume %d\\n\",\n\t\t\tret);\n\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_FAILED);\n\t\treturn ret;\n\t}\n\n\tsof_set_fw_state(sdev, SOF_FW_BOOT_IN_PROGRESS);\n\n\t \n\tret = snd_sof_run_firmware(sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to boot DSP firmware after resume %d\\n\",\n\t\t\tret);\n\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_FAILED);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sof_fw_trace_resume(sdev);\n\tif (ret < 0) {\n\t\t \n\t\tdev_warn(sdev->dev,\n\t\t\t \"warning: failed to init trace after resume %d\\n\",\n\t\t\t ret);\n\t}\n\n\t \n\tif (tplg_ops && tplg_ops->set_up_all_pipelines) {\n\t\tret = tplg_ops->set_up_all_pipelines(sdev, false);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Failed to restore pipeline after resume %d\\n\", ret);\n\t\t\tgoto setup_fail;\n\t\t}\n\t}\n\n\t \n\tsof_resume_clients(sdev);\n\n\t \n\tif (pm_ops && pm_ops->ctx_restore) {\n\t\tret = pm_ops->ctx_restore(sdev);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"ctx_restore IPC error during resume: %d\\n\", ret);\n\t}\n\nsetup_fail:\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\tif (ret < 0) {\n\t\t \n\t\tsof_cache_debugfs(sdev);\n\t}\n#endif\n\n\treturn ret;\n}\n\nstatic int sof_suspend(struct device *dev, bool runtime_suspend)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\tconst struct sof_ipc_pm_ops *pm_ops = sof_ipc_get_ops(sdev, pm);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tpm_message_t pm_state;\n\tu32 target_state = snd_sof_dsp_power_target(sdev);\n\tu32 old_state = sdev->dsp_power_state.state;\n\tint ret;\n\n\t \n\tif (!runtime_suspend && !sof_ops(sdev)->suspend)\n\t\treturn 0;\n\n\tif (runtime_suspend && !sof_ops(sdev)->runtime_suspend)\n\t\treturn 0;\n\n\t \n\tif (tplg_ops && tplg_ops->tear_down_all_pipelines && (old_state == SOF_DSP_PM_D0))\n\t\ttplg_ops->tear_down_all_pipelines(sdev, false);\n\n\tif (sdev->fw_state != SOF_FW_BOOT_COMPLETE)\n\t\tgoto suspend;\n\n\t \n\tif (!runtime_suspend) {\n\t\tret = snd_sof_dsp_hw_params_upon_resume(sdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: setting hw_params flag during suspend %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpm_state.event = target_state;\n\n\t \n\tsof_fw_trace_suspend(sdev, pm_state);\n\n\t \n\tsof_suspend_clients(sdev, pm_state);\n\n\t \n\tif (target_state == SOF_DSP_PM_D0)\n\t\tgoto suspend;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t \n\tif (runtime_suspend)\n\t\tsof_cache_debugfs(sdev);\n#endif\n\t \n\tif (pm_ops && pm_ops->ctx_save) {\n\t\tret = pm_ops->ctx_save(sdev);\n\t\tif (ret == -EBUSY || ret == -EAGAIN) {\n\t\t\t \n\t\t\tdev_err(sdev->dev, \"ctx_save IPC error during suspend: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\t \n\t\t\tdev_warn(sdev->dev, \"ctx_save IPC error: %d, proceeding with suspend\\n\",\n\t\t\t\t ret);\n\t\t}\n\t}\n\nsuspend:\n\n\t \n\tif (sdev->fw_state == SOF_FW_BOOT_NOT_STARTED)\n\t\treturn 0;\n\n\t \n\tif (runtime_suspend)\n\t\tret = snd_sof_dsp_runtime_suspend(sdev);\n\telse\n\t\tret = snd_sof_dsp_suspend(sdev, target_state);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev,\n\t\t\t\"error: failed to power down DSP during suspend %d\\n\",\n\t\t\tret);\n\n\t \n\tif (target_state == SOF_DSP_PM_D0)\n\t\treturn ret;\n\n\t \n\tsof_set_fw_state(sdev, SOF_FW_BOOT_NOT_STARTED);\n\tsdev->enabled_cores_mask = 0;\n\n\treturn ret;\n}\n\nint snd_sof_dsp_power_down_notify(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_ipc_pm_ops *pm_ops = sof_ipc_get_ops(sdev, pm);\n\n\t \n\tif (sof_ops(sdev)->remove && pm_ops && pm_ops->ctx_save)\n\t\treturn pm_ops->ctx_save(sdev);\n\n\treturn 0;\n}\n\nint snd_sof_runtime_suspend(struct device *dev)\n{\n\treturn sof_suspend(dev, true);\n}\nEXPORT_SYMBOL(snd_sof_runtime_suspend);\n\nint snd_sof_runtime_idle(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\n\treturn snd_sof_dsp_runtime_idle(sdev);\n}\nEXPORT_SYMBOL(snd_sof_runtime_idle);\n\nint snd_sof_runtime_resume(struct device *dev)\n{\n\treturn sof_resume(dev, true);\n}\nEXPORT_SYMBOL(snd_sof_runtime_resume);\n\nint snd_sof_resume(struct device *dev)\n{\n\treturn sof_resume(dev, false);\n}\nEXPORT_SYMBOL(snd_sof_resume);\n\nint snd_sof_suspend(struct device *dev)\n{\n\treturn sof_suspend(dev, false);\n}\nEXPORT_SYMBOL(snd_sof_suspend);\n\nint snd_sof_prepare(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\tconst struct sof_dev_desc *desc = sdev->pdata->desc;\n\n\t \n\tsdev->system_suspend_target = SOF_SUSPEND_S3;\n\n\t \n\tif (sdev->fw_state == SOF_FW_CRASHED ||\n\t    sdev->fw_state == SOF_FW_BOOT_FAILED)\n\t\treturn 0;\n\n\tif (!desc->use_acpi_target_states)\n\t\treturn 0;\n\n#if defined(CONFIG_ACPI)\n\tswitch (acpi_target_system_state()) {\n\tcase ACPI_STATE_S0:\n\t\tsdev->system_suspend_target = SOF_SUSPEND_S0IX;\n\t\tbreak;\n\tcase ACPI_STATE_S1:\n\tcase ACPI_STATE_S2:\n\tcase ACPI_STATE_S3:\n\t\tsdev->system_suspend_target = SOF_SUSPEND_S3;\n\t\tbreak;\n\tcase ACPI_STATE_S4:\n\t\tsdev->system_suspend_target = SOF_SUSPEND_S4;\n\t\tbreak;\n\tcase ACPI_STATE_S5:\n\t\tsdev->system_suspend_target = SOF_SUSPEND_S5;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL(snd_sof_prepare);\n\nvoid snd_sof_complete(struct device *dev)\n{\n\tstruct snd_sof_dev *sdev = dev_get_drvdata(dev);\n\n\tsdev->system_suspend_target = SOF_SUSPEND_NONE;\n}\nEXPORT_SYMBOL(snd_sof_complete);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}