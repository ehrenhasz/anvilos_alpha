{
  "module_name": "ipc4-loader.c",
  "hash_id": "c9c81e42c0e946a35404e5901258adef99a87aee46f9d9ef0c99884c80a4c0ab",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc4-loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/firmware.h>\n#include <sound/sof/ext_manifest4.h>\n#include <sound/sof/ipc4/header.h>\n#include <trace/events/sof.h>\n#include \"ipc4-priv.h\"\n#include \"sof-audio.h\"\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\n \n#define SOF_IPC4_MOD_LIB_ID_SHIFT\t12\n\nstatic ssize_t sof_ipc4_fw_parse_ext_man(struct snd_sof_dev *sdev,\n\t\t\t\t\t struct sof_ipc4_fw_library *fw_lib)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tconst struct firmware *fw = fw_lib->sof_fw.fw;\n\tstruct sof_man4_fw_binary_header *fw_header;\n\tstruct sof_ext_manifest4_hdr *ext_man_hdr;\n\tstruct sof_man4_module_config *fm_config;\n\tstruct sof_ipc4_fw_module *fw_module;\n\tstruct sof_man4_module *fm_entry;\n\tssize_t remaining;\n\tu32 fw_hdr_offset;\n\tint i;\n\n\tif (!ipc4_data) {\n\t\tdev_err(sdev->dev, \"%s: ipc4_data is not available\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tremaining = fw->size;\n\tif (remaining <= sizeof(*ext_man_hdr)) {\n\t\tdev_err(sdev->dev, \"Firmware size is too small: %zu\\n\", remaining);\n\t\treturn -EINVAL;\n\t}\n\n\text_man_hdr = (struct sof_ext_manifest4_hdr *)fw->data;\n\n\t \n\tif (ext_man_hdr->id != SOF_EXT_MAN4_MAGIC_NUMBER) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Unexpected extended manifest magic number: %#x\\n\",\n\t\t\text_man_hdr->id);\n\t\treturn -EINVAL;\n\t}\n\n\tfw_hdr_offset = ipc4_data->manifest_fw_hdr_offset;\n\tif (!fw_hdr_offset)\n\t\treturn -EINVAL;\n\n\tif (remaining <= ext_man_hdr->len + fw_hdr_offset + sizeof(*fw_header)) {\n\t\tdev_err(sdev->dev, \"Invalid firmware size %zu, should be at least %zu\\n\",\n\t\t\tremaining, ext_man_hdr->len + fw_hdr_offset + sizeof(*fw_header));\n\t\treturn -EINVAL;\n\t}\n\n\tfw_header = (struct sof_man4_fw_binary_header *)\n\t\t\t\t(fw->data + ext_man_hdr->len + fw_hdr_offset);\n\tremaining -= (ext_man_hdr->len + fw_hdr_offset);\n\n\tif (remaining <= fw_header->len) {\n\t\tdev_err(sdev->dev, \"Invalid fw_header->len %u\\n\", fw_header->len);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(sdev->dev, \"Loaded firmware library: %s, version: %u.%u.%u.%u\\n\",\n\t\t fw_header->name, fw_header->major_version, fw_header->minor_version,\n\t\t fw_header->hotfix_version, fw_header->build_version);\n\tdev_dbg(sdev->dev, \"Header length: %u, module count: %u\\n\",\n\t\tfw_header->len, fw_header->num_module_entries);\n\n\tfw_lib->modules = devm_kmalloc_array(sdev->dev, fw_header->num_module_entries,\n\t\t\t\t\t     sizeof(*fw_module), GFP_KERNEL);\n\tif (!fw_lib->modules)\n\t\treturn -ENOMEM;\n\n\tfw_lib->name = fw_header->name;\n\tfw_lib->num_modules = fw_header->num_module_entries;\n\tfw_module = fw_lib->modules;\n\n\tfm_entry = (struct sof_man4_module *)((u8 *)fw_header + fw_header->len);\n\tremaining -= fw_header->len;\n\n\tif (remaining < fw_header->num_module_entries * sizeof(*fm_entry)) {\n\t\tdev_err(sdev->dev, \"Invalid num_module_entries %u\\n\",\n\t\t\tfw_header->num_module_entries);\n\t\treturn -EINVAL;\n\t}\n\n\tfm_config = (struct sof_man4_module_config *)\n\t\t\t\t(fm_entry + fw_header->num_module_entries);\n\tremaining -= (fw_header->num_module_entries * sizeof(*fm_entry));\n\tfor (i = 0; i < fw_header->num_module_entries; i++) {\n\t\tmemcpy(&fw_module->man4_module_entry, fm_entry, sizeof(*fm_entry));\n\n\t\tif (fm_entry->cfg_count) {\n\t\t\tif (remaining < (fm_entry->cfg_offset + fm_entry->cfg_count) *\n\t\t\t    sizeof(*fm_config)) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid module cfg_offset %u\\n\",\n\t\t\t\t\tfm_entry->cfg_offset);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tfw_module->fw_mod_cfg = &fm_config[fm_entry->cfg_offset];\n\n\t\t\tdev_dbg(sdev->dev,\n\t\t\t\t\"module %s: UUID %pUL cfg_count: %u, bss_size: %#x\\n\",\n\t\t\t\tfm_entry->name, &fm_entry->uuid, fm_entry->cfg_count,\n\t\t\t\tfm_config[fm_entry->cfg_offset].is_bytes);\n\t\t} else {\n\t\t\tdev_dbg(sdev->dev, \"module %s: UUID %pUL\\n\", fm_entry->name,\n\t\t\t\t&fm_entry->uuid);\n\t\t}\n\n\t\tfw_module->man4_module_entry.id = i;\n\t\tida_init(&fw_module->m_ida);\n\t\tfw_module->private = NULL;\n\n\t\tfw_module++;\n\t\tfm_entry++;\n\t}\n\n\treturn ext_man_hdr->len;\n}\n\nstatic size_t sof_ipc4_fw_parse_basefw_ext_man(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_fw_library *fw_lib;\n\tssize_t payload_offset;\n\tint ret;\n\n\tfw_lib = devm_kzalloc(sdev->dev, sizeof(*fw_lib), GFP_KERNEL);\n\tif (!fw_lib)\n\t\treturn -ENOMEM;\n\n\tfw_lib->sof_fw.fw = sdev->basefw.fw;\n\n\tpayload_offset = sof_ipc4_fw_parse_ext_man(sdev, fw_lib);\n\tif (payload_offset > 0) {\n\t\tfw_lib->sof_fw.payload_offset = payload_offset;\n\n\t\t \n\t\tfw_lib->id = 0;\n\t\tret = xa_insert(&ipc4_data->fw_lib_xa, 0, fw_lib, GFP_KERNEL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn payload_offset;\n}\n\nstatic int sof_ipc4_load_library_by_uuid(struct snd_sof_dev *sdev,\n\t\t\t\t\t unsigned long lib_id, const guid_t *uuid)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_fw_library *fw_lib;\n\tconst char *fw_filename;\n\tssize_t payload_offset;\n\tint ret, i, err;\n\n\tif (!sdev->pdata->fw_lib_prefix) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Library loading is not supported due to not set library path\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ipc4_data->load_library) {\n\t\tdev_err(sdev->dev, \"Library loading is not supported on this platform\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfw_lib = devm_kzalloc(sdev->dev, sizeof(*fw_lib), GFP_KERNEL);\n\tif (!fw_lib)\n\t\treturn -ENOMEM;\n\n\tfw_filename = kasprintf(GFP_KERNEL, \"%s/%pUL.bin\",\n\t\t\t\tsdev->pdata->fw_lib_prefix, uuid);\n\tif (!fw_filename) {\n\t\tret = -ENOMEM;\n\t\tgoto free_fw_lib;\n\t}\n\n\tret = request_firmware(&fw_lib->sof_fw.fw, fw_filename, sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"Library file '%s' is missing\\n\", fw_filename);\n\t\tgoto free_filename;\n\t} else {\n\t\tdev_dbg(sdev->dev, \"Library file '%s' loaded\\n\", fw_filename);\n\t}\n\n\tpayload_offset = sof_ipc4_fw_parse_ext_man(sdev, fw_lib);\n\tif (payload_offset <= 0) {\n\t\tif (!payload_offset)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = payload_offset;\n\n\t\tgoto release;\n\t}\n\n\tfw_lib->sof_fw.payload_offset = payload_offset;\n\tfw_lib->id = lib_id;\n\n\t \n\tfor (i = 0; i < fw_lib->num_modules; i++)\n\t\tfw_lib->modules[i].man4_module_entry.id |= (lib_id << SOF_IPC4_MOD_LIB_ID_SHIFT);\n\n\t \n\tret = pm_runtime_resume_and_get(sdev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(sdev->dev, \"%s: pm_runtime resume failed: %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tgoto release;\n\t}\n\n\tret = ipc4_data->load_library(sdev, fw_lib, false);\n\n\tpm_runtime_mark_last_busy(sdev->dev);\n\terr = pm_runtime_put_autosuspend(sdev->dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(sdev->dev, \"%s: pm_runtime idle failed: %d\\n\",\n\t\t\t\t    __func__, err);\n\n\tif (ret)\n\t\tgoto release;\n\n\tret = xa_insert(&ipc4_data->fw_lib_xa, lib_id, fw_lib, GFP_KERNEL);\n\tif (unlikely(ret))\n\t\tgoto release;\n\n\tkfree(fw_filename);\n\n\treturn 0;\n\nrelease:\n\trelease_firmware(fw_lib->sof_fw.fw);\n\t \n\tdevm_kfree(sdev->dev, fw_lib->modules);\nfree_filename:\n\tkfree(fw_filename);\nfree_fw_lib:\n\tdevm_kfree(sdev->dev, fw_lib);\n\n\treturn ret;\n}\n\nstruct sof_ipc4_fw_module *sof_ipc4_find_module_by_uuid(struct snd_sof_dev *sdev,\n\t\t\t\t\t\t\tconst guid_t *uuid)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_fw_library *fw_lib;\n\tunsigned long lib_id;\n\tint i, ret;\n\n\tif (guid_is_null(uuid))\n\t\treturn NULL;\n\n\txa_for_each(&ipc4_data->fw_lib_xa, lib_id, fw_lib) {\n\t\tfor (i = 0; i < fw_lib->num_modules; i++) {\n\t\t\tif (guid_equal(uuid, &fw_lib->modules[i].man4_module_entry.uuid))\n\t\t\t\treturn &fw_lib->modules[i];\n\t\t}\n\t}\n\n\t \n\tif ((lib_id + 1) == ipc4_data->max_libs_count) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"%s: Maximum allowed number of libraries reached (%u)\\n\",\n\t\t\t__func__, ipc4_data->max_libs_count);\n\t\treturn NULL;\n\t}\n\n\t \n\tret = sof_ipc4_load_library_by_uuid(sdev, lib_id + 1, uuid);\n\tif (ret)\n\t\treturn NULL;\n\n\t \n\txa_for_each_start(&ipc4_data->fw_lib_xa, lib_id, fw_lib, lib_id) {\n\t\tfor (i = 0; i < fw_lib->num_modules; i++) {\n\t\t\tif (guid_equal(uuid, &fw_lib->modules[i].man4_module_entry.uuid))\n\t\t\t\treturn &fw_lib->modules[i];\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int sof_ipc4_validate_firmware(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tu32 fw_hdr_offset = ipc4_data->manifest_fw_hdr_offset;\n\tstruct sof_man4_fw_binary_header *fw_header;\n\tconst struct firmware *fw = sdev->basefw.fw;\n\tstruct sof_ext_manifest4_hdr *ext_man_hdr;\n\n\text_man_hdr = (struct sof_ext_manifest4_hdr *)fw->data;\n\tfw_header = (struct sof_man4_fw_binary_header *)\n\t\t\t\t(fw->data + ext_man_hdr->len + fw_hdr_offset);\n\n\t \n\n\tdev_dbg(sdev->dev, \"Validated firmware version: %u.%u.%u.%u\\n\",\n\t\tfw_header->major_version, fw_header->minor_version,\n\t\tfw_header->hotfix_version, fw_header->build_version);\n\n\treturn 0;\n}\n\nint sof_ipc4_query_fw_configuration(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tstruct sof_ipc4_fw_version *fw_ver;\n\tstruct sof_ipc4_tuple *tuple;\n\tstruct sof_ipc4_msg msg;\n\tsize_t offset = 0;\n\tint ret;\n\n\t \n\tmsg.primary = SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MOD_ID(SOF_IPC4_MOD_INIT_BASEFW_MOD_ID);\n\tmsg.primary |= SOF_IPC4_MOD_INSTANCE(SOF_IPC4_MOD_INIT_BASEFW_INSTANCE_ID);\n\tmsg.extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_FW_PARAM_FW_CONFIG);\n\n\tmsg.data_size = sdev->ipc->max_payload_size;\n\tmsg.data_ptr = kzalloc(msg.data_size, GFP_KERNEL);\n\tif (!msg.data_ptr)\n\t\treturn -ENOMEM;\n\n\tret = iops->set_get_data(sdev, &msg, msg.data_size, false);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (offset < msg.data_size) {\n\t\ttuple = (struct sof_ipc4_tuple *)((u8 *)msg.data_ptr + offset);\n\n\t\tswitch (tuple->type) {\n\t\tcase SOF_IPC4_FW_CFG_FW_VERSION:\n\t\t\tfw_ver = (struct sof_ipc4_fw_version *)tuple->value;\n\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Booted firmware version: %u.%u.%u.%u\\n\",\n\t\t\t\t fw_ver->major, fw_ver->minor, fw_ver->hotfix,\n\t\t\t\t fw_ver->build);\n\t\t\tbreak;\n\t\tcase SOF_IPC4_FW_CFG_DL_MAILBOX_BYTES:\n\t\t\ttrace_sof_ipc4_fw_config(sdev, \"DL mailbox size\", *tuple->value);\n\t\t\tbreak;\n\t\tcase SOF_IPC4_FW_CFG_UL_MAILBOX_BYTES:\n\t\t\ttrace_sof_ipc4_fw_config(sdev, \"UL mailbox size\", *tuple->value);\n\t\t\tbreak;\n\t\tcase SOF_IPC4_FW_CFG_TRACE_LOG_BYTES:\n\t\t\ttrace_sof_ipc4_fw_config(sdev, \"Trace log size\", *tuple->value);\n\t\t\tipc4_data->mtrace_log_bytes = *tuple->value;\n\t\t\tbreak;\n\t\tcase SOF_IPC4_FW_CFG_MAX_LIBS_COUNT:\n\t\t\ttrace_sof_ipc4_fw_config(sdev, \"maximum number of libraries\",\n\t\t\t\t\t\t *tuple->value);\n\t\t\tipc4_data->max_libs_count = *tuple->value;\n\t\t\tif (!ipc4_data->max_libs_count)\n\t\t\t\tipc4_data->max_libs_count = 1;\n\t\t\tbreak;\n\t\tcase SOF_IPC4_FW_CFG_MAX_PPL_COUNT:\n\t\t\tipc4_data->max_num_pipelines = *tuple->value;\n\t\t\ttrace_sof_ipc4_fw_config(sdev, \"Max PPL count %d\",\n\t\t\t\t\t\t ipc4_data->max_num_pipelines);\n\t\t\tif (ipc4_data->max_num_pipelines <= 0) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid max_num_pipelines %d\",\n\t\t\t\t\tipc4_data->max_num_pipelines);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += sizeof(*tuple) + tuple->size;\n\t}\n\nout:\n\tkfree(msg.data_ptr);\n\n\treturn ret;\n}\n\nint sof_ipc4_reload_fw_libraries(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_fw_library *fw_lib;\n\tunsigned long lib_id;\n\tint ret = 0;\n\n\txa_for_each_start(&ipc4_data->fw_lib_xa, lib_id, fw_lib, 1) {\n\t\tret = ipc4_data->load_library(sdev, fw_lib, true);\n\t\tif (ret) {\n\t\t\tdev_err(sdev->dev, \"%s: Failed to reload library: %s, %d\\n\",\n\t\t\t\t__func__, fw_lib->name, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nvoid sof_ipc4_update_cpc_from_manifest(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc4_fw_module *fw_module,\n\t\t\t\t       struct sof_ipc4_base_module_cfg *basecfg)\n{\n\tconst struct sof_man4_module_config *fw_mod_cfg;\n\tu32 cpc_pick = 0;\n\tu32 max_cpc = 0;\n\tconst char *msg;\n\tint i;\n\n\tif (!fw_module->fw_mod_cfg) {\n\t\tmsg = \"No mod_cfg available for CPC lookup in the firmware file's manifest\";\n\t\tgoto no_cpc;\n\t}\n\n\t \n\tfw_mod_cfg = fw_module->fw_mod_cfg;\n\tfor (i = 0; i < fw_module->man4_module_entry.cfg_count; i++) {\n\t\tif (basecfg->obs == fw_mod_cfg[i].obs &&\n\t\t    basecfg->ibs == fw_mod_cfg[i].ibs &&\n\t\t    cpc_pick < fw_mod_cfg[i].cpc)\n\t\t\tcpc_pick = fw_mod_cfg[i].cpc;\n\n\t\tif (max_cpc < fw_mod_cfg[i].cpc)\n\t\t\tmax_cpc = fw_mod_cfg[i].cpc;\n\t}\n\n\tbasecfg->cpc = cpc_pick;\n\n\t \n\tif (basecfg->cpc)\n\t\treturn;\n\n\t \n\tif (!max_cpc)\n\t\tmsg = \"No CPC value available in the firmware file's manifest\";\n\telse if (!cpc_pick)\n\t\tmsg = \"No CPC match in the firmware file's manifest\";\n\nno_cpc:\n\tdev_dbg(sdev->dev, \"%s (UUID: %pUL): %s (ibs/obs: %u/%u)\\n\",\n\t\tfw_module->man4_module_entry.name,\n\t\t&fw_module->man4_module_entry.uuid, msg, basecfg->ibs,\n\t\tbasecfg->obs);\n}\n\nconst struct sof_ipc_fw_loader_ops ipc4_loader_ops = {\n\t.validate = sof_ipc4_validate_firmware,\n\t.parse_ext_manifest = sof_ipc4_fw_parse_basefw_ext_man,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}