{
  "module_name": "ipc3-pcm.c",
  "hash_id": "cd24668a7f1fe9f17dda7f92da01f7f9de078c6416e6cfdfa463682acdb53a19",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <sound/pcm_params.h>\n#include \"ipc3-priv.h\"\n#include \"ops.h\"\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n\nstatic int sof_ipc3_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sof_ipc_stream stream;\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tif (!spcm->prepared[substream->stream])\n\t\treturn 0;\n\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_FREE;\n\tstream.comp_id = spcm->stream[substream->stream].comp_id;\n\n\t \n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &stream, sizeof(stream));\n}\n\nstatic int sof_ipc3_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_sof_platform_stream_params *platform_params)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sof_ipc_fw_version *v = &sdev->fw_ready.version;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct sof_ipc_pcm_params_reply ipc_params_reply;\n\tstruct sof_ipc_pcm_params pcm;\n\tstruct snd_sof_pcm *spcm;\n\tint ret;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tmemset(&pcm, 0, sizeof(pcm));\n\n\t \n\tpcm.params.buffer.pages = PFN_UP(runtime->dma_bytes);\n\n\t \n\tpcm.hdr.size = sizeof(pcm);\n\tpcm.hdr.cmd = SOF_IPC_GLB_STREAM_MSG | SOF_IPC_STREAM_PCM_PARAMS;\n\tpcm.comp_id = spcm->stream[substream->stream].comp_id;\n\tpcm.params.hdr.size = sizeof(pcm.params);\n\tpcm.params.buffer.phy_addr = spcm->stream[substream->stream].page_table.addr;\n\tpcm.params.buffer.size = runtime->dma_bytes;\n\tpcm.params.direction = substream->stream;\n\tpcm.params.sample_valid_bytes = params_width(params) >> 3;\n\tpcm.params.buffer_fmt = SOF_IPC_BUFFER_INTERLEAVED;\n\tpcm.params.rate = params_rate(params);\n\tpcm.params.channels = params_channels(params);\n\tpcm.params.host_period_bytes = params_period_bytes(params);\n\n\t \n\tret = snd_pcm_format_physical_width(params_format(params));\n\tif (ret < 0)\n\t\treturn ret;\n\tpcm.params.sample_container_bytes = ret >> 3;\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S16_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S24_4LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_S32_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_FLOAT:\n\t\tpcm.params.frame_fmt = SOF_IPC_FRAME_FLOAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpcm.params.stream_tag = platform_params->stream_tag;\n\n\tif (platform_params->use_phy_address)\n\t\tpcm.params.buffer.phy_addr = platform_params->phy_addr;\n\n\tif (platform_params->no_ipc_position) {\n\t\t \n\t\tif (v->abi_version < SOF_ABI_VER(3, 10, 0))\n\t\t\tpcm.params.host_period_bytes = 0;\n\t\telse\n\t\t\tpcm.params.no_stream_position = 1;\n\t}\n\n\tif (platform_params->cont_update_posn)\n\t\tpcm.params.cont_update_posn = 1;\n\n\tdev_dbg(component->dev, \"stream_tag %d\", pcm.params.stream_tag);\n\n\t \n\tret = sof_ipc_tx_message(sdev->ipc, &pcm, sizeof(pcm),\n\t\t\t\t &ipc_params_reply, sizeof(ipc_params_reply));\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"HW params ipc failed for stream %d\\n\",\n\t\t\tpcm.params.stream_tag);\n\t\treturn ret;\n\t}\n\n\tret = snd_sof_set_stream_data_offset(sdev, &spcm->stream[substream->stream],\n\t\t\t\t\t     ipc_params_reply.posn_offset);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"%s: invalid stream data offset for PCM %d\\n\",\n\t\t\t__func__, spcm->pcm.pcm_id);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct sof_ipc_stream stream;\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tstream.hdr.size = sizeof(stream);\n\tstream.hdr.cmd = SOF_IPC_GLB_STREAM_MSG;\n\tstream.comp_id = spcm->stream[substream->stream].comp_id;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_PAUSE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_RELEASE;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_START;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstream.hdr.cmd |= SOF_IPC_STREAM_TRIG_STOP;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unhandled trigger cmd %d\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &stream, sizeof(stream));\n}\n\nstatic void ssp_dai_config_pcm_params_match(struct snd_sof_dev *sdev, const char *link_name,\n\t\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct sof_ipc_dai_config *config;\n\tstruct snd_sof_dai *dai;\n\tint i;\n\n\t \n\tlist_for_each_entry(dai, &sdev->dai_list, list) {\n\t\tif (!dai->name || strcmp(link_name, dai->name))\n\t\t\tcontinue;\n\t\tfor (i = 0; i < dai->number_configs; i++) {\n\t\t\tstruct sof_dai_private_data *private = dai->private;\n\n\t\t\tconfig = &private->dai_config[i];\n\t\t\tif (config->ssp.fsync_rate == params_rate(params)) {\n\t\t\t\tdev_dbg(sdev->dev, \"DAI config %d matches pcm hw params\\n\", i);\n\t\t\t\tdai->current_config = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int sof_ipc3_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_component *component = snd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\tstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct snd_sof_dai *dai = snd_sof_find_dai(component, (char *)rtd->dai_link->name);\n\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct sof_dai_private_data *private;\n\tstruct snd_soc_dpcm *dpcm;\n\n\tif (!dai) {\n\t\tdev_err(component->dev, \"%s: No DAI found with name %s\\n\", __func__,\n\t\t\trtd->dai_link->name);\n\t\treturn -EINVAL;\n\t}\n\n\tprivate = dai->private;\n\tif (!private) {\n\t\tdev_err(component->dev, \"%s: No private data found for DAI %s\\n\", __func__,\n\t\t\trtd->dai_link->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_mask_none(fmt);\n\n\tswitch (private->comp_dai->config.frame_fmt) {\n\tcase SOF_IPC_FRAME_S16_LE:\n\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);\n\t\tbreak;\n\tcase SOF_IPC_FRAME_S24_4LE:\n\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S24_LE);\n\t\tbreak;\n\tcase SOF_IPC_FRAME_S32_LE:\n\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S32_LE);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"No available DAI format!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (private->dai_config->type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\t \n\t\tssp_dai_config_pcm_params_match(sdev, (char *)rtd->dai_link->name, params);\n\n\t\trate->min = private->dai_config[dai->current_config].ssp.fsync_rate;\n\t\trate->max = private->dai_config[dai->current_config].ssp.fsync_rate;\n\t\tchannels->min = private->dai_config[dai->current_config].ssp.tdm_slots;\n\t\tchannels->max = private->dai_config[dai->current_config].ssp.tdm_slots;\n\n\t\tdev_dbg(component->dev, \"rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\n\t\tbreak;\n\tcase SOF_DAI_INTEL_DMIC:\n\t\t \n\t\tif (private->comp_dai->config.frame_fmt == SOF_IPC_FRAME_S24_4LE) {\n\t\t\tdev_err(component->dev, \"Invalid fmt %d for DAI type %d\\n\",\n\t\t\t\tprivate->comp_dai->config.frame_fmt,\n\t\t\t\tprivate->dai_config->type);\n\t\t}\n\t\tbreak;\n\tcase SOF_DAI_INTEL_HDA:\n\t\t \n\t\tfor_each_dpcm_fe(rtd, SNDRV_PCM_STREAM_PLAYBACK, dpcm) {\n\t\t\tstruct snd_soc_pcm_runtime *fe = dpcm->fe;\n\n\t\t\tfe->dai_link->trigger[SNDRV_PCM_STREAM_PLAYBACK] =\n\t\t\t\tSND_SOC_DPCM_TRIGGER_POST;\n\t\t}\n\t\tbreak;\n\tcase SOF_DAI_INTEL_ALH:\n\t\t \n\t\tchannels->min = private->dai_config->alh.channels;\n\t\tchannels->max = private->dai_config->alh.channels;\n\t\tbreak;\n\tcase SOF_DAI_IMX_ESAI:\n\t\trate->min = private->dai_config->esai.fsync_rate;\n\t\trate->max = private->dai_config->esai.fsync_rate;\n\t\tchannels->min = private->dai_config->esai.tdm_slots;\n\t\tchannels->max = private->dai_config->esai.tdm_slots;\n\n\t\tdev_dbg(component->dev, \"rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tcase SOF_DAI_MEDIATEK_AFE:\n\t\trate->min = private->dai_config->afe.rate;\n\t\trate->max = private->dai_config->afe.rate;\n\t\tchannels->min = private->dai_config->afe.channels;\n\t\tchannels->max = private->dai_config->afe.channels;\n\n\t\tsnd_mask_none(fmt);\n\n\t\tswitch (private->dai_config->afe.format) {\n\t\tcase SOF_IPC_FRAME_S16_LE:\n\t\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S16_LE);\n\t\t\tbreak;\n\t\tcase SOF_IPC_FRAME_S24_4LE:\n\t\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S24_LE);\n\t\t\tbreak;\n\t\tcase SOF_IPC_FRAME_S32_LE:\n\t\t\tsnd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S32_LE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Not available format!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tcase SOF_DAI_IMX_SAI:\n\t\trate->min = private->dai_config->sai.fsync_rate;\n\t\trate->max = private->dai_config->sai.fsync_rate;\n\t\tchannels->min = private->dai_config->sai.tdm_slots;\n\t\tchannels->max = private->dai_config->sai.tdm_slots;\n\n\t\tdev_dbg(component->dev, \"rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tcase SOF_DAI_AMD_BT:\n\t\trate->min = private->dai_config->acpbt.fsync_rate;\n\t\trate->max = private->dai_config->acpbt.fsync_rate;\n\t\tchannels->min = private->dai_config->acpbt.tdm_slots;\n\t\tchannels->max = private->dai_config->acpbt.tdm_slots;\n\n\t\tdev_dbg(component->dev,\n\t\t\t\"AMD_BT rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"AMD_BT channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tcase SOF_DAI_AMD_SP:\n\tcase SOF_DAI_AMD_SP_VIRTUAL:\n\t\trate->min = private->dai_config->acpsp.fsync_rate;\n\t\trate->max = private->dai_config->acpsp.fsync_rate;\n\t\tchannels->min = private->dai_config->acpsp.tdm_slots;\n\t\tchannels->max = private->dai_config->acpsp.tdm_slots;\n\n\t\tdev_dbg(component->dev,\n\t\t\t\"AMD_SP rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"AMD_SP channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tcase SOF_DAI_AMD_HS:\n\tcase SOF_DAI_AMD_HS_VIRTUAL:\n\t\trate->min = private->dai_config->acphs.fsync_rate;\n\t\trate->max = private->dai_config->acphs.fsync_rate;\n\t\tchannels->min = private->dai_config->acphs.tdm_slots;\n\t\tchannels->max = private->dai_config->acphs.tdm_slots;\n\n\t\tdev_dbg(component->dev,\n\t\t\t\"AMD_HS channel_max: %d rate_max: %d\\n\", channels->max, rate->max);\n\t\tbreak;\n\tcase SOF_DAI_AMD_DMIC:\n\t\trate->min = private->dai_config->acpdmic.pdm_rate;\n\t\trate->max = private->dai_config->acpdmic.pdm_rate;\n\t\tchannels->min = private->dai_config->acpdmic.pdm_ch;\n\t\tchannels->max = private->dai_config->acpdmic.pdm_ch;\n\n\t\tdev_dbg(component->dev,\n\t\t\t\"AMD_DMIC rate_min: %d rate_max: %d\\n\", rate->min, rate->max);\n\t\tdev_dbg(component->dev, \"AMD_DMIC channels_min: %d channels_max: %d\\n\",\n\t\t\tchannels->min, channels->max);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI type %d\\n\", private->dai_config->type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nconst struct sof_ipc_pcm_ops ipc3_pcm_ops = {\n\t.hw_params = sof_ipc3_pcm_hw_params,\n\t.hw_free = sof_ipc3_pcm_hw_free,\n\t.trigger = sof_ipc3_pcm_trigger,\n\t.dai_link_fixup = sof_ipc3_pcm_dai_link_fixup,\n\t.reset_hw_params_during_stop = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}