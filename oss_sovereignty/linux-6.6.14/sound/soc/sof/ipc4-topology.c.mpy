{
  "module_name": "ipc4-topology.c",
  "hash_id": "e2afe635c4f20451ba52a073cfd4ae46a335913f95f410ad703d263705355f85",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc4-topology.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <uapi/sound/sof/tokens.h>\n#include <sound/pcm_params.h>\n#include <sound/sof/ext_manifest4.h>\n#include <sound/intel-nhlt.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc4-priv.h\"\n#include \"ipc4-topology.h\"\n#include \"ops.h\"\n\n \nstatic bool ignore_cpc;\nmodule_param_named(ipc4_ignore_cpc, ignore_cpc, bool, 0444);\nMODULE_PARM_DESC(ipc4_ignore_cpc,\n\t\t \"Ignore CPC values. This option will disable clock scaling in firmware.\");\n\n#define SOF_IPC4_GAIN_PARAM_ID  0\n#define SOF_IPC4_TPLG_ABI_SIZE 6\n#define SOF_IPC4_CHAIN_DMA_BUF_SIZE_MS 2\n\nstatic DEFINE_IDA(alh_group_ida);\nstatic DEFINE_IDA(pipeline_ida);\n\nstatic const struct sof_topology_token ipc4_sched_tokens[] = {\n\t{SOF_TKN_SCHED_LP_MODE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pipeline, lp_mode)},\n\t{SOF_TKN_SCHED_USE_CHAIN_DMA, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct sof_ipc4_pipeline, use_chain_dma)},\n\t{SOF_TKN_SCHED_CORE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pipeline, core_id)},\n};\n\nstatic const struct sof_topology_token pipeline_tokens[] = {\n\t{SOF_TKN_SCHED_DYNAMIC_PIPELINE, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct snd_sof_widget, dynamic_pipeline_widget)},\n};\n\nstatic const struct sof_topology_token ipc4_comp_tokens[] = {\n\t{SOF_TKN_COMP_IS_PAGES, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_base_module_cfg, is_pages)},\n};\n\nstatic const struct sof_topology_token ipc4_in_audio_format_tokens[] = {\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.sampling_frequency)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_BIT_DEPTH, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.bit_depth)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_CH_MAP, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.ch_map)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_CH_CFG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.ch_cfg)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_INTERLEAVING_STYLE, SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\tget_token_u32, offsetof(struct sof_ipc4_pin_format,\n\t\taudio_fmt.interleaving_style)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IN_FMT_CFG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.fmt_cfg)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_INPUT_PIN_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, pin_index)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_IBS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, buffer_size)},\n};\n\nstatic const struct sof_topology_token ipc4_out_audio_format_tokens[] = {\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_RATE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.sampling_frequency)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_BIT_DEPTH, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.bit_depth)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_CH_MAP, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.ch_map)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_CH_CFG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.ch_cfg)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_INTERLEAVING_STYLE, SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\tget_token_u32, offsetof(struct sof_ipc4_pin_format,\n\t\taudio_fmt.interleaving_style)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUT_FMT_CFG, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, audio_fmt.fmt_cfg)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OUTPUT_PIN_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, pin_index)},\n\t{SOF_TKN_CAVS_AUDIO_FORMAT_OBS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_pin_format, buffer_size)},\n};\n\nstatic const struct sof_topology_token ipc4_copier_deep_buffer_tokens[] = {\n\t{SOF_TKN_INTEL_COPIER_DEEP_BUFFER_DMA_MS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32, 0},\n};\n\nstatic const struct sof_topology_token ipc4_copier_tokens[] = {\n\t{SOF_TKN_INTEL_COPIER_NODE_TYPE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32, 0},\n};\n\nstatic const struct sof_topology_token ipc4_audio_fmt_num_tokens[] = {\n\t{SOF_TKN_COMP_NUM_INPUT_AUDIO_FORMATS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_available_audio_format, num_input_formats)},\n\t{SOF_TKN_COMP_NUM_OUTPUT_AUDIO_FORMATS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_available_audio_format, num_output_formats)},\n};\n\nstatic const struct sof_topology_token dai_tokens[] = {\n\t{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,\n\t\toffsetof(struct sof_ipc4_copier, dai_type)},\n\t{SOF_TKN_DAI_INDEX, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_copier, dai_index)},\n};\n\n \nstatic const struct sof_topology_token comp_ext_tokens[] = {\n\t{SOF_TKN_COMP_UUID, SND_SOC_TPLG_TUPLE_TYPE_UUID, get_token_uuid,\n\t\toffsetof(struct snd_sof_widget, uuid)},\n\t{SOF_TKN_COMP_CORE_ID, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct snd_sof_widget, core)},\n};\n\nstatic const struct sof_topology_token gain_tokens[] = {\n\t{SOF_TKN_GAIN_RAMP_TYPE, SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\tget_token_u32, offsetof(struct sof_ipc4_gain_params, curve_type)},\n\t{SOF_TKN_GAIN_RAMP_DURATION,\n\t\tSND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_gain_params, curve_duration_l)},\n\t{SOF_TKN_GAIN_VAL, SND_SOC_TPLG_TUPLE_TYPE_WORD,\n\t\tget_token_u32, offsetof(struct sof_ipc4_gain_params, init_val)},\n};\n\n \nstatic const struct sof_topology_token src_tokens[] = {\n\t{SOF_TKN_SRC_RATE_OUT, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct sof_ipc4_src_data, sink_rate)},\n};\n\nstatic const struct sof_token_info ipc4_token_list[SOF_TOKEN_COUNT] = {\n\t[SOF_DAI_TOKENS] = {\"DAI tokens\", dai_tokens, ARRAY_SIZE(dai_tokens)},\n\t[SOF_PIPELINE_TOKENS] = {\"Pipeline tokens\", pipeline_tokens, ARRAY_SIZE(pipeline_tokens)},\n\t[SOF_SCHED_TOKENS] = {\"Scheduler tokens\", ipc4_sched_tokens,\n\t\tARRAY_SIZE(ipc4_sched_tokens)},\n\t[SOF_COMP_EXT_TOKENS] = {\"Comp extended tokens\", comp_ext_tokens,\n\t\tARRAY_SIZE(comp_ext_tokens)},\n\t[SOF_COMP_TOKENS] = {\"IPC4 Component tokens\",\n\t\tipc4_comp_tokens, ARRAY_SIZE(ipc4_comp_tokens)},\n\t[SOF_IN_AUDIO_FORMAT_TOKENS] = {\"IPC4 Input Audio format tokens\",\n\t\tipc4_in_audio_format_tokens, ARRAY_SIZE(ipc4_in_audio_format_tokens)},\n\t[SOF_OUT_AUDIO_FORMAT_TOKENS] = {\"IPC4 Output Audio format tokens\",\n\t\tipc4_out_audio_format_tokens, ARRAY_SIZE(ipc4_out_audio_format_tokens)},\n\t[SOF_COPIER_DEEP_BUFFER_TOKENS] = {\"IPC4 Copier deep buffer tokens\",\n\t\tipc4_copier_deep_buffer_tokens, ARRAY_SIZE(ipc4_copier_deep_buffer_tokens)},\n\t[SOF_COPIER_TOKENS] = {\"IPC4 Copier tokens\", ipc4_copier_tokens,\n\t\tARRAY_SIZE(ipc4_copier_tokens)},\n\t[SOF_AUDIO_FMT_NUM_TOKENS] = {\"IPC4 Audio format number tokens\",\n\t\tipc4_audio_fmt_num_tokens, ARRAY_SIZE(ipc4_audio_fmt_num_tokens)},\n\t[SOF_GAIN_TOKENS] = {\"Gain tokens\", gain_tokens, ARRAY_SIZE(gain_tokens)},\n\t[SOF_SRC_TOKENS] = {\"SRC tokens\", src_tokens, ARRAY_SIZE(src_tokens)},\n};\n\nstatic void sof_ipc4_dbg_audio_format(struct device *dev, struct sof_ipc4_pin_format *pin_fmt,\n\t\t\t\t      int num_formats)\n{\n\tint i;\n\n\tfor (i = 0; i < num_formats; i++) {\n\t\tstruct sof_ipc4_audio_format *fmt = &pin_fmt[i].audio_fmt;\n\t\tdev_dbg(dev,\n\t\t\t\"Pin index #%d: %uHz, %ubit (ch_map %#x ch_cfg %u interleaving_style %u fmt_cfg %#x) buffer size %d\\n\",\n\t\t\tpin_fmt[i].pin_index, fmt->sampling_frequency, fmt->bit_depth, fmt->ch_map,\n\t\t\tfmt->ch_cfg, fmt->interleaving_style, fmt->fmt_cfg,\n\t\t\tpin_fmt[i].buffer_size);\n\t}\n}\n\nstatic const struct sof_ipc4_audio_format *\nsof_ipc4_get_input_pin_audio_fmt(struct snd_sof_widget *swidget, int pin_index)\n{\n\tstruct sof_ipc4_base_module_cfg_ext *base_cfg_ext;\n\tstruct sof_ipc4_process *process;\n\tint i;\n\n\tif (swidget->id != snd_soc_dapm_effect) {\n\t\tstruct sof_ipc4_base_module_cfg *base = swidget->private;\n\n\t\t \n\t\treturn &base->audio_fmt;\n\t}\n\n\tprocess = swidget->private;\n\tbase_cfg_ext = process->base_config_ext;\n\n\t \n\tfor (i = 0; i < base_cfg_ext->num_input_pin_fmts; i++) {\n\t\tstruct sof_ipc4_pin_format *pin_format = &base_cfg_ext->pin_formats[i];\n\n\t\tif (pin_format->pin_index == pin_index)\n\t\t\treturn &pin_format->audio_fmt;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int sof_ipc4_get_audio_fmt(struct snd_soc_component *scomp,\n\t\t\t\t  struct snd_sof_widget *swidget,\n\t\t\t\t  struct sof_ipc4_available_audio_format *available_fmt,\n\t\t\t\t  struct sof_ipc4_base_module_cfg *module_base_cfg)\n{\n\tstruct sof_ipc4_pin_format *in_format = NULL;\n\tstruct sof_ipc4_pin_format *out_format;\n\tint ret;\n\n\tret = sof_update_ipc_object(scomp, available_fmt,\n\t\t\t\t    SOF_AUDIO_FMT_NUM_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*available_fmt), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"Failed to parse audio format token count\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!available_fmt->num_input_formats && !available_fmt->num_output_formats) {\n\t\tdev_err(scomp->dev, \"No input/output pin formats set in topology\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(scomp->dev,\n\t\t\"Number of input audio formats: %d. Number of output audio formats: %d\\n\",\n\t\tavailable_fmt->num_input_formats, available_fmt->num_output_formats);\n\n\t \n\tret = sof_update_ipc_object(scomp, module_base_cfg, SOF_COMP_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*module_base_cfg), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parse comp tokens for %s failed, error: %d\\n\",\n\t\t\tswidget->widget->name, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(scomp->dev, \"widget %s: is_pages: %d\\n\", swidget->widget->name,\n\t\tmodule_base_cfg->is_pages);\n\n\tif (available_fmt->num_input_formats) {\n\t\tin_format = kcalloc(available_fmt->num_input_formats,\n\t\t\t\t    sizeof(*in_format), GFP_KERNEL);\n\t\tif (!in_format)\n\t\t\treturn -ENOMEM;\n\t\tavailable_fmt->input_pin_fmts = in_format;\n\n\t\tret = sof_update_ipc_object(scomp, in_format,\n\t\t\t\t\t    SOF_IN_AUDIO_FORMAT_TOKENS, swidget->tuples,\n\t\t\t\t\t    swidget->num_tuples, sizeof(*in_format),\n\t\t\t\t\t    available_fmt->num_input_formats);\n\t\tif (ret) {\n\t\t\tdev_err(scomp->dev, \"parse input audio fmt tokens failed %d\\n\", ret);\n\t\t\tgoto err_in;\n\t\t}\n\n\t\tdev_dbg(scomp->dev, \"Input audio formats for %s\\n\", swidget->widget->name);\n\t\tsof_ipc4_dbg_audio_format(scomp->dev, in_format,\n\t\t\t\t\t  available_fmt->num_input_formats);\n\t}\n\n\tif (available_fmt->num_output_formats) {\n\t\tout_format = kcalloc(available_fmt->num_output_formats, sizeof(*out_format),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!out_format) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_in;\n\t\t}\n\n\t\tret = sof_update_ipc_object(scomp, out_format,\n\t\t\t\t\t    SOF_OUT_AUDIO_FORMAT_TOKENS, swidget->tuples,\n\t\t\t\t\t    swidget->num_tuples, sizeof(*out_format),\n\t\t\t\t\t    available_fmt->num_output_formats);\n\t\tif (ret) {\n\t\t\tdev_err(scomp->dev, \"parse output audio fmt tokens failed\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tavailable_fmt->output_pin_fmts = out_format;\n\t\tdev_dbg(scomp->dev, \"Output audio formats for %s\\n\", swidget->widget->name);\n\t\tsof_ipc4_dbg_audio_format(scomp->dev, out_format,\n\t\t\t\t\t  available_fmt->num_output_formats);\n\t}\n\n\treturn 0;\n\nerr_out:\n\tkfree(out_format);\nerr_in:\n\tkfree(in_format);\n\tavailable_fmt->input_pin_fmts = NULL;\n\treturn ret;\n}\n\n \nstatic void sof_ipc4_free_audio_fmt(struct sof_ipc4_available_audio_format *available_fmt)\n\n{\n\tkfree(available_fmt->output_pin_fmts);\n\tavailable_fmt->output_pin_fmts = NULL;\n\tkfree(available_fmt->input_pin_fmts);\n\tavailable_fmt->input_pin_fmts = NULL;\n}\n\nstatic void sof_ipc4_widget_free_comp_pipeline(struct snd_sof_widget *swidget)\n{\n\tkfree(swidget->private);\n}\n\nstatic int sof_ipc4_widget_set_module_info(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\n\tswidget->module_info = sof_ipc4_find_module_by_uuid(sdev, &swidget->uuid);\n\n\tif (swidget->module_info)\n\t\treturn 0;\n\n\tdev_err(sdev->dev, \"failed to find module info for widget %s with UUID %pUL\\n\",\n\t\tswidget->widget->name, &swidget->uuid);\n\treturn -EINVAL;\n}\n\nstatic int sof_ipc4_widget_setup_msg(struct snd_sof_widget *swidget, struct sof_ipc4_msg *msg)\n{\n\tstruct sof_ipc4_fw_module *fw_module;\n\tuint32_t type;\n\tint ret;\n\n\tret = sof_ipc4_widget_set_module_info(swidget);\n\tif (ret)\n\t\treturn ret;\n\n\tfw_module = swidget->module_info;\n\n\tmsg->primary = fw_module->man4_module_entry.id;\n\tmsg->primary |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_MOD_INIT_INSTANCE);\n\tmsg->primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg->primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\tmsg->extension = SOF_IPC4_MOD_EXT_CORE_ID(swidget->core);\n\n\ttype = (fw_module->man4_module_entry.type & SOF_IPC4_MODULE_DP) ? 1 : 0;\n\tmsg->extension |= SOF_IPC4_MOD_EXT_DOMAIN(type);\n\n\treturn 0;\n}\n\nstatic void sof_ipc4_widget_update_kcontrol_module_id(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_fw_module *fw_module = swidget->module_info;\n\tstruct snd_sof_control *scontrol;\n\n\t \n\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list) {\n\t\tif (scontrol->comp_id == swidget->comp_id) {\n\t\t\tstruct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;\n\t\t\tstruct sof_ipc4_msg *msg = &cdata->msg;\n\n\t\t\tmsg->primary |= fw_module->man4_module_entry.id;\n\t\t}\n\t}\n}\n\nstatic int sof_ipc4_widget_setup_pcm(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_available_audio_format *available_fmt;\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\tint node_type = 0;\n\tint ret;\n\n\tipc4_copier = kzalloc(sizeof(*ipc4_copier), GFP_KERNEL);\n\tif (!ipc4_copier)\n\t\treturn -ENOMEM;\n\n\tswidget->private = ipc4_copier;\n\tavailable_fmt = &ipc4_copier->available_fmt;\n\n\tdev_dbg(scomp->dev, \"Updating IPC structure for %s\\n\", swidget->widget->name);\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, available_fmt,\n\t\t\t\t     &ipc4_copier->data.base_config);\n\tif (ret)\n\t\tgoto free_copier;\n\n\t \n\tif (!WIDGET_IS_AIF(swidget->id))\n\t\tgoto skip_gtw_cfg;\n\n\tret = sof_update_ipc_object(scomp, &node_type,\n\t\t\t\t    SOF_COPIER_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(node_type), 1);\n\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parse host copier node type token failed %d\\n\",\n\t\t\tret);\n\t\tgoto free_available_fmt;\n\t}\n\tdev_dbg(scomp->dev, \"host copier '%s' node_type %u\\n\", swidget->widget->name, node_type);\n\nskip_gtw_cfg:\n\tipc4_copier->gtw_attr = kzalloc(sizeof(*ipc4_copier->gtw_attr), GFP_KERNEL);\n\tif (!ipc4_copier->gtw_attr) {\n\t\tret = -ENOMEM;\n\t\tgoto free_available_fmt;\n\t}\n\n\tipc4_copier->copier_config = (uint32_t *)ipc4_copier->gtw_attr;\n\tipc4_copier->data.gtw_cfg.config_length =\n\t\tsizeof(struct sof_ipc4_gtw_attributes) >> 2;\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\t\tipc4_copier->data.gtw_cfg.node_id = SOF_IPC4_NODE_TYPE(node_type);\n\t\tbreak;\n\tcase snd_soc_dapm_buffer:\n\t\tipc4_copier->data.gtw_cfg.node_id = SOF_IPC4_INVALID_NODE_ID;\n\t\tipc4_copier->ipc_config_size = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(scomp->dev, \"invalid widget type %d\\n\", swidget->id);\n\t\tret = -EINVAL;\n\t\tgoto free_gtw_attr;\n\t}\n\n\t \n\tret = sof_ipc4_widget_setup_msg(swidget, &ipc4_copier->msg);\n\tif (ret)\n\t\tgoto free_gtw_attr;\n\n\treturn 0;\n\nfree_gtw_attr:\n\tkfree(ipc4_copier->gtw_attr);\nfree_available_fmt:\n\tsof_ipc4_free_audio_fmt(available_fmt);\nfree_copier:\n\tkfree(ipc4_copier);\n\tswidget->private = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc4_widget_free_comp_pcm(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_copier *ipc4_copier = swidget->private;\n\tstruct sof_ipc4_available_audio_format *available_fmt;\n\n\tif (!ipc4_copier)\n\t\treturn;\n\n\tavailable_fmt = &ipc4_copier->available_fmt;\n\tkfree(available_fmt->output_pin_fmts);\n\tkfree(ipc4_copier->gtw_attr);\n\tkfree(ipc4_copier);\n\tswidget->private = NULL;\n}\n\nstatic int sof_ipc4_widget_setup_comp_dai(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_available_audio_format *available_fmt;\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dai *dai = swidget->private;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\tstruct snd_sof_widget *pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline;\n\tint node_type = 0;\n\tint ret;\n\n\tipc4_copier = kzalloc(sizeof(*ipc4_copier), GFP_KERNEL);\n\tif (!ipc4_copier)\n\t\treturn -ENOMEM;\n\n\tavailable_fmt = &ipc4_copier->available_fmt;\n\n\tdev_dbg(scomp->dev, \"Updating IPC structure for %s\\n\", swidget->widget->name);\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, available_fmt,\n\t\t\t\t     &ipc4_copier->data.base_config);\n\tif (ret)\n\t\tgoto free_copier;\n\n\tret = sof_update_ipc_object(scomp, &node_type,\n\t\t\t\t    SOF_COPIER_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(node_type), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parse dai node type failed %d\\n\", ret);\n\t\tgoto free_available_fmt;\n\t}\n\n\tret = sof_update_ipc_object(scomp, ipc4_copier,\n\t\t\t\t    SOF_DAI_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(u32), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parse dai copier node token failed %d\\n\", ret);\n\t\tgoto free_available_fmt;\n\t}\n\n\tdev_dbg(scomp->dev, \"dai %s node_type %u dai_type %u dai_index %d\\n\", swidget->widget->name,\n\t\tnode_type, ipc4_copier->dai_type, ipc4_copier->dai_index);\n\n\tipc4_copier->data.gtw_cfg.node_id = SOF_IPC4_NODE_TYPE(node_type);\n\n\tpipe_widget = swidget->spipe->pipe_widget;\n\tpipeline = pipe_widget->private;\n\tif (pipeline->use_chain_dma && ipc4_copier->dai_type != SOF_DAI_INTEL_HDA) {\n\t\tdev_err(scomp->dev,\n\t\t\t\"Bad DAI type '%d', Chained DMA is only supported by HDA DAIs (%d).\\n\",\n\t\t\tipc4_copier->dai_type, SOF_DAI_INTEL_HDA);\n\t\tret = -ENODEV;\n\t\tgoto free_available_fmt;\n\t}\n\n\tswitch (ipc4_copier->dai_type) {\n\tcase SOF_DAI_INTEL_ALH:\n\t{\n\t\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\t\tstruct sof_ipc4_alh_configuration_blob *blob;\n\t\tstruct snd_soc_dapm_path *p;\n\t\tstruct snd_sof_widget *w;\n\t\tint src_num = 0;\n\n\t\tsnd_soc_dapm_widget_for_each_source_path(swidget->widget, p)\n\t\t\tsrc_num++;\n\n\t\tif (swidget->id == snd_soc_dapm_dai_in && src_num == 0) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tblob = kzalloc(sizeof(*blob), GFP_KERNEL);\n\t\tif (!blob) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_available_fmt;\n\t\t}\n\n\t\tlist_for_each_entry(w, &sdev->widget_list, list) {\n\t\t\tif (w->widget->sname &&\n\t\t\t    strcmp(w->widget->sname, swidget->widget->sname))\n\t\t\t\tcontinue;\n\n\t\t\tblob->alh_cfg.device_count++;\n\t\t}\n\n\t\tipc4_copier->copier_config = (uint32_t *)blob;\n\t\tipc4_copier->data.gtw_cfg.config_length = sizeof(*blob) >> 2;\n\t\tbreak;\n\t}\n\tcase SOF_DAI_INTEL_SSP:\n\t\t \n\t\tipc4_copier->data.gtw_cfg.node_id |=\n\t\t\tSOF_IPC4_NODE_INDEX_INTEL_SSP(ipc4_copier->dai_index);\n\t\tbreak;\n\tcase SOF_DAI_INTEL_DMIC:\n\t\t \n\t\tipc4_copier->data.gtw_cfg.node_id |=\n\t\t\tSOF_IPC4_NODE_INDEX_INTEL_DMIC(ipc4_copier->dai_index);\n\t\tbreak;\n\tdefault:\n\t\tipc4_copier->gtw_attr = kzalloc(sizeof(*ipc4_copier->gtw_attr), GFP_KERNEL);\n\t\tif (!ipc4_copier->gtw_attr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_available_fmt;\n\t\t}\n\n\t\tipc4_copier->copier_config = (uint32_t *)ipc4_copier->gtw_attr;\n\t\tipc4_copier->data.gtw_cfg.config_length =\n\t\t\tsizeof(struct sof_ipc4_gtw_attributes) >> 2;\n\t\tbreak;\n\t}\n\n\tdai->scomp = scomp;\n\tdai->private = ipc4_copier;\n\n\t \n\tret = sof_ipc4_widget_setup_msg(swidget, &ipc4_copier->msg);\n\tif (ret)\n\t\tgoto free_copier_config;\n\n\treturn 0;\n\nfree_copier_config:\n\tkfree(ipc4_copier->copier_config);\nfree_available_fmt:\n\tsof_ipc4_free_audio_fmt(available_fmt);\nfree_copier:\n\tkfree(ipc4_copier);\n\tdai->private = NULL;\n\tdai->scomp = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc4_widget_free_comp_dai(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_available_audio_format *available_fmt;\n\tstruct snd_sof_dai *dai = swidget->private;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\n\tif (!dai)\n\t\treturn;\n\n\tif (!dai->private) {\n\t\tkfree(dai);\n\t\tswidget->private = NULL;\n\t\treturn;\n\t}\n\n\tipc4_copier = dai->private;\n\tavailable_fmt = &ipc4_copier->available_fmt;\n\n\tkfree(available_fmt->output_pin_fmts);\n\tif (ipc4_copier->dai_type != SOF_DAI_INTEL_SSP &&\n\t    ipc4_copier->dai_type != SOF_DAI_INTEL_DMIC)\n\t\tkfree(ipc4_copier->copier_config);\n\tkfree(dai->private);\n\tkfree(dai);\n\tswidget->private = NULL;\n}\n\nstatic int sof_ipc4_widget_setup_comp_pipeline(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc4_pipeline *pipeline;\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tint ret;\n\n\tpipeline = kzalloc(sizeof(*pipeline), GFP_KERNEL);\n\tif (!pipeline)\n\t\treturn -ENOMEM;\n\n\tret = sof_update_ipc_object(scomp, pipeline, SOF_SCHED_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*pipeline), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parsing scheduler tokens failed\\n\");\n\t\tgoto err;\n\t}\n\n\tswidget->core = pipeline->core_id;\n\tspipe->core_mask |= BIT(pipeline->core_id);\n\n\tif (pipeline->use_chain_dma) {\n\t\tdev_dbg(scomp->dev, \"Set up chain DMA for %s\\n\", swidget->widget->name);\n\t\tswidget->private = pipeline;\n\t\treturn 0;\n\t}\n\n\t \n\tret = sof_update_ipc_object(scomp, swidget, SOF_PIPELINE_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*swidget), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"parsing pipeline tokens failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tpipeline->priority = 0;\n\n\tdev_dbg(scomp->dev, \"pipeline '%s': id %d, pri %d, core_id %u, lp mode %d\\n\",\n\t\tswidget->widget->name, swidget->pipeline_id,\n\t\tpipeline->priority, pipeline->core_id, pipeline->lp_mode);\n\n\tswidget->private = pipeline;\n\n\tpipeline->msg.primary = SOF_IPC4_GLB_PIPE_PRIORITY(pipeline->priority);\n\tpipeline->msg.primary |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_CREATE_PIPELINE);\n\tpipeline->msg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tpipeline->msg.primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\n\tpipeline->msg.extension = pipeline->lp_mode;\n\tpipeline->msg.extension |= SOF_IPC4_GLB_PIPE_EXT_CORE_ID(pipeline->core_id);\n\tpipeline->state = SOF_IPC4_PIPE_UNINITIALIZED;\n\n\treturn 0;\nerr:\n\tkfree(pipeline);\n\treturn ret;\n}\n\nstatic int sof_ipc4_widget_setup_comp_pga(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc4_gain *gain;\n\tint ret;\n\n\tgain = kzalloc(sizeof(*gain), GFP_KERNEL);\n\tif (!gain)\n\t\treturn -ENOMEM;\n\n\tswidget->private = gain;\n\n\tgain->data.params.channels = SOF_IPC4_GAIN_ALL_CHANNELS_MASK;\n\tgain->data.params.init_val = SOF_IPC4_VOL_ZERO_DB;\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, &gain->available_fmt, &gain->data.base_config);\n\tif (ret)\n\t\tgoto err;\n\n\tret = sof_update_ipc_object(scomp, &gain->data.params, SOF_GAIN_TOKENS,\n\t\t\t\t    swidget->tuples, swidget->num_tuples, sizeof(gain->data), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"Parsing gain tokens failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_dbg(scomp->dev,\n\t\t\"pga widget %s: ramp type: %d, ramp duration %d, initial gain value: %#x\\n\",\n\t\tswidget->widget->name, gain->data.params.curve_type,\n\t\tgain->data.params.curve_duration_l, gain->data.params.init_val);\n\n\tret = sof_ipc4_widget_setup_msg(swidget, &gain->msg);\n\tif (ret)\n\t\tgoto err;\n\n\tsof_ipc4_widget_update_kcontrol_module_id(swidget);\n\n\treturn 0;\nerr:\n\tsof_ipc4_free_audio_fmt(&gain->available_fmt);\n\tkfree(gain);\n\tswidget->private = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc4_widget_free_comp_pga(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_gain *gain = swidget->private;\n\n\tif (!gain)\n\t\treturn;\n\n\tsof_ipc4_free_audio_fmt(&gain->available_fmt);\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n}\n\nstatic int sof_ipc4_widget_setup_comp_mixer(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc4_mixer *mixer;\n\tint ret;\n\n\tdev_dbg(scomp->dev, \"Updating IPC structure for %s\\n\", swidget->widget->name);\n\n\tmixer = kzalloc(sizeof(*mixer), GFP_KERNEL);\n\tif (!mixer)\n\t\treturn -ENOMEM;\n\n\tswidget->private = mixer;\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, &mixer->available_fmt,\n\t\t\t\t     &mixer->base_config);\n\tif (ret)\n\t\tgoto err;\n\n\tret = sof_ipc4_widget_setup_msg(swidget, &mixer->msg);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tsof_ipc4_free_audio_fmt(&mixer->available_fmt);\n\tkfree(mixer);\n\tswidget->private = NULL;\n\treturn ret;\n}\n\nstatic int sof_ipc4_widget_setup_comp_src(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tstruct sof_ipc4_src *src;\n\tint ret;\n\n\tdev_dbg(scomp->dev, \"Updating IPC structure for %s\\n\", swidget->widget->name);\n\n\tsrc = kzalloc(sizeof(*src), GFP_KERNEL);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\tswidget->private = src;\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, &src->available_fmt,\n\t\t\t\t     &src->data.base_config);\n\tif (ret)\n\t\tgoto err;\n\n\tret = sof_update_ipc_object(scomp, &src->data, SOF_SRC_TOKENS, swidget->tuples,\n\t\t\t\t    swidget->num_tuples, sizeof(*src), 1);\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"Parsing SRC tokens failed\\n\");\n\t\tgoto err;\n\t}\n\n\tspipe->core_mask |= BIT(swidget->core);\n\n\tdev_dbg(scomp->dev, \"SRC sink rate %d\\n\", src->data.sink_rate);\n\n\tret = sof_ipc4_widget_setup_msg(swidget, &src->msg);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tsof_ipc4_free_audio_fmt(&src->available_fmt);\n\tkfree(src);\n\tswidget->private = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc4_widget_free_comp_src(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_src *src = swidget->private;\n\n\tif (!src)\n\t\treturn;\n\n\tsof_ipc4_free_audio_fmt(&src->available_fmt);\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n}\n\nstatic void sof_ipc4_widget_free_comp_mixer(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_mixer *mixer = swidget->private;\n\n\tif (!mixer)\n\t\treturn;\n\n\tsof_ipc4_free_audio_fmt(&mixer->available_fmt);\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n}\n\n \nstatic int sof_ipc4_widget_setup_comp_process(struct snd_sof_widget *swidget)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct sof_ipc4_fw_module *fw_module;\n\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\tstruct sof_ipc4_process *process;\n\tvoid *cfg;\n\tint ret;\n\n\tprocess = kzalloc(sizeof(*process), GFP_KERNEL);\n\tif (!process)\n\t\treturn -ENOMEM;\n\n\tswidget->private = process;\n\n\tret = sof_ipc4_get_audio_fmt(scomp, swidget, &process->available_fmt,\n\t\t\t\t     &process->base_config);\n\tif (ret)\n\t\tgoto err;\n\n\tret = sof_ipc4_widget_setup_msg(swidget, &process->msg);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tfw_module = swidget->module_info;\n\tprocess->init_config = FIELD_GET(SOF_IPC4_MODULE_INIT_CONFIG_MASK,\n\t\t\t\t\t fw_module->man4_module_entry.type);\n\n\tprocess->ipc_config_size = sizeof(struct sof_ipc4_base_module_cfg);\n\n\t \n\tif (process->init_config == SOF_IPC4_MODULE_INIT_CONFIG_TYPE_BASE_CFG_WITH_EXT) {\n\t\tstruct sof_ipc4_base_module_cfg_ext *base_cfg_ext;\n\t\tu32 ext_size = struct_size(base_cfg_ext, pin_formats,\n\t\t\t\t\t   size_add(swidget->num_input_pins,\n\t\t\t\t\t\t    swidget->num_output_pins));\n\n\t\tbase_cfg_ext = kzalloc(ext_size, GFP_KERNEL);\n\t\tif (!base_cfg_ext) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_available_fmt;\n\t\t}\n\n\t\tbase_cfg_ext->num_input_pin_fmts = swidget->num_input_pins;\n\t\tbase_cfg_ext->num_output_pin_fmts = swidget->num_output_pins;\n\t\tprocess->base_config_ext = base_cfg_ext;\n\t\tprocess->base_config_ext_size = ext_size;\n\t\tprocess->ipc_config_size += ext_size;\n\t}\n\n\tcfg = kzalloc(process->ipc_config_size, GFP_KERNEL);\n\tif (!cfg) {\n\t\tret = -ENOMEM;\n\t\tgoto free_base_cfg_ext;\n\t}\n\n\tprocess->ipc_config_data = cfg;\n\n\tsof_ipc4_widget_update_kcontrol_module_id(swidget);\n\n\t \n\tspipe->core_mask |= BIT(swidget->core);\n\n\treturn 0;\nfree_base_cfg_ext:\n\tkfree(process->base_config_ext);\n\tprocess->base_config_ext = NULL;\nfree_available_fmt:\n\tsof_ipc4_free_audio_fmt(&process->available_fmt);\nerr:\n\tkfree(process);\n\tswidget->private = NULL;\n\treturn ret;\n}\n\nstatic void sof_ipc4_widget_free_comp_process(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_process *process = swidget->private;\n\n\tif (!process)\n\t\treturn;\n\n\tkfree(process->ipc_config_data);\n\tkfree(process->base_config_ext);\n\tsof_ipc4_free_audio_fmt(&process->available_fmt);\n\tkfree(swidget->private);\n\tswidget->private = NULL;\n}\n\nstatic void\nsof_ipc4_update_resource_usage(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,\n\t\t\t       struct sof_ipc4_base_module_cfg *base_config)\n{\n\tstruct sof_ipc4_fw_module *fw_module = swidget->module_info;\n\tstruct snd_sof_widget *pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline;\n\tint task_mem, queue_mem;\n\tint ibs, bss, total;\n\n\tibs = base_config->ibs;\n\tbss = base_config->is_pages;\n\n\ttask_mem = SOF_IPC4_PIPELINE_OBJECT_SIZE;\n\ttask_mem += SOF_IPC4_MODULE_INSTANCE_LIST_ITEM_SIZE + bss;\n\n\tif (fw_module->man4_module_entry.type & SOF_IPC4_MODULE_LL) {\n\t\ttask_mem += SOF_IPC4_FW_ROUNDUP(SOF_IPC4_LL_TASK_OBJECT_SIZE);\n\t\ttask_mem += SOF_IPC4_FW_MAX_QUEUE_COUNT * SOF_IPC4_MODULE_INSTANCE_LIST_ITEM_SIZE;\n\t\ttask_mem += SOF_IPC4_LL_TASK_LIST_ITEM_SIZE;\n\t} else {\n\t\ttask_mem += SOF_IPC4_FW_ROUNDUP(SOF_IPC4_DP_TASK_OBJECT_SIZE);\n\t\ttask_mem += SOF_IPC4_DP_TASK_LIST_SIZE;\n\t}\n\n\tibs = SOF_IPC4_FW_ROUNDUP(ibs);\n\tqueue_mem = SOF_IPC4_FW_MAX_QUEUE_COUNT * (SOF_IPC4_DATA_QUEUE_OBJECT_SIZE +  ibs);\n\n\ttotal = SOF_IPC4_FW_PAGE(task_mem + queue_mem);\n\n\tpipe_widget = swidget->spipe->pipe_widget;\n\tpipeline = pipe_widget->private;\n\tpipeline->mem_usage += total;\n\n\t \n\tsof_ipc4_update_cpc_from_manifest(sdev, fw_module, base_config);\n\n\tif (ignore_cpc) {\n\t\tdev_dbg(sdev->dev, \"%s: ibs / obs: %u / %u, forcing cpc to 0 from %u\\n\",\n\t\t\tswidget->widget->name, base_config->ibs, base_config->obs,\n\t\t\tbase_config->cpc);\n\t\tbase_config->cpc = 0;\n\t} else {\n\t\tdev_dbg(sdev->dev, \"%s: ibs / obs / cpc: %u / %u / %u\\n\",\n\t\t\tswidget->widget->name, base_config->ibs, base_config->obs,\n\t\t\tbase_config->cpc);\n\t}\n}\n\nstatic int sof_ipc4_widget_assign_instance_id(struct snd_sof_dev *sdev,\n\t\t\t\t\t      struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_fw_module *fw_module = swidget->module_info;\n\tint max_instances = fw_module->man4_module_entry.instance_max_count;\n\n\tswidget->instance_id = ida_alloc_max(&fw_module->m_ida, max_instances, GFP_KERNEL);\n\tif (swidget->instance_id < 0) {\n\t\tdev_err(sdev->dev, \"failed to assign instance id for widget %s\",\n\t\t\tswidget->widget->name);\n\t\treturn swidget->instance_id;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_ipc4_update_hw_params(struct snd_sof_dev *sdev, struct snd_pcm_hw_params *params,\n\t\t\t\t     struct sof_ipc4_audio_format *fmt)\n{\n\tsnd_pcm_format_t snd_fmt;\n\tstruct snd_interval *i;\n\tstruct snd_mask *m;\n\tint valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\tunsigned int channels, rate;\n\n\tswitch (valid_bits) {\n\tcase 16:\n\t\tsnd_fmt = SNDRV_PCM_FORMAT_S16_LE;\n\t\tbreak;\n\tcase 24:\n\t\tsnd_fmt = SNDRV_PCM_FORMAT_S24_LE;\n\t\tbreak;\n\tcase 32:\n\t\tsnd_fmt = SNDRV_PCM_FORMAT_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"invalid PCM valid_bits %d\\n\", valid_bits);\n\t\treturn -EINVAL;\n\t}\n\n\tm = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tsnd_mask_none(m);\n\tsnd_mask_set_format(m, snd_fmt);\n\n\trate = fmt->sampling_frequency;\n\ti = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\ti->min = rate;\n\ti->max = rate;\n\n\tchannels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(fmt->fmt_cfg);\n\ti = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\ti->min = channels;\n\ti->max = channels;\n\n\treturn 0;\n}\n\nstatic bool sof_ipc4_is_single_format(struct snd_sof_dev *sdev,\n\t\t\t\t      struct sof_ipc4_pin_format *pin_fmts, u32 pin_fmts_size)\n{\n\tstruct sof_ipc4_audio_format *fmt;\n\tu32 rate, channels, valid_bits;\n\tint i;\n\n\tfmt = &pin_fmts[0].audio_fmt;\n\trate = fmt->sampling_frequency;\n\tchannels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(fmt->fmt_cfg);\n\tvalid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\n\t \n\tfor (i = 1; i < pin_fmts_size; i++) {\n\t\tu32 _rate, _channels, _valid_bits;\n\n\t\tfmt = &pin_fmts[i].audio_fmt;\n\t\t_rate = fmt->sampling_frequency;\n\t\t_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(fmt->fmt_cfg);\n\t\t_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\n\t\tif (_rate != rate || _channels != channels || _valid_bits != valid_bits)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int sof_ipc4_init_output_audio_fmt(struct snd_sof_dev *sdev,\n\t\t\t\t\t  struct sof_ipc4_base_module_cfg *base_config,\n\t\t\t\t\t  struct sof_ipc4_available_audio_format *available_fmt,\n\t\t\t\t\t  u32 out_ref_rate, u32 out_ref_channels,\n\t\t\t\t\t  u32 out_ref_valid_bits)\n{\n\tstruct sof_ipc4_audio_format *out_fmt;\n\tbool single_format;\n\tint i;\n\n\tif (!available_fmt->num_output_formats)\n\t\treturn -EINVAL;\n\n\tsingle_format = sof_ipc4_is_single_format(sdev, available_fmt->output_pin_fmts,\n\t\t\t\t\t\t  available_fmt->num_output_formats);\n\n\t \n\tif (single_format) {\n\t\tbase_config->obs = available_fmt->output_pin_fmts[0].buffer_size;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < available_fmt->num_output_formats; i++) {\n\t\tu32 _out_rate, _out_channels, _out_valid_bits;\n\n\t\tout_fmt = &available_fmt->output_pin_fmts[i].audio_fmt;\n\t\t_out_rate = out_fmt->sampling_frequency;\n\t\t_out_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(out_fmt->fmt_cfg);\n\t\t_out_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(out_fmt->fmt_cfg);\n\n\t\tif (_out_rate == out_ref_rate && _out_channels == out_ref_channels &&\n\t\t    _out_valid_bits == out_ref_valid_bits) {\n\t\t\tbase_config->obs = available_fmt->output_pin_fmts[i].buffer_size;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sof_ipc4_get_valid_bits(struct snd_sof_dev *sdev, struct snd_pcm_hw_params *params)\n{\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\treturn 16;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\treturn 24;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\treturn 32;\n\tdefault:\n\t\tdev_err(sdev->dev, \"invalid pcm frame format %d\\n\", params_format(params));\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sof_ipc4_init_input_audio_fmt(struct snd_sof_dev *sdev,\n\t\t\t\t\t struct snd_sof_widget *swidget,\n\t\t\t\t\t struct sof_ipc4_base_module_cfg *base_config,\n\t\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t\t struct sof_ipc4_available_audio_format *available_fmt)\n{\n\tstruct sof_ipc4_pin_format *pin_fmts = available_fmt->input_pin_fmts;\n\tu32 pin_fmts_size = available_fmt->num_input_formats;\n\tu32 valid_bits;\n\tu32 channels;\n\tu32 rate;\n\tbool single_format;\n\tint sample_valid_bits;\n\tint i = 0;\n\n\tif (!available_fmt->num_input_formats) {\n\t\tdev_err(sdev->dev, \"no input formats for %s\\n\", swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\tsingle_format = sof_ipc4_is_single_format(sdev, available_fmt->input_pin_fmts,\n\t\t\t\t\t\t  available_fmt->num_input_formats);\n\tif (single_format)\n\t\tgoto in_fmt;\n\n\tsample_valid_bits = sof_ipc4_get_valid_bits(sdev, params);\n\tif (sample_valid_bits < 0)\n\t\treturn sample_valid_bits;\n\n\t \n\tfor (i = 0; i < pin_fmts_size; i++) {\n\t\tstruct sof_ipc4_audio_format *fmt = &pin_fmts[i].audio_fmt;\n\n\t\tif (pin_fmts[i].pin_index)\n\t\t\tcontinue;\n\n\t\trate = fmt->sampling_frequency;\n\t\tchannels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(fmt->fmt_cfg);\n\t\tvalid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\t\tif (params_rate(params) == rate && params_channels(params) == channels &&\n\t\t    sample_valid_bits == valid_bits) {\n\t\t\tdev_dbg(sdev->dev, \"matched audio format index for %uHz, %ubit, %u channels: %d\\n\",\n\t\t\t\trate, valid_bits, channels, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == pin_fmts_size) {\n\t\tdev_err(sdev->dev, \"%s: Unsupported audio format: %uHz, %ubit, %u channels\\n\",\n\t\t\t__func__, params_rate(params), sample_valid_bits, params_channels(params));\n\t\treturn -EINVAL;\n\t}\n\nin_fmt:\n\t \n\tif (available_fmt->num_input_formats && i < available_fmt->num_input_formats) {\n\t\tmemcpy(&base_config->audio_fmt, &available_fmt->input_pin_fmts[i].audio_fmt,\n\t\t       sizeof(struct sof_ipc4_audio_format));\n\n\t\t \n\t\tbase_config->ibs = available_fmt->input_pin_fmts[i].buffer_size;\n\n\t\tdev_dbg(sdev->dev, \"Init input audio formats for %s\\n\", swidget->widget->name);\n\t\tsof_ipc4_dbg_audio_format(sdev->dev, &available_fmt->input_pin_fmts[i], 1);\n\t}\n\n\treturn i;\n}\n\nstatic void sof_ipc4_unprepare_copier_module(struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_copier *ipc4_copier = NULL;\n\tstruct snd_sof_widget *pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline;\n\n\t \n\tpipe_widget = swidget->spipe->pipe_widget;\n\tpipeline = pipe_widget->private;\n\tpipeline->mem_usage = 0;\n\n\tif (WIDGET_IS_AIF(swidget->id) || swidget->id == snd_soc_dapm_buffer) {\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tpipeline->msg.primary = 0;\n\t\t\tpipeline->msg.extension = 0;\n\t\t}\n\t\tipc4_copier = swidget->private;\n\t} else if (WIDGET_IS_DAI(swidget->id)) {\n\t\tstruct snd_sof_dai *dai = swidget->private;\n\n\t\tipc4_copier = dai->private;\n\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tpipeline->msg.primary = 0;\n\t\t\tpipeline->msg.extension = 0;\n\t\t}\n\n\t\tif (ipc4_copier->dai_type == SOF_DAI_INTEL_ALH) {\n\t\t\tstruct sof_ipc4_copier_data *copier_data = &ipc4_copier->data;\n\t\t\tstruct sof_ipc4_alh_configuration_blob *blob;\n\t\t\tunsigned int group_id;\n\n\t\t\tblob = (struct sof_ipc4_alh_configuration_blob *)ipc4_copier->copier_config;\n\t\t\tif (blob->alh_cfg.device_count > 1) {\n\t\t\t\tgroup_id = SOF_IPC4_NODE_INDEX(ipc4_copier->data.gtw_cfg.node_id) -\n\t\t\t\t\t   ALH_MULTI_GTW_BASE;\n\t\t\t\tida_free(&alh_group_ida, group_id);\n\t\t\t}\n\n\t\t\t \n\t\t\tcopier_data->gtw_cfg.node_id &= ~SOF_IPC4_NODE_INDEX_MASK;\n\t\t}\n\t}\n\n\tif (ipc4_copier) {\n\t\tkfree(ipc4_copier->ipc_config_data);\n\t\tipc4_copier->ipc_config_data = NULL;\n\t\tipc4_copier->ipc_config_size = 0;\n\t}\n}\n\n#if IS_ENABLED(CONFIG_ACPI) && IS_ENABLED(CONFIG_SND_INTEL_NHLT)\nstatic int snd_sof_get_hw_config_params(struct snd_sof_dev *sdev, struct snd_sof_dai *dai,\n\t\t\t\t\tint *sample_rate, int *channel_count, int *bit_depth)\n{\n\tstruct snd_soc_tplg_hw_config *hw_config;\n\tstruct snd_sof_dai_link *slink;\n\tbool dai_link_found = false;\n\tbool hw_cfg_found = false;\n\tint i;\n\n\t \n\tlist_for_each_entry(slink, &sdev->dai_link_list, list) {\n\t\tif (!strcmp(slink->link->name, dai->name)) {\n\t\t\tdai_link_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dai_link_found) {\n\t\tdev_err(sdev->dev, \"%s: no DAI link found for DAI %s\\n\", __func__, dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < slink->num_hw_configs; i++) {\n\t\thw_config = &slink->hw_configs[i];\n\t\tif (dai->current_config == le32_to_cpu(hw_config->id)) {\n\t\t\thw_cfg_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!hw_cfg_found) {\n\t\tdev_err(sdev->dev, \"%s: no matching hw_config found for DAI %s\\n\", __func__,\n\t\t\tdai->name);\n\t\treturn -EINVAL;\n\t}\n\n\t*bit_depth = le32_to_cpu(hw_config->tdm_slot_width);\n\t*channel_count = le32_to_cpu(hw_config->tdm_slots);\n\t*sample_rate = le32_to_cpu(hw_config->fsync_rate);\n\n\tdev_dbg(sdev->dev, \"sample rate: %d sample width: %d channels: %d\\n\",\n\t\t*sample_rate, *bit_depth, *channel_count);\n\n\treturn 0;\n}\n\nstatic int snd_sof_get_nhlt_endpoint_data(struct snd_sof_dev *sdev, struct snd_sof_dai *dai,\n\t\t\t\t\t  struct snd_pcm_hw_params *params, u32 dai_index,\n\t\t\t\t\t  u32 linktype, u8 dir, u32 **dst, u32 *len)\n{\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct nhlt_specific_cfg *cfg;\n\tint sample_rate, channel_count;\n\tint bit_depth, ret;\n\tu32 nhlt_type;\n\n\t \n\tswitch (linktype) {\n\tcase SOF_DAI_INTEL_DMIC:\n\t\tnhlt_type = NHLT_LINK_DMIC;\n\t\tbit_depth = params_width(params);\n\t\tchannel_count = params_channels(params);\n\t\tsample_rate = params_rate(params);\n\t\tbreak;\n\tcase SOF_DAI_INTEL_SSP:\n\t\tnhlt_type = NHLT_LINK_SSP;\n\t\tret = snd_sof_get_hw_config_params(sdev, dai, &sample_rate, &channel_count,\n\t\t\t\t\t\t   &bit_depth);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tdev_dbg(sdev->dev, \"dai index %d nhlt type %d direction %d\\n\",\n\t\tdai_index, nhlt_type, dir);\n\n\t \n\tcfg = intel_nhlt_get_endpoint_blob(sdev->dev, ipc4_data->nhlt, dai_index, nhlt_type,\n\t\t\t\t\t   bit_depth, bit_depth, channel_count, sample_rate,\n\t\t\t\t\t   dir, 0);\n\n\tif (!cfg) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"no matching blob for sample rate: %d sample width: %d channels: %d\\n\",\n\t\t\tsample_rate, bit_depth, channel_count);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\t*len = cfg->size >> 2;\n\t*dst = (u32 *)cfg->caps;\n\n\treturn 0;\n}\n#else\nstatic int snd_sof_get_nhlt_endpoint_data(struct snd_sof_dev *sdev, struct snd_sof_dai *dai,\n\t\t\t\t\t  struct snd_pcm_hw_params *params, u32 dai_index,\n\t\t\t\t\t  u32 linktype, u8 dir, u32 **dst, u32 *len)\n{\n\treturn 0;\n}\n#endif\n\nstatic bool sof_ipc4_copier_is_single_format(struct snd_sof_dev *sdev,\n\t\t\t\t\t     struct sof_ipc4_pin_format *pin_fmts,\n\t\t\t\t\t     u32 pin_fmts_size)\n{\n\tstruct sof_ipc4_audio_format *fmt;\n\tu32 valid_bits;\n\tint i;\n\n\tfmt = &pin_fmts[0].audio_fmt;\n\tvalid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\n\t \n\tfor (i = 1; i < pin_fmts_size; i++) {\n\t\tu32 _valid_bits;\n\n\t\tfmt = &pin_fmts[i].audio_fmt;\n\t\t_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(fmt->fmt_cfg);\n\n\t\tif (_valid_bits != valid_bits)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nsof_ipc4_prepare_copier_module(struct snd_sof_widget *swidget,\n\t\t\t       struct snd_pcm_hw_params *fe_params,\n\t\t\t       struct snd_sof_platform_stream_params *platform_params,\n\t\t\t       struct snd_pcm_hw_params *pipeline_params, int dir)\n{\n\tstruct sof_ipc4_available_audio_format *available_fmt;\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_copier_data *copier_data;\n\tstruct snd_pcm_hw_params *ref_params;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\tstruct snd_sof_dai *dai;\n\tu32 gtw_cfg_config_length;\n\tu32 dma_config_tlv_size = 0;\n\tvoid **ipc_config_data;\n\tint *ipc_config_size;\n\tu32 **data;\n\tint ipc_size, ret, out_ref_valid_bits;\n\tu32 out_ref_rate, out_ref_channels;\n\tu32 deep_buffer_dma_ms = 0;\n\tint output_fmt_index;\n\tbool single_output_format;\n\n\tdev_dbg(sdev->dev, \"copier %s, type %d\", swidget->widget->name, swidget->id);\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\t{\n\t\tstruct sof_ipc4_gtw_attributes *gtw_attr;\n\t\tstruct snd_sof_widget *pipe_widget;\n\t\tstruct sof_ipc4_pipeline *pipeline;\n\n\t\t \n\t\tret = sof_update_ipc_object(scomp, &deep_buffer_dma_ms,\n\t\t\t\t\t    SOF_COPIER_DEEP_BUFFER_TOKENS, swidget->tuples,\n\t\t\t\t\t    swidget->num_tuples, sizeof(u32), 1);\n\t\tif (ret) {\n\t\t\tdev_err(scomp->dev, \"Failed to parse deep buffer dma size for %s\\n\",\n\t\t\t\tswidget->widget->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tipc4_copier = (struct sof_ipc4_copier *)swidget->private;\n\t\tgtw_attr = ipc4_copier->gtw_attr;\n\t\tcopier_data = &ipc4_copier->data;\n\t\tavailable_fmt = &ipc4_copier->available_fmt;\n\n\t\tpipe_widget = swidget->spipe->pipe_widget;\n\t\tpipeline = pipe_widget->private;\n\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tu32 host_dma_id;\n\t\t\tu32 fifo_size;\n\n\t\t\thost_dma_id = platform_params->stream_tag - 1;\n\t\t\tpipeline->msg.primary |= SOF_IPC4_GLB_CHAIN_DMA_HOST_ID(host_dma_id);\n\n\t\t\t \n\t\t\tif (params_format(fe_params) == SNDRV_PCM_FORMAT_S16_LE)\n\t\t\t\tpipeline->msg.primary |= SOF_IPC4_GLB_CHAIN_DMA_SCS_MASK;\n\n\t\t\t \n\t\t\tfifo_size = DIV_ROUND_UP((SOF_IPC4_CHAIN_DMA_BUF_SIZE_MS *\n\t\t\t\t\t\t  params_rate(fe_params) *\n\t\t\t\t\t\t  params_channels(fe_params) *\n\t\t\t\t\t\t  params_physical_width(fe_params)), 8000);\n\t\t\tpipeline->msg.extension |= SOF_IPC4_GLB_EXT_CHAIN_DMA_FIFO_SIZE(fifo_size);\n\n\t\t\t \n\t\t\tcopier_data->gtw_cfg.node_id = SOF_IPC4_INVALID_NODE_ID;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tref_params = fe_params;\n\t\telse\n\t\t\tref_params = pipeline_params;\n\n\t\tcopier_data->gtw_cfg.node_id &= ~SOF_IPC4_NODE_INDEX_MASK;\n\t\tcopier_data->gtw_cfg.node_id |=\n\t\t\tSOF_IPC4_NODE_INDEX(platform_params->stream_tag - 1);\n\n\t\t \n\t\tgtw_attr->lp_buffer_alloc = pipeline->lp_mode;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t{\n\t\tstruct snd_sof_widget *pipe_widget = swidget->spipe->pipe_widget;\n\t\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\n\t\tif (pipeline->use_chain_dma)\n\t\t\treturn 0;\n\n\t\tdai = swidget->private;\n\n\t\tipc4_copier = (struct sof_ipc4_copier *)dai->private;\n\t\tcopier_data = &ipc4_copier->data;\n\t\tavailable_fmt = &ipc4_copier->available_fmt;\n\n\t\t \n\t\tif (dir == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tref_params = pipeline_params;\n\t\telse\n\t\t\tref_params = fe_params;\n\n\t\tret = snd_sof_get_nhlt_endpoint_data(sdev, dai, fe_params, ipc4_copier->dai_index,\n\t\t\t\t\t\t     ipc4_copier->dai_type, dir,\n\t\t\t\t\t\t     &ipc4_copier->copier_config,\n\t\t\t\t\t\t     &copier_data->gtw_cfg.config_length);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_buffer:\n\t{\n\t\tipc4_copier = (struct sof_ipc4_copier *)swidget->private;\n\t\tcopier_data = &ipc4_copier->data;\n\t\tavailable_fmt = &ipc4_copier->available_fmt;\n\t\tref_params = pipeline_params;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdev_err(sdev->dev, \"unsupported type %d for copier %s\",\n\t\t\tswidget->id, swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = sof_ipc4_init_input_audio_fmt(sdev, swidget, &copier_data->base_config, ref_params,\n\t\t\t\t\t    available_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsingle_output_format = sof_ipc4_copier_is_single_format(sdev,\n\t\t\t\t\t\t\t\tavailable_fmt->output_pin_fmts,\n\t\t\t\t\t\t\t\tavailable_fmt->num_output_formats);\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_dai_out:\n\tcase snd_soc_dapm_buffer:\n\t{\n\t\tstruct sof_ipc4_audio_format *in_fmt;\n\n\t\tin_fmt = &available_fmt->input_pin_fmts[ret].audio_fmt;\n\t\tout_ref_rate = in_fmt->sampling_frequency;\n\t\tout_ref_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(in_fmt->fmt_cfg);\n\n\t\tif (!single_output_format)\n\t\t\tout_ref_valid_bits =\n\t\t\t\tSOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(in_fmt->fmt_cfg);\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_dai_in:\n\t\tout_ref_rate = params_rate(fe_params);\n\t\tout_ref_channels = params_channels(fe_params);\n\t\tif (!single_output_format) {\n\t\t\tout_ref_valid_bits = sof_ipc4_get_valid_bits(sdev, fe_params);\n\t\t\tif (out_ref_valid_bits < 0)\n\t\t\t\treturn out_ref_valid_bits;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (single_output_format) {\n\t\tstruct sof_ipc4_audio_format *out_fmt;\n\n\t\tout_fmt = &available_fmt->output_pin_fmts[0].audio_fmt;\n\t\tout_ref_valid_bits =\n\t\t\tSOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(out_fmt->fmt_cfg);\n\t}\n\n\tdev_dbg(sdev->dev, \"copier %s: reference output rate %d, channels %d valid_bits %d\\n\",\n\t\tswidget->widget->name, out_ref_rate, out_ref_channels, out_ref_valid_bits);\n\n\toutput_fmt_index = sof_ipc4_init_output_audio_fmt(sdev, &copier_data->base_config,\n\t\t\t\t\t\t\t  available_fmt, out_ref_rate,\n\t\t\t\t\t\t\t  out_ref_channels, out_ref_valid_bits);\n\tif (output_fmt_index < 0) {\n\t\tdev_err(sdev->dev, \"Failed to initialize output format for %s\",\n\t\t\tswidget->widget->name);\n\t\treturn output_fmt_index;\n\t}\n\n\t \n\tmemcpy(&copier_data->out_format,\n\t       &available_fmt->output_pin_fmts[output_fmt_index].audio_fmt,\n\t       sizeof(struct sof_ipc4_audio_format));\n\tdev_dbg(sdev->dev, \"Output audio format for %s\\n\", swidget->widget->name);\n\tsof_ipc4_dbg_audio_format(sdev->dev, &available_fmt->output_pin_fmts[output_fmt_index], 1);\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t{\n\t\t \n\t\tif (ipc4_copier->dai_type == SOF_DAI_INTEL_ALH) {\n\t\t\tstruct sof_ipc4_alh_configuration_blob *blob;\n\t\t\tstruct sof_ipc4_copier_data *alh_data;\n\t\t\tstruct sof_ipc4_copier *alh_copier;\n\t\t\tstruct snd_sof_widget *w;\n\t\t\tu32 ch_count = 0;\n\t\t\tu32 ch_mask = 0;\n\t\t\tu32 ch_map;\n\t\t\tu32 step;\n\t\t\tu32 mask;\n\t\t\tint i;\n\n\t\t\tblob = (struct sof_ipc4_alh_configuration_blob *)ipc4_copier->copier_config;\n\n\t\t\tblob->gw_attr.lp_buffer_alloc = 0;\n\n\t\t\t \n\t\t\tch_map = copier_data->base_config.audio_fmt.ch_map;\n\t\t\tfor (i = 0; ch_map; i++) {\n\t\t\t\tif ((ch_map & 0xf) != 0xf) {\n\t\t\t\t\tch_mask |= BIT(i);\n\t\t\t\t\tch_count++;\n\t\t\t\t}\n\t\t\t\tch_map >>= 4;\n\t\t\t}\n\n\t\t\tstep = ch_count / blob->alh_cfg.device_count;\n\t\t\tmask =  GENMASK(step - 1, 0);\n\t\t\t \n\t\t\ti = 0;\n\t\t\tlist_for_each_entry(w, &sdev->widget_list, list) {\n\t\t\t\tif (w->widget->sname &&\n\t\t\t\t    strcmp(w->widget->sname, swidget->widget->sname))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdai = w->private;\n\t\t\t\talh_copier = (struct sof_ipc4_copier *)dai->private;\n\t\t\t\talh_data = &alh_copier->data;\n\t\t\t\tblob->alh_cfg.mapping[i].device = alh_data->gtw_cfg.node_id;\n\t\t\t\t \n\t\t\t\tif (w->id == snd_soc_dapm_dai_in)\n\t\t\t\t\tblob->alh_cfg.mapping[i].channel_mask = ch_mask;\n\t\t\t\telse\n\t\t\t\t\tblob->alh_cfg.mapping[i].channel_mask = mask << (step * i);\n\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (blob->alh_cfg.device_count > 1) {\n\t\t\t\tint group_id;\n\n\t\t\t\tgroup_id = ida_alloc_max(&alh_group_ida, ALH_MULTI_GTW_COUNT - 1,\n\t\t\t\t\t\t\t GFP_KERNEL);\n\n\t\t\t\tif (group_id < 0)\n\t\t\t\t\treturn group_id;\n\n\t\t\t\t \n\t\t\t\tgroup_id += ALH_MULTI_GTW_BASE;\n\t\t\t\tcopier_data->gtw_cfg.node_id &= ~SOF_IPC4_NODE_INDEX_MASK;\n\t\t\t\tcopier_data->gtw_cfg.node_id |= SOF_IPC4_NODE_INDEX(group_id);\n\t\t\t}\n\t\t}\n\t}\n\t}\n\n\t \n\tret = sof_ipc4_update_hw_params(sdev, pipeline_params, &copier_data->out_format);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_dai_in:\n\t\tcopier_data->gtw_cfg.dma_buffer_size =\n\t\t\tSOF_IPC4_MIN_DMA_BUFFER_SIZE * copier_data->base_config.ibs;\n\t\tbreak;\n\tcase snd_soc_dapm_aif_in:\n\t\t\tcopier_data->gtw_cfg.dma_buffer_size =\n\t\t\t\tmax((u32)SOF_IPC4_MIN_DMA_BUFFER_SIZE, deep_buffer_dma_ms) *\n\t\t\t\t\tcopier_data->base_config.ibs;\n\t\tbreak;\n\tcase snd_soc_dapm_dai_out:\n\tcase snd_soc_dapm_aif_out:\n\t\tcopier_data->gtw_cfg.dma_buffer_size =\n\t\t\tSOF_IPC4_MIN_DMA_BUFFER_SIZE * copier_data->base_config.obs;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdata = &ipc4_copier->copier_config;\n\tipc_config_size = &ipc4_copier->ipc_config_size;\n\tipc_config_data = &ipc4_copier->ipc_config_data;\n\n\t \n\tgtw_cfg_config_length = copier_data->gtw_cfg.config_length * 4;\n\tipc_size = sizeof(*copier_data) + gtw_cfg_config_length;\n\n\tif (ipc4_copier->dma_config_tlv.type == SOF_IPC4_GTW_DMA_CONFIG_ID &&\n\t    ipc4_copier->dma_config_tlv.length) {\n\t\tdma_config_tlv_size = sizeof(ipc4_copier->dma_config_tlv) +\n\t\t\tipc4_copier->dma_config_tlv.dma_config.dma_priv_config_size;\n\n\t\t \n\t\tif (dma_config_tlv_size != ipc4_copier->dma_config_tlv.length +\n\t\t    sizeof(uint32_t) * 2) {\n\t\t\tdev_err(sdev->dev, \"Invalid configuration, TLV size %d length %d\\n\",\n\t\t\t\tdma_config_tlv_size, ipc4_copier->dma_config_tlv.length);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tipc_size += dma_config_tlv_size;\n\n\t\t \n\t\tcopier_data->gtw_cfg.config_length += dma_config_tlv_size / 4;\n\t}\n\n\tdev_dbg(sdev->dev, \"copier %s, IPC size is %d\", swidget->widget->name, ipc_size);\n\n\t*ipc_config_data = kzalloc(ipc_size, GFP_KERNEL);\n\tif (!*ipc_config_data)\n\t\treturn -ENOMEM;\n\n\t*ipc_config_size = ipc_size;\n\n\t \n\tsof_ipc4_update_resource_usage(sdev, swidget, &copier_data->base_config);\n\n\t \n\tmemcpy(*ipc_config_data, (void *)copier_data, sizeof(*copier_data));\n\tif (gtw_cfg_config_length)\n\t\tmemcpy(*ipc_config_data + sizeof(*copier_data),\n\t\t       *data, gtw_cfg_config_length);\n\n\t \n\tif (dma_config_tlv_size)\n\t\tmemcpy(*ipc_config_data + sizeof(*copier_data) +\n\t\t       gtw_cfg_config_length,\n\t\t       &ipc4_copier->dma_config_tlv, dma_config_tlv_size);\n\n\t \n\tcopier_data->gtw_cfg.config_length = gtw_cfg_config_length / 4;\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_prepare_gain_module(struct snd_sof_widget *swidget,\n\t\t\t\t\tstruct snd_pcm_hw_params *fe_params,\n\t\t\t\t\tstruct snd_sof_platform_stream_params *platform_params,\n\t\t\t\t\tstruct snd_pcm_hw_params *pipeline_params, int dir)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_gain *gain = swidget->private;\n\tstruct sof_ipc4_available_audio_format *available_fmt = &gain->available_fmt;\n\tstruct sof_ipc4_audio_format *in_fmt;\n\tu32 out_ref_rate, out_ref_channels, out_ref_valid_bits;\n\tint ret;\n\n\tret = sof_ipc4_init_input_audio_fmt(sdev, swidget, &gain->data.base_config,\n\t\t\t\t\t    pipeline_params, available_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tin_fmt = &available_fmt->input_pin_fmts[ret].audio_fmt;\n\tout_ref_rate = in_fmt->sampling_frequency;\n\tout_ref_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(in_fmt->fmt_cfg);\n\tout_ref_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(in_fmt->fmt_cfg);\n\n\tret = sof_ipc4_init_output_audio_fmt(sdev, &gain->data.base_config, available_fmt,\n\t\t\t\t\t     out_ref_rate, out_ref_channels, out_ref_valid_bits);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"Failed to initialize output format for %s\",\n\t\t\tswidget->widget->name);\n\t\treturn ret;\n\t}\n\n\t \n\tsof_ipc4_update_resource_usage(sdev, swidget, &gain->data.base_config);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_prepare_mixer_module(struct snd_sof_widget *swidget,\n\t\t\t\t\t struct snd_pcm_hw_params *fe_params,\n\t\t\t\t\t struct snd_sof_platform_stream_params *platform_params,\n\t\t\t\t\t struct snd_pcm_hw_params *pipeline_params, int dir)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_mixer *mixer = swidget->private;\n\tstruct sof_ipc4_available_audio_format *available_fmt = &mixer->available_fmt;\n\tstruct sof_ipc4_audio_format *in_fmt;\n\tu32 out_ref_rate, out_ref_channels, out_ref_valid_bits;\n\tint ret;\n\n\tret = sof_ipc4_init_input_audio_fmt(sdev, swidget, &mixer->base_config,\n\t\t\t\t\t    pipeline_params, available_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tin_fmt = &available_fmt->input_pin_fmts[ret].audio_fmt;\n\tout_ref_rate = in_fmt->sampling_frequency;\n\tout_ref_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(in_fmt->fmt_cfg);\n\tout_ref_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(in_fmt->fmt_cfg);\n\n\tret = sof_ipc4_init_output_audio_fmt(sdev, &mixer->base_config, available_fmt,\n\t\t\t\t\t     out_ref_rate, out_ref_channels, out_ref_valid_bits);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"Failed to initialize output format for %s\",\n\t\t\tswidget->widget->name);\n\t\treturn ret;\n\t}\n\n\t \n\tsof_ipc4_update_resource_usage(sdev, swidget, &mixer->base_config);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_prepare_src_module(struct snd_sof_widget *swidget,\n\t\t\t\t       struct snd_pcm_hw_params *fe_params,\n\t\t\t\t       struct snd_sof_platform_stream_params *platform_params,\n\t\t\t\t       struct snd_pcm_hw_params *pipeline_params, int dir)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_src *src = swidget->private;\n\tstruct sof_ipc4_available_audio_format *available_fmt = &src->available_fmt;\n\tstruct sof_ipc4_audio_format *out_audio_fmt;\n\tstruct sof_ipc4_audio_format *in_audio_fmt;\n\tu32 out_ref_rate, out_ref_channels, out_ref_valid_bits;\n\tint output_format_index, input_format_index;\n\n\tinput_format_index = sof_ipc4_init_input_audio_fmt(sdev, swidget, &src->data.base_config,\n\t\t\t\t\t\t\t   pipeline_params, available_fmt);\n\tif (input_format_index < 0)\n\t\treturn input_format_index;\n\n\t \n\tif (dir == SNDRV_PCM_STREAM_PLAYBACK && available_fmt->num_output_formats > 1) {\n\t\tdev_err(sdev->dev, \"Invalid number of output formats: %d for SRC %s\\n\",\n\t\t\tavailable_fmt->num_output_formats, swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tin_audio_fmt = &available_fmt->input_pin_fmts[input_format_index].audio_fmt;\n\tout_ref_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(in_audio_fmt->fmt_cfg);\n\tout_ref_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(in_audio_fmt->fmt_cfg);\n\n\t \n\tout_ref_rate = params_rate(fe_params);\n\n\toutput_format_index = sof_ipc4_init_output_audio_fmt(sdev, &src->data.base_config,\n\t\t\t\t\t\t\t     available_fmt, out_ref_rate,\n\t\t\t\t\t\t\t     out_ref_channels, out_ref_valid_bits);\n\tif (output_format_index < 0) {\n\t\tdev_err(sdev->dev, \"Failed to initialize output format for %s\",\n\t\t\tswidget->widget->name);\n\t\treturn output_format_index;\n\t}\n\n\t \n\tsof_ipc4_update_resource_usage(sdev, swidget, &src->data.base_config);\n\n\tout_audio_fmt = &available_fmt->output_pin_fmts[output_format_index].audio_fmt;\n\tsrc->data.sink_rate = out_audio_fmt->sampling_frequency;\n\n\t \n\treturn sof_ipc4_update_hw_params(sdev, pipeline_params, out_audio_fmt);\n}\n\nstatic int\nsof_ipc4_process_set_pin_formats(struct snd_sof_widget *swidget, int pin_type)\n{\n\tstruct sof_ipc4_process *process = swidget->private;\n\tstruct sof_ipc4_base_module_cfg_ext *base_cfg_ext = process->base_config_ext;\n\tstruct sof_ipc4_available_audio_format *available_fmt = &process->available_fmt;\n\tstruct sof_ipc4_pin_format *pin_format, *format_list_to_search;\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tint num_pins, format_list_count;\n\tint pin_format_offset = 0;\n\tint i, j;\n\n\t \n\tif (pin_type == SOF_PIN_TYPE_INPUT) {\n\t\tnum_pins = swidget->num_input_pins;\n\t\tformat_list_to_search = available_fmt->input_pin_fmts;\n\t\tformat_list_count = available_fmt->num_input_formats;\n\t} else {\n\t\tnum_pins = swidget->num_output_pins;\n\t\tpin_format_offset = swidget->num_input_pins;\n\t\tformat_list_to_search = available_fmt->output_pin_fmts;\n\t\tformat_list_count = available_fmt->num_output_formats;\n\t}\n\n\tfor (i = pin_format_offset; i < num_pins + pin_format_offset; i++) {\n\t\tpin_format = &base_cfg_ext->pin_formats[i];\n\n\t\t \n\t\tif (i == pin_format_offset) {\n\t\t\tif (pin_type == SOF_PIN_TYPE_INPUT) {\n\t\t\t\tpin_format->buffer_size = process->base_config.ibs;\n\t\t\t\tpin_format->audio_fmt = process->base_config.audio_fmt;\n\t\t\t} else {\n\t\t\t\tpin_format->buffer_size = process->base_config.obs;\n\t\t\t\tpin_format->audio_fmt = process->output_format;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < format_list_count; j++) {\n\t\t\tstruct sof_ipc4_pin_format *pin_format_item = &format_list_to_search[j];\n\n\t\t\tif (pin_format_item->pin_index == i - pin_format_offset) {\n\t\t\t\t*pin_format = *pin_format_item;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j == format_list_count) {\n\t\t\tdev_err(scomp->dev, \"%s pin %d format not found for %s\\n\",\n\t\t\t\t(pin_type == SOF_PIN_TYPE_INPUT) ? \"input\" : \"output\",\n\t\t\t\ti - pin_format_offset, swidget->widget->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_process_add_base_cfg_extn(struct snd_sof_widget *swidget)\n{\n\tint ret, i;\n\n\t \n\tfor (i = 0; i <= SOF_PIN_TYPE_OUTPUT; i++) {\n\t\tret = sof_ipc4_process_set_pin_formats(swidget, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_prepare_process_module(struct snd_sof_widget *swidget,\n\t\t\t\t\t   struct snd_pcm_hw_params *fe_params,\n\t\t\t\t\t   struct snd_sof_platform_stream_params *platform_params,\n\t\t\t\t\t   struct snd_pcm_hw_params *pipeline_params, int dir)\n{\n\tstruct snd_soc_component *scomp = swidget->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_process *process = swidget->private;\n\tstruct sof_ipc4_available_audio_format *available_fmt = &process->available_fmt;\n\tstruct sof_ipc4_audio_format *in_fmt;\n\tu32 out_ref_rate, out_ref_channels, out_ref_valid_bits;\n\tvoid *cfg = process->ipc_config_data;\n\tint output_fmt_index;\n\tint ret;\n\n\tret = sof_ipc4_init_input_audio_fmt(sdev, swidget, &process->base_config,\n\t\t\t\t\t    pipeline_params, available_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tin_fmt = &available_fmt->input_pin_fmts[ret].audio_fmt;\n\tout_ref_rate = in_fmt->sampling_frequency;\n\tout_ref_channels = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(in_fmt->fmt_cfg);\n\tout_ref_valid_bits = SOF_IPC4_AUDIO_FORMAT_CFG_V_BIT_DEPTH(in_fmt->fmt_cfg);\n\n\toutput_fmt_index = sof_ipc4_init_output_audio_fmt(sdev, &process->base_config,\n\t\t\t\t\t\t\t  available_fmt, out_ref_rate,\n\t\t\t\t\t\t\t  out_ref_channels, out_ref_valid_bits);\n\tif (output_fmt_index < 0 && available_fmt->num_output_formats) {\n\t\tdev_err(sdev->dev, \"Failed to initialize output format for %s\",\n\t\t\tswidget->widget->name);\n\t\treturn output_fmt_index;\n\t}\n\n\t \n\tif (available_fmt->num_output_formats &&\n\t    output_fmt_index < available_fmt->num_output_formats &&\n\t    !available_fmt->output_pin_fmts[output_fmt_index].pin_index) {\n\t\tmemcpy(&process->output_format,\n\t\t       &available_fmt->output_pin_fmts[output_fmt_index].audio_fmt,\n\t\t       sizeof(struct sof_ipc4_audio_format));\n\n\t\t \n\t\tret = sof_ipc4_update_hw_params(sdev, pipeline_params, &process->output_format);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsof_ipc4_update_resource_usage(sdev, swidget, &process->base_config);\n\n\t \n\tmemcpy(cfg, &process->base_config, sizeof(struct sof_ipc4_base_module_cfg));\n\tcfg += sizeof(struct sof_ipc4_base_module_cfg);\n\n\tif (process->init_config == SOF_IPC4_MODULE_INIT_CONFIG_TYPE_BASE_CFG_WITH_EXT) {\n\t\tstruct sof_ipc4_base_module_cfg_ext *base_cfg_ext = process->base_config_ext;\n\n\t\tret = sof_ipc4_process_add_base_cfg_extn(swidget);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmemcpy(cfg, base_cfg_ext, process->base_config_ext_size);\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_control_load_volume(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc4_control_data *control_data;\n\tstruct sof_ipc4_msg *msg;\n\tint i;\n\n\tscontrol->size = struct_size(control_data, chanv, scontrol->num_channels);\n\n\t \n\tscontrol->ipc_control_data = kzalloc(scontrol->size, GFP_KERNEL);\n\tif (!scontrol->ipc_control_data)\n\t\treturn -ENOMEM;\n\n\tcontrol_data = scontrol->ipc_control_data;\n\tcontrol_data->index = scontrol->index;\n\n\tmsg = &control_data->msg;\n\tmsg->primary = SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_MOD_LARGE_CONFIG_SET);\n\tmsg->primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg->primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\tmsg->extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_GAIN_PARAM_ID);\n\n\t \n\tfor (i = 0; i < scontrol->num_channels; i++) {\n\t\tcontrol_data->chanv[i].channel = i;\n\t\tcontrol_data->chanv[i].value = SOF_IPC4_VOL_ZERO_DB;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_control_load_bytes(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tstruct sof_ipc4_control_data *control_data;\n\tstruct sof_ipc4_msg *msg;\n\tint ret;\n\n\tif (scontrol->max_size < (sizeof(*control_data) + sizeof(struct sof_abi_hdr))) {\n\t\tdev_err(sdev->dev, \"insufficient size for a bytes control %s: %zu.\\n\",\n\t\t\tscontrol->name, scontrol->max_size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (scontrol->priv_size > scontrol->max_size - sizeof(*control_data)) {\n\t\tdev_err(sdev->dev, \"scontrol %s bytes data size %zu exceeds max %zu.\\n\",\n\t\t\tscontrol->name, scontrol->priv_size,\n\t\t\tscontrol->max_size - sizeof(*control_data));\n\t\treturn -EINVAL;\n\t}\n\n\tscontrol->size = sizeof(struct sof_ipc4_control_data) + scontrol->priv_size;\n\n\tscontrol->ipc_control_data = kzalloc(scontrol->max_size, GFP_KERNEL);\n\tif (!scontrol->ipc_control_data)\n\t\treturn -ENOMEM;\n\n\tcontrol_data = scontrol->ipc_control_data;\n\tcontrol_data->index = scontrol->index;\n\tif (scontrol->priv_size > 0) {\n\t\tmemcpy(control_data->data, scontrol->priv, scontrol->priv_size);\n\t\tkfree(scontrol->priv);\n\t\tscontrol->priv = NULL;\n\n\t\tif (control_data->data->magic != SOF_IPC4_ABI_MAGIC) {\n\t\t\tdev_err(sdev->dev, \"Wrong ABI magic (%#x) for control: %s\\n\",\n\t\t\t\tcontrol_data->data->magic, scontrol->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\n\t\tif (control_data->data->size + sizeof(struct sof_abi_hdr) !=\n\t\t    scontrol->priv_size) {\n\t\t\tdev_err(sdev->dev, \"Control %s conflict in bytes %zu vs. priv size %zu.\\n\",\n\t\t\t\tscontrol->name,\n\t\t\t\tcontrol_data->data->size + sizeof(struct sof_abi_hdr),\n\t\t\t\tscontrol->priv_size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmsg = &control_data->msg;\n\tmsg->primary = SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_MOD_LARGE_CONFIG_SET);\n\tmsg->primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg->primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\treturn 0;\n\nerr:\n\tkfree(scontrol->ipc_control_data);\n\tscontrol->ipc_control_data = NULL;\n\treturn ret;\n}\n\nstatic int sof_ipc4_control_setup(struct snd_sof_dev *sdev, struct snd_sof_control *scontrol)\n{\n\tswitch (scontrol->info_type) {\n\tcase SND_SOC_TPLG_CTL_VOLSW:\n\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\treturn sof_ipc4_control_load_volume(sdev, scontrol);\n\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\treturn sof_ipc4_control_load_bytes(sdev, scontrol);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_widget_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tstruct snd_sof_widget *pipe_widget = swidget->spipe->pipe_widget;\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_pipeline *pipeline;\n\tstruct sof_ipc4_msg *msg;\n\tvoid *ipc_data = NULL;\n\tu32 ipc_size = 0;\n\tint ret;\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_scheduler:\n\t\tpipeline = swidget->private;\n\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tdev_warn(sdev->dev, \"use_chain_dma set for scheduler %s\",\n\t\t\t\t swidget->widget->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_dbg(sdev->dev, \"pipeline: %d memory pages: %d\\n\", swidget->pipeline_id,\n\t\t\tpipeline->mem_usage);\n\n\t\tmsg = &pipeline->msg;\n\t\tmsg->primary |= pipeline->mem_usage;\n\n\t\tswidget->instance_id = ida_alloc_max(&pipeline_ida, ipc4_data->max_num_pipelines,\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (swidget->instance_id < 0) {\n\t\t\tdev_err(sdev->dev, \"failed to assign pipeline id for %s: %d\\n\",\n\t\t\t\tswidget->widget->name, swidget->instance_id);\n\t\t\treturn swidget->instance_id;\n\t\t}\n\t\tmsg->primary &= ~SOF_IPC4_GLB_PIPE_INSTANCE_MASK;\n\t\tmsg->primary |= SOF_IPC4_GLB_PIPE_INSTANCE_ID(swidget->instance_id);\n\t\tbreak;\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_buffer:\n\t{\n\t\tstruct sof_ipc4_copier *ipc4_copier = swidget->private;\n\n\t\tpipeline = pipe_widget->private;\n\t\tif (pipeline->use_chain_dma)\n\t\t\treturn 0;\n\n\t\tipc_size = ipc4_copier->ipc_config_size;\n\t\tipc_data = ipc4_copier->ipc_config_data;\n\n\t\tmsg = &ipc4_copier->msg;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t{\n\t\tstruct snd_sof_dai *dai = swidget->private;\n\t\tstruct sof_ipc4_copier *ipc4_copier = dai->private;\n\n\t\tpipeline = pipe_widget->private;\n\t\tif (pipeline->use_chain_dma)\n\t\t\treturn 0;\n\n\t\tipc_size = ipc4_copier->ipc_config_size;\n\t\tipc_data = ipc4_copier->ipc_config_data;\n\n\t\tmsg = &ipc4_copier->msg;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_pga:\n\t{\n\t\tstruct sof_ipc4_gain *gain = swidget->private;\n\n\t\tipc_size = sizeof(gain->data);\n\t\tipc_data = &gain->data;\n\n\t\tmsg = &gain->msg;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_mixer:\n\t{\n\t\tstruct sof_ipc4_mixer *mixer = swidget->private;\n\n\t\tipc_size = sizeof(mixer->base_config);\n\t\tipc_data = &mixer->base_config;\n\n\t\tmsg = &mixer->msg;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_src:\n\t{\n\t\tstruct sof_ipc4_src *src = swidget->private;\n\n\t\tipc_size = sizeof(src->data);\n\t\tipc_data = &src->data;\n\n\t\tmsg = &src->msg;\n\t\tbreak;\n\t}\n\tcase snd_soc_dapm_effect:\n\t{\n\t\tstruct sof_ipc4_process *process = swidget->private;\n\n\t\tif (!process->ipc_config_size) {\n\t\t\tdev_err(sdev->dev, \"module %s has no config data!\\n\",\n\t\t\t\tswidget->widget->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tipc_size = process->ipc_config_size;\n\t\tipc_data = process->ipc_config_data;\n\n\t\tmsg = &process->msg;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tdev_err(sdev->dev, \"widget type %d not supported\", swidget->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (swidget->id != snd_soc_dapm_scheduler) {\n\t\tret = sof_ipc4_widget_assign_instance_id(sdev, swidget);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"failed to assign instance id for %s\\n\",\n\t\t\t\tswidget->widget->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmsg->primary &= ~SOF_IPC4_MOD_INSTANCE_MASK;\n\t\tmsg->primary |= SOF_IPC4_MOD_INSTANCE(swidget->instance_id);\n\n\t\tmsg->extension &= ~SOF_IPC4_MOD_EXT_PARAM_SIZE_MASK;\n\t\tmsg->extension |= ipc_size >> 2;\n\n\t\tmsg->extension &= ~SOF_IPC4_MOD_EXT_PPL_ID_MASK;\n\t\tmsg->extension |= SOF_IPC4_MOD_EXT_PPL_ID(pipe_widget->instance_id);\n\t}\n\tdev_dbg(sdev->dev, \"Create widget %s instance %d - pipe %d - core %d\\n\",\n\t\tswidget->widget->name, swidget->instance_id, swidget->pipeline_id, swidget->core);\n\n\tmsg->data_size = ipc_size;\n\tmsg->data_ptr = ipc_data;\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, msg, ipc_size);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to create module %s\\n\", swidget->widget->name);\n\n\t\tif (swidget->id != snd_soc_dapm_scheduler) {\n\t\t\tstruct sof_ipc4_fw_module *fw_module = swidget->module_info;\n\n\t\t\tida_free(&fw_module->m_ida, swidget->instance_id);\n\t\t} else {\n\t\t\tida_free(&pipeline_ida, swidget->instance_id);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sof_ipc4_widget_free(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)\n{\n\tstruct sof_ipc4_fw_module *fw_module = swidget->module_info;\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tint ret = 0;\n\n\tmutex_lock(&ipc4_data->pipeline_state_mutex);\n\n\t \n\tif (swidget->id == snd_soc_dapm_scheduler) {\n\t\tstruct sof_ipc4_pipeline *pipeline = swidget->private;\n\t\tstruct sof_ipc4_msg msg = {{ 0 }};\n\t\tu32 header;\n\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tdev_warn(sdev->dev, \"use_chain_dma set for scheduler %s\",\n\t\t\t\t swidget->widget->name);\n\t\t\tmutex_unlock(&ipc4_data->pipeline_state_mutex);\n\t\t\treturn 0;\n\t\t}\n\n\t\theader = SOF_IPC4_GLB_PIPE_INSTANCE_ID(swidget->instance_id);\n\t\theader |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_DELETE_PIPELINE);\n\t\theader |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\t\theader |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\n\t\tmsg.primary = header;\n\n\t\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"failed to free pipeline widget %s\\n\",\n\t\t\t\tswidget->widget->name);\n\n\t\tpipeline->mem_usage = 0;\n\t\tpipeline->state = SOF_IPC4_PIPE_UNINITIALIZED;\n\t\tida_free(&pipeline_ida, swidget->instance_id);\n\t\tswidget->instance_id = -EINVAL;\n\t} else {\n\t\tstruct snd_sof_widget *pipe_widget = swidget->spipe->pipe_widget;\n\t\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\n\t\tif (!pipeline->use_chain_dma)\n\t\t\tida_free(&fw_module->m_ida, swidget->instance_id);\n\t}\n\n\tmutex_unlock(&ipc4_data->pipeline_state_mutex);\n\n\treturn ret;\n}\n\nstatic int sof_ipc4_get_queue_id(struct snd_sof_widget *src_widget,\n\t\t\t\t struct snd_sof_widget *sink_widget, bool pin_type)\n{\n\tstruct snd_sof_widget *current_swidget;\n\tstruct snd_soc_component *scomp;\n\tstruct ida *queue_ida;\n\tconst char *buddy_name;\n\tchar **pin_binding;\n\tu32 num_pins;\n\tint i;\n\n\tif (pin_type == SOF_PIN_TYPE_OUTPUT) {\n\t\tcurrent_swidget = src_widget;\n\t\tpin_binding = src_widget->output_pin_binding;\n\t\tqueue_ida = &src_widget->output_queue_ida;\n\t\tnum_pins = src_widget->num_output_pins;\n\t\tbuddy_name = sink_widget->widget->name;\n\t} else {\n\t\tcurrent_swidget = sink_widget;\n\t\tpin_binding = sink_widget->input_pin_binding;\n\t\tqueue_ida = &sink_widget->input_queue_ida;\n\t\tnum_pins = sink_widget->num_input_pins;\n\t\tbuddy_name = src_widget->widget->name;\n\t}\n\n\tscomp = current_swidget->scomp;\n\n\tif (num_pins < 1) {\n\t\tdev_err(scomp->dev, \"invalid %s num_pins: %d for queue allocation for %s\\n\",\n\t\t\t(pin_type == SOF_PIN_TYPE_OUTPUT ? \"output\" : \"input\"),\n\t\t\tnum_pins, current_swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (num_pins == 1)\n\t\treturn 0;\n\n\t \n\tif (pin_binding) {\n\t\tfor (i = 0; i < num_pins; i++) {\n\t\t\tif (!strcmp(pin_binding[i], buddy_name))\n\t\t\t\treturn i;\n\t\t}\n\t\t \n\t\tdev_err(scomp->dev, \"no %s queue id found from pin binding array for %s\\n\",\n\t\t\t(pin_type == SOF_PIN_TYPE_OUTPUT ? \"output\" : \"input\"),\n\t\t\tcurrent_swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn ida_alloc_max(queue_ida, num_pins, GFP_KERNEL);\n}\n\nstatic void sof_ipc4_put_queue_id(struct snd_sof_widget *swidget, int queue_id,\n\t\t\t\t  bool pin_type)\n{\n\tstruct ida *queue_ida;\n\tchar **pin_binding;\n\tint num_pins;\n\n\tif (pin_type == SOF_PIN_TYPE_OUTPUT) {\n\t\tpin_binding = swidget->output_pin_binding;\n\t\tqueue_ida = &swidget->output_queue_ida;\n\t\tnum_pins = swidget->num_output_pins;\n\t} else {\n\t\tpin_binding = swidget->input_pin_binding;\n\t\tqueue_ida = &swidget->input_queue_ida;\n\t\tnum_pins = swidget->num_input_pins;\n\t}\n\n\t \n\tif (num_pins == 1 || pin_binding)\n\t\treturn;\n\n\tida_free(queue_ida, queue_id);\n}\n\nstatic int sof_ipc4_set_copier_sink_format(struct snd_sof_dev *sdev,\n\t\t\t\t\t   struct snd_sof_widget *src_widget,\n\t\t\t\t\t   struct snd_sof_widget *sink_widget,\n\t\t\t\t\t   int sink_id)\n{\n\tstruct sof_ipc4_copier_config_set_sink_format format;\n\tconst struct sof_ipc_ops *iops = sdev->ipc->ops;\n\tstruct sof_ipc4_base_module_cfg *src_config;\n\tconst struct sof_ipc4_audio_format *pin_fmt;\n\tstruct sof_ipc4_fw_module *fw_module;\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\n\tdev_dbg(sdev->dev, \"%s set copier sink %d format\\n\",\n\t\tsrc_widget->widget->name, sink_id);\n\n\tif (WIDGET_IS_DAI(src_widget->id)) {\n\t\tstruct snd_sof_dai *dai = src_widget->private;\n\n\t\tsrc_config = dai->private;\n\t} else {\n\t\tsrc_config = src_widget->private;\n\t}\n\n\tfw_module = src_widget->module_info;\n\n\tformat.sink_id = sink_id;\n\tmemcpy(&format.source_fmt, &src_config->audio_fmt, sizeof(format.source_fmt));\n\n\tpin_fmt = sof_ipc4_get_input_pin_audio_fmt(sink_widget, sink_id);\n\tif (!pin_fmt) {\n\t\tdev_err(sdev->dev, \"Unable to get pin %d format for %s\",\n\t\t\tsink_id, sink_widget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&format.sink_fmt, pin_fmt, sizeof(format.sink_fmt));\n\n\tmsg.data_size = sizeof(format);\n\tmsg.data_ptr = &format;\n\n\tmsg.primary = fw_module->man4_module_entry.id;\n\tmsg.primary |= SOF_IPC4_MOD_INSTANCE(src_widget->instance_id);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\tmsg.extension =\n\t\tSOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_COPIER_MODULE_CFG_PARAM_SET_SINK_FORMAT);\n\n\treturn iops->set_get_data(sdev, &msg, msg.data_size, true);\n}\n\nstatic int sof_ipc4_route_setup(struct snd_sof_dev *sdev, struct snd_sof_route *sroute)\n{\n\tstruct snd_sof_widget *src_widget = sroute->src_widget;\n\tstruct snd_sof_widget *sink_widget = sroute->sink_widget;\n\tstruct snd_sof_widget *src_pipe_widget = src_widget->spipe->pipe_widget;\n\tstruct snd_sof_widget *sink_pipe_widget = sink_widget->spipe->pipe_widget;\n\tstruct sof_ipc4_fw_module *src_fw_module = src_widget->module_info;\n\tstruct sof_ipc4_fw_module *sink_fw_module = sink_widget->module_info;\n\tstruct sof_ipc4_pipeline *src_pipeline = src_pipe_widget->private;\n\tstruct sof_ipc4_pipeline *sink_pipeline = sink_pipe_widget->private;\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\tu32 header, extension;\n\tint ret;\n\n\t \n\tif (src_pipeline->use_chain_dma || sink_pipeline->use_chain_dma) {\n\t\tif (!src_pipeline->use_chain_dma || !sink_pipeline->use_chain_dma) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"use_chain_dma must be set for both src %s and sink %s pipelines\\n\",\n\t\t\t\tsrc_widget->widget->name, sink_widget->widget->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!src_fw_module || !sink_fw_module) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"cannot bind %s -> %s, no firmware module for: %s%s\\n\",\n\t\t\tsrc_widget->widget->name, sink_widget->widget->name,\n\t\t\tsrc_fw_module ? \"\" : \" source\",\n\t\t\tsink_fw_module ? \"\" : \" sink\");\n\n\t\treturn -ENODEV;\n\t}\n\n\tsroute->src_queue_id = sof_ipc4_get_queue_id(src_widget, sink_widget,\n\t\t\t\t\t\t     SOF_PIN_TYPE_OUTPUT);\n\tif (sroute->src_queue_id < 0) {\n\t\tdev_err(sdev->dev, \"failed to get queue ID for source widget: %s\\n\",\n\t\t\tsrc_widget->widget->name);\n\t\treturn sroute->src_queue_id;\n\t}\n\n\tsroute->dst_queue_id = sof_ipc4_get_queue_id(src_widget, sink_widget,\n\t\t\t\t\t\t     SOF_PIN_TYPE_INPUT);\n\tif (sroute->dst_queue_id < 0) {\n\t\tdev_err(sdev->dev, \"failed to get queue ID for sink widget: %s\\n\",\n\t\t\tsink_widget->widget->name);\n\t\tsof_ipc4_put_queue_id(src_widget, sroute->src_queue_id,\n\t\t\t\t      SOF_PIN_TYPE_OUTPUT);\n\t\treturn sroute->dst_queue_id;\n\t}\n\n\t \n\tif (sroute->src_queue_id > 0 && WIDGET_IS_COPIER(src_widget->id)) {\n\t\tret = sof_ipc4_set_copier_sink_format(sdev, src_widget, sink_widget,\n\t\t\t\t\t\t      sroute->src_queue_id);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"failed to set sink format for %s source queue ID %d\\n\",\n\t\t\t\tsrc_widget->widget->name, sroute->src_queue_id);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_dbg(sdev->dev, \"bind %s:%d -> %s:%d\\n\",\n\t\tsrc_widget->widget->name, sroute->src_queue_id,\n\t\tsink_widget->widget->name, sroute->dst_queue_id);\n\n\theader = src_fw_module->man4_module_entry.id;\n\theader |= SOF_IPC4_MOD_INSTANCE(src_widget->instance_id);\n\theader |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_MOD_BIND);\n\theader |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\theader |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\textension = sink_fw_module->man4_module_entry.id;\n\textension |= SOF_IPC4_MOD_EXT_DST_MOD_INSTANCE(sink_widget->instance_id);\n\textension |= SOF_IPC4_MOD_EXT_DST_MOD_QUEUE_ID(sroute->dst_queue_id);\n\textension |= SOF_IPC4_MOD_EXT_SRC_MOD_QUEUE_ID(sroute->src_queue_id);\n\n\tmsg.primary = header;\n\tmsg.extension = extension;\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to bind modules %s:%d -> %s:%d\\n\",\n\t\t\tsrc_widget->widget->name, sroute->src_queue_id,\n\t\t\tsink_widget->widget->name, sroute->dst_queue_id);\n\t\tgoto out;\n\t}\n\n\treturn ret;\n\nout:\n\tsof_ipc4_put_queue_id(src_widget, sroute->src_queue_id, SOF_PIN_TYPE_OUTPUT);\n\tsof_ipc4_put_queue_id(sink_widget, sroute->dst_queue_id, SOF_PIN_TYPE_INPUT);\n\treturn ret;\n}\n\nstatic int sof_ipc4_route_free(struct snd_sof_dev *sdev, struct snd_sof_route *sroute)\n{\n\tstruct snd_sof_widget *src_widget = sroute->src_widget;\n\tstruct snd_sof_widget *sink_widget = sroute->sink_widget;\n\tstruct sof_ipc4_fw_module *src_fw_module = src_widget->module_info;\n\tstruct sof_ipc4_fw_module *sink_fw_module = sink_widget->module_info;\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\tstruct snd_sof_widget *src_pipe_widget = src_widget->spipe->pipe_widget;\n\tstruct snd_sof_widget *sink_pipe_widget = sink_widget->spipe->pipe_widget;\n\tstruct sof_ipc4_pipeline *src_pipeline = src_pipe_widget->private;\n\tstruct sof_ipc4_pipeline *sink_pipeline = sink_pipe_widget->private;\n\tu32 header, extension;\n\tint ret = 0;\n\n\t \n\tif (src_pipeline->use_chain_dma || sink_pipeline->use_chain_dma)\n\t\treturn 0;\n\n\tdev_dbg(sdev->dev, \"unbind modules %s:%d -> %s:%d\\n\",\n\t\tsrc_widget->widget->name, sroute->src_queue_id,\n\t\tsink_widget->widget->name, sroute->dst_queue_id);\n\n\t \n\tif (src_widget->spipe->pipe_widget == sink_widget->spipe->pipe_widget)\n\t\tgoto out;\n\n\theader = src_fw_module->man4_module_entry.id;\n\theader |= SOF_IPC4_MOD_INSTANCE(src_widget->instance_id);\n\theader |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_MOD_UNBIND);\n\theader |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\theader |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);\n\n\textension = sink_fw_module->man4_module_entry.id;\n\textension |= SOF_IPC4_MOD_EXT_DST_MOD_INSTANCE(sink_widget->instance_id);\n\textension |= SOF_IPC4_MOD_EXT_DST_MOD_QUEUE_ID(sroute->dst_queue_id);\n\textension |= SOF_IPC4_MOD_EXT_SRC_MOD_QUEUE_ID(sroute->src_queue_id);\n\n\tmsg.primary = header;\n\tmsg.extension = extension;\n\n\tret = sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"failed to unbind modules %s:%d -> %s:%d\\n\",\n\t\t\tsrc_widget->widget->name, sroute->src_queue_id,\n\t\t\tsink_widget->widget->name, sroute->dst_queue_id);\nout:\n\tsof_ipc4_put_queue_id(sink_widget, sroute->dst_queue_id, SOF_PIN_TYPE_INPUT);\n\tsof_ipc4_put_queue_id(src_widget, sroute->src_queue_id, SOF_PIN_TYPE_OUTPUT);\n\n\treturn ret;\n}\n\nstatic int sof_ipc4_dai_config(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,\n\t\t\t       unsigned int flags, struct snd_sof_dai_config_data *data)\n{\n\tstruct snd_sof_widget *pipe_widget = swidget->spipe->pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\tstruct snd_sof_dai *dai = swidget->private;\n\tstruct sof_ipc4_gtw_attributes *gtw_attr;\n\tstruct sof_ipc4_copier_data *copier_data;\n\tstruct sof_ipc4_copier *ipc4_copier;\n\n\tif (!dai || !dai->private) {\n\t\tdev_err(sdev->dev, \"Invalid DAI or DAI private data for %s\\n\",\n\t\t\tswidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\tipc4_copier = (struct sof_ipc4_copier *)dai->private;\n\tcopier_data = &ipc4_copier->data;\n\n\tif (!data)\n\t\treturn 0;\n\n\tswitch (ipc4_copier->dai_type) {\n\tcase SOF_DAI_INTEL_HDA:\n\t\tif (pipeline->use_chain_dma) {\n\t\t\tpipeline->msg.primary &= ~SOF_IPC4_GLB_CHAIN_DMA_LINK_ID_MASK;\n\t\t\tpipeline->msg.primary |= SOF_IPC4_GLB_CHAIN_DMA_LINK_ID(data->dai_data);\n\t\t\tbreak;\n\t\t}\n\t\tgtw_attr = ipc4_copier->gtw_attr;\n\t\tgtw_attr->lp_buffer_alloc = pipeline->lp_mode;\n\t\tfallthrough;\n\tcase SOF_DAI_INTEL_ALH:\n\t\t \n\t\tif (flags & SOF_DAI_CONFIG_FLAGS_HW_PARAMS) {\n\t\t\tcopier_data->gtw_cfg.node_id &= ~SOF_IPC4_NODE_INDEX_MASK;\n\t\t\tcopier_data->gtw_cfg.node_id |= SOF_IPC4_NODE_INDEX(data->dai_data);\n\t\t}\n\t\tbreak;\n\tcase SOF_DAI_INTEL_DMIC:\n\tcase SOF_DAI_INTEL_SSP:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"%s: unsupported dai type %d\\n\", __func__,\n\t\t\tipc4_copier->dai_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_parse_manifest(struct snd_soc_component *scomp, int index,\n\t\t\t\t   struct snd_soc_tplg_manifest *man)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_manifest_tlv *manifest_tlv;\n\tstruct sof_manifest *manifest;\n\tu32 size = le32_to_cpu(man->priv.size);\n\tu8 *man_ptr = man->priv.data;\n\tu32 len_check;\n\tint i;\n\n\tif (!size || size < SOF_IPC4_TPLG_ABI_SIZE) {\n\t\tdev_err(scomp->dev, \"%s: Invalid topology ABI size: %u\\n\",\n\t\t\t__func__, size);\n\t\treturn -EINVAL;\n\t}\n\n\tmanifest = (struct sof_manifest *)man_ptr;\n\n\tdev_info(scomp->dev,\n\t\t \"Topology: ABI %d:%d:%d Kernel ABI %u:%u:%u\\n\",\n\t\t  le16_to_cpu(manifest->abi_major), le16_to_cpu(manifest->abi_minor),\n\t\t  le16_to_cpu(manifest->abi_patch),\n\t\t  SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);\n\n\t \n\n\t \n\tif (size <= SOF_IPC4_TPLG_ABI_SIZE)\n\t\treturn 0;\n\n\tmanifest_tlv = manifest->items;\n\tlen_check = sizeof(struct sof_manifest);\n\tfor (i = 0; i < le16_to_cpu(manifest->count); i++) {\n\t\tlen_check += sizeof(struct sof_manifest_tlv) + le32_to_cpu(manifest_tlv->size);\n\t\tif (len_check > size)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (le32_to_cpu(manifest_tlv->type)) {\n\t\tcase SOF_MANIFEST_DATA_TYPE_NHLT:\n\t\t\t \n\t\t\tif (ipc4_data->nhlt)\n\t\t\t\tbreak;\n\t\t\tipc4_data->nhlt = devm_kmemdup(sdev->dev, manifest_tlv->data,\n\t\t\t\t\t\t       le32_to_cpu(manifest_tlv->size), GFP_KERNEL);\n\t\t\tif (!ipc4_data->nhlt)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(scomp->dev, \"Skipping unknown manifest data type %d\\n\",\n\t\t\t\t manifest_tlv->type);\n\t\t\tbreak;\n\t\t}\n\t\tman_ptr += sizeof(struct sof_manifest_tlv) + le32_to_cpu(manifest_tlv->size);\n\t\tmanifest_tlv = (struct sof_manifest_tlv *)man_ptr;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_dai_get_clk(struct snd_sof_dev *sdev, struct snd_sof_dai *dai, int clk_type)\n{\n\tstruct sof_ipc4_copier *ipc4_copier = dai->private;\n\tstruct snd_soc_tplg_hw_config *hw_config;\n\tstruct snd_sof_dai_link *slink;\n\tbool dai_link_found = false;\n\tbool hw_cfg_found = false;\n\tint i;\n\n\tif (!ipc4_copier)\n\t\treturn 0;\n\n\tlist_for_each_entry(slink, &sdev->dai_link_list, list) {\n\t\tif (!strcmp(slink->link->name, dai->name)) {\n\t\t\tdai_link_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dai_link_found) {\n\t\tdev_err(sdev->dev, \"no DAI link found for DAI %s\\n\", dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < slink->num_hw_configs; i++) {\n\t\thw_config = &slink->hw_configs[i];\n\t\tif (dai->current_config == le32_to_cpu(hw_config->id)) {\n\t\t\thw_cfg_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!hw_cfg_found) {\n\t\tdev_err(sdev->dev, \"no matching hw_config found for DAI %s\\n\", dai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ipc4_copier->dai_type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\tswitch (clk_type) {\n\t\tcase SOF_DAI_CLK_INTEL_SSP_MCLK:\n\t\t\treturn le32_to_cpu(hw_config->mclk_rate);\n\t\tcase SOF_DAI_CLK_INTEL_SSP_BCLK:\n\t\t\treturn le32_to_cpu(hw_config->bclk_rate);\n\t\tdefault:\n\t\t\tdev_err(sdev->dev, \"Invalid clk type for SSP %d\\n\", clk_type);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"DAI type %d not supported yet!\\n\", ipc4_copier->dai_type);\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sof_ipc4_tear_down_all_pipelines(struct snd_sof_dev *sdev, bool verify)\n{\n\tstruct snd_sof_pcm *spcm;\n\tint dir, ret;\n\n\t \n\tlist_for_each_entry(spcm, &sdev->pcm_list, list) {\n\t\tfor_each_pcm_streams(dir) {\n\t\t\tstruct snd_pcm_substream *substream = spcm->stream[dir].substream;\n\n\t\t\tif (!substream || !substream->runtime || spcm->stream[dir].suspend_ignored)\n\t\t\t\tcontinue;\n\n\t\t\tif (spcm->stream[dir].list) {\n\t\t\t\tret = sof_pcm_stream_free(sdev, substream, spcm, dir, true);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sof_ipc4_link_setup(struct snd_sof_dev *sdev, struct snd_soc_dai_link *link)\n{\n\tif (link->no_pcm)\n\t\treturn 0;\n\n\t \n\tlink->trigger[SNDRV_PCM_STREAM_PLAYBACK] = SND_SOC_DPCM_TRIGGER_POST;\n\tlink->trigger[SNDRV_PCM_STREAM_CAPTURE] = SND_SOC_DPCM_TRIGGER_PRE;\n\n\treturn 0;\n}\n\nstatic enum sof_tokens common_copier_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COPIER_DEEP_BUFFER_TOKENS,\n\tSOF_COPIER_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic enum sof_tokens pipeline_token_list[] = {\n\tSOF_SCHED_TOKENS,\n\tSOF_PIPELINE_TOKENS,\n};\n\nstatic enum sof_tokens dai_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COPIER_TOKENS,\n\tSOF_DAI_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic enum sof_tokens pga_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_GAIN_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic enum sof_tokens mixer_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic enum sof_tokens src_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_SRC_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic enum sof_tokens process_token_list[] = {\n\tSOF_COMP_TOKENS,\n\tSOF_AUDIO_FMT_NUM_TOKENS,\n\tSOF_IN_AUDIO_FORMAT_TOKENS,\n\tSOF_OUT_AUDIO_FORMAT_TOKENS,\n\tSOF_COMP_EXT_TOKENS,\n};\n\nstatic const struct sof_ipc_tplg_widget_ops tplg_ipc4_widget_ops[SND_SOC_DAPM_TYPE_COUNT] = {\n\t[snd_soc_dapm_aif_in] =  {sof_ipc4_widget_setup_pcm, sof_ipc4_widget_free_comp_pcm,\n\t\t\t\t  common_copier_token_list, ARRAY_SIZE(common_copier_token_list),\n\t\t\t\t  NULL, sof_ipc4_prepare_copier_module,\n\t\t\t\t  sof_ipc4_unprepare_copier_module},\n\t[snd_soc_dapm_aif_out] = {sof_ipc4_widget_setup_pcm, sof_ipc4_widget_free_comp_pcm,\n\t\t\t\t  common_copier_token_list, ARRAY_SIZE(common_copier_token_list),\n\t\t\t\t  NULL, sof_ipc4_prepare_copier_module,\n\t\t\t\t  sof_ipc4_unprepare_copier_module},\n\t[snd_soc_dapm_dai_in] = {sof_ipc4_widget_setup_comp_dai, sof_ipc4_widget_free_comp_dai,\n\t\t\t\t dai_token_list, ARRAY_SIZE(dai_token_list), NULL,\n\t\t\t\t sof_ipc4_prepare_copier_module,\n\t\t\t\t sof_ipc4_unprepare_copier_module},\n\t[snd_soc_dapm_dai_out] = {sof_ipc4_widget_setup_comp_dai, sof_ipc4_widget_free_comp_dai,\n\t\t\t\t  dai_token_list, ARRAY_SIZE(dai_token_list), NULL,\n\t\t\t\t  sof_ipc4_prepare_copier_module,\n\t\t\t\t  sof_ipc4_unprepare_copier_module},\n\t[snd_soc_dapm_buffer] = {sof_ipc4_widget_setup_pcm, sof_ipc4_widget_free_comp_pcm,\n\t\t\t\t common_copier_token_list, ARRAY_SIZE(common_copier_token_list),\n\t\t\t\t NULL, sof_ipc4_prepare_copier_module,\n\t\t\t\t sof_ipc4_unprepare_copier_module},\n\t[snd_soc_dapm_scheduler] = {sof_ipc4_widget_setup_comp_pipeline,\n\t\t\t\t    sof_ipc4_widget_free_comp_pipeline,\n\t\t\t\t    pipeline_token_list, ARRAY_SIZE(pipeline_token_list), NULL,\n\t\t\t\t    NULL, NULL},\n\t[snd_soc_dapm_pga] = {sof_ipc4_widget_setup_comp_pga, sof_ipc4_widget_free_comp_pga,\n\t\t\t      pga_token_list, ARRAY_SIZE(pga_token_list), NULL,\n\t\t\t      sof_ipc4_prepare_gain_module,\n\t\t\t      NULL},\n\t[snd_soc_dapm_mixer] = {sof_ipc4_widget_setup_comp_mixer, sof_ipc4_widget_free_comp_mixer,\n\t\t\t\tmixer_token_list, ARRAY_SIZE(mixer_token_list),\n\t\t\t\tNULL, sof_ipc4_prepare_mixer_module,\n\t\t\t\tNULL},\n\t[snd_soc_dapm_src] = {sof_ipc4_widget_setup_comp_src, sof_ipc4_widget_free_comp_src,\n\t\t\t\tsrc_token_list, ARRAY_SIZE(src_token_list),\n\t\t\t\tNULL, sof_ipc4_prepare_src_module,\n\t\t\t\tNULL},\n\t[snd_soc_dapm_effect] = {sof_ipc4_widget_setup_comp_process,\n\t\t\t\tsof_ipc4_widget_free_comp_process,\n\t\t\t\tprocess_token_list, ARRAY_SIZE(process_token_list),\n\t\t\t\tNULL, sof_ipc4_prepare_process_module,\n\t\t\t\tNULL},\n};\n\nconst struct sof_ipc_tplg_ops ipc4_tplg_ops = {\n\t.widget = tplg_ipc4_widget_ops,\n\t.token_list = ipc4_token_list,\n\t.control_setup = sof_ipc4_control_setup,\n\t.control = &tplg_ipc4_control_ops,\n\t.widget_setup = sof_ipc4_widget_setup,\n\t.widget_free = sof_ipc4_widget_free,\n\t.route_setup = sof_ipc4_route_setup,\n\t.route_free = sof_ipc4_route_free,\n\t.dai_config = sof_ipc4_dai_config,\n\t.parse_manifest = sof_ipc4_parse_manifest,\n\t.dai_get_clk = sof_ipc4_dai_get_clk,\n\t.tear_down_all_pipelines = sof_ipc4_tear_down_all_pipelines,\n\t.link_setup = sof_ipc4_link_setup,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}