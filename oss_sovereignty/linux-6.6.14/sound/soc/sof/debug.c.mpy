{
  "module_name": "debug.c",
  "hash_id": "bb73f4a1fc14a384fdc52acfa858105b35ba8654052567ca6d042e0f2dab97cb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/debug.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <sound/sof/ext_manifest.h>\n#include <sound/sof/debug.h>\n#include \"sof-priv.h\"\n#include \"ops.h\"\n\nstatic ssize_t sof_dfsentry_write(struct file *file, const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tsize_t size;\n\tchar *string;\n\tint ret;\n\n\tstring = kzalloc(count+1, GFP_KERNEL);\n\tif (!string)\n\t\treturn -ENOMEM;\n\n\tsize = simple_write_to_buffer(string, count, ppos, buffer, count);\n\tret = size;\n\n\tkfree(string);\n\treturn ret;\n}\n\nstatic ssize_t sof_dfsentry_read(struct file *file, char __user *buffer,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tloff_t pos = *ppos;\n\tsize_t size_ret;\n\tint skip = 0;\n\tint size;\n\tu8 *buf;\n\n\tsize = dfse->size;\n\n\t \n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= size || !count)\n\t\treturn 0;\n\t \n\tif (count > size - pos)\n\t\tcount = size - pos;\n\n\t \n\tpos = ALIGN_DOWN(pos, 4);\n\n\t \n\tsize = ALIGN(count, 4);\n\n\t \n\tif (unlikely(pos != *ppos)) {\n\t\tskip = *ppos - pos;\n\t\tif (pos + size + 4 < dfse->size)\n\t\t\tsize += 4;\n\t}\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (dfse->type == SOF_DFSENTRY_TYPE_IOMEM) {\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t\t \n\t\tif (pm_runtime_active(sdev->dev) ||\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_ALWAYS) {\n\t\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n\t\t} else {\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Copying cached debugfs data\\n\");\n\t\t\tmemcpy(buf, dfse->cache_buf + pos, size);\n\t\t}\n#else\n\t\t \n\t\tif (!pm_runtime_active(sdev->dev) &&\n\t\t    dfse->access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"error: debugfs entry cannot be read in DSP D3\\n\");\n\t\t\tkfree(buf);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy_fromio(buf, dfse->io_mem + pos, size);\n#endif\n\t} else {\n\t\tmemcpy(buf, ((u8 *)(dfse->buf) + pos), size);\n\t}\n\n\t \n\tsize_ret = copy_to_user(buffer, buf + skip, count);\n\n\tkfree(buf);\n\n\t \n\tif (size_ret)\n\t\treturn -EFAULT;\n\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic const struct file_operations sof_dfs_fops = {\n\t.open = simple_open,\n\t.read = sof_dfsentry_read,\n\t.llseek = default_llseek,\n\t.write = sof_dfsentry_write,\n};\n\n \nstatic int snd_sof_debugfs_io_item(struct snd_sof_dev *sdev,\n\t\t\t\t   void __iomem *base, size_t size,\n\t\t\t\t   const char *name,\n\t\t\t\t   enum sof_debugfs_access_type access_type)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_IOMEM;\n\tdfse->io_mem = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\tdfse->access_type = access_type;\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)\n\t \n\tif (access_type == SOF_DEBUGFS_ACCESS_D0_ONLY) {\n\t\tdfse->cache_buf = devm_kzalloc(sdev->dev, size, GFP_KERNEL);\n\t\tif (!dfse->cache_buf)\n\t\t\treturn -ENOMEM;\n\t}\n#endif\n\n\tdebugfs_create_file(name, 0444, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\n\t \n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\n\nint snd_sof_debugfs_add_region_item_iomem(struct snd_sof_dev *sdev,\n\t\t\t\t\t  enum snd_sof_fw_blk_type blk_type, u32 offset,\n\t\t\t\t\t  size_t size, const char *name,\n\t\t\t\t\t  enum sof_debugfs_access_type access_type)\n{\n\tint bar = snd_sof_dsp_get_bar_index(sdev, blk_type);\n\n\tif (bar < 0)\n\t\treturn bar;\n\n\treturn snd_sof_debugfs_io_item(sdev, sdev->bar[bar] + offset, size, name,\n\t\t\t\t       access_type);\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_add_region_item_iomem);\n\n \nint snd_sof_debugfs_buf_item(struct snd_sof_dev *sdev,\n\t\t\t     void *base, size_t size,\n\t\t\t     const char *name, mode_t mode)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tif (!sdev)\n\t\treturn -EINVAL;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\tdfse->buf = base;\n\tdfse->size = size;\n\tdfse->sdev = sdev;\n\n\tdebugfs_create_file(name, mode, sdev->debugfs_root, dfse,\n\t\t\t    &sof_dfs_fops);\n\t \n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_debugfs_buf_item);\n\nstatic int memory_info_update(struct snd_sof_dev *sdev, char *buf, size_t buff_size)\n{\n\tstruct sof_ipc_cmd_hdr msg = {\n\t\t.size = sizeof(struct sof_ipc_cmd_hdr),\n\t\t.cmd = SOF_IPC_GLB_DEBUG | SOF_IPC_DEBUG_MEM_USAGE,\n\t};\n\tstruct sof_ipc_dbg_mem_usage *reply;\n\tint len;\n\tint ret;\n\tint i;\n\n\treply = kmalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!reply)\n\t\treturn -ENOMEM;\n\n\tret = pm_runtime_resume_and_get(sdev->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err(sdev->dev, \"error: enabling device failed: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tret = sof_ipc_tx_message(sdev->ipc, &msg, msg.size, reply, SOF_IPC_MSG_MAX_SIZE);\n\tpm_runtime_mark_last_busy(sdev->dev);\n\tpm_runtime_put_autosuspend(sdev->dev);\n\tif (ret < 0 || reply->rhdr.error < 0) {\n\t\tret = min(ret, reply->rhdr.error);\n\t\tdev_err(sdev->dev, \"error: reading memory info failed, %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (struct_size(reply, elems, reply->num_elems) != reply->rhdr.hdr.size) {\n\t\tdev_err(sdev->dev, \"error: invalid memory info ipc struct size, %d\\n\",\n\t\t\treply->rhdr.hdr.size);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tfor (i = 0, len = 0; i < reply->num_elems; i++) {\n\t\tret = scnprintf(buf + len, buff_size - len, \"zone %d.%d used %#8x free %#8x\\n\",\n\t\t\t\treply->elems[i].zone, reply->elems[i].id,\n\t\t\t\treply->elems[i].used, reply->elems[i].free);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tlen += ret;\n\t}\n\n\tret = len;\nerror:\n\tkfree(reply);\n\treturn ret;\n}\n\nstatic ssize_t memory_info_read(struct file *file, char __user *to, size_t count, loff_t *ppos)\n{\n\tstruct snd_sof_dfsentry *dfse = file->private_data;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\tint data_length;\n\n\t \n\tif (!*ppos) {\n\t\tdfse->buf_data_size = 0;\n\t\tdata_length = memory_info_update(sdev, dfse->buf, dfse->size);\n\t\tif (data_length < 0)\n\t\t\treturn data_length;\n\t\tdfse->buf_data_size = data_length;\n\t}\n\n\treturn simple_read_from_buffer(to, count, ppos, dfse->buf, dfse->buf_data_size);\n}\n\nstatic int memory_info_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_sof_dfsentry *dfse = inode->i_private;\n\tstruct snd_sof_dev *sdev = dfse->sdev;\n\n\tfile->private_data = dfse;\n\n\t \n\tif (!dfse->buf) {\n\t\tdfse->buf = devm_kmalloc(sdev->dev, PAGE_SIZE, GFP_KERNEL);\n\t\tif (!dfse->buf)\n\t\t\treturn -ENOMEM;\n\t\tdfse->size = PAGE_SIZE;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct file_operations memory_info_fops = {\n\t.open = memory_info_open,\n\t.read = memory_info_read,\n\t.llseek = default_llseek,\n};\n\nint snd_sof_dbg_memory_info_init(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_dfsentry *dfse;\n\n\tdfse = devm_kzalloc(sdev->dev, sizeof(*dfse), GFP_KERNEL);\n\tif (!dfse)\n\t\treturn -ENOMEM;\n\n\t \n\tdfse->type = SOF_DFSENTRY_TYPE_BUF;\n\tdfse->sdev = sdev;\n\n\tdebugfs_create_file(\"memory_info\", 0444, sdev->debugfs_root, dfse, &memory_info_fops);\n\n\t \n\tlist_add(&dfse->list, &sdev->dfsentry_list);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_sof_dbg_memory_info_init);\n\nint snd_sof_dbg_init(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_dsp_ops *ops = sof_ops(sdev);\n\tconst struct snd_sof_debugfs_map *map;\n\tint i;\n\tint err;\n\n\t \n\tsdev->debugfs_root = debugfs_create_dir(\"sof\", NULL);\n\n\t \n\tINIT_LIST_HEAD(&sdev->dfsentry_list);\n\n\t \n\tfor (i = 0; i < ops->debug_map_count; i++) {\n\t\tmap = &ops->debug_map[i];\n\n\t\terr = snd_sof_debugfs_io_item(sdev, sdev->bar[map->bar] +\n\t\t\t\t\t      map->offset, map->size,\n\t\t\t\t\t      map->name, map->access_type);\n\t\t \n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn snd_sof_debugfs_buf_item(sdev, &sdev->fw_state,\n\t\t\t\t\tsizeof(sdev->fw_state),\n\t\t\t\t\t\"fw_state\", 0444);\n}\nEXPORT_SYMBOL_GPL(snd_sof_dbg_init);\n\nvoid snd_sof_free_debug(struct snd_sof_dev *sdev)\n{\n\tdebugfs_remove_recursive(sdev->debugfs_root);\n}\nEXPORT_SYMBOL_GPL(snd_sof_free_debug);\n\nstatic const struct soc_fw_state_info {\n\tenum sof_fw_state state;\n\tconst char *name;\n} fw_state_dbg[] = {\n\t{SOF_FW_BOOT_NOT_STARTED, \"SOF_FW_BOOT_NOT_STARTED\"},\n\t{SOF_DSPLESS_MODE, \"SOF_DSPLESS_MODE\"},\n\t{SOF_FW_BOOT_PREPARE, \"SOF_FW_BOOT_PREPARE\"},\n\t{SOF_FW_BOOT_IN_PROGRESS, \"SOF_FW_BOOT_IN_PROGRESS\"},\n\t{SOF_FW_BOOT_FAILED, \"SOF_FW_BOOT_FAILED\"},\n\t{SOF_FW_BOOT_READY_FAILED, \"SOF_FW_BOOT_READY_FAILED\"},\n\t{SOF_FW_BOOT_READY_OK, \"SOF_FW_BOOT_READY_OK\"},\n\t{SOF_FW_BOOT_COMPLETE, \"SOF_FW_BOOT_COMPLETE\"},\n\t{SOF_FW_CRASHED, \"SOF_FW_CRASHED\"},\n};\n\nstatic void snd_sof_dbg_print_fw_state(struct snd_sof_dev *sdev, const char *level)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_state_dbg); i++) {\n\t\tif (sdev->fw_state == fw_state_dbg[i].state) {\n\t\t\tdev_printk(level, sdev->dev, \"fw_state: %s (%d)\\n\",\n\t\t\t\t   fw_state_dbg[i].name, i);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_printk(level, sdev->dev, \"fw_state: UNKNOWN (%d)\\n\", sdev->fw_state);\n}\n\nvoid snd_sof_dsp_dbg_dump(struct snd_sof_dev *sdev, const char *msg, u32 flags)\n{\n\tchar *level = (flags & SOF_DBG_DUMP_OPTIONAL) ? KERN_DEBUG : KERN_ERR;\n\tbool print_all = sof_debug_check_flag(SOF_DBG_PRINT_ALL_DUMPS);\n\n\tif (flags & SOF_DBG_DUMP_OPTIONAL && !print_all)\n\t\treturn;\n\n\tif (sof_ops(sdev)->dbg_dump && !sdev->dbg_dump_printed) {\n\t\tdev_printk(level, sdev->dev,\n\t\t\t   \"------------[ DSP dump start ]------------\\n\");\n\t\tif (msg)\n\t\t\tdev_printk(level, sdev->dev, \"%s\\n\", msg);\n\t\tsnd_sof_dbg_print_fw_state(sdev, level);\n\t\tsof_ops(sdev)->dbg_dump(sdev, flags);\n\t\tdev_printk(level, sdev->dev,\n\t\t\t   \"------------[ DSP dump end ]------------\\n\");\n\t\tif (!print_all)\n\t\t\tsdev->dbg_dump_printed = true;\n\t} else if (msg) {\n\t\tdev_printk(level, sdev->dev, \"%s\\n\", msg);\n\t}\n}\nEXPORT_SYMBOL(snd_sof_dsp_dbg_dump);\n\nstatic void snd_sof_ipc_dump(struct snd_sof_dev *sdev)\n{\n\tif (sof_ops(sdev)->ipc_dump  && !sdev->ipc_dump_printed) {\n\t\tdev_err(sdev->dev, \"------------[ IPC dump start ]------------\\n\");\n\t\tsof_ops(sdev)->ipc_dump(sdev);\n\t\tdev_err(sdev->dev, \"------------[ IPC dump end ]------------\\n\");\n\t\tif (!sof_debug_check_flag(SOF_DBG_PRINT_ALL_DUMPS))\n\t\t\tsdev->ipc_dump_printed = true;\n\t}\n}\n\nvoid snd_sof_handle_fw_exception(struct snd_sof_dev *sdev, const char *msg)\n{\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_RETAIN_DSP_CONTEXT) ||\n\t    sof_debug_check_flag(SOF_DBG_RETAIN_CTX)) {\n\t\t \n\t\tif (!sdev->ipc_dump_printed)\n\t\t\tdev_info(sdev->dev,\n\t\t\t\t \"Attempting to prevent DSP from entering D3 state to preserve context\\n\");\n\t\tpm_runtime_get_if_in_use(sdev->dev);\n\t}\n\n\t \n\tsnd_sof_ipc_dump(sdev);\n\tsnd_sof_dsp_dbg_dump(sdev, msg, SOF_DBG_DUMP_REGS | SOF_DBG_DUMP_MBOX);\n\tsof_fw_trace_fw_crashed(sdev);\n}\nEXPORT_SYMBOL(snd_sof_handle_fw_exception);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}