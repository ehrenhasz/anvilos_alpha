{
  "module_name": "ipc3.c",
  "hash_id": "ed582af254f9e5185cdbb9f92a4baf10d0fc1b268b4b1805fc93a2ad2f486feb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc3.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <sound/sof/stream.h>\n#include <sound/sof/control.h>\n#include <trace/events/sof.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ipc3-priv.h\"\n#include \"ops.h\"\n\ntypedef void (*ipc3_rx_callback)(struct snd_sof_dev *sdev, void *msg_buf);\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_VERBOSE_IPC)\nstatic void ipc3_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tu8 *str;\n\tu8 *str2 = NULL;\n\tu32 glb;\n\tu32 type;\n\tbool is_sof_ipc_stream_position = false;\n\n\tglb = cmd & SOF_GLB_TYPE_MASK;\n\ttype = cmd & SOF_CMD_TYPE_MASK;\n\n\tswitch (glb) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tstr = \"GLB_REPLY\"; break;\n\tcase SOF_IPC_GLB_COMPOUND:\n\t\tstr = \"GLB_COMPOUND\"; break;\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\t\tstr = \"GLB_TPLG_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TPLG_COMP_NEW:\n\t\t\tstr2 = \"COMP_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_FREE:\n\t\t\tstr2 = \"COMP_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_COMP_CONNECT:\n\t\t\tstr2 = \"COMP_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_NEW:\n\t\t\tstr2 = \"PIPE_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_FREE:\n\t\t\tstr2 = \"PIPE_FREE\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_CONNECT:\n\t\t\tstr2 = \"PIPE_CONNECT\"; break;\n\t\tcase SOF_IPC_TPLG_PIPE_COMPLETE:\n\t\t\tstr2 = \"PIPE_COMPLETE\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_NEW:\n\t\t\tstr2 = \"BUFFER_NEW\"; break;\n\t\tcase SOF_IPC_TPLG_BUFFER_FREE:\n\t\t\tstr2 = \"BUFFER_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_PM_MSG:\n\t\tstr = \"GLB_PM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_PM_CTX_SAVE:\n\t\t\tstr2 = \"CTX_SAVE\"; break;\n\t\tcase SOF_IPC_PM_CTX_RESTORE:\n\t\t\tstr2 = \"CTX_RESTORE\"; break;\n\t\tcase SOF_IPC_PM_CTX_SIZE:\n\t\t\tstr2 = \"CTX_SIZE\"; break;\n\t\tcase SOF_IPC_PM_CLK_SET:\n\t\t\tstr2 = \"CLK_SET\"; break;\n\t\tcase SOF_IPC_PM_CLK_GET:\n\t\t\tstr2 = \"CLK_GET\"; break;\n\t\tcase SOF_IPC_PM_CLK_REQ:\n\t\t\tstr2 = \"CLK_REQ\"; break;\n\t\tcase SOF_IPC_PM_CORE_ENABLE:\n\t\t\tstr2 = \"CORE_ENABLE\"; break;\n\t\tcase SOF_IPC_PM_GATE:\n\t\t\tstr2 = \"GATE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\tstr = \"GLB_COMP_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_COMP_SET_VALUE:\n\t\t\tstr2 = \"SET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_GET_VALUE:\n\t\t\tstr2 = \"GET_VALUE\"; break;\n\t\tcase SOF_IPC_COMP_SET_DATA:\n\t\t\tstr2 = \"SET_DATA\"; break;\n\t\tcase SOF_IPC_COMP_GET_DATA:\n\t\t\tstr2 = \"GET_DATA\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\tstr = \"GLB_STREAM_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS:\n\t\t\tstr2 = \"PCM_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_PARAMS_REPLY:\n\t\t\tstr2 = \"PCM_REPLY\"; break;\n\t\tcase SOF_IPC_STREAM_PCM_FREE:\n\t\t\tstr2 = \"PCM_FREE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_START:\n\t\t\tstr2 = \"TRIG_START\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_STOP:\n\t\t\tstr2 = \"TRIG_STOP\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_PAUSE:\n\t\t\tstr2 = \"TRIG_PAUSE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_RELEASE:\n\t\t\tstr2 = \"TRIG_RELEASE\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_DRAIN:\n\t\t\tstr2 = \"TRIG_DRAIN\"; break;\n\t\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\t\tstr2 = \"TRIG_XRUN\"; break;\n\t\tcase SOF_IPC_STREAM_POSITION:\n\t\t\tis_sof_ipc_stream_position = true;\n\t\t\tstr2 = \"POSITION\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_PARAMS:\n\t\t\tstr2 = \"VORBIS_PARAMS\"; break;\n\t\tcase SOF_IPC_STREAM_VORBIS_FREE:\n\t\t\tstr2 = \"VORBIS_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\tstr = \"FW_READY\"; break;\n\tcase SOF_IPC_GLB_DAI_MSG:\n\t\tstr = \"GLB_DAI_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_DAI_CONFIG:\n\t\t\tstr2 = \"CONFIG\"; break;\n\t\tcase SOF_IPC_DAI_LOOPBACK:\n\t\t\tstr2 = \"LOOPBACK\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\tstr = \"GLB_TRACE_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TRACE_DMA_PARAMS:\n\t\t\tstr2 = \"DMA_PARAMS\"; break;\n\t\tcase SOF_IPC_TRACE_DMA_POSITION:\n\t\t\tif (!sof_debug_check_flag(SOF_DBG_PRINT_DMA_POSITION_UPDATE_LOGS))\n\t\t\t\treturn;\n\t\t\tstr2 = \"DMA_POSITION\"; break;\n\t\tcase SOF_IPC_TRACE_DMA_PARAMS_EXT:\n\t\t\tstr2 = \"DMA_PARAMS_EXT\"; break;\n\t\tcase SOF_IPC_TRACE_FILTER_UPDATE:\n\t\t\tstr2 = \"FILTER_UPDATE\"; break;\n\t\tcase SOF_IPC_TRACE_DMA_FREE:\n\t\t\tstr2 = \"DMA_FREE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_TEST_MSG:\n\t\tstr = \"GLB_TEST_MSG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_TEST_IPC_FLOOD:\n\t\t\tstr2 = \"IPC_FLOOD\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_DEBUG:\n\t\tstr = \"GLB_DEBUG\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_DEBUG_MEM_USAGE:\n\t\t\tstr2 = \"MEM_USAGE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_PROBE:\n\t\tstr = \"GLB_PROBE\";\n\t\tswitch (type) {\n\t\tcase SOF_IPC_PROBE_INIT:\n\t\t\tstr2 = \"INIT\"; break;\n\t\tcase SOF_IPC_PROBE_DEINIT:\n\t\t\tstr2 = \"DEINIT\"; break;\n\t\tcase SOF_IPC_PROBE_DMA_ADD:\n\t\t\tstr2 = \"DMA_ADD\"; break;\n\t\tcase SOF_IPC_PROBE_DMA_INFO:\n\t\t\tstr2 = \"DMA_INFO\"; break;\n\t\tcase SOF_IPC_PROBE_DMA_REMOVE:\n\t\t\tstr2 = \"DMA_REMOVE\"; break;\n\t\tcase SOF_IPC_PROBE_POINT_ADD:\n\t\t\tstr2 = \"POINT_ADD\"; break;\n\t\tcase SOF_IPC_PROBE_POINT_INFO:\n\t\t\tstr2 = \"POINT_INFO\"; break;\n\t\tcase SOF_IPC_PROBE_POINT_REMOVE:\n\t\t\tstr2 = \"POINT_REMOVE\"; break;\n\t\tdefault:\n\t\t\tstr2 = \"unknown type\"; break;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstr = \"unknown GLB command\"; break;\n\t}\n\n\tif (str2) {\n\t\tif (is_sof_ipc_stream_position)\n\t\t\ttrace_sof_stream_position_ipc_rx(dev);\n\t\telse\n\t\t\tdev_dbg(dev, \"%s: 0x%x: %s: %s\\n\", text, cmd, str, str2);\n\t} else {\n\t\tdev_dbg(dev, \"%s: 0x%x: %s\\n\", text, cmd, str);\n\t}\n}\n#else\nstatic inline void ipc3_log_header(struct device *dev, u8 *text, u32 cmd)\n{\n\tif ((cmd & SOF_GLB_TYPE_MASK) != SOF_IPC_GLB_TRACE_MSG)\n\t\tdev_dbg(dev, \"%s: 0x%x\\n\", text, cmd);\n}\n#endif\n\nstatic void sof_ipc3_dump_payload(struct snd_sof_dev *sdev,\n\t\t\t\t  void *ipc_data, size_t size)\n{\n\tprintk(KERN_DEBUG \"Size of payload following the header: %zu\\n\", size);\n\tprint_hex_dump_debug(\"Message payload: \", DUMP_PREFIX_OFFSET,\n\t\t\t     16, 4, ipc_data, size, false);\n}\n\nstatic int sof_ipc3_get_reply(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc_msg *msg = sdev->msg;\n\tstruct sof_ipc_reply *reply;\n\tint ret = 0;\n\n\t \n\treply = msg->reply_data;\n\tsnd_sof_dsp_mailbox_read(sdev, sdev->host_box.offset, reply, sizeof(*reply));\n\n\tif (reply->error < 0)\n\t\treturn reply->error;\n\n\tif (!reply->hdr.size) {\n\t\t \n\t\tif (msg->reply_size)\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"empty reply received, expected %zu bytes\\n\",\n\t\t\t\tmsg->reply_size);\n\t\telse\n\t\t\tdev_err(sdev->dev, \"empty reply received\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (msg->reply_size > 0) {\n\t\tif (reply->hdr.size == msg->reply_size) {\n\t\t\tret = 0;\n\t\t} else if (reply->hdr.size < msg->reply_size) {\n\t\t\tdev_dbg(sdev->dev,\n\t\t\t\t\"reply size (%u) is less than expected (%zu)\\n\",\n\t\t\t\treply->hdr.size, msg->reply_size);\n\n\t\t\tmsg->reply_size = reply->hdr.size;\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"reply size (%u) exceeds the buffer size (%zu)\\n\",\n\t\t\t\treply->hdr.size, msg->reply_size);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (!ret && msg->reply_size > sizeof(*reply))\n\t\t\tsnd_sof_dsp_mailbox_read(sdev, sdev->host_box.offset,\n\t\t\t\t\t\t msg->reply_data, msg->reply_size);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ipc3_wait_tx_done(struct snd_sof_ipc *ipc, void *reply_data)\n{\n\tstruct snd_sof_ipc_msg *msg = &ipc->msg;\n\tstruct sof_ipc_cmd_hdr *hdr = msg->msg_data;\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tint ret;\n\n\t \n\tret = wait_event_timeout(msg->waitq, msg->ipc_complete,\n\t\t\t\t msecs_to_jiffies(sdev->ipc_timeout));\n\n\tif (ret == 0) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"ipc tx timed out for %#x (msg/reply size: %d/%zu)\\n\",\n\t\t\thdr->cmd, hdr->size, msg->reply_size);\n\t\tsnd_sof_handle_fw_exception(ipc->sdev, \"IPC timeout\");\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = msg->reply_error;\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"ipc tx error for %#x (msg/reply size: %d/%zu): %d\\n\",\n\t\t\t\thdr->cmd, hdr->size, msg->reply_size, ret);\n\t\t} else {\n\t\t\tif (sof_debug_check_flag(SOF_DBG_PRINT_IPC_SUCCESS_LOGS))\n\t\t\t\tipc3_log_header(sdev->dev, \"ipc tx succeeded\", hdr->cmd);\n\t\t\tif (reply_data && msg->reply_size)\n\t\t\t\t \n\t\t\t\tmemcpy(reply_data, msg->reply_data,\n\t\t\t\t       msg->reply_size);\n\t\t}\n\n\t\t \n\t\tif (sdev->ipc_dump_printed) {\n\t\t\tsdev->dbg_dump_printed = false;\n\t\t\tsdev->ipc_dump_printed = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ipc3_tx_msg_unlocked(struct snd_sof_ipc *ipc,\n\t\t\t\tvoid *msg_data, size_t msg_bytes,\n\t\t\t\tvoid *reply_data, size_t reply_bytes)\n{\n\tstruct sof_ipc_cmd_hdr *hdr = msg_data;\n\tstruct snd_sof_dev *sdev = ipc->sdev;\n\tint ret;\n\n\tipc3_log_header(sdev->dev, \"ipc tx\", hdr->cmd);\n\n\tret = sof_ipc_send_msg(sdev, msg_data, msg_bytes, reply_bytes);\n\n\tif (ret) {\n\t\tdev_err_ratelimited(sdev->dev,\n\t\t\t\t    \"%s: ipc message send for %#x failed: %d\\n\",\n\t\t\t\t    __func__, hdr->cmd, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn ipc3_wait_tx_done(ipc, reply_data);\n}\n\nstatic int sof_ipc3_tx_msg(struct snd_sof_dev *sdev, void *msg_data, size_t msg_bytes,\n\t\t\t   void *reply_data, size_t reply_bytes, bool no_pm)\n{\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\tint ret;\n\n\tif (!msg_data || msg_bytes < sizeof(struct sof_ipc_cmd_hdr)) {\n\t\tdev_err_ratelimited(sdev->dev, \"No IPC message to send\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!no_pm) {\n\t\tconst struct sof_dsp_power_state target_state = {\n\t\t\t.state = SOF_DSP_PM_D0,\n\t\t};\n\n\t\t \n\t\tret = snd_sof_dsp_set_power_state(sdev, &target_state);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"%s: resuming DSP failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&ipc->tx_mutex);\n\n\tret = ipc3_tx_msg_unlocked(ipc, msg_data, msg_bytes, reply_data, reply_bytes);\n\n\tif (sof_debug_check_flag(SOF_DBG_DUMP_IPC_MESSAGE_PAYLOAD)) {\n\t\tsize_t payload_bytes, header_bytes;\n\t\tchar *payload = NULL;\n\n\t\t \n\t\tif (msg_bytes > sizeof(struct sof_ipc_cmd_hdr)) {\n\t\t\tpayload = msg_data;\n\n\t\t\theader_bytes = sizeof(struct sof_ipc_cmd_hdr);\n\t\t\tpayload_bytes = msg_bytes - header_bytes;\n\t\t} else if (reply_bytes > sizeof(struct sof_ipc_reply)) {\n\t\t\tpayload = reply_data;\n\n\t\t\theader_bytes = sizeof(struct sof_ipc_reply);\n\t\t\tpayload_bytes = reply_bytes - header_bytes;\n\t\t}\n\n\t\tif (payload) {\n\t\t\tpayload += header_bytes;\n\t\t\tsof_ipc3_dump_payload(sdev, payload, payload_bytes);\n\t\t}\n\t}\n\n\tmutex_unlock(&ipc->tx_mutex);\n\n\treturn ret;\n}\n\nstatic int sof_ipc3_set_get_data(struct snd_sof_dev *sdev, void *data, size_t data_bytes,\n\t\t\t\t bool set)\n{\n\tsize_t msg_bytes, hdr_bytes, payload_size, send_bytes;\n\tstruct sof_ipc_ctrl_data *cdata = data;\n\tstruct sof_ipc_ctrl_data *cdata_chunk;\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\tsize_t offset = 0;\n\tu8 *src, *dst;\n\tu32 num_msg;\n\tint ret = 0;\n\tint i;\n\n\tif (!cdata || data_bytes < sizeof(*cdata))\n\t\treturn -EINVAL;\n\n\tif ((cdata->rhdr.hdr.cmd & SOF_GLB_TYPE_MASK) != SOF_IPC_GLB_COMP_MSG) {\n\t\tdev_err(sdev->dev, \"%s: Not supported message type of %#x\\n\",\n\t\t\t__func__, cdata->rhdr.hdr.cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cdata->rhdr.hdr.size <= ipc->max_payload_size)\n\t\treturn sof_ipc3_tx_msg(sdev, cdata, cdata->rhdr.hdr.size,\n\t\t\t\t       cdata, cdata->rhdr.hdr.size, false);\n\n\tcdata_chunk = kzalloc(ipc->max_payload_size, GFP_KERNEL);\n\tif (!cdata_chunk)\n\t\treturn -ENOMEM;\n\n\tswitch (cdata->type) {\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_GET:\n\tcase SOF_CTRL_TYPE_VALUE_CHAN_SET:\n\t\thdr_bytes = sizeof(struct sof_ipc_ctrl_data);\n\t\tif (set) {\n\t\t\tsrc = (u8 *)cdata->chanv;\n\t\t\tdst = (u8 *)cdata_chunk->chanv;\n\t\t} else {\n\t\t\tsrc = (u8 *)cdata_chunk->chanv;\n\t\t\tdst = (u8 *)cdata->chanv;\n\t\t}\n\t\tbreak;\n\tcase SOF_CTRL_TYPE_DATA_GET:\n\tcase SOF_CTRL_TYPE_DATA_SET:\n\t\thdr_bytes = sizeof(struct sof_ipc_ctrl_data) + sizeof(struct sof_abi_hdr);\n\t\tif (set) {\n\t\t\tsrc = (u8 *)cdata->data->data;\n\t\t\tdst = (u8 *)cdata_chunk->data->data;\n\t\t} else {\n\t\t\tsrc = (u8 *)cdata_chunk->data->data;\n\t\t\tdst = (u8 *)cdata->data->data;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tkfree(cdata_chunk);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg_bytes = cdata->rhdr.hdr.size - hdr_bytes;\n\tpayload_size = ipc->max_payload_size - hdr_bytes;\n\tnum_msg = DIV_ROUND_UP(msg_bytes, payload_size);\n\n\t \n\tmemcpy(cdata_chunk, cdata, hdr_bytes);\n\n\t \n\tmutex_lock(&sdev->ipc->tx_mutex);\n\n\t \n\tfor (i = 0; i < num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, payload_size);\n\t\tcdata_chunk->num_elems = send_bytes;\n\t\tcdata_chunk->rhdr.hdr.size = hdr_bytes + send_bytes;\n\t\tcdata_chunk->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tcdata_chunk->elems_remaining = msg_bytes;\n\n\t\tif (set)\n\t\t\tmemcpy(dst, src + offset, send_bytes);\n\n\t\tret = ipc3_tx_msg_unlocked(sdev->ipc,\n\t\t\t\t\t   cdata_chunk, cdata_chunk->rhdr.hdr.size,\n\t\t\t\t\t   cdata_chunk, cdata_chunk->rhdr.hdr.size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (!set)\n\t\t\tmemcpy(dst + offset, src, send_bytes);\n\n\t\toffset += payload_size;\n\t}\n\n\tif (sof_debug_check_flag(SOF_DBG_DUMP_IPC_MESSAGE_PAYLOAD)) {\n\t\tsize_t header_bytes = sizeof(struct sof_ipc_reply);\n\t\tchar *payload = (char *)cdata;\n\n\t\tpayload += header_bytes;\n\t\tsof_ipc3_dump_payload(sdev, payload, data_bytes - header_bytes);\n\t}\n\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\n\tkfree(cdata_chunk);\n\n\treturn ret;\n}\n\nint sof_ipc3_get_ext_windows(struct snd_sof_dev *sdev,\n\t\t\t     const struct sof_ipc_ext_data_hdr *ext_hdr)\n{\n\tconst struct sof_ipc_window *w =\n\t\tcontainer_of(ext_hdr, struct sof_ipc_window, ext_hdr);\n\n\tif (w->num_windows == 0 || w->num_windows > SOF_IPC_MAX_ELEMS)\n\t\treturn -EINVAL;\n\n\tif (sdev->info_window) {\n\t\tif (memcmp(sdev->info_window, w, ext_hdr->hdr.size)) {\n\t\t\tdev_err(sdev->dev, \"mismatch between window descriptor from extended manifest and mailbox\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tsdev->info_window = devm_kmemdup(sdev->dev, w, ext_hdr->hdr.size, GFP_KERNEL);\n\tif (!sdev->info_window)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint sof_ipc3_get_cc_info(struct snd_sof_dev *sdev,\n\t\t\t const struct sof_ipc_ext_data_hdr *ext_hdr)\n{\n\tint ret;\n\n\tconst struct sof_ipc_cc_version *cc =\n\t\tcontainer_of(ext_hdr, struct sof_ipc_cc_version, ext_hdr);\n\n\tif (sdev->cc_version) {\n\t\tif (memcmp(sdev->cc_version, cc, cc->ext_hdr.hdr.size)) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"Receive diverged cc_version descriptions\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tdev_dbg(sdev->dev,\n\t\t\"Firmware info: used compiler %s %d:%d:%d%s used optimization flags %s\\n\",\n\t\tcc->name, cc->major, cc->minor, cc->micro, cc->desc, cc->optim);\n\n\t \n\t \n\tif (sdev->first_boot) {\n\t\tsdev->cc_version = devm_kmemdup(sdev->dev, cc, cc->ext_hdr.hdr.size, GFP_KERNEL);\n\t\tif (!sdev->cc_version)\n\t\t\treturn -ENOMEM;\n\n\t\tret = snd_sof_debugfs_buf_item(sdev, sdev->cc_version,\n\t\t\t\t\t       cc->ext_hdr.hdr.size,\n\t\t\t\t\t       \"cc_version\", 0444);\n\n\t\t \n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"snd_sof_debugfs_buf_item failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ipc3_fw_parse_ext_data(struct snd_sof_dev *sdev, u32 offset)\n{\n\tstruct sof_ipc_ext_data_hdr *ext_hdr;\n\tvoid *ext_data;\n\tint ret = 0;\n\n\text_data = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!ext_data)\n\t\treturn -ENOMEM;\n\n\t \n\tsnd_sof_dsp_block_read(sdev, SOF_FW_BLK_TYPE_SRAM, offset, ext_data,\n\t\t\t       sizeof(*ext_hdr));\n\text_hdr = ext_data;\n\n\twhile (ext_hdr->hdr.cmd == SOF_IPC_FW_READY) {\n\t\t \n\t\tsnd_sof_dsp_block_read(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t       offset + sizeof(*ext_hdr),\n\t\t\t\t       (void *)((u8 *)ext_data + sizeof(*ext_hdr)),\n\t\t\t\t       ext_hdr->hdr.size - sizeof(*ext_hdr));\n\n\t\tdev_dbg(sdev->dev, \"found ext header type %d size 0x%x\\n\",\n\t\t\text_hdr->type, ext_hdr->hdr.size);\n\n\t\t \n\t\tswitch (ext_hdr->type) {\n\t\tcase SOF_IPC_EXT_WINDOW:\n\t\t\tret = sof_ipc3_get_ext_windows(sdev, ext_hdr);\n\t\t\tbreak;\n\t\tcase SOF_IPC_EXT_CC_INFO:\n\t\t\tret = sof_ipc3_get_cc_info(sdev, ext_hdr);\n\t\t\tbreak;\n\t\tcase SOF_IPC_EXT_UNUSED:\n\t\tcase SOF_IPC_EXT_PROBE_INFO:\n\t\tcase SOF_IPC_EXT_USER_ABI_INFO:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(sdev->dev, \"unknown ext header type %d size 0x%x\\n\",\n\t\t\t\t ext_hdr->type, ext_hdr->hdr.size);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"Failed to parse ext data type %d\\n\",\n\t\t\t\text_hdr->type);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\toffset += ext_hdr->hdr.size;\n\t\tsnd_sof_dsp_block_read(sdev, SOF_FW_BLK_TYPE_SRAM, offset, ext_data,\n\t\t\t\t       sizeof(*ext_hdr));\n\t\text_hdr = ext_data;\n\t}\n\n\tkfree(ext_data);\n\treturn ret;\n}\n\nstatic void ipc3_get_windows(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_window_elem *elem;\n\tu32 outbox_offset = 0;\n\tu32 stream_offset = 0;\n\tu32 inbox_offset = 0;\n\tu32 outbox_size = 0;\n\tu32 stream_size = 0;\n\tu32 inbox_size = 0;\n\tu32 debug_size = 0;\n\tu32 debug_offset = 0;\n\tint window_offset;\n\tint i;\n\n\tif (!sdev->info_window) {\n\t\tdev_err(sdev->dev, \"%s: No window info present\\n\", __func__);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < sdev->info_window->num_windows; i++) {\n\t\telem = &sdev->info_window->window[i];\n\n\t\twindow_offset = snd_sof_dsp_get_window_offset(sdev, elem->id);\n\t\tif (window_offset < 0) {\n\t\t\tdev_warn(sdev->dev, \"No offset for window %d\\n\", elem->id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (elem->type) {\n\t\tcase SOF_IPC_REGION_UPBOX:\n\t\t\tinbox_offset = window_offset + elem->offset;\n\t\t\tinbox_size = elem->size;\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\tinbox_offset,\n\t\t\t\t\t\t\telem->size, \"inbox\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_DOWNBOX:\n\t\t\toutbox_offset = window_offset + elem->offset;\n\t\t\toutbox_size = elem->size;\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\toutbox_offset,\n\t\t\t\t\t\t\telem->size, \"outbox\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_TRACE:\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\twindow_offset + elem->offset,\n\t\t\t\t\t\t\telem->size, \"etrace\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_DEBUG:\n\t\t\tdebug_offset = window_offset + elem->offset;\n\t\t\tdebug_size = elem->size;\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\twindow_offset + elem->offset,\n\t\t\t\t\t\t\telem->size, \"debug\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_STREAM:\n\t\t\tstream_offset = window_offset + elem->offset;\n\t\t\tstream_size = elem->size;\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\tstream_offset,\n\t\t\t\t\t\t\telem->size, \"stream\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_REGS:\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\twindow_offset + elem->offset,\n\t\t\t\t\t\t\telem->size, \"regs\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tcase SOF_IPC_REGION_EXCEPTION:\n\t\t\tsdev->dsp_oops_offset = window_offset + elem->offset;\n\t\t\tsnd_sof_debugfs_add_region_item(sdev, SOF_FW_BLK_TYPE_SRAM,\n\t\t\t\t\t\t\twindow_offset + elem->offset,\n\t\t\t\t\t\t\telem->size, \"exception\",\n\t\t\t\t\t\t\tSOF_DEBUGFS_ACCESS_D0_ONLY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sdev->dev, \"%s: Illegal window info: %u\\n\",\n\t\t\t\t__func__, elem->type);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (outbox_size == 0 || inbox_size == 0) {\n\t\tdev_err(sdev->dev, \"%s: Illegal mailbox window\\n\", __func__);\n\t\treturn;\n\t}\n\n\tsdev->dsp_box.offset = inbox_offset;\n\tsdev->dsp_box.size = inbox_size;\n\n\tsdev->host_box.offset = outbox_offset;\n\tsdev->host_box.size = outbox_size;\n\n\tsdev->stream_box.offset = stream_offset;\n\tsdev->stream_box.size = stream_size;\n\n\tsdev->debug_box.offset = debug_offset;\n\tsdev->debug_box.size = debug_size;\n\n\tdev_dbg(sdev->dev, \" mailbox upstream 0x%x - size 0x%x\\n\",\n\t\tinbox_offset, inbox_size);\n\tdev_dbg(sdev->dev, \" mailbox downstream 0x%x - size 0x%x\\n\",\n\t\toutbox_offset, outbox_size);\n\tdev_dbg(sdev->dev, \" stream region 0x%x - size 0x%x\\n\",\n\t\tstream_offset, stream_size);\n\tdev_dbg(sdev->dev, \" debug region 0x%x - size 0x%x\\n\",\n\t\tdebug_offset, debug_size);\n}\n\nstatic int ipc3_init_reply_data_buffer(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc_msg *msg = &sdev->ipc->msg;\n\n\tmsg->reply_data = devm_kzalloc(sdev->dev, SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!msg->reply_data)\n\t\treturn -ENOMEM;\n\n\tsdev->ipc->max_payload_size = SOF_IPC_MSG_MAX_SIZE;\n\n\treturn 0;\n}\n\nint sof_ipc3_validate_fw_version(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_fw_ready *ready = &sdev->fw_ready;\n\tstruct sof_ipc_fw_version *v = &ready->version;\n\n\tdev_info(sdev->dev,\n\t\t \"Firmware info: version %d:%d:%d-%s\\n\",  v->major, v->minor,\n\t\t v->micro, v->tag);\n\tdev_info(sdev->dev,\n\t\t \"Firmware: ABI %d:%d:%d Kernel ABI %d:%d:%d\\n\",\n\t\t SOF_ABI_VERSION_MAJOR(v->abi_version),\n\t\t SOF_ABI_VERSION_MINOR(v->abi_version),\n\t\t SOF_ABI_VERSION_PATCH(v->abi_version),\n\t\t SOF_ABI_MAJOR, SOF_ABI_MINOR, SOF_ABI_PATCH);\n\n\tif (SOF_ABI_VERSION_INCOMPATIBLE(SOF_ABI_VERSION, v->abi_version)) {\n\t\tdev_err(sdev->dev, \"incompatible FW ABI version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_SOF_STRICT_ABI_CHECKS) &&\n\t    SOF_ABI_VERSION_MINOR(v->abi_version) > SOF_ABI_MINOR) {\n\t\tdev_err(sdev->dev, \"FW ABI is more recent than kernel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ready->flags & SOF_IPC_INFO_BUILD) {\n\t\tdev_info(sdev->dev,\n\t\t\t \"Firmware debug build %d on %s-%s - options:\\n\"\n\t\t\t \" GDB: %s\\n\"\n\t\t\t \" lock debug: %s\\n\"\n\t\t\t \" lock vdebug: %s\\n\",\n\t\t\t v->build, v->date, v->time,\n\t\t\t (ready->flags & SOF_IPC_INFO_GDB) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKS) ?\n\t\t\t\t\"enabled\" : \"disabled\",\n\t\t\t (ready->flags & SOF_IPC_INFO_LOCKSV) ?\n\t\t\t\t\"enabled\" : \"disabled\");\n\t}\n\n\t \n\tmemcpy(&sdev->fw_version, v, sizeof(*v));\n\n\treturn 0;\n}\n\nstatic int ipc3_fw_ready(struct snd_sof_dev *sdev, u32 cmd)\n{\n\tstruct sof_ipc_fw_ready *fw_ready = &sdev->fw_ready;\n\tint offset;\n\tint ret;\n\n\t \n\toffset = snd_sof_dsp_get_mailbox_offset(sdev);\n\tif (offset < 0) {\n\t\tdev_err(sdev->dev, \"%s: no mailbox offset\\n\", __func__);\n\t\treturn offset;\n\t}\n\n\tdev_dbg(sdev->dev, \"DSP is ready 0x%8.8x offset 0x%x\\n\", cmd, offset);\n\n\t \n\tif (!sdev->first_boot)\n\t\treturn 0;\n\n\t \n\tret = snd_sof_dsp_block_read(sdev, SOF_FW_BLK_TYPE_SRAM, offset, fw_ready,\n\t\t\t\t     sizeof(*fw_ready));\n\tif (ret) {\n\t\tdev_err(sdev->dev,\n\t\t\t\"Unable to read fw_ready, read from TYPE_SRAM failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = sof_ipc3_validate_fw_version(sdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tipc3_fw_parse_ext_data(sdev, offset + sizeof(struct sof_ipc_fw_ready));\n\n\tipc3_get_windows(sdev);\n\n\treturn ipc3_init_reply_data_buffer(sdev);\n}\n\n \nstatic void ipc3_period_elapsed(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_soc_component *scomp = sdev->component;\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction, ret;\n\n\tspcm = snd_sof_find_spcm_comp(scomp, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev, \"period elapsed for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tret = snd_sof_ipc_msg_data(sdev, stream, &posn, sizeof(posn));\n\tif (ret < 0) {\n\t\tdev_warn(sdev->dev, \"failed to read stream position: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ttrace_sof_ipc3_period_elapsed_position(sdev, &posn);\n\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\n\tif (spcm->pcm.compress)\n\t\tsnd_sof_compr_fragment_elapsed(stream->cstream);\n\telse if (stream->substream->runtime &&\n\t\t !stream->substream->runtime->no_period_wakeup)\n\t\t \n\t\tsnd_sof_pcm_period_elapsed(stream->substream);\n}\n\n \nstatic void ipc3_xrun(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_soc_component *scomp = sdev->component;\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tint direction, ret;\n\n\tspcm = snd_sof_find_spcm_comp(scomp, msg_id, &direction);\n\tif (!spcm) {\n\t\tdev_err(sdev->dev, \"XRUN for unknown stream, msg_id %d\\n\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\tstream = &spcm->stream[direction];\n\tret = snd_sof_ipc_msg_data(sdev, stream, &posn, sizeof(posn));\n\tif (ret < 0) {\n\t\tdev_warn(sdev->dev, \"failed to read overrun position: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tdev_dbg(sdev->dev,  \"posn XRUN: host %llx comp %d size %d\\n\",\n\t\tposn.host_posn, posn.xrun_comp_id, posn.xrun_size);\n\n#if defined(CONFIG_SND_SOC_SOF_DEBUG_XRUN_STOP)\n\t \n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\tsnd_pcm_stop_xrun(stream->substream);\n#endif\n}\n\n \nstatic void ipc3_stream_message(struct snd_sof_dev *sdev, void *msg_buf)\n{\n\tstruct sof_ipc_cmd_hdr *hdr = msg_buf;\n\tu32 msg_type = hdr->cmd & SOF_CMD_TYPE_MASK;\n\tu32 msg_id = SOF_IPC_MESSAGE_ID(hdr->cmd);\n\n\tswitch (msg_type) {\n\tcase SOF_IPC_STREAM_POSITION:\n\t\tipc3_period_elapsed(sdev, msg_id);\n\t\tbreak;\n\tcase SOF_IPC_STREAM_TRIG_XRUN:\n\t\tipc3_xrun(sdev, msg_id);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"unhandled stream message %#x\\n\",\n\t\t\tmsg_id);\n\t\tbreak;\n\t}\n}\n\n \nstatic void ipc3_comp_notification(struct snd_sof_dev *sdev, void *msg_buf)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sdev->ipc->ops->tplg;\n\tstruct sof_ipc_cmd_hdr *hdr = msg_buf;\n\tu32 msg_type = hdr->cmd & SOF_CMD_TYPE_MASK;\n\n\tswitch (msg_type) {\n\tcase SOF_IPC_COMP_GET_VALUE:\n\tcase SOF_IPC_COMP_GET_DATA:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"unhandled component message %#x\\n\", msg_type);\n\t\treturn;\n\t}\n\n\tif (tplg_ops->control->update)\n\t\ttplg_ops->control->update(sdev, msg_buf);\n}\n\nstatic void ipc3_trace_message(struct snd_sof_dev *sdev, void *msg_buf)\n{\n\tstruct sof_ipc_cmd_hdr *hdr = msg_buf;\n\tu32 msg_type = hdr->cmd & SOF_CMD_TYPE_MASK;\n\n\tswitch (msg_type) {\n\tcase SOF_IPC_TRACE_DMA_POSITION:\n\t\tipc3_dtrace_posn_update(sdev, msg_buf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"unhandled trace message %#x\\n\", msg_type);\n\t\tbreak;\n\t}\n}\n\nvoid sof_ipc3_do_rx_work(struct snd_sof_dev *sdev, struct sof_ipc_cmd_hdr *hdr, void *msg_buf)\n{\n\tipc3_rx_callback rx_callback = NULL;\n\tu32 cmd;\n\tint err;\n\n\tipc3_log_header(sdev->dev, \"ipc rx\", hdr->cmd);\n\n\tif (hdr->size < sizeof(*hdr) || hdr->size > SOF_IPC_MSG_MAX_SIZE) {\n\t\tdev_err(sdev->dev, \"The received message size is invalid: %u\\n\",\n\t\t\thdr->size);\n\t\treturn;\n\t}\n\n\tcmd = hdr->cmd & SOF_GLB_TYPE_MASK;\n\n\t \n\tswitch (cmd) {\n\tcase SOF_IPC_GLB_REPLY:\n\t\tdev_err(sdev->dev, \"ipc reply unknown\\n\");\n\t\tbreak;\n\tcase SOF_IPC_FW_READY:\n\t\t \n\t\tif (sdev->fw_state == SOF_FW_BOOT_IN_PROGRESS) {\n\t\t\terr = ipc3_fw_ready(sdev, cmd);\n\t\t\tif (err < 0)\n\t\t\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_READY_FAILED);\n\t\t\telse\n\t\t\t\tsof_set_fw_state(sdev, SOF_FW_BOOT_READY_OK);\n\n\t\t\t \n\t\t\twake_up(&sdev->boot_wait);\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMPOUND:\n\tcase SOF_IPC_GLB_TPLG_MSG:\n\tcase SOF_IPC_GLB_PM_MSG:\n\t\tbreak;\n\tcase SOF_IPC_GLB_COMP_MSG:\n\t\trx_callback = ipc3_comp_notification;\n\t\tbreak;\n\tcase SOF_IPC_GLB_STREAM_MSG:\n\t\trx_callback = ipc3_stream_message;\n\t\tbreak;\n\tcase SOF_IPC_GLB_TRACE_MSG:\n\t\trx_callback = ipc3_trace_message;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"%s: Unknown DSP message: 0x%x\\n\", __func__, cmd);\n\t\tbreak;\n\t}\n\n\t \n\tif (rx_callback)\n\t\trx_callback(sdev, msg_buf);\n\n\t \n\tsof_client_ipc_rx_dispatcher(sdev, msg_buf);\n\n\tipc3_log_header(sdev->dev, \"ipc rx done\", hdr->cmd);\n}\nEXPORT_SYMBOL(sof_ipc3_do_rx_work);\n\n \nstatic void sof_ipc3_rx_msg(struct snd_sof_dev *sdev)\n{\n\tstruct sof_ipc_cmd_hdr hdr;\n\tvoid *msg_buf;\n\tint err;\n\n\t \n\terr = snd_sof_ipc_msg_data(sdev, NULL, &hdr, sizeof(hdr));\n\tif (err < 0) {\n\t\tdev_warn(sdev->dev, \"failed to read IPC header: %d\\n\", err);\n\t\treturn;\n\t}\n\n\tif (hdr.size < sizeof(hdr)) {\n\t\tdev_err(sdev->dev, \"The received message size is invalid\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmsg_buf = kmalloc(hdr.size, GFP_KERNEL);\n\tif (!msg_buf)\n\t\treturn;\n\n\terr = snd_sof_ipc_msg_data(sdev, NULL, msg_buf, hdr.size);\n\tif (err < 0) {\n\t\tdev_err(sdev->dev, \"%s: Failed to read message: %d\\n\", __func__, err);\n\t\tkfree(msg_buf);\n\t\treturn;\n\t}\n\n\tsof_ipc3_do_rx_work(sdev, &hdr, msg_buf);\n\n\tkfree(msg_buf);\n}\n\nstatic int sof_ipc3_set_core_state(struct snd_sof_dev *sdev, int core_idx, bool on)\n{\n\tstruct sof_ipc_pm_core_config core_cfg = {\n\t\t.hdr.size = sizeof(core_cfg),\n\t\t.hdr.cmd = SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_CORE_ENABLE,\n\t};\n\n\tif (on)\n\t\tcore_cfg.enable_mask = sdev->enabled_cores_mask | BIT(core_idx);\n\telse\n\t\tcore_cfg.enable_mask = sdev->enabled_cores_mask & ~BIT(core_idx);\n\n\treturn sof_ipc3_tx_msg(sdev, &core_cfg, sizeof(core_cfg), NULL, 0, false);\n}\n\nstatic int sof_ipc3_ctx_ipc(struct snd_sof_dev *sdev, int cmd)\n{\n\tstruct sof_ipc_pm_ctx pm_ctx = {\n\t\t.hdr.size = sizeof(pm_ctx),\n\t\t.hdr.cmd = SOF_IPC_GLB_PM_MSG | cmd,\n\t};\n\n\t \n\treturn sof_ipc3_tx_msg(sdev, &pm_ctx, sizeof(pm_ctx), NULL, 0, false);\n}\n\nstatic int sof_ipc3_ctx_save(struct snd_sof_dev *sdev)\n{\n\treturn sof_ipc3_ctx_ipc(sdev, SOF_IPC_PM_CTX_SAVE);\n}\n\nstatic int sof_ipc3_ctx_restore(struct snd_sof_dev *sdev)\n{\n\treturn sof_ipc3_ctx_ipc(sdev, SOF_IPC_PM_CTX_RESTORE);\n}\n\nstatic int sof_ipc3_set_pm_gate(struct snd_sof_dev *sdev, u32 flags)\n{\n\tstruct sof_ipc_pm_gate pm_gate;\n\n\tmemset(&pm_gate, 0, sizeof(pm_gate));\n\n\t \n\tpm_gate.hdr.size = sizeof(pm_gate);\n\tpm_gate.hdr.cmd = SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_GATE;\n\tpm_gate.flags = flags;\n\n\t \n\treturn sof_ipc_tx_message_no_pm_no_reply(sdev->ipc, &pm_gate, sizeof(pm_gate));\n}\n\nstatic const struct sof_ipc_pm_ops ipc3_pm_ops = {\n\t.ctx_save = sof_ipc3_ctx_save,\n\t.ctx_restore = sof_ipc3_ctx_restore,\n\t.set_core_state = sof_ipc3_set_core_state,\n\t.set_pm_gate = sof_ipc3_set_pm_gate,\n};\n\nconst struct sof_ipc_ops ipc3_ops = {\n\t.tplg = &ipc3_tplg_ops,\n\t.pm = &ipc3_pm_ops,\n\t.pcm = &ipc3_pcm_ops,\n\t.fw_loader = &ipc3_loader_ops,\n\t.fw_tracing = &ipc3_dtrace_ops,\n\n\t.tx_msg = sof_ipc3_tx_msg,\n\t.rx_msg = sof_ipc3_rx_msg,\n\t.set_get_data = sof_ipc3_set_get_data,\n\t.get_reply = sof_ipc3_get_reply,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}