{
  "module_name": "sof-client.c",
  "hash_id": "15d8cb5ca46180a054b251ecce9001ecb3d219a6ce917702fb5939834e755771",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-client.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <sound/sof/ipc4/header.h>\n#include \"ops.h\"\n#include \"sof-client.h\"\n#include \"sof-priv.h\"\n#include \"ipc3-priv.h\"\n#include \"ipc4-priv.h\"\n\n \nstruct sof_ipc_event_entry {\n\tu32 ipc_msg_type;\n\tstruct sof_client_dev *cdev;\n\tsof_client_event_callback callback;\n\tstruct list_head list;\n};\n\n \nstruct sof_state_event_entry {\n\tstruct sof_client_dev *cdev;\n\tsof_client_fw_state_callback callback;\n\tstruct list_head list;\n};\n\nstatic void sof_client_auxdev_release(struct device *dev)\n{\n\tstruct auxiliary_device *auxdev = to_auxiliary_dev(dev);\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\n\tkfree(cdev->auxdev.dev.platform_data);\n\tkfree(cdev);\n}\n\nstatic int sof_client_dev_add_data(struct sof_client_dev *cdev, const void *data,\n\t\t\t\t   size_t size)\n{\n\tvoid *d = NULL;\n\n\tif (data) {\n\t\td = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!d)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tcdev->auxdev.dev.platform_data = d;\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\nstatic int sof_register_ipc_flood_test(struct snd_sof_dev *sdev)\n{\n\tint ret = 0;\n\tint i;\n\n\tif (sdev->pdata->ipc_type != SOF_IPC)\n\t\treturn 0;\n\n\tfor (i = 0; i < CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST_NUM; i++) {\n\t\tret = sof_client_dev_register(sdev, \"ipc_flood\", i, NULL, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tfor (; i >= 0; --i)\n\t\t\tsof_client_dev_unregister(sdev, \"ipc_flood\", i);\n\t}\n\n\treturn ret;\n}\n\nstatic void sof_unregister_ipc_flood_test(struct snd_sof_dev *sdev)\n{\n\tint i;\n\n\tfor (i = 0; i < CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST_NUM; i++)\n\t\tsof_client_dev_unregister(sdev, \"ipc_flood\", i);\n}\n#else\nstatic inline int sof_register_ipc_flood_test(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline void sof_unregister_ipc_flood_test(struct snd_sof_dev *sdev) {}\n#endif  \n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_MSG_INJECTOR)\nstatic int sof_register_ipc_msg_injector(struct snd_sof_dev *sdev)\n{\n\treturn sof_client_dev_register(sdev, \"msg_injector\", 0, NULL, 0);\n}\n\nstatic void sof_unregister_ipc_msg_injector(struct snd_sof_dev *sdev)\n{\n\tsof_client_dev_unregister(sdev, \"msg_injector\", 0);\n}\n#else\nstatic inline int sof_register_ipc_msg_injector(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline void sof_unregister_ipc_msg_injector(struct snd_sof_dev *sdev) {}\n#endif  \n\n#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_KERNEL_INJECTOR)\nstatic int sof_register_ipc_kernel_injector(struct snd_sof_dev *sdev)\n{\n\t \n\tif (sdev->pdata->ipc_type != SOF_IPC)\n\t\treturn 0;\n\n\treturn sof_client_dev_register(sdev, \"kernel_injector\", 0, NULL, 0);\n}\n\nstatic void sof_unregister_ipc_kernel_injector(struct snd_sof_dev *sdev)\n{\n\tsof_client_dev_unregister(sdev, \"kernel_injector\", 0);\n}\n#else\nstatic inline int sof_register_ipc_kernel_injector(struct snd_sof_dev *sdev)\n{\n\treturn 0;\n}\n\nstatic inline void sof_unregister_ipc_kernel_injector(struct snd_sof_dev *sdev) {}\n#endif  \n\nint sof_register_clients(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn 0;\n\n\t \n\tret = sof_register_ipc_flood_test(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"IPC flood test client registration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = sof_register_ipc_msg_injector(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"IPC message injector client registration failed\\n\");\n\t\tgoto err_msg_injector;\n\t}\n\n\tret = sof_register_ipc_kernel_injector(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"IPC kernel injector client registration failed\\n\");\n\t\tgoto err_kernel_injector;\n\t}\n\n\t \n\n\tif (sof_ops(sdev) && sof_ops(sdev)->register_ipc_clients)\n\t\tret = sof_ops(sdev)->register_ipc_clients(sdev);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tsof_unregister_ipc_kernel_injector(sdev);\n\nerr_kernel_injector:\n\tsof_unregister_ipc_msg_injector(sdev);\n\nerr_msg_injector:\n\tsof_unregister_ipc_flood_test(sdev);\n\n\treturn ret;\n}\n\nvoid sof_unregister_clients(struct snd_sof_dev *sdev)\n{\n\tif (sof_ops(sdev) && sof_ops(sdev)->unregister_ipc_clients)\n\t\tsof_ops(sdev)->unregister_ipc_clients(sdev);\n\n\tsof_unregister_ipc_kernel_injector(sdev);\n\tsof_unregister_ipc_msg_injector(sdev);\n\tsof_unregister_ipc_flood_test(sdev);\n}\n\nint sof_client_dev_register(struct snd_sof_dev *sdev, const char *name, u32 id,\n\t\t\t    const void *data, size_t size)\n{\n\tstruct auxiliary_device *auxdev;\n\tstruct sof_client_dev *cdev;\n\tint ret;\n\n\tcdev = kzalloc(sizeof(*cdev), GFP_KERNEL);\n\tif (!cdev)\n\t\treturn -ENOMEM;\n\n\tcdev->sdev = sdev;\n\tauxdev = &cdev->auxdev;\n\tauxdev->name = name;\n\tauxdev->dev.parent = sdev->dev;\n\tauxdev->dev.release = sof_client_auxdev_release;\n\tauxdev->id = id;\n\n\tret = sof_client_dev_add_data(cdev, data, size);\n\tif (ret < 0)\n\t\tgoto err_dev_add_data;\n\n\tret = auxiliary_device_init(auxdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to initialize client dev %s.%d\\n\", name, id);\n\t\tgoto err_dev_init;\n\t}\n\n\tret = auxiliary_device_add(&cdev->auxdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to add client dev %s.%d\\n\", name, id);\n\t\t \n\t\tauxiliary_device_uninit(&cdev->auxdev);\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&sdev->ipc_client_mutex);\n\tlist_add(&cdev->list, &sdev->ipc_client_list);\n\tmutex_unlock(&sdev->ipc_client_mutex);\n\n\treturn 0;\n\nerr_dev_init:\n\tkfree(cdev->auxdev.dev.platform_data);\n\nerr_dev_add_data:\n\tkfree(cdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_dev_register, SND_SOC_SOF_CLIENT);\n\nvoid sof_client_dev_unregister(struct snd_sof_dev *sdev, const char *name, u32 id)\n{\n\tstruct sof_client_dev *cdev;\n\n\tmutex_lock(&sdev->ipc_client_mutex);\n\n\t \n\tlist_for_each_entry(cdev, &sdev->ipc_client_list, list) {\n\t\tif (!strcmp(cdev->auxdev.name, name) && cdev->auxdev.id == id) {\n\t\t\tlist_del(&cdev->list);\n\t\t\tauxiliary_device_delete(&cdev->auxdev);\n\t\t\tauxiliary_device_uninit(&cdev->auxdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&sdev->ipc_client_mutex);\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_dev_unregister, SND_SOC_SOF_CLIENT);\n\nint sof_client_ipc_tx_message(struct sof_client_dev *cdev, void *ipc_msg,\n\t\t\t      void *reply_data, size_t reply_bytes)\n{\n\tif (cdev->sdev->pdata->ipc_type == SOF_IPC) {\n\t\tstruct sof_ipc_cmd_hdr *hdr = ipc_msg;\n\n\t\treturn sof_ipc_tx_message(cdev->sdev->ipc, ipc_msg, hdr->size,\n\t\t\t\t\t  reply_data, reply_bytes);\n\t} else if (cdev->sdev->pdata->ipc_type == SOF_INTEL_IPC4) {\n\t\tstruct sof_ipc4_msg *msg = ipc_msg;\n\n\t\treturn sof_ipc_tx_message(cdev->sdev->ipc, ipc_msg, msg->data_size,\n\t\t\t\t\t  reply_data, reply_bytes);\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_ipc_tx_message, SND_SOC_SOF_CLIENT);\n\nint sof_client_ipc_rx_message(struct sof_client_dev *cdev, void *ipc_msg, void *msg_buf)\n{\n\tif (cdev->sdev->pdata->ipc_type == SOF_IPC) {\n\t\tstruct sof_ipc_cmd_hdr *hdr = ipc_msg;\n\n\t\tif (hdr->size < sizeof(hdr)) {\n\t\t\tdev_err(cdev->sdev->dev, \"The received message size is invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsof_ipc3_do_rx_work(cdev->sdev, ipc_msg, msg_buf);\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_ipc_rx_message, SND_SOC_SOF_CLIENT);\n\nint sof_client_ipc_set_get_data(struct sof_client_dev *cdev, void *ipc_msg,\n\t\t\t\tbool set)\n{\n\tif (cdev->sdev->pdata->ipc_type == SOF_IPC) {\n\t\tstruct sof_ipc_cmd_hdr *hdr = ipc_msg;\n\n\t\treturn sof_ipc_set_get_data(cdev->sdev->ipc, ipc_msg, hdr->size,\n\t\t\t\t\t    set);\n\t} else if (cdev->sdev->pdata->ipc_type == SOF_INTEL_IPC4) {\n\t\tstruct sof_ipc4_msg *msg = ipc_msg;\n\n\t\treturn sof_ipc_set_get_data(cdev->sdev->ipc, ipc_msg,\n\t\t\t\t\t    msg->data_size, set);\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_ipc_set_get_data, SND_SOC_SOF_CLIENT);\n\n#ifdef CONFIG_SND_SOC_SOF_INTEL_IPC4\nstruct sof_ipc4_fw_module *sof_client_ipc4_find_module(struct sof_client_dev *c, const guid_t *uuid)\n{\n\tstruct snd_sof_dev *sdev = c->sdev;\n\n\tif (sdev->pdata->ipc_type == SOF_INTEL_IPC4)\n\t\treturn sof_ipc4_find_module_by_uuid(sdev, uuid);\n\tdev_err(sdev->dev, \"Only supported with IPC4\\n\");\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_ipc4_find_module, SND_SOC_SOF_CLIENT);\n#endif\n\nint sof_suspend_clients(struct snd_sof_dev *sdev, pm_message_t state)\n{\n\tstruct auxiliary_driver *adrv;\n\tstruct sof_client_dev *cdev;\n\n\tmutex_lock(&sdev->ipc_client_mutex);\n\n\tlist_for_each_entry(cdev, &sdev->ipc_client_list, list) {\n\t\t \n\t\tif (!cdev->auxdev.dev.driver)\n\t\t\tcontinue;\n\n\t\tadrv = to_auxiliary_drv(cdev->auxdev.dev.driver);\n\t\tif (adrv->suspend)\n\t\t\tadrv->suspend(&cdev->auxdev, state);\n\t}\n\n\tmutex_unlock(&sdev->ipc_client_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(sof_suspend_clients, SND_SOC_SOF_CLIENT);\n\nint sof_resume_clients(struct snd_sof_dev *sdev)\n{\n\tstruct auxiliary_driver *adrv;\n\tstruct sof_client_dev *cdev;\n\n\tmutex_lock(&sdev->ipc_client_mutex);\n\n\tlist_for_each_entry(cdev, &sdev->ipc_client_list, list) {\n\t\t \n\t\tif (!cdev->auxdev.dev.driver)\n\t\t\tcontinue;\n\n\t\tadrv = to_auxiliary_drv(cdev->auxdev.dev.driver);\n\t\tif (adrv->resume)\n\t\t\tadrv->resume(&cdev->auxdev);\n\t}\n\n\tmutex_unlock(&sdev->ipc_client_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(sof_resume_clients, SND_SOC_SOF_CLIENT);\n\nstruct dentry *sof_client_get_debugfs_root(struct sof_client_dev *cdev)\n{\n\treturn cdev->sdev->debugfs_root;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_debugfs_root, SND_SOC_SOF_CLIENT);\n\n \nstruct device *sof_client_get_dma_dev(struct sof_client_dev *cdev)\n{\n\treturn cdev->sdev->dev;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_dma_dev, SND_SOC_SOF_CLIENT);\n\nconst struct sof_ipc_fw_version *sof_client_get_fw_version(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\treturn &sdev->fw_ready.version;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_fw_version, SND_SOC_SOF_CLIENT);\n\nsize_t sof_client_get_ipc_max_payload_size(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\treturn sdev->ipc->max_payload_size;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_ipc_max_payload_size, SND_SOC_SOF_CLIENT);\n\nenum sof_ipc_type sof_client_get_ipc_type(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\treturn sdev->pdata->ipc_type;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_ipc_type, SND_SOC_SOF_CLIENT);\n\n \nint sof_client_core_module_get(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\tif (!try_module_get(sdev->dev->driver->owner))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_core_module_get, SND_SOC_SOF_CLIENT);\n\nvoid sof_client_core_module_put(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\tmodule_put(sdev->dev->driver->owner);\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_core_module_put, SND_SOC_SOF_CLIENT);\n\n \nvoid sof_client_ipc_rx_dispatcher(struct snd_sof_dev *sdev, void *msg_buf)\n{\n\tstruct sof_ipc_event_entry *event;\n\tu32 msg_type;\n\n\tif (sdev->pdata->ipc_type == SOF_IPC) {\n\t\tstruct sof_ipc_cmd_hdr *hdr = msg_buf;\n\n\t\tmsg_type = hdr->cmd & SOF_GLB_TYPE_MASK;\n\t} else if (sdev->pdata->ipc_type == SOF_INTEL_IPC4) {\n\t\tstruct sof_ipc4_msg *msg = msg_buf;\n\n\t\tmsg_type = SOF_IPC4_NOTIFICATION_TYPE_GET(msg->primary);\n\t} else {\n\t\tdev_dbg_once(sdev->dev, \"Not supported IPC version: %d\\n\",\n\t\t\t     sdev->pdata->ipc_type);\n\t\treturn;\n\t}\n\n\tmutex_lock(&sdev->client_event_handler_mutex);\n\n\tlist_for_each_entry(event, &sdev->ipc_rx_handler_list, list) {\n\t\tif (event->ipc_msg_type == msg_type)\n\t\t\tevent->callback(event->cdev, msg_buf);\n\t}\n\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n}\n\nint sof_client_register_ipc_rx_handler(struct sof_client_dev *cdev,\n\t\t\t\t       u32 ipc_msg_type,\n\t\t\t\t       sof_client_event_callback callback)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\tstruct sof_ipc_event_entry *event;\n\n\tif (!callback)\n\t\treturn -EINVAL;\n\n\tif (cdev->sdev->pdata->ipc_type == SOF_IPC) {\n\t\tif (!(ipc_msg_type & SOF_GLB_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\t} else if (cdev->sdev->pdata->ipc_type == SOF_INTEL_IPC4) {\n\t\tif (!(ipc_msg_type & SOF_IPC4_NOTIFICATION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdev_warn(sdev->dev, \"%s: Not supported IPC version: %d\\n\",\n\t\t\t __func__, sdev->pdata->ipc_type);\n\t\treturn -EINVAL;\n\t}\n\n\tevent = kmalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->ipc_msg_type = ipc_msg_type;\n\tevent->cdev = cdev;\n\tevent->callback = callback;\n\n\t \n\tmutex_lock(&sdev->client_event_handler_mutex);\n\tlist_add(&event->list, &sdev->ipc_rx_handler_list);\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_register_ipc_rx_handler, SND_SOC_SOF_CLIENT);\n\nvoid sof_client_unregister_ipc_rx_handler(struct sof_client_dev *cdev,\n\t\t\t\t\t  u32 ipc_msg_type)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\tstruct sof_ipc_event_entry *event;\n\n\tmutex_lock(&sdev->client_event_handler_mutex);\n\n\tlist_for_each_entry(event, &sdev->ipc_rx_handler_list, list) {\n\t\tif (event->cdev == cdev && event->ipc_msg_type == ipc_msg_type) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_unregister_ipc_rx_handler, SND_SOC_SOF_CLIENT);\n\n \nvoid sof_client_fw_state_dispatcher(struct snd_sof_dev *sdev)\n{\n\tstruct sof_state_event_entry *event;\n\n\tmutex_lock(&sdev->client_event_handler_mutex);\n\n\tlist_for_each_entry(event, &sdev->fw_state_handler_list, list)\n\t\tevent->callback(event->cdev, sdev->fw_state);\n\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n}\n\nint sof_client_register_fw_state_handler(struct sof_client_dev *cdev,\n\t\t\t\t\t sof_client_fw_state_callback callback)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\tstruct sof_state_event_entry *event;\n\n\tif (!callback)\n\t\treturn -EINVAL;\n\n\tevent = kmalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->cdev = cdev;\n\tevent->callback = callback;\n\n\t \n\tmutex_lock(&sdev->client_event_handler_mutex);\n\tlist_add(&event->list, &sdev->fw_state_handler_list);\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_register_fw_state_handler, SND_SOC_SOF_CLIENT);\n\nvoid sof_client_unregister_fw_state_handler(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\tstruct sof_state_event_entry *event;\n\n\tmutex_lock(&sdev->client_event_handler_mutex);\n\n\tlist_for_each_entry(event, &sdev->fw_state_handler_list, list) {\n\t\tif (event->cdev == cdev) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&sdev->client_event_handler_mutex);\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_unregister_fw_state_handler, SND_SOC_SOF_CLIENT);\n\nenum sof_fw_state sof_client_get_fw_state(struct sof_client_dev *cdev)\n{\n\tstruct snd_sof_dev *sdev = sof_client_dev_to_sof_dev(cdev);\n\n\treturn sdev->fw_state;\n}\nEXPORT_SYMBOL_NS_GPL(sof_client_get_fw_state, SND_SOC_SOF_CLIENT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}