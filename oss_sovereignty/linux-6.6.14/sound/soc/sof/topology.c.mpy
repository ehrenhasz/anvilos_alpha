{
  "module_name": "topology.c",
  "hash_id": "bdf54e562ab3e3f09e656f798277007c66fbc8eb7fd0cbfd75add6507ef82bde",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/topology.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/workqueue.h>\n#include <sound/tlv.h>\n#include <uapi/sound/sof/tokens.h>\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ops.h\"\n\n#define COMP_ID_UNASSIGNED\t\t0xffffffff\n \n#define VOL_TWENTIETH_ROOT_OF_TEN\t73533\n \n#define VOL_FORTIETH_ROOT_OF_TEN\t69419\n\n \n#define VOL_HALF_DB_STEP\t50\n\n \n#define TLV_MIN\t\t0\n#define TLV_STEP\t1\n#define TLV_MUTE\t2\n\n \nint sof_update_ipc_object(struct snd_soc_component *scomp, void *object, enum sof_tokens token_id,\n\t\t\t  struct snd_sof_tuple *tuples, int num_tuples,\n\t\t\t  size_t object_size, int token_instance_num)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tconst struct sof_token_info *token_list;\n\tconst struct sof_topology_token *tokens;\n\tint i, j;\n\n\ttoken_list = tplg_ops ? tplg_ops->token_list : NULL;\n\t \n\tif (!token_list)\n\t\treturn 0;\n\n\tif (token_list[token_id].count < 0) {\n\t\tdev_err(scomp->dev, \"Invalid token count for token ID: %d\\n\", token_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!token_list[token_id].count)\n\t\treturn 0;\n\n\ttokens = token_list[token_id].tokens;\n\tif (!tokens) {\n\t\tdev_err(scomp->dev, \"Invalid tokens for token id: %d\\n\", token_id);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < token_list[token_id].count; i++) {\n\t\tint offset = 0;\n\t\tint num_tokens_matched = 0;\n\n\t\tfor (j = 0; j < num_tuples; j++) {\n\t\t\tif (tokens[i].token == tuples[j].token) {\n\t\t\t\tswitch (tokens[i].type) {\n\t\t\t\tcase SND_SOC_TPLG_TUPLE_TYPE_WORD:\n\t\t\t\t{\n\t\t\t\t\tu32 *val = (u32 *)((u8 *)object + tokens[i].offset +\n\t\t\t\t\t\t\t   offset);\n\n\t\t\t\t\t*val = tuples[j].value.v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SND_SOC_TPLG_TUPLE_TYPE_SHORT:\n\t\t\t\tcase SND_SOC_TPLG_TUPLE_TYPE_BOOL:\n\t\t\t\t{\n\t\t\t\t\tu16 *val = (u16 *)((u8 *)object + tokens[i].offset +\n\t\t\t\t\t\t\t    offset);\n\n\t\t\t\t\t*val = (u16)tuples[j].value.v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase SND_SOC_TPLG_TUPLE_TYPE_STRING:\n\t\t\t\t{\n\t\t\t\t\tif (!tokens[i].get_token) {\n\t\t\t\t\t\tdev_err(scomp->dev,\n\t\t\t\t\t\t\t\"get_token not defined for token %d in %s\\n\",\n\t\t\t\t\t\t\ttokens[i].token, token_list[token_id].name);\n\t\t\t\t\t\treturn -EINVAL;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokens[i].get_token((void *)tuples[j].value.s, object,\n\t\t\t\t\t\t\t    tokens[i].offset + offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnum_tokens_matched++;\n\n\t\t\t\t \n\t\t\t\tif (!(num_tokens_matched % token_instance_num))\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\toffset += object_size;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int get_tlv_data(const int *p, int tlv[SOF_TLV_ITEMS])\n{\n\t \n\tif ((int)p[SNDRV_CTL_TLVO_TYPE] != SNDRV_CTL_TLVT_DB_SCALE)\n\t\treturn -EINVAL;\n\n\t \n\ttlv[TLV_MIN] = (int)p[SNDRV_CTL_TLVO_DB_SCALE_MIN] / 100;\n\n\t \n\ttlv[TLV_STEP] = (int)(p[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP] &\n\t\t\t\tTLV_DB_SCALE_MASK);\n\n\t \n\tif ((p[SNDRV_CTL_TLVO_DB_SCALE_MUTE_AND_STEP] &\n\t\tTLV_DB_SCALE_MUTE) == 0)\n\t\ttlv[TLV_MUTE] = 0;\n\telse\n\t\ttlv[TLV_MUTE] = 1;\n\n\treturn 0;\n}\n\n \nstatic inline u32 vol_shift_64(u64 i, u32 x)\n{\n\t \n\tif (x > 32)\n\t\tx = 32;\n\n\tif (x == 0)\n\t\treturn (u32)i;\n\n\treturn (u32)(((i >> (x - 1)) + 1) >> 1);\n}\n\n \nstatic u32 vol_pow32(u32 a, int exp, u32 fwl)\n{\n\tint i, iter;\n\tu32 power = 1 << fwl;\n\tu64 numerator;\n\n\t \n\tif (exp == 0)\n\t\treturn power;\n\n\t \n\tif (exp < 0)\n\t\titer = exp * -1;\n\telse\n\t\titer = exp;\n\n\t \n\tfor (i = 0; i < iter; i++) {\n\t\t \n\t\tpower = vol_shift_64((u64)power * a, fwl);\n\t}\n\n\tif (exp > 0) {\n\t\t \n\t\treturn power;\n\t}\n\n\t \n\tnumerator = (u64)1 << (fwl << 1);\n\tdo_div(numerator, power);\n\n\treturn (u32)numerator;\n}\n\n \nu32 vol_compute_gain(u32 value, int *tlv)\n{\n\tint dB_gain;\n\tu32 linear_gain;\n\tint f_step;\n\n\t \n\tif (value == 0 && tlv[TLV_MUTE])\n\t\treturn 0;\n\n\t \n\tdB_gain = tlv[TLV_MIN] + (value * tlv[TLV_STEP]) / 100;\n\n\t \n\tlinear_gain = vol_pow32(VOL_TWENTIETH_ROOT_OF_TEN, dB_gain, VOLUME_FWL);\n\n\t \n\tf_step = tlv[TLV_STEP] - (tlv[TLV_STEP] / 100);\n\n\t \n\tif (f_step == VOL_HALF_DB_STEP && (value & 1))\n\t\tlinear_gain = vol_shift_64((u64)linear_gain *\n\t\t\t\t\t\t  VOL_FORTIETH_ROOT_OF_TEN,\n\t\t\t\t\t\t  VOLUME_FWL);\n\n\treturn linear_gain;\n}\n\n \nstatic int set_up_volume_table(struct snd_sof_control *scontrol,\n\t\t\t       int tlv[SOF_TLV_ITEMS], int size)\n{\n\tstruct snd_soc_component *scomp = scontrol->scomp;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->control && tplg_ops->control->set_up_volume_table)\n\t\treturn tplg_ops->control->set_up_volume_table(scontrol, tlv, size);\n\n\tdev_err(scomp->dev, \"Mandatory op %s not set\\n\", __func__);\n\treturn -EINVAL;\n}\n\nstruct sof_dai_types {\n\tconst char *name;\n\tenum sof_ipc_dai_type type;\n};\n\nstatic const struct sof_dai_types sof_dais[] = {\n\t{\"SSP\", SOF_DAI_INTEL_SSP},\n\t{\"HDA\", SOF_DAI_INTEL_HDA},\n\t{\"DMIC\", SOF_DAI_INTEL_DMIC},\n\t{\"ALH\", SOF_DAI_INTEL_ALH},\n\t{\"SAI\", SOF_DAI_IMX_SAI},\n\t{\"ESAI\", SOF_DAI_IMX_ESAI},\n\t{\"ACP\", SOF_DAI_AMD_BT},\n\t{\"ACPSP\", SOF_DAI_AMD_SP},\n\t{\"ACPDMIC\", SOF_DAI_AMD_DMIC},\n\t{\"ACPHS\", SOF_DAI_AMD_HS},\n\t{\"AFE\", SOF_DAI_MEDIATEK_AFE},\n\t{\"ACPSP_VIRTUAL\", SOF_DAI_AMD_SP_VIRTUAL},\n\t{\"ACPHS_VIRTUAL\", SOF_DAI_AMD_HS_VIRTUAL},\n\n};\n\nstatic enum sof_ipc_dai_type find_dai(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sof_dais); i++) {\n\t\tif (strcmp(name, sof_dais[i].name) == 0)\n\t\t\treturn sof_dais[i].type;\n\t}\n\n\treturn SOF_DAI_INTEL_NONE;\n}\n\n \n\nstruct sof_frame_types {\n\tconst char *name;\n\tenum sof_ipc_frame frame;\n};\n\nstatic const struct sof_frame_types sof_frames[] = {\n\t{\"s16le\", SOF_IPC_FRAME_S16_LE},\n\t{\"s24le\", SOF_IPC_FRAME_S24_4LE},\n\t{\"s32le\", SOF_IPC_FRAME_S32_LE},\n\t{\"float\", SOF_IPC_FRAME_FLOAT},\n};\n\nstatic enum sof_ipc_frame find_format(const char *name)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sof_frames); i++) {\n\t\tif (strcmp(name, sof_frames[i].name) == 0)\n\t\t\treturn sof_frames[i].frame;\n\t}\n\n\t \n\treturn SOF_IPC_FRAME_S32_LE;\n}\n\nint get_token_u32(void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *velem = elem;\n\tu32 *val = (u32 *)((u8 *)object + offset);\n\n\t*val = le32_to_cpu(velem->value);\n\treturn 0;\n}\n\nint get_token_u16(void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *velem = elem;\n\tu16 *val = (u16 *)((u8 *)object + offset);\n\n\t*val = (u16)le32_to_cpu(velem->value);\n\treturn 0;\n}\n\nint get_token_uuid(void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_uuid_elem *velem = elem;\n\tu8 *dst = (u8 *)object + offset;\n\n\tmemcpy(dst, velem->uuid, UUID_SIZE);\n\n\treturn 0;\n}\n\n \nint get_token_string(void *elem, void *object, u32 offset)\n{\n\t \n\tchar **dst = (char **)((u8 *)object + offset);\n\n\t*dst = kstrdup(elem, GFP_KERNEL);\n\tif (!*dst)\n\t\treturn -ENOMEM;\n\treturn 0;\n};\n\nint get_token_comp_format(void *elem, void *object, u32 offset)\n{\n\tu32 *val = (u32 *)((u8 *)object + offset);\n\n\t*val = find_format((const char *)elem);\n\treturn 0;\n}\n\nint get_token_dai_type(void *elem, void *object, u32 offset)\n{\n\tu32 *val = (u32 *)((u8 *)object + offset);\n\n\t*val = find_dai((const char *)elem);\n\treturn 0;\n}\n\n \nstatic const struct sof_topology_token stream_tokens[] = {\n\t{SOF_TKN_STREAM_PLAYBACK_COMPATIBLE_D0I3, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct snd_sof_pcm, stream[0].d0i3_compatible)},\n\t{SOF_TKN_STREAM_CAPTURE_COMPATIBLE_D0I3, SND_SOC_TPLG_TUPLE_TYPE_BOOL, get_token_u16,\n\t\toffsetof(struct snd_sof_pcm, stream[1].d0i3_compatible)},\n};\n\n \nstatic const struct sof_topology_token led_tokens[] = {\n\t{SOF_TKN_MUTE_LED_USE, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct snd_sof_led_control, use_led)},\n\t{SOF_TKN_MUTE_LED_DIRECTION, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct snd_sof_led_control, direction)},\n};\n\nstatic const struct sof_topology_token comp_pin_tokens[] = {\n\t{SOF_TKN_COMP_NUM_INPUT_PINS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct snd_sof_widget, num_input_pins)},\n\t{SOF_TKN_COMP_NUM_OUTPUT_PINS, SND_SOC_TPLG_TUPLE_TYPE_WORD, get_token_u32,\n\t\toffsetof(struct snd_sof_widget, num_output_pins)},\n};\n\nstatic const struct sof_topology_token comp_input_pin_binding_tokens[] = {\n\t{SOF_TKN_COMP_INPUT_PIN_BINDING_WNAME, SND_SOC_TPLG_TUPLE_TYPE_STRING,\n\t\tget_token_string, 0},\n};\n\nstatic const struct sof_topology_token comp_output_pin_binding_tokens[] = {\n\t{SOF_TKN_COMP_OUTPUT_PIN_BINDING_WNAME, SND_SOC_TPLG_TUPLE_TYPE_STRING,\n\t\tget_token_string, 0},\n};\n\n \nstatic int sof_parse_uuid_tokens(struct snd_soc_component *scomp,\n\t\t\t\t  void *object, size_t offset,\n\t\t\t\t  const struct sof_topology_token *tokens, int num_tokens,\n\t\t\t\t  struct snd_soc_tplg_vendor_array *array)\n{\n\tstruct snd_soc_tplg_vendor_uuid_elem *elem;\n\tint found = 0;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(array->num_elems); i++) {\n\t\telem = &array->uuid[i];\n\n\t\t \n\t\tfor (j = 0; j < num_tokens; j++) {\n\t\t\t \n\t\t\tif (tokens[j].type != SND_SOC_TPLG_TUPLE_TYPE_UUID)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (tokens[j].token != le32_to_cpu(elem->token))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttokens[j].get_token(elem, object,\n\t\t\t\t\t    offset + tokens[j].offset);\n\n\t\t\tfound++;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nstatic int sof_copy_tuples(struct snd_sof_dev *sdev, struct snd_soc_tplg_vendor_array *array,\n\t\t\t   int array_size, u32 token_id, int token_instance_num,\n\t\t\t   struct snd_sof_tuple *tuples, int tuples_size, int *num_copied_tuples)\n{\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tconst struct sof_token_info *token_list;\n\tconst struct sof_topology_token *tokens;\n\tint found = 0;\n\tint num_tokens, asize;\n\tint i, j;\n\n\ttoken_list = tplg_ops ? tplg_ops->token_list : NULL;\n\t \n\tif (!token_list)\n\t\treturn 0;\n\n\tif (!tuples || !num_copied_tuples) {\n\t\tdev_err(sdev->dev, \"Invalid tuples array\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttokens = token_list[token_id].tokens;\n\tnum_tokens = token_list[token_id].count;\n\n\tif (!tokens) {\n\t\tdev_err(sdev->dev, \"No token array defined for token ID: %d\\n\", token_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (*num_copied_tuples >= tuples_size) {\n\t\tdev_err(sdev->dev, \"No space in tuples array for new tokens from %s\",\n\t\t\ttoken_list[token_id].name);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (array_size > 0 && found < num_tokens * token_instance_num) {\n\t\tasize = le32_to_cpu(array->size);\n\n\t\t \n\t\tif (asize < 0) {\n\t\t\tdev_err(sdev->dev, \"Invalid array size 0x%x\\n\", asize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tarray_size -= asize;\n\t\tif (array_size < 0) {\n\t\t\tdev_err(sdev->dev, \"Invalid array size 0x%x\\n\", asize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < le32_to_cpu(array->num_elems); i++) {\n\t\t\t \n\t\t\tfor (j = 0; j < num_tokens; j++) {\n\t\t\t\t \n\t\t\t\tif (!(tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_WORD ||\n\t\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_SHORT ||\n\t\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_BYTE ||\n\t\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_BOOL ||\n\t\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_STRING))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_STRING) {\n\t\t\t\t\tstruct snd_soc_tplg_vendor_string_elem *elem;\n\n\t\t\t\t\telem = &array->string[i];\n\n\t\t\t\t\t \n\t\t\t\t\tif (tokens[j].token != le32_to_cpu(elem->token))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\ttuples[*num_copied_tuples].token = tokens[j].token;\n\t\t\t\t\ttuples[*num_copied_tuples].value.s = elem->string;\n\t\t\t\t} else {\n\t\t\t\t\tstruct snd_soc_tplg_vendor_value_elem *elem;\n\n\t\t\t\t\telem = &array->value[i];\n\n\t\t\t\t\t \n\t\t\t\t\tif (tokens[j].token != le32_to_cpu(elem->token))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\ttuples[*num_copied_tuples].token = tokens[j].token;\n\t\t\t\t\ttuples[*num_copied_tuples].value.v =\n\t\t\t\t\t\tle32_to_cpu(elem->value);\n\t\t\t\t}\n\t\t\t\tfound++;\n\t\t\t\t(*num_copied_tuples)++;\n\n\t\t\t\t \n\t\t\t\tif (*num_copied_tuples == tuples_size)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (found == num_tokens * token_instance_num)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tarray = (struct snd_soc_tplg_vendor_array *)((u8 *)array + asize);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_parse_string_tokens(struct snd_soc_component *scomp,\n\t\t\t\t   void *object, int offset,\n\t\t\t\t   const struct sof_topology_token *tokens, int num_tokens,\n\t\t\t\t   struct snd_soc_tplg_vendor_array *array)\n{\n\tstruct snd_soc_tplg_vendor_string_elem *elem;\n\tint found = 0;\n\tint i, j, ret;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(array->num_elems); i++) {\n\t\telem = &array->string[i];\n\n\t\t \n\t\tfor (j = 0; j < num_tokens; j++) {\n\t\t\t \n\t\t\tif (tokens[j].type != SND_SOC_TPLG_TUPLE_TYPE_STRING)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (tokens[j].token != le32_to_cpu(elem->token))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tret = tokens[j].get_token(elem->string, object, offset + tokens[j].offset);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tfound++;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nstatic int sof_parse_word_tokens(struct snd_soc_component *scomp,\n\t\t\t\t  void *object, int offset,\n\t\t\t\t  const struct sof_topology_token *tokens, int num_tokens,\n\t\t\t\t  struct snd_soc_tplg_vendor_array *array)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *elem;\n\tint found = 0;\n\tint i, j;\n\n\t \n\tfor (i = 0; i < le32_to_cpu(array->num_elems); i++) {\n\t\telem = &array->value[i];\n\n\t\t \n\t\tfor (j = 0; j < num_tokens; j++) {\n\t\t\t \n\t\t\tif (!(tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_WORD ||\n\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_SHORT ||\n\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_BYTE ||\n\t\t\t      tokens[j].type == SND_SOC_TPLG_TUPLE_TYPE_BOOL))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (tokens[j].token != le32_to_cpu(elem->token))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\ttokens[j].get_token(elem, object, offset + tokens[j].offset);\n\n\t\t\tfound++;\n\t\t}\n\t}\n\n\treturn found;\n}\n\n \nstatic int sof_parse_token_sets(struct snd_soc_component *scomp,\n\t\t\t\tvoid *object, const struct sof_topology_token *tokens,\n\t\t\t\tint count, struct snd_soc_tplg_vendor_array *array,\n\t\t\t\tint array_size, int token_instance_num, size_t object_size)\n{\n\tsize_t offset = 0;\n\tint found = 0;\n\tint total = 0;\n\tint asize;\n\tint ret;\n\n\twhile (array_size > 0 && total < count * token_instance_num) {\n\t\tasize = le32_to_cpu(array->size);\n\n\t\t \n\t\tif (asize < 0) {  \n\t\t\tdev_err(scomp->dev, \"error: invalid array size 0x%x\\n\",\n\t\t\t\tasize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tarray_size -= asize;\n\t\tif (array_size < 0) {\n\t\t\tdev_err(scomp->dev, \"error: invalid array size 0x%x\\n\",\n\t\t\t\tasize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tswitch (le32_to_cpu(array->type)) {\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_UUID:\n\t\t\tfound += sof_parse_uuid_tokens(scomp, object, offset, tokens, count,\n\t\t\t\t\t\t       array);\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_STRING:\n\n\t\t\tret = sof_parse_string_tokens(scomp, object, offset, tokens, count,\n\t\t\t\t\t\t      array);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(scomp->dev, \"error: no memory to copy string token\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tfound += ret;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_BOOL:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_BYTE:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_WORD:\n\t\tcase SND_SOC_TPLG_TUPLE_TYPE_SHORT:\n\t\t\tfound += sof_parse_word_tokens(scomp, object, offset, tokens, count,\n\t\t\t\t\t\t       array);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(scomp->dev, \"error: unknown token type %d\\n\",\n\t\t\t\tarray->type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tarray = (struct snd_soc_tplg_vendor_array *)((u8 *)array\n\t\t\t+ asize);\n\n\t\t \n\t\tif (found >= count) {\n\t\t\toffset += object_size;\n\t\t\ttotal += found;\n\t\t\tfound = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_parse_tokens(struct snd_soc_component *scomp,  void *object,\n\t\t\t    const struct sof_topology_token *tokens, int num_tokens,\n\t\t\t    struct snd_soc_tplg_vendor_array *array,\n\t\t\t    int array_size)\n\n{\n\t \n\treturn sof_parse_token_sets(scomp, object, tokens, num_tokens, array,\n\t\t\t\t    array_size, 1, 0);\n}\n\n \n\nstatic int sof_control_load_volume(struct snd_soc_component *scomp,\n\t\t\t\t   struct snd_sof_control *scontrol,\n\t\t\t\t   struct snd_kcontrol_new *kc,\n\t\t\t\t   struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_soc_tplg_mixer_control *mc =\n\t\tcontainer_of(hdr, struct snd_soc_tplg_mixer_control, hdr);\n\tint tlv[SOF_TLV_ITEMS];\n\tunsigned int mask;\n\tint ret;\n\n\t \n\tif (le32_to_cpu(mc->num_channels) > SND_SOC_TPLG_MAX_CHAN)\n\t\treturn -EINVAL;\n\n\t \n\tif (le32_to_cpu(mc->num_channels) > 2)\n\t\tkc->info = snd_sof_volume_info;\n\n\tscontrol->comp_id = sdev->next_comp_id;\n\tscontrol->min_volume_step = le32_to_cpu(mc->min);\n\tscontrol->max_volume_step = le32_to_cpu(mc->max);\n\tscontrol->num_channels = le32_to_cpu(mc->num_channels);\n\n\tscontrol->max = le32_to_cpu(mc->max);\n\tif (le32_to_cpu(mc->max) == 1)\n\t\tgoto skip;\n\n\t \n\tif (!kc->tlv.p || get_tlv_data(kc->tlv.p, tlv) < 0) {\n\t\tdev_err(scomp->dev, \"error: invalid TLV data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = set_up_volume_table(scontrol, tlv, le32_to_cpu(mc->max) + 1);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"error: setting up volume table\\n\");\n\t\treturn ret;\n\t}\n\nskip:\n\t \n\tret = sof_parse_tokens(scomp, &scontrol->led_ctl, led_tokens,\n\t\t\t       ARRAY_SIZE(led_tokens), mc->priv.array,\n\t\t\t       le32_to_cpu(mc->priv.size));\n\tif (ret != 0) {\n\t\tdev_err(scomp->dev, \"error: parse led tokens failed %d\\n\",\n\t\t\tle32_to_cpu(mc->priv.size));\n\t\tgoto err;\n\t}\n\n\tif (scontrol->led_ctl.use_led) {\n\t\tmask = scontrol->led_ctl.direction ? SNDRV_CTL_ELEM_ACCESS_MIC_LED :\n\t\t\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_SPK_LED;\n\t\tscontrol->access &= ~SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\tscontrol->access |= mask;\n\t\tkc->access &= ~SNDRV_CTL_ELEM_ACCESS_LED_MASK;\n\t\tkc->access |= mask;\n\t\tsdev->led_present = true;\n\t}\n\n\tdev_dbg(scomp->dev, \"tplg: load kcontrol index %d chans %d\\n\",\n\t\tscontrol->comp_id, scontrol->num_channels);\n\n\treturn 0;\n\nerr:\n\tif (le32_to_cpu(mc->max) > 1)\n\t\tkfree(scontrol->volume_table);\n\n\treturn ret;\n}\n\nstatic int sof_control_load_enum(struct snd_soc_component *scomp,\n\t\t\t\t struct snd_sof_control *scontrol,\n\t\t\t\t struct snd_kcontrol_new *kc,\n\t\t\t\t struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_soc_tplg_enum_control *ec =\n\t\tcontainer_of(hdr, struct snd_soc_tplg_enum_control, hdr);\n\n\t \n\tif (le32_to_cpu(ec->num_channels) > SND_SOC_TPLG_MAX_CHAN)\n\t\treturn -EINVAL;\n\n\tscontrol->comp_id = sdev->next_comp_id;\n\tscontrol->num_channels = le32_to_cpu(ec->num_channels);\n\n\tdev_dbg(scomp->dev, \"tplg: load kcontrol index %d chans %d comp_id %d\\n\",\n\t\tscontrol->comp_id, scontrol->num_channels, scontrol->comp_id);\n\n\treturn 0;\n}\n\nstatic int sof_control_load_bytes(struct snd_soc_component *scomp,\n\t\t\t\t  struct snd_sof_control *scontrol,\n\t\t\t\t  struct snd_kcontrol_new *kc,\n\t\t\t\t  struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_soc_tplg_bytes_control *control =\n\t\tcontainer_of(hdr, struct snd_soc_tplg_bytes_control, hdr);\n\tstruct soc_bytes_ext *sbe = (struct soc_bytes_ext *)kc->private_value;\n\tsize_t priv_size = le32_to_cpu(control->priv.size);\n\n\tscontrol->max_size = sbe->max;\n\tscontrol->comp_id = sdev->next_comp_id;\n\n\tdev_dbg(scomp->dev, \"tplg: load kcontrol index %d\\n\", scontrol->comp_id);\n\n\t \n\tif (priv_size > 0) {\n\t\tscontrol->priv = kmemdup(control->priv.data, priv_size, GFP_KERNEL);\n\t\tif (!scontrol->priv)\n\t\t\treturn -ENOMEM;\n\n\t\tscontrol->priv_size = priv_size;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sof_control_load(struct snd_soc_component *scomp, int index,\n\t\t\t    struct snd_kcontrol_new *kc,\n\t\t\t    struct snd_soc_tplg_ctl_hdr *hdr)\n{\n\tstruct soc_mixer_control *sm;\n\tstruct soc_bytes_ext *sbe;\n\tstruct soc_enum *se;\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_soc_dobj *dobj;\n\tstruct snd_sof_control *scontrol;\n\tint ret;\n\n\tdev_dbg(scomp->dev, \"tplg: load control type %d name : %s\\n\",\n\t\thdr->type, hdr->name);\n\n\tscontrol = kzalloc(sizeof(*scontrol), GFP_KERNEL);\n\tif (!scontrol)\n\t\treturn -ENOMEM;\n\n\tscontrol->name = kstrdup(hdr->name, GFP_KERNEL);\n\tif (!scontrol->name) {\n\t\tkfree(scontrol);\n\t\treturn -ENOMEM;\n\t}\n\n\tscontrol->scomp = scomp;\n\tscontrol->access = kc->access;\n\tscontrol->info_type = le32_to_cpu(hdr->ops.info);\n\tscontrol->index = kc->index;\n\n\tswitch (le32_to_cpu(hdr->ops.info)) {\n\tcase SND_SOC_TPLG_CTL_VOLSW:\n\tcase SND_SOC_TPLG_CTL_VOLSW_SX:\n\tcase SND_SOC_TPLG_CTL_VOLSW_XR_SX:\n\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\tdobj = &sm->dobj;\n\t\tret = sof_control_load_volume(scomp, scontrol, kc, hdr);\n\t\tbreak;\n\tcase SND_SOC_TPLG_CTL_BYTES:\n\t\tsbe = (struct soc_bytes_ext *)kc->private_value;\n\t\tdobj = &sbe->dobj;\n\t\tret = sof_control_load_bytes(scomp, scontrol, kc, hdr);\n\t\tbreak;\n\tcase SND_SOC_TPLG_CTL_ENUM:\n\tcase SND_SOC_TPLG_CTL_ENUM_VALUE:\n\t\tse = (struct soc_enum *)kc->private_value;\n\t\tdobj = &se->dobj;\n\t\tret = sof_control_load_enum(scomp, scontrol, kc, hdr);\n\t\tbreak;\n\tcase SND_SOC_TPLG_CTL_RANGE:\n\tcase SND_SOC_TPLG_CTL_STROBE:\n\tcase SND_SOC_TPLG_DAPM_CTL_VOLSW:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_DOUBLE:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VIRT:\n\tcase SND_SOC_TPLG_DAPM_CTL_ENUM_VALUE:\n\tcase SND_SOC_TPLG_DAPM_CTL_PIN:\n\tdefault:\n\t\tdev_warn(scomp->dev, \"control type not supported %d:%d:%d\\n\",\n\t\t\t hdr->ops.get, hdr->ops.put, hdr->ops.info);\n\t\tkfree(scontrol->name);\n\t\tkfree(scontrol);\n\t\treturn 0;\n\t}\n\n\tif (ret < 0) {\n\t\tkfree(scontrol->name);\n\t\tkfree(scontrol);\n\t\treturn ret;\n\t}\n\n\tscontrol->led_ctl.led_value = -1;\n\n\tdobj->private = scontrol;\n\tlist_add(&scontrol->list, &sdev->kcontrol_list);\n\treturn 0;\n}\n\nstatic int sof_control_unload(struct snd_soc_component *scomp,\n\t\t\t      struct snd_soc_dobj *dobj)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_sof_control *scontrol = dobj->private;\n\tint ret = 0;\n\n\tdev_dbg(scomp->dev, \"tplg: unload control name : %s\\n\", scontrol->name);\n\n\tif (tplg_ops && tplg_ops->control_free) {\n\t\tret = tplg_ops->control_free(sdev, scontrol);\n\t\tif (ret < 0)\n\t\t\tdev_err(scomp->dev, \"failed to free control: %s\\n\", scontrol->name);\n\t}\n\n\t \n\tkfree(scontrol->ipc_control_data);\n\tkfree(scontrol->priv);\n\tkfree(scontrol->name);\n\tlist_del(&scontrol->list);\n\tkfree(scontrol);\n\n\treturn ret;\n}\n\n \n\nstatic int sof_connect_dai_widget(struct snd_soc_component *scomp,\n\t\t\t\t  struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_soc_tplg_dapm_widget *tw,\n\t\t\t\t  struct snd_sof_dai *dai)\n{\n\tstruct snd_soc_card *card = scomp->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *cpu_dai;\n\tint stream;\n\tint i;\n\n\tif (!w->sname) {\n\t\tdev_err(scomp->dev, \"Widget %s does not have stream\\n\", w->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (w->id == snd_soc_dapm_dai_out)\n\t\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\telse if (w->id == snd_soc_dapm_dai_in)\n\t\tstream = SNDRV_PCM_STREAM_PLAYBACK;\n\telse\n\t\tgoto end;\n\n\tlist_for_each_entry(rtd, &card->rtd_list, list) {\n\t\t \n\t\tif (!rtd->dai_link->stream_name ||\n\t\t    !strstr(rtd->dai_link->stream_name, w->sname))\n\t\t\tcontinue;\n\n\t\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\t\t \n\t\t\tif (!snd_soc_dai_get_widget(cpu_dai, stream)) {\n\t\t\t\tsnd_soc_dai_set_widget(cpu_dai, stream, w);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == rtd->dai_link->num_cpus) {\n\t\t\tdev_err(scomp->dev, \"error: can't find BE for DAI %s\\n\", w->name);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdai->name = rtd->dai_link->name;\n\t\tdev_dbg(scomp->dev, \"tplg: connected widget %s -> DAI link %s\\n\",\n\t\t\tw->name, rtd->dai_link->name);\n\t}\nend:\n\t \n\tif (!dai->name) {\n\t\tdev_err(scomp->dev, \"error: can't connect DAI %s stream %s\\n\",\n\t\t\tw->name, w->sname);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void sof_disconnect_dai_widget(struct snd_soc_component *scomp,\n\t\t\t\t      struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_card *card = scomp->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tconst char *sname = w->sname;\n\tstruct snd_soc_dai *cpu_dai;\n\tint i, stream;\n\n\tif (!sname)\n\t\treturn;\n\n\tif (w->id == snd_soc_dapm_dai_out)\n\t\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\telse if (w->id == snd_soc_dapm_dai_in)\n\t\tstream = SNDRV_PCM_STREAM_PLAYBACK;\n\telse\n\t\treturn;\n\n\tlist_for_each_entry(rtd, &card->rtd_list, list) {\n\t\t \n\t\tif (!rtd->dai_link->stream_name ||\n\t\t    !strstr(rtd->dai_link->stream_name, sname))\n\t\t\tcontinue;\n\n\t\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai)\n\t\t\tif (snd_soc_dai_get_widget(cpu_dai, stream) == w) {\n\t\t\t\tsnd_soc_dai_set_widget(cpu_dai, stream, NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n}\n\n \nstatic int spcm_bind(struct snd_soc_component *scomp, struct snd_sof_pcm *spcm,\n\t\t     int dir)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_widget *host_widget;\n\n\tif (sdev->dspless_mode_selected)\n\t\treturn 0;\n\n\thost_widget = snd_sof_find_swidget_sname(scomp,\n\t\t\t\t\t\t spcm->pcm.caps[dir].name,\n\t\t\t\t\t\t dir);\n\tif (!host_widget) {\n\t\tdev_err(scomp->dev, \"can't find host comp to bind pcm\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspcm->stream[dir].comp_id = host_widget->comp_id;\n\n\treturn 0;\n}\n\nstatic int sof_get_token_value(u32 token_id, struct snd_sof_tuple *tuples, int num_tuples)\n{\n\tint i;\n\n\tif (!tuples)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_tuples; i++) {\n\t\tif (tuples[i].token == token_id)\n\t\t\treturn tuples[i].value.v;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int sof_widget_parse_tokens(struct snd_soc_component *scomp, struct snd_sof_widget *swidget,\n\t\t\t\t   struct snd_soc_tplg_dapm_widget *tw,\n\t\t\t\t   enum sof_tokens *object_token_list, int count)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_soc_tplg_private *private = &tw->priv;\n\tconst struct sof_token_info *token_list;\n\tint num_tuples = 0;\n\tint ret, i;\n\n\ttoken_list = tplg_ops ? tplg_ops->token_list : NULL;\n\t \n\tif (!token_list)\n\t\treturn 0;\n\n\tif (count > 0 && !object_token_list) {\n\t\tdev_err(scomp->dev, \"No token list for widget %s\\n\", swidget->widget->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++)\n\t\tnum_tuples += token_list[object_token_list[i]].count;\n\n\t \n\tswidget->tuples = kcalloc(num_tuples, sizeof(*swidget->tuples), GFP_KERNEL);\n\tif (!swidget->tuples)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint num_sets = 1;\n\n\t\tif (object_token_list[i] >= SOF_TOKEN_COUNT) {\n\t\t\tdev_err(scomp->dev, \"Invalid token id %d for widget %s\\n\",\n\t\t\t\tobject_token_list[i], swidget->widget->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (object_token_list[i]) {\n\t\tcase SOF_COMP_EXT_TOKENS:\n\t\t\t \n\t\t\tret = sof_parse_tokens(scomp, swidget,\n\t\t\t\t\t       token_list[object_token_list[i]].tokens,\n\t\t\t\t\t       token_list[object_token_list[i]].count,\n\t\t\t\t\t       private->array, le32_to_cpu(private->size));\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(scomp->dev, \"Failed parsing %s for widget %s\\n\",\n\t\t\t\t\ttoken_list[object_token_list[i]].name,\n\t\t\t\t\tswidget->widget->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\tcase SOF_IN_AUDIO_FORMAT_TOKENS:\n\t\t\tnum_sets = sof_get_token_value(SOF_TKN_COMP_NUM_INPUT_AUDIO_FORMATS,\n\t\t\t\t\t\t       swidget->tuples, swidget->num_tuples);\n\t\t\tif (num_sets < 0) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid input audio format count for %s\\n\",\n\t\t\t\t\tswidget->widget->name);\n\t\t\t\tret = num_sets;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SOF_OUT_AUDIO_FORMAT_TOKENS:\n\t\t\tnum_sets = sof_get_token_value(SOF_TKN_COMP_NUM_OUTPUT_AUDIO_FORMATS,\n\t\t\t\t\t\t       swidget->tuples, swidget->num_tuples);\n\t\t\tif (num_sets < 0) {\n\t\t\t\tdev_err(sdev->dev, \"Invalid output audio format count for %s\\n\",\n\t\t\t\t\tswidget->widget->name);\n\t\t\t\tret = num_sets;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (num_sets > 1) {\n\t\t\tstruct snd_sof_tuple *new_tuples;\n\n\t\t\tnum_tuples += token_list[object_token_list[i]].count * (num_sets - 1);\n\t\t\tnew_tuples = krealloc(swidget->tuples,\n\t\t\t\t\t      sizeof(*new_tuples) * num_tuples, GFP_KERNEL);\n\t\t\tif (!new_tuples) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tswidget->tuples = new_tuples;\n\t\t}\n\n\t\t \n\t\tret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),\n\t\t\t\t      object_token_list[i], num_sets, swidget->tuples,\n\t\t\t\t      num_tuples, &swidget->num_tuples);\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"Failed parsing %s for widget %s err: %d\\n\",\n\t\t\t\ttoken_list[object_token_list[i]].name, swidget->widget->name, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tkfree(swidget->tuples);\n\treturn ret;\n}\n\nstatic void sof_free_pin_binding(struct snd_sof_widget *swidget,\n\t\t\t\t bool pin_type)\n{\n\tchar **pin_binding;\n\tu32 num_pins;\n\tint i;\n\n\tif (pin_type == SOF_PIN_TYPE_INPUT) {\n\t\tpin_binding = swidget->input_pin_binding;\n\t\tnum_pins = swidget->num_input_pins;\n\t} else {\n\t\tpin_binding = swidget->output_pin_binding;\n\t\tnum_pins = swidget->num_output_pins;\n\t}\n\n\tif (pin_binding) {\n\t\tfor (i = 0; i < num_pins; i++)\n\t\t\tkfree(pin_binding[i]);\n\t}\n\n\tkfree(pin_binding);\n}\n\nstatic int sof_parse_pin_binding(struct snd_sof_widget *swidget,\n\t\t\t\t struct snd_soc_tplg_private *priv, bool pin_type)\n{\n\tconst struct sof_topology_token *pin_binding_token;\n\tchar *pin_binding[SOF_WIDGET_MAX_NUM_PINS];\n\tint token_count;\n\tu32 num_pins;\n\tchar **pb;\n\tint ret;\n\tint i;\n\n\tif (pin_type == SOF_PIN_TYPE_INPUT) {\n\t\tnum_pins = swidget->num_input_pins;\n\t\tpin_binding_token = comp_input_pin_binding_tokens;\n\t\ttoken_count = ARRAY_SIZE(comp_input_pin_binding_tokens);\n\t} else {\n\t\tnum_pins = swidget->num_output_pins;\n\t\tpin_binding_token = comp_output_pin_binding_tokens;\n\t\ttoken_count = ARRAY_SIZE(comp_output_pin_binding_tokens);\n\t}\n\n\tmemset(pin_binding, 0, SOF_WIDGET_MAX_NUM_PINS * sizeof(char *));\n\tret = sof_parse_token_sets(swidget->scomp, pin_binding, pin_binding_token,\n\t\t\t\t   token_count, priv->array, le32_to_cpu(priv->size),\n\t\t\t\t   num_pins, sizeof(char *));\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (pin_binding[0]) {\n\t\tpb = kmemdup(pin_binding, num_pins * sizeof(char *), GFP_KERNEL);\n\t\tif (!pb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (pin_type == SOF_PIN_TYPE_INPUT)\n\t\t\tswidget->input_pin_binding = pb;\n\t\telse\n\t\t\tswidget->output_pin_binding = pb;\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < num_pins; i++)\n\t\tkfree(pin_binding[i]);\n\n\treturn ret;\n}\n\nstatic int get_w_no_wname_in_long_name(void *elem, void *object, u32 offset)\n{\n\tstruct snd_soc_tplg_vendor_value_elem *velem = elem;\n\tstruct snd_soc_dapm_widget *w = object;\n\n\tw->no_wname_in_kcontrol_name = !!le32_to_cpu(velem->value);\n\treturn 0;\n}\n\nstatic const struct sof_topology_token dapm_widget_tokens[] = {\n\t{SOF_TKN_COMP_NO_WNAME_IN_KCONTROL_NAME, SND_SOC_TPLG_TUPLE_TYPE_BOOL,\n\t get_w_no_wname_in_long_name, 0}\n};\n\n \nstatic int sof_widget_ready(struct snd_soc_component *scomp, int index,\n\t\t\t    struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_soc_tplg_dapm_widget *tw)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tconst struct sof_ipc_tplg_widget_ops *widget_ops;\n\tstruct snd_soc_tplg_private *priv = &tw->priv;\n\tenum sof_tokens *token_list = NULL;\n\tstruct snd_sof_widget *swidget;\n\tstruct snd_sof_dai *dai;\n\tint token_list_size = 0;\n\tint ret = 0;\n\n\tswidget = kzalloc(sizeof(*swidget), GFP_KERNEL);\n\tif (!swidget)\n\t\treturn -ENOMEM;\n\n\tswidget->scomp = scomp;\n\tswidget->widget = w;\n\tswidget->comp_id = sdev->next_comp_id++;\n\tswidget->id = w->id;\n\tswidget->pipeline_id = index;\n\tswidget->private = NULL;\n\tmutex_init(&swidget->setup_mutex);\n\n\tida_init(&swidget->output_queue_ida);\n\tida_init(&swidget->input_queue_ida);\n\n\tret = sof_parse_tokens(scomp, w, dapm_widget_tokens, ARRAY_SIZE(dapm_widget_tokens),\n\t\t\t       priv->array, le32_to_cpu(priv->size));\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"failed to parse dapm widget tokens for %s\\n\",\n\t\t\tw->name);\n\t\tgoto widget_free;\n\t}\n\n\tret = sof_parse_tokens(scomp, swidget, comp_pin_tokens,\n\t\t\t       ARRAY_SIZE(comp_pin_tokens), priv->array,\n\t\t\t       le32_to_cpu(priv->size));\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"failed to parse component pin tokens for %s\\n\",\n\t\t\tw->name);\n\t\tgoto widget_free;\n\t}\n\n\tif (swidget->num_input_pins > SOF_WIDGET_MAX_NUM_PINS ||\n\t    swidget->num_output_pins > SOF_WIDGET_MAX_NUM_PINS) {\n\t\tdev_err(scomp->dev, \"invalid pins for %s: [input: %d, output: %d]\\n\",\n\t\t\tswidget->widget->name, swidget->num_input_pins, swidget->num_output_pins);\n\t\tret = -EINVAL;\n\t\tgoto widget_free;\n\t}\n\n\tif (swidget->num_input_pins > 1) {\n\t\tret = sof_parse_pin_binding(swidget, priv, SOF_PIN_TYPE_INPUT);\n\t\t \n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"failed to parse input pin binding for %s\\n\",\n\t\t\t\tw->name);\n\t\t\tgoto widget_free;\n\t\t}\n\t}\n\n\tif (swidget->num_output_pins > 1) {\n\t\tret = sof_parse_pin_binding(swidget, priv, SOF_PIN_TYPE_OUTPUT);\n\t\t \n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"failed to parse output pin binding for %s\\n\",\n\t\t\t\tw->name);\n\t\t\tgoto widget_free;\n\t\t}\n\t}\n\n\tdev_dbg(scomp->dev,\n\t\t\"tplg: widget %d (%s) is ready [type: %d, pipe: %d, pins: %d / %d, stream: %s]\\n\",\n\t\tswidget->comp_id, w->name, swidget->id, index,\n\t\tswidget->num_input_pins, swidget->num_output_pins,\n\t\tstrnlen(w->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0 ? w->sname : \"none\");\n\n\twidget_ops = tplg_ops ? tplg_ops->widget : NULL;\n\tif (widget_ops) {\n\t\ttoken_list = widget_ops[w->id].token_list;\n\t\ttoken_list_size = widget_ops[w->id].token_list_size;\n\t}\n\n\t \n\tswitch (w->id) {\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t\tdai = kzalloc(sizeof(*dai), GFP_KERNEL);\n\t\tif (!dai) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto widget_free;\n\t\t}\n\n\t\tret = sof_widget_parse_tokens(scomp, swidget, tw, token_list, token_list_size);\n\t\tif (!ret)\n\t\t\tret = sof_connect_dai_widget(scomp, w, tw, dai);\n\t\tif (ret < 0) {\n\t\t\tkfree(dai);\n\t\t\tbreak;\n\t\t}\n\t\tlist_add(&dai->list, &sdev->dai_list);\n\t\tswidget->private = dai;\n\t\tbreak;\n\tcase snd_soc_dapm_effect:\n\t\t \n\t\tif (le32_to_cpu(tw->priv.size) == 0) {\n\t\t\tdev_err(scomp->dev, \"error: process tokens not found\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = sof_widget_parse_tokens(scomp, swidget, tw, token_list, token_list_size);\n\t\tbreak;\n\tcase snd_soc_dapm_pga:\n\t\tif (!le32_to_cpu(tw->num_kcontrols)) {\n\t\t\tdev_err(scomp->dev, \"invalid kcontrol count %d for volume\\n\",\n\t\t\t\ttw->num_kcontrols);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfallthrough;\n\tcase snd_soc_dapm_mixer:\n\tcase snd_soc_dapm_buffer:\n\tcase snd_soc_dapm_scheduler:\n\tcase snd_soc_dapm_aif_out:\n\tcase snd_soc_dapm_aif_in:\n\tcase snd_soc_dapm_src:\n\tcase snd_soc_dapm_asrc:\n\tcase snd_soc_dapm_siggen:\n\tcase snd_soc_dapm_mux:\n\tcase snd_soc_dapm_demux:\n\t\tret = sof_widget_parse_tokens(scomp, swidget, tw,  token_list, token_list_size);\n\t\tbreak;\n\tcase snd_soc_dapm_switch:\n\tcase snd_soc_dapm_dai_link:\n\tcase snd_soc_dapm_kcontrol:\n\tdefault:\n\t\tdev_dbg(scomp->dev, \"widget type %d name %s not handled\\n\", swidget->id, tw->name);\n\t\tbreak;\n\t}\n\n\t \n\tif (ret < 0) {\n\t\tdev_err(scomp->dev,\n\t\t\t\"error: failed to add widget id %d type %d name : %s stream %s\\n\",\n\t\t\ttw->shift, swidget->id, tw->name,\n\t\t\tstrnlen(tw->sname, SNDRV_CTL_ELEM_ID_NAME_MAXLEN) > 0\n\t\t\t\t? tw->sname : \"none\");\n\t\tgoto widget_free;\n\t}\n\n\tif (sof_debug_check_flag(SOF_DBG_DISABLE_MULTICORE)) {\n\t\tswidget->core = SOF_DSP_PRIMARY_CORE;\n\t} else {\n\t\tint core = sof_get_token_value(SOF_TKN_COMP_CORE_ID, swidget->tuples,\n\t\t\t\t\t       swidget->num_tuples);\n\n\t\tif (core >= 0)\n\t\t\tswidget->core = core;\n\t}\n\n\t \n\tif (tw->event_type) {\n\t\tif (widget_ops && widget_ops[w->id].bind_event) {\n\t\t\tret = widget_ops[w->id].bind_event(scomp, swidget,\n\t\t\t\t\t\t\t   le16_to_cpu(tw->event_type));\n\t\t\tif (ret) {\n\t\t\t\tdev_err(scomp->dev, \"widget event binding failed for %s\\n\",\n\t\t\t\t\tswidget->widget->name);\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (w->id == snd_soc_dapm_scheduler) {\n\t\tstruct snd_sof_pipeline *spipe;\n\n\t\tspipe = kzalloc(sizeof(*spipe), GFP_KERNEL);\n\t\tif (!spipe) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\n\t\tspipe->pipe_widget = swidget;\n\t\tswidget->spipe = spipe;\n\t\tlist_add(&spipe->list, &sdev->pipeline_list);\n\t}\n\n\tw->dobj.private = swidget;\n\tlist_add(&swidget->list, &sdev->widget_list);\n\treturn ret;\nfree:\n\tkfree(swidget->private);\n\tkfree(swidget->tuples);\nwidget_free:\n\tkfree(swidget);\n\treturn ret;\n}\n\nstatic int sof_route_unload(struct snd_soc_component *scomp,\n\t\t\t    struct snd_soc_dobj *dobj)\n{\n\tstruct snd_sof_route *sroute;\n\n\tsroute = dobj->private;\n\tif (!sroute)\n\t\treturn 0;\n\n\t \n\tkfree(sroute->private);\n\tlist_del(&sroute->list);\n\tkfree(sroute);\n\n\treturn 0;\n}\n\nstatic int sof_widget_unload(struct snd_soc_component *scomp,\n\t\t\t     struct snd_soc_dobj *dobj)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tconst struct sof_ipc_tplg_widget_ops *widget_ops;\n\tconst struct snd_kcontrol_new *kc;\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct snd_sof_control *scontrol;\n\tstruct snd_sof_widget *swidget;\n\tstruct soc_mixer_control *sm;\n\tstruct soc_bytes_ext *sbe;\n\tstruct snd_sof_dai *dai;\n\tstruct soc_enum *se;\n\tint i;\n\n\tswidget = dobj->private;\n\tif (!swidget)\n\t\treturn 0;\n\n\twidget = swidget->widget;\n\n\tswitch (swidget->id) {\n\tcase snd_soc_dapm_dai_in:\n\tcase snd_soc_dapm_dai_out:\n\t\tdai = swidget->private;\n\n\t\tif (dai)\n\t\t\tlist_del(&dai->list);\n\n\t\tsof_disconnect_dai_widget(scomp, widget);\n\n\t\tbreak;\n\tcase snd_soc_dapm_scheduler:\n\t{\n\t\tstruct snd_sof_pipeline *spipe = swidget->spipe;\n\n\t\tlist_del(&spipe->list);\n\t\tkfree(spipe);\n\t\tswidget->spipe = NULL;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tfor (i = 0; i < widget->num_kcontrols; i++) {\n\t\tkc = &widget->kcontrol_news[i];\n\t\tswitch (widget->dobj.widget.kcontrol_type[i]) {\n\t\tcase SND_SOC_TPLG_TYPE_MIXER:\n\t\t\tsm = (struct soc_mixer_control *)kc->private_value;\n\t\t\tscontrol = sm->dobj.private;\n\t\t\tif (sm->max > 1)\n\t\t\t\tkfree(scontrol->volume_table);\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TYPE_ENUM:\n\t\t\tse = (struct soc_enum *)kc->private_value;\n\t\t\tscontrol = se->dobj.private;\n\t\t\tbreak;\n\t\tcase SND_SOC_TPLG_TYPE_BYTES:\n\t\t\tsbe = (struct soc_bytes_ext *)kc->private_value;\n\t\t\tscontrol = sbe->dobj.private;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(scomp->dev, \"unsupported kcontrol_type\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tkfree(scontrol->ipc_control_data);\n\t\tlist_del(&scontrol->list);\n\t\tkfree(scontrol->name);\n\t\tkfree(scontrol);\n\t}\n\nout:\n\t \n\twidget_ops = tplg_ops ? tplg_ops->widget : NULL;\n\tif (widget_ops && widget_ops[swidget->id].ipc_free)\n\t\twidget_ops[swidget->id].ipc_free(swidget);\n\n\tida_destroy(&swidget->output_queue_ida);\n\tida_destroy(&swidget->input_queue_ida);\n\n\tsof_free_pin_binding(swidget, SOF_PIN_TYPE_INPUT);\n\tsof_free_pin_binding(swidget, SOF_PIN_TYPE_OUTPUT);\n\n\tkfree(swidget->tuples);\n\n\t \n\tlist_del(&swidget->list);\n\tkfree(swidget);\n\n\treturn 0;\n}\n\n \n\n \nstatic int sof_dai_load(struct snd_soc_component *scomp, int index,\n\t\t\tstruct snd_soc_dai_driver *dai_drv,\n\t\t\tstruct snd_soc_tplg_pcm *pcm, struct snd_soc_dai *dai)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_pcm_ops *ipc_pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tstruct snd_soc_tplg_stream_caps *caps;\n\tstruct snd_soc_tplg_private *private = &pcm->priv;\n\tstruct snd_sof_pcm *spcm;\n\tint stream;\n\tint ret;\n\n\t \n\tif (!pcm)\n\t\treturn 0;\n\n\tspcm = kzalloc(sizeof(*spcm), GFP_KERNEL);\n\tif (!spcm)\n\t\treturn -ENOMEM;\n\n\tspcm->scomp = scomp;\n\n\tfor_each_pcm_streams(stream) {\n\t\tspcm->stream[stream].comp_id = COMP_ID_UNASSIGNED;\n\t\tif (pcm->compress)\n\t\t\tsnd_sof_compr_init_elapsed_work(&spcm->stream[stream].period_elapsed_work);\n\t\telse\n\t\t\tsnd_sof_pcm_init_elapsed_work(&spcm->stream[stream].period_elapsed_work);\n\t}\n\n\tspcm->pcm = *pcm;\n\tdev_dbg(scomp->dev, \"tplg: load pcm %s\\n\", pcm->dai_name);\n\n\t \n\tif (ipc_pcm_ops && ipc_pcm_ops->pcm_setup) {\n\t\tret = ipc_pcm_ops->pcm_setup(sdev, spcm);\n\t\tif (ret < 0) {\n\t\t\tkfree(spcm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdai_drv->dobj.private = spcm;\n\tlist_add(&spcm->list, &sdev->pcm_list);\n\n\tret = sof_parse_tokens(scomp, spcm, stream_tokens,\n\t\t\t       ARRAY_SIZE(stream_tokens), private->array,\n\t\t\t       le32_to_cpu(private->size));\n\tif (ret) {\n\t\tdev_err(scomp->dev, \"error: parse stream tokens failed %d\\n\",\n\t\t\tle32_to_cpu(private->size));\n\t\treturn ret;\n\t}\n\n\t \n\tif (!spcm->pcm.playback)\n\t\tgoto capture;\n\n\tstream = SNDRV_PCM_STREAM_PLAYBACK;\n\n\tcaps = &spcm->pcm.caps[stream];\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,\n\t\t\t\t  PAGE_SIZE, &spcm->stream[stream].page_table);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"error: can't alloc page table for %s %d\\n\",\n\t\t\tcaps->name, ret);\n\n\t\treturn ret;\n\t}\n\n\t \n\tret = spcm_bind(scomp, spcm, stream);\n\tif (ret) {\n\t\tdev_err(scomp->dev,\n\t\t\t\"error: can't bind pcm to host\\n\");\n\t\tgoto free_playback_tables;\n\t}\n\ncapture:\n\tstream = SNDRV_PCM_STREAM_CAPTURE;\n\n\t \n\tif (!spcm->pcm.capture)\n\t\treturn ret;\n\n\tcaps = &spcm->pcm.caps[stream];\n\n\t \n\tret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, sdev->dev,\n\t\t\t\t  PAGE_SIZE, &spcm->stream[stream].page_table);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"error: can't alloc page table for %s %d\\n\",\n\t\t\tcaps->name, ret);\n\t\tgoto free_playback_tables;\n\t}\n\n\t \n\tret = spcm_bind(scomp, spcm, stream);\n\tif (ret) {\n\t\tdev_err(scomp->dev,\n\t\t\t\"error: can't bind pcm to host\\n\");\n\t\tsnd_dma_free_pages(&spcm->stream[stream].page_table);\n\t\tgoto free_playback_tables;\n\t}\n\n\treturn ret;\n\nfree_playback_tables:\n\tif (spcm->pcm.playback)\n\t\tsnd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].page_table);\n\n\treturn ret;\n}\n\nstatic int sof_dai_unload(struct snd_soc_component *scomp,\n\t\t\t  struct snd_soc_dobj *dobj)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_pcm_ops *ipc_pcm_ops = sof_ipc_get_ops(sdev, pcm);\n\tstruct snd_sof_pcm *spcm = dobj->private;\n\n\t \n\tif (spcm->pcm.playback)\n\t\tsnd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_PLAYBACK].page_table);\n\n\tif (spcm->pcm.capture)\n\t\tsnd_dma_free_pages(&spcm->stream[SNDRV_PCM_STREAM_CAPTURE].page_table);\n\n\t \n\tif (ipc_pcm_ops && ipc_pcm_ops->pcm_free)\n\t\tipc_pcm_ops->pcm_free(sdev, spcm);\n\n\t \n\tlist_del(&spcm->list);\n\tkfree(spcm);\n\n\treturn 0;\n}\n\nstatic const struct sof_topology_token common_dai_link_tokens[] = {\n\t{SOF_TKN_DAI_TYPE, SND_SOC_TPLG_TUPLE_TYPE_STRING, get_token_dai_type,\n\t\toffsetof(struct snd_sof_dai_link, type)},\n};\n\n \nstatic int sof_link_load(struct snd_soc_component *scomp, int index, struct snd_soc_dai_link *link,\n\t\t\t struct snd_soc_tplg_link_config *cfg)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tstruct snd_soc_tplg_private *private = &cfg->priv;\n\tconst struct sof_token_info *token_list;\n\tstruct snd_sof_dai_link *slink;\n\tu32 token_id = 0;\n\tint num_tuples = 0;\n\tint ret, num_sets;\n\n\tif (!link->platforms) {\n\t\tdev_err(scomp->dev, \"error: no platforms\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlink->platforms->name = dev_name(scomp->dev);\n\n\tif (tplg_ops && tplg_ops->link_setup) {\n\t\tret = tplg_ops->link_setup(sdev, link);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!link->no_pcm) {\n\t\tlink->nonatomic = true;\n\t\treturn 0;\n\t}\n\n\t \n\tif (le32_to_cpu(private->size) == 0) {\n\t\tdev_err(scomp->dev, \"error: expected tokens for DAI, none found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tslink = kzalloc(sizeof(*slink), GFP_KERNEL);\n\tif (!slink)\n\t\treturn -ENOMEM;\n\n\tslink->num_hw_configs = le32_to_cpu(cfg->num_hw_configs);\n\tslink->hw_configs = kmemdup(cfg->hw_config,\n\t\t\t\t    sizeof(*slink->hw_configs) * slink->num_hw_configs,\n\t\t\t\t    GFP_KERNEL);\n\tif (!slink->hw_configs) {\n\t\tkfree(slink);\n\t\treturn -ENOMEM;\n\t}\n\n\tslink->default_hw_cfg_id = le32_to_cpu(cfg->default_hw_config_id);\n\tslink->link = link;\n\n\tdev_dbg(scomp->dev, \"tplg: %d hw_configs found, default id: %d for dai link %s!\\n\",\n\t\tslink->num_hw_configs, slink->default_hw_cfg_id, link->name);\n\n\tret = sof_parse_tokens(scomp, slink, common_dai_link_tokens,\n\t\t\t       ARRAY_SIZE(common_dai_link_tokens),\n\t\t\t       private->array, le32_to_cpu(private->size));\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"Failed tp parse common DAI link tokens\\n\");\n\t\tkfree(slink->hw_configs);\n\t\tkfree(slink);\n\t\treturn ret;\n\t}\n\n\ttoken_list = tplg_ops ? tplg_ops->token_list : NULL;\n\tif (!token_list)\n\t\tgoto out;\n\n\t \n\tnum_tuples += token_list[SOF_DAI_LINK_TOKENS].count;\n\tnum_sets = slink->num_hw_configs;\n\tswitch (slink->type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\ttoken_id = SOF_SSP_TOKENS;\n\t\tnum_tuples += token_list[SOF_SSP_TOKENS].count * slink->num_hw_configs;\n\t\tbreak;\n\tcase SOF_DAI_INTEL_DMIC:\n\t\ttoken_id = SOF_DMIC_TOKENS;\n\t\tnum_tuples += token_list[SOF_DMIC_TOKENS].count;\n\n\t\t \n\t\tnum_tuples += token_list[SOF_DMIC_PDM_TOKENS].count * SOF_DAI_INTEL_DMIC_NUM_CTRL;\n\t\tbreak;\n\tcase SOF_DAI_INTEL_HDA:\n\t\ttoken_id = SOF_HDA_TOKENS;\n\t\tnum_tuples += token_list[SOF_HDA_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_INTEL_ALH:\n\t\ttoken_id = SOF_ALH_TOKENS;\n\t\tnum_tuples += token_list[SOF_ALH_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_IMX_SAI:\n\t\ttoken_id = SOF_SAI_TOKENS;\n\t\tnum_tuples += token_list[SOF_SAI_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_IMX_ESAI:\n\t\ttoken_id = SOF_ESAI_TOKENS;\n\t\tnum_tuples += token_list[SOF_ESAI_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_MEDIATEK_AFE:\n\t\ttoken_id = SOF_AFE_TOKENS;\n\t\tnum_tuples += token_list[SOF_AFE_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_AMD_DMIC:\n\t\ttoken_id = SOF_ACPDMIC_TOKENS;\n\t\tnum_tuples += token_list[SOF_ACPDMIC_TOKENS].count;\n\t\tbreak;\n\tcase SOF_DAI_AMD_SP:\n\tcase SOF_DAI_AMD_HS:\n\tcase SOF_DAI_AMD_SP_VIRTUAL:\n\tcase SOF_DAI_AMD_HS_VIRTUAL:\n\t\ttoken_id = SOF_ACPI2S_TOKENS;\n\t\tnum_tuples += token_list[SOF_ACPI2S_TOKENS].count;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tslink->tuples = kcalloc(num_tuples, sizeof(*slink->tuples), GFP_KERNEL);\n\tif (!slink->tuples) {\n\t\tkfree(slink->hw_configs);\n\t\tkfree(slink);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (token_list[SOF_DAI_LINK_TOKENS].tokens) {\n\t\t \n\t\tret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),\n\t\t\t\t      SOF_DAI_LINK_TOKENS, 1, slink->tuples,\n\t\t\t\t      num_tuples, &slink->num_tuples);\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"failed to parse %s for dai link %s\\n\",\n\t\t\t\ttoken_list[SOF_DAI_LINK_TOKENS].name, link->name);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tif (!token_id || !token_list[token_id].tokens)\n\t\tgoto out;\n\n\t \n\tret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),\n\t\t\t      token_id, num_sets, slink->tuples, num_tuples, &slink->num_tuples);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"failed to parse %s for dai link %s\\n\",\n\t\t\ttoken_list[token_id].name, link->name);\n\t\tgoto err;\n\t}\n\n\t \n\tif (token_id == SOF_DMIC_TOKENS) {\n\t\tnum_sets = sof_get_token_value(SOF_TKN_INTEL_DMIC_NUM_PDM_ACTIVE,\n\t\t\t\t\t       slink->tuples, slink->num_tuples);\n\n\t\tif (num_sets < 0) {\n\t\t\tdev_err(sdev->dev, \"Invalid active PDM count for %s\\n\", link->name);\n\t\t\tret = num_sets;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = sof_copy_tuples(sdev, private->array, le32_to_cpu(private->size),\n\t\t\t\t      SOF_DMIC_PDM_TOKENS, num_sets, slink->tuples,\n\t\t\t\t      num_tuples, &slink->num_tuples);\n\t\tif (ret < 0) {\n\t\t\tdev_err(scomp->dev, \"failed to parse %s for dai link %s\\n\",\n\t\t\t\ttoken_list[SOF_DMIC_PDM_TOKENS].name, link->name);\n\t\t\tgoto err;\n\t\t}\n\t}\nout:\n\tlink->dobj.private = slink;\n\tlist_add(&slink->list, &sdev->dai_link_list);\n\n\treturn 0;\n\nerr:\n\tkfree(slink->tuples);\n\tkfree(slink->hw_configs);\n\tkfree(slink);\n\n\treturn ret;\n}\n\nstatic int sof_link_unload(struct snd_soc_component *scomp, struct snd_soc_dobj *dobj)\n{\n\tstruct snd_sof_dai_link *slink = dobj->private;\n\n\tif (!slink)\n\t\treturn 0;\n\n\tkfree(slink->tuples);\n\tlist_del(&slink->list);\n\tkfree(slink->hw_configs);\n\tkfree(slink);\n\tdobj->private = NULL;\n\n\treturn 0;\n}\n\n \nstatic int sof_route_load(struct snd_soc_component *scomp, int index,\n\t\t\t  struct snd_soc_dapm_route *route)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tstruct snd_sof_widget *source_swidget, *sink_swidget;\n\tstruct snd_soc_dobj *dobj = &route->dobj;\n\tstruct snd_sof_route *sroute;\n\tint ret = 0;\n\n\t \n\tsroute = kzalloc(sizeof(*sroute), GFP_KERNEL);\n\tif (!sroute)\n\t\treturn -ENOMEM;\n\n\tsroute->scomp = scomp;\n\tdev_dbg(scomp->dev, \"sink %s control %s source %s\\n\",\n\t\troute->sink, route->control ? route->control : \"none\",\n\t\troute->source);\n\n\t \n\tsource_swidget = snd_sof_find_swidget(scomp, (char *)route->source);\n\tif (!source_swidget) {\n\t\tdev_err(scomp->dev, \"error: source %s not found\\n\",\n\t\t\troute->source);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (source_swidget->id == snd_soc_dapm_out_drv ||\n\t    source_swidget->id == snd_soc_dapm_output)\n\t\tgoto err;\n\n\t \n\tsink_swidget = snd_sof_find_swidget(scomp, (char *)route->sink);\n\tif (!sink_swidget) {\n\t\tdev_err(scomp->dev, \"error: sink %s not found\\n\",\n\t\t\troute->sink);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif (sink_swidget->id == snd_soc_dapm_out_drv ||\n\t    sink_swidget->id == snd_soc_dapm_output)\n\t\tgoto err;\n\n\tsroute->route = route;\n\tdobj->private = sroute;\n\tsroute->src_widget = source_swidget;\n\tsroute->sink_widget = sink_swidget;\n\n\t \n\tlist_add(&sroute->list, &sdev->route_list);\n\n\treturn 0;\nerr:\n\tkfree(sroute);\n\treturn ret;\n}\n\n \nstatic int sof_set_widget_pipeline(struct snd_sof_dev *sdev, struct snd_sof_pipeline *spipe,\n\t\t\t\t   struct snd_sof_widget *swidget)\n{\n\tstruct snd_sof_widget *pipe_widget = spipe->pipe_widget;\n\tstruct snd_sof_control *scontrol;\n\n\tif (pipe_widget->dynamic_pipeline_widget) {\n\t\t \n\t\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list)\n\t\t\tif (scontrol->comp_id == swidget->comp_id &&\n\t\t\t    (scontrol->access & SNDRV_CTL_ELEM_ACCESS_VOLATILE)) {\n\t\t\t\tdev_err(sdev->dev,\n\t\t\t\t\t\"error: volatile control found for dynamic widget %s\\n\",\n\t\t\t\t\tswidget->widget->name);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t}\n\n\t \n\tswidget->spipe = spipe;\n\tswidget->dynamic_pipeline_widget = pipe_widget->dynamic_pipeline_widget;\n\n\treturn 0;\n}\n\n \nstatic int sof_complete(struct snd_soc_component *scomp)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\tconst struct sof_ipc_tplg_widget_ops *widget_ops;\n\tstruct snd_sof_control *scontrol;\n\tstruct snd_sof_pipeline *spipe;\n\tint ret;\n\n\twidget_ops = tplg_ops ? tplg_ops->widget : NULL;\n\n\t \n\tif (tplg_ops && tplg_ops->control_setup)\n\t\tlist_for_each_entry(scontrol, &sdev->kcontrol_list, list) {\n\t\t\tret = tplg_ops->control_setup(sdev, scontrol);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"failed updating IPC struct for control %s\\n\",\n\t\t\t\t\tscontrol->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t \n\tlist_for_each_entry(spipe, &sdev->pipeline_list, list) {\n\t\tstruct snd_sof_widget *pipe_widget = spipe->pipe_widget;\n\t\tstruct snd_sof_widget *swidget;\n\n\t\tpipe_widget->instance_id = -EINVAL;\n\n\t\t \n\t\tif (widget_ops && widget_ops[pipe_widget->id].ipc_setup) {\n\t\t\tret = widget_ops[pipe_widget->id].ipc_setup(pipe_widget);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"failed updating IPC struct for %s\\n\",\n\t\t\t\t\tpipe_widget->widget->name);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry(swidget, &sdev->widget_list, list)\n\t\t\tif (swidget->widget->id != snd_soc_dapm_scheduler &&\n\t\t\t    swidget->pipeline_id == pipe_widget->pipeline_id) {\n\t\t\t\tret = sof_set_widget_pipeline(sdev, spipe, swidget);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tif (widget_ops && widget_ops[swidget->id].ipc_setup) {\n\t\t\t\t\tret = widget_ops[swidget->id].ipc_setup(swidget);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tdev_err(sdev->dev,\n\t\t\t\t\t\t\t\"failed updating IPC struct for %s\\n\",\n\t\t\t\t\t\t\tswidget->widget->name);\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\t \n\tif (sof_debug_check_flag(SOF_DBG_VERIFY_TPLG)) {\n\t\tif (tplg_ops && tplg_ops->set_up_all_pipelines &&\n\t\t    tplg_ops->tear_down_all_pipelines) {\n\t\t\tret = tplg_ops->set_up_all_pipelines(sdev, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"Failed to set up all topology pipelines: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = tplg_ops->tear_down_all_pipelines(sdev, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(sdev->dev, \"Failed to tear down topology pipelines: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (tplg_ops && tplg_ops->set_up_all_pipelines)\n\t\treturn tplg_ops->set_up_all_pipelines(sdev, false);\n\n\treturn 0;\n}\n\n \nstatic int sof_manifest(struct snd_soc_component *scomp, int index,\n\t\t\tstruct snd_soc_tplg_manifest *man)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct sof_ipc_tplg_ops *tplg_ops = sof_ipc_get_ops(sdev, tplg);\n\n\tif (tplg_ops && tplg_ops->parse_manifest)\n\t\treturn tplg_ops->parse_manifest(scomp, index, man);\n\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_tplg_kcontrol_ops sof_io_ops[] = {\n\t{SOF_TPLG_KCTL_VOL_ID, snd_sof_volume_get, snd_sof_volume_put},\n\t{SOF_TPLG_KCTL_BYTES_ID, snd_sof_bytes_get, snd_sof_bytes_put},\n\t{SOF_TPLG_KCTL_ENUM_ID, snd_sof_enum_get, snd_sof_enum_put},\n\t{SOF_TPLG_KCTL_SWITCH_ID, snd_sof_switch_get, snd_sof_switch_put},\n};\n\n \nstatic const struct snd_soc_tplg_bytes_ext_ops sof_bytes_ext_ops[] = {\n\t{SOF_TPLG_KCTL_BYTES_ID, snd_sof_bytes_ext_get, snd_sof_bytes_ext_put},\n\t{SOF_TPLG_KCTL_BYTES_VOLATILE_RO, snd_sof_bytes_ext_volatile_get},\n};\n\nstatic struct snd_soc_tplg_ops sof_tplg_ops = {\n\t \n\t.control_load\t= sof_control_load,\n\t.control_unload\t= sof_control_unload,\n\n\t \n\t.dapm_route_load\t= sof_route_load,\n\t.dapm_route_unload\t= sof_route_unload,\n\n\t \n\t \n\t.widget_ready\t= sof_widget_ready,\n\t.widget_unload\t= sof_widget_unload,\n\n\t \n\t.dai_load\t= sof_dai_load,\n\t.dai_unload\t= sof_dai_unload,\n\n\t \n\t.link_load\t= sof_link_load,\n\t.link_unload\t= sof_link_unload,\n\n\t \n\t.complete\t= sof_complete,\n\n\t \n\t.manifest\t= sof_manifest,\n\n\t \n\t.io_ops\t\t= sof_io_ops,\n\t.io_ops_count\t= ARRAY_SIZE(sof_io_ops),\n\n\t \n\t.bytes_ext_ops\t= sof_bytes_ext_ops,\n\t.bytes_ext_ops_count\t= ARRAY_SIZE(sof_bytes_ext_ops),\n};\n\nstatic int snd_sof_dspless_kcontrol(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\treturn 0;\n}\n\nstatic const struct snd_soc_tplg_kcontrol_ops sof_dspless_io_ops[] = {\n\t{SOF_TPLG_KCTL_VOL_ID, snd_sof_dspless_kcontrol, snd_sof_dspless_kcontrol},\n\t{SOF_TPLG_KCTL_BYTES_ID, snd_sof_dspless_kcontrol, snd_sof_dspless_kcontrol},\n\t{SOF_TPLG_KCTL_ENUM_ID, snd_sof_dspless_kcontrol, snd_sof_dspless_kcontrol},\n\t{SOF_TPLG_KCTL_SWITCH_ID, snd_sof_dspless_kcontrol, snd_sof_dspless_kcontrol},\n};\n\nstatic int snd_sof_dspless_bytes_ext_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t unsigned int __user *binary_data,\n\t\t\t\t\t unsigned int size)\n{\n\treturn 0;\n}\n\nstatic int snd_sof_dspless_bytes_ext_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t const unsigned int __user *binary_data,\n\t\t\t\t\t unsigned int size)\n{\n\treturn 0;\n}\n\nstatic const struct snd_soc_tplg_bytes_ext_ops sof_dspless_bytes_ext_ops[] = {\n\t{SOF_TPLG_KCTL_BYTES_ID, snd_sof_dspless_bytes_ext_get, snd_sof_dspless_bytes_ext_put},\n\t{SOF_TPLG_KCTL_BYTES_VOLATILE_RO, snd_sof_dspless_bytes_ext_get},\n};\n\n \nstatic int sof_dspless_widget_ready(struct snd_soc_component *scomp, int index,\n\t\t\t\t    struct snd_soc_dapm_widget *w,\n\t\t\t\t    struct snd_soc_tplg_dapm_widget *tw)\n{\n\tif (WIDGET_IS_DAI(w->id)) {\n\t\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\t\tstruct snd_sof_widget *swidget;\n\t\tstruct snd_sof_dai dai;\n\t\tint ret;\n\n\t\tswidget = kzalloc(sizeof(*swidget), GFP_KERNEL);\n\t\tif (!swidget)\n\t\t\treturn -ENOMEM;\n\n\t\tmemset(&dai, 0, sizeof(dai));\n\n\t\tret = sof_connect_dai_widget(scomp, w, tw, &dai);\n\t\tif (ret) {\n\t\t\tkfree(swidget);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswidget->scomp = scomp;\n\t\tswidget->widget = w;\n\t\tmutex_init(&swidget->setup_mutex);\n\t\tw->dobj.private = swidget;\n\t\tlist_add(&swidget->list, &sdev->widget_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_dspless_widget_unload(struct snd_soc_component *scomp,\n\t\t\t\t     struct snd_soc_dobj *dobj)\n{\n\tstruct snd_soc_dapm_widget *w = container_of(dobj, struct snd_soc_dapm_widget, dobj);\n\n\tif (WIDGET_IS_DAI(w->id)) {\n\t\tstruct snd_sof_widget *swidget = dobj->private;\n\n\t\tsof_disconnect_dai_widget(scomp, w);\n\n\t\tif (!swidget)\n\t\t\treturn 0;\n\n\t\t \n\t\tlist_del(&swidget->list);\n\t\tkfree(swidget);\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_dspless_link_load(struct snd_soc_component *scomp, int index,\n\t\t\t\t struct snd_soc_dai_link *link,\n\t\t\t\t struct snd_soc_tplg_link_config *cfg)\n{\n\tlink->platforms->name = dev_name(scomp->dev);\n\n\t \n\tif (!link->no_pcm)\n\t\tlink->nonatomic = true;\n\n\treturn 0;\n}\n\nstatic struct snd_soc_tplg_ops sof_dspless_tplg_ops = {\n\t \n\t.widget_ready\t= sof_dspless_widget_ready,\n\t.widget_unload\t= sof_dspless_widget_unload,\n\n\t \n\t.dai_load\t= sof_dai_load,\n\t.dai_unload\t= sof_dai_unload,\n\n\t \n\t.link_load\t= sof_dspless_link_load,\n\n\t \n\t.io_ops\t\t= sof_dspless_io_ops,\n\t.io_ops_count\t= ARRAY_SIZE(sof_dspless_io_ops),\n\n\t \n\t.bytes_ext_ops = sof_dspless_bytes_ext_ops,\n\t.bytes_ext_ops_count = ARRAY_SIZE(sof_dspless_bytes_ext_ops),\n};\n\nint snd_sof_load_topology(struct snd_soc_component *scomp, const char *file)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);\n\tconst struct firmware *fw;\n\tint ret;\n\n\tdev_dbg(scomp->dev, \"loading topology:%s\\n\", file);\n\n\tret = request_firmware(&fw, file, scomp->dev);\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"error: tplg request firmware %s failed err: %d\\n\",\n\t\t\tfile, ret);\n\t\tdev_err(scomp->dev,\n\t\t\t\"you may need to download the firmware from https://github.com/thesofproject/sof-bin/\\n\");\n\t\treturn ret;\n\t}\n\n\tif (sdev->dspless_mode_selected)\n\t\tret = snd_soc_tplg_component_load(scomp, &sof_dspless_tplg_ops, fw);\n\telse\n\t\tret = snd_soc_tplg_component_load(scomp, &sof_tplg_ops, fw);\n\n\tif (ret < 0) {\n\t\tdev_err(scomp->dev, \"error: tplg component load failed %d\\n\",\n\t\t\tret);\n\t\tret = -EINVAL;\n\t}\n\n\trelease_firmware(fw);\n\n\tif (ret >= 0 && sdev->led_present)\n\t\tret = snd_ctl_led_request();\n\n\treturn ret;\n}\nEXPORT_SYMBOL(snd_sof_load_topology);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}