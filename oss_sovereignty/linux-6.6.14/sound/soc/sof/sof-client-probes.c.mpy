{
  "module_name": "sof-client-probes.c",
  "hash_id": "22f5d7f33a41610586eb238f49c8067c64d89001eeca91115f0b252ec7eafe8f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-client-probes.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/string_helpers.h>\n#include <linux/stddef.h>\n\n#include <sound/soc.h>\n#include <sound/sof/header.h>\n#include \"sof-client.h\"\n#include \"sof-client-probes.h\"\n\n#define SOF_PROBES_SUSPEND_DELAY_MS 3000\n \n#define SOF_PROBES_NUM_DAI_LINKS 1\n\n#define SOF_PROBES_INVALID_NODE_ID UINT_MAX\n\nstatic bool __read_mostly sof_probes_enabled;\nmodule_param_named(enable, sof_probes_enabled, bool, 0444);\nMODULE_PARM_DESC(enable, \"Enable SOF probes support\");\n\nstatic int sof_probes_compr_startup(struct snd_compr_stream *cstream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(dai->component);\n\tstruct sof_client_dev *cdev = snd_soc_card_get_drvdata(card);\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_host_ops *ops = priv->host_ops;\n\tint ret;\n\n\tif (sof_client_get_fw_state(cdev) == SOF_FW_CRASHED)\n\t\treturn -ENODEV;\n\n\tret = sof_client_core_module_get(cdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ops->startup(cdev, cstream, dai, &priv->extractor_stream_tag);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Failed to startup probe stream: %d\\n\", ret);\n\t\tpriv->extractor_stream_tag = SOF_PROBES_INVALID_NODE_ID;\n\t\tsof_client_core_module_put(cdev);\n\t}\n\n\treturn ret;\n}\n\nstatic int sof_probes_compr_shutdown(struct snd_compr_stream *cstream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(dai->component);\n\tstruct sof_client_dev *cdev = snd_soc_card_get_drvdata(card);\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_host_ops *ops = priv->host_ops;\n\tconst struct sof_probes_ipc_ops *ipc = priv->ipc_ops;\n\tstruct sof_probe_point_desc *desc;\n\tsize_t num_desc;\n\tint i, ret;\n\n\t \n\tret = ipc->points_info(cdev, &desc, &num_desc);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Failed to get probe points: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tfor (i = 0; i < num_desc; i++)\n\t\tipc->points_remove(cdev, &desc[i].buffer_id, 1);\n\tkfree(desc);\n\nexit:\n\tret = ipc->deinit(cdev);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"Failed to deinit probe: %d\\n\", ret);\n\n\tpriv->extractor_stream_tag = SOF_PROBES_INVALID_NODE_ID;\n\tsnd_compr_free_pages(cstream);\n\n\tret = ops->shutdown(cdev, cstream, dai);\n\n\tsof_client_core_module_put(cdev);\n\n\treturn ret;\n}\n\nstatic int sof_probes_compr_set_params(struct snd_compr_stream *cstream,\n\t\t\t\t       struct snd_compr_params *params,\n\t\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(dai->component);\n\tstruct sof_client_dev *cdev = snd_soc_card_get_drvdata(card);\n\tstruct snd_compr_runtime *rtd = cstream->runtime;\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_host_ops *ops = priv->host_ops;\n\tconst struct sof_probes_ipc_ops *ipc = priv->ipc_ops;\n\tint ret;\n\n\tcstream->dma_buffer.dev.type = SNDRV_DMA_TYPE_DEV_SG;\n\tcstream->dma_buffer.dev.dev = sof_client_get_dma_dev(cdev);\n\tret = snd_compr_malloc_pages(cstream, rtd->buffer_size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ops->set_params(cdev, cstream, params, dai);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ipc->init(cdev, priv->extractor_stream_tag, rtd->dma_bytes);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Failed to init probe: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_probes_compr_trigger(struct snd_compr_stream *cstream, int cmd,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(dai->component);\n\tstruct sof_client_dev *cdev = snd_soc_card_get_drvdata(card);\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_host_ops *ops = priv->host_ops;\n\n\treturn ops->trigger(cdev, cstream, cmd, dai);\n}\n\nstatic int sof_probes_compr_pointer(struct snd_compr_stream *cstream,\n\t\t\t\t    struct snd_compr_tstamp *tstamp,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_card *card = snd_soc_component_get_drvdata(dai->component);\n\tstruct sof_client_dev *cdev = snd_soc_card_get_drvdata(card);\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_host_ops *ops = priv->host_ops;\n\n\treturn ops->pointer(cdev, cstream, tstamp, dai);\n}\n\nstatic const struct snd_soc_cdai_ops sof_probes_compr_ops = {\n\t.startup = sof_probes_compr_startup,\n\t.shutdown = sof_probes_compr_shutdown,\n\t.set_params = sof_probes_compr_set_params,\n\t.trigger = sof_probes_compr_trigger,\n\t.pointer = sof_probes_compr_pointer,\n};\n\nstatic int sof_probes_compr_copy(struct snd_soc_component *component,\n\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t char __user *buf, size_t count)\n{\n\tstruct snd_compr_runtime *rtd = cstream->runtime;\n\tunsigned int offset, n;\n\tvoid *ptr;\n\tint ret;\n\n\tif (count > rtd->buffer_size)\n\t\tcount = rtd->buffer_size;\n\n\tdiv_u64_rem(rtd->total_bytes_transferred, rtd->buffer_size, &offset);\n\tptr = rtd->dma_area + offset;\n\tn = rtd->buffer_size - offset;\n\n\tif (count < n) {\n\t\tret = copy_to_user(buf, ptr, count);\n\t} else {\n\t\tret = copy_to_user(buf, ptr, n);\n\t\tret += copy_to_user(buf + n, rtd->dma_area, count - n);\n\t}\n\n\tif (ret)\n\t\treturn count - ret;\n\treturn count;\n}\n\nstatic const struct snd_compress_ops sof_probes_compressed_ops = {\n\t.copy = sof_probes_compr_copy,\n};\n\nstatic ssize_t sof_probes_dfs_points_read(struct file *file, char __user *to,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_probes_priv *priv = cdev->data;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tstruct sof_probe_point_desc *desc;\n\tconst struct sof_probes_ipc_ops *ipc = priv->ipc_ops;\n\tint remaining, offset;\n\tsize_t num_desc;\n\tchar *buf;\n\tint i, ret, err;\n\n\tif (priv->extractor_stream_tag == SOF_PROBES_INVALID_NODE_ID) {\n\t\tdev_warn(dev, \"no extractor stream running\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(dev, \"debugfs read failed to resume %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ipc->points_info(cdev, &desc, &num_desc);\n\tif (ret < 0)\n\t\tgoto pm_error;\n\n\tfor (i = 0; i < num_desc; i++) {\n\t\toffset = strlen(buf);\n\t\tremaining = PAGE_SIZE - offset;\n\t\tret = snprintf(buf + offset, remaining,\n\t\t\t       \"Id: %#010x  Purpose: %u  Node id: %#x\\n\",\n\t\t\t\tdesc[i].buffer_id, desc[i].purpose, desc[i].stream_tag);\n\t\tif (ret < 0 || ret >= remaining) {\n\t\t\t \n\t\t\tbuf[offset] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = simple_read_from_buffer(to, count, ppos, buf, strlen(buf));\n\n\tkfree(desc);\n\npm_error:\n\tpm_runtime_mark_last_busy(dev);\n\terr = pm_runtime_put_autosuspend(dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(dev, \"debugfs read failed to idle %d\\n\", err);\n\nexit:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t\nsof_probes_dfs_points_write(struct file *file, const char __user *from,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_ipc_ops *ipc = priv->ipc_ops;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tstruct sof_probe_point_desc *desc;\n\tu32 num_elems, *array;\n\tsize_t bytes;\n\tint ret, err;\n\n\tif (priv->extractor_stream_tag == SOF_PROBES_INVALID_NODE_ID) {\n\t\tdev_warn(dev, \"no extractor stream running\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = parse_int_array_user(from, count, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_elems = *array;\n\tbytes = sizeof(*array) * num_elems;\n\tif (bytes % sizeof(*desc)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tdesc = (struct sof_probe_point_desc *)&array[1];\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to resume %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ipc->points_add(cdev, desc, bytes / sizeof(*desc));\n\tif (!ret)\n\t\tret = count;\n\n\tpm_runtime_mark_last_busy(dev);\n\terr = pm_runtime_put_autosuspend(dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to idle %d\\n\", err);\nexit:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic const struct file_operations sof_probes_points_fops = {\n\t.open = simple_open,\n\t.read = sof_probes_dfs_points_read,\n\t.write = sof_probes_dfs_points_write,\n\t.llseek = default_llseek,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t\nsof_probes_dfs_points_remove_write(struct file *file, const char __user *from,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_probes_priv *priv = cdev->data;\n\tconst struct sof_probes_ipc_ops *ipc = priv->ipc_ops;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tint ret, err;\n\tu32 *array;\n\n\tif (priv->extractor_stream_tag == SOF_PROBES_INVALID_NODE_ID) {\n\t\tdev_warn(dev, \"no extractor stream running\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = parse_int_array_user(from, count, (int **)&array);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to resume %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ipc->points_remove(cdev, &array[1], array[0]);\n\tif (!ret)\n\t\tret = count;\n\n\tpm_runtime_mark_last_busy(dev);\n\terr = pm_runtime_put_autosuspend(dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to idle %d\\n\", err);\nexit:\n\tkfree(array);\n\treturn ret;\n}\n\nstatic const struct file_operations sof_probes_points_remove_fops = {\n\t.open = simple_open,\n\t.write = sof_probes_dfs_points_remove_write,\n\t.llseek = default_llseek,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct snd_soc_dai_ops sof_probes_dai_ops = {\n\t.compress_new = snd_soc_new_compress,\n};\n\nstatic struct snd_soc_dai_driver sof_probes_dai_drv[] = {\n{\n\t.name = \"Probe Extraction CPU DAI\",\n\t.ops  = &sof_probes_dai_ops,\n\t.cops = &sof_probes_compr_ops,\n\t.capture = {\n\t\t.stream_name = \"Probe Extraction\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.rate_min = 48000,\n\t\t.rate_max = 48000,\n\t},\n},\n};\n\nstatic const struct snd_soc_component_driver sof_probes_component = {\n\t.name = \"sof-probes-component\",\n\t.compress_ops = &sof_probes_compressed_ops,\n\t.module_get_upon_open = 1,\n\t.legacy_dai_naming = 1,\n};\n\nSND_SOC_DAILINK_DEF(dummy, DAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nstatic int sof_probes_client_probe(struct auxiliary_device *auxdev,\n\t\t\t\t   const struct auxiliary_device_id *id)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct dentry *dfsroot = sof_client_get_debugfs_root(cdev);\n\tstruct device *dev = &auxdev->dev;\n\tstruct snd_soc_dai_link_component platform_component[] = {\n\t\t{\n\t\t\t.name = dev_name(dev),\n\t\t}\n\t};\n\tstruct snd_soc_card *card;\n\tstruct sof_probes_priv *priv;\n\tstruct snd_soc_dai_link_component *cpus;\n\tstruct sof_probes_host_ops *ops;\n\tstruct snd_soc_dai_link *links;\n\tint ret;\n\n\t \n\tif (!sof_probes_enabled)\n\t\treturn -ENXIO;\n\n\tops = dev_get_platdata(dev);\n\tif (!ops) {\n\t\tdev_err(dev, \"missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (!ops->startup || !ops->shutdown || !ops->set_params || !ops->trigger ||\n\t    !ops->pointer) {\n\t\tdev_err(dev, \"missing platform callback(s)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->host_ops = ops;\n\n\tswitch (sof_client_get_ipc_type(cdev)) {\n#ifdef CONFIG_SND_SOC_SOF_INTEL_IPC4\n\tcase SOF_INTEL_IPC4:\n\t\tpriv->ipc_ops = &ipc4_probe_ops;\n\t\tbreak;\n#endif\n#ifdef CONFIG_SND_SOC_SOF_IPC3\n\tcase SOF_IPC:\n\t\tpriv->ipc_ops = &ipc3_probe_ops;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_err(dev, \"Matching IPC ops not found.\");\n\t\treturn -ENODEV;\n\t}\n\n\tcdev->data = priv;\n\n\t \n\tret = devm_snd_soc_register_component(dev, &sof_probes_component,\n\t\t\t\t\t      sof_probes_dai_drv,\n\t\t\t\t\t      ARRAY_SIZE(sof_probes_dai_drv));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register SOF probes DAI driver %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->extractor_stream_tag = SOF_PROBES_INVALID_NODE_ID;\n\n\t \n\tpriv->dfs_points = debugfs_create_file(\"probe_points\", 0644, dfsroot,\n\t\t\t\t\t       cdev, &sof_probes_points_fops);\n\n\t \n\tpriv->dfs_points_remove = debugfs_create_file(\"probe_points_remove\", 0644,\n\t\t\t\t\t\t      dfsroot, cdev,\n\t\t\t\t\t\t      &sof_probes_points_remove_fops);\n\n\tlinks = devm_kcalloc(dev, SOF_PROBES_NUM_DAI_LINKS, sizeof(*links), GFP_KERNEL);\n\tcpus = devm_kcalloc(dev, SOF_PROBES_NUM_DAI_LINKS, sizeof(*cpus), GFP_KERNEL);\n\tif (!links || !cpus) {\n\t\tdebugfs_remove(priv->dfs_points);\n\t\tdebugfs_remove(priv->dfs_points_remove);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tlinks[0].name = \"Compress Probe Capture\";\n\tlinks[0].id = 0;\n\tlinks[0].cpus = &cpus[0];\n\tlinks[0].num_cpus = 1;\n\tlinks[0].cpus->dai_name = \"Probe Extraction CPU DAI\";\n\tlinks[0].codecs = dummy;\n\tlinks[0].num_codecs = 1;\n\tlinks[0].platforms = platform_component;\n\tlinks[0].num_platforms = ARRAY_SIZE(platform_component);\n\tlinks[0].nonatomic = 1;\n\n\tcard = &priv->card;\n\n\tcard->dev = dev;\n\tcard->name = \"sof-probes\";\n\tcard->owner = THIS_MODULE;\n\tcard->num_links = SOF_PROBES_NUM_DAI_LINKS;\n\tcard->dai_link = links;\n\n\t \n\tcard->dapm.idle_bias_off = true;\n\n\tsnd_soc_card_set_drvdata(card, cdev);\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret < 0) {\n\t\tdebugfs_remove(priv->dfs_points);\n\t\tdebugfs_remove(priv->dfs_points_remove);\n\t\tdev_err(dev, \"Probes card register failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SOF_PROBES_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_idle(dev);\n\n\treturn 0;\n}\n\nstatic void sof_probes_client_remove(struct auxiliary_device *auxdev)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct sof_probes_priv *priv = cdev->data;\n\n\tif (!sof_probes_enabled)\n\t\treturn;\n\n\tpm_runtime_disable(&auxdev->dev);\n\tdebugfs_remove(priv->dfs_points);\n\tdebugfs_remove(priv->dfs_points_remove);\n}\n\nstatic const struct auxiliary_device_id sof_probes_client_id_table[] = {\n\t{ .name = \"snd_sof.hda-probes\", },\n\t{ .name = \"snd_sof.acp-probes\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, sof_probes_client_id_table);\n\n \nstatic struct auxiliary_driver sof_probes_client_drv = {\n\t.probe = sof_probes_client_probe,\n\t.remove = sof_probes_client_remove,\n\n\t.id_table = sof_probes_client_id_table,\n};\n\nmodule_auxiliary_driver(sof_probes_client_drv);\n\nMODULE_DESCRIPTION(\"SOF Probes Client Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(SND_SOC_SOF_CLIENT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}