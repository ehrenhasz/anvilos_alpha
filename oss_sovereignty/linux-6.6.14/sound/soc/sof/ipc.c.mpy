{
  "module_name": "ipc.c",
  "hash_id": "8496a04dbe7762f26526d7aa37388a66c8c354c8081e18111fa37a8c4b897aeb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#include \"sof-priv.h\"\n#include \"sof-audio.h\"\n#include \"ops.h\"\n\n \nint sof_ipc_send_msg(struct snd_sof_dev *sdev, void *msg_data, size_t msg_bytes,\n\t\t     size_t reply_bytes)\n{\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\tstruct snd_sof_ipc_msg *msg;\n\tint ret;\n\n\tif (ipc->disable_ipc_tx || sdev->fw_state != SOF_FW_BOOT_COMPLETE)\n\t\treturn -ENODEV;\n\n\t \n\tspin_lock_irq(&sdev->ipc_lock);\n\n\t \n\tmsg = &ipc->msg;\n\n\t \n\tmsg->msg_data = msg_data;\n\tmsg->msg_size = msg_bytes;\n\n\tmsg->reply_size = reply_bytes;\n\tmsg->reply_error = 0;\n\n\tsdev->msg = msg;\n\n\tret = snd_sof_dsp_send_msg(sdev, msg);\n\t \n\tif (!ret)\n\t\tmsg->ipc_complete = false;\n\n\tspin_unlock_irq(&sdev->ipc_lock);\n\n\treturn ret;\n}\n\n \nint sof_ipc_tx_message(struct snd_sof_ipc *ipc, void *msg_data, size_t msg_bytes,\n\t\t       void *reply_data, size_t reply_bytes)\n{\n\tif (msg_bytes > ipc->max_payload_size ||\n\t    reply_bytes > ipc->max_payload_size)\n\t\treturn -ENOBUFS;\n\n\treturn ipc->ops->tx_msg(ipc->sdev, msg_data, msg_bytes, reply_data,\n\t\t\t\treply_bytes, false);\n}\nEXPORT_SYMBOL(sof_ipc_tx_message);\n\n \nint sof_ipc_set_get_data(struct snd_sof_ipc *ipc, void *msg_data,\n\t\t\t size_t msg_bytes, bool set)\n{\n\treturn ipc->ops->set_get_data(ipc->sdev, msg_data, msg_bytes, set);\n}\nEXPORT_SYMBOL(sof_ipc_set_get_data);\n\n \nint sof_ipc_tx_message_no_pm(struct snd_sof_ipc *ipc, void *msg_data, size_t msg_bytes,\n\t\t\t     void *reply_data, size_t reply_bytes)\n{\n\tif (msg_bytes > ipc->max_payload_size ||\n\t    reply_bytes > ipc->max_payload_size)\n\t\treturn -ENOBUFS;\n\n\treturn ipc->ops->tx_msg(ipc->sdev, msg_data, msg_bytes, reply_data,\n\t\t\t\treply_bytes, true);\n}\nEXPORT_SYMBOL(sof_ipc_tx_message_no_pm);\n\n \nvoid snd_sof_ipc_get_reply(struct snd_sof_dev *sdev)\n{\n\t \n\tif (!sdev->msg) {\n\t\tdev_warn(sdev->dev, \"unexpected ipc interrupt raised!\\n\");\n\t\treturn;\n\t}\n\n\tsdev->msg->reply_error = sdev->ipc->ops->get_reply(sdev);\n}\nEXPORT_SYMBOL(snd_sof_ipc_get_reply);\n\n \nvoid snd_sof_ipc_reply(struct snd_sof_dev *sdev, u32 msg_id)\n{\n\tstruct snd_sof_ipc_msg *msg = &sdev->ipc->msg;\n\n\tif (msg->ipc_complete) {\n\t\tdev_dbg(sdev->dev,\n\t\t\t\"no reply expected, received 0x%x, will be ignored\",\n\t\t\tmsg_id);\n\t\treturn;\n\t}\n\n\t \n\tmsg->ipc_complete = true;\n\twake_up(&msg->waitq);\n}\nEXPORT_SYMBOL(snd_sof_ipc_reply);\n\nstruct snd_sof_ipc *snd_sof_ipc_init(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc;\n\tstruct snd_sof_ipc_msg *msg;\n\tconst struct sof_ipc_ops *ops;\n\n\tipc = devm_kzalloc(sdev->dev, sizeof(*ipc), GFP_KERNEL);\n\tif (!ipc)\n\t\treturn NULL;\n\n\tmutex_init(&ipc->tx_mutex);\n\tipc->sdev = sdev;\n\tmsg = &ipc->msg;\n\n\t \n\tmsg->ipc_complete = true;\n\n\tinit_waitqueue_head(&msg->waitq);\n\n\tswitch (sdev->pdata->ipc_type) {\n#if defined(CONFIG_SND_SOC_SOF_IPC3)\n\tcase SOF_IPC:\n\t\tops = &ipc3_ops;\n\t\tbreak;\n#endif\n#if defined(CONFIG_SND_SOC_SOF_INTEL_IPC4)\n\tcase SOF_INTEL_IPC4:\n\t\tops = &ipc4_ops;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_err(sdev->dev, \"Not supported IPC version: %d\\n\",\n\t\t\tsdev->pdata->ipc_type);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (!ops->tx_msg || !ops->rx_msg || !ops->set_get_data || !ops->get_reply) {\n\t\tdev_err(sdev->dev, \"Missing IPC message handling ops\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!ops->fw_loader || !ops->fw_loader->validate ||\n\t    !ops->fw_loader->parse_ext_manifest) {\n\t\tdev_err(sdev->dev, \"Missing IPC firmware loading ops\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!ops->pcm) {\n\t\tdev_err(sdev->dev, \"Missing IPC PCM ops\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (!ops->tplg || !ops->tplg->widget || !ops->tplg->control) {\n\t\tdev_err(sdev->dev, \"Missing IPC topology ops\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ops->fw_tracing && (!ops->fw_tracing->init || !ops->fw_tracing->suspend ||\n\t\t\t\t!ops->fw_tracing->resume)) {\n\t\tdev_err(sdev->dev, \"Missing firmware tracing ops\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (ops->init && ops->init(sdev))\n\t\treturn NULL;\n\n\tipc->ops = ops;\n\n\treturn ipc;\n}\nEXPORT_SYMBOL(snd_sof_ipc_init);\n\nvoid snd_sof_ipc_free(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc *ipc = sdev->ipc;\n\n\tif (!ipc)\n\t\treturn;\n\n\t \n\tmutex_lock(&ipc->tx_mutex);\n\tipc->disable_ipc_tx = true;\n\tmutex_unlock(&ipc->tx_mutex);\n\n\tif (ipc->ops->exit)\n\t\tipc->ops->exit(sdev);\n}\nEXPORT_SYMBOL(snd_sof_ipc_free);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}