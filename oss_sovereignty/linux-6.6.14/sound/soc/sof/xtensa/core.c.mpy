{
  "module_name": "core.c",
  "hash_id": "033a03fb112bb9427b250df43167a0cdc80bdff5970a74ce9a70a352538ed58b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/xtensa/core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <sound/sof.h>\n#include <sound/sof/xtensa.h>\n#include \"../sof-priv.h\"\n\nstruct xtensa_exception_cause {\n\tu32 id;\n\tconst char *msg;\n\tconst char *description;\n};\n\n \nstatic const struct xtensa_exception_cause xtensa_exception_causes[] = {\n\t{0, \"IllegalInstructionCause\", \"Illegal instruction\"},\n\t{1, \"SyscallCause\", \"SYSCALL instruction\"},\n\t{2, \"InstructionFetchErrorCause\",\n\t\"Processor internal physical address or data error during instruction fetch\"},\n\t{3, \"LoadStoreErrorCause\",\n\t\"Processor internal physical address or data error during load or store\"},\n\t{4, \"Level1InterruptCause\",\n\t\"Level-1 interrupt as indicated by set level-1 bits in the INTERRUPT register\"},\n\t{5, \"AllocaCause\",\n\t\"MOVSP instruction, if caller\u2019s registers are not in the register file\"},\n\t{6, \"IntegerDivideByZeroCause\",\n\t\"QUOS, QUOU, REMS, or REMU divisor operand is zero\"},\n\t{8, \"PrivilegedCause\",\n\t\"Attempt to execute a privileged operation when CRING ? 0\"},\n\t{9, \"LoadStoreAlignmentCause\", \"Load or store to an unaligned address\"},\n\t{12, \"InstrPIFDataErrorCause\",\n\t\"PIF data error during instruction fetch\"},\n\t{13, \"LoadStorePIFDataErrorCause\",\n\t\"Synchronous PIF data error during LoadStore access\"},\n\t{14, \"InstrPIFAddrErrorCause\",\n\t\"PIF address error during instruction fetch\"},\n\t{15, \"LoadStorePIFAddrErrorCause\",\n\t\"Synchronous PIF address error during LoadStore access\"},\n\t{16, \"InstTLBMissCause\", \"Error during Instruction TLB refill\"},\n\t{17, \"InstTLBMultiHitCause\",\n\t\"Multiple instruction TLB entries matched\"},\n\t{18, \"InstFetchPrivilegeCause\",\n\t\"An instruction fetch referenced a virtual address at a ring level less than CRING\"},\n\t{20, \"InstFetchProhibitedCause\",\n\t\"An instruction fetch referenced a page mapped with an attribute that does not permit instruction fetch\"},\n\t{24, \"LoadStoreTLBMissCause\",\n\t\"Error during TLB refill for a load or store\"},\n\t{25, \"LoadStoreTLBMultiHitCause\",\n\t\"Multiple TLB entries matched for a load or store\"},\n\t{26, \"LoadStorePrivilegeCause\",\n\t\"A load or store referenced a virtual address at a ring level less than CRING\"},\n\t{28, \"LoadProhibitedCause\",\n\t\"A load referenced a page mapped with an attribute that does not permit loads\"},\n\t{32, \"Coprocessor0Disabled\",\n\t\"Coprocessor 0 instruction when cp0 disabled\"},\n\t{33, \"Coprocessor1Disabled\",\n\t\"Coprocessor 1 instruction when cp1 disabled\"},\n\t{34, \"Coprocessor2Disabled\",\n\t\"Coprocessor 2 instruction when cp2 disabled\"},\n\t{35, \"Coprocessor3Disabled\",\n\t\"Coprocessor 3 instruction when cp3 disabled\"},\n\t{36, \"Coprocessor4Disabled\",\n\t\"Coprocessor 4 instruction when cp4 disabled\"},\n\t{37, \"Coprocessor5Disabled\",\n\t\"Coprocessor 5 instruction when cp5 disabled\"},\n\t{38, \"Coprocessor6Disabled\",\n\t\"Coprocessor 6 instruction when cp6 disabled\"},\n\t{39, \"Coprocessor7Disabled\",\n\t\"Coprocessor 7 instruction when cp7 disabled\"},\n};\n\n \nstatic void xtensa_dsp_oops(struct snd_sof_dev *sdev, const char *level, void *oops)\n{\n\tstruct sof_ipc_dsp_oops_xtensa *xoops = oops;\n\tint i;\n\n\tdev_printk(level, sdev->dev, \"error: DSP Firmware Oops\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(xtensa_exception_causes); i++) {\n\t\tif (xtensa_exception_causes[i].id == xoops->exccause) {\n\t\t\tdev_printk(level, sdev->dev,\n\t\t\t\t   \"error: Exception Cause: %s, %s\\n\",\n\t\t\t\t   xtensa_exception_causes[i].msg,\n\t\t\t\t   xtensa_exception_causes[i].description);\n\t\t}\n\t}\n\tdev_printk(level, sdev->dev,\n\t\t   \"EXCCAUSE 0x%8.8x EXCVADDR 0x%8.8x PS       0x%8.8x SAR     0x%8.8x\\n\",\n\t\t   xoops->exccause, xoops->excvaddr, xoops->ps, xoops->sar);\n\tdev_printk(level, sdev->dev,\n\t\t   \"EPC1     0x%8.8x EPC2     0x%8.8x EPC3     0x%8.8x EPC4    0x%8.8x\",\n\t\t   xoops->epc1, xoops->epc2, xoops->epc3, xoops->epc4);\n\tdev_printk(level, sdev->dev,\n\t\t   \"EPC5     0x%8.8x EPC6     0x%8.8x EPC7     0x%8.8x DEPC    0x%8.8x\",\n\t\t   xoops->epc5, xoops->epc6, xoops->epc7, xoops->depc);\n\tdev_printk(level, sdev->dev,\n\t\t   \"EPS2     0x%8.8x EPS3     0x%8.8x EPS4     0x%8.8x EPS5    0x%8.8x\",\n\t\t   xoops->eps2, xoops->eps3, xoops->eps4, xoops->eps5);\n\tdev_printk(level, sdev->dev,\n\t\t   \"EPS6     0x%8.8x EPS7     0x%8.8x INTENABL 0x%8.8x INTERRU 0x%8.8x\",\n\t\t   xoops->eps6, xoops->eps7, xoops->intenable, xoops->interrupt);\n}\n\nstatic void xtensa_stack(struct snd_sof_dev *sdev, const char *level, void *oops,\n\t\t\t u32 *stack, u32 stack_words)\n{\n\tstruct sof_ipc_dsp_oops_xtensa *xoops = oops;\n\tu32 stack_ptr = xoops->plat_hdr.stackptr;\n\t \n\tunsigned char buf[4 * 8 + 3 + 1];\n\tint i;\n\n\tdev_printk(level, sdev->dev, \"stack dump from 0x%8.8x\\n\", stack_ptr);\n\n\t \n\tfor (i = 0; i < stack_words; i += 4) {\n\t\thex_dump_to_buffer(stack + i, 16, 16, 4,\n\t\t\t\t   buf, sizeof(buf), false);\n\t\tdev_printk(level, sdev->dev, \"0x%08x: %s\\n\", stack_ptr + i * 4, buf);\n\t}\n}\n\nconst struct dsp_arch_ops sof_xtensa_arch_ops = {\n\t.dsp_oops = xtensa_dsp_oops,\n\t.dsp_stack = xtensa_stack,\n};\nEXPORT_SYMBOL_NS(sof_xtensa_arch_ops, SND_SOC_SOF_XTENSA);\n\nMODULE_DESCRIPTION(\"SOF Xtensa DSP support\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}