{
  "module_name": "sof-client-ipc-msg-injector.c",
  "hash_id": "010597c23a95bbb5d2c66e238467016aedf67ab14debd5c138eeb25aa8122130",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/sof-client-ipc-msg-injector.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/auxiliary_bus.h>\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/ktime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <sound/sof/header.h>\n#include <sound/sof/ipc4/header.h>\n\n#include \"sof-client.h\"\n\n#define SOF_IPC_CLIENT_SUSPEND_DELAY_MS\t3000\n\nstruct sof_msg_inject_priv {\n\tstruct dentry *dfs_file;\n\tsize_t max_msg_size;\n\tenum sof_ipc_type ipc_type;\n\n\tvoid *tx_buffer;\n\tvoid *rx_buffer;\n};\n\nstatic int sof_msg_inject_dfs_open(struct inode *inode, struct file *file)\n{\n\tstruct sof_client_dev *cdev = inode->i_private;\n\tint ret;\n\n\tif (sof_client_get_fw_state(cdev) == SOF_FW_CRASHED)\n\t\treturn -ENODEV;\n\n\tret = debugfs_file_get(file->f_path.dentry);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = simple_open(inode, file);\n\tif (ret)\n\t\tdebugfs_file_put(file->f_path.dentry);\n\n\treturn ret;\n}\n\nstatic ssize_t sof_msg_inject_dfs_read(struct file *file, char __user *buffer,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\tstruct sof_ipc_reply *rhdr = priv->rx_buffer;\n\n\tif (!rhdr->hdr.size || !count || *ppos)\n\t\treturn 0;\n\n\tif (count > rhdr->hdr.size)\n\t\tcount = rhdr->hdr.size;\n\n\tif (copy_to_user(buffer, priv->rx_buffer, count))\n\t\treturn -EFAULT;\n\n\t*ppos += count;\n\treturn count;\n}\n\nstatic ssize_t sof_msg_inject_ipc4_dfs_read(struct file *file,\n\t\t\t\t\t    char __user *buffer,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\tstruct sof_ipc4_msg *ipc4_msg = priv->rx_buffer;\n\tsize_t header_size = sizeof(ipc4_msg->header_u64);\n\tsize_t remaining;\n\n\tif (!ipc4_msg->header_u64 || !count || *ppos)\n\t\treturn 0;\n\n\t \n\tif (count < header_size)\n\t\treturn -ENOSPC;\n\n\tremaining = header_size;\n\n\t \n\tif (SOF_IPC4_MSG_IS_MODULE_MSG(ipc4_msg->primary) &&\n\t    (SOF_IPC4_MSG_TYPE_GET(ipc4_msg->primary) == SOF_IPC4_MOD_LARGE_CONFIG_GET))\n\t\tremaining += ipc4_msg->data_size;\n\n\tif (count > remaining)\n\t\tcount = remaining;\n\telse if (count < remaining)\n\t\tremaining = count;\n\n\t \n\tif (copy_to_user(buffer, &ipc4_msg->header_u64, header_size))\n\t\treturn -EFAULT;\n\n\t*ppos += header_size;\n\tremaining -= header_size;\n\n\tif (!remaining)\n\t\treturn count;\n\n\tif (remaining > ipc4_msg->data_size)\n\t\tremaining = ipc4_msg->data_size;\n\n\t \n\tif (copy_to_user(buffer + *ppos, ipc4_msg->data_ptr, remaining))\n\t\treturn -EFAULT;\n\n\t*ppos += remaining;\n\treturn count;\n}\n\nstatic int sof_msg_inject_send_message(struct sof_client_dev *cdev)\n{\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\tstruct device *dev = &cdev->auxdev.dev;\n\tint ret, err;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to resume %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sof_client_ipc_tx_message(cdev, priv->tx_buffer, priv->rx_buffer,\n\t\t\t\t\tpriv->max_msg_size);\n\tif (ret)\n\t\tdev_err(dev, \"IPC message send failed: %d\\n\", ret);\n\n\tpm_runtime_mark_last_busy(dev);\n\terr = pm_runtime_put_autosuspend(dev);\n\tif (err < 0)\n\t\tdev_err_ratelimited(dev, \"debugfs write failed to idle %d\\n\", err);\n\n\treturn ret;\n}\n\nstatic ssize_t sof_msg_inject_dfs_write(struct file *file, const char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\tssize_t size;\n\tint ret;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tsize = simple_write_to_buffer(priv->tx_buffer, priv->max_msg_size,\n\t\t\t\t      ppos, buffer, count);\n\tif (size < 0)\n\t\treturn size;\n\tif (size != count)\n\t\treturn -EFAULT;\n\n\tmemset(priv->rx_buffer, 0, priv->max_msg_size);\n\n\tret = sof_msg_inject_send_message(cdev);\n\n\t \n\tif (ret < 0)\n\t\tsize = ret;\n\n\treturn size;\n};\n\nstatic ssize_t sof_msg_inject_ipc4_dfs_write(struct file *file,\n\t\t\t\t\t     const char __user *buffer,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct sof_client_dev *cdev = file->private_data;\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\tstruct sof_ipc4_msg *ipc4_msg = priv->tx_buffer;\n\tsize_t data_size;\n\tint ret;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tif (count < sizeof(ipc4_msg->header_u64))\n\t\treturn -EINVAL;\n\n\t \n\tif (copy_from_user(&ipc4_msg->header_u64, buffer,\n\t\t\t   sizeof(ipc4_msg->header_u64)))\n\t\treturn -EFAULT;\n\n\tdata_size = count - sizeof(ipc4_msg->header_u64);\n\tif (data_size > priv->max_msg_size)\n\t\treturn -EINVAL;\n\n\t \n\tif (copy_from_user(ipc4_msg->data_ptr,\n\t\t\t   buffer + sizeof(ipc4_msg->header_u64), data_size))\n\t\treturn -EFAULT;\n\n\tipc4_msg->data_size = data_size;\n\n\t \n\tipc4_msg = priv->rx_buffer;\n\tipc4_msg->header_u64 = 0;\n\tipc4_msg->data_size = priv->max_msg_size;\n\tmemset(ipc4_msg->data_ptr, 0, priv->max_msg_size);\n\n\tret = sof_msg_inject_send_message(cdev);\n\n\t \n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n};\n\nstatic int sof_msg_inject_dfs_release(struct inode *inode, struct file *file)\n{\n\tdebugfs_file_put(file->f_path.dentry);\n\n\treturn 0;\n}\n\nstatic const struct file_operations sof_msg_inject_fops = {\n\t.open = sof_msg_inject_dfs_open,\n\t.read = sof_msg_inject_dfs_read,\n\t.write = sof_msg_inject_dfs_write,\n\t.llseek = default_llseek,\n\t.release = sof_msg_inject_dfs_release,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct file_operations sof_msg_inject_ipc4_fops = {\n\t.open = sof_msg_inject_dfs_open,\n\t.read = sof_msg_inject_ipc4_dfs_read,\n\t.write = sof_msg_inject_ipc4_dfs_write,\n\t.llseek = default_llseek,\n\t.release = sof_msg_inject_dfs_release,\n\n\t.owner = THIS_MODULE,\n};\n\nstatic int sof_msg_inject_probe(struct auxiliary_device *auxdev,\n\t\t\t\tconst struct auxiliary_device_id *id)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct dentry *debugfs_root = sof_client_get_debugfs_root(cdev);\n\tstatic const struct file_operations *fops;\n\tstruct device *dev = &auxdev->dev;\n\tstruct sof_msg_inject_priv *priv;\n\tsize_t alloc_size;\n\n\t \n\tpriv = devm_kzalloc(&auxdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->ipc_type = sof_client_get_ipc_type(cdev);\n\tpriv->max_msg_size = sof_client_get_ipc_max_payload_size(cdev);\n\talloc_size = priv->max_msg_size;\n\n\tif (priv->ipc_type == SOF_INTEL_IPC4)\n\t\talloc_size += sizeof(struct sof_ipc4_msg);\n\n\tpriv->tx_buffer = devm_kmalloc(dev, alloc_size, GFP_KERNEL);\n\tpriv->rx_buffer = devm_kzalloc(dev, alloc_size, GFP_KERNEL);\n\tif (!priv->tx_buffer || !priv->rx_buffer)\n\t\treturn -ENOMEM;\n\n\tif (priv->ipc_type == SOF_INTEL_IPC4) {\n\t\tstruct sof_ipc4_msg *ipc4_msg;\n\n\t\tipc4_msg = priv->tx_buffer;\n\t\tipc4_msg->data_ptr = priv->tx_buffer + sizeof(struct sof_ipc4_msg);\n\n\t\tipc4_msg = priv->rx_buffer;\n\t\tipc4_msg->data_ptr = priv->rx_buffer + sizeof(struct sof_ipc4_msg);\n\n\t\tfops = &sof_msg_inject_ipc4_fops;\n\t} else {\n\t\tfops = &sof_msg_inject_fops;\n\t}\n\n\tcdev->data = priv;\n\n\tpriv->dfs_file = debugfs_create_file(\"ipc_msg_inject\", 0644, debugfs_root,\n\t\t\t\t\t     cdev, fops);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SOF_IPC_CLIENT_SUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_idle(dev);\n\n\treturn 0;\n}\n\nstatic void sof_msg_inject_remove(struct auxiliary_device *auxdev)\n{\n\tstruct sof_client_dev *cdev = auxiliary_dev_to_sof_client_dev(auxdev);\n\tstruct sof_msg_inject_priv *priv = cdev->data;\n\n\tpm_runtime_disable(&auxdev->dev);\n\n\tdebugfs_remove(priv->dfs_file);\n}\n\nstatic const struct auxiliary_device_id sof_msg_inject_client_id_table[] = {\n\t{ .name = \"snd_sof.msg_injector\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, sof_msg_inject_client_id_table);\n\n \nstatic struct auxiliary_driver sof_msg_inject_client_drv = {\n\t.probe = sof_msg_inject_probe,\n\t.remove = sof_msg_inject_remove,\n\n\t.id_table = sof_msg_inject_client_id_table,\n};\n\nmodule_auxiliary_driver(sof_msg_inject_client_drv);\n\nMODULE_DESCRIPTION(\"SOF IPC Message Injector Client Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_SOF_CLIENT);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}