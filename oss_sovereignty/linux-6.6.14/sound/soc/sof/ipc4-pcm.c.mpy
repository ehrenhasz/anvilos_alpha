{
  "module_name": "ipc4-pcm.c",
  "hash_id": "05370d0f80bf764c68e8b136616a79d01e4c37315086ab9ed03ae0b62b071d5a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/ipc4-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/pcm_params.h>\n#include <sound/sof/ipc4/header.h>\n#include \"sof-audio.h\"\n#include \"sof-priv.h\"\n#include \"ops.h\"\n#include \"ipc4-priv.h\"\n#include \"ipc4-topology.h\"\n#include \"ipc4-fw-reg.h\"\n\nstatic int sof_ipc4_set_multi_pipeline_state(struct snd_sof_dev *sdev, u32 state,\n\t\t\t\t\t     struct ipc4_pipeline_set_state_data *trigger_list)\n{\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\tu32 primary, ipc_size;\n\n\t \n\tif (trigger_list->count == 1)\n\t\treturn sof_ipc4_set_pipeline_state(sdev, trigger_list->pipeline_instance_ids[0],\n\t\t\t\t\t\t   state);\n\n\tprimary = state;\n\tprimary |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_SET_PIPELINE_STATE);\n\tprimary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tprimary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\tmsg.primary = primary;\n\n\t \n\tmsg.extension = SOF_IPC4_GLB_PIPE_STATE_EXT_MULTI;\n\n\t \n\tipc_size = sizeof(u32) * (trigger_list->count + 1);\n\tmsg.data_size = ipc_size;\n\tmsg.data_ptr = trigger_list;\n\n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &msg, ipc_size);\n}\n\nint sof_ipc4_set_pipeline_state(struct snd_sof_dev *sdev, u32 instance_id, u32 state)\n{\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\tu32 primary;\n\n\tdev_dbg(sdev->dev, \"ipc4 set pipeline instance %d state %d\", instance_id, state);\n\n\tprimary = state;\n\tprimary |= SOF_IPC4_GLB_PIPE_STATE_ID(instance_id);\n\tprimary |= SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_SET_PIPELINE_STATE);\n\tprimary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tprimary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\n\tmsg.primary = primary;\n\n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n}\nEXPORT_SYMBOL(sof_ipc4_set_pipeline_state);\n\nstatic void\nsof_ipc4_add_pipeline_to_trigger_list(struct snd_sof_dev *sdev, int state,\n\t\t\t\t      struct snd_sof_pipeline *spipe,\n\t\t\t\t      struct ipc4_pipeline_set_state_data *trigger_list)\n{\n\tstruct snd_sof_widget *pipe_widget = spipe->pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\n\tif (pipeline->skip_during_fe_trigger && state != SOF_IPC4_PIPE_RESET)\n\t\treturn;\n\n\tswitch (state) {\n\tcase SOF_IPC4_PIPE_RUNNING:\n\t\t \n\t\tif (spipe->started_count == spipe->paused_count)\n\t\t\ttrigger_list->pipeline_instance_ids[trigger_list->count++] =\n\t\t\t\tpipe_widget->instance_id;\n\t\tbreak;\n\tcase SOF_IPC4_PIPE_RESET:\n\t\t \n\t\tif (!spipe->started_count && !spipe->paused_count)\n\t\t\ttrigger_list->pipeline_instance_ids[trigger_list->count++] =\n\t\t\t\tpipe_widget->instance_id;\n\t\tbreak;\n\tcase SOF_IPC4_PIPE_PAUSED:\n\t\t \n\t\tif (spipe->paused_count == (spipe->started_count - 1))\n\t\t\ttrigger_list->pipeline_instance_ids[trigger_list->count++] =\n\t\t\t\tpipe_widget->instance_id;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void\nsof_ipc4_update_pipeline_state(struct snd_sof_dev *sdev, int state, int cmd,\n\t\t\t       struct snd_sof_pipeline *spipe,\n\t\t\t       struct ipc4_pipeline_set_state_data *trigger_list)\n{\n\tstruct snd_sof_widget *pipe_widget = spipe->pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\tint i;\n\n\tif (pipeline->skip_during_fe_trigger && state != SOF_IPC4_PIPE_RESET)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < trigger_list->count; i++) {\n\t\tif (trigger_list->pipeline_instance_ids[i] == pipe_widget->instance_id) {\n\t\t\tpipeline->state = state;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (state) {\n\tcase SOF_IPC4_PIPE_PAUSED:\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t\t \n\t\t\tspipe->paused_count++;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\t\t \n\t\t\tspipe->started_count--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOF_IPC4_PIPE_RUNNING:\n\t\tswitch (cmd) {\n\t\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\t \n\t\t\tspipe->paused_count--;\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_TRIGGER_START:\n\t\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t\t \n\t\t\tspipe->started_count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \n\n \n\nstatic int sof_ipc4_chain_dma_trigger(struct snd_sof_dev *sdev,\n\t\t\t\t      struct snd_sof_pcm_stream_pipeline_list *pipeline_list,\n\t\t\t\t      int state, int cmd)\n{\n\tbool allocate, enable, set_fifo_size;\n\tstruct sof_ipc4_msg msg = {{ 0 }};\n\tint i;\n\n\tswitch (state) {\n\tcase SOF_IPC4_PIPE_RUNNING:  \n\t\tallocate = true;\n\t\tenable = true;\n\t\t \n\t\tif (cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE)\n\t\t\tset_fifo_size = false;\n\t\telse\n\t\t\tset_fifo_size = true;\n\t\tbreak;\n\tcase SOF_IPC4_PIPE_PAUSED:  \n\t\tallocate = true;\n\t\tenable = false;\n\t\tset_fifo_size = false;\n\t\tbreak;\n\tcase SOF_IPC4_PIPE_RESET:  \n\t\tallocate = false;\n\t\tenable = false;\n\t\tset_fifo_size = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"Unexpected state %d\", state);\n\t\treturn -EINVAL;\n\t}\n\n\tmsg.primary = SOF_IPC4_MSG_TYPE_SET(SOF_IPC4_GLB_CHAIN_DMA);\n\tmsg.primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);\n\tmsg.primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_FW_GEN_MSG);\n\n\t \n\tfor (i = 0; i < pipeline_list->count; i++) {\n\t\tstruct snd_sof_pipeline *spipe = pipeline_list->pipelines[i];\n\t\tstruct snd_sof_widget *pipe_widget = spipe->pipe_widget;\n\t\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\n\t\tif (!pipeline->use_chain_dma) {\n\t\t\tdev_err(sdev->dev,\n\t\t\t\t\"All pipelines in chained DMA stream should have use_chain_dma attribute set.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmsg.primary |= pipeline->msg.primary;\n\n\t\t \n\t\tif (set_fifo_size)\n\t\t\tmsg.extension |= pipeline->msg.extension;\n\t}\n\n\tif (allocate)\n\t\tmsg.primary |= SOF_IPC4_GLB_CHAIN_DMA_ALLOCATE_MASK;\n\n\tif (enable)\n\t\tmsg.primary |= SOF_IPC4_GLB_CHAIN_DMA_ENABLE_MASK;\n\n\treturn sof_ipc_tx_message_no_reply(sdev->ipc, &msg, 0);\n}\n\nstatic int sof_ipc4_trigger_pipelines(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream, int state, int cmd)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_sof_pcm_stream_pipeline_list *pipeline_list;\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct ipc4_pipeline_set_state_data *trigger_list;\n\tstruct snd_sof_widget *pipe_widget;\n\tstruct sof_ipc4_pipeline *pipeline;\n\tstruct snd_sof_pipeline *spipe;\n\tstruct snd_sof_pcm *spcm;\n\tint ret;\n\tint i;\n\n\tdev_dbg(sdev->dev, \"trigger cmd: %d state: %d\\n\", cmd, state);\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\tpipeline_list = &spcm->stream[substream->stream].pipeline_list;\n\n\t \n\tif (!pipeline_list->pipelines || !pipeline_list->count)\n\t\treturn 0;\n\n\tspipe = pipeline_list->pipelines[0];\n\tpipe_widget = spipe->pipe_widget;\n\tpipeline = pipe_widget->private;\n\n\t \n\tif (pipeline->use_chain_dma)\n\t\treturn sof_ipc4_chain_dma_trigger(sdev, pipeline_list, state, cmd);\n\n\t \n\ttrigger_list = kzalloc(struct_size(trigger_list, pipeline_instance_ids,\n\t\t\t\t\t   pipeline_list->count), GFP_KERNEL);\n\tif (!trigger_list)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ipc4_data->pipeline_state_mutex);\n\n\t \n\tif (state == SOF_IPC4_PIPE_RUNNING || state == SOF_IPC4_PIPE_RESET)\n\t\tfor (i = pipeline_list->count - 1; i >= 0; i--) {\n\t\t\tspipe = pipeline_list->pipelines[i];\n\t\t\tsof_ipc4_add_pipeline_to_trigger_list(sdev, state, spipe, trigger_list);\n\t\t}\n\telse\n\t\tfor (i = 0; i < pipeline_list->count; i++) {\n\t\t\tspipe = pipeline_list->pipelines[i];\n\t\t\tsof_ipc4_add_pipeline_to_trigger_list(sdev, state, spipe, trigger_list);\n\t\t}\n\n\t \n\tif (!trigger_list->count) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\t \n\tif (state == SOF_IPC4_PIPE_RESET || cmd == SNDRV_PCM_TRIGGER_PAUSE_RELEASE)\n\t\tgoto skip_pause_transition;\n\n\t \n\tret = sof_ipc4_set_multi_pipeline_state(sdev, SOF_IPC4_PIPE_PAUSED, trigger_list);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to pause all pipelines\\n\");\n\t\tgoto free;\n\t}\n\n\t \n\tfor (i = 0; i < pipeline_list->count ; i++) {\n\t\tspipe = pipeline_list->pipelines[i];\n\t\tsof_ipc4_update_pipeline_state(sdev, SOF_IPC4_PIPE_PAUSED, cmd, spipe,\n\t\t\t\t\t       trigger_list);\n\t}\n\n\t \n\tif (state == SOF_IPC4_PIPE_PAUSED)\n\t\tgoto free;\nskip_pause_transition:\n\t \n\tret = sof_ipc4_set_multi_pipeline_state(sdev, state, trigger_list);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to set final state %d for all pipelines\\n\", state);\n\t\tgoto free;\n\t}\n\n\t \n\tfor (i = 0; i < pipeline_list->count; i++) {\n\t\tspipe = pipeline_list->pipelines[i];\n\t\tsof_ipc4_update_pipeline_state(sdev, state, cmd, spipe, trigger_list);\n\t}\n\nfree:\n\tmutex_unlock(&ipc4_data->pipeline_state_mutex);\n\tkfree(trigger_list);\n\treturn ret;\n}\n\nstatic int sof_ipc4_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tint state;\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tstate = SOF_IPC4_PIPE_PAUSED;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tstate = SOF_IPC4_PIPE_RUNNING;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstate = SOF_IPC4_PIPE_PAUSED;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: unhandled trigger cmd %d\\n\", __func__, cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn sof_ipc4_trigger_pipelines(component, substream, state, cmd);\n}\n\nstatic int sof_ipc4_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\t \n\treturn sof_ipc4_trigger_pipelines(component, substream, SOF_IPC4_PIPE_RESET, 0);\n}\n\nstatic void ipc4_ssp_dai_config_pcm_params_match(struct snd_sof_dev *sdev, const char *link_name,\n\t\t\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_sof_dai_link *slink;\n\tstruct snd_sof_dai *dai;\n\tbool dai_link_found = false;\n\tint i;\n\n\tlist_for_each_entry(slink, &sdev->dai_link_list, list) {\n\t\tif (!strcmp(slink->link->name, link_name)) {\n\t\t\tdai_link_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dai_link_found)\n\t\treturn;\n\n\tfor (i = 0; i < slink->num_hw_configs; i++) {\n\t\tstruct snd_soc_tplg_hw_config *hw_config = &slink->hw_configs[i];\n\n\t\tif (params_rate(params) == le32_to_cpu(hw_config->fsync_rate)) {\n\t\t\t \n\t\t\tlist_for_each_entry(dai, &sdev->dai_list, list)\n\t\t\t\tif (!strcmp(slink->link->name, dai->name))\n\t\t\t\t\tdai->current_config = le32_to_cpu(hw_config->id);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic int sof_ipc4_pcm_dai_link_fixup_rate(struct snd_sof_dev *sdev,\n\t\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t\t    struct sof_ipc4_copier *ipc4_copier)\n{\n\tstruct sof_ipc4_pin_format *pin_fmts = ipc4_copier->available_fmt.input_pin_fmts;\n\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tint num_input_formats = ipc4_copier->available_fmt.num_input_formats;\n\tunsigned int fe_rate = params_rate(params);\n\tbool fe_be_rate_match = false;\n\tbool single_be_rate = true;\n\tunsigned int be_rate;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_input_formats; i++) {\n\t\tunsigned int val = pin_fmts[i].audio_fmt.sampling_frequency;\n\n\t\tif (i == 0)\n\t\t\tbe_rate = val;\n\t\telse if (val != be_rate)\n\t\t\tsingle_be_rate = false;\n\n\t\tif (val == fe_rate) {\n\t\t\tfe_be_rate_match = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!fe_be_rate_match) {\n\t\tif (!single_be_rate) {\n\t\t\tdev_err(sdev->dev, \"Unable to select sampling rate for DAI link\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trate->min = be_rate;\n\t\trate->max = rate->min;\n\t}\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_pcm_dai_link_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t       struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_component *component = snd_soc_rtdcom_lookup(rtd, SOF_AUDIO_PCM_DRV_NAME);\n\tstruct snd_sof_dai *dai = snd_sof_find_dai(component, rtd->dai_link->name);\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct sof_ipc4_copier *ipc4_copier;\n\tbool use_chain_dma = false;\n\tint dir;\n\n\tif (!dai) {\n\t\tdev_err(component->dev, \"%s: No DAI found with name %s\\n\", __func__,\n\t\t\trtd->dai_link->name);\n\t\treturn -EINVAL;\n\t}\n\n\tipc4_copier = dai->private;\n\tif (!ipc4_copier) {\n\t\tdev_err(component->dev, \"%s: No private data found for DAI %s\\n\",\n\t\t\t__func__, rtd->dai_link->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_pcm_streams(dir) {\n\t\tstruct snd_soc_dapm_widget *w = snd_soc_dai_get_widget(cpu_dai, dir);\n\n\t\tif (w) {\n\t\t\tstruct snd_sof_widget *swidget = w->dobj.private;\n\t\t\tstruct snd_sof_widget *pipe_widget = swidget->spipe->pipe_widget;\n\t\t\tstruct sof_ipc4_pipeline *pipeline = pipe_widget->private;\n\n\t\t\tif (pipeline->use_chain_dma)\n\t\t\t\tuse_chain_dma = true;\n\t\t}\n\t}\n\n\t \n\tif (!use_chain_dma) {\n\t\tint ret = sof_ipc4_pcm_dai_link_fixup_rate(sdev, params, ipc4_copier);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (ipc4_copier->dai_type) {\n\tcase SOF_DAI_INTEL_SSP:\n\t\tipc4_ssp_dai_config_pcm_params_match(sdev, (char *)rtd->dai_link->name, params);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void sof_ipc4_pcm_free(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm)\n{\n\tstruct snd_sof_pcm_stream_pipeline_list *pipeline_list;\n\tint stream;\n\n\tfor_each_pcm_streams(stream) {\n\t\tpipeline_list = &spcm->stream[stream].pipeline_list;\n\t\tkfree(pipeline_list->pipelines);\n\t\tpipeline_list->pipelines = NULL;\n\t\tkfree(spcm->stream[stream].private);\n\t\tspcm->stream[stream].private = NULL;\n\t}\n}\n\nstatic int sof_ipc4_pcm_setup(struct snd_sof_dev *sdev, struct snd_sof_pcm *spcm)\n{\n\tstruct snd_sof_pcm_stream_pipeline_list *pipeline_list;\n\tstruct sof_ipc4_fw_data *ipc4_data = sdev->private;\n\tstruct sof_ipc4_timestamp_info *stream_info;\n\tbool support_info = true;\n\tu32 abi_version;\n\tu32 abi_offset;\n\tint stream;\n\n\tabi_offset = offsetof(struct sof_ipc4_fw_registers, abi_ver);\n\tsof_mailbox_read(sdev, sdev->fw_info_box.offset + abi_offset, &abi_version,\n\t\t\t sizeof(abi_version));\n\n\tif (abi_version < SOF_IPC4_FW_REGS_ABI_VER)\n\t\tsupport_info = false;\n\n\tfor_each_pcm_streams(stream) {\n\t\tpipeline_list = &spcm->stream[stream].pipeline_list;\n\n\t\t \n\t\tpipeline_list->pipelines = kcalloc(ipc4_data->max_num_pipelines,\n\t\t\t\t\t\t   sizeof(struct snd_sof_widget *), GFP_KERNEL);\n\t\tif (!pipeline_list->pipelines) {\n\t\t\tsof_ipc4_pcm_free(sdev, spcm);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (!support_info)\n\t\t\tcontinue;\n\n\t\tstream_info = kzalloc(sizeof(*stream_info), GFP_KERNEL);\n\t\tif (!stream_info) {\n\t\t\tsof_ipc4_pcm_free(sdev, spcm);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tspcm->stream[stream].private = stream_info;\n\t}\n\n\treturn 0;\n}\n\nstatic void sof_ipc4_build_time_info(struct snd_sof_dev *sdev, struct snd_sof_pcm_stream *spcm)\n{\n\tstruct sof_ipc4_copier *host_copier = NULL;\n\tstruct sof_ipc4_copier *dai_copier = NULL;\n\tstruct sof_ipc4_llp_reading_slot llp_slot;\n\tstruct sof_ipc4_timestamp_info *info;\n\tstruct snd_soc_dapm_widget *widget;\n\tstruct snd_sof_dai *dai;\n\tint i;\n\n\t \n\tfor_each_dapm_widgets(spcm->list, i, widget) {\n\t\tstruct snd_sof_widget *swidget = widget->dobj.private;\n\n\t\tif (!swidget)\n\t\t\tcontinue;\n\n\t\tif (WIDGET_IS_AIF(swidget->widget->id)) {\n\t\t\thost_copier = swidget->private;\n\t\t} else if (WIDGET_IS_DAI(swidget->widget->id)) {\n\t\t\tdai = swidget->private;\n\t\t\tdai_copier = dai->private;\n\t\t}\n\t}\n\n\t \n\tif (!host_copier || !dai_copier) {\n\t\tdev_err(sdev->dev, \"host or dai copier are not found\\n\");\n\t\treturn;\n\t}\n\n\tinfo = spcm->private;\n\tinfo->host_copier = host_copier;\n\tinfo->dai_copier = dai_copier;\n\tinfo->llp_offset = offsetof(struct sof_ipc4_fw_registers, llp_gpdma_reading_slots) +\n\t\t\t\t    sdev->fw_info_box.offset;\n\n\t \n\tfor (i = 0; i < SOF_IPC4_MAX_LLP_GPDMA_READING_SLOTS; i++) {\n\t\tsof_mailbox_read(sdev, info->llp_offset, &llp_slot, sizeof(llp_slot));\n\t\tif (llp_slot.node_id == dai_copier->data.gtw_cfg.node_id)\n\t\t\tbreak;\n\n\t\tinfo->llp_offset += sizeof(llp_slot);\n\t}\n\n\tif (i < SOF_IPC4_MAX_LLP_GPDMA_READING_SLOTS)\n\t\treturn;\n\n\t \n\tinfo->llp_offset = offsetof(struct sof_ipc4_fw_registers, llp_sndw_reading_slots) +\n\t\t\t\t\tsdev->fw_info_box.offset;\n\tfor (i = 0; i < SOF_IPC4_MAX_LLP_SNDW_READING_SLOTS; i++) {\n\t\tsof_mailbox_read(sdev, info->llp_offset, &llp_slot, sizeof(llp_slot));\n\t\tif (llp_slot.node_id == dai_copier->data.gtw_cfg.node_id)\n\t\t\tbreak;\n\n\t\tinfo->llp_offset += sizeof(llp_slot);\n\t}\n\n\tif (i < SOF_IPC4_MAX_LLP_SNDW_READING_SLOTS)\n\t\treturn;\n\n\t \n\tinfo->llp_offset = offsetof(struct sof_ipc4_fw_registers, llp_evad_reading_slot) +\n\t\t\t\t\tsdev->fw_info_box.offset;\n\tsof_mailbox_read(sdev, info->llp_offset, &llp_slot, sizeof(llp_slot));\n\tif (llp_slot.node_id != dai_copier->data.gtw_cfg.node_id) {\n\t\tdev_info(sdev->dev, \"no llp found, fall back to default HDA path\");\n\t\tinfo->llp_offset = 0;\n\t}\n}\n\nstatic int sof_ipc4_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_sof_platform_stream_params *platform_params)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sof_ipc4_timestamp_info *time_info;\n\tstruct snd_sof_pcm *spcm;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn -EINVAL;\n\n\ttime_info = spcm->stream[substream->stream].private;\n\t \n\tif (!time_info)\n\t\treturn 0;\n\n\ttime_info->stream_start_offset = SOF_IPC4_INVALID_STREAM_POSITION;\n\ttime_info->llp_offset = 0;\n\n\tsof_ipc4_build_time_info(sdev, &spcm->stream[substream->stream]);\n\n\treturn 0;\n}\n\nstatic int sof_ipc4_get_stream_start_offset(struct snd_sof_dev *sdev,\n\t\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t\t    struct snd_sof_pcm_stream *stream,\n\t\t\t\t\t    struct sof_ipc4_timestamp_info *time_info)\n{\n\tstruct sof_ipc4_copier *host_copier = time_info->host_copier;\n\tstruct sof_ipc4_copier *dai_copier = time_info->dai_copier;\n\tstruct sof_ipc4_pipeline_registers ppl_reg;\n\tu64 stream_start_position;\n\tu32 dai_sample_size;\n\tu32 ch, node_index;\n\tu32 offset;\n\n\tif (!host_copier || !dai_copier)\n\t\treturn -EINVAL;\n\n\tif (host_copier->data.gtw_cfg.node_id == SOF_IPC4_INVALID_NODE_ID)\n\t\treturn -EINVAL;\n\n\tnode_index = SOF_IPC4_NODE_INDEX(host_copier->data.gtw_cfg.node_id);\n\toffset = offsetof(struct sof_ipc4_fw_registers, pipeline_regs) + node_index * sizeof(ppl_reg);\n\tsof_mailbox_read(sdev, sdev->fw_info_box.offset + offset, &ppl_reg, sizeof(ppl_reg));\n\tif (ppl_reg.stream_start_offset == SOF_IPC4_INVALID_STREAM_POSITION)\n\t\treturn -EINVAL;\n\n\tstream_start_position = ppl_reg.stream_start_offset;\n\tch = dai_copier->data.out_format.fmt_cfg;\n\tch = SOF_IPC4_AUDIO_FORMAT_CFG_CHANNELS_COUNT(ch);\n\tdai_sample_size = (dai_copier->data.out_format.bit_depth >> 3) * ch;\n\t \n\tdo_div(stream_start_position, dai_sample_size);\n\ttime_info->stream_start_offset = stream_start_position;\n\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t sof_ipc4_pcm_delay(struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_sof_dev *sdev = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct sof_ipc4_timestamp_info *time_info;\n\tstruct sof_ipc4_llp_reading_slot llp;\n\tsnd_pcm_uframes_t head_ptr, tail_ptr;\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct snd_sof_pcm *spcm;\n\tu64 tmp_ptr;\n\tint ret;\n\n\tspcm = snd_sof_find_spcm_dai(component, rtd);\n\tif (!spcm)\n\t\treturn 0;\n\n\tstream = &spcm->stream[substream->stream];\n\ttime_info = stream->private;\n\tif (!time_info)\n\t\treturn 0;\n\n\t \n\tif (time_info->stream_start_offset == SOF_IPC4_INVALID_STREAM_POSITION) {\n\t\tret = sof_ipc4_get_stream_start_offset(sdev, substream, stream, time_info);\n\t\tif (ret < 0)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!time_info->llp_offset) {\n\t\ttmp_ptr = snd_sof_pcm_get_stream_position(sdev, component, substream);\n\t\tif (!tmp_ptr)\n\t\t\treturn 0;\n\t} else {\n\t\tsof_mailbox_read(sdev, time_info->llp_offset, &llp, sizeof(llp));\n\t\ttmp_ptr = ((u64)llp.reading.llp_u << 32) | llp.reading.llp_l;\n\t}\n\n\t \n\ttmp_ptr -= time_info->stream_start_offset;\n\n\t \n\tdiv64_u64_rem(tmp_ptr, substream->runtime->boundary, &tmp_ptr);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\thead_ptr = substream->runtime->status->hw_ptr;\n\t\ttail_ptr = tmp_ptr;\n\t} else {\n\t\thead_ptr = tmp_ptr;\n\t\ttail_ptr = substream->runtime->status->hw_ptr;\n\t}\n\n\tif (head_ptr < tail_ptr)\n\t\treturn substream->runtime->boundary - tail_ptr + head_ptr;\n\n\treturn head_ptr - tail_ptr;\n}\n\nconst struct sof_ipc_pcm_ops ipc4_pcm_ops = {\n\t.hw_params = sof_ipc4_pcm_hw_params,\n\t.trigger = sof_ipc4_pcm_trigger,\n\t.hw_free = sof_ipc4_pcm_hw_free,\n\t.dai_link_fixup = sof_ipc4_pcm_dai_link_fixup,\n\t.pcm_setup = sof_ipc4_pcm_setup,\n\t.pcm_free = sof_ipc4_pcm_free,\n\t.delay = sof_ipc4_pcm_delay,\n\t.ipc_first_on_start = true,\n\t.platform_stop_during_hw_free = true,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}