{
  "module_name": "acp-ipc.c",
  "hash_id": "5a020f1ae339917c209debe5af8ddcc1eed0ced048d8a815547f117a31c524c5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/amd/acp-ipc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/module.h>\n#include \"../ops.h\"\n#include \"acp.h\"\n#include \"acp-dsp-offset.h\"\n\nvoid acp_mailbox_write(struct snd_sof_dev *sdev, u32 offset, void *message, size_t bytes)\n{\n\tmemcpy_to_scratch(sdev, offset, message, bytes);\n}\nEXPORT_SYMBOL_NS(acp_mailbox_write, SND_SOC_SOF_AMD_COMMON);\n\nvoid acp_mailbox_read(struct snd_sof_dev *sdev, u32 offset, void *message, size_t bytes)\n{\n\tmemcpy_from_scratch(sdev, offset, message, bytes);\n}\nEXPORT_SYMBOL_NS(acp_mailbox_read, SND_SOC_SOF_AMD_COMMON);\n\nstatic void acpbus_trigger_host_to_dsp_swintr(struct acp_dev_data *adata)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tu32 swintr_trigger;\n\n\tswintr_trigger = snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->dsp_intr_base +\n\t\t\t\t\t\tDSP_SW_INTR_TRIG_OFFSET);\n\tswintr_trigger |= 0x01;\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->dsp_intr_base + DSP_SW_INTR_TRIG_OFFSET,\n\t\t\t  swintr_trigger);\n}\n\nstatic void acp_ipc_host_msg_set(struct snd_sof_dev *sdev)\n{\n\tunsigned int host_msg = sdev->debug_box.offset +\n\t\t\t\toffsetof(struct scratch_ipc_conf, sof_host_msg_write);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + host_msg, 1);\n}\n\nstatic void acp_dsp_ipc_host_done(struct snd_sof_dev *sdev)\n{\n\tunsigned int dsp_msg = sdev->debug_box.offset +\n\t\t\t       offsetof(struct scratch_ipc_conf, sof_dsp_msg_write);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + dsp_msg, 0);\n}\n\nstatic void acp_dsp_ipc_dsp_done(struct snd_sof_dev *sdev)\n{\n\tunsigned int dsp_ack = sdev->debug_box.offset +\n\t\t\t       offsetof(struct scratch_ipc_conf, sof_dsp_ack_write);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + dsp_ack, 0);\n}\n\nint acp_sof_ipc_send_msg(struct snd_sof_dev *sdev, struct snd_sof_ipc_msg *msg)\n{\n\tstruct acp_dev_data *adata = sdev->pdata->hw_pdata;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int offset = sdev->host_box.offset;\n\tunsigned int count = ACP_HW_SEM_RETRY_COUNT;\n\n\twhile (snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset)) {\n\t\t \n\t\tcount--;\n\t\tif (!count) {\n\t\t\tdev_err(sdev->dev, \"%s: Failed to acquire HW lock\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tacp_mailbox_write(sdev, offset, msg->msg_data, msg->msg_size);\n\tacp_ipc_host_msg_set(sdev);\n\n\t \n\tacpbus_trigger_host_to_dsp_swintr(adata);\n\n\t \n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset, 0x0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_sof_ipc_send_msg, SND_SOC_SOF_AMD_COMMON);\n\nstatic void acp_dsp_ipc_get_reply(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_ipc_msg *msg = sdev->msg;\n\tstruct sof_ipc_reply reply;\n\tstruct sof_ipc_cmd_hdr *hdr;\n\tunsigned int offset = sdev->host_box.offset;\n\tint ret = 0;\n\n        \n\tif (!msg) {\n\t\tdev_warn(sdev->dev, \"unexpected ipc interrupt raised!\\n\");\n\t\treturn;\n\t}\n\thdr = msg->msg_data;\n\tif (hdr->cmd == (SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_CTX_SAVE) ||\n\t    hdr->cmd == (SOF_IPC_GLB_PM_MSG | SOF_IPC_PM_GATE)) {\n\t\t \n\t\treply.error = 0;\n\t\treply.hdr.cmd = SOF_IPC_GLB_REPLY;\n\t\treply.hdr.size = sizeof(reply);\n\t\tmemcpy(msg->reply_data, &reply, sizeof(reply));\n\t\tgoto out;\n\t}\n\t \n\tacp_mailbox_read(sdev, offset, &reply, sizeof(reply));\n\tif (reply.error < 0) {\n\t\tmemcpy(msg->reply_data, &reply, sizeof(reply));\n\t\tret = reply.error;\n\t} else {\n\t\t \n\t\tif (!msg->reply_size)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (reply.hdr.size != msg->reply_size &&\n\t\t    !(reply.hdr.cmd & SOF_IPC_GLB_PROBE)) {\n\t\t\tdev_err(sdev->dev, \"reply expected %zu got %u bytes\\n\",\n\t\t\t\tmsg->reply_size, reply.hdr.size);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t \n\t\tif (msg->reply_size > 0)\n\t\t\tacp_mailbox_read(sdev, offset, msg->reply_data, msg->reply_size);\n\t}\nout:\n\tmsg->reply_error = ret;\n}\n\nirqreturn_t acp_sof_ipc_irq_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tstruct acp_dev_data *adata = sdev->pdata->hw_pdata;\n\tunsigned int dsp_msg_write = sdev->debug_box.offset +\n\t\t\t\t     offsetof(struct scratch_ipc_conf, sof_dsp_msg_write);\n\tunsigned int dsp_ack_write = sdev->debug_box.offset +\n\t\t\t\t     offsetof(struct scratch_ipc_conf, sof_dsp_ack_write);\n\tbool ipc_irq = false;\n\tint dsp_msg, dsp_ack;\n\tunsigned int status;\n\n\tif (sdev->first_boot && sdev->fw_state != SOF_FW_BOOT_COMPLETE) {\n\t\tacp_mailbox_read(sdev, sdev->dsp_box.offset, &status, sizeof(status));\n\t\tif ((status & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {\n\t\t\tsnd_sof_dsp_panic(sdev, sdev->dsp_box.offset + sizeof(status),\n\t\t\t\t\t  true);\n\t\t\tstatus = 0;\n\t\t\tacp_mailbox_write(sdev, sdev->dsp_box.offset, &status, sizeof(status));\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\tacp_dsp_ipc_host_done(sdev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdsp_msg = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + dsp_msg_write);\n\tif (dsp_msg) {\n\t\tsnd_sof_ipc_msgs_rx(sdev);\n\t\tacp_dsp_ipc_host_done(sdev);\n\t\tipc_irq = true;\n\t}\n\n\tdsp_ack = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + dsp_ack_write);\n\tif (dsp_ack) {\n\t\tspin_lock_irq(&sdev->ipc_lock);\n\t\t \n\t\tacp_dsp_ipc_get_reply(sdev);\n\t\tsnd_sof_ipc_reply(sdev, 0);\n\t\t \n\t\tacp_dsp_ipc_dsp_done(sdev);\n\t\tspin_unlock_irq(&sdev->ipc_lock);\n\t\tipc_irq = true;\n\t}\n\n\tacp_mailbox_read(sdev, sdev->debug_box.offset, &status, sizeof(u32));\n\tif ((status & SOF_IPC_PANIC_MAGIC_MASK) == SOF_IPC_PANIC_MAGIC) {\n\t\tsnd_sof_dsp_panic(sdev, sdev->dsp_oops_offset, true);\n\t\tstatus = 0;\n\t\tacp_mailbox_write(sdev, sdev->debug_box.offset, &status, sizeof(status));\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (desc->probe_reg_offset) {\n\t\tu32 val;\n\t\tu32 posn;\n\n\t\t \n\t\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->probe_reg_offset);\n\t\tif (val & PROBE_STATUS_BIT) {\n\t\t\tposn = val & ~PROBE_STATUS_BIT;\n\t\t\tif (adata->probe_stream) {\n\t\t\t\t \n\t\t\t\tadata->probe_stream->cstream_posn = posn;\n\t\t\t\tsnd_compr_fragment_elapsed(adata->probe_stream->cstream);\n\t\t\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->probe_reg_offset, posn);\n\t\t\t\tipc_irq = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ipc_irq)\n\t\tdev_dbg_ratelimited(sdev->dev, \"nothing to do in IPC IRQ thread\\n\");\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_NS(acp_sof_ipc_irq_thread, SND_SOC_SOF_AMD_COMMON);\n\nint acp_sof_ipc_msg_data(struct snd_sof_dev *sdev, struct snd_sof_pcm_stream *sps,\n\t\t\t void *p, size_t sz)\n{\n\tunsigned int offset = sdev->dsp_box.offset;\n\n\tif (!sps || !sdev->stream_box.size) {\n\t\tacp_mailbox_read(sdev, offset, p, sz);\n\t} else {\n\t\tstruct snd_pcm_substream *substream = sps->substream;\n\t\tstruct acp_dsp_stream *stream;\n\n\t\tif (!substream || !substream->runtime)\n\t\t\treturn -ESTRPIPE;\n\n\t\tstream = substream->runtime->private_data;\n\n\t\tif (!stream)\n\t\t\treturn -ESTRPIPE;\n\n\t\tacp_mailbox_read(sdev, stream->posn_offset, p, sz);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_sof_ipc_msg_data, SND_SOC_SOF_AMD_COMMON);\n\nint acp_set_stream_data_offset(struct snd_sof_dev *sdev,\n\t\t\t       struct snd_sof_pcm_stream *sps,\n\t\t\t       size_t posn_offset)\n{\n\tstruct snd_pcm_substream *substream = sps->substream;\n\tstruct acp_dsp_stream *stream = substream->runtime->private_data;\n\n\t \n\tif (posn_offset > sdev->stream_box.size ||\n\t    posn_offset % sizeof(struct sof_ipc_stream_posn) != 0)\n\t\treturn -EINVAL;\n\n\tstream->posn_offset = sdev->stream_box.offset + posn_offset;\n\n\tdev_dbg(sdev->dev, \"pcm: stream dir %d, posn mailbox offset is %zu\",\n\t\tsubstream->stream, stream->posn_offset);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_set_stream_data_offset, SND_SOC_SOF_AMD_COMMON);\n\nint acp_sof_ipc_get_mailbox_offset(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\n\treturn desc->sram_pte_offset;\n}\nEXPORT_SYMBOL_NS(acp_sof_ipc_get_mailbox_offset, SND_SOC_SOF_AMD_COMMON);\n\nint acp_sof_ipc_get_window_offset(struct snd_sof_dev *sdev, u32 id)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_sof_ipc_get_window_offset, SND_SOC_SOF_AMD_COMMON);\n\nMODULE_DESCRIPTION(\"AMD ACP sof-ipc driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}