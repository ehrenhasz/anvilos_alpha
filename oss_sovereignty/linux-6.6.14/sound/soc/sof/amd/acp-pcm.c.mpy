{
  "module_name": "acp-pcm.c",
  "hash_id": "14ebe1d3644095027dcd7c543c86c194021ab2be04ed1f116dd442e7dedea3a7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/amd/acp-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n#include <sound/pcm_params.h>\n\n#include \"../ops.h\"\n#include \"acp.h\"\n#include \"acp-dsp-offset.h\"\n\nint acp_pcm_hw_params(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream,\n\t\t      struct snd_pcm_hw_params *params,\n\t\t      struct snd_sof_platform_stream_params *platform_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct acp_dsp_stream *stream = runtime->private_data;\n\tunsigned int buf_offset, index;\n\tu32 size;\n\tint ret;\n\n\tsize = runtime->dma_bytes;\n\tstream->num_pages = PFN_UP(runtime->dma_bytes);\n\tstream->dmab = substream->runtime->dma_buffer_p;\n\n\tret = acp_dsp_stream_config(sdev, stream);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"stream configuration failed\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_params->use_phy_address = true;\n\tplatform_params->phy_addr = stream->reg_offset;\n\tplatform_params->stream_tag = stream->stream_tag;\n\tplatform_params->cont_update_posn = 1;\n\n\t \n\n\tbuf_offset = sdev->debug_box.offset +\n\t\t     offsetof(struct scratch_reg_conf, buf_size);\n\tindex = stream->stream_tag - 1;\n\tbuf_offset = buf_offset + index * 4;\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + buf_offset, size);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_pcm_hw_params, SND_SOC_SOF_AMD_COMMON);\n\nint acp_pcm_open(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream)\n{\n\tstruct acp_dsp_stream *stream;\n\n\tstream = acp_dsp_stream_get(sdev, 0);\n\tif (!stream)\n\t\treturn -ENODEV;\n\n\tsubstream->runtime->private_data = stream;\n\tstream->substream = substream;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_pcm_open, SND_SOC_SOF_AMD_COMMON);\n\nint acp_pcm_close(struct snd_sof_dev *sdev, struct snd_pcm_substream *substream)\n{\n\tstruct acp_dsp_stream *stream;\n\n\tstream = substream->runtime->private_data;\n\tif (!stream) {\n\t\tdev_err(sdev->dev, \"No open stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstream->substream = NULL;\n\tsubstream->runtime->private_data = NULL;\n\n\treturn acp_dsp_stream_put(sdev, stream);\n}\nEXPORT_SYMBOL_NS(acp_pcm_close, SND_SOC_SOF_AMD_COMMON);\n\nsnd_pcm_uframes_t acp_pcm_pointer(struct snd_sof_dev *sdev,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *scomp = sdev->component;\n\tstruct snd_sof_pcm_stream *stream;\n\tstruct sof_ipc_stream_posn posn;\n\tstruct snd_sof_pcm *spcm;\n\tsnd_pcm_uframes_t pos;\n\tint ret;\n\n\tspcm = snd_sof_find_spcm_dai(scomp, rtd);\n\tif (!spcm) {\n\t\tdev_warn_ratelimited(sdev->dev, \"warn: can't find PCM with DAI ID %d\\n\",\n\t\t\t\t     rtd->dai_link->id);\n\t\treturn 0;\n\t}\n\n\tstream = &spcm->stream[substream->stream];\n\tret = snd_sof_ipc_msg_data(sdev, stream, &posn, sizeof(posn));\n\tif (ret < 0) {\n\t\tdev_warn(sdev->dev, \"failed to read stream position: %d\\n\", ret);\n\t\treturn 0;\n\t}\n\n\tmemcpy(&stream->posn, &posn, sizeof(posn));\n\tpos = spcm->stream[substream->stream].posn.host_posn;\n\tpos = bytes_to_frames(substream->runtime, pos);\n\n\treturn pos;\n}\nEXPORT_SYMBOL_NS(acp_pcm_pointer, SND_SOC_SOF_AMD_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}