{
  "module_name": "acp.c",
  "hash_id": "267f95ffb462620356c79f18f87733e3a83edfc3c36eb060ab430d120e9075e4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/amd/acp.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"../ops.h\"\n#include \"acp.h\"\n#include \"acp-dsp-offset.h\"\n\n#define SECURED_FIRMWARE 1\n\nstatic bool enable_fw_debug;\nmodule_param(enable_fw_debug, bool, 0444);\nMODULE_PARM_DESC(enable_fw_debug, \"Enable Firmware debug\");\n\nconst struct dmi_system_id acp_sof_quirk_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Valve\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Galileo\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_FAMILY, \"Sephiroth\"),\n\t\t},\n\t\t.driver_data = (void *)SECURED_FIRMWARE,\n\t},\n\t{}\n};\nEXPORT_SYMBOL_GPL(acp_sof_quirk_table);\n\nstatic int smn_write(struct pci_dev *dev, u32 smn_addr, u32 data)\n{\n\tpci_write_config_dword(dev, 0x60, smn_addr);\n\tpci_write_config_dword(dev, 0x64, data);\n\n\treturn 0;\n}\n\nstatic int smn_read(struct pci_dev *dev, u32 smn_addr)\n{\n\tu32 data = 0;\n\n\tpci_write_config_dword(dev, 0x60, smn_addr);\n\tpci_read_config_dword(dev, 0x64, &data);\n\n\treturn data;\n}\n\nstatic void init_dma_descriptor(struct acp_dev_data *adata)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int addr;\n\n\taddr = desc->sram_pte_offset + sdev->debug_box.offset +\n\t       offsetof(struct scratch_reg_conf, dma_desc);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_DESC_BASE_ADDR, addr);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_DESC_MAX_NUM_DSCR, ACP_MAX_DESC_CNT);\n}\n\nstatic void configure_dma_descriptor(struct acp_dev_data *adata, unsigned short idx,\n\t\t\t\t     struct dma_descriptor *dscr_info)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tunsigned int offset;\n\n\toffset = ACP_SCRATCH_REG_0 + sdev->debug_box.offset +\n\t\toffsetof(struct scratch_reg_conf, dma_desc) +\n\t\tidx * sizeof(struct dma_descriptor);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, offset, dscr_info->src_addr);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, offset + 0x4, dscr_info->dest_addr);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, offset + 0x8, dscr_info->tx_cnt.u32_all);\n}\n\nstatic int config_dma_channel(struct acp_dev_data *adata, unsigned int ch,\n\t\t\t      unsigned int idx, unsigned int dscr_count)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tunsigned int val, status;\n\tint ret;\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_CNTL_0 + ch * sizeof(u32),\n\t\t\t  ACP_DMA_CH_RST | ACP_DMA_CH_GRACEFUL_RST_EN);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_DMA_CH_RST_STS, val,\n\t\t\t\t\t    val & (1 << ch), ACP_REG_POLL_INTERVAL,\n\t\t\t\t\t    ACP_REG_POLL_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tstatus = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_ERROR_STATUS);\n\t\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_DMA_ERR_STS_0 + ch * sizeof(u32));\n\n\t\tdev_err(sdev->dev, \"ACP_DMA_ERR_STS :0x%x ACP_ERROR_STATUS :0x%x\\n\", val, status);\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, (ACP_DMA_CNTL_0 + ch * sizeof(u32)), 0);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_DSCR_CNT_0 + ch * sizeof(u32), dscr_count);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_DSCR_STRT_IDX_0 + ch * sizeof(u32), idx);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_PRIO_0 + ch * sizeof(u32), 0);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DMA_CNTL_0 + ch * sizeof(u32), ACP_DMA_CH_RUN);\n\n\treturn ret;\n}\n\nstatic int acpbus_dma_start(struct acp_dev_data *adata, unsigned int ch,\n\t\t\t    unsigned int dscr_count, struct dma_descriptor *dscr_info)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tint ret;\n\tu16 dscr;\n\n\tif (!dscr_info || !dscr_count)\n\t\treturn -EINVAL;\n\n\tfor (dscr = 0; dscr < dscr_count; dscr++)\n\t\tconfigure_dma_descriptor(adata, dscr, dscr_info++);\n\n\tret = config_dma_channel(adata, ch, 0, dscr_count);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"config dma ch failed:%d\\n\", ret);\n\n\treturn ret;\n}\n\nint configure_and_run_dma(struct acp_dev_data *adata, unsigned int src_addr,\n\t\t\t  unsigned int dest_addr, int dsp_data_size)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tunsigned int desc_count, index;\n\tint ret;\n\n\tfor (desc_count = 0; desc_count < ACP_MAX_DESC && dsp_data_size >= 0;\n\t     desc_count++, dsp_data_size -= ACP_PAGE_SIZE) {\n\t\tadata->dscr_info[desc_count].src_addr = src_addr + desc_count * ACP_PAGE_SIZE;\n\t\tadata->dscr_info[desc_count].dest_addr = dest_addr + desc_count * ACP_PAGE_SIZE;\n\t\tadata->dscr_info[desc_count].tx_cnt.bits.count = ACP_PAGE_SIZE;\n\t\tif (dsp_data_size < ACP_PAGE_SIZE)\n\t\t\tadata->dscr_info[desc_count].tx_cnt.bits.count = dsp_data_size;\n\t}\n\n\tret = acpbus_dma_start(adata, 0, desc_count, adata->dscr_info);\n\tif (ret)\n\t\tdev_err(sdev->dev, \"acpbus_dma_start failed\\n\");\n\n\t \n\tfor (index = 0; index < desc_count; index++)\n\t\tmemset(&adata->dscr_info[index], 0x00, sizeof(struct dma_descriptor));\n\n\treturn ret;\n}\n\n \n\nstatic int psp_mbox_ready(struct acp_dev_data *adata, bool ack)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tint ret;\n\tu32 data;\n\n\tret = read_poll_timeout(smn_read, data, data & MBOX_READY_MASK, MBOX_DELAY_US,\n\t\t\t\tACP_PSP_TIMEOUT_US, false, adata->smn_dev, MP0_C2PMSG_114_REG);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(sdev->dev, \"PSP error status %x\\n\", data & MBOX_STATUS_MASK);\n\n\tif (ack)\n\t\treturn -ETIMEDOUT;\n\n\treturn -EBUSY;\n}\n\n \n\nstatic int psp_send_cmd(struct acp_dev_data *adata, int cmd)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tint ret;\n\tu32 data;\n\n\tif (!cmd)\n\t\treturn -EINVAL;\n\n\t \n\tret = read_poll_timeout(smn_read, data, data, MBOX_DELAY_US, ACP_PSP_TIMEOUT_US, false,\n\t\t\t\tadata->smn_dev, MP0_C2PMSG_73_REG);\n\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"Failed to get Doorbell from MBOX %x\\n\", MP0_C2PMSG_73_REG);\n\t\treturn ret;\n\t}\n\n\t \n\tret = psp_mbox_ready(adata, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tsmn_write(adata->smn_dev, MP0_C2PMSG_114_REG, cmd);\n\n\t \n\tsmn_write(adata->smn_dev, MP0_C2PMSG_73_REG, data);\n\n\t \n\tret = psp_mbox_ready(adata, 1);\n\n\treturn ret;\n}\n\nint configure_and_run_sha_dma(struct acp_dev_data *adata, void *image_addr,\n\t\t\t      unsigned int start_addr, unsigned int dest_addr,\n\t\t\t      unsigned int image_length)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int tx_count, fw_qualifier, val;\n\tint ret;\n\n\tif (!image_addr) {\n\t\tdev_err(sdev->dev, \"SHA DMA image address is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_SHA_DMA_CMD);\n\tif (val & ACP_SHA_RUN) {\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_DMA_CMD, ACP_SHA_RESET);\n\t\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_SHA_DMA_CMD_STS,\n\t\t\t\t\t\t    val, val & ACP_SHA_RESET,\n\t\t\t\t\t\t    ACP_REG_POLL_INTERVAL,\n\t\t\t\t\t\t    ACP_REG_POLL_TIMEOUT_US);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sdev->dev, \"SHA DMA Failed to Reset\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (adata->signed_fw_image)\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_DMA_INCLUDE_HDR, ACP_SHA_HEADER);\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_DMA_STRT_ADDR, start_addr);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_DMA_DESTINATION_ADDR, dest_addr);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_MSG_LENGTH, image_length);\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SHA_DMA_CMD, ACP_SHA_RUN);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_SHA_TRANSFER_BYTE_CNT,\n\t\t\t\t\t    tx_count, tx_count == image_length,\n\t\t\t\t\t    ACP_REG_POLL_INTERVAL, ACP_DMA_COMPLETE_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"SHA DMA Failed to Transfer Length %x\\n\", tx_count);\n\t\treturn ret;\n\t}\n\n\t \n\tif (desc->rev == 3) {\n\t\tret = psp_send_cmd(adata, MBOX_ACP_SHA_DMA_COMMAND);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_SHA_DSP_FW_QUALIFIER,\n\t\t\t\t\t    fw_qualifier, fw_qualifier & DSP_FW_RUN_ENABLE,\n\t\t\t\t\t    ACP_REG_POLL_INTERVAL, ACP_DMA_COMPLETE_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"PSP validation failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint acp_dma_status(struct acp_dev_data *adata, unsigned char ch)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tunsigned int val;\n\tint ret = 0;\n\n\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_DMA_CNTL_0 + ch * sizeof(u32));\n\tif (val & ACP_DMA_CH_RUN) {\n\t\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_DMA_CH_STS, val, !val,\n\t\t\t\t\t\t    ACP_REG_POLL_INTERVAL,\n\t\t\t\t\t\t    ACP_DMA_COMPLETE_TIMEOUT_US);\n\t\tif (ret < 0)\n\t\t\tdev_err(sdev->dev, \"DMA_CHANNEL %d status timeout\\n\", ch);\n\t}\n\n\treturn ret;\n}\n\nvoid memcpy_from_scratch(struct snd_sof_dev *sdev, u32 offset, unsigned int *dst, size_t bytes)\n{\n\tunsigned int reg_offset = offset + ACP_SCRATCH_REG_0;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < bytes; i = i + 4, j++)\n\t\tdst[j] = snd_sof_dsp_read(sdev, ACP_DSP_BAR, reg_offset + i);\n}\n\nvoid memcpy_to_scratch(struct snd_sof_dev *sdev, u32 offset, unsigned int *src, size_t bytes)\n{\n\tunsigned int reg_offset = offset + ACP_SCRATCH_REG_0;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < bytes; i = i + 4, j++)\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, reg_offset + i, src[j]);\n}\n\nstatic int acp_memory_init(struct snd_sof_dev *sdev)\n{\n\tstruct acp_dev_data *adata = sdev->pdata->hw_pdata;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\n\tsnd_sof_dsp_update_bits(sdev, ACP_DSP_BAR, desc->dsp_intr_base + DSP_SW_INTR_CNTL_OFFSET,\n\t\t\t\tACP_DSP_INTR_EN_MASK, ACP_DSP_INTR_EN_MASK);\n\tinit_dma_descriptor(adata);\n\n\treturn 0;\n}\n\nstatic irqreturn_t acp_irq_thread(int irq, void *context)\n{\n\tstruct snd_sof_dev *sdev = context;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int count = ACP_HW_SEM_RETRY_COUNT;\n\n\twhile (snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset)) {\n\t\t \n\t\tcount--;\n\t\tif (!count) {\n\t\t\tdev_err(sdev->dev, \"%s: Failed to acquire HW lock\\n\", __func__);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\n\tsof_ops(sdev)->irq_thread(irq, sdev);\n\t \n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->hw_semaphore_offset, 0x0);\n\n\treturn IRQ_HANDLED;\n};\n\nstatic irqreturn_t acp_irq_handler(int irq, void *dev_id)\n{\n\tstruct snd_sof_dev *sdev = dev_id;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int base = desc->dsp_intr_base;\n\tunsigned int val;\n\n\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, base + DSP_SW_INTR_STAT_OFFSET);\n\tif (val & ACP_DSP_TO_HOST_IRQ) {\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, base + DSP_SW_INTR_STAT_OFFSET,\n\t\t\t\t  ACP_DSP_TO_HOST_IRQ);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int acp_power_on(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int base = desc->pgfsm_base;\n\tunsigned int val;\n\tint ret;\n\n\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, base + PGFSM_STATUS_OFFSET);\n\n\tif (val == ACP_POWERED_ON)\n\t\treturn 0;\n\n\tif (val & ACP_PGFSM_STATUS_MASK)\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, base + PGFSM_CONTROL_OFFSET,\n\t\t\t\t  ACP_PGFSM_CNTL_POWER_ON_MASK);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, base + PGFSM_STATUS_OFFSET, val,\n\t\t\t\t\t    !val, ACP_REG_POLL_INTERVAL, ACP_REG_POLL_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"timeout in ACP_PGFSM_STATUS read\\n\");\n\n\treturn ret;\n}\n\nstatic int acp_reset(struct snd_sof_dev *sdev)\n{\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int val;\n\tint ret;\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SOFT_RESET, ACP_ASSERT_RESET);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_SOFT_RESET, val,\n\t\t\t\t\t    val & ACP_SOFT_RESET_DONE_MASK,\n\t\t\t\t\t    ACP_REG_POLL_INTERVAL, ACP_REG_POLL_TIMEOUT_US);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"timeout asserting reset\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SOFT_RESET, ACP_RELEASE_RESET);\n\n\tret = snd_sof_dsp_read_poll_timeout(sdev, ACP_DSP_BAR, ACP_SOFT_RESET, val, !val,\n\t\t\t\t\t    ACP_REG_POLL_INTERVAL, ACP_REG_POLL_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"timeout in releasing reset\\n\");\n\n\tif (desc->acp_clkmux_sel)\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->acp_clkmux_sel, ACP_CLOCK_ACLK);\n\n\tif (desc->ext_intr_enb)\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->ext_intr_enb, 0x01);\n\n\treturn ret;\n}\n\nstatic int acp_init(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\t \n\tret = acp_power_on(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"ACP power on failed\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_CONTROL, 0x01);\n\t \n\treturn acp_reset(sdev);\n}\n\nint amd_sof_acp_suspend(struct snd_sof_dev *sdev, u32 target_state)\n{\n\tint ret;\n\n\tret = acp_reset(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"ACP Reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_CONTROL, 0x00);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(amd_sof_acp_suspend, SND_SOC_SOF_AMD_COMMON);\n\nint amd_sof_acp_resume(struct snd_sof_dev *sdev)\n{\n\tint ret;\n\n\tret = acp_init(sdev);\n\tif (ret) {\n\t\tdev_err(sdev->dev, \"ACP Init failed\\n\");\n\t\treturn ret;\n\t}\n\treturn acp_memory_init(sdev);\n}\nEXPORT_SYMBOL_NS(amd_sof_acp_resume, SND_SOC_SOF_AMD_COMMON);\n\nint amd_sof_acp_probe(struct snd_sof_dev *sdev)\n{\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tstruct acp_dev_data *adata;\n\tconst struct sof_amd_acp_desc *chip;\n\tconst struct dmi_system_id *dmi_id;\n\tunsigned int addr;\n\tint ret;\n\n\tchip = get_chip_info(sdev->pdata);\n\tif (!chip) {\n\t\tdev_err(sdev->dev, \"no such device supported, chip id:%x\\n\", pci->device);\n\t\treturn -EIO;\n\t}\n\tadata = devm_kzalloc(sdev->dev, sizeof(struct acp_dev_data),\n\t\t\t     GFP_KERNEL);\n\tif (!adata)\n\t\treturn -ENOMEM;\n\n\tadata->dev = sdev;\n\tadata->dmic_dev = platform_device_register_data(sdev->dev, \"dmic-codec\",\n\t\t\t\t\t\t\tPLATFORM_DEVID_NONE, NULL, 0);\n\tif (IS_ERR(adata->dmic_dev)) {\n\t\tdev_err(sdev->dev, \"failed to register platform for dmic codec\\n\");\n\t\treturn PTR_ERR(adata->dmic_dev);\n\t}\n\taddr = pci_resource_start(pci, ACP_DSP_BAR);\n\tsdev->bar[ACP_DSP_BAR] = devm_ioremap(sdev->dev, addr, pci_resource_len(pci, ACP_DSP_BAR));\n\tif (!sdev->bar[ACP_DSP_BAR]) {\n\t\tdev_err(sdev->dev, \"ioremap error\\n\");\n\t\tret = -ENXIO;\n\t\tgoto unregister_dev;\n\t}\n\n\tpci_set_master(pci);\n\n\tsdev->pdata->hw_pdata = adata;\n\tadata->smn_dev = pci_get_device(PCI_VENDOR_ID_AMD, chip->host_bridge_id, NULL);\n\tif (!adata->smn_dev) {\n\t\tdev_err(sdev->dev, \"Failed to get host bridge device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_dev;\n\t}\n\n\tsdev->ipc_irq = pci->irq;\n\tret = request_threaded_irq(sdev->ipc_irq, acp_irq_handler, acp_irq_thread,\n\t\t\t\t   IRQF_SHARED, \"AudioDSP\", sdev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"failed to register IRQ %d\\n\",\n\t\t\tsdev->ipc_irq);\n\t\tgoto free_smn_dev;\n\t}\n\n\tret = acp_init(sdev);\n\tif (ret < 0)\n\t\tgoto free_ipc_irq;\n\n\tsdev->dsp_box.offset = 0;\n\tsdev->dsp_box.size = BOX_SIZE_512;\n\n\tsdev->host_box.offset = sdev->dsp_box.offset + sdev->dsp_box.size;\n\tsdev->host_box.size = BOX_SIZE_512;\n\n\tsdev->debug_box.offset = sdev->host_box.offset + sdev->host_box.size;\n\tsdev->debug_box.size = BOX_SIZE_1024;\n\n\tadata->signed_fw_image = false;\n\tdmi_id = dmi_first_match(acp_sof_quirk_table);\n\tif (dmi_id && dmi_id->driver_data) {\n\t\tadata->fw_code_bin = kasprintf(GFP_KERNEL, \"%s/sof-%s-code.bin\",\n\t\t\t\t\t       plat_data->fw_filename_prefix,\n\t\t\t\t\t       chip->name);\n\t\tadata->fw_data_bin = kasprintf(GFP_KERNEL, \"%s/sof-%s-data.bin\",\n\t\t\t\t\t       plat_data->fw_filename_prefix,\n\t\t\t\t\t       chip->name);\n\t\tadata->signed_fw_image = dmi_id->driver_data;\n\n\t\tdev_dbg(sdev->dev, \"fw_code_bin:%s, fw_data_bin:%s\\n\", adata->fw_code_bin,\n\t\t\tadata->fw_data_bin);\n\t}\n\tadata->enable_fw_debug = enable_fw_debug;\n\tacp_memory_init(sdev);\n\n\tacp_dsp_stream_init(sdev);\n\n\treturn 0;\n\nfree_ipc_irq:\n\tfree_irq(sdev->ipc_irq, sdev);\nfree_smn_dev:\n\tpci_dev_put(adata->smn_dev);\nunregister_dev:\n\tplatform_device_unregister(adata->dmic_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(amd_sof_acp_probe, SND_SOC_SOF_AMD_COMMON);\n\nint amd_sof_acp_remove(struct snd_sof_dev *sdev)\n{\n\tstruct acp_dev_data *adata = sdev->pdata->hw_pdata;\n\n\tif (adata->smn_dev)\n\t\tpci_dev_put(adata->smn_dev);\n\n\tif (sdev->ipc_irq)\n\t\tfree_irq(sdev->ipc_irq, sdev);\n\n\tif (adata->dmic_dev)\n\t\tplatform_device_unregister(adata->dmic_dev);\n\n\treturn acp_reset(sdev);\n}\nEXPORT_SYMBOL_NS(amd_sof_acp_remove, SND_SOC_SOF_AMD_COMMON);\n\nMODULE_DESCRIPTION(\"AMD ACP sof driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}