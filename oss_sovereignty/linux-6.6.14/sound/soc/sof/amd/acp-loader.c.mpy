{
  "module_name": "acp-loader.c",
  "hash_id": "4e96303d74f3e48046855be461b1a48a422b8be7f1d33ec73eeab4ea23c68669",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sof/amd/acp-loader.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n \n\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"../ops.h\"\n#include \"acp-dsp-offset.h\"\n#include \"acp.h\"\n\n#define FW_BIN\t\t0\n#define FW_DATA_BIN\t1\n\n#define FW_BIN_PTE_OFFSET\t0x00\n#define FW_DATA_BIN_PTE_OFFSET\t0x08\n\n#define ACP_DSP_RUN\t0x00\n\nint acp_dsp_block_read(struct snd_sof_dev *sdev, enum snd_sof_fw_blk_type blk_type,\n\t\t       u32 offset, void *dest, size_t size)\n{\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tswitch (blk_type) {\n\tcase SOF_FW_BLK_TYPE_SRAM:\n\t\toffset = offset - desc->sram_pte_offset;\n\t\tmemcpy_from_scratch(sdev, offset, dest, size);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"bad blk type 0x%x\\n\", blk_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_dsp_block_read, SND_SOC_SOF_AMD_COMMON);\n\nint acp_dsp_block_write(struct snd_sof_dev *sdev, enum snd_sof_fw_blk_type blk_type,\n\t\t\tu32 offset, void *src, size_t size)\n{\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tstruct acp_dev_data *adata;\n\tvoid *dest;\n\tu32 dma_size, page_count;\n\tunsigned int size_fw;\n\n\tadata = sdev->pdata->hw_pdata;\n\n\tswitch (blk_type) {\n\tcase SOF_FW_BLK_TYPE_IRAM:\n\t\tif (!adata->bin_buf) {\n\t\t\tsize_fw = sdev->basefw.fw->size;\n\t\t\tpage_count = PAGE_ALIGN(size_fw) >> PAGE_SHIFT;\n\t\t\tdma_size = page_count * ACP_PAGE_SIZE;\n\t\t\tadata->bin_buf = dma_alloc_coherent(&pci->dev, dma_size,\n\t\t\t\t\t\t\t    &adata->sha_dma_addr,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (!adata->bin_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tadata->fw_bin_size = size + offset;\n\t\tdest = adata->bin_buf + offset;\n\t\tbreak;\n\tcase SOF_FW_BLK_TYPE_DRAM:\n\t\tif (!adata->data_buf) {\n\t\t\tadata->data_buf = dma_alloc_coherent(&pci->dev,\n\t\t\t\t\t\t\t     ACP_DEFAULT_DRAM_LENGTH,\n\t\t\t\t\t\t\t     &adata->dma_addr,\n\t\t\t\t\t\t\t     GFP_ATOMIC);\n\t\t\tif (!adata->data_buf)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdest = adata->data_buf + offset;\n\t\tadata->fw_data_bin_size = size + offset;\n\t\tbreak;\n\tcase SOF_FW_BLK_TYPE_SRAM:\n\t\toffset = offset - desc->sram_pte_offset;\n\t\tmemcpy_to_scratch(sdev, offset, src, size);\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(sdev->dev, \"bad blk type 0x%x\\n\", blk_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(dest, src, size);\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_dsp_block_write, SND_SOC_SOF_AMD_COMMON);\n\nint acp_get_bar_index(struct snd_sof_dev *sdev, u32 type)\n{\n\treturn type;\n}\nEXPORT_SYMBOL_NS(acp_get_bar_index, SND_SOC_SOF_AMD_COMMON);\n\nstatic void configure_pte_for_fw_loading(int type, int num_pages, struct acp_dev_data *adata)\n{\n\tstruct snd_sof_dev *sdev = adata->dev;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tunsigned int low, high;\n\tdma_addr_t addr;\n\tu16 page_idx;\n\tu32 offset;\n\n\tswitch (type) {\n\tcase FW_BIN:\n\t\toffset = FW_BIN_PTE_OFFSET;\n\t\taddr = adata->sha_dma_addr;\n\t\tbreak;\n\tcase FW_DATA_BIN:\n\t\toffset = adata->fw_bin_page_count * 8;\n\t\taddr = adata->dma_addr;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sdev->dev, \"Invalid data type %x\\n\", type);\n\t\treturn;\n\t}\n\n\t \n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACPAXI2AXI_ATU_BASE_ADDR_GRP_1,\n\t\t\t  desc->sram_pte_offset | BIT(31));\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACPAXI2AXI_ATU_PAGE_SIZE_GRP_1,\n\t\t\t  PAGE_SIZE_4K_ENABLE);\n\n\tfor (page_idx = 0; page_idx < num_pages; page_idx++) {\n\t\tlow = lower_32_bits(addr);\n\t\thigh = upper_32_bits(addr);\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + offset, low);\n\t\thigh |= BIT(31);\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_SCRATCH_REG_0 + offset + 4, high);\n\t\toffset += 8;\n\t\taddr += PAGE_SIZE;\n\t}\n\n\t \n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACPAXI2AXI_ATU_CTRL, ACP_ATU_CACHE_INVALID);\n}\n\n \nint acp_dsp_pre_fw_run(struct snd_sof_dev *sdev)\n{\n\tstruct pci_dev *pci = to_pci_dev(sdev->dev);\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tstruct acp_dev_data *adata;\n\tunsigned int src_addr, size_fw;\n\tu32 page_count, dma_size;\n\tint ret;\n\n\tadata = sdev->pdata->hw_pdata;\n\n\tif (adata->signed_fw_image)\n\t\tsize_fw = adata->fw_bin_size - ACP_FIRMWARE_SIGNATURE;\n\telse\n\t\tsize_fw = adata->fw_bin_size;\n\n\tpage_count = PAGE_ALIGN(size_fw) >> PAGE_SHIFT;\n\tadata->fw_bin_page_count = page_count;\n\n\tconfigure_pte_for_fw_loading(FW_BIN, page_count, adata);\n\tret = configure_and_run_sha_dma(adata, adata->bin_buf, ACP_SYSTEM_MEMORY_WINDOW,\n\t\t\t\t\tACP_IRAM_BASE_ADDRESS, size_fw);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"SHA DMA transfer failed status: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tconfigure_pte_for_fw_loading(FW_DATA_BIN, ACP_DRAM_PAGE_COUNT, adata);\n\n\tsrc_addr = ACP_SYSTEM_MEMORY_WINDOW + page_count * ACP_PAGE_SIZE;\n\tret = configure_and_run_dma(adata, src_addr, ACP_DATA_RAM_BASE_ADDRESS,\n\t\t\t\t    adata->fw_data_bin_size);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"acp dma configuration failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = acp_dma_status(adata, 0);\n\tif (ret < 0)\n\t\tdev_err(sdev->dev, \"acp dma transfer status: %d\\n\", ret);\n\n\tif (desc->rev > 3) {\n\t\t \n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DSP0_CACHE_OFFSET0, desc->sram_pte_offset);\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DSP0_CACHE_SIZE0, SRAM1_SIZE | BIT(31));\n\t}\n\n\t \n\tdma_size =  (PAGE_ALIGN(sdev->basefw.fw->size) >> PAGE_SHIFT) * ACP_PAGE_SIZE;\n\tdma_free_coherent(&pci->dev, dma_size, adata->bin_buf, adata->sha_dma_addr);\n\tdma_free_coherent(&pci->dev, ACP_DEFAULT_DRAM_LENGTH, adata->data_buf, adata->dma_addr);\n\tadata->bin_buf = NULL;\n\tadata->data_buf = NULL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(acp_dsp_pre_fw_run, SND_SOC_SOF_AMD_COMMON);\n\nint acp_sof_dsp_run(struct snd_sof_dev *sdev)\n{\n\tstruct acp_dev_data *adata = sdev->pdata->hw_pdata;\n\tconst struct sof_amd_acp_desc *desc = get_chip_info(sdev->pdata);\n\tint val;\n\n\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, ACP_DSP0_RUNSTALL, ACP_DSP_RUN);\n\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, ACP_DSP0_RUNSTALL);\n\tdev_dbg(sdev->dev, \"ACP_DSP0_RUNSTALL : 0x%0x\\n\", val);\n\n\t \n\tif (desc->fusion_dsp_offset && adata->enable_fw_debug) {\n\t\tsnd_sof_dsp_write(sdev, ACP_DSP_BAR, desc->fusion_dsp_offset, ACP_DSP_RUN);\n\t\tval = snd_sof_dsp_read(sdev, ACP_DSP_BAR, desc->fusion_dsp_offset);\n\t\tdev_dbg(sdev->dev, \"ACP_DSP0_FUSION_RUNSTALL : 0x%0x\\n\", val);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_NS(acp_sof_dsp_run, SND_SOC_SOF_AMD_COMMON);\n\nint acp_sof_load_signed_firmware(struct snd_sof_dev *sdev)\n{\n\tstruct snd_sof_pdata *plat_data = sdev->pdata;\n\tstruct acp_dev_data *adata = plat_data->hw_pdata;\n\tint ret;\n\n\tret = request_firmware(&sdev->basefw.fw, adata->fw_code_bin, sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"sof signed firmware code bin is missing\\n\");\n\t\treturn ret;\n\t} else {\n\t\tdev_dbg(sdev->dev, \"request_firmware %s successful\\n\", adata->fw_code_bin);\n\t}\n\tret = snd_sof_dsp_block_write(sdev, SOF_FW_BLK_TYPE_IRAM, 0,\n\t\t\t\t      (void *)sdev->basefw.fw->data, sdev->basefw.fw->size);\n\n\tret = request_firmware(&adata->fw_dbin, adata->fw_data_bin, sdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(sdev->dev, \"sof signed firmware data bin is missing\\n\");\n\t\treturn ret;\n\n\t} else {\n\t\tdev_dbg(sdev->dev, \"request_firmware %s successful\\n\", adata->fw_data_bin);\n\t}\n\n\tret = snd_sof_dsp_block_write(sdev, SOF_FW_BLK_TYPE_DRAM, 0,\n\t\t\t\t      (void *)adata->fw_dbin->data, adata->fw_dbin->size);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS(acp_sof_load_signed_firmware, SND_SOC_SOF_AMD_COMMON);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}