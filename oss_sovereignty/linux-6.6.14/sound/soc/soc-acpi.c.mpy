{
  "module_name": "soc-acpi.c",
  "hash_id": "259df6a3ae463707069059df5cc203ca90b5711490e8e55c2b504df930d52968",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-acpi.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/export.h>\n#include <linux/module.h>\n#include <sound/soc-acpi.h>\n\nstatic bool snd_soc_acpi_id_present(struct snd_soc_acpi_mach *machine)\n{\n\tconst struct snd_soc_acpi_codecs *comp_ids = machine->comp_ids;\n\tint i;\n\n\tif (machine->id[0]) {\n\t\tif (acpi_dev_present(machine->id, NULL, -1))\n\t\t\treturn true;\n\t}\n\n\tif (comp_ids) {\n\t\tfor (i = 0; i < comp_ids->num_codecs; i++) {\n\t\t\tif (acpi_dev_present(comp_ids->codecs[i], NULL, -1)) {\n\t\t\t\tstrscpy(machine->id, comp_ids->codecs[i], ACPI_ID_LEN);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstruct snd_soc_acpi_mach *\nsnd_soc_acpi_find_machine(struct snd_soc_acpi_mach *machines)\n{\n\tstruct snd_soc_acpi_mach *mach;\n\tstruct snd_soc_acpi_mach *mach_alt;\n\n\tfor (mach = machines; mach->id[0] || mach->comp_ids; mach++) {\n\t\tif (snd_soc_acpi_id_present(mach)) {\n\t\t\tif (mach->machine_quirk) {\n\t\t\t\tmach_alt = mach->machine_quirk(mach);\n\t\t\t\tif (!mach_alt)\n\t\t\t\t\tcontinue;  \n\t\t\t\tmach = mach_alt;\n\t\t\t}\n\n\t\t\treturn mach;\n\t\t}\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_acpi_find_machine);\n\nstatic acpi_status snd_soc_acpi_find_package(acpi_handle handle, u32 level,\n\t\t\t\t\t     void *context, void **ret)\n{\n\tstruct acpi_device *adev = acpi_fetch_acpi_dev(handle);\n\tacpi_status status;\n\tstruct snd_soc_acpi_package_context *pkg_ctx = context;\n\n\tpkg_ctx->data_valid = false;\n\n\tif (adev && adev->status.present && adev->status.functional) {\n\t\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\t\tunion acpi_object  *myobj = NULL;\n\n\t\tstatus = acpi_evaluate_object_typed(handle, pkg_ctx->name,\n\t\t\t\t\t\tNULL, &buffer,\n\t\t\t\t\t\tACPI_TYPE_PACKAGE);\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn AE_OK;\n\n\t\tmyobj = buffer.pointer;\n\t\tif (!myobj || myobj->package.count != pkg_ctx->length) {\n\t\t\tkfree(buffer.pointer);\n\t\t\treturn AE_OK;\n\t\t}\n\n\t\tstatus = acpi_extract_package(myobj,\n\t\t\t\t\tpkg_ctx->format, pkg_ctx->state);\n\t\tif (ACPI_FAILURE(status)) {\n\t\t\tkfree(buffer.pointer);\n\t\t\treturn AE_OK;\n\t\t}\n\n\t\tkfree(buffer.pointer);\n\t\tpkg_ctx->data_valid = true;\n\t\treturn AE_CTRL_TERMINATE;\n\t}\n\n\treturn AE_OK;\n}\n\nbool snd_soc_acpi_find_package_from_hid(const u8 hid[ACPI_ID_LEN],\n\t\t\t\tstruct snd_soc_acpi_package_context *ctx)\n{\n\tacpi_status status;\n\n\tstatus = acpi_get_devices(hid, snd_soc_acpi_find_package, ctx, NULL);\n\n\tif (ACPI_FAILURE(status) || !ctx->data_valid)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(snd_soc_acpi_find_package_from_hid);\n\nstruct snd_soc_acpi_mach *snd_soc_acpi_codec_list(void *arg)\n{\n\tstruct snd_soc_acpi_mach *mach = arg;\n\tstruct snd_soc_acpi_codecs *codec_list =\n\t\t(struct snd_soc_acpi_codecs *) mach->quirk_data;\n\tint i;\n\n\tif (mach->quirk_data == NULL)\n\t\treturn mach;\n\n\tfor (i = 0; i < codec_list->num_codecs; i++) {\n\t\tif (!acpi_dev_present(codec_list->codecs[i], NULL, -1))\n\t\t\treturn NULL;\n\t}\n\n\treturn mach;\n}\nEXPORT_SYMBOL_GPL(snd_soc_acpi_codec_list);\n\n#define SDW_CODEC_ADR_MASK(_adr) ((_adr) & (SDW_DISCO_LINK_ID_MASK | SDW_VERSION_MASK | \\\n\t\t\t\t  SDW_MFG_ID_MASK | SDW_PART_ID_MASK))\n\n \nbool snd_soc_acpi_sdw_link_slaves_found(struct device *dev,\n\t\t\t\t\tconst struct snd_soc_acpi_link_adr *link,\n\t\t\t\t\tstruct sdw_extended_slave_id *ids,\n\t\t\t\t\tint num_slaves)\n{\n\tunsigned int part_id, link_id, unique_id, mfg_id, version;\n\tint i, j, k;\n\n\tfor (i = 0; i < link->num_adr; i++) {\n\t\tu64 adr = link->adr_d[i].adr;\n\t\tint reported_part_count = 0;\n\n\t\tmfg_id = SDW_MFG_ID(adr);\n\t\tpart_id = SDW_PART_ID(adr);\n\t\tlink_id = SDW_DISCO_LINK_ID(adr);\n\t\tversion = SDW_VERSION(adr);\n\n\t\tfor (j = 0; j < num_slaves; j++) {\n\t\t\t \n\t\t\tif (ids[j].link_id == link_id &&\n\t\t\t    ids[j].id.part_id == part_id &&\n\t\t\t    ids[j].id.mfg_id == mfg_id &&\n\t\t\t    ids[j].id.sdw_version == version)\n\t\t\t\treported_part_count++;\n\t\t}\n\n\t\tfor (j = 0; j < num_slaves; j++) {\n\t\t\tint expected_part_count = 0;\n\n\t\t\tif (ids[j].link_id != link_id ||\n\t\t\t    ids[j].id.part_id != part_id ||\n\t\t\t    ids[j].id.mfg_id != mfg_id ||\n\t\t\t    ids[j].id.sdw_version != version)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tfor (k = 0; k < link->num_adr; k++) {\n\t\t\t\tu64 adr2 = link->adr_d[k].adr;\n\n\t\t\t\tif (SDW_CODEC_ADR_MASK(adr2) == SDW_CODEC_ADR_MASK(adr))\n\t\t\t\t\texpected_part_count++;\n\t\t\t}\n\n\t\t\tif (reported_part_count == expected_part_count) {\n\t\t\t\t \n\t\t\t\tunique_id = SDW_UNIQUE_ID(adr);\n\t\t\t\tif (reported_part_count == 1 ||\n\t\t\t\t    ids[j].id.unique_id == unique_id) {\n\t\t\t\t\tdev_dbg(dev, \"found part_id %#x at link %d\\n\", part_id, link_id);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(dev, \"part_id %#x reported %d expected %d on link %d, skipping\\n\",\n\t\t\t\t\tpart_id, reported_part_count, expected_part_count, link_id);\n\t\t\t}\n\t\t}\n\t\tif (j == num_slaves) {\n\t\t\tdev_dbg(dev, \"Slave part_id %#x not found\\n\", part_id);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(snd_soc_acpi_sdw_link_slaves_found);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ALSA SoC ACPI module\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}