{
  "module_name": "spdif_out.c",
  "hash_id": "a73c75c12d0506c1f37b50988930f061fd85f13aff0676778a3145590d8a6df6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/spear/spdif_out.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/soc.h>\n#include <sound/spear_dma.h>\n#include <sound/spear_spdif.h>\n#include \"spdif_out_regs.h\"\n#include \"spear_pcm.h\"\n\nstruct spdif_out_params {\n\tu32 rate;\n\tu32 core_freq;\n\tu32 mute;\n};\n\nstruct spdif_out_dev {\n\tstruct clk *clk;\n\tstruct spear_dma_data dma_params;\n\tstruct spdif_out_params saved_params;\n\tu32 running;\n\tvoid __iomem *io_base;\n\tstruct snd_dmaengine_dai_dma_data dma_params_tx;\n\tstruct snd_dmaengine_pcm_config config;\n};\n\nstatic void spdif_out_configure(struct spdif_out_dev *host)\n{\n\twritel(SPDIF_OUT_RESET, host->io_base + SPDIF_OUT_SOFT_RST);\n\tmdelay(1);\n\twritel(readl(host->io_base + SPDIF_OUT_SOFT_RST) & ~SPDIF_OUT_RESET,\n\t\t\thost->io_base + SPDIF_OUT_SOFT_RST);\n\n\twritel(SPDIF_OUT_FDMA_TRIG_16 | SPDIF_OUT_MEMFMT_16_16 |\n\t\t\tSPDIF_OUT_VALID_HW | SPDIF_OUT_USER_HW |\n\t\t\tSPDIF_OUT_CHNLSTA_HW | SPDIF_OUT_PARITY_HW,\n\t\t\thost->io_base + SPDIF_OUT_CFG);\n\n\twritel(0x7F, host->io_base + SPDIF_OUT_INT_STA_CLR);\n\twritel(0x7F, host->io_base + SPDIF_OUT_INT_EN_CLR);\n}\n\nstatic int spdif_out_startup(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -EINVAL;\n\n\tret = clk_enable(host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\thost->running = true;\n\tspdif_out_configure(host);\n\n\treturn 0;\n}\n\nstatic void spdif_out_shutdown(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn;\n\n\tclk_disable(host->clk);\n\thost->running = false;\n}\n\nstatic void spdif_out_clock(struct spdif_out_dev *host, u32 core_freq,\n\t\tu32 rate)\n{\n\tu32 divider, ctrl;\n\n\tclk_set_rate(host->clk, core_freq);\n\tdivider = DIV_ROUND_CLOSEST(clk_get_rate(host->clk), (rate * 128));\n\n\tctrl = readl(host->io_base + SPDIF_OUT_CTRL);\n\tctrl &= ~SPDIF_DIVIDER_MASK;\n\tctrl |= (divider << SPDIF_DIVIDER_SHIFT) & SPDIF_DIVIDER_MASK;\n\twritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\n}\n\nstatic int spdif_out_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\n\tu32 rate, core_freq;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -EINVAL;\n\n\trate = params_rate(params);\n\n\tswitch (rate) {\n\tcase 8000:\n\tcase 16000:\n\tcase 32000:\n\tcase 64000:\n\t\t \n\t\tcore_freq = 64000 * 128 * 10;\t \n\t\tbreak;\n\tcase 5512:\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\tcase 176400:\n\t\tcore_freq = 176400 * 128;\t \n\t\tbreak;\n\tcase 48000:\n\tcase 96000:\n\tcase 192000:\n\tdefault:\n\t\tcore_freq = 192000 * 128;\t \n\t\tbreak;\n\t}\n\n\tspdif_out_clock(host, core_freq, rate);\n\thost->saved_params.core_freq = core_freq;\n\thost->saved_params.rate = rate;\n\n\treturn 0;\n}\n\nstatic int spdif_out_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\n\tu32 ctrl;\n\tint ret = 0;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t\tctrl = readl(host->io_base + SPDIF_OUT_CTRL);\n\t\t\tctrl &= ~SPDIF_OPMODE_MASK;\n\t\t\tif (!host->saved_params.mute)\n\t\t\t\tctrl |= SPDIF_OPMODE_AUD_DATA |\n\t\t\t\t\tSPDIF_STATE_NORMAL;\n\t\t\telse\n\t\t\t\tctrl |= SPDIF_OPMODE_MUTE_PCM;\n\t\t\twritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tctrl = readl(host->io_base + SPDIF_OUT_CTRL);\n\t\tctrl &= ~SPDIF_OPMODE_MASK;\n\t\tctrl |= SPDIF_OPMODE_OFF;\n\t\twritel(ctrl, host->io_base + SPDIF_OUT_CTRL);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int spdif_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\n\tu32 val;\n\n\thost->saved_params.mute = mute;\n\tval = readl(host->io_base + SPDIF_OUT_CTRL);\n\tval &= ~SPDIF_OPMODE_MASK;\n\n\tif (mute)\n\t\tval |= SPDIF_OPMODE_MUTE_PCM;\n\telse {\n\t\tif (host->running)\n\t\t\tval |= SPDIF_OPMODE_AUD_DATA | SPDIF_STATE_NORMAL;\n\t\telse\n\t\t\tval |= SPDIF_OPMODE_OFF;\n\t}\n\n\twritel(val, host->io_base + SPDIF_OUT_CTRL);\n\treturn 0;\n}\n\nstatic int spdif_mute_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tucontrol->value.integer.value[0] = host->saved_params.mute;\n\treturn 0;\n}\n\nstatic int spdif_mute_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (host->saved_params.mute == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tspdif_mute(cpu_dai, ucontrol->value.integer.value[0],\n\t\t   SNDRV_PCM_STREAM_PLAYBACK);\n\n\treturn 1;\n}\nstatic const struct snd_kcontrol_new spdif_out_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"IEC958 Playback Switch\", 0,\n\t\t\tspdif_mute_get, spdif_mute_put),\n};\n\nstatic int spdif_soc_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct spdif_out_dev *host = snd_soc_dai_get_drvdata(dai);\n\n\thost->dma_params_tx.filter_data = &host->dma_params;\n\n\tsnd_soc_dai_dma_data_set_playback(dai, &host->dma_params_tx);\n\n\treturn snd_soc_add_dai_controls(dai, spdif_out_controls,\n\t\t\t\tARRAY_SIZE(spdif_out_controls));\n}\n\nstatic const struct snd_soc_dai_ops spdif_out_dai_ops = {\n\t.mute_stream\t= spdif_mute,\n\t.startup\t= spdif_out_startup,\n\t.shutdown\t= spdif_out_shutdown,\n\t.trigger\t= spdif_out_trigger,\n\t.hw_params\t= spdif_out_hw_params,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver spdif_out_dai = {\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \\\n\t\t\t\t SNDRV_PCM_RATE_192000),\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.probe = spdif_soc_dai_probe,\n\t.ops = &spdif_out_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver spdif_out_component = {\n\t.name\t\t\t= \"spdif-out\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int spdif_out_probe(struct platform_device *pdev)\n{\n\tstruct spdif_out_dev *host;\n\tstruct spear_spdif_platform_data *pdata;\n\tstruct resource *res;\n\tint ret;\n\n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->io_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->io_base))\n\t\treturn PTR_ERR(host->io_base);\n\n\thost->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk))\n\t\treturn PTR_ERR(host->clk);\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\n\thost->dma_params.data = pdata->dma_params;\n\thost->dma_params.addr = res->start + SPDIF_OUT_FIFO_DATA;\n\thost->dma_params.max_burst = 16;\n\thost->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tdev_set_drvdata(&pdev->dev, host);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &spdif_out_component,\n\t\t\t\t\t      &spdif_out_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_spear_pcm_platform_register(&pdev->dev, &host->config,\n\t\t\t\t\t\tpdata->filter);\n}\n\n#ifdef CONFIG_PM\nstatic int spdif_out_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);\n\n\tif (host->running)\n\t\tclk_disable(host->clk);\n\n\treturn 0;\n}\n\nstatic int spdif_out_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct spdif_out_dev *host = dev_get_drvdata(&pdev->dev);\n\n\tif (host->running) {\n\t\tclk_enable(host->clk);\n\t\tspdif_out_configure(host);\n\t\tspdif_out_clock(host, host->saved_params.core_freq,\n\t\t\t\thost->saved_params.rate);\n\t}\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(spdif_out_dev_pm_ops, spdif_out_suspend, \\\n\t\tspdif_out_resume);\n\n#define SPDIF_OUT_DEV_PM_OPS (&spdif_out_dev_pm_ops)\n\n#else\n#define SPDIF_OUT_DEV_PM_OPS NULL\n\n#endif\n\nstatic struct platform_driver spdif_out_driver = {\n\t.probe\t\t= spdif_out_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"spdif-out\",\n\t\t.pm\t= SPDIF_OUT_DEV_PM_OPS,\n\t},\n};\n\nmodule_platform_driver(spdif_out_driver);\n\nMODULE_AUTHOR(\"Vipin Kumar <vipin.kumar@st.com>\");\nMODULE_DESCRIPTION(\"SPEAr SPDIF OUT SoC Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:spdif_out\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}