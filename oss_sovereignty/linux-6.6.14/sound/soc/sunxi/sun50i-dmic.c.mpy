{
  "module_name": "sun50i-dmic.c",
  "hash_id": "83f189c60b4e213a02788f5fcbf86b40c845362cc146901f1fe69227d23ade47",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sunxi/sun50i-dmic.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/of_device.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#define SUN50I_DMIC_EN_CTL\t\t\t(0x00)\n\t#define SUN50I_DMIC_EN_CTL_GLOBE\t\t\tBIT(8)\n\t#define SUN50I_DMIC_EN_CTL_CHAN(v)\t\t\t((v) << 0)\n\t#define SUN50I_DMIC_EN_CTL_CHAN_MASK\t\t\tGENMASK(7, 0)\n#define SUN50I_DMIC_SR\t\t\t\t(0x04)\n\t#define SUN50I_DMIC_SR_SAMPLE_RATE(v)\t\t\t((v) << 0)\n\t#define SUN50I_DMIC_SR_SAMPLE_RATE_MASK\t\t\tGENMASK(2, 0)\n#define SUN50I_DMIC_CTL\t\t\t\t(0x08)\n\t#define SUN50I_DMIC_CTL_OVERSAMPLE_RATE\t\t\tBIT(0)\n#define SUN50I_DMIC_DATA\t\t\t(0x10)\n#define SUN50I_DMIC_INTC\t\t\t(0x14)\n\t#define SUN50I_DMIC_FIFO_DRQ_EN\t\t\t\tBIT(2)\n#define SUN50I_DMIC_INT_STA\t\t\t(0x18)\n\t#define SUN50I_DMIC_INT_STA_OVERRUN_IRQ_PENDING\t\tBIT(1)\n\t#define SUN50I_DMIC_INT_STA_DATA_IRQ_PENDING\t\tBIT(0)\n#define SUN50I_DMIC_RXFIFO_CTL\t\t\t(0x1c)\n\t#define SUN50I_DMIC_RXFIFO_CTL_FLUSH\t\t\tBIT(31)\n\t#define SUN50I_DMIC_RXFIFO_CTL_MODE_MASK\t\tBIT(9)\n\t#define SUN50I_DMIC_RXFIFO_CTL_MODE_LSB\t\t\t(0 << 9)\n\t#define SUN50I_DMIC_RXFIFO_CTL_MODE_MSB\t\t\t(1 << 9)\n\t#define SUN50I_DMIC_RXFIFO_CTL_SAMPLE_MASK\t\tBIT(8)\n\t#define SUN50I_DMIC_RXFIFO_CTL_SAMPLE_16\t\t(0 << 8)\n\t#define SUN50I_DMIC_RXFIFO_CTL_SAMPLE_24\t\t(1 << 8)\n#define SUN50I_DMIC_CH_NUM\t\t\t(0x24)\n\t#define SUN50I_DMIC_CH_NUM_N(v)\t\t\t\t((v) << 0)\n\t#define SUN50I_DMIC_CH_NUM_N_MASK\t\t\tGENMASK(2, 0)\n#define SUN50I_DMIC_CNT\t\t\t\t(0x2c)\n\t#define SUN50I_DMIC_CNT_N\t\t\t\t(1 << 0)\n#define SUN50I_DMIC_HPF_CTRL\t\t\t(0x38)\n#define SUN50I_DMIC_VERSION\t\t\t(0x50)\n\nstruct sun50i_dmic_dev {\n\tstruct clk *dmic_clk;\n\tstruct clk *bus_clk;\n\tstruct reset_control *rst;\n\tstruct regmap *regmap;\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n};\n\nstruct dmic_rate {\n\tunsigned int samplerate;\n\tunsigned int rate_bit;\n};\n\nstatic const struct dmic_rate dmic_rate_s[] = {\n\t{48000, 0x0},\n\t{44100, 0x0},\n\t{32000, 0x1},\n\t{24000, 0x2},\n\t{22050, 0x2},\n\t{16000, 0x3},\n\t{12000, 0x4},\n\t{11025, 0x4},\n\t{8000,  0x5},\n};\n\nstatic int sun50i_dmic_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct sun50i_dmic_dev *host = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\t \n\tif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(host->regmap, SUN50I_DMIC_RXFIFO_CTL,\n\t\t\tSUN50I_DMIC_RXFIFO_CTL_FLUSH,\n\t\t\tSUN50I_DMIC_RXFIFO_CTL_FLUSH);\n\tregmap_write(host->regmap, SUN50I_DMIC_CNT, SUN50I_DMIC_CNT_N);\n\n\treturn 0;\n}\n\nstatic int sun50i_dmic_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tint i = 0;\n\tunsigned long rate = params_rate(params);\n\tunsigned int mclk = 0;\n\tunsigned int channels = params_channels(params);\n\tunsigned int chan_en = (1 << channels) - 1;\n\tstruct sun50i_dmic_dev *host = snd_soc_dai_get_drvdata(cpu_dai);\n\n\t \n\tregmap_update_bits(host->regmap, SUN50I_DMIC_CH_NUM,\n\t\t\t   SUN50I_DMIC_CH_NUM_N_MASK,\n\t\t\t   SUN50I_DMIC_CH_NUM_N(channels - 1));\n\tregmap_write(host->regmap, SUN50I_DMIC_HPF_CTRL, chan_en);\n\tregmap_update_bits(host->regmap, SUN50I_DMIC_EN_CTL,\n\t\t\t   SUN50I_DMIC_EN_CTL_CHAN_MASK,\n\t\t\t   SUN50I_DMIC_EN_CTL_CHAN(chan_en));\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_RXFIFO_CTL,\n\t\t\t\t   SUN50I_DMIC_RXFIFO_CTL_SAMPLE_MASK,\n\t\t\t\t   SUN50I_DMIC_RXFIFO_CTL_SAMPLE_16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_RXFIFO_CTL,\n\t\t\t\t   SUN50I_DMIC_RXFIFO_CTL_SAMPLE_MASK,\n\t\t\t\t   SUN50I_DMIC_RXFIFO_CTL_SAMPLE_24);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Invalid format!\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tregmap_update_bits(host->regmap, SUN50I_DMIC_RXFIFO_CTL,\n\t\t\t   SUN50I_DMIC_RXFIFO_CTL_MODE_MASK,\n\t\t\t   SUN50I_DMIC_RXFIFO_CTL_MODE_MSB);\n\n\tswitch (rate) {\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\t\tmclk = 22579200;\n\t\tbreak;\n\tcase 8000:\n\tcase 12000:\n\tcase 16000:\n\tcase 24000:\n\tcase 32000:\n\tcase 48000:\n\t\tmclk = 24576000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Invalid rate!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_set_rate(host->dmic_clk, mclk)) {\n\t\tdev_err(cpu_dai->dev, \"mclk : %u not support\\n\", mclk);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dmic_rate_s); i++) {\n\t\tif (dmic_rate_s[i].samplerate == rate) {\n\t\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_SR,\n\t\t\t\t\t   SUN50I_DMIC_SR_SAMPLE_RATE_MASK,\n\t\t\t\t\t   SUN50I_DMIC_SR_SAMPLE_RATE(dmic_rate_s[i].rate_bit));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (params_physical_width(params)) {\n\tcase 16:\n\t\thost->dma_params_rx.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\tcase 32:\n\t\thost->dma_params_rx.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported physical sample width: %d\\n\",\n\t\t\tparams_physical_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (params_rate(params) >= 24000)\n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_CTL,\n\t\t\t\t   SUN50I_DMIC_CTL_OVERSAMPLE_RATE,\n\t\t\t\t   SUN50I_DMIC_CTL_OVERSAMPLE_RATE);\n\telse\n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_CTL,\n\t\t\t\t   SUN50I_DMIC_CTL_OVERSAMPLE_RATE, 0);\n\n\treturn 0;\n}\n\nstatic int sun50i_dmic_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\tstruct sun50i_dmic_dev *host = snd_soc_dai_get_drvdata(dai);\n\n\tif (substream->stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_INTC,\n\t\t\t\t   SUN50I_DMIC_FIFO_DRQ_EN,\n\t\t\t\t   SUN50I_DMIC_FIFO_DRQ_EN);\n\t\t \n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_EN_CTL,\n\t\t\t\t   SUN50I_DMIC_EN_CTL_GLOBE,\n\t\t\t\t   SUN50I_DMIC_EN_CTL_GLOBE);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_INTC,\n\t\t\t\t   SUN50I_DMIC_FIFO_DRQ_EN, 0);\n\t\t \n\t\tregmap_update_bits(host->regmap, SUN50I_DMIC_EN_CTL,\n\t\t\t\t   SUN50I_DMIC_EN_CTL_GLOBE, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int sun50i_dmic_soc_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct sun50i_dmic_dev *host = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, NULL, &host->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sun50i_dmic_dai_ops = {\n\t.probe\t\t= sun50i_dmic_soc_dai_probe,\n\t.startup        = sun50i_dmic_startup,\n\t.trigger        = sun50i_dmic_trigger,\n\t.hw_params      = sun50i_dmic_hw_params,\n};\n\nstatic const struct regmap_config sun50i_dmic_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = SUN50I_DMIC_VERSION,\n\t.cache_type = REGCACHE_NONE,\n};\n\n#define SUN50I_DMIC_RATES (SNDRV_PCM_RATE_8000_48000)\n#define SUN50I_DMIC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver sun50i_dmic_dai = {\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SUN50I_DMIC_RATES,\n\t\t.formats = SUN50I_DMIC_FORMATS,\n\t\t.sig_bits = 21,\n\t},\n\t.ops = &sun50i_dmic_dai_ops,\n\t.name = \"dmic\",\n};\n\nstatic const struct of_device_id sun50i_dmic_of_match[] = {\n\t{\n\t\t.compatible = \"allwinner,sun50i-h6-dmic\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sun50i_dmic_of_match);\n\nstatic const struct snd_soc_component_driver sun50i_dmic_component = {\n\t.name           = \"sun50i-dmic\",\n};\n\nstatic int sun50i_dmic_runtime_suspend(struct device *dev)\n{\n\tstruct sun50i_dmic_dev *host  = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(host->dmic_clk);\n\tclk_disable_unprepare(host->bus_clk);\n\n\treturn 0;\n}\n\nstatic int sun50i_dmic_runtime_resume(struct device *dev)\n{\n\tstruct sun50i_dmic_dev *host  = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(host->dmic_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(host->bus_clk);\n\tif (ret) {\n\t\tclk_disable_unprepare(host->dmic_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sun50i_dmic_probe(struct platform_device *pdev)\n{\n\tstruct sun50i_dmic_dev *host;\n\tstruct resource *res;\n\tint ret;\n\tvoid __iomem *base;\n\n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\t \n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(base),\n\t\t\t\t     \"get resource failed.\\n\");\n\n\thost->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t     &sun50i_dmic_regmap_config);\n\n\t \n\thost->bus_clk = devm_clk_get(&pdev->dev, \"bus\");\n\tif (IS_ERR(host->bus_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(host->bus_clk),\n\t\t\t\t     \"failed to get bus clock.\\n\");\n\n\thost->dmic_clk = devm_clk_get(&pdev->dev, \"mod\");\n\tif (IS_ERR(host->dmic_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(host->dmic_clk),\n\t\t\t\t     \"failed to get dmic clock.\\n\");\n\n\thost->dma_params_rx.addr = res->start + SUN50I_DMIC_DATA;\n\thost->dma_params_rx.maxburst = 8;\n\n\tplatform_set_drvdata(pdev, host);\n\n\thost->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(host->rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(host->rst),\n\t\t\t\t     \"Failed to get reset.\\n\");\n\treset_control_deassert(host->rst);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &sun50i_dmic_component,\n\t\t\t\t\t      &sun50i_dmic_dai, 1);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret,\n\t\t\t\t     \"failed to register component.\\n\");\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = sun50i_dmic_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_disable_runtime_pm;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret)\n\t\tgoto err_suspend;\n\n\treturn 0;\nerr_suspend:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tsun50i_dmic_runtime_suspend(&pdev->dev);\nerr_disable_runtime_pm:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void sun50i_dmic_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tsun50i_dmic_runtime_suspend(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops sun50i_dmic_pm = {\n\tSET_RUNTIME_PM_OPS(sun50i_dmic_runtime_suspend,\n\t\t\t   sun50i_dmic_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sun50i_dmic_driver = {\n\t.driver         = {\n\t\t.name   = \"sun50i-dmic\",\n\t\t.of_match_table = sun50i_dmic_of_match,\n\t\t.pm     = &sun50i_dmic_pm,\n\t},\n\t.probe          = sun50i_dmic_probe,\n\t.remove_new     = sun50i_dmic_remove,\n};\n\nmodule_platform_driver(sun50i_dmic_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sun50i DMIC SoC Interface\");\nMODULE_AUTHOR(\"Ban Tao <fengzheng923@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sun50i-dmic\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}