{
  "module_name": "soc-generic-dmaengine-pcm.c",
  "hash_id": "03f0dd7ae9b4221b7a562d5f17e891aca79834f47a4e04b635fdceef3063ec3b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-generic-dmaengine-pcm.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/dmaengine.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n\n#include <sound/dmaengine_pcm.h>\n\nstatic unsigned int prealloc_buffer_size_kbytes = 512;\nmodule_param(prealloc_buffer_size_kbytes, uint, 0444);\nMODULE_PARM_DESC(prealloc_buffer_size_kbytes, \"Preallocate DMA buffer size (KB).\");\n\n \n#define SND_DMAENGINE_PCM_FLAG_NO_RESIDUE BIT(31)\n\nstatic struct device *dmaengine_dma_dev(struct dmaengine_pcm *pcm,\n\tstruct snd_pcm_substream *substream)\n{\n\tif (!pcm->chan[substream->stream])\n\t\treturn NULL;\n\n\treturn pcm->chan[substream->stream]->device->dev;\n}\n\n \nint snd_dmaengine_pcm_prepare_slave_config(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct dma_slave_config *slave_config)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tint ret;\n\n\tif (rtd->dai_link->num_cpus > 1) {\n\t\tdev_err(rtd->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\tret = snd_hwparams_to_dma_slave_config(substream, params, slave_config);\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_dmaengine_pcm_set_config_from_dai_data(substream, dma_data,\n\t\tslave_config);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_prepare_slave_config);\n\nstatic int dmaengine_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tstruct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);\n\tstruct dma_slave_config slave_config;\n\tint ret;\n\n\tif (!pcm->config->prepare_slave_config)\n\t\treturn 0;\n\n\tmemset(&slave_config, 0, sizeof(slave_config));\n\n\tret = pcm->config->prepare_slave_config(substream, params, &slave_config);\n\tif (ret)\n\t\treturn ret;\n\n\treturn dmaengine_slave_config(chan, &slave_config);\n}\n\nstatic int\ndmaengine_pcm_set_runtime_hwparams(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tstruct device *dma_dev = dmaengine_dma_dev(pcm, substream);\n\tstruct dma_chan *chan = pcm->chan[substream->stream];\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tstruct snd_pcm_hardware hw;\n\n\tif (rtd->dai_link->num_cpus > 1) {\n\t\tdev_err(rtd->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcm->config->pcm_hardware)\n\t\treturn snd_soc_set_runtime_hwparams(substream,\n\t\t\t\tpcm->config->pcm_hardware);\n\n\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\tmemset(&hw, 0, sizeof(hw));\n\thw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED;\n\thw.periods_min = 2;\n\thw.periods_max = UINT_MAX;\n\thw.period_bytes_min = dma_data->maxburst * DMA_SLAVE_BUSWIDTH_8_BYTES;\n\tif (!hw.period_bytes_min)\n\t\thw.period_bytes_min = 256;\n\thw.period_bytes_max = dma_get_max_seg_size(dma_dev);\n\thw.buffer_bytes_max = SIZE_MAX;\n\thw.fifo_size = dma_data->fifo_size;\n\n\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)\n\t\thw.info |= SNDRV_PCM_INFO_BATCH;\n\n\t \n\tsnd_dmaengine_pcm_refine_runtime_hwparams(substream,\n\t\t\t\t\t\t  dma_data,\n\t\t\t\t\t\t  &hw,\n\t\t\t\t\t\t  chan);\n\n\treturn snd_soc_set_runtime_hwparams(substream, &hw);\n}\n\nstatic int dmaengine_pcm_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tstruct dma_chan *chan = pcm->chan[substream->stream];\n\tint ret;\n\n\tret = dmaengine_pcm_set_runtime_hwparams(component, substream);\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_dmaengine_pcm_open(substream, chan);\n}\n\nstatic int dmaengine_pcm_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\treturn snd_dmaengine_pcm_close(substream);\n}\n\nstatic int dmaengine_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream, int cmd)\n{\n\treturn snd_dmaengine_pcm_trigger(substream, cmd);\n}\n\nstatic struct dma_chan *dmaengine_pcm_compat_request_channel(\n\tstruct snd_soc_component *component,\n\tstruct snd_soc_pcm_runtime *rtd,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\n\tif (rtd->dai_link->num_cpus > 1) {\n\t\tdev_err(rtd->dev,\n\t\t\t\"%s doesn't support Multi CPU yet\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\tif ((pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX) && pcm->chan[0])\n\t\treturn pcm->chan[0];\n\n\tif (pcm->config->compat_request_channel)\n\t\treturn pcm->config->compat_request_channel(rtd, substream);\n\n\treturn snd_dmaengine_pcm_request_channel(pcm->config->compat_filter_fn,\n\t\t\t\t\t\t dma_data->filter_data);\n}\n\nstatic bool dmaengine_pcm_can_report_residue(struct device *dev,\n\tstruct dma_chan *chan)\n{\n\tstruct dma_slave_caps dma_caps;\n\tint ret;\n\n\tret = dma_get_slave_caps(chan, &dma_caps);\n\tif (ret != 0) {\n\t\tdev_warn(dev, \"Failed to get DMA channel capabilities, falling back to period counting: %d\\n\",\n\t\t\t ret);\n\t\treturn false;\n\t}\n\n\tif (dma_caps.residue_granularity == DMA_RESIDUE_GRANULARITY_DESCRIPTOR)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int dmaengine_pcm_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tconst struct snd_dmaengine_pcm_config *config = pcm->config;\n\tstruct device *dev = component->dev;\n\tsize_t prealloc_buffer_size;\n\tsize_t max_buffer_size;\n\tunsigned int i;\n\n\tif (config->prealloc_buffer_size)\n\t\tprealloc_buffer_size = config->prealloc_buffer_size;\n\telse\n\t\tprealloc_buffer_size = prealloc_buffer_size_kbytes * 1024;\n\n\tif (config->pcm_hardware && config->pcm_hardware->buffer_bytes_max)\n\t\tmax_buffer_size = config->pcm_hardware->buffer_bytes_max;\n\telse\n\t\tmax_buffer_size = SIZE_MAX;\n\n\tfor_each_pcm_streams(i) {\n\t\tstruct snd_pcm_substream *substream = rtd->pcm->streams[i].substream;\n\t\tif (!substream)\n\t\t\tcontinue;\n\n\t\tif (!pcm->chan[i] && config->chan_names[i])\n\t\t\tpcm->chan[i] = dma_request_slave_channel(dev,\n\t\t\t\tconfig->chan_names[i]);\n\n\t\tif (!pcm->chan[i] && (pcm->flags & SND_DMAENGINE_PCM_FLAG_COMPAT)) {\n\t\t\tpcm->chan[i] = dmaengine_pcm_compat_request_channel(\n\t\t\t\tcomponent, rtd, substream);\n\t\t}\n\n\t\tif (!pcm->chan[i]) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Missing dma channel for stream: %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_pcm_set_managed_buffer(substream,\n\t\t\t\tSNDRV_DMA_TYPE_DEV_IRAM,\n\t\t\t\tdmaengine_dma_dev(pcm, substream),\n\t\t\t\tprealloc_buffer_size,\n\t\t\t\tmax_buffer_size);\n\n\t\tif (!dmaengine_pcm_can_report_residue(dev, pcm->chan[i]))\n\t\t\tpcm->flags |= SND_DMAENGINE_PCM_FLAG_NO_RESIDUE;\n\n\t\tif (rtd->pcm->streams[i].pcm->name[0] == '\\0') {\n\t\t\tstrscpy_pad(rtd->pcm->streams[i].pcm->name,\n\t\t\t\t    rtd->pcm->streams[i].pcm->id,\n\t\t\t\t    sizeof(rtd->pcm->streams[i].pcm->name));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t dmaengine_pcm_pointer(\n\tstruct snd_soc_component *component,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\n\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_RESIDUE)\n\t\treturn snd_dmaengine_pcm_pointer_no_residue(substream);\n\telse\n\t\treturn snd_dmaengine_pcm_pointer(substream);\n}\n\nstatic int dmaengine_copy(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  int channel, unsigned long hwoff,\n\t\t\t  struct iov_iter *iter, unsigned long bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dmaengine_pcm *pcm = soc_component_to_pcm(component);\n\tint (*process)(struct snd_pcm_substream *substream,\n\t\t       int channel, unsigned long hwoff,\n\t\t       unsigned long bytes) = pcm->config->process;\n\tbool is_playback = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tvoid *dma_ptr = runtime->dma_area + hwoff +\n\t\t\tchannel * (runtime->dma_bytes / runtime->channels);\n\n\tif (is_playback)\n\t\tif (copy_from_iter(dma_ptr, bytes, iter) != bytes)\n\t\t\treturn -EFAULT;\n\n\tif (process) {\n\t\tint ret = process(substream, channel, hwoff, bytes);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!is_playback)\n\t\tif (copy_to_iter(dma_ptr, bytes, iter) != bytes)\n\t\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver dmaengine_pcm_component = {\n\t.name\t\t= SND_DMAENGINE_PCM_DRV_NAME,\n\t.probe_order\t= SND_SOC_COMP_ORDER_LATE,\n\t.open\t\t= dmaengine_pcm_open,\n\t.close\t\t= dmaengine_pcm_close,\n\t.hw_params\t= dmaengine_pcm_hw_params,\n\t.trigger\t= dmaengine_pcm_trigger,\n\t.pointer\t= dmaengine_pcm_pointer,\n\t.pcm_construct\t= dmaengine_pcm_new,\n};\n\nstatic const struct snd_soc_component_driver dmaengine_pcm_component_process = {\n\t.name\t\t= SND_DMAENGINE_PCM_DRV_NAME,\n\t.probe_order\t= SND_SOC_COMP_ORDER_LATE,\n\t.open\t\t= dmaengine_pcm_open,\n\t.close\t\t= dmaengine_pcm_close,\n\t.hw_params\t= dmaengine_pcm_hw_params,\n\t.trigger\t= dmaengine_pcm_trigger,\n\t.pointer\t= dmaengine_pcm_pointer,\n\t.copy\t\t= dmaengine_copy,\n\t.pcm_construct\t= dmaengine_pcm_new,\n};\n\nstatic const char * const dmaengine_pcm_dma_channel_names[] = {\n\t[SNDRV_PCM_STREAM_PLAYBACK] = \"tx\",\n\t[SNDRV_PCM_STREAM_CAPTURE] = \"rx\",\n};\n\nstatic int dmaengine_pcm_request_chan_of(struct dmaengine_pcm *pcm,\n\tstruct device *dev, const struct snd_dmaengine_pcm_config *config)\n{\n\tunsigned int i;\n\tconst char *name;\n\tstruct dma_chan *chan;\n\n\tif ((pcm->flags & SND_DMAENGINE_PCM_FLAG_NO_DT) || (!dev->of_node &&\n\t    !(config->dma_dev && config->dma_dev->of_node)))\n\t\treturn 0;\n\n\tif (config->dma_dev) {\n\t\t \n\t\tdev_warn(dev, \"DMA channels sourced from device %s\",\n\t\t\t dev_name(config->dma_dev));\n\t\tdev = config->dma_dev;\n\t}\n\n\tfor_each_pcm_streams(i) {\n\t\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\n\t\t\tname = \"rx-tx\";\n\t\telse\n\t\t\tname = dmaengine_pcm_dma_channel_names[i];\n\t\tif (config->chan_names[i])\n\t\t\tname = config->chan_names[i];\n\t\tchan = dma_request_chan(dev, name);\n\t\tif (IS_ERR(chan)) {\n\t\t\t \n\t\t\tif (PTR_ERR(chan) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tpcm->chan[i] = NULL;\n\t\t} else {\n\t\t\tpcm->chan[i] = chan;\n\t\t}\n\t\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\n\t\t\tbreak;\n\t}\n\n\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\n\t\tpcm->chan[1] = pcm->chan[0];\n\n\treturn 0;\n}\n\nstatic void dmaengine_pcm_release_chan(struct dmaengine_pcm *pcm)\n{\n\tunsigned int i;\n\n\tfor_each_pcm_streams(i) {\n\t\tif (!pcm->chan[i])\n\t\t\tcontinue;\n\t\tdma_release_channel(pcm->chan[i]);\n\t\tif (pcm->flags & SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX)\n\t\t\tbreak;\n\t}\n}\n\nstatic const struct snd_dmaengine_pcm_config snd_dmaengine_pcm_default_config = {\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\n \nint snd_dmaengine_pcm_register(struct device *dev,\n\tconst struct snd_dmaengine_pcm_config *config, unsigned int flags)\n{\n\tconst struct snd_soc_component_driver *driver;\n\tstruct dmaengine_pcm *pcm;\n\tint ret;\n\n\tpcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_DEBUG_FS\n\tpcm->component.debugfs_prefix = \"dma\";\n#endif\n\tif (!config)\n\t\tconfig = &snd_dmaengine_pcm_default_config;\n\tpcm->config = config;\n\tpcm->flags = flags;\n\n\tret = dmaengine_pcm_request_chan_of(pcm, dev, config);\n\tif (ret)\n\t\tgoto err_free_dma;\n\n\tif (config->process)\n\t\tdriver = &dmaengine_pcm_component_process;\n\telse\n\t\tdriver = &dmaengine_pcm_component;\n\n\tret = snd_soc_component_initialize(&pcm->component, driver, dev);\n\tif (ret)\n\t\tgoto err_free_dma;\n\n\tret = snd_soc_add_component(&pcm->component, NULL, 0);\n\tif (ret)\n\t\tgoto err_free_dma;\n\n\treturn 0;\n\nerr_free_dma:\n\tdmaengine_pcm_release_chan(pcm);\n\tkfree(pcm);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_register);\n\n \nvoid snd_dmaengine_pcm_unregister(struct device *dev)\n{\n\tstruct snd_soc_component *component;\n\tstruct dmaengine_pcm *pcm;\n\n\tcomponent = snd_soc_lookup_component(dev, SND_DMAENGINE_PCM_DRV_NAME);\n\tif (!component)\n\t\treturn;\n\n\tpcm = soc_component_to_pcm(component);\n\n\tsnd_soc_unregister_component_by_driver(dev, component->driver);\n\tdmaengine_pcm_release_chan(pcm);\n\tkfree(pcm);\n}\nEXPORT_SYMBOL_GPL(snd_dmaengine_pcm_unregister);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}