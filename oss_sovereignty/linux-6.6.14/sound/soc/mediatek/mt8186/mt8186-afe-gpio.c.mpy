{
  "module_name": "mt8186-afe-gpio.c",
  "hash_id": "aa7427f73f48c0958d029fdc704727ab98f4b1f8cc1af430e3825b8903249162",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8186/mt8186-afe-gpio.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/gpio.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"mt8186-afe-common.h\"\n#include \"mt8186-afe-gpio.h\"\n\nstatic struct pinctrl *aud_pinctrl;\n\nenum mt8186_afe_gpio {\n\tMT8186_AFE_GPIO_CLK_MOSI_OFF,\n\tMT8186_AFE_GPIO_CLK_MOSI_ON,\n\tMT8186_AFE_GPIO_CLK_MISO_OFF,\n\tMT8186_AFE_GPIO_CLK_MISO_ON,\n\tMT8186_AFE_GPIO_DAT_MISO_OFF,\n\tMT8186_AFE_GPIO_DAT_MISO_ON,\n\tMT8186_AFE_GPIO_DAT_MOSI_OFF,\n\tMT8186_AFE_GPIO_DAT_MOSI_ON,\n\tMT8186_AFE_GPIO_I2S0_OFF,\n\tMT8186_AFE_GPIO_I2S0_ON,\n\tMT8186_AFE_GPIO_I2S1_OFF,\n\tMT8186_AFE_GPIO_I2S1_ON,\n\tMT8186_AFE_GPIO_I2S2_OFF,\n\tMT8186_AFE_GPIO_I2S2_ON,\n\tMT8186_AFE_GPIO_I2S3_OFF,\n\tMT8186_AFE_GPIO_I2S3_ON,\n\tMT8186_AFE_GPIO_TDM_OFF,\n\tMT8186_AFE_GPIO_TDM_ON,\n\tMT8186_AFE_GPIO_PCM_OFF,\n\tMT8186_AFE_GPIO_PCM_ON,\n\tMT8186_AFE_GPIO_GPIO_NUM\n};\n\nstruct audio_gpio_attr {\n\tconst char *name;\n\tbool gpio_prepare;\n\tstruct pinctrl_state *gpioctrl;\n};\n\nstatic struct audio_gpio_attr aud_gpios[MT8186_AFE_GPIO_GPIO_NUM] = {\n\t[MT8186_AFE_GPIO_CLK_MOSI_OFF] = {\"aud_clk_mosi_off\", false, NULL},\n\t[MT8186_AFE_GPIO_CLK_MOSI_ON] = {\"aud_clk_mosi_on\", false, NULL},\n\t[MT8186_AFE_GPIO_CLK_MISO_OFF] = {\"aud_clk_miso_off\", false, NULL},\n\t[MT8186_AFE_GPIO_CLK_MISO_ON] = {\"aud_clk_miso_on\", false, NULL},\n\t[MT8186_AFE_GPIO_DAT_MISO_OFF] = {\"aud_dat_miso_off\", false, NULL},\n\t[MT8186_AFE_GPIO_DAT_MISO_ON] = {\"aud_dat_miso_on\", false, NULL},\n\t[MT8186_AFE_GPIO_DAT_MOSI_OFF] = {\"aud_dat_mosi_off\", false, NULL},\n\t[MT8186_AFE_GPIO_DAT_MOSI_ON] = {\"aud_dat_mosi_on\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S0_OFF] = {\"aud_gpio_i2s0_off\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S0_ON] = {\"aud_gpio_i2s0_on\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S1_OFF] = {\"aud_gpio_i2s1_off\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S1_ON] = {\"aud_gpio_i2s1_on\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S2_OFF] = {\"aud_gpio_i2s2_off\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S2_ON] = {\"aud_gpio_i2s2_on\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S3_OFF] = {\"aud_gpio_i2s3_off\", false, NULL},\n\t[MT8186_AFE_GPIO_I2S3_ON] = {\"aud_gpio_i2s3_on\", false, NULL},\n\t[MT8186_AFE_GPIO_TDM_OFF] = {\"aud_gpio_tdm_off\", false, NULL},\n\t[MT8186_AFE_GPIO_TDM_ON] = {\"aud_gpio_tdm_on\", false, NULL},\n\t[MT8186_AFE_GPIO_PCM_OFF] = {\"aud_gpio_pcm_off\", false, NULL},\n\t[MT8186_AFE_GPIO_PCM_ON] = {\"aud_gpio_pcm_on\", false, NULL},\n};\n\nstatic DEFINE_MUTEX(gpio_request_mutex);\n\nint mt8186_afe_gpio_init(struct device *dev)\n{\n\tint i, j, ret;\n\n\taud_pinctrl = devm_pinctrl_get(dev);\n\tif (IS_ERR(aud_pinctrl)) {\n\t\tret = PTR_ERR(aud_pinctrl);\n\t\tdev_err(dev, \"%s(), ret %d, cannot get aud_pinctrl!\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(aud_gpios); i++) {\n\t\taud_gpios[i].gpioctrl = pinctrl_lookup_state(aud_pinctrl,\n\t\t\t\t\t\t\t     aud_gpios[i].name);\n\t\tif (IS_ERR(aud_gpios[i].gpioctrl)) {\n\t\t\tret = PTR_ERR(aud_gpios[i].gpioctrl);\n\t\t\tdev_dbg(dev, \"%s(), pinctrl_lookup_state %s fail, ret %d\\n\",\n\t\t\t\t __func__, aud_gpios[i].name, ret);\n\t\t} else {\n\t\t\taud_gpios[i].gpio_prepare = true;\n\t\t}\n\t}\n\n\t \n\tfor (i = MT8186_DAI_ADDA; i <= MT8186_DAI_TDM_IN; i++) {\n\t\tfor (j = 0; j <= 1; j++)\n\t\t\tmt8186_afe_gpio_request(dev, false, i, j);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt8186_afe_gpio_init);\n\nstatic int mt8186_afe_gpio_select(struct device *dev,\n\t\t\t\t  enum mt8186_afe_gpio type)\n{\n\tint ret = 0;\n\n\tif (type < 0 || type >= MT8186_AFE_GPIO_GPIO_NUM) {\n\t\tdev_dbg(dev, \"%s(), error, invalid gpio type %d\\n\",\n\t\t\t__func__, type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!aud_gpios[type].gpio_prepare) {\n\t\tdev_dbg(dev, \"%s(), error, gpio type %d not prepared\\n\",\n\t\t\t__func__, type);\n\t\treturn -EIO;\n\t}\n\n\tret = pinctrl_select_state(aud_pinctrl,\n\t\t\t\t   aud_gpios[type].gpioctrl);\n\tif (ret) {\n\t\tdev_dbg(dev, \"%s(), error, can not set gpio type %d\\n\",\n\t\t\t__func__, type);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt8186_afe_gpio_adda_dl(struct device *dev, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_CLK_MOSI_ON);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MOSI CLK ON select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_DAT_MOSI_ON);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MOSI DAT ON select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_DAT_MOSI_OFF);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MOSI DAT OFF select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_CLK_MOSI_OFF);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MOSI CLK ON select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mt8186_afe_gpio_adda_ul(struct device *dev, bool enable)\n{\n\tint ret;\n\n\tif (enable) {\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_CLK_MISO_ON);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MISO CLK ON select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_DAT_MISO_ON);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MISO DAT ON select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_DAT_MISO_OFF);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MISO DAT OFF select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = mt8186_afe_gpio_select(dev, MT8186_AFE_GPIO_CLK_MISO_OFF);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"%s(), MISO CLK OFF select fail!\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mt8186_afe_gpio_request(struct device *dev, bool enable,\n\t\t\t    int dai, int uplink)\n{\n\tenum mt8186_afe_gpio sel;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&gpio_request_mutex);\n\n\tswitch (dai) {\n\tcase MT8186_DAI_ADDA:\n\t\tif (uplink)\n\t\t\tret = mt8186_afe_gpio_adda_ul(dev, enable);\n\t\telse\n\t\t\tret = mt8186_afe_gpio_adda_dl(dev, enable);\n\t\tgoto unlock;\n\tcase MT8186_DAI_I2S_0:\n\t\tsel = enable ? MT8186_AFE_GPIO_I2S0_ON : MT8186_AFE_GPIO_I2S0_OFF;\n\t\tbreak;\n\tcase MT8186_DAI_I2S_1:\n\t\tsel = enable ? MT8186_AFE_GPIO_I2S1_ON : MT8186_AFE_GPIO_I2S1_OFF;\n\t\tbreak;\n\tcase MT8186_DAI_I2S_2:\n\t\tsel = enable ? MT8186_AFE_GPIO_I2S2_ON : MT8186_AFE_GPIO_I2S2_OFF;\n\t\tbreak;\n\tcase MT8186_DAI_I2S_3:\n\t\tsel = enable ? MT8186_AFE_GPIO_I2S3_ON : MT8186_AFE_GPIO_I2S3_OFF;\n\t\tbreak;\n\tcase MT8186_DAI_TDM_IN:\n\t\tsel = enable ? MT8186_AFE_GPIO_TDM_ON : MT8186_AFE_GPIO_TDM_OFF;\n\t\tbreak;\n\tcase MT8186_DAI_PCM:\n\t\tsel = enable ? MT8186_AFE_GPIO_PCM_ON : MT8186_AFE_GPIO_PCM_OFF;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"%s(), invalid dai %d\\n\", __func__, dai);\n\t\tgoto unlock;\n\t}\n\n\tret = mt8186_afe_gpio_select(dev, sel);\n\nunlock:\n\tmutex_unlock(&gpio_request_mutex);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}