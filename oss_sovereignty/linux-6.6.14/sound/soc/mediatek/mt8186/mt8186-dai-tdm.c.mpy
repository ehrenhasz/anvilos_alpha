{
  "module_name": "mt8186-dai-tdm.c",
  "hash_id": "496e664efe3d84dbb0d0a915f76c66cd1c7bbcbcc7ba5b023f92a4aa104913bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8186/mt8186-dai-tdm.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n\n#include \"mt8186-afe-clk.h\"\n#include \"mt8186-afe-common.h\"\n#include \"mt8186-afe-gpio.h\"\n#include \"mt8186-interconnection.h\"\n\n#define TDM_HD_EN_W_NAME \"TDM_HD_EN\"\n#define TDM_MCLK_EN_W_NAME \"TDM_MCLK_EN\"\n#define MTK_AFE_TDM_KCONTROL_NAME \"TDM_HD_Mux\"\n\nstruct mtk_afe_tdm_priv {\n\tunsigned int id;\n\tunsigned int rate;  \n\tunsigned int bck_invert;\n\tunsigned int lck_invert;\n\tunsigned int lrck_width;\n\tunsigned int mclk_id;\n\tunsigned int mclk_multiple;  \n\tunsigned int mclk_rate;\n\tunsigned int mclk_apll;\n\tunsigned int tdm_mode;\n\tunsigned int data_mode;\n\tunsigned int slave_mode;\n\tunsigned int low_jitter_en;\n};\n\nenum {\n\tTDM_IN_I2S = 0,\n\tTDM_IN_LJ = 1,\n\tTDM_IN_RJ = 2,\n\tTDM_IN_DSP_A = 4,\n\tTDM_IN_DSP_B = 5,\n};\n\nenum {\n\tTDM_DATA_ONE_PIN = 0,\n\tTDM_DATA_MULTI_PIN,\n};\n\nenum {\n\tTDM_BCK_NON_INV = 0,\n\tTDM_BCK_INV = 1,\n};\n\nenum {\n\tTDM_LCK_NON_INV = 0,\n\tTDM_LCK_INV = 1,\n};\n\nstatic unsigned int get_tdm_lrck_width(snd_pcm_format_t format,\n\t\t\t\t       unsigned int mode)\n{\n\tif (mode == TDM_IN_DSP_A || mode == TDM_IN_DSP_B)\n\t\treturn 0;\n\n\treturn snd_pcm_format_physical_width(format) - 1;\n}\n\nstatic unsigned int get_tdm_ch_fixup(unsigned int channels)\n{\n\tif (channels > 4)\n\t\treturn 8;\n\telse if (channels > 2)\n\t\treturn 4;\n\n\treturn 2;\n}\n\nstatic unsigned int get_tdm_ch_per_sdata(unsigned int mode,\n\t\t\t\t\t unsigned int channels)\n{\n\tif (mode == TDM_IN_DSP_A || mode == TDM_IN_DSP_B)\n\t\treturn get_tdm_ch_fixup(channels);\n\n\treturn 2;\n}\n\nenum {\n\tSUPPLY_SEQ_APLL,\n\tSUPPLY_SEQ_TDM_MCK_EN,\n\tSUPPLY_SEQ_TDM_HD_EN,\n\tSUPPLY_SEQ_TDM_EN,\n};\n\nstatic int get_tdm_id_by_name(const char *name)\n{\n\treturn MT8186_DAI_TDM_IN;\n}\n\nstatic int mtk_tdm_en_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t    int event)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\n\tdev_dbg(cmpnt->dev, \"%s(), name %s, event 0x%x\\n\",\n\t\t__func__, w->name, event);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tmt8186_afe_gpio_request(afe->dev, true, tdm_priv->id, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tmt8186_afe_gpio_request(afe->dev, false, tdm_priv->id, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_tdm_mck_en_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol,\n\t\t\t\tint event)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\n\tdev_dbg(cmpnt->dev, \"%s(), name %s, event 0x%x, dai_id %d\\n\",\n\t\t__func__, w->name, event, dai_id);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tmt8186_mck_enable(afe, tdm_priv->mclk_id, tdm_priv->mclk_rate);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\ttdm_priv->mclk_rate = 0;\n\t\tmt8186_mck_disable(afe, tdm_priv->mclk_id);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \n \nstatic const char * const tdm_mux_map[] = {\n\t\"Normal\", \"Dummy_Widget\",\n};\n\nstatic int tdm_mux_map_value[] = {\n\t0, 1,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_AUTODISABLE_DECL(tdm_mux_map_enum,\n\t\t\t\t\t      SND_SOC_NOPM,\n\t\t\t\t\t      0,\n\t\t\t\t\t      1,\n\t\t\t\t\t      tdm_mux_map,\n\t\t\t\t\t      tdm_mux_map_value);\n\nstatic const struct snd_kcontrol_new tdm_in_mux_control =\n\tSOC_DAPM_ENUM(\"TDM In Select\", tdm_mux_map_enum);\n\nstatic const struct snd_soc_dapm_widget mtk_dai_tdm_widgets[] = {\n\tSND_SOC_DAPM_CLOCK_SUPPLY(\"aud_tdm_clk\"),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"TDM_EN\", SUPPLY_SEQ_TDM_EN,\n\t\t\t      ETDM_IN1_CON0, ETDM_IN1_CON0_REG_ETDM_IN_EN_SFT,\n\t\t\t      0, mtk_tdm_en_event,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\t \n\tSND_SOC_DAPM_SUPPLY_S(TDM_HD_EN_W_NAME, SUPPLY_SEQ_TDM_HD_EN,\n\t\t\t      ETDM_IN1_CON2, ETDM_IN1_CON2_REG_CLOCK_SOURCE_SEL_SFT,\n\t\t\t      0, NULL,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_SUPPLY_S(TDM_MCLK_EN_W_NAME, SUPPLY_SEQ_TDM_MCK_EN,\n\t\t\t      SND_SOC_NOPM, 0, 0,\n\t\t\t      mtk_tdm_mck_en_event,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_INPUT(\"TDM_DUMMY_IN\"),\n\n\tSND_SOC_DAPM_MUX(\"TDM_In_Mux\",\n\t\t\t SND_SOC_NOPM, 0, 0, &tdm_in_mux_control),\n};\n\nstatic int mtk_afe_tdm_mclk_connect(struct snd_soc_dapm_widget *source,\n\t\t\t\t    struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_dapm_widget *w = sink;\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\n\treturn (tdm_priv->mclk_rate > 0) ? 1 : 0;\n}\n\nstatic int mtk_afe_tdm_mclk_apll_connect(struct snd_soc_dapm_widget *source,\n\t\t\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_dapm_widget *w = sink;\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\tint cur_apll;\n\n\t \n\tcur_apll = mt8186_get_apll_by_name(afe, source->name);\n\n\treturn (tdm_priv->mclk_apll == cur_apll) ? 1 : 0;\n}\n\nstatic int mtk_afe_tdm_hd_connect(struct snd_soc_dapm_widget *source,\n\t\t\t\t  struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_dapm_widget *w = sink;\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\n\treturn tdm_priv->low_jitter_en;\n}\n\nstatic int mtk_afe_tdm_apll_connect(struct snd_soc_dapm_widget *source,\n\t\t\t\t    struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_dapm_widget *w = sink;\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(w->name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\tint cur_apll;\n\tint tdm_need_apll;\n\n\t \n\tcur_apll = mt8186_get_apll_by_name(afe, source->name);\n\n\t \n\ttdm_need_apll = mt8186_get_apll_by_rate(afe, tdm_priv->rate);\n\n\treturn (tdm_need_apll == cur_apll) ? 1 : 0;\n}\n\n \nstatic const char * const mt8186_tdm_hd_str[] = {\n\t\"Normal\", \"Low_Jitter\"\n};\n\nstatic const struct soc_enum mt8186_tdm_enum[] = {\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(mt8186_tdm_hd_str),\n\t\t\t    mt8186_tdm_hd_str),\n};\n\nstatic int mt8186_tdm_hd_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(kcontrol->id.name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\n\tucontrol->value.integer.value[0] = tdm_priv->low_jitter_en;\n\n\treturn 0;\n}\n\nstatic int mt8186_tdm_hd_set(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint dai_id = get_tdm_id_by_name(kcontrol->id.name);\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai_id];\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tint hd_en;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\thd_en = ucontrol->value.integer.value[0];\n\n\tdev_dbg(afe->dev, \"%s(), kcontrol name %s, hd_en %d\\n\",\n\t\t__func__, kcontrol->id.name, hd_en);\n\n\tif (tdm_priv->low_jitter_en == hd_en)\n\t\treturn 0;\n\n\ttdm_priv->low_jitter_en = hd_en;\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new mtk_dai_tdm_controls[] = {\n\tSOC_ENUM_EXT(MTK_AFE_TDM_KCONTROL_NAME, mt8186_tdm_enum[0],\n\t\t     mt8186_tdm_hd_get, mt8186_tdm_hd_set),\n};\n\nstatic const struct snd_soc_dapm_route mtk_dai_tdm_routes[] = {\n\t{\"TDM IN\", NULL, \"aud_tdm_clk\"},\n\t{\"TDM IN\", NULL, \"TDM_EN\"},\n\t{\"TDM IN\", NULL, TDM_HD_EN_W_NAME, mtk_afe_tdm_hd_connect},\n\t{TDM_HD_EN_W_NAME, NULL, APLL1_W_NAME, mtk_afe_tdm_apll_connect},\n\t{TDM_HD_EN_W_NAME, NULL, APLL2_W_NAME, mtk_afe_tdm_apll_connect},\n\n\t{\"TDM IN\", NULL, TDM_MCLK_EN_W_NAME, mtk_afe_tdm_mclk_connect},\n\t{TDM_MCLK_EN_W_NAME, NULL, APLL1_W_NAME, mtk_afe_tdm_mclk_apll_connect},\n\t{TDM_MCLK_EN_W_NAME, NULL, APLL2_W_NAME, mtk_afe_tdm_mclk_apll_connect},\n\n\t \n\t{\"TDM IN\", NULL, \"TDM_In_Mux\"},\n\t{\"TDM_In_Mux\", \"Dummy_Widget\", \"TDM_DUMMY_IN\"},\n};\n\n \nstatic int mtk_dai_tdm_cal_mclk(struct mtk_base_afe *afe,\n\t\t\t\tstruct mtk_afe_tdm_priv *tdm_priv,\n\t\t\t\tint freq)\n{\n\tint apll;\n\tint apll_rate;\n\n\tapll = mt8186_get_apll_by_rate(afe, freq);\n\tapll_rate = mt8186_get_apll_rate(afe, apll);\n\n\tif (!freq || freq > apll_rate) {\n\t\tdev_err(afe->dev,\n\t\t\t\"%s(), freq(%d Hz) invalid\\n\", __func__, freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (apll_rate % freq != 0) {\n\t\tdev_err(afe->dev,\n\t\t\t\"%s(), APLL cannot generate %d Hz\", __func__, freq);\n\t\treturn -EINVAL;\n\t}\n\n\ttdm_priv->mclk_rate = freq;\n\ttdm_priv->mclk_apll = apll;\n\n\treturn 0;\n}\n\nstatic int mtk_dai_tdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tint tdm_id = dai->id;\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[tdm_id];\n\tunsigned int tdm_mode = tdm_priv->tdm_mode;\n\tunsigned int data_mode = tdm_priv->data_mode;\n\tunsigned int rate = params_rate(params);\n\tunsigned int channels = params_channels(params);\n\tsnd_pcm_format_t format = params_format(params);\n\tunsigned int bit_width =\n\t\tsnd_pcm_format_physical_width(format);\n\tunsigned int tdm_channels = (data_mode == TDM_DATA_ONE_PIN) ?\n\t\tget_tdm_ch_per_sdata(tdm_mode, channels) : 2;\n\tunsigned int lrck_width =\n\t\tget_tdm_lrck_width(format, tdm_mode);\n\tunsigned int tdm_con = 0;\n\tbool slave_mode = tdm_priv->slave_mode;\n\tbool lrck_inv = tdm_priv->lck_invert;\n\tbool bck_inv = tdm_priv->bck_invert;\n\tunsigned int tran_rate;\n\tunsigned int tran_relatch_rate;\n\n\ttdm_priv->rate = rate;\n\ttran_rate = mt8186_rate_transform(afe->dev, rate, dai->id);\n\ttran_relatch_rate = mt8186_tdm_relatch_rate_transform(afe->dev, rate);\n\n\t \n\tif (!tdm_priv->mclk_rate) {\n\t\ttdm_priv->mclk_rate = rate * tdm_priv->mclk_multiple;\n\t\tmtk_dai_tdm_cal_mclk(afe, tdm_priv, tdm_priv->mclk_rate);\n\t}\n\n\t \n\ttdm_con |= slave_mode << ETDM_IN1_CON0_REG_SLAVE_MODE_SFT;\n\ttdm_con |= tdm_mode << ETDM_IN1_CON0_REG_FMT_SFT;\n\ttdm_con |= (bit_width - 1) << ETDM_IN1_CON0_REG_BIT_LENGTH_SFT;\n\ttdm_con |= (bit_width - 1) << ETDM_IN1_CON0_REG_WORD_LENGTH_SFT;\n\ttdm_con |= (tdm_channels - 1) << ETDM_IN1_CON0_REG_CH_NUM_SFT;\n\t \n\ttdm_con |= 0 << ETDM_IN1_CON0_REG_SYNC_MODE_SFT;\n\t \n\ttdm_con |= 0 << ETDM_IN1_CON0_REG_RELATCH_1X_EN_SEL_DOMAIN_SFT;\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON0, ETDM_IN_CON0_CTRL_MASK, tdm_con);\n\n\t \n\ttdm_con = 0;\n\ttdm_con |= 0 << ETDM_IN1_CON1_REG_LRCK_AUTO_MODE_SFT;\n\ttdm_con |= 1 << ETDM_IN1_CON1_PINMUX_MCLK_CTRL_OE_SFT;\n\ttdm_con |= (lrck_width - 1) << ETDM_IN1_CON1_REG_LRCK_WIDTH_SFT;\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON1, ETDM_IN_CON1_CTRL_MASK, tdm_con);\n\n\t \n\ttdm_con = 0;\n\ttdm_con = ETDM_IN_CON3_FS(tran_rate);\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON3, ETDM_IN_CON3_CTRL_MASK, tdm_con);\n\n\t \n\ttdm_con = 0;\n\ttdm_con = ETDM_IN_CON4_FS(tran_relatch_rate);\n\tif (slave_mode) {\n\t\tif (lrck_inv)\n\t\t\ttdm_con |= ETDM_IN_CON4_CON0_SLAVE_LRCK_INV;\n\t\tif (bck_inv)\n\t\t\ttdm_con |= ETDM_IN_CON4_CON0_SLAVE_BCK_INV;\n\t} else {\n\t\tif (lrck_inv)\n\t\t\ttdm_con |= ETDM_IN_CON4_CON0_MASTER_LRCK_INV;\n\t\tif (bck_inv)\n\t\t\ttdm_con |= ETDM_IN_CON4_CON0_MASTER_BCK_INV;\n\t}\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON4, ETDM_IN_CON4_CTRL_MASK, tdm_con);\n\n\t \n\ttdm_con = 0;\n\tif (data_mode == TDM_DATA_MULTI_PIN) {\n\t\ttdm_con |= ETDM_IN_CON2_MULTI_IP_2CH_MODE;\n\t\ttdm_con |= ETDM_IN_CON2_MULTI_IP_CH(channels);\n\t}\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON2, ETDM_IN_CON2_CTRL_MASK, tdm_con);\n\n\t \n\ttdm_con = 0;\n\tif (slave_mode) {\n\t\ttdm_con |= 1 << ETDM_IN1_CON8_REG_ETDM_USE_AFIFO_SFT;\n\t\ttdm_con |= 0 << ETDM_IN1_CON8_REG_AFIFO_CLOCK_DOMAIN_SEL_SFT;\n\t\ttdm_con |= ETDM_IN_CON8_FS(tran_relatch_rate);\n\t} else {\n\t\ttdm_con |= 0 << ETDM_IN1_CON8_REG_ETDM_USE_AFIFO_SFT;\n\t}\n\tregmap_update_bits(afe->regmap, ETDM_IN1_CON8, ETDM_IN_CON8_CTRL_MASK, tdm_con);\n\n\treturn 0;\n}\n\nstatic int mtk_dai_tdm_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai->id];\n\n\tif (dir != SND_SOC_CLOCK_IN) {\n\t\tdev_err(afe->dev, \"%s(), dir != SND_SOC_CLOCK_OUT\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(afe->dev, \"%s(), freq %d\\n\", __func__, freq);\n\n\treturn mtk_dai_tdm_cal_mclk(afe, tdm_priv, freq);\n}\n\nstatic int mtk_dai_tdm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai->id];\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\ttdm_priv->tdm_mode = TDM_IN_I2S;\n\t\ttdm_priv->data_mode = TDM_DATA_MULTI_PIN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ttdm_priv->tdm_mode = TDM_IN_LJ;\n\t\ttdm_priv->data_mode = TDM_DATA_MULTI_PIN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\ttdm_priv->tdm_mode = TDM_IN_RJ;\n\t\ttdm_priv->data_mode = TDM_DATA_MULTI_PIN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\ttdm_priv->tdm_mode = TDM_IN_DSP_A;\n\t\ttdm_priv->data_mode = TDM_DATA_ONE_PIN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\ttdm_priv->tdm_mode = TDM_IN_DSP_B;\n\t\ttdm_priv->data_mode = TDM_DATA_ONE_PIN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(afe->dev, \"%s(), invalid DAIFMT_FORMAT_MASK\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\ttdm_priv->bck_invert = TDM_BCK_NON_INV;\n\t\ttdm_priv->lck_invert = TDM_LCK_NON_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\ttdm_priv->bck_invert = TDM_BCK_NON_INV;\n\t\ttdm_priv->lck_invert = TDM_LCK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\ttdm_priv->bck_invert = TDM_BCK_INV;\n\t\ttdm_priv->lck_invert = TDM_LCK_NON_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\ttdm_priv->bck_invert = TDM_BCK_INV;\n\t\ttdm_priv->lck_invert = TDM_LCK_INV;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(afe->dev, \"%s(), invalid DAIFMT_INV_MASK\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\ttdm_priv->slave_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\ttdm_priv->slave_mode = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(afe->dev, \"%s(), invalid DAIFMT_CLOCK_PROVIDER_MASK\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dai_tdm_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask,\n\t\t\t\t    unsigned int rx_mask,\n\t\t\t\t    int slots,\n\t\t\t\t    int slot_width)\n{\n\tstruct mtk_base_afe *afe = dev_get_drvdata(dai->dev);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_tdm_priv *tdm_priv = afe_priv->dai_priv[dai->id];\n\n\tdev_dbg(dai->dev, \"%s %d slot_width %d\\n\", __func__, dai->id, slot_width);\n\n\ttdm_priv->lrck_width = slot_width;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mtk_dai_tdm_ops = {\n\t.hw_params = mtk_dai_tdm_hw_params,\n\t.set_sysclk = mtk_dai_tdm_set_sysclk,\n\t.set_fmt = mtk_dai_tdm_set_fmt,\n\t.set_tdm_slot = mtk_dai_tdm_set_tdm_slot,\n};\n\n \n#define MTK_TDM_RATES (SNDRV_PCM_RATE_8000_48000 |\\\n\t\t       SNDRV_PCM_RATE_88200 |\\\n\t\t       SNDRV_PCM_RATE_96000 |\\\n\t\t       SNDRV_PCM_RATE_176400 |\\\n\t\t       SNDRV_PCM_RATE_192000)\n\n#define MTK_TDM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mtk_dai_tdm_driver[] = {\n\t{\n\t\t.name = \"TDM IN\",\n\t\t.id = MT8186_DAI_TDM_IN,\n\t\t.capture = {\n\t\t\t.stream_name = \"TDM IN\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = MTK_TDM_RATES,\n\t\t\t.formats = MTK_TDM_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_tdm_ops,\n\t},\n};\n\nstatic struct mtk_afe_tdm_priv *init_tdm_priv_data(struct mtk_base_afe *afe)\n{\n\tstruct mtk_afe_tdm_priv *tdm_priv;\n\n\ttdm_priv = devm_kzalloc(afe->dev, sizeof(struct mtk_afe_tdm_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (!tdm_priv)\n\t\treturn NULL;\n\n\ttdm_priv->mclk_multiple = 512;\n\ttdm_priv->mclk_id = MT8186_TDM_MCK;\n\ttdm_priv->id = MT8186_DAI_TDM_IN;\n\n\treturn tdm_priv;\n}\n\nint mt8186_dai_tdm_register(struct mtk_base_afe *afe)\n{\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_tdm_priv *tdm_priv;\n\tstruct mtk_base_afe_dai *dai;\n\n\tdai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tlist_add(&dai->list, &afe->sub_dais);\n\n\tdai->dai_drivers = mtk_dai_tdm_driver;\n\tdai->num_dai_drivers = ARRAY_SIZE(mtk_dai_tdm_driver);\n\n\tdai->controls = mtk_dai_tdm_controls;\n\tdai->num_controls = ARRAY_SIZE(mtk_dai_tdm_controls);\n\tdai->dapm_widgets = mtk_dai_tdm_widgets;\n\tdai->num_dapm_widgets = ARRAY_SIZE(mtk_dai_tdm_widgets);\n\tdai->dapm_routes = mtk_dai_tdm_routes;\n\tdai->num_dapm_routes = ARRAY_SIZE(mtk_dai_tdm_routes);\n\n\ttdm_priv = init_tdm_priv_data(afe);\n\tif (!tdm_priv)\n\t\treturn -ENOMEM;\n\n\tafe_priv->dai_priv[MT8186_DAI_TDM_IN] = tdm_priv;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}