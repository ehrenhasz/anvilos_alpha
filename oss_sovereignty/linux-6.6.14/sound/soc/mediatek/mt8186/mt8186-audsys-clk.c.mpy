{
  "module_name": "mt8186-audsys-clk.c",
  "hash_id": "8021e6dc849a270d5f40122388669febd19d1dffe3d94f10d581e20e6c6d26e5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8186/mt8186-audsys-clk.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include \"mt8186-afe-common.h\"\n#include \"mt8186-audsys-clk.h\"\n#include \"mt8186-audsys-clkid.h\"\n#include \"mt8186-reg.h\"\n\nstruct afe_gate {\n\tint id;\n\tconst char *name;\n\tconst char *parent_name;\n\tint reg;\n\tu8 bit;\n\tconst struct clk_ops *ops;\n\tunsigned long flags;\n\tu8 cg_flags;\n};\n\n#define GATE_AFE_FLAGS(_id, _name, _parent, _reg, _bit, _flags, _cgflags) {\\\n\t\t.id = _id,\t\t\t\t\t\\\n\t\t.name = _name,\t\t\t\t\t\\\n\t\t.parent_name = _parent,\t\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\t\\\n\t\t.bit = _bit,\t\t\t\t\t\\\n\t\t.flags = _flags,\t\t\t\t\\\n\t\t.cg_flags = _cgflags,\t\t\t\t\\\n\t}\n\n#define GATE_AFE(_id, _name, _parent, _reg, _bit)\t\t\\\n\tGATE_AFE_FLAGS(_id, _name, _parent, _reg, _bit,\t\t\\\n\t\t       CLK_SET_RATE_PARENT, CLK_GATE_SET_TO_DISABLE)\n\n#define GATE_AUD0(_id, _name, _parent, _bit)\t\t\t\\\n\tGATE_AFE(_id, _name, _parent, AUDIO_TOP_CON0, _bit)\n\n#define GATE_AUD1(_id, _name, _parent, _bit)\t\t\t\\\n\tGATE_AFE(_id, _name, _parent, AUDIO_TOP_CON1, _bit)\n\n#define GATE_AUD2(_id, _name, _parent, _bit)\t\t\t\\\n\tGATE_AFE(_id, _name, _parent, AUDIO_TOP_CON2, _bit)\n\nstatic const struct afe_gate aud_clks[CLK_AUD_NR_CLK] = {\n\t \n\tGATE_AUD0(CLK_AUD_AFE, \"aud_afe_clk\", \"top_audio\", 2),\n\tGATE_AUD0(CLK_AUD_22M, \"aud_apll22m_clk\", \"top_aud_engen1\", 8),\n\tGATE_AUD0(CLK_AUD_24M, \"aud_apll24m_clk\", \"top_aud_engen2\", 9),\n\tGATE_AUD0(CLK_AUD_APLL2_TUNER, \"aud_apll2_tuner_clk\", \"top_aud_engen2\", 18),\n\tGATE_AUD0(CLK_AUD_APLL_TUNER, \"aud_apll_tuner_clk\", \"top_aud_engen1\", 19),\n\tGATE_AUD0(CLK_AUD_TDM, \"aud_tdm_clk\", \"top_aud_1\", 20),\n\tGATE_AUD0(CLK_AUD_ADC, \"aud_adc_clk\", \"top_audio\", 24),\n\tGATE_AUD0(CLK_AUD_DAC, \"aud_dac_clk\", \"top_audio\", 25),\n\tGATE_AUD0(CLK_AUD_DAC_PREDIS, \"aud_dac_predis_clk\", \"top_audio\", 26),\n\tGATE_AUD0(CLK_AUD_TML, \"aud_tml_clk\", \"top_audio\", 27),\n\tGATE_AUD0(CLK_AUD_NLE, \"aud_nle_clk\", \"top_audio\", 28),\n\n\t \n\tGATE_AUD1(CLK_AUD_I2S1_BCLK, \"aud_i2s1_bclk\", \"top_audio\", 4),\n\tGATE_AUD1(CLK_AUD_I2S2_BCLK, \"aud_i2s2_bclk\", \"top_audio\", 5),\n\tGATE_AUD1(CLK_AUD_I2S3_BCLK, \"aud_i2s3_bclk\", \"top_audio\", 6),\n\tGATE_AUD1(CLK_AUD_I2S4_BCLK, \"aud_i2s4_bclk\", \"top_audio\", 7),\n\tGATE_AUD1(CLK_AUD_CONNSYS_I2S_ASRC, \"aud_connsys_i2s_asrc\", \"top_audio\", 12),\n\tGATE_AUD1(CLK_AUD_GENERAL1_ASRC, \"aud_general1_asrc\", \"top_audio\", 13),\n\tGATE_AUD1(CLK_AUD_GENERAL2_ASRC, \"aud_general2_asrc\", \"top_audio\", 14),\n\tGATE_AUD1(CLK_AUD_DAC_HIRES, \"aud_dac_hires_clk\", \"top_audio_h\", 15),\n\tGATE_AUD1(CLK_AUD_ADC_HIRES, \"aud_adc_hires_clk\", \"top_audio_h\", 16),\n\tGATE_AUD1(CLK_AUD_ADC_HIRES_TML, \"aud_adc_hires_tml\", \"top_audio_h\", 17),\n\tGATE_AUD1(CLK_AUD_ADDA6_ADC, \"aud_adda6_adc\", \"top_audio\", 20),\n\tGATE_AUD1(CLK_AUD_ADDA6_ADC_HIRES, \"aud_adda6_adc_hires\", \"top_audio_h\", 21),\n\tGATE_AUD1(CLK_AUD_3RD_DAC, \"aud_3rd_dac\", \"top_audio\", 28),\n\tGATE_AUD1(CLK_AUD_3RD_DAC_PREDIS, \"aud_3rd_dac_predis\", \"top_audio\", 29),\n\tGATE_AUD1(CLK_AUD_3RD_DAC_TML, \"aud_3rd_dac_tml\", \"top_audio\", 30),\n\tGATE_AUD1(CLK_AUD_3RD_DAC_HIRES, \"aud_3rd_dac_hires\", \"top_audio_h\", 31),\n\n\t \n\tGATE_AUD2(CLK_AUD_ETDM_IN1_BCLK, \"aud_etdm_in1_bclk\", \"top_audio\", 23),\n\tGATE_AUD2(CLK_AUD_ETDM_OUT1_BCLK, \"aud_etdm_out1_bclk\", \"top_audio\", 24),\n};\n\nstatic void mt8186_audsys_clk_unregister(void *data)\n{\n\tstruct mtk_base_afe *afe = data;\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct clk *clk;\n\tstruct clk_lookup *cl;\n\tint i;\n\n\tif (!afe_priv)\n\t\treturn;\n\n\tfor (i = 0; i < CLK_AUD_NR_CLK; i++) {\n\t\tcl = afe_priv->lookup[i];\n\t\tif (!cl)\n\t\t\tcontinue;\n\n\t\tclk = cl->clk;\n\t\tclk_unregister_gate(clk);\n\n\t\tclkdev_drop(cl);\n\t}\n}\n\nint mt8186_audsys_clk_register(struct mtk_base_afe *afe)\n{\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct clk *clk;\n\tstruct clk_lookup *cl;\n\tint i;\n\n\tafe_priv->lookup = devm_kcalloc(afe->dev, CLK_AUD_NR_CLK,\n\t\t\t\t\tsizeof(*afe_priv->lookup),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!afe_priv->lookup)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(aud_clks); i++) {\n\t\tconst struct afe_gate *gate = &aud_clks[i];\n\n\t\tclk = clk_register_gate(afe->dev, gate->name, gate->parent_name,\n\t\t\t\t\tgate->flags, afe->base_addr + gate->reg,\n\t\t\t\t\tgate->bit, gate->cg_flags, NULL);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(afe->dev, \"Failed to register clk %s: %ld\\n\",\n\t\t\t\tgate->name, PTR_ERR(clk));\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcl = kzalloc(sizeof(*cl), GFP_KERNEL);\n\t\tif (!cl)\n\t\t\treturn -ENOMEM;\n\n\t\tcl->clk = clk;\n\t\tcl->con_id = gate->name;\n\t\tcl->dev_id = dev_name(afe->dev);\n\t\tclkdev_add(cl);\n\n\t\tafe_priv->lookup[i] = cl;\n\t}\n\n\treturn devm_add_action_or_reset(afe->dev, mt8186_audsys_clk_unregister, afe);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}