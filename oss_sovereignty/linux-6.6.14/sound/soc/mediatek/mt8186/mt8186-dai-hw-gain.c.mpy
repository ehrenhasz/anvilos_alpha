{
  "module_name": "mt8186-dai-hw-gain.c",
  "hash_id": "5366e36c4f0d6612d539d0b7d12a1797cbec9b29060b80e1f48f6d5ad73bf6df",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8186/mt8186-dai-hw-gain.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include \"mt8186-afe-common.h\"\n#include \"mt8186-interconnection.h\"\n\n#define HW_GAIN_1_EN_W_NAME \"HW GAIN 1 Enable\"\n#define HW_GAIN_2_EN_W_NAME \"HW GAIN 2 Enable\"\n\n \nstatic const struct snd_kcontrol_new mtk_hw_gain1_in_ch1_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"CONNSYS_I2S_CH1 Switch\", AFE_CONN13_1,\n\t\t\t\t    I_CONNSYS_I2S_CH1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mtk_hw_gain1_in_ch2_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"CONNSYS_I2S_CH2 Switch\", AFE_CONN14_1,\n\t\t\t\t    I_CONNSYS_I2S_CH2, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mtk_hw_gain2_in_ch1_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"ADDA_UL_CH1 Switch\", AFE_CONN15,\n\t\t\t\t    I_ADDA_UL_CH1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mtk_hw_gain2_in_ch2_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"ADDA_UL_CH2 Switch\", AFE_CONN16,\n\t\t\t\t    I_ADDA_UL_CH2, 1, 0),\n};\n\nstatic int mtk_hw_gain_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol,\n\t\t\t     int event)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\tunsigned int gain_cur;\n\tunsigned int gain_con1;\n\n\tdev_dbg(cmpnt->dev, \"%s(), name %s, event 0x%x\\n\",\n\t\t__func__, w->name, event);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (strcmp(w->name, HW_GAIN_1_EN_W_NAME) == 0) {\n\t\t\tgain_cur = AFE_GAIN1_CUR;\n\t\t\tgain_con1 = AFE_GAIN1_CON1;\n\t\t} else {\n\t\t\tgain_cur = AFE_GAIN2_CUR;\n\t\t\tgain_con1 = AFE_GAIN2_CON1;\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, gain_cur, AFE_GAIN1_CUR_MASK_SFT, 0);\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, gain_con1, GAIN1_TARGET_MASK_SFT, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget mtk_dai_hw_gain_widgets[] = {\n\t \n\tSND_SOC_DAPM_MIXER(\"HW_GAIN1_IN_CH1\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_hw_gain1_in_ch1_mix,\n\t\t\t   ARRAY_SIZE(mtk_hw_gain1_in_ch1_mix)),\n\tSND_SOC_DAPM_MIXER(\"HW_GAIN1_IN_CH2\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_hw_gain1_in_ch2_mix,\n\t\t\t   ARRAY_SIZE(mtk_hw_gain1_in_ch2_mix)),\n\tSND_SOC_DAPM_MIXER(\"HW_GAIN2_IN_CH1\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_hw_gain2_in_ch1_mix,\n\t\t\t   ARRAY_SIZE(mtk_hw_gain2_in_ch1_mix)),\n\tSND_SOC_DAPM_MIXER(\"HW_GAIN2_IN_CH2\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_hw_gain2_in_ch2_mix,\n\t\t\t   ARRAY_SIZE(mtk_hw_gain2_in_ch2_mix)),\n\n\tSND_SOC_DAPM_SUPPLY(HW_GAIN_1_EN_W_NAME,\n\t\t\t    AFE_GAIN1_CON0, GAIN1_ON_SFT, 0,\n\t\t\t    mtk_hw_gain_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU),\n\n\tSND_SOC_DAPM_SUPPLY(HW_GAIN_2_EN_W_NAME,\n\t\t\t    AFE_GAIN2_CON0, GAIN2_ON_SFT, 0,\n\t\t\t    mtk_hw_gain_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU),\n\n\tSND_SOC_DAPM_INPUT(\"HW Gain 1 Out Endpoint\"),\n\tSND_SOC_DAPM_INPUT(\"HW Gain 2 Out Endpoint\"),\n\tSND_SOC_DAPM_OUTPUT(\"HW Gain 1 In Endpoint\"),\n};\n\nstatic const struct snd_soc_dapm_route mtk_dai_hw_gain_routes[] = {\n\t{\"HW Gain 1 In\", NULL, \"HW_GAIN1_IN_CH1\"},\n\t{\"HW Gain 1 In\", NULL, \"HW_GAIN1_IN_CH2\"},\n\t{\"HW Gain 2 In\", NULL, \"HW_GAIN2_IN_CH1\"},\n\t{\"HW Gain 2 In\", NULL, \"HW_GAIN2_IN_CH2\"},\n\n\t{\"HW Gain 1 In\", NULL, HW_GAIN_1_EN_W_NAME},\n\t{\"HW Gain 1 Out\", NULL, HW_GAIN_1_EN_W_NAME},\n\t{\"HW Gain 2 In\", NULL, HW_GAIN_2_EN_W_NAME},\n\t{\"HW Gain 2 Out\", NULL, HW_GAIN_2_EN_W_NAME},\n\n\t{\"HW Gain 1 In Endpoint\", NULL, \"HW Gain 1 In\"},\n\t{\"HW Gain 1 Out\", NULL, \"HW Gain 1 Out Endpoint\"},\n\t{\"HW Gain 2 Out\", NULL, \"HW Gain 2 Out Endpoint\"},\n};\n\nstatic const struct snd_kcontrol_new mtk_hw_gain_controls[] = {\n\tSOC_SINGLE(\"HW Gain 1 Volume\", AFE_GAIN1_CON1,\n\t\t   GAIN1_TARGET_SFT, GAIN1_TARGET_MASK, 0),\n\tSOC_SINGLE(\"HW Gain 2 Volume\", AFE_GAIN2_CON1,\n\t\t   GAIN2_TARGET_SFT, GAIN2_TARGET_MASK, 0),\n};\n\n \nstatic int mtk_dai_gain_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tunsigned int rate = params_rate(params);\n\tunsigned int rate_reg = mt8186_rate_transform(afe->dev, rate, dai->id);\n\n\tdev_dbg(afe->dev, \"%s(), id %d, stream %d, rate %d\\n\",\n\t\t__func__, dai->id, substream->stream, rate);\n\n\t \n\tregmap_update_bits(afe->regmap,\n\t\t\t   dai->id == MT8186_DAI_HW_GAIN_1 ?\n\t\t\t   AFE_GAIN1_CON0 : AFE_GAIN2_CON0,\n\t\t\t   GAIN1_MODE_MASK_SFT,\n\t\t\t   rate_reg << GAIN1_MODE_SFT);\n\n\t \n\tregmap_update_bits(afe->regmap,\n\t\t\t   dai->id == MT8186_DAI_HW_GAIN_1 ?\n\t\t\t   AFE_GAIN1_CON0 : AFE_GAIN2_CON0,\n\t\t\t   GAIN1_SAMPLE_PER_STEP_MASK_SFT,\n\t\t\t   (dai->id == MT8186_DAI_HW_GAIN_1 ? 0x40 : 0x0) <<\n\t\t\t   GAIN1_SAMPLE_PER_STEP_SFT);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mtk_dai_gain_ops = {\n\t.hw_params = mtk_dai_gain_hw_params,\n};\n\n \n#define MTK_HW_GAIN_RATES (SNDRV_PCM_RATE_8000_48000 |\\\n\t\t\t   SNDRV_PCM_RATE_88200 |\\\n\t\t\t   SNDRV_PCM_RATE_96000 |\\\n\t\t\t   SNDRV_PCM_RATE_176400 |\\\n\t\t\t   SNDRV_PCM_RATE_192000)\n\n#define MTK_HW_GAIN_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t     SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t     SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mtk_dai_gain_driver[] = {\n\t{\n\t\t.name = \"HW Gain 1\",\n\t\t.id = MT8186_DAI_HW_GAIN_1,\n\t\t.playback = {\n\t\t\t.stream_name = \"HW Gain 1 In\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_HW_GAIN_RATES,\n\t\t\t.formats = MTK_HW_GAIN_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HW Gain 1 Out\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_HW_GAIN_RATES,\n\t\t\t.formats = MTK_HW_GAIN_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_gain_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_channels = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n\t{\n\t\t.name = \"HW Gain 2\",\n\t\t.id = MT8186_DAI_HW_GAIN_2,\n\t\t.playback = {\n\t\t\t.stream_name = \"HW Gain 2 In\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_HW_GAIN_RATES,\n\t\t\t.formats = MTK_HW_GAIN_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HW Gain 2 Out\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_HW_GAIN_RATES,\n\t\t\t.formats = MTK_HW_GAIN_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_gain_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_channels = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n};\n\nint mt8186_dai_hw_gain_register(struct mtk_base_afe *afe)\n{\n\tstruct mtk_base_afe_dai *dai;\n\n\tdai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tlist_add(&dai->list, &afe->sub_dais);\n\n\tdai->dai_drivers = mtk_dai_gain_driver;\n\tdai->num_dai_drivers = ARRAY_SIZE(mtk_dai_gain_driver);\n\n\tdai->controls = mtk_hw_gain_controls;\n\tdai->num_controls = ARRAY_SIZE(mtk_hw_gain_controls);\n\tdai->dapm_widgets = mtk_dai_hw_gain_widgets;\n\tdai->num_dapm_widgets = ARRAY_SIZE(mtk_dai_hw_gain_widgets);\n\tdai->dapm_routes = mtk_dai_hw_gain_routes;\n\tdai->num_dapm_routes = ARRAY_SIZE(mtk_dai_hw_gain_routes);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}