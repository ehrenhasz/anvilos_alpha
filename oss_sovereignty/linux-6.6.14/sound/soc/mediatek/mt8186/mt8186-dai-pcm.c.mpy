{
  "module_name": "mt8186-dai-pcm.c",
  "hash_id": "5af4b75b78b714e449e3fd03a9acc6cd9d934a64cae7c180a330767210c473c8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8186/mt8186-dai-pcm.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include \"mt8186-afe-common.h\"\n#include \"mt8186-afe-gpio.h\"\n#include \"mt8186-interconnection.h\"\n\nstruct mtk_afe_pcm_priv {\n\tunsigned int id;\n\tunsigned int fmt;\n\tunsigned int bck_invert;\n\tunsigned int lck_invert;\n};\n\nenum aud_tx_lch_rpt {\n\tAUD_TX_LCH_RPT_NO_REPEAT = 0,\n\tAUD_TX_LCH_RPT_REPEAT = 1\n};\n\nenum aud_vbt_16k_mode {\n\tAUD_VBT_16K_MODE_DISABLE = 0,\n\tAUD_VBT_16K_MODE_ENABLE = 1\n};\n\nenum aud_ext_modem {\n\tAUD_EXT_MODEM_SELECT_INTERNAL = 0,\n\tAUD_EXT_MODEM_SELECT_EXTERNAL = 1\n};\n\nenum aud_pcm_sync_type {\n\t \n\tAUD_PCM_ONE_BCK_CYCLE_SYNC = 0,\n\t \n\tAUD_PCM_EXTENDED_BCK_CYCLE_SYNC = 1\n};\n\nenum aud_bt_mode {\n\tAUD_BT_MODE_DUAL_MIC_ON_TX = 0,\n\tAUD_BT_MODE_SINGLE_MIC_ON_TX = 1\n};\n\nenum aud_pcm_afifo_src {\n\t \n\tAUD_PCM_AFIFO_ASRC = 0,\n\t \n\tAUD_PCM_AFIFO_AFIFO = 1\n};\n\nenum aud_pcm_clock_source {\n\tAUD_PCM_CLOCK_MASTER_MODE = 0,\n\tAUD_PCM_CLOCK_SLAVE_MODE = 1\n};\n\nenum aud_pcm_wlen {\n\tAUD_PCM_WLEN_PCM_32_BCK_CYCLES = 0,\n\tAUD_PCM_WLEN_PCM_64_BCK_CYCLES = 1\n};\n\nenum aud_pcm_24bit {\n\tAUD_PCM_24BIT_PCM_16_BITS = 0,\n\tAUD_PCM_24BIT_PCM_24_BITS = 1\n};\n\nenum aud_pcm_mode {\n\tAUD_PCM_MODE_PCM_MODE_8K = 0,\n\tAUD_PCM_MODE_PCM_MODE_16K = 1,\n\tAUD_PCM_MODE_PCM_MODE_32K = 2,\n\tAUD_PCM_MODE_PCM_MODE_48K = 3,\n};\n\nenum aud_pcm_fmt {\n\tAUD_PCM_FMT_I2S = 0,\n\tAUD_PCM_FMT_EIAJ = 1,\n\tAUD_PCM_FMT_PCM_MODE_A = 2,\n\tAUD_PCM_FMT_PCM_MODE_B = 3\n};\n\nenum aud_bclk_out_inv {\n\tAUD_BCLK_OUT_INV_NO_INVERSE = 0,\n\tAUD_BCLK_OUT_INV_INVERSE = 1\n};\n\nenum aud_lrclk_out_inv {\n\tAUD_LRCLK_OUT_INV_NO_INVERSE = 0,\n\tAUD_LRCLK_OUT_INV_INVERSE = 1\n};\n\nenum aud_pcm_en {\n\tAUD_PCM_EN_DISABLE = 0,\n\tAUD_PCM_EN_ENABLE = 1\n};\n\n \nstatic const struct snd_kcontrol_new mtk_pcm_1_playback_ch1_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"ADDA_UL_CH1 Switch\", AFE_CONN7,\n\t\t\t\t    I_ADDA_UL_CH1, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"DL2_CH1 Switch\", AFE_CONN7,\n\t\t\t\t    I_DL2_CH1, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"DL4_CH1 Switch\", AFE_CONN7_1,\n\t\t\t\t    I_DL4_CH1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mtk_pcm_1_playback_ch2_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"ADDA_UL_CH2 Switch\", AFE_CONN8,\n\t\t\t\t    I_ADDA_UL_CH2, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"DL2_CH2 Switch\", AFE_CONN8,\n\t\t\t\t    I_DL2_CH2, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"DL4_CH2 Switch\", AFE_CONN8_1,\n\t\t\t\t    I_DL4_CH2, 1, 0),\n};\n\nstatic int mtk_pcm_en_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t    int event)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(cmpnt);\n\n\tdev_dbg(afe->dev, \"%s(), name %s, event 0x%x\\n\",\n\t\t__func__, w->name, event);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tmt8186_afe_gpio_request(afe->dev, true, MT8186_DAI_PCM, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tmt8186_afe_gpio_request(afe->dev, false, MT8186_DAI_PCM, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic const char * const pcm_lpbk_mux_map[] = {\n\t\"Normal\", \"Lpbk\",\n};\n\nstatic int pcm_lpbk_mux_map_value[] = {\n\t0, 1,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_AUTODISABLE_DECL(pcm_in_lpbk_mux_map_enum,\n\t\t\t\t\t      PCM_INTF_CON1,\n\t\t\t\t\t      PCM_I2S_PCM_LOOPBACK_SFT,\n\t\t\t\t\t      1,\n\t\t\t\t\t      pcm_lpbk_mux_map,\n\t\t\t\t\t      pcm_lpbk_mux_map_value);\n\nstatic const struct snd_kcontrol_new pcm_in_lpbk_mux_control =\n\tSOC_DAPM_ENUM(\"PCM In Lpbk Select\", pcm_in_lpbk_mux_map_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_AUTODISABLE_DECL(pcm_out_lpbk_mux_map_enum,\n\t\t\t\t\t      PCM_INTF_CON1,\n\t\t\t\t\t      PCM_I2S_PCM_LOOPBACK_SFT,\n\t\t\t\t\t      1,\n\t\t\t\t\t      pcm_lpbk_mux_map,\n\t\t\t\t\t      pcm_lpbk_mux_map_value);\n\nstatic const struct snd_kcontrol_new pcm_out_lpbk_mux_control =\n\tSOC_DAPM_ENUM(\"PCM Out Lpbk Select\", pcm_out_lpbk_mux_map_enum);\n\nstatic const struct snd_soc_dapm_widget mtk_dai_pcm_widgets[] = {\n\t \n\tSND_SOC_DAPM_MIXER(\"PCM_1_PB_CH1\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_pcm_1_playback_ch1_mix,\n\t\t\t   ARRAY_SIZE(mtk_pcm_1_playback_ch1_mix)),\n\tSND_SOC_DAPM_MIXER(\"PCM_1_PB_CH2\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_pcm_1_playback_ch2_mix,\n\t\t\t   ARRAY_SIZE(mtk_pcm_1_playback_ch2_mix)),\n\n\tSND_SOC_DAPM_SUPPLY(\"PCM_1_EN\",\n\t\t\t    PCM_INTF_CON1, PCM_EN_SFT, 0,\n\t\t\t    mtk_pcm_en_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_MUX(\"PCM_In_Lpbk_Mux\",\n\t\t\t SND_SOC_NOPM, 0, 0, &pcm_in_lpbk_mux_control),\n\n\t \n\tSND_SOC_DAPM_MUX(\"PCM_Out_Lpbk_Mux\",\n\t\t\t SND_SOC_NOPM, 0, 0, &pcm_out_lpbk_mux_control),\n};\n\nstatic const struct snd_soc_dapm_route mtk_dai_pcm_routes[] = {\n\t{\"PCM 1 Playback\", NULL, \"PCM_1_PB_CH1\"},\n\t{\"PCM 1 Playback\", NULL, \"PCM_1_PB_CH2\"},\n\n\t{\"PCM 1 Playback\", NULL, \"PCM_1_EN\"},\n\t{\"PCM 1 Capture\", NULL, \"PCM_1_EN\"},\n\n\t{\"PCM_1_PB_CH1\", \"DL2_CH1 Switch\", \"DL2\"},\n\t{\"PCM_1_PB_CH2\", \"DL2_CH2 Switch\", \"DL2\"},\n\n\t{\"PCM_1_PB_CH1\", \"DL4_CH1 Switch\", \"DL4\"},\n\t{\"PCM_1_PB_CH2\", \"DL4_CH2 Switch\", \"DL4\"},\n\n\t \n\t{\"PCM_Out_Lpbk_Mux\", \"Lpbk\", \"PCM 1 Playback\"},\n\t{\"I2S0\", NULL, \"PCM_Out_Lpbk_Mux\"},\n\n\t \n\t{\"PCM_In_Lpbk_Mux\", \"Lpbk\", \"PCM 1 Capture\"},\n\t{\"I2S3\", NULL, \"PCM_In_Lpbk_Mux\"},\n};\n\n \nstatic int mtk_dai_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct snd_soc_dapm_widget *p = snd_soc_dai_get_widget_playback(dai);\n\tstruct snd_soc_dapm_widget *c = snd_soc_dai_get_widget_capture(dai);\n\tint pcm_id = dai->id;\n\tstruct mtk_afe_pcm_priv *pcm_priv = afe_priv->dai_priv[pcm_id];\n\tunsigned int rate = params_rate(params);\n\tunsigned int rate_reg = mt8186_rate_transform(afe->dev, rate, dai->id);\n\tsnd_pcm_format_t format = params_format(params);\n\tunsigned int data_width =\n\t\tsnd_pcm_format_width(format);\n\tunsigned int wlen_width =\n\t\tsnd_pcm_format_physical_width(format);\n\tunsigned int pcm_con = 0;\n\n\tdev_dbg(afe->dev, \"%s(), id %d, stream %d, widget active p %d, c %d\\n\",\n\t\t__func__, dai->id, substream->stream, p->active, c->active);\n\tdev_dbg(afe->dev, \"%s(), rate %d, rate_reg %d, data_width %d, wlen_width %d\\n\",\n\t\t__func__, rate, rate_reg, data_width, wlen_width);\n\n\tif (p->active || c->active)\n\t\treturn 0;\n\n\tswitch (dai->id) {\n\tcase MT8186_DAI_PCM:\n\t\tpcm_con |= AUD_TX_LCH_RPT_NO_REPEAT << PCM_TX_LCH_RPT_SFT;\n\t\tpcm_con |= AUD_VBT_16K_MODE_DISABLE << PCM_VBT_16K_MODE_SFT;\n\t\tpcm_con |= AUD_EXT_MODEM_SELECT_EXTERNAL << PCM_EXT_MODEM_SFT;\n\t\tpcm_con |= AUD_PCM_ONE_BCK_CYCLE_SYNC << PCM_SYNC_TYPE_SFT;\n\t\tpcm_con |= AUD_BT_MODE_DUAL_MIC_ON_TX << PCM_BT_MODE_SFT;\n\t\tpcm_con |= AUD_PCM_AFIFO_AFIFO << PCM_BYP_ASRC_SFT;\n\t\tpcm_con |= AUD_PCM_CLOCK_MASTER_MODE << PCM_SLAVE_SFT;\n\t\tpcm_con |= 0 << PCM_SYNC_LENGTH_SFT;\n\n\t\t \n\t\tpcm_con |= rate_reg << PCM_MODE_SFT;\n\n\t\t \n\t\tpcm_con |= pcm_priv->fmt << PCM_FMT_SFT;\n\n\t\t \n\t\tif (data_width > 16)\n\t\t\tpcm_con |= AUD_PCM_24BIT_PCM_24_BITS << PCM_24BIT_SFT;\n\t\telse\n\t\t\tpcm_con |= AUD_PCM_24BIT_PCM_16_BITS << PCM_24BIT_SFT;\n\n\t\t \n\t\tif (wlen_width > 16)\n\t\t\tpcm_con |= AUD_PCM_WLEN_PCM_64_BCK_CYCLES << PCM_WLEN_SFT;\n\t\telse\n\t\t\tpcm_con |= AUD_PCM_WLEN_PCM_32_BCK_CYCLES << PCM_WLEN_SFT;\n\n\t\t \n\t\tpcm_con |= pcm_priv->lck_invert << PCM_SYNC_OUT_INV_SFT;\n\t\tpcm_con |= pcm_priv->bck_invert << PCM_BCLK_OUT_INV_SFT;\n\n\t\tregmap_update_bits(afe->regmap, PCM_INTF_CON1, 0xfffffffe, pcm_con);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(afe->dev, \"%s(), id %d not support\\n\", __func__, dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dai_pcm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_pcm_priv *pcm_priv = afe_priv->dai_priv[dai->id];\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpcm_priv->fmt = AUD_PCM_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tpcm_priv->fmt = AUD_PCM_FMT_EIAJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tpcm_priv->fmt = AUD_PCM_FMT_PCM_MODE_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tpcm_priv->fmt = AUD_PCM_FMT_PCM_MODE_B;\n\t\tbreak;\n\tdefault:\n\t\tpcm_priv->fmt = AUD_PCM_FMT_I2S;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_NO_INVERSE;\n\t\tpcm_priv->lck_invert = AUD_LRCLK_OUT_INV_NO_INVERSE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_NO_INVERSE;\n\t\tpcm_priv->lck_invert = AUD_BCLK_OUT_INV_INVERSE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_INVERSE;\n\t\tpcm_priv->lck_invert = AUD_LRCLK_OUT_INV_NO_INVERSE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_INVERSE;\n\t\tpcm_priv->lck_invert = AUD_BCLK_OUT_INV_INVERSE;\n\t\tbreak;\n\tdefault:\n\t\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_NO_INVERSE;\n\t\tpcm_priv->lck_invert = AUD_LRCLK_OUT_INV_NO_INVERSE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mtk_dai_pcm_ops = {\n\t.hw_params = mtk_dai_pcm_hw_params,\n\t.set_fmt = mtk_dai_pcm_set_fmt,\n};\n\n \n#define MTK_PCM_RATES (SNDRV_PCM_RATE_8000 |\\\n\t\t       SNDRV_PCM_RATE_16000 |\\\n\t\t       SNDRV_PCM_RATE_32000 |\\\n\t\t       SNDRV_PCM_RATE_48000)\n\n#define MTK_PCM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mtk_dai_pcm_driver[] = {\n\t{\n\t\t.name = \"PCM 1\",\n\t\t.id = MT8186_DAI_PCM,\n\t\t.playback = {\n\t\t\t.stream_name = \"PCM 1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_PCM_RATES,\n\t\t\t.formats = MTK_PCM_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"PCM 1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_PCM_RATES,\n\t\t\t.formats = MTK_PCM_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_pcm_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n};\n\nstatic struct mtk_afe_pcm_priv *init_pcm_priv_data(struct mtk_base_afe *afe)\n{\n\tstruct mtk_afe_pcm_priv *pcm_priv;\n\n\tpcm_priv = devm_kzalloc(afe->dev, sizeof(struct mtk_afe_pcm_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcm_priv)\n\t\treturn NULL;\n\n\tpcm_priv->id = MT8186_DAI_PCM;\n\tpcm_priv->fmt = AUD_PCM_FMT_I2S;\n\tpcm_priv->bck_invert = AUD_BCLK_OUT_INV_NO_INVERSE;\n\tpcm_priv->lck_invert = AUD_LRCLK_OUT_INV_NO_INVERSE;\n\n\treturn pcm_priv;\n}\n\nint mt8186_dai_pcm_register(struct mtk_base_afe *afe)\n{\n\tstruct mt8186_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_afe_pcm_priv *pcm_priv;\n\tstruct mtk_base_afe_dai *dai;\n\n\tdai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tlist_add(&dai->list, &afe->sub_dais);\n\n\tdai->dai_drivers = mtk_dai_pcm_driver;\n\tdai->num_dai_drivers = ARRAY_SIZE(mtk_dai_pcm_driver);\n\n\tdai->dapm_widgets = mtk_dai_pcm_widgets;\n\tdai->num_dapm_widgets = ARRAY_SIZE(mtk_dai_pcm_widgets);\n\tdai->dapm_routes = mtk_dai_pcm_routes;\n\tdai->num_dapm_routes = ARRAY_SIZE(mtk_dai_pcm_routes);\n\n\tpcm_priv = init_pcm_priv_data(afe);\n\tif (!pcm_priv)\n\t\treturn -ENOMEM;\n\n\tafe_priv->dai_priv[MT8186_DAI_PCM] = pcm_priv;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}