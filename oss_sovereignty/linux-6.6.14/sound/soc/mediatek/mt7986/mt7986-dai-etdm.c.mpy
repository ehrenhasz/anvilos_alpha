{
  "module_name": "mt7986-dai-etdm.c",
  "hash_id": "2f54d15b833b4fd781b46a128433fcde8a28f29c30cadf1ca854ee66ceea33b9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt7986/mt7986-dai-etdm.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include \"mt7986-afe-common.h\"\n#include \"mt7986-reg.h\"\n\n#define HOPPING_CLK  0\n#define APLL_CLK     1\n#define MTK_DAI_ETDM_FORMAT_I2S   0\n#define MTK_DAI_ETDM_FORMAT_DSPA  4\n#define MTK_DAI_ETDM_FORMAT_DSPB  5\n\nenum {\n\tMTK_ETDM_RATE_8K = 0,\n\tMTK_ETDM_RATE_12K = 1,\n\tMTK_ETDM_RATE_16K = 2,\n\tMTK_ETDM_RATE_24K = 3,\n\tMTK_ETDM_RATE_32K = 4,\n\tMTK_ETDM_RATE_48K = 5,\n\tMTK_ETDM_RATE_96K = 7,\n\tMTK_ETDM_RATE_192K = 9,\n\tMTK_ETDM_RATE_11K = 16,\n\tMTK_ETDM_RATE_22K = 17,\n\tMTK_ETDM_RATE_44K = 18,\n\tMTK_ETDM_RATE_88K = 19,\n\tMTK_ETDM_RATE_176K = 20,\n};\n\nstruct mtk_dai_etdm_priv {\n\tbool bck_inv;\n\tbool lrck_inv;\n\tbool slave_mode;\n\tunsigned int format;\n};\n\nstatic unsigned int mt7986_etdm_rate_transform(struct device *dev, unsigned int rate)\n{\n\tswitch (rate) {\n\tcase 8000:\n\t\treturn MTK_ETDM_RATE_8K;\n\tcase 11025:\n\t\treturn MTK_ETDM_RATE_11K;\n\tcase 12000:\n\t\treturn MTK_ETDM_RATE_12K;\n\tcase 16000:\n\t\treturn MTK_ETDM_RATE_16K;\n\tcase 22050:\n\t\treturn MTK_ETDM_RATE_22K;\n\tcase 24000:\n\t\treturn MTK_ETDM_RATE_24K;\n\tcase 32000:\n\t\treturn MTK_ETDM_RATE_32K;\n\tcase 44100:\n\t\treturn MTK_ETDM_RATE_44K;\n\tcase 48000:\n\t\treturn MTK_ETDM_RATE_48K;\n\tcase 88200:\n\t\treturn MTK_ETDM_RATE_88K;\n\tcase 96000:\n\t\treturn MTK_ETDM_RATE_96K;\n\tcase 176400:\n\t\treturn MTK_ETDM_RATE_176K;\n\tcase 192000:\n\t\treturn MTK_ETDM_RATE_192K;\n\tdefault:\n\t\tdev_warn(dev, \"%s(), rate %u invalid, using %d!!!\\n\",\n\t\t\t __func__, rate, MTK_ETDM_RATE_48K);\n\t\treturn MTK_ETDM_RATE_48K;\n\t}\n}\n\nstatic int get_etdm_wlen(unsigned int bitwidth)\n{\n\treturn bitwidth <= 16 ? 16 : 32;\n}\n\n \n \n\nstatic const struct snd_kcontrol_new o124_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I032_Switch\", AFE_CONN124_1, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new o125_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I033_Switch\", AFE_CONN125_1, 1, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget mtk_dai_etdm_widgets[] = {\n\n\t \n\tSND_SOC_DAPM_MIXER(\"I150\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"I151\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_MIXER(\"O124\", SND_SOC_NOPM, 0, 0, o124_mix, ARRAY_SIZE(o124_mix)),\n\tSND_SOC_DAPM_MIXER(\"O125\", SND_SOC_NOPM, 0, 0, o125_mix, ARRAY_SIZE(o125_mix)),\n};\n\nstatic const struct snd_soc_dapm_route mtk_dai_etdm_routes[] = {\n\t{\"I150\", NULL, \"ETDM Capture\"},\n\t{\"I151\", NULL, \"ETDM Capture\"},\n\t{\"ETDM Playback\", NULL, \"O124\"},\n\t{\"ETDM Playback\", NULL, \"O125\"},\n\t{\"O124\", \"I032_Switch\", \"I032\"},\n\t{\"O125\", \"I033_Switch\", \"I033\"},\n};\n\n \nstatic int mtk_dai_etdm_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt7986_afe_private *afe_priv = afe->platform_priv;\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(afe_priv->num_clks, afe_priv->clks);\n\tif (ret)\n\t\treturn dev_err_probe(afe->dev, ret, \"Failed to enable clocks\\n\");\n\n\tregmap_update_bits(afe->regmap, AUDIO_TOP_CON2, CLK_OUT5_PDN_MASK, 0);\n\tregmap_update_bits(afe->regmap, AUDIO_TOP_CON2, CLK_IN5_PDN_MASK, 0);\n\n\treturn 0;\n}\n\nstatic void mtk_dai_etdm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt7986_afe_private *afe_priv = afe->platform_priv;\n\n\tregmap_update_bits(afe->regmap, AUDIO_TOP_CON2, CLK_OUT5_PDN_MASK,\n\t\t\t   CLK_OUT5_PDN);\n\tregmap_update_bits(afe->regmap, AUDIO_TOP_CON2, CLK_IN5_PDN_MASK,\n\t\t\t   CLK_IN5_PDN);\n\n\tclk_bulk_disable_unprepare(afe_priv->num_clks, afe_priv->clks);\n}\n\nstatic unsigned int get_etdm_ch_fixup(unsigned int channels)\n{\n\tif (channels > 16)\n\t\treturn 24;\n\telse if (channels > 8)\n\t\treturn 16;\n\telse if (channels > 4)\n\t\treturn 8;\n\telse if (channels > 2)\n\t\treturn 4;\n\telse\n\t\treturn 2;\n}\n\nstatic int mtk_dai_etdm_config(struct mtk_base_afe *afe,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai,\n\t\t\t       int stream)\n{\n\tstruct mt7986_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_dai_etdm_priv *etdm_data = afe_priv->dai_priv[dai->id];\n\tunsigned int rate = params_rate(params);\n\tunsigned int etdm_rate = mt7986_etdm_rate_transform(afe->dev, rate);\n\tunsigned int afe_rate = mt7986_afe_rate_transform(afe->dev, rate);\n\tunsigned int channels = params_channels(params);\n\tunsigned int bit_width = params_width(params);\n\tunsigned int wlen = get_etdm_wlen(bit_width);\n\tunsigned int val = 0;\n\tunsigned int mask = 0;\n\n\tdev_dbg(afe->dev, \"%s(), stream %d, rate %u, bitwidth %u\\n\",\n\t\t __func__, stream, rate, bit_width);\n\n\t \n\tmask |= ETDM_BIT_LEN_MASK;\n\tval |= FIELD_PREP(ETDM_BIT_LEN_MASK, bit_width - 1);\n\tmask |= ETDM_WRD_LEN_MASK;\n\tval |= FIELD_PREP(ETDM_WRD_LEN_MASK, wlen - 1);\n\tmask |= ETDM_FMT_MASK;\n\tval |= FIELD_PREP(ETDM_FMT_MASK, etdm_data->format);\n\tmask |= ETDM_CH_NUM_MASK;\n\tval |= FIELD_PREP(ETDM_CH_NUM_MASK, get_etdm_ch_fixup(channels) - 1);\n\tmask |= RELATCH_SRC_MASK;\n\tval |= FIELD_PREP(RELATCH_SRC_MASK, APLL_CLK);\n\n\tswitch (stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON0, mask, val);\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON4,\n\t\t\t\t   OUT_RELATCH_MASK, OUT_RELATCH(afe_rate));\n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON4,\n\t\t\t\t   OUT_CLK_SRC_MASK, OUT_CLK_SRC(APLL_CLK));\n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON4,\n\t\t\t\t   OUT_SEL_FS_MASK, OUT_SEL_FS(etdm_rate));\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON5,\n\t\t\t\t   ETDM_CLK_DIV_MASK, ETDM_CLK_DIV);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON0, mask, val);\n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON0,\n\t\t\t\t   ETDM_SYNC_MASK, ETDM_SYNC);\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON2,\n\t\t\t\t   IN_CLK_SRC_MASK, IN_CLK_SRC(APLL_CLK));\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON3,\n\t\t\t\t   IN_SEL_FS_MASK, IN_SEL_FS(etdm_rate));\n\n\t\t \n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON4,\n\t\t\t\t   IN_RELATCH_MASK, IN_RELATCH(afe_rate));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dai_etdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\n\tmtk_dai_etdm_config(afe, params, dai, SNDRV_PCM_STREAM_PLAYBACK);\n\tmtk_dai_etdm_config(afe, params, dai, SNDRV_PCM_STREAM_CAPTURE);\n\n\treturn 0;\n}\n\nstatic int mtk_dai_etdm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\n\tdev_dbg(afe->dev, \"%s(), cmd %d, dai id %d\\n\", __func__, cmd, dai->id);\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_EN_MASK,\n\t\t\t\t   ETDM_EN);\n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_EN_MASK,\n\t\t\t\t   ETDM_EN);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tregmap_update_bits(afe->regmap, ETDM_IN5_CON0, ETDM_EN_MASK,\n\t\t\t\t   0);\n\t\tregmap_update_bits(afe->regmap, ETDM_OUT5_CON0, ETDM_EN_MASK,\n\t\t\t\t   0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_dai_etdm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt7986_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_dai_etdm_priv *etdm_data;\n\tvoid *priv_data;\n\n\tswitch (dai->id) {\n\tcase MT7986_DAI_ETDM:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(afe->dev, \"%s(), id %d not support\\n\",\n\t\t\t __func__, dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv_data = devm_kzalloc(afe->dev, sizeof(struct mtk_dai_etdm_priv),\n\t\t\t\t GFP_KERNEL);\n\tif (!priv_data)\n\t\treturn -ENOMEM;\n\n\tafe_priv->dai_priv[dai->id] = priv_data;\n\tetdm_data = afe_priv->dai_priv[dai->id];\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tetdm_data->format = MTK_DAI_ETDM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tetdm_data->format = MTK_DAI_ETDM_FORMAT_DSPA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tetdm_data->format = MTK_DAI_ETDM_FORMAT_DSPB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tetdm_data->bck_inv = false;\n\t\tetdm_data->lrck_inv = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tetdm_data->bck_inv = false;\n\t\tetdm_data->lrck_inv = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tetdm_data->bck_inv = true;\n\t\tetdm_data->lrck_inv = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tetdm_data->bck_inv = true;\n\t\tetdm_data->lrck_inv = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tetdm_data->slave_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tetdm_data->slave_mode = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mtk_dai_etdm_ops = {\n\t.startup = mtk_dai_etdm_startup,\n\t.shutdown = mtk_dai_etdm_shutdown,\n\t.hw_params = mtk_dai_etdm_hw_params,\n\t.trigger = mtk_dai_etdm_trigger,\n\t.set_fmt = mtk_dai_etdm_set_fmt,\n};\n\n \n#define MTK_ETDM_RATES (SNDRV_PCM_RATE_8000_48000 |\\\n\t\t\tSNDRV_PCM_RATE_88200 |\\\n\t\t\tSNDRV_PCM_RATE_96000 |\\\n\t\t\tSNDRV_PCM_RATE_176400 |\\\n\t\t\tSNDRV_PCM_RATE_192000)\n\n#define MTK_ETDM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t  SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mtk_dai_etdm_driver[] = {\n\t{\n\t\t.name = \"ETDM\",\n\t\t.id = MT7986_DAI_ETDM,\n\t\t.capture = {\n\t\t\t.stream_name = \"ETDM Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_ETDM_RATES,\n\t\t\t.formats = MTK_ETDM_FORMATS,\n\t\t},\n\t\t.playback = {\n\t\t\t.stream_name = \"ETDM Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_ETDM_RATES,\n\t\t\t.formats = MTK_ETDM_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_etdm_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n};\n\nint mt7986_dai_etdm_register(struct mtk_base_afe *afe)\n{\n\tstruct mtk_base_afe_dai *dai;\n\n\tdai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tlist_add(&dai->list, &afe->sub_dais);\n\n\tdai->dai_drivers = mtk_dai_etdm_driver;\n\tdai->num_dai_drivers = ARRAY_SIZE(mtk_dai_etdm_driver);\n\n\tdai->dapm_widgets = mtk_dai_etdm_widgets;\n\tdai->num_dapm_widgets = ARRAY_SIZE(mtk_dai_etdm_widgets);\n\tdai->dapm_routes = mtk_dai_etdm_routes;\n\tdai->num_dapm_routes = ARRAY_SIZE(mtk_dai_etdm_routes);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}