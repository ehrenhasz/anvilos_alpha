{
  "module_name": "mt8195-dai-pcm.c",
  "hash_id": "91940ce86a9db2682b916eaa4a2dd6cd72af44b0b0dc899ad3bcf724e9f36a9e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt8195/mt8195-dai-pcm.c",
  "human_readable_source": "\n \n\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include \"mt8195-afe-clk.h\"\n#include \"mt8195-afe-common.h\"\n#include \"mt8195-reg.h\"\n\nenum {\n\tMTK_DAI_PCM_FMT_I2S,\n\tMTK_DAI_PCM_FMT_EIAJ,\n\tMTK_DAI_PCM_FMT_MODEA,\n\tMTK_DAI_PCM_FMT_MODEB,\n};\n\nenum {\n\tMTK_DAI_PCM_CLK_A1SYS,\n\tMTK_DAI_PCM_CLK_A2SYS,\n\tMTK_DAI_PCM_CLK_26M_48K,\n\tMTK_DAI_PCM_CLK_26M_441K,\n};\n\nstruct mtk_dai_pcm_rate {\n\tunsigned int rate;\n\tunsigned int reg_value;\n};\n\nstruct mtk_dai_pcmif_priv {\n\tunsigned int slave_mode;\n\tunsigned int lrck_inv;\n\tunsigned int bck_inv;\n\tunsigned int format;\n};\n\nstatic const struct mtk_dai_pcm_rate mtk_dai_pcm_rates[] = {\n\t{ .rate = 8000, .reg_value = 0, },\n\t{ .rate = 16000, .reg_value = 1, },\n\t{ .rate = 32000, .reg_value = 2, },\n\t{ .rate = 48000, .reg_value = 3, },\n\t{ .rate = 11025, .reg_value = 1, },\n\t{ .rate = 22050, .reg_value = 2, },\n\t{ .rate = 44100, .reg_value = 3, },\n};\n\nstatic int mtk_dai_pcm_mode(unsigned int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtk_dai_pcm_rates); i++)\n\t\tif (mtk_dai_pcm_rates[i].rate == rate)\n\t\t\treturn mtk_dai_pcm_rates[i].reg_value;\n\n\treturn -EINVAL;\n}\n\nstatic const struct snd_kcontrol_new mtk_dai_pcm_o000_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I000 Switch\", AFE_CONN0, 0, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I070 Switch\", AFE_CONN0_2, 6, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mtk_dai_pcm_o001_mix[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I001 Switch\", AFE_CONN1, 1, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"I071 Switch\", AFE_CONN1_2, 7, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget mtk_dai_pcm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"I002\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"I003\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"O000\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_dai_pcm_o000_mix,\n\t\t\t   ARRAY_SIZE(mtk_dai_pcm_o000_mix)),\n\tSND_SOC_DAPM_MIXER(\"O001\", SND_SOC_NOPM, 0, 0,\n\t\t\t   mtk_dai_pcm_o001_mix,\n\t\t\t   ARRAY_SIZE(mtk_dai_pcm_o001_mix)),\n\n\tSND_SOC_DAPM_SUPPLY(\"PCM_EN\", PCM_INTF_CON1,\n\t\t\t    PCM_INTF_CON1_PCM_EN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"PCM1_INPUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"PCM1_OUTPUT\"),\n\n\tSND_SOC_DAPM_CLOCK_SUPPLY(\"aud_asrc11\"),\n\tSND_SOC_DAPM_CLOCK_SUPPLY(\"aud_asrc12\"),\n\tSND_SOC_DAPM_CLOCK_SUPPLY(\"aud_pcmif\"),\n};\n\nstatic const struct snd_soc_dapm_route mtk_dai_pcm_routes[] = {\n\t{\"I002\", NULL, \"PCM1 Capture\"},\n\t{\"I003\", NULL, \"PCM1 Capture\"},\n\n\t{\"O000\", \"I000 Switch\", \"I000\"},\n\t{\"O001\", \"I001 Switch\", \"I001\"},\n\n\t{\"O000\", \"I070 Switch\", \"I070\"},\n\t{\"O001\", \"I071 Switch\", \"I071\"},\n\n\t{\"PCM1 Playback\", NULL, \"O000\"},\n\t{\"PCM1 Playback\", NULL, \"O001\"},\n\n\t{\"PCM1 Playback\", NULL, \"PCM_EN\"},\n\t{\"PCM1 Playback\", NULL, \"aud_asrc12\"},\n\t{\"PCM1 Playback\", NULL, \"aud_pcmif\"},\n\n\t{\"PCM1 Capture\", NULL, \"PCM_EN\"},\n\t{\"PCM1 Capture\", NULL, \"aud_asrc11\"},\n\t{\"PCM1 Capture\", NULL, \"aud_pcmif\"},\n\n\t{\"PCM1_OUTPUT\", NULL, \"PCM1 Playback\"},\n\t{\"PCM1 Capture\", NULL, \"PCM1_INPUT\"},\n};\n\nstatic int mtk_dai_pcm_configure(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime * const runtime = substream->runtime;\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt8195_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_dai_pcmif_priv *pcmif_priv;\n\tunsigned int slave_mode;\n\tunsigned int lrck_inv;\n\tunsigned int bck_inv;\n\tunsigned int fmt;\n\tunsigned int bit_width = dai->sample_bits;\n\tunsigned int val = 0;\n\tunsigned int mask = 0;\n\tint fs = 0;\n\tint mode = 0;\n\n\tif (dai->id != MT8195_AFE_IO_PCM)\n\t\treturn -EINVAL;\n\n\tpcmif_priv = afe_priv->dai_priv[dai->id];\n\tslave_mode = pcmif_priv->slave_mode;\n\tlrck_inv = pcmif_priv->lrck_inv;\n\tbck_inv = pcmif_priv->bck_inv;\n\tfmt = pcmif_priv->format;\n\n\t \n\tfs = mt8195_afe_fs_timing(runtime->rate);\n\tif (fs < 0)\n\t\treturn -EINVAL;\n\tval |= PCM_INTF_CON2_SYNC_FREQ_MODE(fs);\n\tmask |= PCM_INTF_CON2_SYNC_FREQ_MODE_MASK;\n\n\t \n\tif (runtime->rate % 8000)\n\t\tval |= PCM_INTF_CON2_CLK_DOMAIN_SEL(MTK_DAI_PCM_CLK_26M_441K);\n\telse\n\t\tval |= PCM_INTF_CON2_CLK_DOMAIN_SEL(MTK_DAI_PCM_CLK_26M_48K);\n\tmask |= PCM_INTF_CON2_CLK_DOMAIN_SEL_MASK;\n\n\tregmap_update_bits(afe->regmap, PCM_INTF_CON2, mask, val);\n\n\tval = 0;\n\tmask = 0;\n\n\t \n\tmode = mtk_dai_pcm_mode(runtime->rate);\n\tif (mode < 0)\n\t\treturn -EINVAL;\n\tval |= PCM_INTF_CON1_PCM_MODE(mode);\n\tmask |= PCM_INTF_CON1_PCM_MODE_MASK;\n\n\t \n\tval |= PCM_INTF_CON1_PCM_FMT(fmt);\n\tmask |= PCM_INTF_CON1_PCM_FMT_MASK;\n\n\t \n\tif (fmt == MTK_DAI_PCM_FMT_MODEA ||\n\t    fmt == MTK_DAI_PCM_FMT_MODEB)\n\t\tval |= PCM_INTF_CON1_SYNC_LENGTH(1);\n\telse\n\t\tval |= PCM_INTF_CON1_SYNC_LENGTH(bit_width);\n\tmask |= PCM_INTF_CON1_SYNC_LENGTH_MASK;\n\n\t \n\tif (bit_width > 16) {\n\t\tval |= PCM_INTF_CON1_PCM_24BIT;\n\t\tval |= PCM_INTF_CON1_PCM_WLEN_64BCK;\n\t} else {\n\t\tval |= PCM_INTF_CON1_PCM_16BIT;\n\t\tval |= PCM_INTF_CON1_PCM_WLEN_32BCK;\n\t}\n\tmask |= PCM_INTF_CON1_PCM_BIT_MASK;\n\tmask |= PCM_INTF_CON1_PCM_WLEN_MASK;\n\n\t \n\tif (!slave_mode) {\n\t\tval |= PCM_INTF_CON1_PCM_MASTER;\n\n\t\tif (lrck_inv)\n\t\t\tval |= PCM_INTF_CON1_SYNC_OUT_INV;\n\t\tif (bck_inv)\n\t\t\tval |= PCM_INTF_CON1_BCLK_OUT_INV;\n\t\tmask |= PCM_INTF_CON1_CLK_OUT_INV_MASK;\n\t} else {\n\t\tval |= PCM_INTF_CON1_PCM_SLAVE;\n\n\t\tif (lrck_inv)\n\t\t\tval |= PCM_INTF_CON1_SYNC_IN_INV;\n\t\tif (bck_inv)\n\t\t\tval |= PCM_INTF_CON1_BCLK_IN_INV;\n\t\tmask |= PCM_INTF_CON1_CLK_IN_INV_MASK;\n\n\t\t \n\t}\n\tmask |= PCM_INTF_CON1_PCM_M_S_MASK;\n\n\tregmap_update_bits(afe->regmap, PCM_INTF_CON1, mask, val);\n\n\treturn 0;\n}\n\n \nstatic int mtk_dai_pcm_prepare(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dapm_widget *p = snd_soc_dai_get_widget_playback(dai);\n\tstruct snd_soc_dapm_widget *c = snd_soc_dai_get_widget_capture(dai);\n\n\tdev_dbg(dai->dev, \"%s(), id %d, stream %d, widget active p %d, c %d\\n\",\n\t\t__func__, dai->id, substream->stream,\n\t\tp->active, c->active);\n\n\tif (p->active || c->active)\n\t\treturn 0;\n\n\treturn mtk_dai_pcm_configure(substream, dai);\n}\n\nstatic int mtk_dai_pcm_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mt8195_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_dai_pcmif_priv *pcmif_priv;\n\n\tdev_dbg(dai->dev, \"%s fmt 0x%x\\n\", __func__, fmt);\n\n\tif (dai->id != MT8195_AFE_IO_PCM)\n\t\treturn -EINVAL;\n\n\tpcmif_priv = afe_priv->dai_priv[dai->id];\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpcmif_priv->format = MTK_DAI_PCM_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tpcmif_priv->format = MTK_DAI_PCM_FMT_MODEA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tpcmif_priv->format = MTK_DAI_PCM_FMT_MODEB;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tpcmif_priv->bck_inv = 0;\n\t\tpcmif_priv->lrck_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tpcmif_priv->bck_inv = 0;\n\t\tpcmif_priv->lrck_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tpcmif_priv->bck_inv = 1;\n\t\tpcmif_priv->lrck_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tpcmif_priv->bck_inv = 1;\n\t\tpcmif_priv->lrck_inv = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tpcmif_priv->slave_mode = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tpcmif_priv->slave_mode = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mtk_dai_pcm_ops = {\n\t.prepare\t= mtk_dai_pcm_prepare,\n\t.set_fmt\t= mtk_dai_pcm_set_fmt,\n};\n\n \n#define MTK_PCM_RATES (SNDRV_PCM_RATE_8000_48000)\n\n#define MTK_PCM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver mtk_dai_pcm_driver[] = {\n\t{\n\t\t.name = \"PCM1\",\n\t\t.id = MT8195_AFE_IO_PCM,\n\t\t.playback = {\n\t\t\t.stream_name = \"PCM1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_PCM_RATES,\n\t\t\t.formats = MTK_PCM_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"PCM1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MTK_PCM_RATES,\n\t\t\t.formats = MTK_PCM_FORMATS,\n\t\t},\n\t\t.ops = &mtk_dai_pcm_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n};\n\nstatic int init_pcmif_priv_data(struct mtk_base_afe *afe)\n{\n\tstruct mt8195_afe_private *afe_priv = afe->platform_priv;\n\tstruct mtk_dai_pcmif_priv *pcmif_priv;\n\n\tpcmif_priv = devm_kzalloc(afe->dev, sizeof(struct mtk_dai_pcmif_priv),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pcmif_priv)\n\t\treturn -ENOMEM;\n\n\tafe_priv->dai_priv[MT8195_AFE_IO_PCM] = pcmif_priv;\n\treturn 0;\n}\n\nint mt8195_dai_pcm_register(struct mtk_base_afe *afe)\n{\n\tstruct mtk_base_afe_dai *dai;\n\n\tdai = devm_kzalloc(afe->dev, sizeof(*dai), GFP_KERNEL);\n\tif (!dai)\n\t\treturn -ENOMEM;\n\n\tlist_add(&dai->list, &afe->sub_dais);\n\n\tdai->dai_drivers = mtk_dai_pcm_driver;\n\tdai->num_dai_drivers = ARRAY_SIZE(mtk_dai_pcm_driver);\n\n\tdai->dapm_widgets = mtk_dai_pcm_widgets;\n\tdai->num_dapm_widgets = ARRAY_SIZE(mtk_dai_pcm_widgets);\n\tdai->dapm_routes = mtk_dai_pcm_routes;\n\tdai->num_dapm_routes = ARRAY_SIZE(mtk_dai_pcm_routes);\n\n\treturn init_pcmif_priv_data(afe);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}