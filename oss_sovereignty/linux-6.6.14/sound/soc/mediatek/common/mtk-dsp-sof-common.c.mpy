{
  "module_name": "mtk-dsp-sof-common.c",
  "hash_id": "91501421ba8223530bf8f64fa3a995cfab1fae21b8048fa2eecc2dc2c8b4a9c0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/common/mtk-dsp-sof-common.c",
  "human_readable_source": "\n \n\n#include \"mtk-dsp-sof-common.h\"\n#include \"mtk-soc-card.h\"\n\n \nint mtk_sof_dai_link_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct mtk_soc_card_data *soc_card_data = snd_soc_card_get_drvdata(card);\n\tstruct mtk_sof_priv *sof_priv = soc_card_data->sof_priv;\n\tint i, j, ret = 0;\n\n\tfor (i = 0; i < sof_priv->num_streams; i++) {\n\t\tstruct snd_soc_dai *cpu_dai;\n\t\tstruct snd_soc_pcm_runtime *runtime;\n\t\tstruct snd_soc_dai_link *sof_dai_link = NULL;\n\t\tconst struct sof_conn_stream *conn = &sof_priv->conn_streams[i];\n\n\t\tif (conn->normal_link && strcmp(rtd->dai_link->name, conn->normal_link))\n\t\t\tcontinue;\n\n\t\tfor_each_card_rtds(card, runtime) {\n\t\t\tif (strcmp(runtime->dai_link->name, conn->sof_link))\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_rtd_cpu_dais(runtime, j, cpu_dai) {\n\t\t\t\tif (snd_soc_dai_stream_active(cpu_dai, conn->stream_dir) > 0) {\n\t\t\t\t\tsof_dai_link = runtime->dai_link;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sof_dai_link && sof_dai_link->be_hw_params_fixup)\n\t\t\tret = sof_dai_link->be_hw_params_fixup(runtime, params);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtk_sof_dai_link_fixup);\n\nint mtk_sof_card_probe(struct snd_soc_card *card)\n{\n\tint i;\n\tstruct snd_soc_dai_link *dai_link;\n\n\t \n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tif (dai_link->no_pcm && !dai_link->stream_name && dai_link->name)\n\t\t\tdai_link->stream_name = dai_link->name;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_sof_card_probe);\n\nint mtk_sof_card_late_probe(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_component *sof_comp = NULL;\n\tstruct mtk_soc_card_data *soc_card_data =\n\t\tsnd_soc_card_get_drvdata(card);\n\tstruct mtk_sof_priv *sof_priv = soc_card_data->sof_priv;\n\tint i;\n\n\t \n\tfor_each_card_rtds(card, rtd) {\n\t\tsof_comp = snd_soc_rtdcom_lookup(rtd, \"sof-audio-component\");\n\t\tif (sof_comp)\n\t\t\tbreak;\n\t}\n\n\tif (!sof_comp) {\n\t\tdev_info(card->dev, \"probe without sof-audio-component\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < sof_priv->num_streams; i++) {\n\t\tconst struct sof_conn_stream *conn = &sof_priv->conn_streams[i];\n\t\tstruct snd_soc_pcm_runtime *sof_rtd = NULL;\n\t\tstruct snd_soc_pcm_runtime *normal_rtd = NULL;\n\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\tif (!strcmp(rtd->dai_link->name, conn->sof_link)) {\n\t\t\t\tsof_rtd = rtd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!strcmp(rtd->dai_link->name, conn->normal_link)) {\n\t\t\t\tnormal_rtd = rtd;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (normal_rtd && sof_rtd)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (normal_rtd && sof_rtd) {\n\t\t\tint j;\n\t\t\tstruct snd_soc_dai *cpu_dai;\n\n\t\t\tfor_each_rtd_cpu_dais(sof_rtd, j, cpu_dai) {\n\t\t\t\tstruct snd_soc_dapm_route route;\n\t\t\t\tstruct snd_soc_dapm_path *p = NULL;\n\t\t\t\tstruct snd_soc_dapm_widget *widget = snd_soc_dai_get_widget(cpu_dai, conn->stream_dir);\n\n\t\t\t\tmemset(&route, 0, sizeof(route));\n\t\t\t\tif (conn->stream_dir == SNDRV_PCM_STREAM_CAPTURE && widget) {\n\t\t\t\t\tsnd_soc_dapm_widget_for_each_sink_path(widget, p) {\n\t\t\t\t\t\troute.source = conn->sof_dma;\n\t\t\t\t\t\troute.sink = p->sink->name;\n\t\t\t\t\t\tsnd_soc_dapm_add_routes(&card->dapm, &route, 1);\n\t\t\t\t\t}\n\t\t\t\t} else if (conn->stream_dir == SNDRV_PCM_STREAM_PLAYBACK && widget) {\n\t\t\t\t\tsnd_soc_dapm_widget_for_each_source_path(widget, p) {\n\t\t\t\t\t\troute.source = p->source->name;\n\t\t\t\t\t\troute.sink = conn->sof_dma;\n\t\t\t\t\t\tsnd_soc_dapm_add_routes(&card->dapm, &route, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdev_err(cpu_dai->dev, \"stream dir and widget not pair\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsof_rtd->dai_link->be_hw_params_fixup =\n\t\t\t\tsof_comp->driver->be_hw_params_fixup;\n\t\t\tif (sof_priv->sof_dai_link_fixup)\n\t\t\t\tnormal_rtd->dai_link->be_hw_params_fixup =\n\t\t\t\t\tsof_priv->sof_dai_link_fixup;\n\t\t\telse\n\t\t\t\tnormal_rtd->dai_link->be_hw_params_fixup = mtk_sof_dai_link_fixup;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_sof_card_late_probe);\n\nint mtk_sof_dailink_parse_of(struct snd_soc_card *card, struct device_node *np,\n\t\t\t     const char *propname, struct snd_soc_dai_link *pre_dai_links,\n\t\t\t     int pre_num_links)\n{\n\tstruct device *dev = card->dev;\n\tstruct snd_soc_dai_link *parsed_dai_link;\n\tconst char *dai_name = NULL;\n\tint i, j, ret, num_links, parsed_num_links = 0;\n\n\tnum_links = of_property_count_strings(np, \"mediatek,dai-link\");\n\tif (num_links < 0 || num_links > card->num_links) {\n\t\tdev_dbg(dev, \"number of dai-link is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tparsed_dai_link = devm_kcalloc(dev, num_links, sizeof(*parsed_dai_link), GFP_KERNEL);\n\tif (!parsed_dai_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_links; i++) {\n\t\tret = of_property_read_string_index(np, propname, i, &dai_name);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"ASoC: Property '%s' index %d could not be read: %d\\n\",\n\t\t\t\tpropname, i, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(dev, \"ASoC: Property get dai_name:%s\\n\", dai_name);\n\t\tfor (j = 0; j < pre_num_links; j++) {\n\t\t\tif (!strcmp(dai_name, pre_dai_links[j].name)) {\n\t\t\t\tmemcpy(&parsed_dai_link[parsed_num_links++], &pre_dai_links[j],\n\t\t\t\t       sizeof(struct snd_soc_dai_link));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (parsed_num_links != num_links)\n\t\treturn -EINVAL;\n\n\tcard->dai_link = parsed_dai_link;\n\tcard->num_links = parsed_num_links;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_sof_dailink_parse_of);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}