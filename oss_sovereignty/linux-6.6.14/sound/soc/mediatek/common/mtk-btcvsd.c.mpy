{
  "module_name": "mtk-btcvsd.c",
  "hash_id": "63b9819cf3aa08b478665481b255211f59e14e2eb2413665bcd0291e71448a44",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/common/mtk-btcvsd.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/sched/clock.h>\n\n#include <sound/soc.h>\n\n#define BTCVSD_SND_NAME \"mtk-btcvsd-snd\"\n\n#define BT_CVSD_TX_NREADY\tBIT(21)\n#define BT_CVSD_RX_READY\tBIT(22)\n#define BT_CVSD_TX_UNDERFLOW\tBIT(23)\n#define BT_CVSD_RX_OVERFLOW\tBIT(24)\n#define BT_CVSD_INTERRUPT\tBIT(31)\n\n#define BT_CVSD_CLEAR \\\n\t(BT_CVSD_TX_NREADY | BT_CVSD_RX_READY | BT_CVSD_TX_UNDERFLOW |\\\n\t BT_CVSD_RX_OVERFLOW | BT_CVSD_INTERRUPT)\n\n \n#define SCO_TX_ENCODE_SIZE (60)\n \n#define SCO_TX_PACKER_BUF_NUM (18)\n\n \n#define SCO_RX_PLC_SIZE (30)\n#define SCO_RX_PACKER_BUF_NUM (64)\n#define SCO_RX_PACKET_MASK (0x3F)\n\n#define SCO_CVSD_PACKET_VALID_SIZE 2\n\n#define SCO_PACKET_120 120\n#define SCO_PACKET_180 180\n\n#define BTCVSD_RX_PACKET_SIZE (SCO_RX_PLC_SIZE + SCO_CVSD_PACKET_VALID_SIZE)\n#define BTCVSD_TX_PACKET_SIZE (SCO_TX_ENCODE_SIZE)\n\n#define BTCVSD_RX_BUF_SIZE (BTCVSD_RX_PACKET_SIZE * SCO_RX_PACKER_BUF_NUM)\n#define BTCVSD_TX_BUF_SIZE (BTCVSD_TX_PACKET_SIZE * SCO_TX_PACKER_BUF_NUM)\n\nenum bt_sco_state {\n\tBT_SCO_STATE_IDLE,\n\tBT_SCO_STATE_RUNNING,\n\tBT_SCO_STATE_ENDING,\n\tBT_SCO_STATE_LOOPBACK,\n};\n\nenum bt_sco_direct {\n\tBT_SCO_DIRECT_BT2ARM,\n\tBT_SCO_DIRECT_ARM2BT,\n};\n\nenum bt_sco_packet_len {\n\tBT_SCO_CVSD_30 = 0,\n\tBT_SCO_CVSD_60,\n\tBT_SCO_CVSD_90,\n\tBT_SCO_CVSD_120,\n\tBT_SCO_CVSD_10,\n\tBT_SCO_CVSD_20,\n\tBT_SCO_CVSD_MAX,\n};\n\nenum BT_SCO_BAND {\n\tBT_SCO_NB,\n\tBT_SCO_WB,\n};\n\nstruct mtk_btcvsd_snd_hw_info {\n\tunsigned int num_valid_addr;\n\tunsigned long bt_sram_addr[20];\n\tunsigned int packet_length;\n\tunsigned int packet_num;\n};\n\nstruct mtk_btcvsd_snd_stream {\n\tstruct snd_pcm_substream *substream;\n\tint stream;\n\n\tenum bt_sco_state state;\n\n\tunsigned int packet_size;\n\tunsigned int buf_size;\n\tu8 temp_packet_buf[SCO_PACKET_180];\n\n\tint packet_w;\n\tint packet_r;\n\tsnd_pcm_uframes_t prev_frame;\n\tint prev_packet_idx;\n\n\tunsigned int xrun:1;\n\tunsigned int timeout:1;\n\tunsigned int mute:1;\n\tunsigned int trigger_start:1;\n\tunsigned int wait_flag:1;\n\tunsigned int rw_cnt;\n\n\tunsigned long long time_stamp;\n\tunsigned long long buf_data_equivalent_time;\n\n\tstruct mtk_btcvsd_snd_hw_info buffer_info;\n};\n\nstruct mtk_btcvsd_snd {\n\tstruct device *dev;\n\tint irq_id;\n\n\tstruct regmap *infra;\n\tvoid __iomem *bt_pkv_base;\n\tvoid __iomem *bt_sram_bank2_base;\n\n\tunsigned int infra_misc_offset;\n\tunsigned int conn_bt_cvsd_mask;\n\tunsigned int cvsd_mcu_read_offset;\n\tunsigned int cvsd_mcu_write_offset;\n\tunsigned int cvsd_packet_indicator;\n\n\tu32 *bt_reg_pkt_r;\n\tu32 *bt_reg_pkt_w;\n\tu32 *bt_reg_ctl;\n\n\tunsigned int irq_disabled:1;\n\n\tspinlock_t tx_lock;\t \n\tspinlock_t rx_lock;\t \n\twait_queue_head_t tx_wait;\n\twait_queue_head_t rx_wait;\n\n\tstruct mtk_btcvsd_snd_stream *tx;\n\tstruct mtk_btcvsd_snd_stream *rx;\n\tu8 tx_packet_buf[BTCVSD_TX_BUF_SIZE];\n\tu8 rx_packet_buf[BTCVSD_RX_BUF_SIZE];\n\n\tenum BT_SCO_BAND band;\n};\n\nstruct mtk_btcvsd_snd_time_buffer_info {\n\tunsigned long long data_count_equi_time;\n\tunsigned long long time_stamp_us;\n};\n\nstatic const unsigned int btsco_packet_valid_mask[BT_SCO_CVSD_MAX][6] = {\n\t{0x1, 0x1 << 1, 0x1 << 2, 0x1 << 3, 0x1 << 4, 0x1 << 5},\n\t{0x1, 0x1, 0x2, 0x2, 0x4, 0x4},\n\t{0x1, 0x1, 0x1, 0x2, 0x2, 0x2},\n\t{0x1, 0x1, 0x1, 0x1, 0x0, 0x0},\n\t{0x7, 0x7 << 3, 0x7 << 6, 0x7 << 9, 0x7 << 12, 0x7 << 15},\n\t{0x3, 0x3 << 1, 0x3 << 3, 0x3 << 4, 0x3 << 6, 0x3 << 7},\n};\n\nstatic const unsigned int btsco_packet_info[BT_SCO_CVSD_MAX][4] = {\n\t{30, 6, SCO_PACKET_180 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_180 / SCO_RX_PLC_SIZE},\n\t{60, 3, SCO_PACKET_180 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_180 / SCO_RX_PLC_SIZE},\n\t{90, 2, SCO_PACKET_180 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_180 / SCO_RX_PLC_SIZE},\n\t{120, 1, SCO_PACKET_120 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_120 / SCO_RX_PLC_SIZE},\n\t{10, 18, SCO_PACKET_180 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_180 / SCO_RX_PLC_SIZE},\n\t{20, 9, SCO_PACKET_180 / SCO_TX_ENCODE_SIZE,\n\t SCO_PACKET_180 / SCO_RX_PLC_SIZE},\n};\n\nstatic const u8 table_msbc_silence[SCO_PACKET_180] = {\n\t0x01, 0x38, 0xad, 0x00, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x00,\n\t0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d,\n\t0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7,\n\t0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd,\n\t0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77,\n\t0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6c, 0x00,\n\t0x01, 0xc8, 0xad, 0x00, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x00,\n\t0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d,\n\t0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7,\n\t0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd,\n\t0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77,\n\t0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6c, 0x00,\n\t0x01, 0xf8, 0xad, 0x00, 0x00, 0xc5, 0x00, 0x00, 0x00, 0x00,\n\t0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d,\n\t0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7,\n\t0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77, 0x6d, 0xb6, 0xdd,\n\t0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6d, 0xdd, 0xb6, 0xdb, 0x77,\n\t0x6d, 0xb6, 0xdd, 0xdb, 0x6d, 0xb7, 0x76, 0xdb, 0x6c, 0x00\n};\n\nstatic void mtk_btcvsd_snd_irq_enable(struct mtk_btcvsd_snd *bt)\n{\n\tregmap_update_bits(bt->infra, bt->infra_misc_offset,\n\t\t\t   bt->conn_bt_cvsd_mask, 0);\n}\n\nstatic void mtk_btcvsd_snd_irq_disable(struct mtk_btcvsd_snd *bt)\n{\n\tregmap_update_bits(bt->infra, bt->infra_misc_offset,\n\t\t\t   bt->conn_bt_cvsd_mask, bt->conn_bt_cvsd_mask);\n}\n\nstatic void mtk_btcvsd_snd_set_state(struct mtk_btcvsd_snd *bt,\n\t\t\t\t     struct mtk_btcvsd_snd_stream *bt_stream,\n\t\t\t\t     int state)\n{\n\tdev_dbg(bt->dev, \"%s(), stream %d, state %d, tx->state %d, rx->state %d, irq_disabled %d\\n\",\n\t\t__func__,\n\t\tbt_stream->stream, state,\n\t\tbt->tx->state, bt->rx->state, bt->irq_disabled);\n\n\tbt_stream->state = state;\n\n\tif (bt->tx->state == BT_SCO_STATE_IDLE &&\n\t    bt->rx->state == BT_SCO_STATE_IDLE) {\n\t\tif (!bt->irq_disabled) {\n\t\t\tdisable_irq(bt->irq_id);\n\t\t\tmtk_btcvsd_snd_irq_disable(bt);\n\t\t\tbt->irq_disabled = 1;\n\t\t}\n\t} else {\n\t\tif (bt->irq_disabled) {\n\t\t\tenable_irq(bt->irq_id);\n\t\t\tmtk_btcvsd_snd_irq_enable(bt);\n\t\t\tbt->irq_disabled = 0;\n\t\t}\n\t}\n}\n\nstatic int mtk_btcvsd_snd_tx_init(struct mtk_btcvsd_snd *bt)\n{\n\tmemset(bt->tx, 0, sizeof(*bt->tx));\n\tmemset(bt->tx_packet_buf, 0, sizeof(bt->tx_packet_buf));\n\n\tbt->tx->packet_size = BTCVSD_TX_PACKET_SIZE;\n\tbt->tx->buf_size = BTCVSD_TX_BUF_SIZE;\n\tbt->tx->timeout = 0;\n\tbt->tx->rw_cnt = 0;\n\tbt->tx->stream = SNDRV_PCM_STREAM_PLAYBACK;\n\treturn 0;\n}\n\nstatic int mtk_btcvsd_snd_rx_init(struct mtk_btcvsd_snd *bt)\n{\n\tmemset(bt->rx, 0, sizeof(*bt->rx));\n\tmemset(bt->rx_packet_buf, 0, sizeof(bt->rx_packet_buf));\n\n\tbt->rx->packet_size = BTCVSD_RX_PACKET_SIZE;\n\tbt->rx->buf_size = BTCVSD_RX_BUF_SIZE;\n\tbt->rx->timeout = 0;\n\tbt->rx->rw_cnt = 0;\n\tbt->rx->stream = SNDRV_PCM_STREAM_CAPTURE;\n\treturn 0;\n}\n\nstatic void get_tx_time_stamp(struct mtk_btcvsd_snd *bt,\n\t\t\t      struct mtk_btcvsd_snd_time_buffer_info *ts)\n{\n\tts->time_stamp_us = bt->tx->time_stamp;\n\tts->data_count_equi_time = bt->tx->buf_data_equivalent_time;\n}\n\nstatic void get_rx_time_stamp(struct mtk_btcvsd_snd *bt,\n\t\t\t      struct mtk_btcvsd_snd_time_buffer_info *ts)\n{\n\tts->time_stamp_us = bt->rx->time_stamp;\n\tts->data_count_equi_time = bt->rx->buf_data_equivalent_time;\n}\n\nstatic int btcvsd_bytes_to_frame(struct snd_pcm_substream *substream,\n\t\t\t\t int bytes)\n{\n\tint count = bytes;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tif (runtime->format == SNDRV_PCM_FORMAT_S32_LE ||\n\t    runtime->format == SNDRV_PCM_FORMAT_U32_LE)\n\t\tcount = count >> 2;\n\telse\n\t\tcount = count >> 1;\n\n\tcount = count / runtime->channels;\n\treturn count;\n}\n\nstatic void mtk_btcvsd_snd_data_transfer(enum bt_sco_direct dir,\n\t\t\t\t\t u8 *src, u8 *dst,\n\t\t\t\t\t unsigned int blk_size,\n\t\t\t\t\t unsigned int blk_num)\n{\n\tunsigned int i, j;\n\n\tif (blk_size == 60 || blk_size == 120 || blk_size == 20) {\n\t\tu32 *src_32 = (u32 *)src;\n\t\tu32 *dst_32 = (u32 *)dst;\n\n\t\tfor (i = 0; i < (blk_size * blk_num / 4); i++)\n\t\t\t*dst_32++ = *src_32++;\n\t} else {\n\t\tu16 *src_16 = (u16 *)src;\n\t\tu16 *dst_16 = (u16 *)dst;\n\n\t\tfor (j = 0; j < blk_num; j++) {\n\t\t\tfor (i = 0; i < (blk_size / 2); i++)\n\t\t\t\t*dst_16++ = *src_16++;\n\n\t\t\tif (dir == BT_SCO_DIRECT_BT2ARM)\n\t\t\t\tsrc_16++;\n\t\t\telse\n\t\t\t\tdst_16++;\n\t\t}\n\t}\n}\n\n \nstatic int btcvsd_tx_clean_buffer(struct mtk_btcvsd_snd *bt)\n{\n\tunsigned int i;\n\tunsigned int num_valid_addr;\n\tunsigned long flags;\n\tenum BT_SCO_BAND band = bt->band;\n\n\t \n\tif (band == BT_SCO_NB)\n\t\tmemset(bt->tx->temp_packet_buf, 170, SCO_PACKET_180);\n\telse\n\t\tmemcpy(bt->tx->temp_packet_buf,\n\t\t       table_msbc_silence, SCO_PACKET_180);\n\n\t \n\tspin_lock_irqsave(&bt->tx_lock, flags);\n\tnum_valid_addr = bt->tx->buffer_info.num_valid_addr;\n\n\tdev_info(bt->dev, \"%s(), band %d, num_valid_addr %u\\n\",\n\t\t __func__, band, num_valid_addr);\n\n\tfor (i = 0; i < num_valid_addr; i++) {\n\t\tvoid *dst;\n\n\t\tdev_info(bt->dev, \"%s(), clean addr 0x%lx\\n\", __func__,\n\t\t\t bt->tx->buffer_info.bt_sram_addr[i]);\n\n\t\tdst = (void *)bt->tx->buffer_info.bt_sram_addr[i];\n\n\t\tmtk_btcvsd_snd_data_transfer(BT_SCO_DIRECT_ARM2BT,\n\t\t\t\t\t     bt->tx->temp_packet_buf, dst,\n\t\t\t\t\t     bt->tx->buffer_info.packet_length,\n\t\t\t\t\t     bt->tx->buffer_info.packet_num);\n\t}\n\tspin_unlock_irqrestore(&bt->tx_lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtk_btcvsd_read_from_bt(struct mtk_btcvsd_snd *bt,\n\t\t\t\t   enum bt_sco_packet_len packet_type,\n\t\t\t\t   unsigned int packet_length,\n\t\t\t\t   unsigned int packet_num,\n\t\t\t\t   unsigned int blk_size,\n\t\t\t\t   unsigned int control)\n{\n\tunsigned int i;\n\tint pv;\n\tu8 *src;\n\tunsigned int packet_buf_ofs;\n\tunsigned long flags;\n\tunsigned long connsys_addr_rx, ap_addr_rx;\n\n\tconnsys_addr_rx = *bt->bt_reg_pkt_r;\n\tap_addr_rx = (unsigned long)bt->bt_sram_bank2_base +\n\t\t     (connsys_addr_rx & 0xFFFF);\n\n\tif (connsys_addr_rx == 0xdeadfeed) {\n\t\t \n\t\tdev_warn(bt->dev, \"%s(), connsys_addr_rx == 0xdeadfeed\",\n\t\t\t __func__);\n\t\treturn -EIO;\n\t}\n\n\tsrc = (u8 *)ap_addr_rx;\n\n\tmtk_btcvsd_snd_data_transfer(BT_SCO_DIRECT_BT2ARM, src,\n\t\t\t\t     bt->rx->temp_packet_buf, packet_length,\n\t\t\t\t     packet_num);\n\n\tspin_lock_irqsave(&bt->rx_lock, flags);\n\tfor (i = 0; i < blk_size; i++) {\n\t\tpacket_buf_ofs = (bt->rx->packet_w & SCO_RX_PACKET_MASK) *\n\t\t\t\t bt->rx->packet_size;\n\t\tmemcpy(bt->rx_packet_buf + packet_buf_ofs,\n\t\t       bt->rx->temp_packet_buf + (SCO_RX_PLC_SIZE * i),\n\t\t       SCO_RX_PLC_SIZE);\n\t\tif ((control & btsco_packet_valid_mask[packet_type][i]) ==\n\t\t    btsco_packet_valid_mask[packet_type][i])\n\t\t\tpv = 1;\n\t\telse\n\t\t\tpv = 0;\n\n\t\tpacket_buf_ofs += SCO_RX_PLC_SIZE;\n\t\tmemcpy(bt->rx_packet_buf + packet_buf_ofs, (void *)&pv,\n\t\t       SCO_CVSD_PACKET_VALID_SIZE);\n\t\tbt->rx->packet_w++;\n\t}\n\tspin_unlock_irqrestore(&bt->rx_lock, flags);\n\treturn 0;\n}\n\nstatic int mtk_btcvsd_write_to_bt(struct mtk_btcvsd_snd *bt,\n\t\t\t\t  enum bt_sco_packet_len packet_type,\n\t\t\t\t  unsigned int packet_length,\n\t\t\t\t  unsigned int packet_num,\n\t\t\t\t  unsigned int blk_size)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\tu8 *dst;\n\tunsigned long connsys_addr_tx, ap_addr_tx;\n\tbool new_ap_addr_tx = true;\n\n\tconnsys_addr_tx = *bt->bt_reg_pkt_w;\n\tap_addr_tx = (unsigned long)bt->bt_sram_bank2_base +\n\t\t     (connsys_addr_tx & 0xFFFF);\n\n\tif (connsys_addr_tx == 0xdeadfeed) {\n\t\t \n\t\tdev_warn(bt->dev, \"%s(), connsys_addr_tx == 0xdeadfeed\\n\",\n\t\t\t __func__);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(&bt->tx_lock, flags);\n\tfor (i = 0; i < blk_size; i++) {\n\t\tmemcpy(bt->tx->temp_packet_buf + (bt->tx->packet_size * i),\n\t\t       (bt->tx_packet_buf +\n\t\t\t(bt->tx->packet_r % SCO_TX_PACKER_BUF_NUM) *\n\t\t\tbt->tx->packet_size),\n\t\t       bt->tx->packet_size);\n\n\t\tbt->tx->packet_r++;\n\t}\n\tspin_unlock_irqrestore(&bt->tx_lock, flags);\n\n\tdst = (u8 *)ap_addr_tx;\n\n\tif (!bt->tx->mute) {\n\t\tmtk_btcvsd_snd_data_transfer(BT_SCO_DIRECT_ARM2BT,\n\t\t\t\t\t     bt->tx->temp_packet_buf, dst,\n\t\t\t\t\t     packet_length, packet_num);\n\t}\n\n\t \n\tbt->tx->buffer_info.packet_length = packet_length;\n\tbt->tx->buffer_info.packet_num = packet_num;\n\tfor (i = 0; i < bt->tx->buffer_info.num_valid_addr; i++) {\n\t\tif (bt->tx->buffer_info.bt_sram_addr[i] == ap_addr_tx) {\n\t\t\tnew_ap_addr_tx = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (new_ap_addr_tx) {\n\t\tunsigned int next_idx;\n\n\t\tspin_lock_irqsave(&bt->tx_lock, flags);\n\t\tbt->tx->buffer_info.num_valid_addr++;\n\t\tnext_idx = bt->tx->buffer_info.num_valid_addr - 1;\n\t\tbt->tx->buffer_info.bt_sram_addr[next_idx] = ap_addr_tx;\n\t\tspin_unlock_irqrestore(&bt->tx_lock, flags);\n\t\tdev_info(bt->dev, \"%s(), new ap_addr_tx = 0x%lx, num_valid_addr %d\\n\",\n\t\t\t __func__, ap_addr_tx,\n\t\t\t bt->tx->buffer_info.num_valid_addr);\n\t}\n\n\tif (bt->tx->mute)\n\t\tbtcvsd_tx_clean_buffer(bt);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mtk_btcvsd_snd_irq_handler(int irq_id, void *dev)\n{\n\tstruct mtk_btcvsd_snd *bt = dev;\n\tunsigned int packet_type, packet_num, packet_length;\n\tunsigned int buf_cnt_tx, buf_cnt_rx, control;\n\n\tif (bt->rx->state != BT_SCO_STATE_RUNNING &&\n\t    bt->rx->state != BT_SCO_STATE_ENDING &&\n\t    bt->tx->state != BT_SCO_STATE_RUNNING &&\n\t    bt->tx->state != BT_SCO_STATE_ENDING &&\n\t    bt->tx->state != BT_SCO_STATE_LOOPBACK) {\n\t\tdev_warn(bt->dev, \"%s(), in idle state: rx->state: %d, tx->state: %d\\n\",\n\t\t\t __func__, bt->rx->state, bt->tx->state);\n\t\tgoto irq_handler_exit;\n\t}\n\n\tcontrol = *bt->bt_reg_ctl;\n\tpacket_type = (control >> 18) & 0x7;\n\n\tif (((control >> 31) & 1) == 0) {\n\t\tdev_warn(bt->dev, \"%s(), ((control >> 31) & 1) == 0, control 0x%x\\n\",\n\t\t\t __func__, control);\n\t\tgoto irq_handler_exit;\n\t}\n\n\tif (packet_type >= BT_SCO_CVSD_MAX) {\n\t\tdev_warn(bt->dev, \"%s(), invalid packet_type %u, exit\\n\",\n\t\t\t __func__, packet_type);\n\t\tgoto irq_handler_exit;\n\t}\n\n\tpacket_length = btsco_packet_info[packet_type][0];\n\tpacket_num = btsco_packet_info[packet_type][1];\n\tbuf_cnt_tx = btsco_packet_info[packet_type][2];\n\tbuf_cnt_rx = btsco_packet_info[packet_type][3];\n\n\tif (bt->tx->state == BT_SCO_STATE_LOOPBACK) {\n\t\tu8 *src, *dst;\n\t\tunsigned long connsys_addr_rx, ap_addr_rx;\n\t\tunsigned long connsys_addr_tx, ap_addr_tx;\n\n\t\tconnsys_addr_rx = *bt->bt_reg_pkt_r;\n\t\tap_addr_rx = (unsigned long)bt->bt_sram_bank2_base +\n\t\t\t     (connsys_addr_rx & 0xFFFF);\n\n\t\tconnsys_addr_tx = *bt->bt_reg_pkt_w;\n\t\tap_addr_tx = (unsigned long)bt->bt_sram_bank2_base +\n\t\t\t     (connsys_addr_tx & 0xFFFF);\n\n\t\tif (connsys_addr_tx == 0xdeadfeed ||\n\t\t    connsys_addr_rx == 0xdeadfeed) {\n\t\t\t \n\t\t\tdev_warn(bt->dev, \"%s(), connsys_addr_tx == 0xdeadfeed\\n\",\n\t\t\t\t __func__);\n\t\t\tgoto irq_handler_exit;\n\t\t}\n\n\t\tsrc = (u8 *)ap_addr_rx;\n\t\tdst = (u8 *)ap_addr_tx;\n\n\t\tmtk_btcvsd_snd_data_transfer(BT_SCO_DIRECT_BT2ARM, src,\n\t\t\t\t\t     bt->tx->temp_packet_buf,\n\t\t\t\t\t     packet_length,\n\t\t\t\t\t     packet_num);\n\t\tmtk_btcvsd_snd_data_transfer(BT_SCO_DIRECT_ARM2BT,\n\t\t\t\t\t     bt->tx->temp_packet_buf, dst,\n\t\t\t\t\t     packet_length,\n\t\t\t\t\t     packet_num);\n\t\tbt->rx->rw_cnt++;\n\t\tbt->tx->rw_cnt++;\n\t}\n\n\tif (bt->rx->state == BT_SCO_STATE_RUNNING ||\n\t    bt->rx->state == BT_SCO_STATE_ENDING) {\n\t\tif (bt->rx->xrun) {\n\t\t\tif (bt->rx->packet_w - bt->rx->packet_r <=\n\t\t\t    SCO_RX_PACKER_BUF_NUM - 2 * buf_cnt_rx) {\n\t\t\t\t \n\t\t\t\tbt->rx->xrun = 0;\n\t\t\t\tdev_warn(bt->dev, \"%s(), rx->xrun 0!\\n\",\n\t\t\t\t\t __func__);\n\t\t\t}\n\t\t}\n\n\t\tif (!bt->rx->xrun &&\n\t\t    (bt->rx->packet_w - bt->rx->packet_r <=\n\t\t     SCO_RX_PACKER_BUF_NUM - buf_cnt_rx)) {\n\t\t\tmtk_btcvsd_read_from_bt(bt,\n\t\t\t\t\t\tpacket_type,\n\t\t\t\t\t\tpacket_length,\n\t\t\t\t\t\tpacket_num,\n\t\t\t\t\t\tbuf_cnt_rx,\n\t\t\t\t\t\tcontrol);\n\t\t\tbt->rx->rw_cnt++;\n\t\t} else {\n\t\t\tbt->rx->xrun = 1;\n\t\t\tdev_warn(bt->dev, \"%s(), rx->xrun 1\\n\", __func__);\n\t\t}\n\t}\n\n\t \n\tbt->tx->timeout = 0;\n\tif ((bt->tx->state == BT_SCO_STATE_RUNNING ||\n\t     bt->tx->state == BT_SCO_STATE_ENDING) &&\n\t    bt->tx->trigger_start) {\n\t\tif (bt->tx->xrun) {\n\t\t\t \n\t\t\tif (bt->tx->packet_w - bt->tx->packet_r >=\n\t\t\t    2 * buf_cnt_tx) {\n\t\t\t\tbt->tx->xrun = 0;\n\t\t\t\tdev_warn(bt->dev, \"%s(), tx->xrun 0\\n\",\n\t\t\t\t\t __func__);\n\t\t\t}\n\t\t}\n\n\t\tif ((!bt->tx->xrun &&\n\t\t     (bt->tx->packet_w - bt->tx->packet_r >= buf_cnt_tx)) ||\n\t\t    bt->tx->state == BT_SCO_STATE_ENDING) {\n\t\t\tmtk_btcvsd_write_to_bt(bt,\n\t\t\t\t\t       packet_type,\n\t\t\t\t\t       packet_length,\n\t\t\t\t\t       packet_num,\n\t\t\t\t\t       buf_cnt_tx);\n\t\t\tbt->tx->rw_cnt++;\n\t\t} else {\n\t\t\tbt->tx->xrun = 1;\n\t\t\tdev_warn(bt->dev, \"%s(), tx->xrun 1\\n\", __func__);\n\t\t}\n\t}\n\n\t*bt->bt_reg_ctl &= ~BT_CVSD_CLEAR;\n\n\tif (bt->rx->state == BT_SCO_STATE_RUNNING ||\n\t    bt->rx->state == BT_SCO_STATE_ENDING) {\n\t\tbt->rx->wait_flag = 1;\n\t\twake_up_interruptible(&bt->rx_wait);\n\t\tsnd_pcm_period_elapsed(bt->rx->substream);\n\t}\n\tif (bt->tx->state == BT_SCO_STATE_RUNNING ||\n\t    bt->tx->state == BT_SCO_STATE_ENDING) {\n\t\tbt->tx->wait_flag = 1;\n\t\twake_up_interruptible(&bt->tx_wait);\n\t\tsnd_pcm_period_elapsed(bt->tx->substream);\n\t}\n\n\treturn IRQ_HANDLED;\nirq_handler_exit:\n\t*bt->bt_reg_ctl &= ~BT_CVSD_CLEAR;\n\treturn IRQ_HANDLED;\n}\n\nstatic int wait_for_bt_irq(struct mtk_btcvsd_snd *bt,\n\t\t\t   struct mtk_btcvsd_snd_stream *bt_stream)\n{\n\tunsigned long long t1, t2;\n\t \n\tunsigned long long timeout_limit = 22500000;\n\tint max_timeout_trial = 2;\n\tint ret;\n\n\tbt_stream->wait_flag = 0;\n\n\twhile (max_timeout_trial && !bt_stream->wait_flag) {\n\t\tt1 = sched_clock();\n\t\tif (bt_stream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tret = wait_event_interruptible_timeout(bt->tx_wait,\n\t\t\t\tbt_stream->wait_flag,\n\t\t\t\tnsecs_to_jiffies(timeout_limit));\n\t\t} else {\n\t\t\tret = wait_event_interruptible_timeout(bt->rx_wait,\n\t\t\t\tbt_stream->wait_flag,\n\t\t\t\tnsecs_to_jiffies(timeout_limit));\n\t\t}\n\n\t\tt2 = sched_clock();\n\t\tt2 = t2 - t1;  \n\n\t\tif (t2 > timeout_limit) {\n\t\t\tdev_warn(bt->dev, \"%s(), stream %d, timeout %llu, limit %llu, ret %d, flag %d\\n\",\n\t\t\t\t __func__, bt_stream->stream,\n\t\t\t\t t2, timeout_limit, ret,\n\t\t\t\t bt_stream->wait_flag);\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_warn(bt->dev, \"%s(), stream %d, error, trial left %d\\n\",\n\t\t\t\t __func__,\n\t\t\t\t bt_stream->stream, max_timeout_trial);\n\n\t\t\tbt_stream->timeout = 1;\n\t\t\treturn ret;\n\t\t} else if (ret == 0) {\n\t\t\t \n\t\t\tmax_timeout_trial--;\n\t\t\tdev_warn(bt->dev, \"%s(), stream %d, error, timeout, condition is false, trial left %d\\n\",\n\t\t\t\t __func__,\n\t\t\t\t bt_stream->stream, max_timeout_trial);\n\n\t\t\tif (max_timeout_trial <= 0) {\n\t\t\t\tbt_stream->timeout = 1;\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t mtk_btcvsd_snd_read(struct mtk_btcvsd_snd *bt,\n\t\t\t\t   struct iov_iter *buf,\n\t\t\t\t   size_t count)\n{\n\tssize_t read_size = 0, read_count = 0, cur_read_idx, cont;\n\tunsigned long avail;\n\tunsigned long flags;\n\tunsigned int packet_size = bt->rx->packet_size;\n\n\twhile (count) {\n\t\tspin_lock_irqsave(&bt->rx_lock, flags);\n\t\t \n\t\tavail = (bt->rx->packet_w - bt->rx->packet_r) * packet_size;\n\n\t\tcur_read_idx = (bt->rx->packet_r & SCO_RX_PACKET_MASK) *\n\t\t\t       packet_size;\n\t\tspin_unlock_irqrestore(&bt->rx_lock, flags);\n\n\t\tif (!avail) {\n\t\t\tint ret = wait_for_bt_irq(bt, bt->rx);\n\n\t\t\tif (ret)\n\t\t\t\treturn read_count;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (count % packet_size != 0 ||\n\t\t    avail % packet_size != 0) {\n\t\t\tdev_warn(bt->dev, \"%s(), count %zu or d %lu is not multiple of packet_size %dd\\n\",\n\t\t\t\t __func__, count, avail, packet_size);\n\n\t\t\tcount -= count % packet_size;\n\t\t\tavail -= avail % packet_size;\n\t\t}\n\n\t\tif (count > avail)\n\t\t\tread_size = avail;\n\t\telse\n\t\t\tread_size = count;\n\n\t\t \n\t\tcont = bt->rx->buf_size - cur_read_idx;\n\t\tif (read_size > cont)\n\t\t\tread_size = cont;\n\n\t\tif (copy_to_iter(bt->rx_packet_buf + cur_read_idx,\n\t\t\t\t read_size, buf) != read_size) {\n\t\t\tdev_warn(bt->dev, \"%s(), copy_to_iter fail\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tspin_lock_irqsave(&bt->rx_lock, flags);\n\t\tbt->rx->packet_r += read_size / packet_size;\n\t\tspin_unlock_irqrestore(&bt->rx_lock, flags);\n\n\t\tread_count += read_size;\n\t\tcount -= read_size;\n\t}\n\n\t \n\tbt->rx->time_stamp = sched_clock();\n\tbt->rx->buf_data_equivalent_time =\n\t\t(unsigned long long)(bt->rx->packet_w - bt->rx->packet_r) *\n\t\tSCO_RX_PLC_SIZE * 16 * 1000 / 2 / 64;\n\tbt->rx->buf_data_equivalent_time += read_count * SCO_RX_PLC_SIZE *\n\t\t\t\t\t    16 * 1000 / packet_size / 2 / 64;\n\t \n\tbt->rx->buf_data_equivalent_time *= 1000;\n\n\treturn read_count;\n}\n\nstatic ssize_t mtk_btcvsd_snd_write(struct mtk_btcvsd_snd *bt,\n\t\t\t\t    struct iov_iter *buf,\n\t\t\t\t    size_t count)\n{\n\tint written_size = count, avail, cur_write_idx, write_size, cont;\n\tunsigned long flags;\n\tunsigned int packet_size = bt->tx->packet_size;\n\n\t \n\tbt->tx->time_stamp = sched_clock();\n\tbt->tx->buf_data_equivalent_time =\n\t\t(unsigned long long)(bt->tx->packet_w - bt->tx->packet_r) *\n\t\tpacket_size * 16 * 1000 / 2 / 64;\n\n\t \n\tbt->tx->buf_data_equivalent_time *= 1000;\n\n\twhile (count) {\n\t\tspin_lock_irqsave(&bt->tx_lock, flags);\n\t\t \n\t\tavail = bt->tx->buf_size -\n\t\t\t(bt->tx->packet_w - bt->tx->packet_r) * packet_size;\n\n\t\tcur_write_idx = (bt->tx->packet_w % SCO_TX_PACKER_BUF_NUM) *\n\t\t\t\tpacket_size;\n\t\tspin_unlock_irqrestore(&bt->tx_lock, flags);\n\n\t\tif (!avail) {\n\t\t\tint ret = wait_for_bt_irq(bt, bt->tx);\n\n\t\t\tif (ret)\n\t\t\t\treturn written_size;\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (count % packet_size != 0 ||\n\t\t    avail % packet_size != 0) {\n\t\t\tdev_warn(bt->dev, \"%s(), count %zu or avail %d is not multiple of packet_size %d\\n\",\n\t\t\t\t __func__, count, avail, packet_size);\n\t\t\tcount -= count % packet_size;\n\t\t\tavail -= avail % packet_size;\n\t\t}\n\n\t\tif (count > avail)\n\t\t\twrite_size = avail;\n\t\telse\n\t\t\twrite_size = count;\n\n\t\t \n\t\tcont = bt->tx->buf_size - cur_write_idx;\n\t\tif (write_size > cont)\n\t\t\twrite_size = cont;\n\n\t\tif (copy_from_iter(bt->tx_packet_buf + cur_write_idx,\n\t\t\t\t   write_size, buf) != write_size) {\n\t\t\tdev_warn(bt->dev, \"%s(), copy_from_iter fail\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tspin_lock_irqsave(&bt->tx_lock, flags);\n\t\tbt->tx->packet_w += write_size / packet_size;\n\t\tspin_unlock_irqrestore(&bt->tx_lock, flags);\n\t\tcount -= write_size;\n\t}\n\n\treturn written_size;\n}\n\nstatic struct mtk_btcvsd_snd_stream *get_bt_stream\n\t(struct mtk_btcvsd_snd *bt, struct snd_pcm_substream *substream)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn bt->tx;\n\telse\n\t\treturn bt->rx;\n}\n\n \nstatic const struct snd_pcm_hardware mtk_btcvsd_hardware = {\n\t.info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_RESUME),\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.buffer_bytes_max = 24 * 1024,\n\t.period_bytes_max = 24 * 1024,\n\t.periods_min = 2,\n\t.periods_max = 16,\n\t.fifo_size = 0,\n};\n\nstatic int mtk_pcm_btcvsd_open(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tdev_dbg(bt->dev, \"%s(), stream %d, substream %p\\n\",\n\t\t__func__, substream->stream, substream);\n\n\tsnd_soc_set_runtime_hwparams(substream, &mtk_btcvsd_hardware);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = mtk_btcvsd_snd_tx_init(bt);\n\t\tbt->tx->substream = substream;\n\t} else {\n\t\tret = mtk_btcvsd_snd_rx_init(bt);\n\t\tbt->rx->substream = substream;\n\t}\n\n\treturn ret;\n}\n\nstatic int mtk_pcm_btcvsd_close(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\tstruct mtk_btcvsd_snd_stream *bt_stream = get_bt_stream(bt, substream);\n\n\tdev_dbg(bt->dev, \"%s(), stream %d\\n\", __func__, substream->stream);\n\n\tmtk_btcvsd_snd_set_state(bt, bt_stream, BT_SCO_STATE_IDLE);\n\tbt_stream->substream = NULL;\n\treturn 0;\n}\n\nstatic int mtk_pcm_btcvsd_hw_params(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t    params_buffer_bytes(hw_params) % bt->tx->packet_size != 0) {\n\t\tdev_warn(bt->dev, \"%s(), error, buffer size %d not valid\\n\",\n\t\t\t __func__,\n\t\t\t params_buffer_bytes(hw_params));\n\t\treturn -EINVAL;\n\t}\n\n\tsubstream->runtime->dma_bytes = params_buffer_bytes(hw_params);\n\treturn 0;\n}\n\nstatic int mtk_pcm_btcvsd_hw_free(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tbtcvsd_tx_clean_buffer(bt);\n\n\treturn 0;\n}\n\nstatic int mtk_pcm_btcvsd_prepare(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\tstruct mtk_btcvsd_snd_stream *bt_stream = get_bt_stream(bt, substream);\n\n\tdev_dbg(bt->dev, \"%s(), stream %d\\n\", __func__, substream->stream);\n\n\tmtk_btcvsd_snd_set_state(bt, bt_stream, BT_SCO_STATE_RUNNING);\n\treturn 0;\n}\n\nstatic int mtk_pcm_btcvsd_trigger(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\tstruct mtk_btcvsd_snd_stream *bt_stream = get_bt_stream(bt, substream);\n\tint stream = substream->stream;\n\tint hw_packet_ptr;\n\n\tdev_dbg(bt->dev, \"%s(), stream %d, cmd %d\\n\",\n\t\t__func__, substream->stream, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\thw_packet_ptr = stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\t\tbt_stream->packet_r : bt_stream->packet_w;\n\t\tbt_stream->prev_packet_idx = hw_packet_ptr;\n\t\tbt_stream->prev_frame = 0;\n\t\tbt_stream->trigger_start = 1;\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tbt_stream->trigger_start = 0;\n\t\tmtk_btcvsd_snd_set_state(bt, bt_stream, BT_SCO_STATE_ENDING);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic snd_pcm_uframes_t mtk_pcm_btcvsd_pointer(\n\tstruct snd_soc_component *component,\n\tstruct snd_pcm_substream *substream)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\tstruct mtk_btcvsd_snd_stream *bt_stream;\n\tsnd_pcm_uframes_t frame = 0;\n\tint byte = 0;\n\tint hw_packet_ptr;\n\tint packet_diff;\n\tspinlock_t *lock;\t \n\tunsigned long flags;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tlock = &bt->tx_lock;\n\t\tbt_stream = bt->tx;\n\t} else {\n\t\tlock = &bt->rx_lock;\n\t\tbt_stream = bt->rx;\n\t}\n\n\tspin_lock_irqsave(lock, flags);\n\thw_packet_ptr = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\tbt->tx->packet_r : bt->rx->packet_w;\n\n\t \n\tif (hw_packet_ptr >= bt_stream->prev_packet_idx) {\n\t\tpacket_diff = hw_packet_ptr - bt_stream->prev_packet_idx;\n\t} else {\n\t\t \n\t\tpacket_diff = (INT_MAX - bt_stream->prev_packet_idx) +\n\t\t\t      (hw_packet_ptr - INT_MIN) + 1;\n\t}\n\tbt_stream->prev_packet_idx = hw_packet_ptr;\n\n\t \n\tbyte = packet_diff * bt_stream->packet_size;\n\n\tframe = btcvsd_bytes_to_frame(substream, byte);\n\tframe += bt_stream->prev_frame;\n\tframe %= substream->runtime->buffer_size;\n\n\tbt_stream->prev_frame = frame;\n\n\tspin_unlock_irqrestore(lock, flags);\n\n\treturn frame;\n}\n\nstatic int mtk_pcm_btcvsd_copy(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream,\n\t\t\t       int channel, unsigned long pos,\n\t\t\t       struct iov_iter *buf, unsigned long count)\n{\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(component);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn mtk_btcvsd_snd_write(bt, buf, count);\n\telse\n\t\treturn mtk_btcvsd_snd_read(bt, buf, count);\n}\n\n \nstatic const char *const btsco_band_str[] = {\"NB\", \"WB\"};\n\nstatic const struct soc_enum btcvsd_enum[] = {\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(btsco_band_str), btsco_band_str),\n};\n\nstatic int btcvsd_band_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tucontrol->value.integer.value[0] = bt->band;\n\treturn 0;\n}\n\nstatic int btcvsd_band_set(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tbt->band = ucontrol->value.integer.value[0];\n\tdev_dbg(bt->dev, \"%s(), band %d\\n\", __func__, bt->band);\n\treturn 0;\n}\n\nstatic int btcvsd_loopback_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\tbool lpbk_en = bt->tx->state == BT_SCO_STATE_LOOPBACK;\n\n\tucontrol->value.integer.value[0] = lpbk_en;\n\treturn 0;\n}\n\nstatic int btcvsd_loopback_set(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (ucontrol->value.integer.value[0]) {\n\t\tmtk_btcvsd_snd_set_state(bt, bt->tx, BT_SCO_STATE_LOOPBACK);\n\t\tmtk_btcvsd_snd_set_state(bt, bt->rx, BT_SCO_STATE_LOOPBACK);\n\t} else {\n\t\tmtk_btcvsd_snd_set_state(bt, bt->tx, BT_SCO_STATE_RUNNING);\n\t\tmtk_btcvsd_snd_set_state(bt, bt->rx, BT_SCO_STATE_RUNNING);\n\t}\n\treturn 0;\n}\n\nstatic int btcvsd_tx_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (!bt->tx) {\n\t\tucontrol->value.integer.value[0] = 0;\n\t\treturn 0;\n\t}\n\n\tucontrol->value.integer.value[0] = bt->tx->mute;\n\treturn 0;\n}\n\nstatic int btcvsd_tx_mute_set(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (!bt->tx)\n\t\treturn 0;\n\n\tbt->tx->mute = ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int btcvsd_rx_irq_received_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (!bt->rx)\n\t\treturn 0;\n\n\tucontrol->value.integer.value[0] = bt->rx->rw_cnt ? 1 : 0;\n\treturn 0;\n}\n\nstatic int btcvsd_rx_timeout_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (!bt->rx)\n\t\treturn 0;\n\n\tucontrol->value.integer.value[0] = bt->rx->timeout;\n\tbt->rx->timeout = 0;\n\treturn 0;\n}\n\nstatic int btcvsd_rx_timestamp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   unsigned int __user *data, unsigned int size)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\tint ret = 0;\n\tstruct mtk_btcvsd_snd_time_buffer_info time_buffer_info_rx;\n\n\tif (size > sizeof(struct mtk_btcvsd_snd_time_buffer_info))\n\t\treturn -EINVAL;\n\n\tget_rx_time_stamp(bt, &time_buffer_info_rx);\n\n\tdev_dbg(bt->dev, \"%s(), time_stamp_us %llu, data_count_equi_time %llu\",\n\t\t__func__,\n\t\ttime_buffer_info_rx.time_stamp_us,\n\t\ttime_buffer_info_rx.data_count_equi_time);\n\n\tif (copy_to_user(data, &time_buffer_info_rx,\n\t\t\t sizeof(struct mtk_btcvsd_snd_time_buffer_info))) {\n\t\tdev_warn(bt->dev, \"%s(), copy_to_user fail\", __func__);\n\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nstatic int btcvsd_tx_irq_received_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tif (!bt->tx)\n\t\treturn 0;\n\n\tucontrol->value.integer.value[0] = bt->tx->rw_cnt ? 1 : 0;\n\treturn 0;\n}\n\nstatic int btcvsd_tx_timeout_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\n\tucontrol->value.integer.value[0] = bt->tx->timeout;\n\treturn 0;\n}\n\nstatic int btcvsd_tx_timestamp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   unsigned int __user *data, unsigned int size)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct mtk_btcvsd_snd *bt = snd_soc_component_get_drvdata(cmpnt);\n\tint ret = 0;\n\tstruct mtk_btcvsd_snd_time_buffer_info time_buffer_info_tx;\n\n\tif (size > sizeof(struct mtk_btcvsd_snd_time_buffer_info))\n\t\treturn -EINVAL;\n\n\tget_tx_time_stamp(bt, &time_buffer_info_tx);\n\n\tdev_dbg(bt->dev, \"%s(), time_stamp_us %llu, data_count_equi_time %llu\",\n\t\t__func__,\n\t\ttime_buffer_info_tx.time_stamp_us,\n\t\ttime_buffer_info_tx.data_count_equi_time);\n\n\tif (copy_to_user(data, &time_buffer_info_tx,\n\t\t\t sizeof(struct mtk_btcvsd_snd_time_buffer_info))) {\n\t\tdev_warn(bt->dev, \"%s(), copy_to_user fail\", __func__);\n\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new mtk_btcvsd_snd_controls[] = {\n\tSOC_ENUM_EXT(\"BTCVSD Band\", btcvsd_enum[0],\n\t\t     btcvsd_band_get, btcvsd_band_set),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Loopback Switch\", 0,\n\t\t\t    btcvsd_loopback_get, btcvsd_loopback_set),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Tx Mute Switch\", 0,\n\t\t\t    btcvsd_tx_mute_get, btcvsd_tx_mute_set),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Tx Irq Received Switch\", 0,\n\t\t\t    btcvsd_tx_irq_received_get, NULL),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Tx Timeout Switch\", 0,\n\t\t\t    btcvsd_tx_timeout_get, NULL),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Rx Irq Received Switch\", 0,\n\t\t\t    btcvsd_rx_irq_received_get, NULL),\n\tSOC_SINGLE_BOOL_EXT(\"BTCVSD Rx Timeout Switch\", 0,\n\t\t\t    btcvsd_rx_timeout_get, NULL),\n\tSND_SOC_BYTES_TLV(\"BTCVSD Rx Timestamp\",\n\t\t\t  sizeof(struct mtk_btcvsd_snd_time_buffer_info),\n\t\t\t  btcvsd_rx_timestamp_get, NULL),\n\tSND_SOC_BYTES_TLV(\"BTCVSD Tx Timestamp\",\n\t\t\t  sizeof(struct mtk_btcvsd_snd_time_buffer_info),\n\t\t\t  btcvsd_tx_timestamp_get, NULL),\n};\n\nstatic int mtk_btcvsd_snd_component_probe(struct snd_soc_component *component)\n{\n\treturn snd_soc_add_component_controls(component,\n\t\tmtk_btcvsd_snd_controls,\n\t\tARRAY_SIZE(mtk_btcvsd_snd_controls));\n}\n\nstatic const struct snd_soc_component_driver mtk_btcvsd_snd_platform = {\n\t.name\t\t= BTCVSD_SND_NAME,\n\t.probe\t\t= mtk_btcvsd_snd_component_probe,\n\t.open\t\t= mtk_pcm_btcvsd_open,\n\t.close\t\t= mtk_pcm_btcvsd_close,\n\t.hw_params\t= mtk_pcm_btcvsd_hw_params,\n\t.hw_free\t= mtk_pcm_btcvsd_hw_free,\n\t.prepare\t= mtk_pcm_btcvsd_prepare,\n\t.trigger\t= mtk_pcm_btcvsd_trigger,\n\t.pointer\t= mtk_pcm_btcvsd_pointer,\n\t.copy\t\t= mtk_pcm_btcvsd_copy,\n};\n\nstatic int mtk_btcvsd_snd_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint irq_id;\n\tu32 offset[5] = {0, 0, 0, 0, 0};\n\tstruct mtk_btcvsd_snd *btcvsd;\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tbtcvsd = devm_kzalloc(dev, sizeof(*btcvsd), GFP_KERNEL);\n\tif (!btcvsd)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, btcvsd);\n\tbtcvsd->dev = dev;\n\n\t \n\tbtcvsd->rx = devm_kzalloc(btcvsd->dev, sizeof(*btcvsd->rx), GFP_KERNEL);\n\tif (!btcvsd->rx)\n\t\treturn -ENOMEM;\n\n\tbtcvsd->tx = devm_kzalloc(btcvsd->dev, sizeof(*btcvsd->tx), GFP_KERNEL);\n\tif (!btcvsd->tx)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&btcvsd->tx_lock);\n\tspin_lock_init(&btcvsd->rx_lock);\n\n\tinit_waitqueue_head(&btcvsd->tx_wait);\n\tinit_waitqueue_head(&btcvsd->rx_wait);\n\n\tmtk_btcvsd_snd_tx_init(btcvsd);\n\tmtk_btcvsd_snd_rx_init(btcvsd);\n\n\t \n\tirq_id = platform_get_irq(pdev, 0);\n\tif (irq_id <= 0)\n\t\treturn irq_id < 0 ? irq_id : -ENXIO;\n\n\tret = devm_request_irq(dev, irq_id, mtk_btcvsd_snd_irq_handler,\n\t\t\t       IRQF_TRIGGER_LOW, \"BTCVSD_ISR_Handle\",\n\t\t\t       (void *)btcvsd);\n\tif (ret) {\n\t\tdev_err(dev, \"could not request_irq for BTCVSD_ISR_Handle\\n\");\n\t\treturn ret;\n\t}\n\n\tbtcvsd->irq_id = irq_id;\n\n\t \n\tbtcvsd->bt_pkv_base = of_iomap(dev->of_node, 0);\n\tif (!btcvsd->bt_pkv_base) {\n\t\tdev_err(dev, \"iomap bt_pkv_base fail\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbtcvsd->bt_sram_bank2_base = of_iomap(dev->of_node, 1);\n\tif (!btcvsd->bt_sram_bank2_base) {\n\t\tdev_err(dev, \"iomap bt_sram_bank2_base fail\\n\");\n\t\tret = -EIO;\n\t\tgoto unmap_pkv_err;\n\t}\n\n\tbtcvsd->infra = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t\"mediatek,infracfg\");\n\tif (IS_ERR(btcvsd->infra)) {\n\t\tdev_err(dev, \"cannot find infra controller: %ld\\n\",\n\t\t\tPTR_ERR(btcvsd->infra));\n\t\tret = PTR_ERR(btcvsd->infra);\n\t\tgoto unmap_bank2_err;\n\t}\n\n\t \n\tret = of_property_read_u32_array(dev->of_node, \"mediatek,offset\",\n\t\t\t\t\t offset,\n\t\t\t\t\t ARRAY_SIZE(offset));\n\tif (ret) {\n\t\tdev_warn(dev, \"%s(), get offset fail, ret %d\\n\", __func__, ret);\n\t\tgoto unmap_bank2_err;\n\t}\n\tbtcvsd->infra_misc_offset = offset[0];\n\tbtcvsd->conn_bt_cvsd_mask = offset[1];\n\tbtcvsd->cvsd_mcu_read_offset = offset[2];\n\tbtcvsd->cvsd_mcu_write_offset = offset[3];\n\tbtcvsd->cvsd_packet_indicator = offset[4];\n\n\tbtcvsd->bt_reg_pkt_r = btcvsd->bt_pkv_base +\n\t\t\t       btcvsd->cvsd_mcu_read_offset;\n\tbtcvsd->bt_reg_pkt_w = btcvsd->bt_pkv_base +\n\t\t\t       btcvsd->cvsd_mcu_write_offset;\n\tbtcvsd->bt_reg_ctl = btcvsd->bt_pkv_base +\n\t\t\t     btcvsd->cvsd_packet_indicator;\n\n\t \n\tmtk_btcvsd_snd_set_state(btcvsd, btcvsd->tx, BT_SCO_STATE_IDLE);\n\tmtk_btcvsd_snd_set_state(btcvsd, btcvsd->rx, BT_SCO_STATE_IDLE);\n\n\tret = devm_snd_soc_register_component(dev, &mtk_btcvsd_snd_platform,\n\t\t\t\t\t      NULL, 0);\n\tif (ret)\n\t\tgoto unmap_bank2_err;\n\n\treturn 0;\n\nunmap_bank2_err:\n\tiounmap(btcvsd->bt_sram_bank2_base);\nunmap_pkv_err:\n\tiounmap(btcvsd->bt_pkv_base);\n\treturn ret;\n}\n\nstatic void mtk_btcvsd_snd_remove(struct platform_device *pdev)\n{\n\tstruct mtk_btcvsd_snd *btcvsd = dev_get_drvdata(&pdev->dev);\n\n\tiounmap(btcvsd->bt_pkv_base);\n\tiounmap(btcvsd->bt_sram_bank2_base);\n}\n\nstatic const struct of_device_id mtk_btcvsd_snd_dt_match[] = {\n\t{ .compatible = \"mediatek,mtk-btcvsd-snd\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_btcvsd_snd_dt_match);\n\nstatic struct platform_driver mtk_btcvsd_snd_driver = {\n\t.driver = {\n\t\t.name = \"mtk-btcvsd-snd\",\n\t\t.of_match_table = mtk_btcvsd_snd_dt_match,\n\t},\n\t.probe = mtk_btcvsd_snd_probe,\n\t.remove_new = mtk_btcvsd_snd_remove,\n};\n\nmodule_platform_driver(mtk_btcvsd_snd_driver);\n\nMODULE_DESCRIPTION(\"Mediatek ALSA BT SCO CVSD/MSBC Driver\");\nMODULE_AUTHOR(\"KaiChieh Chuang <kaichieh.chuang@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}