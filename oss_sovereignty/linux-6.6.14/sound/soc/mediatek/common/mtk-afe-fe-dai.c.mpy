{
  "module_name": "mtk-afe-fe-dai.c",
  "hash_id": "d458047eb03e1b2d5de74e5566a9d52f10edac449d327f7469bb608edc992774",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/common/mtk-afe-fe-dai.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"mtk-afe-platform-driver.h\"\n#include <sound/pcm_params.h>\n#include \"mtk-afe-fe-dai.h\"\n#include \"mtk-base-afe.h\"\n\n#define AFE_BASE_END_OFFSET 8\n\nstatic int mtk_regmap_update_bits(struct regmap *map, int reg,\n\t\t\t   unsigned int mask,\n\t\t\t   unsigned int val, int shift)\n{\n\tif (reg < 0 || WARN_ON_ONCE(shift < 0))\n\t\treturn 0;\n\treturn regmap_update_bits(map, reg, mask << shift, val << shift);\n}\n\nstatic int mtk_regmap_write(struct regmap *map, int reg, unsigned int val)\n{\n\tif (reg < 0)\n\t\treturn 0;\n\treturn regmap_write(map, reg, val);\n}\n\nint mtk_afe_fe_startup(struct snd_pcm_substream *substream,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint memif_num = asoc_rtd_to_cpu(rtd, 0)->id;\n\tstruct mtk_base_afe_memif *memif = &afe->memif[memif_num];\n\tconst struct snd_pcm_hardware *mtk_afe_hardware = afe->mtk_afe_hardware;\n\tint ret;\n\n\tmemif->substream = substream;\n\n\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 16);\n\t \n\tmtk_regmap_update_bits(afe->regmap, memif->data->agent_disable_reg,\n\t\t\t       1, 0, memif->data->agent_disable_shift);\n\n\tsnd_soc_set_runtime_hwparams(substream, mtk_afe_hardware);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tint periods_max = mtk_afe_hardware->periods_max;\n\n\t\tret = snd_pcm_hw_constraint_minmax(runtime,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIODS,\n\t\t\t\t\t\t   3, periods_max);\n\t\tif (ret < 0) {\n\t\t\tdev_err(afe->dev, \"hw_constraint_minmax failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\tdev_err(afe->dev, \"snd_pcm_hw_constraint_integer failed\\n\");\n\n\t \n\tif (memif->irq_usage < 0) {\n\t\tint irq_id = mtk_dynamic_irq_acquire(afe);\n\n\t\tif (irq_id != afe->irqs_size) {\n\t\t\t \n\t\t\tmemif->irq_usage = irq_id;\n\t\t} else {\n\t\t\tdev_err(afe->dev, \"%s() error: no more asys irq\\n\",\n\t\t\t\t__func__);\n\t\t\tret = -EBUSY;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_startup);\n\nvoid mtk_afe_fe_shutdown(struct snd_pcm_substream *substream,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tstruct mtk_base_afe_memif *memif = &afe->memif[asoc_rtd_to_cpu(rtd, 0)->id];\n\tint irq_id;\n\n\tirq_id = memif->irq_usage;\n\n\tmtk_regmap_update_bits(afe->regmap, memif->data->agent_disable_reg,\n\t\t\t       1, 1, memif->data->agent_disable_shift);\n\n\tif (!memif->const_irq) {\n\t\tmtk_dynamic_irq_release(afe, irq_id);\n\t\tmemif->irq_usage = -1;\n\t\tmemif->substream = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_shutdown);\n\nint mtk_afe_fe_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tint id = asoc_rtd_to_cpu(rtd, 0)->id;\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\tint ret;\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tsnd_pcm_format_t format = params_format(params);\n\n\tif (afe->request_dram_resource)\n\t\tafe->request_dram_resource(afe->dev);\n\n\tdev_dbg(afe->dev, \"%s(), %s, ch %d, rate %d, fmt %d, dma_addr %pad, dma_area %p, dma_bytes 0x%zx\\n\",\n\t\t__func__, memif->data->name,\n\t\tchannels, rate, format,\n\t\t&substream->runtime->dma_addr,\n\t\tsubstream->runtime->dma_area,\n\t\tsubstream->runtime->dma_bytes);\n\n\tmemset_io((void __force __iomem *)substream->runtime->dma_area, 0,\n\t\t  substream->runtime->dma_bytes);\n\n\t \n\tret = mtk_memif_set_addr(afe, id,\n\t\t\t\t substream->runtime->dma_area,\n\t\t\t\t substream->runtime->dma_addr,\n\t\t\t\t substream->runtime->dma_bytes);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"%s(), error, id %d, set addr, ret %d\\n\",\n\t\t\t__func__, id, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = mtk_memif_set_channel(afe, id, channels);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"%s(), error, id %d, set channel %d, ret %d\\n\",\n\t\t\t__func__, id, channels, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = mtk_memif_set_rate_substream(substream, id, rate);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"%s(), error, id %d, set rate %d, ret %d\\n\",\n\t\t\t__func__, id, rate, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = mtk_memif_set_format(afe, id, format);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"%s(), error, id %d, set format %d, ret %d\\n\",\n\t\t\t__func__, id, format, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_hw_params);\n\nint mtk_afe_fe_hw_free(struct snd_pcm_substream *substream,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\n\tif (afe->release_dram_resource)\n\t\tafe->release_dram_resource(afe->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_hw_free);\n\nint mtk_afe_fe_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime * const runtime = substream->runtime;\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tint id = asoc_rtd_to_cpu(rtd, 0)->id;\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\tstruct mtk_base_afe_irq *irqs = &afe->irqs[memif->irq_usage];\n\tconst struct mtk_base_irq_data *irq_data = irqs->irq_data;\n\tunsigned int counter = runtime->period_size;\n\tint fs;\n\tint ret;\n\n\tdev_dbg(afe->dev, \"%s %s cmd=%d\\n\", __func__, memif->data->name, cmd);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tret = mtk_memif_set_enable(afe, id);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"%s(), error, id %d, memif enable, ret %d\\n\",\n\t\t\t\t__func__, id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tmtk_regmap_update_bits(afe->regmap, irq_data->irq_cnt_reg,\n\t\t\t\t       irq_data->irq_cnt_maskbit, counter,\n\t\t\t\t       irq_data->irq_cnt_shift);\n\n\t\t \n\t\tfs = afe->irq_fs(substream, runtime->rate);\n\n\t\tif (fs < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmtk_regmap_update_bits(afe->regmap, irq_data->irq_fs_reg,\n\t\t\t\t       irq_data->irq_fs_maskbit, fs,\n\t\t\t\t       irq_data->irq_fs_shift);\n\n\t\t \n\t\tmtk_regmap_update_bits(afe->regmap, irq_data->irq_en_reg,\n\t\t\t\t       1, 1, irq_data->irq_en_shift);\n\n\t\treturn 0;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tret = mtk_memif_set_disable(afe, id);\n\t\tif (ret) {\n\t\t\tdev_err(afe->dev, \"%s(), error, id %d, memif enable, ret %d\\n\",\n\t\t\t\t__func__, id, ret);\n\t\t}\n\n\t\t \n\t\tmtk_regmap_update_bits(afe->regmap, irq_data->irq_en_reg,\n\t\t\t\t       1, 0, irq_data->irq_en_shift);\n\t\t \n\t\tmtk_regmap_write(afe->regmap, irq_data->irq_clr_reg,\n\t\t\t\t 1 << irq_data->irq_clr_shift);\n\t\treturn ret;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_trigger);\n\nint mtk_afe_fe_prepare(struct snd_pcm_substream *substream,\n\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd  = asoc_substream_to_rtd(substream);\n\tstruct mtk_base_afe *afe = snd_soc_dai_get_drvdata(dai);\n\tint id = asoc_rtd_to_cpu(rtd, 0)->id;\n\tint pbuf_size;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (afe->get_memif_pbuf_size) {\n\t\t\tpbuf_size = afe->get_memif_pbuf_size(substream);\n\t\t\tmtk_memif_set_pbuf_size(afe, id, pbuf_size);\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_fe_prepare);\n\nconst struct snd_soc_dai_ops mtk_afe_fe_ops = {\n\t.startup\t= mtk_afe_fe_startup,\n\t.shutdown\t= mtk_afe_fe_shutdown,\n\t.hw_params\t= mtk_afe_fe_hw_params,\n\t.hw_free\t= mtk_afe_fe_hw_free,\n\t.prepare\t= mtk_afe_fe_prepare,\n\t.trigger\t= mtk_afe_fe_trigger,\n};\nEXPORT_SYMBOL_GPL(mtk_afe_fe_ops);\n\nint mtk_dynamic_irq_acquire(struct mtk_base_afe *afe)\n{\n\tint i;\n\n\tmutex_lock(&afe->irq_alloc_lock);\n\tfor (i = 0; i < afe->irqs_size; ++i) {\n\t\tif (afe->irqs[i].irq_occupyed == 0) {\n\t\t\tafe->irqs[i].irq_occupyed = 1;\n\t\t\tmutex_unlock(&afe->irq_alloc_lock);\n\t\t\treturn i;\n\t\t}\n\t}\n\tmutex_unlock(&afe->irq_alloc_lock);\n\treturn afe->irqs_size;\n}\nEXPORT_SYMBOL_GPL(mtk_dynamic_irq_acquire);\n\nint mtk_dynamic_irq_release(struct mtk_base_afe *afe, int irq_id)\n{\n\tmutex_lock(&afe->irq_alloc_lock);\n\tif (irq_id >= 0 && irq_id < afe->irqs_size) {\n\t\tafe->irqs[irq_id].irq_occupyed = 0;\n\t\tmutex_unlock(&afe->irq_alloc_lock);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&afe->irq_alloc_lock);\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(mtk_dynamic_irq_release);\n\nint mtk_afe_suspend(struct snd_soc_component *component)\n{\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = afe->dev;\n\tstruct regmap *regmap = afe->regmap;\n\tint i;\n\n\tif (pm_runtime_status_suspended(dev) || afe->suspended)\n\t\treturn 0;\n\n\tif (!afe->reg_back_up)\n\t\tafe->reg_back_up =\n\t\t\tdevm_kcalloc(dev, afe->reg_back_up_list_num,\n\t\t\t\t     sizeof(unsigned int), GFP_KERNEL);\n\n\tif (afe->reg_back_up) {\n\t\tfor (i = 0; i < afe->reg_back_up_list_num; i++)\n\t\t\tregmap_read(regmap, afe->reg_back_up_list[i],\n\t\t\t\t    &afe->reg_back_up[i]);\n\t}\n\n\tafe->suspended = true;\n\tafe->runtime_suspend(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_suspend);\n\nint mtk_afe_resume(struct snd_soc_component *component)\n{\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = afe->dev;\n\tstruct regmap *regmap = afe->regmap;\n\tint i;\n\n\tif (pm_runtime_status_suspended(dev) || !afe->suspended)\n\t\treturn 0;\n\n\tafe->runtime_resume(dev);\n\n\tif (!afe->reg_back_up) {\n\t\tdev_dbg(dev, \"%s no reg_backup\\n\", __func__);\n\t} else {\n\t\tfor (i = 0; i < afe->reg_back_up_list_num; i++)\n\t\t\tmtk_regmap_write(regmap, afe->reg_back_up_list[i],\n\t\t\t\t\t afe->reg_back_up[i]);\n\t}\n\n\tafe->suspended = false;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_afe_resume);\n\nint mtk_memif_set_enable(struct mtk_base_afe *afe, int id)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\n\tif (memif->data->enable_shift < 0) {\n\t\tdev_warn(afe->dev, \"%s(), error, id %d, enable_shift < 0\\n\",\n\t\t\t __func__, id);\n\t\treturn 0;\n\t}\n\treturn mtk_regmap_update_bits(afe->regmap, memif->data->enable_reg,\n\t\t\t\t      1, 1, memif->data->enable_shift);\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_enable);\n\nint mtk_memif_set_disable(struct mtk_base_afe *afe, int id)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\n\tif (memif->data->enable_shift < 0) {\n\t\tdev_warn(afe->dev, \"%s(), error, id %d, enable_shift < 0\\n\",\n\t\t\t __func__, id);\n\t\treturn 0;\n\t}\n\treturn mtk_regmap_update_bits(afe->regmap, memif->data->enable_reg,\n\t\t\t\t      1, 0, memif->data->enable_shift);\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_disable);\n\nint mtk_memif_set_addr(struct mtk_base_afe *afe, int id,\n\t\t       unsigned char *dma_area,\n\t\t       dma_addr_t dma_addr,\n\t\t       size_t dma_bytes)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\tint msb_at_bit33 = upper_32_bits(dma_addr) ? 1 : 0;\n\tunsigned int phys_buf_addr = lower_32_bits(dma_addr);\n\tunsigned int phys_buf_addr_upper_32 = upper_32_bits(dma_addr);\n\n\tmemif->dma_area = dma_area;\n\tmemif->dma_addr = dma_addr;\n\tmemif->dma_bytes = dma_bytes;\n\n\t \n\tmtk_regmap_write(afe->regmap, memif->data->reg_ofs_base,\n\t\t\t phys_buf_addr);\n\t \n\tif (memif->data->reg_ofs_end)\n\t\tmtk_regmap_write(afe->regmap,\n\t\t\t\t memif->data->reg_ofs_end,\n\t\t\t\t phys_buf_addr + dma_bytes - 1);\n\telse\n\t\tmtk_regmap_write(afe->regmap,\n\t\t\t\t memif->data->reg_ofs_base +\n\t\t\t\t AFE_BASE_END_OFFSET,\n\t\t\t\t phys_buf_addr + dma_bytes - 1);\n\n\t \n\tif (memif->data->reg_ofs_base_msb) {\n\t\tmtk_regmap_write(afe->regmap, memif->data->reg_ofs_base_msb,\n\t\t\t\t phys_buf_addr_upper_32);\n\t\tmtk_regmap_write(afe->regmap,\n\t\t\t\t memif->data->reg_ofs_end_msb,\n\t\t\t\t phys_buf_addr_upper_32);\n\t}\n\n\t \n\tif (memif->data->msb_reg)\n\t\tmtk_regmap_update_bits(afe->regmap, memif->data->msb_reg,\n\t\t\t\t       1, msb_at_bit33, memif->data->msb_shift);\n\n\t \n\tif (memif->data->msb_end_reg)\n\t\tmtk_regmap_update_bits(afe->regmap, memif->data->msb_end_reg,\n\t\t\t\t       1, msb_at_bit33,\n\t\t\t\t       memif->data->msb_end_shift);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_addr);\n\nint mtk_memif_set_channel(struct mtk_base_afe *afe,\n\t\t\t  int id, unsigned int channel)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\tunsigned int mono;\n\n\tif (memif->data->mono_shift < 0)\n\t\treturn 0;\n\n\tif (memif->data->quad_ch_mask) {\n\t\tunsigned int quad_ch = (channel == 4) ? 1 : 0;\n\n\t\tmtk_regmap_update_bits(afe->regmap, memif->data->quad_ch_reg,\n\t\t\t\t       memif->data->quad_ch_mask,\n\t\t\t\t       quad_ch, memif->data->quad_ch_shift);\n\t}\n\n\tif (memif->data->mono_invert)\n\t\tmono = (channel == 1) ? 0 : 1;\n\telse\n\t\tmono = (channel == 1) ? 1 : 0;\n\n\t \n\tif (memif->data->int_odd_flag_reg)\n\t\tmtk_regmap_update_bits(afe->regmap,\n\t\t\t\t       memif->data->int_odd_flag_reg,\n\t\t\t\t       1, mono,\n\t\t\t\t       memif->data->int_odd_flag_shift);\n\n\treturn mtk_regmap_update_bits(afe->regmap, memif->data->mono_reg,\n\t\t\t\t      1, mono, memif->data->mono_shift);\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_channel);\n\nstatic int mtk_memif_set_rate_fs(struct mtk_base_afe *afe,\n\t\t\t\t int id, int fs)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\n\tif (memif->data->fs_shift >= 0)\n\t\tmtk_regmap_update_bits(afe->regmap, memif->data->fs_reg,\n\t\t\t\t       memif->data->fs_maskbit,\n\t\t\t\t       fs, memif->data->fs_shift);\n\n\treturn 0;\n}\n\nint mtk_memif_set_rate(struct mtk_base_afe *afe,\n\t\t       int id, unsigned int rate)\n{\n\tint fs = 0;\n\n\tif (!afe->get_dai_fs) {\n\t\tdev_err(afe->dev, \"%s(), error, afe->get_dai_fs == NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfs = afe->get_dai_fs(afe, id, rate);\n\n\tif (fs < 0)\n\t\treturn -EINVAL;\n\n\treturn mtk_memif_set_rate_fs(afe, id, fs);\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_rate);\n\nint mtk_memif_set_rate_substream(struct snd_pcm_substream *substream,\n\t\t\t\t int id, unsigned int rate)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_rtdcom_lookup(rtd, AFE_PCM_NAME);\n\tstruct mtk_base_afe *afe = snd_soc_component_get_drvdata(component);\n\n\tint fs = 0;\n\n\tif (!afe->memif_fs) {\n\t\tdev_err(afe->dev, \"%s(), error, afe->memif_fs == NULL\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tfs = afe->memif_fs(substream, rate);\n\n\tif (fs < 0)\n\t\treturn -EINVAL;\n\n\treturn mtk_memif_set_rate_fs(afe, id, fs);\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_rate_substream);\n\nint mtk_memif_set_format(struct mtk_base_afe *afe,\n\t\t\t int id, snd_pcm_format_t format)\n{\n\tstruct mtk_base_afe_memif *memif = &afe->memif[id];\n\tint hd_audio = 0;\n\tint hd_align = 0;\n\n\t \n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\tcase SNDRV_PCM_FORMAT_U16_LE:\n\t\thd_audio = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\tcase SNDRV_PCM_FORMAT_U32_LE:\n\t\tif (afe->memif_32bit_supported) {\n\t\t\thd_audio = 2;\n\t\t\thd_align = 0;\n\t\t} else {\n\t\t\thd_audio = 1;\n\t\t\thd_align = 1;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\tcase SNDRV_PCM_FORMAT_U24_LE:\n\t\thd_audio = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(afe->dev, \"%s() error: unsupported format %d\\n\",\n\t\t\t__func__, format);\n\t\tbreak;\n\t}\n\n\tmtk_regmap_update_bits(afe->regmap, memif->data->hd_reg,\n\t\t\t       0x3, hd_audio, memif->data->hd_shift);\n\n\tmtk_regmap_update_bits(afe->regmap, memif->data->hd_align_reg,\n\t\t\t       0x1, hd_align, memif->data->hd_align_mshift);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_format);\n\nint mtk_memif_set_pbuf_size(struct mtk_base_afe *afe,\n\t\t\t    int id, int pbuf_size)\n{\n\tconst struct mtk_base_memif_data *memif_data = afe->memif[id].data;\n\n\tif (memif_data->pbuf_mask == 0 || memif_data->minlen_mask == 0)\n\t\treturn 0;\n\n\tmtk_regmap_update_bits(afe->regmap, memif_data->pbuf_reg,\n\t\t\t       memif_data->pbuf_mask,\n\t\t\t       pbuf_size, memif_data->pbuf_shift);\n\n\tmtk_regmap_update_bits(afe->regmap, memif_data->minlen_reg,\n\t\t\t       memif_data->minlen_mask,\n\t\t\t       pbuf_size, memif_data->minlen_shift);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mtk_memif_set_pbuf_size);\n\nMODULE_DESCRIPTION(\"Mediatek simple fe dai operator\");\nMODULE_AUTHOR(\"Garlic Tseng <garlic.tseng@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}