{
  "module_name": "mtk-soundcard-driver.c",
  "hash_id": "96799781bd6855838b8f9a2fa105a5485e51d5c52e398a3891ee715e2158b954",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/common/mtk-soundcard-driver.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <sound/soc.h>\n\n#include \"mtk-soundcard-driver.h\"\n\nstatic int set_card_codec_info(struct snd_soc_card *card,\n\t\t\t       struct device_node *sub_node,\n\t\t\t       struct snd_soc_dai_link *dai_link)\n{\n\tstruct device *dev = card->dev;\n\tstruct device_node *codec_node;\n\tint ret;\n\n\tcodec_node = of_get_child_by_name(sub_node, \"codec\");\n\tif (!codec_node) {\n\t\tdev_dbg(dev, \"%s no specified codec\\n\", dai_link->name);\n\t\treturn 0;\n\t}\n\n\t \n\tret = snd_soc_of_get_dai_link_codecs(dev, codec_node, dai_link);\n\n\tof_node_put(codec_node);\n\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"%s: codec dai not found\\n\",\n\t\t\t\t     dai_link->name);\n\n\treturn 0;\n}\n\nstatic int set_dailink_daifmt(struct snd_soc_card *card,\n\t\t\t      struct device_node *sub_node,\n\t\t\t      struct snd_soc_dai_link *dai_link)\n{\n\tunsigned int daifmt;\n\tconst char *str;\n\tint ret;\n\tstruct {\n\t\tchar *name;\n\t\tunsigned int val;\n\t} of_clk_table[] = {\n\t\t{ \"cpu\",\tSND_SOC_DAIFMT_CBC_CFC },\n\t\t{ \"codec\",\tSND_SOC_DAIFMT_CBP_CFP },\n\t};\n\n\tdaifmt = snd_soc_daifmt_parse_format(sub_node, NULL);\n\tif (daifmt) {\n\t\tdai_link->dai_fmt &= SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\t\tdai_link->dai_fmt |= daifmt;\n\t}\n\n\t \n\tret = of_property_read_string(sub_node, \"mediatek,clk-provider\", &str);\n\tif (ret == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(of_clk_table); i++) {\n\t\t\tif (strcmp(str, of_clk_table[i].name) == 0) {\n\t\t\t\tdai_link->dai_fmt &= ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\t\t\t\tdai_link->dai_fmt |= of_clk_table[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint parse_dai_link_info(struct snd_soc_card *card)\n{\n\tstruct device *dev = card->dev;\n\tstruct device_node *sub_node;\n\tstruct snd_soc_dai_link *dai_link;\n\tconst char *dai_link_name;\n\tint ret, i;\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, sub_node) {\n\t\tif (of_property_read_string(sub_node, \"link-name\",\n\t\t\t\t\t    &dai_link_name)) {\n\t\t\tof_node_put(sub_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor_each_card_prelinks(card, i, dai_link) {\n\t\t\tif (!strcmp(dai_link_name, dai_link->name))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= card->num_links) {\n\t\t\tof_node_put(sub_node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = set_card_codec_info(card, sub_node, dai_link);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(sub_node);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = set_dailink_daifmt(card, sub_node, dai_link);\n\t\tif (ret < 0) {\n\t\t\tof_node_put(sub_node);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(parse_dai_link_info);\n\nvoid clean_card_reference(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tint i;\n\n\t \n\tfor_each_card_prelinks(card, i, dai_link)\n\t\tsnd_soc_of_put_dai_link_codecs(dai_link);\n}\nEXPORT_SYMBOL_GPL(clean_card_reference);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}