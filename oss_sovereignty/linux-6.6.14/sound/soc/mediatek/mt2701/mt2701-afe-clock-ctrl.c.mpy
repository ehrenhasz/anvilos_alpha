{
  "module_name": "mt2701-afe-clock-ctrl.c",
  "hash_id": "dd07adb1480cf2ca04705e64f0c17eb867cdc6ca555173fba38fffdf57a52a1d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/mediatek/mt2701/mt2701-afe-clock-ctrl.c",
  "human_readable_source": "\n \n\n#include \"mt2701-afe-common.h\"\n#include \"mt2701-afe-clock-ctrl.h\"\n\nstatic const char *const base_clks[] = {\n\t[MT2701_INFRA_SYS_AUDIO] = \"infra_sys_audio_clk\",\n\t[MT2701_TOP_AUD_MCLK_SRC0] = \"top_audio_mux1_sel\",\n\t[MT2701_TOP_AUD_MCLK_SRC1] = \"top_audio_mux2_sel\",\n\t[MT2701_TOP_AUD_A1SYS] = \"top_audio_a1sys_hp\",\n\t[MT2701_TOP_AUD_A2SYS] = \"top_audio_a2sys_hp\",\n\t[MT2701_AUDSYS_AFE] = \"audio_afe_pd\",\n\t[MT2701_AUDSYS_AFE_CONN] = \"audio_afe_conn_pd\",\n\t[MT2701_AUDSYS_A1SYS] = \"audio_a1sys_pd\",\n\t[MT2701_AUDSYS_A2SYS] = \"audio_a2sys_pd\",\n};\n\nint mt2701_init_clock(struct mtk_base_afe *afe)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\tint i;\n\n\tfor (i = 0; i < MT2701_BASE_CLK_NUM; i++) {\n\t\tafe_priv->base_ck[i] = devm_clk_get(afe->dev, base_clks[i]);\n\t\tif (IS_ERR(afe_priv->base_ck[i])) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", base_clks[i]);\n\t\t\treturn PTR_ERR(afe_priv->base_ck[i]);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < afe_priv->soc->i2s_num; i++) {\n\t\tstruct mt2701_i2s_path *i2s_path = &afe_priv->i2s_path[i];\n\t\tstruct clk *i2s_ck;\n\t\tchar name[13];\n\n\t\tsnprintf(name, sizeof(name), \"i2s%d_src_sel\", i);\n\t\ti2s_path->sel_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_path->sel_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_path->sel_ck);\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"i2s%d_src_div\", i);\n\t\ti2s_path->div_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_path->div_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_path->div_ck);\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"i2s%d_mclk_en\", i);\n\t\ti2s_path->mclk_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_path->mclk_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_path->mclk_ck);\n\t\t}\n\n\t\tsnprintf(name, sizeof(name), \"i2so%d_hop_ck\", i);\n\t\ti2s_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_ck);\n\t\t}\n\t\ti2s_path->hop_ck[SNDRV_PCM_STREAM_PLAYBACK] = i2s_ck;\n\n\t\tsnprintf(name, sizeof(name), \"i2si%d_hop_ck\", i);\n\t\ti2s_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_ck);\n\t\t}\n\t\ti2s_path->hop_ck[SNDRV_PCM_STREAM_CAPTURE] = i2s_ck;\n\n\t\tsnprintf(name, sizeof(name), \"asrc%d_out_ck\", i);\n\t\ti2s_path->asrco_ck = devm_clk_get(afe->dev, name);\n\t\tif (IS_ERR(i2s_path->asrco_ck)) {\n\t\t\tdev_err(afe->dev, \"failed to get %s\\n\", name);\n\t\t\treturn PTR_ERR(i2s_path->asrco_ck);\n\t\t}\n\t}\n\n\t \n\tafe_priv->mrgif_ck = devm_clk_get(afe->dev, \"audio_mrgif_pd\");\n\tif (IS_ERR(afe_priv->mrgif_ck)) {\n\t\tif (PTR_ERR(afe_priv->mrgif_ck) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tafe_priv->mrgif_ck = NULL;\n\t}\n\n\treturn 0;\n}\n\nint mt2701_afe_enable_i2s(struct mtk_base_afe *afe,\n\t\t\t  struct mt2701_i2s_path *i2s_path,\n\t\t\t  int dir)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(i2s_path->asrco_ck);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"failed to enable ASRC clock %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(i2s_path->hop_ck[dir]);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"failed to enable I2S clock %d\\n\", ret);\n\t\tgoto err_hop_ck;\n\t}\n\n\treturn 0;\n\nerr_hop_ck:\n\tclk_disable_unprepare(i2s_path->asrco_ck);\n\n\treturn ret;\n}\n\nvoid mt2701_afe_disable_i2s(struct mtk_base_afe *afe,\n\t\t\t    struct mt2701_i2s_path *i2s_path,\n\t\t\t    int dir)\n{\n\tclk_disable_unprepare(i2s_path->hop_ck[dir]);\n\tclk_disable_unprepare(i2s_path->asrco_ck);\n}\n\nint mt2701_afe_enable_mclk(struct mtk_base_afe *afe, int id)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\tstruct mt2701_i2s_path *i2s_path = &afe_priv->i2s_path[id];\n\n\treturn clk_prepare_enable(i2s_path->mclk_ck);\n}\n\nvoid mt2701_afe_disable_mclk(struct mtk_base_afe *afe, int id)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\tstruct mt2701_i2s_path *i2s_path = &afe_priv->i2s_path[id];\n\n\tclk_disable_unprepare(i2s_path->mclk_ck);\n}\n\nint mt2701_enable_btmrg_clk(struct mtk_base_afe *afe)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\n\treturn clk_prepare_enable(afe_priv->mrgif_ck);\n}\n\nvoid mt2701_disable_btmrg_clk(struct mtk_base_afe *afe)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\n\tclk_disable_unprepare(afe_priv->mrgif_ck);\n}\n\nstatic int mt2701_afe_enable_audsys(struct mtk_base_afe *afe)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_INFRA_SYS_AUDIO]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_TOP_AUD_A1SYS]);\n\tif (ret)\n\t\tgoto err_a1sys;\n\n\t \n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_TOP_AUD_A2SYS]);\n\tif (ret)\n\t\tgoto err_a2sys;\n\n\t \n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_AUDSYS_AFE]);\n\tif (ret)\n\t\tgoto err_afe;\n\n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_AUDSYS_A1SYS]);\n\tif (ret)\n\t\tgoto err_audio_a1sys;\n\n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_AUDSYS_A2SYS]);\n\tif (ret)\n\t\tgoto err_audio_a2sys;\n\n\tret = clk_prepare_enable(afe_priv->base_ck[MT2701_AUDSYS_AFE_CONN]);\n\tif (ret)\n\t\tgoto err_afe_conn;\n\n\treturn 0;\n\nerr_afe_conn:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_A2SYS]);\nerr_audio_a2sys:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_A1SYS]);\nerr_audio_a1sys:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_AFE]);\nerr_afe:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_TOP_AUD_A2SYS]);\nerr_a2sys:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_TOP_AUD_A1SYS]);\nerr_a1sys:\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_INFRA_SYS_AUDIO]);\n\n\treturn ret;\n}\n\nstatic void mt2701_afe_disable_audsys(struct mtk_base_afe *afe)\n{\n\tstruct mt2701_afe_private *afe_priv = afe->platform_priv;\n\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_AFE_CONN]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_A2SYS]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_A1SYS]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_AUDSYS_AFE]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_TOP_AUD_A1SYS]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_TOP_AUD_A2SYS]);\n\tclk_disable_unprepare(afe_priv->base_ck[MT2701_INFRA_SYS_AUDIO]);\n}\n\nint mt2701_afe_enable_clock(struct mtk_base_afe *afe)\n{\n\tint ret;\n\n\t \n\tret = mt2701_afe_enable_audsys(afe);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"failed to enable audio system %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(afe->regmap, ASYS_TOP_CON,\n\t\t\t   ASYS_TOP_CON_ASYS_TIMING_ON,\n\t\t\t   ASYS_TOP_CON_ASYS_TIMING_ON);\n\tregmap_update_bits(afe->regmap, AFE_DAC_CON0,\n\t\t\t   AFE_DAC_CON0_AFE_ON,\n\t\t\t   AFE_DAC_CON0_AFE_ON);\n\n\t \n\tregmap_write(afe->regmap, PWR1_ASM_CON1, PWR1_ASM_CON1_INIT_VAL);\n\tregmap_write(afe->regmap, PWR2_ASM_CON1, PWR2_ASM_CON1_INIT_VAL);\n\n\treturn 0;\n}\n\nint mt2701_afe_disable_clock(struct mtk_base_afe *afe)\n{\n\tregmap_update_bits(afe->regmap, ASYS_TOP_CON,\n\t\t\t   ASYS_TOP_CON_ASYS_TIMING_ON, 0);\n\tregmap_update_bits(afe->regmap, AFE_DAC_CON0,\n\t\t\t   AFE_DAC_CON0_AFE_ON, 0);\n\n\tmt2701_afe_disable_audsys(afe);\n\n\treturn 0;\n}\n\nint mt2701_mclk_configuration(struct mtk_base_afe *afe, int id)\n\n{\n\tstruct mt2701_afe_private *priv = afe->platform_priv;\n\tstruct mt2701_i2s_path *i2s_path = &priv->i2s_path[id];\n\tint ret = -EINVAL;\n\n\t \n\tif (!(MT2701_PLL_DOMAIN_0_RATE % i2s_path->mclk_rate))\n\t\tret = clk_set_parent(i2s_path->sel_ck,\n\t\t\t\t     priv->base_ck[MT2701_TOP_AUD_MCLK_SRC0]);\n\telse if (!(MT2701_PLL_DOMAIN_1_RATE % i2s_path->mclk_rate))\n\t\tret = clk_set_parent(i2s_path->sel_ck,\n\t\t\t\t     priv->base_ck[MT2701_TOP_AUD_MCLK_SRC1]);\n\n\tif (ret) {\n\t\tdev_err(afe->dev, \"failed to set mclk source\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_set_rate(i2s_path->div_ck, i2s_path->mclk_rate);\n\tif (ret) {\n\t\tdev_err(afe->dev, \"failed to set mclk divider %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}