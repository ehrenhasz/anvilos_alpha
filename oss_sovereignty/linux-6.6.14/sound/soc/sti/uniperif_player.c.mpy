{
  "module_name": "uniperif_player.c",
  "hash_id": "0497521b37b91d66da3e6150cd661aecc4d5f0e2b7116f2c7256d057261d1b29",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sti/uniperif_player.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n\n#include <sound/asoundef.h>\n#include <sound/soc.h>\n\n#include \"uniperif.h\"\n\n \n\n \n#define SYS_CFG_AUDIO_GLUE 0xA4\n\n \n\n#define UNIPERIF_PLAYER_CLK_ADJ_MIN  -999999\n#define UNIPERIF_PLAYER_CLK_ADJ_MAX  1000000\n#define UNIPERIF_PLAYER_I2S_OUT 1  \n\n \nstatic const struct snd_pcm_hardware uni_player_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min = 8000,\n\t.rate_max = 192000,\n\n\t.channels_min = 2,\n\t.channels_max = 8,\n\n\t.periods_min = 2,\n\t.periods_max = 48,\n\n\t.period_bytes_min = 128,\n\t.period_bytes_max = 64 * PAGE_SIZE,\n\t.buffer_bytes_max = 256 * PAGE_SIZE\n};\n\n \nstatic irqreturn_t uni_player_irq_handler(int irq, void *dev_id)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct uniperif *player = dev_id;\n\tunsigned int status;\n\tunsigned int tmp;\n\n\tspin_lock(&player->irq_lock);\n\tif (!player->substream)\n\t\tgoto irq_spin_unlock;\n\n\tsnd_pcm_stream_lock(player->substream);\n\tif (player->state == UNIPERIF_STATE_STOPPED)\n\t\tgoto stream_unlock;\n\n\t \n\tstatus = GET_UNIPERIF_ITS(player);\n\tSET_UNIPERIF_ITS_BCLR(player, status);\n\n\t \n\tif (unlikely(status & UNIPERIF_ITS_FIFO_ERROR_MASK(player))) {\n\t\tdev_err(player->dev, \"FIFO underflow error detected\\n\");\n\n\t\t \n\t\tif (player->underflow_enabled) {\n\t\t\t \n\t\t\tplayer->state = UNIPERIF_STATE_UNDERFLOW;\n\n\t\t} else {\n\t\t\t \n\t\t\tSET_UNIPERIF_ITM_BCLR_FIFO_ERROR(player);\n\n\t\t\t \n\t\t\tsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\n\t\t}\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (unlikely(status & UNIPERIF_ITS_DMA_ERROR_MASK(player))) {\n\t\tdev_err(player->dev, \"DMA error detected\\n\");\n\n\t\t \n\t\tSET_UNIPERIF_ITM_BCLR_DMA_ERROR(player);\n\n\t\t \n\t\tsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (unlikely(status & UNIPERIF_ITM_UNDERFLOW_REC_DONE_MASK(player))) {\n\t\tif (!player->underflow_enabled) {\n\t\t\tdev_err(player->dev,\n\t\t\t\t\"unexpected Underflow recovering\\n\");\n\t\t\tret = -EPERM;\n\t\t\tgoto stream_unlock;\n\t\t}\n\t\t \n\t\ttmp = GET_UNIPERIF_STATUS_1_UNDERFLOW_DURATION(player);\n\t\tdev_dbg(player->dev, \"Underflow recovered (%d LR clocks max)\\n\",\n\t\t\ttmp);\n\n\t\t \n\t\tSET_UNIPERIF_BIT_CONTROL_CLR_UNDERFLOW_DURATION(player);\n\n\t\t \n\t\tplayer->state = UNIPERIF_STATE_STARTED;\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (unlikely(status &\n\t\t     UNIPERIF_ITM_UNDERFLOW_REC_FAILED_MASK(player))) {\n\t\tdev_err(player->dev, \"Underflow recovery failed\\n\");\n\n\t\t \n\t\tsnd_pcm_stop(player->substream, SNDRV_PCM_STATE_XRUN);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\nstream_unlock:\n\tsnd_pcm_stream_unlock(player->substream);\nirq_spin_unlock:\n\tspin_unlock(&player->irq_lock);\n\n\treturn ret;\n}\n\nstatic int uni_player_clk_set_rate(struct uniperif *player, unsigned long rate)\n{\n\tint rate_adjusted, rate_achieved, delta, ret;\n\tint adjustment = player->clk_adj;\n\n\t \n\tif (adjustment < 0) {\n\t\t \n\t\tdelta = -1;\n\t\tadjustment = -adjustment;\n\t} else {\n\t\tdelta = 1;\n\t}\n\t \n\tdelta *= (int)div64_u64((uint64_t)rate *\n\t\t\t\t(uint64_t)adjustment + 500000, 1000000);\n\trate_adjusted = rate + delta;\n\n\t \n\tif (!rate_adjusted)\n\t\treturn -EINVAL;\n\n\tret = clk_set_rate(player->clk, rate_adjusted);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trate_achieved = clk_get_rate(player->clk);\n\tif (!rate_achieved)\n\t\t \n\t\treturn -EINVAL;\n\n\t \n\tdelta = rate_achieved - rate;\n\tif (delta < 0) {\n\t\t \n\t\tdelta = -delta;\n\t\tadjustment = -1;\n\t} else {\n\t\tadjustment = 1;\n\t}\n\t \n\tadjustment *= (int)div64_u64((uint64_t)delta * 1000000 + rate / 2,\n\t\t\t\t     rate);\n\tplayer->clk_adj = adjustment;\n\treturn 0;\n}\n\nstatic void uni_player_set_channel_status(struct uniperif *player,\n\t\t\t\t\t  struct snd_pcm_runtime *runtime)\n{\n\tint n;\n\tunsigned int status;\n\n\t \n\tif (runtime) {\n\t\tswitch (runtime->rate) {\n\t\tcase 22050:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_22050;\n\t\t\tbreak;\n\t\tcase 44100:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_44100;\n\t\t\tbreak;\n\t\tcase 88200:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_88200;\n\t\t\tbreak;\n\t\tcase 176400:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_176400;\n\t\t\tbreak;\n\t\tcase 24000:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_24000;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_48000;\n\t\t\tbreak;\n\t\tcase 96000:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_96000;\n\t\t\tbreak;\n\t\tcase 192000:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_192000;\n\t\t\tbreak;\n\t\tcase 32000:\n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_32000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\t\tIEC958_AES3_CON_FS_NOTID;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (player->stream_settings.iec958.status[0] & IEC958_AES0_NONAUDIO)\n\t\tplayer->stream_settings.encoding_mode =\n\t\t\tUNIPERIF_IEC958_ENCODING_MODE_ENCODED;\n\telse\n\t\tplayer->stream_settings.encoding_mode =\n\t\t\tUNIPERIF_IEC958_ENCODING_MODE_PCM;\n\n\tif (player->stream_settings.encoding_mode ==\n\t\tUNIPERIF_IEC958_ENCODING_MODE_PCM)\n\t\t \n\t\tSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\n\telse\n\t\t \n\t\tSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 1);\n\n\t \n\tfor (n = 0; n < 6; ++n) {\n\t\tstatus  =\n\t\tplayer->stream_settings.iec958.status[0 + (n * 4)] & 0xf;\n\t\tstatus |=\n\t\tplayer->stream_settings.iec958.status[1 + (n * 4)] << 8;\n\t\tstatus |=\n\t\tplayer->stream_settings.iec958.status[2 + (n * 4)] << 16;\n\t\tstatus |=\n\t\tplayer->stream_settings.iec958.status[3 + (n * 4)] << 24;\n\t\tSET_UNIPERIF_CHANNEL_STA_REGN(player, n, status);\n\t}\n\n\t \n\tif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\tSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\n\telse\n\t\tSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\n}\n\nstatic int uni_player_prepare_iec958(struct uniperif *player,\n\t\t\t\t     struct snd_pcm_runtime *runtime)\n{\n\tint clk_div;\n\n\tclk_div = player->mclk / runtime->rate;\n\n\t \n\tif ((clk_div % 128) || (clk_div <= 0)) {\n\t\tdev_err(player->dev, \"%s: invalid clk_div %d\\n\",\n\t\t\t__func__, clk_div);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\n\t\t \n\t\tSET_UNIPERIF_I2S_FMT_NBIT_32(player);\n\t\t \n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\n\t\t \n\t\tSET_UNIPERIF_I2S_FMT_NBIT_32(player);\n\t\t \n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_24(player);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(player->dev, \"format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tSET_UNIPERIF_CONFIG_PARITY_CNTR_BY_HW(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_CHANNEL_STA_CNTR_BY_HW(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_USER_DAT_CNTR_BY_HW(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_VALIDITY_DAT_CNTR_BY_HW(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_SPDIF_SW_CTRL_DISABLE(player);\n\n\tSET_UNIPERIF_CTRL_ZERO_STUFF_HW(player);\n\n\tmutex_lock(&player->ctrl_lock);\n\t \n\tuni_player_set_channel_status(player, runtime);\n\tmutex_unlock(&player->ctrl_lock);\n\n\t \n\tSET_UNIPERIF_USER_VALIDITY_VALIDITY_LR(player, 0);\n\n\t \n\tSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_REPEAT_CHL_STS_ENABLE(player);\n\n\t \n\tSET_UNIPERIF_CONFIG_SUBFRAME_SEL_SUBF1_SUBF0(player);\n\n\t \n\tSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\n\n\tif (player->stream_settings.encoding_mode ==\n\t\t\t\tUNIPERIF_IEC958_ENCODING_MODE_ENCODED)\n\t\tSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_ON(player);\n\telse\n\t\tSET_UNIPERIF_CTRL_EXIT_STBY_ON_EOBLOCK_OFF(player);\n\n\tSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\n\n\t \n\tSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\n\n\t \n\tSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / 128);\n\n\t \n\tSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\n\n\t \n\tif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\tSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\n\telse\n\t\tSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\n\n\treturn 0;\n}\n\nstatic int uni_player_prepare_pcm(struct uniperif *player,\n\t\t\t\t  struct snd_pcm_runtime *runtime)\n{\n\tint output_frame_size, slot_width, clk_div;\n\n\t \n\tif ((player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\n\t\tSND_SOC_DAIFMT_I2S)\n\t\tslot_width = 32;\n\telse\n\t\tslot_width = snd_pcm_format_width(runtime->format);\n\n\toutput_frame_size = slot_width * runtime->channels;\n\n\tclk_div = player->mclk / runtime->rate;\n\t \n\tif ((slot_width == 32) && (clk_div % 128)) {\n\t\tdev_err(player->dev, \"%s: invalid clk_div\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((slot_width == 16) && (clk_div % 64)) {\n\t\tdev_err(player->dev, \"%s: invalid clk_div\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (slot_width) {\n\tcase 32:\n\t\tSET_UNIPERIF_I2S_FMT_NBIT_32(player);\n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(player);\n\t\tbreak;\n\tcase 16:\n\t\tSET_UNIPERIF_I2S_FMT_NBIT_16(player);\n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(player);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(player->dev, \"subframe format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_16(player);\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(player->dev, \"format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\n\n\t \n\tSET_UNIPERIF_CTRL_DIVIDER(player, clk_div / (2 * output_frame_size));\n\n\t \n\tif ((runtime->channels % 2) || (runtime->channels < 2) ||\n\t    (runtime->channels > 10)) {\n\t\tdev_err(player->dev, \"%s: invalid nb of channels\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tSET_UNIPERIF_I2S_FMT_NUM_CH(player, runtime->channels / 2);\n\n\t \n\tSET_UNIPERIF_CONFIG_ONE_BIT_AUD_DISABLE(player);\n\n\tSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\n\n\t \n\tSET_UNIPERIF_CTRL_SPDIF_FMT_OFF(player);\n\n\treturn 0;\n}\n\nstatic int uni_player_prepare_tdm(struct uniperif *player,\n\t\t\t\t  struct snd_pcm_runtime *runtime)\n{\n\tint tdm_frame_size;  \n\tint user_frame_size;  \n\t \n\tunsigned int word_pos[4] = {\n\t\t0x04060002, 0x0C0E080A, 0x14161012, 0x1C1E181A};\n\tint freq, ret;\n\n\ttdm_frame_size =\n\t\tsti_uniperiph_get_unip_tdm_frame_size(player);\n\tuser_frame_size =\n\t\tsti_uniperiph_get_user_frame_size(runtime);\n\n\t \n\tSET_UNIPERIF_CONFIG_MEM_FMT_16_0(player);\n\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(player);\n\n\t \n\tSET_UNIPERIF_I2S_FMT_NUM_CH(player, user_frame_size / 4 / 2);\n\n\tSET_UNIPERIF_I2S_FMT_ORDER_MSB(player);\n\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\n\n\t \n\tSET_UNIPERIF_TDM_ENABLE_TDM_ENABLE(player);\n\n\t \n\tSET_UNIPERIF_TDM_FS_REF_DIV_NUM_TIMESLOT(player, tdm_frame_size);\n\n\t \n\tsti_uniperiph_get_tdm_word_pos(player, word_pos);\n\tSET_UNIPERIF_TDM_WORD_POS(player, 1_2, word_pos[WORD_1_2]);\n\tSET_UNIPERIF_TDM_WORD_POS(player, 3_4, word_pos[WORD_3_4]);\n\tSET_UNIPERIF_TDM_WORD_POS(player, 5_6, word_pos[WORD_5_6]);\n\tSET_UNIPERIF_TDM_WORD_POS(player, 7_8, word_pos[WORD_7_8]);\n\n\t \n\tfreq = runtime->rate * tdm_frame_size * 8;\n\tmutex_lock(&player->ctrl_lock);\n\tret = uni_player_clk_set_rate(player, freq);\n\tif (!ret)\n\t\tplayer->mclk = freq;\n\tmutex_unlock(&player->ctrl_lock);\n\n\treturn 0;\n}\n\n \nstatic int  uni_player_ctl_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int uni_player_ctl_iec958_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tstruct snd_aes_iec958 *iec958 = &player->stream_settings.iec958;\n\n\tmutex_lock(&player->ctrl_lock);\n\tucontrol->value.iec958.status[0] = iec958->status[0];\n\tucontrol->value.iec958.status[1] = iec958->status[1];\n\tucontrol->value.iec958.status[2] = iec958->status[2];\n\tucontrol->value.iec958.status[3] = iec958->status[3];\n\tmutex_unlock(&player->ctrl_lock);\n\treturn 0;\n}\n\nstatic int uni_player_ctl_iec958_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tstruct snd_aes_iec958 *iec958 =  &player->stream_settings.iec958;\n\tunsigned long flags;\n\n\tmutex_lock(&player->ctrl_lock);\n\tiec958->status[0] = ucontrol->value.iec958.status[0];\n\tiec958->status[1] = ucontrol->value.iec958.status[1];\n\tiec958->status[2] = ucontrol->value.iec958.status[2];\n\tiec958->status[3] = ucontrol->value.iec958.status[3];\n\n\tspin_lock_irqsave(&player->irq_lock, flags);\n\tif (player->substream && player->substream->runtime)\n\t\tuni_player_set_channel_status(player,\n\t\t\t\t\t      player->substream->runtime);\n\telse\n\t\tuni_player_set_channel_status(player, NULL);\n\n\tspin_unlock_irqrestore(&player->irq_lock, flags);\n\tmutex_unlock(&player->ctrl_lock);\n\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new uni_player_iec958_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t.info = uni_player_ctl_iec958_info,\n\t.get = uni_player_ctl_iec958_get,\n\t.put = uni_player_ctl_iec958_put,\n};\n\n \nstatic int snd_sti_clk_adjustment_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = UNIPERIF_PLAYER_CLK_ADJ_MIN;\n\tuinfo->value.integer.max = UNIPERIF_PLAYER_CLK_ADJ_MAX;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int snd_sti_clk_adjustment_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\n\tmutex_lock(&player->ctrl_lock);\n\tucontrol->value.integer.value[0] = player->clk_adj;\n\tmutex_unlock(&player->ctrl_lock);\n\n\treturn 0;\n}\n\nstatic int snd_sti_clk_adjustment_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tint ret = 0;\n\n\tif ((ucontrol->value.integer.value[0] < UNIPERIF_PLAYER_CLK_ADJ_MIN) ||\n\t    (ucontrol->value.integer.value[0] > UNIPERIF_PLAYER_CLK_ADJ_MAX))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&player->ctrl_lock);\n\tplayer->clk_adj = ucontrol->value.integer.value[0];\n\n\tif (player->mclk)\n\t\tret = uni_player_clk_set_rate(player, player->mclk);\n\tmutex_unlock(&player->ctrl_lock);\n\n\treturn ret;\n}\n\nstatic struct snd_kcontrol_new uni_player_clk_adj_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"PCM Playback Oversampling Freq. Adjustment\",\n\t.info = snd_sti_clk_adjustment_info,\n\t.get = snd_sti_clk_adjustment_get,\n\t.put = snd_sti_clk_adjustment_put,\n};\n\nstatic struct snd_kcontrol_new *snd_sti_pcm_ctl[] = {\n\t&uni_player_clk_adj_ctl,\n};\n\nstatic struct snd_kcontrol_new *snd_sti_iec_ctl[] = {\n\t&uni_player_iec958_ctl,\n\t&uni_player_clk_adj_ctl,\n};\n\nstatic int uni_player_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&player->irq_lock, flags);\n\tplayer->substream = substream;\n\tspin_unlock_irqrestore(&player->irq_lock, flags);\n\n\tplayer->clk_adj = 0;\n\n\tif (!UNIPERIF_TYPE_IS_TDM(player))\n\t\treturn 0;\n\n\t \n\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  sti_uniperiph_fix_tdm_chan,\n\t\t\t\t  player, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  -1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t   sti_uniperiph_fix_tdm_format,\n\t\t\t\t   player, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t   -1);\n}\n\nstatic int uni_player_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tint ret;\n\n\tif (UNIPERIF_TYPE_IS_TDM(player) || (dir == SND_SOC_CLOCK_IN))\n\t\treturn 0;\n\n\tif (clk_id != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&player->ctrl_lock);\n\tret = uni_player_clk_set_rate(player, freq);\n\tif (!ret)\n\t\tplayer->mclk = freq;\n\tmutex_unlock(&player->ctrl_lock);\n\n\treturn ret;\n}\n\nstatic int uni_player_prepare(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint transfer_size, trigger_limit;\n\tint ret;\n\n\t \n\tif (player->state != UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(player->dev, \"%s: invalid player state %d\\n\", __func__,\n\t\t\tplayer->state);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (player->type == SND_ST_UNIPERIF_TYPE_TDM) {\n\t\t \n\t\ttransfer_size =\n\t\t\tsti_uniperiph_get_user_frame_size(runtime) / 4;\n\t} else {\n\t\ttransfer_size = runtime->channels * UNIPERIF_FIFO_FRAMES;\n\t}\n\n\t \n\tif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\n\t\ttrigger_limit = UNIPERIF_FIFO_SIZE - transfer_size;\n\t} else {\n\t\t \n\t\ttrigger_limit = transfer_size;\n\t}\n\n\t \n\tif ((!trigger_limit % 2) || (trigger_limit != 1 && transfer_size % 2) ||\n\t    (trigger_limit > UNIPERIF_CONFIG_DMA_TRIG_LIMIT_MASK(player))) {\n\t\tdev_err(player->dev, \"invalid trigger limit %d\\n\",\n\t\t\ttrigger_limit);\n\t\treturn -EINVAL;\n\t}\n\n\tSET_UNIPERIF_CONFIG_DMA_TRIG_LIMIT(player, trigger_limit);\n\n\t \n\tswitch (player->type) {\n\tcase SND_ST_UNIPERIF_TYPE_HDMI:\n\t\tret = uni_player_prepare_iec958(player, runtime);\n\t\tbreak;\n\tcase SND_ST_UNIPERIF_TYPE_PCM:\n\t\tret = uni_player_prepare_pcm(player, runtime);\n\t\tbreak;\n\tcase SND_ST_UNIPERIF_TYPE_SPDIF:\n\t\tret = uni_player_prepare_iec958(player, runtime);\n\t\tbreak;\n\tcase SND_ST_UNIPERIF_TYPE_TDM:\n\t\tret = uni_player_prepare_tdm(player, runtime);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(player->dev, \"invalid player type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (player->daifmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(player);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_LOW(player);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_HIG(player);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(player);\n\t\tbreak;\n\t}\n\n\tswitch (player->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_I2S_MODE(player);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(player);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_RIGHT(player);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(player);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(player->dev, \"format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tSET_UNIPERIF_I2S_FMT_NO_OF_SAMPLES_TO_READ(player, 0);\n\n\n\treturn sti_uniperiph_reset(player);\n}\n\nstatic int uni_player_start(struct uniperif *player)\n{\n\tint ret;\n\n\t \n\tif (player->state != UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(player->dev, \"%s: invalid player state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_prepare_enable(player->clk);\n\tif (ret) {\n\t\tdev_err(player->dev, \"%s: Failed to enable clock\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tSET_UNIPERIF_ITS_BCLR(player, GET_UNIPERIF_ITS(player));\n\n\t \n\tSET_UNIPERIF_ITM_BSET_DMA_ERROR(player);\n\tSET_UNIPERIF_ITM_BSET_FIFO_ERROR(player);\n\n\t \n\tif (player->underflow_enabled) {\n\t\tSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_DONE(player);\n\t\tSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_FAILED(player);\n\t}\n\n\tret = sti_uniperiph_reset(player);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(player->clk);\n\t\treturn ret;\n\t}\n\n\t \n\tSET_UNIPERIF_CTRL_OPERATION_PCM_DATA(player);\n\n\t \n\tif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\tif (UNIPERIF_TYPE_IS_IEC958(player))\n\t\t\tSET_UNIPERIF_CTRL_SPDIF_FMT_ON(player);\n\n\t \n\tif (player->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\tSET_UNIPERIF_CONFIG_CHL_STS_UPDATE(player);\n\telse\n\t\tSET_UNIPERIF_BIT_CONTROL_CHL_STS_UPDATE(player);\n\n\t \n\tplayer->state = UNIPERIF_STATE_STARTED;\n\n\treturn 0;\n}\n\nstatic int uni_player_stop(struct uniperif *player)\n{\n\tint ret;\n\n\t \n\tif (player->state == UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(player->dev, \"%s: invalid player state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tSET_UNIPERIF_CTRL_OPERATION_OFF(player);\n\n\tret = sti_uniperiph_reset(player);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tSET_UNIPERIF_ITM_BCLR(player, GET_UNIPERIF_ITM(player));\n\n\t \n\tclk_disable_unprepare(player->clk);\n\n\t \n\tplayer->state = UNIPERIF_STATE_STOPPED;\n\n\treturn 0;\n}\n\nint uni_player_resume(struct uniperif *player)\n{\n\tint ret;\n\n\t \n\tif (player->clk_sel) {\n\t\tret = regmap_field_write(player->clk_sel, 1);\n\t\tif (ret) {\n\t\t\tdev_err(player->dev,\n\t\t\t\t\"%s: Failed to select freq synth clock\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\n\tSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\n\tSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\n\tSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uni_player_resume);\n\nstatic int uni_player_trigger(struct snd_pcm_substream *substream,\n\t\t\t      int cmd, struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\treturn uni_player_start(player);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn uni_player_stop(player);\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\treturn uni_player_resume(player);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void uni_player_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *player = priv->dai_data.uni;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&player->irq_lock, flags);\n\tif (player->state != UNIPERIF_STATE_STOPPED)\n\t\t \n\t\tuni_player_stop(player);\n\n\tplayer->substream = NULL;\n\tspin_unlock_irqrestore(&player->irq_lock, flags);\n}\n\nstatic int uni_player_parse_dt_audio_glue(struct platform_device *pdev,\n\t\t\t\t\t  struct uniperif *player)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct regmap *regmap;\n\tstruct reg_field regfield[2] = {\n\t\t \n\t\tREG_FIELD(SYS_CFG_AUDIO_GLUE,\n\t\t\t  8 + player->id,\n\t\t\t  8 + player->id),\n\t\t \n\t\tREG_FIELD(SYS_CFG_AUDIO_GLUE, 0, 1)\n\t};\n\n\tregmap = syscon_regmap_lookup_by_phandle(node, \"st,syscfg\");\n\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(&pdev->dev, \"sti-audio-clk-glue syscf not found\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tplayer->clk_sel = regmap_field_alloc(regmap, regfield[0]);\n\tplayer->valid_sel = regmap_field_alloc(regmap, regfield[1]);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops uni_player_dai_ops = {\n\t\t.startup = uni_player_startup,\n\t\t.shutdown = uni_player_shutdown,\n\t\t.prepare = uni_player_prepare,\n\t\t.trigger = uni_player_trigger,\n\t\t.hw_params = sti_uniperiph_dai_hw_params,\n\t\t.set_fmt = sti_uniperiph_dai_set_fmt,\n\t\t.set_sysclk = uni_player_set_sysclk,\n\t\t.set_tdm_slot = sti_uniperiph_set_tdm_slot\n};\n\nint uni_player_init(struct platform_device *pdev,\n\t\t    struct uniperif *player)\n{\n\tint ret = 0;\n\n\tplayer->dev = &pdev->dev;\n\tplayer->state = UNIPERIF_STATE_STOPPED;\n\tplayer->dai_ops = &uni_player_dai_ops;\n\n\t \n\tret = uni_player_parse_dt_audio_glue(pdev, player);\n\n\tif (ret < 0) {\n\t\tdev_err(player->dev, \"Failed to parse DeviceTree\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (player->ver >= SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\tplayer->underflow_enabled = 1;\n\n\tif (UNIPERIF_TYPE_IS_TDM(player))\n\t\tplayer->hw = &uni_tdm_hw;\n\telse\n\t\tplayer->hw = &uni_player_pcm_hw;\n\n\t \n\tplayer->clk = of_clk_get(pdev->dev.of_node, 0);\n\tif (IS_ERR(player->clk)) {\n\t\tdev_err(player->dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(player->clk);\n\t}\n\n\t \n\tif (player->clk_sel) {\n\t\tret = regmap_field_write(player->clk_sel, 1);\n\t\tif (ret) {\n\t\t\tdev_err(player->dev,\n\t\t\t\t\"%s: Failed to select freq synth clock\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (player->valid_sel &&\n\t    (player->id == UNIPERIF_PLAYER_I2S_OUT)) {\n\t\tret = regmap_field_write(player->valid_sel, player->id);\n\t\tif (ret) {\n\t\t\tdev_err(player->dev,\n\t\t\t\t\"%s: unable to connect to tdm bus\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_request_irq(&pdev->dev, player->irq,\n\t\t\t       uni_player_irq_handler, IRQF_SHARED,\n\t\t\t       dev_name(&pdev->dev), player);\n\tif (ret < 0) {\n\t\tdev_err(player->dev, \"unable to request IRQ %d\\n\", player->irq);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&player->ctrl_lock);\n\tspin_lock_init(&player->irq_lock);\n\n\t \n\tSET_UNIPERIF_CONFIG_BACK_STALL_REQ_DISABLE(player);\n\tSET_UNIPERIF_CTRL_ROUNDING_OFF(player);\n\tSET_UNIPERIF_CTRL_SPDIF_LAT_OFF(player);\n\tSET_UNIPERIF_CONFIG_IDLE_MOD_DISABLE(player);\n\n\tif (UNIPERIF_TYPE_IS_IEC958(player)) {\n\t\t \n\n\t\t \n\t\tplayer->stream_settings.iec958.status[0] = 0x00;\n\t\t \n\t\tplayer->stream_settings.iec958.status[1] =\n\t\t\t\t\tIEC958_AES1_CON_GENERAL;\n\t\t \n\t\tplayer->stream_settings.iec958.status[2] =\n\t\t\t\t\tIEC958_AES2_CON_SOURCE_UNSPEC;\n\t\t \n\t\tplayer->stream_settings.iec958.status[3] =\n\t\t\t\t\tIEC958_AES3_CON_FS_NOTID;\n\t\t \n\t\tplayer->stream_settings.iec958.status[4] =\n\t\t\t\t\tIEC958_AES4_CON_MAX_WORDLEN_24 |\n\t\t\t\t\tIEC958_AES4_CON_WORDLEN_24_20;\n\n\t\tplayer->num_ctrls = ARRAY_SIZE(snd_sti_iec_ctl);\n\t\tplayer->snd_ctrls = snd_sti_iec_ctl[0];\n\t} else {\n\t\tplayer->num_ctrls = ARRAY_SIZE(snd_sti_pcm_ctl);\n\t\tplayer->snd_ctrls = snd_sti_pcm_ctl[0];\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uni_player_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}