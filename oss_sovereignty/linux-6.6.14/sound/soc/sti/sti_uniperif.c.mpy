{
  "module_name": "sti_uniperif.c",
  "hash_id": "b28522d57e3e726dd7bd05dc715c5b22baa259d497efeb6d447350b3b1c11311",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sti/sti_uniperif.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/delay.h>\n\n#include \"uniperif.h\"\n\n \n#define UNIPERIF_MAX_FRAME_SZ 0x20\n#define UNIPERIF_ALLOWED_FRAME_SZ (0x08 | 0x10 | 0x18 | UNIPERIF_MAX_FRAME_SZ)\n\nstruct sti_uniperiph_dev_data {\n\tunsigned int id;  \n\tunsigned int version;  \n\tunsigned int stream;\n\tconst char *dai_names;\n\tenum uniperif_type type;\n};\n\nstatic const struct sti_uniperiph_dev_data sti_uniplayer_hdmi = {\n\t.id = 0,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0,\n\t.stream = SNDRV_PCM_STREAM_PLAYBACK,\n\t.dai_names = \"Uni Player #0 (HDMI)\",\n\t.type = SND_ST_UNIPERIF_TYPE_HDMI\n};\n\nstatic const struct sti_uniperiph_dev_data sti_uniplayer_pcm_out = {\n\t.id = 1,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0,\n\t.stream = SNDRV_PCM_STREAM_PLAYBACK,\n\t.dai_names = \"Uni Player #1 (PCM OUT)\",\n\t.type = SND_ST_UNIPERIF_TYPE_PCM | SND_ST_UNIPERIF_TYPE_TDM,\n};\n\nstatic const struct sti_uniperiph_dev_data sti_uniplayer_dac = {\n\t.id = 2,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0,\n\t.stream = SNDRV_PCM_STREAM_PLAYBACK,\n\t.dai_names = \"Uni Player #2 (DAC)\",\n\t.type = SND_ST_UNIPERIF_TYPE_PCM,\n};\n\nstatic const struct sti_uniperiph_dev_data sti_uniplayer_spdif = {\n\t.id = 3,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0,\n\t.stream = SNDRV_PCM_STREAM_PLAYBACK,\n\t.dai_names = \"Uni Player #3 (SPDIF)\",\n\t.type = SND_ST_UNIPERIF_TYPE_SPDIF\n};\n\nstatic const struct sti_uniperiph_dev_data sti_unireader_pcm_in = {\n\t.id = 0,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_RDR_1_0,\n\t.stream = SNDRV_PCM_STREAM_CAPTURE,\n\t.dai_names = \"Uni Reader #0 (PCM IN)\",\n\t.type = SND_ST_UNIPERIF_TYPE_PCM | SND_ST_UNIPERIF_TYPE_TDM,\n};\n\nstatic const struct sti_uniperiph_dev_data sti_unireader_hdmi_in = {\n\t.id = 1,\n\t.version = SND_ST_UNIPERIF_VERSION_UNI_RDR_1_0,\n\t.stream = SNDRV_PCM_STREAM_CAPTURE,\n\t.dai_names = \"Uni Reader #1 (HDMI IN)\",\n\t.type = SND_ST_UNIPERIF_TYPE_PCM,\n};\n\nstatic const struct of_device_id snd_soc_sti_match[] = {\n\t{ .compatible = \"st,stih407-uni-player-hdmi\",\n\t  .data = &sti_uniplayer_hdmi\n\t},\n\t{ .compatible = \"st,stih407-uni-player-pcm-out\",\n\t  .data = &sti_uniplayer_pcm_out\n\t},\n\t{ .compatible = \"st,stih407-uni-player-dac\",\n\t  .data = &sti_uniplayer_dac\n\t},\n\t{ .compatible = \"st,stih407-uni-player-spdif\",\n\t  .data = &sti_uniplayer_spdif\n\t},\n\t{ .compatible = \"st,stih407-uni-reader-pcm_in\",\n\t  .data = &sti_unireader_pcm_in\n\t},\n\t{ .compatible = \"st,stih407-uni-reader-hdmi\",\n\t  .data = &sti_unireader_hdmi_in\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, snd_soc_sti_match);\n\nint  sti_uniperiph_reset(struct uniperif *uni)\n{\n\tint count = 10;\n\n\t \n\tSET_UNIPERIF_SOFT_RST_SOFT_RST(uni);\n\n\tif (uni->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0) {\n\t\twhile (GET_UNIPERIF_SOFT_RST_SOFT_RST(uni) && count) {\n\t\t\tudelay(5);\n\t\t\tcount--;\n\t\t}\n\t}\n\n\tif (!count) {\n\t\tdev_err(uni->dev, \"Failed to reset uniperif\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint sti_uniperiph_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots,\n\t\t\t       int slot_width)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *uni = priv->dai_data.uni;\n\tint i, frame_size, avail_slots;\n\n\tif (!UNIPERIF_TYPE_IS_TDM(uni)) {\n\t\tdev_err(uni->dev, \"cpu dai not in tdm mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tuni->tdm_slot.slots = slots;\n\tuni->tdm_slot.slot_width = slot_width;\n\t \n\tuni->tdm_slot.mask = (tx_mask != 0) ? tx_mask : rx_mask;\n\n\t \n\tfor (i = 0, avail_slots = 0; i < uni->tdm_slot.slots; i++) {\n\t\tif ((uni->tdm_slot.mask >> i) & 0x01)\n\t\t\tavail_slots++;\n\t}\n\tuni->tdm_slot.avail_slots = avail_slots;\n\n\t \n\tframe_size = uni->tdm_slot.avail_slots * uni->tdm_slot.slot_width / 8;\n\n\t \n\tif ((frame_size > UNIPERIF_MAX_FRAME_SZ) ||\n\t    (frame_size & ~(int)UNIPERIF_ALLOWED_FRAME_SZ)) {\n\t\tdev_err(uni->dev, \"frame size not allowed: %d bytes\\n\",\n\t\t\tframe_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint sti_uniperiph_fix_tdm_chan(struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct uniperif *uni = rule->private;\n\tstruct snd_interval t;\n\n\tt.min = uni->tdm_slot.avail_slots;\n\tt.max = uni->tdm_slot.avail_slots;\n\tt.openmin = 0;\n\tt.openmax = 0;\n\tt.integer = 0;\n\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), &t);\n}\n\nint sti_uniperiph_fix_tdm_format(struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_pcm_hw_rule *rule)\n{\n\tstruct uniperif *uni = rule->private;\n\tstruct snd_mask *maskp = hw_param_mask(params, rule->var);\n\tu64 format;\n\n\tswitch (uni->tdm_slot.slot_width) {\n\tcase 16:\n\t\tformat = SNDRV_PCM_FMTBIT_S16_LE;\n\t\tbreak;\n\tcase 32:\n\t\tformat = SNDRV_PCM_FMTBIT_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(uni->dev, \"format not supported: %d bits\\n\",\n\t\t\tuni->tdm_slot.slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tmaskp->bits[0] &= (u_int32_t)format;\n\tmaskp->bits[1] &= (u_int32_t)(format >> 32);\n\t \n\tmemset(maskp->bits + 2, 0, (SNDRV_MASK_MAX - 64) / 8);\n\n\tif (!maskp->bits[0] && !maskp->bits[1])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint sti_uniperiph_get_tdm_word_pos(struct uniperif *uni,\n\t\t\t\t   unsigned int *word_pos)\n{\n\tint slot_width = uni->tdm_slot.slot_width / 8;\n\tint slots_num = uni->tdm_slot.slots;\n\tunsigned int slots_mask = uni->tdm_slot.mask;\n\tint i, j, k;\n\tunsigned int word16_pos[4];\n\n\t \n\n\t \n\tfor (i = 0, j = 0, k = 0; (i < slots_num) && (k < WORD_MAX); i++) {\n\t\tif ((slots_mask >> i) & 0x01) {\n\t\t\tword16_pos[j] = i * slot_width;\n\n\t\t\tif (slot_width == 4) {\n\t\t\t\tword16_pos[j + 1] = word16_pos[j] + 2;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tj++;\n\n\t\t\tif (j > 3) {\n\t\t\t\tword_pos[k] = word16_pos[1] |\n\t\t\t\t\t      (word16_pos[0] << 8) |\n\t\t\t\t\t      (word16_pos[3] << 16) |\n\t\t\t\t\t      (word16_pos[2] << 24);\n\t\t\t\tj = 0;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sti_uniperiph_dai_create_ctrl(struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *uni = priv->dai_data.uni;\n\tstruct snd_kcontrol_new *ctrl;\n\tint i;\n\n\tif (!uni->num_ctrls)\n\t\treturn 0;\n\n\tfor (i = 0; i < uni->num_ctrls; i++) {\n\t\t \n\t\tctrl = &uni->snd_ctrls[i];\n\t\tctrl->index = uni->id;\n\t\tctrl->device = uni->id;\n\t}\n\n\treturn snd_soc_add_dai_controls(dai, uni->snd_ctrls, uni->num_ctrls);\n}\n\n \nint sti_uniperiph_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *uni = priv->dai_data.uni;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tint transfer_size;\n\n\tif (uni->type == SND_ST_UNIPERIF_TYPE_TDM)\n\t\t \n\t\ttransfer_size = snd_soc_params_to_frame_size(params) / 32;\n\telse\n\t\ttransfer_size = params_channels(params) * UNIPERIF_FIFO_FRAMES;\n\n\tdma_data = snd_soc_dai_get_dma_data(dai, substream);\n\tdma_data->maxburst = transfer_size;\n\n\treturn 0;\n}\n\nint sti_uniperiph_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\n\tpriv->dai_data.uni->daifmt = fmt;\n\n\treturn 0;\n}\n\nstatic int sti_uniperiph_suspend(struct snd_soc_component *component)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct uniperif *uni = priv->dai_data.uni;\n\tint ret;\n\n\t \n\tif (uni->state != UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(uni->dev, \"%s: invalid uni state( %d)\\n\",\n\t\t\t__func__, (int)uni->state);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = pinctrl_pm_select_sleep_state(uni->dev);\n\tif (ret)\n\t\tdev_err(uni->dev, \"%s: failed to select pinctrl state\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nstatic int sti_uniperiph_resume(struct snd_soc_component *component)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct uniperif *uni = priv->dai_data.uni;\n\tint ret;\n\n\tif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = uni_player_resume(uni);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = pinctrl_pm_select_default_state(uni->dev);\n\tif (ret)\n\t\tdev_err(uni->dev, \"%s: failed to select pinctrl state\\n\",\n\t\t\t__func__);\n\n\treturn ret;\n}\n\nstatic int sti_uniperiph_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\n\n\t \n\tif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_soc_dai_init_dma_data(dai, &dai_data->dma_data, NULL);\n\telse\n\t\tsnd_soc_dai_init_dma_data(dai, NULL, &dai_data->dma_data);\n\n\tdai_data->dma_data.addr = dai_data->uni->fifo_phys_address;\n\tdai_data->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\treturn sti_uniperiph_dai_create_ctrl(dai);\n}\n\nstatic const struct snd_soc_dai_ops sti_uniperiph_dai_ops = {\n\t.probe = sti_uniperiph_dai_probe,\n};\n\nstatic const struct snd_soc_dai_driver sti_uniperiph_dai_template = {\n\t.ops = &sti_uniperiph_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver sti_uniperiph_dai_component = {\n\t.name = \"sti_cpu_dai\",\n\t.suspend = sti_uniperiph_suspend,\n\t.resume = sti_uniperiph_resume,\n\t.legacy_dai_naming = 1,\n};\n\nstatic int sti_uniperiph_cpu_dai_of(struct device_node *node,\n\t\t\t\t    struct sti_uniperiph_data *priv)\n{\n\tstruct device *dev = &priv->pdev->dev;\n\tstruct sti_uniperiph_dai *dai_data = &priv->dai_data;\n\tstruct snd_soc_dai_driver *dai = priv->dai;\n\tstruct snd_soc_pcm_stream *stream;\n\tstruct uniperif *uni;\n\tconst struct of_device_id *of_id;\n\tconst struct sti_uniperiph_dev_data *dev_data;\n\tconst char *mode;\n\tint ret;\n\n\t \n\tof_id = of_match_node(snd_soc_sti_match, node);\n\tif (!of_id->data) {\n\t\tdev_err(dev, \"data associated to device is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_data = (struct sti_uniperiph_dev_data *)of_id->data;\n\n\tuni = devm_kzalloc(dev, sizeof(*uni), GFP_KERNEL);\n\tif (!uni)\n\t\treturn -ENOMEM;\n\n\tuni->id = dev_data->id;\n\tuni->ver = dev_data->version;\n\n\t*dai = sti_uniperiph_dai_template;\n\tdai->name = dev_data->dai_names;\n\n\t \n\tuni->base = devm_platform_get_and_ioremap_resource(priv->pdev, 0, &uni->mem_region);\n\tif (IS_ERR(uni->base))\n\t\treturn PTR_ERR(uni->base);\n\n\tuni->fifo_phys_address = uni->mem_region->start +\n\t\t\t\t     UNIPERIF_FIFO_DATA_OFFSET(uni);\n\n\tuni->irq = platform_get_irq(priv->pdev, 0);\n\tif (uni->irq < 0)\n\t\treturn -ENXIO;\n\n\tuni->type = dev_data->type;\n\n\t \n\tif (dev_data->type & SND_ST_UNIPERIF_TYPE_TDM) {\n\t\tif (!of_property_read_string(node, \"st,tdm-mode\", &mode))\n\t\t\tuni->type = SND_ST_UNIPERIF_TYPE_TDM;\n\t\telse\n\t\t\tuni->type = SND_ST_UNIPERIF_TYPE_PCM;\n\t}\n\n\tdai_data->uni = uni;\n\tdai_data->stream = dev_data->stream;\n\n\tif (priv->dai_data.stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = uni_player_init(priv->pdev, uni);\n\t\tstream = &dai->playback;\n\t} else {\n\t\tret = uni_reader_init(priv->pdev, uni);\n\t\tstream = &dai->capture;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdai->ops = uni->dai_ops;\n\n\tstream->stream_name = dai->name;\n\tstream->channels_min = uni->hw->channels_min;\n\tstream->channels_max = uni->hw->channels_max;\n\tstream->rates = uni->hw->rates;\n\tstream->formats = uni->hw->formats;\n\n\treturn 0;\n}\n\nstatic const struct snd_dmaengine_pcm_config dmaengine_pcm_config = {\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\nstatic int sti_uniperiph_probe(struct platform_device *pdev)\n{\n\tstruct sti_uniperiph_data *priv;\n\tstruct device_node *node = pdev->dev.of_node;\n\tint ret;\n\n\t \n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->dai = devm_kzalloc(&pdev->dev, sizeof(*priv->dai), GFP_KERNEL);\n\tif (!priv->dai)\n\t\treturn -ENOMEM;\n\n\tpriv->pdev = pdev;\n\n\tret = sti_uniperiph_cpu_dai_of(node, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &sti_uniperiph_dai_component,\n\t\t\t\t\t      priv->dai, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_snd_dmaengine_pcm_register(&pdev->dev,\n\t\t\t\t\t       &dmaengine_pcm_config, 0);\n}\n\nstatic struct platform_driver sti_uniperiph_driver = {\n\t.driver = {\n\t\t.name = \"sti-uniperiph-dai\",\n\t\t.of_match_table = snd_soc_sti_match,\n\t},\n\t.probe = sti_uniperiph_probe,\n};\nmodule_platform_driver(sti_uniperiph_driver);\n\nMODULE_DESCRIPTION(\"uniperipheral DAI driver\");\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}