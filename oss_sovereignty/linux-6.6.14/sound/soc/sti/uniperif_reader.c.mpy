{
  "module_name": "uniperif_reader.c",
  "hash_id": "ca3424e70be3a01f560f20506f5905b723941713f3f662fbc2a557cf1fbd4129",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/sti/uniperif_reader.c",
  "human_readable_source": "\n \n\n#include <sound/soc.h>\n\n#include \"uniperif.h\"\n\n#define UNIPERIF_READER_I2S_IN 0  \n \nstatic const struct snd_pcm_hardware uni_reader_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE,\n\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t.rate_min = 8000,\n\t.rate_max = 96000,\n\n\t.channels_min = 2,\n\t.channels_max = 8,\n\n\t.periods_min = 2,\n\t.periods_max = 48,\n\n\t.period_bytes_min = 128,\n\t.period_bytes_max = 64 * PAGE_SIZE,\n\t.buffer_bytes_max = 256 * PAGE_SIZE\n};\n\n \nstatic irqreturn_t uni_reader_irq_handler(int irq, void *dev_id)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct uniperif *reader = dev_id;\n\tunsigned int status;\n\n\tspin_lock(&reader->irq_lock);\n\tif (!reader->substream)\n\t\tgoto irq_spin_unlock;\n\n\tsnd_pcm_stream_lock(reader->substream);\n\tif (reader->state == UNIPERIF_STATE_STOPPED) {\n\t\t \n\t\tdev_warn(reader->dev, \"unexpected IRQ\\n\");\n\t\tgoto stream_unlock;\n\t}\n\n\t \n\tstatus = GET_UNIPERIF_ITS(reader);\n\tSET_UNIPERIF_ITS_BCLR(reader, status);\n\n\t \n\tif (unlikely(status & UNIPERIF_ITS_FIFO_ERROR_MASK(reader))) {\n\t\tdev_err(reader->dev, \"FIFO error detected\\n\");\n\n\t\tsnd_pcm_stop(reader->substream, SNDRV_PCM_STATE_XRUN);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\nstream_unlock:\n\tsnd_pcm_stream_unlock(reader->substream);\nirq_spin_unlock:\n\tspin_unlock(&reader->irq_lock);\n\n\treturn ret;\n}\n\nstatic int uni_reader_prepare_pcm(struct snd_pcm_runtime *runtime,\n\t\t\t\t  struct uniperif *reader)\n{\n\tint slot_width;\n\n\t \n\tif ((reader->daifmt & SND_SOC_DAIFMT_FORMAT_MASK)\n\t\t== SND_SOC_DAIFMT_I2S) {\n\t\tslot_width = 32;\n\t} else {\n\t\tswitch (runtime->format) {\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tslot_width = 16;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tslot_width = 32;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tswitch (slot_width) {\n\tcase 32:\n\t\tSET_UNIPERIF_I2S_FMT_NBIT_32(reader);\n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(reader);\n\t\tbreak;\n\tcase 16:\n\t\tSET_UNIPERIF_I2S_FMT_NBIT_16(reader);\n\t\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_16(reader);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(reader->dev, \"subframe format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_16(reader);\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t \n\t\tSET_UNIPERIF_CONFIG_MEM_FMT_16_0(reader);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(reader->dev, \"format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((runtime->channels % 2) || (runtime->channels < 2) ||\n\t    (runtime->channels > 10)) {\n\t\tdev_err(reader->dev, \"%s: invalid nb of channels\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tSET_UNIPERIF_I2S_FMT_NUM_CH(reader, runtime->channels / 2);\n\tSET_UNIPERIF_I2S_FMT_ORDER_MSB(reader);\n\n\treturn 0;\n}\n\nstatic int uni_reader_prepare_tdm(struct snd_pcm_runtime *runtime,\n\t\t\t\t  struct uniperif *reader)\n{\n\tint frame_size;  \n\t \n\tunsigned int word_pos[4] = {\n\t\t0x04060002, 0x0C0E080A, 0x14161012, 0x1C1E181A};\n\n\tframe_size = sti_uniperiph_get_user_frame_size(runtime);\n\n\t \n\tSET_UNIPERIF_CONFIG_MEM_FMT_16_0(reader);\n\tSET_UNIPERIF_I2S_FMT_DATA_SIZE_32(reader);\n\n\t \n\tSET_UNIPERIF_I2S_FMT_NUM_CH(reader, frame_size / 4 / 2);\n\n\tSET_UNIPERIF_I2S_FMT_ORDER_MSB(reader);\n\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\n\tSET_UNIPERIF_TDM_ENABLE_TDM_ENABLE(reader);\n\n\t \n\tsti_uniperiph_get_tdm_word_pos(reader, word_pos);\n\tSET_UNIPERIF_TDM_WORD_POS(reader, 1_2, word_pos[WORD_1_2]);\n\tSET_UNIPERIF_TDM_WORD_POS(reader, 3_4, word_pos[WORD_3_4]);\n\tSET_UNIPERIF_TDM_WORD_POS(reader, 5_6, word_pos[WORD_5_6]);\n\tSET_UNIPERIF_TDM_WORD_POS(reader, 7_8, word_pos[WORD_7_8]);\n\n\treturn 0;\n}\n\nstatic int uni_reader_prepare(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *reader = priv->dai_data.uni;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tint transfer_size, trigger_limit, ret;\n\n\t \n\tif (reader->state != UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(reader->dev, \"%s: invalid reader state %d\\n\", __func__,\n\t\t\treader->state);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (reader->type == SND_ST_UNIPERIF_TYPE_TDM) {\n\t\t \n\t\ttransfer_size =\n\t\t\tsti_uniperiph_get_user_frame_size(runtime) / 4;\n\t} else {\n\t\ttransfer_size = runtime->channels * UNIPERIF_FIFO_FRAMES;\n\t}\n\n\t \n\tif (reader->ver < SND_ST_UNIPERIF_VERSION_UNI_PLR_TOP_1_0)\n\t\ttrigger_limit = UNIPERIF_FIFO_SIZE - transfer_size;\n\telse\n\t\t \n\t\ttrigger_limit = transfer_size;\n\n\t \n\tif ((!trigger_limit % 2) ||\n\t    (trigger_limit != 1 && transfer_size % 2) ||\n\t    (trigger_limit > UNIPERIF_CONFIG_DMA_TRIG_LIMIT_MASK(reader))) {\n\t\tdev_err(reader->dev, \"invalid trigger limit %d\\n\",\n\t\t\ttrigger_limit);\n\t\treturn -EINVAL;\n\t}\n\n\tSET_UNIPERIF_CONFIG_DMA_TRIG_LIMIT(reader, trigger_limit);\n\n\tif (UNIPERIF_TYPE_IS_TDM(reader))\n\t\tret = uni_reader_prepare_tdm(runtime, reader);\n\telse\n\t\tret = uni_reader_prepare_pcm(runtime, reader);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (reader->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_I2S_MODE(reader);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_LEFT(reader);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(reader);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tSET_UNIPERIF_I2S_FMT_ALIGN_RIGHT(reader);\n\t\tSET_UNIPERIF_I2S_FMT_PADDING_SONY_MODE(reader);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(reader->dev, \"format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (reader->daifmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_LOW(reader);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(reader);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_HIG(reader);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_RISING(reader);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_LOW(reader);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(reader);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tSET_UNIPERIF_I2S_FMT_LR_POL_HIG(reader);\n\t\tSET_UNIPERIF_I2S_FMT_SCLK_EDGE_FALLING(reader);\n\t\tbreak;\n\t}\n\n\t \n\tSET_UNIPERIF_ITS_BCLR(reader, GET_UNIPERIF_ITS(reader));\n\n\tSET_UNIPERIF_I2S_FMT_NO_OF_SAMPLES_TO_READ(reader, 0);\n\n\t \n\tSET_UNIPERIF_ITM_BSET_DMA_ERROR(reader);\n\tSET_UNIPERIF_ITM_BSET_FIFO_ERROR(reader);\n\tSET_UNIPERIF_ITM_BSET_MEM_BLK_READ(reader);\n\n\t \n\tif (reader->underflow_enabled) {\n\t\tSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_DONE(reader);\n\t\tSET_UNIPERIF_ITM_BSET_UNDERFLOW_REC_FAILED(reader);\n\t}\n\n\t \n\treturn sti_uniperiph_reset(reader);\n}\n\nstatic int uni_reader_start(struct uniperif *reader)\n{\n\t \n\tif (reader->state != UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(reader->dev, \"%s: invalid reader state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tSET_UNIPERIF_ITS_BCLR_FIFO_ERROR(reader);\n\tSET_UNIPERIF_ITM_BSET_FIFO_ERROR(reader);\n\n\t \n\tSET_UNIPERIF_CTRL_OPERATION_PCM_DATA(reader);\n\n\t \n\treader->state = UNIPERIF_STATE_STARTED;\n\treturn 0;\n}\n\nstatic int uni_reader_stop(struct uniperif *reader)\n{\n\t \n\tif (reader->state == UNIPERIF_STATE_STOPPED) {\n\t\tdev_err(reader->dev, \"%s: invalid reader state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tSET_UNIPERIF_CTRL_OPERATION_OFF(reader);\n\n\t \n\tSET_UNIPERIF_ITM_BCLR(reader, GET_UNIPERIF_ITM(reader));\n\n\t \n\treader->state = UNIPERIF_STATE_STOPPED;\n\n\treturn 0;\n}\n\nstatic int  uni_reader_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd, struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *reader = priv->dai_data.uni;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\treturn  uni_reader_start(reader);\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn  uni_reader_stop(reader);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int uni_reader_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *reader = priv->dai_data.uni;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&reader->irq_lock, flags);\n\treader->substream = substream;\n\tspin_unlock_irqrestore(&reader->irq_lock, flags);\n\n\tif (!UNIPERIF_TYPE_IS_TDM(reader))\n\t\treturn 0;\n\n\t \n\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  sti_uniperiph_fix_tdm_chan,\n\t\t\t\t  reader, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  -1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t   sti_uniperiph_fix_tdm_format,\n\t\t\t\t   reader, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t   -1);\n}\n\nstatic void uni_reader_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct sti_uniperiph_data *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct uniperif *reader = priv->dai_data.uni;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&reader->irq_lock, flags);\n\tif (reader->state != UNIPERIF_STATE_STOPPED) {\n\t\t \n\t\tuni_reader_stop(reader);\n\t}\n\treader->substream = NULL;\n\tspin_unlock_irqrestore(&reader->irq_lock, flags);\n}\n\nstatic const struct snd_soc_dai_ops uni_reader_dai_ops = {\n\t\t.startup = uni_reader_startup,\n\t\t.shutdown = uni_reader_shutdown,\n\t\t.prepare = uni_reader_prepare,\n\t\t.trigger = uni_reader_trigger,\n\t\t.hw_params = sti_uniperiph_dai_hw_params,\n\t\t.set_fmt = sti_uniperiph_dai_set_fmt,\n\t\t.set_tdm_slot = sti_uniperiph_set_tdm_slot\n};\n\nint uni_reader_init(struct platform_device *pdev,\n\t\t    struct uniperif *reader)\n{\n\tint ret = 0;\n\n\treader->dev = &pdev->dev;\n\treader->state = UNIPERIF_STATE_STOPPED;\n\treader->dai_ops = &uni_reader_dai_ops;\n\n\tif (UNIPERIF_TYPE_IS_TDM(reader))\n\t\treader->hw = &uni_tdm_hw;\n\telse\n\t\treader->hw = &uni_reader_pcm_hw;\n\n\tret = devm_request_irq(&pdev->dev, reader->irq,\n\t\t\t       uni_reader_irq_handler, IRQF_SHARED,\n\t\t\t       dev_name(&pdev->dev), reader);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to request IRQ\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tspin_lock_init(&reader->irq_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(uni_reader_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}