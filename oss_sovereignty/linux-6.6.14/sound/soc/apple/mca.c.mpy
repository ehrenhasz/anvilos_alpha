{
  "module_name": "mca.c",
  "hash_id": "3c2b126eafa843ee6326d4ec200f035e7b0bbafc2685c10ed334fb3ed22d07b1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/apple/mca.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_clk.h>\n#include <linux/of_dma.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#define USE_RXB_FOR_CAPTURE\n\n \n#define REG_STATUS\t\t0x0\n#define STATUS_MCLK_EN\t\tBIT(0)\n#define REG_MCLK_CONF\t\t0x4\n#define MCLK_CONF_DIV\t\tGENMASK(11, 8)\n\n#define REG_SYNCGEN_STATUS\t0x100\n#define SYNCGEN_STATUS_EN\tBIT(0)\n#define REG_SYNCGEN_MCLK_SEL\t0x104\n#define SYNCGEN_MCLK_SEL\tGENMASK(3, 0)\n#define REG_SYNCGEN_HI_PERIOD\t0x108\n#define REG_SYNCGEN_LO_PERIOD\t0x10c\n\n#define REG_PORT_ENABLES\t0x600\n#define PORT_ENABLES_CLOCKS\tGENMASK(2, 1)\n#define PORT_ENABLES_TX_DATA\tBIT(3)\n#define REG_PORT_CLOCK_SEL\t0x604\n#define PORT_CLOCK_SEL\t\tGENMASK(11, 8)\n#define REG_PORT_DATA_SEL\t0x608\n#define PORT_DATA_SEL_TXA(cl)\t(1 << ((cl)*2))\n#define PORT_DATA_SEL_TXB(cl)\t(2 << ((cl)*2))\n\n#define REG_INTSTATE\t\t0x700\n#define REG_INTMASK\t\t0x704\n\n \n#define CLUSTER_RXA_OFF\t0x200\n#define CLUSTER_TXA_OFF\t0x300\n#define CLUSTER_RXB_OFF\t0x400\n#define CLUSTER_TXB_OFF\t0x500\n\n#define CLUSTER_TX_OFF\tCLUSTER_TXA_OFF\n\n#ifndef USE_RXB_FOR_CAPTURE\n#define CLUSTER_RX_OFF\tCLUSTER_RXA_OFF\n#else\n#define CLUSTER_RX_OFF\tCLUSTER_RXB_OFF\n#endif\n\n \n#define REG_SERDES_STATUS\t0x00\n#define SERDES_STATUS_EN\tBIT(0)\n#define SERDES_STATUS_RST\tBIT(1)\n#define REG_TX_SERDES_CONF\t0x04\n#define REG_RX_SERDES_CONF\t0x08\n#define SERDES_CONF_NCHANS\tGENMASK(3, 0)\n#define SERDES_CONF_WIDTH_MASK\tGENMASK(8, 4)\n#define SERDES_CONF_WIDTH_16BIT 0x40\n#define SERDES_CONF_WIDTH_20BIT 0x80\n#define SERDES_CONF_WIDTH_24BIT 0xc0\n#define SERDES_CONF_WIDTH_32BIT 0x100\n#define SERDES_CONF_BCLK_POL\t0x400\n#define SERDES_CONF_LSB_FIRST\t0x800\n#define SERDES_CONF_UNK1\tBIT(12)\n#define SERDES_CONF_UNK2\tBIT(13)\n#define SERDES_CONF_UNK3\tBIT(14)\n#define SERDES_CONF_NO_DATA_FEEDBACK\tBIT(15)\n#define SERDES_CONF_SYNC_SEL\tGENMASK(18, 16)\n#define REG_TX_SERDES_BITSTART\t0x08\n#define REG_RX_SERDES_BITSTART\t0x0c\n#define REG_TX_SERDES_SLOTMASK\t0x0c\n#define REG_RX_SERDES_SLOTMASK\t0x10\n#define REG_RX_SERDES_PORT\t0x04\n\n \n#define REG_DMA_ADAPTER_A(cl)\t(0x8000 * (cl))\n#define REG_DMA_ADAPTER_B(cl)\t(0x8000 * (cl) + 0x4000)\n#define DMA_ADAPTER_TX_LSB_PAD\tGENMASK(4, 0)\n#define DMA_ADAPTER_TX_NCHANS\tGENMASK(6, 5)\n#define DMA_ADAPTER_RX_MSB_PAD\tGENMASK(12, 8)\n#define DMA_ADAPTER_RX_NCHANS\tGENMASK(14, 13)\n#define DMA_ADAPTER_NCHANS\tGENMASK(22, 20)\n\n#define SWITCH_STRIDE\t0x8000\n#define CLUSTER_STRIDE\t0x4000\n\n#define MAX_NCLUSTERS\t6\n\n#define APPLE_MCA_FMTBITS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE)\n\nstruct mca_cluster {\n\tint no;\n\t__iomem void *base;\n\tstruct mca_data *host;\n\tstruct device *pd_dev;\n\tstruct clk *clk_parent;\n\tstruct dma_chan *dma_chans[SNDRV_PCM_STREAM_LAST + 1];\n\n\tbool port_started[SNDRV_PCM_STREAM_LAST + 1];\n\tint port_driver;  \n\n\tbool clocks_in_use[SNDRV_PCM_STREAM_LAST + 1];\n\tstruct device_link *pd_link;\n\n\tunsigned int bclk_ratio;\n\n\t \n\tint tdm_slots;\n\tint tdm_slot_width;\n\tunsigned int tdm_tx_mask;\n\tunsigned int tdm_rx_mask;\n};\n\nstruct mca_data {\n\tstruct device *dev;\n\n\t__iomem void *switch_base;\n\n\tstruct device *pd_dev;\n\tstruct reset_control *rstc;\n\tstruct device_link *pd_link;\n\n\t \n\tstruct mutex port_mutex;\n\n\tint nclusters;\n\tstruct mca_cluster clusters[];\n};\n\nstatic void mca_modify(struct mca_cluster *cl, int regoffset, u32 mask, u32 val)\n{\n\t__iomem void *ptr = cl->base + regoffset;\n\tu32 newval;\n\n\tnewval = (val & mask) | (readl_relaxed(ptr) & ~mask);\n\twritel_relaxed(newval, ptr);\n}\n\n \nstatic struct mca_cluster *mca_dai_to_cluster(struct snd_soc_dai *dai)\n{\n\tstruct mca_data *mca = snd_soc_dai_get_drvdata(dai);\n\t \n\tint cluster_no = dai->id % mca->nclusters;\n\n\treturn &mca->clusters[cluster_no];\n}\n\n \nstatic void mca_fe_early_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tbool is_tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint serdes_unit = is_tx ? CLUSTER_TX_OFF : CLUSTER_RX_OFF;\n\tint serdes_conf =\n\t\tserdes_unit + (is_tx ? REG_TX_SERDES_CONF : REG_RX_SERDES_CONF);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tmca_modify(cl, serdes_conf, SERDES_CONF_SYNC_SEL,\n\t\t\t   FIELD_PREP(SERDES_CONF_SYNC_SEL, 0));\n\t\tmca_modify(cl, serdes_conf, SERDES_CONF_SYNC_SEL,\n\t\t\t   FIELD_PREP(SERDES_CONF_SYNC_SEL, 7));\n\t\tmca_modify(cl, serdes_unit + REG_SERDES_STATUS,\n\t\t\t   SERDES_STATUS_EN | SERDES_STATUS_RST,\n\t\t\t   SERDES_STATUS_RST);\n\t\t \n\t\tudelay(2);\n\t\tWARN_ON(readl_relaxed(cl->base + serdes_unit + REG_SERDES_STATUS) &\n\t\t\tSERDES_STATUS_RST);\n\t\tmca_modify(cl, serdes_conf, SERDES_CONF_SYNC_SEL,\n\t\t\t   FIELD_PREP(SERDES_CONF_SYNC_SEL, 0));\n\t\tmca_modify(cl, serdes_conf, SERDES_CONF_SYNC_SEL,\n\t\t\t   FIELD_PREP(SERDES_CONF_SYNC_SEL, cl->no + 1));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mca_fe_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tbool is_tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint serdes_unit = is_tx ? CLUSTER_TX_OFF : CLUSTER_RX_OFF;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tmca_modify(cl, serdes_unit + REG_SERDES_STATUS,\n\t\t\t   SERDES_STATUS_EN | SERDES_STATUS_RST,\n\t\t\t   SERDES_STATUS_EN);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tmca_modify(cl, serdes_unit + REG_SERDES_STATUS,\n\t\t\t   SERDES_STATUS_EN, 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mca_fe_enable_clocks(struct mca_cluster *cl)\n{\n\tstruct mca_data *mca = cl->host;\n\tint ret;\n\n\tret = clk_prepare_enable(cl->clk_parent);\n\tif (ret) {\n\t\tdev_err(mca->dev,\n\t\t\t\"cluster %d: unable to enable clock parent: %d\\n\",\n\t\t\tcl->no, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcl->pd_link = device_link_add(mca->dev, cl->pd_dev,\n\t\t\t\t      DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t      DL_FLAG_RPM_ACTIVE);\n\tif (!cl->pd_link) {\n\t\tdev_err(mca->dev,\n\t\t\t\"cluster %d: unable to prop-up power domain\\n\", cl->no);\n\t\tclk_disable_unprepare(cl->clk_parent);\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(cl->no + 1, cl->base + REG_SYNCGEN_MCLK_SEL);\n\tmca_modify(cl, REG_SYNCGEN_STATUS, SYNCGEN_STATUS_EN,\n\t\t   SYNCGEN_STATUS_EN);\n\tmca_modify(cl, REG_STATUS, STATUS_MCLK_EN, STATUS_MCLK_EN);\n\n\treturn 0;\n}\n\nstatic void mca_fe_disable_clocks(struct mca_cluster *cl)\n{\n\tmca_modify(cl, REG_SYNCGEN_STATUS, SYNCGEN_STATUS_EN, 0);\n\tmca_modify(cl, REG_STATUS, STATUS_MCLK_EN, 0);\n\n\tdevice_link_del(cl->pd_link);\n\tclk_disable_unprepare(cl->clk_parent);\n}\n\nstatic bool mca_fe_clocks_in_use(struct mca_cluster *cl)\n{\n\tstruct mca_data *mca = cl->host;\n\tstruct mca_cluster *be_cl;\n\tint stream, i;\n\n\tmutex_lock(&mca->port_mutex);\n\tfor (i = 0; i < mca->nclusters; i++) {\n\t\tbe_cl = &mca->clusters[i];\n\n\t\tif (be_cl->port_driver != cl->no)\n\t\t\tcontinue;\n\n\t\tfor_each_pcm_streams(stream) {\n\t\t\tif (be_cl->clocks_in_use[stream]) {\n\t\t\t\tmutex_unlock(&mca->port_mutex);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&mca->port_mutex);\n\treturn false;\n}\n\nstatic int mca_be_prepare(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_data *mca = cl->host;\n\tstruct mca_cluster *fe_cl;\n\tint ret;\n\n\tif (cl->port_driver < 0)\n\t\treturn -EINVAL;\n\n\tfe_cl = &mca->clusters[cl->port_driver];\n\n\t \n\tif (!mca_fe_clocks_in_use(fe_cl)) {\n\t\tret = mca_fe_enable_clocks(fe_cl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tcl->clocks_in_use[substream->stream] = true;\n\n\treturn 0;\n}\n\nstatic int mca_be_hw_free(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_data *mca = cl->host;\n\tstruct mca_cluster *fe_cl;\n\n\tif (cl->port_driver < 0)\n\t\treturn -EINVAL;\n\n\t \n\tfe_cl = &mca->clusters[cl->port_driver];\n\tif (!mca_fe_clocks_in_use(fe_cl))\n\t\treturn 0;  \n\n\tcl->clocks_in_use[substream->stream] = false;\n\n\tif (!mca_fe_clocks_in_use(fe_cl))\n\t\tmca_fe_disable_clocks(fe_cl);\n\n\treturn 0;\n}\n\nstatic unsigned int mca_crop_mask(unsigned int mask, int nchans)\n{\n\twhile (hweight32(mask) > nchans)\n\t\tmask &= ~(1 << __fls(mask));\n\n\treturn mask;\n}\n\nstatic int mca_configure_serdes(struct mca_cluster *cl, int serdes_unit,\n\t\t\t\tunsigned int mask, int slots, int nchans,\n\t\t\t\tint slot_width, bool is_tx, int port)\n{\n\t__iomem void *serdes_base = cl->base + serdes_unit;\n\tu32 serdes_conf, serdes_conf_mask;\n\n\tserdes_conf_mask = SERDES_CONF_WIDTH_MASK | SERDES_CONF_NCHANS;\n\tserdes_conf = FIELD_PREP(SERDES_CONF_NCHANS, max(slots, 1) - 1);\n\tswitch (slot_width) {\n\tcase 16:\n\t\tserdes_conf |= SERDES_CONF_WIDTH_16BIT;\n\t\tbreak;\n\tcase 20:\n\t\tserdes_conf |= SERDES_CONF_WIDTH_20BIT;\n\t\tbreak;\n\tcase 24:\n\t\tserdes_conf |= SERDES_CONF_WIDTH_24BIT;\n\t\tbreak;\n\tcase 32:\n\t\tserdes_conf |= SERDES_CONF_WIDTH_32BIT;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tserdes_conf_mask |= SERDES_CONF_SYNC_SEL;\n\tserdes_conf |= FIELD_PREP(SERDES_CONF_SYNC_SEL, cl->no + 1);\n\n\tif (is_tx) {\n\t\tserdes_conf_mask |= SERDES_CONF_UNK1 | SERDES_CONF_UNK2 |\n\t\t\t\t    SERDES_CONF_UNK3;\n\t\tserdes_conf |= SERDES_CONF_UNK1 | SERDES_CONF_UNK2 |\n\t\t\t       SERDES_CONF_UNK3;\n\t} else {\n\t\tserdes_conf_mask |= SERDES_CONF_UNK1 | SERDES_CONF_UNK2 |\n\t\t\t\t    SERDES_CONF_UNK3 |\n\t\t\t\t    SERDES_CONF_NO_DATA_FEEDBACK;\n\t\tserdes_conf |= SERDES_CONF_UNK1 | SERDES_CONF_UNK2 |\n\t\t\t       SERDES_CONF_NO_DATA_FEEDBACK;\n\t}\n\n\tmca_modify(cl,\n\t\t   serdes_unit +\n\t\t\t   (is_tx ? REG_TX_SERDES_CONF : REG_RX_SERDES_CONF),\n\t\t   serdes_conf_mask, serdes_conf);\n\n\tif (is_tx) {\n\t\twritel_relaxed(0xffffffff,\n\t\t\t       serdes_base + REG_TX_SERDES_SLOTMASK);\n\t\twritel_relaxed(~((u32)mca_crop_mask(mask, nchans)),\n\t\t\t       serdes_base + REG_TX_SERDES_SLOTMASK + 0x4);\n\t\twritel_relaxed(0xffffffff,\n\t\t\t       serdes_base + REG_TX_SERDES_SLOTMASK + 0x8);\n\t\twritel_relaxed(~((u32)mask),\n\t\t\t       serdes_base + REG_TX_SERDES_SLOTMASK + 0xc);\n\t} else {\n\t\twritel_relaxed(0xffffffff,\n\t\t\t       serdes_base + REG_RX_SERDES_SLOTMASK);\n\t\twritel_relaxed(~((u32)mca_crop_mask(mask, nchans)),\n\t\t\t       serdes_base + REG_RX_SERDES_SLOTMASK + 0x4);\n\t\twritel_relaxed(1 << port,\n\t\t\t       serdes_base + REG_RX_SERDES_PORT);\n\t}\n\n\treturn 0;\n\nerr:\n\tdev_err(cl->host->dev,\n\t\t\"unsupported SERDES configuration requested (mask=0x%x slots=%d slot_width=%d)\\n\",\n\t\tmask, slots, slot_width);\n\treturn -EINVAL;\n}\n\nstatic int mca_fe_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\n\tcl->tdm_slots = slots;\n\tcl->tdm_slot_width = slot_width;\n\tcl->tdm_tx_mask = tx_mask;\n\tcl->tdm_rx_mask = rx_mask;\n\n\treturn 0;\n}\n\nstatic int mca_fe_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_data *mca = cl->host;\n\tbool fpol_inv = false;\n\tu32 serdes_conf = 0;\n\tu32 bitstart;\n\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) !=\n\t    SND_SOC_DAIFMT_BP_FP)\n\t\tgoto err;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfpol_inv = 0;\n\t\tbitstart = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfpol_inv = 1;\n\t\tbitstart = 0;\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tfpol_inv ^= 1;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tserdes_conf |= SERDES_CONF_BCLK_POL;\n\t\tbreak;\n\t}\n\n\tif (!fpol_inv)\n\t\tgoto err;\n\n\tmca_modify(cl, CLUSTER_TX_OFF + REG_TX_SERDES_CONF,\n\t\t   SERDES_CONF_BCLK_POL, serdes_conf);\n\tmca_modify(cl, CLUSTER_RX_OFF + REG_RX_SERDES_CONF,\n\t\t   SERDES_CONF_BCLK_POL, serdes_conf);\n\twritel_relaxed(bitstart,\n\t\t       cl->base + CLUSTER_TX_OFF + REG_TX_SERDES_BITSTART);\n\twritel_relaxed(bitstart,\n\t\t       cl->base + CLUSTER_RX_OFF + REG_RX_SERDES_BITSTART);\n\n\treturn 0;\n\nerr:\n\tdev_err(mca->dev, \"unsupported DAI format (0x%x) requested\\n\", fmt);\n\treturn -EINVAL;\n}\n\nstatic int mca_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\n\tcl->bclk_ratio = ratio;\n\n\treturn 0;\n}\n\nstatic int mca_fe_get_port(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *fe = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_pcm_runtime *be;\n\tstruct snd_soc_dpcm *dpcm;\n\n\tbe = NULL;\n\tfor_each_dpcm_be(fe, substream->stream, dpcm) {\n\t\tbe = dpcm->be;\n\t\tbreak;\n\t}\n\n\tif (!be)\n\t\treturn -EINVAL;\n\n\treturn mca_dai_to_cluster(asoc_rtd_to_cpu(be, 0))->no;\n}\n\nstatic int mca_fe_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_data *mca = cl->host;\n\tstruct device *dev = mca->dev;\n\tunsigned int samp_rate = params_rate(params);\n\tbool is_tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tbool refine_tdm = false;\n\tunsigned long bclk_ratio;\n\tunsigned int tdm_slots, tdm_slot_width, tdm_mask;\n\tu32 regval, pad;\n\tint ret, port, nchans_ceiled;\n\n\tif (!cl->tdm_slot_width) {\n\t\t \n\t\ttdm_slot_width = params_width(params);\n\t\ttdm_slots = params_channels(params);\n\t\trefine_tdm = true;\n\t} else {\n\t\ttdm_slot_width = cl->tdm_slot_width;\n\t\ttdm_slots = cl->tdm_slots;\n\t\ttdm_mask = is_tx ? cl->tdm_tx_mask : cl->tdm_rx_mask;\n\t}\n\n\tif (cl->bclk_ratio)\n\t\tbclk_ratio = cl->bclk_ratio;\n\telse\n\t\tbclk_ratio = tdm_slot_width * tdm_slots;\n\n\tif (refine_tdm) {\n\t\tint nchannels = params_channels(params);\n\n\t\tif (nchannels > 2) {\n\t\t\tdev_err(dev, \"missing TDM for stream with two or more channels\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((bclk_ratio % nchannels) != 0) {\n\t\t\tdev_err(dev, \"BCLK ratio (%ld) not divisible by no. of channels (%d)\\n\",\n\t\t\t\tbclk_ratio, nchannels);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttdm_slot_width = bclk_ratio / nchannels;\n\n\t\tif (tdm_slot_width > 32 && nchannels == 1)\n\t\t\ttdm_slot_width = 32;\n\n\t\tif (tdm_slot_width < params_width(params)) {\n\t\t\tdev_err(dev, \"TDM slots too narrow (tdm=%d params=%d)\\n\",\n\t\t\t\ttdm_slot_width, params_width(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttdm_mask = (1 << tdm_slots) - 1;\n\t}\n\n\tport = mca_fe_get_port(substream);\n\tif (port < 0)\n\t\treturn port;\n\n\tret = mca_configure_serdes(cl, is_tx ? CLUSTER_TX_OFF : CLUSTER_RX_OFF,\n\t\t\t\t   tdm_mask, tdm_slots, params_channels(params),\n\t\t\t\t   tdm_slot_width, is_tx, port);\n\tif (ret)\n\t\treturn ret;\n\n\tpad = 32 - params_width(params);\n\n\t \n\tnchans_ceiled = min_t(int, params_channels(params), 4);\n\tregval = FIELD_PREP(DMA_ADAPTER_NCHANS, nchans_ceiled) |\n\t\t FIELD_PREP(DMA_ADAPTER_TX_NCHANS, 0x2) |\n\t\t FIELD_PREP(DMA_ADAPTER_RX_NCHANS, 0x2) |\n\t\t FIELD_PREP(DMA_ADAPTER_TX_LSB_PAD, pad) |\n\t\t FIELD_PREP(DMA_ADAPTER_RX_MSB_PAD, pad);\n\n#ifndef USE_RXB_FOR_CAPTURE\n\twritel_relaxed(regval, mca->switch_base + REG_DMA_ADAPTER_A(cl->no));\n#else\n\tif (is_tx)\n\t\twritel_relaxed(regval,\n\t\t\t       mca->switch_base + REG_DMA_ADAPTER_A(cl->no));\n\telse\n\t\twritel_relaxed(regval,\n\t\t\t       mca->switch_base + REG_DMA_ADAPTER_B(cl->no));\n#endif\n\n\tif (!mca_fe_clocks_in_use(cl)) {\n\t\t \n\t\twritel_relaxed((bclk_ratio / 2) - 1,\n\t\t\t       cl->base + REG_SYNCGEN_HI_PERIOD);\n\t\twritel_relaxed(((bclk_ratio + 1) / 2) - 1,\n\t\t\t       cl->base + REG_SYNCGEN_LO_PERIOD);\n\t\twritel_relaxed(FIELD_PREP(MCLK_CONF_DIV, 0x1),\n\t\t\t       cl->base + REG_MCLK_CONF);\n\n\t\tret = clk_set_rate(cl->clk_parent, bclk_ratio * samp_rate);\n\t\tif (ret) {\n\t\t\tdev_err(mca->dev, \"cluster %d: unable to set clock parent: %d\\n\",\n\t\t\t\tcl->no, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mca_fe_ops = {\n\t.set_fmt = mca_fe_set_fmt,\n\t.set_bclk_ratio = mca_set_bclk_ratio,\n\t.set_tdm_slot = mca_fe_set_tdm_slot,\n\t.hw_params = mca_fe_hw_params,\n\t.trigger = mca_fe_trigger,\n};\n\nstatic bool mca_be_started(struct mca_cluster *cl)\n{\n\tint stream;\n\n\tfor_each_pcm_streams(stream)\n\t\tif (cl->port_started[stream])\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int mca_be_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *be = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_pcm_runtime *fe;\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_cluster *fe_cl;\n\tstruct mca_data *mca = cl->host;\n\tstruct snd_soc_dpcm *dpcm;\n\n\tfe = NULL;\n\n\tfor_each_dpcm_fe(be, substream->stream, dpcm) {\n\t\tif (fe && dpcm->fe != fe) {\n\t\t\tdev_err(mca->dev, \"many FE per one BE unsupported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfe = dpcm->fe;\n\t}\n\n\tif (!fe)\n\t\treturn -EINVAL;\n\n\tfe_cl = mca_dai_to_cluster(asoc_rtd_to_cpu(fe, 0));\n\n\tif (mca_be_started(cl)) {\n\t\t \n\t\tif (cl->port_driver != fe_cl->no)\n\t\t\treturn -EINVAL;\n\n\t\tcl->port_started[substream->stream] = true;\n\t\treturn 0;\n\t}\n\n\twritel_relaxed(PORT_ENABLES_CLOCKS | PORT_ENABLES_TX_DATA,\n\t\t       cl->base + REG_PORT_ENABLES);\n\twritel_relaxed(FIELD_PREP(PORT_CLOCK_SEL, fe_cl->no + 1),\n\t\t       cl->base + REG_PORT_CLOCK_SEL);\n\twritel_relaxed(PORT_DATA_SEL_TXA(fe_cl->no),\n\t\t       cl->base + REG_PORT_DATA_SEL);\n\tmutex_lock(&mca->port_mutex);\n\tcl->port_driver = fe_cl->no;\n\tmutex_unlock(&mca->port_mutex);\n\tcl->port_started[substream->stream] = true;\n\n\treturn 0;\n}\n\nstatic void mca_be_shutdown(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(dai);\n\tstruct mca_data *mca = cl->host;\n\n\tcl->port_started[substream->stream] = false;\n\n\tif (!mca_be_started(cl)) {\n\t\t \n\t\twritel_relaxed(0, cl->base + REG_PORT_ENABLES);\n\t\twritel_relaxed(0, cl->base + REG_PORT_DATA_SEL);\n\t\tmutex_lock(&mca->port_mutex);\n\t\tcl->port_driver = -1;\n\t\tmutex_unlock(&mca->port_mutex);\n\t}\n}\n\nstatic const struct snd_soc_dai_ops mca_be_ops = {\n\t.prepare = mca_be_prepare,\n\t.hw_free = mca_be_hw_free,\n\t.startup = mca_be_startup,\n\t.shutdown = mca_be_shutdown,\n};\n\nstatic int mca_set_runtime_hwparams(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    struct dma_chan *chan)\n{\n\tstruct device *dma_dev = chan->device->dev;\n\tstruct snd_dmaengine_dai_dma_data dma_data = {};\n\tint ret;\n\n\tstruct snd_pcm_hardware hw;\n\n\tmemset(&hw, 0, sizeof(hw));\n\n\thw.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t  SNDRV_PCM_INFO_INTERLEAVED;\n\thw.periods_min = 2;\n\thw.periods_max = UINT_MAX;\n\thw.period_bytes_min = 256;\n\thw.period_bytes_max = dma_get_max_seg_size(dma_dev);\n\thw.buffer_bytes_max = SIZE_MAX;\n\thw.fifo_size = 16;\n\n\tret = snd_dmaengine_pcm_refine_runtime_hwparams(substream, &dma_data,\n\t\t\t\t\t\t\t&hw, chan);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_soc_set_runtime_hwparams(substream, &hw);\n}\n\nstatic int mca_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct mca_cluster *cl = mca_dai_to_cluster(asoc_rtd_to_cpu(rtd, 0));\n\tstruct dma_chan *chan = cl->dma_chans[substream->stream];\n\tint ret;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tret = mca_set_runtime_hwparams(component, substream, chan);\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_dmaengine_pcm_open(substream, chan);\n}\n\nstatic int mca_hw_params(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);\n\tstruct dma_slave_config slave_config;\n\tint ret;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tmemset(&slave_config, 0, sizeof(slave_config));\n\tret = snd_hwparams_to_dma_slave_config(substream, params,\n\t\t\t\t\t       &slave_config);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tslave_config.dst_port_window_size =\n\t\t\tmin_t(u32, params_channels(params), 4);\n\telse\n\t\tslave_config.src_port_window_size =\n\t\t\tmin_t(u32, params_channels(params), 4);\n\n\treturn dmaengine_slave_config(chan, &slave_config);\n}\n\nstatic int mca_close(struct snd_soc_component *component,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\treturn snd_dmaengine_pcm_close(substream);\n}\n\nstatic int mca_trigger(struct snd_soc_component *component,\n\t\t       struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\t \n\tmca_fe_early_trigger(substream, cmd, asoc_rtd_to_cpu(rtd, 0));\n\n\treturn snd_dmaengine_pcm_trigger(substream, cmd);\n}\n\nstatic snd_pcm_uframes_t mca_pointer(struct snd_soc_component *component,\n\t\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn -ENOTSUPP;\n\n\treturn snd_dmaengine_pcm_pointer(substream);\n}\n\nstatic struct dma_chan *mca_request_dma_channel(struct mca_cluster *cl, unsigned int stream)\n{\n\tbool is_tx = (stream == SNDRV_PCM_STREAM_PLAYBACK);\n#ifndef USE_RXB_FOR_CAPTURE\n\tchar *name = devm_kasprintf(cl->host->dev, GFP_KERNEL,\n\t\t\t\t    is_tx ? \"tx%da\" : \"rx%da\", cl->no);\n#else\n\tchar *name = devm_kasprintf(cl->host->dev, GFP_KERNEL,\n\t\t\t\t    is_tx ? \"tx%da\" : \"rx%db\", cl->no);\n#endif\n\treturn of_dma_request_slave_channel(cl->host->dev->of_node, name);\n\n}\n\nstatic void mca_pcm_free(struct snd_soc_component *component,\n\t\t\t struct snd_pcm *pcm)\n{\n\tstruct snd_soc_pcm_runtime *rtd = snd_pcm_chip(pcm);\n\tstruct mca_cluster *cl = mca_dai_to_cluster(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned int i;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn;\n\n\tfor_each_pcm_streams(i) {\n\t\tstruct snd_pcm_substream *substream =\n\t\t\trtd->pcm->streams[i].substream;\n\n\t\tif (!substream || !cl->dma_chans[i])\n\t\t\tcontinue;\n\n\t\tdma_release_channel(cl->dma_chans[i]);\n\t\tcl->dma_chans[i] = NULL;\n\t}\n}\n\n\nstatic int mca_pcm_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct mca_cluster *cl = mca_dai_to_cluster(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned int i;\n\n\tif (rtd->dai_link->no_pcm)\n\t\treturn 0;\n\n\tfor_each_pcm_streams(i) {\n\t\tstruct snd_pcm_substream *substream =\n\t\t\trtd->pcm->streams[i].substream;\n\t\tstruct dma_chan *chan;\n\n\t\tif (!substream)\n\t\t\tcontinue;\n\n\t\tchan = mca_request_dma_channel(cl, i);\n\n\t\tif (IS_ERR_OR_NULL(chan)) {\n\t\t\tmca_pcm_free(component, rtd->pcm);\n\n\t\t\tif (chan && PTR_ERR(chan) == -EPROBE_DEFER)\n\t\t\t\treturn PTR_ERR(chan);\n\n\t\t\tdev_err(component->dev, \"unable to obtain DMA channel (stream %d cluster %d): %pe\\n\",\n\t\t\t\ti, cl->no, chan);\n\n\t\t\tif (!chan)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn PTR_ERR(chan);\n\t\t}\n\n\t\tcl->dma_chans[i] = chan;\n\t\tsnd_pcm_set_managed_buffer(substream, SNDRV_DMA_TYPE_DEV_IRAM,\n\t\t\t\t\t   chan->device->dev, 512 * 1024 * 6,\n\t\t\t\t\t   SIZE_MAX);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver mca_component = {\n\t.name = \"apple-mca\",\n\t.open = mca_pcm_open,\n\t.close = mca_close,\n\t.hw_params = mca_hw_params,\n\t.trigger = mca_trigger,\n\t.pointer = mca_pointer,\n\t.pcm_construct = mca_pcm_new,\n\t.pcm_destruct = mca_pcm_free,\n};\n\nstatic void apple_mca_release(struct mca_data *mca)\n{\n\tint i;\n\n\tfor (i = 0; i < mca->nclusters; i++) {\n\t\tstruct mca_cluster *cl = &mca->clusters[i];\n\n\t\tif (!IS_ERR_OR_NULL(cl->clk_parent))\n\t\t\tclk_put(cl->clk_parent);\n\n\t\tif (!IS_ERR_OR_NULL(cl->pd_dev))\n\t\t\tdev_pm_domain_detach(cl->pd_dev, true);\n\t}\n\n\tif (mca->pd_link)\n\t\tdevice_link_del(mca->pd_link);\n\n\tif (!IS_ERR_OR_NULL(mca->pd_dev))\n\t\tdev_pm_domain_detach(mca->pd_dev, true);\n\n\treset_control_rearm(mca->rstc);\n}\n\nstatic int apple_mca_probe(struct platform_device *pdev)\n{\n\tstruct mca_data *mca;\n\tstruct mca_cluster *clusters;\n\tstruct snd_soc_dai_driver *dai_drivers;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint nclusters;\n\tint ret, i;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (resource_size(res) < CLUSTER_STRIDE)\n\t\treturn -EINVAL;\n\tnclusters = (resource_size(res) - CLUSTER_STRIDE) / CLUSTER_STRIDE + 1;\n\n\tmca = devm_kzalloc(&pdev->dev, struct_size(mca, clusters, nclusters),\n\t\t\t   GFP_KERNEL);\n\tif (!mca)\n\t\treturn -ENOMEM;\n\tmca->dev = &pdev->dev;\n\tmca->nclusters = nclusters;\n\tmutex_init(&mca->port_mutex);\n\tplatform_set_drvdata(pdev, mca);\n\tclusters = mca->clusters;\n\n\tmca->switch_base =\n\t\tdevm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(mca->switch_base))\n\t\treturn PTR_ERR(mca->switch_base);\n\n\tmca->rstc = devm_reset_control_get_optional_shared(&pdev->dev, NULL);\n\tif (IS_ERR(mca->rstc))\n\t\treturn PTR_ERR(mca->rstc);\n\n\tdai_drivers = devm_kzalloc(\n\t\t&pdev->dev, sizeof(*dai_drivers) * 2 * nclusters, GFP_KERNEL);\n\tif (!dai_drivers)\n\t\treturn -ENOMEM;\n\n\tmca->pd_dev = dev_pm_domain_attach_by_id(&pdev->dev, 0);\n\tif (IS_ERR(mca->pd_dev))\n\t\treturn -EINVAL;\n\n\tmca->pd_link = device_link_add(&pdev->dev, mca->pd_dev,\n\t\t\t\t       DL_FLAG_STATELESS | DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t       DL_FLAG_RPM_ACTIVE);\n\tif (!mca->pd_link) {\n\t\tret = -EINVAL;\n\t\t \n\t\tmca->rstc = NULL;\n\t\tgoto err_release;\n\t}\n\n\treset_control_reset(mca->rstc);\n\n\tfor (i = 0; i < nclusters; i++) {\n\t\tstruct mca_cluster *cl = &clusters[i];\n\t\tstruct snd_soc_dai_driver *fe =\n\t\t\t&dai_drivers[mca->nclusters + i];\n\t\tstruct snd_soc_dai_driver *be = &dai_drivers[i];\n\n\t\tcl->host = mca;\n\t\tcl->no = i;\n\t\tcl->base = base + CLUSTER_STRIDE * i;\n\t\tcl->port_driver = -1;\n\t\tcl->clk_parent = of_clk_get(pdev->dev.of_node, i);\n\t\tif (IS_ERR(cl->clk_parent)) {\n\t\t\tdev_err(&pdev->dev, \"unable to obtain clock %d: %ld\\n\",\n\t\t\t\ti, PTR_ERR(cl->clk_parent));\n\t\t\tret = PTR_ERR(cl->clk_parent);\n\t\t\tgoto err_release;\n\t\t}\n\t\tcl->pd_dev = dev_pm_domain_attach_by_id(&pdev->dev, i + 1);\n\t\tif (IS_ERR(cl->pd_dev)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to obtain cluster %d PD: %ld\\n\", i,\n\t\t\t\tPTR_ERR(cl->pd_dev));\n\t\t\tret = PTR_ERR(cl->pd_dev);\n\t\t\tgoto err_release;\n\t\t}\n\n\t\tfe->id = i;\n\t\tfe->name =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"mca-pcm-%d\", i);\n\t\tif (!fe->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release;\n\t\t}\n\t\tfe->ops = &mca_fe_ops;\n\t\tfe->playback.channels_min = 1;\n\t\tfe->playback.channels_max = 32;\n\t\tfe->playback.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tfe->playback.formats = APPLE_MCA_FMTBITS;\n\t\tfe->capture.channels_min = 1;\n\t\tfe->capture.channels_max = 32;\n\t\tfe->capture.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tfe->capture.formats = APPLE_MCA_FMTBITS;\n\t\tfe->symmetric_rate = 1;\n\n\t\tfe->playback.stream_name =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"PCM%d TX\", i);\n\t\tfe->capture.stream_name =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"PCM%d RX\", i);\n\n\t\tif (!fe->playback.stream_name || !fe->capture.stream_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release;\n\t\t}\n\n\t\tbe->id = i + nclusters;\n\t\tbe->name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"mca-i2s-%d\", i);\n\t\tif (!be->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release;\n\t\t}\n\t\tbe->ops = &mca_be_ops;\n\t\tbe->playback.channels_min = 1;\n\t\tbe->playback.channels_max = 32;\n\t\tbe->playback.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tbe->playback.formats = APPLE_MCA_FMTBITS;\n\t\tbe->capture.channels_min = 1;\n\t\tbe->capture.channels_max = 32;\n\t\tbe->capture.rates = SNDRV_PCM_RATE_8000_192000;\n\t\tbe->capture.formats = APPLE_MCA_FMTBITS;\n\n\t\tbe->playback.stream_name =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"I2S%d TX\", i);\n\t\tbe->capture.stream_name =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"I2S%d RX\", i);\n\t\tif (!be->playback.stream_name || !be->capture.stream_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release;\n\t\t}\n\t}\n\n\tret = snd_soc_register_component(&pdev->dev, &mca_component,\n\t\t\t\t\t dai_drivers, nclusters * 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"unable to register ASoC component: %d\\n\",\n\t\t\tret);\n\t\tgoto err_release;\n\t}\n\n\treturn 0;\n\nerr_release:\n\tapple_mca_release(mca);\n\treturn ret;\n}\n\nstatic void apple_mca_remove(struct platform_device *pdev)\n{\n\tstruct mca_data *mca = platform_get_drvdata(pdev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\tapple_mca_release(mca);\n}\n\nstatic const struct of_device_id apple_mca_of_match[] = {\n\t{ .compatible = \"apple,mca\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, apple_mca_of_match);\n\nstatic struct platform_driver apple_mca_driver = {\n\t.driver = {\n\t\t.name = \"apple-mca\",\n\t\t.of_match_table = apple_mca_of_match,\n\t},\n\t.probe = apple_mca_probe,\n\t.remove_new = apple_mca_remove,\n};\nmodule_platform_driver(apple_mca_driver);\n\nMODULE_AUTHOR(\"Martin Povi\u0161er <povik+lin@cutebit.org>\");\nMODULE_DESCRIPTION(\"ASoC Apple MCA driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}