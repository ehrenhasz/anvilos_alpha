{
  "module_name": "stm32_spdifrx.c",
  "hash_id": "d24cd0fe0a78cfff2dc3709dada2ce08bc2f7dbf9df5b83fac01e213bc8dfd45",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/stm/stm32_spdifrx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n \n#define STM32_SPDIFRX_CR\t0x00\n#define STM32_SPDIFRX_IMR\t0x04\n#define STM32_SPDIFRX_SR\t0x08\n#define STM32_SPDIFRX_IFCR\t0x0C\n#define STM32_SPDIFRX_DR\t0x10\n#define STM32_SPDIFRX_CSR\t0x14\n#define STM32_SPDIFRX_DIR\t0x18\n#define STM32_SPDIFRX_VERR\t0x3F4\n#define STM32_SPDIFRX_IDR\t0x3F8\n#define STM32_SPDIFRX_SIDR\t0x3FC\n\n \n#define SPDIFRX_CR_SPDIFEN_SHIFT\t0\n#define SPDIFRX_CR_SPDIFEN_MASK\tGENMASK(1, SPDIFRX_CR_SPDIFEN_SHIFT)\n#define SPDIFRX_CR_SPDIFENSET(x)\t((x) << SPDIFRX_CR_SPDIFEN_SHIFT)\n\n#define SPDIFRX_CR_RXDMAEN\tBIT(2)\n#define SPDIFRX_CR_RXSTEO\tBIT(3)\n\n#define SPDIFRX_CR_DRFMT_SHIFT\t4\n#define SPDIFRX_CR_DRFMT_MASK\tGENMASK(5, SPDIFRX_CR_DRFMT_SHIFT)\n#define SPDIFRX_CR_DRFMTSET(x)\t((x) << SPDIFRX_CR_DRFMT_SHIFT)\n\n#define SPDIFRX_CR_PMSK\t\tBIT(6)\n#define SPDIFRX_CR_VMSK\t\tBIT(7)\n#define SPDIFRX_CR_CUMSK\tBIT(8)\n#define SPDIFRX_CR_PTMSK\tBIT(9)\n#define SPDIFRX_CR_CBDMAEN\tBIT(10)\n#define SPDIFRX_CR_CHSEL_SHIFT\t11\n#define SPDIFRX_CR_CHSEL\tBIT(SPDIFRX_CR_CHSEL_SHIFT)\n\n#define SPDIFRX_CR_NBTR_SHIFT\t12\n#define SPDIFRX_CR_NBTR_MASK\tGENMASK(13, SPDIFRX_CR_NBTR_SHIFT)\n#define SPDIFRX_CR_NBTRSET(x)\t((x) << SPDIFRX_CR_NBTR_SHIFT)\n\n#define SPDIFRX_CR_WFA\t\tBIT(14)\n\n#define SPDIFRX_CR_INSEL_SHIFT\t16\n#define SPDIFRX_CR_INSEL_MASK\tGENMASK(18, PDIFRX_CR_INSEL_SHIFT)\n#define SPDIFRX_CR_INSELSET(x)\t((x) << SPDIFRX_CR_INSEL_SHIFT)\n\n#define SPDIFRX_CR_CKSEN_SHIFT\t20\n#define SPDIFRX_CR_CKSEN\tBIT(20)\n#define SPDIFRX_CR_CKSBKPEN\tBIT(21)\n\n \n#define SPDIFRX_IMR_RXNEI\tBIT(0)\n#define SPDIFRX_IMR_CSRNEIE\tBIT(1)\n#define SPDIFRX_IMR_PERRIE\tBIT(2)\n#define SPDIFRX_IMR_OVRIE\tBIT(3)\n#define SPDIFRX_IMR_SBLKIE\tBIT(4)\n#define SPDIFRX_IMR_SYNCDIE\tBIT(5)\n#define SPDIFRX_IMR_IFEIE\tBIT(6)\n\n#define SPDIFRX_XIMR_MASK\tGENMASK(6, 0)\n\n \n#define SPDIFRX_SR_RXNE\t\tBIT(0)\n#define SPDIFRX_SR_CSRNE\tBIT(1)\n#define SPDIFRX_SR_PERR\t\tBIT(2)\n#define SPDIFRX_SR_OVR\t\tBIT(3)\n#define SPDIFRX_SR_SBD\t\tBIT(4)\n#define SPDIFRX_SR_SYNCD\tBIT(5)\n#define SPDIFRX_SR_FERR\t\tBIT(6)\n#define SPDIFRX_SR_SERR\t\tBIT(7)\n#define SPDIFRX_SR_TERR\t\tBIT(8)\n\n#define SPDIFRX_SR_WIDTH5_SHIFT\t16\n#define SPDIFRX_SR_WIDTH5_MASK\tGENMASK(30, PDIFRX_SR_WIDTH5_SHIFT)\n#define SPDIFRX_SR_WIDTH5SET(x)\t((x) << SPDIFRX_SR_WIDTH5_SHIFT)\n\n \n#define SPDIFRX_IFCR_PERRCF\tBIT(2)\n#define SPDIFRX_IFCR_OVRCF\tBIT(3)\n#define SPDIFRX_IFCR_SBDCF\tBIT(4)\n#define SPDIFRX_IFCR_SYNCDCF\tBIT(5)\n\n#define SPDIFRX_XIFCR_MASK\tGENMASK(5, 2)\n\n \n#define SPDIFRX_DR0_DR_SHIFT\t0\n#define SPDIFRX_DR0_DR_MASK\tGENMASK(23, SPDIFRX_DR0_DR_SHIFT)\n#define SPDIFRX_DR0_DRSET(x)\t((x) << SPDIFRX_DR0_DR_SHIFT)\n\n#define SPDIFRX_DR0_PE\t\tBIT(24)\n\n#define SPDIFRX_DR0_V\t\tBIT(25)\n#define SPDIFRX_DR0_U\t\tBIT(26)\n#define SPDIFRX_DR0_C\t\tBIT(27)\n\n#define SPDIFRX_DR0_PT_SHIFT\t28\n#define SPDIFRX_DR0_PT_MASK\tGENMASK(29, SPDIFRX_DR0_PT_SHIFT)\n#define SPDIFRX_DR0_PTSET(x)\t((x) << SPDIFRX_DR0_PT_SHIFT)\n\n \n#define  SPDIFRX_DR1_PE\t\tBIT(0)\n#define  SPDIFRX_DR1_V\t\tBIT(1)\n#define  SPDIFRX_DR1_U\t\tBIT(2)\n#define  SPDIFRX_DR1_C\t\tBIT(3)\n\n#define  SPDIFRX_DR1_PT_SHIFT\t4\n#define  SPDIFRX_DR1_PT_MASK\tGENMASK(5, SPDIFRX_DR1_PT_SHIFT)\n#define  SPDIFRX_DR1_PTSET(x)\t((x) << SPDIFRX_DR1_PT_SHIFT)\n\n#define SPDIFRX_DR1_DR_SHIFT\t8\n#define SPDIFRX_DR1_DR_MASK\tGENMASK(31, SPDIFRX_DR1_DR_SHIFT)\n#define SPDIFRX_DR1_DRSET(x)\t((x) << SPDIFRX_DR1_DR_SHIFT)\n\n \n#define SPDIFRX_DR1_DRNL1_SHIFT\t0\n#define SPDIFRX_DR1_DRNL1_MASK\tGENMASK(15, SPDIFRX_DR1_DRNL1_SHIFT)\n#define SPDIFRX_DR1_DRNL1SET(x)\t((x) << SPDIFRX_DR1_DRNL1_SHIFT)\n\n#define SPDIFRX_DR1_DRNL2_SHIFT\t16\n#define SPDIFRX_DR1_DRNL2_MASK\tGENMASK(31, SPDIFRX_DR1_DRNL2_SHIFT)\n#define SPDIFRX_DR1_DRNL2SET(x)\t((x) << SPDIFRX_DR1_DRNL2_SHIFT)\n\n \n#define SPDIFRX_CSR_USR_SHIFT\t0\n#define SPDIFRX_CSR_USR_MASK\tGENMASK(15, SPDIFRX_CSR_USR_SHIFT)\n#define SPDIFRX_CSR_USRGET(x)\t(((x) & SPDIFRX_CSR_USR_MASK)\\\n\t\t\t\t>> SPDIFRX_CSR_USR_SHIFT)\n\n#define SPDIFRX_CSR_CS_SHIFT\t16\n#define SPDIFRX_CSR_CS_MASK\tGENMASK(23, SPDIFRX_CSR_CS_SHIFT)\n#define SPDIFRX_CSR_CSGET(x)\t(((x) & SPDIFRX_CSR_CS_MASK)\\\n\t\t\t\t>> SPDIFRX_CSR_CS_SHIFT)\n\n#define SPDIFRX_CSR_SOB\t\tBIT(24)\n\n \n#define SPDIFRX_DIR_THI_SHIFT\t0\n#define SPDIFRX_DIR_THI_MASK\tGENMASK(12, SPDIFRX_DIR_THI_SHIFT)\n#define SPDIFRX_DIR_THI_SET(x)\t((x) << SPDIFRX_DIR_THI_SHIFT)\n\n#define SPDIFRX_DIR_TLO_SHIFT\t16\n#define SPDIFRX_DIR_TLO_MASK\tGENMASK(28, SPDIFRX_DIR_TLO_SHIFT)\n#define SPDIFRX_DIR_TLO_SET(x)\t((x) << SPDIFRX_DIR_TLO_SHIFT)\n\n#define SPDIFRX_SPDIFEN_DISABLE\t0x0\n#define SPDIFRX_SPDIFEN_SYNC\t0x1\n#define SPDIFRX_SPDIFEN_ENABLE\t0x3\n\n \n#define SPDIFRX_VERR_MIN_MASK\tGENMASK(3, 0)\n#define SPDIFRX_VERR_MAJ_MASK\tGENMASK(7, 4)\n\n \n#define SPDIFRX_IDR_ID_MASK\tGENMASK(31, 0)\n\n \n#define SPDIFRX_SIDR_SID_MASK\tGENMASK(31, 0)\n\n#define SPDIFRX_IPIDR_NUMBER\t0x00130041\n\n#define SPDIFRX_IN1\t\t0x1\n#define SPDIFRX_IN2\t\t0x2\n#define SPDIFRX_IN3\t\t0x3\n#define SPDIFRX_IN4\t\t0x4\n#define SPDIFRX_IN5\t\t0x5\n#define SPDIFRX_IN6\t\t0x6\n#define SPDIFRX_IN7\t\t0x7\n#define SPDIFRX_IN8\t\t0x8\n\n#define SPDIFRX_NBTR_NONE\t0x0\n#define SPDIFRX_NBTR_3\t\t0x1\n#define SPDIFRX_NBTR_15\t\t0x2\n#define SPDIFRX_NBTR_63\t\t0x3\n\n#define SPDIFRX_DRFMT_RIGHT\t0x0\n#define SPDIFRX_DRFMT_LEFT\t0x1\n#define SPDIFRX_DRFMT_PACKED\t0x2\n\n \n#define SPDIFRX_CS_BYTES_NB\t24\n#define SPDIFRX_UB_BYTES_NB\t48\n\n \n#define SPDIFRX_CSR_BUF_LENGTH\t(SPDIFRX_CS_BYTES_NB * 4 * 2)\n\n \nstruct stm32_spdifrx_data {\n\tstruct platform_device *pdev;\n\tvoid __iomem *base;\n\tstruct regmap *regmap;\n\tconst struct regmap_config *regmap_conf;\n\tstruct completion cs_completion;\n\tstruct clk *kclk;\n\tstruct snd_dmaengine_dai_dma_data dma_params;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_dma_buffer *dmab;\n\tstruct dma_chan *ctrl_chan;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_slave_config slave_config;\n\tdma_addr_t phys_addr;\n\tspinlock_t lock;   \n\tspinlock_t irq_lock;  \n\tunsigned char cs[SPDIFRX_CS_BYTES_NB];\n\tunsigned char ub[SPDIFRX_UB_BYTES_NB];\n\tint irq;\n\tint refcount;\n};\n\nstatic void stm32_spdifrx_dma_complete(void *data)\n{\n\tstruct stm32_spdifrx_data *spdifrx = (struct stm32_spdifrx_data *)data;\n\tstruct platform_device *pdev = spdifrx->pdev;\n\tu32 *p_start = (u32 *)spdifrx->dmab->area;\n\tu32 *p_end = p_start + (2 * SPDIFRX_CS_BYTES_NB) - 1;\n\tu32 *ptr = p_start;\n\tu16 *ub_ptr = (short *)spdifrx->ub;\n\tint i = 0;\n\n\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t   SPDIFRX_CR_CBDMAEN,\n\t\t\t   (unsigned int)~SPDIFRX_CR_CBDMAEN);\n\n\tif (!spdifrx->dmab->area)\n\t\treturn;\n\n\twhile (ptr <= p_end) {\n\t\tif (*ptr & SPDIFRX_CSR_SOB)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\n\tif (ptr > p_end) {\n\t\tdev_err(&pdev->dev, \"Start of S/PDIF block not found\\n\");\n\t\treturn;\n\t}\n\n\twhile (i < SPDIFRX_CS_BYTES_NB) {\n\t\tspdifrx->cs[i] = (unsigned char)SPDIFRX_CSR_CSGET(*ptr);\n\t\t*ub_ptr++ = SPDIFRX_CSR_USRGET(*ptr++);\n\t\tif (ptr > p_end) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get channel status\\n\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t}\n\n\tcomplete(&spdifrx->cs_completion);\n}\n\nstatic int stm32_spdifrx_dma_ctrl_start(struct stm32_spdifrx_data *spdifrx)\n{\n\tdma_cookie_t cookie;\n\tint err;\n\n\tspdifrx->desc = dmaengine_prep_slave_single(spdifrx->ctrl_chan,\n\t\t\t\t\t\t    spdifrx->dmab->addr,\n\t\t\t\t\t\t    SPDIFRX_CSR_BUF_LENGTH,\n\t\t\t\t\t\t    DMA_DEV_TO_MEM,\n\t\t\t\t\t\t    DMA_CTRL_ACK);\n\tif (!spdifrx->desc)\n\t\treturn -EINVAL;\n\n\tspdifrx->desc->callback = stm32_spdifrx_dma_complete;\n\tspdifrx->desc->callback_param = spdifrx;\n\tcookie = dmaengine_submit(spdifrx->desc);\n\terr = dma_submit_error(cookie);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tdma_async_issue_pending(spdifrx->ctrl_chan);\n\n\treturn 0;\n}\n\nstatic void stm32_spdifrx_dma_ctrl_stop(struct stm32_spdifrx_data *spdifrx)\n{\n\tdmaengine_terminate_async(spdifrx->ctrl_chan);\n}\n\nstatic int stm32_spdifrx_start_sync(struct stm32_spdifrx_data *spdifrx)\n{\n\tint cr, cr_mask, imr, ret;\n\tunsigned long flags;\n\n\t \n\timr = SPDIFRX_IMR_IFEIE | SPDIFRX_IMR_SYNCDIE | SPDIFRX_IMR_PERRIE;\n\tret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR, imr, imr);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&spdifrx->lock, flags);\n\n\tspdifrx->refcount++;\n\n\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_CR, &cr);\n\n\tif (!(cr & SPDIFRX_CR_SPDIFEN_MASK)) {\n\t\t \n\t\tdev_dbg(&spdifrx->pdev->dev, \"start synchronization\\n\");\n\n\t\t \n\t\tcr = SPDIFRX_CR_WFA | SPDIFRX_CR_PMSK | SPDIFRX_CR_VMSK |\n\t\t     SPDIFRX_CR_CUMSK | SPDIFRX_CR_PTMSK | SPDIFRX_CR_RXSTEO;\n\t\tcr_mask = cr;\n\n\t\tcr |= SPDIFRX_CR_NBTRSET(SPDIFRX_NBTR_63);\n\t\tcr_mask |= SPDIFRX_CR_NBTR_MASK;\n\t\tcr |= SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_SYNC);\n\t\tcr_mask |= SPDIFRX_CR_SPDIFEN_MASK;\n\t\tret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t\t cr_mask, cr);\n\t\tif (ret < 0)\n\t\t\tdev_err(&spdifrx->pdev->dev,\n\t\t\t\t\"Failed to start synchronization\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&spdifrx->lock, flags);\n\n\treturn ret;\n}\n\nstatic void stm32_spdifrx_stop(struct stm32_spdifrx_data *spdifrx)\n{\n\tint cr, cr_mask, reg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spdifrx->lock, flags);\n\n\tif (--spdifrx->refcount) {\n\t\tspin_unlock_irqrestore(&spdifrx->lock, flags);\n\t\treturn;\n\t}\n\n\tcr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_DISABLE);\n\tcr_mask = SPDIFRX_CR_SPDIFEN_MASK | SPDIFRX_CR_RXDMAEN;\n\n\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR, cr_mask, cr);\n\n\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR,\n\t\t\t   SPDIFRX_XIMR_MASK, 0);\n\n\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IFCR,\n\t\t\t   SPDIFRX_XIFCR_MASK, SPDIFRX_XIFCR_MASK);\n\n\t \n\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_DR, &reg);\n\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_CSR, &reg);\n\n\tspin_unlock_irqrestore(&spdifrx->lock, flags);\n}\n\nstatic int stm32_spdifrx_dma_ctrl_register(struct device *dev,\n\t\t\t\t\t   struct stm32_spdifrx_data *spdifrx)\n{\n\tint ret;\n\n\tspdifrx->ctrl_chan = dma_request_chan(dev, \"rx-ctrl\");\n\tif (IS_ERR(spdifrx->ctrl_chan))\n\t\treturn dev_err_probe(dev, PTR_ERR(spdifrx->ctrl_chan),\n\t\t\t\t     \"dma_request_slave_channel error\\n\");\n\n\tspdifrx->dmab = devm_kzalloc(dev, sizeof(struct snd_dma_buffer),\n\t\t\t\t     GFP_KERNEL);\n\tif (!spdifrx->dmab)\n\t\treturn -ENOMEM;\n\n\tspdifrx->dmab->dev.type = SNDRV_DMA_TYPE_DEV_IRAM;\n\tspdifrx->dmab->dev.dev = dev;\n\tret = snd_dma_alloc_pages(spdifrx->dmab->dev.type, dev,\n\t\t\t\t  SPDIFRX_CSR_BUF_LENGTH, spdifrx->dmab);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"snd_dma_alloc_pages returned error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspdifrx->slave_config.direction = DMA_DEV_TO_MEM;\n\tspdifrx->slave_config.src_addr = (dma_addr_t)(spdifrx->phys_addr +\n\t\t\t\t\t STM32_SPDIFRX_CSR);\n\tspdifrx->slave_config.dst_addr = spdifrx->dmab->addr;\n\tspdifrx->slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tspdifrx->slave_config.src_maxburst = 1;\n\n\tret = dmaengine_slave_config(spdifrx->ctrl_chan,\n\t\t\t\t     &spdifrx->slave_config);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"dmaengine_slave_config returned error %d\\n\", ret);\n\t\tspdifrx->ctrl_chan = NULL;\n\t}\n\n\treturn ret;\n};\n\nstatic const char * const spdifrx_enum_input[] = {\n\t\"in0\", \"in1\", \"in2\", \"in3\"\n};\n\n \nstatic const char * const spdifrx_enum_cs_channel[] = {\n\t\"A\", \"B\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ctrl_enum_input,\n\t\t\t    STM32_SPDIFRX_CR, SPDIFRX_CR_INSEL_SHIFT,\n\t\t\t    spdifrx_enum_input);\n\nstatic SOC_ENUM_SINGLE_DECL(ctrl_enum_cs_channel,\n\t\t\t    STM32_SPDIFRX_CR, SPDIFRX_CR_CHSEL_SHIFT,\n\t\t\t    spdifrx_enum_cs_channel);\n\nstatic int stm32_spdifrx_info(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int stm32_spdifrx_ub_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int stm32_spdifrx_get_ctrl_data(struct stm32_spdifrx_data *spdifrx)\n{\n\tint ret = 0;\n\n\tmemset(spdifrx->cs, 0, SPDIFRX_CS_BYTES_NB);\n\tmemset(spdifrx->ub, 0, SPDIFRX_UB_BYTES_NB);\n\n\tret = stm32_spdifrx_dma_ctrl_start(spdifrx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(spdifrx->kclk);\n\tif (ret) {\n\t\tdev_err(&spdifrx->pdev->dev, \"Enable kclk failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t SPDIFRX_CR_CBDMAEN, SPDIFRX_CR_CBDMAEN);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tret = stm32_spdifrx_start_sync(spdifrx);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tif (wait_for_completion_interruptible_timeout(&spdifrx->cs_completion,\n\t\t\t\t\t\t      msecs_to_jiffies(100))\n\t\t\t\t\t\t      <= 0) {\n\t\tdev_dbg(&spdifrx->pdev->dev, \"Failed to get control data\\n\");\n\t\tret = -EAGAIN;\n\t}\n\n\tstm32_spdifrx_stop(spdifrx);\n\tstm32_spdifrx_dma_ctrl_stop(spdifrx);\n\nend:\n\tclk_disable_unprepare(spdifrx->kclk);\n\n\treturn ret;\n}\n\nstatic int stm32_spdifrx_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tstm32_spdifrx_get_ctrl_data(spdifrx);\n\n\tucontrol->value.iec958.status[0] = spdifrx->cs[0];\n\tucontrol->value.iec958.status[1] = spdifrx->cs[1];\n\tucontrol->value.iec958.status[2] = spdifrx->cs[2];\n\tucontrol->value.iec958.status[3] = spdifrx->cs[3];\n\tucontrol->value.iec958.status[4] = spdifrx->cs[4];\n\n\treturn 0;\n}\n\nstatic int stm32_spdif_user_bits_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tstm32_spdifrx_get_ctrl_data(spdifrx);\n\n\tucontrol->value.iec958.status[0] = spdifrx->ub[0];\n\tucontrol->value.iec958.status[1] = spdifrx->ub[1];\n\tucontrol->value.iec958.status[2] = spdifrx->ub[2];\n\tucontrol->value.iec958.status[3] = spdifrx->ub[3];\n\tucontrol->value.iec958.status[4] = spdifrx->ub[4];\n\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new stm32_spdifrx_iec_ctrls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = stm32_spdifrx_info,\n\t\t.get = stm32_spdifrx_capture_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 User Bit Capture Default\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = stm32_spdifrx_ub_info,\n\t\t.get = stm32_spdif_user_bits_get,\n\t},\n};\n\nstatic struct snd_kcontrol_new stm32_spdifrx_ctrls[] = {\n\tSOC_ENUM(\"SPDIFRX input\", ctrl_enum_input),\n\tSOC_ENUM(\"SPDIFRX CS channel\", ctrl_enum_cs_channel),\n};\n\nstatic int stm32_spdifrx_dai_register_ctrls(struct snd_soc_dai *cpu_dai)\n{\n\tint ret;\n\n\tret = snd_soc_add_dai_controls(cpu_dai, stm32_spdifrx_iec_ctrls,\n\t\t\t\t       ARRAY_SIZE(stm32_spdifrx_iec_ctrls));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_add_component_controls(cpu_dai->component,\n\t\t\t\t\t      stm32_spdifrx_ctrls,\n\t\t\t\t\t      ARRAY_SIZE(stm32_spdifrx_ctrls));\n}\n\nstatic int stm32_spdifrx_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_spdifrx_data *spdifrx = dev_get_drvdata(cpu_dai->dev);\n\n\tspdifrx->dma_params.addr = (dma_addr_t)(spdifrx->phys_addr +\n\t\t\t\t   STM32_SPDIFRX_DR);\n\tspdifrx->dma_params.maxburst = 1;\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, NULL, &spdifrx->dma_params);\n\n\treturn stm32_spdifrx_dai_register_ctrls(cpu_dai);\n}\n\nstatic bool stm32_spdifrx_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_SPDIFRX_CR:\n\tcase STM32_SPDIFRX_IMR:\n\tcase STM32_SPDIFRX_SR:\n\tcase STM32_SPDIFRX_IFCR:\n\tcase STM32_SPDIFRX_DR:\n\tcase STM32_SPDIFRX_CSR:\n\tcase STM32_SPDIFRX_DIR:\n\tcase STM32_SPDIFRX_VERR:\n\tcase STM32_SPDIFRX_IDR:\n\tcase STM32_SPDIFRX_SIDR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_spdifrx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_SPDIFRX_DR:\n\tcase STM32_SPDIFRX_CSR:\n\tcase STM32_SPDIFRX_SR:\n\tcase STM32_SPDIFRX_DIR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_spdifrx_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_SPDIFRX_CR:\n\tcase STM32_SPDIFRX_IMR:\n\tcase STM32_SPDIFRX_IFCR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config stm32_h7_spdifrx_regmap_conf = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = STM32_SPDIFRX_SIDR,\n\t.readable_reg = stm32_spdifrx_readable_reg,\n\t.volatile_reg = stm32_spdifrx_volatile_reg,\n\t.writeable_reg = stm32_spdifrx_writeable_reg,\n\t.num_reg_defaults_raw = STM32_SPDIFRX_SIDR / sizeof(u32) + 1,\n\t.fast_io = true,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic irqreturn_t stm32_spdifrx_isr(int irq, void *devid)\n{\n\tstruct stm32_spdifrx_data *spdifrx = (struct stm32_spdifrx_data *)devid;\n\tstruct platform_device *pdev = spdifrx->pdev;\n\tunsigned int cr, mask, sr, imr;\n\tunsigned int flags, sync_state;\n\tint err = 0, err_xrun = 0;\n\n\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_SR, &sr);\n\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_IMR, &imr);\n\n\tmask = imr & SPDIFRX_XIMR_MASK;\n\t \n\tif (mask & SPDIFRX_IMR_IFEIE)\n\t\tmask |= (SPDIFRX_IMR_IFEIE << 1) | (SPDIFRX_IMR_IFEIE << 2);\n\n\tflags = sr & mask;\n\tif (!flags) {\n\t\tdev_err(&pdev->dev, \"Unexpected IRQ. rflags=%#x, imr=%#x\\n\",\n\t\t\tsr, imr);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IFCR,\n\t\t\t   SPDIFRX_XIFCR_MASK, flags);\n\n\tif (flags & SPDIFRX_SR_PERR) {\n\t\tdev_dbg(&pdev->dev, \"Parity error\\n\");\n\t\terr_xrun = 1;\n\t}\n\n\tif (flags & SPDIFRX_SR_OVR) {\n\t\tdev_dbg(&pdev->dev, \"Overrun error\\n\");\n\t\terr_xrun = 1;\n\t}\n\n\tif (flags & SPDIFRX_SR_SBD)\n\t\tdev_dbg(&pdev->dev, \"Synchronization block detected\\n\");\n\n\tif (flags & SPDIFRX_SR_SYNCD) {\n\t\tdev_dbg(&pdev->dev, \"Synchronization done\\n\");\n\n\t\t \n\t\tcr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_ENABLE);\n\t\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t   SPDIFRX_CR_SPDIFEN_MASK, cr);\n\t}\n\n\tif (flags & SPDIFRX_SR_FERR) {\n\t\tdev_dbg(&pdev->dev, \"Frame error\\n\");\n\t\terr = 1;\n\t}\n\n\tif (flags & SPDIFRX_SR_SERR) {\n\t\tdev_dbg(&pdev->dev, \"Synchronization error\\n\");\n\t\terr = 1;\n\t}\n\n\tif (flags & SPDIFRX_SR_TERR) {\n\t\tdev_dbg(&pdev->dev, \"Timeout error\\n\");\n\t\terr = 1;\n\t}\n\n\tif (err) {\n\t\tregmap_read(spdifrx->regmap, STM32_SPDIFRX_CR, &cr);\n\t\tsync_state = FIELD_GET(SPDIFRX_CR_SPDIFEN_MASK, cr) &&\n\t\t\t     SPDIFRX_SPDIFEN_SYNC;\n\n\t\t \n\t\tcr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_DISABLE);\n\t\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t   SPDIFRX_CR_SPDIFEN_MASK, cr);\n\n\t\t \n\t\tif (sync_state) {\n\t\t\tcr = SPDIFRX_CR_SPDIFENSET(SPDIFRX_SPDIFEN_SYNC);\n\t\t\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t\t   SPDIFRX_CR_SPDIFEN_MASK, cr);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tspin_lock(&spdifrx->irq_lock);\n\t\tif (spdifrx->substream)\n\t\t\tsnd_pcm_stop(spdifrx->substream,\n\t\t\t\t     SNDRV_PCM_STATE_DISCONNECTED);\n\t\tspin_unlock(&spdifrx->irq_lock);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(&spdifrx->irq_lock);\n\tif (err_xrun && spdifrx->substream)\n\t\tsnd_pcm_stop_xrun(spdifrx->substream);\n\tspin_unlock(&spdifrx->irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stm32_spdifrx_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&spdifrx->irq_lock, flags);\n\tspdifrx->substream = substream;\n\tspin_unlock_irqrestore(&spdifrx->irq_lock, flags);\n\n\tret = clk_prepare_enable(spdifrx->kclk);\n\tif (ret)\n\t\tdev_err(&spdifrx->pdev->dev, \"Enable kclk failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int stm32_spdifrx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\tint data_size = params_width(params);\n\tint fmt;\n\n\tswitch (data_size) {\n\tcase 16:\n\t\tfmt = SPDIFRX_DRFMT_PACKED;\n\t\tbreak;\n\tcase 32:\n\t\tfmt = SPDIFRX_DRFMT_LEFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&spdifrx->pdev->dev, \"Unexpected data format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspdifrx->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tsnd_soc_dai_init_dma_data(cpu_dai, NULL, &spdifrx->dma_params);\n\n\treturn regmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t  SPDIFRX_CR_DRFMT_MASK,\n\t\t\t\t  SPDIFRX_CR_DRFMTSET(fmt));\n}\n\nstatic int stm32_spdifrx_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_IMR,\n\t\t\t\t   SPDIFRX_IMR_OVRIE, SPDIFRX_IMR_OVRIE);\n\n\t\tregmap_update_bits(spdifrx->regmap, STM32_SPDIFRX_CR,\n\t\t\t\t   SPDIFRX_CR_RXDMAEN, SPDIFRX_CR_RXDMAEN);\n\n\t\tret = stm32_spdifrx_start_sync(spdifrx);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tstm32_spdifrx_stop(spdifrx);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32_spdifrx_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_spdifrx_data *spdifrx = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&spdifrx->irq_lock, flags);\n\tspdifrx->substream = NULL;\n\tspin_unlock_irqrestore(&spdifrx->irq_lock, flags);\n\n\tclk_disable_unprepare(spdifrx->kclk);\n}\n\nstatic const struct snd_soc_dai_ops stm32_spdifrx_pcm_dai_ops = {\n\t.probe\t\t= stm32_spdifrx_dai_probe,\n\t.startup\t= stm32_spdifrx_startup,\n\t.hw_params\t= stm32_spdifrx_hw_params,\n\t.trigger\t= stm32_spdifrx_trigger,\n\t.shutdown\t= stm32_spdifrx_shutdown,\n};\n\nstatic struct snd_soc_dai_driver stm32_spdifrx_dai[] = {\n\t{\n\t\t.capture = {\n\t\t\t.stream_name = \"CPU-Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.ops = &stm32_spdifrx_pcm_dai_ops,\n\t}\n};\n\nstatic const struct snd_pcm_hardware stm32_spdifrx_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,\n\t.buffer_bytes_max = 8 * PAGE_SIZE,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = 4 * PAGE_SIZE,\n\t.periods_min = 2,\n\t.periods_max = 8,\n};\n\nstatic const struct snd_soc_component_driver stm32_spdifrx_component = {\n\t.name = \"stm32-spdifrx\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct snd_dmaengine_pcm_config stm32_spdifrx_pcm_config = {\n\t.pcm_hardware = &stm32_spdifrx_pcm_hw,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\nstatic const struct of_device_id stm32_spdifrx_ids[] = {\n\t{\n\t\t.compatible = \"st,stm32h7-spdifrx\",\n\t\t.data = &stm32_h7_spdifrx_regmap_conf\n\t},\n\t{}\n};\n\nstatic int stm32_spdifrx_parse_of(struct platform_device *pdev,\n\t\t\t\t  struct stm32_spdifrx_data *spdifrx)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tstruct resource *res;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tof_id = of_match_device(stm32_spdifrx_ids, &pdev->dev);\n\tif (of_id)\n\t\tspdifrx->regmap_conf =\n\t\t\t(const struct regmap_config *)of_id->data;\n\telse\n\t\treturn -EINVAL;\n\n\tspdifrx->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(spdifrx->base))\n\t\treturn PTR_ERR(spdifrx->base);\n\n\tspdifrx->phys_addr = res->start;\n\n\tspdifrx->kclk = devm_clk_get(&pdev->dev, \"kclk\");\n\tif (IS_ERR(spdifrx->kclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(spdifrx->kclk),\n\t\t\t\t     \"Could not get kclk\\n\");\n\n\tspdifrx->irq = platform_get_irq(pdev, 0);\n\tif (spdifrx->irq < 0)\n\t\treturn spdifrx->irq;\n\n\treturn 0;\n}\n\nstatic void stm32_spdifrx_remove(struct platform_device *pdev)\n{\n\tstruct stm32_spdifrx_data *spdifrx = platform_get_drvdata(pdev);\n\n\tif (spdifrx->ctrl_chan)\n\t\tdma_release_channel(spdifrx->ctrl_chan);\n\n\tif (spdifrx->dmab)\n\t\tsnd_dma_free_pages(spdifrx->dmab);\n\n\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\tsnd_soc_unregister_component(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int stm32_spdifrx_probe(struct platform_device *pdev)\n{\n\tstruct stm32_spdifrx_data *spdifrx;\n\tstruct reset_control *rst;\n\tconst struct snd_dmaengine_pcm_config *pcm_config = NULL;\n\tu32 ver, idr;\n\tint ret;\n\n\tspdifrx = devm_kzalloc(&pdev->dev, sizeof(*spdifrx), GFP_KERNEL);\n\tif (!spdifrx)\n\t\treturn -ENOMEM;\n\n\tspdifrx->pdev = pdev;\n\tinit_completion(&spdifrx->cs_completion);\n\tspin_lock_init(&spdifrx->lock);\n\tspin_lock_init(&spdifrx->irq_lock);\n\n\tplatform_set_drvdata(pdev, spdifrx);\n\n\tret = stm32_spdifrx_parse_of(pdev, spdifrx);\n\tif (ret)\n\t\treturn ret;\n\n\tspdifrx->regmap = devm_regmap_init_mmio_clk(&pdev->dev, \"kclk\",\n\t\t\t\t\t\t    spdifrx->base,\n\t\t\t\t\t\t    spdifrx->regmap_conf);\n\tif (IS_ERR(spdifrx->regmap))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(spdifrx->regmap),\n\t\t\t\t     \"Regmap init error\\n\");\n\n\tret = devm_request_irq(&pdev->dev, spdifrx->irq, stm32_spdifrx_isr, 0,\n\t\t\t       dev_name(&pdev->dev), spdifrx);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ request returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t     \"Reset controller error\\n\");\n\n\treset_control_assert(rst);\n\tudelay(2);\n\treset_control_deassert(rst);\n\n\tpcm_config = &stm32_spdifrx_pcm_config;\n\tret = snd_dmaengine_pcm_register(&pdev->dev, pcm_config, 0);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"PCM DMA register error\\n\");\n\n\tret = snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t &stm32_spdifrx_component,\n\t\t\t\t\t stm32_spdifrx_dai,\n\t\t\t\t\t ARRAY_SIZE(stm32_spdifrx_dai));\n\tif (ret) {\n\t\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tret = stm32_spdifrx_dma_ctrl_register(&pdev->dev, spdifrx);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_IDR, &idr);\n\tif (ret)\n\t\tgoto error;\n\n\tif (idr == SPDIFRX_IPIDR_NUMBER) {\n\t\tret = regmap_read(spdifrx->regmap, STM32_SPDIFRX_VERR, &ver);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tdev_dbg(&pdev->dev, \"SPDIFRX version: %lu.%lu registered\\n\",\n\t\t\tFIELD_GET(SPDIFRX_VERR_MAJ_MASK, ver),\n\t\t\tFIELD_GET(SPDIFRX_VERR_MIN_MASK, ver));\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn ret;\n\nerror:\n\tstm32_spdifrx_remove(pdev);\n\n\treturn ret;\n}\n\nMODULE_DEVICE_TABLE(of, stm32_spdifrx_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_spdifrx_suspend(struct device *dev)\n{\n\tstruct stm32_spdifrx_data *spdifrx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(spdifrx->regmap, true);\n\tregcache_mark_dirty(spdifrx->regmap);\n\n\treturn 0;\n}\n\nstatic int stm32_spdifrx_resume(struct device *dev)\n{\n\tstruct stm32_spdifrx_data *spdifrx = dev_get_drvdata(dev);\n\n\tregcache_cache_only(spdifrx->regmap, false);\n\n\treturn regcache_sync(spdifrx->regmap);\n}\n#endif  \n\nstatic const struct dev_pm_ops stm32_spdifrx_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_spdifrx_suspend, stm32_spdifrx_resume)\n};\n\nstatic struct platform_driver stm32_spdifrx_driver = {\n\t.driver = {\n\t\t.name = \"st,stm32-spdifrx\",\n\t\t.of_match_table = stm32_spdifrx_ids,\n\t\t.pm = &stm32_spdifrx_pm_ops,\n\t},\n\t.probe = stm32_spdifrx_probe,\n\t.remove_new = stm32_spdifrx_remove,\n};\n\nmodule_platform_driver(stm32_spdifrx_driver);\n\nMODULE_DESCRIPTION(\"STM32 Soc spdifrx Interface\");\nMODULE_AUTHOR(\"Olivier Moysan, <olivier.moysan@st.com>\");\nMODULE_ALIAS(\"platform:stm32-spdifrx\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}