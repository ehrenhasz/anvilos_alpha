{
  "module_name": "stm32_sai.c",
  "hash_id": "ddebffda000d58d14c09e982530904dac3f3673b5f0b734c3b5e23c0c84c2c82",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/stm/stm32_sai.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/reset.h>\n\n#include <sound/dmaengine_pcm.h>\n#include <sound/core.h>\n\n#include \"stm32_sai.h\"\n\nstatic const struct stm32_sai_conf stm32_sai_conf_f4 = {\n\t.version = STM_SAI_STM32F4,\n\t.fifo_size = 8,\n\t.has_spdif_pdm = false,\n};\n\n \nstatic const struct stm32_sai_conf stm32_sai_conf_h7 = {\n\t.version = STM_SAI_STM32H7,\n\t.fifo_size = 8,\n\t.has_spdif_pdm = true,\n};\n\nstatic const struct of_device_id stm32_sai_ids[] = {\n\t{ .compatible = \"st,stm32f4-sai\", .data = (void *)&stm32_sai_conf_f4 },\n\t{ .compatible = \"st,stm32h7-sai\", .data = (void *)&stm32_sai_conf_h7 },\n\t{}\n};\n\nstatic int stm32_sai_pclk_disable(struct device *dev)\n{\n\tstruct stm32_sai_data *sai = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(sai->pclk);\n\n\treturn 0;\n}\n\nstatic int stm32_sai_pclk_enable(struct device *dev)\n{\n\tstruct stm32_sai_data *sai = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(sai->pclk);\n\tif (ret) {\n\t\tdev_err(&sai->pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_sai_sync_conf_client(struct stm32_sai_data *sai, int synci)\n{\n\tint ret;\n\n\t \n\tret = stm32_sai_pclk_enable(&sai->pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\twritel_relaxed(FIELD_PREP(SAI_GCR_SYNCIN_MASK, (synci - 1)), sai->base);\n\n\tstm32_sai_pclk_disable(&sai->pdev->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_sai_sync_conf_provider(struct stm32_sai_data *sai, int synco)\n{\n\tu32 prev_synco;\n\tint ret;\n\n\t \n\tret = stm32_sai_pclk_enable(&sai->pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&sai->pdev->dev, \"Set %pOFn%s as synchro provider\\n\",\n\t\tsai->pdev->dev.of_node,\n\t\tsynco == STM_SAI_SYNC_OUT_A ? \"A\" : \"B\");\n\n\tprev_synco = FIELD_GET(SAI_GCR_SYNCOUT_MASK, readl_relaxed(sai->base));\n\tif (prev_synco != STM_SAI_SYNC_OUT_NONE && synco != prev_synco) {\n\t\tdev_err(&sai->pdev->dev, \"%pOFn%s already set as sync provider\\n\",\n\t\t\tsai->pdev->dev.of_node,\n\t\t\tprev_synco == STM_SAI_SYNC_OUT_A ? \"A\" : \"B\");\n\t\tstm32_sai_pclk_disable(&sai->pdev->dev);\n\t\treturn -EINVAL;\n\t}\n\n\twritel_relaxed(FIELD_PREP(SAI_GCR_SYNCOUT_MASK, synco), sai->base);\n\n\tstm32_sai_pclk_disable(&sai->pdev->dev);\n\n\treturn 0;\n}\n\nstatic int stm32_sai_set_sync(struct stm32_sai_data *sai_client,\n\t\t\t      struct device_node *np_provider,\n\t\t\t      int synco, int synci)\n{\n\tstruct platform_device *pdev = of_find_device_by_node(np_provider);\n\tstruct stm32_sai_data *sai_provider;\n\tint ret;\n\n\tif (!pdev) {\n\t\tdev_err(&sai_client->pdev->dev,\n\t\t\t\"Device not found for node %pOFn\\n\", np_provider);\n\t\tof_node_put(np_provider);\n\t\treturn -ENODEV;\n\t}\n\n\tsai_provider = platform_get_drvdata(pdev);\n\tif (!sai_provider) {\n\t\tdev_err(&sai_client->pdev->dev,\n\t\t\t\"SAI sync provider data not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tret = stm32_sai_sync_conf_client(sai_client, synci);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t \n\tret = stm32_sai_sync_conf_provider(sai_provider, synco);\n\nerror:\n\tput_device(&pdev->dev);\n\tof_node_put(np_provider);\n\treturn ret;\n}\n\nstatic int stm32_sai_probe(struct platform_device *pdev)\n{\n\tstruct stm32_sai_data *sai;\n\tstruct reset_control *rst;\n\tconst struct of_device_id *of_id;\n\tu32 val;\n\tint ret;\n\n\tsai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);\n\tif (!sai)\n\t\treturn -ENOMEM;\n\n\tsai->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(sai->base))\n\t\treturn PTR_ERR(sai->base);\n\n\tof_id = of_match_device(stm32_sai_ids, &pdev->dev);\n\tif (of_id)\n\t\tmemcpy(&sai->conf, (const struct stm32_sai_conf *)of_id->data,\n\t\t       sizeof(struct stm32_sai_conf));\n\telse\n\t\treturn -EINVAL;\n\n\tif (!STM_SAI_IS_F4(sai)) {\n\t\tsai->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\t\tif (IS_ERR(sai->pclk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sai->pclk),\n\t\t\t\t\t     \"missing bus clock pclk\\n\");\n\t}\n\n\tsai->clk_x8k = devm_clk_get(&pdev->dev, \"x8k\");\n\tif (IS_ERR(sai->clk_x8k))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sai->clk_x8k),\n\t\t\t\t     \"missing x8k parent clock\\n\");\n\n\tsai->clk_x11k = devm_clk_get(&pdev->dev, \"x11k\");\n\tif (IS_ERR(sai->clk_x11k))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sai->clk_x11k),\n\t\t\t\t     \"missing x11k parent clock\\n\");\n\n\t \n\tsai->irq = platform_get_irq(pdev, 0);\n\tif (sai->irq < 0)\n\t\treturn sai->irq;\n\n\t \n\trst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t     \"Reset controller error\\n\");\n\n\treset_control_assert(rst);\n\tudelay(2);\n\treset_control_deassert(rst);\n\n\t \n\tret = clk_prepare_enable(sai->pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval = FIELD_GET(SAI_IDR_ID_MASK,\n\t\t\treadl_relaxed(sai->base + STM_SAI_IDR));\n\tif (val == SAI_IPIDR_NUMBER) {\n\t\tval = readl_relaxed(sai->base + STM_SAI_HWCFGR);\n\t\tsai->conf.fifo_size = FIELD_GET(SAI_HWCFGR_FIFO_SIZE, val);\n\t\tsai->conf.has_spdif_pdm = !!FIELD_GET(SAI_HWCFGR_SPDIF_PDM,\n\t\t\t\t\t\t      val);\n\n\t\tval = readl_relaxed(sai->base + STM_SAI_VERR);\n\t\tsai->conf.version = val;\n\n\t\tdev_dbg(&pdev->dev, \"SAI version: %lu.%lu registered\\n\",\n\t\t\tFIELD_GET(SAI_VERR_MAJ_MASK, val),\n\t\t\tFIELD_GET(SAI_VERR_MIN_MASK, val));\n\t}\n\tclk_disable_unprepare(sai->pclk);\n\n\tsai->pdev = pdev;\n\tsai->set_sync = &stm32_sai_set_sync;\n\tplatform_set_drvdata(pdev, sai);\n\n\treturn devm_of_platform_populate(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int stm32_sai_suspend(struct device *dev)\n{\n\tstruct stm32_sai_data *sai = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = stm32_sai_pclk_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tsai->gcr = readl_relaxed(sai->base);\n\tstm32_sai_pclk_disable(dev);\n\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int stm32_sai_resume(struct device *dev)\n{\n\tstruct stm32_sai_data *sai = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = stm32_sai_pclk_enable(dev);\n\tif (ret)\n\t\treturn ret;\n\n\twritel_relaxed(sai->gcr, sai->base);\n\tstm32_sai_pclk_disable(dev);\n\n\treturn pinctrl_pm_select_default_state(dev);\n}\n#endif  \n\nstatic const struct dev_pm_ops stm32_sai_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_sai_suspend, stm32_sai_resume)\n};\n\nMODULE_DEVICE_TABLE(of, stm32_sai_ids);\n\nstatic struct platform_driver stm32_sai_driver = {\n\t.driver = {\n\t\t.name = \"st,stm32-sai\",\n\t\t.of_match_table = stm32_sai_ids,\n\t\t.pm = &stm32_sai_pm_ops,\n\t},\n\t.probe = stm32_sai_probe,\n};\n\nmodule_platform_driver(stm32_sai_driver);\n\nMODULE_DESCRIPTION(\"STM32 Soc SAI Interface\");\nMODULE_AUTHOR(\"Olivier Moysan <olivier.moysan@st.com>\");\nMODULE_ALIAS(\"platform:st,stm32-sai\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}