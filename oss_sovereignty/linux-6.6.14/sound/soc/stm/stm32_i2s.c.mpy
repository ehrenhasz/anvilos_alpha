{
  "module_name": "stm32_i2s.c",
  "hash_id": "8823f06c2fd58e856cf5f961ecf32f86551b9f09ac6d9f1a1f98be30e42cda02",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/stm/stm32_i2s.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#define STM32_I2S_CR1_REG\t0x0\n#define STM32_I2S_CFG1_REG\t0x08\n#define STM32_I2S_CFG2_REG\t0x0C\n#define STM32_I2S_IER_REG\t0x10\n#define STM32_I2S_SR_REG\t0x14\n#define STM32_I2S_IFCR_REG\t0x18\n#define STM32_I2S_TXDR_REG\t0X20\n#define STM32_I2S_RXDR_REG\t0x30\n#define STM32_I2S_CGFR_REG\t0X50\n#define STM32_I2S_HWCFGR_REG\t0x3F0\n#define STM32_I2S_VERR_REG\t0x3F4\n#define STM32_I2S_IPIDR_REG\t0x3F8\n#define STM32_I2S_SIDR_REG\t0x3FC\n\n \n#define I2S_CR1_SPE\t\tBIT(0)\n#define I2S_CR1_CSTART\t\tBIT(9)\n#define I2S_CR1_CSUSP\t\tBIT(10)\n#define I2S_CR1_HDDIR\t\tBIT(11)\n#define I2S_CR1_SSI\t\tBIT(12)\n#define I2S_CR1_CRC33_17\tBIT(13)\n#define I2S_CR1_RCRCI\t\tBIT(14)\n#define I2S_CR1_TCRCI\t\tBIT(15)\n\n \n#define I2S_CFG2_IOSWP_SHIFT\t15\n#define I2S_CFG2_IOSWP\t\tBIT(I2S_CFG2_IOSWP_SHIFT)\n#define I2S_CFG2_LSBFRST\tBIT(23)\n#define I2S_CFG2_AFCNTR\t\tBIT(31)\n\n \n#define I2S_CFG1_FTHVL_SHIFT\t5\n#define I2S_CFG1_FTHVL_MASK\tGENMASK(8, I2S_CFG1_FTHVL_SHIFT)\n#define I2S_CFG1_FTHVL_SET(x)\t((x) << I2S_CFG1_FTHVL_SHIFT)\n\n#define I2S_CFG1_TXDMAEN\tBIT(15)\n#define I2S_CFG1_RXDMAEN\tBIT(14)\n\n \n#define I2S_IER_RXPIE\t\tBIT(0)\n#define I2S_IER_TXPIE\t\tBIT(1)\n#define I2S_IER_DPXPIE\t\tBIT(2)\n#define I2S_IER_EOTIE\t\tBIT(3)\n#define I2S_IER_TXTFIE\t\tBIT(4)\n#define I2S_IER_UDRIE\t\tBIT(5)\n#define I2S_IER_OVRIE\t\tBIT(6)\n#define I2S_IER_CRCEIE\t\tBIT(7)\n#define I2S_IER_TIFREIE\t\tBIT(8)\n#define I2S_IER_MODFIE\t\tBIT(9)\n#define I2S_IER_TSERFIE\t\tBIT(10)\n\n \n#define I2S_SR_RXP\t\tBIT(0)\n#define I2S_SR_TXP\t\tBIT(1)\n#define I2S_SR_DPXP\t\tBIT(2)\n#define I2S_SR_EOT\t\tBIT(3)\n#define I2S_SR_TXTF\t\tBIT(4)\n#define I2S_SR_UDR\t\tBIT(5)\n#define I2S_SR_OVR\t\tBIT(6)\n#define I2S_SR_CRCERR\t\tBIT(7)\n#define I2S_SR_TIFRE\t\tBIT(8)\n#define I2S_SR_MODF\t\tBIT(9)\n#define I2S_SR_TSERF\t\tBIT(10)\n#define I2S_SR_SUSP\t\tBIT(11)\n#define I2S_SR_TXC\t\tBIT(12)\n#define I2S_SR_RXPLVL\t\tGENMASK(14, 13)\n#define I2S_SR_RXWNE\t\tBIT(15)\n\n#define I2S_SR_MASK\t\tGENMASK(15, 0)\n\n \n#define I2S_IFCR_EOTC\t\tBIT(3)\n#define I2S_IFCR_TXTFC\t\tBIT(4)\n#define I2S_IFCR_UDRC\t\tBIT(5)\n#define I2S_IFCR_OVRC\t\tBIT(6)\n#define I2S_IFCR_CRCEC\t\tBIT(7)\n#define I2S_IFCR_TIFREC\t\tBIT(8)\n#define I2S_IFCR_MODFC\t\tBIT(9)\n#define I2S_IFCR_TSERFC\t\tBIT(10)\n#define I2S_IFCR_SUSPC\t\tBIT(11)\n\n#define I2S_IFCR_MASK\t\tGENMASK(11, 3)\n\n \n#define I2S_CGFR_I2SMOD\t\tBIT(0)\n\n#define I2S_CGFR_I2SCFG_SHIFT\t1\n#define I2S_CGFR_I2SCFG_MASK\tGENMASK(3, I2S_CGFR_I2SCFG_SHIFT)\n#define I2S_CGFR_I2SCFG_SET(x)\t((x) << I2S_CGFR_I2SCFG_SHIFT)\n\n#define I2S_CGFR_I2SSTD_SHIFT\t4\n#define I2S_CGFR_I2SSTD_MASK\tGENMASK(5, I2S_CGFR_I2SSTD_SHIFT)\n#define I2S_CGFR_I2SSTD_SET(x)\t((x) << I2S_CGFR_I2SSTD_SHIFT)\n\n#define I2S_CGFR_PCMSYNC\tBIT(7)\n\n#define I2S_CGFR_DATLEN_SHIFT\t8\n#define I2S_CGFR_DATLEN_MASK\tGENMASK(9, I2S_CGFR_DATLEN_SHIFT)\n#define I2S_CGFR_DATLEN_SET(x)\t((x) << I2S_CGFR_DATLEN_SHIFT)\n\n#define I2S_CGFR_CHLEN_SHIFT\t10\n#define I2S_CGFR_CHLEN\t\tBIT(I2S_CGFR_CHLEN_SHIFT)\n#define I2S_CGFR_CKPOL\t\tBIT(11)\n#define I2S_CGFR_FIXCH\t\tBIT(12)\n#define I2S_CGFR_WSINV\t\tBIT(13)\n#define I2S_CGFR_DATFMT\t\tBIT(14)\n\n#define I2S_CGFR_I2SDIV_SHIFT\t16\n#define I2S_CGFR_I2SDIV_BIT_H\t23\n#define I2S_CGFR_I2SDIV_MASK\tGENMASK(I2S_CGFR_I2SDIV_BIT_H,\\\n\t\t\t\tI2S_CGFR_I2SDIV_SHIFT)\n#define I2S_CGFR_I2SDIV_SET(x)\t((x) << I2S_CGFR_I2SDIV_SHIFT)\n#define\tI2S_CGFR_I2SDIV_MAX\t((1 << (I2S_CGFR_I2SDIV_BIT_H -\\\n\t\t\t\tI2S_CGFR_I2SDIV_SHIFT)) - 1)\n\n#define I2S_CGFR_ODD_SHIFT\t24\n#define I2S_CGFR_ODD\t\tBIT(I2S_CGFR_ODD_SHIFT)\n#define I2S_CGFR_MCKOE\t\tBIT(25)\n\n \n\n \n#define I2S_HWCFGR_I2S_SUPPORT_MASK\tGENMASK(15, 12)\n\n \n#define I2S_VERR_MIN_MASK\tGENMASK(3, 0)\n#define I2S_VERR_MAJ_MASK\tGENMASK(7, 4)\n\n \n#define I2S_IPIDR_ID_MASK\tGENMASK(31, 0)\n\n \n#define I2S_SIDR_ID_MASK\tGENMASK(31, 0)\n\n#define I2S_IPIDR_NUMBER\t0x00130022\n\nenum i2s_master_mode {\n\tI2S_MS_NOT_SET,\n\tI2S_MS_MASTER,\n\tI2S_MS_SLAVE,\n};\n\nenum i2s_mode {\n\tI2S_I2SMOD_TX_SLAVE,\n\tI2S_I2SMOD_RX_SLAVE,\n\tI2S_I2SMOD_TX_MASTER,\n\tI2S_I2SMOD_RX_MASTER,\n\tI2S_I2SMOD_FD_SLAVE,\n\tI2S_I2SMOD_FD_MASTER,\n};\n\nenum i2s_fifo_th {\n\tI2S_FIFO_TH_NONE,\n\tI2S_FIFO_TH_ONE_QUARTER,\n\tI2S_FIFO_TH_HALF,\n\tI2S_FIFO_TH_THREE_QUARTER,\n\tI2S_FIFO_TH_FULL,\n};\n\nenum i2s_std {\n\tI2S_STD_I2S,\n\tI2S_STD_LEFT_J,\n\tI2S_STD_RIGHT_J,\n\tI2S_STD_DSP,\n};\n\nenum i2s_datlen {\n\tI2S_I2SMOD_DATLEN_16,\n\tI2S_I2SMOD_DATLEN_24,\n\tI2S_I2SMOD_DATLEN_32,\n};\n\n#define STM32_I2S_FIFO_SIZE\t\t16\n\n#define STM32_I2S_IS_MASTER(x)\t\t((x)->ms_flg == I2S_MS_MASTER)\n#define STM32_I2S_IS_SLAVE(x)\t\t((x)->ms_flg == I2S_MS_SLAVE)\n\n#define STM32_I2S_NAME_LEN\t\t32\n#define STM32_I2S_RATE_11K\t\t11025\n\n \nstruct stm32_i2s_data {\n\tconst struct regmap_config *regmap_conf;\n\tstruct regmap *regmap;\n\tstruct platform_device *pdev;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct snd_dmaengine_dai_dma_data dma_data_tx;\n\tstruct snd_dmaengine_dai_dma_data dma_data_rx;\n\tstruct snd_pcm_substream *substream;\n\tstruct clk *i2sclk;\n\tstruct clk *i2smclk;\n\tstruct clk *pclk;\n\tstruct clk *x8kclk;\n\tstruct clk *x11kclk;\n\tvoid __iomem *base;\n\tdma_addr_t phys_addr;\n\tspinlock_t lock_fd;  \n\tspinlock_t irq_lock;  \n\tunsigned int mclk_rate;\n\tunsigned int fmt;\n\tunsigned int divider;\n\tunsigned int div;\n\tbool odd;\n\tint refcount;\n\tint ms_flg;\n};\n\nstruct stm32_i2smclk_data {\n\tstruct clk_hw hw;\n\tunsigned long freq;\n\tstruct stm32_i2s_data *i2s_data;\n};\n\n#define to_mclk_data(_hw) container_of(_hw, struct stm32_i2smclk_data, hw)\n\nstatic int stm32_i2s_calc_clk_div(struct stm32_i2s_data *i2s,\n\t\t\t\t  unsigned long input_rate,\n\t\t\t\t  unsigned long output_rate)\n{\n\tunsigned int ratio, div, divider = 1;\n\tbool odd;\n\n\tratio = DIV_ROUND_CLOSEST(input_rate, output_rate);\n\n\t \n\todd = ratio & 0x1;\n\n\t \n\tdiv = ratio >> 1;\n\n\t \n\tif (div) {\n\t\tdivider = ((2 * div) + odd);\n\t\tdev_dbg(&i2s->pdev->dev, \"Divider: 2*%d(div)+%d(odd) = %d\\n\",\n\t\t\tdiv, odd, divider);\n\t}\n\n\t \n\tif ((div == 1 && odd) || div > I2S_CGFR_I2SDIV_MAX) {\n\t\tdev_err(&i2s->pdev->dev, \"Wrong divider setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (input_rate % divider)\n\t\tdev_dbg(&i2s->pdev->dev,\n\t\t\t\"Rate not accurate. requested (%ld), actual (%ld)\\n\",\n\t\t\toutput_rate, input_rate / divider);\n\n\ti2s->div = div;\n\ti2s->odd = odd;\n\ti2s->divider = divider;\n\n\treturn 0;\n}\n\nstatic int stm32_i2s_set_clk_div(struct stm32_i2s_data *i2s)\n{\n\tu32 cgfr, cgfr_mask;\n\n\tcgfr = I2S_CGFR_I2SDIV_SET(i2s->div) | (i2s->odd << I2S_CGFR_ODD_SHIFT);\n\tcgfr_mask = I2S_CGFR_I2SDIV_MASK | I2S_CGFR_ODD;\n\n\treturn regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t  cgfr_mask, cgfr);\n}\n\nstatic int stm32_i2s_set_parent_clock(struct stm32_i2s_data *i2s,\n\t\t\t\t      unsigned int rate)\n{\n\tstruct platform_device *pdev = i2s->pdev;\n\tstruct clk *parent_clk;\n\tint ret;\n\n\tif (!(rate % STM32_I2S_RATE_11K))\n\t\tparent_clk = i2s->x11kclk;\n\telse\n\t\tparent_clk = i2s->x8kclk;\n\n\tret = clk_set_parent(i2s->i2sclk, parent_clk);\n\tif (ret)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Error %d setting i2sclk parent clock\\n\", ret);\n\n\treturn ret;\n}\n\nstatic long stm32_i2smclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t     unsigned long *prate)\n{\n\tstruct stm32_i2smclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_i2s_data *i2s = mclk->i2s_data;\n\tint ret;\n\n\tret = stm32_i2s_calc_clk_div(i2s, *prate, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tmclk->freq = *prate / i2s->divider;\n\n\treturn mclk->freq;\n}\n\nstatic unsigned long stm32_i2smclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t       unsigned long parent_rate)\n{\n\tstruct stm32_i2smclk_data *mclk = to_mclk_data(hw);\n\n\treturn mclk->freq;\n}\n\nstatic int stm32_i2smclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t  unsigned long parent_rate)\n{\n\tstruct stm32_i2smclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_i2s_data *i2s = mclk->i2s_data;\n\tint ret;\n\n\tret = stm32_i2s_calc_clk_div(i2s, parent_rate, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_i2s_set_clk_div(i2s);\n\tif (ret)\n\t\treturn ret;\n\n\tmclk->freq = rate;\n\n\treturn 0;\n}\n\nstatic int stm32_i2smclk_enable(struct clk_hw *hw)\n{\n\tstruct stm32_i2smclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_i2s_data *i2s = mclk->i2s_data;\n\n\tdev_dbg(&i2s->pdev->dev, \"Enable master clock\\n\");\n\n\treturn regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t    I2S_CGFR_MCKOE, I2S_CGFR_MCKOE);\n}\n\nstatic void stm32_i2smclk_disable(struct clk_hw *hw)\n{\n\tstruct stm32_i2smclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_i2s_data *i2s = mclk->i2s_data;\n\n\tdev_dbg(&i2s->pdev->dev, \"Disable master clock\\n\");\n\n\tregmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG, I2S_CGFR_MCKOE, 0);\n}\n\nstatic const struct clk_ops mclk_ops = {\n\t.enable = stm32_i2smclk_enable,\n\t.disable = stm32_i2smclk_disable,\n\t.recalc_rate = stm32_i2smclk_recalc_rate,\n\t.round_rate = stm32_i2smclk_round_rate,\n\t.set_rate = stm32_i2smclk_set_rate,\n};\n\nstatic int stm32_i2s_add_mclk_provider(struct stm32_i2s_data *i2s)\n{\n\tstruct clk_hw *hw;\n\tstruct stm32_i2smclk_data *mclk;\n\tstruct device *dev = &i2s->pdev->dev;\n\tconst char *pname = __clk_get_name(i2s->i2sclk);\n\tchar *mclk_name, *p, *s = (char *)pname;\n\tint ret, i = 0;\n\n\tmclk = devm_kzalloc(dev, sizeof(*mclk), GFP_KERNEL);\n\tif (!mclk)\n\t\treturn -ENOMEM;\n\n\tmclk_name = devm_kcalloc(dev, sizeof(char),\n\t\t\t\t STM32_I2S_NAME_LEN, GFP_KERNEL);\n\tif (!mclk_name)\n\t\treturn -ENOMEM;\n\n\t \n\tp = mclk_name;\n\twhile (*s && *s != '_' && (i < (STM32_I2S_NAME_LEN - 7))) {\n\t\t*p++ = *s++;\n\t\ti++;\n\t}\n\tstrcat(p, \"_mclk\");\n\n\tmclk->hw.init = CLK_HW_INIT(mclk_name, pname, &mclk_ops, 0);\n\tmclk->i2s_data = i2s;\n\thw = &mclk->hw;\n\n\tdev_dbg(dev, \"Register master clock %s\\n\", mclk_name);\n\tret = devm_clk_hw_register(&i2s->pdev->dev, hw);\n\tif (ret) {\n\t\tdev_err(dev, \"mclk register fails with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\ti2s->i2smclk = hw->clk;\n\n\t \n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, hw);\n}\n\nstatic irqreturn_t stm32_i2s_isr(int irq, void *devid)\n{\n\tstruct stm32_i2s_data *i2s = (struct stm32_i2s_data *)devid;\n\tstruct platform_device *pdev = i2s->pdev;\n\tu32 sr, ier;\n\tunsigned long flags;\n\tint err = 0;\n\n\tregmap_read(i2s->regmap, STM32_I2S_SR_REG, &sr);\n\tregmap_read(i2s->regmap, STM32_I2S_IER_REG, &ier);\n\n\tflags = sr & ier;\n\tif (!flags) {\n\t\tdev_dbg(&pdev->dev, \"Spurious IRQ sr=0x%08x, ier=0x%08x\\n\",\n\t\t\tsr, ier);\n\t\treturn IRQ_NONE;\n\t}\n\n\tregmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,\n\t\t\t  I2S_IFCR_MASK, flags);\n\n\tif (flags & I2S_SR_OVR) {\n\t\tdev_dbg(&pdev->dev, \"Overrun\\n\");\n\t\terr = 1;\n\t}\n\n\tif (flags & I2S_SR_UDR) {\n\t\tdev_dbg(&pdev->dev, \"Underrun\\n\");\n\t\terr = 1;\n\t}\n\n\tif (flags & I2S_SR_TIFRE)\n\t\tdev_dbg(&pdev->dev, \"Frame error\\n\");\n\n\tspin_lock(&i2s->irq_lock);\n\tif (err && i2s->substream)\n\t\tsnd_pcm_stop_xrun(i2s->substream);\n\tspin_unlock(&i2s->irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic bool stm32_i2s_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_I2S_CR1_REG:\n\tcase STM32_I2S_CFG1_REG:\n\tcase STM32_I2S_CFG2_REG:\n\tcase STM32_I2S_IER_REG:\n\tcase STM32_I2S_SR_REG:\n\tcase STM32_I2S_RXDR_REG:\n\tcase STM32_I2S_CGFR_REG:\n\tcase STM32_I2S_HWCFGR_REG:\n\tcase STM32_I2S_VERR_REG:\n\tcase STM32_I2S_IPIDR_REG:\n\tcase STM32_I2S_SIDR_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_i2s_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_I2S_SR_REG:\n\tcase STM32_I2S_RXDR_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_i2s_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM32_I2S_CR1_REG:\n\tcase STM32_I2S_CFG1_REG:\n\tcase STM32_I2S_CFG2_REG:\n\tcase STM32_I2S_IER_REG:\n\tcase STM32_I2S_IFCR_REG:\n\tcase STM32_I2S_TXDR_REG:\n\tcase STM32_I2S_CGFR_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int stm32_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tu32 cgfr;\n\tu32 cgfr_mask =  I2S_CGFR_I2SSTD_MASK | I2S_CGFR_CKPOL |\n\t\t\t I2S_CGFR_WSINV | I2S_CGFR_I2SCFG_MASK;\n\n\tdev_dbg(cpu_dai->dev, \"fmt %x\\n\", fmt);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_I2S);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tcgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_LEFT_J);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tcgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_RIGHT_J);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcgfr = I2S_CGFR_I2SSTD_SET(I2S_STD_DSP);\n\t\tbreak;\n\t \n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported protocol %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tcgfr |= I2S_CGFR_CKPOL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tcgfr |= I2S_CGFR_WSINV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tcgfr |= I2S_CGFR_CKPOL;\n\t\tcgfr |= I2S_CGFR_WSINV;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported strobing %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_INV_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\ti2s->ms_flg = I2S_MS_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\ti2s->ms_flg = I2S_MS_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported mode %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\ti2s->fmt = fmt;\n\treturn regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t  cgfr_mask, cgfr);\n}\n\nstatic int stm32_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret = 0;\n\n\tdev_dbg(cpu_dai->dev, \"I2S MCLK frequency is %uHz. mode: %s, dir: %s\\n\",\n\t\tfreq, STM32_I2S_IS_MASTER(i2s) ? \"master\" : \"slave\",\n\t\tdir ? \"output\" : \"input\");\n\n\t \n\tif (dir == SND_SOC_CLOCK_OUT && STM32_I2S_IS_MASTER(i2s)) {\n\t\tif (!i2s->i2smclk) {\n\t\t\tdev_dbg(cpu_dai->dev, \"No MCLK registered\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (!freq) {\n\t\t\t \n\t\t\tif (i2s->mclk_rate) {\n\t\t\t\tclk_rate_exclusive_put(i2s->i2smclk);\n\t\t\t\ti2s->mclk_rate = 0;\n\t\t\t}\n\t\t\treturn regmap_update_bits(i2s->regmap,\n\t\t\t\t\t\t  STM32_I2S_CGFR_REG,\n\t\t\t\t\t\t  I2S_CGFR_MCKOE, 0);\n\t\t}\n\t\t \n\t\tret = stm32_i2s_set_parent_clock(i2s, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = clk_set_rate_exclusive(i2s->i2smclk, freq);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dai->dev, \"Could not set mclk rate\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t\t I2S_CGFR_MCKOE, I2S_CGFR_MCKOE);\n\t\tif (!ret)\n\t\t\ti2s->mclk_rate = freq;\n\t}\n\n\treturn ret;\n}\n\nstatic int stm32_i2s_configure_clock(struct snd_soc_dai *cpu_dai,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long i2s_clock_rate;\n\tunsigned int nb_bits, frame_len;\n\tunsigned int rate = params_rate(params);\n\tu32 cgfr;\n\tint ret;\n\n\tif (!(rate % 11025))\n\t\tclk_set_parent(i2s->i2sclk, i2s->x11kclk);\n\telse\n\t\tclk_set_parent(i2s->i2sclk, i2s->x8kclk);\n\ti2s_clock_rate = clk_get_rate(i2s->i2sclk);\n\n\t \n\tif (i2s->mclk_rate) {\n\t\tret = stm32_i2s_calc_clk_div(i2s, i2s_clock_rate,\n\t\t\t\t\t     i2s->mclk_rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tframe_len = 32;\n\t\tif ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\n\t\t    SND_SOC_DAIFMT_DSP_A)\n\t\t\tframe_len = 16;\n\n\t\t \n\t\tret = regmap_read(i2s->regmap, STM32_I2S_CGFR_REG, &cgfr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnb_bits = frame_len * (FIELD_GET(I2S_CGFR_CHLEN, cgfr) + 1);\n\t\tret = stm32_i2s_calc_clk_div(i2s, i2s_clock_rate,\n\t\t\t\t\t     (nb_bits * rate));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = stm32_i2s_set_clk_div(i2s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn regmap_update_bits(i2s->regmap, STM32_I2S_CFG2_REG,\n\t\t\t\t  I2S_CFG2_AFCNTR, I2S_CFG2_AFCNTR);\n}\n\nstatic int stm32_i2s_configure(struct snd_soc_dai *cpu_dai,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tint format = params_width(params);\n\tu32 cfgr, cfgr_mask, cfg1;\n\tunsigned int fthlv;\n\tint ret;\n\n\tswitch (format) {\n\tcase 16:\n\t\tcfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_16);\n\t\tcfgr_mask = I2S_CGFR_DATLEN_MASK | I2S_CGFR_CHLEN;\n\t\tbreak;\n\tcase 32:\n\t\tcfgr = I2S_CGFR_DATLEN_SET(I2S_I2SMOD_DATLEN_32) |\n\t\t\t\t\t   I2S_CGFR_CHLEN;\n\t\tcfgr_mask = I2S_CGFR_DATLEN_MASK | I2S_CGFR_CHLEN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unexpected format %d\", format);\n\t\treturn -EINVAL;\n\t}\n\n\tif (STM32_I2S_IS_SLAVE(i2s)) {\n\t\tcfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_FD_SLAVE);\n\n\t\t \n\t\tcfgr |= I2S_CGFR_FIXCH;\n\t\tcfgr_mask |= I2S_CGFR_FIXCH;\n\t} else {\n\t\tcfgr |= I2S_CGFR_I2SCFG_SET(I2S_I2SMOD_FD_MASTER);\n\t}\n\tcfgr_mask |= I2S_CGFR_I2SCFG_MASK;\n\n\tret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t cfgr_mask, cfgr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfthlv = STM32_I2S_FIFO_SIZE * I2S_FIFO_TH_ONE_QUARTER / 4;\n\tcfg1 = I2S_CFG1_FTHVL_SET(fthlv - 1);\n\n\treturn regmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,\n\t\t\t\t  I2S_CFG1_FTHVL_MASK, cfg1);\n}\n\nstatic int stm32_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&i2s->irq_lock, flags);\n\ti2s->substream = substream;\n\tspin_unlock_irqrestore(&i2s->irq_lock, flags);\n\n\tif ((i2s->fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_DSP_A)\n\t\tsnd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\n\tret = clk_prepare_enable(i2s->i2sclk);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"Failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn regmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,\n\t\t\t\t I2S_IFCR_MASK, I2S_IFCR_MASK);\n}\n\nstatic int stm32_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tret = stm32_i2s_configure(cpu_dai, params, substream);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"Configuration returned error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (STM32_I2S_IS_MASTER(i2s))\n\t\tret = stm32_i2s_configure_clock(cpu_dai, params);\n\n\treturn ret;\n}\n\nstatic int stm32_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tbool playback_flg = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tu32 cfg1_mask, ier;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tdev_dbg(cpu_dai->dev, \"start I2S %s\\n\",\n\t\t\tplayback_flg ? \"playback\" : \"capture\");\n\n\t\tcfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;\n\t\tregmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,\n\t\t\t\t   cfg1_mask, cfg1_mask);\n\n\t\tret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,\n\t\t\t\t\t I2S_CR1_SPE, I2S_CR1_SPE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cpu_dai->dev, \"Error %d enabling I2S\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write_bits(i2s->regmap, STM32_I2S_CR1_REG,\n\t\t\t\t\tI2S_CR1_CSTART, I2S_CR1_CSTART);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cpu_dai->dev, \"Error %d starting I2S\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tregmap_write_bits(i2s->regmap, STM32_I2S_IFCR_REG,\n\t\t\t\t  I2S_IFCR_MASK, I2S_IFCR_MASK);\n\n\t\tspin_lock(&i2s->lock_fd);\n\t\ti2s->refcount++;\n\t\tif (playback_flg) {\n\t\t\tier = I2S_IER_UDRIE;\n\t\t} else {\n\t\t\tier = I2S_IER_OVRIE;\n\n\t\t\tif (STM32_I2S_IS_MASTER(i2s) && i2s->refcount == 1)\n\t\t\t\t \n\t\t\t\tregmap_write(i2s->regmap,\n\t\t\t\t\t     STM32_I2S_TXDR_REG, 0);\n\t\t}\n\t\tspin_unlock(&i2s->lock_fd);\n\n\t\tif (STM32_I2S_IS_SLAVE(i2s))\n\t\t\tier |= I2S_IER_TIFREIE;\n\n\t\tregmap_update_bits(i2s->regmap, STM32_I2S_IER_REG, ier, ier);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdev_dbg(cpu_dai->dev, \"stop I2S %s\\n\",\n\t\t\tplayback_flg ? \"playback\" : \"capture\");\n\n\t\tif (playback_flg)\n\t\t\tregmap_update_bits(i2s->regmap, STM32_I2S_IER_REG,\n\t\t\t\t\t   I2S_IER_UDRIE,\n\t\t\t\t\t   (unsigned int)~I2S_IER_UDRIE);\n\t\telse\n\t\t\tregmap_update_bits(i2s->regmap, STM32_I2S_IER_REG,\n\t\t\t\t\t   I2S_IER_OVRIE,\n\t\t\t\t\t   (unsigned int)~I2S_IER_OVRIE);\n\n\t\tspin_lock(&i2s->lock_fd);\n\t\ti2s->refcount--;\n\t\tif (i2s->refcount) {\n\t\t\tspin_unlock(&i2s->lock_fd);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = regmap_update_bits(i2s->regmap, STM32_I2S_CR1_REG,\n\t\t\t\t\t I2S_CR1_SPE, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cpu_dai->dev, \"Error %d disabling I2S\\n\", ret);\n\t\t\tspin_unlock(&i2s->lock_fd);\n\t\t\treturn ret;\n\t\t}\n\t\tspin_unlock(&i2s->lock_fd);\n\n\t\tcfg1_mask = I2S_CFG1_RXDMAEN | I2S_CFG1_TXDMAEN;\n\t\tregmap_update_bits(i2s->regmap, STM32_I2S_CFG1_REG,\n\t\t\t\t   cfg1_mask, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_i2s_data *i2s = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long flags;\n\n\tclk_disable_unprepare(i2s->i2sclk);\n\n\tspin_lock_irqsave(&i2s->irq_lock, flags);\n\ti2s->substream = NULL;\n\tspin_unlock_irqrestore(&i2s->irq_lock, flags);\n}\n\nstatic int stm32_i2s_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_i2s_data *i2s = dev_get_drvdata(cpu_dai->dev);\n\tstruct snd_dmaengine_dai_dma_data *dma_data_tx = &i2s->dma_data_tx;\n\tstruct snd_dmaengine_dai_dma_data *dma_data_rx = &i2s->dma_data_rx;\n\n\t \n\tdma_data_tx->addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\tdma_data_tx->addr = (dma_addr_t)(i2s->phys_addr) + STM32_I2S_TXDR_REG;\n\tdma_data_tx->maxburst = 1;\n\tdma_data_rx->addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\tdma_data_rx->addr = (dma_addr_t)(i2s->phys_addr) + STM32_I2S_RXDR_REG;\n\tdma_data_rx->maxburst = 1;\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, dma_data_tx, dma_data_rx);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config stm32_h7_i2s_regmap_conf = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = STM32_I2S_SIDR_REG,\n\t.readable_reg = stm32_i2s_readable_reg,\n\t.volatile_reg = stm32_i2s_volatile_reg,\n\t.writeable_reg = stm32_i2s_writeable_reg,\n\t.num_reg_defaults_raw = STM32_I2S_SIDR_REG / sizeof(u32) + 1,\n\t.fast_io = true,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct snd_soc_dai_ops stm32_i2s_pcm_dai_ops = {\n\t.probe\t\t= stm32_i2s_dai_probe,\n\t.set_sysclk\t= stm32_i2s_set_sysclk,\n\t.set_fmt\t= stm32_i2s_set_dai_fmt,\n\t.startup\t= stm32_i2s_startup,\n\t.hw_params\t= stm32_i2s_hw_params,\n\t.trigger\t= stm32_i2s_trigger,\n\t.shutdown\t= stm32_i2s_shutdown,\n};\n\nstatic const struct snd_pcm_hardware stm32_i2s_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,\n\t.buffer_bytes_max = 8 * PAGE_SIZE,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = 4 * PAGE_SIZE,\n\t.periods_min = 2,\n\t.periods_max = 8,\n};\n\nstatic const struct snd_dmaengine_pcm_config stm32_i2s_pcm_config = {\n\t.pcm_hardware\t= &stm32_i2s_pcm_hw,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n\t.prealloc_buffer_size = PAGE_SIZE * 8,\n};\n\nstatic const struct snd_soc_component_driver stm32_i2s_component = {\n\t.name = \"stm32-i2s\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic void stm32_i2s_dai_init(struct snd_soc_pcm_stream *stream,\n\t\t\t       char *stream_name)\n{\n\tstream->stream_name = stream_name;\n\tstream->channels_min = 1;\n\tstream->channels_max = 2;\n\tstream->rates = SNDRV_PCM_RATE_8000_192000;\n\tstream->formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE;\n}\n\nstatic int stm32_i2s_dais_init(struct platform_device *pdev,\n\t\t\t       struct stm32_i2s_data *i2s)\n{\n\tstruct snd_soc_dai_driver *dai_ptr;\n\n\tdai_ptr = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_dai_driver),\n\t\t\t       GFP_KERNEL);\n\tif (!dai_ptr)\n\t\treturn -ENOMEM;\n\n\tdai_ptr->ops = &stm32_i2s_pcm_dai_ops;\n\tdai_ptr->id = 1;\n\tstm32_i2s_dai_init(&dai_ptr->playback, \"playback\");\n\tstm32_i2s_dai_init(&dai_ptr->capture, \"capture\");\n\ti2s->dai_drv = dai_ptr;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id stm32_i2s_ids[] = {\n\t{\n\t\t.compatible = \"st,stm32h7-i2s\",\n\t\t.data = &stm32_h7_i2s_regmap_conf\n\t},\n\t{},\n};\n\nstatic int stm32_i2s_parse_dt(struct platform_device *pdev,\n\t\t\t      struct stm32_i2s_data *i2s)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *of_id;\n\tstruct reset_control *rst;\n\tstruct resource *res;\n\tint irq, ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tof_id = of_match_device(stm32_i2s_ids, &pdev->dev);\n\tif (of_id)\n\t\ti2s->regmap_conf = (const struct regmap_config *)of_id->data;\n\telse\n\t\treturn -EINVAL;\n\n\ti2s->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2s->base))\n\t\treturn PTR_ERR(i2s->base);\n\n\ti2s->phys_addr = res->start;\n\n\t \n\ti2s->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(i2s->pclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2s->pclk),\n\t\t\t\t     \"Could not get pclk\\n\");\n\n\ti2s->i2sclk = devm_clk_get(&pdev->dev, \"i2sclk\");\n\tif (IS_ERR(i2s->i2sclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2s->i2sclk),\n\t\t\t\t     \"Could not get i2sclk\\n\");\n\n\ti2s->x8kclk = devm_clk_get(&pdev->dev, \"x8k\");\n\tif (IS_ERR(i2s->x8kclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2s->x8kclk),\n\t\t\t\t     \"Could not get x8k parent clock\\n\");\n\n\ti2s->x11kclk = devm_clk_get(&pdev->dev, \"x11k\");\n\tif (IS_ERR(i2s->x11kclk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2s->x11kclk),\n\t\t\t\t     \"Could not get x11k parent clock\\n\");\n\n\t \n\tif (of_property_present(np, \"#clock-cells\")) {\n\t\tret = stm32_i2s_add_mclk_provider(i2s);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, stm32_i2s_isr, 0,\n\t\t\t       dev_name(&pdev->dev), i2s);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"irq request returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\trst = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rst))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(rst),\n\t\t\t\t     \"Reset controller error\\n\");\n\n\treset_control_assert(rst);\n\tudelay(2);\n\treset_control_deassert(rst);\n\n\treturn 0;\n}\n\nstatic void stm32_i2s_remove(struct platform_device *pdev)\n{\n\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\tsnd_soc_unregister_component(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int stm32_i2s_probe(struct platform_device *pdev)\n{\n\tstruct stm32_i2s_data *i2s;\n\tu32 val;\n\tint ret;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\n\ti2s->pdev = pdev;\n\ti2s->ms_flg = I2S_MS_NOT_SET;\n\tspin_lock_init(&i2s->lock_fd);\n\tspin_lock_init(&i2s->irq_lock);\n\tplatform_set_drvdata(pdev, i2s);\n\n\tret = stm32_i2s_parse_dt(pdev, i2s);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stm32_i2s_dais_init(pdev, i2s);\n\tif (ret)\n\t\treturn ret;\n\n\ti2s->regmap = devm_regmap_init_mmio_clk(&pdev->dev, \"pclk\",\n\t\t\t\t\t\ti2s->base, i2s->regmap_conf);\n\tif (IS_ERR(i2s->regmap))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(i2s->regmap),\n\t\t\t\t     \"Regmap init error\\n\");\n\n\tret = snd_dmaengine_pcm_register(&pdev->dev, &stm32_i2s_pcm_config, 0);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"PCM DMA register error\\n\");\n\n\tret = snd_soc_register_component(&pdev->dev, &stm32_i2s_component,\n\t\t\t\t\t i2s->dai_drv, 1);\n\tif (ret) {\n\t\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(i2s->regmap, STM32_I2S_CGFR_REG,\n\t\t\t\t I2S_CGFR_I2SMOD, I2S_CGFR_I2SMOD);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read(i2s->regmap, STM32_I2S_IPIDR_REG, &val);\n\tif (ret)\n\t\tgoto error;\n\n\tif (val == I2S_IPIDR_NUMBER) {\n\t\tret = regmap_read(i2s->regmap, STM32_I2S_HWCFGR_REG, &val);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tif (!FIELD_GET(I2S_HWCFGR_I2S_SUPPORT_MASK, val)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Device does not support i2s mode\\n\");\n\t\t\tret = -EPERM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = regmap_read(i2s->regmap, STM32_I2S_VERR_REG, &val);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\tdev_dbg(&pdev->dev, \"I2S version: %lu.%lu registered\\n\",\n\t\t\tFIELD_GET(I2S_VERR_MAJ_MASK, val),\n\t\t\tFIELD_GET(I2S_VERR_MIN_MASK, val));\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn ret;\n\nerror:\n\tstm32_i2s_remove(pdev);\n\n\treturn ret;\n}\n\nMODULE_DEVICE_TABLE(of, stm32_i2s_ids);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_i2s_suspend(struct device *dev)\n{\n\tstruct stm32_i2s_data *i2s = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s->regmap, true);\n\tregcache_mark_dirty(i2s->regmap);\n\n\treturn 0;\n}\n\nstatic int stm32_i2s_resume(struct device *dev)\n{\n\tstruct stm32_i2s_data *i2s = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s->regmap, false);\n\treturn regcache_sync(i2s->regmap);\n}\n#endif  \n\nstatic const struct dev_pm_ops stm32_i2s_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_i2s_suspend, stm32_i2s_resume)\n};\n\nstatic struct platform_driver stm32_i2s_driver = {\n\t.driver = {\n\t\t.name = \"st,stm32-i2s\",\n\t\t.of_match_table = stm32_i2s_ids,\n\t\t.pm = &stm32_i2s_pm_ops,\n\t},\n\t.probe = stm32_i2s_probe,\n\t.remove_new = stm32_i2s_remove,\n};\n\nmodule_platform_driver(stm32_i2s_driver);\n\nMODULE_DESCRIPTION(\"STM32 Soc i2s Interface\");\nMODULE_AUTHOR(\"Olivier Moysan, <olivier.moysan@st.com>\");\nMODULE_ALIAS(\"platform:stm32-i2s\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}