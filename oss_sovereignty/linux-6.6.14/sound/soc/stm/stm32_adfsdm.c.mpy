{
  "module_name": "stm32_adfsdm.c",
  "hash_id": "2ab314b0bbc417e9272fc023630dc0f8cb62acd0a284973c15995faa219ac5bb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/stm/stm32_adfsdm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/iio/iio.h>\n#include <linux/iio/consumer.h>\n#include <linux/iio/adc/stm32-dfsdm-adc.h>\n\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#define STM32_ADFSDM_DRV_NAME \"stm32-adfsdm\"\n\n#define DFSDM_MAX_PERIOD_SIZE\t(PAGE_SIZE / 2)\n#define DFSDM_MAX_PERIODS\t6\n\nstruct stm32_adfsdm_priv {\n\tstruct snd_soc_dai_driver dai_drv;\n\tstruct snd_pcm_substream *substream;\n\tstruct device *dev;\n\n\t \n\tstruct iio_channel *iio_ch;\n\tstruct iio_cb_buffer *iio_cb;\n\tbool iio_active;\n\n\t \n\tunsigned char *pcm_buff;\n\tunsigned int pos;\n\n\tstruct mutex lock;  \n};\n\nstatic const struct snd_pcm_hardware stm32_adfsdm_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_PAUSE,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\n\t.channels_min = 1,\n\t.channels_max = 1,\n\n\t.periods_min = 2,\n\t.periods_max = DFSDM_MAX_PERIODS,\n\n\t.period_bytes_max = DFSDM_MAX_PERIOD_SIZE,\n\t.buffer_bytes_max = DFSDM_MAX_PERIODS * DFSDM_MAX_PERIOD_SIZE\n};\n\nstatic void stm32_adfsdm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct stm32_adfsdm_priv *priv = snd_soc_dai_get_drvdata(dai);\n\n\tmutex_lock(&priv->lock);\n\tif (priv->iio_active) {\n\t\tiio_channel_stop_all_cb(priv->iio_cb);\n\t\tpriv->iio_active = false;\n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int stm32_adfsdm_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct stm32_adfsdm_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tif (priv->iio_active) {\n\t\tiio_channel_stop_all_cb(priv->iio_cb);\n\t\tpriv->iio_active = false;\n\t}\n\n\tret = iio_write_channel_attribute(priv->iio_ch,\n\t\t\t\t\t  substream->runtime->rate, 0,\n\t\t\t\t\t  IIO_CHAN_INFO_SAMP_FREQ);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"%s: Failed to set %d sampling rate\\n\",\n\t\t\t__func__, substream->runtime->rate);\n\t\tgoto out;\n\t}\n\n\tif (!priv->iio_active) {\n\t\tret = iio_channel_start_all_cb(priv->iio_cb);\n\t\tif (!ret)\n\t\t\tpriv->iio_active = true;\n\t\telse\n\t\t\tdev_err(dai->dev, \"%s: IIO channel start failed (%d)\\n\",\n\t\t\t\t__func__, ret);\n\t}\n\nout:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int stm32_adfsdm_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t   unsigned int freq, int dir)\n{\n\tstruct stm32_adfsdm_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tssize_t size;\n\tchar str_freq[10];\n\n\tdev_dbg(dai->dev, \"%s: Enter for freq %d\\n\", __func__, freq);\n\n\t \n\n\tsnprintf(str_freq, sizeof(str_freq), \"%u\\n\", freq);\n\tsize = iio_write_channel_ext_info(priv->iio_ch, \"spi_clk_freq\",\n\t\t\t\t\t  str_freq, sizeof(str_freq));\n\tif (size != sizeof(str_freq)) {\n\t\tdev_err(dai->dev, \"%s: Failed to set SPI clock\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops stm32_adfsdm_dai_ops = {\n\t.shutdown = stm32_adfsdm_shutdown,\n\t.prepare = stm32_adfsdm_dai_prepare,\n\t.set_sysclk = stm32_adfsdm_set_sysclk,\n};\n\nstatic const struct snd_soc_dai_driver stm32_adfsdm_dai = {\n\t.capture = {\n\t\t    .channels_min = 1,\n\t\t    .channels_max = 1,\n\t\t    .formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t       SNDRV_PCM_FMTBIT_S32_LE,\n\t\t    .rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t    .rate_min = 8000,\n\t\t    .rate_max = 48000,\n\t\t    },\n\t.ops = &stm32_adfsdm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver stm32_adfsdm_dai_component = {\n\t.name = \"stm32_dfsdm_audio\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic void stm32_memcpy_32to16(void *dest, const void *src, size_t n)\n{\n\tunsigned int i = 0;\n\tu16 *d = (u16 *)dest, *s = (u16 *)src;\n\n\ts++;\n\tfor (i = n >> 1; i > 0; i--) {\n\t\t*d++ = *s++;\n\t\ts++;\n\t}\n}\n\nstatic int stm32_afsdm_pcm_cb(const void *data, size_t size, void *private)\n{\n\tstruct stm32_adfsdm_priv *priv = private;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(priv->substream);\n\tu8 *pcm_buff = priv->pcm_buff;\n\tu8 *src_buff = (u8 *)data;\n\tunsigned int old_pos = priv->pos;\n\tsize_t buff_size = snd_pcm_lib_buffer_bytes(priv->substream);\n\tsize_t period_size = snd_pcm_lib_period_bytes(priv->substream);\n\tsize_t cur_size, src_size = size;\n\tsnd_pcm_format_t format = priv->substream->runtime->format;\n\n\tif (format == SNDRV_PCM_FORMAT_S16_LE)\n\t\tsrc_size >>= 1;\n\tcur_size = src_size;\n\n\tdev_dbg(rtd->dev, \"%s: buff_add :%pK, pos = %d, size = %zu\\n\",\n\t\t__func__, &pcm_buff[priv->pos], priv->pos, src_size);\n\n\tif ((priv->pos + src_size) > buff_size) {\n\t\tif (format == SNDRV_PCM_FORMAT_S16_LE)\n\t\t\tstm32_memcpy_32to16(&pcm_buff[priv->pos], src_buff,\n\t\t\t\t\t    buff_size - priv->pos);\n\t\telse\n\t\t\tmemcpy(&pcm_buff[priv->pos], src_buff,\n\t\t\t       buff_size - priv->pos);\n\t\tcur_size -= buff_size - priv->pos;\n\t\tpriv->pos = 0;\n\t}\n\n\tif (format == SNDRV_PCM_FORMAT_S16_LE)\n\t\tstm32_memcpy_32to16(&pcm_buff[priv->pos],\n\t\t\t\t    &src_buff[src_size - cur_size], cur_size);\n\telse\n\t\tmemcpy(&pcm_buff[priv->pos], &src_buff[src_size - cur_size],\n\t\t       cur_size);\n\n\tpriv->pos = (priv->pos + cur_size) % buff_size;\n\n\tif (cur_size != src_size || (old_pos && (old_pos % period_size < size)))\n\t\tsnd_pcm_period_elapsed(priv->substream);\n\n\treturn 0;\n}\n\nstatic int stm32_adfsdm_trigger(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct stm32_adfsdm_priv *priv =\n\t\tsnd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tpriv->pos = 0;\n\t\treturn stm32_dfsdm_get_buff_cb(priv->iio_ch->indio_dev,\n\t\t\t\t\t       stm32_afsdm_pcm_cb, priv);\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\treturn stm32_dfsdm_release_buff_cb(priv->iio_ch->indio_dev);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_adfsdm_pcm_open(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct stm32_adfsdm_priv *priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tint ret;\n\n\tret =  snd_soc_set_runtime_hwparams(substream, &stm32_adfsdm_pcm_hw);\n\tif (!ret)\n\t\tpriv->substream = substream;\n\n\treturn ret;\n}\n\nstatic int stm32_adfsdm_pcm_close(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct stm32_adfsdm_priv *priv =\n\t\tsnd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tpriv->substream = NULL;\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t stm32_adfsdm_pcm_pointer(\n\t\t\t\t\t    struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct stm32_adfsdm_priv *priv =\n\t\tsnd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\treturn bytes_to_frames(substream->runtime, priv->pos);\n}\n\nstatic int stm32_adfsdm_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct stm32_adfsdm_priv *priv =\n\t\tsnd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tpriv->pcm_buff = substream->runtime->dma_area;\n\n\treturn iio_channel_cb_set_buffer_watermark(priv->iio_cb,\n\t\t\t\t\t\t   params_period_size(params));\n}\n\nstatic int stm32_adfsdm_pcm_new(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct stm32_adfsdm_priv *priv =\n\t\tsnd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned int size = DFSDM_MAX_PERIODS * DFSDM_MAX_PERIOD_SIZE;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t       priv->dev, size, size);\n\treturn 0;\n}\n\nstatic int stm32_adfsdm_dummy_cb(const void *data, void *private)\n{\n\t \n\treturn 0;\n}\n\nstatic void stm32_adfsdm_cleanup(void *data)\n{\n\tiio_channel_release_all_cb(data);\n}\n\nstatic struct snd_soc_component_driver stm32_adfsdm_soc_platform = {\n\t.open\t\t= stm32_adfsdm_pcm_open,\n\t.close\t\t= stm32_adfsdm_pcm_close,\n\t.hw_params\t= stm32_adfsdm_pcm_hw_params,\n\t.trigger\t= stm32_adfsdm_trigger,\n\t.pointer\t= stm32_adfsdm_pcm_pointer,\n\t.pcm_construct\t= stm32_adfsdm_pcm_new,\n};\n\nstatic const struct of_device_id stm32_adfsdm_of_match[] = {\n\t{.compatible = \"st,stm32h7-dfsdm-dai\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_adfsdm_of_match);\n\nstatic int stm32_adfsdm_probe(struct platform_device *pdev)\n{\n\tstruct stm32_adfsdm_priv *priv;\n\tstruct snd_soc_component *component;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = &pdev->dev;\n\tpriv->dai_drv = stm32_adfsdm_dai;\n\tmutex_init(&priv->lock);\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &stm32_adfsdm_dai_component,\n\t\t\t\t\t      &priv->dai_drv, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpriv->iio_ch  = devm_iio_channel_get_all(&pdev->dev);\n\tif (IS_ERR(priv->iio_ch))\n\t\treturn PTR_ERR(priv->iio_ch);\n\n\tpriv->iio_cb = iio_channel_get_all_cb(&pdev->dev, &stm32_adfsdm_dummy_cb, NULL);\n\tif (IS_ERR(priv->iio_cb))\n\t\treturn PTR_ERR(priv->iio_cb);\n\n\tret = devm_add_action_or_reset(&pdev->dev, stm32_adfsdm_cleanup, priv->iio_cb);\n\tif (ret < 0)  {\n\t\tdev_err(&pdev->dev, \"Unable to add action\\n\");\n\t\treturn ret;\n\t}\n\n\tcomponent = devm_kzalloc(&pdev->dev, sizeof(*component), GFP_KERNEL);\n\tif (!component)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_component_initialize(component,\n\t\t\t\t\t   &stm32_adfsdm_soc_platform,\n\t\t\t\t\t   &pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_DEBUG_FS\n\tcomponent->debugfs_prefix = \"pcm\";\n#endif\n\n\tret = snd_soc_add_component(component, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"%s: Failed to register PCM platform\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void stm32_adfsdm_remove(struct platform_device *pdev)\n{\n\tsnd_soc_unregister_component(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic struct platform_driver stm32_adfsdm_driver = {\n\t.driver = {\n\t\t   .name = STM32_ADFSDM_DRV_NAME,\n\t\t   .of_match_table = stm32_adfsdm_of_match,\n\t\t   },\n\t.probe = stm32_adfsdm_probe,\n\t.remove_new = stm32_adfsdm_remove,\n};\n\nmodule_platform_driver(stm32_adfsdm_driver);\n\nMODULE_DESCRIPTION(\"stm32 DFSDM DAI driver\");\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" STM32_ADFSDM_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}