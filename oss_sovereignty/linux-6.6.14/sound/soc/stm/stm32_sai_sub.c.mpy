{
  "module_name": "stm32_sai_sub.c",
  "hash_id": "7dd8c7f4ca1ce8106bd5636c0871ba0f15808b564e4915e082e515356782dfd5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/stm/stm32_sai_sub.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"stm32_sai.h\"\n\n#define SAI_FREE_PROTOCOL\t0x0\n#define SAI_SPDIF_PROTOCOL\t0x1\n\n#define SAI_SLOT_SIZE_AUTO\t0x0\n#define SAI_SLOT_SIZE_16\t0x1\n#define SAI_SLOT_SIZE_32\t0x2\n\n#define SAI_DATASIZE_8\t\t0x2\n#define SAI_DATASIZE_10\t\t0x3\n#define SAI_DATASIZE_16\t\t0x4\n#define SAI_DATASIZE_20\t\t0x5\n#define SAI_DATASIZE_24\t\t0x6\n#define SAI_DATASIZE_32\t\t0x7\n\n#define STM_SAI_DAI_NAME_SIZE\t15\n\n#define STM_SAI_IS_PLAYBACK(ip)\t((ip)->dir == SNDRV_PCM_STREAM_PLAYBACK)\n#define STM_SAI_IS_CAPTURE(ip)\t((ip)->dir == SNDRV_PCM_STREAM_CAPTURE)\n\n#define STM_SAI_A_ID\t\t0x0\n#define STM_SAI_B_ID\t\t0x1\n\n#define STM_SAI_IS_SUB_A(x)\t((x)->id == STM_SAI_A_ID)\n\n#define SAI_SYNC_NONE\t\t0x0\n#define SAI_SYNC_INTERNAL\t0x1\n#define SAI_SYNC_EXTERNAL\t0x2\n\n#define STM_SAI_PROTOCOL_IS_SPDIF(ip)\t((ip)->spdif)\n#define STM_SAI_HAS_SPDIF(x)\t((x)->pdata->conf.has_spdif_pdm)\n#define STM_SAI_HAS_PDM(x)\t((x)->pdata->conf.has_spdif_pdm)\n#define STM_SAI_HAS_EXT_SYNC(x) (!STM_SAI_IS_F4(sai->pdata))\n\n#define SAI_IEC60958_BLOCK_FRAMES\t192\n#define SAI_IEC60958_STATUS_BYTES\t24\n\n#define SAI_MCLK_NAME_LEN\t\t32\n#define SAI_RATE_11K\t\t\t11025\n\n \nstruct stm32_sai_sub_data {\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tconst struct regmap_config *regmap_config;\n\tstruct snd_dmaengine_dai_dma_data dma_params;\n\tstruct snd_soc_dai_driver cpu_dai_drv;\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct snd_pcm_substream *substream;\n\tstruct stm32_sai_data *pdata;\n\tstruct device_node *np_sync_provider;\n\tstruct clk *sai_ck;\n\tstruct clk *sai_mclk;\n\tdma_addr_t phys_addr;\n\tunsigned int mclk_rate;\n\tunsigned int id;\n\tint dir;\n\tbool master;\n\tbool spdif;\n\tint fmt;\n\tint sync;\n\tint synco;\n\tint synci;\n\tint fs_length;\n\tint slots;\n\tint slot_width;\n\tint slot_mask;\n\tint data_size;\n\tunsigned int spdif_frm_cnt;\n\tstruct snd_aes_iec958 iec958;\n\tstruct mutex ctrl_lock;  \n\tspinlock_t irq_lock;  \n};\n\nenum stm32_sai_fifo_th {\n\tSTM_SAI_FIFO_TH_EMPTY,\n\tSTM_SAI_FIFO_TH_QUARTER,\n\tSTM_SAI_FIFO_TH_HALF,\n\tSTM_SAI_FIFO_TH_3_QUARTER,\n\tSTM_SAI_FIFO_TH_FULL,\n};\n\nstatic bool stm32_sai_sub_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM_SAI_CR1_REGX:\n\tcase STM_SAI_CR2_REGX:\n\tcase STM_SAI_FRCR_REGX:\n\tcase STM_SAI_SLOTR_REGX:\n\tcase STM_SAI_IMR_REGX:\n\tcase STM_SAI_SR_REGX:\n\tcase STM_SAI_CLRFR_REGX:\n\tcase STM_SAI_DR_REGX:\n\tcase STM_SAI_PDMCR_REGX:\n\tcase STM_SAI_PDMLY_REGX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_sai_sub_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM_SAI_DR_REGX:\n\tcase STM_SAI_SR_REGX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stm32_sai_sub_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STM_SAI_CR1_REGX:\n\tcase STM_SAI_CR2_REGX:\n\tcase STM_SAI_FRCR_REGX:\n\tcase STM_SAI_SLOTR_REGX:\n\tcase STM_SAI_IMR_REGX:\n\tcase STM_SAI_CLRFR_REGX:\n\tcase STM_SAI_DR_REGX:\n\tcase STM_SAI_PDMCR_REGX:\n\tcase STM_SAI_PDMLY_REGX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int stm32_sai_sub_reg_up(struct stm32_sai_sub_data *sai,\n\t\t\t\tunsigned int reg, unsigned int mask,\n\t\t\t\tunsigned int val)\n{\n\tint ret;\n\n\tret = clk_enable(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(sai->regmap, reg, mask, val);\n\n\tclk_disable(sai->pdata->pclk);\n\n\treturn ret;\n}\n\nstatic int stm32_sai_sub_reg_wr(struct stm32_sai_sub_data *sai,\n\t\t\t\tunsigned int reg, unsigned int mask,\n\t\t\t\tunsigned int val)\n{\n\tint ret;\n\n\tret = clk_enable(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write_bits(sai->regmap, reg, mask, val);\n\n\tclk_disable(sai->pdata->pclk);\n\n\treturn ret;\n}\n\nstatic int stm32_sai_sub_reg_rd(struct stm32_sai_sub_data *sai,\n\t\t\t\tunsigned int reg, unsigned int *val)\n{\n\tint ret;\n\n\tret = clk_enable(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(sai->regmap, reg, val);\n\n\tclk_disable(sai->pdata->pclk);\n\n\treturn ret;\n}\n\nstatic const struct regmap_config stm32_sai_sub_regmap_config_f4 = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = STM_SAI_DR_REGX,\n\t.readable_reg = stm32_sai_sub_readable_reg,\n\t.volatile_reg = stm32_sai_sub_volatile_reg,\n\t.writeable_reg = stm32_sai_sub_writeable_reg,\n\t.fast_io = true,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct regmap_config stm32_sai_sub_regmap_config_h7 = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = STM_SAI_PDMLY_REGX,\n\t.readable_reg = stm32_sai_sub_readable_reg,\n\t.volatile_reg = stm32_sai_sub_volatile_reg,\n\t.writeable_reg = stm32_sai_sub_writeable_reg,\n\t.fast_io = true,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int snd_pcm_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int snd_pcm_iec958_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *uctl)\n{\n\tstruct stm32_sai_sub_data *sai = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&sai->ctrl_lock);\n\tmemcpy(uctl->value.iec958.status, sai->iec958.status, 4);\n\tmutex_unlock(&sai->ctrl_lock);\n\n\treturn 0;\n}\n\nstatic int snd_pcm_iec958_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *uctl)\n{\n\tstruct stm32_sai_sub_data *sai = snd_kcontrol_chip(kcontrol);\n\n\tmutex_lock(&sai->ctrl_lock);\n\tmemcpy(sai->iec958.status, uctl->value.iec958.status, 4);\n\tmutex_unlock(&sai->ctrl_lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new iec958_ctls = {\n\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t.info = snd_pcm_iec958_info,\n\t.get = snd_pcm_iec958_get,\n\t.put = snd_pcm_iec958_put,\n};\n\nstruct stm32_sai_mclk_data {\n\tstruct clk_hw hw;\n\tunsigned long freq;\n\tstruct stm32_sai_sub_data *sai_data;\n};\n\n#define to_mclk_data(_hw) container_of(_hw, struct stm32_sai_mclk_data, hw)\n#define STM32_SAI_MAX_CLKS 1\n\nstatic int stm32_sai_get_clk_div(struct stm32_sai_sub_data *sai,\n\t\t\t\t unsigned long input_rate,\n\t\t\t\t unsigned long output_rate)\n{\n\tint version = sai->pdata->conf.version;\n\tint div;\n\n\tdiv = DIV_ROUND_CLOSEST(input_rate, output_rate);\n\tif (div > SAI_XCR1_MCKDIV_MAX(version)) {\n\t\tdev_err(&sai->pdev->dev, \"Divider %d out of range\\n\", div);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(&sai->pdev->dev, \"SAI divider %d\\n\", div);\n\n\tif (input_rate % div)\n\t\tdev_dbg(&sai->pdev->dev,\n\t\t\t\"Rate not accurate. requested (%ld), actual (%ld)\\n\",\n\t\t\toutput_rate, input_rate / div);\n\n\treturn div;\n}\n\nstatic int stm32_sai_set_clk_div(struct stm32_sai_sub_data *sai,\n\t\t\t\t unsigned int div)\n{\n\tint version = sai->pdata->conf.version;\n\tint ret, cr1, mask;\n\n\tif (div > SAI_XCR1_MCKDIV_MAX(version)) {\n\t\tdev_err(&sai->pdev->dev, \"Divider %d out of range\\n\", div);\n\t\treturn -EINVAL;\n\t}\n\n\tmask = SAI_XCR1_MCKDIV_MASK(SAI_XCR1_MCKDIV_WIDTH(version));\n\tcr1 = SAI_XCR1_MCKDIV_SET(div);\n\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX, mask, cr1);\n\tif (ret < 0)\n\t\tdev_err(&sai->pdev->dev, \"Failed to update CR1 register\\n\");\n\n\treturn ret;\n}\n\nstatic int stm32_sai_set_parent_clock(struct stm32_sai_sub_data *sai,\n\t\t\t\t      unsigned int rate)\n{\n\tstruct platform_device *pdev = sai->pdev;\n\tstruct clk *parent_clk = sai->pdata->clk_x8k;\n\tint ret;\n\n\tif (!(rate % SAI_RATE_11K))\n\t\tparent_clk = sai->pdata->clk_x11k;\n\n\tret = clk_set_parent(sai->sai_ck, parent_clk);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \" Error %d setting sai_ck parent clock. %s\",\n\t\t\tret, ret == -EBUSY ?\n\t\t\t\"Active stream rates conflict\\n\" : \"\\n\");\n\n\treturn ret;\n}\n\nstatic long stm32_sai_mclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t      unsigned long *prate)\n{\n\tstruct stm32_sai_mclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_sai_sub_data *sai = mclk->sai_data;\n\tint div;\n\n\tdiv = stm32_sai_get_clk_div(sai, *prate, rate);\n\tif (div < 0)\n\t\treturn div;\n\n\tmclk->freq = *prate / div;\n\n\treturn mclk->freq;\n}\n\nstatic unsigned long stm32_sai_mclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct stm32_sai_mclk_data *mclk = to_mclk_data(hw);\n\n\treturn mclk->freq;\n}\n\nstatic int stm32_sai_mclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long parent_rate)\n{\n\tstruct stm32_sai_mclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_sai_sub_data *sai = mclk->sai_data;\n\tint div, ret;\n\n\tdiv = stm32_sai_get_clk_div(sai, parent_rate, rate);\n\tif (div < 0)\n\t\treturn div;\n\n\tret = stm32_sai_set_clk_div(sai, div);\n\tif (ret)\n\t\treturn ret;\n\n\tmclk->freq = rate;\n\n\treturn 0;\n}\n\nstatic int stm32_sai_mclk_enable(struct clk_hw *hw)\n{\n\tstruct stm32_sai_mclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_sai_sub_data *sai = mclk->sai_data;\n\n\tdev_dbg(&sai->pdev->dev, \"Enable master clock\\n\");\n\n\treturn stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t    SAI_XCR1_MCKEN, SAI_XCR1_MCKEN);\n}\n\nstatic void stm32_sai_mclk_disable(struct clk_hw *hw)\n{\n\tstruct stm32_sai_mclk_data *mclk = to_mclk_data(hw);\n\tstruct stm32_sai_sub_data *sai = mclk->sai_data;\n\n\tdev_dbg(&sai->pdev->dev, \"Disable master clock\\n\");\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX, SAI_XCR1_MCKEN, 0);\n}\n\nstatic const struct clk_ops mclk_ops = {\n\t.enable = stm32_sai_mclk_enable,\n\t.disable = stm32_sai_mclk_disable,\n\t.recalc_rate = stm32_sai_mclk_recalc_rate,\n\t.round_rate = stm32_sai_mclk_round_rate,\n\t.set_rate = stm32_sai_mclk_set_rate,\n};\n\nstatic int stm32_sai_add_mclk_provider(struct stm32_sai_sub_data *sai)\n{\n\tstruct clk_hw *hw;\n\tstruct stm32_sai_mclk_data *mclk;\n\tstruct device *dev = &sai->pdev->dev;\n\tconst char *pname = __clk_get_name(sai->sai_ck);\n\tchar *mclk_name, *p, *s = (char *)pname;\n\tint ret, i = 0;\n\n\tmclk = devm_kzalloc(dev, sizeof(*mclk), GFP_KERNEL);\n\tif (!mclk)\n\t\treturn -ENOMEM;\n\n\tmclk_name = devm_kcalloc(dev, sizeof(char),\n\t\t\t\t SAI_MCLK_NAME_LEN, GFP_KERNEL);\n\tif (!mclk_name)\n\t\treturn -ENOMEM;\n\n\t \n\tp = mclk_name;\n\twhile (*s && *s != '_' && (i < (SAI_MCLK_NAME_LEN - 7))) {\n\t\t*p++ = *s++;\n\t\ti++;\n\t}\n\tSTM_SAI_IS_SUB_A(sai) ? strcat(p, \"a_mclk\") : strcat(p, \"b_mclk\");\n\n\tmclk->hw.init = CLK_HW_INIT(mclk_name, pname, &mclk_ops, 0);\n\tmclk->sai_data = sai;\n\thw = &mclk->hw;\n\n\tdev_dbg(dev, \"Register master clock %s\\n\", mclk_name);\n\tret = devm_clk_hw_register(&sai->pdev->dev, hw);\n\tif (ret) {\n\t\tdev_err(dev, \"mclk register returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsai->sai_mclk = hw->clk;\n\n\t \n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, hw);\n}\n\nstatic irqreturn_t stm32_sai_isr(int irq, void *devid)\n{\n\tstruct stm32_sai_sub_data *sai = (struct stm32_sai_sub_data *)devid;\n\tstruct platform_device *pdev = sai->pdev;\n\tunsigned int sr, imr, flags;\n\tsnd_pcm_state_t status = SNDRV_PCM_STATE_RUNNING;\n\n\tstm32_sai_sub_reg_rd(sai, STM_SAI_IMR_REGX, &imr);\n\tstm32_sai_sub_reg_rd(sai, STM_SAI_SR_REGX, &sr);\n\n\tflags = sr & imr;\n\tif (!flags)\n\t\treturn IRQ_NONE;\n\n\tstm32_sai_sub_reg_wr(sai, STM_SAI_CLRFR_REGX, SAI_XCLRFR_MASK,\n\t\t\t     SAI_XCLRFR_MASK);\n\n\tif (!sai->substream) {\n\t\tdev_err(&pdev->dev, \"Device stopped. Spurious IRQ 0x%x\\n\", sr);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (flags & SAI_XIMR_OVRUDRIE) {\n\t\tdev_err(&pdev->dev, \"IRQ %s\\n\",\n\t\t\tSTM_SAI_IS_PLAYBACK(sai) ? \"underrun\" : \"overrun\");\n\t\tstatus = SNDRV_PCM_STATE_XRUN;\n\t}\n\n\tif (flags & SAI_XIMR_MUTEDETIE)\n\t\tdev_dbg(&pdev->dev, \"IRQ mute detected\\n\");\n\n\tif (flags & SAI_XIMR_WCKCFGIE) {\n\t\tdev_err(&pdev->dev, \"IRQ wrong clock configuration\\n\");\n\t\tstatus = SNDRV_PCM_STATE_DISCONNECTED;\n\t}\n\n\tif (flags & SAI_XIMR_CNRDYIE)\n\t\tdev_err(&pdev->dev, \"IRQ Codec not ready\\n\");\n\n\tif (flags & SAI_XIMR_AFSDETIE) {\n\t\tdev_err(&pdev->dev, \"IRQ Anticipated frame synchro\\n\");\n\t\tstatus = SNDRV_PCM_STATE_XRUN;\n\t}\n\n\tif (flags & SAI_XIMR_LFSDETIE) {\n\t\tdev_err(&pdev->dev, \"IRQ Late frame synchro\\n\");\n\t\tstatus = SNDRV_PCM_STATE_XRUN;\n\t}\n\n\tspin_lock(&sai->irq_lock);\n\tif (status != SNDRV_PCM_STATE_RUNNING && sai->substream)\n\t\tsnd_pcm_stop_xrun(sai->substream);\n\tspin_unlock(&sai->irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int stm32_sai_set_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tif (dir == SND_SOC_CLOCK_OUT && sai->sai_mclk) {\n\t\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t\t   SAI_XCR1_NODIV,\n\t\t\t\t\t freq ? 0 : SAI_XCR1_NODIV);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!freq) {\n\t\t\t \n\t\t\tif (sai->mclk_rate) {\n\t\t\t\tclk_rate_exclusive_put(sai->sai_mclk);\n\t\t\t\tsai->mclk_rate = 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret = stm32_sai_set_parent_clock(sai, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_set_rate_exclusive(sai->sai_mclk, freq);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dai->dev,\n\t\t\t\tret == -EBUSY ?\n\t\t\t\t\"Active streams have incompatible rates\" :\n\t\t\t\t\"Could not set mclk rate\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_dbg(cpu_dai->dev, \"SAI MCLK frequency is %uHz\\n\", freq);\n\t\tsai->mclk_rate = freq;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_sai_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\n\t\t\t\t      u32 rx_mask, int slots, int slot_width)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint slotr, slotr_mask, slot_size;\n\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\tdev_warn(cpu_dai->dev, \"Slot setting relevant only for TDM\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(cpu_dai->dev, \"Masks tx/rx:%#x/%#x, slots:%d, width:%d\\n\",\n\t\ttx_mask, rx_mask, slots, slot_width);\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tslot_size = SAI_SLOT_SIZE_16;\n\t\tbreak;\n\tcase 32:\n\t\tslot_size = SAI_SLOT_SIZE_32;\n\t\tbreak;\n\tdefault:\n\t\tslot_size = SAI_SLOT_SIZE_AUTO;\n\t\tbreak;\n\t}\n\n\tslotr = SAI_XSLOTR_SLOTSZ_SET(slot_size) |\n\t\tSAI_XSLOTR_NBSLOT_SET(slots - 1);\n\tslotr_mask = SAI_XSLOTR_SLOTSZ_MASK | SAI_XSLOTR_NBSLOT_MASK;\n\n\t \n\tif (STM_SAI_IS_PLAYBACK(sai)) {\n\t\tsai->slot_mask = tx_mask;\n\t\tslotr |= SAI_XSLOTR_SLOTEN_SET(tx_mask);\n\t}\n\n\tif (STM_SAI_IS_CAPTURE(sai)) {\n\t\tsai->slot_mask = rx_mask;\n\t\tslotr |= SAI_XSLOTR_SLOTEN_SET(rx_mask);\n\t}\n\n\tslotr_mask |= SAI_XSLOTR_SLOTEN_MASK;\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_SLOTR_REGX, slotr_mask, slotr);\n\n\tsai->slot_width = slot_width;\n\tsai->slots = slots;\n\n\treturn 0;\n}\n\nstatic int stm32_sai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint cr1, frcr = 0;\n\tint cr1_mask, frcr_mask = 0;\n\tint ret;\n\n\tdev_dbg(cpu_dai->dev, \"fmt %x\\n\", fmt);\n\n\t \n\tcr1 = SAI_XCR1_NODIV;\n\tcr1_mask = SAI_XCR1_NODIV;\n\n\tcr1_mask |= SAI_XCR1_PRTCFG_MASK;\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\tcr1 |= SAI_XCR1_PRTCFG_SET(SAI_SPDIF_PROTOCOL);\n\t\tgoto conf_update;\n\t}\n\n\tcr1 |= SAI_XCR1_PRTCFG_SET(SAI_FREE_PROTOCOL);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t \n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcr1 |= SAI_XCR1_CKSTR;\n\t\tfrcr |= SAI_XFRCR_FSOFF | SAI_XFRCR_FSDEF;\n\t\tbreak;\n\t \n\tcase SND_SOC_DAIFMT_MSB:\n\t\tfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSDEF;\n\t\tbreak;\n\t \n\tcase SND_SOC_DAIFMT_LSB:\n\t\tfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSDEF;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tfrcr |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSOFF;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tfrcr |= SAI_XFRCR_FSPOL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported protocol %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tcr1_mask |= SAI_XCR1_CKSTR;\n\tfrcr_mask |= SAI_XFRCR_FSPOL | SAI_XFRCR_FSOFF |\n\t\t     SAI_XFRCR_FSDEF;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tcr1 ^= SAI_XCR1_CKSTR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tfrcr ^= SAI_XFRCR_FSPOL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\tcr1 ^= SAI_XCR1_CKSTR;\n\t\tfrcr ^= SAI_XFRCR_FSPOL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported strobing %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_INV_MASK);\n\t\treturn -EINVAL;\n\t}\n\tcr1_mask |= SAI_XCR1_CKSTR;\n\tfrcr_mask |= SAI_XFRCR_FSPOL;\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_FRCR_REGX, frcr_mask, frcr);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tcr1 |= SAI_XCR1_SLAVE;\n\t\tsai->master = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tsai->master = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Unsupported mode %#x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (sai->sync) {\n\t\tdev_dbg(cpu_dai->dev, \"Synchronized SAI configured as slave\\n\");\n\t\tcr1 |= SAI_XCR1_SLAVE;\n\t\tsai->master = false;\n\t}\n\n\tcr1_mask |= SAI_XCR1_SLAVE;\n\nconf_update:\n\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX, cr1_mask, cr1);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"Failed to update CR1 register\\n\");\n\t\treturn ret;\n\t}\n\n\tsai->fmt = fmt;\n\n\treturn 0;\n}\n\nstatic int stm32_sai_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint imr, cr2, ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sai->irq_lock, flags);\n\tsai->substream = substream;\n\tspin_unlock_irqrestore(&sai->irq_lock, flags);\n\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\tsnd_pcm_hw_constraint_mask64(substream->runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t     SNDRV_PCM_FMTBIT_S32_LE);\n\t\tsnd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\t}\n\n\tret = clk_prepare_enable(sai->sai_ck);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"Failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tstm32_sai_sub_reg_wr(sai, STM_SAI_CLRFR_REGX,\n\t\t\t     SAI_XCLRFR_MASK, SAI_XCLRFR_MASK);\n\n\timr = SAI_XIMR_OVRUDRIE;\n\tif (STM_SAI_IS_CAPTURE(sai)) {\n\t\tstm32_sai_sub_reg_rd(sai, STM_SAI_CR2_REGX, &cr2);\n\t\tif (cr2 & SAI_XCR2_MUTECNT_MASK)\n\t\t\timr |= SAI_XIMR_MUTEDETIE;\n\t}\n\n\tif (sai->master)\n\t\timr |= SAI_XIMR_WCKCFGIE;\n\telse\n\t\timr |= SAI_XIMR_AFSDETIE | SAI_XIMR_LFSDETIE;\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_IMR_REGX,\n\t\t\t     SAI_XIMR_MASK, imr);\n\n\treturn 0;\n}\n\nstatic int stm32_sai_set_config(struct snd_soc_dai *cpu_dai,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint cr1, cr1_mask, ret;\n\n\t \n\tstm32_sai_sub_reg_wr(sai, STM_SAI_CR2_REGX,\n\t\t\t     SAI_XCR2_FFLUSH | SAI_XCR2_FTH_MASK,\n\t\t\t     SAI_XCR2_FFLUSH |\n\t\t\t     SAI_XCR2_FTH_SET(STM_SAI_FIFO_TH_HALF));\n\n\t \n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\tsai->spdif_frm_cnt = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tcr1_mask = SAI_XCR1_DS_MASK;\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tcr1 = SAI_XCR1_DS_SET(SAI_DATASIZE_8);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tcr1 = SAI_XCR1_DS_SET(SAI_DATASIZE_16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tcr1 = SAI_XCR1_DS_SET(SAI_DATASIZE_32);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dai->dev, \"Data format not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcr1_mask |= SAI_XCR1_MONO;\n\tif ((sai->slots == 2) && (params_channels(params) == 1))\n\t\tcr1 |= SAI_XCR1_MONO;\n\n\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX, cr1_mask, cr1);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dai->dev, \"Failed to update CR1 register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_sai_set_slots(struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint slotr, slot_sz;\n\n\tstm32_sai_sub_reg_rd(sai, STM_SAI_SLOTR_REGX, &slotr);\n\n\t \n\tslot_sz = slotr & SAI_XSLOTR_SLOTSZ_MASK;\n\tif (slot_sz == SAI_XSLOTR_SLOTSZ_SET(SAI_SLOT_SIZE_AUTO))\n\t\tsai->slot_width = sai->data_size;\n\n\tif (sai->slot_width < sai->data_size) {\n\t\tdev_err(cpu_dai->dev,\n\t\t\t\"Data size %d larger than slot width\\n\",\n\t\t\tsai->data_size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!sai->slots)\n\t\tsai->slots = 2;\n\n\t \n\tstm32_sai_sub_reg_up(sai, STM_SAI_SLOTR_REGX,\n\t\t\t     SAI_XSLOTR_NBSLOT_MASK,\n\t\t\t     SAI_XSLOTR_NBSLOT_SET((sai->slots - 1)));\n\n\t \n\tif (!(slotr & SAI_XSLOTR_SLOTEN_MASK)) {\n\t\tsai->slot_mask = (1 << sai->slots) - 1;\n\t\tstm32_sai_sub_reg_up(sai,\n\t\t\t\t     STM_SAI_SLOTR_REGX, SAI_XSLOTR_SLOTEN_MASK,\n\t\t\t\t     SAI_XSLOTR_SLOTEN_SET(sai->slot_mask));\n\t}\n\n\tdev_dbg(cpu_dai->dev, \"Slots %d, slot width %d\\n\",\n\t\tsai->slots, sai->slot_width);\n\n\treturn 0;\n}\n\nstatic void stm32_sai_set_frame(struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint fs_active, offset, format;\n\tint frcr, frcr_mask;\n\n\tformat = sai->fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\tsai->fs_length = sai->slot_width * sai->slots;\n\n\tfs_active = sai->fs_length / 2;\n\tif ((format == SND_SOC_DAIFMT_DSP_A) ||\n\t    (format == SND_SOC_DAIFMT_DSP_B))\n\t\tfs_active = 1;\n\n\tfrcr = SAI_XFRCR_FRL_SET((sai->fs_length - 1));\n\tfrcr |= SAI_XFRCR_FSALL_SET((fs_active - 1));\n\tfrcr_mask = SAI_XFRCR_FRL_MASK | SAI_XFRCR_FSALL_MASK;\n\n\tdev_dbg(cpu_dai->dev, \"Frame length %d, frame active %d\\n\",\n\t\tsai->fs_length, fs_active);\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_FRCR_REGX, frcr_mask, frcr);\n\n\tif ((sai->fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_LSB) {\n\t\toffset = sai->slot_width - sai->data_size;\n\n\t\tstm32_sai_sub_reg_up(sai, STM_SAI_SLOTR_REGX,\n\t\t\t\t     SAI_XSLOTR_FBOFF_MASK,\n\t\t\t\t     SAI_XSLOTR_FBOFF_SET(offset));\n\t}\n}\n\nstatic void stm32_sai_init_iec958_status(struct stm32_sai_sub_data *sai)\n{\n\tunsigned char *cs = sai->iec958.status;\n\n\tcs[0] = IEC958_AES0_CON_NOT_COPYRIGHT | IEC958_AES0_CON_EMPHASIS_NONE;\n\tcs[1] = IEC958_AES1_CON_GENERAL;\n\tcs[2] = IEC958_AES2_CON_SOURCE_UNSPEC | IEC958_AES2_CON_CHANNEL_UNSPEC;\n\tcs[3] = IEC958_AES3_CON_CLOCK_1000PPM | IEC958_AES3_CON_FS_NOTID;\n}\n\nstatic void stm32_sai_set_iec958_status(struct stm32_sai_sub_data *sai,\n\t\t\t\t\tstruct snd_pcm_runtime *runtime)\n{\n\tif (!runtime)\n\t\treturn;\n\n\t \n\tmutex_lock(&sai->ctrl_lock);\n\tswitch (runtime->rate) {\n\tcase 22050:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_22050;\n\t\tbreak;\n\tcase 44100:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 88200:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 176400:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 24000:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_24000;\n\t\tbreak;\n\tcase 48000:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 96000:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 192000:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tcase 32000:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tdefault:\n\t\tsai->iec958.status[3] = IEC958_AES3_CON_FS_NOTID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&sai->ctrl_lock);\n}\n\nstatic int stm32_sai_configure_clock(struct snd_soc_dai *cpu_dai,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint div = 0, cr1 = 0;\n\tint sai_clk_rate, mclk_ratio, den;\n\tunsigned int rate = params_rate(params);\n\tint ret;\n\n\tif (!sai->sai_mclk) {\n\t\tret = stm32_sai_set_parent_clock(sai, rate);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsai_clk_rate = clk_get_rate(sai->sai_ck);\n\n\tif (STM_SAI_IS_F4(sai->pdata)) {\n\t\t \n\t\tif (!sai->mclk_rate)\n\t\t\treturn 0;\n\n\t\tif (2 * sai_clk_rate >= 3 * sai->mclk_rate) {\n\t\t\tdiv = stm32_sai_get_clk_div(sai, sai_clk_rate,\n\t\t\t\t\t\t    2 * sai->mclk_rate);\n\t\t\tif (div < 0)\n\t\t\t\treturn div;\n\t\t}\n\t} else {\n\t\t \n\t\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\t\tdiv = stm32_sai_get_clk_div(sai, sai_clk_rate,\n\t\t\t\t\t\t    rate * 128);\n\t\t\tif (div < 0)\n\t\t\t\treturn div;\n\t\t} else {\n\t\t\tif (sai->mclk_rate) {\n\t\t\t\tmclk_ratio = sai->mclk_rate / rate;\n\t\t\t\tif (mclk_ratio == 512) {\n\t\t\t\t\tcr1 = SAI_XCR1_OSR;\n\t\t\t\t} else if (mclk_ratio != 256) {\n\t\t\t\t\tdev_err(cpu_dai->dev,\n\t\t\t\t\t\t\"Wrong mclk ratio %d\\n\",\n\t\t\t\t\t\tmclk_ratio);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tstm32_sai_sub_reg_up(sai,\n\t\t\t\t\t\t     STM_SAI_CR1_REGX,\n\t\t\t\t\t\t     SAI_XCR1_OSR, cr1);\n\n\t\t\t\tdiv = stm32_sai_get_clk_div(sai, sai_clk_rate,\n\t\t\t\t\t\t\t    sai->mclk_rate);\n\t\t\t\tif (div < 0)\n\t\t\t\t\treturn div;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tden = sai->fs_length * params_rate(params);\n\t\t\t\tdiv = stm32_sai_get_clk_div(sai, sai_clk_rate,\n\t\t\t\t\t\t\t    den);\n\t\t\t\tif (div < 0)\n\t\t\t\t\treturn div;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stm32_sai_set_clk_div(sai, div);\n}\n\nstatic int stm32_sai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tsai->data_size = params_width(params);\n\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\t \n\t\tsubstream->runtime->rate = params_rate(params);\n\t\tstm32_sai_set_iec958_status(sai, substream->runtime);\n\t} else {\n\t\tret = stm32_sai_set_slots(cpu_dai);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tstm32_sai_set_frame(cpu_dai);\n\t}\n\n\tret = stm32_sai_set_config(cpu_dai, substream, params);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sai->master)\n\t\tret = stm32_sai_configure_clock(cpu_dai, params);\n\n\treturn ret;\n}\n\nstatic int stm32_sai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdev_dbg(cpu_dai->dev, \"Enable DMA and SAI\\n\");\n\n\t\tstm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t     SAI_XCR1_DMAEN, SAI_XCR1_DMAEN);\n\n\t\t \n\t\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t\t   SAI_XCR1_SAIEN, SAI_XCR1_SAIEN);\n\t\tif (ret < 0)\n\t\t\tdev_err(cpu_dai->dev, \"Failed to update CR1 register\\n\");\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(cpu_dai->dev, \"Disable DMA and SAI\\n\");\n\n\t\tstm32_sai_sub_reg_up(sai, STM_SAI_IMR_REGX,\n\t\t\t\t     SAI_XIMR_MASK, 0);\n\n\t\tstm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t     SAI_XCR1_SAIEN,\n\t\t\t\t     (unsigned int)~SAI_XCR1_SAIEN);\n\n\t\tret = stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX,\n\t\t\t\t\t   SAI_XCR1_DMAEN,\n\t\t\t\t\t   (unsigned int)~SAI_XCR1_DMAEN);\n\t\tif (ret < 0)\n\t\t\tdev_err(cpu_dai->dev, \"Failed to update CR1 register\\n\");\n\n\t\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai))\n\t\t\tsai->spdif_frm_cnt = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void stm32_sai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long flags;\n\n\tstm32_sai_sub_reg_up(sai, STM_SAI_IMR_REGX, SAI_XIMR_MASK, 0);\n\n\tclk_disable_unprepare(sai->sai_ck);\n\n\tspin_lock_irqsave(&sai->irq_lock, flags);\n\tsai->substream = NULL;\n\tspin_unlock_irqrestore(&sai->irq_lock, flags);\n}\n\nstatic int stm32_sai_pcm_new(struct snd_soc_pcm_runtime *rtd,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(cpu_dai->dev);\n\tstruct snd_kcontrol_new knew = iec958_ctls;\n\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai)) {\n\t\tdev_dbg(&sai->pdev->dev, \"%s: register iec controls\", __func__);\n\t\tknew.device = rtd->pcm->device;\n\t\treturn snd_ctl_add(rtd->pcm->card, snd_ctl_new1(&knew, sai));\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_sai_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(cpu_dai->dev);\n\tint cr1 = 0, cr1_mask, ret;\n\n\tsai->cpu_dai = cpu_dai;\n\n\tsai->dma_params.addr = (dma_addr_t)(sai->phys_addr + STM_SAI_DR_REGX);\n\t \n\tsai->dma_params.maxburst = 4;\n\tif (sai->pdata->conf.fifo_size < 8)\n\t\tsai->dma_params.maxburst = 1;\n\t \n\tsai->dma_params.addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;\n\n\tif (STM_SAI_IS_PLAYBACK(sai))\n\t\tsnd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params, NULL);\n\telse\n\t\tsnd_soc_dai_init_dma_data(cpu_dai, NULL, &sai->dma_params);\n\n\t \n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai))\n\t\treturn 0;\n\n\tcr1_mask = SAI_XCR1_RX_TX;\n\tif (STM_SAI_IS_CAPTURE(sai))\n\t\tcr1 |= SAI_XCR1_RX_TX;\n\n\t \n\tif (sai->sync == SAI_SYNC_EXTERNAL) {\n\t\t \n\t\tret = sai->pdata->set_sync(sai->pdata, sai->np_sync_provider,\n\t\t\t\t\t   sai->synco, sai->synci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcr1_mask |= SAI_XCR1_SYNCEN_MASK;\n\tcr1 |= SAI_XCR1_SYNCEN_SET(sai->sync);\n\n\treturn stm32_sai_sub_reg_up(sai, STM_SAI_CR1_REGX, cr1_mask, cr1);\n}\n\nstatic const struct snd_soc_dai_ops stm32_sai_pcm_dai_ops = {\n\t.probe\t\t= stm32_sai_dai_probe,\n\t.set_sysclk\t= stm32_sai_set_sysclk,\n\t.set_fmt\t= stm32_sai_set_dai_fmt,\n\t.set_tdm_slot\t= stm32_sai_set_dai_tdm_slot,\n\t.startup\t= stm32_sai_startup,\n\t.hw_params\t= stm32_sai_hw_params,\n\t.trigger\t= stm32_sai_trigger,\n\t.shutdown\t= stm32_sai_shutdown,\n\t.pcm_new\t= stm32_sai_pcm_new,\n};\n\nstatic const struct snd_soc_dai_ops stm32_sai_pcm_dai_ops2 = {\n\t.probe\t\t= stm32_sai_dai_probe,\n\t.set_sysclk\t= stm32_sai_set_sysclk,\n\t.set_fmt\t= stm32_sai_set_dai_fmt,\n\t.set_tdm_slot\t= stm32_sai_set_dai_tdm_slot,\n\t.startup\t= stm32_sai_startup,\n\t.hw_params\t= stm32_sai_hw_params,\n\t.trigger\t= stm32_sai_trigger,\n\t.shutdown\t= stm32_sai_shutdown,\n};\n\nstatic int stm32_sai_pcm_process_spdif(struct snd_pcm_substream *substream,\n\t\t\t\t       int channel, unsigned long hwoff,\n\t\t\t\t       unsigned long bytes)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(cpu_dai->dev);\n\tint *ptr = (int *)(runtime->dma_area + hwoff +\n\t\t\t   channel * (runtime->dma_bytes / runtime->channels));\n\tssize_t cnt = bytes_to_samples(runtime, bytes);\n\tunsigned int frm_cnt = sai->spdif_frm_cnt;\n\tunsigned int byte;\n\tunsigned int mask;\n\n\tdo {\n\t\t*ptr = ((*ptr >> 8) & 0x00ffffff);\n\n\t\t \n\t\tbyte = frm_cnt >> 3;\n\t\tmask = 1 << (frm_cnt - (byte << 3));\n\t\tif (sai->iec958.status[byte] & mask)\n\t\t\t*ptr |= 0x04000000;\n\t\tptr++;\n\n\t\tif (!(cnt % 2))\n\t\t\tfrm_cnt++;\n\n\t\tif (frm_cnt == SAI_IEC60958_BLOCK_FRAMES)\n\t\t\tfrm_cnt = 0;\n\t} while (--cnt);\n\tsai->spdif_frm_cnt = frm_cnt;\n\n\treturn 0;\n}\n\n \nstatic const struct snd_pcm_hardware stm32_sai_pcm_hw_spdif = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED,\n\t.buffer_bytes_max = 8 * PAGE_SIZE,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = PAGE_SIZE,\n\t.periods_min = 2,\n\t.periods_max = 8,\n};\n\nstatic const struct snd_pcm_hardware stm32_sai_pcm_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP,\n\t.buffer_bytes_max = 8 * PAGE_SIZE,\n\t.period_bytes_min = 1024,  \n\t.period_bytes_max = PAGE_SIZE,\n\t.periods_min = 2,\n\t.periods_max = 8,\n};\n\nstatic struct snd_soc_dai_driver stm32_sai_playback_dai = {\n\t\t.id = 1,  \n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 192000,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t \n\t\t\t.formats =\n\t\t\t\tSNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &stm32_sai_pcm_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver stm32_sai_capture_dai = {\n\t\t.id = 1,  \n\t\t.capture = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 16,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 192000,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t \n\t\t\t.formats =\n\t\t\t\tSNDRV_PCM_FMTBIT_S8 |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &stm32_sai_pcm_dai_ops2,\n};\n\nstatic const struct snd_dmaengine_pcm_config stm32_sai_pcm_config = {\n\t.pcm_hardware = &stm32_sai_pcm_hw,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n};\n\nstatic const struct snd_dmaengine_pcm_config stm32_sai_pcm_config_spdif = {\n\t.pcm_hardware = &stm32_sai_pcm_hw_spdif,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n\t.process = stm32_sai_pcm_process_spdif,\n};\n\nstatic const struct snd_soc_component_driver stm32_component = {\n\t.name = \"stm32-sai\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct of_device_id stm32_sai_sub_ids[] = {\n\t{ .compatible = \"st,stm32-sai-sub-a\",\n\t  .data = (void *)STM_SAI_A_ID},\n\t{ .compatible = \"st,stm32-sai-sub-b\",\n\t  .data = (void *)STM_SAI_B_ID},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, stm32_sai_sub_ids);\n\nstatic int stm32_sai_sub_parse_of(struct platform_device *pdev,\n\t\t\t\t  struct stm32_sai_sub_data *sai)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tstruct of_phandle_args args;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tsai->phys_addr = res->start;\n\n\tsai->regmap_config = &stm32_sai_sub_regmap_config_f4;\n\t \n\tif (STM_SAI_HAS_PDM(sai) && STM_SAI_IS_SUB_A(sai))\n\t\tsai->regmap_config = &stm32_sai_sub_regmap_config_h7;\n\n\t \n\tsai->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t    sai->regmap_config);\n\tif (IS_ERR(sai->regmap))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sai->regmap),\n\t\t\t\t     \"Regmap init error\\n\");\n\n\t \n\tif (of_property_match_string(np, \"dma-names\", \"tx\") >= 0) {\n\t\tsai->dir = SNDRV_PCM_STREAM_PLAYBACK;\n\t} else if (of_property_match_string(np, \"dma-names\", \"rx\") >= 0) {\n\t\tsai->dir = SNDRV_PCM_STREAM_CAPTURE;\n\t} else {\n\t\tdev_err(&pdev->dev, \"Unsupported direction\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsai->spdif = false;\n\tif (of_property_present(np, \"st,iec60958\")) {\n\t\tif (!STM_SAI_HAS_SPDIF(sai) ||\n\t\t    sai->dir == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tdev_err(&pdev->dev, \"S/PDIF IEC60958 not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstm32_sai_init_iec958_status(sai);\n\t\tsai->spdif = true;\n\t\tsai->master = true;\n\t}\n\n\t \n\targs.np = NULL;\n\tret = of_parse_phandle_with_fixed_args(np, \"st,sync\", 1, 0, &args);\n\tif (ret < 0  && ret != -ENOENT) {\n\t\tdev_err(&pdev->dev, \"Failed to get st,sync property\\n\");\n\t\treturn ret;\n\t}\n\n\tsai->sync = SAI_SYNC_NONE;\n\tif (args.np) {\n\t\tif (args.np == np) {\n\t\t\tdev_err(&pdev->dev, \"%pOFn sync own reference\\n\", np);\n\t\t\tof_node_put(args.np);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsai->np_sync_provider  = of_get_parent(args.np);\n\t\tif (!sai->np_sync_provider) {\n\t\t\tdev_err(&pdev->dev, \"%pOFn parent node not found\\n\",\n\t\t\t\tnp);\n\t\t\tof_node_put(args.np);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsai->sync = SAI_SYNC_INTERNAL;\n\t\tif (sai->np_sync_provider != sai->pdata->pdev->dev.of_node) {\n\t\t\tif (!STM_SAI_HAS_EXT_SYNC(sai)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"External synchro not supported\\n\");\n\t\t\t\tof_node_put(args.np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsai->sync = SAI_SYNC_EXTERNAL;\n\n\t\t\tsai->synci = args.args[0];\n\t\t\tif (sai->synci < 1 ||\n\t\t\t    (sai->synci > (SAI_GCR_SYNCIN_MAX + 1))) {\n\t\t\t\tdev_err(&pdev->dev, \"Wrong SAI index\\n\");\n\t\t\t\tof_node_put(args.np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (of_property_match_string(args.np, \"compatible\",\n\t\t\t\t\t\t     \"st,stm32-sai-sub-a\") >= 0)\n\t\t\t\tsai->synco = STM_SAI_SYNC_OUT_A;\n\n\t\t\tif (of_property_match_string(args.np, \"compatible\",\n\t\t\t\t\t\t     \"st,stm32-sai-sub-b\") >= 0)\n\t\t\t\tsai->synco = STM_SAI_SYNC_OUT_B;\n\n\t\t\tif (!sai->synco) {\n\t\t\t\tdev_err(&pdev->dev, \"Unknown SAI sub-block\\n\");\n\t\t\t\tof_node_put(args.np);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&pdev->dev, \"%s synchronized with %s\\n\",\n\t\t\tpdev->name, args.np->full_name);\n\t}\n\n\tof_node_put(args.np);\n\tsai->sai_ck = devm_clk_get(&pdev->dev, \"sai_ck\");\n\tif (IS_ERR(sai->sai_ck))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(sai->sai_ck),\n\t\t\t\t     \"Missing kernel clock sai_ck\\n\");\n\n\tret = clk_prepare(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (STM_SAI_IS_F4(sai->pdata))\n\t\treturn 0;\n\n\t \n\tif (of_property_present(np, \"#clock-cells\")) {\n\t\tret = stm32_sai_add_mclk_provider(sai);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tsai->sai_mclk = devm_clk_get_optional(&pdev->dev, \"MCLK\");\n\t\tif (IS_ERR(sai->sai_mclk))\n\t\t\treturn PTR_ERR(sai->sai_mclk);\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_sai_sub_probe(struct platform_device *pdev)\n{\n\tstruct stm32_sai_sub_data *sai;\n\tconst struct of_device_id *of_id;\n\tconst struct snd_dmaengine_pcm_config *conf = &stm32_sai_pcm_config;\n\tint ret;\n\n\tsai = devm_kzalloc(&pdev->dev, sizeof(*sai), GFP_KERNEL);\n\tif (!sai)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(stm32_sai_sub_ids, &pdev->dev);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\tsai->id = (uintptr_t)of_id->data;\n\n\tsai->pdev = pdev;\n\tmutex_init(&sai->ctrl_lock);\n\tspin_lock_init(&sai->irq_lock);\n\tplatform_set_drvdata(pdev, sai);\n\n\tsai->pdata = dev_get_drvdata(pdev->dev.parent);\n\tif (!sai->pdata) {\n\t\tdev_err(&pdev->dev, \"Parent device data not available\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = stm32_sai_sub_parse_of(pdev, sai);\n\tif (ret)\n\t\treturn ret;\n\n\tif (STM_SAI_IS_PLAYBACK(sai))\n\t\tsai->cpu_dai_drv = stm32_sai_playback_dai;\n\telse\n\t\tsai->cpu_dai_drv = stm32_sai_capture_dai;\n\tsai->cpu_dai_drv.name = dev_name(&pdev->dev);\n\n\tret = devm_request_irq(&pdev->dev, sai->pdata->irq, stm32_sai_isr,\n\t\t\t       IRQF_SHARED, dev_name(&pdev->dev), sai);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IRQ request returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (STM_SAI_PROTOCOL_IS_SPDIF(sai))\n\t\tconf = &stm32_sai_pcm_config_spdif;\n\n\tret = snd_dmaengine_pcm_register(&pdev->dev, conf, 0);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"Could not register pcm dma\\n\");\n\n\tret = snd_soc_register_component(&pdev->dev, &stm32_component,\n\t\t\t\t\t &sai->cpu_dai_drv, 1);\n\tif (ret) {\n\t\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void stm32_sai_sub_remove(struct platform_device *pdev)\n{\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(&pdev->dev);\n\n\tclk_unprepare(sai->pdata->pclk);\n\tsnd_dmaengine_pcm_unregister(&pdev->dev);\n\tsnd_soc_unregister_component(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int stm32_sai_sub_suspend(struct device *dev)\n{\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_cache_only(sai->regmap, true);\n\tregcache_mark_dirty(sai->regmap);\n\n\tclk_disable(sai->pdata->pclk);\n\n\treturn 0;\n}\n\nstatic int stm32_sai_sub_resume(struct device *dev)\n{\n\tstruct stm32_sai_sub_data *sai = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(sai->pdata->pclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_cache_only(sai->regmap, false);\n\tret = regcache_sync(sai->regmap);\n\n\tclk_disable(sai->pdata->pclk);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct dev_pm_ops stm32_sai_sub_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stm32_sai_sub_suspend, stm32_sai_sub_resume)\n};\n\nstatic struct platform_driver stm32_sai_sub_driver = {\n\t.driver = {\n\t\t.name = \"st,stm32-sai-sub\",\n\t\t.of_match_table = stm32_sai_sub_ids,\n\t\t.pm = &stm32_sai_sub_pm_ops,\n\t},\n\t.probe = stm32_sai_sub_probe,\n\t.remove_new = stm32_sai_sub_remove,\n};\n\nmodule_platform_driver(stm32_sai_sub_driver);\n\nMODULE_DESCRIPTION(\"STM32 Soc SAI sub-block Interface\");\nMODULE_AUTHOR(\"Olivier Moysan <olivier.moysan@st.com>\");\nMODULE_ALIAS(\"platform:st,stm32-sai-sub\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}