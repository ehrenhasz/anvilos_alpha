{
  "module_name": "jh7110_tdm.c",
  "hash_id": "b3f29038f9c26892f86f0a819d81ad93886194b80043198c54ea4f5af393b547",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/starfive/jh7110_tdm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/types.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#define TDM_PCMGBCR\t\t\t0x00\n\t#define PCMGBCR_ENABLE\t\tBIT(0)\n\t#define CLKPOL_BIT\t\t5\n\t#define ELM_BIT\t\t\t3\n\t#define SYNCM_BIT\t\t2\n\t#define MS_BIT\t\t\t1\n#define TDM_PCMTXCR\t\t\t0x04\n\t#define PCMTXCR_TXEN\t\tBIT(0)\n\t#define IFL_BIT\t\t\t11\n\t#define WL_BIT\t\t\t8\n\t#define SSCALE_BIT\t\t4\n\t#define SL_BIT\t\t\t2\n\t#define LRJ_BIT\t\t\t1\n#define TDM_PCMRXCR\t\t\t0x08\n\t#define PCMRXCR_RXEN\t\tBIT(0)\n#define TDM_PCMDIV\t\t\t0x0c\n\n#define JH7110_TDM_FIFO\t\t\t0x170c0000\n#define JH7110_TDM_FIFO_DEPTH\t\t32\n\nenum TDM_MASTER_SLAVE_MODE {\n\tTDM_AS_MASTER = 0,\n\tTDM_AS_SLAVE,\n};\n\nenum TDM_CLKPOL {\n\t \n\tTDM_TX_RASING_RX_FALLING = 0,\n\t \n\tTDM_TX_FALLING_RX_RASING,\n};\n\nenum TDM_ELM {\n\t \n\tTDM_ELM_LATE = 0,\n\tTDM_ELM_EARLY,\n};\n\nenum TDM_SYNCM {\n\t \n\tTDM_SYNCM_SHORT = 0,\n\t \n\tTDM_SYNCM_LONG,\n};\n\nenum TDM_IFL {\n\t \n\tTDM_FIFO_HALF = 0,\n\tTDM_FIFO_QUARTER,\n};\n\nenum TDM_WL {\n\t \n\tTDM_8BIT_WORD_LEN = 0,\n\tTDM_16BIT_WORD_LEN,\n\tTDM_20BIT_WORD_LEN,\n\tTDM_24BIT_WORD_LEN,\n\tTDM_32BIT_WORD_LEN,\n};\n\nenum TDM_SL {\n\t \n\tTDM_8BIT_SLOT_LEN = 0,\n\tTDM_16BIT_SLOT_LEN,\n\tTDM_32BIT_SLOT_LEN,\n};\n\nenum TDM_LRJ {\n\t \n\tTDM_RIGHT_JUSTIFY = 0,\n\tTDM_LEFT_JUSTIFT,\n};\n\nstruct tdm_chan_cfg {\n\tenum TDM_IFL ifl;\n\tenum TDM_WL  wl;\n\tunsigned char sscale;\n\tenum TDM_SL  sl;\n\tenum TDM_LRJ lrj;\n\tunsigned char enable;\n};\n\nstruct jh7110_tdm_dev {\n\tvoid __iomem *tdm_base;\n\tstruct device *dev;\n\tstruct clk_bulk_data clks[6];\n\tstruct reset_control *resets;\n\n\tenum TDM_CLKPOL clkpolity;\n\tenum TDM_ELM\telm;\n\tenum TDM_SYNCM\tsyncm;\n\tenum TDM_MASTER_SLAVE_MODE ms_mode;\n\n\tstruct tdm_chan_cfg tx;\n\tstruct tdm_chan_cfg rx;\n\n\tu16 syncdiv;\n\tu32 samplerate;\n\tu32 pcmclk;\n\n\t \n\tstruct snd_dmaengine_dai_dma_data play_dma_data;\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tu32 saved_pcmgbcr;\n\tu32 saved_pcmtxcr;\n\tu32 saved_pcmrxcr;\n\tu32 saved_pcmdiv;\n};\n\nstatic inline u32 jh7110_tdm_readl(struct jh7110_tdm_dev *tdm, u16 reg)\n{\n\treturn readl_relaxed(tdm->tdm_base + reg);\n}\n\nstatic inline void jh7110_tdm_writel(struct jh7110_tdm_dev *tdm, u16 reg, u32 val)\n{\n\twritel_relaxed(val, tdm->tdm_base + reg);\n}\n\nstatic void jh7110_tdm_save_context(struct jh7110_tdm_dev *tdm,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\ttdm->saved_pcmtxcr = jh7110_tdm_readl(tdm, TDM_PCMTXCR);\n\telse\n\t\ttdm->saved_pcmrxcr = jh7110_tdm_readl(tdm, TDM_PCMRXCR);\n}\n\nstatic void jh7110_tdm_start(struct jh7110_tdm_dev *tdm,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tu32 data;\n\n\tdata = jh7110_tdm_readl(tdm, TDM_PCMGBCR);\n\tjh7110_tdm_writel(tdm, TDM_PCMGBCR, data | PCMGBCR_ENABLE);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tjh7110_tdm_writel(tdm, TDM_PCMTXCR, tdm->saved_pcmtxcr | PCMTXCR_TXEN);\n\telse\n\t\tjh7110_tdm_writel(tdm, TDM_PCMRXCR, tdm->saved_pcmrxcr | PCMRXCR_RXEN);\n}\n\nstatic void jh7110_tdm_stop(struct jh7110_tdm_dev *tdm,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tunsigned int val;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tval = jh7110_tdm_readl(tdm, TDM_PCMTXCR);\n\t\tval &= ~PCMTXCR_TXEN;\n\t\tjh7110_tdm_writel(tdm, TDM_PCMTXCR, val);\n\t} else {\n\t\tval = jh7110_tdm_readl(tdm, TDM_PCMRXCR);\n\t\tval &= ~PCMRXCR_RXEN;\n\t\tjh7110_tdm_writel(tdm, TDM_PCMRXCR, val);\n\t}\n}\n\nstatic int jh7110_tdm_syncdiv(struct jh7110_tdm_dev *tdm)\n{\n\tu32 sl, sscale, syncdiv;\n\n\tif (tdm->rx.sl >= tdm->tx.sl)\n\t\tsl = tdm->rx.sl;\n\telse\n\t\tsl = tdm->tx.sl;\n\n\tif (tdm->rx.sscale >= tdm->tx.sscale)\n\t\tsscale = tdm->rx.sscale;\n\telse\n\t\tsscale = tdm->tx.sscale;\n\n\tsyncdiv = tdm->pcmclk / tdm->samplerate - 1;\n\n\tif ((syncdiv + 1) < (sl * sscale)) {\n\t\tdev_err(tdm->dev, \"Failed to set syncdiv!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tdm->syncm == TDM_SYNCM_LONG &&\n\t    (tdm->rx.sscale <= 1 || tdm->tx.sscale <= 1) &&\n\t    ((syncdiv + 1) <= sl)) {\n\t\tdev_err(tdm->dev, \"Wrong syncdiv! It must be (syncdiv+1) > max[tx.sl, rx.sl]\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tjh7110_tdm_writel(tdm, TDM_PCMDIV, syncdiv);\n\treturn 0;\n}\n\nstatic int jh7110_tdm_config(struct jh7110_tdm_dev *tdm,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tu32 datarx, datatx;\n\tint ret;\n\n\tret = jh7110_tdm_syncdiv(tdm);\n\tif (ret)\n\t\treturn ret;\n\n\tdatarx = (tdm->rx.ifl << IFL_BIT) |\n\t\t  (tdm->rx.wl << WL_BIT) |\n\t\t  (tdm->rx.sscale << SSCALE_BIT) |\n\t\t  (tdm->rx.sl << SL_BIT) |\n\t\t  (tdm->rx.lrj << LRJ_BIT);\n\n\tdatatx = (tdm->tx.ifl << IFL_BIT) |\n\t\t  (tdm->tx.wl << WL_BIT) |\n\t\t  (tdm->tx.sscale << SSCALE_BIT) |\n\t\t  (tdm->tx.sl << SL_BIT) |\n\t\t  (tdm->tx.lrj << LRJ_BIT);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tjh7110_tdm_writel(tdm, TDM_PCMTXCR, datatx);\n\telse\n\t\tjh7110_tdm_writel(tdm, TDM_PCMRXCR, datarx);\n\n\treturn 0;\n}\n\nstatic void jh7110_tdm_clk_disable(struct jh7110_tdm_dev *tdm)\n{\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(tdm->clks), tdm->clks);\n}\n\nstatic int jh7110_tdm_clk_enable(struct jh7110_tdm_dev *tdm)\n{\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(tdm->clks), tdm->clks);\n\tif (ret) {\n\t\tdev_err(tdm->dev, \"Failed to enable tdm clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(tdm->resets);\n\tif (ret) {\n\t\tdev_err(tdm->dev, \"Failed to deassert tdm resets\\n\");\n\t\tgoto dis_tdm_clk;\n\t}\n\n\t \n\tret = clk_set_parent(tdm->clks[5].clk, tdm->clks[4].clk);\n\tif (ret) {\n\t\tdev_err(tdm->dev, \"Can't set extern clock source for clk_tdm\\n\");\n\t\tgoto dis_tdm_clk;\n\t}\n\n\treturn 0;\n\ndis_tdm_clk:\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(tdm->clks), tdm->clks);\n\n\treturn ret;\n}\n\nstatic int jh7110_tdm_runtime_suspend(struct device *dev)\n{\n\tstruct jh7110_tdm_dev *tdm = dev_get_drvdata(dev);\n\n\tjh7110_tdm_clk_disable(tdm);\n\treturn 0;\n}\n\nstatic int jh7110_tdm_runtime_resume(struct device *dev)\n{\n\tstruct jh7110_tdm_dev *tdm = dev_get_drvdata(dev);\n\n\treturn jh7110_tdm_clk_enable(tdm);\n}\n\nstatic int jh7110_tdm_system_suspend(struct device *dev)\n{\n\tstruct jh7110_tdm_dev *tdm = dev_get_drvdata(dev);\n\n\t \n\ttdm->saved_pcmgbcr = jh7110_tdm_readl(tdm, TDM_PCMGBCR);\n\ttdm->saved_pcmdiv = jh7110_tdm_readl(tdm, TDM_PCMDIV);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int jh7110_tdm_system_resume(struct device *dev)\n{\n\tstruct jh7110_tdm_dev *tdm = dev_get_drvdata(dev);\n\n\t \n\tjh7110_tdm_writel(tdm, TDM_PCMGBCR, tdm->saved_pcmgbcr);\n\tjh7110_tdm_writel(tdm, TDM_PCMDIV, tdm->saved_pcmdiv);\n\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic const struct snd_soc_component_driver jh7110_tdm_component = {\n\t.name = \"jh7110-tdm\",\n};\n\nstatic int jh7110_tdm_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\n\tdai_link->trigger_stop = SND_SOC_TRIGGER_ORDER_LDC;\n\n\treturn 0;\n}\n\nstatic int jh7110_tdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct jh7110_tdm_dev *tdm = snd_soc_dai_get_drvdata(dai);\n\tint chan_wl, chan_sl, chan_nr;\n\tunsigned int data_width;\n\tunsigned int dma_bus_width;\n\tstruct snd_dmaengine_dai_dma_data *dma_data = NULL;\n\tint ret;\n\n\tdata_width = params_width(params);\n\n\ttdm->samplerate = params_rate(params);\n\ttdm->pcmclk = params_channels(params) * tdm->samplerate * data_width;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tchan_wl = TDM_16BIT_WORD_LEN;\n\t\tchan_sl = TDM_16BIT_SLOT_LEN;\n\t\tdma_bus_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tchan_wl = TDM_32BIT_WORD_LEN;\n\t\tchan_sl = TDM_32BIT_SLOT_LEN;\n\t\tdma_bus_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(tdm->dev, \"tdm: unsupported PCM fmt\");\n\t\treturn -EINVAL;\n\t}\n\n\tchan_nr = params_channels(params);\n\tswitch (chan_nr) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tdm->dev, \"channel not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\ttdm->tx.wl = chan_wl;\n\t\ttdm->tx.sl = chan_sl;\n\t\ttdm->tx.sscale = chan_nr;\n\t\ttdm->play_dma_data.addr_width = dma_bus_width;\n\t\tdma_data = &tdm->play_dma_data;\n\t} else {\n\t\ttdm->rx.wl = chan_wl;\n\t\ttdm->rx.sl = chan_sl;\n\t\ttdm->rx.sscale = chan_nr;\n\t\ttdm->capture_dma_data.addr_width = dma_bus_width;\n\t\tdma_data = &tdm->capture_dma_data;\n\t}\n\n\tsnd_soc_dai_set_dma_data(dai, substream, dma_data);\n\n\tret = jh7110_tdm_config(tdm, substream);\n\tif (ret)\n\t\treturn ret;\n\n\tjh7110_tdm_save_context(tdm, substream);\n\treturn 0;\n}\n\nstatic int jh7110_tdm_trigger(struct snd_pcm_substream *substream,\n\t\t\t      int cmd, struct snd_soc_dai *dai)\n{\n\tstruct jh7110_tdm_dev *tdm = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tjh7110_tdm_start(tdm, substream);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tjh7110_tdm_stop(tdm, substream);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int jh7110_tdm_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct jh7110_tdm_dev *tdm = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int gbcr;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\ttdm->ms_mode = TDM_AS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\ttdm->ms_mode = TDM_AS_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdev_dbg(tdm->dev, \"dwc : Invalid clock provider format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgbcr = (tdm->clkpolity << CLKPOL_BIT) |\n\t\t(tdm->elm << ELM_BIT) |\n\t\t(tdm->syncm << SYNCM_BIT) |\n\t\t(tdm->ms_mode << MS_BIT);\n\tjh7110_tdm_writel(tdm, TDM_PCMGBCR, gbcr);\n\n\treturn 0;\n}\n\nstatic int jh7110_tdm_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct jh7110_tdm_dev *tdm = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &tdm->play_dma_data, &tdm->capture_dma_data);\n\tsnd_soc_dai_set_drvdata(dai, tdm);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops jh7110_tdm_dai_ops = {\n\t.probe\t\t= jh7110_tdm_dai_probe,\n\t.startup\t= jh7110_tdm_startup,\n\t.hw_params\t= jh7110_tdm_hw_params,\n\t.trigger\t= jh7110_tdm_trigger,\n\t.set_fmt\t= jh7110_tdm_set_dai_fmt,\n};\n\n#define JH7110_TDM_RATES\tSNDRV_PCM_RATE_8000_48000\n\n#define JH7110_TDM_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver jh7110_tdm_dai = {\n\t.name = \"sf_tdm\",\n\t.id = 0,\n\t.playback = {\n\t\t.stream_name    = \"Playback\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 8,\n\t\t.rates          = JH7110_TDM_RATES,\n\t\t.formats        = JH7110_TDM_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name    = \"Capture\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 8,\n\t\t.rates          = JH7110_TDM_RATES,\n\t\t.formats        = JH7110_TDM_FORMATS,\n\t},\n\t.ops = &jh7110_tdm_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_pcm_hardware jh7110_pcm_hardware = {\n\t.info\t\t\t= (SNDRV_PCM_INFO_MMAP\t\t|\n\t\t\t\t   SNDRV_PCM_INFO_MMAP_VALID\t|\n\t\t\t\t   SNDRV_PCM_INFO_PAUSE\t\t|\n\t\t\t\t   SNDRV_PCM_INFO_RESUME\t|\n\t\t\t\t   SNDRV_PCM_INFO_INTERLEAVED\t|\n\t\t\t\t   SNDRV_PCM_INFO_BLOCK_TRANSFER),\n\t.buffer_bytes_max\t= 192512,\n\t.period_bytes_min\t= 4096,\n\t.period_bytes_max\t= 32768,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 48,\n\t.fifo_size\t\t= 16,\n};\n\nstatic const struct snd_dmaengine_pcm_config jh7110_dmaengine_pcm_config = {\n\t.pcm_hardware = &jh7110_pcm_hardware,\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n\t.prealloc_buffer_size = 192512,\n};\n\nstatic void jh7110_tdm_init_params(struct jh7110_tdm_dev *tdm)\n{\n\ttdm->clkpolity = TDM_TX_RASING_RX_FALLING;\n\ttdm->elm = TDM_ELM_LATE;\n\ttdm->syncm = TDM_SYNCM_SHORT;\n\n\ttdm->rx.ifl = TDM_FIFO_HALF;\n\ttdm->tx.ifl = TDM_FIFO_HALF;\n\ttdm->rx.wl = TDM_16BIT_WORD_LEN;\n\ttdm->tx.wl = TDM_16BIT_WORD_LEN;\n\ttdm->rx.sscale = 2;\n\ttdm->tx.sscale = 2;\n\ttdm->rx.lrj = TDM_LEFT_JUSTIFT;\n\ttdm->tx.lrj = TDM_LEFT_JUSTIFT;\n\n\ttdm->play_dma_data.addr = JH7110_TDM_FIFO;\n\ttdm->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\ttdm->play_dma_data.fifo_size = JH7110_TDM_FIFO_DEPTH / 2;\n\ttdm->play_dma_data.maxburst = 16;\n\n\ttdm->capture_dma_data.addr = JH7110_TDM_FIFO;\n\ttdm->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\ttdm->capture_dma_data.fifo_size = JH7110_TDM_FIFO_DEPTH / 2;\n\ttdm->capture_dma_data.maxburst = 8;\n}\n\nstatic int jh7110_tdm_clk_reset_get(struct platform_device *pdev,\n\t\t\t\t    struct jh7110_tdm_dev *tdm)\n{\n\tint ret;\n\n\ttdm->clks[0].id = \"mclk_inner\";\n\ttdm->clks[1].id = \"tdm_ahb\";\n\ttdm->clks[2].id = \"tdm_apb\";\n\ttdm->clks[3].id = \"tdm_internal\";\n\ttdm->clks[4].id = \"tdm_ext\";\n\ttdm->clks[5].id = \"tdm\";\n\n\tret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(tdm->clks), tdm->clks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get tdm clocks\\n\");\n\t\treturn ret;\n\t}\n\n\ttdm->resets = devm_reset_control_array_get_exclusive(&pdev->dev);\n\tif (IS_ERR(tdm->resets)) {\n\t\tdev_err(&pdev->dev, \"Failed to get tdm resets\\n\");\n\t\treturn PTR_ERR(tdm->resets);\n\t}\n\n\treturn 0;\n}\n\nstatic int jh7110_tdm_probe(struct platform_device *pdev)\n{\n\tstruct jh7110_tdm_dev *tdm;\n\tint ret;\n\n\ttdm = devm_kzalloc(&pdev->dev, sizeof(*tdm), GFP_KERNEL);\n\tif (!tdm)\n\t\treturn -ENOMEM;\n\n\ttdm->tdm_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(tdm->tdm_base))\n\t\treturn PTR_ERR(tdm->tdm_base);\n\n\ttdm->dev = &pdev->dev;\n\n\tret = jh7110_tdm_clk_reset_get(pdev, tdm);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to enable audio-tdm clock\\n\");\n\t\treturn ret;\n\t}\n\n\tjh7110_tdm_init_params(tdm);\n\n\tdev_set_drvdata(&pdev->dev, tdm);\n\tret = devm_snd_soc_register_component(&pdev->dev, &jh7110_tdm_component,\n\t\t\t\t\t      &jh7110_tdm_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to register dai\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev,\n\t\t\t\t\t      &jh7110_dmaengine_pcm_config,\n\t\t\t\t\t      SND_DMAENGINE_PCM_FLAG_COMPAT);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not register pcm: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = jh7110_tdm_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void jh7110_tdm_dev_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id jh7110_tdm_of_match[] = {\n\t{ .compatible = \"starfive,jh7110-tdm\", },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, jh7110_tdm_of_match);\n\nstatic const struct dev_pm_ops jh7110_tdm_pm_ops = {\n\tRUNTIME_PM_OPS(jh7110_tdm_runtime_suspend,\n\t\t       jh7110_tdm_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(jh7110_tdm_system_suspend,\n\t\t\t    jh7110_tdm_system_resume)\n};\n\nstatic struct platform_driver jh7110_tdm_driver = {\n\t.driver = {\n\t\t.name = \"jh7110-tdm\",\n\t\t.of_match_table = jh7110_tdm_of_match,\n\t\t.pm = pm_ptr(&jh7110_tdm_pm_ops),\n\t},\n\t.probe = jh7110_tdm_probe,\n\t.remove_new = jh7110_tdm_dev_remove,\n};\nmodule_platform_driver(jh7110_tdm_driver);\n\nMODULE_DESCRIPTION(\"StarFive JH7110 TDM ASoC Driver\");\nMODULE_AUTHOR(\"Walker Chen <walker.chen@starfivetech.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}