{
  "module_name": "loongson_i2s.c",
  "hash_id": "39e8931c278c2a3d0cd4e5a59f59a05a4d8a79f83c5663f9cf2eed07cc31edf3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/loongson/loongson_i2s.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <sound/soc.h>\n#include <linux/regmap.h>\n#include <sound/pcm_params.h>\n#include \"loongson_i2s.h\"\n\n#define LOONGSON_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic int loongson_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct loongson_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\t   I2S_CTRL_TX_EN | I2S_CTRL_TX_DMA_EN,\n\t\t\t\t\t   I2S_CTRL_TX_EN | I2S_CTRL_TX_DMA_EN);\n\t\telse\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\t   I2S_CTRL_RX_EN | I2S_CTRL_RX_DMA_EN,\n\t\t\t\t\t   I2S_CTRL_RX_EN | I2S_CTRL_RX_DMA_EN);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\tI2S_CTRL_TX_EN | I2S_CTRL_TX_DMA_EN, 0);\n\t\telse\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\tI2S_CTRL_RX_EN | I2S_CTRL_RX_DMA_EN, 0);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int loongson_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct loongson_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tu32 clk_rate = i2s->clk_rate;\n\tu32 sysclk = i2s->sysclk;\n\tu32 bits = params_width(params);\n\tu32 chans = params_channels(params);\n\tu32 fs = params_rate(params);\n\tu32 bclk_ratio, mclk_ratio;\n\tu32 mclk_ratio_frac;\n\tu32 val = 0;\n\n\tswitch (i2s->rev_id) {\n\tcase 0:\n\t\tbclk_ratio = DIV_ROUND_CLOSEST(clk_rate,\n\t\t\t\t\t       (bits * chans * fs * 2)) - 1;\n\t\tmclk_ratio = DIV_ROUND_CLOSEST(clk_rate, (sysclk * 2)) - 1;\n\n\t\t \n\t\tval |= (bits << 24);\n\t\tval |= (bits << 16);\n\t\tval |= (bclk_ratio << 8);\n\t\tval |= mclk_ratio;\n\t\tregmap_write(i2s->regmap, LS_I2S_CFG, val);\n\n\t\tbreak;\n\tcase 1:\n\t\tbclk_ratio = DIV_ROUND_CLOSEST(sysclk,\n\t\t\t\t\t       (bits * chans * fs * 2)) - 1;\n\t\tmclk_ratio = clk_rate / sysclk;\n\t\tmclk_ratio_frac = DIV_ROUND_CLOSEST_ULL(((u64)clk_rate << 16),\n\t\t\t\t\t\t    sysclk) - (mclk_ratio << 16);\n\n\t\tregmap_read(i2s->regmap, LS_I2S_CFG, &val);\n\t\tval |= (bits << 24);\n\t\tval |= (bclk_ratio << 8);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tval |= (bits << 16);\n\t\telse\n\t\t\tval |= bits;\n\t\tregmap_write(i2s->regmap, LS_I2S_CFG, val);\n\n\t\tval = (mclk_ratio_frac << 16) | mclk_ratio;\n\t\tregmap_write(i2s->regmap, LS_I2S_CFG1, val);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(i2s->dev, \"I2S revision invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int loongson_i2s_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t       unsigned int freq, int dir)\n{\n\tstruct loongson_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\n\ti2s->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int loongson_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct loongson_i2s *i2s = snd_soc_dai_get_drvdata(dai);\n\tu32 val;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL, I2S_CTRL_MSB,\n\t\t\t\t   I2S_CTRL_MSB);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\t \n\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL, I2S_CTRL_MASTER,\n\t\t\t\t   I2S_CTRL_MASTER);\n\t\tif (i2s->rev_id == 1) {\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\tLS_I2S_CTRL, val,\n\t\t\t\t\t\tval & I2S_CTRL_CLK_READY,\n\t\t\t\t\t\t10, 500000);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(dai->dev, \"wait BCLK ready timeout\\n\");\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t \n\t\tif (i2s->rev_id == 1) {\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\t   I2S_CTRL_MCLK_EN,\n\t\t\t\t\t   I2S_CTRL_MCLK_EN);\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\tLS_I2S_CTRL, val,\n\t\t\t\t\t\tval & I2S_CTRL_MCLK_READY,\n\t\t\t\t\t\t10, 500000);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(dai->dev, \"wait MCLK ready timeout\\n\");\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tif (i2s->rev_id == 1) {\n\t\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL,\n\t\t\t\t\t   I2S_CTRL_MCLK_EN,\n\t\t\t\t\t   I2S_CTRL_MCLK_EN);\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\tLS_I2S_CTRL, val,\n\t\t\t\t\t\tval & I2S_CTRL_MCLK_READY,\n\t\t\t\t\t\t10, 500000);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(dai->dev, \"wait MCLK ready timeout\\n\");\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(i2s->regmap, LS_I2S_CTRL, I2S_CTRL_MASTER,\n\t\t\t\t   I2S_CTRL_MASTER);\n\t\tif (i2s->rev_id == 1) {\n\t\t\tret = regmap_read_poll_timeout_atomic(i2s->regmap,\n\t\t\t\t\t\tLS_I2S_CTRL, val,\n\t\t\t\t\t\tval & I2S_CTRL_CLK_READY,\n\t\t\t\t\t\t10, 500000);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_warn(dai->dev, \"wait BCLK ready timeout\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int loongson_i2s_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct loongson_i2s *i2s = dev_get_drvdata(cpu_dai->dev);\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, &i2s->playback_dma_data,\n\t\t\t\t  &i2s->capture_dma_data);\n\tsnd_soc_dai_set_drvdata(cpu_dai, i2s);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops loongson_i2s_dai_ops = {\n\t.probe\t\t= loongson_i2s_dai_probe,\n\t.trigger\t= loongson_i2s_trigger,\n\t.hw_params\t= loongson_i2s_hw_params,\n\t.set_sysclk\t= loongson_i2s_set_dai_sysclk,\n\t.set_fmt\t= loongson_i2s_set_fmt,\n};\n\nstruct snd_soc_dai_driver loongson_i2s_dai = {\n\t.name = \"loongson-i2s\",\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = LOONGSON_I2S_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = LOONGSON_I2S_FORMATS,\n\t},\n\t.ops = &loongson_i2s_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int i2s_suspend(struct device *dev)\n{\n\tstruct loongson_i2s *i2s = dev_get_drvdata(dev);\n\n\tregcache_cache_only(i2s->regmap, true);\n\n\treturn 0;\n}\n\nstatic int i2s_resume(struct device *dev)\n{\n\tstruct loongson_i2s *i2s = dev_get_drvdata(dev);\n\tint ret;\n\n\tregcache_cache_only(i2s->regmap, false);\n\tregcache_mark_dirty(i2s->regmap);\n\tret = regcache_sync(i2s->regmap);\n\n\treturn ret;\n}\n\nconst struct dev_pm_ops loongson_i2s_pm = {\n\tSYSTEM_SLEEP_PM_OPS(i2s_suspend, i2s_resume)\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}