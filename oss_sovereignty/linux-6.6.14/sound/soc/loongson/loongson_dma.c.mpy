{
  "module_name": "loongson_dma.c",
  "hash_id": "dc6caf3d3d10dca03435f39e67568189fd850ee1ce5541fa46b02e4acdaf2ceb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/loongson/loongson_dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"loongson_i2s.h\"\n\n \n#define DMA_ORDER_STOP          (1 << 4)  \n#define DMA_ORDER_START         (1 << 3)  \n#define DMA_ORDER_ASK_VALID     (1 << 2)  \n#define DMA_ORDER_AXI_UNCO      (1 << 1)  \n#define DMA_ORDER_ADDR_64       (1 << 0)  \n\n#define DMA_ORDER_ASK_MASK      (~0x1fUL)  \n#define DMA_ORDER_CTRL_MASK     (0x0fUL)   \n\n \nstruct loongson_dma_desc {\n\tu32 order;\t\t \n\tu32 saddr;\t\t \n\tu32 daddr;\t\t \n\tu32 length;\t\t \n\tu32 step_length;\t \n\tu32 step_times;\t\t \n\tu32 cmd;\t\t \n\tu32 stats;\t\t \n\tu32 order_hi;\t\t \n\tu32 saddr_hi;\t\t \n\tu32 res[6];\t\t \n} __packed;\n\nstruct loongson_runtime_data {\n\tstruct loongson_dma_data *dma_data;\n\n\tstruct loongson_dma_desc *dma_desc_arr;\n\tdma_addr_t dma_desc_arr_phy;\n\tint dma_desc_arr_size;\n\n\tstruct loongson_dma_desc *dma_pos_desc;\n\tdma_addr_t dma_pos_desc_phy;\n};\n\nstatic const struct snd_pcm_hardware ls_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_RESUME |\n\t\tSNDRV_PCM_INFO_PAUSE,\n\t.formats = (SNDRV_PCM_FMTBIT_S8 |\n\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S20_3LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE),\n\t.period_bytes_min = 128,\n\t.period_bytes_max = 128 * 1024,\n\t.periods_min = 1,\n\t.periods_max = PAGE_SIZE / sizeof(struct loongson_dma_desc),\n\t.buffer_bytes_max = 1024 * 1024,\n};\n\nstatic struct\nloongson_dma_desc *dma_desc_save(struct loongson_runtime_data *prtd)\n{\n\tvoid __iomem *order_reg = prtd->dma_data->order_addr;\n\tu64 val;\n\n\tval = (u64)prtd->dma_pos_desc_phy & DMA_ORDER_ASK_MASK;\n\tval |= (readq(order_reg) & DMA_ORDER_CTRL_MASK);\n\tval |= DMA_ORDER_ASK_VALID;\n\twriteq(val, order_reg);\n\n\twhile (readl(order_reg) & DMA_ORDER_ASK_VALID)\n\t\tudelay(2);\n\n\treturn prtd->dma_pos_desc;\n}\n\nstatic int loongson_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct loongson_runtime_data *prtd = substream->runtime->private_data;\n\tstruct device *dev = substream->pcm->card->dev;\n\tvoid __iomem *order_reg = prtd->dma_data->order_addr;\n\tu64 val;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tval = prtd->dma_pos_desc_phy & DMA_ORDER_ASK_MASK;\n\t\tif (dev->coherent_dma_mask == DMA_BIT_MASK(64))\n\t\t\tval |= DMA_ORDER_ADDR_64;\n\t\telse\n\t\t\tval &= ~DMA_ORDER_ADDR_64;\n\t\tval |= (readq(order_reg) & DMA_ORDER_CTRL_MASK);\n\t\tval |= DMA_ORDER_START;\n\t\twriteq(val, order_reg);\n\n\t\twhile ((readl(order_reg) & DMA_ORDER_START))\n\t\t\tudelay(2);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdma_desc_save(prtd);\n\n\t\t \n\t\tval = readq(order_reg) | DMA_ORDER_STOP;\n\t\twriteq(val, order_reg);\n\t\tudelay(1000);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid pcm trigger operation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int loongson_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = substream->pcm->card->dev;\n\tstruct loongson_runtime_data *prtd = runtime->private_data;\n\tsize_t buf_len = params_buffer_bytes(params);\n\tsize_t period_len = params_period_bytes(params);\n\tdma_addr_t order_addr, mem_addr;\n\tstruct loongson_dma_desc *desc;\n\tu32 num_periods;\n\tint i;\n\n\tif (buf_len % period_len) {\n\t\tdev_err(dev, \"buf len not multiply of period len\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_periods = buf_len / period_len;\n\tif (!num_periods || num_periods > prtd->dma_desc_arr_size) {\n\t\tdev_err(dev, \"dma data too small or too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\n\truntime->dma_bytes = buf_len;\n\n\t \n\tmem_addr = runtime->dma_addr;\n\torder_addr = prtd->dma_desc_arr_phy;\n\tfor (i = 0; i < num_periods; i++) {\n\t\tdesc = &prtd->dma_desc_arr[i];\n\n\t\t \n\t\torder_addr += sizeof(*desc);\n\t\tdesc->order = lower_32_bits(order_addr | BIT(0));\n\t\tdesc->order_hi = upper_32_bits(order_addr);\n\n\t\tdesc->saddr = lower_32_bits(mem_addr);\n\t\tdesc->saddr_hi = upper_32_bits(mem_addr);\n\t\tdesc->daddr = prtd->dma_data->dev_addr;\n\n\t\tdesc->cmd = BIT(0);\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tdesc->cmd |= BIT(12);\n\n\t\tdesc->length = period_len >> 2;\n\t\tdesc->step_length = 0;\n\t\tdesc->step_times = 1;\n\n\t\tmem_addr += period_len;\n\t}\n\tdesc = &prtd->dma_desc_arr[num_periods - 1];\n\tdesc->order = lower_32_bits(prtd->dma_desc_arr_phy | BIT(0));\n\tdesc->order_hi = upper_32_bits(prtd->dma_desc_arr_phy);\n\n\t \n\t*prtd->dma_pos_desc = *prtd->dma_desc_arr;\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nloongson_pcm_pointer(struct snd_soc_component *component,\n\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct loongson_runtime_data *prtd = runtime->private_data;\n\tstruct loongson_dma_desc *desc;\n\tsnd_pcm_uframes_t x;\n\tu64 addr;\n\n\tdesc = dma_desc_save(prtd);\n\taddr = ((u64)desc->saddr_hi << 32) | desc->saddr;\n\n\tx = bytes_to_frames(runtime, addr - runtime->dma_addr);\n\tif (x == runtime->buffer_size)\n\t\tx = 0;\n\treturn x;\n}\n\nstatic irqreturn_t loongson_pcm_dma_irq(int irq, void *devid)\n{\n\tstruct snd_pcm_substream *substream = devid;\n\n\tsnd_pcm_period_elapsed(substream);\n\treturn IRQ_HANDLED;\n}\n\nstatic int loongson_pcm_open(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_card *card = substream->pcm->card;\n\tstruct loongson_runtime_data *prtd;\n\tstruct loongson_dma_data *dma_data;\n\tint ret;\n\n\t \n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 128);\n\tsnd_pcm_hw_constraint_step(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 128);\n\tsnd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t      SNDRV_PCM_HW_PARAM_PERIODS);\n\tsnd_soc_set_runtime_hwparams(substream, &ls_pcm_hardware);\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (!prtd)\n\t\treturn -ENOMEM;\n\n\tprtd->dma_desc_arr = dma_alloc_coherent(card->dev, PAGE_SIZE,\n\t\t\t\t\t\t&prtd->dma_desc_arr_phy,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!prtd->dma_desc_arr) {\n\t\tret = -ENOMEM;\n\t\tgoto desc_err;\n\t}\n\tprtd->dma_desc_arr_size = PAGE_SIZE / sizeof(*prtd->dma_desc_arr);\n\n\tprtd->dma_pos_desc = dma_alloc_coherent(card->dev,\n\t\t\t\t\t\tsizeof(*prtd->dma_pos_desc),\n\t\t\t\t\t\t&prtd->dma_pos_desc_phy,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!prtd->dma_pos_desc) {\n\t\tret = -ENOMEM;\n\t\tgoto pos_err;\n\t}\n\n\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tprtd->dma_data = dma_data;\n\n\tsubstream->runtime->private_data = prtd;\n\n\treturn 0;\npos_err:\n\tdma_free_coherent(card->dev, PAGE_SIZE, prtd->dma_desc_arr,\n\t\t\t  prtd->dma_desc_arr_phy);\ndesc_err:\n\tkfree(prtd);\n\n\treturn ret;\n}\n\nstatic int loongson_pcm_close(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_card *card = substream->pcm->card;\n\tstruct loongson_runtime_data *prtd = substream->runtime->private_data;\n\n\tdma_free_coherent(card->dev, PAGE_SIZE, prtd->dma_desc_arr,\n\t\t\t  prtd->dma_desc_arr_phy);\n\n\tdma_free_coherent(card->dev, sizeof(*prtd->dma_pos_desc),\n\t\t\t  prtd->dma_pos_desc, prtd->dma_pos_desc_phy);\n\n\tkfree(prtd);\n\treturn 0;\n}\n\nstatic int loongson_pcm_mmap(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct vm_area_struct *vma)\n{\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\tsubstream->dma_buffer.addr >> PAGE_SHIFT,\n\t\t\tvma->vm_end - vma->vm_start, vma->vm_page_prot);\n}\n\nstatic int loongson_pcm_new(struct snd_soc_component *component,\n\t\t\t    struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm_substream *substream;\n\tstruct loongson_dma_data *dma_data;\n\tunsigned int i;\n\tint ret;\n\n\tfor_each_pcm_streams(i) {\n\t\tsubstream = rtd->pcm->streams[i].substream;\n\t\tif (!substream)\n\t\t\tcontinue;\n\n\t\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0),\n\t\t\t\t\t\t    substream);\n\t\tret = devm_request_irq(card->dev, dma_data->irq,\n\t\t\t\t       loongson_pcm_dma_irq,\n\t\t\t\t       IRQF_TRIGGER_HIGH, LS_I2S_DRVNAME,\n\t\t\t\t       substream);\n\t\tif (ret < 0) {\n\t\t\tdev_err(card->dev, \"request irq for DMA failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn snd_pcm_set_fixed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    card->dev,\n\t\t\t\t\t    ls_pcm_hardware.buffer_bytes_max);\n}\n\nconst struct snd_soc_component_driver loongson_i2s_component = {\n\t.name\t\t= LS_I2S_DRVNAME,\n\t.open\t\t= loongson_pcm_open,\n\t.close\t\t= loongson_pcm_close,\n\t.hw_params\t= loongson_pcm_hw_params,\n\t.trigger\t= loongson_pcm_trigger,\n\t.pointer\t= loongson_pcm_pointer,\n\t.mmap\t\t= loongson_pcm_mmap,\n\t.pcm_construct\t= loongson_pcm_new,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}