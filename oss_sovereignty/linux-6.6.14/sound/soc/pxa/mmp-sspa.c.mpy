{
  "module_name": "mmp-sspa.c",
  "hash_id": "285bc055fb0a8e7e1f549c2682fb8164163df42413dc13a7000c6f3e3b1c3446",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/pxa/mmp-sspa.c",
  "human_readable_source": "\n \n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/dmaengine.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/pxa2xx-lib.h>\n#include <sound/dmaengine_pcm.h>\n#include \"mmp-sspa.h\"\n\n \nstruct sspa_priv {\n\tvoid __iomem *tx_base;\n\tvoid __iomem *rx_base;\n\n\tstruct snd_dmaengine_dai_dma_data playback_dma_data;\n\tstruct snd_dmaengine_dai_dma_data capture_dma_data;\n\tstruct clk *clk;\n\tstruct clk *audio_clk;\n\tstruct clk *sysclk;\n\n\tint running_cnt;\n\tu32 sp;\n\tu32 ctrl;\n};\n\nstatic void mmp_sspa_tx_enable(struct sspa_priv *sspa)\n{\n\tunsigned int sspa_sp = sspa->sp;\n\n\tsspa_sp &= ~SSPA_SP_MSL;\n\tsspa_sp |= SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\t__raw_writel(sspa_sp, sspa->tx_base + SSPA_SP);\n}\n\nstatic void mmp_sspa_tx_disable(struct sspa_priv *sspa)\n{\n\tunsigned int sspa_sp = sspa->sp;\n\n\tsspa_sp &= ~SSPA_SP_MSL;\n\tsspa_sp &= ~SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\t__raw_writel(sspa_sp, sspa->tx_base + SSPA_SP);\n}\n\nstatic void mmp_sspa_rx_enable(struct sspa_priv *sspa)\n{\n\tunsigned int sspa_sp = sspa->sp;\n\n\tsspa_sp |= SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\t__raw_writel(sspa_sp, sspa->rx_base + SSPA_SP);\n}\n\nstatic void mmp_sspa_rx_disable(struct sspa_priv *sspa)\n{\n\tunsigned int sspa_sp = sspa->sp;\n\n\tsspa_sp &= ~SSPA_SP_S_EN;\n\tsspa_sp |= SSPA_SP_WEN;\n\t__raw_writel(sspa_sp, sspa->rx_base + SSPA_SP);\n}\n\nstatic int mmp_sspa_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);\n\n\tclk_prepare_enable(sspa->sysclk);\n\tclk_prepare_enable(sspa->clk);\n\n\treturn 0;\n}\n\nstatic void mmp_sspa_shutdown(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);\n\n\tclk_disable_unprepare(sspa->clk);\n\tclk_disable_unprepare(sspa->sysclk);\n}\n\n \nstatic int mmp_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\t    int clk_id, unsigned int freq, int dir)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct device *dev = cpu_dai->component->dev;\n\tint ret = 0;\n\n\tif (dev->of_node)\n\t\treturn -ENOTSUPP;\n\n\tswitch (clk_id) {\n\tcase MMP_SSPA_CLK_AUDIO:\n\t\tret = clk_set_rate(sspa->audio_clk, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase MMP_SSPA_CLK_PLL:\n\tcase MMP_SSPA_CLK_VCXO:\n\t\t \n\t\treturn -EINVAL;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmp_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,\n\t\t\t\t int source, unsigned int freq_in,\n\t\t\t\t unsigned int freq_out)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct device *dev = cpu_dai->component->dev;\n\tint ret = 0;\n\n\tif (dev->of_node)\n\t\treturn -ENOTSUPP;\n\n\tswitch (pll_id) {\n\tcase MMP_SYSCLK:\n\t\tret = clk_set_rate(sspa->sysclk, freq_out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase MMP_SSPA_CLK:\n\t\tret = clk_set_rate(sspa->clk, freq_out);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mmp_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(cpu_dai);\n\n\t \n\tsspa->sp   = SSPA_SP_WEN | SSPA_SP_S_RST | SSPA_SP_FFLUSH;\n\tsspa->ctrl = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tsspa->sp |= SSPA_SP_MSL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tsspa->sp |= SSPA_SP_FSP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsspa->ctrl |= SSPA_CTL_XDATDLY(1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn 0;\n}\n\n \nstatic int mmp_sspa_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);\n\tstruct device *dev = dai->component->dev;\n\tu32 sspa_ctrl = sspa->ctrl;\n\tint bits;\n\tint bitval;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tbits = 8;\n\t\tbitval = SSPA_CTL_8_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbits = 16;\n\t\tbitval = SSPA_CTL_16_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tbits = 24;\n\t\tbitval = SSPA_CTL_24_BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tbits = 32;\n\t\tbitval = SSPA_CTL_32_BITS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsspa_ctrl &= ~SSPA_CTL_XPH;\n\tif (dev->of_node || params_channels(params) == 2)\n\t\tsspa_ctrl |= SSPA_CTL_XPH;\n\n\tsspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;\n\tsspa_ctrl |= SSPA_CTL_XWDLEN1(bitval);\n\n\tsspa_ctrl &= ~SSPA_CTL_XWDLEN2_MASK;\n\tsspa_ctrl |= SSPA_CTL_XWDLEN2(bitval);\n\n\tsspa_ctrl &= ~SSPA_CTL_XSSZ1_MASK;\n\tsspa_ctrl |= SSPA_CTL_XSSZ1(bitval);\n\n\tsspa_ctrl &= ~SSPA_CTL_XSSZ2_MASK;\n\tsspa_ctrl |= SSPA_CTL_XSSZ2(bitval);\n\n\tsspa->sp &= ~SSPA_SP_FWID_MASK;\n\tsspa->sp |= SSPA_SP_FWID(bits - 1);\n\n\tsspa->sp &= ~SSPA_TXSP_FPER_MASK;\n\tsspa->sp |= SSPA_TXSP_FPER(bits * 2 - 1);\n\n\tif (dev->of_node) {\n\t\tclk_set_rate(sspa->clk, params_rate(params) *\n\t\t\t\t\tparams_channels(params) * bits);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t__raw_writel(sspa_ctrl, sspa->tx_base + SSPA_CTL);\n\t\t__raw_writel(0x1, sspa->tx_base + SSPA_FIFO_UL);\n\t} else {\n\t\t__raw_writel(sspa_ctrl, sspa->rx_base + SSPA_CTL);\n\t\t__raw_writel(0x0, sspa->rx_base + SSPA_FIFO_UL);\n\t}\n\n\treturn 0;\n}\n\nstatic int mmp_sspa_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct sspa_priv *sspa = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tif (!sspa->running_cnt)\n\t\t\tmmp_sspa_rx_enable(sspa);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tmmp_sspa_tx_enable(sspa);\n\n\t\tsspa->running_cnt++;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tsspa->running_cnt--;\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tmmp_sspa_tx_disable(sspa);\n\n\t\t \n\t\tif (!sspa->running_cnt)\n\t\t\tmmp_sspa_rx_disable(sspa);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int mmp_sspa_probe(struct snd_soc_dai *dai)\n{\n\tstruct sspa_priv *sspa = dev_get_drvdata(dai->dev);\n\n\tsnd_soc_dai_init_dma_data(dai,\n\t\t\t\t&sspa->playback_dma_data,\n\t\t\t\t&sspa->capture_dma_data);\n\n\treturn 0;\n}\n\n#define MMP_SSPA_RATES SNDRV_PCM_RATE_8000_192000\n#define MMP_SSPA_FORMATS (SNDRV_PCM_FMTBIT_S8 | \\\n\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\tSNDRV_PCM_FMTBIT_S24_3LE | \\\n\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops mmp_sspa_dai_ops = {\n\t.probe\t\t= mmp_sspa_probe,\n\t.startup\t= mmp_sspa_startup,\n\t.shutdown\t= mmp_sspa_shutdown,\n\t.trigger\t= mmp_sspa_trigger,\n\t.hw_params\t= mmp_sspa_hw_params,\n\t.set_sysclk\t= mmp_sspa_set_dai_sysclk,\n\t.set_pll\t= mmp_sspa_set_dai_pll,\n\t.set_fmt\t= mmp_sspa_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver mmp_sspa_dai = {\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 128,\n\t\t.rates = MMP_SSPA_RATES,\n\t\t.formats = MMP_SSPA_FORMATS,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MMP_SSPA_RATES,\n\t\t.formats = MMP_SSPA_FORMATS,\n\t},\n\t.ops = &mmp_sspa_dai_ops,\n};\n\n#define MMP_PCM_INFO (SNDRV_PCM_INFO_MMAP |\t\\\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\t\\\n\t\tSNDRV_PCM_INFO_INTERLEAVED |\t\\\n\t\tSNDRV_PCM_INFO_PAUSE |\t\t\\\n\t\tSNDRV_PCM_INFO_RESUME |\t\t\\\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP)\n\nstatic const struct snd_pcm_hardware mmp_pcm_hardware[] = {\n\t{\n\t\t.info\t\t\t= MMP_PCM_INFO,\n\t\t.period_bytes_min\t= 1024,\n\t\t.period_bytes_max\t= 2048,\n\t\t.periods_min\t\t= 2,\n\t\t.periods_max\t\t= 32,\n\t\t.buffer_bytes_max\t= 4096,\n\t\t.fifo_size\t\t= 32,\n\t},\n\t{\n\t\t.info\t\t\t= MMP_PCM_INFO,\n\t\t.period_bytes_min\t= 1024,\n\t\t.period_bytes_max\t= 2048,\n\t\t.periods_min\t\t= 2,\n\t\t.periods_max\t\t= 32,\n\t\t.buffer_bytes_max\t= 4096,\n\t\t.fifo_size\t\t= 32,\n\t},\n};\n\nstatic const struct snd_dmaengine_pcm_config mmp_pcm_config = {\n\t.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,\n\t.pcm_hardware = mmp_pcm_hardware,\n\t.prealloc_buffer_size = 4096,\n};\n\nstatic int mmp_pcm_mmap(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct vm_area_struct *vma)\n{\n\tvm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\tsubstream->dma_buffer.addr >> PAGE_SHIFT,\n\t\tvma->vm_end - vma->vm_start, vma->vm_page_prot);\n}\n\nstatic int mmp_sspa_open(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct sspa_priv *sspa = snd_soc_component_get_drvdata(component);\n\n\tpm_runtime_get_sync(component->dev);\n\n\t \n\tif ((__raw_readl(sspa->tx_base + SSPA_SP) & SSPA_SP_S_EN) ||\n\t    (__raw_readl(sspa->rx_base + SSPA_SP) & SSPA_SP_S_EN)) {\n\t\tdev_err(component->dev,\n\t\t\t\"can't change hardware dai format: stream is in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t__raw_writel(sspa->sp, sspa->tx_base + SSPA_SP);\n\t__raw_writel(sspa->sp, sspa->rx_base + SSPA_SP);\n\n\tsspa->sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);\n\t__raw_writel(sspa->sp, sspa->tx_base + SSPA_SP);\n\t__raw_writel(sspa->sp, sspa->rx_base + SSPA_SP);\n\n\t \n\t__raw_writel(sspa->sp & ~SSPA_SP_MSL, sspa->tx_base + SSPA_SP);\n\n\t__raw_writel(sspa->ctrl, sspa->tx_base + SSPA_CTL);\n\t__raw_writel(sspa->ctrl, sspa->rx_base + SSPA_CTL);\n\n\treturn 0;\n}\n\nstatic int mmp_sspa_close(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tpm_runtime_put_sync(component->dev);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver mmp_sspa_component = {\n\t.name\t\t\t= \"mmp-sspa\",\n\t.mmap\t\t\t= mmp_pcm_mmap,\n\t.open\t\t\t= mmp_sspa_open,\n\t.close\t\t\t= mmp_sspa_close,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int asoc_mmp_sspa_probe(struct platform_device *pdev)\n{\n\tstruct sspa_priv *sspa;\n\tint ret;\n\n\tsspa = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct sspa_priv), GFP_KERNEL);\n\tif (!sspa)\n\t\treturn -ENOMEM;\n\n\tif (pdev->dev.of_node) {\n\t\tsspa->rx_base = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(sspa->rx_base))\n\t\t\treturn PTR_ERR(sspa->rx_base);\n\n\t\tsspa->tx_base = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(sspa->tx_base))\n\t\t\treturn PTR_ERR(sspa->tx_base);\n\n\t\tsspa->clk = devm_clk_get(&pdev->dev, \"bitclk\");\n\t\tif (IS_ERR(sspa->clk))\n\t\t\treturn PTR_ERR(sspa->clk);\n\n\t\tsspa->audio_clk = devm_clk_get(&pdev->dev, \"audio\");\n\t\tif (IS_ERR(sspa->audio_clk))\n\t\t\treturn PTR_ERR(sspa->audio_clk);\n\t} else {\n\t\tstruct resource *res;\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_IO, 0);\n\t\tif (res == NULL)\n\t\t\treturn -ENODEV;\n\n\t\tsspa->rx_base = devm_ioremap(&pdev->dev, res->start, 0x30);\n\t\tif (!sspa->rx_base)\n\t\t\treturn -ENOMEM;\n\n\t\tsspa->tx_base = devm_ioremap(&pdev->dev,\n\t\t\t\t\t     res->start + 0x80, 0x30);\n\t\tif (!sspa->tx_base)\n\t\t\treturn -ENOMEM;\n\n\t\tsspa->clk = devm_clk_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(sspa->clk))\n\t\t\treturn PTR_ERR(sspa->clk);\n\n\t\tsspa->audio_clk = clk_get(NULL, \"mmp-audio\");\n\t\tif (IS_ERR(sspa->audio_clk))\n\t\t\treturn PTR_ERR(sspa->audio_clk);\n\n\t\tsspa->sysclk = clk_get(NULL, \"mmp-sysclk\");\n\t\tif (IS_ERR(sspa->sysclk)) {\n\t\t\tclk_put(sspa->audio_clk);\n\t\t\treturn PTR_ERR(sspa->sysclk);\n\t\t}\n\t}\n\tplatform_set_drvdata(pdev, sspa);\n\n\tsspa->playback_dma_data.maxburst = 4;\n\tsspa->capture_dma_data.maxburst = 4;\n\t \n\tsspa->capture_dma_data.addr = SSPA_D;\n\tsspa->playback_dma_data.addr = 0x80 + SSPA_D;\n\n\tif (pdev->dev.of_node) {\n\t\tret = devm_snd_dmaengine_pcm_register(&pdev->dev,\n\t\t\t\t\t\t      &mmp_pcm_config, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &mmp_sspa_component,\n\t\t\t\t\t      &mmp_sspa_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_enable(&pdev->dev);\n\tclk_prepare_enable(sspa->audio_clk);\n\n\treturn 0;\n}\n\nstatic void asoc_mmp_sspa_remove(struct platform_device *pdev)\n{\n\tstruct sspa_priv *sspa = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(sspa->audio_clk);\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (pdev->dev.of_node)\n\t\treturn;\n\n\tclk_put(sspa->audio_clk);\n\tclk_put(sspa->sysclk);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mmp_sspa_of_match[] = {\n\t{ .compatible = \"marvell,mmp-sspa\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, mmp_sspa_of_match);\n#endif\n\nstatic struct platform_driver asoc_mmp_sspa_driver = {\n\t.driver = {\n\t\t.name = \"mmp-sspa-dai\",\n\t\t.of_match_table = of_match_ptr(mmp_sspa_of_match),\n\t},\n\t.probe = asoc_mmp_sspa_probe,\n\t.remove_new = asoc_mmp_sspa_remove,\n};\n\nmodule_platform_driver(asoc_mmp_sspa_driver);\n\nMODULE_AUTHOR(\"Leo Yan <leoy@marvell.com>\");\nMODULE_DESCRIPTION(\"MMP SSPA SoC Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mmp-sspa-dai\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}