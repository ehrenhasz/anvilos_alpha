{
  "module_name": "pxa-ssp.c",
  "hash_id": "b20d5c8c813ca473c1e3e307b239dc4e04accb57a0c0d6863e144e57ee35a768",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/pxa/pxa-ssp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/pxa2xx_ssp.h>\n#include <linux/of.h>\n#include <linux/dmaengine.h>\n\n#include <asm/irq.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/pxa2xx-lib.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"pxa-ssp.h\"\n\n \nstruct ssp_priv {\n\tstruct ssp_device *ssp;\n\tstruct clk *extclk;\n\tunsigned long ssp_clk;\n\tunsigned int sysclk;\n\tunsigned int dai_fmt;\n\tunsigned int configured_dai_fmt;\n#ifdef CONFIG_PM\n\tuint32_t\tcr0;\n\tuint32_t\tcr1;\n\tuint32_t\tto;\n\tuint32_t\tpsp;\n#endif\n};\n\nstatic void dump_registers(struct ssp_device *ssp)\n{\n\tdev_dbg(ssp->dev, \"SSCR0 0x%08x SSCR1 0x%08x SSTO 0x%08x\\n\",\n\t\t pxa_ssp_read_reg(ssp, SSCR0), pxa_ssp_read_reg(ssp, SSCR1),\n\t\t pxa_ssp_read_reg(ssp, SSTO));\n\n\tdev_dbg(ssp->dev, \"SSPSP 0x%08x SSSR 0x%08x SSACD 0x%08x\\n\",\n\t\t pxa_ssp_read_reg(ssp, SSPSP), pxa_ssp_read_reg(ssp, SSSR),\n\t\t pxa_ssp_read_reg(ssp, SSACD));\n}\n\nstatic void pxa_ssp_set_dma_params(struct ssp_device *ssp, int width4,\n\t\t\tint out, struct snd_dmaengine_dai_dma_data *dma)\n{\n\tdma->addr_width = width4 ? DMA_SLAVE_BUSWIDTH_4_BYTES :\n\t\t\t\t   DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tdma->maxburst = 16;\n\tdma->addr = ssp->phys_base + SSDR;\n}\n\nstatic int pxa_ssp_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\tstruct snd_dmaengine_dai_dma_data *dma;\n\tint ret = 0;\n\n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tclk_prepare_enable(ssp->clk);\n\t\tpxa_ssp_disable(ssp);\n\t}\n\n\tclk_prepare_enable(priv->extclk);\n\n\tdma = kzalloc(sizeof(struct snd_dmaengine_dai_dma_data), GFP_KERNEL);\n\tif (!dma)\n\t\treturn -ENOMEM;\n\tdma->chan_name = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\n\t\t\"tx\" : \"rx\";\n\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream, dma);\n\n\treturn ret;\n}\n\nstatic void pxa_ssp_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tpxa_ssp_disable(ssp);\n\t\tclk_disable_unprepare(ssp->clk);\n\t}\n\n\tclk_disable_unprepare(priv->extclk);\n\n\tkfree(snd_soc_dai_get_dma_data(cpu_dai, substream));\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream, NULL);\n}\n\n#ifdef CONFIG_PM\n\nstatic int pxa_ssp_suspend(struct snd_soc_component *component)\n{\n\tstruct ssp_priv *priv = snd_soc_component_get_drvdata(component);\n\tstruct ssp_device *ssp = priv->ssp;\n\n\tif (!snd_soc_component_active(component))\n\t\tclk_prepare_enable(ssp->clk);\n\n\tpriv->cr0 = __raw_readl(ssp->mmio_base + SSCR0);\n\tpriv->cr1 = __raw_readl(ssp->mmio_base + SSCR1);\n\tpriv->to  = __raw_readl(ssp->mmio_base + SSTO);\n\tpriv->psp = __raw_readl(ssp->mmio_base + SSPSP);\n\n\tpxa_ssp_disable(ssp);\n\tclk_disable_unprepare(ssp->clk);\n\treturn 0;\n}\n\nstatic int pxa_ssp_resume(struct snd_soc_component *component)\n{\n\tstruct ssp_priv *priv = snd_soc_component_get_drvdata(component);\n\tstruct ssp_device *ssp = priv->ssp;\n\tuint32_t sssr = SSSR_ROR | SSSR_TUR | SSSR_BCE;\n\n\tclk_prepare_enable(ssp->clk);\n\n\t__raw_writel(sssr, ssp->mmio_base + SSSR);\n\t__raw_writel(priv->cr0 & ~SSCR0_SSE, ssp->mmio_base + SSCR0);\n\t__raw_writel(priv->cr1, ssp->mmio_base + SSCR1);\n\t__raw_writel(priv->to,  ssp->mmio_base + SSTO);\n\t__raw_writel(priv->psp, ssp->mmio_base + SSPSP);\n\n\tif (snd_soc_component_active(component))\n\t\tpxa_ssp_enable(ssp);\n\telse\n\t\tclk_disable_unprepare(ssp->clk);\n\n\treturn 0;\n}\n\n#else\n#define pxa_ssp_suspend\tNULL\n#define pxa_ssp_resume\tNULL\n#endif\n\n \nstatic void pxa_ssp_set_scr(struct ssp_device *ssp, u32 div)\n{\n\tu32 sscr0 = pxa_ssp_read_reg(ssp, SSCR0);\n\n\tif (ssp->type == PXA25x_SSP) {\n\t\tsscr0 &= ~0x0000ff00;\n\t\tsscr0 |= ((div - 2)/2) << 8;  \n\t} else {\n\t\tsscr0 &= ~0x000fff00;\n\t\tsscr0 |= (div - 1) << 8;      \n\t}\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\n}\n\n \nstatic int pxa_ssp_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\n\tu32 sscr0 = pxa_ssp_read_reg(ssp, SSCR0) &\n\t\t~(SSCR0_ECS | SSCR0_NCS | SSCR0_MOD | SSCR0_ACS);\n\n\tif (priv->extclk) {\n\t\tint ret;\n\n\t\t \n\n\t\tret = clk_set_rate(priv->extclk, freq);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tclk_id = PXA_SSP_CLK_EXT;\n\t}\n\n\tdev_dbg(ssp->dev,\n\t\t\"pxa_ssp_set_dai_sysclk id: %d, clk_id %d, freq %u\\n\",\n\t\tcpu_dai->id, clk_id, freq);\n\n\tswitch (clk_id) {\n\tcase PXA_SSP_CLK_NET_PLL:\n\t\tsscr0 |= SSCR0_MOD;\n\t\tbreak;\n\tcase PXA_SSP_CLK_PLL:\n\t\t \n\t\tif (ssp->type == PXA25x_SSP)\n\t\t\tpriv->sysclk = 1843200;\n\t\telse\n\t\t\tpriv->sysclk = 13000000;\n\t\tbreak;\n\tcase PXA_SSP_CLK_EXT:\n\t\tpriv->sysclk = freq;\n\t\tsscr0 |= SSCR0_ECS;\n\t\tbreak;\n\tcase PXA_SSP_CLK_NET:\n\t\tpriv->sysclk = freq;\n\t\tsscr0 |= SSCR0_NCS | SSCR0_MOD;\n\t\tbreak;\n\tcase PXA_SSP_CLK_AUDIO:\n\t\tpriv->sysclk = 0;\n\t\tpxa_ssp_set_scr(ssp, 1);\n\t\tsscr0 |= SSCR0_ACS;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (ssp->type != PXA3xx_SSP)\n\t\tclk_disable_unprepare(ssp->clk);\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\n\tif (ssp->type != PXA3xx_SSP)\n\t\tclk_prepare_enable(ssp->clk);\n\n\treturn 0;\n}\n\n \nstatic int pxa_ssp_set_pll(struct ssp_priv *priv, unsigned int freq)\n{\n\tstruct ssp_device *ssp = priv->ssp;\n\tu32 ssacd = pxa_ssp_read_reg(ssp, SSACD) & ~0x70;\n\n\tif (ssp->type == PXA3xx_SSP)\n\t\tpxa_ssp_write_reg(ssp, SSACDD, 0);\n\n\tswitch (freq) {\n\tcase 5622000:\n\t\tbreak;\n\tcase 11345000:\n\t\tssacd |= (0x1 << 4);\n\t\tbreak;\n\tcase 12235000:\n\t\tssacd |= (0x2 << 4);\n\t\tbreak;\n\tcase 14857000:\n\t\tssacd |= (0x3 << 4);\n\t\tbreak;\n\tcase 32842000:\n\t\tssacd |= (0x4 << 4);\n\t\tbreak;\n\tcase 48000000:\n\t\tssacd |= (0x5 << 4);\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (ssp->type == PXA3xx_SSP) {\n\t\t\tu32 val;\n\t\t\tu64 tmp = 19968;\n\n\t\t\ttmp *= 1000000;\n\t\t\tdo_div(tmp, freq);\n\t\t\tval = tmp;\n\n\t\t\tval = (val << 16) | 64;\n\t\t\tpxa_ssp_write_reg(ssp, SSACDD, val);\n\n\t\t\tssacd |= (0x6 << 4);\n\n\t\t\tdev_dbg(ssp->dev,\n\t\t\t\t\"Using SSACDD %x to supply %uHz\\n\",\n\t\t\t\tval, freq);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn -EINVAL;\n\t}\n\n\tpxa_ssp_write_reg(ssp, SSACD, ssacd);\n\n\treturn 0;\n}\n\n \nstatic int pxa_ssp_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\tu32 sscr0;\n\n\tsscr0 = pxa_ssp_read_reg(ssp, SSCR0);\n\tsscr0 &= ~(SSCR0_MOD | SSCR0_SlotsPerFrm(8) | SSCR0_EDSS | SSCR0_DSS);\n\n\t \n\tif (slot_width > 16)\n\t\tsscr0 |= SSCR0_EDSS | SSCR0_DataSize(slot_width - 16);\n\telse\n\t\tsscr0 |= SSCR0_DataSize(slot_width);\n\n\tif (slots > 1) {\n\t\t \n\t\tsscr0 |= SSCR0_MOD;\n\n\t\t \n\t\tsscr0 |= SSCR0_SlotsPerFrm(slots);\n\n\t\t \n\t\tpxa_ssp_write_reg(ssp, SSTSA, tx_mask);\n\t\tpxa_ssp_write_reg(ssp, SSRSA, rx_mask);\n\t}\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\n\n\treturn 0;\n}\n\n \nstatic int pxa_ssp_set_dai_tristate(struct snd_soc_dai *cpu_dai,\n\tint tristate)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\tu32 sscr1;\n\n\tsscr1 = pxa_ssp_read_reg(ssp, SSCR1);\n\tif (tristate)\n\t\tsscr1 &= ~SSCR1_TTE;\n\telse\n\t\tsscr1 |= SSCR1_TTE;\n\tpxa_ssp_write_reg(ssp, SSCR1, sscr1);\n\n\treturn 0;\n}\n\nstatic int pxa_ssp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_BC_FP:\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->dai_fmt = fmt;\n\n\treturn 0;\n}\n\n \nstatic int pxa_ssp_configure_dai_fmt(struct ssp_priv *priv)\n{\n\tstruct ssp_device *ssp = priv->ssp;\n\tu32 sscr0, sscr1, sspsp, scfr;\n\n\t \n\tif (priv->configured_dai_fmt == priv->dai_fmt)\n\t\treturn 0;\n\n\t \n\tsscr0 = pxa_ssp_read_reg(ssp, SSCR0) &\n\t\t~(SSCR0_PSP | SSCR0_MOD);\n\tsscr1 = pxa_ssp_read_reg(ssp, SSCR1) &\n\t\t~(SSCR1_SCLKDIR | SSCR1_SFRMDIR | SSCR1_SCFR |\n\t\t  SSCR1_RWOT | SSCR1_TRAIL | SSCR1_TFT | SSCR1_RFT);\n\tsspsp = pxa_ssp_read_reg(ssp, SSPSP) &\n\t\t~(SSPSP_SFRMP | SSPSP_SCMODE(3));\n\n\tsscr1 |= SSCR1_RxTresh(8) | SSCR1_TxTresh(7);\n\n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tsscr1 |= SSCR1_SCLKDIR | SSCR1_SFRMDIR | SSCR1_SCFR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tsscr1 |= SSCR1_SCLKDIR | SSCR1_SCFR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tsspsp |= SSPSP_SFRMP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tsspsp |= SSPSP_SCMODE(2);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tsspsp |= SSPSP_SCMODE(2) | SSPSP_SFRMP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsscr0 |= SSCR0_PSP;\n\t\tsscr1 |= SSCR1_RWOT | SSCR1_TRAIL;\n\t\t \n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tsspsp |= SSPSP_FSRT;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tsscr0 |= SSCR0_MOD | SSCR0_PSP;\n\t\tsscr1 |= SSCR1_TRAIL | SSCR1_RWOT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\n\tpxa_ssp_write_reg(ssp, SSCR1, sscr1);\n\tpxa_ssp_write_reg(ssp, SSPSP, sspsp);\n\n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tscfr = pxa_ssp_read_reg(ssp, SSCR1) | SSCR1_SCFR;\n\t\tpxa_ssp_write_reg(ssp, SSCR1, scfr);\n\n\t\twhile (pxa_ssp_read_reg(ssp, SSSR) & SSSR_BSY)\n\t\t\tcpu_relax();\n\t\tbreak;\n\t}\n\n\tdump_registers(ssp);\n\n\t \n\tpriv->configured_dai_fmt = priv->dai_fmt;\n\n\treturn 0;\n}\n\nstruct pxa_ssp_clock_mode {\n\tint rate;\n\tint pll;\n\tu8 acds;\n\tu8 scdb;\n};\n\nstatic const struct pxa_ssp_clock_mode pxa_ssp_clock_modes[] = {\n\t{ .rate =  8000, .pll = 32842000, .acds = SSACD_ACDS_32, .scdb = SSACD_SCDB_4X },\n\t{ .rate = 11025, .pll =  5622000, .acds = SSACD_ACDS_4,  .scdb = SSACD_SCDB_4X },\n\t{ .rate = 16000, .pll = 32842000, .acds = SSACD_ACDS_16, .scdb = SSACD_SCDB_4X },\n\t{ .rate = 22050, .pll =  5622000, .acds = SSACD_ACDS_2,  .scdb = SSACD_SCDB_4X },\n\t{ .rate = 44100, .pll = 11345000, .acds = SSACD_ACDS_2,  .scdb = SSACD_SCDB_4X },\n\t{ .rate = 48000, .pll = 12235000, .acds = SSACD_ACDS_2,  .scdb = SSACD_SCDB_4X },\n\t{ .rate = 96000, .pll = 12235000, .acds = SSACD_ACDS_4,  .scdb = SSACD_SCDB_1X },\n\t{}\n};\n\n \nstatic int pxa_ssp_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\tint chn = params_channels(params);\n\tu32 sscr0, sspsp;\n\tint width = snd_pcm_format_physical_width(params_format(params));\n\tint ttsa = pxa_ssp_read_reg(ssp, SSTSA) & 0xf;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tint rate = params_rate(params);\n\tint bclk = rate * chn * (width / 8);\n\tint ret;\n\n\tdma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);\n\n\t \n\tpxa_ssp_set_dma_params(ssp,\n\t\t((chn == 2) && (ttsa != 1)) || (width == 32),\n\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK, dma_data);\n\n\t \n\tif (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE)\n\t\treturn 0;\n\n\tret = pxa_ssp_configure_dai_fmt(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsscr0 = pxa_ssp_read_reg(ssp, SSCR0) & ~(SSCR0_DSS | SSCR0_EDSS);\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tif (ssp->type == PXA3xx_SSP)\n\t\t\tsscr0 |= SSCR0_FPCKE;\n\t\tsscr0 |= SSCR0_DataSize(16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tsscr0 |= (SSCR0_EDSS | SSCR0_DataSize(8));\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tsscr0 |= (SSCR0_EDSS | SSCR0_DataSize(16));\n\t\tbreak;\n\t}\n\tpxa_ssp_write_reg(ssp, SSCR0, sscr0);\n\n\tif (sscr0 & SSCR0_ACS) {\n\t\tret = pxa_ssp_set_pll(priv, bclk);\n\n\t\t \n\n\t\tif (ret < 0) {\n\t\t\tconst struct pxa_ssp_clock_mode *m;\n\t\t\tint ssacd;\n\n\t\t\tfor (m = pxa_ssp_clock_modes; m->rate; m++) {\n\t\t\t\tif (m->rate == rate)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!m->rate)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = pxa_ssp_set_pll(priv, bclk);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tssacd = pxa_ssp_read_reg(ssp, SSACD);\n\t\t\tssacd &= ~(SSACD_ACDS(7) | SSACD_SCDB_1X);\n\t\t\tssacd |= SSACD_ACDS(m->acds);\n\t\t\tssacd |= m->scdb;\n\t\t\tpxa_ssp_write_reg(ssp, SSACD, ssacd);\n\t\t}\n\t} else if (sscr0 & SSCR0_ECS) {\n\t\t \n\t\tpxa_ssp_set_scr(ssp, bclk / rate);\n\t}\n\n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t       sspsp = pxa_ssp_read_reg(ssp, SSPSP);\n\n\t\tif (((priv->sysclk / bclk) == 64) && (width == 16)) {\n\t\t\t \n\t\t\tif (ssp->type != PXA3xx_SSP)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tsspsp |= SSPSP_SFRMWDTH(width * 2);\n\t\t\tsspsp |= SSPSP_SFRMDLY(width * 4);\n\t\t\tsspsp |= SSPSP_EDMYSTOP(3);\n\t\t\tsspsp |= SSPSP_DMYSTOP(3);\n\t\t\tsspsp |= SSPSP_DMYSTRT(1);\n\t\t} else {\n\t\t\t \n\t\t\tsspsp |= SSPSP_SFRMWDTH(width + 1);\n\t\t\tsspsp |= SSPSP_SFRMDLY((width + 1) * 2);\n\t\t\tsspsp |= SSPSP_DMYSTRT(1);\n\t\t}\n\n\t\tpxa_ssp_write_reg(ssp, SSPSP, sspsp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif ((sscr0 & SSCR0_MOD) && !ttsa) {\n\t\tdev_err(ssp->dev, \"No TDM timeslot configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdump_registers(ssp);\n\n\treturn 0;\n}\n\nstatic void pxa_ssp_set_running_bit(struct snd_pcm_substream *substream,\n\t\t\t\t    struct ssp_device *ssp, int value)\n{\n\tuint32_t sscr0 = pxa_ssp_read_reg(ssp, SSCR0);\n\tuint32_t sscr1 = pxa_ssp_read_reg(ssp, SSCR1);\n\tuint32_t sspsp = pxa_ssp_read_reg(ssp, SSPSP);\n\tuint32_t sssr = pxa_ssp_read_reg(ssp, SSSR);\n\n\tif (value && (sscr0 & SSCR0_SSE))\n\t\tpxa_ssp_write_reg(ssp, SSCR0, sscr0 & ~SSCR0_SSE);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (value)\n\t\t\tsscr1 |= SSCR1_TSRE;\n\t\telse\n\t\t\tsscr1 &= ~SSCR1_TSRE;\n\t} else {\n\t\tif (value)\n\t\t\tsscr1 |= SSCR1_RSRE;\n\t\telse\n\t\t\tsscr1 &= ~SSCR1_RSRE;\n\t}\n\n\tpxa_ssp_write_reg(ssp, SSCR1, sscr1);\n\n\tif (value) {\n\t\tpxa_ssp_write_reg(ssp, SSSR, sssr);\n\t\tpxa_ssp_write_reg(ssp, SSPSP, sspsp);\n\t\tpxa_ssp_write_reg(ssp, SSCR0, sscr0 | SSCR0_SSE);\n\t}\n}\n\nstatic int pxa_ssp_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tint ret = 0;\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct ssp_device *ssp = priv->ssp;\n\tint val;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tpxa_ssp_enable(ssp);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tpxa_ssp_set_running_bit(substream, ssp, 1);\n\t\tval = pxa_ssp_read_reg(ssp, SSSR);\n\t\tpxa_ssp_write_reg(ssp, SSSR, val);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tpxa_ssp_set_running_bit(substream, ssp, 1);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tpxa_ssp_set_running_bit(substream, ssp, 0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tpxa_ssp_disable(ssp);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tpxa_ssp_set_running_bit(substream, ssp, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tdump_registers(ssp);\n\n\treturn ret;\n}\n\nstatic int pxa_ssp_probe(struct snd_soc_dai *dai)\n{\n\tstruct device *dev = dai->dev;\n\tstruct ssp_priv *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(struct ssp_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (dev->of_node) {\n\t\tstruct device_node *ssp_handle;\n\n\t\tssp_handle = of_parse_phandle(dev->of_node, \"port\", 0);\n\t\tif (!ssp_handle) {\n\t\t\tdev_err(dev, \"unable to get 'port' phandle\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_priv;\n\t\t}\n\n\t\tpriv->ssp = pxa_ssp_request_of(ssp_handle, \"SoC audio\");\n\t\tif (priv->ssp == NULL) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_priv;\n\t\t}\n\n\t\tpriv->extclk = devm_clk_get(dev, \"extclk\");\n\t\tif (IS_ERR(priv->extclk)) {\n\t\t\tret = PTR_ERR(priv->extclk);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto err_priv;\n\n\t\t\tpriv->extclk = NULL;\n\t\t}\n\t} else {\n\t\tpriv->ssp = pxa_ssp_request(dai->id + 1, \"SoC audio\");\n\t\tif (priv->ssp == NULL) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_priv;\n\t\t}\n\t}\n\n\tpriv->dai_fmt = (unsigned int) -1;\n\tsnd_soc_dai_set_drvdata(dai, priv);\n\n\treturn 0;\n\nerr_priv:\n\tkfree(priv);\n\treturn ret;\n}\n\nstatic int pxa_ssp_remove(struct snd_soc_dai *dai)\n{\n\tstruct ssp_priv *priv = snd_soc_dai_get_drvdata(dai);\n\n\tpxa_ssp_free(priv->ssp);\n\tkfree(priv);\n\treturn 0;\n}\n\n#define PXA_SSP_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\t\t  SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\t\\\n\t\t\t  SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\t\\\n\t\t\t  SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 |\t\\\n\t\t\t  SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)\n\n#define PXA_SSP_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops pxa_ssp_dai_ops = {\n\t.probe\t\t= pxa_ssp_probe,\n\t.remove\t\t= pxa_ssp_remove,\n\t.startup\t= pxa_ssp_startup,\n\t.shutdown\t= pxa_ssp_shutdown,\n\t.trigger\t= pxa_ssp_trigger,\n\t.hw_params\t= pxa_ssp_hw_params,\n\t.set_sysclk\t= pxa_ssp_set_dai_sysclk,\n\t.set_fmt\t= pxa_ssp_set_dai_fmt,\n\t.set_tdm_slot\t= pxa_ssp_set_dai_tdm_slot,\n\t.set_tristate\t= pxa_ssp_set_dai_tristate,\n};\n\nstatic struct snd_soc_dai_driver pxa_ssp_dai = {\n\t\t.playback = {\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = PXA_SSP_RATES,\n\t\t\t.formats = PXA_SSP_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .channels_min = 1,\n\t\t\t .channels_max = 8,\n\t\t\t.rates = PXA_SSP_RATES,\n\t\t\t.formats = PXA_SSP_FORMATS,\n\t\t },\n\t\t.ops = &pxa_ssp_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver pxa_ssp_component = {\n\t.name\t\t\t= \"pxa-ssp\",\n\t.pcm_construct\t\t= pxa2xx_soc_pcm_new,\n\t.open\t\t\t= pxa2xx_soc_pcm_open,\n\t.close\t\t\t= pxa2xx_soc_pcm_close,\n\t.hw_params\t\t= pxa2xx_soc_pcm_hw_params,\n\t.prepare\t\t= pxa2xx_soc_pcm_prepare,\n\t.trigger\t\t= pxa2xx_soc_pcm_trigger,\n\t.pointer\t\t= pxa2xx_soc_pcm_pointer,\n\t.suspend\t\t= pxa_ssp_suspend,\n\t.resume\t\t\t= pxa_ssp_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_ssp_of_ids[] = {\n\t{ .compatible = \"mrvl,pxa-ssp-dai\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pxa_ssp_of_ids);\n#endif\n\nstatic int asoc_ssp_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev, &pxa_ssp_component,\n\t\t\t\t\t       &pxa_ssp_dai, 1);\n}\n\nstatic struct platform_driver asoc_ssp_driver = {\n\t.driver = {\n\t\t.name = \"pxa-ssp-dai\",\n\t\t.of_match_table = of_match_ptr(pxa_ssp_of_ids),\n\t},\n\n\t.probe = asoc_ssp_probe,\n};\n\nmodule_platform_driver(asoc_ssp_driver);\n\n \nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"PXA SSP/PCM SoC Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa-ssp-dai\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}