{
  "module_name": "pxa2xx-ac97.c",
  "hash_id": "2eb251e02fb28b485e307aea5503574bb29f674d359e00c3791266edac4ee9ff",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/pxa/pxa2xx-ac97.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/pxa-dma.h>\n\n#include <sound/ac97/controller.h>\n#include <sound/core.h>\n#include <sound/ac97_codec.h>\n#include <sound/soc.h>\n#include <sound/pxa2xx-lib.h>\n#include <sound/dmaengine_pcm.h>\n\n#include <linux/platform_data/asoc-pxa.h>\n\n#define PCDR\t0x0040   \n#define MODR\t0x0140   \n#define MCDR\t0x0060   \n\nstatic void pxa2xx_ac97_warm_reset(struct ac97_controller *adrv)\n{\n\tpxa2xx_ac97_try_warm_reset();\n\n\tpxa2xx_ac97_finish_reset();\n}\n\nstatic void pxa2xx_ac97_cold_reset(struct ac97_controller *adrv)\n{\n\tpxa2xx_ac97_try_cold_reset();\n\n\tpxa2xx_ac97_finish_reset();\n}\n\nstatic int pxa2xx_ac97_read_actrl(struct ac97_controller *adrv, int slot,\n\t\t\t\t  unsigned short reg)\n{\n\treturn pxa2xx_ac97_read(slot, reg);\n}\n\nstatic int pxa2xx_ac97_write_actrl(struct ac97_controller *adrv, int slot,\n\t\t\t\t   unsigned short reg, unsigned short val)\n{\n\treturn pxa2xx_ac97_write(slot, reg, val);\n}\n\nstatic struct ac97_controller_ops pxa2xx_ac97_ops = {\n\t.read\t= pxa2xx_ac97_read_actrl,\n\t.write\t= pxa2xx_ac97_write_actrl,\n\t.warm_reset\t= pxa2xx_ac97_warm_reset,\n\t.reset\t= pxa2xx_ac97_cold_reset,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_stereo_in = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t.chan_name\t= \"pcm_pcm_stereo_in\",\n\t.maxburst\t= 32,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_stereo_out = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t.chan_name\t= \"pcm_pcm_stereo_out\",\n\t.maxburst\t= 32,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_aux_mono_out = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_2_BYTES,\n\t.chan_name\t= \"pcm_aux_mono_out\",\n\t.maxburst\t= 16,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_aux_mono_in = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_2_BYTES,\n\t.chan_name\t= \"pcm_aux_mono_in\",\n\t.maxburst\t= 16,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_ac97_pcm_mic_mono_in = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_2_BYTES,\n\t.chan_name\t= \"pcm_aux_mic_mono\",\n\t.maxburst\t= 16,\n};\n\nstatic int pxa2xx_ac97_hifi_startup(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_data = &pxa2xx_ac97_pcm_stereo_out;\n\telse\n\t\tdma_data = &pxa2xx_ac97_pcm_stereo_in;\n\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);\n\n\treturn 0;\n}\n\nstatic int pxa2xx_ac97_aux_startup(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_data = &pxa2xx_ac97_pcm_aux_mono_out;\n\telse\n\t\tdma_data = &pxa2xx_ac97_pcm_aux_mono_in;\n\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);\n\n\treturn 0;\n}\n\nstatic int pxa2xx_ac97_mic_startup(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -ENODEV;\n\tsnd_soc_dai_set_dma_data(cpu_dai, substream,\n\t\t\t\t &pxa2xx_ac97_pcm_mic_mono_in);\n\n\treturn 0;\n}\n\n#define PXA2XX_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \\\n\t\tSNDRV_PCM_RATE_48000)\n\nstatic const struct snd_soc_dai_ops pxa_ac97_hifi_dai_ops = {\n\t.startup\t= pxa2xx_ac97_hifi_startup,\n};\n\nstatic const struct snd_soc_dai_ops pxa_ac97_aux_dai_ops = {\n\t.startup\t= pxa2xx_ac97_aux_startup,\n};\n\nstatic const struct snd_soc_dai_ops pxa_ac97_mic_dai_ops = {\n\t.startup\t= pxa2xx_ac97_mic_startup,\n};\n\n \nstatic struct snd_soc_dai_driver pxa_ac97_dai_driver[] = {\n{\n\t.name = \"pxa2xx-ac97\",\n\t.playback = {\n\t\t.stream_name = \"AC97 Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PXA2XX_AC97_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.stream_name = \"AC97 Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PXA2XX_AC97_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &pxa_ac97_hifi_dai_ops,\n},\n{\n\t.name = \"pxa2xx-ac97-aux\",\n\t.playback = {\n\t\t.stream_name = \"AC97 Aux Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = PXA2XX_AC97_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.stream_name = \"AC97 Aux Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = PXA2XX_AC97_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &pxa_ac97_aux_dai_ops,\n},\n{\n\t.name = \"pxa2xx-ac97-mic\",\n\t.capture = {\n\t\t.stream_name = \"AC97 Mic Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = PXA2XX_AC97_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &pxa_ac97_mic_dai_ops,\n},\n};\n\nstatic const struct snd_soc_component_driver pxa_ac97_component = {\n\t.name\t\t= \"pxa-ac97\",\n\t.pcm_construct\t= pxa2xx_soc_pcm_new,\n\t.open\t\t= pxa2xx_soc_pcm_open,\n\t.close\t\t= pxa2xx_soc_pcm_close,\n\t.hw_params\t= pxa2xx_soc_pcm_hw_params,\n\t.prepare\t= pxa2xx_soc_pcm_prepare,\n\t.trigger\t= pxa2xx_soc_pcm_trigger,\n\t.pointer\t= pxa2xx_soc_pcm_pointer,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa2xx_ac97_dt_ids[] = {\n\t{ .compatible = \"marvell,pxa250-ac97\", },\n\t{ .compatible = \"marvell,pxa270-ac97\", },\n\t{ .compatible = \"marvell,pxa300-ac97\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, pxa2xx_ac97_dt_ids);\n\n#endif\n\nstatic int pxa2xx_ac97_dev_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct ac97_controller *ctrl;\n\tpxa2xx_audio_ops_t *pdata = pdev->dev.platform_data;\n\tstruct resource *regs;\n\tvoid **codecs_pdata;\n\n\tif (pdev->id != -1) {\n\t\tdev_err(&pdev->dev, \"PXA2xx has only one AC97 port.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn -ENXIO;\n\n\tpxa2xx_ac97_pcm_stereo_in.addr = regs->start + PCDR;\n\tpxa2xx_ac97_pcm_stereo_out.addr = regs->start + PCDR;\n\tpxa2xx_ac97_pcm_aux_mono_out.addr = regs->start + MODR;\n\tpxa2xx_ac97_pcm_aux_mono_in.addr = regs->start + MODR;\n\tpxa2xx_ac97_pcm_mic_mono_in.addr = regs->start + MCDR;\n\n\tret = pxa2xx_ac97_hw_probe(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"PXA2xx AC97 hw probe error (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcodecs_pdata = pdata ? pdata->codec_pdata : NULL;\n\tctrl = snd_ac97_controller_register(&pxa2xx_ac97_ops, &pdev->dev,\n\t\t\t\t\t    AC97_SLOTS_AVAILABLE_ALL,\n\t\t\t\t\t    codecs_pdata);\n\tif (IS_ERR(ctrl))\n\t\treturn PTR_ERR(ctrl);\n\n\tplatform_set_drvdata(pdev, ctrl);\n\t \n\treturn devm_snd_soc_register_component(&pdev->dev, &pxa_ac97_component,\n\t\t\t\t\t  pxa_ac97_dai_driver, ARRAY_SIZE(pxa_ac97_dai_driver));\n}\n\nstatic void pxa2xx_ac97_dev_remove(struct platform_device *pdev)\n{\n\tstruct ac97_controller *ctrl = platform_get_drvdata(pdev);\n\n\tsnd_ac97_controller_unregister(ctrl);\n\tpxa2xx_ac97_hw_remove(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int pxa2xx_ac97_dev_suspend(struct device *dev)\n{\n\treturn pxa2xx_ac97_hw_suspend();\n}\n\nstatic int pxa2xx_ac97_dev_resume(struct device *dev)\n{\n\treturn pxa2xx_ac97_hw_resume();\n}\n\nstatic SIMPLE_DEV_PM_OPS(pxa2xx_ac97_pm_ops,\n\t\tpxa2xx_ac97_dev_suspend, pxa2xx_ac97_dev_resume);\n#endif\n\nstatic struct platform_driver pxa2xx_ac97_driver = {\n\t.probe\t\t= pxa2xx_ac97_dev_probe,\n\t.remove_new\t= pxa2xx_ac97_dev_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa2xx-ac97\",\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &pxa2xx_ac97_pm_ops,\n#endif\n\t\t.of_match_table = of_match_ptr(pxa2xx_ac97_dt_ids),\n\t},\n};\n\nmodule_platform_driver(pxa2xx_ac97_driver);\n\nMODULE_AUTHOR(\"Nicolas Pitre\");\nMODULE_DESCRIPTION(\"AC97 driver for the Intel PXA2xx chip\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-ac97\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}