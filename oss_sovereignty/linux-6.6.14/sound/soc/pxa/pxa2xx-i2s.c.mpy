{
  "module_name": "pxa2xx-i2s.c",
  "hash_id": "eb80f8a43a5734494b25649721a3bcdf11078e5ac67cc53838444483913d4615",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/pxa/pxa2xx-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/pxa2xx-lib.h>\n#include <sound/dmaengine_pcm.h>\n\n#include <linux/platform_data/asoc-pxa.h>\n\n#include \"pxa2xx-i2s.h\"\n\n \n#define SACR0\t\t(0x0000)\t \n#define SACR1\t\t(0x0004)\t \n#define SASR0\t\t(0x000C)\t \n#define SAIMR\t\t(0x0014)\t \n#define SAICR\t\t(0x0018)\t \n#define SADIV\t\t(0x0060)\t \n#define SADR\t\t(0x0080)\t \n\n#define SACR0_RFTH(x)\t((x) << 12)\t \n#define SACR0_TFTH(x)\t((x) << 8)\t \n#define SACR0_STRF\t(1 << 5)\t \n#define SACR0_EFWR\t(1 << 4)\t \n#define SACR0_RST\t(1 << 3)\t \n#define SACR0_BCKD\t(1 << 2)\t \n#define SACR0_ENB\t(1 << 0)\t \n#define SACR1_ENLBF\t(1 << 5)\t \n#define SACR1_DRPL\t(1 << 4)\t \n#define SACR1_DREC\t(1 << 3)\t \n#define SACR1_AMSL\t(1 << 0)\t \n\n#define SASR0_I2SOFF\t(1 << 7)\t \n#define SASR0_ROR\t(1 << 6)\t \n#define SASR0_TUR\t(1 << 5)\t \n#define SASR0_RFS\t(1 << 4)\t \n#define SASR0_TFS\t(1 << 3)\t \n#define SASR0_BSY\t(1 << 2)\t \n#define SASR0_RNE\t(1 << 1)\t \n#define SASR0_TNF\t(1 << 0)\t \n\n#define SAICR_ROR\t(1 << 6)\t \n#define SAICR_TUR\t(1 << 5)\t \n\n#define SAIMR_ROR\t(1 << 6)\t \n#define SAIMR_TUR\t(1 << 5)\t \n#define SAIMR_RFS\t(1 << 4)\t \n#define SAIMR_TFS\t(1 << 3)\t \n\nstruct pxa_i2s_port {\n\tu32 sadiv;\n\tu32 sacr0;\n\tu32 sacr1;\n\tu32 saimr;\n\tint master;\n\tu32 fmt;\n};\nstatic struct pxa_i2s_port pxa_i2s;\nstatic struct clk *clk_i2s;\nstatic int clk_ena = 0;\nstatic void __iomem *i2s_reg_base;\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_i2s_pcm_stereo_out = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t.chan_name\t= \"tx\",\n\t.maxburst\t= 32,\n};\n\nstatic struct snd_dmaengine_dai_dma_data pxa2xx_i2s_pcm_stereo_in = {\n\t.addr_width\t= DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t.chan_name\t= \"rx\",\n\t.maxburst\t= 32,\n};\n\nstatic int pxa2xx_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\n\tif (IS_ERR(clk_i2s))\n\t\treturn PTR_ERR(clk_i2s);\n\n\tif (!snd_soc_dai_active(cpu_dai))\n\t\twritel(0, i2s_reg_base + SACR0);\n\n\treturn 0;\n}\n\n \nstatic int pxa_i2s_wait(void)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 16; i++)\n\t\treadl(i2s_reg_base + SADR);\n\treturn 0;\n}\n\nstatic int pxa2xx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\tunsigned int fmt)\n{\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpxa_i2s.fmt = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tpxa_i2s.fmt = SACR1_AMSL;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tpxa_i2s.master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tpxa_i2s.master = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int pxa2xx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tif (clk_id != PXA2XX_I2S_SYSCLK)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int pxa2xx_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\n\tif (WARN_ON(IS_ERR(clk_i2s)))\n\t\treturn -EINVAL;\n\tclk_prepare_enable(clk_i2s);\n\tclk_ena = 1;\n\tpxa_i2s_wait();\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_data = &pxa2xx_i2s_pcm_stereo_out;\n\telse\n\t\tdma_data = &pxa2xx_i2s_pcm_stereo_in;\n\n\tsnd_soc_dai_set_dma_data(dai, substream, dma_data);\n\n\t \n\tif (!(SACR0 & SACR0_ENB)) {\n\t\twritel(0, i2s_reg_base + SACR0);\n\t\tif (pxa_i2s.master)\n\t\t\twritel(readl(i2s_reg_base + SACR0) | (SACR0_BCKD), i2s_reg_base + SACR0);\n\n\t\twritel(readl(i2s_reg_base + SACR0) | (SACR0_RFTH(14) | SACR0_TFTH(1)), i2s_reg_base + SACR0);\n\t\twritel(readl(i2s_reg_base + SACR1) | (pxa_i2s.fmt), i2s_reg_base + SACR1);\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\twritel(readl(i2s_reg_base + SAIMR) | (SAIMR_TFS), i2s_reg_base + SAIMR);\n\telse\n\t\twritel(readl(i2s_reg_base + SAIMR) | (SAIMR_RFS), i2s_reg_base + SAIMR);\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\twritel(0x48, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 11025:\n\t\twritel(0x34, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 16000:\n\t\twritel(0x24, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 22050:\n\t\twritel(0x1a, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 44100:\n\t\twritel(0xd, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 48000:\n\t\twritel(0xc, i2s_reg_base + SADIV);\n\t\tbreak;\n\tcase 96000:  \n\t\twritel(0x6, i2s_reg_base + SADIV);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pxa2xx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\twritel(readl(i2s_reg_base + SACR1) & (~SACR1_DRPL), i2s_reg_base + SACR1);\n\t\telse\n\t\t\twritel(readl(i2s_reg_base + SACR1) & (~SACR1_DREC), i2s_reg_base + SACR1);\n\t\twritel(readl(i2s_reg_base + SACR0) | (SACR0_ENB), i2s_reg_base + SACR0);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void pxa2xx_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\twritel(readl(i2s_reg_base + SACR1) | (SACR1_DRPL), i2s_reg_base + SACR1);\n\t\twritel(readl(i2s_reg_base + SAIMR) & (~SAIMR_TFS), i2s_reg_base + SAIMR);\n\t} else {\n\t\twritel(readl(i2s_reg_base + SACR1) | (SACR1_DREC), i2s_reg_base + SACR1);\n\t\twritel(readl(i2s_reg_base + SAIMR) & (~SAIMR_RFS), i2s_reg_base + SAIMR);\n\t}\n\n\tif ((readl(i2s_reg_base + SACR1) & (SACR1_DREC | SACR1_DRPL)) == (SACR1_DREC | SACR1_DRPL)) {\n\t\twritel(readl(i2s_reg_base + SACR0) & (~SACR0_ENB), i2s_reg_base + SACR0);\n\t\tpxa_i2s_wait();\n\t\tif (clk_ena) {\n\t\t\tclk_disable_unprepare(clk_i2s);\n\t\t\tclk_ena = 0;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int pxa2xx_soc_pcm_suspend(struct snd_soc_component *component)\n{\n\t \n\tpxa_i2s.sacr0 = readl(i2s_reg_base + SACR0);\n\tpxa_i2s.sacr1 = readl(i2s_reg_base + SACR1);\n\tpxa_i2s.saimr = readl(i2s_reg_base + SAIMR);\n\tpxa_i2s.sadiv = readl(i2s_reg_base + SADIV);\n\n\t \n\twritel(readl(i2s_reg_base + SACR0) & (~SACR0_ENB), i2s_reg_base + SACR0);\n\tpxa_i2s_wait();\n\treturn 0;\n}\n\nstatic int pxa2xx_soc_pcm_resume(struct snd_soc_component *component)\n{\n\tpxa_i2s_wait();\n\n\twritel(pxa_i2s.sacr0 & ~SACR0_ENB, i2s_reg_base + SACR0);\n\twritel(pxa_i2s.sacr1, i2s_reg_base + SACR1);\n\twritel(pxa_i2s.saimr, i2s_reg_base + SAIMR);\n\twritel(pxa_i2s.sadiv, i2s_reg_base + SADIV);\n\n\twritel(pxa_i2s.sacr0, i2s_reg_base + SACR0);\n\n\treturn 0;\n}\n\n#else\n#define pxa2xx_soc_pcm_suspend\tNULL\n#define pxa2xx_soc_pcm_resume\tNULL\n#endif\n\nstatic int pxa2xx_i2s_probe(struct snd_soc_dai *dai)\n{\n\tclk_i2s = clk_get(dai->dev, \"I2SCLK\");\n\tif (IS_ERR(clk_i2s))\n\t\treturn PTR_ERR(clk_i2s);\n\n\t \n\twritel(SACR0_RST, i2s_reg_base + SACR0);\n\twritel(0, i2s_reg_base + SACR0);\n\t \n\twritel(SACR1_DRPL | SACR1_DREC, i2s_reg_base + SACR1);\n\t \n\twritel(readl(i2s_reg_base + SAIMR) & (~(SAIMR_RFS | SAIMR_TFS)), i2s_reg_base + SAIMR);\n\n\tsnd_soc_dai_init_dma_data(dai, &pxa2xx_i2s_pcm_stereo_out,\n\t\t&pxa2xx_i2s_pcm_stereo_in);\n\n\treturn 0;\n}\n\nstatic int  pxa2xx_i2s_remove(struct snd_soc_dai *dai)\n{\n\tclk_put(clk_i2s);\n\tclk_i2s = ERR_PTR(-ENOENT);\n\treturn 0;\n}\n\n#define PXA2XX_I2S_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 | \\\n\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000)\n\nstatic const struct snd_soc_dai_ops pxa_i2s_dai_ops = {\n\t.probe\t\t= pxa2xx_i2s_probe,\n\t.remove\t\t= pxa2xx_i2s_remove,\n\t.startup\t= pxa2xx_i2s_startup,\n\t.shutdown\t= pxa2xx_i2s_shutdown,\n\t.trigger\t= pxa2xx_i2s_trigger,\n\t.hw_params\t= pxa2xx_i2s_hw_params,\n\t.set_fmt\t= pxa2xx_i2s_set_dai_fmt,\n\t.set_sysclk\t= pxa2xx_i2s_set_dai_sysclk,\n};\n\nstatic struct snd_soc_dai_driver pxa_i2s_dai = {\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PXA2XX_I2S_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PXA2XX_I2S_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &pxa_i2s_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver pxa_i2s_component = {\n\t.name\t\t\t= \"pxa-i2s\",\n\t.pcm_construct\t\t= pxa2xx_soc_pcm_new,\n\t.open\t\t\t= pxa2xx_soc_pcm_open,\n\t.close\t\t\t= pxa2xx_soc_pcm_close,\n\t.hw_params\t\t= pxa2xx_soc_pcm_hw_params,\n\t.prepare\t\t= pxa2xx_soc_pcm_prepare,\n\t.trigger\t\t= pxa2xx_soc_pcm_trigger,\n\t.pointer\t\t= pxa2xx_soc_pcm_pointer,\n\t.suspend\t\t= pxa2xx_soc_pcm_suspend,\n\t.resume\t\t\t= pxa2xx_soc_pcm_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int pxa2xx_i2s_drv_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\n\ti2s_reg_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(i2s_reg_base))\n\t\treturn PTR_ERR(i2s_reg_base);\n\n\tpxa2xx_i2s_pcm_stereo_out.addr = res->start + SADR;\n\tpxa2xx_i2s_pcm_stereo_in.addr = res->start + SADR;\n\n\treturn devm_snd_soc_register_component(&pdev->dev, &pxa_i2s_component,\n\t\t\t\t\t       &pxa_i2s_dai, 1);\n}\n\nstatic struct platform_driver pxa2xx_i2s_driver = {\n\t.probe = pxa2xx_i2s_drv_probe,\n\n\t.driver = {\n\t\t.name = \"pxa2xx-i2s\",\n\t},\n};\n\nstatic int __init pxa2xx_i2s_init(void)\n{\n\tclk_i2s = ERR_PTR(-ENOENT);\n\treturn platform_driver_register(&pxa2xx_i2s_driver);\n}\n\nstatic void __exit pxa2xx_i2s_exit(void)\n{\n\tplatform_driver_unregister(&pxa2xx_i2s_driver);\n}\n\nmodule_init(pxa2xx_i2s_init);\nmodule_exit(pxa2xx_i2s_exit);\n\n \nMODULE_AUTHOR(\"Liam Girdwood, lrg@slimlogic.co.uk\");\nMODULE_DESCRIPTION(\"pxa2xx I2S SoC Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-i2s\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}