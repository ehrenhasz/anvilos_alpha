{
  "module_name": "soc-core.c",
  "hash_id": "6b8559f23867de647c4ce5c1b152755733c49aad06164f938f6bfc62063883a5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dpcm.h>\n#include <sound/soc-topology.h>\n#include <sound/soc-link.h>\n#include <sound/initval.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/asoc.h>\n\nstatic DEFINE_MUTEX(client_mutex);\nstatic LIST_HEAD(component_list);\nstatic LIST_HEAD(unbind_card_list);\n\n#define for_each_component(component)\t\t\t\\\n\tlist_for_each_entry(component, &component_list, list)\n\n \nstruct snd_soc_dai_link_component null_dailink_component[0];\nEXPORT_SYMBOL_GPL(null_dailink_component);\n\n \nstatic int pmdown_time = 5000;\nmodule_param(pmdown_time, int, 0);\nMODULE_PARM_DESC(pmdown_time, \"DAPM stream powerdown time (msecs)\");\n\nstatic ssize_t pmdown_time_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", rtd->pmdown_time);\n}\n\nstatic ssize_t pmdown_time_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtol(buf, 10, &rtd->pmdown_time);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(pmdown_time);\n\nstatic struct attribute *soc_dev_attrs[] = {\n\t&dev_attr_pmdown_time.attr,\n\tNULL\n};\n\nstatic umode_t soc_dev_attr_is_visible(struct kobject *kobj,\n\t\t\t\t       struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct snd_soc_pcm_runtime *rtd = dev_get_drvdata(dev);\n\n\tif (!rtd)\n\t\treturn 0;\n\n\tif (attr == &dev_attr_pmdown_time.attr)\n\t\treturn attr->mode;  \n\treturn rtd->dai_link->num_codecs ? attr->mode : 0;  \n}\n\nstatic const struct attribute_group soc_dapm_dev_group = {\n\t.attrs = soc_dapm_dev_attrs,\n\t.is_visible = soc_dev_attr_is_visible,\n};\n\nstatic const struct attribute_group soc_dev_group = {\n\t.attrs = soc_dev_attrs,\n\t.is_visible = soc_dev_attr_is_visible,\n};\n\nstatic const struct attribute_group *soc_dev_attr_groups[] = {\n\t&soc_dapm_dev_group,\n\t&soc_dev_group,\n\tNULL\n};\n\n#ifdef CONFIG_DEBUG_FS\nstruct dentry *snd_soc_debugfs_root;\nEXPORT_SYMBOL_GPL(snd_soc_debugfs_root);\n\nstatic void soc_init_component_debugfs(struct snd_soc_component *component)\n{\n\tif (!component->card->debugfs_card_root)\n\t\treturn;\n\n\tif (component->debugfs_prefix) {\n\t\tchar *name;\n\n\t\tname = kasprintf(GFP_KERNEL, \"%s:%s\",\n\t\t\tcomponent->debugfs_prefix, component->name);\n\t\tif (name) {\n\t\t\tcomponent->debugfs_root = debugfs_create_dir(name,\n\t\t\t\tcomponent->card->debugfs_card_root);\n\t\t\tkfree(name);\n\t\t}\n\t} else {\n\t\tcomponent->debugfs_root = debugfs_create_dir(component->name,\n\t\t\t\tcomponent->card->debugfs_card_root);\n\t}\n\n\tsnd_soc_dapm_debugfs_init(snd_soc_component_get_dapm(component),\n\t\tcomponent->debugfs_root);\n}\n\nstatic void soc_cleanup_component_debugfs(struct snd_soc_component *component)\n{\n\tif (!component->debugfs_root)\n\t\treturn;\n\tdebugfs_remove_recursive(component->debugfs_root);\n\tcomponent->debugfs_root = NULL;\n}\n\nstatic int dai_list_show(struct seq_file *m, void *v)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *dai;\n\n\tmutex_lock(&client_mutex);\n\n\tfor_each_component(component)\n\t\tfor_each_component_dais(component, dai)\n\t\t\tseq_printf(m, \"%s\\n\", dai->name);\n\n\tmutex_unlock(&client_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dai_list);\n\nstatic int component_list_show(struct seq_file *m, void *v)\n{\n\tstruct snd_soc_component *component;\n\n\tmutex_lock(&client_mutex);\n\n\tfor_each_component(component)\n\t\tseq_printf(m, \"%s\\n\", component->name);\n\n\tmutex_unlock(&client_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(component_list);\n\nstatic void soc_init_card_debugfs(struct snd_soc_card *card)\n{\n\tcard->debugfs_card_root = debugfs_create_dir(card->name,\n\t\t\t\t\t\t     snd_soc_debugfs_root);\n\n\tdebugfs_create_u32(\"dapm_pop_time\", 0644, card->debugfs_card_root,\n\t\t\t   &card->pop_time);\n\n\tsnd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);\n}\n\nstatic void soc_cleanup_card_debugfs(struct snd_soc_card *card)\n{\n\tdebugfs_remove_recursive(card->debugfs_card_root);\n\tcard->debugfs_card_root = NULL;\n}\n\nstatic void snd_soc_debugfs_init(void)\n{\n\tsnd_soc_debugfs_root = debugfs_create_dir(\"asoc\", NULL);\n\n\tdebugfs_create_file(\"dais\", 0444, snd_soc_debugfs_root, NULL,\n\t\t\t    &dai_list_fops);\n\n\tdebugfs_create_file(\"components\", 0444, snd_soc_debugfs_root, NULL,\n\t\t\t    &component_list_fops);\n}\n\nstatic void snd_soc_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(snd_soc_debugfs_root);\n}\n\n#else\n\nstatic inline void soc_init_component_debugfs(struct snd_soc_component *component) { }\nstatic inline void soc_cleanup_component_debugfs(struct snd_soc_component *component) { }\nstatic inline void soc_init_card_debugfs(struct snd_soc_card *card) { }\nstatic inline void soc_cleanup_card_debugfs(struct snd_soc_card *card) { }\nstatic inline void snd_soc_debugfs_init(void) { }\nstatic inline void snd_soc_debugfs_exit(void) { }\n\n#endif\n\nstatic int snd_soc_is_match_dai_args(struct of_phandle_args *args1,\n\t\t\t\t     struct of_phandle_args *args2)\n{\n\tif (!args1 || !args2)\n\t\treturn 0;\n\n\tif (args1->np != args2->np)\n\t\treturn 0;\n\n\tfor (int i = 0; i < args1->args_count; i++)\n\t\tif (args1->args[i] != args2->args[i])\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline int snd_soc_dlc_component_is_empty(struct snd_soc_dai_link_component *dlc)\n{\n\treturn !(dlc->dai_args || dlc->name || dlc->of_node);\n}\n\nstatic inline int snd_soc_dlc_component_is_invalid(struct snd_soc_dai_link_component *dlc)\n{\n\treturn (dlc->name && dlc->of_node);\n}\n\nstatic inline int snd_soc_dlc_dai_is_empty(struct snd_soc_dai_link_component *dlc)\n{\n\treturn !(dlc->dai_args || dlc->dai_name);\n}\n\nstatic int snd_soc_is_matching_dai(const struct snd_soc_dai_link_component *dlc,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tif (!dlc)\n\t\treturn 0;\n\n\tif (dlc->dai_args)\n\t\treturn snd_soc_is_match_dai_args(dai->driver->dai_args, dlc->dai_args);\n\n\tif (!dlc->dai_name)\n\t\treturn 1;\n\n\t \n\n\tif (strcmp(dlc->dai_name, dai->name) == 0)\n\t\treturn 1;\n\n\tif (dai->driver->name &&\n\t    strcmp(dai->driver->name, dlc->dai_name) == 0)\n\t\treturn 1;\n\n\tif (dai->component->name &&\n\t    strcmp(dlc->dai_name, dai->component->name) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nconst char *snd_soc_dai_name_get(struct snd_soc_dai *dai)\n{\n\t \n\tif (dai->name)\n\t\treturn dai->name;\n\n\tif (dai->driver->name)\n\t\treturn dai->driver->name;\n\n\tif (dai->component->name)\n\t\treturn dai->component->name;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_name_get);\n\nstatic int snd_soc_rtd_add_component(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t     struct snd_soc_component *component)\n{\n\tstruct snd_soc_component *comp;\n\tint i;\n\n\tfor_each_rtd_components(rtd, i, comp) {\n\t\t \n\t\tif (comp == component)\n\t\t\treturn 0;\n\t}\n\n\t \n\trtd->components[rtd->num_components] = component;\n\trtd->num_components++;\n\n\treturn 0;\n}\n\nstruct snd_soc_component *snd_soc_rtdcom_lookup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t\tconst char *driver_name)\n{\n\tstruct snd_soc_component *component;\n\tint i;\n\n\tif (!driver_name)\n\t\treturn NULL;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tconst char *component_name = component->driver->name;\n\n\t\tif (!component_name)\n\t\t\tcontinue;\n\n\t\tif ((component_name == driver_name) ||\n\t\t    strcmp(component_name, driver_name) == 0)\n\t\t\treturn component;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_rtdcom_lookup);\n\nstruct snd_soc_component\n*snd_soc_lookup_component_nolocked(struct device *dev, const char *driver_name)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_component *found_component;\n\n\tfound_component = NULL;\n\tfor_each_component(component) {\n\t\tif ((dev == component->dev) &&\n\t\t    (!driver_name ||\n\t\t     (driver_name == component->driver->name) ||\n\t\t     (strcmp(component->driver->name, driver_name) == 0))) {\n\t\t\tfound_component = component;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found_component;\n}\nEXPORT_SYMBOL_GPL(snd_soc_lookup_component_nolocked);\n\nstruct snd_soc_component *snd_soc_lookup_component(struct device *dev,\n\t\t\t\t\t\t   const char *driver_name)\n{\n\tstruct snd_soc_component *component;\n\n\tmutex_lock(&client_mutex);\n\tcomponent = snd_soc_lookup_component_nolocked(dev, driver_name);\n\tmutex_unlock(&client_mutex);\n\n\treturn component;\n}\nEXPORT_SYMBOL_GPL(snd_soc_lookup_component);\n\nstruct snd_soc_pcm_runtime\n*snd_soc_get_pcm_runtime(struct snd_soc_card *card,\n\t\t\t struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tif (rtd->dai_link == dai_link)\n\t\t\treturn rtd;\n\t}\n\tdev_dbg(card->dev, \"ASoC: failed to find rtd %s\\n\", dai_link->name);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_pcm_runtime);\n\n \nvoid snd_soc_close_delayed_work(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint playback = SNDRV_PCM_STREAM_PLAYBACK;\n\n\tsnd_soc_dpcm_mutex_lock(rtd);\n\n\tdev_dbg(rtd->dev,\n\t\t\"ASoC: pop wq checking: %s status: %s waiting: %s\\n\",\n\t\tcodec_dai->driver->playback.stream_name,\n\t\tsnd_soc_dai_stream_active(codec_dai, playback) ?\n\t\t\"active\" : \"inactive\",\n\t\trtd->pop_wait ? \"yes\" : \"no\");\n\n\t \n\tif (rtd->pop_wait == 1) {\n\t\trtd->pop_wait = 0;\n\t\tsnd_soc_dapm_stream_event(rtd, playback,\n\t\t\t\t\t  SND_SOC_DAPM_STREAM_STOP);\n\t}\n\n\tsnd_soc_dpcm_mutex_unlock(rtd);\n}\nEXPORT_SYMBOL_GPL(snd_soc_close_delayed_work);\n\nstatic void soc_release_rtd_dev(struct device *dev)\n{\n\t \n\tkfree(dev);\n}\n\nstatic void soc_free_pcm_runtime(struct snd_soc_pcm_runtime *rtd)\n{\n\tif (!rtd)\n\t\treturn;\n\n\tlist_del(&rtd->list);\n\n\tif (delayed_work_pending(&rtd->delayed_work))\n\t\tflush_delayed_work(&rtd->delayed_work);\n\tsnd_soc_pcm_component_free(rtd);\n\n\t \n\tdevice_unregister(rtd->dev);\n}\n\nstatic void close_delayed_work(struct work_struct *work) {\n\tstruct snd_soc_pcm_runtime *rtd =\n\t\t\tcontainer_of(work, struct snd_soc_pcm_runtime,\n\t\t\t\t     delayed_work.work);\n\n\tif (rtd->close_delayed_work_func)\n\t\trtd->close_delayed_work_func(rtd);\n}\n\nstatic struct snd_soc_pcm_runtime *soc_new_pcm_runtime(\n\tstruct snd_soc_card *card, struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_component *component;\n\tstruct device *dev;\n\tint ret;\n\tint stream;\n\n\t \n\tdev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tdev->parent\t= card->dev;\n\tdev->release\t= soc_release_rtd_dev;\n\n\tdev_set_name(dev, \"%s\", dai_link->name);\n\n\tret = device_register(dev);\n\tif (ret < 0) {\n\t\tput_device(dev);  \n\t\treturn NULL;\n\t}\n\n\t \n\trtd = devm_kzalloc(dev,\n\t\t\t   sizeof(*rtd) +\n\t\t\t   sizeof(component) * (dai_link->num_cpus +\n\t\t\t\t\t\t dai_link->num_codecs +\n\t\t\t\t\t\t dai_link->num_platforms),\n\t\t\t   GFP_KERNEL);\n\tif (!rtd) {\n\t\tdevice_unregister(dev);\n\t\treturn NULL;\n\t}\n\n\trtd->dev = dev;\n\tINIT_LIST_HEAD(&rtd->list);\n\tfor_each_pcm_streams(stream) {\n\t\tINIT_LIST_HEAD(&rtd->dpcm[stream].be_clients);\n\t\tINIT_LIST_HEAD(&rtd->dpcm[stream].fe_clients);\n\t}\n\tdev_set_drvdata(dev, rtd);\n\tINIT_DELAYED_WORK(&rtd->delayed_work, close_delayed_work);\n\n\t \n\trtd->dais = devm_kcalloc(dev, dai_link->num_cpus + dai_link->num_codecs,\n\t\t\t\t\tsizeof(struct snd_soc_dai *),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!rtd->dais)\n\t\tgoto free_rtd;\n\n\t \n\trtd->card\t= card;\n\trtd->dai_link\t= dai_link;\n\trtd->num\t= card->num_rtd++;\n\trtd->pmdown_time = pmdown_time;\t\t\t \n\n\t \n\tlist_add_tail(&rtd->list, &card->rtd_list);\n\n\tret = device_add_groups(dev, soc_dev_attr_groups);\n\tif (ret < 0)\n\t\tgoto free_rtd;\n\n\treturn rtd;\n\nfree_rtd:\n\tsoc_free_pcm_runtime(rtd);\n\treturn NULL;\n}\n\nstatic void snd_soc_flush_all_delayed_work(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tfor_each_card_rtds(card, rtd)\n\t\tflush_delayed_work(&rtd->delayed_work);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void soc_playback_digital_mute(struct snd_soc_card *card, int mute)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai *dai;\n\tint playback = SNDRV_PCM_STREAM_PLAYBACK;\n\tint i;\n\n\tfor_each_card_rtds(card, rtd) {\n\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tcontinue;\n\n\t\tfor_each_rtd_dais(rtd, i, dai) {\n\t\t\tif (snd_soc_dai_stream_active(dai, playback))\n\t\t\t\tsnd_soc_dai_digital_mute(dai, mute, playback);\n\t\t}\n\t}\n}\n\nstatic void soc_dapm_suspend_resume(struct snd_soc_card *card, int event)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint stream;\n\n\tfor_each_card_rtds(card, rtd) {\n\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tcontinue;\n\n\t\tfor_each_pcm_streams(stream)\n\t\t\tsnd_soc_dapm_stream_event(rtd, stream, event);\n\t}\n}\n\n \nint snd_soc_suspend(struct device *dev)\n{\n\tstruct snd_soc_card *card = dev_get_drvdata(dev);\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint i;\n\n\t \n\tif (!snd_soc_card_is_instantiated(card))\n\t\treturn 0;\n\n\t \n\tsnd_power_wait(card->snd_card);\n\n\t \n\tsnd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);\n\n\t \n\tsoc_playback_digital_mute(card, 1);\n\n\t \n\tfor_each_card_rtds(card, rtd) {\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tcontinue;\n\n\t\tsnd_pcm_suspend_all(rtd->pcm);\n\t}\n\n\tsnd_soc_card_suspend_pre(card);\n\n\t \n\tsnd_soc_flush_all_delayed_work(card);\n\n\tsoc_dapm_suspend_resume(card, SND_SOC_DAPM_STREAM_SUSPEND);\n\n\t \n\tdapm_mark_endpoints_dirty(card);\n\tsnd_soc_dapm_sync(&card->dapm);\n\n\t \n\tfor_each_card_rtds(card, rtd) {\n\n\t\tif (rtd->dai_link->ignore_suspend)\n\t\t\tcontinue;\n\n\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\tstruct snd_soc_dapm_context *dapm =\n\t\t\t\tsnd_soc_component_get_dapm(component);\n\n\t\t\t \n\t\t\tif (snd_soc_component_is_suspended(component))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tswitch (snd_soc_dapm_get_bias_level(dapm)) {\n\t\t\tcase SND_SOC_BIAS_STANDBY:\n\t\t\t\t \n\t\t\t\tif (dapm->idle_bias_off) {\n\t\t\t\t\tdev_dbg(component->dev,\n\t\t\t\t\t\t\"ASoC: idle_bias_off CODEC on over suspend\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\n\t\t\tcase SND_SOC_BIAS_OFF:\n\t\t\t\tsnd_soc_component_suspend(component);\n\t\t\t\tif (component->regmap)\n\t\t\t\t\tregcache_mark_dirty(component->regmap);\n\t\t\t\t \n\t\t\t\tpinctrl_pm_select_sleep_state(component->dev);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_dbg(component->dev,\n\t\t\t\t\t\"ASoC: COMPONENT is on over suspend\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_soc_card_suspend_post(card);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_suspend);\n\n \nstatic void soc_resume_deferred(struct work_struct *work)\n{\n\tstruct snd_soc_card *card =\n\t\t\tcontainer_of(work, struct snd_soc_card,\n\t\t\t\t     deferred_resume_work);\n\tstruct snd_soc_component *component;\n\n\t \n\n\tdev_dbg(card->dev, \"ASoC: starting resume work\\n\");\n\n\t \n\tsnd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);\n\n\tsnd_soc_card_resume_pre(card);\n\n\tfor_each_card_components(card, component) {\n\t\tif (snd_soc_component_is_suspended(component))\n\t\t\tsnd_soc_component_resume(component);\n\t}\n\n\tsoc_dapm_suspend_resume(card, SND_SOC_DAPM_STREAM_RESUME);\n\n\t \n\tsoc_playback_digital_mute(card, 0);\n\n\tsnd_soc_card_resume_post(card);\n\n\tdev_dbg(card->dev, \"ASoC: resume work completed\\n\");\n\n\t \n\tdapm_mark_endpoints_dirty(card);\n\tsnd_soc_dapm_sync(&card->dapm);\n\n\t \n\tsnd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);\n}\n\n \nint snd_soc_resume(struct device *dev)\n{\n\tstruct snd_soc_card *card = dev_get_drvdata(dev);\n\tstruct snd_soc_component *component;\n\n\t \n\tif (!snd_soc_card_is_instantiated(card))\n\t\treturn 0;\n\n\t \n\tfor_each_card_components(card, component)\n\t\tif (snd_soc_component_active(component))\n\t\t\tpinctrl_pm_select_default_state(component->dev);\n\n\tdev_dbg(dev, \"ASoC: Scheduling resume work\\n\");\n\tif (!schedule_work(&card->deferred_resume_work))\n\t\tdev_err(dev, \"ASoC: resume work item may be lost\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_resume);\n\nstatic void soc_resume_init(struct snd_soc_card *card)\n{\n\t \n\tINIT_WORK(&card->deferred_resume_work, soc_resume_deferred);\n}\n#else\n#define snd_soc_suspend NULL\n#define snd_soc_resume NULL\nstatic inline void soc_resume_init(struct snd_soc_card *card) { }\n#endif\n\nstatic struct device_node\n*soc_component_to_node(struct snd_soc_component *component)\n{\n\tstruct device_node *of_node;\n\n\tof_node = component->dev->of_node;\n\tif (!of_node && component->dev->parent)\n\t\tof_node = component->dev->parent->of_node;\n\n\treturn of_node;\n}\n\nstruct of_phandle_args *snd_soc_copy_dai_args(struct device *dev, struct of_phandle_args *args)\n{\n\tstruct of_phandle_args *ret = devm_kzalloc(dev, sizeof(*ret), GFP_KERNEL);\n\n\tif (!ret)\n\t\treturn NULL;\n\n\t*ret = *args;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_copy_dai_args);\n\nstatic int snd_soc_is_matching_component(\n\tconst struct snd_soc_dai_link_component *dlc,\n\tstruct snd_soc_component *component)\n{\n\tstruct device_node *component_of_node;\n\n\tif (!dlc)\n\t\treturn 0;\n\n\tif (dlc->dai_args) {\n\t\tstruct snd_soc_dai *dai;\n\n\t\tfor_each_component_dais(component, dai)\n\t\t\tif (snd_soc_is_matching_dai(dlc, dai))\n\t\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\tcomponent_of_node = soc_component_to_node(component);\n\n\tif (dlc->of_node && component_of_node != dlc->of_node)\n\t\treturn 0;\n\tif (dlc->name && strcmp(component->name, dlc->name))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic struct snd_soc_component *soc_find_component(\n\tconst struct snd_soc_dai_link_component *dlc)\n{\n\tstruct snd_soc_component *component;\n\n\tlockdep_assert_held(&client_mutex);\n\n\t \n\tfor_each_component(component)\n\t\tif (snd_soc_is_matching_component(dlc, component))\n\t\t\treturn component;\n\n\treturn NULL;\n}\n\n \nstruct snd_soc_dai *snd_soc_find_dai(\n\tconst struct snd_soc_dai_link_component *dlc)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai *dai;\n\n\tlockdep_assert_held(&client_mutex);\n\n\t \n\tfor_each_component(component)\n\t\tif (snd_soc_is_matching_component(dlc, component))\n\t\t\tfor_each_component_dais(component, dai)\n\t\t\t\tif (snd_soc_is_matching_dai(dlc, dai))\n\t\t\t\t\treturn dai;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(snd_soc_find_dai);\n\nstruct snd_soc_dai *snd_soc_find_dai_with_mutex(\n\tconst struct snd_soc_dai_link_component *dlc)\n{\n\tstruct snd_soc_dai *dai;\n\n\tmutex_lock(&client_mutex);\n\tdai = snd_soc_find_dai(dlc);\n\tmutex_unlock(&client_mutex);\n\n\treturn dai;\n}\nEXPORT_SYMBOL_GPL(snd_soc_find_dai_with_mutex);\n\nstatic int soc_dai_link_sanity_check(struct snd_soc_card *card,\n\t\t\t\t     struct snd_soc_dai_link *link)\n{\n\tint i;\n\tstruct snd_soc_dai_link_component *dlc;\n\n\t \n\tfor_each_link_codecs(link, i, dlc) {\n\t\t \n\t\tif (snd_soc_dlc_component_is_invalid(dlc))\n\t\t\tgoto component_invalid;\n\n\t\tif (snd_soc_dlc_component_is_empty(dlc))\n\t\t\tgoto component_empty;\n\n\t\t \n\t\tif (snd_soc_dlc_dai_is_empty(dlc))\n\t\t\tgoto dai_empty;\n\n\t\t \n\t\tif (!soc_find_component(dlc))\n\t\t\tgoto component_not_found;\n\t}\n\n\t \n\tfor_each_link_platforms(link, i, dlc) {\n\t\t \n\t\tif (snd_soc_dlc_component_is_invalid(dlc))\n\t\t\tgoto component_invalid;\n\n\t\tif (snd_soc_dlc_component_is_empty(dlc))\n\t\t\tgoto component_empty;\n\n\t\t \n\t\tif (!soc_find_component(dlc))\n\t\t\tgoto component_not_found;\n\t}\n\n\t \n\tfor_each_link_cpus(link, i, dlc) {\n\t\t \n\t\tif (snd_soc_dlc_component_is_invalid(dlc))\n\t\t\tgoto component_invalid;\n\n\n\t\tif (snd_soc_dlc_component_is_empty(dlc)) {\n\t\t\t \n\t\t\tif (snd_soc_dlc_dai_is_empty(dlc))\n\t\t\t\tgoto component_dai_empty;\n\t\t} else {\n\t\t\t \n\t\t\tif (!soc_find_component(dlc))\n\t\t\t\tgoto component_not_found;\n\t\t}\n\t}\n\n\treturn 0;\n\ncomponent_invalid:\n\tdev_err(card->dev, \"ASoC: Both Component name/of_node are set for %s\\n\", link->name);\n\treturn -EINVAL;\n\ncomponent_empty:\n\tdev_err(card->dev, \"ASoC: Neither Component name/of_node are set for %s\\n\", link->name);\n\treturn -EINVAL;\n\ncomponent_not_found:\n\tdev_dbg(card->dev, \"ASoC: Component %s not found for link %s\\n\", dlc->name, link->name);\n\treturn -EPROBE_DEFER;\n\ndai_empty:\n\tdev_err(card->dev, \"ASoC: DAI name is not set for %s\\n\", link->name);\n\treturn -EINVAL;\n\ncomponent_dai_empty:\n\tdev_err(card->dev, \"ASoC: Neither DAI/Component name/of_node are set for %s\\n\", link->name);\n\treturn -EINVAL;\n}\n\n \nvoid snd_soc_remove_pcm_runtime(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tlockdep_assert_held(&client_mutex);\n\n\t \n\tsnd_soc_card_remove_dai_link(card, rtd->dai_link);\n\n\tsoc_free_pcm_runtime(rtd);\n}\nEXPORT_SYMBOL_GPL(snd_soc_remove_pcm_runtime);\n\n \nstatic int snd_soc_add_pcm_runtime(struct snd_soc_card *card,\n\t\t\t\t   struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_dai_link_component *codec, *platform, *cpu;\n\tstruct snd_soc_component *component;\n\tint i, ret;\n\n\tlockdep_assert_held(&client_mutex);\n\n\t \n\tret = snd_soc_card_add_dai_link(card, dai_link);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (dai_link->ignore)\n\t\treturn 0;\n\n\tdev_dbg(card->dev, \"ASoC: binding %s\\n\", dai_link->name);\n\n\tret = soc_dai_link_sanity_check(card, dai_link);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trtd = soc_new_pcm_runtime(card, dai_link);\n\tif (!rtd)\n\t\treturn -ENOMEM;\n\n\tfor_each_link_cpus(dai_link, i, cpu) {\n\t\tasoc_rtd_to_cpu(rtd, i) = snd_soc_find_dai(cpu);\n\t\tif (!asoc_rtd_to_cpu(rtd, i)) {\n\t\t\tdev_info(card->dev, \"ASoC: CPU DAI %s not registered\\n\",\n\t\t\t\t cpu->dai_name);\n\t\t\tgoto _err_defer;\n\t\t}\n\t\tsnd_soc_rtd_add_component(rtd, asoc_rtd_to_cpu(rtd, i)->component);\n\t}\n\n\t \n\tfor_each_link_codecs(dai_link, i, codec) {\n\t\tasoc_rtd_to_codec(rtd, i) = snd_soc_find_dai(codec);\n\t\tif (!asoc_rtd_to_codec(rtd, i)) {\n\t\t\tdev_info(card->dev, \"ASoC: CODEC DAI %s not registered\\n\",\n\t\t\t\t codec->dai_name);\n\t\t\tgoto _err_defer;\n\t\t}\n\n\t\tsnd_soc_rtd_add_component(rtd, asoc_rtd_to_codec(rtd, i)->component);\n\t}\n\n\t \n\tfor_each_link_platforms(dai_link, i, platform) {\n\t\tfor_each_component(component) {\n\t\t\tif (!snd_soc_is_matching_component(platform, component))\n\t\t\t\tcontinue;\n\n\t\t\tsnd_soc_rtd_add_component(rtd, component);\n\t\t}\n\t}\n\n\treturn 0;\n\n_err_defer:\n\tsnd_soc_remove_pcm_runtime(card, rtd);\n\treturn -EPROBE_DEFER;\n}\n\nint snd_soc_add_pcm_runtimes(struct snd_soc_card *card,\n\t\t\t     struct snd_soc_dai_link *dai_link,\n\t\t\t     int num_dai_link)\n{\n\tfor (int i = 0; i < num_dai_link; i++) {\n\t\tint ret = snd_soc_add_pcm_runtime(card, dai_link + i);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_add_pcm_runtimes);\n\nstatic void snd_soc_runtime_get_dai_fmt(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tstruct snd_soc_dai *dai, *not_used;\n\tu64 pos, possible_fmt;\n\tunsigned int mask = 0, dai_fmt = 0;\n\tint i, j, priority, pri, until;\n\n\t \n\tuntil = snd_soc_dai_get_fmt_max_priority(rtd);\n\tfor (priority = 1; priority <= until; priority++) {\n\t\tfor_each_rtd_dais(rtd, j, not_used) {\n\n\t\t\tpossible_fmt = ULLONG_MAX;\n\t\t\tfor_each_rtd_dais(rtd, i, dai) {\n\t\t\t\tu64 fmt = 0;\n\n\t\t\t\tpri = (j >= i) ? priority : priority - 1;\n\t\t\t\tfmt = snd_soc_dai_get_fmt(dai, pri);\n\t\t\t\tpossible_fmt &= fmt;\n\t\t\t}\n\t\t\tif (possible_fmt)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\t \n\treturn;\nfound:\n\t \n\tfor (i = 63; i >= 0; i--) {\n\t\tpos = 1ULL << i;\n\t\tswitch (possible_fmt & pos) {\n\t\t \n\t\tcase SND_SOC_POSSIBLE_DAIFMT_I2S:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_RIGHT_J:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_LEFT_J:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_DSP_A:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_DSP_B:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_AC97:\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_PDM:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_FORMAT_MASK) | i;\n\t\t\tbreak;\n\t\t \n\t\tcase SND_SOC_POSSIBLE_DAIFMT_CONT:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_MASK) | SND_SOC_DAIFMT_CONT;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_GATED:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_MASK) | SND_SOC_DAIFMT_GATED;\n\t\t\tbreak;\n\t\t \n\t\tcase SND_SOC_POSSIBLE_DAIFMT_NB_NF:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_INV_MASK) | SND_SOC_DAIFMT_NB_NF;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_NB_IF:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_INV_MASK) | SND_SOC_DAIFMT_NB_IF;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_IB_NF:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_INV_MASK) | SND_SOC_DAIFMT_IB_NF;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_IB_IF:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_INV_MASK) | SND_SOC_DAIFMT_IB_IF;\n\t\t\tbreak;\n\t\t \n\t\tcase SND_SOC_POSSIBLE_DAIFMT_CBP_CFP:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) | SND_SOC_DAIFMT_CBP_CFP;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_CBC_CFP:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) | SND_SOC_DAIFMT_CBC_CFP;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_CBP_CFC:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) | SND_SOC_DAIFMT_CBP_CFC;\n\t\t\tbreak;\n\t\tcase SND_SOC_POSSIBLE_DAIFMT_CBC_CFC:\n\t\t\tdai_fmt = (dai_fmt & ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) | SND_SOC_DAIFMT_CBC_CFC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!(dai_link->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK))\n\t\tmask |= SND_SOC_DAIFMT_FORMAT_MASK;\n\tif (!(dai_link->dai_fmt & SND_SOC_DAIFMT_CLOCK_MASK))\n\t\tmask |= SND_SOC_DAIFMT_CLOCK_MASK;\n\tif (!(dai_link->dai_fmt & SND_SOC_DAIFMT_INV_MASK))\n\t\tmask |= SND_SOC_DAIFMT_INV_MASK;\n\tif (!(dai_link->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK))\n\t\tmask |= SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\n\tdai_link->dai_fmt |= (dai_fmt & mask);\n}\n\n \nint snd_soc_runtime_set_dai_fmt(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\tunsigned int dai_fmt)\n{\n\tstruct snd_soc_dai *cpu_dai;\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned int i;\n\tint ret;\n\n\tif (!dai_fmt)\n\t\treturn 0;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_fmt(codec_dai, dai_fmt);\n\t\tif (ret != 0 && ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdai_fmt = snd_soc_daifmt_clock_provider_flipped(dai_fmt);\n\n\tfor_each_rtd_cpu_dais(rtd, i, cpu_dai) {\n\t\tret = snd_soc_dai_set_fmt(cpu_dai, dai_fmt);\n\t\tif (ret != 0 && ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_runtime_set_dai_fmt);\n\nstatic int soc_init_pcm_runtime(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_component *component;\n\tint ret, num, i;\n\n\t \n\tret = snd_soc_link_init(rtd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnd_soc_runtime_get_dai_fmt(rtd);\n\tret = snd_soc_runtime_set_dai_fmt(rtd, dai_link->dai_fmt);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tsoc_dpcm_debugfs_add(rtd);\n\n\tnum = rtd->num;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (!component->driver->use_dai_pcm_id)\n\t\t\tcontinue;\n\n\t\tif (rtd->dai_link->no_pcm)\n\t\t\tnum += component->driver->be_pcm_base;\n\t\telse\n\t\t\tnum = rtd->dai_link->id;\n\t}\n\n\t \n\tret = snd_soc_dai_compress_new(cpu_dai, rtd, num);\n\tif (ret != -ENOTSUPP)\n\t\tgoto err;\n\n\t \n\tret = soc_new_pcm(rtd, num);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"ASoC: can't create pcm %s :%d\\n\",\n\t\t\tdai_link->stream_name, ret);\n\t\tgoto err;\n\t}\n\n\tret = snd_soc_pcm_dai_new(rtd);\n\tif (ret < 0)\n\t\tgoto err;\n\n\trtd->initialized = true;\n\n\treturn 0;\nerr:\n\tsnd_soc_link_exit(rtd);\n\treturn ret;\n}\n\nstatic void soc_set_name_prefix(struct snd_soc_card *card,\n\t\t\t\tstruct snd_soc_component *component)\n{\n\tstruct device_node *of_node = soc_component_to_node(component);\n\tconst char *str;\n\tint ret, i;\n\n\tfor (i = 0; i < card->num_configs; i++) {\n\t\tstruct snd_soc_codec_conf *map = &card->codec_conf[i];\n\n\t\tif (snd_soc_is_matching_component(&map->dlc, component) &&\n\t\t    map->name_prefix) {\n\t\t\tcomponent->name_prefix = map->name_prefix;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tret = of_property_read_string(of_node, \"sound-name-prefix\", &str);\n\tif (ret < 0)\n\t\treturn;\n\n\tcomponent->name_prefix = str;\n}\n\nstatic void soc_remove_component(struct snd_soc_component *component,\n\t\t\t\t int probed)\n{\n\n\tif (!component->card)\n\t\treturn;\n\n\tif (probed)\n\t\tsnd_soc_component_remove(component);\n\n\tlist_del_init(&component->card_list);\n\tsnd_soc_dapm_free(snd_soc_component_get_dapm(component));\n\tsoc_cleanup_component_debugfs(component);\n\tcomponent->card = NULL;\n\tsnd_soc_component_module_put_when_remove(component);\n}\n\nstatic int soc_probe_component(struct snd_soc_card *card,\n\t\t\t       struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct snd_soc_dai *dai;\n\tint probed = 0;\n\tint ret;\n\n\tif (snd_soc_component_is_dummy(component))\n\t\treturn 0;\n\n\tif (component->card) {\n\t\tif (component->card != card) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Trying to bind component \\\"%s\\\" to card \\\"%s\\\" but is already bound to card \\\"%s\\\"\\n\",\n\t\t\t\tcomponent->name, card->name, component->card->name);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tret = snd_soc_component_module_get_when_probe(component);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcomponent->card = card;\n\tsoc_set_name_prefix(card, component);\n\n\tsoc_init_component_debugfs(component);\n\n\tsnd_soc_dapm_init(dapm, card, component);\n\n\tret = snd_soc_dapm_new_controls(dapm,\n\t\t\t\t\tcomponent->driver->dapm_widgets,\n\t\t\t\t\tcomponent->driver->num_dapm_widgets);\n\n\tif (ret != 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"Failed to create new controls %d\\n\", ret);\n\t\tgoto err_probe;\n\t}\n\n\tfor_each_component_dais(component, dai) {\n\t\tret = snd_soc_dapm_new_dai_widgets(dapm, dai);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to create DAI widgets %d\\n\", ret);\n\t\t\tgoto err_probe;\n\t\t}\n\t}\n\n\tret = snd_soc_component_probe(component);\n\tif (ret < 0)\n\t\tgoto err_probe;\n\n\tWARN(dapm->idle_bias_off &&\n\t     dapm->bias_level != SND_SOC_BIAS_OFF,\n\t     \"codec %s can not start from non-off bias with idle_bias_off==1\\n\",\n\t     component->name);\n\tprobed = 1;\n\n\t \n\tret = snd_soc_component_init(component);\n\tif (ret < 0)\n\t\tgoto err_probe;\n\n\tret = snd_soc_add_component_controls(component,\n\t\t\t\t\t     component->driver->controls,\n\t\t\t\t\t     component->driver->num_controls);\n\tif (ret < 0)\n\t\tgoto err_probe;\n\n\tret = snd_soc_dapm_add_routes(dapm,\n\t\t\t\t      component->driver->dapm_routes,\n\t\t\t\t      component->driver->num_dapm_routes);\n\tif (ret < 0) {\n\t\tif (card->disable_route_checks) {\n\t\t\tdev_info(card->dev,\n\t\t\t\t \"%s: disable_route_checks set, ignoring errors on add_routes\\n\",\n\t\t\t\t __func__);\n\t\t} else {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"%s: snd_soc_dapm_add_routes failed: %d\\n\",\n\t\t\t\t__func__, ret);\n\t\t\tgoto err_probe;\n\t\t}\n\t}\n\n\t \n\tlist_add(&component->card_list, &card->component_dev_list);\n\nerr_probe:\n\tif (ret < 0)\n\t\tsoc_remove_component(component, probed);\n\n\treturn ret;\n}\n\nstatic void soc_remove_link_dais(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint order;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\t \n\t\t\tsnd_soc_pcm_dai_remove(rtd, order);\n\t\t}\n\t}\n}\n\nstatic int soc_probe_link_dais(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint order, ret;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\t \n\t\t\tret = snd_soc_pcm_dai_probe(rtd, order);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void soc_remove_link_components(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint i, order;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\t\tif (component->driver->remove_order != order)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tsoc_remove_component(component, 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int soc_probe_link_components(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tint i, ret, order;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_rtds(card, rtd) {\n\t\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\t\tif (component->driver->probe_order != order)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tret = soc_probe_component(card, component);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void soc_unbind_aux_dev(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component, *_component;\n\n\tfor_each_card_auxs_safe(card, component, _component) {\n\t\t \n\t\tsnd_soc_component_set_aux(component, NULL);\n\t\tlist_del(&component->card_aux_list);\n\t}\n}\n\nstatic int soc_bind_aux_dev(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_aux_dev *aux;\n\tint i;\n\n\tfor_each_card_pre_auxs(card, i, aux) {\n\t\t \n\t\tcomponent = soc_find_component(&aux->dlc);\n\t\tif (!component)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\t \n\t\tsnd_soc_component_set_aux(component, aux);\n\t\t \n\t\tlist_add(&component->card_aux_list, &card->aux_comp_list);\n\t}\n\treturn 0;\n}\n\nstatic int soc_probe_aux_devices(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component;\n\tint order;\n\tint ret;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_auxs(card, component) {\n\t\t\tif (component->driver->probe_order != order)\n\t\t\t\tcontinue;\n\n\t\t\tret = soc_probe_component(card,\tcomponent);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void soc_remove_aux_devices(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *comp, *_comp;\n\tint order;\n\n\tfor_each_comp_order(order) {\n\t\tfor_each_card_auxs_safe(card, comp, _comp) {\n\t\t\tif (comp->driver->remove_order == order)\n\t\t\t\tsoc_remove_component(comp, 1);\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_DMI\n \nstatic const char * const dmi_blacklist[] = {\n\t\"To be filled by OEM\",\n\t\"TBD by OEM\",\n\t\"Default String\",\n\t\"Board Manufacturer\",\n\t\"Board Vendor Name\",\n\t\"Board Product Name\",\n\tNULL,\t \n};\n\n \nstatic void cleanup_dmi_name(char *name)\n{\n\tint i, j = 0;\n\n\tfor (i = 0; name[i]; i++) {\n\t\tif (isalnum(name[i]) || (name[i] == '.')\n\t\t    || (name[i] == '_'))\n\t\t\tname[j++] = name[i];\n\t\telse if (name[i] == '-')\n\t\t\tname[j++] = '_';\n\t}\n\n\tname[j] = '\\0';\n}\n\n \nstatic int is_dmi_valid(const char *field)\n{\n\tint i = 0;\n\n\twhile (dmi_blacklist[i]) {\n\t\tif (strstr(field, dmi_blacklist[i]))\n\t\t\treturn 0;\n\t\ti++;\n\t}\n\n\treturn 1;\n}\n\n \nstatic void append_dmi_string(struct snd_soc_card *card, const char *str)\n{\n\tchar *dst = card->dmi_longname;\n\tsize_t dst_len = sizeof(card->dmi_longname);\n\tsize_t len;\n\n\tlen = strlen(dst);\n\tsnprintf(dst + len, dst_len - len, \"-%s\", str);\n\n\tlen++;\t \n\tif (len < dst_len)\n\t\tcleanup_dmi_name(dst + len);\n}\n\n \nint snd_soc_set_dmi_name(struct snd_soc_card *card, const char *flavour)\n{\n\tconst char *vendor, *product, *board;\n\n\tif (card->long_name)\n\t\treturn 0;  \n\n\tif (!dmi_available)\n\t\treturn 0;\n\n\t \n\tvendor = dmi_get_system_info(DMI_BOARD_VENDOR);\n\tif (!vendor || !is_dmi_valid(vendor)) {\n\t\tdev_warn(card->dev, \"ASoC: no DMI vendor name!\\n\");\n\t\treturn 0;\n\t}\n\n\tsnprintf(card->dmi_longname, sizeof(card->dmi_longname), \"%s\", vendor);\n\tcleanup_dmi_name(card->dmi_longname);\n\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\tif (product && is_dmi_valid(product)) {\n\t\tconst char *product_version = dmi_get_system_info(DMI_PRODUCT_VERSION);\n\n\t\tappend_dmi_string(card, product);\n\n\t\t \n\t\tif (product_version && is_dmi_valid(product_version))\n\t\t\tappend_dmi_string(card, product_version);\n\t}\n\n\tboard = dmi_get_system_info(DMI_BOARD_NAME);\n\tif (board && is_dmi_valid(board)) {\n\t\tif (!product || strcasecmp(board, product))\n\t\t\tappend_dmi_string(card, board);\n\t} else if (!product) {\n\t\t \n\t\tdev_warn(card->dev, \"ASoC: no DMI board/product name!\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (flavour)\n\t\tappend_dmi_string(card, flavour);\n\n\t \n\tcard->long_name = card->dmi_longname;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_set_dmi_name);\n#endif  \n\nstatic void soc_check_tplg_fes(struct snd_soc_card *card)\n{\n\tstruct snd_soc_component *component;\n\tconst struct snd_soc_component_driver *comp_drv;\n\tstruct snd_soc_dai_link *dai_link;\n\tint i;\n\n\tfor_each_component(component) {\n\n\t\t \n\t\tif (!component->driver->ignore_machine)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!strcmp(component->driver->ignore_machine,\n\t\t\t    card->dev->driver->name))\n\t\t\tgoto match;\n\t\tif (strcmp(component->driver->ignore_machine,\n\t\t\t   dev_name(card->dev)))\n\t\t\tcontinue;\nmatch:\n\t\t \n\t\tfor_each_card_prelinks(card, i, dai_link) {\n\n\t\t\t \n\t\t\tif (dai_link->dynamic) {\n\t\t\t\tdai_link->ignore = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdev_dbg(card->dev, \"info: override BE DAI link %s\\n\",\n\t\t\t\tcard->dai_link[i].name);\n\n\t\t\t \n\t\t\tif (!dai_link->platforms) {\n\t\t\t\tdev_err(card->dev, \"init platform error\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (component->dev->of_node)\n\t\t\t\tdai_link->platforms->of_node = component->dev->of_node;\n\t\t\telse\n\t\t\t\tdai_link->platforms->name = component->name;\n\n\t\t\t \n\t\t\tif (!dai_link->no_pcm) {\n\t\t\t\tdai_link->no_pcm = 1;\n\n\t\t\t\tif (dai_link->dpcm_playback)\n\t\t\t\t\tdev_warn(card->dev,\n\t\t\t\t\t\t \"invalid configuration, dailink %s has flags no_pcm=0 and dpcm_playback=1\\n\",\n\t\t\t\t\t\t dai_link->name);\n\t\t\t\tif (dai_link->dpcm_capture)\n\t\t\t\t\tdev_warn(card->dev,\n\t\t\t\t\t\t \"invalid configuration, dailink %s has flags no_pcm=0 and dpcm_capture=1\\n\",\n\t\t\t\t\t\t dai_link->name);\n\n\t\t\t\t \n\t\t\t\tif (!(dai_link->dpcm_playback ||\n\t\t\t\t      dai_link->dpcm_capture)) {\n\t\t\t\t\tdai_link->dpcm_playback = !dai_link->capture_only;\n\t\t\t\t\tdai_link->dpcm_capture = !dai_link->playback_only;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tdai_link->be_hw_params_fixup =\n\t\t\t\tcomponent->driver->be_hw_params_fixup;\n\n\t\t\t \n\t\t\tif (!dai_link->stream_name)\n\t\t\t\tdai_link->stream_name = dai_link->name;\n\t\t}\n\n\t\t \n\t\tif (component->driver->topology_name_prefix) {\n\n\t\t\t \n\t\t\tif (!card->topology_shortname_created) {\n\t\t\t\tcomp_drv = component->driver;\n\n\t\t\t\tsnprintf(card->topology_shortname, 32, \"%s-%s\",\n\t\t\t\t\t comp_drv->topology_name_prefix,\n\t\t\t\t\t card->name);\n\t\t\t\tcard->topology_shortname_created = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tcard->name = card->topology_shortname;\n\t\t}\n\t}\n}\n\n#define soc_setup_card_name(card, name, name1, name2) \\\n\t__soc_setup_card_name(card, name, sizeof(name), name1, name2)\nstatic void __soc_setup_card_name(struct snd_soc_card *card,\n\t\t\t\t  char *name, int len,\n\t\t\t\t  const char *name1, const char *name2)\n{\n\tconst char *src = name1 ? name1 : name2;\n\tint i;\n\n\tsnprintf(name, len, \"%s\", src);\n\n\tif (name != card->snd_card->driver)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tswitch (name[i]) {\n\t\tcase '_':\n\t\tcase '-':\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!isalnum(name[i]))\n\t\t\t\tname[i] = '_';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (strlen(src) > len - 1)\n\t\tdev_err(card->dev, \"ASoC: driver name too long '%s' -> '%s'\\n\", src, name);\n}\n\nstatic void soc_cleanup_card_resources(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd, *n;\n\n\tif (card->snd_card)\n\t\tsnd_card_disconnect_sync(card->snd_card);\n\n\tsnd_soc_dapm_shutdown(card);\n\n\t \n\tfor_each_card_rtds(card, rtd)\n\t\tif (rtd->initialized)\n\t\t\tsnd_soc_link_exit(rtd);\n\t \n\tsoc_remove_link_dais(card);\n\tsoc_remove_link_components(card);\n\n\tfor_each_card_rtds_safe(card, rtd, n)\n\t\tsnd_soc_remove_pcm_runtime(card, rtd);\n\n\t \n\tsoc_remove_aux_devices(card);\n\tsoc_unbind_aux_dev(card);\n\n\tsnd_soc_dapm_free(&card->dapm);\n\tsoc_cleanup_card_debugfs(card);\n\n\t \n\tsnd_soc_card_remove(card);\n\n\tif (card->snd_card) {\n\t\tsnd_card_free(card->snd_card);\n\t\tcard->snd_card = NULL;\n\t}\n}\n\nstatic void snd_soc_unbind_card(struct snd_soc_card *card, bool unregister)\n{\n\tif (snd_soc_card_is_instantiated(card)) {\n\t\tcard->instantiated = false;\n\t\tsnd_soc_flush_all_delayed_work(card);\n\n\t\tsoc_cleanup_card_resources(card);\n\t\tif (!unregister)\n\t\t\tlist_add(&card->list, &unbind_card_list);\n\t} else {\n\t\tif (unregister)\n\t\t\tlist_del(&card->list);\n\t}\n}\n\nstatic int snd_soc_bind_card(struct snd_soc_card *card)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\tstruct snd_soc_component *component;\n\tint ret;\n\n\tmutex_lock(&client_mutex);\n\tsnd_soc_card_mutex_lock_root(card);\n\n\tsnd_soc_dapm_init(&card->dapm, card, NULL);\n\n\t \n\tsoc_check_tplg_fes(card);\n\n\t \n\tret = soc_bind_aux_dev(card);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\t \n\tcard->num_rtd = 0;\n\tret = snd_soc_add_pcm_runtimes(card, card->dai_link, card->num_links);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\t \n\tret = snd_card_new(card->dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,\n\t\t\tcard->owner, 0, &card->snd_card);\n\tif (ret < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: can't create sound card for card %s: %d\\n\",\n\t\t\tcard->name, ret);\n\t\tgoto probe_end;\n\t}\n\n\tsoc_init_card_debugfs(card);\n\n\tsoc_resume_init(card);\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,\n\t\t\t\t\tcard->num_dapm_widgets);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\tret = snd_soc_dapm_new_controls(&card->dapm, card->of_dapm_widgets,\n\t\t\t\t\tcard->num_of_dapm_widgets);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\t \n\tret = snd_soc_card_probe(card);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\t \n\tret = soc_probe_link_components(card);\n\tif (ret < 0) {\n\t\tif (ret != -EPROBE_DEFER) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: failed to instantiate card %d\\n\", ret);\n\t\t}\n\t\tgoto probe_end;\n\t}\n\n\t \n\tret = soc_probe_aux_devices(card);\n\tif (ret < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: failed to probe aux component %d\\n\", ret);\n\t\tgoto probe_end;\n\t}\n\n\t \n\tret = soc_probe_link_dais(card);\n\tif (ret < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: failed to instantiate card %d\\n\", ret);\n\t\tgoto probe_end;\n\t}\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tret = soc_init_pcm_runtime(card, rtd);\n\t\tif (ret < 0)\n\t\t\tgoto probe_end;\n\t}\n\n\tsnd_soc_dapm_link_dai_widgets(card);\n\tsnd_soc_dapm_connect_dai_link_widgets(card);\n\n\tret = snd_soc_add_card_controls(card, card->controls,\n\t\t\t\t\tcard->num_controls);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,\n\t\t\t\t      card->num_dapm_routes);\n\tif (ret < 0) {\n\t\tif (card->disable_route_checks) {\n\t\t\tdev_info(card->dev,\n\t\t\t\t \"%s: disable_route_checks set, ignoring errors on add_routes\\n\",\n\t\t\t\t __func__);\n\t\t} else {\n\t\t\tdev_err(card->dev,\n\t\t\t\t \"%s: snd_soc_dapm_add_routes failed: %d\\n\",\n\t\t\t\t __func__, ret);\n\t\t\tgoto probe_end;\n\t\t}\n\t}\n\n\tret = snd_soc_dapm_add_routes(&card->dapm, card->of_dapm_routes,\n\t\t\t\t      card->num_of_dapm_routes);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\t \n\tsnd_soc_set_dmi_name(card, NULL);\n\n\tsoc_setup_card_name(card, card->snd_card->shortname,\n\t\t\t    card->name, NULL);\n\tsoc_setup_card_name(card, card->snd_card->longname,\n\t\t\t    card->long_name, card->name);\n\tsoc_setup_card_name(card, card->snd_card->driver,\n\t\t\t    card->driver_name, card->name);\n\n\tif (card->components) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tret = snd_component_add(card->snd_card, card->components);\n\t\tif (ret < 0) {\n\t\t\tdev_err(card->dev, \"ASoC: %s snd_component_add() failed: %d\\n\",\n\t\t\t\tcard->name, ret);\n\t\t\tgoto probe_end;\n\t\t}\n\t}\n\n\tret = snd_soc_card_late_probe(card);\n\tif (ret < 0)\n\t\tgoto probe_end;\n\n\tsnd_soc_dapm_new_widgets(card);\n\tsnd_soc_card_fixup_controls(card);\n\n\tret = snd_card_register(card->snd_card);\n\tif (ret < 0) {\n\t\tdev_err(card->dev, \"ASoC: failed to register soundcard %d\\n\",\n\t\t\t\tret);\n\t\tgoto probe_end;\n\t}\n\n\tcard->instantiated = 1;\n\tdapm_mark_endpoints_dirty(card);\n\tsnd_soc_dapm_sync(&card->dapm);\n\n\t \n\tfor_each_card_components(card, component)\n\t\tif (!snd_soc_component_active(component))\n\t\t\tpinctrl_pm_select_sleep_state(component->dev);\n\nprobe_end:\n\tif (ret < 0)\n\t\tsoc_cleanup_card_resources(card);\n\n\tsnd_soc_card_mutex_unlock(card);\n\tmutex_unlock(&client_mutex);\n\n\treturn ret;\n}\n\n \nstatic int soc_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\n\t \n\tif (!card)\n\t\treturn -EINVAL;\n\n\tdev_warn(&pdev->dev,\n\t\t \"ASoC: machine %s should use snd_soc_register_card()\\n\",\n\t\t card->name);\n\n\t \n\tcard->dev = &pdev->dev;\n\n\treturn devm_snd_soc_register_card(&pdev->dev, card);\n}\n\nint snd_soc_poweroff(struct device *dev)\n{\n\tstruct snd_soc_card *card = dev_get_drvdata(dev);\n\tstruct snd_soc_component *component;\n\n\tif (!snd_soc_card_is_instantiated(card))\n\t\treturn 0;\n\n\t \n\tsnd_soc_flush_all_delayed_work(card);\n\n\tsnd_soc_dapm_shutdown(card);\n\n\t \n\tfor_each_card_components(card, component)\n\t\tpinctrl_pm_select_sleep_state(component->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_poweroff);\n\nconst struct dev_pm_ops snd_soc_pm_ops = {\n\t.suspend = snd_soc_suspend,\n\t.resume = snd_soc_resume,\n\t.freeze = snd_soc_suspend,\n\t.thaw = snd_soc_resume,\n\t.poweroff = snd_soc_poweroff,\n\t.restore = snd_soc_resume,\n};\nEXPORT_SYMBOL_GPL(snd_soc_pm_ops);\n\n \nstatic struct platform_driver soc_driver = {\n\t.driver\t\t= {\n\t\t.name\t\t= \"soc-audio\",\n\t\t.pm\t\t= &snd_soc_pm_ops,\n\t},\n\t.probe\t\t= soc_probe,\n};\n\n \nstruct snd_kcontrol *snd_soc_cnew(const struct snd_kcontrol_new *_template,\n\t\t\t\t  void *data, const char *long_name,\n\t\t\t\t  const char *prefix)\n{\n\tstruct snd_kcontrol_new template;\n\tstruct snd_kcontrol *kcontrol;\n\tchar *name = NULL;\n\n\tmemcpy(&template, _template, sizeof(template));\n\ttemplate.index = 0;\n\n\tif (!long_name)\n\t\tlong_name = template.name;\n\n\tif (prefix) {\n\t\tname = kasprintf(GFP_KERNEL, \"%s %s\", prefix, long_name);\n\t\tif (!name)\n\t\t\treturn NULL;\n\n\t\ttemplate.name = name;\n\t} else {\n\t\ttemplate.name = long_name;\n\t}\n\n\tkcontrol = snd_ctl_new1(&template, data);\n\n\tkfree(name);\n\n\treturn kcontrol;\n}\nEXPORT_SYMBOL_GPL(snd_soc_cnew);\n\nstatic int snd_soc_add_controls(struct snd_card *card, struct device *dev,\n\tconst struct snd_kcontrol_new *controls, int num_controls,\n\tconst char *prefix, void *data)\n{\n\tint i;\n\n\tfor (i = 0; i < num_controls; i++) {\n\t\tconst struct snd_kcontrol_new *control = &controls[i];\n\t\tint err = snd_ctl_add(card, snd_soc_cnew(control, data,\n\t\t\t\t\t\t\t control->name, prefix));\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"ASoC: Failed to add %s: %d\\n\",\n\t\t\t\tcontrol->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint snd_soc_add_component_controls(struct snd_soc_component *component,\n\tconst struct snd_kcontrol_new *controls, unsigned int num_controls)\n{\n\tstruct snd_card *card = component->card->snd_card;\n\n\treturn snd_soc_add_controls(card, component->dev, controls,\n\t\t\tnum_controls, component->name_prefix, component);\n}\nEXPORT_SYMBOL_GPL(snd_soc_add_component_controls);\n\n \nint snd_soc_add_card_controls(struct snd_soc_card *soc_card,\n\tconst struct snd_kcontrol_new *controls, int num_controls)\n{\n\tstruct snd_card *card = soc_card->snd_card;\n\n\treturn snd_soc_add_controls(card, soc_card->dev, controls, num_controls,\n\t\t\tNULL, soc_card);\n}\nEXPORT_SYMBOL_GPL(snd_soc_add_card_controls);\n\n \nint snd_soc_add_dai_controls(struct snd_soc_dai *dai,\n\tconst struct snd_kcontrol_new *controls, int num_controls)\n{\n\tstruct snd_card *card = dai->component->card->snd_card;\n\n\treturn snd_soc_add_controls(card, dai->dev, controls, num_controls,\n\t\t\tNULL, dai);\n}\nEXPORT_SYMBOL_GPL(snd_soc_add_dai_controls);\n\n \nint snd_soc_register_card(struct snd_soc_card *card)\n{\n\tif (!card->name || !card->dev)\n\t\treturn -EINVAL;\n\n\tdev_set_drvdata(card->dev, card);\n\n\tINIT_LIST_HEAD(&card->widgets);\n\tINIT_LIST_HEAD(&card->paths);\n\tINIT_LIST_HEAD(&card->dapm_list);\n\tINIT_LIST_HEAD(&card->aux_comp_list);\n\tINIT_LIST_HEAD(&card->component_dev_list);\n\tINIT_LIST_HEAD(&card->list);\n\tINIT_LIST_HEAD(&card->rtd_list);\n\tINIT_LIST_HEAD(&card->dapm_dirty);\n\tINIT_LIST_HEAD(&card->dobj_list);\n\n\tcard->instantiated = 0;\n\tmutex_init(&card->mutex);\n\tmutex_init(&card->dapm_mutex);\n\tmutex_init(&card->pcm_mutex);\n\n\treturn snd_soc_bind_card(card);\n}\nEXPORT_SYMBOL_GPL(snd_soc_register_card);\n\n \nvoid snd_soc_unregister_card(struct snd_soc_card *card)\n{\n\tmutex_lock(&client_mutex);\n\tsnd_soc_unbind_card(card, true);\n\tmutex_unlock(&client_mutex);\n\tdev_dbg(card->dev, \"ASoC: Unregistered card '%s'\\n\", card->name);\n}\nEXPORT_SYMBOL_GPL(snd_soc_unregister_card);\n\n \nstatic char *fmt_single_name(struct device *dev, int *id)\n{\n\tconst char *devname = dev_name(dev);\n\tchar *found, *name;\n\tunsigned int id1, id2;\n\n\tif (devname == NULL)\n\t\treturn NULL;\n\n\tname = devm_kstrdup(dev, devname, GFP_KERNEL);\n\tif (!name)\n\t\treturn NULL;\n\n\t \n\tfound = strstr(name, dev->driver->name);\n\tif (found) {\n\t\t \n\t\tif (sscanf(&found[strlen(dev->driver->name)], \".%d\", id) == 1) {\n\n\t\t\t \n\t\t\tif (*id == -1)\n\t\t\t\tfound[strlen(dev->driver->name)] = '\\0';\n\t\t}\n\n\t \n\t} else if (sscanf(name, \"%x-%x\", &id1, &id2) == 2) {\n\n\t\t \n\t\t*id = ((id1 & 0xffff) << 16) + id2;\n\n\t\tdevm_kfree(dev, name);\n\n\t\t \n\t\tname = devm_kasprintf(dev, GFP_KERNEL, \"%s.%s\", dev->driver->name, devname);\n\t} else {\n\t\t*id = 0;\n\t}\n\n\treturn name;\n}\n\n \nstatic inline char *fmt_multiple_name(struct device *dev,\n\t\tstruct snd_soc_dai_driver *dai_drv)\n{\n\tif (dai_drv->name == NULL) {\n\t\tdev_err(dev,\n\t\t\t\"ASoC: error - multiple DAI %s registered with no name\\n\",\n\t\t\tdev_name(dev));\n\t\treturn NULL;\n\t}\n\n\treturn devm_kstrdup(dev, dai_drv->name, GFP_KERNEL);\n}\n\nvoid snd_soc_unregister_dai(struct snd_soc_dai *dai)\n{\n\tdev_dbg(dai->dev, \"ASoC: Unregistered DAI '%s'\\n\", dai->name);\n\tlist_del(&dai->list);\n}\nEXPORT_SYMBOL_GPL(snd_soc_unregister_dai);\n\n \nstruct snd_soc_dai *snd_soc_register_dai(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_soc_dai_driver *dai_drv,\n\t\t\t\t\t bool legacy_dai_naming)\n{\n\tstruct device *dev = component->dev;\n\tstruct snd_soc_dai *dai;\n\n\tlockdep_assert_held(&client_mutex);\n\n\tdai = devm_kzalloc(dev, sizeof(*dai), GFP_KERNEL);\n\tif (dai == NULL)\n\t\treturn NULL;\n\n\t \n\tif (legacy_dai_naming &&\n\t    (dai_drv->id == 0 || dai_drv->name == NULL)) {\n\t\tdai->name = fmt_single_name(dev, &dai->id);\n\t} else {\n\t\tdai->name = fmt_multiple_name(dev, dai_drv);\n\t\tif (dai_drv->id)\n\t\t\tdai->id = dai_drv->id;\n\t\telse\n\t\t\tdai->id = component->num_dai;\n\t}\n\tif (!dai->name)\n\t\treturn NULL;\n\n\tdai->component = component;\n\tdai->dev = dev;\n\tdai->driver = dai_drv;\n\n\t \n\tlist_add_tail(&dai->list, &component->dai_list);\n\tcomponent->num_dai++;\n\n\tdev_dbg(dev, \"ASoC: Registered DAI '%s'\\n\", dai->name);\n\treturn dai;\n}\nEXPORT_SYMBOL_GPL(snd_soc_register_dai);\n\n \nstatic void snd_soc_unregister_dais(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai, *_dai;\n\n\tfor_each_component_dais_safe(component, dai, _dai)\n\t\tsnd_soc_unregister_dai(dai);\n}\n\n \nstatic int snd_soc_register_dais(struct snd_soc_component *component,\n\t\t\t\t struct snd_soc_dai_driver *dai_drv,\n\t\t\t\t size_t count)\n{\n\tstruct snd_soc_dai *dai;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdai = snd_soc_register_dai(component, dai_drv + i, count == 1 &&\n\t\t\t\t\t   component->driver->legacy_dai_naming);\n\t\tif (dai == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tsnd_soc_unregister_dais(component);\n\n\treturn ret;\n}\n\n#define ENDIANNESS_MAP(name) \\\n\t(SNDRV_PCM_FMTBIT_##name##LE | SNDRV_PCM_FMTBIT_##name##BE)\nstatic u64 endianness_format_map[] = {\n\tENDIANNESS_MAP(S16_),\n\tENDIANNESS_MAP(U16_),\n\tENDIANNESS_MAP(S24_),\n\tENDIANNESS_MAP(U24_),\n\tENDIANNESS_MAP(S32_),\n\tENDIANNESS_MAP(U32_),\n\tENDIANNESS_MAP(S24_3),\n\tENDIANNESS_MAP(U24_3),\n\tENDIANNESS_MAP(S20_3),\n\tENDIANNESS_MAP(U20_3),\n\tENDIANNESS_MAP(S18_3),\n\tENDIANNESS_MAP(U18_3),\n\tENDIANNESS_MAP(FLOAT_),\n\tENDIANNESS_MAP(FLOAT64_),\n\tENDIANNESS_MAP(IEC958_SUBFRAME_),\n};\n\n \nstatic void convert_endianness_formats(struct snd_soc_pcm_stream *stream)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(endianness_format_map); i++)\n\t\tif (stream->formats & endianness_format_map[i])\n\t\t\tstream->formats |= endianness_format_map[i];\n}\n\nstatic void snd_soc_try_rebind_card(void)\n{\n\tstruct snd_soc_card *card, *c;\n\n\tlist_for_each_entry_safe(card, c, &unbind_card_list, list)\n\t\tif (!snd_soc_bind_card(card))\n\t\t\tlist_del(&card->list);\n}\n\nstatic void snd_soc_del_component_unlocked(struct snd_soc_component *component)\n{\n\tstruct snd_soc_card *card = component->card;\n\n\tsnd_soc_unregister_dais(component);\n\n\tif (card)\n\t\tsnd_soc_unbind_card(card, false);\n\n\tlist_del(&component->list);\n}\n\nint snd_soc_component_initialize(struct snd_soc_component *component,\n\t\t\t\t const struct snd_soc_component_driver *driver,\n\t\t\t\t struct device *dev)\n{\n\tINIT_LIST_HEAD(&component->dai_list);\n\tINIT_LIST_HEAD(&component->dobj_list);\n\tINIT_LIST_HEAD(&component->card_list);\n\tINIT_LIST_HEAD(&component->list);\n\tmutex_init(&component->io_mutex);\n\n\tcomponent->name = fmt_single_name(dev, &component->id);\n\tif (!component->name) {\n\t\tdev_err(dev, \"ASoC: Failed to allocate name\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcomponent->dev\t\t= dev;\n\tcomponent->driver\t= driver;\n\n#ifdef CONFIG_DEBUG_FS\n\tif (!component->debugfs_prefix)\n\t\tcomponent->debugfs_prefix = driver->debugfs_prefix;\n#endif\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_component_initialize);\n\nint snd_soc_add_component(struct snd_soc_component *component,\n\t\t\t  struct snd_soc_dai_driver *dai_drv,\n\t\t\t  int num_dai)\n{\n\tint ret;\n\tint i;\n\n\tmutex_lock(&client_mutex);\n\n\tif (component->driver->endianness) {\n\t\tfor (i = 0; i < num_dai; i++) {\n\t\t\tconvert_endianness_formats(&dai_drv[i].playback);\n\t\t\tconvert_endianness_formats(&dai_drv[i].capture);\n\t\t}\n\t}\n\n\tret = snd_soc_register_dais(component, dai_drv, num_dai);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"ASoC: Failed to register DAIs: %d\\n\",\n\t\t\tret);\n\t\tgoto err_cleanup;\n\t}\n\n\tif (!component->driver->write && !component->driver->read) {\n\t\tif (!component->regmap)\n\t\t\tcomponent->regmap = dev_get_regmap(component->dev,\n\t\t\t\t\t\t\t   NULL);\n\t\tif (component->regmap)\n\t\t\tsnd_soc_component_setup_regmap(component);\n\t}\n\n\t \n\tlist_add(&component->list, &component_list);\n\nerr_cleanup:\n\tif (ret < 0)\n\t\tsnd_soc_del_component_unlocked(component);\n\n\tmutex_unlock(&client_mutex);\n\n\tif (ret == 0)\n\t\tsnd_soc_try_rebind_card();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_add_component);\n\nint snd_soc_register_component(struct device *dev,\n\t\t\tconst struct snd_soc_component_driver *component_driver,\n\t\t\tstruct snd_soc_dai_driver *dai_drv,\n\t\t\tint num_dai)\n{\n\tstruct snd_soc_component *component;\n\tint ret;\n\n\tcomponent = devm_kzalloc(dev, sizeof(*component), GFP_KERNEL);\n\tif (!component)\n\t\treturn -ENOMEM;\n\n\tret = snd_soc_component_initialize(component, component_driver, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_add_component(component, dai_drv, num_dai);\n}\nEXPORT_SYMBOL_GPL(snd_soc_register_component);\n\n \nvoid snd_soc_unregister_component_by_driver(struct device *dev,\n\t\t\t\t\t    const struct snd_soc_component_driver *component_driver)\n{\n\tstruct snd_soc_component *component;\n\n\tif (!component_driver)\n\t\treturn;\n\n\tmutex_lock(&client_mutex);\n\tcomponent = snd_soc_lookup_component_nolocked(dev, component_driver->name);\n\tif (!component)\n\t\tgoto out;\n\n\tsnd_soc_del_component_unlocked(component);\n\nout:\n\tmutex_unlock(&client_mutex);\n}\nEXPORT_SYMBOL_GPL(snd_soc_unregister_component_by_driver);\n\n \nvoid snd_soc_unregister_component(struct device *dev)\n{\n\tmutex_lock(&client_mutex);\n\twhile (1) {\n\t\tstruct snd_soc_component *component = snd_soc_lookup_component_nolocked(dev, NULL);\n\n\t\tif (!component)\n\t\t\tbreak;\n\n\t\tsnd_soc_del_component_unlocked(component);\n\t}\n\tmutex_unlock(&client_mutex);\n}\nEXPORT_SYMBOL_GPL(snd_soc_unregister_component);\n\n \nint snd_soc_of_parse_card_name(struct snd_soc_card *card,\n\t\t\t       const char *propname)\n{\n\tstruct device_node *np;\n\tint ret;\n\n\tif (!card->dev) {\n\t\tpr_err(\"card->dev is not set before calling %s\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tnp = card->dev->of_node;\n\n\tret = of_property_read_string_index(np, propname, 0, &card->name);\n\t \n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Property '%s' could not be read: %d\\n\",\n\t\t\tpropname, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_card_name);\n\nstatic const struct snd_soc_dapm_widget simple_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"Microphone\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n};\n\nint snd_soc_of_parse_audio_simple_widgets(struct snd_soc_card *card,\n\t\t\t\t\t  const char *propname)\n{\n\tstruct device_node *np = card->dev->of_node;\n\tstruct snd_soc_dapm_widget *widgets;\n\tconst char *template, *wname;\n\tint i, j, num_widgets;\n\n\tnum_widgets = of_property_count_strings(np, propname);\n\tif (num_widgets < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Property '%s' does not exist\\n\",\tpropname);\n\t\treturn -EINVAL;\n\t}\n\tif (!num_widgets) {\n\t\tdev_err(card->dev, \"ASoC: Property '%s's length is zero\\n\",\n\t\t\tpropname);\n\t\treturn -EINVAL;\n\t}\n\tif (num_widgets & 1) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Property '%s' length is not even\\n\", propname);\n\t\treturn -EINVAL;\n\t}\n\n\tnum_widgets /= 2;\n\n\twidgets = devm_kcalloc(card->dev, num_widgets, sizeof(*widgets),\n\t\t\t       GFP_KERNEL);\n\tif (!widgets) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Could not allocate memory for widgets\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < num_widgets; i++) {\n\t\tint ret = of_property_read_string_index(np, propname,\n\t\t\t\t\t\t\t2 * i, &template);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: Property '%s' index %d read error:%d\\n\",\n\t\t\t\tpropname, 2 * i, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < ARRAY_SIZE(simple_widgets); j++) {\n\t\t\tif (!strncmp(template, simple_widgets[j].name,\n\t\t\t\t     strlen(simple_widgets[j].name))) {\n\t\t\t\twidgets[i] = simple_widgets[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (j >= ARRAY_SIZE(simple_widgets)) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: DAPM widget '%s' is not supported\\n\",\n\t\t\t\ttemplate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = of_property_read_string_index(np, propname,\n\t\t\t\t\t\t    (2 * i) + 1,\n\t\t\t\t\t\t    &wname);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: Property '%s' index %d read error:%d\\n\",\n\t\t\t\tpropname, (2 * i) + 1, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twidgets[i].name = wname;\n\t}\n\n\tcard->of_dapm_widgets = widgets;\n\tcard->num_of_dapm_widgets = num_widgets;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_simple_widgets);\n\nint snd_soc_of_parse_pin_switches(struct snd_soc_card *card, const char *prop)\n{\n\tconst unsigned int nb_controls_max = 16;\n\tconst char **strings, *control_name;\n\tstruct snd_kcontrol_new *controls;\n\tstruct device *dev = card->dev;\n\tunsigned int i, nb_controls;\n\tint ret;\n\n\tif (!of_property_read_bool(dev->of_node, prop))\n\t\treturn 0;\n\n\tstrings = devm_kcalloc(dev, nb_controls_max,\n\t\t\t       sizeof(*strings), GFP_KERNEL);\n\tif (!strings)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_string_array(dev->of_node, prop,\n\t\t\t\t\t    strings, nb_controls_max);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnb_controls = (unsigned int)ret;\n\n\tcontrols = devm_kcalloc(dev, nb_controls,\n\t\t\t\tsizeof(*controls), GFP_KERNEL);\n\tif (!controls)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nb_controls; i++) {\n\t\tcontrol_name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t\t      \"%s Switch\", strings[i]);\n\t\tif (!control_name)\n\t\t\treturn -ENOMEM;\n\n\t\tcontrols[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\tcontrols[i].name = control_name;\n\t\tcontrols[i].info = snd_soc_dapm_info_pin_switch;\n\t\tcontrols[i].get = snd_soc_dapm_get_pin_switch;\n\t\tcontrols[i].put = snd_soc_dapm_put_pin_switch;\n\t\tcontrols[i].private_value = (unsigned long)strings[i];\n\t}\n\n\tcard->controls = controls;\n\tcard->num_controls = nb_controls;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_pin_switches);\n\nint snd_soc_of_get_slot_mask(struct device_node *np,\n\t\t\t     const char *prop_name,\n\t\t\t     unsigned int *mask)\n{\n\tu32 val;\n\tconst __be32 *of_slot_mask = of_get_property(np, prop_name, &val);\n\tint i;\n\n\tif (!of_slot_mask)\n\t\treturn 0;\n\tval /= sizeof(u32);\n\tfor (i = 0; i < val; i++)\n\t\tif (be32_to_cpup(&of_slot_mask[i]))\n\t\t\t*mask |= (1 << i);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_get_slot_mask);\n\nint snd_soc_of_parse_tdm_slot(struct device_node *np,\n\t\t\t      unsigned int *tx_mask,\n\t\t\t      unsigned int *rx_mask,\n\t\t\t      unsigned int *slots,\n\t\t\t      unsigned int *slot_width)\n{\n\tu32 val;\n\tint ret;\n\n\tif (tx_mask)\n\t\tsnd_soc_of_get_slot_mask(np, \"dai-tdm-slot-tx-mask\", tx_mask);\n\tif (rx_mask)\n\t\tsnd_soc_of_get_slot_mask(np, \"dai-tdm-slot-rx-mask\", rx_mask);\n\n\tif (of_property_read_bool(np, \"dai-tdm-slot-num\")) {\n\t\tret = of_property_read_u32(np, \"dai-tdm-slot-num\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (slots)\n\t\t\t*slots = val;\n\t}\n\n\tif (of_property_read_bool(np, \"dai-tdm-slot-width\")) {\n\t\tret = of_property_read_u32(np, \"dai-tdm-slot-width\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (slot_width)\n\t\t\t*slot_width = val;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_tdm_slot);\n\nvoid snd_soc_dlc_use_cpu_as_platform(struct snd_soc_dai_link_component *platforms,\n\t\t\t\t     struct snd_soc_dai_link_component *cpus)\n{\n\tplatforms->of_node\t= cpus->of_node;\n\tplatforms->dai_args\t= cpus->dai_args;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dlc_use_cpu_as_platform);\n\nvoid snd_soc_of_parse_node_prefix(struct device_node *np,\n\t\t\t\t  struct snd_soc_codec_conf *codec_conf,\n\t\t\t\t  struct device_node *of_node,\n\t\t\t\t  const char *propname)\n{\n\tconst char *str;\n\tint ret;\n\n\tret = of_property_read_string(np, propname, &str);\n\tif (ret < 0) {\n\t\t \n\t\treturn;\n\t}\n\n\tcodec_conf->dlc.of_node\t= of_node;\n\tcodec_conf->name_prefix\t= str;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_node_prefix);\n\nint snd_soc_of_parse_audio_routing(struct snd_soc_card *card,\n\t\t\t\t   const char *propname)\n{\n\tstruct device_node *np = card->dev->of_node;\n\tint num_routes;\n\tstruct snd_soc_dapm_route *routes;\n\tint i;\n\n\tnum_routes = of_property_count_strings(np, propname);\n\tif (num_routes < 0 || num_routes & 1) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Property '%s' does not exist or its length is not even\\n\",\n\t\t\tpropname);\n\t\treturn -EINVAL;\n\t}\n\tnum_routes /= 2;\n\n\troutes = devm_kcalloc(card->dev, num_routes, sizeof(*routes),\n\t\t\t      GFP_KERNEL);\n\tif (!routes) {\n\t\tdev_err(card->dev,\n\t\t\t\"ASoC: Could not allocate DAPM route table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < num_routes; i++) {\n\t\tint ret = of_property_read_string_index(np, propname,\n\t\t\t\t\t\t\t2 * i, &routes[i].sink);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: Property '%s' index %d could not be read: %d\\n\",\n\t\t\t\tpropname, 2 * i, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = of_property_read_string_index(np, propname,\n\t\t\t(2 * i) + 1, &routes[i].source);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev,\n\t\t\t\t\"ASoC: Property '%s' index %d could not be read: %d\\n\",\n\t\t\t\tpropname, (2 * i) + 1, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcard->num_of_dapm_routes = num_routes;\n\tcard->of_dapm_routes = routes;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_audio_routing);\n\nint snd_soc_of_parse_aux_devs(struct snd_soc_card *card, const char *propname)\n{\n\tstruct device_node *node = card->dev->of_node;\n\tstruct snd_soc_aux_dev *aux;\n\tint num, i;\n\n\tnum = of_count_phandle_with_args(node, propname, NULL);\n\tif (num == -ENOENT) {\n\t\treturn 0;\n\t} else if (num < 0) {\n\t\tdev_err(card->dev, \"ASOC: Property '%s' could not be read: %d\\n\",\n\t\t\tpropname, num);\n\t\treturn num;\n\t}\n\n\taux = devm_kcalloc(card->dev, num, sizeof(*aux), GFP_KERNEL);\n\tif (!aux)\n\t\treturn -ENOMEM;\n\tcard->aux_dev = aux;\n\tcard->num_aux_devs = num;\n\n\tfor_each_card_pre_auxs(card, i, aux) {\n\t\taux->dlc.of_node = of_parse_phandle(node, propname, i);\n\t\tif (!aux->dlc.of_node)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_parse_aux_devs);\n\nunsigned int snd_soc_daifmt_clock_provider_flipped(unsigned int dai_fmt)\n{\n\tunsigned int inv_dai_fmt = dai_fmt & ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\n\tswitch (dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tinv_dai_fmt |= SND_SOC_DAIFMT_CBC_CFC;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tinv_dai_fmt |= SND_SOC_DAIFMT_CBC_CFP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tinv_dai_fmt |= SND_SOC_DAIFMT_CBP_CFC;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tinv_dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t\tbreak;\n\t}\n\n\treturn inv_dai_fmt;\n}\nEXPORT_SYMBOL_GPL(snd_soc_daifmt_clock_provider_flipped);\n\nunsigned int snd_soc_daifmt_clock_provider_from_bitmap(unsigned int bit_frame)\n{\n\t \n\n\t \n\tswitch (bit_frame) {\n\tcase 0x11:\n\t\treturn SND_SOC_DAIFMT_CBP_CFP;\n\tcase 0x10:\n\t\treturn SND_SOC_DAIFMT_CBP_CFC;\n\tcase 0x01:\n\t\treturn SND_SOC_DAIFMT_CBC_CFP;\n\tdefault:\n\t\treturn SND_SOC_DAIFMT_CBC_CFC;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(snd_soc_daifmt_clock_provider_from_bitmap);\n\nunsigned int snd_soc_daifmt_parse_format(struct device_node *np,\n\t\t\t\t\t const char *prefix)\n{\n\tint ret;\n\tchar prop[128];\n\tunsigned int format = 0;\n\tint bit, frame;\n\tconst char *str;\n\tstruct {\n\t\tchar *name;\n\t\tunsigned int val;\n\t} of_fmt_table[] = {\n\t\t{ \"i2s\",\tSND_SOC_DAIFMT_I2S },\n\t\t{ \"right_j\",\tSND_SOC_DAIFMT_RIGHT_J },\n\t\t{ \"left_j\",\tSND_SOC_DAIFMT_LEFT_J },\n\t\t{ \"dsp_a\",\tSND_SOC_DAIFMT_DSP_A },\n\t\t{ \"dsp_b\",\tSND_SOC_DAIFMT_DSP_B },\n\t\t{ \"ac97\",\tSND_SOC_DAIFMT_AC97 },\n\t\t{ \"pdm\",\tSND_SOC_DAIFMT_PDM},\n\t\t{ \"msb\",\tSND_SOC_DAIFMT_MSB },\n\t\t{ \"lsb\",\tSND_SOC_DAIFMT_LSB },\n\t};\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t \n\tret = of_property_read_string(np, \"dai-format\", &str);\n\tif (ret < 0) {\n\t\tsnprintf(prop, sizeof(prop), \"%sformat\", prefix);\n\t\tret = of_property_read_string(np, prop, &str);\n\t}\n\tif (ret == 0) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(of_fmt_table); i++) {\n\t\t\tif (strcmp(str, of_fmt_table[i].name) == 0) {\n\t\t\t\tformat |= of_fmt_table[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%scontinuous-clock\", prefix);\n\tif (of_property_read_bool(np, prop))\n\t\tformat |= SND_SOC_DAIFMT_CONT;\n\telse\n\t\tformat |= SND_SOC_DAIFMT_GATED;\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%sbitclock-inversion\", prefix);\n\tbit = !!of_get_property(np, prop, NULL);\n\n\tsnprintf(prop, sizeof(prop), \"%sframe-inversion\", prefix);\n\tframe = !!of_get_property(np, prop, NULL);\n\n\tswitch ((bit << 4) + frame) {\n\tcase 0x11:\n\t\tformat |= SND_SOC_DAIFMT_IB_IF;\n\t\tbreak;\n\tcase 0x10:\n\t\tformat |= SND_SOC_DAIFMT_IB_NF;\n\t\tbreak;\n\tcase 0x01:\n\t\tformat |= SND_SOC_DAIFMT_NB_IF;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn format;\n}\nEXPORT_SYMBOL_GPL(snd_soc_daifmt_parse_format);\n\nunsigned int snd_soc_daifmt_parse_clock_provider_raw(struct device_node *np,\n\t\t\t\t\t\t     const char *prefix,\n\t\t\t\t\t\t     struct device_node **bitclkmaster,\n\t\t\t\t\t\t     struct device_node **framemaster)\n{\n\tchar prop[128];\n\tunsigned int bit, frame;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%sbitclock-master\", prefix);\n\tbit = !!of_get_property(np, prop, NULL);\n\tif (bit && bitclkmaster)\n\t\t*bitclkmaster = of_parse_phandle(np, prop, 0);\n\n\tsnprintf(prop, sizeof(prop), \"%sframe-master\", prefix);\n\tframe = !!of_get_property(np, prop, NULL);\n\tif (frame && framemaster)\n\t\t*framemaster = of_parse_phandle(np, prop, 0);\n\n\t \n\treturn (bit << 4) + frame;\n}\nEXPORT_SYMBOL_GPL(snd_soc_daifmt_parse_clock_provider_raw);\n\nint snd_soc_get_stream_cpu(struct snd_soc_dai_link *dai_link, int stream)\n{\n\t \n\tif (!dai_link->c2c_params)\n\t\treturn stream;\n\n\t \n\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn SNDRV_PCM_STREAM_PLAYBACK;\n\n\treturn SNDRV_PCM_STREAM_CAPTURE;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_stream_cpu);\n\nint snd_soc_get_dai_id(struct device_node *ep)\n{\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_dai_link_component dlc = {\n\t\t.of_node = of_graph_get_port_parent(ep),\n\t};\n\tint ret;\n\n\n\t \n\tret = -ENOTSUPP;\n\tmutex_lock(&client_mutex);\n\tcomponent = soc_find_component(&dlc);\n\tif (component)\n\t\tret = snd_soc_component_of_xlate_dai_id(component, ep);\n\tmutex_unlock(&client_mutex);\n\n\tof_node_put(dlc.of_node);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_dai_id);\n\nint snd_soc_get_dlc(const struct of_phandle_args *args, struct snd_soc_dai_link_component *dlc)\n{\n\tstruct snd_soc_component *pos;\n\tint ret = -EPROBE_DEFER;\n\n\tmutex_lock(&client_mutex);\n\tfor_each_component(pos) {\n\t\tstruct device_node *component_of_node = soc_component_to_node(pos);\n\n\t\tif (component_of_node != args->np || !pos->num_dai)\n\t\t\tcontinue;\n\n\t\tret = snd_soc_component_of_xlate_dai_name(pos, args, &dlc->dai_name);\n\t\tif (ret == -ENOTSUPP) {\n\t\t\tstruct snd_soc_dai *dai;\n\t\t\tint id = -1;\n\n\t\t\tswitch (args->args_count) {\n\t\t\tcase 0:\n\t\t\t\tid = 0;  \n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = args->args[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (id < 0 || id >= pos->num_dai) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = 0;\n\n\t\t\t \n\t\t\tfor_each_component_dais(pos, dai) {\n\t\t\t\tif (id == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tid--;\n\t\t\t}\n\n\t\t\tdlc->dai_name\t= snd_soc_dai_name_get(dai);\n\t\t} else if (ret) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret == 0)\n\t\tdlc->of_node = args->np;\n\n\tmutex_unlock(&client_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_dlc);\n\nint snd_soc_of_get_dlc(struct device_node *of_node,\n\t\t       struct of_phandle_args *args,\n\t\t       struct snd_soc_dai_link_component *dlc,\n\t\t       int index)\n{\n\tstruct of_phandle_args __args;\n\tint ret;\n\n\tif (!args)\n\t\targs = &__args;\n\n\tret = of_parse_phandle_with_args(of_node, \"sound-dai\",\n\t\t\t\t\t \"#sound-dai-cells\", index, args);\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_soc_get_dlc(args, dlc);\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_get_dlc);\n\nint snd_soc_get_dai_name(const struct of_phandle_args *args,\n\t\t\t const char **dai_name)\n{\n\tstruct snd_soc_dai_link_component dlc;\n\tint ret = snd_soc_get_dlc(args, &dlc);\n\n\tif (ret == 0)\n\t\t*dai_name = dlc.dai_name;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_dai_name);\n\nint snd_soc_of_get_dai_name(struct device_node *of_node,\n\t\t\t    const char **dai_name, int index)\n{\n\tstruct snd_soc_dai_link_component dlc;\n\tint ret = snd_soc_of_get_dlc(of_node, NULL, &dlc, index);\n\n\tif (ret == 0)\n\t\t*dai_name = dlc.dai_name;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_get_dai_name);\n\nstruct snd_soc_dai *snd_soc_get_dai_via_args(struct of_phandle_args *dai_args)\n{\n\tstruct snd_soc_dai *dai;\n\tstruct snd_soc_component *component;\n\n\tmutex_lock(&client_mutex);\n\tfor_each_component(component) {\n\t\tfor_each_component_dais(component, dai)\n\t\t\tif (snd_soc_is_match_dai_args(dai->driver->dai_args, dai_args))\n\t\t\t\tgoto found;\n\t}\n\tdai = NULL;\nfound:\n\tmutex_unlock(&client_mutex);\n\treturn dai;\n}\nEXPORT_SYMBOL_GPL(snd_soc_get_dai_via_args);\n\nstatic void __snd_soc_of_put_component(struct snd_soc_dai_link_component *component)\n{\n\tif (component->of_node) {\n\t\tof_node_put(component->of_node);\n\t\tcomponent->of_node = NULL;\n\t}\n}\n\nstatic int __snd_soc_of_get_dai_link_component_alloc(\n\tstruct device *dev, struct device_node *of_node,\n\tstruct snd_soc_dai_link_component **ret_component,\n\tint *ret_num)\n{\n\tstruct snd_soc_dai_link_component *component;\n\tint num;\n\n\t \n\tnum = of_count_phandle_with_args(of_node, \"sound-dai\", \"#sound-dai-cells\");\n\tif (num <= 0) {\n\t\tif (num == -ENOENT)\n\t\t\tdev_err(dev, \"No 'sound-dai' property\\n\");\n\t\telse\n\t\t\tdev_err(dev, \"Bad phandle in 'sound-dai'\\n\");\n\t\treturn num;\n\t}\n\tcomponent = devm_kcalloc(dev, num, sizeof(*component), GFP_KERNEL);\n\tif (!component)\n\t\treturn -ENOMEM;\n\n\t*ret_component\t= component;\n\t*ret_num\t= num;\n\n\treturn 0;\n}\n\n \nvoid snd_soc_of_put_dai_link_codecs(struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_dai_link_component *component;\n\tint index;\n\n\tfor_each_link_codecs(dai_link, index, component)\n\t\t__snd_soc_of_put_component(component);\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_put_dai_link_codecs);\n\n \nint snd_soc_of_get_dai_link_codecs(struct device *dev,\n\t\t\t\t   struct device_node *of_node,\n\t\t\t\t   struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_dai_link_component *component;\n\tint index, ret;\n\n\tret = __snd_soc_of_get_dai_link_component_alloc(dev, of_node,\n\t\t\t\t\t &dai_link->codecs, &dai_link->num_codecs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor_each_link_codecs(dai_link, index, component) {\n\t\tret = snd_soc_of_get_dlc(of_node, NULL, component, index);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tsnd_soc_of_put_dai_link_codecs(dai_link);\n\tdai_link->codecs = NULL;\n\tdai_link->num_codecs = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_codecs);\n\n \nvoid snd_soc_of_put_dai_link_cpus(struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_dai_link_component *component;\n\tint index;\n\n\tfor_each_link_cpus(dai_link, index, component)\n\t\t__snd_soc_of_put_component(component);\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_put_dai_link_cpus);\n\n \nint snd_soc_of_get_dai_link_cpus(struct device *dev,\n\t\t\t\t struct device_node *of_node,\n\t\t\t\t struct snd_soc_dai_link *dai_link)\n{\n\tstruct snd_soc_dai_link_component *component;\n\tint index, ret;\n\n\t \n\tret = __snd_soc_of_get_dai_link_component_alloc(dev, of_node,\n\t\t\t\t\t &dai_link->cpus, &dai_link->num_cpus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tfor_each_link_cpus(dai_link, index, component) {\n\t\tret = snd_soc_of_get_dlc(of_node, NULL, component, index);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tsnd_soc_of_put_dai_link_cpus(dai_link);\n\tdai_link->cpus = NULL;\n\tdai_link->num_cpus = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(snd_soc_of_get_dai_link_cpus);\n\nstatic int __init snd_soc_init(void)\n{\n\tint ret;\n\n\tsnd_soc_debugfs_init();\n\tret = snd_soc_util_init();\n\tif (ret)\n\t\tgoto err_util_init;\n\n\tret = platform_driver_register(&soc_driver);\n\tif (ret)\n\t\tgoto err_register;\n\treturn 0;\n\nerr_register:\n\tsnd_soc_util_exit();\nerr_util_init:\n\tsnd_soc_debugfs_exit();\n\treturn ret;\n}\nmodule_init(snd_soc_init);\n\nstatic void __exit snd_soc_exit(void)\n{\n\tsnd_soc_util_exit();\n\tsnd_soc_debugfs_exit();\n\n\tplatform_driver_unregister(&soc_driver);\n}\nmodule_exit(snd_soc_exit);\n\n \nMODULE_AUTHOR(\"Liam Girdwood, lrg@slimlogic.co.uk\");\nMODULE_DESCRIPTION(\"ALSA SoC Core\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:soc-audio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}