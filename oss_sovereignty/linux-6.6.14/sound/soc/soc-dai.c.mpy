{
  "module_name": "soc-dai.c",
  "hash_id": "7698295282e221e3404b4cf7f2beb3b825f3b125a0b28c39ca00091744ba353b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/soc-dai.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/soc-link.h>\n\n#define soc_dai_ret(dai, ret) _soc_dai_ret(dai, __func__, ret)\nstatic inline int _soc_dai_ret(struct snd_soc_dai *dai,\n\t\t\t       const char *func, int ret)\n{\n\t \n\tif (ret >= 0)\n\t\treturn ret;\n\n\t \n\tswitch (ret) {\n\tcase -EPROBE_DEFER:\n\tcase -ENOTSUPP:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev,\n\t\t\t\"ASoC: error at %s on %s: %d\\n\",\n\t\t\tfunc, dai->name, ret);\n\t}\n\n\treturn ret;\n}\n\n \n#define soc_dai_mark_push(dai, substream, tgt)\t((dai)->mark_##tgt = substream)\n#define soc_dai_mark_pop(dai, substream, tgt)\t((dai)->mark_##tgt = NULL)\n#define soc_dai_mark_match(dai, substream, tgt)\t((dai)->mark_##tgt == substream)\n\n \nint snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t   unsigned int freq, int dir)\n{\n\tint ret;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_sysclk)\n\t\tret = dai->driver->ops->set_sysclk(dai, clk_id, freq, dir);\n\telse\n\t\tret = snd_soc_component_set_sysclk(dai->component, clk_id, 0,\n\t\t\t\t\t\t   freq, dir);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);\n\n \nint snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,\n\t\t\t   int div_id, int div)\n{\n\tint ret = -EINVAL;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_clkdiv)\n\t\tret = dai->driver->ops->set_clkdiv(dai, div_id, div);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);\n\n \nint snd_soc_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tint ret;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_pll)\n\t\tret = dai->driver->ops->set_pll(dai, pll_id, source,\n\t\t\t\t\t\tfreq_in, freq_out);\n\telse\n\t\tret = snd_soc_component_set_pll(dai->component, pll_id, source,\n\t\t\t\t\t\tfreq_in, freq_out);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);\n\n \nint snd_soc_dai_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_bclk_ratio)\n\t\tret = dai->driver->ops->set_bclk_ratio(dai, ratio);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_bclk_ratio);\n\nint snd_soc_dai_get_fmt_max_priority(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *dai;\n\tint i, max = 0;\n\n\t \n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->num_auto_selectable_formats)\n\t\t\tmax = max(max, dai->driver->ops->num_auto_selectable_formats);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn max;\n}\n\n \nu64 snd_soc_dai_get_fmt(struct snd_soc_dai *dai, int priority)\n{\n\tconst struct snd_soc_dai_ops *ops = dai->driver->ops;\n\tu64 fmt = 0;\n\tint i, max = 0, until = priority;\n\n\t \n\tif (ops)\n\t\tmax = ops->num_auto_selectable_formats;\n\n\tif (max < until)\n\t\tuntil = max;\n\n\tfor (i = 0; i < until; i++)\n\t\tfmt |= ops->auto_selectable_formats[i];\n\n\treturn fmt;\n}\n\n \nint snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (dai->driver->ops && dai->driver->ops->set_fmt)\n\t\tret = dai->driver->ops->set_fmt(dai, fmt);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);\n\n \nstatic int snd_soc_xlate_tdm_slot_mask(unsigned int slots,\n\t\t\t\t       unsigned int *tx_mask,\n\t\t\t\t       unsigned int *rx_mask)\n{\n\tif (*tx_mask || *rx_mask)\n\t\treturn 0;\n\n\tif (!slots)\n\t\treturn -EINVAL;\n\n\t*tx_mask = (1 << slots) - 1;\n\t*rx_mask = (1 << slots) - 1;\n\n\treturn 0;\n}\n\n \nint snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t     unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t     int slots, int slot_width)\n{\n\tint ret = -ENOTSUPP;\n\tint stream;\n\tunsigned int *tdm_mask[] = {\n\t\t&tx_mask,\n\t\t&rx_mask,\n\t};\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->xlate_tdm_slot_mask)\n\t\tdai->driver->ops->xlate_tdm_slot_mask(slots,\n\t\t\t\t\t\t      &tx_mask, &rx_mask);\n\telse\n\t\tsnd_soc_xlate_tdm_slot_mask(slots, &tx_mask, &rx_mask);\n\n\tfor_each_pcm_streams(stream)\n\t\tsnd_soc_dai_tdm_mask_set(dai, stream, *tdm_mask[stream]);\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_tdm_slot)\n\t\tret = dai->driver->ops->set_tdm_slot(dai, tx_mask, rx_mask,\n\t\t\t\t\t\t      slots, slot_width);\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);\n\n \nint snd_soc_dai_set_channel_map(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int tx_num, unsigned int *tx_slot,\n\t\t\t\tunsigned int rx_num, unsigned int *rx_slot)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_channel_map)\n\t\tret = dai->driver->ops->set_channel_map(dai, tx_num, tx_slot,\n\t\t\t\t\t\t\trx_num, rx_slot);\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_channel_map);\n\n \nint snd_soc_dai_get_channel_map(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int *tx_num, unsigned int *tx_slot,\n\t\t\t\tunsigned int *rx_num, unsigned int *rx_slot)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->get_channel_map)\n\t\tret = dai->driver->ops->get_channel_map(dai, tx_num, tx_slot,\n\t\t\t\t\t\t\trx_num, rx_slot);\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_get_channel_map);\n\n \nint snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tint ret = -EINVAL;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->set_tristate)\n\t\tret = dai->driver->ops->set_tristate(dai, tristate);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);\n\n \nint snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute,\n\t\t\t     int direction)\n{\n\tint ret = -ENOTSUPP;\n\n\t \n\tif (dai->driver->ops &&\n\t    dai->driver->ops->mute_stream &&\n\t    (direction == SNDRV_PCM_STREAM_PLAYBACK ||\n\t     !dai->driver->ops->no_capture_mute))\n\t\tret = dai->driver->ops->mute_stream(dai, mute, direction);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);\n\nint snd_soc_dai_hw_params(struct snd_soc_dai *dai,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tint ret = 0;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->hw_params)\n\t\tret = dai->driver->ops->hw_params(substream, params, dai);\n\n\t \n\tif (ret == 0)\n\t\tsoc_dai_mark_push(dai, substream, hw_params);\n\n\treturn soc_dai_ret(dai, ret);\n}\n\nvoid snd_soc_dai_hw_free(struct snd_soc_dai *dai,\n\t\t\t struct snd_pcm_substream *substream,\n\t\t\t int rollback)\n{\n\tif (rollback && !soc_dai_mark_match(dai, substream, hw_params))\n\t\treturn;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->hw_free)\n\t\tdai->driver->ops->hw_free(substream, dai);\n\n\t \n\tsoc_dai_mark_pop(dai, substream, hw_params);\n}\n\nint snd_soc_dai_startup(struct snd_soc_dai *dai,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tint ret = 0;\n\n\tif (!snd_soc_dai_stream_valid(dai, substream->stream))\n\t\treturn 0;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->startup)\n\t\tret = dai->driver->ops->startup(substream, dai);\n\n\t \n\tif (ret == 0)\n\t\tsoc_dai_mark_push(dai, substream, startup);\n\n\treturn soc_dai_ret(dai, ret);\n}\n\nvoid snd_soc_dai_shutdown(struct snd_soc_dai *dai,\n\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t  int rollback)\n{\n\tif (!snd_soc_dai_stream_valid(dai, substream->stream))\n\t\treturn;\n\n\tif (rollback && !soc_dai_mark_match(dai, substream, startup))\n\t\treturn;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->shutdown)\n\t\tdai->driver->ops->shutdown(substream, dai);\n\n\t \n\tsoc_dai_mark_pop(dai, substream, startup);\n}\n\nint snd_soc_dai_compress_new(struct snd_soc_dai *dai,\n\t\t\t     struct snd_soc_pcm_runtime *rtd, int num)\n{\n\tint ret = -ENOTSUPP;\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->compress_new)\n\t\tret = dai->driver->ops->compress_new(rtd, num);\n\treturn soc_dai_ret(dai, ret);\n}\n\n \nbool snd_soc_dai_stream_valid(struct snd_soc_dai *dai, int dir)\n{\n\tstruct snd_soc_pcm_stream *stream = snd_soc_dai_get_pcm_stream(dai, dir);\n\n\t \n\treturn stream->channels_min;\n}\n\n \nvoid snd_soc_dai_link_set_capabilities(struct snd_soc_dai_link *dai_link)\n{\n\tbool supported[SNDRV_PCM_STREAM_LAST + 1];\n\tint direction;\n\n\tfor_each_pcm_streams(direction) {\n\t\tstruct snd_soc_dai_link_component *cpu;\n\t\tstruct snd_soc_dai_link_component *codec;\n\t\tstruct snd_soc_dai *dai;\n\t\tbool supported_cpu = false;\n\t\tbool supported_codec = false;\n\t\tint i;\n\n\t\tfor_each_link_cpus(dai_link, i, cpu) {\n\t\t\tdai = snd_soc_find_dai_with_mutex(cpu);\n\t\t\tif (dai && snd_soc_dai_stream_valid(dai, direction)) {\n\t\t\t\tsupported_cpu = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor_each_link_codecs(dai_link, i, codec) {\n\t\t\tdai = snd_soc_find_dai_with_mutex(codec);\n\t\t\tif (dai && snd_soc_dai_stream_valid(dai, direction)) {\n\t\t\t\tsupported_codec = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsupported[direction] = supported_cpu && supported_codec;\n\t}\n\n\tdai_link->dpcm_playback = supported[SNDRV_PCM_STREAM_PLAYBACK];\n\tdai_link->dpcm_capture  = supported[SNDRV_PCM_STREAM_CAPTURE];\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_link_set_capabilities);\n\nvoid snd_soc_dai_action(struct snd_soc_dai *dai,\n\t\t\tint stream, int action)\n{\n\t \n\tdai->stream[stream].active\t+= action;\n\n\t \n\tdai->component->active\t\t+= action;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_action);\n\nint snd_soc_dai_active(struct snd_soc_dai *dai)\n{\n\tint stream, active;\n\n\tactive = 0;\n\tfor_each_pcm_streams(stream)\n\t\tactive += dai->stream[stream].active;\n\n\treturn active;\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_active);\n\nint snd_soc_pcm_dai_probe(struct snd_soc_pcm_runtime *rtd, int order)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (dai->probed)\n\t\t\tcontinue;\n\n\t\tif (dai->driver->ops) {\n\t\t\tif (dai->driver->ops->probe_order != order)\n\t\t\t\tcontinue;\n\n\t\t\tif (dai->driver->ops->probe) {\n\t\t\t\tint ret = dai->driver->ops->probe(dai);\n\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn soc_dai_ret(dai, ret);\n\t\t\t}\n\t\t}\n\t\tdai->probed = 1;\n\t}\n\n\treturn 0;\n}\n\nint snd_soc_pcm_dai_remove(struct snd_soc_pcm_runtime *rtd, int order)\n{\n\tstruct snd_soc_dai *dai;\n\tint i, r, ret = 0;\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (!dai->probed)\n\t\t\tcontinue;\n\n\t\tif (dai->driver->ops) {\n\t\t\tif (dai->driver->ops->remove_order != order)\n\t\t\t\tcontinue;\n\n\t\t\tif (dai->driver->ops->remove) {\n\t\t\t\tr = dai->driver->ops->remove(dai);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tret = r;  \n\t\t\t}\n\t\t}\n\t\tdai->probed = 0;\n\t}\n\n\treturn ret;\n}\n\nint snd_soc_pcm_dai_new(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->pcm_new) {\n\t\t\tint ret = dai->driver->ops->pcm_new(rtd, dai);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_dai_ret(dai, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint snd_soc_pcm_dai_prepare(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *dai;\n\tint i, ret;\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (!snd_soc_dai_stream_valid(dai, substream->stream))\n\t\t\tcontinue;\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->prepare) {\n\t\t\tret = dai->driver->ops->prepare(substream, dai);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_dai_ret(dai, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int soc_dai_trigger(struct snd_soc_dai *dai,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tint ret = 0;\n\n\tif (!snd_soc_dai_stream_valid(dai, substream->stream))\n\t\treturn 0;\n\n\tif (dai->driver->ops &&\n\t    dai->driver->ops->trigger)\n\t\tret = dai->driver->ops->trigger(substream, cmd, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\n\nint snd_soc_pcm_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t    int cmd, int rollback)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *dai;\n\tint i, r, ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfor_each_rtd_dais(rtd, i, dai) {\n\t\t\tret = soc_dai_trigger(dai, substream, cmd);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tif (dai->driver->ops && dai->driver->ops->mute_unmute_on_trigger)\n\t\t\t\tsnd_soc_dai_digital_mute(dai, 0, substream->stream);\n\n\t\t\tsoc_dai_mark_push(dai, substream, trigger);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfor_each_rtd_dais(rtd, i, dai) {\n\t\t\tif (rollback && !soc_dai_mark_match(dai, substream, trigger))\n\t\t\t\tcontinue;\n\n\t\t\tif (dai->driver->ops && dai->driver->ops->mute_unmute_on_trigger)\n\t\t\t\tsnd_soc_dai_digital_mute(dai, 1, substream->stream);\n\n\t\t\tr = soc_dai_trigger(dai, substream, cmd);\n\t\t\tif (r < 0)\n\t\t\t\tret = r;  \n\t\t\tsoc_dai_mark_pop(dai, substream, trigger);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint snd_soc_pcm_dai_bespoke_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *dai;\n\tint i, ret;\n\n\tfor_each_rtd_dais(rtd, i, dai) {\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->bespoke_trigger) {\n\t\t\tret = dai->driver->ops->bespoke_trigger(substream,\n\t\t\t\t\t\t\t\tcmd, dai);\n\t\t\tif (ret < 0)\n\t\t\t\treturn soc_dai_ret(dai, ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid snd_soc_pcm_dai_delay(struct snd_pcm_substream *substream,\n\t\t\t   snd_pcm_sframes_t *cpu_delay,\n\t\t\t   snd_pcm_sframes_t *codec_delay)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *dai;\n\tint i;\n\n\t \n\n\t \n\tfor_each_rtd_cpu_dais(rtd, i, dai)\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->delay)\n\t\t\t*cpu_delay = max(*cpu_delay, dai->driver->ops->delay(substream, dai));\n\n\t \n\tfor_each_rtd_codec_dais(rtd, i, dai)\n\t\tif (dai->driver->ops &&\n\t\t    dai->driver->ops->delay)\n\t\t\t*codec_delay = max(*codec_delay, dai->driver->ops->delay(substream, dai));\n}\n\nint snd_soc_dai_compr_startup(struct snd_soc_dai *dai,\n\t\t\t      struct snd_compr_stream *cstream)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->startup)\n\t\tret = dai->driver->cops->startup(cstream, dai);\n\n\t \n\tif (ret == 0)\n\t\tsoc_dai_mark_push(dai, cstream, compr_startup);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_startup);\n\nvoid snd_soc_dai_compr_shutdown(struct snd_soc_dai *dai,\n\t\t\t\tstruct snd_compr_stream *cstream,\n\t\t\t\tint rollback)\n{\n\tif (rollback && !soc_dai_mark_match(dai, cstream, compr_startup))\n\t\treturn;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->shutdown)\n\t\tdai->driver->cops->shutdown(cstream, dai);\n\n\t \n\tsoc_dai_mark_pop(dai, cstream, compr_startup);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_shutdown);\n\nint snd_soc_dai_compr_trigger(struct snd_soc_dai *dai,\n\t\t\t      struct snd_compr_stream *cstream, int cmd)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->trigger)\n\t\tret = dai->driver->cops->trigger(cstream, cmd, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_trigger);\n\nint snd_soc_dai_compr_set_params(struct snd_soc_dai *dai,\n\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t struct snd_compr_params *params)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->set_params)\n\t\tret = dai->driver->cops->set_params(cstream, params, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_params);\n\nint snd_soc_dai_compr_get_params(struct snd_soc_dai *dai,\n\t\t\t\t struct snd_compr_stream *cstream,\n\t\t\t\t struct snd_codec *params)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->get_params)\n\t\tret = dai->driver->cops->get_params(cstream, params, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_get_params);\n\nint snd_soc_dai_compr_ack(struct snd_soc_dai *dai,\n\t\t\t  struct snd_compr_stream *cstream,\n\t\t\t  size_t bytes)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->ack)\n\t\tret = dai->driver->cops->ack(cstream, bytes, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_ack);\n\nint snd_soc_dai_compr_pointer(struct snd_soc_dai *dai,\n\t\t\t      struct snd_compr_stream *cstream,\n\t\t\t      struct snd_compr_tstamp *tstamp)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->pointer)\n\t\tret = dai->driver->cops->pointer(cstream, tstamp, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_pointer);\n\nint snd_soc_dai_compr_set_metadata(struct snd_soc_dai *dai,\n\t\t\t\t   struct snd_compr_stream *cstream,\n\t\t\t\t   struct snd_compr_metadata *metadata)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->set_metadata)\n\t\tret = dai->driver->cops->set_metadata(cstream, metadata, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_set_metadata);\n\nint snd_soc_dai_compr_get_metadata(struct snd_soc_dai *dai,\n\t\t\t\t   struct snd_compr_stream *cstream,\n\t\t\t\t   struct snd_compr_metadata *metadata)\n{\n\tint ret = 0;\n\n\tif (dai->driver->cops &&\n\t    dai->driver->cops->get_metadata)\n\t\tret = dai->driver->cops->get_metadata(cstream, metadata, dai);\n\n\treturn soc_dai_ret(dai, ret);\n}\nEXPORT_SYMBOL_GPL(snd_soc_dai_compr_get_metadata);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}