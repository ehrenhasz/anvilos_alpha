{
  "module_name": "chv3-i2s.c",
  "hash_id": "f87c9b0b93b16d22f15afad65764d58e1e1f48b42b415f86b56ea96d004e76ec",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/google/chv3-i2s.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <sound/soc.h>\n\n \n\n#define I2S_TX_ENABLE\t\t0x00\n#define I2S_TX_BASE_ADDR\t0x04\n#define I2S_TX_BUFFER_SIZE\t0x08\n#define I2S_TX_PRODUCER_IDX\t0x0c\n#define I2S_TX_CONSUMER_IDX\t0x10\n#define I2S_RX_ENABLE\t\t0x14\n#define I2S_RX_BASE_ADDR\t0x18\n#define I2S_RX_BUFFER_SIZE\t0x1c\n#define I2S_RX_PRODUCER_IDX\t0x20\n#define I2S_RX_CONSUMER_IDX\t0x24\n\n#define I2S_SOFT_RESET\t\t0x2c\n#define I2S_SOFT_RESET_RX_BIT\t0x1\n#define I2S_SOFT_RESET_TX_BIT\t0x2\n\n#define I2S_RX_IRQ\t\t0x4c\n#define I2S_RX_IRQ_CONST\t0x50\n#define I2S_TX_IRQ\t\t0x54\n#define I2S_TX_IRQ_CONST\t0x58\n\n#define I2S_IRQ_MASK\t0x8\n#define I2S_IRQ_CLR\t0xc\n#define I2S_IRQ_RX_BIT\t0x1\n#define I2S_IRQ_TX_BIT\t0x2\n\n#define I2S_MAX_BUFFER_SIZE\t0x200000\n\nstruct chv3_i2s_dev {\n\tstruct device *dev;\n\tvoid __iomem *iobase;\n\tvoid __iomem *iobase_irq;\n\tstruct snd_pcm_substream *rx_substream;\n\tstruct snd_pcm_substream *tx_substream;\n\tint tx_bytes_to_fetch;\n};\n\nstatic struct snd_soc_dai_driver chv3_i2s_dai = {\n\t.name = \"chv3-i2s\",\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 128,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 128,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n};\n\nstatic const struct snd_pcm_hardware chv3_dma_hw = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.buffer_bytes_max = I2S_MAX_BUFFER_SIZE,\n\t.period_bytes_min = 64,\n\t.period_bytes_max = 8192,\n\t.periods_min = 4,\n\t.periods_max = 256,\n};\n\nstatic inline void chv3_i2s_wr(struct chv3_i2s_dev *i2s, int offset, u32 val)\n{\n\twritel(val, i2s->iobase + offset);\n}\n\nstatic inline u32 chv3_i2s_rd(struct chv3_i2s_dev *i2s, int offset)\n{\n\treturn readl(i2s->iobase + offset);\n}\n\nstatic irqreturn_t chv3_i2s_isr(int irq, void *data)\n{\n\tstruct chv3_i2s_dev *i2s = data;\n\tu32 reg;\n\n\treg = readl(i2s->iobase_irq + I2S_IRQ_CLR);\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\tif (reg & I2S_IRQ_RX_BIT)\n\t\tsnd_pcm_period_elapsed(i2s->rx_substream);\n\n\tif (reg & I2S_IRQ_TX_BIT)\n\t\tsnd_pcm_period_elapsed(i2s->tx_substream);\n\n\twritel(reg, i2s->iobase_irq + I2S_IRQ_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int chv3_dma_open(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tint res;\n\n\tsnd_soc_set_runtime_hwparams(substream, &chv3_dma_hw);\n\n\tres = snd_pcm_hw_constraint_pow2(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_BYTES);\n\tif (res)\n\t\treturn res;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\ti2s->rx_substream = substream;\n\telse\n\t\ti2s->tx_substream = substream;\n\n\treturn 0;\n}\nstatic int chv3_dma_close(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tchv3_i2s_wr(i2s, I2S_RX_ENABLE, 0);\n\telse\n\t\tchv3_i2s_wr(i2s, I2S_TX_ENABLE, 0);\n\n\treturn 0;\n}\n\nstatic int chv3_dma_pcm_construct(struct snd_soc_component *component,\n\t\t\t\t  struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct snd_pcm_substream *substream;\n\tint res;\n\n\tsubstream = rtd->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\tif (substream) {\n\t\tres = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, i2s->dev,\n\t\t\t\tI2S_MAX_BUFFER_SIZE, &substream->dma_buffer);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tsubstream = rtd->pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\tif (substream) {\n\t\tres = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, i2s->dev,\n\t\t\t\tI2S_MAX_BUFFER_SIZE, &substream->dma_buffer);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int chv3_dma_hw_params(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\n\treturn 0;\n}\n\nstatic int chv3_dma_prepare(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned int buffer_bytes, period_bytes, period_size;\n\n\tbuffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\tperiod_bytes = snd_pcm_lib_period_bytes(substream);\n\tperiod_size = substream->runtime->period_size;\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tchv3_i2s_wr(i2s, I2S_SOFT_RESET, I2S_SOFT_RESET_RX_BIT);\n\t\tchv3_i2s_wr(i2s, I2S_RX_BASE_ADDR, substream->dma_buffer.addr);\n\t\tchv3_i2s_wr(i2s, I2S_RX_BUFFER_SIZE, buffer_bytes);\n\t\tchv3_i2s_wr(i2s, I2S_RX_IRQ, (period_size << 8) | 1);\n\t\tchv3_i2s_wr(i2s, I2S_RX_ENABLE, 1);\n\t} else {\n\t\tchv3_i2s_wr(i2s, I2S_SOFT_RESET, I2S_SOFT_RESET_TX_BIT);\n\t\tchv3_i2s_wr(i2s, I2S_TX_BASE_ADDR, substream->dma_buffer.addr);\n\t\tchv3_i2s_wr(i2s, I2S_TX_BUFFER_SIZE, buffer_bytes);\n\t\tchv3_i2s_wr(i2s, I2S_TX_IRQ, ((period_bytes / i2s->tx_bytes_to_fetch) << 8) | 1);\n\t\tchv3_i2s_wr(i2s, I2S_TX_ENABLE, 1);\n\t}\n\twritel(I2S_IRQ_RX_BIT | I2S_IRQ_TX_BIT, i2s->iobase_irq + I2S_IRQ_MASK);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t chv3_dma_pointer(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tu32 frame_bytes, buffer_bytes;\n\tu32 idx_bytes;\n\n\tframe_bytes = substream->runtime->frame_bits * 8;\n\tbuffer_bytes = snd_pcm_lib_buffer_bytes(substream);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tidx_bytes = chv3_i2s_rd(i2s, I2S_RX_PRODUCER_IDX);\n\t} else {\n\t\tidx_bytes = chv3_i2s_rd(i2s, I2S_TX_CONSUMER_IDX);\n\t\t \n\t\tidx_bytes = (idx_bytes - frame_bytes) & (buffer_bytes - 1);\n\t}\n\n\treturn bytes_to_frames(substream->runtime, idx_bytes);\n}\n\nstatic int chv3_dma_ack(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct chv3_i2s_dev *i2s = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tunsigned int bytes, idx;\n\n\tbytes = frames_to_bytes(runtime, runtime->control->appl_ptr);\n\tidx = bytes & (snd_pcm_lib_buffer_bytes(substream) - 1);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tchv3_i2s_wr(i2s, I2S_RX_CONSUMER_IDX, idx);\n\telse\n\t\tchv3_i2s_wr(i2s, I2S_TX_PRODUCER_IDX, idx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver chv3_i2s_comp = {\n\t.name = \"chv3-i2s-comp\",\n\t.open = chv3_dma_open,\n\t.close = chv3_dma_close,\n\t.pcm_construct = chv3_dma_pcm_construct,\n\t.hw_params = chv3_dma_hw_params,\n\t.prepare = chv3_dma_prepare,\n\t.pointer = chv3_dma_pointer,\n\t.ack = chv3_dma_ack,\n};\n\nstatic int chv3_i2s_probe(struct platform_device *pdev)\n{\n\tstruct chv3_i2s_dev *i2s;\n\tint res;\n\tint irq;\n\n\ti2s = devm_kzalloc(&pdev->dev, sizeof(*i2s), GFP_KERNEL);\n\tif (!i2s)\n\t\treturn -ENOMEM;\n\n\ti2s->iobase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(i2s->iobase))\n\t\treturn PTR_ERR(i2s->iobase);\n\n\ti2s->iobase_irq = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(i2s->iobase_irq))\n\t\treturn PTR_ERR(i2s->iobase_irq);\n\n\ti2s->tx_bytes_to_fetch = (chv3_i2s_rd(i2s, I2S_TX_IRQ_CONST) >> 8) & 0xffff;\n\n\ti2s->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, i2s);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -ENXIO;\n\tres = devm_request_irq(i2s->dev, irq, chv3_i2s_isr, 0, \"chv3-i2s\", i2s);\n\tif (res)\n\t\treturn res;\n\n\tres = devm_snd_soc_register_component(&pdev->dev, &chv3_i2s_comp,\n\t\t\t\t\t      &chv3_i2s_dai, 1);\n\tif (res) {\n\t\tdev_err(&pdev->dev, \"couldn't register component: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id chv3_i2s_of_match[] = {\n\t{ .compatible = \"google,chv3-i2s\" },\n\t{},\n};\n\nstatic struct platform_driver chv3_i2s_driver = {\n\t.probe = chv3_i2s_probe,\n\t.driver = {\n\t\t.name = \"chv3-i2s\",\n\t\t.of_match_table = chv3_i2s_of_match,\n\t},\n};\n\nmodule_platform_driver(chv3_i2s_driver);\n\nMODULE_AUTHOR(\"Pawel Anikiel <pan@semihalf.com>\");\nMODULE_DESCRIPTION(\"Chameleon v3 I2S interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}