{
  "module_name": "dwc-pcm.c",
  "hash_id": "2dbee1ae14c685402880db7bdbde234a56ecfed1c4814e7a0772bee6183424c2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/dwc/dwc-pcm.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/rcupdate.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include \"local.h\"\n\n#define BUFFER_BYTES_MAX\t(3 * 2 * 8 * PERIOD_BYTES_MIN)\n#define PERIOD_BYTES_MIN\t4096\n#define PERIODS_MIN\t\t2\n\n#define dw_pcm_tx_fn(sample_bits) \\\nstatic unsigned int dw_pcm_tx_##sample_bits(struct dw_i2s_dev *dev, \\\n\t\tstruct snd_pcm_runtime *runtime, unsigned int tx_ptr, \\\n\t\tbool *period_elapsed) \\\n{ \\\n\tconst u##sample_bits (*p)[2] = (void *)runtime->dma_area; \\\n\tunsigned int period_pos = tx_ptr % runtime->period_size; \\\n\tint i; \\\n\\\n\tfor (i = 0; i < dev->fifo_th; i++) { \\\n\t\tiowrite32(p[tx_ptr][0], dev->i2s_base + dev->l_reg); \\\n\t\tiowrite32(p[tx_ptr][1], dev->i2s_base + dev->r_reg); \\\n\t\tperiod_pos++; \\\n\t\tif (++tx_ptr >= runtime->buffer_size) \\\n\t\t\ttx_ptr = 0; \\\n\t} \\\n\t*period_elapsed = period_pos >= runtime->period_size; \\\n\treturn tx_ptr; \\\n}\n\n#define dw_pcm_rx_fn(sample_bits) \\\nstatic unsigned int dw_pcm_rx_##sample_bits(struct dw_i2s_dev *dev, \\\n\t\tstruct snd_pcm_runtime *runtime, unsigned int rx_ptr, \\\n\t\tbool *period_elapsed) \\\n{ \\\n\tu##sample_bits (*p)[2] = (void *)runtime->dma_area; \\\n\tunsigned int period_pos = rx_ptr % runtime->period_size; \\\n\tint i; \\\n\\\n\tfor (i = 0; i < dev->fifo_th; i++) { \\\n\t\tp[rx_ptr][0] = ioread32(dev->i2s_base + dev->l_reg); \\\n\t\tp[rx_ptr][1] = ioread32(dev->i2s_base + dev->r_reg); \\\n\t\tperiod_pos++; \\\n\t\tif (++rx_ptr >= runtime->buffer_size) \\\n\t\t\trx_ptr = 0; \\\n\t} \\\n\t*period_elapsed = period_pos >= runtime->period_size; \\\n\treturn rx_ptr; \\\n}\n\ndw_pcm_tx_fn(16);\ndw_pcm_tx_fn(32);\ndw_pcm_rx_fn(16);\ndw_pcm_rx_fn(32);\n\n#undef dw_pcm_tx_fn\n#undef dw_pcm_rx_fn\n\nstatic const struct snd_pcm_hardware dw_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER,\n\t.rates = SNDRV_PCM_RATE_32000 |\n\t\tSNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000,\n\t.rate_min = 32000,\n\t.rate_max = 48000,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE |\n\t\tSNDRV_PCM_FMTBIT_S32_LE,\n\t.channels_min = 2,\n\t.channels_max = 2,\n\t.buffer_bytes_max = BUFFER_BYTES_MAX,\n\t.period_bytes_min = PERIOD_BYTES_MIN,\n\t.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,\n\t.periods_min = PERIODS_MIN,\n\t.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,\n\t.fifo_size = 16,\n};\n\nstatic void dw_pcm_transfer(struct dw_i2s_dev *dev, bool push)\n{\n\tstruct snd_pcm_substream *substream;\n\tbool active, period_elapsed;\n\n\trcu_read_lock();\n\tif (push)\n\t\tsubstream = rcu_dereference(dev->tx_substream);\n\telse\n\t\tsubstream = rcu_dereference(dev->rx_substream);\n\tactive = substream && snd_pcm_running(substream);\n\tif (active) {\n\t\tunsigned int ptr;\n\t\tunsigned int new_ptr;\n\n\t\tif (push) {\n\t\t\tptr = READ_ONCE(dev->tx_ptr);\n\t\t\tnew_ptr = dev->tx_fn(dev, substream->runtime, ptr,\n\t\t\t\t\t&period_elapsed);\n\t\t\tcmpxchg(&dev->tx_ptr, ptr, new_ptr);\n\t\t} else {\n\t\t\tptr = READ_ONCE(dev->rx_ptr);\n\t\t\tnew_ptr = dev->rx_fn(dev, substream->runtime, ptr,\n\t\t\t\t\t&period_elapsed);\n\t\t\tcmpxchg(&dev->rx_ptr, ptr, new_ptr);\n\t\t}\n\n\t\tif (period_elapsed)\n\t\t\tsnd_pcm_period_elapsed(substream);\n\t}\n\trcu_read_unlock();\n}\n\nvoid dw_pcm_push_tx(struct dw_i2s_dev *dev)\n{\n\tdw_pcm_transfer(dev, true);\n}\n\nvoid dw_pcm_pop_rx(struct dw_i2s_dev *dev)\n{\n\tdw_pcm_transfer(dev, false);\n}\n\nstatic int dw_pcm_open(struct snd_soc_component *component,\n\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tsnd_soc_set_runtime_hwparams(substream, &dw_pcm_hardware);\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\truntime->private_data = dev;\n\n\treturn 0;\n}\n\nstatic int dw_pcm_close(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tsynchronize_rcu();\n\treturn 0;\n}\n\nstatic int dw_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dw_i2s_dev *dev = runtime->private_data;\n\n\tswitch (params_channels(hw_params)) {\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"invalid channels number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_format(hw_params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tdev->tx_fn = dw_pcm_tx_16;\n\t\tdev->rx_fn = dw_pcm_rx_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tdev->tx_fn = dw_pcm_tx_32;\n\t\tdev->rx_fn = dw_pcm_rx_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"invalid format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dw_pcm_trigger(struct snd_soc_component *component,\n\t\t\t  struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dw_i2s_dev *dev = runtime->private_data;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tWRITE_ONCE(dev->tx_ptr, 0);\n\t\t\trcu_assign_pointer(dev->tx_substream, substream);\n\t\t} else {\n\t\t\tWRITE_ONCE(dev->rx_ptr, 0);\n\t\t\trcu_assign_pointer(dev->rx_substream, substream);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\trcu_assign_pointer(dev->tx_substream, NULL);\n\t\telse\n\t\t\trcu_assign_pointer(dev->rx_substream, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_uframes_t dw_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct dw_i2s_dev *dev = runtime->private_data;\n\tsnd_pcm_uframes_t pos;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tpos = READ_ONCE(dev->tx_ptr);\n\telse\n\t\tpos = READ_ONCE(dev->rx_ptr);\n\n\treturn pos < runtime->buffer_size ? pos : 0;\n}\n\nstatic int dw_pcm_new(struct snd_soc_component *component,\n\t\t      struct snd_soc_pcm_runtime *rtd)\n{\n\tsize_t size = dw_pcm_hardware.buffer_bytes_max;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm,\n\t\t\tSNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\tNULL, size, size);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver dw_pcm_component = {\n\t.open\t\t= dw_pcm_open,\n\t.close\t\t= dw_pcm_close,\n\t.hw_params\t= dw_pcm_hw_params,\n\t.trigger\t= dw_pcm_trigger,\n\t.pointer\t= dw_pcm_pointer,\n\t.pcm_construct\t= dw_pcm_new,\n};\n\nint dw_pcm_register(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev, &dw_pcm_component,\n\t\t\t\t\t       NULL, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}