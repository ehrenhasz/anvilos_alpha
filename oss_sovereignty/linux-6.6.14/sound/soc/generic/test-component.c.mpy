{
  "module_name": "test-component.c",
  "hash_id": "b780d639a6d515b7c5d0ec00aaaae59bbd8f68a5c88794dea772d8e1059d9361",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/generic/test-component.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#define TEST_NAME_LEN 32\nstruct test_dai_name {\n\tchar name[TEST_NAME_LEN];\n\tchar name_playback[TEST_NAME_LEN];\n\tchar name_capture[TEST_NAME_LEN];\n};\n\nstruct test_priv {\n\tstruct device *dev;\n\tstruct snd_pcm_substream *substream;\n\tstruct delayed_work dwork;\n\tstruct snd_soc_component_driver *component_driver;\n\tstruct snd_soc_dai_driver *dai_driver;\n\tstruct test_dai_name *name;\n};\n\nstruct test_adata {\n\tu32 is_cpu:1;\n\tu32 cmp_v:1;\n\tu32 dai_v:1;\n};\n\n#define mile_stone(d)\t\tdev_info((d)->dev, \"%s() : %s\", __func__, (d)->driver->name)\n#define mile_stone_x(dev)\tdev_info(dev, \"%s()\", __func__)\n\nstatic int test_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t       int clk_id, unsigned int freq, int dir)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\t    unsigned int freq_in, unsigned int freq_out)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tunsigned int format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\tunsigned int clock  = fmt & SND_SOC_DAIFMT_CLOCK_MASK;\n\tunsigned int inv    = fmt & SND_SOC_DAIFMT_INV_MASK;\n\tunsigned int master = fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tchar *str;\n\n\tdev_info(dai->dev, \"name   : %s\", dai->name);\n\n\tstr = \"unknown\";\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tstr = \"i2s\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tstr = \"right_j\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tstr = \"left_j\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tstr = \"dsp_a\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tstr = \"dsp_b\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_AC97:\n\t\tstr = \"ac97\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_PDM:\n\t\tstr = \"pdm\";\n\t\tbreak;\n\t}\n\tdev_info(dai->dev, \"format : %s\", str);\n\n\tif (clock == SND_SOC_DAIFMT_CONT)\n\t\tstr = \"continuous\";\n\telse\n\t\tstr = \"gated\";\n\tdev_info(dai->dev, \"clock  : %s\", str);\n\n\tstr = \"unknown\";\n\tswitch (master) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tstr = \"clk provider, frame provider\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tstr = \"clk consumer, frame provider\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\tstr = \"clk provider, frame consumer\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tstr = \"clk consumer, frame consumer\";\n\t\tbreak;\n\t}\n\tdev_info(dai->dev, \"clock  : codec is %s\", str);\n\n\tstr = \"unknown\";\n\tswitch (inv) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tstr = \"normal bit, normal frame\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tstr = \"normal bit, invert frame\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tstr = \"invert bit, normal frame\";\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tstr = \"invert bit, invert frame\";\n\t\tbreak;\n\t}\n\tdev_info(dai->dev, \"signal : %s\", str);\n\n\treturn 0;\n}\n\nstatic int test_dai_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic void test_dai_shutdown(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n}\n\nstatic int test_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_hw_free(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic int test_dai_bespoke_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd, struct snd_soc_dai *dai)\n{\n\tmile_stone(dai);\n\n\treturn 0;\n}\n\nstatic u64 test_dai_formats =\n\t \n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_RIGHT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B\t|\n\tSND_SOC_POSSIBLE_DAIFMT_AC97\t|\n\tSND_SOC_POSSIBLE_DAIFMT_PDM\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_IF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_IF;\n\nstatic const struct snd_soc_dai_ops test_ops = {\n\t.set_fmt\t\t= test_dai_set_fmt,\n\t.startup\t\t= test_dai_startup,\n\t.shutdown\t\t= test_dai_shutdown,\n\t.auto_selectable_formats\t= &test_dai_formats,\n\t.num_auto_selectable_formats\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops test_verbose_ops = {\n\t.set_sysclk\t\t= test_dai_set_sysclk,\n\t.set_pll\t\t= test_dai_set_pll,\n\t.set_clkdiv\t\t= test_dai_set_clkdiv,\n\t.set_fmt\t\t= test_dai_set_fmt,\n\t.mute_stream\t\t= test_dai_mute_stream,\n\t.startup\t\t= test_dai_startup,\n\t.shutdown\t\t= test_dai_shutdown,\n\t.hw_params\t\t= test_dai_hw_params,\n\t.hw_free\t\t= test_dai_hw_free,\n\t.trigger\t\t= test_dai_trigger,\n\t.bespoke_trigger\t= test_dai_bespoke_trigger,\n\t.auto_selectable_formats\t= &test_dai_formats,\n\t.num_auto_selectable_formats\t= 1,\n};\n\n#define STUB_RATES\tSNDRV_PCM_RATE_8000_384000\n#define STUB_FORMATS\t(SNDRV_PCM_FMTBIT_S8\t\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_U8\t\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_S16_LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_U16_LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_U24_LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE\t| \\\n\t\t\t SNDRV_PCM_FMTBIT_U32_LE)\n\nstatic int test_component_probe(struct snd_soc_component *component)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic void test_component_remove(struct snd_soc_component *component)\n{\n\tmile_stone(component);\n}\n\nstatic int test_component_suspend(struct snd_soc_component *component)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_resume(struct snd_soc_component *component)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\n#define PREALLOC_BUFFER\t\t(32 * 1024)\nstatic int test_component_pcm_construct(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tmile_stone(component);\n\n\tsnd_pcm_set_managed_buffer_all(\n\t\trtd->pcm,\n\t\tSNDRV_DMA_TYPE_DEV,\n\t\trtd->card->snd_card->dev,\n\t\tPREALLOC_BUFFER, PREALLOC_BUFFER);\n\n\treturn 0;\n}\n\nstatic void test_component_pcm_destruct(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm *pcm)\n{\n\tmile_stone(component);\n}\n\nstatic int test_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\t     int clk_id, int source, unsigned int freq, int dir)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_set_pll(struct snd_soc_component *component, int pll_id,\n\t\t\t\t  int source, unsigned int freq_in, unsigned int freq_out)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_set_jack(struct snd_soc_component *component,\n\t\t\t\t   struct snd_soc_jack *jack,  void *data)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic void test_component_seq_notifier(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_dapm_type type, int subseq)\n{\n\tmile_stone(component);\n}\n\nstatic int test_component_stream_event(struct snd_soc_component *component, int event)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\t enum snd_soc_bias_level level)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic const struct snd_pcm_hardware test_component_hardware = {\n\t \n\t.info\t\t\t= SNDRV_PCM_INFO_INTERLEAVED\t|\n\t\t\t\t  SNDRV_PCM_INFO_MMAP\t\t|\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID,\n\t.buffer_bytes_max\t= 32 * 1024,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 8192,\n\t.periods_min\t\t= 1,\n\t.periods_max\t\t= 128,\n\t.fifo_size\t\t= 256,\n};\n\nstatic int test_component_open(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tmile_stone(component);\n\n\t \n\tif (!rtd->dai_link->no_pcm)\n\t\tsnd_soc_set_runtime_hwparams(substream, &test_component_hardware);\n\n\treturn 0;\n}\n\nstatic int test_component_close(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_ioctl(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tunsigned int cmd, void *arg)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_hw_params(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_hw_free(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_prepare(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic void test_component_timer_stop(struct test_priv *priv)\n{\n\tcancel_delayed_work(&priv->dwork);\n}\n\nstatic void test_component_timer_start(struct test_priv *priv)\n{\n\tschedule_delayed_work(&priv->dwork, msecs_to_jiffies(10));\n}\n\nstatic void test_component_dwork(struct work_struct *work)\n{\n\tstruct test_priv *priv = container_of(work, struct test_priv, dwork.work);\n\n\tif (priv->substream)\n\t\tsnd_pcm_period_elapsed(priv->substream);\n\n\ttest_component_timer_start(priv);\n}\n\nstatic int test_component_trigger(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct test_priv *priv = dev_get_drvdata(component->dev);\n\n\tmile_stone(component);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\ttest_component_timer_start(priv);\n\t\tpriv->substream = substream;  \n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tpriv->substream = NULL;\n\t\ttest_component_timer_stop(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int test_component_sync_stop(struct snd_soc_component *component,\n\t\t\t\t    struct snd_pcm_substream *substream)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t test_component_pointer(struct snd_soc_component *component,\n\t\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstatic int pointer;\n\n\tif (!runtime)\n\t\treturn 0;\n\n\tpointer += 10;\n\tif (pointer > PREALLOC_BUFFER)\n\t\tpointer = 0;\n\n\t \n\n\treturn bytes_to_frames(runtime, pointer);\n}\n\nstatic int test_component_get_time_info(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\t\tstruct timespec64 *system_ts,\n\t\t\t\t\tstruct timespec64 *audio_ts,\n\t\t\t\t\tstruct snd_pcm_audio_tstamp_config *audio_tstamp_config,\n\t\t\t\t\tstruct snd_pcm_audio_tstamp_report *audio_tstamp_report)\n{\n\tmile_stone(component);\n\n\treturn 0;\n}\n\nstatic int test_component_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tmile_stone_x(rtd->dev);\n\n\treturn 0;\n}\n\n \nstatic const struct test_adata test_cpu\t\t= { .is_cpu = 1, .cmp_v = 0, .dai_v = 0, };\nstatic const struct test_adata test_cpu_vv\t= { .is_cpu = 1, .cmp_v = 1, .dai_v = 1, };\nstatic const struct test_adata test_cpu_nv\t= { .is_cpu = 1, .cmp_v = 0, .dai_v = 1, };\nstatic const struct test_adata test_cpu_vn\t= { .is_cpu = 1, .cmp_v = 1, .dai_v = 0, };\n \nstatic const struct test_adata test_codec\t= { .is_cpu = 0, .cmp_v = 0, .dai_v = 0, };\nstatic const struct test_adata test_codec_vv\t= { .is_cpu = 0, .cmp_v = 1, .dai_v = 1, };\nstatic const struct test_adata test_codec_nv\t= { .is_cpu = 0, .cmp_v = 0, .dai_v = 1, };\nstatic const struct test_adata test_codec_vn\t= { .is_cpu = 0, .cmp_v = 1, .dai_v = 0, };\n\nstatic const struct of_device_id test_of_match[] = {\n\t{ .compatible = \"test-cpu\",\t\t\t.data = (void *)&test_cpu,    },\n\t{ .compatible = \"test-cpu-verbose\",\t\t.data = (void *)&test_cpu_vv, },\n\t{ .compatible = \"test-cpu-verbose-dai\",\t\t.data = (void *)&test_cpu_nv, },\n\t{ .compatible = \"test-cpu-verbose-component\",\t.data = (void *)&test_cpu_vn, },\n\t{ .compatible = \"test-codec\",\t\t\t.data = (void *)&test_codec,    },\n\t{ .compatible = \"test-codec-verbose\",\t\t.data = (void *)&test_codec_vv, },\n\t{ .compatible = \"test-codec-verbose-dai\",\t.data = (void *)&test_codec_nv, },\n\t{ .compatible = \"test-codec-verbose-component\",\t.data = (void *)&test_codec_vn, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, test_of_match);\n\nstatic const struct snd_soc_dapm_widget widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"IN\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic int test_driver_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *ep;\n\tconst struct test_adata *adata = of_device_get_match_data(&pdev->dev);\n\tstruct snd_soc_component_driver *cdriv;\n\tstruct snd_soc_dai_driver *ddriv;\n\tstruct test_dai_name *dname;\n\tstruct test_priv *priv;\n\tint num, ret, i;\n\n\tnum = of_graph_get_endpoint_count(node);\n\tif (!num) {\n\t\tdev_err(dev, \"no port exits\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv\t= devm_kzalloc(dev, sizeof(*priv),\t\tGFP_KERNEL);\n\tcdriv\t= devm_kzalloc(dev, sizeof(*cdriv),\t\tGFP_KERNEL);\n\tddriv\t= devm_kzalloc(dev, sizeof(*ddriv) * num,\tGFP_KERNEL);\n\tdname\t= devm_kzalloc(dev, sizeof(*dname) * num,\tGFP_KERNEL);\n\tif (!priv || !cdriv || !ddriv || !dname || !adata)\n\t\treturn -EINVAL;\n\n\tpriv->dev\t\t= dev;\n\tpriv->component_driver\t= cdriv;\n\tpriv->dai_driver\t= ddriv;\n\tpriv->name\t\t= dname;\n\n\tINIT_DELAYED_WORK(&priv->dwork, test_component_dwork);\n\tdev_set_drvdata(dev, priv);\n\n\tif (adata->is_cpu) {\n\t\tcdriv->name\t\t\t= \"test_cpu\";\n\t\tcdriv->pcm_construct\t\t= test_component_pcm_construct;\n\t\tcdriv->pointer\t\t\t= test_component_pointer;\n\t\tcdriv->trigger\t\t\t= test_component_trigger;\n\t\tcdriv->legacy_dai_naming\t= 1;\n\t} else {\n\t\tcdriv->name\t\t\t= \"test_codec\";\n\t\tcdriv->idle_bias_on\t\t= 1;\n\t\tcdriv->endianness\t\t= 1;\n\t}\n\n\tcdriv->open\t\t= test_component_open;\n\tcdriv->dapm_widgets\t= widgets;\n\tcdriv->num_dapm_widgets\t= ARRAY_SIZE(widgets);\n\n\tif (adata->cmp_v) {\n\t\tcdriv->probe\t\t\t= test_component_probe;\n\t\tcdriv->remove\t\t\t= test_component_remove;\n\t\tcdriv->suspend\t\t\t= test_component_suspend;\n\t\tcdriv->resume\t\t\t= test_component_resume;\n\t\tcdriv->set_sysclk\t\t= test_component_set_sysclk;\n\t\tcdriv->set_pll\t\t\t= test_component_set_pll;\n\t\tcdriv->set_jack\t\t\t= test_component_set_jack;\n\t\tcdriv->seq_notifier\t\t= test_component_seq_notifier;\n\t\tcdriv->stream_event\t\t= test_component_stream_event;\n\t\tcdriv->set_bias_level\t\t= test_component_set_bias_level;\n\t\tcdriv->close\t\t\t= test_component_close;\n\t\tcdriv->ioctl\t\t\t= test_component_ioctl;\n\t\tcdriv->hw_params\t\t= test_component_hw_params;\n\t\tcdriv->hw_free\t\t\t= test_component_hw_free;\n\t\tcdriv->prepare\t\t\t= test_component_prepare;\n\t\tcdriv->sync_stop\t\t= test_component_sync_stop;\n\t\tcdriv->get_time_info\t\t= test_component_get_time_info;\n\t\tcdriv->be_hw_params_fixup\t= test_component_be_hw_params_fixup;\n\n\t\tif (adata->is_cpu)\n\t\t\tcdriv->pcm_destruct\t= test_component_pcm_destruct;\n\t}\n\n\ti = 0;\n\tfor_each_endpoint_of_node(node, ep) {\n\t\tsnprintf(dname[i].name, TEST_NAME_LEN, \"%s.%d\", node->name, i);\n\t\tddriv[i].name = dname[i].name;\n\n\t\tsnprintf(dname[i].name_playback, TEST_NAME_LEN, \"DAI%d Playback\", i);\n\t\tddriv[i].playback.stream_name\t= dname[i].name_playback;\n\t\tddriv[i].playback.channels_min\t= 1;\n\t\tddriv[i].playback.channels_max\t= 384;\n\t\tddriv[i].playback.rates\t\t= STUB_RATES;\n\t\tddriv[i].playback.formats\t= STUB_FORMATS;\n\n\t\tsnprintf(dname[i].name_capture, TEST_NAME_LEN, \"DAI%d Capture\", i);\n\t\tddriv[i].capture.stream_name\t= dname[i].name_capture;\n\t\tddriv[i].capture.channels_min\t= 1;\n\t\tddriv[i].capture.channels_max\t= 384;\n\t\tddriv[i].capture.rates\t\t= STUB_RATES;\n\t\tddriv[i].capture.formats\t= STUB_FORMATS;\n\n\t\tif (adata->dai_v)\n\t\t\tddriv[i].ops = &test_verbose_ops;\n\t\telse\n\t\t\tddriv[i].ops = &test_ops;\n\n\t\ti++;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, cdriv, ddriv, num);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmile_stone_x(dev);\n\n\treturn 0;\n}\n\nstatic void test_driver_remove(struct platform_device *pdev)\n{\n\tmile_stone_x(&pdev->dev);\n}\n\nstatic struct platform_driver test_driver = {\n\t.driver = {\n\t\t.name = \"test-component\",\n\t\t.of_match_table = test_of_match,\n\t},\n\t.probe  = test_driver_probe,\n\t.remove_new = test_driver_remove,\n};\nmodule_platform_driver(test_driver);\n\nMODULE_ALIAS(\"platform:asoc-test-component\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_DESCRIPTION(\"ASoC Test Component\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}