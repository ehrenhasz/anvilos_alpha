{
  "module_name": "simple-card-utils.c",
  "hash_id": "055902ba24aab36819ab248a63221afd3d1bc4b7d625801eae29d0be5d7e707a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/generic/simple-card-utils.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <sound/jack.h>\n#include <sound/pcm_params.h>\n#include <sound/simple_card_utils.h>\n\nstatic void asoc_simple_fixup_sample_fmt(struct asoc_simple_data *data,\n\t\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tint i;\n\tstruct snd_mask *mask = hw_param_mask(params,\n\t\t\t\t\t      SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct {\n\t\tchar *fmt;\n\t\tu32 val;\n\t} of_sample_fmt_table[] = {\n\t\t{ \"s8\",\t\tSNDRV_PCM_FORMAT_S8},\n\t\t{ \"s16_le\",\tSNDRV_PCM_FORMAT_S16_LE},\n\t\t{ \"s24_le\",\tSNDRV_PCM_FORMAT_S24_LE},\n\t\t{ \"s24_3le\",\tSNDRV_PCM_FORMAT_S24_3LE},\n\t\t{ \"s32_le\",\tSNDRV_PCM_FORMAT_S32_LE},\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(of_sample_fmt_table); i++) {\n\t\tif (!strcmp(data->convert_sample_format,\n\t\t\t    of_sample_fmt_table[i].fmt)) {\n\t\t\tsnd_mask_none(mask);\n\t\t\tsnd_mask_set(mask, of_sample_fmt_table[i].val);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid asoc_simple_parse_convert(struct device_node *np,\n\t\t\t       char *prefix,\n\t\t\t       struct asoc_simple_data *data)\n{\n\tchar prop[128];\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"convert-rate\");\n\tof_property_read_u32(np, prop, &data->convert_rate);\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"convert-channels\");\n\tof_property_read_u32(np, prop, &data->convert_channels);\n\n\t \n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"convert-sample-format\");\n\tof_property_read_string(np, prop, &data->convert_sample_format);\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_convert);\n\n \nbool asoc_simple_is_convert_required(const struct asoc_simple_data *data)\n{\n\treturn data->convert_rate ||\n\t       data->convert_channels ||\n\t       data->convert_sample_format;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_is_convert_required);\n\nint asoc_simple_parse_daifmt(struct device *dev,\n\t\t\t     struct device_node *node,\n\t\t\t     struct device_node *codec,\n\t\t\t     char *prefix,\n\t\t\t     unsigned int *retfmt)\n{\n\tstruct device_node *bitclkmaster = NULL;\n\tstruct device_node *framemaster = NULL;\n\tunsigned int daifmt;\n\n\tdaifmt = snd_soc_daifmt_parse_format(node, prefix);\n\n\tsnd_soc_daifmt_parse_clock_provider_as_phandle(node, prefix, &bitclkmaster, &framemaster);\n\tif (!bitclkmaster && !framemaster) {\n\t\t \n\t\tdev_dbg(dev, \"Revert to legacy daifmt parsing\\n\");\n\n\t\tdaifmt |= snd_soc_daifmt_parse_clock_provider_as_flag(codec, NULL);\n\t} else {\n\t\tdaifmt |= snd_soc_daifmt_clock_provider_from_bitmap(\n\t\t\t\t((codec == bitclkmaster) << 4) | (codec == framemaster));\n\t}\n\n\tof_node_put(bitclkmaster);\n\tof_node_put(framemaster);\n\n\t*retfmt = daifmt;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_daifmt);\n\nint asoc_simple_parse_tdm_width_map(struct device *dev, struct device_node *np,\n\t\t\t\t    struct asoc_simple_dai *dai)\n{\n\tu32 *array_values, *p;\n\tint n, i, ret;\n\n\tif (!of_property_read_bool(np, \"dai-tdm-slot-width-map\"))\n\t\treturn 0;\n\n\tn = of_property_count_elems_of_size(np, \"dai-tdm-slot-width-map\", sizeof(u32));\n\tif (n % 3) {\n\t\tdev_err(dev, \"Invalid number of cells for dai-tdm-slot-width-map\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdai->tdm_width_map = devm_kcalloc(dev, n, sizeof(*dai->tdm_width_map), GFP_KERNEL);\n\tif (!dai->tdm_width_map)\n\t\treturn -ENOMEM;\n\n\tarray_values = kcalloc(n, sizeof(*array_values), GFP_KERNEL);\n\tif (!array_values)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32_array(np, \"dai-tdm-slot-width-map\", array_values, n);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not read dai-tdm-slot-width-map: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tp = array_values;\n\tfor (i = 0; i < n / 3; ++i) {\n\t\tdai->tdm_width_map[i].sample_bits = *p++;\n\t\tdai->tdm_width_map[i].slot_width = *p++;\n\t\tdai->tdm_width_map[i].slot_count = *p++;\n\t}\n\n\tdai->n_tdm_widths = i;\n\tret = 0;\nout:\n\tkfree(array_values);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_tdm_width_map);\n\nint asoc_simple_set_dailink_name(struct device *dev,\n\t\t\t\t struct snd_soc_dai_link *dai_link,\n\t\t\t\t const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *name = NULL;\n\tint ret = -ENOMEM;\n\n\tva_start(ap, fmt);\n\tname = devm_kvasprintf(dev, GFP_KERNEL, fmt, ap);\n\tva_end(ap);\n\n\tif (name) {\n\t\tret = 0;\n\n\t\tdai_link->name\t\t= name;\n\t\tdai_link->stream_name\t= name;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_set_dailink_name);\n\nint asoc_simple_parse_card_name(struct snd_soc_card *card,\n\t\t\t\tchar *prefix)\n{\n\tint ret;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\t \n\tret = snd_soc_of_parse_card_name(card, \"label\");\n\tif (ret < 0 || !card->name) {\n\t\tchar prop[128];\n\n\t\tsnprintf(prop, sizeof(prop), \"%sname\", prefix);\n\t\tret = snd_soc_of_parse_card_name(card, prop);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!card->name && card->dai_link)\n\t\tcard->name = card->dai_link->name;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_card_name);\n\nstatic int asoc_simple_clk_enable(struct asoc_simple_dai *dai)\n{\n\tif (dai)\n\t\treturn clk_prepare_enable(dai->clk);\n\n\treturn 0;\n}\n\nstatic void asoc_simple_clk_disable(struct asoc_simple_dai *dai)\n{\n\tif (dai)\n\t\tclk_disable_unprepare(dai->clk);\n}\n\nint asoc_simple_parse_clk(struct device *dev,\n\t\t\t  struct device_node *node,\n\t\t\t  struct asoc_simple_dai *simple_dai,\n\t\t\t  struct snd_soc_dai_link_component *dlc)\n{\n\tstruct clk *clk;\n\tu32 val;\n\n\t \n\tclk = devm_get_clk_from_child(dev, node, NULL);\n\tsimple_dai->clk_fixed = of_property_read_bool(\n\t\tnode, \"system-clock-fixed\");\n\tif (!IS_ERR(clk)) {\n\t\tsimple_dai->sysclk = clk_get_rate(clk);\n\n\t\tsimple_dai->clk = clk;\n\t} else if (!of_property_read_u32(node, \"system-clock-frequency\", &val)) {\n\t\tsimple_dai->sysclk = val;\n\t\tsimple_dai->clk_fixed = true;\n\t} else {\n\t\tclk = devm_get_clk_from_child(dev, dlc->of_node, NULL);\n\t\tif (!IS_ERR(clk))\n\t\t\tsimple_dai->sysclk = clk_get_rate(clk);\n\t}\n\n\tif (of_property_read_bool(node, \"system-clock-direction-out\"))\n\t\tsimple_dai->clk_direction = SND_SOC_CLOCK_OUT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_clk);\n\nstatic int asoc_simple_check_fixed_sysclk(struct device *dev,\n\t\t\t\t\t  struct asoc_simple_dai *dai,\n\t\t\t\t\t  unsigned int *fixed_sysclk)\n{\n\tif (dai->clk_fixed) {\n\t\tif (*fixed_sysclk && *fixed_sysclk != dai->sysclk) {\n\t\t\tdev_err(dev, \"inconsistent fixed sysclk rates (%u vs %u)\\n\",\n\t\t\t\t*fixed_sysclk, dai->sysclk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*fixed_sysclk = dai->sysclk;\n\t}\n\n\treturn 0;\n}\n\nint asoc_simple_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct simple_dai_props *props = simple_priv_to_props(priv, rtd->num);\n\tstruct asoc_simple_dai *dai;\n\tunsigned int fixed_sysclk = 0;\n\tint i1, i2, i;\n\tint ret;\n\n\tfor_each_prop_dai_cpu(props, i1, dai) {\n\t\tret = asoc_simple_clk_enable(dai);\n\t\tif (ret)\n\t\t\tgoto cpu_err;\n\t\tret = asoc_simple_check_fixed_sysclk(rtd->dev, dai, &fixed_sysclk);\n\t\tif (ret)\n\t\t\tgoto cpu_err;\n\t}\n\n\tfor_each_prop_dai_codec(props, i2, dai) {\n\t\tret = asoc_simple_clk_enable(dai);\n\t\tif (ret)\n\t\t\tgoto codec_err;\n\t\tret = asoc_simple_check_fixed_sysclk(rtd->dev, dai, &fixed_sysclk);\n\t\tif (ret)\n\t\t\tgoto codec_err;\n\t}\n\n\tif (fixed_sysclk && props->mclk_fs) {\n\t\tunsigned int fixed_rate = fixed_sysclk / props->mclk_fs;\n\n\t\tif (fixed_sysclk % props->mclk_fs) {\n\t\t\tdev_err(rtd->dev, \"fixed sysclk %u not divisible by mclk_fs %u\\n\",\n\t\t\t\tfixed_sysclk, props->mclk_fs);\n\t\t\tret = -EINVAL;\n\t\t\tgoto codec_err;\n\t\t}\n\t\tret = snd_pcm_hw_constraint_minmax(substream->runtime, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\tfixed_rate, fixed_rate);\n\t\tif (ret < 0)\n\t\t\tgoto codec_err;\n\t}\n\n\treturn 0;\n\ncodec_err:\n\tfor_each_prop_dai_codec(props, i, dai) {\n\t\tif (i >= i2)\n\t\t\tbreak;\n\t\tasoc_simple_clk_disable(dai);\n\t}\ncpu_err:\n\tfor_each_prop_dai_cpu(props, i, dai) {\n\t\tif (i >= i1)\n\t\t\tbreak;\n\t\tasoc_simple_clk_disable(dai);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_startup);\n\nvoid asoc_simple_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct simple_dai_props *props = simple_priv_to_props(priv, rtd->num);\n\tstruct asoc_simple_dai *dai;\n\tint i;\n\n\tfor_each_prop_dai_cpu(props, i, dai) {\n\t\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, i);\n\n\t\tif (props->mclk_fs && !dai->clk_fixed && !snd_soc_dai_active(cpu_dai))\n\t\t\tsnd_soc_dai_set_sysclk(cpu_dai,\n\t\t\t\t\t       0, 0, SND_SOC_CLOCK_OUT);\n\n\t\tasoc_simple_clk_disable(dai);\n\t}\n\tfor_each_prop_dai_codec(props, i, dai) {\n\t\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, i);\n\n\t\tif (props->mclk_fs && !dai->clk_fixed && !snd_soc_dai_active(codec_dai))\n\t\t\tsnd_soc_dai_set_sysclk(codec_dai,\n\t\t\t\t\t       0, 0, SND_SOC_CLOCK_IN);\n\n\t\tasoc_simple_clk_disable(dai);\n\t}\n}\nEXPORT_SYMBOL_GPL(asoc_simple_shutdown);\n\nstatic int asoc_simple_set_clk_rate(struct device *dev,\n\t\t\t\t    struct asoc_simple_dai *simple_dai,\n\t\t\t\t    unsigned long rate)\n{\n\tif (!simple_dai)\n\t\treturn 0;\n\n\tif (simple_dai->clk_fixed && rate != simple_dai->sysclk) {\n\t\tdev_err(dev, \"dai %s invalid clock rate %lu\\n\", simple_dai->name, rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!simple_dai->clk)\n\t\treturn 0;\n\n\tif (clk_get_rate(simple_dai->clk) == rate)\n\t\treturn 0;\n\n\treturn clk_set_rate(simple_dai->clk, rate);\n}\n\nstatic int asoc_simple_set_tdm(struct snd_soc_dai *dai,\n\t\t\t\tstruct asoc_simple_dai *simple_dai,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tint sample_bits = params_width(params);\n\tint slot_width, slot_count;\n\tint i, ret;\n\n\tif (!simple_dai || !simple_dai->tdm_width_map)\n\t\treturn 0;\n\n\tslot_width = simple_dai->slot_width;\n\tslot_count = simple_dai->slots;\n\n\tif (slot_width == 0)\n\t\tslot_width = sample_bits;\n\n\tfor (i = 0; i < simple_dai->n_tdm_widths; ++i) {\n\t\tif (simple_dai->tdm_width_map[i].sample_bits == sample_bits) {\n\t\t\tslot_width = simple_dai->tdm_width_map[i].slot_width;\n\t\t\tslot_count = simple_dai->tdm_width_map[i].slot_count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_tdm_slot(dai,\n\t\t\t\t       simple_dai->tx_slot_mask,\n\t\t\t\t       simple_dai->rx_slot_mask,\n\t\t\t\t       slot_count,\n\t\t\t\t       slot_width);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dai->dev, \"simple-card: set_tdm_slot error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint asoc_simple_hw_params(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct asoc_simple_dai *pdai;\n\tstruct snd_soc_dai *sdai;\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct simple_dai_props *props = simple_priv_to_props(priv, rtd->num);\n\tunsigned int mclk, mclk_fs = 0;\n\tint i, ret;\n\n\tif (props->mclk_fs)\n\t\tmclk_fs = props->mclk_fs;\n\n\tif (mclk_fs) {\n\t\tstruct snd_soc_component *component;\n\t\tmclk = params_rate(params) * mclk_fs;\n\n\t\tfor_each_prop_dai_codec(props, i, pdai) {\n\t\t\tret = asoc_simple_set_clk_rate(rtd->dev, pdai, mclk);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor_each_prop_dai_cpu(props, i, pdai) {\n\t\t\tret = asoc_simple_set_clk_rate(rtd->dev, pdai, mclk);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tfor_each_rtd_components(rtd, i, component) {\n\t\t\tret = snd_soc_component_set_sysclk(component, 0, 0,\n\t\t\t\t\t\t\t   mclk, SND_SOC_CLOCK_IN);\n\t\t\tif (ret && ret != -ENOTSUPP)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor_each_rtd_codec_dais(rtd, i, sdai) {\n\t\t\tret = snd_soc_dai_set_sysclk(sdai, 0, mclk, SND_SOC_CLOCK_IN);\n\t\t\tif (ret && ret != -ENOTSUPP)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor_each_rtd_cpu_dais(rtd, i, sdai) {\n\t\t\tret = snd_soc_dai_set_sysclk(sdai, 0, mclk, SND_SOC_CLOCK_OUT);\n\t\t\tif (ret && ret != -ENOTSUPP)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_prop_dai_codec(props, i, pdai) {\n\t\tsdai = asoc_rtd_to_codec(rtd, i);\n\t\tret = asoc_simple_set_tdm(sdai, pdai, params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor_each_prop_dai_cpu(props, i, pdai) {\n\t\tsdai = asoc_rtd_to_cpu(rtd, i);\n\t\tret = asoc_simple_set_tdm(sdai, pdai, params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_hw_params);\n\nint asoc_simple_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, rtd->num);\n\tstruct asoc_simple_data *data = &dai_props->adata;\n\tstruct snd_interval *rate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tstruct snd_interval *channels = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\n\tif (data->convert_rate)\n\t\trate->min =\n\t\trate->max = data->convert_rate;\n\n\tif (data->convert_channels)\n\t\tchannels->min =\n\t\tchannels->max = data->convert_channels;\n\n\tif (data->convert_sample_format)\n\t\tasoc_simple_fixup_sample_fmt(data, params);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_be_hw_params_fixup);\n\nstatic int asoc_simple_init_dai(struct snd_soc_dai *dai,\n\t\t\t\t     struct asoc_simple_dai *simple_dai)\n{\n\tint ret;\n\n\tif (!simple_dai)\n\t\treturn 0;\n\n\tif (simple_dai->sysclk) {\n\t\tret = snd_soc_dai_set_sysclk(dai, 0, simple_dai->sysclk,\n\t\t\t\t\t     simple_dai->clk_direction);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dai->dev, \"simple-card: set_sysclk error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (simple_dai->slots) {\n\t\tret = snd_soc_dai_set_tdm_slot(dai,\n\t\t\t\t\t       simple_dai->tx_slot_mask,\n\t\t\t\t\t       simple_dai->rx_slot_mask,\n\t\t\t\t\t       simple_dai->slots,\n\t\t\t\t\t       simple_dai->slot_width);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dai->dev, \"simple-card: set_tdm_slot error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int asoc_simple_component_is_codec(struct snd_soc_component *component)\n{\n\treturn component->driver->endianness;\n}\n\nstatic int asoc_simple_init_for_codec2codec(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t\t    struct simple_dai_props *dai_props)\n{\n\tstruct snd_soc_dai_link *dai_link = rtd->dai_link;\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_pcm_stream *c2c_params;\n\tstruct snd_pcm_hardware hw;\n\tint i, ret, stream;\n\n\t \n\tif (dai_link->c2c_params)\n\t\treturn 0;\n\n\t \n\tif (dai_link->no_pcm)\n\t\treturn 0;\n\n\t \n\tfor_each_rtd_components(rtd, i, component) {\n\t\tif (!asoc_simple_component_is_codec(component))\n\t\t\treturn 0;\n\t}\n\n\t \n\tfor_each_pcm_streams(stream) {\n\t\tret = snd_soc_runtime_calc_hw(rtd, &hw, stream);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0) {\n\t\tdev_err(rtd->dev, \"simple-card: no valid dai_link params\\n\");\n\t\treturn ret;\n\t}\n\n\tc2c_params = devm_kzalloc(rtd->dev, sizeof(*c2c_params), GFP_KERNEL);\n\tif (!c2c_params)\n\t\treturn -ENOMEM;\n\n\tc2c_params->formats\t\t= hw.formats;\n\tc2c_params->rates\t\t= hw.rates;\n\tc2c_params->rate_min\t\t= hw.rate_min;\n\tc2c_params->rate_max\t\t= hw.rate_max;\n\tc2c_params->channels_min\t= hw.channels_min;\n\tc2c_params->channels_max\t= hw.channels_max;\n\n\tdai_link->c2c_params\t\t= c2c_params;\n\tdai_link->num_c2c_params\t= 1;\n\n\treturn 0;\n}\n\nint asoc_simple_dai_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct simple_dai_props *props = simple_priv_to_props(priv, rtd->num);\n\tstruct asoc_simple_dai *dai;\n\tint i, ret;\n\n\tfor_each_prop_dai_codec(props, i, dai) {\n\t\tret = asoc_simple_init_dai(asoc_rtd_to_codec(rtd, i), dai);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tfor_each_prop_dai_cpu(props, i, dai) {\n\t\tret = asoc_simple_init_dai(asoc_rtd_to_cpu(rtd, i), dai);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = asoc_simple_init_for_codec2codec(rtd, props);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_dai_init);\n\nvoid asoc_simple_canonicalize_platform(struct snd_soc_dai_link_component *platforms,\n\t\t\t\t       struct snd_soc_dai_link_component *cpus)\n{\n\t \n\tif (!platforms->of_node)\n\t\tsnd_soc_dlc_use_cpu_as_platform(platforms, cpus);\n}\nEXPORT_SYMBOL_GPL(asoc_simple_canonicalize_platform);\n\nvoid asoc_simple_canonicalize_cpu(struct snd_soc_dai_link_component *cpus,\n\t\t\t\t  int is_single_links)\n{\n\t \n\tif (is_single_links)\n\t\tcpus->dai_name = NULL;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_canonicalize_cpu);\n\nvoid asoc_simple_clean_reference(struct snd_soc_card *card)\n{\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct snd_soc_dai_link_component *cpu;\n\tstruct snd_soc_dai_link_component *codec;\n\tint i, j;\n\n\tfor_each_card_prelinks(card, i, dai_link) {\n\t\tfor_each_link_cpus(dai_link, j, cpu)\n\t\t\tof_node_put(cpu->of_node);\n\t\tfor_each_link_codecs(dai_link, j, codec)\n\t\t\tof_node_put(codec->of_node);\n\t}\n}\nEXPORT_SYMBOL_GPL(asoc_simple_clean_reference);\n\nint asoc_simple_parse_routing(struct snd_soc_card *card,\n\t\t\t      char *prefix)\n{\n\tstruct device_node *node = card->dev->of_node;\n\tchar prop[128];\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"routing\");\n\n\tif (!of_property_read_bool(node, prop))\n\t\treturn 0;\n\n\treturn snd_soc_of_parse_audio_routing(card, prop);\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_routing);\n\nint asoc_simple_parse_widgets(struct snd_soc_card *card,\n\t\t\t      char *prefix)\n{\n\tstruct device_node *node = card->dev->of_node;\n\tchar prop[128];\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"widgets\");\n\n\tif (of_property_read_bool(node, prop))\n\t\treturn snd_soc_of_parse_audio_simple_widgets(card, prop);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_widgets);\n\nint asoc_simple_parse_pin_switches(struct snd_soc_card *card,\n\t\t\t\t   char *prefix)\n{\n\tchar prop[128];\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tsnprintf(prop, sizeof(prop), \"%s%s\", prefix, \"pin-switches\");\n\n\treturn snd_soc_of_parse_pin_switches(card, prop);\n}\nEXPORT_SYMBOL_GPL(asoc_simple_parse_pin_switches);\n\nint asoc_simple_init_jack(struct snd_soc_card *card,\n\t\t\t  struct asoc_simple_jack *sjack,\n\t\t\t  int is_hp, char *prefix,\n\t\t\t  char *pin)\n{\n\tstruct device *dev = card->dev;\n\tstruct gpio_desc *desc;\n\tchar prop[128];\n\tchar *pin_name;\n\tchar *gpio_name;\n\tint mask;\n\tint error;\n\n\tif (!prefix)\n\t\tprefix = \"\";\n\n\tsjack->gpio.gpio = -ENOENT;\n\n\tif (is_hp) {\n\t\tsnprintf(prop, sizeof(prop), \"%shp-det\", prefix);\n\t\tpin_name\t= pin ? pin : \"Headphones\";\n\t\tgpio_name\t= \"Headphone detection\";\n\t\tmask\t\t= SND_JACK_HEADPHONE;\n\t} else {\n\t\tsnprintf(prop, sizeof(prop), \"%smic-det\", prefix);\n\t\tpin_name\t= pin ? pin : \"Mic Jack\";\n\t\tgpio_name\t= \"Mic detection\";\n\t\tmask\t\t= SND_JACK_MICROPHONE;\n\t}\n\n\tdesc = gpiod_get_optional(dev, prop, GPIOD_IN);\n\terror = PTR_ERR_OR_ZERO(desc);\n\tif (error)\n\t\treturn error;\n\n\tif (desc) {\n\t\terror = gpiod_set_consumer_name(desc, gpio_name);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tsjack->pin.pin\t\t= pin_name;\n\t\tsjack->pin.mask\t\t= mask;\n\n\t\tsjack->gpio.name\t= gpio_name;\n\t\tsjack->gpio.report\t= mask;\n\t\tsjack->gpio.desc\t= desc;\n\t\tsjack->gpio.debounce_time = 150;\n\n\t\tsnd_soc_card_jack_new_pins(card, pin_name, mask, &sjack->jack,\n\t\t\t\t\t   &sjack->pin, 1);\n\n\t\tsnd_soc_jack_add_gpios(&sjack->jack, 1, &sjack->gpio);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_init_jack);\n\nint asoc_simple_init_aux_jacks(struct asoc_simple_priv *priv, char *prefix)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tstruct snd_soc_component *component;\n\tint found_jack_index = 0;\n\tint type = 0;\n\tint num = 0;\n\tint ret;\n\n\tif (priv->aux_jacks)\n\t\treturn 0;\n\n\tfor_each_card_auxs(card, component) {\n\t\ttype = snd_soc_component_get_jack_type(component);\n\t\tif (type > 0)\n\t\t\tnum++;\n\t}\n\tif (num < 1)\n\t\treturn 0;\n\n\tpriv->aux_jacks = devm_kcalloc(card->dev, num,\n\t\t\t\t       sizeof(struct snd_soc_jack), GFP_KERNEL);\n\tif (!priv->aux_jacks)\n\t\treturn -ENOMEM;\n\n\tfor_each_card_auxs(card, component) {\n\t\tchar id[128];\n\t\tstruct snd_soc_jack *jack;\n\n\t\tif (found_jack_index >= num)\n\t\t\tbreak;\n\n\t\ttype = snd_soc_component_get_jack_type(component);\n\t\tif (type <= 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tjack = &(priv->aux_jacks[found_jack_index++]);\n\t\tsnprintf(id, sizeof(id), \"%s-jack\", component->name);\n\t\tret = snd_soc_card_jack_new(card, id, type, jack);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t(void)snd_soc_component_set_jack(component, jack, NULL);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_init_aux_jacks);\n\nint asoc_simple_init_priv(struct asoc_simple_priv *priv,\n\t\t\t  struct link_info *li)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link;\n\tstruct simple_dai_props *dai_props;\n\tstruct asoc_simple_dai *dais;\n\tstruct snd_soc_dai_link_component *dlcs;\n\tstruct snd_soc_codec_conf *cconf = NULL;\n\tint i, dai_num = 0, dlc_num = 0, cnf_num = 0;\n\n\tdai_props = devm_kcalloc(dev, li->link, sizeof(*dai_props), GFP_KERNEL);\n\tdai_link  = devm_kcalloc(dev, li->link, sizeof(*dai_link),  GFP_KERNEL);\n\tif (!dai_props || !dai_link)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < li->link; i++) {\n\t\tint cc = li->num[i].cpus + li->num[i].codecs;\n\n\t\tdai_num += cc;\n\t\tdlc_num += cc + li->num[i].platforms;\n\n\t\tif (!li->num[i].cpus)\n\t\t\tcnf_num += li->num[i].codecs;\n\t}\n\n\tdais = devm_kcalloc(dev, dai_num, sizeof(*dais), GFP_KERNEL);\n\tdlcs = devm_kcalloc(dev, dlc_num, sizeof(*dlcs), GFP_KERNEL);\n\tif (!dais || !dlcs)\n\t\treturn -ENOMEM;\n\n\tif (cnf_num) {\n\t\tcconf = devm_kcalloc(dev, cnf_num, sizeof(*cconf), GFP_KERNEL);\n\t\tif (!cconf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(dev, \"link %d, dais %d, ccnf %d\\n\",\n\t\tli->link, dai_num, cnf_num);\n\n\tpriv->dai_props\t\t= dai_props;\n\tpriv->dai_link\t\t= dai_link;\n\tpriv->dais\t\t= dais;\n\tpriv->dlcs\t\t= dlcs;\n\tpriv->codec_conf\t= cconf;\n\n\tcard->dai_link\t\t= priv->dai_link;\n\tcard->num_links\t\t= li->link;\n\tcard->codec_conf\t= cconf;\n\tcard->num_configs\t= cnf_num;\n\n\tfor (i = 0; i < li->link; i++) {\n\t\tif (li->num[i].cpus) {\n\t\t\t \n\t\t\tdai_link[i].cpus\t= dlcs;\n\t\t\tdai_props[i].num.cpus\t=\n\t\t\tdai_link[i].num_cpus\t= li->num[i].cpus;\n\t\t\tdai_props[i].cpu_dai\t= dais;\n\n\t\t\tdlcs += li->num[i].cpus;\n\t\t\tdais += li->num[i].cpus;\n\t\t} else {\n\t\t\t \n\t\t\tdai_link[i].cpus\t= &asoc_dummy_dlc;\n\t\t\tdai_props[i].num.cpus\t=\n\t\t\tdai_link[i].num_cpus\t= 1;\n\t\t}\n\n\t\tif (li->num[i].codecs) {\n\t\t\t \n\t\t\tdai_link[i].codecs\t= dlcs;\n\t\t\tdai_props[i].num.codecs\t=\n\t\t\tdai_link[i].num_codecs\t= li->num[i].codecs;\n\t\t\tdai_props[i].codec_dai\t= dais;\n\n\t\t\tdlcs += li->num[i].codecs;\n\t\t\tdais += li->num[i].codecs;\n\n\t\t\tif (!li->num[i].cpus) {\n\t\t\t\t \n\t\t\t\tdai_props[i].codec_conf = cconf;\n\t\t\t\tcconf += li->num[i].codecs;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdai_link[i].codecs\t= &asoc_dummy_dlc;\n\t\t\tdai_props[i].num.codecs\t=\n\t\t\tdai_link[i].num_codecs\t= 1;\n\t\t}\n\n\t\tif (li->num[i].platforms) {\n\t\t\t \n\t\t\tdai_link[i].platforms\t\t= dlcs;\n\t\t\tdai_props[i].num.platforms\t=\n\t\t\tdai_link[i].num_platforms\t= li->num[i].platforms;\n\n\t\t\tdlcs += li->num[i].platforms;\n\t\t} else {\n\t\t\t \n\t\t\tdai_link[i].platforms\t\t= NULL;\n\t\t\tdai_props[i].num.platforms\t=\n\t\t\tdai_link[i].num_platforms\t= 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_init_priv);\n\nint asoc_simple_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\n\tasoc_simple_clean_reference(card);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_simple_remove);\n\nint asoc_graph_card_probe(struct snd_soc_card *card)\n{\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\tret = asoc_simple_init_hp(card, &priv->hp_jack, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_init_mic(card, &priv->mic_jack, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_graph_card_probe);\n\nint asoc_graph_is_ports0(struct device_node *np)\n{\n\tstruct device_node *port, *ports, *ports0, *top;\n\tint ret;\n\n\t \n\tif (of_node_name_eq(np, \"endpoint\")) {\n\t\tport = of_get_parent(np);\n\t} else {\n\t\tport = np;\n\t\tof_node_get(port);\n\t}\n\n\tports\t= of_get_parent(port);\n\ttop\t= of_get_parent(ports);\n\tports0\t= of_get_child_by_name(top, \"ports\");\n\n\tret = ports0 == ports;\n\n\tof_node_put(port);\n\tof_node_put(ports);\n\tof_node_put(ports0);\n\tof_node_put(top);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(asoc_graph_is_ports0);\n\nstatic int graph_get_dai_id(struct device_node *ep)\n{\n\tstruct device_node *node;\n\tstruct device_node *endpoint;\n\tstruct of_endpoint info;\n\tint i, id;\n\tint ret;\n\n\t \n\tret = snd_soc_get_dai_id(ep);\n\tif (ret != -ENOTSUPP)\n\t\treturn ret;\n\n\t \n\tret = of_graph_parse_endpoint(ep, &info);\n\tif (ret == 0) {\n\t\t \n\t\tif (of_property_present(ep,   \"reg\"))\n\t\t\treturn info.id;\n\n\t\tnode = of_get_parent(ep);\n\t\tret = of_property_present(node, \"reg\");\n\t\tof_node_put(node);\n\t\tif (ret)\n\t\t\treturn info.port;\n\t}\n\tnode = of_graph_get_port_parent(ep);\n\n\t \n\ti = 0;\n\tid = -1;\n\tfor_each_endpoint_of_node(node, endpoint) {\n\t\tif (endpoint == ep)\n\t\t\tid = i;\n\t\ti++;\n\t}\n\n\tof_node_put(node);\n\n\tif (id < 0)\n\t\treturn -ENODEV;\n\n\treturn id;\n}\n\nint asoc_graph_parse_dai(struct device *dev, struct device_node *ep,\n\t\t\t struct snd_soc_dai_link_component *dlc, int *is_single_link)\n{\n\tstruct device_node *node;\n\tstruct of_phandle_args args = {};\n\tstruct snd_soc_dai *dai;\n\tint ret;\n\n\tif (!ep)\n\t\treturn 0;\n\n\tnode = of_graph_get_port_parent(ep);\n\n\t \n\targs.np = ep;\n\tdai = snd_soc_get_dai_via_args(&args);\n\tif (dai) {\n\t\tdlc->dai_name = snd_soc_dai_name_get(dai);\n\t\tdlc->dai_args = snd_soc_copy_dai_args(dev, &args);\n\t\tif (!dlc->dai_args)\n\t\t\treturn -ENOMEM;\n\n\t\tgoto parse_dai_end;\n\t}\n\n\t \n\targs.np\t\t= node;\n\targs.args[0]\t= graph_get_dai_id(ep);\n\targs.args_count\t= (of_graph_get_endpoint_count(node) > 1);\n\n\t \n\tret = snd_soc_get_dlc(&args, dlc);\n\tif (ret < 0) {\n\t\tof_node_put(node);\n\t\treturn ret;\n\t}\n\nparse_dai_end:\n\tif (is_single_link)\n\t\t*is_single_link = of_graph_get_endpoint_count(node) == 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(asoc_graph_parse_dai);\n\n \nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC Simple Card Utils\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}