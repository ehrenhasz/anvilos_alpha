{
  "module_name": "simple-card.c",
  "hash_id": "6706915e2a7a65fbdd7d397f5b5d2d8610c3d2b864d8f0d6730893a706773899",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/generic/simple-card.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <sound/simple_card.h>\n#include <sound/soc-dai.h>\n#include <sound/soc.h>\n\n#define DPCM_SELECTABLE 1\n\n#define DAI\t\"sound-dai\"\n#define CELL\t\"#sound-dai-cells\"\n#define PREFIX\t\"simple-audio-card,\"\n\nstatic const struct snd_soc_ops simple_ops = {\n\t.startup\t= asoc_simple_startup,\n\t.shutdown\t= asoc_simple_shutdown,\n\t.hw_params\t= asoc_simple_hw_params,\n};\n\nstatic int asoc_simple_parse_platform(struct device_node *node,\n\t\t\t\t      struct snd_soc_dai_link_component *dlc)\n{\n\tstruct of_phandle_args args;\n\tint ret;\n\n\tif (!node)\n\t\treturn 0;\n\n\t \n\tret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tdlc->of_node = args.np;\n\n\treturn 0;\n}\n\nstatic int asoc_simple_parse_dai(struct device *dev,\n\t\t\t\t struct device_node *node,\n\t\t\t\t struct snd_soc_dai_link_component *dlc,\n\t\t\t\t int *is_single_link)\n{\n\tstruct of_phandle_args args;\n\tstruct snd_soc_dai *dai;\n\tint ret;\n\n\tif (!node)\n\t\treturn 0;\n\n\t \n\tret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdai = snd_soc_get_dai_via_args(&args);\n\tif (dai) {\n\t\tdlc->dai_name = snd_soc_dai_name_get(dai);\n\t\tdlc->dai_args = snd_soc_copy_dai_args(dev, &args);\n\t\tif (!dlc->dai_args)\n\t\t\treturn -ENOMEM;\n\n\t\tgoto parse_dai_end;\n\t}\n\n\t \n\tret = snd_soc_get_dlc(&args, dlc);\n\tif (ret < 0)\n\t\treturn ret;\n\nparse_dai_end:\n\tif (is_single_link)\n\t\t*is_single_link = !args.args_count;\n\n\treturn 0;\n}\n\nstatic void simple_parse_convert(struct device *dev,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct asoc_simple_data *adata)\n{\n\tstruct device_node *top = dev->of_node;\n\tstruct device_node *node = of_get_parent(np);\n\n\tasoc_simple_parse_convert(top,  PREFIX, adata);\n\tasoc_simple_parse_convert(node, PREFIX, adata);\n\tasoc_simple_parse_convert(node, NULL,   adata);\n\tasoc_simple_parse_convert(np,   NULL,   adata);\n\n\tof_node_put(node);\n}\n\nstatic void simple_parse_mclk_fs(struct device_node *top,\n\t\t\t\t struct device_node *np,\n\t\t\t\t struct simple_dai_props *props,\n\t\t\t\t char *prefix)\n{\n\tstruct device_node *node = of_get_parent(np);\n\tchar prop[128];\n\n\tsnprintf(prop, sizeof(prop), \"%smclk-fs\", PREFIX);\n\tof_property_read_u32(top,\tprop, &props->mclk_fs);\n\n\tsnprintf(prop, sizeof(prop), \"%smclk-fs\", prefix);\n\tof_property_read_u32(node,\tprop, &props->mclk_fs);\n\tof_property_read_u32(np,\tprop, &props->mclk_fs);\n\n\tof_node_put(node);\n}\n\nstatic int simple_parse_node(struct asoc_simple_priv *priv,\n\t\t\t     struct device_node *np,\n\t\t\t     struct link_info *li,\n\t\t\t     char *prefix,\n\t\t\t     int *cpu)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *top = dev->of_node;\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tstruct snd_soc_dai_link_component *dlc;\n\tstruct asoc_simple_dai *dai;\n\tint ret;\n\n\tif (cpu) {\n\t\tdlc = asoc_link_to_cpu(dai_link, 0);\n\t\tdai = simple_props_to_dai_cpu(dai_props, 0);\n\t} else {\n\t\tdlc = asoc_link_to_codec(dai_link, 0);\n\t\tdai = simple_props_to_dai_codec(dai_props, 0);\n\t}\n\n\tsimple_parse_mclk_fs(top, np, dai_props, prefix);\n\n\tret = asoc_simple_parse_dai(dev, np, dlc, cpu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_clk(dev, np, dai, dlc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_tdm(np, dai);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int simple_link_init(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *node,\n\t\t\t    struct device_node *codec,\n\t\t\t    struct link_info *li,\n\t\t\t    char *prefix, char *name)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tint ret;\n\n\tret = asoc_simple_parse_daifmt(dev, node, codec,\n\t\t\t\t       prefix, &dai_link->dai_fmt);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tdai_link->init\t\t\t= asoc_simple_dai_init;\n\tdai_link->ops\t\t\t= &simple_ops;\n\n\treturn asoc_simple_set_dailink_name(dev, dai_link, name);\n}\n\nstatic int simple_dai_link_of_dpcm(struct asoc_simple_priv *priv,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   struct device_node *codec,\n\t\t\t\t   struct link_info *li,\n\t\t\t\t   bool is_top)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tstruct device_node *top = dev->of_node;\n\tstruct device_node *node = of_get_parent(np);\n\tchar *prefix = \"\";\n\tchar dai_name[64];\n\tint ret;\n\n\tdev_dbg(dev, \"link_of DPCM (%pOF)\\n\", np);\n\n\t \n\tif (is_top)\n\t\tprefix = PREFIX;\n\n\tif (li->cpu) {\n\t\tstruct snd_soc_dai_link_component *cpus = asoc_link_to_cpu(dai_link, 0);\n\t\tstruct snd_soc_dai_link_component *platforms = asoc_link_to_platform(dai_link, 0);\n\t\tint is_single_links = 0;\n\n\t\t \n\n\t\t \n\t\tdai_link->dynamic\t\t= 1;\n\t\tdai_link->dpcm_merged_format\t= 1;\n\n\t\tret = simple_parse_node(priv, np, li, prefix, &is_single_links);\n\t\tif (ret < 0)\n\t\t\tgoto out_put_node;\n\n\t\tsnprintf(dai_name, sizeof(dai_name), \"fe.%s\", cpus->dai_name);\n\n\t\tasoc_simple_canonicalize_cpu(cpus, is_single_links);\n\t\tasoc_simple_canonicalize_platform(platforms, cpus);\n\t} else {\n\t\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, 0);\n\t\tstruct snd_soc_codec_conf *cconf;\n\n\t\t \n\n\t\t \n\t\tdai_link->no_pcm\t\t= 1;\n\t\tdai_link->be_hw_params_fixup\t= asoc_simple_be_hw_params_fixup;\n\n\t\tcconf\t= simple_props_to_codec_conf(dai_props, 0);\n\n\t\tret = simple_parse_node(priv, np, li, prefix, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto out_put_node;\n\n\t\tsnprintf(dai_name, sizeof(dai_name), \"be.%s\", codecs->dai_name);\n\n\t\t \n\t\tsnd_soc_of_parse_node_prefix(top, cconf, codecs->of_node,\n\t\t\t\t\t      PREFIX \"prefix\");\n\t\tsnd_soc_of_parse_node_prefix(node, cconf, codecs->of_node,\n\t\t\t\t\t     \"prefix\");\n\t\tsnd_soc_of_parse_node_prefix(np, cconf, codecs->of_node,\n\t\t\t\t\t     \"prefix\");\n\t}\n\n\tsimple_parse_convert(dev, np, &dai_props->adata);\n\n\tsnd_soc_dai_link_set_capabilities(dai_link);\n\n\tret = simple_link_init(priv, node, codec, li, prefix, dai_name);\n\nout_put_node:\n\tli->link++;\n\n\tof_node_put(node);\n\treturn ret;\n}\n\nstatic int simple_dai_link_of(struct asoc_simple_priv *priv,\n\t\t\t      struct device_node *np,\n\t\t\t      struct device_node *codec,\n\t\t\t      struct link_info *li,\n\t\t\t      bool is_top)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct snd_soc_dai_link_component *cpus = asoc_link_to_cpu(dai_link, 0);\n\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, 0);\n\tstruct snd_soc_dai_link_component *platforms = asoc_link_to_platform(dai_link, 0);\n\tstruct device_node *cpu = NULL;\n\tstruct device_node *node = NULL;\n\tstruct device_node *plat = NULL;\n\tchar dai_name[64];\n\tchar prop[128];\n\tchar *prefix = \"\";\n\tint ret, single_cpu = 0;\n\n\tcpu  = np;\n\tnode = of_get_parent(np);\n\n\tdev_dbg(dev, \"link_of (%pOF)\\n\", node);\n\n\t \n\tif (is_top)\n\t\tprefix = PREFIX;\n\n\tsnprintf(prop, sizeof(prop), \"%splat\", prefix);\n\tplat = of_get_child_by_name(node, prop);\n\n\tret = simple_parse_node(priv, cpu, li, prefix, &single_cpu);\n\tif (ret < 0)\n\t\tgoto dai_link_of_err;\n\n\tret = simple_parse_node(priv, codec, li, prefix, NULL);\n\tif (ret < 0)\n\t\tgoto dai_link_of_err;\n\n\tret = asoc_simple_parse_platform(plat, platforms);\n\tif (ret < 0)\n\t\tgoto dai_link_of_err;\n\n\tsnprintf(dai_name, sizeof(dai_name),\n\t\t \"%s-%s\", cpus->dai_name, codecs->dai_name);\n\n\tasoc_simple_canonicalize_cpu(cpus, single_cpu);\n\tasoc_simple_canonicalize_platform(platforms, cpus);\n\n\tret = simple_link_init(priv, node, codec, li, prefix, dai_name);\n\ndai_link_of_err:\n\tof_node_put(plat);\n\tof_node_put(node);\n\n\tli->link++;\n\n\treturn ret;\n}\n\nstatic int __simple_for_each_link(struct asoc_simple_priv *priv,\n\t\t\tstruct link_info *li,\n\t\t\tint (*func_noml)(struct asoc_simple_priv *priv,\n\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t struct device_node *codec,\n\t\t\t\t\t struct link_info *li, bool is_top),\n\t\t\tint (*func_dpcm)(struct asoc_simple_priv *priv,\n\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t struct device_node *codec,\n\t\t\t\t\t struct link_info *li, bool is_top))\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *top = dev->of_node;\n\tstruct device_node *node;\n\tstruct device_node *add_devs;\n\tuintptr_t dpcm_selectable = (uintptr_t)of_device_get_match_data(dev);\n\tbool is_top = 0;\n\tint ret = 0;\n\n\t \n\tnode = of_get_child_by_name(top, PREFIX \"dai-link\");\n\tif (!node) {\n\t\tnode = of_node_get(top);\n\t\tis_top = 1;\n\t}\n\n\tadd_devs = of_get_child_by_name(top, PREFIX \"additional-devs\");\n\n\t \n\tdo {\n\t\tstruct asoc_simple_data adata;\n\t\tstruct device_node *codec;\n\t\tstruct device_node *plat;\n\t\tstruct device_node *np;\n\t\tint num = of_get_child_count(node);\n\n\t\t \n\t\tif (node == add_devs) {\n\t\t\tnode = of_get_next_child(top, node);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcodec = of_get_child_by_name(node, is_top ?\n\t\t\t\t\t     PREFIX \"codec\" : \"codec\");\n\t\tif (!codec) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tplat = of_get_child_by_name(node, is_top ?\n\t\t\t\t\t    PREFIX \"plat\" : \"plat\");\n\n\t\t \n\t\tmemset(&adata, 0, sizeof(adata));\n\t\tfor_each_child_of_node(node, np) {\n\t\t\tif (np == add_devs)\n\t\t\t\tcontinue;\n\t\t\tsimple_parse_convert(dev, np, &adata);\n\t\t}\n\n\t\t \n\t\tfor_each_child_of_node(node, np) {\n\t\t\tif (plat == np || add_devs == np)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (dpcm_selectable &&\n\t\t\t    (num > 2 || asoc_simple_is_convert_required(&adata))) {\n\t\t\t\t \n\t\t\t\tif (li->cpu != (np == codec))\n\t\t\t\t\tret = func_dpcm(priv, np, codec, li, is_top);\n\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (li->cpu && (np != codec))\n\t\t\t\t\tret = func_noml(priv, np, codec, li, is_top);\n\t\t\t}\n\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(codec);\n\t\t\t\tof_node_put(plat);\n\t\t\t\tof_node_put(np);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tof_node_put(codec);\n\t\tof_node_put(plat);\n\t\tnode = of_get_next_child(top, node);\n\t} while (!is_top && node);\n\n error:\n\tof_node_put(add_devs);\n\tof_node_put(node);\n\treturn ret;\n}\n\nstatic int simple_for_each_link(struct asoc_simple_priv *priv,\n\t\t\t\tstruct link_info *li,\n\t\t\t\tint (*func_noml)(struct asoc_simple_priv *priv,\n\t\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t\t struct device_node *codec,\n\t\t\t\t\t\t struct link_info *li, bool is_top),\n\t\t\t\tint (*func_dpcm)(struct asoc_simple_priv *priv,\n\t\t\t\t\t\t struct device_node *np,\n\t\t\t\t\t\t struct device_node *codec,\n\t\t\t\t\t\t struct link_info *li, bool is_top))\n{\n\tint ret;\n\t \n\tfor (li->cpu = 1; li->cpu >= 0; li->cpu--) {\n\t\tret = __simple_for_each_link(priv, li, func_noml, func_dpcm);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void simple_depopulate_aux(void *data)\n{\n\tstruct asoc_simple_priv *priv = data;\n\n\tof_platform_depopulate(simple_priv_to_dev(priv));\n}\n\nstatic int simple_populate_aux(struct asoc_simple_priv *priv)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *node;\n\tint ret;\n\n\tnode = of_get_child_by_name(dev->of_node, PREFIX \"additional-devs\");\n\tif (!node)\n\t\treturn 0;\n\n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tof_node_put(node);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dev, simple_depopulate_aux, priv);\n}\n\nstatic int simple_parse_of(struct asoc_simple_priv *priv, struct link_info *li)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tint ret;\n\n\tret = asoc_simple_parse_widgets(card, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_routing(card, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_pin_switches(card, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmemset(li, 0, sizeof(*li));\n\tret = simple_for_each_link(priv, li,\n\t\t\t\t   simple_dai_link_of,\n\t\t\t\t   simple_dai_link_of_dpcm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_card_name(card, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = simple_populate_aux(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_of_parse_aux_devs(card, PREFIX \"aux-devs\");\n\n\treturn ret;\n}\n\nstatic int simple_count_noml(struct asoc_simple_priv *priv,\n\t\t\t     struct device_node *np,\n\t\t\t     struct device_node *codec,\n\t\t\t     struct link_info *li, bool is_top)\n{\n\tif (li->link >= SNDRV_MAX_LINKS) {\n\t\tstruct device *dev = simple_priv_to_dev(priv);\n\n\t\tdev_err(dev, \"too many links\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tli->num[li->link].cpus\t\t= 1;\n\tli->num[li->link].platforms\t= 1;\n\n\tli->num[li->link].codecs\t= 1;\n\n\tli->link += 1;\n\n\treturn 0;\n}\n\nstatic int simple_count_dpcm(struct asoc_simple_priv *priv,\n\t\t\t     struct device_node *np,\n\t\t\t     struct device_node *codec,\n\t\t\t     struct link_info *li, bool is_top)\n{\n\tif (li->link >= SNDRV_MAX_LINKS) {\n\t\tstruct device *dev = simple_priv_to_dev(priv);\n\n\t\tdev_err(dev, \"too many links\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (li->cpu) {\n\t\t \n\t\tli->num[li->link].cpus\t\t= 1;\n\t\tli->num[li->link].platforms\t= 1;\n\n\t\tli->link++;  \n\t} else {\n\t\tli->num[li->link].codecs\t= 1;\n\n\t\tli->link++;  \n\t}\n\n\treturn 0;\n}\n\nstatic int simple_get_dais_count(struct asoc_simple_priv *priv,\n\t\t\t\t struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *top = dev->of_node;\n\n\t \n\tif (!top) {\n\t\tli->num[0].cpus\t\t= 1;\n\t\tli->num[0].codecs\t= 1;\n\t\tli->num[0].platforms\t= 1;\n\n\t\tli->link = 1;\n\t\treturn 0;\n\t}\n\n\treturn simple_for_each_link(priv, li,\n\t\t\t\t    simple_count_noml,\n\t\t\t\t    simple_count_dpcm);\n}\n\nstatic int simple_soc_probe(struct snd_soc_card *card)\n{\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card);\n\tint ret;\n\n\tret = asoc_simple_init_hp(card, &priv->hp_jack, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_init_mic(card, &priv->mic_jack, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_init_aux_jacks(priv, PREFIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int asoc_simple_probe(struct platform_device *pdev)\n{\n\tstruct asoc_simple_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct snd_soc_card *card;\n\tstruct link_info *li;\n\tint ret;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tcard = simple_priv_to_card(priv);\n\tcard->owner\t\t= THIS_MODULE;\n\tcard->dev\t\t= dev;\n\tcard->probe\t\t= simple_soc_probe;\n\tcard->driver_name       = \"simple-card\";\n\n\tli = devm_kzalloc(dev, sizeof(*li), GFP_KERNEL);\n\tif (!li)\n\t\treturn -ENOMEM;\n\n\tret = simple_get_dais_count(priv, li);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!li->link)\n\t\treturn -EINVAL;\n\n\tret = asoc_simple_init_priv(priv, li);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (np && of_device_is_available(np)) {\n\n\t\tret = simple_parse_of(priv, li);\n\t\tif (ret < 0) {\n\t\t\tdev_err_probe(dev, ret, \"parse error\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t} else {\n\t\tstruct asoc_simple_card_info *cinfo;\n\t\tstruct snd_soc_dai_link_component *cpus;\n\t\tstruct snd_soc_dai_link_component *codecs;\n\t\tstruct snd_soc_dai_link_component *platform;\n\t\tstruct snd_soc_dai_link *dai_link = priv->dai_link;\n\t\tstruct simple_dai_props *dai_props = priv->dai_props;\n\n\t\tret = -EINVAL;\n\n\t\tcinfo = dev->platform_data;\n\t\tif (!cinfo) {\n\t\t\tdev_err(dev, \"no info for asoc-simple-card\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!cinfo->name ||\n\t\t    !cinfo->codec_dai.name ||\n\t\t    !cinfo->codec ||\n\t\t    !cinfo->platform ||\n\t\t    !cinfo->cpu_dai.name) {\n\t\t\tdev_err(dev, \"insufficient asoc_simple_card_info settings\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tcpus\t\t\t= dai_link->cpus;\n\t\tcpus->dai_name\t\t= cinfo->cpu_dai.name;\n\n\t\tcodecs\t\t\t= dai_link->codecs;\n\t\tcodecs->name\t\t= cinfo->codec;\n\t\tcodecs->dai_name\t= cinfo->codec_dai.name;\n\n\t\tplatform\t\t= dai_link->platforms;\n\t\tplatform->name\t\t= cinfo->platform;\n\n\t\tcard->name\t\t= (cinfo->card) ? cinfo->card : cinfo->name;\n\t\tdai_link->name\t\t= cinfo->name;\n\t\tdai_link->stream_name\t= cinfo->name;\n\t\tdai_link->dai_fmt\t= cinfo->daifmt;\n\t\tdai_link->init\t\t= asoc_simple_dai_init;\n\t\tmemcpy(dai_props->cpu_dai, &cinfo->cpu_dai,\n\t\t\t\t\tsizeof(*dai_props->cpu_dai));\n\t\tmemcpy(dai_props->codec_dai, &cinfo->codec_dai,\n\t\t\t\t\tsizeof(*dai_props->codec_dai));\n\t}\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tasoc_simple_debug_info(priv);\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdevm_kfree(dev, li);\n\treturn 0;\nerr:\n\tasoc_simple_clean_reference(card);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id simple_of_match[] = {\n\t{ .compatible = \"simple-audio-card\", },\n\t{ .compatible = \"simple-scu-audio-card\",\n\t  .data = (void *)DPCM_SELECTABLE },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, simple_of_match);\n\nstatic struct platform_driver asoc_simple_card = {\n\t.driver = {\n\t\t.name = \"asoc-simple-card\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = simple_of_match,\n\t},\n\t.probe = asoc_simple_probe,\n\t.remove = asoc_simple_remove,\n};\n\nmodule_platform_driver(asoc_simple_card);\n\nMODULE_ALIAS(\"platform:asoc-simple-card\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ASoC Simple Sound Card\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}