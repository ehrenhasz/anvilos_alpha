{
  "module_name": "audio-graph-card.c",
  "hash_id": "24aeaf9bbdb36b720382375801ec9732fbb59c8452b527f2945ad95b2ee23fc1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/generic/audio-graph-card.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <sound/graph_card.h>\n\n#define DPCM_SELECTABLE 1\n\nstatic int graph_outdrv_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol,\n\t\t\t      int event)\n{\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct asoc_simple_priv *priv = snd_soc_card_get_drvdata(dapm->card);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tgpiod_set_value_cansleep(priv->pa_gpio, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tgpiod_set_value_cansleep(priv->pa_gpio, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget graph_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUT_DRV_E(\"Amplifier\", SND_SOC_NOPM,\n\t\t\t       0, 0, NULL, 0, graph_outdrv_event,\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n};\n\nstatic const struct snd_soc_ops graph_ops = {\n\t.startup\t= asoc_simple_startup,\n\t.shutdown\t= asoc_simple_shutdown,\n\t.hw_params\t= asoc_simple_hw_params,\n};\n\nstatic bool soc_component_is_pcm(struct snd_soc_dai_link_component *dlc)\n{\n\tstruct snd_soc_dai *dai = snd_soc_find_dai_with_mutex(dlc);\n\n\tif (dai && (dai->component->driver->pcm_construct ||\n\t\t    (dai->driver->ops && dai->driver->ops->pcm_new)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void graph_parse_convert(struct device *dev,\n\t\t\t\tstruct device_node *ep,\n\t\t\t\tstruct asoc_simple_data *adata)\n{\n\tstruct device_node *top = dev->of_node;\n\tstruct device_node *port = of_get_parent(ep);\n\tstruct device_node *ports = of_get_parent(port);\n\tstruct device_node *node = of_graph_get_port_parent(ep);\n\n\tasoc_simple_parse_convert(top,   NULL,   adata);\n\tif (of_node_name_eq(ports, \"ports\"))\n\t\tasoc_simple_parse_convert(ports, NULL, adata);\n\tasoc_simple_parse_convert(port,  NULL,   adata);\n\tasoc_simple_parse_convert(ep,    NULL,   adata);\n\n\tof_node_put(port);\n\tof_node_put(ports);\n\tof_node_put(node);\n}\n\nstatic void graph_parse_mclk_fs(struct device_node *top,\n\t\t\t\tstruct device_node *ep,\n\t\t\t\tstruct simple_dai_props *props)\n{\n\tstruct device_node *port\t= of_get_parent(ep);\n\tstruct device_node *ports\t= of_get_parent(port);\n\n\tof_property_read_u32(top,\t\"mclk-fs\", &props->mclk_fs);\n\tif (of_node_name_eq(ports, \"ports\"))\n\t\tof_property_read_u32(ports, \"mclk-fs\", &props->mclk_fs);\n\tof_property_read_u32(port,\t\"mclk-fs\", &props->mclk_fs);\n\tof_property_read_u32(ep,\t\"mclk-fs\", &props->mclk_fs);\n\n\tof_node_put(port);\n\tof_node_put(ports);\n}\n\nstatic int graph_parse_node(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *ep,\n\t\t\t    struct link_info *li,\n\t\t\t    int *cpu)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *top = dev->of_node;\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tstruct snd_soc_dai_link_component *dlc;\n\tstruct asoc_simple_dai *dai;\n\tint ret;\n\n\tif (cpu) {\n\t\tdlc = asoc_link_to_cpu(dai_link, 0);\n\t\tdai = simple_props_to_dai_cpu(dai_props, 0);\n\t} else {\n\t\tdlc = asoc_link_to_codec(dai_link, 0);\n\t\tdai = simple_props_to_dai_codec(dai_props, 0);\n\t}\n\n\tgraph_parse_mclk_fs(top, ep, dai_props);\n\n\tret = asoc_graph_parse_dai(dev, ep, dlc, cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_tdm(ep, dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_clk(dev, ep, dai, dlc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int graph_link_init(struct asoc_simple_priv *priv,\n\t\t\t   struct device_node *cpu_ep,\n\t\t\t   struct device_node *codec_ep,\n\t\t\t   struct link_info *li,\n\t\t\t   char *name)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tint ret;\n\n\tret = asoc_simple_parse_daifmt(dev, cpu_ep, codec_ep,\n\t\t\t\t       NULL, &dai_link->dai_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdai_link->init\t\t= asoc_simple_dai_init;\n\tdai_link->ops\t\t= &graph_ops;\n\tif (priv->ops)\n\t\tdai_link->ops\t= priv->ops;\n\n\treturn asoc_simple_set_dailink_name(dev, dai_link, name);\n}\n\nstatic int graph_dai_link_of_dpcm(struct asoc_simple_priv *priv,\n\t\t\t\t  struct device_node *cpu_ep,\n\t\t\t\t  struct device_node *codec_ep,\n\t\t\t\t  struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tstruct device_node *top = dev->of_node;\n\tstruct device_node *ep = li->cpu ? cpu_ep : codec_ep;\n\tchar dai_name[64];\n\tint ret;\n\n\tdev_dbg(dev, \"link_of DPCM (%pOF)\\n\", ep);\n\n\tif (li->cpu) {\n\t\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\t\tstruct snd_soc_dai_link_component *cpus = asoc_link_to_cpu(dai_link, 0);\n\t\tstruct snd_soc_dai_link_component *platforms = asoc_link_to_platform(dai_link, 0);\n\t\tint is_single_links = 0;\n\n\t\t \n\n\t\t \n\t\tdai_link->dynamic\t\t= 1;\n\t\tdai_link->dpcm_merged_format\t= 1;\n\n\t\tret = graph_parse_node(priv, cpu_ep, li, &is_single_links);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsnprintf(dai_name, sizeof(dai_name),\n\t\t\t \"fe.%pOFP.%s\", cpus->of_node, cpus->dai_name);\n\t\t \n\t\tif (card->component_chaining && !soc_component_is_pcm(cpus)) {\n\t\t\tdai_link->no_pcm = 1;\n\t\t\tdai_link->be_hw_params_fixup = asoc_simple_be_hw_params_fixup;\n\t\t}\n\n\t\tasoc_simple_canonicalize_cpu(cpus, is_single_links);\n\t\tasoc_simple_canonicalize_platform(platforms, cpus);\n\t} else {\n\t\tstruct snd_soc_codec_conf *cconf = simple_props_to_codec_conf(dai_props, 0);\n\t\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, 0);\n\t\tstruct device_node *port;\n\t\tstruct device_node *ports;\n\n\t\t \n\n\t\t \n\t\tdai_link->no_pcm\t\t= 1;\n\t\tdai_link->be_hw_params_fixup\t= asoc_simple_be_hw_params_fixup;\n\n\t\tret = graph_parse_node(priv, codec_ep, li, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tsnprintf(dai_name, sizeof(dai_name),\n\t\t\t \"be.%pOFP.%s\", codecs->of_node, codecs->dai_name);\n\n\t\t \n\t\tport = of_get_parent(ep);\n\t\tports = of_get_parent(port);\n\t\tsnd_soc_of_parse_node_prefix(top, cconf, codecs->of_node,\n\t\t\t\t\t      \"prefix\");\n\t\tif (of_node_name_eq(ports, \"ports\"))\n\t\t\tsnd_soc_of_parse_node_prefix(ports, cconf, codecs->of_node, \"prefix\");\n\t\tsnd_soc_of_parse_node_prefix(port, cconf, codecs->of_node,\n\t\t\t\t\t     \"prefix\");\n\n\t\tof_node_put(ports);\n\t\tof_node_put(port);\n\t}\n\n\tgraph_parse_convert(dev, ep, &dai_props->adata);\n\n\tsnd_soc_dai_link_set_capabilities(dai_link);\n\n\tret = graph_link_init(priv, cpu_ep, codec_ep, li, dai_name);\n\n\tli->link++;\n\n\treturn ret;\n}\n\nstatic int graph_dai_link_of(struct asoc_simple_priv *priv,\n\t\t\t     struct device_node *cpu_ep,\n\t\t\t     struct device_node *codec_ep,\n\t\t\t     struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct snd_soc_dai_link_component *cpus = asoc_link_to_cpu(dai_link, 0);\n\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, 0);\n\tstruct snd_soc_dai_link_component *platforms = asoc_link_to_platform(dai_link, 0);\n\tchar dai_name[64];\n\tint ret, is_single_links = 0;\n\n\tdev_dbg(dev, \"link_of (%pOF)\\n\", cpu_ep);\n\n\tret = graph_parse_node(priv, cpu_ep, li, &is_single_links);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = graph_parse_node(priv, codec_ep, li, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnprintf(dai_name, sizeof(dai_name),\n\t\t \"%s-%s\", cpus->dai_name, codecs->dai_name);\n\n\tasoc_simple_canonicalize_cpu(cpus, is_single_links);\n\tasoc_simple_canonicalize_platform(platforms, cpus);\n\n\tret = graph_link_init(priv, cpu_ep, codec_ep, li, dai_name);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tli->link++;\n\n\treturn 0;\n}\n\nstatic inline bool parse_as_dpcm_link(struct asoc_simple_priv *priv,\n\t\t\t\t      struct device_node *codec_port,\n\t\t\t\t      struct asoc_simple_data *adata)\n{\n\tif (priv->force_dpcm)\n\t\treturn true;\n\n\tif (!priv->dpcm_selectable)\n\t\treturn false;\n\n\t \n\tif ((of_get_child_count(codec_port) > 1) ||\n\t    asoc_simple_is_convert_required(adata))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int __graph_for_each_link(struct asoc_simple_priv *priv,\n\t\t\tstruct link_info *li,\n\t\t\tint (*func_noml)(struct asoc_simple_priv *priv,\n\t\t\t\t\t struct device_node *cpu_ep,\n\t\t\t\t\t struct device_node *codec_ep,\n\t\t\t\t\t struct link_info *li),\n\t\t\tint (*func_dpcm)(struct asoc_simple_priv *priv,\n\t\t\t\t\t struct device_node *cpu_ep,\n\t\t\t\t\t struct device_node *codec_ep,\n\t\t\t\t\t struct link_info *li))\n{\n\tstruct of_phandle_iterator it;\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *cpu_port;\n\tstruct device_node *cpu_ep;\n\tstruct device_node *codec_ep;\n\tstruct device_node *codec_port;\n\tstruct device_node *codec_port_old = NULL;\n\tstruct asoc_simple_data adata;\n\tint rc, ret = 0;\n\n\t \n\tof_for_each_phandle(&it, rc, node, \"dais\", NULL, 0) {\n\t\tcpu_port = it.node;\n\t\tcpu_ep\t = NULL;\n\n\t\t \n\t\twhile (1) {\n\t\t\tcpu_ep = of_get_next_child(cpu_port, cpu_ep);\n\t\t\tif (!cpu_ep)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcodec_ep = of_graph_get_remote_endpoint(cpu_ep);\n\t\t\tcodec_port = of_get_parent(codec_ep);\n\n\t\t\t \n\t\t\tmemset(&adata, 0, sizeof(adata));\n\t\t\tgraph_parse_convert(dev, codec_ep, &adata);\n\t\t\tgraph_parse_convert(dev, cpu_ep,   &adata);\n\n\t\t\t \n\t\t\tif (parse_as_dpcm_link(priv, codec_port, &adata)) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tif (li->cpu ||\n\t\t\t\t    ((codec_port_old != codec_port) && codec_ep))\n\t\t\t\t\tret = func_dpcm(priv, cpu_ep, codec_ep, li);\n\t\t\t \n\t\t\t} else {\n\t\t\t\tif (li->cpu)\n\t\t\t\t\tret = func_noml(priv, cpu_ep, codec_ep, li);\n\t\t\t}\n\n\t\t\tof_node_put(codec_ep);\n\t\t\tof_node_put(codec_port);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tof_node_put(cpu_ep);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tcodec_port_old = codec_port;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int graph_for_each_link(struct asoc_simple_priv *priv,\n\t\t\t       struct link_info *li,\n\t\t\t       int (*func_noml)(struct asoc_simple_priv *priv,\n\t\t\t\t\t\tstruct device_node *cpu_ep,\n\t\t\t\t\t\tstruct device_node *codec_ep,\n\t\t\t\t\t\tstruct link_info *li),\n\t\t\t       int (*func_dpcm)(struct asoc_simple_priv *priv,\n\t\t\t\t\t\tstruct device_node *cpu_ep,\n\t\t\t\t\t\tstruct device_node *codec_ep,\n\t\t\t\t\t\tstruct link_info *li))\n{\n\tint ret;\n\t \n\tfor (li->cpu = 1; li->cpu >= 0; li->cpu--) {\n\t\tret = __graph_for_each_link(priv, li, func_noml, func_dpcm);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int graph_count_noml(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *cpu_ep,\n\t\t\t    struct device_node *codec_ep,\n\t\t\t    struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\n\tif (li->link >= SNDRV_MAX_LINKS) {\n\t\tdev_err(dev, \"too many links\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tli->num[li->link].cpus\t\t= 1;\n\tli->num[li->link].platforms     = 1;\n\n\tli->num[li->link].codecs\t= 1;\n\n\tli->link += 1;  \n\n\tdev_dbg(dev, \"Count As Normal\\n\");\n\n\treturn 0;\n}\n\nstatic int graph_count_dpcm(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *cpu_ep,\n\t\t\t    struct device_node *codec_ep,\n\t\t\t    struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\n\tif (li->link >= SNDRV_MAX_LINKS) {\n\t\tdev_err(dev, \"too many links\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (li->cpu) {\n\t\t \n\t\tli->num[li->link].cpus\t\t= 1;\n\t\tli->num[li->link].platforms     = 1;\n\n\t\tli->link++;  \n\t} else {\n\t\tli->num[li->link].codecs\t= 1;\n\n\t\tli->link++;  \n\t}\n\n\tdev_dbg(dev, \"Count As DPCM\\n\");\n\n\treturn 0;\n}\n\nstatic int graph_get_dais_count(struct asoc_simple_priv *priv,\n\t\t\t\tstruct link_info *li)\n{\n\t \n\treturn graph_for_each_link(priv, li,\n\t\t\t\t   graph_count_noml,\n\t\t\t\t   graph_count_dpcm);\n}\n\nint audio_graph_parse_of(struct asoc_simple_priv *priv, struct device *dev)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tstruct link_info *li;\n\tint ret;\n\n\tli = devm_kzalloc(dev, sizeof(*li), GFP_KERNEL);\n\tif (!li)\n\t\treturn -ENOMEM;\n\n\tcard->owner = THIS_MODULE;\n\tcard->dev = dev;\n\n\tret = graph_get_dais_count(priv, li);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!li->link)\n\t\treturn -EINVAL;\n\n\tret = asoc_simple_init_priv(priv, li);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->pa_gpio = devm_gpiod_get_optional(dev, \"pa\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->pa_gpio)) {\n\t\tret = PTR_ERR(priv->pa_gpio);\n\t\tdev_err(dev, \"failed to get amplifier gpio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = asoc_simple_parse_widgets(card, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_routing(card, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(li, 0, sizeof(*li));\n\tret = graph_for_each_link(priv, li,\n\t\t\t\t  graph_dai_link_of,\n\t\t\t\t  graph_dai_link_of_dpcm);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = asoc_simple_parse_card_name(card, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tasoc_simple_debug_info(priv);\n\n\tret = devm_snd_soc_register_card(dev, card);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdevm_kfree(dev, li);\n\treturn 0;\n\nerr:\n\tasoc_simple_clean_reference(card);\n\n\treturn dev_err_probe(dev, ret, \"parse error\\n\");\n}\nEXPORT_SYMBOL_GPL(audio_graph_parse_of);\n\nstatic int graph_probe(struct platform_device *pdev)\n{\n\tstruct asoc_simple_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_card *card;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tcard = simple_priv_to_card(priv);\n\tcard->dapm_widgets\t= graph_dapm_widgets;\n\tcard->num_dapm_widgets\t= ARRAY_SIZE(graph_dapm_widgets);\n\tcard->probe\t\t= asoc_graph_card_probe;\n\n\tif (of_device_get_match_data(dev))\n\t\tpriv->dpcm_selectable = 1;\n\n\treturn audio_graph_parse_of(priv, dev);\n}\n\nstatic const struct of_device_id graph_of_match[] = {\n\t{ .compatible = \"audio-graph-card\", },\n\t{ .compatible = \"audio-graph-scu-card\",\n\t  .data = (void *)DPCM_SELECTABLE },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, graph_of_match);\n\nstatic struct platform_driver graph_card = {\n\t.driver = {\n\t\t.name = \"asoc-audio-graph-card\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = graph_of_match,\n\t},\n\t.probe = graph_probe,\n\t.remove = asoc_simple_remove,\n};\nmodule_platform_driver(graph_card);\n\nMODULE_ALIAS(\"platform:asoc-audio-graph-card\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ASoC Audio Graph Sound Card\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}