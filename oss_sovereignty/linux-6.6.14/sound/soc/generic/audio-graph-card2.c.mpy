{
  "module_name": "audio-graph-card2.c",
  "hash_id": "1e9db8486336b0934d5847f915fd350cbf621f60d67f28b4522f581b5411199d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/generic/audio-graph-card2.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/string.h>\n#include <sound/graph_card.h>\n\n \n\nenum graph_type {\n\tGRAPH_NORMAL,\n\tGRAPH_DPCM,\n\tGRAPH_C2C,\n\n\tGRAPH_MULTI,\t \n};\n\n#define GRAPH_NODENAME_MULTI\t\"multi\"\n#define GRAPH_NODENAME_DPCM\t\"dpcm\"\n#define GRAPH_NODENAME_C2C\t\"codec2codec\"\n\n#define port_to_endpoint(port) of_get_child_by_name(port, \"endpoint\")\n\nstatic enum graph_type __graph_get_type(struct device_node *lnk)\n{\n\tstruct device_node *np, *parent_np;\n\tenum graph_type ret;\n\n\t \n\tnp = of_get_parent(lnk);\n\tif (of_node_name_eq(np, \"ports\")) {\n\t\tparent_np = of_get_parent(np);\n\t\tof_node_put(np);\n\t\tnp = parent_np;\n\t}\n\n\tif (of_node_name_eq(np, GRAPH_NODENAME_MULTI)) {\n\t\tret = GRAPH_MULTI;\n\t\tgoto out_put;\n\t}\n\n\tif (of_node_name_eq(np, GRAPH_NODENAME_DPCM)) {\n\t\tret = GRAPH_DPCM;\n\t\tgoto out_put;\n\t}\n\n\tif (of_node_name_eq(np, GRAPH_NODENAME_C2C)) {\n\t\tret = GRAPH_C2C;\n\t\tgoto out_put;\n\t}\n\n\tret = GRAPH_NORMAL;\n\nout_put:\n\tof_node_put(np);\n\treturn ret;\n\n}\n\nstatic enum graph_type graph_get_type(struct asoc_simple_priv *priv,\n\t\t\t\t      struct device_node *lnk)\n{\n\tenum graph_type type = __graph_get_type(lnk);\n\n\t \n\tif (type == GRAPH_MULTI)\n\t\ttype = GRAPH_NORMAL;\n\n#ifdef DEBUG\n\t{\n\t\tstruct device *dev = simple_priv_to_dev(priv);\n\t\tconst char *str = \"Normal\";\n\n\t\tswitch (type) {\n\t\tcase GRAPH_DPCM:\n\t\t\tif (asoc_graph_is_ports0(lnk))\n\t\t\t\tstr = \"DPCM Front-End\";\n\t\t\telse\n\t\t\t\tstr = \"DPCM Back-End\";\n\t\t\tbreak;\n\t\tcase GRAPH_C2C:\n\t\t\tstr = \"Codec2Codec\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(dev, \"%pOF (%s)\", lnk, str);\n\t}\n#endif\n\treturn type;\n}\n\nstatic int graph_lnk_is_multi(struct device_node *lnk)\n{\n\treturn __graph_get_type(lnk) == GRAPH_MULTI;\n}\n\nstatic struct device_node *graph_get_next_multi_ep(struct device_node **port)\n{\n\tstruct device_node *ports = of_get_parent(*port);\n\tstruct device_node *ep = NULL;\n\tstruct device_node *rep = NULL;\n\n\t \n\tdo {\n\t\t*port = of_get_next_child(ports, *port);\n\t\tif (!*port)\n\t\t\tbreak;\n\t} while (!of_node_name_eq(*port, \"port\"));\n\n\tif (*port) {\n\t\tep  = port_to_endpoint(*port);\n\t\trep = of_graph_get_remote_endpoint(ep);\n\t}\n\n\tof_node_put(ep);\n\tof_node_put(ports);\n\n\treturn rep;\n}\n\nstatic const struct snd_soc_ops graph_ops = {\n\t.startup\t= asoc_simple_startup,\n\t.shutdown\t= asoc_simple_shutdown,\n\t.hw_params\t= asoc_simple_hw_params,\n};\n\nstatic void graph_parse_convert(struct device_node *ep,\n\t\t\t\tstruct simple_dai_props *props)\n{\n\tstruct device_node *port = of_get_parent(ep);\n\tstruct device_node *ports = of_get_parent(port);\n\tstruct asoc_simple_data *adata = &props->adata;\n\n\tif (of_node_name_eq(ports, \"ports\"))\n\t\tasoc_simple_parse_convert(ports, NULL, adata);\n\tasoc_simple_parse_convert(port, NULL, adata);\n\tasoc_simple_parse_convert(ep,   NULL, adata);\n\n\tof_node_put(port);\n\tof_node_put(ports);\n}\n\nstatic void graph_parse_mclk_fs(struct device_node *ep,\n\t\t\t\tstruct simple_dai_props *props)\n{\n\tstruct device_node *port\t= of_get_parent(ep);\n\tstruct device_node *ports\t= of_get_parent(port);\n\n\tif (of_node_name_eq(ports, \"ports\"))\n\t\tof_property_read_u32(ports, \"mclk-fs\", &props->mclk_fs);\n\tof_property_read_u32(port,\t\"mclk-fs\", &props->mclk_fs);\n\tof_property_read_u32(ep,\t\"mclk-fs\", &props->mclk_fs);\n\n\tof_node_put(port);\n\tof_node_put(ports);\n}\n\nstatic int __graph_parse_node(struct asoc_simple_priv *priv,\n\t\t\t      enum graph_type gtype,\n\t\t\t      struct device_node *ep,\n\t\t\t      struct link_info *li,\n\t\t\t      int is_cpu, int idx)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tstruct snd_soc_dai_link_component *dlc;\n\tstruct asoc_simple_dai *dai;\n\tint ret, is_single_links = 0;\n\n\tif (is_cpu) {\n\t\tdlc = asoc_link_to_cpu(dai_link, idx);\n\t\tdai = simple_props_to_dai_cpu(dai_props, idx);\n\t} else {\n\t\tdlc = asoc_link_to_codec(dai_link, idx);\n\t\tdai = simple_props_to_dai_codec(dai_props, idx);\n\t}\n\n\tgraph_parse_mclk_fs(ep, dai_props);\n\n\tret = asoc_graph_parse_dai(dev, ep, dlc, &is_single_links);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_tdm(ep, dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_tdm_width_map(dev, ep, dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = asoc_simple_parse_clk(dev, ep, dai, dlc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!dai_link->name) {\n\t\tstruct snd_soc_dai_link_component *cpus = dlc;\n\t\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, idx);\n\t\tchar *cpu_multi   = \"\";\n\t\tchar *codec_multi = \"\";\n\n\t\tif (dai_link->num_cpus > 1)\n\t\t\tcpu_multi = \"_multi\";\n\t\tif (dai_link->num_codecs > 1)\n\t\t\tcodec_multi = \"_multi\";\n\n\t\tswitch (gtype) {\n\t\tcase GRAPH_NORMAL:\n\t\t\t \n\t\t\tif (is_cpu)\n\t\t\t\tasoc_simple_set_dailink_name(dev, dai_link, \"%s%s-%s%s\",\n\t\t\t\t\t\t\t       cpus->dai_name,   cpu_multi,\n\t\t\t\t\t\t\t     codecs->dai_name, codec_multi);\n\t\t\tbreak;\n\t\tcase GRAPH_DPCM:\n\t\t\tif (is_cpu)\n\t\t\t\tasoc_simple_set_dailink_name(dev, dai_link, \"fe.%pOFP.%s%s\",\n\t\t\t\t\t\tcpus->of_node, cpus->dai_name, cpu_multi);\n\t\t\telse\n\t\t\t\tasoc_simple_set_dailink_name(dev, dai_link, \"be.%pOFP.%s%s\",\n\t\t\t\t\t\tcodecs->of_node, codecs->dai_name, codec_multi);\n\t\t\tbreak;\n\t\tcase GRAPH_C2C:\n\t\t\t \n\t\t\tif (is_cpu)\n\t\t\t\tasoc_simple_set_dailink_name(dev, dai_link, \"c2c.%s%s-%s%s\",\n\t\t\t\t\t\t\t     cpus->dai_name,   cpu_multi,\n\t\t\t\t\t\t\t     codecs->dai_name, codec_multi);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!is_cpu && gtype == GRAPH_DPCM) {\n\t\tstruct snd_soc_dai_link_component *codecs = asoc_link_to_codec(dai_link, idx);\n\t\tstruct snd_soc_codec_conf *cconf = simple_props_to_codec_conf(dai_props, idx);\n\t\tstruct device_node *rport  = of_get_parent(ep);\n\t\tstruct device_node *rports = of_get_parent(rport);\n\n\t\tif (of_node_name_eq(rports, \"ports\"))\n\t\t\tsnd_soc_of_parse_node_prefix(rports, cconf, codecs->of_node, \"prefix\");\n\t\tsnd_soc_of_parse_node_prefix(rport,  cconf, codecs->of_node, \"prefix\");\n\n\t\tof_node_put(rport);\n\t\tof_node_put(rports);\n\t}\n\n\tif (is_cpu) {\n\t\tstruct snd_soc_dai_link_component *cpus = dlc;\n\t\tstruct snd_soc_dai_link_component *platforms = asoc_link_to_platform(dai_link, idx);\n\n\t\tasoc_simple_canonicalize_cpu(cpus, is_single_links);\n\t\tasoc_simple_canonicalize_platform(platforms, cpus);\n\t}\n\n\treturn 0;\n}\n\nstatic int graph_parse_node(struct asoc_simple_priv *priv,\n\t\t\t    enum graph_type gtype,\n\t\t\t    struct device_node *port,\n\t\t\t    struct link_info *li, int is_cpu)\n{\n\tstruct device_node *ep;\n\tint ret = 0;\n\n\tif (graph_lnk_is_multi(port)) {\n\t\tint idx;\n\n\t\tof_node_get(port);\n\n\t\tfor (idx = 0;; idx++) {\n\t\t\tep = graph_get_next_multi_ep(&port);\n\t\t\tif (!ep)\n\t\t\t\tbreak;\n\n\t\t\tret = __graph_parse_node(priv, gtype, ep,\n\t\t\t\t\t\t li, is_cpu, idx);\n\t\t\tof_node_put(ep);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tep = port_to_endpoint(port);\n\t\tret = __graph_parse_node(priv, gtype, ep, li, is_cpu, 0);\n\t\tof_node_put(ep);\n\t}\n\n\treturn ret;\n}\n\nstatic void graph_parse_daifmt(struct device_node *node,\n\t\t\t       unsigned int *daifmt, unsigned int *bit_frame)\n{\n\tunsigned int fmt;\n\n\t \n\n\t \n\n\t \n\t*bit_frame |= snd_soc_daifmt_parse_clock_provider_as_bitmap(node, NULL);\n\n#define update_daifmt(name)\t\t\t\t\t\\\n\tif (!(*daifmt & SND_SOC_DAIFMT_##name##_MASK) &&\t\\\n\t\t (fmt & SND_SOC_DAIFMT_##name##_MASK))\t\t\\\n\t\t*daifmt |= fmt & SND_SOC_DAIFMT_##name##_MASK\n\n\t \n\tfmt = snd_soc_daifmt_parse_format(node, NULL);\n\tupdate_daifmt(FORMAT);\n\tupdate_daifmt(CLOCK);\n\tupdate_daifmt(INV);\n}\n\nstatic void graph_link_init(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *port,\n\t\t\t    struct link_info *li,\n\t\t\t    int is_cpu_node)\n{\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct device_node *ep;\n\tstruct device_node *ports;\n\tunsigned int daifmt = 0, daiclk = 0;\n\tunsigned int bit_frame = 0;\n\n\tif (graph_lnk_is_multi(port)) {\n\t\tof_node_get(port);\n\t\tep = graph_get_next_multi_ep(&port);\n\t\tport = of_get_parent(ep);\n\t} else {\n\t\tep = port_to_endpoint(port);\n\t}\n\n\tports = of_get_parent(port);\n\n\t \n\tgraph_parse_daifmt(ep,    &daifmt, &bit_frame);\t\t \n\tgraph_parse_daifmt(port,  &daifmt, &bit_frame);\t\t \n\tif (of_node_name_eq(ports, \"ports\"))\n\t\tgraph_parse_daifmt(ports, &daifmt, &bit_frame);\t \n\n\t \n\tdaiclk = snd_soc_daifmt_clock_provider_from_bitmap(bit_frame);\n\tif (is_cpu_node)\n\t\tdaiclk = snd_soc_daifmt_clock_provider_flipped(daiclk);\n\n\tdai_link->dai_fmt\t= daifmt | daiclk;\n\tdai_link->init\t\t= asoc_simple_dai_init;\n\tdai_link->ops\t\t= &graph_ops;\n\tif (priv->ops)\n\t\tdai_link->ops\t= priv->ops;\n}\n\nint audio_graph2_link_normal(struct asoc_simple_priv *priv,\n\t\t\t     struct device_node *lnk,\n\t\t\t     struct link_info *li)\n{\n\tstruct device_node *cpu_port = lnk;\n\tstruct device_node *cpu_ep = port_to_endpoint(cpu_port);\n\tstruct device_node *codec_port = of_graph_get_remote_port(cpu_ep);\n\tint ret;\n\n\t \n\tret = graph_parse_node(priv, GRAPH_NORMAL, codec_port, li, 0);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = graph_parse_node(priv, GRAPH_NORMAL, cpu_port, li, 1);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tgraph_link_init(priv, cpu_port, li, 1);\nerr:\n\tof_node_put(codec_port);\n\tof_node_put(cpu_ep);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(audio_graph2_link_normal);\n\nint audio_graph2_link_dpcm(struct asoc_simple_priv *priv,\n\t\t\t   struct device_node *lnk,\n\t\t\t   struct link_info *li)\n{\n\tstruct device_node *ep = port_to_endpoint(lnk);\n\tstruct device_node *rep = of_graph_get_remote_endpoint(ep);\n\tstruct device_node *rport = of_graph_get_remote_port(ep);\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct simple_dai_props *dai_props = simple_priv_to_props(priv, li->link);\n\tint is_cpu = asoc_graph_is_ports0(lnk);\n\tint ret;\n\n\tif (is_cpu) {\n\t\t \n\t\t \n\t\tdai_link->dynamic\t\t= 1;\n\t\tdai_link->dpcm_merged_format\t= 1;\n\n\t\tret = graph_parse_node(priv, GRAPH_DPCM, rport, li, 1);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\t \n\t\t \n\n\t\t \n\t\tdai_link->no_pcm\t\t= 1;\n\t\tdai_link->be_hw_params_fixup\t= asoc_simple_be_hw_params_fixup;\n\n\t\tret = graph_parse_node(priv, GRAPH_DPCM, rport, li, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tgraph_parse_convert(ep,  dai_props);  \n\tgraph_parse_convert(rep, dai_props);  \n\n\tsnd_soc_dai_link_set_capabilities(dai_link);\n\n\tgraph_link_init(priv, rport, li, is_cpu);\nerr:\n\tof_node_put(ep);\n\tof_node_put(rep);\n\tof_node_put(rport);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(audio_graph2_link_dpcm);\n\nint audio_graph2_link_c2c(struct asoc_simple_priv *priv,\n\t\t\t  struct device_node *lnk,\n\t\t\t  struct link_info *li)\n{\n\tstruct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);\n\tstruct device_node *port0, *port1, *ports;\n\tstruct device_node *codec0_port, *codec1_port;\n\tstruct device_node *ep0, *ep1;\n\tu32 val = 0;\n\tint ret = -EINVAL;\n\n\t \n\tof_node_get(lnk);\n\tport0 = lnk;\n\tports = of_get_parent(port0);\n\tport1 = of_get_next_child(ports, lnk);\n\n\t \n\tof_property_read_u32(ports, \"rate\", &val);\n\tif (val) {\n\t\tstruct device *dev = simple_priv_to_dev(priv);\n\t\tstruct snd_soc_pcm_stream *c2c_conf;\n\n\t\tc2c_conf = devm_kzalloc(dev, sizeof(*c2c_conf), GFP_KERNEL);\n\t\tif (!c2c_conf)\n\t\t\tgoto err1;\n\n\t\tc2c_conf->formats\t= SNDRV_PCM_FMTBIT_S32_LE;  \n\t\tc2c_conf->rates\t\t= SNDRV_PCM_RATE_8000_384000;\n\t\tc2c_conf->rate_min\t=\n\t\tc2c_conf->rate_max\t= val;\n\t\tc2c_conf->channels_min\t=\n\t\tc2c_conf->channels_max\t= 2;  \n\n\t\tdai_link->c2c_params\t\t= c2c_conf;\n\t\tdai_link->num_c2c_params\t= 1;\n\t}\n\n\tep0 = port_to_endpoint(port0);\n\tep1 = port_to_endpoint(port1);\n\n\tcodec0_port = of_graph_get_remote_port(ep0);\n\tcodec1_port = of_graph_get_remote_port(ep1);\n\n\t \n\tret = graph_parse_node(priv, GRAPH_C2C, codec1_port, li, 0);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\t \n\tret = graph_parse_node(priv, GRAPH_C2C, codec0_port, li, 1);\n\tif (ret < 0)\n\t\tgoto err2;\n\n\tgraph_link_init(priv, codec0_port, li, 1);\nerr2:\n\tof_node_put(ep0);\n\tof_node_put(ep1);\n\tof_node_put(codec0_port);\n\tof_node_put(codec1_port);\nerr1:\n\tof_node_put(ports);\n\tof_node_put(port0);\n\tof_node_put(port1);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(audio_graph2_link_c2c);\n\nstatic int graph_link(struct asoc_simple_priv *priv,\n\t\t      struct graph2_custom_hooks *hooks,\n\t\t      enum graph_type gtype,\n\t\t      struct device_node *lnk,\n\t\t      struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tGRAPH2_CUSTOM func = NULL;\n\tint ret = -EINVAL;\n\n\tswitch (gtype) {\n\tcase GRAPH_NORMAL:\n\t\tif (hooks && hooks->custom_normal)\n\t\t\tfunc = hooks->custom_normal;\n\t\telse\n\t\t\tfunc = audio_graph2_link_normal;\n\t\tbreak;\n\tcase GRAPH_DPCM:\n\t\tif (hooks && hooks->custom_dpcm)\n\t\t\tfunc = hooks->custom_dpcm;\n\t\telse\n\t\t\tfunc = audio_graph2_link_dpcm;\n\t\tbreak;\n\tcase GRAPH_C2C:\n\t\tif (hooks && hooks->custom_c2c)\n\t\t\tfunc = hooks->custom_c2c;\n\t\telse\n\t\t\tfunc = audio_graph2_link_c2c;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!func) {\n\t\tdev_err(dev, \"non supported gtype (%d)\\n\", gtype);\n\t\tgoto err;\n\t}\n\n\tret = func(priv, lnk, li);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tli->link++;\nerr:\n\treturn ret;\n}\n\nstatic int graph_counter(struct device_node *lnk)\n{\n\t \n\tif (graph_lnk_is_multi(lnk))\n\t\treturn of_graph_get_endpoint_count(of_get_parent(lnk)) - 1;\n\t \n\telse\n\t\treturn 1;\n}\n\nstatic int graph_count_normal(struct asoc_simple_priv *priv,\n\t\t\t      struct device_node *lnk,\n\t\t\t      struct link_info *li)\n{\n\tstruct device_node *cpu_port = lnk;\n\tstruct device_node *cpu_ep = port_to_endpoint(cpu_port);\n\tstruct device_node *codec_port = of_graph_get_remote_port(cpu_ep);\n\n\t \n\t \n\tli->num[li->link].cpus\t\t=\n\tli->num[li->link].platforms\t= graph_counter(cpu_port);\n\n\tli->num[li->link].codecs\t= graph_counter(codec_port);\n\n\tof_node_put(cpu_ep);\n\tof_node_put(codec_port);\n\n\treturn 0;\n}\n\nstatic int graph_count_dpcm(struct asoc_simple_priv *priv,\n\t\t\t    struct device_node *lnk,\n\t\t\t    struct link_info *li)\n{\n\tstruct device_node *ep = port_to_endpoint(lnk);\n\tstruct device_node *rport = of_graph_get_remote_port(ep);\n\n\t \n\n\tif (asoc_graph_is_ports0(lnk)) {\n\t\t \n\t\tli->num[li->link].cpus\t\t= graph_counter(rport);  \n\t\tli->num[li->link].platforms\t= graph_counter(rport);\n\t} else {\n\t\tli->num[li->link].codecs\t= graph_counter(rport);  \n\t}\n\n\tof_node_put(ep);\n\tof_node_put(rport);\n\n\treturn 0;\n}\n\nstatic int graph_count_c2c(struct asoc_simple_priv *priv,\n\t\t\t   struct device_node *lnk,\n\t\t\t   struct link_info *li)\n{\n\tstruct device_node *ports = of_get_parent(lnk);\n\tstruct device_node *port0 = lnk;\n\tstruct device_node *port1 = of_get_next_child(ports, lnk);\n\tstruct device_node *ep0 = port_to_endpoint(port0);\n\tstruct device_node *ep1 = port_to_endpoint(port1);\n\tstruct device_node *codec0 = of_graph_get_remote_port(ep0);\n\tstruct device_node *codec1 = of_graph_get_remote_port(ep1);\n\n\tof_node_get(lnk);\n\n\t \n\t \n\tli->num[li->link].cpus\t\t=\n\tli->num[li->link].platforms\t= graph_counter(codec0);\n\n\tli->num[li->link].codecs\t= graph_counter(codec1);\n\n\tof_node_put(ports);\n\tof_node_put(port1);\n\tof_node_put(ep0);\n\tof_node_put(ep1);\n\tof_node_put(codec0);\n\tof_node_put(codec1);\n\n\treturn 0;\n}\n\nstatic int graph_count(struct asoc_simple_priv *priv,\n\t\t       struct graph2_custom_hooks *hooks,\n\t\t       enum graph_type gtype,\n\t\t       struct device_node *lnk,\n\t\t       struct link_info *li)\n{\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tGRAPH2_CUSTOM func = NULL;\n\tint ret = -EINVAL;\n\n\tif (li->link >= SNDRV_MAX_LINKS) {\n\t\tdev_err(dev, \"too many links\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (gtype) {\n\tcase GRAPH_NORMAL:\n\t\tfunc = graph_count_normal;\n\t\tbreak;\n\tcase GRAPH_DPCM:\n\t\tfunc = graph_count_dpcm;\n\t\tbreak;\n\tcase GRAPH_C2C:\n\t\tfunc = graph_count_c2c;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!func) {\n\t\tdev_err(dev, \"non supported gtype (%d)\\n\", gtype);\n\t\tgoto err;\n\t}\n\n\tret = func(priv, lnk, li);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tli->link++;\nerr:\n\treturn ret;\n}\n\nstatic int graph_for_each_link(struct asoc_simple_priv *priv,\n\t\t\t       struct graph2_custom_hooks *hooks,\n\t\t\t       struct link_info *li,\n\t\t\t       int (*func)(struct asoc_simple_priv *priv,\n\t\t\t\t\t   struct graph2_custom_hooks *hooks,\n\t\t\t\t\t   enum graph_type gtype,\n\t\t\t\t\t   struct device_node *lnk,\n\t\t\t\t\t   struct link_info *li))\n{\n\tstruct of_phandle_iterator it;\n\tstruct device *dev = simple_priv_to_dev(priv);\n\tstruct device_node *node = dev->of_node;\n\tstruct device_node *lnk;\n\tenum graph_type gtype;\n\tint rc, ret;\n\n\t \n\tof_for_each_phandle(&it, rc, node, \"links\", NULL, 0) {\n\t\tlnk = it.node;\n\n\t\tgtype = graph_get_type(priv, lnk);\n\n\t\tret = func(priv, hooks, gtype, lnk, li);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint audio_graph2_parse_of(struct asoc_simple_priv *priv, struct device *dev,\n\t\t\t  struct graph2_custom_hooks *hooks)\n{\n\tstruct snd_soc_card *card = simple_priv_to_card(priv);\n\tstruct link_info *li;\n\tint ret;\n\n\tli = devm_kzalloc(dev, sizeof(*li), GFP_KERNEL);\n\tif (!li)\n\t\treturn -ENOMEM;\n\n\tcard->probe\t= asoc_graph_card_probe;\n\tcard->owner\t= THIS_MODULE;\n\tcard->dev\t= dev;\n\n\tif ((hooks) && (hooks)->hook_pre) {\n\t\tret = (hooks)->hook_pre(priv);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tret = graph_for_each_link(priv, hooks, li, graph_count);\n\tif (!li->link)\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = asoc_simple_init_priv(priv, li);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tpriv->pa_gpio = devm_gpiod_get_optional(dev, \"pa\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->pa_gpio)) {\n\t\tret = PTR_ERR(priv->pa_gpio);\n\t\tdev_err(dev, \"failed to get amplifier gpio: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = asoc_simple_parse_widgets(card, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = asoc_simple_parse_routing(card, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmemset(li, 0, sizeof(*li));\n\tret = graph_for_each_link(priv, hooks, li, graph_link);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = asoc_simple_parse_card_name(card, NULL);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tif ((hooks) && (hooks)->hook_post) {\n\t\tret = (hooks)->hook_post(priv);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\n\n\tasoc_simple_debug_info(priv);\n\n\tret = devm_snd_soc_register_card(dev, card);\nerr:\n\tdevm_kfree(dev, li);\n\n\tif (ret < 0)\n\t\tdev_err_probe(dev, ret, \"parse error\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(audio_graph2_parse_of);\n\nstatic int graph_probe(struct platform_device *pdev)\n{\n\tstruct asoc_simple_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\treturn audio_graph2_parse_of(priv, dev, NULL);\n}\n\nstatic const struct of_device_id graph_of_match[] = {\n\t{ .compatible = \"audio-graph-card2\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, graph_of_match);\n\nstatic struct platform_driver graph_card = {\n\t.driver = {\n\t\t.name = \"asoc-audio-graph-card2\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = graph_of_match,\n\t},\n\t.probe\t= graph_probe,\n\t.remove\t= asoc_simple_remove,\n};\nmodule_platform_driver(graph_card);\n\nMODULE_ALIAS(\"platform:asoc-audio-graph-card2\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ASoC Audio Graph Card2\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}