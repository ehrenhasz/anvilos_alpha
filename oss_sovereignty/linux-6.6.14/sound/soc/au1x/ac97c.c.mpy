{
  "module_name": "ac97c.c",
  "hash_id": "54c7aaf09d5674f1396a5a817681a1b0bc047db978367e47fe93baf6de3d5c22",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/ac97c.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/suspend.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <asm/mach-au1x00/au1000.h>\n\n#include \"psc.h\"\n\n \n#define AC97_CONFIG\t0x00\n#define AC97_STATUS\t0x04\n#define AC97_DATA\t0x08\n#define AC97_CMDRESP\t0x0c\n#define AC97_ENABLE\t0x10\n\n#define CFG_RC(x)\t(((x) & 0x3ff) << 13)\t \n#define CFG_XS(x)\t(((x) & 0x3ff) << 3)\t \n#define CFG_SG\t\t(1 << 2)\t \n#define CFG_SN\t\t(1 << 1)\t \n#define CFG_RS\t\t(1 << 0)\t \n#define STAT_XU\t\t(1 << 11)\t \n#define STAT_XO\t\t(1 << 10)\t \n#define STAT_RU\t\t(1 << 9)\t \n#define STAT_RO\t\t(1 << 8)\t \n#define STAT_RD\t\t(1 << 7)\t \n#define STAT_CP\t\t(1 << 6)\t \n#define STAT_TE\t\t(1 << 4)\t \n#define STAT_TF\t\t(1 << 3)\t \n#define STAT_RE\t\t(1 << 1)\t \n#define STAT_RF\t\t(1 << 0)\t \n#define CMD_SET_DATA(x)\t(((x) & 0xffff) << 16)\n#define CMD_GET_DATA(x)\t((x) & 0xffff)\n#define CMD_READ\t(1 << 7)\n#define CMD_WRITE\t(0 << 7)\n#define CMD_IDX(x)\t((x) & 0x7f)\n#define EN_D\t\t(1 << 1)\t \n#define EN_CE\t\t(1 << 0)\t \n\n \n#define AC97_RW_RETRIES\t5\n\n#define AC97_RATES\t\\\n\tSNDRV_PCM_RATE_CONTINUOUS\n\n#define AC97_FMTS\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE)\n\n \nstatic struct au1xpsc_audio_data *ac97c_workdata;\n#define ac97_to_ctx(x)\t\tac97c_workdata\n\nstatic inline unsigned long RD(struct au1xpsc_audio_data *ctx, int reg)\n{\n\treturn __raw_readl(ctx->mmio + reg);\n}\n\nstatic inline void WR(struct au1xpsc_audio_data *ctx, int reg, unsigned long v)\n{\n\t__raw_writel(v, ctx->mmio + reg);\n\twmb();\n}\n\nstatic unsigned short au1xac97c_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\t  unsigned short r)\n{\n\tstruct au1xpsc_audio_data *ctx = ac97_to_ctx(ac97);\n\tunsigned int tmo, retry;\n\tunsigned long data;\n\n\tdata = ~0;\n\tretry = AC97_RW_RETRIES;\n\tdo {\n\t\tmutex_lock(&ctx->lock);\n\n\t\ttmo = 6;\n\t\twhile ((RD(ctx, AC97_STATUS) & STAT_CP) && --tmo)\n\t\t\tudelay(21);\t \n\t\tif (!tmo) {\n\t\t\tpr_debug(\"ac97rd timeout #1\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\tWR(ctx, AC97_CMDRESP, CMD_IDX(r) | CMD_READ);\n\n\t\t \n\t\ttmo = 0x10000;\n\t\twhile ((RD(ctx, AC97_STATUS) & STAT_CP) && --tmo)\n\t\t\tasm volatile (\"nop\");\n\t\tdata = RD(ctx, AC97_CMDRESP);\n\n\t\tif (!tmo)\n\t\t\tpr_debug(\"ac97rd timeout #2\\n\");\n\nnext:\n\t\tmutex_unlock(&ctx->lock);\n\t} while (--retry && !tmo);\n\n\tpr_debug(\"AC97RD %04x %04lx %d\\n\", r, data, retry);\n\n\treturn retry ? data & 0xffff : 0xffff;\n}\n\nstatic void au1xac97c_ac97_write(struct snd_ac97 *ac97, unsigned short r,\n\t\t\t\t unsigned short v)\n{\n\tstruct au1xpsc_audio_data *ctx = ac97_to_ctx(ac97);\n\tunsigned int tmo, retry;\n\n\tretry = AC97_RW_RETRIES;\n\tdo {\n\t\tmutex_lock(&ctx->lock);\n\n\t\tfor (tmo = 5; (RD(ctx, AC97_STATUS) & STAT_CP) && tmo; tmo--)\n\t\t\tudelay(21);\n\t\tif (!tmo) {\n\t\t\tpr_debug(\"ac97wr timeout #1\\n\");\n\t\t\tgoto next;\n\t\t}\n\n\t\tWR(ctx, AC97_CMDRESP, CMD_WRITE | CMD_IDX(r) | CMD_SET_DATA(v));\n\n\t\tfor (tmo = 10; (RD(ctx, AC97_STATUS) & STAT_CP) && tmo; tmo--)\n\t\t\tudelay(21);\n\t\tif (!tmo)\n\t\t\tpr_debug(\"ac97wr timeout #2\\n\");\nnext:\n\t\tmutex_unlock(&ctx->lock);\n\t} while (--retry && !tmo);\n\n\tpr_debug(\"AC97WR %04x %04x %d\\n\", r, v, retry);\n}\n\nstatic void au1xac97c_ac97_warm_reset(struct snd_ac97 *ac97)\n{\n\tstruct au1xpsc_audio_data *ctx = ac97_to_ctx(ac97);\n\n\tWR(ctx, AC97_CONFIG, ctx->cfg | CFG_SG | CFG_SN);\n\tmsleep(20);\n\tWR(ctx, AC97_CONFIG, ctx->cfg | CFG_SG);\n\tWR(ctx, AC97_CONFIG, ctx->cfg);\n}\n\nstatic void au1xac97c_ac97_cold_reset(struct snd_ac97 *ac97)\n{\n\tstruct au1xpsc_audio_data *ctx = ac97_to_ctx(ac97);\n\tint i;\n\n\tWR(ctx, AC97_CONFIG, ctx->cfg | CFG_RS);\n\tmsleep(500);\n\tWR(ctx, AC97_CONFIG, ctx->cfg);\n\n\t \n\ti = 50;\n\twhile (((RD(ctx, AC97_STATUS) & STAT_RD) == 0) && --i)\n\t\tmsleep(20);\n\tif (!i)\n\t\tprintk(KERN_ERR \"ac97c: codec not ready after cold reset\\n\");\n}\n\n \nstatic struct snd_ac97_bus_ops ac97c_bus_ops = {\n\t.read\t\t= au1xac97c_ac97_read,\n\t.write\t\t= au1xac97c_ac97_write,\n\t.reset\t\t= au1xac97c_ac97_cold_reset,\n\t.warm_reset\t= au1xac97c_ac97_warm_reset,\n};\n\nstatic int alchemy_ac97c_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *ctx = snd_soc_dai_get_drvdata(dai);\n\tsnd_soc_dai_set_dma_data(dai, substream, &ctx->dmaids[0]);\n\treturn 0;\n}\n\nstatic int au1xac97c_dai_probe(struct snd_soc_dai *dai)\n{\n\treturn ac97c_workdata ? 0 : -ENODEV;\n}\n\nstatic const struct snd_soc_dai_ops alchemy_ac97c_ops = {\n\t.probe\t\t\t= au1xac97c_dai_probe,\n\t.startup\t\t= alchemy_ac97c_startup,\n};\n\nstatic struct snd_soc_dai_driver au1xac97c_dai_driver = {\n\t.name\t\t\t= \"alchemy-ac97c\",\n\t.playback = {\n\t\t.rates\t\t= AC97_RATES,\n\t\t.formats\t= AC97_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.capture = {\n\t\t.rates\t\t= AC97_RATES,\n\t\t.formats\t= AC97_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.ops\t\t\t= &alchemy_ac97c_ops,\n};\n\nstatic const struct snd_soc_component_driver au1xac97c_component = {\n\t.name\t\t\t= \"au1xac97c\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int au1xac97c_drvprobe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *iores, *dmares;\n\tstruct au1xpsc_audio_data *ctx;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ctx->lock);\n\n\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iores)\n\t\treturn -ENODEV;\n\n\tif (!devm_request_mem_region(&pdev->dev, iores->start,\n\t\t\t\t     resource_size(iores),\n\t\t\t\t     pdev->name))\n\t\treturn -EBUSY;\n\n\tctx->mmio = devm_ioremap(&pdev->dev, iores->start,\n\t\t\t\t\t resource_size(iores));\n\tif (!ctx->mmio)\n\t\treturn -EBUSY;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\tctx->dmaids[SNDRV_PCM_STREAM_PLAYBACK] = dmares->start;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\tctx->dmaids[SNDRV_PCM_STREAM_CAPTURE] = dmares->start;\n\n\t \n\tWR(ctx, AC97_ENABLE, EN_D | EN_CE);\n\tWR(ctx, AC97_ENABLE, EN_CE);\n\n\tctx->cfg = CFG_RC(3) | CFG_XS(3);\n\tWR(ctx, AC97_CONFIG, ctx->cfg);\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\tret = snd_soc_set_ac97_ops(&ac97c_bus_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_register_component(&pdev->dev, &au1xac97c_component,\n\t\t\t\t\t &au1xac97c_dai_driver, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tac97c_workdata = ctx;\n\treturn 0;\n}\n\nstatic void au1xac97c_drvremove(struct platform_device *pdev)\n{\n\tstruct au1xpsc_audio_data *ctx = platform_get_drvdata(pdev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\tWR(ctx, AC97_ENABLE, EN_D);\t \n\n\tac97c_workdata = NULL;\t \n}\n\n#ifdef CONFIG_PM\nstatic int au1xac97c_drvsuspend(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *ctx = dev_get_drvdata(dev);\n\n\tWR(ctx, AC97_ENABLE, EN_D);\t \n\n\treturn 0;\n}\n\nstatic int au1xac97c_drvresume(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *ctx = dev_get_drvdata(dev);\n\n\tWR(ctx, AC97_ENABLE, EN_D | EN_CE);\n\tWR(ctx, AC97_ENABLE, EN_CE);\n\tWR(ctx, AC97_CONFIG, ctx->cfg);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1xpscac97_pmops = {\n\t.suspend\t= au1xac97c_drvsuspend,\n\t.resume\t\t= au1xac97c_drvresume,\n};\n\n#define AU1XPSCAC97_PMOPS (&au1xpscac97_pmops)\n\n#else\n\n#define AU1XPSCAC97_PMOPS NULL\n\n#endif\n\nstatic struct platform_driver au1xac97c_driver = {\n\t.driver\t= {\n\t\t.name\t= \"alchemy-ac97c\",\n\t\t.pm\t= AU1XPSCAC97_PMOPS,\n\t},\n\t.probe\t\t= au1xac97c_drvprobe,\n\t.remove_new\t= au1xac97c_drvremove,\n};\n\nmodule_platform_driver(au1xac97c_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au1000/1500/1100 AC97C ASoC driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}