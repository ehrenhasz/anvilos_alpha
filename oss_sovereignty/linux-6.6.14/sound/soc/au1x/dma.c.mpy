{
  "module_name": "dma.c",
  "hash_id": "566d7f31a37e8305fcae7ec503e35d1f953bbe8c30df47490c65ede7511e3b33",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/dma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1000_dma.h>\n\n#include \"psc.h\"\n\n#define DRV_NAME \"au1x_dma\"\n\nstruct pcm_period {\n\tu32 start;\n\tu32 relative_end;\t \n\tstruct pcm_period *next;\n};\n\nstruct audio_stream {\n\tstruct snd_pcm_substream *substream;\n\tint dma;\n\tstruct pcm_period *buffer;\n\tunsigned int period_size;\n\tunsigned int periods;\n};\n\nstruct alchemy_pcm_ctx {\n\tstruct audio_stream stream[2];\t \n};\n\nstatic void au1000_release_dma_link(struct audio_stream *stream)\n{\n\tstruct pcm_period *pointer;\n\tstruct pcm_period *pointer_next;\n\n\tstream->period_size = 0;\n\tstream->periods = 0;\n\tpointer = stream->buffer;\n\tif (!pointer)\n\t\treturn;\n\tdo {\n\t\tpointer_next = pointer->next;\n\t\tkfree(pointer);\n\t\tpointer = pointer_next;\n\t} while (pointer != stream->buffer);\n\tstream->buffer = NULL;\n}\n\nstatic int au1000_setup_dma_link(struct audio_stream *stream,\n\t\t\t\t unsigned int period_bytes,\n\t\t\t\t unsigned int periods)\n{\n\tstruct snd_pcm_substream *substream = stream->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct pcm_period *pointer;\n\tunsigned long dma_start;\n\tint i;\n\n\tdma_start = virt_to_phys(runtime->dma_area);\n\n\tif (stream->period_size == period_bytes &&\n\t    stream->periods == periods)\n\t\treturn 0;  \n\n\tau1000_release_dma_link(stream);\n\n\tstream->period_size = period_bytes;\n\tstream->periods = periods;\n\n\tstream->buffer = kmalloc(sizeof(struct pcm_period), GFP_KERNEL);\n\tif (!stream->buffer)\n\t\treturn -ENOMEM;\n\tpointer = stream->buffer;\n\tfor (i = 0; i < periods; i++) {\n\t\tpointer->start = (u32)(dma_start + (i * period_bytes));\n\t\tpointer->relative_end = (u32) (((i+1) * period_bytes) - 0x1);\n\t\tif (i < periods - 1) {\n\t\t\tpointer->next = kmalloc(sizeof(struct pcm_period),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!pointer->next) {\n\t\t\t\tau1000_release_dma_link(stream);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpointer = pointer->next;\n\t\t}\n\t}\n\tpointer->next = stream->buffer;\n\treturn 0;\n}\n\nstatic void au1000_dma_stop(struct audio_stream *stream)\n{\n\tif (stream->buffer)\n\t\tdisable_dma(stream->dma);\n}\n\nstatic void au1000_dma_start(struct audio_stream *stream)\n{\n\tif (!stream->buffer)\n\t\treturn;\n\n\tinit_dma(stream->dma);\n\tif (get_dma_active_buffer(stream->dma) == 0) {\n\t\tclear_dma_done0(stream->dma);\n\t\tset_dma_addr0(stream->dma, stream->buffer->start);\n\t\tset_dma_count0(stream->dma, stream->period_size >> 1);\n\t\tset_dma_addr1(stream->dma, stream->buffer->next->start);\n\t\tset_dma_count1(stream->dma, stream->period_size >> 1);\n\t} else {\n\t\tclear_dma_done1(stream->dma);\n\t\tset_dma_addr1(stream->dma, stream->buffer->start);\n\t\tset_dma_count1(stream->dma, stream->period_size >> 1);\n\t\tset_dma_addr0(stream->dma, stream->buffer->next->start);\n\t\tset_dma_count0(stream->dma, stream->period_size >> 1);\n\t}\n\tenable_dma_buffers(stream->dma);\n\tstart_dma(stream->dma);\n}\n\nstatic irqreturn_t au1000_dma_interrupt(int irq, void *ptr)\n{\n\tstruct audio_stream *stream = (struct audio_stream *)ptr;\n\tstruct snd_pcm_substream *substream = stream->substream;\n\n\tswitch (get_dma_buffer_done(stream->dma)) {\n\tcase DMA_D0:\n\t\tstream->buffer = stream->buffer->next;\n\t\tclear_dma_done0(stream->dma);\n\t\tset_dma_addr0(stream->dma, stream->buffer->next->start);\n\t\tset_dma_count0(stream->dma, stream->period_size >> 1);\n\t\tenable_dma_buffer0(stream->dma);\n\t\tbreak;\n\tcase DMA_D1:\n\t\tstream->buffer = stream->buffer->next;\n\t\tclear_dma_done1(stream->dma);\n\t\tset_dma_addr1(stream->dma, stream->buffer->next->start);\n\t\tset_dma_count1(stream->dma, stream->period_size >> 1);\n\t\tenable_dma_buffer1(stream->dma);\n\t\tbreak;\n\tcase (DMA_D0 | DMA_D1):\n\t\tpr_debug(\"DMA %d missed interrupt.\\n\", stream->dma);\n\t\tau1000_dma_stop(stream);\n\t\tau1000_dma_start(stream);\n\t\tbreak;\n\tcase (~DMA_D0 & ~DMA_D1):\n\t\tpr_debug(\"DMA %d empty irq.\\n\", stream->dma);\n\t}\n\tsnd_pcm_period_elapsed(substream);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_pcm_hardware alchemy_pcm_hardware = {\n\t.info\t\t  = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t    SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BATCH,\n\t.period_bytes_min = 1024,\n\t.period_bytes_max = 16 * 1024 - 1,\n\t.periods_min\t  = 4,\n\t.periods_max\t  = 255,\n\t.buffer_bytes_max = 128 * 1024,\n\t.fifo_size\t  = 16,\n};\n\nstatic inline struct alchemy_pcm_ctx *ss_to_ctx(struct snd_pcm_substream *ss,\n\t\t\t\t\t\tstruct snd_soc_component *component)\n{\n\treturn snd_soc_component_get_drvdata(component);\n}\n\nstatic inline struct audio_stream *ss_to_as(struct snd_pcm_substream *ss,\n\t\t\t\t\t    struct snd_soc_component *component)\n{\n\tstruct alchemy_pcm_ctx *ctx = ss_to_ctx(ss, component);\n\treturn &(ctx->stream[ss->stream]);\n}\n\nstatic int alchemy_pcm_open(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct alchemy_pcm_ctx *ctx = ss_to_ctx(substream, component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint *dmaids, s = substream->stream;\n\tchar *name;\n\n\tdmaids = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tif (!dmaids)\n\t\treturn -ENODEV;\t \n\n\t \n\tname = (s == SNDRV_PCM_STREAM_PLAYBACK) ? \"audio-tx\" : \"audio-rx\";\n\tctx->stream[s].dma = request_au1000_dma(dmaids[s], name,\n\t\t\t\t\tau1000_dma_interrupt, 0,\n\t\t\t\t\t&ctx->stream[s]);\n\tset_dma_mode(ctx->stream[s].dma,\n\t\t     get_dma_mode(ctx->stream[s].dma) & ~DMA_NC);\n\n\tctx->stream[s].substream = substream;\n\tctx->stream[s].buffer = NULL;\n\tsnd_soc_set_runtime_hwparams(substream, &alchemy_pcm_hardware);\n\n\treturn 0;\n}\n\nstatic int alchemy_pcm_close(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct alchemy_pcm_ctx *ctx = ss_to_ctx(substream, component);\n\tint stype = substream->stream;\n\n\tctx->stream[stype].substream = NULL;\n\tfree_au1000_dma(ctx->stream[stype].dma);\n\n\treturn 0;\n}\n\nstatic int alchemy_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *hw_params)\n{\n\tstruct audio_stream *stream = ss_to_as(substream, component);\n\n\treturn au1000_setup_dma_link(stream,\n\t\t\t\t     params_period_bytes(hw_params),\n\t\t\t\t     params_periods(hw_params));\n}\n\nstatic int alchemy_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct audio_stream *stream = ss_to_as(substream, component);\n\tau1000_release_dma_link(stream);\n\treturn 0;\n}\n\nstatic int alchemy_pcm_trigger(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct audio_stream *stream = ss_to_as(substream, component);\n\tint err = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tau1000_dma_start(stream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tau1000_dma_stop(stream);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\nstatic snd_pcm_uframes_t alchemy_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t     struct snd_pcm_substream *ss)\n{\n\tstruct audio_stream *stream = ss_to_as(ss, component);\n\tlong location;\n\n\tlocation = get_dma_residue(stream->dma);\n\tlocation = stream->buffer->relative_end - location;\n\tif (location == -1)\n\t\tlocation = 0;\n\treturn bytes_to_frames(ss->runtime, location);\n}\n\nstatic int alchemy_pcm_new(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 65536, (4096 * 1024) - 1);\n\n\treturn 0;\n}\n\nstatic struct snd_soc_component_driver alchemy_pcm_soc_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= alchemy_pcm_open,\n\t.close\t\t= alchemy_pcm_close,\n\t.hw_params\t= alchemy_pcm_hw_params,\n\t.hw_free\t= alchemy_pcm_hw_free,\n\t.trigger\t= alchemy_pcm_trigger,\n\t.pointer\t= alchemy_pcm_pointer,\n\t.pcm_construct\t= alchemy_pcm_new,\n};\n\nstatic int alchemy_pcm_drvprobe(struct platform_device *pdev)\n{\n\tstruct alchemy_pcm_ctx *ctx;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t&alchemy_pcm_soc_component, NULL, 0);\n}\n\nstatic struct platform_driver alchemy_pcmdma_driver = {\n\t.driver\t= {\n\t\t.name\t= \"alchemy-pcm-dma\",\n\t},\n\t.probe\t\t= alchemy_pcm_drvprobe,\n};\n\nmodule_platform_driver(alchemy_pcmdma_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au1000/Au1500/Au1100 Audio DMA driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}