{
  "module_name": "psc-ac97.c",
  "hash_id": "9edc906153192f4521a401c48db989808d0e06a25f880b38923007478ee08b19",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/psc-ac97.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/suspend.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_psc.h>\n\n#include \"psc.h\"\n\n \n#define AC97_RW_RETRIES\t5\n\n#define AC97_DIR\t\\\n\t(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)\n\n#define AC97_RATES\t\\\n\tSNDRV_PCM_RATE_8000_48000\n\n#define AC97_FMTS\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3BE)\n\n#define AC97PCR_START(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_AC97PCR_TS : PSC_AC97PCR_RS)\n#define AC97PCR_STOP(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_AC97PCR_TP : PSC_AC97PCR_RP)\n#define AC97PCR_CLRFIFO(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_AC97PCR_TC : PSC_AC97PCR_RC)\n\n#define AC97STAT_BUSY(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_AC97STAT_TB : PSC_AC97STAT_RB)\n\n \nstatic struct au1xpsc_audio_data *au1xpsc_ac97_workdata;\n\n#if 0\n\n \nstatic inline struct au1xpsc_audio_data *ac97_to_pscdata(struct snd_ac97 *x)\n{\n\tstruct snd_soc_card *c = x->bus->card->private_data;\n\treturn snd_soc_dai_get_drvdata(c->asoc_rtd_to_cpu(rtd, 0));\n}\n\n#else\n\n#define ac97_to_pscdata(x)\tau1xpsc_ac97_workdata\n\n#endif\n\n \nstatic unsigned short au1xpsc_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\tunsigned short reg)\n{\n\tstruct au1xpsc_audio_data *pscdata = ac97_to_pscdata(ac97);\n\tunsigned short retry, tmo;\n\tunsigned long data;\n\n\t__raw_writel(PSC_AC97EVNT_CD, AC97_EVNT(pscdata));\n\twmb();  \n\n\tretry = AC97_RW_RETRIES;\n\tdo {\n\t\tmutex_lock(&pscdata->lock);\n\n\t\t__raw_writel(PSC_AC97CDC_RD | PSC_AC97CDC_INDX(reg),\n\t\t\t  AC97_CDC(pscdata));\n\t\twmb();  \n\n\t\ttmo = 20;\n\t\tdo {\n\t\t\tudelay(21);\n\t\t\tif (__raw_readl(AC97_EVNT(pscdata)) & PSC_AC97EVNT_CD)\n\t\t\t\tbreak;\n\t\t} while (--tmo);\n\n\t\tdata = __raw_readl(AC97_CDC(pscdata));\n\n\t\t__raw_writel(PSC_AC97EVNT_CD, AC97_EVNT(pscdata));\n\t\twmb();  \n\n\t\tmutex_unlock(&pscdata->lock);\n\n\t\tif (reg != ((data >> 16) & 0x7f))\n\t\t\ttmo = 1;\t \n\n\t} while (--retry && !tmo);\n\n\treturn retry ? data & 0xffff : 0xffff;\n}\n\n \nstatic void au1xpsc_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t\tunsigned short val)\n{\n\tstruct au1xpsc_audio_data *pscdata = ac97_to_pscdata(ac97);\n\tunsigned int tmo, retry;\n\n\t__raw_writel(PSC_AC97EVNT_CD, AC97_EVNT(pscdata));\n\twmb();  \n\n\tretry = AC97_RW_RETRIES;\n\tdo {\n\t\tmutex_lock(&pscdata->lock);\n\n\t\t__raw_writel(PSC_AC97CDC_INDX(reg) | (val & 0xffff),\n\t\t\t  AC97_CDC(pscdata));\n\t\twmb();  \n\n\t\ttmo = 20;\n\t\tdo {\n\t\t\tudelay(21);\n\t\t\tif (__raw_readl(AC97_EVNT(pscdata)) & PSC_AC97EVNT_CD)\n\t\t\t\tbreak;\n\t\t} while (--tmo);\n\n\t\t__raw_writel(PSC_AC97EVNT_CD, AC97_EVNT(pscdata));\n\t\twmb();  \n\n\t\tmutex_unlock(&pscdata->lock);\n\t} while (--retry && !tmo);\n}\n\n \nstatic void au1xpsc_ac97_warm_reset(struct snd_ac97 *ac97)\n{\n\tstruct au1xpsc_audio_data *pscdata = ac97_to_pscdata(ac97);\n\n\t__raw_writel(PSC_AC97RST_SNC, AC97_RST(pscdata));\n\twmb();  \n\tmsleep(10);\n\t__raw_writel(0, AC97_RST(pscdata));\n\twmb();  \n}\n\nstatic void au1xpsc_ac97_cold_reset(struct snd_ac97 *ac97)\n{\n\tstruct au1xpsc_audio_data *pscdata = ac97_to_pscdata(ac97);\n\tint i;\n\n\t \n\t__raw_writel(0, AC97_CFG(au1xpsc_ac97_workdata));\n\twmb();  \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(pscdata));\n\twmb();  \n\n\t \n\t__raw_writel(PSC_AC97RST_RST, AC97_RST(pscdata));\n\twmb();  \n\tmsleep(500);\n\t__raw_writel(0, AC97_RST(pscdata));\n\twmb();  \n\n\t \n\t__raw_writel(PSC_CTRL_ENABLE, PSC_CTRL(pscdata));\n\twmb();  \n\n\t \n\ti = 1000;\n\twhile (!((__raw_readl(AC97_STAT(pscdata)) & PSC_AC97STAT_SR)) && (--i))\n\t\tmsleep(1);\n\n\tif (i == 0) {\n\t\tprintk(KERN_ERR \"au1xpsc-ac97: PSC not ready!\\n\");\n\t\treturn;\n\t}\n\n\t \n\t__raw_writel(pscdata->cfg | PSC_AC97CFG_DE_ENABLE, AC97_CFG(pscdata));\n\twmb();  \n\n\t \n\ti = 1000;\n\twhile (!((__raw_readl(AC97_STAT(pscdata)) & PSC_AC97STAT_DR)) && (--i))\n\t\tmsleep(1);\n\tif (i == 0)\n\t\tprintk(KERN_ERR \"au1xpsc-ac97: AC97 ctrl not ready\\n\");\n}\n\n \nstatic struct snd_ac97_bus_ops psc_ac97_ops = {\n\t.read\t\t= au1xpsc_ac97_read,\n\t.write\t\t= au1xpsc_ac97_write,\n\t.reset\t\t= au1xpsc_ac97_cold_reset,\n\t.warm_reset\t= au1xpsc_ac97_warm_reset,\n};\n\nstatic int au1xpsc_ac97_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\tunsigned long r, ro, stat;\n\tint chans, t, stype = substream->stream;\n\n\tchans = params_channels(params);\n\n\tr = ro = __raw_readl(AC97_CFG(pscdata));\n\tstat = __raw_readl(AC97_STAT(pscdata));\n\n\t \n\tif (stat & (PSC_AC97STAT_TB | PSC_AC97STAT_RB)) {\n\t\t \n\t\tif ((PSC_AC97CFG_GET_LEN(r) != params->msbits) ||\n\t\t    (pscdata->rate != params_rate(params)))\n\t\t\treturn -EINVAL;\n\t} else {\n\n\t\t \n\t\tr &= ~PSC_AC97CFG_LEN_MASK;\n\t\tr |= PSC_AC97CFG_SET_LEN(params->msbits);\n\n\t\t \n\t\tif (stype == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tr &= ~PSC_AC97CFG_TXSLOT_MASK;\n\t\t\tr |= PSC_AC97CFG_TXSLOT_ENA(3);\n\t\t\tr |= PSC_AC97CFG_TXSLOT_ENA(4);\n\t\t} else {\n\t\t\tr &= ~PSC_AC97CFG_RXSLOT_MASK;\n\t\t\tr |= PSC_AC97CFG_RXSLOT_ENA(3);\n\t\t\tr |= PSC_AC97CFG_RXSLOT_ENA(4);\n\t\t}\n\n\t\t \n\t\tif (!(r ^ ro))\n\t\t\tgoto out;\n\n\t\t \n\t\tmutex_lock(&pscdata->lock);\n\n\t\t \n\t\t__raw_writel(r & ~PSC_AC97CFG_DE_ENABLE, AC97_CFG(pscdata));\n\t\twmb();  \n\n\t\t \n\t\tt = 100;\n\t\twhile ((__raw_readl(AC97_STAT(pscdata)) & PSC_AC97STAT_DR) && --t)\n\t\t\tmsleep(1);\n\n\t\tif (!t)\n\t\t\tprintk(KERN_ERR \"PSC-AC97: can't disable!\\n\");\n\n\t\t \n\t\t__raw_writel(r, AC97_CFG(pscdata));\n\t\twmb();  \n\n\t\t \n\t\t__raw_writel(r | PSC_AC97CFG_DE_ENABLE, AC97_CFG(pscdata));\n\t\twmb();  \n\n\t\t \n\t\tt = 100;\n\t\twhile ((!(__raw_readl(AC97_STAT(pscdata)) & PSC_AC97STAT_DR)) && --t)\n\t\t\tmsleep(1);\n\n\t\tif (!t)\n\t\t\tprintk(KERN_ERR \"PSC-AC97: can't enable!\\n\");\n\n\t\tmutex_unlock(&pscdata->lock);\n\n\t\tpscdata->cfg = r;\n\t\tpscdata->rate = params_rate(params);\n\t}\n\nout:\n\treturn 0;\n}\n\nstatic int au1xpsc_ac97_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\tint ret, stype = substream->stream;\n\n\tret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t__raw_writel(AC97PCR_CLRFIFO(stype), AC97_PCR(pscdata));\n\t\twmb();  \n\t\t__raw_writel(AC97PCR_START(stype), AC97_PCR(pscdata));\n\t\twmb();  \n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\t__raw_writel(AC97PCR_STOP(stype), AC97_PCR(pscdata));\n\t\twmb();  \n\n\t\twhile (__raw_readl(AC97_STAT(pscdata)) & AC97STAT_BUSY(stype))\n\t\t\tasm volatile (\"nop\");\n\n\t\t__raw_writel(AC97PCR_CLRFIFO(stype), AC97_PCR(pscdata));\n\t\twmb();  \n\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int au1xpsc_ac97_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\tsnd_soc_dai_set_dma_data(dai, substream, &pscdata->dmaids[0]);\n\treturn 0;\n}\n\nstatic int au1xpsc_ac97_probe(struct snd_soc_dai *dai)\n{\n\treturn au1xpsc_ac97_workdata ? 0 : -ENODEV;\n}\n\nstatic const struct snd_soc_dai_ops au1xpsc_ac97_dai_ops = {\n\t.probe\t\t= au1xpsc_ac97_probe,\n\t.startup\t= au1xpsc_ac97_startup,\n\t.trigger\t= au1xpsc_ac97_trigger,\n\t.hw_params\t= au1xpsc_ac97_hw_params,\n};\n\nstatic const struct snd_soc_dai_driver au1xpsc_ac97_dai_template = {\n\t.playback = {\n\t\t.rates\t\t= AC97_RATES,\n\t\t.formats\t= AC97_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.capture = {\n\t\t.rates\t\t= AC97_RATES,\n\t\t.formats\t= AC97_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.ops = &au1xpsc_ac97_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver au1xpsc_ac97_component = {\n\t.name\t\t\t= \"au1xpsc-ac97\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int au1xpsc_ac97_drvprobe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct resource *dmares;\n\tunsigned long sel;\n\tstruct au1xpsc_audio_data *wd;\n\n\twd = devm_kzalloc(&pdev->dev, sizeof(struct au1xpsc_audio_data),\n\t\t\t  GFP_KERNEL);\n\tif (!wd)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wd->lock);\n\n\twd->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wd->mmio))\n\t\treturn PTR_ERR(wd->mmio);\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\twd->dmaids[SNDRV_PCM_STREAM_PLAYBACK] = dmares->start;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\twd->dmaids[SNDRV_PCM_STREAM_CAPTURE] = dmares->start;\n\n\t \n\twd->cfg = PSC_AC97CFG_RT_FIFO8 | PSC_AC97CFG_TT_FIFO8 |\n\t\t  PSC_AC97CFG_DE_ENABLE;\n\n\t \n\tsel = __raw_readl(PSC_SEL(wd)) & PSC_SEL_CLK_MASK;\n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\t__raw_writel(0, PSC_SEL(wd));\n\twmb();  \n\t__raw_writel(PSC_SEL_PS_AC97MODE | sel, PSC_SEL(wd));\n\twmb();  \n\n\t \n\tmemcpy(&wd->dai_drv, &au1xpsc_ac97_dai_template,\n\t       sizeof(struct snd_soc_dai_driver));\n\twd->dai_drv.name = dev_name(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, wd);\n\n\tret = snd_soc_set_ac97_ops(&psc_ac97_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_register_component(&pdev->dev, &au1xpsc_ac97_component,\n\t\t\t\t\t &wd->dai_drv, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tau1xpsc_ac97_workdata = wd;\n\treturn 0;\n}\n\nstatic void au1xpsc_ac97_drvremove(struct platform_device *pdev)\n{\n\tstruct au1xpsc_audio_data *wd = platform_get_drvdata(pdev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\t \n\t__raw_writel(0, AC97_CFG(wd));\n\twmb();  \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\n\tau1xpsc_ac97_workdata = NULL;\t \n}\n\n#ifdef CONFIG_PM\nstatic int au1xpsc_ac97_drvsuspend(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *wd = dev_get_drvdata(dev);\n\n\t \n\twd->pm[0] = __raw_readl(PSC_SEL(wd));\n\n\t__raw_writel(0, AC97_CFG(wd));\n\twmb();  \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int au1xpsc_ac97_drvresume(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *wd = dev_get_drvdata(dev);\n\n\t \n\t__raw_writel(wd->pm[0] | PSC_SEL_PS_AC97MODE, PSC_SEL(wd));\n\twmb();  \n\n\t \n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1xpscac97_pmops = {\n\t.suspend\t= au1xpsc_ac97_drvsuspend,\n\t.resume\t\t= au1xpsc_ac97_drvresume,\n};\n\n#define AU1XPSCAC97_PMOPS &au1xpscac97_pmops\n\n#else\n\n#define AU1XPSCAC97_PMOPS NULL\n\n#endif\n\nstatic struct platform_driver au1xpsc_ac97_driver = {\n\t.driver\t= {\n\t\t.name\t= \"au1xpsc_ac97\",\n\t\t.pm\t= AU1XPSCAC97_PMOPS,\n\t},\n\t.probe\t\t= au1xpsc_ac97_drvprobe,\n\t.remove_new\t= au1xpsc_ac97_drvremove,\n};\n\nmodule_platform_driver(au1xpsc_ac97_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au12x0/Au1550 PSC AC97 ALSA ASoC audio driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}