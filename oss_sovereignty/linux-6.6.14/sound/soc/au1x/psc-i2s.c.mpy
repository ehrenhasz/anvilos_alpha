{
  "module_name": "psc-i2s.c",
  "hash_id": "0588b2fdb580eac709186ac6087cb0e1de38abf50760ed2679780a96d00d2d78",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/psc-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_psc.h>\n\n#include \"psc.h\"\n\n \n#define AU1XPSC_I2S_DAIFMT \\\n\t(SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_LEFT_J |\t\\\n\t SND_SOC_DAIFMT_NB_NF)\n\n \n#define AU1XPSC_I2S_DIR \\\n\t(SND_SOC_DAIDIR_PLAYBACK | SND_SOC_DAIDIR_CAPTURE)\n\n#define AU1XPSC_I2S_RATES \\\n\tSNDRV_PCM_RATE_8000_192000\n\n#define AU1XPSC_I2S_FMTS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\n#define I2SSTAT_BUSY(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_I2SSTAT_TB : PSC_I2SSTAT_RB)\n#define I2SPCR_START(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_I2SPCR_TS : PSC_I2SPCR_RS)\n#define I2SPCR_STOP(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_I2SPCR_TP : PSC_I2SPCR_RP)\n#define I2SPCR_CLRFIFO(stype)\t\\\n\t((stype) == SNDRV_PCM_STREAM_PLAYBACK ? PSC_I2SPCR_TC : PSC_I2SPCR_RC)\n\n\nstatic int au1xpsc_i2s_set_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long ct;\n\tint ret;\n\n\tret = -EINVAL;\n\n\tct = pscdata->cfg;\n\n\tct &= ~(PSC_I2SCFG_XM | PSC_I2SCFG_MLJ);\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tct |= PSC_I2SCFG_XM;\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tct |= PSC_I2SCFG_MLJ;\t \n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tct &= ~(PSC_I2SCFG_BI | PSC_I2SCFG_WI);\t\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tct |= PSC_I2SCFG_BI | PSC_I2SCFG_WI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tct |= PSC_I2SCFG_BI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tct |= PSC_I2SCFG_WI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\t \n\t\tct |= PSC_I2SCFG_MS;\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\t \n\t\tct &= ~PSC_I2SCFG_MS;\t \n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tpscdata->cfg = ct;\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int au1xpsc_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\n\tint cfgbits;\n\tunsigned long stat;\n\n\t \n\tstat = __raw_readl(I2S_STAT(pscdata));\n\tif (stat & (PSC_I2SSTAT_TB | PSC_I2SSTAT_RB)) {\n\t\t \n\t\tcfgbits = __raw_readl(I2S_CFG(pscdata));\n\t\tif ((PSC_I2SCFG_GET_LEN(cfgbits) != params->msbits) ||\n\t\t    (params_rate(params) != pscdata->rate))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\t \n\t\tpscdata->cfg &= ~(0x1f << 4);\n\t\tpscdata->cfg |= PSC_I2SCFG_SET_LEN(params->msbits);\n\t\t \n\t\tpscdata->rate = params_rate(params);\n\t}\n\treturn 0;\n}\n\n \nstatic int au1xpsc_i2s_configure(struct au1xpsc_audio_data *pscdata)\n{\n\tunsigned long tmo;\n\n\t \n\t__raw_writel(PSC_CTRL_ENABLE, PSC_CTRL(pscdata));\n\twmb();  \n\n\ttmo = 1000000;\n\twhile (!(__raw_readl(I2S_STAT(pscdata)) & PSC_I2SSTAT_SR) && tmo)\n\t\ttmo--;\n\n\tif (!tmo)\n\t\tgoto psc_err;\n\n\t__raw_writel(0, I2S_CFG(pscdata));\n\twmb();  \n\t__raw_writel(pscdata->cfg | PSC_I2SCFG_DE_ENABLE, I2S_CFG(pscdata));\n\twmb();  \n\n\t \n\ttmo = 1000000;\n\twhile (!(__raw_readl(I2S_STAT(pscdata)) & PSC_I2SSTAT_DR) && tmo)\n\t\ttmo--;\n\n\tif (tmo)\n\t\treturn 0;\n\npsc_err:\n\t__raw_writel(0, I2S_CFG(pscdata));\n\t__raw_writel(PSC_CTRL_SUSPEND, PSC_CTRL(pscdata));\n\twmb();  \n\treturn -ETIMEDOUT;\n}\n\nstatic int au1xpsc_i2s_start(struct au1xpsc_audio_data *pscdata, int stype)\n{\n\tunsigned long tmo, stat;\n\tint ret;\n\n\tret = 0;\n\n\t \n\tstat = __raw_readl(I2S_STAT(pscdata));\n\tif (!(stat & (PSC_I2SSTAT_TB | PSC_I2SSTAT_RB))) {\n\t\tret = au1xpsc_i2s_configure(pscdata);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t__raw_writel(I2SPCR_CLRFIFO(stype), I2S_PCR(pscdata));\n\twmb();  \n\t__raw_writel(I2SPCR_START(stype), I2S_PCR(pscdata));\n\twmb();  \n\n\t \n\ttmo = 1000000;\n\twhile (!(__raw_readl(I2S_STAT(pscdata)) & I2SSTAT_BUSY(stype)) && tmo)\n\t\ttmo--;\n\n\tif (!tmo) {\n\t\t__raw_writel(I2SPCR_STOP(stype), I2S_PCR(pscdata));\n\t\twmb();  \n\t\tret = -ETIMEDOUT;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int au1xpsc_i2s_stop(struct au1xpsc_audio_data *pscdata, int stype)\n{\n\tunsigned long tmo, stat;\n\n\t__raw_writel(I2SPCR_STOP(stype), I2S_PCR(pscdata));\n\twmb();  \n\n\t \n\ttmo = 1000000;\n\twhile ((__raw_readl(I2S_STAT(pscdata)) & I2SSTAT_BUSY(stype)) && tmo)\n\t\ttmo--;\n\n\t \n\tstat = __raw_readl(I2S_STAT(pscdata));\n\tif (!(stat & (PSC_I2SSTAT_TB | PSC_I2SSTAT_RB))) {\n\t\t__raw_writel(0, I2S_CFG(pscdata));\n\t\twmb();  \n\t\t__raw_writel(PSC_CTRL_SUSPEND, PSC_CTRL(pscdata));\n\t\twmb();  \n\t}\n\treturn 0;\n}\n\nstatic int au1xpsc_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\tint ret, stype = substream->stream;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tret = au1xpsc_i2s_start(pscdata, stype);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tret = au1xpsc_i2s_stop(pscdata, stype);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int au1xpsc_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *pscdata = snd_soc_dai_get_drvdata(dai);\n\tsnd_soc_dai_set_dma_data(dai, substream, &pscdata->dmaids[0]);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops au1xpsc_i2s_dai_ops = {\n\t.startup\t= au1xpsc_i2s_startup,\n\t.trigger\t= au1xpsc_i2s_trigger,\n\t.hw_params\t= au1xpsc_i2s_hw_params,\n\t.set_fmt\t= au1xpsc_i2s_set_fmt,\n};\n\nstatic const struct snd_soc_dai_driver au1xpsc_i2s_dai_template = {\n\t.playback = {\n\t\t.rates\t\t= AU1XPSC_I2S_RATES,\n\t\t.formats\t= AU1XPSC_I2S_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\t \n\t},\n\t.capture = {\n\t\t.rates\t\t= AU1XPSC_I2S_RATES,\n\t\t.formats\t= AU1XPSC_I2S_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 8,\t \n\t},\n\t.ops = &au1xpsc_i2s_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver au1xpsc_i2s_component = {\n\t.name\t\t\t= \"au1xpsc-i2s\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int au1xpsc_i2s_drvprobe(struct platform_device *pdev)\n{\n\tstruct resource *dmares;\n\tunsigned long sel;\n\tstruct au1xpsc_audio_data *wd;\n\n\twd = devm_kzalloc(&pdev->dev, sizeof(struct au1xpsc_audio_data),\n\t\t\t  GFP_KERNEL);\n\tif (!wd)\n\t\treturn -ENOMEM;\n\n\twd->mmio = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(wd->mmio))\n\t\treturn PTR_ERR(wd->mmio);\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\twd->dmaids[SNDRV_PCM_STREAM_PLAYBACK] = dmares->start;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\twd->dmaids[SNDRV_PCM_STREAM_CAPTURE] = dmares->start;\n\n\t \n\tsel = __raw_readl(PSC_SEL(wd)) & PSC_SEL_CLK_MASK;\n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\t__raw_writel(PSC_SEL_PS_I2SMODE | sel, PSC_SEL(wd));\n\t__raw_writel(0, I2S_CFG(wd));\n\twmb();  \n\n\t \n\twd->cfg |= PSC_I2SCFG_RT_FIFO8 | PSC_I2SCFG_TT_FIFO8;\n\n\t \n\n\t \n\tmemcpy(&wd->dai_drv, &au1xpsc_i2s_dai_template,\n\t       sizeof(struct snd_soc_dai_driver));\n\twd->dai_drv.name = dev_name(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, wd);\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t&au1xpsc_i2s_component, &wd->dai_drv, 1);\n}\n\nstatic void au1xpsc_i2s_drvremove(struct platform_device *pdev)\n{\n\tstruct au1xpsc_audio_data *wd = platform_get_drvdata(pdev);\n\n\t__raw_writel(0, I2S_CFG(wd));\n\twmb();  \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n}\n\n#ifdef CONFIG_PM\nstatic int au1xpsc_i2s_drvsuspend(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *wd = dev_get_drvdata(dev);\n\n\t \n\twd->pm[0] = __raw_readl(PSC_SEL(wd));\n\n\t__raw_writel(0, I2S_CFG(wd));\n\twmb();  \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int au1xpsc_i2s_drvresume(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *wd = dev_get_drvdata(dev);\n\n\t \n\t__raw_writel(PSC_CTRL_DISABLE, PSC_CTRL(wd));\n\twmb();  \n\t__raw_writel(0, PSC_SEL(wd));\n\twmb();  \n\t__raw_writel(wd->pm[0], PSC_SEL(wd));\n\twmb();  \n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1xpsci2s_pmops = {\n\t.suspend\t= au1xpsc_i2s_drvsuspend,\n\t.resume\t\t= au1xpsc_i2s_drvresume,\n};\n\n#define AU1XPSCI2S_PMOPS &au1xpsci2s_pmops\n\n#else\n\n#define AU1XPSCI2S_PMOPS NULL\n\n#endif\n\nstatic struct platform_driver au1xpsc_i2s_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"au1xpsc_i2s\",\n\t\t.pm\t= AU1XPSCI2S_PMOPS,\n\t},\n\t.probe\t\t= au1xpsc_i2s_drvprobe,\n\t.remove_new\t= au1xpsc_i2s_drvremove,\n};\n\nmodule_platform_driver(au1xpsc_i2s_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au12x0/Au1550 PSC I2S ALSA ASoC audio driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}