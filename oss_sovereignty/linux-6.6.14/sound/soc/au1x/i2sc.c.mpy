{
  "module_name": "i2sc.c",
  "hash_id": "eca4e547451af754c56e20ed0670c3be030cec4528a05110bacef9f0073d1b22",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/i2sc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <asm/mach-au1x00/au1000.h>\n\n#include \"psc.h\"\n\n#define I2S_RXTX\t0x00\n#define I2S_CFG\t\t0x04\n#define I2S_ENABLE\t0x08\n\n#define CFG_XU\t\t(1 << 25)\t \n#define CFG_XO\t\t(1 << 24)\n#define CFG_RU\t\t(1 << 23)\n#define CFG_RO\t\t(1 << 22)\n#define CFG_TR\t\t(1 << 21)\n#define CFG_TE\t\t(1 << 20)\n#define CFG_TF\t\t(1 << 19)\n#define CFG_RR\t\t(1 << 18)\n#define CFG_RF\t\t(1 << 17)\n#define CFG_ICK\t\t(1 << 12)\t \n#define CFG_PD\t\t(1 << 11)\t \n#define CFG_LB\t\t(1 << 10)\t \n#define CFG_IC\t\t(1 << 9)\t \n#define CFG_FM_I2S\t(0 << 7)\t \n#define CFG_FM_LJ\t(1 << 7)\t \n#define CFG_FM_RJ\t(2 << 7)\t \n#define CFG_FM_MASK\t(3 << 7)\n#define CFG_TN\t\t(1 << 6)\t \n#define CFG_RN\t\t(1 << 5)\t \n#define CFG_SZ_8\t(0x08)\n#define CFG_SZ_16\t(0x10)\n#define CFG_SZ_18\t(0x12)\n#define CFG_SZ_20\t(0x14)\n#define CFG_SZ_24\t(0x18)\n#define CFG_SZ_MASK\t(0x1f)\n#define EN_D\t\t(1 << 1)\t \n#define EN_CE\t\t(1 << 0)\t \n\n \n#define AU1XI2SC_RATES \\\n\tSNDRV_PCM_RATE_CONTINUOUS\n\n#define AU1XI2SC_FMTS \\\n\t(SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_U8 |\t\t\\\n\tSNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\t\\\n\tSNDRV_PCM_FMTBIT_U16_LE | SNDRV_PCM_FMTBIT_U16_BE |\t\\\n\tSNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_U18_3LE |\t\\\n\tSNDRV_PCM_FMTBIT_S18_3BE | SNDRV_PCM_FMTBIT_U18_3BE |\t\\\n\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_U20_3LE |\t\\\n\tSNDRV_PCM_FMTBIT_S20_3BE | SNDRV_PCM_FMTBIT_U20_3BE |\t\\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE |\t\\\n\tSNDRV_PCM_FMTBIT_U24_LE | SNDRV_PCM_FMTBIT_U24_BE |\t\\\n\t0)\n\nstatic inline unsigned long RD(struct au1xpsc_audio_data *ctx, int reg)\n{\n\treturn __raw_readl(ctx->mmio + reg);\n}\n\nstatic inline void WR(struct au1xpsc_audio_data *ctx, int reg, unsigned long v)\n{\n\t__raw_writel(v, ctx->mmio + reg);\n\twmb();\n}\n\nstatic int au1xi2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tstruct au1xpsc_audio_data *ctx = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned long c;\n\tint ret;\n\n\tret = -EINVAL;\n\tc = ctx->cfg;\n\n\tc &= ~CFG_FM_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tc |= CFG_FM_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tc |= CFG_FM_RJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tc |= CFG_FM_LJ;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tc &= ~(CFG_IC | CFG_ICK);\t\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tc |= CFG_IC | CFG_ICK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tc |= CFG_IC;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tc |= CFG_ICK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\t \n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\tctx->cfg = c;\nout:\n\treturn ret;\n}\n\nstatic int au1xi2s_trigger(struct snd_pcm_substream *substream,\n\t\t\t   int cmd, struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *ctx = snd_soc_dai_get_drvdata(dai);\n\tint stype = SUBSTREAM_TYPE(substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\t \n\t\tWR(ctx, I2S_ENABLE, EN_D | EN_CE);\n\t\tWR(ctx, I2S_ENABLE, EN_CE);\n\t\tctx->cfg |= (stype == PCM_TX) ? CFG_TN : CFG_RN;\n\t\tWR(ctx, I2S_CFG, ctx->cfg);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tctx->cfg &= ~((stype == PCM_TX) ? CFG_TN : CFG_RN);\n\t\tWR(ctx, I2S_CFG, ctx->cfg);\n\t\tWR(ctx, I2S_ENABLE, EN_D);\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long msbits_to_reg(int msbits)\n{\n\tswitch (msbits) {\n\tcase 8:\n\t\treturn CFG_SZ_8;\n\tcase 16:\n\t\treturn CFG_SZ_16;\n\tcase 18:\n\t\treturn CFG_SZ_18;\n\tcase 20:\n\t\treturn CFG_SZ_20;\n\tcase 24:\n\t\treturn CFG_SZ_24;\n\t}\n\treturn 0;\n}\n\nstatic int au1xi2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *ctx = snd_soc_dai_get_drvdata(dai);\n\tunsigned long v;\n\n\tv = msbits_to_reg(params->msbits);\n\tif (!v)\n\t\treturn -EINVAL;\n\n\tctx->cfg &= ~CFG_SZ_MASK;\n\tctx->cfg |= v;\n\treturn 0;\n}\n\nstatic int au1xi2s_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct au1xpsc_audio_data *ctx = snd_soc_dai_get_drvdata(dai);\n\tsnd_soc_dai_set_dma_data(dai, substream, &ctx->dmaids[0]);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops au1xi2s_dai_ops = {\n\t.startup\t= au1xi2s_startup,\n\t.trigger\t= au1xi2s_trigger,\n\t.hw_params\t= au1xi2s_hw_params,\n\t.set_fmt\t= au1xi2s_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver au1xi2s_dai_driver = {\n\t.symmetric_rate\t\t= 1,\n\t.playback = {\n\t\t.rates\t\t= AU1XI2SC_RATES,\n\t\t.formats\t= AU1XI2SC_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.capture = {\n\t\t.rates\t\t= AU1XI2SC_RATES,\n\t\t.formats\t= AU1XI2SC_FMTS,\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t},\n\t.ops = &au1xi2s_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver au1xi2s_component = {\n\t.name\t\t\t= \"au1xi2s\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int au1xi2s_drvprobe(struct platform_device *pdev)\n{\n\tstruct resource *iores, *dmares;\n\tstruct au1xpsc_audio_data *ctx;\n\n\tctx = devm_kzalloc(&pdev->dev, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iores)\n\t\treturn -ENODEV;\n\n\tif (!devm_request_mem_region(&pdev->dev, iores->start,\n\t\t\t\t     resource_size(iores),\n\t\t\t\t     pdev->name))\n\t\treturn -EBUSY;\n\n\tctx->mmio = devm_ioremap(&pdev->dev, iores->start,\n\t\t\t\t\t resource_size(iores));\n\tif (!ctx->mmio)\n\t\treturn -EBUSY;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\tctx->dmaids[SNDRV_PCM_STREAM_PLAYBACK] = dmares->start;\n\n\tdmares = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\tif (!dmares)\n\t\treturn -EBUSY;\n\tctx->dmaids[SNDRV_PCM_STREAM_CAPTURE] = dmares->start;\n\n\tplatform_set_drvdata(pdev, ctx);\n\n\treturn snd_soc_register_component(&pdev->dev, &au1xi2s_component,\n\t\t\t\t\t  &au1xi2s_dai_driver, 1);\n}\n\nstatic void au1xi2s_drvremove(struct platform_device *pdev)\n{\n\tstruct au1xpsc_audio_data *ctx = platform_get_drvdata(pdev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\tWR(ctx, I2S_ENABLE, EN_D);\t \n}\n\n#ifdef CONFIG_PM\nstatic int au1xi2s_drvsuspend(struct device *dev)\n{\n\tstruct au1xpsc_audio_data *ctx = dev_get_drvdata(dev);\n\n\tWR(ctx, I2S_ENABLE, EN_D);\t \n\n\treturn 0;\n}\n\nstatic int au1xi2s_drvresume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops au1xi2sc_pmops = {\n\t.suspend\t= au1xi2s_drvsuspend,\n\t.resume\t\t= au1xi2s_drvresume,\n};\n\n#define AU1XI2SC_PMOPS (&au1xi2sc_pmops)\n\n#else\n\n#define AU1XI2SC_PMOPS NULL\n\n#endif\n\nstatic struct platform_driver au1xi2s_driver = {\n\t.driver\t= {\n\t\t.name\t= \"alchemy-i2sc\",\n\t\t.pm\t= AU1XI2SC_PMOPS,\n\t},\n\t.probe\t\t= au1xi2s_drvprobe,\n\t.remove_new\t= au1xi2s_drvremove,\n};\n\nmodule_platform_driver(au1xi2s_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au1000/1500/1100 I2S ASoC driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}