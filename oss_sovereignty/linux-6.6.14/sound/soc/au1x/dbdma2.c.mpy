{
  "module_name": "dbdma2.c",
  "hash_id": "0f6bc7cd254a993969829200c25518f857b3af3c85384b8d42d389a671ab7b61",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/au1x/dbdma2.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_dbdma.h>\n#include <asm/mach-au1x00/au1xxx_psc.h>\n\n#include \"psc.h\"\n\n \n\n#define DRV_NAME \"dbdma2\"\n\n#define MSG(x...)\tprintk(KERN_INFO \"au1xpsc_pcm: \" x)\n#ifdef PCM_DEBUG\n#define DBG\t\tMSG\n#else\n#define DBG(x...)\tdo {} while (0)\n#endif\n\nstruct au1xpsc_audio_dmadata {\n\t \n\tunsigned int ddma_id;\t\t \n\tu32 ddma_chan;\t\t\t \n\n\t \n\tstruct snd_pcm_substream *substream;\n\tunsigned long curr_period;\t \n\tunsigned long q_period;\t\t \n\tdma_addr_t dma_area;\t\t \n\tdma_addr_t dma_area_s;\t\t \n\tunsigned long pos;\t\t \n\tunsigned long periods;\t\t \n\tunsigned long period_bytes;\t \n\n\t \n\tint msbits;\n};\n\n \n#define AU1XPSC_PERIOD_MIN_BYTES\t1024\n#define AU1XPSC_BUFFER_MIN_BYTES\t65536\n\n \nstatic const struct snd_pcm_hardware au1xpsc_pcm_hardware = {\n\t.info\t\t  = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t    SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BATCH,\n\t.period_bytes_min = AU1XPSC_PERIOD_MIN_BYTES,\n\t.period_bytes_max = 4096 * 1024 - 1,\n\t.periods_min\t  = 2,\n\t.periods_max\t  = 4096,\t \n\t.buffer_bytes_max = 4096 * 1024 - 1,\n\t.fifo_size\t  = 16,\t\t \n};\n\nstatic void au1x_pcm_queue_tx(struct au1xpsc_audio_dmadata *cd)\n{\n\tau1xxx_dbdma_put_source(cd->ddma_chan, cd->dma_area,\n\t\t\t\tcd->period_bytes, DDMA_FLAGS_IE);\n\n\t \n\t++cd->q_period;\n\tcd->dma_area += cd->period_bytes;\n\tif (cd->q_period >= cd->periods) {\n\t\tcd->q_period = 0;\n\t\tcd->dma_area = cd->dma_area_s;\n\t}\n}\n\nstatic void au1x_pcm_queue_rx(struct au1xpsc_audio_dmadata *cd)\n{\n\tau1xxx_dbdma_put_dest(cd->ddma_chan, cd->dma_area,\n\t\t\t      cd->period_bytes, DDMA_FLAGS_IE);\n\n\t \n\t++cd->q_period;\n\tcd->dma_area += cd->period_bytes;\n\tif (cd->q_period >= cd->periods) {\n\t\tcd->q_period = 0;\n\t\tcd->dma_area = cd->dma_area_s;\n\t}\n}\n\nstatic void au1x_pcm_dmatx_cb(int irq, void *dev_id)\n{\n\tstruct au1xpsc_audio_dmadata *cd = dev_id;\n\n\tcd->pos += cd->period_bytes;\n\tif (++cd->curr_period >= cd->periods) {\n\t\tcd->pos = 0;\n\t\tcd->curr_period = 0;\n\t}\n\tsnd_pcm_period_elapsed(cd->substream);\n\tau1x_pcm_queue_tx(cd);\n}\n\nstatic void au1x_pcm_dmarx_cb(int irq, void *dev_id)\n{\n\tstruct au1xpsc_audio_dmadata *cd = dev_id;\n\n\tcd->pos += cd->period_bytes;\n\tif (++cd->curr_period >= cd->periods) {\n\t\tcd->pos = 0;\n\t\tcd->curr_period = 0;\n\t}\n\tsnd_pcm_period_elapsed(cd->substream);\n\tau1x_pcm_queue_rx(cd);\n}\n\nstatic void au1x_pcm_dbdma_free(struct au1xpsc_audio_dmadata *pcd)\n{\n\tif (pcd->ddma_chan) {\n\t\tau1xxx_dbdma_stop(pcd->ddma_chan);\n\t\tau1xxx_dbdma_reset(pcd->ddma_chan);\n\t\tau1xxx_dbdma_chan_free(pcd->ddma_chan);\n\t\tpcd->ddma_chan = 0;\n\t\tpcd->msbits = 0;\n\t}\n}\n\n \nstatic int au1x_pcm_dbdma_realloc(struct au1xpsc_audio_dmadata *pcd,\n\t\t\t\t int stype, int msbits)\n{\n\t \n\tif (msbits == 24)\n\t\tmsbits = 32;\n\n\t \n\tif ((pcd->ddma_chan) && (msbits == pcd->msbits))\n\t\tgoto out;\t \n\n\tau1x_pcm_dbdma_free(pcd);\n\n\tif (stype == SNDRV_PCM_STREAM_CAPTURE)\n\t\tpcd->ddma_chan = au1xxx_dbdma_chan_alloc(pcd->ddma_id,\n\t\t\t\t\tDSCR_CMD0_ALWAYS,\n\t\t\t\t\tau1x_pcm_dmarx_cb, (void *)pcd);\n\telse\n\t\tpcd->ddma_chan = au1xxx_dbdma_chan_alloc(DSCR_CMD0_ALWAYS,\n\t\t\t\t\tpcd->ddma_id,\n\t\t\t\t\tau1x_pcm_dmatx_cb, (void *)pcd);\n\n\tif (!pcd->ddma_chan)\n\t\treturn -ENOMEM;\n\n\tau1xxx_dbdma_set_devwidth(pcd->ddma_chan, msbits);\n\tau1xxx_dbdma_ring_alloc(pcd->ddma_chan, 2);\n\n\tpcd->msbits = msbits;\n\n\tau1xxx_dbdma_stop(pcd->ddma_chan);\n\tau1xxx_dbdma_reset(pcd->ddma_chan);\n\nout:\n\treturn 0;\n}\n\nstatic inline struct au1xpsc_audio_dmadata *to_dmadata(struct snd_pcm_substream *ss,\n\t\t\t\t\t\t       struct snd_soc_component *component)\n{\n\tstruct au1xpsc_audio_dmadata *pcd = snd_soc_component_get_drvdata(component);\n\treturn &pcd[ss->stream];\n}\n\nstatic int au1xpsc_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct au1xpsc_audio_dmadata *pcd;\n\tint stype, ret;\n\n\tstype = substream->stream;\n\tpcd = to_dmadata(substream, component);\n\n\tDBG(\"runtime->dma_area = 0x%08lx dma_addr_t = 0x%08lx dma_size = %zu \"\n\t    \"runtime->min_align %lu\\n\",\n\t\t(unsigned long)runtime->dma_area,\n\t\t(unsigned long)runtime->dma_addr, runtime->dma_bytes,\n\t\truntime->min_align);\n\n\tDBG(\"bits %d  frags %d  frag_bytes %d  is_rx %d\\n\", params->msbits,\n\t\tparams_periods(params), params_period_bytes(params), stype);\n\n\tret = au1x_pcm_dbdma_realloc(pcd, stype, params->msbits);\n\tif (ret) {\n\t\tMSG(\"DDMA channel (re)alloc failed!\\n\");\n\t\tgoto out;\n\t}\n\n\tpcd->substream = substream;\n\tpcd->period_bytes = params_period_bytes(params);\n\tpcd->periods = params_periods(params);\n\tpcd->dma_area_s = pcd->dma_area = runtime->dma_addr;\n\tpcd->q_period = 0;\n\tpcd->curr_period = 0;\n\tpcd->pos = 0;\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nstatic int au1xpsc_pcm_prepare(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct au1xpsc_audio_dmadata *pcd = to_dmadata(substream, component);\n\n\tau1xxx_dbdma_reset(pcd->ddma_chan);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tau1x_pcm_queue_rx(pcd);\n\t\tau1x_pcm_queue_rx(pcd);\n\t} else {\n\t\tau1x_pcm_queue_tx(pcd);\n\t\tau1x_pcm_queue_tx(pcd);\n\t}\n\n\treturn 0;\n}\n\nstatic int au1xpsc_pcm_trigger(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream, int cmd)\n{\n\tu32 c = to_dmadata(substream, component)->ddma_chan;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tau1xxx_dbdma_start(c);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tau1xxx_dbdma_stop(c);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nau1xpsc_pcm_pointer(struct snd_soc_component *component,\n\t\t    struct snd_pcm_substream *substream)\n{\n\treturn bytes_to_frames(substream->runtime,\n\t\t\t       to_dmadata(substream, component)->pos);\n}\n\nstatic int au1xpsc_pcm_open(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct au1xpsc_audio_dmadata *pcd = to_dmadata(substream, component);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tint stype = substream->stream, *dmaids;\n\n\tdmaids = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tif (!dmaids)\n\t\treturn -ENODEV;\t \n\n\tpcd->ddma_id = dmaids[stype];\n\n\tsnd_soc_set_runtime_hwparams(substream, &au1xpsc_pcm_hardware);\n\treturn 0;\n}\n\nstatic int au1xpsc_pcm_close(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tau1x_pcm_dbdma_free(to_dmadata(substream, component));\n\treturn 0;\n}\n\nstatic int au1xpsc_pcm_new(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\tcard->dev, AU1XPSC_BUFFER_MIN_BYTES, (4096 * 1024) - 1);\n\n\treturn 0;\n}\n\n \nstatic struct snd_soc_component_driver au1xpsc_soc_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= au1xpsc_pcm_open,\n\t.close\t\t= au1xpsc_pcm_close,\n\t.hw_params\t= au1xpsc_pcm_hw_params,\n\t.prepare\t= au1xpsc_pcm_prepare,\n\t.trigger\t= au1xpsc_pcm_trigger,\n\t.pointer\t= au1xpsc_pcm_pointer,\n\t.pcm_construct\t= au1xpsc_pcm_new,\n};\n\nstatic int au1xpsc_pcm_drvprobe(struct platform_device *pdev)\n{\n\tstruct au1xpsc_audio_dmadata *dmadata;\n\n\tdmadata = devm_kcalloc(&pdev->dev,\n\t\t\t       2, sizeof(struct au1xpsc_audio_dmadata),\n\t\t\t       GFP_KERNEL);\n\tif (!dmadata)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dmadata);\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t&au1xpsc_soc_component, NULL, 0);\n}\n\nstatic struct platform_driver au1xpsc_pcm_driver = {\n\t.driver\t= {\n\t\t.name\t= \"au1xpsc-pcm\",\n\t},\n\t.probe\t\t= au1xpsc_pcm_drvprobe,\n};\n\nmodule_platform_driver(au1xpsc_pcm_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Au12x0/Au1550 PSC Audio DMA driver\");\nMODULE_AUTHOR(\"Manuel Lauss\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}