{
  "module_name": "t9015.c",
  "hash_id": "d646e30fdaadab0582a5dff8cb751a992880c62ae06ebbd27f5684f29ba3bdbc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/t9015.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define BLOCK_EN\t0x00\n#define  LORN_EN\t0\n#define  LORP_EN\t1\n#define  LOLN_EN\t2\n#define  LOLP_EN\t3\n#define  DACR_EN\t4\n#define  DACL_EN\t5\n#define  DACR_INV\t20\n#define  DACL_INV\t21\n#define  DACR_SRC\t22\n#define  DACL_SRC\t23\n#define  REFP_BUF_EN\tBIT(12)\n#define  BIAS_CURRENT_EN BIT(13)\n#define  VMID_GEN_FAST\tBIT(14)\n#define  VMID_GEN_EN\tBIT(15)\n#define  I2S_MODE\tBIT(30)\n#define VOL_CTRL0\t0x04\n#define  GAIN_H\t\t31\n#define  GAIN_L\t\t23\n#define VOL_CTRL1\t0x08\n#define  DAC_MONO\t8\n#define  RAMP_RATE\t10\n#define  VC_RAMP_MODE\t12\n#define  MUTE_MODE\t13\n#define  UNMUTE_MODE\t14\n#define  DAC_SOFT_MUTE\t15\n#define  DACR_VC\t16\n#define  DACL_VC\t24\n#define LINEOUT_CFG\t0x0c\n#define  LORN_POL\t0\n#define  LORP_POL\t4\n#define  LOLN_POL\t8\n#define  LOLP_POL\t12\n#define POWER_CFG\t0x10\n\nstruct t9015 {\n\tstruct clk *pclk;\n\tstruct regulator *avdd;\n};\n\nstatic int t9015_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tval = I2S_MODE;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, BLOCK_EN, I2S_MODE, val);\n\n\tif (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S) &&\n\t    ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_LEFT_J))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops t9015_dai_ops = {\n\t.set_fmt = t9015_dai_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver t9015_dai = {\n\t.name = \"t9015-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = (SNDRV_PCM_FMTBIT_S8 |\n\t\t\t    SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S20_LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE),\n\t},\n\t.ops = &t9015_dai_ops,\n};\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(dac_vol_tlv, -9525, 0);\n\nstatic const char * const ramp_rate_txt[] = { \"Fast\", \"Slow\" };\nstatic SOC_ENUM_SINGLE_DECL(ramp_rate_enum, VOL_CTRL1, RAMP_RATE,\n\t\t\t    ramp_rate_txt);\n\nstatic const char * const dacr_in_txt[] = { \"Right\", \"Left\" };\nstatic SOC_ENUM_SINGLE_DECL(dacr_in_enum, BLOCK_EN, DACR_SRC, dacr_in_txt);\n\nstatic const char * const dacl_in_txt[] = { \"Left\", \"Right\" };\nstatic SOC_ENUM_SINGLE_DECL(dacl_in_enum, BLOCK_EN, DACL_SRC, dacl_in_txt);\n\nstatic const char * const mono_txt[] = { \"Stereo\", \"Mono\"};\nstatic SOC_ENUM_SINGLE_DECL(mono_enum, VOL_CTRL1, DAC_MONO, mono_txt);\n\nstatic const struct snd_kcontrol_new t9015_snd_controls[] = {\n\t \n\tSOC_ENUM(\"Playback Channel Mode\", mono_enum),\n\tSOC_SINGLE(\"Playback Switch\", VOL_CTRL1, DAC_SOFT_MUTE, 1, 1),\n\tSOC_DOUBLE_TLV(\"Playback Volume\", VOL_CTRL1, DACL_VC, DACR_VC,\n\t\t       0xff, 0, dac_vol_tlv),\n\n\t \n\tSOC_ENUM(\"Ramp Rate\", ramp_rate_enum),\n\tSOC_SINGLE(\"Volume Ramp Switch\", VOL_CTRL1, VC_RAMP_MODE, 1, 0),\n\tSOC_SINGLE(\"Mute Ramp Switch\", VOL_CTRL1, MUTE_MODE, 1, 0),\n\tSOC_SINGLE(\"Unmute Ramp Switch\", VOL_CTRL1, UNMUTE_MODE, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new t9015_right_dac_mux =\n\tSOC_DAPM_ENUM(\"Right DAC Source\", dacr_in_enum);\nstatic const struct snd_kcontrol_new t9015_left_dac_mux =\n\tSOC_DAPM_ENUM(\"Left DAC Source\", dacl_in_enum);\n\nstatic const struct snd_soc_dapm_widget t9015_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"Right IN\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Left IN\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"Right DAC Sel\", SND_SOC_NOPM, 0, 0,\n\t\t\t &t9015_right_dac_mux),\n\tSND_SOC_DAPM_MUX(\"Left DAC Sel\", SND_SOC_NOPM, 0, 0,\n\t\t\t &t9015_left_dac_mux),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", NULL, BLOCK_EN, DACR_EN, 0),\n\tSND_SOC_DAPM_DAC(\"Left DAC\",  NULL, BLOCK_EN, DACL_EN, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Right- Driver\", BLOCK_EN, LORN_EN, 0,\n\t\t\t NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Right+ Driver\", BLOCK_EN, LORP_EN, 0,\n\t\t\t NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Left- Driver\",  BLOCK_EN, LOLN_EN, 0,\n\t\t\t NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Left+ Driver\",  BLOCK_EN, LOLP_EN, 0,\n\t\t\t NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"LORN\"),\n\tSND_SOC_DAPM_OUTPUT(\"LORP\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOLN\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOLP\"),\n};\n\nstatic const struct snd_soc_dapm_route t9015_dapm_routes[] = {\n\t{ \"Right IN\", NULL, \"Playback\" },\n\t{ \"Left IN\",  NULL, \"Playback\" },\n\t{ \"Right DAC Sel\", \"Right\", \"Right IN\" },\n\t{ \"Right DAC Sel\", \"Left\",  \"Left IN\" },\n\t{ \"Left DAC Sel\",  \"Right\", \"Right IN\" },\n\t{ \"Left DAC Sel\",  \"Left\",  \"Left IN\" },\n\t{ \"Right DAC\", NULL, \"Right DAC Sel\" },\n\t{ \"Left DAC\",  NULL, \"Left DAC Sel\" },\n\t{ \"Right- Driver\", NULL, \"Right DAC\" },\n\t{ \"Right+ Driver\", NULL, \"Right DAC\" },\n\t{ \"Left- Driver\",  NULL, \"Left DAC\"  },\n\t{ \"Left+ Driver\",  NULL, \"Left DAC\"  },\n\t{ \"LORN\", NULL, \"Right- Driver\", },\n\t{ \"LORP\", NULL, \"Right+ Driver\", },\n\t{ \"LOLN\", NULL, \"Left- Driver\",  },\n\t{ \"LOLP\", NULL, \"Left+ Driver\",  },\n};\n\nstatic int t9015_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct t9015 *priv = snd_soc_component_get_drvdata(component);\n\tenum snd_soc_bias_level now =\n\t\tsnd_soc_component_get_bias_level(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tsnd_soc_component_update_bits(component, BLOCK_EN,\n\t\t\t\t\t      BIAS_CURRENT_EN,\n\t\t\t\t\t      BIAS_CURRENT_EN);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, BLOCK_EN,\n\t\t\t\t\t      BIAS_CURRENT_EN,\n\t\t\t\t\t      0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tret = regulator_enable(priv->avdd);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"AVDD enable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (now == SND_SOC_BIAS_OFF) {\n\t\t\tsnd_soc_component_update_bits(component, BLOCK_EN,\n\t\t\t\tVMID_GEN_EN | VMID_GEN_FAST | REFP_BUF_EN,\n\t\t\t\tVMID_GEN_EN | VMID_GEN_FAST | REFP_BUF_EN);\n\n\t\t\tmdelay(200);\n\t\t\tsnd_soc_component_update_bits(component, BLOCK_EN,\n\t\t\t\t\t\t      VMID_GEN_FAST,\n\t\t\t\t\t\t      0);\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, BLOCK_EN,\n\t\t\tVMID_GEN_EN | VMID_GEN_FAST | REFP_BUF_EN,\n\t\t\t0);\n\n\t\tregulator_disable(priv->avdd);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver t9015_codec_driver = {\n\t.set_bias_level\t\t= t9015_set_bias_level,\n\t.controls\t\t= t9015_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(t9015_snd_controls),\n\t.dapm_widgets\t\t= t9015_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(t9015_dapm_widgets),\n\t.dapm_routes\t\t= t9015_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(t9015_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config t9015_regmap_config = {\n\t.reg_bits\t\t= 32,\n\t.reg_stride\t\t= 4,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= POWER_CFG,\n};\n\nstatic int t9015_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct t9015 *priv;\n\tvoid __iomem *regs;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->pclk), \"failed to get core clock\\n\");\n\n\tpriv->avdd = devm_regulator_get(dev, \"AVDD\");\n\tif (IS_ERR(priv->avdd))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->avdd), \"failed to AVDD\\n\");\n\n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"core clock enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev,\n\t\t\t(void(*)(void *))clk_disable_unprepare,\n\t\t\tpriv->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = device_reset(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(dev, \"register map failed\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\n\tregmap = devm_regmap_init_mmio(dev, regs, &t9015_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\t \n\tregmap_write(regmap, LINEOUT_CFG, 0x1111);\n\n\treturn devm_snd_soc_register_component(dev, &t9015_codec_driver,\n\t\t\t\t\t       &t9015_dai, 1);\n}\n\nstatic const struct of_device_id t9015_ids[] __maybe_unused = {\n\t{ .compatible = \"amlogic,t9015\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, t9015_ids);\n\nstatic struct platform_driver t9015_driver = {\n\t.driver = {\n\t\t.name = \"t9015-codec\",\n\t\t.of_match_table = of_match_ptr(t9015_ids),\n\t},\n\t.probe = t9015_probe,\n};\n\nmodule_platform_driver(t9015_driver);\n\nMODULE_DESCRIPTION(\"ASoC Amlogic T9015 codec driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}