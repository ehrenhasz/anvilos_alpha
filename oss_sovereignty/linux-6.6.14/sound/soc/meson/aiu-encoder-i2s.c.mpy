{
  "module_name": "aiu-encoder-i2s.c",
  "hash_id": "bc8d3330b26459be212e44b9ecfff2ca12d54c9e1873fc03dba37ef4b729f32f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/aiu-encoder-i2s.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"aiu.h\"\n\n#define AIU_I2S_SOURCE_DESC_MODE_8CH\tBIT(0)\n#define AIU_I2S_SOURCE_DESC_MODE_24BIT\tBIT(5)\n#define AIU_I2S_SOURCE_DESC_MODE_32BIT\tBIT(9)\n#define AIU_I2S_SOURCE_DESC_MODE_SPLIT\tBIT(11)\n#define AIU_RST_SOFT_I2S_FAST\t\tBIT(0)\n\n#define AIU_I2S_DAC_CFG_MSB_FIRST\tBIT(2)\n#define AIU_CLK_CTRL_I2S_DIV_EN\t\tBIT(0)\n#define AIU_CLK_CTRL_I2S_DIV\t\tGENMASK(3, 2)\n#define AIU_CLK_CTRL_AOCLK_INVERT\tBIT(6)\n#define AIU_CLK_CTRL_LRCLK_INVERT\tBIT(7)\n#define AIU_CLK_CTRL_LRCLK_SKEW\t\tGENMASK(9, 8)\n#define AIU_CLK_CTRL_MORE_HDMI_AMCLK\tBIT(6)\n#define AIU_CLK_CTRL_MORE_I2S_DIV\tGENMASK(5, 0)\n#define AIU_CODEC_DAC_LRCLK_CTRL_DIV\tGENMASK(11, 0)\n\nstatic void aiu_encoder_i2s_divider_enable(struct snd_soc_component *component,\n\t\t\t\t\t   bool enable)\n{\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_I2S_DIV_EN,\n\t\t\t\t      enable ? AIU_CLK_CTRL_I2S_DIV_EN : 0);\n}\n\nstatic int aiu_encoder_i2s_setup_desc(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\t \n\tunsigned int desc = AIU_I2S_SOURCE_DESC_MODE_SPLIT;\n\n\t \n\tsnd_soc_component_write(component, AIU_RST_SOFT, AIU_RST_SOFT_I2S_FAST);\n\tsnd_soc_component_read(component, AIU_I2S_SYNC);\n\n\tswitch (params_physical_width(params)) {\n\tcase 16:  \n\t\tbreak;\n\n\tcase 32:\n\t\tdesc |= (AIU_I2S_SOURCE_DESC_MODE_24BIT |\n\t\t\t AIU_I2S_SOURCE_DESC_MODE_32BIT);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 2:  \n\t\tbreak;\n\tcase 8:\n\t\tdesc |= AIU_I2S_SOURCE_DESC_MODE_8CH;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIU_I2S_SOURCE_DESC,\n\t\t\t\t      AIU_I2S_SOURCE_DESC_MODE_8CH |\n\t\t\t\t      AIU_I2S_SOURCE_DESC_MODE_24BIT |\n\t\t\t\t      AIU_I2S_SOURCE_DESC_MODE_32BIT |\n\t\t\t\t      AIU_I2S_SOURCE_DESC_MODE_SPLIT,\n\t\t\t\t      desc);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_set_legacy_div(struct snd_soc_component *component,\n\t\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t\t  unsigned int bs)\n{\n\tswitch (bs) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported i2s divider: %u\\n\", bs);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_I2S_DIV,\n\t\t\t\t      FIELD_PREP(AIU_CLK_CTRL_I2S_DIV,\n\t\t\t\t\t\t __ffs(bs)));\n\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL_MORE,\n\t\t\t\t      AIU_CLK_CTRL_MORE_I2S_DIV,\n\t\t\t\t      FIELD_PREP(AIU_CLK_CTRL_MORE_I2S_DIV,\n\t\t\t\t\t\t 0));\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_set_more_div(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\t\tunsigned int bs)\n{\n\t \n\tif (params_width(params) == 16 && params_channels(params) == 8) {\n\t\tif (bs % 2) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Cannot increase i2s divider by 50%%\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbs += bs / 2;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_I2S_DIV,\n\t\t\t\t      FIELD_PREP(AIU_CLK_CTRL_I2S_DIV, 0));\n\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL_MORE,\n\t\t\t\t      AIU_CLK_CTRL_MORE_I2S_DIV,\n\t\t\t\t      FIELD_PREP(AIU_CLK_CTRL_MORE_I2S_DIV,\n\t\t\t\t\t\t bs - 1));\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_set_clocks(struct snd_soc_component *component,\n\t\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(component);\n\tunsigned int srate = params_rate(params);\n\tunsigned int fs, bs;\n\tint ret;\n\n\t \n\tfs = DIV_ROUND_CLOSEST(clk_get_rate(aiu->i2s.clks[MCLK].clk), srate);\n\n\tif (fs % 64)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_soc_component_update_bits(component, AIU_I2S_DAC_CFG,\n\t\t\t\t      AIU_I2S_DAC_CFG_MSB_FIRST,\n\t\t\t\t      AIU_I2S_DAC_CFG_MSB_FIRST);\n\n\t \n\tsnd_soc_component_update_bits(component, AIU_CODEC_DAC_LRCLK_CTRL,\n\t\t\t\t      AIU_CODEC_DAC_LRCLK_CTRL_DIV,\n\t\t\t\t      FIELD_PREP(AIU_CODEC_DAC_LRCLK_CTRL_DIV,\n\t\t\t\t\t\t 64 - 1));\n\n\tbs = fs / 64;\n\n\tif (aiu->platform->has_clk_ctrl_more_i2s_div)\n\t\tret = aiu_encoder_i2s_set_more_div(component, params, bs);\n\telse\n\t\tret = aiu_encoder_i2s_set_legacy_div(component, params, bs);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL_MORE,\n\t\t\t\t      AIU_CLK_CTRL_MORE_HDMI_AMCLK,\n\t\t\t\t      AIU_CLK_CTRL_MORE_HDMI_AMCLK);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint ret;\n\n\t \n\taiu_encoder_i2s_divider_enable(component, false);\n\n\tret = aiu_encoder_i2s_setup_desc(component, params);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting i2s desc failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = aiu_encoder_i2s_set_clocks(component, params);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting i2s clocks failed\\n\");\n\t\treturn ret;\n\t}\n\n\taiu_encoder_i2s_divider_enable(component, true);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\taiu_encoder_i2s_divider_enable(component, false);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int inv = fmt & SND_SOC_DAIFMT_INV_MASK;\n\tunsigned int val = 0;\n\tunsigned int skew;\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_BP_FP)\n\t\treturn -EINVAL;\n\n\tif (inv == SND_SOC_DAIFMT_NB_IF ||\n\t    inv == SND_SOC_DAIFMT_IB_IF)\n\t\tval |= AIU_CLK_CTRL_LRCLK_INVERT;\n\n\tif (inv == SND_SOC_DAIFMT_IB_NF ||\n\t    inv == SND_SOC_DAIFMT_IB_IF)\n\t\tval |= AIU_CLK_CTRL_AOCLK_INVERT;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tval ^= AIU_CLK_CTRL_LRCLK_INVERT;\n\t\tskew = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tskew = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval |= FIELD_PREP(AIU_CLK_CTRL_LRCLK_SKEW, skew);\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_LRCLK_INVERT |\n\t\t\t\t      AIU_CLK_CTRL_AOCLK_INVERT |\n\t\t\t\t      AIU_CLK_CTRL_LRCLK_SKEW,\n\t\t\t\t      val);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_i2s_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t      unsigned int freq, int dir)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\tif (WARN_ON(clk_id != 0))\n\t\treturn -EINVAL;\n\n\tif (dir == SND_SOC_CLOCK_IN)\n\t\treturn 0;\n\n\tret = clk_set_rate(aiu->i2s.clks[MCLK].clk, freq);\n\tif (ret)\n\t\tdev_err(dai->dev, \"Failed to set sysclk to %uHz\", freq);\n\n\treturn ret;\n}\n\nstatic const unsigned int hw_channels[] = {2, 8};\nstatic const struct snd_pcm_hw_constraint_list hw_channel_constraints = {\n\t.list = hw_channels,\n\t.count = ARRAY_SIZE(hw_channels),\n\t.mask = 0,\n};\n\nstatic int aiu_encoder_i2s_startup(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\t \n\tret = snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t &hw_channel_constraints);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"adding channels constraints failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(aiu->i2s.clk_num, aiu->i2s.clks);\n\tif (ret)\n\t\tdev_err(dai->dev, \"failed to enable i2s clocks\\n\");\n\n\treturn ret;\n}\n\nstatic void aiu_encoder_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(dai->component);\n\n\tclk_bulk_disable_unprepare(aiu->i2s.clk_num, aiu->i2s.clks);\n}\n\nconst struct snd_soc_dai_ops aiu_encoder_i2s_dai_ops = {\n\t.hw_params\t= aiu_encoder_i2s_hw_params,\n\t.hw_free\t= aiu_encoder_i2s_hw_free,\n\t.set_fmt\t= aiu_encoder_i2s_set_fmt,\n\t.set_sysclk\t= aiu_encoder_i2s_set_sysclk,\n\t.startup\t= aiu_encoder_i2s_startup,\n\t.shutdown\t= aiu_encoder_i2s_shutdown,\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}