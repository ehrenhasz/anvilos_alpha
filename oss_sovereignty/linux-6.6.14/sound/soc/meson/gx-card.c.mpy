{
  "module_name": "gx-card.c",
  "hash_id": "f161518fcc56528dfc46c9fff74550e2b0889f03df70fead897d03a123669440",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/gx-card.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"meson-card.h\"\n\nstruct gx_dai_link_i2s_data {\n\tunsigned int mclk_fs;\n};\n\n \nstatic const struct snd_soc_pcm_stream codec_params = {\n\t.formats = SNDRV_PCM_FMTBIT_S24_LE,\n\t.rate_min = 5525,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = 8,\n};\n\nstatic int gx_card_i2s_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct gx_dai_link_i2s_data *be =\n\t\t(struct gx_dai_link_i2s_data *)priv->link_data[rtd->num];\n\n\treturn meson_card_i2s_set_sysclk(substream, params, be->mclk_fs);\n}\n\nstatic const struct snd_soc_ops gx_card_i2s_be_ops = {\n\t.hw_params = gx_card_i2s_be_hw_params,\n};\n\nstatic int gx_card_parse_i2s(struct snd_soc_card *card,\n\t\t\t     struct device_node *node,\n\t\t\t     int *index)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *link = &card->dai_link[*index];\n\tstruct gx_dai_link_i2s_data *be;\n\n\t \n\tbe = devm_kzalloc(card->dev, sizeof(*be), GFP_KERNEL);\n\tif (!be)\n\t\treturn -ENOMEM;\n\tpriv->link_data[*index] = be;\n\n\t \n\tlink->ops = &gx_card_i2s_be_ops;\n\tlink->dai_fmt = meson_card_parse_daifmt(node, link->cpus->of_node);\n\n\tof_property_read_u32(node, \"mclk-fs\", &be->mclk_fs);\n\n\treturn 0;\n}\n\nstatic int gx_card_cpu_identify(struct snd_soc_dai_link_component *c,\n\t\t\t\tchar *match)\n{\n\tif (of_device_is_compatible(c->of_node, DT_PREFIX \"aiu\")) {\n\t\tif (strstr(c->dai_name, match))\n\t\t\treturn 1;\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int gx_card_add_link(struct snd_soc_card *card, struct device_node *np,\n\t\t\t    int *index)\n{\n\tstruct snd_soc_dai_link *dai_link = &card->dai_link[*index];\n\tstruct snd_soc_dai_link_component *cpu;\n\tint ret;\n\n\tcpu = devm_kzalloc(card->dev, sizeof(*cpu), GFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tdai_link->cpus = cpu;\n\tdai_link->num_cpus = 1;\n\n\tret = meson_card_parse_dai(card, np, dai_link->cpus);\n\tif (ret)\n\t\treturn ret;\n\n\tif (gx_card_cpu_identify(dai_link->cpus, \"FIFO\"))\n\t\treturn  meson_card_set_fe_link(card, dai_link, np, true);\n\n\tret = meson_card_set_be_link(card, dai_link, np);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (gx_card_cpu_identify(dai_link->cpus, \"CODEC CTRL\")) {\n\t\tdai_link->c2c_params = &codec_params;\n\t\tdai_link->num_c2c_params = 1;\n\t} else {\n\t\tdai_link->no_pcm = 1;\n\t\tsnd_soc_dai_link_set_capabilities(dai_link);\n\t\t \n\t\tif (gx_card_cpu_identify(dai_link->cpus, \"I2S Encoder\"))\n\t\t\tret = gx_card_parse_i2s(card, np, index);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct meson_card_match_data gx_card_match_data = {\n\t.add_link = gx_card_add_link,\n};\n\nstatic const struct of_device_id gx_card_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,gx-sound-card\",\n\t\t.data = &gx_card_match_data,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, gx_card_of_match);\n\nstatic struct platform_driver gx_card_pdrv = {\n\t.probe = meson_card_probe,\n\t.remove = meson_card_remove,\n\t.driver = {\n\t\t.name = \"gx-sound-card\",\n\t\t.of_match_table = gx_card_of_match,\n\t},\n};\nmodule_platform_driver(gx_card_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic GX ALSA machine driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}