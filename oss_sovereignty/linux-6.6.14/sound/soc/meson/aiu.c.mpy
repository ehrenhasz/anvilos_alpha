{
  "module_name": "aiu.c",
  "hash_id": "2efa9de7f2312dded70085ff799ff35d3be06839831aa9816733df23d7d71613",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/aiu.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/meson-aiu.h>\n#include \"aiu.h\"\n#include \"aiu-fifo.h\"\n\n#define AIU_I2S_MISC_958_SRC_SHIFT 3\n\nstatic const char * const aiu_spdif_encode_sel_texts[] = {\n\t\"SPDIF\", \"I2S\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(aiu_spdif_encode_sel_enum, AIU_I2S_MISC,\n\t\t\t    AIU_I2S_MISC_958_SRC_SHIFT,\n\t\t\t    aiu_spdif_encode_sel_texts);\n\nstatic const struct snd_kcontrol_new aiu_spdif_encode_mux =\n\tSOC_DAPM_ENUM(\"SPDIF Buffer Src\", aiu_spdif_encode_sel_enum);\n\nstatic const struct snd_soc_dapm_widget aiu_cpu_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"SPDIF SRC SEL\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aiu_spdif_encode_mux),\n};\n\nstatic const struct snd_soc_dapm_route aiu_cpu_dapm_routes[] = {\n\t{ \"I2S Encoder Playback\", NULL, \"I2S FIFO Playback\" },\n\t{ \"SPDIF SRC SEL\", \"SPDIF\", \"SPDIF FIFO Playback\" },\n\t{ \"SPDIF SRC SEL\", \"I2S\", \"I2S FIFO Playback\" },\n\t{ \"SPDIF Encoder Playback\", NULL, \"SPDIF SRC SEL\" },\n};\n\nint aiu_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t  const struct of_phandle_args *args,\n\t\t\t  const char **dai_name,\n\t\t\t  unsigned int component_id)\n{\n\tstruct snd_soc_dai *dai;\n\tint id;\n\n\tif (args->args_count != 2)\n\t\treturn -EINVAL;\n\n\tif (args->args[0] != component_id)\n\t\treturn -EINVAL;\n\n\tid = args->args[1];\n\n\tif (id < 0 || id >= component->num_dai)\n\t\treturn -EINVAL;\n\n\tfor_each_component_dais(component, dai) {\n\t\tif (id == 0)\n\t\t\tbreak;\n\t\tid--;\n\t}\n\n\t*dai_name = dai->driver->name;\n\n\treturn 0;\n}\n\nstatic int aiu_cpu_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t     const struct of_phandle_args *args,\n\t\t\t\t     const char **dai_name)\n{\n\treturn aiu_of_xlate_dai_name(component, args, dai_name, AIU_CPU);\n}\n\nstatic int aiu_cpu_component_probe(struct snd_soc_component *component)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(component);\n\n\t \n\treturn clk_prepare_enable(aiu->i2s.clks[PCLK].clk);\n}\n\nstatic void aiu_cpu_component_remove(struct snd_soc_component *component)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(component);\n\n\tclk_disable_unprepare(aiu->i2s.clks[PCLK].clk);\n}\n\nstatic const struct snd_soc_component_driver aiu_cpu_component = {\n\t.name\t\t\t= \"AIU CPU\",\n\t.dapm_widgets\t\t= aiu_cpu_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aiu_cpu_dapm_widgets),\n\t.dapm_routes\t\t= aiu_cpu_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aiu_cpu_dapm_routes),\n\t.of_xlate_dai_name\t= aiu_cpu_of_xlate_dai_name,\n\t.pointer\t\t= aiu_fifo_pointer,\n\t.probe\t\t\t= aiu_cpu_component_probe,\n\t.remove\t\t\t= aiu_cpu_component_remove,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_prefix\t\t= \"cpu\",\n#endif\n};\n\nstatic struct snd_soc_dai_driver aiu_cpu_dai_drv[] = {\n\t[CPU_I2S_FIFO] = {\n\t\t.name = \"I2S FIFO\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"I2S FIFO Playback\",\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 8,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min\t= 5512,\n\t\t\t.rate_max\t= 192000,\n\t\t\t.formats\t= AIU_FORMATS,\n\t\t},\n\t\t.ops\t\t= &aiu_fifo_i2s_dai_ops,\n\t},\n\t[CPU_SPDIF_FIFO] = {\n\t\t.name = \"SPDIF FIFO\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"SPDIF FIFO Playback\",\n\t\t\t.channels_min\t= 2,\n\t\t\t.channels_max\t= 2,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min\t= 5512,\n\t\t\t.rate_max\t= 192000,\n\t\t\t.formats\t= AIU_FORMATS,\n\t\t},\n\t\t.ops\t\t= &aiu_fifo_spdif_dai_ops,\n\t},\n\t[CPU_I2S_ENCODER] = {\n\t\t.name = \"I2S Encoder\",\n\t\t.playback = {\n\t\t\t.stream_name = \"I2S Encoder Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = AIU_FORMATS,\n\t\t},\n\t\t.ops = &aiu_encoder_i2s_dai_ops,\n\t},\n\t[CPU_SPDIF_ENCODER] = {\n\t\t.name = \"SPDIF Encoder\",\n\t\t.playback = {\n\t\t\t.stream_name = \"SPDIF Encoder Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = (SNDRV_PCM_RATE_32000  |\n\t\t\t\t  SNDRV_PCM_RATE_44100  |\n\t\t\t\t  SNDRV_PCM_RATE_48000  |\n\t\t\t\t  SNDRV_PCM_RATE_88200  |\n\t\t\t\t  SNDRV_PCM_RATE_96000  |\n\t\t\t\t  SNDRV_PCM_RATE_176400 |\n\t\t\t\t  SNDRV_PCM_RATE_192000),\n\t\t\t.formats = AIU_FORMATS,\n\t\t},\n\t\t.ops = &aiu_encoder_spdif_dai_ops,\n\t}\n};\n\nstatic const struct regmap_config aiu_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= 0x2ac,\n};\n\nstatic int aiu_clk_bulk_get(struct device *dev,\n\t\t\t    const char * const *ids,\n\t\t\t    unsigned int num,\n\t\t\t    struct aiu_interface *interface)\n{\n\tstruct clk_bulk_data *clks;\n\tint i, ret;\n\n\tclks = devm_kcalloc(dev, num, sizeof(*clks), GFP_KERNEL);\n\tif (!clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num; i++)\n\t\tclks[i].id = ids[i];\n\n\tret = devm_clk_bulk_get(dev, num, clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinterface->clks = clks;\n\tinterface->clk_num = num;\n\treturn 0;\n}\n\nstatic const char * const aiu_i2s_ids[] = {\n\t[PCLK]\t= \"i2s_pclk\",\n\t[AOCLK]\t= \"i2s_aoclk\",\n\t[MCLK]\t= \"i2s_mclk\",\n\t[MIXER]\t= \"i2s_mixer\",\n};\n\nstatic const char * const aiu_spdif_ids[] = {\n\t[PCLK]\t= \"spdif_pclk\",\n\t[AOCLK]\t= \"spdif_aoclk\",\n\t[MCLK]\t= \"spdif_mclk_sel\"\n};\n\nstatic int aiu_clk_get(struct device *dev)\n{\n\tstruct aiu *aiu = dev_get_drvdata(dev);\n\tint ret;\n\n\taiu->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(aiu->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(aiu->pclk), \"Can't get the aiu pclk\\n\");\n\n\taiu->spdif_mclk = devm_clk_get(dev, \"spdif_mclk\");\n\tif (IS_ERR(aiu->spdif_mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(aiu->spdif_mclk),\n\t\t\t\t     \"Can't get the aiu spdif master clock\\n\");\n\n\tret = aiu_clk_bulk_get(dev, aiu_i2s_ids, ARRAY_SIZE(aiu_i2s_ids),\n\t\t\t       &aiu->i2s);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Can't get the i2s clocks\\n\");\n\n\tret = aiu_clk_bulk_get(dev, aiu_spdif_ids, ARRAY_SIZE(aiu_spdif_ids),\n\t\t\t       &aiu->spdif);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Can't get the spdif clocks\\n\");\n\n\tret = clk_prepare_enable(aiu->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"peripheral clock enable failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev,\n\t\t\t\t       (void(*)(void *))clk_disable_unprepare,\n\t\t\t\t       aiu->pclk);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add reset action on pclk\");\n\n\treturn ret;\n}\n\nstatic int aiu_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\tstruct aiu *aiu;\n\tint ret;\n\n\taiu = devm_kzalloc(dev, sizeof(*aiu), GFP_KERNEL);\n\tif (!aiu)\n\t\treturn -ENOMEM;\n\n\taiu->platform = device_get_match_data(dev);\n\tif (!aiu->platform)\n\t\treturn -ENODEV;\n\n\tplatform_set_drvdata(pdev, aiu);\n\n\tret = device_reset(dev);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to reset device\\n\");\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tmap = devm_regmap_init_mmio(dev, regs, &aiu_regmap_cfg);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(map));\n\t\treturn PTR_ERR(map);\n\t}\n\n\taiu->i2s.irq = platform_get_irq_byname(pdev, \"i2s\");\n\tif (aiu->i2s.irq < 0)\n\t\treturn aiu->i2s.irq;\n\n\taiu->spdif.irq = platform_get_irq_byname(pdev, \"spdif\");\n\tif (aiu->spdif.irq < 0)\n\t\treturn aiu->spdif.irq;\n\n\tret = aiu_clk_get(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_register_component(dev, &aiu_cpu_component,\n\t\t\t\t\t aiu_cpu_dai_drv,\n\t\t\t\t\t ARRAY_SIZE(aiu_cpu_dai_drv));\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register cpu component\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = aiu_hdmi_ctrl_register_component(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register hdmi control component\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (aiu->platform->has_acodec) {\n\t\tret = aiu_acodec_ctrl_register_component(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t    \"Failed to register acodec control component\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tsnd_soc_unregister_component(dev);\n\treturn ret;\n}\n\nstatic void aiu_remove(struct platform_device *pdev)\n{\n\tsnd_soc_unregister_component(&pdev->dev);\n}\n\nstatic const struct aiu_platform_data aiu_gxbb_pdata = {\n\t.has_acodec = false,\n\t.has_clk_ctrl_more_i2s_div = true,\n};\n\nstatic const struct aiu_platform_data aiu_gxl_pdata = {\n\t.has_acodec = true,\n\t.has_clk_ctrl_more_i2s_div = true,\n};\n\nstatic const struct aiu_platform_data aiu_meson8_pdata = {\n\t.has_acodec = false,\n\t.has_clk_ctrl_more_i2s_div = false,\n};\n\nstatic const struct of_device_id aiu_of_match[] = {\n\t{ .compatible = \"amlogic,aiu-gxbb\", .data = &aiu_gxbb_pdata },\n\t{ .compatible = \"amlogic,aiu-gxl\", .data = &aiu_gxl_pdata },\n\t{ .compatible = \"amlogic,aiu-meson8\", .data = &aiu_meson8_pdata },\n\t{ .compatible = \"amlogic,aiu-meson8b\", .data = &aiu_meson8_pdata },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, aiu_of_match);\n\nstatic struct platform_driver aiu_pdrv = {\n\t.probe = aiu_probe,\n\t.remove_new = aiu_remove,\n\t.driver = {\n\t\t.name = \"meson-aiu\",\n\t\t.of_match_table = aiu_of_match,\n\t},\n};\nmodule_platform_driver(aiu_pdrv);\n\nMODULE_DESCRIPTION(\"Meson AIU Driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}