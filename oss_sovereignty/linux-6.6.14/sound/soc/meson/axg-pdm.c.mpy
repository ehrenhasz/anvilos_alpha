{
  "module_name": "axg-pdm.c",
  "hash_id": "b65b8e812ae46692f9ab2b012f74562a61550f8a8085313c9aa661f787914d19",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-pdm.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/pcm_params.h>\n\n#define PDM_CTRL\t\t\t0x00\n#define  PDM_CTRL_EN\t\t\tBIT(31)\n#define  PDM_CTRL_OUT_MODE\t\tBIT(29)\n#define  PDM_CTRL_BYPASS_MODE\t\tBIT(28)\n#define  PDM_CTRL_RST_FIFO\t\tBIT(16)\n#define  PDM_CTRL_CHAN_RSTN_MASK\tGENMASK(15, 8)\n#define  PDM_CTRL_CHAN_RSTN(x)\t\t((x) << 8)\n#define  PDM_CTRL_CHAN_EN_MASK\t\tGENMASK(7, 0)\n#define  PDM_CTRL_CHAN_EN(x)\t\t((x) << 0)\n#define PDM_HCIC_CTRL1\t\t\t0x04\n#define  PDM_FILTER_EN\t\t\tBIT(31)\n#define  PDM_HCIC_CTRL1_GAIN_SFT_MASK\tGENMASK(29, 24)\n#define  PDM_HCIC_CTRL1_GAIN_SFT(x)\t((x) << 24)\n#define  PDM_HCIC_CTRL1_GAIN_MULT_MASK\tGENMASK(23, 16)\n#define  PDM_HCIC_CTRL1_GAIN_MULT(x)\t((x) << 16)\n#define  PDM_HCIC_CTRL1_DSR_MASK\tGENMASK(8, 4)\n#define  PDM_HCIC_CTRL1_DSR(x)\t\t((x) << 4)\n#define  PDM_HCIC_CTRL1_STAGE_NUM_MASK\tGENMASK(3, 0)\n#define  PDM_HCIC_CTRL1_STAGE_NUM(x)\t((x) << 0)\n#define PDM_HCIC_CTRL2\t\t\t0x08\n#define PDM_F1_CTRL\t\t\t0x0c\n#define  PDM_LPF_ROUND_MODE_MASK\tGENMASK(17, 16)\n#define  PDM_LPF_ROUND_MODE(x)\t\t((x) << 16)\n#define  PDM_LPF_DSR_MASK\t\tGENMASK(15, 12)\n#define  PDM_LPF_DSR(x)\t\t\t((x) << 12)\n#define  PDM_LPF_STAGE_NUM_MASK\t\tGENMASK(8, 0)\n#define  PDM_LPF_STAGE_NUM(x)\t\t((x) << 0)\n#define  PDM_LPF_MAX_STAGE\t\t336\n#define  PDM_LPF_NUM\t\t\t3\n#define PDM_F2_CTRL\t\t\t0x10\n#define PDM_F3_CTRL\t\t\t0x14\n#define PDM_HPF_CTRL\t\t\t0x18\n#define  PDM_HPF_SFT_STEPS_MASK\t\tGENMASK(20, 16)\n#define  PDM_HPF_SFT_STEPS(x)\t\t((x) << 16)\n#define  PDM_HPF_OUT_FACTOR_MASK\tGENMASK(15, 0)\n#define  PDM_HPF_OUT_FACTOR(x)\t\t((x) << 0)\n#define PDM_CHAN_CTRL\t\t\t0x1c\n#define  PDM_CHAN_CTRL_POINTER_WIDTH\t8\n#define  PDM_CHAN_CTRL_POINTER_MAX\t((1 << PDM_CHAN_CTRL_POINTER_WIDTH) - 1)\n#define  PDM_CHAN_CTRL_NUM\t\t4\n#define PDM_CHAN_CTRL1\t\t\t0x20\n#define PDM_COEFF_ADDR\t\t\t0x24\n#define PDM_COEFF_DATA\t\t\t0x28\n#define PDM_CLKG_CTRL\t\t\t0x2c\n#define PDM_STS\t\t\t\t0x30\n\nstruct axg_pdm_lpf {\n\tunsigned int ds;\n\tunsigned int round_mode;\n\tconst unsigned int *tap;\n\tunsigned int tap_num;\n};\n\nstruct axg_pdm_hcic {\n\tunsigned int shift;\n\tunsigned int mult;\n\tunsigned int steps;\n\tunsigned int ds;\n};\n\nstruct axg_pdm_hpf {\n\tunsigned int out_factor;\n\tunsigned int steps;\n};\n\nstruct axg_pdm_filters {\n\tstruct axg_pdm_hcic hcic;\n\tstruct axg_pdm_hpf hpf;\n\tstruct axg_pdm_lpf lpf[PDM_LPF_NUM];\n};\n\nstruct axg_pdm_cfg {\n\tconst struct axg_pdm_filters *filters;\n\tunsigned int sys_rate;\n};\n\nstruct axg_pdm {\n\tconst struct axg_pdm_cfg *cfg;\n\tstruct regmap *map;\n\tstruct clk *dclk;\n\tstruct clk *sysclk;\n\tstruct clk *pclk;\n};\n\nstatic void axg_pdm_enable(struct regmap *map)\n{\n\t \n\tregmap_update_bits(map, PDM_CTRL, PDM_CTRL_RST_FIFO, PDM_CTRL_RST_FIFO);\n\tregmap_update_bits(map, PDM_CTRL, PDM_CTRL_RST_FIFO, 0);\n\n\t \n\tregmap_update_bits(map, PDM_CTRL, PDM_CTRL_EN, PDM_CTRL_EN);\n}\n\nstatic void axg_pdm_disable(struct regmap *map)\n{\n\tregmap_update_bits(map, PDM_CTRL, PDM_CTRL_EN, 0);\n}\n\nstatic void axg_pdm_filters_enable(struct regmap *map, bool enable)\n{\n\tunsigned int val = enable ? PDM_FILTER_EN : 0;\n\n\tregmap_update_bits(map, PDM_HCIC_CTRL1, PDM_FILTER_EN, val);\n\tregmap_update_bits(map, PDM_F1_CTRL, PDM_FILTER_EN, val);\n\tregmap_update_bits(map, PDM_F2_CTRL, PDM_FILTER_EN, val);\n\tregmap_update_bits(map, PDM_F3_CTRL, PDM_FILTER_EN, val);\n\tregmap_update_bits(map, PDM_HPF_CTRL, PDM_FILTER_EN, val);\n}\n\nstatic int axg_pdm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\taxg_pdm_enable(priv->map);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\taxg_pdm_disable(priv->map);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic unsigned int axg_pdm_get_os(struct axg_pdm *priv)\n{\n\tconst struct axg_pdm_filters *filters = priv->cfg->filters;\n\tunsigned int os = filters->hcic.ds;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < PDM_LPF_NUM; i++)\n\t\tos *= filters->lpf[i].ds;\n\n\treturn os;\n}\n\nstatic int axg_pdm_set_sysclk(struct axg_pdm *priv, unsigned int os,\n\t\t\t      unsigned int rate)\n{\n\tunsigned int sys_rate = os * 2 * rate * PDM_CHAN_CTRL_POINTER_MAX;\n\n\t \n\tif (sys_rate < priv->cfg->sys_rate)\n\t\treturn clk_set_rate(priv->sysclk, sys_rate);\n\n\treturn clk_set_rate(priv->sysclk, priv->cfg->sys_rate);\n}\n\nstatic int axg_pdm_set_sample_pointer(struct axg_pdm *priv)\n{\n\tunsigned int spmax, sp, val;\n\tint i;\n\n\t \n\tspmax = DIV_ROUND_UP_ULL((u64)clk_get_rate(priv->sysclk),\n\t\t\t\t clk_get_rate(priv->dclk) * 2);\n\n\t \n\tif (WARN_ON(spmax > PDM_CHAN_CTRL_POINTER_MAX))\n\t\treturn -EINVAL;\n\n\t \n\tsp = spmax * 3 / 4;\n\n\tfor (i = 0, val = 0; i < PDM_CHAN_CTRL_NUM; i++)\n\t\tval |= sp << (PDM_CHAN_CTRL_POINTER_WIDTH * i);\n\n\tregmap_write(priv->map, PDM_CHAN_CTRL, val);\n\tregmap_write(priv->map, PDM_CHAN_CTRL1, val);\n\n\treturn 0;\n}\n\nstatic void axg_pdm_set_channel_mask(struct axg_pdm *priv,\n\t\t\t\t     unsigned int channels)\n{\n\tunsigned int mask = GENMASK(channels - 1, 0);\n\n\t \n\tregmap_update_bits(priv->map, PDM_CTRL,\n\t\t\t   PDM_CTRL_CHAN_RSTN_MASK, 0);\n\n\t \n\tregmap_update_bits(priv->map, PDM_CTRL,\n\t\t\t   PDM_CTRL_CHAN_RSTN_MASK |\n\t\t\t   PDM_CTRL_CHAN_EN_MASK,\n\t\t\t   PDM_CTRL_CHAN_RSTN(mask) |\n\t\t\t   PDM_CTRL_CHAN_EN(mask));\n}\n\nstatic int axg_pdm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int os = axg_pdm_get_os(priv);\n\tunsigned int rate = params_rate(params);\n\tunsigned int val;\n\tint ret;\n\n\tswitch (params_width(params)) {\n\tcase 24:\n\t\tval = PDM_CTRL_OUT_MODE;\n\t\tbreak;\n\tcase 32:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"unsupported sample width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(priv->map, PDM_CTRL, PDM_CTRL_OUT_MODE, val);\n\n\tret = axg_pdm_set_sysclk(priv, os, rate);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to set system clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_set_rate(priv->dclk, rate * os);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to set dclk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axg_pdm_set_sample_pointer(priv);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"invalid clock setting\\n\");\n\t\treturn ret;\n\t}\n\n\taxg_pdm_set_channel_mask(priv, params_channels(params));\n\n\treturn 0;\n}\n\nstatic int axg_pdm_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->dclk);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"enabling dclk failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\taxg_pdm_filters_enable(priv->map, true);\n\n\treturn ret;\n}\n\nstatic void axg_pdm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\n\taxg_pdm_filters_enable(priv->map, false);\n\tclk_disable_unprepare(priv->dclk);\n}\n\nstatic void axg_pdm_set_hcic_ctrl(struct axg_pdm *priv)\n{\n\tconst struct axg_pdm_hcic *hcic = &priv->cfg->filters->hcic;\n\tunsigned int val;\n\n\tval = PDM_HCIC_CTRL1_STAGE_NUM(hcic->steps);\n\tval |= PDM_HCIC_CTRL1_DSR(hcic->ds);\n\tval |= PDM_HCIC_CTRL1_GAIN_MULT(hcic->mult);\n\tval |= PDM_HCIC_CTRL1_GAIN_SFT(hcic->shift);\n\n\tregmap_update_bits(priv->map, PDM_HCIC_CTRL1,\n\t\t\t   PDM_HCIC_CTRL1_STAGE_NUM_MASK |\n\t\t\t   PDM_HCIC_CTRL1_DSR_MASK |\n\t\t\t   PDM_HCIC_CTRL1_GAIN_MULT_MASK |\n\t\t\t   PDM_HCIC_CTRL1_GAIN_SFT_MASK,\n\t\t\t   val);\n}\n\nstatic void axg_pdm_set_lpf_ctrl(struct axg_pdm *priv, unsigned int index)\n{\n\tconst struct axg_pdm_lpf *lpf = &priv->cfg->filters->lpf[index];\n\tunsigned int offset = index * regmap_get_reg_stride(priv->map)\n\t\t+ PDM_F1_CTRL;\n\tunsigned int val;\n\n\tval = PDM_LPF_STAGE_NUM(lpf->tap_num);\n\tval |= PDM_LPF_DSR(lpf->ds);\n\tval |= PDM_LPF_ROUND_MODE(lpf->round_mode);\n\n\tregmap_update_bits(priv->map, offset,\n\t\t\t   PDM_LPF_STAGE_NUM_MASK |\n\t\t\t   PDM_LPF_DSR_MASK |\n\t\t\t   PDM_LPF_ROUND_MODE_MASK,\n\t\t\t   val);\n}\n\nstatic void axg_pdm_set_hpf_ctrl(struct axg_pdm *priv)\n{\n\tconst struct axg_pdm_hpf *hpf = &priv->cfg->filters->hpf;\n\tunsigned int val;\n\n\tval = PDM_HPF_OUT_FACTOR(hpf->out_factor);\n\tval |= PDM_HPF_SFT_STEPS(hpf->steps);\n\n\tregmap_update_bits(priv->map, PDM_HPF_CTRL,\n\t\t\t   PDM_HPF_OUT_FACTOR_MASK |\n\t\t\t   PDM_HPF_SFT_STEPS_MASK,\n\t\t\t   val);\n}\n\nstatic int axg_pdm_set_lpf_filters(struct axg_pdm *priv)\n{\n\tconst struct axg_pdm_lpf *lpf = priv->cfg->filters->lpf;\n\tunsigned int count = 0;\n\tint i, j;\n\n\tfor (i = 0; i < PDM_LPF_NUM; i++)\n\t\tcount += lpf[i].tap_num;\n\n\t \n\tif (count >= PDM_LPF_MAX_STAGE)\n\t\treturn -EINVAL;\n\n\t \n\tregmap_write(priv->map, PDM_COEFF_ADDR, 0);\n\n\t \n\tfor (i = 0; i < PDM_LPF_NUM; i++) {\n\t\taxg_pdm_set_lpf_ctrl(priv, i);\n\n\t\tfor (j = 0; j < lpf[i].tap_num; j++)\n\t\t\tregmap_write(priv->map, PDM_COEFF_DATA, lpf[i].tap[j]);\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_pdm_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"enabling pclk failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_set_rate(priv->sysclk, priv->cfg->sys_rate);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting sysclk failed\\n\");\n\t\tgoto err_pclk;\n\t}\n\n\tret = clk_prepare_enable(priv->sysclk);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"enabling sysclk failed\\n\");\n\t\tgoto err_pclk;\n\t}\n\n\t \n\taxg_pdm_disable(priv->map);\n\n\t \n\tregmap_update_bits(priv->map, PDM_CTRL, PDM_CTRL_BYPASS_MODE, 0);\n\n\t \n\taxg_pdm_set_hcic_ctrl(priv);\n\taxg_pdm_set_hpf_ctrl(priv);\n\n\tret = axg_pdm_set_lpf_filters(priv);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"invalid filter configuration\\n\");\n\t\tgoto err_sysclk;\n\t}\n\n\treturn 0;\n\nerr_sysclk:\n\tclk_disable_unprepare(priv->sysclk);\nerr_pclk:\n\tclk_disable_unprepare(priv->pclk);\n\treturn ret;\n}\n\nstatic int axg_pdm_dai_remove(struct snd_soc_dai *dai)\n{\n\tstruct axg_pdm *priv = snd_soc_dai_get_drvdata(dai);\n\n\tclk_disable_unprepare(priv->sysclk);\n\tclk_disable_unprepare(priv->pclk);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops axg_pdm_dai_ops = {\n\t.probe\t\t= axg_pdm_dai_probe,\n\t.remove\t\t= axg_pdm_dai_remove,\n\t.trigger\t= axg_pdm_trigger,\n\t.hw_params\t= axg_pdm_hw_params,\n\t.startup\t= axg_pdm_startup,\n\t.shutdown\t= axg_pdm_shutdown,\n};\n\nstatic struct snd_soc_dai_driver axg_pdm_dai_drv = {\n\t.name = \"PDM\",\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 8,\n\t\t.rates\t\t= SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min\t= 5512,\n\t\t.rate_max\t= 48000,\n\t\t.formats\t= (SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE),\n\t},\n\t.ops\t\t= &axg_pdm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver axg_pdm_component_drv = {\n\t.legacy_dai_naming = 1,\n};\n\nstatic const struct regmap_config axg_pdm_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= PDM_STS,\n};\n\nstatic const unsigned int lpf1_default_tap[] = {\n\t0x000014, 0xffffb2, 0xfffed9, 0xfffdce, 0xfffd45,\n\t0xfffe32, 0x000147, 0x000645, 0x000b86, 0x000e21,\n\t0x000ae3, 0x000000, 0xffeece, 0xffdca8, 0xffd212,\n\t0xffd7d1, 0xfff2a7, 0x001f4c, 0x0050c2, 0x0072aa,\n\t0x006ff1, 0x003c32, 0xffdc4e, 0xff6a18, 0xff0fef,\n\t0xfefbaf, 0xff4c40, 0x000000, 0x00ebc8, 0x01c077,\n\t0x02209e, 0x01c1a4, 0x008e60, 0xfebe52, 0xfcd690,\n\t0xfb8fa5, 0xfba498, 0xfd9812, 0x0181ce, 0x06f5f3,\n\t0x0d112f, 0x12a958, 0x169686, 0x18000e, 0x169686,\n\t0x12a958, 0x0d112f, 0x06f5f3, 0x0181ce, 0xfd9812,\n\t0xfba498, 0xfb8fa5, 0xfcd690, 0xfebe52, 0x008e60,\n\t0x01c1a4, 0x02209e, 0x01c077, 0x00ebc8, 0x000000,\n\t0xff4c40, 0xfefbaf, 0xff0fef, 0xff6a18, 0xffdc4e,\n\t0x003c32, 0x006ff1, 0x0072aa, 0x0050c2, 0x001f4c,\n\t0xfff2a7, 0xffd7d1, 0xffd212, 0xffdca8, 0xffeece,\n\t0x000000, 0x000ae3, 0x000e21, 0x000b86, 0x000645,\n\t0x000147, 0xfffe32, 0xfffd45, 0xfffdce, 0xfffed9,\n\t0xffffb2, 0x000014,\n};\n\nstatic const unsigned int lpf2_default_tap[] = {\n\t0x00050a, 0xfff004, 0x0002c1, 0x003c12, 0xffa818,\n\t0xffc87d, 0x010aef, 0xff5223, 0xfebd93, 0x028f41,\n\t0xff5c0e, 0xfc63f8, 0x055f81, 0x000000, 0xf478a0,\n\t0x11c5e3, 0x2ea74d, 0x11c5e3, 0xf478a0, 0x000000,\n\t0x055f81, 0xfc63f8, 0xff5c0e, 0x028f41, 0xfebd93,\n\t0xff5223, 0x010aef, 0xffc87d, 0xffa818, 0x003c12,\n\t0x0002c1, 0xfff004, 0x00050a,\n};\n\nstatic const unsigned int lpf3_default_tap[] = {\n\t0x000000, 0x000081, 0x000000, 0xfffedb, 0x000000,\n\t0x00022d, 0x000000, 0xfffc46, 0x000000, 0x0005f7,\n\t0x000000, 0xfff6eb, 0x000000, 0x000d4e, 0x000000,\n\t0xffed1e, 0x000000, 0x001a1c, 0x000000, 0xffdcb0,\n\t0x000000, 0x002ede, 0x000000, 0xffc2d1, 0x000000,\n\t0x004ebe, 0x000000, 0xff9beb, 0x000000, 0x007dd7,\n\t0x000000, 0xff633a, 0x000000, 0x00c1d2, 0x000000,\n\t0xff11d5, 0x000000, 0x012368, 0x000000, 0xfe9c45,\n\t0x000000, 0x01b252, 0x000000, 0xfdebf6, 0x000000,\n\t0x0290b8, 0x000000, 0xfcca0d, 0x000000, 0x041d7c,\n\t0x000000, 0xfa8152, 0x000000, 0x07e9c6, 0x000000,\n\t0xf28fb5, 0x000000, 0x28b216, 0x3fffde, 0x28b216,\n\t0x000000, 0xf28fb5, 0x000000, 0x07e9c6, 0x000000,\n\t0xfa8152, 0x000000, 0x041d7c, 0x000000, 0xfcca0d,\n\t0x000000, 0x0290b8, 0x000000, 0xfdebf6, 0x000000,\n\t0x01b252, 0x000000, 0xfe9c45, 0x000000, 0x012368,\n\t0x000000, 0xff11d5, 0x000000, 0x00c1d2, 0x000000,\n\t0xff633a, 0x000000, 0x007dd7, 0x000000, 0xff9beb,\n\t0x000000, 0x004ebe, 0x000000, 0xffc2d1, 0x000000,\n\t0x002ede, 0x000000, 0xffdcb0, 0x000000, 0x001a1c,\n\t0x000000, 0xffed1e, 0x000000, 0x000d4e, 0x000000,\n\t0xfff6eb, 0x000000, 0x0005f7, 0x000000, 0xfffc46,\n\t0x000000, 0x00022d, 0x000000, 0xfffedb, 0x000000,\n\t0x000081, 0x000000,\n};\n\n \nstatic const struct axg_pdm_filters axg_default_filters = {\n\t.hcic = {\n\t\t.shift = 0x15,\n\t\t.mult = 0x80,\n\t\t.steps = 7,\n\t\t.ds = 8,\n\t},\n\t.hpf = {\n\t\t.out_factor = 0x8000,\n\t\t.steps = 13,\n\t},\n\t.lpf = {\n\t\t[0] = {\n\t\t\t.ds = 2,\n\t\t\t.round_mode = 1,\n\t\t\t.tap = lpf1_default_tap,\n\t\t\t.tap_num = ARRAY_SIZE(lpf1_default_tap),\n\t\t},\n\t\t[1] = {\n\t\t\t.ds = 2,\n\t\t\t.round_mode = 0,\n\t\t\t.tap = lpf2_default_tap,\n\t\t\t.tap_num = ARRAY_SIZE(lpf2_default_tap),\n\t\t},\n\t\t[2] = {\n\t\t\t.ds = 2,\n\t\t\t.round_mode = 1,\n\t\t\t.tap = lpf3_default_tap,\n\t\t\t.tap_num = ARRAY_SIZE(lpf3_default_tap)\n\t\t},\n\t},\n};\n\nstatic const struct axg_pdm_cfg axg_pdm_config = {\n\t.filters = &axg_default_filters,\n\t.sys_rate = 250000000,\n};\n\nstatic const struct of_device_id axg_pdm_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-pdm\",\n\t\t.data = &axg_pdm_config,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_pdm_of_match);\n\nstatic int axg_pdm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct axg_pdm *priv;\n\tvoid __iomem *regs;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->cfg = of_device_get_match_data(dev);\n\tif (!priv->cfg) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->map = devm_regmap_init_mmio(dev, regs, &axg_pdm_regmap_cfg);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(priv->map));\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tpriv->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->pclk), \"failed to get pclk\\n\");\n\n\tpriv->dclk = devm_clk_get(dev, \"dclk\");\n\tif (IS_ERR(priv->dclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->dclk), \"failed to get dclk\\n\");\n\n\tpriv->sysclk = devm_clk_get(dev, \"sysclk\");\n\tif (IS_ERR(priv->sysclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->sysclk), \"failed to get dclk\\n\");\n\n\treturn devm_snd_soc_register_component(dev, &axg_pdm_component_drv,\n\t\t\t\t\t       &axg_pdm_dai_drv, 1);\n}\n\nstatic struct platform_driver axg_pdm_pdrv = {\n\t.probe = axg_pdm_probe,\n\t.driver = {\n\t\t.name = \"axg-pdm\",\n\t\t.of_match_table = axg_pdm_of_match,\n\t},\n};\nmodule_platform_driver(axg_pdm_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG PDM Input driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}