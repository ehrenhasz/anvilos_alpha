{
  "module_name": "axg-tdmin.c",
  "hash_id": "90ca49c3ec7cd3ae1fbf38d7a870f8e67ad5d914141a665e6c576d3f48e83972",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-tdmin.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-tdm-formatter.h\"\n\n#define TDMIN_CTRL\t\t\t0x00\n#define  TDMIN_CTRL_ENABLE\t\tBIT(31)\n#define  TDMIN_CTRL_I2S_MODE\t\tBIT(30)\n#define  TDMIN_CTRL_RST_OUT\t\tBIT(29)\n#define  TDMIN_CTRL_RST_IN\t\tBIT(28)\n#define  TDMIN_CTRL_WS_INV\t\tBIT(25)\n#define  TDMIN_CTRL_SEL_SHIFT\t\t20\n#define  TDMIN_CTRL_IN_BIT_SKEW_MASK\tGENMASK(18, 16)\n#define  TDMIN_CTRL_IN_BIT_SKEW(x)\t((x) << 16)\n#define  TDMIN_CTRL_LSB_FIRST\t\tBIT(5)\n#define  TDMIN_CTRL_BITNUM_MASK\tGENMASK(4, 0)\n#define  TDMIN_CTRL_BITNUM(x)\t\t((x) << 0)\n#define TDMIN_SWAP\t\t\t0x04\n#define TDMIN_MASK0\t\t\t0x08\n#define TDMIN_MASK1\t\t\t0x0c\n#define TDMIN_MASK2\t\t\t0x10\n#define TDMIN_MASK3\t\t\t0x14\n#define TDMIN_STAT\t\t\t0x18\n#define TDMIN_MUTE_VAL\t\t\t0x1c\n#define TDMIN_MUTE0\t\t\t0x20\n#define TDMIN_MUTE1\t\t\t0x24\n#define TDMIN_MUTE2\t\t\t0x28\n#define TDMIN_MUTE3\t\t\t0x2c\n\nstatic const struct regmap_config axg_tdmin_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= TDMIN_MUTE3,\n};\n\nstatic const char * const axg_tdmin_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\",  \"IN 3\",  \"IN 4\",  \"IN 5\",  \"IN 6\",  \"IN 7\",\n\t\"IN 8\", \"IN 9\", \"IN 10\", \"IN 11\", \"IN 12\", \"IN 13\", \"IN 14\", \"IN 15\",\n};\n\n \nstatic SOC_ENUM_SINGLE_DECL(axg_tdmin_sel_enum, TDMIN_CTRL,\n\t\t\t    TDMIN_CTRL_SEL_SHIFT, axg_tdmin_sel_texts);\n\nstatic const struct snd_kcontrol_new axg_tdmin_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", axg_tdmin_sel_enum);\n\nstatic struct snd_soc_dai *\naxg_tdmin_get_be(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct snd_soc_dai *be;\n\n\tsnd_soc_dapm_widget_for_each_source_path(w, p) {\n\t\tif (!p->connect)\n\t\t\tcontinue;\n\n\t\tif (p->source->id == snd_soc_dapm_dai_out)\n\t\t\treturn (struct snd_soc_dai *)p->source->priv;\n\n\t\tbe = axg_tdmin_get_be(p->source);\n\t\tif (be)\n\t\t\treturn be;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct axg_tdm_stream *\naxg_tdmin_get_tdm_stream(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dai *be = axg_tdmin_get_be(w);\n\n\tif (!be)\n\t\treturn NULL;\n\n\treturn snd_soc_dai_dma_data_get_capture(be);\n}\n\nstatic void axg_tdmin_enable(struct regmap *map)\n{\n\t \n\tregmap_update_bits(map, TDMIN_CTRL,\n\t\t\t   TDMIN_CTRL_RST_OUT | TDMIN_CTRL_RST_IN, 0);\n\n\t \n\tregmap_update_bits(map, TDMIN_CTRL,\n\t\t\t   TDMIN_CTRL_RST_OUT, TDMIN_CTRL_RST_OUT);\n\tregmap_update_bits(map, TDMIN_CTRL,\n\t\t\t   TDMIN_CTRL_RST_IN,  TDMIN_CTRL_RST_IN);\n\n\t \n\tregmap_update_bits(map, TDMIN_CTRL,\n\t\t\t   TDMIN_CTRL_ENABLE, TDMIN_CTRL_ENABLE);\n}\n\nstatic void axg_tdmin_disable(struct regmap *map)\n{\n\tregmap_update_bits(map, TDMIN_CTRL, TDMIN_CTRL_ENABLE, 0);\n}\n\nstatic int axg_tdmin_prepare(struct regmap *map,\n\t\t\t     const struct axg_tdm_formatter_hw *quirks,\n\t\t\t     struct axg_tdm_stream *ts)\n{\n\tunsigned int val, skew = quirks->skew_offset;\n\n\t \n\tswitch (ts->iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tskew += 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unsupported format: %u\\n\",\n\t\t       ts->iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tval = TDMIN_CTRL_IN_BIT_SKEW(skew);\n\n\t \n\tswitch (ts->iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval |= TDMIN_CTRL_I2S_MODE;\n\t\tbreak;\n\t}\n\n\t \n\tif (axg_tdm_lrclk_invert(ts->iface->fmt))\n\t\tval |= TDMIN_CTRL_WS_INV;\n\n\t \n\tval |= TDMIN_CTRL_BITNUM(ts->iface->slot_width - 1);\n\n\t \n\tregmap_update_bits(map, TDMIN_CTRL,\n\t\t\t   (TDMIN_CTRL_IN_BIT_SKEW_MASK | TDMIN_CTRL_WS_INV |\n\t\t\t    TDMIN_CTRL_I2S_MODE | TDMIN_CTRL_LSB_FIRST |\n\t\t\t    TDMIN_CTRL_BITNUM_MASK), val);\n\n\t \n\tregmap_write(map, TDMIN_SWAP, 0x76543210);\n\n\treturn axg_tdm_formatter_set_channel_masks(map, ts, TDMIN_MASK0);\n}\n\nstatic const struct snd_soc_dapm_widget axg_tdmin_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 3\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 4\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 5\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 6\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 7\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 8\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 9\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 10\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 11\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 12\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 13\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 14\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 15\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &axg_tdmin_in_mux),\n\tSND_SOC_DAPM_PGA_E(\"DEC\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t   axg_tdm_formatter_event,\n\t\t\t   (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD)),\n\tSND_SOC_DAPM_AIF_OUT(\"OUT\", NULL, 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route axg_tdmin_dapm_routes[] = {\n\t{ \"SRC SEL\", \"IN 0\",  \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\",  \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\",  \"IN 2\" },\n\t{ \"SRC SEL\", \"IN 3\",  \"IN 3\" },\n\t{ \"SRC SEL\", \"IN 4\",  \"IN 4\" },\n\t{ \"SRC SEL\", \"IN 5\",  \"IN 5\" },\n\t{ \"SRC SEL\", \"IN 6\",  \"IN 6\" },\n\t{ \"SRC SEL\", \"IN 7\",  \"IN 7\" },\n\t{ \"SRC SEL\", \"IN 8\",  \"IN 8\" },\n\t{ \"SRC SEL\", \"IN 9\",  \"IN 9\" },\n\t{ \"SRC SEL\", \"IN 10\", \"IN 10\" },\n\t{ \"SRC SEL\", \"IN 11\", \"IN 11\" },\n\t{ \"SRC SEL\", \"IN 12\", \"IN 12\" },\n\t{ \"SRC SEL\", \"IN 13\", \"IN 13\" },\n\t{ \"SRC SEL\", \"IN 14\", \"IN 14\" },\n\t{ \"SRC SEL\", \"IN 15\", \"IN 15\" },\n\t{ \"DEC\", NULL, \"SRC SEL\" },\n\t{ \"OUT\", NULL, \"DEC\" },\n};\n\nstatic const struct snd_soc_component_driver axg_tdmin_component_drv = {\n\t.dapm_widgets\t\t= axg_tdmin_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_tdmin_dapm_widgets),\n\t.dapm_routes\t\t= axg_tdmin_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_tdmin_dapm_routes),\n};\n\nstatic const struct axg_tdm_formatter_ops axg_tdmin_ops = {\n\t.get_stream\t= axg_tdmin_get_tdm_stream,\n\t.prepare\t= axg_tdmin_prepare,\n\t.enable\t\t= axg_tdmin_enable,\n\t.disable\t= axg_tdmin_disable,\n};\n\nstatic const struct axg_tdm_formatter_driver axg_tdmin_drv = {\n\t.component_drv\t= &axg_tdmin_component_drv,\n\t.regmap_cfg\t= &axg_tdmin_regmap_cfg,\n\t.ops\t\t= &axg_tdmin_ops,\n\t.quirks\t\t= &(const struct axg_tdm_formatter_hw) {\n\t\t.skew_offset\t= 3,\n\t},\n};\n\nstatic const struct of_device_id axg_tdmin_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-tdmin\",\n\t\t.data = &axg_tdmin_drv,\n\t}, {\n\t\t.compatible = \"amlogic,g12a-tdmin\",\n\t\t.data = &axg_tdmin_drv,\n\t}, {\n\t\t.compatible = \"amlogic,sm1-tdmin\",\n\t\t.data = &axg_tdmin_drv,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_tdmin_of_match);\n\nstatic struct platform_driver axg_tdmin_pdrv = {\n\t.probe = axg_tdm_formatter_probe,\n\t.driver = {\n\t\t.name = \"axg-tdmin\",\n\t\t.of_match_table = axg_tdmin_of_match,\n\t},\n};\nmodule_platform_driver(axg_tdmin_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG TDM input formatter driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}