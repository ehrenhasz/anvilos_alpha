{
  "module_name": "axg-spdifin.c",
  "hash_id": "3bcf30a1a40347fbe3adf80604698718be67e3709aface3a9b8f7ee1bb364bab",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-spdifin.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/pcm_params.h>\n\n#define SPDIFIN_CTRL0\t\t\t0x00\n#define  SPDIFIN_CTRL0_EN\t\tBIT(31)\n#define  SPDIFIN_CTRL0_RST_OUT\t\tBIT(29)\n#define  SPDIFIN_CTRL0_RST_IN\t\tBIT(28)\n#define  SPDIFIN_CTRL0_WIDTH_SEL\tBIT(24)\n#define  SPDIFIN_CTRL0_STATUS_CH_SHIFT\t11\n#define  SPDIFIN_CTRL0_STATUS_SEL\tGENMASK(10, 8)\n#define  SPDIFIN_CTRL0_SRC_SEL\t\tGENMASK(5, 4)\n#define  SPDIFIN_CTRL0_CHK_VALID\tBIT(3)\n#define SPDIFIN_CTRL1\t\t\t0x04\n#define  SPDIFIN_CTRL1_BASE_TIMER\tGENMASK(19, 0)\n#define  SPDIFIN_CTRL1_IRQ_MASK\t\tGENMASK(27, 20)\n#define SPDIFIN_CTRL2\t\t\t0x08\n#define  SPDIFIN_THRES_PER_REG\t\t3\n#define  SPDIFIN_THRES_WIDTH\t\t10\n#define SPDIFIN_CTRL3\t\t\t0x0c\n#define SPDIFIN_CTRL4\t\t\t0x10\n#define  SPDIFIN_TIMER_PER_REG\t\t4\n#define  SPDIFIN_TIMER_WIDTH\t\t8\n#define SPDIFIN_CTRL5\t\t\t0x14\n#define SPDIFIN_CTRL6\t\t\t0x18\n#define SPDIFIN_STAT0\t\t\t0x1c\n#define  SPDIFIN_STAT0_MODE\t\tGENMASK(30, 28)\n#define  SPDIFIN_STAT0_MAXW\t\tGENMASK(17, 8)\n#define  SPDIFIN_STAT0_IRQ\t\tGENMASK(7, 0)\n#define  SPDIFIN_IRQ_MODE_CHANGED\tBIT(2)\n#define SPDIFIN_STAT1\t\t\t0x20\n#define SPDIFIN_STAT2\t\t\t0x24\n#define SPDIFIN_MUTE_VAL\t\t0x28\n\n#define SPDIFIN_MODE_NUM\t\t7\n\nstruct axg_spdifin_cfg {\n\tconst unsigned int *mode_rates;\n\tunsigned int ref_rate;\n};\n\nstruct axg_spdifin {\n\tconst struct axg_spdifin_cfg *conf;\n\tstruct regmap *map;\n\tstruct clk *refclk;\n\tstruct clk *pclk;\n};\n\n \n\nstatic unsigned int axg_spdifin_get_rate(struct axg_spdifin *priv)\n{\n\tunsigned int stat, mode, rate = 0;\n\n\tregmap_read(priv->map, SPDIFIN_STAT0, &stat);\n\tmode = FIELD_GET(SPDIFIN_STAT0_MODE, stat);\n\n\t \n\tif (FIELD_GET(SPDIFIN_STAT0_MAXW, stat) &&\n\t    mode < SPDIFIN_MODE_NUM)\n\t\trate = priv->conf->mode_rates[mode];\n\n\treturn rate;\n}\n\nstatic int axg_spdifin_prepare(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifin *priv = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0,\n\t\t\t   SPDIFIN_CTRL0_RST_OUT |\n\t\t\t   SPDIFIN_CTRL0_RST_IN,\n\t\t\t   0);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0,\n\t\t\t   SPDIFIN_CTRL0_RST_OUT, SPDIFIN_CTRL0_RST_OUT);\n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0,\n\t\t\t   SPDIFIN_CTRL0_RST_IN,  SPDIFIN_CTRL0_RST_IN);\n\n\treturn 0;\n}\n\nstatic void axg_spdifin_write_mode_param(struct regmap *map, int mode,\n\t\t\t\t\t unsigned int val,\n\t\t\t\t\t unsigned int num_per_reg,\n\t\t\t\t\t unsigned int base_reg,\n\t\t\t\t\t unsigned int width)\n{\n\tuint64_t offset = mode;\n\tunsigned int reg, shift, rem;\n\n\trem = do_div(offset, num_per_reg);\n\n\treg = offset * regmap_get_reg_stride(map) + base_reg;\n\tshift = width * (num_per_reg - 1 - rem);\n\n\tregmap_update_bits(map, reg, GENMASK(width - 1, 0) << shift,\n\t\t\t   val << shift);\n}\n\nstatic void axg_spdifin_write_timer(struct regmap *map, int mode,\n\t\t\t\t    unsigned int val)\n{\n\taxg_spdifin_write_mode_param(map, mode, val, SPDIFIN_TIMER_PER_REG,\n\t\t\t\t     SPDIFIN_CTRL4, SPDIFIN_TIMER_WIDTH);\n}\n\nstatic void axg_spdifin_write_threshold(struct regmap *map, int mode,\n\t\t\t\t\tunsigned int val)\n{\n\taxg_spdifin_write_mode_param(map, mode, val, SPDIFIN_THRES_PER_REG,\n\t\t\t\t     SPDIFIN_CTRL2, SPDIFIN_THRES_WIDTH);\n}\n\nstatic unsigned int axg_spdifin_mode_timer(struct axg_spdifin *priv,\n\t\t\t\t\t   int mode,\n\t\t\t\t\t   unsigned int rate)\n{\n\t \n\treturn rate / (128 * priv->conf->mode_rates[mode]);\n}\n\nstatic int axg_spdifin_sample_mode_config(struct snd_soc_dai *dai,\n\t\t\t\t\t  struct axg_spdifin *priv)\n{\n\tunsigned int rate, t_next;\n\tint ret, i = SPDIFIN_MODE_NUM - 1;\n\n\t \n\tret = clk_set_rate(priv->refclk, priv->conf->ref_rate);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"reference clock rate set failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\trate = clk_get_rate(priv->refclk);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFIN_CTRL1,\n\t\t\t   SPDIFIN_CTRL1_BASE_TIMER,\n\t\t\t   FIELD_PREP(SPDIFIN_CTRL1_BASE_TIMER, rate / 1000));\n\n\t \n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0,\n\t\t\t   SPDIFIN_CTRL0_WIDTH_SEL, SPDIFIN_CTRL0_WIDTH_SEL);\n\n\t \n\tt_next = axg_spdifin_mode_timer(priv, i, rate);\n\taxg_spdifin_write_timer(priv->map, i, t_next);\n\n\tdo {\n\t\tunsigned int t;\n\n\t\ti -= 1;\n\n\t\t \n\t\tt = axg_spdifin_mode_timer(priv, i, rate);\n\n\t\t \n\t\taxg_spdifin_write_timer(priv->map, i, t);\n\n\t\t \n\t\taxg_spdifin_write_threshold(priv->map, i, t + t_next);\n\n\t\t \n\t\tt_next = t;\n\n\t} while (i > 0);\n\n\treturn 0;\n}\n\nstatic int axg_spdifin_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifin *priv = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to enable pclk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axg_spdifin_sample_mode_config(dai, priv);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"mode configuration failed\\n\");\n\t\tgoto pclk_err;\n\t}\n\n\tret = clk_prepare_enable(priv->refclk);\n\tif (ret) {\n\t\tdev_err(dai->dev,\n\t\t\t\"failed to enable spdifin reference clock\\n\");\n\t\tgoto pclk_err;\n\t}\n\n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0, SPDIFIN_CTRL0_EN,\n\t\t\t   SPDIFIN_CTRL0_EN);\n\n\treturn 0;\n\npclk_err:\n\tclk_disable_unprepare(priv->pclk);\n\treturn ret;\n}\n\nstatic int axg_spdifin_dai_remove(struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifin *priv = snd_soc_dai_get_drvdata(dai);\n\n\tregmap_update_bits(priv->map, SPDIFIN_CTRL0, SPDIFIN_CTRL0_EN, 0);\n\tclk_disable_unprepare(priv->refclk);\n\tclk_disable_unprepare(priv->pclk);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops axg_spdifin_ops = {\n\t.probe\t\t= axg_spdifin_dai_probe,\n\t.remove\t\t= axg_spdifin_dai_remove,\n\t.prepare\t= axg_spdifin_prepare,\n};\n\nstatic int axg_spdifin_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int axg_spdifin_get_status_mask(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tint i;\n\n\tfor (i = 0; i < 24; i++)\n\t\tucontrol->value.iec958.status[i] = 0xff;\n\n\treturn 0;\n}\n\nstatic int axg_spdifin_get_status(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *c = snd_kcontrol_chip(kcontrol);\n\tstruct axg_spdifin *priv = snd_soc_component_get_drvdata(c);\n\tint i, j;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tunsigned int val;\n\n\t\tregmap_update_bits(priv->map, SPDIFIN_CTRL0,\n\t\t\t\t   SPDIFIN_CTRL0_STATUS_SEL,\n\t\t\t\t   FIELD_PREP(SPDIFIN_CTRL0_STATUS_SEL, i));\n\n\t\tregmap_read(priv->map, SPDIFIN_STAT1, &val);\n\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tunsigned int offset = i * 4 + j;\n\n\t\t\tucontrol->value.iec958.status[offset] =\n\t\t\t\t(val >> (j * 8)) & 0xff;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define AXG_SPDIFIN_IEC958_MASK\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\t\t\t\\\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\t\t\t\\\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, MASK),\t\\\n\t\t.info = axg_spdifin_iec958_info,\t\t\t\\\n\t\t.get = axg_spdifin_get_status_mask,\t\t\t\\\n\t}\n\n#define AXG_SPDIFIN_IEC958_STATUS\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READ |\t\t\t\\\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE),\t\t\\\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\t\t\t\\\n\t\t.name =\tSNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE),\t\\\n\t\t.info = axg_spdifin_iec958_info,\t\t\t\\\n\t\t.get = axg_spdifin_get_status,\t\t\t\t\\\n\t}\n\nstatic const char * const spdifin_chsts_src_texts[] = {\n\t\"A\", \"B\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(axg_spdifin_chsts_src_enum, SPDIFIN_CTRL0,\n\t\t\t    SPDIFIN_CTRL0_STATUS_CH_SHIFT,\n\t\t\t    spdifin_chsts_src_texts);\n\nstatic int axg_spdifin_rate_lock_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 192000;\n\n\treturn 0;\n}\n\nstatic int axg_spdifin_rate_lock_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *c = snd_kcontrol_chip(kcontrol);\n\tstruct axg_spdifin *priv = snd_soc_component_get_drvdata(c);\n\n\tucontrol->value.integer.value[0] = axg_spdifin_get_rate(priv);\n\n\treturn 0;\n}\n\n#define AXG_SPDIFIN_LOCK_RATE(xname)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\t\t\\\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READ |\t\t\\\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE),\t\\\n\t\t.get = axg_spdifin_rate_lock_get,\t\t\\\n\t\t.info = axg_spdifin_rate_lock_info,\t\t\\\n\t\t.name = xname,\t\t\t\t\t\\\n\t}\n\nstatic const struct snd_kcontrol_new axg_spdifin_controls[] = {\n\tAXG_SPDIFIN_LOCK_RATE(\"Capture Rate Lock\"),\n\tSOC_DOUBLE(\"Capture Switch\", SPDIFIN_CTRL0, 7, 6, 1, 1),\n\tSOC_ENUM(SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, NONE) \"Src\",\n\t\t axg_spdifin_chsts_src_enum),\n\tAXG_SPDIFIN_IEC958_MASK,\n\tAXG_SPDIFIN_IEC958_STATUS,\n};\n\nstatic const struct snd_soc_component_driver axg_spdifin_component_drv = {\n\t.controls\t\t= axg_spdifin_controls,\n\t.num_controls\t\t= ARRAY_SIZE(axg_spdifin_controls),\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct regmap_config axg_spdifin_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= SPDIFIN_MUTE_VAL,\n};\n\nstatic const unsigned int axg_spdifin_mode_rates[SPDIFIN_MODE_NUM] = {\n\t32000, 44100, 48000, 88200, 96000, 176400, 192000,\n};\n\nstatic const struct axg_spdifin_cfg axg_cfg = {\n\t.mode_rates = axg_spdifin_mode_rates,\n\t.ref_rate = 333333333,\n};\n\nstatic const struct of_device_id axg_spdifin_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-spdifin\",\n\t\t.data = &axg_cfg,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_spdifin_of_match);\n\nstatic struct snd_soc_dai_driver *\naxg_spdifin_get_dai_drv(struct device *dev, struct axg_spdifin *priv)\n{\n\tstruct snd_soc_dai_driver *drv;\n\tint i;\n\n\tdrv = devm_kzalloc(dev, sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdrv->name = \"SPDIF Input\";\n\tdrv->ops = &axg_spdifin_ops;\n\tdrv->capture.stream_name = \"Capture\";\n\tdrv->capture.channels_min = 1;\n\tdrv->capture.channels_max = 2;\n\tdrv->capture.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;\n\n\tfor (i = 0; i < SPDIFIN_MODE_NUM; i++) {\n\t\tunsigned int rb =\n\t\t\tsnd_pcm_rate_to_rate_bit(priv->conf->mode_rates[i]);\n\n\t\tif (rb == SNDRV_PCM_RATE_KNOT)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tdrv->capture.rates |= rb;\n\t}\n\n\treturn drv;\n}\n\nstatic int axg_spdifin_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct axg_spdifin *priv;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tvoid __iomem *regs;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->conf = of_device_get_match_data(dev);\n\tif (!priv->conf) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->map = devm_regmap_init_mmio(dev, regs, &axg_spdifin_regmap_cfg);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(priv->map));\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tpriv->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->pclk), \"failed to get pclk\\n\");\n\n\tpriv->refclk = devm_clk_get(dev, \"refclk\");\n\tif (IS_ERR(priv->refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->refclk), \"failed to get mclk\\n\");\n\n\tdai_drv = axg_spdifin_get_dai_drv(dev, priv);\n\tif (IS_ERR(dai_drv)) {\n\t\tdev_err(dev, \"failed to get dai driver: %ld\\n\",\n\t\t\tPTR_ERR(dai_drv));\n\t\treturn PTR_ERR(dai_drv);\n\t}\n\n\treturn devm_snd_soc_register_component(dev, &axg_spdifin_component_drv,\n\t\t\t\t\t       dai_drv, 1);\n}\n\nstatic struct platform_driver axg_spdifin_pdrv = {\n\t.probe = axg_spdifin_probe,\n\t.driver = {\n\t\t.name = \"axg-spdifin\",\n\t\t.of_match_table = axg_spdifin_of_match,\n\t},\n};\nmodule_platform_driver(axg_spdifin_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG SPDIF Input driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}