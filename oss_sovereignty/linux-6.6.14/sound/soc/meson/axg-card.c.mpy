{
  "module_name": "axg-card.c",
  "hash_id": "6c4b3c07f3f228ae061e054382e5aeb13217f57ca94a9ba5394f024af4d21bdd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-card.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-tdm.h\"\n#include \"meson-card.h\"\n\nstruct axg_dai_link_tdm_mask {\n\tu32 tx;\n\tu32 rx;\n};\n\nstruct axg_dai_link_tdm_data {\n\tunsigned int mclk_fs;\n\tunsigned int slots;\n\tunsigned int slot_width;\n\tu32 *tx_mask;\n\tu32 *rx_mask;\n\tstruct axg_dai_link_tdm_mask *codec_masks;\n};\n\n \nstatic const struct snd_soc_pcm_stream codec_params = {\n\t.formats = SNDRV_PCM_FMTBIT_S24_LE,\n\t.rate_min = 5525,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = 8,\n};\n\nstatic int axg_card_tdm_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct axg_dai_link_tdm_data *be =\n\t\t(struct axg_dai_link_tdm_data *)priv->link_data[rtd->num];\n\n\treturn meson_card_i2s_set_sysclk(substream, params, be->mclk_fs);\n}\n\nstatic const struct snd_soc_ops axg_card_tdm_be_ops = {\n\t.hw_params = axg_card_tdm_be_hw_params,\n};\n\nstatic int axg_card_tdm_dai_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct axg_dai_link_tdm_data *be =\n\t\t(struct axg_dai_link_tdm_data *)priv->link_data[rtd->num];\n\tstruct snd_soc_dai *codec_dai;\n\tint ret, i;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai,\n\t\t\t\t\t       be->codec_masks[i].tx,\n\t\t\t\t\t       be->codec_masks[i].rx,\n\t\t\t\t\t       be->slots, be->slot_width);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(codec_dai->dev,\n\t\t\t\t\"setting tdm link slots failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = axg_tdm_set_tdm_slots(asoc_rtd_to_cpu(rtd, 0), be->tx_mask, be->rx_mask,\n\t\t\t\t    be->slots, be->slot_width);\n\tif (ret) {\n\t\tdev_err(asoc_rtd_to_cpu(rtd, 0)->dev, \"setting tdm link slots failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_card_tdm_dai_lb_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct axg_dai_link_tdm_data *be =\n\t\t(struct axg_dai_link_tdm_data *)priv->link_data[rtd->num];\n\tint ret;\n\n\t \n\tret = axg_tdm_set_tdm_slots(asoc_rtd_to_cpu(rtd, 0), NULL, be->tx_mask,\n\t\t\t\t    be->slots, be->slot_width);\n\tif (ret) {\n\t\tdev_err(asoc_rtd_to_cpu(rtd, 0)->dev, \"setting tdm link slots failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_card_add_tdm_loopback(struct snd_soc_card *card,\n\t\t\t\t     int *index)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *pad = &card->dai_link[*index];\n\tstruct snd_soc_dai_link *lb;\n\tstruct snd_soc_dai_link_component *dlc;\n\tint ret;\n\n\t \n\tret = meson_card_reallocate_links(card, card->num_links + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tlb = &card->dai_link[*index + 1];\n\n\tlb->name = devm_kasprintf(card->dev, GFP_KERNEL, \"%s-lb\", pad->name);\n\tif (!lb->name)\n\t\treturn -ENOMEM;\n\n\tdlc = devm_kzalloc(card->dev, sizeof(*dlc), GFP_KERNEL);\n\tif (!dlc)\n\t\treturn -ENOMEM;\n\n\tlb->cpus = dlc;\n\tlb->codecs = &asoc_dummy_dlc;\n\tlb->num_cpus = 1;\n\tlb->num_codecs = 1;\n\n\tlb->stream_name = lb->name;\n\tlb->cpus->of_node = pad->cpus->of_node;\n\tlb->cpus->dai_name = \"TDM Loopback\";\n\tlb->dpcm_capture = 1;\n\tlb->no_pcm = 1;\n\tlb->ops = &axg_card_tdm_be_ops;\n\tlb->init = axg_card_tdm_dai_lb_init;\n\n\t \n\tpriv->link_data[*index + 1] = priv->link_data[*index];\n\n\t \n\tof_node_get(lb->cpus->of_node);\n\n\t \n\t*index += 1;\n\n\treturn 0;\n}\n\nstatic int axg_card_parse_cpu_tdm_slots(struct snd_soc_card *card,\n\t\t\t\t\tstruct snd_soc_dai_link *link,\n\t\t\t\t\tstruct device_node *node,\n\t\t\t\t\tstruct axg_dai_link_tdm_data *be)\n{\n\tchar propname[32];\n\tu32 tx, rx;\n\tint i;\n\n\tbe->tx_mask = devm_kcalloc(card->dev, AXG_TDM_NUM_LANES,\n\t\t\t\t   sizeof(*be->tx_mask), GFP_KERNEL);\n\tbe->rx_mask = devm_kcalloc(card->dev, AXG_TDM_NUM_LANES,\n\t\t\t\t   sizeof(*be->rx_mask), GFP_KERNEL);\n\tif (!be->tx_mask || !be->rx_mask)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, tx = 0; i < AXG_TDM_NUM_LANES; i++) {\n\t\tsnprintf(propname, 32, \"dai-tdm-slot-tx-mask-%d\", i);\n\t\tsnd_soc_of_get_slot_mask(node, propname, &be->tx_mask[i]);\n\t\ttx = max(tx, be->tx_mask[i]);\n\t}\n\n\t \n\tif (!tx)\n\t\tlink->dpcm_playback = 0;\n\n\tfor (i = 0, rx = 0; i < AXG_TDM_NUM_LANES; i++) {\n\t\tsnprintf(propname, 32, \"dai-tdm-slot-rx-mask-%d\", i);\n\t\tsnd_soc_of_get_slot_mask(node, propname, &be->rx_mask[i]);\n\t\trx = max(rx, be->rx_mask[i]);\n\t}\n\n\t \n\tif (!rx)\n\t\tlink->dpcm_capture = 0;\n\n\t \n\tif (!tx && !rx) {\n\t\tdev_err(card->dev, \"tdm link has no cpu slots\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32(node, \"dai-tdm-slot-num\", &be->slots);\n\tif (!be->slots) {\n\t\t \n\t\tbe->slots = fls(max(tx, rx));\n\t} else if (be->slots < fls(max(tx, rx)) || be->slots > 32) {\n\t\t \n\t\tdev_err(card->dev, \"bad slot number\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32(node, \"dai-tdm-slot-width\", &be->slot_width);\n\n\treturn 0;\n}\n\nstatic int axg_card_parse_codecs_masks(struct snd_soc_card *card,\n\t\t\t\t       struct snd_soc_dai_link *link,\n\t\t\t\t       struct device_node *node,\n\t\t\t\t       struct axg_dai_link_tdm_data *be)\n{\n\tstruct axg_dai_link_tdm_mask *codec_mask;\n\tstruct device_node *np;\n\n\tcodec_mask = devm_kcalloc(card->dev, link->num_codecs,\n\t\t\t\t  sizeof(*codec_mask), GFP_KERNEL);\n\tif (!codec_mask)\n\t\treturn -ENOMEM;\n\n\tbe->codec_masks = codec_mask;\n\n\tfor_each_child_of_node(node, np) {\n\t\tsnd_soc_of_get_slot_mask(np, \"dai-tdm-slot-rx-mask\",\n\t\t\t\t\t &codec_mask->rx);\n\t\tsnd_soc_of_get_slot_mask(np, \"dai-tdm-slot-tx-mask\",\n\t\t\t\t\t &codec_mask->tx);\n\n\t\tcodec_mask++;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_card_parse_tdm(struct snd_soc_card *card,\n\t\t\t      struct device_node *node,\n\t\t\t      int *index)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *link = &card->dai_link[*index];\n\tstruct axg_dai_link_tdm_data *be;\n\tint ret;\n\n\t \n\tbe = devm_kzalloc(card->dev, sizeof(*be), GFP_KERNEL);\n\tif (!be)\n\t\treturn -ENOMEM;\n\tpriv->link_data[*index] = be;\n\n\t \n\tlink->ops = &axg_card_tdm_be_ops;\n\tlink->init = axg_card_tdm_dai_init;\n\tlink->dai_fmt = meson_card_parse_daifmt(node, link->cpus->of_node);\n\n\tof_property_read_u32(node, \"mclk-fs\", &be->mclk_fs);\n\n\tret = axg_card_parse_cpu_tdm_slots(card, link, node, be);\n\tif (ret) {\n\t\tdev_err(card->dev, \"error parsing tdm link slots\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axg_card_parse_codecs_masks(card, link, node, be);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (link->dpcm_playback) {\n\t\tret = axg_card_add_tdm_loopback(card, index);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_card_cpu_is_capture_fe(struct device_node *np)\n{\n\treturn of_device_is_compatible(np, DT_PREFIX \"axg-toddr\");\n}\n\nstatic int axg_card_cpu_is_playback_fe(struct device_node *np)\n{\n\treturn of_device_is_compatible(np, DT_PREFIX \"axg-frddr\");\n}\n\nstatic int axg_card_cpu_is_tdm_iface(struct device_node *np)\n{\n\treturn of_device_is_compatible(np, DT_PREFIX \"axg-tdm-iface\");\n}\n\nstatic int axg_card_cpu_is_codec(struct device_node *np)\n{\n\treturn of_device_is_compatible(np, DT_PREFIX \"g12a-tohdmitx\") ||\n\t\tof_device_is_compatible(np, DT_PREFIX \"g12a-toacodec\");\n}\n\nstatic int axg_card_add_link(struct snd_soc_card *card, struct device_node *np,\n\t\t\t     int *index)\n{\n\tstruct snd_soc_dai_link *dai_link = &card->dai_link[*index];\n\tstruct snd_soc_dai_link_component *cpu;\n\tint ret;\n\n\tcpu = devm_kzalloc(card->dev, sizeof(*cpu), GFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tdai_link->cpus = cpu;\n\tdai_link->num_cpus = 1;\n\n\tret = meson_card_parse_dai(card, np, dai_link->cpus);\n\tif (ret)\n\t\treturn ret;\n\n\tif (axg_card_cpu_is_playback_fe(dai_link->cpus->of_node))\n\t\treturn meson_card_set_fe_link(card, dai_link, np, true);\n\telse if (axg_card_cpu_is_capture_fe(dai_link->cpus->of_node))\n\t\treturn meson_card_set_fe_link(card, dai_link, np, false);\n\n\n\tret = meson_card_set_be_link(card, dai_link, np);\n\tif (ret)\n\t\treturn ret;\n\n\tif (axg_card_cpu_is_codec(dai_link->cpus->of_node)) {\n\t\tdai_link->c2c_params = &codec_params;\n\t\tdai_link->num_c2c_params = 1;\n\t} else {\n\t\tdai_link->no_pcm = 1;\n\t\tsnd_soc_dai_link_set_capabilities(dai_link);\n\t\tif (axg_card_cpu_is_tdm_iface(dai_link->cpus->of_node))\n\t\t\tret = axg_card_parse_tdm(card, np, index);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct meson_card_match_data axg_card_match_data = {\n\t.add_link = axg_card_add_link,\n};\n\nstatic const struct of_device_id axg_card_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-sound-card\",\n\t\t.data = &axg_card_match_data,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_card_of_match);\n\nstatic struct platform_driver axg_card_pdrv = {\n\t.probe = meson_card_probe,\n\t.remove = meson_card_remove,\n\t.driver = {\n\t\t.name = \"axg-sound-card\",\n\t\t.of_match_table = axg_card_of_match,\n\t},\n};\nmodule_platform_driver(axg_card_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG ALSA machine driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}