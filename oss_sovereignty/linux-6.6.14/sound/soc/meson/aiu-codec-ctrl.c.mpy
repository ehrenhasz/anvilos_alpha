{
  "module_name": "aiu-codec-ctrl.c",
  "hash_id": "ee2c356bbb1acfa53b1d066b04141af8855b58355e4b683b11e457980ca83de9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/aiu-codec-ctrl.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/meson-aiu.h>\n#include \"aiu.h\"\n#include \"meson-codec-glue.h\"\n\n#define CTRL_CLK_SEL\t\tGENMASK(1, 0)\n#define CTRL_DATA_SEL_SHIFT\t4\n#define CTRL_DATA_SEL\t\t(0x3 << CTRL_DATA_SEL_SHIFT)\n\nstatic const char * const aiu_codec_ctrl_mux_texts[] = {\n\t\"DISABLED\", \"PCM\", \"I2S\",\n};\n\nstatic int aiu_codec_ctrl_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int mux, changed;\n\n\tmux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);\n\tchanged = snd_soc_component_test_bits(component, e->reg,\n\t\t\t\t\t      CTRL_DATA_SEL,\n\t\t\t\t\t      FIELD_PREP(CTRL_DATA_SEL, mux));\n\n\tif (!changed)\n\t\treturn 0;\n\n\t \n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);\n\n\t \n\tsnd_soc_component_update_bits(component, e->reg,\n\t\t\t\t      CTRL_CLK_SEL |\n\t\t\t\t      CTRL_DATA_SEL,\n\t\t\t\t      FIELD_PREP(CTRL_CLK_SEL, 0) |\n\t\t\t\t      FIELD_PREP(CTRL_DATA_SEL, 0));\n\n\t \n\tsnd_soc_component_update_bits(component, e->reg,\n\t\t\t\t      CTRL_CLK_SEL |\n\t\t\t\t      CTRL_DATA_SEL,\n\t\t\t\t      FIELD_PREP(CTRL_CLK_SEL, mux) |\n\t\t\t\t      FIELD_PREP(CTRL_DATA_SEL, mux));\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_DECL(aiu_hdmi_ctrl_mux_enum, AIU_HDMI_CLK_DATA_CTRL,\n\t\t\t    CTRL_DATA_SEL_SHIFT,\n\t\t\t    aiu_codec_ctrl_mux_texts);\n\nstatic const struct snd_kcontrol_new aiu_hdmi_ctrl_mux =\n\tSOC_DAPM_ENUM_EXT(\"HDMI Source\", aiu_hdmi_ctrl_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  aiu_codec_ctrl_mux_put_enum);\n\nstatic const struct snd_soc_dapm_widget aiu_hdmi_ctrl_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"HDMI CTRL SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aiu_hdmi_ctrl_mux),\n};\n\nstatic const struct snd_soc_dai_ops aiu_codec_ctrl_input_ops = {\n\t.probe\t\t= meson_codec_glue_input_dai_probe,\n\t.remove\t\t= meson_codec_glue_input_dai_remove,\n\t.hw_params\t= meson_codec_glue_input_hw_params,\n\t.set_fmt\t= meson_codec_glue_input_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops aiu_codec_ctrl_output_ops = {\n\t.startup\t= meson_codec_glue_output_startup,\n};\n\n#define AIU_CODEC_CTRL_FORMATS\t\t\t\t\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t SNDRV_PCM_FMTBIT_S32_LE)\n\n#define AIU_CODEC_CTRL_STREAM(xname, xsuffix)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.stream_name\t= xname \" \" xsuffix,\t\t\t\\\n\t.channels_min\t= 1,\t\t\t\t\t\\\n\t.channels_max\t= 8,\t\t\t\t\t\\\n\t.rate_min       = 5512,\t\t\t\t\t\\\n\t.rate_max\t= 192000,\t\t\t\t\\\n\t.formats\t= AIU_CODEC_CTRL_FORMATS,\t\t\\\n}\n\n#define AIU_CODEC_CTRL_INPUT(xname) {\t\t\t\t\\\n\t.name = \"CODEC CTRL \" xname,\t\t\t\t\\\n\t.playback = AIU_CODEC_CTRL_STREAM(xname, \"Playback\"),\t\\\n\t.ops = &aiu_codec_ctrl_input_ops,\t\t\t\\\n}\n\n#define AIU_CODEC_CTRL_OUTPUT(xname) {\t\t\t\t\\\n\t.name = \"CODEC CTRL \" xname,\t\t\t\t\\\n\t.capture = AIU_CODEC_CTRL_STREAM(xname, \"Capture\"),\t\\\n\t.ops = &aiu_codec_ctrl_output_ops,\t\t\t\\\n}\n\nstatic struct snd_soc_dai_driver aiu_hdmi_ctrl_dai_drv[] = {\n\t[CTRL_I2S] = AIU_CODEC_CTRL_INPUT(\"HDMI I2S IN\"),\n\t[CTRL_PCM] = AIU_CODEC_CTRL_INPUT(\"HDMI PCM IN\"),\n\t[CTRL_OUT] = AIU_CODEC_CTRL_OUTPUT(\"HDMI OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route aiu_hdmi_ctrl_routes[] = {\n\t{ \"HDMI CTRL SRC\", \"I2S\", \"HDMI I2S IN Playback\" },\n\t{ \"HDMI CTRL SRC\", \"PCM\", \"HDMI PCM IN Playback\" },\n\t{ \"HDMI OUT Capture\", NULL, \"HDMI CTRL SRC\" },\n};\n\nstatic int aiu_hdmi_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t      const struct of_phandle_args *args,\n\t\t\t\t      const char **dai_name)\n{\n\treturn aiu_of_xlate_dai_name(component, args, dai_name, AIU_HDMI);\n}\n\nstatic const struct snd_soc_component_driver aiu_hdmi_ctrl_component = {\n\t.name\t\t\t= \"AIU HDMI Codec Control\",\n\t.dapm_widgets\t\t= aiu_hdmi_ctrl_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aiu_hdmi_ctrl_widgets),\n\t.dapm_routes\t\t= aiu_hdmi_ctrl_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aiu_hdmi_ctrl_routes),\n\t.of_xlate_dai_name\t= aiu_hdmi_of_xlate_dai_name,\n\t.endianness\t\t= 1,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_prefix\t\t= \"hdmi\",\n#endif\n};\n\nint aiu_hdmi_ctrl_register_component(struct device *dev)\n{\n\treturn snd_soc_register_component(dev, &aiu_hdmi_ctrl_component,\n\t\t\t\t\t  aiu_hdmi_ctrl_dai_drv,\n\t\t\t\t\t  ARRAY_SIZE(aiu_hdmi_ctrl_dai_drv));\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}