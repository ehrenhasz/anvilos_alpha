{
  "module_name": "g12a-toacodec.c",
  "hash_id": "86ab2f5e27378d7c63a57874b805f666004cc7e4931f55e84922c828f3997769",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/g12a-toacodec.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/meson-g12a-toacodec.h>\n#include \"axg-tdm.h\"\n#include \"meson-codec-glue.h\"\n\n#define G12A_TOACODEC_DRV_NAME \"g12a-toacodec\"\n\n#define TOACODEC_CTRL0\t\t\t0x0\n#define  CTRL0_ENABLE_SHIFT\t\t31\n#define  CTRL0_DAT_SEL_SM1_MSB\t\t19\n#define  CTRL0_DAT_SEL_SM1_LSB\t\t18\n#define  CTRL0_DAT_SEL_MSB\t\t15\n#define  CTRL0_DAT_SEL_LSB\t\t14\n#define  CTRL0_LANE_SEL_SM1\t\t16\n#define  CTRL0_LANE_SEL\t\t\t12\n#define  CTRL0_LRCLK_SEL_SM1_MSB\t14\n#define  CTRL0_LRCLK_SEL_SM1_LSB\t12\n#define  CTRL0_LRCLK_SEL_MSB\t\t9\n#define  CTRL0_LRCLK_SEL_LSB\t\t8\n#define  CTRL0_LRCLK_INV_SM1\t\tBIT(10)\n#define  CTRL0_BLK_CAP_INV_SM1\t\tBIT(9)\n#define  CTRL0_BLK_CAP_INV\t\tBIT(7)\n#define  CTRL0_BCLK_O_INV_SM1\t\tBIT(8)\n#define  CTRL0_BCLK_O_INV\t\tBIT(6)\n#define  CTRL0_BCLK_SEL_SM1_MSB\t\t6\n#define  CTRL0_BCLK_SEL_MSB\t\t5\n#define  CTRL0_BCLK_SEL_LSB\t\t4\n#define  CTRL0_MCLK_SEL\t\t\tGENMASK(2, 0)\n\n#define TOACODEC_OUT_CHMAX\t\t2\n\nstruct g12a_toacodec {\n\tstruct regmap_field *field_dat_sel;\n\tstruct regmap_field *field_lrclk_sel;\n\tstruct regmap_field *field_bclk_sel;\n};\n\nstruct g12a_toacodec_match_data {\n\tconst struct snd_soc_component_driver *component_drv;\n\tstruct reg_field field_dat_sel;\n\tstruct reg_field field_lrclk_sel;\n\tstruct reg_field field_bclk_sel;\n};\n\nstatic const char * const g12a_toacodec_mux_texts[] = {\n\t\"I2S A\", \"I2S B\", \"I2S C\",\n};\n\nstatic int g12a_toacodec_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct g12a_toacodec *priv = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int mux, reg;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tmux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);\n\tregmap_field_read(priv->field_dat_sel, &reg);\n\n\tif (mux == reg)\n\t\treturn 0;\n\n\t \n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);\n\n\tregmap_field_write(priv->field_dat_sel, mux);\n\tregmap_field_write(priv->field_lrclk_sel, mux);\n\tregmap_field_write(priv->field_bclk_sel, mux);\n\n\t \n\tsnd_soc_component_update_bits(component, e->reg,\n\t\t\t\t      CTRL0_MCLK_SEL,\n\t\t\t\t      FIELD_PREP(CTRL0_MCLK_SEL, mux));\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_DECL(g12a_toacodec_mux_enum, TOACODEC_CTRL0,\n\t\t\t    CTRL0_DAT_SEL_LSB,\n\t\t\t    g12a_toacodec_mux_texts);\n\nstatic SOC_ENUM_SINGLE_DECL(sm1_toacodec_mux_enum, TOACODEC_CTRL0,\n\t\t\t    CTRL0_DAT_SEL_SM1_LSB,\n\t\t\t    g12a_toacodec_mux_texts);\n\nstatic const struct snd_kcontrol_new g12a_toacodec_mux =\n\tSOC_DAPM_ENUM_EXT(\"Source\", g12a_toacodec_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  g12a_toacodec_mux_put_enum);\n\nstatic const struct snd_kcontrol_new sm1_toacodec_mux =\n\tSOC_DAPM_ENUM_EXT(\"Source\", sm1_toacodec_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  g12a_toacodec_mux_put_enum);\n\nstatic const struct snd_kcontrol_new g12a_toacodec_out_enable =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", TOACODEC_CTRL0,\n\t\t\t\t    CTRL0_ENABLE_SHIFT, 1, 0);\n\nstatic const struct snd_soc_dapm_widget g12a_toacodec_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &g12a_toacodec_mux),\n\tSND_SOC_DAPM_SWITCH(\"OUT EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &g12a_toacodec_out_enable),\n};\n\nstatic const struct snd_soc_dapm_widget sm1_toacodec_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &sm1_toacodec_mux),\n\tSND_SOC_DAPM_SWITCH(\"OUT EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &g12a_toacodec_out_enable),\n};\n\nstatic int g12a_toacodec_input_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct meson_codec_glue_input *data;\n\tint ret;\n\n\tret = meson_codec_glue_input_hw_params(substream, params, dai);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = meson_codec_glue_input_get_data(dai);\n\tdata->params.channels_min = min_t(unsigned int, TOACODEC_OUT_CHMAX,\n\t\t\t\t\tdata->params.channels_min);\n\tdata->params.channels_max = min_t(unsigned int, TOACODEC_OUT_CHMAX,\n\t\t\t\t\tdata->params.channels_max);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops g12a_toacodec_input_ops = {\n\t.probe\t\t= meson_codec_glue_input_dai_probe,\n\t.remove\t\t= meson_codec_glue_input_dai_remove,\n\t.hw_params\t= g12a_toacodec_input_hw_params,\n\t.set_fmt\t= meson_codec_glue_input_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops g12a_toacodec_output_ops = {\n\t.startup\t= meson_codec_glue_output_startup,\n};\n\n#define TOACODEC_STREAM(xname, xsuffix, xchmax)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.stream_name\t= xname \" \" xsuffix,\t\t\t\\\n\t.channels_min\t= 1,\t\t\t\t\t\\\n\t.channels_max\t= (xchmax),\t\t\t\t\\\n\t.rate_min       = 5512,\t\t\t\t\t\\\n\t.rate_max\t= 192000,\t\t\t\t\\\n\t.formats\t= AXG_TDM_FORMATS,\t\t\t\\\n}\n\n#define TOACODEC_INPUT(xname, xid) {\t\t\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.id = (xid),\t\t\t\t\t\t\t\\\n\t.playback = TOACODEC_STREAM(xname, \"Playback\", 8),\t\t\\\n\t.ops = &g12a_toacodec_input_ops,\t\t\t\t\\\n}\n\n#define TOACODEC_OUTPUT(xname, xid) {\t\t\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.id = (xid),\t\t\t\t\t\t\t\\\n\t.capture = TOACODEC_STREAM(xname, \"Capture\", TOACODEC_OUT_CHMAX), \\\n\t.ops = &g12a_toacodec_output_ops,\t\t\t\t\\\n}\n\nstatic struct snd_soc_dai_driver g12a_toacodec_dai_drv[] = {\n\tTOACODEC_INPUT(\"IN A\", TOACODEC_IN_A),\n\tTOACODEC_INPUT(\"IN B\", TOACODEC_IN_B),\n\tTOACODEC_INPUT(\"IN C\", TOACODEC_IN_C),\n\tTOACODEC_OUTPUT(\"OUT\", TOACODEC_OUT),\n};\n\nstatic int g12a_toacodec_component_probe(struct snd_soc_component *c)\n{\n\t \n\treturn snd_soc_component_write(c, TOACODEC_CTRL0,\n\t\t\t\t       CTRL0_BLK_CAP_INV);\n}\n\nstatic int sm1_toacodec_component_probe(struct snd_soc_component *c)\n{\n\t \n\treturn snd_soc_component_write(c, TOACODEC_CTRL0,\n\t\t\t\t       CTRL0_BLK_CAP_INV_SM1);\n}\n\nstatic const struct snd_soc_dapm_route g12a_toacodec_routes[] = {\n\t{ \"SRC\", \"I2S A\", \"IN A Playback\" },\n\t{ \"SRC\", \"I2S B\", \"IN B Playback\" },\n\t{ \"SRC\", \"I2S C\", \"IN C Playback\" },\n\t{ \"OUT EN\", \"Switch\", \"SRC\" },\n\t{ \"OUT Capture\", NULL, \"OUT EN\" },\n};\n\nstatic const struct snd_kcontrol_new g12a_toacodec_controls[] = {\n\tSOC_SINGLE(\"Lane Select\", TOACODEC_CTRL0, CTRL0_LANE_SEL, 3, 0),\n};\n\nstatic const struct snd_kcontrol_new sm1_toacodec_controls[] = {\n\tSOC_SINGLE(\"Lane Select\", TOACODEC_CTRL0, CTRL0_LANE_SEL_SM1, 3, 0),\n};\n\nstatic const struct snd_soc_component_driver g12a_toacodec_component_drv = {\n\t.probe\t\t\t= g12a_toacodec_component_probe,\n\t.controls\t\t= g12a_toacodec_controls,\n\t.num_controls\t\t= ARRAY_SIZE(g12a_toacodec_controls),\n\t.dapm_widgets\t\t= g12a_toacodec_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(g12a_toacodec_widgets),\n\t.dapm_routes\t\t= g12a_toacodec_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(g12a_toacodec_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver sm1_toacodec_component_drv = {\n\t.probe\t\t\t= sm1_toacodec_component_probe,\n\t.controls\t\t= sm1_toacodec_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sm1_toacodec_controls),\n\t.dapm_widgets\t\t= sm1_toacodec_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sm1_toacodec_widgets),\n\t.dapm_routes\t\t= g12a_toacodec_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(g12a_toacodec_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config g12a_toacodec_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstatic const struct g12a_toacodec_match_data g12a_toacodec_match_data = {\n\t.component_drv\t= &g12a_toacodec_component_drv,\n\t.field_dat_sel\t= REG_FIELD(TOACODEC_CTRL0, 14, 15),\n\t.field_lrclk_sel = REG_FIELD(TOACODEC_CTRL0, 8, 9),\n\t.field_bclk_sel\t= REG_FIELD(TOACODEC_CTRL0, 4, 5),\n};\n\nstatic const struct g12a_toacodec_match_data sm1_toacodec_match_data = {\n\t.component_drv\t= &sm1_toacodec_component_drv,\n\t.field_dat_sel\t= REG_FIELD(TOACODEC_CTRL0, 18, 19),\n\t.field_lrclk_sel = REG_FIELD(TOACODEC_CTRL0, 12, 14),\n\t.field_bclk_sel\t= REG_FIELD(TOACODEC_CTRL0, 4, 6),\n};\n\nstatic const struct of_device_id g12a_toacodec_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,g12a-toacodec\",\n\t\t.data = &g12a_toacodec_match_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,sm1-toacodec\",\n\t\t.data = &sm1_toacodec_match_data,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, g12a_toacodec_of_match);\n\nstatic int g12a_toacodec_probe(struct platform_device *pdev)\n{\n\tconst struct g12a_toacodec_match_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct g12a_toacodec *priv;\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\tint ret;\n\n\tdata = device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = device_reset(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tmap = devm_regmap_init_mmio(dev, regs, &g12a_toacodec_regmap_cfg);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(map));\n\t\treturn PTR_ERR(map);\n\t}\n\n\tpriv->field_dat_sel = devm_regmap_field_alloc(dev, map, data->field_dat_sel);\n\tif (IS_ERR(priv->field_dat_sel))\n\t\treturn PTR_ERR(priv->field_dat_sel);\n\n\tpriv->field_lrclk_sel = devm_regmap_field_alloc(dev, map, data->field_lrclk_sel);\n\tif (IS_ERR(priv->field_lrclk_sel))\n\t\treturn PTR_ERR(priv->field_lrclk_sel);\n\n\tpriv->field_bclk_sel = devm_regmap_field_alloc(dev, map, data->field_bclk_sel);\n\tif (IS_ERR(priv->field_bclk_sel))\n\t\treturn PTR_ERR(priv->field_bclk_sel);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\tdata->component_drv, g12a_toacodec_dai_drv,\n\t\t\tARRAY_SIZE(g12a_toacodec_dai_drv));\n}\n\nstatic struct platform_driver g12a_toacodec_pdrv = {\n\t.driver = {\n\t\t.name = G12A_TOACODEC_DRV_NAME,\n\t\t.of_match_table = g12a_toacodec_of_match,\n\t},\n\t.probe = g12a_toacodec_probe,\n};\nmodule_platform_driver(g12a_toacodec_pdrv);\n\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic G12a To Internal DAC Codec Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}