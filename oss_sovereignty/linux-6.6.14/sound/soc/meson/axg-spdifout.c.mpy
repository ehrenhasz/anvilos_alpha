{
  "module_name": "axg-spdifout.c",
  "hash_id": "09b2cb7c7712f6c8115341781fba4fdc4bad6f2b3c70fa30de40d84e6151fd4e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-spdifout.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm_iec958.h>\n\n \n\n#define SPDIFOUT_STAT\t\t\t0x00\n#define SPDIFOUT_GAIN0\t\t\t0x04\n#define SPDIFOUT_GAIN1\t\t\t0x08\n#define SPDIFOUT_CTRL0\t\t\t0x0c\n#define  SPDIFOUT_CTRL0_EN\t\tBIT(31)\n#define  SPDIFOUT_CTRL0_RST_OUT\t\tBIT(29)\n#define  SPDIFOUT_CTRL0_RST_IN\t\tBIT(28)\n#define  SPDIFOUT_CTRL0_USEL\t\tBIT(26)\n#define  SPDIFOUT_CTRL0_USET\t\tBIT(25)\n#define  SPDIFOUT_CTRL0_CHSTS_SEL\tBIT(24)\n#define  SPDIFOUT_CTRL0_DATA_SEL\tBIT(20)\n#define  SPDIFOUT_CTRL0_MSB_FIRST\tBIT(19)\n#define  SPDIFOUT_CTRL0_VSEL\t\tBIT(18)\n#define  SPDIFOUT_CTRL0_VSET\t\tBIT(17)\n#define  SPDIFOUT_CTRL0_MASK_MASK\tGENMASK(11, 4)\n#define  SPDIFOUT_CTRL0_MASK(x)\t\t((x) << 4)\n#define SPDIFOUT_CTRL1\t\t\t0x10\n#define  SPDIFOUT_CTRL1_MSB_POS_MASK\tGENMASK(12, 8)\n#define  SPDIFOUT_CTRL1_MSB_POS(x)\t((x) << 8)\n#define  SPDIFOUT_CTRL1_TYPE_MASK\tGENMASK(6, 4)\n#define  SPDIFOUT_CTRL1_TYPE(x)\t\t((x) << 4)\n#define SPDIFOUT_PREAMB\t\t\t0x14\n#define SPDIFOUT_SWAP\t\t\t0x18\n#define SPDIFOUT_CHSTS0\t\t\t0x1c\n#define SPDIFOUT_CHSTS1\t\t\t0x20\n#define SPDIFOUT_CHSTS2\t\t\t0x24\n#define SPDIFOUT_CHSTS3\t\t\t0x28\n#define SPDIFOUT_CHSTS4\t\t\t0x2c\n#define SPDIFOUT_CHSTS5\t\t\t0x30\n#define SPDIFOUT_CHSTS6\t\t\t0x34\n#define SPDIFOUT_CHSTS7\t\t\t0x38\n#define SPDIFOUT_CHSTS8\t\t\t0x3c\n#define SPDIFOUT_CHSTS9\t\t\t0x40\n#define SPDIFOUT_CHSTSA\t\t\t0x44\n#define SPDIFOUT_CHSTSB\t\t\t0x48\n#define SPDIFOUT_MUTE_VAL\t\t0x4c\n\nstruct axg_spdifout {\n\tstruct regmap *map;\n\tstruct clk *mclk;\n\tstruct clk *pclk;\n};\n\nstatic void axg_spdifout_enable(struct regmap *map)\n{\n\t \n\tregmap_update_bits(map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_RST_OUT | SPDIFOUT_CTRL0_RST_IN,\n\t\t\t   0);\n\n\t \n\tregmap_update_bits(map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_RST_OUT, SPDIFOUT_CTRL0_RST_OUT);\n\tregmap_update_bits(map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_RST_IN,  SPDIFOUT_CTRL0_RST_IN);\n\n\t \n\tregmap_update_bits(map, SPDIFOUT_CTRL0, SPDIFOUT_CTRL0_EN,\n\t\t\t   SPDIFOUT_CTRL0_EN);\n}\n\nstatic void axg_spdifout_disable(struct regmap *map)\n{\n\tregmap_update_bits(map, SPDIFOUT_CTRL0, SPDIFOUT_CTRL0_EN, 0);\n}\n\nstatic int axg_spdifout_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\taxg_spdifout_enable(priv->map);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\taxg_spdifout_disable(priv->map);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int axg_spdifout_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL0, SPDIFOUT_CTRL0_VSET,\n\t\t\t   mute ? SPDIFOUT_CTRL0_VSET : 0);\n\n\treturn 0;\n}\n\nstatic int axg_spdifout_sample_fmt(struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int val;\n\n\t \n\tswitch (params_channels(params)) {\n\tcase 1:\n\t\tval = SPDIFOUT_CTRL0_MASK(0x1);\n\t\tbreak;\n\tcase 2:\n\t\tval = SPDIFOUT_CTRL0_MASK(0x3);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"too many channels for spdif dai: %u\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_MASK_MASK, val);\n\n\t \n\tswitch (params_physical_width(params)) {\n\tcase 8:\n\t\t \n\t\tval = SPDIFOUT_CTRL1_TYPE(0);\n\t\tbreak;\n\tcase 16:\n\t\t \n\t\tval = SPDIFOUT_CTRL1_TYPE(2);\n\t\tbreak;\n\tcase 32:\n\t\t \n\t\tval = SPDIFOUT_CTRL1_TYPE(4);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported physical width: %u\\n\",\n\t\t\tparams_physical_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval |= SPDIFOUT_CTRL1_MSB_POS(params_width(params) - 1);\n\n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL1,\n\t\t\t   SPDIFOUT_CTRL1_MSB_POS_MASK |\n\t\t\t   SPDIFOUT_CTRL1_TYPE_MASK, val);\n\n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_MSB_FIRST | SPDIFOUT_CTRL0_DATA_SEL,\n\t\t\t   0);\n\n\treturn 0;\n}\n\nstatic int axg_spdifout_set_chsts(struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int offset;\n\tint ret;\n\tu8 cs[4];\n\tu32 val;\n\n\tret = snd_pcm_create_iec958_consumer_hw_params(params, cs, 4);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Creating IEC958 channel status failed %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tval = cs[0] | cs[1] << 8 | cs[2] << 16 | cs[3] << 24;\n\n\t \n\tregmap_write(priv->map, SPDIFOUT_CHSTS0, val);\n\n\t \n\tfor (offset = SPDIFOUT_CHSTS1; offset <= SPDIFOUT_CHSTS5;\n\t     offset += regmap_get_reg_stride(priv->map))\n\t\tregmap_write(priv->map, offset, 0);\n\n\t \n\tregmap_write(priv->map, SPDIFOUT_CHSTS6, val);\n\n\t \n\tfor (offset = SPDIFOUT_CHSTS7; offset <= SPDIFOUT_CHSTSB;\n\t     offset += regmap_get_reg_stride(priv->map))\n\t\tregmap_write(priv->map, offset, 0);\n\n\treturn 0;\n}\n\nstatic int axg_spdifout_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int rate = params_rate(params);\n\tint ret;\n\n\t \n\tret = clk_set_rate(priv->mclk, rate * 128);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to set spdif clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axg_spdifout_sample_fmt(params, dai);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to setup sample format\\n\");\n\t\treturn ret;\n\t}\n\n\tret = axg_spdifout_set_chsts(params, dai);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to setup channel status words\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_spdifout_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to enable pclk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\taxg_spdifout_disable(priv->map);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_MSB_FIRST | SPDIFOUT_CTRL0_DATA_SEL,\n\t\t\t   0);\n\n\t \n\tregmap_update_bits(priv->map, SPDIFOUT_CTRL0,\n\t\t\t   SPDIFOUT_CTRL0_CHSTS_SEL | SPDIFOUT_CTRL0_VSEL |\n\t\t\t   SPDIFOUT_CTRL0_USEL | SPDIFOUT_CTRL0_USET,\n\t\t\t   0);\n\n\t \n\tregmap_write(priv->map, SPDIFOUT_SWAP, 0x10);\n\n\treturn 0;\n}\n\nstatic void axg_spdifout_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct axg_spdifout *priv = snd_soc_dai_get_drvdata(dai);\n\n\tclk_disable_unprepare(priv->pclk);\n}\n\nstatic const struct snd_soc_dai_ops axg_spdifout_ops = {\n\t.trigger\t= axg_spdifout_trigger,\n\t.mute_stream\t= axg_spdifout_mute,\n\t.hw_params\t= axg_spdifout_hw_params,\n\t.startup\t= axg_spdifout_startup,\n\t.shutdown\t= axg_spdifout_shutdown,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver axg_spdifout_dai_drv[] = {\n\t{\n\t\t.name = \"SPDIF Output\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"Playback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 2,\n\t\t\t.rates\t\t= (SNDRV_PCM_RATE_32000  |\n\t\t\t\t\t   SNDRV_PCM_RATE_44100  |\n\t\t\t\t\t   SNDRV_PCM_RATE_48000  |\n\t\t\t\t\t   SNDRV_PCM_RATE_88200  |\n\t\t\t\t\t   SNDRV_PCM_RATE_96000  |\n\t\t\t\t\t   SNDRV_PCM_RATE_176400 |\n\t\t\t\t\t   SNDRV_PCM_RATE_192000),\n\t\t\t.formats\t= (SNDRV_PCM_FMTBIT_S8     |\n\t\t\t\t\t   SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t\t   SNDRV_PCM_FMTBIT_S20_LE |\n\t\t\t\t\t   SNDRV_PCM_FMTBIT_S24_LE),\n\t\t},\n\t\t.ops = &axg_spdifout_ops,\n\t},\n};\n\nstatic const char * const spdifout_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(axg_spdifout_sel_enum, SPDIFOUT_CTRL1, 24,\n\t\t\t    spdifout_sel_texts);\n\nstatic const struct snd_kcontrol_new axg_spdifout_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", axg_spdifout_sel_enum);\n\nstatic const struct snd_soc_dapm_widget axg_spdifout_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &axg_spdifout_in_mux),\n};\n\nstatic const struct snd_soc_dapm_route axg_spdifout_dapm_routes[] = {\n\t{ \"SRC SEL\", \"IN 0\", \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\", \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\", \"IN 2\" },\n\t{ \"Playback\", NULL, \"SRC SEL\" },\n};\n\nstatic const struct snd_kcontrol_new axg_spdifout_controls[] = {\n\tSOC_DOUBLE(\"Playback Volume\", SPDIFOUT_GAIN0,  0,  8, 255, 0),\n\tSOC_DOUBLE(\"Playback Switch\", SPDIFOUT_CTRL0, 22, 21, 1, 1),\n\tSOC_SINGLE(\"Playback Gain Enable Switch\",\n\t\t   SPDIFOUT_CTRL1, 26, 1, 0),\n\tSOC_SINGLE(\"Playback Channels Mix Switch\",\n\t\t   SPDIFOUT_CTRL0, 23, 1, 0),\n};\n\nstatic int axg_spdifout_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tstruct axg_spdifout *priv = snd_soc_component_get_drvdata(component);\n\tenum snd_soc_bias_level now =\n\t\tsnd_soc_component_get_bias_level(component);\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (now == SND_SOC_BIAS_STANDBY)\n\t\t\tret = clk_prepare_enable(priv->mclk);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (now == SND_SOC_BIAS_PREPARE)\n\t\t\tclk_disable_unprepare(priv->mclk);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver axg_spdifout_component_drv = {\n\t.controls\t\t= axg_spdifout_controls,\n\t.num_controls\t\t= ARRAY_SIZE(axg_spdifout_controls),\n\t.dapm_widgets\t\t= axg_spdifout_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_spdifout_dapm_widgets),\n\t.dapm_routes\t\t= axg_spdifout_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_spdifout_dapm_routes),\n\t.set_bias_level\t\t= axg_spdifout_set_bias_level,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct regmap_config axg_spdifout_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= SPDIFOUT_MUTE_VAL,\n};\n\nstatic const struct of_device_id axg_spdifout_of_match[] = {\n\t{ .compatible = \"amlogic,axg-spdifout\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, axg_spdifout_of_match);\n\nstatic int axg_spdifout_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct axg_spdifout *priv;\n\tvoid __iomem *regs;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->map = devm_regmap_init_mmio(dev, regs, &axg_spdifout_regmap_cfg);\n\tif (IS_ERR(priv->map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(priv->map));\n\t\treturn PTR_ERR(priv->map);\n\t}\n\n\tpriv->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->pclk), \"failed to get pclk\\n\");\n\n\tpriv->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(priv->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->mclk), \"failed to get mclk\\n\");\n\n\treturn devm_snd_soc_register_component(dev, &axg_spdifout_component_drv,\n\t\t\taxg_spdifout_dai_drv, ARRAY_SIZE(axg_spdifout_dai_drv));\n}\n\nstatic struct platform_driver axg_spdifout_pdrv = {\n\t.probe = axg_spdifout_probe,\n\t.driver = {\n\t\t.name = \"axg-spdifout\",\n\t\t.of_match_table = axg_spdifout_of_match,\n\t},\n};\nmodule_platform_driver(axg_spdifout_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG SPDIF Output driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}