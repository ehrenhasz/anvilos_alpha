{
  "module_name": "g12a-tohdmitx.c",
  "hash_id": "09e6a75d5554641b9925c55ec0d8ad9f9dcfa6a5b9830f935bf0af8a0e3213d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/g12a-tohdmitx.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/meson-g12a-tohdmitx.h>\n#include \"meson-codec-glue.h\"\n\n#define G12A_TOHDMITX_DRV_NAME \"g12a-tohdmitx\"\n\n#define TOHDMITX_CTRL0\t\t\t0x0\n#define  CTRL0_ENABLE_SHIFT\t\t31\n#define  CTRL0_I2S_DAT_SEL_SHIFT\t12\n#define  CTRL0_I2S_DAT_SEL\t\t(0x3 << CTRL0_I2S_DAT_SEL_SHIFT)\n#define  CTRL0_I2S_LRCLK_SEL\t\tGENMASK(9, 8)\n#define  CTRL0_I2S_BLK_CAP_INV\t\tBIT(7)\n#define  CTRL0_I2S_BCLK_O_INV\t\tBIT(6)\n#define  CTRL0_I2S_BCLK_SEL\t\tGENMASK(5, 4)\n#define  CTRL0_SPDIF_CLK_CAP_INV\tBIT(3)\n#define  CTRL0_SPDIF_CLK_O_INV\t\tBIT(2)\n#define  CTRL0_SPDIF_SEL_SHIFT\t\t1\n#define  CTRL0_SPDIF_SEL\t\t(0x1 << CTRL0_SPDIF_SEL_SHIFT)\n#define  CTRL0_SPDIF_CLK_SEL\t\tBIT(0)\n\nstatic const char * const g12a_tohdmitx_i2s_mux_texts[] = {\n\t\"I2S A\", \"I2S B\", \"I2S C\",\n};\n\nstatic int g12a_tohdmitx_i2s_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int mux, changed;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tmux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);\n\tchanged = snd_soc_component_test_bits(component, e->reg,\n\t\t\t\t\t      CTRL0_I2S_DAT_SEL,\n\t\t\t\t\t      FIELD_PREP(CTRL0_I2S_DAT_SEL,\n\t\t\t\t\t\t\t mux));\n\n\tif (!changed)\n\t\treturn 0;\n\n\t \n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);\n\n\tsnd_soc_component_update_bits(component, e->reg,\n\t\t\t\t      CTRL0_I2S_DAT_SEL |\n\t\t\t\t      CTRL0_I2S_LRCLK_SEL |\n\t\t\t\t      CTRL0_I2S_BCLK_SEL,\n\t\t\t\t      FIELD_PREP(CTRL0_I2S_DAT_SEL, mux) |\n\t\t\t\t      FIELD_PREP(CTRL0_I2S_LRCLK_SEL, mux) |\n\t\t\t\t      FIELD_PREP(CTRL0_I2S_BCLK_SEL, mux));\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_DECL(g12a_tohdmitx_i2s_mux_enum, TOHDMITX_CTRL0,\n\t\t\t    CTRL0_I2S_DAT_SEL_SHIFT,\n\t\t\t    g12a_tohdmitx_i2s_mux_texts);\n\nstatic const struct snd_kcontrol_new g12a_tohdmitx_i2s_mux =\n\tSOC_DAPM_ENUM_EXT(\"I2S Source\", g12a_tohdmitx_i2s_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  g12a_tohdmitx_i2s_mux_put_enum);\n\nstatic const char * const g12a_tohdmitx_spdif_mux_texts[] = {\n\t\"SPDIF A\", \"SPDIF B\",\n};\n\nstatic int g12a_tohdmitx_spdif_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int mux, changed;\n\n\tif (ucontrol->value.enumerated.item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tmux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);\n\tchanged = snd_soc_component_test_bits(component, TOHDMITX_CTRL0,\n\t\t\t\t\t      CTRL0_SPDIF_SEL,\n\t\t\t\t\t      FIELD_PREP(CTRL0_SPDIF_SEL, mux));\n\n\tif (!changed)\n\t\treturn 0;\n\n\t \n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);\n\n\tsnd_soc_component_update_bits(component, TOHDMITX_CTRL0,\n\t\t\t\t      CTRL0_SPDIF_SEL |\n\t\t\t\t      CTRL0_SPDIF_CLK_SEL,\n\t\t\t\t      FIELD_PREP(CTRL0_SPDIF_SEL, mux) |\n\t\t\t\t      FIELD_PREP(CTRL0_SPDIF_CLK_SEL, mux));\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_DECL(g12a_tohdmitx_spdif_mux_enum, TOHDMITX_CTRL0,\n\t\t\t    CTRL0_SPDIF_SEL_SHIFT,\n\t\t\t    g12a_tohdmitx_spdif_mux_texts);\n\nstatic const struct snd_kcontrol_new g12a_tohdmitx_spdif_mux =\n\tSOC_DAPM_ENUM_EXT(\"SPDIF Source\", g12a_tohdmitx_spdif_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  g12a_tohdmitx_spdif_mux_put_enum);\n\nstatic const struct snd_kcontrol_new g12a_tohdmitx_out_enable =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", TOHDMITX_CTRL0,\n\t\t\t\t    CTRL0_ENABLE_SHIFT, 1, 0);\n\nstatic const struct snd_soc_dapm_widget g12a_tohdmitx_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"I2S SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &g12a_tohdmitx_i2s_mux),\n\tSND_SOC_DAPM_SWITCH(\"I2S OUT EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &g12a_tohdmitx_out_enable),\n\tSND_SOC_DAPM_MUX(\"SPDIF SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &g12a_tohdmitx_spdif_mux),\n\tSND_SOC_DAPM_SWITCH(\"SPDIF OUT EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &g12a_tohdmitx_out_enable),\n};\n\nstatic const struct snd_soc_dai_ops g12a_tohdmitx_input_ops = {\n\t.probe\t\t= meson_codec_glue_input_dai_probe,\n\t.remove\t\t= meson_codec_glue_input_dai_remove,\n\t.hw_params\t= meson_codec_glue_input_hw_params,\n\t.set_fmt\t= meson_codec_glue_input_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops g12a_tohdmitx_output_ops = {\n\t.startup\t= meson_codec_glue_output_startup,\n};\n\n#define TOHDMITX_SPDIF_FORMATS\t\t\t\t\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\n#define TOHDMITX_I2S_FORMATS\t\t\t\t\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t SNDRV_PCM_FMTBIT_S32_LE)\n\n#define TOHDMITX_STREAM(xname, xsuffix, xfmt, xchmax)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.stream_name\t= xname \" \" xsuffix,\t\t\t\\\n\t.channels_min\t= 1,\t\t\t\t\t\\\n\t.channels_max\t= (xchmax),\t\t\t\t\\\n\t.rate_min       = 8000,\t\t\t\t\t\\\n\t.rate_max\t= 192000,\t\t\t\t\\\n\t.formats\t= (xfmt),\t\t\t\t\\\n}\n\n#define TOHDMITX_IN(xname, xid, xfmt, xchmax) {\t\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.id = (xid),\t\t\t\t\t\t\t\\\n\t.playback = TOHDMITX_STREAM(xname, \"Playback\", xfmt, xchmax),\t\\\n\t.ops = &g12a_tohdmitx_input_ops,\t\t\t\t\\\n}\n\n#define TOHDMITX_OUT(xname, xid, xfmt, xchmax) {\t\t\t\\\n\t.name = xname,\t\t\t\t\t\t\t\\\n\t.id = (xid),\t\t\t\t\t\t\t\\\n\t.capture = TOHDMITX_STREAM(xname, \"Capture\", xfmt, xchmax),\t\\\n\t.ops = &g12a_tohdmitx_output_ops,\t\t\t\t\\\n}\n\nstatic struct snd_soc_dai_driver g12a_tohdmitx_dai_drv[] = {\n\tTOHDMITX_IN(\"I2S IN A\", TOHDMITX_I2S_IN_A,\n\t\t    TOHDMITX_I2S_FORMATS, 8),\n\tTOHDMITX_IN(\"I2S IN B\", TOHDMITX_I2S_IN_B,\n\t\t    TOHDMITX_I2S_FORMATS, 8),\n\tTOHDMITX_IN(\"I2S IN C\", TOHDMITX_I2S_IN_C,\n\t\t    TOHDMITX_I2S_FORMATS, 8),\n\tTOHDMITX_OUT(\"I2S OUT\", TOHDMITX_I2S_OUT,\n\t\t     TOHDMITX_I2S_FORMATS, 8),\n\tTOHDMITX_IN(\"SPDIF IN A\", TOHDMITX_SPDIF_IN_A,\n\t\t    TOHDMITX_SPDIF_FORMATS, 2),\n\tTOHDMITX_IN(\"SPDIF IN B\", TOHDMITX_SPDIF_IN_B,\n\t\t    TOHDMITX_SPDIF_FORMATS, 2),\n\tTOHDMITX_OUT(\"SPDIF OUT\", TOHDMITX_SPDIF_OUT,\n\t\t     TOHDMITX_SPDIF_FORMATS, 2),\n};\n\nstatic int g12a_tohdmi_component_probe(struct snd_soc_component *c)\n{\n\t \n\treturn snd_soc_component_write(c, TOHDMITX_CTRL0,\n\t\t     CTRL0_I2S_BLK_CAP_INV | CTRL0_SPDIF_CLK_CAP_INV);\n}\n\nstatic const struct snd_soc_dapm_route g12a_tohdmitx_routes[] = {\n\t{ \"I2S SRC\", \"I2S A\", \"I2S IN A Playback\" },\n\t{ \"I2S SRC\", \"I2S B\", \"I2S IN B Playback\" },\n\t{ \"I2S SRC\", \"I2S C\", \"I2S IN C Playback\" },\n\t{ \"I2S OUT EN\", \"Switch\", \"I2S SRC\" },\n\t{ \"I2S OUT Capture\", NULL, \"I2S OUT EN\" },\n\t{ \"SPDIF SRC\", \"SPDIF A\", \"SPDIF IN A Playback\" },\n\t{ \"SPDIF SRC\", \"SPDIF B\", \"SPDIF IN B Playback\" },\n\t{ \"SPDIF OUT EN\", \"Switch\", \"SPDIF SRC\" },\n\t{ \"SPDIF OUT Capture\", NULL, \"SPDIF OUT EN\" },\n};\n\nstatic const struct snd_soc_component_driver g12a_tohdmitx_component_drv = {\n\t.probe\t\t\t= g12a_tohdmi_component_probe,\n\t.dapm_widgets\t\t= g12a_tohdmitx_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(g12a_tohdmitx_widgets),\n\t.dapm_routes\t\t= g12a_tohdmitx_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(g12a_tohdmitx_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config g12a_tohdmitx_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n};\n\nstatic const struct of_device_id g12a_tohdmitx_of_match[] = {\n\t{ .compatible = \"amlogic,g12a-tohdmitx\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, g12a_tohdmitx_of_match);\n\nstatic int g12a_tohdmitx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *regs;\n\tstruct regmap *map;\n\tint ret;\n\n\tret = device_reset(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tmap = devm_regmap_init_mmio(dev, regs, &g12a_tohdmitx_regmap_cfg);\n\tif (IS_ERR(map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(map));\n\t\treturn PTR_ERR(map);\n\t}\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t&g12a_tohdmitx_component_drv, g12a_tohdmitx_dai_drv,\n\t\t\tARRAY_SIZE(g12a_tohdmitx_dai_drv));\n}\n\nstatic struct platform_driver g12a_tohdmitx_pdrv = {\n\t.driver = {\n\t\t.name = G12A_TOHDMITX_DRV_NAME,\n\t\t.of_match_table = g12a_tohdmitx_of_match,\n\t},\n\t.probe = g12a_tohdmitx_probe,\n};\nmodule_platform_driver(g12a_tohdmitx_pdrv);\n\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_DESCRIPTION(\"Amlogic G12a To HDMI Tx Control Codec Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}