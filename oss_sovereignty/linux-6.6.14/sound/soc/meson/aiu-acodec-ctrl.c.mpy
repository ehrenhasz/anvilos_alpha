{
  "module_name": "aiu-acodec-ctrl.c",
  "hash_id": "47306564983fc972df3bc2e03d9db1b8bbfdab141574d75cc4a6acc231359f38",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/aiu-acodec-ctrl.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include <dt-bindings/sound/meson-aiu.h>\n#include \"aiu.h\"\n#include \"meson-codec-glue.h\"\n\n#define CTRL_DIN_EN\t\t\t15\n#define CTRL_CLK_INV\t\t\tBIT(14)\n#define CTRL_LRCLK_INV\t\t\tBIT(13)\n#define CTRL_I2S_IN_BCLK_SRC\t\tBIT(11)\n#define CTRL_DIN_LRCLK_SRC_SHIFT\t6\n#define CTRL_DIN_LRCLK_SRC\t\t(0x3 << CTRL_DIN_LRCLK_SRC_SHIFT)\n#define CTRL_BCLK_MCLK_SRC\t\tGENMASK(5, 4)\n#define CTRL_DIN_SKEW\t\t\tGENMASK(3, 2)\n#define CTRL_I2S_OUT_LANE_SRC\t\t0\n\n#define AIU_ACODEC_OUT_CHMAX\t\t2\n\nstatic const char * const aiu_acodec_ctrl_mux_texts[] = {\n\t\"DISABLED\", \"I2S\", \"PCM\",\n};\n\nstatic int aiu_acodec_ctrl_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int mux, changed;\n\n\tmux = snd_soc_enum_item_to_val(e, ucontrol->value.enumerated.item[0]);\n\tchanged = snd_soc_component_test_bits(component, e->reg,\n\t\t\t\t\t      CTRL_DIN_LRCLK_SRC,\n\t\t\t\t\t      FIELD_PREP(CTRL_DIN_LRCLK_SRC,\n\t\t\t\t\t\t\t mux));\n\n\tif (!changed)\n\t\treturn 0;\n\n\t \n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, 0, NULL, NULL);\n\n\tsnd_soc_component_update_bits(component, e->reg,\n\t\t\t\t      CTRL_DIN_LRCLK_SRC |\n\t\t\t\t      CTRL_BCLK_MCLK_SRC,\n\t\t\t\t      FIELD_PREP(CTRL_DIN_LRCLK_SRC, mux) |\n\t\t\t\t      FIELD_PREP(CTRL_BCLK_MCLK_SRC, mux));\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, mux, e, NULL);\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_DECL(aiu_acodec_ctrl_mux_enum, AIU_ACODEC_CTRL,\n\t\t\t    CTRL_DIN_LRCLK_SRC_SHIFT,\n\t\t\t    aiu_acodec_ctrl_mux_texts);\n\nstatic const struct snd_kcontrol_new aiu_acodec_ctrl_mux =\n\tSOC_DAPM_ENUM_EXT(\"ACodec Source\", aiu_acodec_ctrl_mux_enum,\n\t\t\t  snd_soc_dapm_get_enum_double,\n\t\t\t  aiu_acodec_ctrl_mux_put_enum);\n\nstatic const struct snd_kcontrol_new aiu_acodec_ctrl_out_enable =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", AIU_ACODEC_CTRL,\n\t\t\t\t    CTRL_DIN_EN, 1, 0);\n\nstatic const struct snd_soc_dapm_widget aiu_acodec_ctrl_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"ACODEC SRC\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aiu_acodec_ctrl_mux),\n\tSND_SOC_DAPM_SWITCH(\"ACODEC OUT EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aiu_acodec_ctrl_out_enable),\n};\n\nstatic int aiu_acodec_ctrl_input_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct meson_codec_glue_input *data;\n\tint ret;\n\n\tret = meson_codec_glue_input_hw_params(substream, params, dai);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdata = meson_codec_glue_input_get_data(dai);\n\tdata->params.channels_min = min_t(unsigned int, AIU_ACODEC_OUT_CHMAX,\n\t\t\t\t\t  data->params.channels_min);\n\tdata->params.channels_max = min_t(unsigned int, AIU_ACODEC_OUT_CHMAX,\n\t\t\t\t\t  data->params.channels_max);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops aiu_acodec_ctrl_input_ops = {\n\t.probe\t\t= meson_codec_glue_input_dai_probe,\n\t.remove\t\t= meson_codec_glue_input_dai_remove,\n\t.hw_params\t= aiu_acodec_ctrl_input_hw_params,\n\t.set_fmt\t= meson_codec_glue_input_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops aiu_acodec_ctrl_output_ops = {\n\t.startup\t= meson_codec_glue_output_startup,\n};\n\n#define AIU_ACODEC_CTRL_FORMATS\t\t\t\t\t\\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\t\\\n\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE |\t\\\n\t SNDRV_PCM_FMTBIT_S32_LE)\n\n#define AIU_ACODEC_STREAM(xname, xsuffix, xchmax)\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\t.stream_name\t= xname \" \" xsuffix,\t\t\t\\\n\t.channels_min\t= 1,\t\t\t\t\t\\\n\t.channels_max\t= (xchmax),\t\t\t\t\\\n\t.rate_min       = 5512,\t\t\t\t\t\\\n\t.rate_max\t= 192000,\t\t\t\t\\\n\t.formats\t= AIU_ACODEC_CTRL_FORMATS,\t\t\\\n}\n\n#define AIU_ACODEC_INPUT(xname) {\t\t\t\t\\\n\t.name = \"ACODEC CTRL \" xname,\t\t\t\t\\\n\t.playback = AIU_ACODEC_STREAM(xname, \"Playback\", 8),\t\\\n\t.ops = &aiu_acodec_ctrl_input_ops,\t\t\t\\\n}\n\n#define AIU_ACODEC_OUTPUT(xname) {\t\t\t\t\\\n\t.name = \"ACODEC CTRL \" xname,\t\t\t\t\\\n\t.capture = AIU_ACODEC_STREAM(xname, \"Capture\", AIU_ACODEC_OUT_CHMAX), \\\n\t.ops = &aiu_acodec_ctrl_output_ops,\t\t\t\\\n}\n\nstatic struct snd_soc_dai_driver aiu_acodec_ctrl_dai_drv[] = {\n\t[CTRL_I2S] = AIU_ACODEC_INPUT(\"ACODEC I2S IN\"),\n\t[CTRL_PCM] = AIU_ACODEC_INPUT(\"ACODEC PCM IN\"),\n\t[CTRL_OUT] = AIU_ACODEC_OUTPUT(\"ACODEC OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route aiu_acodec_ctrl_routes[] = {\n\t{ \"ACODEC SRC\", \"I2S\", \"ACODEC I2S IN Playback\" },\n\t{ \"ACODEC SRC\", \"PCM\", \"ACODEC PCM IN Playback\" },\n\t{ \"ACODEC OUT EN\", \"Switch\", \"ACODEC SRC\" },\n\t{ \"ACODEC OUT Capture\", NULL, \"ACODEC OUT EN\" },\n};\n\nstatic const struct snd_kcontrol_new aiu_acodec_ctrl_controls[] = {\n\tSOC_SINGLE(\"ACODEC I2S Lane Select\", AIU_ACODEC_CTRL,\n\t\t   CTRL_I2S_OUT_LANE_SRC, 3, 0),\n};\n\nstatic int aiu_acodec_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t\tconst struct of_phandle_args *args,\n\t\t\t\t\tconst char **dai_name)\n{\n\treturn aiu_of_xlate_dai_name(component, args, dai_name, AIU_ACODEC);\n}\n\nstatic int aiu_acodec_ctrl_component_probe(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_update_bits(component, AIU_ACODEC_CTRL,\n\t\t\t\t      CTRL_DIN_SKEW,\n\t\t\t\t      FIELD_PREP(CTRL_DIN_SKEW, 2));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver aiu_acodec_ctrl_component = {\n\t.name\t\t\t= \"AIU Internal DAC Codec Control\",\n\t.probe\t\t\t= aiu_acodec_ctrl_component_probe,\n\t.controls\t\t= aiu_acodec_ctrl_controls,\n\t.num_controls\t\t= ARRAY_SIZE(aiu_acodec_ctrl_controls),\n\t.dapm_widgets\t\t= aiu_acodec_ctrl_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aiu_acodec_ctrl_widgets),\n\t.dapm_routes\t\t= aiu_acodec_ctrl_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aiu_acodec_ctrl_routes),\n\t.of_xlate_dai_name\t= aiu_acodec_of_xlate_dai_name,\n\t.endianness\t\t= 1,\n#ifdef CONFIG_DEBUG_FS\n\t.debugfs_prefix\t\t= \"acodec\",\n#endif\n};\n\nint aiu_acodec_ctrl_register_component(struct device *dev)\n{\n\treturn snd_soc_register_component(dev, &aiu_acodec_ctrl_component,\n\t\t\t\t\t  aiu_acodec_ctrl_dai_drv,\n\t\t\t\t\t  ARRAY_SIZE(aiu_acodec_ctrl_dai_drv));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}