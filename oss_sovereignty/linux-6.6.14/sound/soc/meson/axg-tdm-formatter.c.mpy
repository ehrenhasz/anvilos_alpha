{
  "module_name": "axg-tdm-formatter.c",
  "hash_id": "b2ef1c4aa103e302c631936eeafbf29c266a502dc97121cbb1faf0212b42e246",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-tdm-formatter.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/soc.h>\n\n#include \"axg-tdm-formatter.h\"\n\nstruct axg_tdm_formatter {\n\tstruct list_head list;\n\tstruct axg_tdm_stream *stream;\n\tconst struct axg_tdm_formatter_driver *drv;\n\tstruct clk *pclk;\n\tstruct clk *sclk;\n\tstruct clk *lrclk;\n\tstruct clk *sclk_sel;\n\tstruct clk *lrclk_sel;\n\tstruct reset_control *reset;\n\tbool enabled;\n\tstruct regmap *map;\n};\n\nint axg_tdm_formatter_set_channel_masks(struct regmap *map,\n\t\t\t\t\tstruct axg_tdm_stream *ts,\n\t\t\t\t\tunsigned int offset)\n{\n\tunsigned int ch = ts->channels;\n\tu32 val[AXG_TDM_NUM_LANES];\n\tint i, j, k;\n\n\t \n\tmemset(val, 0, sizeof(*val) * AXG_TDM_NUM_LANES);\n\n\t \n\tfor (i = 0; (i < 32) && ch; i += 2) {\n\t\t \n\t\tfor (j = 0; j < AXG_TDM_NUM_LANES; j++) {\n\t\t\t \n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\tif ((BIT(i + k) & ts->mask[j]) && ch) {\n\t\t\t\t\tval[j] |= BIT(i + k);\n\t\t\t\t\tch -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (WARN_ON(ch != 0)) {\n\t\tpr_err(\"channel mask error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < AXG_TDM_NUM_LANES; i++) {\n\t\tregmap_write(map, offset, val[i]);\n\t\toffset += regmap_get_reg_stride(map);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_tdm_formatter_set_channel_masks);\n\nstatic int axg_tdm_formatter_enable(struct axg_tdm_formatter *formatter)\n{\n\tstruct axg_tdm_stream *ts = formatter->stream;\n\tbool invert;\n\tint ret;\n\n\t \n\tif (formatter->enabled)\n\t\treturn 0;\n\n\t \n\tret = reset_control_reset(formatter->reset);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tinvert = axg_tdm_sclk_invert(ts->iface->fmt);\n\tret = clk_set_phase(formatter->sclk, invert ? 0 : 180);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = formatter->drv->ops->prepare(formatter->map,\n\t\t\t\t\t   formatter->drv->quirks,\n\t\t\t\t\t   formatter->stream);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_prepare_enable(formatter->sclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(formatter->lrclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(formatter->sclk);\n\t\treturn ret;\n\t}\n\n\t \n\tformatter->drv->ops->enable(formatter->map);\n\tformatter->enabled = true;\n\n\treturn 0;\n}\n\nstatic void axg_tdm_formatter_disable(struct axg_tdm_formatter *formatter)\n{\n\t \n\tif (!formatter->enabled)\n\t\treturn;\n\n\tformatter->drv->ops->disable(formatter->map);\n\tclk_disable_unprepare(formatter->lrclk);\n\tclk_disable_unprepare(formatter->sclk);\n\tformatter->enabled = false;\n}\n\nstatic int axg_tdm_formatter_attach(struct axg_tdm_formatter *formatter)\n{\n\tstruct axg_tdm_stream *ts = formatter->stream;\n\tint ret = 0;\n\n\tmutex_lock(&ts->lock);\n\n\t \n\tif (ts->ready) {\n\t\tret = axg_tdm_formatter_enable(formatter);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to enable formatter\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_add_tail(&formatter->list, &ts->formatter_list);\nout:\n\tmutex_unlock(&ts->lock);\n\treturn ret;\n}\n\nstatic void axg_tdm_formatter_dettach(struct axg_tdm_formatter *formatter)\n{\n\tstruct axg_tdm_stream *ts = formatter->stream;\n\n\tmutex_lock(&ts->lock);\n\tlist_del(&formatter->list);\n\tmutex_unlock(&ts->lock);\n\n\taxg_tdm_formatter_disable(formatter);\n}\n\nstatic int axg_tdm_formatter_power_up(struct axg_tdm_formatter *formatter,\n\t\t\t\t      struct snd_soc_dapm_widget *w)\n{\n\tstruct axg_tdm_stream *ts = formatter->drv->ops->get_stream(w);\n\tint ret;\n\n\t \n\tif (WARN_ON(!ts))\n\t\treturn -ENODEV;\n\n\t \n\tret = clk_prepare_enable(formatter->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_set_parent(formatter->sclk_sel, ts->iface->sclk);\n\tif (ret)\n\t\tgoto disable_pclk;\n\n\t \n\tret = clk_set_parent(formatter->lrclk_sel, ts->iface->lrclk);\n\tif (ret)\n\t\tgoto disable_pclk;\n\n\tformatter->stream = ts;\n\tret = axg_tdm_formatter_attach(formatter);\n\tif (ret)\n\t\tgoto disable_pclk;\n\n\treturn 0;\n\ndisable_pclk:\n\tclk_disable_unprepare(formatter->pclk);\n\treturn ret;\n}\n\nstatic void axg_tdm_formatter_power_down(struct axg_tdm_formatter *formatter)\n{\n\taxg_tdm_formatter_dettach(formatter);\n\tclk_disable_unprepare(formatter->pclk);\n\tformatter->stream = NULL;\n}\n\nint axg_tdm_formatter_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *control,\n\t\t\t    int event)\n{\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct axg_tdm_formatter *formatter = snd_soc_component_get_drvdata(c);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = axg_tdm_formatter_power_up(formatter, w);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\taxg_tdm_formatter_power_down(formatter);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(c->dev, \"Unexpected event %d\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(axg_tdm_formatter_event);\n\nint axg_tdm_formatter_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct axg_tdm_formatter_driver *drv;\n\tstruct axg_tdm_formatter *formatter;\n\tvoid __iomem *regs;\n\n\tdrv = of_device_get_match_data(dev);\n\tif (!drv) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tformatter = devm_kzalloc(dev, sizeof(*formatter), GFP_KERNEL);\n\tif (!formatter)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, formatter);\n\tformatter->drv = drv;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tformatter->map = devm_regmap_init_mmio(dev, regs, drv->regmap_cfg);\n\tif (IS_ERR(formatter->map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(formatter->map));\n\t\treturn PTR_ERR(formatter->map);\n\t}\n\n\t \n\tformatter->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(formatter->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->pclk), \"failed to get pclk\\n\");\n\n\t \n\tformatter->sclk = devm_clk_get(dev, \"sclk\");\n\tif (IS_ERR(formatter->sclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->sclk), \"failed to get sclk\\n\");\n\n\t \n\tformatter->lrclk = devm_clk_get(dev, \"lrclk\");\n\tif (IS_ERR(formatter->lrclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->lrclk), \"failed to get lrclk\\n\");\n\n\t \n\tformatter->sclk_sel = devm_clk_get(dev, \"sclk_sel\");\n\tif (IS_ERR(formatter->sclk_sel))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->sclk_sel), \"failed to get sclk_sel\\n\");\n\n\t \n\tformatter->lrclk_sel = devm_clk_get(dev, \"lrclk_sel\");\n\tif (IS_ERR(formatter->lrclk_sel))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->lrclk_sel),\n\t\t\t\t     \"failed to get lrclk_sel\\n\");\n\n\t \n\tformatter->reset = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(formatter->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(formatter->reset), \"failed to get reset\\n\");\n\n\treturn devm_snd_soc_register_component(dev, drv->component_drv,\n\t\t\t\t\t       NULL, 0);\n}\nEXPORT_SYMBOL_GPL(axg_tdm_formatter_probe);\n\nint axg_tdm_stream_start(struct axg_tdm_stream *ts)\n{\n\tstruct axg_tdm_formatter *formatter;\n\tint ret = 0;\n\n\tmutex_lock(&ts->lock);\n\tts->ready = true;\n\n\t \n\tlist_for_each_entry(formatter, &ts->formatter_list, list) {\n\t\tret = axg_tdm_formatter_enable(formatter);\n\t\tif (ret) {\n\t\t\tpr_err(\"failed to start tdm stream\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&ts->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(axg_tdm_stream_start);\n\nvoid axg_tdm_stream_stop(struct axg_tdm_stream *ts)\n{\n\tstruct axg_tdm_formatter *formatter;\n\n\tmutex_lock(&ts->lock);\n\tts->ready = false;\n\n\t \n\tlist_for_each_entry(formatter, &ts->formatter_list, list) {\n\t\taxg_tdm_formatter_disable(formatter);\n\t}\n\n\tmutex_unlock(&ts->lock);\n}\nEXPORT_SYMBOL_GPL(axg_tdm_stream_stop);\n\nstruct axg_tdm_stream *axg_tdm_stream_alloc(struct axg_tdm_iface *iface)\n{\n\tstruct axg_tdm_stream *ts;\n\n\tts = kzalloc(sizeof(*ts), GFP_KERNEL);\n\tif (ts) {\n\t\tINIT_LIST_HEAD(&ts->formatter_list);\n\t\tmutex_init(&ts->lock);\n\t\tts->iface = iface;\n\t}\n\n\treturn ts;\n}\nEXPORT_SYMBOL_GPL(axg_tdm_stream_alloc);\n\nvoid axg_tdm_stream_free(struct axg_tdm_stream *ts)\n{\n\t \n\tWARN_ON(!list_empty(&ts->formatter_list));\n\tmutex_destroy(&ts->lock);\n\tkfree(ts);\n}\nEXPORT_SYMBOL_GPL(axg_tdm_stream_free);\n\nMODULE_DESCRIPTION(\"Amlogic AXG TDM formatter driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}