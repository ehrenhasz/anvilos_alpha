{
  "module_name": "axg-fifo.c",
  "hash_id": "02454b1dded218bf3e36cd9e8e2f6b18f6c7357ca7d70237ac7c958084cfc6ec",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-fifo.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-fifo.h\"\n\n \n\nstatic struct snd_pcm_hardware axg_fifo_hw = {\n\t.info = (SNDRV_PCM_INFO_INTERLEAVED |\n\t\t SNDRV_PCM_INFO_MMAP |\n\t\t SNDRV_PCM_INFO_MMAP_VALID |\n\t\t SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\t SNDRV_PCM_INFO_PAUSE |\n\t\t SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),\n\t.formats = AXG_FIFO_FORMATS,\n\t.rate_min = 5512,\n\t.rate_max = 192000,\n\t.channels_min = 1,\n\t.channels_max = AXG_FIFO_CH_MAX,\n\t.period_bytes_min = AXG_FIFO_BURST,\n\t.period_bytes_max = UINT_MAX,\n\t.periods_min = 2,\n\t.periods_max = UINT_MAX,\n\n\t \n\t.buffer_bytes_max = 1 * 1024 * 1024,\n};\n\nstatic struct snd_soc_dai *axg_fifo_dai(struct snd_pcm_substream *ss)\n{\n\tstruct snd_soc_pcm_runtime *rtd = ss->private_data;\n\n\treturn asoc_rtd_to_cpu(rtd, 0);\n}\n\nstatic struct axg_fifo *axg_fifo_data(struct snd_pcm_substream *ss)\n{\n\tstruct snd_soc_dai *dai = axg_fifo_dai(ss);\n\n\treturn snd_soc_dai_get_drvdata(dai);\n}\n\nstatic struct device *axg_fifo_dev(struct snd_pcm_substream *ss)\n{\n\tstruct snd_soc_dai *dai = axg_fifo_dai(ss);\n\n\treturn dai->dev;\n}\n\nstatic void __dma_enable(struct axg_fifo *fifo,  bool enable)\n{\n\tregmap_update_bits(fifo->map, FIFO_CTRL0, CTRL0_DMA_EN,\n\t\t\t   enable ? CTRL0_DMA_EN : 0);\n}\n\nint axg_fifo_pcm_trigger(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *ss, int cmd)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t__dma_enable(fifo, true);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\t__dma_enable(fifo, false);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_trigger);\n\nsnd_pcm_uframes_t axg_fifo_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t       struct snd_pcm_substream *ss)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tstruct snd_pcm_runtime *runtime = ss->runtime;\n\tunsigned int addr;\n\n\tregmap_read(fifo->map, FIFO_STATUS2, &addr);\n\n\treturn bytes_to_frames(runtime, addr - (unsigned int)runtime->dma_addr);\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_pointer);\n\nint axg_fifo_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *ss,\n\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = ss->runtime;\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tunsigned int burst_num, period, threshold, irq_en;\n\tdma_addr_t end_ptr;\n\n\tperiod = params_period_bytes(params);\n\n\t \n\tend_ptr = runtime->dma_addr + runtime->dma_bytes - AXG_FIFO_BURST;\n\tregmap_write(fifo->map, FIFO_START_ADDR, runtime->dma_addr);\n\tregmap_write(fifo->map, FIFO_FINISH_ADDR, end_ptr);\n\n\t \n\tburst_num = period / AXG_FIFO_BURST;\n\tregmap_write(fifo->map, FIFO_INT_ADDR, burst_num);\n\n\t \n\tthreshold = min(period / 2, fifo->depth / 2);\n\n\t \n\tthreshold /= AXG_FIFO_BURST;\n\tregmap_field_write(fifo->field_threshold,\n\t\t\t   threshold ? threshold - 1 : 0);\n\n\t \n\tirq_en = runtime->no_period_wakeup ? 0 : FIFO_INT_COUNT_REPEAT;\n\tregmap_update_bits(fifo->map, FIFO_CTRL0,\n\t\t\t   CTRL0_INT_EN(FIFO_INT_COUNT_REPEAT),\n\t\t\t   CTRL0_INT_EN(irq_en));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_hw_params);\n\nint g12a_fifo_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t    struct snd_pcm_substream *ss,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tstruct snd_pcm_runtime *runtime = ss->runtime;\n\tint ret;\n\n\tret = axg_fifo_pcm_hw_params(component, ss, params);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_write(fifo->map, FIFO_INIT_ADDR, runtime->dma_addr);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(g12a_fifo_pcm_hw_params);\n\nint axg_fifo_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *ss)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0,\n\t\t\t   CTRL0_INT_EN(FIFO_INT_COUNT_REPEAT), 0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_hw_free);\n\nstatic void axg_fifo_ack_irq(struct axg_fifo *fifo, u8 mask)\n{\n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_INT_CLR(FIFO_INT_MASK),\n\t\t\t   CTRL1_INT_CLR(mask));\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_INT_CLR(FIFO_INT_MASK),\n\t\t\t   0);\n}\n\nstatic irqreturn_t axg_fifo_pcm_irq_block(int irq, void *dev_id)\n{\n\tstruct snd_pcm_substream *ss = dev_id;\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tunsigned int status;\n\n\tregmap_read(fifo->map, FIFO_STATUS1, &status);\n\n\tstatus = STATUS1_INT_STS(status) & FIFO_INT_MASK;\n\tif (status & FIFO_INT_COUNT_REPEAT)\n\t\tsnd_pcm_period_elapsed(ss);\n\telse\n\t\tdev_dbg(axg_fifo_dev(ss), \"unexpected irq - STS 0x%02x\\n\",\n\t\t\tstatus);\n\n\t \n\taxg_fifo_ack_irq(fifo, status);\n\n\treturn IRQ_RETVAL(status);\n}\n\nint axg_fifo_pcm_open(struct snd_soc_component *component,\n\t\t      struct snd_pcm_substream *ss)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tstruct device *dev = axg_fifo_dev(ss);\n\tint ret;\n\n\tsnd_soc_set_runtime_hwparams(ss, &axg_fifo_hw);\n\n\t \n\tret = snd_pcm_hw_constraint_step(ss->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES,\n\t\t\t\t\t AXG_FIFO_BURST);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_step(ss->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES,\n\t\t\t\t\t AXG_FIFO_BURST);\n\tif (ret)\n\t\treturn ret;\n\n\tret = request_irq(fifo->irq, axg_fifo_pcm_irq_block, 0,\n\t\t\t  dev_name(dev), ss);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = clk_prepare_enable(fifo->pclk);\n\tif (ret)\n\t\tgoto free_irq;\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_STATUS2_SEL_MASK,\n\t\t\t   CTRL1_STATUS2_SEL(STATUS2_SEL_DDR_READ));\n\n\t \n\t__dma_enable(fifo, false);\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0,\n\t\t\t   CTRL0_INT_EN(FIFO_INT_MASK), 0);\n\n\t \n\taxg_fifo_ack_irq(fifo, FIFO_INT_MASK);\n\n\t \n\tret = reset_control_deassert(fifo->arb);\n\tif (ret)\n\t\tgoto free_clk;\n\n\treturn 0;\n\nfree_clk:\n\tclk_disable_unprepare(fifo->pclk);\nfree_irq:\n\tfree_irq(fifo->irq, ss);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_open);\n\nint axg_fifo_pcm_close(struct snd_soc_component *component,\n\t\t       struct snd_pcm_substream *ss)\n{\n\tstruct axg_fifo *fifo = axg_fifo_data(ss);\n\tint ret;\n\n\t \n\tret = reset_control_assert(fifo->arb);\n\n\t \n\tclk_disable_unprepare(fifo->pclk);\n\n\t \n\tfree_irq(fifo->irq, ss);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_close);\n\nint axg_fifo_pcm_new(struct snd_soc_pcm_runtime *rtd, unsigned int type)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tsize_t size = axg_fifo_hw.buffer_bytes_max;\n\n\tsnd_pcm_set_managed_buffer(rtd->pcm->streams[type].substream,\n\t\t\t\t   SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t   size, size);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_fifo_pcm_new);\n\nstatic const struct regmap_config axg_fifo_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= FIFO_CTRL2,\n};\n\nint axg_fifo_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct axg_fifo_match_data *data;\n\tstruct axg_fifo *fifo;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfifo = devm_kzalloc(dev, sizeof(*fifo), GFP_KERNEL);\n\tif (!fifo)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, fifo);\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tfifo->map = devm_regmap_init_mmio(dev, regs, &axg_fifo_regmap_cfg);\n\tif (IS_ERR(fifo->map)) {\n\t\tdev_err(dev, \"failed to init regmap: %ld\\n\",\n\t\t\tPTR_ERR(fifo->map));\n\t\treturn PTR_ERR(fifo->map);\n\t}\n\n\tfifo->pclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(fifo->pclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(fifo->pclk), \"failed to get pclk\\n\");\n\n\tfifo->arb = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(fifo->arb))\n\t\treturn dev_err_probe(dev, PTR_ERR(fifo->arb), \"failed to get arb reset\\n\");\n\n\tfifo->irq = of_irq_get(dev->of_node, 0);\n\tif (fifo->irq <= 0) {\n\t\tdev_err(dev, \"failed to get irq: %d\\n\", fifo->irq);\n\t\treturn fifo->irq;\n\t}\n\n\tfifo->field_threshold =\n\t\tdevm_regmap_field_alloc(dev, fifo->map, data->field_threshold);\n\tif (IS_ERR(fifo->field_threshold))\n\t\treturn PTR_ERR(fifo->field_threshold);\n\n\tret = of_property_read_u32(dev->of_node, \"amlogic,fifo-depth\",\n\t\t\t\t   &fifo->depth);\n\tif (ret) {\n\t\t \n\t\tif (ret != -EINVAL)\n\t\t\treturn ret;\n\t\t \n\t\tfifo->depth = 256;\n\t\tdev_warn(dev, \"fifo depth not found, assume %u bytes\\n\",\n\t\t\t fifo->depth);\n\t}\n\n\treturn devm_snd_soc_register_component(dev, data->component_drv,\n\t\t\t\t\t       data->dai_drv, 1);\n}\nEXPORT_SYMBOL_GPL(axg_fifo_probe);\n\nMODULE_DESCRIPTION(\"Amlogic AXG/G12A fifo driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}