{
  "module_name": "axg-toddr.c",
  "hash_id": "cb7178cf5971c39e42cefa3f4d1bb6c00ec54ee35fd6df7d29ce004fcf7f6343",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-toddr.c",
  "human_readable_source": "\n\n\n\n\n \n\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-fifo.h\"\n\n#define CTRL0_TODDR_SEL_RESAMPLE\tBIT(30)\n#define CTRL0_TODDR_EXT_SIGNED\t\tBIT(29)\n#define CTRL0_TODDR_PP_MODE\t\tBIT(28)\n#define CTRL0_TODDR_SYNC_CH\t\tBIT(27)\n#define CTRL0_TODDR_TYPE_MASK\t\tGENMASK(15, 13)\n#define CTRL0_TODDR_TYPE(x)\t\t((x) << 13)\n#define CTRL0_TODDR_MSB_POS_MASK\tGENMASK(12, 8)\n#define CTRL0_TODDR_MSB_POS(x)\t\t((x) << 8)\n#define CTRL0_TODDR_LSB_POS_MASK\tGENMASK(7, 3)\n#define CTRL0_TODDR_LSB_POS(x)\t\t((x) << 3)\n#define CTRL1_TODDR_FORCE_FINISH\tBIT(25)\n#define CTRL1_SEL_SHIFT\t\t\t28\n\n#define TODDR_MSB_POS\t31\n\nstatic int axg_toddr_pcm_new(struct snd_soc_pcm_runtime *rtd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\treturn axg_fifo_pcm_new(rtd, SNDRV_PCM_STREAM_CAPTURE);\n}\n\nstatic int g12a_toddr_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct axg_fifo *fifo = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_TODDR_FORCE_FINISH, 0);\n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_TODDR_FORCE_FINISH, CTRL1_TODDR_FORCE_FINISH);\n\tregmap_update_bits(fifo->map, FIFO_CTRL1,\n\t\t\t   CTRL1_TODDR_FORCE_FINISH, 0);\n\n\treturn 0;\n}\n\nstatic int axg_toddr_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_fifo *fifo = snd_soc_dai_get_drvdata(dai);\n\tunsigned int type, width;\n\n\tswitch (params_physical_width(params)) {\n\tcase 8:\n\t\ttype = 0;  \n\t\tbreak;\n\tcase 16:\n\t\ttype = 2;  \n\t\tbreak;\n\tcase 32:\n\t\ttype = 4;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twidth = params_width(params);\n\n\tregmap_update_bits(fifo->map, FIFO_CTRL0,\n\t\t\t   CTRL0_TODDR_TYPE_MASK |\n\t\t\t   CTRL0_TODDR_MSB_POS_MASK |\n\t\t\t   CTRL0_TODDR_LSB_POS_MASK,\n\t\t\t   CTRL0_TODDR_TYPE(type) |\n\t\t\t   CTRL0_TODDR_MSB_POS(TODDR_MSB_POS) |\n\t\t\t   CTRL0_TODDR_LSB_POS(TODDR_MSB_POS - (width - 1)));\n\n\treturn 0;\n}\n\nstatic int axg_toddr_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct axg_fifo *fifo = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(fifo->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0, CTRL0_TODDR_SEL_RESAMPLE, 0);\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0, CTRL0_TODDR_EXT_SIGNED,\n\t\t\t   CTRL0_TODDR_EXT_SIGNED);\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0, CTRL0_TODDR_PP_MODE, 0);\n\n\treturn 0;\n}\n\nstatic void axg_toddr_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_fifo *fifo = snd_soc_dai_get_drvdata(dai);\n\n\tclk_disable_unprepare(fifo->pclk);\n}\n\nstatic const struct snd_soc_dai_ops axg_toddr_ops = {\n\t.hw_params\t= axg_toddr_dai_hw_params,\n\t.startup\t= axg_toddr_dai_startup,\n\t.shutdown\t= axg_toddr_dai_shutdown,\n\t.pcm_new\t= axg_toddr_pcm_new,\n};\n\nstatic struct snd_soc_dai_driver axg_toddr_dai_drv = {\n\t.name = \"TODDR\",\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= AXG_FIFO_CH_MAX,\n\t\t.rates\t\t= AXG_FIFO_RATES,\n\t\t.formats\t= AXG_FIFO_FORMATS,\n\t},\n\t.ops\t\t= &axg_toddr_ops,\n};\n\nstatic const char * const axg_toddr_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\", \"IN 3\", \"IN 4\", \"IN 5\", \"IN 6\", \"IN 7\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(axg_toddr_sel_enum, FIFO_CTRL0, CTRL0_SEL_SHIFT,\n\t\t\t    axg_toddr_sel_texts);\n\nstatic const struct snd_kcontrol_new axg_toddr_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", axg_toddr_sel_enum);\n\nstatic const struct snd_soc_dapm_widget axg_toddr_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &axg_toddr_in_mux),\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 3\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 4\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 5\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 6\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 7\", NULL, 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route axg_toddr_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"SRC SEL\" },\n\t{ \"SRC SEL\", \"IN 0\", \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\", \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\", \"IN 2\" },\n\t{ \"SRC SEL\", \"IN 3\", \"IN 3\" },\n\t{ \"SRC SEL\", \"IN 4\", \"IN 4\" },\n\t{ \"SRC SEL\", \"IN 5\", \"IN 5\" },\n\t{ \"SRC SEL\", \"IN 6\", \"IN 6\" },\n\t{ \"SRC SEL\", \"IN 7\", \"IN 7\" },\n};\n\nstatic const struct snd_soc_component_driver axg_toddr_component_drv = {\n\t.dapm_widgets\t\t= axg_toddr_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_toddr_dapm_widgets),\n\t.dapm_routes\t\t= axg_toddr_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_toddr_dapm_routes),\n\t.open\t\t\t= axg_fifo_pcm_open,\n\t.close\t\t\t= axg_fifo_pcm_close,\n\t.hw_params\t\t= axg_fifo_pcm_hw_params,\n\t.hw_free\t\t= axg_fifo_pcm_hw_free,\n\t.pointer\t\t= axg_fifo_pcm_pointer,\n\t.trigger\t\t= axg_fifo_pcm_trigger,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct axg_fifo_match_data axg_toddr_match_data = {\n\t.field_threshold\t= REG_FIELD(FIFO_CTRL1, 16, 23),\n\t.component_drv\t\t= &axg_toddr_component_drv,\n\t.dai_drv\t\t= &axg_toddr_dai_drv\n};\n\nstatic int g12a_toddr_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct axg_fifo *fifo = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tret = axg_toddr_dai_startup(substream, dai);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(fifo->map, FIFO_CTRL0, CTRL0_TODDR_SYNC_CH,\n\t\t\t   CTRL0_TODDR_SYNC_CH);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops g12a_toddr_ops = {\n\t.prepare\t= g12a_toddr_dai_prepare,\n\t.hw_params\t= axg_toddr_dai_hw_params,\n\t.startup\t= g12a_toddr_dai_startup,\n\t.shutdown\t= axg_toddr_dai_shutdown,\n\t.pcm_new\t= axg_toddr_pcm_new,\n};\n\nstatic struct snd_soc_dai_driver g12a_toddr_dai_drv = {\n\t.name = \"TODDR\",\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= AXG_FIFO_CH_MAX,\n\t\t.rates\t\t= AXG_FIFO_RATES,\n\t\t.formats\t= AXG_FIFO_FORMATS,\n\t},\n\t.ops\t\t= &g12a_toddr_ops,\n};\n\nstatic const struct snd_soc_component_driver g12a_toddr_component_drv = {\n\t.dapm_widgets\t\t= axg_toddr_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_toddr_dapm_widgets),\n\t.dapm_routes\t\t= axg_toddr_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_toddr_dapm_routes),\n\t.open\t\t\t= axg_fifo_pcm_open,\n\t.close\t\t\t= axg_fifo_pcm_close,\n\t.hw_params\t\t= g12a_fifo_pcm_hw_params,\n\t.hw_free\t\t= axg_fifo_pcm_hw_free,\n\t.pointer\t\t= axg_fifo_pcm_pointer,\n\t.trigger\t\t= axg_fifo_pcm_trigger,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct axg_fifo_match_data g12a_toddr_match_data = {\n\t.field_threshold\t= REG_FIELD(FIFO_CTRL1, 16, 23),\n\t.component_drv\t\t= &g12a_toddr_component_drv,\n\t.dai_drv\t\t= &g12a_toddr_dai_drv\n};\n\nstatic const char * const sm1_toddr_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\",  \"IN 3\",  \"IN 4\",  \"IN 5\",  \"IN 6\",  \"IN 7\",\n\t\"IN 8\", \"IN 9\", \"IN 10\", \"IN 11\", \"IN 12\", \"IN 13\", \"IN 14\", \"IN 15\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(sm1_toddr_sel_enum, FIFO_CTRL1, CTRL1_SEL_SHIFT,\n\t\t\t    sm1_toddr_sel_texts);\n\nstatic const struct snd_kcontrol_new sm1_toddr_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", sm1_toddr_sel_enum);\n\nstatic const struct snd_soc_dapm_widget sm1_toddr_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &sm1_toddr_in_mux),\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 3\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 4\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 5\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 6\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 7\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 8\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 9\",  NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 10\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 11\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 12\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 13\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 14\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 15\", NULL, 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route sm1_toddr_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"SRC SEL\" },\n\t{ \"SRC SEL\", \"IN 0\",  \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\",  \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\",  \"IN 2\" },\n\t{ \"SRC SEL\", \"IN 3\",  \"IN 3\" },\n\t{ \"SRC SEL\", \"IN 4\",  \"IN 4\" },\n\t{ \"SRC SEL\", \"IN 5\",  \"IN 5\" },\n\t{ \"SRC SEL\", \"IN 6\",  \"IN 6\" },\n\t{ \"SRC SEL\", \"IN 7\",  \"IN 7\" },\n\t{ \"SRC SEL\", \"IN 8\",  \"IN 8\" },\n\t{ \"SRC SEL\", \"IN 9\",  \"IN 9\" },\n\t{ \"SRC SEL\", \"IN 10\", \"IN 10\" },\n\t{ \"SRC SEL\", \"IN 11\", \"IN 11\" },\n\t{ \"SRC SEL\", \"IN 12\", \"IN 12\" },\n\t{ \"SRC SEL\", \"IN 13\", \"IN 13\" },\n\t{ \"SRC SEL\", \"IN 14\", \"IN 14\" },\n\t{ \"SRC SEL\", \"IN 15\", \"IN 15\" },\n};\n\nstatic const struct snd_soc_component_driver sm1_toddr_component_drv = {\n\t.dapm_widgets\t\t= sm1_toddr_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sm1_toddr_dapm_widgets),\n\t.dapm_routes\t\t= sm1_toddr_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(sm1_toddr_dapm_routes),\n\t.open\t\t\t= axg_fifo_pcm_open,\n\t.close\t\t\t= axg_fifo_pcm_close,\n\t.hw_params\t\t= g12a_fifo_pcm_hw_params,\n\t.hw_free\t\t= axg_fifo_pcm_hw_free,\n\t.pointer\t\t= axg_fifo_pcm_pointer,\n\t.trigger\t\t= axg_fifo_pcm_trigger,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct axg_fifo_match_data sm1_toddr_match_data = {\n\t.field_threshold\t= REG_FIELD(FIFO_CTRL1, 12, 23),\n\t.component_drv\t\t= &sm1_toddr_component_drv,\n\t.dai_drv\t\t= &g12a_toddr_dai_drv\n};\n\nstatic const struct of_device_id axg_toddr_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-toddr\",\n\t\t.data = &axg_toddr_match_data,\n\t}, {\n\t\t.compatible = \"amlogic,g12a-toddr\",\n\t\t.data = &g12a_toddr_match_data,\n\t}, {\n\t\t.compatible = \"amlogic,sm1-toddr\",\n\t\t.data = &sm1_toddr_match_data,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_toddr_of_match);\n\nstatic struct platform_driver axg_toddr_pdrv = {\n\t.probe = axg_fifo_probe,\n\t.driver = {\n\t\t.name = \"axg-toddr\",\n\t\t.of_match_table = axg_toddr_of_match,\n\t},\n};\nmodule_platform_driver(axg_toddr_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG capture fifo driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}