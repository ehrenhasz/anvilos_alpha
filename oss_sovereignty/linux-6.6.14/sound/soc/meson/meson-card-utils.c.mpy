{
  "module_name": "meson-card-utils.c",
  "hash_id": "320731f1c224b83368f207d6f5ea4dcd8b003fe7d33bf7586270c0cdc8edc082",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/meson-card-utils.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <sound/soc.h>\n\n#include \"meson-card.h\"\n\nint meson_card_i2s_set_sysclk(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      unsigned int mclk_fs)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned int mclk;\n\tint ret, i;\n\n\tif (!mclk_fs)\n\t\treturn 0;\n\n\tmclk = params_rate(params) * mclk_fs;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, 0, mclk,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret && ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), 0, mclk,\n\t\t\t\t     SND_SOC_CLOCK_OUT);\n\tif (ret && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_card_i2s_set_sysclk);\n\nint meson_card_reallocate_links(struct snd_soc_card *card,\n\t\t\t\tunsigned int num_links)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_dai_link *links;\n\tvoid **ldata;\n\n\tlinks = krealloc(priv->card.dai_link,\n\t\t\t num_links * sizeof(*priv->card.dai_link),\n\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!links)\n\t\tgoto err_links;\n\n\tldata = krealloc(priv->link_data,\n\t\t\t num_links * sizeof(*priv->link_data),\n\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!ldata)\n\t\tgoto err_ldata;\n\n\tpriv->card.dai_link = links;\n\tpriv->link_data = ldata;\n\tpriv->card.num_links = num_links;\n\treturn 0;\n\nerr_ldata:\n\tkfree(links);\nerr_links:\n\tdev_err(priv->card.dev, \"failed to allocate links\\n\");\n\treturn -ENOMEM;\n\n}\nEXPORT_SYMBOL_GPL(meson_card_reallocate_links);\n\nint meson_card_parse_dai(struct snd_soc_card *card,\n\t\t\t struct device_node *node,\n\t\t\t struct snd_soc_dai_link_component *dlc)\n{\n\tint ret;\n\n\tif (!dlc || !node)\n\t\treturn -EINVAL;\n\n\tret = snd_soc_of_get_dlc(node, NULL, dlc, 0);\n\tif (ret)\n\t\treturn dev_err_probe(card->dev, ret, \"can't parse dai\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(meson_card_parse_dai);\n\nstatic int meson_card_set_link_name(struct snd_soc_card *card,\n\t\t\t\t    struct snd_soc_dai_link *link,\n\t\t\t\t    struct device_node *node,\n\t\t\t\t    const char *prefix)\n{\n\tchar *name = devm_kasprintf(card->dev, GFP_KERNEL, \"%s.%s\",\n\t\t\t\t    prefix, node->full_name);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tlink->name = name;\n\tlink->stream_name = name;\n\n\treturn 0;\n}\n\nunsigned int meson_card_parse_daifmt(struct device_node *node,\n\t\t\t\t     struct device_node *cpu_node)\n{\n\tstruct device_node *bitclkmaster = NULL;\n\tstruct device_node *framemaster = NULL;\n\tunsigned int daifmt;\n\n\tdaifmt = snd_soc_daifmt_parse_format(node, NULL);\n\n\tsnd_soc_daifmt_parse_clock_provider_as_phandle(node, NULL, &bitclkmaster, &framemaster);\n\n\t \n\tif (!bitclkmaster || bitclkmaster == cpu_node) {\n\t\tdaifmt |= (!framemaster || framemaster == cpu_node) ?\n\t\t\tSND_SOC_DAIFMT_CBS_CFS : SND_SOC_DAIFMT_CBS_CFM;\n\t} else {\n\t\tdaifmt |= (!framemaster || framemaster == cpu_node) ?\n\t\t\tSND_SOC_DAIFMT_CBM_CFS : SND_SOC_DAIFMT_CBM_CFM;\n\t}\n\n\tof_node_put(bitclkmaster);\n\tof_node_put(framemaster);\n\n\treturn daifmt;\n}\nEXPORT_SYMBOL_GPL(meson_card_parse_daifmt);\n\nint meson_card_set_be_link(struct snd_soc_card *card,\n\t\t\t   struct snd_soc_dai_link *link,\n\t\t\t   struct device_node *node)\n{\n\tstruct snd_soc_dai_link_component *codec;\n\tstruct device_node *np;\n\tint ret, num_codecs;\n\n\tnum_codecs = of_get_child_count(node);\n\tif (!num_codecs) {\n\t\tdev_err(card->dev, \"be link %s has no codec\\n\",\n\t\t\tnode->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tcodec = devm_kcalloc(card->dev, num_codecs, sizeof(*codec), GFP_KERNEL);\n\tif (!codec)\n\t\treturn -ENOMEM;\n\n\tlink->codecs = codec;\n\tlink->num_codecs = num_codecs;\n\n\tfor_each_child_of_node(node, np) {\n\t\tret = meson_card_parse_dai(card, np, codec);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcodec++;\n\t}\n\n\tret = meson_card_set_link_name(card, link, node, \"be\");\n\tif (ret)\n\t\tdev_err(card->dev, \"error setting %pOFn link name\\n\", np);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(meson_card_set_be_link);\n\nint meson_card_set_fe_link(struct snd_soc_card *card,\n\t\t\t   struct snd_soc_dai_link *link,\n\t\t\t   struct device_node *node,\n\t\t\t   bool is_playback)\n{\n\tlink->codecs = &asoc_dummy_dlc;\n\tlink->num_codecs = 1;\n\n\tlink->dynamic = 1;\n\tlink->dpcm_merged_format = 1;\n\tlink->dpcm_merged_chan = 1;\n\tlink->dpcm_merged_rate = 1;\n\n\tif (is_playback)\n\t\tlink->dpcm_playback = 1;\n\telse\n\t\tlink->dpcm_capture = 1;\n\n\treturn meson_card_set_link_name(card, link, node, \"fe\");\n}\nEXPORT_SYMBOL_GPL(meson_card_set_fe_link);\n\nstatic int meson_card_add_links(struct snd_soc_card *card)\n{\n\tstruct meson_card *priv = snd_soc_card_get_drvdata(card);\n\tstruct device_node *node = card->dev->of_node;\n\tstruct device_node *np;\n\tint num, i, ret;\n\n\tnum = of_get_child_count(node);\n\tif (!num) {\n\t\tdev_err(card->dev, \"card has no links\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = meson_card_reallocate_links(card, num);\n\tif (ret)\n\t\treturn ret;\n\n\ti = 0;\n\tfor_each_child_of_node(node, np) {\n\t\tret = priv->match_data->add_link(card, np, &i);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_card_parse_of_optional(struct snd_soc_card *card,\n\t\t\t\t\tconst char *propname,\n\t\t\t\t\tint (*func)(struct snd_soc_card *c,\n\t\t\t\t\t\t    const char *p))\n{\n\t \n\tif (!of_property_read_bool(card->dev->of_node, propname))\n\t\treturn 0;\n\n\t \n\treturn func(card, propname);\n}\n\nstatic void meson_card_clean_references(struct meson_card *priv)\n{\n\tstruct snd_soc_card *card = &priv->card;\n\tstruct snd_soc_dai_link *link;\n\tstruct snd_soc_dai_link_component *codec;\n\tstruct snd_soc_aux_dev *aux;\n\tint i, j;\n\n\tif (card->dai_link) {\n\t\tfor_each_card_prelinks(card, i, link) {\n\t\t\tif (link->cpus)\n\t\t\t\tof_node_put(link->cpus->of_node);\n\t\t\tfor_each_link_codecs(link, j, codec)\n\t\t\t\tof_node_put(codec->of_node);\n\t\t}\n\t}\n\n\tif (card->aux_dev) {\n\t\tfor_each_card_pre_auxs(card, i, aux)\n\t\t\tof_node_put(aux->dlc.of_node);\n\t}\n\n\tkfree(card->dai_link);\n\tkfree(priv->link_data);\n}\n\nint meson_card_probe(struct platform_device *pdev)\n{\n\tconst struct meson_card_match_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_card *priv;\n\tint ret;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, priv);\n\tsnd_soc_card_set_drvdata(&priv->card, priv);\n\n\tpriv->card.owner = THIS_MODULE;\n\tpriv->card.dev = dev;\n\tpriv->card.driver_name = dev->driver->name;\n\tpriv->match_data = data;\n\n\tret = snd_soc_of_parse_card_name(&priv->card, \"model\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = meson_card_parse_of_optional(&priv->card, \"audio-routing\",\n\t\t\t\t\t   snd_soc_of_parse_audio_routing);\n\tif (ret) {\n\t\tdev_err(dev, \"error while parsing routing\\n\");\n\t\treturn ret;\n\t}\n\n\tret = meson_card_parse_of_optional(&priv->card, \"audio-widgets\",\n\t\t\t\t\t   snd_soc_of_parse_audio_simple_widgets);\n\tif (ret) {\n\t\tdev_err(dev, \"error while parsing widgets\\n\");\n\t\treturn ret;\n\t}\n\n\tret = meson_card_add_links(&priv->card);\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = snd_soc_of_parse_aux_devs(&priv->card, \"audio-aux-devs\");\n\tif (ret)\n\t\tgoto out_err;\n\n\tret = devm_snd_soc_register_card(dev, &priv->card);\n\tif (ret)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tmeson_card_clean_references(priv);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(meson_card_probe);\n\nint meson_card_remove(struct platform_device *pdev)\n{\n\tstruct meson_card *priv = platform_get_drvdata(pdev);\n\n\tmeson_card_clean_references(priv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(meson_card_remove);\n\nMODULE_DESCRIPTION(\"Amlogic Sound Card Utils\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}