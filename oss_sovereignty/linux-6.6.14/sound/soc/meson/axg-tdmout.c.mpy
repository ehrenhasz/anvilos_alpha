{
  "module_name": "axg-tdmout.c",
  "hash_id": "6865a644feb3eea8768b695f168f715950cad7a7441b972e5753ff1657b606d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-tdmout.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-tdm-formatter.h\"\n\n#define TDMOUT_CTRL0\t\t\t0x00\n#define  TDMOUT_CTRL0_BITNUM_MASK\tGENMASK(4, 0)\n#define  TDMOUT_CTRL0_BITNUM(x)\t\t((x) << 0)\n#define  TDMOUT_CTRL0_SLOTNUM_MASK\tGENMASK(9, 5)\n#define  TDMOUT_CTRL0_SLOTNUM(x)\t((x) << 5)\n#define  TDMOUT_CTRL0_INIT_BITNUM_MASK\tGENMASK(19, 15)\n#define  TDMOUT_CTRL0_INIT_BITNUM(x)\t((x) << 15)\n#define  TDMOUT_CTRL0_ENABLE\t\tBIT(31)\n#define  TDMOUT_CTRL0_RST_OUT\t\tBIT(29)\n#define  TDMOUT_CTRL0_RST_IN\t\tBIT(28)\n#define TDMOUT_CTRL1\t\t\t0x04\n#define  TDMOUT_CTRL1_TYPE_MASK\t\tGENMASK(6, 4)\n#define  TDMOUT_CTRL1_TYPE(x)\t\t((x) << 4)\n#define  SM1_TDMOUT_CTRL1_GAIN_EN\t7\n#define  TDMOUT_CTRL1_MSB_POS_MASK\tGENMASK(12, 8)\n#define  TDMOUT_CTRL1_MSB_POS(x)\t((x) << 8)\n#define  TDMOUT_CTRL1_SEL_SHIFT\t\t24\n#define  TDMOUT_CTRL1_GAIN_EN\t\t26\n#define  TDMOUT_CTRL1_WS_INV\t\tBIT(28)\n#define TDMOUT_SWAP\t\t\t0x08\n#define TDMOUT_MASK0\t\t\t0x0c\n#define TDMOUT_MASK1\t\t\t0x10\n#define TDMOUT_MASK2\t\t\t0x14\n#define TDMOUT_MASK3\t\t\t0x18\n#define TDMOUT_STAT\t\t\t0x1c\n#define TDMOUT_GAIN0\t\t\t0x20\n#define TDMOUT_GAIN1\t\t\t0x24\n#define TDMOUT_MUTE_VAL\t\t\t0x28\n#define TDMOUT_MUTE0\t\t\t0x2c\n#define TDMOUT_MUTE1\t\t\t0x30\n#define TDMOUT_MUTE2\t\t\t0x34\n#define TDMOUT_MUTE3\t\t\t0x38\n#define TDMOUT_MASK_VAL\t\t\t0x3c\n\nstatic const struct regmap_config axg_tdmout_regmap_cfg = {\n\t.reg_bits\t= 32,\n\t.val_bits\t= 32,\n\t.reg_stride\t= 4,\n\t.max_register\t= TDMOUT_MASK_VAL,\n};\n\nstatic struct snd_soc_dai *\naxg_tdmout_get_be(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dapm_path *p;\n\tstruct snd_soc_dai *be;\n\n\tsnd_soc_dapm_widget_for_each_sink_path(w, p) {\n\t\tif (!p->connect)\n\t\t\tcontinue;\n\n\t\tif (p->sink->id == snd_soc_dapm_dai_in)\n\t\t\treturn (struct snd_soc_dai *)p->sink->priv;\n\n\t\tbe = axg_tdmout_get_be(p->sink);\n\t\tif (be)\n\t\t\treturn be;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct axg_tdm_stream *\naxg_tdmout_get_tdm_stream(struct snd_soc_dapm_widget *w)\n{\n\tstruct snd_soc_dai *be = axg_tdmout_get_be(w);\n\n\tif (!be)\n\t\treturn NULL;\n\n\treturn snd_soc_dai_dma_data_get_playback(be);\n}\n\nstatic void axg_tdmout_enable(struct regmap *map)\n{\n\t \n\tregmap_update_bits(map, TDMOUT_CTRL0,\n\t\t\t   TDMOUT_CTRL0_RST_OUT | TDMOUT_CTRL0_RST_IN, 0);\n\n\t \n\tregmap_update_bits(map, TDMOUT_CTRL0,\n\t\t\t   TDMOUT_CTRL0_RST_OUT, TDMOUT_CTRL0_RST_OUT);\n\tregmap_update_bits(map, TDMOUT_CTRL0,\n\t\t\t   TDMOUT_CTRL0_RST_IN,  TDMOUT_CTRL0_RST_IN);\n\n\t \n\tregmap_update_bits(map, TDMOUT_CTRL0,\n\t\t\t   TDMOUT_CTRL0_ENABLE, TDMOUT_CTRL0_ENABLE);\n}\n\nstatic void axg_tdmout_disable(struct regmap *map)\n{\n\tregmap_update_bits(map, TDMOUT_CTRL0, TDMOUT_CTRL0_ENABLE, 0);\n}\n\nstatic int axg_tdmout_prepare(struct regmap *map,\n\t\t\t      const struct axg_tdm_formatter_hw *quirks,\n\t\t\t      struct axg_tdm_stream *ts)\n{\n\tunsigned int val, skew = quirks->skew_offset;\n\n\t \n\tswitch (ts->iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tskew += 1;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unsupported format: %u\\n\",\n\t\t       ts->iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tval = TDMOUT_CTRL0_INIT_BITNUM(skew);\n\n\t \n\tval |= TDMOUT_CTRL0_BITNUM(ts->iface->slot_width - 1);\n\n\t \n\tval |= TDMOUT_CTRL0_SLOTNUM(ts->iface->slots - 1);\n\n\tregmap_update_bits(map, TDMOUT_CTRL0,\n\t\t\t   TDMOUT_CTRL0_INIT_BITNUM_MASK |\n\t\t\t   TDMOUT_CTRL0_BITNUM_MASK |\n\t\t\t   TDMOUT_CTRL0_SLOTNUM_MASK, val);\n\n\t \n\tval = TDMOUT_CTRL1_MSB_POS(ts->width - 1);\n\n\t \n\tswitch (ts->physical_width) {\n\tcase 8:\n\t\t \n\t\tval |= TDMOUT_CTRL1_TYPE(0);\n\t\tbreak;\n\tcase 16:\n\t\t \n\t\tval |= TDMOUT_CTRL1_TYPE(2);\n\t\tbreak;\n\tcase 32:\n\t\t \n\t\tval |= TDMOUT_CTRL1_TYPE(4);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported physical width: %u\\n\",\n\t\t       ts->physical_width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (axg_tdm_lrclk_invert(ts->iface->fmt))\n\t\tval |= TDMOUT_CTRL1_WS_INV;\n\n\tregmap_update_bits(map, TDMOUT_CTRL1,\n\t\t\t   (TDMOUT_CTRL1_TYPE_MASK | TDMOUT_CTRL1_MSB_POS_MASK |\n\t\t\t    TDMOUT_CTRL1_WS_INV), val);\n\n\t \n\tregmap_write(map, TDMOUT_SWAP, 0x76543210);\n\n\treturn axg_tdm_formatter_set_channel_masks(map, ts, TDMOUT_MASK0);\n}\n\nstatic const struct snd_kcontrol_new axg_tdmout_controls[] = {\n\tSOC_DOUBLE(\"Lane 0 Volume\", TDMOUT_GAIN0,  0,  8, 255, 0),\n\tSOC_DOUBLE(\"Lane 1 Volume\", TDMOUT_GAIN0, 16, 24, 255, 0),\n\tSOC_DOUBLE(\"Lane 2 Volume\", TDMOUT_GAIN1,  0,  8, 255, 0),\n\tSOC_DOUBLE(\"Lane 3 Volume\", TDMOUT_GAIN1, 16, 24, 255, 0),\n\tSOC_SINGLE(\"Gain Enable Switch\", TDMOUT_CTRL1,\n\t\t   TDMOUT_CTRL1_GAIN_EN, 1, 0),\n};\n\nstatic const char * const axg_tdmout_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(axg_tdmout_sel_enum, TDMOUT_CTRL1,\n\t\t\t    TDMOUT_CTRL1_SEL_SHIFT, axg_tdmout_sel_texts);\n\nstatic const struct snd_kcontrol_new axg_tdmout_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", axg_tdmout_sel_enum);\n\nstatic const struct snd_soc_dapm_widget axg_tdmout_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &axg_tdmout_in_mux),\n\tSND_SOC_DAPM_PGA_E(\"ENC\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t   axg_tdm_formatter_event,\n\t\t\t   (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD)),\n\tSND_SOC_DAPM_AIF_OUT(\"OUT\", NULL, 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route axg_tdmout_dapm_routes[] = {\n\t{ \"SRC SEL\", \"IN 0\", \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\", \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\", \"IN 2\" },\n\t{ \"ENC\", NULL, \"SRC SEL\" },\n\t{ \"OUT\", NULL, \"ENC\" },\n};\n\nstatic const struct snd_soc_component_driver axg_tdmout_component_drv = {\n\t.controls\t\t= axg_tdmout_controls,\n\t.num_controls\t\t= ARRAY_SIZE(axg_tdmout_controls),\n\t.dapm_widgets\t\t= axg_tdmout_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_tdmout_dapm_widgets),\n\t.dapm_routes\t\t= axg_tdmout_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_tdmout_dapm_routes),\n};\n\nstatic const struct axg_tdm_formatter_ops axg_tdmout_ops = {\n\t.get_stream\t= axg_tdmout_get_tdm_stream,\n\t.prepare\t= axg_tdmout_prepare,\n\t.enable\t\t= axg_tdmout_enable,\n\t.disable\t= axg_tdmout_disable,\n};\n\nstatic const struct axg_tdm_formatter_driver axg_tdmout_drv = {\n\t.component_drv\t= &axg_tdmout_component_drv,\n\t.regmap_cfg\t= &axg_tdmout_regmap_cfg,\n\t.ops\t\t= &axg_tdmout_ops,\n\t.quirks\t\t= &(const struct axg_tdm_formatter_hw) {\n\t\t.skew_offset = 1,\n\t},\n};\n\nstatic const struct axg_tdm_formatter_driver g12a_tdmout_drv = {\n\t.component_drv\t= &axg_tdmout_component_drv,\n\t.regmap_cfg\t= &axg_tdmout_regmap_cfg,\n\t.ops\t\t= &axg_tdmout_ops,\n\t.quirks\t\t= &(const struct axg_tdm_formatter_hw) {\n\t\t.skew_offset = 2,\n\t},\n};\n\nstatic const struct snd_kcontrol_new sm1_tdmout_controls[] = {\n\tSOC_DOUBLE(\"Lane 0 Volume\", TDMOUT_GAIN0,  0,  8, 255, 0),\n\tSOC_DOUBLE(\"Lane 1 Volume\", TDMOUT_GAIN0, 16, 24, 255, 0),\n\tSOC_DOUBLE(\"Lane 2 Volume\", TDMOUT_GAIN1,  0,  8, 255, 0),\n\tSOC_DOUBLE(\"Lane 3 Volume\", TDMOUT_GAIN1, 16, 24, 255, 0),\n\tSOC_SINGLE(\"Gain Enable Switch\", TDMOUT_CTRL1,\n\t\t   SM1_TDMOUT_CTRL1_GAIN_EN, 1, 0),\n};\n\nstatic const char * const sm1_tdmout_sel_texts[] = {\n\t\"IN 0\", \"IN 1\", \"IN 2\", \"IN 3\", \"IN 4\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(sm1_tdmout_sel_enum, TDMOUT_CTRL1,\n\t\t\t    TDMOUT_CTRL1_SEL_SHIFT, sm1_tdmout_sel_texts);\n\nstatic const struct snd_kcontrol_new sm1_tdmout_in_mux =\n\tSOC_DAPM_ENUM(\"Input Source\", sm1_tdmout_sel_enum);\n\nstatic const struct snd_soc_dapm_widget sm1_tdmout_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"IN 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 2\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 3\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"IN 4\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"SRC SEL\", SND_SOC_NOPM, 0, 0, &sm1_tdmout_in_mux),\n\tSND_SOC_DAPM_PGA_E(\"ENC\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t   axg_tdm_formatter_event,\n\t\t\t   (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD)),\n\tSND_SOC_DAPM_AIF_OUT(\"OUT\", NULL, 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route sm1_tdmout_dapm_routes[] = {\n\t{ \"SRC SEL\", \"IN 0\", \"IN 0\" },\n\t{ \"SRC SEL\", \"IN 1\", \"IN 1\" },\n\t{ \"SRC SEL\", \"IN 2\", \"IN 2\" },\n\t{ \"SRC SEL\", \"IN 3\", \"IN 3\" },\n\t{ \"SRC SEL\", \"IN 4\", \"IN 4\" },\n\t{ \"ENC\", NULL, \"SRC SEL\" },\n\t{ \"OUT\", NULL, \"ENC\" },\n};\n\nstatic const struct snd_soc_component_driver sm1_tdmout_component_drv = {\n\t.controls\t\t= sm1_tdmout_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sm1_tdmout_controls),\n\t.dapm_widgets\t\t= sm1_tdmout_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sm1_tdmout_dapm_widgets),\n\t.dapm_routes\t\t= sm1_tdmout_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(sm1_tdmout_dapm_routes),\n};\n\nstatic const struct axg_tdm_formatter_driver sm1_tdmout_drv = {\n\t.component_drv\t= &sm1_tdmout_component_drv,\n\t.regmap_cfg\t= &axg_tdmout_regmap_cfg,\n\t.ops\t\t= &axg_tdmout_ops,\n\t.quirks\t\t= &(const struct axg_tdm_formatter_hw) {\n\t\t.skew_offset = 2,\n\t},\n};\n\nstatic const struct of_device_id axg_tdmout_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,axg-tdmout\",\n\t\t.data = &axg_tdmout_drv,\n\t}, {\n\t\t.compatible = \"amlogic,g12a-tdmout\",\n\t\t.data = &g12a_tdmout_drv,\n\t}, {\n\t\t.compatible = \"amlogic,sm1-tdmout\",\n\t\t.data = &sm1_tdmout_drv,\n\t}, {}\n};\nMODULE_DEVICE_TABLE(of, axg_tdmout_of_match);\n\nstatic struct platform_driver axg_tdmout_pdrv = {\n\t.probe = axg_tdm_formatter_probe,\n\t.driver = {\n\t\t.name = \"axg-tdmout\",\n\t\t.of_match_table = axg_tdmout_of_match,\n\t},\n};\nmodule_platform_driver(axg_tdmout_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG TDM output formatter driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}