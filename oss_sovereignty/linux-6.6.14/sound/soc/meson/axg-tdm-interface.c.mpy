{
  "module_name": "axg-tdm-interface.c",
  "hash_id": "dbd9f10f33aefe7e6bdb97cb6104a5cada400336c9f1da038c959a8a1728fc09",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/axg-tdm-interface.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"axg-tdm.h\"\n\nenum {\n\tTDM_IFACE_PAD,\n\tTDM_IFACE_LOOPBACK,\n};\n\nstatic unsigned int axg_tdm_slots_total(u32 *mask)\n{\n\tunsigned int slots = 0;\n\tint i;\n\n\tif (!mask)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < AXG_TDM_NUM_LANES; i++)\n\t\tslots += hweight32(mask[i]);\n\n\treturn slots;\n}\n\nint axg_tdm_set_tdm_slots(struct snd_soc_dai *dai, u32 *tx_mask,\n\t\t\t  u32 *rx_mask, unsigned int slots,\n\t\t\t  unsigned int slot_width)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tstruct axg_tdm_stream *tx = snd_soc_dai_dma_data_get_playback(dai);\n\tstruct axg_tdm_stream *rx = snd_soc_dai_dma_data_get_capture(dai);\n\tunsigned int tx_slots, rx_slots;\n\tunsigned int fmt = 0;\n\n\ttx_slots = axg_tdm_slots_total(tx_mask);\n\trx_slots = axg_tdm_slots_total(rx_mask);\n\n\t \n\tif (!tx_slots && !rx_slots) {\n\t\tdev_err(dai->dev, \"interface has no slot\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiface->slots = slots;\n\n\tswitch (slot_width) {\n\tcase 0:\n\t\tslot_width = 32;\n\t\tfallthrough;\n\tcase 32:\n\t\tfmt |= SNDRV_PCM_FMTBIT_S32_LE;\n\t\tfallthrough;\n\tcase 24:\n\t\tfmt |= SNDRV_PCM_FMTBIT_S24_LE;\n\t\tfmt |= SNDRV_PCM_FMTBIT_S20_LE;\n\t\tfallthrough;\n\tcase 16:\n\t\tfmt |= SNDRV_PCM_FMTBIT_S16_LE;\n\t\tfallthrough;\n\tcase 8:\n\t\tfmt |= SNDRV_PCM_FMTBIT_S8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"unsupported slot width: %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tiface->slot_width = slot_width;\n\n\t \n\tif (tx) {\n\t\ttx->mask = tx_mask;\n\t\tdai->driver->playback.channels_max = tx_slots;\n\t\tdai->driver->playback.formats = fmt;\n\t}\n\n\tif (rx) {\n\t\trx->mask = rx_mask;\n\t\tdai->driver->capture.channels_max = rx_slots;\n\t\tdai->driver->capture.formats = fmt;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(axg_tdm_set_tdm_slots);\n\nstatic int axg_tdm_iface_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t    unsigned int freq, int dir)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tint ret = -ENOTSUPP;\n\n\tif (dir == SND_SOC_CLOCK_OUT && clk_id == 0) {\n\t\tif (!iface->mclk) {\n\t\t\tdev_warn(dai->dev, \"master clock not provided\\n\");\n\t\t} else {\n\t\t\tret = clk_set_rate(iface->mclk, freq);\n\t\t\tif (!ret)\n\t\t\t\tiface->mclk_rate = freq;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int axg_tdm_iface_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tif (!iface->mclk) {\n\t\t\tdev_err(dai->dev, \"cpu clock master: mclk missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_BP_FC:\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tdev_err(dai->dev, \"only CBS_CFS and CBM_CFM are supported\\n\");\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tiface->fmt = fmt;\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tstruct axg_tdm_stream *ts =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\tint ret;\n\n\tif (!axg_tdm_slots_total(ts->mask)) {\n\t\tdev_err(dai->dev, \"interface has not slots\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (snd_soc_component_active(dai->component)) {\n\t\tret = snd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t   iface->rate);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"can't set iface rate constraint\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_set_stream(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tstruct axg_tdm_stream *ts = snd_soc_dai_get_dma_data(dai, substream);\n\tunsigned int channels = params_channels(params);\n\tunsigned int width = params_width(params);\n\n\t \n\tiface->rate = params_rate(params);\n\n\t \n\tif (axg_tdm_slots_total(ts->mask) < channels) {\n\t\tdev_err(dai->dev, \"not enough slots for channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iface->slot_width < width) {\n\t\tdev_err(dai->dev, \"incompatible slots width for stream\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tts->physical_width = params_physical_width(params);\n\tts->width = params_width(params);\n\tts->channels = params_channels(params);\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_set_lrclk(struct snd_soc_dai *dai,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tunsigned int ratio_num;\n\tint ret;\n\n\tret = clk_set_rate(iface->lrclk, params_rate(params));\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting sample clock failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t \n\t\tratio_num = 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tratio_num = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = clk_set_duty_cycle(iface->lrclk, ratio_num, 2);\n\tif (ret) {\n\t\tdev_err(dai->dev,\n\t\t\t\"setting sample clock duty cycle failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_set_phase(iface->lrclk,\n\t\t\t    axg_tdm_lrclk_invert(iface->fmt) ? 180 : 0);\n\tif (ret) {\n\t\tdev_err(dai->dev,\n\t\t\t\"setting sample clock phase failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_set_sclk(struct snd_soc_dai *dai,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tunsigned long srate;\n\tint ret;\n\n\tsrate = iface->slots * iface->slot_width * params_rate(params);\n\n\tif (!iface->mclk_rate) {\n\t\t \n\t\tclk_set_rate(iface->mclk, 4 * srate);\n\t} else {\n\t\t \n\t\tif (iface->mclk_rate % srate) {\n\t\t\tdev_err(dai->dev,\n\t\t\t\t\"can't derive sclk %lu from mclk %lu\\n\",\n\t\t\t\tsrate, iface->mclk_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = clk_set_rate(iface->sclk, srate);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting bit clock failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = clk_set_phase(iface->sclk,\n\t\t\t    axg_tdm_sclk_invert(iface->fmt) ? 0 : 180);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"setting bit clock phase failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int axg_tdm_iface_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tswitch (iface->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tif (iface->slots > 2) {\n\t\t\tdev_err(dai->dev, \"bad slot number for format: %d\\n\",\n\t\t\t\tiface->slots);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dai->dev, \"unsupported dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = axg_tdm_iface_set_stream(substream, params, dai);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((iface->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) ==\n\t    SND_SOC_DAIFMT_BP_FP) {\n\t\tret = axg_tdm_iface_set_sclk(dai, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = axg_tdm_iface_set_lrclk(dai, params);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_stream *ts = snd_soc_dai_get_dma_data(dai, substream);\n\n\t \n\taxg_tdm_stream_stop(ts);\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_stream *ts = snd_soc_dai_get_dma_data(dai, substream);\n\n\t \n\treturn axg_tdm_stream_reset(ts);\n}\n\nstatic int axg_tdm_iface_remove_dai(struct snd_soc_dai *dai)\n{\n\tint stream;\n\n\tfor_each_pcm_streams(stream) {\n\t\tstruct axg_tdm_stream *ts = snd_soc_dai_dma_data_get(dai, stream);\n\n\t\tif (ts)\n\t\t\taxg_tdm_stream_free(ts);\n\t}\n\n\treturn 0;\n}\n\nstatic int axg_tdm_iface_probe_dai(struct snd_soc_dai *dai)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_dai_get_drvdata(dai);\n\tint stream;\n\n\tfor_each_pcm_streams(stream) {\n\t\tstruct axg_tdm_stream *ts;\n\n\t\tif (!snd_soc_dai_get_widget(dai, stream))\n\t\t\tcontinue;\n\n\t\tts = axg_tdm_stream_alloc(iface);\n\t\tif (!ts) {\n\t\t\taxg_tdm_iface_remove_dai(dai);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsnd_soc_dai_dma_data_set(dai, stream, ts);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops axg_tdm_iface_ops = {\n\t.probe\t\t= axg_tdm_iface_probe_dai,\n\t.remove\t\t= axg_tdm_iface_remove_dai,\n\t.set_sysclk\t= axg_tdm_iface_set_sysclk,\n\t.set_fmt\t= axg_tdm_iface_set_fmt,\n\t.startup\t= axg_tdm_iface_startup,\n\t.hw_params\t= axg_tdm_iface_hw_params,\n\t.prepare\t= axg_tdm_iface_prepare,\n\t.hw_free\t= axg_tdm_iface_hw_free,\n};\n\n \nstatic const struct snd_soc_dai_driver axg_tdm_iface_dai_drv[] = {\n\t[TDM_IFACE_PAD] = {\n\t\t.name = \"TDM Pad\",\n\t\t.playback = {\n\t\t\t.stream_name\t= \"Playback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= AXG_TDM_CHANNEL_MAX,\n\t\t\t.rates\t\t= AXG_TDM_RATES,\n\t\t\t.formats\t= AXG_TDM_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name\t= \"Capture\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= AXG_TDM_CHANNEL_MAX,\n\t\t\t.rates\t\t= AXG_TDM_RATES,\n\t\t\t.formats\t= AXG_TDM_FORMATS,\n\t\t},\n\t\t.id = TDM_IFACE_PAD,\n\t\t.ops = &axg_tdm_iface_ops,\n\t},\n\t[TDM_IFACE_LOOPBACK] = {\n\t\t.name = \"TDM Loopback\",\n\t\t.capture = {\n\t\t\t.stream_name\t= \"Loopback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= AXG_TDM_CHANNEL_MAX,\n\t\t\t.rates\t\t= AXG_TDM_RATES,\n\t\t\t.formats\t= AXG_TDM_FORMATS,\n\t\t},\n\t\t.id = TDM_IFACE_LOOPBACK,\n\t\t.ops = &axg_tdm_iface_ops,\n\t},\n};\n\nstatic int axg_tdm_iface_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct axg_tdm_iface *iface = snd_soc_component_get_drvdata(component);\n\tenum snd_soc_bias_level now =\n\t\tsnd_soc_component_get_bias_level(component);\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (now == SND_SOC_BIAS_STANDBY)\n\t\t\tret = clk_prepare_enable(iface->mclk);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (now == SND_SOC_BIAS_PREPARE)\n\t\t\tclk_disable_unprepare(iface->mclk);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget axg_tdm_iface_dapm_widgets[] = {\n\tSND_SOC_DAPM_SIGGEN(\"Playback Signal\"),\n};\n\nstatic const struct snd_soc_dapm_route axg_tdm_iface_dapm_routes[] = {\n\t{ \"Loopback\", NULL, \"Playback Signal\" },\n};\n\nstatic const struct snd_soc_component_driver axg_tdm_iface_component_drv = {\n\t.dapm_widgets\t\t= axg_tdm_iface_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(axg_tdm_iface_dapm_widgets),\n\t.dapm_routes\t\t= axg_tdm_iface_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(axg_tdm_iface_dapm_routes),\n\t.set_bias_level\t\t= axg_tdm_iface_set_bias_level,\n};\n\nstatic const struct of_device_id axg_tdm_iface_of_match[] = {\n\t{ .compatible = \"amlogic,axg-tdm-iface\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, axg_tdm_iface_of_match);\n\nstatic int axg_tdm_iface_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct axg_tdm_iface *iface;\n\tint i;\n\n\tiface = devm_kzalloc(dev, sizeof(*iface), GFP_KERNEL);\n\tif (!iface)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, iface);\n\n\t \n\tdai_drv = devm_kcalloc(dev, ARRAY_SIZE(axg_tdm_iface_dai_drv),\n\t\t\t       sizeof(*dai_drv), GFP_KERNEL);\n\tif (!dai_drv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(axg_tdm_iface_dai_drv); i++)\n\t\tmemcpy(&dai_drv[i], &axg_tdm_iface_dai_drv[i],\n\t\t       sizeof(*dai_drv));\n\n\t \n\tiface->sclk = devm_clk_get(dev, \"sclk\");\n\tif (IS_ERR(iface->sclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(iface->sclk), \"failed to get sclk\\n\");\n\n\t \n\tiface->lrclk = devm_clk_get(dev, \"lrclk\");\n\tif (IS_ERR(iface->lrclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(iface->lrclk), \"failed to get lrclk\\n\");\n\n\t \n\tiface->mclk = devm_clk_get_optional(dev, \"mclk\");\n\tif (IS_ERR(iface->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(iface->mclk), \"failed to get mclk\\n\");\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t\t&axg_tdm_iface_component_drv, dai_drv,\n\t\t\t\t\tARRAY_SIZE(axg_tdm_iface_dai_drv));\n}\n\nstatic struct platform_driver axg_tdm_iface_pdrv = {\n\t.probe = axg_tdm_iface_probe,\n\t.driver = {\n\t\t.name = \"axg-tdm-iface\",\n\t\t.of_match_table = axg_tdm_iface_of_match,\n\t},\n};\nmodule_platform_driver(axg_tdm_iface_pdrv);\n\nMODULE_DESCRIPTION(\"Amlogic AXG TDM interface driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}