{
  "module_name": "aiu-encoder-spdif.c",
  "hash_id": "e22ecdc1172111c2d5940415753b17d8d69c868f0346f222599bb99fb63c555a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/meson/aiu-encoder-spdif.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm_iec958.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n\n#include \"aiu.h\"\n\n#define AIU_958_MISC_NON_PCM\t\tBIT(0)\n#define AIU_958_MISC_MODE_16BITS\tBIT(1)\n#define AIU_958_MISC_16BITS_ALIGN\tGENMASK(6, 5)\n#define AIU_958_MISC_MODE_32BITS\tBIT(7)\n#define AIU_958_MISC_U_FROM_STREAM\tBIT(12)\n#define AIU_958_MISC_FORCE_LR\t\tBIT(13)\n#define AIU_958_CTRL_HOLD_EN\t\tBIT(0)\n#define AIU_CLK_CTRL_958_DIV_EN\t\tBIT(1)\n#define AIU_CLK_CTRL_958_DIV\t\tGENMASK(5, 4)\n#define AIU_CLK_CTRL_958_DIV_MORE\tBIT(12)\n\n#define AIU_CS_WORD_LEN\t\t\t4\n#define AIU_958_INTERNAL_DIV\t\t2\n\nstatic void\naiu_encoder_spdif_divider_enable(struct snd_soc_component *component,\n\t\t\t\t bool enable)\n{\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_958_DIV_EN,\n\t\t\t\t      enable ? AIU_CLK_CTRL_958_DIV_EN : 0);\n}\n\nstatic void aiu_encoder_spdif_hold(struct snd_soc_component *component,\n\t\t\t\t   bool enable)\n{\n\tsnd_soc_component_update_bits(component, AIU_958_CTRL,\n\t\t\t\t      AIU_958_CTRL_HOLD_EN,\n\t\t\t\t      enable ? AIU_958_CTRL_HOLD_EN : 0);\n}\n\nstatic int\naiu_encoder_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\taiu_encoder_spdif_hold(component, false);\n\t\treturn 0;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\taiu_encoder_spdif_hold(component, true);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aiu_encoder_spdif_setup_cs_word(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tu8 cs[AIU_CS_WORD_LEN];\n\tunsigned int val;\n\tint ret;\n\n\tret = snd_pcm_create_iec958_consumer_hw_params(params, cs,\n\t\t\t\t\t\t       AIU_CS_WORD_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = cs[1] | cs[0] << 8;\n\tsnd_soc_component_write(component, AIU_958_CHSTAT_L0, val);\n\tsnd_soc_component_write(component, AIU_958_CHSTAT_R0, val);\n\n\t \n\tval = cs[3] | cs[2] << 8;\n\tsnd_soc_component_write(component, AIU_958_CHSTAT_L1, val);\n\tsnd_soc_component_write(component, AIU_958_CHSTAT_R1, val);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0, mrate;\n\tint ret;\n\n\t \n\taiu_encoder_spdif_divider_enable(component, false);\n\n\tswitch (params_physical_width(params)) {\n\tcase 16:\n\t\tval |= AIU_958_MISC_MODE_16BITS;\n\t\tval |= FIELD_PREP(AIU_958_MISC_16BITS_ALIGN, 2);\n\t\tbreak;\n\tcase 32:\n\t\tval |= AIU_958_MISC_MODE_32BITS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported physical width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIU_958_MISC,\n\t\t\t\t      AIU_958_MISC_NON_PCM |\n\t\t\t\t      AIU_958_MISC_MODE_16BITS |\n\t\t\t\t      AIU_958_MISC_16BITS_ALIGN |\n\t\t\t\t      AIU_958_MISC_MODE_32BITS |\n\t\t\t\t      AIU_958_MISC_FORCE_LR |\n\t\t\t\t      AIU_958_MISC_U_FROM_STREAM,\n\t\t\t\t      val);\n\n\t \n\tret = aiu_encoder_spdif_setup_cs_word(component, params);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to set channel status word\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIU_CLK_CTRL,\n\t\t\t\t      AIU_CLK_CTRL_958_DIV |\n\t\t\t\t      AIU_CLK_CTRL_958_DIV_MORE,\n\t\t\t\t      FIELD_PREP(AIU_CLK_CTRL_958_DIV,\n\t\t\t\t\t\t __ffs(AIU_958_INTERNAL_DIV)));\n\n\t \n\tmrate = params_rate(params) * 128 * AIU_958_INTERNAL_DIV;\n\tret = clk_set_rate(aiu->spdif.clks[MCLK].clk, mrate);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"failed to set mclk rate\\n\");\n\t\treturn ret;\n\t}\n\n\taiu_encoder_spdif_divider_enable(component, true);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_spdif_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\taiu_encoder_spdif_divider_enable(component, false);\n\n\treturn 0;\n}\n\nstatic int aiu_encoder_spdif_startup(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\t \n\tret = clk_set_parent(aiu->spdif.clks[MCLK].clk,\n\t\t\t     aiu->spdif_mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(aiu->spdif.clk_num, aiu->spdif.clks);\n\tif (ret)\n\t\tdev_err(dai->dev, \"failed to enable spdif clocks\\n\");\n\n\treturn ret;\n}\n\nstatic void aiu_encoder_spdif_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct aiu *aiu = snd_soc_component_get_drvdata(dai->component);\n\n\tclk_bulk_disable_unprepare(aiu->spdif.clk_num, aiu->spdif.clks);\n}\n\nconst struct snd_soc_dai_ops aiu_encoder_spdif_dai_ops = {\n\t.trigger\t= aiu_encoder_spdif_trigger,\n\t.hw_params\t= aiu_encoder_spdif_hw_params,\n\t.hw_free\t= aiu_encoder_spdif_hw_free,\n\t.startup\t= aiu_encoder_spdif_startup,\n\t.shutdown\t= aiu_encoder_spdif_shutdown,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}