{
  "module_name": "imx-rpmsg.c",
  "hash_id": "a4a05a7571ded4d5e904385dea197893dade17b436530f52fe6bc372d33f2c11",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-rpmsg.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/i2c.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/clk.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/control.h>\n#include <sound/pcm_params.h>\n#include <sound/soc-dapm.h>\n#include \"imx-pcm-rpmsg.h\"\n\nstruct imx_rpmsg {\n\tstruct snd_soc_dai_link dai;\n\tstruct snd_soc_card card;\n\tunsigned long sysclk;\n};\n\nstatic const struct snd_soc_dapm_widget imx_rpmsg_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"Main MIC\", NULL),\n};\n\nstatic int imx_rpmsg_late_probe(struct snd_soc_card *card)\n{\n\tstruct imx_rpmsg *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_pcm_runtime *rtd = list_first_entry(&card->rtd_list,\n\t\t\t\t\t\t\t   struct snd_soc_pcm_runtime, list);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct device *dev = card->dev;\n\tint ret;\n\n\tif (!data->sysclk)\n\t\treturn 0;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, 0, data->sysclk, SND_SOC_CLOCK_IN);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set sysclk in %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_dai_link_component *dlc;\n\tstruct device *dev = pdev->dev.parent;\n\t \n\tstruct platform_device *rpmsg_pdev = to_platform_device(dev);\n\tstruct device_node *np = rpmsg_pdev->dev.of_node;\n\tstruct of_phandle_args args;\n\tconst char *platform_name;\n\tstruct imx_rpmsg *data;\n\tint ret = 0;\n\n\tdlc = devm_kzalloc(&pdev->dev, 3 * sizeof(*dlc), GFP_KERNEL);\n\tif (!dlc)\n\t\treturn -ENOMEM;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = of_reserved_mem_device_init_by_idx(&pdev->dev, np, 0);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"no reserved DMA memory\\n\");\n\n\tdata->dai.cpus = &dlc[0];\n\tdata->dai.num_cpus = 1;\n\tdata->dai.platforms = &dlc[1];\n\tdata->dai.num_platforms = 1;\n\tdata->dai.codecs = &dlc[2];\n\tdata->dai.num_codecs = 1;\n\n\tdata->dai.name = \"rpmsg hifi\";\n\tdata->dai.stream_name = \"rpmsg hifi\";\n\tdata->dai.dai_fmt = SND_SOC_DAIFMT_I2S |\n\t\t\t    SND_SOC_DAIFMT_NB_NF |\n\t\t\t    SND_SOC_DAIFMT_CBC_CFC;\n\n\t \n\tdata->dai.ignore_pmdown_time = 1;\n\n\t \n\tret = of_parse_phandle_with_fixed_args(np, \"audio-codec\", 0, 0, &args);\n\tif (ret) {\n\t\t*data->dai.codecs = asoc_dummy_dlc;\n\t} else {\n\t\tstruct clk *clk;\n\n\t\tret = snd_soc_get_dlc(&args, data->dai.codecs);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Unable to get codec_dai_name\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tclk = devm_get_clk_from_child(&pdev->dev, args.np, NULL);\n\t\tif (!IS_ERR(clk))\n\t\t\tdata->sysclk = clk_get_rate(clk);\n\t}\n\n\tdata->dai.cpus->dai_name = dev_name(&rpmsg_pdev->dev);\n\tif (!of_property_read_string(np, \"fsl,rpmsg-channel-name\", &platform_name))\n\t\tdata->dai.platforms->name = platform_name;\n\telse\n\t\tdata->dai.platforms->name = \"rpmsg-audio-channel\";\n\tdata->dai.playback_only = true;\n\tdata->dai.capture_only = true;\n\tdata->card.num_links = 1;\n\tdata->card.dai_link = &data->dai;\n\n\tif (of_property_read_bool(np, \"fsl,rpmsg-out\"))\n\t\tdata->dai.capture_only = false;\n\n\tif (of_property_read_bool(np, \"fsl,rpmsg-in\"))\n\t\tdata->dai.playback_only = false;\n\n\tif (data->dai.playback_only && data->dai.capture_only) {\n\t\tdev_err(&pdev->dev, \"no enabled rpmsg DAI link\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tdata->card.dev = &pdev->dev;\n\tdata->card.owner = THIS_MODULE;\n\tdata->card.dapm_widgets = imx_rpmsg_dapm_widgets;\n\tdata->card.num_dapm_widgets = ARRAY_SIZE(imx_rpmsg_dapm_widgets);\n\tdata->card.late_probe = imx_rpmsg_late_probe;\n\t \n\tdata->card.dev->of_node = np;\n\n\tret = snd_soc_of_parse_card_name(&data->card, \"model\");\n\tif (ret)\n\t\tgoto fail;\n\n\tif (of_property_read_bool(np, \"audio-routing\")) {\n\t\tret = snd_soc_of_parse_audio_routing(&data->card, \"audio-routing\");\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse audio-routing: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, &data->card);\n\tsnd_soc_card_set_drvdata(&data->card, data);\n\tret = devm_snd_soc_register_card(&pdev->dev, &data->card);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"snd_soc_register_card failed\\n\");\n\t\tgoto fail;\n\t}\n\nfail:\n\tpdev->dev.of_node = NULL;\n\treturn ret;\n}\n\nstatic struct platform_driver imx_rpmsg_driver = {\n\t.driver = {\n\t\t.name = \"imx-audio-rpmsg\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n\t.probe = imx_rpmsg_probe,\n};\nmodule_platform_driver(imx_rpmsg_driver);\n\nMODULE_DESCRIPTION(\"Freescale SoC Audio RPMSG Machine Driver\");\nMODULE_AUTHOR(\"Shengjiu Wang <shengjiu.wang@nxp.com>\");\nMODULE_ALIAS(\"platform:imx-audio-rpmsg\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}