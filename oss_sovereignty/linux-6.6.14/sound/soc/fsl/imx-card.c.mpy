{
  "module_name": "imx-card.c",
  "hash_id": "994b227762e604af032ce3bd6889eed4db7c3a0b0eb5e8a496c1cc12afa2485d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-card.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/i2c.h>\n#include <linux/of_gpio.h>\n#include <linux/clk.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm.h>\n#include <sound/soc-dapm.h>\n#include <sound/simple_card_utils.h>\n\n#include \"fsl_sai.h\"\n\n#define IMX_CARD_MCLK_22P5792MHZ  22579200\n#define IMX_CARD_MCLK_24P576MHZ   24576000\n\nenum codec_type {\n\tCODEC_DUMMY = 0,\n\tCODEC_AK5558 = 1,\n\tCODEC_AK4458,\n\tCODEC_AK4497,\n\tCODEC_AK5552,\n};\n\n \nstruct imx_akcodec_fs_mul {\n\tunsigned int rmin;\n\tunsigned int rmax;\n\tunsigned int wmin;\n\tunsigned int wmax;\n};\n\n \nstruct imx_akcodec_tdm_fs_mul {\n\tunsigned int min;\n\tunsigned int max;\n\tunsigned int mul;\n};\n\n \nstruct imx_card_plat_data {\n\tstruct imx_akcodec_fs_mul  *fs_mul;\n\tstruct imx_akcodec_tdm_fs_mul  *tdm_fs_mul;\n\tconst u32 *support_rates;\n\tconst u32 *support_tdm_rates;\n\tconst u32 *support_channels;\n\tconst u32 *support_tdm_channels;\n\tunsigned int num_fs_mul;\n\tunsigned int num_tdm_fs_mul;\n\tunsigned int num_rates;\n\tunsigned int num_tdm_rates;\n\tunsigned int num_channels;\n\tunsigned int num_tdm_channels;\n\tunsigned int num_codecs;\n\tenum codec_type type;\n};\n\n \nstruct dai_link_data {\n\tunsigned int slots;\n\tunsigned int slot_width;\n\tunsigned int cpu_sysclk_id;\n\tbool one2one_ratio;\n};\n\n \nstruct imx_card_data {\n\tstruct imx_card_plat_data *plat_data;\n\tstruct snd_soc_dapm_route *dapm_routes;\n\tstruct dai_link_data *link_data;\n\tstruct snd_soc_card card;\n\tint num_dapm_routes;\n\tu32 asrc_rate;\n\tsnd_pcm_format_t asrc_format;\n};\n\nstatic struct imx_akcodec_fs_mul ak4458_fs_mul[] = {\n\t \n\t{ .rmin = 8000,   .rmax = 24000,  .wmin = 256,  .wmax = 1024, },\n\t \n\t{ .rmin = 32000,  .rmax = 32000,  .wmin = 256,  .wmax = 1024, },\n\t \n\t{ .rmin = 44100,  .rmax = 48000,  .wmin = 256,  .wmax = 768,  },\n\t \n\t{ .rmin = 88200,  .rmax = 96000,  .wmin = 256,  .wmax = 512,  },\n\t \n\t{ .rmin = 176400, .rmax = 192000, .wmin = 128,  .wmax = 256,  },\n\t \n\t{ .rmin = 352800, .rmax = 384000, .wmin = 32,   .wmax = 128,  },\n\t \n\t{ .rmin = 705600, .rmax = 768000, .wmin = 16,   .wmax = 64,   },\n};\n\nstatic struct imx_akcodec_tdm_fs_mul ak4458_tdm_fs_mul[] = {\n\t \n\t{ .min = 128,\t.max = 128,\t.mul = 256  },  \n\t{ .min = 256,\t.max = 256,\t.mul = 512  },  \n\t{ .min = 512,\t.max = 512,\t.mul = 1024  },  \n};\n\nstatic struct imx_akcodec_fs_mul ak4497_fs_mul[] = {\n\t \n\t{ .rmin = 8000,   .rmax = 32000,  .wmin = 256,  .wmax = 1024, },  \n\t{ .rmin = 44100,  .rmax = 48000,  .wmin = 256,  .wmax = 512, },  \n\t{ .rmin = 88200,  .rmax = 96000,  .wmin = 256,  .wmax = 256, },  \n\t{ .rmin = 176400, .rmax = 192000, .wmin = 128,  .wmax = 128, },  \n\t{ .rmin = 352800, .rmax = 384000, .wmin = 128,  .wmax = 128, },  \n\t{ .rmin = 705600, .rmax = 768000, .wmin = 64,   .wmax = 64, },  \n};\n\n \nstatic struct imx_akcodec_fs_mul ak5558_fs_mul[] = {\n\t{ .rmin = 8000,   .rmax = 32000,  .wmin = 512,  .wmax = 1024, },\n\t{ .rmin = 44100,  .rmax = 48000,  .wmin = 512,  .wmax = 512, },\n\t{ .rmin = 88200,  .rmax = 96000,  .wmin = 256,  .wmax = 256, },\n\t{ .rmin = 176400, .rmax = 192000, .wmin = 128,  .wmax = 128, },\n\t{ .rmin = 352800, .rmax = 384000, .wmin = 64,   .wmax = 64, },\n\t{ .rmin = 705600, .rmax = 768000, .wmin = 32,   .wmax = 32, },\n};\n\n \nstatic struct imx_akcodec_tdm_fs_mul ak5558_tdm_fs_mul[] = {\n\t{ .min = 128,\t.max = 128,\t.mul = 256 },\n\t{ .min = 256,\t.max = 256,\t.mul = 512 },\n\t{ .min = 512,\t.max = 512,\t.mul = 1024 },\n};\n\nstatic const u32 akcodec_rates[] = {\n\t8000, 11025, 16000, 22050, 32000, 44100, 48000, 88200,\n\t96000, 176400, 192000, 352800, 384000, 705600, 768000,\n};\n\nstatic const u32 akcodec_tdm_rates[] = {\n\t8000, 16000, 32000, 48000, 96000,\n};\n\nstatic const u32 ak4458_channels[] = {\n\t1, 2, 4, 6, 8, 10, 12, 14, 16,\n};\n\nstatic const u32 ak4458_tdm_channels[] = {\n\t1, 2, 3, 4, 5, 6, 7, 8, 16,\n};\n\nstatic const u32 ak5558_channels[] = {\n\t1, 2, 4, 6, 8,\n};\n\nstatic const u32 ak5558_tdm_channels[] = {\n\t1, 2, 3, 4, 5, 6, 7, 8,\n};\n\nstatic bool format_is_dsd(struct snd_pcm_hw_params *params)\n{\n\tsnd_pcm_format_t format = params_format(params);\n\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_DSD_U8:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_BE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_BE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool format_is_tdm(struct dai_link_data *link_data)\n{\n\tif (link_data->slots > 2)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool codec_is_akcodec(unsigned int type)\n{\n\tswitch (type) {\n\tcase CODEC_AK4458:\n\tcase CODEC_AK4497:\n\tcase CODEC_AK5558:\n\tcase CODEC_AK5552:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic unsigned long akcodec_get_mclk_rate(struct snd_pcm_substream *substream,\n\t\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t\t   int slots, int slot_width)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct imx_card_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tconst struct imx_card_plat_data *plat_data = data->plat_data;\n\tstruct dai_link_data *link_data = &data->link_data[rtd->num];\n\tunsigned int width = slots * slot_width;\n\tunsigned int rate = params_rate(params);\n\tint i;\n\n\tif (format_is_tdm(link_data)) {\n\t\tfor (i = 0; i < plat_data->num_tdm_fs_mul; i++) {\n\t\t\t \n\t\t\tif (width != plat_data->tdm_fs_mul[i].min)\n\t\t\t\tcontinue;\n\t\t\treturn rate * plat_data->tdm_fs_mul[i].mul;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < plat_data->num_fs_mul; i++) {\n\t\t\tif (rate >= plat_data->fs_mul[i].rmin &&\n\t\t\t    rate <= plat_data->fs_mul[i].rmax) {\n\t\t\t\twidth = max(width, plat_data->fs_mul[i].wmin);\n\t\t\t\twidth = min(width, plat_data->fs_mul[i].wmax);\n\n\t\t\t\t \n\t\t\t\twidth *= link_data->one2one_ratio ? 1 : 2;\n\n\t\t\t\treturn rate * width;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nstatic int imx_aif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct imx_card_data *data = snd_soc_card_get_drvdata(card);\n\tstruct dai_link_data *link_data = &data->link_data[rtd->num];\n\tstruct imx_card_plat_data *plat_data = data->plat_data;\n\tstruct device *dev = card->dev;\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned long mclk_freq;\n\tunsigned int fmt = rtd->dai_link->dai_fmt;\n\tunsigned int slots, slot_width;\n\tint ret, i;\n\n\tslots = link_data->slots;\n\tslot_width = link_data->slot_width;\n\n\tif (!format_is_tdm(link_data)) {\n\t\tif (format_is_dsd(params)) {\n\t\t\tslots = 1;\n\t\t\tslot_width = params_width(params);\n\t\t\tfmt = (rtd->dai_link->dai_fmt & ~SND_SOC_DAIFMT_FORMAT_MASK) |\n\t\t\t      SND_SOC_DAIFMT_PDM;\n\t\t} else {\n\t\t\tslots = 2;\n\t\t\tslot_width = params_physical_width(params);\n\t\t\tfmt = (rtd->dai_link->dai_fmt & ~SND_SOC_DAIFMT_FORMAT_MASK) |\n\t\t\t      SND_SOC_DAIFMT_I2S;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_fmt(cpu_dai, snd_soc_daifmt_clock_provider_flipped(fmt));\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set cpu dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_dai_set_tdm_slot(cpu_dai,\n\t\t\t\t       BIT(slots) - 1,\n\t\t\t\t       BIT(slots) - 1,\n\t\t\t\t       slots, slot_width);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set cpu dai tdm slot: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_fmt(codec_dai, fmt);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dev, \"failed to set codec dai[%d] fmt: %d\\n\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai,\n\t\t\t\t\t       BIT(slots) - 1,\n\t\t\t\t\t       BIT(slots) - 1,\n\t\t\t\t\t       slots, slot_width);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dev, \"failed to set codec dai[%d] tdm slot: %d\\n\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (codec_is_akcodec(plat_data->type))\n\t\tmclk_freq = akcodec_get_mclk_rate(substream, params, slots, slot_width);\n\telse\n\t\tmclk_freq = params_rate(params) * slots * slot_width;\n\n\tif (format_is_dsd(params)) {\n\t\t \n\t\tif (!(params_rate(params) % 11025))\n\t\t\tmclk_freq = IMX_CARD_MCLK_22P5792MHZ;\n\t\telse\n\t\t\tmclk_freq = IMX_CARD_MCLK_24P576MHZ;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, link_data->cpu_sysclk_id, mclk_freq,\n\t\t\t\t     SND_SOC_CLOCK_OUT);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set cpui dai mclk1 rate (%lu): %d\\n\", mclk_freq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ak5558_hw_rule_rate(struct snd_pcm_hw_params *p, struct snd_pcm_hw_rule *r)\n{\n\tstruct dai_link_data *link_data = r->private;\n\tstruct snd_interval t = { .min = 8000, .max = 8000, };\n\tunsigned long mclk_freq;\n\tunsigned int fs;\n\tint i;\n\n\tfs = hw_param_interval(p, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\n\tfs *= link_data->slots;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(akcodec_rates); i++) {\n\t\tmclk_freq = fs * akcodec_rates[i];\n\t\t \n\t\tmclk_freq *= link_data->one2one_ratio ? 1 : 2;\n\n\t\t \n\t\tif (mclk_freq > 36864000)\n\t\t\tcontinue;\n\n\t\tif (t.max < akcodec_rates[i])\n\t\t\tt.max = akcodec_rates[i];\n\t}\n\n\treturn snd_interval_refine(hw_param_interval(p, r->var), &t);\n}\n\nstatic int imx_aif_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct imx_card_data *data = snd_soc_card_get_drvdata(card);\n\tstruct dai_link_data *link_data = &data->link_data[rtd->num];\n\tstatic struct snd_pcm_hw_constraint_list constraint_rates;\n\tstatic struct snd_pcm_hw_constraint_list constraint_channels;\n\tint ret = 0;\n\n\tif (format_is_tdm(link_data)) {\n\t\tconstraint_channels.list = data->plat_data->support_tdm_channels;\n\t\tconstraint_channels.count = data->plat_data->num_tdm_channels;\n\t\tconstraint_rates.list = data->plat_data->support_tdm_rates;\n\t\tconstraint_rates.count = data->plat_data->num_tdm_rates;\n\t} else {\n\t\tconstraint_channels.list = data->plat_data->support_channels;\n\t\tconstraint_channels.count = data->plat_data->num_channels;\n\t\tconstraint_rates.list = data->plat_data->support_rates;\n\t\tconstraint_rates.count = data->plat_data->num_rates;\n\t}\n\n\tif (constraint_channels.count) {\n\t\tret = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t\t SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t\t &constraint_channels);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (constraint_rates.count) {\n\t\tret = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t\t SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t &constraint_rates);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (data->plat_data->type == CODEC_AK5558)\n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  ak5558_hw_rule_rate, link_data,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_SAMPLE_BITS, -1);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops imx_aif_ops = {\n\t.hw_params = imx_aif_hw_params,\n\t.startup = imx_aif_startup,\n};\n\nstatic const struct snd_soc_ops imx_aif_ops_be = {\n\t.hw_params = imx_aif_hw_params,\n};\n\nstatic int be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct imx_card_data *data = snd_soc_card_get_drvdata(card);\n\tstruct snd_interval *rate;\n\tstruct snd_mask *mask;\n\n\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\trate->max = data->asrc_rate;\n\trate->min = data->asrc_rate;\n\n\tmask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tsnd_mask_none(mask);\n\tsnd_mask_set(mask, (__force unsigned int)data->asrc_format);\n\n\treturn 0;\n}\n\nstatic int imx_card_parse_of(struct imx_card_data *data)\n{\n\tstruct imx_card_plat_data *plat_data = data->plat_data;\n\tstruct snd_soc_card *card = &data->card;\n\tstruct snd_soc_dai_link_component *dlc;\n\tstruct device_node *platform = NULL;\n\tstruct device_node *codec = NULL;\n\tstruct device_node *cpu = NULL;\n\tstruct device_node *np;\n\tstruct device *dev = card->dev;\n\tstruct snd_soc_dai_link *link;\n\tstruct dai_link_data *link_data;\n\tstruct of_phandle_args args;\n\tint ret, num_links;\n\tu32 asrc_fmt = 0;\n\tu32 width;\n\n\tret = snd_soc_of_parse_card_name(card, \"model\");\n\tif (ret) {\n\t\tdev_err(dev, \"Error parsing card name: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (of_property_read_bool(dev->of_node, \"audio-routing\")) {\n\t\tret = snd_soc_of_parse_audio_routing(card, \"audio-routing\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tnum_links = of_get_child_count(dev->of_node);\n\n\t \n\tcard->dai_link = devm_kcalloc(dev, num_links, sizeof(*link), GFP_KERNEL);\n\tif (!card->dai_link)\n\t\treturn -ENOMEM;\n\n\tdata->link_data = devm_kcalloc(dev, num_links, sizeof(*link), GFP_KERNEL);\n\tif (!data->link_data)\n\t\treturn -ENOMEM;\n\n\tcard->num_links = num_links;\n\tlink = card->dai_link;\n\tlink_data = data->link_data;\n\n\tfor_each_child_of_node(dev->of_node, np) {\n\t\tdlc = devm_kzalloc(dev, 2 * sizeof(*dlc), GFP_KERNEL);\n\t\tif (!dlc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_np;\n\t\t}\n\n\t\tlink->cpus\t= &dlc[0];\n\t\tlink->platforms\t= &dlc[1];\n\n\t\tlink->num_cpus\t\t= 1;\n\t\tlink->num_platforms\t= 1;\n\n\t\tret = of_property_read_string(np, \"link-name\", &link->name);\n\t\tif (ret) {\n\t\t\tdev_err(card->dev, \"error getting codec dai_link name\\n\");\n\t\t\tgoto err_put_np;\n\t\t}\n\n\t\tcpu = of_get_child_by_name(np, \"cpu\");\n\t\tif (!cpu) {\n\t\t\tdev_err(dev, \"%s: Can't find cpu DT node\\n\", link->name);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = snd_soc_of_get_dlc(cpu, &args, link->cpus, 0);\n\t\tif (ret) {\n\t\t\tdev_err_probe(card->dev, ret,\n\t\t\t\t      \"%s: error getting cpu dai info\\n\", link->name);\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (of_node_name_eq(args.np, \"sai\")) {\n\t\t\t \n\t\t\tlink_data->cpu_sysclk_id = FSL_SAI_CLK_MAST1;\n\n\t\t\t \n\t\t\tif (of_property_read_bool(np, \"fsl,mclk-equal-bclk\")) {\n\t\t\t\tlink_data->one2one_ratio = true;\n\t\t\t} else {\n\t\t\t\tint i;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(ak4497_fs_mul); i++) {\n\t\t\t\t\tif (ak4497_fs_mul[i].rmin == 705600 &&\n\t\t\t\t\t    ak4497_fs_mul[i].rmax == 768000) {\n\t\t\t\t\t\tak4497_fs_mul[i].wmin = 32;\n\t\t\t\t\t\tak4497_fs_mul[i].wmax = 32;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlink->platforms->of_node = link->cpus->of_node;\n\t\tlink->id = args.args[0];\n\n\t\tcodec = of_get_child_by_name(np, \"codec\");\n\t\tif (codec) {\n\t\t\tret = snd_soc_of_get_dai_link_codecs(dev, codec, link);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err_probe(dev, ret, \"%s: codec dai not found\\n\",\n\t\t\t\t\t\tlink->name);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tplat_data->num_codecs = link->num_codecs;\n\n\t\t\t \n\t\t\tif (!strcmp(link->codecs->dai_name, \"ak4458-aif\"))\n\t\t\t\tplat_data->type = CODEC_AK4458;\n\t\t\telse if (!strcmp(link->codecs->dai_name, \"ak4497-aif\"))\n\t\t\t\tplat_data->type = CODEC_AK4497;\n\t\t\telse if (!strcmp(link->codecs->dai_name, \"ak5558-aif\"))\n\t\t\t\tplat_data->type = CODEC_AK5558;\n\t\t\telse if (!strcmp(link->codecs->dai_name, \"ak5552-aif\"))\n\t\t\t\tplat_data->type = CODEC_AK5552;\n\n\t\t} else {\n\t\t\tlink->codecs\t = &asoc_dummy_dlc;\n\t\t\tlink->num_codecs = 1;\n\t\t}\n\n\t\tif (!strncmp(link->name, \"HiFi-ASRC-FE\", 12)) {\n\t\t\t \n\t\t\tlink->dynamic = 1;\n\t\t\tlink->dpcm_merged_chan = 1;\n\n\t\t\tret = of_property_read_u32(args.np, \"fsl,asrc-rate\", &data->asrc_rate);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"failed to get output rate\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = of_property_read_u32(args.np, \"fsl,asrc-format\", &asrc_fmt);\n\t\t\tdata->asrc_format = (__force snd_pcm_format_t)asrc_fmt;\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tret = of_property_read_u32(args.np, \"fsl,asrc-width\", &width);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\"failed to decide output format\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\tif (width == 24)\n\t\t\t\t\tdata->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t\t\t\telse\n\t\t\t\t\tdata->asrc_format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t\t}\n\t\t} else if (!strncmp(link->name, \"HiFi-ASRC-BE\", 12)) {\n\t\t\t \n\t\t\tlink->no_pcm = 1;\n\t\t\tlink->platforms->of_node = NULL;\n\t\t\tlink->platforms->name = \"snd-soc-dummy\";\n\n\t\t\tlink->be_hw_params_fixup = be_hw_params_fixup;\n\t\t\tlink->ops = &imx_aif_ops_be;\n\t\t} else {\n\t\t\tlink->ops = &imx_aif_ops;\n\t\t}\n\n\t\tif (link->no_pcm || link->dynamic)\n\t\t\tsnd_soc_dai_link_set_capabilities(link);\n\n\t\t \n\t\tret = asoc_simple_parse_daifmt(dev, np, codec,\n\t\t\t\t\t       NULL, &link->dai_fmt);\n\t\tif (ret)\n\t\t\tlink->dai_fmt = SND_SOC_DAIFMT_NB_NF |\n\t\t\t\t\tSND_SOC_DAIFMT_CBC_CFC |\n\t\t\t\t\tSND_SOC_DAIFMT_I2S;\n\n\t\t \n\t\tsnd_soc_of_parse_tdm_slot(np, NULL, NULL,\n\t\t\t\t\t  &link_data->slots,\n\t\t\t\t\t  &link_data->slot_width);\n\t\t \n\t\tif (!link_data->slots)\n\t\t\tlink_data->slots = 2;\n\n\t\tif (!link_data->slot_width)\n\t\t\tlink_data->slot_width = 32;\n\n\t\tlink->ignore_pmdown_time = 1;\n\t\tlink->stream_name = link->name;\n\t\tlink++;\n\t\tlink_data++;\n\n\t\tof_node_put(cpu);\n\t\tof_node_put(codec);\n\t\tof_node_put(platform);\n\n\t\tcpu = NULL;\n\t\tcodec = NULL;\n\t\tplatform = NULL;\n\t}\n\n\treturn 0;\nerr:\n\tof_node_put(cpu);\n\tof_node_put(codec);\n\tof_node_put(platform);\nerr_put_np:\n\tof_node_put(np);\n\treturn ret;\n}\n\nstatic int imx_card_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_dai_link *link_be = NULL, *link;\n\tstruct imx_card_plat_data *plat_data;\n\tstruct imx_card_data *data;\n\tint ret, i;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplat_data = devm_kzalloc(&pdev->dev, sizeof(*plat_data), GFP_KERNEL);\n\tif (!plat_data)\n\t\treturn -ENOMEM;\n\n\tdata->plat_data = plat_data;\n\tdata->card.dev = &pdev->dev;\n\n\tdev_set_drvdata(&pdev->dev, &data->card);\n\tsnd_soc_card_set_drvdata(&data->card, data);\n\tret = imx_card_parse_of(data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->num_dapm_routes = plat_data->num_codecs + 1;\n\tdata->dapm_routes = devm_kcalloc(&pdev->dev, data->num_dapm_routes,\n\t\t\t\t\t sizeof(struct snd_soc_dapm_route),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!data->dapm_routes)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (plat_data->type) {\n\tcase CODEC_AK4458:\n\tcase CODEC_AK4497:\n\t\tif (plat_data->num_codecs == 1) {\n\t\t\tdata->dapm_routes[0].sink = \"Playback\";\n\t\t\tdata->dapm_routes[0].source = \"CPU-Playback\";\n\t\t\ti = 1;\n\t\t} else {\n\t\t\tfor (i = 0; i < plat_data->num_codecs; i++) {\n\t\t\t\tdata->dapm_routes[i].sink =\n\t\t\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"%d %s\",\n\t\t\t\t\t\t       i + 1, \"Playback\");\n\t\t\t\tdata->dapm_routes[i].source = \"CPU-Playback\";\n\t\t\t}\n\t\t}\n\t\tdata->dapm_routes[i].sink = \"CPU-Playback\";\n\t\tdata->dapm_routes[i].source = \"ASRC-Playback\";\n\t\tbreak;\n\tcase CODEC_AK5558:\n\tcase CODEC_AK5552:\n\t\tif (plat_data->num_codecs == 1) {\n\t\t\tdata->dapm_routes[0].sink = \"CPU-Capture\";\n\t\t\tdata->dapm_routes[0].source = \"Capture\";\n\t\t\ti = 1;\n\t\t} else {\n\t\t\tfor (i = 0; i < plat_data->num_codecs; i++) {\n\t\t\t\tdata->dapm_routes[i].source =\n\t\t\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"%d %s\",\n\t\t\t\t\t\t       i + 1, \"Capture\");\n\t\t\t\tdata->dapm_routes[i].sink = \"CPU-Capture\";\n\t\t\t}\n\t\t}\n\t\tdata->dapm_routes[i].sink = \"ASRC-Capture\";\n\t\tdata->dapm_routes[i].source = \"CPU-Capture\";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (codec_is_akcodec(plat_data->type)) {\n\t\tplat_data->support_rates = akcodec_rates;\n\t\tplat_data->num_rates = ARRAY_SIZE(akcodec_rates);\n\t\tplat_data->support_tdm_rates = akcodec_tdm_rates;\n\t\tplat_data->num_tdm_rates = ARRAY_SIZE(akcodec_tdm_rates);\n\n\t\tswitch (plat_data->type) {\n\t\tcase CODEC_AK4458:\n\t\t\tplat_data->fs_mul = ak4458_fs_mul;\n\t\t\tplat_data->num_fs_mul = ARRAY_SIZE(ak4458_fs_mul);\n\t\t\tplat_data->tdm_fs_mul = ak4458_tdm_fs_mul;\n\t\t\tplat_data->num_tdm_fs_mul = ARRAY_SIZE(ak4458_tdm_fs_mul);\n\t\t\tplat_data->support_channels = ak4458_channels;\n\t\t\tplat_data->num_channels = ARRAY_SIZE(ak4458_channels);\n\t\t\tplat_data->support_tdm_channels = ak4458_tdm_channels;\n\t\t\tplat_data->num_tdm_channels = ARRAY_SIZE(ak4458_tdm_channels);\n\t\t\tbreak;\n\t\tcase CODEC_AK4497:\n\t\t\tplat_data->fs_mul = ak4497_fs_mul;\n\t\t\tplat_data->num_fs_mul = ARRAY_SIZE(ak4497_fs_mul);\n\t\t\tplat_data->support_channels = ak4458_channels;\n\t\t\tplat_data->num_channels = ARRAY_SIZE(ak4458_channels);\n\t\t\tbreak;\n\t\tcase CODEC_AK5558:\n\t\tcase CODEC_AK5552:\n\t\t\tplat_data->fs_mul = ak5558_fs_mul;\n\t\t\tplat_data->num_fs_mul = ARRAY_SIZE(ak5558_fs_mul);\n\t\t\tplat_data->tdm_fs_mul = ak5558_tdm_fs_mul;\n\t\t\tplat_data->num_tdm_fs_mul = ARRAY_SIZE(ak5558_tdm_fs_mul);\n\t\t\tplat_data->support_channels = ak5558_channels;\n\t\t\tplat_data->num_channels = ARRAY_SIZE(ak5558_channels);\n\t\t\tplat_data->support_tdm_channels = ak5558_tdm_channels;\n\t\t\tplat_data->num_tdm_channels = ARRAY_SIZE(ak5558_tdm_channels);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (data->card.num_links == 3) {\n\t\tdata->card.dapm_routes = data->dapm_routes;\n\t\tdata->card.num_dapm_routes = data->num_dapm_routes;\n\t\tfor_each_card_prelinks(&data->card, i, link) {\n\t\t\tif (link->no_pcm == 1)\n\t\t\t\tlink_be = link;\n\t\t}\n\t\tfor_each_card_prelinks(&data->card, i, link) {\n\t\t\tif (link->dynamic == 1 && link_be) {\n\t\t\t\tlink->dpcm_playback = link_be->dpcm_playback;\n\t\t\t\tlink->dpcm_capture = link_be->dpcm_capture;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &data->card);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"snd_soc_register_card failed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct of_device_id imx_card_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-audio-card\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, imx_card_dt_ids);\n\nstatic struct platform_driver imx_card_driver = {\n\t.driver = {\n\t\t.name = \"imx-card\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = imx_card_dt_ids,\n\t},\n\t.probe = imx_card_probe,\n};\nmodule_platform_driver(imx_card_driver);\n\nMODULE_DESCRIPTION(\"Freescale i.MX ASoC Machine Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-card\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}