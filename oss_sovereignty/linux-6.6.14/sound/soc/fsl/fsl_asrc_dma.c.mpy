{
  "module_name": "fsl_asrc_dma.c",
  "hash_id": "fc79e9d1f148b4302085495652e5db224eba857e3d77cf5a9ad92fde29ea12ca",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_asrc_dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/dma/imx-dma.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"fsl_asrc_common.h\"\n\n#define FSL_ASRC_DMABUF_SIZE\t(256 * 1024)\n\nstatic struct snd_pcm_hardware snd_imx_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t.buffer_bytes_max = FSL_ASRC_DMABUF_SIZE,\n\t.period_bytes_min = 128,\n\t.period_bytes_max = 65535,  \n\t.periods_min = 2,\n\t.periods_max = 255,\n\t.fifo_size = 0,\n};\n\nstatic bool filter(struct dma_chan *chan, void *param)\n{\n\tif (!imx_dma_is_general_purpose(chan))\n\t\treturn false;\n\n\tchan->private = param;\n\n\treturn true;\n}\n\nstatic void fsl_asrc_dma_complete(void *arg)\n{\n\tstruct snd_pcm_substream *substream = arg;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\n\tpair->pos += snd_pcm_lib_period_bytes(substream);\n\tif (pair->pos >= snd_pcm_lib_buffer_bytes(substream))\n\t\tpair->pos = 0;\n\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int fsl_asrc_dma_prepare_and_submit(struct snd_pcm_substream *substream,\n\t\t\t\t\t   struct snd_soc_component *component)\n{\n\tu8 dir = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? OUT : IN;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tunsigned long flags = DMA_CTRL_ACK;\n\n\t \n\tif (!substream->runtime->no_period_wakeup)\n\t\tflags |= DMA_PREP_INTERRUPT;\n\n\tpair->pos = 0;\n\tpair->desc[!dir] = dmaengine_prep_dma_cyclic(\n\t\t\tpair->dma_chan[!dir], runtime->dma_addr,\n\t\t\tsnd_pcm_lib_buffer_bytes(substream),\n\t\t\tsnd_pcm_lib_period_bytes(substream),\n\t\t\tdir == OUT ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM, flags);\n\tif (!pair->desc[!dir]) {\n\t\tdev_err(dev, \"failed to prepare slave DMA for Front-End\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpair->desc[!dir]->callback = fsl_asrc_dma_complete;\n\tpair->desc[!dir]->callback_param = substream;\n\n\tdmaengine_submit(pair->desc[!dir]);\n\n\t \n\tpair->desc[dir] = dmaengine_prep_dma_cyclic(\n\t\t\tpair->dma_chan[dir], 0xffff, 64, 64, DMA_DEV_TO_DEV, 0);\n\tif (!pair->desc[dir]) {\n\t\tdev_err(dev, \"failed to prepare slave DMA for Back-End\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdmaengine_submit(pair->desc[dir]);\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dma_trigger(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = fsl_asrc_dma_prepare_and_submit(substream, component);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdma_async_issue_pending(pair->dma_chan[IN]);\n\t\tdma_async_issue_pending(pair->dma_chan[OUT]);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdmaengine_terminate_async(pair->dma_chan[OUT]);\n\t\tdmaengine_terminate_async(pair->dma_chan[IN]);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dma_hw_params(struct snd_soc_component *component,\n\t\t\t\t  struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params)\n{\n\tenum dma_slave_buswidth buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\tenum sdma_peripheral_type be_peripheral_type = IMX_DMATYPE_SSI;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct snd_dmaengine_dai_dma_data *dma_params_fe = NULL;\n\tstruct snd_dmaengine_dai_dma_data *dma_params_be = NULL;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tstruct dma_chan *tmp_chan = NULL, *be_chan = NULL;\n\tstruct snd_soc_component *component_be = NULL;\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tstruct dma_slave_config config_fe = {}, config_be = {};\n\tstruct sdma_peripheral_config audio_config;\n\tenum asrc_pair_index index = pair->index;\n\tstruct device *dev = component->dev;\n\tstruct device_node *of_dma_node;\n\tint stream = substream->stream;\n\tstruct imx_dma_data *tmp_data;\n\tstruct snd_soc_dpcm *dpcm;\n\tstruct device *dev_be;\n\tu8 dir = tx ? OUT : IN;\n\tdma_cap_mask_t mask;\n\tint ret, width;\n\n\t \n\tfor_each_dpcm_be(rtd, stream, dpcm) {\n\t\tstruct snd_soc_pcm_runtime *be = dpcm->be;\n\t\tstruct snd_pcm_substream *substream_be;\n\t\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(be, 0);\n\n\t\tif (dpcm->fe != rtd)\n\t\t\tcontinue;\n\n\t\tsubstream_be = snd_soc_dpcm_get_substream(be, stream);\n\t\tdma_params_be = snd_soc_dai_get_dma_data(dai, substream_be);\n\t\tdev_be = dai->dev;\n\t\tbreak;\n\t}\n\n\tif (!dma_params_be) {\n\t\tdev_err(dev, \"failed to get the substream of Back-End\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdma_params_fe = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\tdma_params_fe->addr = asrc->paddr + asrc->get_fifo_addr(!dir, index);\n\tdma_params_fe->maxburst = dma_params_be->maxburst;\n\n\tpair->dma_chan[!dir] = asrc->get_dma_channel(pair, !dir);\n\tif (!pair->dma_chan[!dir]) {\n\t\tdev_err(dev, \"failed to request DMA channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_dmaengine_pcm_prepare_slave_config(substream, params, &config_fe);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to prepare DMA config for Front-End\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dmaengine_slave_config(pair->dma_chan[!dir], &config_fe);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to config DMA channel for Front-End\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tdma_cap_set(DMA_CYCLIC, mask);\n\n\t \n\tcomponent_be = snd_soc_lookup_component_nolocked(dev_be, SND_DMAENGINE_PCM_DRV_NAME);\n\tif (component_be) {\n\t\tbe_chan = soc_component_to_pcm(component_be)->chan[substream->stream];\n\t\ttmp_chan = be_chan;\n\t}\n\tif (!tmp_chan) {\n\t\ttmp_chan = dma_request_chan(dev_be, tx ? \"tx\" : \"rx\");\n\t\tif (IS_ERR(tmp_chan)) {\n\t\t\tdev_err(dev, \"failed to request DMA channel for Back-End\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!asrc->use_edma) {\n\t\t \n\t\ttmp_data = tmp_chan->private;\n\t\tpair->dma_data.dma_request = tmp_data->dma_request;\n\t\tbe_peripheral_type = tmp_data->peripheral_type;\n\t\tif (!be_chan)\n\t\t\tdma_release_channel(tmp_chan);\n\n\t\t \n\t\ttmp_chan = asrc->get_dma_channel(pair, dir);\n\t\ttmp_data = tmp_chan->private;\n\t\tpair->dma_data.dma_request2 = tmp_data->dma_request;\n\t\tpair->dma_data.peripheral_type = tmp_data->peripheral_type;\n\t\tpair->dma_data.priority = tmp_data->priority;\n\t\tdma_release_channel(tmp_chan);\n\n\t\tof_dma_node = pair->dma_chan[!dir]->device->dev->of_node;\n\t\tpair->dma_chan[dir] =\n\t\t\t__dma_request_channel(&mask, filter, &pair->dma_data,\n\t\t\t\t\t      of_dma_node);\n\t\tpair->req_dma_chan = true;\n\t} else {\n\t\tpair->dma_chan[dir] = tmp_chan;\n\t\t \n\t\tpair->req_dma_chan = !be_chan;\n\t}\n\n\tif (!pair->dma_chan[dir]) {\n\t\tdev_err(dev, \"failed to request DMA channel for Back-End\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twidth = snd_pcm_format_physical_width(asrc->asrc_format);\n\tif (width < 8 || width > 64)\n\t\treturn -EINVAL;\n\telse if (width == 8)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\telse if (width == 16)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\telse if (width == 24)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_3_BYTES;\n\telse if (width <= 32)\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\telse\n\t\tbuswidth = DMA_SLAVE_BUSWIDTH_8_BYTES;\n\n\tconfig_be.direction = DMA_DEV_TO_DEV;\n\tconfig_be.src_addr_width = buswidth;\n\tconfig_be.src_maxburst = dma_params_be->maxburst;\n\tconfig_be.dst_addr_width = buswidth;\n\tconfig_be.dst_maxburst = dma_params_be->maxburst;\n\n\tmemset(&audio_config, 0, sizeof(audio_config));\n\tconfig_be.peripheral_config = &audio_config;\n\tconfig_be.peripheral_size  = sizeof(audio_config);\n\n\tif (tx && (be_peripheral_type == IMX_DMATYPE_SSI_DUAL ||\n\t\t   be_peripheral_type == IMX_DMATYPE_SPDIF))\n\t\taudio_config.n_fifos_dst = 2;\n\tif (!tx && (be_peripheral_type == IMX_DMATYPE_SSI_DUAL ||\n\t\t    be_peripheral_type == IMX_DMATYPE_SPDIF))\n\t\taudio_config.n_fifos_src = 2;\n\n\tif (tx) {\n\t\tconfig_be.src_addr = asrc->paddr + asrc->get_fifo_addr(OUT, index);\n\t\tconfig_be.dst_addr = dma_params_be->addr;\n\t} else {\n\t\tconfig_be.dst_addr = asrc->paddr + asrc->get_fifo_addr(IN, index);\n\t\tconfig_be.src_addr = dma_params_be->addr;\n\t}\n\n\tret = dmaengine_slave_config(pair->dma_chan[dir], &config_be);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to config DMA channel for Back-End\\n\");\n\t\tif (pair->req_dma_chan)\n\t\t\tdma_release_channel(pair->dma_chan[dir]);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dma_hw_free(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tu8 dir = tx ? OUT : IN;\n\n\tif (pair->dma_chan[!dir])\n\t\tdma_release_channel(pair->dma_chan[!dir]);\n\n\t \n\tif (pair->dma_chan[dir] && pair->req_dma_chan)\n\t\tdma_release_channel(pair->dma_chan[dir]);\n\n\tpair->dma_chan[!dir] = NULL;\n\tpair->dma_chan[dir] = NULL;\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dma_startup(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tstruct device *dev = component->dev;\n\tstruct fsl_asrc *asrc = dev_get_drvdata(dev);\n\tstruct fsl_asrc_pair *pair;\n\tstruct dma_chan *tmp_chan = NULL;\n\tu8 dir = tx ? OUT : IN;\n\tbool release_pair = true;\n\tint ret = 0;\n\n\tret = snd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to set pcm hw params periods\\n\");\n\t\treturn ret;\n\t}\n\n\tpair = kzalloc(sizeof(*pair) + asrc->pair_priv_size, GFP_KERNEL);\n\tif (!pair)\n\t\treturn -ENOMEM;\n\n\tpair->asrc = asrc;\n\tpair->private = (void *)pair + sizeof(struct fsl_asrc_pair);\n\n\truntime->private_data = pair;\n\n\t \n\tret = asrc->request_pair(1, pair);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to request asrc pair\\n\");\n\t\tgoto req_pair_err;\n\t}\n\n\t \n\ttmp_chan = asrc->get_dma_channel(pair, dir);\n\tif (!tmp_chan) {\n\t\tdev_err(dev, \"failed to get dma channel\\n\");\n\t\tret = -EINVAL;\n\t\tgoto dma_chan_err;\n\t}\n\n\tdma_data = snd_soc_dai_get_dma_data(asoc_rtd_to_cpu(rtd, 0), substream);\n\n\t \n\tret = snd_dmaengine_pcm_refine_runtime_hwparams(substream,\n\t\t\t\t\t\t\tdma_data,\n\t\t\t\t\t\t\t&snd_imx_hardware,\n\t\t\t\t\t\t\ttmp_chan);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to refine runtime hwparams\\n\");\n\t\tgoto out;\n\t}\n\n\trelease_pair = false;\n\tsnd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);\n\nout:\n\tdma_release_channel(tmp_chan);\n\ndma_chan_err:\n\tasrc->release_pair(pair);\n\nreq_pair_err:\n\tif (release_pair)\n\t\tkfree(pair);\n\n\treturn ret;\n}\n\nstatic int fsl_asrc_dma_shutdown(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tstruct fsl_asrc *asrc;\n\n\tif (!pair)\n\t\treturn 0;\n\n\tasrc = pair->asrc;\n\n\tif (asrc->pair[pair->index] == pair)\n\t\tasrc->pair[pair->index] = NULL;\n\n\tkfree(pair);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nfsl_asrc_dma_pcm_pointer(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\n\treturn bytes_to_frames(substream->runtime, pair->pos);\n}\n\nstatic int fsl_asrc_dma_pcm_new(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(card->dev, \"failed to set DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    card->dev, FSL_ASRC_DMABUF_SIZE);\n}\n\nstruct snd_soc_component_driver fsl_asrc_component = {\n\t.name\t\t= DRV_NAME,\n\t.hw_params\t= fsl_asrc_dma_hw_params,\n\t.hw_free\t= fsl_asrc_dma_hw_free,\n\t.trigger\t= fsl_asrc_dma_trigger,\n\t.open\t\t= fsl_asrc_dma_startup,\n\t.close\t\t= fsl_asrc_dma_shutdown,\n\t.pointer\t= fsl_asrc_dma_pcm_pointer,\n\t.pcm_construct\t= fsl_asrc_dma_pcm_new,\n\t.legacy_dai_naming = 1,\n};\nEXPORT_SYMBOL_GPL(fsl_asrc_component);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}