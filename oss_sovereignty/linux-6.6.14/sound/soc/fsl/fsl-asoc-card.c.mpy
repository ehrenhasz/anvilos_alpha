{
  "module_name": "fsl-asoc-card.c",
  "hash_id": "305efb527a0404d46d4bab427e9ae3b9b358d482fbdddb3466c17109ec56baf3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl-asoc-card.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#if IS_ENABLED(CONFIG_SND_AC97_CODEC)\n#include <sound/ac97_codec.h>\n#endif\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/simple_card_utils.h>\n\n#include \"fsl_esai.h\"\n#include \"fsl_sai.h\"\n#include \"imx-audmux.h\"\n\n#include \"../codecs/sgtl5000.h\"\n#include \"../codecs/wm8962.h\"\n#include \"../codecs/wm8960.h\"\n#include \"../codecs/wm8994.h\"\n#include \"../codecs/tlv320aic31xx.h\"\n#include \"../codecs/nau8822.h\"\n\n#define DRIVER_NAME \"fsl-asoc-card\"\n\n#define CS427x_SYSCLK_MCLK 0\n\n#define RX 0\n#define TX 1\n\n \n#define DAI_FMT_BASE (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF)\n\n \nstruct codec_priv {\n\tstruct clk *mclk;\n\tunsigned long mclk_freq;\n\tunsigned long free_freq;\n\tu32 mclk_id;\n\tint fll_id;\n\tint pll_id;\n};\n\n \nstruct cpu_priv {\n\tunsigned long sysclk_freq[2];\n\tu32 sysclk_dir[2];\n\tu32 sysclk_id[2];\n\tu32 slot_width;\n\tu32 slot_num;\n};\n\n \n\nstruct fsl_asoc_card_priv {\n\tstruct snd_soc_dai_link dai_link[3];\n\tstruct asoc_simple_jack hp_jack;\n\tstruct asoc_simple_jack mic_jack;\n\tstruct platform_device *pdev;\n\tstruct codec_priv codec_priv;\n\tstruct cpu_priv cpu_priv;\n\tstruct snd_soc_card card;\n\tu8 streams;\n\tu32 sample_rate;\n\tsnd_pcm_format_t sample_format;\n\tu32 asrc_rate;\n\tsnd_pcm_format_t asrc_format;\n\tu32 dai_fmt;\n\tchar name[32];\n};\n\n \nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t \n\t{\"Playback\",  NULL, \"CPU-Playback\"},\n\t{\"CPU-Capture\",  NULL, \"Capture\"},\n\t \n\t{\"CPU-Playback\",  NULL, \"ASRC-Playback\"},\n\t{\"ASRC-Capture\",  NULL, \"CPU-Capture\"},\n};\n\nstatic const struct snd_soc_dapm_route audio_map_ac97[] = {\n\t \n\t{\"AC97 Playback\",  NULL, \"CPU AC97 Playback\"},\n\t{\"CPU AC97 Capture\",  NULL, \"AC97 Capture\"},\n\t \n\t{\"CPU AC97 Playback\",  NULL, \"ASRC-Playback\"},\n\t{\"ASRC-Capture\",  NULL, \"CPU AC97 Capture\"},\n};\n\nstatic const struct snd_soc_dapm_route audio_map_tx[] = {\n\t \n\t{\"Playback\",  NULL, \"CPU-Playback\"},\n\t \n\t{\"CPU-Playback\",  NULL, \"ASRC-Playback\"},\n};\n\nstatic const struct snd_soc_dapm_route audio_map_rx[] = {\n\t \n\t{\"CPU-Capture\",  NULL, \"Capture\"},\n\t \n\t{\"ASRC-Capture\",  NULL, \"CPU-Capture\"},\n};\n\n \nstatic const struct snd_soc_dapm_widget fsl_asoc_card_dapm_widgets[] = {\n\tSND_SOC_DAPM_LINE(\"Line Out Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In Jack\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_MIC(\"AMIC\", NULL),\n\tSND_SOC_DAPM_MIC(\"DMIC\", NULL),\n};\n\nstatic bool fsl_asoc_card_is_ac97(struct fsl_asoc_card_priv *priv)\n{\n\treturn priv->dai_fmt == SND_SOC_DAIFMT_AC97;\n}\n\nstatic int fsl_asoc_card_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct codec_priv *codec_priv = &priv->codec_priv;\n\tstruct cpu_priv *cpu_priv = &priv->cpu_priv;\n\tstruct device *dev = rtd->card->dev;\n\tunsigned int pll_out;\n\tint ret;\n\n\tpriv->sample_rate = params_rate(params);\n\tpriv->sample_format = params_format(params);\n\tpriv->streams |= BIT(substream->stream);\n\n\tif (fsl_asoc_card_is_ac97(priv))\n\t\treturn 0;\n\n\t \n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), cpu_priv->sysclk_id[tx],\n\t\t\t\t     cpu_priv->sysclk_freq[tx],\n\t\t\t\t     cpu_priv->sysclk_dir[tx]);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set sysclk for cpu dai\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (cpu_priv->slot_width) {\n\t\tif (!cpu_priv->slot_num)\n\t\t\tcpu_priv->slot_num = 2;\n\n\t\tret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0x3, 0x3,\n\t\t\t\t\t       cpu_priv->slot_num,\n\t\t\t\t\t       cpu_priv->slot_width);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dev, \"failed to set TDM slot for cpu dai\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (codec_priv->pll_id >= 0 && codec_priv->fll_id >= 0) {\n\t\tif (priv->sample_format == SNDRV_PCM_FORMAT_S24_LE)\n\t\t\tpll_out = priv->sample_rate * 384;\n\t\telse\n\t\t\tpll_out = priv->sample_rate * 256;\n\n\t\tret = snd_soc_dai_set_pll(asoc_rtd_to_codec(rtd, 0),\n\t\t\t\t\t  codec_priv->pll_id,\n\t\t\t\t\t  codec_priv->mclk_id,\n\t\t\t\t\t  codec_priv->mclk_freq, pll_out);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to start FLL: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0),\n\t\t\t\t\t     codec_priv->fll_id,\n\t\t\t\t\t     pll_out, SND_SOC_CLOCK_IN);\n\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dev, \"failed to set SYSCLK: %d\\n\", ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail:\n\tpriv->streams &= ~BIT(substream->stream);\n\treturn ret;\n}\n\nstatic int fsl_asoc_card_hw_free(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct codec_priv *codec_priv = &priv->codec_priv;\n\tstruct device *dev = rtd->card->dev;\n\tint ret;\n\n\tpriv->streams &= ~BIT(substream->stream);\n\n\tif (!priv->streams && codec_priv->pll_id >= 0 && codec_priv->fll_id >= 0) {\n\t\t \n\t\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0),\n\t\t\t\t\t     codec_priv->mclk_id,\n\t\t\t\t\t     codec_priv->free_freq,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to switch away from FLL: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = snd_soc_dai_set_pll(asoc_rtd_to_codec(rtd, 0),\n\t\t\t\t\t  codec_priv->pll_id, 0, 0, 0);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(dev, \"failed to stop FLL: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops fsl_asoc_card_ops = {\n\t.hw_params = fsl_asoc_card_hw_params,\n\t.hw_free = fsl_asoc_card_hw_free,\n};\n\nstatic int be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_interval *rate;\n\tstruct snd_mask *mask;\n\n\trate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\trate->max = rate->min = priv->asrc_rate;\n\n\tmask = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tsnd_mask_none(mask);\n\tsnd_mask_set_format(mask, priv->asrc_format);\n\n\treturn 0;\n}\n\nSND_SOC_DAILINK_DEFS(hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(hifi_fe,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(hifi_be,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_DUMMY()));\n\nstatic const struct snd_soc_dai_link fsl_asoc_card_dai[] = {\n\t \n\t{\n\t\t.name = \"HiFi\",\n\t\t.stream_name = \"HiFi\",\n\t\t.ops = &fsl_asoc_card_ops,\n\t\tSND_SOC_DAILINK_REG(hifi),\n\t},\n\t \n\t{\n\t\t.name = \"HiFi-ASRC-FE\",\n\t\t.stream_name = \"HiFi-ASRC-FE\",\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.dynamic = 1,\n\t\tSND_SOC_DAILINK_REG(hifi_fe),\n\t},\n\t{\n\t\t.name = \"HiFi-ASRC-BE\",\n\t\t.stream_name = \"HiFi-ASRC-BE\",\n\t\t.be_hw_params_fixup = be_hw_params_fixup,\n\t\t.ops = &fsl_asoc_card_ops,\n\t\t.dpcm_playback = 1,\n\t\t.dpcm_capture = 1,\n\t\t.no_pcm = 1,\n\t\tSND_SOC_DAILINK_REG(hifi_be),\n\t},\n};\n\nstatic int fsl_asoc_card_audmux_init(struct device_node *np,\n\t\t\t\t     struct fsl_asoc_card_priv *priv)\n{\n\tstruct device *dev = &priv->pdev->dev;\n\tu32 int_ptcr = 0, ext_ptcr = 0;\n\tint int_port, ext_port;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"mux-int-port\", &int_port);\n\tif (ret) {\n\t\tdev_err(dev, \"mux-int-port missing or invalid\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"mux-ext-port\", &ext_port);\n\tif (ret) {\n\t\tdev_err(dev, \"mux-ext-port missing or invalid\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tint_port--;\n\text_port--;\n\n\t \n\tswitch (priv->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tint_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCSEL(8 | ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCLKDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCLKDIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tint_ptcr = IMX_AUDMUX_V2_PTCR_RCSEL(8 | ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCLKDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCLKDIR;\n\t\text_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSDIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tint_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSDIR;\n\t\text_ptcr = IMX_AUDMUX_V2_PTCR_RCSEL(8 | int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCSEL(int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCLKDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCLKDIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\text_ptcr = IMX_AUDMUX_V2_PTCR_RFSEL(8 | int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCSEL(8 | int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCSEL(int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_RCLKDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSDIR |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCLKDIR;\n\t\tbreak;\n\tdefault:\n\t\tif (!fsl_asoc_card_is_ac97(priv))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (fsl_asoc_card_is_ac97(priv)) {\n\t\tint_ptcr = IMX_AUDMUX_V2_PTCR_SYN |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TCLKDIR;\n\t\text_ptcr = IMX_AUDMUX_V2_PTCR_SYN |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSEL(int_port) |\n\t\t\t   IMX_AUDMUX_V2_PTCR_TFSDIR;\n\t}\n\n\t \n\tif (!fsl_asoc_card_is_ac97(priv)) {\n\t\tunsigned int pdcr =\n\t\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port);\n\n\t\tret = imx_audmux_v2_configure_port(int_port, 0,\n\t\t\t\t\t\t   pdcr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"audmux internal port setup failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = imx_audmux_v2_configure_port(int_port, int_ptcr,\n\t\t\t\t\t   IMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));\n\tif (ret) {\n\t\tdev_err(dev, \"audmux internal port setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!fsl_asoc_card_is_ac97(priv)) {\n\t\tunsigned int pdcr =\n\t\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(int_port);\n\n\t\tret = imx_audmux_v2_configure_port(ext_port, 0,\n\t\t\t\t\t\t   pdcr);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"audmux external port setup failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = imx_audmux_v2_configure_port(ext_port, ext_ptcr,\n\t\t\t\t\t   IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));\n\tif (ret) {\n\t\tdev_err(dev, \"audmux external port setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hp_jack_event(struct notifier_block *nb, unsigned long event,\n\t\t\t void *data)\n{\n\tstruct snd_soc_jack *jack = (struct snd_soc_jack *)data;\n\tstruct snd_soc_dapm_context *dapm = &jack->card->dapm;\n\n\tif (event & SND_JACK_HEADPHONE)\n\t\t \n\t\treturn snd_soc_dapm_disable_pin(dapm, \"Ext Spk\");\n\telse\n\t\treturn snd_soc_dapm_enable_pin(dapm, \"Ext Spk\");\n}\n\nstatic struct notifier_block hp_jack_nb = {\n\t.notifier_call = hp_jack_event,\n};\n\nstatic int mic_jack_event(struct notifier_block *nb, unsigned long event,\n\t\t\t  void *data)\n{\n\tstruct snd_soc_jack *jack = (struct snd_soc_jack *)data;\n\tstruct snd_soc_dapm_context *dapm = &jack->card->dapm;\n\n\tif (event & SND_JACK_MICROPHONE)\n\t\t \n\t\treturn snd_soc_dapm_disable_pin(dapm, \"DMIC\");\n\telse\n\t\treturn snd_soc_dapm_enable_pin(dapm, \"DMIC\");\n}\n\nstatic struct notifier_block mic_jack_nb = {\n\t.notifier_call = mic_jack_event,\n};\n\nstatic int fsl_asoc_card_late_probe(struct snd_soc_card *card)\n{\n\tstruct fsl_asoc_card_priv *priv = snd_soc_card_get_drvdata(card);\n\tstruct snd_soc_pcm_runtime *rtd = list_first_entry(\n\t\t\t&card->rtd_list, struct snd_soc_pcm_runtime, list);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct codec_priv *codec_priv = &priv->codec_priv;\n\tstruct device *dev = card->dev;\n\tint ret;\n\n\tif (fsl_asoc_card_is_ac97(priv)) {\n#if IS_ENABLED(CONFIG_SND_AC97_CODEC)\n\t\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\t\tstruct snd_ac97 *ac97 = snd_soc_component_get_drvdata(component);\n\n\t\t \n\t\tsnd_ac97_update_bits(ac97, AC97_EXTENDED_STATUS,\n\t\t\t\t     AC97_EA_SPSA_SLOT_MASK, AC97_EA_SPSA_3_4);\n#endif\n\n\t\treturn 0;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, codec_priv->mclk_id,\n\t\t\t\t     codec_priv->mclk_freq, SND_SOC_CLOCK_IN);\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(dev, \"failed to set sysclk in %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR_OR_NULL(codec_priv->mclk))\n\t\tclk_prepare_enable(codec_priv->mclk);\n\n\treturn 0;\n}\n\nstatic int fsl_asoc_card_probe(struct platform_device *pdev)\n{\n\tstruct device_node *cpu_np, *codec_np, *asrc_np;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct platform_device *asrc_pdev = NULL;\n\tstruct device_node *bitclkprovider = NULL;\n\tstruct device_node *frameprovider = NULL;\n\tstruct platform_device *cpu_pdev;\n\tstruct fsl_asoc_card_priv *priv;\n\tstruct device *codec_dev = NULL;\n\tconst char *codec_dai_name;\n\tconst char *codec_dev_name;\n\tu32 asrc_fmt = 0;\n\tu32 width;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tcpu_np = of_parse_phandle(np, \"audio-cpu\", 0);\n\t \n\tif (!cpu_np)\n\t\tcpu_np = of_parse_phandle(np, \"ssi-controller\", 0);\n\tif (!cpu_np) {\n\t\tdev_err(&pdev->dev, \"CPU phandle missing or invalid\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tcpu_pdev = of_find_device_by_node(cpu_np);\n\tif (!cpu_pdev) {\n\t\tdev_err(&pdev->dev, \"failed to find CPU DAI device\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tcodec_np = of_parse_phandle(np, \"audio-codec\", 0);\n\tif (codec_np) {\n\t\tstruct platform_device *codec_pdev;\n\t\tstruct i2c_client *codec_i2c;\n\n\t\tcodec_i2c = of_find_i2c_device_by_node(codec_np);\n\t\tif (codec_i2c) {\n\t\t\tcodec_dev = &codec_i2c->dev;\n\t\t\tcodec_dev_name = codec_i2c->name;\n\t\t}\n\t\tif (!codec_dev) {\n\t\t\tcodec_pdev = of_find_device_by_node(codec_np);\n\t\t\tif (codec_pdev) {\n\t\t\t\tcodec_dev = &codec_pdev->dev;\n\t\t\t\tcodec_dev_name = codec_pdev->name;\n\t\t\t}\n\t\t}\n\t}\n\n\tasrc_np = of_parse_phandle(np, \"audio-asrc\", 0);\n\tif (asrc_np)\n\t\tasrc_pdev = of_find_device_by_node(asrc_np);\n\n\t \n\tif (codec_dev) {\n\t\tstruct clk *codec_clk = clk_get(codec_dev, NULL);\n\n\t\tif (!IS_ERR(codec_clk)) {\n\t\t\tpriv->codec_priv.mclk_freq = clk_get_rate(codec_clk);\n\t\t\tclk_put(codec_clk);\n\t\t}\n\t}\n\n\t \n\tpriv->sample_rate = 44100;\n\tpriv->sample_format = SNDRV_PCM_FORMAT_S16_LE;\n\n\t \n\tpriv->dai_fmt = DAI_FMT_BASE;\n\n\tmemcpy(priv->dai_link, fsl_asoc_card_dai,\n\t       sizeof(struct snd_soc_dai_link) * ARRAY_SIZE(priv->dai_link));\n\n\tpriv->card.dapm_routes = audio_map;\n\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map);\n\tpriv->card.driver_name = DRIVER_NAME;\n\n\tpriv->codec_priv.fll_id = -1;\n\tpriv->codec_priv.pll_id = -1;\n\n\t \n\tif (of_device_is_compatible(np, \"fsl,imx-audio-cs42888\")) {\n\t\tcodec_dai_name = \"cs42888\";\n\t\tpriv->cpu_priv.sysclk_freq[TX] = priv->codec_priv.mclk_freq;\n\t\tpriv->cpu_priv.sysclk_freq[RX] = priv->codec_priv.mclk_freq;\n\t\tpriv->cpu_priv.sysclk_dir[TX] = SND_SOC_CLOCK_OUT;\n\t\tpriv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_OUT;\n\t\tpriv->cpu_priv.slot_width = 32;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBC_CFC;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-cs427x\")) {\n\t\tcodec_dai_name = \"cs4271-hifi\";\n\t\tpriv->codec_priv.mclk_id = CS427x_SYSCLK_MCLK;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-sgtl5000\")) {\n\t\tcodec_dai_name = \"sgtl5000\";\n\t\tpriv->codec_priv.mclk_id = SGTL5000_SYSCLK;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-tlv320aic32x4\")) {\n\t\tcodec_dai_name = \"tlv320aic32x4-hifi\";\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-tlv320aic31xx\")) {\n\t\tcodec_dai_name = \"tlv320dac31xx-hifi\";\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBS_CFS;\n\t\tpriv->dai_link[1].dpcm_capture = 0;\n\t\tpriv->dai_link[2].dpcm_capture = 0;\n\t\tpriv->cpu_priv.sysclk_dir[TX] = SND_SOC_CLOCK_OUT;\n\t\tpriv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_OUT;\n\t\tpriv->card.dapm_routes = audio_map_tx;\n\t\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map_tx);\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-wm8962\")) {\n\t\tcodec_dai_name = \"wm8962\";\n\t\tpriv->codec_priv.mclk_id = WM8962_SYSCLK_MCLK;\n\t\tpriv->codec_priv.fll_id = WM8962_SYSCLK_FLL;\n\t\tpriv->codec_priv.pll_id = WM8962_FLL;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-wm8960\")) {\n\t\tcodec_dai_name = \"wm8960-hifi\";\n\t\tpriv->codec_priv.fll_id = WM8960_SYSCLK_AUTO;\n\t\tpriv->codec_priv.pll_id = WM8960_SYSCLK_AUTO;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-ac97\")) {\n\t\tcodec_dai_name = \"ac97-hifi\";\n\t\tpriv->dai_fmt = SND_SOC_DAIFMT_AC97;\n\t\tpriv->card.dapm_routes = audio_map_ac97;\n\t\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map_ac97);\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-mqs\")) {\n\t\tcodec_dai_name = \"fsl-mqs-dai\";\n\t\tpriv->dai_fmt = SND_SOC_DAIFMT_LEFT_J |\n\t\t\t\tSND_SOC_DAIFMT_CBC_CFC |\n\t\t\t\tSND_SOC_DAIFMT_NB_NF;\n\t\tpriv->dai_link[1].dpcm_capture = 0;\n\t\tpriv->dai_link[2].dpcm_capture = 0;\n\t\tpriv->card.dapm_routes = audio_map_tx;\n\t\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map_tx);\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-wm8524\")) {\n\t\tcodec_dai_name = \"wm8524-hifi\";\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBC_CFC;\n\t\tpriv->dai_link[1].dpcm_capture = 0;\n\t\tpriv->dai_link[2].dpcm_capture = 0;\n\t\tpriv->cpu_priv.slot_width = 32;\n\t\tpriv->card.dapm_routes = audio_map_tx;\n\t\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map_tx);\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-si476x\")) {\n\t\tcodec_dai_name = \"si476x-codec\";\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBC_CFC;\n\t\tpriv->card.dapm_routes = audio_map_rx;\n\t\tpriv->card.num_dapm_routes = ARRAY_SIZE(audio_map_rx);\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-wm8958\")) {\n\t\tcodec_dai_name = \"wm8994-aif1\";\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBP_CFP;\n\t\tpriv->codec_priv.mclk_id = WM8994_FLL_SRC_MCLK1;\n\t\tpriv->codec_priv.fll_id = WM8994_SYSCLK_FLL1;\n\t\tpriv->codec_priv.pll_id = WM8994_FLL1;\n\t\tpriv->codec_priv.free_freq = priv->codec_priv.mclk_freq;\n\t\tpriv->card.dapm_routes = NULL;\n\t\tpriv->card.num_dapm_routes = 0;\n\t} else if (of_device_is_compatible(np, \"fsl,imx-audio-nau8822\")) {\n\t\tcodec_dai_name = \"nau8822-hifi\";\n\t\tpriv->codec_priv.mclk_id = NAU8822_CLK_MCLK;\n\t\tpriv->codec_priv.fll_id = NAU8822_CLK_PLL;\n\t\tpriv->codec_priv.pll_id = NAU8822_CLK_PLL;\n\t\tpriv->dai_fmt |= SND_SOC_DAIFMT_CBM_CFM;\n\t\tif (codec_dev)\n\t\t\tpriv->codec_priv.mclk = devm_clk_get(codec_dev, NULL);\n\t} else {\n\t\tdev_err(&pdev->dev, \"unknown Device Tree compatible\\n\");\n\t\tret = -EINVAL;\n\t\tgoto asrc_fail;\n\t}\n\n\t \n\tof_property_read_u32(np, \"mclk-id\", &priv->codec_priv.mclk_id);\n\n\t \n\tsnd_soc_daifmt_parse_clock_provider_as_phandle(np, NULL, &bitclkprovider, &frameprovider);\n\tif (bitclkprovider || frameprovider) {\n\t\tunsigned int daifmt = snd_soc_daifmt_parse_format(np, NULL);\n\n\t\tif (codec_np == bitclkprovider)\n\t\t\tdaifmt |= (codec_np == frameprovider) ?\n\t\t\t\tSND_SOC_DAIFMT_CBP_CFP : SND_SOC_DAIFMT_CBP_CFC;\n\t\telse\n\t\t\tdaifmt |= (codec_np == frameprovider) ?\n\t\t\t\tSND_SOC_DAIFMT_CBC_CFP : SND_SOC_DAIFMT_CBC_CFC;\n\n\t\t \n\t\tpriv->dai_fmt = daifmt;\n\t}\n\n\t \n\tif (priv->dai_fmt & SND_SOC_DAIFMT_CBP_CFP) {\n\t\tpriv->cpu_priv.sysclk_dir[TX] = SND_SOC_CLOCK_IN;\n\t\tpriv->cpu_priv.sysclk_dir[RX] = SND_SOC_CLOCK_IN;\n\t}\n\n\tof_node_put(bitclkprovider);\n\tof_node_put(frameprovider);\n\n\tif (!fsl_asoc_card_is_ac97(priv) && !codec_dev) {\n\t\tdev_dbg(&pdev->dev, \"failed to find codec device\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto asrc_fail;\n\t}\n\n\t \n\tif (of_node_name_eq(cpu_np, \"ssi\")) {\n\t\t \n\t\tret = fsl_asoc_card_audmux_init(np, priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to init audmux\\n\");\n\t\t\tgoto asrc_fail;\n\t\t}\n\t} else if (of_node_name_eq(cpu_np, \"esai\")) {\n\t\tstruct clk *esai_clk = clk_get(&cpu_pdev->dev, \"extal\");\n\n\t\tif (!IS_ERR(esai_clk)) {\n\t\t\tpriv->cpu_priv.sysclk_freq[TX] = clk_get_rate(esai_clk);\n\t\t\tpriv->cpu_priv.sysclk_freq[RX] = clk_get_rate(esai_clk);\n\t\t\tclk_put(esai_clk);\n\t\t} else if (PTR_ERR(esai_clk) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto asrc_fail;\n\t\t}\n\n\t\tpriv->cpu_priv.sysclk_id[1] = ESAI_HCKT_EXTAL;\n\t\tpriv->cpu_priv.sysclk_id[0] = ESAI_HCKR_EXTAL;\n\t} else if (of_node_name_eq(cpu_np, \"sai\")) {\n\t\tpriv->cpu_priv.sysclk_id[1] = FSL_SAI_CLK_MAST1;\n\t\tpriv->cpu_priv.sysclk_id[0] = FSL_SAI_CLK_MAST1;\n\t}\n\n\t \n\tpriv->pdev = pdev;\n\tpriv->card.dev = &pdev->dev;\n\tpriv->card.owner = THIS_MODULE;\n\tret = snd_soc_of_parse_card_name(&priv->card, \"model\");\n\tif (ret) {\n\t\tsnprintf(priv->name, sizeof(priv->name), \"%s-audio\",\n\t\t\t fsl_asoc_card_is_ac97(priv) ? \"ac97\" : codec_dev_name);\n\t\tpriv->card.name = priv->name;\n\t}\n\tpriv->card.dai_link = priv->dai_link;\n\tpriv->card.late_probe = fsl_asoc_card_late_probe;\n\tpriv->card.dapm_widgets = fsl_asoc_card_dapm_widgets;\n\tpriv->card.num_dapm_widgets = ARRAY_SIZE(fsl_asoc_card_dapm_widgets);\n\n\t \n\tif (!asrc_pdev)\n\t\tpriv->card.num_dapm_routes /= 2;\n\n\tif (of_property_read_bool(np, \"audio-routing\")) {\n\t\tret = snd_soc_of_parse_audio_routing(&priv->card, \"audio-routing\");\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse audio-routing: %d\\n\", ret);\n\t\t\tgoto asrc_fail;\n\t\t}\n\t}\n\n\t \n\tpriv->dai_link[0].cpus->of_node = cpu_np;\n\tpriv->dai_link[0].codecs->dai_name = codec_dai_name;\n\n\tif (!fsl_asoc_card_is_ac97(priv))\n\t\tpriv->dai_link[0].codecs->of_node = codec_np;\n\telse {\n\t\tu32 idx;\n\n\t\tret = of_property_read_u32(cpu_np, \"cell-index\", &idx);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"cannot get CPU index property\\n\");\n\t\t\tgoto asrc_fail;\n\t\t}\n\n\t\tpriv->dai_link[0].codecs->name =\n\t\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t       \"ac97-codec.%u\",\n\t\t\t\t\t       (unsigned int)idx);\n\t\tif (!priv->dai_link[0].codecs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto asrc_fail;\n\t\t}\n\t}\n\n\tpriv->dai_link[0].platforms->of_node = cpu_np;\n\tpriv->dai_link[0].dai_fmt = priv->dai_fmt;\n\tpriv->card.num_links = 1;\n\n\tif (asrc_pdev) {\n\t\t \n\t\tpriv->dai_link[1].cpus->of_node = asrc_np;\n\t\tpriv->dai_link[1].platforms->of_node = asrc_np;\n\t\tpriv->dai_link[2].codecs->dai_name = codec_dai_name;\n\t\tpriv->dai_link[2].codecs->of_node = codec_np;\n\t\tpriv->dai_link[2].codecs->name =\n\t\t\t\tpriv->dai_link[0].codecs->name;\n\t\tpriv->dai_link[2].cpus->of_node = cpu_np;\n\t\tpriv->dai_link[2].dai_fmt = priv->dai_fmt;\n\t\tpriv->card.num_links = 3;\n\n\t\tret = of_property_read_u32(asrc_np, \"fsl,asrc-rate\",\n\t\t\t\t\t   &priv->asrc_rate);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to get output rate\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto asrc_fail;\n\t\t}\n\n\t\tret = of_property_read_u32(asrc_np, \"fsl,asrc-format\", &asrc_fmt);\n\t\tpriv->asrc_format = (__force snd_pcm_format_t)asrc_fmt;\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = of_property_read_u32(asrc_np, \"fsl,asrc-width\",\n\t\t\t\t\t\t   &width);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"failed to decide output format\\n\");\n\t\t\t\tgoto asrc_fail;\n\t\t\t}\n\n\t\t\tif (width == 24)\n\t\t\t\tpriv->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t\t\telse\n\t\t\t\tpriv->asrc_format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t}\n\t}\n\n\t \n\tplatform_set_drvdata(pdev, priv);\n\tsnd_soc_card_set_drvdata(&priv->card, priv);\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &priv->card);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"snd_soc_register_card failed\\n\");\n\t\tgoto asrc_fail;\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"hp-det-gpio\")) {\n\t\tret = asoc_simple_init_jack(&priv->card, &priv->hp_jack,\n\t\t\t\t\t    1, NULL, \"Headphone Jack\");\n\t\tif (ret)\n\t\t\tgoto asrc_fail;\n\n\t\tsnd_soc_jack_notifier_register(&priv->hp_jack.jack, &hp_jack_nb);\n\t}\n\n\tif (of_property_read_bool(np, \"mic-det-gpio\")) {\n\t\tret = asoc_simple_init_jack(&priv->card, &priv->mic_jack,\n\t\t\t\t\t    0, NULL, \"Mic Jack\");\n\t\tif (ret)\n\t\t\tgoto asrc_fail;\n\n\t\tsnd_soc_jack_notifier_register(&priv->mic_jack.jack, &mic_jack_nb);\n\t}\n\nasrc_fail:\n\tof_node_put(asrc_np);\n\tof_node_put(codec_np);\n\tput_device(&cpu_pdev->dev);\nfail:\n\tof_node_put(cpu_np);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id fsl_asoc_card_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-audio-ac97\", },\n\t{ .compatible = \"fsl,imx-audio-cs42888\", },\n\t{ .compatible = \"fsl,imx-audio-cs427x\", },\n\t{ .compatible = \"fsl,imx-audio-tlv320aic32x4\", },\n\t{ .compatible = \"fsl,imx-audio-tlv320aic31xx\", },\n\t{ .compatible = \"fsl,imx-audio-sgtl5000\", },\n\t{ .compatible = \"fsl,imx-audio-wm8962\", },\n\t{ .compatible = \"fsl,imx-audio-wm8960\", },\n\t{ .compatible = \"fsl,imx-audio-mqs\", },\n\t{ .compatible = \"fsl,imx-audio-wm8524\", },\n\t{ .compatible = \"fsl,imx-audio-si476x\", },\n\t{ .compatible = \"fsl,imx-audio-wm8958\", },\n\t{ .compatible = \"fsl,imx-audio-nau8822\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_asoc_card_dt_ids);\n\nstatic struct platform_driver fsl_asoc_card_driver = {\n\t.probe = fsl_asoc_card_probe,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = fsl_asoc_card_dt_ids,\n\t},\n};\nmodule_platform_driver(fsl_asoc_card_driver);\n\nMODULE_DESCRIPTION(\"Freescale Generic ASoC Sound Card driver with ASRC\");\nMODULE_AUTHOR(\"Nicolin Chen <nicoleotsuka@gmail.com>\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}