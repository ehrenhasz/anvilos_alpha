{
  "module_name": "p1022_ds.c",
  "hash_id": "09cb093c1a53ce6e4cc83faa7c4d7cc35cbf503b71a564c17fb642b76418d2ab",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/p1022_ds.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/fsl/guts.h>\n#include <linux/interrupt.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n\n#include \"fsl_dma.h\"\n#include \"fsl_ssi.h\"\n#include \"fsl_utils.h\"\n\n \n\n#define CCSR_GUTS_PMUXCR_UART0_I2C1_MASK\t0x0001c000\n#define CCSR_GUTS_PMUXCR_UART0_I2C1_UART0_SSI\t0x00010000\n#define CCSR_GUTS_PMUXCR_UART0_I2C1_SSI\t\t0x00018000\n\n#define CCSR_GUTS_PMUXCR_SSI_DMA_TDM_MASK\t0x00000c00\n#define CCSR_GUTS_PMUXCR_SSI_DMA_TDM_SSI\t0x00000000\n\n#define CCSR_GUTS_DMUXCR_PAD\t1\t \n#define CCSR_GUTS_DMUXCR_SSI\t2\t \n\n \nstatic inline void guts_set_dmuxcr(struct ccsr_guts __iomem *guts,\n\tunsigned int co, unsigned int ch, unsigned int device)\n{\n\tunsigned int shift = 16 + (8 * (1 - co) + 2 * (3 - ch));\n\n\tclrsetbits_be32(&guts->dmuxcr, 3 << shift, device << shift);\n}\n\n \nstatic phys_addr_t guts_phys;\n\n \nstruct machine_data {\n\tstruct snd_soc_dai_link dai[2];\n\tstruct snd_soc_card card;\n\tunsigned int dai_format;\n\tunsigned int codec_clk_direction;\n\tunsigned int cpu_clk_direction;\n\tunsigned int clk_frequency;\n\tunsigned int ssi_id;\t\t \n\tunsigned int dma_id[2];\t\t \n\tunsigned int dma_channel_id[2];  \n\tchar platform_name[2][DAI_NAME_SIZE];  \n};\n\n \nstatic int p1022_ds_machine_probe(struct snd_soc_card *card)\n{\n\tstruct machine_data *mdata =\n\t\tcontainer_of(card, struct machine_data, card);\n\tstruct ccsr_guts __iomem *guts;\n\n\tguts = ioremap(guts_phys, sizeof(struct ccsr_guts));\n\tif (!guts) {\n\t\tdev_err(card->dev, \"could not map global utilities\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tclrsetbits_be32(&guts->pmuxcr, CCSR_GUTS_PMUXCR_UART0_I2C1_MASK,\n\t\t\tCCSR_GUTS_PMUXCR_UART0_I2C1_UART0_SSI);\n\n\t \n\tclrsetbits_be32(&guts->pmuxcr, CCSR_GUTS_PMUXCR_SSI_DMA_TDM_MASK,\n\t\t\tCCSR_GUTS_PMUXCR_SSI_DMA_TDM_SSI);\n\n\t \n\tguts_set_dmuxcr(guts, mdata->dma_id[0], mdata->dma_channel_id[0],\n\t\t\tCCSR_GUTS_DMUXCR_SSI);\n\n\tguts_set_dmuxcr(guts, mdata->dma_id[1], mdata->dma_channel_id[1],\n\t\t\tCCSR_GUTS_DMUXCR_SSI);\n\n\tiounmap(guts);\n\n\treturn 0;\n}\n\n \nstatic int p1022_ds_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct machine_data *mdata =\n\t\tcontainer_of(rtd->card, struct machine_data, card);\n\tstruct device *dev = rtd->card->dev;\n\tint ret = 0;\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_codec(rtd, 0), mdata->dai_format);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not set codec driver audio format\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0), 0, mdata->clk_frequency,\n\t\t\t\t     mdata->codec_clk_direction);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not set codec driver clock params\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int p1022_ds_machine_remove(struct snd_soc_card *card)\n{\n\tstruct machine_data *mdata =\n\t\tcontainer_of(card, struct machine_data, card);\n\tstruct ccsr_guts __iomem *guts;\n\n\tguts = ioremap(guts_phys, sizeof(struct ccsr_guts));\n\tif (!guts) {\n\t\tdev_err(card->dev, \"could not map global utilities\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tclrbits32(&guts->pmuxcr, CCSR_GUTS_PMUXCR_UART0_I2C1_MASK);\n\tclrbits32(&guts->pmuxcr, CCSR_GUTS_PMUXCR_SSI_DMA_TDM_MASK);\n\tguts_set_dmuxcr(guts, mdata->dma_id[0], mdata->dma_channel_id[0], 0);\n\tguts_set_dmuxcr(guts, mdata->dma_id[1], mdata->dma_channel_id[1], 0);\n\n\tiounmap(guts);\n\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_ops p1022_ds_ops = {\n\t.startup = p1022_ds_startup,\n};\n\n \nstatic int p1022_ds_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = pdev->dev.parent;\n\t \n\tstruct platform_device *ssi_pdev = to_platform_device(dev);\n\tstruct device_node *np = ssi_pdev->dev.of_node;\n\tstruct device_node *codec_np = NULL;\n\tstruct machine_data *mdata;\n\tstruct snd_soc_dai_link_component *comp;\n\tint ret;\n\tconst char *sprop;\n\tconst u32 *iprop;\n\n\t \n\tcodec_np = of_parse_phandle(np, \"codec-handle\", 0);\n\tif (!codec_np) {\n\t\tdev_err(dev, \"could not find codec node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmdata = kzalloc(sizeof(struct machine_data), GFP_KERNEL);\n\tif (!mdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put;\n\t}\n\n\tcomp = devm_kzalloc(&pdev->dev, 6 * sizeof(*comp), GFP_KERNEL);\n\tif (!comp) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put;\n\t}\n\n\tmdata->dai[0].cpus\t= &comp[0];\n\tmdata->dai[0].codecs\t= &comp[1];\n\tmdata->dai[0].platforms\t= &comp[2];\n\n\tmdata->dai[0].num_cpus\t\t= 1;\n\tmdata->dai[0].num_codecs\t= 1;\n\tmdata->dai[0].num_platforms\t= 1;\n\n\tmdata->dai[1].cpus\t= &comp[3];\n\tmdata->dai[1].codecs\t= &comp[4];\n\tmdata->dai[1].platforms\t= &comp[5];\n\n\tmdata->dai[1].num_cpus\t\t= 1;\n\tmdata->dai[1].num_codecs\t= 1;\n\tmdata->dai[1].num_platforms\t= 1;\n\n\n\tmdata->dai[0].cpus->dai_name = dev_name(&ssi_pdev->dev);\n\tmdata->dai[0].ops = &p1022_ds_ops;\n\n\t \n\tmdata->dai[0].codecs->of_node = codec_np;\n\n\t \n\tmemcpy(&mdata->dai[1], &mdata->dai[0], sizeof(struct snd_soc_dai_link));\n\n\t \n\tmdata->dai[0].codecs->dai_name = \"wm8776-hifi-playback\";\n\tmdata->dai[1].codecs->dai_name = \"wm8776-hifi-capture\";\n\n\t \n\tiprop = of_get_property(np, \"cell-index\", NULL);\n\tif (!iprop) {\n\t\tdev_err(&pdev->dev, \"cell-index property not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tmdata->ssi_id = be32_to_cpup(iprop);\n\n\t \n\tsprop = of_get_property(np, \"fsl,mode\", NULL);\n\tif (!sprop) {\n\t\tdev_err(&pdev->dev, \"fsl,mode property not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (strcasecmp(sprop, \"i2s-slave\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\n\t\t \n\t\tiprop = of_get_property(codec_np, \"clock-frequency\", NULL);\n\t\tif (!iprop || !*iprop) {\n\t\t\tdev_err(&pdev->dev, \"codec bus-frequency \"\n\t\t\t\t\"property is missing or invalid\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tmdata->clk_frequency = be32_to_cpup(iprop);\n\t} else if (strcasecmp(sprop, \"i2s-master\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"lj-slave\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"lj-master\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"rj-slave\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"rj-master\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"ac97-slave\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_AC97 | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"ac97-master\") == 0) {\n\t\tmdata->dai_format = SND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_AC97 | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmdata->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmdata->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unrecognized fsl,mode property '%s'\\n\", sprop);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!mdata->clk_frequency) {\n\t\tdev_err(&pdev->dev, \"unknown clock frequency\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tmdata->dai[0].platforms->name = mdata->platform_name[0];\n\tret = fsl_asoc_get_dma_channel(np, \"fsl,playback-dma\", &mdata->dai[0],\n\t\t\t\t       &mdata->dma_channel_id[0],\n\t\t\t\t       &mdata->dma_id[0]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing/invalid playback DMA phandle\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmdata->dai[1].platforms->name = mdata->platform_name[1];\n\tret = fsl_asoc_get_dma_channel(np, \"fsl,capture-dma\", &mdata->dai[1],\n\t\t\t\t       &mdata->dma_channel_id[1],\n\t\t\t\t       &mdata->dma_id[1]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing/invalid capture DMA phandle\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmdata->dai[0].stream_name = \"playback\";\n\tmdata->dai[1].stream_name = \"capture\";\n\tmdata->dai[0].name = mdata->dai[0].stream_name;\n\tmdata->dai[1].name = mdata->dai[1].stream_name;\n\n\tmdata->card.probe = p1022_ds_machine_probe;\n\tmdata->card.remove = p1022_ds_machine_remove;\n\tmdata->card.name = pdev->name;  \n\tmdata->card.owner = THIS_MODULE;\n\tmdata->card.dev = &pdev->dev;\n\tmdata->card.num_links = 2;\n\tmdata->card.dai_link = mdata->dai;\n\n\t \n\tret = snd_soc_register_card(&mdata->card);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register card\\n\");\n\t\tgoto error;\n\t}\n\n\tof_node_put(codec_np);\n\n\treturn 0;\n\nerror:\n\tkfree(mdata);\nerror_put:\n\tof_node_put(codec_np);\n\treturn ret;\n}\n\n \nstatic void p1022_ds_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct machine_data *mdata =\n\t\tcontainer_of(card, struct machine_data, card);\n\n\tsnd_soc_unregister_card(card);\n\tkfree(mdata);\n}\n\nstatic struct platform_driver p1022_ds_driver = {\n\t.probe = p1022_ds_probe,\n\t.remove_new = p1022_ds_remove,\n\t.driver = {\n\t\t \n\t\t.name = \"snd-soc-p1022ds\",\n\t},\n};\n\n \nstatic int __init p1022_ds_init(void)\n{\n\tstruct device_node *guts_np;\n\tstruct resource res;\n\n\t \n\tguts_np = of_find_compatible_node(NULL, NULL, \"fsl,p1022-guts\");\n\tif (of_address_to_resource(guts_np, 0, &res)) {\n\t\tpr_err(\"snd-soc-p1022ds: missing/invalid global utils node\\n\");\n\t\tof_node_put(guts_np);\n\t\treturn -EINVAL;\n\t}\n\tguts_phys = res.start;\n\tof_node_put(guts_np);\n\n\treturn platform_driver_register(&p1022_ds_driver);\n}\n\n \nstatic void __exit p1022_ds_exit(void)\n{\n\tplatform_driver_unregister(&p1022_ds_driver);\n}\n\nmodule_init(p1022_ds_init);\nmodule_exit(p1022_ds_exit);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale P1022 DS ALSA SoC machine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}