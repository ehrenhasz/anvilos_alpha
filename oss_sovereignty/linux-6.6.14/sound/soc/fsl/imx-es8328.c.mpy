{
  "module_name": "imx-es8328.c",
  "hash_id": "22d554479fe9d73bdbf2b59f15e58c4ef0dbdd3af7fd2e4770ec480a6d7df4c6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-es8328.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/i2c.h>\n#include <linux/of_gpio.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n\n#include \"imx-audmux.h\"\n\n#define DAI_NAME_SIZE\t32\n#define MUX_PORT_MAX\t7\n\nstruct imx_es8328_data {\n\tstruct device *dev;\n\tstruct snd_soc_dai_link dai;\n\tstruct snd_soc_card card;\n\tchar codec_dai_name[DAI_NAME_SIZE];\n\tchar platform_name[DAI_NAME_SIZE];\n\tint jack_gpio;\n};\n\nstatic struct snd_soc_jack_gpio headset_jack_gpios[] = {\n\t{\n\t\t.gpio = -1,\n\t\t.name = \"headset-gpio\",\n\t\t.report = SND_JACK_HEADSET,\n\t\t.invert = 0,\n\t\t.debounce_time = 200,\n\t},\n};\n\nstatic struct snd_soc_jack headset_jack;\nstatic struct snd_soc_jack_pin headset_jack_pins[] = {\n\t{\n\t\t.pin = \"Headphone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t{\n\t\t.pin = \"Mic Jack\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n};\n\nstatic int imx_es8328_dai_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct imx_es8328_data *data = container_of(rtd->card,\n\t\t\t\t\tstruct imx_es8328_data, card);\n\tint ret = 0;\n\n\t \n\tif (gpio_is_valid(data->jack_gpio)) {\n\t\tret = snd_soc_card_jack_new_pins(rtd->card, \"Headphone\",\n\t\t\t\t\t\t SND_JACK_HEADSET | SND_JACK_BTN_0,\n\t\t\t\t\t\t &headset_jack,\n\t\t\t\t\t\t headset_jack_pins,\n\t\t\t\t\t\t ARRAY_SIZE(headset_jack_pins));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\theadset_jack_gpios[0].gpio = data->jack_gpio;\n\t\tret = snd_soc_jack_add_gpios(&headset_jack,\n\t\t\t\t\t     ARRAY_SIZE(headset_jack_gpios),\n\t\t\t\t\t     headset_jack_gpios);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget imx_es8328_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", NULL),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"audio-amp\", 1, 0),\n};\n\nstatic const struct snd_kcontrol_new imx_es8328_controls[] = {\n\tSOC_DAPM_PIN_SWITCH(\"Headphone\"),\n\tSOC_DAPM_PIN_SWITCH(\"Mic Jack\"),\n};\n\nstatic int imx_es8328_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ssi_np = NULL, *codec_np = NULL;\n\tstruct platform_device *ssi_pdev;\n\tstruct imx_es8328_data *data;\n\tstruct snd_soc_dai_link_component *comp;\n\tu32 int_port, ext_port;\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\n\tret = of_property_read_u32(np, \"mux-int-port\", &int_port);\n\tif (ret) {\n\t\tdev_err(dev, \"mux-int-port missing or invalid\\n\");\n\t\tgoto fail;\n\t}\n\tif (int_port > MUX_PORT_MAX || int_port == 0) {\n\t\tdev_err(dev, \"mux-int-port: hardware only has %d mux ports\\n\",\n\t\t\tMUX_PORT_MAX);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tret = of_property_read_u32(np, \"mux-ext-port\", &ext_port);\n\tif (ret) {\n\t\tdev_err(dev, \"mux-ext-port missing or invalid\\n\");\n\t\tgoto fail;\n\t}\n\tif (ext_port > MUX_PORT_MAX || ext_port == 0) {\n\t\tdev_err(dev, \"mux-ext-port: hardware only has %d mux ports\\n\",\n\t\t\tMUX_PORT_MAX);\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tint_port--;\n\text_port--;\n\tret = imx_audmux_v2_configure_port(int_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSDIR |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCLKDIR,\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));\n\tif (ret) {\n\t\tdev_err(dev, \"audmux internal port setup failed\\n\");\n\t\treturn ret;\n\t}\n\tret = imx_audmux_v2_configure_port(ext_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN,\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(int_port));\n\tif (ret) {\n\t\tdev_err(dev, \"audmux external port setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tssi_np = of_parse_phandle(pdev->dev.of_node, \"ssi-controller\", 0);\n\tcodec_np = of_parse_phandle(pdev->dev.of_node, \"audio-codec\", 0);\n\tif (!ssi_np || !codec_np) {\n\t\tdev_err(dev, \"phandle missing or invalid\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tssi_pdev = of_find_device_by_node(ssi_np);\n\tif (!ssi_pdev) {\n\t\tdev_err(dev, \"failed to find SSI platform device\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tcomp = devm_kzalloc(dev, 2 * sizeof(*comp), GFP_KERNEL);\n\tif (!comp) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tdata->dev = dev;\n\n\tdata->jack_gpio = of_get_named_gpio(pdev->dev.of_node, \"jack-gpio\", 0);\n\n\t \n\tdata->dai.cpus\t\t=\n\tdata->dai.platforms\t= &comp[0];\n\tdata->dai.codecs\t= &comp[1];\n\n\tdata->dai.num_cpus\t= 1;\n\tdata->dai.num_codecs\t= 1;\n\tdata->dai.num_platforms\t= 1;\n\n\tdata->dai.name = \"hifi\";\n\tdata->dai.stream_name = \"hifi\";\n\tdata->dai.codecs->dai_name = \"es8328-hifi-analog\";\n\tdata->dai.codecs->of_node = codec_np;\n\tdata->dai.cpus->of_node = ssi_np;\n\tdata->dai.init = &imx_es8328_dai_init;\n\tdata->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t    SND_SOC_DAIFMT_CBP_CFP;\n\n\tdata->card.dev = dev;\n\tdata->card.dapm_widgets = imx_es8328_dapm_widgets;\n\tdata->card.num_dapm_widgets = ARRAY_SIZE(imx_es8328_dapm_widgets);\n\tdata->card.controls = imx_es8328_controls;\n\tdata->card.num_controls = ARRAY_SIZE(imx_es8328_controls);\n\tret = snd_soc_of_parse_card_name(&data->card, \"model\");\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to parse card name\\n\");\n\t\tgoto put_device;\n\t}\n\tret = snd_soc_of_parse_audio_routing(&data->card, \"audio-routing\");\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to parse routing: %d\\n\", ret);\n\t\tgoto put_device;\n\t}\n\tdata->card.num_links = 1;\n\tdata->card.owner = THIS_MODULE;\n\tdata->card.dai_link = &data->dai;\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &data->card);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to register: %d\\n\", ret);\n\t\tgoto put_device;\n\t}\n\n\tplatform_set_drvdata(pdev, data);\nput_device:\n\tput_device(&ssi_pdev->dev);\nfail:\n\tof_node_put(ssi_np);\n\tof_node_put(codec_np);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id imx_es8328_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-audio-es8328\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_es8328_dt_ids);\n\nstatic struct platform_driver imx_es8328_driver = {\n\t.driver = {\n\t\t.name = \"imx-es8328\",\n\t\t.of_match_table = imx_es8328_dt_ids,\n\t},\n\t.probe = imx_es8328_probe,\n};\nmodule_platform_driver(imx_es8328_driver);\n\nMODULE_AUTHOR(\"Sean Cross <xobs@kosagi.com>\");\nMODULE_DESCRIPTION(\"Kosagi i.MX6 ES8328 ASoC machine driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-audio-es8328\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}