{
  "module_name": "imx-audmux.c",
  "hash_id": "daed45be8c4682e96e8f118f10d9beb515c429834aefc5fdac6d487a4362bd08",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-audmux.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"imx-audmux.h\"\n\n#define DRIVER_NAME \"imx-audmux\"\n\nstatic struct clk *audmux_clk;\nstatic void __iomem *audmux_base;\nstatic u32 *regcache;\nstatic u32 reg_max;\n\n#define IMX_AUDMUX_V2_PTCR(x)\t\t((x) * 8)\n#define IMX_AUDMUX_V2_PDCR(x)\t\t((x) * 8 + 4)\n\n#ifdef CONFIG_DEBUG_FS\nstatic struct dentry *audmux_debugfs_root;\n\n \nstatic const char *audmux_port_string(int port)\n{\n\tswitch (port) {\n\tcase MX31_AUDMUX_PORT1_SSI0:\n\t\treturn \"imx-ssi.0\";\n\tcase MX31_AUDMUX_PORT2_SSI1:\n\t\treturn \"imx-ssi.1\";\n\tcase MX31_AUDMUX_PORT3_SSI_PINS_3:\n\t\treturn \"SSI3\";\n\tcase MX31_AUDMUX_PORT4_SSI_PINS_4:\n\t\treturn \"SSI4\";\n\tcase MX31_AUDMUX_PORT5_SSI_PINS_5:\n\t\treturn \"SSI5\";\n\tcase MX31_AUDMUX_PORT6_SSI_PINS_6:\n\t\treturn \"SSI6\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic ssize_t audmux_read_file(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *buf;\n\tuintptr_t port = (uintptr_t)file->private_data;\n\tu32 pdcr, ptcr;\n\n\tret = clk_prepare_enable(audmux_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tptcr = readl(audmux_base + IMX_AUDMUX_V2_PTCR(port));\n\tpdcr = readl(audmux_base + IMX_AUDMUX_V2_PDCR(port));\n\n\tclk_disable_unprepare(audmux_clk);\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_emit(buf, \"PDCR: %08x\\nPTCR: %08x\\n\", pdcr, ptcr);\n\n\tif (ptcr & IMX_AUDMUX_V2_PTCR_TFSDIR)\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\"TxFS output from %s, \",\n\t\t\t\taudmux_port_string((ptcr >> 27) & 0x7));\n\telse\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\"TxFS input, \");\n\n\tif (ptcr & IMX_AUDMUX_V2_PTCR_TCLKDIR)\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\"TxClk output from %s\",\n\t\t\t\taudmux_port_string((ptcr >> 22) & 0x7));\n\telse\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\"TxClk input\");\n\n\tret += scnprintf(buf + ret, PAGE_SIZE - ret, \"\\n\");\n\n\tif (ptcr & IMX_AUDMUX_V2_PTCR_SYN) {\n\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\"Port is symmetric\");\n\t} else {\n\t\tif (ptcr & IMX_AUDMUX_V2_PTCR_RFSDIR)\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t\"RxFS output from %s, \",\n\t\t\t\t\taudmux_port_string((ptcr >> 17) & 0x7));\n\t\telse\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t\"RxFS input, \");\n\n\t\tif (ptcr & IMX_AUDMUX_V2_PTCR_RCLKDIR)\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t\"RxClk output from %s\",\n\t\t\t\t\taudmux_port_string((ptcr >> 12) & 0x7));\n\t\telse\n\t\t\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\t\t\"RxClk input\");\n\t}\n\n\tret += scnprintf(buf + ret, PAGE_SIZE - ret,\n\t\t\t\"\\nData received from %s\\n\",\n\t\t\taudmux_port_string((pdcr >> 13) & 0x7));\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations audmux_debugfs_fops = {\n\t.open = simple_open,\n\t.read = audmux_read_file,\n\t.llseek = default_llseek,\n};\n\nstatic void audmux_debugfs_init(void)\n{\n\tuintptr_t i;\n\tchar buf[20];\n\n\taudmux_debugfs_root = debugfs_create_dir(\"audmux\", NULL);\n\n\tfor (i = 0; i < MX31_AUDMUX_PORT7_SSI_PINS_7 + 1; i++) {\n\t\tsnprintf(buf, sizeof(buf), \"ssi%lu\", i);\n\t\tdebugfs_create_file(buf, 0444, audmux_debugfs_root,\n\t\t\t\t    (void *)i, &audmux_debugfs_fops);\n\t}\n}\n\nstatic void audmux_debugfs_remove(void)\n{\n\tdebugfs_remove_recursive(audmux_debugfs_root);\n}\n#else\nstatic inline void audmux_debugfs_init(void)\n{\n}\n\nstatic inline void audmux_debugfs_remove(void)\n{\n}\n#endif\n\nstatic enum imx_audmux_type {\n\tIMX21_AUDMUX,\n\tIMX31_AUDMUX,\n} audmux_type;\n\nstatic const struct of_device_id imx_audmux_dt_ids[] = {\n\t{ .compatible = \"fsl,imx21-audmux\", .data = (void *)IMX21_AUDMUX, },\n\t{ .compatible = \"fsl,imx31-audmux\", .data = (void *)IMX31_AUDMUX, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_audmux_dt_ids);\n\nstatic const uint8_t port_mapping[] = {\n\t0x0, 0x4, 0x8, 0x10, 0x14, 0x1c,\n};\n\nint imx_audmux_v1_configure_port(unsigned int port, unsigned int pcr)\n{\n\tif (audmux_type != IMX21_AUDMUX)\n\t\treturn -EINVAL;\n\n\tif (!audmux_base)\n\t\treturn -ENOSYS;\n\n\tif (port >= ARRAY_SIZE(port_mapping))\n\t\treturn -EINVAL;\n\n\twritel(pcr, audmux_base + port_mapping[port]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_audmux_v1_configure_port);\n\nint imx_audmux_v2_configure_port(unsigned int port, unsigned int ptcr,\n\t\tunsigned int pdcr)\n{\n\tint ret;\n\n\tif (audmux_type != IMX31_AUDMUX)\n\t\treturn -EINVAL;\n\n\tif (!audmux_base)\n\t\treturn -ENOSYS;\n\n\tret = clk_prepare_enable(audmux_clk);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(ptcr, audmux_base + IMX_AUDMUX_V2_PTCR(port));\n\twritel(pdcr, audmux_base + IMX_AUDMUX_V2_PDCR(port));\n\n\tclk_disable_unprepare(audmux_clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_audmux_v2_configure_port);\n\nstatic int imx_audmux_parse_dt_defaults(struct platform_device *pdev,\n\t\tstruct device_node *of_node)\n{\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(of_node, child) {\n\t\tunsigned int port;\n\t\tunsigned int ptcr = 0;\n\t\tunsigned int pdcr = 0;\n\t\tunsigned int pcr = 0;\n\t\tunsigned int val;\n\t\tint ret;\n\t\tint i = 0;\n\n\t\tret = of_property_read_u32(child, \"fsl,audmux-port\", &port);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"Failed to get fsl,audmux-port of child node \\\"%pOF\\\"\\n\",\n\t\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!of_property_read_bool(child, \"fsl,port-config\")) {\n\t\t\tdev_warn(&pdev->dev, \"child node \\\"%pOF\\\" does not have property fsl,port-config\\n\",\n\t\t\t\t\tchild);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 0; (ret = of_property_read_u32_index(child,\n\t\t\t\t\t\"fsl,port-config\", i, &val)) == 0;\n\t\t\t\t++i) {\n\t\t\tif (audmux_type == IMX31_AUDMUX) {\n\t\t\t\tif (i % 2)\n\t\t\t\t\tpdcr |= val;\n\t\t\t\telse\n\t\t\t\t\tptcr |= val;\n\t\t\t} else {\n\t\t\t\tpcr |= val;\n\t\t\t}\n\t\t}\n\n\t\tif (ret != -EOVERFLOW) {\n\t\t\tdev_err(&pdev->dev, \"Failed to read u32 at index %d of child %pOF\\n\",\n\t\t\t\t\ti, child);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (audmux_type == IMX31_AUDMUX) {\n\t\t\tif (i % 2) {\n\t\t\t\tdev_err(&pdev->dev, \"One pdcr value is missing in child node %pOF\\n\",\n\t\t\t\t\t\tchild);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\timx_audmux_v2_configure_port(port, ptcr, pdcr);\n\t\t} else {\n\t\t\timx_audmux_v1_configure_port(port, pcr);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_audmux_probe(struct platform_device *pdev)\n{\n\taudmux_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(audmux_base))\n\t\treturn PTR_ERR(audmux_base);\n\n\taudmux_clk = devm_clk_get(&pdev->dev, \"audmux\");\n\tif (IS_ERR(audmux_clk)) {\n\t\tdev_dbg(&pdev->dev, \"cannot get clock: %ld\\n\",\n\t\t\t\tPTR_ERR(audmux_clk));\n\t\taudmux_clk = NULL;\n\t}\n\n\taudmux_type = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\tswitch (audmux_type) {\n\tcase IMX31_AUDMUX:\n\t\taudmux_debugfs_init();\n\t\treg_max = 14;\n\t\tbreak;\n\tcase IMX21_AUDMUX:\n\t\treg_max = 6;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unsupported version!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregcache = devm_kzalloc(&pdev->dev, sizeof(u32) * reg_max, GFP_KERNEL);\n\tif (!regcache)\n\t\treturn -ENOMEM;\n\n\timx_audmux_parse_dt_defaults(pdev, pdev->dev.of_node);\n\n\treturn 0;\n}\n\nstatic void imx_audmux_remove(struct platform_device *pdev)\n{\n\tif (audmux_type == IMX31_AUDMUX)\n\t\taudmux_debugfs_remove();\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx_audmux_suspend(struct device *dev)\n{\n\tint i;\n\n\tclk_prepare_enable(audmux_clk);\n\n\tfor (i = 0; i < reg_max; i++)\n\t\tregcache[i] = readl(audmux_base + i * 4);\n\n\tclk_disable_unprepare(audmux_clk);\n\n\treturn 0;\n}\n\nstatic int imx_audmux_resume(struct device *dev)\n{\n\tint i;\n\n\tclk_prepare_enable(audmux_clk);\n\n\tfor (i = 0; i < reg_max; i++)\n\t\twritel(regcache[i], audmux_base + i * 4);\n\n\tclk_disable_unprepare(audmux_clk);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops imx_audmux_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(imx_audmux_suspend, imx_audmux_resume)\n};\n\nstatic struct platform_driver imx_audmux_driver = {\n\t.probe\t\t= imx_audmux_probe,\n\t.remove_new\t= imx_audmux_remove,\n\t.driver\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm = &imx_audmux_pm,\n\t\t.of_match_table = imx_audmux_dt_ids,\n\t}\n};\n\nstatic int __init imx_audmux_init(void)\n{\n\treturn platform_driver_register(&imx_audmux_driver);\n}\nsubsys_initcall(imx_audmux_init);\n\nstatic void __exit imx_audmux_exit(void)\n{\n\tplatform_driver_unregister(&imx_audmux_driver);\n}\nmodule_exit(imx_audmux_exit);\n\nMODULE_DESCRIPTION(\"Freescale i.MX AUDMUX driver\");\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}