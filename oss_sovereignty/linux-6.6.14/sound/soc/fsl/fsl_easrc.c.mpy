{
  "module_name": "fsl_easrc.c",
  "hash_id": "03cba33d9f65c9cedf32f6ba91b3af520250c7be01feeda699ea4c2b02939c93",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_easrc.c",
  "human_readable_source": "\n\n\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/miscdevice.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/sched/signal.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/gcd.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/core.h>\n\n#include \"fsl_easrc.h\"\n#include \"imx-pcm.h\"\n\n#define FSL_EASRC_FORMATS       (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_U24_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_U24_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_U32_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_U20_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_FLOAT_LE)\n\nstatic int fsl_easrc_iec958_put_bits(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_asrc *easrc = snd_soc_component_get_drvdata(comp);\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tunsigned int regval = ucontrol->value.integer.value[0];\n\n\teasrc_priv->bps_iec958[mc->regbase] = regval;\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_iec958_get_bits(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_asrc *easrc = snd_soc_component_get_drvdata(comp);\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\n\tucontrol->value.enumerated.item[0] = easrc_priv->bps_iec958[mc->regbase];\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_get_reg(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tunsigned int regval;\n\n\tregval = snd_soc_component_read(component, mc->regbase);\n\n\tucontrol->value.integer.value[0] = regval;\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_set_reg(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mreg_control *mc =\n\t\t(struct soc_mreg_control *)kcontrol->private_value;\n\tunsigned int regval = ucontrol->value.integer.value[0];\n\tint ret;\n\n\tret = snd_soc_component_write(component, mc->regbase, regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define SOC_SINGLE_REG_RW(xname, xreg) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.info = snd_soc_info_xr_sx, .get = fsl_easrc_get_reg, \\\n\t.put = fsl_easrc_set_reg, \\\n\t.private_value = (unsigned long)&(struct soc_mreg_control) \\\n\t\t{ .regbase = xreg, .regcount = 1, .nbits = 32, \\\n\t\t  .invert = 0, .min = 0, .max = 0xffffffff, } }\n\n#define SOC_SINGLE_VAL_RW(xname, xreg) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_PCM, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.info = snd_soc_info_xr_sx, .get = fsl_easrc_iec958_get_bits, \\\n\t.put = fsl_easrc_iec958_put_bits, \\\n\t.private_value = (unsigned long)&(struct soc_mreg_control) \\\n\t\t{ .regbase = xreg, .regcount = 1, .nbits = 32, \\\n\t\t  .invert = 0, .min = 0, .max = 2, } }\n\nstatic const struct snd_kcontrol_new fsl_easrc_snd_controls[] = {\n\tSOC_SINGLE(\"Context 0 Dither Switch\", REG_EASRC_COC(0), 0, 1, 0),\n\tSOC_SINGLE(\"Context 1 Dither Switch\", REG_EASRC_COC(1), 0, 1, 0),\n\tSOC_SINGLE(\"Context 2 Dither Switch\", REG_EASRC_COC(2), 0, 1, 0),\n\tSOC_SINGLE(\"Context 3 Dither Switch\", REG_EASRC_COC(3), 0, 1, 0),\n\n\tSOC_SINGLE(\"Context 0 IEC958 Validity\", REG_EASRC_COC(0), 2, 1, 0),\n\tSOC_SINGLE(\"Context 1 IEC958 Validity\", REG_EASRC_COC(1), 2, 1, 0),\n\tSOC_SINGLE(\"Context 2 IEC958 Validity\", REG_EASRC_COC(2), 2, 1, 0),\n\tSOC_SINGLE(\"Context 3 IEC958 Validity\", REG_EASRC_COC(3), 2, 1, 0),\n\n\tSOC_SINGLE_VAL_RW(\"Context 0 IEC958 Bits Per Sample\", 0),\n\tSOC_SINGLE_VAL_RW(\"Context 1 IEC958 Bits Per Sample\", 1),\n\tSOC_SINGLE_VAL_RW(\"Context 2 IEC958 Bits Per Sample\", 2),\n\tSOC_SINGLE_VAL_RW(\"Context 3 IEC958 Bits Per Sample\", 3),\n\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS0\", REG_EASRC_CS0(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS0\", REG_EASRC_CS0(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS0\", REG_EASRC_CS0(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS0\", REG_EASRC_CS0(3)),\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS1\", REG_EASRC_CS1(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS1\", REG_EASRC_CS1(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS1\", REG_EASRC_CS1(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS1\", REG_EASRC_CS1(3)),\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS2\", REG_EASRC_CS2(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS2\", REG_EASRC_CS2(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS2\", REG_EASRC_CS2(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS2\", REG_EASRC_CS2(3)),\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS3\", REG_EASRC_CS3(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS3\", REG_EASRC_CS3(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS3\", REG_EASRC_CS3(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS3\", REG_EASRC_CS3(3)),\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS4\", REG_EASRC_CS4(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS4\", REG_EASRC_CS4(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS4\", REG_EASRC_CS4(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS4\", REG_EASRC_CS4(3)),\n\tSOC_SINGLE_REG_RW(\"Context 0 IEC958 CS5\", REG_EASRC_CS5(0)),\n\tSOC_SINGLE_REG_RW(\"Context 1 IEC958 CS5\", REG_EASRC_CS5(1)),\n\tSOC_SINGLE_REG_RW(\"Context 2 IEC958 CS5\", REG_EASRC_CS5(2)),\n\tSOC_SINGLE_REG_RW(\"Context 3 IEC958 CS5\", REG_EASRC_CS5(3)),\n};\n\n \nstatic int fsl_easrc_set_rs_ratio(struct fsl_asrc_pair *ctx)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct fsl_easrc_ctx_priv *ctx_priv = ctx->private;\n\tunsigned int in_rate = ctx_priv->in_params.norm_rate;\n\tunsigned int out_rate = ctx_priv->out_params.norm_rate;\n\tunsigned int frac_bits;\n\tu64 val;\n\tu32 *r;\n\n\tswitch (easrc_priv->rs_num_taps) {\n\tcase EASRC_RS_32_TAPS:\n\t\t \n\t\tfrac_bits = 39;\n\t\tbreak;\n\tcase EASRC_RS_64_TAPS:\n\t\t \n\t\tfrac_bits = 38;\n\t\tbreak;\n\tcase EASRC_RS_128_TAPS:\n\t\t \n\t\tfrac_bits = 37;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = (u64)in_rate << frac_bits;\n\tdo_div(val, out_rate);\n\tr = (uint32_t *)&val;\n\n\tif (r[1] & 0xFFFFF000) {\n\t\tdev_err(&easrc->pdev->dev, \"ratio exceed range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(easrc->regmap, REG_EASRC_RRL(ctx->index),\n\t\t     EASRC_RRL_RS_RL(r[0]));\n\tregmap_write(easrc->regmap, REG_EASRC_RRH(ctx->index),\n\t\t     EASRC_RRH_RS_RH(r[1]));\n\n\treturn 0;\n}\n\n \nstatic void fsl_easrc_normalize_rates(struct fsl_asrc_pair *ctx)\n{\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\tint a, b;\n\n\tif (!ctx)\n\t\treturn;\n\n\tctx_priv = ctx->private;\n\n\ta = ctx_priv->in_params.sample_rate;\n\tb = ctx_priv->out_params.sample_rate;\n\n\ta = gcd(a, b);\n\n\t \n\tctx_priv->in_params.norm_rate = ctx_priv->in_params.sample_rate / a;\n\tctx_priv->out_params.norm_rate = ctx_priv->out_params.sample_rate / a;\n}\n\n \nstatic int fsl_easrc_coeff_mem_ptr_reset(struct fsl_asrc *easrc,\n\t\t\t\t\t unsigned int ctx_id, int mem_type)\n{\n\tstruct device *dev;\n\tu32 reg, mask, val;\n\n\tif (!easrc)\n\t\treturn -ENODEV;\n\n\tdev = &easrc->pdev->dev;\n\n\tswitch (mem_type) {\n\tcase EASRC_PF_COEFF_MEM:\n\t\t \n\t\tif (ctx_id >= EASRC_CTX_MAX_NUM) {\n\t\t\tdev_err(dev, \"Invalid context id[%d]\\n\", ctx_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treg = REG_EASRC_CCE1(ctx_id);\n\t\tmask = EASRC_CCE1_COEF_MEM_RST_MASK;\n\t\tval = EASRC_CCE1_COEF_MEM_RST;\n\t\tbreak;\n\tcase EASRC_RS_COEFF_MEM:\n\t\t \n\t\treg = REG_EASRC_CRCC;\n\t\tmask = EASRC_CRCC_RS_CPR_MASK;\n\t\tval = EASRC_CRCC_RS_CPR;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown memory type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_update_bits(easrc->regmap, reg, mask, 0);\n\tregmap_update_bits(easrc->regmap, reg, mask, val);\n\tregmap_update_bits(easrc->regmap, reg, mask, 0);\n\n\treturn 0;\n}\n\nstatic inline uint32_t bits_taps_to_val(unsigned int t)\n{\n\tswitch (t) {\n\tcase EASRC_RS_32_TAPS:\n\t\treturn 32;\n\tcase EASRC_RS_64_TAPS:\n\t\treturn 64;\n\tcase EASRC_RS_128_TAPS:\n\t\treturn 128;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_resampler_config(struct fsl_asrc *easrc)\n{\n\tstruct device *dev = &easrc->pdev->dev;\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct asrc_firmware_hdr *hdr =  easrc_priv->firmware_hdr;\n\tstruct interp_params *interp = easrc_priv->interp;\n\tstruct interp_params *selected_interp = NULL;\n\tunsigned int num_coeff;\n\tunsigned int i;\n\tu64 *coef;\n\tu32 *r;\n\tint ret;\n\n\tif (!hdr) {\n\t\tdev_err(dev, \"firmware not loaded!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < hdr->interp_scen; i++) {\n\t\tif ((interp[i].num_taps - 1) !=\n\t\t    bits_taps_to_val(easrc_priv->rs_num_taps))\n\t\t\tcontinue;\n\n\t\tcoef = interp[i].coeff;\n\t\tselected_interp = &interp[i];\n\t\tdev_dbg(dev, \"Selected interp_filter: %u taps - %u phases\\n\",\n\t\t\tselected_interp->num_taps,\n\t\t\tselected_interp->num_phases);\n\t\tbreak;\n\t}\n\n\tif (!selected_interp) {\n\t\tdev_err(dev, \"failed to get interpreter configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tr = (uint32_t *)&selected_interp->center_tap;\n\tregmap_write(easrc->regmap, REG_EASRC_RCTCL, EASRC_RCTCL_RS_CL(r[0]));\n\tregmap_write(easrc->regmap, REG_EASRC_RCTCH, EASRC_RCTCH_RS_CH(r[1]));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CRCC,\n\t\t\t   EASRC_CRCC_RS_TAPS_MASK,\n\t\t\t   EASRC_CRCC_RS_TAPS(easrc_priv->rs_num_taps));\n\n\t \n\tret = fsl_easrc_coeff_mem_ptr_reset(easrc, 0, EASRC_RS_COEFF_MEM);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnum_coeff = 16 * 128 * 4;\n\n\tfor (i = 0; i < num_coeff; i++) {\n\t\tr = (uint32_t *)&coef[i];\n\t\tregmap_write(easrc->regmap, REG_EASRC_CRCM,\n\t\t\t     EASRC_CRCM_RS_CWD(r[0]));\n\t\tregmap_write(easrc->regmap, REG_EASRC_CRCM,\n\t\t\t     EASRC_CRCM_RS_CWD(r[1]));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_normalize_filter(struct fsl_asrc *easrc,\n\t\t\t\t      u64 *infilter,\n\t\t\t\t      u64 *outfilter,\n\t\t\t\t      int shift)\n{\n\tstruct device *dev = &easrc->pdev->dev;\n\tu64 coef = *infilter;\n\ts64 exp  = (coef & 0x7ff0000000000000ll) >> 52;\n\tu64 outcoef;\n\n\t \n\tif (exp == 0 || exp == 0x7ff) {\n\t\t*outfilter = coef;\n\t\treturn 0;\n\t}\n\n\t \n\texp += shift;\n\n\tif ((shift > 0 && exp >= 0x7ff) || (shift < 0 && exp <= 0)) {\n\t\tdev_err(dev, \"coef out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\toutcoef = (u64)(coef & 0x800FFFFFFFFFFFFFll) + ((u64)exp << 52);\n\t*outfilter = outcoef;\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_write_pf_coeff_mem(struct fsl_asrc *easrc, int ctx_id,\n\t\t\t\t\tu64 *coef, int n_taps, int shift)\n{\n\tstruct device *dev = &easrc->pdev->dev;\n\tint ret = 0;\n\tint i;\n\tu32 *r;\n\tu64 tmp;\n\n\t \n\tif (!n_taps)\n\t\treturn 0;\n\n\tif (!coef) {\n\t\tdev_err(dev, \"coef table is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = fsl_easrc_coeff_mem_ptr_reset(easrc, ctx_id, EASRC_PF_COEFF_MEM);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < (n_taps + 1) / 2; i++) {\n\t\tret = fsl_easrc_normalize_filter(easrc, &coef[i], &tmp, shift);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tr = (uint32_t *)&tmp;\n\t\tregmap_write(easrc->regmap, REG_EASRC_PCF(ctx_id),\n\t\t\t     EASRC_PCF_CD(r[0]));\n\t\tregmap_write(easrc->regmap, REG_EASRC_PCF(ctx_id),\n\t\t\t     EASRC_PCF_CD(r[1]));\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_prefilter_config(struct fsl_asrc *easrc,\n\t\t\t\t      unsigned int ctx_id)\n{\n\tstruct prefil_params *prefil, *selected_prefil = NULL;\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\tstruct fsl_easrc_priv *easrc_priv;\n\tstruct asrc_firmware_hdr *hdr;\n\tstruct fsl_asrc_pair *ctx;\n\tstruct device *dev;\n\tu32 inrate, outrate, offset = 0;\n\tu32 in_s_rate, out_s_rate;\n\tsnd_pcm_format_t in_s_fmt, out_s_fmt;\n\tint ret, i;\n\n\tif (!easrc)\n\t\treturn -ENODEV;\n\n\tdev = &easrc->pdev->dev;\n\n\tif (ctx_id >= EASRC_CTX_MAX_NUM) {\n\t\tdev_err(dev, \"Invalid context id[%d]\\n\", ctx_id);\n\t\treturn -EINVAL;\n\t}\n\n\teasrc_priv = easrc->private;\n\n\tctx = easrc->pair[ctx_id];\n\tctx_priv = ctx->private;\n\n\tin_s_rate = ctx_priv->in_params.sample_rate;\n\tout_s_rate = ctx_priv->out_params.sample_rate;\n\tin_s_fmt = ctx_priv->in_params.sample_format;\n\tout_s_fmt = ctx_priv->out_params.sample_format;\n\n\tctx_priv->in_filled_sample = bits_taps_to_val(easrc_priv->rs_num_taps) / 2;\n\tctx_priv->out_missed_sample = ctx_priv->in_filled_sample * out_s_rate / in_s_rate;\n\n\tctx_priv->st1_num_taps = 0;\n\tctx_priv->st2_num_taps = 0;\n\n\tregmap_write(easrc->regmap, REG_EASRC_CCE1(ctx_id), 0);\n\tregmap_write(easrc->regmap, REG_EASRC_CCE2(ctx_id), 0);\n\n\t \n\tif (out_s_rate >= in_s_rate) {\n\t\tif (out_s_rate == in_s_rate)\n\t\t\tregmap_update_bits(easrc->regmap,\n\t\t\t\t\t   REG_EASRC_CCE1(ctx_id),\n\t\t\t\t\t   EASRC_CCE1_RS_BYPASS_MASK,\n\t\t\t\t\t   EASRC_CCE1_RS_BYPASS);\n\n\t\tctx_priv->st1_num_taps = 1;\n\t\tctx_priv->st1_coeff    = &easrc_priv->const_coeff;\n\t\tctx_priv->st1_num_exp  = 1;\n\t\tctx_priv->st2_num_taps = 0;\n\n\t\tif (in_s_fmt == SNDRV_PCM_FORMAT_FLOAT_LE &&\n\t\t    out_s_fmt != SNDRV_PCM_FORMAT_FLOAT_LE)\n\t\t\tctx_priv->st1_addexp = 31;\n\t\telse if (in_s_fmt != SNDRV_PCM_FORMAT_FLOAT_LE &&\n\t\t\t out_s_fmt == SNDRV_PCM_FORMAT_FLOAT_LE)\n\t\t\tctx_priv->st1_addexp -= ctx_priv->in_params.fmt.addexp;\n\t} else {\n\t\tinrate = ctx_priv->in_params.norm_rate;\n\t\toutrate = ctx_priv->out_params.norm_rate;\n\n\t\thdr = easrc_priv->firmware_hdr;\n\t\tprefil = easrc_priv->prefil;\n\n\t\tfor (i = 0; i < hdr->prefil_scen; i++) {\n\t\t\tif (inrate == prefil[i].insr &&\n\t\t\t    outrate == prefil[i].outsr) {\n\t\t\t\tselected_prefil = &prefil[i];\n\t\t\t\tdev_dbg(dev, \"Selected prefilter: %u insr, %u outsr, %u st1_taps, %u st2_taps\\n\",\n\t\t\t\t\tselected_prefil->insr,\n\t\t\t\t\tselected_prefil->outsr,\n\t\t\t\t\tselected_prefil->st1_taps,\n\t\t\t\t\tselected_prefil->st2_taps);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!selected_prefil) {\n\t\t\tdev_err(dev, \"Conversion from in ratio %u(%u) to out ratio %u(%u) is not supported\\n\",\n\t\t\t\tin_s_rate, inrate,\n\t\t\t\tout_s_rate, outrate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tctx_priv->st1_num_taps = selected_prefil->st1_taps;\n\t\tctx_priv->st1_coeff    = selected_prefil->coeff;\n\t\tctx_priv->st1_num_exp  = selected_prefil->st1_exp;\n\n\t\toffset = ((selected_prefil->st1_taps + 1) / 2);\n\t\tctx_priv->st2_num_taps = selected_prefil->st2_taps;\n\t\tctx_priv->st2_coeff    = selected_prefil->coeff + offset;\n\n\t\tif (in_s_fmt == SNDRV_PCM_FORMAT_FLOAT_LE &&\n\t\t    out_s_fmt != SNDRV_PCM_FORMAT_FLOAT_LE) {\n\t\t\t \n\t\t\tif (ctx_priv->st2_num_taps > 0)\n\t\t\t\tctx_priv->st2_addexp = 31;\n\t\t\telse\n\t\t\t\tctx_priv->st1_addexp = 31;\n\t\t} else if (in_s_fmt != SNDRV_PCM_FORMAT_FLOAT_LE &&\n\t\t\t   out_s_fmt == SNDRV_PCM_FORMAT_FLOAT_LE) {\n\t\t\tif (ctx_priv->st2_num_taps > 0)\n\t\t\t\tctx_priv->st2_addexp -= ctx_priv->in_params.fmt.addexp;\n\t\t\telse\n\t\t\t\tctx_priv->st1_addexp -= ctx_priv->in_params.fmt.addexp;\n\t\t}\n\t}\n\n\tctx_priv->in_filled_sample += (ctx_priv->st1_num_taps / 2) * ctx_priv->st1_num_exp +\n\t\t\t\t  ctx_priv->st2_num_taps / 2;\n\tctx_priv->out_missed_sample = ctx_priv->in_filled_sample * out_s_rate / in_s_rate;\n\n\tif (ctx_priv->in_filled_sample * out_s_rate % in_s_rate != 0)\n\t\tctx_priv->out_missed_sample += 1;\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx_id),\n\t\t\t   EASRC_CC_EN_MASK, 0);\n\n\tif (ctx_priv->st1_num_taps > EASRC_MAX_PF_TAPS) {\n\t\tdev_err(dev, \"ST1 taps [%d] mus be lower than %d\\n\",\n\t\t\tctx_priv->st1_num_taps, EASRC_MAX_PF_TAPS);\n\t\tret = -EINVAL;\n\t\tgoto ctx_error;\n\t}\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE2(ctx_id),\n\t\t\t   EASRC_CCE2_ST1_TAPS_MASK,\n\t\t\t   EASRC_CCE2_ST1_TAPS(ctx_priv->st1_num_taps - 1));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t   EASRC_CCE1_COEF_WS_MASK,\n\t\t\t   EASRC_PF_ST1_COEFF_WR << EASRC_CCE1_COEF_WS_SHIFT);\n\n\tret = fsl_easrc_write_pf_coeff_mem(easrc, ctx_id,\n\t\t\t\t\t   ctx_priv->st1_coeff,\n\t\t\t\t\t   ctx_priv->st1_num_taps,\n\t\t\t\t\t   ctx_priv->st1_addexp);\n\tif (ret)\n\t\tgoto ctx_error;\n\n\tif (ctx_priv->st2_num_taps > 0) {\n\t\tif (ctx_priv->st2_num_taps + ctx_priv->st1_num_taps > EASRC_MAX_PF_TAPS) {\n\t\t\tdev_err(dev, \"ST2 taps [%d] mus be lower than %d\\n\",\n\t\t\t\tctx_priv->st2_num_taps, EASRC_MAX_PF_TAPS);\n\t\t\tret = -EINVAL;\n\t\t\tgoto ctx_error;\n\t\t}\n\n\t\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t\t   EASRC_CCE1_PF_TSEN_MASK,\n\t\t\t\t   EASRC_CCE1_PF_TSEN);\n\t\t \n\t\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t\t   EASRC_CCE1_PF_ST1_WBFP_MASK,\n\t\t\t\t   EASRC_CCE1_PF_ST1_WBFP);\n\n\t\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t\t   EASRC_CCE1_PF_EXP_MASK,\n\t\t\t\t   EASRC_CCE1_PF_EXP(ctx_priv->st1_num_exp - 1));\n\n\t\t \n\t\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE2(ctx_id),\n\t\t\t\t   EASRC_CCE2_ST2_TAPS_MASK,\n\t\t\t\t   EASRC_CCE2_ST2_TAPS(ctx_priv->st2_num_taps - 1));\n\n\t\t \n\t\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t\t   EASRC_CCE1_COEF_WS_MASK,\n\t\t\t\t   EASRC_PF_ST2_COEFF_WR << EASRC_CCE1_COEF_WS_SHIFT);\n\n\t\tret = fsl_easrc_write_pf_coeff_mem(easrc, ctx_id,\n\t\t\t\t\t\t   ctx_priv->st2_coeff,\n\t\t\t\t\t\t   ctx_priv->st2_num_taps,\n\t\t\t\t\t\t   ctx_priv->st2_addexp);\n\t\tif (ret)\n\t\t\tgoto ctx_error;\n\t}\n\n\treturn 0;\n\nctx_error:\n\treturn ret;\n}\n\nstatic int fsl_easrc_max_ch_for_slot(struct fsl_asrc_pair *ctx,\n\t\t\t\t     struct fsl_easrc_slot *slot)\n{\n\tstruct fsl_easrc_ctx_priv *ctx_priv = ctx->private;\n\tint st1_mem_alloc = 0, st2_mem_alloc = 0;\n\tint pf_mem_alloc = 0;\n\tint max_channels = 8 - slot->num_channel;\n\tint channels = 0;\n\n\tif (ctx_priv->st1_num_taps > 0) {\n\t\tif (ctx_priv->st2_num_taps > 0)\n\t\t\tst1_mem_alloc =\n\t\t\t\t(ctx_priv->st1_num_taps - 1) * ctx_priv->st1_num_exp + 1;\n\t\telse\n\t\t\tst1_mem_alloc = ctx_priv->st1_num_taps;\n\t}\n\n\tif (ctx_priv->st2_num_taps > 0)\n\t\tst2_mem_alloc = ctx_priv->st2_num_taps;\n\n\tpf_mem_alloc = st1_mem_alloc + st2_mem_alloc;\n\n\tif (pf_mem_alloc != 0)\n\t\tchannels = (6144 - slot->pf_mem_used) / pf_mem_alloc;\n\telse\n\t\tchannels = 8;\n\n\tif (channels < max_channels)\n\t\tmax_channels = channels;\n\n\treturn max_channels;\n}\n\nstatic int fsl_easrc_config_one_slot(struct fsl_asrc_pair *ctx,\n\t\t\t\t     struct fsl_easrc_slot *slot,\n\t\t\t\t     unsigned int slot_ctx_idx,\n\t\t\t\t     unsigned int *req_channels,\n\t\t\t\t     unsigned int *start_channel,\n\t\t\t\t     unsigned int *avail_channel)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tstruct fsl_easrc_ctx_priv *ctx_priv = ctx->private;\n\tint st1_chanxexp, st1_mem_alloc = 0, st2_mem_alloc;\n\tunsigned int reg0, reg1, reg2, reg3;\n\tunsigned int addr;\n\n\tif (slot->slot_index == 0) {\n\t\treg0 = REG_EASRC_DPCS0R0(slot_ctx_idx);\n\t\treg1 = REG_EASRC_DPCS0R1(slot_ctx_idx);\n\t\treg2 = REG_EASRC_DPCS0R2(slot_ctx_idx);\n\t\treg3 = REG_EASRC_DPCS0R3(slot_ctx_idx);\n\t} else {\n\t\treg0 = REG_EASRC_DPCS1R0(slot_ctx_idx);\n\t\treg1 = REG_EASRC_DPCS1R1(slot_ctx_idx);\n\t\treg2 = REG_EASRC_DPCS1R2(slot_ctx_idx);\n\t\treg3 = REG_EASRC_DPCS1R3(slot_ctx_idx);\n\t}\n\n\tif (*req_channels <= *avail_channel) {\n\t\tslot->num_channel = *req_channels;\n\t\t*req_channels = 0;\n\t} else {\n\t\tslot->num_channel = *avail_channel;\n\t\t*req_channels -= *avail_channel;\n\t}\n\n\tslot->min_channel = *start_channel;\n\tslot->max_channel = *start_channel + slot->num_channel - 1;\n\tslot->ctx_index = ctx->index;\n\tslot->busy = true;\n\t*start_channel += slot->num_channel;\n\n\tregmap_update_bits(easrc->regmap, reg0,\n\t\t\t   EASRC_DPCS0R0_MAXCH_MASK,\n\t\t\t   EASRC_DPCS0R0_MAXCH(slot->max_channel));\n\n\tregmap_update_bits(easrc->regmap, reg0,\n\t\t\t   EASRC_DPCS0R0_MINCH_MASK,\n\t\t\t   EASRC_DPCS0R0_MINCH(slot->min_channel));\n\n\tregmap_update_bits(easrc->regmap, reg0,\n\t\t\t   EASRC_DPCS0R0_NUMCH_MASK,\n\t\t\t   EASRC_DPCS0R0_NUMCH(slot->num_channel - 1));\n\n\tregmap_update_bits(easrc->regmap, reg0,\n\t\t\t   EASRC_DPCS0R0_CTXNUM_MASK,\n\t\t\t   EASRC_DPCS0R0_CTXNUM(slot->ctx_index));\n\n\tif (ctx_priv->st1_num_taps > 0) {\n\t\tif (ctx_priv->st2_num_taps > 0)\n\t\t\tst1_mem_alloc =\n\t\t\t\t(ctx_priv->st1_num_taps - 1) * slot->num_channel *\n\t\t\t\tctx_priv->st1_num_exp + slot->num_channel;\n\t\telse\n\t\t\tst1_mem_alloc = ctx_priv->st1_num_taps * slot->num_channel;\n\n\t\tslot->pf_mem_used = st1_mem_alloc;\n\t\tregmap_update_bits(easrc->regmap, reg2,\n\t\t\t\t   EASRC_DPCS0R2_ST1_MA_MASK,\n\t\t\t\t   EASRC_DPCS0R2_ST1_MA(st1_mem_alloc));\n\n\t\tif (slot->slot_index == 1)\n\t\t\taddr = PREFILTER_MEM_LEN - st1_mem_alloc;\n\t\telse\n\t\t\taddr = 0;\n\n\t\tregmap_update_bits(easrc->regmap, reg2,\n\t\t\t\t   EASRC_DPCS0R2_ST1_SA_MASK,\n\t\t\t\t   EASRC_DPCS0R2_ST1_SA(addr));\n\t}\n\n\tif (ctx_priv->st2_num_taps > 0) {\n\t\tst1_chanxexp = slot->num_channel * (ctx_priv->st1_num_exp - 1);\n\n\t\tregmap_update_bits(easrc->regmap, reg1,\n\t\t\t\t   EASRC_DPCS0R1_ST1_EXP_MASK,\n\t\t\t\t   EASRC_DPCS0R1_ST1_EXP(st1_chanxexp));\n\n\t\tst2_mem_alloc = slot->num_channel * ctx_priv->st2_num_taps;\n\t\tslot->pf_mem_used += st2_mem_alloc;\n\t\tregmap_update_bits(easrc->regmap, reg3,\n\t\t\t\t   EASRC_DPCS0R3_ST2_MA_MASK,\n\t\t\t\t   EASRC_DPCS0R3_ST2_MA(st2_mem_alloc));\n\n\t\tif (slot->slot_index == 1)\n\t\t\taddr = PREFILTER_MEM_LEN - st1_mem_alloc - st2_mem_alloc;\n\t\telse\n\t\t\taddr = st1_mem_alloc;\n\n\t\tregmap_update_bits(easrc->regmap, reg3,\n\t\t\t\t   EASRC_DPCS0R3_ST2_SA_MASK,\n\t\t\t\t   EASRC_DPCS0R3_ST2_SA(addr));\n\t}\n\n\tregmap_update_bits(easrc->regmap, reg0,\n\t\t\t   EASRC_DPCS0R0_EN_MASK, EASRC_DPCS0R0_EN);\n\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_config_slot(struct fsl_asrc *easrc, unsigned int ctx_id)\n{\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct fsl_asrc_pair *ctx = easrc->pair[ctx_id];\n\tint req_channels = ctx->channels;\n\tint start_channel = 0, avail_channel;\n\tstruct fsl_easrc_slot *slot0, *slot1;\n\tstruct fsl_easrc_slot *slota, *slotb;\n\tint i, ret;\n\n\tif (req_channels <= 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < EASRC_CTX_MAX_NUM; i++) {\n\t\tslot0 = &easrc_priv->slot[i][0];\n\t\tslot1 = &easrc_priv->slot[i][1];\n\n\t\tif (slot0->busy && slot1->busy) {\n\t\t\tcontinue;\n\t\t} else if ((slot0->busy && slot0->ctx_index == ctx->index) ||\n\t\t\t (slot1->busy && slot1->ctx_index == ctx->index)) {\n\t\t\tcontinue;\n\t\t} else if (!slot0->busy) {\n\t\t\tslota = slot0;\n\t\t\tslotb = slot1;\n\t\t\tslota->slot_index = 0;\n\t\t} else if (!slot1->busy) {\n\t\t\tslota = slot1;\n\t\t\tslotb = slot0;\n\t\t\tslota->slot_index = 1;\n\t\t}\n\n\t\tif (!slota || !slotb)\n\t\t\tcontinue;\n\n\t\tavail_channel = fsl_easrc_max_ch_for_slot(ctx, slotb);\n\t\tif (avail_channel <= 0)\n\t\t\tcontinue;\n\n\t\tret = fsl_easrc_config_one_slot(ctx, slota, i, &req_channels,\n\t\t\t\t\t\t&start_channel, &avail_channel);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (req_channels > 0)\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (req_channels > 0) {\n\t\tdev_err(&easrc->pdev->dev, \"no avail slot.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_release_slot(struct fsl_asrc *easrc, unsigned int ctx_id)\n{\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct fsl_asrc_pair *ctx = easrc->pair[ctx_id];\n\tint i;\n\n\tfor (i = 0; i < EASRC_CTX_MAX_NUM; i++) {\n\t\tif (easrc_priv->slot[i][0].busy &&\n\t\t    easrc_priv->slot[i][0].ctx_index == ctx->index) {\n\t\t\teasrc_priv->slot[i][0].busy = false;\n\t\t\teasrc_priv->slot[i][0].num_channel = 0;\n\t\t\teasrc_priv->slot[i][0].pf_mem_used = 0;\n\t\t\t \n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS0R0(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS0R1(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS0R2(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS0R3(i), 0);\n\t\t}\n\n\t\tif (easrc_priv->slot[i][1].busy &&\n\t\t    easrc_priv->slot[i][1].ctx_index == ctx->index) {\n\t\t\teasrc_priv->slot[i][1].busy = false;\n\t\t\teasrc_priv->slot[i][1].num_channel = 0;\n\t\t\teasrc_priv->slot[i][1].pf_mem_used = 0;\n\t\t\t \n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS1R0(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS1R1(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS1R2(i), 0);\n\t\t\tregmap_write(easrc->regmap, REG_EASRC_DPCS1R3(i), 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_config_context(struct fsl_asrc *easrc, unsigned int ctx_id)\n{\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\tstruct fsl_asrc_pair *ctx;\n\tstruct device *dev;\n\tunsigned long lock_flags;\n\tint ret;\n\n\tif (!easrc)\n\t\treturn -ENODEV;\n\n\tdev = &easrc->pdev->dev;\n\n\tif (ctx_id >= EASRC_CTX_MAX_NUM) {\n\t\tdev_err(dev, \"Invalid context id[%d]\\n\", ctx_id);\n\t\treturn -EINVAL;\n\t}\n\n\tctx = easrc->pair[ctx_id];\n\n\tctx_priv = ctx->private;\n\n\tfsl_easrc_normalize_rates(ctx);\n\n\tret = fsl_easrc_set_rs_ratio(ctx);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = fsl_easrc_prefilter_config(easrc, ctx->index);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&easrc->lock, lock_flags);\n\tret = fsl_easrc_config_slot(easrc, ctx->index);\n\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t   EASRC_CCE1_RS_INIT_MASK,\n\t\t\t   EASRC_CCE1_RS_INIT(ctx_priv->rs_init_mode));\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CCE1(ctx_id),\n\t\t\t   EASRC_CCE1_PF_INIT_MASK,\n\t\t\t   EASRC_CCE1_PF_INIT(ctx_priv->pf_init_mode));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx_id),\n\t\t\t   EASRC_CC_FIFO_WTMK_MASK,\n\t\t\t   EASRC_CC_FIFO_WTMK(ctx_priv->in_params.fifo_wtmk));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx_id),\n\t\t\t   EASRC_COC_FIFO_WTMK_MASK,\n\t\t\t   EASRC_COC_FIFO_WTMK(ctx_priv->out_params.fifo_wtmk - 1));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx_id),\n\t\t\t   EASRC_CC_CHEN_MASK,\n\t\t\t   EASRC_CC_CHEN(ctx->channels - 1));\n\treturn 0;\n}\n\nstatic int fsl_easrc_process_format(struct fsl_asrc_pair *ctx,\n\t\t\t\t    struct fsl_easrc_data_fmt *fmt,\n\t\t\t\t    snd_pcm_format_t raw_fmt)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tint ret;\n\n\tif (!fmt)\n\t\treturn -EINVAL;\n\n\t \n\tfmt->floating_point = !snd_pcm_format_linear(raw_fmt);\n\tfmt->sample_pos = 0;\n\tfmt->iec958 = 0;\n\n\t \n\tswitch (snd_pcm_format_width(raw_fmt)) {\n\tcase 16:\n\t\tfmt->width = EASRC_WIDTH_16_BIT;\n\t\tfmt->addexp = 15;\n\t\tbreak;\n\tcase 20:\n\t\tfmt->width = EASRC_WIDTH_20_BIT;\n\t\tfmt->addexp = 19;\n\t\tbreak;\n\tcase 24:\n\t\tfmt->width = EASRC_WIDTH_24_BIT;\n\t\tfmt->addexp = 23;\n\t\tbreak;\n\tcase 32:\n\t\tfmt->width = EASRC_WIDTH_32_BIT;\n\t\tfmt->addexp = 31;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (raw_fmt) {\n\tcase SNDRV_PCM_FORMAT_IEC958_SUBFRAME_LE:\n\t\tfmt->width = easrc_priv->bps_iec958[ctx->index];\n\t\tfmt->iec958 = 1;\n\t\tfmt->floating_point = 0;\n\t\tif (fmt->width == EASRC_WIDTH_16_BIT) {\n\t\t\tfmt->sample_pos = 12;\n\t\t\tfmt->addexp = 15;\n\t\t} else if (fmt->width == EASRC_WIDTH_20_BIT) {\n\t\t\tfmt->sample_pos = 8;\n\t\t\tfmt->addexp = 19;\n\t\t} else if (fmt->width == EASRC_WIDTH_24_BIT) {\n\t\t\tfmt->sample_pos = 4;\n\t\t\tfmt->addexp = 23;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tret = snd_pcm_format_big_endian(raw_fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfmt->endianness = ret;\n\n\t \n\tfmt->unsign = snd_pcm_format_unsigned(raw_fmt) > 0 ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_set_ctx_format(struct fsl_asrc_pair *ctx,\n\t\t\t\t    snd_pcm_format_t *in_raw_format,\n\t\t\t\t    snd_pcm_format_t *out_raw_format)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tstruct fsl_easrc_ctx_priv *ctx_priv = ctx->private;\n\tstruct fsl_easrc_data_fmt *in_fmt = &ctx_priv->in_params.fmt;\n\tstruct fsl_easrc_data_fmt *out_fmt = &ctx_priv->out_params.fmt;\n\tint ret = 0;\n\n\t \n\tif (in_raw_format && out_raw_format) {\n\t\tret = fsl_easrc_process_format(ctx, in_fmt, *in_raw_format);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_BPS_MASK,\n\t\t\t   EASRC_CC_BPS(in_fmt->width));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_ENDIANNESS_MASK,\n\t\t\t   in_fmt->endianness << EASRC_CC_ENDIANNESS_SHIFT);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_FMT_MASK,\n\t\t\t   in_fmt->floating_point << EASRC_CC_FMT_SHIFT);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_INSIGN_MASK,\n\t\t\t   in_fmt->unsign << EASRC_CC_INSIGN_SHIFT);\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_SAMPLE_POS_MASK,\n\t\t\t   EASRC_CC_SAMPLE_POS(in_fmt->sample_pos));\n\n\t \n\tif (in_raw_format && out_raw_format) {\n\t\tret = fsl_easrc_process_format(ctx, out_fmt, *out_raw_format);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_BPS_MASK,\n\t\t\t   EASRC_COC_BPS(out_fmt->width));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_ENDIANNESS_MASK,\n\t\t\t   out_fmt->endianness << EASRC_COC_ENDIANNESS_SHIFT);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_FMT_MASK,\n\t\t\t   out_fmt->floating_point << EASRC_COC_FMT_SHIFT);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_OUTSIGN_MASK,\n\t\t\t   out_fmt->unsign << EASRC_COC_OUTSIGN_SHIFT);\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_SAMPLE_POS_MASK,\n\t\t\t   EASRC_COC_SAMPLE_POS(out_fmt->sample_pos));\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_IEC_EN_MASK,\n\t\t\t   out_fmt->iec958 << EASRC_COC_IEC_EN_SHIFT);\n\n\treturn ret;\n}\n\n \nstatic int fsl_easrc_set_ctx_organziation(struct fsl_asrc_pair *ctx)\n{\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\tstruct fsl_asrc *easrc;\n\n\tif (!ctx)\n\t\treturn -ENODEV;\n\n\teasrc = ctx->asrc;\n\tctx_priv = ctx->private;\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_CIA(ctx->index),\n\t\t\t   EASRC_CIA_ITER_MASK,\n\t\t\t   EASRC_CIA_ITER(ctx_priv->in_params.iterations));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CIA(ctx->index),\n\t\t\t   EASRC_CIA_GRLEN_MASK,\n\t\t\t   EASRC_CIA_GRLEN(ctx_priv->in_params.group_len));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CIA(ctx->index),\n\t\t\t   EASRC_CIA_ACCLEN_MASK,\n\t\t\t   EASRC_CIA_ACCLEN(ctx_priv->in_params.access_len));\n\n\t \n\tregmap_update_bits(easrc->regmap, REG_EASRC_COA(ctx->index),\n\t\t\t   EASRC_COA_ITER_MASK,\n\t\t\t   EASRC_COA_ITER(ctx_priv->out_params.iterations));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COA(ctx->index),\n\t\t\t   EASRC_COA_GRLEN_MASK,\n\t\t\t   EASRC_COA_GRLEN(ctx_priv->out_params.group_len));\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COA(ctx->index),\n\t\t\t   EASRC_COA_ACCLEN_MASK,\n\t\t\t   EASRC_COA_ACCLEN(ctx_priv->out_params.access_len));\n\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_request_context(int channels, struct fsl_asrc_pair *ctx)\n{\n\tenum asrc_pair_index index = ASRC_INVALID_PAIR;\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tstruct device *dev;\n\tunsigned long lock_flags;\n\tint ret = 0;\n\tint i;\n\n\tdev = &easrc->pdev->dev;\n\n\tspin_lock_irqsave(&easrc->lock, lock_flags);\n\n\tfor (i = ASRC_PAIR_A; i < EASRC_CTX_MAX_NUM; i++) {\n\t\tif (easrc->pair[i])\n\t\t\tcontinue;\n\n\t\tindex = i;\n\t\tbreak;\n\t}\n\n\tif (index == ASRC_INVALID_PAIR) {\n\t\tdev_err(dev, \"all contexts are busy\\n\");\n\t\tret = -EBUSY;\n\t} else if (channels > easrc->channel_avail) {\n\t\tdev_err(dev, \"can't give the required channels: %d\\n\",\n\t\t\tchannels);\n\t\tret = -EINVAL;\n\t} else {\n\t\tctx->index = index;\n\t\tctx->channels = channels;\n\t\teasrc->pair[index] = ctx;\n\t\teasrc->channel_avail -= channels;\n\t}\n\n\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n\n\treturn ret;\n}\n\n \nstatic void fsl_easrc_release_context(struct fsl_asrc_pair *ctx)\n{\n\tunsigned long lock_flags;\n\tstruct fsl_asrc *easrc;\n\n\tif (!ctx)\n\t\treturn;\n\n\teasrc = ctx->asrc;\n\n\tspin_lock_irqsave(&easrc->lock, lock_flags);\n\n\tfsl_easrc_release_slot(easrc, ctx->index);\n\n\teasrc->channel_avail += ctx->channels;\n\teasrc->pair[ctx->index] = NULL;\n\n\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n}\n\n \nstatic int fsl_easrc_start_context(struct fsl_asrc_pair *ctx)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_FWMDE_MASK, EASRC_CC_FWMDE);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_FWMDE_MASK, EASRC_COC_FWMDE);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_EN_MASK, EASRC_CC_EN);\n\treturn 0;\n}\n\n \nstatic int fsl_easrc_stop_context(struct fsl_asrc_pair *ctx)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tint val, i;\n\tint size;\n\tint retry = 200;\n\n\tregmap_read(easrc->regmap, REG_EASRC_CC(ctx->index), &val);\n\n\tif (val & EASRC_CC_EN_MASK) {\n\t\tregmap_update_bits(easrc->regmap,\n\t\t\t\t   REG_EASRC_CC(ctx->index),\n\t\t\t\t   EASRC_CC_STOP_MASK, EASRC_CC_STOP);\n\t\tdo {\n\t\t\tregmap_read(easrc->regmap, REG_EASRC_SFS(ctx->index), &val);\n\t\t\tval &= EASRC_SFS_NSGO_MASK;\n\t\t\tsize = val >> EASRC_SFS_NSGO_SHIFT;\n\n\t\t\t \n\t\t\tfor (i = 0; i < size * ctx->channels; i++)\n\t\t\t\tregmap_read(easrc->regmap, REG_EASRC_RDFIFO(ctx->index), &val);\n\t\t\t \n\t\t\tregmap_read(easrc->regmap, REG_EASRC_IRQF, &val);\n\t\t\tif (val & EASRC_IRQF_RSD(1 << ctx->index)) {\n\t\t\t\t \n\t\t\t\tregmap_write_bits(easrc->regmap,\n\t\t\t\t\t\t  REG_EASRC_IRQF,\n\t\t\t\t\t\t  EASRC_IRQF_RSD(1 << ctx->index),\n\t\t\t\t\t\t  EASRC_IRQF_RSD(1 << ctx->index));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(100);\n\t\t} while (--retry);\n\n\t\tif (retry == 0)\n\t\t\tdev_warn(&easrc->pdev->dev, \"RUN STOP fail\\n\");\n\t}\n\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_EN_MASK | EASRC_CC_STOP_MASK, 0);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_CC(ctx->index),\n\t\t\t   EASRC_CC_FWMDE_MASK, 0);\n\tregmap_update_bits(easrc->regmap, REG_EASRC_COC(ctx->index),\n\t\t\t   EASRC_COC_FWMDE_MASK, 0);\n\treturn 0;\n}\n\nstatic struct dma_chan *fsl_easrc_get_dma_channel(struct fsl_asrc_pair *ctx,\n\t\t\t\t\t\t  bool dir)\n{\n\tstruct fsl_asrc *easrc = ctx->asrc;\n\tenum asrc_pair_index index = ctx->index;\n\tchar name[8];\n\n\t \n\tsprintf(name, \"ctx%c_%cx\", index + '0', dir == IN ? 'r' : 't');\n\n\treturn dma_request_slave_channel(&easrc->pdev->dev, name);\n};\n\nstatic const unsigned int easrc_rates[] = {\n\t8000, 11025, 12000, 16000,\n\t22050, 24000, 32000, 44100,\n\t48000, 64000, 88200, 96000,\n\t128000, 176400, 192000, 256000,\n\t352800, 384000, 705600, 768000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list easrc_rate_constraints = {\n\t.count = ARRAY_SIZE(easrc_rates),\n\t.list = easrc_rates,\n};\n\nstatic int fsl_easrc_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &easrc_rate_constraints);\n}\n\nstatic int fsl_easrc_trigger(struct snd_pcm_substream *substream,\n\t\t\t     int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *ctx = runtime->private_data;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = fsl_easrc_start_context(ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = fsl_easrc_stop_context(ctx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_hw_params(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_pcm_hw_params *params,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct fsl_asrc *easrc = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = &easrc->pdev->dev;\n\tstruct fsl_asrc_pair *ctx = runtime->private_data;\n\tstruct fsl_easrc_ctx_priv *ctx_priv = ctx->private;\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tsnd_pcm_format_t format = params_format(params);\n\tint ret;\n\n\tret = fsl_easrc_request_context(channels, ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request context\\n\");\n\t\treturn ret;\n\t}\n\n\tctx_priv->ctx_streams |= BIT(substream->stream);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tctx_priv->in_params.sample_rate = rate;\n\t\tctx_priv->in_params.sample_format = format;\n\t\tctx_priv->out_params.sample_rate = easrc->asrc_rate;\n\t\tctx_priv->out_params.sample_format = easrc->asrc_format;\n\t} else {\n\t\tctx_priv->out_params.sample_rate = rate;\n\t\tctx_priv->out_params.sample_format = format;\n\t\tctx_priv->in_params.sample_rate = easrc->asrc_rate;\n\t\tctx_priv->in_params.sample_format = easrc->asrc_format;\n\t}\n\n\tctx->channels = channels;\n\tctx_priv->in_params.fifo_wtmk  = 0x20;\n\tctx_priv->out_params.fifo_wtmk = 0x20;\n\n\t \n\tret = fsl_easrc_set_ctx_format(ctx,\n\t\t\t\t       &ctx_priv->in_params.sample_format,\n\t\t\t\t       &ctx_priv->out_params.sample_format);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set format %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = fsl_easrc_config_context(easrc, ctx->index);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to config context\\n\");\n\t\treturn ret;\n\t}\n\n\tctx_priv->in_params.iterations = 1;\n\tctx_priv->in_params.group_len = ctx->channels;\n\tctx_priv->in_params.access_len = ctx->channels;\n\tctx_priv->out_params.iterations = 1;\n\tctx_priv->out_params.group_len = ctx->channels;\n\tctx_priv->out_params.access_len = ctx->channels;\n\n\tret = fsl_easrc_set_ctx_organziation(ctx);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set fifo organization\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_hw_free(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *ctx = runtime->private_data;\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\n\tif (!ctx)\n\t\treturn -EINVAL;\n\n\tctx_priv = ctx->private;\n\n\tif (ctx_priv->ctx_streams & BIT(substream->stream)) {\n\t\tctx_priv->ctx_streams &= ~BIT(substream->stream);\n\t\tfsl_easrc_release_context(ctx);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_easrc_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_asrc *easrc = dev_get_drvdata(cpu_dai->dev);\n\n\tsnd_soc_dai_init_dma_data(cpu_dai,\n\t\t\t\t  &easrc->dma_params_tx,\n\t\t\t\t  &easrc->dma_params_rx);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_easrc_dai_ops = {\n\t.probe\t\t= fsl_easrc_dai_probe,\n\t.startup\t= fsl_easrc_startup,\n\t.trigger\t= fsl_easrc_trigger,\n\t.hw_params\t= fsl_easrc_hw_params,\n\t.hw_free\t= fsl_easrc_hw_free,\n};\n\nstatic struct snd_soc_dai_driver fsl_easrc_dai = {\n\t.playback = {\n\t\t.stream_name = \"ASRC-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 768000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_EASRC_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ASRC-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 768000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_EASRC_FORMATS |\n\t\t\t   SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t},\n\t.ops = &fsl_easrc_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_easrc_component = {\n\t.name\t\t\t= \"fsl-easrc-dai\",\n\t.controls\t\t= fsl_easrc_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(fsl_easrc_snd_controls),\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct reg_default fsl_easrc_reg_defaults[] = {\n\t{REG_EASRC_WRFIFO(0),\t0x00000000},\n\t{REG_EASRC_WRFIFO(1),\t0x00000000},\n\t{REG_EASRC_WRFIFO(2),\t0x00000000},\n\t{REG_EASRC_WRFIFO(3),\t0x00000000},\n\t{REG_EASRC_RDFIFO(0),\t0x00000000},\n\t{REG_EASRC_RDFIFO(1),\t0x00000000},\n\t{REG_EASRC_RDFIFO(2),\t0x00000000},\n\t{REG_EASRC_RDFIFO(3),\t0x00000000},\n\t{REG_EASRC_CC(0),\t0x00000000},\n\t{REG_EASRC_CC(1),\t0x00000000},\n\t{REG_EASRC_CC(2),\t0x00000000},\n\t{REG_EASRC_CC(3),\t0x00000000},\n\t{REG_EASRC_CCE1(0),\t0x00000000},\n\t{REG_EASRC_CCE1(1),\t0x00000000},\n\t{REG_EASRC_CCE1(2),\t0x00000000},\n\t{REG_EASRC_CCE1(3),\t0x00000000},\n\t{REG_EASRC_CCE2(0),\t0x00000000},\n\t{REG_EASRC_CCE2(1),\t0x00000000},\n\t{REG_EASRC_CCE2(2),\t0x00000000},\n\t{REG_EASRC_CCE2(3),\t0x00000000},\n\t{REG_EASRC_CIA(0),\t0x00000000},\n\t{REG_EASRC_CIA(1),\t0x00000000},\n\t{REG_EASRC_CIA(2),\t0x00000000},\n\t{REG_EASRC_CIA(3),\t0x00000000},\n\t{REG_EASRC_DPCS0R0(0),\t0x00000000},\n\t{REG_EASRC_DPCS0R0(1),\t0x00000000},\n\t{REG_EASRC_DPCS0R0(2),\t0x00000000},\n\t{REG_EASRC_DPCS0R0(3),\t0x00000000},\n\t{REG_EASRC_DPCS0R1(0),\t0x00000000},\n\t{REG_EASRC_DPCS0R1(1),\t0x00000000},\n\t{REG_EASRC_DPCS0R1(2),\t0x00000000},\n\t{REG_EASRC_DPCS0R1(3),\t0x00000000},\n\t{REG_EASRC_DPCS0R2(0),\t0x00000000},\n\t{REG_EASRC_DPCS0R2(1),\t0x00000000},\n\t{REG_EASRC_DPCS0R2(2),\t0x00000000},\n\t{REG_EASRC_DPCS0R2(3),\t0x00000000},\n\t{REG_EASRC_DPCS0R3(0),\t0x00000000},\n\t{REG_EASRC_DPCS0R3(1),\t0x00000000},\n\t{REG_EASRC_DPCS0R3(2),\t0x00000000},\n\t{REG_EASRC_DPCS0R3(3),\t0x00000000},\n\t{REG_EASRC_DPCS1R0(0),\t0x00000000},\n\t{REG_EASRC_DPCS1R0(1),\t0x00000000},\n\t{REG_EASRC_DPCS1R0(2),\t0x00000000},\n\t{REG_EASRC_DPCS1R0(3),\t0x00000000},\n\t{REG_EASRC_DPCS1R1(0),\t0x00000000},\n\t{REG_EASRC_DPCS1R1(1),\t0x00000000},\n\t{REG_EASRC_DPCS1R1(2),\t0x00000000},\n\t{REG_EASRC_DPCS1R1(3),\t0x00000000},\n\t{REG_EASRC_DPCS1R2(0),\t0x00000000},\n\t{REG_EASRC_DPCS1R2(1),\t0x00000000},\n\t{REG_EASRC_DPCS1R2(2),\t0x00000000},\n\t{REG_EASRC_DPCS1R2(3),\t0x00000000},\n\t{REG_EASRC_DPCS1R3(0),\t0x00000000},\n\t{REG_EASRC_DPCS1R3(1),\t0x00000000},\n\t{REG_EASRC_DPCS1R3(2),\t0x00000000},\n\t{REG_EASRC_DPCS1R3(3),\t0x00000000},\n\t{REG_EASRC_COC(0),\t0x00000000},\n\t{REG_EASRC_COC(1),\t0x00000000},\n\t{REG_EASRC_COC(2),\t0x00000000},\n\t{REG_EASRC_COC(3),\t0x00000000},\n\t{REG_EASRC_COA(0),\t0x00000000},\n\t{REG_EASRC_COA(1),\t0x00000000},\n\t{REG_EASRC_COA(2),\t0x00000000},\n\t{REG_EASRC_COA(3),\t0x00000000},\n\t{REG_EASRC_SFS(0),\t0x00000000},\n\t{REG_EASRC_SFS(1),\t0x00000000},\n\t{REG_EASRC_SFS(2),\t0x00000000},\n\t{REG_EASRC_SFS(3),\t0x00000000},\n\t{REG_EASRC_RRL(0),\t0x00000000},\n\t{REG_EASRC_RRL(1),\t0x00000000},\n\t{REG_EASRC_RRL(2),\t0x00000000},\n\t{REG_EASRC_RRL(3),\t0x00000000},\n\t{REG_EASRC_RRH(0),\t0x00000000},\n\t{REG_EASRC_RRH(1),\t0x00000000},\n\t{REG_EASRC_RRH(2),\t0x00000000},\n\t{REG_EASRC_RRH(3),\t0x00000000},\n\t{REG_EASRC_RUC(0),\t0x00000000},\n\t{REG_EASRC_RUC(1),\t0x00000000},\n\t{REG_EASRC_RUC(2),\t0x00000000},\n\t{REG_EASRC_RUC(3),\t0x00000000},\n\t{REG_EASRC_RUR(0),\t0x7FFFFFFF},\n\t{REG_EASRC_RUR(1),\t0x7FFFFFFF},\n\t{REG_EASRC_RUR(2),\t0x7FFFFFFF},\n\t{REG_EASRC_RUR(3),\t0x7FFFFFFF},\n\t{REG_EASRC_RCTCL,\t0x00000000},\n\t{REG_EASRC_RCTCH,\t0x00000000},\n\t{REG_EASRC_PCF(0),\t0x00000000},\n\t{REG_EASRC_PCF(1),\t0x00000000},\n\t{REG_EASRC_PCF(2),\t0x00000000},\n\t{REG_EASRC_PCF(3),\t0x00000000},\n\t{REG_EASRC_CRCM,\t0x00000000},\n\t{REG_EASRC_CRCC,\t0x00000000},\n\t{REG_EASRC_IRQC,\t0x00000FFF},\n\t{REG_EASRC_IRQF,\t0x00000000},\n\t{REG_EASRC_CS0(0),\t0x00000000},\n\t{REG_EASRC_CS0(1),\t0x00000000},\n\t{REG_EASRC_CS0(2),\t0x00000000},\n\t{REG_EASRC_CS0(3),\t0x00000000},\n\t{REG_EASRC_CS1(0),\t0x00000000},\n\t{REG_EASRC_CS1(1),\t0x00000000},\n\t{REG_EASRC_CS1(2),\t0x00000000},\n\t{REG_EASRC_CS1(3),\t0x00000000},\n\t{REG_EASRC_CS2(0),\t0x00000000},\n\t{REG_EASRC_CS2(1),\t0x00000000},\n\t{REG_EASRC_CS2(2),\t0x00000000},\n\t{REG_EASRC_CS2(3),\t0x00000000},\n\t{REG_EASRC_CS3(0),\t0x00000000},\n\t{REG_EASRC_CS3(1),\t0x00000000},\n\t{REG_EASRC_CS3(2),\t0x00000000},\n\t{REG_EASRC_CS3(3),\t0x00000000},\n\t{REG_EASRC_CS4(0),\t0x00000000},\n\t{REG_EASRC_CS4(1),\t0x00000000},\n\t{REG_EASRC_CS4(2),\t0x00000000},\n\t{REG_EASRC_CS4(3),\t0x00000000},\n\t{REG_EASRC_CS5(0),\t0x00000000},\n\t{REG_EASRC_CS5(1),\t0x00000000},\n\t{REG_EASRC_CS5(2),\t0x00000000},\n\t{REG_EASRC_CS5(3),\t0x00000000},\n\t{REG_EASRC_DBGC,\t0x00000000},\n\t{REG_EASRC_DBGS,\t0x00000000},\n};\n\nstatic const struct regmap_range fsl_easrc_readable_ranges[] = {\n\tregmap_reg_range(REG_EASRC_RDFIFO(0), REG_EASRC_RCTCH),\n\tregmap_reg_range(REG_EASRC_PCF(0), REG_EASRC_PCF(3)),\n\tregmap_reg_range(REG_EASRC_CRCC, REG_EASRC_DBGS),\n};\n\nstatic const struct regmap_access_table fsl_easrc_readable_table = {\n\t.yes_ranges = fsl_easrc_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(fsl_easrc_readable_ranges),\n};\n\nstatic const struct regmap_range fsl_easrc_writeable_ranges[] = {\n\tregmap_reg_range(REG_EASRC_WRFIFO(0), REG_EASRC_WRFIFO(3)),\n\tregmap_reg_range(REG_EASRC_CC(0), REG_EASRC_COA(3)),\n\tregmap_reg_range(REG_EASRC_RRL(0), REG_EASRC_RCTCH),\n\tregmap_reg_range(REG_EASRC_PCF(0), REG_EASRC_DBGC),\n};\n\nstatic const struct regmap_access_table fsl_easrc_writeable_table = {\n\t.yes_ranges = fsl_easrc_writeable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(fsl_easrc_writeable_ranges),\n};\n\nstatic const struct regmap_range fsl_easrc_volatileable_ranges[] = {\n\tregmap_reg_range(REG_EASRC_RDFIFO(0), REG_EASRC_RDFIFO(3)),\n\tregmap_reg_range(REG_EASRC_SFS(0), REG_EASRC_SFS(3)),\n\tregmap_reg_range(REG_EASRC_IRQF, REG_EASRC_IRQF),\n\tregmap_reg_range(REG_EASRC_DBGS, REG_EASRC_DBGS),\n};\n\nstatic const struct regmap_access_table fsl_easrc_volatileable_table = {\n\t.yes_ranges = fsl_easrc_volatileable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(fsl_easrc_volatileable_ranges),\n};\n\nstatic const struct regmap_config fsl_easrc_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = REG_EASRC_DBGS,\n\t.reg_defaults = fsl_easrc_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_easrc_reg_defaults),\n\t.rd_table = &fsl_easrc_readable_table,\n\t.wr_table = &fsl_easrc_writeable_table,\n\t.volatile_table = &fsl_easrc_volatileable_table,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n#ifdef DEBUG\nstatic void fsl_easrc_dump_firmware(struct fsl_asrc *easrc)\n{\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct asrc_firmware_hdr *firm = easrc_priv->firmware_hdr;\n\tstruct interp_params *interp = easrc_priv->interp;\n\tstruct prefil_params *prefil = easrc_priv->prefil;\n\tstruct device *dev = &easrc->pdev->dev;\n\tint i;\n\n\tif (firm->magic != FIRMWARE_MAGIC) {\n\t\tdev_err(dev, \"Wrong magic. Something went wrong!\");\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"Firmware v%u dump:\\n\", firm->firmware_version);\n\tdev_dbg(dev, \"Num prefilter scenarios: %u\\n\", firm->prefil_scen);\n\tdev_dbg(dev, \"Num interpolation scenarios: %u\\n\", firm->interp_scen);\n\tdev_dbg(dev, \"\\nInterpolation scenarios:\\n\");\n\n\tfor (i = 0; i < firm->interp_scen; i++) {\n\t\tif (interp[i].magic != FIRMWARE_MAGIC) {\n\t\t\tdev_dbg(dev, \"%d. wrong interp magic: %x\\n\",\n\t\t\t\ti, interp[i].magic);\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(dev, \"%d. taps: %u, phases: %u, center: %llu\\n\", i,\n\t\t\tinterp[i].num_taps, interp[i].num_phases,\n\t\t\tinterp[i].center_tap);\n\t}\n\n\tfor (i = 0; i < firm->prefil_scen; i++) {\n\t\tif (prefil[i].magic != FIRMWARE_MAGIC) {\n\t\t\tdev_dbg(dev, \"%d. wrong prefil magic: %x\\n\",\n\t\t\t\ti, prefil[i].magic);\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(dev, \"%d. insr: %u, outsr: %u, st1: %u, st2: %u\\n\", i,\n\t\t\tprefil[i].insr, prefil[i].outsr,\n\t\t\tprefil[i].st1_taps, prefil[i].st2_taps);\n\t}\n\n\tdev_dbg(dev, \"end of firmware dump\\n\");\n}\n#endif\n\nstatic int fsl_easrc_get_firmware(struct fsl_asrc *easrc)\n{\n\tstruct fsl_easrc_priv *easrc_priv;\n\tconst struct firmware **fw_p;\n\tu32 pnum, inum, offset;\n\tconst u8 *data;\n\tint ret;\n\n\tif (!easrc)\n\t\treturn -EINVAL;\n\n\teasrc_priv = easrc->private;\n\tfw_p = &easrc_priv->fw;\n\n\tret = request_firmware(fw_p, easrc_priv->fw_name, &easrc->pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = easrc_priv->fw->data;\n\n\teasrc_priv->firmware_hdr = (struct asrc_firmware_hdr *)data;\n\tpnum = easrc_priv->firmware_hdr->prefil_scen;\n\tinum = easrc_priv->firmware_hdr->interp_scen;\n\n\tif (inum) {\n\t\toffset = sizeof(struct asrc_firmware_hdr);\n\t\teasrc_priv->interp = (struct interp_params *)(data + offset);\n\t}\n\n\tif (pnum) {\n\t\toffset = sizeof(struct asrc_firmware_hdr) +\n\t\t\t\tinum * sizeof(struct interp_params);\n\t\teasrc_priv->prefil = (struct prefil_params *)(data + offset);\n\t}\n\n#ifdef DEBUG\n\tfsl_easrc_dump_firmware(easrc);\n#endif\n\n\treturn 0;\n}\n\nstatic irqreturn_t fsl_easrc_isr(int irq, void *dev_id)\n{\n\tstruct fsl_asrc *easrc = (struct fsl_asrc *)dev_id;\n\tstruct device *dev = &easrc->pdev->dev;\n\tint val;\n\n\tregmap_read(easrc->regmap, REG_EASRC_IRQF, &val);\n\n\tif (val & EASRC_IRQF_OER_MASK)\n\t\tdev_dbg(dev, \"output FIFO underflow\\n\");\n\n\tif (val & EASRC_IRQF_IFO_MASK)\n\t\tdev_dbg(dev, \"input FIFO overflow\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsl_easrc_get_fifo_addr(u8 dir, enum asrc_pair_index index)\n{\n\treturn REG_EASRC_FIFO(dir, index);\n}\n\nstatic const struct of_device_id fsl_easrc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8mn-easrc\",},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_easrc_dt_ids);\n\nstatic int fsl_easrc_probe(struct platform_device *pdev)\n{\n\tstruct fsl_easrc_priv *easrc_priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct fsl_asrc *easrc;\n\tstruct resource *res;\n\tstruct device_node *np;\n\tvoid __iomem *regs;\n\tu32 asrc_fmt = 0;\n\tint ret, irq;\n\n\teasrc = devm_kzalloc(dev, sizeof(*easrc), GFP_KERNEL);\n\tif (!easrc)\n\t\treturn -ENOMEM;\n\n\teasrc_priv = devm_kzalloc(dev, sizeof(*easrc_priv), GFP_KERNEL);\n\tif (!easrc_priv)\n\t\treturn -ENOMEM;\n\n\teasrc->pdev = pdev;\n\teasrc->private = easrc_priv;\n\tnp = dev->of_node;\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\teasrc->paddr = res->start;\n\n\teasrc->regmap = devm_regmap_init_mmio(dev, regs, &fsl_easrc_regmap_config);\n\tif (IS_ERR(easrc->regmap)) {\n\t\tdev_err(dev, \"failed to init regmap\");\n\t\treturn PTR_ERR(easrc->regmap);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_easrc_isr, 0,\n\t\t\t       dev_name(dev), easrc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to claim irq %u: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\teasrc->mem_clk = devm_clk_get(dev, \"mem\");\n\tif (IS_ERR(easrc->mem_clk)) {\n\t\tdev_err(dev, \"failed to get mem clock\\n\");\n\t\treturn PTR_ERR(easrc->mem_clk);\n\t}\n\n\t \n\teasrc->channel_avail = 32;\n\teasrc->get_dma_channel = fsl_easrc_get_dma_channel;\n\teasrc->request_pair = fsl_easrc_request_context;\n\teasrc->release_pair = fsl_easrc_release_context;\n\teasrc->get_fifo_addr = fsl_easrc_get_fifo_addr;\n\teasrc->pair_priv_size = sizeof(struct fsl_easrc_ctx_priv);\n\n\teasrc_priv->rs_num_taps = EASRC_RS_32_TAPS;\n\teasrc_priv->const_coeff = 0x3FF0000000000000;\n\n\tret = of_property_read_u32(np, \"fsl,asrc-rate\", &easrc->asrc_rate);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to asrc rate\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"fsl,asrc-format\", &asrc_fmt);\n\teasrc->asrc_format = (__force snd_pcm_format_t)asrc_fmt;\n\tif (ret) {\n\t\tdev_err(dev, \"failed to asrc format\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!(FSL_EASRC_FORMATS & (pcm_format_to_bits(easrc->asrc_format)))) {\n\t\tdev_warn(dev, \"unsupported format, switching to S24_LE\\n\");\n\t\teasrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t}\n\n\tret = of_property_read_string(np, \"firmware-name\",\n\t\t\t\t      &easrc_priv->fw_name);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get firmware name\\n\");\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, easrc);\n\tpm_runtime_enable(dev);\n\n\tspin_lock_init(&easrc->lock);\n\n\tregcache_cache_only(easrc->regmap, true);\n\n\tret = devm_snd_soc_register_component(dev, &fsl_easrc_component,\n\t\t\t\t\t      &fsl_easrc_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register ASoC DAI\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &fsl_asrc_component,\n\t\t\t\t\t      NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register ASoC platform\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\treturn 0;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void fsl_easrc_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic __maybe_unused int fsl_easrc_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_asrc *easrc = dev_get_drvdata(dev);\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tunsigned long lock_flags;\n\n\tregcache_cache_only(easrc->regmap, true);\n\n\tclk_disable_unprepare(easrc->mem_clk);\n\n\tspin_lock_irqsave(&easrc->lock, lock_flags);\n\teasrc_priv->firmware_loaded = 0;\n\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int fsl_easrc_runtime_resume(struct device *dev)\n{\n\tstruct fsl_asrc *easrc = dev_get_drvdata(dev);\n\tstruct fsl_easrc_priv *easrc_priv = easrc->private;\n\tstruct fsl_easrc_ctx_priv *ctx_priv;\n\tstruct fsl_asrc_pair *ctx;\n\tunsigned long lock_flags;\n\tint ret;\n\tint i;\n\n\tret = clk_prepare_enable(easrc->mem_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(easrc->regmap, false);\n\tregcache_mark_dirty(easrc->regmap);\n\tregcache_sync(easrc->regmap);\n\n\tspin_lock_irqsave(&easrc->lock, lock_flags);\n\tif (easrc_priv->firmware_loaded) {\n\t\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n\t\tgoto skip_load;\n\t}\n\teasrc_priv->firmware_loaded = 1;\n\tspin_unlock_irqrestore(&easrc->lock, lock_flags);\n\n\tret = fsl_easrc_get_firmware(easrc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get firmware\\n\");\n\t\tgoto disable_mem_clk;\n\t}\n\n\t \n\tret = fsl_easrc_resampler_config(easrc);\n\tif (ret) {\n\t\tdev_err(dev, \"resampler config failed\\n\");\n\t\tgoto disable_mem_clk;\n\t}\n\n\tfor (i = ASRC_PAIR_A; i < EASRC_CTX_MAX_NUM; i++) {\n\t\tctx = easrc->pair[i];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tctx_priv = ctx->private;\n\t\tfsl_easrc_set_rs_ratio(ctx);\n\t\tctx_priv->out_missed_sample = ctx_priv->in_filled_sample *\n\t\t\t\t\t      ctx_priv->out_params.sample_rate /\n\t\t\t\t\t      ctx_priv->in_params.sample_rate;\n\t\tif (ctx_priv->in_filled_sample * ctx_priv->out_params.sample_rate\n\t\t    % ctx_priv->in_params.sample_rate != 0)\n\t\t\tctx_priv->out_missed_sample += 1;\n\n\t\tret = fsl_easrc_write_pf_coeff_mem(easrc, i,\n\t\t\t\t\t\t   ctx_priv->st1_coeff,\n\t\t\t\t\t\t   ctx_priv->st1_num_taps,\n\t\t\t\t\t\t   ctx_priv->st1_addexp);\n\t\tif (ret)\n\t\t\tgoto disable_mem_clk;\n\n\t\tret = fsl_easrc_write_pf_coeff_mem(easrc, i,\n\t\t\t\t\t\t   ctx_priv->st2_coeff,\n\t\t\t\t\t\t   ctx_priv->st2_num_taps,\n\t\t\t\t\t\t   ctx_priv->st2_addexp);\n\t\tif (ret)\n\t\t\tgoto disable_mem_clk;\n\t}\n\nskip_load:\n\treturn 0;\n\ndisable_mem_clk:\n\tclk_disable_unprepare(easrc->mem_clk);\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops fsl_easrc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_easrc_runtime_suspend,\n\t\t\t   fsl_easrc_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_easrc_driver = {\n\t.probe = fsl_easrc_probe,\n\t.remove_new = fsl_easrc_remove,\n\t.driver = {\n\t\t.name = \"fsl-easrc\",\n\t\t.pm = &fsl_easrc_pm_ops,\n\t\t.of_match_table = fsl_easrc_dt_ids,\n\t},\n};\nmodule_platform_driver(fsl_easrc_driver);\n\nMODULE_DESCRIPTION(\"NXP Enhanced Asynchronous Sample Rate (eASRC) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}