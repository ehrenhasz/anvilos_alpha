{
  "module_name": "eukrea-tlv320.c",
  "hash_id": "a52d9a090370aedbbd1d76bda92b1bd563001004012ca515af8dec17a0d07916",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/eukrea-tlv320.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <asm/mach-types.h>\n\n#include \"../codecs/tlv320aic23.h\"\n#include \"imx-ssi.h\"\n#include \"imx-audmux.h\"\n\n#define CODEC_CLOCK 12000000\n\nstatic int eukrea_tlv320_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret;\n\n\tret = snd_soc_dai_set_sysclk(codec_dai, 0,\n\t\t\t\t     CODEC_CLOCK, SND_SOC_CLOCK_OUT);\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev,\n\t\t\t\"Failed to set the codec sysclk.\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, 0);\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0,\n\t\t\t\tSND_SOC_CLOCK_IN);\n\t \n\tif (ret && ret != -EINVAL) {\n\t\tdev_err(cpu_dai->dev,\n\t\t\t\"Can't set the IMX_SSP_SYS_CLK CPU system clock.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops eukrea_tlv320_snd_ops = {\n\t.hw_params\t= eukrea_tlv320_hw_params,\n};\n\nSND_SOC_DAILINK_DEFS(hifi,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"tlv320aic23-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link eukrea_tlv320_dai = {\n\t.name\t\t= \"tlv320aic23\",\n\t.stream_name\t= \"TLV320AIC23\",\n\t.dai_fmt\t= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t  SND_SOC_DAIFMT_CBP_CFP,\n\t.ops\t\t= &eukrea_tlv320_snd_ops,\n\tSND_SOC_DAILINK_REG(hifi),\n};\n\nstatic struct snd_soc_card eukrea_tlv320 = {\n\t.owner\t\t= THIS_MODULE,\n\t.dai_link\t= &eukrea_tlv320_dai,\n\t.num_links\t= 1,\n};\n\nstatic int eukrea_tlv320_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tint int_port = 0, ext_port;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ssi_np = NULL, *codec_np = NULL, *tmp_np = NULL;\n\n\teukrea_tlv320.dev = &pdev->dev;\n\tif (np) {\n\t\tret = snd_soc_of_parse_card_name(&eukrea_tlv320,\n\t\t\t\t\t\t \"eukrea,model\");\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"eukrea,model node missing or invalid.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tssi_np = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t\t  \"ssi-controller\", 0);\n\t\tif (!ssi_np) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"ssi-controller missing or invalid.\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcodec_np = of_parse_phandle(ssi_np, \"codec-handle\", 0);\n\t\tif (codec_np)\n\t\t\teukrea_tlv320_dai.codecs->of_node = codec_np;\n\t\telse\n\t\t\tdev_err(&pdev->dev, \"codec-handle node missing or invalid.\\n\");\n\n\t\tret = of_property_read_u32(np, \"fsl,mux-int-port\", &int_port);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"fsl,mux-int-port node missing or invalid.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tret = of_property_read_u32(np, \"fsl,mux-ext-port\", &ext_port);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"fsl,mux-ext-port node missing or invalid.\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tint_port--;\n\t\text_port--;\n\n\t\teukrea_tlv320_dai.cpus->of_node = ssi_np;\n\t\teukrea_tlv320_dai.platforms->of_node = ssi_np;\n\t} else {\n\t\teukrea_tlv320_dai.cpus->dai_name = \"imx-ssi.0\";\n\t\teukrea_tlv320_dai.platforms->name = \"imx-ssi.0\";\n\t\teukrea_tlv320_dai.codecs->name = \"tlv320aic23-codec.0-001a\";\n\t\teukrea_tlv320.name = \"cpuimx-audio\";\n\t}\n\n\tif (machine_is_eukrea_cpuimx27() ||\n\t    (tmp_np = of_find_compatible_node(NULL, NULL, \"fsl,imx21-audmux\"))) {\n\t\timx_audmux_v1_configure_port(MX27_AUDMUX_HPCR1_SSI0,\n\t\t\tIMX_AUDMUX_V1_PCR_SYN |\n\t\t\tIMX_AUDMUX_V1_PCR_TFSDIR |\n\t\t\tIMX_AUDMUX_V1_PCR_TCLKDIR |\n\t\t\tIMX_AUDMUX_V1_PCR_RFSDIR |\n\t\t\tIMX_AUDMUX_V1_PCR_RCLKDIR |\n\t\t\tIMX_AUDMUX_V1_PCR_TFCSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4) |\n\t\t\tIMX_AUDMUX_V1_PCR_RFCSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4) |\n\t\t\tIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_HPCR3_SSI_PINS_4)\n\t\t);\n\t\timx_audmux_v1_configure_port(MX27_AUDMUX_HPCR3_SSI_PINS_4,\n\t\t\tIMX_AUDMUX_V1_PCR_SYN |\n\t\t\tIMX_AUDMUX_V1_PCR_RXDSEL(MX27_AUDMUX_HPCR1_SSI0)\n\t\t);\n\t\tof_node_put(tmp_np);\n\t} else if (machine_is_eukrea_cpuimx25sd() ||\n\t\t   machine_is_eukrea_cpuimx35sd() ||\n\t\t   machine_is_eukrea_cpuimx51sd() ||\n\t\t   (tmp_np = of_find_compatible_node(NULL, NULL, \"fsl,imx31-audmux\"))) {\n\t\tif (!np)\n\t\t\text_port = machine_is_eukrea_cpuimx25sd() ?\n\t\t\t\t4 : 3;\n\n\t\timx_audmux_v2_configure_port(int_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSDIR |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCLKDIR |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCSEL(ext_port),\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port)\n\t\t);\n\t\timx_audmux_v2_configure_port(ext_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN,\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(int_port)\n\t\t);\n\t\tof_node_put(tmp_np);\n\t} else {\n\t\tif (np) {\n\t\t\t \n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Missing or invalid audmux DT node.\\n\");\n\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = snd_soc_register_card(&eukrea_tlv320);\nerr:\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"snd_soc_register_card failed (%d)\\n\", ret);\n\tof_node_put(ssi_np);\n\n\treturn ret;\n}\n\nstatic void eukrea_tlv320_remove(struct platform_device *pdev)\n{\n\tsnd_soc_unregister_card(&eukrea_tlv320);\n}\n\nstatic const struct of_device_id imx_tlv320_dt_ids[] = {\n\t{ .compatible = \"eukrea,asoc-tlv320\"},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_tlv320_dt_ids);\n\nstatic struct platform_driver eukrea_tlv320_driver = {\n\t.driver = {\n\t\t.name = \"eukrea_tlv320\",\n\t\t.of_match_table = imx_tlv320_dt_ids,\n\t},\n\t.probe = eukrea_tlv320_probe,\n\t.remove_new = eukrea_tlv320_remove,\n};\n\nmodule_platform_driver(eukrea_tlv320_driver);\n\nMODULE_AUTHOR(\"Eric B\u00e9nard <eric@eukrea.com>\");\nMODULE_DESCRIPTION(\"CPUIMX ALSA SoC driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:eukrea_tlv320\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}