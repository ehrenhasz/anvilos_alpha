{
  "module_name": "imx-sgtl5000.c",
  "hash_id": "26a1d78b0c20d770b924f8000f6a4d640f1bf994e9fd41dd64b447352b7cdfca",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-sgtl5000.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <sound/soc.h>\n\n#include \"../codecs/sgtl5000.h\"\n#include \"imx-audmux.h\"\n\n#define DAI_NAME_SIZE\t32\n\nstruct imx_sgtl5000_data {\n\tstruct snd_soc_dai_link dai;\n\tstruct snd_soc_card card;\n\tchar codec_dai_name[DAI_NAME_SIZE];\n\tchar platform_name[DAI_NAME_SIZE];\n\tstruct clk *codec_clk;\n\tunsigned int clk_frequency;\n};\n\nstatic int imx_sgtl5000_dai_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct imx_sgtl5000_data *data = snd_soc_card_get_drvdata(rtd->card);\n\tstruct device *dev = rtd->card->dev;\n\tint ret;\n\n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0), SGTL5000_SYSCLK,\n\t\t\t\t     data->clk_frequency, SND_SOC_CLOCK_IN);\n\tif (ret) {\n\t\tdev_err(dev, \"could not set codec driver clock params\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget imx_sgtl5000_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In Jack\", NULL),\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Line Out Jack\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n};\n\nstatic int imx_sgtl5000_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ssi_np, *codec_np;\n\tstruct platform_device *ssi_pdev;\n\tstruct i2c_client *codec_dev;\n\tstruct imx_sgtl5000_data *data = NULL;\n\tstruct snd_soc_dai_link_component *comp;\n\tint int_port, ext_port;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"mux-int-port\", &int_port);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"mux-int-port missing or invalid\\n\");\n\t\treturn ret;\n\t}\n\tret = of_property_read_u32(np, \"mux-ext-port\", &ext_port);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"mux-ext-port missing or invalid\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tint_port--;\n\text_port--;\n\tret = imx_audmux_v2_configure_port(int_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\n\t\t\tIMX_AUDMUX_V2_PTCR_TFSDIR |\n\t\t\tIMX_AUDMUX_V2_PTCR_TCLKDIR,\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"audmux internal port setup failed\\n\");\n\t\treturn ret;\n\t}\n\tret = imx_audmux_v2_configure_port(ext_port,\n\t\t\tIMX_AUDMUX_V2_PTCR_SYN,\n\t\t\tIMX_AUDMUX_V2_PDCR_RXDSEL(int_port));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"audmux external port setup failed\\n\");\n\t\treturn ret;\n\t}\n\n\tssi_np = of_parse_phandle(pdev->dev.of_node, \"ssi-controller\", 0);\n\tcodec_np = of_parse_phandle(pdev->dev.of_node, \"audio-codec\", 0);\n\tif (!ssi_np || !codec_np) {\n\t\tdev_err(&pdev->dev, \"phandle missing or invalid\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tssi_pdev = of_find_device_by_node(ssi_np);\n\tif (!ssi_pdev) {\n\t\tdev_dbg(&pdev->dev, \"failed to find SSI platform device\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto fail;\n\t}\n\tput_device(&ssi_pdev->dev);\n\tcodec_dev = of_find_i2c_device_by_node(codec_np);\n\tif (!codec_dev) {\n\t\tdev_dbg(&pdev->dev, \"failed to find codec platform device\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto fail;\n\t}\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tcomp = devm_kzalloc(&pdev->dev, 3 * sizeof(*comp), GFP_KERNEL);\n\tif (!comp) {\n\t\tret = -ENOMEM;\n\t\tgoto put_device;\n\t}\n\n\tdata->codec_clk = clk_get(&codec_dev->dev, NULL);\n\tif (IS_ERR(data->codec_clk)) {\n\t\tret = PTR_ERR(data->codec_clk);\n\t\tgoto put_device;\n\t}\n\n\tdata->clk_frequency = clk_get_rate(data->codec_clk);\n\n\tdata->dai.cpus\t\t= &comp[0];\n\tdata->dai.codecs\t= &comp[1];\n\tdata->dai.platforms\t= &comp[2];\n\n\tdata->dai.num_cpus\t= 1;\n\tdata->dai.num_codecs\t= 1;\n\tdata->dai.num_platforms\t= 1;\n\n\tdata->dai.name = \"HiFi\";\n\tdata->dai.stream_name = \"HiFi\";\n\tdata->dai.codecs->dai_name = \"sgtl5000\";\n\tdata->dai.codecs->of_node = codec_np;\n\tdata->dai.cpus->of_node = ssi_np;\n\tdata->dai.platforms->of_node = ssi_np;\n\tdata->dai.init = &imx_sgtl5000_dai_init;\n\tdata->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t\t    SND_SOC_DAIFMT_CBP_CFP;\n\n\tdata->card.dev = &pdev->dev;\n\tret = snd_soc_of_parse_card_name(&data->card, \"model\");\n\tif (ret)\n\t\tgoto put_device;\n\tret = snd_soc_of_parse_audio_routing(&data->card, \"audio-routing\");\n\tif (ret)\n\t\tgoto put_device;\n\tdata->card.num_links = 1;\n\tdata->card.owner = THIS_MODULE;\n\tdata->card.dai_link = &data->dai;\n\tdata->card.dapm_widgets = imx_sgtl5000_dapm_widgets;\n\tdata->card.num_dapm_widgets = ARRAY_SIZE(imx_sgtl5000_dapm_widgets);\n\n\tplatform_set_drvdata(pdev, &data->card);\n\tsnd_soc_card_set_drvdata(&data->card, data);\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &data->card);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"snd_soc_register_card failed\\n\");\n\t\tgoto put_device;\n\t}\n\n\tof_node_put(ssi_np);\n\tof_node_put(codec_np);\n\n\treturn 0;\n\nput_device:\n\tput_device(&codec_dev->dev);\nfail:\n\tif (data && !IS_ERR(data->codec_clk))\n\t\tclk_put(data->codec_clk);\n\tof_node_put(ssi_np);\n\tof_node_put(codec_np);\n\n\treturn ret;\n}\n\nstatic void imx_sgtl5000_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct imx_sgtl5000_data *data = snd_soc_card_get_drvdata(card);\n\n\tclk_put(data->codec_clk);\n}\n\nstatic const struct of_device_id imx_sgtl5000_dt_ids[] = {\n\t{ .compatible = \"fsl,imx-audio-sgtl5000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_sgtl5000_dt_ids);\n\nstatic struct platform_driver imx_sgtl5000_driver = {\n\t.driver = {\n\t\t.name = \"imx-sgtl5000\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = imx_sgtl5000_dt_ids,\n\t},\n\t.probe = imx_sgtl5000_probe,\n\t.remove_new = imx_sgtl5000_remove,\n};\nmodule_platform_driver(imx_sgtl5000_driver);\n\nMODULE_AUTHOR(\"Shawn Guo <shawn.guo@linaro.org>\");\nMODULE_DESCRIPTION(\"Freescale i.MX SGTL5000 ASoC machine driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:imx-sgtl5000\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}