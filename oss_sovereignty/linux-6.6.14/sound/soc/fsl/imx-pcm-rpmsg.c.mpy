{
  "module_name": "imx-pcm-rpmsg.c",
  "hash_id": "271bb95f0eb7139be06f4116fc67d4b2a076fc29128c5086d7bf80bbbade3b4a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-pcm-rpmsg.c",
  "human_readable_source": "\n\n\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/rpmsg.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/soc.h>\n\n#include \"imx-pcm.h\"\n#include \"fsl_rpmsg.h\"\n#include \"imx-pcm-rpmsg.h\"\n\nstatic struct snd_pcm_hardware imx_rpmsg_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_NO_PERIOD_WAKEUP |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_RESUME,\n\t.buffer_bytes_max = IMX_DEFAULT_DMABUF_SIZE,\n\t.period_bytes_min = 512,\n\t.period_bytes_max = 65536,\n\t.periods_min = 2,\n\t.periods_max = 6000,\n\t.fifo_size = 0,\n};\n\nstatic int imx_rpmsg_pcm_send_message(struct rpmsg_msg *msg,\n\t\t\t\t      struct rpmsg_info *info)\n{\n\tstruct rpmsg_device *rpdev = info->rpdev;\n\tint ret = 0;\n\n\tmutex_lock(&info->msg_lock);\n\tif (!rpdev) {\n\t\tdev_err(info->dev, \"rpmsg channel not ready\\n\");\n\t\tmutex_unlock(&info->msg_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&rpdev->dev, \"send cmd %d\\n\", msg->s_msg.header.cmd);\n\n\tif (!(msg->s_msg.header.type == MSG_TYPE_C))\n\t\treinit_completion(&info->cmd_complete);\n\n\tret = rpmsg_send(rpdev->ept, (void *)&msg->s_msg,\n\t\t\t sizeof(struct rpmsg_s_msg));\n\tif (ret) {\n\t\tdev_err(&rpdev->dev, \"rpmsg_send failed: %d\\n\", ret);\n\t\tmutex_unlock(&info->msg_lock);\n\t\treturn ret;\n\t}\n\n\t \n\tif (msg->s_msg.header.type == MSG_TYPE_C) {\n\t\tmutex_unlock(&info->msg_lock);\n\t\treturn 0;\n\t}\n\n\t \n\tret = wait_for_completion_timeout(&info->cmd_complete,\n\t\t\t\t\t  msecs_to_jiffies(RPMSG_TIMEOUT));\n\tif (!ret) {\n\t\tdev_err(&rpdev->dev, \"rpmsg_send cmd %d timeout!\\n\",\n\t\t\tmsg->s_msg.header.cmd);\n\t\tmutex_unlock(&info->msg_lock);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmemcpy(&msg->r_msg, &info->r_msg, sizeof(struct rpmsg_r_msg));\n\tmemcpy(&info->msg[msg->r_msg.header.cmd].r_msg,\n\t       &msg->r_msg, sizeof(struct rpmsg_r_msg));\n\n\t \n\tswitch (msg->s_msg.header.cmd) {\n\tcase TX_TERMINATE:\n\t\tinfo->msg[TX_POINTER].r_msg.param.buffer_offset = 0;\n\t\tbreak;\n\tcase RX_TERMINATE:\n\t\tinfo->msg[RX_POINTER].r_msg.param.buffer_offset = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_dbg(&rpdev->dev, \"cmd:%d, resp %d\\n\", msg->s_msg.header.cmd,\n\t\tinfo->r_msg.param.resp);\n\n\tmutex_unlock(&info->msg_lock);\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_insert_workqueue(struct snd_pcm_substream *substream,\n\t\t\t\t      struct rpmsg_msg *msg,\n\t\t\t\t      struct rpmsg_info *info)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tspin_lock_irqsave(&info->wq_lock, flags);\n\tif (info->work_write_index != info->work_read_index) {\n\t\tint index = info->work_write_index;\n\n\t\tmemcpy(&info->work_list[index].msg, msg,\n\t\t       sizeof(struct rpmsg_s_msg));\n\n\t\tqueue_work(info->rpmsg_wq, &info->work_list[index].work);\n\t\tinfo->work_write_index++;\n\t\tinfo->work_write_index %= WORK_MAX_NUM;\n\t} else {\n\t\tinfo->msg_drop_count[substream->stream]++;\n\t\tret = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&info->wq_lock, flags);\n\n\treturn ret;\n}\n\nstatic int imx_rpmsg_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_HW_PARAM];\n\t\tmsg->s_msg.header.cmd = TX_HW_PARAM;\n\t} else {\n\t\tmsg = &info->msg[RX_HW_PARAM];\n\t\tmsg->s_msg.header.cmd = RX_HW_PARAM;\n\t}\n\n\tmsg->s_msg.param.rate = params_rate(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tmsg->s_msg.param.format   = RPMSG_S16_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tmsg->s_msg.param.format   = RPMSG_S24_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_DSD_U16_LE:\n\t\tmsg->s_msg.param.format   = RPMSG_DSD_U16_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_DSD_U32_LE:\n\t\tmsg->s_msg.param.format   = RPMSG_DSD_U32_LE;\n\t\tbreak;\n\tdefault:\n\t\tmsg->s_msg.param.format   = RPMSG_S32_LE;\n\t\tbreak;\n\t}\n\n\tswitch (params_channels(params)) {\n\tcase 1:\n\t\tmsg->s_msg.param.channels = RPMSG_CH_LEFT;\n\t\tbreak;\n\tcase 2:\n\t\tmsg->s_msg.param.channels = RPMSG_CH_STEREO;\n\t\tbreak;\n\tdefault:\n\t\tmsg->s_msg.param.channels = params_channels(params);\n\t\tbreak;\n\t}\n\n\tinfo->send_message(msg, info);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t imx_rpmsg_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\tunsigned int pos = 0;\n\tint buffer_tail = 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmsg = &info->msg[TX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\telse\n\t\tmsg = &info->msg[RX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\n\tbuffer_tail = msg->r_msg.param.buffer_tail;\n\tpos = buffer_tail * snd_pcm_lib_period_bytes(substream);\n\n\treturn bytes_to_frames(substream->runtime, pos);\n}\n\nstatic void imx_rpmsg_timer_callback(struct timer_list *t)\n{\n\tstruct stream_timer  *stream_timer =\n\t\t\tfrom_timer(stream_timer, t, timer);\n\tstruct snd_pcm_substream *substream = stream_timer->substream;\n\tstruct rpmsg_info *info = stream_timer->info;\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\t\tmsg->s_msg.header.cmd = TX_PERIOD_DONE;\n\t} else {\n\t\tmsg = &info->msg[RX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\t\tmsg->s_msg.header.cmd = RX_PERIOD_DONE;\n\t}\n\n\timx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_pcm_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);\n\tstruct snd_pcm_hardware pcm_hardware;\n\tstruct rpmsg_msg *msg;\n\tint ret = 0;\n\tint cmd;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_OPEN];\n\t\tmsg->s_msg.header.cmd = TX_OPEN;\n\n\t\t \n\t\tcmd = TX_PERIOD_DONE + MSG_TYPE_A_NUM;\n\t\tinfo->msg[cmd].s_msg.param.buffer_tail = 0;\n\t\tinfo->msg[cmd].r_msg.param.buffer_tail = 0;\n\t\tinfo->msg[TX_POINTER].r_msg.param.buffer_offset = 0;\n\n\t} else {\n\t\tmsg = &info->msg[RX_OPEN];\n\t\tmsg->s_msg.header.cmd = RX_OPEN;\n\n\t\t \n\t\tcmd = RX_PERIOD_DONE + MSG_TYPE_A_NUM;\n\t\tinfo->msg[cmd].s_msg.param.buffer_tail = 0;\n\t\tinfo->msg[cmd].r_msg.param.buffer_tail = 0;\n\t\tinfo->msg[RX_POINTER].r_msg.param.buffer_offset = 0;\n\t}\n\n\tinfo->send_message(msg, info);\n\n\tpcm_hardware = imx_rpmsg_pcm_hardware;\n\tpcm_hardware.buffer_bytes_max = rpmsg->buffer_size;\n\tpcm_hardware.period_bytes_max = pcm_hardware.buffer_bytes_max / 2;\n\n\tsnd_soc_set_runtime_hwparams(substream, &pcm_hardware);\n\n\tret = snd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo->msg_drop_count[substream->stream] = 0;\n\n\t \n\tinfo->stream_timer[substream->stream].info = info;\n\tinfo->stream_timer[substream->stream].substream = substream;\n\ttimer_setup(&info->stream_timer[substream->stream].timer,\n\t\t    imx_rpmsg_timer_callback, 0);\n\treturn ret;\n}\n\nstatic int imx_rpmsg_pcm_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\t \n\tflush_workqueue(info->rpmsg_wq);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_CLOSE];\n\t\tmsg->s_msg.header.cmd = TX_CLOSE;\n\t} else {\n\t\tmsg = &info->msg[RX_CLOSE];\n\t\tmsg->s_msg.header.cmd = RX_CLOSE;\n\t}\n\n\tinfo->send_message(msg, info);\n\n\tdel_timer(&info->stream_timer[substream->stream].timer);\n\n\trtd->dai_link->ignore_suspend = 0;\n\n\tif (info->msg_drop_count[substream->stream])\n\t\tdev_warn(rtd->dev, \"Msg is dropped!, number is %d\\n\",\n\t\t\t info->msg_drop_count[substream->stream]);\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_pcm_prepare(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);\n\n\t \n\tif ((runtime->access == SNDRV_PCM_ACCESS_RW_INTERLEAVED ||\n\t     runtime->access == SNDRV_PCM_ACCESS_RW_NONINTERLEAVED) &&\n\t     rpmsg->enable_lpa) {\n\t\t \n\t\trtd->dai_link->ignore_suspend = 1;\n\t\trpmsg->force_lpa = 1;\n\t} else {\n\t\trpmsg->force_lpa = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_rpmsg_pcm_dma_complete(void *arg)\n{\n\tstruct snd_pcm_substream *substream = arg;\n\n\tsnd_pcm_period_elapsed(substream);\n}\n\nstatic int imx_rpmsg_prepare_and_submit(struct snd_soc_component *component,\n\t\t\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_BUFFER];\n\t\tmsg->s_msg.header.cmd = TX_BUFFER;\n\t} else {\n\t\tmsg = &info->msg[RX_BUFFER];\n\t\tmsg->s_msg.header.cmd = RX_BUFFER;\n\t}\n\n\t \n\tmsg->s_msg.param.buffer_addr = substream->runtime->dma_addr;\n\tmsg->s_msg.param.buffer_size = snd_pcm_lib_buffer_bytes(substream);\n\tmsg->s_msg.param.period_size = snd_pcm_lib_period_bytes(substream);\n\tmsg->s_msg.param.buffer_tail = 0;\n\n\tinfo->num_period[substream->stream] = msg->s_msg.param.buffer_size /\n\t\t\t\t\t      msg->s_msg.param.period_size;\n\n\tinfo->callback[substream->stream] = imx_rpmsg_pcm_dma_complete;\n\tinfo->callback_param[substream->stream] = substream;\n\n\treturn imx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_async_issue_pending(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_START];\n\t\tmsg->s_msg.header.cmd = TX_START;\n\t} else {\n\t\tmsg = &info->msg[RX_START];\n\t\tmsg->s_msg.header.cmd = RX_START;\n\t}\n\n\treturn imx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_restart(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_RESTART];\n\t\tmsg->s_msg.header.cmd = TX_RESTART;\n\t} else {\n\t\tmsg = &info->msg[RX_RESTART];\n\t\tmsg->s_msg.header.cmd = RX_RESTART;\n\t}\n\n\treturn imx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_pause(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_PAUSE];\n\t\tmsg->s_msg.header.cmd = TX_PAUSE;\n\t} else {\n\t\tmsg = &info->msg[RX_PAUSE];\n\t\tmsg->s_msg.header.cmd = RX_PAUSE;\n\t}\n\n\treturn imx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_terminate_all(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tstruct rpmsg_msg *msg;\n\tint cmd;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_TERMINATE];\n\t\tmsg->s_msg.header.cmd = TX_TERMINATE;\n\t\t \n\t\tcmd = TX_PERIOD_DONE + MSG_TYPE_A_NUM;\n\t\tinfo->msg[cmd].s_msg.param.buffer_tail = 0;\n\t\tinfo->msg[cmd].r_msg.param.buffer_tail = 0;\n\t\tinfo->msg[TX_POINTER].r_msg.param.buffer_offset = 0;\n\t} else {\n\t\tmsg = &info->msg[RX_TERMINATE];\n\t\tmsg->s_msg.header.cmd = RX_TERMINATE;\n\t\t \n\t\tcmd = RX_PERIOD_DONE + MSG_TYPE_A_NUM;\n\t\tinfo->msg[cmd].s_msg.param.buffer_tail = 0;\n\t\tinfo->msg[cmd].r_msg.param.buffer_tail = 0;\n\t\tinfo->msg[RX_POINTER].r_msg.param.buffer_offset = 0;\n\t}\n\n\tdel_timer(&info->stream_timer[substream->stream].timer);\n\n\treturn imx_rpmsg_insert_workqueue(substream, msg, info);\n}\n\nstatic int imx_rpmsg_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tret = imx_rpmsg_prepare_and_submit(component, substream);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = imx_rpmsg_async_issue_pending(component, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tif (rpmsg->force_lpa)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = imx_rpmsg_restart(component, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tif (!rpmsg->force_lpa) {\n\t\t\tif (runtime->info & SNDRV_PCM_INFO_PAUSE)\n\t\t\t\tret = imx_rpmsg_pause(component, substream);\n\t\t\telse\n\t\t\t\tret = imx_rpmsg_terminate_all(component, substream);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = imx_rpmsg_pause(component, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = imx_rpmsg_terminate_all(component, substream);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int imx_rpmsg_pcm_ack(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = substream->private_data;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);\n\tstruct rpmsg_info *info = dev_get_drvdata(component->dev);\n\tsnd_pcm_uframes_t period_size = runtime->period_size;\n\tsnd_pcm_sframes_t avail;\n\tstruct timer_list *timer;\n\tstruct rpmsg_msg *msg;\n\tunsigned long flags;\n\tint buffer_tail = 0;\n\tint written_num;\n\n\tif (!rpmsg->force_lpa)\n\t\treturn 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmsg = &info->msg[TX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\t\tmsg->s_msg.header.cmd = TX_PERIOD_DONE;\n\t} else {\n\t\tmsg = &info->msg[RX_PERIOD_DONE + MSG_TYPE_A_NUM];\n\t\tmsg->s_msg.header.cmd = RX_PERIOD_DONE;\n\t}\n\n\tmsg->s_msg.header.type = MSG_TYPE_C;\n\n\tbuffer_tail = (frames_to_bytes(runtime, runtime->control->appl_ptr) %\n\t\t       snd_pcm_lib_buffer_bytes(substream));\n\tbuffer_tail = buffer_tail / snd_pcm_lib_period_bytes(substream);\n\n\t \n\tif (buffer_tail != msg->s_msg.param.buffer_tail) {\n\t\twritten_num = buffer_tail - msg->s_msg.param.buffer_tail;\n\t\tif (written_num < 0)\n\t\t\twritten_num += runtime->periods;\n\n\t\tmsg->s_msg.param.buffer_tail = buffer_tail;\n\n\t\t \n\t\tspin_lock_irqsave(&info->lock[substream->stream], flags);\n\t\tmemcpy(&info->notify[substream->stream], msg,\n\t\t       sizeof(struct rpmsg_s_msg));\n\t\tinfo->notify_updated[substream->stream] = true;\n\t\tspin_unlock_irqrestore(&info->lock[substream->stream], flags);\n\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tavail = snd_pcm_playback_hw_avail(runtime);\n\t\telse\n\t\t\tavail = snd_pcm_capture_hw_avail(runtime);\n\n\t\ttimer = &info->stream_timer[substream->stream].timer;\n\t\t \n\t\tif ((avail - written_num * period_size) <= period_size) {\n\t\t\timx_rpmsg_insert_workqueue(substream, msg, info);\n\t\t} else if (rpmsg->force_lpa && !timer_pending(timer)) {\n\t\t\tint time_msec;\n\n\t\t\ttime_msec = (int)(runtime->period_size * 1000 / runtime->rate);\n\t\t\tmod_timer(timer, jiffies + msecs_to_jiffies(time_msec));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_pcm_new(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct fsl_rpmsg *rpmsg = dev_get_drvdata(cpu_dai->dev);\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC,\n\t\t\t\t\t    pcm->card->dev, rpmsg->buffer_size);\n}\n\nstatic const struct snd_soc_component_driver imx_rpmsg_soc_component = {\n\t.name\t\t= IMX_PCM_DRV_NAME,\n\t.pcm_construct\t= imx_rpmsg_pcm_new,\n\t.open\t\t= imx_rpmsg_pcm_open,\n\t.close\t\t= imx_rpmsg_pcm_close,\n\t.hw_params\t= imx_rpmsg_pcm_hw_params,\n\t.trigger\t= imx_rpmsg_pcm_trigger,\n\t.pointer\t= imx_rpmsg_pcm_pointer,\n\t.ack\t\t= imx_rpmsg_pcm_ack,\n\t.prepare\t= imx_rpmsg_pcm_prepare,\n};\n\nstatic void imx_rpmsg_pcm_work(struct work_struct *work)\n{\n\tstruct work_of_rpmsg *work_of_rpmsg;\n\tbool is_notification = false;\n\tstruct rpmsg_info *info;\n\tstruct rpmsg_msg msg;\n\tunsigned long flags;\n\n\twork_of_rpmsg = container_of(work, struct work_of_rpmsg, work);\n\tinfo = work_of_rpmsg->info;\n\n\t \n\tspin_lock_irqsave(&info->lock[TX], flags);\n\tif (info->notify_updated[TX]) {\n\t\tmemcpy(&msg, &info->notify[TX], sizeof(struct rpmsg_s_msg));\n\t\tinfo->notify_updated[TX] = false;\n\t\tspin_unlock_irqrestore(&info->lock[TX], flags);\n\t\tinfo->send_message(&msg, info);\n\t} else {\n\t\tspin_unlock_irqrestore(&info->lock[TX], flags);\n\t}\n\n\tspin_lock_irqsave(&info->lock[RX], flags);\n\tif (info->notify_updated[RX]) {\n\t\tmemcpy(&msg, &info->notify[RX], sizeof(struct rpmsg_s_msg));\n\t\tinfo->notify_updated[RX] = false;\n\t\tspin_unlock_irqrestore(&info->lock[RX], flags);\n\t\tinfo->send_message(&msg, info);\n\t} else {\n\t\tspin_unlock_irqrestore(&info->lock[RX], flags);\n\t}\n\n\t \n\tif (work_of_rpmsg->msg.s_msg.header.type == MSG_TYPE_C &&\n\t    (work_of_rpmsg->msg.s_msg.header.cmd == TX_PERIOD_DONE ||\n\t     work_of_rpmsg->msg.s_msg.header.cmd == RX_PERIOD_DONE))\n\t\tis_notification = true;\n\n\tif (!is_notification)\n\t\tinfo->send_message(&work_of_rpmsg->msg, info);\n\n\t \n\tspin_lock_irqsave(&info->wq_lock, flags);\n\tinfo->work_read_index++;\n\tinfo->work_read_index %= WORK_MAX_NUM;\n\tspin_unlock_irqrestore(&info->wq_lock, flags);\n}\n\nstatic int imx_rpmsg_pcm_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_component *component;\n\tstruct rpmsg_info *info;\n\tint ret, i;\n\n\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, info);\n\n\tinfo->rpdev = container_of(pdev->dev.parent, struct rpmsg_device, dev);\n\tinfo->dev = &pdev->dev;\n\t \n\tinfo->rpmsg_wq = alloc_ordered_workqueue(info->rpdev->id.name,\n\t\t\t\t\t\t WQ_HIGHPRI |\n\t\t\t\t\t\t WQ_UNBOUND |\n\t\t\t\t\t\t WQ_FREEZABLE);\n\tif (!info->rpmsg_wq) {\n\t\tdev_err(&pdev->dev, \"workqueue create failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tinfo->work_write_index = 1;\n\tinfo->send_message = imx_rpmsg_pcm_send_message;\n\n\tfor (i = 0; i < WORK_MAX_NUM; i++) {\n\t\tINIT_WORK(&info->work_list[i].work, imx_rpmsg_pcm_work);\n\t\tinfo->work_list[i].info = info;\n\t}\n\n\t \n\tfor (i = 0; i < MSG_MAX_NUM; i++) {\n\t\tinfo->msg[i].s_msg.header.cate  = IMX_RPMSG_AUDIO;\n\t\tinfo->msg[i].s_msg.header.major = IMX_RMPSG_MAJOR;\n\t\tinfo->msg[i].s_msg.header.minor = IMX_RMPSG_MINOR;\n\t\tinfo->msg[i].s_msg.header.type  = MSG_TYPE_A;\n\t\tinfo->msg[i].s_msg.param.audioindex = 0;\n\t}\n\n\tinit_completion(&info->cmd_complete);\n\tmutex_init(&info->msg_lock);\n\tspin_lock_init(&info->lock[TX]);\n\tspin_lock_init(&info->lock[RX]);\n\tspin_lock_init(&info->wq_lock);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &imx_rpmsg_soc_component,\n\t\t\t\t\t      NULL, 0);\n\tif (ret)\n\t\tgoto fail;\n\n\tcomponent = snd_soc_lookup_component(&pdev->dev, NULL);\n\tif (!component) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\t \n\tcomponent->name = info->rpdev->id.name;\n\n#ifdef CONFIG_DEBUG_FS\n\tcomponent->debugfs_prefix = \"rpmsg\";\n#endif\n\n\treturn 0;\n\nfail:\n\tif (info->rpmsg_wq)\n\t\tdestroy_workqueue(info->rpmsg_wq);\n\n\treturn ret;\n}\n\nstatic void imx_rpmsg_pcm_remove(struct platform_device *pdev)\n{\n\tstruct rpmsg_info *info = platform_get_drvdata(pdev);\n\n\tif (info->rpmsg_wq)\n\t\tdestroy_workqueue(info->rpmsg_wq);\n}\n\n#ifdef CONFIG_PM\nstatic int imx_rpmsg_pcm_runtime_resume(struct device *dev)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(dev);\n\n\tcpu_latency_qos_add_request(&info->pm_qos_req, 0);\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_pcm_runtime_suspend(struct device *dev)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(dev);\n\n\tcpu_latency_qos_remove_request(&info->pm_qos_req);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int imx_rpmsg_pcm_suspend(struct device *dev)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(dev);\n\tstruct rpmsg_msg *rpmsg_tx;\n\tstruct rpmsg_msg *rpmsg_rx;\n\n\trpmsg_tx = &info->msg[TX_SUSPEND];\n\trpmsg_rx = &info->msg[RX_SUSPEND];\n\n\trpmsg_tx->s_msg.header.cmd = TX_SUSPEND;\n\tinfo->send_message(rpmsg_tx, info);\n\n\trpmsg_rx->s_msg.header.cmd = RX_SUSPEND;\n\tinfo->send_message(rpmsg_rx, info);\n\n\treturn 0;\n}\n\nstatic int imx_rpmsg_pcm_resume(struct device *dev)\n{\n\tstruct rpmsg_info *info = dev_get_drvdata(dev);\n\tstruct rpmsg_msg *rpmsg_tx;\n\tstruct rpmsg_msg *rpmsg_rx;\n\n\trpmsg_tx = &info->msg[TX_RESUME];\n\trpmsg_rx = &info->msg[RX_RESUME];\n\n\trpmsg_tx->s_msg.header.cmd = TX_RESUME;\n\tinfo->send_message(rpmsg_tx, info);\n\n\trpmsg_rx->s_msg.header.cmd = RX_RESUME;\n\tinfo->send_message(rpmsg_rx, info);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops imx_rpmsg_pcm_pm_ops = {\n\tSET_RUNTIME_PM_OPS(imx_rpmsg_pcm_runtime_suspend,\n\t\t\t   imx_rpmsg_pcm_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(imx_rpmsg_pcm_suspend,\n\t\t\t\timx_rpmsg_pcm_resume)\n};\n\nstatic struct platform_driver imx_pcm_rpmsg_driver = {\n\t.probe  = imx_rpmsg_pcm_probe,\n\t.remove_new = imx_rpmsg_pcm_remove,\n\t.driver = {\n\t\t.name = IMX_PCM_DRV_NAME,\n\t\t.pm = &imx_rpmsg_pcm_pm_ops,\n\t},\n};\nmodule_platform_driver(imx_pcm_rpmsg_driver);\n\nMODULE_DESCRIPTION(\"Freescale SoC Audio RPMSG PCM interface\");\nMODULE_AUTHOR(\"Shengjiu Wang <shengjiu.wang@nxp.com>\");\nMODULE_ALIAS(\"platform:\" IMX_PCM_DRV_NAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}