{
  "module_name": "fsl_micfil.c",
  "hash_id": "8e9873c5431010fa2beb6a43c16adc9170f3a79ba907d4d9272bb9dd2e745546",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_micfil.c",
  "human_readable_source": "\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/dma/imx-dma.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/core.h>\n\n#include \"fsl_micfil.h\"\n#include \"fsl_utils.h\"\n\n#define MICFIL_OSR_DEFAULT\t16\n\nenum quality {\n\tQUALITY_HIGH,\n\tQUALITY_MEDIUM,\n\tQUALITY_LOW,\n\tQUALITY_VLOW0,\n\tQUALITY_VLOW1,\n\tQUALITY_VLOW2,\n};\n\nstruct fsl_micfil {\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tconst struct fsl_micfil_soc_data *soc;\n\tstruct clk *busclk;\n\tstruct clk *mclk;\n\tstruct clk *pll8k_clk;\n\tstruct clk *pll11k_clk;\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n\tstruct sdma_peripheral_config sdmacfg;\n\tstruct snd_soc_card *card;\n\tunsigned int dataline;\n\tchar name[32];\n\tint irq[MICFIL_IRQ_LINES];\n\tenum quality quality;\n\tint dc_remover;\n\tint vad_init_mode;\n\tint vad_enabled;\n\tint vad_detected;\n\tstruct fsl_micfil_verid verid;\n\tstruct fsl_micfil_param param;\n};\n\nstruct fsl_micfil_soc_data {\n\tunsigned int fifos;\n\tunsigned int fifo_depth;\n\tunsigned int dataline;\n\tbool imx;\n\tbool use_edma;\n\tbool use_verid;\n\tu64  formats;\n};\n\nstatic struct fsl_micfil_soc_data fsl_micfil_imx8mm = {\n\t.imx = true,\n\t.fifos = 8,\n\t.fifo_depth = 8,\n\t.dataline =  0xf,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n};\n\nstatic struct fsl_micfil_soc_data fsl_micfil_imx8mp = {\n\t.imx = true,\n\t.fifos = 8,\n\t.fifo_depth = 32,\n\t.dataline =  0xf,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n};\n\nstatic struct fsl_micfil_soc_data fsl_micfil_imx93 = {\n\t.imx = true,\n\t.fifos = 8,\n\t.fifo_depth = 32,\n\t.dataline =  0xf,\n\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t.use_edma = true,\n\t.use_verid = true,\n};\n\nstatic const struct of_device_id fsl_micfil_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8mm-micfil\", .data = &fsl_micfil_imx8mm },\n\t{ .compatible = \"fsl,imx8mp-micfil\", .data = &fsl_micfil_imx8mp },\n\t{ .compatible = \"fsl,imx93-micfil\", .data = &fsl_micfil_imx93 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_micfil_dt_ids);\n\nstatic const char * const micfil_quality_select_texts[] = {\n\t[QUALITY_HIGH] = \"High\",\n\t[QUALITY_MEDIUM] = \"Medium\",\n\t[QUALITY_LOW] = \"Low\",\n\t[QUALITY_VLOW0] = \"VLow0\",\n\t[QUALITY_VLOW1] = \"Vlow1\",\n\t[QUALITY_VLOW2] = \"Vlow2\",\n};\n\nstatic const struct soc_enum fsl_micfil_quality_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_quality_select_texts),\n\t\t\t    micfil_quality_select_texts);\n\nstatic DECLARE_TLV_DB_SCALE(gain_tlv, 0, 100, 0);\n\nstatic int micfil_set_quality(struct fsl_micfil *micfil)\n{\n\tu32 qsel;\n\n\tswitch (micfil->quality) {\n\tcase QUALITY_HIGH:\n\t\tqsel = MICFIL_QSEL_HIGH_QUALITY;\n\t\tbreak;\n\tcase QUALITY_MEDIUM:\n\t\tqsel = MICFIL_QSEL_MEDIUM_QUALITY;\n\t\tbreak;\n\tcase QUALITY_LOW:\n\t\tqsel = MICFIL_QSEL_LOW_QUALITY;\n\t\tbreak;\n\tcase QUALITY_VLOW0:\n\t\tqsel = MICFIL_QSEL_VLOW0_QUALITY;\n\t\tbreak;\n\tcase QUALITY_VLOW1:\n\t\tqsel = MICFIL_QSEL_VLOW1_QUALITY;\n\t\tbreak;\n\tcase QUALITY_VLOW2:\n\t\tqsel = MICFIL_QSEL_VLOW2_QUALITY;\n\t\tbreak;\n\t}\n\n\treturn regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL2,\n\t\t\t\t  MICFIL_CTRL2_QSEL,\n\t\t\t\t  FIELD_PREP(MICFIL_CTRL2_QSEL, qsel));\n}\n\nstatic int micfil_quality_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(cmpnt);\n\n\tucontrol->value.integer.value[0] = micfil->quality;\n\n\treturn 0;\n}\n\nstatic int micfil_quality_set(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(cmpnt);\n\n\tmicfil->quality = ucontrol->value.integer.value[0];\n\n\treturn micfil_set_quality(micfil);\n}\n\nstatic const char * const micfil_hwvad_enable[] = {\n\t\"Disable (Record only)\",\n\t\"Enable (Record with Vad)\",\n};\n\nstatic const char * const micfil_hwvad_init_mode[] = {\n\t\"Envelope mode\", \"Energy mode\",\n};\n\nstatic const char * const micfil_hwvad_hpf_texts[] = {\n\t\"Filter bypass\",\n\t\"Cut-off @1750Hz\",\n\t\"Cut-off @215Hz\",\n\t\"Cut-off @102Hz\",\n};\n\n \nstatic const char * const micfil_dc_remover_texts[] = {\n\t\"Cut-off @21Hz\", \"Cut-off @83Hz\",\n\t\"Cut-off @152Hz\", \"Bypass\",\n};\n\nstatic const struct soc_enum hwvad_enable_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_enable),\n\t\t\t    micfil_hwvad_enable);\nstatic const struct soc_enum hwvad_init_mode_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_hwvad_init_mode),\n\t\t\t    micfil_hwvad_init_mode);\nstatic const struct soc_enum hwvad_hpf_enum =\n\tSOC_ENUM_SINGLE(REG_MICFIL_VAD0_CTRL2, 0,\n\t\t\tARRAY_SIZE(micfil_hwvad_hpf_texts),\n\t\t\tmicfil_hwvad_hpf_texts);\nstatic const struct soc_enum fsl_micfil_dc_remover_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(micfil_dc_remover_texts),\n\t\t\t    micfil_dc_remover_texts);\n\nstatic int micfil_put_dc_remover_state(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tint val = snd_soc_enum_item_to_val(e, item[0]);\n\tint i = 0, ret = 0;\n\tu32 reg_val = 0;\n\n\tif (val < 0 || val > 3)\n\t\treturn -EINVAL;\n\n\tmicfil->dc_remover = val;\n\n\t \n\tfor (i = 0; i < MICFIL_OUTPUT_CHANNELS; i++)\n\t\treg_val |= val << MICFIL_DC_CHX_SHIFT(i);\n\n\t \n\tret = snd_soc_component_update_bits(comp, REG_MICFIL_DC_CTRL,\n\t\t\t\t\t    MICFIL_DC_CTRL_CONFIG, reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int micfil_get_dc_remover_state(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = micfil->dc_remover;\n\n\treturn 0;\n}\n\nstatic int hwvad_put_enable(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\tint val = snd_soc_enum_item_to_val(e, item[0]);\n\n\tmicfil->vad_enabled = val;\n\n\treturn 0;\n}\n\nstatic int hwvad_get_enable(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = micfil->vad_enabled;\n\n\treturn 0;\n}\n\nstatic int hwvad_put_init_mode(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\tint val = snd_soc_enum_item_to_val(e, item[0]);\n\n\t \n\tmicfil->vad_init_mode = val;\n\n\treturn 0;\n}\n\nstatic int hwvad_get_init_mode(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = micfil->vad_init_mode;\n\n\treturn 0;\n}\n\nstatic int hwvad_detected(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_micfil *micfil = snd_soc_component_get_drvdata(comp);\n\n\tucontrol->value.enumerated.item[0] = micfil->vad_detected;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new fsl_micfil_snd_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"CH0 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(0), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH1 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(1), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH2 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(2), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH3 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(3), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH4 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(4), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH5 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(5), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH6 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(6), 0x8, 0xF, gain_tlv),\n\tSOC_SINGLE_SX_TLV(\"CH7 Volume\", REG_MICFIL_OUT_CTRL,\n\t\t\t  MICFIL_OUTGAIN_CHX_SHIFT(7), 0x8, 0xF, gain_tlv),\n\tSOC_ENUM_EXT(\"MICFIL Quality Select\",\n\t\t     fsl_micfil_quality_enum,\n\t\t     micfil_quality_get, micfil_quality_set),\n\tSOC_ENUM_EXT(\"HWVAD Enablement Switch\", hwvad_enable_enum,\n\t\t     hwvad_get_enable, hwvad_put_enable),\n\tSOC_ENUM_EXT(\"HWVAD Initialization Mode\", hwvad_init_mode_enum,\n\t\t     hwvad_get_init_mode, hwvad_put_init_mode),\n\tSOC_ENUM(\"HWVAD High-Pass Filter\", hwvad_hpf_enum),\n\tSOC_SINGLE(\"HWVAD ZCD Switch\", REG_MICFIL_VAD0_ZCD, 0, 1, 0),\n\tSOC_SINGLE(\"HWVAD ZCD Auto Threshold Switch\",\n\t\t   REG_MICFIL_VAD0_ZCD, 2, 1, 0),\n\tSOC_ENUM_EXT(\"MICFIL DC Remover Control\", fsl_micfil_dc_remover_enum,\n\t\t     micfil_get_dc_remover_state, micfil_put_dc_remover_state),\n\tSOC_SINGLE(\"HWVAD Input Gain\", REG_MICFIL_VAD0_CTRL2, 8, 15, 0),\n\tSOC_SINGLE(\"HWVAD Sound Gain\", REG_MICFIL_VAD0_SCONFIG, 0, 15, 0),\n\tSOC_SINGLE(\"HWVAD Noise Gain\", REG_MICFIL_VAD0_NCONFIG, 0, 15, 0),\n\tSOC_SINGLE_RANGE(\"HWVAD Detector Frame Time\", REG_MICFIL_VAD0_CTRL2, 16, 0, 63, 0),\n\tSOC_SINGLE(\"HWVAD Detector Initialization Time\", REG_MICFIL_VAD0_CTRL1, 8, 31, 0),\n\tSOC_SINGLE(\"HWVAD Noise Filter Adjustment\", REG_MICFIL_VAD0_NCONFIG, 8, 31, 0),\n\tSOC_SINGLE(\"HWVAD ZCD Threshold\", REG_MICFIL_VAD0_ZCD, 16, 1023, 0),\n\tSOC_SINGLE(\"HWVAD ZCD Adjustment\", REG_MICFIL_VAD0_ZCD, 8, 15, 0),\n\tSOC_SINGLE(\"HWVAD ZCD And Behavior Switch\",\n\t\t   REG_MICFIL_VAD0_ZCD, 4, 1, 0),\n\tSOC_SINGLE_BOOL_EXT(\"VAD Detected\", 0, hwvad_detected, NULL),\n};\n\nstatic int fsl_micfil_use_verid(struct device *dev)\n{\n\tstruct fsl_micfil *micfil = dev_get_drvdata(dev);\n\tunsigned int val;\n\tint ret;\n\n\tif (!micfil->soc->use_verid)\n\t\treturn 0;\n\n\tret = regmap_read(micfil->regmap, REG_MICFIL_VERID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"VERID: 0x%016X\\n\", val);\n\n\tmicfil->verid.version = val &\n\t\t(MICFIL_VERID_MAJOR_MASK | MICFIL_VERID_MINOR_MASK);\n\tmicfil->verid.version >>= MICFIL_VERID_MINOR_SHIFT;\n\tmicfil->verid.feature = val & MICFIL_VERID_FEATURE_MASK;\n\n\tret = regmap_read(micfil->regmap, REG_MICFIL_PARAM, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"PARAM: 0x%016X\\n\", val);\n\n\tmicfil->param.hwvad_num = (val & MICFIL_PARAM_NUM_HWVAD_MASK) >>\n\t\tMICFIL_PARAM_NUM_HWVAD_SHIFT;\n\tmicfil->param.hwvad_zcd = val & MICFIL_PARAM_HWVAD_ZCD;\n\tmicfil->param.hwvad_energy_mode = val & MICFIL_PARAM_HWVAD_ENERGY_MODE;\n\tmicfil->param.hwvad = val & MICFIL_PARAM_HWVAD;\n\tmicfil->param.dc_out_bypass = val & MICFIL_PARAM_DC_OUT_BYPASS;\n\tmicfil->param.dc_in_bypass = val & MICFIL_PARAM_DC_IN_BYPASS;\n\tmicfil->param.low_power = val & MICFIL_PARAM_LOW_POWER;\n\tmicfil->param.fil_out_width = val & MICFIL_PARAM_FIL_OUT_WIDTH;\n\tmicfil->param.fifo_ptrwid = (val & MICFIL_PARAM_FIFO_PTRWID_MASK) >>\n\t\tMICFIL_PARAM_FIFO_PTRWID_SHIFT;\n\tmicfil->param.npair = (val & MICFIL_PARAM_NPAIR_MASK) >>\n\t\tMICFIL_PARAM_NPAIR_SHIFT;\n\n\treturn 0;\n}\n\n \nstatic int fsl_micfil_reset(struct device *dev)\n{\n\tstruct fsl_micfil *micfil = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_clear_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\tMICFIL_CTRL1_MDIS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_set_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t      MICFIL_CTRL1_SRES);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_clear_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\tMICFIL_CTRL1_SRES);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write_bits(micfil->regmap, REG_MICFIL_STAT, 0xFF, 0xFF);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int fsl_micfil_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct fsl_micfil *micfil = snd_soc_dai_get_drvdata(dai);\n\n\tif (!micfil) {\n\t\tdev_err(dai->dev, \"micfil dai priv_data not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_micfil_configure_hwvad_interrupts(struct fsl_micfil *micfil, int enable)\n{\n\tu32 vadie_reg = enable ? MICFIL_VAD0_CTRL1_IE : 0;\n\tu32 vaderie_reg = enable ? MICFIL_VAD0_CTRL1_ERIE : 0;\n\n\t \n\tregmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t   MICFIL_VAD0_CTRL1_ERIE, vaderie_reg);\n\n\t \n\tregmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t   MICFIL_VAD0_CTRL1_IE, vadie_reg);\n\n\treturn 0;\n}\n\n \nstatic int fsl_micfil_init_hwvad_energy_mode(struct fsl_micfil *micfil)\n{\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,\n\t\t\t  MICFIL_VAD0_CTRL2_FRENDIS);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,\n\t\t\t  MICFIL_VAD0_CTRL2_PREFEN);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,\n\t\t\t  MICFIL_VAD0_SCONFIG_SFILEN);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,\n\t\t\t  MICFIL_VAD0_SCONFIG_SMAXEN);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\tMICFIL_VAD0_NCONFIG_NFILAUT);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\t  MICFIL_VAD0_NCONFIG_NMINEN);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\t  MICFIL_VAD0_NCONFIG_NDECEN);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\t  MICFIL_VAD0_NCONFIG_NOREN);\n\n\treturn 0;\n}\n\n \nstatic int fsl_micfil_init_hwvad_envelope_mode(struct fsl_micfil *micfil)\n{\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,\n\t\t\tMICFIL_VAD0_CTRL2_FRENDIS);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL2,\n\t\t\tMICFIL_VAD0_CTRL2_PREFEN);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,\n\t\t\tMICFIL_VAD0_SCONFIG_SFILEN);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_SCONFIG,\n\t\t\tMICFIL_VAD0_SCONFIG_SMAXEN);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\t  MICFIL_VAD0_NCONFIG_NFILAUT);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\tMICFIL_VAD0_NCONFIG_NMINEN);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\tMICFIL_VAD0_NCONFIG_NDECEN);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_NCONFIG,\n\t\t\tMICFIL_VAD0_NCONFIG_NOREN);\n\n\treturn 0;\n}\n\n \nstatic int fsl_micfil_hwvad_enable(struct fsl_micfil *micfil)\n{\n\tint ret;\n\n\tmicfil->vad_detected = 0;\n\n\t \n\tif (micfil->vad_init_mode == MICFIL_HWVAD_ENVELOPE_MODE)\n\t\tret = fsl_micfil_init_hwvad_envelope_mode(micfil);\n\telse\n\t\tret = fsl_micfil_init_hwvad_energy_mode(micfil);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\tMICFIL_VAD0_CTRL1_ST10);\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t  MICFIL_VAD0_CTRL1_ST10);\n\n\t \n\tret = fsl_micfil_configure_hwvad_interrupts(micfil, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\tMICFIL_VAD0_CTRL1_RST);\n\n\t \n\tregmap_set_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\tMICFIL_VAD0_CTRL1_EN);\n\n\treturn 0;\n}\n\nstatic int fsl_micfil_hwvad_disable(struct fsl_micfil *micfil)\n{\n\tstruct device *dev = &micfil->pdev->dev;\n\tint ret = 0;\n\n\t \n\tregmap_clear_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t  MICFIL_VAD0_CTRL1_EN);\n\n\t \n\tret = fsl_micfil_configure_hwvad_interrupts(micfil, 0);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable interrupts\\n\");\n\n\treturn ret;\n}\n\nstatic int fsl_micfil_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct fsl_micfil *micfil = snd_soc_dai_get_drvdata(dai);\n\tstruct device *dev = &micfil->pdev->dev;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = fsl_micfil_reset(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to soft reset\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\tMICFIL_CTRL1_DISEL,\n\t\t\t\tFIELD_PREP(MICFIL_CTRL1_DISEL, MICFIL_CTRL1_DISEL_DMA));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_set_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\t      MICFIL_CTRL1_PDMIEN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (micfil->vad_enabled)\n\t\t\tfsl_micfil_hwvad_enable(micfil);\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (micfil->vad_enabled)\n\t\t\tfsl_micfil_hwvad_disable(micfil);\n\n\t\t \n\t\tret = regmap_clear_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\t\tMICFIL_CTRL1_PDMIEN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\tMICFIL_CTRL1_DISEL,\n\t\t\t\tFIELD_PREP(MICFIL_CTRL1_DISEL, MICFIL_CTRL1_DISEL_DISABLE));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int fsl_micfil_reparent_rootclk(struct fsl_micfil *micfil, unsigned int sample_rate)\n{\n\tstruct device *dev = &micfil->pdev->dev;\n\tu64 ratio = sample_rate;\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tclk = micfil->mclk;\n\n\t \n\tclk_disable_unprepare(clk);\n\tfsl_asoc_reparent_pll_clocks(dev, clk, micfil->pll8k_clk,\n\t\t\t\t     micfil->pll11k_clk, ratio);\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int fsl_micfil_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct fsl_micfil *micfil = snd_soc_dai_get_drvdata(dai);\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tint clk_div = 8;\n\tint osr = MICFIL_OSR_DEFAULT;\n\tint ret;\n\n\t \n\tret = regmap_clear_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\tMICFIL_CTRL1_PDMIEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL1,\n\t\t\t\t 0xFF, ((1 << channels) - 1));\n\tif (ret)\n\t\treturn ret;\n\n\tret = fsl_micfil_reparent_rootclk(micfil, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(micfil->mclk, rate * clk_div * osr * 8);\n\tif (ret)\n\t\treturn ret;\n\n\tret = micfil_set_quality(micfil);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_CTRL2,\n\t\t\t\t MICFIL_CTRL2_CLKDIV | MICFIL_CTRL2_CICOSR,\n\t\t\t\t FIELD_PREP(MICFIL_CTRL2_CLKDIV, clk_div) |\n\t\t\t\t FIELD_PREP(MICFIL_CTRL2_CICOSR, 16 - osr));\n\n\t \n\tregmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t   MICFIL_VAD0_CTRL1_CICOSR,\n\t\t\t   FIELD_PREP(MICFIL_VAD0_CTRL1_CICOSR, 16 - osr));\n\n\t \n\tregmap_update_bits(micfil->regmap, REG_MICFIL_VAD0_CTRL1,\n\t\t\t   MICFIL_VAD0_CTRL1_CHSEL,\n\t\t\t   FIELD_PREP(MICFIL_VAD0_CTRL1_CHSEL, (channels - 1)));\n\n\tmicfil->dma_params_rx.peripheral_config = &micfil->sdmacfg;\n\tmicfil->dma_params_rx.peripheral_size = sizeof(micfil->sdmacfg);\n\tmicfil->sdmacfg.n_fifos_src = channels;\n\tmicfil->sdmacfg.sw_done = true;\n\tmicfil->dma_params_rx.maxburst = channels * MICFIL_DMA_MAXBURST_RX;\n\tif (micfil->soc->use_edma)\n\t\tmicfil->dma_params_rx.maxburst = channels;\n\n\treturn 0;\n}\n\nstatic int fsl_micfil_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_micfil *micfil = dev_get_drvdata(cpu_dai->dev);\n\tstruct device *dev = cpu_dai->dev;\n\tunsigned int val = 0;\n\tint ret, i;\n\n\tmicfil->quality = QUALITY_VLOW0;\n\tmicfil->card = cpu_dai->component->card;\n\n\t \n\tregmap_write(micfil->regmap, REG_MICFIL_OUT_CTRL, 0x22222222);\n\n\t \n\tfor (i = 0; i < MICFIL_OUTPUT_CHANNELS; i++)\n\t\tval |= MICFIL_DC_BYPASS << MICFIL_DC_CHX_SHIFT(i);\n\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_DC_CTRL,\n\t\t\t\t MICFIL_DC_CTRL_CONFIG, val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set DC Remover mode bits\\n\");\n\t\treturn ret;\n\t}\n\tmicfil->dc_remover = MICFIL_DC_BYPASS;\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, NULL,\n\t\t\t\t  &micfil->dma_params_rx);\n\n\t \n\tret = regmap_update_bits(micfil->regmap, REG_MICFIL_FIFO_CTRL,\n\t\t\tMICFIL_FIFO_CTRL_FIFOWMK,\n\t\t\tFIELD_PREP(MICFIL_FIFO_CTRL_FIFOWMK, micfil->soc->fifo_depth - 1));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_micfil_dai_ops = {\n\t.probe\t\t= fsl_micfil_dai_probe,\n\t.startup\t= fsl_micfil_startup,\n\t.trigger\t= fsl_micfil_trigger,\n\t.hw_params\t= fsl_micfil_hw_params,\n};\n\nstatic struct snd_soc_dai_driver fsl_micfil_dai = {\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &fsl_micfil_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_micfil_component = {\n\t.name\t\t= \"fsl-micfil-dai\",\n\t.controls       = fsl_micfil_snd_controls,\n\t.num_controls   = ARRAY_SIZE(fsl_micfil_snd_controls),\n\t.legacy_dai_naming      = 1,\n};\n\n \nstatic const struct reg_default fsl_micfil_reg_defaults[] = {\n\t{REG_MICFIL_CTRL1,\t\t0x00000000},\n\t{REG_MICFIL_CTRL2,\t\t0x00000000},\n\t{REG_MICFIL_STAT,\t\t0x00000000},\n\t{REG_MICFIL_FIFO_CTRL,\t\t0x00000007},\n\t{REG_MICFIL_FIFO_STAT,\t\t0x00000000},\n\t{REG_MICFIL_DATACH0,\t\t0x00000000},\n\t{REG_MICFIL_DATACH1,\t\t0x00000000},\n\t{REG_MICFIL_DATACH2,\t\t0x00000000},\n\t{REG_MICFIL_DATACH3,\t\t0x00000000},\n\t{REG_MICFIL_DATACH4,\t\t0x00000000},\n\t{REG_MICFIL_DATACH5,\t\t0x00000000},\n\t{REG_MICFIL_DATACH6,\t\t0x00000000},\n\t{REG_MICFIL_DATACH7,\t\t0x00000000},\n\t{REG_MICFIL_DC_CTRL,\t\t0x00000000},\n\t{REG_MICFIL_OUT_CTRL,\t\t0x00000000},\n\t{REG_MICFIL_OUT_STAT,\t\t0x00000000},\n\t{REG_MICFIL_VAD0_CTRL1,\t\t0x00000000},\n\t{REG_MICFIL_VAD0_CTRL2,\t\t0x000A0000},\n\t{REG_MICFIL_VAD0_STAT,\t\t0x00000000},\n\t{REG_MICFIL_VAD0_SCONFIG,\t0x00000000},\n\t{REG_MICFIL_VAD0_NCONFIG,\t0x80000000},\n\t{REG_MICFIL_VAD0_NDATA,\t\t0x00000000},\n\t{REG_MICFIL_VAD0_ZCD,\t\t0x00000004},\n};\n\nstatic bool fsl_micfil_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_MICFIL_CTRL1:\n\tcase REG_MICFIL_CTRL2:\n\tcase REG_MICFIL_STAT:\n\tcase REG_MICFIL_FIFO_CTRL:\n\tcase REG_MICFIL_FIFO_STAT:\n\tcase REG_MICFIL_DATACH0:\n\tcase REG_MICFIL_DATACH1:\n\tcase REG_MICFIL_DATACH2:\n\tcase REG_MICFIL_DATACH3:\n\tcase REG_MICFIL_DATACH4:\n\tcase REG_MICFIL_DATACH5:\n\tcase REG_MICFIL_DATACH6:\n\tcase REG_MICFIL_DATACH7:\n\tcase REG_MICFIL_DC_CTRL:\n\tcase REG_MICFIL_OUT_CTRL:\n\tcase REG_MICFIL_OUT_STAT:\n\tcase REG_MICFIL_FSYNC_CTRL:\n\tcase REG_MICFIL_VERID:\n\tcase REG_MICFIL_PARAM:\n\tcase REG_MICFIL_VAD0_CTRL1:\n\tcase REG_MICFIL_VAD0_CTRL2:\n\tcase REG_MICFIL_VAD0_STAT:\n\tcase REG_MICFIL_VAD0_SCONFIG:\n\tcase REG_MICFIL_VAD0_NCONFIG:\n\tcase REG_MICFIL_VAD0_NDATA:\n\tcase REG_MICFIL_VAD0_ZCD:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_micfil_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_MICFIL_CTRL1:\n\tcase REG_MICFIL_CTRL2:\n\tcase REG_MICFIL_STAT:\t\t \n\tcase REG_MICFIL_FIFO_CTRL:\n\tcase REG_MICFIL_FIFO_STAT:\t \n\tcase REG_MICFIL_DC_CTRL:\n\tcase REG_MICFIL_OUT_CTRL:\n\tcase REG_MICFIL_OUT_STAT:\t \n\tcase REG_MICFIL_FSYNC_CTRL:\n\tcase REG_MICFIL_VAD0_CTRL1:\n\tcase REG_MICFIL_VAD0_CTRL2:\n\tcase REG_MICFIL_VAD0_STAT:\t \n\tcase REG_MICFIL_VAD0_SCONFIG:\n\tcase REG_MICFIL_VAD0_NCONFIG:\n\tcase REG_MICFIL_VAD0_ZCD:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_micfil_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_MICFIL_STAT:\n\tcase REG_MICFIL_DATACH0:\n\tcase REG_MICFIL_DATACH1:\n\tcase REG_MICFIL_DATACH2:\n\tcase REG_MICFIL_DATACH3:\n\tcase REG_MICFIL_DATACH4:\n\tcase REG_MICFIL_DATACH5:\n\tcase REG_MICFIL_DATACH6:\n\tcase REG_MICFIL_DATACH7:\n\tcase REG_MICFIL_VERID:\n\tcase REG_MICFIL_PARAM:\n\tcase REG_MICFIL_VAD0_STAT:\n\tcase REG_MICFIL_VAD0_NDATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config fsl_micfil_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = REG_MICFIL_VAD0_ZCD,\n\t.reg_defaults = fsl_micfil_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_micfil_reg_defaults),\n\t.readable_reg = fsl_micfil_readable_reg,\n\t.volatile_reg = fsl_micfil_volatile_reg,\n\t.writeable_reg = fsl_micfil_writeable_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \n\nstatic irqreturn_t micfil_isr(int irq, void *devid)\n{\n\tstruct fsl_micfil *micfil = (struct fsl_micfil *)devid;\n\tstruct platform_device *pdev = micfil->pdev;\n\tu32 stat_reg;\n\tu32 fifo_stat_reg;\n\tu32 ctrl1_reg;\n\tbool dma_enabled;\n\tint i;\n\n\tregmap_read(micfil->regmap, REG_MICFIL_STAT, &stat_reg);\n\tregmap_read(micfil->regmap, REG_MICFIL_CTRL1, &ctrl1_reg);\n\tregmap_read(micfil->regmap, REG_MICFIL_FIFO_STAT, &fifo_stat_reg);\n\n\tdma_enabled = FIELD_GET(MICFIL_CTRL1_DISEL, ctrl1_reg) == MICFIL_CTRL1_DISEL_DMA;\n\n\t \n\tfor (i = 0; i < MICFIL_OUTPUT_CHANNELS; i++) {\n\t\tif (stat_reg & MICFIL_STAT_CHXF(i))\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"Data available in Data Channel %d\\n\", i);\n\t\t \n\t\tif (!dma_enabled)\n\t\t\tregmap_write_bits(micfil->regmap,\n\t\t\t\t\t  REG_MICFIL_STAT,\n\t\t\t\t\t  MICFIL_STAT_CHXF(i),\n\t\t\t\t\t  1);\n\t}\n\n\tfor (i = 0; i < MICFIL_FIFO_NUM; i++) {\n\t\tif (fifo_stat_reg & MICFIL_FIFO_STAT_FIFOX_OVER(i))\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"FIFO Overflow Exception flag for channel %d\\n\",\n\t\t\t\ti);\n\n\t\tif (fifo_stat_reg & MICFIL_FIFO_STAT_FIFOX_UNDER(i))\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"FIFO Underflow Exception flag for channel %d\\n\",\n\t\t\t\ti);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t micfil_err_isr(int irq, void *devid)\n{\n\tstruct fsl_micfil *micfil = (struct fsl_micfil *)devid;\n\tstruct platform_device *pdev = micfil->pdev;\n\tu32 stat_reg;\n\n\tregmap_read(micfil->regmap, REG_MICFIL_STAT, &stat_reg);\n\n\tif (stat_reg & MICFIL_STAT_BSY_FIL)\n\t\tdev_dbg(&pdev->dev, \"isr: Decimation Filter is running\\n\");\n\n\tif (stat_reg & MICFIL_STAT_FIR_RDY)\n\t\tdev_dbg(&pdev->dev, \"isr: FIR Filter Data ready\\n\");\n\n\tif (stat_reg & MICFIL_STAT_LOWFREQF) {\n\t\tdev_dbg(&pdev->dev, \"isr: ipg_clk_app is too low\\n\");\n\t\tregmap_write_bits(micfil->regmap, REG_MICFIL_STAT,\n\t\t\t\t  MICFIL_STAT_LOWFREQF, 1);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t voice_detected_fn(int irq, void *devid)\n{\n\tstruct fsl_micfil *micfil = (struct fsl_micfil *)devid;\n\tstruct snd_kcontrol *kctl;\n\n\tif (!micfil->card)\n\t\treturn IRQ_HANDLED;\n\n\tkctl = snd_soc_card_get_kcontrol(micfil->card, \"VAD Detected\");\n\tif (!kctl)\n\t\treturn IRQ_HANDLED;\n\n\tif (micfil->vad_detected)\n\t\tsnd_ctl_notify(micfil->card->snd_card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &kctl->id);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t hwvad_isr(int irq, void *devid)\n{\n\tstruct fsl_micfil *micfil = (struct fsl_micfil *)devid;\n\tstruct device *dev = &micfil->pdev->dev;\n\tu32 vad0_reg;\n\tint ret;\n\n\tregmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &vad0_reg);\n\n\t \n\tif (vad0_reg & MICFIL_VAD0_STAT_IF) {\n\t\t \n\t\tregmap_write_bits(micfil->regmap, REG_MICFIL_VAD0_STAT,\n\t\t\t\t  MICFIL_VAD0_STAT_IF,\n\t\t\t\t  MICFIL_VAD0_STAT_IF);\n\n\t\tmicfil->vad_detected = 1;\n\t}\n\n\tret = fsl_micfil_hwvad_disable(micfil);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to disable hwvad\\n\");\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t hwvad_err_isr(int irq, void *devid)\n{\n\tstruct fsl_micfil *micfil = (struct fsl_micfil *)devid;\n\tstruct device *dev = &micfil->pdev->dev;\n\tu32 vad0_reg;\n\n\tregmap_read(micfil->regmap, REG_MICFIL_VAD0_STAT, &vad0_reg);\n\n\tif (vad0_reg & MICFIL_VAD0_STAT_INSATF)\n\t\tdev_dbg(dev, \"voice activity input overflow/underflow detected\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsl_micfil_runtime_suspend(struct device *dev);\nstatic int fsl_micfil_runtime_resume(struct device *dev);\n\nstatic int fsl_micfil_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_micfil *micfil;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint ret, i;\n\n\tmicfil = devm_kzalloc(&pdev->dev, sizeof(*micfil), GFP_KERNEL);\n\tif (!micfil)\n\t\treturn -ENOMEM;\n\n\tmicfil->pdev = pdev;\n\tstrscpy(micfil->name, np->name, sizeof(micfil->name));\n\n\tmicfil->soc = of_device_get_match_data(&pdev->dev);\n\n\t \n\tmicfil->mclk = devm_clk_get(&pdev->dev, \"ipg_clk_app\");\n\tif (IS_ERR(micfil->mclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get core clock: %ld\\n\",\n\t\t\tPTR_ERR(micfil->mclk));\n\t\treturn PTR_ERR(micfil->mclk);\n\t}\n\n\tmicfil->busclk = devm_clk_get(&pdev->dev, \"ipg_clk\");\n\tif (IS_ERR(micfil->busclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get ipg clock: %ld\\n\",\n\t\t\tPTR_ERR(micfil->busclk));\n\t\treturn PTR_ERR(micfil->busclk);\n\t}\n\n\tfsl_asoc_get_pll_clocks(&pdev->dev, &micfil->pll8k_clk,\n\t\t\t\t&micfil->pll11k_clk);\n\n\t \n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tmicfil->regmap = devm_regmap_init_mmio(&pdev->dev,\n\t\t\t\t\t       regs,\n\t\t\t\t\t       &fsl_micfil_regmap_config);\n\tif (IS_ERR(micfil->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to init MICFIL regmap: %ld\\n\",\n\t\t\tPTR_ERR(micfil->regmap));\n\t\treturn PTR_ERR(micfil->regmap);\n\t}\n\n\t \n\tret = of_property_read_u32_index(np,\n\t\t\t\t\t \"fsl,dataline\",\n\t\t\t\t\t 0,\n\t\t\t\t\t &micfil->dataline);\n\tif (ret)\n\t\tmicfil->dataline = 1;\n\n\tif (micfil->dataline & ~micfil->soc->dataline) {\n\t\tdev_err(&pdev->dev, \"dataline setting error, Mask is 0x%X\\n\",\n\t\t\tmicfil->soc->dataline);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < MICFIL_IRQ_LINES; i++) {\n\t\tmicfil->irq[i] = platform_get_irq(pdev, i);\n\t\tif (micfil->irq[i] < 0)\n\t\t\treturn micfil->irq[i];\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, micfil->irq[0],\n\t\t\t       micfil_isr, IRQF_SHARED,\n\t\t\t       micfil->name, micfil);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim mic interface irq %u\\n\",\n\t\t\tmicfil->irq[0]);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, micfil->irq[1],\n\t\t\t       micfil_err_isr, IRQF_SHARED,\n\t\t\t       micfil->name, micfil);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim mic interface error irq %u\\n\",\n\t\t\tmicfil->irq[1]);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(&pdev->dev, micfil->irq[2],\n\t\t\t\t\thwvad_isr, voice_detected_fn,\n\t\t\t\t\tIRQF_SHARED, micfil->name, micfil);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim hwvad event irq %u\\n\",\n\t\t\tmicfil->irq[0]);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_irq(&pdev->dev, micfil->irq[3],\n\t\t\t       hwvad_err_isr, IRQF_SHARED,\n\t\t\t       micfil->name, micfil);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim hwvad error irq %u\\n\",\n\t\t\tmicfil->irq[1]);\n\t\treturn ret;\n\t}\n\n\tmicfil->dma_params_rx.chan_name = \"rx\";\n\tmicfil->dma_params_rx.addr = res->start + REG_MICFIL_DATACH0;\n\tmicfil->dma_params_rx.maxburst = MICFIL_DMA_MAXBURST_RX;\n\n\tplatform_set_drvdata(pdev, micfil);\n\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = fsl_micfil_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_pm_get_sync;\n\n\t \n\tret = fsl_micfil_use_verid(&pdev->dev);\n\tif (ret < 0)\n\t\tdev_warn(&pdev->dev, \"Error reading MICFIL version: %d\\n\", ret);\n\n\tret = pm_runtime_put_sync(&pdev->dev);\n\tif (ret < 0 && ret != -ENOSYS)\n\t\tgoto err_pm_get_sync;\n\n\tregcache_cache_only(micfil->regmap, true);\n\n\t \n\tret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to pcm register\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\tfsl_micfil_dai.capture.formats = micfil->soc->formats;\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &fsl_micfil_component,\n\t\t\t\t\t      &fsl_micfil_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register component %s\\n\",\n\t\t\tfsl_micfil_component.name);\n\t\tgoto err_pm_disable;\n\t}\n\n\treturn ret;\n\nerr_pm_get_sync:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_micfil_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic void fsl_micfil_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int fsl_micfil_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_micfil *micfil = dev_get_drvdata(dev);\n\n\tregcache_cache_only(micfil->regmap, true);\n\n\tclk_disable_unprepare(micfil->mclk);\n\tclk_disable_unprepare(micfil->busclk);\n\n\treturn 0;\n}\n\nstatic int fsl_micfil_runtime_resume(struct device *dev)\n{\n\tstruct fsl_micfil *micfil = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(micfil->busclk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(micfil->mclk);\n\tif (ret < 0) {\n\t\tclk_disable_unprepare(micfil->busclk);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(micfil->regmap, false);\n\tregcache_mark_dirty(micfil->regmap);\n\tregcache_sync(micfil->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops fsl_micfil_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_micfil_runtime_suspend,\n\t\t\t   fsl_micfil_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_micfil_driver = {\n\t.probe = fsl_micfil_probe,\n\t.remove_new = fsl_micfil_remove,\n\t.driver = {\n\t\t.name = \"fsl-micfil-dai\",\n\t\t.pm = &fsl_micfil_pm_ops,\n\t\t.of_match_table = fsl_micfil_dt_ids,\n\t},\n};\nmodule_platform_driver(fsl_micfil_driver);\n\nMODULE_AUTHOR(\"Cosmin-Gabriel Samoila <cosmin.samoila@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP PDM Microphone Interface (MICFIL) driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}