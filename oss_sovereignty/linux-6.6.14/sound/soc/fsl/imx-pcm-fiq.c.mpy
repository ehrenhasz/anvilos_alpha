{
  "module_name": "imx-pcm-fiq.c",
  "hash_id": "40cbed17d8ebe82a59d05960b8d62469375d85a11684e6dc5f6578b26e4f2e99",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-pcm-fiq.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/fiq.h>\n\n#include <linux/platform_data/asoc-imx-ssi.h>\n\n#include \"imx-ssi.h\"\n#include \"imx-pcm.h\"\n\nstruct imx_pcm_runtime_data {\n\tunsigned int period;\n\tint periods;\n\tunsigned long offset;\n\tstruct hrtimer hrt;\n\tint poll_time_ns;\n\tstruct snd_pcm_substream *substream;\n\tatomic_t playing;\n\tatomic_t capturing;\n};\n\nstatic enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)\n{\n\tstruct imx_pcm_runtime_data *iprtd =\n\t\tcontainer_of(hrt, struct imx_pcm_runtime_data, hrt);\n\tstruct snd_pcm_substream *substream = iprtd->substream;\n\tstruct pt_regs regs;\n\n\tif (!atomic_read(&iprtd->playing) && !atomic_read(&iprtd->capturing))\n\t\treturn HRTIMER_NORESTART;\n\n\tget_fiq_regs(&regs);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tiprtd->offset = regs.ARM_r8 & 0xffff;\n\telse\n\t\tiprtd->offset = regs.ARM_r9 & 0xffff;\n\n\tsnd_pcm_period_elapsed(substream);\n\n\thrtimer_forward_now(hrt, ns_to_ktime(iprtd->poll_time_ns));\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic struct fiq_handler fh = {\n\t.name\t\t= DRV_NAME,\n};\n\nstatic int snd_imx_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\n\n\tiprtd->periods = params_periods(params);\n\tiprtd->period = params_period_bytes(params);\n\tiprtd->offset = 0;\n\tiprtd->poll_time_ns = 1000000000 / params_rate(params) *\n\t\t\t\tparams_period_size(params);\n\n\treturn 0;\n}\n\nstatic int snd_imx_pcm_prepare(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\n\tstruct pt_regs regs;\n\n\tget_fiq_regs(&regs);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregs.ARM_r8 = (iprtd->period * iprtd->periods - 1) << 16;\n\telse\n\t\tregs.ARM_r9 = (iprtd->period * iprtd->periods - 1) << 16;\n\n\tset_fiq_regs(&regs);\n\n\treturn 0;\n}\n\nstatic int imx_pcm_fiq;\n\nstatic int snd_imx_pcm_trigger(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tatomic_set(&iprtd->playing, 1);\n\t\telse\n\t\t\tatomic_set(&iprtd->capturing, 1);\n\t\thrtimer_start(&iprtd->hrt, ns_to_ktime(iprtd->poll_time_ns),\n\t\t      HRTIMER_MODE_REL);\n\t\tenable_fiq(imx_pcm_fiq);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tatomic_set(&iprtd->playing, 0);\n\t\telse\n\t\t\tatomic_set(&iprtd->capturing, 0);\n\t\tif (!atomic_read(&iprtd->playing) &&\n\t\t\t\t!atomic_read(&iprtd->capturing))\n\t\t\tdisable_fiq(imx_pcm_fiq);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\nsnd_imx_pcm_pointer(struct snd_soc_component *component,\n\t\t    struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\n\n\treturn bytes_to_frames(substream->runtime, iprtd->offset);\n}\n\nstatic const struct snd_pcm_hardware snd_imx_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED |\n\t\tSNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_MMAP |\n\t\tSNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_PAUSE |\n\t\tSNDRV_PCM_INFO_RESUME,\n\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t.buffer_bytes_max = IMX_SSI_DMABUF_SIZE,\n\t.period_bytes_min = 128,\n\t.period_bytes_max = 16 * 1024,\n\t.periods_min = 4,\n\t.periods_max = 255,\n\t.fifo_size = 0,\n};\n\nstatic int snd_imx_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd;\n\tint ret;\n\n\tiprtd = kzalloc(sizeof(*iprtd), GFP_KERNEL);\n\tif (iprtd == NULL)\n\t\treturn -ENOMEM;\n\truntime->private_data = iprtd;\n\n\tiprtd->substream = substream;\n\n\tatomic_set(&iprtd->playing, 0);\n\tatomic_set(&iprtd->capturing, 0);\n\thrtimer_init(&iprtd->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tiprtd->hrt.function = snd_hrtimer_callback;\n\n\tret = snd_pcm_hw_constraint_integer(substream->runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tkfree(iprtd);\n\t\treturn ret;\n\t}\n\n\tsnd_soc_set_runtime_hwparams(substream, &snd_imx_hardware);\n\treturn 0;\n}\n\nstatic int snd_imx_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct imx_pcm_runtime_data *iprtd = runtime->private_data;\n\n\thrtimer_cancel(&iprtd->hrt);\n\n\tkfree(iprtd);\n\n\treturn 0;\n}\n\nstatic int imx_pcm_new(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV_WC,\n\t\t\t\t\t    pcm->card->dev,\n\t\t\t\t\t    IMX_SSI_DMABUF_SIZE);\n}\n\nstatic int ssi_irq;\n\nstatic int snd_imx_pcm_new(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tstruct snd_pcm_substream *substream;\n\tint ret;\n\n\tret = imx_pcm_new(rtd);\n\tif (ret)\n\t\treturn ret;\n\n\tsubstream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\n\tif (substream) {\n\t\tstruct snd_dma_buffer *buf = &substream->dma_buffer;\n\n\t\timx_ssi_fiq_tx_buffer = (unsigned long)buf->area;\n\t}\n\n\tsubstream = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\n\tif (substream) {\n\t\tstruct snd_dma_buffer *buf = &substream->dma_buffer;\n\n\t\timx_ssi_fiq_rx_buffer = (unsigned long)buf->area;\n\t}\n\n\tset_fiq_handler(&imx_ssi_fiq_start,\n\t\t&imx_ssi_fiq_end - &imx_ssi_fiq_start);\n\n\treturn 0;\n}\n\nstatic void snd_imx_pcm_free(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm *pcm)\n{\n\tmxc_set_irq_fiq(ssi_irq, 0);\n\trelease_fiq(&fh);\n}\n\nstatic const struct snd_soc_component_driver imx_soc_component_fiq = {\n\t.open\t\t= snd_imx_open,\n\t.close\t\t= snd_imx_close,\n\t.hw_params\t= snd_imx_pcm_hw_params,\n\t.prepare\t= snd_imx_pcm_prepare,\n\t.trigger\t= snd_imx_pcm_trigger,\n\t.pointer\t= snd_imx_pcm_pointer,\n\t.pcm_construct\t= snd_imx_pcm_new,\n\t.pcm_destruct\t= snd_imx_pcm_free,\n};\n\nint imx_pcm_fiq_init(struct platform_device *pdev,\n\t\tstruct imx_pcm_fiq_params *params)\n{\n\tint ret;\n\n\tret = claim_fiq(&fh);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim fiq: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tmxc_set_irq_fiq(params->irq, 1);\n\tssi_irq = params->irq;\n\n\timx_pcm_fiq = params->irq;\n\n\timx_ssi_fiq_base = (unsigned long)params->base;\n\n\tparams->dma_params_tx->maxburst = 4;\n\tparams->dma_params_rx->maxburst = 6;\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &imx_soc_component_fiq,\n\t\t\t\t\t      NULL, 0);\n\tif (ret)\n\t\tgoto failed_register;\n\n\treturn 0;\n\nfailed_register:\n\tmxc_set_irq_fiq(ssi_irq, 0);\n\trelease_fiq(&fh);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imx_pcm_fiq_init);\n\nvoid imx_pcm_fiq_exit(struct platform_device *pdev)\n{\n}\nEXPORT_SYMBOL_GPL(imx_pcm_fiq_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}