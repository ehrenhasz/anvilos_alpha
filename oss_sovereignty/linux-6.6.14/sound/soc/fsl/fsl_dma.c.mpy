{
  "module_name": "fsl_dma.c",
  "hash_id": "9fc7b0c1b98540ec15ad24556eefcb7daf8c72356cf3f3b4b05a73b8b084f03b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/gfp.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/io.h>\n\n#include \"fsl_dma.h\"\n#include \"fsl_ssi.h\"\t \n\n#define DRV_NAME \"fsl_dma\"\n\n \n#define FSLDMA_PCM_FORMATS (SNDRV_PCM_FMTBIT_S8 \t| \\\n\t\t\t    SNDRV_PCM_FMTBIT_U8 \t| \\\n\t\t\t    SNDRV_PCM_FMTBIT_S16_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S16_BE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U16_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U16_BE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S24_BE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U24_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U24_BE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S32_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S32_BE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U32_LE     | \\\n\t\t\t    SNDRV_PCM_FMTBIT_U32_BE)\nstruct dma_object {\n\tstruct snd_soc_component_driver dai;\n\tdma_addr_t ssi_stx_phys;\n\tdma_addr_t ssi_srx_phys;\n\tunsigned int ssi_fifo_depth;\n\tstruct ccsr_dma_channel __iomem *channel;\n\tunsigned int irq;\n\tbool assigned;\n};\n\n \n#define NUM_DMA_LINKS   2\n\n \nstruct fsl_dma_private {\n\tstruct fsl_dma_link_descriptor link[NUM_DMA_LINKS];\n\tstruct ccsr_dma_channel __iomem *dma_channel;\n\tunsigned int irq;\n\tstruct snd_pcm_substream *substream;\n\tdma_addr_t ssi_sxx_phys;\n\tunsigned int ssi_fifo_depth;\n\tdma_addr_t ld_buf_phys;\n\tunsigned int current_link;\n\tdma_addr_t dma_buf_phys;\n\tdma_addr_t dma_buf_next;\n\tdma_addr_t dma_buf_end;\n\tsize_t period_size;\n\tunsigned int num_periods;\n};\n\n \nstatic const struct snd_pcm_hardware fsl_dma_hardware = {\n\n\t.info   \t\t= SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_JOINT_DUPLEX |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE,\n\t.formats\t\t= FSLDMA_PCM_FORMATS,\n\t.period_bytes_min       = 512,  \t \n\t.period_bytes_max       = (u32) -1,\n\t.periods_min    \t= NUM_DMA_LINKS,\n\t.periods_max    \t= (unsigned int) -1,\n\t.buffer_bytes_max       = 128 * 1024,    \n};\n\n \nstatic void fsl_dma_abort_stream(struct snd_pcm_substream *substream)\n{\n\tsnd_pcm_stop_xrun(substream);\n}\n\n \nstatic void fsl_dma_update_pointers(struct fsl_dma_private *dma_private)\n{\n\tstruct fsl_dma_link_descriptor *link =\n\t\t&dma_private->link[dma_private->current_link];\n\n\t \n\tif (dma_private->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tlink->source_addr = cpu_to_be32(dma_private->dma_buf_next);\n#ifdef CONFIG_PHYS_64BIT\n\t\tlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\n\t\t\tupper_32_bits(dma_private->dma_buf_next));\n#endif\n\t} else {\n\t\tlink->dest_addr = cpu_to_be32(dma_private->dma_buf_next);\n#ifdef CONFIG_PHYS_64BIT\n\t\tlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\n\t\t\tupper_32_bits(dma_private->dma_buf_next));\n#endif\n\t}\n\n\t \n\tdma_private->dma_buf_next += dma_private->period_size;\n\n\tif (dma_private->dma_buf_next >= dma_private->dma_buf_end)\n\t\tdma_private->dma_buf_next = dma_private->dma_buf_phys;\n\n\tif (++dma_private->current_link >= NUM_DMA_LINKS)\n\t\tdma_private->current_link = 0;\n}\n\n \nstatic irqreturn_t fsl_dma_isr(int irq, void *dev_id)\n{\n\tstruct fsl_dma_private *dma_private = dev_id;\n\tstruct snd_pcm_substream *substream = dma_private->substream;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct device *dev = rtd->dev;\n\tstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 sr, sr2 = 0;\n\n\t \n\tsr = in_be32(&dma_channel->sr);\n\n\tif (sr & CCSR_DMA_SR_TE) {\n\t\tdev_err(dev, \"dma transmit error\\n\");\n\t\tfsl_dma_abort_stream(substream);\n\t\tsr2 |= CCSR_DMA_SR_TE;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (sr & CCSR_DMA_SR_CH)\n\t\tret = IRQ_HANDLED;\n\n\tif (sr & CCSR_DMA_SR_PE) {\n\t\tdev_err(dev, \"dma programming error\\n\");\n\t\tfsl_dma_abort_stream(substream);\n\t\tsr2 |= CCSR_DMA_SR_PE;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (sr & CCSR_DMA_SR_EOLNI) {\n\t\tsr2 |= CCSR_DMA_SR_EOLNI;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (sr & CCSR_DMA_SR_CB)\n\t\tret = IRQ_HANDLED;\n\n\tif (sr & CCSR_DMA_SR_EOSI) {\n\t\t \n\t\tsnd_pcm_period_elapsed(substream);\n\n\t\t \n\t\tif (dma_private->num_periods != NUM_DMA_LINKS)\n\t\t\tfsl_dma_update_pointers(dma_private);\n\n\t\tsr2 |= CCSR_DMA_SR_EOSI;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (sr & CCSR_DMA_SR_EOLSI) {\n\t\tsr2 |= CCSR_DMA_SR_EOLSI;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (sr2)\n\t\tout_be32(&dma_channel->sr, sr2);\n\n\treturn ret;\n}\n\n \nstatic int fsl_dma_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(36));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,\n\t\t\t\t\t    card->dev,\n\t\t\t\t\t    fsl_dma_hardware.buffer_bytes_max);\n}\n\n \nstatic int fsl_dma_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = component->dev;\n\tstruct dma_object *dma =\n\t\tcontainer_of(component->driver, struct dma_object, dai);\n\tstruct fsl_dma_private *dma_private;\n\tstruct ccsr_dma_channel __iomem *dma_channel;\n\tdma_addr_t ld_buf_phys;\n\tu64 temp_link;  \t \n\tu32 mr;\n\tint ret = 0;\n\tunsigned int i;\n\n\t \n\tret = snd_pcm_hw_constraint_integer(runtime,\n\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"invalid buffer size\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dma->assigned) {\n\t\tdev_err(dev, \"dma channel already assigned\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdma_private = dma_alloc_coherent(dev, sizeof(struct fsl_dma_private),\n\t\t\t\t\t &ld_buf_phys, GFP_KERNEL);\n\tif (!dma_private) {\n\t\tdev_err(dev, \"can't allocate dma private data\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdma_private->ssi_sxx_phys = dma->ssi_stx_phys;\n\telse\n\t\tdma_private->ssi_sxx_phys = dma->ssi_srx_phys;\n\n\tdma_private->ssi_fifo_depth = dma->ssi_fifo_depth;\n\tdma_private->dma_channel = dma->channel;\n\tdma_private->irq = dma->irq;\n\tdma_private->substream = substream;\n\tdma_private->ld_buf_phys = ld_buf_phys;\n\tdma_private->dma_buf_phys = substream->dma_buffer.addr;\n\n\tret = request_irq(dma_private->irq, fsl_dma_isr, 0, \"fsldma-audio\",\n\t\t\t  dma_private);\n\tif (ret) {\n\t\tdev_err(dev, \"can't register ISR for IRQ %u (ret=%i)\\n\",\n\t\t\tdma_private->irq, ret);\n\t\tdma_free_coherent(dev, sizeof(struct fsl_dma_private),\n\t\t\tdma_private, dma_private->ld_buf_phys);\n\t\treturn ret;\n\t}\n\n\tdma->assigned = true;\n\n\tsnd_soc_set_runtime_hwparams(substream, &fsl_dma_hardware);\n\truntime->private_data = dma_private;\n\n\t \n\n\tdma_channel = dma_private->dma_channel;\n\n\ttemp_link = dma_private->ld_buf_phys +\n\t\tsizeof(struct fsl_dma_link_descriptor);\n\n\tfor (i = 0; i < NUM_DMA_LINKS; i++) {\n\t\tdma_private->link[i].next = cpu_to_be64(temp_link);\n\n\t\ttemp_link += sizeof(struct fsl_dma_link_descriptor);\n\t}\n\t \n\tdma_private->link[i - 1].next = cpu_to_be64(dma_private->ld_buf_phys);\n\n\t \n\tout_be32(&dma_channel->clndar,\n\t\tCCSR_DMA_CLNDAR_ADDR(dma_private->ld_buf_phys));\n\tout_be32(&dma_channel->eclndar,\n\t\tCCSR_DMA_ECLNDAR_ADDR(dma_private->ld_buf_phys));\n\n\t \n\tout_be32(&dma_channel->bcr, 0);\n\n\t \n\tmr = in_be32(&dma_channel->mr) &\n\t\t~(CCSR_DMA_MR_CA | CCSR_DMA_MR_DAHE | CCSR_DMA_MR_SAHE);\n\n\t \n\tmr |= CCSR_DMA_MR_EOSIE | CCSR_DMA_MR_EIE | CCSR_DMA_MR_EMP_EN |\n\t\tCCSR_DMA_MR_EMS_EN;\n\n\t \n\tmr |= (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\tCCSR_DMA_MR_DAHE : CCSR_DMA_MR_SAHE;\n\n\tout_be32(&dma_channel->mr, mr);\n\n\treturn 0;\n}\n\n \nstatic int fsl_dma_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_dma_private *dma_private = runtime->private_data;\n\tstruct device *dev = component->dev;\n\n\t \n\tunsigned int sample_bits =\n\t\tsnd_pcm_format_physical_width(params_format(hw_params));\n\n\t \n\tunsigned int sample_bytes = sample_bits / 8;\n\n\t \n\tdma_addr_t ssi_sxx_phys = dma_private->ssi_sxx_phys;\n\n\t \n\tsize_t buffer_size = params_buffer_bytes(hw_params);\n\n\t \n\tsize_t period_size = params_period_bytes(hw_params);\n\n\t \n\tdma_addr_t temp_addr = substream->dma_buffer.addr;\n\n\t \n\tstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\n\n\tu32 mr;  \n\n\tunsigned int i;\n\n\t \n\tdma_private->period_size = period_size;\n\tdma_private->num_periods = params_periods(hw_params);\n\tdma_private->dma_buf_end = dma_private->dma_buf_phys + buffer_size;\n\tdma_private->dma_buf_next = dma_private->dma_buf_phys +\n\t\t(NUM_DMA_LINKS * period_size);\n\n\tif (dma_private->dma_buf_next >= dma_private->dma_buf_end)\n\t\t \n\t\tdma_private->dma_buf_next = dma_private->dma_buf_phys;\n\n\tmr = in_be32(&dma_channel->mr) & ~(CCSR_DMA_MR_BWC_MASK |\n\t\t  CCSR_DMA_MR_SAHTS_MASK | CCSR_DMA_MR_DAHTS_MASK);\n\n\t \n\tswitch (sample_bits) {\n\tcase 8:\n\t\tmr |= CCSR_DMA_MR_DAHTS_1 | CCSR_DMA_MR_SAHTS_1;\n\t\tssi_sxx_phys += 3;\n\t\tbreak;\n\tcase 16:\n\t\tmr |= CCSR_DMA_MR_DAHTS_2 | CCSR_DMA_MR_SAHTS_2;\n\t\tssi_sxx_phys += 2;\n\t\tbreak;\n\tcase 32:\n\t\tmr |= CCSR_DMA_MR_DAHTS_4 | CCSR_DMA_MR_SAHTS_4;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(dev, \"unsupported sample size %u\\n\", sample_bits);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmr |= CCSR_DMA_MR_BWC((dma_private->ssi_fifo_depth - 2) * sample_bytes);\n\n\tout_be32(&dma_channel->mr, mr);\n\n\tfor (i = 0; i < NUM_DMA_LINKS; i++) {\n\t\tstruct fsl_dma_link_descriptor *link = &dma_private->link[i];\n\n\t\tlink->count = cpu_to_be32(period_size);\n\n\t\t \n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tlink->source_addr = cpu_to_be32(temp_addr);\n\t\t\tlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\n\t\t\t\tupper_32_bits(temp_addr));\n\n\t\t\tlink->dest_addr = cpu_to_be32(ssi_sxx_phys);\n\t\t\tlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_NOSNOOP |\n\t\t\t\tupper_32_bits(ssi_sxx_phys));\n\t\t} else {\n\t\t\tlink->source_addr = cpu_to_be32(ssi_sxx_phys);\n\t\t\tlink->source_attr = cpu_to_be32(CCSR_DMA_ATR_NOSNOOP |\n\t\t\t\tupper_32_bits(ssi_sxx_phys));\n\n\t\t\tlink->dest_addr = cpu_to_be32(temp_addr);\n\t\t\tlink->dest_attr = cpu_to_be32(CCSR_DMA_ATR_SNOOP |\n\t\t\t\tupper_32_bits(temp_addr));\n\t\t}\n\n\t\ttemp_addr += period_size;\n\t}\n\n\treturn 0;\n}\n\n \nstatic snd_pcm_uframes_t fsl_dma_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_dma_private *dma_private = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tstruct ccsr_dma_channel __iomem *dma_channel = dma_private->dma_channel;\n\tdma_addr_t position;\n\tsnd_pcm_uframes_t frames;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tposition = in_be32(&dma_channel->sar);\n#ifdef CONFIG_PHYS_64BIT\n\t\tposition |= (u64)(in_be32(&dma_channel->satr) &\n\t\t\t\t  CCSR_DMA_ATR_ESAD_MASK) << 32;\n#endif\n\t} else {\n\t\tposition = in_be32(&dma_channel->dar);\n#ifdef CONFIG_PHYS_64BIT\n\t\tposition |= (u64)(in_be32(&dma_channel->datr) &\n\t\t\t\t  CCSR_DMA_ATR_ESAD_MASK) << 32;\n#endif\n\t}\n\n\t \n\tif (!position)\n\t\treturn 0;\n\n\tif ((position < dma_private->dma_buf_phys) ||\n\t    (position > dma_private->dma_buf_end)) {\n\t\tdev_err(dev, \"dma pointer is out of range, halting stream\\n\");\n\t\treturn SNDRV_PCM_POS_XRUN;\n\t}\n\n\tframes = bytes_to_frames(runtime, position - dma_private->dma_buf_phys);\n\n\t \n\tif (frames == runtime->buffer_size)\n\t\tframes = 0;\n\n\treturn frames;\n}\n\n \nstatic int fsl_dma_hw_free(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_dma_private *dma_private = runtime->private_data;\n\n\tif (dma_private) {\n\t\tstruct ccsr_dma_channel __iomem *dma_channel;\n\n\t\tdma_channel = dma_private->dma_channel;\n\n\t\t \n\t\tout_be32(&dma_channel->mr, CCSR_DMA_MR_CA);\n\t\tout_be32(&dma_channel->mr, 0);\n\n\t\t \n\t\tout_be32(&dma_channel->sr, -1);\n\t\tout_be32(&dma_channel->clndar, 0);\n\t\tout_be32(&dma_channel->eclndar, 0);\n\t\tout_be32(&dma_channel->satr, 0);\n\t\tout_be32(&dma_channel->sar, 0);\n\t\tout_be32(&dma_channel->datr, 0);\n\t\tout_be32(&dma_channel->dar, 0);\n\t\tout_be32(&dma_channel->bcr, 0);\n\t\tout_be32(&dma_channel->nlndar, 0);\n\t\tout_be32(&dma_channel->enlndar, 0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_dma_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_dma_private *dma_private = runtime->private_data;\n\tstruct device *dev = component->dev;\n\tstruct dma_object *dma =\n\t\tcontainer_of(component->driver, struct dma_object, dai);\n\n\tif (dma_private) {\n\t\tif (dma_private->irq)\n\t\t\tfree_irq(dma_private->irq, dma_private);\n\n\t\t \n\t\tdma_free_coherent(dev, sizeof(struct fsl_dma_private),\n\t\t\t\t  dma_private, dma_private->ld_buf_phys);\n\t\tsubstream->runtime->private_data = NULL;\n\t}\n\n\tdma->assigned = false;\n\n\treturn 0;\n}\n\n \nstatic struct device_node *find_ssi_node(struct device_node *dma_channel_np)\n{\n\tstruct device_node *ssi_np, *np;\n\n\tfor_each_compatible_node(ssi_np, NULL, \"fsl,mpc8610-ssi\") {\n\t\t \n\t\tnp = of_parse_phandle(ssi_np, \"fsl,playback-dma\", 0);\n\t\tof_node_put(np);\n\t\tif (np == dma_channel_np)\n\t\t\treturn ssi_np;\n\n\t\tnp = of_parse_phandle(ssi_np, \"fsl,capture-dma\", 0);\n\t\tof_node_put(np);\n\t\tif (np == dma_channel_np)\n\t\t\treturn ssi_np;\n\t}\n\n\treturn NULL;\n}\n\nstatic int fsl_soc_dma_probe(struct platform_device *pdev)\n{\n\tstruct dma_object *dma;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *ssi_np;\n\tstruct resource res;\n\tconst uint32_t *iprop;\n\tint ret;\n\n\t \n\tssi_np = find_ssi_node(np);\n\tif (!ssi_np) {\n\t\tdev_err(&pdev->dev, \"cannot find parent SSI node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_address_to_resource(ssi_np, 0, &res);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not determine resources for %pOF\\n\",\n\t\t\tssi_np);\n\t\tof_node_put(ssi_np);\n\t\treturn ret;\n\t}\n\n\tdma = kzalloc(sizeof(*dma), GFP_KERNEL);\n\tif (!dma) {\n\t\tof_node_put(ssi_np);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma->dai.name = DRV_NAME;\n\tdma->dai.open = fsl_dma_open;\n\tdma->dai.close = fsl_dma_close;\n\tdma->dai.hw_params = fsl_dma_hw_params;\n\tdma->dai.hw_free = fsl_dma_hw_free;\n\tdma->dai.pointer = fsl_dma_pointer;\n\tdma->dai.pcm_construct = fsl_dma_new;\n\n\t \n\tdma->ssi_stx_phys = res.start + REG_SSI_STX0;\n\tdma->ssi_srx_phys = res.start + REG_SSI_SRX0;\n\n\tiprop = of_get_property(ssi_np, \"fsl,fifo-depth\", NULL);\n\tif (iprop)\n\t\tdma->ssi_fifo_depth = be32_to_cpup(iprop);\n\telse\n                 \n\t\tdma->ssi_fifo_depth = 8;\n\n\tof_node_put(ssi_np);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &dma->dai, NULL, 0);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register platform\\n\");\n\t\tkfree(dma);\n\t\treturn ret;\n\t}\n\n\tdma->channel = of_iomap(np, 0);\n\tdma->irq = irq_of_parse_and_map(np, 0);\n\n\tdev_set_drvdata(&pdev->dev, dma);\n\n\treturn 0;\n}\n\nstatic void fsl_soc_dma_remove(struct platform_device *pdev)\n{\n\tstruct dma_object *dma = dev_get_drvdata(&pdev->dev);\n\n\tiounmap(dma->channel);\n\tirq_dispose_mapping(dma->irq);\n\tkfree(dma);\n}\n\nstatic const struct of_device_id fsl_soc_dma_ids[] = {\n\t{ .compatible = \"fsl,ssi-dma-channel\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_soc_dma_ids);\n\nstatic struct platform_driver fsl_soc_dma_driver = {\n\t.driver = {\n\t\t.name = \"fsl-pcm-audio\",\n\t\t.of_match_table = fsl_soc_dma_ids,\n\t},\n\t.probe = fsl_soc_dma_probe,\n\t.remove_new = fsl_soc_dma_remove,\n};\n\nmodule_platform_driver(fsl_soc_dma_driver);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale Elo DMA ASoC PCM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}