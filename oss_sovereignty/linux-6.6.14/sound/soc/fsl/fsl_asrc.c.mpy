{
  "module_name": "fsl_asrc.c",
  "hash_id": "e8ea077117174e6f7bed722fd32afe8ea34f1e69f01389957772e0cc988b0d04",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_asrc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/dma/imx-dma.h>\n#include <linux/pm_runtime.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"fsl_asrc.h\"\n\n#define IDEAL_RATIO_DECIMAL_DEPTH 26\n#define DIVIDER_NUM  64\n#define INIT_RETRY_NUM 50\n\n#define pair_err(fmt, ...) \\\n\tdev_err(&asrc->pdev->dev, \"Pair %c: \" fmt, 'A' + index, ##__VA_ARGS__)\n\n#define pair_dbg(fmt, ...) \\\n\tdev_dbg(&asrc->pdev->dev, \"Pair %c: \" fmt, 'A' + index, ##__VA_ARGS__)\n\n#define pair_warn(fmt, ...) \\\n\tdev_warn(&asrc->pdev->dev, \"Pair %c: \" fmt, 'A' + index, ##__VA_ARGS__)\n\n \nstatic unsigned int supported_asrc_rate[] = {\n\t5512, 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,\n\t64000, 88200, 96000, 128000, 176400, 192000,\n};\n\nstatic struct snd_pcm_hw_constraint_list fsl_asrc_rate_constraints = {\n\t.count = ARRAY_SIZE(supported_asrc_rate),\n\t.list = supported_asrc_rate,\n};\n\n \nstatic unsigned char input_clk_map_imx35[ASRC_CLK_MAP_LEN] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n};\n\nstatic unsigned char output_clk_map_imx35[ASRC_CLK_MAP_LEN] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n};\n\n \nstatic unsigned char input_clk_map_imx53[ASRC_CLK_MAP_LEN] = {\n \n\t0x0, 0x1, 0x2, 0x7, 0x4, 0x5, 0x6, 0x3, 0x8, 0x9, 0xa, 0xb, 0xc, 0xf, 0xe, 0xd,\n\t0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,\n\t0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,\n};\n\nstatic unsigned char output_clk_map_imx53[ASRC_CLK_MAP_LEN] = {\n \n\t0x8, 0x9, 0xa, 0x7, 0xc, 0x5, 0x6, 0xb, 0x0, 0x1, 0x2, 0x3, 0x4, 0xf, 0xe, 0xd,\n\t0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,\n\t0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,\n};\n\n \nstatic unsigned char clk_map_imx8qm[2][ASRC_CLK_MAP_LEN] = {\n\t{\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0,\n\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t},\n\t{\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0,\n\t0x0, 0x1, 0x2, 0x3, 0xb, 0xc, 0xf, 0xf, 0xd, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t0x4, 0x5, 0x6, 0xf, 0x8, 0x9, 0xa, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t},\n};\n\nstatic unsigned char clk_map_imx8qxp[2][ASRC_CLK_MAP_LEN] = {\n\t{\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0,\n\t0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0xf, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xf, 0xf,\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t},\n\t{\n\t0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0,\n\t0x0, 0x1, 0x2, 0x3, 0x7, 0x8, 0xf, 0xf, 0x9, 0xa, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t0xf, 0xf, 0x6, 0xf, 0xf, 0xf, 0xa, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,\n\t},\n};\n\n \nstatic int asrc_clk_divider[DIVIDER_NUM] = {\n\t1,  2,  4,  8,  16,  32,  64,  128,   \n\t2,  4,  8, 16,  32,  64, 128,  256,   \n\t3,  6, 12, 24,  48,  96, 192,  384,   \n\t4,  8, 16, 32,  64, 128, 256,  512,   \n\t5, 10, 20, 40,  80, 160, 320,  640,   \n\t6, 12, 24, 48,  96, 192, 384,  768,   \n\t7, 14, 28, 56, 112, 224, 448,  896,   \n\t8, 16, 32, 64, 128, 256, 512, 1024,   \n};\n\n \nstatic bool fsl_asrc_divider_avail(int clk_rate, int rate, int *div)\n{\n\tu32 rem, i;\n\tu64 n;\n\n\tif (div)\n\t\t*div = 0;\n\n\tif (clk_rate == 0 || rate == 0)\n\t\treturn false;\n\n\tn = clk_rate;\n\trem = do_div(n, rate);\n\n\tif (div)\n\t\t*div = n;\n\n\tif (rem != 0)\n\t\treturn false;\n\n\tfor (i = 0; i < DIVIDER_NUM; i++) {\n\t\tif (n == asrc_clk_divider[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == DIVIDER_NUM)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic void fsl_asrc_sel_proc(int inrate, int outrate,\n\t\t\t     int *pre_proc, int *post_proc)\n{\n\tbool post_proc_cond2;\n\tbool post_proc_cond0;\n\n\t \n\tif (inrate * 8 > 33 * outrate)\n\t\t*pre_proc = 2;\n\telse if (inrate * 8 > 15 * outrate) {\n\t\tif (inrate > 152000)\n\t\t\t*pre_proc = 2;\n\t\telse\n\t\t\t*pre_proc = 1;\n\t} else if (inrate < 76000)\n\t\t*pre_proc = 0;\n\telse if (inrate > 152000)\n\t\t*pre_proc = 2;\n\telse\n\t\t*pre_proc = 1;\n\n\t \n\tpost_proc_cond2 = (inrate * 15 > outrate * 16 && outrate < 56000) ||\n\t\t\t  (inrate > 56000 && outrate < 56000);\n\tpost_proc_cond0 = inrate * 23 < outrate * 8;\n\n\tif (post_proc_cond2)\n\t\t*post_proc = 2;\n\telse if (post_proc_cond0)\n\t\t*post_proc = 0;\n\telse\n\t\t*post_proc = 1;\n}\n\n \nstatic int fsl_asrc_request_pair(int channels, struct fsl_asrc_pair *pair)\n{\n\tenum asrc_pair_index index = ASRC_INVALID_PAIR;\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tstruct device *dev = &asrc->pdev->dev;\n\tunsigned long lock_flags;\n\tint i, ret = 0;\n\n\tspin_lock_irqsave(&asrc->lock, lock_flags);\n\n\tfor (i = ASRC_PAIR_A; i < ASRC_PAIR_MAX_NUM; i++) {\n\t\tif (asrc->pair[i] != NULL)\n\t\t\tcontinue;\n\n\t\tindex = i;\n\n\t\tif (i != ASRC_PAIR_B)\n\t\t\tbreak;\n\t}\n\n\tif (index == ASRC_INVALID_PAIR) {\n\t\tdev_err(dev, \"all pairs are busy now\\n\");\n\t\tret = -EBUSY;\n\t} else if (asrc->channel_avail < channels) {\n\t\tdev_err(dev, \"can't afford required channels: %d\\n\", channels);\n\t\tret = -EINVAL;\n\t} else {\n\t\tasrc->channel_avail -= channels;\n\t\tasrc->pair[index] = pair;\n\t\tpair->channels = channels;\n\t\tpair->index = index;\n\t}\n\n\tspin_unlock_irqrestore(&asrc->lock, lock_flags);\n\n\treturn ret;\n}\n\n \nstatic void fsl_asrc_release_pair(struct fsl_asrc_pair *pair)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\tunsigned long lock_flags;\n\n\t \n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ASRCEi_MASK(index), 0);\n\n\tspin_lock_irqsave(&asrc->lock, lock_flags);\n\n\tasrc->channel_avail += pair->channels;\n\tasrc->pair[index] = NULL;\n\tpair->error = 0;\n\n\tspin_unlock_irqrestore(&asrc->lock, lock_flags);\n}\n\n \nstatic void fsl_asrc_set_watermarks(struct fsl_asrc_pair *pair, u32 in, u32 out)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\n\tregmap_update_bits(asrc->regmap, REG_ASRMCR(index),\n\t\t\t   ASRMCRi_EXTTHRSHi_MASK |\n\t\t\t   ASRMCRi_INFIFO_THRESHOLD_MASK |\n\t\t\t   ASRMCRi_OUTFIFO_THRESHOLD_MASK,\n\t\t\t   ASRMCRi_EXTTHRSHi |\n\t\t\t   ASRMCRi_INFIFO_THRESHOLD(in) |\n\t\t\t   ASRMCRi_OUTFIFO_THRESHOLD(out));\n}\n\n \nstatic u32 fsl_asrc_cal_asrck_divisor(struct fsl_asrc_pair *pair, u32 div)\n{\n\tu32 ps;\n\n\t \n\tfor (ps = 0; div > 8; ps++)\n\t\tdiv >>= 1;\n\n\treturn ((div - 1) << ASRCDRi_AxCPi_WIDTH) | ps;\n}\n\n \nstatic int fsl_asrc_set_ideal_ratio(struct fsl_asrc_pair *pair,\n\t\t\t\t    int inrate, int outrate)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\tunsigned long ratio;\n\tint i;\n\n\tif (!outrate) {\n\t\tpair_err(\"output rate should not be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tratio = (inrate / outrate) << IDEAL_RATIO_DECIMAL_DEPTH;\n\n\t \n\tinrate %= outrate;\n\n\tfor (i = 1; i <= IDEAL_RATIO_DECIMAL_DEPTH; i++) {\n\t\tinrate <<= 1;\n\n\t\tif (inrate < outrate)\n\t\t\tcontinue;\n\n\t\tratio |= 1 << (IDEAL_RATIO_DECIMAL_DEPTH - i);\n\t\tinrate -= outrate;\n\n\t\tif (!inrate)\n\t\t\tbreak;\n\t}\n\n\tregmap_write(asrc->regmap, REG_ASRIDRL(index), ratio);\n\tregmap_write(asrc->regmap, REG_ASRIDRH(index), ratio >> 24);\n\n\treturn 0;\n}\n\n \nstatic int fsl_asrc_config_pair(struct fsl_asrc_pair *pair, bool use_ideal_rate)\n{\n\tstruct fsl_asrc_pair_priv *pair_priv = pair->private;\n\tstruct asrc_config *config = pair_priv->config;\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tstruct fsl_asrc_priv *asrc_priv = asrc->private;\n\tenum asrc_pair_index index = pair->index;\n\tenum asrc_word_width input_word_width;\n\tenum asrc_word_width output_word_width;\n\tu32 inrate, outrate, indiv, outdiv;\n\tu32 clk_index[2], div[2];\n\tu64 clk_rate;\n\tint in, out, channels;\n\tint pre_proc, post_proc;\n\tstruct clk *clk;\n\tbool ideal, div_avail;\n\n\tif (!config) {\n\t\tpair_err(\"invalid pair config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (config->channel_num < 1 || config->channel_num > 10) {\n\t\tpair_err(\"does not support %d channels\\n\", config->channel_num);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (snd_pcm_format_width(config->input_format)) {\n\tcase 8:\n\t\tinput_word_width = ASRC_WIDTH_8_BIT;\n\t\tbreak;\n\tcase 16:\n\t\tinput_word_width = ASRC_WIDTH_16_BIT;\n\t\tbreak;\n\tcase 24:\n\t\tinput_word_width = ASRC_WIDTH_24_BIT;\n\t\tbreak;\n\tdefault:\n\t\tpair_err(\"does not support this input format, %d\\n\",\n\t\t\t config->input_format);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (snd_pcm_format_width(config->output_format)) {\n\tcase 16:\n\t\toutput_word_width = ASRC_WIDTH_16_BIT;\n\t\tbreak;\n\tcase 24:\n\t\toutput_word_width = ASRC_WIDTH_24_BIT;\n\t\tbreak;\n\tdefault:\n\t\tpair_err(\"does not support this output format, %d\\n\",\n\t\t\t config->output_format);\n\t\treturn -EINVAL;\n\t}\n\n\tinrate = config->input_sample_rate;\n\toutrate = config->output_sample_rate;\n\tideal = config->inclk == INCLK_NONE;\n\n\t \n\tfor (in = 0; in < ARRAY_SIZE(supported_asrc_rate); in++)\n\t\tif (inrate == supported_asrc_rate[in])\n\t\t\tbreak;\n\n\tif (in == ARRAY_SIZE(supported_asrc_rate)) {\n\t\tpair_err(\"unsupported input sample rate: %dHz\\n\", inrate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (out = 0; out < ARRAY_SIZE(supported_asrc_rate); out++)\n\t\tif (outrate == supported_asrc_rate[out])\n\t\t\tbreak;\n\n\tif (out == ARRAY_SIZE(supported_asrc_rate)) {\n\t\tpair_err(\"unsupported output sample rate: %dHz\\n\", outrate);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((outrate >= 5512 && outrate <= 30000) &&\n\t    (outrate > 24 * inrate || inrate > 8 * outrate)) {\n\t\tpair_err(\"exceed supported ratio range [1/24, 8] for \\\n\t\t\t\tinrate/outrate: %d/%d\\n\", inrate, outrate);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Validate input and output clock sources */\n\tclk_index[IN] = asrc_priv->clk_map[IN][config->inclk];\n\tclk_index[OUT] = asrc_priv->clk_map[OUT][config->outclk];\n\n\t/* We only have output clock for ideal ratio mode */\n\tclk = asrc_priv->asrck_clk[clk_index[ideal ? OUT : IN]];\n\n\tclk_rate = clk_get_rate(clk);\n\tdiv_avail = fsl_asrc_divider_avail(clk_rate, inrate, &div[IN]);\n\n\t/*\n\t * The divider range is [1, 1024], defined by the hardware. For non-\n\t * ideal ratio configuration, clock rate has to be strictly aligned\n\t * with the sample rate. For ideal ratio configuration, clock rates\n\t * only result in different converting speeds. So remainder does not\n\t * matter, as long as we keep the divider within its valid range.\n\t */\n\tif (div[IN] == 0 || (!ideal && !div_avail)) {\n\t\tpair_err(\"failed to support input sample rate %dHz by asrck_%x\\n\",\n\t\t\t\tinrate, clk_index[ideal ? OUT : IN]);\n\t\treturn -EINVAL;\n\t}\n\n\tdiv[IN] = min_t(u32, 1024, div[IN]);\n\n\tclk = asrc_priv->asrck_clk[clk_index[OUT]];\n\tclk_rate = clk_get_rate(clk);\n\tif (ideal && use_ideal_rate)\n\t\tdiv_avail = fsl_asrc_divider_avail(clk_rate, IDEAL_RATIO_RATE, &div[OUT]);\n\telse\n\t\tdiv_avail = fsl_asrc_divider_avail(clk_rate, outrate, &div[OUT]);\n\n\t/* Output divider has the same limitation as the input one */\n\tif (div[OUT] == 0 || (!ideal && !div_avail)) {\n\t\tpair_err(\"failed to support output sample rate %dHz by asrck_%x\\n\",\n\t\t\t\toutrate, clk_index[OUT]);\n\t\treturn -EINVAL;\n\t}\n\n\tdiv[OUT] = min_t(u32, 1024, div[OUT]);\n\n\t/* Set the channel number */\n\tchannels = config->channel_num;\n\n\tif (asrc_priv->soc->channel_bits < 4)\n\t\tchannels /= 2;\n\n\t/* Update channels for current pair */\n\tregmap_update_bits(asrc->regmap, REG_ASRCNCR,\n\t\t\t   ASRCNCR_ANCi_MASK(index, asrc_priv->soc->channel_bits),\n\t\t\t   ASRCNCR_ANCi(index, channels, asrc_priv->soc->channel_bits));\n\n\t/* Default setting: Automatic selection for processing mode */\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ATSi_MASK(index), ASRCTR_ATS(index));\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_USRi_MASK(index), 0);\n\n\t/* Set the input and output clock sources */\n\tregmap_update_bits(asrc->regmap, REG_ASRCSR,\n\t\t\t   ASRCSR_AICSi_MASK(index) | ASRCSR_AOCSi_MASK(index),\n\t\t\t   ASRCSR_AICS(index, clk_index[IN]) |\n\t\t\t   ASRCSR_AOCS(index, clk_index[OUT]));\n\n\t/* Calculate the input clock divisors */\n\tindiv = fsl_asrc_cal_asrck_divisor(pair, div[IN]);\n\toutdiv = fsl_asrc_cal_asrck_divisor(pair, div[OUT]);\n\n\t/* Suppose indiv and outdiv includes prescaler, so add its MASK too */\n\tregmap_update_bits(asrc->regmap, REG_ASRCDR(index),\n\t\t\t   ASRCDRi_AOCPi_MASK(index) | ASRCDRi_AICPi_MASK(index) |\n\t\t\t   ASRCDRi_AOCDi_MASK(index) | ASRCDRi_AICDi_MASK(index),\n\t\t\t   ASRCDRi_AOCP(index, outdiv) | ASRCDRi_AICP(index, indiv));\n\n\t/* Implement word_width configurations */\n\tregmap_update_bits(asrc->regmap, REG_ASRMCR1(index),\n\t\t\t   ASRMCR1i_OW16_MASK | ASRMCR1i_IWD_MASK,\n\t\t\t   ASRMCR1i_OW16(output_word_width) |\n\t\t\t   ASRMCR1i_IWD(input_word_width));\n\n\t/* Enable BUFFER STALL */\n\tregmap_update_bits(asrc->regmap, REG_ASRMCR(index),\n\t\t\t   ASRMCRi_BUFSTALLi_MASK, ASRMCRi_BUFSTALLi);\n\n\t/* Set default thresholds for input and output FIFO */\n\tfsl_asrc_set_watermarks(pair, ASRC_INPUTFIFO_THRESHOLD,\n\t\t\t\tASRC_INPUTFIFO_THRESHOLD);\n\n\t/* Configure the following only for Ideal Ratio mode */\n\tif (!ideal)\n\t\treturn 0;\n\n\t/* Clear ASTSx bit to use Ideal Ratio mode */\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ATSi_MASK(index), 0);\n\n\t/* Enable Ideal Ratio mode */\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_IDRi_MASK(index) | ASRCTR_USRi_MASK(index),\n\t\t\t   ASRCTR_IDR(index) | ASRCTR_USR(index));\n\n\tfsl_asrc_sel_proc(inrate, outrate, &pre_proc, &post_proc);\n\n\t/* Apply configurations for pre- and post-processing */\n\tregmap_update_bits(asrc->regmap, REG_ASRCFG,\n\t\t\t   ASRCFG_PREMODi_MASK(index) |\tASRCFG_POSTMODi_MASK(index),\n\t\t\t   ASRCFG_PREMOD(index, pre_proc) |\n\t\t\t   ASRCFG_POSTMOD(index, post_proc));\n\n\treturn fsl_asrc_set_ideal_ratio(pair, inrate, outrate);\n}\n\n/**\n * fsl_asrc_start_pair - Start the assigned ASRC pair\n * @pair: pointer to pair\n *\n * It enables the assigned pair and makes it stopped at the stall level.\n */\nstatic void fsl_asrc_start_pair(struct fsl_asrc_pair *pair)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\tint reg, retry = INIT_RETRY_NUM, i;\n\n\t/* Enable the current pair */\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ASRCEi_MASK(index), ASRCTR_ASRCE(index));\n\n\t/* Wait for status of initialization */\n\tdo {\n\t\tudelay(5);\n\t\tregmap_read(asrc->regmap, REG_ASRCFG, &reg);\n\t\treg &= ASRCFG_INIRQi_MASK(index);\n\t} while (!reg && --retry);\n\n\t/* NOTE: Doesn't treat initialization timeout as an error */\n\tif (!retry)\n\t\tpair_warn(\"initialization isn't finished\\n\");\n\n\t/* Make the input fifo to ASRC STALL level */\n\tregmap_read(asrc->regmap, REG_ASRCNCR, &reg);\n\tfor (i = 0; i < pair->channels * 4; i++)\n\t\tregmap_write(asrc->regmap, REG_ASRDI(index), 0);\n\n\t/* Enable overload interrupt */\n\tregmap_write(asrc->regmap, REG_ASRIER, ASRIER_AOLIE);\n}\n\n/**\n * fsl_asrc_stop_pair - Stop the assigned ASRC pair\n * @pair: pointer to pair\n */\nstatic void fsl_asrc_stop_pair(struct fsl_asrc_pair *pair)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\n\t/* Stop the current pair */\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ASRCEi_MASK(index), 0);\n}\n\n/**\n * fsl_asrc_get_dma_channel- Get DMA channel according to the pair and direction.\n * @pair: pointer to pair\n * @dir: DMA direction\n */\nstatic struct dma_chan *fsl_asrc_get_dma_channel(struct fsl_asrc_pair *pair,\n\t\t\t\t\t\t bool dir)\n{\n\tstruct fsl_asrc *asrc = pair->asrc;\n\tenum asrc_pair_index index = pair->index;\n\tchar name[4];\n\n\tsprintf(name, \"%cx%c\", dir == IN ? 'r' : 't', index + 'a');\n\n\treturn dma_request_slave_channel(&asrc->pdev->dev, name);\n}\n\nstatic int fsl_asrc_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct fsl_asrc *asrc = snd_soc_dai_get_drvdata(dai);\n\tstruct fsl_asrc_priv *asrc_priv = asrc->private;\n\n\t \n\tif (asrc_priv->soc->channel_bits == 3)\n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\n\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &fsl_asrc_rate_constraints);\n}\n\n \nstatic void fsl_asrc_select_clk(struct fsl_asrc_priv *asrc_priv,\n\t\t\t\tstruct fsl_asrc_pair *pair,\n\t\t\t\tint in_rate,\n\t\t\t\tint out_rate)\n{\n\tstruct fsl_asrc_pair_priv *pair_priv = pair->private;\n\tstruct asrc_config *config = pair_priv->config;\n\tint rate[2], select_clk[2];  \n\tint clk_rate, clk_index;\n\tint i, j;\n\n\trate[IN] = in_rate;\n\trate[OUT] = out_rate;\n\n\t \n\tfor (j = 0; j < 2; j++) {\n\t\tfor (i = 0; i < ASRC_CLK_MAP_LEN; i++) {\n\t\t\tclk_index = asrc_priv->clk_map[j][i];\n\t\t\tclk_rate = clk_get_rate(asrc_priv->asrck_clk[clk_index]);\n\t\t\t \n\t\t\tif (fsl_asrc_divider_avail(clk_rate, rate[j], NULL))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tselect_clk[j] = i;\n\t}\n\n\t \n\tif (select_clk[IN] == ASRC_CLK_MAP_LEN || select_clk[OUT] == ASRC_CLK_MAP_LEN) {\n\t\tselect_clk[IN] = INCLK_NONE;\n\t\tselect_clk[OUT] = OUTCLK_ASRCK1_CLK;\n\t}\n\n\tconfig->inclk = select_clk[IN];\n\tconfig->outclk = select_clk[OUT];\n}\n\nstatic int fsl_asrc_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct fsl_asrc *asrc = snd_soc_dai_get_drvdata(dai);\n\tstruct fsl_asrc_priv *asrc_priv = asrc->private;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\tstruct fsl_asrc_pair_priv *pair_priv = pair->private;\n\tunsigned int channels = params_channels(params);\n\tunsigned int rate = params_rate(params);\n\tstruct asrc_config config;\n\tint ret;\n\n\tret = fsl_asrc_request_pair(channels, pair);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"fail to request asrc pair\\n\");\n\t\treturn ret;\n\t}\n\n\tpair_priv->config = &config;\n\n\tconfig.pair = pair->index;\n\tconfig.channel_num = channels;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tconfig.input_format   = params_format(params);\n\t\tconfig.output_format  = asrc->asrc_format;\n\t\tconfig.input_sample_rate  = rate;\n\t\tconfig.output_sample_rate = asrc->asrc_rate;\n\t} else {\n\t\tconfig.input_format   = asrc->asrc_format;\n\t\tconfig.output_format  = params_format(params);\n\t\tconfig.input_sample_rate  = asrc->asrc_rate;\n\t\tconfig.output_sample_rate = rate;\n\t}\n\n\tfsl_asrc_select_clk(asrc_priv, pair,\n\t\t\t    config.input_sample_rate,\n\t\t\t    config.output_sample_rate);\n\n\tret = fsl_asrc_config_pair(pair, false);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"fail to config asrc pair\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\n\tif (pair)\n\t\tfsl_asrc_release_pair(pair);\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct fsl_asrc_pair *pair = runtime->private_data;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tfsl_asrc_start_pair(pair);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfsl_asrc_stop_pair(pair);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_asrc_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct fsl_asrc *asrc = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &asrc->dma_params_tx,\n\t\t\t\t  &asrc->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_asrc_dai_ops = {\n\t.probe\t\t= fsl_asrc_dai_probe,\n\t.startup\t= fsl_asrc_dai_startup,\n\t.hw_params\t= fsl_asrc_dai_hw_params,\n\t.hw_free\t= fsl_asrc_dai_hw_free,\n\t.trigger\t= fsl_asrc_dai_trigger,\n};\n\n#define FSL_ASRC_FORMATS\t(SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE)\n\nstatic struct snd_soc_dai_driver fsl_asrc_dai = {\n\t.playback = {\n\t\t.stream_name = \"ASRC-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 10,\n\t\t.rate_min = 5512,\n\t\t.rate_max = 192000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_ASRC_FORMATS |\n\t\t\t   SNDRV_PCM_FMTBIT_S8,\n\t},\n\t.capture = {\n\t\t.stream_name = \"ASRC-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 10,\n\t\t.rate_min = 5512,\n\t\t.rate_max = 192000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_ASRC_FORMATS,\n\t},\n\t.ops = &fsl_asrc_dai_ops,\n};\n\nstatic bool fsl_asrc_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ASRCTR:\n\tcase REG_ASRIER:\n\tcase REG_ASRCNCR:\n\tcase REG_ASRCFG:\n\tcase REG_ASRCSR:\n\tcase REG_ASRCDR1:\n\tcase REG_ASRCDR2:\n\tcase REG_ASRSTR:\n\tcase REG_ASRPM1:\n\tcase REG_ASRPM2:\n\tcase REG_ASRPM3:\n\tcase REG_ASRPM4:\n\tcase REG_ASRPM5:\n\tcase REG_ASRTFR1:\n\tcase REG_ASRCCR:\n\tcase REG_ASRDOA:\n\tcase REG_ASRDOB:\n\tcase REG_ASRDOC:\n\tcase REG_ASRIDRHA:\n\tcase REG_ASRIDRLA:\n\tcase REG_ASRIDRHB:\n\tcase REG_ASRIDRLB:\n\tcase REG_ASRIDRHC:\n\tcase REG_ASRIDRLC:\n\tcase REG_ASR76K:\n\tcase REG_ASR56K:\n\tcase REG_ASRMCRA:\n\tcase REG_ASRFSTA:\n\tcase REG_ASRMCRB:\n\tcase REG_ASRFSTB:\n\tcase REG_ASRMCRC:\n\tcase REG_ASRFSTC:\n\tcase REG_ASRMCR1A:\n\tcase REG_ASRMCR1B:\n\tcase REG_ASRMCR1C:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_asrc_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ASRSTR:\n\tcase REG_ASRDIA:\n\tcase REG_ASRDIB:\n\tcase REG_ASRDIC:\n\tcase REG_ASRDOA:\n\tcase REG_ASRDOB:\n\tcase REG_ASRDOC:\n\tcase REG_ASRFSTA:\n\tcase REG_ASRFSTB:\n\tcase REG_ASRFSTC:\n\tcase REG_ASRCFG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_asrc_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ASRCTR:\n\tcase REG_ASRIER:\n\tcase REG_ASRCNCR:\n\tcase REG_ASRCFG:\n\tcase REG_ASRCSR:\n\tcase REG_ASRCDR1:\n\tcase REG_ASRCDR2:\n\tcase REG_ASRSTR:\n\tcase REG_ASRPM1:\n\tcase REG_ASRPM2:\n\tcase REG_ASRPM3:\n\tcase REG_ASRPM4:\n\tcase REG_ASRPM5:\n\tcase REG_ASRTFR1:\n\tcase REG_ASRCCR:\n\tcase REG_ASRDIA:\n\tcase REG_ASRDIB:\n\tcase REG_ASRDIC:\n\tcase REG_ASRIDRHA:\n\tcase REG_ASRIDRLA:\n\tcase REG_ASRIDRHB:\n\tcase REG_ASRIDRLB:\n\tcase REG_ASRIDRHC:\n\tcase REG_ASRIDRLC:\n\tcase REG_ASR76K:\n\tcase REG_ASR56K:\n\tcase REG_ASRMCRA:\n\tcase REG_ASRMCRB:\n\tcase REG_ASRMCRC:\n\tcase REG_ASRMCR1A:\n\tcase REG_ASRMCR1B:\n\tcase REG_ASRMCR1C:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct reg_default fsl_asrc_reg[] = {\n\t{ REG_ASRCTR, 0x0000 }, { REG_ASRIER, 0x0000 },\n\t{ REG_ASRCNCR, 0x0000 }, { REG_ASRCFG, 0x0000 },\n\t{ REG_ASRCSR, 0x0000 }, { REG_ASRCDR1, 0x0000 },\n\t{ REG_ASRCDR2, 0x0000 }, { REG_ASRSTR, 0x0000 },\n\t{ REG_ASRRA, 0x0000 }, { REG_ASRRB, 0x0000 },\n\t{ REG_ASRRC, 0x0000 }, { REG_ASRPM1, 0x0000 },\n\t{ REG_ASRPM2, 0x0000 }, { REG_ASRPM3, 0x0000 },\n\t{ REG_ASRPM4, 0x0000 }, { REG_ASRPM5, 0x0000 },\n\t{ REG_ASRTFR1, 0x0000 }, { REG_ASRCCR, 0x0000 },\n\t{ REG_ASRDIA, 0x0000 }, { REG_ASRDOA, 0x0000 },\n\t{ REG_ASRDIB, 0x0000 }, { REG_ASRDOB, 0x0000 },\n\t{ REG_ASRDIC, 0x0000 }, { REG_ASRDOC, 0x0000 },\n\t{ REG_ASRIDRHA, 0x0000 }, { REG_ASRIDRLA, 0x0000 },\n\t{ REG_ASRIDRHB, 0x0000 }, { REG_ASRIDRLB, 0x0000 },\n\t{ REG_ASRIDRHC, 0x0000 }, { REG_ASRIDRLC, 0x0000 },\n\t{ REG_ASR76K, 0x0A47 }, { REG_ASR56K, 0x0DF3 },\n\t{ REG_ASRMCRA, 0x0000 }, { REG_ASRFSTA, 0x0000 },\n\t{ REG_ASRMCRB, 0x0000 }, { REG_ASRFSTB, 0x0000 },\n\t{ REG_ASRMCRC, 0x0000 }, { REG_ASRFSTC, 0x0000 },\n\t{ REG_ASRMCR1A, 0x0000 }, { REG_ASRMCR1B, 0x0000 },\n\t{ REG_ASRMCR1C, 0x0000 },\n};\n\nstatic const struct regmap_config fsl_asrc_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = REG_ASRMCR1C,\n\t.reg_defaults = fsl_asrc_reg,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_asrc_reg),\n\t.readable_reg = fsl_asrc_readable_reg,\n\t.volatile_reg = fsl_asrc_volatile_reg,\n\t.writeable_reg = fsl_asrc_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\n \nstatic int fsl_asrc_init(struct fsl_asrc *asrc)\n{\n\tunsigned long ipg_rate;\n\n\t \n\tregmap_write(asrc->regmap, REG_ASRCTR, ASRCTR_ASRCEN);\n\n\t \n\tregmap_write(asrc->regmap, REG_ASRIER, 0x0);\n\n\t \n\tregmap_write(asrc->regmap, REG_ASRPM1, 0x7fffff);\n\tregmap_write(asrc->regmap, REG_ASRPM2, 0x255555);\n\tregmap_write(asrc->regmap, REG_ASRPM3, 0xff7280);\n\tregmap_write(asrc->regmap, REG_ASRPM4, 0xff7280);\n\tregmap_write(asrc->regmap, REG_ASRPM5, 0xff7280);\n\n\t \n\tregmap_update_bits(asrc->regmap, REG_ASRTFR1,\n\t\t\t   ASRTFR1_TF_BASE_MASK, ASRTFR1_TF_BASE(0xfc));\n\n\t \n\tipg_rate = clk_get_rate(asrc->ipg_clk);\n\tregmap_write(asrc->regmap, REG_ASR76K, ipg_rate / 76000);\n\treturn regmap_write(asrc->regmap, REG_ASR56K, ipg_rate / 56000);\n}\n\n \nstatic irqreturn_t fsl_asrc_isr(int irq, void *dev_id)\n{\n\tstruct fsl_asrc *asrc = (struct fsl_asrc *)dev_id;\n\tstruct device *dev = &asrc->pdev->dev;\n\tenum asrc_pair_index index;\n\tu32 status;\n\n\tregmap_read(asrc->regmap, REG_ASRSTR, &status);\n\n\t \n\tregmap_write(asrc->regmap, REG_ASRSTR, ASRSTR_AOLE);\n\n\t \n\tfor (index = ASRC_PAIR_A; index < ASRC_PAIR_MAX_NUM; index++) {\n\t\tif (!asrc->pair[index])\n\t\t\tcontinue;\n\n\t\tif (status & ASRSTR_ATQOL) {\n\t\t\tasrc->pair[index]->error |= ASRC_TASK_Q_OVERLOAD;\n\t\t\tdev_dbg(dev, \"ASRC Task Queue FIFO overload\\n\");\n\t\t}\n\n\t\tif (status & ASRSTR_AOOL(index)) {\n\t\t\tasrc->pair[index]->error |= ASRC_OUTPUT_TASK_OVERLOAD;\n\t\t\tpair_dbg(\"Output Task Overload\\n\");\n\t\t}\n\n\t\tif (status & ASRSTR_AIOL(index)) {\n\t\t\tasrc->pair[index]->error |= ASRC_INPUT_TASK_OVERLOAD;\n\t\t\tpair_dbg(\"Input Task Overload\\n\");\n\t\t}\n\n\t\tif (status & ASRSTR_AODO(index)) {\n\t\t\tasrc->pair[index]->error |= ASRC_OUTPUT_BUFFER_OVERFLOW;\n\t\t\tpair_dbg(\"Output Data Buffer has overflowed\\n\");\n\t\t}\n\n\t\tif (status & ASRSTR_AIDU(index)) {\n\t\t\tasrc->pair[index]->error |= ASRC_INPUT_BUFFER_UNDERRUN;\n\t\t\tpair_dbg(\"Input Data Buffer has underflowed\\n\");\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int fsl_asrc_get_fifo_addr(u8 dir, enum asrc_pair_index index)\n{\n\treturn REG_ASRDx(dir, index);\n}\n\nstatic int fsl_asrc_runtime_resume(struct device *dev);\nstatic int fsl_asrc_runtime_suspend(struct device *dev);\n\nstatic int fsl_asrc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_asrc_priv *asrc_priv;\n\tstruct fsl_asrc *asrc;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint irq, ret, i;\n\tu32 asrc_fmt = 0;\n\tu32 map_idx;\n\tchar tmp[16];\n\tu32 width;\n\n\tasrc = devm_kzalloc(&pdev->dev, sizeof(*asrc), GFP_KERNEL);\n\tif (!asrc)\n\t\treturn -ENOMEM;\n\n\tasrc_priv = devm_kzalloc(&pdev->dev, sizeof(*asrc_priv), GFP_KERNEL);\n\tif (!asrc_priv)\n\t\treturn -ENOMEM;\n\n\tasrc->pdev = pdev;\n\tasrc->private = asrc_priv;\n\n\t \n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tasrc->paddr = res->start;\n\n\tasrc->regmap = devm_regmap_init_mmio(&pdev->dev, regs, &fsl_asrc_regmap_config);\n\tif (IS_ERR(asrc->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to init regmap\\n\");\n\t\treturn PTR_ERR(asrc->regmap);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, fsl_asrc_isr, 0,\n\t\t\t       dev_name(&pdev->dev), asrc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim irq %u: %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tasrc->mem_clk = devm_clk_get(&pdev->dev, \"mem\");\n\tif (IS_ERR(asrc->mem_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get mem clock\\n\");\n\t\treturn PTR_ERR(asrc->mem_clk);\n\t}\n\n\tasrc->ipg_clk = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(asrc->ipg_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get ipg clock\\n\");\n\t\treturn PTR_ERR(asrc->ipg_clk);\n\t}\n\n\tasrc->spba_clk = devm_clk_get(&pdev->dev, \"spba\");\n\tif (IS_ERR(asrc->spba_clk))\n\t\tdev_warn(&pdev->dev, \"failed to get spba clock\\n\");\n\n\tfor (i = 0; i < ASRC_CLK_MAX_NUM; i++) {\n\t\tsprintf(tmp, \"asrck_%x\", i);\n\t\tasrc_priv->asrck_clk[i] = devm_clk_get(&pdev->dev, tmp);\n\t\tif (IS_ERR(asrc_priv->asrck_clk[i])) {\n\t\t\tdev_err(&pdev->dev, \"failed to get %s clock\\n\", tmp);\n\t\t\treturn PTR_ERR(asrc_priv->asrck_clk[i]);\n\t\t}\n\t}\n\n\tasrc_priv->soc = of_device_get_match_data(&pdev->dev);\n\tasrc->use_edma = asrc_priv->soc->use_edma;\n\tasrc->get_dma_channel = fsl_asrc_get_dma_channel;\n\tasrc->request_pair = fsl_asrc_request_pair;\n\tasrc->release_pair = fsl_asrc_release_pair;\n\tasrc->get_fifo_addr = fsl_asrc_get_fifo_addr;\n\tasrc->pair_priv_size = sizeof(struct fsl_asrc_pair_priv);\n\n\tif (of_device_is_compatible(np, \"fsl,imx35-asrc\")) {\n\t\tasrc_priv->clk_map[IN] = input_clk_map_imx35;\n\t\tasrc_priv->clk_map[OUT] = output_clk_map_imx35;\n\t} else if (of_device_is_compatible(np, \"fsl,imx53-asrc\")) {\n\t\tasrc_priv->clk_map[IN] = input_clk_map_imx53;\n\t\tasrc_priv->clk_map[OUT] = output_clk_map_imx53;\n\t} else if (of_device_is_compatible(np, \"fsl,imx8qm-asrc\") ||\n\t\t   of_device_is_compatible(np, \"fsl,imx8qxp-asrc\")) {\n\t\tret = of_property_read_u32(np, \"fsl,asrc-clk-map\", &map_idx);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to get clk map index\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (map_idx > 1) {\n\t\t\tdev_err(&pdev->dev, \"unsupported clk map index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (of_device_is_compatible(np, \"fsl,imx8qm-asrc\")) {\n\t\t\tasrc_priv->clk_map[IN] = clk_map_imx8qm[map_idx];\n\t\t\tasrc_priv->clk_map[OUT] = clk_map_imx8qm[map_idx];\n\t\t} else {\n\t\t\tasrc_priv->clk_map[IN] = clk_map_imx8qxp[map_idx];\n\t\t\tasrc_priv->clk_map[OUT] = clk_map_imx8qxp[map_idx];\n\t\t}\n\t}\n\n\tasrc->channel_avail = 10;\n\n\tret = of_property_read_u32(np, \"fsl,asrc-rate\",\n\t\t\t\t   &asrc->asrc_rate);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to get output rate\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(np, \"fsl,asrc-format\", &asrc_fmt);\n\tasrc->asrc_format = (__force snd_pcm_format_t)asrc_fmt;\n\tif (ret) {\n\t\tret = of_property_read_u32(np, \"fsl,asrc-width\", &width);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to decide output format\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (width) {\n\t\tcase 16:\n\t\t\tasrc->asrc_format = SNDRV_PCM_FORMAT_S16_LE;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tasrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"unsupported width, use default S24_LE\\n\");\n\t\t\tasrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!(FSL_ASRC_FORMATS & pcm_format_to_bits(asrc->asrc_format))) {\n\t\tdev_warn(&pdev->dev, \"unsupported width, use default S24_LE\\n\");\n\t\tasrc->asrc_format = SNDRV_PCM_FORMAT_S24_LE;\n\t}\n\n\tplatform_set_drvdata(pdev, asrc);\n\tspin_lock_init(&asrc->lock);\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = fsl_asrc_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_pm_get_sync;\n\n\tret = fsl_asrc_init(asrc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to init asrc %d\\n\", ret);\n\t\tgoto err_pm_get_sync;\n\t}\n\n\tret = pm_runtime_put_sync(&pdev->dev);\n\tif (ret < 0 && ret != -ENOSYS)\n\t\tgoto err_pm_get_sync;\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &fsl_asrc_component,\n\t\t\t\t\t      &fsl_asrc_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register ASoC DAI\\n\");\n\t\tgoto err_pm_get_sync;\n\t}\n\n\treturn 0;\n\nerr_pm_get_sync:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_asrc_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void fsl_asrc_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_asrc_runtime_suspend(&pdev->dev);\n}\n\nstatic int fsl_asrc_runtime_resume(struct device *dev)\n{\n\tstruct fsl_asrc *asrc = dev_get_drvdata(dev);\n\tstruct fsl_asrc_priv *asrc_priv = asrc->private;\n\tint reg, retry = INIT_RETRY_NUM;\n\tint i, ret;\n\tu32 asrctr;\n\n\tret = clk_prepare_enable(asrc->mem_clk);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_prepare_enable(asrc->ipg_clk);\n\tif (ret)\n\t\tgoto disable_mem_clk;\n\tif (!IS_ERR(asrc->spba_clk)) {\n\t\tret = clk_prepare_enable(asrc->spba_clk);\n\t\tif (ret)\n\t\t\tgoto disable_ipg_clk;\n\t}\n\tfor (i = 0; i < ASRC_CLK_MAX_NUM; i++) {\n\t\tret = clk_prepare_enable(asrc_priv->asrck_clk[i]);\n\t\tif (ret)\n\t\t\tgoto disable_asrck_clk;\n\t}\n\n\t \n\tregmap_read(asrc->regmap, REG_ASRCTR, &asrctr);\n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ASRCEi_ALL_MASK, 0);\n\n\t \n\tregcache_cache_only(asrc->regmap, false);\n\tregcache_mark_dirty(asrc->regmap);\n\tregcache_sync(asrc->regmap);\n\n\tregmap_update_bits(asrc->regmap, REG_ASRCFG,\n\t\t\t   ASRCFG_NDPRi_ALL_MASK | ASRCFG_POSTMODi_ALL_MASK |\n\t\t\t   ASRCFG_PREMODi_ALL_MASK, asrc_priv->regcache_cfg);\n\n\t \n\tregmap_update_bits(asrc->regmap, REG_ASRCTR,\n\t\t\t   ASRCTR_ASRCEi_ALL_MASK, asrctr);\n\n\t \n\tdo {\n\t\tudelay(5);\n\t\tregmap_read(asrc->regmap, REG_ASRCFG, &reg);\n\t\treg = (reg >> ASRCFG_INIRQi_SHIFT(0)) & 0x7;\n\t} while ((reg != ((asrctr >> ASRCTR_ASRCEi_SHIFT(0)) & 0x7)) && --retry);\n\n\t \n\tif (!retry) {\n\t\tfor (i = ASRC_PAIR_A; i < ASRC_PAIR_MAX_NUM; i++) {\n\t\t\tif ((asrctr & ASRCTR_ASRCEi_MASK(i)) && !(reg & (1 << i)))\n\t\t\t\tdev_warn(dev, \"Pair %c initialization isn't finished\\n\", 'A' + i);\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_asrck_clk:\n\tfor (i--; i >= 0; i--)\n\t\tclk_disable_unprepare(asrc_priv->asrck_clk[i]);\n\tif (!IS_ERR(asrc->spba_clk))\n\t\tclk_disable_unprepare(asrc->spba_clk);\ndisable_ipg_clk:\n\tclk_disable_unprepare(asrc->ipg_clk);\ndisable_mem_clk:\n\tclk_disable_unprepare(asrc->mem_clk);\n\treturn ret;\n}\n\nstatic int fsl_asrc_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_asrc *asrc = dev_get_drvdata(dev);\n\tstruct fsl_asrc_priv *asrc_priv = asrc->private;\n\tint i;\n\n\tregmap_read(asrc->regmap, REG_ASRCFG,\n\t\t    &asrc_priv->regcache_cfg);\n\n\tregcache_cache_only(asrc->regmap, true);\n\n\tfor (i = 0; i < ASRC_CLK_MAX_NUM; i++)\n\t\tclk_disable_unprepare(asrc_priv->asrck_clk[i]);\n\tif (!IS_ERR(asrc->spba_clk))\n\t\tclk_disable_unprepare(asrc->spba_clk);\n\tclk_disable_unprepare(asrc->ipg_clk);\n\tclk_disable_unprepare(asrc->mem_clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops fsl_asrc_pm = {\n\tSET_RUNTIME_PM_OPS(fsl_asrc_runtime_suspend, fsl_asrc_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct fsl_asrc_soc_data fsl_asrc_imx35_data = {\n\t.use_edma = false,\n\t.channel_bits = 3,\n};\n\nstatic const struct fsl_asrc_soc_data fsl_asrc_imx53_data = {\n\t.use_edma = false,\n\t.channel_bits = 4,\n};\n\nstatic const struct fsl_asrc_soc_data fsl_asrc_imx8qm_data = {\n\t.use_edma = true,\n\t.channel_bits = 4,\n};\n\nstatic const struct fsl_asrc_soc_data fsl_asrc_imx8qxp_data = {\n\t.use_edma = true,\n\t.channel_bits = 4,\n};\n\nstatic const struct of_device_id fsl_asrc_ids[] = {\n\t{ .compatible = \"fsl,imx35-asrc\", .data = &fsl_asrc_imx35_data },\n\t{ .compatible = \"fsl,imx53-asrc\", .data = &fsl_asrc_imx53_data },\n\t{ .compatible = \"fsl,imx8qm-asrc\", .data = &fsl_asrc_imx8qm_data },\n\t{ .compatible = \"fsl,imx8qxp-asrc\", .data = &fsl_asrc_imx8qxp_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_asrc_ids);\n\nstatic struct platform_driver fsl_asrc_driver = {\n\t.probe = fsl_asrc_probe,\n\t.remove_new = fsl_asrc_remove,\n\t.driver = {\n\t\t.name = \"fsl-asrc\",\n\t\t.of_match_table = fsl_asrc_ids,\n\t\t.pm = &fsl_asrc_pm,\n\t},\n};\nmodule_platform_driver(fsl_asrc_driver);\n\nMODULE_DESCRIPTION(\"Freescale ASRC ASoC driver\");\nMODULE_AUTHOR(\"Nicolin Chen <nicoleotsuka@gmail.com>\");\nMODULE_ALIAS(\"platform:fsl-asrc\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}