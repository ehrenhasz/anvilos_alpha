{
  "module_name": "mpc5200_psc_ac97.c",
  "hash_id": "f54e63e65bbf1ec724542230d7f29c5fdf8f59d91342a3fc9db5c6cc2f1c3fa2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/mpc5200_psc_ac97.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include <linux/delay.h>\n#include <linux/time.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/time.h>\n#include <asm/delay.h>\n#include <asm/mpc52xx.h>\n#include <asm/mpc52xx_psc.h>\n\n#include \"mpc5200_dma.h\"\n\n#define DRV_NAME \"mpc5200-psc-ac97\"\n\n \nstatic struct psc_dma *psc_dma;\n\nstatic unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\n{\n\tint status;\n\tunsigned int val;\n\n\tmutex_lock(&psc_dma->mutex);\n\n\t \n\tstatus = spin_event_timeout(!(in_be16(&psc_dma->psc_regs->sr_csr.status) &\n\t\t\t\tMPC52xx_PSC_SR_CMDSEND), 100, 0);\n\tif (status == 0) {\n\t\tpr_err(\"timeout on ac97 bus (rdy)\\n\");\n\t\tmutex_unlock(&psc_dma->mutex);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tin_be32(&psc_dma->psc_regs->ac97_data);\n\n\t \n\tout_be32(&psc_dma->psc_regs->ac97_cmd, (1<<31) | ((reg & 0x7f) << 24));\n\n\t \n\tstatus = spin_event_timeout((in_be16(&psc_dma->psc_regs->sr_csr.status) &\n\t\t\t\tMPC52xx_PSC_SR_DATA_VAL), 100, 0);\n\tif (status == 0) {\n\t\tpr_err(\"timeout on ac97 read (val) %x\\n\",\n\t\t\t\tin_be16(&psc_dma->psc_regs->sr_csr.status));\n\t\tmutex_unlock(&psc_dma->mutex);\n\t\treturn -ENODEV;\n\t}\n\t \n\tval = in_be32(&psc_dma->psc_regs->ac97_data);\n\tif (((val >> 24) & 0x7f) != reg) {\n\t\tpr_err(\"reg echo error on ac97 read\\n\");\n\t\tmutex_unlock(&psc_dma->mutex);\n\t\treturn -ENODEV;\n\t}\n\tval = (val >> 8) & 0xffff;\n\n\tmutex_unlock(&psc_dma->mutex);\n\treturn (unsigned short) val;\n}\n\nstatic void psc_ac97_write(struct snd_ac97 *ac97,\n\t\t\t\tunsigned short reg, unsigned short val)\n{\n\tint status;\n\n\tmutex_lock(&psc_dma->mutex);\n\n\t \n\tstatus = spin_event_timeout(!(in_be16(&psc_dma->psc_regs->sr_csr.status) &\n\t\t\t\tMPC52xx_PSC_SR_CMDSEND), 100, 0);\n\tif (status == 0) {\n\t\tpr_err(\"timeout on ac97 bus (write)\\n\");\n\t\tgoto out;\n\t}\n\t \n\tout_be32(&psc_dma->psc_regs->ac97_cmd,\n\t\t\t((reg & 0x7f) << 24) | (val << 8));\n\n out:\n\tmutex_unlock(&psc_dma->mutex);\n}\n\nstatic void psc_ac97_warm_reset(struct snd_ac97 *ac97)\n{\n\tstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\n\n\tmutex_lock(&psc_dma->mutex);\n\n\tout_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);\n\tudelay(3);\n\tout_be32(&regs->sicr, psc_dma->sicr);\n\n\tmutex_unlock(&psc_dma->mutex);\n}\n\nstatic void psc_ac97_cold_reset(struct snd_ac97 *ac97)\n{\n\tstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\n\n\tmutex_lock(&psc_dma->mutex);\n\tdev_dbg(psc_dma->dev, \"cold reset\\n\");\n\n\tmpc5200_psc_ac97_gpio_reset(psc_dma->id);\n\n\t \n\tout_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_ACRB);\n\n\t \n\tout_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\n\n\tmutex_unlock(&psc_dma->mutex);\n\n\tusleep_range(1000, 2000);\n\tpsc_ac97_warm_reset(ac97);\n}\n\nstatic struct snd_ac97_bus_ops psc_ac97_ops = {\n\t.read\t\t= psc_ac97_read,\n\t.write\t\t= psc_ac97_write,\n\t.reset\t\t= psc_ac97_cold_reset,\n\t.warm_reset\t= psc_ac97_warm_reset,\n};\n\nstatic int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct psc_dma_stream *s = to_psc_dma_stream(substream, psc_dma);\n\n\tdev_dbg(psc_dma->dev, \"%s(substream=%p) p_size=%i p_bytes=%i\"\n\t\t\" periods=%i buffer_size=%i  buffer_bytes=%i channels=%i\"\n\t\t\" rate=%i format=%i\\n\",\n\t\t__func__, substream, params_period_size(params),\n\t\tparams_period_bytes(params), params_periods(params),\n\t\tparams_buffer_size(params), params_buffer_bytes(params),\n\t\tparams_channels(params), params_rate(params),\n\t\tparams_format(params));\n\n\t \n\ts->ac97_slot_bits = (params_channels(params) == 1) ? 0x100 : 0x300;\n\tif (substream->pstr->stream != SNDRV_PCM_STREAM_CAPTURE)\n\t\ts->ac97_slot_bits <<= 16;\n\treturn 0;\n}\n\nstatic int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tdev_dbg(psc_dma->dev, \"%s(substream=%p)\\n\", __func__, substream);\n\n\tif (params_channels(params) == 1)\n\t\tout_be32(&psc_dma->psc_regs->ac97_slots, 0x01000000);\n\telse\n\t\tout_be32(&psc_dma->psc_regs->ac97_slots, 0x03000000);\n\n\treturn 0;\n}\n\nstatic int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(dai);\n\tstruct psc_dma_stream *s = to_psc_dma_stream(substream, psc_dma);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdev_dbg(psc_dma->dev, \"AC97 START: stream=%i\\n\",\n\t\t\tsubstream->pstr->stream);\n\n\t\t \n\t\tpsc_dma->slots |= s->ac97_slot_bits;\n\t\tout_be32(&psc_dma->psc_regs->ac97_slots, psc_dma->slots);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(psc_dma->dev, \"AC97 STOP: stream=%i\\n\",\n\t\t\tsubstream->pstr->stream);\n\n\t\t \n\t\tpsc_dma->slots &= ~(s->ac97_slot_bits);\n\t\tout_be32(&psc_dma->psc_regs->ac97_slots, psc_dma->slots);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int psc_ac97_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\n\n\t \n\tout_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\n\treturn 0;\n}\n\n \n\n \nstatic const struct snd_soc_dai_ops psc_ac97_analog_ops = {\n\t.probe\t\t= psc_ac97_probe,\n\t.hw_params\t= psc_ac97_hw_analog_params,\n\t.trigger\t= psc_ac97_trigger,\n};\n\nstatic const struct snd_soc_dai_ops psc_ac97_digital_ops = {\n\t.hw_params\t= psc_ac97_hw_digital_params,\n};\n\nstatic struct snd_soc_dai_driver psc_ac97_dai[] = {\n{\n\t.name = \"mpc5200-psc-ac97.0\",\n\t.playback = {\n\t\t.stream_name\t= \"AC97 Playback\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 6,\n\t\t.rates          = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_BE,\n\t},\n\t.capture = {\n\t\t.stream_name\t= \"AC97 Capture\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 2,\n\t\t.rates          = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_BE,\n\t},\n\t.ops = &psc_ac97_analog_ops,\n},\n{\n\t.name = \"mpc5200-psc-ac97.1\",\n\t.playback = {\n\t\t.stream_name\t= \"AC97 SPDIF\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 2,\n\t\t.rates          = SNDRV_PCM_RATE_32000 | \\\n\t\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_BE,\n\t},\n\t.ops = &psc_ac97_digital_ops,\n} };\n\nstatic const struct snd_soc_component_driver psc_ac97_component = {\n\t.name\t\t= DRV_NAME,\n};\n\n\n \nstatic int psc_ac97_of_probe(struct platform_device *op)\n{\n\tint rc;\n\tstruct mpc52xx_psc __iomem *regs;\n\n\trc = mpc5200_audio_dma_create(op);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = snd_soc_set_ac97_ops(&psc_ac97_ops);\n\tif (rc != 0) {\n\t\tdev_err(&op->dev, \"Failed to set AC'97 ops: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\trc = snd_soc_register_component(&op->dev, &psc_ac97_component,\n\t\t\t\t\tpsc_ac97_dai, ARRAY_SIZE(psc_ac97_dai));\n\tif (rc != 0) {\n\t\tdev_err(&op->dev, \"Failed to register DAI\\n\");\n\t\treturn rc;\n\t}\n\n\tpsc_dma = dev_get_drvdata(&op->dev);\n\tregs = psc_dma->psc_regs;\n\n\tpsc_dma->imr = 0;\n\tout_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);\n\n\t \n\tpsc_dma->sicr = MPC52xx_PSC_SICR_SIM_AC97 | MPC52xx_PSC_SICR_ENAC97;\n\tout_be32(&regs->sicr, psc_dma->sicr);\n\n\t \n\tout_be32(&regs->ac97_slots, 0x00000000);\n\n\treturn 0;\n}\n\nstatic void psc_ac97_of_remove(struct platform_device *op)\n{\n\tmpc5200_audio_dma_destroy(op);\n\tsnd_soc_unregister_component(&op->dev);\n\tsnd_soc_set_ac97_ops(NULL);\n}\n\n \nstatic const struct of_device_id psc_ac97_match[] = {\n\t{ .compatible = \"fsl,mpc5200-psc-ac97\", },\n\t{ .compatible = \"fsl,mpc5200b-psc-ac97\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, psc_ac97_match);\n\nstatic struct platform_driver psc_ac97_driver = {\n\t.probe = psc_ac97_of_probe,\n\t.remove_new = psc_ac97_of_remove,\n\t.driver = {\n\t\t.name = \"mpc5200-psc-ac97\",\n\t\t.of_match_table = psc_ac97_match,\n\t},\n};\n\nmodule_platform_driver(psc_ac97_driver);\n\nMODULE_AUTHOR(\"Jon Smirl <jonsmirl@gmail.com>\");\nMODULE_DESCRIPTION(\"mpc5200 AC97 module\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}