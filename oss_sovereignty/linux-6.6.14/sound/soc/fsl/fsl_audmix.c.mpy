{
  "module_name": "fsl_audmix.c",
  "hash_id": "ed2f7c29a787326b9831ea450ea0b5d797d3dc4fcbd1e16b30d10909da84bfff",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_audmix.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n\n#include \"fsl_audmix.h\"\n\n#define SOC_ENUM_SINGLE_S(xreg, xshift, xtexts) \\\n\tSOC_ENUM_SINGLE(xreg, xshift, ARRAY_SIZE(xtexts), xtexts)\n\nstatic const char\n\t*tdm_sel[] = { \"TDM1\", \"TDM2\", },\n\t*mode_sel[] = { \"Disabled\", \"TDM1\", \"TDM2\", \"Mixed\", },\n\t*width_sel[] = { \"16b\", \"18b\", \"20b\", \"24b\", \"32b\", },\n\t*endis_sel[] = { \"Disabled\", \"Enabled\", },\n\t*updn_sel[] = { \"Downward\", \"Upward\", },\n\t*mask_sel[] = { \"Unmask\", \"Mask\", };\n\nstatic const struct soc_enum fsl_audmix_enum[] = {\n \nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_MIXCLK_SHIFT, tdm_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_OUTSRC_SHIFT, mode_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_OUTWIDTH_SHIFT, width_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_MASKRTDF_SHIFT, mask_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_MASKCKDF_SHIFT, mask_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_SYNCMODE_SHIFT, endis_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_CTR, FSL_AUDMIX_CTR_SYNCSRC_SHIFT, tdm_sel),\n \nSOC_ENUM_SINGLE_S(FSL_AUDMIX_ATCR0, 0, endis_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_ATCR0, 1, updn_sel),\n \nSOC_ENUM_SINGLE_S(FSL_AUDMIX_ATCR1, 0, endis_sel),\nSOC_ENUM_SINGLE_S(FSL_AUDMIX_ATCR1, 1, updn_sel),\n};\n\nstruct fsl_audmix_state {\n\tu8 tdms;\n\tu8 clk;\n\tchar msg[64];\n};\n\nstatic const struct fsl_audmix_state prms[4][4] = {{\n\t \n\t{ .tdms = 0, .clk = 0, .msg = \"\" },\n\t \n\t{ .tdms = 1, .clk = 1, .msg = \"DIS->TDM1: TDM1 not started!\\n\" },\n\t \n\t{ .tdms = 2, .clk = 2, .msg = \"DIS->TDM2: TDM2 not started!\\n\" },\n\t \n\t{ .tdms = 3, .clk = 0, .msg = \"DIS->MIX: Please start both TDMs!\\n\" }\n}, {\t \n\t{ .tdms = 1, .clk = 0, .msg = \"TDM1->DIS: TDM1 not started!\\n\" },\n\t \n\t{ .tdms = 0, .clk = 0, .msg = \"\" },\n\t \n\t{ .tdms = 3, .clk = 2, .msg = \"TDM1->TDM2: Please start both TDMs!\\n\" },\n\t \n\t{ .tdms = 3, .clk = 0, .msg = \"TDM1->MIX: Please start both TDMs!\\n\" }\n}, {\t \n\t{ .tdms = 2, .clk = 0, .msg = \"TDM2->DIS: TDM2 not started!\\n\" },\n\t \n\t{ .tdms = 3, .clk = 1, .msg = \"TDM2->TDM1: Please start both TDMs!\\n\" },\n\t \n\t{ .tdms = 0, .clk = 0, .msg = \"\" },\n\t \n\t{ .tdms = 3, .clk = 0, .msg = \"TDM2->MIX: Please start both TDMs!\\n\" }\n}, {\t \n\t{ .tdms = 3, .clk = 0, .msg = \"MIX->DIS: Please start both TDMs!\\n\" },\n\t \n\t{ .tdms = 3, .clk = 1, .msg = \"MIX->TDM1: Please start both TDMs!\\n\" },\n\t \n\t{ .tdms = 3, .clk = 2, .msg = \"MIX->TDM2: Please start both TDMs!\\n\" },\n\t \n\t{ .tdms = 0, .clk = 0, .msg = \"\" }\n}, };\n\nstatic int fsl_audmix_state_trans(struct snd_soc_component *comp,\n\t\t\t\t  unsigned int *mask, unsigned int *ctr,\n\t\t\t\t  const struct fsl_audmix_state prm)\n{\n\tstruct fsl_audmix *priv = snd_soc_component_get_drvdata(comp);\n\t \n\tif ((priv->tdms & prm.tdms) != prm.tdms) {\n\t\tdev_dbg(comp->dev, \"%s\", prm.msg);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (prm.clk) {\n\tcase 1:\n\tcase 2:\n\t\t \n\t\t(*mask) |= FSL_AUDMIX_CTR_MIXCLK_MASK;\n\t\t(*ctr)  |= FSL_AUDMIX_CTR_MIXCLK(prm.clk - 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_audmix_put_mix_clk_src(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_audmix *priv = snd_soc_component_get_drvdata(comp);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int reg_val, val, mix_clk;\n\n\t \n\treg_val = snd_soc_component_read(comp, FSL_AUDMIX_CTR);\n\tmix_clk = ((reg_val & FSL_AUDMIX_CTR_MIXCLK_MASK)\n\t\t\t>> FSL_AUDMIX_CTR_MIXCLK_SHIFT);\n\tval = snd_soc_enum_item_to_val(e, item[0]);\n\n\tdev_dbg(comp->dev, \"TDMs=x%08x, val=x%08x\\n\", priv->tdms, val);\n\n\t \n\tif (!(priv->tdms & BIT(mix_clk))) {\n\t\tdev_err(comp->dev,\n\t\t\t\"Started TDM%d needed for config propagation!\\n\",\n\t\t\tmix_clk + 1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(priv->tdms & BIT(val))) {\n\t\tdev_err(comp->dev,\n\t\t\t\"The selected clock source has no TDM%d enabled!\\n\",\n\t\t\tval + 1);\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_put_enum_double(kcontrol, ucontrol);\n}\n\nstatic int fsl_audmix_put_out_src(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_audmix *priv = snd_soc_component_get_drvdata(comp);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tu32 out_src, mix_clk;\n\tunsigned int reg_val, val, mask = 0, ctr = 0;\n\tint ret;\n\n\t \n\treg_val = snd_soc_component_read(comp, FSL_AUDMIX_CTR);\n\n\t \n\tout_src = ((reg_val & FSL_AUDMIX_CTR_OUTSRC_MASK)\n\t\t\t>> FSL_AUDMIX_CTR_OUTSRC_SHIFT);\n\tmix_clk = ((reg_val & FSL_AUDMIX_CTR_MIXCLK_MASK)\n\t\t\t>> FSL_AUDMIX_CTR_MIXCLK_SHIFT);\n\n\t \n\tval = snd_soc_enum_item_to_val(e, item[0]);\n\n\tdev_dbg(comp->dev, \"TDMs=x%08x, val=x%08x\\n\", priv->tdms, val);\n\n\t \n\tif (out_src == val)\n\t\treturn 0;\n\t \n\tif (!(priv->tdms & BIT(mix_clk))) {\n\t\tdev_err(comp->dev,\n\t\t\t\"Started TDM%d needed for config propagation!\\n\",\n\t\t\tmix_clk + 1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = fsl_audmix_state_trans(comp, &mask, &ctr, prms[out_src][val]);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask |= FSL_AUDMIX_CTR_OUTSRC_MASK;\n\tctr  |= FSL_AUDMIX_CTR_OUTSRC(val);\n\n\treturn snd_soc_component_update_bits(comp, FSL_AUDMIX_CTR, mask, ctr);\n}\n\nstatic const struct snd_kcontrol_new fsl_audmix_snd_controls[] = {\n\t \n\tSOC_ENUM_EXT(\"Mixing Clock Source\", fsl_audmix_enum[0],\n\t\t     snd_soc_get_enum_double, fsl_audmix_put_mix_clk_src),\n\tSOC_ENUM_EXT(\"Output Source\", fsl_audmix_enum[1],\n\t\t     snd_soc_get_enum_double, fsl_audmix_put_out_src),\n\tSOC_ENUM(\"Output Width\", fsl_audmix_enum[2]),\n\tSOC_ENUM(\"Frame Rate Diff Error\", fsl_audmix_enum[3]),\n\tSOC_ENUM(\"Clock Freq Diff Error\", fsl_audmix_enum[4]),\n\tSOC_ENUM(\"Sync Mode Config\", fsl_audmix_enum[5]),\n\tSOC_ENUM(\"Sync Mode Clk Source\", fsl_audmix_enum[6]),\n\t \n\tSOC_ENUM(\"TDM1 Attenuation\", fsl_audmix_enum[7]),\n\tSOC_ENUM(\"TDM1 Attenuation Direction\", fsl_audmix_enum[8]),\n\tSOC_SINGLE(\"TDM1 Attenuation Step Divider\", FSL_AUDMIX_ATCR0,\n\t\t   2, 0x00fff, 0),\n\tSOC_SINGLE(\"TDM1 Attenuation Initial Value\", FSL_AUDMIX_ATIVAL0,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM1 Attenuation Step Up Factor\", FSL_AUDMIX_ATSTPUP0,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM1 Attenuation Step Down Factor\", FSL_AUDMIX_ATSTPDN0,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM1 Attenuation Step Target\", FSL_AUDMIX_ATSTPTGT0,\n\t\t   0, 0x3ffff, 0),\n\t \n\tSOC_ENUM(\"TDM2 Attenuation\", fsl_audmix_enum[9]),\n\tSOC_ENUM(\"TDM2 Attenuation Direction\", fsl_audmix_enum[10]),\n\tSOC_SINGLE(\"TDM2 Attenuation Step Divider\", FSL_AUDMIX_ATCR1,\n\t\t   2, 0x00fff, 0),\n\tSOC_SINGLE(\"TDM2 Attenuation Initial Value\", FSL_AUDMIX_ATIVAL1,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM2 Attenuation Step Up Factor\", FSL_AUDMIX_ATSTPUP1,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM2 Attenuation Step Down Factor\", FSL_AUDMIX_ATSTPDN1,\n\t\t   0, 0x3ffff, 0),\n\tSOC_SINGLE(\"TDM2 Attenuation Step Target\", FSL_AUDMIX_ATSTPTGT1,\n\t\t   0, 0x3ffff, 0),\n};\n\nstatic int fsl_audmix_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tu32 mask = 0, ctr = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tctr |= FSL_AUDMIX_CTR_OUTCKPOL(0);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tctr |= FSL_AUDMIX_CTR_OUTCKPOL(1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask |= FSL_AUDMIX_CTR_OUTCKPOL_MASK;\n\n\treturn snd_soc_component_update_bits(comp, FSL_AUDMIX_CTR, mask, ctr);\n}\n\nstatic int fsl_audmix_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct fsl_audmix *priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned long lock_flags;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&priv->lock, lock_flags);\n\t\tpriv->tdms |= BIT(dai->driver->id);\n\t\tspin_unlock_irqrestore(&priv->lock, lock_flags);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&priv->lock, lock_flags);\n\t\tpriv->tdms &= ~BIT(dai->driver->id);\n\t\tspin_unlock_irqrestore(&priv->lock, lock_flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_audmix_dai_ops = {\n\t.set_fmt  = fsl_audmix_dai_set_fmt,\n\t.trigger      = fsl_audmix_dai_trigger,\n};\n\nstatic struct snd_soc_dai_driver fsl_audmix_dai[] = {\n\t{\n\t\t.id   = 0,\n\t\t.name = \"audmix-0\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AUDMIX-Playback-0\",\n\t\t\t.channels_min = 8,\n\t\t\t.channels_max = 8,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 96000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = FSL_AUDMIX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AUDMIX-Capture-0\",\n\t\t\t.channels_min = 8,\n\t\t\t.channels_max = 8,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 96000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = FSL_AUDMIX_FORMATS,\n\t\t},\n\t\t.ops = &fsl_audmix_dai_ops,\n\t},\n\t{\n\t\t.id   = 1,\n\t\t.name = \"audmix-1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AUDMIX-Playback-1\",\n\t\t\t.channels_min = 8,\n\t\t\t.channels_max = 8,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 96000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = FSL_AUDMIX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AUDMIX-Capture-1\",\n\t\t\t.channels_min = 8,\n\t\t\t.channels_max = 8,\n\t\t\t.rate_min = 8000,\n\t\t\t.rate_max = 96000,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = FSL_AUDMIX_FORMATS,\n\t\t},\n\t\t.ops = &fsl_audmix_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver fsl_audmix_component = {\n\t.name\t\t  = \"fsl-audmix-dai\",\n\t.controls\t  = fsl_audmix_snd_controls,\n\t.num_controls\t  = ARRAY_SIZE(fsl_audmix_snd_controls),\n};\n\nstatic bool fsl_audmix_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase FSL_AUDMIX_CTR:\n\tcase FSL_AUDMIX_STR:\n\tcase FSL_AUDMIX_ATCR0:\n\tcase FSL_AUDMIX_ATIVAL0:\n\tcase FSL_AUDMIX_ATSTPUP0:\n\tcase FSL_AUDMIX_ATSTPDN0:\n\tcase FSL_AUDMIX_ATSTPTGT0:\n\tcase FSL_AUDMIX_ATTNVAL0:\n\tcase FSL_AUDMIX_ATSTP0:\n\tcase FSL_AUDMIX_ATCR1:\n\tcase FSL_AUDMIX_ATIVAL1:\n\tcase FSL_AUDMIX_ATSTPUP1:\n\tcase FSL_AUDMIX_ATSTPDN1:\n\tcase FSL_AUDMIX_ATSTPTGT1:\n\tcase FSL_AUDMIX_ATTNVAL1:\n\tcase FSL_AUDMIX_ATSTP1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_audmix_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase FSL_AUDMIX_CTR:\n\tcase FSL_AUDMIX_ATCR0:\n\tcase FSL_AUDMIX_ATIVAL0:\n\tcase FSL_AUDMIX_ATSTPUP0:\n\tcase FSL_AUDMIX_ATSTPDN0:\n\tcase FSL_AUDMIX_ATSTPTGT0:\n\tcase FSL_AUDMIX_ATCR1:\n\tcase FSL_AUDMIX_ATIVAL1:\n\tcase FSL_AUDMIX_ATSTPUP1:\n\tcase FSL_AUDMIX_ATSTPDN1:\n\tcase FSL_AUDMIX_ATSTPTGT1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default fsl_audmix_reg[] = {\n\t{ FSL_AUDMIX_CTR,       0x00060 },\n\t{ FSL_AUDMIX_STR,       0x00003 },\n\t{ FSL_AUDMIX_ATCR0,     0x00000 },\n\t{ FSL_AUDMIX_ATIVAL0,   0x3FFFF },\n\t{ FSL_AUDMIX_ATSTPUP0,  0x2AAAA },\n\t{ FSL_AUDMIX_ATSTPDN0,  0x30000 },\n\t{ FSL_AUDMIX_ATSTPTGT0, 0x00010 },\n\t{ FSL_AUDMIX_ATTNVAL0,  0x00000 },\n\t{ FSL_AUDMIX_ATSTP0,    0x00000 },\n\t{ FSL_AUDMIX_ATCR1,     0x00000 },\n\t{ FSL_AUDMIX_ATIVAL1,   0x3FFFF },\n\t{ FSL_AUDMIX_ATSTPUP1,  0x2AAAA },\n\t{ FSL_AUDMIX_ATSTPDN1,  0x30000 },\n\t{ FSL_AUDMIX_ATSTPTGT1, 0x00010 },\n\t{ FSL_AUDMIX_ATTNVAL1,  0x00000 },\n\t{ FSL_AUDMIX_ATSTP1,    0x00000 },\n};\n\nstatic const struct regmap_config fsl_audmix_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = FSL_AUDMIX_ATSTP1,\n\t.reg_defaults = fsl_audmix_reg,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_audmix_reg),\n\t.readable_reg = fsl_audmix_readable_reg,\n\t.writeable_reg = fsl_audmix_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic const struct of_device_id fsl_audmix_ids[] = {\n\t{\n\t\t.compatible = \"fsl,imx8qm-audmix\",\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_audmix_ids);\n\nstatic int fsl_audmix_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fsl_audmix *priv;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tpriv->regmap = devm_regmap_init_mmio(dev, regs, &fsl_audmix_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(dev, \"failed to init regmap\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->ipg_clk = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(priv->ipg_clk)) {\n\t\tdev_err(dev, \"failed to get ipg clock\\n\");\n\t\treturn PTR_ERR(priv->ipg_clk);\n\t}\n\n\tspin_lock_init(&priv->lock);\n\tplatform_set_drvdata(pdev, priv);\n\tpm_runtime_enable(dev);\n\n\tret = devm_snd_soc_register_component(dev, &fsl_audmix_component,\n\t\t\t\t\t      fsl_audmix_dai,\n\t\t\t\t\t      ARRAY_SIZE(fsl_audmix_dai));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register ASoC DAI\\n\");\n\t\tgoto err_disable_pm;\n\t}\n\n\tpriv->pdev = platform_device_register_data(dev, \"imx-audmix\", 0, NULL, 0);\n\tif (IS_ERR(priv->pdev)) {\n\t\tret = PTR_ERR(priv->pdev);\n\t\tdev_err(dev, \"failed to register platform: %d\\n\", ret);\n\t\tgoto err_disable_pm;\n\t}\n\n\treturn 0;\n\nerr_disable_pm:\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void fsl_audmix_remove(struct platform_device *pdev)\n{\n\tstruct fsl_audmix *priv = dev_get_drvdata(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tif (priv->pdev)\n\t\tplatform_device_unregister(priv->pdev);\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_audmix_runtime_resume(struct device *dev)\n{\n\tstruct fsl_audmix *priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable IPG clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(priv->regmap, false);\n\tregcache_mark_dirty(priv->regmap);\n\n\treturn regcache_sync(priv->regmap);\n}\n\nstatic int fsl_audmix_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_audmix *priv = dev_get_drvdata(dev);\n\n\tregcache_cache_only(priv->regmap, true);\n\n\tclk_disable_unprepare(priv->ipg_clk);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops fsl_audmix_pm = {\n\tSET_RUNTIME_PM_OPS(fsl_audmix_runtime_suspend,\n\t\t\t   fsl_audmix_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_audmix_driver = {\n\t.probe = fsl_audmix_probe,\n\t.remove_new = fsl_audmix_remove,\n\t.driver = {\n\t\t.name = \"fsl-audmix\",\n\t\t.of_match_table = fsl_audmix_ids,\n\t\t.pm = &fsl_audmix_pm,\n\t},\n};\nmodule_platform_driver(fsl_audmix_driver);\n\nMODULE_DESCRIPTION(\"NXP AUDMIX ASoC DAI driver\");\nMODULE_AUTHOR(\"Viorel Suman <viorel.suman@nxp.com>\");\nMODULE_ALIAS(\"platform:fsl-audmix\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}