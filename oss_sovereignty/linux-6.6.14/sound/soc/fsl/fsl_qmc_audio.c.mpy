{
  "module_name": "fsl_qmc_audio.c",
  "hash_id": "6edb2d6005b59c62463b0d0004802d117ebe55855134ff32c31280df99cfbd62",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_qmc_audio.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <soc/fsl/qe/qmc.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\nstruct qmc_dai {\n\tchar *name;\n\tint id;\n\tstruct device *dev;\n\tstruct qmc_chan *qmc_chan;\n\tunsigned int nb_tx_ts;\n\tunsigned int nb_rx_ts;\n};\n\nstruct qmc_audio {\n\tstruct device *dev;\n\tunsigned int num_dais;\n\tstruct qmc_dai *dais;\n\tstruct snd_soc_dai_driver *dai_drivers;\n};\n\nstruct qmc_dai_prtd {\n\tstruct qmc_dai *qmc_dai;\n\tdma_addr_t dma_buffer_start;\n\tdma_addr_t period_ptr_submitted;\n\tdma_addr_t period_ptr_ended;\n\tdma_addr_t dma_buffer_end;\n\tsize_t period_size;\n\tstruct snd_pcm_substream *substream;\n};\n\nstatic int qmc_audio_pcm_construct(struct snd_soc_component *component,\n\t\t\t\t   struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t       64*1024, 64*1024);\n\treturn 0;\n}\n\nstatic int qmc_audio_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t\t   struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct qmc_dai_prtd *prtd = substream->runtime->private_data;\n\n\tprtd->dma_buffer_start = runtime->dma_addr;\n\tprtd->dma_buffer_end = runtime->dma_addr + params_buffer_bytes(params);\n\tprtd->period_size = params_period_bytes(params);\n\tprtd->period_ptr_submitted = prtd->dma_buffer_start;\n\tprtd->period_ptr_ended = prtd->dma_buffer_start;\n\tprtd->substream = substream;\n\n\treturn 0;\n}\n\nstatic void qmc_audio_pcm_write_complete(void *context)\n{\n\tstruct qmc_dai_prtd *prtd = context;\n\tint ret;\n\n\tprtd->period_ptr_ended += prtd->period_size;\n\tif (prtd->period_ptr_ended >= prtd->dma_buffer_end)\n\t\tprtd->period_ptr_ended = prtd->dma_buffer_start;\n\n\tprtd->period_ptr_submitted += prtd->period_size;\n\tif (prtd->period_ptr_submitted >= prtd->dma_buffer_end)\n\t\tprtd->period_ptr_submitted = prtd->dma_buffer_start;\n\n\tret = qmc_chan_write_submit(prtd->qmc_dai->qmc_chan,\n\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\tqmc_audio_pcm_write_complete, prtd);\n\tif (ret) {\n\t\tdev_err(prtd->qmc_dai->dev, \"write_submit failed %d\\n\",\n\t\t\tret);\n\t}\n\n\tsnd_pcm_period_elapsed(prtd->substream);\n}\n\nstatic void qmc_audio_pcm_read_complete(void *context, size_t length)\n{\n\tstruct qmc_dai_prtd *prtd = context;\n\tint ret;\n\n\tif (length != prtd->period_size) {\n\t\tdev_err(prtd->qmc_dai->dev, \"read complete length = %zu, exp %zu\\n\",\n\t\t\tlength, prtd->period_size);\n\t}\n\n\tprtd->period_ptr_ended += prtd->period_size;\n\tif (prtd->period_ptr_ended >= prtd->dma_buffer_end)\n\t\tprtd->period_ptr_ended = prtd->dma_buffer_start;\n\n\tprtd->period_ptr_submitted += prtd->period_size;\n\tif (prtd->period_ptr_submitted >= prtd->dma_buffer_end)\n\t\tprtd->period_ptr_submitted = prtd->dma_buffer_start;\n\n\tret = qmc_chan_read_submit(prtd->qmc_dai->qmc_chan,\n\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\tqmc_audio_pcm_read_complete, prtd);\n\tif (ret) {\n\t\tdev_err(prtd->qmc_dai->dev, \"read_submit failed %d\\n\",\n\t\t\tret);\n\t}\n\n\tsnd_pcm_period_elapsed(prtd->substream);\n}\n\nstatic int qmc_audio_pcm_trigger(struct snd_soc_component *component,\n\t\t\t\t struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct qmc_dai_prtd *prtd = substream->runtime->private_data;\n\tint ret;\n\n\tif (!prtd->qmc_dai) {\n\t\tdev_err(component->dev, \"qmc_dai is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\t \n\t\t\tret = qmc_chan_write_submit(prtd->qmc_dai->qmc_chan,\n\t\t\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\t\t\tqmc_audio_pcm_write_complete, prtd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev, \"write_submit failed %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tprtd->period_ptr_submitted += prtd->period_size;\n\t\t\tif (prtd->period_ptr_submitted >= prtd->dma_buffer_end)\n\t\t\t\tprtd->period_ptr_submitted = prtd->dma_buffer_start;\n\n\t\t\t \n\t\t\tret = qmc_chan_write_submit(prtd->qmc_dai->qmc_chan,\n\t\t\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\t\t\tqmc_audio_pcm_write_complete, prtd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev, \"write_submit failed %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = qmc_chan_read_submit(prtd->qmc_dai->qmc_chan,\n\t\t\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\t\t\tqmc_audio_pcm_read_complete, prtd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev, \"read_submit failed %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tprtd->period_ptr_submitted += prtd->period_size;\n\t\t\tif (prtd->period_ptr_submitted >= prtd->dma_buffer_end)\n\t\t\t\tprtd->period_ptr_submitted = prtd->dma_buffer_start;\n\n\t\t\t \n\t\t\tret = qmc_chan_read_submit(prtd->qmc_dai->qmc_chan,\n\t\t\t\tprtd->period_ptr_submitted, prtd->period_size,\n\t\t\t\tqmc_audio_pcm_read_complete, prtd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev, \"write_submit failed %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t qmc_audio_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct qmc_dai_prtd *prtd = substream->runtime->private_data;\n\n\treturn bytes_to_frames(substream->runtime,\n\t\t\t       prtd->period_ptr_ended - prtd->dma_buffer_start);\n}\n\nstatic int qmc_audio_of_xlate_dai_name(struct snd_soc_component *component,\n\t\t\t\t\tconst struct of_phandle_args *args,\n\t\t\t\t\tconst char **dai_name)\n{\n\tstruct qmc_audio *qmc_audio = dev_get_drvdata(component->dev);\n\tstruct snd_soc_dai_driver *dai_driver;\n\tint id = args->args[0];\n\tint i;\n\n\tfor (i = 0; i  < qmc_audio->num_dais; i++) {\n\t\tdai_driver = qmc_audio->dai_drivers + i;\n\t\tif (dai_driver->id == id) {\n\t\t\t*dai_name = dai_driver->name;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct snd_pcm_hardware qmc_audio_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED |\n\t\t\t\t  SNDRV_PCM_INFO_PAUSE,\n\t.period_bytes_min\t= 32,\n\t.period_bytes_max\t= 64*1024,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 2*1024,\n\t.buffer_bytes_max\t= 64*1024,\n};\n\nstatic int qmc_audio_pcm_open(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct qmc_dai_prtd *prtd;\n\tint ret;\n\n\tsnd_soc_set_runtime_hwparams(substream, &qmc_audio_pcm_hardware);\n\n\t \n\tret = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tprtd = kzalloc(sizeof(*prtd), GFP_KERNEL);\n\tif (prtd == NULL)\n\t\treturn -ENOMEM;\n\n\truntime->private_data = prtd;\n\n\treturn 0;\n}\n\nstatic int qmc_audio_pcm_close(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tstruct qmc_dai_prtd *prtd = substream->runtime->private_data;\n\n\tkfree(prtd);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver qmc_audio_soc_platform = {\n\t.open\t\t\t= qmc_audio_pcm_open,\n\t.close\t\t\t= qmc_audio_pcm_close,\n\t.hw_params\t\t= qmc_audio_pcm_hw_params,\n\t.trigger\t\t= qmc_audio_pcm_trigger,\n\t.pointer\t\t= qmc_audio_pcm_pointer,\n\t.pcm_construct\t\t= qmc_audio_pcm_construct,\n\t.of_xlate_dai_name\t= qmc_audio_of_xlate_dai_name,\n};\n\nstatic unsigned int qmc_dai_get_index(struct snd_soc_dai *dai)\n{\n\tstruct qmc_audio *qmc_audio = snd_soc_dai_get_drvdata(dai);\n\n\treturn dai->driver - qmc_audio->dai_drivers;\n}\n\nstatic struct qmc_dai *qmc_dai_get_data(struct snd_soc_dai *dai)\n{\n\tstruct qmc_audio *qmc_audio = snd_soc_dai_get_drvdata(dai);\n\tunsigned int index;\n\n\tindex = qmc_dai_get_index(dai);\n\tif (index > qmc_audio->num_dais)\n\t\treturn NULL;\n\n\treturn qmc_audio->dais + index;\n}\n\n \nstatic int qmc_dai_hw_rule_channels_by_format(struct qmc_dai *qmc_dai,\n\t\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t\t      unsigned int nb_ts)\n{\n\tstruct snd_interval *c = hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\n\tsnd_pcm_format_t format = params_format(params);\n\tstruct snd_interval ch = {0};\n\n\tswitch (snd_pcm_format_physical_width(format)) {\n\tcase 8:\n\t\tch.max = nb_ts;\n\t\tbreak;\n\tcase 16:\n\t\tch.max = nb_ts/2;\n\t\tbreak;\n\tcase 32:\n\t\tch.max = nb_ts/4;\n\t\tbreak;\n\tcase 64:\n\t\tch.max = nb_ts/8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(qmc_dai->dev, \"format physical width %u not supported\\n\",\n\t\t\tsnd_pcm_format_physical_width(format));\n\t\treturn -EINVAL;\n\t}\n\n\tch.min = ch.max ? 1 : 0;\n\n\treturn snd_interval_refine(c, &ch);\n}\n\nstatic int qmc_dai_hw_rule_playback_channels_by_format(struct snd_pcm_hw_params *params,\n\t\t\t\t\t\t       struct snd_pcm_hw_rule *rule)\n{\n\tstruct qmc_dai *qmc_dai = rule->private;\n\n\treturn qmc_dai_hw_rule_channels_by_format(qmc_dai, params, qmc_dai->nb_tx_ts);\n}\n\nstatic int qmc_dai_hw_rule_capture_channels_by_format(\n\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct qmc_dai *qmc_dai = rule->private;\n\n\treturn qmc_dai_hw_rule_channels_by_format(qmc_dai, params, qmc_dai->nb_rx_ts);\n}\n\nstatic int qmc_dai_hw_rule_format_by_channels(struct qmc_dai *qmc_dai,\n\t\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t\t      unsigned int nb_ts)\n{\n\tstruct snd_mask *f_old = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tunsigned int channels = params_channels(params);\n\tunsigned int slot_width;\n\tsnd_pcm_format_t format;\n\tstruct snd_mask f_new;\n\n\tif (!channels || channels > nb_ts) {\n\t\tdev_err(qmc_dai->dev, \"channels %u not supported\\n\",\n\t\t\tnb_ts);\n\t\treturn -EINVAL;\n\t}\n\n\tslot_width = (nb_ts / channels) * 8;\n\n\tsnd_mask_none(&f_new);\n\tpcm_for_each_format(format) {\n\t\tif (snd_mask_test_format(f_old, format)) {\n\t\t\tif (snd_pcm_format_physical_width(format) <= slot_width)\n\t\t\t\tsnd_mask_set_format(&f_new, format);\n\t\t}\n\t}\n\n\treturn snd_mask_refine(f_old, &f_new);\n}\n\nstatic int qmc_dai_hw_rule_playback_format_by_channels(\n\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct qmc_dai *qmc_dai = rule->private;\n\n\treturn qmc_dai_hw_rule_format_by_channels(qmc_dai, params, qmc_dai->nb_tx_ts);\n}\n\nstatic int qmc_dai_hw_rule_capture_format_by_channels(\n\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct qmc_dai *qmc_dai = rule->private;\n\n\treturn qmc_dai_hw_rule_format_by_channels(qmc_dai, params, qmc_dai->nb_rx_ts);\n}\n\nstatic int qmc_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct qmc_dai_prtd *prtd = substream->runtime->private_data;\n\tsnd_pcm_hw_rule_func_t hw_rule_channels_by_format;\n\tsnd_pcm_hw_rule_func_t hw_rule_format_by_channels;\n\tstruct qmc_dai *qmc_dai;\n\tunsigned int frame_bits;\n\tint ret;\n\n\tqmc_dai = qmc_dai_get_data(dai);\n\tif (!qmc_dai) {\n\t\tdev_err(dai->dev, \"Invalid dai\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tprtd->qmc_dai = qmc_dai;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\thw_rule_channels_by_format = qmc_dai_hw_rule_capture_channels_by_format;\n\t\thw_rule_format_by_channels = qmc_dai_hw_rule_capture_format_by_channels;\n\t\tframe_bits = qmc_dai->nb_rx_ts * 8;\n\t} else {\n\t\thw_rule_channels_by_format = qmc_dai_hw_rule_playback_channels_by_format;\n\t\thw_rule_format_by_channels = qmc_dai_hw_rule_playback_format_by_channels;\n\t\tframe_bits = qmc_dai->nb_tx_ts * 8;\n\t}\n\n\tret = snd_pcm_hw_rule_add(substream->runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t  hw_rule_channels_by_format, qmc_dai,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Failed to add channels rule (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_rule_add(substream->runtime, 0,  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t  hw_rule_format_by_channels, qmc_dai,\n\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Failed to add format rule (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_FRAME_BITS,\n\t\t\t\t\t   frame_bits);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Failed to add frame_bits constraint (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int qmc_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct qmc_chan_param chan_param = {0};\n\tstruct qmc_dai *qmc_dai;\n\tint ret;\n\n\tqmc_dai = qmc_dai_get_data(dai);\n\tif (!qmc_dai) {\n\t\tdev_err(dai->dev, \"Invalid dai\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tchan_param.mode = QMC_TRANSPARENT;\n\t\tchan_param.transp.max_rx_buf_size = params_period_bytes(params);\n\t\tret = qmc_chan_set_param(qmc_dai->qmc_chan, &chan_param);\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"set param failed %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qmc_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct qmc_dai *qmc_dai;\n\tint direction;\n\tint ret;\n\n\tqmc_dai = qmc_dai_get_data(dai);\n\tif (!qmc_dai) {\n\t\tdev_err(dai->dev, \"Invalid dai\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdirection = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\t    QMC_CHAN_WRITE : QMC_CHAN_READ;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tret = qmc_chan_start(qmc_dai->qmc_chan, direction);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tret = qmc_chan_stop(qmc_dai->qmc_chan, direction);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = qmc_chan_reset(qmc_dai->qmc_chan, direction);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tret = qmc_chan_stop(qmc_dai->qmc_chan, direction);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops qmc_dai_ops = {\n\t.startup\t= qmc_dai_startup,\n\t.trigger\t= qmc_dai_trigger,\n\t.hw_params\t= qmc_dai_hw_params,\n};\n\nstatic u64 qmc_audio_formats(u8 nb_ts)\n{\n\tunsigned int format_width;\n\tunsigned int chan_width;\n\tsnd_pcm_format_t format;\n\tu64 formats_mask;\n\n\tif (!nb_ts)\n\t\treturn 0;\n\n\tformats_mask = 0;\n\tchan_width = nb_ts * 8;\n\tpcm_for_each_format(format) {\n\t\t \n\t\tif (snd_pcm_format_little_endian(format) == 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tformat_width = snd_pcm_format_physical_width(format);\n\t\tif (format_width == 0 || format_width % 8)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (format_width > chan_width || chan_width % format_width)\n\t\t\tcontinue;\n\n\t\tformats_mask |= pcm_format_to_bits(format);\n\t}\n\treturn formats_mask;\n}\n\nstatic int qmc_audio_dai_parse(struct qmc_audio *qmc_audio, struct device_node *np,\n\tstruct qmc_dai *qmc_dai, struct snd_soc_dai_driver *qmc_soc_dai_driver)\n{\n\tstruct qmc_chan_info info;\n\tu32 val;\n\tint ret;\n\n\tqmc_dai->dev = qmc_audio->dev;\n\n\tret = of_property_read_u32(np, \"reg\", &val);\n\tif (ret) {\n\t\tdev_err(qmc_audio->dev, \"%pOF: failed to read reg\\n\", np);\n\t\treturn ret;\n\t}\n\tqmc_dai->id = val;\n\n\tqmc_dai->name = devm_kasprintf(qmc_audio->dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t       np->parent->name, qmc_dai->id);\n\n\tqmc_dai->qmc_chan = devm_qmc_chan_get_byphandle(qmc_audio->dev, np,\n\t\t\t\t\t\t\t\"fsl,qmc-chan\");\n\tif (IS_ERR(qmc_dai->qmc_chan)) {\n\t\tret = PTR_ERR(qmc_dai->qmc_chan);\n\t\treturn dev_err_probe(qmc_audio->dev, ret,\n\t\t\t\t     \"dai %d get QMC channel failed\\n\", qmc_dai->id);\n\t}\n\n\tqmc_soc_dai_driver->id = qmc_dai->id;\n\tqmc_soc_dai_driver->name = qmc_dai->name;\n\n\tret = qmc_chan_get_info(qmc_dai->qmc_chan, &info);\n\tif (ret) {\n\t\tdev_err(qmc_audio->dev, \"dai %d get QMC channel info failed %d\\n\",\n\t\t\tqmc_dai->id, ret);\n\t\treturn ret;\n\t}\n\tdev_info(qmc_audio->dev, \"dai %d QMC channel mode %d, nb_tx_ts %u, nb_rx_ts %u\\n\",\n\t\t qmc_dai->id, info.mode, info.nb_tx_ts, info.nb_rx_ts);\n\n\tif (info.mode != QMC_TRANSPARENT) {\n\t\tdev_err(qmc_audio->dev, \"dai %d QMC chan mode %d is not QMC_TRANSPARENT\\n\",\n\t\t\tqmc_dai->id, info.mode);\n\t\treturn -EINVAL;\n\t}\n\tqmc_dai->nb_tx_ts = info.nb_tx_ts;\n\tqmc_dai->nb_rx_ts = info.nb_rx_ts;\n\n\tqmc_soc_dai_driver->playback.channels_min = 0;\n\tqmc_soc_dai_driver->playback.channels_max = 0;\n\tif (qmc_dai->nb_tx_ts) {\n\t\tqmc_soc_dai_driver->playback.channels_min = 1;\n\t\tqmc_soc_dai_driver->playback.channels_max = qmc_dai->nb_tx_ts;\n\t}\n\tqmc_soc_dai_driver->playback.formats = qmc_audio_formats(qmc_dai->nb_tx_ts);\n\n\tqmc_soc_dai_driver->capture.channels_min = 0;\n\tqmc_soc_dai_driver->capture.channels_max = 0;\n\tif (qmc_dai->nb_rx_ts) {\n\t\tqmc_soc_dai_driver->capture.channels_min = 1;\n\t\tqmc_soc_dai_driver->capture.channels_max = qmc_dai->nb_rx_ts;\n\t}\n\tqmc_soc_dai_driver->capture.formats = qmc_audio_formats(qmc_dai->nb_rx_ts);\n\n\tqmc_soc_dai_driver->playback.rates = snd_pcm_rate_to_rate_bit(info.tx_fs_rate);\n\tqmc_soc_dai_driver->playback.rate_min = info.tx_fs_rate;\n\tqmc_soc_dai_driver->playback.rate_max = info.tx_fs_rate;\n\tqmc_soc_dai_driver->capture.rates = snd_pcm_rate_to_rate_bit(info.rx_fs_rate);\n\tqmc_soc_dai_driver->capture.rate_min = info.rx_fs_rate;\n\tqmc_soc_dai_driver->capture.rate_max = info.rx_fs_rate;\n\n\tqmc_soc_dai_driver->ops = &qmc_dai_ops;\n\n\treturn 0;\n}\n\nstatic int qmc_audio_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct qmc_audio *qmc_audio;\n\tstruct device_node *child;\n\tunsigned int i;\n\tint ret;\n\n\tqmc_audio = devm_kzalloc(&pdev->dev, sizeof(*qmc_audio), GFP_KERNEL);\n\tif (!qmc_audio)\n\t\treturn -ENOMEM;\n\n\tqmc_audio->dev = &pdev->dev;\n\n\tqmc_audio->num_dais = of_get_available_child_count(np);\n\tif (qmc_audio->num_dais) {\n\t\tqmc_audio->dais = devm_kcalloc(&pdev->dev, qmc_audio->num_dais,\n\t\t\t\t\t       sizeof(*qmc_audio->dais),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!qmc_audio->dais)\n\t\t\treturn -ENOMEM;\n\n\t\tqmc_audio->dai_drivers = devm_kcalloc(&pdev->dev, qmc_audio->num_dais,\n\t\t\t\t\t\t      sizeof(*qmc_audio->dai_drivers),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!qmc_audio->dai_drivers)\n\t\t\treturn -ENOMEM;\n\t}\n\n\ti = 0;\n\tfor_each_available_child_of_node(np, child) {\n\t\tret = qmc_audio_dai_parse(qmc_audio, child,\n\t\t\t\t\t  qmc_audio->dais + i,\n\t\t\t\t\t  qmc_audio->dai_drivers + i);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\t\ti++;\n\t}\n\n\n\tplatform_set_drvdata(pdev, qmc_audio);\n\n\tret = devm_snd_soc_register_component(qmc_audio->dev,\n\t\t\t\t\t      &qmc_audio_soc_platform,\n\t\t\t\t\t      qmc_audio->dai_drivers,\n\t\t\t\t\t      qmc_audio->num_dais);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id qmc_audio_id_table[] = {\n\t{ .compatible = \"fsl,qmc-audio\" },\n\t{}  \n};\nMODULE_DEVICE_TABLE(of, qmc_audio_id_table);\n\nstatic struct platform_driver qmc_audio_driver = {\n\t.driver = {\n\t\t.name = \"fsl-qmc-audio\",\n\t\t.of_match_table = of_match_ptr(qmc_audio_id_table),\n\t},\n\t.probe = qmc_audio_probe,\n};\nmodule_platform_driver(qmc_audio_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"CPM/QE QMC audio driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}