{
  "module_name": "fsl_esai.c",
  "hash_id": "5162fed77ced7a4284410551acfcad2aac66b17836acf80f353cacd450a6b7da",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_esai.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n\n#include \"fsl_esai.h\"\n#include \"imx-pcm.h\"\n\n#define FSL_ESAI_FORMATS\t(SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\n \nstruct fsl_esai_soc_data {\n\tbool reset_at_xrun;\n};\n\n \nstruct fsl_esai {\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n\tstruct snd_dmaengine_dai_dma_data dma_params_tx;\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tstruct clk *coreclk;\n\tstruct clk *extalclk;\n\tstruct clk *fsysclk;\n\tstruct clk *spbaclk;\n\tstruct work_struct work;\n\tconst struct fsl_esai_soc_data *soc;\n\tspinlock_t lock;  \n\tu32 fifo_depth;\n\tu32 slot_width;\n\tu32 slots;\n\tu32 tx_mask;\n\tu32 rx_mask;\n\tu32 channels[2];\n\tu32 hck_rate[2];\n\tu32 sck_rate[2];\n\tbool hck_dir[2];\n\tbool sck_div[2];\n\tbool consumer_mode;\n\tbool synchronous;\n\tchar name[32];\n};\n\nstatic struct fsl_esai_soc_data fsl_esai_vf610 = {\n\t.reset_at_xrun = true,\n};\n\nstatic struct fsl_esai_soc_data fsl_esai_imx35 = {\n\t.reset_at_xrun = true,\n};\n\nstatic struct fsl_esai_soc_data fsl_esai_imx6ull = {\n\t.reset_at_xrun = false,\n};\n\nstatic irqreturn_t esai_isr(int irq, void *devid)\n{\n\tstruct fsl_esai *esai_priv = (struct fsl_esai *)devid;\n\tstruct platform_device *pdev = esai_priv->pdev;\n\tu32 esr;\n\tu32 saisr;\n\n\tregmap_read(esai_priv->regmap, REG_ESAI_ESR, &esr);\n\tregmap_read(esai_priv->regmap, REG_ESAI_SAISR, &saisr);\n\n\tif ((saisr & (ESAI_SAISR_TUE | ESAI_SAISR_ROE)) &&\n\t    esai_priv->soc->reset_at_xrun) {\n\t\tdev_dbg(&pdev->dev, \"reset module for xrun\\n\");\n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR,\n\t\t\t\t   ESAI_xCR_xEIE_MASK, 0);\n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCR,\n\t\t\t\t   ESAI_xCR_xEIE_MASK, 0);\n\t\tschedule_work(&esai_priv->work);\n\t}\n\n\tif (esr & ESAI_ESR_TINIT_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Transmission Initialized\\n\");\n\n\tif (esr & ESAI_ESR_RFF_MASK)\n\t\tdev_warn(&pdev->dev, \"isr: Receiving overrun\\n\");\n\n\tif (esr & ESAI_ESR_TFE_MASK)\n\t\tdev_warn(&pdev->dev, \"isr: Transmission underrun\\n\");\n\n\tif (esr & ESAI_ESR_TLS_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Just transmitted the last slot\\n\");\n\n\tif (esr & ESAI_ESR_TDE_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Transmission data exception\\n\");\n\n\tif (esr & ESAI_ESR_TED_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Transmitting even slots\\n\");\n\n\tif (esr & ESAI_ESR_TD_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Transmitting data\\n\");\n\n\tif (esr & ESAI_ESR_RLS_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Just received the last slot\\n\");\n\n\tif (esr & ESAI_ESR_RDE_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Receiving data exception\\n\");\n\n\tif (esr & ESAI_ESR_RED_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Receiving even slots\\n\");\n\n\tif (esr & ESAI_ESR_RD_MASK)\n\t\tdev_dbg(&pdev->dev, \"isr: Receiving data\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int fsl_esai_divisor_cal(struct snd_soc_dai *dai, bool tx, u32 ratio,\n\t\t\t\tbool usefp, u32 fp)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tu32 psr, pm = 999, maxfp, prod, sub, savesub, i, j;\n\n\tmaxfp = usefp ? 16 : 1;\n\n\tif (usefp && fp)\n\t\tgoto out_fp;\n\n\tif (ratio > 2 * 8 * 256 * maxfp || ratio < 2) {\n\t\tdev_err(dai->dev, \"the ratio is out of range (2 ~ %d)\\n\",\n\t\t\t\t2 * 8 * 256 * maxfp);\n\t\treturn -EINVAL;\n\t} else if (ratio % 2) {\n\t\tdev_err(dai->dev, \"the raio must be even if using upper divider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tratio /= 2;\n\n\tpsr = ratio <= 256 * maxfp ? ESAI_xCCR_xPSR_BYPASS : ESAI_xCCR_xPSR_DIV8;\n\n\t \n\tif (ratio <= 256) {\n\t\tpm = ratio;\n\t\tfp = 1;\n\t\tgoto out;\n\t}\n\n\t \n\tsavesub = (psr ? 1 : 8)  * 256 * maxfp / 1000;\n\n\t \n\tfor (i = 1; i <= 256; i++) {\n\t\tfor (j = 1; j <= maxfp; j++) {\n\t\t\t \n\t\t\tprod = (psr ? 1 : 8) * i * j;\n\n\t\t\tif (prod == ratio)\n\t\t\t\tsub = 0;\n\t\t\telse if (prod / ratio == 1)\n\t\t\t\tsub = prod - ratio;\n\t\t\telse if (ratio / prod == 1)\n\t\t\t\tsub = ratio - prod;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tsub = sub * 1000 / ratio;\n\t\t\tif (sub < savesub) {\n\t\t\t\tsavesub = sub;\n\t\t\t\tpm = i;\n\t\t\t\tfp = j;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (savesub == 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (pm == 999) {\n\t\tdev_err(dai->dev, \"failed to calculate proper divisors\\n\");\n\t\treturn -EINVAL;\n\t}\n\nout:\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\n\t\t\t   ESAI_xCCR_xPSR_MASK | ESAI_xCCR_xPM_MASK,\n\t\t\t   psr | ESAI_xCCR_xPM(pm));\n\nout_fp:\n\t \n\tif (maxfp <= 1)\n\t\treturn 0;\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\n\t\t\t   ESAI_xCCR_xFP_MASK, ESAI_xCCR_xFP(fp));\n\n\treturn 0;\n}\n\n \nstatic int fsl_esai_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t   unsigned int freq, int dir)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tstruct clk *clksrc = esai_priv->extalclk;\n\tbool tx = (clk_id <= ESAI_HCKT_EXTAL || esai_priv->synchronous);\n\tbool in = dir == SND_SOC_CLOCK_IN;\n\tu32 ratio, ecr = 0;\n\tunsigned long clk_rate;\n\tint ret;\n\n\tif (freq == 0) {\n\t\tdev_err(dai->dev, \"%sput freq of HCK%c should not be 0Hz\\n\",\n\t\t\tin ? \"in\" : \"out\", tx ? 'T' : 'R');\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (freq == esai_priv->hck_rate[tx] && dir == esai_priv->hck_dir[tx])\n\t\treturn 0;\n\n\t \n\tesai_priv->sck_div[tx] = true;\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCCR(tx),\n\t\t\t   ESAI_xCCR_xHCKD, in ? 0 : ESAI_xCCR_xHCKD);\n\n\tif (in)\n\t\tgoto out;\n\n\tswitch (clk_id) {\n\tcase ESAI_HCKT_FSYS:\n\tcase ESAI_HCKR_FSYS:\n\t\tclksrc = esai_priv->fsysclk;\n\t\tbreak;\n\tcase ESAI_HCKT_EXTAL:\n\t\tecr |= ESAI_ECR_ETI;\n\t\tbreak;\n\tcase ESAI_HCKR_EXTAL:\n\t\tecr |= esai_priv->synchronous ? ESAI_ECR_ETI : ESAI_ECR_ERI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ERR(clksrc)) {\n\t\tdev_err(dai->dev, \"no assigned %s clock\\n\",\n\t\t\t(clk_id % 2) ? \"extal\" : \"fsys\");\n\t\treturn PTR_ERR(clksrc);\n\t}\n\tclk_rate = clk_get_rate(clksrc);\n\n\tratio = clk_rate / freq;\n\tif (ratio * freq > clk_rate)\n\t\tret = ratio * freq - clk_rate;\n\telse if (ratio * freq < clk_rate)\n\t\tret = clk_rate - ratio * freq;\n\telse\n\t\tret = 0;\n\n\t \n\tif (ret != 0 && clk_rate / ret < 1000) {\n\t\tdev_err(dai->dev, \"failed to derive required HCK%c rate\\n\",\n\t\t\t\ttx ? 'T' : 'R');\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ratio == 1 && clksrc == esai_priv->extalclk) {\n\t\t \n\t\tecr |= tx ? ESAI_ECR_ETO : ESAI_ECR_ERO;\n\t\tgoto out;\n\t} else if (ratio < 2) {\n\t\t \n\t\tdev_err(dai->dev, \"failed to derive required HCK%c rate\\n\",\n\t\t\t\ttx ? 'T' : 'R');\n\t\treturn -EINVAL;\n\t}\n\n\tret = fsl_esai_divisor_cal(dai, tx, ratio, false, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tesai_priv->sck_div[tx] = false;\n\nout:\n\tesai_priv->hck_dir[tx] = dir;\n\tesai_priv->hck_rate[tx] = freq;\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_ECR,\n\t\t\t   tx ? ESAI_ECR_ETI | ESAI_ECR_ETO :\n\t\t\t   ESAI_ECR_ERI | ESAI_ECR_ERO, ecr);\n\n\treturn 0;\n}\n\n \nstatic int fsl_esai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tu32 hck_rate = esai_priv->hck_rate[tx];\n\tu32 sub, ratio = hck_rate / freq;\n\tint ret;\n\n\t \n\tif (esai_priv->consumer_mode || esai_priv->sck_rate[tx] == freq)\n\t\treturn 0;\n\n\tif (ratio * freq > hck_rate)\n\t\tsub = ratio * freq - hck_rate;\n\telse if (ratio * freq < hck_rate)\n\t\tsub = hck_rate - ratio * freq;\n\telse\n\t\tsub = 0;\n\n\t \n\tif (sub != 0 && hck_rate / sub < 1000) {\n\t\tdev_err(dai->dev, \"failed to derive required SCK%c rate\\n\",\n\t\t\t\ttx ? 'T' : 'R');\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!esai_priv->sck_div[tx] && (ratio > 16 || ratio == 0)) {\n\t\tdev_err(dai->dev, \"the ratio is out of range (1 ~ 16)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = fsl_esai_divisor_cal(dai, tx, ratio, true,\n\t\t\tesai_priv->sck_div[tx] ? 0 : ratio);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tesai_priv->sck_rate[tx] = freq;\n\n\treturn 0;\n}\n\nstatic int fsl_esai_set_dai_tdm_slot(struct snd_soc_dai *dai, u32 tx_mask,\n\t\t\t\t     u32 rx_mask, int slots, int slot_width)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR,\n\t\t\t   ESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(slots));\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR,\n\t\t\t   ESAI_xCCR_xDC_MASK, ESAI_xCCR_xDC(slots));\n\n\tesai_priv->slot_width = slot_width;\n\tesai_priv->slots = slots;\n\tesai_priv->tx_mask = tx_mask;\n\tesai_priv->rx_mask = rx_mask;\n\n\treturn 0;\n}\n\nstatic int fsl_esai_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tu32 xcr = 0, xccr = 0, mask;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\txcr |= ESAI_xCR_xFSR;\n\t\txccr |= ESAI_xCCR_xFSP | ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\txccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t \n\t\txccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\txcr  |= ESAI_xCR_xWA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\txcr |= ESAI_xCR_xFSL | ESAI_xCR_xFSR;\n\t\txccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\txcr |= ESAI_xCR_xFSL;\n\t\txccr |= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\txccr ^= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t \n\t\txccr ^= ESAI_xCCR_xFSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\txccr ^= ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tesai_priv->consumer_mode = false;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tesai_priv->consumer_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\txccr |= ESAI_xCCR_xCKD;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\txccr |= ESAI_xCCR_xFSD;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\txccr |= ESAI_xCCR_xFSD | ESAI_xCCR_xCKD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask = ESAI_xCR_xFSL | ESAI_xCR_xFSR | ESAI_xCR_xWA;\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR, mask, xcr);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCR, mask, xcr);\n\n\tmask = ESAI_xCCR_xCKP | ESAI_xCCR_xHCKP | ESAI_xCCR_xFSP |\n\t\tESAI_xCCR_xFSD | ESAI_xCCR_xCKD;\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR, mask, xccr);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR, mask, xccr);\n\n\treturn 0;\n}\n\nstatic int fsl_esai_startup(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\n\tif (!snd_soc_dai_active(dai)) {\n\t\t \n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_SAICR,\n\t\t\t\t   ESAI_SAICR_SYNC, esai_priv->synchronous ?\n\t\t\t\t   ESAI_SAICR_SYNC : 0);\n\n\t\t \n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCCR,\n\t\t\t\t   ESAI_xCCR_xDC_MASK,\n\t\t\t\t   ESAI_xCCR_xDC(esai_priv->slots));\n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCCR,\n\t\t\t\t   ESAI_xCCR_xDC_MASK,\n\t\t\t\t   ESAI_xCCR_xDC(esai_priv->slots));\n\t}\n\n\treturn 0;\n\n}\n\nstatic int fsl_esai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tu32 width = params_width(params);\n\tu32 channels = params_channels(params);\n\tu32 pins = DIV_ROUND_UP(channels, esai_priv->slots);\n\tu32 slot_width = width;\n\tu32 bclk, mask, val;\n\tint ret;\n\n\t \n\tif (esai_priv->slot_width)\n\t\tslot_width = esai_priv->slot_width;\n\n\tbclk = params_rate(params) * slot_width * esai_priv->slots;\n\n\tret = fsl_esai_set_bclk(dai, esai_priv->synchronous || tx, bclk);\n\tif (ret)\n\t\treturn ret;\n\n\tmask = ESAI_xCR_xSWS_MASK;\n\tval = ESAI_xCR_xSWS(slot_width, width);\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx), mask, val);\n\t \n\tif (!tx && esai_priv->synchronous)\n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR, mask, val);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\n\t\t\t   ESAI_xCR_xMOD_MASK, params_channels(params) > 1 ?\n\t\t\t   ESAI_xCR_xMOD_NETWORK : 0);\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\n\t\t\t   ESAI_xFCR_xFR_MASK, ESAI_xFCR_xFR);\n\n\tmask = ESAI_xFCR_xFR_MASK | ESAI_xFCR_xWA_MASK | ESAI_xFCR_xFWM_MASK |\n\t      (tx ? ESAI_xFCR_TE_MASK | ESAI_xFCR_TIEN : ESAI_xFCR_RE_MASK);\n\tval = ESAI_xFCR_xWA(width) | ESAI_xFCR_xFWM(esai_priv->fifo_depth) |\n\t     (tx ? ESAI_xFCR_TE(pins) | ESAI_xFCR_TIEN : ESAI_xFCR_RE(pins));\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx), mask, val);\n\n\tif (tx)\n\t\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR,\n\t\t\t\tESAI_xCR_PADC, ESAI_xCR_PADC);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PRRC,\n\t\t\t   ESAI_PRRC_PDC_MASK, ESAI_PRRC_PDC(ESAI_GPIO));\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PCRC,\n\t\t\t   ESAI_PCRC_PC_MASK, ESAI_PCRC_PC(ESAI_GPIO));\n\treturn 0;\n}\n\nstatic int fsl_esai_hw_init(struct fsl_esai *esai_priv)\n{\n\tstruct platform_device *pdev = esai_priv->pdev;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(esai_priv->regmap, REG_ESAI_ECR,\n\t\t\t\t ESAI_ECR_ESAIEN_MASK | ESAI_ECR_ERST_MASK,\n\t\t\t\t ESAI_ECR_ESAIEN | ESAI_ECR_ERST);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to reset ESAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(esai_priv->regmap, REG_ESAI_ECR,\n\t\t\t\t ESAI_ECR_ESAIEN_MASK | ESAI_ECR_ERST_MASK,\n\t\t\t\t ESAI_ECR_ESAIEN);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable ESAI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PRRC,\n\t\t\t   ESAI_PRRC_PDC_MASK, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PCRC,\n\t\t\t   ESAI_PCRC_PC_MASK, 0);\n\n\treturn 0;\n}\n\nstatic int fsl_esai_register_restore(struct fsl_esai *esai_priv)\n{\n\tint ret;\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TFCR,\n\t\t\t   ESAI_xFCR_xFR, ESAI_xFCR_xFR);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RFCR,\n\t\t\t   ESAI_xFCR_xFR, ESAI_xFCR_xFR);\n\n\tregcache_mark_dirty(esai_priv->regmap);\n\tret = regcache_sync(esai_priv->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TFCR, ESAI_xFCR_xFR, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RFCR, ESAI_xFCR_xFR, 0);\n\n\treturn 0;\n}\n\nstatic void fsl_esai_trigger_start(struct fsl_esai *esai_priv, bool tx)\n{\n\tu8 i, channels = esai_priv->channels[tx];\n\tu32 pins = DIV_ROUND_UP(channels, esai_priv->slots);\n\tu32 mask;\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\n\t\t\t   ESAI_xFCR_xFEN_MASK, ESAI_xFCR_xFEN);\n\n\t \n\tfor (i = 0; tx && i < channels; i++)\n\t\tregmap_write(esai_priv->regmap, REG_ESAI_ETDR, 0x0);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\n\t\t\t   tx ? ESAI_xCR_TE_MASK : ESAI_xCR_RE_MASK,\n\t\t\t   tx ? ESAI_xCR_TE(pins) : ESAI_xCR_RE(pins));\n\tmask = tx ? esai_priv->tx_mask : esai_priv->rx_mask;\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xSMB(tx),\n\t\t\t   ESAI_xSMB_xS_MASK, ESAI_xSMB_xS(mask));\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xSMA(tx),\n\t\t\t   ESAI_xSMA_xS_MASK, ESAI_xSMA_xS(mask));\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\n\t\t\t   ESAI_xCR_xEIE_MASK, ESAI_xCR_xEIE);\n}\n\nstatic void fsl_esai_trigger_stop(struct fsl_esai *esai_priv, bool tx)\n{\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\n\t\t\t   ESAI_xCR_xEIE_MASK, 0);\n\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xCR(tx),\n\t\t\t   tx ? ESAI_xCR_TE_MASK : ESAI_xCR_RE_MASK, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xSMA(tx),\n\t\t\t   ESAI_xSMA_xS_MASK, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xSMB(tx),\n\t\t\t   ESAI_xSMB_xS_MASK, 0);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\n\t\t\t   ESAI_xFCR_xFR | ESAI_xFCR_xFEN, ESAI_xFCR_xFR);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_xFCR(tx),\n\t\t\t   ESAI_xFCR_xFR, 0);\n}\n\nstatic void fsl_esai_hw_reset(struct work_struct *work)\n{\n\tstruct fsl_esai *esai_priv = container_of(work, struct fsl_esai, work);\n\tbool tx = true, rx = false, enabled[2];\n\tunsigned long lock_flags;\n\tu32 tfcr, rfcr;\n\n\tspin_lock_irqsave(&esai_priv->lock, lock_flags);\n\t \n\tregmap_read(esai_priv->regmap, REG_ESAI_TFCR, &tfcr);\n\tregmap_read(esai_priv->regmap, REG_ESAI_RFCR, &rfcr);\n\tenabled[tx] = tfcr & ESAI_xFCR_xFEN;\n\tenabled[rx] = rfcr & ESAI_xFCR_xFEN;\n\n\t \n\tfsl_esai_trigger_stop(esai_priv, tx);\n\tfsl_esai_trigger_stop(esai_priv, rx);\n\n\t \n\tfsl_esai_hw_init(esai_priv);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR,\n\t\t\t   ESAI_xCR_xPR_MASK, ESAI_xCR_xPR);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCR,\n\t\t\t   ESAI_xCR_xPR_MASK, ESAI_xCR_xPR);\n\n\t \n\tfsl_esai_register_restore(esai_priv);\n\n\t \n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_TCR,\n\t\t\t   ESAI_xCR_xPR_MASK, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_RCR,\n\t\t\t   ESAI_xCR_xPR_MASK, 0);\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PRRC,\n\t\t\t   ESAI_PRRC_PDC_MASK, ESAI_PRRC_PDC(ESAI_GPIO));\n\tregmap_update_bits(esai_priv->regmap, REG_ESAI_PCRC,\n\t\t\t   ESAI_PCRC_PC_MASK, ESAI_PCRC_PC(ESAI_GPIO));\n\n\t \n\tif (enabled[tx])\n\t\tfsl_esai_trigger_start(esai_priv, tx);\n\tif (enabled[rx])\n\t\tfsl_esai_trigger_start(esai_priv, rx);\n\n\tspin_unlock_irqrestore(&esai_priv->lock, lock_flags);\n}\n\nstatic int fsl_esai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned long lock_flags;\n\n\tesai_priv->channels[tx] = substream->runtime->channels;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tspin_lock_irqsave(&esai_priv->lock, lock_flags);\n\t\tfsl_esai_trigger_start(esai_priv, tx);\n\t\tspin_unlock_irqrestore(&esai_priv->lock, lock_flags);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tspin_lock_irqsave(&esai_priv->lock, lock_flags);\n\t\tfsl_esai_trigger_stop(esai_priv, tx);\n\t\tspin_unlock_irqrestore(&esai_priv->lock, lock_flags);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_esai_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct fsl_esai *esai_priv = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &esai_priv->dma_params_tx,\n\t\t\t\t  &esai_priv->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_esai_dai_ops = {\n\t.probe\t\t= fsl_esai_dai_probe,\n\t.startup\t= fsl_esai_startup,\n\t.trigger\t= fsl_esai_trigger,\n\t.hw_params\t= fsl_esai_hw_params,\n\t.set_sysclk\t= fsl_esai_set_dai_sysclk,\n\t.set_fmt\t= fsl_esai_set_dai_fmt,\n\t.set_tdm_slot\t= fsl_esai_set_dai_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver fsl_esai_dai = {\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 12,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = FSL_ESAI_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = FSL_ESAI_FORMATS,\n\t},\n\t.ops = &fsl_esai_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_esai_component = {\n\t.name\t\t\t= \"fsl-esai\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct reg_default fsl_esai_reg_defaults[] = {\n\t{REG_ESAI_ETDR,\t 0x00000000},\n\t{REG_ESAI_ECR,\t 0x00000000},\n\t{REG_ESAI_TFCR,\t 0x00000000},\n\t{REG_ESAI_RFCR,\t 0x00000000},\n\t{REG_ESAI_TX0,\t 0x00000000},\n\t{REG_ESAI_TX1,\t 0x00000000},\n\t{REG_ESAI_TX2,\t 0x00000000},\n\t{REG_ESAI_TX3,\t 0x00000000},\n\t{REG_ESAI_TX4,\t 0x00000000},\n\t{REG_ESAI_TX5,\t 0x00000000},\n\t{REG_ESAI_TSR,\t 0x00000000},\n\t{REG_ESAI_SAICR, 0x00000000},\n\t{REG_ESAI_TCR,\t 0x00000000},\n\t{REG_ESAI_TCCR,\t 0x00000000},\n\t{REG_ESAI_RCR,\t 0x00000000},\n\t{REG_ESAI_RCCR,\t 0x00000000},\n\t{REG_ESAI_TSMA,  0x0000ffff},\n\t{REG_ESAI_TSMB,  0x0000ffff},\n\t{REG_ESAI_RSMA,  0x0000ffff},\n\t{REG_ESAI_RSMB,  0x0000ffff},\n\t{REG_ESAI_PRRC,  0x00000000},\n\t{REG_ESAI_PCRC,  0x00000000},\n};\n\nstatic bool fsl_esai_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ESAI_ERDR:\n\tcase REG_ESAI_ECR:\n\tcase REG_ESAI_ESR:\n\tcase REG_ESAI_TFCR:\n\tcase REG_ESAI_TFSR:\n\tcase REG_ESAI_RFCR:\n\tcase REG_ESAI_RFSR:\n\tcase REG_ESAI_RX0:\n\tcase REG_ESAI_RX1:\n\tcase REG_ESAI_RX2:\n\tcase REG_ESAI_RX3:\n\tcase REG_ESAI_SAISR:\n\tcase REG_ESAI_SAICR:\n\tcase REG_ESAI_TCR:\n\tcase REG_ESAI_TCCR:\n\tcase REG_ESAI_RCR:\n\tcase REG_ESAI_RCCR:\n\tcase REG_ESAI_TSMA:\n\tcase REG_ESAI_TSMB:\n\tcase REG_ESAI_RSMA:\n\tcase REG_ESAI_RSMB:\n\tcase REG_ESAI_PRRC:\n\tcase REG_ESAI_PCRC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_esai_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ESAI_ERDR:\n\tcase REG_ESAI_ESR:\n\tcase REG_ESAI_TFSR:\n\tcase REG_ESAI_RFSR:\n\tcase REG_ESAI_RX0:\n\tcase REG_ESAI_RX1:\n\tcase REG_ESAI_RX2:\n\tcase REG_ESAI_RX3:\n\tcase REG_ESAI_SAISR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_esai_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_ESAI_ETDR:\n\tcase REG_ESAI_ECR:\n\tcase REG_ESAI_TFCR:\n\tcase REG_ESAI_RFCR:\n\tcase REG_ESAI_TX0:\n\tcase REG_ESAI_TX1:\n\tcase REG_ESAI_TX2:\n\tcase REG_ESAI_TX3:\n\tcase REG_ESAI_TX4:\n\tcase REG_ESAI_TX5:\n\tcase REG_ESAI_TSR:\n\tcase REG_ESAI_SAICR:\n\tcase REG_ESAI_TCR:\n\tcase REG_ESAI_TCCR:\n\tcase REG_ESAI_RCR:\n\tcase REG_ESAI_RCCR:\n\tcase REG_ESAI_TSMA:\n\tcase REG_ESAI_TSMB:\n\tcase REG_ESAI_RSMA:\n\tcase REG_ESAI_RSMB:\n\tcase REG_ESAI_PRRC:\n\tcase REG_ESAI_PCRC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config fsl_esai_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = REG_ESAI_PCRC,\n\t.reg_defaults = fsl_esai_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_esai_reg_defaults),\n\t.readable_reg = fsl_esai_readable_reg,\n\t.volatile_reg = fsl_esai_volatile_reg,\n\t.writeable_reg = fsl_esai_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int fsl_esai_runtime_resume(struct device *dev);\nstatic int fsl_esai_runtime_suspend(struct device *dev);\n\nstatic int fsl_esai_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct fsl_esai *esai_priv;\n\tstruct resource *res;\n\tconst __be32 *iprop;\n\tvoid __iomem *regs;\n\tint irq, ret;\n\n\tesai_priv = devm_kzalloc(&pdev->dev, sizeof(*esai_priv), GFP_KERNEL);\n\tif (!esai_priv)\n\t\treturn -ENOMEM;\n\n\tesai_priv->pdev = pdev;\n\tsnprintf(esai_priv->name, sizeof(esai_priv->name), \"%pOFn\", np);\n\n\tesai_priv->soc = of_device_get_match_data(&pdev->dev);\n\n\t \n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tesai_priv->regmap = devm_regmap_init_mmio(&pdev->dev, regs, &fsl_esai_regmap_config);\n\tif (IS_ERR(esai_priv->regmap)) {\n\t\tdev_err(&pdev->dev, \"failed to init regmap: %ld\\n\",\n\t\t\t\tPTR_ERR(esai_priv->regmap));\n\t\treturn PTR_ERR(esai_priv->regmap);\n\t}\n\n\tesai_priv->coreclk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(esai_priv->coreclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get core clock: %ld\\n\",\n\t\t\t\tPTR_ERR(esai_priv->coreclk));\n\t\treturn PTR_ERR(esai_priv->coreclk);\n\t}\n\n\tesai_priv->extalclk = devm_clk_get(&pdev->dev, \"extal\");\n\tif (IS_ERR(esai_priv->extalclk))\n\t\tdev_warn(&pdev->dev, \"failed to get extal clock: %ld\\n\",\n\t\t\t\tPTR_ERR(esai_priv->extalclk));\n\n\tesai_priv->fsysclk = devm_clk_get(&pdev->dev, \"fsys\");\n\tif (IS_ERR(esai_priv->fsysclk))\n\t\tdev_warn(&pdev->dev, \"failed to get fsys clock: %ld\\n\",\n\t\t\t\tPTR_ERR(esai_priv->fsysclk));\n\n\tesai_priv->spbaclk = devm_clk_get(&pdev->dev, \"spba\");\n\tif (IS_ERR(esai_priv->spbaclk))\n\t\tdev_warn(&pdev->dev, \"failed to get spba clock: %ld\\n\",\n\t\t\t\tPTR_ERR(esai_priv->spbaclk));\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(&pdev->dev, irq, esai_isr, IRQF_SHARED,\n\t\t\t       esai_priv->name, esai_priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to claim irq %u\\n\", irq);\n\t\treturn ret;\n\t}\n\n\t \n\tesai_priv->slots = 2;\n\n\t \n\tesai_priv->consumer_mode = true;\n\n\t \n\tiprop = of_get_property(np, \"fsl,fifo-depth\", NULL);\n\tif (iprop)\n\t\tesai_priv->fifo_depth = be32_to_cpup(iprop);\n\telse\n\t\tesai_priv->fifo_depth = 64;\n\n\tesai_priv->dma_params_tx.maxburst = 16;\n\tesai_priv->dma_params_rx.maxburst = 16;\n\tesai_priv->dma_params_tx.addr = res->start + REG_ESAI_ETDR;\n\tesai_priv->dma_params_rx.addr = res->start + REG_ESAI_ERDR;\n\n\tesai_priv->synchronous =\n\t\tof_property_read_bool(np, \"fsl,esai-synchronous\");\n\n\t \n\tif (esai_priv->synchronous) {\n\t\tfsl_esai_dai.symmetric_rate = 1;\n\t\tfsl_esai_dai.symmetric_channels = 1;\n\t\tfsl_esai_dai.symmetric_sample_bits = 1;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, esai_priv);\n\tspin_lock_init(&esai_priv->lock);\n\tpm_runtime_enable(&pdev->dev);\n\tif (!pm_runtime_enabled(&pdev->dev)) {\n\t\tret = fsl_esai_runtime_resume(&pdev->dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_pm_get_sync;\n\n\tret = fsl_esai_hw_init(esai_priv);\n\tif (ret)\n\t\tgoto err_pm_get_sync;\n\n\tesai_priv->tx_mask = 0xFFFFFFFF;\n\tesai_priv->rx_mask = 0xFFFFFFFF;\n\n\t \n\tregmap_write(esai_priv->regmap, REG_ESAI_TSMA, 0);\n\tregmap_write(esai_priv->regmap, REG_ESAI_TSMB, 0);\n\tregmap_write(esai_priv->regmap, REG_ESAI_RSMA, 0);\n\tregmap_write(esai_priv->regmap, REG_ESAI_RSMB, 0);\n\n\tret = pm_runtime_put_sync(&pdev->dev);\n\tif (ret < 0 && ret != -ENOSYS)\n\t\tgoto err_pm_get_sync;\n\n\t \n\tret = imx_pcm_dma_init(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to init imx pcm dma: %d\\n\", ret);\n\t\tgoto err_pm_get_sync;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &fsl_esai_component,\n\t\t\t\t\t      &fsl_esai_dai, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register DAI: %d\\n\", ret);\n\t\tgoto err_pm_get_sync;\n\t}\n\n\tINIT_WORK(&esai_priv->work, fsl_esai_hw_reset);\n\n\treturn ret;\n\nerr_pm_get_sync:\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_esai_runtime_suspend(&pdev->dev);\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void fsl_esai_remove(struct platform_device *pdev)\n{\n\tstruct fsl_esai *esai_priv = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_esai_runtime_suspend(&pdev->dev);\n\n\tcancel_work_sync(&esai_priv->work);\n}\n\nstatic const struct of_device_id fsl_esai_dt_ids[] = {\n\t{ .compatible = \"fsl,imx35-esai\", .data = &fsl_esai_imx35 },\n\t{ .compatible = \"fsl,vf610-esai\", .data = &fsl_esai_vf610 },\n\t{ .compatible = \"fsl,imx6ull-esai\", .data = &fsl_esai_imx6ull },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_esai_dt_ids);\n\nstatic int fsl_esai_runtime_resume(struct device *dev)\n{\n\tstruct fsl_esai *esai = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(esai->coreclk);\n\tif (ret)\n\t\treturn ret;\n\tif (!IS_ERR(esai->spbaclk)) {\n\t\tret = clk_prepare_enable(esai->spbaclk);\n\t\tif (ret)\n\t\t\tgoto err_spbaclk;\n\t}\n\tif (!IS_ERR(esai->extalclk)) {\n\t\tret = clk_prepare_enable(esai->extalclk);\n\t\tif (ret)\n\t\t\tgoto err_extalclk;\n\t}\n\tif (!IS_ERR(esai->fsysclk)) {\n\t\tret = clk_prepare_enable(esai->fsysclk);\n\t\tif (ret)\n\t\t\tgoto err_fsysclk;\n\t}\n\n\tregcache_cache_only(esai->regmap, false);\n\n\tret = fsl_esai_register_restore(esai);\n\tif (ret)\n\t\tgoto err_regcache_sync;\n\n\treturn 0;\n\nerr_regcache_sync:\n\tif (!IS_ERR(esai->fsysclk))\n\t\tclk_disable_unprepare(esai->fsysclk);\nerr_fsysclk:\n\tif (!IS_ERR(esai->extalclk))\n\t\tclk_disable_unprepare(esai->extalclk);\nerr_extalclk:\n\tif (!IS_ERR(esai->spbaclk))\n\t\tclk_disable_unprepare(esai->spbaclk);\nerr_spbaclk:\n\tclk_disable_unprepare(esai->coreclk);\n\n\treturn ret;\n}\n\nstatic int fsl_esai_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_esai *esai = dev_get_drvdata(dev);\n\n\tregcache_cache_only(esai->regmap, true);\n\n\tif (!IS_ERR(esai->fsysclk))\n\t\tclk_disable_unprepare(esai->fsysclk);\n\tif (!IS_ERR(esai->extalclk))\n\t\tclk_disable_unprepare(esai->extalclk);\n\tif (!IS_ERR(esai->spbaclk))\n\t\tclk_disable_unprepare(esai->spbaclk);\n\tclk_disable_unprepare(esai->coreclk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops fsl_esai_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_esai_runtime_suspend,\n\t\t\t   fsl_esai_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_esai_driver = {\n\t.probe = fsl_esai_probe,\n\t.remove_new = fsl_esai_remove,\n\t.driver = {\n\t\t.name = \"fsl-esai-dai\",\n\t\t.pm = &fsl_esai_pm_ops,\n\t\t.of_match_table = fsl_esai_dt_ids,\n\t},\n};\n\nmodule_platform_driver(fsl_esai_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Freescale ESAI CPU DAI driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:fsl-esai-dai\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}