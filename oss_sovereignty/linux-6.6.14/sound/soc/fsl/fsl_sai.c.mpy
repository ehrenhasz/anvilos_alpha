{
  "module_name": "fsl_sai.c",
  "hash_id": "99f9b5ffb8c2e5d8e80ee797a06d383315e2c2a2ef63c10105a014fec9e3cb1f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_sai.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <sound/core.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n\n#include \"fsl_sai.h\"\n#include \"fsl_utils.h\"\n#include \"imx-pcm.h\"\n\n#define FSL_SAI_FLAGS (FSL_SAI_CSR_SEIE |\\\n\t\t       FSL_SAI_CSR_FEIE)\n\nstatic const unsigned int fsl_sai_rates[] = {\n\t8000, 11025, 12000, 16000, 22050,\n\t24000, 32000, 44100, 48000, 64000,\n\t88200, 96000, 176400, 192000, 352800,\n\t384000, 705600, 768000, 1411200, 2822400,\n};\n\nstatic const struct snd_pcm_hw_constraint_list fsl_sai_rate_constraints = {\n\t.count = ARRAY_SIZE(fsl_sai_rates),\n\t.list = fsl_sai_rates,\n};\n\n \nstatic inline bool fsl_sai_dir_is_synced(struct fsl_sai *sai, int dir)\n{\n\tint adir = (dir == TX) ? RX : TX;\n\n\t \n\treturn !sai->synchronous[dir] && sai->synchronous[adir];\n}\n\nstatic struct pinctrl_state *fsl_sai_get_pins_state(struct fsl_sai *sai, u32 bclk)\n{\n\tstruct pinctrl_state *state = NULL;\n\n\tif (sai->is_pdm_mode) {\n\t\t \n\t\tif (bclk >= 22579200)\n\t\t\tstate = pinctrl_lookup_state(sai->pinctrl, \"dsd512\");\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(state))\n\t\t\tstate = pinctrl_lookup_state(sai->pinctrl, \"dsd\");\n\t} else {\n\t\t \n\t\tif (bclk >= 45158400)\n\t\t\tstate = pinctrl_lookup_state(sai->pinctrl, \"pcm_b2m\");\n\t}\n\n\t \n\tif (IS_ERR_OR_NULL(state))\n\t\tstate = pinctrl_lookup_state(sai->pinctrl, \"default\");\n\n\treturn state;\n}\n\nstatic irqreturn_t fsl_sai_isr(int irq, void *devid)\n{\n\tstruct fsl_sai *sai = (struct fsl_sai *)devid;\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tstruct device *dev = &sai->pdev->dev;\n\tu32 flags, xcsr, mask;\n\tirqreturn_t iret = IRQ_NONE;\n\n\t \n\tmask = (FSL_SAI_FLAGS >> FSL_SAI_CSR_xIE_SHIFT) << FSL_SAI_CSR_xF_SHIFT;\n\n\t \n\tregmap_read(sai->regmap, FSL_SAI_TCSR(ofs), &xcsr);\n\tflags = xcsr & mask;\n\n\tif (flags)\n\t\tiret = IRQ_HANDLED;\n\telse\n\t\tgoto irq_rx;\n\n\tif (flags & FSL_SAI_CSR_WSF)\n\t\tdev_dbg(dev, \"isr: Start of Tx word detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_SEF)\n\t\tdev_dbg(dev, \"isr: Tx Frame sync error detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_FEF)\n\t\tdev_dbg(dev, \"isr: Transmit underrun detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_FWF)\n\t\tdev_dbg(dev, \"isr: Enabled transmit FIFO is empty\\n\");\n\n\tif (flags & FSL_SAI_CSR_FRF)\n\t\tdev_dbg(dev, \"isr: Transmit FIFO watermark has been reached\\n\");\n\n\tflags &= FSL_SAI_CSR_xF_W_MASK;\n\txcsr &= ~FSL_SAI_CSR_xF_MASK;\n\n\tif (flags)\n\t\tregmap_write(sai->regmap, FSL_SAI_TCSR(ofs), flags | xcsr);\n\nirq_rx:\n\t \n\tregmap_read(sai->regmap, FSL_SAI_RCSR(ofs), &xcsr);\n\tflags = xcsr & mask;\n\n\tif (flags)\n\t\tiret = IRQ_HANDLED;\n\telse\n\t\tgoto out;\n\n\tif (flags & FSL_SAI_CSR_WSF)\n\t\tdev_dbg(dev, \"isr: Start of Rx word detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_SEF)\n\t\tdev_dbg(dev, \"isr: Rx Frame sync error detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_FEF)\n\t\tdev_dbg(dev, \"isr: Receive overflow detected\\n\");\n\n\tif (flags & FSL_SAI_CSR_FWF)\n\t\tdev_dbg(dev, \"isr: Enabled receive FIFO is full\\n\");\n\n\tif (flags & FSL_SAI_CSR_FRF)\n\t\tdev_dbg(dev, \"isr: Receive FIFO watermark has been reached\\n\");\n\n\tflags &= FSL_SAI_CSR_xF_W_MASK;\n\txcsr &= ~FSL_SAI_CSR_xF_MASK;\n\n\tif (flags)\n\t\tregmap_write(sai->regmap, FSL_SAI_RCSR(ofs), flags | xcsr);\n\nout:\n\treturn iret;\n}\n\nstatic int fsl_sai_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai, u32 tx_mask,\n\t\t\t\tu32 rx_mask, int slots, int slot_width)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tsai->slots = slots;\n\tsai->slot_width = slot_width;\n\n\treturn 0;\n}\n\nstatic int fsl_sai_set_dai_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int ratio)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(dai);\n\n\tsai->bclk_ratio = ratio;\n\n\treturn 0;\n}\n\nstatic int fsl_sai_set_dai_sysclk_tr(struct snd_soc_dai *cpu_dai,\n\t\tint clk_id, unsigned int freq, bool tx)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tu32 val_cr2 = 0;\n\n\tswitch (clk_id) {\n\tcase FSL_SAI_CLK_BUS:\n\t\tval_cr2 |= FSL_SAI_CR2_MSEL_BUS;\n\t\tbreak;\n\tcase FSL_SAI_CLK_MAST1:\n\t\tval_cr2 |= FSL_SAI_CR2_MSEL_MCLK1;\n\t\tbreak;\n\tcase FSL_SAI_CLK_MAST2:\n\t\tval_cr2 |= FSL_SAI_CR2_MSEL_MCLK2;\n\t\tbreak;\n\tcase FSL_SAI_CLK_MAST3:\n\t\tval_cr2 |= FSL_SAI_CR2_MSEL_MCLK3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx, ofs),\n\t\t\t   FSL_SAI_CR2_MSEL_MASK, val_cr2);\n\n\treturn 0;\n}\n\nstatic int fsl_sai_set_mclk_rate(struct snd_soc_dai *dai, int clk_id, unsigned int freq)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tfsl_asoc_reparent_pll_clocks(dai->dev, sai->mclk_clk[clk_id],\n\t\t\t\t     sai->pll8k_clk, sai->pll11k_clk, freq);\n\n\tret = clk_set_rate(sai->mclk_clk[clk_id], freq);\n\tif (ret < 0)\n\t\tdev_err(dai->dev, \"failed to set clock rate (%u): %d\\n\", freq, ret);\n\n\treturn ret;\n}\n\nstatic int fsl_sai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret;\n\n\tif (dir == SND_SOC_CLOCK_IN)\n\t\treturn 0;\n\n\tif (freq > 0 && clk_id != FSL_SAI_CLK_BUS) {\n\t\tif (clk_id < 0 || clk_id >= FSL_SAI_MCLK_MAX) {\n\t\t\tdev_err(cpu_dai->dev, \"Unknown clock id: %d\\n\", clk_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (IS_ERR_OR_NULL(sai->mclk_clk[clk_id])) {\n\t\t\tdev_err(cpu_dai->dev, \"Unassigned clock: %d\\n\", clk_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sai->mclk_streams == 0) {\n\t\t\tret = fsl_sai_set_mclk_rate(cpu_dai, clk_id, freq);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq, true);\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev, \"Cannot set tx sysclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = fsl_sai_set_dai_sysclk_tr(cpu_dai, clk_id, freq, false);\n\tif (ret)\n\t\tdev_err(cpu_dai->dev, \"Cannot set rx sysclk: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int fsl_sai_set_dai_fmt_tr(struct snd_soc_dai *cpu_dai,\n\t\t\t\tunsigned int fmt, bool tx)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tu32 val_cr2 = 0, val_cr4 = 0;\n\n\tif (!sai->is_lsb_first)\n\t\tval_cr4 |= FSL_SAI_CR4_MF;\n\n\tsai->is_pdm_mode = false;\n\tsai->is_dsp_mode = false;\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tval_cr2 |= FSL_SAI_CR2_BCP;\n\t\tval_cr4 |= FSL_SAI_CR4_FSE | FSL_SAI_CR4_FSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\tval_cr2 |= FSL_SAI_CR2_BCP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\tval_cr2 |= FSL_SAI_CR2_BCP;\n\t\tval_cr4 |= FSL_SAI_CR4_FSE;\n\t\tsai->is_dsp_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tval_cr2 |= FSL_SAI_CR2_BCP;\n\t\tsai->is_dsp_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_PDM:\n\t\tval_cr2 |= FSL_SAI_CR2_BCP;\n\t\tval_cr4 &= ~FSL_SAI_CR4_MF;\n\t\tsai->is_pdm_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\tval_cr2 ^= FSL_SAI_CR2_BCP;\n\t\tval_cr4 ^= FSL_SAI_CR4_FSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tval_cr2 ^= FSL_SAI_CR2_BCP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t \n\t\tval_cr4 ^= FSL_SAI_CR4_FSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\n\t\tval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\n\t\tsai->is_consumer_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tsai->is_consumer_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\tval_cr2 |= FSL_SAI_CR2_BCD_MSTR;\n\t\tsai->is_consumer_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tval_cr4 |= FSL_SAI_CR4_FSD_MSTR;\n\t\tsai->is_consumer_mode = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx, ofs),\n\t\t\t   FSL_SAI_CR2_BCP | FSL_SAI_CR2_BCD_MSTR, val_cr2);\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t   FSL_SAI_CR4_MF | FSL_SAI_CR4_FSE |\n\t\t\t   FSL_SAI_CR4_FSP | FSL_SAI_CR4_FSD_MSTR, val_cr4);\n\n\treturn 0;\n}\n\nstatic int fsl_sai_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\n{\n\tint ret;\n\n\tret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, true);\n\tif (ret) {\n\t\tdev_err(cpu_dai->dev, \"Cannot set tx format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = fsl_sai_set_dai_fmt_tr(cpu_dai, fmt, false);\n\tif (ret)\n\t\tdev_err(cpu_dai->dev, \"Cannot set rx format: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int fsl_sai_set_bclk(struct snd_soc_dai *dai, bool tx, u32 freq)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(dai);\n\tunsigned int reg, ofs = sai->soc_data->reg_offset;\n\tunsigned long clk_rate;\n\tu32 savediv = 0, ratio, bestdiff = freq;\n\tint adir = tx ? RX : TX;\n\tint dir = tx ? TX : RX;\n\tu32 id;\n\tbool support_1_1_ratio = sai->verid.version >= 0x0301;\n\n\t \n\tif (sai->is_consumer_mode)\n\t\treturn 0;\n\n\t \n\tid = sai->soc_data->mclk0_is_mclk1 ? 1 : 0;\n\n\tfor (; id < FSL_SAI_MCLK_MAX; id++) {\n\t\tint diff;\n\n\t\tclk_rate = clk_get_rate(sai->mclk_clk[id]);\n\t\tif (!clk_rate)\n\t\t\tcontinue;\n\n\t\tratio = DIV_ROUND_CLOSEST(clk_rate, freq);\n\t\tif (!ratio || ratio > 512)\n\t\t\tcontinue;\n\t\tif (ratio == 1 && !support_1_1_ratio)\n\t\t\tcontinue;\n\t\tif ((ratio & 1) && ratio > 1)\n\t\t\tcontinue;\n\n\t\tdiff = abs((long)clk_rate - ratio * freq);\n\n\t\t \n\t\tif (diff != 0 && clk_rate / diff < 1000)\n\t\t\tcontinue;\n\n\t\tdev_dbg(dai->dev,\n\t\t\t\"ratio %d for freq %dHz based on clock %ldHz\\n\",\n\t\t\tratio, freq, clk_rate);\n\n\n\t\tif (diff < bestdiff) {\n\t\t\tsavediv = ratio;\n\t\t\tsai->mclk_id[tx] = id;\n\t\t\tbestdiff = diff;\n\t\t}\n\n\t\tif (diff == 0)\n\t\t\tbreak;\n\t}\n\n\tif (savediv == 0) {\n\t\tdev_err(dai->dev, \"failed to derive required %cx rate: %d\\n\",\n\t\t\t\ttx ? 'T' : 'R', freq);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"best fit: clock id=%d, div=%d, deviation =%d\\n\",\n\t\t\tsai->mclk_id[tx], savediv, bestdiff);\n\n\t \n\tif (fsl_sai_dir_is_synced(sai, adir))\n\t\treg = FSL_SAI_xCR2(!tx, ofs);\n\telse if (!sai->synchronous[dir])\n\t\treg = FSL_SAI_xCR2(tx, ofs);\n\telse\n\t\treturn 0;\n\n\tregmap_update_bits(sai->regmap, reg, FSL_SAI_CR2_MSEL_MASK,\n\t\t\t   FSL_SAI_CR2_MSEL(sai->mclk_id[tx]));\n\n\tif (savediv == 1) {\n\t\tregmap_update_bits(sai->regmap, reg,\n\t\t\t\t   FSL_SAI_CR2_DIV_MASK | FSL_SAI_CR2_BYP,\n\t\t\t\t   FSL_SAI_CR2_BYP);\n\t\tif (fsl_sai_dir_is_synced(sai, adir))\n\t\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx, ofs),\n\t\t\t\t\t   FSL_SAI_CR2_BCI, FSL_SAI_CR2_BCI);\n\t\telse\n\t\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR2(tx, ofs),\n\t\t\t\t\t   FSL_SAI_CR2_BCI, 0);\n\t} else {\n\t\tregmap_update_bits(sai->regmap, reg,\n\t\t\t\t   FSL_SAI_CR2_DIV_MASK | FSL_SAI_CR2_BYP,\n\t\t\t\t   savediv / 2 - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_sai_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned int channels = params_channels(params);\n\tstruct snd_dmaengine_dai_dma_data *dma_params;\n\tstruct fsl_sai_dl_cfg *dl_cfg = sai->dl_cfg;\n\tu32 word_width = params_width(params);\n\tint trce_mask = 0, dl_cfg_idx = 0;\n\tint dl_cfg_cnt = sai->dl_cfg_cnt;\n\tu32 dl_type = FSL_SAI_DL_I2S;\n\tu32 val_cr4 = 0, val_cr5 = 0;\n\tu32 slots = (channels == 1) ? 2 : channels;\n\tu32 slot_width = word_width;\n\tint adir = tx ? RX : TX;\n\tu32 pins, bclk;\n\tu32 watermark;\n\tint ret, i;\n\n\tif (sai->slot_width)\n\t\tslot_width = sai->slot_width;\n\n\tif (sai->slots)\n\t\tslots = sai->slots;\n\telse if (sai->bclk_ratio)\n\t\tslots = sai->bclk_ratio / slot_width;\n\n\tpins = DIV_ROUND_UP(channels, slots);\n\n\t \n\tif (sai->is_pdm_mode) {\n\t\tpins = channels;\n\t\tdl_type = FSL_SAI_DL_PDM;\n\t}\n\n\tfor (i = 0; i < dl_cfg_cnt; i++) {\n\t\tif (dl_cfg[i].type == dl_type && dl_cfg[i].pins[tx] == pins) {\n\t\t\tdl_cfg_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (hweight8(dl_cfg[dl_cfg_idx].mask[tx]) < pins) {\n\t\tdev_err(cpu_dai->dev, \"channel not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbclk = params_rate(params) * (sai->bclk_ratio ? sai->bclk_ratio : slots * slot_width);\n\n\tif (!IS_ERR_OR_NULL(sai->pinctrl)) {\n\t\tsai->pins_state = fsl_sai_get_pins_state(sai, bclk);\n\t\tif (!IS_ERR_OR_NULL(sai->pins_state)) {\n\t\t\tret = pinctrl_select_state(sai->pinctrl, sai->pins_state);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(cpu_dai->dev, \"failed to set proper pins state: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!sai->is_consumer_mode) {\n\t\tret = fsl_sai_set_bclk(cpu_dai, tx, bclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(sai->mclk_streams & BIT(substream->stream))) {\n\t\t\tret = clk_prepare_enable(sai->mclk_clk[sai->mclk_id[tx]]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsai->mclk_streams |= BIT(substream->stream);\n\t\t}\n\t}\n\n\tif (!sai->is_dsp_mode && !sai->is_pdm_mode)\n\t\tval_cr4 |= FSL_SAI_CR4_SYWD(slot_width);\n\n\tval_cr5 |= FSL_SAI_CR5_WNW(slot_width);\n\tval_cr5 |= FSL_SAI_CR5_W0W(slot_width);\n\n\tif (sai->is_lsb_first || sai->is_pdm_mode)\n\t\tval_cr5 |= FSL_SAI_CR5_FBT(0);\n\telse\n\t\tval_cr5 |= FSL_SAI_CR5_FBT(word_width - 1);\n\n\tval_cr4 |= FSL_SAI_CR4_FRSZ(slots);\n\n\t \n\tif (tx)\n\t\tval_cr4 |= FSL_SAI_CR4_CHMOD;\n\n\t \n\n\tif (!sai->is_consumer_mode && fsl_sai_dir_is_synced(sai, adir)) {\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(!tx, ofs),\n\t\t\t\t   FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK |\n\t\t\t\t   FSL_SAI_CR4_CHMOD_MASK,\n\t\t\t\t   val_cr4);\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR5(!tx, ofs),\n\t\t\t\t   FSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\n\t\t\t\t   FSL_SAI_CR5_FBT_MASK, val_cr5);\n\t}\n\n\t \n\tif (hweight8(dl_cfg[dl_cfg_idx].mask[tx]) <= 1 || sai->is_multi_fifo_dma)\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t\t   FSL_SAI_CR4_FCOMB_MASK, 0);\n\telse\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t\t   FSL_SAI_CR4_FCOMB_MASK, FSL_SAI_CR4_FCOMB_SOFT);\n\n\tdma_params = tx ? &sai->dma_params_tx : &sai->dma_params_rx;\n\tdma_params->addr = sai->res->start + FSL_SAI_xDR0(tx) +\n\t\t\t   dl_cfg[dl_cfg_idx].start_off[tx] * 0x4;\n\n\tif (sai->is_multi_fifo_dma) {\n\t\tsai->audio_config[tx].words_per_fifo = min(slots, channels);\n\t\tif (tx) {\n\t\t\tsai->audio_config[tx].n_fifos_dst = pins;\n\t\t\tsai->audio_config[tx].stride_fifos_dst = dl_cfg[dl_cfg_idx].next_off[tx];\n\t\t} else {\n\t\t\tsai->audio_config[tx].n_fifos_src = pins;\n\t\t\tsai->audio_config[tx].stride_fifos_src = dl_cfg[dl_cfg_idx].next_off[tx];\n\t\t}\n\t\tdma_params->maxburst = sai->audio_config[tx].words_per_fifo * pins;\n\t\tdma_params->peripheral_config = &sai->audio_config[tx];\n\t\tdma_params->peripheral_size = sizeof(sai->audio_config[tx]);\n\n\t\twatermark = tx ? (sai->soc_data->fifo_depth - dma_params->maxburst) :\n\t\t\t\t (dma_params->maxburst - 1);\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR1(tx, ofs),\n\t\t\t\t   FSL_SAI_CR1_RFW_MASK(sai->soc_data->fifo_depth),\n\t\t\t\t   watermark);\n\t}\n\n\t \n\tfor (i = 0; i < sai->soc_data->pins; i++) {\n\t\ttrce_mask = (1 << (i + 1)) - 1;\n\t\tif (hweight8(dl_cfg[dl_cfg_idx].mask[tx] & trce_mask) == pins)\n\t\t\tbreak;\n\t}\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, ofs),\n\t\t\t   FSL_SAI_CR3_TRCE_MASK,\n\t\t\t   FSL_SAI_CR3_TRCE((dl_cfg[dl_cfg_idx].mask[tx] & trce_mask)));\n\n\t \n\tif (sai->soc_data->mclk_with_tere && sai->mclk_direction_output &&\n\t    !sai->is_consumer_mode)\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t\t   FSL_SAI_CR4_FSD_MSTR, 0);\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t   FSL_SAI_CR4_SYWD_MASK | FSL_SAI_CR4_FRSZ_MASK |\n\t\t\t   FSL_SAI_CR4_CHMOD_MASK,\n\t\t\t   val_cr4);\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR5(tx, ofs),\n\t\t\t   FSL_SAI_CR5_WNW_MASK | FSL_SAI_CR5_W0W_MASK |\n\t\t\t   FSL_SAI_CR5_FBT_MASK, val_cr5);\n\n\t \n\tif (sai->soc_data->mclk_with_tere && sai->mclk_direction_output &&\n\t    !sai->is_consumer_mode)\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCR4(tx, ofs),\n\t\t\t\t   FSL_SAI_CR4_FSD_MSTR, FSL_SAI_CR4_FSD_MSTR);\n\n\tregmap_write(sai->regmap, FSL_SAI_xMR(tx),\n\t\t     ~0UL - ((1 << min(channels, slots)) - 1));\n\n\treturn 0;\n}\n\nstatic int fsl_sai_hw_free(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\t \n\tregmap_write(sai->regmap, FSL_SAI_xMR(tx), 0);\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCR3(tx, ofs),\n\t\t\t   FSL_SAI_CR3_TRCE_MASK, 0);\n\n\tif (!sai->is_consumer_mode &&\n\t\t\tsai->mclk_streams & BIT(substream->stream)) {\n\t\tclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[tx]]);\n\t\tsai->mclk_streams &= ~BIT(substream->stream);\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_sai_config_disable(struct fsl_sai *sai, int dir)\n{\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tbool tx = dir == TX;\n\tu32 xcsr, count = 100, mask;\n\n\tif (sai->soc_data->mclk_with_tere && sai->mclk_direction_output)\n\t\tmask = FSL_SAI_CSR_TERE;\n\telse\n\t\tmask = FSL_SAI_CSR_TERE | FSL_SAI_CSR_BCE;\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t   mask, 0);\n\n\t \n\tdo {\n\t\tudelay(10);\n\t\tregmap_read(sai->regmap, FSL_SAI_xCSR(tx, ofs), &xcsr);\n\t} while (--count && xcsr & FSL_SAI_CSR_TERE);\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t   FSL_SAI_CSR_FR, FSL_SAI_CSR_FR);\n\n\t \n\tif (!sai->is_consumer_mode) {\n\t\t \n\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), FSL_SAI_CSR_SR);\n\t\t \n\t\tregmap_write(sai->regmap, FSL_SAI_xCSR(tx, ofs), 0);\n\t}\n}\n\nstatic int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint adir = tx ? RX : TX;\n\tint dir = tx ? TX : RX;\n\tu32 xcsr;\n\n\t \n\tregmap_update_bits(sai->regmap, FSL_SAI_TCR2(ofs), FSL_SAI_CR2_SYNC,\n\t\t\t   sai->synchronous[TX] ? FSL_SAI_CR2_SYNC : 0);\n\tregmap_update_bits(sai->regmap, FSL_SAI_RCR2(ofs), FSL_SAI_CR2_SYNC,\n\t\t\t   sai->synchronous[RX] ? FSL_SAI_CR2_SYNC : 0);\n\n\t \n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t\t   FSL_SAI_CSR_FRDE, FSL_SAI_CSR_FRDE);\n\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t\t   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\n\t\t \n\t\tif (fsl_sai_dir_is_synced(sai, adir))\n\t\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR((!tx), ofs),\n\t\t\t\t\t   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\n\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t\t   FSL_SAI_CSR_xIE_MASK, FSL_SAI_FLAGS);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t\t   FSL_SAI_CSR_FRDE, 0);\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_xCSR(tx, ofs),\n\t\t\t\t   FSL_SAI_CSR_xIE_MASK, 0);\n\n\t\t \n\t\tregmap_read(sai->regmap, FSL_SAI_xCSR(!tx, ofs), &xcsr);\n\n\t\t \n\t\tif (fsl_sai_dir_is_synced(sai, adir) && !(xcsr & FSL_SAI_CSR_FRDE))\n\t\t\tfsl_sai_config_disable(sai, adir);\n\n\t\t \n\t\tif (!fsl_sai_dir_is_synced(sai, dir) || !(xcsr & FSL_SAI_CSR_FRDE))\n\t\t\tfsl_sai_config_disable(sai, dir);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_sai_startup(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_sai *sai = snd_soc_dai_get_drvdata(cpu_dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint ret;\n\n\t \n\tif (sai->soc_data->use_edma)\n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t   tx ? sai->dma_params_tx.maxburst :\n\t\t\t\t\t   sai->dma_params_rx.maxburst);\n\n\tret = snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, &fsl_sai_rate_constraints);\n\n\treturn ret;\n}\n\nstatic int fsl_sai_dai_probe(struct snd_soc_dai *cpu_dai)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(cpu_dai->dev);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\t \n\tregmap_write(sai->regmap, FSL_SAI_TCSR(ofs), FSL_SAI_CSR_SR);\n\tregmap_write(sai->regmap, FSL_SAI_RCSR(ofs), FSL_SAI_CSR_SR);\n\t \n\tregmap_write(sai->regmap, FSL_SAI_TCSR(ofs), 0);\n\tregmap_write(sai->regmap, FSL_SAI_RCSR(ofs), 0);\n\n\tregmap_update_bits(sai->regmap, FSL_SAI_TCR1(ofs),\n\t\t\t   FSL_SAI_CR1_RFW_MASK(sai->soc_data->fifo_depth),\n\t\t\t   sai->soc_data->fifo_depth - sai->dma_params_tx.maxburst);\n\tregmap_update_bits(sai->regmap, FSL_SAI_RCR1(ofs),\n\t\t\t   FSL_SAI_CR1_RFW_MASK(sai->soc_data->fifo_depth),\n\t\t\t   sai->dma_params_rx.maxburst - 1);\n\n\tsnd_soc_dai_init_dma_data(cpu_dai, &sai->dma_params_tx,\n\t\t\t\t&sai->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_sai_pcm_dai_ops = {\n\t.probe\t\t= fsl_sai_dai_probe,\n\t.set_bclk_ratio\t= fsl_sai_set_dai_bclk_ratio,\n\t.set_sysclk\t= fsl_sai_set_dai_sysclk,\n\t.set_fmt\t= fsl_sai_set_dai_fmt,\n\t.set_tdm_slot\t= fsl_sai_set_dai_tdm_slot,\n\t.hw_params\t= fsl_sai_hw_params,\n\t.hw_free\t= fsl_sai_hw_free,\n\t.trigger\t= fsl_sai_trigger,\n\t.startup\t= fsl_sai_startup,\n};\n\nstatic int fsl_sai_dai_resume(struct snd_soc_component *component)\n{\n\tstruct fsl_sai *sai = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = &sai->pdev->dev;\n\tint ret;\n\n\tif (!IS_ERR_OR_NULL(sai->pinctrl) && !IS_ERR_OR_NULL(sai->pins_state)) {\n\t\tret = pinctrl_select_state(sai->pinctrl, sai->pins_state);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set proper pins state: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_dai_driver fsl_sai_dai_template = {\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 2822400,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_SAI_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 2822400,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = FSL_SAI_FORMATS,\n\t},\n\t.ops = &fsl_sai_pcm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_component = {\n\t.name\t\t\t= \"fsl-sai\",\n\t.resume\t\t\t= fsl_sai_dai_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic struct reg_default fsl_sai_reg_defaults_ofs0[] = {\n\t{FSL_SAI_TCR1(0), 0},\n\t{FSL_SAI_TCR2(0), 0},\n\t{FSL_SAI_TCR3(0), 0},\n\t{FSL_SAI_TCR4(0), 0},\n\t{FSL_SAI_TCR5(0), 0},\n\t{FSL_SAI_TDR0, 0},\n\t{FSL_SAI_TDR1, 0},\n\t{FSL_SAI_TDR2, 0},\n\t{FSL_SAI_TDR3, 0},\n\t{FSL_SAI_TDR4, 0},\n\t{FSL_SAI_TDR5, 0},\n\t{FSL_SAI_TDR6, 0},\n\t{FSL_SAI_TDR7, 0},\n\t{FSL_SAI_TMR, 0},\n\t{FSL_SAI_RCR1(0), 0},\n\t{FSL_SAI_RCR2(0), 0},\n\t{FSL_SAI_RCR3(0), 0},\n\t{FSL_SAI_RCR4(0), 0},\n\t{FSL_SAI_RCR5(0), 0},\n\t{FSL_SAI_RMR, 0},\n};\n\nstatic struct reg_default fsl_sai_reg_defaults_ofs8[] = {\n\t{FSL_SAI_TCR1(8), 0},\n\t{FSL_SAI_TCR2(8), 0},\n\t{FSL_SAI_TCR3(8), 0},\n\t{FSL_SAI_TCR4(8), 0},\n\t{FSL_SAI_TCR5(8), 0},\n\t{FSL_SAI_TDR0, 0},\n\t{FSL_SAI_TDR1, 0},\n\t{FSL_SAI_TDR2, 0},\n\t{FSL_SAI_TDR3, 0},\n\t{FSL_SAI_TDR4, 0},\n\t{FSL_SAI_TDR5, 0},\n\t{FSL_SAI_TDR6, 0},\n\t{FSL_SAI_TDR7, 0},\n\t{FSL_SAI_TMR, 0},\n\t{FSL_SAI_RCR1(8), 0},\n\t{FSL_SAI_RCR2(8), 0},\n\t{FSL_SAI_RCR3(8), 0},\n\t{FSL_SAI_RCR4(8), 0},\n\t{FSL_SAI_RCR5(8), 0},\n\t{FSL_SAI_RMR, 0},\n\t{FSL_SAI_MCTL, 0},\n\t{FSL_SAI_MDIV, 0},\n};\n\nstatic bool fsl_sai_readable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\tif (reg >= FSL_SAI_TCSR(ofs) && reg <= FSL_SAI_TCR5(ofs))\n\t\treturn true;\n\n\tif (reg >= FSL_SAI_RCSR(ofs) && reg <= FSL_SAI_RCR5(ofs))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase FSL_SAI_TFR0:\n\tcase FSL_SAI_TFR1:\n\tcase FSL_SAI_TFR2:\n\tcase FSL_SAI_TFR3:\n\tcase FSL_SAI_TFR4:\n\tcase FSL_SAI_TFR5:\n\tcase FSL_SAI_TFR6:\n\tcase FSL_SAI_TFR7:\n\tcase FSL_SAI_TMR:\n\tcase FSL_SAI_RDR0:\n\tcase FSL_SAI_RDR1:\n\tcase FSL_SAI_RDR2:\n\tcase FSL_SAI_RDR3:\n\tcase FSL_SAI_RDR4:\n\tcase FSL_SAI_RDR5:\n\tcase FSL_SAI_RDR6:\n\tcase FSL_SAI_RDR7:\n\tcase FSL_SAI_RFR0:\n\tcase FSL_SAI_RFR1:\n\tcase FSL_SAI_RFR2:\n\tcase FSL_SAI_RFR3:\n\tcase FSL_SAI_RFR4:\n\tcase FSL_SAI_RFR5:\n\tcase FSL_SAI_RFR6:\n\tcase FSL_SAI_RFR7:\n\tcase FSL_SAI_RMR:\n\tcase FSL_SAI_MCTL:\n\tcase FSL_SAI_MDIV:\n\tcase FSL_SAI_VERID:\n\tcase FSL_SAI_PARAM:\n\tcase FSL_SAI_TTCTN:\n\tcase FSL_SAI_RTCTN:\n\tcase FSL_SAI_TTCTL:\n\tcase FSL_SAI_TBCTN:\n\tcase FSL_SAI_TTCAP:\n\tcase FSL_SAI_RTCTL:\n\tcase FSL_SAI_RBCTN:\n\tcase FSL_SAI_RTCAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_sai_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\tif (reg == FSL_SAI_TCSR(ofs) || reg == FSL_SAI_RCSR(ofs))\n\t\treturn true;\n\n\t \n\tif (ofs == 8 && (reg == FSL_SAI_VERID || reg == FSL_SAI_PARAM))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase FSL_SAI_TFR0:\n\tcase FSL_SAI_TFR1:\n\tcase FSL_SAI_TFR2:\n\tcase FSL_SAI_TFR3:\n\tcase FSL_SAI_TFR4:\n\tcase FSL_SAI_TFR5:\n\tcase FSL_SAI_TFR6:\n\tcase FSL_SAI_TFR7:\n\tcase FSL_SAI_RFR0:\n\tcase FSL_SAI_RFR1:\n\tcase FSL_SAI_RFR2:\n\tcase FSL_SAI_RFR3:\n\tcase FSL_SAI_RFR4:\n\tcase FSL_SAI_RFR5:\n\tcase FSL_SAI_RFR6:\n\tcase FSL_SAI_RFR7:\n\tcase FSL_SAI_RDR0:\n\tcase FSL_SAI_RDR1:\n\tcase FSL_SAI_RDR2:\n\tcase FSL_SAI_RDR3:\n\tcase FSL_SAI_RDR4:\n\tcase FSL_SAI_RDR5:\n\tcase FSL_SAI_RDR6:\n\tcase FSL_SAI_RDR7:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_sai_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\n\tif (reg >= FSL_SAI_TCSR(ofs) && reg <= FSL_SAI_TCR5(ofs))\n\t\treturn true;\n\n\tif (reg >= FSL_SAI_RCSR(ofs) && reg <= FSL_SAI_RCR5(ofs))\n\t\treturn true;\n\n\tswitch (reg) {\n\tcase FSL_SAI_TDR0:\n\tcase FSL_SAI_TDR1:\n\tcase FSL_SAI_TDR2:\n\tcase FSL_SAI_TDR3:\n\tcase FSL_SAI_TDR4:\n\tcase FSL_SAI_TDR5:\n\tcase FSL_SAI_TDR6:\n\tcase FSL_SAI_TDR7:\n\tcase FSL_SAI_TMR:\n\tcase FSL_SAI_RMR:\n\tcase FSL_SAI_MCTL:\n\tcase FSL_SAI_MDIV:\n\tcase FSL_SAI_TTCTL:\n\tcase FSL_SAI_RTCTL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct regmap_config fsl_sai_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.fast_io = true,\n\n\t.max_register = FSL_SAI_RMR,\n\t.reg_defaults = fsl_sai_reg_defaults_ofs0,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_sai_reg_defaults_ofs0),\n\t.readable_reg = fsl_sai_readable_reg,\n\t.volatile_reg = fsl_sai_volatile_reg,\n\t.writeable_reg = fsl_sai_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int fsl_sai_check_version(struct device *dev)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\tunsigned char ofs = sai->soc_data->reg_offset;\n\tunsigned int val;\n\tint ret;\n\n\tif (FSL_SAI_TCSR(ofs) == FSL_SAI_VERID)\n\t\treturn 0;\n\n\tret = regmap_read(sai->regmap, FSL_SAI_VERID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"VERID: 0x%016X\\n\", val);\n\n\tsai->verid.version = val &\n\t\t(FSL_SAI_VERID_MAJOR_MASK | FSL_SAI_VERID_MINOR_MASK);\n\tsai->verid.version >>= FSL_SAI_VERID_MINOR_SHIFT;\n\tsai->verid.feature = val & FSL_SAI_VERID_FEATURE_MASK;\n\n\tret = regmap_read(sai->regmap, FSL_SAI_PARAM, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_dbg(dev, \"PARAM: 0x%016X\\n\", val);\n\n\t \n\tsai->param.slot_num = 1 <<\n\t\t((val & FSL_SAI_PARAM_SPF_MASK) >> FSL_SAI_PARAM_SPF_SHIFT);\n\n\t \n\tsai->param.fifo_depth = 1 <<\n\t\t((val & FSL_SAI_PARAM_WPF_MASK) >> FSL_SAI_PARAM_WPF_SHIFT);\n\n\t \n\tsai->param.dataline = val & FSL_SAI_PARAM_DLN_MASK;\n\n\treturn 0;\n}\n\n \nstatic unsigned int fsl_sai_calc_dl_off(unsigned long dl_mask)\n{\n\tint fbidx, nbidx, offset;\n\n\tfbidx = find_first_bit(&dl_mask, FSL_SAI_DL_NUM);\n\tnbidx = find_next_bit(&dl_mask, FSL_SAI_DL_NUM, fbidx + 1);\n\toffset = nbidx - fbidx - 1;\n\n\treturn (offset < 0 || offset >= (FSL_SAI_DL_NUM - 1) ? 0 : offset);\n}\n\n \nstatic int fsl_sai_read_dlcfg(struct fsl_sai *sai)\n{\n\tstruct platform_device *pdev = sai->pdev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tint ret, elems, i, index, num_cfg;\n\tchar *propname = \"fsl,dataline\";\n\tstruct fsl_sai_dl_cfg *cfg;\n\tunsigned long dl_mask;\n\tunsigned int soc_dl;\n\tu32 rx, tx, type;\n\n\telems = of_property_count_u32_elems(np, propname);\n\n\tif (elems <= 0) {\n\t\telems = 0;\n\t} else if (elems % 3) {\n\t\tdev_err(dev, \"Number of elements must be divisible to 3.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_cfg = elems / 3;\n\t \n\tcfg = devm_kzalloc(&pdev->dev, (num_cfg + 1) * sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn -ENOMEM;\n\n\t \n\tsoc_dl = BIT(sai->soc_data->pins) - 1;\n\tcfg[0].type = FSL_SAI_DL_DEFAULT;\n\tcfg[0].pins[0] = sai->soc_data->pins;\n\tcfg[0].mask[0] = soc_dl;\n\tcfg[0].start_off[0] = 0;\n\tcfg[0].next_off[0] = 0;\n\n\tcfg[0].pins[1] = sai->soc_data->pins;\n\tcfg[0].mask[1] = soc_dl;\n\tcfg[0].start_off[1] = 0;\n\tcfg[0].next_off[1] = 0;\n\tfor (i = 1, index = 0; i < num_cfg + 1; i++) {\n\t\t \n\t\tret = of_property_read_u32_index(np, propname, index++, &type);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tret = of_property_read_u32_index(np, propname, index++, &rx);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tret = of_property_read_u32_index(np, propname, index++, &tx);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tif ((rx & ~soc_dl) || (tx & ~soc_dl)) {\n\t\t\tdev_err(dev, \"dataline cfg[%d] setting error, mask is 0x%x\\n\", i, soc_dl);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trx = rx & soc_dl;\n\t\ttx = tx & soc_dl;\n\n\t\tcfg[i].type = type;\n\t\tcfg[i].pins[0] = hweight8(rx);\n\t\tcfg[i].mask[0] = rx;\n\t\tdl_mask = rx;\n\t\tcfg[i].start_off[0] = find_first_bit(&dl_mask, FSL_SAI_DL_NUM);\n\t\tcfg[i].next_off[0] = fsl_sai_calc_dl_off(rx);\n\n\t\tcfg[i].pins[1] = hweight8(tx);\n\t\tcfg[i].mask[1] = tx;\n\t\tdl_mask = tx;\n\t\tcfg[i].start_off[1] = find_first_bit(&dl_mask, FSL_SAI_DL_NUM);\n\t\tcfg[i].next_off[1] = fsl_sai_calc_dl_off(tx);\n\t}\n\n\tsai->dl_cfg = cfg;\n\tsai->dl_cfg_cnt = num_cfg + 1;\n\treturn 0;\n}\n\nstatic int fsl_sai_runtime_suspend(struct device *dev);\nstatic int fsl_sai_runtime_resume(struct device *dev);\n\nstatic int fsl_sai_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct fsl_sai *sai;\n\tstruct regmap *gpr;\n\tvoid __iomem *base;\n\tchar tmp[8];\n\tint irq, ret, i;\n\tint index;\n\tu32 dmas[4];\n\n\tsai = devm_kzalloc(dev, sizeof(*sai), GFP_KERNEL);\n\tif (!sai)\n\t\treturn -ENOMEM;\n\n\tsai->pdev = pdev;\n\tsai->soc_data = of_device_get_match_data(dev);\n\n\tsai->is_lsb_first = of_property_read_bool(np, \"lsb-first\");\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &sai->res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (sai->soc_data->reg_offset == 8) {\n\t\tfsl_sai_regmap_config.reg_defaults = fsl_sai_reg_defaults_ofs8;\n\t\tfsl_sai_regmap_config.max_register = FSL_SAI_MDIV;\n\t\tfsl_sai_regmap_config.num_reg_defaults =\n\t\t\tARRAY_SIZE(fsl_sai_reg_defaults_ofs8);\n\t}\n\n\tsai->regmap = devm_regmap_init_mmio(dev, base, &fsl_sai_regmap_config);\n\tif (IS_ERR(sai->regmap)) {\n\t\tdev_err(dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(sai->regmap);\n\t}\n\n\tsai->bus_clk = devm_clk_get(dev, \"bus\");\n\t \n\tif (IS_ERR(sai->bus_clk) && PTR_ERR(sai->bus_clk) != -EPROBE_DEFER)\n\t\tsai->bus_clk = devm_clk_get(dev, \"sai\");\n\tif (IS_ERR(sai->bus_clk)) {\n\t\tdev_err(dev, \"failed to get bus clock: %ld\\n\",\n\t\t\t\tPTR_ERR(sai->bus_clk));\n\t\t \n\t\treturn PTR_ERR(sai->bus_clk);\n\t}\n\n\tfor (i = 1; i < FSL_SAI_MCLK_MAX; i++) {\n\t\tsprintf(tmp, \"mclk%d\", i);\n\t\tsai->mclk_clk[i] = devm_clk_get(dev, tmp);\n\t\tif (IS_ERR(sai->mclk_clk[i])) {\n\t\t\tdev_err(dev, \"failed to get mclk%d clock: %ld\\n\",\n\t\t\t\t\ti, PTR_ERR(sai->mclk_clk[i]));\n\t\t\tsai->mclk_clk[i] = NULL;\n\t\t}\n\t}\n\n\tif (sai->soc_data->mclk0_is_mclk1)\n\t\tsai->mclk_clk[0] = sai->mclk_clk[1];\n\telse\n\t\tsai->mclk_clk[0] = sai->bus_clk;\n\n\tfsl_asoc_get_pll_clocks(&pdev->dev, &sai->pll8k_clk,\n\t\t\t\t&sai->pll11k_clk);\n\n\t \n\tret = of_property_read_u32_array(np, \"dmas\", dmas, 4);\n\tif (!sai->soc_data->use_edma && !ret && dmas[2] == IMX_DMATYPE_MULTI_SAI)\n\t\tsai->is_multi_fifo_dma = true;\n\n\t \n\tret = fsl_sai_read_dlcfg(sai);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read dlcfg %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, fsl_sai_isr, IRQF_SHARED,\n\t\t\t       np->name, sai);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to claim irq %u\\n\", irq);\n\t\treturn ret;\n\t}\n\n\tmemcpy(&sai->cpu_dai_drv, &fsl_sai_dai_template,\n\t       sizeof(fsl_sai_dai_template));\n\n\t \n\tsai->synchronous[RX] = true;\n\tsai->synchronous[TX] = false;\n\tsai->cpu_dai_drv.symmetric_rate = 1;\n\tsai->cpu_dai_drv.symmetric_channels = 1;\n\tsai->cpu_dai_drv.symmetric_sample_bits = 1;\n\n\tif (of_property_read_bool(np, \"fsl,sai-synchronous-rx\") &&\n\t    of_property_read_bool(np, \"fsl,sai-asynchronous\")) {\n\t\t \n\t\tdev_err(dev, \"invalid binding for synchronous mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(np, \"fsl,sai-synchronous-rx\")) {\n\t\t \n\t\tsai->synchronous[RX] = false;\n\t\tsai->synchronous[TX] = true;\n\t} else if (of_property_read_bool(np, \"fsl,sai-asynchronous\")) {\n\t\t \n\t\tsai->synchronous[RX] = false;\n\t\tsai->synchronous[TX] = false;\n\t\tsai->cpu_dai_drv.symmetric_rate = 0;\n\t\tsai->cpu_dai_drv.symmetric_channels = 0;\n\t\tsai->cpu_dai_drv.symmetric_sample_bits = 0;\n\t}\n\n\tsai->mclk_direction_output = of_property_read_bool(np, \"fsl,sai-mclk-direction-output\");\n\n\tif (sai->mclk_direction_output &&\n\t    of_device_is_compatible(np, \"fsl,imx6ul-sai\")) {\n\t\tgpr = syscon_regmap_lookup_by_compatible(\"fsl,imx6ul-iomuxc-gpr\");\n\t\tif (IS_ERR(gpr)) {\n\t\t\tdev_err(dev, \"cannot find iomuxc registers\\n\");\n\t\t\treturn PTR_ERR(gpr);\n\t\t}\n\n\t\tindex = of_alias_get_id(np, \"sai\");\n\t\tif (index < 0)\n\t\t\treturn index;\n\n\t\tregmap_update_bits(gpr, IOMUXC_GPR1, MCLK_DIR(index),\n\t\t\t\t   MCLK_DIR(index));\n\t}\n\n\tsai->dma_params_rx.addr = sai->res->start + FSL_SAI_RDR0;\n\tsai->dma_params_tx.addr = sai->res->start + FSL_SAI_TDR0;\n\tsai->dma_params_rx.maxburst =\n\t\tsai->soc_data->max_burst[RX] ? sai->soc_data->max_burst[RX] : FSL_SAI_MAXBURST_RX;\n\tsai->dma_params_tx.maxburst =\n\t\tsai->soc_data->max_burst[TX] ? sai->soc_data->max_burst[TX] : FSL_SAI_MAXBURST_TX;\n\n\tsai->pinctrl = devm_pinctrl_get(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, sai);\n\tpm_runtime_enable(dev);\n\tif (!pm_runtime_enabled(dev)) {\n\t\tret = fsl_sai_runtime_resume(dev);\n\t\tif (ret)\n\t\t\tgoto err_pm_disable;\n\t}\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0)\n\t\tgoto err_pm_get_sync;\n\n\t \n\tret = fsl_sai_check_version(dev);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"Error reading SAI version: %d\\n\", ret);\n\n\t \n\tif (sai->mclk_direction_output &&\n\t    sai->soc_data->max_register >= FSL_SAI_MCTL) {\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_MCTL,\n\t\t\t\t   FSL_SAI_MCTL_MCLK_EN, FSL_SAI_MCTL_MCLK_EN);\n\t}\n\n\tret = pm_runtime_put_sync(dev);\n\tif (ret < 0 && ret != -ENOSYS)\n\t\tgoto err_pm_get_sync;\n\n\t \n\tif (sai->soc_data->use_imx_pcm) {\n\t\tret = imx_pcm_dma_init(pdev);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"PCM DMA init failed\\n\");\n\t\t\tif (!IS_ENABLED(CONFIG_SND_SOC_IMX_PCM_DMA))\n\t\t\t\tdev_err(dev, \"Error: You must enable the imx-pcm-dma support!\\n\");\n\t\t\tgoto err_pm_get_sync;\n\t\t}\n\t} else {\n\t\tret = devm_snd_dmaengine_pcm_register(dev, NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err_probe(dev, ret, \"Registering PCM dmaengine failed\\n\");\n\t\t\tgoto err_pm_get_sync;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &fsl_component,\n\t\t\t\t\t      &sai->cpu_dai_drv, 1);\n\tif (ret)\n\t\tgoto err_pm_get_sync;\n\n\treturn ret;\n\nerr_pm_get_sync:\n\tif (!pm_runtime_status_suspended(dev))\n\t\tfsl_sai_runtime_suspend(dev);\nerr_pm_disable:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void fsl_sai_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev))\n\t\tfsl_sai_runtime_suspend(&pdev->dev);\n}\n\nstatic const struct fsl_sai_soc_data fsl_sai_vf610_data = {\n\t.use_imx_pcm = false,\n\t.use_edma = false,\n\t.fifo_depth = 32,\n\t.pins = 1,\n\t.reg_offset = 0,\n\t.mclk0_is_mclk1 = false,\n\t.flags = 0,\n\t.max_register = FSL_SAI_RMR,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx6sx_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 32,\n\t.pins = 1,\n\t.reg_offset = 0,\n\t.mclk0_is_mclk1 = true,\n\t.flags = 0,\n\t.max_register = FSL_SAI_RMR,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx7ulp_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 16,\n\t.pins = 2,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.flags = PMQOS_CPU_LATENCY,\n\t.max_register = FSL_SAI_RMR,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8mq_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 128,\n\t.pins = 8,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.flags = 0,\n\t.max_register = FSL_SAI_RMR,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8qm_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = true,\n\t.fifo_depth = 64,\n\t.pins = 4,\n\t.reg_offset = 0,\n\t.mclk0_is_mclk1 = false,\n\t.flags = 0,\n\t.max_register = FSL_SAI_RMR,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8mm_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 128,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.pins = 8,\n\t.flags = 0,\n\t.max_register = FSL_SAI_MCTL,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8mn_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 128,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.pins = 8,\n\t.flags = 0,\n\t.max_register = FSL_SAI_MDIV,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8mp_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = false,\n\t.fifo_depth = 128,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.pins = 8,\n\t.flags = 0,\n\t.max_register = FSL_SAI_MDIV,\n\t.mclk_with_tere = true,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx8ulp_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = true,\n\t.fifo_depth = 16,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.pins = 4,\n\t.flags = PMQOS_CPU_LATENCY,\n\t.max_register = FSL_SAI_RTCAP,\n};\n\nstatic const struct fsl_sai_soc_data fsl_sai_imx93_data = {\n\t.use_imx_pcm = true,\n\t.use_edma = true,\n\t.fifo_depth = 128,\n\t.reg_offset = 8,\n\t.mclk0_is_mclk1 = false,\n\t.pins = 4,\n\t.flags = 0,\n\t.max_register = FSL_SAI_MCTL,\n\t.max_burst = {8, 8},\n};\n\nstatic const struct of_device_id fsl_sai_ids[] = {\n\t{ .compatible = \"fsl,vf610-sai\", .data = &fsl_sai_vf610_data },\n\t{ .compatible = \"fsl,imx6sx-sai\", .data = &fsl_sai_imx6sx_data },\n\t{ .compatible = \"fsl,imx6ul-sai\", .data = &fsl_sai_imx6sx_data },\n\t{ .compatible = \"fsl,imx7ulp-sai\", .data = &fsl_sai_imx7ulp_data },\n\t{ .compatible = \"fsl,imx8mq-sai\", .data = &fsl_sai_imx8mq_data },\n\t{ .compatible = \"fsl,imx8qm-sai\", .data = &fsl_sai_imx8qm_data },\n\t{ .compatible = \"fsl,imx8mm-sai\", .data = &fsl_sai_imx8mm_data },\n\t{ .compatible = \"fsl,imx8mp-sai\", .data = &fsl_sai_imx8mp_data },\n\t{ .compatible = \"fsl,imx8ulp-sai\", .data = &fsl_sai_imx8ulp_data },\n\t{ .compatible = \"fsl,imx8mn-sai\", .data = &fsl_sai_imx8mn_data },\n\t{ .compatible = \"fsl,imx93-sai\", .data = &fsl_sai_imx93_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_sai_ids);\n\nstatic int fsl_sai_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_CAPTURE))\n\t\tclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[0]]);\n\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_PLAYBACK))\n\t\tclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[1]]);\n\n\tclk_disable_unprepare(sai->bus_clk);\n\n\tif (sai->soc_data->flags & PMQOS_CPU_LATENCY)\n\t\tcpu_latency_qos_remove_request(&sai->pm_qos_req);\n\n\tregcache_cache_only(sai->regmap, true);\n\n\treturn 0;\n}\n\nstatic int fsl_sai_runtime_resume(struct device *dev)\n{\n\tstruct fsl_sai *sai = dev_get_drvdata(dev);\n\tunsigned int ofs = sai->soc_data->reg_offset;\n\tint ret;\n\n\tret = clk_prepare_enable(sai->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable bus clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_PLAYBACK)) {\n\t\tret = clk_prepare_enable(sai->mclk_clk[sai->mclk_id[1]]);\n\t\tif (ret)\n\t\t\tgoto disable_bus_clk;\n\t}\n\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_CAPTURE)) {\n\t\tret = clk_prepare_enable(sai->mclk_clk[sai->mclk_id[0]]);\n\t\tif (ret)\n\t\t\tgoto disable_tx_clk;\n\t}\n\n\tif (sai->soc_data->flags & PMQOS_CPU_LATENCY)\n\t\tcpu_latency_qos_add_request(&sai->pm_qos_req, 0);\n\n\tregcache_cache_only(sai->regmap, false);\n\tregcache_mark_dirty(sai->regmap);\n\tregmap_write(sai->regmap, FSL_SAI_TCSR(ofs), FSL_SAI_CSR_SR);\n\tregmap_write(sai->regmap, FSL_SAI_RCSR(ofs), FSL_SAI_CSR_SR);\n\tusleep_range(1000, 2000);\n\tregmap_write(sai->regmap, FSL_SAI_TCSR(ofs), 0);\n\tregmap_write(sai->regmap, FSL_SAI_RCSR(ofs), 0);\n\n\tret = regcache_sync(sai->regmap);\n\tif (ret)\n\t\tgoto disable_rx_clk;\n\n\tif (sai->soc_data->mclk_with_tere && sai->mclk_direction_output)\n\t\tregmap_update_bits(sai->regmap, FSL_SAI_TCSR(ofs),\n\t\t\t\t   FSL_SAI_CSR_TERE, FSL_SAI_CSR_TERE);\n\n\treturn 0;\n\ndisable_rx_clk:\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_CAPTURE))\n\t\tclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[0]]);\ndisable_tx_clk:\n\tif (sai->mclk_streams & BIT(SNDRV_PCM_STREAM_PLAYBACK))\n\t\tclk_disable_unprepare(sai->mclk_clk[sai->mclk_id[1]]);\ndisable_bus_clk:\n\tclk_disable_unprepare(sai->bus_clk);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops fsl_sai_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_sai_runtime_suspend,\n\t\t\t   fsl_sai_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_sai_driver = {\n\t.probe = fsl_sai_probe,\n\t.remove_new = fsl_sai_remove,\n\t.driver = {\n\t\t.name = \"fsl-sai\",\n\t\t.pm = &fsl_sai_pm_ops,\n\t\t.of_match_table = fsl_sai_ids,\n\t},\n};\nmodule_platform_driver(fsl_sai_driver);\n\nMODULE_DESCRIPTION(\"Freescale Soc SAI Interface\");\nMODULE_AUTHOR(\"Xiubo Li, <Li.Xiubo@freescale.com>\");\nMODULE_ALIAS(\"platform:fsl-sai\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}