{
  "module_name": "fsl_utils.c",
  "hash_id": "d8975356d36c274247bef177ce917757f5b1d754a218fb95cc181bccaa17a1ed",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_utils.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <sound/soc.h>\n\n#include \"fsl_utils.h\"\n\n \nint fsl_asoc_get_dma_channel(struct device_node *ssi_np,\n\t\t\t     const char *name,\n\t\t\t     struct snd_soc_dai_link *dai,\n\t\t\t     unsigned int *dma_channel_id,\n\t\t\t     unsigned int *dma_id)\n{\n\tstruct resource res;\n\tstruct device_node *dma_channel_np, *dma_np;\n\tconst __be32 *iprop;\n\tint ret;\n\n\tdma_channel_np = of_parse_phandle(ssi_np, name, 0);\n\tif (!dma_channel_np)\n\t\treturn -EINVAL;\n\n\tif (!of_device_is_compatible(dma_channel_np, \"fsl,ssi-dma-channel\")) {\n\t\tof_node_put(dma_channel_np);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = of_address_to_resource(dma_channel_np, 0, &res);\n\tif (ret) {\n\t\tof_node_put(dma_channel_np);\n\t\treturn ret;\n\t}\n\tsnprintf((char *)dai->platforms->name, DAI_NAME_SIZE, \"%llx.%pOFn\",\n\t\t (unsigned long long) res.start, dma_channel_np);\n\n\tiprop = of_get_property(dma_channel_np, \"cell-index\", NULL);\n\tif (!iprop) {\n\t\tof_node_put(dma_channel_np);\n\t\treturn -EINVAL;\n\t}\n\t*dma_channel_id = be32_to_cpup(iprop);\n\n\tdma_np = of_get_parent(dma_channel_np);\n\tiprop = of_get_property(dma_np, \"cell-index\", NULL);\n\tif (!iprop) {\n\t\tof_node_put(dma_np);\n\t\tof_node_put(dma_channel_np);\n\t\treturn -EINVAL;\n\t}\n\t*dma_id = be32_to_cpup(iprop);\n\n\tof_node_put(dma_np);\n\tof_node_put(dma_channel_np);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(fsl_asoc_get_dma_channel);\n\n \nvoid fsl_asoc_get_pll_clocks(struct device *dev, struct clk **pll8k_clk,\n\t\t\t     struct clk **pll11k_clk)\n{\n\t*pll8k_clk = devm_clk_get(dev, \"pll8k\");\n\tif (IS_ERR(*pll8k_clk))\n\t\t*pll8k_clk = NULL;\n\n\t*pll11k_clk = devm_clk_get(dev, \"pll11k\");\n\tif (IS_ERR(*pll11k_clk))\n\t\t*pll11k_clk = NULL;\n}\nEXPORT_SYMBOL(fsl_asoc_get_pll_clocks);\n\n \nvoid fsl_asoc_reparent_pll_clocks(struct device *dev, struct clk *clk,\n\t\t\t\t  struct clk *pll8k_clk,\n\t\t\t\t  struct clk *pll11k_clk, u64 ratio)\n{\n\tstruct clk *p, *pll = NULL, *npll = NULL;\n\tbool reparent = false;\n\tint ret;\n\n\tif (!clk || !pll8k_clk || !pll11k_clk)\n\t\treturn;\n\n\tp = clk;\n\twhile (p && pll8k_clk && pll11k_clk) {\n\t\tstruct clk *pp = clk_get_parent(p);\n\n\t\tif (clk_is_match(pp, pll8k_clk) ||\n\t\t    clk_is_match(pp, pll11k_clk)) {\n\t\t\tpll = pp;\n\t\t\tbreak;\n\t\t}\n\t\tp = pp;\n\t}\n\n\tnpll = (do_div(ratio, 8000) ? pll11k_clk : pll8k_clk);\n\treparent = (pll && !clk_is_match(pll, npll));\n\n\tif (reparent) {\n\t\tret = clk_set_parent(p, npll);\n\t\tif (ret < 0)\n\t\t\tdev_warn(dev, \"failed to set parent:%d\\n\", ret);\n\t}\n}\nEXPORT_SYMBOL(fsl_asoc_reparent_pll_clocks);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale ASoC utility code\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}