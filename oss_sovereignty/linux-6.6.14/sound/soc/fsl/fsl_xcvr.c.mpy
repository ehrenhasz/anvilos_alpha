{
  "module_name": "fsl_xcvr.c",
  "hash_id": "7227734d2b7e8cee1fd0d67e550a838c249d29ce0d62507042e60710fb232f69",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_xcvr.c",
  "human_readable_source": "\n\n\n#include <linux/bitrev.h>\n#include <linux/clk.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_iec958.h>\n#include <sound/pcm_params.h>\n\n#include \"fsl_xcvr.h\"\n#include \"imx-pcm.h\"\n\n#define FSL_XCVR_CAPDS_SIZE\t256\n\nstruct fsl_xcvr_soc_data {\n\tconst char *fw_name;\n\tbool spdif_only;\n\tbool use_edma;\n};\n\nstruct fsl_xcvr {\n\tconst struct fsl_xcvr_soc_data *soc_data;\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tstruct clk *ipg_clk;\n\tstruct clk *pll_ipg_clk;\n\tstruct clk *phy_clk;\n\tstruct clk *spba_clk;\n\tstruct reset_control *reset;\n\tu8 streams;\n\tu32 mode;\n\tu32 arc_mode;\n\tvoid __iomem *ram_addr;\n\tstruct snd_dmaengine_dai_dma_data dma_prms_rx;\n\tstruct snd_dmaengine_dai_dma_data dma_prms_tx;\n\tstruct snd_aes_iec958 rx_iec958;\n\tstruct snd_aes_iec958 tx_iec958;\n\tu8 cap_ds[FSL_XCVR_CAPDS_SIZE];\n};\n\nstatic const struct fsl_xcvr_pll_conf {\n\tu8 mfi;    \n\tu32 mfn;   \n\tu32 mfd;   \n\tu32 fout;  \n} fsl_xcvr_pll_cfg[] = {\n\t{ .mfi = 54, .mfn = 1,  .mfd = 6,   .fout = 1300000000, },  \n\t{ .mfi = 32, .mfn = 96, .mfd = 125, .fout = 786432000, },   \n\t{ .mfi = 30, .mfn = 66, .mfd = 625, .fout = 722534400, },   \n\t{ .mfi = 29, .mfn = 1,  .mfd = 6,   .fout = 700000000, },   \n};\n\n \nstatic const u32 fsl_xcvr_earc_channels[] = { 1, 2, 8, 16, 32, };\nstatic const struct snd_pcm_hw_constraint_list fsl_xcvr_earc_channels_constr = {\n\t.count = ARRAY_SIZE(fsl_xcvr_earc_channels),\n\t.list = fsl_xcvr_earc_channels,\n};\n\nstatic const u32 fsl_xcvr_earc_rates[] = {\n\t32000, 44100, 48000, 64000, 88200, 96000,\n\t128000, 176400, 192000, 256000, 352800, 384000,\n\t512000, 705600, 768000, 1024000, 1411200, 1536000,\n};\nstatic const struct snd_pcm_hw_constraint_list fsl_xcvr_earc_rates_constr = {\n\t.count = ARRAY_SIZE(fsl_xcvr_earc_rates),\n\t.list = fsl_xcvr_earc_rates,\n};\n\nstatic const u32 fsl_xcvr_spdif_channels[] = { 2, };\nstatic const struct snd_pcm_hw_constraint_list fsl_xcvr_spdif_channels_constr = {\n\t.count = ARRAY_SIZE(fsl_xcvr_spdif_channels),\n\t.list = fsl_xcvr_spdif_channels,\n};\n\nstatic const u32 fsl_xcvr_spdif_rates[] = {\n\t32000, 44100, 48000, 88200, 96000, 176400, 192000,\n};\nstatic const struct snd_pcm_hw_constraint_list fsl_xcvr_spdif_rates_constr = {\n\t.count = ARRAY_SIZE(fsl_xcvr_spdif_rates),\n\t.list = fsl_xcvr_spdif_rates,\n};\n\nstatic int fsl_xcvr_arc_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\n\txcvr->arc_mode = snd_soc_enum_item_to_val(e, item[0]);\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_arc_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tucontrol->value.enumerated.item[0] = xcvr->arc_mode;\n\n\treturn 0;\n}\n\nstatic const u32 fsl_xcvr_phy_arc_cfg[] = {\n\tFSL_XCVR_PHY_CTRL_ARC_MODE_SE_EN, FSL_XCVR_PHY_CTRL_ARC_MODE_CM_EN,\n};\n\nstatic const char * const fsl_xcvr_arc_mode[] = { \"Single Ended\", \"Common\", };\nstatic const struct soc_enum fsl_xcvr_arc_mode_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(fsl_xcvr_arc_mode), fsl_xcvr_arc_mode);\nstatic struct snd_kcontrol_new fsl_xcvr_arc_mode_kctl =\n\tSOC_ENUM_EXT(\"ARC Mode\", fsl_xcvr_arc_mode_enum,\n\t\t     fsl_xcvr_arc_mode_get, fsl_xcvr_arc_mode_put);\n\n \nstatic int fsl_xcvr_type_capds_bytes_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = FSL_XCVR_CAPDS_SIZE;\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_capds_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tmemcpy(ucontrol->value.bytes.data, xcvr->cap_ds, FSL_XCVR_CAPDS_SIZE);\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_capds_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tmemcpy(xcvr->cap_ds, ucontrol->value.bytes.data, FSL_XCVR_CAPDS_SIZE);\n\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new fsl_xcvr_earc_capds_kctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t.name = \"Capabilities Data Structure\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = fsl_xcvr_type_capds_bytes_info,\n\t.get = fsl_xcvr_capds_get,\n\t.put = fsl_xcvr_capds_put,\n};\n\nstatic int fsl_xcvr_activate_ctl(struct snd_soc_dai *dai, const char *name,\n\t\t\t\t bool active)\n{\n\tstruct snd_soc_card *card = dai->component->card;\n\tstruct snd_kcontrol *kctl;\n\tbool enabled;\n\n\tkctl = snd_soc_card_get_kcontrol(card, name);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\tenabled = ((kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_WRITE) != 0);\n\tif (active == enabled)\n\t\treturn 0;  \n\n\tif (active)\n\t\tkctl->vd[0].access |=  SNDRV_CTL_ELEM_ACCESS_WRITE;\n\telse\n\t\tkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_WRITE;\n\n\tsnd_ctl_notify(card->snd_card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\n\n\treturn 1;\n}\n\nstatic int fsl_xcvr_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tstruct snd_soc_card *card = dai->component->card;\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\txcvr->mode = snd_soc_enum_item_to_val(e, item[0]);\n\n\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_arc_mode_kctl.name,\n\t\t\t      (xcvr->mode == FSL_XCVR_MODE_ARC));\n\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_earc_capds_kctl.name,\n\t\t\t      (xcvr->mode == FSL_XCVR_MODE_EARC));\n\t \n\trtd = snd_soc_get_pcm_runtime(card, card->dai_link);\n\trtd->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream_count =\n\t\t(xcvr->mode == FSL_XCVR_MODE_SPDIF ? 1 : 0);\n\treturn 0;\n}\n\nstatic int fsl_xcvr_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tucontrol->value.enumerated.item[0] = xcvr->mode;\n\n\treturn 0;\n}\n\nstatic const char * const fsl_xcvr_mode[] = { \"SPDIF\", \"ARC RX\", \"eARC\", };\nstatic const struct soc_enum fsl_xcvr_mode_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(fsl_xcvr_mode), fsl_xcvr_mode);\nstatic struct snd_kcontrol_new fsl_xcvr_mode_kctl =\n\tSOC_ENUM_EXT(\"XCVR Mode\", fsl_xcvr_mode_enum,\n\t\t     fsl_xcvr_mode_get, fsl_xcvr_mode_put);\n\n \nstatic int fsl_xcvr_ai_write(struct fsl_xcvr *xcvr, u8 reg, u32 data, bool phy)\n{\n\tstruct device *dev = &xcvr->pdev->dev;\n\tu32 val, idx, tidx;\n\tint ret;\n\n\tidx  = BIT(phy ? 26 : 24);\n\ttidx = BIT(phy ? 27 : 25);\n\n\tregmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL_CLR, 0xFF);\n\tregmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL_SET, reg);\n\tregmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_WDATA, data);\n\tregmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL_TOG, idx);\n\n\tret = regmap_read_poll_timeout(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL, val,\n\t\t\t\t       (val & idx) == ((val & tidx) >> 1),\n\t\t\t\t       10, 10000);\n\tif (ret)\n\t\tdev_err(dev, \"AI timeout: failed to set %s reg 0x%02x=0x%08x\\n\",\n\t\t\tphy ? \"PHY\" : \"PLL\", reg, data);\n\treturn ret;\n}\n\nstatic int fsl_xcvr_en_phy_pll(struct fsl_xcvr *xcvr, u32 freq, bool tx)\n{\n\tstruct device *dev = &xcvr->pdev->dev;\n\tu32 i, div = 0, log2;\n\tint ret;\n\n\tif (xcvr->soc_data->spdif_only)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(fsl_xcvr_pll_cfg); i++) {\n\t\tif (fsl_xcvr_pll_cfg[i].fout % freq == 0) {\n\t\t\tdiv = fsl_xcvr_pll_cfg[i].fout / freq;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!div || i >= ARRAY_SIZE(fsl_xcvr_pll_cfg))\n\t\treturn -EINVAL;\n\n\tlog2 = ilog2(div);\n\n\t \n\tret = regmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL_SET,\n\t\t\t   FSL_XCVR_PHY_AI_CTRL_AI_RESETN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error while setting IER0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_BANDGAP_SET,\n\t\t\t  FSL_XCVR_PLL_BANDGAP_EN_VBG, 0);\n\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0, fsl_xcvr_pll_cfg[i].mfi, 0);\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_NUM, fsl_xcvr_pll_cfg[i].mfn, 0);\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_DEN, fsl_xcvr_pll_cfg[i].mfd, 0);\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0_SET,\n\t\t\t  FSL_XCVR_PLL_CTRL0_HROFF | FSL_XCVR_PLL_CTRL0_PWP, 0);\n\tudelay(25);\n\t \n\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0_CLR,\n\t\t\t  FSL_XCVR_PLL_CTRL0_HROFF, 0);\n\tudelay(100);\n\tif (tx) {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_PDIV,\n\t\t\t\t  FSL_XCVR_PLL_PDIVx(log2, 0), 0);\n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0_SET,\n\t\t\t\t  FSL_XCVR_PLL_CTRL0_CM0_EN, 0);\n\t} else if (xcvr->mode == FSL_XCVR_MODE_EARC) {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_PDIV,\n\t\t\t\t  FSL_XCVR_PLL_PDIVx(log2, 1), 0);\n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0_SET,\n\t\t\t\t  FSL_XCVR_PLL_CTRL0_CM1_EN, 0);\n\t} else {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_PDIV,\n\t\t\t\t  FSL_XCVR_PLL_PDIVx(log2, 2), 0);\n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PLL_CTRL0_SET,\n\t\t\t\t  FSL_XCVR_PLL_CTRL0_CM2_EN, 0);\n\t}\n\n\tif (xcvr->mode == FSL_XCVR_MODE_EARC) {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL_SET,\n\t\t\t\t  FSL_XCVR_PHY_CTRL_TSDIFF_OE |\n\t\t\t\t  FSL_XCVR_PHY_CTRL_PHY_EN, 1);\n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL2_SET,\n\t\t\t\t  FSL_XCVR_PHY_CTRL2_EARC_TXMS, 1);\n\t} else if (!tx) {  \n\t\tif (xcvr->mode == FSL_XCVR_MODE_SPDIF)\n\t\t\t \n\t\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL_SET,\n\t\t\t\t\t  FSL_XCVR_PHY_CTRL_SPDIF_EN, 1);\n\t\telse\t \n\t\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL_SET,\n\t\t\t\t\t  FSL_XCVR_PHY_CTRL_PHY_EN |\n\t\t\t\t\t  FSL_XCVR_PHY_CTRL_RX_CM_EN |\n\t\t\t\t\t  fsl_xcvr_phy_arc_cfg[xcvr->arc_mode], 1);\n\t}\n\n\tdev_dbg(dev, \"PLL Fexp: %u, Fout: %u, mfi: %u, mfn: %u, mfd: %d, div: %u, pdiv0: %u\\n\",\n\t\tfreq, fsl_xcvr_pll_cfg[i].fout, fsl_xcvr_pll_cfg[i].mfi,\n\t\tfsl_xcvr_pll_cfg[i].mfn, fsl_xcvr_pll_cfg[i].mfd, div, log2);\n\treturn 0;\n}\n\nstatic int fsl_xcvr_en_aud_pll(struct fsl_xcvr *xcvr, u32 freq)\n{\n\tstruct device *dev = &xcvr->pdev->dev;\n\tint ret;\n\n\tfreq = xcvr->soc_data->spdif_only ? freq / 5 : freq;\n\tclk_disable_unprepare(xcvr->phy_clk);\n\tret = clk_set_rate(xcvr->phy_clk, freq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error while setting AUD PLL rate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(xcvr->phy_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start PHY clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (xcvr->soc_data->spdif_only)\n\t\treturn 0;\n\t \n\tret = regmap_write(xcvr->regmap, FSL_XCVR_PHY_AI_CTRL_SET,\n\t\t\t   FSL_XCVR_PHY_AI_CTRL_AI_RESETN);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error while setting IER0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (xcvr->mode == FSL_XCVR_MODE_EARC) {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL_SET,\n\t\t\t\t  FSL_XCVR_PHY_CTRL_TSDIFF_OE |\n\t\t\t\t  FSL_XCVR_PHY_CTRL_PHY_EN, 1);\n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL2_SET,\n\t\t\t\t  FSL_XCVR_PHY_CTRL2_EARC_TXMS, 1);\n\t} else {  \n\t\t \n\t\tfsl_xcvr_ai_write(xcvr, FSL_XCVR_PHY_CTRL_SET,\n\t\t\t\t  FSL_XCVR_PHY_CTRL_TX_CLK_AUD_SS |\n\t\t\t\t  FSL_XCVR_PHY_CTRL_SPDIF_EN, 1);\n\t}\n\n\tdev_dbg(dev, \"PLL Fexp: %u\\n\", freq);\n\n\treturn 0;\n}\n\n#define FSL_XCVR_SPDIF_RX_FREQ\t175000000\nstatic int fsl_xcvr_prepare(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tu32 m_ctl = 0, v_ctl = 0;\n\tu32 r = substream->runtime->rate, ch = substream->runtime->channels;\n\tu32 fout = 32 * r * ch * 10;\n\tint ret = 0;\n\n\tswitch (xcvr->mode) {\n\tcase FSL_XCVR_MODE_SPDIF:\n\t\tif (xcvr->soc_data->spdif_only && tx) {\n\t\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_TX_DPTH_CTRL_SET,\n\t\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_BYPASS_FEM,\n\t\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_BYPASS_FEM);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set bypass fem: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase FSL_XCVR_MODE_ARC:\n\t\tif (tx) {\n\t\t\tret = fsl_xcvr_en_aud_pll(xcvr, fout);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set TX freq %u: %d\\n\",\n\t\t\t\t\tfout, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = regmap_write(xcvr->regmap, FSL_XCVR_TX_DPTH_CTRL_SET,\n\t\t\t\t\t   FSL_XCVR_TX_DPTH_CTRL_FRM_FMT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set TX_DPTH: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tm_ctl |= FSL_XCVR_EXT_CTRL_SPDIF_MODE;\n\t\t\tv_ctl |= FSL_XCVR_EXT_CTRL_SPDIF_MODE;\n\t\t} else {\n\t\t\t \n\t\t\tret = regmap_write(xcvr->regmap, FSL_XCVR_RX_DPTH_CTRL_SET,\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_STORE_FMT |\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_CLR_RX_FIFO |\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_COMP |\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_LAYB_CTRL);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set RX_DPTH: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = fsl_xcvr_en_phy_pll(xcvr, FSL_XCVR_SPDIF_RX_FREQ, tx);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set RX freq %u: %d\\n\",\n\t\t\t\t\tFSL_XCVR_SPDIF_RX_FREQ, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase FSL_XCVR_MODE_EARC:\n\t\tif (!tx) {\n\t\t\t \n\t\t\tret = regmap_write(xcvr->regmap, FSL_XCVR_RX_DPTH_CTRL_SET,\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_STORE_FMT |\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_CLR_RX_FIFO);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to set RX_DPTH: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = regmap_write(xcvr->regmap, FSL_XCVR_RX_DPTH_CTRL_CLR,\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_COMP |\n\t\t\t\t\t   FSL_XCVR_RX_DPTH_CTRL_LAYB_CTRL);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dai->dev, \"Failed to clr TX_DPTH: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tm_ctl |= FSL_XCVR_EXT_CTRL_CMDC_RESET(tx);\n\t\t \n\t\tm_ctl |= FSL_XCVR_EXT_CTRL_TX_RX_MODE;\n\t\tv_ctl |= (tx ? FSL_XCVR_EXT_CTRL_TX_RX_MODE : 0);\n\t\tbreak;\n\t}\n\n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_IER0,\n\t\t\t\t FSL_XCVR_IRQ_EARC_ALL, FSL_XCVR_IRQ_EARC_ALL);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Error while setting IER0: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tm_ctl |= FSL_XCVR_EXT_CTRL_DPTH_RESET(tx);\n\tv_ctl |= FSL_XCVR_EXT_CTRL_DPTH_RESET(tx);\n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL, m_ctl, v_ctl);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Error while setting EXT_CTRL: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_constr(const struct snd_pcm_substream *substream,\n\t\t\t   const struct snd_pcm_hw_constraint_list *channels,\n\t\t\t   const struct snd_pcm_hw_constraint_list *rates)\n{\n\tstruct snd_pcm_runtime *rt = substream->runtime;\n\tint ret;\n\n\tret = snd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t channels);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t rates);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_startup(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint ret = 0;\n\n\tif (xcvr->streams & BIT(substream->stream)) {\n\t\tdev_err(dai->dev, \"%sX busy\\n\", tx ? \"T\" : \"R\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (xcvr->soc_data->use_edma)\n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t\t\t   tx ? xcvr->dma_prms_tx.maxburst :\n\t\t\t\t\t   xcvr->dma_prms_rx.maxburst);\n\n\tswitch (xcvr->mode) {\n\tcase FSL_XCVR_MODE_SPDIF:\n\tcase FSL_XCVR_MODE_ARC:\n\t\tret = fsl_xcvr_constr(substream, &fsl_xcvr_spdif_channels_constr,\n\t\t\t\t      &fsl_xcvr_spdif_rates_constr);\n\t\tbreak;\n\tcase FSL_XCVR_MODE_EARC:\n\t\tret = fsl_xcvr_constr(substream, &fsl_xcvr_earc_channels_constr,\n\t\t\t\t      &fsl_xcvr_earc_rates_constr);\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn ret;\n\n\txcvr->streams |= BIT(substream->stream);\n\n\tif (!xcvr->soc_data->spdif_only) {\n\t\t \n\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_mode_kctl.name, false);\n\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_arc_mode_kctl.name, false);\n\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_earc_capds_kctl.name, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void fsl_xcvr_shutdown(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tu32 mask = 0, val = 0;\n\tint ret;\n\n\txcvr->streams &= ~BIT(substream->stream);\n\n\t \n\tif (!xcvr->streams) {\n\t\tif (!xcvr->soc_data->spdif_only) {\n\t\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_mode_kctl.name, true);\n\t\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_arc_mode_kctl.name,\n\t\t\t\t\t\t(xcvr->mode == FSL_XCVR_MODE_ARC));\n\t\t\tfsl_xcvr_activate_ctl(dai, fsl_xcvr_earc_capds_kctl.name,\n\t\t\t\t\t\t(xcvr->mode == FSL_XCVR_MODE_EARC));\n\t\t}\n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_IER0,\n\t\t\t\t\t FSL_XCVR_IRQ_EARC_ALL, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"Failed to set IER0: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (xcvr->mode == FSL_XCVR_MODE_SPDIF)\n\t\t\tmask |= FSL_XCVR_EXT_CTRL_SPDIF_MODE;\n\t}\n\n\tif (xcvr->mode == FSL_XCVR_MODE_EARC) {\n\t\t \n\t\tmask |= FSL_XCVR_EXT_CTRL_CMDC_RESET(tx);\n\t\tval  |= FSL_XCVR_EXT_CTRL_CMDC_RESET(tx);\n\t}\n\n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL, mask, val);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Err setting DPATH RESET: %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nstatic int fsl_xcvr_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (tx) {\n\t\t\tswitch (xcvr->mode) {\n\t\t\tcase FSL_XCVR_MODE_EARC:\n\t\t\t\t \n\t\t\t\tret = regmap_write(xcvr->regmap,\n\t\t\t\t\t\t   FSL_XCVR_ISR_SET,\n\t\t\t\t\t\t   FSL_XCVR_ISR_CMDC_TX_EN);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dai->dev, \"err updating isr %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase FSL_XCVR_MODE_SPDIF:\n\t\t\t\tret = regmap_write(xcvr->regmap,\n\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_SET,\n\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_STRT_DATA_TX);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dai->dev, \"Failed to start DATA_TX: %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_DMA_DIS(tx), 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"Failed to enable DMA: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_DPTH_RESET(tx),\n\t\t\t\t\t 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"Failed to clear DPATH RESET: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_DMA_DIS(tx),\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_DMA_DIS(tx));\n\t\tif (ret < 0) {\n\t\t\tdev_err(dai->dev, \"Failed to disable DMA: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (tx) {\n\t\t\tswitch (xcvr->mode) {\n\t\t\tcase FSL_XCVR_MODE_SPDIF:\n\t\t\t\tret = regmap_write(xcvr->regmap,\n\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_CLR,\n\t\t\t\t\t FSL_XCVR_TX_DPTH_CTRL_STRT_DATA_TX);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dai->dev, \"Failed to stop DATA_TX: %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tif (xcvr->soc_data->spdif_only)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\tfallthrough;\n\t\t\tcase FSL_XCVR_MODE_EARC:\n\t\t\t\t \n\t\t\t\tret = regmap_write(xcvr->regmap,\n\t\t\t\t\t\t   FSL_XCVR_ISR_CLR,\n\t\t\t\t\t\t   FSL_XCVR_ISR_CMDC_TX_EN);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(dai->dev,\n\t\t\t\t\t\t\"Err updating ISR %d\\n\", ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_load_firmware(struct fsl_xcvr *xcvr)\n{\n\tstruct device *dev = &xcvr->pdev->dev;\n\tconst struct firmware *fw;\n\tint ret = 0, rem, off, out, page = 0, size = FSL_XCVR_REG_OFFSET;\n\tu32 mask, val;\n\n\tret = request_firmware(&fw, xcvr->soc_data->fw_name, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request firmware.\\n\");\n\t\treturn ret;\n\t}\n\n\trem = fw->size;\n\n\t \n\tif (rem > 16384) {\n\t\tdev_err(dev, \"FW size %d is bigger than 16KiB.\\n\", rem);\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (page = 0; page < 10; page++) {\n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_PAGE_MASK,\n\t\t\t\t\t FSL_XCVR_EXT_CTRL_PAGE(page));\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"FW: failed to set page %d, err=%d\\n\",\n\t\t\t\tpage, ret);\n\t\t\tgoto err_firmware;\n\t\t}\n\n\t\toff = page * size;\n\t\tout = min(rem, size);\n\t\t \n\t\tif (out > 0) {\n\t\t\t \n\t\t\tmemcpy_toio(xcvr->ram_addr, fw->data + off, out);\n\t\t\trem -= out;\n\t\t\tif (rem == 0) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmemset_io(xcvr->ram_addr + out, 0, size - out);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tmemset_io(xcvr->ram_addr, 0, size);\n\t\t}\n\t}\n\nerr_firmware:\n\trelease_firmware(fw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmask = FSL_XCVR_EXT_CTRL_RX_FWM_MASK | FSL_XCVR_EXT_CTRL_TX_FWM_MASK;\n\tval  = FSL_XCVR_EXT_CTRL_RX_FWM(FSL_XCVR_FIFO_WMK_RX);\n\tval |= FSL_XCVR_EXT_CTRL_TX_FWM(FSL_XCVR_FIFO_WMK_TX);\n\t \n\tmask |= FSL_XCVR_EXT_CTRL_DMA_RD_DIS | FSL_XCVR_EXT_CTRL_DMA_WR_DIS;\n\tval  |= FSL_XCVR_EXT_CTRL_DMA_RD_DIS | FSL_XCVR_EXT_CTRL_DMA_WR_DIS;\n\t \n\tmask |= FSL_XCVR_EXT_CTRL_PAGE_MASK;\n\tval  |= FSL_XCVR_EXT_CTRL_PAGE(8);\n\n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL, mask, val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to set watermarks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmemcpy_toio(xcvr->ram_addr + FSL_XCVR_CAP_DATA_STR, xcvr->cap_ds,\n\t\t    FSL_XCVR_CAPDS_SIZE);\n\treturn 0;\n}\n\nstatic int fsl_xcvr_type_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_type_iec958_bytes_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = sizeof_field(struct snd_aes_iec958, status);\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_rx_cs_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tmemcpy(ucontrol->value.iec958.status, xcvr->rx_iec958.status, 24);\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_tx_cs_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tmemcpy(ucontrol->value.iec958.status, xcvr->tx_iec958.status, 24);\n\n\treturn 0;\n}\n\nstatic int fsl_xcvr_tx_cs_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tmemcpy(xcvr->tx_iec958.status, ucontrol->value.iec958.status, 24);\n\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new fsl_xcvr_rx_ctls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = fsl_xcvr_type_iec958_info,\n\t\t.get = fsl_xcvr_rx_cs_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"Capture Channel Status\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.info = fsl_xcvr_type_iec958_bytes_info,\n\t\t.get = fsl_xcvr_rx_cs_get,\n\t},\n};\n\nstatic struct snd_kcontrol_new fsl_xcvr_tx_ctls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = fsl_xcvr_type_iec958_info,\n\t\t.get = fsl_xcvr_tx_cs_get,\n\t\t.put = fsl_xcvr_tx_cs_put,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"Playback Channel Status\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = fsl_xcvr_type_iec958_bytes_info,\n\t\t.get = fsl_xcvr_tx_cs_get,\n\t\t.put = fsl_xcvr_tx_cs_put,\n\t},\n};\n\nstatic int fsl_xcvr_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct fsl_xcvr *xcvr = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &xcvr->dma_prms_tx, &xcvr->dma_prms_rx);\n\n\tif (xcvr->soc_data->spdif_only)\n\t\txcvr->mode = FSL_XCVR_MODE_SPDIF;\n\telse {\n\t\tsnd_soc_add_dai_controls(dai, &fsl_xcvr_mode_kctl, 1);\n\t\tsnd_soc_add_dai_controls(dai, &fsl_xcvr_arc_mode_kctl, 1);\n\t\tsnd_soc_add_dai_controls(dai, &fsl_xcvr_earc_capds_kctl, 1);\n\t}\n\tsnd_soc_add_dai_controls(dai, fsl_xcvr_tx_ctls,\n\t\t\t\t ARRAY_SIZE(fsl_xcvr_tx_ctls));\n\tsnd_soc_add_dai_controls(dai, fsl_xcvr_rx_ctls,\n\t\t\t\t ARRAY_SIZE(fsl_xcvr_rx_ctls));\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_xcvr_dai_ops = {\n\t.probe\t\t= fsl_xcvr_dai_probe,\n\t.prepare\t= fsl_xcvr_prepare,\n\t.startup\t= fsl_xcvr_startup,\n\t.shutdown\t= fsl_xcvr_shutdown,\n\t.trigger\t= fsl_xcvr_trigger,\n};\n\nstatic struct snd_soc_dai_driver fsl_xcvr_dai = {\n\t.ops = &fsl_xcvr_dai_ops,\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 32000,\n\t\t.rate_max = 1536000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rate_min = 32000,\n\t\t.rate_max = 1536000,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE,\n\t},\n};\n\nstatic const struct snd_soc_component_driver fsl_xcvr_comp = {\n\t.name\t\t\t= \"fsl-xcvr-dai\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic const struct reg_default fsl_xcvr_reg_defaults[] = {\n\t{ FSL_XCVR_VERSION,\t0x00000000 },\n\t{ FSL_XCVR_EXT_CTRL,\t0xF8204040 },\n\t{ FSL_XCVR_EXT_STATUS,\t0x00000000 },\n\t{ FSL_XCVR_EXT_IER0,\t0x00000000 },\n\t{ FSL_XCVR_EXT_IER1,\t0x00000000 },\n\t{ FSL_XCVR_EXT_ISR,\t0x00000000 },\n\t{ FSL_XCVR_EXT_ISR_SET,\t0x00000000 },\n\t{ FSL_XCVR_EXT_ISR_CLR,\t0x00000000 },\n\t{ FSL_XCVR_EXT_ISR_TOG,\t0x00000000 },\n\t{ FSL_XCVR_IER,\t\t0x00000000 },\n\t{ FSL_XCVR_ISR,\t\t0x00000000 },\n\t{ FSL_XCVR_ISR_SET,\t0x00000000 },\n\t{ FSL_XCVR_ISR_CLR,\t0x00000000 },\n\t{ FSL_XCVR_ISR_TOG,\t0x00000000 },\n\t{ FSL_XCVR_CLK_CTRL,\t0x0000018F },\n\t{ FSL_XCVR_RX_DPTH_CTRL,\t0x00040CC1 },\n\t{ FSL_XCVR_RX_DPTH_CTRL_SET,\t0x00040CC1 },\n\t{ FSL_XCVR_RX_DPTH_CTRL_CLR,\t0x00040CC1 },\n\t{ FSL_XCVR_RX_DPTH_CTRL_TOG,\t0x00040CC1 },\n\t{ FSL_XCVR_RX_DPTH_CNTR_CTRL,\t0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_CNTR_CTRL_SET, 0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR, 0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG, 0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_TSCR, 0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_BCR,  0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_BCTR, 0x00000000 },\n\t{ FSL_XCVR_RX_DPTH_BCRR, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CTRL,\t0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CTRL_SET,\t0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CTRL_CLR,\t0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CTRL_TOG,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_0,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_1,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_2,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_3,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_4,\t0x00000000 },\n\t{ FSL_XCVR_TX_CS_DATA_5,\t0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CNTR_CTRL,\t0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CNTR_CTRL_SET, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_TSCR, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_BCR,\t 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_BCTR, 0x00000000 },\n\t{ FSL_XCVR_TX_DPTH_BCRR, 0x00000000 },\n\t{ FSL_XCVR_DEBUG_REG_0,\t\t0x00000000 },\n\t{ FSL_XCVR_DEBUG_REG_1,\t\t0x00000000 },\n};\n\nstatic bool fsl_xcvr_readable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct fsl_xcvr *xcvr = dev_get_drvdata(dev);\n\n\tif (xcvr->soc_data->spdif_only)\n\t\tif ((reg >= FSL_XCVR_IER && reg <= FSL_XCVR_PHY_AI_RDATA) ||\n\t\t    reg > FSL_XCVR_TX_DPTH_BCRR)\n\t\t\treturn false;\n\tswitch (reg) {\n\tcase FSL_XCVR_VERSION:\n\tcase FSL_XCVR_EXT_CTRL:\n\tcase FSL_XCVR_EXT_STATUS:\n\tcase FSL_XCVR_EXT_IER0:\n\tcase FSL_XCVR_EXT_IER1:\n\tcase FSL_XCVR_EXT_ISR:\n\tcase FSL_XCVR_EXT_ISR_SET:\n\tcase FSL_XCVR_EXT_ISR_CLR:\n\tcase FSL_XCVR_EXT_ISR_TOG:\n\tcase FSL_XCVR_IER:\n\tcase FSL_XCVR_ISR:\n\tcase FSL_XCVR_ISR_SET:\n\tcase FSL_XCVR_ISR_CLR:\n\tcase FSL_XCVR_ISR_TOG:\n\tcase FSL_XCVR_PHY_AI_CTRL:\n\tcase FSL_XCVR_PHY_AI_CTRL_SET:\n\tcase FSL_XCVR_PHY_AI_CTRL_CLR:\n\tcase FSL_XCVR_PHY_AI_CTRL_TOG:\n\tcase FSL_XCVR_PHY_AI_RDATA:\n\tcase FSL_XCVR_CLK_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CTRL_SET:\n\tcase FSL_XCVR_RX_DPTH_CTRL_CLR:\n\tcase FSL_XCVR_RX_DPTH_CTRL_TOG:\n\tcase FSL_XCVR_RX_CS_DATA_0:\n\tcase FSL_XCVR_RX_CS_DATA_1:\n\tcase FSL_XCVR_RX_CS_DATA_2:\n\tcase FSL_XCVR_RX_CS_DATA_3:\n\tcase FSL_XCVR_RX_CS_DATA_4:\n\tcase FSL_XCVR_RX_CS_DATA_5:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_SET:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG:\n\tcase FSL_XCVR_RX_DPTH_TSCR:\n\tcase FSL_XCVR_RX_DPTH_BCR:\n\tcase FSL_XCVR_RX_DPTH_BCTR:\n\tcase FSL_XCVR_RX_DPTH_BCRR:\n\tcase FSL_XCVR_TX_DPTH_CTRL:\n\tcase FSL_XCVR_TX_DPTH_CTRL_SET:\n\tcase FSL_XCVR_TX_DPTH_CTRL_CLR:\n\tcase FSL_XCVR_TX_DPTH_CTRL_TOG:\n\tcase FSL_XCVR_TX_CS_DATA_0:\n\tcase FSL_XCVR_TX_CS_DATA_1:\n\tcase FSL_XCVR_TX_CS_DATA_2:\n\tcase FSL_XCVR_TX_CS_DATA_3:\n\tcase FSL_XCVR_TX_CS_DATA_4:\n\tcase FSL_XCVR_TX_CS_DATA_5:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_SET:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG:\n\tcase FSL_XCVR_TX_DPTH_TSCR:\n\tcase FSL_XCVR_TX_DPTH_BCR:\n\tcase FSL_XCVR_TX_DPTH_BCTR:\n\tcase FSL_XCVR_TX_DPTH_BCRR:\n\tcase FSL_XCVR_DEBUG_REG_0:\n\tcase FSL_XCVR_DEBUG_REG_1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_xcvr_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tstruct fsl_xcvr *xcvr = dev_get_drvdata(dev);\n\n\tif (xcvr->soc_data->spdif_only)\n\t\tif (reg >= FSL_XCVR_IER && reg <= FSL_XCVR_PHY_AI_RDATA)\n\t\t\treturn false;\n\tswitch (reg) {\n\tcase FSL_XCVR_EXT_CTRL:\n\tcase FSL_XCVR_EXT_IER0:\n\tcase FSL_XCVR_EXT_IER1:\n\tcase FSL_XCVR_EXT_ISR:\n\tcase FSL_XCVR_EXT_ISR_SET:\n\tcase FSL_XCVR_EXT_ISR_CLR:\n\tcase FSL_XCVR_EXT_ISR_TOG:\n\tcase FSL_XCVR_IER:\n\tcase FSL_XCVR_ISR_SET:\n\tcase FSL_XCVR_ISR_CLR:\n\tcase FSL_XCVR_ISR_TOG:\n\tcase FSL_XCVR_PHY_AI_CTRL:\n\tcase FSL_XCVR_PHY_AI_CTRL_SET:\n\tcase FSL_XCVR_PHY_AI_CTRL_CLR:\n\tcase FSL_XCVR_PHY_AI_CTRL_TOG:\n\tcase FSL_XCVR_PHY_AI_WDATA:\n\tcase FSL_XCVR_CLK_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CTRL_SET:\n\tcase FSL_XCVR_RX_DPTH_CTRL_CLR:\n\tcase FSL_XCVR_RX_DPTH_CTRL_TOG:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_SET:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_CLR:\n\tcase FSL_XCVR_RX_DPTH_CNTR_CTRL_TOG:\n\tcase FSL_XCVR_TX_DPTH_CTRL_SET:\n\tcase FSL_XCVR_TX_DPTH_CTRL_CLR:\n\tcase FSL_XCVR_TX_DPTH_CTRL_TOG:\n\tcase FSL_XCVR_TX_CS_DATA_0:\n\tcase FSL_XCVR_TX_CS_DATA_1:\n\tcase FSL_XCVR_TX_CS_DATA_2:\n\tcase FSL_XCVR_TX_CS_DATA_3:\n\tcase FSL_XCVR_TX_CS_DATA_4:\n\tcase FSL_XCVR_TX_CS_DATA_5:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_SET:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_CLR:\n\tcase FSL_XCVR_TX_DPTH_CNTR_CTRL_TOG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_xcvr_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn fsl_xcvr_readable_reg(dev, reg);\n}\n\nstatic const struct regmap_config fsl_xcvr_regmap_cfg = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = FSL_XCVR_MAX_REG,\n\t.reg_defaults = fsl_xcvr_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_xcvr_reg_defaults),\n\t.readable_reg = fsl_xcvr_readable_reg,\n\t.volatile_reg = fsl_xcvr_volatile_reg,\n\t.writeable_reg = fsl_xcvr_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic irqreturn_t irq0_isr(int irq, void *devid)\n{\n\tstruct fsl_xcvr *xcvr = (struct fsl_xcvr *)devid;\n\tstruct device *dev = &xcvr->pdev->dev;\n\tstruct regmap *regmap = xcvr->regmap;\n\tvoid __iomem *reg_ctrl, *reg_buff;\n\tu32 isr, isr_clr = 0, val, i;\n\n\tregmap_read(regmap, FSL_XCVR_EXT_ISR, &isr);\n\n\tif (isr & FSL_XCVR_IRQ_NEW_CS) {\n\t\tdev_dbg(dev, \"Received new CS block\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_NEW_CS;\n\t\tif (!xcvr->soc_data->spdif_only) {\n\t\t\t \n\t\t\tregmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\t   FSL_XCVR_EXT_CTRL_PAGE_MASK,\n\t\t\t\t\t   FSL_XCVR_EXT_CTRL_PAGE(8));\n\n\t\t\t \n\t\t\treg_ctrl = xcvr->ram_addr + FSL_XCVR_RX_CS_CTRL_0;\n\t\t\treg_buff = xcvr->ram_addr + FSL_XCVR_RX_CS_BUFF_0;\n\t\t\tmemcpy_fromio(&val, reg_ctrl, sizeof(val));\n\t\t\tif (!val) {\n\t\t\t\treg_ctrl = xcvr->ram_addr + FSL_XCVR_RX_CS_CTRL_1;\n\t\t\t\treg_buff = xcvr->ram_addr + FSL_XCVR_RX_CS_BUFF_1;\n\t\t\t\tmemcpy_fromio(&val, reg_ctrl, sizeof(val));\n\t\t\t}\n\n\t\t\tif (val) {\n\t\t\t\t \n\t\t\t\tmemcpy_fromio(&xcvr->rx_iec958.status, reg_buff,\n\t\t\t\t\t      sizeof(xcvr->rx_iec958.status));\n\t\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\t\tval = *(u32 *)(xcvr->rx_iec958.status + i*4);\n\t\t\t\t\t*(u32 *)(xcvr->rx_iec958.status + i*4) =\n\t\t\t\t\t\tbitrev32(val);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tmemset_io(reg_ctrl, 0, sizeof(val));\n\t\t\t}\n\t\t}\n\t}\n\tif (isr & FSL_XCVR_IRQ_NEW_UD) {\n\t\tdev_dbg(dev, \"Received new UD block\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_NEW_UD;\n\t}\n\tif (isr & FSL_XCVR_IRQ_MUTE) {\n\t\tdev_dbg(dev, \"HW mute bit detected\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_MUTE;\n\t}\n\tif (isr & FSL_XCVR_IRQ_FIFO_UOFL_ERR) {\n\t\tdev_dbg(dev, \"RX/TX FIFO full/empty\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_FIFO_UOFL_ERR;\n\t}\n\tif (isr & FSL_XCVR_IRQ_ARC_MODE) {\n\t\tdev_dbg(dev, \"CMDC SM falls out of eARC mode\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_ARC_MODE;\n\t}\n\tif (isr & FSL_XCVR_IRQ_DMA_RD_REQ) {\n\t\tdev_dbg(dev, \"DMA read request\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_DMA_RD_REQ;\n\t}\n\tif (isr & FSL_XCVR_IRQ_DMA_WR_REQ) {\n\t\tdev_dbg(dev, \"DMA write request\\n\");\n\t\tisr_clr |= FSL_XCVR_IRQ_DMA_WR_REQ;\n\t}\n\n\tif (isr_clr) {\n\t\tregmap_write(regmap, FSL_XCVR_EXT_ISR_CLR, isr_clr);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic const struct fsl_xcvr_soc_data fsl_xcvr_imx8mp_data = {\n\t.fw_name = \"imx/xcvr/xcvr-imx8mp.bin\",\n};\n\nstatic const struct fsl_xcvr_soc_data fsl_xcvr_imx93_data = {\n\t.spdif_only = true,\n\t.use_edma = true,\n};\n\nstatic const struct of_device_id fsl_xcvr_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8mp-xcvr\", .data = &fsl_xcvr_imx8mp_data },\n\t{ .compatible = \"fsl,imx93-xcvr\", .data = &fsl_xcvr_imx93_data},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, fsl_xcvr_dt_ids);\n\nstatic int fsl_xcvr_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct fsl_xcvr *xcvr;\n\tstruct resource *rx_res, *tx_res;\n\tvoid __iomem *regs;\n\tint ret, irq;\n\n\txcvr = devm_kzalloc(dev, sizeof(*xcvr), GFP_KERNEL);\n\tif (!xcvr)\n\t\treturn -ENOMEM;\n\n\txcvr->pdev = pdev;\n\txcvr->soc_data = of_device_get_match_data(&pdev->dev);\n\n\txcvr->ipg_clk = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(xcvr->ipg_clk)) {\n\t\tdev_err(dev, \"failed to get ipg clock\\n\");\n\t\treturn PTR_ERR(xcvr->ipg_clk);\n\t}\n\n\txcvr->phy_clk = devm_clk_get(dev, \"phy\");\n\tif (IS_ERR(xcvr->phy_clk)) {\n\t\tdev_err(dev, \"failed to get phy clock\\n\");\n\t\treturn PTR_ERR(xcvr->phy_clk);\n\t}\n\n\txcvr->spba_clk = devm_clk_get(dev, \"spba\");\n\tif (IS_ERR(xcvr->spba_clk)) {\n\t\tdev_err(dev, \"failed to get spba clock\\n\");\n\t\treturn PTR_ERR(xcvr->spba_clk);\n\t}\n\n\txcvr->pll_ipg_clk = devm_clk_get(dev, \"pll_ipg\");\n\tif (IS_ERR(xcvr->pll_ipg_clk)) {\n\t\tdev_err(dev, \"failed to get pll_ipg clock\\n\");\n\t\treturn PTR_ERR(xcvr->pll_ipg_clk);\n\t}\n\n\txcvr->ram_addr = devm_platform_ioremap_resource_byname(pdev, \"ram\");\n\tif (IS_ERR(xcvr->ram_addr))\n\t\treturn PTR_ERR(xcvr->ram_addr);\n\n\tregs = devm_platform_ioremap_resource_byname(pdev, \"regs\");\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\txcvr->regmap = devm_regmap_init_mmio_clk(dev, NULL, regs,\n\t\t\t\t\t\t &fsl_xcvr_regmap_cfg);\n\tif (IS_ERR(xcvr->regmap)) {\n\t\tdev_err(dev, \"failed to init XCVR regmap: %ld\\n\",\n\t\t\tPTR_ERR(xcvr->regmap));\n\t\treturn PTR_ERR(xcvr->regmap);\n\t}\n\n\txcvr->reset = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(xcvr->reset)) {\n\t\tdev_err(dev, \"failed to get XCVR reset control\\n\");\n\t\treturn PTR_ERR(xcvr->reset);\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_irq(dev, irq, irq0_isr, 0, pdev->name, xcvr);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to claim IRQ0: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trx_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"rxfifo\");\n\ttx_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"txfifo\");\n\tif (!rx_res || !tx_res) {\n\t\tdev_err(dev, \"could not find rxfifo or txfifo resource\\n\");\n\t\treturn -EINVAL;\n\t}\n\txcvr->dma_prms_rx.chan_name = \"rx\";\n\txcvr->dma_prms_tx.chan_name = \"tx\";\n\txcvr->dma_prms_rx.addr = rx_res->start;\n\txcvr->dma_prms_tx.addr = tx_res->start;\n\txcvr->dma_prms_rx.maxburst = FSL_XCVR_MAXBURST_RX;\n\txcvr->dma_prms_tx.maxburst = FSL_XCVR_MAXBURST_TX;\n\n\tplatform_set_drvdata(pdev, xcvr);\n\tpm_runtime_enable(dev);\n\tregcache_cache_only(xcvr->regmap, true);\n\n\t \n\tret = devm_snd_dmaengine_pcm_register(dev, NULL, 0);\n\tif (ret) {\n\t\tpm_runtime_disable(dev);\n\t\tdev_err(dev, \"failed to pcm register\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &fsl_xcvr_comp,\n\t\t\t\t\t      &fsl_xcvr_dai, 1);\n\tif (ret) {\n\t\tpm_runtime_disable(dev);\n\t\tdev_err(dev, \"failed to register component %s\\n\",\n\t\t\tfsl_xcvr_comp.name);\n\t}\n\n\treturn ret;\n}\n\nstatic void fsl_xcvr_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic __maybe_unused int fsl_xcvr_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_xcvr *xcvr = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_IER0,\n\t\t\t\t FSL_XCVR_IRQ_EARC_ALL, 0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to clear IER0: %d\\n\", ret);\n\n\tif (!xcvr->soc_data->spdif_only) {\n\t\t \n\t\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t\tFSL_XCVR_EXT_CTRL_CORE_RESET,\n\t\t\t\t\tFSL_XCVR_EXT_CTRL_CORE_RESET);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"Failed to assert M0+ core: %d\\n\", ret);\n\t}\n\n\tregcache_cache_only(xcvr->regmap, true);\n\n\tclk_disable_unprepare(xcvr->spba_clk);\n\tclk_disable_unprepare(xcvr->phy_clk);\n\tclk_disable_unprepare(xcvr->pll_ipg_clk);\n\tclk_disable_unprepare(xcvr->ipg_clk);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int fsl_xcvr_runtime_resume(struct device *dev)\n{\n\tstruct fsl_xcvr *xcvr = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = reset_control_assert(xcvr->reset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to assert M0+ reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(xcvr->ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start IPG clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(xcvr->pll_ipg_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start PLL IPG clock.\\n\");\n\t\tgoto stop_ipg_clk;\n\t}\n\n\tret = clk_prepare_enable(xcvr->phy_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start PHY clock: %d\\n\", ret);\n\t\tgoto stop_pll_ipg_clk;\n\t}\n\n\tret = clk_prepare_enable(xcvr->spba_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to start SPBA clock.\\n\");\n\t\tgoto stop_phy_clk;\n\t}\n\n\tregcache_cache_only(xcvr->regmap, false);\n\tregcache_mark_dirty(xcvr->regmap);\n\tret = regcache_sync(xcvr->regmap);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to sync regcache.\\n\");\n\t\tgoto stop_spba_clk;\n\t}\n\n\tif (xcvr->soc_data->spdif_only)\n\t\treturn 0;\n\n\tret = reset_control_deassert(xcvr->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to deassert M0+ reset.\\n\");\n\t\tgoto stop_spba_clk;\n\t}\n\n\tret = fsl_xcvr_load_firmware(xcvr);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to load firmware.\\n\");\n\t\tgoto stop_spba_clk;\n\t}\n\n\t \n\tret = regmap_update_bits(xcvr->regmap, FSL_XCVR_EXT_CTRL,\n\t\t\t\t FSL_XCVR_EXT_CTRL_CORE_RESET, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"M0+ core release failed: %d\\n\", ret);\n\t\tgoto stop_spba_clk;\n\t}\n\n\t \n\tmsleep(50);\n\n\treturn 0;\n\nstop_spba_clk:\n\tclk_disable_unprepare(xcvr->spba_clk);\nstop_phy_clk:\n\tclk_disable_unprepare(xcvr->phy_clk);\nstop_pll_ipg_clk:\n\tclk_disable_unprepare(xcvr->pll_ipg_clk);\nstop_ipg_clk:\n\tclk_disable_unprepare(xcvr->ipg_clk);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops fsl_xcvr_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_xcvr_runtime_suspend,\n\t\t\t   fsl_xcvr_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver fsl_xcvr_driver = {\n\t.probe = fsl_xcvr_probe,\n\t.driver = {\n\t\t.name = \"fsl,imx8mp-audio-xcvr\",\n\t\t.pm = &fsl_xcvr_pm_ops,\n\t\t.of_match_table = fsl_xcvr_dt_ids,\n\t},\n\t.remove_new = fsl_xcvr_remove,\n};\nmodule_platform_driver(fsl_xcvr_driver);\n\nMODULE_AUTHOR(\"Viorel Suman <viorel.suman@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP Audio Transceiver (XCVR) driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}