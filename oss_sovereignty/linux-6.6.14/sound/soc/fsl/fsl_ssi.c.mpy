{
  "module_name": "fsl_ssi.c",
  "hash_id": "567d6a607a671447a46962aaa20763e3250aab34bf322c098715a1d47c75a41d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_ssi.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/clk.h>\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/dma/imx-dma.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"fsl_ssi.h\"\n#include \"imx-pcm.h\"\n\n \n#define RX 0\n#define TX 1\n\n \n#ifdef __BIG_ENDIAN\n#define FSLSSI_I2S_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S8 | \\\n\t SNDRV_PCM_FMTBIT_S16_BE | \\\n\t SNDRV_PCM_FMTBIT_S18_3BE | \\\n\t SNDRV_PCM_FMTBIT_S20_3BE | \\\n\t SNDRV_PCM_FMTBIT_S24_3BE | \\\n\t SNDRV_PCM_FMTBIT_S24_BE)\n#else\n#define FSLSSI_I2S_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S8 | \\\n\t SNDRV_PCM_FMTBIT_S16_LE | \\\n\t SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t SNDRV_PCM_FMTBIT_S24_LE)\n#endif\n\n \n#define FSLSSI_AC97_DAIFMT \\\n\t(SND_SOC_DAIFMT_AC97 | \\\n\t SND_SOC_DAIFMT_BC_FP | \\\n\t SND_SOC_DAIFMT_NB_NF)\n\n#define FSLSSI_SIER_DBG_RX_FLAGS \\\n\t(SSI_SIER_RFF0_EN | \\\n\t SSI_SIER_RLS_EN | \\\n\t SSI_SIER_RFS_EN | \\\n\t SSI_SIER_ROE0_EN | \\\n\t SSI_SIER_RFRC_EN)\n#define FSLSSI_SIER_DBG_TX_FLAGS \\\n\t(SSI_SIER_TFE0_EN | \\\n\t SSI_SIER_TLS_EN | \\\n\t SSI_SIER_TFS_EN | \\\n\t SSI_SIER_TUE0_EN | \\\n\t SSI_SIER_TFRC_EN)\n\nenum fsl_ssi_type {\n\tFSL_SSI_MCP8610,\n\tFSL_SSI_MX21,\n\tFSL_SSI_MX35,\n\tFSL_SSI_MX51,\n};\n\nstruct fsl_ssi_regvals {\n\tu32 sier;\n\tu32 srcr;\n\tu32 stcr;\n\tu32 scr;\n};\n\nstatic bool fsl_ssi_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SSI_SACCEN:\n\tcase REG_SSI_SACCDIS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool fsl_ssi_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SSI_STX0:\n\tcase REG_SSI_STX1:\n\tcase REG_SSI_SRX0:\n\tcase REG_SSI_SRX1:\n\tcase REG_SSI_SISR:\n\tcase REG_SSI_SFCSR:\n\tcase REG_SSI_SACNT:\n\tcase REG_SSI_SACADD:\n\tcase REG_SSI_SACDAT:\n\tcase REG_SSI_SATAG:\n\tcase REG_SSI_SACCST:\n\tcase REG_SSI_SOR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_ssi_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SSI_SRX0:\n\tcase REG_SSI_SRX1:\n\tcase REG_SSI_SISR:\n\tcase REG_SSI_SACADD:\n\tcase REG_SSI_SACDAT:\n\tcase REG_SSI_SATAG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_ssi_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SSI_SRX0:\n\tcase REG_SSI_SRX1:\n\tcase REG_SSI_SACCST:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct regmap_config fsl_ssi_regconfig = {\n\t.max_register = REG_SSI_SACCDIS,\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.val_format_endian = REGMAP_ENDIAN_NATIVE,\n\t.num_reg_defaults_raw = REG_SSI_SACCDIS / sizeof(uint32_t) + 1,\n\t.readable_reg = fsl_ssi_readable_reg,\n\t.volatile_reg = fsl_ssi_volatile_reg,\n\t.precious_reg = fsl_ssi_precious_reg,\n\t.writeable_reg = fsl_ssi_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstruct fsl_ssi_soc_data {\n\tbool imx;\n\tbool imx21regs;  \n\tbool offline_config;\n\tu32 sisr_write_mask;\n};\n\n \nstruct fsl_ssi {\n\tstruct regmap *regs;\n\tint irq;\n\tstruct snd_soc_dai_driver cpu_dai_drv;\n\n\tunsigned int dai_fmt;\n\tu8 streams;\n\tu8 i2s_net;\n\tbool synchronous;\n\tbool use_dma;\n\tbool use_dual_fifo;\n\tbool use_dyna_fifo;\n\tbool has_ipg_clk_name;\n\tunsigned int fifo_depth;\n\tunsigned int slot_width;\n\tunsigned int slots;\n\tstruct fsl_ssi_regvals regvals[2];\n\n\tstruct clk *clk;\n\tstruct clk *baudclk;\n\tunsigned int baudclk_streams;\n\n\tu32 regcache_sfcsr;\n\tu32 regcache_sacnt;\n\n\tstruct snd_dmaengine_dai_dma_data dma_params_tx;\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n\tdma_addr_t ssi_phys;\n\n\tstruct imx_pcm_fiq_params fiq_params;\n\n\tstruct platform_device *card_pdev;\n\tchar card_name[32];\n\tu32 card_idx;\n\n\tstruct fsl_ssi_dbg dbg_stats;\n\n\tconst struct fsl_ssi_soc_data *soc;\n\tstruct device *dev;\n\n\tu32 fifo_watermark;\n\tu32 dma_maxburst;\n\n\tstruct mutex ac97_reg_lock;\n\tstruct sdma_peripheral_config audio_config[2];\n};\n\n \n\nstatic struct fsl_ssi_soc_data fsl_ssi_mpc8610 = {\n\t.imx = false,\n\t.offline_config = true,\n\t.sisr_write_mask = SSI_SISR_RFRC | SSI_SISR_TFRC |\n\t\t\t   SSI_SISR_ROE0 | SSI_SISR_ROE1 |\n\t\t\t   SSI_SISR_TUE0 | SSI_SISR_TUE1,\n};\n\nstatic struct fsl_ssi_soc_data fsl_ssi_imx21 = {\n\t.imx = true,\n\t.imx21regs = true,\n\t.offline_config = true,\n\t.sisr_write_mask = 0,\n};\n\nstatic struct fsl_ssi_soc_data fsl_ssi_imx35 = {\n\t.imx = true,\n\t.offline_config = true,\n\t.sisr_write_mask = SSI_SISR_RFRC | SSI_SISR_TFRC |\n\t\t\t   SSI_SISR_ROE0 | SSI_SISR_ROE1 |\n\t\t\t   SSI_SISR_TUE0 | SSI_SISR_TUE1,\n};\n\nstatic struct fsl_ssi_soc_data fsl_ssi_imx51 = {\n\t.imx = true,\n\t.offline_config = false,\n\t.sisr_write_mask = SSI_SISR_ROE0 | SSI_SISR_ROE1 |\n\t\t\t   SSI_SISR_TUE0 | SSI_SISR_TUE1,\n};\n\nstatic const struct of_device_id fsl_ssi_ids[] = {\n\t{ .compatible = \"fsl,mpc8610-ssi\", .data = &fsl_ssi_mpc8610 },\n\t{ .compatible = \"fsl,imx51-ssi\", .data = &fsl_ssi_imx51 },\n\t{ .compatible = \"fsl,imx35-ssi\", .data = &fsl_ssi_imx35 },\n\t{ .compatible = \"fsl,imx21-ssi\", .data = &fsl_ssi_imx21 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_ssi_ids);\n\nstatic bool fsl_ssi_is_ac97(struct fsl_ssi *ssi)\n{\n\treturn (ssi->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\n\t\tSND_SOC_DAIFMT_AC97;\n}\n\nstatic bool fsl_ssi_is_i2s_clock_provider(struct fsl_ssi *ssi)\n{\n\treturn (ssi->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) ==\n\t\tSND_SOC_DAIFMT_BP_FP;\n}\n\nstatic bool fsl_ssi_is_i2s_bc_fp(struct fsl_ssi *ssi)\n{\n\treturn (ssi->dai_fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) ==\n\t\tSND_SOC_DAIFMT_BC_FP;\n}\n\n \nstatic irqreturn_t fsl_ssi_isr(int irq, void *dev_id)\n{\n\tstruct fsl_ssi *ssi = dev_id;\n\tstruct regmap *regs = ssi->regs;\n\tu32 sisr, sisr2;\n\n\tregmap_read(regs, REG_SSI_SISR, &sisr);\n\n\tsisr2 = sisr & ssi->soc->sisr_write_mask;\n\t \n\tif (sisr2)\n\t\tregmap_write(regs, REG_SSI_SISR, sisr2);\n\n\tfsl_ssi_dbg_isr(&ssi->dbg_stats, sisr);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void fsl_ssi_config_enable(struct fsl_ssi *ssi, bool tx)\n{\n\tstruct fsl_ssi_regvals *vals = ssi->regvals;\n\tint dir = tx ? TX : RX;\n\tu32 sier, srcr, stcr;\n\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SOR,\n\t\t\t   SSI_SOR_xX_CLR(tx), SSI_SOR_xX_CLR(tx));\n\n\t \n\tif (ssi->soc->offline_config && ssi->streams)\n\t\tgoto enable_scr;\n\n\tif (ssi->soc->offline_config) {\n\t\t \n\t\tsrcr = vals[RX].srcr | vals[TX].srcr;\n\t\tstcr = vals[RX].stcr | vals[TX].stcr;\n\t\tsier = vals[RX].sier | vals[TX].sier;\n\t} else {\n\t\t \n\t\tsrcr = vals[dir].srcr;\n\t\tstcr = vals[dir].stcr;\n\t\tsier = vals[dir].sier;\n\t}\n\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SRCR, srcr, srcr);\n\tregmap_update_bits(ssi->regs, REG_SSI_STCR, stcr, stcr);\n\tregmap_update_bits(ssi->regs, REG_SSI_SIER, sier, sier);\n\nenable_scr:\n\t \n\tif (ssi->use_dma && tx) {\n\t\tint try = 100;\n\t\tu32 sfcsr;\n\n\t\t \n\t\tregmap_update_bits(ssi->regs, REG_SSI_SCR,\n\t\t\t\t   SSI_SCR_SSIEN, SSI_SCR_SSIEN);\n\n\t\t \n\t\tdo {\n\t\t\tregmap_read(ssi->regs, REG_SSI_SFCSR, &sfcsr);\n\t\t\tif (SSI_SFCSR_TFCNT0(sfcsr))\n\t\t\t\tbreak;\n\t\t} while (--try);\n\n\t\t \n\t\tif (!SSI_SFCSR_TFCNT0(sfcsr))\n\t\t\tdev_warn(ssi->dev, \"Timeout waiting TX FIFO filling\\n\");\n\t}\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SCR,\n\t\t\t   vals[dir].scr, vals[dir].scr);\n\n\t \n\tssi->streams |= BIT(dir);\n}\n\n \n#define _ssi_xor_shared_bits(vals, avals, aactive) \\\n\t((vals) ^ ((avals) * (aactive)))\n\n#define ssi_excl_shared_bits(vals, avals, aactive) \\\n\t((vals) & _ssi_xor_shared_bits(vals, avals, aactive))\n\n \nstatic void fsl_ssi_config_disable(struct fsl_ssi *ssi, bool tx)\n{\n\tstruct fsl_ssi_regvals *vals, *avals;\n\tu32 sier, srcr, stcr, scr;\n\tint adir = tx ? RX : TX;\n\tint dir = tx ? TX : RX;\n\tbool aactive;\n\n\t \n\taactive = ssi->streams & BIT(adir);\n\n\tvals = &ssi->regvals[dir];\n\n\t \n\tavals = &ssi->regvals[adir];\n\n\t \n\tscr = ssi_excl_shared_bits(vals->scr, avals->scr, aactive);\n\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SCR, scr, 0);\n\n\t \n\tssi->streams &= ~BIT(dir);\n\n\t \n\tif (ssi->soc->offline_config && aactive)\n\t\tgoto fifo_clear;\n\n\tif (ssi->soc->offline_config) {\n\t\t \n\t\tsrcr = vals->srcr | avals->srcr;\n\t\tstcr = vals->stcr | avals->stcr;\n\t\tsier = vals->sier | avals->sier;\n\t} else {\n\t\t \n\t\tsier = ssi_excl_shared_bits(vals->sier, avals->sier, aactive);\n\t\tsrcr = ssi_excl_shared_bits(vals->srcr, avals->srcr, aactive);\n\t\tstcr = ssi_excl_shared_bits(vals->stcr, avals->stcr, aactive);\n\t}\n\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SRCR, srcr, 0);\n\tregmap_update_bits(ssi->regs, REG_SSI_STCR, stcr, 0);\n\tregmap_update_bits(ssi->regs, REG_SSI_SIER, sier, 0);\n\nfifo_clear:\n\t \n\tregmap_update_bits(ssi->regs, REG_SSI_SOR,\n\t\t\t   SSI_SOR_xX_CLR(tx), SSI_SOR_xX_CLR(tx));\n}\n\nstatic void fsl_ssi_tx_ac97_saccst_setup(struct fsl_ssi *ssi)\n{\n\tstruct regmap *regs = ssi->regs;\n\n\t \n\tif (!ssi->soc->imx21regs) {\n\t\t \n\t\tregmap_write(regs, REG_SSI_SACCDIS, 0xff);\n\t\t \n\t\tregmap_write(regs, REG_SSI_SACCEN, 0x300);\n\t}\n}\n\n \nstatic void fsl_ssi_setup_regvals(struct fsl_ssi *ssi)\n{\n\tstruct fsl_ssi_regvals *vals = ssi->regvals;\n\n\tvals[RX].sier = SSI_SIER_RFF0_EN | FSLSSI_SIER_DBG_RX_FLAGS;\n\tvals[RX].srcr = SSI_SRCR_RFEN0;\n\tvals[RX].scr = SSI_SCR_SSIEN | SSI_SCR_RE;\n\tvals[TX].sier = SSI_SIER_TFE0_EN | FSLSSI_SIER_DBG_TX_FLAGS;\n\tvals[TX].stcr = SSI_STCR_TFEN0;\n\tvals[TX].scr = SSI_SCR_SSIEN | SSI_SCR_TE;\n\n\t \n\tif (fsl_ssi_is_ac97(ssi))\n\t\tvals[RX].scr = vals[TX].scr = 0;\n\n\tif (ssi->use_dual_fifo) {\n\t\tvals[RX].srcr |= SSI_SRCR_RFEN1;\n\t\tvals[TX].stcr |= SSI_STCR_TFEN1;\n\t}\n\n\tif (ssi->use_dma) {\n\t\tvals[RX].sier |= SSI_SIER_RDMAE;\n\t\tvals[TX].sier |= SSI_SIER_TDMAE;\n\t} else {\n\t\tvals[RX].sier |= SSI_SIER_RIE;\n\t\tvals[TX].sier |= SSI_SIER_TIE;\n\t}\n}\n\nstatic void fsl_ssi_setup_ac97(struct fsl_ssi *ssi)\n{\n\tstruct regmap *regs = ssi->regs;\n\n\t \n\tregmap_write(regs, REG_SSI_STCCR, SSI_SxCCR_WL(17) | SSI_SxCCR_DC(13));\n\tregmap_write(regs, REG_SSI_SRCCR, SSI_SxCCR_WL(17) | SSI_SxCCR_DC(13));\n\n\t \n\tregmap_write(regs, REG_SSI_SACNT, SSI_SACNT_AC97EN | SSI_SACNT_FV);\n\n\t \n\tregmap_update_bits(regs, REG_SSI_SCR,\n\t\t\t   SSI_SCR_SSIEN | SSI_SCR_TE | SSI_SCR_RE,\n\t\t\t   SSI_SCR_SSIEN | SSI_SCR_TE | SSI_SCR_RE);\n\n\tregmap_write(regs, REG_SSI_SOR, SSI_SOR_WAIT(3));\n}\n\nstatic int fsl_ssi_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tint ret;\n\n\tret = clk_prepare_enable(ssi->clk);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ssi->use_dual_fifo || ssi->use_dyna_fifo)\n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\n\n\treturn 0;\n}\n\nstatic void fsl_ssi_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tclk_disable_unprepare(ssi->clk);\n}\n\n \nstatic int fsl_ssi_set_bclk(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai,\n\t\t\t    struct snd_pcm_hw_params *hw_params)\n{\n\tbool tx2, tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *regs = ssi->regs;\n\tu32 pm = 999, div2, psr, stccr, mask, afreq, factor, i;\n\tunsigned long clkrate, baudrate, tmprate;\n\tunsigned int channels = params_channels(hw_params);\n\tunsigned int slot_width = params_width(hw_params);\n\tunsigned int slots = 2;\n\tu64 sub, savesub = 100000;\n\tunsigned int freq;\n\tbool baudclk_is_used;\n\tint ret;\n\n\t \n\tif (ssi->slots)\n\t\tslots = ssi->slots;\n\tif (ssi->slot_width)\n\t\tslot_width = ssi->slot_width;\n\n\t \n\tif (channels == 2 &&\n\t    (ssi->i2s_net & SSI_SCR_I2S_MODE_MASK) == SSI_SCR_I2S_MODE_MASTER)\n\t\tslot_width = 32;\n\n\t \n\tfreq = slots * slot_width * params_rate(hw_params);\n\n\t \n\tif (IS_ERR(ssi->baudclk))\n\t\treturn -EINVAL;\n\n\t \n\tif (freq * 5 > clk_get_rate(ssi->clk)) {\n\t\tdev_err(dai->dev, \"bitclk > ipgclk / 5\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbaudclk_is_used = ssi->baudclk_streams & ~(BIT(substream->stream));\n\n\t \n\tpsr = 0;\n\tdiv2 = 0;\n\n\tfactor = (div2 + 1) * (7 * psr + 1) * 2;\n\n\tfor (i = 0; i < 255; i++) {\n\t\ttmprate = freq * factor * (i + 1);\n\n\t\tif (baudclk_is_used)\n\t\t\tclkrate = clk_get_rate(ssi->baudclk);\n\t\telse\n\t\t\tclkrate = clk_round_rate(ssi->baudclk, tmprate);\n\n\t\tclkrate /= factor;\n\t\tafreq = clkrate / (i + 1);\n\n\t\tif (freq == afreq)\n\t\t\tsub = 0;\n\t\telse if (freq / afreq == 1)\n\t\t\tsub = freq - afreq;\n\t\telse if (afreq / freq == 1)\n\t\t\tsub = afreq - freq;\n\t\telse\n\t\t\tcontinue;\n\n\t\t \n\t\tsub *= 100000;\n\t\tdo_div(sub, freq);\n\n\t\tif (sub < savesub && !(i == 0)) {\n\t\t\tbaudrate = tmprate;\n\t\t\tsavesub = sub;\n\t\t\tpm = i;\n\t\t}\n\n\t\t \n\t\tif (savesub == 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (pm == 999) {\n\t\tdev_err(dai->dev, \"failed to handle the required sysclk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstccr = SSI_SxCCR_PM(pm + 1);\n\tmask = SSI_SxCCR_PM_MASK | SSI_SxCCR_DIV2 | SSI_SxCCR_PSR;\n\n\t \n\ttx2 = tx || ssi->synchronous;\n\tregmap_update_bits(regs, REG_SSI_SxCCR(tx2), mask, stccr);\n\n\tif (!baudclk_is_used) {\n\t\tret = clk_set_rate(ssi->baudclk, baudrate);\n\t\tif (ret) {\n\t\t\tdev_err(dai->dev, \"failed to set baudclk rate\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_ssi_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tbool tx2, tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(dai);\n\tstruct fsl_ssi_regvals *vals = ssi->regvals;\n\tstruct regmap *regs = ssi->regs;\n\tunsigned int channels = params_channels(hw_params);\n\tunsigned int sample_size = params_width(hw_params);\n\tu32 wl = SSI_SxCCR_WL(sample_size);\n\tint ret;\n\n\tif (fsl_ssi_is_i2s_clock_provider(ssi)) {\n\t\tret = fsl_ssi_set_bclk(substream, dai, hw_params);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(ssi->baudclk_streams & BIT(substream->stream))) {\n\t\t\tret = clk_prepare_enable(ssi->baudclk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tssi->baudclk_streams |= BIT(substream->stream);\n\t\t}\n\t}\n\n\t \n\tif (ssi->streams && ssi->synchronous)\n\t\treturn 0;\n\n\tif (!fsl_ssi_is_ac97(ssi)) {\n\t\t \n\t\tu8 i2s_net = ssi->i2s_net;\n\n\t\t \n\t\tif (fsl_ssi_is_i2s_bc_fp(ssi) && sample_size == 16)\n\t\t\ti2s_net = SSI_SCR_I2S_MODE_NORMAL | SSI_SCR_NET;\n\n\t\t \n\t\tif (channels == 1)\n\t\t\ti2s_net = SSI_SCR_I2S_MODE_NORMAL;\n\n\t\tregmap_update_bits(regs, REG_SSI_SCR,\n\t\t\t\t   SSI_SCR_I2S_NET_MASK, i2s_net);\n\t}\n\n\t \n\ttx2 = tx || ssi->synchronous;\n\tregmap_update_bits(regs, REG_SSI_SxCCR(tx2), SSI_SxCCR_WL_MASK, wl);\n\n\tif (ssi->use_dyna_fifo) {\n\t\tif (channels == 1) {\n\t\t\tssi->audio_config[0].n_fifos_dst = 1;\n\t\t\tssi->audio_config[1].n_fifos_src = 1;\n\t\t\tvals[RX].srcr &= ~SSI_SRCR_RFEN1;\n\t\t\tvals[TX].stcr &= ~SSI_STCR_TFEN1;\n\t\t\tvals[RX].scr  &= ~SSI_SCR_TCH_EN;\n\t\t\tvals[TX].scr  &= ~SSI_SCR_TCH_EN;\n\t\t} else {\n\t\t\tssi->audio_config[0].n_fifos_dst = 2;\n\t\t\tssi->audio_config[1].n_fifos_src = 2;\n\t\t\tvals[RX].srcr |= SSI_SRCR_RFEN1;\n\t\t\tvals[TX].stcr |= SSI_STCR_TFEN1;\n\t\t\tvals[RX].scr  |= SSI_SCR_TCH_EN;\n\t\t\tvals[TX].scr  |= SSI_SCR_TCH_EN;\n\t\t}\n\t\tssi->dma_params_tx.peripheral_config = &ssi->audio_config[0];\n\t\tssi->dma_params_tx.peripheral_size = sizeof(ssi->audio_config[0]);\n\t\tssi->dma_params_rx.peripheral_config = &ssi->audio_config[1];\n\t\tssi->dma_params_rx.peripheral_size = sizeof(ssi->audio_config[1]);\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_ssi_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tif (fsl_ssi_is_i2s_clock_provider(ssi) &&\n\t    ssi->baudclk_streams & BIT(substream->stream)) {\n\t\tclk_disable_unprepare(ssi->baudclk);\n\t\tssi->baudclk_streams &= ~BIT(substream->stream);\n\t}\n\n\treturn 0;\n}\n\nstatic int _fsl_ssi_set_dai_fmt(struct fsl_ssi *ssi, unsigned int fmt)\n{\n\tu32 strcr = 0, scr = 0, stcr, srcr, mask;\n\tunsigned int slots;\n\n\tssi->dai_fmt = fmt;\n\n\t \n\tscr |= SSI_SCR_SYNC_TX_FS;\n\n\t \n\tstrcr |= SSI_STCR_TXBIT0;\n\n\t \n\tssi->i2s_net = SSI_SCR_NET;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t\tif (IS_ERR(ssi->baudclk)) {\n\t\t\t\tdev_err(ssi->dev,\n\t\t\t\t\t\"missing baudclk for master mode\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t\tssi->i2s_net |= SSI_SCR_I2S_MODE_MASTER;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t\tssi->i2s_net |= SSI_SCR_I2S_MODE_SLAVE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tslots = ssi->slots ? : 2;\n\t\tregmap_update_bits(ssi->regs, REG_SSI_STCCR,\n\t\t\t\t   SSI_SxCCR_DC_MASK, SSI_SxCCR_DC(slots));\n\t\tregmap_update_bits(ssi->regs, REG_SSI_SRCCR,\n\t\t\t\t   SSI_SxCCR_DC_MASK, SSI_SxCCR_DC(slots));\n\n\t\t \n\t\tstrcr |= SSI_STCR_TFSI | SSI_STCR_TSCKP | SSI_STCR_TEFS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\tstrcr |= SSI_STCR_TSCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\tstrcr |= SSI_STCR_TFSL | SSI_STCR_TSCKP | SSI_STCR_TEFS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tstrcr |= SSI_STCR_TFSL | SSI_STCR_TSCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_AC97:\n\t\t \n\t\tstrcr |= SSI_STCR_TEFS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tscr |= ssi->i2s_net;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tstrcr ^= SSI_STCR_TSCKP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t \n\t\tstrcr ^= SSI_STCR_TFSI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\tstrcr ^= SSI_STCR_TSCKP;\n\t\tstrcr ^= SSI_STCR_TFSI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tstrcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;\n\t\tscr |= SSI_SCR_SYS_CLK_EN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t \n\t\tstrcr |= SSI_STCR_TFDIR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstcr = strcr;\n\tsrcr = strcr;\n\n\t \n\tif (ssi->synchronous || fsl_ssi_is_ac97(ssi)) {\n\t\tsrcr &= ~SSI_SRCR_RXDIR;\n\t\tscr |= SSI_SCR_SYN;\n\t}\n\n\tmask = SSI_STCR_TFDIR | SSI_STCR_TXDIR | SSI_STCR_TSCKP |\n\t       SSI_STCR_TFSL | SSI_STCR_TFSI | SSI_STCR_TEFS | SSI_STCR_TXBIT0;\n\n\tregmap_update_bits(ssi->regs, REG_SSI_STCR, mask, stcr);\n\tregmap_update_bits(ssi->regs, REG_SSI_SRCR, mask, srcr);\n\n\tmask = SSI_SCR_SYNC_TX_FS | SSI_SCR_I2S_MODE_MASK |\n\t       SSI_SCR_SYS_CLK_EN | SSI_SCR_SYN;\n\tregmap_update_bits(ssi->regs, REG_SSI_SCR, mask, scr);\n\n\treturn 0;\n}\n\n \nstatic int fsl_ssi_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tif (fsl_ssi_is_ac97(ssi))\n\t\treturn 0;\n\n\treturn _fsl_ssi_set_dai_fmt(ssi, fmt);\n}\n\n \nstatic int fsl_ssi_set_dai_tdm_slot(struct snd_soc_dai *dai, u32 tx_mask,\n\t\t\t\t    u32 rx_mask, int slots, int slot_width)\n{\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *regs = ssi->regs;\n\tu32 val;\n\n\t \n\tif (slot_width & 1 || slot_width < 8 || slot_width > 24) {\n\t\tdev_err(dai->dev, \"invalid slot width: %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ssi->i2s_net && slots < 2) {\n\t\tdev_err(dai->dev, \"slot number should be >= 2 in I2S or NET\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(regs, REG_SSI_STCCR,\n\t\t\t   SSI_SxCCR_DC_MASK, SSI_SxCCR_DC(slots));\n\tregmap_update_bits(regs, REG_SSI_SRCCR,\n\t\t\t   SSI_SxCCR_DC_MASK, SSI_SxCCR_DC(slots));\n\n\t \n\tregmap_read(regs, REG_SSI_SCR, &val);\n\t \n\tregmap_update_bits(regs, REG_SSI_SCR, SSI_SCR_SSIEN, SSI_SCR_SSIEN);\n\n\tregmap_write(regs, REG_SSI_STMSK, ~tx_mask);\n\tregmap_write(regs, REG_SSI_SRMSK, ~rx_mask);\n\n\t \n\tregmap_update_bits(regs, REG_SSI_SCR, SSI_SCR_SSIEN, val);\n\n\tssi->slot_width = slot_width;\n\tssi->slots = slots;\n\n\treturn 0;\n}\n\n \nstatic int fsl_ssi_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\t \n\t\tif (tx && fsl_ssi_is_ac97(ssi))\n\t\t\tfsl_ssi_tx_ac97_saccst_setup(ssi);\n\t\tfsl_ssi_config_enable(ssi, tx);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tfsl_ssi_config_disable(ssi, tx);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_ssi_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct fsl_ssi *ssi = snd_soc_dai_get_drvdata(dai);\n\n\tif (ssi->soc->imx && ssi->use_dma)\n\t\tsnd_soc_dai_init_dma_data(dai, &ssi->dma_params_tx,\n\t\t\t\t\t  &ssi->dma_params_rx);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_ssi_dai_ops = {\n\t.probe = fsl_ssi_dai_probe,\n\t.startup = fsl_ssi_startup,\n\t.shutdown = fsl_ssi_shutdown,\n\t.hw_params = fsl_ssi_hw_params,\n\t.hw_free = fsl_ssi_hw_free,\n\t.set_fmt = fsl_ssi_set_dai_fmt,\n\t.set_tdm_slot = fsl_ssi_set_dai_tdm_slot,\n\t.trigger = fsl_ssi_trigger,\n};\n\nstatic struct snd_soc_dai_driver fsl_ssi_dai_template = {\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.formats = FSLSSI_I2S_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 32,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.formats = FSLSSI_I2S_FORMATS,\n\t},\n\t.ops = &fsl_ssi_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_ssi_component = {\n\t.name = \"fsl-ssi\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic struct snd_soc_dai_driver fsl_ssi_ac97_dai = {\n\t.symmetric_channels = 1,\n\t.playback = {\n\t\t.stream_name = \"CPU AC97 Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S20,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU AC97 Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t \n\t\t.formats = SNDRV_PCM_FMTBIT_S20,\n\t},\n\t.ops = &fsl_ssi_dai_ops,\n};\n\nstatic struct fsl_ssi *fsl_ac97_data;\n\nstatic void fsl_ssi_ac97_write(struct snd_ac97 *ac97, unsigned short reg,\n\t\t\t       unsigned short val)\n{\n\tstruct regmap *regs = fsl_ac97_data->regs;\n\tunsigned int lreg;\n\tunsigned int lval;\n\tint ret;\n\n\tif (reg > 0x7f)\n\t\treturn;\n\n\tmutex_lock(&fsl_ac97_data->ac97_reg_lock);\n\n\tret = clk_prepare_enable(fsl_ac97_data->clk);\n\tif (ret) {\n\t\tpr_err(\"ac97 write clk_prepare_enable failed: %d\\n\",\n\t\t\tret);\n\t\tgoto ret_unlock;\n\t}\n\n\tlreg = reg <<  12;\n\tregmap_write(regs, REG_SSI_SACADD, lreg);\n\n\tlval = val << 4;\n\tregmap_write(regs, REG_SSI_SACDAT, lval);\n\n\tregmap_update_bits(regs, REG_SSI_SACNT,\n\t\t\t   SSI_SACNT_RDWR_MASK, SSI_SACNT_WR);\n\tudelay(100);\n\n\tclk_disable_unprepare(fsl_ac97_data->clk);\n\nret_unlock:\n\tmutex_unlock(&fsl_ac97_data->ac97_reg_lock);\n}\n\nstatic unsigned short fsl_ssi_ac97_read(struct snd_ac97 *ac97,\n\t\t\t\t\tunsigned short reg)\n{\n\tstruct regmap *regs = fsl_ac97_data->regs;\n\tunsigned short val = 0;\n\tu32 reg_val;\n\tunsigned int lreg;\n\tint ret;\n\n\tmutex_lock(&fsl_ac97_data->ac97_reg_lock);\n\n\tret = clk_prepare_enable(fsl_ac97_data->clk);\n\tif (ret) {\n\t\tpr_err(\"ac97 read clk_prepare_enable failed: %d\\n\", ret);\n\t\tgoto ret_unlock;\n\t}\n\n\tlreg = (reg & 0x7f) <<  12;\n\tregmap_write(regs, REG_SSI_SACADD, lreg);\n\tregmap_update_bits(regs, REG_SSI_SACNT,\n\t\t\t   SSI_SACNT_RDWR_MASK, SSI_SACNT_RD);\n\n\tudelay(100);\n\n\tregmap_read(regs, REG_SSI_SACDAT, &reg_val);\n\tval = (reg_val >> 4) & 0xffff;\n\n\tclk_disable_unprepare(fsl_ac97_data->clk);\n\nret_unlock:\n\tmutex_unlock(&fsl_ac97_data->ac97_reg_lock);\n\treturn val;\n}\n\nstatic struct snd_ac97_bus_ops fsl_ssi_ac97_ops = {\n\t.read = fsl_ssi_ac97_read,\n\t.write = fsl_ssi_ac97_write,\n};\n\n \nstatic int fsl_ssi_hw_init(struct fsl_ssi *ssi)\n{\n\tu32 wm = ssi->fifo_watermark;\n\n\t \n\tfsl_ssi_setup_regvals(ssi);\n\n\t \n\tregmap_write(ssi->regs, REG_SSI_SFCSR,\n\t\t     SSI_SFCSR_TFWM0(wm) | SSI_SFCSR_RFWM0(wm) |\n\t\t     SSI_SFCSR_TFWM1(wm) | SSI_SFCSR_RFWM1(wm));\n\n\t \n\tif (ssi->use_dual_fifo)\n\t\tregmap_update_bits(ssi->regs, REG_SSI_SCR,\n\t\t\t\t   SSI_SCR_TCH_EN, SSI_SCR_TCH_EN);\n\n\t \n\tif (fsl_ssi_is_ac97(ssi)) {\n\t\t_fsl_ssi_set_dai_fmt(ssi, ssi->dai_fmt);\n\t\tfsl_ssi_setup_ac97(ssi);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fsl_ssi_hw_clean(struct fsl_ssi *ssi)\n{\n\t \n\tif (fsl_ssi_is_ac97(ssi)) {\n\t\t \n\t\tregmap_update_bits(ssi->regs, REG_SSI_SCR,\n\t\t\t\t   SSI_SCR_TE | SSI_SCR_RE, 0);\n\t\t \n\t\tregmap_write(ssi->regs, REG_SSI_SACNT, 0);\n\t\t \n\t\tregmap_write(ssi->regs, REG_SSI_SOR, 0);\n\t\t \n\t\tregmap_update_bits(ssi->regs, REG_SSI_SCR, SSI_SCR_SSIEN, 0);\n\t}\n}\n\n \nstatic void make_lowercase(char *s)\n{\n\tif (!s)\n\t\treturn;\n\tfor (; *s; s++)\n\t\t*s = tolower(*s);\n}\n\nstatic int fsl_ssi_imx_probe(struct platform_device *pdev,\n\t\t\t     struct fsl_ssi *ssi, void __iomem *iomem)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\t \n\tif (ssi->has_ipg_clk_name)\n\t\tssi->clk = devm_clk_get(dev, \"ipg\");\n\telse\n\t\tssi->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ssi->clk)) {\n\t\tret = PTR_ERR(ssi->clk);\n\t\tdev_err(dev, \"failed to get clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!ssi->has_ipg_clk_name) {\n\t\tret = clk_prepare_enable(ssi->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"clk_prepare_enable failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tssi->baudclk = devm_clk_get(dev, \"baud\");\n\tif (IS_ERR(ssi->baudclk))\n\t\tdev_dbg(dev, \"failed to get baud clock: %ld\\n\",\n\t\t\t PTR_ERR(ssi->baudclk));\n\n\tssi->dma_params_tx.maxburst = ssi->dma_maxburst;\n\tssi->dma_params_rx.maxburst = ssi->dma_maxburst;\n\tssi->dma_params_tx.addr = ssi->ssi_phys + REG_SSI_STX0;\n\tssi->dma_params_rx.addr = ssi->ssi_phys + REG_SSI_SRX0;\n\n\t \n\tif (ssi->use_dual_fifo || ssi->use_dyna_fifo) {\n\t\tssi->dma_params_tx.maxburst &= ~0x1;\n\t\tssi->dma_params_rx.maxburst &= ~0x1;\n\t}\n\n\tif (!ssi->use_dma) {\n\t\t \n\t\tssi->fiq_params.irq = ssi->irq;\n\t\tssi->fiq_params.base = iomem;\n\t\tssi->fiq_params.dma_params_rx = &ssi->dma_params_rx;\n\t\tssi->fiq_params.dma_params_tx = &ssi->dma_params_tx;\n\n\t\tret = imx_pcm_fiq_init(pdev, &ssi->fiq_params);\n\t\tif (ret)\n\t\t\tgoto error_pcm;\n\t} else {\n\t\tret = imx_pcm_dma_init(pdev);\n\t\tif (ret)\n\t\t\tgoto error_pcm;\n\t}\n\n\treturn 0;\n\nerror_pcm:\n\tif (!ssi->has_ipg_clk_name)\n\t\tclk_disable_unprepare(ssi->clk);\n\n\treturn ret;\n}\n\nstatic void fsl_ssi_imx_clean(struct platform_device *pdev, struct fsl_ssi *ssi)\n{\n\tif (!ssi->use_dma)\n\t\timx_pcm_fiq_exit(pdev);\n\tif (!ssi->has_ipg_clk_name)\n\t\tclk_disable_unprepare(ssi->clk);\n}\n\nstatic int fsl_ssi_probe_from_dt(struct fsl_ssi *ssi)\n{\n\tstruct device *dev = ssi->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst char *p, *sprop;\n\tconst __be32 *iprop;\n\tu32 dmas[4];\n\tint ret;\n\n\tret = of_property_match_string(np, \"clock-names\", \"ipg\");\n\t \n\tssi->has_ipg_clk_name = ret >= 0;\n\n\t \n\tsprop = of_get_property(np, \"fsl,mode\", NULL);\n\tif (sprop && !strcmp(sprop, \"ac97-slave\")) {\n\t\tssi->dai_fmt = FSLSSI_AC97_DAIFMT;\n\n\t\tret = of_property_read_u32(np, \"cell-index\", &ssi->card_idx);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to get SSI index property\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstrcpy(ssi->card_name, \"ac97-codec\");\n\t} else if (!of_property_read_bool(np, \"fsl,ssi-asynchronous\")) {\n\t\t \n\t\tssi->synchronous = true;\n\t}\n\n\t \n\tssi->use_dma = !of_property_read_bool(np, \"fsl,fiq-stream-filter\");\n\n\t \n\tiprop = of_get_property(np, \"fsl,fifo-depth\", NULL);\n\tif (iprop)\n\t\tssi->fifo_depth = be32_to_cpup(iprop);\n\telse\n\t\tssi->fifo_depth = 8;\n\n\t \n\tret = of_property_read_u32_array(np, \"dmas\", dmas, 4);\n\tif (ssi->use_dma && !ret && dmas[2] == IMX_DMATYPE_SSI_DUAL)\n\t\tssi->use_dual_fifo = true;\n\n\tif (ssi->use_dma && !ret && dmas[2] == IMX_DMATYPE_MULTI_SAI)\n\t\tssi->use_dyna_fifo = true;\n\t \n\tif (!ssi->card_name[0] && of_get_property(np, \"codec-handle\", NULL)) {\n\t\tstruct device_node *root = of_find_node_by_path(\"/\");\n\n\t\tsprop = of_get_property(root, \"compatible\", NULL);\n\t\tof_node_put(root);\n\t\t \n\t\tp = strrchr(sprop, ',');\n\t\tif (p)\n\t\t\tsprop = p + 1;\n\t\tsnprintf(ssi->card_name, sizeof(ssi->card_name),\n\t\t\t \"snd-soc-%s\", sprop);\n\t\tmake_lowercase(ssi->card_name);\n\t\tssi->card_idx = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_ssi_probe(struct platform_device *pdev)\n{\n\tstruct regmap_config regconfig = fsl_ssi_regconfig;\n\tstruct device *dev = &pdev->dev;\n\tstruct fsl_ssi *ssi;\n\tstruct resource *res;\n\tvoid __iomem *iomem;\n\tint ret = 0;\n\n\tssi = devm_kzalloc(dev, sizeof(*ssi), GFP_KERNEL);\n\tif (!ssi)\n\t\treturn -ENOMEM;\n\n\tssi->dev = dev;\n\tssi->soc = of_device_get_match_data(&pdev->dev);\n\n\t \n\tret = fsl_ssi_probe_from_dt(ssi);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fsl_ssi_is_ac97(ssi)) {\n\t\tmemcpy(&ssi->cpu_dai_drv, &fsl_ssi_ac97_dai,\n\t\t       sizeof(fsl_ssi_ac97_dai));\n\t\tfsl_ac97_data = ssi;\n\t} else {\n\t\tmemcpy(&ssi->cpu_dai_drv, &fsl_ssi_dai_template,\n\t\t       sizeof(fsl_ssi_dai_template));\n\t}\n\tssi->cpu_dai_drv.name = dev_name(dev);\n\n\tiomem = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(iomem))\n\t\treturn PTR_ERR(iomem);\n\tssi->ssi_phys = res->start;\n\n\tif (ssi->soc->imx21regs) {\n\t\t \n\t\tregconfig.max_register = REG_SSI_SRMSK;\n\t\tregconfig.num_reg_defaults_raw =\n\t\t\tREG_SSI_SRMSK / sizeof(uint32_t) + 1;\n\t}\n\n\tif (ssi->has_ipg_clk_name)\n\t\tssi->regs = devm_regmap_init_mmio_clk(dev, \"ipg\", iomem,\n\t\t\t\t\t\t      &regconfig);\n\telse\n\t\tssi->regs = devm_regmap_init_mmio(dev, iomem, &regconfig);\n\tif (IS_ERR(ssi->regs)) {\n\t\tdev_err(dev, \"failed to init register map\\n\");\n\t\treturn PTR_ERR(ssi->regs);\n\t}\n\n\tssi->irq = platform_get_irq(pdev, 0);\n\tif (ssi->irq < 0)\n\t\treturn ssi->irq;\n\n\t \n\tif (ssi->synchronous && !fsl_ssi_is_ac97(ssi)) {\n\t\tssi->cpu_dai_drv.symmetric_rate = 1;\n\t\tssi->cpu_dai_drv.symmetric_channels = 1;\n\t\tssi->cpu_dai_drv.symmetric_sample_bits = 1;\n\t}\n\n\t \n\tswitch (ssi->fifo_depth) {\n\tcase 15:\n\t\t \n\t\tssi->fifo_watermark = 8;\n\t\tssi->dma_maxburst = 8;\n\t\tbreak;\n\tcase 8:\n\tdefault:\n\t\t \n\t\tssi->fifo_watermark = ssi->fifo_depth - 2;\n\t\tssi->dma_maxburst = ssi->fifo_depth - 2;\n\t\tbreak;\n\t}\n\n\tdev_set_drvdata(dev, ssi);\n\n\tif (ssi->soc->imx) {\n\t\tret = fsl_ssi_imx_probe(pdev, ssi, iomem);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (fsl_ssi_is_ac97(ssi)) {\n\t\tmutex_init(&ssi->ac97_reg_lock);\n\t\tret = snd_soc_set_ac97_ops_of_reset(&fsl_ssi_ac97_ops, pdev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set AC'97 ops\\n\");\n\t\t\tgoto error_ac97_ops;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &fsl_ssi_component,\n\t\t\t\t\t      &ssi->cpu_dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register DAI: %d\\n\", ret);\n\t\tgoto error_asoc_register;\n\t}\n\n\tif (ssi->use_dma) {\n\t\tret = devm_request_irq(dev, ssi->irq, fsl_ssi_isr, 0,\n\t\t\t\t       dev_name(dev), ssi);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to claim irq %u\\n\", ssi->irq);\n\t\t\tgoto error_asoc_register;\n\t\t}\n\t}\n\n\tfsl_ssi_debugfs_create(&ssi->dbg_stats, dev);\n\n\t \n\tfsl_ssi_hw_init(ssi);\n\n\t \n\tif (ssi->card_name[0]) {\n\t\tstruct device *parent = dev;\n\t\t \n\t\tif (fsl_ssi_is_ac97(ssi))\n\t\t\tparent = NULL;\n\n\t\tssi->card_pdev = platform_device_register_data(parent,\n\t\t\t\tssi->card_name, ssi->card_idx, NULL, 0);\n\t\tif (IS_ERR(ssi->card_pdev)) {\n\t\t\tret = PTR_ERR(ssi->card_pdev);\n\t\t\tdev_err(dev, \"failed to register %s: %d\\n\",\n\t\t\t\tssi->card_name, ret);\n\t\t\tgoto error_sound_card;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror_sound_card:\n\tfsl_ssi_debugfs_remove(&ssi->dbg_stats);\nerror_asoc_register:\n\tif (fsl_ssi_is_ac97(ssi))\n\t\tsnd_soc_set_ac97_ops(NULL);\nerror_ac97_ops:\n\tif (fsl_ssi_is_ac97(ssi))\n\t\tmutex_destroy(&ssi->ac97_reg_lock);\n\n\tif (ssi->soc->imx)\n\t\tfsl_ssi_imx_clean(pdev, ssi);\n\n\treturn ret;\n}\n\nstatic void fsl_ssi_remove(struct platform_device *pdev)\n{\n\tstruct fsl_ssi *ssi = dev_get_drvdata(&pdev->dev);\n\n\tfsl_ssi_debugfs_remove(&ssi->dbg_stats);\n\n\tif (ssi->card_pdev)\n\t\tplatform_device_unregister(ssi->card_pdev);\n\n\t \n\tfsl_ssi_hw_clean(ssi);\n\n\tif (ssi->soc->imx)\n\t\tfsl_ssi_imx_clean(pdev, ssi);\n\n\tif (fsl_ssi_is_ac97(ssi)) {\n\t\tsnd_soc_set_ac97_ops(NULL);\n\t\tmutex_destroy(&ssi->ac97_reg_lock);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int fsl_ssi_suspend(struct device *dev)\n{\n\tstruct fsl_ssi *ssi = dev_get_drvdata(dev);\n\tstruct regmap *regs = ssi->regs;\n\n\tregmap_read(regs, REG_SSI_SFCSR, &ssi->regcache_sfcsr);\n\tregmap_read(regs, REG_SSI_SACNT, &ssi->regcache_sacnt);\n\n\tregcache_cache_only(regs, true);\n\tregcache_mark_dirty(regs);\n\n\treturn 0;\n}\n\nstatic int fsl_ssi_resume(struct device *dev)\n{\n\tstruct fsl_ssi *ssi = dev_get_drvdata(dev);\n\tstruct regmap *regs = ssi->regs;\n\n\tregcache_cache_only(regs, false);\n\n\tregmap_update_bits(regs, REG_SSI_SFCSR,\n\t\t\t   SSI_SFCSR_RFWM1_MASK | SSI_SFCSR_TFWM1_MASK |\n\t\t\t   SSI_SFCSR_RFWM0_MASK | SSI_SFCSR_TFWM0_MASK,\n\t\t\t   ssi->regcache_sfcsr);\n\tregmap_write(regs, REG_SSI_SACNT, ssi->regcache_sacnt);\n\n\treturn regcache_sync(regs);\n}\n#endif  \n\nstatic const struct dev_pm_ops fsl_ssi_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(fsl_ssi_suspend, fsl_ssi_resume)\n};\n\nstatic struct platform_driver fsl_ssi_driver = {\n\t.driver = {\n\t\t.name = \"fsl-ssi-dai\",\n\t\t.of_match_table = fsl_ssi_ids,\n\t\t.pm = &fsl_ssi_pm,\n\t},\n\t.probe = fsl_ssi_probe,\n\t.remove_new = fsl_ssi_remove,\n};\n\nmodule_platform_driver(fsl_ssi_driver);\n\nMODULE_ALIAS(\"platform:fsl-ssi-dai\");\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale Synchronous Serial Interface (SSI) ASoC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}