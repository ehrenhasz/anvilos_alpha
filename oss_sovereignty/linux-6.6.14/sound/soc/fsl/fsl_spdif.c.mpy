{
  "module_name": "fsl_spdif.c",
  "hash_id": "5e1d8a0155a3015203f81d3583a81aefbc371bba88b18b44d7dfc8cc4d9ab1bd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_spdif.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitrev.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/pm_runtime.h>\n\n#include <sound/asoundef.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/soc.h>\n\n#include \"fsl_spdif.h\"\n#include \"fsl_utils.h\"\n#include \"imx-pcm.h\"\n\n#define FSL_SPDIF_TXFIFO_WML\t0x8\n#define FSL_SPDIF_RXFIFO_WML\t0x8\n\n#define INTR_FOR_PLAYBACK\t(INT_TXFIFO_RESYNC)\n#define INTR_FOR_CAPTURE\t(INT_SYM_ERR | INT_BIT_ERR | INT_URX_FUL |\\\n\t\t\t\tINT_URX_OV | INT_QRX_FUL | INT_QRX_OV |\\\n\t\t\t\tINT_UQ_SYNC | INT_UQ_ERR | INT_RXFIFO_RESYNC |\\\n\t\t\t\tINT_LOSS_LOCK | INT_DPLL_LOCKED)\n\n#define SIE_INTR_FOR(tx)\t(tx ? INTR_FOR_PLAYBACK : INTR_FOR_CAPTURE)\n\n \nstatic u8 srpc_dpll_locked[] = { 0x0, 0x1, 0x2, 0x3, 0x4, 0xa, 0xb };\n#define SRPC_NODPLL_START1\t0x5\n#define SRPC_NODPLL_START2\t0xc\n\n#define DEFAULT_RXCLK_SRC\t1\n\n#define RX_SAMPLE_RATE_KCONTROL \"RX Sample Rate\"\n\n \nstruct fsl_spdif_soc_data {\n\tbool imx;\n\tbool shared_root_clock;\n\tbool raw_capture_mode;\n\tbool cchannel_192b;\n\tu32 interrupts;\n\tu32 tx_burst;\n\tu32 rx_burst;\n\tu64 tx_formats;\n};\n\n \nstruct spdif_mixer_control {\n\t \n\tspinlock_t ctl_lock;\n\n\t \n\tunsigned char ch_status[4];\n\n\t \n\tunsigned char subcode[2 * SPDIF_UBITS_SIZE];\n\n\t \n\tunsigned char qsub[2 * SPDIF_QSUB_SIZE];\n\n\t \n\tu32 upos;\n\tu32 qpos;\n\n\t \n\tu32 ready_buf;\n};\n\n \nstruct fsl_spdif_priv {\n\tconst struct fsl_spdif_soc_data *soc;\n\tstruct spdif_mixer_control fsl_spdif_control;\n\tstruct snd_soc_dai_driver cpu_dai_drv;\n\tstruct snd_card *snd_card;\n\tstruct snd_kcontrol *rxrate_kcontrol;\n\tstruct platform_device *pdev;\n\tstruct regmap *regmap;\n\tbool dpll_locked;\n\tu32 txrate[SPDIF_TXRATE_MAX];\n\tu8 txclk_df[SPDIF_TXRATE_MAX];\n\tu16 sysclk_df[SPDIF_TXRATE_MAX];\n\tu8 txclk_src[SPDIF_TXRATE_MAX];\n\tu8 rxclk_src;\n\tstruct clk *txclk[STC_TXCLK_SRC_MAX];\n\tstruct clk *rxclk;\n\tstruct clk *coreclk;\n\tstruct clk *sysclk;\n\tstruct clk *spbaclk;\n\tstruct snd_dmaengine_dai_dma_data dma_params_tx;\n\tstruct snd_dmaengine_dai_dma_data dma_params_rx;\n\t \n\tu32 regcache_srpc;\n\tbool bypass;\n\tstruct clk *pll8k_clk;\n\tstruct clk *pll11k_clk;\n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_vf610 = {\n\t.imx = false,\n\t.shared_root_clock = false,\n\t.raw_capture_mode = false,\n\t.interrupts = 1,\n\t.tx_burst = FSL_SPDIF_TXFIFO_WML,\n\t.rx_burst = FSL_SPDIF_RXFIFO_WML,\n\t.tx_formats = FSL_SPDIF_FORMATS_PLAYBACK,\n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_imx35 = {\n\t.imx = true,\n\t.shared_root_clock = false,\n\t.raw_capture_mode = false,\n\t.interrupts = 1,\n\t.tx_burst = FSL_SPDIF_TXFIFO_WML,\n\t.rx_burst = FSL_SPDIF_RXFIFO_WML,\n\t.tx_formats = FSL_SPDIF_FORMATS_PLAYBACK,\n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_imx6sx = {\n\t.imx = true,\n\t.shared_root_clock = true,\n\t.raw_capture_mode = false,\n\t.interrupts = 1,\n\t.tx_burst = FSL_SPDIF_TXFIFO_WML,\n\t.rx_burst = FSL_SPDIF_RXFIFO_WML,\n\t.tx_formats = FSL_SPDIF_FORMATS_PLAYBACK,\n\n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_imx8qm = {\n\t.imx = true,\n\t.shared_root_clock = true,\n\t.raw_capture_mode = false,\n\t.interrupts = 2,\n\t.tx_burst = 2,\t\t \n\t.rx_burst = 2,\t\t \n\t.tx_formats = SNDRV_PCM_FMTBIT_S24_LE,   \n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_imx8mm = {\n\t.imx = true,\n\t.shared_root_clock = false,\n\t.raw_capture_mode = true,\n\t.interrupts = 1,\n\t.tx_burst = FSL_SPDIF_TXFIFO_WML,\n\t.rx_burst = FSL_SPDIF_RXFIFO_WML,\n\t.tx_formats = FSL_SPDIF_FORMATS_PLAYBACK,\n};\n\nstatic struct fsl_spdif_soc_data fsl_spdif_imx8ulp = {\n\t.imx = true,\n\t.shared_root_clock = true,\n\t.raw_capture_mode = false,\n\t.interrupts = 1,\n\t.tx_burst = 2,\t\t \n\t.rx_burst = 2,\t\t \n\t.tx_formats = SNDRV_PCM_FMTBIT_S24_LE,\t \n\t.cchannel_192b = true,\n};\n\n \nstatic inline bool fsl_spdif_can_set_clk_rate(struct fsl_spdif_priv *spdif, int clk)\n{\n\treturn (clk == STC_TXCLK_SPDIF_ROOT) && !spdif->soc->shared_root_clock;\n}\n\n \nstatic void spdif_irq_dpll_lock(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 locked;\n\n\tregmap_read(regmap, REG_SPDIF_SRPC, &locked);\n\tlocked &= SRPC_DPLL_LOCKED;\n\n\tdev_dbg(&pdev->dev, \"isr: Rx dpll %s \\n\",\n\t\t\tlocked ? \"locked\" : \"loss lock\");\n\n\tspdif_priv->dpll_locked = locked ? true : false;\n\n\tif (spdif_priv->snd_card && spdif_priv->rxrate_kcontrol) {\n\t\tsnd_ctl_notify(spdif_priv->snd_card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &spdif_priv->rxrate_kcontrol->id);\n\t}\n}\n\n \nstatic void spdif_irq_sym_error(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\n\tdev_dbg(&pdev->dev, \"isr: receiver found illegal symbol\\n\");\n\n\t \n\tif (!spdif_priv->dpll_locked)\n\t\tregmap_update_bits(regmap, REG_SPDIF_SIE, INT_SYM_ERR, 0);\n}\n\n \nstatic void spdif_irq_uqrx_full(struct fsl_spdif_priv *spdif_priv, char name)\n{\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 *pos, size, val, reg;\n\n\tswitch (name) {\n\tcase 'U':\n\t\tpos = &ctrl->upos;\n\t\tsize = SPDIF_UBITS_SIZE;\n\t\treg = REG_SPDIF_SRU;\n\t\tbreak;\n\tcase 'Q':\n\t\tpos = &ctrl->qpos;\n\t\tsize = SPDIF_QSUB_SIZE;\n\t\treg = REG_SPDIF_SRQ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unsupported channel name\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(&pdev->dev, \"isr: %c Channel receive register full\\n\", name);\n\n\tif (*pos >= size * 2) {\n\t\t*pos = 0;\n\t} else if (unlikely((*pos % size) + 3 > size)) {\n\t\tdev_err(&pdev->dev, \"User bit receive buffer overflow\\n\");\n\t\treturn;\n\t}\n\n\tregmap_read(regmap, reg, &val);\n\tctrl->subcode[*pos++] = val >> 16;\n\tctrl->subcode[*pos++] = val >> 8;\n\tctrl->subcode[*pos++] = val;\n}\n\n \nstatic void spdif_irq_uq_sync(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\n\tdev_dbg(&pdev->dev, \"isr: U/Q Channel sync found\\n\");\n\n\t \n\tif (ctrl->qpos == 0)\n\t\treturn;\n\n\t \n\tctrl->ready_buf = (ctrl->qpos - 1) / SPDIF_QSUB_SIZE + 1;\n}\n\n \nstatic void spdif_irq_uq_err(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 val;\n\n\tdev_dbg(&pdev->dev, \"isr: U/Q Channel framing error\\n\");\n\n\t \n\tregmap_read(regmap, REG_SPDIF_SRU, &val);\n\tregmap_read(regmap, REG_SPDIF_SRQ, &val);\n\n\t \n\tctrl->ready_buf = 0;\n\tctrl->upos = 0;\n\tctrl->qpos = 0;\n}\n\n \nstatic u32 spdif_intr_status_clear(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val, val2;\n\n\tregmap_read(regmap, REG_SPDIF_SIS, &val);\n\tregmap_read(regmap, REG_SPDIF_SIE, &val2);\n\n\tregmap_write(regmap, REG_SPDIF_SIC, val & val2);\n\n\treturn val;\n}\n\nstatic irqreturn_t spdif_isr(int irq, void *devid)\n{\n\tstruct fsl_spdif_priv *spdif_priv = (struct fsl_spdif_priv *)devid;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 sis;\n\n\tsis = spdif_intr_status_clear(spdif_priv);\n\n\tif (sis & INT_DPLL_LOCKED)\n\t\tspdif_irq_dpll_lock(spdif_priv);\n\n\tif (sis & INT_TXFIFO_UNOV)\n\t\tdev_dbg(&pdev->dev, \"isr: Tx FIFO under/overrun\\n\");\n\n\tif (sis & INT_TXFIFO_RESYNC)\n\t\tdev_dbg(&pdev->dev, \"isr: Tx FIFO resync\\n\");\n\n\tif (sis & INT_CNEW)\n\t\tdev_dbg(&pdev->dev, \"isr: cstatus new\\n\");\n\n\tif (sis & INT_VAL_NOGOOD)\n\t\tdev_dbg(&pdev->dev, \"isr: validity flag no good\\n\");\n\n\tif (sis & INT_SYM_ERR)\n\t\tspdif_irq_sym_error(spdif_priv);\n\n\tif (sis & INT_BIT_ERR)\n\t\tdev_dbg(&pdev->dev, \"isr: receiver found parity bit error\\n\");\n\n\tif (sis & INT_URX_FUL)\n\t\tspdif_irq_uqrx_full(spdif_priv, 'U');\n\n\tif (sis & INT_URX_OV)\n\t\tdev_dbg(&pdev->dev, \"isr: U Channel receive register overrun\\n\");\n\n\tif (sis & INT_QRX_FUL)\n\t\tspdif_irq_uqrx_full(spdif_priv, 'Q');\n\n\tif (sis & INT_QRX_OV)\n\t\tdev_dbg(&pdev->dev, \"isr: Q Channel receive register overrun\\n\");\n\n\tif (sis & INT_UQ_SYNC)\n\t\tspdif_irq_uq_sync(spdif_priv);\n\n\tif (sis & INT_UQ_ERR)\n\t\tspdif_irq_uq_err(spdif_priv);\n\n\tif (sis & INT_RXFIFO_UNOV)\n\t\tdev_dbg(&pdev->dev, \"isr: Rx FIFO under/overrun\\n\");\n\n\tif (sis & INT_RXFIFO_RESYNC)\n\t\tdev_dbg(&pdev->dev, \"isr: Rx FIFO resync\\n\");\n\n\tif (sis & INT_LOSS_LOCK)\n\t\tspdif_irq_dpll_lock(spdif_priv);\n\n\t \n\tif (sis & INT_TX_EM)\n\t\tdev_dbg(&pdev->dev, \"isr: Tx FIFO empty\\n\");\n\n\t \n\tif (sis & INT_RXFIFO_FUL)\n\t\tdev_dbg(&pdev->dev, \"isr: Rx FIFO full\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spdif_softreset(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val, cycle = 1000;\n\n\tregcache_cache_bypass(regmap, true);\n\n\tregmap_write(regmap, REG_SPDIF_SCR, SCR_SOFT_RESET);\n\n\t \n\tdo {\n\t\tregmap_read(regmap, REG_SPDIF_SCR, &val);\n\t} while ((val & SCR_SOFT_RESET) && cycle--);\n\n\tregcache_cache_bypass(regmap, false);\n\tregcache_mark_dirty(regmap);\n\tregcache_sync(regmap);\n\n\tif (cycle)\n\t\treturn 0;\n\telse\n\t\treturn -EBUSY;\n}\n\nstatic void spdif_set_cstatus(struct spdif_mixer_control *ctrl,\n\t\t\t\tu8 mask, u8 cstatus)\n{\n\tctrl->ch_status[3] &= ~mask;\n\tctrl->ch_status[3] |= cstatus & mask;\n}\n\nstatic void spdif_write_channel_status(struct fsl_spdif_priv *spdif_priv)\n{\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 ch_status;\n\n\tch_status = (bitrev8(ctrl->ch_status[0]) << 16) |\n\t\t    (bitrev8(ctrl->ch_status[1]) << 8) |\n\t\t    bitrev8(ctrl->ch_status[2]);\n\tregmap_write(regmap, REG_SPDIF_STCSCH, ch_status);\n\n\tdev_dbg(&pdev->dev, \"STCSCH: 0x%06x\\n\", ch_status);\n\n\tch_status = bitrev8(ctrl->ch_status[3]) << 16;\n\tregmap_write(regmap, REG_SPDIF_STCSCL, ch_status);\n\n\tdev_dbg(&pdev->dev, \"STCSCL: 0x%06x\\n\", ch_status);\n\n\tif (spdif_priv->soc->cchannel_192b) {\n\t\tch_status = (bitrev8(ctrl->ch_status[0]) << 24) |\n\t\t\t    (bitrev8(ctrl->ch_status[1]) << 16) |\n\t\t\t    (bitrev8(ctrl->ch_status[2]) << 8) |\n\t\t\t    bitrev8(ctrl->ch_status[3]);\n\n\t\tregmap_update_bits(regmap, REG_SPDIF_SCR, 0x1000000, 0x1000000);\n\n\t\t \n\t\tregmap_write(regmap, REG_SPDIF_STCCA_191_160, ch_status);\n\t}\n}\n\n \nstatic int spdif_set_rx_clksrc(struct fsl_spdif_priv *spdif_priv,\n\t\t\t\tenum spdif_gainsel gainsel, int dpll_locked)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu8 clksrc = spdif_priv->rxclk_src;\n\n\tif (clksrc >= SRPC_CLKSRC_MAX || gainsel >= GAINSEL_MULTI_MAX)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(regmap, REG_SPDIF_SRPC,\n\t\t\tSRPC_CLKSRC_SEL_MASK | SRPC_GAINSEL_MASK,\n\t\t\tSRPC_CLKSRC_SEL_SET(clksrc) | SRPC_GAINSEL_SET(gainsel));\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_probe_txclk(struct fsl_spdif_priv *spdif_priv, enum spdif_txrate index);\n\nstatic int spdif_set_sample_rate(struct snd_pcm_substream *substream,\n\t\t\t\tint sample_rate)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tunsigned long csfs = 0;\n\tu32 stc, mask, rate;\n\tu16 sysclk_df;\n\tu8 clk, txclk_df;\n\tint ret;\n\n\tswitch (sample_rate) {\n\tcase 22050:\n\t\trate = SPDIF_TXRATE_22050;\n\t\tcsfs = IEC958_AES3_CON_FS_22050;\n\t\tbreak;\n\tcase 32000:\n\t\trate = SPDIF_TXRATE_32000;\n\t\tcsfs = IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\trate = SPDIF_TXRATE_44100;\n\t\tcsfs = IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\trate = SPDIF_TXRATE_48000;\n\t\tcsfs = IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\trate = SPDIF_TXRATE_88200;\n\t\tcsfs = IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\trate = SPDIF_TXRATE_96000;\n\t\tcsfs = IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 176400:\n\t\trate = SPDIF_TXRATE_176400;\n\t\tcsfs = IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 192000:\n\t\trate = SPDIF_TXRATE_192000;\n\t\tcsfs = IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unsupported sample rate %d\\n\", sample_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tret = fsl_spdif_probe_txclk(spdif_priv, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tclk = spdif_priv->txclk_src[rate];\n\tif (clk >= STC_TXCLK_SRC_MAX) {\n\t\tdev_err(&pdev->dev, \"tx clock source is out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttxclk_df = spdif_priv->txclk_df[rate];\n\tif (txclk_df == 0) {\n\t\tdev_err(&pdev->dev, \"the txclk_df can't be zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsysclk_df = spdif_priv->sysclk_df[rate];\n\n\tif (!fsl_spdif_can_set_clk_rate(spdif_priv, clk))\n\t\tgoto clk_set_bypass;\n\n\t \n\tret = clk_set_rate(spdif_priv->txclk[clk],\n\t\t\t   64 * sample_rate * txclk_df);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to set tx clock rate\\n\");\n\t\treturn ret;\n\t}\n\nclk_set_bypass:\n\tdev_dbg(&pdev->dev, \"expected clock rate = %d\\n\",\n\t\t\t(64 * sample_rate * txclk_df * sysclk_df));\n\tdev_dbg(&pdev->dev, \"actual clock rate = %ld\\n\",\n\t\t\tclk_get_rate(spdif_priv->txclk[clk]));\n\n\t \n\tspdif_set_cstatus(ctrl, IEC958_AES3_CON_FS, csfs);\n\n\t \n\tstc = STC_TXCLK_ALL_EN | STC_TXCLK_SRC_SET(clk) |\n\t      STC_TXCLK_DF(txclk_df) | STC_SYSCLK_DF(sysclk_df);\n\tmask = STC_TXCLK_ALL_EN_MASK | STC_TXCLK_SRC_MASK |\n\t       STC_TXCLK_DF_MASK | STC_SYSCLK_DF_MASK;\n\tregmap_update_bits(regmap, REG_SPDIF_STC, mask, stc);\n\n\tdev_dbg(&pdev->dev, \"set sample rate to %dHz for %dHz playback\\n\",\n\t\t\tspdif_priv->txrate[rate], sample_rate);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_startup(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 scr, mask;\n\tint ret;\n\n\t \n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tret = spdif_softreset(spdif_priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to soft reset\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(regmap, REG_SPDIF_SIE, 0xffffff, 0);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tscr = SCR_TXFIFO_AUTOSYNC | SCR_TXFIFO_CTRL_NORMAL |\n\t\t\tSCR_TXSEL_NORMAL | SCR_USRC_SEL_CHIP |\n\t\t\tSCR_TXFIFO_FSEL_IF8;\n\t\tmask = SCR_TXFIFO_AUTOSYNC_MASK | SCR_TXFIFO_CTRL_MASK |\n\t\t\tSCR_TXSEL_MASK | SCR_USRC_SEL_MASK |\n\t\t\tSCR_TXFIFO_FSEL_MASK;\n\t} else {\n\t\tscr = SCR_RXFIFO_FSEL_IF8 | SCR_RXFIFO_AUTOSYNC;\n\t\tmask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK|\n\t\t\tSCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK;\n\t}\n\tregmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);\n\n\t \n\tregmap_update_bits(regmap, REG_SPDIF_SCR, SCR_LOW_POWER, 0);\n\n\treturn 0;\n}\n\nstatic void fsl_spdif_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 scr, mask;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tscr = 0;\n\t\tmask = SCR_TXFIFO_AUTOSYNC_MASK | SCR_TXFIFO_CTRL_MASK |\n\t\t\tSCR_TXSEL_MASK | SCR_USRC_SEL_MASK |\n\t\t\tSCR_TXFIFO_FSEL_MASK;\n\t\t \n\t\tregmap_update_bits(regmap, REG_SPDIF_STC, STC_TXCLK_ALL_EN_MASK, 0);\n\t} else {\n\t\tscr = SCR_RXFIFO_OFF | SCR_RXFIFO_CTL_ZERO;\n\t\tmask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK|\n\t\t\tSCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK;\n\t}\n\tregmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);\n\n\t \n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tspdif_intr_status_clear(spdif_priv);\n\t\tregmap_update_bits(regmap, REG_SPDIF_SCR,\n\t\t\t\tSCR_LOW_POWER, SCR_LOW_POWER);\n\t}\n}\n\nstatic int spdif_reparent_rootclk(struct fsl_spdif_priv *spdif_priv, unsigned int sample_rate)\n{\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tif (!fsl_spdif_can_set_clk_rate(spdif_priv, STC_TXCLK_SPDIF_ROOT))\n\t\treturn 0;\n\n\t \n\tclk = spdif_priv->txclk[STC_TXCLK_SPDIF_ROOT];\n\n\t \n\tclk_disable_unprepare(clk);\n\tfsl_asoc_reparent_pll_clocks(&pdev->dev, clk, spdif_priv->pll8k_clk,\n\t\t\t\t     spdif_priv->pll11k_clk, sample_rate);\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nstatic int fsl_spdif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu32 sample_rate = params_rate(params);\n\tint ret = 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tret = spdif_reparent_rootclk(spdif_priv, sample_rate);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"%s: reparent root clk failed: %d\\n\",\n\t\t\t\t__func__, sample_rate);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret  = spdif_set_sample_rate(substream, sample_rate);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"%s: set sample rate failed: %d\\n\",\n\t\t\t\t\t__func__, sample_rate);\n\t\t\treturn ret;\n\t\t}\n\t\tspdif_set_cstatus(ctrl, IEC958_AES3_CON_CLOCK,\n\t\t\t\t  IEC958_AES3_CON_CLOCK_1000PPM);\n\t\tspdif_write_channel_status(spdif_priv);\n\t} else {\n\t\t \n\t\tret = spdif_set_rx_clksrc(spdif_priv, SPDIF_DEFAULT_GAINSEL, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int fsl_spdif_trigger(struct snd_pcm_substream *substream,\n\t\t\t\tint cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tu32 intr = SIE_INTR_FOR(tx);\n\tu32 dmaen = SCR_DMA_xX_EN(tx);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tregmap_update_bits(regmap, REG_SPDIF_SIE, intr, intr);\n\t\tregmap_update_bits(regmap, REG_SPDIF_SCR, dmaen, dmaen);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tregmap_update_bits(regmap, REG_SPDIF_SCR, dmaen, 0);\n\t\tregmap_update_bits(regmap, REG_SPDIF_SIE, intr, 0);\n\t\tregmap_write(regmap, REG_SPDIF_STL, 0x0);\n\t\tregmap_write(regmap, REG_SPDIF_STR, 0x0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int fsl_spdif_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_pb_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\n\tuvalue->value.iec958.status[0] = ctrl->ch_status[0];\n\tuvalue->value.iec958.status[1] = ctrl->ch_status[1];\n\tuvalue->value.iec958.status[2] = ctrl->ch_status[2];\n\tuvalue->value.iec958.status[3] = ctrl->ch_status[3];\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_pb_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *uvalue)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\n\tctrl->ch_status[0] = uvalue->value.iec958.status[0];\n\tctrl->ch_status[1] = uvalue->value.iec958.status[1];\n\tctrl->ch_status[2] = uvalue->value.iec958.status[2];\n\tctrl->ch_status[3] = uvalue->value.iec958.status[3];\n\n\tspdif_write_channel_status(spdif_priv);\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 cstatus, val;\n\n\tregmap_read(regmap, REG_SPDIF_SIS, &val);\n\tif (!(val & INT_CNEW))\n\t\treturn -EAGAIN;\n\n\tregmap_read(regmap, REG_SPDIF_SRCSH, &cstatus);\n\tucontrol->value.iec958.status[0] = (cstatus >> 16) & 0xFF;\n\tucontrol->value.iec958.status[1] = (cstatus >> 8) & 0xFF;\n\tucontrol->value.iec958.status[2] = cstatus & 0xFF;\n\n\tregmap_read(regmap, REG_SPDIF_SRCSL, &cstatus);\n\tucontrol->value.iec958.status[3] = (cstatus >> 16) & 0xFF;\n\tucontrol->value.iec958.status[4] = (cstatus >> 8) & 0xFF;\n\tucontrol->value.iec958.status[5] = cstatus & 0xFF;\n\n\t \n\tregmap_write(regmap, REG_SPDIF_SIC, INT_CNEW);\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_subcode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tunsigned long flags;\n\tint ret = -EAGAIN;\n\n\tspin_lock_irqsave(&ctrl->ctl_lock, flags);\n\tif (ctrl->ready_buf) {\n\t\tint idx = (ctrl->ready_buf - 1) * SPDIF_UBITS_SIZE;\n\t\tmemcpy(&ucontrol->value.iec958.subcode[0],\n\t\t\t\t&ctrl->subcode[idx], SPDIF_UBITS_SIZE);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&ctrl->ctl_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int fsl_spdif_qinfo(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = SPDIF_QSUB_SIZE;\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_qget(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct spdif_mixer_control *ctrl = &spdif_priv->fsl_spdif_control;\n\tunsigned long flags;\n\tint ret = -EAGAIN;\n\n\tspin_lock_irqsave(&ctrl->ctl_lock, flags);\n\tif (ctrl->ready_buf) {\n\t\tint idx = (ctrl->ready_buf - 1) * SPDIF_QSUB_SIZE;\n\t\tmemcpy(&ucontrol->value.bytes.data[0],\n\t\t\t\t&ctrl->qsub[idx], SPDIF_QSUB_SIZE);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&ctrl->ctl_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int fsl_spdif_rx_vbit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val;\n\n\tregmap_read(regmap, REG_SPDIF_SIS, &val);\n\tucontrol->value.integer.value[0] = (val & INT_VAL_NOGOOD) != 0;\n\tregmap_write(regmap, REG_SPDIF_SIC, INT_VAL_NOGOOD);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_tx_vbit_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val;\n\n\tregmap_read(regmap, REG_SPDIF_SCR, &val);\n\tval = (val & SCR_VAL_MASK) >> SCR_VAL_OFFSET;\n\tval = 1 - val;\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_tx_vbit_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val = (1 - ucontrol->value.integer.value[0]) << SCR_VAL_OFFSET;\n\n\tregmap_update_bits(regmap, REG_SPDIF_SCR, SCR_VAL_MASK, val);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_rx_rcm_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val;\n\n\tregmap_read(regmap, REG_SPDIF_SCR, &val);\n\tval = (val & SCR_RAW_CAPTURE_MODE) ? 1 : 0;\n\tucontrol->value.integer.value[0] = val;\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_rx_rcm_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val = (ucontrol->value.integer.value[0] ? SCR_RAW_CAPTURE_MODE : 0);\n\n\tif (val)\n\t\tcpu_dai->driver->capture.formats |= SNDRV_PCM_FMTBIT_S32_LE;\n\telse\n\t\tcpu_dai->driver->capture.formats &= ~SNDRV_PCM_FMTBIT_S32_LE;\n\n\tregmap_update_bits(regmap, REG_SPDIF_SCR, SCR_RAW_CAPTURE_MODE, val);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_bypass_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);\n\n\tucontrol->value.integer.value[0] = priv->bypass ? 1 : 0;\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_bypass_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_soc_card *card = dai->component->card;\n\tbool set = (ucontrol->value.integer.value[0] != 0);\n\tstruct regmap *regmap = priv->regmap;\n\tstruct snd_soc_pcm_runtime *rtd;\n\tu32 scr, mask;\n\tint stream;\n\n\trtd = snd_soc_get_pcm_runtime(card, card->dai_link);\n\n\tif (priv->bypass == set)\n\t\treturn 0;  \n\n\tif (snd_soc_dai_active(dai)) {\n\t\tdev_err(dai->dev, \"Cannot change BYPASS mode while stream is running.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tpm_runtime_get_sync(dai->dev);\n\n\tif (set) {\n\t\t \n\t\tregmap_update_bits(regmap, REG_SPDIF_SIE, 0xffffff, 0);\n\n\t\t \n\t\tscr = SCR_TXSEL_RX | SCR_RXFIFO_OFF;\n\t\tmask = SCR_RXFIFO_FSEL_MASK | SCR_RXFIFO_AUTOSYNC_MASK |\n\t\t\tSCR_RXFIFO_CTL_MASK | SCR_RXFIFO_OFF_MASK | SCR_TXSEL_MASK;\n\t\t \n\t\tmask |= SCR_LOW_POWER;\n\t} else {\n\t\t \n\t\tscr = SCR_LOW_POWER | SCR_TXSEL_OFF;\n\t\tmask = SCR_LOW_POWER | SCR_TXSEL_MASK;\n\t}\n\n\tregmap_update_bits(regmap, REG_SPDIF_SCR, mask, scr);\n\n\t \n\tfor_each_pcm_streams(stream)\n\t\trtd->pcm->streams[stream].substream_count = (set ? 0 : 1);\n\n\tpriv->bypass = set;\n\tpm_runtime_put_sync(dai->dev);\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_rxrate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 16000;\n\tuinfo->value.integer.max = 192000;\n\n\treturn 0;\n}\n\nstatic u32 gainsel_multi[GAINSEL_MULTI_MAX] = {\n\t24, 16, 12, 8, 6, 4, 3,\n};\n\n \nstatic int spdif_get_rxclk_rate(struct fsl_spdif_priv *spdif_priv,\n\t\t\t\tenum spdif_gainsel gainsel)\n{\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tu64 tmpval64, busclk_freq = 0;\n\tu32 freqmeas, phaseconf;\n\tu8 clksrc;\n\n\tregmap_read(regmap, REG_SPDIF_SRFM, &freqmeas);\n\tregmap_read(regmap, REG_SPDIF_SRPC, &phaseconf);\n\n\tclksrc = (phaseconf >> SRPC_CLKSRC_SEL_OFFSET) & 0xf;\n\n\t \n\tif (srpc_dpll_locked[clksrc] && (phaseconf & SRPC_DPLL_LOCKED))\n\t\tbusclk_freq = clk_get_rate(spdif_priv->sysclk);\n\n\t \n\ttmpval64 = (u64) busclk_freq * freqmeas;\n\tdo_div(tmpval64, gainsel_multi[gainsel] * 1024);\n\tdo_div(tmpval64, 128 * 1024);\n\n\tdev_dbg(&pdev->dev, \"FreqMeas: %d\\n\", freqmeas);\n\tdev_dbg(&pdev->dev, \"BusclkFreq: %lld\\n\", busclk_freq);\n\tdev_dbg(&pdev->dev, \"RxRate: %lld\\n\", tmpval64);\n\n\treturn (int)tmpval64;\n}\n\n \nstatic int fsl_spdif_rxrate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tint rate = 0;\n\n\tif (spdif_priv->dpll_locked)\n\t\trate = spdif_get_rxclk_rate(spdif_priv, SPDIF_DEFAULT_GAINSEL);\n\n\tucontrol->value.integer.value[0] = rate;\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_usync_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val;\n\n\tregmap_read(regmap, REG_SPDIF_SRCD, &val);\n\tucontrol->value.integer.value[0] = (val & SRCD_CD_USER) != 0;\n\n\treturn 0;\n}\n\n \nstatic int fsl_spdif_usync_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct fsl_spdif_priv *spdif_priv = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct regmap *regmap = spdif_priv->regmap;\n\tu32 val = ucontrol->value.integer.value[0] << SRCD_CD_USER_OFFSET;\n\n\tregmap_update_bits(regmap, REG_SPDIF_SRCD, SRCD_CD_USER, val);\n\n\treturn 0;\n}\n\n \nstatic struct snd_kcontrol_new fsl_spdif_ctrls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = fsl_spdif_info,\n\t\t.get = fsl_spdif_pb_get,\n\t\t.put = fsl_spdif_pb_put,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", CAPTURE, DEFAULT),\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = fsl_spdif_info,\n\t\t.get = fsl_spdif_capture_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Subcode Capture Default\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = fsl_spdif_info,\n\t\t.get = fsl_spdif_subcode_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Q-subcode Capture Default\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = fsl_spdif_qinfo,\n\t\t.get = fsl_spdif_qget,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 RX V-Bit Errors\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = fsl_spdif_rx_vbit_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 TX V-Bit\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = fsl_spdif_tx_vbit_get,\n\t\t.put = fsl_spdif_tx_vbit_put,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = RX_SAMPLE_RATE_KCONTROL,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = fsl_spdif_rxrate_info,\n\t\t.get = fsl_spdif_rxrate_get,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"Bypass Mode\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = fsl_spdif_bypass_get,\n\t\t.put = fsl_spdif_bypass_put,\n\t},\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 USyncMode CDText\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = fsl_spdif_usync_get,\n\t\t.put = fsl_spdif_usync_put,\n\t},\n};\n\nstatic struct snd_kcontrol_new fsl_spdif_ctrls_rcm[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = \"IEC958 Raw Capture Mode\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_WRITE |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info = snd_ctl_boolean_mono_info,\n\t\t.get = fsl_spdif_rx_rcm_get,\n\t\t.put = fsl_spdif_rx_rcm_put,\n\t},\n};\n\nstatic int fsl_spdif_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct fsl_spdif_priv *spdif_private = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_soc_dai_init_dma_data(dai, &spdif_private->dma_params_tx,\n\t\t\t\t  &spdif_private->dma_params_rx);\n\n\tsnd_soc_add_dai_controls(dai, fsl_spdif_ctrls, ARRAY_SIZE(fsl_spdif_ctrls));\n\n\tif (spdif_private->soc->raw_capture_mode)\n\t\tsnd_soc_add_dai_controls(dai, fsl_spdif_ctrls_rcm,\n\t\t\t\t\t ARRAY_SIZE(fsl_spdif_ctrls_rcm));\n\n\tspdif_private->snd_card = dai->component->card->snd_card;\n\tspdif_private->rxrate_kcontrol = snd_soc_card_get_kcontrol(dai->component->card,\n\t\t\t\t\t\t\t\t   RX_SAMPLE_RATE_KCONTROL);\n\tif (!spdif_private->rxrate_kcontrol)\n\t\tdev_err(&spdif_private->pdev->dev, \"failed to get %s kcontrol\\n\",\n\t\t\tRX_SAMPLE_RATE_KCONTROL);\n\n\t \n\tregmap_update_bits(spdif_private->regmap, REG_SPDIF_SCR,\n\t\t\t   SCR_VAL_MASK, SCR_VAL_CLEAR);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops fsl_spdif_dai_ops = {\n\t.probe\t\t= fsl_spdif_dai_probe,\n\t.startup\t= fsl_spdif_startup,\n\t.hw_params\t= fsl_spdif_hw_params,\n\t.trigger\t= fsl_spdif_trigger,\n\t.shutdown\t= fsl_spdif_shutdown,\n};\n\nstatic struct snd_soc_dai_driver fsl_spdif_dai = {\n\t.playback = {\n\t\t.stream_name = \"CPU-Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = FSL_SPDIF_RATES_PLAYBACK,\n\t\t.formats = FSL_SPDIF_FORMATS_PLAYBACK,\n\t},\n\t.capture = {\n\t\t.stream_name = \"CPU-Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = FSL_SPDIF_RATES_CAPTURE,\n\t\t.formats = FSL_SPDIF_FORMATS_CAPTURE,\n\t},\n\t.ops = &fsl_spdif_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver fsl_spdif_component = {\n\t.name\t\t\t= \"fsl-spdif\",\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic const struct reg_default fsl_spdif_reg_defaults[] = {\n\t{REG_SPDIF_SCR,    0x00000400},\n\t{REG_SPDIF_SRCD,   0x00000000},\n\t{REG_SPDIF_SIE,\t   0x00000000},\n\t{REG_SPDIF_STL,\t   0x00000000},\n\t{REG_SPDIF_STR,\t   0x00000000},\n\t{REG_SPDIF_STCSCH, 0x00000000},\n\t{REG_SPDIF_STCSCL, 0x00000000},\n\t{REG_SPDIF_STCSPH, 0x00000000},\n\t{REG_SPDIF_STCSPL, 0x00000000},\n\t{REG_SPDIF_STC,\t   0x00020f00},\n};\n\nstatic bool fsl_spdif_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SPDIF_SCR:\n\tcase REG_SPDIF_SRCD:\n\tcase REG_SPDIF_SRPC:\n\tcase REG_SPDIF_SIE:\n\tcase REG_SPDIF_SIS:\n\tcase REG_SPDIF_SRL:\n\tcase REG_SPDIF_SRR:\n\tcase REG_SPDIF_SRCSH:\n\tcase REG_SPDIF_SRCSL:\n\tcase REG_SPDIF_SRU:\n\tcase REG_SPDIF_SRQ:\n\tcase REG_SPDIF_STCSCH:\n\tcase REG_SPDIF_STCSCL:\n\tcase REG_SPDIF_STCSPH:\n\tcase REG_SPDIF_STCSPL:\n\tcase REG_SPDIF_SRFM:\n\tcase REG_SPDIF_STC:\n\tcase REG_SPDIF_SRCCA_31_0:\n\tcase REG_SPDIF_SRCCA_63_32:\n\tcase REG_SPDIF_SRCCA_95_64:\n\tcase REG_SPDIF_SRCCA_127_96:\n\tcase REG_SPDIF_SRCCA_159_128:\n\tcase REG_SPDIF_SRCCA_191_160:\n\tcase REG_SPDIF_STCCA_31_0:\n\tcase REG_SPDIF_STCCA_63_32:\n\tcase REG_SPDIF_STCCA_95_64:\n\tcase REG_SPDIF_STCCA_127_96:\n\tcase REG_SPDIF_STCCA_159_128:\n\tcase REG_SPDIF_STCCA_191_160:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_spdif_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SPDIF_SRPC:\n\tcase REG_SPDIF_SIS:\n\tcase REG_SPDIF_SRL:\n\tcase REG_SPDIF_SRR:\n\tcase REG_SPDIF_SRCSH:\n\tcase REG_SPDIF_SRCSL:\n\tcase REG_SPDIF_SRU:\n\tcase REG_SPDIF_SRQ:\n\tcase REG_SPDIF_SRFM:\n\tcase REG_SPDIF_SRCCA_31_0:\n\tcase REG_SPDIF_SRCCA_63_32:\n\tcase REG_SPDIF_SRCCA_95_64:\n\tcase REG_SPDIF_SRCCA_127_96:\n\tcase REG_SPDIF_SRCCA_159_128:\n\tcase REG_SPDIF_SRCCA_191_160:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool fsl_spdif_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_SPDIF_SCR:\n\tcase REG_SPDIF_SRCD:\n\tcase REG_SPDIF_SRPC:\n\tcase REG_SPDIF_SIE:\n\tcase REG_SPDIF_SIC:\n\tcase REG_SPDIF_STL:\n\tcase REG_SPDIF_STR:\n\tcase REG_SPDIF_STCSCH:\n\tcase REG_SPDIF_STCSCL:\n\tcase REG_SPDIF_STCSPH:\n\tcase REG_SPDIF_STCSPL:\n\tcase REG_SPDIF_STC:\n\tcase REG_SPDIF_STCCA_31_0:\n\tcase REG_SPDIF_STCCA_63_32:\n\tcase REG_SPDIF_STCCA_95_64:\n\tcase REG_SPDIF_STCCA_127_96:\n\tcase REG_SPDIF_STCCA_159_128:\n\tcase REG_SPDIF_STCCA_191_160:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config fsl_spdif_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\n\t.max_register = REG_SPDIF_STCCA_191_160,\n\t.reg_defaults = fsl_spdif_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(fsl_spdif_reg_defaults),\n\t.readable_reg = fsl_spdif_readable_reg,\n\t.volatile_reg = fsl_spdif_volatile_reg,\n\t.writeable_reg = fsl_spdif_writeable_reg,\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic u32 fsl_spdif_txclk_caldiv(struct fsl_spdif_priv *spdif_priv,\n\t\t\t\tstruct clk *clk, u64 savesub,\n\t\t\t\tenum spdif_txrate index, bool round)\n{\n\tstatic const u32 rate[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400,\n\t\t\t\t    192000, };\n\tbool is_sysclk = clk_is_match(clk, spdif_priv->sysclk);\n\tu64 rate_ideal, rate_actual, sub;\n\tu32 arate;\n\tu16 sysclk_dfmin, sysclk_dfmax, sysclk_df;\n\tu8 txclk_df;\n\n\t \n\tsysclk_dfmin = is_sysclk ? 2 : 1;\n\tsysclk_dfmax = is_sysclk ? 512 : 1;\n\n\tfor (sysclk_df = sysclk_dfmin; sysclk_df <= sysclk_dfmax; sysclk_df++) {\n\t\tfor (txclk_df = 1; txclk_df <= 128; txclk_df++) {\n\t\t\trate_ideal = rate[index] * txclk_df * 64ULL;\n\t\t\tif (round)\n\t\t\t\trate_actual = clk_round_rate(clk, rate_ideal);\n\t\t\telse\n\t\t\t\trate_actual = clk_get_rate(clk);\n\n\t\t\tarate = rate_actual / 64;\n\t\t\tarate /= txclk_df * sysclk_df;\n\n\t\t\tif (arate == rate[index]) {\n\t\t\t\t \n\t\t\t\tsavesub = 0;\n\t\t\t\tspdif_priv->txclk_df[index] = txclk_df;\n\t\t\t\tspdif_priv->sysclk_df[index] = sysclk_df;\n\t\t\t\tspdif_priv->txrate[index] = arate;\n\t\t\t\tgoto out;\n\t\t\t} else if (arate / rate[index] == 1) {\n\t\t\t\t \n\t\t\t\tsub = (u64)(arate - rate[index]) * 100000;\n\t\t\t\tdo_div(sub, rate[index]);\n\t\t\t\tif (sub >= savesub)\n\t\t\t\t\tcontinue;\n\t\t\t\tsavesub = sub;\n\t\t\t\tspdif_priv->txclk_df[index] = txclk_df;\n\t\t\t\tspdif_priv->sysclk_df[index] = sysclk_df;\n\t\t\t\tspdif_priv->txrate[index] = arate;\n\t\t\t} else if (rate[index] / arate == 1) {\n\t\t\t\t \n\t\t\t\tsub = (u64)(rate[index] - arate) * 100000;\n\t\t\t\tdo_div(sub, rate[index]);\n\t\t\t\tif (sub >= savesub)\n\t\t\t\t\tcontinue;\n\t\t\t\tsavesub = sub;\n\t\t\t\tspdif_priv->txclk_df[index] = txclk_df;\n\t\t\t\tspdif_priv->sysclk_df[index] = sysclk_df;\n\t\t\t\tspdif_priv->txrate[index] = arate;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn savesub;\n}\n\nstatic int fsl_spdif_probe_txclk(struct fsl_spdif_priv *spdif_priv,\n\t\t\t\tenum spdif_txrate index)\n{\n\tstatic const u32 rate[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400,\n\t\t\t\t    192000, };\n\tstruct platform_device *pdev = spdif_priv->pdev;\n\tstruct device *dev = &pdev->dev;\n\tu64 savesub = 100000, ret;\n\tstruct clk *clk;\n\tint i;\n\n\tfor (i = 0; i < STC_TXCLK_SRC_MAX; i++) {\n\t\tclk = spdif_priv->txclk[i];\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(dev, \"no rxtx%d clock in devicetree\\n\", i);\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\t\tif (!clk_get_rate(clk))\n\t\t\tcontinue;\n\n\t\tret = fsl_spdif_txclk_caldiv(spdif_priv, clk, savesub, index,\n\t\t\t\t\t     fsl_spdif_can_set_clk_rate(spdif_priv, i));\n\t\tif (savesub == ret)\n\t\t\tcontinue;\n\n\t\tsavesub = ret;\n\t\tspdif_priv->txclk_src[index] = i;\n\n\t\t \n\t\tif (savesub < 100)\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"use rxtx%d as tx clock source for %dHz sample rate\\n\",\n\t\t\tspdif_priv->txclk_src[index], rate[index]);\n\tdev_dbg(dev, \"use txclk df %d for %dHz sample rate\\n\",\n\t\t\tspdif_priv->txclk_df[index], rate[index]);\n\tif (clk_is_match(spdif_priv->txclk[spdif_priv->txclk_src[index]], spdif_priv->sysclk))\n\t\tdev_dbg(dev, \"use sysclk df %d for %dHz sample rate\\n\",\n\t\t\t\tspdif_priv->sysclk_df[index], rate[index]);\n\tdev_dbg(dev, \"the best rate for %dHz sample rate is %dHz\\n\",\n\t\t\trate[index], spdif_priv->txrate[index]);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_probe(struct platform_device *pdev)\n{\n\tstruct fsl_spdif_priv *spdif_priv;\n\tstruct spdif_mixer_control *ctrl;\n\tstruct resource *res;\n\tvoid __iomem *regs;\n\tint irq, ret, i;\n\tchar tmp[16];\n\n\tspdif_priv = devm_kzalloc(&pdev->dev, sizeof(*spdif_priv), GFP_KERNEL);\n\tif (!spdif_priv)\n\t\treturn -ENOMEM;\n\n\tspdif_priv->pdev = pdev;\n\n\tspdif_priv->soc = of_device_get_match_data(&pdev->dev);\n\n\t \n\tmemcpy(&spdif_priv->cpu_dai_drv, &fsl_spdif_dai, sizeof(fsl_spdif_dai));\n\tspdif_priv->cpu_dai_drv.name = dev_name(&pdev->dev);\n\tspdif_priv->cpu_dai_drv.playback.formats =\n\t\t\t\tspdif_priv->soc->tx_formats;\n\n\t \n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tspdif_priv->regmap = devm_regmap_init_mmio(&pdev->dev, regs, &fsl_spdif_regmap_config);\n\tif (IS_ERR(spdif_priv->regmap)) {\n\t\tdev_err(&pdev->dev, \"regmap init failed\\n\");\n\t\treturn PTR_ERR(spdif_priv->regmap);\n\t}\n\n\tfor (i = 0; i < spdif_priv->soc->interrupts; i++) {\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_irq(&pdev->dev, irq, spdif_isr, 0,\n\t\t\t\t       dev_name(&pdev->dev), spdif_priv);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not claim irq %u\\n\", irq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < STC_TXCLK_SRC_MAX; i++) {\n\t\tsprintf(tmp, \"rxtx%d\", i);\n\t\tspdif_priv->txclk[i] = devm_clk_get(&pdev->dev, tmp);\n\t\tif (IS_ERR(spdif_priv->txclk[i])) {\n\t\t\tdev_err(&pdev->dev, \"no rxtx%d clock in devicetree\\n\", i);\n\t\t\treturn PTR_ERR(spdif_priv->txclk[i]);\n\t\t}\n\t}\n\n\t \n\tspdif_priv->sysclk = spdif_priv->txclk[5];\n\tif (IS_ERR(spdif_priv->sysclk)) {\n\t\tdev_err(&pdev->dev, \"no sys clock (rxtx5) in devicetree\\n\");\n\t\treturn PTR_ERR(spdif_priv->sysclk);\n\t}\n\n\t \n\tspdif_priv->coreclk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(spdif_priv->coreclk)) {\n\t\tdev_err(&pdev->dev, \"no core clock in devicetree\\n\");\n\t\treturn PTR_ERR(spdif_priv->coreclk);\n\t}\n\n\tspdif_priv->spbaclk = devm_clk_get(&pdev->dev, \"spba\");\n\tif (IS_ERR(spdif_priv->spbaclk))\n\t\tdev_warn(&pdev->dev, \"no spba clock in devicetree\\n\");\n\n\t \n\tspdif_priv->rxclk = spdif_priv->txclk[1];\n\tif (IS_ERR(spdif_priv->rxclk)) {\n\t\tdev_err(&pdev->dev, \"no rxtx1 clock in devicetree\\n\");\n\t\treturn PTR_ERR(spdif_priv->rxclk);\n\t}\n\tspdif_priv->rxclk_src = DEFAULT_RXCLK_SRC;\n\n\tfsl_asoc_get_pll_clocks(&pdev->dev, &spdif_priv->pll8k_clk,\n\t\t\t\t&spdif_priv->pll11k_clk);\n\n\t \n\tctrl = &spdif_priv->fsl_spdif_control;\n\tspin_lock_init(&ctrl->ctl_lock);\n\n\t \n\tctrl->ch_status[0] = IEC958_AES0_CON_NOT_COPYRIGHT |\n\t\t\t     IEC958_AES0_CON_EMPHASIS_5015;\n\tctrl->ch_status[1] = IEC958_AES1_CON_DIGDIGCONV_ID;\n\tctrl->ch_status[2] = 0x00;\n\tctrl->ch_status[3] = IEC958_AES3_CON_FS_44100 |\n\t\t\t     IEC958_AES3_CON_CLOCK_1000PPM;\n\n\tspdif_priv->dpll_locked = false;\n\n\tspdif_priv->dma_params_tx.maxburst = spdif_priv->soc->tx_burst;\n\tspdif_priv->dma_params_rx.maxburst = spdif_priv->soc->rx_burst;\n\tspdif_priv->dma_params_tx.addr = res->start + REG_SPDIF_STL;\n\tspdif_priv->dma_params_rx.addr = res->start + REG_SPDIF_SRL;\n\n\t \n\tdev_set_drvdata(&pdev->dev, spdif_priv);\n\tpm_runtime_enable(&pdev->dev);\n\tregcache_cache_only(spdif_priv->regmap, true);\n\n\t \n\tret = imx_pcm_dma_init(pdev);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"imx_pcm_dma_init failed\\n\");\n\t\tgoto err_pm_disable;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &fsl_spdif_component,\n\t\t\t\t\t      &spdif_priv->cpu_dai_drv, 1);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register DAI: %d\\n\", ret);\n\t\tgoto err_pm_disable;\n\t}\n\n\treturn ret;\n\nerr_pm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void fsl_spdif_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_spdif_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_spdif_priv *spdif_priv = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tregmap_update_bits(spdif_priv->regmap, REG_SPDIF_SIE, 0xffffff, 0);\n\n\tregmap_read(spdif_priv->regmap, REG_SPDIF_SRPC,\n\t\t\t&spdif_priv->regcache_srpc);\n\tregcache_cache_only(spdif_priv->regmap, true);\n\n\tfor (i = 0; i < STC_TXCLK_SRC_MAX; i++)\n\t\tclk_disable_unprepare(spdif_priv->txclk[i]);\n\n\tif (!IS_ERR(spdif_priv->spbaclk))\n\t\tclk_disable_unprepare(spdif_priv->spbaclk);\n\tclk_disable_unprepare(spdif_priv->coreclk);\n\n\treturn 0;\n}\n\nstatic int fsl_spdif_runtime_resume(struct device *dev)\n{\n\tstruct fsl_spdif_priv *spdif_priv = dev_get_drvdata(dev);\n\tint ret;\n\tint i;\n\n\tret = clk_prepare_enable(spdif_priv->coreclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable core clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR(spdif_priv->spbaclk)) {\n\t\tret = clk_prepare_enable(spdif_priv->spbaclk);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to enable spba clock\\n\");\n\t\t\tgoto disable_core_clk;\n\t\t}\n\t}\n\n\tfor (i = 0; i < STC_TXCLK_SRC_MAX; i++) {\n\t\tret = clk_prepare_enable(spdif_priv->txclk[i]);\n\t\tif (ret)\n\t\t\tgoto disable_tx_clk;\n\t}\n\n\tregcache_cache_only(spdif_priv->regmap, false);\n\tregcache_mark_dirty(spdif_priv->regmap);\n\n\tregmap_update_bits(spdif_priv->regmap, REG_SPDIF_SRPC,\n\t\t\tSRPC_CLKSRC_SEL_MASK | SRPC_GAINSEL_MASK,\n\t\t\tspdif_priv->regcache_srpc);\n\n\tret = regcache_sync(spdif_priv->regmap);\n\tif (ret)\n\t\tgoto disable_tx_clk;\n\n\treturn 0;\n\ndisable_tx_clk:\n\tfor (i--; i >= 0; i--)\n\t\tclk_disable_unprepare(spdif_priv->txclk[i]);\n\tif (!IS_ERR(spdif_priv->spbaclk))\n\t\tclk_disable_unprepare(spdif_priv->spbaclk);\ndisable_core_clk:\n\tclk_disable_unprepare(spdif_priv->coreclk);\n\n\treturn ret;\n}\n#endif  \n\nstatic const struct dev_pm_ops fsl_spdif_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(fsl_spdif_runtime_suspend, fsl_spdif_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id fsl_spdif_dt_ids[] = {\n\t{ .compatible = \"fsl,imx35-spdif\", .data = &fsl_spdif_imx35, },\n\t{ .compatible = \"fsl,vf610-spdif\", .data = &fsl_spdif_vf610, },\n\t{ .compatible = \"fsl,imx6sx-spdif\", .data = &fsl_spdif_imx6sx, },\n\t{ .compatible = \"fsl,imx8qm-spdif\", .data = &fsl_spdif_imx8qm, },\n\t{ .compatible = \"fsl,imx8mm-spdif\", .data = &fsl_spdif_imx8mm, },\n\t{ .compatible = \"fsl,imx8ulp-spdif\", .data = &fsl_spdif_imx8ulp, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_spdif_dt_ids);\n\nstatic struct platform_driver fsl_spdif_driver = {\n\t.driver = {\n\t\t.name = \"fsl-spdif-dai\",\n\t\t.of_match_table = fsl_spdif_dt_ids,\n\t\t.pm = &fsl_spdif_pm,\n\t},\n\t.probe = fsl_spdif_probe,\n\t.remove_new = fsl_spdif_remove,\n};\n\nmodule_platform_driver(fsl_spdif_driver);\n\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_DESCRIPTION(\"Freescale S/PDIF CPU DAI Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:fsl-spdif-dai\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}