{
  "module_name": "mpc5200_psc_i2s.c",
  "hash_id": "810b018225060fc67a0bb312eefd052bd4396b17fa80bbffbc2924a85eff6d60",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/mpc5200_psc_i2s.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/mpc52xx_psc.h>\n\n#include \"mpc5200_dma.h\"\n\n \n#define PSC_I2S_RATES SNDRV_PCM_RATE_CONTINUOUS\n\n \n#define PSC_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE)\n\nstatic int psc_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tu32 mode;\n\n\tdev_dbg(psc_dma->dev, \"%s(substream=%p) p_size=%i p_bytes=%i\"\n\t\t\" periods=%i buffer_size=%i  buffer_bytes=%i\\n\",\n\t\t__func__, substream, params_period_size(params),\n\t\tparams_period_bytes(params), params_periods(params),\n\t\tparams_buffer_size(params), params_buffer_bytes(params));\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tmode = MPC52xx_PSC_SICR_SIM_CODEC_8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_BE:\n\t\tmode = MPC52xx_PSC_SICR_SIM_CODEC_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_BE:\n\t\tmode = MPC52xx_PSC_SICR_SIM_CODEC_24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_BE:\n\t\tmode = MPC52xx_PSC_SICR_SIM_CODEC_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(psc_dma->dev, \"invalid format\\n\");\n\t\treturn -EINVAL;\n\t}\n\tout_be32(&psc_dma->psc_regs->sicr, psc_dma->sicr | mode);\n\n\treturn 0;\n}\n\n \nstatic int psc_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t      int clk_id, unsigned int freq, int dir)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(cpu_dai);\n\tdev_dbg(psc_dma->dev, \"psc_i2s_set_sysclk(cpu_dai=%p, dir=%i)\\n\",\n\t\t\t\tcpu_dai, dir);\n\treturn (dir == SND_SOC_CLOCK_IN) ? 0 : -EINVAL;\n}\n\n \nstatic int psc_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int format)\n{\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(cpu_dai);\n\tdev_dbg(psc_dma->dev, \"psc_i2s_set_fmt(cpu_dai=%p, format=%i)\\n\",\n\t\t\t\tcpu_dai, format);\n\treturn (format == SND_SOC_DAIFMT_I2S) ? 0 : -EINVAL;\n}\n\n \n\n \nstatic const struct snd_soc_dai_ops psc_i2s_dai_ops = {\n\t.hw_params\t= psc_i2s_hw_params,\n\t.set_sysclk\t= psc_i2s_set_sysclk,\n\t.set_fmt\t= psc_i2s_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver psc_i2s_dai[] = {{\n\t.name = \"mpc5200-psc-i2s.0\",\n\t.playback = {\n\t\t.stream_name = \"I2S Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PSC_I2S_RATES,\n\t\t.formats = PSC_I2S_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"I2S Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = PSC_I2S_RATES,\n\t\t.formats = PSC_I2S_FORMATS,\n\t},\n\t.ops = &psc_i2s_dai_ops,\n} };\n\nstatic const struct snd_soc_component_driver psc_i2s_component = {\n\t.name\t\t\t= \"mpc5200-i2s\",\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic int psc_i2s_of_probe(struct platform_device *op)\n{\n\tint rc;\n\tstruct psc_dma *psc_dma;\n\tstruct mpc52xx_psc __iomem *regs;\n\n\trc = mpc5200_audio_dma_create(op);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = snd_soc_register_component(&op->dev, &psc_i2s_component,\n\t\t\t\t\tpsc_i2s_dai, ARRAY_SIZE(psc_i2s_dai));\n\tif (rc != 0) {\n\t\tpr_err(\"Failed to register DAI\\n\");\n\t\treturn rc;\n\t}\n\n\tpsc_dma = dev_get_drvdata(&op->dev);\n\tregs = psc_dma->psc_regs;\n\n\t \n\tpsc_dma->sicr = MPC52xx_PSC_SICR_DTS1 | MPC52xx_PSC_SICR_I2S |\n\t\t\tMPC52xx_PSC_SICR_CLKPOL;\n\tout_be32(&psc_dma->psc_regs->sicr,\n\t\t psc_dma->sicr | MPC52xx_PSC_SICR_SIM_CODEC_8);\n\n\t \n\tif (!of_get_property(op->dev.of_node, \"codec-handle\", NULL))\n\t\treturn 0;\n\n\t \n\n\t \n\twhile ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0)\n\t\t;\n\t \n\twhile ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0)\n\t\t;\n\t \n\n\t \n\tout_8(&psc_dma->psc_regs->command,\n\t\t\tMPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);\n\n\treturn 0;\n\n}\n\nstatic void psc_i2s_of_remove(struct platform_device *op)\n{\n\tmpc5200_audio_dma_destroy(op);\n\tsnd_soc_unregister_component(&op->dev);\n}\n\n \nstatic const struct of_device_id psc_i2s_match[] = {\n\t{ .compatible = \"fsl,mpc5200-psc-i2s\", },\n\t{ .compatible = \"fsl,mpc5200b-psc-i2s\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, psc_i2s_match);\n\nstatic struct platform_driver psc_i2s_driver = {\n\t.probe = psc_i2s_of_probe,\n\t.remove_new = psc_i2s_of_remove,\n\t.driver = {\n\t\t.name = \"mpc5200-psc-i2s\",\n\t\t.of_match_table = psc_i2s_match,\n\t},\n};\n\nmodule_platform_driver(psc_i2s_driver);\n\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_DESCRIPTION(\"Freescale MPC5200 PSC in I2S mode ASoC Driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}