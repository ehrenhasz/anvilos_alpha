{
  "module_name": "imx-audmix.c",
  "hash_id": "27dc4c4de40d504f69d0181a09cfc4c418f598091f432847a038fa86cadf79d3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/imx-audmix.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/clk.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include \"fsl_sai.h\"\n#include \"fsl_audmix.h\"\n\nstruct imx_audmix {\n\tstruct platform_device *pdev;\n\tstruct snd_soc_card card;\n\tstruct platform_device *audmix_pdev;\n\tstruct platform_device *out_pdev;\n\tstruct clk *cpu_mclk;\n\tint num_dai;\n\tstruct snd_soc_dai_link *dai;\n\tint num_dai_conf;\n\tstruct snd_soc_codec_conf *dai_conf;\n\tint num_dapm_routes;\n\tstruct snd_soc_dapm_route *dapm_routes;\n};\n\nstatic const u32 imx_audmix_rates[] = {\n\t8000, 12000, 16000, 24000, 32000, 48000, 64000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list imx_audmix_rate_constraints = {\n\t.count = ARRAY_SIZE(imx_audmix_rates),\n\t.list = imx_audmix_rates,\n};\n\nstatic int imx_audmix_fe_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct imx_audmix *priv = snd_soc_card_get_drvdata(rtd->card);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct device *dev = rtd->card->dev;\n\tunsigned long clk_rate = clk_get_rate(priv->cpu_mclk);\n\tint ret;\n\n\tif (clk_rate % 24576000 == 0) {\n\t\tret = snd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t\t\t SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t &imx_audmix_rate_constraints);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tdev_warn(dev, \"mclk may be not supported %lu\\n\", clk_rate);\n\t}\n\n\tret = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   1, 8);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_constraint_mask64(runtime, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t    FSL_AUDMIX_FORMATS);\n}\n\nstatic int imx_audmix_fe_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct device *dev = rtd->card->dev;\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned int fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF;\n\tu32 channels = params_channels(params);\n\tint ret, dir;\n\n\t \n\tfmt |= tx ? SND_SOC_DAIFMT_BP_FP : SND_SOC_DAIFMT_BC_FC;\n\tdir  = tx ? SND_SOC_CLOCK_OUT : SND_SOC_CLOCK_IN;\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_cpu(rtd, 0), fmt);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set cpu dai fmt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), FSL_SAI_CLK_MAST1, 0, dir);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set cpu sysclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), BIT(channels) - 1,\n\t\t\t\t       BIT(channels) - 1, 8, 32);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set cpu dai tdm slot: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int imx_audmix_be_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct device *dev = rtd->card->dev;\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned int fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF;\n\tint ret;\n\n\tif (!tx)\n\t\treturn 0;\n\n\t \n\tfmt |= SND_SOC_DAIFMT_BC_FC;\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_cpu(rtd, 0), fmt);\n\tif (ret)\n\t\tdev_err(dev, \"failed to set AUDMIX DAI fmt: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops imx_audmix_fe_ops = {\n\t.startup = imx_audmix_fe_startup,\n\t.hw_params = imx_audmix_fe_hw_params,\n};\n\nstatic const struct snd_soc_ops imx_audmix_be_ops = {\n\t.hw_params = imx_audmix_be_hw_params,\n};\n\nstatic int imx_audmix_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *audmix_np = NULL, *out_cpu_np = NULL;\n\tstruct platform_device *audmix_pdev = NULL;\n\tstruct platform_device *cpu_pdev;\n\tstruct of_phandle_args args;\n\tstruct imx_audmix *priv;\n\tint i, num_dai, ret;\n\tconst char *fe_name_pref = \"HiFi-AUDMIX-FE-\";\n\tchar *be_name, *be_pb, *be_cp, *dai_name, *capture_dai_name;\n\n\tif (pdev->dev.parent) {\n\t\taudmix_np = pdev->dev.parent->of_node;\n\t} else {\n\t\tdev_err(&pdev->dev, \"Missing parent device.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!audmix_np) {\n\t\tdev_err(&pdev->dev, \"Missing DT node for parent device.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taudmix_pdev = of_find_device_by_node(audmix_np);\n\tif (!audmix_pdev) {\n\t\tdev_err(&pdev->dev, \"Missing AUDMIX platform device for %s\\n\",\n\t\t\tnp->full_name);\n\t\treturn -EINVAL;\n\t}\n\tput_device(&audmix_pdev->dev);\n\n\tnum_dai = of_count_phandle_with_args(audmix_np, \"dais\", NULL);\n\tif (num_dai != FSL_AUDMIX_MAX_DAIS) {\n\t\tdev_err(&pdev->dev, \"Need 2 dais to be provided for %s\\n\",\n\t\t\taudmix_np->full_name);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->num_dai = 2 * num_dai;\n\tpriv->dai = devm_kcalloc(&pdev->dev, priv->num_dai,\n\t\t\t\t sizeof(struct snd_soc_dai_link), GFP_KERNEL);\n\tif (!priv->dai)\n\t\treturn -ENOMEM;\n\n\tpriv->num_dai_conf = num_dai;\n\tpriv->dai_conf = devm_kcalloc(&pdev->dev, priv->num_dai_conf,\n\t\t\t\t      sizeof(struct snd_soc_codec_conf),\n\t\t\t\t      GFP_KERNEL);\n\tif (!priv->dai_conf)\n\t\treturn -ENOMEM;\n\n\tpriv->num_dapm_routes = 3 * num_dai;\n\tpriv->dapm_routes = devm_kcalloc(&pdev->dev, priv->num_dapm_routes,\n\t\t\t\t\t sizeof(struct snd_soc_dapm_route),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->dapm_routes)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_dai; i++) {\n\t\tstruct snd_soc_dai_link_component *dlc;\n\n\t\t \n\t\tdlc = devm_kcalloc(&pdev->dev, 2, sizeof(*dlc), GFP_KERNEL);\n\t\tif (!dlc)\n\t\t\treturn -ENOMEM;\n\n\t\tret = of_parse_phandle_with_args(audmix_np, \"dais\", NULL, i,\n\t\t\t\t\t\t &args);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"of_parse_phandle_with_args failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tcpu_pdev = of_find_device_by_node(args.np);\n\t\tif (!cpu_pdev) {\n\t\t\tdev_err(&pdev->dev, \"failed to find SAI platform device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tput_device(&cpu_pdev->dev);\n\n\t\tdai_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s%s\",\n\t\t\t\t\t  fe_name_pref, args.np->full_name + 1);\n\t\tif (!dai_name)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_info(pdev->dev.parent, \"DAI FE name:%s\\n\", dai_name);\n\n\t\tif (i == 0) {\n\t\t\tout_cpu_np = args.np;\n\t\t\tcapture_dai_name =\n\t\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s %s\",\n\t\t\t\t\t       dai_name, \"CPU-Capture\");\n\t\t\tif (!capture_dai_name)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tpriv->dai[i].cpus\t=\n\t\tpriv->dai[i].platforms\t= &dlc[0];\n\t\tpriv->dai[i].codecs\t= &asoc_dummy_dlc;\n\n\t\tpriv->dai[i].num_cpus = 1;\n\t\tpriv->dai[i].num_codecs = 1;\n\t\tpriv->dai[i].num_platforms = 1;\n\n\t\tpriv->dai[i].name = dai_name;\n\t\tpriv->dai[i].stream_name = \"HiFi-AUDMIX-FE\";\n\t\tpriv->dai[i].cpus->of_node = args.np;\n\t\tpriv->dai[i].cpus->dai_name = dev_name(&cpu_pdev->dev);\n\t\tpriv->dai[i].dynamic = 1;\n\t\tpriv->dai[i].dpcm_playback = 1;\n\t\tpriv->dai[i].dpcm_capture = (i == 0 ? 1 : 0);\n\t\tpriv->dai[i].ignore_pmdown_time = 1;\n\t\tpriv->dai[i].ops = &imx_audmix_fe_ops;\n\n\t\t \n\t\tbe_name = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t\t \"audmix-%d\", i);\n\t\tbe_pb = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t       \"AUDMIX-Playback-%d\", i);\n\t\tbe_cp = devm_kasprintf(&pdev->dev, GFP_KERNEL,\n\t\t\t\t       \"AUDMIX-Capture-%d\", i);\n\t\tif (!be_name || !be_pb || !be_cp)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->dai[num_dai + i].cpus\t= &dlc[1];\n\t\tpriv->dai[num_dai + i].codecs\t= &asoc_dummy_dlc;\n\n\t\tpriv->dai[num_dai + i].num_cpus = 1;\n\t\tpriv->dai[num_dai + i].num_codecs = 1;\n\n\t\tpriv->dai[num_dai + i].name = be_name;\n\t\tpriv->dai[num_dai + i].cpus->of_node = audmix_np;\n\t\tpriv->dai[num_dai + i].cpus->dai_name = be_name;\n\t\tpriv->dai[num_dai + i].no_pcm = 1;\n\t\tpriv->dai[num_dai + i].dpcm_playback = 1;\n\t\tpriv->dai[num_dai + i].dpcm_capture  = 1;\n\t\tpriv->dai[num_dai + i].ignore_pmdown_time = 1;\n\t\tpriv->dai[num_dai + i].ops = &imx_audmix_be_ops;\n\n\t\tpriv->dai_conf[i].dlc.of_node = args.np;\n\t\tpriv->dai_conf[i].name_prefix = dai_name;\n\n\t\tpriv->dapm_routes[i].source =\n\t\t\tdevm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s %s\",\n\t\t\t\t       dai_name, \"CPU-Playback\");\n\t\tif (!priv->dapm_routes[i].source)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->dapm_routes[i].sink = be_pb;\n\t\tpriv->dapm_routes[num_dai + i].source   = be_pb;\n\t\tpriv->dapm_routes[num_dai + i].sink     = be_cp;\n\t\tpriv->dapm_routes[2 * num_dai + i].source = be_cp;\n\t\tpriv->dapm_routes[2 * num_dai + i].sink   = capture_dai_name;\n\t}\n\n\tcpu_pdev = of_find_device_by_node(out_cpu_np);\n\tif (!cpu_pdev) {\n\t\tdev_err(&pdev->dev, \"failed to find SAI platform device\\n\");\n\t\treturn -EINVAL;\n\t}\n\tput_device(&cpu_pdev->dev);\n\n\tpriv->cpu_mclk = devm_clk_get(&cpu_pdev->dev, \"mclk1\");\n\tif (IS_ERR(priv->cpu_mclk)) {\n\t\tret = PTR_ERR(priv->cpu_mclk);\n\t\tdev_err(&cpu_pdev->dev, \"failed to get DAI mclk1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->audmix_pdev = audmix_pdev;\n\tpriv->out_pdev  = cpu_pdev;\n\n\tpriv->card.dai_link = priv->dai;\n\tpriv->card.num_links = priv->num_dai;\n\tpriv->card.codec_conf = priv->dai_conf;\n\tpriv->card.num_configs = priv->num_dai_conf;\n\tpriv->card.dapm_routes = priv->dapm_routes;\n\tpriv->card.num_dapm_routes = priv->num_dapm_routes;\n\tpriv->card.dev = &pdev->dev;\n\tpriv->card.owner = THIS_MODULE;\n\tpriv->card.name = \"imx-audmix\";\n\n\tplatform_set_drvdata(pdev, &priv->card);\n\tsnd_soc_card_set_drvdata(&priv->card, priv);\n\n\tret = devm_snd_soc_register_card(&pdev->dev, &priv->card);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"snd_soc_register_card failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver imx_audmix_driver = {\n\t.probe = imx_audmix_probe,\n\t.driver = {\n\t\t.name = \"imx-audmix\",\n\t\t.pm = &snd_soc_pm_ops,\n\t},\n};\nmodule_platform_driver(imx_audmix_driver);\n\nMODULE_DESCRIPTION(\"NXP AUDMIX ASoC machine driver\");\nMODULE_AUTHOR(\"Viorel Suman <viorel.suman@nxp.com>\");\nMODULE_ALIAS(\"platform:imx-audmix\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}