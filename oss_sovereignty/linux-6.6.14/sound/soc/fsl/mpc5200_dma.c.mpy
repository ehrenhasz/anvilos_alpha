{
  "module_name": "mpc5200_dma.c",
  "hash_id": "1fa9e9b8fbd58ee8175aefbab1746caa1fbf30b642bc5ed1e2107198bc883fec",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/mpc5200_dma.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n\n#include <sound/soc.h>\n\n#include <linux/fsl/bestcomm/bestcomm.h>\n#include <linux/fsl/bestcomm/gen_bd.h>\n#include <asm/mpc52xx_psc.h>\n\n#include \"mpc5200_dma.h\"\n\n#define DRV_NAME \"mpc5200_dma\"\n\n \nstatic irqreturn_t psc_dma_status_irq(int irq, void *_psc_dma)\n{\n\tstruct psc_dma *psc_dma = _psc_dma;\n\tstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\n\tu16 isr;\n\n\tisr = in_be16(&regs->mpc52xx_psc_isr);\n\n\t \n\tif (psc_dma->playback.active && (isr & MPC52xx_PSC_IMR_TXEMP))\n\t\tpsc_dma->stats.underrun_count++;\n\n\t \n\tif (psc_dma->capture.active && (isr & MPC52xx_PSC_IMR_ORERR))\n\t\tpsc_dma->stats.overrun_count++;\n\n\tout_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void psc_dma_bcom_enqueue_next_buffer(struct psc_dma_stream *s)\n{\n\tstruct bcom_bd *bd;\n\n\t \n\tbd = bcom_prepare_next_buffer(s->bcom_task);\n\tbd->status = s->period_bytes;\n\tbd->data[0] = s->runtime->dma_addr + (s->period_next * s->period_bytes);\n\tbcom_submit_next_buffer(s->bcom_task, NULL);\n\n\t \n\ts->period_next = (s->period_next + 1) % s->runtime->periods;\n}\n\n \nstatic irqreturn_t psc_dma_bcom_irq(int irq, void *_psc_dma_stream)\n{\n\tstruct psc_dma_stream *s = _psc_dma_stream;\n\n\tspin_lock(&s->psc_dma->lock);\n\t \n\twhile (bcom_buffer_done(s->bcom_task)) {\n\t\tbcom_retrieve_buffer(s->bcom_task, NULL, NULL);\n\n\t\ts->period_current = (s->period_current+1) % s->runtime->periods;\n\t\ts->period_count++;\n\n\t\tpsc_dma_bcom_enqueue_next_buffer(s);\n\t}\n\tspin_unlock(&s->psc_dma->lock);\n\n\t \n\tif (s->active)\n\t\tsnd_pcm_period_elapsed(s->stream);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int psc_dma_trigger(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct psc_dma_stream *s = to_psc_dma_stream(substream, psc_dma);\n\tstruct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;\n\tu16 imr;\n\tunsigned long flags;\n\tint i;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tdev_dbg(psc_dma->dev, \"START: stream=%i fbits=%u ps=%u #p=%u\\n\",\n\t\t\tsubstream->pstr->stream, runtime->frame_bits,\n\t\t\t(int)runtime->period_size, runtime->periods);\n\t\ts->period_bytes = frames_to_bytes(runtime,\n\t\t\t\t\t\t  runtime->period_size);\n\t\ts->period_next = 0;\n\t\ts->period_current = 0;\n\t\ts->active = 1;\n\t\ts->period_count = 0;\n\t\ts->runtime = runtime;\n\n\t\t \n\t\tspin_lock_irqsave(&psc_dma->lock, flags);\n\n\t\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tbcom_gen_bd_rx_reset(s->bcom_task);\n\t\telse\n\t\t\tbcom_gen_bd_tx_reset(s->bcom_task);\n\n\t\tfor (i = 0; i < runtime->periods; i++)\n\t\t\tif (!bcom_queue_full(s->bcom_task))\n\t\t\t\tpsc_dma_bcom_enqueue_next_buffer(s);\n\n\t\tbcom_enable(s->bcom_task);\n\t\tspin_unlock_irqrestore(&psc_dma->lock, flags);\n\n\t\tout_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);\n\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tdev_dbg(psc_dma->dev, \"STOP: stream=%i periods_count=%i\\n\",\n\t\t\tsubstream->pstr->stream, s->period_count);\n\t\ts->active = 0;\n\n\t\tspin_lock_irqsave(&psc_dma->lock, flags);\n\t\tbcom_disable(s->bcom_task);\n\t\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\tbcom_gen_bd_rx_reset(s->bcom_task);\n\t\telse\n\t\t\tbcom_gen_bd_tx_reset(s->bcom_task);\n\t\tspin_unlock_irqrestore(&psc_dma->lock, flags);\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(psc_dma->dev, \"unhandled trigger: stream=%i cmd=%i\\n\",\n\t\t\tsubstream->pstr->stream, cmd);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\timr = 0;\n\tif (psc_dma->playback.active)\n\t\timr |= MPC52xx_PSC_IMR_TXEMP;\n\tif (psc_dma->capture.active)\n\t\timr |= MPC52xx_PSC_IMR_ORERR;\n\tout_be16(&regs->isr_imr.imr, psc_dma->imr | imr);\n\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_pcm_hardware psc_dma_hardware = {\n\t.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |\n\t\tSNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |\n\t\tSNDRV_PCM_INFO_BATCH,\n\t.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |\n\t\tSNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,\n\t.period_bytes_max\t= 1024 * 1024,\n\t.period_bytes_min\t= 32,\n\t.periods_min\t\t= 2,\n\t.periods_max\t\t= 256,\n\t.buffer_bytes_max\t= 2 * 1024 * 1024,\n\t.fifo_size\t\t= 512,\n};\n\nstatic int psc_dma_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct psc_dma_stream *s;\n\tint rc;\n\n\tdev_dbg(psc_dma->dev, \"psc_dma_open(substream=%p)\\n\", substream);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\ts = &psc_dma->capture;\n\telse\n\t\ts = &psc_dma->playback;\n\n\tsnd_soc_set_runtime_hwparams(substream, &psc_dma_hardware);\n\n\trc = snd_pcm_hw_constraint_integer(runtime,\n\t\tSNDRV_PCM_HW_PARAM_PERIODS);\n\tif (rc < 0) {\n\t\tdev_err(substream->pcm->card->dev, \"invalid buffer size\\n\");\n\t\treturn rc;\n\t}\n\n\ts->stream = substream;\n\treturn 0;\n}\n\nstatic int psc_dma_close(struct snd_soc_component *component,\n\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct psc_dma_stream *s;\n\n\tdev_dbg(psc_dma->dev, \"psc_dma_close(substream=%p)\\n\", substream);\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\ts = &psc_dma->capture;\n\telse\n\t\ts = &psc_dma->playback;\n\n\tif (!psc_dma->playback.active &&\n\t    !psc_dma->capture.active) {\n\n\t\t \n\t\tout_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);\n\t\tout_8(&psc_dma->psc_regs->command, 4 << 4);  \n\t}\n\ts->stream = NULL;\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t\npsc_dma_pointer(struct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct psc_dma *psc_dma = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\tstruct psc_dma_stream *s;\n\tdma_addr_t count;\n\n\tif (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\ts = &psc_dma->capture;\n\telse\n\t\ts = &psc_dma->playback;\n\n\tcount = s->period_current * s->period_bytes;\n\n\treturn bytes_to_frames(substream->runtime, count);\n}\n\nstatic int psc_dma_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_card *card = rtd->card->snd_card;\n\tstruct snd_soc_dai *dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_pcm *pcm = rtd->pcm;\n\tsize_t size = psc_dma_hardware.buffer_bytes_max;\n\tint rc;\n\n\tdev_dbg(component->dev, \"psc_dma_new(card=%p, dai=%p, pcm=%p)\\n\",\n\t\tcard, dai, pcm);\n\n\trc = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\n\tif (rc)\n\t\treturn rc;\n\n\treturn snd_pcm_set_fixed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV, card->dev,\n\t\t\t\t\t    size);\n}\n\nstatic const struct snd_soc_component_driver mpc5200_audio_dma_component = {\n\t.name\t\t= DRV_NAME,\n\t.open\t\t= psc_dma_open,\n\t.close\t\t= psc_dma_close,\n\t.pointer\t= psc_dma_pointer,\n\t.trigger\t= psc_dma_trigger,\n\t.pcm_construct\t= psc_dma_new,\n};\n\nint mpc5200_audio_dma_create(struct platform_device *op)\n{\n\tphys_addr_t fifo;\n\tstruct psc_dma *psc_dma;\n\tstruct resource res;\n\tint size, irq, rc;\n\tconst __be32 *prop;\n\tvoid __iomem *regs;\n\tint ret;\n\n\t \n\tirq = irq_of_parse_and_map(op->dev.of_node, 0);\n\tif (of_address_to_resource(op->dev.of_node, 0, &res)) {\n\t\tdev_err(&op->dev, \"Missing reg property\\n\");\n\t\treturn -ENODEV;\n\t}\n\tregs = ioremap(res.start, resource_size(&res));\n\tif (!regs) {\n\t\tdev_err(&op->dev, \"Could not map registers\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpsc_dma = kzalloc(sizeof *psc_dma, GFP_KERNEL);\n\tif (!psc_dma) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unmap;\n\t}\n\n\t \n\tprop = of_get_property(op->dev.of_node, \"cell-index\", &size);\n\tif (!prop || size < sizeof *prop) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tspin_lock_init(&psc_dma->lock);\n\tmutex_init(&psc_dma->mutex);\n\tpsc_dma->id = be32_to_cpu(*prop);\n\tpsc_dma->irq = irq;\n\tpsc_dma->psc_regs = regs;\n\tpsc_dma->fifo_regs = regs + sizeof *psc_dma->psc_regs;\n\tpsc_dma->dev = &op->dev;\n\tpsc_dma->playback.psc_dma = psc_dma;\n\tpsc_dma->capture.psc_dma = psc_dma;\n\tsnprintf(psc_dma->name, sizeof(psc_dma->name), \"PSC%d\", psc_dma->id);\n\n\t \n\tfifo = res.start + offsetof(struct mpc52xx_psc, buffer.buffer_32);\n\tpsc_dma->capture.bcom_task =\n\t\tbcom_psc_gen_bd_rx_init(psc_dma->id, 10, fifo, 512);\n\tpsc_dma->playback.bcom_task =\n\t\tbcom_psc_gen_bd_tx_init(psc_dma->id, 10, fifo);\n\tif (!psc_dma->capture.bcom_task ||\n\t    !psc_dma->playback.bcom_task) {\n\t\tdev_err(&op->dev, \"Could not allocate bestcomm tasks\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\t \n\tout_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);\n\t  \n\tout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_RX);\n\t  \n\tout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_TX);\n\t  \n\tout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RST_ERR_STAT);\n\t  \n\tout_8(&psc_dma->psc_regs->command, MPC52xx_PSC_SEL_MODE_REG_1);\n\n\t \n\tout_8(&psc_dma->psc_regs->mode, 0);\n\tout_8(&psc_dma->psc_regs->mode, 0);\n\n\t \n\tout_be16(&psc_dma->fifo_regs->rfalarm, 0x100);\n\tout_8(&psc_dma->fifo_regs->rfcntl, 0x4);\n\tout_be16(&psc_dma->fifo_regs->tfalarm, 0x100);\n\tout_8(&psc_dma->fifo_regs->tfcntl, 0x7);\n\n\t \n\tpsc_dma->playback.irq =\n\t\tbcom_get_task_irq(psc_dma->playback.bcom_task);\n\tpsc_dma->capture.irq =\n\t\tbcom_get_task_irq(psc_dma->capture.bcom_task);\n\n\trc = request_irq(psc_dma->irq, &psc_dma_status_irq, IRQF_SHARED,\n\t\t\t \"psc-dma-status\", psc_dma);\n\trc |= request_irq(psc_dma->capture.irq, &psc_dma_bcom_irq, IRQF_SHARED,\n\t\t\t  \"psc-dma-capture\", &psc_dma->capture);\n\trc |= request_irq(psc_dma->playback.irq, &psc_dma_bcom_irq, IRQF_SHARED,\n\t\t\t  \"psc-dma-playback\", &psc_dma->playback);\n\tif (rc) {\n\t\tret = -ENODEV;\n\t\tgoto out_irq;\n\t}\n\n\t \n\tdev_set_drvdata(&op->dev, psc_dma);\n\n\t \n\treturn devm_snd_soc_register_component(&op->dev,\n\t\t\t\t\t&mpc5200_audio_dma_component, NULL, 0);\nout_irq:\n\tfree_irq(psc_dma->irq, psc_dma);\n\tfree_irq(psc_dma->capture.irq, &psc_dma->capture);\n\tfree_irq(psc_dma->playback.irq, &psc_dma->playback);\nout_free:\n\tkfree(psc_dma);\nout_unmap:\n\tiounmap(regs);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mpc5200_audio_dma_create);\n\nint mpc5200_audio_dma_destroy(struct platform_device *op)\n{\n\tstruct psc_dma *psc_dma = dev_get_drvdata(&op->dev);\n\n\tdev_dbg(&op->dev, \"mpc5200_audio_dma_destroy()\\n\");\n\n\tbcom_gen_bd_rx_release(psc_dma->capture.bcom_task);\n\tbcom_gen_bd_tx_release(psc_dma->playback.bcom_task);\n\n\t \n\tfree_irq(psc_dma->irq, psc_dma);\n\tfree_irq(psc_dma->capture.irq, &psc_dma->capture);\n\tfree_irq(psc_dma->playback.irq, &psc_dma->playback);\n\n\tiounmap(psc_dma->psc_regs);\n\tkfree(psc_dma);\n\tdev_set_drvdata(&op->dev, NULL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mpc5200_audio_dma_destroy);\n\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_DESCRIPTION(\"Freescale MPC5200 PSC in DMA mode ASoC Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}