{
  "module_name": "mpc8610_hpcd.c",
  "hash_id": "36cce04cf0a854ffb5dc4a13ad421c6ce49f4665f20155f6cc730f8b02ed0849",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/mpc8610_hpcd.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/fsl/guts.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n\n#include \"fsl_dma.h\"\n#include \"fsl_ssi.h\"\n#include \"fsl_utils.h\"\n\n \nstatic phys_addr_t guts_phys;\n\n \nstruct mpc8610_hpcd_data {\n\tstruct snd_soc_dai_link dai[2];\n\tstruct snd_soc_card card;\n\tunsigned int dai_format;\n\tunsigned int codec_clk_direction;\n\tunsigned int cpu_clk_direction;\n\tunsigned int clk_frequency;\n\tunsigned int ssi_id;\t\t \n\tunsigned int dma_id[2];\t\t \n\tunsigned int dma_channel_id[2];  \n\tchar codec_dai_name[DAI_NAME_SIZE];\n\tchar platform_name[2][DAI_NAME_SIZE];  \n};\n\n \nstatic int mpc8610_hpcd_machine_probe(struct snd_soc_card *card)\n{\n\tstruct mpc8610_hpcd_data *machine_data =\n\t\tcontainer_of(card, struct mpc8610_hpcd_data, card);\n\tstruct ccsr_guts __iomem *guts;\n\n\tguts = ioremap(guts_phys, sizeof(struct ccsr_guts));\n\tif (!guts) {\n\t\tdev_err(card->dev, \"could not map global utilities\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tguts_set_dmacr(guts, machine_data->dma_id[0],\n\t\t       machine_data->dma_channel_id[0],\n\t\t       CCSR_GUTS_DMACR_DEV_SSI);\n\tguts_set_dmacr(guts, machine_data->dma_id[1],\n\t\t       machine_data->dma_channel_id[1],\n\t\t       CCSR_GUTS_DMACR_DEV_SSI);\n\n\tguts_set_pmuxcr_dma(guts, machine_data->dma_id[0],\n\t\t\t    machine_data->dma_channel_id[0], 0);\n\tguts_set_pmuxcr_dma(guts, machine_data->dma_id[1],\n\t\t\t    machine_data->dma_channel_id[1], 0);\n\n\tswitch (machine_data->ssi_id) {\n\tcase 0:\n\t\tclrsetbits_be32(&guts->pmuxcr,\n\t\t\tCCSR_GUTS_PMUXCR_SSI1_MASK, CCSR_GUTS_PMUXCR_SSI1_SSI);\n\t\tbreak;\n\tcase 1:\n\t\tclrsetbits_be32(&guts->pmuxcr,\n\t\t\tCCSR_GUTS_PMUXCR_SSI2_MASK, CCSR_GUTS_PMUXCR_SSI2_SSI);\n\t\tbreak;\n\t}\n\n\tiounmap(guts);\n\n\treturn 0;\n}\n\n \nstatic int mpc8610_hpcd_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct mpc8610_hpcd_data *machine_data =\n\t\tcontainer_of(rtd->card, struct mpc8610_hpcd_data, card);\n\tstruct device *dev = rtd->card->dev;\n\tint ret = 0;\n\n\t \n\tret = snd_soc_dai_set_fmt(asoc_rtd_to_codec(rtd, 0), machine_data->dai_format);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not set codec driver audio format\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_dai_set_sysclk(asoc_rtd_to_codec(rtd, 0), 0,\n\t\t\t\t     machine_data->clk_frequency,\n\t\t\t\t     machine_data->codec_clk_direction);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"could not set codec driver clock params\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mpc8610_hpcd_machine_remove(struct snd_soc_card *card)\n{\n\tstruct mpc8610_hpcd_data *machine_data =\n\t\tcontainer_of(card, struct mpc8610_hpcd_data, card);\n\tstruct ccsr_guts __iomem *guts;\n\n\tguts = ioremap(guts_phys, sizeof(struct ccsr_guts));\n\tif (!guts) {\n\t\tdev_err(card->dev, \"could not map global utilities\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\n\tguts_set_dmacr(guts, machine_data->dma_id[0],\n\t\t       machine_data->dma_channel_id[0], 0);\n\tguts_set_dmacr(guts, machine_data->dma_id[1],\n\t\t       machine_data->dma_channel_id[1], 0);\n\n\tswitch (machine_data->ssi_id) {\n\tcase 0:\n\t\tclrsetbits_be32(&guts->pmuxcr,\n\t\t\tCCSR_GUTS_PMUXCR_SSI1_MASK, CCSR_GUTS_PMUXCR_SSI1_LA);\n\t\tbreak;\n\tcase 1:\n\t\tclrsetbits_be32(&guts->pmuxcr,\n\t\t\tCCSR_GUTS_PMUXCR_SSI2_MASK, CCSR_GUTS_PMUXCR_SSI2_LA);\n\t\tbreak;\n\t}\n\n\tiounmap(guts);\n\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_ops mpc8610_hpcd_ops = {\n\t.startup = mpc8610_hpcd_startup,\n};\n\n \nstatic int mpc8610_hpcd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = pdev->dev.parent;\n\t \n\tstruct platform_device *ssi_pdev = to_platform_device(dev);\n\tstruct device_node *np = ssi_pdev->dev.of_node;\n\tstruct device_node *codec_np = NULL;\n\tstruct mpc8610_hpcd_data *machine_data;\n\tstruct snd_soc_dai_link_component *comp;\n\tint ret;\n\tconst char *sprop;\n\tconst u32 *iprop;\n\n\t \n\tcodec_np = of_parse_phandle(np, \"codec-handle\", 0);\n\tif (!codec_np) {\n\t\tdev_err(dev, \"invalid codec node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmachine_data = kzalloc(sizeof(struct mpc8610_hpcd_data), GFP_KERNEL);\n\tif (!machine_data) {\n\t\tret = -ENOMEM;\n\t\tgoto error_alloc;\n\t}\n\n\tcomp = devm_kzalloc(&pdev->dev, 6 * sizeof(*comp), GFP_KERNEL);\n\tif (!comp) {\n\t\tret = -ENOMEM;\n\t\tgoto error_alloc;\n\t}\n\n\tmachine_data->dai[0].cpus\t= &comp[0];\n\tmachine_data->dai[0].codecs\t= &comp[1];\n\tmachine_data->dai[0].platforms\t= &comp[2];\n\n\tmachine_data->dai[0].num_cpus\t\t= 1;\n\tmachine_data->dai[0].num_codecs\t\t= 1;\n\tmachine_data->dai[0].num_platforms\t= 1;\n\n\tmachine_data->dai[1].cpus\t= &comp[3];\n\tmachine_data->dai[1].codecs\t= &comp[4];\n\tmachine_data->dai[1].platforms\t= &comp[5];\n\n\tmachine_data->dai[1].num_cpus\t\t= 1;\n\tmachine_data->dai[1].num_codecs\t\t= 1;\n\tmachine_data->dai[1].num_platforms\t= 1;\n\n\tmachine_data->dai[0].cpus->dai_name = dev_name(&ssi_pdev->dev);\n\tmachine_data->dai[0].ops = &mpc8610_hpcd_ops;\n\n\t \n\tmachine_data->dai[0].codecs->of_node = codec_np;\n\n\t \n\tmachine_data->dai[0].codecs->dai_name = \"cs4270-hifi\";\n\n\t \n\tmemcpy(&machine_data->dai[1], &machine_data->dai[0],\n\t       sizeof(struct snd_soc_dai_link));\n\n\t \n\tiprop = of_get_property(np, \"cell-index\", NULL);\n\tif (!iprop) {\n\t\tdev_err(&pdev->dev, \"cell-index property not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\tmachine_data->ssi_id = be32_to_cpup(iprop);\n\n\t \n\tsprop = of_get_property(np, \"fsl,mode\", NULL);\n\tif (!sprop) {\n\t\tdev_err(&pdev->dev, \"fsl,mode property not found\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (strcasecmp(sprop, \"i2s-slave\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\n\t\t \n\t\tiprop = of_get_property(codec_np, \"clock-frequency\", NULL);\n\t\tif (!iprop || !*iprop) {\n\t\t\tdev_err(&pdev->dev, \"codec bus-frequency \"\n\t\t\t\t\"property is missing or invalid\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tmachine_data->clk_frequency = be32_to_cpup(iprop);\n\t} else if (strcasecmp(sprop, \"i2s-master\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"lj-slave\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"lj-master\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"rj-slave\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"rj-master\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else if (strcasecmp(sprop, \"ac97-slave\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_AC97 | SND_SOC_DAIFMT_CBP_CFP;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;\n\t} else if (strcasecmp(sprop, \"ac97-master\") == 0) {\n\t\tmachine_data->dai_format =\n\t\t\tSND_SOC_DAIFMT_AC97 | SND_SOC_DAIFMT_CBC_CFC;\n\t\tmachine_data->codec_clk_direction = SND_SOC_CLOCK_IN;\n\t\tmachine_data->cpu_clk_direction = SND_SOC_CLOCK_OUT;\n\t} else {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"unrecognized fsl,mode property '%s'\\n\", sprop);\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (!machine_data->clk_frequency) {\n\t\tdev_err(&pdev->dev, \"unknown clock frequency\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\tmachine_data->dai[0].platforms->name = machine_data->platform_name[0];\n\tret = fsl_asoc_get_dma_channel(np, \"fsl,playback-dma\",\n\t\t\t\t       &machine_data->dai[0],\n\t\t\t\t       &machine_data->dma_channel_id[0],\n\t\t\t\t       &machine_data->dma_id[0]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing/invalid playback DMA phandle\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmachine_data->dai[1].platforms->name = machine_data->platform_name[1];\n\tret = fsl_asoc_get_dma_channel(np, \"fsl,capture-dma\",\n\t\t\t\t       &machine_data->dai[1],\n\t\t\t\t       &machine_data->dma_channel_id[1],\n\t\t\t\t       &machine_data->dma_id[1]);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing/invalid capture DMA phandle\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tmachine_data->dai[0].stream_name = \"playback\";\n\tmachine_data->dai[1].stream_name = \"capture\";\n\tmachine_data->dai[0].name = machine_data->dai[0].stream_name;\n\tmachine_data->dai[1].name = machine_data->dai[1].stream_name;\n\n\tmachine_data->card.probe = mpc8610_hpcd_machine_probe;\n\tmachine_data->card.remove = mpc8610_hpcd_machine_remove;\n\tmachine_data->card.name = pdev->name;  \n\tmachine_data->card.owner = THIS_MODULE;\n\tmachine_data->card.dev = &pdev->dev;\n\tmachine_data->card.num_links = 2;\n\tmachine_data->card.dai_link = machine_data->dai;\n\n\t \n\tret = snd_soc_register_card(&machine_data->card);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register card\\n\");\n\t\tgoto error;\n\t}\n\n\tof_node_put(codec_np);\n\n\treturn 0;\n\nerror:\n\tkfree(machine_data);\nerror_alloc:\n\tof_node_put(codec_np);\n\treturn ret;\n}\n\n \nstatic void mpc8610_hpcd_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\tstruct mpc8610_hpcd_data *machine_data =\n\t\tcontainer_of(card, struct mpc8610_hpcd_data, card);\n\n\tsnd_soc_unregister_card(card);\n\tkfree(machine_data);\n}\n\nstatic struct platform_driver mpc8610_hpcd_driver = {\n\t.probe = mpc8610_hpcd_probe,\n\t.remove_new = mpc8610_hpcd_remove,\n\t.driver = {\n\t\t \n\t\t.name = \"snd-soc-mpc8610hpcd\",\n\t},\n};\n\n \nstatic int __init mpc8610_hpcd_init(void)\n{\n\tstruct device_node *guts_np;\n\tstruct resource res;\n\n\tpr_info(\"Freescale MPC8610 HPCD ALSA SoC machine driver\\n\");\n\n\t \n\tguts_np = of_find_compatible_node(NULL, NULL, \"fsl,mpc8610-guts\");\n\tif (of_address_to_resource(guts_np, 0, &res)) {\n\t\tpr_err(\"mpc8610-hpcd: missing/invalid global utilities node\\n\");\n\t\tof_node_put(guts_np);\n\t\treturn -EINVAL;\n\t}\n\tguts_phys = res.start;\n\tof_node_put(guts_np);\n\n\treturn platform_driver_register(&mpc8610_hpcd_driver);\n}\n\n \nstatic void __exit mpc8610_hpcd_exit(void)\n{\n\tplatform_driver_unregister(&mpc8610_hpcd_driver);\n}\n\nmodule_init(mpc8610_hpcd_init);\nmodule_exit(mpc8610_hpcd_exit);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale MPC8610 HPCD ALSA SoC machine driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}