{
  "module_name": "fsl_mqs.c",
  "hash_id": "9d3b2d76393edae22b352bf05f8e1839866571c3b0d7fee7b5b11a38b6f1f6b4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/fsl/fsl_mqs.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n\n#define REG_MQS_CTRL\t\t0x00\n\n#define MQS_EN_MASK\t\t\t(0x1 << 28)\n#define MQS_EN_SHIFT\t\t\t(28)\n#define MQS_SW_RST_MASK\t\t\t(0x1 << 24)\n#define MQS_SW_RST_SHIFT\t\t(24)\n#define MQS_OVERSAMPLE_MASK\t\t(0x1 << 20)\n#define MQS_OVERSAMPLE_SHIFT\t\t(20)\n#define MQS_CLK_DIV_MASK\t\t(0xFF << 0)\n#define MQS_CLK_DIV_SHIFT\t\t(0)\n\n \nstruct fsl_mqs_soc_data {\n\tbool use_gpr;\n\tint  ctrl_off;\n\tint  en_mask;\n\tint  en_shift;\n\tint  rst_mask;\n\tint  rst_shift;\n\tint  osr_mask;\n\tint  osr_shift;\n\tint  div_mask;\n\tint  div_shift;\n};\n\n \nstruct fsl_mqs {\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\tstruct clk *ipg;\n\tconst struct fsl_mqs_soc_data *soc;\n\n\tunsigned int reg_mqs_ctrl;\n};\n\n#define FSL_MQS_RATES\t(SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define FSL_MQS_FORMATS\tSNDRV_PCM_FMTBIT_S16_LE\n\nstatic int fsl_mqs_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct fsl_mqs *mqs_priv = snd_soc_component_get_drvdata(component);\n\tunsigned long mclk_rate;\n\tint div, res;\n\tint lrclk;\n\n\tmclk_rate = clk_get_rate(mqs_priv->mclk);\n\tlrclk = params_rate(params);\n\n\t \n\tdiv = mclk_rate / (32 * lrclk * 2 * 8);\n\tres = mclk_rate % (32 * lrclk * 2 * 8);\n\n\tif (res == 0 && div > 0 && div <= 256) {\n\t\tregmap_update_bits(mqs_priv->regmap, mqs_priv->soc->ctrl_off,\n\t\t\t\t   mqs_priv->soc->div_mask,\n\t\t\t\t   (div - 1) << mqs_priv->soc->div_shift);\n\t\tregmap_update_bits(mqs_priv->regmap, mqs_priv->soc->ctrl_off,\n\t\t\t\t   mqs_priv->soc->osr_mask, 0);\n\t} else {\n\t\tdev_err(component->dev, \"can't get proper divider\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_mqs_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int fsl_mqs_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct fsl_mqs *mqs_priv = snd_soc_component_get_drvdata(component);\n\n\tregmap_update_bits(mqs_priv->regmap, mqs_priv->soc->ctrl_off,\n\t\t\t   mqs_priv->soc->en_mask,\n\t\t\t   1 << mqs_priv->soc->en_shift);\n\treturn 0;\n}\n\nstatic void fsl_mqs_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct fsl_mqs *mqs_priv = snd_soc_component_get_drvdata(component);\n\n\tregmap_update_bits(mqs_priv->regmap, mqs_priv->soc->ctrl_off,\n\t\t\t   mqs_priv->soc->en_mask, 0);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_fsl_mqs = {\n\t.idle_bias_on = 1,\n};\n\nstatic const struct snd_soc_dai_ops fsl_mqs_dai_ops = {\n\t.startup = fsl_mqs_startup,\n\t.shutdown = fsl_mqs_shutdown,\n\t.hw_params = fsl_mqs_hw_params,\n\t.set_fmt = fsl_mqs_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver fsl_mqs_dai = {\n\t.name\t\t= \"fsl-mqs-dai\",\n\t.playback\t= {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= FSL_MQS_RATES,\n\t\t.formats\t= FSL_MQS_FORMATS,\n\t},\n\t.ops = &fsl_mqs_dai_ops,\n};\n\nstatic const struct regmap_config fsl_mqs_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = REG_MQS_CTRL,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int fsl_mqs_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *gpr_np = NULL;\n\tstruct fsl_mqs *mqs_priv;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tmqs_priv = devm_kzalloc(&pdev->dev, sizeof(*mqs_priv), GFP_KERNEL);\n\tif (!mqs_priv)\n\t\treturn -ENOMEM;\n\n\t \n\tmqs_priv->soc = of_device_get_match_data(&pdev->dev);\n\n\tif (mqs_priv->soc->use_gpr) {\n\t\tgpr_np = of_parse_phandle(np, \"gpr\", 0);\n\t\tif (!gpr_np) {\n\t\t\tdev_err(&pdev->dev, \"failed to get gpr node by phandle\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmqs_priv->regmap = syscon_node_to_regmap(gpr_np);\n\t\tof_node_put(gpr_np);\n\t\tif (IS_ERR(mqs_priv->regmap)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get gpr regmap\\n\");\n\t\t\treturn PTR_ERR(mqs_priv->regmap);\n\t\t}\n\t} else {\n\t\tregs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(regs))\n\t\t\treturn PTR_ERR(regs);\n\n\t\tmqs_priv->regmap = devm_regmap_init_mmio_clk(&pdev->dev,\n\t\t\t\t\t\t\t     \"core\",\n\t\t\t\t\t\t\t     regs,\n\t\t\t\t\t\t\t     &fsl_mqs_regmap_config);\n\t\tif (IS_ERR(mqs_priv->regmap)) {\n\t\t\tdev_err(&pdev->dev, \"failed to init regmap: %ld\\n\",\n\t\t\t\tPTR_ERR(mqs_priv->regmap));\n\t\t\treturn PTR_ERR(mqs_priv->regmap);\n\t\t}\n\n\t\tmqs_priv->ipg = devm_clk_get(&pdev->dev, \"core\");\n\t\tif (IS_ERR(mqs_priv->ipg)) {\n\t\t\tdev_err(&pdev->dev, \"failed to get the clock: %ld\\n\",\n\t\t\t\tPTR_ERR(mqs_priv->ipg));\n\t\t\treturn PTR_ERR(mqs_priv->ipg);\n\t\t}\n\t}\n\n\tmqs_priv->mclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(mqs_priv->mclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get the clock: %ld\\n\",\n\t\t\tPTR_ERR(mqs_priv->mclk));\n\t\treturn PTR_ERR(mqs_priv->mclk);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, mqs_priv);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_fsl_mqs,\n\t\t\t&fsl_mqs_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void fsl_mqs_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int fsl_mqs_runtime_resume(struct device *dev)\n{\n\tstruct fsl_mqs *mqs_priv = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(mqs_priv->ipg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable ipg clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(mqs_priv->mclk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable mclk clock\\n\");\n\t\tclk_disable_unprepare(mqs_priv->ipg);\n\t\treturn ret;\n\t}\n\n\tregmap_write(mqs_priv->regmap, mqs_priv->soc->ctrl_off, mqs_priv->reg_mqs_ctrl);\n\treturn 0;\n}\n\nstatic int fsl_mqs_runtime_suspend(struct device *dev)\n{\n\tstruct fsl_mqs *mqs_priv = dev_get_drvdata(dev);\n\n\tregmap_read(mqs_priv->regmap, mqs_priv->soc->ctrl_off, &mqs_priv->reg_mqs_ctrl);\n\n\tclk_disable_unprepare(mqs_priv->mclk);\n\tclk_disable_unprepare(mqs_priv->ipg);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops fsl_mqs_pm_ops = {\n\tSET_RUNTIME_PM_OPS(fsl_mqs_runtime_suspend,\n\t\t\t   fsl_mqs_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct fsl_mqs_soc_data fsl_mqs_imx8qm_data = {\n\t.use_gpr = false,\n\t.ctrl_off = REG_MQS_CTRL,\n\t.en_mask  = MQS_EN_MASK,\n\t.en_shift = MQS_EN_SHIFT,\n\t.rst_mask = MQS_SW_RST_MASK,\n\t.rst_shift = MQS_SW_RST_SHIFT,\n\t.osr_mask = MQS_OVERSAMPLE_MASK,\n\t.osr_shift = MQS_OVERSAMPLE_SHIFT,\n\t.div_mask = MQS_CLK_DIV_MASK,\n\t.div_shift = MQS_CLK_DIV_SHIFT,\n};\n\nstatic const struct fsl_mqs_soc_data fsl_mqs_imx6sx_data = {\n\t.use_gpr = true,\n\t.ctrl_off = IOMUXC_GPR2,\n\t.en_mask  = IMX6SX_GPR2_MQS_EN_MASK,\n\t.en_shift = IMX6SX_GPR2_MQS_EN_SHIFT,\n\t.rst_mask = IMX6SX_GPR2_MQS_SW_RST_MASK,\n\t.rst_shift = IMX6SX_GPR2_MQS_SW_RST_SHIFT,\n\t.osr_mask  = IMX6SX_GPR2_MQS_OVERSAMPLE_MASK,\n\t.osr_shift = IMX6SX_GPR2_MQS_OVERSAMPLE_SHIFT,\n\t.div_mask  = IMX6SX_GPR2_MQS_CLK_DIV_MASK,\n\t.div_shift = IMX6SX_GPR2_MQS_CLK_DIV_SHIFT,\n};\n\nstatic const struct fsl_mqs_soc_data fsl_mqs_imx93_data = {\n\t.use_gpr = true,\n\t.ctrl_off = 0x20,\n\t.en_mask  = BIT(1),\n\t.en_shift = 1,\n\t.rst_mask = BIT(2),\n\t.rst_shift = 2,\n\t.osr_mask = BIT(3),\n\t.osr_shift = 3,\n\t.div_mask = GENMASK(15, 8),\n\t.div_shift = 8,\n};\n\nstatic const struct of_device_id fsl_mqs_dt_ids[] = {\n\t{ .compatible = \"fsl,imx8qm-mqs\", .data = &fsl_mqs_imx8qm_data },\n\t{ .compatible = \"fsl,imx6sx-mqs\", .data = &fsl_mqs_imx6sx_data },\n\t{ .compatible = \"fsl,imx93-mqs\", .data = &fsl_mqs_imx93_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, fsl_mqs_dt_ids);\n\nstatic struct platform_driver fsl_mqs_driver = {\n\t.probe\t\t= fsl_mqs_probe,\n\t.remove_new\t= fsl_mqs_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"fsl-mqs\",\n\t\t.of_match_table = fsl_mqs_dt_ids,\n\t\t.pm = &fsl_mqs_pm_ops,\n\t},\n};\n\nmodule_platform_driver(fsl_mqs_driver);\n\nMODULE_AUTHOR(\"Shengjiu Wang <Shengjiu.Wang@nxp.com>\");\nMODULE_DESCRIPTION(\"MQS codec driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:fsl-mqs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}