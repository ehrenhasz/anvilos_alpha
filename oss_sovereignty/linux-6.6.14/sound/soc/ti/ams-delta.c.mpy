{
  "module_name": "ams-delta.c",
  "hash_id": "ec3de29468264d61d408de192d4d496774fac05d30631bc6c32fc4e81a97aed5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/ams-delta.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/spinlock.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n\n#include <sound/soc.h>\n#include <sound/jack.h>\n\n#include <asm/mach-types.h>\n\n#include <linux/platform_data/asoc-ti-mcbsp.h>\n\n#include \"omap-mcbsp.h\"\n#include \"../codecs/cx20442.h\"\n\nstatic struct gpio_desc *handset_mute;\nstatic struct gpio_desc *handsfree_mute;\n\nstatic int ams_delta_event_handset(struct snd_soc_dapm_widget *w,\n\t\t\t\t   struct snd_kcontrol *k, int event)\n{\n\tgpiod_set_value_cansleep(handset_mute, !SND_SOC_DAPM_EVENT_ON(event));\n\treturn 0;\n}\n\nstatic int ams_delta_event_handsfree(struct snd_soc_dapm_widget *w,\n\t\t\t\t     struct snd_kcontrol *k, int event)\n{\n\tgpiod_set_value_cansleep(handsfree_mute, !SND_SOC_DAPM_EVENT_ON(event));\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_dapm_widget ams_delta_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_MIC(\"Mouthpiece\", NULL),\n\tSND_SOC_DAPM_HP(\"Earpiece\", ams_delta_event_handset),\n\t \n\tSND_SOC_DAPM_MIC(\"Microphone\", NULL),\n\tSND_SOC_DAPM_SPK(\"Speaker\", ams_delta_event_handsfree),\n};\n\n \nstatic const struct snd_soc_dapm_route ams_delta_audio_map[] = {\n\t{\"TELIN\", NULL, \"Mouthpiece\"},\n\t{\"Earpiece\", NULL, \"TELOUT\"},\n\n\t{\"MIC\", NULL, \"Microphone\"},\n\t{\"Speaker\", NULL, \"SPKOUT\"},\n};\n\n \n\n \nstatic const char *ams_delta_audio_mode[] =\n\t{\"Mixed\", \"Handset\", \"Handsfree\", \"Speakerphone\"};\n\n \n#define AMS_DELTA_MOUTHPIECE\t0\n#define AMS_DELTA_EARPIECE\t1\n#define AMS_DELTA_MICROPHONE\t2\n#define AMS_DELTA_SPEAKER\t3\n#define AMS_DELTA_AGC\t\t4\n\n#define AMS_DELTA_MIXED\t\t((1 << AMS_DELTA_EARPIECE) | \\\n\t\t\t\t\t\t(1 << AMS_DELTA_MICROPHONE))\n#define AMS_DELTA_HANDSET\t((1 << AMS_DELTA_MOUTHPIECE) | \\\n\t\t\t\t\t\t(1 << AMS_DELTA_EARPIECE))\n#define AMS_DELTA_HANDSFREE\t((1 << AMS_DELTA_MICROPHONE) | \\\n\t\t\t\t\t\t(1 << AMS_DELTA_SPEAKER))\n#define AMS_DELTA_SPEAKERPHONE\t(AMS_DELTA_HANDSFREE | (1 << AMS_DELTA_AGC))\n\nstatic const unsigned short ams_delta_audio_mode_pins[] = {\n\tAMS_DELTA_MIXED,\n\tAMS_DELTA_HANDSET,\n\tAMS_DELTA_HANDSFREE,\n\tAMS_DELTA_SPEAKERPHONE,\n};\n\nstatic unsigned short ams_delta_audio_agc;\n\n \nstatic struct snd_soc_component *cx20442_codec;\n\nstatic int ams_delta_set_audio_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = &card->dapm;\n\tstruct soc_enum *control = (struct soc_enum *)kcontrol->private_value;\n\tunsigned short pins;\n\tint pin, changed = 0;\n\n\t \n\tif (!cx20442_codec->card->pop_time)\n\t\treturn -EUNATCH;\n\n\tif (ucontrol->value.enumerated.item[0] >= control->items)\n\t\treturn -EINVAL;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\t \n\tpins = ams_delta_audio_mode_pins[ucontrol->value.enumerated.item[0]];\n\n\t \n\tpin = !!(pins & (1 << AMS_DELTA_MOUTHPIECE));\n\n\tif (pin != snd_soc_dapm_get_pin_status(dapm, \"Mouthpiece\")) {\n\t\tchanged = 1;\n\t\tif (pin)\n\t\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Mouthpiece\");\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Mouthpiece\");\n\t}\n\tpin = !!(pins & (1 << AMS_DELTA_EARPIECE));\n\tif (pin != snd_soc_dapm_get_pin_status(dapm, \"Earpiece\")) {\n\t\tchanged = 1;\n\t\tif (pin)\n\t\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Earpiece\");\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Earpiece\");\n\t}\n\tpin = !!(pins & (1 << AMS_DELTA_MICROPHONE));\n\tif (pin != snd_soc_dapm_get_pin_status(dapm, \"Microphone\")) {\n\t\tchanged = 1;\n\t\tif (pin)\n\t\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Microphone\");\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Microphone\");\n\t}\n\tpin = !!(pins & (1 << AMS_DELTA_SPEAKER));\n\tif (pin != snd_soc_dapm_get_pin_status(dapm, \"Speaker\")) {\n\t\tchanged = 1;\n\t\tif (pin)\n\t\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Speaker\");\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Speaker\");\n\t}\n\tpin = !!(pins & (1 << AMS_DELTA_AGC));\n\tif (pin != ams_delta_audio_agc) {\n\t\tams_delta_audio_agc = pin;\n\t\tchanged = 1;\n\t\tif (pin)\n\t\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"AGCIN\");\n\t\telse\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"AGCIN\");\n\t}\n\n\tif (changed)\n\t\tsnd_soc_dapm_sync_unlocked(dapm);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn changed;\n}\n\nstatic int ams_delta_get_audio_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = &card->dapm;\n\tunsigned short pins, mode;\n\n\tpins = ((snd_soc_dapm_get_pin_status(dapm, \"Mouthpiece\") <<\n\t\t\t\t\t\t\tAMS_DELTA_MOUTHPIECE) |\n\t\t\t(snd_soc_dapm_get_pin_status(dapm, \"Earpiece\") <<\n\t\t\t\t\t\t\tAMS_DELTA_EARPIECE));\n\tif (pins)\n\t\tpins |= (snd_soc_dapm_get_pin_status(dapm, \"Microphone\") <<\n\t\t\t\t\t\t\tAMS_DELTA_MICROPHONE);\n\telse\n\t\tpins = ((snd_soc_dapm_get_pin_status(dapm, \"Microphone\") <<\n\t\t\t\t\t\t\tAMS_DELTA_MICROPHONE) |\n\t\t\t(snd_soc_dapm_get_pin_status(dapm, \"Speaker\") <<\n\t\t\t\t\t\t\tAMS_DELTA_SPEAKER) |\n\t\t\t(ams_delta_audio_agc << AMS_DELTA_AGC));\n\n\tfor (mode = 0; mode < ARRAY_SIZE(ams_delta_audio_mode); mode++)\n\t\tif (pins == ams_delta_audio_mode_pins[mode])\n\t\t\tbreak;\n\n\tif (mode >= ARRAY_SIZE(ams_delta_audio_mode))\n\t\treturn -EINVAL;\n\n\tucontrol->value.enumerated.item[0] = mode;\n\n\treturn 0;\n}\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(ams_delta_audio_enum,\n\t\t\t\t      ams_delta_audio_mode);\n\nstatic const struct snd_kcontrol_new ams_delta_audio_controls[] = {\n\tSOC_ENUM_EXT(\"Audio Mode\", ams_delta_audio_enum,\n\t\t\tams_delta_get_audio_mode, ams_delta_set_audio_mode),\n};\n\n \nstatic struct snd_soc_jack ams_delta_hook_switch;\nstatic struct snd_soc_jack_gpio ams_delta_hook_switch_gpios[] = {\n\t{\n\t\t.name = \"hook_switch\",\n\t\t.report = SND_JACK_HEADSET,\n\t\t.invert = 1,\n\t\t.debounce_time = 150,\n\t}\n};\n\n \nstatic struct snd_soc_jack_pin ams_delta_hook_switch_pins[] = {\n\t \n\t{\n\t\t.pin = \"Mouthpiece\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n\t{\n\t\t.pin = \"Earpiece\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n\t \n\t{\n\t\t.pin = \"Microphone\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t\t.invert = 1,\n\t},\n\t{\n\t\t.pin = \"Speaker\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t\t.invert = 1,\n\t},\n};\n\n\n \n\n \nstatic struct timer_list cx81801_timer;\nstatic bool cx81801_cmd_pending;\nstatic bool ams_delta_muted;\nstatic DEFINE_SPINLOCK(ams_delta_lock);\nstatic struct gpio_desc *gpiod_modem_codec;\n\nstatic void cx81801_timeout(struct timer_list *unused)\n{\n\tint muted;\n\n\tspin_lock(&ams_delta_lock);\n\tcx81801_cmd_pending = 0;\n\tmuted = ams_delta_muted;\n\tspin_unlock(&ams_delta_lock);\n\n\t \n\tif (!muted)\n\t\tgpiod_set_value(gpiod_modem_codec, 0);\n}\n\n \nstatic int cx81801_open(struct tty_struct *tty)\n{\n\tint ret;\n\n\tif (!cx20442_codec)\n\t\treturn -ENODEV;\n\n\t \n\ttty->disc_data = cx20442_codec;\n\n\tret = v253_ops.open(tty);\n\n\tif (ret < 0)\n\t\ttty->disc_data = NULL;\n\n\treturn ret;\n}\n\n \nstatic void cx81801_close(struct tty_struct *tty)\n{\n\tstruct snd_soc_component *component = tty->disc_data;\n\tstruct snd_soc_dapm_context *dapm;\n\n\tdel_timer_sync(&cx81801_timer);\n\n\t \n\tINIT_LIST_HEAD(&ams_delta_hook_switch.pins);\n\n\tif (!component)\n\t\treturn;\n\n\tv253_ops.close(tty);\n\n\tdapm = &component->card->dapm;\n\n\t \n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Mouthpiece\");\n\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Earpiece\");\n\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Microphone\");\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Speaker\");\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"AGCIN\");\n\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\n \nstatic void cx81801_hangup(struct tty_struct *tty)\n{\n\tcx81801_close(tty);\n}\n\n \nstatic void cx81801_receive(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t\t    size_t count)\n{\n\tstruct snd_soc_component *component = tty->disc_data;\n\tconst unsigned char *c;\n\tint apply, ret;\n\n\tif (!component)\n\t\treturn;\n\n\tif (!component->card->pop_time) {\n\t\t \n\n\t\t \n\t\ttimer_setup(&cx81801_timer, cx81801_timeout, 0);\n\n\t\tv253_ops.receive_buf(tty, cp, fp, count);\n\n\t\t \n\t\tret = snd_soc_jack_add_pins(&ams_delta_hook_switch,\n\t\t\t\t\tARRAY_SIZE(ams_delta_hook_switch_pins),\n\t\t\t\t\tams_delta_hook_switch_pins);\n\t\tif (ret)\n\t\t\tdev_warn(component->dev,\n\t\t\t\t\"Failed to link hook switch to DAPM pins, \"\n\t\t\t\t\"will continue with hook switch unlinked.\\n\");\n\n\t\treturn;\n\t}\n\n\tv253_ops.receive_buf(tty, cp, fp, count);\n\n\tfor (c = &cp[count - 1]; c >= cp; c--) {\n\t\tif (*c != '\\r')\n\t\t\tcontinue;\n\t\t \n\n\t\tspin_lock_bh(&ams_delta_lock);\n\t\tmod_timer(&cx81801_timer, jiffies + msecs_to_jiffies(150));\n\t\tapply = !ams_delta_muted && !cx81801_cmd_pending;\n\t\tcx81801_cmd_pending = 1;\n\t\tspin_unlock_bh(&ams_delta_lock);\n\n\t\t \n\t\tif (apply)\n\t\t\tgpiod_set_value(gpiod_modem_codec, 1);\n\t\tbreak;\n\t}\n}\n\n \nstatic void cx81801_wakeup(struct tty_struct *tty)\n{\n\tv253_ops.write_wakeup(tty);\n}\n\nstatic struct tty_ldisc_ops cx81801_ops = {\n\t.name = \"cx81801\",\n\t.num = N_V253,\n\t.owner = THIS_MODULE,\n\t.open = cx81801_open,\n\t.close = cx81801_close,\n\t.hangup = cx81801_hangup,\n\t.receive_buf = cx81801_receive,\n\t.write_wakeup = cx81801_wakeup,\n};\n\n\n \n\nstatic struct snd_soc_ops ams_delta_ops;\n\n\n \nstatic bool ams_delta_muted = 1;\n\nstatic int ams_delta_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tint apply;\n\n\tif (ams_delta_muted == mute)\n\t\treturn 0;\n\n\tspin_lock_bh(&ams_delta_lock);\n\tams_delta_muted = mute;\n\tapply = !cx81801_cmd_pending;\n\tspin_unlock_bh(&ams_delta_lock);\n\n\tif (apply)\n\t\tgpiod_set_value(gpiod_modem_codec, !!mute);\n\treturn 0;\n}\n\n \nstatic const struct snd_soc_dai_ops ams_delta_dai_ops = {\n\t.mute_stream = ams_delta_mute,\n\t.no_capture_mute = 1,\n};\n\n \nstatic int ams_delta_startup(struct snd_pcm_substream *substream)\n{\n\treturn ams_delta_mute(NULL, 0, substream->stream);\n}\n\nstatic void ams_delta_shutdown(struct snd_pcm_substream *substream)\n{\n\tams_delta_mute(NULL, 1, substream->stream);\n}\n\n\n \n\nstatic int ams_delta_cx20442_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct snd_soc_dapm_context *dapm = &card->dapm;\n\tint ret;\n\t \n\n\t \n\tcx20442_codec = asoc_rtd_to_codec(rtd, 0)->component;\n\n\t \n\tret = snd_soc_card_jack_new_pins(card, \"hook_switch\", SND_JACK_HEADSET,\n\t\t\t\t\t &ams_delta_hook_switch, NULL, 0);\n\tif (ret)\n\t\tdev_warn(card->dev,\n\t\t\t\t\"Failed to allocate resources for hook switch, \"\n\t\t\t\t\"will continue without one.\\n\");\n\telse {\n\t\tret = snd_soc_jack_add_gpiods(card->dev, &ams_delta_hook_switch,\n\t\t\t\t\tARRAY_SIZE(ams_delta_hook_switch_gpios),\n\t\t\t\t\tams_delta_hook_switch_gpios);\n\t\tif (ret)\n\t\t\tdev_warn(card->dev,\n\t\t\t\t\"Failed to set up hook switch GPIO line, \"\n\t\t\t\t\"will continue with hook switch inactive.\\n\");\n\t}\n\n\tgpiod_modem_codec = devm_gpiod_get(card->dev, \"modem_codec\",\n\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpiod_modem_codec)) {\n\t\tdev_warn(card->dev, \"Failed to obtain modem_codec GPIO\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!codec_dai->driver->ops) {\n\t\tcodec_dai->driver->ops = &ams_delta_dai_ops;\n\t} else {\n\t\tams_delta_ops.startup = ams_delta_startup;\n\t\tams_delta_ops.shutdown = ams_delta_shutdown;\n\t}\n\n\t \n\tret = tty_register_ldisc(&cx81801_ops);\n\tif (ret) {\n\t\tdev_warn(card->dev,\n\t\t\t\t\"Failed to register line discipline, \"\n\t\t\t\t\"will continue without any controls.\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tsnd_soc_dapm_disable_pin(dapm, \"Mouthpiece\");\n\tsnd_soc_dapm_disable_pin(dapm, \"Speaker\");\n\tsnd_soc_dapm_disable_pin(dapm, \"AGCIN\");\n\tsnd_soc_dapm_disable_pin(dapm, \"AGCOUT\");\n\n\treturn 0;\n}\n\n \nSND_SOC_DAILINK_DEFS(cx20442,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"omap-mcbsp.1\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"cx20442-codec\", \"cx20442-voice\")),\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"omap-mcbsp.1\")));\n\nstatic struct snd_soc_dai_link ams_delta_dai_link = {\n\t.name = \"CX20442\",\n\t.stream_name = \"CX20442\",\n\t.init = ams_delta_cx20442_init,\n\t.ops = &ams_delta_ops,\n\t.dai_fmt = SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBM_CFM,\n\tSND_SOC_DAILINK_REG(cx20442),\n};\n\n \nstatic struct snd_soc_card ams_delta_audio_card = {\n\t.name = \"AMS_DELTA\",\n\t.owner = THIS_MODULE,\n\t.dai_link = &ams_delta_dai_link,\n\t.num_links = 1,\n\n\t.controls = ams_delta_audio_controls,\n\t.num_controls = ARRAY_SIZE(ams_delta_audio_controls),\n\t.dapm_widgets = ams_delta_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(ams_delta_dapm_widgets),\n\t.dapm_routes = ams_delta_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(ams_delta_audio_map),\n};\n\n \nstatic int ams_delta_probe(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = &ams_delta_audio_card;\n\tint ret;\n\n\tcard->dev = &pdev->dev;\n\n\thandset_mute = devm_gpiod_get(card->dev, \"handset_mute\",\n\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(handset_mute))\n\t\treturn PTR_ERR(handset_mute);\n\n\thandsfree_mute = devm_gpiod_get(card->dev, \"handsfree_mute\",\n\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(handsfree_mute))\n\t\treturn PTR_ERR(handsfree_mute);\n\n\tret = snd_soc_register_card(card);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"snd_soc_register_card failed (%d)\\n\", ret);\n\t\tcard->dev = NULL;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void ams_delta_remove(struct platform_device *pdev)\n{\n\tstruct snd_soc_card *card = platform_get_drvdata(pdev);\n\n\ttty_unregister_ldisc(&cx81801_ops);\n\n\tsnd_soc_unregister_card(card);\n\tcard->dev = NULL;\n}\n\n#define DRV_NAME \"ams-delta-audio\"\n\nstatic struct platform_driver ams_delta_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = ams_delta_probe,\n\t.remove_new = ams_delta_remove,\n};\n\nmodule_platform_driver(ams_delta_driver);\n\nMODULE_AUTHOR(\"Janusz Krzysztofik <jkrzyszt@tis.icnet.pl>\");\nMODULE_DESCRIPTION(\"ALSA SoC driver for Amstrad E3 (Delta) videophone\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}