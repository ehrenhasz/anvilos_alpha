{
  "module_name": "j721e-evm.c",
  "hash_id": "a0f508053ee8dd417b79ef4b40871b0de9e8f34bd6b248a000ac6be2d9906981",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/j721e-evm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"davinci-mcasp.h\"\n\n \n#define J721E_CODEC_CONF_COUNT\t5\n\nenum j721e_audio_domain_id {\n\tJ721E_AUDIO_DOMAIN_CPB = 0,\n\tJ721E_AUDIO_DOMAIN_IVI,\n\tJ721E_AUDIO_DOMAIN_LAST,\n};\n\n#define J721E_CLK_PARENT_48000\t0\n#define J721E_CLK_PARENT_44100\t1\n\n#define J721E_MAX_CLK_HSDIV\t128\n#define PCM1368A_MAX_SYSCLK\t36864000\n\n#define J721E_DAI_FMT\t\t(SND_SOC_DAIFMT_RIGHT_J | \\\n\t\t\t\t SND_SOC_DAIFMT_NB_NF |   \\\n\t\t\t\t SND_SOC_DAIFMT_CBS_CFS)\n\nenum j721e_board_type {\n\tJ721E_BOARD_CPB = 1,\n\tJ721E_BOARD_CPB_IVI,\n};\n\nstruct j721e_audio_match_data {\n\tenum j721e_board_type board_type;\n\tint num_links;\n\tunsigned int pll_rates[2];\n};\n\nstatic unsigned int ratios_for_pcm3168a[] = {\n\t256,\n\t512,\n\t768,\n};\n\nstruct j721e_audio_clocks {\n\tstruct clk *target;\n\tstruct clk *parent[2];\n};\n\nstruct j721e_audio_domain {\n\tstruct j721e_audio_clocks codec;\n\tstruct j721e_audio_clocks mcasp;\n\tint parent_clk_id;\n\n\tint active;\n\tunsigned int active_link;\n\tunsigned int rate;\n};\n\nstruct j721e_priv {\n\tstruct device *dev;\n\tstruct snd_soc_card card;\n\tstruct snd_soc_dai_link *dai_links;\n\tstruct snd_soc_codec_conf codec_conf[J721E_CODEC_CONF_COUNT];\n\tstruct snd_interval rate_range;\n\tconst struct j721e_audio_match_data *match_data;\n\tu32 pll_rates[2];\n\tunsigned int hsdiv_rates[2];\n\n\tstruct j721e_audio_domain audio_domains[J721E_AUDIO_DOMAIN_LAST];\n\n\tstruct mutex mutex;\n};\n\nstatic const struct snd_soc_dapm_widget j721e_cpb_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"CPB Stereo HP 1\", NULL),\n\tSND_SOC_DAPM_HP(\"CPB Stereo HP 2\", NULL),\n\tSND_SOC_DAPM_HP(\"CPB Stereo HP 3\", NULL),\n\tSND_SOC_DAPM_LINE(\"CPB Line Out\", NULL),\n\tSND_SOC_DAPM_MIC(\"CPB Stereo Mic 1\", NULL),\n\tSND_SOC_DAPM_MIC(\"CPB Stereo Mic 2\", NULL),\n\tSND_SOC_DAPM_LINE(\"CPB Line In\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route j721e_cpb_dapm_routes[] = {\n\t{\"CPB Stereo HP 1\", NULL, \"codec-1 AOUT1L\"},\n\t{\"CPB Stereo HP 1\", NULL, \"codec-1 AOUT1R\"},\n\t{\"CPB Stereo HP 2\", NULL, \"codec-1 AOUT2L\"},\n\t{\"CPB Stereo HP 2\", NULL, \"codec-1 AOUT2R\"},\n\t{\"CPB Stereo HP 3\", NULL, \"codec-1 AOUT3L\"},\n\t{\"CPB Stereo HP 3\", NULL, \"codec-1 AOUT3R\"},\n\t{\"CPB Line Out\", NULL, \"codec-1 AOUT4L\"},\n\t{\"CPB Line Out\", NULL, \"codec-1 AOUT4R\"},\n\n\t{\"codec-1 AIN1L\", NULL, \"CPB Stereo Mic 1\"},\n\t{\"codec-1 AIN1R\", NULL, \"CPB Stereo Mic 1\"},\n\t{\"codec-1 AIN2L\", NULL, \"CPB Stereo Mic 2\"},\n\t{\"codec-1 AIN2R\", NULL, \"CPB Stereo Mic 2\"},\n\t{\"codec-1 AIN3L\", NULL, \"CPB Line In\"},\n\t{\"codec-1 AIN3R\", NULL, \"CPB Line In\"},\n};\n\nstatic const struct snd_soc_dapm_widget j721e_ivi_codec_a_dapm_widgets[] = {\n\tSND_SOC_DAPM_LINE(\"IVI A Line Out 1\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI A Line Out 2\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI A Line Out 3\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI A Line Out 4\", NULL),\n\tSND_SOC_DAPM_MIC(\"IVI A Stereo Mic 1\", NULL),\n\tSND_SOC_DAPM_MIC(\"IVI A Stereo Mic 2\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI A Line In\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route j721e_codec_a_dapm_routes[] = {\n\t{\"IVI A Line Out 1\", NULL, \"codec-a AOUT1L\"},\n\t{\"IVI A Line Out 1\", NULL, \"codec-a AOUT1R\"},\n\t{\"IVI A Line Out 2\", NULL, \"codec-a AOUT2L\"},\n\t{\"IVI A Line Out 2\", NULL, \"codec-a AOUT2R\"},\n\t{\"IVI A Line Out 3\", NULL, \"codec-a AOUT3L\"},\n\t{\"IVI A Line Out 3\", NULL, \"codec-a AOUT3R\"},\n\t{\"IVI A Line Out 4\", NULL, \"codec-a AOUT4L\"},\n\t{\"IVI A Line Out 4\", NULL, \"codec-a AOUT4R\"},\n\n\t{\"codec-a AIN1L\", NULL, \"IVI A Stereo Mic 1\"},\n\t{\"codec-a AIN1R\", NULL, \"IVI A Stereo Mic 1\"},\n\t{\"codec-a AIN2L\", NULL, \"IVI A Stereo Mic 2\"},\n\t{\"codec-a AIN2R\", NULL, \"IVI A Stereo Mic 2\"},\n\t{\"codec-a AIN3L\", NULL, \"IVI A Line In\"},\n\t{\"codec-a AIN3R\", NULL, \"IVI A Line In\"},\n};\n\nstatic const struct snd_soc_dapm_widget j721e_ivi_codec_b_dapm_widgets[] = {\n\tSND_SOC_DAPM_LINE(\"IVI B Line Out 1\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI B Line Out 2\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI B Line Out 3\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI B Line Out 4\", NULL),\n\tSND_SOC_DAPM_MIC(\"IVI B Stereo Mic 1\", NULL),\n\tSND_SOC_DAPM_MIC(\"IVI B Stereo Mic 2\", NULL),\n\tSND_SOC_DAPM_LINE(\"IVI B Line In\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route j721e_codec_b_dapm_routes[] = {\n\t{\"IVI B Line Out 1\", NULL, \"codec-b AOUT1L\"},\n\t{\"IVI B Line Out 1\", NULL, \"codec-b AOUT1R\"},\n\t{\"IVI B Line Out 2\", NULL, \"codec-b AOUT2L\"},\n\t{\"IVI B Line Out 2\", NULL, \"codec-b AOUT2R\"},\n\t{\"IVI B Line Out 3\", NULL, \"codec-b AOUT3L\"},\n\t{\"IVI B Line Out 3\", NULL, \"codec-b AOUT3R\"},\n\t{\"IVI B Line Out 4\", NULL, \"codec-b AOUT4L\"},\n\t{\"IVI B Line Out 4\", NULL, \"codec-b AOUT4R\"},\n\n\t{\"codec-b AIN1L\", NULL, \"IVI B Stereo Mic 1\"},\n\t{\"codec-b AIN1R\", NULL, \"IVI B Stereo Mic 1\"},\n\t{\"codec-b AIN2L\", NULL, \"IVI B Stereo Mic 2\"},\n\t{\"codec-b AIN2R\", NULL, \"IVI B Stereo Mic 2\"},\n\t{\"codec-b AIN3L\", NULL, \"IVI B Line In\"},\n\t{\"codec-b AIN3R\", NULL, \"IVI B Line In\"},\n};\n\nstatic int j721e_configure_refclk(struct j721e_priv *priv,\n\t\t\t\t  unsigned int audio_domain, unsigned int rate)\n{\n\tstruct j721e_audio_domain *domain = &priv->audio_domains[audio_domain];\n\tunsigned int scki;\n\tint ret = -EINVAL;\n\tint i, clk_id;\n\n\tif (!(rate % 8000) && priv->pll_rates[J721E_CLK_PARENT_48000])\n\t\tclk_id = J721E_CLK_PARENT_48000;\n\telse if (!(rate % 11025) && priv->pll_rates[J721E_CLK_PARENT_44100])\n\t\tclk_id = J721E_CLK_PARENT_44100;\n\telse\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ratios_for_pcm3168a); i++) {\n\t\tscki = ratios_for_pcm3168a[i] * rate;\n\n\t\tif (priv->pll_rates[clk_id] / scki <= J721E_MAX_CLK_HSDIV) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tdev_err(priv->dev, \"No valid clock configuration for %u Hz\\n\",\n\t\t\trate);\n\t\treturn ret;\n\t}\n\n\tif (domain->parent_clk_id == -1 || priv->hsdiv_rates[domain->parent_clk_id] != scki) {\n\t\tdev_dbg(priv->dev,\n\t\t\t\"domain%u configuration for %u Hz: %s, %dxFS (SCKI: %u Hz)\\n\",\n\t\t\taudio_domain, rate,\n\t\t\tclk_id == J721E_CLK_PARENT_48000 ? \"PLL4\" : \"PLL15\",\n\t\t\tratios_for_pcm3168a[i], scki);\n\n\t\tif (domain->parent_clk_id != clk_id) {\n\t\t\tret = clk_set_parent(domain->codec.target,\n\t\t\t\t\t     domain->codec.parent[clk_id]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = clk_set_parent(domain->mcasp.target,\n\t\t\t\t\t     domain->mcasp.parent[clk_id]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tdomain->parent_clk_id = clk_id;\n\t\t}\n\n\t\tret = clk_set_rate(domain->codec.target, scki);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"codec set rate failed for %u Hz\\n\",\n\t\t\t\tscki);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_set_rate(domain->mcasp.target, scki);\n\t\tif (!ret) {\n\t\t\tpriv->hsdiv_rates[domain->parent_clk_id] = scki;\n\t\t} else {\n\t\t\tdev_err(priv->dev, \"mcasp set rate failed for %u Hz\\n\",\n\t\t\t\tscki);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int j721e_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *t = rule->private;\n\n\treturn snd_interval_refine(hw_param_interval(params, rule->var), t);\n}\n\nstatic int j721e_audio_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct j721e_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tunsigned int domain_id = rtd->dai_link->id;\n\tstruct j721e_audio_domain *domain = &priv->audio_domains[domain_id];\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned int active_rate;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&priv->mutex);\n\n\tdomain->active++;\n\n\tfor (i = 0; i < J721E_AUDIO_DOMAIN_LAST; i++) {\n\t\tactive_rate = priv->audio_domains[i].rate;\n\t\tif (active_rate)\n\t\t\tbreak;\n\t}\n\n\tif (active_rate)\n\t\tret = snd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t   active_rate);\n\telse\n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  j721e_rule_rate, &priv->rate_range,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, 32);\n\tif (ret && ret != -ENOTSUPP)\n\t\tgoto out;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 2, 32);\n\t\tif (ret && ret != -ENOTSUPP)\n\t\t\tgoto out;\n\t}\n\n\tif (ret == -ENOTSUPP)\n\t\tret = 0;\nout:\n\tif (ret)\n\t\tdomain->active--;\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic int j721e_audio_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct j721e_priv *priv = snd_soc_card_get_drvdata(card);\n\tunsigned int domain_id = rtd->dai_link->id;\n\tstruct j721e_audio_domain *domain = &priv->audio_domains[domain_id];\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned int sysclk_rate;\n\tint slot_width = 32;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (domain->rate && domain->rate != params_rate(params)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (params_width(params) == 16)\n\t\tslot_width = 16;\n\n\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, slot_width);\n\tif (ret && ret != -ENOTSUPP)\n\t\tgoto out;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 2,\n\t\t\t\t\t       slot_width);\n\t\tif (ret && ret != -ENOTSUPP)\n\t\t\tgoto out;\n\t}\n\n\tret = j721e_configure_refclk(priv, domain_id, params_rate(params));\n\tif (ret)\n\t\tgoto out;\n\n\tsysclk_rate = priv->hsdiv_rates[domain->parent_clk_id];\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, 0, sysclk_rate,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret && ret != -ENOTSUPP) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"codec set_sysclk failed for %u Hz\\n\",\n\t\t\t\tsysclk_rate);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, MCASP_CLK_HCLK_AUXCLK,\n\t\t\t\t     sysclk_rate, SND_SOC_CLOCK_IN);\n\n\tif (ret && ret != -ENOTSUPP) {\n\t\tdev_err(priv->dev, \"mcasp set_sysclk failed for %u Hz\\n\",\n\t\t\tsysclk_rate);\n\t} else {\n\t\tdomain->rate = params_rate(params);\n\t\tret = 0;\n\t}\n\nout:\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic void j721e_audio_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct j721e_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tunsigned int domain_id = rtd->dai_link->id;\n\tstruct j721e_audio_domain *domain = &priv->audio_domains[domain_id];\n\n\tmutex_lock(&priv->mutex);\n\n\tdomain->active--;\n\tif (!domain->active) {\n\t\tdomain->rate = 0;\n\t\tdomain->active_link = 0;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic const struct snd_soc_ops j721e_audio_ops = {\n\t.startup = j721e_audio_startup,\n\t.hw_params = j721e_audio_hw_params,\n\t.shutdown = j721e_audio_shutdown,\n};\n\nstatic int j721e_audio_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct j721e_priv *priv = snd_soc_card_get_drvdata(rtd->card);\n\tunsigned int domain_id = rtd->dai_link->id;\n\tstruct j721e_audio_domain *domain = &priv->audio_domains[domain_id];\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_dai *codec_dai;\n\tunsigned int sysclk_rate;\n\tint i, ret;\n\n\t \n\tret = j721e_configure_refclk(priv, domain_id, 48000);\n\tif (ret)\n\t\treturn ret;\n\n\tsysclk_rate = priv->hsdiv_rates[domain->parent_clk_id];\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_sysclk(codec_dai, 0, sysclk_rate,\n\t\t\t\t\t     SND_SOC_CLOCK_IN);\n\t\tif (ret && ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, MCASP_CLK_HCLK_AUXCLK,\n\t\t\t\t     sysclk_rate, SND_SOC_CLOCK_IN);\n\tif (ret && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dai_set_tdm_slot(cpu_dai, 0x3, 0x3, 2, 32);\n\tif (ret && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\tfor_each_rtd_codec_dais(rtd, i, codec_dai) {\n\t\tret = snd_soc_dai_set_tdm_slot(codec_dai, 0x3, 0x3, 2, 32);\n\t\tif (ret && ret != -ENOTSUPP)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int j721e_audio_init_ivi(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dapm_context *dapm = &rtd->card->dapm;\n\n\tsnd_soc_dapm_new_controls(dapm, j721e_ivi_codec_a_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(j721e_ivi_codec_a_dapm_widgets));\n\tsnd_soc_dapm_add_routes(dapm, j721e_codec_a_dapm_routes,\n\t\t\t\tARRAY_SIZE(j721e_codec_a_dapm_routes));\n\tsnd_soc_dapm_new_controls(dapm, j721e_ivi_codec_b_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(j721e_ivi_codec_b_dapm_widgets));\n\tsnd_soc_dapm_add_routes(dapm, j721e_codec_b_dapm_routes,\n\t\t\t\tARRAY_SIZE(j721e_codec_b_dapm_routes));\n\n\treturn j721e_audio_init(rtd);\n}\n\nstatic int j721e_get_clocks(struct device *dev,\n\t\t\t    struct j721e_audio_clocks *clocks, char *prefix)\n{\n\tstruct clk *parent;\n\tchar *clk_name;\n\tint ret;\n\n\tclocks->target = devm_clk_get(dev, prefix);\n\tif (IS_ERR(clocks->target))\n\t\treturn dev_err_probe(dev, PTR_ERR(clocks->target),\n\t\t\t\t     \"failed to acquire %s\\n\", prefix);\n\n\tclk_name = kasprintf(GFP_KERNEL, \"%s-48000\", prefix);\n\tif (clk_name) {\n\t\tparent = devm_clk_get(dev, clk_name);\n\t\tkfree(clk_name);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\treturn ret;\n\n\t\t\tdev_dbg(dev, \"no 48KHz parent for %s: %d\\n\", prefix, ret);\n\t\t\tparent = NULL;\n\t\t}\n\t\tclocks->parent[J721E_CLK_PARENT_48000] = parent;\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\n\tclk_name = kasprintf(GFP_KERNEL, \"%s-44100\", prefix);\n\tif (clk_name) {\n\t\tparent = devm_clk_get(dev, clk_name);\n\t\tkfree(clk_name);\n\t\tif (IS_ERR(parent)) {\n\t\t\tret = PTR_ERR(parent);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\treturn ret;\n\n\t\t\tdev_dbg(dev, \"no 44.1KHz parent for %s: %d\\n\", prefix, ret);\n\t\t\tparent = NULL;\n\t\t}\n\t\tclocks->parent[J721E_CLK_PARENT_44100] = parent;\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!clocks->parent[J721E_CLK_PARENT_44100] &&\n\t    !clocks->parent[J721E_CLK_PARENT_48000]) {\n\t\tdev_err(dev, \"At least one parent clock is needed for %s\\n\",\n\t\t\tprefix);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct j721e_audio_match_data j721e_cpb_data = {\n\t.board_type = J721E_BOARD_CPB,\n\t.num_links = 2,  \n\t.pll_rates = {\n\t\t[J721E_CLK_PARENT_44100] = 1083801600,  \n\t\t[J721E_CLK_PARENT_48000] = 1179648000,  \n\t},\n};\n\nstatic const struct j721e_audio_match_data j721e_cpb_ivi_data = {\n\t.board_type = J721E_BOARD_CPB_IVI,\n\t.num_links = 4,  \n\t.pll_rates = {\n\t\t[J721E_CLK_PARENT_44100] = 1083801600,  \n\t\t[J721E_CLK_PARENT_48000] = 1179648000,  \n\t},\n};\n\nstatic const struct j721e_audio_match_data j7200_cpb_data = {\n\t.board_type = J721E_BOARD_CPB,\n\t.num_links = 2,  \n\t.pll_rates = {\n\t\t[J721E_CLK_PARENT_48000] = 2359296000u,  \n\t},\n};\n\nstatic const struct of_device_id j721e_audio_of_match[] = {\n\t{\n\t\t.compatible = \"ti,j721e-cpb-audio\",\n\t\t.data = &j721e_cpb_data,\n\t}, {\n\t\t.compatible = \"ti,j721e-cpb-ivi-audio\",\n\t\t.data = &j721e_cpb_ivi_data,\n\t}, {\n\t\t.compatible = \"ti,j7200-cpb-audio\",\n\t\t.data = &j7200_cpb_data,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, j721e_audio_of_match);\n\nstatic int j721e_calculate_rate_range(struct j721e_priv *priv)\n{\n\tconst struct j721e_audio_match_data *match_data = priv->match_data;\n\tstruct j721e_audio_clocks *domain_clocks;\n\tunsigned int min_rate, max_rate, pll_rate;\n\tstruct clk *pll;\n\n\tdomain_clocks = &priv->audio_domains[J721E_AUDIO_DOMAIN_CPB].mcasp;\n\n\tpll = clk_get_parent(domain_clocks->parent[J721E_CLK_PARENT_44100]);\n\tif (IS_ERR_OR_NULL(pll)) {\n\t\tpriv->pll_rates[J721E_CLK_PARENT_44100] =\n\t\t\t\tmatch_data->pll_rates[J721E_CLK_PARENT_44100];\n\t} else {\n\t\tpriv->pll_rates[J721E_CLK_PARENT_44100] = clk_get_rate(pll);\n\t\tclk_put(pll);\n\t}\n\n\tpll = clk_get_parent(domain_clocks->parent[J721E_CLK_PARENT_48000]);\n\tif (IS_ERR_OR_NULL(pll)) {\n\t\tpriv->pll_rates[J721E_CLK_PARENT_48000] =\n\t\t\t\tmatch_data->pll_rates[J721E_CLK_PARENT_48000];\n\t} else {\n\t\tpriv->pll_rates[J721E_CLK_PARENT_48000] = clk_get_rate(pll);\n\t\tclk_put(pll);\n\t}\n\n\tif (!priv->pll_rates[J721E_CLK_PARENT_44100] &&\n\t    !priv->pll_rates[J721E_CLK_PARENT_48000]) {\n\t\tdev_err(priv->dev, \"At least one PLL is needed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (priv->pll_rates[J721E_CLK_PARENT_44100])\n\t\tpll_rate = priv->pll_rates[J721E_CLK_PARENT_44100];\n\telse\n\t\tpll_rate = priv->pll_rates[J721E_CLK_PARENT_48000];\n\n\tmin_rate = pll_rate / J721E_MAX_CLK_HSDIV;\n\tmin_rate /= ratios_for_pcm3168a[ARRAY_SIZE(ratios_for_pcm3168a) - 1];\n\n\tif (priv->pll_rates[J721E_CLK_PARENT_48000])\n\t\tpll_rate = priv->pll_rates[J721E_CLK_PARENT_48000];\n\telse\n\t\tpll_rate = priv->pll_rates[J721E_CLK_PARENT_44100];\n\n\tif (pll_rate > PCM1368A_MAX_SYSCLK)\n\t\tpll_rate = PCM1368A_MAX_SYSCLK;\n\n\tmax_rate = pll_rate / ratios_for_pcm3168a[0];\n\n\tsnd_interval_any(&priv->rate_range);\n\tpriv->rate_range.min = min_rate;\n\tpriv->rate_range.max = max_rate;\n\n\treturn 0;\n}\n\nstatic int j721e_soc_probe_cpb(struct j721e_priv *priv, int *link_idx,\n\t\t\t       int *conf_idx)\n{\n\tstruct device_node *node = priv->dev->of_node;\n\tstruct snd_soc_dai_link_component *compnent;\n\tstruct device_node *dai_node, *codec_node;\n\tstruct j721e_audio_domain *domain;\n\tint comp_count, comp_idx;\n\tint ret;\n\n\tdai_node = of_parse_phandle(node, \"ti,cpb-mcasp\", 0);\n\tif (!dai_node) {\n\t\tdev_err(priv->dev, \"CPB McASP node is not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcodec_node = of_parse_phandle(node, \"ti,cpb-codec\", 0);\n\tif (!codec_node) {\n\t\tdev_err(priv->dev, \"CPB codec node is not provided\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_dai_node;\n\t}\n\n\tdomain = &priv->audio_domains[J721E_AUDIO_DOMAIN_CPB];\n\tret = j721e_get_clocks(priv->dev, &domain->codec, \"cpb-codec-scki\");\n\tif (ret)\n\t\tgoto put_codec_node;\n\n\tret = j721e_get_clocks(priv->dev, &domain->mcasp, \"cpb-mcasp-auxclk\");\n\tif (ret)\n\t\tgoto put_codec_node;\n\n\t \n\tcomp_count = 6;\n\tcompnent = devm_kzalloc(priv->dev, comp_count * sizeof(*compnent),\n\t\t\t\tGFP_KERNEL);\n\tif (!compnent) {\n\t\tret = -ENOMEM;\n\t\tgoto put_codec_node;\n\t}\n\n\tcomp_idx = 0;\n\tpriv->dai_links[*link_idx].cpus = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_cpus = 1;\n\tpriv->dai_links[*link_idx].codecs = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_codecs = 1;\n\tpriv->dai_links[*link_idx].platforms = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_platforms = 1;\n\n\tpriv->dai_links[*link_idx].name = \"CPB PCM3168A Playback\";\n\tpriv->dai_links[*link_idx].stream_name = \"CPB PCM3168A Analog\";\n\tpriv->dai_links[*link_idx].cpus->of_node = dai_node;\n\tpriv->dai_links[*link_idx].platforms->of_node = dai_node;\n\tpriv->dai_links[*link_idx].codecs->of_node = codec_node;\n\tpriv->dai_links[*link_idx].codecs->dai_name = \"pcm3168a-dac\";\n\tpriv->dai_links[*link_idx].playback_only = 1;\n\tpriv->dai_links[*link_idx].id = J721E_AUDIO_DOMAIN_CPB;\n\tpriv->dai_links[*link_idx].dai_fmt = J721E_DAI_FMT;\n\tpriv->dai_links[*link_idx].init = j721e_audio_init;\n\tpriv->dai_links[*link_idx].ops = &j721e_audio_ops;\n\t(*link_idx)++;\n\n\tpriv->dai_links[*link_idx].cpus = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_cpus = 1;\n\tpriv->dai_links[*link_idx].codecs = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_codecs = 1;\n\tpriv->dai_links[*link_idx].platforms = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_platforms = 1;\n\n\tpriv->dai_links[*link_idx].name = \"CPB PCM3168A Capture\";\n\tpriv->dai_links[*link_idx].stream_name = \"CPB PCM3168A Analog\";\n\tpriv->dai_links[*link_idx].cpus->of_node = dai_node;\n\tpriv->dai_links[*link_idx].platforms->of_node = dai_node;\n\tpriv->dai_links[*link_idx].codecs->of_node = codec_node;\n\tpriv->dai_links[*link_idx].codecs->dai_name = \"pcm3168a-adc\";\n\tpriv->dai_links[*link_idx].capture_only = 1;\n\tpriv->dai_links[*link_idx].id = J721E_AUDIO_DOMAIN_CPB;\n\tpriv->dai_links[*link_idx].dai_fmt = J721E_DAI_FMT;\n\tpriv->dai_links[*link_idx].init = j721e_audio_init;\n\tpriv->dai_links[*link_idx].ops = &j721e_audio_ops;\n\t(*link_idx)++;\n\n\tpriv->codec_conf[*conf_idx].dlc.of_node = codec_node;\n\tpriv->codec_conf[*conf_idx].name_prefix = \"codec-1\";\n\t(*conf_idx)++;\n\tpriv->codec_conf[*conf_idx].dlc.of_node = dai_node;\n\tpriv->codec_conf[*conf_idx].name_prefix = \"McASP10\";\n\t(*conf_idx)++;\n\n\treturn 0;\n\nput_codec_node:\n\tof_node_put(codec_node);\nput_dai_node:\n\tof_node_put(dai_node);\n\treturn ret;\n}\n\nstatic int j721e_soc_probe_ivi(struct j721e_priv *priv, int *link_idx,\n\t\t\t       int *conf_idx)\n{\n\tstruct device_node *node = priv->dev->of_node;\n\tstruct snd_soc_dai_link_component *compnent;\n\tstruct device_node *dai_node, *codeca_node, *codecb_node;\n\tstruct j721e_audio_domain *domain;\n\tint comp_count, comp_idx;\n\tint ret;\n\n\tif (priv->match_data->board_type != J721E_BOARD_CPB_IVI)\n\t\treturn 0;\n\n\tdai_node = of_parse_phandle(node, \"ti,ivi-mcasp\", 0);\n\tif (!dai_node) {\n\t\tdev_err(priv->dev, \"IVI McASP node is not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcodeca_node = of_parse_phandle(node, \"ti,ivi-codec-a\", 0);\n\tif (!codeca_node) {\n\t\tdev_err(priv->dev, \"IVI codec-a node is not provided\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_dai_node;\n\t}\n\n\tcodecb_node = of_parse_phandle(node, \"ti,ivi-codec-b\", 0);\n\tif (!codecb_node) {\n\t\tdev_warn(priv->dev, \"IVI codec-b node is not provided\\n\");\n\t\tret = 0;\n\t\tgoto put_codeca_node;\n\t}\n\n\tdomain = &priv->audio_domains[J721E_AUDIO_DOMAIN_IVI];\n\tret = j721e_get_clocks(priv->dev, &domain->codec, \"ivi-codec-scki\");\n\tif (ret)\n\t\tgoto put_codecb_node;\n\n\tret = j721e_get_clocks(priv->dev, &domain->mcasp, \"ivi-mcasp-auxclk\");\n\tif (ret)\n\t\tgoto put_codecb_node;\n\n\t \n\tcomp_count = 8;\n\tcompnent = devm_kzalloc(priv->dev, comp_count * sizeof(*compnent),\n\t\t\t\tGFP_KERNEL);\n\tif (!compnent) {\n\t\tret = -ENOMEM;\n\t\tgoto put_codecb_node;\n\t}\n\n\tcomp_idx = 0;\n\tpriv->dai_links[*link_idx].cpus = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_cpus = 1;\n\tpriv->dai_links[*link_idx].platforms = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_platforms = 1;\n\tpriv->dai_links[*link_idx].codecs = &compnent[comp_idx];\n\tpriv->dai_links[*link_idx].num_codecs = 2;\n\tcomp_idx += 2;\n\n\tpriv->dai_links[*link_idx].name = \"IVI 2xPCM3168A Playback\";\n\tpriv->dai_links[*link_idx].stream_name = \"IVI 2xPCM3168A Analog\";\n\tpriv->dai_links[*link_idx].cpus->of_node = dai_node;\n\tpriv->dai_links[*link_idx].platforms->of_node = dai_node;\n\tpriv->dai_links[*link_idx].codecs[0].of_node = codeca_node;\n\tpriv->dai_links[*link_idx].codecs[0].dai_name = \"pcm3168a-dac\";\n\tpriv->dai_links[*link_idx].codecs[1].of_node = codecb_node;\n\tpriv->dai_links[*link_idx].codecs[1].dai_name = \"pcm3168a-dac\";\n\tpriv->dai_links[*link_idx].playback_only = 1;\n\tpriv->dai_links[*link_idx].id = J721E_AUDIO_DOMAIN_IVI;\n\tpriv->dai_links[*link_idx].dai_fmt = J721E_DAI_FMT;\n\tpriv->dai_links[*link_idx].init = j721e_audio_init_ivi;\n\tpriv->dai_links[*link_idx].ops = &j721e_audio_ops;\n\t(*link_idx)++;\n\n\tpriv->dai_links[*link_idx].cpus = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_cpus = 1;\n\tpriv->dai_links[*link_idx].platforms = &compnent[comp_idx++];\n\tpriv->dai_links[*link_idx].num_platforms = 1;\n\tpriv->dai_links[*link_idx].codecs = &compnent[comp_idx];\n\tpriv->dai_links[*link_idx].num_codecs = 2;\n\n\tpriv->dai_links[*link_idx].name = \"IVI 2xPCM3168A Capture\";\n\tpriv->dai_links[*link_idx].stream_name = \"IVI 2xPCM3168A Analog\";\n\tpriv->dai_links[*link_idx].cpus->of_node = dai_node;\n\tpriv->dai_links[*link_idx].platforms->of_node = dai_node;\n\tpriv->dai_links[*link_idx].codecs[0].of_node = codeca_node;\n\tpriv->dai_links[*link_idx].codecs[0].dai_name = \"pcm3168a-adc\";\n\tpriv->dai_links[*link_idx].codecs[1].of_node = codecb_node;\n\tpriv->dai_links[*link_idx].codecs[1].dai_name = \"pcm3168a-adc\";\n\tpriv->dai_links[*link_idx].capture_only = 1;\n\tpriv->dai_links[*link_idx].id = J721E_AUDIO_DOMAIN_IVI;\n\tpriv->dai_links[*link_idx].dai_fmt = J721E_DAI_FMT;\n\tpriv->dai_links[*link_idx].init = j721e_audio_init;\n\tpriv->dai_links[*link_idx].ops = &j721e_audio_ops;\n\t(*link_idx)++;\n\n\tpriv->codec_conf[*conf_idx].dlc.of_node = codeca_node;\n\tpriv->codec_conf[*conf_idx].name_prefix = \"codec-a\";\n\t(*conf_idx)++;\n\n\tpriv->codec_conf[*conf_idx].dlc.of_node = codecb_node;\n\tpriv->codec_conf[*conf_idx].name_prefix = \"codec-b\";\n\t(*conf_idx)++;\n\n\tpriv->codec_conf[*conf_idx].dlc.of_node = dai_node;\n\tpriv->codec_conf[*conf_idx].name_prefix = \"McASP0\";\n\t(*conf_idx)++;\n\n\treturn 0;\n\n\nput_codecb_node:\n\tof_node_put(codecb_node);\nput_codeca_node:\n\tof_node_put(codeca_node);\nput_dai_node:\n\tof_node_put(dai_node);\n\treturn ret;\n}\n\nstatic int j721e_soc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct snd_soc_card *card;\n\tconst struct of_device_id *match;\n\tstruct j721e_priv *priv;\n\tint link_cnt, conf_cnt, ret, i;\n\n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"of node is missing.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmatch = of_match_node(j721e_audio_of_match, node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"No compatible match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->match_data = match->data;\n\n\tpriv->dai_links = devm_kcalloc(&pdev->dev, priv->match_data->num_links,\n\t\t\t\t       sizeof(*priv->dai_links), GFP_KERNEL);\n\tif (!priv->dai_links)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < J721E_AUDIO_DOMAIN_LAST; i++)\n\t\tpriv->audio_domains[i].parent_clk_id = -1;\n\n\tpriv->dev = &pdev->dev;\n\tcard = &priv->card;\n\tcard->dev = &pdev->dev;\n\tcard->owner = THIS_MODULE;\n\tcard->dapm_widgets = j721e_cpb_dapm_widgets;\n\tcard->num_dapm_widgets = ARRAY_SIZE(j721e_cpb_dapm_widgets);\n\tcard->dapm_routes = j721e_cpb_dapm_routes;\n\tcard->num_dapm_routes = ARRAY_SIZE(j721e_cpb_dapm_routes);\n\tcard->fully_routed = 1;\n\n\tif (snd_soc_of_parse_card_name(card, \"model\")) {\n\t\tdev_err(&pdev->dev, \"Card name is not provided\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tlink_cnt = 0;\n\tconf_cnt = 0;\n\tret = j721e_soc_probe_cpb(priv, &link_cnt, &conf_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = j721e_soc_probe_ivi(priv, &link_cnt, &conf_cnt);\n\tif (ret)\n\t\treturn ret;\n\n\tcard->dai_link = priv->dai_links;\n\tcard->num_links = link_cnt;\n\n\tcard->codec_conf = priv->codec_conf;\n\tcard->num_configs = conf_cnt;\n\n\tret = j721e_calculate_rate_range(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tmutex_init(&priv->mutex);\n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"devm_snd_soc_register_card() failed: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver j721e_soc_driver = {\n\t.driver = {\n\t\t.name = \"j721e-audio\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = j721e_audio_of_match,\n\t},\n\t.probe = j721e_soc_probe,\n};\n\nmodule_platform_driver(j721e_soc_driver);\n\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"ASoC machine driver for j721e Common Processor Board\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}