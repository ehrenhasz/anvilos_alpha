{
  "module_name": "omap-mcbsp.c",
  "hash_id": "e8d10d1bedbaaa350379ede83274b0b1e5b819f7dddd919ed3688108baf224bc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-mcbsp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"omap-mcbsp-priv.h\"\n#include \"omap-mcbsp.h\"\n#include \"sdma-pcm.h\"\n\n#define OMAP_MCBSP_RATES\t(SNDRV_PCM_RATE_8000_96000)\n\nenum {\n\tOMAP_MCBSP_WORD_8 = 0,\n\tOMAP_MCBSP_WORD_12,\n\tOMAP_MCBSP_WORD_16,\n\tOMAP_MCBSP_WORD_20,\n\tOMAP_MCBSP_WORD_24,\n\tOMAP_MCBSP_WORD_32,\n};\n\nstatic void omap_mcbsp_dump_reg(struct omap_mcbsp *mcbsp)\n{\n\tdev_dbg(mcbsp->dev, \"**** McBSP%d regs ****\\n\", mcbsp->id);\n\tdev_dbg(mcbsp->dev, \"DRR2:  0x%04x\\n\", MCBSP_READ(mcbsp, DRR2));\n\tdev_dbg(mcbsp->dev, \"DRR1:  0x%04x\\n\", MCBSP_READ(mcbsp, DRR1));\n\tdev_dbg(mcbsp->dev, \"DXR2:  0x%04x\\n\", MCBSP_READ(mcbsp, DXR2));\n\tdev_dbg(mcbsp->dev, \"DXR1:  0x%04x\\n\", MCBSP_READ(mcbsp, DXR1));\n\tdev_dbg(mcbsp->dev, \"SPCR2: 0x%04x\\n\", MCBSP_READ(mcbsp, SPCR2));\n\tdev_dbg(mcbsp->dev, \"SPCR1: 0x%04x\\n\", MCBSP_READ(mcbsp, SPCR1));\n\tdev_dbg(mcbsp->dev, \"RCR2:  0x%04x\\n\", MCBSP_READ(mcbsp, RCR2));\n\tdev_dbg(mcbsp->dev, \"RCR1:  0x%04x\\n\", MCBSP_READ(mcbsp, RCR1));\n\tdev_dbg(mcbsp->dev, \"XCR2:  0x%04x\\n\", MCBSP_READ(mcbsp, XCR2));\n\tdev_dbg(mcbsp->dev, \"XCR1:  0x%04x\\n\", MCBSP_READ(mcbsp, XCR1));\n\tdev_dbg(mcbsp->dev, \"SRGR2: 0x%04x\\n\", MCBSP_READ(mcbsp, SRGR2));\n\tdev_dbg(mcbsp->dev, \"SRGR1: 0x%04x\\n\", MCBSP_READ(mcbsp, SRGR1));\n\tdev_dbg(mcbsp->dev, \"PCR0:  0x%04x\\n\", MCBSP_READ(mcbsp, PCR0));\n\tdev_dbg(mcbsp->dev, \"***********************\\n\");\n}\n\nstatic int omap2_mcbsp_set_clks_src(struct omap_mcbsp *mcbsp, u8 fck_src_id)\n{\n\tstruct clk *fck_src;\n\tconst char *src;\n\tint r;\n\n\tif (fck_src_id == MCBSP_CLKS_PAD_SRC)\n\t\tsrc = \"pad_fck\";\n\telse if (fck_src_id == MCBSP_CLKS_PRCM_SRC)\n\t\tsrc = \"prcm_fck\";\n\telse\n\t\treturn -EINVAL;\n\n\tfck_src = clk_get(mcbsp->dev, src);\n\tif (IS_ERR(fck_src)) {\n\t\tdev_info(mcbsp->dev, \"CLKS: could not clk_get() %s\\n\", src);\n\t\treturn 0;\n\t}\n\n\tif (mcbsp->active)\n\t\tpm_runtime_put_sync(mcbsp->dev);\n\n\tr = clk_set_parent(mcbsp->fclk, fck_src);\n\tif (r)\n\t\tdev_err(mcbsp->dev, \"CLKS: could not clk_set_parent() to %s\\n\",\n\t\t\tsrc);\n\n\tif (mcbsp->active)\n\t\tpm_runtime_get_sync(mcbsp->dev);\n\n\tclk_put(fck_src);\n\n\treturn r;\n}\n\nstatic irqreturn_t omap_mcbsp_irq_handler(int irq, void *data)\n{\n\tstruct omap_mcbsp *mcbsp = data;\n\tu16 irqst;\n\n\tirqst = MCBSP_READ(mcbsp, IRQST);\n\tdev_dbg(mcbsp->dev, \"IRQ callback : 0x%x\\n\", irqst);\n\n\tif (irqst & RSYNCERREN)\n\t\tdev_err(mcbsp->dev, \"RX Frame Sync Error!\\n\");\n\tif (irqst & RFSREN)\n\t\tdev_dbg(mcbsp->dev, \"RX Frame Sync\\n\");\n\tif (irqst & REOFEN)\n\t\tdev_dbg(mcbsp->dev, \"RX End Of Frame\\n\");\n\tif (irqst & RRDYEN)\n\t\tdev_dbg(mcbsp->dev, \"RX Buffer Threshold Reached\\n\");\n\tif (irqst & RUNDFLEN)\n\t\tdev_err(mcbsp->dev, \"RX Buffer Underflow!\\n\");\n\tif (irqst & ROVFLEN)\n\t\tdev_err(mcbsp->dev, \"RX Buffer Overflow!\\n\");\n\n\tif (irqst & XSYNCERREN)\n\t\tdev_err(mcbsp->dev, \"TX Frame Sync Error!\\n\");\n\tif (irqst & XFSXEN)\n\t\tdev_dbg(mcbsp->dev, \"TX Frame Sync\\n\");\n\tif (irqst & XEOFEN)\n\t\tdev_dbg(mcbsp->dev, \"TX End Of Frame\\n\");\n\tif (irqst & XRDYEN)\n\t\tdev_dbg(mcbsp->dev, \"TX Buffer threshold Reached\\n\");\n\tif (irqst & XUNDFLEN)\n\t\tdev_err(mcbsp->dev, \"TX Buffer Underflow!\\n\");\n\tif (irqst & XOVFLEN)\n\t\tdev_err(mcbsp->dev, \"TX Buffer Overflow!\\n\");\n\tif (irqst & XEMPTYEOFEN)\n\t\tdev_dbg(mcbsp->dev, \"TX Buffer empty at end of frame\\n\");\n\n\tMCBSP_WRITE(mcbsp, IRQST, irqst);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t omap_mcbsp_tx_irq_handler(int irq, void *data)\n{\n\tstruct omap_mcbsp *mcbsp = data;\n\tu16 irqst_spcr2;\n\n\tirqst_spcr2 = MCBSP_READ(mcbsp, SPCR2);\n\tdev_dbg(mcbsp->dev, \"TX IRQ callback : 0x%x\\n\", irqst_spcr2);\n\n\tif (irqst_spcr2 & XSYNC_ERR) {\n\t\tdev_err(mcbsp->dev, \"TX Frame Sync Error! : 0x%x\\n\",\n\t\t\tirqst_spcr2);\n\t\t \n\t\tMCBSP_WRITE(mcbsp, SPCR2, MCBSP_READ_CACHE(mcbsp, SPCR2));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t omap_mcbsp_rx_irq_handler(int irq, void *data)\n{\n\tstruct omap_mcbsp *mcbsp = data;\n\tu16 irqst_spcr1;\n\n\tirqst_spcr1 = MCBSP_READ(mcbsp, SPCR1);\n\tdev_dbg(mcbsp->dev, \"RX IRQ callback : 0x%x\\n\", irqst_spcr1);\n\n\tif (irqst_spcr1 & RSYNC_ERR) {\n\t\tdev_err(mcbsp->dev, \"RX Frame Sync Error! : 0x%x\\n\",\n\t\t\tirqst_spcr1);\n\t\t \n\t\tMCBSP_WRITE(mcbsp, SPCR1, MCBSP_READ_CACHE(mcbsp, SPCR1));\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void omap_mcbsp_config(struct omap_mcbsp *mcbsp,\n\t\t\t      const struct omap_mcbsp_reg_cfg *config)\n{\n\tdev_dbg(mcbsp->dev, \"Configuring McBSP%d  phys_base: 0x%08lx\\n\",\n\t\tmcbsp->id, mcbsp->phys_base);\n\n\t \n\tMCBSP_WRITE(mcbsp, SPCR2, config->spcr2);\n\tMCBSP_WRITE(mcbsp, SPCR1, config->spcr1);\n\tMCBSP_WRITE(mcbsp, RCR2, config->rcr2);\n\tMCBSP_WRITE(mcbsp, RCR1, config->rcr1);\n\tMCBSP_WRITE(mcbsp, XCR2, config->xcr2);\n\tMCBSP_WRITE(mcbsp, XCR1, config->xcr1);\n\tMCBSP_WRITE(mcbsp, SRGR2, config->srgr2);\n\tMCBSP_WRITE(mcbsp, SRGR1, config->srgr1);\n\tMCBSP_WRITE(mcbsp, MCR2, config->mcr2);\n\tMCBSP_WRITE(mcbsp, MCR1, config->mcr1);\n\tMCBSP_WRITE(mcbsp, PCR0, config->pcr0);\n\tif (mcbsp->pdata->has_ccr) {\n\t\tMCBSP_WRITE(mcbsp, XCCR, config->xccr);\n\t\tMCBSP_WRITE(mcbsp, RCCR, config->rccr);\n\t}\n\t \n\tif (mcbsp->pdata->has_wakeup)\n\t\tMCBSP_WRITE(mcbsp, WAKEUPEN, XRDYEN | RRDYEN);\n\n\t \n\tif (mcbsp->irq)\n\t\tMCBSP_WRITE(mcbsp, IRQEN, RSYNCERREN | XSYNCERREN |\n\t\t\t    RUNDFLEN | ROVFLEN | XUNDFLEN | XOVFLEN);\n}\n\n \nstatic int omap_mcbsp_dma_reg_params(struct omap_mcbsp *mcbsp,\n\t\t\t\t     unsigned int stream)\n{\n\tint data_reg;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (mcbsp->pdata->reg_size == 2)\n\t\t\tdata_reg = OMAP_MCBSP_REG_DXR1;\n\t\telse\n\t\t\tdata_reg = OMAP_MCBSP_REG_DXR;\n\t} else {\n\t\tif (mcbsp->pdata->reg_size == 2)\n\t\t\tdata_reg = OMAP_MCBSP_REG_DRR1;\n\t\telse\n\t\t\tdata_reg = OMAP_MCBSP_REG_DRR;\n\t}\n\n\treturn mcbsp->phys_dma_base + data_reg * mcbsp->pdata->reg_step;\n}\n\n \nstatic void omap_mcbsp_set_tx_threshold(struct omap_mcbsp *mcbsp, u16 threshold)\n{\n\tif (threshold && threshold <= mcbsp->max_tx_thres)\n\t\tMCBSP_WRITE(mcbsp, THRSH2, threshold - 1);\n}\n\n \nstatic void omap_mcbsp_set_rx_threshold(struct omap_mcbsp *mcbsp, u16 threshold)\n{\n\tif (threshold && threshold <= mcbsp->max_rx_thres)\n\t\tMCBSP_WRITE(mcbsp, THRSH1, threshold - 1);\n}\n\n \nstatic u16 omap_mcbsp_get_tx_delay(struct omap_mcbsp *mcbsp)\n{\n\tu16 buffstat;\n\n\t \n\tbuffstat = MCBSP_READ(mcbsp, XBUFFSTAT);\n\n\t \n\treturn mcbsp->pdata->buffer_size - buffstat;\n}\n\n \nstatic u16 omap_mcbsp_get_rx_delay(struct omap_mcbsp *mcbsp)\n{\n\tu16 buffstat, threshold;\n\n\t \n\tbuffstat = MCBSP_READ(mcbsp, RBUFFSTAT);\n\t \n\tthreshold = MCBSP_READ(mcbsp, THRSH1);\n\n\t \n\tif (threshold <= buffstat)\n\t\treturn 0;\n\telse\n\t\treturn threshold - buffstat;\n}\n\nstatic int omap_mcbsp_request(struct omap_mcbsp *mcbsp)\n{\n\tvoid *reg_cache;\n\tint err;\n\n\treg_cache = kzalloc(mcbsp->reg_cache_size, GFP_KERNEL);\n\tif (!reg_cache)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&mcbsp->lock);\n\tif (!mcbsp->free) {\n\t\tdev_err(mcbsp->dev, \"McBSP%d is currently in use\\n\", mcbsp->id);\n\t\terr = -EBUSY;\n\t\tgoto err_kfree;\n\t}\n\n\tmcbsp->free = false;\n\tmcbsp->reg_cache = reg_cache;\n\tspin_unlock(&mcbsp->lock);\n\n\tif(mcbsp->pdata->ops && mcbsp->pdata->ops->request)\n\t\tmcbsp->pdata->ops->request(mcbsp->id - 1);\n\n\t \n\tMCBSP_WRITE(mcbsp, SPCR1, 0);\n\tMCBSP_WRITE(mcbsp, SPCR2, 0);\n\n\tif (mcbsp->irq) {\n\t\terr = request_irq(mcbsp->irq, omap_mcbsp_irq_handler, 0,\n\t\t\t\t  \"McBSP\", (void *)mcbsp);\n\t\tif (err != 0) {\n\t\t\tdev_err(mcbsp->dev, \"Unable to request IRQ\\n\");\n\t\t\tgoto err_clk_disable;\n\t\t}\n\t} else {\n\t\terr = request_irq(mcbsp->tx_irq, omap_mcbsp_tx_irq_handler, 0,\n\t\t\t\t  \"McBSP TX\", (void *)mcbsp);\n\t\tif (err != 0) {\n\t\t\tdev_err(mcbsp->dev, \"Unable to request TX IRQ\\n\");\n\t\t\tgoto err_clk_disable;\n\t\t}\n\n\t\terr = request_irq(mcbsp->rx_irq, omap_mcbsp_rx_irq_handler, 0,\n\t\t\t\t  \"McBSP RX\", (void *)mcbsp);\n\t\tif (err != 0) {\n\t\t\tdev_err(mcbsp->dev, \"Unable to request RX IRQ\\n\");\n\t\t\tgoto err_free_irq;\n\t\t}\n\t}\n\n\treturn 0;\nerr_free_irq:\n\tfree_irq(mcbsp->tx_irq, (void *)mcbsp);\nerr_clk_disable:\n\tif(mcbsp->pdata->ops && mcbsp->pdata->ops->free)\n\t\tmcbsp->pdata->ops->free(mcbsp->id - 1);\n\n\t \n\tif (mcbsp->pdata->has_wakeup)\n\t\tMCBSP_WRITE(mcbsp, WAKEUPEN, 0);\n\n\tspin_lock(&mcbsp->lock);\n\tmcbsp->free = true;\n\tmcbsp->reg_cache = NULL;\nerr_kfree:\n\tspin_unlock(&mcbsp->lock);\n\tkfree(reg_cache);\n\n\treturn err;\n}\n\nstatic void omap_mcbsp_free(struct omap_mcbsp *mcbsp)\n{\n\tvoid *reg_cache;\n\n\tif(mcbsp->pdata->ops && mcbsp->pdata->ops->free)\n\t\tmcbsp->pdata->ops->free(mcbsp->id - 1);\n\n\t \n\tif (mcbsp->pdata->has_wakeup)\n\t\tMCBSP_WRITE(mcbsp, WAKEUPEN, 0);\n\n\t \n\tif (mcbsp->irq) {\n\t\tMCBSP_WRITE(mcbsp, IRQEN, 0);\n\n\t\tfree_irq(mcbsp->irq, (void *)mcbsp);\n\t} else {\n\t\tfree_irq(mcbsp->rx_irq, (void *)mcbsp);\n\t\tfree_irq(mcbsp->tx_irq, (void *)mcbsp);\n\t}\n\n\treg_cache = mcbsp->reg_cache;\n\n\t \n\tif (!mcbsp_omap1())\n\t\tomap2_mcbsp_set_clks_src(mcbsp, MCBSP_CLKS_PRCM_SRC);\n\n\tspin_lock(&mcbsp->lock);\n\tif (mcbsp->free)\n\t\tdev_err(mcbsp->dev, \"McBSP%d was not reserved\\n\", mcbsp->id);\n\telse\n\t\tmcbsp->free = true;\n\tmcbsp->reg_cache = NULL;\n\tspin_unlock(&mcbsp->lock);\n\n\tkfree(reg_cache);\n}\n\n \nstatic void omap_mcbsp_start(struct omap_mcbsp *mcbsp, int stream)\n{\n\tint tx = (stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint rx = !tx;\n\tint enable_srg = 0;\n\tu16 w;\n\n\tif (mcbsp->st_data)\n\t\tomap_mcbsp_st_start(mcbsp);\n\n\t \n\tw = MCBSP_READ_CACHE(mcbsp, PCR0);\n\tif (w & (FSXM | FSRM | CLKXM | CLKRM))\n\t\tenable_srg = !((MCBSP_READ_CACHE(mcbsp, SPCR2) |\n\t\t\t\tMCBSP_READ_CACHE(mcbsp, SPCR1)) & 1);\n\n\tif (enable_srg) {\n\t\t \n\t\tw = MCBSP_READ_CACHE(mcbsp, SPCR2);\n\t\tMCBSP_WRITE(mcbsp, SPCR2, w | (1 << 6));\n\t}\n\n\t \n\ttx &= 1;\n\tw = MCBSP_READ_CACHE(mcbsp, SPCR2);\n\tMCBSP_WRITE(mcbsp, SPCR2, w | tx);\n\n\trx &= 1;\n\tw = MCBSP_READ_CACHE(mcbsp, SPCR1);\n\tMCBSP_WRITE(mcbsp, SPCR1, w | rx);\n\n\t \n\tudelay(500);\n\n\tif (enable_srg) {\n\t\t \n\t\tw = MCBSP_READ_CACHE(mcbsp, SPCR2);\n\t\tMCBSP_WRITE(mcbsp, SPCR2, w | (1 << 7));\n\t}\n\n\tif (mcbsp->pdata->has_ccr) {\n\t\t \n\t\tw = MCBSP_READ_CACHE(mcbsp, XCCR);\n\t\tw &= ~(tx ? XDISABLE : 0);\n\t\tMCBSP_WRITE(mcbsp, XCCR, w);\n\t\tw = MCBSP_READ_CACHE(mcbsp, RCCR);\n\t\tw &= ~(rx ? RDISABLE : 0);\n\t\tMCBSP_WRITE(mcbsp, RCCR, w);\n\t}\n\n\t \n\tomap_mcbsp_dump_reg(mcbsp);\n}\n\nstatic void omap_mcbsp_stop(struct omap_mcbsp *mcbsp, int stream)\n{\n\tint tx = (stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint rx = !tx;\n\tint idle;\n\tu16 w;\n\n\t \n\ttx &= 1;\n\tif (mcbsp->pdata->has_ccr) {\n\t\tw = MCBSP_READ_CACHE(mcbsp, XCCR);\n\t\tw |= (tx ? XDISABLE : 0);\n\t\tMCBSP_WRITE(mcbsp, XCCR, w);\n\t}\n\tw = MCBSP_READ_CACHE(mcbsp, SPCR2);\n\tMCBSP_WRITE(mcbsp, SPCR2, w & ~tx);\n\n\t \n\trx &= 1;\n\tif (mcbsp->pdata->has_ccr) {\n\t\tw = MCBSP_READ_CACHE(mcbsp, RCCR);\n\t\tw |= (rx ? RDISABLE : 0);\n\t\tMCBSP_WRITE(mcbsp, RCCR, w);\n\t}\n\tw = MCBSP_READ_CACHE(mcbsp, SPCR1);\n\tMCBSP_WRITE(mcbsp, SPCR1, w & ~rx);\n\n\tidle = !((MCBSP_READ_CACHE(mcbsp, SPCR2) |\n\t\t\tMCBSP_READ_CACHE(mcbsp, SPCR1)) & 1);\n\n\tif (idle) {\n\t\t \n\t\tw = MCBSP_READ_CACHE(mcbsp, SPCR2);\n\t\tMCBSP_WRITE(mcbsp, SPCR2, w & ~(1 << 6));\n\t}\n\n\tif (mcbsp->st_data)\n\t\tomap_mcbsp_st_stop(mcbsp);\n}\n\n#define max_thres(m)\t\t\t(mcbsp->pdata->buffer_size)\n#define valid_threshold(m, val)\t\t((val) <= max_thres(m))\n#define THRESHOLD_PROP_BUILDER(prop)\t\t\t\t\t\\\nstatic ssize_t prop##_show(struct device *dev,\t\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%u\\n\", mcbsp->prop);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t prop##_store(struct device *dev,\t\t\t\t\\\n\t\t\t\tstruct device_attribute *attr,\t\t\\\n\t\t\t\tconst char *buf, size_t size)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint status;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tstatus = kstrtoul(buf, 0, &val);\t\t\t\t\\\n\tif (status)\t\t\t\t\t\t\t\\\n\t\treturn status;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!valid_threshold(mcbsp, val))\t\t\t\t\\\n\t\treturn -EDOM;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmcbsp->prop = val;\t\t\t\t\t\t\\\n\treturn size;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(prop)\n\nTHRESHOLD_PROP_BUILDER(max_tx_thres);\nTHRESHOLD_PROP_BUILDER(max_rx_thres);\n\nstatic const char * const dma_op_modes[] = {\n\t\"element\", \"threshold\",\n};\n\nstatic ssize_t dma_op_mode_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\n\tint dma_op_mode, i = 0;\n\tssize_t len = 0;\n\tconst char * const *s;\n\n\tdma_op_mode = mcbsp->dma_op_mode;\n\n\tfor (s = &dma_op_modes[i]; i < ARRAY_SIZE(dma_op_modes); s++, i++) {\n\t\tif (dma_op_mode == i)\n\t\t\tlen += sysfs_emit_at(buf, len, \"[%s] \", *s);\n\t\telse\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s \", *s);\n\t}\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t dma_op_mode_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t size)\n{\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\n\tint i;\n\n\ti = sysfs_match_string(dma_op_modes, buf);\n\tif (i < 0)\n\t\treturn i;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tif (!mcbsp->free) {\n\t\tsize = -EBUSY;\n\t\tgoto unlock;\n\t}\n\tmcbsp->dma_op_mode = i;\n\nunlock:\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(dma_op_mode);\n\nstatic const struct attribute *additional_attrs[] = {\n\t&dev_attr_max_tx_thres.attr,\n\t&dev_attr_max_rx_thres.attr,\n\t&dev_attr_dma_op_mode.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group additional_attr_group = {\n\t.attrs = (struct attribute **)additional_attrs,\n};\n\n \nstatic int omap_mcbsp_init(struct platform_device *pdev)\n{\n\tstruct omap_mcbsp *mcbsp = platform_get_drvdata(pdev);\n\tstruct resource *res;\n\tint ret;\n\n\tspin_lock_init(&mcbsp->lock);\n\tmcbsp->free = true;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mpu\");\n\tif (!res)\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tmcbsp->io_base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(mcbsp->io_base))\n\t\treturn PTR_ERR(mcbsp->io_base);\n\n\tmcbsp->phys_base = res->start;\n\tmcbsp->reg_cache_size = resource_size(res);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dma\");\n\tif (!res)\n\t\tmcbsp->phys_dma_base = mcbsp->phys_base;\n\telse\n\t\tmcbsp->phys_dma_base = res->start;\n\n\t \n\tmcbsp->irq = platform_get_irq_byname(pdev, \"common\");\n\tif (mcbsp->irq == -ENXIO) {\n\t\tmcbsp->tx_irq = platform_get_irq_byname(pdev, \"tx\");\n\n\t\tif (mcbsp->tx_irq == -ENXIO) {\n\t\t\tmcbsp->irq = platform_get_irq(pdev, 0);\n\t\t\tmcbsp->tx_irq = 0;\n\t\t} else {\n\t\t\tmcbsp->rx_irq = platform_get_irq_byname(pdev, \"rx\");\n\t\t\tmcbsp->irq = 0;\n\t\t}\n\t}\n\n\tif (!pdev->dev.of_node) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_DMA, \"tx\");\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"invalid tx DMA channel\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmcbsp->dma_req[0] = res->start;\n\t\tmcbsp->dma_data[0].filter_data = &mcbsp->dma_req[0];\n\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_DMA, \"rx\");\n\t\tif (!res) {\n\t\t\tdev_err(&pdev->dev, \"invalid rx DMA channel\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tmcbsp->dma_req[1] = res->start;\n\t\tmcbsp->dma_data[1].filter_data = &mcbsp->dma_req[1];\n\t} else {\n\t\tmcbsp->dma_data[0].filter_data = \"tx\";\n\t\tmcbsp->dma_data[1].filter_data = \"rx\";\n\t}\n\n\tmcbsp->dma_data[0].addr = omap_mcbsp_dma_reg_params(mcbsp,\n\t\t\t\t\t\tSNDRV_PCM_STREAM_PLAYBACK);\n\tmcbsp->dma_data[1].addr = omap_mcbsp_dma_reg_params(mcbsp,\n\t\t\t\t\t\tSNDRV_PCM_STREAM_CAPTURE);\n\n\tmcbsp->fclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(mcbsp->fclk)) {\n\t\tret = PTR_ERR(mcbsp->fclk);\n\t\tdev_err(mcbsp->dev, \"unable to get fck: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmcbsp->dma_op_mode = MCBSP_DMA_MODE_ELEMENT;\n\tif (mcbsp->pdata->buffer_size) {\n\t\t \n\t\tmcbsp->max_tx_thres = max_thres(mcbsp) - 0x10;\n\t\tmcbsp->max_rx_thres = max_thres(mcbsp) - 0x10;\n\n\t\tret = devm_device_add_group(mcbsp->dev, &additional_attr_group);\n\t\tif (ret) {\n\t\t\tdev_err(mcbsp->dev,\n\t\t\t\t\"Unable to create additional controls\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn omap_mcbsp_st_init(pdev);\n}\n\n \nstatic void omap_mcbsp_set_threshold(struct snd_pcm_substream *substream,\n\t\tunsigned int packet_size)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint words;\n\n\t \n\tif (mcbsp->pdata->buffer_size == 0)\n\t\treturn;\n\n\t \n\tif (packet_size)\n\t\twords = packet_size;\n\telse\n\t\twords = 1;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tomap_mcbsp_set_tx_threshold(mcbsp, words);\n\telse\n\t\tomap_mcbsp_set_rx_threshold(mcbsp, words);\n}\n\nstatic int omap_mcbsp_hwrule_min_buffersize(struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *buffer_size = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_BUFFER_SIZE);\n\tstruct snd_interval *channels = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS);\n\tstruct omap_mcbsp *mcbsp = rule->private;\n\tstruct snd_interval frames;\n\tint size;\n\n\tsnd_interval_any(&frames);\n\tsize = mcbsp->pdata->buffer_size;\n\n\tframes.min = size / channels->min;\n\tframes.integer = 1;\n\treturn snd_interval_refine(buffer_size, &frames);\n}\n\nstatic int omap_mcbsp_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *cpu_dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint err = 0;\n\n\tif (!snd_soc_dai_active(cpu_dai))\n\t\terr = omap_mcbsp_request(mcbsp);\n\n\t \n\tif (mcbsp->pdata->buffer_size) {\n\t\t \n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsnd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_BUFFER_SIZE,\n\t\t\t\t\t    omap_mcbsp_hwrule_min_buffersize,\n\t\t\t\t\t    mcbsp,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\n\t\t \n\t\tsnd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_PERIOD_SIZE, 2);\n\t}\n\n\treturn err;\n}\n\nstatic void omap_mcbsp_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *cpu_dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint tx = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint stream1 = tx ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\n\tint stream2 = tx ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\n\tif (mcbsp->latency[stream2])\n\t\tcpu_latency_qos_update_request(&mcbsp->pm_qos_req,\n\t\t\t\t\t       mcbsp->latency[stream2]);\n\telse if (mcbsp->latency[stream1])\n\t\tcpu_latency_qos_remove_request(&mcbsp->pm_qos_req);\n\n\tmcbsp->latency[stream1] = 0;\n\n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tomap_mcbsp_free(mcbsp);\n\t\tmcbsp->configured = 0;\n\t}\n}\n\nstatic int omap_mcbsp_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *cpu_dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct pm_qos_request *pm_qos_req = &mcbsp->pm_qos_req;\n\tint tx = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint stream1 = tx ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\n\tint stream2 = tx ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\tint latency = mcbsp->latency[stream2];\n\n\t \n\tif (!latency || mcbsp->latency[stream1] < latency)\n\t\tlatency = mcbsp->latency[stream1];\n\n\tif (cpu_latency_qos_request_active(pm_qos_req))\n\t\tcpu_latency_qos_update_request(pm_qos_req, latency);\n\telse if (latency)\n\t\tcpu_latency_qos_add_request(pm_qos_req, latency);\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t  struct snd_soc_dai *cpu_dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tmcbsp->active++;\n\t\tomap_mcbsp_start(mcbsp, substream->stream);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tomap_mcbsp_stop(mcbsp, substream->stream);\n\t\tmcbsp->active--;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic snd_pcm_sframes_t omap_mcbsp_dai_delay(\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tu16 fifo_use;\n\tsnd_pcm_sframes_t delay;\n\n\t \n\tif (mcbsp->pdata->buffer_size == 0)\n\t\treturn 0;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tfifo_use = omap_mcbsp_get_tx_delay(mcbsp);\n\telse\n\t\tfifo_use = omap_mcbsp_get_rx_delay(mcbsp);\n\n\t \n\tdelay = fifo_use / substream->runtime->channels;\n\n\treturn delay;\n}\n\nstatic int omap_mcbsp_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *cpu_dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tint wlen, channels, wpf;\n\tint pkt_size = 0;\n\tunsigned int format, div, framesize, master;\n\tunsigned int buffer_size = mcbsp->pdata->buffer_size;\n\n\tdma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);\n\tchannels = params_channels(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\twlen = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\twlen = 32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (buffer_size) {\n\t\tint latency;\n\n\t\tif (mcbsp->dma_op_mode == MCBSP_DMA_MODE_THRESHOLD) {\n\t\t\tint period_words, max_thrsh;\n\t\t\tint divider = 0;\n\n\t\t\tperiod_words = params_period_bytes(params) / (wlen / 8);\n\t\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\t\tmax_thrsh = mcbsp->max_tx_thres;\n\t\t\telse\n\t\t\t\tmax_thrsh = mcbsp->max_rx_thres;\n\t\t\t \n\t\t\tdivider = period_words / max_thrsh;\n\t\t\tif (period_words % max_thrsh)\n\t\t\t\tdivider++;\n\t\t\twhile (period_words % divider &&\n\t\t\t\tdivider < period_words)\n\t\t\t\tdivider++;\n\t\t\tif (divider == period_words)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tpkt_size = period_words / divider;\n\t\t} else if (channels > 1) {\n\t\t\t \n\t\t\tpkt_size = channels;\n\t\t}\n\n\t\tlatency = (buffer_size - pkt_size) / channels;\n\t\tlatency = latency * USEC_PER_SEC /\n\t\t\t  (params->rate_num / params->rate_den);\n\t\tmcbsp->latency[substream->stream] = latency;\n\n\t\tomap_mcbsp_set_threshold(substream, pkt_size);\n\t}\n\n\tdma_data->maxburst = pkt_size;\n\n\tif (mcbsp->configured) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tregs->rcr2\t&= ~(RPHASE | RFRLEN2(0x7f) | RWDLEN2(7));\n\tregs->xcr2\t&= ~(RPHASE | XFRLEN2(0x7f) | XWDLEN2(7));\n\tregs->rcr1\t&= ~(RFRLEN1(0x7f) | RWDLEN1(7));\n\tregs->xcr1\t&= ~(XFRLEN1(0x7f) | XWDLEN1(7));\n\tformat = mcbsp->fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\twpf = channels;\n\tif (channels == 2 && (format == SND_SOC_DAIFMT_I2S ||\n\t\t\t      format == SND_SOC_DAIFMT_LEFT_J)) {\n\t\t \n\t\tregs->rcr2\t|= RPHASE;\n\t\tregs->xcr2\t|= XPHASE;\n\t\t \n\t\twpf--;\n\t\tregs->rcr2\t|= RFRLEN2(wpf - 1);\n\t\tregs->xcr2\t|= XFRLEN2(wpf - 1);\n\t}\n\n\tregs->rcr1\t|= RFRLEN1(wpf - 1);\n\tregs->xcr1\t|= XFRLEN1(wpf - 1);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t \n\t\tregs->rcr2\t|= RWDLEN2(OMAP_MCBSP_WORD_16);\n\t\tregs->rcr1\t|= RWDLEN1(OMAP_MCBSP_WORD_16);\n\t\tregs->xcr2\t|= XWDLEN2(OMAP_MCBSP_WORD_16);\n\t\tregs->xcr1\t|= XWDLEN1(OMAP_MCBSP_WORD_16);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t \n\t\tregs->rcr2\t|= RWDLEN2(OMAP_MCBSP_WORD_32);\n\t\tregs->rcr1\t|= RWDLEN1(OMAP_MCBSP_WORD_32);\n\t\tregs->xcr2\t|= XWDLEN2(OMAP_MCBSP_WORD_32);\n\t\tregs->xcr1\t|= XWDLEN1(OMAP_MCBSP_WORD_32);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmaster = mcbsp->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tif (master == SND_SOC_DAIFMT_BP_FP) {\n\t\tdiv = mcbsp->clk_div ? mcbsp->clk_div : 1;\n\t\tframesize = (mcbsp->in_freq / div) / params_rate(params);\n\n\t\tif (framesize < wlen * channels) {\n\t\t\tprintk(KERN_ERR \"%s: not enough bandwidth for desired rate and \"\n\t\t\t\t\t\"channels\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tframesize = wlen * channels;\n\n\t \n\tregs->srgr2\t&= ~FPER(0xfff);\n\tregs->srgr1\t&= ~FWID(0xff);\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tregs->srgr2\t|= FPER(framesize - 1);\n\t\tregs->srgr1\t|= FWID((framesize >> 1) - 1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tregs->srgr2\t|= FPER(framesize - 1);\n\t\tregs->srgr1\t|= FWID(0);\n\t\tbreak;\n\t}\n\n\tomap_mcbsp_config(mcbsp, &mcbsp->cfg_regs);\n\tmcbsp->wlen = wlen;\n\tmcbsp->configured = 1;\n\n\treturn 0;\n}\n\n \nstatic int omap_mcbsp_dai_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t      unsigned int fmt)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\n\tbool inv_fs = false;\n\n\tif (mcbsp->configured)\n\t\treturn 0;\n\n\tmcbsp->fmt = fmt;\n\tmemset(regs, 0, sizeof(*regs));\n\t \n\tregs->spcr2\t|= XINTM(3) | FREE;\n\tregs->spcr1\t|= RINTM(3);\n\t \n\tif (!mcbsp->pdata->has_ccr) {\n\t\tregs->rcr2\t|= RFIG;\n\t\tregs->xcr2\t|= XFIG;\n\t}\n\n\t \n\tif (mcbsp->pdata->has_ccr) {\n\t\tregs->xccr = DXENDLY(1) | XDMAEN | XDISABLE;\n\t\tregs->rccr = RFULL_CYCLE | RDMAEN | RDISABLE;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tregs->rcr2\t|= RDATDLY(1);\n\t\tregs->xcr2\t|= XDATDLY(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\tregs->rcr2\t|= RDATDLY(0);\n\t\tregs->xcr2\t|= XDATDLY(0);\n\t\tregs->spcr1\t|= RJUST(2);\n\t\t \n\t\tinv_fs = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\tregs->rcr2      |= RDATDLY(1);\n\t\tregs->xcr2      |= XDATDLY(1);\n\t\t \n\t\tinv_fs = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tregs->rcr2      |= RDATDLY(0);\n\t\tregs->xcr2      |= XDATDLY(0);\n\t\t \n\t\tinv_fs = true;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tregs->pcr0\t|= FSXM | FSRM |\n\t\t\t\t   CLKXM | CLKRM;\n\t\t \n\t\tregs->srgr2\t|= FSGM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t \n\t\tregs->srgr2\t|= FSGM;\n\t\tregs->pcr0\t|= FSXM | FSRM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tregs->pcr0\t|= FSXP | FSRP |\n\t\t\t\t   CLKXP | CLKRP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tregs->pcr0\t|= CLKXP | CLKRP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tregs->pcr0\t|= FSXP | FSRP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (inv_fs)\n\t\tregs->pcr0 ^= FSXP | FSRP;\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_dai_set_clkdiv(struct snd_soc_dai *cpu_dai,\n\t\t\t\t     int div_id, int div)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\n\n\tif (div_id != OMAP_MCBSP_CLKGDV)\n\t\treturn -ENODEV;\n\n\tmcbsp->clk_div = div;\n\tregs->srgr1\t&= ~CLKGDV(0xff);\n\tregs->srgr1\t|= CLKGDV(div - 1);\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_dai_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\n\t\t\t\t\t int clk_id, unsigned int freq,\n\t\t\t\t\t int dir)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct omap_mcbsp_reg_cfg *regs = &mcbsp->cfg_regs;\n\tint err = 0;\n\n\tif (mcbsp->active) {\n\t\tif (freq == mcbsp->in_freq)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EBUSY;\n\t}\n\n\tmcbsp->in_freq = freq;\n\tregs->srgr2 &= ~CLKSM;\n\tregs->pcr0 &= ~SCLKME;\n\n\tswitch (clk_id) {\n\tcase OMAP_MCBSP_SYSCLK_CLK:\n\t\tregs->srgr2\t|= CLKSM;\n\t\tbreak;\n\tcase OMAP_MCBSP_SYSCLK_CLKS_FCLK:\n\t\tif (mcbsp_omap1()) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\terr = omap2_mcbsp_set_clks_src(mcbsp,\n\t\t\t\t\t       MCBSP_CLKS_PRCM_SRC);\n\t\tbreak;\n\tcase OMAP_MCBSP_SYSCLK_CLKS_EXT:\n\t\tif (mcbsp_omap1()) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t\terr = omap2_mcbsp_set_clks_src(mcbsp,\n\t\t\t\t\t       MCBSP_CLKS_PAD_SRC);\n\t\tbreak;\n\n\tcase OMAP_MCBSP_SYSCLK_CLKX_EXT:\n\t\tregs->srgr2\t|= CLKSM;\n\t\tregs->pcr0\t|= SCLKME;\n\t\t \n\t\tregs->pcr0\t&= ~CLKXM;\n\t\tbreak;\n\tcase OMAP_MCBSP_SYSCLK_CLKR_EXT:\n\t\tregs->pcr0\t|= SCLKME;\n\t\t \n\t\tregs->pcr0\t&= ~CLKRM;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t}\n\n\treturn err;\n}\n\nstatic int omap_mcbsp_probe(struct snd_soc_dai *dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(dai);\n\n\tpm_runtime_enable(mcbsp->dev);\n\n\tsnd_soc_dai_init_dma_data(dai,\n\t\t\t\t  &mcbsp->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t  &mcbsp->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_remove(struct snd_soc_dai *dai)\n{\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(dai);\n\n\tpm_runtime_disable(mcbsp->dev);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mcbsp_dai_ops = {\n\t.probe\t\t= omap_mcbsp_probe,\n\t.remove\t\t= omap_mcbsp_remove,\n\t.startup\t= omap_mcbsp_dai_startup,\n\t.shutdown\t= omap_mcbsp_dai_shutdown,\n\t.prepare\t= omap_mcbsp_dai_prepare,\n\t.trigger\t= omap_mcbsp_dai_trigger,\n\t.delay\t\t= omap_mcbsp_dai_delay,\n\t.hw_params\t= omap_mcbsp_dai_hw_params,\n\t.set_fmt\t= omap_mcbsp_dai_set_dai_fmt,\n\t.set_clkdiv\t= omap_mcbsp_dai_set_clkdiv,\n\t.set_sysclk\t= omap_mcbsp_dai_set_dai_sysclk,\n};\n\nstatic struct snd_soc_dai_driver omap_mcbsp_dai = {\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t\t.rates = OMAP_MCBSP_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 16,\n\t\t.rates = OMAP_MCBSP_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.ops = &mcbsp_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver omap_mcbsp_component = {\n\t.name\t\t\t= \"omap-mcbsp\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic struct omap_mcbsp_platform_data omap2420_pdata = {\n\t.reg_step = 4,\n\t.reg_size = 2,\n};\n\nstatic struct omap_mcbsp_platform_data omap2430_pdata = {\n\t.reg_step = 4,\n\t.reg_size = 4,\n\t.has_ccr = true,\n};\n\nstatic struct omap_mcbsp_platform_data omap3_pdata = {\n\t.reg_step = 4,\n\t.reg_size = 4,\n\t.has_ccr = true,\n\t.has_wakeup = true,\n};\n\nstatic struct omap_mcbsp_platform_data omap4_pdata = {\n\t.reg_step = 4,\n\t.reg_size = 4,\n\t.has_ccr = true,\n\t.has_wakeup = true,\n};\n\nstatic const struct of_device_id omap_mcbsp_of_match[] = {\n\t{\n\t\t.compatible = \"ti,omap2420-mcbsp\",\n\t\t.data = &omap2420_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap2430-mcbsp\",\n\t\t.data = &omap2430_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-mcbsp\",\n\t\t.data = &omap3_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4-mcbsp\",\n\t\t.data = &omap4_pdata,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap_mcbsp_of_match);\n\nstatic int asoc_mcbsp_probe(struct platform_device *pdev)\n{\n\tstruct omap_mcbsp_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct omap_mcbsp *mcbsp;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_device(omap_mcbsp_of_match, &pdev->dev);\n\tif (match) {\n\t\tstruct device_node *node = pdev->dev.of_node;\n\t\tstruct omap_mcbsp_platform_data *pdata_quirk = pdata;\n\t\tint buffer_size;\n\n\t\tpdata = devm_kzalloc(&pdev->dev,\n\t\t\t\t     sizeof(struct omap_mcbsp_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(pdata, match->data, sizeof(*pdata));\n\t\tif (!of_property_read_u32(node, \"ti,buffer-size\", &buffer_size))\n\t\t\tpdata->buffer_size = buffer_size;\n\t\tif (pdata_quirk)\n\t\t\tpdata->force_ick_on = pdata_quirk->force_ick_on;\n\t} else if (!pdata) {\n\t\tdev_err(&pdev->dev, \"missing platform data.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmcbsp = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcbsp), GFP_KERNEL);\n\tif (!mcbsp)\n\t\treturn -ENOMEM;\n\n\tmcbsp->id = pdev->id;\n\tmcbsp->pdata = pdata;\n\tmcbsp->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, mcbsp);\n\n\tret = omap_mcbsp_init(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mcbsp->pdata->reg_size == 2) {\n\t\tomap_mcbsp_dai.playback.formats = SNDRV_PCM_FMTBIT_S16_LE;\n\t\tomap_mcbsp_dai.capture.formats = SNDRV_PCM_FMTBIT_S16_LE;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &omap_mcbsp_component,\n\t\t\t\t\t      &omap_mcbsp_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdma_pcm_platform_register(&pdev->dev, \"tx\", \"rx\");\n}\n\nstatic void asoc_mcbsp_remove(struct platform_device *pdev)\n{\n\tstruct omap_mcbsp *mcbsp = platform_get_drvdata(pdev);\n\n\tif (mcbsp->pdata->ops && mcbsp->pdata->ops->free)\n\t\tmcbsp->pdata->ops->free(mcbsp->id);\n\n\tif (cpu_latency_qos_request_active(&mcbsp->pm_qos_req))\n\t\tcpu_latency_qos_remove_request(&mcbsp->pm_qos_req);\n}\n\nstatic struct platform_driver asoc_mcbsp_driver = {\n\t.driver = {\n\t\t\t.name = \"omap-mcbsp\",\n\t\t\t.of_match_table = omap_mcbsp_of_match,\n\t},\n\n\t.probe = asoc_mcbsp_probe,\n\t.remove_new = asoc_mcbsp_remove,\n};\n\nmodule_platform_driver(asoc_mcbsp_driver);\n\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@bitmer.com>\");\nMODULE_DESCRIPTION(\"OMAP I2S SoC Interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap-mcbsp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}