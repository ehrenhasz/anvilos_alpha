{
  "module_name": "omap-dmic.c",
  "hash_id": "4632e43198dc0aba7478dca5013b368cae07e0550e3bbd19f725985db8ba7715",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-dmic.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/of_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"omap-dmic.h\"\n#include \"sdma-pcm.h\"\n\nstruct omap_dmic {\n\tstruct device *dev;\n\tvoid __iomem *io_base;\n\tstruct clk *fclk;\n\tstruct pm_qos_request pm_qos_req;\n\tint latency;\n\tint fclk_freq;\n\tint out_freq;\n\tint clk_div;\n\tint sysclk;\n\tint threshold;\n\tu32 ch_enabled;\n\tbool active;\n\tstruct mutex mutex;\n\n\tstruct snd_dmaengine_dai_dma_data dma_data;\n};\n\nstatic inline void omap_dmic_write(struct omap_dmic *dmic, u16 reg, u32 val)\n{\n\twritel_relaxed(val, dmic->io_base + reg);\n}\n\nstatic inline int omap_dmic_read(struct omap_dmic *dmic, u16 reg)\n{\n\treturn readl_relaxed(dmic->io_base + reg);\n}\n\nstatic inline void omap_dmic_start(struct omap_dmic *dmic)\n{\n\tu32 ctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\n\n\t \n\tomap_dmic_write(dmic, OMAP_DMIC_DMAENABLE_SET_REG,\n\t\t\tOMAP_DMIC_DMA_ENABLE);\n\n\tomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, ctrl | dmic->ch_enabled);\n}\n\nstatic inline void omap_dmic_stop(struct omap_dmic *dmic)\n{\n\tu32 ctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\n\tomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG,\n\t\t\tctrl & ~OMAP_DMIC_UP_ENABLE_MASK);\n\n\t \n\tomap_dmic_write(dmic, OMAP_DMIC_DMAENABLE_CLR_REG,\n\t\t\tOMAP_DMIC_DMA_ENABLE);\n\n}\n\nstatic inline int dmic_is_enabled(struct omap_dmic *dmic)\n{\n\treturn omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG) &\n\t\t\t\t\t\tOMAP_DMIC_UP_ENABLE_MASK;\n}\n\nstatic int omap_dmic_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\n\tmutex_lock(&dmic->mutex);\n\n\tif (!snd_soc_dai_active(dai))\n\t\tdmic->active = 1;\n\telse\n\t\tret = -EBUSY;\n\n\tmutex_unlock(&dmic->mutex);\n\n\treturn ret;\n}\n\nstatic void omap_dmic_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\n\tmutex_lock(&dmic->mutex);\n\n\tcpu_latency_qos_remove_request(&dmic->pm_qos_req);\n\n\tif (!snd_soc_dai_active(dai))\n\t\tdmic->active = 0;\n\n\tmutex_unlock(&dmic->mutex);\n}\n\nstatic int omap_dmic_select_divider(struct omap_dmic *dmic, int sample_rate)\n{\n\tint divider = -EINVAL;\n\n\t \n\tif (sample_rate == 192000) {\n\t\tif (dmic->fclk_freq == 19200000 && dmic->out_freq == 3840000)\n\t\t\tdivider = 0x6;  \n\t\telse\n\t\t\tdev_err(dmic->dev,\n\t\t\t\t\"invalid clock configuration for 192KHz\\n\");\n\n\t\treturn divider;\n\t}\n\n\tswitch (dmic->out_freq) {\n\tcase 1536000:\n\t\tif (dmic->fclk_freq != 24576000)\n\t\t\tgoto div_err;\n\t\tdivider = 0x4;  \n\t\tbreak;\n\tcase 2400000:\n\t\tswitch (dmic->fclk_freq) {\n\t\tcase 12000000:\n\t\t\tdivider = 0x5;  \n\t\t\tbreak;\n\t\tcase 19200000:\n\t\t\tdivider = 0x0;  \n\t\t\tbreak;\n\t\tcase 24000000:\n\t\t\tdivider = 0x2;  \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto div_err;\n\t\t}\n\t\tbreak;\n\tcase 3072000:\n\t\tif (dmic->fclk_freq != 24576000)\n\t\t\tgoto div_err;\n\t\tdivider = 0x3;  \n\t\tbreak;\n\tcase 3840000:\n\t\tif (dmic->fclk_freq != 19200000)\n\t\t\tgoto div_err;\n\t\tdivider = 0x1;  \n\t\tbreak;\n\tdefault:\n\t\tdev_err(dmic->dev, \"invalid out frequency: %dHz\\n\",\n\t\t\tdmic->out_freq);\n\t\tbreak;\n\t}\n\n\treturn divider;\n\ndiv_err:\n\tdev_err(dmic->dev, \"invalid out frequency %dHz for %dHz input\\n\",\n\t\tdmic->out_freq, dmic->fclk_freq);\n\treturn -EINVAL;\n}\n\nstatic int omap_dmic_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tint channels;\n\n\tdmic->clk_div = omap_dmic_select_divider(dmic, params_rate(params));\n\tif (dmic->clk_div < 0) {\n\t\tdev_err(dmic->dev, \"no valid divider for %dHz from %dHz\\n\",\n\t\t\tdmic->out_freq, dmic->fclk_freq);\n\t\treturn -EINVAL;\n\t}\n\n\tdmic->ch_enabled = 0;\n\tchannels = params_channels(params);\n\tswitch (channels) {\n\tcase 6:\n\t\tdmic->ch_enabled |= OMAP_DMIC_UP3_ENABLE;\n\t\tfallthrough;\n\tcase 4:\n\t\tdmic->ch_enabled |= OMAP_DMIC_UP2_ENABLE;\n\t\tfallthrough;\n\tcase 2:\n\t\tdmic->ch_enabled |= OMAP_DMIC_UP1_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dmic->dev, \"invalid number of legacy channels\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdma_data = snd_soc_dai_get_dma_data(dai, substream);\n\tdma_data->maxburst = dmic->threshold * channels;\n\tdmic->latency = (OMAP_DMIC_THRES_MAX - dmic->threshold) * USEC_PER_SEC /\n\t\t\tparams_rate(params);\n\n\treturn 0;\n}\n\nstatic int omap_dmic_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\tu32 ctrl;\n\n\tif (cpu_latency_qos_request_active(&dmic->pm_qos_req))\n\t\tcpu_latency_qos_update_request(&dmic->pm_qos_req,\n\t\t\t\t\t       dmic->latency);\n\n\t \n\tomap_dmic_write(dmic, OMAP_DMIC_FIFO_CTRL_REG, dmic->threshold);\n\n\tctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\n\n\t \n\tctrl &= ~(OMAP_DMIC_FORMAT | OMAP_DMIC_POLAR_MASK);\n\tctrl |= (OMAP_DMICOUTFORMAT_LJUST | OMAP_DMIC_POLAR1 |\n\t\t OMAP_DMIC_POLAR2 | OMAP_DMIC_POLAR3);\n\n\t \n\tctrl &= ~OMAP_DMIC_CLK_DIV_MASK;\n\tctrl |= OMAP_DMIC_CLK_DIV(dmic->clk_div);\n\n\tomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, ctrl);\n\n\tomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG,\n\t\t\tctrl | OMAP_DMICOUTFORMAT_LJUST | OMAP_DMIC_POLAR1 |\n\t\t\tOMAP_DMIC_POLAR2 | OMAP_DMIC_POLAR3);\n\n\treturn 0;\n}\n\nstatic int omap_dmic_dai_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t  int cmd, struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tomap_dmic_start(dmic);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tomap_dmic_stop(dmic);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_dmic_select_fclk(struct omap_dmic *dmic, int clk_id,\n\t\t\t\t unsigned int freq)\n{\n\tstruct clk *parent_clk, *mux;\n\tchar *parent_clk_name;\n\tint ret = 0;\n\n\tswitch (freq) {\n\tcase 12000000:\n\tcase 19200000:\n\tcase 24000000:\n\tcase 24576000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dmic->dev, \"invalid input frequency: %dHz\\n\", freq);\n\t\tdmic->fclk_freq = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tif (dmic->sysclk == clk_id) {\n\t\tdmic->fclk_freq = freq;\n\t\treturn 0;\n\t}\n\n\t \n\tif (dmic->active && dmic_is_enabled(dmic)) {\n\t\tdev_err(dmic->dev, \"can't re-parent when DMIC active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (clk_id) {\n\tcase OMAP_DMIC_SYSCLK_PAD_CLKS:\n\t\tparent_clk_name = \"pad_clks_ck\";\n\t\tbreak;\n\tcase OMAP_DMIC_SYSCLK_SLIMBLUS_CLKS:\n\t\tparent_clk_name = \"slimbus_clk\";\n\t\tbreak;\n\tcase OMAP_DMIC_SYSCLK_SYNC_MUX_CLKS:\n\t\tparent_clk_name = \"dmic_sync_mux_ck\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dmic->dev, \"fclk clk_id (%d) not supported\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tparent_clk = clk_get(dmic->dev, parent_clk_name);\n\tif (IS_ERR(parent_clk)) {\n\t\tdev_err(dmic->dev, \"can't get %s\\n\", parent_clk_name);\n\t\treturn -ENODEV;\n\t}\n\n\tmux = clk_get_parent(dmic->fclk);\n\tif (IS_ERR(mux)) {\n\t\tdev_err(dmic->dev, \"can't get fck mux parent\\n\");\n\t\tclk_put(parent_clk);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_lock(&dmic->mutex);\n\tif (dmic->active) {\n\t\t \n\t\tpm_runtime_put_sync(dmic->dev);\n\t\tret = clk_set_parent(mux, parent_clk);\n\t\tpm_runtime_get_sync(dmic->dev);\n\t} else {\n\t\tret = clk_set_parent(mux, parent_clk);\n\t}\n\tmutex_unlock(&dmic->mutex);\n\n\tif (ret < 0) {\n\t\tdev_err(dmic->dev, \"re-parent failed\\n\");\n\t\tgoto err_busy;\n\t}\n\n\tdmic->sysclk = clk_id;\n\tdmic->fclk_freq = freq;\n\nerr_busy:\n\tclk_put(mux);\n\tclk_put(parent_clk);\n\n\treturn ret;\n}\n\nstatic int omap_dmic_select_outclk(struct omap_dmic *dmic, int clk_id,\n\t\t\t\t    unsigned int freq)\n{\n\tint ret = 0;\n\n\tif (clk_id != OMAP_DMIC_ABE_DMIC_CLK) {\n\t\tdev_err(dmic->dev, \"output clk_id (%d) not supported\\n\",\n\t\t\tclk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 1536000:\n\tcase 2400000:\n\tcase 3072000:\n\tcase 3840000:\n\t\tdmic->out_freq = freq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dmic->dev, \"invalid out frequency: %dHz\\n\", freq);\n\t\tdmic->out_freq = 0;\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int omap_dmic_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t    unsigned int freq, int dir)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\n\tif (dir == SND_SOC_CLOCK_IN)\n\t\treturn omap_dmic_select_fclk(dmic, clk_id, freq);\n\telse if (dir == SND_SOC_CLOCK_OUT)\n\t\treturn omap_dmic_select_outclk(dmic, clk_id, freq);\n\n\tdev_err(dmic->dev, \"invalid clock direction (%d)\\n\", dir);\n\treturn -EINVAL;\n}\n\nstatic int omap_dmic_probe(struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\n\tpm_runtime_enable(dmic->dev);\n\n\t \n\tpm_runtime_get_sync(dmic->dev);\n\tomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, 0x00);\n\tpm_runtime_put_sync(dmic->dev);\n\n\t \n\tdmic->threshold = OMAP_DMIC_THRES_MAX - 3;\n\n\tsnd_soc_dai_init_dma_data(dai, NULL, &dmic->dma_data);\n\n\treturn 0;\n}\n\nstatic int omap_dmic_remove(struct snd_soc_dai *dai)\n{\n\tstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\n\n\tpm_runtime_disable(dmic->dev);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops omap_dmic_dai_ops = {\n\t.probe\t\t= omap_dmic_probe,\n\t.remove\t\t= omap_dmic_remove,\n\t.startup\t= omap_dmic_dai_startup,\n\t.shutdown\t= omap_dmic_dai_shutdown,\n\t.hw_params\t= omap_dmic_dai_hw_params,\n\t.prepare\t= omap_dmic_dai_prepare,\n\t.trigger\t= omap_dmic_dai_trigger,\n\t.set_sysclk\t= omap_dmic_set_dai_sysclk,\n};\n\nstatic struct snd_soc_dai_driver omap_dmic_dai = {\n\t.name = \"omap-dmic\",\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 6,\n\t\t.rates = SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &omap_dmic_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver omap_dmic_component = {\n\t.name\t\t\t= \"omap-dmic\",\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int asoc_dmic_probe(struct platform_device *pdev)\n{\n\tstruct omap_dmic *dmic;\n\tstruct resource *res;\n\tint ret;\n\n\tdmic = devm_kzalloc(&pdev->dev, sizeof(struct omap_dmic), GFP_KERNEL);\n\tif (!dmic)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dmic);\n\tdmic->dev = &pdev->dev;\n\tdmic->sysclk = OMAP_DMIC_SYSCLK_SYNC_MUX_CLKS;\n\n\tmutex_init(&dmic->mutex);\n\n\tdmic->fclk = devm_clk_get(dmic->dev, \"fck\");\n\tif (IS_ERR(dmic->fclk)) {\n\t\tdev_err(dmic->dev, \"can't get fck\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dma\");\n\tif (!res) {\n\t\tdev_err(dmic->dev, \"invalid dma memory resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdmic->dma_data.addr = res->start + OMAP_DMIC_DATA_REG;\n\n\tdmic->dma_data.filter_data = \"up_link\";\n\n\tdmic->io_base = devm_platform_ioremap_resource_byname(pdev, \"mpu\");\n\tif (IS_ERR(dmic->io_base))\n\t\treturn PTR_ERR(dmic->io_base);\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &omap_dmic_component,\n\t\t\t\t\t      &omap_dmic_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdma_pcm_platform_register(&pdev->dev, NULL, \"up_link\");\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id omap_dmic_of_match[] = {\n\t{ .compatible = \"ti,omap4-dmic\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, omap_dmic_of_match);\n\nstatic struct platform_driver asoc_dmic_driver = {\n\t.driver = {\n\t\t.name = \"omap-dmic\",\n\t\t.of_match_table = omap_dmic_of_match,\n\t},\n\t.probe = asoc_dmic_probe,\n};\n\nmodule_platform_driver(asoc_dmic_driver);\n\nMODULE_ALIAS(\"platform:omap-dmic\");\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"OMAP DMIC ASoC Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}