{
  "module_name": "davinci-i2s.c",
  "hash_id": "652e45a8fa480bb0ee3032c2e3e74b44bf0ad02f0d00a5bf72adc442e87562d2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/davinci-i2s.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/platform_data/davinci_asp.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"edma-pcm.h\"\n#include \"davinci-i2s.h\"\n\n#define DRV_NAME \"davinci-i2s\"\n\n \n#define DAVINCI_MCBSP_DRR_REG\t0x00\n#define DAVINCI_MCBSP_DXR_REG\t0x04\n#define DAVINCI_MCBSP_SPCR_REG\t0x08\n#define DAVINCI_MCBSP_RCR_REG\t0x0c\n#define DAVINCI_MCBSP_XCR_REG\t0x10\n#define DAVINCI_MCBSP_SRGR_REG\t0x14\n#define DAVINCI_MCBSP_PCR_REG\t0x24\n\n#define DAVINCI_MCBSP_SPCR_RRST\t\t(1 << 0)\n#define DAVINCI_MCBSP_SPCR_RINTM(v)\t((v) << 4)\n#define DAVINCI_MCBSP_SPCR_XRST\t\t(1 << 16)\n#define DAVINCI_MCBSP_SPCR_XINTM(v)\t((v) << 20)\n#define DAVINCI_MCBSP_SPCR_GRST\t\t(1 << 22)\n#define DAVINCI_MCBSP_SPCR_FRST\t\t(1 << 23)\n#define DAVINCI_MCBSP_SPCR_FREE\t\t(1 << 25)\n\n#define DAVINCI_MCBSP_RCR_RWDLEN1(v)\t((v) << 5)\n#define DAVINCI_MCBSP_RCR_RFRLEN1(v)\t((v) << 8)\n#define DAVINCI_MCBSP_RCR_RDATDLY(v)\t((v) << 16)\n#define DAVINCI_MCBSP_RCR_RFIG\t\t(1 << 18)\n#define DAVINCI_MCBSP_RCR_RWDLEN2(v)\t((v) << 21)\n#define DAVINCI_MCBSP_RCR_RFRLEN2(v)\t((v) << 24)\n#define DAVINCI_MCBSP_RCR_RPHASE\tBIT(31)\n\n#define DAVINCI_MCBSP_XCR_XWDLEN1(v)\t((v) << 5)\n#define DAVINCI_MCBSP_XCR_XFRLEN1(v)\t((v) << 8)\n#define DAVINCI_MCBSP_XCR_XDATDLY(v)\t((v) << 16)\n#define DAVINCI_MCBSP_XCR_XFIG\t\t(1 << 18)\n#define DAVINCI_MCBSP_XCR_XWDLEN2(v)\t((v) << 21)\n#define DAVINCI_MCBSP_XCR_XFRLEN2(v)\t((v) << 24)\n#define DAVINCI_MCBSP_XCR_XPHASE\tBIT(31)\n\n#define DAVINCI_MCBSP_SRGR_FWID(v)\t((v) << 8)\n#define DAVINCI_MCBSP_SRGR_FPER(v)\t((v) << 16)\n#define DAVINCI_MCBSP_SRGR_FSGM\t\t(1 << 28)\n#define DAVINCI_MCBSP_SRGR_CLKSM\tBIT(29)\n\n#define DAVINCI_MCBSP_PCR_CLKRP\t\t(1 << 0)\n#define DAVINCI_MCBSP_PCR_CLKXP\t\t(1 << 1)\n#define DAVINCI_MCBSP_PCR_FSRP\t\t(1 << 2)\n#define DAVINCI_MCBSP_PCR_FSXP\t\t(1 << 3)\n#define DAVINCI_MCBSP_PCR_SCLKME\t(1 << 7)\n#define DAVINCI_MCBSP_PCR_CLKRM\t\t(1 << 8)\n#define DAVINCI_MCBSP_PCR_CLKXM\t\t(1 << 9)\n#define DAVINCI_MCBSP_PCR_FSRM\t\t(1 << 10)\n#define DAVINCI_MCBSP_PCR_FSXM\t\t(1 << 11)\n\nenum {\n\tDAVINCI_MCBSP_WORD_8 = 0,\n\tDAVINCI_MCBSP_WORD_12,\n\tDAVINCI_MCBSP_WORD_16,\n\tDAVINCI_MCBSP_WORD_20,\n\tDAVINCI_MCBSP_WORD_24,\n\tDAVINCI_MCBSP_WORD_32,\n};\n\nstatic const unsigned char data_type[SNDRV_PCM_FORMAT_S32_LE + 1] = {\n\t[SNDRV_PCM_FORMAT_S8]\t\t= 1,\n\t[SNDRV_PCM_FORMAT_S16_LE]\t= 2,\n\t[SNDRV_PCM_FORMAT_S32_LE]\t= 4,\n};\n\nstatic const unsigned char asp_word_length[SNDRV_PCM_FORMAT_S32_LE + 1] = {\n\t[SNDRV_PCM_FORMAT_S8]\t\t= DAVINCI_MCBSP_WORD_8,\n\t[SNDRV_PCM_FORMAT_S16_LE]\t= DAVINCI_MCBSP_WORD_16,\n\t[SNDRV_PCM_FORMAT_S32_LE]\t= DAVINCI_MCBSP_WORD_32,\n};\n\nstatic const unsigned char double_fmt[SNDRV_PCM_FORMAT_S32_LE + 1] = {\n\t[SNDRV_PCM_FORMAT_S8]\t\t= SNDRV_PCM_FORMAT_S16_LE,\n\t[SNDRV_PCM_FORMAT_S16_LE]\t= SNDRV_PCM_FORMAT_S32_LE,\n};\n\nstruct davinci_mcbsp_dev {\n\tstruct device *dev;\n\tstruct snd_dmaengine_dai_dma_data dma_data[2];\n\tint dma_request[2];\n\tvoid __iomem\t\t\t*base;\n#define MOD_DSP_A\t0\n#define MOD_DSP_B\t1\n\tint\t\t\t\tmode;\n\tu32\t\t\t\tpcr;\n\tstruct clk\t\t\t*clk;\n\t \n\tunsigned enable_channel_combine:1;\n\n\tunsigned int fmt;\n\tint clk_div;\n\tint clk_input_pin;\n\tbool i2s_accurate_sck;\n};\n\nstatic inline void davinci_mcbsp_write_reg(struct davinci_mcbsp_dev *dev,\n\t\t\t\t\t   int reg, u32 val)\n{\n\t__raw_writel(val, dev->base + reg);\n}\n\nstatic inline u32 davinci_mcbsp_read_reg(struct davinci_mcbsp_dev *dev, int reg)\n{\n\treturn __raw_readl(dev->base + reg);\n}\n\nstatic void toggle_clock(struct davinci_mcbsp_dev *dev, int playback)\n{\n\tu32 m = playback ? DAVINCI_MCBSP_PCR_CLKXP : DAVINCI_MCBSP_PCR_CLKRP;\n\t \n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, dev->pcr ^ m);\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, dev->pcr);\n}\n\nstatic void davinci_mcbsp_start(struct davinci_mcbsp_dev *dev,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tint playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tu32 spcr;\n\tu32 mask = playback ? DAVINCI_MCBSP_SPCR_XRST : DAVINCI_MCBSP_SPCR_RRST;\n\n\t \n\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\tspcr |= mask;\n\n\tif (dev->pcr & (DAVINCI_MCBSP_PCR_FSXM | DAVINCI_MCBSP_PCR_FSRM)) {\n\t\t \n\t\tspcr |= DAVINCI_MCBSP_SPCR_FRST;\n\t}\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n}\n\nstatic void davinci_mcbsp_stop(struct davinci_mcbsp_dev *dev, int playback)\n{\n\tu32 spcr;\n\n\t \n\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\tspcr &= ~(DAVINCI_MCBSP_SPCR_GRST | DAVINCI_MCBSP_SPCR_FRST);\n\tspcr &= playback ? ~DAVINCI_MCBSP_SPCR_XRST : ~DAVINCI_MCBSP_SPCR_RRST;\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\ttoggle_clock(dev, playback);\n}\n\n#define DEFAULT_BITPERSAMPLE\t16\n\nstatic int davinci_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t   unsigned int fmt)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\n\tunsigned int pcr;\n\tunsigned int srgr;\n\tbool inv_fs = false;\n\t \n\tsrgr = DAVINCI_MCBSP_SRGR_FSGM |\n\t\tDAVINCI_MCBSP_SRGR_FPER(DEFAULT_BITPERSAMPLE * 2 - 1) |\n\t\tDAVINCI_MCBSP_SRGR_FWID(DEFAULT_BITPERSAMPLE - 1);\n\n\tdev->fmt = fmt;\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tpcr = DAVINCI_MCBSP_PCR_FSXM |\n\t\t\tDAVINCI_MCBSP_PCR_FSRM |\n\t\t\tDAVINCI_MCBSP_PCR_CLKXM |\n\t\t\tDAVINCI_MCBSP_PCR_CLKRM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tpcr = DAVINCI_MCBSP_PCR_FSRM | DAVINCI_MCBSP_PCR_FSXM;\n\t\t \n\t\tswitch (dev->clk_input_pin) {\n\t\tcase MCBSP_CLKS:\n\t\t\tpcr |= DAVINCI_MCBSP_PCR_CLKXM |\n\t\t\t\tDAVINCI_MCBSP_PCR_CLKRM;\n\t\t\tbreak;\n\t\tcase MCBSP_CLKR:\n\t\t\tpcr |= DAVINCI_MCBSP_PCR_SCLKME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev, \"bad clk_input_pin\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tpcr = 0;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s:bad master\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tinv_fs = true;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tdev->mode = MOD_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tdev->mode = MOD_DSP_B;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s:bad format\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tpcr |= (DAVINCI_MCBSP_PCR_CLKXP | DAVINCI_MCBSP_PCR_CLKRP);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t \n\t\tpcr |= (DAVINCI_MCBSP_PCR_FSXP | DAVINCI_MCBSP_PCR_FSRP);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t \n\t\tpcr |= (DAVINCI_MCBSP_PCR_CLKXP | DAVINCI_MCBSP_PCR_CLKRP |\n\t\t\tDAVINCI_MCBSP_PCR_FSXP | DAVINCI_MCBSP_PCR_FSRP);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (inv_fs == true)\n\t\tpcr ^= (DAVINCI_MCBSP_PCR_FSXP | DAVINCI_MCBSP_PCR_FSRP);\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SRGR_REG, srgr);\n\tdev->pcr = pcr;\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_PCR_REG, pcr);\n\treturn 0;\n}\n\nstatic int davinci_i2s_dai_set_clkdiv(struct snd_soc_dai *cpu_dai,\n\t\t\t\tint div_id, int div)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (div_id != DAVINCI_MCBSP_CLKGDV)\n\t\treturn -ENODEV;\n\n\tdev->clk_div = div;\n\treturn 0;\n}\n\nstatic int davinci_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tstruct snd_interval *i = NULL;\n\tint mcbsp_word_length, master;\n\tunsigned int rcr, xcr, srgr, clk_div, freq, framesize;\n\tu32 spcr;\n\tsnd_pcm_format_t fmt;\n\tunsigned element_cnt = 1;\n\n\t \n\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tspcr |= DAVINCI_MCBSP_SPCR_RINTM(3) | DAVINCI_MCBSP_SPCR_FREE;\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\t} else {\n\t\tspcr |= DAVINCI_MCBSP_SPCR_XINTM(3) | DAVINCI_MCBSP_SPCR_FREE;\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\t}\n\n\tmaster = dev->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tfmt = params_format(params);\n\tmcbsp_word_length = asp_word_length[fmt];\n\n\tswitch (master) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tfreq = clk_get_rate(dev->clk);\n\t\tsrgr = DAVINCI_MCBSP_SRGR_FSGM |\n\t\t       DAVINCI_MCBSP_SRGR_CLKSM;\n\t\tsrgr |= DAVINCI_MCBSP_SRGR_FWID(mcbsp_word_length *\n\t\t\t\t\t\t8 - 1);\n\t\tif (dev->i2s_accurate_sck) {\n\t\t\tclk_div = 256;\n\t\t\tdo {\n\t\t\t\tframesize = (freq / (--clk_div)) /\n\t\t\t\tparams->rate_num *\n\t\t\t\t\tparams->rate_den;\n\t\t\t} while (((framesize < 33) || (framesize > 4095)) &&\n\t\t\t\t (clk_div));\n\t\t\tclk_div--;\n\t\t\tsrgr |= DAVINCI_MCBSP_SRGR_FPER(framesize - 1);\n\t\t} else {\n\t\t\t \n\t\t\tclk_div = freq / (mcbsp_word_length * 16) /\n\t\t\t\t  params->rate_num * params->rate_den;\n\t\t\tsrgr |= DAVINCI_MCBSP_SRGR_FPER(mcbsp_word_length *\n\t\t\t\t\t\t\t16 - 1);\n\t\t}\n\t\tclk_div &= 0xFF;\n\t\tsrgr |= clk_div;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\tsrgr = DAVINCI_MCBSP_SRGR_FSGM;\n\t\tclk_div = dev->clk_div - 1;\n\t\tsrgr |= DAVINCI_MCBSP_SRGR_FWID(mcbsp_word_length * 8 - 1);\n\t\tsrgr |= DAVINCI_MCBSP_SRGR_FPER(mcbsp_word_length * 16 - 1);\n\t\tclk_div &= 0xFF;\n\t\tsrgr |= clk_div;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\ti = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS);\n\t\tsrgr = DAVINCI_MCBSP_SRGR_FSGM;\n\t\tsrgr |= DAVINCI_MCBSP_SRGR_FWID(snd_interval_value(i) - 1);\n\t\tpr_debug(\"%s - %d  FWID set: re-read srgr = %X\\n\",\n\t\t\t__func__, __LINE__, snd_interval_value(i) - 1);\n\n\t\ti = hw_param_interval(params, SNDRV_PCM_HW_PARAM_FRAME_BITS);\n\t\tsrgr |= DAVINCI_MCBSP_SRGR_FPER(snd_interval_value(i) - 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SRGR_REG, srgr);\n\n\trcr = DAVINCI_MCBSP_RCR_RFIG;\n\txcr = DAVINCI_MCBSP_XCR_XFIG;\n\tif (dev->mode == MOD_DSP_B) {\n\t\trcr |= DAVINCI_MCBSP_RCR_RDATDLY(0);\n\t\txcr |= DAVINCI_MCBSP_XCR_XDATDLY(0);\n\t} else {\n\t\trcr |= DAVINCI_MCBSP_RCR_RDATDLY(1);\n\t\txcr |= DAVINCI_MCBSP_XCR_XDATDLY(1);\n\t}\n\t \n\tfmt = params_format(params);\n\tif ((fmt > SNDRV_PCM_FORMAT_S32_LE) || !data_type[fmt]) {\n\t\tprintk(KERN_WARNING \"davinci-i2s: unsupported PCM format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_channels(params) == 2) {\n\t\telement_cnt = 2;\n\t\tif (double_fmt[fmt] && dev->enable_channel_combine) {\n\t\t\telement_cnt = 1;\n\t\t\tfmt = double_fmt[fmt];\n\t\t}\n\t\tswitch (master) {\n\t\tcase SND_SOC_DAIFMT_BP_FP:\n\t\tcase SND_SOC_DAIFMT_BP_FC:\n\t\t\trcr |= DAVINCI_MCBSP_RCR_RFRLEN2(0);\n\t\t\txcr |= DAVINCI_MCBSP_XCR_XFRLEN2(0);\n\t\t\trcr |= DAVINCI_MCBSP_RCR_RPHASE;\n\t\t\txcr |= DAVINCI_MCBSP_XCR_XPHASE;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_BC_FC:\n\t\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t\trcr |= DAVINCI_MCBSP_RCR_RFRLEN2(element_cnt - 1);\n\t\t\txcr |= DAVINCI_MCBSP_XCR_XFRLEN2(element_cnt - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tmcbsp_word_length = asp_word_length[fmt];\n\n\tswitch (master) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\trcr |= DAVINCI_MCBSP_RCR_RFRLEN1(0);\n\t\txcr |= DAVINCI_MCBSP_XCR_XFRLEN1(0);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\trcr |= DAVINCI_MCBSP_RCR_RFRLEN1(element_cnt - 1);\n\t\txcr |= DAVINCI_MCBSP_XCR_XFRLEN1(element_cnt - 1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trcr |= DAVINCI_MCBSP_RCR_RWDLEN1(mcbsp_word_length) |\n\t\tDAVINCI_MCBSP_RCR_RWDLEN2(mcbsp_word_length);\n\txcr |= DAVINCI_MCBSP_XCR_XWDLEN1(mcbsp_word_length) |\n\t\tDAVINCI_MCBSP_XCR_XWDLEN2(mcbsp_word_length);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_XCR_REG, xcr);\n\telse\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_RCR_REG, rcr);\n\n\tpr_debug(\"%s - %d  srgr=%X\\n\", __func__, __LINE__, srgr);\n\tpr_debug(\"%s - %d  xcr=%X\\n\", __func__, __LINE__, xcr);\n\tpr_debug(\"%s - %d  rcr=%X\\n\", __func__, __LINE__, rcr);\n\treturn 0;\n}\n\nstatic int davinci_i2s_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tint playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tu32 spcr;\n\tu32 mask = playback ? DAVINCI_MCBSP_SPCR_XRST : DAVINCI_MCBSP_SPCR_RRST;\n\n\tdavinci_mcbsp_stop(dev, playback);\n\n\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\tif (spcr & mask) {\n\t\t \n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG,\n\t\t\t\t\tspcr & ~mask);\n\t\ttoggle_clock(dev, playback);\n\t}\n\tif (dev->pcr & (DAVINCI_MCBSP_PCR_FSXM | DAVINCI_MCBSP_PCR_FSRM |\n\t\t\tDAVINCI_MCBSP_PCR_CLKXM | DAVINCI_MCBSP_PCR_CLKRM)) {\n\t\t \n\t\tspcr |= DAVINCI_MCBSP_SPCR_GRST;\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\t}\n\n\tif (playback) {\n\t\t \n\t\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\t\tspcr |= DAVINCI_MCBSP_SPCR_XRST;\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\n\t\t \n\t\tudelay(100);\n\n\t\t \n\t\tspcr = davinci_mcbsp_read_reg(dev, DAVINCI_MCBSP_SPCR_REG);\n\t\tspcr &= ~DAVINCI_MCBSP_SPCR_XRST;\n\t\tdavinci_mcbsp_write_reg(dev, DAVINCI_MCBSP_SPCR_REG, spcr);\n\t\ttoggle_clock(dev, playback);\n\t}\n\n\treturn 0;\n}\n\nstatic int davinci_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tint ret = 0;\n\tint playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdavinci_mcbsp_start(dev, substream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdavinci_mcbsp_stop(dev, playback);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic void davinci_i2s_shutdown(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tint playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tdavinci_mcbsp_stop(dev, playback);\n}\n\n#define DAVINCI_I2S_RATES\tSNDRV_PCM_RATE_8000_96000\n#define DAVINCI_I2S_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int davinci_i2s_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct davinci_mcbsp_dev *dev = snd_soc_dai_get_drvdata(dai);\n\tint stream;\n\n\tfor_each_pcm_streams(stream)\n\t\tsnd_soc_dai_dma_data_set(dai, stream, &dev->dma_data[stream]);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops davinci_i2s_dai_ops = {\n\t.probe\t\t= davinci_i2s_dai_probe,\n\t.shutdown\t= davinci_i2s_shutdown,\n\t.prepare\t= davinci_i2s_prepare,\n\t.trigger\t= davinci_i2s_trigger,\n\t.hw_params\t= davinci_i2s_hw_params,\n\t.set_fmt\t= davinci_i2s_set_dai_fmt,\n\t.set_clkdiv\t= davinci_i2s_dai_set_clkdiv,\n\n};\n\nstatic struct snd_soc_dai_driver davinci_i2s_dai = {\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = DAVINCI_I2S_RATES,\n\t\t.formats = DAVINCI_I2S_FORMATS,\n\t},\n\t.capture = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = DAVINCI_I2S_RATES,\n\t\t.formats = DAVINCI_I2S_FORMATS,\n\t},\n\t.ops = &davinci_i2s_dai_ops,\n\n};\n\nstatic const struct snd_soc_component_driver davinci_i2s_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.legacy_dai_naming\t= 1,\n};\n\nstatic int davinci_i2s_probe(struct platform_device *pdev)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tstruct davinci_mcbsp_dev *dev;\n\tstruct resource *mem, *res;\n\tvoid __iomem *io_base;\n\tint *dma;\n\tint ret;\n\n\tmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mpu\");\n\tif (!mem) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"\\\"mpu\\\" mem resource not found, using index 0\\n\");\n\t\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!mem) {\n\t\t\tdev_err(&pdev->dev, \"no mem resource?\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tio_base = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(io_base))\n\t\treturn PTR_ERR(io_base);\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_mcbsp_dev),\n\t\t\t   GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->base = io_base;\n\n\t \n\tdma_data = &dev->dma_data[SNDRV_PCM_STREAM_PLAYBACK];\n\tdma_data->addr = (dma_addr_t)(mem->start + DAVINCI_MCBSP_DXR_REG);\n\n\tres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\tif (res) {\n\t\tdma = &dev->dma_request[SNDRV_PCM_STREAM_PLAYBACK];\n\t\t*dma = res->start;\n\t\tdma_data->filter_data = dma;\n\t} else if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tdma_data->filter_data = \"tx\";\n\t} else {\n\t\tdev_err(&pdev->dev, \"Missing DMA tx resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdma_data = &dev->dma_data[SNDRV_PCM_STREAM_CAPTURE];\n\tdma_data->addr = (dma_addr_t)(mem->start + DAVINCI_MCBSP_DRR_REG);\n\n\tres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\n\tif (res) {\n\t\tdma = &dev->dma_request[SNDRV_PCM_STREAM_CAPTURE];\n\t\t*dma = res->start;\n\t\tdma_data->filter_data = dma;\n\t} else if (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tdma_data->filter_data = \"rx\";\n\t} else {\n\t\tdev_err(&pdev->dev, \"Missing DMA rx resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev->clk = clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn -ENODEV;\n\tret = clk_enable(dev->clk);\n\tif (ret)\n\t\tgoto err_put_clk;\n\n\tdev->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, dev);\n\n\tret = snd_soc_register_component(&pdev->dev, &davinci_i2s_component,\n\t\t\t\t\t &davinci_i2s_dai, 1);\n\tif (ret != 0)\n\t\tgoto err_release_clk;\n\n\tret = edma_pcm_platform_register(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"register PCM failed: %d\\n\", ret);\n\t\tgoto err_unregister_component;\n\t}\n\n\treturn 0;\n\nerr_unregister_component:\n\tsnd_soc_unregister_component(&pdev->dev);\nerr_release_clk:\n\tclk_disable(dev->clk);\nerr_put_clk:\n\tclk_put(dev->clk);\n\treturn ret;\n}\n\nstatic void davinci_i2s_remove(struct platform_device *pdev)\n{\n\tstruct davinci_mcbsp_dev *dev = dev_get_drvdata(&pdev->dev);\n\n\tsnd_soc_unregister_component(&pdev->dev);\n\n\tclk_disable(dev->clk);\n\tclk_put(dev->clk);\n\tdev->clk = NULL;\n}\n\nstatic const struct of_device_id davinci_i2s_match[] __maybe_unused = {\n\t{ .compatible = \"ti,da850-mcbsp\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_i2s_match);\n\nstatic struct platform_driver davinci_mcbsp_driver = {\n\t.probe\t\t= davinci_i2s_probe,\n\t.remove_new\t= davinci_i2s_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"davinci-mcbsp\",\n\t\t.of_match_table = of_match_ptr(davinci_i2s_match),\n\t},\n};\n\nmodule_platform_driver(davinci_mcbsp_driver);\n\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_DESCRIPTION(\"TI DAVINCI I2S (McBSP) SoC Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}