{
  "module_name": "omap-mcbsp-st.c",
  "hash_id": "b75012699c2f84c986cd5fbc94908fd528663c563355ff5f4b660065014513b7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-mcbsp-st.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include \"omap-mcbsp.h\"\n#include \"omap-mcbsp-priv.h\"\n\n \n#define OMAP_ST_REG_REV\t\t0x00\n#define OMAP_ST_REG_SYSCONFIG\t0x10\n#define OMAP_ST_REG_IRQSTATUS\t0x18\n#define OMAP_ST_REG_IRQENABLE\t0x1C\n#define OMAP_ST_REG_SGAINCR\t0x24\n#define OMAP_ST_REG_SFIRCR\t0x28\n#define OMAP_ST_REG_SSELCR\t0x2C\n\n \n#define SIDETONEEN\t\tBIT(10)\n\n \n#define ST_AUTOIDLE\t\tBIT(0)\n\n \n#define ST_CH0GAIN(value)\t((value) & 0xffff)\t \n#define ST_CH1GAIN(value)\t(((value) & 0xffff) << 16)  \n\n \n#define ST_FIRCOEFF(value)\t((value) & 0xffff)\t \n\n \n#define ST_SIDETONEEN\t\tBIT(0)\n#define ST_COEFFWREN\t\tBIT(1)\n#define ST_COEFFWRDONE\t\tBIT(2)\n\nstruct omap_mcbsp_st_data {\n\tvoid __iomem *io_base_st;\n\tstruct clk *mcbsp_iclk;\n\tbool running;\n\tbool enabled;\n\ts16 taps[128];\t \n\tint nr_taps;\t \n\ts16 ch0gain;\n\ts16 ch1gain;\n};\n\nstatic void omap_mcbsp_st_write(struct omap_mcbsp *mcbsp, u16 reg, u32 val)\n{\n\twritel_relaxed(val, mcbsp->st_data->io_base_st + reg);\n}\n\nstatic int omap_mcbsp_st_read(struct omap_mcbsp *mcbsp, u16 reg)\n{\n\treturn readl_relaxed(mcbsp->st_data->io_base_st + reg);\n}\n\n#define MCBSP_ST_READ(mcbsp, reg) omap_mcbsp_st_read(mcbsp, OMAP_ST_REG_##reg)\n#define MCBSP_ST_WRITE(mcbsp, reg, val) \\\n\t\t\tomap_mcbsp_st_write(mcbsp, OMAP_ST_REG_##reg, val)\n\nstatic void omap_mcbsp_st_on(struct omap_mcbsp *mcbsp)\n{\n\tunsigned int w;\n\n\tif (mcbsp->pdata->force_ick_on)\n\t\tmcbsp->pdata->force_ick_on(mcbsp->st_data->mcbsp_iclk, true);\n\n\t \n\tw = MCBSP_ST_READ(mcbsp, SYSCONFIG);\n\tMCBSP_ST_WRITE(mcbsp, SYSCONFIG, w & ~(ST_AUTOIDLE));\n\n\t \n\tw = MCBSP_READ(mcbsp, SSELCR);\n\tMCBSP_WRITE(mcbsp, SSELCR, w | SIDETONEEN);\n\n\t \n\tw = MCBSP_ST_READ(mcbsp, SSELCR);\n\tMCBSP_ST_WRITE(mcbsp, SSELCR, w | ST_SIDETONEEN);\n}\n\nstatic void omap_mcbsp_st_off(struct omap_mcbsp *mcbsp)\n{\n\tunsigned int w;\n\n\tw = MCBSP_ST_READ(mcbsp, SSELCR);\n\tMCBSP_ST_WRITE(mcbsp, SSELCR, w & ~(ST_SIDETONEEN));\n\n\tw = MCBSP_READ(mcbsp, SSELCR);\n\tMCBSP_WRITE(mcbsp, SSELCR, w & ~(SIDETONEEN));\n\n\t \n\tw = MCBSP_ST_READ(mcbsp, SYSCONFIG);\n\tMCBSP_ST_WRITE(mcbsp, SYSCONFIG, w | ST_AUTOIDLE);\n\n\tif (mcbsp->pdata->force_ick_on)\n\t\tmcbsp->pdata->force_ick_on(mcbsp->st_data->mcbsp_iclk, false);\n}\n\nstatic void omap_mcbsp_st_fir_write(struct omap_mcbsp *mcbsp, s16 *fir)\n{\n\tu16 val, i;\n\n\tval = MCBSP_ST_READ(mcbsp, SSELCR);\n\n\tif (val & ST_COEFFWREN)\n\t\tMCBSP_ST_WRITE(mcbsp, SSELCR, val & ~(ST_COEFFWREN));\n\n\tMCBSP_ST_WRITE(mcbsp, SSELCR, val | ST_COEFFWREN);\n\n\tfor (i = 0; i < 128; i++)\n\t\tMCBSP_ST_WRITE(mcbsp, SFIRCR, fir[i]);\n\n\ti = 0;\n\n\tval = MCBSP_ST_READ(mcbsp, SSELCR);\n\twhile (!(val & ST_COEFFWRDONE) && (++i < 1000))\n\t\tval = MCBSP_ST_READ(mcbsp, SSELCR);\n\n\tMCBSP_ST_WRITE(mcbsp, SSELCR, val & ~(ST_COEFFWREN));\n\n\tif (i == 1000)\n\t\tdev_err(mcbsp->dev, \"McBSP FIR load error!\\n\");\n}\n\nstatic void omap_mcbsp_st_chgain(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\n\tMCBSP_ST_WRITE(mcbsp, SGAINCR, ST_CH0GAIN(st_data->ch0gain) |\n\t\t       ST_CH1GAIN(st_data->ch1gain));\n}\n\nstatic int omap_mcbsp_st_set_chgain(struct omap_mcbsp *mcbsp, int channel,\n\t\t\t\t    s16 chgain)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\tint ret = 0;\n\n\tif (!st_data)\n\t\treturn -ENOENT;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tif (channel == 0)\n\t\tst_data->ch0gain = chgain;\n\telse if (channel == 1)\n\t\tst_data->ch1gain = chgain;\n\telse\n\t\tret = -EINVAL;\n\n\tif (st_data->enabled)\n\t\tomap_mcbsp_st_chgain(mcbsp);\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn ret;\n}\n\nstatic int omap_mcbsp_st_get_chgain(struct omap_mcbsp *mcbsp, int channel,\n\t\t\t\t    s16 *chgain)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\tint ret = 0;\n\n\tif (!st_data)\n\t\treturn -ENOENT;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tif (channel == 0)\n\t\t*chgain = st_data->ch0gain;\n\telse if (channel == 1)\n\t\t*chgain = st_data->ch1gain;\n\telse\n\t\tret = -EINVAL;\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn ret;\n}\n\nstatic int omap_mcbsp_st_enable(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\n\tif (!st_data)\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tst_data->enabled = 1;\n\tomap_mcbsp_st_start(mcbsp);\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_st_disable(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\tint ret = 0;\n\n\tif (!st_data)\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tomap_mcbsp_st_stop(mcbsp);\n\tst_data->enabled = 0;\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn ret;\n}\n\nstatic int omap_mcbsp_st_is_enabled(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\n\tif (!st_data)\n\t\treturn -ENODEV;\n\n\treturn st_data->enabled;\n}\n\nstatic ssize_t st_taps_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\tssize_t status = 0;\n\tint i;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tfor (i = 0; i < st_data->nr_taps; i++)\n\t\tstatus += sysfs_emit_at(buf, status, (i ? \", %d\" : \"%d\"),\n\t\t\t\t\tst_data->taps[i]);\n\tif (i)\n\t\tstatus += sysfs_emit_at(buf, status, \"\\n\");\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn status;\n}\n\nstatic ssize_t st_taps_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tstruct omap_mcbsp *mcbsp = dev_get_drvdata(dev);\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\tint val, tmp, status, i = 0;\n\n\tspin_lock_irq(&mcbsp->lock);\n\tmemset(st_data->taps, 0, sizeof(st_data->taps));\n\tst_data->nr_taps = 0;\n\n\tdo {\n\t\tstatus = sscanf(buf, \"%d%n\", &val, &tmp);\n\t\tif (status < 0 || status == 0) {\n\t\t\tsize = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (val < -32768 || val > 32767) {\n\t\t\tsize = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tst_data->taps[i++] = val;\n\t\tbuf += tmp;\n\t\tif (*buf != ',')\n\t\t\tbreak;\n\t\tbuf++;\n\t} while (1);\n\n\tst_data->nr_taps = i;\n\nout:\n\tspin_unlock_irq(&mcbsp->lock);\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(st_taps);\n\nstatic const struct attribute *sidetone_attrs[] = {\n\t&dev_attr_st_taps.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sidetone_attr_group = {\n\t.attrs = (struct attribute **)sidetone_attrs,\n};\n\nint omap_mcbsp_st_start(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\n\tif (st_data->enabled && !st_data->running) {\n\t\tomap_mcbsp_st_fir_write(mcbsp, st_data->taps);\n\t\tomap_mcbsp_st_chgain(mcbsp);\n\n\t\tif (!mcbsp->free) {\n\t\t\tomap_mcbsp_st_on(mcbsp);\n\t\t\tst_data->running = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint omap_mcbsp_st_stop(struct omap_mcbsp *mcbsp)\n{\n\tstruct omap_mcbsp_st_data *st_data = mcbsp->st_data;\n\n\tif (st_data->running) {\n\t\tif (!mcbsp->free) {\n\t\t\tomap_mcbsp_st_off(mcbsp);\n\t\t\tst_data->running = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint omap_mcbsp_st_init(struct platform_device *pdev)\n{\n\tstruct omap_mcbsp *mcbsp = platform_get_drvdata(pdev);\n\tstruct omap_mcbsp_st_data *st_data;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"sidetone\");\n\tif (!res)\n\t\treturn 0;\n\n\tst_data = devm_kzalloc(mcbsp->dev, sizeof(*mcbsp->st_data), GFP_KERNEL);\n\tif (!st_data)\n\t\treturn -ENOMEM;\n\n\tst_data->mcbsp_iclk = devm_clk_get(mcbsp->dev, \"ick\");\n\tif (IS_ERR(st_data->mcbsp_iclk)) {\n\t\tdev_warn(mcbsp->dev,\n\t\t\t \"Failed to get ick, sidetone might be broken\\n\");\n\t\tst_data->mcbsp_iclk = NULL;\n\t}\n\n\tst_data->io_base_st = devm_ioremap(mcbsp->dev, res->start,\n\t\t\t\t\t   resource_size(res));\n\tif (!st_data->io_base_st)\n\t\treturn -ENOMEM;\n\n\tret = devm_device_add_group(mcbsp->dev, &sidetone_attr_group);\n\tif (ret)\n\t\treturn ret;\n\n\tmcbsp->st_data = st_data;\n\n\treturn 0;\n}\n\nstatic int omap_mcbsp_st_info_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint max = mc->max;\n\tint min = mc->min;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = min;\n\tuinfo->value.integer.max = max;\n\treturn 0;\n}\n\n#define OMAP_MCBSP_ST_CHANNEL_VOLUME(channel)\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nomap_mcbsp_set_st_ch##channel##_volume(struct snd_kcontrol *kc,\t\t\\\n\t\t\t\t       struct snd_ctl_elem_value *uc)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kc);\t\t\\\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\t\\\n\tstruct soc_mixer_control *mc =\t\t\t\t\t\\\n\t\t(struct soc_mixer_control *)kc->private_value;\t\t\\\n\tint max = mc->max;\t\t\t\t\t\t\\\n\tint min = mc->min;\t\t\t\t\t\t\\\n\tint val = uc->value.integer.value[0];\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (val < min || val > max)\t\t\t\t\t\\\n\t\treturn -EINVAL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\\\n\treturn omap_mcbsp_st_set_chgain(mcbsp, channel, val);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nomap_mcbsp_get_st_ch##channel##_volume(struct snd_kcontrol *kc,\t\t\\\n\t\t\t\t       struct snd_ctl_elem_value *uc)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kc);\t\t\\\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\t\\\n\ts16 chgain;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (omap_mcbsp_st_get_chgain(mcbsp, channel, &chgain))\t\t\\\n\t\treturn -EAGAIN;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tuc->value.integer.value[0] = chgain;\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nOMAP_MCBSP_ST_CHANNEL_VOLUME(0)\nOMAP_MCBSP_ST_CHANNEL_VOLUME(1)\n\nstatic int omap_mcbsp_st_put_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\tu8 value = ucontrol->value.integer.value[0];\n\n\tif (value == omap_mcbsp_st_is_enabled(mcbsp))\n\t\treturn 0;\n\n\tif (value)\n\t\tomap_mcbsp_st_enable(mcbsp);\n\telse\n\t\tomap_mcbsp_st_disable(mcbsp);\n\n\treturn 1;\n}\n\nstatic int omap_mcbsp_st_get_mode(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tucontrol->value.integer.value[0] = omap_mcbsp_st_is_enabled(mcbsp);\n\treturn 0;\n}\n\n#define OMAP_MCBSP_SOC_SINGLE_S16_EXT(xname, xmin, xmax,\t\t\\\n\t\t\t\t      xhandler_get, xhandler_put)\t\\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\t\t\\\n\t.info = omap_mcbsp_st_info_volsw,\t\t\t\t\\\n\t.get = xhandler_get, .put = xhandler_put,\t\t\t\\\n\t.private_value = (unsigned long)&(struct soc_mixer_control)\t\\\n\t{.min = xmin, .max = xmax} }\n\n#define OMAP_MCBSP_ST_CONTROLS(port)\t\t\t\t\t  \\\nstatic const struct snd_kcontrol_new omap_mcbsp##port##_st_controls[] = { \\\nSOC_SINGLE_EXT(\"McBSP\" #port \" Sidetone Switch\", 1, 0, 1, 0,\t\t  \\\n\t       omap_mcbsp_st_get_mode, omap_mcbsp_st_put_mode),\t\t  \\\nOMAP_MCBSP_SOC_SINGLE_S16_EXT(\"McBSP\" #port \" Sidetone Channel 0 Volume\", \\\n\t\t\t      -32768, 32767,\t\t\t\t  \\\n\t\t\t      omap_mcbsp_get_st_ch0_volume,\t\t  \\\n\t\t\t      omap_mcbsp_set_st_ch0_volume),\t\t  \\\nOMAP_MCBSP_SOC_SINGLE_S16_EXT(\"McBSP\" #port \" Sidetone Channel 1 Volume\", \\\n\t\t\t      -32768, 32767,\t\t\t\t  \\\n\t\t\t      omap_mcbsp_get_st_ch1_volume,\t\t  \\\n\t\t\t      omap_mcbsp_set_st_ch1_volume),\t\t  \\\n}\n\nOMAP_MCBSP_ST_CONTROLS(2);\nOMAP_MCBSP_ST_CONTROLS(3);\n\nint omap_mcbsp_st_add_controls(struct snd_soc_pcm_runtime *rtd, int port_id)\n{\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct omap_mcbsp *mcbsp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tif (!mcbsp->st_data) {\n\t\tdev_warn(mcbsp->dev, \"No sidetone data for port\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (port_id) {\n\tcase 2:  \n\t\treturn snd_soc_add_dai_controls(cpu_dai,\n\t\t\t\t\tomap_mcbsp2_st_controls,\n\t\t\t\t\tARRAY_SIZE(omap_mcbsp2_st_controls));\n\tcase 3:  \n\t\treturn snd_soc_add_dai_controls(cpu_dai,\n\t\t\t\t\tomap_mcbsp3_st_controls,\n\t\t\t\t\tARRAY_SIZE(omap_mcbsp3_st_controls));\n\tdefault:\n\t\tdev_err(mcbsp->dev, \"Port %d not supported\\n\", port_id);\n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(omap_mcbsp_st_add_controls);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}