{
  "module_name": "n810.c",
  "hash_id": "b3717ac2954311781257640c2d4615c3596303beb7af30a9173c20853b189105",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/n810.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#include <asm/mach-types.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/platform_data/asoc-ti-mcbsp.h>\n\n#include \"omap-mcbsp.h\"\n\n#define N810_HEADSET_AMP_GPIO\t10\n#define N810_SPEAKER_AMP_GPIO\t101\n\nenum {\n\tN810_JACK_DISABLED,\n\tN810_JACK_HP,\n\tN810_JACK_HS,\n\tN810_JACK_MIC,\n};\n\nstatic struct clk *sys_clkout2;\nstatic struct clk *sys_clkout2_src;\nstatic struct clk *func96m_clk;\n\nstatic int n810_spk_func;\nstatic int n810_jack_func;\nstatic int n810_dmic_func;\n\nstatic void n810_ext_control(struct snd_soc_dapm_context *dapm)\n{\n\tint hp = 0, line1l = 0;\n\n\tswitch (n810_jack_func) {\n\tcase N810_JACK_HS:\n\t\tline1l = 1;\n\t\tfallthrough;\n\tcase N810_JACK_HP:\n\t\thp = 1;\n\t\tbreak;\n\tcase N810_JACK_MIC:\n\t\tline1l = 1;\n\t\tbreak;\n\t}\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tif (n810_spk_func)\n\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Ext Spk\");\n\telse\n\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Ext Spk\");\n\n\tif (hp)\n\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"Headphone Jack\");\n\telse\n\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Headphone Jack\");\n\tif (line1l)\n\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"HS Mic\");\n\telse\n\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"HS Mic\");\n\n\tif (n810_dmic_func)\n\t\tsnd_soc_dapm_enable_pin_unlocked(dapm, \"DMic\");\n\telse\n\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"DMic\");\n\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\nstatic int n810_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\n\tsnd_pcm_hw_constraint_single(runtime, SNDRV_PCM_HW_PARAM_CHANNELS, 2);\n\n\tn810_ext_control(&rtd->card->dapm);\n\treturn clk_prepare_enable(sys_clkout2);\n}\n\nstatic void n810_shutdown(struct snd_pcm_substream *substream)\n{\n\tclk_disable_unprepare(sys_clkout2);\n}\n\nstatic int n810_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tint err;\n\n\t \n\terr = snd_soc_dai_set_sysclk(codec_dai, 0, 12000000,\n\t\t\t\t\t    SND_SOC_CLOCK_IN);\n\n\treturn err;\n}\n\nstatic const struct snd_soc_ops n810_ops = {\n\t.startup = n810_startup,\n\t.hw_params = n810_hw_params,\n\t.shutdown = n810_shutdown,\n};\n\nstatic int n810_get_spk(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = n810_spk_func;\n\n\treturn 0;\n}\n\nstatic int n810_set_spk(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card =  snd_kcontrol_chip(kcontrol);\n\n\tif (n810_spk_func == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tn810_spk_func = ucontrol->value.enumerated.item[0];\n\tn810_ext_control(&card->dapm);\n\n\treturn 1;\n}\n\nstatic int n810_get_jack(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = n810_jack_func;\n\n\treturn 0;\n}\n\nstatic int n810_set_jack(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card =  snd_kcontrol_chip(kcontrol);\n\n\tif (n810_jack_func == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tn810_jack_func = ucontrol->value.enumerated.item[0];\n\tn810_ext_control(&card->dapm);\n\n\treturn 1;\n}\n\nstatic int n810_get_input(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tucontrol->value.enumerated.item[0] = n810_dmic_func;\n\n\treturn 0;\n}\n\nstatic int n810_set_input(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_card *card =  snd_kcontrol_chip(kcontrol);\n\n\tif (n810_dmic_func == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tn810_dmic_func = ucontrol->value.enumerated.item[0];\n\tn810_ext_control(&card->dapm);\n\n\treturn 1;\n}\n\nstatic int n810_spk_event(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *k, int event)\n{\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tgpio_set_value(N810_SPEAKER_AMP_GPIO, 1);\n\telse\n\t\tgpio_set_value(N810_SPEAKER_AMP_GPIO, 0);\n\n\treturn 0;\n}\n\nstatic int n810_jack_event(struct snd_soc_dapm_widget *w,\n\t\t\t   struct snd_kcontrol *k, int event)\n{\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tgpio_set_value(N810_HEADSET_AMP_GPIO, 1);\n\telse\n\t\tgpio_set_value(N810_HEADSET_AMP_GPIO, 0);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget aic33_dapm_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", n810_spk_event),\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", n810_jack_event),\n\tSND_SOC_DAPM_MIC(\"DMic\", NULL),\n\tSND_SOC_DAPM_MIC(\"HS Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t{\"Headphone Jack\", NULL, \"HPLOUT\"},\n\t{\"Headphone Jack\", NULL, \"HPROUT\"},\n\n\t{\"Ext Spk\", NULL, \"LLOUT\"},\n\t{\"Ext Spk\", NULL, \"RLOUT\"},\n\n\t{\"DMic Rate 64\", NULL, \"DMic\"},\n\t{\"DMic\", NULL, \"Mic Bias\"},\n\n\t \n\t{\"LINE1L\", NULL, \"HS Mic\"},\n};\n\nstatic const char *spk_function[] = {\"Off\", \"On\"};\nstatic const char *jack_function[] = {\"Off\", \"Headphone\", \"Headset\", \"Mic\"};\nstatic const char *input_function[] = {\"ADC\", \"Digital Mic\"};\nstatic const struct soc_enum n810_enum[] = {\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spk_function), spk_function),\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(jack_function), jack_function),\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(input_function), input_function),\n};\n\nstatic const struct snd_kcontrol_new aic33_n810_controls[] = {\n\tSOC_ENUM_EXT(\"Speaker Function\", n810_enum[0],\n\t\t     n810_get_spk, n810_set_spk),\n\tSOC_ENUM_EXT(\"Jack Function\", n810_enum[1],\n\t\t     n810_get_jack, n810_set_jack),\n\tSOC_ENUM_EXT(\"Input Select\",  n810_enum[2],\n\t\t     n810_get_input, n810_set_input),\n};\n\n \nSND_SOC_DAILINK_DEFS(aic33,\n\tDAILINK_COMP_ARRAY(COMP_CPU(\"48076000.mcbsp\")),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"tlv320aic3x-codec.1-0018\",\n\t\t\t\t      \"tlv320aic3x-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_PLATFORM(\"48076000.mcbsp\")));\n\nstatic struct snd_soc_dai_link n810_dai = {\n\t.name = \"TLV320AIC33\",\n\t.stream_name = \"AIC33\",\n\t.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t   SND_SOC_DAIFMT_CBM_CFM,\n\t.ops = &n810_ops,\n\tSND_SOC_DAILINK_REG(aic33),\n};\n\n \nstatic struct snd_soc_card snd_soc_n810 = {\n\t.name = \"N810\",\n\t.owner = THIS_MODULE,\n\t.dai_link = &n810_dai,\n\t.num_links = 1,\n\n\t.controls = aic33_n810_controls,\n\t.num_controls = ARRAY_SIZE(aic33_n810_controls),\n\t.dapm_widgets = aic33_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(aic33_dapm_widgets),\n\t.dapm_routes = audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(audio_map),\n\t.fully_routed = true,\n};\n\nstatic struct platform_device *n810_snd_device;\n\nstatic int __init n810_soc_init(void)\n{\n\tint err;\n\tstruct device *dev;\n\n\tif (!of_have_populated_dt() ||\n\t    (!of_machine_is_compatible(\"nokia,n810\") &&\n\t     !of_machine_is_compatible(\"nokia,n810-wimax\")))\n\t\treturn -ENODEV;\n\n\tn810_snd_device = platform_device_alloc(\"soc-audio\", -1);\n\tif (!n810_snd_device)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(n810_snd_device, &snd_soc_n810);\n\terr = platform_device_add(n810_snd_device);\n\tif (err)\n\t\tgoto err1;\n\n\tdev = &n810_snd_device->dev;\n\n\tsys_clkout2_src = clk_get(dev, \"sys_clkout2_src\");\n\tif (IS_ERR(sys_clkout2_src)) {\n\t\tdev_err(dev, \"Could not get sys_clkout2_src clock\\n\");\n\t\terr = PTR_ERR(sys_clkout2_src);\n\t\tgoto err2;\n\t}\n\tsys_clkout2 = clk_get(dev, \"sys_clkout2\");\n\tif (IS_ERR(sys_clkout2)) {\n\t\tdev_err(dev, \"Could not get sys_clkout2\\n\");\n\t\terr = PTR_ERR(sys_clkout2);\n\t\tgoto err3;\n\t}\n\t \n\tfunc96m_clk = clk_get(dev, \"func_96m_ck\");\n\tif (IS_ERR(func96m_clk)) {\n\t\tdev_err(dev, \"Could not get func 96M clock\\n\");\n\t\terr = PTR_ERR(func96m_clk);\n\t\tgoto err4;\n\t}\n\tclk_set_parent(sys_clkout2_src, func96m_clk);\n\tclk_set_rate(sys_clkout2, 12000000);\n\n\tif (WARN_ON((gpio_request(N810_HEADSET_AMP_GPIO, \"hs_amp\") < 0) ||\n\t\t    (gpio_request(N810_SPEAKER_AMP_GPIO, \"spk_amp\") < 0))) {\n\t\terr = -EINVAL;\n\t\tgoto err4;\n\t}\n\n\tgpio_direction_output(N810_HEADSET_AMP_GPIO, 0);\n\tgpio_direction_output(N810_SPEAKER_AMP_GPIO, 0);\n\n\treturn 0;\nerr4:\n\tclk_put(sys_clkout2);\nerr3:\n\tclk_put(sys_clkout2_src);\nerr2:\n\tplatform_device_del(n810_snd_device);\nerr1:\n\tplatform_device_put(n810_snd_device);\n\n\treturn err;\n}\n\nstatic void __exit n810_soc_exit(void)\n{\n\tgpio_free(N810_SPEAKER_AMP_GPIO);\n\tgpio_free(N810_HEADSET_AMP_GPIO);\n\tclk_put(sys_clkout2_src);\n\tclk_put(sys_clkout2);\n\tclk_put(func96m_clk);\n\n\tplatform_device_unregister(n810_snd_device);\n}\n\nmodule_init(n810_soc_init);\nmodule_exit(n810_soc_exit);\n\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@bitmer.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC Nokia N810\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}