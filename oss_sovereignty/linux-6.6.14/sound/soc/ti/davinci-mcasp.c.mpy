{
  "module_name": "davinci-mcasp.c",
  "hash_id": "48350d021f78bc557b4ee79a38219eb8660d2d2aafe3d9cffae9599385d00637",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/davinci-mcasp.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/platform_data/davinci_asp.h>\n#include <linux/math64.h>\n#include <linux/bitmap.h>\n#include <linux/gpio/driver.h>\n\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"edma-pcm.h\"\n#include \"sdma-pcm.h\"\n#include \"udma-pcm.h\"\n#include \"davinci-mcasp.h\"\n\n#define MCASP_MAX_AFIFO_DEPTH\t64\n\n#ifdef CONFIG_PM\nstatic u32 context_regs[] = {\n\tDAVINCI_MCASP_TXFMCTL_REG,\n\tDAVINCI_MCASP_RXFMCTL_REG,\n\tDAVINCI_MCASP_TXFMT_REG,\n\tDAVINCI_MCASP_RXFMT_REG,\n\tDAVINCI_MCASP_ACLKXCTL_REG,\n\tDAVINCI_MCASP_ACLKRCTL_REG,\n\tDAVINCI_MCASP_AHCLKXCTL_REG,\n\tDAVINCI_MCASP_AHCLKRCTL_REG,\n\tDAVINCI_MCASP_PDIR_REG,\n\tDAVINCI_MCASP_PFUNC_REG,\n\tDAVINCI_MCASP_RXMASK_REG,\n\tDAVINCI_MCASP_TXMASK_REG,\n\tDAVINCI_MCASP_RXTDM_REG,\n\tDAVINCI_MCASP_TXTDM_REG,\n};\n\nstruct davinci_mcasp_context {\n\tu32\tconfig_regs[ARRAY_SIZE(context_regs)];\n\tu32\tafifo_regs[2];  \n\tu32\t*xrsr_regs;  \n\tbool\tpm_state;\n};\n#endif\n\nstruct davinci_mcasp_ruledata {\n\tstruct davinci_mcasp *mcasp;\n\tint serializers;\n};\n\nstruct davinci_mcasp {\n\tstruct snd_dmaengine_dai_dma_data dma_data[2];\n\tstruct davinci_mcasp_pdata *pdata;\n\tvoid __iomem *base;\n\tu32 fifo_base;\n\tstruct device *dev;\n\tstruct snd_pcm_substream *substreams[2];\n\tunsigned int dai_fmt;\n\n\tu32 iec958_status;\n\n\t \n\tbool\tmissing_audio_param;\n\n\t \n\tint\ttdm_slots;\n\tu32\ttdm_mask[2];\n\tint\tslot_width;\n\tu8\top_mode;\n\tu8\tdismod;\n\tu8\tnum_serializer;\n\tu8\t*serial_dir;\n\tu8\tversion;\n\tu8\tbclk_div;\n\tint\tstreams;\n\tu32\tirq_request[2];\n\n\tint\tsysclk_freq;\n\tbool\tbclk_master;\n\tu32\tauxclk_fs_ratio;\n\n\tunsigned long pdir;  \n\n\t \n\tu8\ttxnumevt;\n\tu8\trxnumevt;\n\n\tbool\tdat_port;\n\n\t \n\tu32\tchannels;\n\tint\tmax_format_width;\n\tu8\tactive_serializers[2];\n\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gpio_chip;\n#endif\n\n#ifdef CONFIG_PM\n\tstruct davinci_mcasp_context context;\n#endif\n\n\tstruct davinci_mcasp_ruledata ruledata[2];\n\tstruct snd_pcm_hw_constraint_list chconstr[2];\n};\n\nstatic inline void mcasp_set_bits(struct davinci_mcasp *mcasp, u32 offset,\n\t\t\t\t  u32 val)\n{\n\tvoid __iomem *reg = mcasp->base + offset;\n\t__raw_writel(__raw_readl(reg) | val, reg);\n}\n\nstatic inline void mcasp_clr_bits(struct davinci_mcasp *mcasp, u32 offset,\n\t\t\t\t  u32 val)\n{\n\tvoid __iomem *reg = mcasp->base + offset;\n\t__raw_writel((__raw_readl(reg) & ~(val)), reg);\n}\n\nstatic inline void mcasp_mod_bits(struct davinci_mcasp *mcasp, u32 offset,\n\t\t\t\t  u32 val, u32 mask)\n{\n\tvoid __iomem *reg = mcasp->base + offset;\n\t__raw_writel((__raw_readl(reg) & ~mask) | val, reg);\n}\n\nstatic inline void mcasp_set_reg(struct davinci_mcasp *mcasp, u32 offset,\n\t\t\t\t u32 val)\n{\n\t__raw_writel(val, mcasp->base + offset);\n}\n\nstatic inline u32 mcasp_get_reg(struct davinci_mcasp *mcasp, u32 offset)\n{\n\treturn (u32)__raw_readl(mcasp->base + offset);\n}\n\nstatic void mcasp_set_ctl_reg(struct davinci_mcasp *mcasp, u32 ctl_reg, u32 val)\n{\n\tint i = 0;\n\n\tmcasp_set_bits(mcasp, ctl_reg, val);\n\n\t \n\t \n\tfor (i = 0; i < 1000; i++) {\n\t\tif ((mcasp_get_reg(mcasp, ctl_reg) & val) == val)\n\t\t\tbreak;\n\t}\n\n\tif (i == 1000 && ((mcasp_get_reg(mcasp, ctl_reg) & val) != val))\n\t\tprintk(KERN_ERR \"GBLCTL write error\\n\");\n}\n\nstatic bool mcasp_is_synchronous(struct davinci_mcasp *mcasp)\n{\n\tu32 rxfmctl = mcasp_get_reg(mcasp, DAVINCI_MCASP_RXFMCTL_REG);\n\tu32 aclkxctl = mcasp_get_reg(mcasp, DAVINCI_MCASP_ACLKXCTL_REG);\n\n\treturn !(aclkxctl & TX_ASYNC) && rxfmctl & AFSRE;\n}\n\nstatic inline void mcasp_set_clk_pdir(struct davinci_mcasp *mcasp, bool enable)\n{\n\tu32 bit = PIN_BIT_AMUTE;\n\n\tfor_each_set_bit_from(bit, &mcasp->pdir, PIN_BIT_AFSR + 1) {\n\t\tif (enable)\n\t\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(bit));\n\t\telse\n\t\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(bit));\n\t}\n}\n\nstatic inline void mcasp_set_axr_pdir(struct davinci_mcasp *mcasp, bool enable)\n{\n\tu32 bit;\n\n\tfor_each_set_bit(bit, &mcasp->pdir, PIN_BIT_AMUTE) {\n\t\tif (enable)\n\t\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(bit));\n\t\telse\n\t\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(bit));\n\t}\n}\n\nstatic void mcasp_start_rx(struct davinci_mcasp *mcasp)\n{\n\tif (mcasp->rxnumevt) {\t \n\t\tu32 reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\n\n\t\tmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\n\t\tmcasp_set_bits(mcasp, reg, FIFO_ENABLE);\n\t}\n\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);\n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);\n\t \n\tif (mcasp_is_synchronous(mcasp)) {\n\t\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\n\t\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\n\t\tmcasp_set_clk_pdir(mcasp, true);\n\t}\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXSMRST);\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, RXFSRST);\n\tif (mcasp_is_synchronous(mcasp))\n\t\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\n\n\t \n\tmcasp_set_bits(mcasp, DAVINCI_MCASP_EVTCTLR_REG,\n\t\t       mcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE]);\n}\n\nstatic void mcasp_start_tx(struct davinci_mcasp *mcasp)\n{\n\tu32 cnt;\n\n\tif (mcasp->txnumevt) {\t \n\t\tu32 reg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\n\n\t\tmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\n\t\tmcasp_set_bits(mcasp, reg, FIFO_ENABLE);\n\t}\n\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);\n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);\n\tmcasp_set_clk_pdir(mcasp, true);\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXSERCLR);\n\n\t \n\tcnt = 0;\n\twhile ((mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) & XRDATA) &&\n\t       (cnt < 100000))\n\t\tcnt++;\n\n\tmcasp_set_axr_pdir(mcasp, true);\n\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXSMRST);\n\t \n\tmcasp_set_ctl_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, TXFSRST);\n\n\t \n\tmcasp_set_bits(mcasp, DAVINCI_MCASP_EVTCTLX_REG,\n\t\t       mcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK]);\n}\n\nstatic void davinci_mcasp_start(struct davinci_mcasp *mcasp, int stream)\n{\n\tmcasp->streams++;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmcasp_start_tx(mcasp);\n\telse\n\t\tmcasp_start_rx(mcasp);\n}\n\nstatic void mcasp_stop_rx(struct davinci_mcasp *mcasp)\n{\n\t \n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_EVTCTLR_REG,\n\t\t       mcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE]);\n\n\t \n\tif (mcasp_is_synchronous(mcasp) && !mcasp->streams) {\n\t\tmcasp_set_clk_pdir(mcasp, false);\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, 0);\n\t}\n\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLR_REG, 0);\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\n\n\tif (mcasp->rxnumevt) {\t \n\t\tu32 reg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\n\n\t\tmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\n\t}\n}\n\nstatic void mcasp_stop_tx(struct davinci_mcasp *mcasp)\n{\n\tu32 val = 0;\n\n\t \n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_EVTCTLX_REG,\n\t\t       mcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK]);\n\n\t \n\tif (mcasp_is_synchronous(mcasp) && mcasp->streams)\n\t\tval =  TXHCLKRST | TXCLKRST | TXFSRST;\n\telse\n\t\tmcasp_set_clk_pdir(mcasp, false);\n\n\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_GBLCTLX_REG, val);\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\n\n\tif (mcasp->txnumevt) {\t \n\t\tu32 reg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\n\n\t\tmcasp_clr_bits(mcasp, reg, FIFO_ENABLE);\n\t}\n\n\tmcasp_set_axr_pdir(mcasp, false);\n}\n\nstatic void davinci_mcasp_stop(struct davinci_mcasp *mcasp, int stream)\n{\n\tmcasp->streams--;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmcasp_stop_tx(mcasp);\n\telse\n\t\tmcasp_stop_rx(mcasp);\n}\n\nstatic irqreturn_t davinci_mcasp_tx_irq_handler(int irq, void *data)\n{\n\tstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\n\tstruct snd_pcm_substream *substream;\n\tu32 irq_mask = mcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK];\n\tu32 handled_mask = 0;\n\tu32 stat;\n\n\tstat = mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG);\n\tif (stat & XUNDRN & irq_mask) {\n\t\tdev_warn(mcasp->dev, \"Transmit buffer underflow\\n\");\n\t\thandled_mask |= XUNDRN;\n\n\t\tsubstream = mcasp->substreams[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tif (substream)\n\t\t\tsnd_pcm_stop_xrun(substream);\n\t}\n\n\tif (!handled_mask)\n\t\tdev_warn(mcasp->dev, \"unhandled tx event. txstat: 0x%08x\\n\",\n\t\t\t stat);\n\n\tif (stat & XRERR)\n\t\thandled_mask |= XRERR;\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, handled_mask);\n\n\treturn IRQ_RETVAL(handled_mask);\n}\n\nstatic irqreturn_t davinci_mcasp_rx_irq_handler(int irq, void *data)\n{\n\tstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\n\tstruct snd_pcm_substream *substream;\n\tu32 irq_mask = mcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE];\n\tu32 handled_mask = 0;\n\tu32 stat;\n\n\tstat = mcasp_get_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG);\n\tif (stat & ROVRN & irq_mask) {\n\t\tdev_warn(mcasp->dev, \"Receive buffer overflow\\n\");\n\t\thandled_mask |= ROVRN;\n\n\t\tsubstream = mcasp->substreams[SNDRV_PCM_STREAM_CAPTURE];\n\t\tif (substream)\n\t\t\tsnd_pcm_stop_xrun(substream);\n\t}\n\n\tif (!handled_mask)\n\t\tdev_warn(mcasp->dev, \"unhandled rx event. rxstat: 0x%08x\\n\",\n\t\t\t stat);\n\n\tif (stat & XRERR)\n\t\thandled_mask |= XRERR;\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, handled_mask);\n\n\treturn IRQ_RETVAL(handled_mask);\n}\n\nstatic irqreturn_t davinci_mcasp_common_irq_handler(int irq, void *data)\n{\n\tstruct davinci_mcasp *mcasp = (struct davinci_mcasp *)data;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (mcasp->substreams[SNDRV_PCM_STREAM_PLAYBACK])\n\t\tret = davinci_mcasp_tx_irq_handler(irq, data);\n\n\tif (mcasp->substreams[SNDRV_PCM_STREAM_CAPTURE])\n\t\tret |= davinci_mcasp_rx_irq_handler(irq, data);\n\n\treturn ret;\n}\n\nstatic int davinci_mcasp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\n\t\t\t\t\t unsigned int fmt)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret = 0;\n\tu32 data_delay;\n\tbool fs_pol_rising;\n\tbool inv_fs = false;\n\n\tif (!fmt)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(mcasp->dev);\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\n\t\t \n\t\tdata_delay = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\tcase SND_SOC_DAIFMT_AC97:\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\n\t\t \n\t\tdata_delay = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\n\t\t \n\t\tdata_delay = 1;\n\t\t \n\t\tinv_fs = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);\n\t\t \n\t\tdata_delay = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, FSXDLY(data_delay),\n\t\t       FSXDLY(3));\n\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, FSRDLY(data_delay),\n\t\t       FSRDLY(3));\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_BP_FP:\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\n\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\n\n\t\t \n\t\tset_bit(PIN_BIT_ACLKX, &mcasp->pdir);\n\t\tset_bit(PIN_BIT_ACLKR, &mcasp->pdir);\n\t\t \n\t\tset_bit(PIN_BIT_AFSX, &mcasp->pdir);\n\t\tset_bit(PIN_BIT_AFSR, &mcasp->pdir);\n\n\t\tmcasp->bclk_master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BP_FC:\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\n\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\n\n\t\t \n\t\tset_bit(PIN_BIT_ACLKX, &mcasp->pdir);\n\t\tset_bit(PIN_BIT_ACLKR, &mcasp->pdir);\n\t\t \n\t\tclear_bit(PIN_BIT_AFSX, &mcasp->pdir);\n\t\tclear_bit(PIN_BIT_AFSR, &mcasp->pdir);\n\n\t\tmcasp->bclk_master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FP:\n\t\t \n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\n\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\n\n\t\t \n\t\tclear_bit(PIN_BIT_ACLKX, &mcasp->pdir);\n\t\tclear_bit(PIN_BIT_ACLKR, &mcasp->pdir);\n\t\t \n\t\tset_bit(PIN_BIT_AFSX, &mcasp->pdir);\n\t\tset_bit(PIN_BIT_AFSR, &mcasp->pdir);\n\n\t\tmcasp->bclk_master = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_BC_FC:\n\t\t \n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE);\n\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, AFSRE);\n\n\t\t \n\t\tclear_bit(PIN_BIT_ACLKX, &mcasp->pdir);\n\t\tclear_bit(PIN_BIT_ACLKR, &mcasp->pdir);\n\t\t \n\t\tclear_bit(PIN_BIT_AFSX, &mcasp->pdir);\n\t\tclear_bit(PIN_BIT_AFSR, &mcasp->pdir);\n\n\t\tmcasp->bclk_master = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\n\t\tfs_pol_rising = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\n\t\tfs_pol_rising = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\n\t\tfs_pol_rising = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);\n\t\tfs_pol_rising = true;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inv_fs)\n\t\tfs_pol_rising = !fs_pol_rising;\n\n\tif (fs_pol_rising) {\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\n\t} else {\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);\n\t}\n\n\tmcasp->dai_fmt = fmt;\nout:\n\tpm_runtime_put(mcasp->dev);\n\treturn ret;\n}\n\nstatic int __davinci_mcasp_set_clkdiv(struct davinci_mcasp *mcasp, int div_id,\n\t\t\t\t      int div, bool explicit)\n{\n\tpm_runtime_get_sync(mcasp->dev);\n\tswitch (div_id) {\n\tcase MCASP_CLKDIV_AUXCLK:\t\t\t \n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG,\n\t\t\t       AHCLKXDIV(div - 1), AHCLKXDIV_MASK);\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG,\n\t\t\t       AHCLKRDIV(div - 1), AHCLKRDIV_MASK);\n\t\tbreak;\n\n\tcase MCASP_CLKDIV_BCLK:\t\t\t \n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG,\n\t\t\t       ACLKXDIV(div - 1), ACLKXDIV_MASK);\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_ACLKRCTL_REG,\n\t\t\t       ACLKRDIV(div - 1), ACLKRDIV_MASK);\n\t\tif (explicit)\n\t\t\tmcasp->bclk_div = div;\n\t\tbreak;\n\n\tcase MCASP_CLKDIV_BCLK_FS_RATIO:\n\t\t \n\t\tmcasp->slot_width = div / mcasp->tdm_slots;\n\t\tif (div % mcasp->tdm_slots)\n\t\t\tdev_warn(mcasp->dev,\n\t\t\t\t \"%s(): BCLK/LRCLK %d is not divisible by %d tdm slots\",\n\t\t\t\t __func__, div, mcasp->tdm_slots);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_put(mcasp->dev);\n\treturn 0;\n}\n\nstatic int davinci_mcasp_set_clkdiv(struct snd_soc_dai *dai, int div_id,\n\t\t\t\t    int div)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\n\n\treturn __davinci_mcasp_set_clkdiv(mcasp, div_id, div, 1);\n}\n\nstatic int davinci_mcasp_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t    unsigned int freq, int dir)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\n\n\tpm_runtime_get_sync(mcasp->dev);\n\n\tif (dir == SND_SOC_CLOCK_IN) {\n\t\tswitch (clk_id) {\n\t\tcase MCASP_CLK_HCLK_AHCLK:\n\t\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG,\n\t\t\t\t       AHCLKXE);\n\t\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG,\n\t\t\t\t       AHCLKRE);\n\t\t\tclear_bit(PIN_BIT_AHCLKX, &mcasp->pdir);\n\t\t\tbreak;\n\t\tcase MCASP_CLK_HCLK_AUXCLK:\n\t\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG,\n\t\t\t\t       AHCLKXE);\n\t\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG,\n\t\t\t\t       AHCLKRE);\n\t\t\tset_bit(PIN_BIT_AHCLKX, &mcasp->pdir);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(mcasp->dev, \"Invalid clk id: %d\\n\", clk_id);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXE);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRE);\n\t\tset_bit(PIN_BIT_AHCLKX, &mcasp->pdir);\n\t}\n\t \n\tmcasp->sysclk_freq = freq;\nout:\n\tpm_runtime_put(mcasp->dev);\n\treturn 0;\n}\n\n \nstatic int davinci_mcasp_ch_constraint(struct davinci_mcasp *mcasp, int stream,\n\t\t\t\t       int serializers)\n{\n\tstruct snd_pcm_hw_constraint_list *cl = &mcasp->chconstr[stream];\n\tunsigned int *list = (unsigned int *) cl->list;\n\tint slots = mcasp->tdm_slots;\n\tint i, count = 0;\n\n\tif (mcasp->tdm_mask[stream])\n\t\tslots = hweight32(mcasp->tdm_mask[stream]);\n\n\tfor (i = 1; i <= slots; i++)\n\t\tlist[count++] = i;\n\n\tfor (i = 2; i <= serializers; i++)\n\t\tlist[count++] = i*slots;\n\n\tcl->count = count;\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_set_ch_constraints(struct davinci_mcasp *mcasp)\n{\n\tint rx_serializers = 0, tx_serializers = 0, ret, i;\n\n\tfor (i = 0; i < mcasp->num_serializer; i++)\n\t\tif (mcasp->serial_dir[i] == TX_MODE)\n\t\t\ttx_serializers++;\n\t\telse if (mcasp->serial_dir[i] == RX_MODE)\n\t\t\trx_serializers++;\n\n\tret = davinci_mcasp_ch_constraint(mcasp, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t\t  tx_serializers);\n\tif (ret)\n\t\treturn ret;\n\n\tret = davinci_mcasp_ch_constraint(mcasp, SNDRV_PCM_STREAM_CAPTURE,\n\t\t\t\t\t  rx_serializers);\n\n\treturn ret;\n}\n\n\nstatic int davinci_mcasp_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int tx_mask,\n\t\t\t\t      unsigned int rx_mask,\n\t\t\t\t      int slots, int slot_width)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\n\t\treturn 0;\n\n\tdev_dbg(mcasp->dev,\n\t\t \"%s() tx_mask 0x%08x rx_mask 0x%08x slots %d width %d\\n\",\n\t\t __func__, tx_mask, rx_mask, slots, slot_width);\n\n\tif (tx_mask >= (1<<slots) || rx_mask >= (1<<slots)) {\n\t\tdev_err(mcasp->dev,\n\t\t\t\"Bad tdm mask tx: 0x%08x rx: 0x%08x slots %d\\n\",\n\t\t\ttx_mask, rx_mask, slots);\n\t\treturn -EINVAL;\n\t}\n\n\tif (slot_width &&\n\t    (slot_width < 8 || slot_width > 32 || slot_width % 4 != 0)) {\n\t\tdev_err(mcasp->dev, \"%s: Unsupported slot_width %d\\n\",\n\t\t\t__func__, slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tmcasp->tdm_slots = slots;\n\tmcasp->tdm_mask[SNDRV_PCM_STREAM_PLAYBACK] = tx_mask;\n\tmcasp->tdm_mask[SNDRV_PCM_STREAM_CAPTURE] = rx_mask;\n\tmcasp->slot_width = slot_width;\n\n\treturn davinci_mcasp_set_ch_constraints(mcasp);\n}\n\nstatic int davinci_config_channel_size(struct davinci_mcasp *mcasp,\n\t\t\t\t       int sample_width)\n{\n\tu32 fmt;\n\tu32 tx_rotate, rx_rotate, slot_width;\n\tu32 mask = (1ULL << sample_width) - 1;\n\n\tif (mcasp->slot_width)\n\t\tslot_width = mcasp->slot_width;\n\telse if (mcasp->max_format_width)\n\t\tslot_width = mcasp->max_format_width;\n\telse\n\t\tslot_width = sample_width;\n\t \n\tif ((mcasp->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==\n\t    SND_SOC_DAIFMT_RIGHT_J) {\n\t\ttx_rotate = (slot_width / 4) & 0x7;\n\t\trx_rotate = 0;\n\t} else {\n\t\ttx_rotate = (sample_width / 4) & 0x7;\n\t\trx_rotate = (slot_width - sample_width) / 4;\n\t}\n\n\t \n\tfmt = (slot_width >> 1) - 1;\n\n\tif (mcasp->op_mode != DAVINCI_MCASP_DIT_MODE) {\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, RXSSZ(fmt),\n\t\t\t       RXSSZ(0x0F));\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXSSZ(fmt),\n\t\t\t       TXSSZ(0x0F));\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXROT(tx_rotate),\n\t\t\t       TXROT(7));\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, RXROT(rx_rotate),\n\t\t\t       RXROT(7));\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXMASK_REG, mask);\n\t} else {\n\t\t \n\t\ttx_rotate = (sample_width / 4 + 2) & 0x7;\n\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXROT(tx_rotate),\n\t\t\t       TXROT(7));\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXSSZ(15),\n\t\t\t       TXSSZ(0x0F));\n\t}\n\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXMASK_REG, mask);\n\n\treturn 0;\n}\n\nstatic int mcasp_common_hw_param(struct davinci_mcasp *mcasp, int stream,\n\t\t\t\t int period_words, int channels)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data = &mcasp->dma_data[stream];\n\tint i;\n\tu8 tx_ser = 0;\n\tu8 rx_ser = 0;\n\tu8 slots = mcasp->tdm_slots;\n\tu8 max_active_serializers, max_rx_serializers, max_tx_serializers;\n\tint active_serializers, numevt;\n\tu32 reg;\n\n\t \n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\n\t\tmax_active_serializers = 1;\n\telse\n\t\tmax_active_serializers = DIV_ROUND_UP(channels, slots);\n\n\t \n\tif (mcasp->version < MCASP_VERSION_3)\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PWREMUMGT_REG, MCASP_SOFT);\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\n\t\tmax_tx_serializers = max_active_serializers;\n\t\tmax_rx_serializers =\n\t\t\tmcasp->active_serializers[SNDRV_PCM_STREAM_CAPTURE];\n\t} else {\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_REVTCTL_REG, RXDATADMADIS);\n\t\tmax_tx_serializers =\n\t\t\tmcasp->active_serializers[SNDRV_PCM_STREAM_PLAYBACK];\n\t\tmax_rx_serializers = max_active_serializers;\n\t}\n\n\tfor (i = 0; i < mcasp->num_serializer; i++) {\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\n\t\t\t       mcasp->serial_dir[i]);\n\t\tif (mcasp->serial_dir[i] == TX_MODE &&\n\t\t\t\t\ttx_ser < max_tx_serializers) {\n\t\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\n\t\t\t\t       mcasp->dismod, DISMOD_MASK);\n\t\t\tset_bit(PIN_BIT_AXR(i), &mcasp->pdir);\n\t\t\ttx_ser++;\n\t\t} else if (mcasp->serial_dir[i] == RX_MODE &&\n\t\t\t\t\trx_ser < max_rx_serializers) {\n\t\t\tclear_bit(PIN_BIT_AXR(i), &mcasp->pdir);\n\t\t\trx_ser++;\n\t\t} else {\n\t\t\t \n\t\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\n\t\t\t\t       SRMOD_INACTIVE, SRMOD_MASK);\n\t\t\t \n\t\t\tif (mcasp->serial_dir[i] != INACTIVE_MODE)\n\t\t\t\tmcasp_mod_bits(mcasp,\n\t\t\t\t\t       DAVINCI_MCASP_XRSRCTL_REG(i),\n\t\t\t\t\t       mcasp->dismod, DISMOD_MASK);\n\t\t\tclear_bit(PIN_BIT_AXR(i), &mcasp->pdir);\n\t\t}\n\t}\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tactive_serializers = tx_ser;\n\t\tnumevt = mcasp->txnumevt;\n\t\treg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\n\t} else {\n\t\tactive_serializers = rx_ser;\n\t\tnumevt = mcasp->rxnumevt;\n\t\treg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\n\t}\n\n\tif (active_serializers < max_active_serializers) {\n\t\tdev_warn(mcasp->dev, \"stream has more channels (%d) than are \"\n\t\t\t \"enabled in mcasp (%d)\\n\", channels,\n\t\t\t active_serializers * slots);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!numevt) {\n\t\t \n\t\tif (active_serializers > 1) {\n\t\t\t \n\t\t\tdma_data->maxburst = active_serializers;\n\t\t} else {\n\t\t\tdma_data->maxburst = 0;\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (period_words % active_serializers) {\n\t\tdev_err(mcasp->dev, \"Invalid combination of period words and \"\n\t\t\t\"active serializers: %d, %d\\n\", period_words,\n\t\t\tactive_serializers);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tnumevt = (numevt / active_serializers) * active_serializers;\n\n\twhile (period_words % numevt && numevt > 0)\n\t\tnumevt -= active_serializers;\n\tif (numevt <= 0)\n\t\tnumevt = active_serializers;\n\n\tmcasp_mod_bits(mcasp, reg, active_serializers, NUMDMA_MASK);\n\tmcasp_mod_bits(mcasp, reg, NUMEVT(numevt), NUMEVT_MASK);\n\n\t \n\tif (numevt == 1)\n\t\tnumevt = 0;\n\tdma_data->maxburst = numevt;\n\nout:\n\tmcasp->active_serializers[stream] = active_serializers;\n\n\treturn 0;\n}\n\nstatic int mcasp_i2s_hw_param(struct davinci_mcasp *mcasp, int stream,\n\t\t\t      int channels)\n{\n\tint i, active_slots;\n\tint total_slots;\n\tint active_serializers;\n\tu32 mask = 0;\n\tu32 busel = 0;\n\n\ttotal_slots = mcasp->tdm_slots;\n\n\t \n\tif (mcasp->tdm_mask[stream]) {\n\t\tactive_slots = hweight32(mcasp->tdm_mask[stream]);\n\t\tactive_serializers = DIV_ROUND_UP(channels, active_slots);\n\t\tif (active_serializers == 1)\n\t\t\tactive_slots = channels;\n\t\tfor (i = 0; i < total_slots; i++) {\n\t\t\tif ((1 << i) & mcasp->tdm_mask[stream]) {\n\t\t\t\tmask |= (1 << i);\n\t\t\t\tif (--active_slots <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tactive_serializers = DIV_ROUND_UP(channels, total_slots);\n\t\tif (active_serializers == 1)\n\t\t\tactive_slots = channels;\n\t\telse\n\t\t\tactive_slots = total_slots;\n\n\t\tfor (i = 0; i < active_slots; i++)\n\t\t\tmask |= (1 << i);\n\t}\n\n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);\n\n\tif (!mcasp->dat_port)\n\t\tbusel = TXSEL;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXTDM_REG, mask);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, busel | TXORD);\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG,\n\t\t\t       FSXMOD(total_slots), FSXMOD(0x1FF));\n\t} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_RXTDM_REG, mask);\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_RXFMT_REG, busel | RXORD);\n\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_RXFMCTL_REG,\n\t\t\t       FSRMOD(total_slots), FSRMOD(0x1FF));\n\t\t \n\t\tif (mcasp_is_synchronous(mcasp) && !mcasp->channels)\n\t\t\tmcasp_mod_bits(mcasp, DAVINCI_MCASP_TXFMCTL_REG,\n\t\t\t\t       FSXMOD(total_slots), FSXMOD(0x1FF));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mcasp_dit_hw_param(struct davinci_mcasp *mcasp,\n\t\t\t      unsigned int rate)\n{\n\tu8 *cs_bytes = (u8 *)&mcasp->iec958_status;\n\n\tif (!mcasp->dat_port)\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXSEL);\n\telse\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_TXFMT_REG, TXSEL);\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXFMCTL_REG, AFSXE | FSXMOD(0x180));\n\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXMASK_REG, 0xFFFF);\n\n\t \n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_TXTDM_REG, 0xFFFFFFFF);\n\n\t \n\tmcasp_set_bits(mcasp, DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE | TX_ASYNC);\n\n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_XEVTCTL_REG, TXDATADMADIS);\n\n\t \n\tcs_bytes[3] &= ~IEC958_AES3_CON_FS;\n\tswitch (rate) {\n\tcase 22050:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 176400:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 192000:\n\t\tcs_bytes[3] |= IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mcasp->dev, \"unsupported sampling rate: %d\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_DITCSRA_REG, mcasp->iec958_status);\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_DITCSRB_REG, mcasp->iec958_status);\n\n\t \n\tmcasp_set_bits(mcasp, DAVINCI_MCASP_TXDITCTL_REG, DITEN);\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_calc_clk_div(struct davinci_mcasp *mcasp,\n\t\t\t\t      unsigned int sysclk_freq,\n\t\t\t\t      unsigned int bclk_freq, bool set)\n{\n\tu32 reg = mcasp_get_reg(mcasp, DAVINCI_MCASP_AHCLKXCTL_REG);\n\tint div = sysclk_freq / bclk_freq;\n\tint rem = sysclk_freq % bclk_freq;\n\tint error_ppm;\n\tint aux_div = 1;\n\n\tif (div > (ACLKXDIV_MASK + 1)) {\n\t\tif (reg & AHCLKXE) {\n\t\t\taux_div = div / (ACLKXDIV_MASK + 1);\n\t\t\tif (div % (ACLKXDIV_MASK + 1))\n\t\t\t\taux_div++;\n\n\t\t\tsysclk_freq /= aux_div;\n\t\t\tdiv = sysclk_freq / bclk_freq;\n\t\t\trem = sysclk_freq % bclk_freq;\n\t\t} else if (set) {\n\t\t\tdev_warn(mcasp->dev, \"Too fast reference clock (%u)\\n\",\n\t\t\t\t sysclk_freq);\n\t\t}\n\t}\n\n\tif (rem != 0) {\n\t\tif (div == 0 ||\n\t\t    ((sysclk_freq / div) - bclk_freq) >\n\t\t    (bclk_freq - (sysclk_freq / (div+1)))) {\n\t\t\tdiv++;\n\t\t\trem = rem - bclk_freq;\n\t\t}\n\t}\n\terror_ppm = (div*1000000 + (int)div64_long(1000000LL*rem,\n\t\t     (int)bclk_freq)) / div - 1000000;\n\n\tif (set) {\n\t\tif (error_ppm)\n\t\t\tdev_info(mcasp->dev, \"Sample-rate is off by %d PPM\\n\",\n\t\t\t\t error_ppm);\n\n\t\t__davinci_mcasp_set_clkdiv(mcasp, MCASP_CLKDIV_BCLK, div, 0);\n\t\tif (reg & AHCLKXE)\n\t\t\t__davinci_mcasp_set_clkdiv(mcasp, MCASP_CLKDIV_AUXCLK,\n\t\t\t\t\t\t   aux_div, 0);\n\t}\n\n\treturn error_ppm;\n}\n\nstatic inline u32 davinci_mcasp_tx_delay(struct davinci_mcasp *mcasp)\n{\n\tif (!mcasp->txnumevt)\n\t\treturn 0;\n\n\treturn mcasp_get_reg(mcasp, mcasp->fifo_base + MCASP_WFIFOSTS_OFFSET);\n}\n\nstatic inline u32 davinci_mcasp_rx_delay(struct davinci_mcasp *mcasp)\n{\n\tif (!mcasp->rxnumevt)\n\t\treturn 0;\n\n\treturn mcasp_get_reg(mcasp, mcasp->fifo_base + MCASP_RFIFOSTS_OFFSET);\n}\n\nstatic snd_pcm_sframes_t davinci_mcasp_delay(\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\tu32 fifo_use;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tfifo_use = davinci_mcasp_tx_delay(mcasp);\n\telse\n\t\tfifo_use = davinci_mcasp_rx_delay(mcasp);\n\n\t \n\treturn fifo_use / substream->runtime->channels;\n}\n\nstatic int davinci_mcasp_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_soc_dai *cpu_dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint word_length;\n\tint channels = params_channels(params);\n\tint period_size = params_period_size(params);\n\tint ret;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_U8:\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tword_length = 8;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_U16_LE:\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tword_length = 16;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_U24_3LE:\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tword_length = 24;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_U24_LE:\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tword_length = 24;\n\t\tbreak;\n\n\tcase SNDRV_PCM_FORMAT_U32_LE:\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tword_length = 32;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING \"davinci-mcasp: unsupported PCM format\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = davinci_mcasp_set_dai_fmt(cpu_dai, mcasp->dai_fmt);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (mcasp->bclk_master && mcasp->bclk_div == 0 && mcasp->sysclk_freq) {\n\t\tint slots = mcasp->tdm_slots;\n\t\tint rate = params_rate(params);\n\t\tint sbits = params_width(params);\n\t\tunsigned int bclk_target;\n\n\t\tif (mcasp->slot_width)\n\t\t\tsbits = mcasp->slot_width;\n\n\t\tif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE)\n\t\t\tbclk_target = rate * sbits * slots;\n\t\telse\n\t\t\tbclk_target = rate * 128;\n\n\t\tdavinci_mcasp_calc_clk_div(mcasp, mcasp->sysclk_freq,\n\t\t\t\t\t   bclk_target, true);\n\t}\n\n\tret = mcasp_common_hw_param(mcasp, substream->stream,\n\t\t\t\t    period_size * channels, channels);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\n\t\tret = mcasp_dit_hw_param(mcasp, params_rate(params));\n\telse\n\t\tret = mcasp_i2s_hw_param(mcasp, substream->stream,\n\t\t\t\t\t channels);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdavinci_config_channel_size(mcasp, word_length);\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE) {\n\t\tmcasp->channels = channels;\n\t\tif (!mcasp->max_format_width)\n\t\t\tmcasp->max_format_width = word_length;\n\t}\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t     int cmd, struct snd_soc_dai *cpu_dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdavinci_mcasp_start(mcasp, substream->stream);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tdavinci_mcasp_stop(mcasp, substream->stream);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int davinci_mcasp_hw_rule_slot_width(struct snd_pcm_hw_params *params,\n\t\t\t\t\t    struct snd_pcm_hw_rule *rule)\n{\n\tstruct davinci_mcasp_ruledata *rd = rule->private;\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask nfmt;\n\tint slot_width;\n\tsnd_pcm_format_t i;\n\n\tsnd_mask_none(&nfmt);\n\tslot_width = rd->mcasp->slot_width;\n\n\tpcm_for_each_format(i) {\n\t\tif (snd_mask_test_format(fmt, i)) {\n\t\t\tif (snd_pcm_format_width(i) <= slot_width) {\n\t\t\t\tsnd_mask_set_format(&nfmt, i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snd_mask_refine(fmt, &nfmt);\n}\n\nstatic int davinci_mcasp_hw_rule_format_width(struct snd_pcm_hw_params *params,\n\t\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct davinci_mcasp_ruledata *rd = rule->private;\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask nfmt;\n\tint format_width;\n\tsnd_pcm_format_t i;\n\n\tsnd_mask_none(&nfmt);\n\tformat_width = rd->mcasp->max_format_width;\n\n\tpcm_for_each_format(i) {\n\t\tif (snd_mask_test_format(fmt, i)) {\n\t\t\tif (snd_pcm_format_width(i) == format_width) {\n\t\t\t\tsnd_mask_set_format(&nfmt, i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn snd_mask_refine(fmt, &nfmt);\n}\n\nstatic const unsigned int davinci_mcasp_dai_rates[] = {\n\t8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000,\n\t88200, 96000, 176400, 192000,\n};\n\n#define DAVINCI_MAX_RATE_ERROR_PPM 1000\n\nstatic int davinci_mcasp_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_pcm_hw_rule *rule)\n{\n\tstruct davinci_mcasp_ruledata *rd = rule->private;\n\tstruct snd_interval *ri =\n\t\thw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\n\tint sbits = params_width(params);\n\tint slots = rd->mcasp->tdm_slots;\n\tstruct snd_interval range;\n\tint i;\n\n\tif (rd->mcasp->slot_width)\n\t\tsbits = rd->mcasp->slot_width;\n\n\tsnd_interval_any(&range);\n\trange.empty = 1;\n\n\tfor (i = 0; i < ARRAY_SIZE(davinci_mcasp_dai_rates); i++) {\n\t\tif (snd_interval_test(ri, davinci_mcasp_dai_rates[i])) {\n\t\t\tuint bclk_freq = sbits * slots *\n\t\t\t\t\t davinci_mcasp_dai_rates[i];\n\t\t\tunsigned int sysclk_freq;\n\t\t\tint ppm;\n\n\t\t\tif (rd->mcasp->auxclk_fs_ratio)\n\t\t\t\tsysclk_freq =  davinci_mcasp_dai_rates[i] *\n\t\t\t\t\t       rd->mcasp->auxclk_fs_ratio;\n\t\t\telse\n\t\t\t\tsysclk_freq = rd->mcasp->sysclk_freq;\n\n\t\t\tppm = davinci_mcasp_calc_clk_div(rd->mcasp, sysclk_freq,\n\t\t\t\t\t\t\t bclk_freq, false);\n\t\t\tif (abs(ppm) < DAVINCI_MAX_RATE_ERROR_PPM) {\n\t\t\t\tif (range.empty) {\n\t\t\t\t\trange.min = davinci_mcasp_dai_rates[i];\n\t\t\t\t\trange.empty = 0;\n\t\t\t\t}\n\t\t\t\trange.max = davinci_mcasp_dai_rates[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(rd->mcasp->dev,\n\t\t\"Frequencies %d-%d -> %d-%d for %d sbits and %d tdm slots\\n\",\n\t\tri->min, ri->max, range.min, range.max, sbits, slots);\n\n\treturn snd_interval_refine(hw_param_interval(params, rule->var),\n\t\t\t\t   &range);\n}\n\nstatic int davinci_mcasp_hw_rule_format(struct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct davinci_mcasp_ruledata *rd = rule->private;\n\tstruct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\n\tstruct snd_mask nfmt;\n\tint rate = params_rate(params);\n\tint slots = rd->mcasp->tdm_slots;\n\tint count = 0;\n\tsnd_pcm_format_t i;\n\n\tsnd_mask_none(&nfmt);\n\n\tpcm_for_each_format(i) {\n\t\tif (snd_mask_test_format(fmt, i)) {\n\t\t\tuint sbits = snd_pcm_format_width(i);\n\t\t\tunsigned int sysclk_freq;\n\t\t\tint ppm;\n\n\t\t\tif (rd->mcasp->auxclk_fs_ratio)\n\t\t\t\tsysclk_freq =  rate *\n\t\t\t\t\t       rd->mcasp->auxclk_fs_ratio;\n\t\t\telse\n\t\t\t\tsysclk_freq = rd->mcasp->sysclk_freq;\n\n\t\t\tif (rd->mcasp->slot_width)\n\t\t\t\tsbits = rd->mcasp->slot_width;\n\n\t\t\tppm = davinci_mcasp_calc_clk_div(rd->mcasp, sysclk_freq,\n\t\t\t\t\t\t\t sbits * slots * rate,\n\t\t\t\t\t\t\t false);\n\t\t\tif (abs(ppm) < DAVINCI_MAX_RATE_ERROR_PPM) {\n\t\t\t\tsnd_mask_set_format(&nfmt, i);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(rd->mcasp->dev,\n\t\t\"%d possible sample format for %d Hz and %d tdm slots\\n\",\n\t\tcount, rate, slots);\n\n\treturn snd_mask_refine(fmt, &nfmt);\n}\n\nstatic int davinci_mcasp_hw_rule_min_periodsize(\n\t\tstruct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval *period_size = hw_param_interval(params,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_PERIOD_SIZE);\n\tstruct snd_interval frames;\n\n\tsnd_interval_any(&frames);\n\tframes.min = 64;\n\tframes.integer = 1;\n\n\treturn snd_interval_refine(period_size, &frames);\n}\n\nstatic int davinci_mcasp_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *cpu_dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\tstruct davinci_mcasp_ruledata *ruledata =\n\t\t\t\t\t&mcasp->ruledata[substream->stream];\n\tu32 max_channels = 0;\n\tint i, dir, ret;\n\tint tdm_slots = mcasp->tdm_slots;\n\n\t \n\tif (mcasp->substreams[substream->stream])\n\t\treturn -EBUSY;\n\n\tmcasp->substreams[substream->stream] = substream;\n\n\tif (mcasp->tdm_mask[substream->stream])\n\t\ttdm_slots = hweight32(mcasp->tdm_mask[substream->stream]);\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\n\t\treturn 0;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tdir = TX_MODE;\n\telse\n\t\tdir = RX_MODE;\n\n\tfor (i = 0; i < mcasp->num_serializer; i++) {\n\t\tif (mcasp->serial_dir[i] == dir)\n\t\t\tmax_channels++;\n\t}\n\truledata->serializers = max_channels;\n\truledata->mcasp = mcasp;\n\tmax_channels *= tdm_slots;\n\t \n\tif (mcasp->channels && mcasp->channels < max_channels &&\n\t    ruledata->serializers == 1)\n\t\tmax_channels = mcasp->channels;\n\t \n\tif (max_channels < tdm_slots)\n\t\tmax_channels = tdm_slots;\n\n\tsnd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t     0, max_channels);\n\n\tsnd_pcm_hw_constraint_list(substream->runtime,\n\t\t\t\t   0, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t   &mcasp->chconstr[substream->stream]);\n\n\tif (mcasp->max_format_width) {\n\t\t \n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t  davinci_mcasp_hw_rule_format_width,\n\t\t\t\t\t  ruledata,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\telse if (mcasp->slot_width) {\n\t\t \n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t  davinci_mcasp_hw_rule_slot_width,\n\t\t\t\t\t  ruledata,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (mcasp->bclk_master && mcasp->bclk_div == 0 && mcasp->sysclk_freq) {\n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  davinci_mcasp_hw_rule_rate,\n\t\t\t\t\t  ruledata,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t  davinci_mcasp_hw_rule_format,\n\t\t\t\t\t  ruledata,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE, -1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsnd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t    SNDRV_PCM_HW_PARAM_PERIOD_SIZE,\n\t\t\t    davinci_mcasp_hw_rule_min_periodsize, NULL,\n\t\t\t    SNDRV_PCM_HW_PARAM_PERIOD_SIZE, -1);\n\n\treturn 0;\n}\n\nstatic void davinci_mcasp_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *cpu_dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tmcasp->substreams[substream->stream] = NULL;\n\tmcasp->active_serializers[substream->stream] = 0;\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE)\n\t\treturn;\n\n\tif (!snd_soc_dai_active(cpu_dai)) {\n\t\tmcasp->channels = 0;\n\t\tmcasp->max_format_width = 0;\n\t}\n}\n\nstatic int davinci_mcasp_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_iec958_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uctl)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tmemcpy(uctl->value.iec958.status, &mcasp->iec958_status,\n\t       sizeof(mcasp->iec958_status));\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_iec958_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *uctl)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tmemcpy(&mcasp->iec958_status, uctl->value.iec958.status,\n\t       sizeof(mcasp->iec958_status));\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_iec958_con_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(cpu_dai);\n\n\tmemset(ucontrol->value.iec958.status, 0xff, sizeof(mcasp->iec958_status));\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new davinci_mcasp_iec958_ctls[] = {\n\t{\n\t\t.access = (SNDRV_CTL_ELEM_ACCESS_READWRITE |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = davinci_mcasp_iec958_info,\n\t\t.get = davinci_mcasp_iec958_get,\n\t\t.put = davinci_mcasp_iec958_put,\n\t}, {\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, CON_MASK),\n\t\t.info = davinci_mcasp_iec958_info,\n\t\t.get = davinci_mcasp_iec958_con_mask_get,\n\t},\n};\n\nstatic void davinci_mcasp_init_iec958_status(struct davinci_mcasp *mcasp)\n{\n\tunsigned char *cs = (u8 *)&mcasp->iec958_status;\n\n\tcs[0] = IEC958_AES0_CON_NOT_COPYRIGHT | IEC958_AES0_CON_EMPHASIS_NONE;\n\tcs[1] = IEC958_AES1_CON_PCM_CODER;\n\tcs[2] = IEC958_AES2_CON_SOURCE_UNSPEC | IEC958_AES2_CON_CHANNEL_UNSPEC;\n\tcs[3] = IEC958_AES3_CON_CLOCK_1000PPM;\n}\n\nstatic int davinci_mcasp_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct davinci_mcasp *mcasp = snd_soc_dai_get_drvdata(dai);\n\tint stream;\n\n\tfor_each_pcm_streams(stream)\n\t\tsnd_soc_dai_dma_data_set(dai, stream, &mcasp->dma_data[stream]);\n\n\tif (mcasp->op_mode == DAVINCI_MCASP_DIT_MODE) {\n\t\tdavinci_mcasp_init_iec958_status(mcasp);\n\t\tsnd_soc_add_dai_controls(dai, davinci_mcasp_iec958_ctls,\n\t\t\t\t\t ARRAY_SIZE(davinci_mcasp_iec958_ctls));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops davinci_mcasp_dai_ops = {\n\t.probe\t\t= davinci_mcasp_dai_probe,\n\t.startup\t= davinci_mcasp_startup,\n\t.shutdown\t= davinci_mcasp_shutdown,\n\t.trigger\t= davinci_mcasp_trigger,\n\t.delay\t\t= davinci_mcasp_delay,\n\t.hw_params\t= davinci_mcasp_hw_params,\n\t.set_fmt\t= davinci_mcasp_set_dai_fmt,\n\t.set_clkdiv\t= davinci_mcasp_set_clkdiv,\n\t.set_sysclk\t= davinci_mcasp_set_sysclk,\n\t.set_tdm_slot\t= davinci_mcasp_set_tdm_slot,\n};\n\n#define DAVINCI_MCASP_RATES\tSNDRV_PCM_RATE_8000_192000\n\n#define DAVINCI_MCASP_PCM_FMTS (SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U8 | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U24_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_3LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U24_3LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_U32_LE)\n\nstatic struct snd_soc_dai_driver davinci_mcasp_dai[] = {\n\t{\n\t\t.name\t\t= \"davinci-mcasp.0\",\n\t\t.playback\t= {\n\t\t\t.stream_name = \"IIS Playback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 32 * 16,\n\t\t\t.rates \t\t= DAVINCI_MCASP_RATES,\n\t\t\t.formats\t= DAVINCI_MCASP_PCM_FMTS,\n\t\t},\n\t\t.capture \t= {\n\t\t\t.stream_name = \"IIS Capture\",\n\t\t\t.channels_min \t= 1,\n\t\t\t.channels_max\t= 32 * 16,\n\t\t\t.rates \t\t= DAVINCI_MCASP_RATES,\n\t\t\t.formats\t= DAVINCI_MCASP_PCM_FMTS,\n\t\t},\n\t\t.ops \t\t= &davinci_mcasp_dai_ops,\n\n\t\t.symmetric_rate\t\t= 1,\n\t},\n\t{\n\t\t.name\t\t= \"davinci-mcasp.1\",\n\t\t.playback \t= {\n\t\t\t.stream_name = \"DIT Playback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 384,\n\t\t\t.rates\t\t= DAVINCI_MCASP_RATES,\n\t\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE,\n\t\t},\n\t\t.ops \t\t= &davinci_mcasp_dai_ops,\n\t},\n\n};\n\nstatic const struct snd_soc_component_driver davinci_mcasp_component = {\n\t.name\t\t\t= \"davinci-mcasp\",\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic struct davinci_mcasp_pdata dm646x_mcasp_pdata = {\n\t.tx_dma_offset = 0x400,\n\t.rx_dma_offset = 0x400,\n\t.version = MCASP_VERSION_1,\n};\n\nstatic struct davinci_mcasp_pdata da830_mcasp_pdata = {\n\t.tx_dma_offset = 0x2000,\n\t.rx_dma_offset = 0x2000,\n\t.version = MCASP_VERSION_2,\n};\n\nstatic struct davinci_mcasp_pdata am33xx_mcasp_pdata = {\n\t.tx_dma_offset = 0,\n\t.rx_dma_offset = 0,\n\t.version = MCASP_VERSION_3,\n};\n\nstatic struct davinci_mcasp_pdata dra7_mcasp_pdata = {\n\t \n\t.tx_dma_offset = 0,\n\t.rx_dma_offset = 0,\n\t.version = MCASP_VERSION_4,\n};\n\nstatic struct davinci_mcasp_pdata omap_mcasp_pdata = {\n\t.tx_dma_offset = 0x200,\n\t.rx_dma_offset = 0,\n\t.version = MCASP_VERSION_OMAP,\n};\n\nstatic const struct of_device_id mcasp_dt_ids[] = {\n\t{\n\t\t.compatible = \"ti,dm646x-mcasp-audio\",\n\t\t.data = &dm646x_mcasp_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,da830-mcasp-audio\",\n\t\t.data = &da830_mcasp_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am33xx-mcasp-audio\",\n\t\t.data = &am33xx_mcasp_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,dra7-mcasp-audio\",\n\t\t.data = &dra7_mcasp_pdata,\n\t},\n\t{\n\t\t.compatible = \"ti,omap4-mcasp-audio\",\n\t\t.data = &omap_mcasp_pdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mcasp_dt_ids);\n\nstatic int mcasp_reparent_fck(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct clk *gfclk, *parent_clk;\n\tconst char *parent_name;\n\tint ret;\n\n\tif (!node)\n\t\treturn 0;\n\n\tparent_name = of_get_property(node, \"fck_parent\", NULL);\n\tif (!parent_name)\n\t\treturn 0;\n\n\tdev_warn(&pdev->dev, \"Update the bindings to use assigned-clocks!\\n\");\n\n\tgfclk = clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(gfclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get fck\\n\");\n\t\treturn PTR_ERR(gfclk);\n\t}\n\n\tparent_clk = clk_get(NULL, parent_name);\n\tif (IS_ERR(parent_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get parent clock\\n\");\n\t\tret = PTR_ERR(parent_clk);\n\t\tgoto err1;\n\t}\n\n\tret = clk_set_parent(gfclk, parent_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to reparent fck\\n\");\n\t\tgoto err2;\n\t}\n\nerr2:\n\tclk_put(parent_clk);\nerr1:\n\tclk_put(gfclk);\n\treturn ret;\n}\n\nstatic bool davinci_mcasp_have_gpiochip(struct davinci_mcasp *mcasp)\n{\n#ifdef CONFIG_OF_GPIO\n\treturn of_property_read_bool(mcasp->dev->of_node, \"gpio-controller\");\n#else\n\treturn false;\n#endif\n}\n\nstatic int davinci_mcasp_get_config(struct davinci_mcasp *mcasp,\n\t\t\t\t    struct platform_device *pdev)\n{\n\tconst struct of_device_id *match = of_match_device(mcasp_dt_ids, &pdev->dev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct davinci_mcasp_pdata *pdata = NULL;\n\tconst u32 *of_serial_dir32;\n\tu32 val;\n\tint i;\n\n\tif (pdev->dev.platform_data) {\n\t\tpdata = pdev->dev.platform_data;\n\t\tpdata->dismod = DISMOD_LOW;\n\t\tgoto out;\n\t} else if (match) {\n\t\tpdata = devm_kmemdup(&pdev->dev, match->data, sizeof(*pdata),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tdev_err(&pdev->dev, \"No compatible match found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"op-mode\", &val) == 0) {\n\t\tpdata->op_mode = val;\n\t} else {\n\t\tmcasp->missing_audio_param = true;\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"tdm-slots\", &val) == 0) {\n\t\tif (val < 2 || val > 32) {\n\t\t\tdev_err(&pdev->dev, \"tdm-slots must be in rage [2-32]\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpdata->tdm_slots = val;\n\t} else if (pdata->op_mode == DAVINCI_MCASP_IIS_MODE) {\n\t\tmcasp->missing_audio_param = true;\n\t\tgoto out;\n\t}\n\n\tof_serial_dir32 = of_get_property(np, \"serial-dir\", &val);\n\tval /= sizeof(u32);\n\tif (of_serial_dir32) {\n\t\tu8 *of_serial_dir = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t\t (sizeof(*of_serial_dir) * val),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!of_serial_dir)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < val; i++)\n\t\t\tof_serial_dir[i] = be32_to_cpup(&of_serial_dir32[i]);\n\n\t\tpdata->num_serializer = val;\n\t\tpdata->serial_dir = of_serial_dir;\n\t} else {\n\t\tmcasp->missing_audio_param = true;\n\t\tgoto out;\n\t}\n\n\tif (of_property_read_u32(np, \"tx-num-evt\", &val) == 0)\n\t\tpdata->txnumevt = val;\n\n\tif (of_property_read_u32(np, \"rx-num-evt\", &val) == 0)\n\t\tpdata->rxnumevt = val;\n\n\tif (of_property_read_u32(np, \"auxclk-fs-ratio\", &val) == 0)\n\t\tmcasp->auxclk_fs_ratio = val;\n\n\tif (of_property_read_u32(np, \"dismod\", &val) == 0) {\n\t\tif (val == 0 || val == 2 || val == 3) {\n\t\t\tpdata->dismod = DISMOD_VAL(val);\n\t\t} else {\n\t\t\tdev_warn(&pdev->dev, \"Invalid dismod value: %u\\n\", val);\n\t\t\tpdata->dismod = DISMOD_LOW;\n\t\t}\n\t} else {\n\t\tpdata->dismod = DISMOD_LOW;\n\t}\n\nout:\n\tmcasp->pdata = pdata;\n\n\tif (mcasp->missing_audio_param) {\n\t\tif (davinci_mcasp_have_gpiochip(mcasp)) {\n\t\t\tdev_dbg(&pdev->dev, \"Missing DT parameter(s) for audio\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(&pdev->dev, \"Insufficient DT parameter(s)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmcasp->op_mode = pdata->op_mode;\n\t \n\tif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE) {\n\t\tif (pdata->tdm_slots < 2) {\n\t\t\tdev_warn(&pdev->dev, \"invalid tdm slots: %d\\n\",\n\t\t\t\t pdata->tdm_slots);\n\t\t\tmcasp->tdm_slots = 2;\n\t\t} else if (pdata->tdm_slots > 32) {\n\t\t\tdev_warn(&pdev->dev, \"invalid tdm slots: %d\\n\",\n\t\t\t\t pdata->tdm_slots);\n\t\t\tmcasp->tdm_slots = 32;\n\t\t} else {\n\t\t\tmcasp->tdm_slots = pdata->tdm_slots;\n\t\t}\n\t} else {\n\t\tmcasp->tdm_slots = 32;\n\t}\n\n\tmcasp->num_serializer = pdata->num_serializer;\n#ifdef CONFIG_PM\n\tmcasp->context.xrsr_regs = devm_kcalloc(&pdev->dev,\n\t\t\t\t\t\tmcasp->num_serializer, sizeof(u32),\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!mcasp->context.xrsr_regs)\n\t\treturn -ENOMEM;\n#endif\n\tmcasp->serial_dir = pdata->serial_dir;\n\tmcasp->version = pdata->version;\n\tmcasp->txnumevt = pdata->txnumevt;\n\tmcasp->rxnumevt = pdata->rxnumevt;\n\tmcasp->dismod = pdata->dismod;\n\n\treturn 0;\n}\n\nenum {\n\tPCM_EDMA,\n\tPCM_SDMA,\n\tPCM_UDMA,\n};\nstatic const char *sdma_prefix = \"ti,omap\";\n\nstatic int davinci_mcasp_get_dma_type(struct davinci_mcasp *mcasp)\n{\n\tstruct dma_chan *chan;\n\tconst char *tmp;\n\tint ret = PCM_EDMA;\n\n\tif (!mcasp->dev->of_node)\n\t\treturn PCM_EDMA;\n\n\ttmp = mcasp->dma_data[SNDRV_PCM_STREAM_PLAYBACK].filter_data;\n\tchan = dma_request_chan(mcasp->dev, tmp);\n\tif (IS_ERR(chan))\n\t\treturn dev_err_probe(mcasp->dev, PTR_ERR(chan),\n\t\t\t\t     \"Can't verify DMA configuration\\n\");\n\tif (WARN_ON(!chan->device || !chan->device->dev)) {\n\t\tdma_release_channel(chan);\n\t\treturn -EINVAL;\n\t}\n\n\tif (chan->device->dev->of_node)\n\t\tret = of_property_read_string(chan->device->dev->of_node,\n\t\t\t\t\t      \"compatible\", &tmp);\n\telse\n\t\tdev_dbg(mcasp->dev, \"DMA controller has no of-node\\n\");\n\n\tdma_release_channel(chan);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(mcasp->dev, \"DMA controller compatible = \\\"%s\\\"\\n\", tmp);\n\tif (!strncmp(tmp, sdma_prefix, strlen(sdma_prefix)))\n\t\treturn PCM_SDMA;\n\telse if (strstr(tmp, \"udmap\"))\n\t\treturn PCM_UDMA;\n\telse if (strstr(tmp, \"bcdma\"))\n\t\treturn PCM_UDMA;\n\n\treturn PCM_EDMA;\n}\n\nstatic u32 davinci_mcasp_txdma_offset(struct davinci_mcasp_pdata *pdata)\n{\n\tint i;\n\tu32 offset = 0;\n\n\tif (pdata->version != MCASP_VERSION_4)\n\t\treturn pdata->tx_dma_offset;\n\n\tfor (i = 0; i < pdata->num_serializer; i++) {\n\t\tif (pdata->serial_dir[i] == TX_MODE) {\n\t\t\tif (!offset) {\n\t\t\t\toffset = DAVINCI_MCASP_TXBUF_REG(i);\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: Only one serializer allowed!\\n\",\n\t\t\t\t       __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn offset;\n}\n\nstatic u32 davinci_mcasp_rxdma_offset(struct davinci_mcasp_pdata *pdata)\n{\n\tint i;\n\tu32 offset = 0;\n\n\tif (pdata->version != MCASP_VERSION_4)\n\t\treturn pdata->rx_dma_offset;\n\n\tfor (i = 0; i < pdata->num_serializer; i++) {\n\t\tif (pdata->serial_dir[i] == RX_MODE) {\n\t\t\tif (!offset) {\n\t\t\t\toffset = DAVINCI_MCASP_RXBUF_REG(i);\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: Only one serializer allowed!\\n\",\n\t\t\t\t       __func__);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic int davinci_mcasp_gpio_request(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\n\tif (mcasp->num_serializer && offset < mcasp->num_serializer &&\n\t    mcasp->serial_dir[offset] != INACTIVE_MODE) {\n\t\tdev_err(mcasp->dev, \"AXR%u pin is  used for audio\\n\", offset);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\treturn pm_runtime_resume_and_get(mcasp->dev);\n}\n\nstatic void davinci_mcasp_gpio_free(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\n\t \n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(offset));\n\n\t \n\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PFUNC_REG, BIT(offset));\n\n\tpm_runtime_put_sync(mcasp->dev);\n}\n\nstatic int davinci_mcasp_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned offset, int value)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\tu32 val;\n\n\tif (value)\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PDOUT_REG, BIT(offset));\n\telse\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDOUT_REG, BIT(offset));\n\n\tval = mcasp_get_reg(mcasp, DAVINCI_MCASP_PFUNC_REG);\n\tif (!(val & BIT(offset))) {\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PFUNC_REG, BIT(offset));\n\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(offset));\n\t}\n\n\treturn 0;\n}\n\nstatic void davinci_mcasp_gpio_set(struct gpio_chip *chip, unsigned offset,\n\t\t\t\t  int value)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\n\tif (value)\n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PDOUT_REG, BIT(offset));\n\telse\n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDOUT_REG, BIT(offset));\n}\n\nstatic int davinci_mcasp_gpio_direction_in(struct gpio_chip *chip,\n\t\t\t\t\t   unsigned offset)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\tu32 val;\n\n\tval = mcasp_get_reg(mcasp, DAVINCI_MCASP_PFUNC_REG);\n\tif (!(val & BIT(offset))) {\n\t\t \n\t\tmcasp_clr_bits(mcasp, DAVINCI_MCASP_PDIR_REG, BIT(offset));\n\n\t\t \n\t\tmcasp_set_bits(mcasp, DAVINCI_MCASP_PFUNC_REG, BIT(offset));\n\t}\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\tu32 val;\n\n\tval = mcasp_get_reg(mcasp, DAVINCI_MCASP_PDSET_REG);\n\tif (val & BIT(offset))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t\t    unsigned offset)\n{\n\tstruct davinci_mcasp *mcasp = gpiochip_get_data(chip);\n\tu32 val;\n\n\tval = mcasp_get_reg(mcasp, DAVINCI_MCASP_PDIR_REG);\n\tif (val & BIT(offset))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic const struct gpio_chip davinci_mcasp_template_chip = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= davinci_mcasp_gpio_request,\n\t.free\t\t\t= davinci_mcasp_gpio_free,\n\t.direction_output\t= davinci_mcasp_gpio_direction_out,\n\t.set\t\t\t= davinci_mcasp_gpio_set,\n\t.direction_input\t= davinci_mcasp_gpio_direction_in,\n\t.get\t\t\t= davinci_mcasp_gpio_get,\n\t.get_direction\t\t= davinci_mcasp_gpio_get_direction,\n\t.base\t\t\t= -1,\n\t.ngpio\t\t\t= 32,\n};\n\nstatic int davinci_mcasp_init_gpiochip(struct davinci_mcasp *mcasp)\n{\n\tif (!davinci_mcasp_have_gpiochip(mcasp))\n\t\treturn 0;\n\n\tmcasp->gpio_chip = davinci_mcasp_template_chip;\n\tmcasp->gpio_chip.label = dev_name(mcasp->dev);\n\tmcasp->gpio_chip.parent = mcasp->dev;\n\n\treturn devm_gpiochip_add_data(mcasp->dev, &mcasp->gpio_chip, mcasp);\n}\n\n#else  \nstatic inline int davinci_mcasp_init_gpiochip(struct davinci_mcasp *mcasp)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int davinci_mcasp_probe(struct platform_device *pdev)\n{\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tstruct resource *mem, *dat;\n\tstruct davinci_mcasp *mcasp;\n\tchar *irq_name;\n\tint irq;\n\tint ret;\n\n\tif (!pdev->dev.platform_data && !pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"No platform data supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmcasp = devm_kzalloc(&pdev->dev, sizeof(struct davinci_mcasp),\n\t\t\t   GFP_KERNEL);\n\tif (!mcasp)\n\t\treturn\t-ENOMEM;\n\n\tmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mpu\");\n\tif (!mem) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"\\\"mpu\\\" mem resource not found, using index 0\\n\");\n\t\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!mem) {\n\t\t\tdev_err(&pdev->dev, \"no mem resource?\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tmcasp->base = devm_ioremap_resource(&pdev->dev, mem);\n\tif (IS_ERR(mcasp->base))\n\t\treturn PTR_ERR(mcasp->base);\n\n\tdev_set_drvdata(&pdev->dev, mcasp);\n\tpm_runtime_enable(&pdev->dev);\n\n\tmcasp->dev = &pdev->dev;\n\tret = davinci_mcasp_get_config(mcasp, pdev);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tpm_runtime_get_sync(mcasp->dev);\n\tmcasp_set_reg(mcasp, DAVINCI_MCASP_PFUNC_REG, 0x00000000);\n\tpm_runtime_put(mcasp->dev);\n\n\t \n\tif (mcasp->missing_audio_param)\n\t\tgoto no_audio;\n\n\tirq = platform_get_irq_byname_optional(pdev, \"common\");\n\tif (irq > 0) {\n\t\tirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_common\",\n\t\t\t\t\t  dev_name(&pdev->dev));\n\t\tif (!irq_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tdavinci_mcasp_common_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t\t\tirq_name, mcasp);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"common IRQ request failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK] = XUNDRN;\n\t\tmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE] = ROVRN;\n\t}\n\n\tirq = platform_get_irq_byname_optional(pdev, \"rx\");\n\tif (irq > 0) {\n\t\tirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_rx\",\n\t\t\t\t\t  dev_name(&pdev->dev));\n\t\tif (!irq_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tdavinci_mcasp_rx_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, irq_name, mcasp);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"RX IRQ request failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tmcasp->irq_request[SNDRV_PCM_STREAM_CAPTURE] = ROVRN;\n\t}\n\n\tirq = platform_get_irq_byname_optional(pdev, \"tx\");\n\tif (irq > 0) {\n\t\tirq_name = devm_kasprintf(&pdev->dev, GFP_KERNEL, \"%s_tx\",\n\t\t\t\t\t  dev_name(&pdev->dev));\n\t\tif (!irq_name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tdavinci_mcasp_tx_irq_handler,\n\t\t\t\t\t\tIRQF_ONESHOT, irq_name, mcasp);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"TX IRQ request failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tmcasp->irq_request[SNDRV_PCM_STREAM_PLAYBACK] = XUNDRN;\n\t}\n\n\tdat = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dat\");\n\tif (dat)\n\t\tmcasp->dat_port = true;\n\n\tdma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_PLAYBACK];\n\tdma_data->filter_data = \"tx\";\n\tif (dat) {\n\t\tdma_data->addr = dat->start;\n\t\t \n\t\tif (mcasp->version == MCASP_VERSION_OMAP)\n\t\t\tdma_data->addr += davinci_mcasp_txdma_offset(mcasp->pdata);\n\t} else {\n\t\tdma_data->addr = mem->start + davinci_mcasp_txdma_offset(mcasp->pdata);\n\t}\n\n\n\t \n\tif (mcasp->op_mode != DAVINCI_MCASP_DIT_MODE) {\n\t\tdma_data = &mcasp->dma_data[SNDRV_PCM_STREAM_CAPTURE];\n\t\tdma_data->filter_data = \"rx\";\n\t\tif (dat)\n\t\t\tdma_data->addr = dat->start;\n\t\telse\n\t\t\tdma_data->addr =\n\t\t\t\tmem->start + davinci_mcasp_rxdma_offset(mcasp->pdata);\n\t}\n\n\tif (mcasp->version < MCASP_VERSION_3) {\n\t\tmcasp->fifo_base = DAVINCI_MCASP_V2_AFIFO_BASE;\n\t\t \n\t\tmcasp->dat_port = true;\n\t} else {\n\t\tmcasp->fifo_base = DAVINCI_MCASP_V3_AFIFO_BASE;\n\t}\n\n\t \n\tmcasp->chconstr[SNDRV_PCM_STREAM_PLAYBACK].list =\n\t\tdevm_kcalloc(mcasp->dev,\n\t\t\t     32 + mcasp->num_serializer - 1,\n\t\t\t     sizeof(unsigned int),\n\t\t\t     GFP_KERNEL);\n\n\tmcasp->chconstr[SNDRV_PCM_STREAM_CAPTURE].list =\n\t\tdevm_kcalloc(mcasp->dev,\n\t\t\t     32 + mcasp->num_serializer - 1,\n\t\t\t     sizeof(unsigned int),\n\t\t\t     GFP_KERNEL);\n\n\tif (!mcasp->chconstr[SNDRV_PCM_STREAM_PLAYBACK].list ||\n\t    !mcasp->chconstr[SNDRV_PCM_STREAM_CAPTURE].list) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = davinci_mcasp_set_ch_constraints(mcasp);\n\tif (ret)\n\t\tgoto err;\n\n\tmcasp_reparent_fck(pdev);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &davinci_mcasp_component,\n\t\t\t\t\t      &davinci_mcasp_dai[mcasp->op_mode], 1);\n\n\tif (ret != 0)\n\t\tgoto err;\n\n\tret = davinci_mcasp_get_dma_type(mcasp);\n\tswitch (ret) {\n\tcase PCM_EDMA:\n\t\tret = edma_pcm_platform_register(&pdev->dev);\n\t\tbreak;\n\tcase PCM_SDMA:\n\t\tif (mcasp->op_mode == DAVINCI_MCASP_IIS_MODE)\n\t\t\tret = sdma_pcm_platform_register(&pdev->dev, \"tx\", \"rx\");\n\t\telse\n\t\t\tret = sdma_pcm_platform_register(&pdev->dev, \"tx\", NULL);\n\t\tbreak;\n\tcase PCM_UDMA:\n\t\tret = udma_pcm_platform_register(&pdev->dev);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"No DMA controller found (%d)\\n\", ret);\n\t\tfallthrough;\n\tcase -EPROBE_DEFER:\n\t\tgoto err;\n\t}\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"register PCM failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\nno_audio:\n\tret = davinci_mcasp_init_gpiochip(mcasp);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"gpiochip registration failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tpm_runtime_disable(&pdev->dev);\n\treturn ret;\n}\n\nstatic void davinci_mcasp_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int davinci_mcasp_runtime_suspend(struct device *dev)\n{\n\tstruct davinci_mcasp *mcasp = dev_get_drvdata(dev);\n\tstruct davinci_mcasp_context *context = &mcasp->context;\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(context_regs); i++)\n\t\tcontext->config_regs[i] = mcasp_get_reg(mcasp, context_regs[i]);\n\n\tif (mcasp->txnumevt) {\n\t\treg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\n\t\tcontext->afifo_regs[0] = mcasp_get_reg(mcasp, reg);\n\t}\n\tif (mcasp->rxnumevt) {\n\t\treg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\n\t\tcontext->afifo_regs[1] = mcasp_get_reg(mcasp, reg);\n\t}\n\n\tfor (i = 0; i < mcasp->num_serializer; i++)\n\t\tcontext->xrsr_regs[i] = mcasp_get_reg(mcasp,\n\t\t\t\t\t\tDAVINCI_MCASP_XRSRCTL_REG(i));\n\n\treturn 0;\n}\n\nstatic int davinci_mcasp_runtime_resume(struct device *dev)\n{\n\tstruct davinci_mcasp *mcasp = dev_get_drvdata(dev);\n\tstruct davinci_mcasp_context *context = &mcasp->context;\n\tu32 reg;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(context_regs); i++)\n\t\tmcasp_set_reg(mcasp, context_regs[i], context->config_regs[i]);\n\n\tif (mcasp->txnumevt) {\n\t\treg = mcasp->fifo_base + MCASP_WFIFOCTL_OFFSET;\n\t\tmcasp_set_reg(mcasp, reg, context->afifo_regs[0]);\n\t}\n\tif (mcasp->rxnumevt) {\n\t\treg = mcasp->fifo_base + MCASP_RFIFOCTL_OFFSET;\n\t\tmcasp_set_reg(mcasp, reg, context->afifo_regs[1]);\n\t}\n\n\tfor (i = 0; i < mcasp->num_serializer; i++)\n\t\tmcasp_set_reg(mcasp, DAVINCI_MCASP_XRSRCTL_REG(i),\n\t\t\t      context->xrsr_regs[i]);\n\n\treturn 0;\n}\n\n#endif\n\nstatic const struct dev_pm_ops davinci_mcasp_pm_ops = {\n\tSET_RUNTIME_PM_OPS(davinci_mcasp_runtime_suspend,\n\t\t\t   davinci_mcasp_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver davinci_mcasp_driver = {\n\t.probe\t\t= davinci_mcasp_probe,\n\t.remove_new\t= davinci_mcasp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"davinci-mcasp\",\n\t\t.pm     = &davinci_mcasp_pm_ops,\n\t\t.of_match_table = mcasp_dt_ids,\n\t},\n};\n\nmodule_platform_driver(davinci_mcasp_driver);\n\nMODULE_AUTHOR(\"Steve Chen\");\nMODULE_DESCRIPTION(\"TI DAVINCI McASP SoC Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}