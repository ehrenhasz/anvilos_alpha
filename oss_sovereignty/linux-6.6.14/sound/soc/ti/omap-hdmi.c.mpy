{
  "module_name": "omap-hdmi.c",
  "hash_id": "0a24b52d15a45fc2d308713b96619077d092b57f6191ec382eb0c43ddabf10cd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <sound/dmaengine_pcm.h>\n#include <uapi/sound/asound.h>\n#include <sound/asoundef.h>\n#include <sound/omap-hdmi-audio.h>\n\n#include \"sdma-pcm.h\"\n\n#define DRV_NAME \"omap-hdmi-audio\"\n\nstruct hdmi_audio_data {\n\tstruct snd_soc_card *card;\n\n\tconst struct omap_hdmi_audio_ops *ops;\n\tstruct device *dssdev;\n\tstruct snd_dmaengine_dai_dma_data dma_data;\n\tstruct omap_dss_audio dss_audio;\n\tstruct snd_aes_iec958 iec;\n\tstruct snd_cea_861_aud_if cea;\n\n\tstruct mutex current_stream_lock;\n\tstruct snd_pcm_substream *current_stream;\n};\n\nstatic\nstruct hdmi_audio_data *card_drvdata_substream(struct snd_pcm_substream *ss)\n{\n\tstruct snd_soc_pcm_runtime *rtd = ss->private_data;\n\n\treturn snd_soc_card_get_drvdata(rtd->card);\n}\n\nstatic void hdmi_dai_abort(struct device *dev)\n{\n\tstruct hdmi_audio_data *ad = dev_get_drvdata(dev);\n\n\tmutex_lock(&ad->current_stream_lock);\n\tif (ad->current_stream && ad->current_stream->runtime &&\n\t    snd_pcm_running(ad->current_stream)) {\n\t\tdev_err(dev, \"HDMI display disabled, aborting playback\\n\");\n\t\tsnd_pcm_stream_lock_irq(ad->current_stream);\n\t\tsnd_pcm_stop(ad->current_stream, SNDRV_PCM_STATE_DISCONNECTED);\n\t\tsnd_pcm_stream_unlock_irq(ad->current_stream);\n\t}\n\tmutex_unlock(&ad->current_stream_lock);\n}\n\nstatic int hdmi_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\n\tint ret;\n\t \n\tret = snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 128);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Could not apply period constraint: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tret = snd_pcm_hw_constraint_step(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 128);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Could not apply buffer constraint: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tsnd_soc_dai_set_dma_data(dai, substream, &ad->dma_data);\n\n\tmutex_lock(&ad->current_stream_lock);\n\tad->current_stream = substream;\n\tmutex_unlock(&ad->current_stream_lock);\n\n\tret = ad->ops->audio_startup(ad->dssdev, hdmi_dai_abort);\n\n\tif (ret) {\n\t\tmutex_lock(&ad->current_stream_lock);\n\t\tad->current_stream = NULL;\n\t\tmutex_unlock(&ad->current_stream_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int hdmi_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\n\tstruct snd_aes_iec958 *iec = &ad->iec;\n\tstruct snd_cea_861_aud_if *cea = &ad->cea;\n\n\tWARN_ON(ad->current_stream != substream);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tad->dma_data.maxburst = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tad->dma_data.maxburst = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"format not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tad->dss_audio.iec = iec;\n\tad->dss_audio.cea = cea;\n\t \n\t \n\tmemset(iec->status, 0, sizeof(iec->status));\n\n\t \n\tiec->status[0] &= ~IEC958_AES0_PROFESSIONAL;\n\n\t \n\tiec->status[0] &= ~IEC958_AES0_NONAUDIO;\n\n\tiec->status[0] |= IEC958_AES0_CON_NOT_COPYRIGHT;\n\n\tiec->status[0] |= IEC958_AES0_CON_EMPHASIS_NONE;\n\n\tiec->status[1] = IEC958_AES1_CON_GENERAL;\n\n\tiec->status[2] |= IEC958_AES2_CON_SOURCE_UNSPEC;\n\n\tiec->status[2] |= IEC958_AES2_CON_CHANNEL_UNSPEC;\n\n\tswitch (params_rate(params)) {\n\tcase 32000:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 176400:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 192000:\n\t\tiec->status[3] |= IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"rate not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tiec->status[3] |= IEC958_AES3_CON_CLOCK_1000PPM;\n\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tiec->status[4] |= IEC958_AES4_CON_WORDLEN_20_16;\n\t\tiec->status[4] &= ~IEC958_AES4_CON_MAX_WORDLEN_24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tiec->status[4] |= IEC958_AES4_CON_WORDLEN_24_20;\n\t\tiec->status[4] |= IEC958_AES4_CON_MAX_WORDLEN_24;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"format not supported!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tcea->db1_ct_cc = (params_channels(params) - 1)\n\t\t& CEA861_AUDIO_INFOFRAME_DB1CC;\n\tcea->db1_ct_cc |= CEA861_AUDIO_INFOFRAME_DB1CT_FROM_STREAM;\n\n\tcea->db2_sf_ss = CEA861_AUDIO_INFOFRAME_DB2SF_FROM_STREAM;\n\tcea->db2_sf_ss |= CEA861_AUDIO_INFOFRAME_DB2SS_FROM_STREAM;\n\n\tcea->db3 = 0;  \n\n\tif (params_channels(params) == 2)\n\t\tcea->db4_ca = 0x0;\n\telse if (params_channels(params) == 6)\n\t\tcea->db4_ca = 0xb;\n\telse\n\t\tcea->db4_ca = 0x13;\n\n\tif (cea->db4_ca == 0x00)\n\t\tcea->db5_dminh_lsv = CEA861_AUDIO_INFOFRAME_DB5_DM_INH_PERMITTED;\n\telse\n\t\tcea->db5_dminh_lsv = CEA861_AUDIO_INFOFRAME_DB5_DM_INH_PROHIBITED;\n\n\t \n\tcea->db5_dminh_lsv |= (0 & CEA861_AUDIO_INFOFRAME_DB5_LSV);\n\n\treturn ad->ops->audio_config(ad->dssdev, &ad->dss_audio);\n}\n\nstatic int hdmi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\n\tint err = 0;\n\n\tWARN_ON(ad->current_stream != substream);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\terr = ad->ops->audio_start(ad->dssdev);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tad->ops->audio_stop(ad->dssdev);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\treturn err;\n}\n\nstatic void hdmi_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct hdmi_audio_data *ad = card_drvdata_substream(substream);\n\n\tWARN_ON(ad->current_stream != substream);\n\n\tad->ops->audio_shutdown(ad->dssdev);\n\n\tmutex_lock(&ad->current_stream_lock);\n\tad->current_stream = NULL;\n\tmutex_unlock(&ad->current_stream_lock);\n}\n\nstatic const struct snd_soc_dai_ops hdmi_dai_ops = {\n\t.startup\t= hdmi_dai_startup,\n\t.hw_params\t= hdmi_dai_hw_params,\n\t.trigger\t= hdmi_dai_trigger,\n\t.shutdown\t= hdmi_dai_shutdown,\n};\n\nstatic const struct snd_soc_component_driver omap_hdmi_component = {\n\t.name = \"omapdss_hdmi\",\n\t.legacy_dai_naming = 1,\n};\n\nstatic struct snd_soc_dai_driver omap5_hdmi_dai = {\n\t.name = \"omap5-hdmi-dai\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t  SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\t  SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\t  SNDRV_PCM_RATE_192000),\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &hdmi_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver omap4_hdmi_dai = {\n\t.name = \"omap4-hdmi-dai\",\n\t.playback = {\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t  SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\n\t\t\t  SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\n\t\t\t  SNDRV_PCM_RATE_192000),\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.ops = &hdmi_dai_ops,\n};\n\nstatic int omap_hdmi_audio_probe(struct platform_device *pdev)\n{\n\tstruct omap_hdmi_audio_pdata *ha = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi_audio_data *ad;\n\tstruct snd_soc_dai_driver *dai_drv;\n\tstruct snd_soc_card *card;\n\tstruct snd_soc_dai_link_component *compnent;\n\tint ret;\n\n\tif (!ha) {\n\t\tdev_err(dev, \"No platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tad = devm_kzalloc(dev, sizeof(*ad), GFP_KERNEL);\n\tif (!ad)\n\t\treturn -ENOMEM;\n\tad->dssdev = ha->dev;\n\tad->ops = ha->ops;\n\tad->dma_data.addr = ha->audio_dma_addr;\n\tad->dma_data.filter_data = \"audio_tx\";\n\tad->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tmutex_init(&ad->current_stream_lock);\n\n\tswitch (ha->version) {\n\tcase 4:\n\t\tdai_drv = &omap4_hdmi_dai;\n\t\tbreak;\n\tcase 5:\n\t\tdai_drv = &omap5_hdmi_dai;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = devm_snd_soc_register_component(ad->dssdev, &omap_hdmi_component,\n\t\t\t\t\t dai_drv, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdma_pcm_platform_register(ad->dssdev, \"audio_tx\", NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tcard = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->name = devm_kasprintf(dev, GFP_KERNEL,\n\t\t\t\t    \"HDMI %s\", dev_name(ad->dssdev));\n\tif (!card->name)\n\t\treturn -ENOMEM;\n\n\tcard->owner = THIS_MODULE;\n\tcard->dai_link =\n\t\tdevm_kzalloc(dev, sizeof(*(card->dai_link)), GFP_KERNEL);\n\tif (!card->dai_link)\n\t\treturn -ENOMEM;\n\n\tcompnent = devm_kzalloc(dev, sizeof(*compnent), GFP_KERNEL);\n\tif (!compnent)\n\t\treturn -ENOMEM;\n\tcard->dai_link->cpus\t\t= compnent;\n\tcard->dai_link->num_cpus\t= 1;\n\tcard->dai_link->codecs\t\t= &asoc_dummy_dlc;\n\tcard->dai_link->num_codecs\t= 1;\n\n\tcard->dai_link->name = card->name;\n\tcard->dai_link->stream_name = card->name;\n\tcard->dai_link->cpus->dai_name = dev_name(ad->dssdev);\n\tcard->num_links = 1;\n\tcard->dev = dev;\n\n\tret = snd_soc_register_card(card);\n\tif (ret) {\n\t\tdev_err(dev, \"snd_soc_register_card failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tad->card = card;\n\tsnd_soc_card_set_drvdata(card, ad);\n\n\tdev_set_drvdata(dev, ad);\n\n\treturn 0;\n}\n\nstatic void omap_hdmi_audio_remove(struct platform_device *pdev)\n{\n\tstruct hdmi_audio_data *ad = platform_get_drvdata(pdev);\n\n\tsnd_soc_unregister_card(ad->card);\n}\n\nstatic struct platform_driver hdmi_audio_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = omap_hdmi_audio_probe,\n\t.remove_new = omap_hdmi_audio_remove,\n};\n\nmodule_platform_driver(hdmi_audio_driver);\n\nMODULE_AUTHOR(\"Jyri Sarha <jsarha@ti.com>\");\nMODULE_DESCRIPTION(\"OMAP HDMI Audio Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}