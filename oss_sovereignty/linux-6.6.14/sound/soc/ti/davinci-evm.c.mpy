{
  "module_name": "davinci-evm.c",
  "hash_id": "e3bedd0dff9bd2e4c1f58665eb9df26f1fafc6d398449a657b6c2c24f96b0bc0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/davinci-evm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/i2c.h>\n#include <linux/of_platform.h>\n#include <linux/clk.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#include <asm/dma.h>\n#include <asm/mach-types.h>\n\nstruct snd_soc_card_drvdata_davinci {\n\tstruct clk *mclk;\n\tunsigned sysclk;\n};\n\nstatic int evm_startup(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *soc_card = rtd->card;\n\tstruct snd_soc_card_drvdata_davinci *drvdata =\n\t\tsnd_soc_card_get_drvdata(soc_card);\n\n\tif (drvdata->mclk)\n\t\treturn clk_prepare_enable(drvdata->mclk);\n\n\treturn 0;\n}\n\nstatic void evm_shutdown(struct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_card *soc_card = rtd->card;\n\tstruct snd_soc_card_drvdata_davinci *drvdata =\n\t\tsnd_soc_card_get_drvdata(soc_card);\n\n\tclk_disable_unprepare(drvdata->mclk);\n}\n\nstatic int evm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t struct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tstruct snd_soc_card *soc_card = rtd->card;\n\tint ret = 0;\n\tunsigned sysclk = ((struct snd_soc_card_drvdata_davinci *)\n\t\t\t   snd_soc_card_get_drvdata(soc_card))->sysclk;\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, 0, sysclk, SND_SOC_CLOCK_OUT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dai_set_sysclk(cpu_dai, 0, sysclk, SND_SOC_CLOCK_OUT);\n\tif (ret < 0 && ret != -ENOTSUPP)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops evm_ops = {\n\t.startup = evm_startup,\n\t.shutdown = evm_shutdown,\n\t.hw_params = evm_hw_params,\n};\n\n \nstatic const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {\n\tSND_SOC_DAPM_HP(\"Headphone Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line Out\", NULL),\n\tSND_SOC_DAPM_MIC(\"Mic Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In\", NULL),\n};\n\n \nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t \n\t{\"Headphone Jack\", NULL, \"HPLOUT\"},\n\t{\"Headphone Jack\", NULL, \"HPROUT\"},\n\n\t \n\t{\"Line Out\", NULL, \"LLOUT\"},\n\t{\"Line Out\", NULL, \"RLOUT\"},\n\n\t \n\t{\"MIC3L\", NULL, \"Mic Bias\"},\n\t{\"MIC3R\", NULL, \"Mic Bias\"},\n\t{\"Mic Bias\", NULL, \"Mic Jack\"},\n\n\t \n\t{\"LINE1L\", NULL, \"Line In\"},\n\t{\"LINE2L\", NULL, \"Line In\"},\n\t{\"LINE1R\", NULL, \"Line In\"},\n\t{\"LINE2R\", NULL, \"Line In\"},\n};\n\n \nstatic int evm_aic3x_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct device_node *np = card->dev->of_node;\n\tint ret;\n\n\t \n\tsnd_soc_dapm_new_controls(&card->dapm, aic3x_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(aic3x_dapm_widgets));\n\n\tif (np) {\n\t\tret = snd_soc_of_parse_audio_routing(card, \"ti,audio-routing\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tsnd_soc_dapm_add_routes(&card->dapm, audio_map,\n\t\t\t\t\tARRAY_SIZE(audio_map));\n\t}\n\n\t \n\tsnd_soc_dapm_nc_pin(&card->dapm, \"MONO_LOUT\");\n\tsnd_soc_dapm_nc_pin(&card->dapm, \"HPLCOM\");\n\tsnd_soc_dapm_nc_pin(&card->dapm, \"HPRCOM\");\n\n\treturn 0;\n}\n\n \nSND_SOC_DAILINK_DEFS(evm,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(NULL, \"tlv320aic3x-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstatic struct snd_soc_dai_link evm_dai_tlv320aic3x = {\n\t.name\t\t= \"TLV320AIC3X\",\n\t.stream_name\t= \"AIC3X\",\n\t.ops            = &evm_ops,\n\t.init           = evm_aic3x_init,\n\t.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBM_CFM |\n\t\t   SND_SOC_DAIFMT_IB_NF,\n\tSND_SOC_DAILINK_REG(evm),\n};\n\nstatic const struct of_device_id davinci_evm_dt_ids[] = {\n\t{\n\t\t.compatible = \"ti,da830-evm-audio\",\n\t\t.data = (void *) &evm_dai_tlv320aic3x,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, davinci_evm_dt_ids);\n\n \nstatic struct snd_soc_card evm_soc_card = {\n\t.owner = THIS_MODULE,\n\t.num_links = 1,\n};\n\nstatic int davinci_evm_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct snd_soc_dai_link *dai;\n\tstruct snd_soc_card_drvdata_davinci *drvdata = NULL;\n\tstruct clk *mclk;\n\tint ret = 0;\n\n\tmatch = of_match_device(of_match_ptr(davinci_evm_dt_ids), &pdev->dev);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"Error: No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdai = (struct snd_soc_dai_link *) match->data;\n\n\tevm_soc_card.dai_link = dai;\n\n\tdai->codecs->of_node = of_parse_phandle(np, \"ti,audio-codec\", 0);\n\tif (!dai->codecs->of_node)\n\t\treturn -EINVAL;\n\n\tdai->cpus->of_node = of_parse_phandle(np, \"ti,mcasp-controller\", 0);\n\tif (!dai->cpus->of_node)\n\t\treturn -EINVAL;\n\n\tdai->platforms->of_node = dai->cpus->of_node;\n\n\tevm_soc_card.dev = &pdev->dev;\n\tret = snd_soc_of_parse_card_name(&evm_soc_card, \"ti,model\");\n\tif (ret)\n\t\treturn ret;\n\n\tmclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (PTR_ERR(mclk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (IS_ERR(mclk)) {\n\t\tdev_dbg(&pdev->dev, \"mclk not found.\\n\");\n\t\tmclk = NULL;\n\t}\n\n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\tdrvdata->mclk = mclk;\n\n\tret = of_property_read_u32(np, \"ti,codec-clock-rate\", &drvdata->sysclk);\n\n\tif (ret < 0) {\n\t\tif (!drvdata->mclk) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"No clock or clock rate defined.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdrvdata->sysclk = clk_get_rate(drvdata->mclk);\n\t} else if (drvdata->mclk) {\n\t\tunsigned int requestd_rate = drvdata->sysclk;\n\t\tclk_set_rate(drvdata->mclk, drvdata->sysclk);\n\t\tdrvdata->sysclk = clk_get_rate(drvdata->mclk);\n\t\tif (drvdata->sysclk != requestd_rate)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"Could not get requested rate %u using %u.\\n\",\n\t\t\t\t requestd_rate, drvdata->sysclk);\n\t}\n\n\tsnd_soc_card_set_drvdata(&evm_soc_card, drvdata);\n\tret = devm_snd_soc_register_card(&pdev->dev, &evm_soc_card);\n\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"snd_soc_register_card failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver davinci_evm_driver = {\n\t.probe\t\t= davinci_evm_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"davinci_evm\",\n\t\t.pm\t= &snd_soc_pm_ops,\n\t\t.of_match_table = davinci_evm_dt_ids,\n\t},\n};\n\nmodule_platform_driver(davinci_evm_driver);\n\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_DESCRIPTION(\"TI DAVINCI EVM ASoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}