{
  "module_name": "omap-mcpdm.c",
  "hash_id": "97f293eaa27869be2bea9483dff55d7aca6fd39bcc1ca825b3b78cea6491f08d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-mcpdm.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/of_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/dmaengine_pcm.h>\n\n#include \"omap-mcpdm.h\"\n#include \"sdma-pcm.h\"\n\nstruct mcpdm_link_config {\n\tu32 link_mask;  \n\tu32 threshold;  \n};\n\nstruct omap_mcpdm {\n\tstruct device *dev;\n\tunsigned long phys_base;\n\tvoid __iomem *io_base;\n\tint irq;\n\tstruct pm_qos_request pm_qos_req;\n\tint latency[2];\n\n\tstruct mutex mutex;\n\n\t \n\tstruct mcpdm_link_config config[2];\n\n\t \n\tu32 dn_rx_offset;\n\n\t \n\tbool restart;\n\n\t \n\tint pm_active_count;\n\n\tstruct snd_dmaengine_dai_dma_data dma_data[2];\n};\n\n \n\nstatic inline void omap_mcpdm_write(struct omap_mcpdm *mcpdm, u16 reg, u32 val)\n{\n\twritel_relaxed(val, mcpdm->io_base + reg);\n}\n\nstatic inline int omap_mcpdm_read(struct omap_mcpdm *mcpdm, u16 reg)\n{\n\treturn readl_relaxed(mcpdm->io_base + reg);\n}\n\n#ifdef DEBUG\nstatic void omap_mcpdm_reg_dump(struct omap_mcpdm *mcpdm)\n{\n\tdev_dbg(mcpdm->dev, \"***********************\\n\");\n\tdev_dbg(mcpdm->dev, \"IRQSTATUS_RAW:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS_RAW));\n\tdev_dbg(mcpdm->dev, \"IRQSTATUS:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS));\n\tdev_dbg(mcpdm->dev, \"IRQENABLE_SET:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_IRQENABLE_SET));\n\tdev_dbg(mcpdm->dev, \"IRQENABLE_CLR:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_IRQENABLE_CLR));\n\tdev_dbg(mcpdm->dev, \"IRQWAKE_EN: 0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_IRQWAKE_EN));\n\tdev_dbg(mcpdm->dev, \"DMAENABLE_SET: 0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_DMAENABLE_SET));\n\tdev_dbg(mcpdm->dev, \"DMAENABLE_CLR:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_DMAENABLE_CLR));\n\tdev_dbg(mcpdm->dev, \"DMAWAKEEN:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_DMAWAKEEN));\n\tdev_dbg(mcpdm->dev, \"CTRL:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_CTRL));\n\tdev_dbg(mcpdm->dev, \"DN_DATA:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_DN_DATA));\n\tdev_dbg(mcpdm->dev, \"UP_DATA: 0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_UP_DATA));\n\tdev_dbg(mcpdm->dev, \"FIFO_CTRL_DN: 0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_FIFO_CTRL_DN));\n\tdev_dbg(mcpdm->dev, \"FIFO_CTRL_UP:  0x%04x\\n\",\n\t\t\tomap_mcpdm_read(mcpdm, MCPDM_REG_FIFO_CTRL_UP));\n\tdev_dbg(mcpdm->dev, \"***********************\\n\");\n}\n#else\nstatic void omap_mcpdm_reg_dump(struct omap_mcpdm *mcpdm) {}\n#endif\n\n \nstatic void omap_mcpdm_start(struct omap_mcpdm *mcpdm)\n{\n\tu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\n\tu32 link_mask = mcpdm->config[0].link_mask | mcpdm->config[1].link_mask;\n\n\tctrl |= (MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n\n\tctrl |= link_mask;\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n\n\tctrl &= ~(MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n}\n\n \nstatic void omap_mcpdm_stop(struct omap_mcpdm *mcpdm)\n{\n\tu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\n\tu32 link_mask = MCPDM_PDM_DN_MASK | MCPDM_PDM_UP_MASK;\n\n\tctrl |= (MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n\n\tctrl &= ~(link_mask);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n\n\tctrl &= ~(MCPDM_SW_DN_RST | MCPDM_SW_UP_RST);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl);\n\n}\n\n \nstatic inline int omap_mcpdm_active(struct omap_mcpdm *mcpdm)\n{\n\treturn omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL) &\n\t\t\t\t\t(MCPDM_PDM_DN_MASK | MCPDM_PDM_UP_MASK);\n}\n\n \nstatic void omap_mcpdm_open_streams(struct omap_mcpdm *mcpdm)\n{\n\tu32 ctrl = omap_mcpdm_read(mcpdm, MCPDM_REG_CTRL);\n\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, ctrl | MCPDM_WD_EN);\n\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_SET,\n\t\t\tMCPDM_DN_IRQ_EMPTY | MCPDM_DN_IRQ_FULL |\n\t\t\tMCPDM_UP_IRQ_EMPTY | MCPDM_UP_IRQ_FULL);\n\n\t \n\tif (mcpdm->dn_rx_offset) {\n\t\tu32 dn_offset = mcpdm->dn_rx_offset;\n\n\t\tomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, dn_offset);\n\t\tdn_offset |= (MCPDM_DN_OFST_RX1_EN | MCPDM_DN_OFST_RX2_EN);\n\t\tomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, dn_offset);\n\t}\n\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_FIFO_CTRL_DN,\n\t\t\t mcpdm->config[SNDRV_PCM_STREAM_PLAYBACK].threshold);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_FIFO_CTRL_UP,\n\t\t\t mcpdm->config[SNDRV_PCM_STREAM_CAPTURE].threshold);\n\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_SET,\n\t\t\tMCPDM_DMA_DN_ENABLE | MCPDM_DMA_UP_ENABLE);\n}\n\n \nstatic void omap_mcpdm_close_streams(struct omap_mcpdm *mcpdm)\n{\n\t \n\tomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_CLR,\n\t\t\tMCPDM_DN_IRQ_EMPTY | MCPDM_DN_IRQ_FULL);\n\n\t \n\tomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_CLR, MCPDM_DMA_DN_ENABLE);\n\n\t \n\tomap_mcpdm_write(mcpdm, MCPDM_REG_IRQENABLE_CLR,\n\t\t\tMCPDM_UP_IRQ_EMPTY | MCPDM_UP_IRQ_FULL);\n\n\t \n\tomap_mcpdm_write(mcpdm, MCPDM_REG_DMAENABLE_CLR, MCPDM_DMA_UP_ENABLE);\n\n\t \n\tif (mcpdm->dn_rx_offset)\n\t\tomap_mcpdm_write(mcpdm, MCPDM_REG_DN_OFFSET, 0);\n}\n\nstatic irqreturn_t omap_mcpdm_irq_handler(int irq, void *dev_id)\n{\n\tstruct omap_mcpdm *mcpdm = dev_id;\n\tint irq_status;\n\n\tirq_status = omap_mcpdm_read(mcpdm, MCPDM_REG_IRQSTATUS);\n\n\t \n\tomap_mcpdm_write(mcpdm, MCPDM_REG_IRQSTATUS, irq_status);\n\n\tif (irq_status & MCPDM_DN_IRQ_FULL)\n\t\tdev_dbg(mcpdm->dev, \"DN (playback) FIFO Full\\n\");\n\n\tif (irq_status & MCPDM_DN_IRQ_EMPTY)\n\t\tdev_dbg(mcpdm->dev, \"DN (playback) FIFO Empty\\n\");\n\n\tif (irq_status & MCPDM_DN_IRQ)\n\t\tdev_dbg(mcpdm->dev, \"DN (playback) write request\\n\");\n\n\tif (irq_status & MCPDM_UP_IRQ_FULL)\n\t\tdev_dbg(mcpdm->dev, \"UP (capture) FIFO Full\\n\");\n\n\tif (irq_status & MCPDM_UP_IRQ_EMPTY)\n\t\tdev_dbg(mcpdm->dev, \"UP (capture) FIFO Empty\\n\");\n\n\tif (irq_status & MCPDM_UP_IRQ)\n\t\tdev_dbg(mcpdm->dev, \"UP (capture) write request\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int omap_mcpdm_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\n\tmutex_lock(&mcpdm->mutex);\n\n\tif (!snd_soc_dai_active(dai))\n\t\tomap_mcpdm_open_streams(mcpdm);\n\n\tmutex_unlock(&mcpdm->mutex);\n\n\treturn 0;\n}\n\nstatic void omap_mcpdm_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\tint tx = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint stream1 = tx ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\n\tint stream2 = tx ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\n\tmutex_lock(&mcpdm->mutex);\n\n\tif (!snd_soc_dai_active(dai)) {\n\t\tif (omap_mcpdm_active(mcpdm)) {\n\t\t\tomap_mcpdm_stop(mcpdm);\n\t\t\tomap_mcpdm_close_streams(mcpdm);\n\t\t\tmcpdm->config[0].link_mask = 0;\n\t\t\tmcpdm->config[1].link_mask = 0;\n\t\t}\n\t}\n\n\tif (mcpdm->latency[stream2])\n\t\tcpu_latency_qos_update_request(&mcpdm->pm_qos_req,\n\t\t\t\t\t       mcpdm->latency[stream2]);\n\telse if (mcpdm->latency[stream1])\n\t\tcpu_latency_qos_remove_request(&mcpdm->pm_qos_req);\n\n\tmcpdm->latency[stream1] = 0;\n\n\tmutex_unlock(&mcpdm->mutex);\n}\n\nstatic int omap_mcpdm_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\tint stream = substream->stream;\n\tstruct snd_dmaengine_dai_dma_data *dma_data;\n\tu32 threshold;\n\tint channels, latency;\n\tint link_mask = 0;\n\n\tchannels = params_channels(params);\n\tswitch (channels) {\n\tcase 5:\n\t\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tlink_mask |= 1 << 4;\n\t\tfallthrough;\n\tcase 4:\n\t\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\tlink_mask |= 1 << 3;\n\t\tfallthrough;\n\tcase 3:\n\t\tlink_mask |= 1 << 2;\n\t\tfallthrough;\n\tcase 2:\n\t\tlink_mask |= 1 << 1;\n\t\tfallthrough;\n\tcase 1:\n\t\tlink_mask |= 1 << 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tdma_data = snd_soc_dai_get_dma_data(dai, substream);\n\n\tthreshold = mcpdm->config[stream].threshold;\n\t \n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tlink_mask <<= 3;\n\n\t\t \n\t\tif (!mcpdm->config[!stream].link_mask)\n\t\t\tmcpdm->config[!stream].link_mask = 0x3;\n\n\t\tdma_data->maxburst =\n\t\t\t\t(MCPDM_DN_THRES_MAX - threshold) * channels;\n\t\tlatency = threshold;\n\t} else {\n\t\t \n\t\tif (!mcpdm->config[!stream].link_mask)\n\t\t\tmcpdm->config[!stream].link_mask = (0x3 << 3);\n\n\t\tdma_data->maxburst = threshold * channels;\n\t\tlatency = (MCPDM_DN_THRES_MAX - threshold);\n\t}\n\n\t \n\tmcpdm->latency[stream] = latency * USEC_PER_SEC / params_rate(params);\n\n\tif (!mcpdm->latency[stream])\n\t\tmcpdm->latency[stream] = 10;\n\n\t \n\tif (mcpdm->config[stream].link_mask &&\n\t    mcpdm->config[stream].link_mask != link_mask)\n\t\tmcpdm->restart = true;\n\n\tmcpdm->config[stream].link_mask = link_mask;\n\n\treturn 0;\n}\n\nstatic int omap_mcpdm_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\tstruct pm_qos_request *pm_qos_req = &mcpdm->pm_qos_req;\n\tint tx = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\tint stream1 = tx ? SNDRV_PCM_STREAM_PLAYBACK : SNDRV_PCM_STREAM_CAPTURE;\n\tint stream2 = tx ? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;\n\tint latency = mcpdm->latency[stream2];\n\n\t \n\tif (!latency || mcpdm->latency[stream1] < latency)\n\t\tlatency = mcpdm->latency[stream1];\n\n\tif (cpu_latency_qos_request_active(pm_qos_req))\n\t\tcpu_latency_qos_update_request(pm_qos_req, latency);\n\telse if (latency)\n\t\tcpu_latency_qos_add_request(pm_qos_req, latency);\n\n\tif (!omap_mcpdm_active(mcpdm)) {\n\t\tomap_mcpdm_start(mcpdm);\n\t\tomap_mcpdm_reg_dump(mcpdm);\n\t} else if (mcpdm->restart) {\n\t\tomap_mcpdm_stop(mcpdm);\n\t\tomap_mcpdm_start(mcpdm);\n\t\tmcpdm->restart = false;\n\t\tomap_mcpdm_reg_dump(mcpdm);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_mcpdm_probe(struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\tint ret;\n\n\tpm_runtime_enable(mcpdm->dev);\n\n\t \n\tpm_runtime_get_sync(mcpdm->dev);\n\tomap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, 0x00);\n\n\tret = request_irq(mcpdm->irq, omap_mcpdm_irq_handler, 0, \"McPDM\",\n\t\t\t  (void *)mcpdm);\n\n\tpm_runtime_put_sync(mcpdm->dev);\n\n\tif (ret) {\n\t\tdev_err(mcpdm->dev, \"Request for IRQ failed\\n\");\n\t\tpm_runtime_disable(mcpdm->dev);\n\t}\n\n\t \n\tmcpdm->config[SNDRV_PCM_STREAM_PLAYBACK].threshold = 2;\n\tmcpdm->config[SNDRV_PCM_STREAM_CAPTURE].threshold =\n\t\t\t\t\t\t\tMCPDM_UP_THRES_MAX - 3;\n\n\tsnd_soc_dai_init_dma_data(dai,\n\t\t\t\t  &mcpdm->dma_data[SNDRV_PCM_STREAM_PLAYBACK],\n\t\t\t\t  &mcpdm->dma_data[SNDRV_PCM_STREAM_CAPTURE]);\n\n\treturn ret;\n}\n\nstatic int omap_mcpdm_remove(struct snd_soc_dai *dai)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);\n\n\tfree_irq(mcpdm->irq, (void *)mcpdm);\n\tpm_runtime_disable(mcpdm->dev);\n\n\tif (cpu_latency_qos_request_active(&mcpdm->pm_qos_req))\n\t\tcpu_latency_qos_remove_request(&mcpdm->pm_qos_req);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops omap_mcpdm_dai_ops = {\n\t.probe\t\t= omap_mcpdm_probe,\n\t.remove\t\t= omap_mcpdm_remove,\n\t.startup\t= omap_mcpdm_dai_startup,\n\t.shutdown\t= omap_mcpdm_dai_shutdown,\n\t.hw_params\t= omap_mcpdm_dai_hw_params,\n\t.prepare\t= omap_mcpdm_prepare,\n\t.probe_order\t= SND_SOC_COMP_ORDER_LATE,\n\t.remove_order\t= SND_SOC_COMP_ORDER_EARLY,\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_mcpdm_suspend(struct snd_soc_component *component)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_component_get_drvdata(component);\n\n\tif (snd_soc_component_active(component)) {\n\t\tomap_mcpdm_stop(mcpdm);\n\t\tomap_mcpdm_close_streams(mcpdm);\n\t}\n\n\tmcpdm->pm_active_count = 0;\n\twhile (pm_runtime_active(mcpdm->dev)) {\n\t\tpm_runtime_put_sync(mcpdm->dev);\n\t\tmcpdm->pm_active_count++;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_mcpdm_resume(struct snd_soc_component *component)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_component_get_drvdata(component);\n\n\tif (mcpdm->pm_active_count) {\n\t\twhile (mcpdm->pm_active_count--)\n\t\t\tpm_runtime_get_sync(mcpdm->dev);\n\n\t\tif (snd_soc_component_active(component)) {\n\t\t\tomap_mcpdm_open_streams(mcpdm);\n\t\t\tomap_mcpdm_start(mcpdm);\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n#else\n#define omap_mcpdm_suspend NULL\n#define omap_mcpdm_resume NULL\n#endif\n\n#define OMAP_MCPDM_RATES\t(SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)\n#define OMAP_MCPDM_FORMATS\tSNDRV_PCM_FMTBIT_S32_LE\n\nstatic struct snd_soc_dai_driver omap_mcpdm_dai = {\n\t.playback = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 5,\n\t\t.rates = OMAP_MCPDM_RATES,\n\t\t.formats = OMAP_MCPDM_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.capture = {\n\t\t.channels_min = 1,\n\t\t.channels_max = 3,\n\t\t.rates = OMAP_MCPDM_RATES,\n\t\t.formats = OMAP_MCPDM_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &omap_mcpdm_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver omap_mcpdm_component = {\n\t.name\t\t\t= \"omap-mcpdm\",\n\t.suspend\t\t= omap_mcpdm_suspend,\n\t.resume\t\t\t= omap_mcpdm_resume,\n\t.legacy_dai_naming\t= 1,\n};\n\nvoid omap_mcpdm_configure_dn_offsets(struct snd_soc_pcm_runtime *rtd,\n\t\t\t\t    u8 rx1, u8 rx2)\n{\n\tstruct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));\n\n\tmcpdm->dn_rx_offset = MCPDM_DNOFST_RX1(rx1) | MCPDM_DNOFST_RX2(rx2);\n}\nEXPORT_SYMBOL_GPL(omap_mcpdm_configure_dn_offsets);\n\nstatic int asoc_mcpdm_probe(struct platform_device *pdev)\n{\n\tstruct omap_mcpdm *mcpdm;\n\tstruct resource *res;\n\tint ret;\n\n\tmcpdm = devm_kzalloc(&pdev->dev, sizeof(struct omap_mcpdm), GFP_KERNEL);\n\tif (!mcpdm)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mcpdm);\n\n\tmutex_init(&mcpdm->mutex);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"dma\");\n\tif (res == NULL)\n\t\treturn -ENOMEM;\n\n\tmcpdm->dma_data[0].addr = res->start + MCPDM_REG_DN_DATA;\n\tmcpdm->dma_data[1].addr = res->start + MCPDM_REG_UP_DATA;\n\n\tmcpdm->dma_data[0].filter_data = \"dn_link\";\n\tmcpdm->dma_data[1].filter_data = \"up_link\";\n\n\tmcpdm->io_base = devm_platform_ioremap_resource_byname(pdev, \"mpu\");\n\tif (IS_ERR(mcpdm->io_base))\n\t\treturn PTR_ERR(mcpdm->io_base);\n\n\tmcpdm->irq = platform_get_irq(pdev, 0);\n\tif (mcpdm->irq < 0)\n\t\treturn mcpdm->irq;\n\n\tmcpdm->dev = &pdev->dev;\n\n\tret =  devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t       &omap_mcpdm_component,\n\t\t\t\t\t       &omap_mcpdm_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdma_pcm_platform_register(&pdev->dev, \"dn_link\", \"up_link\");\n}\n\nstatic const struct of_device_id omap_mcpdm_of_match[] = {\n\t{ .compatible = \"ti,omap4-mcpdm\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, omap_mcpdm_of_match);\n\nstatic struct platform_driver asoc_mcpdm_driver = {\n\t.driver = {\n\t\t.name\t= \"omap-mcpdm\",\n\t\t.of_match_table = omap_mcpdm_of_match,\n\t},\n\n\t.probe\t= asoc_mcpdm_probe,\n};\n\nmodule_platform_driver(asoc_mcpdm_driver);\n\nMODULE_ALIAS(\"platform:omap-mcpdm\");\nMODULE_AUTHOR(\"Misael Lopez Cruz <misael.lopez@ti.com>\");\nMODULE_DESCRIPTION(\"OMAP PDM SoC Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}