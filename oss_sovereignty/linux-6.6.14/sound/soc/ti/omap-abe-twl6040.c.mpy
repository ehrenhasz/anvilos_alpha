{
  "module_name": "omap-abe-twl6040.c",
  "hash_id": "fc4bb5003bb876fe8af2c6fe5ff96966dbd8ba6b1dae72a2f4be54415c228085",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/ti/omap-abe-twl6040.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/twl6040.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n\n#include \"omap-dmic.h\"\n#include \"omap-mcpdm.h\"\n#include \"../codecs/twl6040.h\"\n\nSND_SOC_DAILINK_DEFS(link0,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"twl6040-codec\",\n\t\t\t\t      \"twl6040-legacy\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nSND_SOC_DAILINK_DEFS(link1,\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()),\n\tDAILINK_COMP_ARRAY(COMP_CODEC(\"dmic-codec\",\n\t\t\t\t      \"dmic-hifi\")),\n\tDAILINK_COMP_ARRAY(COMP_EMPTY()));\n\nstruct abe_twl6040 {\n\tstruct snd_soc_card card;\n\tstruct snd_soc_dai_link dai_links[2];\n\tint\tjack_detection;\t \n\tint\tmclk_freq;\t \n};\n\nstatic struct platform_device *dmic_codec_dev;\n\nstatic int omap_abe_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct abe_twl6040 *priv = snd_soc_card_get_drvdata(card);\n\tint clk_id, freq;\n\tint ret;\n\n\tclk_id = twl6040_get_clk_id(codec_dai->component);\n\tif (clk_id == TWL6040_SYSCLK_SEL_HPPLL)\n\t\tfreq = priv->mclk_freq;\n\telse if (clk_id == TWL6040_SYSCLK_SEL_LPPLL)\n\t\tfreq = 32768;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tret = snd_soc_dai_set_sysclk(codec_dai, clk_id, freq,\n\t\t\t\tSND_SOC_CLOCK_IN);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"can't set codec system clock\\n\");\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_soc_ops omap_abe_ops = {\n\t.hw_params = omap_abe_hw_params,\n};\n\nstatic int omap_abe_dmic_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_dai *cpu_dai = asoc_rtd_to_cpu(rtd, 0);\n\tint ret = 0;\n\n\tret = snd_soc_dai_set_sysclk(cpu_dai, OMAP_DMIC_SYSCLK_PAD_CLKS,\n\t\t\t\t     19200000, SND_SOC_CLOCK_IN);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"can't set DMIC cpu system clock\\n\");\n\t\treturn ret;\n\t}\n\tret = snd_soc_dai_set_sysclk(cpu_dai, OMAP_DMIC_ABE_DMIC_CLK, 2400000,\n\t\t\t\t     SND_SOC_CLOCK_OUT);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR \"can't set DMIC output clock\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_ops omap_abe_dmic_ops = {\n\t.hw_params = omap_abe_dmic_hw_params,\n};\n\n \nstatic struct snd_soc_jack hs_jack;\n\n \nstatic struct snd_soc_jack_pin hs_jack_pins[] = {\n\t{\n\t\t.pin = \"Headset Mic\",\n\t\t.mask = SND_JACK_MICROPHONE,\n\t},\n\t{\n\t\t.pin = \"Headset Stereophone\",\n\t\t.mask = SND_JACK_HEADPHONE,\n\t},\n};\n\n \nstatic const struct snd_soc_dapm_widget twl6040_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_HP(\"Headset Stereophone\", NULL),\n\tSND_SOC_DAPM_SPK(\"Earphone Spk\", NULL),\n\tSND_SOC_DAPM_SPK(\"Ext Spk\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line Out\", NULL),\n\tSND_SOC_DAPM_SPK(\"Vibrator\", NULL),\n\n\t \n\tSND_SOC_DAPM_MIC(\"Headset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Main Handset Mic\", NULL),\n\tSND_SOC_DAPM_MIC(\"Sub Handset Mic\", NULL),\n\tSND_SOC_DAPM_LINE(\"Line In\", NULL),\n\n\t \n\tSND_SOC_DAPM_MIC(\"Digital Mic\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t \n\t{\"Headset Stereophone\", NULL, \"HSOL\"},\n\t{\"Headset Stereophone\", NULL, \"HSOR\"},\n\n\t{\"Earphone Spk\", NULL, \"EP\"},\n\n\t{\"Ext Spk\", NULL, \"HFL\"},\n\t{\"Ext Spk\", NULL, \"HFR\"},\n\n\t{\"Line Out\", NULL, \"AUXL\"},\n\t{\"Line Out\", NULL, \"AUXR\"},\n\n\t{\"Vibrator\", NULL, \"VIBRAL\"},\n\t{\"Vibrator\", NULL, \"VIBRAR\"},\n\n\t \n\t{\"HSMIC\", NULL, \"Headset Mic\"},\n\t{\"Headset Mic\", NULL, \"Headset Mic Bias\"},\n\n\t{\"MAINMIC\", NULL, \"Main Handset Mic\"},\n\t{\"Main Handset Mic\", NULL, \"Main Mic Bias\"},\n\n\t{\"SUBMIC\", NULL, \"Sub Handset Mic\"},\n\t{\"Sub Handset Mic\", NULL, \"Main Mic Bias\"},\n\n\t{\"AFML\", NULL, \"Line In\"},\n\t{\"AFMR\", NULL, \"Line In\"},\n};\n\nstatic int omap_abe_twl6040_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_component *component = asoc_rtd_to_codec(rtd, 0)->component;\n\tstruct snd_soc_card *card = rtd->card;\n\tstruct abe_twl6040 *priv = snd_soc_card_get_drvdata(card);\n\tint hs_trim;\n\tint ret;\n\n\t \n\ths_trim = twl6040_get_trim_value(component, TWL6040_TRIM_HSOTRIM);\n\tomap_mcpdm_configure_dn_offsets(rtd, TWL6040_HSF_TRIM_LEFT(hs_trim),\n\t\t\t\t\tTWL6040_HSF_TRIM_RIGHT(hs_trim));\n\n\t \n\tif (priv->jack_detection) {\n\t\tret = snd_soc_card_jack_new_pins(rtd->card, \"Headset Jack\",\n\t\t\t\t\t\t SND_JACK_HEADSET, &hs_jack,\n\t\t\t\t\t\t hs_jack_pins,\n\t\t\t\t\t\t ARRAY_SIZE(hs_jack_pins));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttwl6040_hs_jack_detect(component, &hs_jack, SND_JACK_HEADSET);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_route dmic_audio_map[] = {\n\t{\"DMic\", NULL, \"Digital Mic\"},\n\t{\"Digital Mic\", NULL, \"Digital Mic1 Bias\"},\n};\n\nstatic int omap_abe_dmic_init(struct snd_soc_pcm_runtime *rtd)\n{\n\tstruct snd_soc_dapm_context *dapm = &rtd->card->dapm;\n\n\treturn snd_soc_dapm_add_routes(dapm, dmic_audio_map,\n\t\t\t\tARRAY_SIZE(dmic_audio_map));\n}\n\nstatic int omap_abe_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct snd_soc_card *card;\n\tstruct device_node *dai_node;\n\tstruct abe_twl6040 *priv;\n\tint num_links = 0;\n\tint ret = 0;\n\n\tif (!node) {\n\t\tdev_err(&pdev->dev, \"of node is missing.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct abe_twl6040), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tcard = &priv->card;\n\tcard->dev = &pdev->dev;\n\tcard->owner = THIS_MODULE;\n\tcard->dapm_widgets = twl6040_dapm_widgets;\n\tcard->num_dapm_widgets = ARRAY_SIZE(twl6040_dapm_widgets);\n\tcard->dapm_routes = audio_map;\n\tcard->num_dapm_routes = ARRAY_SIZE(audio_map);\n\n\tif (snd_soc_of_parse_card_name(card, \"ti,model\")) {\n\t\tdev_err(&pdev->dev, \"Card name is not provided\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = snd_soc_of_parse_audio_routing(card, \"ti,audio-routing\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error while parsing DAPM routing\\n\");\n\t\treturn ret;\n\t}\n\n\tdai_node = of_parse_phandle(node, \"ti,mcpdm\", 0);\n\tif (!dai_node) {\n\t\tdev_err(&pdev->dev, \"McPDM node is not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->dai_links[0].name = \"DMIC\";\n\tpriv->dai_links[0].stream_name = \"TWL6040\";\n\tpriv->dai_links[0].cpus = link0_cpus;\n\tpriv->dai_links[0].num_cpus = 1;\n\tpriv->dai_links[0].cpus->of_node = dai_node;\n\tpriv->dai_links[0].platforms = link0_platforms;\n\tpriv->dai_links[0].num_platforms = 1;\n\tpriv->dai_links[0].platforms->of_node = dai_node;\n\tpriv->dai_links[0].codecs = link0_codecs;\n\tpriv->dai_links[0].num_codecs = 1;\n\tpriv->dai_links[0].init = omap_abe_twl6040_init;\n\tpriv->dai_links[0].ops = &omap_abe_ops;\n\n\tdai_node = of_parse_phandle(node, \"ti,dmic\", 0);\n\tif (dai_node) {\n\t\tnum_links = 2;\n\t\tpriv->dai_links[1].name = \"TWL6040\";\n\t\tpriv->dai_links[1].stream_name = \"DMIC Capture\";\n\t\tpriv->dai_links[1].cpus = link1_cpus;\n\t\tpriv->dai_links[1].num_cpus = 1;\n\t\tpriv->dai_links[1].cpus->of_node = dai_node;\n\t\tpriv->dai_links[1].platforms = link1_platforms;\n\t\tpriv->dai_links[1].num_platforms = 1;\n\t\tpriv->dai_links[1].platforms->of_node = dai_node;\n\t\tpriv->dai_links[1].codecs = link1_codecs;\n\t\tpriv->dai_links[1].num_codecs = 1;\n\t\tpriv->dai_links[1].init = omap_abe_dmic_init;\n\t\tpriv->dai_links[1].ops = &omap_abe_dmic_ops;\n\t} else {\n\t\tnum_links = 1;\n\t}\n\n\tpriv->jack_detection = of_property_read_bool(node, \"ti,jack-detection\");\n\tof_property_read_u32(node, \"ti,mclk-freq\", &priv->mclk_freq);\n\tif (!priv->mclk_freq) {\n\t\tdev_err(&pdev->dev, \"MCLK frequency not provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcard->fully_routed = 1;\n\n\tcard->dai_link = priv->dai_links;\n\tcard->num_links = num_links;\n\n\tsnd_soc_card_set_drvdata(card, priv);\n\n\tret = devm_snd_soc_register_card(&pdev->dev, card);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"devm_snd_soc_register_card() failed: %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id omap_abe_of_match[] = {\n\t{.compatible = \"ti,abe-twl6040\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, omap_abe_of_match);\n\nstatic struct platform_driver omap_abe_driver = {\n\t.driver = {\n\t\t.name = \"omap-abe-twl6040\",\n\t\t.pm = &snd_soc_pm_ops,\n\t\t.of_match_table = omap_abe_of_match,\n\t},\n\t.probe = omap_abe_probe,\n};\n\nstatic int __init omap_abe_init(void)\n{\n\tint ret;\n\n\tdmic_codec_dev = platform_device_register_simple(\"dmic-codec\", -1, NULL,\n\t\t\t\t\t\t\t 0);\n\tif (IS_ERR(dmic_codec_dev)) {\n\t\tpr_err(\"%s: dmic-codec device registration failed\\n\", __func__);\n\t\treturn PTR_ERR(dmic_codec_dev);\n\t}\n\n\tret = platform_driver_register(&omap_abe_driver);\n\tif (ret) {\n\t\tpr_err(\"%s: platform driver registration failed\\n\", __func__);\n\t\tplatform_device_unregister(dmic_codec_dev);\n\t}\n\n\treturn ret;\n}\nmodule_init(omap_abe_init);\n\nstatic void __exit omap_abe_exit(void)\n{\n\tplatform_driver_unregister(&omap_abe_driver);\n\tplatform_device_unregister(dmic_codec_dev);\n}\nmodule_exit(omap_abe_exit);\n\nMODULE_AUTHOR(\"Misael Lopez Cruz <misael.lopez@ti.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC for OMAP boards with ABE and twl6040 codec\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap-abe-twl6040\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}