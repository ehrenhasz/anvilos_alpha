{
  "module_name": "es8328.c",
  "hash_id": "40e54fe6223eb784edb6112b891c86ec754501af617245458560b23070443b90",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/es8328.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/of_device.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"es8328.h\"\n\nstatic const unsigned int rates_12288[] = {\n\t8000, 12000, 16000, 24000, 32000, 48000, 96000,\n};\n\nstatic const int ratios_12288[] = {\n\t10, 7, 6, 4, 3, 2, 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_12288 = {\n\t.count\t= ARRAY_SIZE(rates_12288),\n\t.list\t= rates_12288,\n};\n\nstatic const unsigned int rates_11289[] = {\n\t8018, 11025, 22050, 44100, 88200,\n};\n\nstatic const int ratios_11289[] = {\n\t9, 7, 4, 2, 0,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_11289 = {\n\t.count\t= ARRAY_SIZE(rates_11289),\n\t.list\t= rates_11289,\n};\n\n \nenum sgtl5000_regulator_supplies {\n\tDVDD,\n\tAVDD,\n\tPVDD,\n\tHPVDD,\n\tES8328_SUPPLY_NUM\n};\n\n \nstatic const char * const supply_names[ES8328_SUPPLY_NUM] = {\n\t\"DVDD\",\n\t\"AVDD\",\n\t\"PVDD\",\n\t\"HPVDD\",\n};\n\n#define ES8328_RATES (SNDRV_PCM_RATE_192000 | \\\n\t\tSNDRV_PCM_RATE_96000 | \\\n\t\tSNDRV_PCM_RATE_88200 | \\\n\t\tSNDRV_PCM_RATE_8000_48000)\n#define ES8328_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\tSNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\tSNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\tSNDRV_PCM_FMTBIT_S24_LE | \\\n\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstruct es8328_priv {\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\tint playback_fs;\n\tbool deemph;\n\tint mclkdiv2;\n\tconst struct snd_pcm_hw_constraint_list *sysclk_constraints;\n\tconst int *mclk_ratios;\n\tbool provider;\n\tstruct regulator_bulk_data supplies[ES8328_SUPPLY_NUM];\n};\n\n \n\nstatic const char * const adcpol_txt[] = {\"Normal\", \"L Invert\", \"R Invert\",\n\t\t\t\t\t  \"L + R Invert\"};\nstatic SOC_ENUM_SINGLE_DECL(adcpol,\n\t\t\t    ES8328_ADCCONTROL6, 6, adcpol_txt);\n\nstatic const DECLARE_TLV_DB_SCALE(play_tlv, -3000, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_adc_tlv, -9600, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 300, 0);\n\nstatic const struct {\n\tint rate;\n\tunsigned int val;\n} deemph_settings[] = {\n\t{ 0,     ES8328_DACCONTROL6_DEEMPH_OFF },\n\t{ 32000, ES8328_DACCONTROL6_DEEMPH_32k },\n\t{ 44100, ES8328_DACCONTROL6_DEEMPH_44_1k },\n\t{ 48000, ES8328_DACCONTROL6_DEEMPH_48k },\n};\n\nstatic int es8328_set_deemph(struct snd_soc_component *component)\n{\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (es8328->deemph) {\n\t\tbest = 0;\n\t\tfor (i = 1; i < ARRAY_SIZE(deemph_settings); i++) {\n\t\t\tif (abs(deemph_settings[i].rate - es8328->playback_fs) <\n\t\t\t    abs(deemph_settings[best].rate - es8328->playback_fs))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = deemph_settings[best].val;\n\t} else {\n\t\tval = ES8328_DACCONTROL6_DEEMPH_OFF;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d\\n\", val);\n\n\treturn snd_soc_component_update_bits(component, ES8328_DACCONTROL6,\n\t\t\tES8328_DACCONTROL6_DEEMPH_MASK, val);\n}\n\nstatic int es8328_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = es8328->deemph;\n\treturn 0;\n}\n\nstatic int es8328_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\tint ret;\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tif (es8328->deemph == deemph)\n\t\treturn 0;\n\n\tret = es8328_set_deemph(component);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tes8328->deemph = deemph;\n\n\treturn 1;\n}\n\n\n\nstatic const struct snd_kcontrol_new es8328_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Capture Digital Volume\",\n\t\tES8328_ADCCONTROL8, ES8328_ADCCONTROL9,\n\t\t 0, 0xc0, 1, dac_adc_tlv),\n\tSOC_SINGLE(\"Capture ZC Switch\", ES8328_ADCCONTROL7, 6, 1, 0),\n\n\tSOC_SINGLE_BOOL_EXT(\"DAC Deemphasis Switch\", 0,\n\t\t    es8328_get_deemph, es8328_put_deemph),\n\n\tSOC_ENUM(\"Capture Polarity\", adcpol),\n\n\tSOC_SINGLE_TLV(\"Left Mixer Left Bypass Volume\",\n\t\t\tES8328_DACCONTROL17, 3, 7, 1, bypass_tlv),\n\tSOC_SINGLE_TLV(\"Left Mixer Right Bypass Volume\",\n\t\t\tES8328_DACCONTROL19, 3, 7, 1, bypass_tlv),\n\tSOC_SINGLE_TLV(\"Right Mixer Left Bypass Volume\",\n\t\t\tES8328_DACCONTROL18, 3, 7, 1, bypass_tlv),\n\tSOC_SINGLE_TLV(\"Right Mixer Right Bypass Volume\",\n\t\t\tES8328_DACCONTROL20, 3, 7, 1, bypass_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"PCM Volume\",\n\t\t\tES8328_LDACVOL, ES8328_RDACVOL,\n\t\t\t0, ES8328_DACVOL_MAX, 1, dac_adc_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Output 1 Playback Volume\",\n\t\t\tES8328_LOUT1VOL, ES8328_ROUT1VOL,\n\t\t\t0, ES8328_OUT1VOL_MAX, 0, play_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Output 2 Playback Volume\",\n\t\t\tES8328_LOUT2VOL, ES8328_ROUT2VOL,\n\t\t\t0, ES8328_OUT2VOL_MAX, 0, play_tlv),\n\n\tSOC_DOUBLE_TLV(\"Mic PGA Volume\", ES8328_ADCCONTROL1,\n\t\t\t4, 0, 8, 0, mic_tlv),\n};\n\n \n\nstatic const char * const es8328_line_texts[] = {\n\t\"Line 1\", \"Line 2\", \"PGA\", \"Differential\"};\n\nstatic const struct soc_enum es8328_lline_enum =\n\tSOC_ENUM_SINGLE(ES8328_DACCONTROL16, 3,\n\t\t\t      ARRAY_SIZE(es8328_line_texts),\n\t\t\t      es8328_line_texts);\nstatic const struct snd_kcontrol_new es8328_left_line_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8328_lline_enum);\n\nstatic const struct soc_enum es8328_rline_enum =\n\tSOC_ENUM_SINGLE(ES8328_DACCONTROL16, 0,\n\t\t\t      ARRAY_SIZE(es8328_line_texts),\n\t\t\t      es8328_line_texts);\nstatic const struct snd_kcontrol_new es8328_right_line_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8328_rline_enum);\n\n \nstatic const struct snd_kcontrol_new es8328_left_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Playback Switch\", ES8328_DACCONTROL17, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Bypass Switch\", ES8328_DACCONTROL17, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Playback Switch\", ES8328_DACCONTROL18, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Bypass Switch\", ES8328_DACCONTROL18, 6, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new es8328_right_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left Playback Switch\", ES8328_DACCONTROL19, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Bypass Switch\", ES8328_DACCONTROL19, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"Playback Switch\", ES8328_DACCONTROL20, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Bypass Switch\", ES8328_DACCONTROL20, 6, 1, 0),\n};\n\nstatic const char * const es8328_pga_sel[] = {\n\t\"Line 1\", \"Line 2\", \"Line 3\", \"Differential\"};\n\n \nstatic const struct soc_enum es8328_lpga_enum =\n\tSOC_ENUM_SINGLE(ES8328_ADCCONTROL2, 6,\n\t\t\t      ARRAY_SIZE(es8328_pga_sel),\n\t\t\t      es8328_pga_sel);\nstatic const struct snd_kcontrol_new es8328_left_pga_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8328_lpga_enum);\n\n \nstatic const struct soc_enum es8328_rpga_enum =\n\tSOC_ENUM_SINGLE(ES8328_ADCCONTROL2, 4,\n\t\t\t      ARRAY_SIZE(es8328_pga_sel),\n\t\t\t      es8328_pga_sel);\nstatic const struct snd_kcontrol_new es8328_right_pga_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8328_rpga_enum);\n\n \nstatic const char * const es8328_diff_sel[] = {\"Line 1\", \"Line 2\"};\nstatic SOC_ENUM_SINGLE_DECL(diffmux,\n\t\t\t    ES8328_ADCCONTROL3, 7, es8328_diff_sel);\nstatic const struct snd_kcontrol_new es8328_diffmux_controls =\n\tSOC_DAPM_ENUM(\"Route\", diffmux);\n\n \nstatic const char * const es8328_mono_mux[] = {\"Stereo\", \"Mono (Left)\",\n\t\"Mono (Right)\", \"Digital Mono\"};\nstatic SOC_ENUM_SINGLE_DECL(monomux,\n\t\t\t    ES8328_ADCCONTROL3, 3, es8328_mono_mux);\nstatic const struct snd_kcontrol_new es8328_monomux_controls =\n\tSOC_DAPM_ENUM(\"Route\", monomux);\n\nstatic const struct snd_soc_dapm_widget es8328_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"Differential Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_diffmux_controls),\n\tSND_SOC_DAPM_MUX(\"Left ADC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_monomux_controls),\n\tSND_SOC_DAPM_MUX(\"Right ADC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_monomux_controls),\n\n\tSND_SOC_DAPM_MUX(\"Left PGA Mux\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_AINL_OFF, 1,\n\t\t\t&es8328_left_pga_controls),\n\tSND_SOC_DAPM_MUX(\"Right PGA Mux\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_AINR_OFF, 1,\n\t\t\t&es8328_right_pga_controls),\n\n\tSND_SOC_DAPM_MUX(\"Left Line Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_left_line_controls),\n\tSND_SOC_DAPM_MUX(\"Right Line Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_right_line_controls),\n\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_ADCR_OFF, 1),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_ADCL_OFF, 1),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_MIC_BIAS_OFF, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias Gen\", ES8328_ADCPOWER,\n\t\t\tES8328_ADCPOWER_ADC_BIAS_GEN_OFF, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC STM\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_DACSTM_RESET, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC STM\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_ADCSTM_RESET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC DIG\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_DACDIG_OFF, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC DIG\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_ADCDIG_OFF, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC DLL\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_DACDLL_OFF, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC DLL\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_ADCDLL_OFF, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"ADC Vref\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_ADCVREF_OFF, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAC Vref\", ES8328_CHIPPOWER,\n\t\t\tES8328_CHIPPOWER_DACVREF_OFF, 1, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_RDAC_OFF, 1),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_LDAC_OFF, 1),\n\n\tSND_SOC_DAPM_MIXER(\"Left Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_left_mixer_controls[0],\n\t\tARRAY_SIZE(es8328_left_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&es8328_right_mixer_controls[0],\n\t\tARRAY_SIZE(es8328_right_mixer_controls)),\n\n\tSND_SOC_DAPM_PGA(\"Right Out 2\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_ROUT2_ON, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left Out 2\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_LOUT2_ON, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Out 1\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_ROUT1_ON, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left Out 1\", ES8328_DACPOWER,\n\t\t\tES8328_DACPOWER_LOUT1_ON, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\n\n\tSND_SOC_DAPM_INPUT(\"LINPUT1\"),\n\tSND_SOC_DAPM_INPUT(\"LINPUT2\"),\n\tSND_SOC_DAPM_INPUT(\"RINPUT1\"),\n\tSND_SOC_DAPM_INPUT(\"RINPUT2\"),\n};\n\nstatic const struct snd_soc_dapm_route es8328_dapm_routes[] = {\n\n\t{ \"Left Line Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left Line Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left Line Mux\", \"PGA\", \"Left PGA Mux\" },\n\t{ \"Left Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right Line Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right Line Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right Line Mux\", \"PGA\", \"Right PGA Mux\" },\n\t{ \"Right Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Left PGA Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left PGA Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left PGA Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right PGA Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right PGA Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right PGA Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Differential Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Differential Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Differential Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Differential Mux\", \"Line 2\", \"RINPUT2\" },\n\n\t{ \"Left ADC Mux\", \"Stereo\", \"Left PGA Mux\" },\n\t{ \"Left ADC Mux\", \"Mono (Left)\", \"Left PGA Mux\" },\n\t{ \"Left ADC Mux\", \"Digital Mono\", \"Left PGA Mux\" },\n\n\t{ \"Right ADC Mux\", \"Stereo\", \"Right PGA Mux\" },\n\t{ \"Right ADC Mux\", \"Mono (Right)\", \"Right PGA Mux\" },\n\t{ \"Right ADC Mux\", \"Digital Mono\", \"Right PGA Mux\" },\n\n\t{ \"Left ADC\", NULL, \"Left ADC Mux\" },\n\t{ \"Right ADC\", NULL, \"Right ADC Mux\" },\n\n\t{ \"ADC DIG\", NULL, \"ADC STM\" },\n\t{ \"ADC DIG\", NULL, \"ADC Vref\" },\n\t{ \"ADC DIG\", NULL, \"ADC DLL\" },\n\n\t{ \"Left ADC\", NULL, \"ADC DIG\" },\n\t{ \"Right ADC\", NULL, \"ADC DIG\" },\n\n\t{ \"Mic Bias\", NULL, \"Mic Bias Gen\" },\n\n\t{ \"Left Line Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left Line Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left Line Mux\", \"PGA\", \"Left PGA Mux\" },\n\t{ \"Left Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right Line Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right Line Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right Line Mux\", \"PGA\", \"Right PGA Mux\" },\n\t{ \"Right Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Left Out 1\", NULL, \"Left DAC\" },\n\t{ \"Right Out 1\", NULL, \"Right DAC\" },\n\t{ \"Left Out 2\", NULL, \"Left DAC\" },\n\t{ \"Right Out 2\", NULL, \"Right DAC\" },\n\n\t{ \"Left Mixer\", \"Playback Switch\", \"Left DAC\" },\n\t{ \"Left Mixer\", \"Left Bypass Switch\", \"Left Line Mux\" },\n\t{ \"Left Mixer\", \"Right Playback Switch\", \"Right DAC\" },\n\t{ \"Left Mixer\", \"Right Bypass Switch\", \"Right Line Mux\" },\n\n\t{ \"Right Mixer\", \"Left Playback Switch\", \"Left DAC\" },\n\t{ \"Right Mixer\", \"Left Bypass Switch\", \"Left Line Mux\" },\n\t{ \"Right Mixer\", \"Playback Switch\", \"Right DAC\" },\n\t{ \"Right Mixer\", \"Right Bypass Switch\", \"Right Line Mux\" },\n\n\t{ \"DAC DIG\", NULL, \"DAC STM\" },\n\t{ \"DAC DIG\", NULL, \"DAC Vref\" },\n\t{ \"DAC DIG\", NULL, \"DAC DLL\" },\n\n\t{ \"Left DAC\", NULL, \"DAC DIG\" },\n\t{ \"Right DAC\", NULL, \"DAC DIG\" },\n\n\t{ \"Left Out 1\", NULL, \"Left Mixer\" },\n\t{ \"LOUT1\", NULL, \"Left Out 1\" },\n\t{ \"Right Out 1\", NULL, \"Right Mixer\" },\n\t{ \"ROUT1\", NULL, \"Right Out 1\" },\n\n\t{ \"Left Out 2\", NULL, \"Left Mixer\" },\n\t{ \"LOUT2\", NULL, \"Left Out 2\" },\n\t{ \"Right Out 2\", NULL, \"Right Mixer\" },\n\t{ \"ROUT2\", NULL, \"Right Out 2\" },\n};\n\nstatic int es8328_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\treturn snd_soc_component_update_bits(dai->component, ES8328_DACCONTROL3,\n\t\t\tES8328_DACCONTROL3_DACMUTE,\n\t\t\tmute ? ES8328_DACCONTROL3_DACMUTE : 0);\n}\n\nstatic int es8328_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\n\tif (es8328->provider && es8328->sysclk_constraints)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\tes8328->sysclk_constraints);\n\n\treturn 0;\n}\n\nstatic int es8328_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\tint i;\n\tint reg;\n\tint wl;\n\tint ratio;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treg = ES8328_DACCONTROL2;\n\telse\n\t\treg = ES8328_ADCCONTROL5;\n\n\tif (es8328->provider) {\n\t\tif (!es8328->sysclk_constraints) {\n\t\t\tdev_err(component->dev, \"No MCLK configured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < es8328->sysclk_constraints->count; i++)\n\t\t\tif (es8328->sysclk_constraints->list[i] ==\n\t\t\t    params_rate(params))\n\t\t\t\tbreak;\n\n\t\tif (i == es8328->sysclk_constraints->count) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"LRCLK %d unsupported with current clock\\n\",\n\t\t\t\tparams_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tratio = es8328->mclk_ratios[i];\n\t} else {\n\t\tratio = 0;\n\t\tes8328->mclkdiv2 = 0;\n\t}\n\n\tsnd_soc_component_update_bits(component, ES8328_MASTERMODE,\n\t\t\tES8328_MASTERMODE_MCLKDIV2,\n\t\t\tes8328->mclkdiv2 ? ES8328_MASTERMODE_MCLKDIV2 : 0);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\twl = 3;\n\t\tbreak;\n\tcase 18:\n\t\twl = 2;\n\t\tbreak;\n\tcase 20:\n\t\twl = 1;\n\t\tbreak;\n\tcase 24:\n\t\twl = 0;\n\t\tbreak;\n\tcase 32:\n\t\twl = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsnd_soc_component_update_bits(component, ES8328_DACCONTROL1,\n\t\t\t\tES8328_DACCONTROL1_DACWL_MASK,\n\t\t\t\twl << ES8328_DACCONTROL1_DACWL_SHIFT);\n\n\t\tes8328->playback_fs = params_rate(params);\n\t\tes8328_set_deemph(component);\n\t} else\n\t\tsnd_soc_component_update_bits(component, ES8328_ADCCONTROL4,\n\t\t\t\tES8328_ADCCONTROL4_ADCWL_MASK,\n\t\t\t\twl << ES8328_ADCCONTROL4_ADCWL_SHIFT);\n\n\treturn snd_soc_component_update_bits(component, reg, ES8328_RATEMASK, ratio);\n}\n\nstatic int es8328_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\tint mclkdiv2 = 0;\n\n\tswitch (freq) {\n\tcase 0:\n\t\tes8328->sysclk_constraints = NULL;\n\t\tes8328->mclk_ratios = NULL;\n\t\tbreak;\n\tcase 22579200:\n\t\tmclkdiv2 = 1;\n\t\tfallthrough;\n\tcase 11289600:\n\t\tes8328->sysclk_constraints = &constraints_11289;\n\t\tes8328->mclk_ratios = ratios_11289;\n\t\tbreak;\n\tcase 24576000:\n\t\tmclkdiv2 = 1;\n\t\tfallthrough;\n\tcase 12288000:\n\t\tes8328->sysclk_constraints = &constraints_12288;\n\t\tes8328->mclk_ratios = ratios_12288;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tes8328->mclkdiv2 = mclkdiv2;\n\treturn 0;\n}\n\nstatic int es8328_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);\n\tu8 dac_mode = 0;\n\tu8 adc_mode = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t \n\t\tsnd_soc_component_update_bits(component, ES8328_MASTERMODE,\n\t\t\t\t    ES8328_MASTERMODE_MSC,\n\t\t\t\t    ES8328_MASTERMODE_MSC);\n\t\tes8328->provider = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\t \n\t\tsnd_soc_component_update_bits(component, ES8328_MASTERMODE,\n\t\t\t\t    ES8328_MASTERMODE_MSC, 0);\n\t\tes8328->provider = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdac_mode |= ES8328_DACCONTROL1_DACFORMAT_I2S;\n\t\tadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdac_mode |= ES8328_DACCONTROL1_DACFORMAT_RJUST;\n\t\tadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_RJUST;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdac_mode |= ES8328_DACCONTROL1_DACFORMAT_LJUST;\n\t\tadc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_LJUST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, ES8328_DACCONTROL1,\n\t\t\tES8328_DACCONTROL1_DACFORMAT_MASK, dac_mode);\n\tsnd_soc_component_update_bits(component, ES8328_ADCCONTROL4,\n\t\t\tES8328_ADCCONTROL4_ADCFORMAT_MASK, adc_mode);\n\n\treturn 0;\n}\n\nstatic int es8328_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_write(component, ES8328_CHIPPOWER, 0);\n\t\tsnd_soc_component_update_bits(component, ES8328_CONTROL1,\n\t\t\t\tES8328_CONTROL1_VMIDSEL_MASK |\n\t\t\t\tES8328_CONTROL1_ENREF,\n\t\t\t\tES8328_CONTROL1_VMIDSEL_50k |\n\t\t\t\tES8328_CONTROL1_ENREF);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tsnd_soc_component_update_bits(component, ES8328_CONTROL1,\n\t\t\t\t\tES8328_CONTROL1_VMIDSEL_MASK |\n\t\t\t\t\tES8328_CONTROL1_ENREF,\n\t\t\t\t\tES8328_CONTROL1_VMIDSEL_5k |\n\t\t\t\t\tES8328_CONTROL1_ENREF);\n\n\t\t\t \n\t\t\tmsleep(100);\n\t\t}\n\n\t\tsnd_soc_component_write(component, ES8328_CONTROL2,\n\t\t\t\tES8328_CONTROL2_OVERCURRENT_ON |\n\t\t\t\tES8328_CONTROL2_THERMAL_SHUTDOWN_ON);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, ES8328_CONTROL1,\n\t\t\t\tES8328_CONTROL1_VMIDSEL_MASK |\n\t\t\t\tES8328_CONTROL1_ENREF,\n\t\t\t\tES8328_CONTROL1_VMIDSEL_500k |\n\t\t\t\tES8328_CONTROL1_ENREF);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, ES8328_CONTROL1,\n\t\t\t\tES8328_CONTROL1_VMIDSEL_MASK |\n\t\t\t\tES8328_CONTROL1_ENREF,\n\t\t\t\t0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops es8328_dai_ops = {\n\t.startup\t= es8328_startup,\n\t.hw_params\t= es8328_hw_params,\n\t.mute_stream\t= es8328_mute,\n\t.set_sysclk\t= es8328_set_sysclk,\n\t.set_fmt\t= es8328_set_dai_fmt,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver es8328_dai = {\n\t.name = \"es8328-hifi-analog\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = ES8328_RATES,\n\t\t.formats = ES8328_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = ES8328_RATES,\n\t\t.formats = ES8328_FORMATS,\n\t},\n\t.ops = &es8328_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int es8328_suspend(struct snd_soc_component *component)\n{\n\tstruct es8328_priv *es8328;\n\tint ret;\n\n\tes8328 = snd_soc_component_get_drvdata(component);\n\n\tclk_disable_unprepare(es8328->clk);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\n\t\t\tes8328->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to disable regulators\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int es8328_resume(struct snd_soc_component *component)\n{\n\tstruct regmap *regmap = dev_get_regmap(component->dev, NULL);\n\tstruct es8328_priv *es8328;\n\tint ret;\n\n\tes8328 = snd_soc_component_get_drvdata(component);\n\n\tret = clk_prepare_enable(es8328->clk);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\n\t\t\t\t\tes8328->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tregcache_mark_dirty(regmap);\n\tret = regcache_sync(regmap);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to sync regcache\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int es8328_component_probe(struct snd_soc_component *component)\n{\n\tstruct es8328_priv *es8328;\n\tint ret;\n\n\tes8328 = snd_soc_component_get_drvdata(component);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(es8328->supplies),\n\t\t\t\t\tes8328->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to enable regulators\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tes8328->clk = devm_clk_get(component->dev, NULL);\n\tif (IS_ERR(es8328->clk)) {\n\t\tdev_err(component->dev, \"codec clock missing or invalid\\n\");\n\t\tret = PTR_ERR(es8328->clk);\n\t\tgoto clk_fail;\n\t}\n\n\tret = clk_prepare_enable(es8328->clk);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to prepare codec clk\\n\");\n\t\tgoto clk_fail;\n\t}\n\n\treturn 0;\n\nclk_fail:\n\tregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\n\t\t\t       es8328->supplies);\n\treturn ret;\n}\n\nstatic void es8328_remove(struct snd_soc_component *component)\n{\n\tstruct es8328_priv *es8328;\n\n\tes8328 = snd_soc_component_get_drvdata(component);\n\n\tclk_disable_unprepare(es8328->clk);\n\n\tregulator_bulk_disable(ARRAY_SIZE(es8328->supplies),\n\t\t\t       es8328->supplies);\n}\n\nconst struct regmap_config es8328_regmap_config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= ES8328_REG_MAX,\n\t.cache_type\t= REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\nEXPORT_SYMBOL_GPL(es8328_regmap_config);\n\nstatic const struct snd_soc_component_driver es8328_component_driver = {\n\t.probe\t\t\t= es8328_component_probe,\n\t.remove\t\t\t= es8328_remove,\n\t.suspend\t\t= es8328_suspend,\n\t.resume\t\t\t= es8328_resume,\n\t.set_bias_level\t\t= es8328_set_bias_level,\n\t.controls\t\t= es8328_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(es8328_snd_controls),\n\t.dapm_widgets\t\t= es8328_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(es8328_dapm_widgets),\n\t.dapm_routes\t\t= es8328_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(es8328_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint es8328_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct es8328_priv *es8328;\n\tint ret;\n\tint i;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tes8328 = devm_kzalloc(dev, sizeof(*es8328), GFP_KERNEL);\n\tif (es8328 == NULL)\n\t\treturn -ENOMEM;\n\n\tes8328->regmap = regmap;\n\n\tfor (i = 0; i < ARRAY_SIZE(es8328->supplies); i++)\n\t\tes8328->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(es8328->supplies),\n\t\t\t\tes8328->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to get regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, es8328);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t&es8328_component_driver, &es8328_dai, 1);\n}\nEXPORT_SYMBOL_GPL(es8328_probe);\n\nMODULE_DESCRIPTION(\"ASoC ES8328 driver\");\nMODULE_AUTHOR(\"Sean Cross <xobs@kosagi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}