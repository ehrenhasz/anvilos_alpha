{
  "module_name": "tlv320aic3x.c",
  "hash_id": "88aebe64b68f617ad771c466a1782deee3ceb216f11ef8281d286e8770f8fc15",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic3x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"tlv320aic3x.h\"\n\n#define AIC3X_NUM_SUPPLIES\t4\nstatic const char *aic3x_supply_names[AIC3X_NUM_SUPPLIES] = {\n\t\"IOVDD\",\t \n\t\"DVDD\",\t\t \n\t\"AVDD\",\t\t \n\t\"DRVDD\",\t \n};\n\nstruct aic3x_priv;\n\nstruct aic3x_disable_nb {\n\tstruct notifier_block nb;\n\tstruct aic3x_priv *aic3x;\n};\n\nstruct aic3x_setup_data {\n\tunsigned int gpio_func[2];\n};\n\n \nstruct aic3x_priv {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[AIC3X_NUM_SUPPLIES];\n\tstruct aic3x_disable_nb disable_nb[AIC3X_NUM_SUPPLIES];\n\tstruct aic3x_setup_data *setup;\n\tunsigned int sysclk;\n\tunsigned int dai_fmt;\n\tunsigned int tdm_delay;\n\tunsigned int slot_width;\n\tint master;\n\tstruct gpio_desc *gpio_reset;\n\tbool shared_reset;\n\tint power;\n\tu16 model;\n\n\t \n\tenum aic3x_micbias_voltage micbias_vg;\n\t \n\tu8 ocmv;\n};\n\nstatic const struct reg_default aic3x_reg[] = {\n\t{   0, 0x00 }, {   1, 0x00 }, {   2, 0x00 }, {   3, 0x10 },\n\t{   4, 0x04 }, {   5, 0x00 }, {   6, 0x00 }, {   7, 0x00 },\n\t{   8, 0x00 }, {   9, 0x00 }, {  10, 0x00 }, {  11, 0x01 },\n\t{  12, 0x00 }, {  13, 0x00 }, {  14, 0x00 }, {  15, 0x80 },\n\t{  16, 0x80 }, {  17, 0xff }, {  18, 0xff }, {  19, 0x78 },\n\t{  20, 0x78 }, {  21, 0x78 }, {  22, 0x78 }, {  23, 0x78 },\n\t{  24, 0x78 }, {  25, 0x00 }, {  26, 0x00 }, {  27, 0xfe },\n\t{  28, 0x00 }, {  29, 0x00 }, {  30, 0xfe }, {  31, 0x00 },\n\t{  32, 0x18 }, {  33, 0x18 }, {  34, 0x00 }, {  35, 0x00 },\n\t{  36, 0x00 }, {  37, 0x00 }, {  38, 0x00 }, {  39, 0x00 },\n\t{  40, 0x00 }, {  41, 0x00 }, {  42, 0x00 }, {  43, 0x80 },\n\t{  44, 0x80 }, {  45, 0x00 }, {  46, 0x00 }, {  47, 0x00 },\n\t{  48, 0x00 }, {  49, 0x00 }, {  50, 0x00 }, {  51, 0x04 },\n\t{  52, 0x00 }, {  53, 0x00 }, {  54, 0x00 }, {  55, 0x00 },\n\t{  56, 0x00 }, {  57, 0x00 }, {  58, 0x04 }, {  59, 0x00 },\n\t{  60, 0x00 }, {  61, 0x00 }, {  62, 0x00 }, {  63, 0x00 },\n\t{  64, 0x00 }, {  65, 0x04 }, {  66, 0x00 }, {  67, 0x00 },\n\t{  68, 0x00 }, {  69, 0x00 }, {  70, 0x00 }, {  71, 0x00 },\n\t{  72, 0x04 }, {  73, 0x00 }, {  74, 0x00 }, {  75, 0x00 },\n\t{  76, 0x00 }, {  77, 0x00 }, {  78, 0x00 }, {  79, 0x00 },\n\t{  80, 0x00 }, {  81, 0x00 }, {  82, 0x00 }, {  83, 0x00 },\n\t{  84, 0x00 }, {  85, 0x00 }, {  86, 0x00 }, {  87, 0x00 },\n\t{  88, 0x00 }, {  89, 0x00 }, {  90, 0x00 }, {  91, 0x00 },\n\t{  92, 0x00 }, {  93, 0x00 }, {  94, 0x00 }, {  95, 0x00 },\n\t{  96, 0x00 }, {  97, 0x00 }, {  98, 0x00 }, {  99, 0x00 },\n\t{ 100, 0x00 }, { 101, 0x00 }, { 102, 0x02 }, { 103, 0x00 },\n\t{ 104, 0x00 }, { 105, 0x00 }, { 106, 0x00 }, { 107, 0x00 },\n\t{ 108, 0x00 }, { 109, 0x00 },\n};\n\nstatic bool aic3x_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AIC3X_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct regmap_config aic3x_regmap = {\n\t.max_register = DAC_ICC_ADJ,\n\t.reg_defaults = aic3x_reg,\n\t.num_reg_defaults = ARRAY_SIZE(aic3x_reg),\n\n\t.volatile_reg = aic3x_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_GPL(aic3x_regmap);\n\n#define SOC_DAPM_SINGLE_AIC3X(xname, reg, shift, mask, invert) \\\n\tSOC_SINGLE_EXT(xname, reg, shift, mask, invert, \\\n\t\tsnd_soc_dapm_get_volsw, snd_soc_dapm_put_volsw_aic3x)\n\n \nstatic int snd_soc_dapm_put_volsw_aic3x(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned short val;\n\tstruct snd_soc_dapm_update update = {};\n\tint connect, change;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\n\tmask = 0xf;\n\tif (val)\n\t\tval = mask;\n\n\tconnect = !!val;\n\n\tif (invert)\n\t\tval = mask - val;\n\n\tmask <<= shift;\n\tval <<= shift;\n\n\tchange = snd_soc_component_test_bits(component, reg, mask, val);\n\tif (change) {\n\t\tupdate.kcontrol = kcontrol;\n\t\tupdate.reg = reg;\n\t\tupdate.mask = mask;\n\t\tupdate.val = val;\n\n\t\tsnd_soc_dapm_mixer_update_power(dapm, kcontrol, connect,\n\t\t\t&update);\n\t}\n\n\treturn change;\n}\n\n \nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, MICBIAS_CTRL,\n\t\t\t\tMICBIAS_LEVEL_MASK,\n\t\t\t\taic3x->micbias_vg << MICBIAS_LEVEL_SHIFT);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, MICBIAS_CTRL,\n\t\t\t\tMICBIAS_LEVEL_MASK, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const char * const aic3x_left_dac_mux[] = {\n\t\"DAC_L1\", \"DAC_L3\", \"DAC_L2\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_left_dac_enum, DAC_LINE_MUX, 6,\n\t\t\t    aic3x_left_dac_mux);\n\nstatic const char * const aic3x_right_dac_mux[] = {\n\t\"DAC_R1\", \"DAC_R3\", \"DAC_R2\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_right_dac_enum, DAC_LINE_MUX, 4,\n\t\t\t    aic3x_right_dac_mux);\n\nstatic const char * const aic3x_left_hpcom_mux[] = {\n\t\"differential of HPLOUT\", \"constant VCM\", \"single-ended\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_left_hpcom_enum, HPLCOM_CFG, 4,\n\t\t\t    aic3x_left_hpcom_mux);\n\nstatic const char * const aic3x_right_hpcom_mux[] = {\n\t\"differential of HPROUT\", \"constant VCM\", \"single-ended\",\n\t\"differential of HPLCOM\", \"external feedback\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_right_hpcom_enum, HPRCOM_CFG, 3,\n\t\t\t    aic3x_right_hpcom_mux);\n\nstatic const char * const aic3x_linein_mode_mux[] = {\n\t\"single-ended\", \"differential\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line1l_2_l_enum, LINE1L_2_LADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line1l_2_r_enum, LINE1L_2_RADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line1r_2_l_enum, LINE1R_2_LADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line1r_2_r_enum, LINE1R_2_RADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line2l_2_ldac_enum, LINE2L_2_LADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_line2r_2_rdac_enum, LINE2R_2_RADC_CTRL, 7,\n\t\t\t    aic3x_linein_mode_mux);\n\nstatic const char * const aic3x_adc_hpf[] = {\n\t\"Disabled\", \"0.0045xFs\", \"0.0125xFs\", \"0.025xFs\" };\nstatic SOC_ENUM_DOUBLE_DECL(aic3x_adc_hpf_enum, AIC3X_CODEC_DFILT_CTRL, 6, 4,\n\t\t\t    aic3x_adc_hpf);\n\nstatic const char * const aic3x_agc_level[] = {\n\t\"-5.5dB\", \"-8dB\", \"-10dB\", \"-12dB\",\n\t\"-14dB\", \"-17dB\", \"-20dB\", \"-24dB\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_lagc_level_enum, LAGC_CTRL_A, 4,\n\t\t\t    aic3x_agc_level);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_ragc_level_enum, RAGC_CTRL_A, 4,\n\t\t\t    aic3x_agc_level);\n\nstatic const char * const aic3x_agc_attack[] = {\n\t\"8ms\", \"11ms\", \"16ms\", \"20ms\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_lagc_attack_enum, LAGC_CTRL_A, 2,\n\t\t\t    aic3x_agc_attack);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_ragc_attack_enum, RAGC_CTRL_A, 2,\n\t\t\t    aic3x_agc_attack);\n\nstatic const char * const aic3x_agc_decay[] = {\n\t\"100ms\", \"200ms\", \"400ms\", \"500ms\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_lagc_decay_enum, LAGC_CTRL_A, 0,\n\t\t\t    aic3x_agc_decay);\nstatic SOC_ENUM_SINGLE_DECL(aic3x_ragc_decay_enum, RAGC_CTRL_A, 0,\n\t\t\t    aic3x_agc_decay);\n\nstatic const char * const aic3x_poweron_time[] = {\n\t\"0us\", \"10us\", \"100us\", \"1ms\", \"10ms\", \"50ms\",\n\t\"100ms\", \"200ms\", \"400ms\", \"800ms\", \"2s\", \"4s\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_poweron_time_enum, HPOUT_POP_REDUCTION, 4,\n\t\t\t    aic3x_poweron_time);\n\nstatic const char * const aic3x_rampup_step[] = { \"0ms\", \"1ms\", \"2ms\", \"4ms\" };\nstatic SOC_ENUM_SINGLE_DECL(aic3x_rampup_step_enum, HPOUT_POP_REDUCTION, 2,\n\t\t\t    aic3x_rampup_step);\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -6350, 50, 0);\n \nstatic DECLARE_TLV_DB_SCALE(adc_tlv, 0, 50, 0);\n \nstatic DECLARE_TLV_DB_SCALE(output_stage_tlv, -5900, 50, 1);\n\n \nstatic const DECLARE_TLV_DB_SCALE(out_tlv, 0, 100, 0);\n\nstatic const struct snd_kcontrol_new aic3x_snd_controls[] = {\n\t \n\tSOC_DOUBLE_R_TLV(\"PCM Playback Volume\",\n\t\t\t LDAC_VOL, RDAC_VOL, 0, 0x7f, 1, dac_tlv),\n\n\t \n\tSOC_SINGLE_TLV(\"Left Line Mixer PGAR Bypass Volume\",\n\t\t       PGAR_2_LLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Left Line Mixer DACR1 Playback Volume\",\n\t\t       DACR1_2_LLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right Line Mixer PGAL Bypass Volume\",\n\t\t       PGAL_2_RLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Right Line Mixer DACL1 Playback Volume\",\n\t\t       DACL1_2_RLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Left HP Mixer PGAR Bypass Volume\",\n\t\t       PGAR_2_HPLOUT_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Left HP Mixer DACR1 Playback Volume\",\n\t\t       DACR1_2_HPLOUT_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right HP Mixer PGAL Bypass Volume\",\n\t\t       PGAL_2_HPROUT_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Right HP Mixer DACL1 Playback Volume\",\n\t\t       DACL1_2_HPROUT_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Left HPCOM Mixer PGAR Bypass Volume\",\n\t\t       PGAR_2_HPLCOM_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Left HPCOM Mixer DACR1 Playback Volume\",\n\t\t       DACR1_2_HPLCOM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right HPCOM Mixer PGAL Bypass Volume\",\n\t\t       PGAL_2_HPRCOM_VOL, 0, 118, 1, output_stage_tlv),\n\tSOC_SINGLE_TLV(\"Right HPCOM Mixer DACL1 Playback Volume\",\n\t\t       DACL1_2_HPRCOM_VOL, 0, 118, 1, output_stage_tlv),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Line PGA Bypass Volume\",\n\t\t\t PGAL_2_LLOPM_VOL, PGAR_2_RLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\tSOC_DOUBLE_R_TLV(\"Line DAC Playback Volume\",\n\t\t\t DACL1_2_LLOPM_VOL, DACR1_2_RLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HP PGA Bypass Volume\",\n\t\t\t PGAL_2_HPLOUT_VOL, PGAR_2_HPROUT_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\tSOC_DOUBLE_R_TLV(\"HP DAC Playback Volume\",\n\t\t\t DACL1_2_HPLOUT_VOL, DACR1_2_HPROUT_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HPCOM PGA Bypass Volume\",\n\t\t\t PGAL_2_HPLCOM_VOL, PGAR_2_HPRCOM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\tSOC_DOUBLE_R_TLV(\"HPCOM DAC Playback Volume\",\n\t\t\t DACL1_2_HPLCOM_VOL, DACR1_2_HPRCOM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Line Playback Volume\", LLOPM_CTRL, RLOPM_CTRL, 4,\n\t\t\t 9, 0, out_tlv),\n\tSOC_DOUBLE_R(\"Line Playback Switch\", LLOPM_CTRL, RLOPM_CTRL, 3,\n\t\t     0x01, 0),\n\tSOC_DOUBLE_R_TLV(\"HP Playback Volume\", HPLOUT_CTRL, HPROUT_CTRL, 4,\n\t\t\t 9, 0, out_tlv),\n\tSOC_DOUBLE_R(\"HP Playback Switch\", HPLOUT_CTRL, HPROUT_CTRL, 3,\n\t\t     0x01, 0),\n\tSOC_DOUBLE_R_TLV(\"HPCOM Playback Volume\", HPLCOM_CTRL, HPRCOM_CTRL,\n\t\t\t 4, 9, 0, out_tlv),\n\tSOC_DOUBLE_R(\"HPCOM Playback Switch\", HPLCOM_CTRL, HPRCOM_CTRL, 3,\n\t\t     0x01, 0),\n\n\t \n\tSOC_DOUBLE_R(\"AGC Switch\", LAGC_CTRL_A, RAGC_CTRL_A, 7, 0x01, 0),\n\tSOC_ENUM(\"Left AGC Target level\", aic3x_lagc_level_enum),\n\tSOC_ENUM(\"Right AGC Target level\", aic3x_ragc_level_enum),\n\tSOC_ENUM(\"Left AGC Attack time\", aic3x_lagc_attack_enum),\n\tSOC_ENUM(\"Right AGC Attack time\", aic3x_ragc_attack_enum),\n\tSOC_ENUM(\"Left AGC Decay time\", aic3x_lagc_decay_enum),\n\tSOC_ENUM(\"Right AGC Decay time\", aic3x_ragc_decay_enum),\n\n\t \n\tSOC_DOUBLE(\"De-emphasis Switch\", AIC3X_CODEC_DFILT_CTRL, 2, 0, 0x01, 0),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"PGA Capture Volume\", LADC_VOL, RADC_VOL,\n\t\t\t 0, 119, 0, adc_tlv),\n\tSOC_DOUBLE_R(\"PGA Capture Switch\", LADC_VOL, RADC_VOL, 7, 0x01, 1),\n\n\tSOC_ENUM(\"ADC HPF Cut-off\", aic3x_adc_hpf_enum),\n\n\t \n\tSOC_ENUM(\"Output Driver Power-On time\", aic3x_poweron_time_enum),\n\tSOC_ENUM(\"Output Driver Ramp-up step\", aic3x_rampup_step_enum),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_extra_snd_controls[] = {\n\t \n\tSOC_SINGLE_TLV(\"Left Line Mixer Line2R Bypass Volume\",\n\t\t       LINE2R_2_LLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right Line Mixer Line2L Bypass Volume\",\n\t\t       LINE2L_2_RLOPM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Left HP Mixer Line2R Bypass Volume\",\n\t\t       LINE2R_2_HPLOUT_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right HP Mixer Line2L Bypass Volume\",\n\t\t       LINE2L_2_HPROUT_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Left HPCOM Mixer Line2R Bypass Volume\",\n\t\t       LINE2R_2_HPLCOM_VOL, 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE_TLV(\"Right HPCOM Mixer Line2L Bypass Volume\",\n\t\t       LINE2L_2_HPRCOM_VOL, 0, 118, 1, output_stage_tlv),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Line Line2 Bypass Volume\",\n\t\t\t LINE2L_2_LLOPM_VOL, LINE2R_2_RLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HP Line2 Bypass Volume\",\n\t\t\t LINE2L_2_HPLOUT_VOL, LINE2R_2_HPROUT_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HPCOM Line2 Bypass Volume\",\n\t\t\t LINE2L_2_HPLCOM_VOL, LINE2R_2_HPRCOM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n};\n\nstatic const struct snd_kcontrol_new aic3x_mono_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Mono Line2 Bypass Volume\",\n\t\t\t LINE2L_2_MONOLOPM_VOL, LINE2R_2_MONOLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\tSOC_DOUBLE_R_TLV(\"Mono PGA Bypass Volume\",\n\t\t\t PGAL_2_MONOLOPM_VOL, PGAR_2_MONOLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\tSOC_DOUBLE_R_TLV(\"Mono DAC Playback Volume\",\n\t\t\t DACL1_2_MONOLOPM_VOL, DACR1_2_MONOLOPM_VOL,\n\t\t\t 0, 118, 1, output_stage_tlv),\n\n\tSOC_SINGLE(\"Mono Playback Switch\", MONOLOPM_CTRL, 3, 0x01, 0),\n\tSOC_SINGLE_TLV(\"Mono Playback Volume\", MONOLOPM_CTRL, 4, 9, 0,\n\t\t\tout_tlv),\n\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(classd_amp_tlv, 0, 600, 0);\n\nstatic const struct snd_kcontrol_new aic3x_classd_amp_gain_ctrl =\n\tSOC_DOUBLE_TLV(\"Class-D Playback Volume\", CLASSD_CTRL, 6, 4, 3, 0, classd_amp_tlv);\n\n \nstatic const struct snd_kcontrol_new aic3x_left_dac_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_left_dac_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_right_dac_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_right_dac_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_left_hpcom_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_left_hpcom_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_right_hpcom_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_right_hpcom_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_left_line_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_LLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_LLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_LLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_LLOPM_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_LLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_LLOPM_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_right_line_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_RLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_RLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_RLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_RLOPM_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_RLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_RLOPM_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_mono_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_MONOLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_MONOLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_MONOLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_MONOLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_MONOLOPM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_MONOLOPM_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_left_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_HPLOUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_HPLOUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_HPLOUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_HPLOUT_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_HPLOUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_HPLOUT_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_right_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_HPROUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_HPROUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_HPROUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_HPROUT_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_HPROUT_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_HPROUT_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_left_hpcom_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_HPLCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_HPLCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_HPLCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_HPLCOM_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_HPLCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_HPLCOM_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_right_hpcom_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PGAL Bypass Switch\", PGAL_2_HPRCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACL1 Switch\", DACL1_2_HPRCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"PGAR Bypass Switch\", PGAR_2_HPRCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"DACR1 Switch\", DACR1_2_HPRCOM_VOL, 7, 1, 0),\n\t \n\tSOC_DAPM_SINGLE(\"Line2L Bypass Switch\", LINE2L_2_HPRCOM_VOL, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line2R Bypass Switch\", LINE2R_2_HPRCOM_VOL, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_left_pga_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1L Switch\", LINE1L_2_LADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1R Switch\", LINE1R_2_LADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line2L Switch\", LINE2L_2_LADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic3L Switch\", MIC3LR_2_LADC_CTRL, 4, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic3R Switch\", MIC3LR_2_LADC_CTRL, 0, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_right_pga_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1R Switch\", LINE1R_2_RADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1L Switch\", LINE1L_2_RADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line2R Switch\", LINE2R_2_RADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic3L Switch\", MIC3LR_2_RADC_CTRL, 4, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic3R Switch\", MIC3LR_2_RADC_CTRL, 0, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new aic3104_left_pga_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1L Switch\", LINE1L_2_LADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1R Switch\", LINE1R_2_LADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic2L Switch\", MIC3LR_2_LADC_CTRL, 4, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic2R Switch\", MIC3LR_2_LADC_CTRL, 0, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new aic3104_right_pga_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1R Switch\", LINE1R_2_RADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Line1L Switch\", LINE1L_2_RADC_CTRL, 3, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic2L Switch\", MIC3LR_2_RADC_CTRL, 4, 1, 1),\n\tSOC_DAPM_SINGLE_AIC3X(\"Mic2R Switch\", MIC3LR_2_RADC_CTRL, 0, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new aic3x_left_line1l_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line1l_2_l_enum);\nstatic const struct snd_kcontrol_new aic3x_right_line1l_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line1l_2_r_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_right_line1r_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line1r_2_r_enum);\nstatic const struct snd_kcontrol_new aic3x_left_line1r_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line1r_2_l_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_left_line2_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line2l_2_ldac_enum);\n\n \nstatic const struct snd_kcontrol_new aic3x_right_line2_mux_controls =\nSOC_DAPM_ENUM(\"Route\", aic3x_line2r_2_rdac_enum);\n\nstatic const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", DAC_PWR, 7, 0),\n\tSND_SOC_DAPM_MUX(\"Left DAC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_left_dac_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Left HPCOM Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_left_hpcom_mux_controls),\n\tSND_SOC_DAPM_PGA(\"Left Line Out\", LLOPM_CTRL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left HP Out\", HPLOUT_CTRL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left HP Com\", HPLCOM_CTRL, 0, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", DAC_PWR, 6, 0),\n\tSND_SOC_DAPM_MUX(\"Right DAC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_right_dac_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Right HPCOM Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_right_hpcom_mux_controls),\n\tSND_SOC_DAPM_PGA(\"Right Line Out\", RLOPM_CTRL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right HP Out\", HPROUT_CTRL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right HP Com\", HPRCOM_CTRL, 0, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", LINE1L_2_LADC_CTRL, 2, 0),\n\tSND_SOC_DAPM_MUX(\"Left Line1L Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_left_line1l_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Left Line1R Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_left_line1r_mux_controls),\n\n\t \n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\",\n\t\t\t LINE1R_2_RADC_CTRL, 2, 0),\n\tSND_SOC_DAPM_MUX(\"Right Line1L Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_right_line1l_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Right Line1R Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_right_line1r_mux_controls),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", MICBIAS_CTRL, 6, 0,\n\t\t\t mic_bias_event,\n\t\t\t SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"LLOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"RLOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPLOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPROUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPLCOM\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPRCOM\"),\n\n\tSND_SOC_DAPM_INPUT(\"LINE1L\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1R\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"Detection\"),\n};\n\n \nstatic const struct snd_soc_dapm_widget aic3x_extra_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_MIXER(\"Left PGA Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_pga_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_pga_mixer_controls)),\n\tSND_SOC_DAPM_MUX(\"Left Line2L Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_left_line2_mux_controls),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Right PGA Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_pga_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_pga_mixer_controls)),\n\tSND_SOC_DAPM_MUX(\"Right Line2R Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &aic3x_right_line2_mux_controls),\n\n\t \n\tSND_SOC_DAPM_REG(snd_soc_dapm_micbias, \"GPIO1 dmic modclk\",\n\t\t\t AIC3X_GPIO1_REG, 4, 0xf,\n\t\t\t AIC3X_GPIO1_FUNC_DIGITAL_MIC_MODCLK,\n\t\t\t AIC3X_GPIO1_FUNC_DISABLED),\n\n\t \n\tSND_SOC_DAPM_REG(snd_soc_dapm_micbias, \"DMic Rate 128\",\n\t\t\t AIC3X_ASD_INTF_CTRLA, 0, 3, 1, 0),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_micbias, \"DMic Rate 64\",\n\t\t\t AIC3X_ASD_INTF_CTRLA, 0, 3, 2, 0),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_micbias, \"DMic Rate 32\",\n\t\t\t AIC3X_ASD_INTF_CTRLA, 0, 3, 3, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Left Line Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_line_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_line_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right Line Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_line_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_line_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Left HP Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_hp_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_hp_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right HP Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_hp_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_hp_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Left HPCOM Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_hpcom_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_hpcom_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right HPCOM Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_hpcom_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_hpcom_mixer_controls)),\n\n\tSND_SOC_DAPM_INPUT(\"MIC3L\"),\n\tSND_SOC_DAPM_INPUT(\"MIC3R\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2L\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2R\"),\n};\n\n \nstatic const struct snd_soc_dapm_widget aic3104_extra_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_MIXER(\"Left PGA Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3104_left_pga_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3104_left_pga_mixer_controls)),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Right PGA Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3104_right_pga_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3104_right_pga_mixer_controls)),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Left Line Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_line_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_line_mixer_controls) - 2),\n\tSND_SOC_DAPM_MIXER(\"Right Line Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_line_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_line_mixer_controls) - 2),\n\tSND_SOC_DAPM_MIXER(\"Left HP Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_hp_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_hp_mixer_controls) - 2),\n\tSND_SOC_DAPM_MIXER(\"Right HP Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_hp_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_hp_mixer_controls) - 2),\n\tSND_SOC_DAPM_MIXER(\"Left HPCOM Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_left_hpcom_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_left_hpcom_mixer_controls) - 2),\n\tSND_SOC_DAPM_MIXER(\"Right HPCOM Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_right_hpcom_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_right_hpcom_mixer_controls) - 2),\n\n\tSND_SOC_DAPM_INPUT(\"MIC2L\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2R\"),\n};\n\nstatic const struct snd_soc_dapm_widget aic3x_dapm_mono_widgets[] = {\n\t \n\tSND_SOC_DAPM_PGA(\"Mono Out\", MONOLOPM_CTRL, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Mono Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &aic3x_mono_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(aic3x_mono_mixer_controls)),\n\n\tSND_SOC_DAPM_OUTPUT(\"MONO_LOUT\"),\n};\n\nstatic const struct snd_soc_dapm_widget aic3007_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_PGA(\"Left Class-D Out\", CLASSD_CTRL, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Class-D Out\", CLASSD_CTRL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPOP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOM\"),\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t \n\t{\"Left Line1L Mux\", \"single-ended\", \"LINE1L\"},\n\t{\"Left Line1L Mux\", \"differential\", \"LINE1L\"},\n\t{\"Left Line1R Mux\", \"single-ended\", \"LINE1R\"},\n\t{\"Left Line1R Mux\", \"differential\", \"LINE1R\"},\n\n\t{\"Left PGA Mixer\", \"Line1L Switch\", \"Left Line1L Mux\"},\n\t{\"Left PGA Mixer\", \"Line1R Switch\", \"Left Line1R Mux\"},\n\n\t{\"Left ADC\", NULL, \"Left PGA Mixer\"},\n\n\t \n\t{\"Right Line1R Mux\", \"single-ended\", \"LINE1R\"},\n\t{\"Right Line1R Mux\", \"differential\", \"LINE1R\"},\n\t{\"Right Line1L Mux\", \"single-ended\", \"LINE1L\"},\n\t{\"Right Line1L Mux\", \"differential\", \"LINE1L\"},\n\n\t{\"Right PGA Mixer\", \"Line1L Switch\", \"Right Line1L Mux\"},\n\t{\"Right PGA Mixer\", \"Line1R Switch\", \"Right Line1R Mux\"},\n\n\t{\"Right ADC\", NULL, \"Right PGA Mixer\"},\n\n\t \n\t{\"Left DAC Mux\", \"DAC_L1\", \"Left DAC\"},\n\t{\"Left DAC Mux\", \"DAC_L2\", \"Left DAC\"},\n\t{\"Left DAC Mux\", \"DAC_L3\", \"Left DAC\"},\n\n\t \n\t{\"Right DAC Mux\", \"DAC_R1\", \"Right DAC\"},\n\t{\"Right DAC Mux\", \"DAC_R2\", \"Right DAC\"},\n\t{\"Right DAC Mux\", \"DAC_R3\", \"Right DAC\"},\n\n\t \n\t{\"Left Line Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Left Line Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Left Line Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Left Line Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Left Line Out\", NULL, \"Left Line Mixer\"},\n\t{\"Left Line Out\", NULL, \"Left DAC Mux\"},\n\t{\"LLOUT\", NULL, \"Left Line Out\"},\n\n\t \n\t{\"Right Line Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Right Line Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Right Line Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Right Line Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Right Line Out\", NULL, \"Right Line Mixer\"},\n\t{\"Right Line Out\", NULL, \"Right DAC Mux\"},\n\t{\"RLOUT\", NULL, \"Right Line Out\"},\n\n\t \n\t{\"Left HP Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Left HP Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Left HP Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Left HP Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Left HP Out\", NULL, \"Left HP Mixer\"},\n\t{\"Left HP Out\", NULL, \"Left DAC Mux\"},\n\t{\"HPLOUT\", NULL, \"Left HP Out\"},\n\n\t \n\t{\"Right HP Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Right HP Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Right HP Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Right HP Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Right HP Out\", NULL, \"Right HP Mixer\"},\n\t{\"Right HP Out\", NULL, \"Right DAC Mux\"},\n\t{\"HPROUT\", NULL, \"Right HP Out\"},\n\n\t \n\t{\"Left HPCOM Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Left HPCOM Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Left HPCOM Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Left HPCOM Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Left HPCOM Mux\", \"differential of HPLOUT\", \"Left HP Mixer\"},\n\t{\"Left HPCOM Mux\", \"constant VCM\", \"Left HPCOM Mixer\"},\n\t{\"Left HPCOM Mux\", \"single-ended\", \"Left HPCOM Mixer\"},\n\t{\"Left HP Com\", NULL, \"Left HPCOM Mux\"},\n\t{\"HPLCOM\", NULL, \"Left HP Com\"},\n\n\t \n\t{\"Right HPCOM Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Right HPCOM Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Right HPCOM Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Right HPCOM Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\n\t{\"Right HPCOM Mux\", \"differential of HPROUT\", \"Right HP Mixer\"},\n\t{\"Right HPCOM Mux\", \"constant VCM\", \"Right HPCOM Mixer\"},\n\t{\"Right HPCOM Mux\", \"single-ended\", \"Right HPCOM Mixer\"},\n\t{\"Right HPCOM Mux\", \"differential of HPLCOM\", \"Left HPCOM Mixer\"},\n\t{\"Right HPCOM Mux\", \"external feedback\", \"Right HPCOM Mixer\"},\n\t{\"Right HP Com\", NULL, \"Right HPCOM Mux\"},\n\t{\"HPRCOM\", NULL, \"Right HP Com\"},\n};\n\n \nstatic const struct snd_soc_dapm_route intercon_extra[] = {\n\t \n\t{\"Left Line2L Mux\", \"single-ended\", \"LINE2L\"},\n\t{\"Left Line2L Mux\", \"differential\", \"LINE2L\"},\n\n\t{\"Left PGA Mixer\", \"Line2L Switch\", \"Left Line2L Mux\"},\n\t{\"Left PGA Mixer\", \"Mic3L Switch\", \"MIC3L\"},\n\t{\"Left PGA Mixer\", \"Mic3R Switch\", \"MIC3R\"},\n\n\t{\"Left ADC\", NULL, \"GPIO1 dmic modclk\"},\n\n\t \n\t{\"Right Line2R Mux\", \"single-ended\", \"LINE2R\"},\n\t{\"Right Line2R Mux\", \"differential\", \"LINE2R\"},\n\n\t{\"Right PGA Mixer\", \"Line2R Switch\", \"Right Line2R Mux\"},\n\t{\"Right PGA Mixer\", \"Mic3L Switch\", \"MIC3L\"},\n\t{\"Right PGA Mixer\", \"Mic3R Switch\", \"MIC3R\"},\n\n\t{\"Right ADC\", NULL, \"GPIO1 dmic modclk\"},\n\n\t \n\t{\"GPIO1 dmic modclk\", NULL, \"DMic Rate 128\"},\n\t{\"GPIO1 dmic modclk\", NULL, \"DMic Rate 64\"},\n\t{\"GPIO1 dmic modclk\", NULL, \"DMic Rate 32\"},\n\n\t \n\t{\"Left Line Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Left Line Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\n\t \n\t{\"Right Line Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Right Line Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\n\t \n\t{\"Left HP Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Left HP Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\n\t \n\t{\"Right HP Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Right HP Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\n\t \n\t{\"Left HPCOM Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Left HPCOM Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\n\t \n\t{\"Right HPCOM Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Right HPCOM Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n};\n\n \nstatic const struct snd_soc_dapm_route intercon_extra_3104[] = {\n\t \n\t{\"Left PGA Mixer\", \"Mic2L Switch\", \"MIC2L\"},\n\t{\"Left PGA Mixer\", \"Mic2R Switch\", \"MIC2R\"},\n\n\t \n\t{\"Right PGA Mixer\", \"Mic2L Switch\", \"MIC2L\"},\n\t{\"Right PGA Mixer\", \"Mic2R Switch\", \"MIC2R\"},\n};\n\nstatic const struct snd_soc_dapm_route intercon_mono[] = {\n\t \n\t{\"Mono Mixer\", \"Line2L Bypass Switch\", \"Left Line2L Mux\"},\n\t{\"Mono Mixer\", \"PGAL Bypass Switch\", \"Left PGA Mixer\"},\n\t{\"Mono Mixer\", \"DACL1 Switch\", \"Left DAC Mux\"},\n\t{\"Mono Mixer\", \"Line2R Bypass Switch\", \"Right Line2R Mux\"},\n\t{\"Mono Mixer\", \"PGAR Bypass Switch\", \"Right PGA Mixer\"},\n\t{\"Mono Mixer\", \"DACR1 Switch\", \"Right DAC Mux\"},\n\t{\"Mono Out\", NULL, \"Mono Mixer\"},\n\t{\"MONO_LOUT\", NULL, \"Mono Out\"},\n};\n\nstatic const struct snd_soc_dapm_route intercon_3007[] = {\n\t \n\t{\"Left Class-D Out\", NULL, \"Left Line Out\"},\n\t{\"Right Class-D Out\", NULL, \"Left Line Out\"},\n\t{\"SPOP\", NULL, \"Left Class-D Out\"},\n\t{\"SPOM\", NULL, \"Right Class-D Out\"},\n};\n\nstatic int aic3x_add_widgets(struct snd_soc_component *component)\n{\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tswitch (aic3x->model) {\n\tcase AIC3X_MODEL_3X:\n\tcase AIC3X_MODEL_33:\n\tcase AIC3X_MODEL_3106:\n\t\tsnd_soc_dapm_new_controls(dapm, aic3x_extra_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(aic3x_extra_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, intercon_extra,\n\t\t\t\t\tARRAY_SIZE(intercon_extra));\n\t\tsnd_soc_dapm_new_controls(dapm, aic3x_dapm_mono_widgets,\n\t\t\tARRAY_SIZE(aic3x_dapm_mono_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, intercon_mono,\n\t\t\t\t\tARRAY_SIZE(intercon_mono));\n\t\tbreak;\n\tcase AIC3X_MODEL_3007:\n\t\tsnd_soc_dapm_new_controls(dapm, aic3x_extra_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(aic3x_extra_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, intercon_extra,\n\t\t\t\t\tARRAY_SIZE(intercon_extra));\n\t\tsnd_soc_dapm_new_controls(dapm, aic3007_dapm_widgets,\n\t\t\tARRAY_SIZE(aic3007_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, intercon_3007,\n\t\t\t\t\tARRAY_SIZE(intercon_3007));\n\t\tbreak;\n\tcase AIC3X_MODEL_3104:\n\t\tsnd_soc_dapm_new_controls(dapm, aic3104_extra_dapm_widgets,\n\t\t\t\tARRAY_SIZE(aic3104_extra_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, intercon_extra_3104,\n\t\t\t\tARRAY_SIZE(intercon_extra_3104));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int aic3x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tint codec_clk = 0, bypass_pll = 0, fsref, last_clk = 0;\n\tu8 data, j, r, p, pll_q, pll_p = 1, pll_r = 1, pll_j = 1;\n\tu16 d, pll_d = 1;\n\tint clk;\n\tint width = aic3x->slot_width;\n\n\tif (!width)\n\t\twidth = params_width(params);\n\n\t \n\tdata = snd_soc_component_read(component, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));\n\tswitch (width) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tdata |= (0x01 << 4);\n\t\tbreak;\n\tcase 24:\n\t\tdata |= (0x02 << 4);\n\t\tbreak;\n\tcase 32:\n\t\tdata |= (0x03 << 4);\n\t\tbreak;\n\t}\n\tsnd_soc_component_write(component, AIC3X_ASD_INTF_CTRLB, data);\n\n\t \n\tfsref = (params_rate(params) % 11025 == 0) ? 44100 : 48000;\n\n\t \n\tfor (pll_q = 2; pll_q < 18; pll_q++)\n\t\tif (aic3x->sysclk / (128 * pll_q) == fsref) {\n\t\t\tbypass_pll = 1;\n\t\t\tbreak;\n\t\t}\n\n\tif (bypass_pll) {\n\t\tpll_q &= 0xf;\n\t\tsnd_soc_component_write(component, AIC3X_PLL_PROGA_REG, pll_q << PLLQ_SHIFT);\n\t\tsnd_soc_component_write(component, AIC3X_GPIOB_REG, CODEC_CLKIN_CLKDIV);\n\t\t \n\t\tsnd_soc_component_update_bits(component, AIC3X_PLL_PROGA_REG, PLL_ENABLE, 0);\n\n\t} else {\n\t\tsnd_soc_component_write(component, AIC3X_GPIOB_REG, CODEC_CLKIN_PLLDIV);\n\t\t \n\t\tsnd_soc_component_update_bits(component, AIC3X_PLL_PROGA_REG,\n\t\t\t\t    PLL_ENABLE, PLL_ENABLE);\n\t}\n\n\t \n\tdata = (LDAC2LCH | RDAC2RCH);\n\tdata |= (fsref == 44100) ? FSREF_44100 : FSREF_48000;\n\tif (params_rate(params) >= 64000)\n\t\tdata |= DUAL_RATE_MODE;\n\tsnd_soc_component_write(component, AIC3X_CODEC_DATAPATH_REG, data);\n\n\t \n\tdata = (fsref * 20) / params_rate(params);\n\tif (params_rate(params) < 64000)\n\t\tdata /= 2;\n\tdata /= 5;\n\tdata -= 2;\n\tdata |= (data << 4);\n\tsnd_soc_component_write(component, AIC3X_SAMPLE_RATE_SEL_REG, data);\n\n\tif (bypass_pll)\n\t\treturn 0;\n\n\t \n\n\tcodec_clk = (2048 * fsref) / (aic3x->sysclk / 1000);\n\n\tfor (r = 1; r <= 16; r++)\n\t\tfor (p = 1; p <= 8; p++) {\n\t\t\tfor (j = 4; j <= 55; j++) {\n\t\t\t\t \n\t\t\t\tint tmp_clk = (1000 * j * r) / p;\n\n\t\t\t\t \n\t\t\t\tif (abs(codec_clk - tmp_clk) <\n\t\t\t\t\tabs(codec_clk - last_clk)) {\n\t\t\t\t\tpll_j = j; pll_d = 0;\n\t\t\t\t\tpll_r = r; pll_p = p;\n\t\t\t\t\tlast_clk = tmp_clk;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (tmp_clk == codec_clk)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\n\t \n\tfor (p = 1; p <= 8; p++) {\n\t\tj = codec_clk * p / 1000;\n\n\t\tif (j < 4 || j > 11)\n\t\t\tcontinue;\n\n\t\t \n\t\td = ((2048 * p * fsref) - j * aic3x->sysclk)\n\t\t\t* 100 / (aic3x->sysclk/100);\n\n\t\tclk = (10000 * j + d) / (10 * p);\n\n\t\t \n\t\tif (abs(codec_clk - clk) < abs(codec_clk - last_clk)) {\n\t\t\tpll_j = j; pll_d = d; pll_r = 1; pll_p = p;\n\t\t\tlast_clk = clk;\n\t\t}\n\n\t\t \n\t\tif (clk == codec_clk)\n\t\t\tgoto found;\n\t}\n\n\tif (last_clk == 0) {\n\t\tprintk(KERN_ERR \"%s(): unable to setup PLL\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\nfound:\n\tsnd_soc_component_update_bits(component, AIC3X_PLL_PROGA_REG, PLLP_MASK, pll_p);\n\tsnd_soc_component_write(component, AIC3X_OVRF_STATUS_AND_PLLR_REG,\n\t\t      pll_r << PLLR_SHIFT);\n\tsnd_soc_component_write(component, AIC3X_PLL_PROGB_REG, pll_j << PLLJ_SHIFT);\n\tsnd_soc_component_write(component, AIC3X_PLL_PROGC_REG,\n\t\t      (pll_d >> 6) << PLLD_MSB_SHIFT);\n\tsnd_soc_component_write(component, AIC3X_PLL_PROGD_REG,\n\t\t      (pll_d & 0x3F) << PLLD_LSB_SHIFT);\n\n\treturn 0;\n}\n\nstatic int aic3x_prepare(struct snd_pcm_substream *substream,\n\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tint delay = 0;\n\tint width = aic3x->slot_width;\n\n\tif (!width)\n\t\twidth = substream->runtime->sample_bits;\n\n\t \n\tif (aic3x->dai_fmt == SND_SOC_DAIFMT_DSP_A)\n\t\tdelay += (aic3x->tdm_delay*width + 1);\n\telse if (aic3x->dai_fmt == SND_SOC_DAIFMT_DSP_B)\n\t\tdelay += aic3x->tdm_delay*width;\n\n\t \n\tsnd_soc_component_write(component, AIC3X_ASD_INTF_CTRLC, delay);\n\n\treturn 0;\n}\n\nstatic int aic3x_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 ldac_reg = snd_soc_component_read(component, LDAC_VOL) & ~MUTE_ON;\n\tu8 rdac_reg = snd_soc_component_read(component, RDAC_VOL) & ~MUTE_ON;\n\n\tif (mute) {\n\t\tsnd_soc_component_write(component, LDAC_VOL, ldac_reg | MUTE_ON);\n\t\tsnd_soc_component_write(component, RDAC_VOL, rdac_reg | MUTE_ON);\n\t} else {\n\t\tsnd_soc_component_write(component, LDAC_VOL, ldac_reg);\n\t\tsnd_soc_component_write(component, RDAC_VOL, rdac_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic3x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\n\t \n\tsnd_soc_component_update_bits(component, AIC3X_CLKGEN_CTRL_REG, PLLCLK_IN_MASK,\n\t\t\t\tclk_id << PLLCLK_IN_SHIFT);\n\tsnd_soc_component_update_bits(component, AIC3X_CLKGEN_CTRL_REG, CLKDIV_IN_MASK,\n\t\t\t\tclk_id << CLKDIV_IN_SHIFT);\n\n\taic3x->sysclk = freq;\n\treturn 0;\n}\n\nstatic int aic3x_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t     unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tu8 iface_areg, iface_breg;\n\n\tiface_areg = snd_soc_component_read(component, AIC3X_ASD_INTF_CTRLA) & 0x3f;\n\tiface_breg = snd_soc_component_read(component, AIC3X_ASD_INTF_CTRLB) & 0x3f;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\taic3x->master = 1;\n\t\tiface_areg |= BIT_CLK_MASTER | WORD_CLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\taic3x->master = 0;\n\t\tiface_areg &= ~(BIT_CLK_MASTER | WORD_CLK_MASTER);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\taic3x->master = 1;\n\t\tiface_areg |= BIT_CLK_MASTER;\n\t\tiface_areg &= ~WORD_CLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\taic3x->master = 1;\n\t\tiface_areg |= WORD_CLK_MASTER;\n\t\tiface_areg &= ~BIT_CLK_MASTER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\n\t\t       SND_SOC_DAIFMT_INV_MASK)) {\n\tcase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):\n\tcase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):\n\t\tiface_breg |= (0x01 << 6);\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):\n\t\tiface_breg |= (0x02 << 6);\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\n\t\tiface_breg |= (0x03 << 6);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\taic3x->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\t \n\tsnd_soc_component_write(component, AIC3X_ASD_INTF_CTRLA, iface_areg);\n\tsnd_soc_component_write(component, AIC3X_ASD_INTF_CTRLB, iface_breg);\n\n\treturn 0;\n}\n\nstatic int aic3x_set_dai_tdm_slot(struct snd_soc_dai *codec_dai,\n\t\t\t\t  unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t  int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tunsigned int lsb;\n\n\tif (tx_mask != rx_mask) {\n\t\tdev_err(component->dev, \"tx and rx masks must be symmetric\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(!tx_mask)) {\n\t\tdev_err(component->dev, \"tx and rx masks need to be non 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlsb = __ffs(tx_mask);\n\tif ((lsb + 1) != __fls(tx_mask)) {\n\t\tdev_err(component->dev, \"Invalid mask, slots must be adjacent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slot_width) {\n\tcase 16:\n\tcase 20:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported slot width %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\n\taic3x->tdm_delay = lsb;\n\taic3x->slot_width = slot_width;\n\n\t \n\tsnd_soc_component_update_bits(component, AIC3X_ASD_INTF_CTRLA,\n\t\t\t    DOUT_TRISTATE, DOUT_TRISTATE);\n\n\treturn 0;\n}\n\nstatic int aic3x_regulator_event(struct notifier_block *nb,\n\t\t\t\t unsigned long event, void *data)\n{\n\tstruct aic3x_disable_nb *disable_nb =\n\t\tcontainer_of(nb, struct aic3x_disable_nb, nb);\n\tstruct aic3x_priv *aic3x = disable_nb->aic3x;\n\n\tif (event & REGULATOR_EVENT_DISABLE) {\n\t\t \n\t\tif (aic3x->gpio_reset)\n\t\t\tgpiod_set_value(aic3x->gpio_reset, 1);\n\t\tregcache_mark_dirty(aic3x->regmap);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic3x_set_power(struct snd_soc_component *component, int power)\n{\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tunsigned int pll_c, pll_d;\n\tint ret;\n\n\tif (power) {\n\t\tret = regulator_bulk_enable(ARRAY_SIZE(aic3x->supplies),\n\t\t\t\t\t    aic3x->supplies);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\taic3x->power = 1;\n\n\t\tif (aic3x->gpio_reset) {\n\t\t\tudelay(1);\n\t\t\tgpiod_set_value(aic3x->gpio_reset, 0);\n\t\t}\n\n\t\t \n\t\tregcache_cache_only(aic3x->regmap, false);\n\t\tregcache_sync(aic3x->regmap);\n\n\t\t \n\t\tpll_c = snd_soc_component_read(component, AIC3X_PLL_PROGC_REG);\n\t\tpll_d = snd_soc_component_read(component, AIC3X_PLL_PROGD_REG);\n\t\tif (pll_c == aic3x_reg[AIC3X_PLL_PROGC_REG].def ||\n\t\t\tpll_d == aic3x_reg[AIC3X_PLL_PROGD_REG].def) {\n\t\t\tsnd_soc_component_write(component, AIC3X_PLL_PROGC_REG, pll_c);\n\t\t\tsnd_soc_component_write(component, AIC3X_PLL_PROGD_REG, pll_d);\n\t\t}\n\n\t\t \n\t\tmdelay(50);\n\t} else {\n\t\t \n\t\tsnd_soc_component_write(component, AIC3X_RESET, SOFT_RESET);\n\t\tregcache_mark_dirty(aic3x->regmap);\n\t\taic3x->power = 0;\n\t\t \n\t\tregcache_cache_only(aic3x->regmap, true);\n\t\tret = regulator_bulk_disable(ARRAY_SIZE(aic3x->supplies),\n\t\t\t\t\t     aic3x->supplies);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int aic3x_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY &&\n\t\t    aic3x->master) {\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, AIC3X_PLL_PROGA_REG,\n\t\t\t\t\t    PLL_ENABLE, PLL_ENABLE);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (!aic3x->power)\n\t\t\taic3x_set_power(component, 1);\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE &&\n\t\t    aic3x->master) {\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, AIC3X_PLL_PROGA_REG,\n\t\t\t\t\t    PLL_ENABLE, 0);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (aic3x->power)\n\t\t\taic3x_set_power(component, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define AIC3X_RATES\tSNDRV_PCM_RATE_8000_96000\n#define AIC3X_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops aic3x_dai_ops = {\n\t.hw_params\t= aic3x_hw_params,\n\t.prepare\t= aic3x_prepare,\n\t.mute_stream\t= aic3x_mute,\n\t.set_sysclk\t= aic3x_set_dai_sysclk,\n\t.set_fmt\t= aic3x_set_dai_fmt,\n\t.set_tdm_slot\t= aic3x_set_dai_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver aic3x_dai = {\n\t.name = \"tlv320aic3x-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = AIC3X_RATES,\n\t\t.formats = AIC3X_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = AIC3X_RATES,\n\t\t.formats = AIC3X_FORMATS,},\n\t.ops = &aic3x_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic void aic3x_mono_init(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_write(component, DACL1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\n\tsnd_soc_component_write(component, DACR1_2_MONOLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\n\n\t \n\tsnd_soc_component_update_bits(component, MONOLOPM_CTRL, UNMUTE, UNMUTE);\n\n\t \n\tsnd_soc_component_write(component, PGAL_2_MONOLOPM_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, PGAR_2_MONOLOPM_VOL, DEFAULT_VOL);\n\n\t \n\tsnd_soc_component_write(component, LINE2L_2_MONOLOPM_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, LINE2R_2_MONOLOPM_VOL, DEFAULT_VOL);\n}\n\n \nstatic int aic3x_init(struct snd_soc_component *component)\n{\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_write(component, AIC3X_PAGE_SELECT, PAGE0_SELECT);\n\tsnd_soc_component_write(component, AIC3X_RESET, SOFT_RESET);\n\n\t \n\tsnd_soc_component_write(component, LDAC_VOL, DEFAULT_VOL | MUTE_ON);\n\tsnd_soc_component_write(component, RDAC_VOL, DEFAULT_VOL | MUTE_ON);\n\n\t \n\tsnd_soc_component_write(component, DACL1_2_HPLOUT_VOL, DEFAULT_VOL | ROUTE_ON);\n\tsnd_soc_component_write(component, DACR1_2_HPROUT_VOL, DEFAULT_VOL | ROUTE_ON);\n\tsnd_soc_component_write(component, DACL1_2_HPLCOM_VOL, DEFAULT_VOL | ROUTE_ON);\n\tsnd_soc_component_write(component, DACR1_2_HPRCOM_VOL, DEFAULT_VOL | ROUTE_ON);\n\t \n\tsnd_soc_component_write(component, DACL1_2_LLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\n\tsnd_soc_component_write(component, DACR1_2_RLOPM_VOL, DEFAULT_VOL | ROUTE_ON);\n\n\t \n\tsnd_soc_component_update_bits(component, LLOPM_CTRL, UNMUTE, UNMUTE);\n\tsnd_soc_component_update_bits(component, RLOPM_CTRL, UNMUTE, UNMUTE);\n\tsnd_soc_component_update_bits(component, HPLOUT_CTRL, UNMUTE, UNMUTE);\n\tsnd_soc_component_update_bits(component, HPROUT_CTRL, UNMUTE, UNMUTE);\n\tsnd_soc_component_update_bits(component, HPLCOM_CTRL, UNMUTE, UNMUTE);\n\tsnd_soc_component_update_bits(component, HPRCOM_CTRL, UNMUTE, UNMUTE);\n\n\t \n\tsnd_soc_component_write(component, LADC_VOL, DEFAULT_GAIN);\n\tsnd_soc_component_write(component, RADC_VOL, DEFAULT_GAIN);\n\t \n\tsnd_soc_component_write(component, LINE1L_2_LADC_CTRL, 0x0);\n\tsnd_soc_component_write(component, LINE1R_2_RADC_CTRL, 0x0);\n\n\t \n\tsnd_soc_component_write(component, PGAL_2_HPLOUT_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, PGAR_2_HPROUT_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, PGAL_2_HPLCOM_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, PGAR_2_HPRCOM_VOL, DEFAULT_VOL);\n\t \n\tsnd_soc_component_write(component, PGAL_2_LLOPM_VOL, DEFAULT_VOL);\n\tsnd_soc_component_write(component, PGAR_2_RLOPM_VOL, DEFAULT_VOL);\n\n\t \n\tif (aic3x->model != AIC3X_MODEL_3104) {\n\t\t \n\t\tsnd_soc_component_write(component, LINE2L_2_HPLOUT_VOL, DEFAULT_VOL);\n\t\tsnd_soc_component_write(component, LINE2R_2_HPROUT_VOL, DEFAULT_VOL);\n\t\tsnd_soc_component_write(component, LINE2L_2_HPLCOM_VOL, DEFAULT_VOL);\n\t\tsnd_soc_component_write(component, LINE2R_2_HPRCOM_VOL, DEFAULT_VOL);\n\t\t \n\t\tsnd_soc_component_write(component, LINE2L_2_LLOPM_VOL, DEFAULT_VOL);\n\t\tsnd_soc_component_write(component, LINE2R_2_RLOPM_VOL, DEFAULT_VOL);\n\t}\n\n\tswitch (aic3x->model) {\n\tcase AIC3X_MODEL_3X:\n\tcase AIC3X_MODEL_33:\n\tcase AIC3X_MODEL_3106:\n\t\taic3x_mono_init(component);\n\t\tbreak;\n\tcase AIC3X_MODEL_3007:\n\t\tsnd_soc_component_write(component, CLASSD_CTRL, 0);\n\t\tbreak;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, HPOUT_SC, HPOUT_SC_OCMV_MASK,\n\t\t\t    aic3x->ocmv << HPOUT_SC_OCMV_SHIFT);\n\n\treturn 0;\n}\n\nstatic int aic3x_component_probe(struct snd_soc_component *component)\n{\n\tstruct aic3x_priv *aic3x = snd_soc_component_get_drvdata(component);\n\tint ret, i;\n\n\taic3x->component = component;\n\n\tfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++) {\n\t\taic3x->disable_nb[i].nb.notifier_call = aic3x_regulator_event;\n\t\taic3x->disable_nb[i].aic3x = aic3x;\n\t\tret = devm_regulator_register_notifier(\n\t\t\t\t\t\taic3x->supplies[i].consumer,\n\t\t\t\t\t\t&aic3x->disable_nb[i].nb);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to request regulator notifier: %d\\n\",\n\t\t\t\t ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tregcache_mark_dirty(aic3x->regmap);\n\taic3x_init(component);\n\n\tif (aic3x->setup) {\n\t\tif (aic3x->model != AIC3X_MODEL_3104) {\n\t\t\t \n\t\t\tsnd_soc_component_write(component, AIC3X_GPIO1_REG,\n\t\t\t\t      (aic3x->setup->gpio_func[0] & 0xf) << 4);\n\t\t\tsnd_soc_component_write(component, AIC3X_GPIO2_REG,\n\t\t\t\t      (aic3x->setup->gpio_func[1] & 0xf) << 4);\n\t\t} else {\n\t\t\tdev_warn(component->dev, \"GPIO functionality is not supported on tlv320aic3104\\n\");\n\t\t}\n\t}\n\n\tswitch (aic3x->model) {\n\tcase AIC3X_MODEL_3X:\n\tcase AIC3X_MODEL_33:\n\tcase AIC3X_MODEL_3106:\n\t\tsnd_soc_add_component_controls(component, aic3x_extra_snd_controls,\n\t\t\t\tARRAY_SIZE(aic3x_extra_snd_controls));\n\t\tsnd_soc_add_component_controls(component, aic3x_mono_controls,\n\t\t\t\tARRAY_SIZE(aic3x_mono_controls));\n\t\tbreak;\n\tcase AIC3X_MODEL_3007:\n\t\tsnd_soc_add_component_controls(component, aic3x_extra_snd_controls,\n\t\t\t\tARRAY_SIZE(aic3x_extra_snd_controls));\n\t\tsnd_soc_add_component_controls(component,\n\t\t\t\t&aic3x_classd_amp_gain_ctrl, 1);\n\t\tbreak;\n\tcase AIC3X_MODEL_3104:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (aic3x->micbias_vg) {\n\tcase AIC3X_MICBIAS_2_0V:\n\tcase AIC3X_MICBIAS_2_5V:\n\tcase AIC3X_MICBIAS_AVDDV:\n\t\tsnd_soc_component_update_bits(component, MICBIAS_CTRL,\n\t\t\t\t    MICBIAS_LEVEL_MASK,\n\t\t\t\t    (aic3x->micbias_vg) << MICBIAS_LEVEL_SHIFT);\n\t\tbreak;\n\tcase AIC3X_MICBIAS_OFF:\n\t\t \n\t\tbreak;\n\t}\n\n\taic3x_add_widgets(component);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_aic3x = {\n\t.set_bias_level\t\t= aic3x_set_bias_level,\n\t.probe\t\t\t= aic3x_component_probe,\n\t.controls\t\t= aic3x_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(aic3x_snd_controls),\n\t.dapm_widgets\t\t= aic3x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aic3x_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void aic3x_configure_ocmv(struct device *dev, struct aic3x_priv *aic3x)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 value;\n\tint dvdd, avdd;\n\n\tif (np && !of_property_read_u32(np, \"ai3x-ocmv\", &value)) {\n\t\t \n\t\tif (value <= 3) {\n\t\t\taic3x->ocmv = value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdvdd = regulator_get_voltage(aic3x->supplies[1].consumer);\n\tavdd = regulator_get_voltage(aic3x->supplies[2].consumer);\n\n\tif (avdd > 3600000 || dvdd > 1950000) {\n\t\tdev_warn(dev,\n\t\t\t \"Too high supply voltage(s) AVDD: %d, DVDD: %d\\n\",\n\t\t\t avdd, dvdd);\n\t} else if (avdd == 3600000 && dvdd == 1950000) {\n\t\taic3x->ocmv = HPOUT_SC_OCMV_1_8V;\n\t} else if (avdd > 3300000 && dvdd > 1800000) {\n\t\taic3x->ocmv = HPOUT_SC_OCMV_1_65V;\n\t} else if (avdd > 3000000 && dvdd > 1650000) {\n\t\taic3x->ocmv = HPOUT_SC_OCMV_1_5V;\n\t} else if (avdd >= 2700000 && dvdd >= 1525000) {\n\t\taic3x->ocmv = HPOUT_SC_OCMV_1_35V;\n\t} else {\n\t\tdev_warn(dev,\n\t\t\t \"Invalid supply voltage(s) AVDD: %d, DVDD: %d\\n\",\n\t\t\t avdd, dvdd);\n\t}\n}\n\n\nstatic const struct reg_sequence aic3007_class_d[] = {\n\t \n\t{ AIC3X_PAGE_SELECT, 0x0D },\n\t{ 0xD, 0x0D },\n\t{ 0x8, 0x5C },\n\t{ 0x8, 0x5D },\n\t{ 0x8, 0x5C },\n\t{ AIC3X_PAGE_SELECT, 0x00 },\n};\n\nint aic3x_probe(struct device *dev, struct regmap *regmap, kernel_ulong_t driver_data)\n{\n\tstruct aic3x_priv *aic3x;\n\tstruct aic3x_setup_data *ai3x_setup;\n\tstruct device_node *np = dev->of_node;\n\tint ret, i;\n\tu32 value;\n\n\taic3x = devm_kzalloc(dev, sizeof(struct aic3x_priv), GFP_KERNEL);\n\tif (!aic3x)\n\t\treturn -ENOMEM;\n\n\taic3x->regmap = regmap;\n\tif (IS_ERR(aic3x->regmap)) {\n\t\tret = PTR_ERR(aic3x->regmap);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(aic3x->regmap, true);\n\n\tdev_set_drvdata(dev, aic3x);\n\tif (np) {\n\t\tai3x_setup = devm_kzalloc(dev, sizeof(*ai3x_setup), GFP_KERNEL);\n\t\tif (!ai3x_setup)\n\t\t\treturn -ENOMEM;\n\n\t\tif (of_property_read_u32_array(np, \"ai3x-gpio-func\",\n\t\t\t\t\tai3x_setup->gpio_func, 2) >= 0) {\n\t\t\taic3x->setup = ai3x_setup;\n\t\t}\n\n\t\tif (!of_property_read_u32(np, \"ai3x-micbias-vg\", &value)) {\n\t\t\tswitch (value) {\n\t\t\tcase 1 :\n\t\t\t\taic3x->micbias_vg = AIC3X_MICBIAS_2_0V;\n\t\t\t\tbreak;\n\t\t\tcase 2 :\n\t\t\t\taic3x->micbias_vg = AIC3X_MICBIAS_2_5V;\n\t\t\t\tbreak;\n\t\t\tcase 3 :\n\t\t\t\taic3x->micbias_vg = AIC3X_MICBIAS_AVDDV;\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\taic3x->micbias_vg = AIC3X_MICBIAS_OFF;\n\t\t\t\tdev_err(dev, \"Unsuitable MicBias voltage \"\n\t\t\t\t\t\t\t\"found in DT\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\taic3x->micbias_vg = AIC3X_MICBIAS_OFF;\n\t\t}\n\t}\n\n\taic3x->model = driver_data;\n\n\taic3x->gpio_reset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(aic3x->gpio_reset);\n\tif (ret) {\n\t\tif (ret != -EBUSY)\n\t\t\treturn ret;\n\n\t\t \n\t\taic3x->gpio_reset = devm_gpiod_get(dev, \"reset\",\n\t\t\t\tGPIOD_ASIS | GPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\t\tret = PTR_ERR_OR_ZERO(aic3x->gpio_reset);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taic3x->shared_reset = true;\n\t}\n\n\tgpiod_set_consumer_name(aic3x->gpio_reset, \"tlv320aic3x reset\");\n\n\tfor (i = 0; i < ARRAY_SIZE(aic3x->supplies); i++)\n\t\taic3x->supplies[i].supply = aic3x_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(aic3x->supplies),\n\t\t\t\t      aic3x->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\taic3x_configure_ocmv(dev, aic3x);\n\n\tif (aic3x->model == AIC3X_MODEL_3007) {\n\t\tret = regmap_register_patch(aic3x->regmap, aic3007_class_d,\n\t\t\t\t\t    ARRAY_SIZE(aic3007_class_d));\n\t\tif (ret != 0)\n\t\t\tdev_err(dev, \"Failed to init class D: %d\\n\", ret);\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &soc_component_dev_aic3x, &aic3x_dai, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(aic3x_probe);\n\nvoid aic3x_remove(struct device *dev)\n{\n\tstruct aic3x_priv *aic3x = dev_get_drvdata(dev);\n\n\t \n\tif (aic3x->gpio_reset && !aic3x->shared_reset)\n\t\tgpiod_set_value(aic3x->gpio_reset, 1);\n}\nEXPORT_SYMBOL(aic3x_remove);\n\nMODULE_DESCRIPTION(\"ASoC TLV320AIC3X codec driver\");\nMODULE_AUTHOR(\"Vladimir Barinov\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}