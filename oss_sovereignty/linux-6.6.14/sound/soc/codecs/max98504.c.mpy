{
  "module_name": "max98504.c",
  "hash_id": "b3fcbc78fc849258b3c27265e5d9c69a426ff62b8a7a4edc88c2e1dd0502fad6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98504.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <sound/soc.h>\n\n#include \"max98504.h\"\n\nstatic const char * const max98504_supply_names[] = {\n\t\"DVDD\",\n\t\"DIOVDD\",\n\t\"PVDD\",\n};\n#define MAX98504_NUM_SUPPLIES ARRAY_SIZE(max98504_supply_names)\n\nstruct max98504_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[MAX98504_NUM_SUPPLIES];\n\tunsigned int pcm_rx_channels;\n\tbool brownout_enable;\n\tunsigned int brownout_threshold;\n\tunsigned int brownout_attenuation;\n\tunsigned int brownout_attack_hold;\n\tunsigned int brownout_timed_hold;\n\tunsigned int brownout_release_rate;\n};\n\nstatic struct reg_default max98504_reg_defaults[] = {\n\t{ 0x01,\t0},\n\t{ 0x02,\t0},\n\t{ 0x03,\t0},\n\t{ 0x04,\t0},\n\t{ 0x10, 0},\n\t{ 0x11, 0},\n\t{ 0x12, 0},\n\t{ 0x13, 0},\n\t{ 0x14, 0},\n\t{ 0x15, 0},\n\t{ 0x16, 0},\n\t{ 0x17, 0},\n\t{ 0x18, 0},\n\t{ 0x19, 0},\n\t{ 0x1A, 0},\n\t{ 0x20, 0},\n\t{ 0x21, 0},\n\t{ 0x22, 0},\n\t{ 0x23, 0},\n\t{ 0x24, 0},\n\t{ 0x25, 0},\n\t{ 0x26, 0},\n\t{ 0x27, 0},\n\t{ 0x28, 0},\n\t{ 0x30, 0},\n\t{ 0x31, 0},\n\t{ 0x32, 0},\n\t{ 0x33, 0},\n\t{ 0x34, 0},\n\t{ 0x35, 0},\n\t{ 0x36, 0},\n\t{ 0x37, 0},\n\t{ 0x38, 0},\n\t{ 0x39, 0},\n\t{ 0x40, 0},\n\t{ 0x41, 0},\n};\n\nstatic bool max98504_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98504_INTERRUPT_STATUS:\n\tcase MAX98504_INTERRUPT_FLAGS:\n\tcase MAX98504_INTERRUPT_FLAG_CLEARS:\n\tcase MAX98504_WATCHDOG_CLEAR:\n\tcase MAX98504_GLOBAL_ENABLE:\n\tcase MAX98504_SOFTWARE_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98504_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98504_SOFTWARE_RESET:\n\tcase MAX98504_WATCHDOG_CLEAR:\n\tcase MAX98504_INTERRUPT_FLAG_CLEARS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int max98504_pcm_rx_ev(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_write(max98504->regmap, MAX98504_PCM_RX_ENABLE,\n\t\t\t     max98504->pcm_rx_channels);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_write(max98504->regmap, MAX98504_PCM_RX_ENABLE, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int max98504_component_probe(struct snd_soc_component *c)\n{\n\tstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\n\tstruct regmap *map = max98504->regmap;\n\tint ret;\n\n\tret = regulator_bulk_enable(MAX98504_NUM_SUPPLIES, max98504->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregmap_write(map, MAX98504_SOFTWARE_RESET, 0x1);\n\tmsleep(20);\n\n\tif (!max98504->brownout_enable)\n\t\treturn 0;\n\n\tregmap_write(map, MAX98504_PVDD_BROWNOUT_ENABLE, 0x1);\n\n\tregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_1,\n\t\t     (max98504->brownout_threshold & 0x1f) << 3 |\n\t\t     (max98504->brownout_attenuation & 0x3));\n\n\tregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_2,\n\t\t     max98504->brownout_attack_hold & 0xff);\n\n\tregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_3,\n\t\t     max98504->brownout_timed_hold & 0xff);\n\n\tregmap_write(map, MAX98504_PVDD_BROWNOUT_CONFIG_4,\n\t\t     max98504->brownout_release_rate & 0xff);\n\n\treturn 0;\n}\n\nstatic void max98504_component_remove(struct snd_soc_component *c)\n{\n\tstruct max98504_priv *max98504 = snd_soc_component_get_drvdata(c);\n\n\tregulator_bulk_disable(MAX98504_NUM_SUPPLIES, max98504->supplies);\n}\n\nstatic const char *spk_source_mux_text[] = {\n\t\"PCM Monomix\", \"Analog In\", \"PDM Left\", \"PDM Right\"\n};\n\nstatic const struct soc_enum spk_source_mux_enum =\n\tSOC_ENUM_SINGLE(MAX98504_SPEAKER_SOURCE_SELECT,\n\t\t\t0, ARRAY_SIZE(spk_source_mux_text),\n\t\t\tspk_source_mux_text);\n\nstatic const struct snd_kcontrol_new spk_source_mux =\n\tSOC_DAPM_ENUM(\"SPK Source\", spk_source_mux_enum);\n\nstatic const struct snd_soc_dapm_route max98504_dapm_routes[] = {\n\t{ \"SPKOUT\", NULL, \"Global Enable\" },\n\t{ \"SPK Source\", \"PCM Monomix\", \"DAC PCM\" },\n\t{ \"SPK Source\", \"Analog In\", \"AIN\" },\n\t{ \"SPK Source\", \"PDM Left\", \"DAC PDM\" },\n\t{ \"SPK Source\", \"PDM Right\", \"DAC PDM\" },\n};\n\nstatic const struct snd_soc_dapm_widget max98504_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Global Enable\", MAX98504_GLOBAL_ENABLE,\n\t\t0, 0, NULL, 0),\n\tSND_SOC_DAPM_INPUT(\"AIN\"),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2OUTL\", \"AIF2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2OUTR\", \"AIF2 Capture\", 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC PCM\", NULL, SND_SOC_NOPM, 0, 0,\n\t\tmax98504_pcm_rx_ev,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_DAC(\"DAC PDM\", NULL, MAX98504_PDM_RX_ENABLE, 0, 0),\n\tSND_SOC_DAPM_MUX(\"SPK Source\", SND_SOC_NOPM, 0, 0, &spk_source_mux),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_spk, \"SPKOUT\",\n\t\tMAX98504_SPEAKER_ENABLE, 0, 1, 1, 0),\n};\n\nstatic int max98504_set_tdm_slot(struct snd_soc_dai *dai,\n\t\tunsigned int tx_mask, unsigned int rx_mask,\n\t\tint slots, int slot_width)\n{\n\tstruct max98504_priv *max98504 = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *map = max98504->regmap;\n\n\n\tswitch (dai->id) {\n\tcase MAX98504_DAI_ID_PCM:\n\t\tregmap_write(map, MAX98504_PCM_TX_ENABLE, tx_mask);\n\t\tmax98504->pcm_rx_channels = rx_mask;\n\t\tbreak;\n\n\tcase MAX98504_DAI_ID_PDM:\n\t\tregmap_write(map, MAX98504_PDM_TX_ENABLE, tx_mask);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn 0;\n}\nstatic int max98504_set_channel_map(struct snd_soc_dai *dai,\n\t\tunsigned int tx_num, unsigned int *tx_slot,\n\t\tunsigned int rx_num, unsigned int *rx_slot)\n{\n\tstruct max98504_priv *max98504 = snd_soc_dai_get_drvdata(dai);\n\tstruct regmap *map = max98504->regmap;\n\tunsigned int i, sources = 0;\n\n\tfor (i = 0; i < tx_num; i++)\n\t\tif (tx_slot[i])\n\t\t\tsources |= (1 << i);\n\n\tswitch (dai->id) {\n\tcase MAX98504_DAI_ID_PCM:\n\t\tregmap_write(map, MAX98504_PCM_TX_CHANNEL_SOURCES,\n\t\t\t     sources);\n\t\tbreak;\n\n\tcase MAX98504_DAI_ID_PDM:\n\t\tregmap_write(map, MAX98504_PDM_TX_CONTROL, sources);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\tregmap_write(map, MAX98504_MEASUREMENT_ENABLE, sources ? 0x3 : 0x01);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops max98504_dai_ops = {\n\t.set_tdm_slot\t\t= max98504_set_tdm_slot,\n\t.set_channel_map\t= max98504_set_channel_map,\n};\n\n#define MAX98504_FORMATS\t(SNDRV_PCM_FMTBIT_S8|SNDRV_PCM_FMTBIT_S16_LE|\\\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE|SNDRV_PCM_FMTBIT_S32_LE)\n#define MAX98504_PDM_RATES\t(SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|\\\n\t\t\t\tSNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_44100|\\\n\t\t\t\tSNDRV_PCM_RATE_48000|SNDRV_PCM_RATE_88200|\\\n\t\t\t\tSNDRV_PCM_RATE_96000)\n\nstatic struct snd_soc_dai_driver max98504_dai[] = {\n\t \n\t{\n\t\t.name = \"max98504-aif2\",\n\t\t.id = MAX98504_DAI_ID_PDM,\n\t\t.playback = {\n\t\t\t.stream_name\t= \"AIF2 Playback\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 2,\n\t\t\t.rates\t\t= MAX98504_PDM_RATES,\n\t\t\t.formats\t= MAX98504_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name\t= \"AIF2 Capture\",\n\t\t\t.channels_min\t= 1,\n\t\t\t.channels_max\t= 2,\n\t\t\t.rates\t\t= MAX98504_PDM_RATES,\n\t\t\t.formats\t= MAX98504_FORMATS,\n\t\t},\n\t\t.ops = &max98504_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver max98504_component_driver = {\n\t.probe\t\t\t= max98504_component_probe,\n\t.remove\t\t\t= max98504_component_remove,\n\t.dapm_widgets\t\t= max98504_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98504_dapm_widgets),\n\t.dapm_routes\t\t= max98504_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98504_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98504_regmap = {\n\t.reg_bits\t\t= 16,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= MAX98504_MAX_REGISTER,\n\t.reg_defaults\t\t= max98504_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(max98504_reg_defaults),\n\t.volatile_reg\t\t= max98504_volatile_register,\n\t.readable_reg\t\t= max98504_readable_register,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic int max98504_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct max98504_priv *max98504;\n\tint i, ret;\n\n\tmax98504 = devm_kzalloc(dev, sizeof(*max98504), GFP_KERNEL);\n\tif (!max98504)\n\t\treturn -ENOMEM;\n\n\tif (node) {\n\t\tif (!of_property_read_u32(node, \"maxim,brownout-threshold\",\n\t\t\t\t\t&max98504->brownout_threshold))\n\t\t\tmax98504->brownout_enable = true;\n\n\t\tof_property_read_u32(node, \"maxim,brownout-attenuation\",\n\t\t\t\t\t&max98504->brownout_attenuation);\n\t\tof_property_read_u32(node, \"maxim,brownout-attack-hold-ms\",\n\t\t\t\t\t&max98504->brownout_attack_hold);\n\t\tof_property_read_u32(node, \"maxim,brownout-timed-hold-ms\",\n\t\t\t\t\t&max98504->brownout_timed_hold);\n\t\tof_property_read_u32(node, \"maxim,brownout-release-rate-ms\",\n\t\t\t\t\t&max98504->brownout_release_rate);\n\t}\n\n\tmax98504->regmap = devm_regmap_init_i2c(client, &max98504_regmap);\n\tif (IS_ERR(max98504->regmap)) {\n\t\tret = PTR_ERR(max98504->regmap);\n\t\tdev_err(&client->dev, \"regmap initialization failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < MAX98504_NUM_SUPPLIES; i++)\n\t\tmax98504->supplies[i].supply = max98504_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, MAX98504_NUM_SUPPLIES,\n\t\t\t\t      max98504->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti2c_set_clientdata(client, max98504);\n\n\treturn devm_snd_soc_register_component(dev, &max98504_component_driver,\n\t\t\t\tmax98504_dai, ARRAY_SIZE(max98504_dai));\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98504_of_match[] = {\n\t{ .compatible = \"maxim,max98504\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, max98504_of_match);\n#endif\n\nstatic const struct i2c_device_id max98504_i2c_id[] = {\n\t{ \"max98504\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max98504_i2c_id);\n\nstatic struct i2c_driver max98504_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98504\",\n\t\t.of_match_table = of_match_ptr(max98504_of_match),\n\t},\n\t.probe = max98504_i2c_probe,\n\t.id_table = max98504_i2c_id,\n};\nmodule_i2c_driver(max98504_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC MAX98504 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}