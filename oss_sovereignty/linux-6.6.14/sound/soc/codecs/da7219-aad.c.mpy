{
  "module_name": "da7219-aad.c",
  "hash_id": "cff70f9615616e7e26630b35461edd41e3a92ec366b31c81b5134267688d9901",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/da7219-aad.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/property.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/da7219.h>\n\n#include \"da7219.h\"\n#include \"da7219-aad.h\"\n\n\n \n\nvoid da7219_aad_jack_det(struct snd_soc_component *component, struct snd_soc_jack *jack)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tda7219->aad->jack = jack;\n\tda7219->aad->jack_inserted = false;\n\n\t \n\tsnd_soc_jack_report(jack, 0, DA7219_AAD_REPORT_ALL_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t    DA7219_ACCDET_EN_MASK,\n\t\t\t    (jack ? DA7219_ACCDET_EN_MASK : 0));\n}\n\n \n\nstatic void da7219_aad_btn_det_work(struct work_struct *work)\n{\n\tstruct da7219_aad_priv *da7219_aad =\n\t\tcontainer_of(work, struct da7219_aad_priv, btn_det_work);\n\tstruct snd_soc_component *component = da7219_aad->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tu8 statusa, micbias_ctrl;\n\tbool micbias_up = false;\n\tint retries = 0;\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t    DA7219_HP_L_AMP_OE_MASK,\n\t\t\t    DA7219_HP_L_AMP_OE_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t    DA7219_HP_R_AMP_OE_MASK,\n\t\t\t    DA7219_HP_R_AMP_OE_MASK);\n\n\t \n\tsnd_soc_dapm_force_enable_pin(dapm, \"Mic Bias\");\n\tsnd_soc_dapm_sync(dapm);\n\n\tdo {\n\t\tstatusa = snd_soc_component_read(component, DA7219_ACCDET_STATUS_A);\n\t\tif (statusa & DA7219_MICBIAS_UP_STS_MASK)\n\t\t\tmicbias_up = true;\n\t\telse if (retries++ < DA7219_AAD_MICBIAS_CHK_RETRIES)\n\t\t\tmsleep(DA7219_AAD_MICBIAS_CHK_DELAY);\n\t} while ((!micbias_up) && (retries < DA7219_AAD_MICBIAS_CHK_RETRIES));\n\n\tif (retries >= DA7219_AAD_MICBIAS_CHK_RETRIES)\n\t\tdev_warn(component->dev, \"Mic bias status check timed out\");\n\n\tda7219->micbias_on_event = true;\n\n\t \n\tif (da7219_aad->micbias_pulse_lvl && da7219_aad->micbias_pulse_time) {\n\t\t \n\t\tmicbias_ctrl = snd_soc_component_read(component, DA7219_MICBIAS_CTRL);\n\t\tsnd_soc_component_update_bits(component, DA7219_MICBIAS_CTRL,\n\t\t\t\t    DA7219_MICBIAS1_LEVEL_MASK,\n\t\t\t\t    da7219_aad->micbias_pulse_lvl);\n\t\tmsleep(da7219_aad->micbias_pulse_time);\n\t\tsnd_soc_component_write(component, DA7219_MICBIAS_CTRL, micbias_ctrl);\n\n\t}\n\n\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t    DA7219_BUTTON_CONFIG_MASK,\n\t\t\t    da7219_aad->btn_cfg);\n}\n\nstatic void da7219_aad_hptest_work(struct work_struct *work)\n{\n\tstruct da7219_aad_priv *da7219_aad =\n\t\tcontainer_of(work, struct da7219_aad_priv, hptest_work);\n\tstruct snd_soc_component *component = da7219_aad->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\t__le16 tonegen_freq_hptest;\n\tu8 pll_srm_sts, pll_ctrl, gain_ramp_ctrl, accdet_cfg8;\n\tint report = 0, ret;\n\n\t \n\tsnd_soc_dapm_mutex_lock(dapm);\n\tmutex_lock(&da7219->ctrl_lock);\n\tmutex_lock(&da7219->pll_lock);\n\n\t \n\tif (da7219->mclk) {\n\t\tret = clk_prepare_enable(da7219->mclk);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to enable mclk - %d\\n\", ret);\n\t\t\tmutex_unlock(&da7219->pll_lock);\n\t\t\tmutex_unlock(&da7219->ctrl_lock);\n\t\t\tsnd_soc_dapm_mutex_unlock(dapm);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tpll_srm_sts = snd_soc_component_read(component, DA7219_PLL_SRM_STS);\n\tif (pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) {\n\t\ttonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ);\n\n\t\tpll_ctrl = snd_soc_component_read(component, DA7219_PLL_CTRL);\n\t\tif ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS)\n\t\t\tda7219_set_pll(component, DA7219_SYSCLK_PLL,\n\t\t\t\t       DA7219_PLL_FREQ_OUT_98304);\n\t} else {\n\t\ttonegen_freq_hptest = cpu_to_le16(DA7219_AAD_HPTEST_RAMP_FREQ_INT_OSC);\n\t}\n\n\t \n\tgain_ramp_ctrl = snd_soc_component_read(component, DA7219_GAIN_RAMP_CTRL);\n\tsnd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_X8);\n\n\t \n\tregcache_cache_bypass(da7219->regmap, true);\n\n\t \n\tsnd_soc_component_write(component, DA7219_TONE_GEN_CFG1, 0);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_8,\n\t\t\t    DA7219_HPTEST_EN_MASK | DA7219_HPTEST_RES_SEL_MASK,\n\t\t\t    DA7219_HPTEST_EN_MASK |\n\t\t\t    DA7219_HPTEST_RES_SEL_1KOHMS);\n\n\t \n\tsnd_soc_component_write(component, DA7219_DAC_L_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);\n\tsnd_soc_component_write(component, DA7219_DAC_R_GAIN, DA7219_DAC_DIGITAL_GAIN_0DB);\n\tsnd_soc_component_write(component, DA7219_HP_L_GAIN, DA7219_HP_AMP_GAIN_0DB);\n\tsnd_soc_component_write(component, DA7219_HP_R_GAIN, DA7219_HP_AMP_GAIN_0DB);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_DAC_FILTERS1, DA7219_HPF_MODE_MASK,\n\t\t\t    0);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_FILTERS4, DA7219_DAC_EQ_EN_MASK,\n\t\t\t    0);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_FILTERS5,\n\t\t\t    DA7219_DAC_SOFTMUTE_EN_MASK, 0);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_CP_CTRL, DA7219_CP_EN_MASK,\n\t\t\t    DA7219_CP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_DIG_ROUTING_DAC,\n\t\t\t    DA7219_DAC_L_SRC_MASK | DA7219_DAC_R_SRC_MASK,\n\t\t\t    DA7219_DAC_L_SRC_TONEGEN |\n\t\t\t    DA7219_DAC_R_SRC_TONEGEN);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_L_CTRL,\n\t\t\t    DA7219_DAC_L_EN_MASK | DA7219_DAC_L_MUTE_EN_MASK,\n\t\t\t    DA7219_DAC_L_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_R_CTRL,\n\t\t\t    DA7219_DAC_R_EN_MASK | DA7219_DAC_R_MUTE_EN_MASK,\n\t\t\t    DA7219_DAC_R_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_MIXOUT_L_SELECT,\n\t\t\t    DA7219_MIXOUT_L_MIX_SELECT_MASK,\n\t\t\t    DA7219_MIXOUT_L_MIX_SELECT_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_MIXOUT_R_SELECT,\n\t\t\t    DA7219_MIXOUT_R_MIX_SELECT_MASK,\n\t\t\t    DA7219_MIXOUT_R_MIX_SELECT_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_DROUTING_ST_OUTFILT_1L,\n\t\t\t    DA7219_OUTFILT_ST_1L_SRC_MASK,\n\t\t\t    DA7219_DMIX_ST_SRC_OUTFILT1L);\n\tsnd_soc_component_update_bits(component, DA7219_DROUTING_ST_OUTFILT_1R,\n\t\t\t    DA7219_OUTFILT_ST_1R_SRC_MASK,\n\t\t\t    DA7219_DMIX_ST_SRC_OUTFILT1R);\n\tsnd_soc_component_update_bits(component, DA7219_MIXOUT_L_CTRL,\n\t\t\t    DA7219_MIXOUT_L_AMP_EN_MASK,\n\t\t\t    DA7219_MIXOUT_L_AMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_MIXOUT_R_CTRL,\n\t\t\t    DA7219_MIXOUT_R_AMP_EN_MASK,\n\t\t\t    DA7219_MIXOUT_R_AMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK,\n\t\t\t    DA7219_HP_L_AMP_OE_MASK | DA7219_HP_L_AMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK,\n\t\t\t    DA7219_HP_R_AMP_OE_MASK | DA7219_HP_R_AMP_EN_MASK);\n\tmsleep(DA7219_SETTLING_DELAY);\n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t    DA7219_HP_L_AMP_MUTE_EN_MASK |\n\t\t\t    DA7219_HP_L_AMP_MIN_GAIN_EN_MASK, 0);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t    DA7219_HP_R_AMP_MUTE_EN_MASK |\n\t\t\t    DA7219_HP_R_AMP_MIN_GAIN_EN_MASK, 0);\n\n\t \n\tif (!(pll_srm_sts & DA7219_PLL_SRM_STS_MCLK))\n\t\tmsleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);\n\n\t \n\tsnd_soc_component_write(component, DA7219_TONE_GEN_ON_PER, DA7219_BEEP_ON_PER_MASK);\n\tregmap_raw_write(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,\n\t\t\t &tonegen_freq_hptest, sizeof(tonegen_freq_hptest));\n\tsnd_soc_component_update_bits(component, DA7219_TONE_GEN_CFG2,\n\t\t\t    DA7219_SWG_SEL_MASK | DA7219_TONE_GEN_GAIN_MASK,\n\t\t\t    DA7219_SWG_SEL_SRAMP |\n\t\t\t    DA7219_TONE_GEN_GAIN_MINUS_15DB);\n\tsnd_soc_component_write(component, DA7219_TONE_GEN_CFG1, DA7219_START_STOPN_MASK);\n\n\tmsleep(DA7219_AAD_HPTEST_PERIOD);\n\n\t \n\taccdet_cfg8 = snd_soc_component_read(component, DA7219_ACCDET_CONFIG_8);\n\tif (accdet_cfg8 & DA7219_HPTEST_COMP_MASK)\n\t\treport |= SND_JACK_HEADPHONE;\n\telse\n\t\treport |= SND_JACK_LINEOUT;\n\n\t \n\tsnd_soc_component_write(component, DA7219_TONE_GEN_CFG1, 0);\n\n\tmsleep(DA7219_AAD_HPTEST_PERIOD);\n\n\t \n\tregcache_mark_dirty(da7219->regmap);\n\tregcache_sync_region(da7219->regmap, DA7219_HP_L_CTRL,\n\t\t\t     DA7219_HP_R_CTRL);\n\tmsleep(DA7219_SETTLING_DELAY);\n\tregcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_CTRL,\n\t\t\t     DA7219_MIXOUT_R_CTRL);\n\tregcache_sync_region(da7219->regmap, DA7219_DROUTING_ST_OUTFILT_1L,\n\t\t\t     DA7219_DROUTING_ST_OUTFILT_1R);\n\tregcache_sync_region(da7219->regmap, DA7219_MIXOUT_L_SELECT,\n\t\t\t     DA7219_MIXOUT_R_SELECT);\n\tregcache_sync_region(da7219->regmap, DA7219_DAC_L_CTRL,\n\t\t\t     DA7219_DAC_R_CTRL);\n\tregcache_sync_region(da7219->regmap, DA7219_DIG_ROUTING_DAC,\n\t\t\t     DA7219_DIG_ROUTING_DAC);\n\tregcache_sync_region(da7219->regmap, DA7219_CP_CTRL, DA7219_CP_CTRL);\n\tregcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS5,\n\t\t\t     DA7219_DAC_FILTERS5);\n\tregcache_sync_region(da7219->regmap, DA7219_DAC_FILTERS4,\n\t\t\t     DA7219_DAC_FILTERS1);\n\tregcache_sync_region(da7219->regmap, DA7219_HP_L_GAIN,\n\t\t\t     DA7219_HP_R_GAIN);\n\tregcache_sync_region(da7219->regmap, DA7219_DAC_L_GAIN,\n\t\t\t     DA7219_DAC_R_GAIN);\n\tregcache_sync_region(da7219->regmap, DA7219_TONE_GEN_ON_PER,\n\t\t\t     DA7219_TONE_GEN_ON_PER);\n\tregcache_sync_region(da7219->regmap, DA7219_TONE_GEN_FREQ1_L,\n\t\t\t     DA7219_TONE_GEN_FREQ1_U);\n\tregcache_sync_region(da7219->regmap, DA7219_TONE_GEN_CFG1,\n\t\t\t     DA7219_TONE_GEN_CFG2);\n\n\tregcache_cache_bypass(da7219->regmap, false);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_8,\n\t\t\t    DA7219_HPTEST_EN_MASK, 0);\n\n\t \n\tif (!(pll_srm_sts & DA7219_PLL_SRM_STS_MCLK))\n\t\tmsleep(DA7219_AAD_HPTEST_INT_OSC_PATH_DELAY);\n\n\t \n\tsnd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL, gain_ramp_ctrl);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL, DA7219_HP_L_AMP_OE_MASK,\n\t\t\t    DA7219_HP_L_AMP_OE_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL, DA7219_HP_R_AMP_OE_MASK,\n\t\t\t    DA7219_HP_R_AMP_OE_MASK);\n\n\t \n\tif ((pll_srm_sts & DA7219_PLL_SRM_STS_MCLK) &&\n\t    ((pll_ctrl & DA7219_PLL_MODE_MASK) == DA7219_PLL_MODE_BYPASS))\n\t\tda7219_set_pll(component, DA7219_SYSCLK_MCLK, 0);\n\n\t \n\tif (da7219->mclk)\n\t\tclk_disable_unprepare(da7219->mclk);\n\n\tmutex_unlock(&da7219->pll_lock);\n\tmutex_unlock(&da7219->ctrl_lock);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\t \n\tif (da7219_aad->jack_inserted)\n\t\tsnd_soc_jack_report(da7219_aad->jack, report,\n\t\t\t\t    SND_JACK_HEADSET | SND_JACK_LINEOUT);\n}\n\nstatic void da7219_aad_jack_det_work(struct work_struct *work)\n{\n\tstruct da7219_aad_priv *da7219_aad =\n\t\tcontainer_of(work, struct da7219_aad_priv, jack_det_work.work);\n\tstruct snd_soc_component *component = da7219_aad->component;\n\n\t \n\tsnd_soc_component_update_bits(component, 0xFB, 0x01, 0x01);\n}\n\n \n\nstatic irqreturn_t da7219_aad_irq_thread(int irq, void *data)\n{\n\tstruct da7219_aad_priv *da7219_aad = data;\n\tstruct snd_soc_component *component = da7219_aad->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tu8 events[DA7219_AAD_IRQ_REG_MAX];\n\tu8 statusa;\n\tint i, ret, report = 0, mask = 0;\n\n\t \n\tret = regmap_bulk_read(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,\n\t\t\t       events, DA7219_AAD_IRQ_REG_MAX);\n\tif (ret) {\n\t\tdev_warn_ratelimited(component->dev, \"Failed to read IRQ events: %d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!events[DA7219_AAD_IRQ_REG_A] && !events[DA7219_AAD_IRQ_REG_B])\n\t\treturn IRQ_NONE;\n\n\t \n\tstatusa = snd_soc_component_read(component, DA7219_ACCDET_STATUS_A);\n\n\tif (events[DA7219_AAD_IRQ_REG_A] & DA7219_E_JACK_INSERTED_MASK) {\n\t\tu8 srm_st;\n\t\tint delay = 0;\n\n\t\tsrm_st = snd_soc_component_read(component,\n\t\t\t\t\tDA7219_PLL_SRM_STS) & DA7219_PLL_SRM_STS_MCLK;\n\t\tdelay = (da7219_aad->gnd_switch_delay * ((srm_st == 0x0) ? 2 : 1) - 2);\n\t\tqueue_delayed_work(da7219_aad->aad_wq,\n\t\t\t\t\t\t\t&da7219_aad->jack_det_work,\n\t\t\t\t\t\t\tmsecs_to_jiffies(delay));\n\t}\n\n\t \n\tregmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_EVENT_A,\n\t\t\t  events, DA7219_AAD_IRQ_REG_MAX);\n\n\tdev_dbg(component->dev, \"IRQ events = 0x%x|0x%x, status = 0x%x\\n\",\n\t\tevents[DA7219_AAD_IRQ_REG_A], events[DA7219_AAD_IRQ_REG_B],\n\t\tstatusa);\n\n\tif (statusa & DA7219_JACK_INSERTION_STS_MASK) {\n\t\t \n\t\tif (events[DA7219_AAD_IRQ_REG_A] &\n\t\t    DA7219_E_JACK_INSERTED_MASK) {\n\t\t\treport |= SND_JACK_MECHANICAL;\n\t\t\tmask |= SND_JACK_MECHANICAL;\n\t\t\tda7219_aad->jack_inserted = true;\n\t\t}\n\n\t\t \n\t\tif (events[DA7219_AAD_IRQ_REG_A] &\n\t\t    DA7219_E_JACK_DETECT_COMPLETE_MASK) {\n\t\t\t \n\n\t\t\tcancel_delayed_work_sync(&da7219_aad->jack_det_work);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, 0xFB, 0x01, 0x00);\n\n\t\t\tif (statusa & DA7219_JACK_TYPE_STS_MASK) {\n\t\t\t\treport |= SND_JACK_HEADSET;\n\t\t\t\tmask |=\tSND_JACK_HEADSET | SND_JACK_LINEOUT;\n\t\t\t\tqueue_work(da7219_aad->aad_wq, &da7219_aad->btn_det_work);\n\t\t\t} else {\n\t\t\t\tqueue_work(da7219_aad->aad_wq, &da7219_aad->hptest_work);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (statusa & DA7219_JACK_TYPE_STS_MASK) {\n\t\t\tfor (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {\n\t\t\t\t \n\t\t\t\tif (events[DA7219_AAD_IRQ_REG_B] &\n\t\t\t\t    (DA7219_E_BUTTON_A_PRESSED_MASK << i)) {\n\t\t\t\t\treport |= SND_JACK_BTN_0 >> i;\n\t\t\t\t\tmask |= SND_JACK_BTN_0 >> i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnd_soc_jack_report(da7219_aad->jack, report, mask);\n\n\t\t\tfor (i = 0; i < DA7219_AAD_MAX_BUTTONS; ++i) {\n\t\t\t\t \n\t\t\t\tif (events[DA7219_AAD_IRQ_REG_B] &\n\t\t\t\t    (DA7219_E_BUTTON_A_RELEASED_MASK >> i)) {\n\t\t\t\t\treport &= ~(SND_JACK_BTN_0 >> i);\n\t\t\t\t\tmask |= SND_JACK_BTN_0 >> i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (events[DA7219_AAD_IRQ_REG_A] & DA7219_E_JACK_REMOVED_MASK) {\n\t\t\treport = 0;\n\t\t\tmask |= DA7219_AAD_REPORT_ALL_MASK;\n\t\t\tda7219_aad->jack_inserted = false;\n\n\t\t\t \n\t\t\tcancel_delayed_work_sync(&da7219_aad->jack_det_work);\n\t\t\tcancel_work_sync(&da7219_aad->btn_det_work);\n\t\t\tcancel_work_sync(&da7219_aad->hptest_work);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t\t\t    DA7219_HP_R_AMP_OE_MASK, 0);\n\t\t\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t\t\t    DA7219_HP_L_AMP_OE_MASK, 0);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t\t\t    DA7219_BUTTON_CONFIG_MASK, 0);\n\n\t\t\tda7219->micbias_on_event = false;\n\n\t\t\t \n\t\t\tsnd_soc_dapm_disable_pin(dapm, \"Mic Bias\");\n\t\t\tsnd_soc_dapm_sync(dapm);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, 0xFB, 0x01, 0x00);\n\t\t}\n\t}\n\n\tsnd_soc_jack_report(da7219_aad->jack, report, mask);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic enum da7219_aad_micbias_pulse_lvl\n\tda7219_aad_fw_micbias_pulse_lvl(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 2800:\n\t\treturn DA7219_AAD_MICBIAS_PULSE_LVL_2_8V;\n\tcase 2900:\n\t\treturn DA7219_AAD_MICBIAS_PULSE_LVL_2_9V;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid micbias pulse level\");\n\t\treturn DA7219_AAD_MICBIAS_PULSE_LVL_OFF;\n\t}\n}\n\nstatic enum da7219_aad_btn_cfg\n\tda7219_aad_fw_btn_cfg(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 2:\n\t\treturn DA7219_AAD_BTN_CFG_2MS;\n\tcase 5:\n\t\treturn DA7219_AAD_BTN_CFG_5MS;\n\tcase 10:\n\t\treturn DA7219_AAD_BTN_CFG_10MS;\n\tcase 50:\n\t\treturn DA7219_AAD_BTN_CFG_50MS;\n\tcase 100:\n\t\treturn DA7219_AAD_BTN_CFG_100MS;\n\tcase 200:\n\t\treturn DA7219_AAD_BTN_CFG_200MS;\n\tcase 500:\n\t\treturn DA7219_AAD_BTN_CFG_500MS;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid button config\");\n\t\treturn DA7219_AAD_BTN_CFG_10MS;\n\t}\n}\n\nstatic enum da7219_aad_mic_det_thr\n\tda7219_aad_fw_mic_det_thr(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 200:\n\t\treturn DA7219_AAD_MIC_DET_THR_200_OHMS;\n\tcase 500:\n\t\treturn DA7219_AAD_MIC_DET_THR_500_OHMS;\n\tcase 750:\n\t\treturn DA7219_AAD_MIC_DET_THR_750_OHMS;\n\tcase 1000:\n\t\treturn DA7219_AAD_MIC_DET_THR_1000_OHMS;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid mic detect threshold\");\n\t\treturn DA7219_AAD_MIC_DET_THR_500_OHMS;\n\t}\n}\n\nstatic enum da7219_aad_jack_ins_deb\n\tda7219_aad_fw_jack_ins_deb(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 5:\n\t\treturn DA7219_AAD_JACK_INS_DEB_5MS;\n\tcase 10:\n\t\treturn DA7219_AAD_JACK_INS_DEB_10MS;\n\tcase 20:\n\t\treturn DA7219_AAD_JACK_INS_DEB_20MS;\n\tcase 50:\n\t\treturn DA7219_AAD_JACK_INS_DEB_50MS;\n\tcase 100:\n\t\treturn DA7219_AAD_JACK_INS_DEB_100MS;\n\tcase 200:\n\t\treturn DA7219_AAD_JACK_INS_DEB_200MS;\n\tcase 500:\n\t\treturn DA7219_AAD_JACK_INS_DEB_500MS;\n\tcase 1000:\n\t\treturn DA7219_AAD_JACK_INS_DEB_1S;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid jack insert debounce\");\n\t\treturn DA7219_AAD_JACK_INS_DEB_20MS;\n\t}\n}\n\nstatic enum da7219_aad_jack_ins_det_pty\n\tda7219_aad_fw_jack_ins_det_pty(struct device *dev, const char *str)\n{\n\tif (!strcmp(str, \"low\")) {\n\t\treturn DA7219_AAD_JACK_INS_DET_PTY_LOW;\n\t} else if (!strcmp(str, \"high\")) {\n\t\treturn DA7219_AAD_JACK_INS_DET_PTY_HIGH;\n\t} else {\n\t\tdev_warn(dev, \"Invalid jack insertion detection polarity\");\n\t\treturn DA7219_AAD_JACK_INS_DET_PTY_LOW;\n\t}\n}\n\nstatic enum da7219_aad_jack_det_rate\n\tda7219_aad_fw_jack_det_rate(struct device *dev, const char *str)\n{\n\tif (!strcmp(str, \"32_64\")) {\n\t\treturn DA7219_AAD_JACK_DET_RATE_32_64MS;\n\t} else if (!strcmp(str, \"64_128\")) {\n\t\treturn DA7219_AAD_JACK_DET_RATE_64_128MS;\n\t} else if (!strcmp(str, \"128_256\")) {\n\t\treturn DA7219_AAD_JACK_DET_RATE_128_256MS;\n\t} else if (!strcmp(str, \"256_512\")) {\n\t\treturn DA7219_AAD_JACK_DET_RATE_256_512MS;\n\t} else {\n\t\tdev_warn(dev, \"Invalid jack detect rate\");\n\t\treturn DA7219_AAD_JACK_DET_RATE_256_512MS;\n\t}\n}\n\nstatic enum da7219_aad_jack_rem_deb\n\tda7219_aad_fw_jack_rem_deb(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 1:\n\t\treturn DA7219_AAD_JACK_REM_DEB_1MS;\n\tcase 5:\n\t\treturn DA7219_AAD_JACK_REM_DEB_5MS;\n\tcase 10:\n\t\treturn DA7219_AAD_JACK_REM_DEB_10MS;\n\tcase 20:\n\t\treturn DA7219_AAD_JACK_REM_DEB_20MS;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid jack removal debounce\");\n\t\treturn DA7219_AAD_JACK_REM_DEB_1MS;\n\t}\n}\n\nstatic enum da7219_aad_btn_avg\n\tda7219_aad_fw_btn_avg(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 1:\n\t\treturn DA7219_AAD_BTN_AVG_1;\n\tcase 2:\n\t\treturn DA7219_AAD_BTN_AVG_2;\n\tcase 4:\n\t\treturn DA7219_AAD_BTN_AVG_4;\n\tcase 8:\n\t\treturn DA7219_AAD_BTN_AVG_8;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid button average value\");\n\t\treturn DA7219_AAD_BTN_AVG_2;\n\t}\n}\n\nstatic enum da7219_aad_adc_1bit_rpt\n\tda7219_aad_fw_adc_1bit_rpt(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 1:\n\t\treturn DA7219_AAD_ADC_1BIT_RPT_1;\n\tcase 2:\n\t\treturn DA7219_AAD_ADC_1BIT_RPT_2;\n\tcase 4:\n\t\treturn DA7219_AAD_ADC_1BIT_RPT_4;\n\tcase 8:\n\t\treturn DA7219_AAD_ADC_1BIT_RPT_8;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid ADC 1-bit repeat value\");\n\t\treturn DA7219_AAD_ADC_1BIT_RPT_1;\n\t}\n}\n\nstatic struct da7219_aad_pdata *da7219_aad_fw_to_pdata(struct device *dev)\n{\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct fwnode_handle *aad_np;\n\tstruct da7219_aad_pdata *aad_pdata;\n\tconst char *fw_str;\n\tu32 fw_val32;\n\n\taad_np = device_get_named_child_node(dev, \"da7219_aad\");\n\tif (!aad_np)\n\t\treturn NULL;\n\n\taad_pdata = devm_kzalloc(dev, sizeof(*aad_pdata), GFP_KERNEL);\n\tif (!aad_pdata)\n\t\treturn NULL;\n\n\taad_pdata->irq = i2c->irq;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,micbias-pulse-lvl\",\n\t\t\t\t     &fw_val32) >= 0)\n\t\taad_pdata->micbias_pulse_lvl =\n\t\t\tda7219_aad_fw_micbias_pulse_lvl(dev, fw_val32);\n\telse\n\t\taad_pdata->micbias_pulse_lvl = DA7219_AAD_MICBIAS_PULSE_LVL_OFF;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,micbias-pulse-time\",\n\t\t\t\t     &fw_val32) >= 0)\n\t\taad_pdata->micbias_pulse_time = fw_val32;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,btn-cfg\", &fw_val32) >= 0)\n\t\taad_pdata->btn_cfg = da7219_aad_fw_btn_cfg(dev, fw_val32);\n\telse\n\t\taad_pdata->btn_cfg = DA7219_AAD_BTN_CFG_10MS;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,mic-det-thr\", &fw_val32) >= 0)\n\t\taad_pdata->mic_det_thr =\n\t\t\tda7219_aad_fw_mic_det_thr(dev, fw_val32);\n\telse\n\t\taad_pdata->mic_det_thr = DA7219_AAD_MIC_DET_THR_200_OHMS;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,jack-ins-deb\", &fw_val32) >= 0)\n\t\taad_pdata->jack_ins_deb =\n\t\t\tda7219_aad_fw_jack_ins_deb(dev, fw_val32);\n\telse\n\t\taad_pdata->jack_ins_deb = DA7219_AAD_JACK_INS_DEB_20MS;\n\n\tif (!fwnode_property_read_string(aad_np, \"dlg,jack-ins-det-pty\", &fw_str))\n\t\taad_pdata->jack_ins_det_pty =\n\t\t\tda7219_aad_fw_jack_ins_det_pty(dev, fw_str);\n\telse\n\t\taad_pdata->jack_ins_det_pty = DA7219_AAD_JACK_INS_DET_PTY_LOW;\n\n\tif (!fwnode_property_read_string(aad_np, \"dlg,jack-det-rate\", &fw_str))\n\t\taad_pdata->jack_det_rate =\n\t\t\tda7219_aad_fw_jack_det_rate(dev, fw_str);\n\telse\n\t\taad_pdata->jack_det_rate = DA7219_AAD_JACK_DET_RATE_256_512MS;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,jack-rem-deb\", &fw_val32) >= 0)\n\t\taad_pdata->jack_rem_deb =\n\t\t\tda7219_aad_fw_jack_rem_deb(dev, fw_val32);\n\telse\n\t\taad_pdata->jack_rem_deb = DA7219_AAD_JACK_REM_DEB_1MS;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,a-d-btn-thr\", &fw_val32) >= 0)\n\t\taad_pdata->a_d_btn_thr = (u8) fw_val32;\n\telse\n\t\taad_pdata->a_d_btn_thr = 0xA;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,d-b-btn-thr\", &fw_val32) >= 0)\n\t\taad_pdata->d_b_btn_thr = (u8) fw_val32;\n\telse\n\t\taad_pdata->d_b_btn_thr = 0x16;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,b-c-btn-thr\", &fw_val32) >= 0)\n\t\taad_pdata->b_c_btn_thr = (u8) fw_val32;\n\telse\n\t\taad_pdata->b_c_btn_thr = 0x21;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,c-mic-btn-thr\", &fw_val32) >= 0)\n\t\taad_pdata->c_mic_btn_thr = (u8) fw_val32;\n\telse\n\t\taad_pdata->c_mic_btn_thr = 0x3E;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,btn-avg\", &fw_val32) >= 0)\n\t\taad_pdata->btn_avg = da7219_aad_fw_btn_avg(dev, fw_val32);\n\telse\n\t\taad_pdata->btn_avg = DA7219_AAD_BTN_AVG_2;\n\n\tif (fwnode_property_read_u32(aad_np, \"dlg,adc-1bit-rpt\", &fw_val32) >= 0)\n\t\taad_pdata->adc_1bit_rpt =\n\t\t\tda7219_aad_fw_adc_1bit_rpt(dev, fw_val32);\n\telse\n\t\taad_pdata->adc_1bit_rpt = DA7219_AAD_ADC_1BIT_RPT_1;\n\n\treturn aad_pdata;\n}\n\nstatic void da7219_aad_handle_pdata(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tstruct da7219_pdata *pdata = da7219->pdata;\n\n\tif ((pdata) && (pdata->aad_pdata)) {\n\t\tstruct da7219_aad_pdata *aad_pdata = pdata->aad_pdata;\n\t\tu8 cfg, mask;\n\n\t\tda7219_aad->irq = aad_pdata->irq;\n\n\t\tswitch (aad_pdata->micbias_pulse_lvl) {\n\t\tcase DA7219_AAD_MICBIAS_PULSE_LVL_2_8V:\n\t\tcase DA7219_AAD_MICBIAS_PULSE_LVL_2_9V:\n\t\t\tda7219_aad->micbias_pulse_lvl =\n\t\t\t\t(aad_pdata->micbias_pulse_lvl <<\n\t\t\t\t DA7219_MICBIAS1_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tda7219_aad->micbias_pulse_time = aad_pdata->micbias_pulse_time;\n\n\t\tswitch (aad_pdata->btn_cfg) {\n\t\tcase DA7219_AAD_BTN_CFG_2MS:\n\t\tcase DA7219_AAD_BTN_CFG_5MS:\n\t\tcase DA7219_AAD_BTN_CFG_10MS:\n\t\tcase DA7219_AAD_BTN_CFG_50MS:\n\t\tcase DA7219_AAD_BTN_CFG_100MS:\n\t\tcase DA7219_AAD_BTN_CFG_200MS:\n\t\tcase DA7219_AAD_BTN_CFG_500MS:\n\t\t\tda7219_aad->btn_cfg  = (aad_pdata->btn_cfg <<\n\t\t\t\t\t\tDA7219_BUTTON_CONFIG_SHIFT);\n\t\t}\n\n\t\tcfg = 0;\n\t\tmask = 0;\n\t\tswitch (aad_pdata->mic_det_thr) {\n\t\tcase DA7219_AAD_MIC_DET_THR_200_OHMS:\n\t\tcase DA7219_AAD_MIC_DET_THR_500_OHMS:\n\t\tcase DA7219_AAD_MIC_DET_THR_750_OHMS:\n\t\tcase DA7219_AAD_MIC_DET_THR_1000_OHMS:\n\t\t\tcfg |= (aad_pdata->mic_det_thr <<\n\t\t\t\tDA7219_MIC_DET_THRESH_SHIFT);\n\t\t\tmask |= DA7219_MIC_DET_THRESH_MASK;\n\t\t}\n\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1, mask, cfg);\n\n\t\tcfg = 0;\n\t\tmask = 0;\n\t\tswitch (aad_pdata->jack_ins_deb) {\n\t\tcase DA7219_AAD_JACK_INS_DEB_5MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_10MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_20MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_50MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_100MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_200MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_500MS:\n\t\tcase DA7219_AAD_JACK_INS_DEB_1S:\n\t\t\tcfg |= (aad_pdata->jack_ins_deb <<\n\t\t\t\tDA7219_JACKDET_DEBOUNCE_SHIFT);\n\t\t\tmask |= DA7219_JACKDET_DEBOUNCE_MASK;\n\t\t}\n\t\tswitch (aad_pdata->jack_det_rate) {\n\t\tcase DA7219_AAD_JACK_DET_RATE_32_64MS:\n\t\tcase DA7219_AAD_JACK_DET_RATE_64_128MS:\n\t\tcase DA7219_AAD_JACK_DET_RATE_128_256MS:\n\t\tcase DA7219_AAD_JACK_DET_RATE_256_512MS:\n\t\t\tcfg |= (aad_pdata->jack_det_rate <<\n\t\t\t\tDA7219_JACK_DETECT_RATE_SHIFT);\n\t\t\tmask |= DA7219_JACK_DETECT_RATE_MASK;\n\t\t}\n\t\tswitch (aad_pdata->jack_rem_deb) {\n\t\tcase DA7219_AAD_JACK_REM_DEB_1MS:\n\t\tcase DA7219_AAD_JACK_REM_DEB_5MS:\n\t\tcase DA7219_AAD_JACK_REM_DEB_10MS:\n\t\tcase DA7219_AAD_JACK_REM_DEB_20MS:\n\t\t\tcfg |= (aad_pdata->jack_rem_deb <<\n\t\t\t\tDA7219_JACKDET_REM_DEB_SHIFT);\n\t\t\tmask |= DA7219_JACKDET_REM_DEB_MASK;\n\t\t}\n\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_2, mask, cfg);\n\n\t\tsnd_soc_component_write(component, DA7219_ACCDET_CONFIG_3,\n\t\t\t      aad_pdata->a_d_btn_thr);\n\t\tsnd_soc_component_write(component, DA7219_ACCDET_CONFIG_4,\n\t\t\t      aad_pdata->d_b_btn_thr);\n\t\tsnd_soc_component_write(component, DA7219_ACCDET_CONFIG_5,\n\t\t\t      aad_pdata->b_c_btn_thr);\n\t\tsnd_soc_component_write(component, DA7219_ACCDET_CONFIG_6,\n\t\t\t      aad_pdata->c_mic_btn_thr);\n\n\t\tcfg = 0;\n\t\tmask = 0;\n\t\tswitch (aad_pdata->btn_avg) {\n\t\tcase DA7219_AAD_BTN_AVG_1:\n\t\tcase DA7219_AAD_BTN_AVG_2:\n\t\tcase DA7219_AAD_BTN_AVG_4:\n\t\tcase DA7219_AAD_BTN_AVG_8:\n\t\t\tcfg |= (aad_pdata->btn_avg <<\n\t\t\t\tDA7219_BUTTON_AVERAGE_SHIFT);\n\t\t\tmask |= DA7219_BUTTON_AVERAGE_MASK;\n\t\t}\n\t\tswitch (aad_pdata->adc_1bit_rpt) {\n\t\tcase DA7219_AAD_ADC_1BIT_RPT_1:\n\t\tcase DA7219_AAD_ADC_1BIT_RPT_2:\n\t\tcase DA7219_AAD_ADC_1BIT_RPT_4:\n\t\tcase DA7219_AAD_ADC_1BIT_RPT_8:\n\t\t\tcfg |= (aad_pdata->adc_1bit_rpt <<\n\t\t\t       DA7219_ADC_1_BIT_REPEAT_SHIFT);\n\t\t\tmask |= DA7219_ADC_1_BIT_REPEAT_MASK;\n\t\t}\n\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_7, mask, cfg);\n\n\t\tswitch (aad_pdata->jack_ins_det_pty) {\n\t\tcase DA7219_AAD_JACK_INS_DET_PTY_LOW:\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x8B);\n\t\t\tsnd_soc_component_write(component, 0x75, 0x80);\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x00);\n\t\t\tbreak;\n\t\tcase DA7219_AAD_JACK_INS_DET_PTY_HIGH:\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x8B);\n\t\t\tsnd_soc_component_write(component, 0x75, 0x00);\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x00);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void da7219_aad_handle_gnd_switch_time(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tu8 jack_det;\n\n\tjack_det = snd_soc_component_read(component, DA7219_ACCDET_CONFIG_2)\n\t\t& DA7219_JACK_DETECT_RATE_MASK;\n\tswitch (jack_det) {\n\tcase 0x00:\n\t\tda7219_aad->gnd_switch_delay = 32;\n\t\tbreak;\n\tcase 0x10:\n\t\tda7219_aad->gnd_switch_delay = 64;\n\t\tbreak;\n\tcase 0x20:\n\t\tda7219_aad->gnd_switch_delay = 128;\n\t\tbreak;\n\tcase 0x30:\n\t\tda7219_aad->gnd_switch_delay = 256;\n\t\tbreak;\n\tdefault:\n\t\tda7219_aad->gnd_switch_delay = 32;\n\t\tbreak;\n\t}\n}\n\n \n\nvoid da7219_aad_suspend(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tu8 micbias_ctrl;\n\n\tif (da7219_aad->jack) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t\t    DA7219_ACCDET_EN_MASK, 0);\n\n\t\t \n\t\tif (da7219_aad->jack_inserted) {\n\t\t\tmicbias_ctrl = snd_soc_component_read(component, DA7219_MICBIAS_CTRL);\n\t\t\tif (micbias_ctrl & DA7219_MICBIAS1_EN_MASK) {\n\t\t\t\tsnd_soc_dapm_disable_pin(dapm, \"Mic Bias\");\n\t\t\t\tsnd_soc_dapm_sync(dapm);\n\t\t\t\tda7219_aad->micbias_resume_enable = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tsynchronize_irq(da7219_aad->irq);\n}\n\nvoid da7219_aad_resume(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tif (da7219_aad->jack) {\n\t\t \n\t\tif (da7219_aad->jack_inserted &&\n\t\t    da7219_aad->micbias_resume_enable) {\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"Mic Bias\");\n\t\t\tsnd_soc_dapm_sync(dapm);\n\t\t\tda7219_aad->micbias_resume_enable = false;\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t\t    DA7219_ACCDET_EN_MASK,\n\t\t\t\t    DA7219_ACCDET_EN_MASK);\n\t}\n}\n\n\n \n\nint da7219_aad_init(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tu8 mask[DA7219_AAD_IRQ_REG_MAX];\n\tint ret;\n\n\tda7219_aad->component = component;\n\n\t \n\tda7219_aad_handle_pdata(component);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ACCDET_CONFIG_1,\n\t\t\t    DA7219_BUTTON_CONFIG_MASK, 0);\n\n\tda7219_aad_handle_gnd_switch_time(component);\n\n\tda7219_aad->aad_wq = create_singlethread_workqueue(\"da7219-aad\");\n\tif (!da7219_aad->aad_wq) {\n\t\tdev_err(component->dev, \"Failed to create aad workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&da7219_aad->jack_det_work, da7219_aad_jack_det_work);\n\tINIT_WORK(&da7219_aad->btn_det_work, da7219_aad_btn_det_work);\n\tINIT_WORK(&da7219_aad->hptest_work, da7219_aad_hptest_work);\n\n\tret = request_threaded_irq(da7219_aad->irq, NULL,\n\t\t\t\t   da7219_aad_irq_thread,\n\t\t\t\t   IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t   \"da7219-aad\", da7219_aad);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmemset(mask, 0, DA7219_AAD_IRQ_REG_MAX);\n\tregmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,\n\t\t\t  &mask, DA7219_AAD_IRQ_REG_MAX);\n\n\treturn 0;\n}\n\nvoid da7219_aad_exit(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_aad_priv *da7219_aad = da7219->aad;\n\tu8 mask[DA7219_AAD_IRQ_REG_MAX];\n\n\t \n\tmemset(mask, DA7219_BYTE_MASK, DA7219_AAD_IRQ_REG_MAX);\n\tregmap_bulk_write(da7219->regmap, DA7219_ACCDET_IRQ_MASK_A,\n\t\t\t  mask, DA7219_AAD_IRQ_REG_MAX);\n\n\tfree_irq(da7219_aad->irq, da7219_aad);\n\n\tcancel_delayed_work_sync(&da7219_aad->jack_det_work);\n\tcancel_work_sync(&da7219_aad->btn_det_work);\n\tcancel_work_sync(&da7219_aad->hptest_work);\n\tdestroy_workqueue(da7219_aad->aad_wq);\n}\n\n \n\nint da7219_aad_probe(struct i2c_client *i2c)\n{\n\tstruct da7219_priv *da7219 = i2c_get_clientdata(i2c);\n\tstruct device *dev = &i2c->dev;\n\tstruct da7219_aad_priv *da7219_aad;\n\n\tda7219_aad = devm_kzalloc(dev, sizeof(*da7219_aad), GFP_KERNEL);\n\tif (!da7219_aad)\n\t\treturn -ENOMEM;\n\n\tda7219->aad = da7219_aad;\n\n\t \n\tif (da7219->pdata && !da7219->pdata->aad_pdata)\n\t\tda7219->pdata->aad_pdata = da7219_aad_fw_to_pdata(dev);\n\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"ASoC DA7219 AAD Driver\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_AUTHOR(\"David Rau <David.Rau.opensource@dm.renesas.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}