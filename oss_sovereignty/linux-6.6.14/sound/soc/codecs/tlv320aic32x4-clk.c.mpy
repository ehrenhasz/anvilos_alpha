{
  "module_name": "tlv320aic32x4-clk.c",
  "hash_id": "2b9b353415695e4819ecd8890cb99c9768f497bd67fc28973277e918d6ab2f17",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic32x4-clk.c",
  "human_readable_source": " \n\n#include <linux/clk-provider.h>\n#include <linux/clkdev.h>\n#include <linux/regmap.h>\n#include <linux/device.h>\n\n#include \"tlv320aic32x4.h\"\n\n#define to_clk_aic32x4(_hw) container_of(_hw, struct clk_aic32x4, hw)\nstruct clk_aic32x4 {\n\tstruct clk_hw hw;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tunsigned int reg;\n};\n\n \nstruct clk_aic32x4_pll_muldiv {\n\tu8 p;\n\tu16 r;\n\tu8 j;\n\tu16 d;\n};\n\nstruct aic32x4_clkdesc {\n\tconst char *name;\n\tconst char * const *parent_names;\n\tunsigned int num_parents;\n\tconst struct clk_ops *ops;\n\tunsigned int reg;\n};\n\nstatic int clk_aic32x4_pll_prepare(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\n\treturn regmap_update_bits(pll->regmap, AIC32X4_PLLPR,\n\t\t\t\tAIC32X4_PLLEN, AIC32X4_PLLEN);\n}\n\nstatic void clk_aic32x4_pll_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\n\tregmap_update_bits(pll->regmap, AIC32X4_PLLPR,\n\t\t\t\tAIC32X4_PLLEN, 0);\n}\n\nstatic int clk_aic32x4_pll_is_prepared(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(pll->regmap, AIC32X4_PLLPR, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(val & AIC32X4_PLLEN);\n}\n\nstatic int clk_aic32x4_pll_get_muldiv(struct clk_aic32x4 *pll,\n\t\t\tstruct clk_aic32x4_pll_muldiv *settings)\n{\n\t \n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(pll->regmap, AIC32X4_PLLPR, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tsettings->r = val & AIC32X4_PLL_R_MASK;\n\tsettings->p = (val & AIC32X4_PLL_P_MASK) >> AIC32X4_PLL_P_SHIFT;\n\n\tret = regmap_read(pll->regmap, AIC32X4_PLLJ, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tsettings->j = val;\n\n\tret = regmap_read(pll->regmap, AIC32X4_PLLDMSB, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tsettings->d = val << 8;\n\n\tret = regmap_read(pll->regmap, AIC32X4_PLLDLSB,\t &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tsettings->d |= val;\n\n\treturn 0;\n}\n\nstatic int clk_aic32x4_pll_set_muldiv(struct clk_aic32x4 *pll,\n\t\t\tstruct clk_aic32x4_pll_muldiv *settings)\n{\n\tint ret;\n\t \n\n\tret = regmap_update_bits(pll->regmap, AIC32X4_PLLPR,\n\t\t\t\tAIC32X4_PLL_R_MASK, settings->r);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(pll->regmap, AIC32X4_PLLPR,\n\t\t\t\tAIC32X4_PLL_P_MASK,\n\t\t\t\tsettings->p << AIC32X4_PLL_P_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(pll->regmap, AIC32X4_PLLJ, settings->j);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_write(pll->regmap, AIC32X4_PLLDMSB, (settings->d >> 8));\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_write(pll->regmap, AIC32X4_PLLDLSB, (settings->d & 0xff));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_aic32x4_pll_calc_rate(\n\t\t\tstruct clk_aic32x4_pll_muldiv *settings,\n\t\t\tunsigned long parent_rate)\n{\n\tu64 rate;\n\t \n\trate = (u64) parent_rate * settings->r *\n\t\t\t\t((settings->j * 10000) + settings->d);\n\n\treturn (unsigned long) DIV_ROUND_UP_ULL(rate, settings->p * 10000);\n}\n\nstatic int clk_aic32x4_pll_calc_muldiv(struct clk_aic32x4_pll_muldiv *settings,\n\t\t\tunsigned long rate, unsigned long parent_rate)\n{\n\tu64 multiplier;\n\n\tsettings->p = parent_rate / AIC32X4_MAX_PLL_CLKIN + 1;\n\tif (settings->p > 8)\n\t\treturn -1;\n\n\t \n\tmultiplier = (u64) rate * settings->p * 10000;\n\tdo_div(multiplier, parent_rate);\n\n\t \n\tsettings->r = ((u32) multiplier / 640000) + 1;\n\tif (settings->r > 4)\n\t\treturn -1;\n\tdo_div(multiplier, settings->r);\n\n\t \n\tif (multiplier < 10000)\n\t\treturn -1;\n\n\t \n\tsettings->j = (u32) multiplier / 10000;\n\tsettings->d = (u32) multiplier % 10000;\n\n\treturn 0;\n}\n\nstatic unsigned long clk_aic32x4_pll_recalc_rate(struct clk_hw *hw,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\tstruct clk_aic32x4_pll_muldiv settings;\n\tint ret;\n\n\tret =  clk_aic32x4_pll_get_muldiv(pll, &settings);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn clk_aic32x4_pll_calc_rate(&settings, parent_rate);\n}\n\nstatic int clk_aic32x4_pll_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\tstruct clk_aic32x4_pll_muldiv settings;\n\tint ret;\n\n\tret = clk_aic32x4_pll_calc_muldiv(&settings, req->rate, req->best_parent_rate);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treq->rate = clk_aic32x4_pll_calc_rate(&settings, req->best_parent_rate);\n\n\treturn 0;\n}\n\nstatic int clk_aic32x4_pll_set_rate(struct clk_hw *hw,\n\t\t\tunsigned long rate,\n\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\tstruct clk_aic32x4_pll_muldiv settings;\n\tint ret;\n\n\tret = clk_aic32x4_pll_calc_muldiv(&settings, rate, parent_rate);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tret = clk_aic32x4_pll_set_muldiv(pll, &settings);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(10);\n\n\treturn 0;\n}\n\nstatic int clk_aic32x4_pll_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\n\treturn regmap_update_bits(pll->regmap,\n\t\t\t\tAIC32X4_CLKMUX,\n\t\t\t\tAIC32X4_PLL_CLKIN_MASK,\n\t\t\t\tindex << AIC32X4_PLL_CLKIN_SHIFT);\n}\n\nstatic u8 clk_aic32x4_pll_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *pll = to_clk_aic32x4(hw);\n\tunsigned int val;\n\n\tregmap_read(pll->regmap, AIC32X4_PLLPR, &val);\n\n\treturn (val & AIC32X4_PLL_CLKIN_MASK) >> AIC32X4_PLL_CLKIN_SHIFT;\n}\n\n\nstatic const struct clk_ops aic32x4_pll_ops = {\n\t.prepare = clk_aic32x4_pll_prepare,\n\t.unprepare = clk_aic32x4_pll_unprepare,\n\t.is_prepared = clk_aic32x4_pll_is_prepared,\n\t.recalc_rate = clk_aic32x4_pll_recalc_rate,\n\t.determine_rate = clk_aic32x4_pll_determine_rate,\n\t.set_rate = clk_aic32x4_pll_set_rate,\n\t.set_parent = clk_aic32x4_pll_set_parent,\n\t.get_parent = clk_aic32x4_pll_get_parent,\n};\n\nstatic int clk_aic32x4_codec_clkin_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_aic32x4 *mux = to_clk_aic32x4(hw);\n\n\treturn regmap_update_bits(mux->regmap,\n\t\tAIC32X4_CLKMUX,\n\t\tAIC32X4_CODEC_CLKIN_MASK, index << AIC32X4_CODEC_CLKIN_SHIFT);\n}\n\nstatic u8 clk_aic32x4_codec_clkin_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *mux = to_clk_aic32x4(hw);\n\tunsigned int val;\n\n\tregmap_read(mux->regmap, AIC32X4_CLKMUX, &val);\n\n\treturn (val & AIC32X4_CODEC_CLKIN_MASK) >> AIC32X4_CODEC_CLKIN_SHIFT;\n}\n\nstatic const struct clk_ops aic32x4_codec_clkin_ops = {\n\t.determine_rate = clk_hw_determine_rate_no_reparent,\n\t.set_parent = clk_aic32x4_codec_clkin_set_parent,\n\t.get_parent = clk_aic32x4_codec_clkin_get_parent,\n};\n\nstatic int clk_aic32x4_div_prepare(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *div = to_clk_aic32x4(hw);\n\n\treturn regmap_update_bits(div->regmap, div->reg,\n\t\t\t\tAIC32X4_DIVEN, AIC32X4_DIVEN);\n}\n\nstatic void clk_aic32x4_div_unprepare(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *div = to_clk_aic32x4(hw);\n\n\tregmap_update_bits(div->regmap, div->reg,\n\t\t\tAIC32X4_DIVEN, 0);\n}\n\nstatic int clk_aic32x4_div_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_aic32x4 *div = to_clk_aic32x4(hw);\n\tu8 divisor;\n\n\tdivisor = DIV_ROUND_UP(parent_rate, rate);\n\tif (divisor > AIC32X4_DIV_MAX)\n\t\treturn -EINVAL;\n\n\treturn regmap_update_bits(div->regmap, div->reg,\n\t\t\t\tAIC32X4_DIV_MASK, divisor);\n}\n\nstatic int clk_aic32x4_div_determine_rate(struct clk_hw *hw,\n\t\t\t\t\t  struct clk_rate_request *req)\n{\n\tunsigned long divisor;\n\n\tdivisor = DIV_ROUND_UP(req->best_parent_rate, req->rate);\n\tif (divisor > AIC32X4_DIV_MAX)\n\t\treturn -EINVAL;\n\n\treq->rate = DIV_ROUND_UP(req->best_parent_rate, divisor);\n\treturn 0;\n}\n\nstatic unsigned long clk_aic32x4_div_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\tunsigned long parent_rate)\n{\n\tstruct clk_aic32x4 *div = to_clk_aic32x4(hw);\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(div->regmap, div->reg, &val);\n\tif (err)\n\t\treturn 0;\n\n\tval &= AIC32X4_DIV_MASK;\n\tif (!val)\n\t\tval = AIC32X4_DIV_MAX;\n\n\treturn DIV_ROUND_UP(parent_rate, val);\n}\n\nstatic const struct clk_ops aic32x4_div_ops = {\n\t.prepare = clk_aic32x4_div_prepare,\n\t.unprepare = clk_aic32x4_div_unprepare,\n\t.set_rate = clk_aic32x4_div_set_rate,\n\t.determine_rate = clk_aic32x4_div_determine_rate,\n\t.recalc_rate = clk_aic32x4_div_recalc_rate,\n};\n\nstatic int clk_aic32x4_bdiv_set_parent(struct clk_hw *hw, u8 index)\n{\n\tstruct clk_aic32x4 *mux = to_clk_aic32x4(hw);\n\n\treturn regmap_update_bits(mux->regmap, AIC32X4_IFACE3,\n\t\t\t\tAIC32X4_BDIVCLK_MASK, index);\n}\n\nstatic u8 clk_aic32x4_bdiv_get_parent(struct clk_hw *hw)\n{\n\tstruct clk_aic32x4 *mux = to_clk_aic32x4(hw);\n\tunsigned int val;\n\n\tregmap_read(mux->regmap, AIC32X4_IFACE3, &val);\n\n\treturn val & AIC32X4_BDIVCLK_MASK;\n}\n\nstatic const struct clk_ops aic32x4_bdiv_ops = {\n\t.prepare = clk_aic32x4_div_prepare,\n\t.unprepare = clk_aic32x4_div_unprepare,\n\t.set_parent = clk_aic32x4_bdiv_set_parent,\n\t.get_parent = clk_aic32x4_bdiv_get_parent,\n\t.set_rate = clk_aic32x4_div_set_rate,\n\t.determine_rate = clk_aic32x4_div_determine_rate,\n\t.recalc_rate = clk_aic32x4_div_recalc_rate,\n};\n\nstatic struct aic32x4_clkdesc aic32x4_clkdesc_array[] = {\n\t{\n\t\t.name = \"pll\",\n\t\t.parent_names =\n\t\t\t(const char* []) { \"mclk\", \"bclk\", \"gpio\", \"din\" },\n\t\t.num_parents = 4,\n\t\t.ops = &aic32x4_pll_ops,\n\t\t.reg = 0,\n\t},\n\t{\n\t\t.name = \"codec_clkin\",\n\t\t.parent_names =\n\t\t\t(const char *[]) { \"mclk\", \"bclk\", \"gpio\", \"pll\" },\n\t\t.num_parents = 4,\n\t\t.ops = &aic32x4_codec_clkin_ops,\n\t\t.reg = 0,\n\t},\n\t{\n\t\t.name = \"ndac\",\n\t\t.parent_names = (const char * []) { \"codec_clkin\" },\n\t\t.num_parents = 1,\n\t\t.ops = &aic32x4_div_ops,\n\t\t.reg = AIC32X4_NDAC,\n\t},\n\t{\n\t\t.name = \"mdac\",\n\t\t.parent_names = (const char * []) { \"ndac\" },\n\t\t.num_parents = 1,\n\t\t.ops = &aic32x4_div_ops,\n\t\t.reg = AIC32X4_MDAC,\n\t},\n\t{\n\t\t.name = \"nadc\",\n\t\t.parent_names = (const char * []) { \"codec_clkin\" },\n\t\t.num_parents = 1,\n\t\t.ops = &aic32x4_div_ops,\n\t\t.reg = AIC32X4_NADC,\n\t},\n\t{\n\t\t.name = \"madc\",\n\t\t.parent_names = (const char * []) { \"nadc\" },\n\t\t.num_parents = 1,\n\t\t.ops = &aic32x4_div_ops,\n\t\t.reg = AIC32X4_MADC,\n\t},\n\t{\n\t\t.name = \"bdiv\",\n\t\t.parent_names =\n\t\t\t(const char *[]) { \"ndac\", \"mdac\", \"nadc\", \"madc\" },\n\t\t.num_parents = 4,\n\t\t.ops = &aic32x4_bdiv_ops,\n\t\t.reg = AIC32X4_BCLKN,\n\t},\n};\n\nstatic struct clk *aic32x4_register_clk(struct device *dev,\n\t\t\tstruct aic32x4_clkdesc *desc)\n{\n\tstruct clk_init_data init;\n\tstruct clk_aic32x4 *priv;\n\tconst char *devname = dev_name(dev);\n\n\tinit.ops = desc->ops;\n\tinit.name = desc->name;\n\tinit.parent_names = desc->parent_names;\n\tinit.num_parents = desc->num_parents;\n\tinit.flags = 0;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct clk_aic32x4), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn (struct clk *) -ENOMEM;\n\n\tpriv->dev = dev;\n\tpriv->hw.init = &init;\n\tpriv->regmap = dev_get_regmap(dev, NULL);\n\tpriv->reg = desc->reg;\n\n\tclk_hw_register_clkdev(&priv->hw, desc->name, devname);\n\treturn devm_clk_register(dev, &priv->hw);\n}\n\nint aic32x4_register_clocks(struct device *dev, const char *mclk_name)\n{\n\tint i;\n\n\t \n\taic32x4_clkdesc_array[0].parent_names =\n\t\t\t(const char* []) { mclk_name, \"bclk\", \"gpio\", \"din\" };\n\taic32x4_clkdesc_array[1].parent_names =\n\t\t\t(const char *[]) { mclk_name, \"bclk\", \"gpio\", \"pll\" };\n\n\tfor (i = 0; i < ARRAY_SIZE(aic32x4_clkdesc_array); ++i)\n\t\taic32x4_register_clk(dev, &aic32x4_clkdesc_array[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aic32x4_register_clocks);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}