{
  "module_name": "adau1701.c",
  "hash_id": "9f4f4b419a1d2ca908213282ab97d99b37723eb9b2acfab8f46031abfcb32985",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau1701.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include <asm/unaligned.h>\n\n#include \"sigmadsp.h\"\n#include \"adau1701.h\"\n\n#define ADAU1701_SAFELOAD_DATA(i) (0x0810 + (i))\n#define ADAU1701_SAFELOAD_ADDR(i) (0x0815 + (i))\n\n#define ADAU1701_DSPCTRL\t0x081c\n#define ADAU1701_SEROCTL\t0x081e\n#define ADAU1701_SERICTL\t0x081f\n\n#define ADAU1701_AUXNPOW\t0x0822\n#define ADAU1701_PINCONF_0\t0x0820\n#define ADAU1701_PINCONF_1\t0x0821\n#define ADAU1701_AUXNPOW\t0x0822\n\n#define ADAU1701_OSCIPOW\t0x0826\n#define ADAU1701_DACSET\t\t0x0827\n\n#define ADAU1701_MAX_REGISTER\t0x0828\n\n#define ADAU1701_DSPCTRL_CR\t\t(1 << 2)\n#define ADAU1701_DSPCTRL_DAM\t\t(1 << 3)\n#define ADAU1701_DSPCTRL_ADM\t\t(1 << 4)\n#define ADAU1701_DSPCTRL_IST\t\t(1 << 5)\n#define ADAU1701_DSPCTRL_SR_48\t\t0x00\n#define ADAU1701_DSPCTRL_SR_96\t\t0x01\n#define ADAU1701_DSPCTRL_SR_192\t\t0x02\n#define ADAU1701_DSPCTRL_SR_MASK\t0x03\n\n#define ADAU1701_SEROCTL_INV_LRCLK\t0x2000\n#define ADAU1701_SEROCTL_INV_BCLK\t0x1000\n#define ADAU1701_SEROCTL_MASTER\t\t0x0800\n\n#define ADAU1701_SEROCTL_OBF16\t\t0x0000\n#define ADAU1701_SEROCTL_OBF8\t\t0x0200\n#define ADAU1701_SEROCTL_OBF4\t\t0x0400\n#define ADAU1701_SEROCTL_OBF2\t\t0x0600\n#define ADAU1701_SEROCTL_OBF_MASK\t0x0600\n\n#define ADAU1701_SEROCTL_OLF1024\t0x0000\n#define ADAU1701_SEROCTL_OLF512\t\t0x0080\n#define ADAU1701_SEROCTL_OLF256\t\t0x0100\n#define ADAU1701_SEROCTL_OLF_MASK\t0x0180\n\n#define ADAU1701_SEROCTL_MSB_DEALY1\t0x0000\n#define ADAU1701_SEROCTL_MSB_DEALY0\t0x0004\n#define ADAU1701_SEROCTL_MSB_DEALY8\t0x0008\n#define ADAU1701_SEROCTL_MSB_DEALY12\t0x000c\n#define ADAU1701_SEROCTL_MSB_DEALY16\t0x0010\n#define ADAU1701_SEROCTL_MSB_DEALY_MASK\t0x001c\n\n#define ADAU1701_SEROCTL_WORD_LEN_24\t0x0000\n#define ADAU1701_SEROCTL_WORD_LEN_20\t0x0001\n#define ADAU1701_SEROCTL_WORD_LEN_16\t0x0002\n#define ADAU1701_SEROCTL_WORD_LEN_MASK\t0x0003\n\n#define ADAU1701_AUXNPOW_VBPD\t\t0x40\n#define ADAU1701_AUXNPOW_VRPD\t\t0x20\n\n#define ADAU1701_SERICTL_I2S\t\t0\n#define ADAU1701_SERICTL_LEFTJ\t\t1\n#define ADAU1701_SERICTL_TDM\t\t2\n#define ADAU1701_SERICTL_RIGHTJ_24\t3\n#define ADAU1701_SERICTL_RIGHTJ_20\t4\n#define ADAU1701_SERICTL_RIGHTJ_18\t5\n#define ADAU1701_SERICTL_RIGHTJ_16\t6\n#define ADAU1701_SERICTL_MODE_MASK\t7\n#define ADAU1701_SERICTL_INV_BCLK\tBIT(3)\n#define ADAU1701_SERICTL_INV_LRCLK\tBIT(4)\n\n#define ADAU1701_OSCIPOW_OPD\t\t0x04\n#define ADAU1701_DACSET_DACINIT\t\t1\n\n#define ADAU1707_CLKDIV_UNSET\t\t(-1U)\n\n#define ADAU1701_FIRMWARE \"adau1701.bin\"\n\nstatic const char * const supply_names[] = {\n\t\"dvdd\", \"avdd\"\n};\n\nstruct adau1701 {\n\tstruct gpio_desc  *gpio_nreset;\n\tstruct gpio_descs *gpio_pll_mode;\n\tunsigned int dai_fmt;\n\tunsigned int pll_clkdiv;\n\tunsigned int sysclk;\n\tstruct regmap *regmap;\n\tstruct i2c_client *client;\n\tu8 pin_config[12];\n\n\tstruct sigmadsp *sigmadsp;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n};\n\nstatic const struct snd_kcontrol_new adau1701_controls[] = {\n\tSOC_SINGLE(\"Master Capture Switch\", ADAU1701_DSPCTRL, 4, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget adau1701_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC0\", \"Playback\", ADAU1701_AUXNPOW, 3, 1),\n\tSND_SOC_DAPM_DAC(\"DAC1\", \"Playback\", ADAU1701_AUXNPOW, 2, 1),\n\tSND_SOC_DAPM_DAC(\"DAC2\", \"Playback\", ADAU1701_AUXNPOW, 1, 1),\n\tSND_SOC_DAPM_DAC(\"DAC3\", \"Playback\", ADAU1701_AUXNPOW, 0, 1),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", ADAU1701_AUXNPOW, 7, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT0\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\tSND_SOC_DAPM_INPUT(\"IN0\"),\n\tSND_SOC_DAPM_INPUT(\"IN1\"),\n};\n\nstatic const struct snd_soc_dapm_route adau1701_dapm_routes[] = {\n\t{ \"OUT0\", NULL, \"DAC0\" },\n\t{ \"OUT1\", NULL, \"DAC1\" },\n\t{ \"OUT2\", NULL, \"DAC2\" },\n\t{ \"OUT3\", NULL, \"DAC3\" },\n\n\t{ \"ADC\", NULL, \"IN0\" },\n\t{ \"ADC\", NULL, \"IN1\" },\n};\n\nstatic unsigned int adau1701_register_size(struct device *dev,\n\t\tunsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADAU1701_PINCONF_0:\n\tcase ADAU1701_PINCONF_1:\n\t\treturn 3;\n\tcase ADAU1701_DSPCTRL:\n\tcase ADAU1701_SEROCTL:\n\tcase ADAU1701_AUXNPOW:\n\tcase ADAU1701_OSCIPOW:\n\tcase ADAU1701_DACSET:\n\t\treturn 2;\n\tcase ADAU1701_SERICTL:\n\t\treturn 1;\n\t}\n\n\tdev_err(dev, \"Unsupported register address: %d\\n\", reg);\n\treturn 0;\n}\n\nstatic bool adau1701_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADAU1701_DACSET:\n\tcase ADAU1701_DSPCTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int adau1701_reg_write(void *context, unsigned int reg,\n\t\t\t      unsigned int value)\n{\n\tstruct i2c_client *client = context;\n\tunsigned int i;\n\tunsigned int size;\n\tuint8_t buf[5];\n\tint ret;\n\n\tsize = adau1701_register_size(&client->dev, reg);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tfor (i = size + 1; i >= 2; --i) {\n\t\tbuf[i] = value;\n\t\tvalue >>= 8;\n\t}\n\n\tret = i2c_master_send(client, buf, size + 2);\n\tif (ret == size + 2)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int adau1701_reg_read(void *context, unsigned int reg,\n\t\t\t     unsigned int *value)\n{\n\tint ret;\n\tunsigned int i;\n\tunsigned int size;\n\tuint8_t send_buf[2], recv_buf[3];\n\tstruct i2c_client *client = context;\n\tstruct i2c_msg msgs[2];\n\n\tsize = adau1701_register_size(&client->dev, reg);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tsend_buf[0] = reg >> 8;\n\tsend_buf[1] = reg & 0xff;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].len = sizeof(send_buf);\n\tmsgs[0].buf = send_buf;\n\tmsgs[0].flags = 0;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].len = size;\n\tmsgs[1].buf = recv_buf;\n\tmsgs[1].flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\t*value = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\t*value <<= 8;\n\t\t*value |= recv_buf[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int adau1701_safeload(struct sigmadsp *sigmadsp, unsigned int addr,\n\tconst uint8_t bytes[], size_t len)\n{\n\tstruct i2c_client *client = to_i2c_client(sigmadsp->dev);\n\tstruct adau1701 *adau1701 = i2c_get_clientdata(client);\n\tunsigned int val;\n\tunsigned int i;\n\tuint8_t buf[10];\n\tint ret;\n\n\tret = regmap_read(adau1701->regmap, ADAU1701_DSPCTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val & ADAU1701_DSPCTRL_IST)\n\t\tmsleep(50);\n\n\tfor (i = 0; i < len / 4; i++) {\n\t\tput_unaligned_le16(ADAU1701_SAFELOAD_DATA(i), buf);\n\t\tbuf[2] = 0x00;\n\t\tmemcpy(buf + 3, bytes + i * 4, 4);\n\t\tret = i2c_master_send(client, buf, 7);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != 7)\n\t\t\treturn -EIO;\n\n\t\tput_unaligned_le16(ADAU1701_SAFELOAD_ADDR(i), buf);\n\t\tput_unaligned_le16(addr + i, buf + 2);\n\t\tret = i2c_master_send(client, buf, 4);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret != 4)\n\t\t\treturn -EIO;\n\t}\n\n\treturn regmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL,\n\t\tADAU1701_DSPCTRL_IST, ADAU1701_DSPCTRL_IST);\n}\n\nstatic const struct sigmadsp_ops adau1701_sigmadsp_ops = {\n\t.safeload = adau1701_safeload,\n};\n\nstatic int adau1701_reset(struct snd_soc_component *component, unsigned int clkdiv,\n\tunsigned int rate)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tDECLARE_BITMAP(values, 2);\n\tsigmadsp_reset(adau1701->sigmadsp);\n\n\tif (clkdiv != ADAU1707_CLKDIV_UNSET && adau1701->gpio_pll_mode) {\n\t\tswitch (clkdiv) {\n\t\tcase 64:\n\t\t\t__assign_bit(0, values, 0);\n\t\t\t__assign_bit(1, values, 0);\n\t\t\tbreak;\n\t\tcase 256:\n\t\t\t__assign_bit(0, values, 0);\n\t\t\t__assign_bit(1, values, 1);\n\t\t\tbreak;\n\t\tcase 384:\n\t\t\t__assign_bit(0, values, 1);\n\t\t\t__assign_bit(1, values, 0);\n\t\t\tbreak;\n\t\tcase 0:  \n\t\tcase 512:\n\t\t\t__assign_bit(0, values, 1);\n\t\t\t__assign_bit(1, values, 1);\n\t\t\tbreak;\n\t\t}\n\t\tgpiod_set_array_value_cansleep(adau1701->gpio_pll_mode->ndescs,\n\t\t\t\tadau1701->gpio_pll_mode->desc, adau1701->gpio_pll_mode->info,\n\t\t\t\tvalues);\n\t}\n\n\tadau1701->pll_clkdiv = clkdiv;\n\n\tif (adau1701->gpio_nreset) {\n\t\tgpiod_set_value_cansleep(adau1701->gpio_nreset, 0);\n\t\t \n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(adau1701->gpio_nreset, 1);\n\t\t \n\t\tmdelay(85);\n\t}\n\n\t \n\tif (clkdiv != ADAU1707_CLKDIV_UNSET) {\n\t\tret = sigmadsp_setup(adau1701->sigmadsp, rate);\n\t\tif (ret) {\n\t\t\tdev_warn(component->dev, \"Failed to load firmware\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tregmap_write(adau1701->regmap, ADAU1701_DACSET, ADAU1701_DACSET_DACINIT);\n\tregmap_write(adau1701->regmap, ADAU1701_DSPCTRL, ADAU1701_DSPCTRL_CR);\n\n\tregcache_mark_dirty(adau1701->regmap);\n\tregcache_sync(adau1701->regmap);\n\n\treturn 0;\n}\n\nstatic int adau1701_set_capture_pcm_format(struct snd_soc_component *component,\n\t\t\t\t\t   struct snd_pcm_hw_params *params)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tunsigned int mask = ADAU1701_SEROCTL_WORD_LEN_MASK;\n\tunsigned int val;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval = ADAU1701_SEROCTL_WORD_LEN_16;\n\t\tbreak;\n\tcase 20:\n\t\tval = ADAU1701_SEROCTL_WORD_LEN_20;\n\t\tbreak;\n\tcase 24:\n\t\tval = ADAU1701_SEROCTL_WORD_LEN_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (adau1701->dai_fmt == SND_SOC_DAIFMT_RIGHT_J) {\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tval |= ADAU1701_SEROCTL_MSB_DEALY16;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tval |= ADAU1701_SEROCTL_MSB_DEALY12;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tval |= ADAU1701_SEROCTL_MSB_DEALY8;\n\t\t\tbreak;\n\t\t}\n\t\tmask |= ADAU1701_SEROCTL_MSB_DEALY_MASK;\n\t}\n\n\tregmap_update_bits(adau1701->regmap, ADAU1701_SEROCTL, mask, val);\n\n\treturn 0;\n}\n\nstatic int adau1701_set_playback_pcm_format(struct snd_soc_component *component,\n\t\t\t\t\t    struct snd_pcm_hw_params *params)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (adau1701->dai_fmt != SND_SOC_DAIFMT_RIGHT_J)\n\t\treturn 0;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval = ADAU1701_SERICTL_RIGHTJ_16;\n\t\tbreak;\n\tcase 20:\n\t\tval = ADAU1701_SERICTL_RIGHTJ_20;\n\t\tbreak;\n\tcase 24:\n\t\tval = ADAU1701_SERICTL_RIGHTJ_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau1701->regmap, ADAU1701_SERICTL,\n\t\tADAU1701_SERICTL_MODE_MASK, val);\n\n\treturn 0;\n}\n\nstatic int adau1701_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tunsigned int clkdiv = adau1701->sysclk / params_rate(params);\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (clkdiv != adau1701->pll_clkdiv) {\n\t\tret = adau1701_reset(component, clkdiv, params_rate(params));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 192000:\n\t\tval = ADAU1701_DSPCTRL_SR_192;\n\t\tbreak;\n\tcase 96000:\n\t\tval = ADAU1701_DSPCTRL_SR_96;\n\t\tbreak;\n\tcase 48000:\n\t\tval = ADAU1701_DSPCTRL_SR_48;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL,\n\t\tADAU1701_DSPCTRL_SR_MASK, val);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn adau1701_set_playback_pcm_format(component, params);\n\telse\n\t\treturn adau1701_set_capture_pcm_format(component, params);\n}\n\nstatic int adau1701_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tunsigned int serictl = 0x00, seroctl = 0x00;\n\tbool invert_lrclk;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t \n\t\tseroctl |= ADAU1701_SEROCTL_MASTER | ADAU1701_SEROCTL_OBF16\n\t\t\t\t| ADAU1701_SEROCTL_OLF1024;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert_lrclk = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert_lrclk = false;\n\t\tserictl |= ADAU1701_SERICTL_INV_BCLK;\n\t\tseroctl |= ADAU1701_SEROCTL_INV_BCLK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tinvert_lrclk = true;\n\t\tserictl |= ADAU1701_SERICTL_INV_BCLK;\n\t\tseroctl |= ADAU1701_SEROCTL_INV_BCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tserictl |= ADAU1701_SERICTL_LEFTJ;\n\t\tseroctl |= ADAU1701_SEROCTL_MSB_DEALY0;\n\t\tinvert_lrclk = !invert_lrclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tserictl |= ADAU1701_SERICTL_RIGHTJ_24;\n\t\tseroctl |= ADAU1701_SEROCTL_MSB_DEALY8;\n\t\tinvert_lrclk = !invert_lrclk;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (invert_lrclk) {\n\t\tseroctl |= ADAU1701_SEROCTL_INV_LRCLK;\n\t\tserictl |= ADAU1701_SERICTL_INV_LRCLK;\n\t}\n\n\tadau1701->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tregmap_write(adau1701->regmap, ADAU1701_SERICTL, serictl);\n\tregmap_update_bits(adau1701->regmap, ADAU1701_SEROCTL,\n\t\t~ADAU1701_SEROCTL_WORD_LEN_MASK, seroctl);\n\n\treturn 0;\n}\n\nstatic int adau1701_set_bias_level(struct snd_soc_component *component,\n\t\tenum snd_soc_bias_level level)\n{\n\tunsigned int mask = ADAU1701_AUXNPOW_VBPD | ADAU1701_AUXNPOW_VRPD;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tregmap_update_bits(adau1701->regmap,\n\t\t\t\t   ADAU1701_AUXNPOW, mask, 0x00);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tregmap_update_bits(adau1701->regmap,\n\t\t\t\t   ADAU1701_AUXNPOW, mask, mask);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int adau1701_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int mask = ADAU1701_DSPCTRL_DAM;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (mute)\n\t\tval = 0;\n\telse\n\t\tval = mask;\n\n\tregmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL, mask, val);\n\n\treturn 0;\n}\n\nstatic int adau1701_set_sysclk(struct snd_soc_component *component, int clk_id,\n\tint source, unsigned int freq, int dir)\n{\n\tunsigned int val;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase ADAU1701_CLK_SRC_OSC:\n\t\tval = 0x0;\n\t\tbreak;\n\tcase ADAU1701_CLK_SRC_MCLK:\n\t\tval = ADAU1701_OSCIPOW_OPD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau1701->regmap, ADAU1701_OSCIPOW,\n\t\t\t   ADAU1701_OSCIPOW_OPD, val);\n\tadau1701->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int adau1701_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(dai->component);\n\n\treturn sigmadsp_restrict_params(adau1701->sigmadsp, substream);\n}\n\n#define ADAU1701_RATES (SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \\\n\tSNDRV_PCM_RATE_192000)\n\n#define ADAU1701_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops adau1701_dai_ops = {\n\t.set_fmt\t= adau1701_set_dai_fmt,\n\t.hw_params\t= adau1701_hw_params,\n\t.mute_stream\t= adau1701_mute_stream,\n\t.startup\t= adau1701_startup,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver adau1701_dai = {\n\t.name = \"adau1701\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = ADAU1701_RATES,\n\t\t.formats = ADAU1701_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = ADAU1701_RATES,\n\t\t.formats = ADAU1701_FORMATS,\n\t},\n\t.ops = &adau1701_dai_ops,\n\t.symmetric_rate = 1,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id adau1701_dt_ids[] = {\n\t{ .compatible = \"adi,adau1701\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adau1701_dt_ids);\n#endif\n\nstatic int adau1701_probe(struct snd_soc_component *component)\n{\n\tint i, ret;\n\tunsigned int val;\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\n\tret = sigmadsp_attach(adau1701->sigmadsp, component);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(adau1701->supplies),\n\t\t\t\t    adau1701->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tadau1701->pll_clkdiv = ADAU1707_CLKDIV_UNSET;\n\n\t \n\tret = adau1701_reset(component, adau1701->pll_clkdiv, 0);\n\tif (ret < 0)\n\t\tgoto exit_regulators_disable;\n\n\t \n\tval = 0;\n\tfor (i = 0; i < 6; i++)\n\t\tval |= adau1701->pin_config[i] << (i * 4);\n\n\tregmap_write(adau1701->regmap, ADAU1701_PINCONF_0, val);\n\n\tval = 0;\n\tfor (i = 0; i < 6; i++)\n\t\tval |= adau1701->pin_config[i + 6] << (i * 4);\n\n\tregmap_write(adau1701->regmap, ADAU1701_PINCONF_1, val);\n\n\treturn 0;\n\nexit_regulators_disable:\n\n\tregulator_bulk_disable(ARRAY_SIZE(adau1701->supplies), adau1701->supplies);\n\treturn ret;\n}\n\nstatic void adau1701_remove(struct snd_soc_component *component)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\n\tif (adau1701->gpio_nreset)\n\t\tgpiod_set_value_cansleep(adau1701->gpio_nreset, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(adau1701->supplies), adau1701->supplies);\n}\n\n#ifdef CONFIG_PM\nstatic int adau1701_suspend(struct snd_soc_component *component)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\n\tregulator_bulk_disable(ARRAY_SIZE(adau1701->supplies),\n\t\t\t       adau1701->supplies);\n\n\treturn 0;\n}\n\nstatic int adau1701_resume(struct snd_soc_component *component)\n{\n\tstruct adau1701 *adau1701 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n        ret = regulator_bulk_enable(ARRAY_SIZE(adau1701->supplies),\n\t\t\t\t    adau1701->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn adau1701_reset(component, adau1701->pll_clkdiv, 0);\n}\n#else\n#define adau1701_resume \tNULL\n#define adau1701_suspend \tNULL\n#endif  \n\nstatic const struct snd_soc_component_driver adau1701_component_drv = {\n\t.probe\t\t\t= adau1701_probe,\n\t.remove\t\t\t= adau1701_remove,\n\t.resume\t\t\t= adau1701_resume,\n\t.suspend\t\t= adau1701_suspend,\n\t.set_bias_level\t\t= adau1701_set_bias_level,\n\t.controls\t\t= adau1701_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adau1701_controls),\n\t.dapm_widgets\t\t= adau1701_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adau1701_dapm_widgets),\n\t.dapm_routes\t\t= adau1701_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(adau1701_dapm_routes),\n\t.set_sysclk\t\t= adau1701_set_sysclk,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config adau1701_regmap = {\n\t.reg_bits\t\t= 16,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= ADAU1701_MAX_REGISTER,\n\t.cache_type\t\t= REGCACHE_MAPLE,\n\t.volatile_reg\t\t= adau1701_volatile_reg,\n\t.reg_write\t\t= adau1701_reg_write,\n\t.reg_read\t\t= adau1701_reg_read,\n};\n\nstatic int adau1701_i2c_probe(struct i2c_client *client)\n{\n\tstruct adau1701 *adau1701;\n\tstruct device *dev = &client->dev;\n\tint ret, i;\n\n\tadau1701 = devm_kzalloc(dev, sizeof(*adau1701), GFP_KERNEL);\n\tif (!adau1701)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tadau1701->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(adau1701->supplies),\n\t\t\tadau1701->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(adau1701->supplies),\n\t\t\tadau1701->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tadau1701->client = client;\n\tadau1701->regmap = devm_regmap_init(dev, NULL, client,\n\t\t\t\t\t    &adau1701_regmap);\n\tif (IS_ERR(adau1701->regmap)) {\n\t\tret = PTR_ERR(adau1701->regmap);\n\t\tgoto exit_regulators_disable;\n\t}\n\n\n\tif (dev->of_node) {\n\t\tof_property_read_u32(dev->of_node, \"adi,pll-clkdiv\",\n\t\t\t\t     &adau1701->pll_clkdiv);\n\n\t\tof_property_read_u8_array(dev->of_node, \"adi,pin-config\",\n\t\t\t\t\t  adau1701->pin_config,\n\t\t\t\t\t  ARRAY_SIZE(adau1701->pin_config));\n\t}\n\n\tadau1701->gpio_nreset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_IN);\n\n\tif (IS_ERR(adau1701->gpio_nreset)) {\n\t\tret = PTR_ERR(adau1701->gpio_nreset);\n\t\tgoto exit_regulators_disable;\n\t}\n\n\tadau1701->gpio_pll_mode = devm_gpiod_get_array_optional(dev, \"adi,pll-mode\", GPIOD_OUT_LOW);\n\n\tif (IS_ERR(adau1701->gpio_pll_mode)) {\n\t\tret = PTR_ERR(adau1701->gpio_pll_mode);\n\t\tgoto exit_regulators_disable;\n\t}\n\n\ti2c_set_clientdata(client, adau1701);\n\n\tadau1701->sigmadsp = devm_sigmadsp_init_i2c(client,\n\t\t&adau1701_sigmadsp_ops, ADAU1701_FIRMWARE);\n\tif (IS_ERR(adau1701->sigmadsp)) {\n\t\tret = PTR_ERR(adau1701->sigmadsp);\n\t\tgoto exit_regulators_disable;\n\t}\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t&adau1701_component_drv,\n\t\t\t&adau1701_dai, 1);\n\nexit_regulators_disable:\n\n\tregulator_bulk_disable(ARRAY_SIZE(adau1701->supplies), adau1701->supplies);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id adau1701_i2c_id[] = {\n\t{ \"adau1401\", 0 },\n\t{ \"adau1401a\", 0 },\n\t{ \"adau1701\", 0 },\n\t{ \"adau1702\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, adau1701_i2c_id);\n\nstatic struct i2c_driver adau1701_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"adau1701\",\n\t\t.of_match_table\t= of_match_ptr(adau1701_dt_ids),\n\t},\n\t.probe\t\t= adau1701_i2c_probe,\n\t.id_table\t= adau1701_i2c_id,\n};\n\nmodule_i2c_driver(adau1701_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC ADAU1701 SigmaDSP driver\");\nMODULE_AUTHOR(\"Cliff Cai <cliff.cai@analog.com>\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}