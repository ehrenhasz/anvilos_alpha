{
  "module_name": "cs35l33.c",
  "hash_id": "f57dd19cb089acc03c5c8a81d5c42a337f18f842f576cb046fa66c557e9022bf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l33.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/gpio/consumer.h>\n#include <sound/cs35l33.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/machine.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n\n#include \"cs35l33.h\"\n#include \"cirrus_legacy.h\"\n\n#define CS35L33_BOOT_DELAY\t50\n\nstruct cs35l33_private {\n\tstruct snd_soc_component *component;\n\tstruct cs35l33_pdata pdata;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpio;\n\tbool amp_cal;\n\tint mclk_int;\n\tstruct regulator_bulk_data core_supplies[2];\n\tint num_core_supplies;\n\tbool is_tdm_mode;\n\tbool enable_soft_ramp;\n};\n\nstatic const struct reg_default cs35l33_reg[] = {\n\t{CS35L33_PWRCTL1, 0x85},\n\t{CS35L33_PWRCTL2, 0xFE},\n\t{CS35L33_CLK_CTL, 0x0C},\n\t{CS35L33_BST_PEAK_CTL, 0x90},\n\t{CS35L33_PROTECT_CTL, 0x55},\n\t{CS35L33_BST_CTL1, 0x00},\n\t{CS35L33_BST_CTL2, 0x01},\n\t{CS35L33_ADSP_CTL, 0x00},\n\t{CS35L33_ADC_CTL, 0xC8},\n\t{CS35L33_DAC_CTL, 0x14},\n\t{CS35L33_DIG_VOL_CTL, 0x00},\n\t{CS35L33_CLASSD_CTL, 0x04},\n\t{CS35L33_AMP_CTL, 0x90},\n\t{CS35L33_INT_MASK_1, 0xFF},\n\t{CS35L33_INT_MASK_2, 0xFF},\n\t{CS35L33_DIAG_LOCK, 0x00},\n\t{CS35L33_DIAG_CTRL_1, 0x40},\n\t{CS35L33_DIAG_CTRL_2, 0x00},\n\t{CS35L33_HG_MEMLDO_CTL, 0x62},\n\t{CS35L33_HG_REL_RATE, 0x03},\n\t{CS35L33_LDO_DEL, 0x12},\n\t{CS35L33_HG_HEAD, 0x0A},\n\t{CS35L33_HG_EN, 0x05},\n\t{CS35L33_TX_VMON, 0x00},\n\t{CS35L33_TX_IMON, 0x03},\n\t{CS35L33_TX_VPMON, 0x02},\n\t{CS35L33_TX_VBSTMON, 0x05},\n\t{CS35L33_TX_FLAG, 0x06},\n\t{CS35L33_TX_EN1, 0x00},\n\t{CS35L33_TX_EN2, 0x00},\n\t{CS35L33_TX_EN3, 0x00},\n\t{CS35L33_TX_EN4, 0x00},\n\t{CS35L33_RX_AUD, 0x40},\n\t{CS35L33_RX_SPLY, 0x03},\n\t{CS35L33_RX_ALIVE, 0x04},\n\t{CS35L33_BST_CTL4, 0x63},\n};\n\nstatic const struct reg_sequence cs35l33_patch[] = {\n\t{ 0x00,  0x99, 0 },\n\t{ 0x59,  0x02, 0 },\n\t{ 0x52,  0x30, 0 },\n\t{ 0x39,  0x45, 0 },\n\t{ 0x57,  0x30, 0 },\n\t{ 0x2C,  0x68, 0 },\n\t{ 0x00,  0x00, 0 },\n};\n\nstatic bool cs35l33_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L33_DEVID_AB:\n\tcase CS35L33_DEVID_CD:\n\tcase CS35L33_DEVID_E:\n\tcase CS35L33_REV_ID:\n\tcase CS35L33_INT_STATUS_1:\n\tcase CS35L33_INT_STATUS_2:\n\tcase CS35L33_HG_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l33_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\t \n\tcase CS35L33_DEVID_AB:\n\tcase CS35L33_DEVID_CD:\n\tcase CS35L33_DEVID_E:\n\tcase CS35L33_REV_ID:\n\tcase CS35L33_INT_STATUS_1:\n\tcase CS35L33_INT_STATUS_2:\n\tcase CS35L33_HG_STATUS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool cs35l33_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L33_DEVID_AB:\n\tcase CS35L33_DEVID_CD:\n\tcase CS35L33_DEVID_E:\n\tcase CS35L33_REV_ID:\n\tcase CS35L33_PWRCTL1:\n\tcase CS35L33_PWRCTL2:\n\tcase CS35L33_CLK_CTL:\n\tcase CS35L33_BST_PEAK_CTL:\n\tcase CS35L33_PROTECT_CTL:\n\tcase CS35L33_BST_CTL1:\n\tcase CS35L33_BST_CTL2:\n\tcase CS35L33_ADSP_CTL:\n\tcase CS35L33_ADC_CTL:\n\tcase CS35L33_DAC_CTL:\n\tcase CS35L33_DIG_VOL_CTL:\n\tcase CS35L33_CLASSD_CTL:\n\tcase CS35L33_AMP_CTL:\n\tcase CS35L33_INT_MASK_1:\n\tcase CS35L33_INT_MASK_2:\n\tcase CS35L33_INT_STATUS_1:\n\tcase CS35L33_INT_STATUS_2:\n\tcase CS35L33_DIAG_LOCK:\n\tcase CS35L33_DIAG_CTRL_1:\n\tcase CS35L33_DIAG_CTRL_2:\n\tcase CS35L33_HG_MEMLDO_CTL:\n\tcase CS35L33_HG_REL_RATE:\n\tcase CS35L33_LDO_DEL:\n\tcase CS35L33_HG_HEAD:\n\tcase CS35L33_HG_EN:\n\tcase CS35L33_TX_VMON:\n\tcase CS35L33_TX_IMON:\n\tcase CS35L33_TX_VPMON:\n\tcase CS35L33_TX_VBSTMON:\n\tcase CS35L33_TX_FLAG:\n\tcase CS35L33_TX_EN1:\n\tcase CS35L33_TX_EN2:\n\tcase CS35L33_TX_EN3:\n\tcase CS35L33_TX_EN4:\n\tcase CS35L33_RX_AUD:\n\tcase CS35L33_RX_SPLY:\n\tcase CS35L33_RX_ALIVE:\n\tcase CS35L33_BST_CTL4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(classd_ctl_tlv, 900, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -10200, 50, 0);\n\nstatic const struct snd_kcontrol_new cs35l33_snd_controls[] = {\n\n\tSOC_SINGLE_TLV(\"SPK Amp Volume\", CS35L33_AMP_CTL,\n\t\t       4, 0x09, 0, classd_ctl_tlv),\n\tSOC_SINGLE_SX_TLV(\"DAC Volume\", CS35L33_DIG_VOL_CTL,\n\t\t\t0, 0x34, 0xE4, dac_tlv),\n};\n\nstatic int cs35l33_spkrdrv_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (!priv->amp_cal) {\n\t\t\tusleep_range(8000, 9000);\n\t\t\tpriv->amp_cal = true;\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_CLASSD_CTL,\n\t\t\t\t    CS35L33_AMP_CAL, 0);\n\t\t\tdev_dbg(component->dev, \"Amp calibration done\\n\");\n\t\t}\n\t\tdev_dbg(component->dev, \"Amp turned on\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdev_dbg(component->dev, \"Amp turned off\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l33_sdin_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\n\t\t\t\t    CS35L33_PDN_BST, 0);\n\t\tval = priv->is_tdm_mode ? 0 : CS35L33_PDN_TDM;\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\n\t\t\t\t    CS35L33_PDN_TDM, val);\n\t\tdev_dbg(component->dev, \"BST turned on\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tdev_dbg(component->dev, \"SDIN turned on\\n\");\n\t\tif (!priv->amp_cal) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_CLASSD_CTL,\n\t\t\t\t    CS35L33_AMP_CAL, CS35L33_AMP_CAL);\n\t\t\tdev_dbg(component->dev, \"Amp calibration started\\n\");\n\t\t\tusleep_range(10000, 11000);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\n\t\t\t\t    CS35L33_PDN_TDM, CS35L33_PDN_TDM);\n\t\tusleep_range(4000, 4100);\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\n\t\t\t\t    CS35L33_PDN_BST, CS35L33_PDN_BST);\n\t\tdev_dbg(component->dev, \"BST and SDIN turned off\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l33_sdout_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int mask = CS35L33_SDOUT_3ST_I2S | CS35L33_PDN_TDM;\n\tunsigned int mask2 = CS35L33_SDOUT_3ST_TDM;\n\tunsigned int val, val2;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (priv->is_tdm_mode) {\n\t\t\t \n\t\t\tval = CS35L33_SDOUT_3ST_I2S;\n\t\t\t \n\t\t\tval2 = 0;\n\t\t} else {\n\t\t\t \n\t\t\tval = CS35L33_PDN_TDM;\n\t\t\t \n\t\t\tval2 = CS35L33_SDOUT_3ST_TDM;\n\t\t}\n\t\tdev_dbg(component->dev, \"SDOUT turned on\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tval = CS35L33_SDOUT_3ST_I2S | CS35L33_PDN_TDM;\n\t\tval2 = CS35L33_SDOUT_3ST_TDM;\n\t\tdev_dbg(component->dev, \"SDOUT turned off\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\treturn 0;\n\t}\n\n\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\n\t\tmask, val);\n\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\tmask2, val2);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs35l33_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\tSND_SOC_DAPM_OUT_DRV_E(\"SPKDRV\", CS35L33_PWRCTL1, 7, 1, NULL, 0,\n\t\tcs35l33_spkrdrv_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_AIF_IN_E(\"SDIN\", NULL, 0, CS35L33_PWRCTL2,\n\t\t2, 1, cs35l33_sdin_event, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_INPUT(\"MON\"),\n\n\tSND_SOC_DAPM_ADC(\"VMON\", NULL,\n\t\tCS35L33_PWRCTL2, CS35L33_PDN_VMON_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"IMON\", NULL,\n\t\tCS35L33_PWRCTL2, CS35L33_PDN_IMON_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"VPMON\", NULL,\n\t\tCS35L33_PWRCTL2, CS35L33_PDN_VPMON_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"VBSTMON\", NULL,\n\t\tCS35L33_PWRCTL2, CS35L33_PDN_VBSTMON_SHIFT, 1),\n\n\tSND_SOC_DAPM_AIF_OUT_E(\"SDOUT\", NULL, 0, SND_SOC_NOPM, 0, 0,\n\t\tcs35l33_sdout_event, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_PRE_PMD),\n};\n\nstatic const struct snd_soc_dapm_route cs35l33_audio_map[] = {\n\t{\"SDIN\", NULL, \"CS35L33 Playback\"},\n\t{\"SPKDRV\", NULL, \"SDIN\"},\n\t{\"SPK\", NULL, \"SPKDRV\"},\n\n\t{\"VMON\", NULL, \"MON\"},\n\t{\"IMON\", NULL, \"MON\"},\n\n\t{\"SDOUT\", NULL, \"VMON\"},\n\t{\"SDOUT\", NULL, \"IMON\"},\n\t{\"CS35L33 Capture\", NULL, \"SDOUT\"},\n};\n\nstatic const struct snd_soc_dapm_route cs35l33_vphg_auto_route[] = {\n\t{\"SPKDRV\", NULL, \"VPMON\"},\n\t{\"VPMON\", NULL, \"CS35L33 Playback\"},\n};\n\nstatic const struct snd_soc_dapm_route cs35l33_vp_vbst_mon_route[] = {\n\t{\"SDOUT\", NULL, \"VPMON\"},\n\t{\"VPMON\", NULL, \"MON\"},\n\t{\"SDOUT\", NULL, \"VBSTMON\"},\n\t{\"VBSTMON\", NULL, \"MON\"},\n};\n\nstatic int cs35l33_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tunsigned int val;\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\n\t\t\t\t    CS35L33_PDN_ALL, 0);\n\t\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\t\t\t    CS35L33_MCLKDIS, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL1,\n\t\t\t\t    CS35L33_PDN_ALL, CS35L33_PDN_ALL);\n\t\tregmap_read(priv->regmap, CS35L33_INT_STATUS_2, &val);\n\t\tusleep_range(1000, 1100);\n\t\tif (val & CS35L33_PDN_DONE)\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\t\t\t\t    CS35L33_MCLKDIS, CS35L33_MCLKDIS);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct cs35l33_mclk_div {\n\tint mclk;\n\tint srate;\n\tu8 adsp_rate;\n\tu8 int_fs_ratio;\n};\n\nstatic const struct cs35l33_mclk_div cs35l33_mclk_coeffs[] = {\n\t \n\t{5644800, 11025, 0x4, CS35L33_INT_FS_RATE},\n\t{5644800, 22050, 0x8, CS35L33_INT_FS_RATE},\n\t{5644800, 44100, 0xC, CS35L33_INT_FS_RATE},\n\n\t{6000000,  8000, 0x1, 0},\n\t{6000000, 11025, 0x2, 0},\n\t{6000000, 11029, 0x3, 0},\n\t{6000000, 12000, 0x4, 0},\n\t{6000000, 16000, 0x5, 0},\n\t{6000000, 22050, 0x6, 0},\n\t{6000000, 22059, 0x7, 0},\n\t{6000000, 24000, 0x8, 0},\n\t{6000000, 32000, 0x9, 0},\n\t{6000000, 44100, 0xA, 0},\n\t{6000000, 44118, 0xB, 0},\n\t{6000000, 48000, 0xC, 0},\n\n\t{6144000,  8000, 0x1, CS35L33_INT_FS_RATE},\n\t{6144000, 12000, 0x4, CS35L33_INT_FS_RATE},\n\t{6144000, 16000, 0x5, CS35L33_INT_FS_RATE},\n\t{6144000, 24000, 0x8, CS35L33_INT_FS_RATE},\n\t{6144000, 32000, 0x9, CS35L33_INT_FS_RATE},\n\t{6144000, 48000, 0xC, CS35L33_INT_FS_RATE},\n};\n\nstatic int cs35l33_get_mclk_coeff(int mclk, int srate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l33_mclk_coeffs); i++) {\n\t\tif (cs35l33_mclk_coeffs[i].mclk == mclk &&\n\t\t\tcs35l33_mclk_coeffs[i].srate == srate)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs35l33_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tregmap_update_bits(priv->regmap, CS35L33_ADSP_CTL,\n\t\t\tCS35L33_MS_MASK, CS35L33_MS_MASK);\n\t\tdev_dbg(component->dev, \"Audio port in master mode\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tregmap_update_bits(priv->regmap, CS35L33_ADSP_CTL,\n\t\t\tCS35L33_MS_MASK, 0);\n\t\tdev_dbg(component->dev, \"Audio port in slave mode\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\tpriv->is_tdm_mode = true;\n\t\tdev_dbg(component->dev, \"Audio port in TDM mode\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpriv->is_tdm_mode = false;\n\t\tdev_dbg(component->dev, \"Audio port in I2S mode\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l33_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\tint sample_size = params_width(params);\n\tint coeff = cs35l33_get_mclk_coeff(priv->mclk_int, params_rate(params));\n\n\tif (coeff < 0)\n\t\treturn coeff;\n\n\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\tCS35L33_ADSP_FS | CS35L33_INT_FS_RATE,\n\t\tcs35l33_mclk_coeffs[coeff].int_fs_ratio\n\t\t| cs35l33_mclk_coeffs[coeff].adsp_rate);\n\n\tif (priv->is_tdm_mode) {\n\t\tsample_size = (sample_size / 8) - 1;\n\t\tif (sample_size > 2)\n\t\t\tsample_size = 2;\n\t\tregmap_update_bits(priv->regmap, CS35L33_RX_AUD,\n\t\t\tCS35L33_AUDIN_RX_DEPTH,\n\t\t\tsample_size << CS35L33_AUDIN_RX_DEPTH_SHIFT);\n\t}\n\n\tdev_dbg(component->dev, \"sample rate=%d, bits per sample=%d\\n\",\n\t\tparams_rate(params), params_width(params));\n\n\treturn 0;\n}\n\nstatic const unsigned int cs35l33_src_rates[] = {\n\t8000, 11025, 11029, 12000, 16000, 22050,\n\t22059, 24000, 32000, 44100, 44118, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs35l33_constraints = {\n\t.count  = ARRAY_SIZE(cs35l33_src_rates),\n\t.list   = cs35l33_src_rates,\n};\n\nstatic int cs35l33_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t&cs35l33_constraints);\n\treturn 0;\n}\n\nstatic int cs35l33_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\n\tif (tristate) {\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\n\t\t\tCS35L33_SDOUT_3ST_I2S, CS35L33_SDOUT_3ST_I2S);\n\t\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\t\tCS35L33_SDOUT_3ST_TDM, CS35L33_SDOUT_3ST_TDM);\n\t} else {\n\t\tregmap_update_bits(priv->regmap, CS35L33_PWRCTL2,\n\t\t\tCS35L33_SDOUT_3ST_I2S, 0);\n\t\tregmap_update_bits(priv->regmap, CS35L33_CLK_CTL,\n\t\t\tCS35L33_SDOUT_3ST_TDM, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l33_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int reg, bit_pos, i;\n\tint slot, slot_num;\n\n\tif (slot_width != 8)\n\t\treturn -EINVAL;\n\n\t \n\tslot = ffs(rx_mask) - 1;\n\tif (slot >= 0) {\n\t\tregmap_update_bits(priv->regmap, CS35L33_RX_AUD,\n\t\t\tCS35L33_X_LOC, slot);\n\t\tdev_dbg(component->dev, \"Audio starts from slots %d\", slot);\n\t}\n\n\t \n\tslot = ffs(tx_mask) - 1;\n\tslot_num = 0;\n\n\tfor (i = 0; i < 2 ; i++) {\n\t\t \n\t\tregmap_update_bits(priv->regmap, CS35L33_TX_VPMON + i,\n\t\t\tCS35L33_X_STATE | CS35L33_X_LOC, CS35L33_X_STATE\n\t\t\t| CS35L33_X_LOC);\n\t}\n\n\t \n\tsnd_soc_dapm_del_routes(dapm, cs35l33_vp_vbst_mon_route,\n\t\tARRAY_SIZE(cs35l33_vp_vbst_mon_route));\n\n\twhile (slot >= 0) {\n\t\t \n\t\tif (slot_num == 0) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_TX_VMON,\n\t\t\t\tCS35L33_X_STATE | CS35L33_X_LOC, slot);\n\t\t\tdev_dbg(component->dev, \"VMON enabled in slots %d-%d\",\n\t\t\t\tslot, slot + 1);\n\t\t}\n\n\t\t \n\t\tif (slot_num == 3) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_TX_IMON,\n\t\t\t\tCS35L33_X_STATE | CS35L33_X_LOC, slot);\n\t\t\tdev_dbg(component->dev, \"IMON enabled in slots %d-%d\",\n\t\t\t\tslot, slot + 1);\n\t\t}\n\n\t\t \n\t\tif (slot_num == 4) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_TX_VPMON,\n\t\t\t\tCS35L33_X_STATE | CS35L33_X_LOC, slot);\n\t\t\tsnd_soc_dapm_add_routes(dapm,\n\t\t\t\t&cs35l33_vp_vbst_mon_route[0], 2);\n\t\t\tdev_dbg(component->dev, \"VPMON enabled in slots %d\", slot);\n\t\t}\n\n\t\t \n\t\tif (slot_num == 5) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_TX_VBSTMON,\n\t\t\t\tCS35L33_X_STATE | CS35L33_X_LOC, slot);\n\t\t\tsnd_soc_dapm_add_routes(dapm,\n\t\t\t\t&cs35l33_vp_vbst_mon_route[2], 2);\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"VBSTMON enabled in slots %d\", slot);\n\t\t}\n\n\t\t \n\t\treg = CS35L33_TX_EN4 - (slot/8);\n\t\tbit_pos = slot - ((slot / 8) * (8));\n\t\tregmap_update_bits(priv->regmap, reg,\n\t\t\t1 << bit_pos, 1 << bit_pos);\n\n\t\ttx_mask &= ~(1 << slot);\n\t\tslot = ffs(tx_mask) - 1;\n\t\tslot_num++;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l33_component_set_sysclk(struct snd_soc_component *component,\n\t\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct cs35l33_private *cs35l33 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase CS35L33_MCLK_5644:\n\tcase CS35L33_MCLK_6:\n\tcase CS35L33_MCLK_6144:\n\t\tregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\n\t\t\tCS35L33_MCLKDIV2, 0);\n\t\tcs35l33->mclk_int = freq;\n\t\tbreak;\n\tcase CS35L33_MCLK_11289:\n\tcase CS35L33_MCLK_12:\n\tcase CS35L33_MCLK_12288:\n\t\tregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\n\t\t\tCS35L33_MCLKDIV2, CS35L33_MCLKDIV2);\n\t\tcs35l33->mclk_int = freq/2;\n\t\tbreak;\n\tdefault:\n\t\tcs35l33->mclk_int = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"external mclk freq=%d, internal mclk freq=%d\\n\",\n\t\tfreq, cs35l33->mclk_int);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l33_ops = {\n\t.startup = cs35l33_pcm_startup,\n\t.set_tristate = cs35l33_set_tristate,\n\t.set_fmt = cs35l33_set_dai_fmt,\n\t.hw_params = cs35l33_pcm_hw_params,\n\t.set_tdm_slot = cs35l33_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver cs35l33_dai = {\n\t\t.name = \"cs35l33-dai\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"CS35L33 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rates = CS35L33_RATES,\n\t\t\t.formats = CS35L33_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"CS35L33 Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS35L33_RATES,\n\t\t\t.formats = CS35L33_FORMATS,\n\t\t},\n\t\t.ops = &cs35l33_ops,\n\t\t.symmetric_rate = 1,\n};\n\nstatic int cs35l33_set_hg_data(struct snd_soc_component *component,\n\t\t\t       struct cs35l33_pdata *pdata)\n{\n\tstruct cs35l33_hg *hg_config = &pdata->hg_config;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct cs35l33_private *priv = snd_soc_component_get_drvdata(component);\n\n\tif (hg_config->enable_hg_algo) {\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\n\t\t\tCS35L33_MEM_DEPTH_MASK,\n\t\t\thg_config->mem_depth << CS35L33_MEM_DEPTH_SHIFT);\n\t\tregmap_write(priv->regmap, CS35L33_HG_REL_RATE,\n\t\t\thg_config->release_rate);\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_HEAD,\n\t\t\tCS35L33_HD_RM_MASK,\n\t\t\thg_config->hd_rm << CS35L33_HD_RM_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\n\t\t\tCS35L33_LDO_THLD_MASK,\n\t\t\thg_config->ldo_thld << CS35L33_LDO_THLD_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_MEMLDO_CTL,\n\t\t\tCS35L33_LDO_DISABLE_MASK,\n\t\t\thg_config->ldo_path_disable <<\n\t\t\t\tCS35L33_LDO_DISABLE_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\n\t\t\tCS35L33_LDO_ENTRY_DELAY_MASK,\n\t\t\thg_config->ldo_entry_delay <<\n\t\t\t\tCS35L33_LDO_ENTRY_DELAY_SHIFT);\n\t\tif (hg_config->vp_hg_auto) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L33_HG_EN,\n\t\t\t\tCS35L33_VP_HG_AUTO_MASK,\n\t\t\t\tCS35L33_VP_HG_AUTO_MASK);\n\t\t\tsnd_soc_dapm_add_routes(dapm, cs35l33_vphg_auto_route,\n\t\t\t\tARRAY_SIZE(cs35l33_vphg_auto_route));\n\t\t}\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_EN,\n\t\t\tCS35L33_VP_HG_MASK,\n\t\t\thg_config->vp_hg << CS35L33_VP_HG_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\n\t\t\tCS35L33_VP_HG_RATE_MASK,\n\t\t\thg_config->vp_hg_rate << CS35L33_VP_HG_RATE_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_LDO_DEL,\n\t\t\tCS35L33_VP_HG_VA_MASK,\n\t\t\thg_config->vp_hg_va << CS35L33_VP_HG_VA_SHIFT);\n\t\tregmap_update_bits(priv->regmap, CS35L33_HG_EN,\n\t\t\tCS35L33_CLASS_HG_EN_MASK, CS35L33_CLASS_HG_EN_MASK);\n\t}\n\treturn 0;\n}\n\nstatic int cs35l33_set_bst_ipk(struct snd_soc_component *component, unsigned int bst)\n{\n\tstruct cs35l33_private *cs35l33 = snd_soc_component_get_drvdata(component);\n\tint ret = 0, steps = 0;\n\n\t \n\tif (bst > 3600000 || bst < 1850000) {\n\t\tdev_err(component->dev, \"Invalid boost current %d\\n\", bst);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (bst % 15625) {\n\t\tdev_err(component->dev, \"Current not a multiple of 15625uA (%d)\\n\",\n\t\t\tbst);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\twhile (bst > 1850000) {\n\t\tbst -= 15625;\n\t\tsteps++;\n\t}\n\n\tregmap_write(cs35l33->regmap, CS35L33_BST_PEAK_CTL,\n\t\tsteps+0x70);\n\nerr:\n\treturn ret;\n}\n\nstatic int cs35l33_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l33_private *cs35l33 = snd_soc_component_get_drvdata(component);\n\n\tcs35l33->component = component;\n\tpm_runtime_get_sync(component->dev);\n\n\tregmap_update_bits(cs35l33->regmap, CS35L33_PROTECT_CTL,\n\t\tCS35L33_ALIVE_WD_DIS, 0x8);\n\tregmap_update_bits(cs35l33->regmap, CS35L33_BST_CTL2,\n\t\t\t\tCS35L33_ALIVE_WD_DIS2,\n\t\t\t\tCS35L33_ALIVE_WD_DIS2);\n\n\t \n\tregmap_update_bits(cs35l33->regmap, CS35L33_BST_CTL1,\n\t\tCS35L33_BST_CTL_MASK, cs35l33->pdata.boost_ctl);\n\tregmap_update_bits(cs35l33->regmap, CS35L33_CLASSD_CTL,\n\t\tCS35L33_AMP_DRV_SEL_MASK,\n\t\tcs35l33->pdata.amp_drv_sel << CS35L33_AMP_DRV_SEL_SHIFT);\n\n\tif (cs35l33->pdata.boost_ipk)\n\t\tcs35l33_set_bst_ipk(component, cs35l33->pdata.boost_ipk);\n\n\tif (cs35l33->enable_soft_ramp) {\n\t\tsnd_soc_component_update_bits(component, CS35L33_DAC_CTL,\n\t\t\tCS35L33_DIGSFT, CS35L33_DIGSFT);\n\t\tsnd_soc_component_update_bits(component, CS35L33_DAC_CTL,\n\t\t\tCS35L33_DSR_RATE, cs35l33->pdata.ramp_rate);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, CS35L33_DAC_CTL,\n\t\t\tCS35L33_DIGSFT, 0);\n\t}\n\n\t \n\tif (cs35l33->pdata.imon_adc_scale != 0x8)\n\t\tsnd_soc_component_update_bits(component, CS35L33_ADC_CTL,\n\t\t\tCS35L33_IMON_SCALE, cs35l33->pdata.imon_adc_scale);\n\n\tcs35l33_set_hg_data(component, &(cs35l33->pdata));\n\n\t \n\tregmap_update_bits(cs35l33->regmap, CS35L33_INT_MASK_1,\n\t\tCS35L33_M_OTE | CS35L33_M_OTW | CS35L33_M_AMP_SHORT |\n\t\tCS35L33_M_CAL_ERR, 0);\n\n\tpm_runtime_put_sync(component->dev);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l33 = {\n\t.probe\t\t\t= cs35l33_probe,\n\t.set_bias_level\t\t= cs35l33_set_bias_level,\n\t.set_sysclk\t\t= cs35l33_component_set_sysclk,\n\t.controls\t\t= cs35l33_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs35l33_snd_controls),\n\t.dapm_widgets\t\t= cs35l33_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs35l33_dapm_widgets),\n\t.dapm_routes\t\t= cs35l33_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs35l33_audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs35l33_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS35L33_MAX_REGISTER,\n\t.reg_defaults = cs35l33_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l33_reg),\n\t.volatile_reg = cs35l33_volatile_register,\n\t.readable_reg = cs35l33_readable_register,\n\t.writeable_reg = cs35l33_writeable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int __maybe_unused cs35l33_runtime_resume(struct device *dev)\n{\n\tstruct cs35l33_private *cs35l33 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tgpiod_set_value_cansleep(cs35l33->reset_gpio, 0);\n\n\tret = regulator_bulk_enable(cs35l33->num_core_supplies,\n\t\tcs35l33->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(cs35l33->regmap, false);\n\n\tgpiod_set_value_cansleep(cs35l33->reset_gpio, 1);\n\n\tmsleep(CS35L33_BOOT_DELAY);\n\n\tret = regcache_sync(cs35l33->regmap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to restore register cache\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tregcache_cache_only(cs35l33->regmap, true);\n\tregulator_bulk_disable(cs35l33->num_core_supplies,\n\t\tcs35l33->core_supplies);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused cs35l33_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l33_private *cs35l33 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\t \n\tcs35l33->amp_cal = false;\n\n\tregcache_cache_only(cs35l33->regmap, true);\n\tregcache_mark_dirty(cs35l33->regmap);\n\tregulator_bulk_disable(cs35l33->num_core_supplies,\n\t\tcs35l33->core_supplies);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cs35l33_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cs35l33_runtime_suspend,\n\t\t\t   cs35l33_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic int cs35l33_get_hg_data(const struct device_node *np,\n\t\t\t       struct cs35l33_pdata *pdata)\n{\n\tstruct device_node *hg;\n\tstruct cs35l33_hg *hg_config = &pdata->hg_config;\n\tu32 val32;\n\n\thg = of_get_child_by_name(np, \"cirrus,hg-algo\");\n\thg_config->enable_hg_algo = hg ? true : false;\n\n\tif (hg_config->enable_hg_algo) {\n\t\tif (of_property_read_u32(hg, \"cirrus,mem-depth\", &val32) >= 0)\n\t\t\thg_config->mem_depth = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,release-rate\",\n\t\t\t\t&val32) >= 0)\n\t\t\thg_config->release_rate = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,ldo-thld\", &val32) >= 0)\n\t\t\thg_config->ldo_thld = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,ldo-path-disable\",\n\t\t\t\t&val32) >= 0)\n\t\t\thg_config->ldo_path_disable = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,ldo-entry-delay\",\n\t\t\t\t&val32) >= 0)\n\t\t\thg_config->ldo_entry_delay = val32;\n\n\t\thg_config->vp_hg_auto = of_property_read_bool(hg,\n\t\t\t\"cirrus,vp-hg-auto\");\n\n\t\tif (of_property_read_u32(hg, \"cirrus,vp-hg\", &val32) >= 0)\n\t\t\thg_config->vp_hg = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,vp-hg-rate\", &val32) >= 0)\n\t\t\thg_config->vp_hg_rate = val32;\n\t\tif (of_property_read_u32(hg, \"cirrus,vp-hg-va\", &val32) >= 0)\n\t\t\thg_config->vp_hg_va = val32;\n\t}\n\n\tof_node_put(hg);\n\n\treturn 0;\n}\n\nstatic irqreturn_t cs35l33_irq_thread(int irq, void *data)\n{\n\tstruct cs35l33_private *cs35l33 = data;\n\tstruct snd_soc_component *component = cs35l33->component;\n\tunsigned int sticky_val1, sticky_val2, current_val, mask1, mask2;\n\n\tregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_2,\n\t\t&sticky_val2);\n\tregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_1,\n\t\t&sticky_val1);\n\tregmap_read(cs35l33->regmap, CS35L33_INT_MASK_2, &mask2);\n\tregmap_read(cs35l33->regmap, CS35L33_INT_MASK_1, &mask1);\n\n\t \n\tif (!(sticky_val1 & ~mask1) && !(sticky_val2 & ~mask2))\n\t\treturn IRQ_NONE;\n\n\tregmap_read(cs35l33->regmap, CS35L33_INT_STATUS_1,\n\t\t&current_val);\n\n\t \n\n\tif (sticky_val1 & CS35L33_AMP_SHORT) {\n\t\tdev_crit(component->dev, \"Amp short error\\n\");\n\t\tif (!(current_val & CS35L33_AMP_SHORT)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Amp short error release\\n\");\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL,\n\t\t\t\tCS35L33_AMP_SHORT_RLS, 0);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL,\n\t\t\t\tCS35L33_AMP_SHORT_RLS,\n\t\t\t\tCS35L33_AMP_SHORT_RLS);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_AMP_SHORT_RLS,\n\t\t\t\t0);\n\t\t}\n\t}\n\n\tif (sticky_val1 & CS35L33_CAL_ERR) {\n\t\tdev_err(component->dev, \"Cal error\\n\");\n\n\t\t \n\t\tcs35l33->amp_cal = false;\n\n\t\tif (!(current_val & CS35L33_CAL_ERR)) {\n\t\t\tdev_dbg(component->dev, \"Cal error release\\n\");\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\n\t\t\t\t0);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\n\t\t\t\tCS35L33_CAL_ERR_RLS);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_CAL_ERR_RLS,\n\t\t\t\t0);\n\t\t}\n\t}\n\n\tif (sticky_val1 & CS35L33_OTE) {\n\t\tdev_crit(component->dev, \"Over temperature error\\n\");\n\t\tif (!(current_val & CS35L33_OTE)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Over temperature error release\\n\");\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTE_RLS, 0);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTE_RLS,\n\t\t\t\tCS35L33_OTE_RLS);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTE_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky_val1 & CS35L33_OTW) {\n\t\tdev_err(component->dev, \"Over temperature warning\\n\");\n\t\tif (!(current_val & CS35L33_OTW)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Over temperature warning release\\n\");\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTW_RLS, 0);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTW_RLS,\n\t\t\t\tCS35L33_OTW_RLS);\n\t\t\tregmap_update_bits(cs35l33->regmap,\n\t\t\t\tCS35L33_AMP_CTL, CS35L33_OTW_RLS, 0);\n\t\t}\n\t}\n\tif (CS35L33_ALIVE_ERR & sticky_val1)\n\t\tdev_err(component->dev, \"ERROR: ADSPCLK Interrupt\\n\");\n\n\tif (CS35L33_MCLK_ERR & sticky_val1)\n\t\tdev_err(component->dev, \"ERROR: MCLK Interrupt\\n\");\n\n\tif (CS35L33_VMON_OVFL & sticky_val2)\n\t\tdev_err(component->dev,\n\t\t\t\"ERROR: VMON Overflow Interrupt\\n\");\n\n\tif (CS35L33_IMON_OVFL & sticky_val2)\n\t\tdev_err(component->dev,\n\t\t\t\"ERROR: IMON Overflow Interrupt\\n\");\n\n\tif (CS35L33_VPMON_OVFL & sticky_val2)\n\t\tdev_err(component->dev,\n\t\t\t\"ERROR: VPMON Overflow Interrupt\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char * const cs35l33_core_supplies[] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstatic int cs35l33_of_get_pdata(struct device *dev,\n\t\t\t\tstruct cs35l33_private *cs35l33)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct cs35l33_pdata *pdata = &cs35l33->pdata;\n\tu32 val32;\n\n\tif (!np)\n\t\treturn 0;\n\n\tif (of_property_read_u32(np, \"cirrus,boost-ctl\", &val32) >= 0) {\n\t\tpdata->boost_ctl = val32;\n\t\tpdata->amp_drv_sel = 1;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,ramp-rate\", &val32) >= 0) {\n\t\tpdata->ramp_rate = val32;\n\t\tcs35l33->enable_soft_ramp = true;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,boost-ipk\", &val32) >= 0)\n\t\tpdata->boost_ipk = val32;\n\n\tif (of_property_read_u32(np, \"cirrus,imon-adc-scale\", &val32) >= 0) {\n\t\tif ((val32 == 0x0) || (val32 == 0x7) || (val32 == 0x6))\n\t\t\tpdata->imon_adc_scale = val32;\n\t\telse\n\t\t\t \n\t\t\tpdata->imon_adc_scale = 0x8;\n\t} else {\n\t\t \n\t\tpdata->imon_adc_scale = 0x8;\n\t}\n\n\tcs35l33_get_hg_data(np, pdata);\n\n\treturn 0;\n}\n\nstatic int cs35l33_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs35l33_private *cs35l33;\n\tstruct cs35l33_pdata *pdata = dev_get_platdata(&i2c_client->dev);\n\tint ret, devid, i;\n\tunsigned int reg;\n\n\tcs35l33 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs35l33_private),\n\t\t\t       GFP_KERNEL);\n\tif (!cs35l33)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c_client, cs35l33);\n\tcs35l33->regmap = devm_regmap_init_i2c(i2c_client, &cs35l33_regmap);\n\tif (IS_ERR(cs35l33->regmap)) {\n\t\tret = PTR_ERR(cs35l33->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(cs35l33->regmap, true);\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l33_core_supplies); i++)\n\t\tcs35l33->core_supplies[i].supply\n\t\t\t= cs35l33_core_supplies[i];\n\tcs35l33->num_core_supplies = ARRAY_SIZE(cs35l33_core_supplies);\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\t\tcs35l33->num_core_supplies,\n\t\t\tcs35l33->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to request core supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs35l33->pdata = *pdata;\n\t} else {\n\t\tcs35l33_of_get_pdata(&i2c_client->dev, cs35l33);\n\t\tpdata = &cs35l33->pdata;\n\t}\n\n\tret = devm_request_threaded_irq(&i2c_client->dev, i2c_client->irq, NULL,\n\t\t\tcs35l33_irq_thread, IRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\"cs35l33\", cs35l33);\n\tif (ret != 0)\n\t\tdev_warn(&i2c_client->dev, \"Failed to request IRQ: %d\\n\", ret);\n\n\t \n\tcs35l33->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\n\t\t\t\"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(cs35l33->reset_gpio)) {\n\t\tdev_err(&i2c_client->dev, \"%s ERROR: Can't get reset GPIO\\n\",\n\t\t\t__func__);\n\t\treturn PTR_ERR(cs35l33->reset_gpio);\n\t}\n\n\tret = regulator_bulk_enable(cs35l33->num_core_supplies,\n\t\t\t\t\tcs35l33->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to enable core supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(cs35l33->reset_gpio, 1);\n\n\tmsleep(CS35L33_BOOT_DELAY);\n\tregcache_cache_only(cs35l33->regmap, false);\n\n\t \n\tdevid = cirrus_read_device_id(cs35l33->regmap, CS35L33_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(&i2c_client->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tif (devid != CS35L33_CHIP_ID) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS35L33 Device ID (%X). Expected ID %X\\n\",\n\t\t\tdevid, CS35L33_CHIP_ID);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = regmap_read(cs35l33->regmap, CS35L33_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tdev_info(&i2c_client->dev,\n\t\t \"Cirrus Logic CS35L33, Revision: %02X\\n\", reg & 0xFF);\n\n\tret = regmap_register_patch(cs35l33->regmap,\n\t\t\tcs35l33_patch, ARRAY_SIZE(cs35l33_patch));\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Error in applying regmap patch: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\tregmap_update_bits(cs35l33->regmap, CS35L33_CLK_CTL,\n\t\tCS35L33_MCLKDIS | CS35L33_SDOUT_3ST_TDM,\n\t\tCS35L33_MCLKDIS | CS35L33_SDOUT_3ST_TDM);\n\n\tpm_runtime_set_autosuspend_delay(&i2c_client->dev, 100);\n\tpm_runtime_use_autosuspend(&i2c_client->dev);\n\tpm_runtime_set_active(&i2c_client->dev);\n\tpm_runtime_enable(&i2c_client->dev);\n\n\tret = devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs35l33, &cs35l33_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"%s: Register component failed\\n\",\n\t\t\t__func__);\n\t\tgoto err_enable;\n\t}\n\n\treturn 0;\n\nerr_enable:\n\tgpiod_set_value_cansleep(cs35l33->reset_gpio, 0);\n\n\tregulator_bulk_disable(cs35l33->num_core_supplies,\n\t\t\t       cs35l33->core_supplies);\n\n\treturn ret;\n}\n\nstatic void cs35l33_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs35l33_private *cs35l33 = i2c_get_clientdata(client);\n\n\tgpiod_set_value_cansleep(cs35l33->reset_gpio, 0);\n\n\tpm_runtime_disable(&client->dev);\n\tregulator_bulk_disable(cs35l33->num_core_supplies,\n\t\tcs35l33->core_supplies);\n}\n\nstatic const struct of_device_id cs35l33_of_match[] = {\n\t{ .compatible = \"cirrus,cs35l33\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs35l33_of_match);\n\nstatic const struct i2c_device_id cs35l33_id[] = {\n\t{\"cs35l33\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs35l33_id);\n\nstatic struct i2c_driver cs35l33_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs35l33\",\n\t\t.pm = &cs35l33_pm_ops,\n\t\t.of_match_table = cs35l33_of_match,\n\n\t\t},\n\t.id_table = cs35l33_id,\n\t.probe = cs35l33_i2c_probe,\n\t.remove = cs35l33_i2c_remove,\n\n};\nmodule_i2c_driver(cs35l33_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS35L33 driver\");\nMODULE_AUTHOR(\"Paul Handrigan, Cirrus Logic Inc, <paul.handrigan@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}