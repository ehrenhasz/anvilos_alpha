{
  "module_name": "ak4613.c",
  "hash_id": "b690206cd18b299c082ce439071b56e445f2b9c0b70de966822b9f6a0ea310d0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4613.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/of_graph.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n\n#define PW_MGMT1\t0x00  \n#define PW_MGMT2\t0x01  \n#define PW_MGMT3\t0x02  \n#define CTRL1\t\t0x03  \n#define CTRL2\t\t0x04  \n#define DEMP1\t\t0x05  \n#define DEMP2\t\t0x06  \n#define OFD\t\t0x07  \n#define ZRD\t\t0x08  \n#define ICTRL\t\t0x09  \n#define OCTRL\t\t0x0a  \n#define LOUT1\t\t0x0b  \n#define ROUT1\t\t0x0c  \n#define LOUT2\t\t0x0d  \n#define ROUT2\t\t0x0e  \n#define LOUT3\t\t0x0f  \n#define ROUT3\t\t0x10  \n#define LOUT4\t\t0x11  \n#define ROUT4\t\t0x12  \n#define LOUT5\t\t0x13  \n#define ROUT5\t\t0x14  \n#define LOUT6\t\t0x15  \n#define ROUT6\t\t0x16  \n\n \n#define RSTN\t\tBIT(0)\n#define PMDAC\t\tBIT(1)\n#define PMADC\t\tBIT(2)\n#define PMVR\t\tBIT(3)\n\n \n#define PMAD_ALL\t0x7\n\n \n#define PMDA_ALL\t0x3f\n\n \n#define DIF0\t\tBIT(3)\n#define DIF1\t\tBIT(4)\n#define DIF2\t\tBIT(5)\n#define TDM0\t\tBIT(6)\n#define TDM1\t\tBIT(7)\n#define NO_FMT\t\t(0xff)\n#define FMT_MASK\t(0xf8)\n\n \n#define DFS_MASK\t\t(3 << 2)\n#define DFS_NORMAL_SPEED\t(0 << 2)\n#define DFS_DOUBLE_SPEED\t(1 << 2)\n#define DFS_QUAD_SPEED\t\t(2 << 2)\n\n \n#define ICTRL_MASK\t(0x3)\n\n \n#define OCTRL_MASK\t(0x3F)\n\n \n#define AK4613_CONFIG_SET(priv, x)\t priv->configs |= AK4613_CONFIG_##x\n#define AK4613_CONFIG_GET(priv, x)\t(priv->configs &  AK4613_CONFIG_##x##_MASK)\n\n \n#define AK4613_CONFIG_SDTI_MASK\t\t(0xF << 4)\n#define AK4613_CONFIG_SDTI(x)\t\t(((x) & 0xF) << 4)\n#define AK4613_CONFIG_SDTI_set(priv, x)\t  AK4613_CONFIG_SET(priv, SDTI(x))\n#define AK4613_CONFIG_SDTI_get(priv)\t((AK4613_CONFIG_GET(priv, SDTI) >> 4) & 0xF)\n\n \n#define AK4613_CONFIG_MODE_MASK\t\t(0xF)\n#define AK4613_CONFIG_MODE_STEREO\t(0x0)\n#define AK4613_CONFIG_MODE_TDM512\t(0x1)\n#define AK4613_CONFIG_MODE_TDM256\t(0x2)\n#define AK4613_CONFIG_MODE_TDM128\t(0x3)\n\n \n\nstruct ak4613_interface {\n\tunsigned int width;\n\tunsigned int fmt;\n\tu8 dif;\n};\n\nstruct ak4613_priv {\n\tstruct mutex lock;\n\tstruct snd_pcm_hw_constraint_list constraint_rates;\n\tstruct snd_pcm_hw_constraint_list constraint_channels;\n\tstruct work_struct dummy_write_work;\n\tstruct snd_soc_component *component;\n\tunsigned int rate;\n\tunsigned int sysclk;\n\n\tunsigned int fmt;\n\tunsigned int configs;\n\tint cnt;\n\tu8 ctrl1;\n\tu8 oc;\n\tu8 ic;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12750, 50, 1);\n\nstatic const struct snd_kcontrol_new ak4613_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume1\", LOUT1, ROUT1,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume2\", LOUT2, ROUT2,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume3\", LOUT3, ROUT3,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume4\", LOUT4, ROUT4,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume5\", LOUT5, ROUT5,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume6\", LOUT6, ROUT6,\n\t\t\t 0, 0xFF, 1, out_tlv),\n};\n\nstatic const struct reg_default ak4613_reg[] = {\n\t{ 0x0,  0x0f }, { 0x1,  0x07 }, { 0x2,  0x3f }, { 0x3,  0x20 },\n\t{ 0x4,  0x20 }, { 0x5,  0x55 }, { 0x6,  0x05 }, { 0x7,  0x07 },\n\t{ 0x8,  0x0f }, { 0x9,  0x07 }, { 0xa,  0x3f }, { 0xb,  0x00 },\n\t{ 0xc,  0x00 }, { 0xd,  0x00 }, { 0xe,  0x00 }, { 0xf,  0x00 },\n\t{ 0x10, 0x00 }, { 0x11, 0x00 }, { 0x12, 0x00 }, { 0x13, 0x00 },\n\t{ 0x14, 0x00 }, { 0x15, 0x00 }, { 0x16, 0x00 },\n};\n\n \n#define AUDIO_IFACE(_dif, _width, _fmt)\t\t\\\n\t{\t\t\t\t\t\\\n\t\t.dif\t= _dif,\t\t\t\\\n\t\t.width\t= _width,\t\t\\\n\t\t.fmt\t= SND_SOC_DAIFMT_##_fmt,\\\n\t}\nstatic const struct ak4613_interface ak4613_iface[] = {\n\t \n\n\tAUDIO_IFACE(0x03, 24, LEFT_J),\n\tAUDIO_IFACE(0x04, 24, I2S),\n};\n#define AK4613_CTRL1_TO_MODE(priv)\t((priv)->ctrl1 >> 6)  \n\nstatic const struct regmap_config ak4613_regmap_cfg = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= 0x16,\n\t.reg_defaults\t\t= ak4613_reg,\n\t.num_reg_defaults\t= ARRAY_SIZE(ak4613_reg),\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct of_device_id ak4613_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4613\",\t.data = &ak4613_regmap_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ak4613_of_match);\n\nstatic const struct i2c_device_id ak4613_i2c_id[] = {\n\t{ \"ak4613\", (kernel_ulong_t)&ak4613_regmap_cfg },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ak4613_i2c_id);\n\nstatic const struct snd_soc_dapm_widget ak4613_dapm_widgets[] = {\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"LOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT4\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT5\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT6\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"ROUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT4\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT5\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT6\"),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"LIN1\"),\n\tSND_SOC_DAPM_INPUT(\"LIN2\"),\n\n\tSND_SOC_DAPM_INPUT(\"RIN1\"),\n\tSND_SOC_DAPM_INPUT(\"RIN2\"),\n\n\t \n\tSND_SOC_DAPM_DAC(\"DAC1\", NULL, PW_MGMT3, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC2\", NULL, PW_MGMT3, 1, 0),\n\tSND_SOC_DAPM_DAC(\"DAC3\", NULL, PW_MGMT3, 2, 0),\n\tSND_SOC_DAPM_DAC(\"DAC4\", NULL, PW_MGMT3, 3, 0),\n\tSND_SOC_DAPM_DAC(\"DAC5\", NULL, PW_MGMT3, 4, 0),\n\tSND_SOC_DAPM_DAC(\"DAC6\", NULL, PW_MGMT3, 5, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC1\", NULL, PW_MGMT2, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC2\", NULL, PW_MGMT2, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_route ak4613_intercon[] = {\n\t{\"LOUT1\", NULL, \"DAC1\"},\n\t{\"LOUT2\", NULL, \"DAC2\"},\n\t{\"LOUT3\", NULL, \"DAC3\"},\n\t{\"LOUT4\", NULL, \"DAC4\"},\n\t{\"LOUT5\", NULL, \"DAC5\"},\n\t{\"LOUT6\", NULL, \"DAC6\"},\n\n\t{\"ROUT1\", NULL, \"DAC1\"},\n\t{\"ROUT2\", NULL, \"DAC2\"},\n\t{\"ROUT3\", NULL, \"DAC3\"},\n\t{\"ROUT4\", NULL, \"DAC4\"},\n\t{\"ROUT5\", NULL, \"DAC5\"},\n\t{\"ROUT6\", NULL, \"DAC6\"},\n\n\t{\"DAC1\", NULL, \"Playback\"},\n\t{\"DAC2\", NULL, \"Playback\"},\n\t{\"DAC3\", NULL, \"Playback\"},\n\t{\"DAC4\", NULL, \"Playback\"},\n\t{\"DAC5\", NULL, \"Playback\"},\n\t{\"DAC6\", NULL, \"Playback\"},\n\n\t{\"Capture\", NULL, \"ADC1\"},\n\t{\"Capture\", NULL, \"ADC2\"},\n\n\t{\"ADC1\", NULL, \"LIN1\"},\n\t{\"ADC2\", NULL, \"LIN2\"},\n\n\t{\"ADC1\", NULL, \"RIN1\"},\n\t{\"ADC2\", NULL, \"RIN2\"},\n};\n\nstatic void ak4613_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = component->dev;\n\n\tmutex_lock(&priv->lock);\n\tpriv->cnt--;\n\tif (priv->cnt < 0) {\n\t\tdev_err(dev, \"unexpected counter error\\n\");\n\t\tpriv->cnt = 0;\n\t}\n\tif (!priv->cnt)\n\t\tpriv->ctrl1 = 0;\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void ak4613_hw_constraints(struct ak4613_priv *priv,\n\t\t\t\t  struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstatic const unsigned int ak4613_rates[] = {\n\t\t 32000,\n\t\t 44100,\n\t\t 48000,\n\t\t 64000,\n\t\t 88200,\n\t\t 96000,\n\t\t176400,\n\t\t192000,\n\t};\n#define AK4613_CHANNEL_2\t 0\n#define AK4613_CHANNEL_4\t 1\n#define AK4613_CHANNEL_8\t 2\n#define AK4613_CHANNEL_12\t 3\n#define AK4613_CHANNEL_NONE\t-1\n\tstatic const unsigned int ak4613_channels[] = {\n\t\t[AK4613_CHANNEL_2]  =  2,\n\t\t[AK4613_CHANNEL_4]  =  4,\n\t\t[AK4613_CHANNEL_8]  =  8,\n\t\t[AK4613_CHANNEL_12] = 12,\n\t};\n#define MODE_MAX 4\n#define SDTx_MAX 4\n#define MASK(x) (1 << AK4613_CHANNEL_##x)\n\tstatic const int mask_list[MODE_MAX][SDTx_MAX] = {\n\t\t \n\t\t[AK4613_CONFIG_MODE_STEREO] = { MASK(2), MASK(2),  MASK(2),\t\tMASK(2)},\n\t\t[AK4613_CONFIG_MODE_TDM512] = { MASK(4), MASK(12), MASK(12),\t\tMASK(12)},\n\t\t[AK4613_CONFIG_MODE_TDM256] = { MASK(4), MASK(8),  MASK(8)|MASK(12),\tMASK(8)|MASK(12)},\n\t\t[AK4613_CONFIG_MODE_TDM128] = { MASK(4), MASK(4),  MASK(4)|MASK(8),\tMASK(4)|MASK(8)|MASK(12)},\n\t};\n\tstruct snd_pcm_hw_constraint_list *constraint;\n\tunsigned int mask;\n\tunsigned int mode;\n\tunsigned int fs;\n\tint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint sdti_num;\n\tint i;\n\n\tconstraint\t\t= &priv->constraint_rates;\n\tconstraint->list\t= ak4613_rates;\n\tconstraint->mask\t= 0;\n\tconstraint->count\t= 0;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ak4613_rates); i++) {\n\t\t \n\t\tfs = (ak4613_rates[i] <= 96000) ? 256 : 128;\n\n\t\tif (priv->sysclk >= ak4613_rates[i] * fs)\n\t\t\tconstraint->count = i + 1;\n\t}\n\n\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE, constraint);\n\n\n\tsdti_num = AK4613_CONFIG_SDTI_get(priv);\n\tif (WARN_ON(sdti_num >= SDTx_MAX))\n\t\treturn;\n\n\tif (priv->cnt) {\n\t\t \n\t\tmode = AK4613_CTRL1_TO_MODE(priv);\n\t\tmask = 0;  \n\t} else {\n\t\t \n\t\tmode = AK4613_CONFIG_GET(priv, MODE);\n\t\tmask = mask_list[AK4613_CONFIG_MODE_STEREO][is_play * sdti_num];\n\t}\n\n\tif (WARN_ON(mode >= MODE_MAX))\n\t\treturn;\n\n\t \n\tmask |= mask_list[mode][is_play * sdti_num];\n\n\tconstraint\t\t= &priv->constraint_channels;\n\tconstraint->list\t= ak4613_channels;\n\tconstraint->mask\t= mask;\n\tconstraint->count\t= sizeof(ak4613_channels);\n\tsnd_pcm_hw_constraint_list(runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, constraint);\n}\n\nstatic int ak4613_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&priv->lock);\n\tak4613_hw_constraints(priv, substream);\n\tpriv->cnt++;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int ak4613_dai_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tpriv->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int ak4613_dai_set_fmt(struct snd_soc_dai *dai, unsigned int format)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int fmt;\n\n\tfmt = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\tswitch (fmt) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpriv->fmt = fmt;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfmt = format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tswitch (fmt) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ak4613_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = component->dev;\n\tunsigned int width = params_width(params);\n\tunsigned int fmt = priv->fmt;\n\tunsigned int rate;\n\tint i, ret;\n\tu8 ctrl2;\n\n\trate = params_rate(params);\n\tswitch (rate) {\n\tcase 32000:\n\tcase 44100:\n\tcase 48000:\n\t\tctrl2 = DFS_NORMAL_SPEED;\n\t\tbreak;\n\tcase 64000:\n\tcase 88200:\n\tcase 96000:\n\t\tctrl2 = DFS_DOUBLE_SPEED;\n\t\tbreak;\n\tcase 176400:\n\tcase 192000:\n\t\tctrl2 = DFS_QUAD_SPEED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tpriv->rate = rate;\n\n\t \n\tret = -EINVAL;\n\n\tmutex_lock(&priv->lock);\n\tif (priv->cnt > 1) {\n\t\t \n\t\tret = 0;\n\t} else {\n\t\t \n\t\tunsigned int channel = params_channels(params);\n\t\tu8 tdm;\n\n\t\t \n\t\tif (channel == 2)\n\t\t\ttdm = AK4613_CONFIG_MODE_STEREO;\n\t\telse\n\t\t\ttdm = AK4613_CONFIG_GET(priv, MODE);\n\n\t\tfor (i = ARRAY_SIZE(ak4613_iface) - 1; i >= 0; i--) {\n\t\t\tconst struct ak4613_interface *iface = ak4613_iface + i;\n\n\t\t\tif ((iface->fmt == fmt) && (iface->width == width)) {\n\t\t\t\t \n\t\t\t\tpriv->ctrl1 = (tdm << 6) | (iface->dif << 3);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&priv->lock);\n\n\tif (ret < 0)\n\t\tgoto hw_params_end;\n\n\tsnd_soc_component_update_bits(component, CTRL1, FMT_MASK, priv->ctrl1);\n\tsnd_soc_component_update_bits(component, CTRL2, DFS_MASK, ctrl2);\n\n\tsnd_soc_component_update_bits(component, ICTRL, ICTRL_MASK, priv->ic);\n\tsnd_soc_component_update_bits(component, OCTRL, OCTRL_MASK, priv->oc);\n\nhw_params_end:\n\tif (ret < 0)\n\t\tdev_warn(dev, \"unsupported data width/format combination\\n\");\n\n\treturn ret;\n}\n\nstatic int ak4613_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tu8 mgmt1 = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tmgmt1 |= RSTN;\n\t\tfallthrough;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tmgmt1 |= PMADC | PMDAC;\n\t\tfallthrough;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tmgmt1 |= PMVR;\n\t\tfallthrough;\n\tcase SND_SOC_BIAS_OFF:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, PW_MGMT1, mgmt1);\n\n\treturn 0;\n}\n\nstatic void ak4613_dummy_write(struct work_struct *work)\n{\n\tstruct ak4613_priv *priv = container_of(work,\n\t\t\t\t\t\tstruct ak4613_priv,\n\t\t\t\t\t\tdummy_write_work);\n\tstruct snd_soc_component *component = priv->component;\n\tunsigned int mgmt1;\n\tunsigned int mgmt3;\n\n\t \n\tudelay(5000000 / priv->rate);\n\n\tmgmt1 = snd_soc_component_read(component, PW_MGMT1);\n\tmgmt3 = snd_soc_component_read(component, PW_MGMT3);\n\n\tsnd_soc_component_write(component, PW_MGMT1, mgmt1);\n\tsnd_soc_component_write(component, PW_MGMT3, mgmt3);\n}\n\nstatic int ak4613_dai_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4613_priv *priv = snd_soc_component_get_drvdata(component);\n\n\t \n\n\tif ((cmd != SNDRV_PCM_TRIGGER_START) &&\n\t    (cmd != SNDRV_PCM_TRIGGER_RESUME))\n\t\treturn 0;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn  0;\n\n\tpriv->component = component;\n\tschedule_work(&priv->dummy_write_work);\n\n\treturn 0;\n}\n\n \nstatic u64 ak4613_dai_formats =\n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J;\n\nstatic const struct snd_soc_dai_ops ak4613_dai_ops = {\n\t.startup\t= ak4613_dai_startup,\n\t.shutdown\t= ak4613_dai_shutdown,\n\t.set_sysclk\t= ak4613_dai_set_sysclk,\n\t.set_fmt\t= ak4613_dai_set_fmt,\n\t.trigger\t= ak4613_dai_trigger,\n\t.hw_params\t= ak4613_dai_hw_params,\n\t.auto_selectable_formats\t= &ak4613_dai_formats,\n\t.num_auto_selectable_formats\t= 1,\n};\n\n#define AK4613_PCM_RATE\t\t(SNDRV_PCM_RATE_32000  |\\\n\t\t\t\t SNDRV_PCM_RATE_44100  |\\\n\t\t\t\t SNDRV_PCM_RATE_48000  |\\\n\t\t\t\t SNDRV_PCM_RATE_64000  |\\\n\t\t\t\t SNDRV_PCM_RATE_88200  |\\\n\t\t\t\t SNDRV_PCM_RATE_96000  |\\\n\t\t\t\t SNDRV_PCM_RATE_176400 |\\\n\t\t\t\t SNDRV_PCM_RATE_192000)\n#define AK4613_PCM_FMTBIT\t(SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver ak4613_dai = {\n\t.name = \"ak4613-hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 12,\n\t\t.rates\t\t= AK4613_PCM_RATE,\n\t\t.formats\t= AK4613_PCM_FMTBIT,\n\t},\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 4,\n\t\t.rates\t\t= AK4613_PCM_RATE,\n\t\t.formats\t= AK4613_PCM_FMTBIT,\n\t},\n\t.ops = &ak4613_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int ak4613_suspend(struct snd_soc_component *component)\n{\n\tstruct regmap *regmap = dev_get_regmap(component->dev, NULL);\n\n\tregcache_cache_only(regmap, true);\n\tregcache_mark_dirty(regmap);\n\treturn 0;\n}\n\nstatic int ak4613_resume(struct snd_soc_component *component)\n{\n\tstruct regmap *regmap = dev_get_regmap(component->dev, NULL);\n\n\tregcache_cache_only(regmap, false);\n\treturn regcache_sync(regmap);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ak4613 = {\n\t.suspend\t\t= ak4613_suspend,\n\t.resume\t\t\t= ak4613_resume,\n\t.set_bias_level\t\t= ak4613_set_bias_level,\n\t.controls\t\t= ak4613_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4613_snd_controls),\n\t.dapm_widgets\t\t= ak4613_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4613_dapm_widgets),\n\t.dapm_routes\t\t= ak4613_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4613_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void ak4613_parse_of(struct ak4613_priv *priv,\n\t\t\t    struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tchar prop[32];\n\tint sdti_num;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tsnprintf(prop, sizeof(prop), \"asahi-kasei,in%d-single-end\", i + 1);\n\t\tif (!of_get_property(np, prop, NULL))\n\t\t\tpriv->ic |= 1 << i;\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tsnprintf(prop, sizeof(prop), \"asahi-kasei,out%d-single-end\", i + 1);\n\t\tif (!of_get_property(np, prop, NULL))\n\t\t\tpriv->oc |= 1 << i;\n\t}\n\n\t \n#if defined(AK4613_ENABLE_TDM_TEST)\n\tAK4613_CONFIG_SET(priv, MODE_TDM256);\n#endif\n\n\t \n\tsdti_num = of_graph_get_endpoint_count(np);\n\tif ((sdti_num >= SDTx_MAX) || (sdti_num < 1))\n\t\tsdti_num = 1;\n\n\tAK4613_CONFIG_SDTI_set(priv, sdti_num);\n}\n\nstatic int ak4613_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tconst struct regmap_config *regmap_cfg;\n\tstruct regmap *regmap;\n\tstruct ak4613_priv *priv;\n\n\tregmap_cfg = i2c_get_match_data(i2c);\n\tif (!regmap_cfg)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tak4613_parse_of(priv, dev);\n\n\tpriv->ctrl1\t\t= 0;\n\tpriv->cnt\t\t= 0;\n\tpriv->sysclk\t\t= 0;\n\tINIT_WORK(&priv->dummy_write_work, ak4613_dummy_write);\n\n\tmutex_init(&priv->lock);\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tregmap = devm_regmap_init_i2c(i2c, regmap_cfg);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_dev_ak4613,\n\t\t\t\t      &ak4613_dai, 1);\n}\n\nstatic struct i2c_driver ak4613_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4613-codec\",\n\t\t.of_match_table = ak4613_of_match,\n\t},\n\t.probe\t\t= ak4613_i2c_probe,\n\t.id_table\t= ak4613_i2c_id,\n};\n\nmodule_i2c_driver(ak4613_i2c_driver);\n\nMODULE_DESCRIPTION(\"Soc AK4613 driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}