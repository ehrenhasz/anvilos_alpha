{
  "module_name": "wm8955.c",
  "hash_id": "41e5a404e6513a9381e564b0cbf854b430c16becbdfac0b2ff1ee60cd9f55a43",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8955.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/wm8955.h>\n\n#include \"wm8955.h\"\n\n#define WM8955_NUM_SUPPLIES 4\nstatic const char *wm8955_supply_names[WM8955_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"HPVDD\",\n\t\"AVDD\",\n};\n\n \nstruct wm8955_priv {\n\tstruct regmap *regmap;\n\n\tunsigned int mclk_rate;\n\n\tint deemph;\n\tint fs;\n\n\tstruct regulator_bulk_data supplies[WM8955_NUM_SUPPLIES];\n};\n\nstatic const struct reg_default wm8955_reg_defaults[] = {\n\t{ 2,  0x0079 },      \n\t{ 3,  0x0079 },      \n\t{ 5,  0x0008 },      \n\t{ 7,  0x000A },      \n\t{ 8,  0x0000 },      \n\t{ 10, 0x00FF },      \n\t{ 11, 0x00FF },      \n\t{ 12, 0x000F },      \n\t{ 13, 0x000F },      \n\t{ 23, 0x00C1 },      \n\t{ 24, 0x0000 },      \n\t{ 25, 0x0000 },      \n\t{ 26, 0x0000 },      \n\t{ 27, 0x0000 },      \n\t{ 34, 0x0050 },      \n\t{ 35, 0x0050 },      \n\t{ 36, 0x0050 },      \n\t{ 37, 0x0050 },      \n\t{ 38, 0x0050 },      \n\t{ 39, 0x0050 },      \n\t{ 40, 0x0079 },      \n\t{ 41, 0x0079 },      \n\t{ 42, 0x0079 },      \n\t{ 43, 0x0000 },      \n\t{ 44, 0x0103 },      \n\t{ 45, 0x0024 },      \n\t{ 46, 0x01BA },      \n\t{ 59, 0x0000 },      \n};\n\nstatic bool wm8955_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8955_LOUT1_VOLUME:\n\tcase WM8955_ROUT1_VOLUME:\n\tcase WM8955_DAC_CONTROL:\n\tcase WM8955_AUDIO_INTERFACE:\n\tcase WM8955_SAMPLE_RATE:\n\tcase WM8955_LEFT_DAC_VOLUME:\n\tcase WM8955_RIGHT_DAC_VOLUME:\n\tcase WM8955_BASS_CONTROL:\n\tcase WM8955_TREBLE_CONTROL:\n\tcase WM8955_RESET:\n\tcase WM8955_ADDITIONAL_CONTROL_1:\n\tcase WM8955_ADDITIONAL_CONTROL_2:\n\tcase WM8955_POWER_MANAGEMENT_1:\n\tcase WM8955_POWER_MANAGEMENT_2:\n\tcase WM8955_ADDITIONAL_CONTROL_3:\n\tcase WM8955_LEFT_OUT_MIX_1:\n\tcase WM8955_LEFT_OUT_MIX_2:\n\tcase WM8955_RIGHT_OUT_MIX_1:\n\tcase WM8955_RIGHT_OUT_MIX_2:\n\tcase WM8955_MONO_OUT_MIX_1:\n\tcase WM8955_MONO_OUT_MIX_2:\n\tcase WM8955_LOUT2_VOLUME:\n\tcase WM8955_ROUT2_VOLUME:\n\tcase WM8955_MONOOUT_VOLUME:\n\tcase WM8955_CLOCKING_PLL:\n\tcase WM8955_PLL_CONTROL_1:\n\tcase WM8955_PLL_CONTROL_2:\n\tcase WM8955_PLL_CONTROL_3:\n\tcase WM8955_PLL_CONTROL_4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8955_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8955_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8955_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8955_RESET, 0);\n}\n\nstruct pll_factors {\n\tint n;\n\tint k;\n\tint outdiv;\n};\n\n \n#define FIXED_FLL_SIZE ((1 << 22) * 10)\n\nstatic int wm8955_pll_factors(struct device *dev,\n\t\t\t      int Fref, int Fout, struct pll_factors *pll)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod, target;\n\n\tdev_dbg(dev, \"Fref=%u Fout=%u\\n\", Fref, Fout);\n\n\t \n\ttarget = Fout * 4;\n\tif (target < 90000000) {\n\t\tpll->outdiv = 1;\n\t\ttarget *= 2;\n\t} else {\n\t\tpll->outdiv = 0;\n\t}\n\n\tWARN_ON(target < 90000000 || target > 100000000);\n\n\tdev_dbg(dev, \"Fvco=%dHz\\n\", target);\n\n\t \n\tNdiv = target / Fref;\n\n\tpll->n = Ndiv;\n\tNmod = target % Fref;\n\tdev_dbg(dev, \"Nmod=%d\\n\", Nmod);\n\n\t \n\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, Fref);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tpll->k = K / 10;\n\n\tdev_dbg(dev, \"N=%x K=%x OUTDIV=%x\\n\", pll->n, pll->k, pll->outdiv);\n\n\treturn 0;\n}\n\n \nstatic struct {\n\tint mclk;\n\tint fs;\n\tint usb;\n\tint sr;\n} clock_cfgs[] = {\n\t{ 18432000,  8000, 0,  3, },\n\t{ 18432000, 12000, 0,  9, },\n\t{ 18432000, 16000, 0, 11, },\n\t{ 18432000, 24000, 0, 29, },\n\t{ 18432000, 32000, 0, 13, },\n\t{ 18432000, 48000, 0,  1, },\n\t{ 18432000, 96000, 0, 15, },\n\n\t{ 16934400,  8018, 0, 19, },\n\t{ 16934400, 11025, 0, 25, },\n\t{ 16934400, 22050, 0, 27, },\n\t{ 16934400, 44100, 0, 17, },\n\t{ 16934400, 88200, 0, 31, },\n\n\t{ 12000000,  8000, 1,  2, },\n\t{ 12000000, 11025, 1, 25, },\n\t{ 12000000, 12000, 1,  8, },\n\t{ 12000000, 16000, 1, 10, },\n\t{ 12000000, 22050, 1, 27, },\n\t{ 12000000, 24000, 1, 28, },\n\t{ 12000000, 32000, 1, 12, },\n\t{ 12000000, 44100, 1, 17, },\n\t{ 12000000, 48000, 1,  0, },\n\t{ 12000000, 88200, 1, 31, },\n\t{ 12000000, 96000, 1, 14, },\n\n\t{ 12288000,  8000, 0,  2, },\n\t{ 12288000, 12000, 0,  8, },\n\t{ 12288000, 16000, 0, 10, },\n\t{ 12288000, 24000, 0, 28, },\n\t{ 12288000, 32000, 0, 12, },\n\t{ 12288000, 48000, 0,  0, },\n\t{ 12288000, 96000, 0, 14, },\n\n\t{ 12289600,  8018, 0, 18, },\n\t{ 12289600, 11025, 0, 24, },\n\t{ 12289600, 22050, 0, 26, },\n\t{ 11289600, 44100, 0, 16, },\n\t{ 11289600, 88200, 0, 31, },\n};\n\nstatic int wm8955_configure_clocking(struct snd_soc_component *component)\n{\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tint i, ret, val;\n\tint clocking = 0;\n\tint srate = 0;\n\tint sr = -1;\n\tstruct pll_factors pll;\n\n\t \n\tif (wm8955->fs == 0)\n\t\twm8955->fs = 8000;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(clock_cfgs); i++) {\n\t\tif (wm8955->fs != clock_cfgs[i].fs)\n\t\t\tcontinue;\n\t\tsr = i;\n\n\t\tif (wm8955->mclk_rate == clock_cfgs[i].mclk)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (sr == -1) {\n\t\tdev_err(component->dev, \"Sample rate %dHz unsupported\\n\",\n\t\t\twm8955->fs);\n\t\tWARN_ON(sr == -1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (i == ARRAY_SIZE(clock_cfgs)) {\n\t\t \n\t\tclocking |= WM8955_MCLKSEL;\n\n\t\t \n\t\tret = wm8955_pll_factors(component->dev, wm8955->mclk_rate,\n\t\t\t\t\t clock_cfgs[sr].mclk, &pll);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Unable to generate %dHz from %dHz MCLK\\n\",\n\t\t\t\twm8955->fs, wm8955->mclk_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, WM8955_PLL_CONTROL_1,\n\t\t\t\t    WM8955_N_MASK | WM8955_K_21_18_MASK,\n\t\t\t\t    (pll.n << WM8955_N_SHIFT) |\n\t\t\t\t    pll.k >> 18);\n\t\tsnd_soc_component_update_bits(component, WM8955_PLL_CONTROL_2,\n\t\t\t\t    WM8955_K_17_9_MASK,\n\t\t\t\t    (pll.k >> 9) & WM8955_K_17_9_MASK);\n\t\tsnd_soc_component_update_bits(component, WM8955_PLL_CONTROL_3,\n\t\t\t\t    WM8955_K_8_0_MASK,\n\t\t\t\t    pll.k & WM8955_K_8_0_MASK);\n\t\tif (pll.k)\n\t\t\tsnd_soc_component_update_bits(component, WM8955_PLL_CONTROL_4,\n\t\t\t\t\t    WM8955_KEN, WM8955_KEN);\n\t\telse\n\t\t\tsnd_soc_component_update_bits(component, WM8955_PLL_CONTROL_4,\n\t\t\t\t\t    WM8955_KEN, 0);\n\n\t\tif (pll.outdiv)\n\t\t\tval = WM8955_PLL_RB | WM8955_PLLOUTDIV2;\n\t\telse\n\t\t\tval = WM8955_PLL_RB;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_CLOCKING_PLL,\n\t\t\t\t    WM8955_PLL_RB | WM8955_PLLOUTDIV2, val);\n\t\tsnd_soc_component_update_bits(component, WM8955_CLOCKING_PLL,\n\t\t\t\t    WM8955_PLLEN, WM8955_PLLEN);\n\t}\n\n\tsrate = clock_cfgs[sr].usb | (clock_cfgs[sr].sr << WM8955_SR_SHIFT);\n\n\tsnd_soc_component_update_bits(component, WM8955_SAMPLE_RATE,\n\t\t\t    WM8955_USB | WM8955_SR_MASK, srate);\n\tsnd_soc_component_update_bits(component, WM8955_CLOCKING_PLL,\n\t\t\t    WM8955_MCLKSEL, clocking);\n\n\treturn 0;\n}\n\nstatic int wm8955_sysclk(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tint ret = 0;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t    WM8955_DIGENB, 0);\n\tsnd_soc_component_update_bits(component, WM8955_CLOCKING_PLL,\n\t\t\t    WM8955_PLL_RB | WM8955_PLLEN, 0);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = wm8955_configure_clocking(component);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int deemph_settings[] = { 0, 32000, 44100, 48000 };\n\nstatic int wm8955_set_deemph(struct snd_soc_component *component)\n{\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (wm8955->deemph) {\n\t\tbest = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\n\t\t\tif (abs(deemph_settings[i] - wm8955->fs) <\n\t\t\t    abs(deemph_settings[best] - wm8955->fs))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = best << WM8955_DEEMPH_SHIFT;\n\t} else {\n\t\tval = 0;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d\\n\", val);\n\n\treturn snd_soc_component_update_bits(component, WM8955_DAC_CONTROL,\n\t\t\t\t   WM8955_DEEMPH_MASK, val);\n}\n\nstatic int wm8955_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8955->deemph;\n\treturn 0;\n}\n\nstatic int wm8955_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\twm8955->deemph = deemph;\n\n\treturn wm8955_set_deemph(component);\n}\n\nstatic const char *bass_mode_text[] = {\n\t\"Linear\", \"Adaptive\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(bass_mode, WM8955_BASS_CONTROL, 7, bass_mode_text);\n\nstatic const char *bass_cutoff_text[] = {\n\t\"Low\", \"High\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(bass_cutoff, WM8955_BASS_CONTROL, 6,\n\t\t\t    bass_cutoff_text);\n\nstatic const char *treble_cutoff_text[] = {\n\t\"High\", \"Low\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(treble_cutoff, WM8955_TREBLE_CONTROL, 2,\n\t\t\t    treble_cutoff_text);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(atten_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(mono_tlv, -2100, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(treble_tlv, -1200, 150, 1);\n\nstatic const struct snd_kcontrol_new wm8955_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", WM8955_LEFT_DAC_VOLUME,\n\t\t WM8955_RIGHT_DAC_VOLUME, 0, 255, 0, digital_tlv),\nSOC_SINGLE_TLV(\"Playback Attenuation Volume\", WM8955_DAC_CONTROL, 7, 1, 1,\n\t       atten_tlv),\nSOC_SINGLE_BOOL_EXT(\"DAC Deemphasis Switch\", 0,\n\t\t    wm8955_get_deemph, wm8955_put_deemph),\n\nSOC_ENUM(\"Bass Mode\", bass_mode),\nSOC_ENUM(\"Bass Cutoff\", bass_cutoff),\nSOC_SINGLE(\"Bass Volume\", WM8955_BASS_CONTROL, 0, 15, 1),\n\nSOC_ENUM(\"Treble Cutoff\", treble_cutoff),\nSOC_SINGLE_TLV(\"Treble Volume\", WM8955_TREBLE_CONTROL, 0, 14, 1, treble_tlv),\n\nSOC_SINGLE_TLV(\"Left Bypass Volume\", WM8955_LEFT_OUT_MIX_1, 4, 7, 1,\n\t       bypass_tlv),\nSOC_SINGLE_TLV(\"Left Mono Volume\", WM8955_LEFT_OUT_MIX_2, 4, 7, 1,\n\t       bypass_tlv),\n\nSOC_SINGLE_TLV(\"Right Mono Volume\", WM8955_RIGHT_OUT_MIX_1, 4, 7, 1,\n\t       bypass_tlv),\nSOC_SINGLE_TLV(\"Right Bypass Volume\", WM8955_RIGHT_OUT_MIX_2, 4, 7, 1,\n\t       bypass_tlv),\n\n \nSOC_SINGLE_TLV(\"Mono Left Bypass Volume\", WM8955_MONO_OUT_MIX_1, 4, 7, 1,\n\t       mono_tlv),\nSOC_SINGLE_TLV(\"Mono Right Bypass Volume\", WM8955_MONO_OUT_MIX_2, 4, 7, 1,\n\t       mono_tlv),\n\nSOC_DOUBLE_R_TLV(\"Headphone Volume\", WM8955_LOUT1_VOLUME,\n\t\t WM8955_ROUT1_VOLUME, 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Headphone ZC Switch\", WM8955_LOUT1_VOLUME,\n\t     WM8955_ROUT1_VOLUME, 7, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Speaker Volume\", WM8955_LOUT2_VOLUME,\n\t\t WM8955_ROUT2_VOLUME, 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Speaker ZC Switch\", WM8955_LOUT2_VOLUME,\n\t     WM8955_ROUT2_VOLUME, 7, 1, 0),\n\nSOC_SINGLE_TLV(\"Mono Volume\", WM8955_MONOOUT_VOLUME, 0, 127, 0, out_tlv),\nSOC_SINGLE(\"Mono ZC Switch\", WM8955_MONOOUT_VOLUME, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new lmixer[] = {\nSOC_DAPM_SINGLE(\"Playback Switch\", WM8955_LEFT_OUT_MIX_1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Switch\", WM8955_LEFT_OUT_MIX_1, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Right Playback Switch\", WM8955_LEFT_OUT_MIX_2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Mono Switch\", WM8955_LEFT_OUT_MIX_2, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new rmixer[] = {\nSOC_DAPM_SINGLE(\"Left Playback Switch\", WM8955_RIGHT_OUT_MIX_1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Mono Switch\", WM8955_RIGHT_OUT_MIX_1, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Playback Switch\", WM8955_RIGHT_OUT_MIX_2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Switch\", WM8955_RIGHT_OUT_MIX_2, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mmixer[] = {\nSOC_DAPM_SINGLE(\"Left Playback Switch\", WM8955_MONO_OUT_MIX_1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Left Bypass Switch\", WM8955_MONO_OUT_MIX_1, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Right Playback Switch\", WM8955_MONO_OUT_MIX_2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Right Bypass Switch\", WM8955_MONO_OUT_MIX_2, 7, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8955_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"MONOIN-\"),\nSND_SOC_DAPM_INPUT(\"MONOIN+\"),\nSND_SOC_DAPM_INPUT(\"LINEINR\"),\nSND_SOC_DAPM_INPUT(\"LINEINL\"),\n\nSND_SOC_DAPM_PGA(\"Mono Input\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_SUPPLY(\"SYSCLK\", WM8955_POWER_MANAGEMENT_1, 0, 1, wm8955_sysclk,\n\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_SUPPLY(\"TSDEN\", WM8955_ADDITIONAL_CONTROL_1, 8, 0, NULL, 0),\n\nSND_SOC_DAPM_DAC(\"DACL\", \"Playback\", WM8955_POWER_MANAGEMENT_2, 8, 0),\nSND_SOC_DAPM_DAC(\"DACR\", \"Playback\", WM8955_POWER_MANAGEMENT_2, 7, 0),\n\nSND_SOC_DAPM_PGA(\"LOUT1 PGA\", WM8955_POWER_MANAGEMENT_2, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"ROUT1 PGA\", WM8955_POWER_MANAGEMENT_2, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"LOUT2 PGA\", WM8955_POWER_MANAGEMENT_2, 4, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"ROUT2 PGA\", WM8955_POWER_MANAGEMENT_2, 3, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"MOUT PGA\", WM8955_POWER_MANAGEMENT_2, 2, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"OUT3 PGA\", WM8955_POWER_MANAGEMENT_2, 1, 0, NULL, 0),\n\n \nSND_SOC_DAPM_MIXER(\"Left\", SND_SOC_NOPM, 0, 0,\n\t\t   lmixer, ARRAY_SIZE(lmixer)),\nSND_SOC_DAPM_MIXER(\"Right\", SND_SOC_NOPM, 0, 0,\n\t\t   rmixer, ARRAY_SIZE(rmixer)),\nSND_SOC_DAPM_MIXER(\"Mono\", SND_SOC_NOPM, 0, 0,\n\t\t   mmixer, ARRAY_SIZE(mmixer)),\n\nSND_SOC_DAPM_OUTPUT(\"LOUT1\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT1\"),\nSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\nSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\nSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8955_dapm_routes[] = {\n\t{ \"DACL\", NULL, \"SYSCLK\" },\n\t{ \"DACR\", NULL, \"SYSCLK\" },\n\n\t{ \"Mono Input\", NULL, \"MONOIN-\" },\n\t{ \"Mono Input\", NULL, \"MONOIN+\" },\n\n\t{ \"Left\", \"Playback Switch\", \"DACL\" },\n\t{ \"Left\", \"Right Playback Switch\", \"DACR\" },\n\t{ \"Left\", \"Bypass Switch\", \"LINEINL\" },\n\t{ \"Left\", \"Mono Switch\", \"Mono Input\" },\n\n\t{ \"Right\", \"Playback Switch\", \"DACR\" },\n\t{ \"Right\", \"Left Playback Switch\", \"DACL\" },\n\t{ \"Right\", \"Bypass Switch\", \"LINEINR\" },\n\t{ \"Right\", \"Mono Switch\", \"Mono Input\" },\n\n\t{ \"Mono\", \"Left Playback Switch\", \"DACL\" },\n\t{ \"Mono\", \"Right Playback Switch\", \"DACR\" },\n\t{ \"Mono\", \"Left Bypass Switch\", \"LINEINL\" },\n\t{ \"Mono\", \"Right Bypass Switch\", \"LINEINR\" },\n\n\t{ \"LOUT1 PGA\", NULL, \"Left\" },\n\t{ \"LOUT1\", NULL, \"TSDEN\" },\n\t{ \"LOUT1\", NULL, \"LOUT1 PGA\" },\n\n\t{ \"ROUT1 PGA\", NULL, \"Right\" },\n\t{ \"ROUT1\", NULL, \"TSDEN\" },\n\t{ \"ROUT1\", NULL, \"ROUT1 PGA\" },\n\n\t{ \"LOUT2 PGA\", NULL, \"Left\" },\n\t{ \"LOUT2\", NULL, \"TSDEN\" },\n\t{ \"LOUT2\", NULL, \"LOUT2 PGA\" },\n\n\t{ \"ROUT2 PGA\", NULL, \"Right\" },\n\t{ \"ROUT2\", NULL, \"TSDEN\" },\n\t{ \"ROUT2\", NULL, \"ROUT2 PGA\" },\n\n\t{ \"MOUT PGA\", NULL, \"Mono\" },\n\t{ \"MONOOUT\", NULL, \"MOUT PGA\" },\n\n\t \n\t{ \"OUT3\", NULL, \"OUT3 PGA\" },\n};\n\nstatic int wm8955_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tint wl;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\twl = 0;\n\t\tbreak;\n\tcase 20:\n\t\twl = 0x4;\n\t\tbreak;\n\tcase 24:\n\t\twl = 0x8;\n\t\tbreak;\n\tcase 32:\n\t\twl = 0xc;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, WM8955_AUDIO_INTERFACE,\n\t\t\t    WM8955_WL_MASK, wl);\n\n\twm8955->fs = params_rate(params);\n\twm8955_set_deemph(component);\n\n\t \n\tret = snd_soc_component_read(component, WM8955_POWER_MANAGEMENT_1);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & WM8955_DIGENB) {\n\t\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8955_DIGENB, 0);\n\t\tsnd_soc_component_update_bits(component, WM8955_CLOCKING_PLL,\n\t\t\t\t    WM8955_PLL_RB | WM8955_PLLEN, 0);\n\n\t\twm8955_configure_clocking(component);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int wm8955_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8955_priv *priv = snd_soc_component_get_drvdata(component);\n\tint div;\n\n\tswitch (clk_id) {\n\tcase WM8955_CLK_MCLK:\n\t\tif (freq > 15000000) {\n\t\t\tpriv->mclk_rate = freq /= 2;\n\t\t\tdiv = WM8955_MCLKDIV2;\n\t\t} else {\n\t\t\tpriv->mclk_rate = freq;\n\t\t\tdiv = 0;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, WM8955_SAMPLE_RATE,\n\t\t\t\t    WM8955_MCLKDIV2, div);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"Clock source is %d at %uHz\\n\", clk_id, freq);\n\n\treturn 0;\n}\n\nstatic int wm8955_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 aif = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif |= WM8955_MS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif |= WM8955_LRP;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif |= 0x3;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif |= WM8955_BCLKINV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif |= WM8955_BCLKINV | WM8955_LRP;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif |= WM8955_BCLKINV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif |= WM8955_LRP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8955_AUDIO_INTERFACE,\n\t\t\t    WM8955_MS | WM8955_FORMAT_MASK | WM8955_BCLKINV |\n\t\t\t    WM8955_LRP, aif);\n\n\treturn 0;\n}\n\n\nstatic int wm8955_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint val;\n\n\tif (mute)\n\t\tval = WM8955_DACMU;\n\telse\n\t\tval = 0;\n\n\tsnd_soc_component_update_bits(component, WM8955_DAC_CONTROL, WM8955_DACMU, val);\n\n\treturn 0;\n}\n\nstatic int wm8955_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8955_VMIDSEL_MASK,\n\t\t\t\t    0x1 << WM8955_VMIDSEL_SHIFT);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_ADDITIONAL_CONTROL_1,\n\t\t\t\t    WM8955_VSEL_MASK,\n\t\t\t\t    0x2 << WM8955_VSEL_SHIFT);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8955->supplies),\n\t\t\t\t\t\t    wm8955->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tregcache_sync(wm8955->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8955_VREF |\n\t\t\t\t\t    WM8955_VMIDSEL_MASK,\n\t\t\t\t\t    WM8955_VREF |\n\t\t\t\t\t    0x3 << WM8955_VREF_SHIFT);\n\n\t\t\t \n\t\t\tmsleep(500);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t    WM8955_ADDITIONAL_CONTROL_3,\n\t\t\t\t\t    WM8955_VROI, WM8955_VROI);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8955_VMIDSEL_MASK,\n\t\t\t\t    0x2 << WM8955_VMIDSEL_SHIFT);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_ADDITIONAL_CONTROL_1,\n\t\t\t\t    WM8955_VSEL_MASK, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t    WM8955_ADDITIONAL_CONTROL_3,\n\t\t\t\t    WM8955_VROI, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8955_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8955_VREF |\n\t\t\t\t    WM8955_VMIDSEL_MASK, 0);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies),\n\t\t\t\t       wm8955->supplies);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8955_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8955_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8955_dai_ops = {\n\t.set_sysclk = wm8955_set_sysclk,\n\t.set_fmt = wm8955_set_fmt,\n\t.hw_params = wm8955_hw_params,\n\t.mute_stream = wm8955_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8955_dai = {\n\t.name = \"wm8955-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8955_RATES,\n\t\t.formats = WM8955_FORMATS,\n\t},\n\t.ops = &wm8955_dai_ops,\n};\n\nstatic int wm8955_probe(struct snd_soc_component *component)\n{\n\tstruct wm8955_priv *wm8955 = snd_soc_component_get_drvdata(component);\n\tstruct wm8955_pdata *pdata = dev_get_platdata(component->dev);\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8955->supplies); i++)\n\t\twm8955->supplies[i].supply = wm8955_supply_names[i];\n\n\tret = devm_regulator_bulk_get(component->dev, ARRAY_SIZE(wm8955->supplies),\n\t\t\t\t wm8955->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8955->supplies),\n\t\t\t\t    wm8955->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8955_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8955_LEFT_DAC_VOLUME,\n\t\t\t    WM8955_LDVU, WM8955_LDVU);\n\tsnd_soc_component_update_bits(component, WM8955_RIGHT_DAC_VOLUME,\n\t\t\t    WM8955_RDVU, WM8955_RDVU);\n\tsnd_soc_component_update_bits(component, WM8955_LOUT1_VOLUME,\n\t\t\t    WM8955_LO1VU | WM8955_LO1ZC,\n\t\t\t    WM8955_LO1VU | WM8955_LO1ZC);\n\tsnd_soc_component_update_bits(component, WM8955_ROUT1_VOLUME,\n\t\t\t    WM8955_RO1VU | WM8955_RO1ZC,\n\t\t\t    WM8955_RO1VU | WM8955_RO1ZC);\n\tsnd_soc_component_update_bits(component, WM8955_LOUT2_VOLUME,\n\t\t\t    WM8955_LO2VU | WM8955_LO2ZC,\n\t\t\t    WM8955_LO2VU | WM8955_LO2ZC);\n\tsnd_soc_component_update_bits(component, WM8955_ROUT2_VOLUME,\n\t\t\t    WM8955_RO2VU | WM8955_RO2ZC,\n\t\t\t    WM8955_RO2VU | WM8955_RO2ZC);\n\tsnd_soc_component_update_bits(component, WM8955_MONOOUT_VOLUME,\n\t\t\t    WM8955_MOZC, WM8955_MOZC);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8955_BASS_CONTROL, WM8955_BB, WM8955_BB);\n\n\t \n\tif (pdata) {\n\t\tif (pdata->out2_speaker)\n\t\t\tsnd_soc_component_update_bits(component, WM8955_ADDITIONAL_CONTROL_2,\n\t\t\t\t\t    WM8955_ROUT2INV, WM8955_ROUT2INV);\n\n\t\tif (pdata->monoin_diff)\n\t\t\tsnd_soc_component_update_bits(component, WM8955_MONO_OUT_MIX_1,\n\t\t\t\t\t    WM8955_DMEN, WM8955_DMEN);\n\t}\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\n\n\treturn 0;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8955->supplies), wm8955->supplies);\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8955 = {\n\t.probe\t\t\t= wm8955_probe,\n\t.set_bias_level\t\t= wm8955_set_bias_level,\n\t.controls\t\t= wm8955_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8955_snd_controls),\n\t.dapm_widgets\t\t= wm8955_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8955_dapm_widgets),\n\t.dapm_routes\t\t= wm8955_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8955_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8955_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8955_MAX_REGISTER,\n\t.volatile_reg = wm8955_volatile,\n\t.writeable_reg = wm8955_writeable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8955_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8955_reg_defaults),\n};\n\nstatic int wm8955_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8955_priv *wm8955;\n\tint ret;\n\n\twm8955 = devm_kzalloc(&i2c->dev, sizeof(struct wm8955_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8955 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8955->regmap = devm_regmap_init_i2c(i2c, &wm8955_regmap);\n\tif (IS_ERR(wm8955->regmap)) {\n\t\tret = PTR_ERR(wm8955->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8955);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8955, &wm8955_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8955_i2c_id[] = {\n\t{ \"wm8955\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8955_i2c_id);\n\nstatic struct i2c_driver wm8955_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8955\",\n\t},\n\t.probe = wm8955_i2c_probe,\n\t.id_table = wm8955_i2c_id,\n};\n\nmodule_i2c_driver(wm8955_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8955 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}