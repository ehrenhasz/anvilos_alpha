{
  "module_name": "ad1980.c",
  "hash_id": "81a56ba348beb17b31247d370e1a52980828d45e3ea04916cdc66ef0846ca7ce",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ad1980.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\nstatic const struct reg_default ad1980_reg_defaults[] = {\n\t{ 0x02, 0x8000 },\n\t{ 0x04, 0x8000 },\n\t{ 0x06, 0x8000 },\n\t{ 0x0c, 0x8008 },\n\t{ 0x0e, 0x8008 },\n\t{ 0x10, 0x8808 },\n\t{ 0x12, 0x8808 },\n\t{ 0x16, 0x8808 },\n\t{ 0x18, 0x8808 },\n\t{ 0x1a, 0x0000 },\n\t{ 0x1c, 0x8000 },\n\t{ 0x20, 0x0000 },\n\t{ 0x28, 0x03c7 },\n\t{ 0x2c, 0xbb80 },\n\t{ 0x2e, 0xbb80 },\n\t{ 0x30, 0xbb80 },\n\t{ 0x32, 0xbb80 },\n\t{ 0x36, 0x8080 },\n\t{ 0x38, 0x8080 },\n\t{ 0x3a, 0x2000 },\n\t{ 0x60, 0x0000 },\n\t{ 0x62, 0x0000 },\n\t{ 0x72, 0x0000 },\n\t{ 0x74, 0x1001 },\n\t{ 0x76, 0x0000 },\n};\n\nstatic bool ad1980_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_RESET ... AC97_MASTER_MONO:\n\tcase AC97_PHONE ... AC97_CD:\n\tcase AC97_AUX ... AC97_GENERAL_PURPOSE:\n\tcase AC97_POWERDOWN ... AC97_PCM_LR_ADC_RATE:\n\tcase AC97_SPDIF:\n\tcase AC97_CODEC_CLASS_REV:\n\tcase AC97_PCI_SVID:\n\tcase AC97_AD_CODEC_CFG:\n\tcase AC97_AD_JACK_SPDIF:\n\tcase AC97_AD_SERIAL_CFG:\n\tcase AC97_VENDOR_ID1:\n\tcase AC97_VENDOR_ID2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ad1980_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_VENDOR_ID1:\n\tcase AC97_VENDOR_ID2:\n\t\treturn false;\n\tdefault:\n\t\treturn ad1980_readable_reg(dev, reg);\n\t}\n}\n\nstatic const struct regmap_config ad1980_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x7e,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = regmap_ac97_default_volatile,\n\t.readable_reg = ad1980_readable_reg,\n\t.writeable_reg = ad1980_writeable_reg,\n\n\t.reg_defaults = ad1980_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ad1980_reg_defaults),\n};\n\nstatic const char *ad1980_rec_sel[] = {\"Mic\", \"CD\", \"NC\", \"AUX\", \"Line\",\n\t\t\"Stereo Mix\", \"Mono Mix\", \"Phone\"};\n\nstatic SOC_ENUM_DOUBLE_DECL(ad1980_cap_src,\n\t\t\t    AC97_REC_SEL, 8, 0, ad1980_rec_sel);\n\nstatic const struct snd_kcontrol_new ad1980_snd_ac97_controls[] = {\nSOC_DOUBLE(\"Master Playback Volume\", AC97_MASTER, 8, 0, 31, 1),\nSOC_SINGLE(\"Master Playback Switch\", AC97_MASTER, 15, 1, 1),\n\nSOC_DOUBLE(\"Headphone Playback Volume\", AC97_HEADPHONE, 8, 0, 31, 1),\nSOC_SINGLE(\"Headphone Playback Switch\", AC97_HEADPHONE, 15, 1, 1),\n\nSOC_DOUBLE(\"PCM Playback Volume\", AC97_PCM, 8, 0, 31, 1),\nSOC_SINGLE(\"PCM Playback Switch\", AC97_PCM, 15, 1, 1),\n\nSOC_DOUBLE(\"PCM Capture Volume\", AC97_REC_GAIN, 8, 0, 31, 0),\nSOC_SINGLE(\"PCM Capture Switch\", AC97_REC_GAIN, 15, 1, 1),\n\nSOC_SINGLE(\"Mono Playback Volume\", AC97_MASTER_MONO, 0, 31, 1),\nSOC_SINGLE(\"Mono Playback Switch\", AC97_MASTER_MONO, 15, 1, 1),\n\nSOC_SINGLE(\"Phone Capture Volume\", AC97_PHONE, 0, 31, 1),\nSOC_SINGLE(\"Phone Capture Switch\", AC97_PHONE, 15, 1, 1),\n\nSOC_SINGLE(\"Mic Volume\", AC97_MIC, 0, 31, 1),\nSOC_SINGLE(\"Mic Switch\", AC97_MIC, 15, 1, 1),\n\nSOC_SINGLE(\"Stereo Mic Switch\", AC97_AD_MISC, 6, 1, 0),\nSOC_DOUBLE(\"Line HP Swap Switch\", AC97_AD_MISC, 10, 5, 1, 0),\n\nSOC_DOUBLE(\"Surround Playback Volume\", AC97_SURROUND_MASTER, 8, 0, 31, 1),\nSOC_DOUBLE(\"Surround Playback Switch\", AC97_SURROUND_MASTER, 15, 7, 1, 1),\n\nSOC_DOUBLE(\"Center/LFE Playback Volume\", AC97_CENTER_LFE_MASTER, 8, 0, 31, 1),\nSOC_DOUBLE(\"Center/LFE Playback Switch\", AC97_CENTER_LFE_MASTER, 15, 7, 1, 1),\n\nSOC_ENUM(\"Capture Source\", ad1980_cap_src),\n\nSOC_SINGLE(\"Mic Boost Switch\", AC97_MIC, 6, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget ad1980_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"MIC1\"),\nSND_SOC_DAPM_INPUT(\"MIC2\"),\nSND_SOC_DAPM_INPUT(\"CD_L\"),\nSND_SOC_DAPM_INPUT(\"CD_R\"),\nSND_SOC_DAPM_INPUT(\"AUX_L\"),\nSND_SOC_DAPM_INPUT(\"AUX_R\"),\nSND_SOC_DAPM_INPUT(\"LINE_IN_L\"),\nSND_SOC_DAPM_INPUT(\"LINE_IN_R\"),\n\nSND_SOC_DAPM_OUTPUT(\"LFE_OUT\"),\nSND_SOC_DAPM_OUTPUT(\"CENTER_OUT\"),\nSND_SOC_DAPM_OUTPUT(\"LINE_OUT_L\"),\nSND_SOC_DAPM_OUTPUT(\"LINE_OUT_R\"),\nSND_SOC_DAPM_OUTPUT(\"MONO_OUT\"),\nSND_SOC_DAPM_OUTPUT(\"HP_OUT_L\"),\nSND_SOC_DAPM_OUTPUT(\"HP_OUT_R\"),\n};\n\nstatic const struct snd_soc_dapm_route ad1980_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"MIC1\" },\n\t{ \"Capture\", NULL, \"MIC2\" },\n\t{ \"Capture\", NULL, \"CD_L\" },\n\t{ \"Capture\", NULL, \"CD_R\" },\n\t{ \"Capture\", NULL, \"AUX_L\" },\n\t{ \"Capture\", NULL, \"AUX_R\" },\n\t{ \"Capture\", NULL, \"LINE_IN_L\" },\n\t{ \"Capture\", NULL, \"LINE_IN_R\" },\n\n\t{ \"LFE_OUT\", NULL, \"Playback\" },\n\t{ \"CENTER_OUT\", NULL, \"Playback\" },\n\t{ \"LINE_OUT_L\", NULL, \"Playback\" },\n\t{ \"LINE_OUT_R\", NULL, \"Playback\" },\n\t{ \"MONO_OUT\", NULL, \"Playback\" },\n\t{ \"HP_OUT_L\", NULL, \"Playback\" },\n\t{ \"HP_OUT_R\", NULL, \"Playback\" },\n};\n\nstatic struct snd_soc_dai_driver ad1980_dai = {\n\t.name = \"ad1980-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 6,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SND_SOC_STD_AC97_FMTS, },\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SND_SOC_STD_AC97_FMTS, },\n};\n\n#define AD1980_VENDOR_ID 0x41445300\n#define AD1980_VENDOR_MASK 0xffffff00\n\nstatic int ad1980_reset(struct snd_soc_component *component, int try_warm)\n{\n\tstruct snd_ac97 *ac97 = snd_soc_component_get_drvdata(component);\n\tunsigned int retry_cnt = 0;\n\tint ret;\n\n\tdo {\n\t\tret = snd_ac97_reset(ac97, true, AD1980_VENDOR_ID,\n\t\t\tAD1980_VENDOR_MASK);\n\t\tif (ret >= 0)\n\t\t\treturn 0;\n\n\t\t \n\t\tsnd_soc_component_write(component, AC97_AD_SERIAL_CFG, 0x9900);\n\n\t} while (retry_cnt++ < 10);\n\n\tdev_err(component->dev, \"Failed to reset: AC97 link error\\n\");\n\n\treturn -EIO;\n}\n\nstatic int ad1980_soc_probe(struct snd_soc_component *component)\n{\n\tstruct snd_ac97 *ac97;\n\tstruct regmap *regmap;\n\tint ret;\n\tu16 vendor_id2;\n\tu16 ext_status;\n\n\tac97 = snd_soc_new_ac97_component(component, 0, 0);\n\tif (IS_ERR(ac97)) {\n\t\tret = PTR_ERR(ac97);\n\t\tdev_err(component->dev, \"Failed to register AC97 component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap = regmap_init_ac97(ac97, &ad1980_regmap_config);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tgoto err_free_ac97;\n\t}\n\n\tsnd_soc_component_init_regmap(component, regmap);\n\tsnd_soc_component_set_drvdata(component, ac97);\n\n\tret = ad1980_reset(component, 0);\n\tif (ret < 0)\n\t\tgoto reset_err;\n\n\tvendor_id2 = snd_soc_component_read(component, AC97_VENDOR_ID2);\n\tif (vendor_id2 == 0x5374) {\n\t\tdev_warn(component->dev,\n\t\t\t\"Found AD1981 - only 2/2 IN/OUT Channels supported\\n\");\n\t}\n\n\t \n\tsnd_soc_component_write(component, AC97_MASTER, 0x0000);\n\tsnd_soc_component_write(component, AC97_PCM, 0x0000);\n\tsnd_soc_component_write(component, AC97_REC_GAIN, 0x0000);\n\tsnd_soc_component_write(component, AC97_CENTER_LFE_MASTER, 0x0000);\n\tsnd_soc_component_write(component, AC97_SURROUND_MASTER, 0x0000);\n\n\t \n\text_status = snd_soc_component_read(component, AC97_EXTENDED_STATUS);\n\tsnd_soc_component_write(component, AC97_EXTENDED_STATUS, ext_status&~0x3800);\n\n\treturn 0;\n\nreset_err:\n\tsnd_soc_component_exit_regmap(component);\nerr_free_ac97:\n\tsnd_soc_free_ac97_component(ac97);\n\treturn ret;\n}\n\nstatic void ad1980_soc_remove(struct snd_soc_component *component)\n{\n\tstruct snd_ac97 *ac97 = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_exit_regmap(component);\n\tsnd_soc_free_ac97_component(ac97);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ad1980 = {\n\t.probe\t\t\t= ad1980_soc_probe,\n\t.remove\t\t\t= ad1980_soc_remove,\n\t.controls\t\t= ad1980_snd_ac97_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ad1980_snd_ac97_controls),\n\t.dapm_widgets\t\t= ad1980_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ad1980_dapm_widgets),\n\t.dapm_routes\t\t= ad1980_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ad1980_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int ad1980_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_component_dev_ad1980, &ad1980_dai, 1);\n}\n\nstatic struct platform_driver ad1980_codec_driver = {\n\t.driver = {\n\t\t\t.name = \"ad1980\",\n\t},\n\n\t.probe = ad1980_probe,\n};\n\nmodule_platform_driver(ad1980_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC ad1980 driver (Obsolete)\");\nMODULE_AUTHOR(\"Roy Huang, Cliff Cai\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}