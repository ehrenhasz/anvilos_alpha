{
  "module_name": "sgtl5000.c",
  "hash_id": "2a9a43d9aa394abacec2c94bf4b0984c5abc25a921abb3c8f0833dc8aabf5055",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sgtl5000.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <linux/log2.h>\n#include <linux/regmap.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/tlv.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n\n#include \"sgtl5000.h\"\n\n#define SGTL5000_DAP_REG_OFFSET\t0x0100\n#define SGTL5000_MAX_REG_OFFSET\t0x013A\n\n \n#define SGTL5000_VAG_POWERUP_DELAY 500  \n \n#define SGTL5000_VAG_POWERDOWN_DELAY 500  \n\n#define SGTL5000_OUTPUTS_MUTE (SGTL5000_HP_MUTE | SGTL5000_LINE_OUT_MUTE)\n\n \nstatic const struct reg_default sgtl5000_reg_defaults[] = {\n\t{ SGTL5000_CHIP_DIG_POWER,\t\t0x0000 },\n\t{ SGTL5000_CHIP_I2S_CTRL,\t\t0x0010 },\n\t{ SGTL5000_CHIP_SSS_CTRL,\t\t0x0010 },\n\t{ SGTL5000_CHIP_ADCDAC_CTRL,\t\t0x020c },\n\t{ SGTL5000_CHIP_DAC_VOL,\t\t0x3c3c },\n\t{ SGTL5000_CHIP_PAD_STRENGTH,\t\t0x015f },\n\t{ SGTL5000_CHIP_ANA_ADC_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_ANA_HP_CTRL,\t\t0x1818 },\n\t{ SGTL5000_CHIP_ANA_CTRL,\t\t0x0111 },\n\t{ SGTL5000_CHIP_REF_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_MIC_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_LINE_OUT_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_LINE_OUT_VOL,\t\t0x0404 },\n\t{ SGTL5000_CHIP_PLL_CTRL,\t\t0x5000 },\n\t{ SGTL5000_CHIP_CLK_TOP_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_ANA_STATUS,\t\t0x0000 },\n\t{ SGTL5000_CHIP_SHORT_CTRL,\t\t0x0000 },\n\t{ SGTL5000_CHIP_ANA_TEST2,\t\t0x0000 },\n\t{ SGTL5000_DAP_CTRL,\t\t\t0x0000 },\n\t{ SGTL5000_DAP_PEQ,\t\t\t0x0000 },\n\t{ SGTL5000_DAP_BASS_ENHANCE,\t\t0x0040 },\n\t{ SGTL5000_DAP_BASS_ENHANCE_CTRL,\t0x051f },\n\t{ SGTL5000_DAP_AUDIO_EQ,\t\t0x0000 },\n\t{ SGTL5000_DAP_SURROUND,\t\t0x0040 },\n\t{ SGTL5000_DAP_EQ_BASS_BAND0,\t\t0x002f },\n\t{ SGTL5000_DAP_EQ_BASS_BAND1,\t\t0x002f },\n\t{ SGTL5000_DAP_EQ_BASS_BAND2,\t\t0x002f },\n\t{ SGTL5000_DAP_EQ_BASS_BAND3,\t\t0x002f },\n\t{ SGTL5000_DAP_EQ_BASS_BAND4,\t\t0x002f },\n\t{ SGTL5000_DAP_MAIN_CHAN,\t\t0x8000 },\n\t{ SGTL5000_DAP_MIX_CHAN,\t\t0x0000 },\n\t{ SGTL5000_DAP_AVC_CTRL,\t\t0x5100 },\n\t{ SGTL5000_DAP_AVC_THRESHOLD,\t\t0x1473 },\n\t{ SGTL5000_DAP_AVC_ATTACK,\t\t0x0028 },\n\t{ SGTL5000_DAP_AVC_DECAY,\t\t0x0050 },\n};\n\n \nstatic const u16 avc_thr_db2reg[97] = {\n\t0x5168, 0x488E, 0x40AA, 0x39A1, 0x335D, 0x2DC7, 0x28CC, 0x245D, 0x2068,\n\t0x1CE2, 0x19BE, 0x16F1, 0x1472, 0x1239, 0x103E, 0x0E7A, 0x0CE6, 0x0B7F,\n\t0x0A3F, 0x0922, 0x0824, 0x0741, 0x0677, 0x05C3, 0x0522, 0x0493, 0x0414,\n\t0x03A2, 0x033D, 0x02E3, 0x0293, 0x024B, 0x020B, 0x01D2, 0x019F, 0x0172,\n\t0x014A, 0x0126, 0x0106, 0x00E9, 0x00D0, 0x00B9, 0x00A5, 0x0093, 0x0083,\n\t0x0075, 0x0068, 0x005D, 0x0052, 0x0049, 0x0041, 0x003A, 0x0034, 0x002E,\n\t0x0029, 0x0025, 0x0021, 0x001D, 0x001A, 0x0017, 0x0014, 0x0012, 0x0010,\n\t0x000E, 0x000D, 0x000B, 0x000A, 0x0009, 0x0008, 0x0007, 0x0006, 0x0005,\n\t0x0005, 0x0004, 0x0004, 0x0003, 0x0003, 0x0002, 0x0002, 0x0002, 0x0002,\n\t0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};\n\n \nenum sgtl5000_regulator_supplies {\n\tVDDA,\n\tVDDIO,\n\tVDDD,\n\tSGTL5000_SUPPLY_NUM\n};\n\n \nstatic const char *supply_names[SGTL5000_SUPPLY_NUM] = {\n\t\"VDDA\",\n\t\"VDDIO\",\n\t\"VDDD\"\n};\n\n#define LDO_VOLTAGE\t\t1200000\n#define LINREG_VDDD\t((1600 - LDO_VOLTAGE / 1000) / 50)\n\nenum sgtl5000_micbias_resistor {\n\tSGTL5000_MICBIAS_OFF = 0,\n\tSGTL5000_MICBIAS_2K = 2,\n\tSGTL5000_MICBIAS_4K = 4,\n\tSGTL5000_MICBIAS_8K = 8,\n};\n\nenum  {\n\tI2S_LRCLK_STRENGTH_DISABLE,\n\tI2S_LRCLK_STRENGTH_LOW,\n\tI2S_LRCLK_STRENGTH_MEDIUM,\n\tI2S_LRCLK_STRENGTH_HIGH,\n};\n\nenum  {\n\tI2S_SCLK_STRENGTH_DISABLE,\n\tI2S_SCLK_STRENGTH_LOW,\n\tI2S_SCLK_STRENGTH_MEDIUM,\n\tI2S_SCLK_STRENGTH_HIGH,\n};\n\nenum {\n\tHP_POWER_EVENT,\n\tDAC_POWER_EVENT,\n\tADC_POWER_EVENT,\n\tLAST_POWER_EVENT = ADC_POWER_EVENT\n};\n\n \nstruct sgtl5000_priv {\n\tint sysclk;\t \n\tint master;\t \n\tint fmt;\t \n\tstruct regulator_bulk_data supplies[SGTL5000_SUPPLY_NUM];\n\tint num_supplies;\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\tint revision;\n\tu8 micbias_resistor;\n\tu8 micbias_voltage;\n\tu8 lrclk_strength;\n\tu8 sclk_strength;\n\tu16 mute_state[LAST_POWER_EVENT + 1];\n};\n\nstatic inline int hp_sel_input(struct snd_soc_component *component)\n{\n\treturn (snd_soc_component_read(component, SGTL5000_CHIP_ANA_CTRL) &\n\t\tSGTL5000_HP_SEL_MASK) >> SGTL5000_HP_SEL_SHIFT;\n}\n\nstatic inline u16 mute_output(struct snd_soc_component *component,\n\t\t\t      u16 mute_mask)\n{\n\tu16 mute_reg = snd_soc_component_read(component,\n\t\t\t\t\t      SGTL5000_CHIP_ANA_CTRL);\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_CTRL,\n\t\t\t    mute_mask, mute_mask);\n\treturn mute_reg;\n}\n\nstatic inline void restore_output(struct snd_soc_component *component,\n\t\t\t\t  u16 mute_mask, u16 mute_reg)\n{\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_CTRL,\n\t\tmute_mask, mute_reg);\n}\n\nstatic void vag_power_on(struct snd_soc_component *component, u32 source)\n{\n\tif (snd_soc_component_read(component, SGTL5000_CHIP_ANA_POWER) &\n\t    SGTL5000_VAG_POWERUP)\n\t\treturn;\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\t\t    SGTL5000_VAG_POWERUP, SGTL5000_VAG_POWERUP);\n\n\t \n\tif (hp_sel_input(component) == SGTL5000_HP_SEL_LINE_IN &&\n\t    source == HP_POWER_EVENT)\n\t\tmsleep(SGTL5000_VAG_POWERUP_DELAY);\n}\n\nstatic int vag_power_consumers(struct snd_soc_component *component,\n\t\t\t       u16 ana_pwr_reg, u32 source)\n{\n\tint consumers = 0;\n\n\t \n\tif (ana_pwr_reg & SGTL5000_DAC_POWERUP)\n\t\tconsumers++;\n\tif (ana_pwr_reg & SGTL5000_ADC_POWERUP)\n\t\tconsumers++;\n\n\t \n\tif (source == HP_POWER_EVENT) {\n\t\tif (hp_sel_input(component) == SGTL5000_HP_SEL_LINE_IN)\n\t\t\tconsumers++;\n\t} else {\n\t\tif (ana_pwr_reg & SGTL5000_HP_POWERUP)\n\t\t\tconsumers++;\n\t}\n\n\treturn consumers;\n}\n\nstatic void vag_power_off(struct snd_soc_component *component, u32 source)\n{\n\tu16 ana_pwr = snd_soc_component_read(component,\n\t\t\t\t\t     SGTL5000_CHIP_ANA_POWER);\n\n\tif (!(ana_pwr & SGTL5000_VAG_POWERUP))\n\t\treturn;\n\n\t \n\tif (vag_power_consumers(component, ana_pwr, source) >= 2)\n\t\treturn;\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\tSGTL5000_VAG_POWERUP, 0);\n\t \n\tmsleep(SGTL5000_VAG_POWERDOWN_DELAY);\n}\n\n \nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_MIC_CTRL,\n\t\t\tSGTL5000_BIAS_R_MASK,\n\t\t\tsgtl5000->micbias_resistor << SGTL5000_BIAS_R_SHIFT);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_MIC_CTRL,\n\t\t\t\tSGTL5000_BIAS_R_MASK, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vag_and_mute_control(struct snd_soc_component *component,\n\t\t\t\t int event, int event_source)\n{\n\tstatic const u16 mute_mask[] = {\n\t\t \n\t\tSGTL5000_HP_MUTE,\n\t\t \n\t\tSGTL5000_OUTPUTS_MUTE,\n\t\tSGTL5000_OUTPUTS_MUTE\n\t};\n\n\tstruct sgtl5000_priv *sgtl5000 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsgtl5000->mute_state[event_source] =\n\t\t\tmute_output(component, mute_mask[event_source]);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tvag_power_on(component, event_source);\n\t\trestore_output(component, mute_mask[event_source],\n\t\t\t       sgtl5000->mute_state[event_source]);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsgtl5000->mute_state[event_source] =\n\t\t\tmute_output(component, mute_mask[event_source]);\n\t\tvag_power_off(component, event_source);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\trestore_output(component, mute_mask[event_source],\n\t\t\t       sgtl5000->mute_state[event_source]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int headphone_pga_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\n\treturn vag_and_mute_control(component, event, HP_POWER_EVENT);\n}\n\n \nstatic int adc_updown_depop(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\n\treturn vag_and_mute_control(component, event, ADC_POWER_EVENT);\n}\n\nstatic int dac_updown_depop(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\n\treturn vag_and_mute_control(component, event, DAC_POWER_EVENT);\n}\n\n \nstatic const char *adc_mux_text[] = {\n\t\"MIC_IN\", \"LINE_IN\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adc_enum,\n\t\t\t    SGTL5000_CHIP_ANA_CTRL, 2,\n\t\t\t    adc_mux_text);\n\nstatic const struct snd_kcontrol_new adc_mux =\nSOC_DAPM_ENUM(\"Capture Mux\", adc_enum);\n\n \nstatic const char *hp_mux_text[] = {\n\t\"DAC\", \"LINE_IN\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(hp_enum,\n\t\t\t    SGTL5000_CHIP_ANA_CTRL, 6,\n\t\t\t    hp_mux_text);\n\nstatic const struct snd_kcontrol_new hp_mux =\nSOC_DAPM_ENUM(\"Headphone Mux\", hp_enum);\n\n \nstatic const char *dac_mux_text[] = {\n\t\"ADC\", \"I2S\", \"Rsvrd\", \"DAP\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dac_enum,\n\t\t\t    SGTL5000_CHIP_SSS_CTRL, SGTL5000_DAC_SEL_SHIFT,\n\t\t\t    dac_mux_text);\n\nstatic const struct snd_kcontrol_new dac_mux =\nSOC_DAPM_ENUM(\"Digital Input Mux\", dac_enum);\n\n \nstatic const char *dap_mux_text[] = {\n\t\"ADC\", \"I2S\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dap_enum,\n\t\t\t    SGTL5000_CHIP_SSS_CTRL, SGTL5000_DAP_SEL_SHIFT,\n\t\t\t    dap_mux_text);\n\nstatic const struct snd_kcontrol_new dap_mux =\nSOC_DAPM_ENUM(\"DAP Mux\", dap_enum);\n\n \nstatic const char *dapmix_mux_text[] = {\n\t\"ADC\", \"I2S\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dapmix_enum,\n\t\t\t    SGTL5000_CHIP_SSS_CTRL, SGTL5000_DAP_MIX_SEL_SHIFT,\n\t\t\t    dapmix_mux_text);\n\nstatic const struct snd_kcontrol_new dapmix_mux =\nSOC_DAPM_ENUM(\"DAP MIX Mux\", dapmix_enum);\n\n\nstatic const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"LINE_IN\"),\n\tSND_SOC_DAPM_INPUT(\"MIC_IN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"HP_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINE_OUT\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", SGTL5000_CHIP_MIC_CTRL, 8, 0,\n\t\t\t    mic_bias_event,\n\t\t\t    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_PGA_E(\"HP\", SGTL5000_CHIP_ANA_POWER, 4, 0, NULL, 0,\n\t\t\t   headphone_pga_event,\n\t\t\t   SND_SOC_DAPM_PRE_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_PGA(\"LO\", SGTL5000_CHIP_ANA_POWER, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Capture Mux\", SND_SOC_NOPM, 0, 0, &adc_mux),\n\tSND_SOC_DAPM_MUX(\"Headphone Mux\", SND_SOC_NOPM, 0, 0, &hp_mux),\n\tSND_SOC_DAPM_MUX(\"Digital Input Mux\", SND_SOC_NOPM, 0, 0, &dac_mux),\n\tSND_SOC_DAPM_MUX(\"DAP Mux\", SGTL5000_DAP_CTRL, 0, 0, &dap_mux),\n\tSND_SOC_DAPM_MUX(\"DAP MIX Mux\", SGTL5000_DAP_CTRL, 4, 0, &dapmix_mux),\n\tSND_SOC_DAPM_MIXER(\"DAP\", SGTL5000_CHIP_DIG_POWER, 4, 0, NULL, 0),\n\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIFIN\", \"Playback\",\n\t\t\t\t0, SGTL5000_CHIP_DIG_POWER,\n\t\t\t\t0, 0),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUT\", \"Capture\",\n\t\t\t\t0, SGTL5000_CHIP_DIG_POWER,\n\t\t\t\t1, 0),\n\n\tSND_SOC_DAPM_ADC_E(\"ADC\", \"Capture\", SGTL5000_CHIP_ANA_POWER, 1, 0,\n\t\t\t   adc_updown_depop, SND_SOC_DAPM_PRE_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", \"Playback\", SGTL5000_CHIP_ANA_POWER, 3, 0,\n\t\t\t   dac_updown_depop, SND_SOC_DAPM_PRE_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_POST_PMD),\n};\n\n \nstatic const struct snd_soc_dapm_route sgtl5000_dapm_routes[] = {\n\t{\"Capture Mux\", \"LINE_IN\", \"LINE_IN\"},\t \n\t{\"Capture Mux\", \"MIC_IN\", \"MIC_IN\"},\t \n\n\t{\"ADC\", NULL, \"Capture Mux\"},\t\t \n\t{\"AIFOUT\", NULL, \"ADC\"},\t\t \n\n\t{\"DAP Mux\", \"ADC\", \"ADC\"},\t\t \n\t{\"DAP Mux\", NULL, \"AIFIN\"},\t\t \n\t{\"DAP\", NULL, \"DAP Mux\"},\t\t \n\n\t{\"DAP MIX Mux\", \"ADC\", \"ADC\"},\t\t \n\t{\"DAP MIX Mux\", NULL, \"AIFIN\"},\t\t \n\t{\"DAP\", NULL, \"DAP MIX Mux\"},\t\t \n\n\t{\"Digital Input Mux\", \"ADC\", \"ADC\"},\t \n\t{\"Digital Input Mux\", NULL, \"AIFIN\"},\t \n\t{\"Digital Input Mux\", NULL, \"DAP\"},\t \n\t{\"DAC\", NULL, \"Digital Input Mux\"},\t \n\n\t{\"Headphone Mux\", \"DAC\", \"DAC\"},\t \n\t{\"LO\", NULL, \"DAC\"},\t\t\t \n\n\t{\"Headphone Mux\", \"LINE_IN\", \"LINE_IN\"}, \n\t{\"HP\", NULL, \"Headphone Mux\"},\t\t \n\n\t{\"LINE_OUT\", NULL, \"LO\"},\n\t{\"HP_OUT\", NULL, \"HP\"},\n};\n\n \nstatic int dac_info_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xfc - 0x3c;\n\treturn 0;\n}\n\n \nstatic int dac_get_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint reg;\n\tint l;\n\tint r;\n\n\treg = snd_soc_component_read(component, SGTL5000_CHIP_DAC_VOL);\n\n\t \n\tl = (reg & SGTL5000_DAC_VOL_LEFT_MASK) >> SGTL5000_DAC_VOL_LEFT_SHIFT;\n\n\t \n\tr = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) >> SGTL5000_DAC_VOL_RIGHT_SHIFT;\n\n\t \n\tl = clamp(l, 0x3c, 0xfc);\n\tr = clamp(r, 0x3c, 0xfc);\n\n\t \n\tl = 0xfc - l;\n\tr = 0xfc - r;\n\n\tucontrol->value.integer.value[0] = l;\n\tucontrol->value.integer.value[1] = r;\n\n\treturn 0;\n}\n\n \nstatic int dac_put_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint reg;\n\tint l;\n\tint r;\n\n\tl = ucontrol->value.integer.value[0];\n\tr = ucontrol->value.integer.value[1];\n\n\t \n\tl = clamp(l, 0, 0xfc - 0x3c);\n\tr = clamp(r, 0, 0xfc - 0x3c);\n\n\t \n\tl = 0xfc - l;\n\tr = 0xfc - r;\n\n\t \n\treg = l << SGTL5000_DAC_VOL_LEFT_SHIFT |\n\t\tr << SGTL5000_DAC_VOL_RIGHT_SHIFT;\n\n\tsnd_soc_component_write(component, SGTL5000_CHIP_DAC_VOL, reg);\n\n\treturn 0;\n}\n\n \nstatic int avc_get_threshold(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint db, i;\n\tu16 reg = snd_soc_component_read(component, SGTL5000_DAP_AVC_THRESHOLD);\n\n\t \n\tif (!reg) {\n\t\tucontrol->value.integer.value[0] = 96;\n\t\tucontrol->value.integer.value[1] = 96;\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; avc_thr_db2reg[i] > reg; i++)\n\t\t;\n\tdb = i;\n\n\tucontrol->value.integer.value[0] = db;\n\tucontrol->value.integer.value[1] = db;\n\n\treturn 0;\n}\n\n \nstatic int avc_put_threshold(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint db;\n\tu16 reg;\n\n\tdb = (int)ucontrol->value.integer.value[0];\n\tif (db < 0 || db > 96)\n\t\treturn -EINVAL;\n\treg = avc_thr_db2reg[db];\n\tsnd_soc_component_write(component, SGTL5000_DAP_AVC_THRESHOLD, reg);\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(capture_6db_attenuate, -600, 600, 0);\n\n \nstatic const DECLARE_TLV_DB_RANGE(mic_gain_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),\n\t1, 3, TLV_DB_SCALE_ITEM(2000, 1000, 0)\n);\n\n \nstatic const DECLARE_TLV_DB_SCALE(dap_volume, 0, 1, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(bass_band, -1175, 25, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(headphone_volume, -5150, 50, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(lineout_volume, -1550, 50, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(avc_max_gain, 0, 600, 0);\n\n \nstatic const DECLARE_TLV_DB_MINMAX(avc_threshold, 0, 9600);\n\nstatic const struct snd_kcontrol_new sgtl5000_snd_controls[] = {\n\t \n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"PCM Playback Volume\",\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\tSNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = dac_info_volsw,\n\t\t.get = dac_get_volsw,\n\t\t.put = dac_put_volsw,\n\t},\n\n\tSOC_DOUBLE(\"Capture Volume\", SGTL5000_CHIP_ANA_ADC_CTRL, 0, 4, 0xf, 0),\n\tSOC_SINGLE_TLV(\"Capture Attenuate Switch (-6dB)\",\n\t\t\tSGTL5000_CHIP_ANA_ADC_CTRL,\n\t\t\t8, 1, 0, capture_6db_attenuate),\n\tSOC_SINGLE(\"Capture ZC Switch\", SGTL5000_CHIP_ANA_CTRL, 1, 1, 0),\n\tSOC_SINGLE(\"Capture Switch\", SGTL5000_CHIP_ANA_CTRL, 0, 1, 1),\n\n\tSOC_DOUBLE_TLV(\"Headphone Playback Volume\",\n\t\t\tSGTL5000_CHIP_ANA_HP_CTRL,\n\t\t\t0, 8,\n\t\t\t0x7f, 1,\n\t\t\theadphone_volume),\n\tSOC_SINGLE(\"Headphone Playback Switch\", SGTL5000_CHIP_ANA_CTRL,\n\t\t\t4, 1, 1),\n\tSOC_SINGLE(\"Headphone Playback ZC Switch\", SGTL5000_CHIP_ANA_CTRL,\n\t\t\t5, 1, 0),\n\n\tSOC_SINGLE_TLV(\"Mic Volume\", SGTL5000_CHIP_MIC_CTRL,\n\t\t\t0, 3, 0, mic_gain_tlv),\n\n\tSOC_DOUBLE_TLV(\"Lineout Playback Volume\",\n\t\t\tSGTL5000_CHIP_LINE_OUT_VOL,\n\t\t\tSGTL5000_LINE_OUT_VOL_LEFT_SHIFT,\n\t\t\tSGTL5000_LINE_OUT_VOL_RIGHT_SHIFT,\n\t\t\t0x1f, 1,\n\t\t\tlineout_volume),\n\tSOC_SINGLE(\"Lineout Playback Switch\", SGTL5000_CHIP_ANA_CTRL, 8, 1, 1),\n\n\tSOC_SINGLE_TLV(\"DAP Main channel\", SGTL5000_DAP_MAIN_CHAN,\n\t0, 0xffff, 0, dap_volume),\n\n\tSOC_SINGLE_TLV(\"DAP Mix channel\", SGTL5000_DAP_MIX_CHAN,\n\t0, 0xffff, 0, dap_volume),\n\t \n\tSOC_SINGLE(\"AVC Switch\", SGTL5000_DAP_AVC_CTRL, 0, 1, 0),\n\tSOC_SINGLE(\"AVC Hard Limiter Switch\", SGTL5000_DAP_AVC_CTRL, 5, 1, 0),\n\tSOC_SINGLE_TLV(\"AVC Max Gain Volume\", SGTL5000_DAP_AVC_CTRL, 12, 2, 0,\n\t\t\tavc_max_gain),\n\tSOC_SINGLE(\"AVC Integrator Response\", SGTL5000_DAP_AVC_CTRL, 8, 3, 0),\n\tSOC_SINGLE_EXT_TLV(\"AVC Threshold Volume\", SGTL5000_DAP_AVC_THRESHOLD,\n\t\t\t0, 96, 0, avc_get_threshold, avc_put_threshold,\n\t\t\tavc_threshold),\n\n\tSOC_SINGLE_TLV(\"BASS 0\", SGTL5000_DAP_EQ_BASS_BAND0,\n\t0, 0x5F, 0, bass_band),\n\n\tSOC_SINGLE_TLV(\"BASS 1\", SGTL5000_DAP_EQ_BASS_BAND1,\n\t0, 0x5F, 0, bass_band),\n\n\tSOC_SINGLE_TLV(\"BASS 2\", SGTL5000_DAP_EQ_BASS_BAND2,\n\t0, 0x5F, 0, bass_band),\n\n\tSOC_SINGLE_TLV(\"BASS 3\", SGTL5000_DAP_EQ_BASS_BAND3,\n\t0, 0x5F, 0, bass_band),\n\n\tSOC_SINGLE_TLV(\"BASS 4\", SGTL5000_DAP_EQ_BASS_BAND4,\n\t0, 0x5F, 0, bass_band),\n};\n\n \nstatic int sgtl5000_mute_stream(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 i2s_pwr = SGTL5000_I2S_IN_POWERUP;\n\n\t \n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_DIG_POWER,\n\t\t\ti2s_pwr, mute ? 0 : i2s_pwr);\n\n\treturn 0;\n}\n\n \nstatic int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\tu16 i2sctl = 0;\n\n\tsgtl5000->master = 0;\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\ti2sctl |= SGTL5000_I2S_MASTER;\n\t\tsgtl5000->master = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\ti2sctl |= SGTL5000_I2S_MODE_PCM << SGTL5000_I2S_MODE_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\ti2sctl |= SGTL5000_I2S_MODE_PCM << SGTL5000_I2S_MODE_SHIFT;\n\t\ti2sctl |= SGTL5000_I2S_LRALIGN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\ti2sctl |= SGTL5000_I2S_MODE_I2S_LJ << SGTL5000_I2S_MODE_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\ti2sctl |= SGTL5000_I2S_MODE_RJ << SGTL5000_I2S_MODE_SHIFT;\n\t\ti2sctl |= SGTL5000_I2S_LRPOL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ti2sctl |= SGTL5000_I2S_MODE_I2S_LJ << SGTL5000_I2S_MODE_SHIFT;\n\t\ti2sctl |= SGTL5000_I2S_LRALIGN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsgtl5000->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\ti2sctl |= SGTL5000_I2S_SCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, SGTL5000_CHIP_I2S_CTRL, i2sctl);\n\n\treturn 0;\n}\n\n \nstatic int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t   int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase SGTL5000_SYSCLK:\n\t\tsgtl5000->sysclk = freq;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sgtl5000_set_clock(struct snd_soc_component *component, int frame_rate)\n{\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\tint clk_ctl = 0;\n\tint sys_fs;\t \n\n\t \n\tswitch (frame_rate) {\n\tcase 8000:\n\tcase 16000:\n\t\tsys_fs = 32000;\n\t\tbreak;\n\tcase 11025:\n\tcase 22050:\n\t\tsys_fs = 44100;\n\t\tbreak;\n\tdefault:\n\t\tsys_fs = frame_rate;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (sys_fs / frame_rate) {\n\tcase 4:\n\t\tclk_ctl |= SGTL5000_RATE_MODE_DIV_4 << SGTL5000_RATE_MODE_SHIFT;\n\t\tbreak;\n\tcase 2:\n\t\tclk_ctl |= SGTL5000_RATE_MODE_DIV_2 << SGTL5000_RATE_MODE_SHIFT;\n\t\tbreak;\n\tcase 1:\n\t\tclk_ctl |= SGTL5000_RATE_MODE_DIV_1 << SGTL5000_RATE_MODE_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (sys_fs) {\n\tcase 32000:\n\t\tclk_ctl |= SGTL5000_SYS_FS_32k << SGTL5000_SYS_FS_SHIFT;\n\t\tbreak;\n\tcase 44100:\n\t\tclk_ctl |= SGTL5000_SYS_FS_44_1k << SGTL5000_SYS_FS_SHIFT;\n\t\tbreak;\n\tcase 48000:\n\t\tclk_ctl |= SGTL5000_SYS_FS_48k << SGTL5000_SYS_FS_SHIFT;\n\t\tbreak;\n\tcase 96000:\n\t\tclk_ctl |= SGTL5000_SYS_FS_96k << SGTL5000_SYS_FS_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"frame rate %d not supported\\n\",\n\t\t\tframe_rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (sgtl5000->sysclk / frame_rate) {\n\tcase 256:\n\t\tclk_ctl |= SGTL5000_MCLK_FREQ_256FS <<\n\t\t\tSGTL5000_MCLK_FREQ_SHIFT;\n\t\tbreak;\n\tcase 384:\n\t\tclk_ctl |= SGTL5000_MCLK_FREQ_384FS <<\n\t\t\tSGTL5000_MCLK_FREQ_SHIFT;\n\t\tbreak;\n\tcase 512:\n\t\tclk_ctl |= SGTL5000_MCLK_FREQ_512FS <<\n\t\t\tSGTL5000_MCLK_FREQ_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (sgtl5000->master) {\n\t\t\tclk_ctl |= SGTL5000_MCLK_FREQ_PLL <<\n\t\t\t\tSGTL5000_MCLK_FREQ_SHIFT;\n\t\t} else {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"PLL not supported in slave mode\\n\");\n\t\t\tdev_err(component->dev, \"%d ratio is not supported. \"\n\t\t\t\t\"SYS_MCLK needs to be 256, 384 or 512 * fs\\n\",\n\t\t\t\tsgtl5000->sysclk / frame_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {\n\t\tu64 out, t;\n\t\tint div2;\n\t\tint pll_ctl;\n\t\tunsigned int in, int_div, frac_div;\n\n\t\tif (sgtl5000->sysclk > 17000000) {\n\t\t\tdiv2 = 1;\n\t\t\tin = sgtl5000->sysclk / 2;\n\t\t} else {\n\t\t\tdiv2 = 0;\n\t\t\tin = sgtl5000->sysclk;\n\t\t}\n\t\tif (sys_fs == 44100)\n\t\t\tout = 180633600;\n\t\telse\n\t\t\tout = 196608000;\n\t\tt = do_div(out, in);\n\t\tint_div = out;\n\t\tt *= 2048;\n\t\tdo_div(t, in);\n\t\tfrac_div = t;\n\t\tpll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |\n\t\t    frac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;\n\n\t\tsnd_soc_component_write(component, SGTL5000_CHIP_PLL_CTRL, pll_ctl);\n\t\tif (div2)\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tSGTL5000_CHIP_CLK_TOP_CTRL,\n\t\t\t\tSGTL5000_INPUT_FREQ_DIV2,\n\t\t\t\tSGTL5000_INPUT_FREQ_DIV2);\n\t\telse\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tSGTL5000_CHIP_CLK_TOP_CTRL,\n\t\t\t\tSGTL5000_INPUT_FREQ_DIV2,\n\t\t\t\t0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\t\tSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP,\n\t\t\tSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP);\n\n\t\t \n\t\tsnd_soc_component_write(component, SGTL5000_CHIP_CLK_CTRL, clk_ctl);\n\t} else {\n\t\t \n\t\tsnd_soc_component_write(component, SGTL5000_CHIP_CLK_CTRL, clk_ctl);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\t\tSGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP,\n\t\t\t0);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\tint channels = params_channels(params);\n\tint i2s_ctl = 0;\n\tint stereo;\n\tint ret;\n\n\t \n\tif (!sgtl5000->sysclk) {\n\t\tdev_err(component->dev, \"%s: set sysclk first!\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tstereo = SGTL5000_DAC_STEREO;\n\telse\n\t\tstereo = SGTL5000_ADC_STEREO;\n\n\t \n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER, stereo,\n\t\t\tchannels == 1 ? 0 : stereo);\n\n\t \n\tret = sgtl5000_set_clock(component, params_rate(params));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tif (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)\n\t\t\treturn -EINVAL;\n\t\ti2s_ctl |= SGTL5000_I2S_DLEN_16 << SGTL5000_I2S_DLEN_SHIFT;\n\t\ti2s_ctl |= SGTL5000_I2S_SCLKFREQ_32FS <<\n\t\t    SGTL5000_I2S_SCLKFREQ_SHIFT;\n\t\tbreak;\n\tcase 20:\n\t\ti2s_ctl |= SGTL5000_I2S_DLEN_20 << SGTL5000_I2S_DLEN_SHIFT;\n\t\ti2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\n\t\t    SGTL5000_I2S_SCLKFREQ_SHIFT;\n\t\tbreak;\n\tcase 24:\n\t\ti2s_ctl |= SGTL5000_I2S_DLEN_24 << SGTL5000_I2S_DLEN_SHIFT;\n\t\ti2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\n\t\t    SGTL5000_I2S_SCLKFREQ_SHIFT;\n\t\tbreak;\n\tcase 32:\n\t\tif (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)\n\t\t\treturn -EINVAL;\n\t\ti2s_ctl |= SGTL5000_I2S_DLEN_32 << SGTL5000_I2S_DLEN_SHIFT;\n\t\ti2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<\n\t\t    SGTL5000_I2S_SCLKFREQ_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_I2S_CTRL,\n\t\t\t    SGTL5000_I2S_DLEN_MASK | SGTL5000_I2S_SCLKFREQ_MASK,\n\t\t\t    i2s_ctl);\n\n\treturn 0;\n}\n\n \nstatic int sgtl5000_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct sgtl5000_priv *sgtl = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregcache_cache_only(sgtl->regmap, false);\n\t\tret = regcache_sync(sgtl->regmap);\n\t\tif (ret) {\n\t\t\tregcache_cache_only(sgtl->regmap, true);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\t\t\t    SGTL5000_REFTOP_POWERUP,\n\t\t\t\t    SGTL5000_REFTOP_POWERUP);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tregcache_cache_only(sgtl->regmap, true);\n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_POWER,\n\t\t\t\t    SGTL5000_REFTOP_POWERUP, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define SGTL5000_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops sgtl5000_ops = {\n\t.hw_params = sgtl5000_pcm_hw_params,\n\t.mute_stream = sgtl5000_mute_stream,\n\t.set_fmt = sgtl5000_set_dai_fmt,\n\t.set_sysclk = sgtl5000_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver sgtl5000_dai = {\n\t.name = \"sgtl5000\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t \n\t\t.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_96000,\n\t\t.formats = SGTL5000_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_96000,\n\t\t.formats = SGTL5000_FORMATS,\n\t},\n\t.ops = &sgtl5000_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic bool sgtl5000_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SGTL5000_CHIP_ID:\n\tcase SGTL5000_CHIP_ADCDAC_CTRL:\n\tcase SGTL5000_CHIP_ANA_STATUS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool sgtl5000_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SGTL5000_CHIP_ID:\n\tcase SGTL5000_CHIP_DIG_POWER:\n\tcase SGTL5000_CHIP_CLK_CTRL:\n\tcase SGTL5000_CHIP_I2S_CTRL:\n\tcase SGTL5000_CHIP_SSS_CTRL:\n\tcase SGTL5000_CHIP_ADCDAC_CTRL:\n\tcase SGTL5000_CHIP_DAC_VOL:\n\tcase SGTL5000_CHIP_PAD_STRENGTH:\n\tcase SGTL5000_CHIP_ANA_ADC_CTRL:\n\tcase SGTL5000_CHIP_ANA_HP_CTRL:\n\tcase SGTL5000_CHIP_ANA_CTRL:\n\tcase SGTL5000_CHIP_LINREG_CTRL:\n\tcase SGTL5000_CHIP_REF_CTRL:\n\tcase SGTL5000_CHIP_MIC_CTRL:\n\tcase SGTL5000_CHIP_LINE_OUT_CTRL:\n\tcase SGTL5000_CHIP_LINE_OUT_VOL:\n\tcase SGTL5000_CHIP_ANA_POWER:\n\tcase SGTL5000_CHIP_PLL_CTRL:\n\tcase SGTL5000_CHIP_CLK_TOP_CTRL:\n\tcase SGTL5000_CHIP_ANA_STATUS:\n\tcase SGTL5000_CHIP_SHORT_CTRL:\n\tcase SGTL5000_CHIP_ANA_TEST2:\n\tcase SGTL5000_DAP_CTRL:\n\tcase SGTL5000_DAP_PEQ:\n\tcase SGTL5000_DAP_BASS_ENHANCE:\n\tcase SGTL5000_DAP_BASS_ENHANCE_CTRL:\n\tcase SGTL5000_DAP_AUDIO_EQ:\n\tcase SGTL5000_DAP_SURROUND:\n\tcase SGTL5000_DAP_FLT_COEF_ACCESS:\n\tcase SGTL5000_DAP_COEF_WR_B0_MSB:\n\tcase SGTL5000_DAP_COEF_WR_B0_LSB:\n\tcase SGTL5000_DAP_EQ_BASS_BAND0:\n\tcase SGTL5000_DAP_EQ_BASS_BAND1:\n\tcase SGTL5000_DAP_EQ_BASS_BAND2:\n\tcase SGTL5000_DAP_EQ_BASS_BAND3:\n\tcase SGTL5000_DAP_EQ_BASS_BAND4:\n\tcase SGTL5000_DAP_MAIN_CHAN:\n\tcase SGTL5000_DAP_MIX_CHAN:\n\tcase SGTL5000_DAP_AVC_CTRL:\n\tcase SGTL5000_DAP_AVC_THRESHOLD:\n\tcase SGTL5000_DAP_AVC_ATTACK:\n\tcase SGTL5000_DAP_AVC_DECAY:\n\tcase SGTL5000_DAP_COEF_WR_B1_MSB:\n\tcase SGTL5000_DAP_COEF_WR_B1_LSB:\n\tcase SGTL5000_DAP_COEF_WR_B2_MSB:\n\tcase SGTL5000_DAP_COEF_WR_B2_LSB:\n\tcase SGTL5000_DAP_COEF_WR_A1_MSB:\n\tcase SGTL5000_DAP_COEF_WR_A1_LSB:\n\tcase SGTL5000_DAP_COEF_WR_A2_MSB:\n\tcase SGTL5000_DAP_COEF_WR_A2_LSB:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic const u8 vol_quot_table[] = {\n\t42, 45, 47, 50, 53, 56, 60, 63,\n\t67, 71, 75, 79, 84, 89, 94, 100,\n\t106, 112, 119, 126, 133, 141, 150, 158,\n\t168, 178, 188, 200, 211, 224, 237, 251\n};\n\n \nstatic int sgtl5000_set_power_regs(struct snd_soc_component *component)\n{\n\tint vddd;\n\tint vdda;\n\tint vddio;\n\tu16 ana_pwr;\n\tu16 lreg_ctrl;\n\tint vag;\n\tint lo_vag;\n\tint vol_quot;\n\tint lo_vol;\n\tsize_t i;\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\n\tvdda  = regulator_get_voltage(sgtl5000->supplies[VDDA].consumer);\n\tvddio = regulator_get_voltage(sgtl5000->supplies[VDDIO].consumer);\n\tvddd  = (sgtl5000->num_supplies > VDDD)\n\t\t? regulator_get_voltage(sgtl5000->supplies[VDDD].consumer)\n\t\t: LDO_VOLTAGE;\n\n\tvdda  = vdda / 1000;\n\tvddio = vddio / 1000;\n\tvddd  = vddd / 1000;\n\n\tif (vdda <= 0 || vddio <= 0 || vddd < 0) {\n\t\tdev_err(component->dev, \"regulator voltage not set correctly\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (vdda > 3600 || vddio > 3600 || vddd > 1980) {\n\t\tdev_err(component->dev,\n\t\t\t\"exceed max voltage vdda %dmV vddio %dmV vddd %dmV\\n\",\n\t\t\tvdda, vddio, vddd);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tana_pwr = snd_soc_component_read(component, SGTL5000_CHIP_ANA_POWER);\n\tana_pwr |= SGTL5000_DAC_STEREO |\n\t\t\tSGTL5000_ADC_STEREO |\n\t\t\tSGTL5000_REFTOP_POWERUP;\n\tlreg_ctrl = snd_soc_component_read(component, SGTL5000_CHIP_LINREG_CTRL);\n\n\tif (vddio < 3100 && vdda < 3100) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_CLK_TOP_CTRL,\n\t\t\t\t\tSGTL5000_INT_OSC_EN,\n\t\t\t\t\tSGTL5000_INT_OSC_EN);\n\t\t \n\t\tana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;\n\t} else {\n\t\tana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;\n\t\t \n\t\tif (regulator_is_equal(sgtl5000->supplies[VDDA].consumer,\n\t\t\t\t       sgtl5000->supplies[VDDIO].consumer)) {\n\t\t\tlreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;\n\t\t\tlreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<\n\t\t\t\t    SGTL5000_VDDC_MAN_ASSN_SHIFT;\n\t\t}\n\t}\n\n\tsnd_soc_component_write(component, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);\n\n\tsnd_soc_component_write(component, SGTL5000_CHIP_ANA_POWER, ana_pwr);\n\n\t \n\tvag = vdda / 2;\n\tif (vag <= SGTL5000_ANA_GND_BASE)\n\t\tvag = 0;\n\telse if (vag >= SGTL5000_ANA_GND_BASE + SGTL5000_ANA_GND_STP *\n\t\t (SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT))\n\t\tvag = SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT;\n\telse\n\t\tvag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_REF_CTRL,\n\t\t\tSGTL5000_ANA_GND_MASK, vag << SGTL5000_ANA_GND_SHIFT);\n\n\t \n\tlo_vag = vddio / 2;\n\tif (lo_vag <= SGTL5000_LINE_OUT_GND_BASE)\n\t\tlo_vag = 0;\n\telse if (lo_vag >= SGTL5000_LINE_OUT_GND_BASE +\n\t\tSGTL5000_LINE_OUT_GND_STP * SGTL5000_LINE_OUT_GND_MAX)\n\t\tlo_vag = SGTL5000_LINE_OUT_GND_MAX;\n\telse\n\t\tlo_vag = (lo_vag - SGTL5000_LINE_OUT_GND_BASE) /\n\t\t    SGTL5000_LINE_OUT_GND_STP;\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_LINE_OUT_CTRL,\n\t\t\tSGTL5000_LINE_OUT_CURRENT_MASK |\n\t\t\tSGTL5000_LINE_OUT_GND_MASK,\n\t\t\tlo_vag << SGTL5000_LINE_OUT_GND_SHIFT |\n\t\t\tSGTL5000_LINE_OUT_CURRENT_360u <<\n\t\t\t\tSGTL5000_LINE_OUT_CURRENT_SHIFT);\n\n\t \n\tvol_quot = lo_vag ? (vag * 100) / lo_vag : 0;\n\tlo_vol = 0;\n\tfor (i = 0; i < ARRAY_SIZE(vol_quot_table); i++) {\n\t\tif (vol_quot >= vol_quot_table[i])\n\t\t\tlo_vol = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_LINE_OUT_VOL,\n\t\tSGTL5000_LINE_OUT_VOL_RIGHT_MASK |\n\t\tSGTL5000_LINE_OUT_VOL_LEFT_MASK,\n\t\tlo_vol << SGTL5000_LINE_OUT_VOL_RIGHT_SHIFT |\n\t\tlo_vol << SGTL5000_LINE_OUT_VOL_LEFT_SHIFT);\n\n\treturn 0;\n}\n\nstatic int sgtl5000_enable_regulators(struct i2c_client *client)\n{\n\tint ret;\n\tint i;\n\tint external_vddd = 0;\n\tstruct regulator *vddd;\n\tstruct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);\n\n\tfor (i = 0; i < ARRAY_SIZE(sgtl5000->supplies); i++)\n\t\tsgtl5000->supplies[i].supply = supply_names[i];\n\n\tvddd = regulator_get_optional(&client->dev, \"VDDD\");\n\tif (IS_ERR(vddd)) {\n\t\t \n\t\tif (PTR_ERR(vddd) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t} else {\n\t\texternal_vddd = 1;\n\t\tregulator_put(vddd);\n\t}\n\n\tsgtl5000->num_supplies = ARRAY_SIZE(sgtl5000->supplies)\n\t\t\t\t - 1 + external_vddd;\n\tret = regulator_bulk_get(&client->dev, sgtl5000->num_supplies,\n\t\t\t\t sgtl5000->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_bulk_enable(sgtl5000->num_supplies,\n\t\t\t\t    sgtl5000->supplies);\n\tif (!ret)\n\t\tusleep_range(10, 20);\n\telse\n\t\tregulator_bulk_free(sgtl5000->num_supplies,\n\t\t\t\t    sgtl5000->supplies);\n\n\treturn ret;\n}\n\nstatic int sgtl5000_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\tu16 reg;\n\tstruct sgtl5000_priv *sgtl5000 = snd_soc_component_get_drvdata(component);\n\tunsigned int zcd_mask = SGTL5000_HP_ZCD_EN | SGTL5000_ADC_ZCD_EN;\n\n\t \n\tret = sgtl5000_set_power_regs(component);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_REF_CTRL,\n\t\t\t\tSGTL5000_SMALL_POP, SGTL5000_SMALL_POP);\n\n\t \n\tsnd_soc_component_write(component, SGTL5000_CHIP_SHORT_CTRL, 0);\n\n\tsnd_soc_component_write(component, SGTL5000_CHIP_DIG_POWER,\n\t\t\tSGTL5000_ADC_EN | SGTL5000_DAC_EN);\n\n\t \n\tsnd_soc_component_write(component, SGTL5000_CHIP_ADCDAC_CTRL,\n\t\t\tSGTL5000_DAC_VOL_RAMP_EN |\n\t\t\tSGTL5000_DAC_MUTE_RIGHT |\n\t\t\tSGTL5000_DAC_MUTE_LEFT);\n\n\treg = ((sgtl5000->lrclk_strength) << SGTL5000_PAD_I2S_LRCLK_SHIFT |\n\t       (sgtl5000->sclk_strength) << SGTL5000_PAD_I2S_SCLK_SHIFT |\n\t       0x1f);\n\tsnd_soc_component_write(component, SGTL5000_CHIP_PAD_STRENGTH, reg);\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ANA_CTRL,\n\t\tzcd_mask, zcd_mask);\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_MIC_CTRL,\n\t\t\tSGTL5000_BIAS_R_MASK,\n\t\t\tsgtl5000->micbias_resistor << SGTL5000_BIAS_R_SHIFT);\n\n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_MIC_CTRL,\n\t\t\tSGTL5000_BIAS_VOLT_MASK,\n\t\t\tsgtl5000->micbias_voltage << SGTL5000_BIAS_VOLT_SHIFT);\n\t \n\tsnd_soc_component_write(component, SGTL5000_DAP_AUDIO_EQ, SGTL5000_DAP_SEL_GEQ);\n\n\t \n\tsnd_soc_component_update_bits(component, SGTL5000_CHIP_ADCDAC_CTRL,\n\t\tSGTL5000_DAC_MUTE_LEFT | SGTL5000_DAC_MUTE_RIGHT, 0);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int sgtl5000_of_xlate_dai_id(struct snd_soc_component *component,\n\t\t\t\t    struct device_node *endpoint)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver sgtl5000_driver = {\n\t.probe\t\t\t= sgtl5000_probe,\n\t.set_bias_level\t\t= sgtl5000_set_bias_level,\n\t.controls\t\t= sgtl5000_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sgtl5000_snd_controls),\n\t.dapm_widgets\t\t= sgtl5000_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sgtl5000_dapm_widgets),\n\t.dapm_routes\t\t= sgtl5000_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(sgtl5000_dapm_routes),\n\t.of_xlate_dai_id\t= sgtl5000_of_xlate_dai_id,\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config sgtl5000_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_stride = 2,\n\n\t.max_register = SGTL5000_MAX_REG_OFFSET,\n\t.volatile_reg = sgtl5000_volatile,\n\t.readable_reg = sgtl5000_readable,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = sgtl5000_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(sgtl5000_reg_defaults),\n};\n\n \nstatic void sgtl5000_fill_defaults(struct i2c_client *client)\n{\n\tstruct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);\n\tint i, ret, val, index;\n\n\tfor (i = 0; i < ARRAY_SIZE(sgtl5000_reg_defaults); i++) {\n\t\tval = sgtl5000_reg_defaults[i].def;\n\t\tindex = sgtl5000_reg_defaults[i].reg;\n\t\tret = regmap_write(sgtl5000->regmap, index, val);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"%s: error %d setting reg 0x%02x to 0x%04x\\n\",\n\t\t\t\t__func__, ret, index, val);\n\t}\n}\n\nstatic int sgtl5000_i2c_probe(struct i2c_client *client)\n{\n\tstruct sgtl5000_priv *sgtl5000;\n\tint ret, reg, rev;\n\tstruct device_node *np = client->dev.of_node;\n\tu32 value;\n\tu16 ana_pwr;\n\n\tsgtl5000 = devm_kzalloc(&client->dev, sizeof(*sgtl5000), GFP_KERNEL);\n\tif (!sgtl5000)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, sgtl5000);\n\n\tret = sgtl5000_enable_regulators(client);\n\tif (ret)\n\t\treturn ret;\n\n\tsgtl5000->regmap = devm_regmap_init_i2c(client, &sgtl5000_regmap);\n\tif (IS_ERR(sgtl5000->regmap)) {\n\t\tret = PTR_ERR(sgtl5000->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\tgoto disable_regs;\n\t}\n\n\tsgtl5000->mclk = devm_clk_get(&client->dev, NULL);\n\tif (IS_ERR(sgtl5000->mclk)) {\n\t\tret = PTR_ERR(sgtl5000->mclk);\n\t\t \n\t\tif (ret == -ENOENT)\n\t\t\tret = -EPROBE_DEFER;\n\n\t\tdev_err_probe(&client->dev, ret, \"Failed to get mclock\\n\");\n\n\t\tgoto disable_regs;\n\t}\n\n\tret = clk_prepare_enable(sgtl5000->mclk);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Error enabling clock %d\\n\", ret);\n\t\tgoto disable_regs;\n\t}\n\n\t \n\tudelay(1);\n\n\t \n\tret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ID, &reg);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Error reading chip id %d\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\tif (((reg & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=\n\t    SGTL5000_PARTID_PART_ID) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Device with ID register %x is not a sgtl5000\\n\", reg);\n\t\tret = -ENODEV;\n\t\tgoto disable_clk;\n\t}\n\n\trev = (reg & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;\n\tdev_info(&client->dev, \"sgtl5000 revision 0x%x\\n\", rev);\n\tsgtl5000->revision = rev;\n\n\t \n\tret = regmap_write(sgtl5000->regmap,\n\t\t\t   SGTL5000_CHIP_CLK_CTRL,\n\t\t\t   SGTL5000_CHIP_CLK_CTRL_DEFAULT);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Error %d initializing CHIP_CLK_CTRL\\n\", ret);\n\n\t \n\tret = regmap_write(sgtl5000->regmap, SGTL5000_CHIP_ANA_CTRL,\n\t\t\t   SGTL5000_CHIP_ANA_CTRL_DEFAULT);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"Error %d muting outputs via CHIP_ANA_CTRL\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tret = regmap_read(sgtl5000->regmap, SGTL5000_CHIP_ANA_POWER, &value);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to read ANA_POWER: %d\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\tif (value & SGTL5000_VAG_POWERUP) {\n\t\tret = regmap_update_bits(sgtl5000->regmap,\n\t\t\t\t\t SGTL5000_CHIP_ANA_POWER,\n\t\t\t\t\t SGTL5000_VAG_POWERUP,\n\t\t\t\t\t 0);\n\t\tif (ret) {\n\t\t\tdev_err(&client->dev, \"Error %d disabling VAG\\n\", ret);\n\t\t\tgoto disable_clk;\n\t\t}\n\n\t\tmsleep(SGTL5000_VAG_POWERDOWN_DELAY);\n\t}\n\n\t \n\tana_pwr = SGTL5000_ANA_POWER_DEFAULT;\n\tif (sgtl5000->num_supplies <= VDDD) {\n\t\t \n\t\tret = regmap_update_bits(sgtl5000->regmap,\n\t\t\t\t\t SGTL5000_CHIP_LINREG_CTRL,\n\t\t\t\t\t SGTL5000_LINREG_VDDD_MASK,\n\t\t\t\t\t LINREG_VDDD);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Error %d setting LINREG_VDDD\\n\", ret);\n\n\t\tana_pwr |= SGTL5000_LINEREG_D_POWERUP;\n\t\tdev_info(&client->dev,\n\t\t\t \"Using internal LDO instead of VDDD: check ER1 erratum\\n\");\n\t} else {\n\t\t \n\t\tana_pwr &= ~(SGTL5000_STARTUP_POWERUP\n\t\t\t     | SGTL5000_LINREG_SIMPLE_POWERUP);\n\t\tdev_dbg(&client->dev, \"Using external VDDD\\n\");\n\t}\n\tret = regmap_write(sgtl5000->regmap, SGTL5000_CHIP_ANA_POWER, ana_pwr);\n\tif (ret)\n\t\tdev_err(&client->dev,\n\t\t\t\"Error %d setting CHIP_ANA_POWER to %04x\\n\",\n\t\t\tret, ana_pwr);\n\n\tif (np) {\n\t\tif (!of_property_read_u32(np,\n\t\t\t\"micbias-resistor-k-ohms\", &value)) {\n\t\t\tswitch (value) {\n\t\t\tcase SGTL5000_MICBIAS_OFF:\n\t\t\t\tsgtl5000->micbias_resistor = 0;\n\t\t\t\tbreak;\n\t\t\tcase SGTL5000_MICBIAS_2K:\n\t\t\t\tsgtl5000->micbias_resistor = 1;\n\t\t\t\tbreak;\n\t\t\tcase SGTL5000_MICBIAS_4K:\n\t\t\t\tsgtl5000->micbias_resistor = 2;\n\t\t\t\tbreak;\n\t\t\tcase SGTL5000_MICBIAS_8K:\n\t\t\t\tsgtl5000->micbias_resistor = 3;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsgtl5000->micbias_resistor = 2;\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Unsuitable MicBias resistor\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tsgtl5000->micbias_resistor = 2;\n\t\t}\n\t\tif (!of_property_read_u32(np,\n\t\t\t\"micbias-voltage-m-volts\", &value)) {\n\t\t\t \n\t\t\t \n\t\t\tif ((value >= 1250) && (value <= 3000))\n\t\t\t\tsgtl5000->micbias_voltage = (value / 250) - 5;\n\t\t\telse {\n\t\t\t\tsgtl5000->micbias_voltage = 0;\n\t\t\t\tdev_err(&client->dev,\n\t\t\t\t\t\"Unsuitable MicBias voltage\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tsgtl5000->micbias_voltage = 0;\n\t\t}\n\t}\n\n\tsgtl5000->lrclk_strength = I2S_LRCLK_STRENGTH_LOW;\n\tif (!of_property_read_u32(np, \"lrclk-strength\", &value)) {\n\t\tif (value > I2S_LRCLK_STRENGTH_HIGH)\n\t\t\tvalue = I2S_LRCLK_STRENGTH_LOW;\n\t\tsgtl5000->lrclk_strength = value;\n\t}\n\n\tsgtl5000->sclk_strength = I2S_SCLK_STRENGTH_LOW;\n\tif (!of_property_read_u32(np, \"sclk-strength\", &value)) {\n\t\tif (value > I2S_SCLK_STRENGTH_HIGH)\n\t\t\tvalue = I2S_SCLK_STRENGTH_LOW;\n\t\tsgtl5000->sclk_strength = value;\n\t}\n\n\t \n\tsgtl5000_fill_defaults(client);\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t&sgtl5000_driver, &sgtl5000_dai, 1);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(sgtl5000->mclk);\n\ndisable_regs:\n\tregulator_bulk_disable(sgtl5000->num_supplies, sgtl5000->supplies);\n\tregulator_bulk_free(sgtl5000->num_supplies, sgtl5000->supplies);\n\n\treturn ret;\n}\n\nstatic void sgtl5000_i2c_remove(struct i2c_client *client)\n{\n\tstruct sgtl5000_priv *sgtl5000 = i2c_get_clientdata(client);\n\n\tregmap_write(sgtl5000->regmap, SGTL5000_CHIP_CLK_CTRL, SGTL5000_CHIP_CLK_CTRL_DEFAULT);\n\tregmap_write(sgtl5000->regmap, SGTL5000_CHIP_DIG_POWER, SGTL5000_DIG_POWER_DEFAULT);\n\tregmap_write(sgtl5000->regmap, SGTL5000_CHIP_ANA_POWER, SGTL5000_ANA_POWER_DEFAULT);\n\n\tclk_disable_unprepare(sgtl5000->mclk);\n\tregulator_bulk_disable(sgtl5000->num_supplies, sgtl5000->supplies);\n\tregulator_bulk_free(sgtl5000->num_supplies, sgtl5000->supplies);\n}\n\nstatic void sgtl5000_i2c_shutdown(struct i2c_client *client)\n{\n\tsgtl5000_i2c_remove(client);\n}\n\nstatic const struct i2c_device_id sgtl5000_id[] = {\n\t{\"sgtl5000\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, sgtl5000_id);\n\nstatic const struct of_device_id sgtl5000_dt_ids[] = {\n\t{ .compatible = \"fsl,sgtl5000\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sgtl5000_dt_ids);\n\nstatic struct i2c_driver sgtl5000_i2c_driver = {\n\t.driver = {\n\t\t.name = \"sgtl5000\",\n\t\t.of_match_table = sgtl5000_dt_ids,\n\t},\n\t.probe = sgtl5000_i2c_probe,\n\t.remove = sgtl5000_i2c_remove,\n\t.shutdown = sgtl5000_i2c_shutdown,\n\t.id_table = sgtl5000_id,\n};\n\nmodule_i2c_driver(sgtl5000_i2c_driver);\n\nMODULE_DESCRIPTION(\"Freescale SGTL5000 ALSA SoC Codec Driver\");\nMODULE_AUTHOR(\"Zeng Zhaoming <zengzm.kernel@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}