{
  "module_name": "aw8738.c",
  "hash_id": "7819576ba14212d393a0718d439cf34310a5107ed6833d7b5655d8735df1bd6c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/aw8738.c",
  "human_readable_source": "\n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n\nstruct aw8738_priv {\n\tstruct gpio_desc *gpiod_mode;\n\tunsigned int mode;\n};\n\nstatic int aw8738_drv_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct aw8738_priv *aw = snd_soc_component_get_drvdata(c);\n\tint i;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tfor (i = 0; i < aw->mode; i++) {\n\t\t\tgpiod_set_value_cansleep(aw->gpiod_mode, 0);\n\t\t\tudelay(2);\n\t\t\tgpiod_set_value_cansleep(aw->gpiod_mode, 1);\n\t\t\tudelay(2);\n\t\t}\n\t\tmsleep(40);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tgpiod_set_value_cansleep(aw->gpiod_mode, 0);\n\t\tusleep_range(1000, 2000);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected event\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget aw8738_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"IN\"),\n\tSND_SOC_DAPM_OUT_DRV_E(\"DRV\", SND_SOC_NOPM, 0, 0, NULL, 0, aw8738_drv_event,\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route aw8738_dapm_routes[] = {\n\t{ \"DRV\", NULL, \"IN\" },\n\t{ \"OUT\", NULL, \"DRV\" },\n};\n\nstatic const struct snd_soc_component_driver aw8738_component_driver = {\n\t.dapm_widgets = aw8738_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(aw8738_dapm_widgets),\n\t.dapm_routes = aw8738_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(aw8738_dapm_routes),\n};\n\nstatic int aw8738_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct aw8738_priv *aw;\n\tint ret;\n\n\taw = devm_kzalloc(dev, sizeof(*aw), GFP_KERNEL);\n\tif (!aw)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, aw);\n\n\taw->gpiod_mode = devm_gpiod_get(dev, \"mode\", GPIOD_OUT_LOW);\n\tif (IS_ERR(aw->gpiod_mode))\n\t\treturn dev_err_probe(dev, PTR_ERR(aw->gpiod_mode),\n\t\t\t\t     \"Failed to get 'mode' gpio\");\n\n\tret = device_property_read_u32(dev, \"awinic,mode\", &aw->mode);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t       &aw8738_component_driver,\n\t\t\t\t\t       NULL, 0);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id aw8738_of_match[] = {\n\t{ .compatible = \"awinic,aw8738\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, aw8738_of_match);\n#endif\n\nstatic struct platform_driver aw8738_driver = {\n\t.probe\t= aw8738_probe,\n\t.driver = {\n\t\t.name = \"aw8738\",\n\t\t.of_match_table = of_match_ptr(aw8738_of_match),\n\t},\n};\nmodule_platform_driver(aw8738_driver);\n\nMODULE_DESCRIPTION(\"Awinic AW8738 Amplifier Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}