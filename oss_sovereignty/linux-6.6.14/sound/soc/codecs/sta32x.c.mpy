{
  "module_name": "sta32x.c",
  "hash_id": "603576eb79159e179998e29dfe806d63d10a4ccdd72cb4f7235bbbb5a8b7c39e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sta32x.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s:%d: \" fmt, __func__, __LINE__\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/sta32x.h>\n#include \"sta32x.h\"\n\n#define STA32X_RATES (SNDRV_PCM_RATE_32000 | \\\n\t\t      SNDRV_PCM_RATE_44100 | \\\n\t\t      SNDRV_PCM_RATE_48000 | \\\n\t\t      SNDRV_PCM_RATE_88200 | \\\n\t\t      SNDRV_PCM_RATE_96000 | \\\n\t\t      SNDRV_PCM_RATE_176400 | \\\n\t\t      SNDRV_PCM_RATE_192000)\n\n#define STA32X_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S32_LE)\n\n \nstatic const struct reg_default sta32x_regs[] = {\n\t{  0x0, 0x63 },\n\t{  0x1, 0x80 },\n\t{  0x2, 0xc2 },\n\t{  0x3, 0x40 },\n\t{  0x4, 0xc2 },\n\t{  0x5, 0x5c },\n\t{  0x6, 0x10 },\n\t{  0x7, 0xff },\n\t{  0x8, 0x60 },\n\t{  0x9, 0x60 },\n\t{  0xa, 0x60 },\n\t{  0xb, 0x80 },\n\t{  0xc, 0x00 },\n\t{  0xd, 0x00 },\n\t{  0xe, 0x00 },\n\t{  0xf, 0x40 },\n\t{ 0x10, 0x80 },\n\t{ 0x11, 0x77 },\n\t{ 0x12, 0x6a },\n\t{ 0x13, 0x69 },\n\t{ 0x14, 0x6a },\n\t{ 0x15, 0x69 },\n\t{ 0x16, 0x00 },\n\t{ 0x17, 0x00 },\n\t{ 0x18, 0x00 },\n\t{ 0x19, 0x00 },\n\t{ 0x1a, 0x00 },\n\t{ 0x1b, 0x00 },\n\t{ 0x1c, 0x00 },\n\t{ 0x1d, 0x00 },\n\t{ 0x1e, 0x00 },\n\t{ 0x1f, 0x00 },\n\t{ 0x20, 0x00 },\n\t{ 0x21, 0x00 },\n\t{ 0x22, 0x00 },\n\t{ 0x23, 0x00 },\n\t{ 0x24, 0x00 },\n\t{ 0x25, 0x00 },\n\t{ 0x26, 0x00 },\n\t{ 0x27, 0x2d },\n\t{ 0x28, 0xc0 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x0c },\n};\n\nstatic const struct regmap_range sta32x_write_regs_range[] = {\n\tregmap_reg_range(STA32X_CONFA,  STA32X_FDRC2),\n};\n\nstatic const struct regmap_range sta32x_read_regs_range[] = {\n\tregmap_reg_range(STA32X_CONFA,  STA32X_FDRC2),\n};\n\nstatic const struct regmap_range sta32x_volatile_regs_range[] = {\n\tregmap_reg_range(STA32X_CFADDR2, STA32X_CFUD),\n};\n\nstatic const struct regmap_access_table sta32x_write_regs = {\n\t.yes_ranges =\tsta32x_write_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta32x_write_regs_range),\n};\n\nstatic const struct regmap_access_table sta32x_read_regs = {\n\t.yes_ranges =\tsta32x_read_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta32x_read_regs_range),\n};\n\nstatic const struct regmap_access_table sta32x_volatile_regs = {\n\t.yes_ranges =\tsta32x_volatile_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta32x_volatile_regs_range),\n};\n\n \nstatic const char *sta32x_supply_names[] = {\n\t\"Vdda\",\t \n\t\"Vdd3\",\t \n\t\"Vcc\"\t \n};\n\n \nstruct sta32x_priv {\n\tstruct regmap *regmap;\n\tstruct clk *xti_clk;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(sta32x_supply_names)];\n\tstruct snd_soc_component *component;\n\tstruct sta32x_platform_data *pdata;\n\n\tunsigned int mclk;\n\tunsigned int format;\n\n\tu32 coef_shadow[STA32X_COEF_COUNT];\n\tstruct delayed_work watchdog_work;\n\tint shutdown;\n\tstruct gpio_desc *gpiod_nreset;\n\tstruct mutex coeff_lock;\n};\n\nstatic const DECLARE_TLV_DB_SCALE(mvol_tlv, -12700, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(chvol_tlv, -7950, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(tone_tlv, -120, 200, 0);\n\nstatic const char *sta32x_drc_ac[] = {\n\t\"Anti-Clipping\", \"Dynamic Range Compression\" };\nstatic const char *sta32x_auto_eq_mode[] = {\n\t\"User\", \"Preset\", \"Loudness\" };\nstatic const char *sta32x_auto_gc_mode[] = {\n\t\"User\", \"AC no clipping\", \"AC limited clipping (10%)\",\n\t\"DRC nighttime listening mode\" };\nstatic const char *sta32x_auto_xo_mode[] = {\n\t\"User\", \"80Hz\", \"100Hz\", \"120Hz\", \"140Hz\", \"160Hz\", \"180Hz\", \"200Hz\",\n\t\"220Hz\", \"240Hz\", \"260Hz\", \"280Hz\", \"300Hz\", \"320Hz\", \"340Hz\", \"360Hz\" };\nstatic const char *sta32x_preset_eq_mode[] = {\n\t\"Flat\", \"Rock\", \"Soft Rock\", \"Jazz\", \"Classical\", \"Dance\", \"Pop\", \"Soft\",\n\t\"Hard\", \"Party\", \"Vocal\", \"Hip-Hop\", \"Dialog\", \"Bass-boost #1\",\n\t\"Bass-boost #2\", \"Bass-boost #3\", \"Loudness 1\", \"Loudness 2\",\n\t\"Loudness 3\", \"Loudness 4\", \"Loudness 5\", \"Loudness 6\", \"Loudness 7\",\n\t\"Loudness 8\", \"Loudness 9\", \"Loudness 10\", \"Loudness 11\", \"Loudness 12\",\n\t\"Loudness 13\", \"Loudness 14\", \"Loudness 15\", \"Loudness 16\" };\nstatic const char *sta32x_limiter_select[] = {\n\t\"Limiter Disabled\", \"Limiter #1\", \"Limiter #2\" };\nstatic const char *sta32x_limiter_attack_rate[] = {\n\t\"3.1584\", \"2.7072\", \"2.2560\", \"1.8048\", \"1.3536\", \"0.9024\",\n\t\"0.4512\", \"0.2256\", \"0.1504\", \"0.1123\", \"0.0902\", \"0.0752\",\n\t\"0.0645\", \"0.0564\", \"0.0501\", \"0.0451\" };\nstatic const char *sta32x_limiter_release_rate[] = {\n\t\"0.5116\", \"0.1370\", \"0.0744\", \"0.0499\", \"0.0360\", \"0.0299\",\n\t\"0.0264\", \"0.0208\", \"0.0198\", \"0.0172\", \"0.0147\", \"0.0137\",\n\t\"0.0134\", \"0.0117\", \"0.0110\", \"0.0104\" };\nstatic DECLARE_TLV_DB_RANGE(sta32x_limiter_ac_attack_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t8, 16, TLV_DB_SCALE_ITEM(300, 100, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta32x_limiter_ac_release_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(-2900, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(-2000, 0, 0),\n\t3, 8, TLV_DB_SCALE_ITEM(-1400, 200, 0),\n\t8, 16, TLV_DB_SCALE_ITEM(-700, 100, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta32x_limiter_drc_attack_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-3100, 200, 0),\n\t8, 13, TLV_DB_SCALE_ITEM(-1600, 100, 0),\n\t14, 16, TLV_DB_SCALE_ITEM(-1000, 300, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta32x_limiter_drc_release_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),\n\t1, 2, TLV_DB_SCALE_ITEM(-3800, 200, 0),\n\t3, 4, TLV_DB_SCALE_ITEM(-3300, 200, 0),\n\t5, 12, TLV_DB_SCALE_ITEM(-3000, 200, 0),\n\t13, 16, TLV_DB_SCALE_ITEM(-1500, 300, 0),\n);\n\nstatic SOC_ENUM_SINGLE_DECL(sta32x_drc_ac_enum,\n\t\t\t    STA32X_CONFD, STA32X_CONFD_DRC_SHIFT,\n\t\t\t    sta32x_drc_ac);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_auto_eq_enum,\n\t\t\t    STA32X_AUTO1, STA32X_AUTO1_AMEQ_SHIFT,\n\t\t\t    sta32x_auto_eq_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_auto_gc_enum,\n\t\t\t    STA32X_AUTO1, STA32X_AUTO1_AMGC_SHIFT,\n\t\t\t    sta32x_auto_gc_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_auto_xo_enum,\n\t\t\t    STA32X_AUTO2, STA32X_AUTO2_XO_SHIFT,\n\t\t\t    sta32x_auto_xo_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_preset_eq_enum,\n\t\t\t    STA32X_AUTO3, STA32X_AUTO3_PEQ_SHIFT,\n\t\t\t    sta32x_preset_eq_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter_ch1_enum,\n\t\t\t    STA32X_C1CFG, STA32X_CxCFG_LS_SHIFT,\n\t\t\t    sta32x_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter_ch2_enum,\n\t\t\t    STA32X_C2CFG, STA32X_CxCFG_LS_SHIFT,\n\t\t\t    sta32x_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter_ch3_enum,\n\t\t\t    STA32X_C3CFG, STA32X_CxCFG_LS_SHIFT,\n\t\t\t    sta32x_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter1_attack_rate_enum,\n\t\t\t    STA32X_L1AR, STA32X_LxA_SHIFT,\n\t\t\t    sta32x_limiter_attack_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter2_attack_rate_enum,\n\t\t\t    STA32X_L2AR, STA32X_LxA_SHIFT,\n\t\t\t    sta32x_limiter_attack_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter1_release_rate_enum,\n\t\t\t    STA32X_L1AR, STA32X_LxR_SHIFT,\n\t\t\t    sta32x_limiter_release_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta32x_limiter2_release_rate_enum,\n\t\t\t    STA32X_L2AR, STA32X_LxR_SHIFT,\n\t\t\t    sta32x_limiter_release_rate);\n\n \n\nstatic int sta32x_coefficient_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint numcoef = kcontrol->private_value >> 16;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = 3 * numcoef;\n\treturn 0;\n}\n\nstatic int sta32x_coefficient_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\tunsigned int cfud, val;\n\tint i, ret = 0;\n\n\tmutex_lock(&sta32x->coeff_lock);\n\n\t \n\tregmap_read(sta32x->regmap, STA32X_CFUD, &cfud);\n\tcfud &= 0xf0;\n\t \n\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud);\n\n\tregmap_write(sta32x->regmap, STA32X_CFADDR2, index);\n\tif (numcoef == 1) {\n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud | 0x04);\n\t} else if (numcoef == 5) {\n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud | 0x08);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto exit_unlock;\n\t}\n\n\tfor (i = 0; i < 3 * numcoef; i++) {\n\t\tregmap_read(sta32x->regmap, STA32X_B1CF1 + i, &val);\n\t\tucontrol->value.bytes.data[i] = val;\n\t}\n\nexit_unlock:\n\tmutex_unlock(&sta32x->coeff_lock);\n\n\treturn ret;\n}\n\nstatic int sta32x_coefficient_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\tunsigned int cfud;\n\tint i;\n\n\t \n\tregmap_read(sta32x->regmap, STA32X_CFUD, &cfud);\n\tcfud &= 0xf0;\n\t \n\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud);\n\n\tregmap_write(sta32x->regmap, STA32X_CFADDR2, index);\n\tfor (i = 0; i < numcoef && (index + i < STA32X_COEF_COUNT); i++)\n\t\tsta32x->coef_shadow[index + i] =\n\t\t\t  (ucontrol->value.bytes.data[3 * i] << 16)\n\t\t\t| (ucontrol->value.bytes.data[3 * i + 1] << 8)\n\t\t\t| (ucontrol->value.bytes.data[3 * i + 2]);\n\tfor (i = 0; i < 3 * numcoef; i++)\n\t\tregmap_write(sta32x->regmap, STA32X_B1CF1 + i,\n\t\t\t     ucontrol->value.bytes.data[i]);\n\tif (numcoef == 1)\n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud | 0x01);\n\telse if (numcoef == 5)\n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud | 0x02);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sta32x_sync_coef_shadow(struct snd_soc_component *component)\n{\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tunsigned int cfud;\n\tint i;\n\n\t \n\tregmap_read(sta32x->regmap, STA32X_CFUD, &cfud);\n\tcfud &= 0xf0;\n\n\tfor (i = 0; i < STA32X_COEF_COUNT; i++) {\n\t\tregmap_write(sta32x->regmap, STA32X_CFADDR2, i);\n\t\tregmap_write(sta32x->regmap, STA32X_B1CF1,\n\t\t\t     (sta32x->coef_shadow[i] >> 16) & 0xff);\n\t\tregmap_write(sta32x->regmap, STA32X_B1CF2,\n\t\t\t     (sta32x->coef_shadow[i] >> 8) & 0xff);\n\t\tregmap_write(sta32x->regmap, STA32X_B1CF3,\n\t\t\t     (sta32x->coef_shadow[i]) & 0xff);\n\t\t \n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud);\n\t\tregmap_write(sta32x->regmap, STA32X_CFUD, cfud | 0x01);\n\t}\n\treturn 0;\n}\n\nstatic int sta32x_cache_sync(struct snd_soc_component *component)\n{\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tunsigned int mute;\n\tint rc;\n\n\t \n\tregmap_read(sta32x->regmap, STA32X_MMUTE, &mute);\n\tregmap_write(sta32x->regmap, STA32X_MMUTE, mute | STA32X_MMUTE_MMUTE);\n\tsta32x_sync_coef_shadow(component);\n\trc = regcache_sync(sta32x->regmap);\n\tregmap_write(sta32x->regmap, STA32X_MMUTE, mute);\n\treturn rc;\n}\n\n \nstatic void sta32x_watchdog(struct work_struct *work)\n{\n\tstruct sta32x_priv *sta32x = container_of(work, struct sta32x_priv,\n\t\t\t\t\t\t  watchdog_work.work);\n\tstruct snd_soc_component *component = sta32x->component;\n\tunsigned int confa, confa_cached;\n\n\t \n\tconfa_cached = snd_soc_component_read(component, STA32X_CONFA);\n\tregcache_cache_bypass(sta32x->regmap, true);\n\tconfa = snd_soc_component_read(component, STA32X_CONFA);\n\tregcache_cache_bypass(sta32x->regmap, false);\n\tif (confa != confa_cached) {\n\t\tregcache_mark_dirty(sta32x->regmap);\n\t\tsta32x_cache_sync(component);\n\t}\n\n\tif (!sta32x->shutdown)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t   &sta32x->watchdog_work,\n\t\t\t\t   round_jiffies_relative(HZ));\n}\n\nstatic void sta32x_watchdog_start(struct sta32x_priv *sta32x)\n{\n\tif (sta32x->pdata->needs_esd_watchdog) {\n\t\tsta32x->shutdown = 0;\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t   &sta32x->watchdog_work,\n\t\t\t\t   round_jiffies_relative(HZ));\n\t}\n}\n\nstatic void sta32x_watchdog_stop(struct sta32x_priv *sta32x)\n{\n\tif (sta32x->pdata->needs_esd_watchdog) {\n\t\tsta32x->shutdown = 1;\n\t\tcancel_delayed_work_sync(&sta32x->watchdog_work);\n\t}\n}\n\n#define SINGLE_COEF(xname, index) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = sta32x_coefficient_info, \\\n\t.get = sta32x_coefficient_get,\\\n\t.put = sta32x_coefficient_put, \\\n\t.private_value = index | (1 << 16) }\n\n#define BIQUAD_COEFS(xname, index) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = sta32x_coefficient_info, \\\n\t.get = sta32x_coefficient_get,\\\n\t.put = sta32x_coefficient_put, \\\n\t.private_value = index | (5 << 16) }\n\nstatic const struct snd_kcontrol_new sta32x_snd_controls[] = {\nSOC_SINGLE_TLV(\"Master Volume\", STA32X_MVOL, 0, 0xff, 1, mvol_tlv),\nSOC_SINGLE(\"Master Switch\", STA32X_MMUTE, 0, 1, 1),\nSOC_SINGLE(\"Ch1 Switch\", STA32X_MMUTE, 1, 1, 1),\nSOC_SINGLE(\"Ch2 Switch\", STA32X_MMUTE, 2, 1, 1),\nSOC_SINGLE(\"Ch3 Switch\", STA32X_MMUTE, 3, 1, 1),\nSOC_SINGLE_TLV(\"Ch1 Volume\", STA32X_C1VOL, 0, 0xff, 1, chvol_tlv),\nSOC_SINGLE_TLV(\"Ch2 Volume\", STA32X_C2VOL, 0, 0xff, 1, chvol_tlv),\nSOC_SINGLE_TLV(\"Ch3 Volume\", STA32X_C3VOL, 0, 0xff, 1, chvol_tlv),\nSOC_SINGLE(\"De-emphasis Filter Switch\", STA32X_CONFD, STA32X_CONFD_DEMP_SHIFT, 1, 0),\nSOC_ENUM(\"Compressor/Limiter Switch\", sta32x_drc_ac_enum),\nSOC_SINGLE(\"Miami Mode Switch\", STA32X_CONFD, STA32X_CONFD_MME_SHIFT, 1, 0),\nSOC_SINGLE(\"Zero Cross Switch\", STA32X_CONFE, STA32X_CONFE_ZCE_SHIFT, 1, 0),\nSOC_SINGLE(\"Soft Ramp Switch\", STA32X_CONFE, STA32X_CONFE_SVE_SHIFT, 1, 0),\nSOC_SINGLE(\"Auto-Mute Switch\", STA32X_CONFF, STA32X_CONFF_IDE_SHIFT, 1, 0),\nSOC_ENUM(\"Automode EQ\", sta32x_auto_eq_enum),\nSOC_ENUM(\"Automode GC\", sta32x_auto_gc_enum),\nSOC_ENUM(\"Automode XO\", sta32x_auto_xo_enum),\nSOC_ENUM(\"Preset EQ\", sta32x_preset_eq_enum),\nSOC_SINGLE(\"Ch1 Tone Control Bypass Switch\", STA32X_C1CFG, STA32X_CxCFG_TCB_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 Tone Control Bypass Switch\", STA32X_C2CFG, STA32X_CxCFG_TCB_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch1 EQ Bypass Switch\", STA32X_C1CFG, STA32X_CxCFG_EQBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 EQ Bypass Switch\", STA32X_C2CFG, STA32X_CxCFG_EQBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch1 Master Volume Bypass Switch\", STA32X_C1CFG, STA32X_CxCFG_VBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 Master Volume Bypass Switch\", STA32X_C1CFG, STA32X_CxCFG_VBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch3 Master Volume Bypass Switch\", STA32X_C1CFG, STA32X_CxCFG_VBP_SHIFT, 1, 0),\nSOC_ENUM(\"Ch1 Limiter Select\", sta32x_limiter_ch1_enum),\nSOC_ENUM(\"Ch2 Limiter Select\", sta32x_limiter_ch2_enum),\nSOC_ENUM(\"Ch3 Limiter Select\", sta32x_limiter_ch3_enum),\nSOC_SINGLE_TLV(\"Bass Tone Control\", STA32X_TONE, STA32X_TONE_BTC_SHIFT, 15, 0, tone_tlv),\nSOC_SINGLE_TLV(\"Treble Tone Control\", STA32X_TONE, STA32X_TONE_TTC_SHIFT, 15, 0, tone_tlv),\nSOC_ENUM(\"Limiter1 Attack Rate (dB/ms)\", sta32x_limiter1_attack_rate_enum),\nSOC_ENUM(\"Limiter2 Attack Rate (dB/ms)\", sta32x_limiter2_attack_rate_enum),\nSOC_ENUM(\"Limiter1 Release Rate (dB/ms)\", sta32x_limiter1_release_rate_enum),\nSOC_ENUM(\"Limiter2 Release Rate (dB/ms)\", sta32x_limiter2_release_rate_enum),\n\n \nSOC_SINGLE_TLV(\"Limiter1 Attack Threshold (AC Mode)\", STA32X_L1ATRT, STA32X_LxA_SHIFT,\n\t       16, 0, sta32x_limiter_ac_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Attack Threshold (AC Mode)\", STA32X_L2ATRT, STA32X_LxA_SHIFT,\n\t       16, 0, sta32x_limiter_ac_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Release Threshold (AC Mode)\", STA32X_L1ATRT, STA32X_LxR_SHIFT,\n\t       16, 0, sta32x_limiter_ac_release_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Release Threshold (AC Mode)\", STA32X_L2ATRT, STA32X_LxR_SHIFT,\n\t       16, 0, sta32x_limiter_ac_release_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Attack Threshold (DRC Mode)\", STA32X_L1ATRT, STA32X_LxA_SHIFT,\n\t       16, 0, sta32x_limiter_drc_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Attack Threshold (DRC Mode)\", STA32X_L2ATRT, STA32X_LxA_SHIFT,\n\t       16, 0, sta32x_limiter_drc_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Release Threshold (DRC Mode)\", STA32X_L1ATRT, STA32X_LxR_SHIFT,\n\t       16, 0, sta32x_limiter_drc_release_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Release Threshold (DRC Mode)\", STA32X_L2ATRT, STA32X_LxR_SHIFT,\n\t       16, 0, sta32x_limiter_drc_release_tlv),\n\nBIQUAD_COEFS(\"Ch1 - Biquad 1\", 0),\nBIQUAD_COEFS(\"Ch1 - Biquad 2\", 5),\nBIQUAD_COEFS(\"Ch1 - Biquad 3\", 10),\nBIQUAD_COEFS(\"Ch1 - Biquad 4\", 15),\nBIQUAD_COEFS(\"Ch2 - Biquad 1\", 20),\nBIQUAD_COEFS(\"Ch2 - Biquad 2\", 25),\nBIQUAD_COEFS(\"Ch2 - Biquad 3\", 30),\nBIQUAD_COEFS(\"Ch2 - Biquad 4\", 35),\nBIQUAD_COEFS(\"High-pass\", 40),\nBIQUAD_COEFS(\"Low-pass\", 45),\nSINGLE_COEF(\"Ch1 - Prescale\", 50),\nSINGLE_COEF(\"Ch2 - Prescale\", 51),\nSINGLE_COEF(\"Ch1 - Postscale\", 52),\nSINGLE_COEF(\"Ch2 - Postscale\", 53),\nSINGLE_COEF(\"Ch3 - Postscale\", 54),\nSINGLE_COEF(\"Thermal warning - Postscale\", 55),\nSINGLE_COEF(\"Ch1 - Mix 1\", 56),\nSINGLE_COEF(\"Ch1 - Mix 2\", 57),\nSINGLE_COEF(\"Ch2 - Mix 1\", 58),\nSINGLE_COEF(\"Ch2 - Mix 2\", 59),\nSINGLE_COEF(\"Ch3 - Mix 1\", 60),\nSINGLE_COEF(\"Ch3 - Mix 2\", 61),\n};\n\nstatic const struct snd_soc_dapm_widget sta32x_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"LEFT\"),\nSND_SOC_DAPM_OUTPUT(\"RIGHT\"),\nSND_SOC_DAPM_OUTPUT(\"SUB\"),\n};\n\nstatic const struct snd_soc_dapm_route sta32x_dapm_routes[] = {\n\t{ \"LEFT\", NULL, \"DAC\" },\n\t{ \"RIGHT\", NULL, \"DAC\" },\n\t{ \"SUB\", NULL, \"DAC\" },\n};\n\n \nstatic struct {\n\tint fs;\n\tint ir;\n} interpolation_ratios[] = {\n\t{ 32000, 0 },\n\t{ 44100, 0 },\n\t{ 48000, 0 },\n\t{ 88200, 1 },\n\t{ 96000, 1 },\n\t{ 176400, 2 },\n\t{ 192000, 2 },\n};\n\n \nstatic int mcs_ratio_table[3][7] = {\n\t{ 768, 512, 384, 256, 128, 576, 0 },\n\t{ 384, 256, 192, 128,  64,   0 },\n\t{ 384, 256, 192, 128,  64,   0 },\n};\n\n \nstatic int sta32x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"mclk=%u\\n\", freq);\n\tsta32x->mclk = freq;\n\n\treturn 0;\n}\n\n \nstatic int sta32x_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tu8 confb = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsta32x->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tconfb |= STA32X_CONFB_C2IM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tconfb |= STA32X_CONFB_C1IM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(sta32x->regmap, STA32X_CONFB,\n\t\t\t\t  STA32X_CONFB_C1IM | STA32X_CONFB_C2IM, confb);\n}\n\n \nstatic int sta32x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tint i, mcs = -EINVAL, ir = -EINVAL;\n\tunsigned int confa, confb;\n\tunsigned int rate, ratio;\n\tint ret;\n\n\tif (!sta32x->mclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"sta32x->mclk is unset. Unable to determine ratio\\n\");\n\t\treturn -EIO;\n\t}\n\n\trate = params_rate(params);\n\tratio = sta32x->mclk / rate;\n\tdev_dbg(component->dev, \"rate: %u, ratio: %u\\n\", rate, ratio);\n\n\tfor (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {\n\t\tif (interpolation_ratios[i].fs == rate) {\n\t\t\tir = interpolation_ratios[i].ir;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ir < 0) {\n\t\tdev_err(component->dev, \"Unsupported samplerate: %u\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mcs_ratio_table[ir][i] == ratio) {\n\t\t\tmcs = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mcs < 0) {\n\t\tdev_err(component->dev, \"Unresolvable ratio: %u\\n\", ratio);\n\t\treturn -EINVAL;\n\t}\n\n\tconfa = (ir << STA32X_CONFA_IR_SHIFT) |\n\t\t(mcs << STA32X_CONFA_MCS_SHIFT);\n\tconfb = 0;\n\n\tswitch (params_width(params)) {\n\tcase 24:\n\t\tdev_dbg(component->dev, \"24bit\\n\");\n\t\tfallthrough;\n\tcase 32:\n\t\tdev_dbg(component->dev, \"24bit or 32bit\\n\");\n\t\tswitch (sta32x->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x0;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x1;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0x2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 20:\n\t\tdev_dbg(component->dev, \"20bit\\n\");\n\t\tswitch (sta32x->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x4;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x5;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0x6;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 18:\n\t\tdev_dbg(component->dev, \"18bit\\n\");\n\t\tswitch (sta32x->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x8;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x9;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0xa;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 16:\n\t\tdev_dbg(component->dev, \"16bit\\n\");\n\t\tswitch (sta32x->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x0;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0xd;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0xe;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(sta32x->regmap, STA32X_CONFA,\n\t\t\t\t STA32X_CONFA_MCS_MASK | STA32X_CONFA_IR_MASK,\n\t\t\t\t confa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(sta32x->regmap, STA32X_CONFB,\n\t\t\t\t STA32X_CONFB_SAI_MASK | STA32X_CONFB_SAIFB,\n\t\t\t\t confb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sta32x_startup_sequence(struct sta32x_priv *sta32x)\n{\n\tif (sta32x->gpiod_nreset) {\n\t\tgpiod_set_value(sta32x->gpiod_nreset, 0);\n\t\tmdelay(1);\n\t\tgpiod_set_value(sta32x->gpiod_nreset, 1);\n\t\tmdelay(1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sta32x_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tint ret;\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"level = %d\\n\", level);\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tregmap_update_bits(sta32x->regmap, STA32X_CONFF,\n\t\t\t\t    STA32X_CONFF_PWDN | STA32X_CONFF_EAPD,\n\t\t\t\t    STA32X_CONFF_PWDN | STA32X_CONFF_EAPD);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(sta32x->supplies),\n\t\t\t\t\t\t    sta32x->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tsta32x_startup_sequence(sta32x);\n\t\t\tsta32x_cache_sync(component);\n\t\t\tsta32x_watchdog_start(sta32x);\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(sta32x->regmap, STA32X_CONFF,\n\t\t\t\t   STA32X_CONFF_PWDN | STA32X_CONFF_EAPD,\n\t\t\t\t   0);\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tregmap_update_bits(sta32x->regmap, STA32X_CONFF,\n\t\t\t\t   STA32X_CONFF_PWDN | STA32X_CONFF_EAPD, 0);\n\t\tmsleep(300);\n\t\tsta32x_watchdog_stop(sta32x);\n\n\t\tgpiod_set_value(sta32x->gpiod_nreset, 0);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies),\n\t\t\t\t       sta32x->supplies);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sta32x_dai_ops = {\n\t.hw_params\t= sta32x_hw_params,\n\t.set_sysclk\t= sta32x_set_dai_sysclk,\n\t.set_fmt\t= sta32x_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver sta32x_dai = {\n\t.name = \"sta32x-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = STA32X_RATES,\n\t\t.formats = STA32X_FORMATS,\n\t},\n\t.ops = &sta32x_dai_ops,\n};\n\nstatic int sta32x_probe(struct snd_soc_component *component)\n{\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\tstruct sta32x_platform_data *pdata = sta32x->pdata;\n\tint i, ret = 0, thermal = 0;\n\n\tsta32x->component = component;\n\n\tif (sta32x->xti_clk) {\n\t\tret = clk_prepare_enable(sta32x->xti_clk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to enable clock: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(sta32x->supplies),\n\t\t\t\t    sta32x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_clk_disable_unprepare;\n\t}\n\n\tret = sta32x_startup_sequence(sta32x);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to startup device\\n\");\n\t\tgoto err_regulator_bulk_disable;\n\t}\n\n\t \n\tif (!pdata->thermal_warning_recovery)\n\t\tthermal |= STA32X_CONFA_TWAB;\n\tif (!pdata->thermal_warning_adjustment)\n\t\tthermal |= STA32X_CONFA_TWRB;\n\tif (!pdata->fault_detect_recovery)\n\t\tthermal |= STA32X_CONFA_FDRB;\n\tregmap_update_bits(sta32x->regmap, STA32X_CONFA,\n\t\t\t   STA32X_CONFA_TWAB | STA32X_CONFA_TWRB |\n\t\t\t   STA32X_CONFA_FDRB,\n\t\t\t   thermal);\n\n\t \n\tregmap_update_bits(sta32x->regmap, STA32X_CONFC,\n\t\t\t   STA32X_CONFC_CSZ_MASK,\n\t\t\t   pdata->drop_compensation_ns\n\t\t\t\t<< STA32X_CONFC_CSZ_SHIFT);\n\n\t \n\tregmap_update_bits(sta32x->regmap, STA32X_CONFE,\n\t\t\t   STA32X_CONFE_MPCV,\n\t\t\t   pdata->max_power_use_mpcc ?\n\t\t\t\tSTA32X_CONFE_MPCV : 0);\n\tregmap_update_bits(sta32x->regmap, STA32X_CONFE,\n\t\t\t   STA32X_CONFE_MPC,\n\t\t\t   pdata->max_power_correction ?\n\t\t\t\tSTA32X_CONFE_MPC : 0);\n\tregmap_update_bits(sta32x->regmap, STA32X_CONFE,\n\t\t\t   STA32X_CONFE_AME,\n\t\t\t   pdata->am_reduction_mode ?\n\t\t\t\tSTA32X_CONFE_AME : 0);\n\tregmap_update_bits(sta32x->regmap, STA32X_CONFE,\n\t\t\t   STA32X_CONFE_PWMS,\n\t\t\t   pdata->odd_pwm_speed_mode ?\n\t\t\t\tSTA32X_CONFE_PWMS : 0);\n\n\t \n\tregmap_update_bits(sta32x->regmap, STA32X_CONFF,\n\t\t\t   STA32X_CONFF_IDE,\n\t\t\t   pdata->invalid_input_detect_mute ?\n\t\t\t\tSTA32X_CONFF_IDE : 0);\n\n\t \n\tregmap_update_bits(sta32x->regmap, STA32X_CONFF,\n\t\t\t   STA32X_CONFF_OCFG_MASK,\n\t\t\t   pdata->output_conf\n\t\t\t\t<< STA32X_CONFF_OCFG_SHIFT);\n\n\t \n\tregmap_update_bits(sta32x->regmap, STA32X_C1CFG,\n\t\t\t   STA32X_CxCFG_OM_MASK,\n\t\t\t   pdata->ch1_output_mapping\n\t\t\t\t<< STA32X_CxCFG_OM_SHIFT);\n\tregmap_update_bits(sta32x->regmap, STA32X_C2CFG,\n\t\t\t   STA32X_CxCFG_OM_MASK,\n\t\t\t   pdata->ch2_output_mapping\n\t\t\t\t<< STA32X_CxCFG_OM_SHIFT);\n\tregmap_update_bits(sta32x->regmap, STA32X_C3CFG,\n\t\t\t   STA32X_CxCFG_OM_MASK,\n\t\t\t   pdata->ch3_output_mapping\n\t\t\t\t<< STA32X_CxCFG_OM_SHIFT);\n\n\t \n\tfor (i = 4; i <= 49; i += 5)\n\t\tsta32x->coef_shadow[i] = 0x400000;\n\tfor (i = 50; i <= 54; i++)\n\t\tsta32x->coef_shadow[i] = 0x7fffff;\n\tsta32x->coef_shadow[55] = 0x5a9df7;\n\tsta32x->coef_shadow[56] = 0x7fffff;\n\tsta32x->coef_shadow[59] = 0x7fffff;\n\tsta32x->coef_shadow[60] = 0x400000;\n\tsta32x->coef_shadow[61] = 0x400000;\n\n\tif (sta32x->pdata->needs_esd_watchdog)\n\t\tINIT_DELAYED_WORK(&sta32x->watchdog_work, sta32x_watchdog);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\n\n\treturn 0;\n\nerr_regulator_bulk_disable:\n\tregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\nerr_clk_disable_unprepare:\n\tif (sta32x->xti_clk)\n\t\tclk_disable_unprepare(sta32x->xti_clk);\n\treturn ret;\n}\n\nstatic void sta32x_remove(struct snd_soc_component *component)\n{\n\tstruct sta32x_priv *sta32x = snd_soc_component_get_drvdata(component);\n\n\tsta32x_watchdog_stop(sta32x);\n\tregulator_bulk_disable(ARRAY_SIZE(sta32x->supplies), sta32x->supplies);\n\n\tif (sta32x->xti_clk)\n\t\tclk_disable_unprepare(sta32x->xti_clk);\n}\n\nstatic const struct snd_soc_component_driver sta32x_component = {\n\t.probe\t\t\t= sta32x_probe,\n\t.remove\t\t\t= sta32x_remove,\n\t.set_bias_level\t\t= sta32x_set_bias_level,\n\t.controls\t\t= sta32x_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sta32x_snd_controls),\n\t.dapm_widgets\t\t= sta32x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sta32x_dapm_widgets),\n\t.dapm_routes\t\t= sta32x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(sta32x_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config sta32x_regmap = {\n\t.reg_bits =\t\t8,\n\t.val_bits =\t\t8,\n\t.max_register =\t\tSTA32X_FDRC2,\n\t.reg_defaults =\t\tsta32x_regs,\n\t.num_reg_defaults =\tARRAY_SIZE(sta32x_regs),\n\t.cache_type =\t\tREGCACHE_MAPLE,\n\t.wr_table =\t\t&sta32x_write_regs,\n\t.rd_table =\t\t&sta32x_read_regs,\n\t.volatile_table =\t&sta32x_volatile_regs,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id st32x_dt_ids[] = {\n\t{ .compatible = \"st,sta32x\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, st32x_dt_ids);\n\nstatic int sta32x_probe_dt(struct device *dev, struct sta32x_priv *sta32x)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct sta32x_platform_data *pdata;\n\tu16 tmp;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tof_property_read_u8(np, \"st,output-conf\",\n\t\t\t    &pdata->output_conf);\n\tof_property_read_u8(np, \"st,ch1-output-mapping\",\n\t\t\t    &pdata->ch1_output_mapping);\n\tof_property_read_u8(np, \"st,ch2-output-mapping\",\n\t\t\t    &pdata->ch2_output_mapping);\n\tof_property_read_u8(np, \"st,ch3-output-mapping\",\n\t\t\t    &pdata->ch3_output_mapping);\n\n\tpdata->fault_detect_recovery =\n\t\tof_property_read_bool(np, \"st,fault-detect-recovery\");\n\tpdata->thermal_warning_recovery =\n\t\tof_property_read_bool(np, \"st,thermal-warning-recovery\");\n\tpdata->thermal_warning_adjustment =\n\t\tof_property_read_bool(np, \"st,thermal-warning-adjustment\");\n\tpdata->needs_esd_watchdog =\n\t\tof_property_read_bool(np, \"st,needs_esd_watchdog\");\n\n\ttmp = 140;\n\tof_property_read_u16(np, \"st,drop-compensation-ns\", &tmp);\n\tpdata->drop_compensation_ns = clamp_t(u16, tmp, 0, 300) / 20;\n\n\t \n\tpdata->max_power_use_mpcc =\n\t\tof_property_read_bool(np, \"st,max-power-use-mpcc\");\n\tpdata->max_power_correction =\n\t\tof_property_read_bool(np, \"st,max-power-correction\");\n\tpdata->am_reduction_mode =\n\t\tof_property_read_bool(np, \"st,am-reduction-mode\");\n\tpdata->odd_pwm_speed_mode =\n\t\tof_property_read_bool(np, \"st,odd-pwm-speed-mode\");\n\n\t \n\tpdata->invalid_input_detect_mute =\n\t\tof_property_read_bool(np, \"st,invalid-input-detect-mute\");\n\n\tsta32x->pdata = pdata;\n\n\treturn 0;\n}\n#endif\n\nstatic int sta32x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct sta32x_priv *sta32x;\n\tint ret, i;\n\n\tsta32x = devm_kzalloc(&i2c->dev, sizeof(struct sta32x_priv),\n\t\t\t      GFP_KERNEL);\n\tif (!sta32x)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sta32x->coeff_lock);\n\tsta32x->pdata = dev_get_platdata(dev);\n\n#ifdef CONFIG_OF\n\tif (dev->of_node) {\n\t\tret = sta32x_probe_dt(dev, sta32x);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n#endif\n\n\t \n\tsta32x->xti_clk = devm_clk_get(dev, \"xti\");\n\tif (IS_ERR(sta32x->xti_clk)) {\n\t\tret = PTR_ERR(sta32x->xti_clk);\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\n\t\tsta32x->xti_clk = NULL;\n\t}\n\n\t \n\tsta32x->gpiod_nreset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(sta32x->gpiod_nreset))\n\t\treturn PTR_ERR(sta32x->gpiod_nreset);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sta32x->supplies); i++)\n\t\tsta32x->supplies[i].supply = sta32x_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(sta32x->supplies),\n\t\t\t\t      sta32x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsta32x->regmap = devm_regmap_init_i2c(i2c, &sta32x_regmap);\n\tif (IS_ERR(sta32x->regmap)) {\n\t\tret = PTR_ERR(sta32x->regmap);\n\t\tdev_err(dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, sta32x);\n\n\tret = devm_snd_soc_register_component(dev, &sta32x_component,\n\t\t\t\t\t      &sta32x_dai, 1);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register component (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id sta32x_i2c_id[] = {\n\t{ \"sta326\", 0 },\n\t{ \"sta328\", 0 },\n\t{ \"sta329\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sta32x_i2c_id);\n\nstatic struct i2c_driver sta32x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"sta32x\",\n\t\t.of_match_table = of_match_ptr(st32x_dt_ids),\n\t},\n\t.probe = sta32x_i2c_probe,\n\t.id_table = sta32x_i2c_id,\n};\n\nmodule_i2c_driver(sta32x_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC STA32X driver\");\nMODULE_AUTHOR(\"Johannes Stezenbach <js@sig21.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}