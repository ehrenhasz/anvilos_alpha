{
  "module_name": "rt274.c",
  "hash_id": "c9db3f9b2bf659ca1682d88af0941e31bc66f571dcad98cb6d18ddc862f86f52",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt274.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/jack.h>\n#include <linux/workqueue.h>\n\n#include \"rl6347a.h\"\n#include \"rt274.h\"\n\n#define RT274_VENDOR_ID 0x10ec0274\n\nstruct rt274_priv {\n\tstruct reg_default *index_cache;\n\tint index_cache_size;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct i2c_client *i2c;\n\tstruct snd_soc_jack *jack;\n\tstruct delayed_work jack_detect_work;\n\tint sys_clk;\n\tint clk_id;\n\tint fs;\n\tbool master;\n};\n\nstatic const struct reg_default rt274_index_def[] = {\n\t{ 0x00, 0x1004 },\n\t{ 0x01, 0xaaaa },\n\t{ 0x02, 0x88aa },\n\t{ 0x03, 0x0002 },\n\t{ 0x04, 0xaa09 },\n\t{ 0x05, 0x0700 },\n\t{ 0x06, 0x6110 },\n\t{ 0x07, 0x0200 },\n\t{ 0x08, 0xa807 },\n\t{ 0x09, 0x0021 },\n\t{ 0x0a, 0x7770 },\n\t{ 0x0b, 0x7770 },\n\t{ 0x0c, 0x002b },\n\t{ 0x0d, 0x2420 },\n\t{ 0x0e, 0x65c0 },\n\t{ 0x0f, 0x7770 },\n\t{ 0x10, 0x0420 },\n\t{ 0x11, 0x7418 },\n\t{ 0x12, 0x6bd0 },\n\t{ 0x13, 0x645f },\n\t{ 0x14, 0x0400 },\n\t{ 0x15, 0x8ccc },\n\t{ 0x16, 0x4c50 },\n\t{ 0x17, 0xff00 },\n\t{ 0x18, 0x0003 },\n\t{ 0x19, 0x2c11 },\n\t{ 0x1a, 0x830b },\n\t{ 0x1b, 0x4e4b },\n\t{ 0x1c, 0x0000 },\n\t{ 0x1d, 0x0000 },\n\t{ 0x1e, 0x0000 },\n\t{ 0x1f, 0x0000 },\n\t{ 0x20, 0x51ff },\n\t{ 0x21, 0x8000 },\n\t{ 0x22, 0x8f00 },\n\t{ 0x23, 0x88f4 },\n\t{ 0x24, 0x0000 },\n\t{ 0x25, 0x0000 },\n\t{ 0x26, 0x0000 },\n\t{ 0x27, 0x0000 },\n\t{ 0x28, 0x0000 },\n\t{ 0x29, 0x3000 },\n\t{ 0x2a, 0x0000 },\n\t{ 0x2b, 0x0000 },\n\t{ 0x2c, 0x0f00 },\n\t{ 0x2d, 0x100f },\n\t{ 0x2e, 0x2902 },\n\t{ 0x2f, 0xe280 },\n\t{ 0x30, 0x1000 },\n\t{ 0x31, 0x8400 },\n\t{ 0x32, 0x5aaa },\n\t{ 0x33, 0x8420 },\n\t{ 0x34, 0xa20c },\n\t{ 0x35, 0x096a },\n\t{ 0x36, 0x5757 },\n\t{ 0x37, 0xfe05 },\n\t{ 0x38, 0x4901 },\n\t{ 0x39, 0x110a },\n\t{ 0x3a, 0x0010 },\n\t{ 0x3b, 0x60d9 },\n\t{ 0x3c, 0xf214 },\n\t{ 0x3d, 0xc2ba },\n\t{ 0x3e, 0xa928 },\n\t{ 0x3f, 0x0000 },\n\t{ 0x40, 0x9800 },\n\t{ 0x41, 0x0000 },\n\t{ 0x42, 0x2000 },\n\t{ 0x43, 0x3d90 },\n\t{ 0x44, 0x4900 },\n\t{ 0x45, 0x5289 },\n\t{ 0x46, 0x0004 },\n\t{ 0x47, 0xa47a },\n\t{ 0x48, 0xd049 },\n\t{ 0x49, 0x0049 },\n\t{ 0x4a, 0xa83b },\n\t{ 0x4b, 0x0777 },\n\t{ 0x4c, 0x065c },\n\t{ 0x4d, 0x7fff },\n\t{ 0x4e, 0x7fff },\n\t{ 0x4f, 0x0000 },\n\t{ 0x50, 0x0000 },\n\t{ 0x51, 0x0000 },\n\t{ 0x52, 0xbf5f },\n\t{ 0x53, 0x3320 },\n\t{ 0x54, 0xcc00 },\n\t{ 0x55, 0x0000 },\n\t{ 0x56, 0x3f00 },\n\t{ 0x57, 0x0000 },\n\t{ 0x58, 0x0000 },\n\t{ 0x59, 0x0000 },\n\t{ 0x5a, 0x1300 },\n\t{ 0x5b, 0x005f },\n\t{ 0x5c, 0x0000 },\n\t{ 0x5d, 0x1001 },\n\t{ 0x5e, 0x1000 },\n\t{ 0x5f, 0x0000 },\n\t{ 0x60, 0x5554 },\n\t{ 0x61, 0xffc0 },\n\t{ 0x62, 0xa000 },\n\t{ 0x63, 0xd010 },\n\t{ 0x64, 0x0000 },\n\t{ 0x65, 0x3fb1 },\n\t{ 0x66, 0x1881 },\n\t{ 0x67, 0xc810 },\n\t{ 0x68, 0x2000 },\n\t{ 0x69, 0xfff0 },\n\t{ 0x6a, 0x0300 },\n\t{ 0x6b, 0x5060 },\n\t{ 0x6c, 0x0000 },\n\t{ 0x6d, 0x0000 },\n\t{ 0x6e, 0x0c25 },\n\t{ 0x6f, 0x0c0b },\n\t{ 0x70, 0x8000 },\n\t{ 0x71, 0x4008 },\n\t{ 0x72, 0x0000 },\n\t{ 0x73, 0x0800 },\n\t{ 0x74, 0xa28f },\n\t{ 0x75, 0xa050 },\n\t{ 0x76, 0x7fe8 },\n\t{ 0x77, 0xdb8c },\n\t{ 0x78, 0x0000 },\n\t{ 0x79, 0x0000 },\n\t{ 0x7a, 0x2a96 },\n\t{ 0x7b, 0x800f },\n\t{ 0x7c, 0x0200 },\n\t{ 0x7d, 0x1600 },\n\t{ 0x7e, 0x0000 },\n\t{ 0x7f, 0x0000 },\n};\n#define INDEX_CACHE_SIZE ARRAY_SIZE(rt274_index_def)\n\nstatic const struct reg_default rt274_reg[] = {\n\t{ 0x00170500, 0x00000400 },\n\t{ 0x00220000, 0x00000031 },\n\t{ 0x00239000, 0x00000057 },\n\t{ 0x0023a000, 0x00000057 },\n\t{ 0x00270500, 0x00000400 },\n\t{ 0x00370500, 0x00000400 },\n\t{ 0x00870500, 0x00000400 },\n\t{ 0x00920000, 0x00000031 },\n\t{ 0x00935000, 0x00000097 },\n\t{ 0x00936000, 0x00000097 },\n\t{ 0x00970500, 0x00000400 },\n\t{ 0x00b37000, 0x00000400 },\n\t{ 0x00b37200, 0x00000400 },\n\t{ 0x00b37300, 0x00000400 },\n\t{ 0x00c37000, 0x00000400 },\n\t{ 0x00c37100, 0x00000400 },\n\t{ 0x01270500, 0x00000400 },\n\t{ 0x01370500, 0x00000400 },\n\t{ 0x01371f00, 0x411111f0 },\n\t{ 0x01937000, 0x00000000 },\n\t{ 0x01970500, 0x00000400 },\n\t{ 0x02050000, 0x0000001b },\n\t{ 0x02139000, 0x00000080 },\n\t{ 0x0213a000, 0x00000080 },\n\t{ 0x02170100, 0x00000001 },\n\t{ 0x02170500, 0x00000400 },\n\t{ 0x02170700, 0x00000000 },\n\t{ 0x02270100, 0x00000000 },\n\t{ 0x02370100, 0x00000000 },\n\t{ 0x01970700, 0x00000020 },\n\t{ 0x00830000, 0x00000097 },\n\t{ 0x00930000, 0x00000097 },\n\t{ 0x01270700, 0x00000000 },\n};\n\nstatic bool rt274_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0 ... 0xff:\n\tcase RT274_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\n\tcase RT274_GET_HP_SENSE:\n\tcase RT274_GET_MIC_SENSE:\n\tcase RT274_PROC_COEF:\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_DAC_OUT0, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_DAC_OUT1, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_ADC_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_ADC_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DAC_OUT0, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DAC_OUT1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_ADC_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_ADC_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DMIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DMIC2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_LINE1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_LINE2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_MIXER_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_MIXER_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_DMIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_DMIC2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_LINE1, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_LINE2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_INLINE_CMD, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n\n}\n\nstatic bool rt274_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0 ... 0xff:\n\tcase RT274_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\n\tcase RT274_GET_HP_SENSE:\n\tcase RT274_GET_MIC_SENSE:\n\tcase RT274_SET_AUDIO_POWER:\n\tcase RT274_SET_HPO_POWER:\n\tcase RT274_SET_DMIC1_POWER:\n\tcase RT274_LOUT_MUX:\n\tcase RT274_HPO_MUX:\n\tcase RT274_ADC0_MUX:\n\tcase RT274_ADC1_MUX:\n\tcase RT274_SET_MIC:\n\tcase RT274_SET_PIN_HPO:\n\tcase RT274_SET_PIN_LOUT3:\n\tcase RT274_SET_PIN_DMIC1:\n\tcase RT274_SET_AMP_GAIN_HPO:\n\tcase RT274_SET_DMIC2_DEFAULT:\n\tcase RT274_DAC0L_GAIN:\n\tcase RT274_DAC0R_GAIN:\n\tcase RT274_DAC1L_GAIN:\n\tcase RT274_DAC1R_GAIN:\n\tcase RT274_ADCL_GAIN:\n\tcase RT274_ADCR_GAIN:\n\tcase RT274_MIC_GAIN:\n\tcase RT274_HPOL_GAIN:\n\tcase RT274_HPOR_GAIN:\n\tcase RT274_LOUTL_GAIN:\n\tcase RT274_LOUTR_GAIN:\n\tcase RT274_DAC_FORMAT:\n\tcase RT274_ADC_FORMAT:\n\tcase RT274_COEF_INDEX:\n\tcase RT274_PROC_COEF:\n\tcase RT274_SET_AMP_GAIN_ADC_IN1:\n\tcase RT274_SET_AMP_GAIN_ADC_IN2:\n\tcase RT274_SET_POWER(RT274_DAC_OUT0):\n\tcase RT274_SET_POWER(RT274_DAC_OUT1):\n\tcase RT274_SET_POWER(RT274_ADC_IN1):\n\tcase RT274_SET_POWER(RT274_ADC_IN2):\n\tcase RT274_SET_POWER(RT274_DMIC2):\n\tcase RT274_SET_POWER(RT274_MIC):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_DAC_OUT0, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_DAC_OUT1, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_ADC_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_STREAM_FORMAT, RT274_ADC_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DAC_OUT0, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DAC_OUT1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_ADC_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_ADC_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DMIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_DMIC2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_LINE1, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_LINE2, 0):\n\tcase VERB_CMD(AC_VERB_GET_AMP_GAIN_MUTE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_MIXER_IN1, 0):\n\tcase VERB_CMD(AC_VERB_GET_CONNECT_SEL, RT274_MIXER_IN2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_DMIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_DMIC2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_LINE1, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_LINE2, 0):\n\tcase VERB_CMD(AC_VERB_GET_PIN_WIDGET_CONTROL, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_HP_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_MIC, 0):\n\tcase VERB_CMD(AC_VERB_GET_UNSOLICITED_RESPONSE, RT274_INLINE_CMD, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic void rt274_index_sync(struct snd_soc_component *component)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tfor (i = 0; i < INDEX_CACHE_SIZE; i++) {\n\t\tsnd_soc_component_write(component, rt274->index_cache[i].reg,\n\t\t\t\t  rt274->index_cache[i].def);\n\t}\n}\n#endif\n\nstatic int rt274_jack_detect(struct rt274_priv *rt274, bool *hp, bool *mic)\n{\n\tunsigned int buf;\n\tint ret;\n\n\t*hp = false;\n\t*mic = false;\n\n\tif (!rt274->component)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(rt274->regmap, RT274_GET_HP_SENSE, &buf);\n\tif (ret)\n\t\treturn ret;\n\n\t*hp = buf & 0x80000000;\n\tret = regmap_read(rt274->regmap, RT274_GET_MIC_SENSE, &buf);\n\tif (ret)\n\t\treturn ret;\n\n\t*mic = buf & 0x80000000;\n\n\tpr_debug(\"*hp = %d *mic = %d\\n\", *hp, *mic);\n\n\treturn 0;\n}\n\nstatic void rt274_jack_detect_work(struct work_struct *work)\n{\n\tstruct rt274_priv *rt274 =\n\t\tcontainer_of(work, struct rt274_priv, jack_detect_work.work);\n\tint status = 0;\n\tbool hp = false;\n\tbool mic = false;\n\n\tif (rt274_jack_detect(rt274, &hp, &mic) < 0)\n\t\treturn;\n\n\tif (hp)\n\t\tstatus |= SND_JACK_HEADPHONE;\n\n\tif (mic)\n\t\tstatus |= SND_JACK_MICROPHONE;\n\n\tsnd_soc_jack_report(rt274->jack, status,\n\t\tSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\n}\n\nstatic irqreturn_t rt274_irq(int irq, void *data);\n\nstatic int rt274_mic_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *jack,  void *data)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\trt274->jack = jack;\n\n\tif (jack == NULL) {\n\t\t \n\t\tregmap_update_bits(rt274->regmap, RT274_EAPD_GPIO_IRQ_CTRL,\n\t\t\t\t\tRT274_IRQ_EN, RT274_IRQ_DIS);\n\n\t\treturn 0;\n\t}\n\n\tregmap_update_bits(rt274->regmap, RT274_EAPD_GPIO_IRQ_CTRL,\n\t\t\t\tRT274_IRQ_EN, RT274_IRQ_EN);\n\n\t \n\trt274_irq(0, rt274);\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(out_vol_tlv, -6350, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic const struct snd_kcontrol_new rt274_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC0 Playback Volume\", RT274_DAC0L_GAIN,\n\t\t\t RT274_DAC0R_GAIN, 0, 0x7f, 0, out_vol_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC1 Playback Volume\", RT274_DAC1L_GAIN,\n\t\t\t RT274_DAC1R_GAIN, 0, 0x7f, 0, out_vol_tlv),\n\tSOC_DOUBLE_R_TLV(\"ADC0 Capture Volume\", RT274_ADCL_GAIN,\n\t\t\t    RT274_ADCR_GAIN, 0, 0x7f, 0, out_vol_tlv),\n\tSOC_DOUBLE_R(\"ADC0 Capture Switch\", RT274_ADCL_GAIN,\n\t\t\t    RT274_ADCR_GAIN, RT274_MUTE_SFT, 1, 1),\n\tSOC_SINGLE_TLV(\"AMIC Volume\", RT274_MIC_GAIN,\n\t\t\t    0, 0x3, 0, mic_vol_tlv),\n};\n\nstatic const struct snd_kcontrol_new hpol_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT274_HPOL_GAIN,\n\t\t\tRT274_MUTE_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new hpor_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT274_HPOR_GAIN,\n\t\t\tRT274_MUTE_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new loutl_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT274_LOUTL_GAIN,\n\t\t\tRT274_MUTE_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new loutr_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT274_LOUTR_GAIN,\n\t\t\tRT274_MUTE_SFT, 1, 1);\n\n \nstatic const char * const rt274_adc_src[] = {\n\t\"Mic\", \"Line1\", \"Line2\", \"Dmic\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt274_adc0_enum, RT274_ADC0_MUX, RT274_ADC_SEL_SFT,\n\trt274_adc_src);\n\nstatic const struct snd_kcontrol_new rt274_adc0_mux =\n\tSOC_DAPM_ENUM(\"ADC 0 source\", rt274_adc0_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt274_adc1_enum, RT274_ADC1_MUX, RT274_ADC_SEL_SFT,\n\trt274_adc_src);\n\nstatic const struct snd_kcontrol_new rt274_adc1_mux =\n\tSOC_DAPM_ENUM(\"ADC 1 source\", rt274_adc1_enum);\n\nstatic const char * const rt274_dac_src[] = {\n\t\"DAC OUT0\", \"DAC OUT1\"\n};\n \nstatic SOC_ENUM_SINGLE_DECL(rt274_hpo_enum, RT274_HPO_MUX,\n\t\t\t\t0, rt274_dac_src);\n\nstatic const struct snd_kcontrol_new rt274_hpo_mux =\nSOC_DAPM_ENUM(\"HPO source\", rt274_hpo_enum);\n\n \nstatic SOC_ENUM_SINGLE_DECL(rt274_lout_enum, RT274_LOUT_MUX,\n\t\t\t\t0, rt274_dac_src);\n\nstatic const struct snd_kcontrol_new rt274_lout_mux =\nSOC_DAPM_ENUM(\"LOUT source\", rt274_lout_enum);\n\nstatic const struct snd_soc_dapm_widget rt274_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"DMIC1 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"MIC\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2\"),\n\n\t \n\tSND_SOC_DAPM_PGA(\"DMIC1\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"DMIC2\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC 0\", NULL, RT274_SET_STREAMID_ADC1, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 1\", NULL, RT274_SET_STREAMID_ADC2, 4, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"ADC 0 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt274_adc0_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt274_adc1_mux),\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RXL\", \"AIF1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF1RXR\", \"AIF1 Playback\", 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TXL\", \"AIF1 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TXR\", \"AIF1 Capture\", 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF2RXL\", \"AIF1 Playback\", 2, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF2RXR\", \"AIF1 Playback\", 3, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2TXL\", \"AIF1 Capture\", 2, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2TXR\", \"AIF1 Capture\", 3, SND_SOC_NOPM, 0, 0),\n\n\t \n\t \n\tSND_SOC_DAPM_DAC(\"DAC 0\", NULL, RT274_SET_STREAMID_DAC0, 4, 0),\n\tSND_SOC_DAPM_DAC(\"DAC 1\", NULL, RT274_SET_STREAMID_DAC1, 4, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"HPO Mux\", SND_SOC_NOPM, 0, 0, &rt274_hpo_mux),\n\tSND_SOC_DAPM_MUX(\"LOUT Mux\", SND_SOC_NOPM, 0, 0, &rt274_lout_mux),\n\n\tSND_SOC_DAPM_SUPPLY(\"HP Power\", RT274_SET_PIN_HPO,\n\t\tRT274_SET_PIN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"LOUT Power\", RT274_SET_PIN_LOUT3,\n\t\tRT274_SET_PIN_SFT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA(\"DAC OUT0\", SND_SOC_NOPM, 0, 0,\n\t\t\tNULL, 0),\n\tSND_SOC_DAPM_PGA(\"DAC OUT1\", SND_SOC_NOPM, 0, 0,\n\t\t\tNULL, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"LOUT L\", SND_SOC_NOPM, 0, 0,\n\t\t&loutl_enable_control),\n\tSND_SOC_DAPM_SWITCH(\"LOUT R\", SND_SOC_NOPM, 0, 0,\n\t\t&loutr_enable_control),\n\tSND_SOC_DAPM_SWITCH(\"HPO L\", SND_SOC_NOPM, 0, 0,\n\t\t&hpol_enable_control),\n\tSND_SOC_DAPM_SWITCH(\"HPO R\", SND_SOC_NOPM, 0, 0,\n\t\t&hpor_enable_control),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPO Pin\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPDIF\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINE3\"),\n};\n\nstatic const struct snd_soc_dapm_route rt274_dapm_routes[] = {\n\t{\"DMIC1\", NULL, \"DMIC1 Pin\"},\n\t{\"DMIC2\", NULL, \"DMIC2 Pin\"},\n\n\t{\"ADC 0 Mux\", \"Mic\", \"MIC\"},\n\t{\"ADC 0 Mux\", \"Dmic\", \"DMIC1\"},\n\t{\"ADC 0 Mux\", \"Line1\", \"LINE1\"},\n\t{\"ADC 0 Mux\", \"Line2\", \"LINE2\"},\n\t{\"ADC 1 Mux\", \"Mic\", \"MIC\"},\n\t{\"ADC 1 Mux\", \"Dmic\", \"DMIC2\"},\n\t{\"ADC 1 Mux\", \"Line1\", \"LINE1\"},\n\t{\"ADC 1 Mux\", \"Line2\", \"LINE2\"},\n\n\t{\"ADC 0\", NULL, \"ADC 0 Mux\"},\n\t{\"ADC 1\", NULL, \"ADC 1 Mux\"},\n\n\t{\"AIF1TXL\", NULL, \"ADC 0\"},\n\t{\"AIF1TXR\", NULL, \"ADC 0\"},\n\t{\"AIF2TXL\", NULL, \"ADC 1\"},\n\t{\"AIF2TXR\", NULL, \"ADC 1\"},\n\n\t{\"DAC 0\", NULL, \"AIF1RXL\"},\n\t{\"DAC 0\", NULL, \"AIF1RXR\"},\n\t{\"DAC 1\", NULL, \"AIF2RXL\"},\n\t{\"DAC 1\", NULL, \"AIF2RXR\"},\n\n\t{\"DAC OUT0\", NULL, \"DAC 0\"},\n\n\t{\"DAC OUT1\", NULL, \"DAC 1\"},\n\n\t{\"LOUT Mux\", \"DAC OUT0\", \"DAC OUT0\"},\n\t{\"LOUT Mux\", \"DAC OUT1\", \"DAC OUT1\"},\n\n\t{\"LOUT L\", \"Switch\", \"LOUT Mux\"},\n\t{\"LOUT R\", \"Switch\", \"LOUT Mux\"},\n\t{\"LOUT L\", NULL, \"LOUT Power\"},\n\t{\"LOUT R\", NULL, \"LOUT Power\"},\n\n\t{\"LINE3\", NULL, \"LOUT L\"},\n\t{\"LINE3\", NULL, \"LOUT R\"},\n\n\t{\"HPO Mux\", \"DAC OUT0\", \"DAC OUT0\"},\n\t{\"HPO Mux\", \"DAC OUT1\", \"DAC OUT1\"},\n\n\t{\"HPO L\", \"Switch\", \"HPO Mux\"},\n\t{\"HPO R\", \"Switch\", \"HPO Mux\"},\n\t{\"HPO L\", NULL, \"HP Power\"},\n\t{\"HPO R\", NULL, \"HP Power\"},\n\n\t{\"HPO Pin\", NULL, \"HPO L\"},\n\t{\"HPO Pin\", NULL, \"HPO R\"},\n};\n\nstatic int rt274_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\tint d_len_code = 0, c_len_code = 0;\n\n\tswitch (params_rate(params)) {\n\t \n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample rate %d\\n\",\n\t\t\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\tswitch (rt274->sys_clk) {\n\tcase 12288000:\n\tcase 24576000:\n\t\tif (params_rate(params) != 48000) {\n\t\t\tdev_err(component->dev, \"Sys_clk is not matched (%d %d)\\n\",\n\t\t\t\t\tparams_rate(params), rt274->sys_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 11289600:\n\tcase 22579200:\n\t\tif (params_rate(params) != 44100) {\n\t\t\tdev_err(component->dev, \"Sys_clk is not matched (%d %d)\\n\",\n\t\t\t\t\tparams_rate(params), rt274->sys_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (params_channels(params) <= 16) {\n\t\t \n\t\tval |= (params_channels(params) - 1);\n\t} else {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\t \n\tcase 16:\n\t\td_len_code = 0;\n\t\tc_len_code = 0;\n\t\tval |= (0x1 << 4);\n\t\tbreak;\n\tcase 32:\n\t\td_len_code = 2;\n\t\tc_len_code = 3;\n\t\tval |= (0x4 << 4);\n\t\tbreak;\n\tcase 20:\n\t\td_len_code = 1;\n\t\tc_len_code = 1;\n\t\tval |= (0x2 << 4);\n\t\tbreak;\n\tcase 24:\n\t\td_len_code = 2;\n\t\tc_len_code = 2;\n\t\tval |= (0x3 << 4);\n\t\tbreak;\n\tcase 8:\n\t\td_len_code = 3;\n\t\tc_len_code = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rt274->master)\n\t\tc_len_code = 0x3;\n\n\tsnd_soc_component_update_bits(component,\n\t\tRT274_I2S_CTRL1, 0xc018, d_len_code << 3 | c_len_code << 14);\n\tdev_dbg(component->dev, \"format val = 0x%x\\n\", val);\n\n\tsnd_soc_component_update_bits(component, RT274_DAC_FORMAT, 0x407f, val);\n\tsnd_soc_component_update_bits(component, RT274_ADC_FORMAT, 0x407f, val);\n\n\treturn 0;\n}\n\nstatic int rt274_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_I2S_MODE_MASK, RT274_I2S_MODE_M);\n\t\trt274->master = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_I2S_MODE_MASK, RT274_I2S_MODE_S);\n\t\trt274->master = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsnd_soc_component_update_bits(component, RT274_I2S_CTRL1,\n\t\t\t\t\tRT274_I2S_FMT_MASK, RT274_I2S_FMT_I2S);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsnd_soc_component_update_bits(component, RT274_I2S_CTRL1,\n\t\t\t\t\tRT274_I2S_FMT_MASK, RT274_I2S_FMT_LJ);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tsnd_soc_component_update_bits(component, RT274_I2S_CTRL1,\n\t\t\t\t\tRT274_I2S_FMT_MASK, RT274_I2S_FMT_PCMA);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tsnd_soc_component_update_bits(component, RT274_I2S_CTRL1,\n\t\t\t\t\tRT274_I2S_FMT_MASK, RT274_I2S_FMT_PCMB);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tsnd_soc_component_update_bits(component, RT274_DAC_FORMAT, 0x8000, 0);\n\tsnd_soc_component_update_bits(component, RT274_ADC_FORMAT, 0x8000, 0);\n\n\treturn 0;\n}\n\nstatic int rt274_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tswitch (source) {\n\tcase RT274_PLL2_S_MCLK:\n\t\tsnd_soc_component_update_bits(component, RT274_PLL2_CTRL,\n\t\t\t\tRT274_PLL2_SRC_MASK, RT274_PLL2_SRC_MCLK);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(component->dev, \"invalid pll source, use BCLK\\n\");\n\t\tfallthrough;\n\tcase RT274_PLL2_S_BCLK:\n\t\tsnd_soc_component_update_bits(component, RT274_PLL2_CTRL,\n\t\t\t\tRT274_PLL2_SRC_MASK, RT274_PLL2_SRC_BCLK);\n\t\tbreak;\n\t}\n\n\tif (source == RT274_PLL2_S_BCLK) {\n\t\tsnd_soc_component_update_bits(component, RT274_MCLK_CTRL,\n\t\t\t\t(0x3 << 12), (0x3 << 12));\n\t\tswitch (rt274->fs) {\n\t\tcase 50:\n\t\t\tsnd_soc_component_write(component, 0x7a, 0xaab6);\n\t\t\tsnd_soc_component_write(component, 0x7b, 0x0301);\n\t\t\tsnd_soc_component_write(component, 0x7c, 0x04fe);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tsnd_soc_component_write(component, 0x7a, 0xaa96);\n\t\t\tsnd_soc_component_write(component, 0x7b, 0x8003);\n\t\t\tsnd_soc_component_write(component, 0x7c, 0x081e);\n\t\t\tbreak;\n\t\tcase 128:\n\t\t\tsnd_soc_component_write(component, 0x7a, 0xaa96);\n\t\t\tsnd_soc_component_write(component, 0x7b, 0x8003);\n\t\t\tsnd_soc_component_write(component, 0x7c, 0x080e);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(component->dev, \"invalid freq_in, assume 4.8M\\n\");\n\t\t\tfallthrough;\n\t\tcase 100:\n\t\t\tsnd_soc_component_write(component, 0x7a, 0xaab6);\n\t\t\tsnd_soc_component_write(component, 0x7b, 0x0301);\n\t\t\tsnd_soc_component_write(component, 0x7c, 0x047e);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rt274_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\tunsigned int clk_src, mclk_en;\n\n\tdev_dbg(component->dev, \"%s freq=%d\\n\", __func__, freq);\n\n\tswitch (clk_id) {\n\tcase RT274_SCLK_S_MCLK:\n\t\tmclk_en = RT274_MCLK_MODE_EN;\n\t\tclk_src = RT274_CLK_SRC_MCLK;\n\t\tbreak;\n\tcase RT274_SCLK_S_PLL1:\n\t\tmclk_en = RT274_MCLK_MODE_DIS;\n\t\tclk_src = RT274_CLK_SRC_MCLK;\n\t\tbreak;\n\tcase RT274_SCLK_S_PLL2:\n\t\tmclk_en = RT274_MCLK_MODE_EN;\n\t\tclk_src = RT274_CLK_SRC_PLL2;\n\t\tbreak;\n\tdefault:\n\t\tmclk_en = RT274_MCLK_MODE_DIS;\n\t\tclk_src = RT274_CLK_SRC_MCLK;\n\t\tdev_warn(component->dev, \"invalid sysclk source, use PLL1\\n\");\n\t\tbreak;\n\t}\n\tsnd_soc_component_update_bits(component, RT274_MCLK_CTRL,\n\t\t\tRT274_MCLK_MODE_MASK, mclk_en);\n\tsnd_soc_component_update_bits(component, RT274_CLK_CTRL,\n\t\t\tRT274_CLK_SRC_MASK, clk_src);\n\n\tswitch (freq) {\n\tcase 19200000:\n\t\tif (clk_id == RT274_SCLK_S_MCLK) {\n\t\t\tdev_err(component->dev, \"Should not use MCLK\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL2, 0x40, 0x40);\n\t\tbreak;\n\tcase 24000000:\n\t\tif (clk_id == RT274_SCLK_S_MCLK) {\n\t\t\tdev_err(component->dev, \"Should not use MCLK\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL2, 0x40, 0x0);\n\t\tbreak;\n\tcase 12288000:\n\tcase 11289600:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_MCLK_CTRL, 0x1fcf, 0x0008);\n\t\tbreak;\n\tcase 24576000:\n\tcase 22579200:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_MCLK_CTRL, 0x1fcf, 0x1543);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported system clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trt274->sys_clk = freq;\n\trt274->clk_id = clk_id;\n\n\treturn 0;\n}\n\nstatic int rt274_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s ratio=%d\\n\", __func__, ratio);\n\trt274->fs = ratio;\n\tif ((ratio / 50) == 0)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, 0x1000, 0x1000);\n\telse\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, 0x1000, 0x0);\n\n\n\treturn 0;\n}\n\nstatic int rt274_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\tunsigned int rx_mask, int slots, int slot_width)\n\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (rx_mask || tx_mask) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_TDM_EN, RT274_TDM_EN);\n\t} else {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_TDM_EN, RT274_TDM_DIS);\n\t\treturn 0;\n\t}\n\n\tswitch (slots) {\n\tcase 4:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_TDM_CH_NUM, RT274_TDM_4CH);\n\t\tbreak;\n\tcase 2:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT274_I2S_CTRL1, RT274_TDM_CH_NUM, RT274_TDM_2CH);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"Support 2 or 4 slots TDM only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt274_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (SND_SOC_BIAS_STANDBY ==\n\t\t\tsnd_soc_component_get_bias_level(component)) {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT274_SET_AUDIO_POWER, AC_PWRST_D0);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_write(component,\n\t\t\tRT274_SET_AUDIO_POWER, AC_PWRST_D3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rt274_irq(int irq, void *data)\n{\n\tstruct rt274_priv *rt274 = data;\n\tbool hp = false;\n\tbool mic = false;\n\tint ret, status = 0;\n\n\t \n\tregmap_update_bits(rt274->regmap, RT274_EAPD_GPIO_IRQ_CTRL,\n\t\t\t\tRT274_IRQ_CLR, RT274_IRQ_CLR);\n\n\tret = rt274_jack_detect(rt274, &hp, &mic);\n\n\tif (ret == 0) {\n\t\tif (hp)\n\t\t\tstatus |= SND_JACK_HEADPHONE;\n\n\t\tif (mic)\n\t\t\tstatus |= SND_JACK_MICROPHONE;\n\n\t\tsnd_soc_jack_report(rt274->jack, status,\n\t\t\tSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\n\n\t\tpm_wakeup_event(&rt274->i2c->dev, 300);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rt274_probe(struct snd_soc_component *component)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\trt274->component = component;\n\tINIT_DELAYED_WORK(&rt274->jack_detect_work, rt274_jack_detect_work);\n\n\tif (rt274->i2c->irq)\n\t\tschedule_delayed_work(&rt274->jack_detect_work,\n\t\t\t\t      msecs_to_jiffies(1250));\n\treturn 0;\n}\n\nstatic void rt274_remove(struct snd_soc_component *component)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&rt274->jack_detect_work);\n\trt274->component = NULL;\n}\n\n#ifdef CONFIG_PM\nstatic int rt274_suspend(struct snd_soc_component *component)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt274->regmap, true);\n\tregcache_mark_dirty(rt274->regmap);\n\n\treturn 0;\n}\n\nstatic int rt274_resume(struct snd_soc_component *component)\n{\n\tstruct rt274_priv *rt274 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt274->regmap, false);\n\trt274_index_sync(component);\n\tregcache_sync(rt274->regmap);\n\n\treturn 0;\n}\n#else\n#define rt274_suspend NULL\n#define rt274_resume NULL\n#endif\n\n#define RT274_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define RT274_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt274_aif_dai_ops = {\n\t.hw_params = rt274_hw_params,\n\t.set_fmt = rt274_set_dai_fmt,\n\t.set_sysclk = rt274_set_dai_sysclk,\n\t.set_pll = rt274_set_dai_pll,\n\t.set_bclk_ratio = rt274_set_bclk_ratio,\n\t.set_tdm_slot = rt274_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver rt274_dai[] = {\n\t{\n\t\t.name = \"rt274-aif1\",\n\t\t.id = RT274_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT274_STEREO_RATES,\n\t\t\t.formats = RT274_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT274_STEREO_RATES,\n\t\t\t.formats = RT274_FORMATS,\n\t\t},\n\t\t.ops = &rt274_aif_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt274 = {\n\t.probe\t\t\t= rt274_probe,\n\t.remove\t\t\t= rt274_remove,\n\t.suspend\t\t= rt274_suspend,\n\t.resume\t\t\t= rt274_resume,\n\t.set_bias_level\t\t= rt274_set_bias_level,\n\t.set_jack\t\t= rt274_mic_detect,\n\t.controls\t\t= rt274_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(rt274_snd_controls),\n\t.dapm_widgets\t\t= rt274_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(rt274_dapm_widgets),\n\t.dapm_routes\t\t= rt274_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(rt274_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt274_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.max_register = 0x05bfffff,\n\t.volatile_reg = rt274_volatile_register,\n\t.readable_reg = rt274_readable_register,\n\t.reg_write = rl6347a_hw_write,\n\t.reg_read = rl6347a_hw_read,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = rt274_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt274_reg),\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rt274_of_match[] = {\n\t{.compatible = \"realtek,rt274\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt274_of_match);\n#endif\n\nstatic const struct i2c_device_id rt274_i2c_id[] = {\n\t{\"rt274\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rt274_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt274_acpi_match[] = {\n\t{ \"10EC0274\", 0 },\n\t{ \"INT34C2\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt274_acpi_match);\n#endif\n\nstatic int rt274_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt274_priv *rt274;\n\n\tint ret;\n\tunsigned int val;\n\n\trt274 = devm_kzalloc(&i2c->dev,\tsizeof(*rt274),\n\t\t\t\tGFP_KERNEL);\n\tif (rt274 == NULL)\n\t\treturn -ENOMEM;\n\n\trt274->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt274_regmap);\n\tif (IS_ERR(rt274->regmap)) {\n\t\tret = PTR_ERR(rt274->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(rt274->regmap,\n\t\tRT274_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != RT274_VENDOR_ID) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %#x is not rt274\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\trt274->index_cache = devm_kmemdup(&i2c->dev, rt274_index_def,\n\t\t\t\t\t  sizeof(rt274_index_def), GFP_KERNEL);\n\tif (!rt274->index_cache)\n\t\treturn -ENOMEM;\n\n\trt274->index_cache_size = INDEX_CACHE_SIZE;\n\trt274->i2c = i2c;\n\ti2c_set_clientdata(i2c, rt274);\n\n\t \n\tregmap_write(rt274->regmap, RT274_RESET, 0);\n\tregmap_update_bits(rt274->regmap, 0x1a, 0x4000, 0x4000);\n\n\t \n\tregmap_update_bits(rt274->regmap, RT274_PAD_CTRL12, 0x3, 0x0);\n\tregmap_write(rt274->regmap, RT274_COEF5b_INDEX, 0x01);\n\tregmap_write(rt274->regmap, RT274_COEF5b_COEF, 0x8540);\n\tregmap_update_bits(rt274->regmap, 0x6f, 0x0100, 0x0100);\n\t \n\tregmap_write(rt274->regmap, 0x4a, 0x201b);\n\t \n\tregmap_update_bits(rt274->regmap, 0x6f, 0x3000, 0x2000);\n\t \n\tregmap_update_bits(rt274->regmap, 0x6f, 0xf, 0x0);\n\t \n\tregmap_write(rt274->regmap, RT274_COEF58_INDEX, 0x00);\n\tregmap_write(rt274->regmap, RT274_COEF58_COEF, 0xb888);\n\tmsleep(500);\n\tregmap_update_bits(rt274->regmap, 0x6f, 0xf, 0xb);\n\tregmap_write(rt274->regmap, RT274_COEF58_INDEX, 0x00);\n\tregmap_write(rt274->regmap, RT274_COEF58_COEF, 0x3888);\n\t \n\tregmap_write(rt274->regmap, RT274_SET_PIN_HPO, 0x40);\n\tregmap_write(rt274->regmap, RT274_SET_PIN_LOUT3, 0x40);\n\tregmap_write(rt274->regmap, RT274_SET_MIC, 0x20);\n\tregmap_write(rt274->regmap, RT274_SET_PIN_DMIC1, 0x20);\n\n\tregmap_update_bits(rt274->regmap, RT274_I2S_CTRL2, 0xc004, 0x4004);\n\tregmap_update_bits(rt274->regmap, RT274_EAPD_GPIO_IRQ_CTRL,\n\t\t\t\tRT274_GPI2_SEL_MASK, RT274_GPI2_SEL_DMIC_CLK);\n\n\t \n\tregmap_write(rt274->regmap, RT274_UNSOLICITED_HP_OUT, 0x81);\n\tregmap_write(rt274->regmap, RT274_UNSOLICITED_MIC, 0x82);\n\n\tif (rt274->i2c->irq) {\n\t\tret = request_threaded_irq(rt274->i2c->irq, NULL, rt274_irq,\n\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT, \"rt274\", rt274);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to reguest IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_rt274,\n\t\t\t\t     rt274_dai, ARRAY_SIZE(rt274_dai));\n\n\treturn ret;\n}\n\nstatic void rt274_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct rt274_priv *rt274 = i2c_get_clientdata(i2c);\n\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, rt274);\n}\n\n\nstatic struct i2c_driver rt274_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"rt274\",\n\t\t   .acpi_match_table = ACPI_PTR(rt274_acpi_match),\n#ifdef CONFIG_OF\n\t\t   .of_match_table = of_match_ptr(rt274_of_match),\n#endif\n\t\t   },\n\t.probe = rt274_i2c_probe,\n\t.remove = rt274_i2c_remove,\n\t.id_table = rt274_i2c_id,\n};\n\nmodule_i2c_driver(rt274_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT274 driver\");\nMODULE_AUTHOR(\"Bard Liao <bardliao@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}