{
  "module_name": "pcm512x.c",
  "hash_id": "e0dc52d1b49b629030fd514b8e0e0be01ee8f812e0867cf16a924fc11310e8dd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm512x.c",
  "human_readable_source": "\n \n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gcd.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n\n#include \"pcm512x.h\"\n\n#define PCM512x_NUM_SUPPLIES 3\nstatic const char * const pcm512x_supply_names[PCM512x_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"CPVDD\",\n};\n\nstruct pcm512x_priv {\n\tstruct regmap *regmap;\n\tstruct clk *sclk;\n\tstruct regulator_bulk_data supplies[PCM512x_NUM_SUPPLIES];\n\tstruct notifier_block supply_nb[PCM512x_NUM_SUPPLIES];\n\tint fmt;\n\tint pll_in;\n\tint pll_out;\n\tint pll_r;\n\tint pll_j;\n\tint pll_d;\n\tint pll_p;\n\tunsigned long real_pll;\n\tunsigned long overclock_pll;\n\tunsigned long overclock_dac;\n\tunsigned long overclock_dsp;\n\tint mute;\n\tstruct mutex mutex;\n\tunsigned int bclk_ratio;\n};\n\n \n#define PCM512x_REGULATOR_EVENT(n) \\\nstatic int pcm512x_regulator_event_##n(struct notifier_block *nb, \\\n\t\t\t\t      unsigned long event, void *data)    \\\n{ \\\n\tstruct pcm512x_priv *pcm512x = container_of(nb, struct pcm512x_priv, \\\n\t\t\t\t\t\t    supply_nb[n]); \\\n\tif (event & REGULATOR_EVENT_DISABLE) { \\\n\t\tregcache_mark_dirty(pcm512x->regmap);\t\\\n\t\tregcache_cache_only(pcm512x->regmap, true);\t\\\n\t} \\\n\treturn 0; \\\n}\n\nPCM512x_REGULATOR_EVENT(0)\nPCM512x_REGULATOR_EVENT(1)\nPCM512x_REGULATOR_EVENT(2)\n\nstatic const struct reg_default pcm512x_reg_defaults[] = {\n\t{ PCM512x_RESET,             0x00 },\n\t{ PCM512x_POWER,             0x00 },\n\t{ PCM512x_MUTE,              0x00 },\n\t{ PCM512x_DSP,               0x00 },\n\t{ PCM512x_PLL_REF,           0x00 },\n\t{ PCM512x_DAC_REF,           0x00 },\n\t{ PCM512x_DAC_ROUTING,       0x11 },\n\t{ PCM512x_DSP_PROGRAM,       0x01 },\n\t{ PCM512x_CLKDET,            0x00 },\n\t{ PCM512x_AUTO_MUTE,         0x00 },\n\t{ PCM512x_ERROR_DETECT,      0x00 },\n\t{ PCM512x_DIGITAL_VOLUME_1,  0x00 },\n\t{ PCM512x_DIGITAL_VOLUME_2,  0x30 },\n\t{ PCM512x_DIGITAL_VOLUME_3,  0x30 },\n\t{ PCM512x_DIGITAL_MUTE_1,    0x22 },\n\t{ PCM512x_DIGITAL_MUTE_2,    0x00 },\n\t{ PCM512x_DIGITAL_MUTE_3,    0x07 },\n\t{ PCM512x_OUTPUT_AMPLITUDE,  0x00 },\n\t{ PCM512x_ANALOG_GAIN_CTRL,  0x00 },\n\t{ PCM512x_UNDERVOLTAGE_PROT, 0x00 },\n\t{ PCM512x_ANALOG_MUTE_CTRL,  0x00 },\n\t{ PCM512x_ANALOG_GAIN_BOOST, 0x00 },\n\t{ PCM512x_VCOM_CTRL_1,       0x00 },\n\t{ PCM512x_VCOM_CTRL_2,       0x01 },\n\t{ PCM512x_BCLK_LRCLK_CFG,    0x00 },\n\t{ PCM512x_MASTER_MODE,       0x7c },\n\t{ PCM512x_GPIO_DACIN,        0x00 },\n\t{ PCM512x_GPIO_PLLIN,        0x00 },\n\t{ PCM512x_SYNCHRONIZE,       0x10 },\n\t{ PCM512x_PLL_COEFF_0,       0x00 },\n\t{ PCM512x_PLL_COEFF_1,       0x00 },\n\t{ PCM512x_PLL_COEFF_2,       0x00 },\n\t{ PCM512x_PLL_COEFF_3,       0x00 },\n\t{ PCM512x_PLL_COEFF_4,       0x00 },\n\t{ PCM512x_DSP_CLKDIV,        0x00 },\n\t{ PCM512x_DAC_CLKDIV,        0x00 },\n\t{ PCM512x_NCP_CLKDIV,        0x00 },\n\t{ PCM512x_OSR_CLKDIV,        0x00 },\n\t{ PCM512x_MASTER_CLKDIV_1,   0x00 },\n\t{ PCM512x_MASTER_CLKDIV_2,   0x00 },\n\t{ PCM512x_FS_SPEED_MODE,     0x00 },\n\t{ PCM512x_IDAC_1,            0x01 },\n\t{ PCM512x_IDAC_2,            0x00 },\n\t{ PCM512x_I2S_1,             0x02 },\n\t{ PCM512x_I2S_2,             0x00 },\n};\n\nstatic bool pcm512x_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PCM512x_RESET:\n\tcase PCM512x_POWER:\n\tcase PCM512x_MUTE:\n\tcase PCM512x_PLL_EN:\n\tcase PCM512x_SPI_MISO_FUNCTION:\n\tcase PCM512x_DSP:\n\tcase PCM512x_GPIO_EN:\n\tcase PCM512x_BCLK_LRCLK_CFG:\n\tcase PCM512x_DSP_GPIO_INPUT:\n\tcase PCM512x_MASTER_MODE:\n\tcase PCM512x_PLL_REF:\n\tcase PCM512x_DAC_REF:\n\tcase PCM512x_GPIO_DACIN:\n\tcase PCM512x_GPIO_PLLIN:\n\tcase PCM512x_SYNCHRONIZE:\n\tcase PCM512x_PLL_COEFF_0:\n\tcase PCM512x_PLL_COEFF_1:\n\tcase PCM512x_PLL_COEFF_2:\n\tcase PCM512x_PLL_COEFF_3:\n\tcase PCM512x_PLL_COEFF_4:\n\tcase PCM512x_DSP_CLKDIV:\n\tcase PCM512x_DAC_CLKDIV:\n\tcase PCM512x_NCP_CLKDIV:\n\tcase PCM512x_OSR_CLKDIV:\n\tcase PCM512x_MASTER_CLKDIV_1:\n\tcase PCM512x_MASTER_CLKDIV_2:\n\tcase PCM512x_FS_SPEED_MODE:\n\tcase PCM512x_IDAC_1:\n\tcase PCM512x_IDAC_2:\n\tcase PCM512x_ERROR_DETECT:\n\tcase PCM512x_I2S_1:\n\tcase PCM512x_I2S_2:\n\tcase PCM512x_DAC_ROUTING:\n\tcase PCM512x_DSP_PROGRAM:\n\tcase PCM512x_CLKDET:\n\tcase PCM512x_AUTO_MUTE:\n\tcase PCM512x_DIGITAL_VOLUME_1:\n\tcase PCM512x_DIGITAL_VOLUME_2:\n\tcase PCM512x_DIGITAL_VOLUME_3:\n\tcase PCM512x_DIGITAL_MUTE_1:\n\tcase PCM512x_DIGITAL_MUTE_2:\n\tcase PCM512x_DIGITAL_MUTE_3:\n\tcase PCM512x_GPIO_OUTPUT_1:\n\tcase PCM512x_GPIO_OUTPUT_2:\n\tcase PCM512x_GPIO_OUTPUT_3:\n\tcase PCM512x_GPIO_OUTPUT_4:\n\tcase PCM512x_GPIO_OUTPUT_5:\n\tcase PCM512x_GPIO_OUTPUT_6:\n\tcase PCM512x_GPIO_CONTROL_1:\n\tcase PCM512x_GPIO_CONTROL_2:\n\tcase PCM512x_OVERFLOW:\n\tcase PCM512x_RATE_DET_1:\n\tcase PCM512x_RATE_DET_2:\n\tcase PCM512x_RATE_DET_3:\n\tcase PCM512x_RATE_DET_4:\n\tcase PCM512x_CLOCK_STATUS:\n\tcase PCM512x_ANALOG_MUTE_DET:\n\tcase PCM512x_GPIN:\n\tcase PCM512x_DIGITAL_MUTE_DET:\n\tcase PCM512x_OUTPUT_AMPLITUDE:\n\tcase PCM512x_ANALOG_GAIN_CTRL:\n\tcase PCM512x_UNDERVOLTAGE_PROT:\n\tcase PCM512x_ANALOG_MUTE_CTRL:\n\tcase PCM512x_ANALOG_GAIN_BOOST:\n\tcase PCM512x_VCOM_CTRL_1:\n\tcase PCM512x_VCOM_CTRL_2:\n\tcase PCM512x_CRAM_CTRL:\n\tcase PCM512x_FLEX_A:\n\tcase PCM512x_FLEX_B:\n\t\treturn true;\n\tdefault:\n\t\t \n\t\treturn reg < 0xff;\n\t}\n}\n\nstatic bool pcm512x_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PCM512x_PLL_EN:\n\tcase PCM512x_OVERFLOW:\n\tcase PCM512x_RATE_DET_1:\n\tcase PCM512x_RATE_DET_2:\n\tcase PCM512x_RATE_DET_3:\n\tcase PCM512x_RATE_DET_4:\n\tcase PCM512x_CLOCK_STATUS:\n\tcase PCM512x_ANALOG_MUTE_DET:\n\tcase PCM512x_GPIN:\n\tcase PCM512x_DIGITAL_MUTE_DET:\n\tcase PCM512x_CRAM_CTRL:\n\t\treturn true;\n\tdefault:\n\t\t \n\t\treturn reg < 0xff;\n\t}\n}\n\nstatic int pcm512x_overclock_pll_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = pcm512x->overclock_pll;\n\treturn 0;\n}\n\nstatic int pcm512x_overclock_pll_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tswitch (snd_soc_component_get_bias_level(component)) {\n\tcase SND_SOC_BIAS_OFF:\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tpcm512x->overclock_pll = ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int pcm512x_overclock_dsp_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = pcm512x->overclock_dsp;\n\treturn 0;\n}\n\nstatic int pcm512x_overclock_dsp_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tswitch (snd_soc_component_get_bias_level(component)) {\n\tcase SND_SOC_BIAS_OFF:\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tpcm512x->overclock_dsp = ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic int pcm512x_overclock_dac_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = pcm512x->overclock_dac;\n\treturn 0;\n}\n\nstatic int pcm512x_overclock_dac_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tswitch (snd_soc_component_get_bias_level(component)) {\n\tcase SND_SOC_BIAS_OFF:\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tpcm512x->overclock_dac = ucontrol->value.integer.value[0];\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -10350, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(analog_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, 0, 80, 0);\n\nstatic const char * const pcm512x_dsp_program_texts[] = {\n\t\"FIR interpolation with de-emphasis\",\n\t\"Low latency IIR with de-emphasis\",\n\t\"High attenuation with de-emphasis\",\n\t\"Fixed process flow\",\n\t\"Ringing-less low latency FIR\",\n};\n\nstatic const unsigned int pcm512x_dsp_program_values[] = {\n\t1,\n\t2,\n\t3,\n\t5,\n\t7,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(pcm512x_dsp_program,\n\t\t\t\t  PCM512x_DSP_PROGRAM, 0, 0x1f,\n\t\t\t\t  pcm512x_dsp_program_texts,\n\t\t\t\t  pcm512x_dsp_program_values);\n\nstatic const char * const pcm512x_clk_missing_text[] = {\n\t\"1s\", \"2s\", \"3s\", \"4s\", \"5s\", \"6s\", \"7s\", \"8s\"\n};\n\nstatic const struct soc_enum pcm512x_clk_missing =\n\tSOC_ENUM_SINGLE(PCM512x_CLKDET, 0,  8, pcm512x_clk_missing_text);\n\nstatic const char * const pcm512x_autom_text[] = {\n\t\"21ms\", \"106ms\", \"213ms\", \"533ms\", \"1.07s\", \"2.13s\", \"5.33s\", \"10.66s\"\n};\n\nstatic const struct soc_enum pcm512x_autom_l =\n\tSOC_ENUM_SINGLE(PCM512x_AUTO_MUTE, PCM512x_ATML_SHIFT, 8,\n\t\t\tpcm512x_autom_text);\n\nstatic const struct soc_enum pcm512x_autom_r =\n\tSOC_ENUM_SINGLE(PCM512x_AUTO_MUTE, PCM512x_ATMR_SHIFT, 8,\n\t\t\tpcm512x_autom_text);\n\nstatic const char * const pcm512x_ramp_rate_text[] = {\n\t\"1 sample/update\", \"2 samples/update\", \"4 samples/update\",\n\t\"Immediate\"\n};\n\nstatic const struct soc_enum pcm512x_vndf =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_1, PCM512x_VNDF_SHIFT, 4,\n\t\t\tpcm512x_ramp_rate_text);\n\nstatic const struct soc_enum pcm512x_vnuf =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_1, PCM512x_VNUF_SHIFT, 4,\n\t\t\tpcm512x_ramp_rate_text);\n\nstatic const struct soc_enum pcm512x_vedf =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_2, PCM512x_VEDF_SHIFT, 4,\n\t\t\tpcm512x_ramp_rate_text);\n\nstatic const char * const pcm512x_ramp_step_text[] = {\n\t\"4dB/step\", \"2dB/step\", \"1dB/step\", \"0.5dB/step\"\n};\n\nstatic const struct soc_enum pcm512x_vnds =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_1, PCM512x_VNDS_SHIFT, 4,\n\t\t\tpcm512x_ramp_step_text);\n\nstatic const struct soc_enum pcm512x_vnus =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_1, PCM512x_VNUS_SHIFT, 4,\n\t\t\tpcm512x_ramp_step_text);\n\nstatic const struct soc_enum pcm512x_veds =\n\tSOC_ENUM_SINGLE(PCM512x_DIGITAL_MUTE_2, PCM512x_VEDS_SHIFT, 4,\n\t\t\tpcm512x_ramp_step_text);\n\nstatic int pcm512x_update_mute(struct pcm512x_priv *pcm512x)\n{\n\treturn regmap_update_bits(\n\t\tpcm512x->regmap, PCM512x_MUTE, PCM512x_RQML | PCM512x_RQMR,\n\t\t(!!(pcm512x->mute & 0x5) << PCM512x_RQML_SHIFT)\n\t\t| (!!(pcm512x->mute & 0x3) << PCM512x_RQMR_SHIFT));\n}\n\nstatic int pcm512x_digital_playback_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&pcm512x->mutex);\n\tucontrol->value.integer.value[0] = !(pcm512x->mute & 0x4);\n\tucontrol->value.integer.value[1] = !(pcm512x->mute & 0x2);\n\tmutex_unlock(&pcm512x->mutex);\n\n\treturn 0;\n}\n\nstatic int pcm512x_digital_playback_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tint ret, changed = 0;\n\n\tmutex_lock(&pcm512x->mutex);\n\n\tif ((pcm512x->mute & 0x4) == (ucontrol->value.integer.value[0] << 2)) {\n\t\tpcm512x->mute ^= 0x4;\n\t\tchanged = 1;\n\t}\n\tif ((pcm512x->mute & 0x2) == (ucontrol->value.integer.value[1] << 1)) {\n\t\tpcm512x->mute ^= 0x2;\n\t\tchanged = 1;\n\t}\n\n\tif (changed) {\n\t\tret = pcm512x_update_mute(pcm512x);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update digital mute: %d\\n\", ret);\n\t\t\tmutex_unlock(&pcm512x->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&pcm512x->mutex);\n\n\treturn changed;\n}\n\nstatic const struct snd_kcontrol_new pcm512x_controls[] = {\nSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", PCM512x_DIGITAL_VOLUME_2,\n\t\t PCM512x_DIGITAL_VOLUME_3, 0, 255, 1, digital_tlv),\nSOC_DOUBLE_TLV(\"Analogue Playback Volume\", PCM512x_ANALOG_GAIN_CTRL,\n\t       PCM512x_LAGN_SHIFT, PCM512x_RAGN_SHIFT, 1, 1, analog_tlv),\nSOC_DOUBLE_TLV(\"Analogue Playback Boost Volume\", PCM512x_ANALOG_GAIN_BOOST,\n\t       PCM512x_AGBL_SHIFT, PCM512x_AGBR_SHIFT, 1, 0, boost_tlv),\n{\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t.name = \"Digital Playback Switch\",\n\t.index = 0,\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t.info = snd_ctl_boolean_stereo_info,\n\t.get = pcm512x_digital_playback_switch_get,\n\t.put = pcm512x_digital_playback_switch_put\n},\n\nSOC_SINGLE(\"Deemphasis Switch\", PCM512x_DSP, PCM512x_DEMP_SHIFT, 1, 1),\nSOC_ENUM(\"DSP Program\", pcm512x_dsp_program),\n\nSOC_ENUM(\"Clock Missing Period\", pcm512x_clk_missing),\nSOC_ENUM(\"Auto Mute Time Left\", pcm512x_autom_l),\nSOC_ENUM(\"Auto Mute Time Right\", pcm512x_autom_r),\nSOC_SINGLE(\"Auto Mute Mono Switch\", PCM512x_DIGITAL_MUTE_3,\n\t   PCM512x_ACTL_SHIFT, 1, 0),\nSOC_DOUBLE(\"Auto Mute Switch\", PCM512x_DIGITAL_MUTE_3, PCM512x_AMLE_SHIFT,\n\t   PCM512x_AMRE_SHIFT, 1, 0),\n\nSOC_ENUM(\"Volume Ramp Down Rate\", pcm512x_vndf),\nSOC_ENUM(\"Volume Ramp Down Step\", pcm512x_vnds),\nSOC_ENUM(\"Volume Ramp Up Rate\", pcm512x_vnuf),\nSOC_ENUM(\"Volume Ramp Up Step\", pcm512x_vnus),\nSOC_ENUM(\"Volume Ramp Down Emergency Rate\", pcm512x_vedf),\nSOC_ENUM(\"Volume Ramp Down Emergency Step\", pcm512x_veds),\n\nSOC_SINGLE_EXT(\"Max Overclock PLL\", SND_SOC_NOPM, 0, 20, 0,\n\t       pcm512x_overclock_pll_get, pcm512x_overclock_pll_put),\nSOC_SINGLE_EXT(\"Max Overclock DSP\", SND_SOC_NOPM, 0, 40, 0,\n\t       pcm512x_overclock_dsp_get, pcm512x_overclock_dsp_put),\nSOC_SINGLE_EXT(\"Max Overclock DAC\", SND_SOC_NOPM, 0, 40, 0,\n\t       pcm512x_overclock_dac_get, pcm512x_overclock_dac_put),\n};\n\nstatic const struct snd_soc_dapm_widget pcm512x_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DACL\", NULL, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_DAC(\"DACR\", NULL, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_OUTPUT(\"OUTL\"),\nSND_SOC_DAPM_OUTPUT(\"OUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route pcm512x_dapm_routes[] = {\n\t{ \"DACL\", NULL, \"Playback\" },\n\t{ \"DACR\", NULL, \"Playback\" },\n\n\t{ \"OUTL\", NULL, \"DACL\" },\n\t{ \"OUTR\", NULL, \"DACR\" },\n};\n\nstatic unsigned long pcm512x_pll_max(struct pcm512x_priv *pcm512x)\n{\n\treturn 25000000 + 25000000 * pcm512x->overclock_pll / 100;\n}\n\nstatic unsigned long pcm512x_dsp_max(struct pcm512x_priv *pcm512x)\n{\n\treturn 50000000 + 50000000 * pcm512x->overclock_dsp / 100;\n}\n\nstatic unsigned long pcm512x_dac_max(struct pcm512x_priv *pcm512x,\n\t\t\t\t     unsigned long rate)\n{\n\treturn rate + rate * pcm512x->overclock_dac / 100;\n}\n\nstatic unsigned long pcm512x_sck_max(struct pcm512x_priv *pcm512x)\n{\n\tif (!pcm512x->pll_out)\n\t\treturn 25000000;\n\treturn pcm512x_pll_max(pcm512x);\n}\n\nstatic unsigned long pcm512x_ncp_target(struct pcm512x_priv *pcm512x,\n\t\t\t\t\tunsigned long dac_rate)\n{\n\t \n\tif (dac_rate <= 6144000)\n\t\treturn 1536000;\n\t \n\treturn pcm512x_dac_max(pcm512x, 1536000);\n}\n\nstatic const u32 pcm512x_dai_rates[] = {\n\t8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000,\n\t88200, 96000, 176400, 192000, 384000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_slave = {\n\t.count = ARRAY_SIZE(pcm512x_dai_rates),\n\t.list  = pcm512x_dai_rates,\n};\n\nstatic int pcm512x_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_pcm_hw_rule *rule)\n{\n\tstruct pcm512x_priv *pcm512x = rule->private;\n\tstruct snd_interval ranges[2];\n\tint frame_size;\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0)\n\t\treturn frame_size;\n\n\tswitch (frame_size) {\n\tcase 32:\n\t\t \n\t\treturn 0;\n\tcase 48:\n\tcase 64:\n\t\t \n\t\tmemset(ranges, 0, sizeof(ranges));\n\t\tranges[0].min = 8000;\n\t\tranges[0].max = pcm512x_sck_max(pcm512x) / frame_size / 2;\n\t\tranges[1].min = DIV_ROUND_UP(16000000, frame_size);\n\t\tranges[1].max = 384000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_interval_ranges(hw_param_interval(params, rule->var),\n\t\t\t\t   ARRAY_SIZE(ranges), ranges, 0);\n}\n\nstatic int pcm512x_dai_startup_master(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = dai->dev;\n\tstruct snd_pcm_hw_constraint_ratnums *constraints_no_pll;\n\tstruct snd_ratnum *rats_no_pll;\n\n\tif (IS_ERR(pcm512x->sclk)) {\n\t\tdev_err(dev, \"Need SCLK for master mode: %ld\\n\",\n\t\t\tPTR_ERR(pcm512x->sclk));\n\t\treturn PTR_ERR(pcm512x->sclk);\n\t}\n\n\tif (pcm512x->pll_out)\n\t\treturn snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   pcm512x_hw_rule_rate,\n\t\t\t\t\t   pcm512x,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_FRAME_BITS,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS, -1);\n\n\tconstraints_no_pll = devm_kzalloc(dev, sizeof(*constraints_no_pll),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!constraints_no_pll)\n\t\treturn -ENOMEM;\n\tconstraints_no_pll->nrats = 1;\n\trats_no_pll = devm_kzalloc(dev, sizeof(*rats_no_pll), GFP_KERNEL);\n\tif (!rats_no_pll)\n\t\treturn -ENOMEM;\n\tconstraints_no_pll->rats = rats_no_pll;\n\trats_no_pll->num = clk_get_rate(pcm512x->sclk) / 64;\n\trats_no_pll->den_min = 1;\n\trats_no_pll->den_max = 128;\n\trats_no_pll->den_step = 1;\n\n\treturn snd_pcm_hw_constraint_ratnums(substream->runtime, 0,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t     constraints_no_pll);\n}\n\nstatic int pcm512x_dai_startup_slave(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = dai->dev;\n\tstruct regmap *regmap = pcm512x->regmap;\n\n\tif (IS_ERR(pcm512x->sclk)) {\n\t\tdev_info(dev, \"No SCLK, using BCLK: %ld\\n\",\n\t\t\t PTR_ERR(pcm512x->sclk));\n\n\t\t \n\t\tregmap_update_bits(regmap, PCM512x_ERROR_DETECT,\n\t\t\t\t   PCM512x_IDCH, PCM512x_IDCH);\n\n\t\t \n\t\tregmap_update_bits(regmap, PCM512x_PLL_REF,\n\t\t\t\t   PCM512x_SREF, PCM512x_SREF_BCK);\n\t}\n\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &constraints_slave);\n}\n\nstatic int pcm512x_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tswitch (pcm512x->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\treturn pcm512x_dai_startup_master(substream, dai);\n\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\treturn pcm512x_dai_startup_slave(substream, dai);\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int pcm512x_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct pcm512x_priv *pcm512x = dev_get_drvdata(component->dev);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\n\t\t\t\t\t PCM512x_RQST, 0);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to remove standby: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\n\t\t\t\t\t PCM512x_RQST, PCM512x_RQST);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to request standby: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long pcm512x_find_sck(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned long bclk_rate)\n{\n\tstruct device *dev = dai->dev;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tunsigned long sck_rate;\n\tint pow2;\n\n\t \n\t \n\n\t \n\tpow2 = 1 << fls((pcm512x_pll_max(pcm512x) - 16000000) / bclk_rate);\n\tfor (; pow2; pow2 >>= 1) {\n\t\tsck_rate = rounddown(pcm512x_pll_max(pcm512x),\n\t\t\t\t     bclk_rate * pow2);\n\t\tif (sck_rate >= 16000000)\n\t\t\tbreak;\n\t}\n\tif (!pow2) {\n\t\tdev_err(dev, \"Impossible to generate a suitable SCK\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"sck_rate %lu\\n\", sck_rate);\n\treturn sck_rate;\n}\n\n \nstatic int pcm512x_find_pll_coeff(struct snd_soc_dai *dai,\n\t\t\t\t  unsigned long pllin_rate,\n\t\t\t\t  unsigned long pll_rate)\n{\n\tstruct device *dev = dai->dev;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tunsigned long common;\n\tint R, J, D, P;\n\tunsigned long K;  \n\tunsigned long num;\n\tunsigned long den;\n\n\tcommon = gcd(pll_rate, pllin_rate);\n\tdev_dbg(dev, \"pll %lu pllin %lu common %lu\\n\",\n\t\tpll_rate, pllin_rate, common);\n\tnum = pll_rate / common;\n\tden = pllin_rate / common;\n\n\t \n\tif (pllin_rate / den > 20000000 && num < 8) {\n\t\tnum *= DIV_ROUND_UP(pllin_rate / den, 20000000);\n\t\tden *= DIV_ROUND_UP(pllin_rate / den, 20000000);\n\t}\n\tdev_dbg(dev, \"num / den = %lu / %lu\\n\", num, den);\n\n\tP = den;\n\tif (den <= 15 && num <= 16 * 63\n\t    && 1000000 <= pllin_rate / P && pllin_rate / P <= 20000000) {\n\t\t \n\t\tD = 0;\n\t\t \n\t\tfor (R = 16; R; R--) {\n\t\t\tif (num % R)\n\t\t\t\tcontinue;\n\t\t\tJ = num / R;\n\t\t\tif (J == 0 || J > 63)\n\t\t\t\tcontinue;\n\n\t\t\tdev_dbg(dev, \"R * J / P = %d * %d / %d\\n\", R, J, P);\n\t\t\tpcm512x->real_pll = pll_rate;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t}\n\n\tR = 1;\n\n\tif (num > 0xffffffffUL / 10000)\n\t\tgoto fallback;\n\n\t \n\tcommon = gcd(10000 * num, den);\n\tnum = 10000 * num / common;\n\tden /= common;\n\tdev_dbg(dev, \"num %lu den %lu common %lu\\n\", num, den, common);\n\n\tfor (P = den; P <= 15; P++) {\n\t\tif (pllin_rate / P < 6667000 || 200000000 < pllin_rate / P)\n\t\t\tcontinue;\n\t\tif (num * P % den)\n\t\t\tcontinue;\n\t\tK = num * P / den;\n\t\t \n\t\tif (K < 40000 || K > 120000)\n\t\t\tcontinue;\n\n\t\tJ = K / 10000;\n\t\tD = K % 10000;\n\t\tdev_dbg(dev, \"J.D / P = %d.%04d / %d\\n\", J, D, P);\n\t\tpcm512x->real_pll = pll_rate;\n\t\tgoto done;\n\t}\n\n\t \n\nfallback:\n\t \n\tP = DIV_ROUND_UP(pllin_rate, 20000000);\n\tif (!P)\n\t\tP = 1;\n\telse if (P > 15) {\n\t\tdev_err(dev, \"Need a slower clock as pll-input\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pllin_rate / P < 6667000) {\n\t\tdev_err(dev, \"Need a faster clock as pll-input\\n\");\n\t\treturn -EINVAL;\n\t}\n\tK = DIV_ROUND_CLOSEST_ULL(10000ULL * pll_rate * P, pllin_rate);\n\tif (K < 40000)\n\t\tK = 40000;\n\t \n\tif (K > 120000)\n\t\tK = 120000;\n\tJ = K / 10000;\n\tD = K % 10000;\n\tdev_dbg(dev, \"J.D / P ~ %d.%04d / %d\\n\", J, D, P);\n\tpcm512x->real_pll = DIV_ROUND_DOWN_ULL((u64)K * pllin_rate, 10000 * P);\n\ndone:\n\tpcm512x->pll_r = R;\n\tpcm512x->pll_j = J;\n\tpcm512x->pll_d = D;\n\tpcm512x->pll_p = P;\n\treturn 0;\n}\n\nstatic unsigned long pcm512x_pllin_dac_rate(struct snd_soc_dai *dai,\n\t\t\t\t\t    unsigned long osr_rate,\n\t\t\t\t\t    unsigned long pllin_rate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tunsigned long dac_rate;\n\n\tif (!pcm512x->pll_out)\n\t\treturn 0;  \n\n\tif (pllin_rate % osr_rate)\n\t\treturn 0;  \n\n\t \n\tfor (dac_rate = rounddown(pcm512x_dac_max(pcm512x, 6144000), osr_rate);\n\t     dac_rate;\n\t     dac_rate -= osr_rate) {\n\n\t\tif (pllin_rate / dac_rate > 128)\n\t\t\treturn 0;  \n\n\t\tif (!(pllin_rate % dac_rate))\n\t\t\treturn dac_rate;\n\n\t\tdac_rate -= osr_rate;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcm512x_set_dividers(struct snd_soc_dai *dai,\n\t\t\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct device *dev = dai->dev;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tunsigned long pllin_rate = 0;\n\tunsigned long pll_rate;\n\tunsigned long sck_rate;\n\tunsigned long mck_rate;\n\tunsigned long bclk_rate;\n\tunsigned long sample_rate;\n\tunsigned long osr_rate;\n\tunsigned long dacsrc_rate;\n\tint bclk_div;\n\tint lrclk_div;\n\tint dsp_div;\n\tint dac_div;\n\tunsigned long dac_rate;\n\tint ncp_div;\n\tint osr_div;\n\tint ret;\n\tint idac;\n\tint fssp;\n\tint gpio;\n\n\tif (pcm512x->bclk_ratio > 0) {\n\t\tlrclk_div = pcm512x->bclk_ratio;\n\t} else {\n\t\tlrclk_div = snd_soc_params_to_frame_size(params);\n\n\t\tif (lrclk_div == 0) {\n\t\t\tdev_err(dev, \"No LRCLK?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!pcm512x->pll_out) {\n\t\tsck_rate = clk_get_rate(pcm512x->sclk);\n\t\tbclk_rate = params_rate(params) * lrclk_div;\n\t\tbclk_div = DIV_ROUND_CLOSEST(sck_rate, bclk_rate);\n\n\t\tmck_rate = sck_rate;\n\t} else {\n\t\tret = snd_soc_params_to_bclk(params);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to find suitable BCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret == 0) {\n\t\t\tdev_err(dev, \"No BCLK?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbclk_rate = ret;\n\n\t\tpllin_rate = clk_get_rate(pcm512x->sclk);\n\n\t\tsck_rate = pcm512x_find_sck(dai, bclk_rate);\n\t\tif (!sck_rate)\n\t\t\treturn -EINVAL;\n\t\tpll_rate = 4 * sck_rate;\n\n\t\tret = pcm512x_find_pll_coeff(dai, pllin_rate, pll_rate);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(pcm512x->regmap,\n\t\t\t\t   PCM512x_PLL_COEFF_0, pcm512x->pll_p - 1);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to write PLL P: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(pcm512x->regmap,\n\t\t\t\t   PCM512x_PLL_COEFF_1, pcm512x->pll_j);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to write PLL J: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(pcm512x->regmap,\n\t\t\t\t   PCM512x_PLL_COEFF_2, pcm512x->pll_d >> 8);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to write PLL D msb: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(pcm512x->regmap,\n\t\t\t\t   PCM512x_PLL_COEFF_3, pcm512x->pll_d & 0xff);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to write PLL D lsb: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(pcm512x->regmap,\n\t\t\t\t   PCM512x_PLL_COEFF_4, pcm512x->pll_r - 1);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to write PLL R: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmck_rate = pcm512x->real_pll;\n\n\t\tbclk_div = DIV_ROUND_CLOSEST(sck_rate, bclk_rate);\n\t}\n\n\tif (bclk_div > 128) {\n\t\tdev_err(dev, \"Failed to find BCLK divider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsample_rate = sck_rate / bclk_div / lrclk_div;\n\tosr_rate = 16 * sample_rate;\n\n\t \n\tdsp_div = mck_rate > pcm512x_dsp_max(pcm512x) ? 2 : 1;\n\n\tdac_rate = pcm512x_pllin_dac_rate(dai, osr_rate, pllin_rate);\n\tif (dac_rate) {\n\t\t \n\t\tdev_dbg(dev, \"using pll input as dac input\\n\");\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_DAC_REF,\n\t\t\t\t\t PCM512x_SDAC, PCM512x_SDAC_GPIO);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set gpio as dacref: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgpio = PCM512x_GREF_GPIO1 + pcm512x->pll_in - 1;\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_DACIN,\n\t\t\t\t\t PCM512x_GREF, gpio);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set gpio %d as dacin: %d\\n\",\n\t\t\t\tpcm512x->pll_in, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdacsrc_rate = pllin_rate;\n\t} else {\n\t\t \n\t\tunsigned long dac_mul = pcm512x_dac_max(pcm512x, 6144000)\n\t\t\t/ osr_rate;\n\t\tunsigned long sck_mul = sck_rate / osr_rate;\n\n\t\tfor (; dac_mul; dac_mul--) {\n\t\t\tif (!(sck_mul % dac_mul))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!dac_mul) {\n\t\t\tdev_err(dev, \"Failed to find DAC rate\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdac_rate = dac_mul * osr_rate;\n\t\tdev_dbg(dev, \"dac_rate %lu sample_rate %lu\\n\",\n\t\t\tdac_rate, sample_rate);\n\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_DAC_REF,\n\t\t\t\t\t PCM512x_SDAC, PCM512x_SDAC_SCK);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set sck as dacref: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdacsrc_rate = sck_rate;\n\t}\n\n\tosr_div = DIV_ROUND_CLOSEST(dac_rate, osr_rate);\n\tif (osr_div > 128) {\n\t\tdev_err(dev, \"Failed to find OSR divider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdac_div = DIV_ROUND_CLOSEST(dacsrc_rate, dac_rate);\n\tif (dac_div > 128) {\n\t\tdev_err(dev, \"Failed to find DAC divider\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdac_rate = dacsrc_rate / dac_div;\n\n\tncp_div = DIV_ROUND_CLOSEST(dac_rate,\n\t\t\t\t    pcm512x_ncp_target(pcm512x, dac_rate));\n\tif (ncp_div > 128 || dac_rate / ncp_div > 2048000) {\n\t\t \n\t\tncp_div = DIV_ROUND_UP(dac_rate, 2048000);\n\t\tif (ncp_div > 128) {\n\t\t\tdev_err(dev, \"Failed to find NCP divider\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tidac = mck_rate / (dsp_div * sample_rate);\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_DSP_CLKDIV, dsp_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write DSP divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_DAC_CLKDIV, dac_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write DAC divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_NCP_CLKDIV, ncp_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write NCP divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_OSR_CLKDIV, osr_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write OSR divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap,\n\t\t\t   PCM512x_MASTER_CLKDIV_1, bclk_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write BCLK divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap,\n\t\t\t   PCM512x_MASTER_CLKDIV_2, lrclk_div - 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write LRCLK divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_IDAC_1, idac >> 8);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write IDAC msb divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(pcm512x->regmap, PCM512x_IDAC_2, idac & 0xff);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to write IDAC lsb divider: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (sample_rate <= pcm512x_dac_max(pcm512x, 48000))\n\t\tfssp = PCM512x_FSSP_48KHZ;\n\telse if (sample_rate <= pcm512x_dac_max(pcm512x, 96000))\n\t\tfssp = PCM512x_FSSP_96KHZ;\n\telse if (sample_rate <= pcm512x_dac_max(pcm512x, 192000))\n\t\tfssp = PCM512x_FSSP_192KHZ;\n\telse\n\t\tfssp = PCM512x_FSSP_384KHZ;\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_FS_SPEED_MODE,\n\t\t\t\t PCM512x_FSSP, fssp);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set fs speed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"DSP divider %d\\n\", dsp_div);\n\tdev_dbg(component->dev, \"DAC divider %d\\n\", dac_div);\n\tdev_dbg(component->dev, \"NCP divider %d\\n\", ncp_div);\n\tdev_dbg(component->dev, \"OSR divider %d\\n\", osr_div);\n\tdev_dbg(component->dev, \"BCK divider %d\\n\", bclk_div);\n\tdev_dbg(component->dev, \"LRCK divider %d\\n\", lrclk_div);\n\tdev_dbg(component->dev, \"IDAC %d\\n\", idac);\n\tdev_dbg(component->dev, \"1<<FSSP %d\\n\", 1 << fssp);\n\n\treturn 0;\n}\n\nstatic int pcm512x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tint alen;\n\tint gpio;\n\tint ret;\n\n\tdev_dbg(component->dev, \"hw_params %u Hz, %u channels\\n\",\n\t\tparams_rate(params),\n\t\tparams_channels(params));\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\talen = PCM512x_ALEN_16;\n\t\tbreak;\n\tcase 20:\n\t\talen = PCM512x_ALEN_20;\n\t\tbreak;\n\tcase 24:\n\t\talen = PCM512x_ALEN_24;\n\t\tbreak;\n\tcase 32:\n\t\talen = PCM512x_ALEN_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Bad frame size: %d\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_I2S_1,\n\t\t\t\t PCM512x_ALEN, alen);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set frame size: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif ((pcm512x->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) ==\n\t    SND_SOC_DAIFMT_CBC_CFC) {\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\n\t\t\t\t\t PCM512x_DCAS, 0);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to enable clock divider autoset: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tgoto skip_pll;\n\t}\n\n\tif (pcm512x->pll_out) {\n\t\tret = regmap_write(pcm512x->regmap, PCM512x_FLEX_A, 0x11);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to set FLEX_A: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(pcm512x->regmap, PCM512x_FLEX_B, 0xff);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to set FLEX_B: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\n\t\t\t\t\t PCM512x_IDFS | PCM512x_IDBK\n\t\t\t\t\t | PCM512x_IDSK | PCM512x_IDCH\n\t\t\t\t\t | PCM512x_IDCM | PCM512x_DCAS\n\t\t\t\t\t | PCM512x_IPLK,\n\t\t\t\t\t PCM512x_IDFS | PCM512x_IDBK\n\t\t\t\t\t | PCM512x_IDSK | PCM512x_IDCH\n\t\t\t\t\t | PCM512x_DCAS);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to ignore auto-clock failures: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_ERROR_DETECT,\n\t\t\t\t\t PCM512x_IDFS | PCM512x_IDBK\n\t\t\t\t\t | PCM512x_IDSK | PCM512x_IDCH\n\t\t\t\t\t | PCM512x_IDCM | PCM512x_DCAS\n\t\t\t\t\t | PCM512x_IPLK,\n\t\t\t\t\t PCM512x_IDFS | PCM512x_IDBK\n\t\t\t\t\t | PCM512x_IDSK | PCM512x_IDCH\n\t\t\t\t\t | PCM512x_DCAS | PCM512x_IPLK);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to ignore auto-clock failures: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_EN,\n\t\t\t\t\t PCM512x_PLLE, 0);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to disable pll: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = pcm512x_set_dividers(dai, params);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (pcm512x->pll_out) {\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_REF,\n\t\t\t\t\t PCM512x_SREF, PCM512x_SREF_GPIO);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set gpio as pllref: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgpio = PCM512x_GREF_GPIO1 + pcm512x->pll_in - 1;\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_PLLIN,\n\t\t\t\t\t PCM512x_GREF, gpio);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set gpio %d as pllin: %d\\n\",\n\t\t\t\tpcm512x->pll_in, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_PLL_EN,\n\t\t\t\t\t PCM512x_PLLE, PCM512x_PLLE);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to enable pll: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgpio = PCM512x_G1OE << (pcm512x->pll_out - 1);\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_GPIO_EN,\n\t\t\t\t\t gpio, gpio);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to enable gpio %d: %d\\n\",\n\t\t\t\tpcm512x->pll_out, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgpio = PCM512x_GPIO_OUTPUT_1 + pcm512x->pll_out - 1;\n\t\tret = regmap_update_bits(pcm512x->regmap, gpio,\n\t\t\t\t\t PCM512x_GxSL, PCM512x_GxSL_PLLCK);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to output pll on %d: %d\\n\",\n\t\t\t\tret, pcm512x->pll_out);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_SYNCHRONIZE,\n\t\t\t\t PCM512x_RQSY, PCM512x_RQSY_HALT);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to halt clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_SYNCHRONIZE,\n\t\t\t\t PCM512x_RQSY, PCM512x_RQSY_RESUME);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to resume clocks: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nskip_pll:\n\treturn 0;\n}\n\nstatic int pcm512x_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tint afmt;\n\tint offset = 0;\n\tint clock_output;\n\tint provider_mode;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tclock_output = 0;\n\t\tprovider_mode = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tclock_output = PCM512x_BCKO | PCM512x_LRKO;\n\t\tprovider_mode = PCM512x_RLRK | PCM512x_RBCK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tclock_output = PCM512x_BCKO;\n\t\tprovider_mode = PCM512x_RBCK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_BCLK_LRCLK_CFG,\n\t\t\t\t PCM512x_BCKP | PCM512x_BCKO | PCM512x_LRKO,\n\t\t\t\t clock_output);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable clock output: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_MASTER_MODE,\n\t\t\t\t PCM512x_RLRK | PCM512x_RBCK,\n\t\t\t\t provider_mode);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable provider mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tafmt = PCM512x_AFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tafmt = PCM512x_AFMT_RTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tafmt = PCM512x_AFMT_LTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\toffset = 1;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tafmt = PCM512x_AFMT_DSP;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported DAI format: 0x%x\\n\",\n\t\t\tpcm512x->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_I2S_1,\n\t\t\t\t PCM512x_AFMT, afmt);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set data format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_I2S_2,\n\t\t\t\t 0xFF, offset);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set data offset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpcm512x->fmt = fmt;\n\n\treturn 0;\n}\n\nstatic int pcm512x_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\n\tif (ratio > 256)\n\t\treturn -EINVAL;\n\n\tpcm512x->bclk_ratio = ratio;\n\n\treturn 0;\n}\n\nstatic int pcm512x_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm512x_priv *pcm512x = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tunsigned int mute_det;\n\n\tmutex_lock(&pcm512x->mutex);\n\n\tif (mute) {\n\t\tpcm512x->mute |= 0x1;\n\t\tret = regmap_update_bits(pcm512x->regmap, PCM512x_MUTE,\n\t\t\t\t\t PCM512x_RQML | PCM512x_RQMR,\n\t\t\t\t\t PCM512x_RQML | PCM512x_RQMR);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set digital mute: %d\\n\", ret);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tregmap_read_poll_timeout(pcm512x->regmap,\n\t\t\t\t\t PCM512x_ANALOG_MUTE_DET,\n\t\t\t\t\t mute_det, (mute_det & 0x3) == 0,\n\t\t\t\t\t 200, 10000);\n\t} else {\n\t\tpcm512x->mute &= ~0x1;\n\t\tret = pcm512x_update_mute(pcm512x);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update digital mute: %d\\n\", ret);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tregmap_read_poll_timeout(pcm512x->regmap,\n\t\t\t\t\t PCM512x_ANALOG_MUTE_DET,\n\t\t\t\t\t mute_det,\n\t\t\t\t\t (mute_det & 0x3)\n\t\t\t\t\t == ((~pcm512x->mute >> 1) & 0x3),\n\t\t\t\t\t 200, 10000);\n\t}\n\nunlock:\n\tmutex_unlock(&pcm512x->mutex);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops pcm512x_dai_ops = {\n\t.startup = pcm512x_dai_startup,\n\t.hw_params = pcm512x_hw_params,\n\t.set_fmt = pcm512x_set_fmt,\n\t.mute_stream = pcm512x_mute,\n\t.set_bclk_ratio = pcm512x_set_bclk_ratio,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver pcm512x_dai = {\n\t.name = \"pcm512x-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 384000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE\n\t},\n\t.ops = &pcm512x_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver pcm512x_component_driver = {\n\t.set_bias_level\t\t= pcm512x_set_bias_level,\n\t.controls\t\t= pcm512x_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm512x_controls),\n\t.dapm_widgets\t\t= pcm512x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm512x_dapm_widgets),\n\t.dapm_routes\t\t= pcm512x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm512x_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_range_cfg pcm512x_range = {\n\t.name = \"Pages\", .range_min = PCM512x_VIRT_BASE,\n\t.range_max = PCM512x_MAX_REGISTER,\n\t.selector_reg = PCM512x_PAGE,\n\t.selector_mask = 0xff,\n\t.window_start = 0, .window_len = 0x100,\n};\n\nconst struct regmap_config pcm512x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.readable_reg = pcm512x_readable,\n\t.volatile_reg = pcm512x_volatile,\n\n\t.ranges = &pcm512x_range,\n\t.num_ranges = 1,\n\n\t.max_register = PCM512x_MAX_REGISTER,\n\t.reg_defaults = pcm512x_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(pcm512x_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_GPL(pcm512x_regmap);\n\nint pcm512x_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct pcm512x_priv *pcm512x;\n\tint i, ret;\n\n\tpcm512x = devm_kzalloc(dev, sizeof(struct pcm512x_priv), GFP_KERNEL);\n\tif (!pcm512x)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&pcm512x->mutex);\n\n\tdev_set_drvdata(dev, pcm512x);\n\tpcm512x->regmap = regmap;\n\n\tfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++)\n\t\tpcm512x->supplies[i].supply = pcm512x_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(pcm512x->supplies),\n\t\t\t\t      pcm512x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpcm512x->supply_nb[0].notifier_call = pcm512x_regulator_event_0;\n\tpcm512x->supply_nb[1].notifier_call = pcm512x_regulator_event_1;\n\tpcm512x->supply_nb[2].notifier_call = pcm512x_regulator_event_2;\n\n\tfor (i = 0; i < ARRAY_SIZE(pcm512x->supplies); i++) {\n\t\tret = devm_regulator_register_notifier(\n\t\t\t\t\t\tpcm512x->supplies[i].consumer,\n\t\t\t\t\t\t&pcm512x->supply_nb[i]);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to register regulator notifier: %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\n\t\t\t\t    pcm512x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(regmap, PCM512x_RESET,\n\t\t\t   PCM512x_RSTM | PCM512x_RSTR);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to reset device: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_write(regmap, PCM512x_RESET, 0);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to reset device: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tpcm512x->sclk = devm_clk_get(dev, NULL);\n\tif (PTR_ERR(pcm512x->sclk) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err;\n\t}\n\tif (!IS_ERR(pcm512x->sclk)) {\n\t\tret = clk_prepare_enable(pcm512x->sclk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to enable SCLK: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\n\t\t\t\t PCM512x_RQST, PCM512x_RQST);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request standby: %d\\n\",\n\t\t\tret);\n\t\tgoto err_clk;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n#ifdef CONFIG_OF\n\tif (dev->of_node) {\n\t\tconst struct device_node *np = dev->of_node;\n\t\tu32 val;\n\n\t\tif (of_property_read_u32(np, \"pll-in\", &val) >= 0) {\n\t\t\tif (val > 6) {\n\t\t\t\tdev_err(dev, \"Invalid pll-in\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_pm;\n\t\t\t}\n\t\t\tpcm512x->pll_in = val;\n\t\t}\n\n\t\tif (of_property_read_u32(np, \"pll-out\", &val) >= 0) {\n\t\t\tif (val > 6) {\n\t\t\t\tdev_err(dev, \"Invalid pll-out\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err_pm;\n\t\t\t}\n\t\t\tpcm512x->pll_out = val;\n\t\t}\n\n\t\tif (!pcm512x->pll_in != !pcm512x->pll_out) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Error: both pll-in and pll-out, or none\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_pm;\n\t\t}\n\t\tif (pcm512x->pll_in && pcm512x->pll_in == pcm512x->pll_out) {\n\t\t\tdev_err(dev, \"Error: pll-in == pll-out\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_pm;\n\t\t}\n\t}\n#endif\n\n\tret = devm_snd_soc_register_component(dev, &pcm512x_component_driver,\n\t\t\t\t    &pcm512x_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev);\nerr_clk:\n\tif (!IS_ERR(pcm512x->sclk))\n\t\tclk_disable_unprepare(pcm512x->sclk);\nerr:\n\tregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\n\t\t\t\t     pcm512x->supplies);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pcm512x_probe);\n\nvoid pcm512x_remove(struct device *dev)\n{\n\tstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\n\n\tpm_runtime_disable(dev);\n\tif (!IS_ERR(pcm512x->sclk))\n\t\tclk_disable_unprepare(pcm512x->sclk);\n\tregulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\n\t\t\t       pcm512x->supplies);\n}\nEXPORT_SYMBOL_GPL(pcm512x_remove);\n\n#ifdef CONFIG_PM\nstatic int pcm512x_suspend(struct device *dev)\n{\n\tstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\n\t\t\t\t PCM512x_RQPD, PCM512x_RQPD);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request power down: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(pcm512x->supplies),\n\t\t\t\t     pcm512x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to disable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR(pcm512x->sclk))\n\t\tclk_disable_unprepare(pcm512x->sclk);\n\n\treturn 0;\n}\n\nstatic int pcm512x_resume(struct device *dev)\n{\n\tstruct pcm512x_priv *pcm512x = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!IS_ERR(pcm512x->sclk)) {\n\t\tret = clk_prepare_enable(pcm512x->sclk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev, \"Failed to enable SCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(pcm512x->supplies),\n\t\t\t\t    pcm512x->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(pcm512x->regmap, false);\n\tret = regcache_sync(pcm512x->regmap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to sync cache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(pcm512x->regmap, PCM512x_POWER,\n\t\t\t\t PCM512x_RQPD, 0);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to remove power down: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops pcm512x_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pcm512x_suspend, pcm512x_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(pcm512x_pm_ops);\n\nMODULE_DESCRIPTION(\"ASoC PCM512x codec driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}