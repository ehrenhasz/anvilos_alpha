{
  "module_name": "adau1977.c",
  "hash_id": "cf20c75ca6335db0eb6467be39dd7609ba5882364a8f02627ebae5f878784234",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau1977.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include <dt-bindings/sound/adi,adau1977.h>\n\n#include \"adau1977.h\"\n\n#define ADAU1977_REG_POWER\t\t0x00\n#define ADAU1977_REG_PLL\t\t0x01\n#define ADAU1977_REG_BOOST\t\t0x02\n#define ADAU1977_REG_MICBIAS\t\t0x03\n#define ADAU1977_REG_BLOCK_POWER_SAI\t0x04\n#define ADAU1977_REG_SAI_CTRL0\t\t0x05\n#define ADAU1977_REG_SAI_CTRL1\t\t0x06\n#define ADAU1977_REG_CMAP12\t\t0x07\n#define ADAU1977_REG_CMAP34\t\t0x08\n#define ADAU1977_REG_SAI_OVERTEMP\t0x09\n#define ADAU1977_REG_POST_ADC_GAIN(x)\t(0x0a + (x))\n#define ADAU1977_REG_MISC_CONTROL\t0x0e\n#define ADAU1977_REG_DIAG_CONTROL\t0x10\n#define ADAU1977_REG_STATUS(x)\t\t(0x11 + (x))\n#define ADAU1977_REG_DIAG_IRQ1\t\t0x15\n#define ADAU1977_REG_DIAG_IRQ2\t\t0x16\n#define ADAU1977_REG_ADJUST1\t\t0x17\n#define ADAU1977_REG_ADJUST2\t\t0x18\n#define ADAU1977_REG_ADC_CLIP\t\t0x19\n#define ADAU1977_REG_DC_HPF_CAL\t\t0x1a\n\n#define ADAU1977_POWER_RESET\t\t\tBIT(7)\n#define ADAU1977_POWER_PWUP\t\t\tBIT(0)\n\n#define ADAU1977_PLL_CLK_S\t\t\tBIT(4)\n#define ADAU1977_PLL_MCS_MASK\t\t\t0x7\n\n#define ADAU1977_MICBIAS_MB_VOLTS_MASK\t\t0xf0\n#define ADAU1977_MICBIAS_MB_VOLTS_OFFSET\t4\n\n#define ADAU1977_BLOCK_POWER_SAI_LR_POL\t\tBIT(7)\n#define ADAU1977_BLOCK_POWER_SAI_BCLK_EDGE\tBIT(6)\n#define ADAU1977_BLOCK_POWER_SAI_LDO_EN\t\tBIT(5)\n\n#define ADAU1977_SAI_CTRL0_FMT_MASK\t\t(0x3 << 6)\n#define ADAU1977_SAI_CTRL0_FMT_I2S\t\t(0x0 << 6)\n#define ADAU1977_SAI_CTRL0_FMT_LJ\t\t(0x1 << 6)\n#define ADAU1977_SAI_CTRL0_FMT_RJ_24BIT\t\t(0x2 << 6)\n#define ADAU1977_SAI_CTRL0_FMT_RJ_16BIT\t\t(0x3 << 6)\n\n#define ADAU1977_SAI_CTRL0_SAI_MASK\t\t(0x7 << 3)\n#define ADAU1977_SAI_CTRL0_SAI_I2S\t\t(0x0 << 3)\n#define ADAU1977_SAI_CTRL0_SAI_TDM_2\t\t(0x1 << 3)\n#define ADAU1977_SAI_CTRL0_SAI_TDM_4\t\t(0x2 << 3)\n#define ADAU1977_SAI_CTRL0_SAI_TDM_8\t\t(0x3 << 3)\n#define ADAU1977_SAI_CTRL0_SAI_TDM_16\t\t(0x4 << 3)\n\n#define ADAU1977_SAI_CTRL0_FS_MASK\t\t(0x7)\n#define ADAU1977_SAI_CTRL0_FS_8000_12000\t(0x0)\n#define ADAU1977_SAI_CTRL0_FS_16000_24000\t(0x1)\n#define ADAU1977_SAI_CTRL0_FS_32000_48000\t(0x2)\n#define ADAU1977_SAI_CTRL0_FS_64000_96000\t(0x3)\n#define ADAU1977_SAI_CTRL0_FS_128000_192000\t(0x4)\n\n#define ADAU1977_SAI_CTRL1_SLOT_WIDTH_MASK\t(0x3 << 5)\n#define ADAU1977_SAI_CTRL1_SLOT_WIDTH_32\t(0x0 << 5)\n#define ADAU1977_SAI_CTRL1_SLOT_WIDTH_24\t(0x1 << 5)\n#define ADAU1977_SAI_CTRL1_SLOT_WIDTH_16\t(0x2 << 5)\n#define ADAU1977_SAI_CTRL1_DATA_WIDTH_MASK\t(0x1 << 4)\n#define ADAU1977_SAI_CTRL1_DATA_WIDTH_16BIT\t(0x1 << 4)\n#define ADAU1977_SAI_CTRL1_DATA_WIDTH_24BIT\t(0x0 << 4)\n#define ADAU1977_SAI_CTRL1_LRCLK_PULSE\t\tBIT(3)\n#define ADAU1977_SAI_CTRL1_MSB\t\t\tBIT(2)\n#define ADAU1977_SAI_CTRL1_BCLKRATE_16\t\t(0x1 << 1)\n#define ADAU1977_SAI_CTRL1_BCLKRATE_32\t\t(0x0 << 1)\n#define ADAU1977_SAI_CTRL1_BCLKRATE_MASK\t(0x1 << 1)\n#define ADAU1977_SAI_CTRL1_MASTER\t\tBIT(0)\n\n#define ADAU1977_SAI_OVERTEMP_DRV_C(x)\t\tBIT(4 + (x))\n#define ADAU1977_SAI_OVERTEMP_DRV_HIZ\t\tBIT(3)\n\n#define ADAU1977_MISC_CONTROL_SUM_MODE_MASK\t(0x3 << 6)\n#define ADAU1977_MISC_CONTROL_SUM_MODE_1CH\t(0x2 << 6)\n#define ADAU1977_MISC_CONTROL_SUM_MODE_2CH\t(0x1 << 6)\n#define ADAU1977_MISC_CONTROL_SUM_MODE_4CH\t(0x0 << 6)\n#define ADAU1977_MISC_CONTROL_MMUTE\t\tBIT(4)\n#define ADAU1977_MISC_CONTROL_DC_CAL\t\tBIT(0)\n\n#define ADAU1977_CHAN_MAP_SECOND_SLOT_OFFSET\t4\n#define ADAU1977_CHAN_MAP_FIRST_SLOT_OFFSET\t0\n\nstruct adau1977 {\n\tstruct regmap *regmap;\n\tbool right_j;\n\tunsigned int sysclk;\n\tenum adau1977_sysclk_src sysclk_src;\n\tstruct gpio_desc *reset_gpio;\n\tenum adau1977_type type;\n\n\tstruct regulator *avdd_reg;\n\tstruct regulator *dvdd_reg;\n\n\tstruct snd_pcm_hw_constraint_list constraints;\n\n\tstruct device *dev;\n\tvoid (*switch_mode)(struct device *dev);\n\n\tunsigned int max_clock_provider_fs;\n\tunsigned int slot_width;\n\tbool enabled;\n\tbool clock_provider;\n};\n\nstatic const struct reg_default adau1977_reg_defaults[] = {\n\t{ 0x00, 0x00 },\n\t{ 0x01, 0x41 },\n\t{ 0x02, 0x4a },\n\t{ 0x03, 0x7d },\n\t{ 0x04, 0x3d },\n\t{ 0x05, 0x02 },\n\t{ 0x06, 0x00 },\n\t{ 0x07, 0x10 },\n\t{ 0x08, 0x32 },\n\t{ 0x09, 0xf0 },\n\t{ 0x0a, 0xa0 },\n\t{ 0x0b, 0xa0 },\n\t{ 0x0c, 0xa0 },\n\t{ 0x0d, 0xa0 },\n\t{ 0x0e, 0x02 },\n\t{ 0x10, 0x0f },\n\t{ 0x15, 0x20 },\n\t{ 0x16, 0x00 },\n\t{ 0x17, 0x00 },\n\t{ 0x18, 0x00 },\n\t{ 0x1a, 0x00 },\n};\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(adau1977_adc_gain, -3562, 6000);\n\nstatic const struct snd_soc_dapm_widget adau1977_micbias_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", ADAU1977_REG_MICBIAS,\n\t\t3, 0, NULL, 0)\n};\n\nstatic const struct snd_soc_dapm_widget adau1977_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Vref\", ADAU1977_REG_BLOCK_POWER_SAI,\n\t\t4, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"ADC1\", \"Capture\", ADAU1977_REG_BLOCK_POWER_SAI, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC2\", \"Capture\", ADAU1977_REG_BLOCK_POWER_SAI, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADC3\", \"Capture\", ADAU1977_REG_BLOCK_POWER_SAI, 2, 0),\n\tSND_SOC_DAPM_ADC(\"ADC4\", \"Capture\", ADAU1977_REG_BLOCK_POWER_SAI, 3, 0),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"VREF\"),\n};\n\nstatic const struct snd_soc_dapm_route adau1977_dapm_routes[] = {\n\t{ \"ADC1\", NULL, \"AIN1\" },\n\t{ \"ADC2\", NULL, \"AIN2\" },\n\t{ \"ADC3\", NULL, \"AIN3\" },\n\t{ \"ADC4\", NULL, \"AIN4\" },\n\n\t{ \"ADC1\", NULL, \"Vref\" },\n\t{ \"ADC2\", NULL, \"Vref\" },\n\t{ \"ADC3\", NULL, \"Vref\" },\n\t{ \"ADC4\", NULL, \"Vref\" },\n\n\t{ \"VREF\", NULL, \"Vref\" },\n};\n\n#define ADAU1977_VOLUME(x) \\\n\tSOC_SINGLE_TLV(\"ADC\" #x \" Capture Volume\", \\\n\t\tADAU1977_REG_POST_ADC_GAIN((x) - 1), \\\n\t\t0, 255, 1, adau1977_adc_gain)\n\n#define ADAU1977_HPF_SWITCH(x) \\\n\tSOC_SINGLE(\"ADC\" #x \" Highpass-Filter Capture Switch\", \\\n\t\tADAU1977_REG_DC_HPF_CAL, (x) - 1, 1, 0)\n\n#define ADAU1977_DC_SUB_SWITCH(x) \\\n\tSOC_SINGLE(\"ADC\" #x \" DC Subtraction Capture Switch\", \\\n\t\tADAU1977_REG_DC_HPF_CAL, (x) + 3, 1, 0)\n\nstatic const struct snd_kcontrol_new adau1977_snd_controls[] = {\n\tADAU1977_VOLUME(1),\n\tADAU1977_VOLUME(2),\n\tADAU1977_VOLUME(3),\n\tADAU1977_VOLUME(4),\n\n\tADAU1977_HPF_SWITCH(1),\n\tADAU1977_HPF_SWITCH(2),\n\tADAU1977_HPF_SWITCH(3),\n\tADAU1977_HPF_SWITCH(4),\n\n\tADAU1977_DC_SUB_SWITCH(1),\n\tADAU1977_DC_SUB_SWITCH(2),\n\tADAU1977_DC_SUB_SWITCH(3),\n\tADAU1977_DC_SUB_SWITCH(4),\n};\n\nstatic int adau1977_reset(struct adau1977 *adau1977)\n{\n\tint ret;\n\n\t \n\tregcache_cache_bypass(adau1977->regmap, true);\n\tret = regmap_write(adau1977->regmap, ADAU1977_REG_POWER,\n\t\t\tADAU1977_POWER_RESET);\n\tregcache_cache_bypass(adau1977->regmap, false);\n\n\treturn ret;\n}\n\n \nstatic int adau1977_lookup_fs(unsigned int rate)\n{\n\tif (rate >= 8000 && rate <= 12000)\n\t\treturn ADAU1977_SAI_CTRL0_FS_8000_12000;\n\telse if (rate >= 16000 && rate <= 24000)\n\t\treturn ADAU1977_SAI_CTRL0_FS_16000_24000;\n\telse if (rate >= 32000 && rate <= 48000)\n\t\treturn ADAU1977_SAI_CTRL0_FS_32000_48000;\n\telse if (rate >= 64000 && rate <= 96000)\n\t\treturn ADAU1977_SAI_CTRL0_FS_64000_96000;\n\telse if (rate >= 128000 && rate <= 192000)\n\t\treturn ADAU1977_SAI_CTRL0_FS_128000_192000;\n\telse\n\t\treturn -EINVAL;\n}\n\nstatic int adau1977_lookup_mcs(struct adau1977 *adau1977, unsigned int rate,\n\tunsigned int fs)\n{\n\tunsigned int mcs;\n\n\t \n\n\trate *= 512 >> fs;\n\n\tif (adau1977->sysclk % rate != 0)\n\t\treturn -EINVAL;\n\n\tmcs = adau1977->sysclk / rate;\n\n\t \n\tif (mcs < 1 || mcs > 6 || mcs == 5)\n\t\treturn -EINVAL;\n\n\tmcs = mcs - 1;\n\tif (mcs == 5)\n\t\tmcs = 4;\n\n\treturn mcs;\n}\n\nstatic int adau1977_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(component);\n\tunsigned int rate = params_rate(params);\n\tunsigned int slot_width;\n\tunsigned int ctrl0, ctrl0_mask;\n\tunsigned int ctrl1;\n\tint mcs, fs;\n\tint ret;\n\n\tfs = adau1977_lookup_fs(rate);\n\tif (fs < 0)\n\t\treturn fs;\n\n\tif (adau1977->sysclk_src == ADAU1977_SYSCLK_SRC_MCLK) {\n\t\tmcs = adau1977_lookup_mcs(adau1977, rate, fs);\n\t\tif (mcs < 0)\n\t\t\treturn mcs;\n\t} else {\n\t\tmcs = 0;\n\t}\n\n\tctrl0_mask = ADAU1977_SAI_CTRL0_FS_MASK;\n\tctrl0 = fs;\n\n\tif (adau1977->right_j) {\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_16BIT;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_24BIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctrl0_mask |= ADAU1977_SAI_CTRL0_FMT_MASK;\n\t}\n\n\tif (adau1977->clock_provider) {\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tctrl1 = ADAU1977_SAI_CTRL1_DATA_WIDTH_16BIT;\n\t\t\tslot_width = 16;\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tctrl1 = ADAU1977_SAI_CTRL1_DATA_WIDTH_24BIT;\n\t\t\tslot_width = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (adau1977->slot_width)\n\t\t\tslot_width = adau1977->slot_width;\n\n\t\tif (slot_width == 16)\n\t\t\tctrl1 |= ADAU1977_SAI_CTRL1_BCLKRATE_16;\n\t\telse\n\t\t\tctrl1 |= ADAU1977_SAI_CTRL1_BCLKRATE_32;\n\n\t\tret = regmap_update_bits(adau1977->regmap,\n\t\t\tADAU1977_REG_SAI_CTRL1,\n\t\t\tADAU1977_SAI_CTRL1_DATA_WIDTH_MASK |\n\t\t\tADAU1977_SAI_CTRL1_BCLKRATE_MASK,\n\t\t\tctrl1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\n\t\t\t\tctrl0_mask, ctrl0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_PLL,\n\t\t\t\tADAU1977_PLL_MCS_MASK, mcs);\n}\n\nstatic int adau1977_power_disable(struct adau1977 *adau1977)\n{\n\tint ret = 0;\n\n\tif (!adau1977->enabled)\n\t\treturn 0;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_POWER,\n\t\tADAU1977_POWER_PWUP, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_mark_dirty(adau1977->regmap);\n\n\tgpiod_set_value_cansleep(adau1977->reset_gpio, 0);\n\n\tregcache_cache_only(adau1977->regmap, true);\n\n\tregulator_disable(adau1977->avdd_reg);\n\tif (adau1977->dvdd_reg)\n\t\tregulator_disable(adau1977->dvdd_reg);\n\n\tadau1977->enabled = false;\n\n\treturn 0;\n}\n\nstatic int adau1977_power_enable(struct adau1977 *adau1977)\n{\n\tunsigned int val;\n\tint ret = 0;\n\n\tif (adau1977->enabled)\n\t\treturn 0;\n\n\tret = regulator_enable(adau1977->avdd_reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adau1977->dvdd_reg) {\n\t\tret = regulator_enable(adau1977->dvdd_reg);\n\t\tif (ret)\n\t\t\tgoto err_disable_avdd;\n\t}\n\n\tgpiod_set_value_cansleep(adau1977->reset_gpio, 1);\n\n\tregcache_cache_only(adau1977->regmap, false);\n\n\tif (adau1977->switch_mode)\n\t\tadau1977->switch_mode(adau1977->dev);\n\n\tret = adau1977_reset(adau1977);\n\tif (ret)\n\t\tgoto err_disable_dvdd;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_POWER,\n\t\tADAU1977_POWER_PWUP, ADAU1977_POWER_PWUP);\n\tif (ret)\n\t\tgoto err_disable_dvdd;\n\n\tret = regcache_sync(adau1977->regmap);\n\tif (ret)\n\t\tgoto err_disable_dvdd;\n\n\t \n\tret = regmap_read(adau1977->regmap, ADAU1977_REG_PLL, &val);\n\tif (ret)\n\t\tgoto err_disable_dvdd;\n\n\tif (val == 0x41) {\n\t\tregcache_cache_bypass(adau1977->regmap, true);\n\t\tret = regmap_write(adau1977->regmap, ADAU1977_REG_PLL,\n\t\t\t0x41);\n\t\tif (ret)\n\t\t\tgoto err_disable_dvdd;\n\t\tregcache_cache_bypass(adau1977->regmap, false);\n\t}\n\n\tadau1977->enabled = true;\n\n\treturn ret;\n\nerr_disable_dvdd:\n\tif (adau1977->dvdd_reg)\n\t\tregulator_disable(adau1977->dvdd_reg);\nerr_disable_avdd:\n\t\tregulator_disable(adau1977->avdd_reg);\n\treturn ret;\n}\n\nstatic int adau1977_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tret = adau1977_power_enable(adau1977);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tret = adau1977_power_disable(adau1977);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int adau1977_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\tunsigned int rx_mask, int slots, int width)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ctrl0, ctrl1, drv;\n\tunsigned int slot[4];\n\tunsigned int i;\n\tint ret;\n\n\tif (slots == 0) {\n\t\t \n\t\tadau1977->slot_width = 0;\n\t\tadau1977->max_clock_provider_fs = 192000;\n\t\treturn regmap_update_bits(adau1977->regmap,\n\t\t\tADAU1977_REG_SAI_CTRL0, ADAU1977_SAI_CTRL0_SAI_MASK,\n\t\t\tADAU1977_SAI_CTRL0_SAI_I2S);\n\t}\n\n\tif (rx_mask == 0 || tx_mask != 0)\n\t\treturn -EINVAL;\n\n\tdrv = 0;\n\tfor (i = 0; i < 4; i++) {\n\t\tslot[i] = __ffs(rx_mask);\n\t\tdrv |= ADAU1977_SAI_OVERTEMP_DRV_C(i);\n\t\trx_mask &= ~(1 << slot[i]);\n\t\tif (slot[i] >= slots)\n\t\t\treturn -EINVAL;\n\t\tif (rx_mask == 0)\n\t\t\tbreak;\n\t}\n\n\tif (rx_mask != 0)\n\t\treturn -EINVAL;\n\n\tswitch (width) {\n\tcase 16:\n\t\tctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_16;\n\t\tbreak;\n\tcase 24:\n\t\t \n\t\tif (adau1977->clock_provider)\n\t\t\treturn -EINVAL;\n\t\tctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_24;\n\t\tbreak;\n\tcase 32:\n\t\tctrl1 = ADAU1977_SAI_CTRL1_SLOT_WIDTH_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slots) {\n\tcase 2:\n\t\tctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_2;\n\t\tbreak;\n\tcase 4:\n\t\tctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_4;\n\t\tbreak;\n\tcase 8:\n\t\tctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_8;\n\t\tbreak;\n\tcase 16:\n\t\tctrl0 = ADAU1977_SAI_CTRL0_SAI_TDM_16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_OVERTEMP,\n\t\tADAU1977_SAI_OVERTEMP_DRV_C(0) |\n\t\tADAU1977_SAI_OVERTEMP_DRV_C(1) |\n\t\tADAU1977_SAI_OVERTEMP_DRV_C(2) |\n\t\tADAU1977_SAI_OVERTEMP_DRV_C(3), drv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(adau1977->regmap, ADAU1977_REG_CMAP12,\n\t\t(slot[1] << ADAU1977_CHAN_MAP_SECOND_SLOT_OFFSET) |\n\t\t(slot[0] << ADAU1977_CHAN_MAP_FIRST_SLOT_OFFSET));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(adau1977->regmap, ADAU1977_REG_CMAP34,\n\t\t(slot[3] << ADAU1977_CHAN_MAP_SECOND_SLOT_OFFSET) |\n\t\t(slot[2] << ADAU1977_CHAN_MAP_FIRST_SLOT_OFFSET));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\n\t\tADAU1977_SAI_CTRL0_SAI_MASK, ctrl0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL1,\n\t\tADAU1977_SAI_CTRL1_SLOT_WIDTH_MASK, ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\tadau1977->slot_width = width;\n\n\t \n\tadau1977->max_clock_provider_fs = min(192000, 24576000 / width / slots);\n\n\treturn 0;\n}\n\nstatic int adau1977_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int val;\n\n\tif (mute)\n\t\tval = ADAU1977_MISC_CONTROL_MMUTE;\n\telse\n\t\tval = 0;\n\n\treturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_MISC_CONTROL,\n\t\t\tADAU1977_MISC_CONTROL_MMUTE, val);\n}\n\nstatic int adau1977_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ctrl0 = 0, ctrl1 = 0, block_power = 0;\n\tbool invert_lrclk;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tadau1977->clock_provider = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tctrl1 |= ADAU1977_SAI_CTRL1_MASTER;\n\t\tadau1977->clock_provider = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tblock_power |= ADAU1977_BLOCK_POWER_SAI_BCLK_EDGE;\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert_lrclk = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tblock_power |= ADAU1977_BLOCK_POWER_SAI_BCLK_EDGE;\n\t\tinvert_lrclk = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadau1977->right_j = false;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_LJ;\n\t\tinvert_lrclk = !invert_lrclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_RJ_24BIT;\n\t\tadau1977->right_j = true;\n\t\tinvert_lrclk = !invert_lrclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1 |= ADAU1977_SAI_CTRL1_LRCLK_PULSE;\n\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_I2S;\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl1 |= ADAU1977_SAI_CTRL1_LRCLK_PULSE;\n\t\tctrl0 |= ADAU1977_SAI_CTRL0_FMT_LJ;\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (invert_lrclk)\n\t\tblock_power |= ADAU1977_BLOCK_POWER_SAI_LR_POL;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_BLOCK_POWER_SAI,\n\t\tADAU1977_BLOCK_POWER_SAI_LR_POL |\n\t\tADAU1977_BLOCK_POWER_SAI_BCLK_EDGE, block_power);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL0,\n\t\tADAU1977_SAI_CTRL0_FMT_MASK,\n\t\tctrl0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_CTRL1,\n\t\tADAU1977_SAI_CTRL1_MASTER | ADAU1977_SAI_CTRL1_LRCLK_PULSE,\n\t\tctrl1);\n}\n\nstatic int adau1977_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(dai->component);\n\tu64 formats = 0;\n\n\tif (adau1977->slot_width == 16)\n\t\tformats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE;\n\telse if (adau1977->right_j || adau1977->slot_width == 24)\n\t\tformats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S16_BE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_BE;\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_RATE, &adau1977->constraints);\n\n\tif (adau1977->clock_provider)\n\t\tsnd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, 8000,\n\t\t\t\t\t     adau1977->max_clock_provider_fs);\n\n\tif (formats != 0)\n\t\tsnd_pcm_hw_constraint_mask64(substream->runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_FORMAT, formats);\n\n\treturn 0;\n}\n\nstatic int adau1977_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int val;\n\n\tif (tristate)\n\t\tval = ADAU1977_SAI_OVERTEMP_DRV_HIZ;\n\telse\n\t\tval = 0;\n\n\treturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_SAI_OVERTEMP,\n\t\tADAU1977_SAI_OVERTEMP_DRV_HIZ, val);\n}\n\nstatic const struct snd_soc_dai_ops adau1977_dai_ops = {\n\t.startup\t= adau1977_startup,\n\t.hw_params\t= adau1977_hw_params,\n\t.mute_stream\t= adau1977_mute,\n\t.set_fmt\t= adau1977_set_dai_fmt,\n\t.set_tdm_slot\t= adau1977_set_tdm_slot,\n\t.set_tristate\t= adau1977_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver adau1977_dai = {\n\t.name = \"adau1977-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 4,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t    SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &adau1977_dai_ops,\n};\n\nstatic const unsigned int adau1977_rates[] = {\n\t8000, 16000, 32000, 64000, 128000,\n\t11025, 22050, 44100, 88200, 172400,\n\t12000, 24000, 48000, 96000, 192000,\n};\n\n#define ADAU1977_RATE_CONSTRAINT_MASK_32000 0x001f\n#define ADAU1977_RATE_CONSTRAINT_MASK_44100 0x03e0\n#define ADAU1977_RATE_CONSTRAINT_MASK_48000 0x7c00\n \n#define ADAU1977_RATE_CONSTRAINT_MASK_LRCLK 0x739c\n\nstatic bool adau1977_check_sysclk(unsigned int mclk, unsigned int base_freq)\n{\n\tunsigned int mcs;\n\n\tif (mclk % (base_freq * 128) != 0)\n\t\treturn false;\n\n\tmcs = mclk / (128 * base_freq);\n\tif (mcs < 1 || mcs > 6 || mcs == 5)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int adau1977_set_sysclk(struct snd_soc_component *component,\n\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(component);\n\tunsigned int mask = 0;\n\tunsigned int clk_src;\n\tunsigned int ret;\n\n\tif (dir != SND_SOC_CLOCK_IN)\n\t\treturn -EINVAL;\n\n\tif (clk_id != ADAU1977_SYSCLK)\n\t\treturn -EINVAL;\n\n\tswitch (source) {\n\tcase ADAU1977_SYSCLK_SRC_MCLK:\n\t\tclk_src = 0;\n\t\tbreak;\n\tcase ADAU1977_SYSCLK_SRC_LRCLK:\n\t\tclk_src = ADAU1977_PLL_CLK_S;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (freq != 0 && source == ADAU1977_SYSCLK_SRC_MCLK) {\n\t\tif (freq < 4000000 || freq > 36864000)\n\t\t\treturn -EINVAL;\n\n\t\tif (adau1977_check_sysclk(freq, 32000))\n\t\t\tmask |= ADAU1977_RATE_CONSTRAINT_MASK_32000;\n\t\tif (adau1977_check_sysclk(freq, 44100))\n\t\t\tmask |= ADAU1977_RATE_CONSTRAINT_MASK_44100;\n\t\tif (adau1977_check_sysclk(freq, 48000))\n\t\t\tmask |= ADAU1977_RATE_CONSTRAINT_MASK_48000;\n\n\t\tif (mask == 0)\n\t\t\treturn -EINVAL;\n\t} else if (source == ADAU1977_SYSCLK_SRC_LRCLK) {\n\t\tmask = ADAU1977_RATE_CONSTRAINT_MASK_LRCLK;\n\t}\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_PLL,\n\t\tADAU1977_PLL_CLK_S, clk_src);\n\tif (ret)\n\t\treturn ret;\n\n\tadau1977->constraints.mask = mask;\n\tadau1977->sysclk_src = source;\n\tadau1977->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int adau1977_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau1977 *adau1977 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (adau1977->type) {\n\tcase ADAU1977:\n\t\tret = snd_soc_dapm_new_controls(dapm,\n\t\t\tadau1977_micbias_dapm_widgets,\n\t\t\tARRAY_SIZE(adau1977_micbias_dapm_widgets));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver adau1977_component_driver = {\n\t.probe\t\t\t= adau1977_component_probe,\n\t.set_bias_level\t\t= adau1977_set_bias_level,\n\t.set_sysclk\t\t= adau1977_set_sysclk,\n\t.controls\t\t= adau1977_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adau1977_snd_controls),\n\t.dapm_widgets\t\t= adau1977_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adau1977_dapm_widgets),\n\t.dapm_routes\t\t= adau1977_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(adau1977_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int adau1977_setup_micbias(struct adau1977 *adau1977)\n{\n\tunsigned int micbias;\n\n\tif (device_property_read_u32(adau1977->dev, \"adi,micbias\", &micbias))\n\t\tmicbias = ADAU1977_MICBIAS_8V5;\n\n\tif (micbias > ADAU1977_MICBIAS_9V0) {\n\t\tdev_err(adau1977->dev, \"Invalid value for 'adi,micbias'\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(adau1977->regmap, ADAU1977_REG_MICBIAS,\n\t\tADAU1977_MICBIAS_MB_VOLTS_MASK,\n\t\tmicbias << ADAU1977_MICBIAS_MB_VOLTS_OFFSET);\n}\n\nint adau1977_probe(struct device *dev, struct regmap *regmap,\n\tenum adau1977_type type, void (*switch_mode)(struct device *dev))\n{\n\tunsigned int power_off_mask;\n\tstruct adau1977 *adau1977;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tadau1977 = devm_kzalloc(dev, sizeof(*adau1977), GFP_KERNEL);\n\tif (adau1977 == NULL)\n\t\treturn -ENOMEM;\n\n\tadau1977->dev = dev;\n\tadau1977->type = type;\n\tadau1977->regmap = regmap;\n\tadau1977->switch_mode = switch_mode;\n\tadau1977->max_clock_provider_fs = 192000;\n\n\tadau1977->constraints.list = adau1977_rates;\n\tadau1977->constraints.count = ARRAY_SIZE(adau1977_rates);\n\n\tadau1977->avdd_reg = devm_regulator_get(dev, \"AVDD\");\n\tif (IS_ERR(adau1977->avdd_reg))\n\t\treturn PTR_ERR(adau1977->avdd_reg);\n\n\tadau1977->dvdd_reg = devm_regulator_get_optional(dev, \"DVDD\");\n\tif (IS_ERR(adau1977->dvdd_reg)) {\n\t\tif (PTR_ERR(adau1977->dvdd_reg) != -ENODEV)\n\t\t\treturn PTR_ERR(adau1977->dvdd_reg);\n\t\tadau1977->dvdd_reg = NULL;\n\t}\n\n\tadau1977->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(adau1977->reset_gpio))\n\t\treturn PTR_ERR(adau1977->reset_gpio);\n\n\tdev_set_drvdata(dev, adau1977);\n\n\tif (adau1977->reset_gpio)\n\t\tndelay(100);\n\n\tret = adau1977_power_enable(adau1977);\n\tif (ret)\n\t\treturn ret;\n\n\tif (type == ADAU1977) {\n\t\tret = adau1977_setup_micbias(adau1977);\n\t\tif (ret)\n\t\t\tgoto err_poweroff;\n\t}\n\n\tif (adau1977->dvdd_reg)\n\t\tpower_off_mask = ~0;\n\telse\n\t\tpower_off_mask = (unsigned int)~ADAU1977_BLOCK_POWER_SAI_LDO_EN;\n\n\tret = regmap_update_bits(adau1977->regmap, ADAU1977_REG_BLOCK_POWER_SAI,\n\t\t\t\tpower_off_mask, 0x00);\n\tif (ret)\n\t\tgoto err_poweroff;\n\n\tret = adau1977_power_disable(adau1977);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(dev, &adau1977_component_driver,\n\t\t\t&adau1977_dai, 1);\n\nerr_poweroff:\n\tadau1977_power_disable(adau1977);\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(adau1977_probe);\n\nstatic bool adau1977_register_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADAU1977_REG_STATUS(0):\n\tcase ADAU1977_REG_STATUS(1):\n\tcase ADAU1977_REG_STATUS(2):\n\tcase ADAU1977_REG_STATUS(3):\n\tcase ADAU1977_REG_ADC_CLIP:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nconst struct regmap_config adau1977_regmap_config = {\n\t.max_register = ADAU1977_REG_DC_HPF_CAL,\n\t.volatile_reg = adau1977_register_volatile,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = adau1977_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adau1977_reg_defaults),\n};\nEXPORT_SYMBOL_GPL(adau1977_regmap_config);\n\nMODULE_DESCRIPTION(\"ASoC ADAU1977/ADAU1978/ADAU1979 driver\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}