{
  "module_name": "si476x.c",
  "hash_id": "7c2e9f02bdd84d2c826e0cdf62a7ca76195af6990ce434706d5e874677448c9a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/si476x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include <linux/i2c.h>\n\n#include <linux/mfd/si476x-core.h>\n\nenum si476x_audio_registers {\n\tSI476X_DIGITAL_IO_OUTPUT_FORMAT\t\t= 0x0203,\n\tSI476X_DIGITAL_IO_OUTPUT_SAMPLE_RATE\t= 0x0202,\n};\n\nenum si476x_digital_io_output_format {\n\tSI476X_DIGITAL_IO_SLOT_SIZE_SHIFT\t= 11,\n\tSI476X_DIGITAL_IO_SAMPLE_SIZE_SHIFT\t= 8,\n};\n\n#define SI476X_DIGITAL_IO_OUTPUT_WIDTH_MASK\t((0x7 << SI476X_DIGITAL_IO_SLOT_SIZE_SHIFT) | \\\n\t\t\t\t\t\t  (0x7 << SI476X_DIGITAL_IO_SAMPLE_SIZE_SHIFT))\n#define SI476X_DIGITAL_IO_OUTPUT_FORMAT_MASK\t(0x7e)\n\nenum si476x_daudio_formats {\n\tSI476X_DAUDIO_MODE_I2S\t\t= (0x0 << 1),\n\tSI476X_DAUDIO_MODE_DSP_A\t= (0x6 << 1),\n\tSI476X_DAUDIO_MODE_DSP_B\t= (0x7 << 1),\n\tSI476X_DAUDIO_MODE_LEFT_J\t= (0x8 << 1),\n\tSI476X_DAUDIO_MODE_RIGHT_J\t= (0x9 << 1),\n\n\tSI476X_DAUDIO_MODE_IB\t\t= (1 << 5),\n\tSI476X_DAUDIO_MODE_IF\t\t= (1 << 6),\n};\n\nenum si476x_pcm_format {\n\tSI476X_PCM_FORMAT_S8\t\t= 2,\n\tSI476X_PCM_FORMAT_S16_LE\t= 4,\n\tSI476X_PCM_FORMAT_S20_3LE\t= 5,\n\tSI476X_PCM_FORMAT_S24_LE\t= 6,\n};\n\nstatic const struct snd_soc_dapm_widget si476x_dapm_widgets[] = {\nSND_SOC_DAPM_OUTPUT(\"LOUT\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n};\n\nstatic const struct snd_soc_dapm_route si476x_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"LOUT\" },\n\t{ \"Capture\", NULL, \"ROUT\" },\n};\n\nstatic int si476x_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t    unsigned int fmt)\n{\n\tstruct si476x_core *core = i2c_mfd_cell_to_core(codec_dai->dev);\n\tint err;\n\tu16 format = 0;\n\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC)\n\t\treturn -EINVAL;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat |= SI476X_DAUDIO_MODE_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat |= SI476X_DAUDIO_MODE_DSP_B;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat |= SI476X_DAUDIO_MODE_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tformat |= SI476X_DAUDIO_MODE_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat |= SI476X_DAUDIO_MODE_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tformat |= SI476X_DAUDIO_MODE_IB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tformat |= SI476X_DAUDIO_MODE_IB |\n\t\t\t\tSI476X_DAUDIO_MODE_IF;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tformat |= SI476X_DAUDIO_MODE_IB;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tformat |= SI476X_DAUDIO_MODE_IF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsi476x_core_lock(core);\n\n\terr = snd_soc_component_update_bits(codec_dai->component, SI476X_DIGITAL_IO_OUTPUT_FORMAT,\n\t\t\t\t  SI476X_DIGITAL_IO_OUTPUT_FORMAT_MASK,\n\t\t\t\t  format);\n\n\tsi476x_core_unlock(core);\n\n\tif (err < 0) {\n\t\tdev_err(codec_dai->component->dev, \"Failed to set output format\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int si476x_codec_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct si476x_core *core = i2c_mfd_cell_to_core(dai->dev);\n\tint rate, width, err;\n\n\trate = params_rate(params);\n\tif (rate < 32000 || rate > 48000) {\n\t\tdev_err(dai->component->dev, \"Rate: %d is not supported\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 8:\n\t\twidth = SI476X_PCM_FORMAT_S8;\n\t\tbreak;\n\tcase 16:\n\t\twidth = SI476X_PCM_FORMAT_S16_LE;\n\t\tbreak;\n\tcase 20:\n\t\twidth = SI476X_PCM_FORMAT_S20_3LE;\n\t\tbreak;\n\tcase 24:\n\t\twidth = SI476X_PCM_FORMAT_S24_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsi476x_core_lock(core);\n\n\terr = snd_soc_component_write(dai->component, SI476X_DIGITAL_IO_OUTPUT_SAMPLE_RATE,\n\t\t\t    rate);\n\tif (err < 0) {\n\t\tdev_err(dai->component->dev, \"Failed to set sample rate\\n\");\n\t\tgoto out;\n\t}\n\n\terr = snd_soc_component_update_bits(dai->component, SI476X_DIGITAL_IO_OUTPUT_FORMAT,\n\t\t\t\t  SI476X_DIGITAL_IO_OUTPUT_WIDTH_MASK,\n\t\t\t\t  (width << SI476X_DIGITAL_IO_SLOT_SIZE_SHIFT) |\n\t\t\t\t  (width << SI476X_DIGITAL_IO_SAMPLE_SIZE_SHIFT));\n\tif (err < 0) {\n\t\tdev_err(dai->component->dev, \"Failed to set output width\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tsi476x_core_unlock(core);\n\n\treturn err;\n}\n\nstatic const struct snd_soc_dai_ops si476x_dai_ops = {\n\t.hw_params\t= si476x_codec_hw_params,\n\t.set_fmt\t= si476x_codec_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver si476x_dai = {\n\t.name\t\t= \"si476x-codec\",\n\t.capture\t= {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\n\t\t.rates = SNDRV_PCM_RATE_32000 |\n\t\tSNDRV_PCM_RATE_44100 |\n\t\tSNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S8 |\n\t\tSNDRV_PCM_FMTBIT_S16_LE |\n\t\tSNDRV_PCM_FMTBIT_S20_3LE |\n\t\tSNDRV_PCM_FMTBIT_S24_LE\n\t},\n\t.ops\t\t= &si476x_dai_ops,\n};\n\nstatic int si476x_probe(struct snd_soc_component *component)\n{\n\tsnd_soc_component_init_regmap(component,\n\t\t\t\tdev_get_regmap(component->dev->parent, NULL));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_si476x = {\n\t.probe\t\t\t= si476x_probe,\n\t.dapm_widgets\t\t= si476x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(si476x_dapm_widgets),\n\t.dapm_routes\t\t= si476x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(si476x_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int si476x_platform_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &soc_component_dev_si476x,\n\t\t\t\t      &si476x_dai, 1);\n}\n\nMODULE_ALIAS(\"platform:si476x-codec\");\n\nstatic struct platform_driver si476x_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"si476x-codec\",\n\t},\n\t.probe\t\t= si476x_platform_probe,\n};\nmodule_platform_driver(si476x_platform_driver);\n\nMODULE_AUTHOR(\"Andrey Smirnov <andrew.smirnov@gmail.com>\");\nMODULE_DESCRIPTION(\"ASoC Si4761/64 codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}