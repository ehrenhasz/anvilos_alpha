{
  "module_name": "wm8978.c",
  "hash_id": "91aed63ffdf7ef7cc7b7b587021054c6e72ba9dd3ba02234d02694026d667a8e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8978.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <asm/div64.h>\n\n#include \"wm8978.h\"\n\nstatic const struct reg_default wm8978_reg_defaults[] = {\n\t{ 1, 0x0000 },\n\t{ 2, 0x0000 },\n\t{ 3, 0x0000 },\n\t{ 4, 0x0050 },\n\t{ 5, 0x0000 },\n\t{ 6, 0x0140 },\n\t{ 7, 0x0000 },\n\t{ 8, 0x0000 },\n\t{ 9, 0x0000 },\n\t{ 10, 0x0000 },\n\t{ 11, 0x00ff },\n\t{ 12, 0x00ff },\n\t{ 13, 0x0000 },\n\t{ 14, 0x0100 },\n\t{ 15, 0x00ff },\n\t{ 16, 0x00ff },\n\t{ 17, 0x0000 },\n\t{ 18, 0x012c },\n\t{ 19, 0x002c },\n\t{ 20, 0x002c },\n\t{ 21, 0x002c },\n\t{ 22, 0x002c },\n\t{ 23, 0x0000 },\n\t{ 24, 0x0032 },\n\t{ 25, 0x0000 },\n\t{ 26, 0x0000 },\n\t{ 27, 0x0000 },\n\t{ 28, 0x0000 },\n\t{ 29, 0x0000 },\n\t{ 30, 0x0000 },\n\t{ 31, 0x0000 },\n\t{ 32, 0x0038 },\n\t{ 33, 0x000b },\n\t{ 34, 0x0032 },\n\t{ 35, 0x0000 },\n\t{ 36, 0x0008 },\n\t{ 37, 0x000c },\n\t{ 38, 0x0093 },\n\t{ 39, 0x00e9 },\n\t{ 40, 0x0000 },\n\t{ 41, 0x0000 },\n\t{ 42, 0x0000 },\n\t{ 43, 0x0000 },\n\t{ 44, 0x0033 },\n\t{ 45, 0x0010 },\n\t{ 46, 0x0010 },\n\t{ 47, 0x0100 },\n\t{ 48, 0x0100 },\n\t{ 49, 0x0002 },\n\t{ 50, 0x0001 },\n\t{ 51, 0x0001 },\n\t{ 52, 0x0039 },\n\t{ 53, 0x0039 },\n\t{ 54, 0x0039 },\n\t{ 55, 0x0039 },\n\t{ 56, 0x0001 },\n\t{ 57, 0x0001 },\n};\n\nstatic bool wm8978_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == WM8978_RESET;\n}\n\n \nstruct wm8978_priv {\n\tstruct regmap *regmap;\n\tunsigned int f_pllout;\n\tunsigned int f_mclk;\n\tunsigned int f_256fs;\n\tunsigned int f_opclk;\n\tint mclk_idx;\n\tenum wm8978_sysclk_src sysclk;\n};\n\nstatic const char *wm8978_companding[] = {\"Off\", \"NC\", \"u-law\", \"A-law\"};\nstatic const char *wm8978_eqmode[] = {\"Capture\", \"Playback\"};\nstatic const char *wm8978_bw[] = {\"Narrow\", \"Wide\"};\nstatic const char *wm8978_eq1[] = {\"80Hz\", \"105Hz\", \"135Hz\", \"175Hz\"};\nstatic const char *wm8978_eq2[] = {\"230Hz\", \"300Hz\", \"385Hz\", \"500Hz\"};\nstatic const char *wm8978_eq3[] = {\"650Hz\", \"850Hz\", \"1.1kHz\", \"1.4kHz\"};\nstatic const char *wm8978_eq4[] = {\"1.8kHz\", \"2.4kHz\", \"3.2kHz\", \"4.1kHz\"};\nstatic const char *wm8978_eq5[] = {\"5.3kHz\", \"6.9kHz\", \"9kHz\", \"11.7kHz\"};\nstatic const char *wm8978_alc3[] = {\"ALC\", \"Limiter\"};\nstatic const char *wm8978_alc1[] = {\"Off\", \"Right\", \"Left\", \"Both\"};\n\nstatic SOC_ENUM_SINGLE_DECL(adc_compand, WM8978_COMPANDING_CONTROL, 1,\n\t\t\t    wm8978_companding);\nstatic SOC_ENUM_SINGLE_DECL(dac_compand, WM8978_COMPANDING_CONTROL, 3,\n\t\t\t    wm8978_companding);\nstatic SOC_ENUM_SINGLE_DECL(eqmode, WM8978_EQ1, 8, wm8978_eqmode);\nstatic SOC_ENUM_SINGLE_DECL(eq1, WM8978_EQ1, 5, wm8978_eq1);\nstatic SOC_ENUM_SINGLE_DECL(eq2bw, WM8978_EQ2, 8, wm8978_bw);\nstatic SOC_ENUM_SINGLE_DECL(eq2, WM8978_EQ2, 5, wm8978_eq2);\nstatic SOC_ENUM_SINGLE_DECL(eq3bw, WM8978_EQ3, 8, wm8978_bw);\nstatic SOC_ENUM_SINGLE_DECL(eq3, WM8978_EQ3, 5, wm8978_eq3);\nstatic SOC_ENUM_SINGLE_DECL(eq4bw, WM8978_EQ4, 8, wm8978_bw);\nstatic SOC_ENUM_SINGLE_DECL(eq4, WM8978_EQ4, 5, wm8978_eq4);\nstatic SOC_ENUM_SINGLE_DECL(eq5, WM8978_EQ5, 5, wm8978_eq5);\nstatic SOC_ENUM_SINGLE_DECL(alc3, WM8978_ALC_CONTROL_3, 8, wm8978_alc3);\nstatic SOC_ENUM_SINGLE_DECL(alc1, WM8978_ALC_CONTROL_1, 7, wm8978_alc1);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, -1500, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(limiter_tlv, 0, 100, 0);\n\nstatic const struct snd_kcontrol_new wm8978_snd_controls[] = {\n\n\tSOC_SINGLE(\"Digital Loopback Switch\",\n\t\tWM8978_COMPANDING_CONTROL, 0, 1, 0),\n\n\tSOC_ENUM(\"ADC Companding\", adc_compand),\n\tSOC_ENUM(\"DAC Companding\", dac_compand),\n\n\tSOC_DOUBLE(\"DAC Inversion Switch\", WM8978_DAC_CONTROL, 0, 1, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"PCM Volume\",\n\t\tWM8978_LEFT_DAC_DIGITAL_VOLUME, WM8978_RIGHT_DAC_DIGITAL_VOLUME,\n\t\t0, 255, 0, digital_tlv),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\", WM8978_ADC_CONTROL, 8, 1, 0),\n\tSOC_SINGLE(\"High Pass Cut Off\", WM8978_ADC_CONTROL, 4, 7, 0),\n\tSOC_DOUBLE(\"ADC Inversion Switch\", WM8978_ADC_CONTROL, 0, 1, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"ADC Volume\",\n\t\tWM8978_LEFT_ADC_DIGITAL_VOLUME, WM8978_RIGHT_ADC_DIGITAL_VOLUME,\n\t\t0, 255, 0, digital_tlv),\n\n\tSOC_ENUM(\"Equaliser Function\", eqmode),\n\tSOC_ENUM(\"EQ1 Cut Off\", eq1),\n\tSOC_SINGLE_TLV(\"EQ1 Volume\", WM8978_EQ1,  0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"Equaliser EQ2 Bandwidth\", eq2bw),\n\tSOC_ENUM(\"EQ2 Cut Off\", eq2),\n\tSOC_SINGLE_TLV(\"EQ2 Volume\", WM8978_EQ2,  0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"Equaliser EQ3 Bandwidth\", eq3bw),\n\tSOC_ENUM(\"EQ3 Cut Off\", eq3),\n\tSOC_SINGLE_TLV(\"EQ3 Volume\", WM8978_EQ3,  0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"Equaliser EQ4 Bandwidth\", eq4bw),\n\tSOC_ENUM(\"EQ4 Cut Off\", eq4),\n\tSOC_SINGLE_TLV(\"EQ4 Volume\", WM8978_EQ4,  0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"EQ5 Cut Off\", eq5),\n\tSOC_SINGLE_TLV(\"EQ5 Volume\", WM8978_EQ5, 0, 24, 1, eq_tlv),\n\n\tSOC_SINGLE(\"DAC Playback Limiter Switch\",\n\t\tWM8978_DAC_LIMITER_1, 8, 1, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Decay\",\n\t\tWM8978_DAC_LIMITER_1, 4, 15, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Attack\",\n\t\tWM8978_DAC_LIMITER_1, 0, 15, 0),\n\n\tSOC_SINGLE(\"DAC Playback Limiter Threshold\",\n\t\tWM8978_DAC_LIMITER_2, 4, 7, 0),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Volume\",\n\t\tWM8978_DAC_LIMITER_2, 0, 12, 0, limiter_tlv),\n\n\tSOC_ENUM(\"ALC Enable Switch\", alc1),\n\tSOC_SINGLE(\"ALC Capture Min Gain\", WM8978_ALC_CONTROL_1, 0, 7, 0),\n\tSOC_SINGLE(\"ALC Capture Max Gain\", WM8978_ALC_CONTROL_1, 3, 7, 0),\n\n\tSOC_SINGLE(\"ALC Capture Hold\", WM8978_ALC_CONTROL_2, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Target\", WM8978_ALC_CONTROL_2, 0, 15, 0),\n\n\tSOC_ENUM(\"ALC Capture Mode\", alc3),\n\tSOC_SINGLE(\"ALC Capture Decay\", WM8978_ALC_CONTROL_3, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Attack\", WM8978_ALC_CONTROL_3, 0, 10, 0),\n\n\tSOC_SINGLE(\"ALC Capture Noise Gate Switch\", WM8978_NOISE_GATE, 3, 1, 0),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Threshold\",\n\t\tWM8978_NOISE_GATE, 0, 7, 0),\n\n\tSOC_DOUBLE_R(\"Capture PGA ZC Switch\",\n\t\tWM8978_LEFT_INP_PGA_CONTROL, WM8978_RIGHT_INP_PGA_CONTROL,\n\t\t7, 1, 0),\n\n\t \n\tSOC_DOUBLE_R(\"Headphone Playback ZC Switch\",\n\t\tWM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL, 7, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\",\n\t\tWM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL,\n\t\t0, 63, 0, spk_tlv),\n\n\t \n\tSOC_DOUBLE_R(\"Speaker Playback ZC Switch\",\n\t\tWM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL, 7, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Speaker Playback Volume\",\n\t\tWM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL,\n\t\t0, 63, 0, spk_tlv),\n\n\t \n\tSOC_DOUBLE_R(\"Line Playback Switch\",\n\t\tWM8978_OUT3_MIXER_CONTROL, WM8978_OUT4_MIXER_CONTROL, 6, 1, 1),\n\n\t \n\tSOC_DOUBLE_R(\"PGA Boost (+20dB)\",\n\t\tWM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,\n\t\t8, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"L2/R2 Boost Volume\",\n\t\tWM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,\n\t\t4, 7, 0, boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"Aux Boost Volume\",\n\t\tWM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,\n\t\t0, 7, 0, boost_tlv),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Input PGA Volume\",\n\t\tWM8978_LEFT_INP_PGA_CONTROL, WM8978_RIGHT_INP_PGA_CONTROL,\n\t\t0, 63, 0, inpga_tlv),\n\n\t \n\tSOC_DOUBLE_R(\"Headphone Switch\",\n\t\tWM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL, 6, 1, 1),\n\n\t \n\tSOC_DOUBLE_R(\"Speaker Switch\",\n\t\tWM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL, 6, 1, 1),\n\n\t \n\tSOC_SINGLE(\"DAC 128x Oversampling Switch\", WM8978_DAC_CONTROL,\n\t\t   5, 1, 0),\n\tSOC_SINGLE(\"ADC 128x Oversampling Switch\", WM8978_ADC_CONTROL,\n\t\t   5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8978_left_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8978_LEFT_MIXER_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8978_LEFT_MIXER_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8978_LEFT_MIXER_CONTROL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8978_right_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8978_RIGHT_MIXER_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8978_RIGHT_MIXER_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8978_RIGHT_MIXER_CONTROL, 0, 1, 0),\n};\n\n \n\n \nstatic const struct snd_kcontrol_new wm8978_left_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"L2 Switch\", WM8978_INPUT_CONTROL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8978_INPUT_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8978_INPUT_CONTROL, 0, 1, 0),\n};\nstatic const struct snd_kcontrol_new wm8978_right_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"R2 Switch\", WM8978_INPUT_CONTROL, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8978_INPUT_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8978_INPUT_CONTROL, 4, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8978_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left HiFi Playback\",\n\t\t\t WM8978_POWER_MANAGEMENT_3, 0, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right HiFi Playback\",\n\t\t\t WM8978_POWER_MANAGEMENT_3, 1, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left HiFi Capture\",\n\t\t\t WM8978_POWER_MANAGEMENT_2, 0, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right HiFi Capture\",\n\t\t\t WM8978_POWER_MANAGEMENT_2, 1, 0),\n\n\t \n\tSOC_MIXER_ARRAY(\"Left Output Mixer\", WM8978_POWER_MANAGEMENT_3,\n\t\t\t2, 0, wm8978_left_out_mixer),\n\tSOC_MIXER_ARRAY(\"Right Output Mixer\", WM8978_POWER_MANAGEMENT_3,\n\t\t\t3, 0, wm8978_right_out_mixer),\n\n\tSOC_MIXER_ARRAY(\"Left Input Mixer\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t2, 0, wm8978_left_input_mixer),\n\tSOC_MIXER_ARRAY(\"Right Input Mixer\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t3, 0, wm8978_right_input_mixer),\n\n\tSND_SOC_DAPM_PGA(\"Left Boost Mixer\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t 4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Boost Mixer\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Capture PGA\", WM8978_LEFT_INP_PGA_CONTROL,\n\t\t\t 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Capture PGA\", WM8978_RIGHT_INP_PGA_CONTROL,\n\t\t\t 6, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Headphone Out\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t 7, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Headphone Out\", WM8978_POWER_MANAGEMENT_2,\n\t\t\t 8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Speaker Out\", WM8978_POWER_MANAGEMENT_3,\n\t\t\t 6, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Speaker Out\", WM8978_POWER_MANAGEMENT_3,\n\t\t\t 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"OUT4 VMID\", WM8978_POWER_MANAGEMENT_3,\n\t\t\t   8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MICBIAS(\"Mic Bias\", WM8978_POWER_MANAGEMENT_1, 4, 0),\n\n\tSND_SOC_DAPM_INPUT(\"LMICN\"),\n\tSND_SOC_DAPM_INPUT(\"LMICP\"),\n\tSND_SOC_DAPM_INPUT(\"RMICN\"),\n\tSND_SOC_DAPM_INPUT(\"RMICP\"),\n\tSND_SOC_DAPM_INPUT(\"LAUX\"),\n\tSND_SOC_DAPM_INPUT(\"RAUX\"),\n\tSND_SOC_DAPM_INPUT(\"L2\"),\n\tSND_SOC_DAPM_INPUT(\"R2\"),\n\tSND_SOC_DAPM_OUTPUT(\"LHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"LSPK\"),\n\tSND_SOC_DAPM_OUTPUT(\"RSPK\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8978_dapm_routes[] = {\n\t \n\t{\"Right Output Mixer\", \"PCM Playback Switch\", \"Right DAC\"},\n\t{\"Right Output Mixer\", \"Aux Playback Switch\", \"RAUX\"},\n\t{\"Right Output Mixer\", \"Line Bypass Switch\", \"Right Boost Mixer\"},\n\n\t{\"Left Output Mixer\", \"PCM Playback Switch\", \"Left DAC\"},\n\t{\"Left Output Mixer\", \"Aux Playback Switch\", \"LAUX\"},\n\t{\"Left Output Mixer\", \"Line Bypass Switch\", \"Left Boost Mixer\"},\n\n\t \n\t{\"Right Headphone Out\", NULL, \"Right Output Mixer\"},\n\t{\"RHP\", NULL, \"Right Headphone Out\"},\n\n\t{\"Left Headphone Out\", NULL, \"Left Output Mixer\"},\n\t{\"LHP\", NULL, \"Left Headphone Out\"},\n\n\t{\"Right Speaker Out\", NULL, \"Right Output Mixer\"},\n\t{\"RSPK\", NULL, \"Right Speaker Out\"},\n\n\t{\"Left Speaker Out\", NULL, \"Left Output Mixer\"},\n\t{\"LSPK\", NULL, \"Left Speaker Out\"},\n\n\t \n\t{\"Right ADC\", NULL, \"Right Boost Mixer\"},\n\n\t{\"Right Boost Mixer\", NULL, \"RAUX\"},\n\t{\"Right Boost Mixer\", NULL, \"Right Capture PGA\"},\n\t{\"Right Boost Mixer\", NULL, \"R2\"},\n\n\t{\"Left ADC\", NULL, \"Left Boost Mixer\"},\n\n\t{\"Left Boost Mixer\", NULL, \"LAUX\"},\n\t{\"Left Boost Mixer\", NULL, \"Left Capture PGA\"},\n\t{\"Left Boost Mixer\", NULL, \"L2\"},\n\n\t \n\t{\"Right Capture PGA\", NULL, \"Right Input Mixer\"},\n\t{\"Left Capture PGA\", NULL, \"Left Input Mixer\"},\n\n\t{\"Right Input Mixer\", \"R2 Switch\", \"R2\"},\n\t{\"Right Input Mixer\", \"MicN Switch\", \"RMICN\"},\n\t{\"Right Input Mixer\", \"MicP Switch\", \"RMICP\"},\n\n\t{\"Left Input Mixer\", \"L2 Switch\", \"L2\"},\n\t{\"Left Input Mixer\", \"MicN Switch\", \"LMICN\"},\n\t{\"Left Input Mixer\", \"MicP Switch\", \"LMICP\"},\n};\n\n \nstruct wm8978_pll_div {\n\tu32 k;\n\tu8 n;\n\tu8 div2;\n};\n\n#define FIXED_PLL_SIZE (1 << 24)\n\nstatic void pll_factors(struct snd_soc_component *component,\n\t\tstruct wm8978_pll_div *pll_div, unsigned int target, unsigned int source)\n{\n\tu64 k_part;\n\tunsigned int k, n_div, n_mod;\n\n\tn_div = target / source;\n\tif (n_div < 6) {\n\t\tsource >>= 1;\n\t\tpll_div->div2 = 1;\n\t\tn_div = target / source;\n\t} else {\n\t\tpll_div->div2 = 0;\n\t}\n\n\tif (n_div < 6 || n_div > 12)\n\t\tdev_warn(component->dev,\n\t\t\t \"WM8978 N value exceeds recommended range! N = %u\\n\",\n\t\t\t n_div);\n\n\tpll_div->n = n_div;\n\tn_mod = target - source * n_div;\n\tk_part = FIXED_PLL_SIZE * (long long)n_mod + source / 2;\n\n\tdo_div(k_part, source);\n\n\tk = k_part & 0xFFFFFFFF;\n\n\tpll_div->k = k;\n}\n\n \nstatic const int mclk_numerator[]\t= {1, 3, 2, 3, 4, 6, 8, 12};\nstatic const int mclk_denominator[]\t= {1, 2, 1, 1, 1, 1, 1, 1};\n\n \nstatic int wm8978_enum_mclk(unsigned int f_out, unsigned int f_mclk,\n\t\t\t    unsigned int *f_pllout)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {\n\t\tunsigned int f_pllout_x4 = 4 * f_out * mclk_numerator[i] /\n\t\t\tmclk_denominator[i];\n\t\tif (3 * f_mclk <= f_pllout_x4 && f_pllout_x4 < 13 * f_mclk) {\n\t\t\t*f_pllout = f_pllout_x4 / 4;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int wm8978_configure_pll(struct snd_soc_component *component)\n{\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\tstruct wm8978_pll_div pll_div;\n\tunsigned int f_opclk = wm8978->f_opclk, f_mclk = wm8978->f_mclk,\n\t\tf_256fs = wm8978->f_256fs;\n\tunsigned int f2;\n\n\tif (!f_mclk)\n\t\treturn -EINVAL;\n\n\tif (f_opclk) {\n\t\tunsigned int opclk_div;\n\t\t \n\t\twm8978->mclk_idx = -1;\n\n\t\t \n\t\tif (16 * f_opclk < 3 * f_mclk || 4 * f_opclk >= 13 * f_mclk)\n\t\t\treturn -EINVAL;\n\n\t\tif (4 * f_opclk < 3 * f_mclk)\n\t\t\t \n\t\t\topclk_div = DIV_ROUND_UP(3 * f_mclk / 4, f_opclk);\n\t\telse\n\t\t\topclk_div = 1;\n\n\t\tdev_dbg(component->dev, \"%s: OPCLKDIV=%d\\n\", __func__, opclk_div);\n\n\t\tsnd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 0x30,\n\t\t\t\t    (opclk_div - 1) << 4);\n\n\t\twm8978->f_pllout = f_opclk * opclk_div;\n\t} else if (f_256fs) {\n\t\t \n\t\tint idx = wm8978_enum_mclk(f_256fs, f_mclk, &wm8978->f_pllout);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\twm8978->mclk_idx = idx;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tf2 = wm8978->f_pllout * 4;\n\n\tdev_dbg(component->dev, \"%s: f_MCLK=%uHz, f_PLLOUT=%uHz\\n\", __func__,\n\t\twm8978->f_mclk, wm8978->f_pllout);\n\n\tpll_factors(component, &pll_div, f2, wm8978->f_mclk);\n\n\tdev_dbg(component->dev, \"%s: calculated PLL N=0x%x, K=0x%x, div2=%d\\n\",\n\t\t__func__, pll_div.n, pll_div.k, pll_div.div2);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0);\n\n\tsnd_soc_component_write(component, WM8978_PLL_N, (pll_div.div2 << 4) | pll_div.n);\n\tsnd_soc_component_write(component, WM8978_PLL_K1, pll_div.k >> 18);\n\tsnd_soc_component_write(component, WM8978_PLL_K2, (pll_div.k >> 9) & 0x1ff);\n\tsnd_soc_component_write(component, WM8978_PLL_K3, pll_div.k & 0x1ff);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);\n\n\tif (f_opclk)\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 7, 4);\n\n\treturn 0;\n}\n\n \nstatic int wm8978_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\t\t\t int div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (div_id) {\n\tcase WM8978_OPCLKRATE:\n\t\twm8978->f_opclk = div;\n\n\t\tif (wm8978->f_mclk)\n\t\t\t \n\t\t\tret = wm8978_configure_pll(component);\n\t\tbreak;\n\tcase WM8978_BCLKDIV:\n\t\tif (div & ~0x1c)\n\t\t\treturn -EINVAL;\n\t\tsnd_soc_component_update_bits(component, WM8978_CLOCKING, 0x1c, div);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"%s: ID %d, value %u\\n\", __func__, div_id, div);\n\n\treturn ret;\n}\n\n \nstatic int wm8978_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tdev_dbg(component->dev, \"%s: ID %d, freq %u\\n\", __func__, clk_id, freq);\n\n\tif (freq) {\n\t\twm8978->f_mclk = freq;\n\n\t\t \n\t\tif (wm8978->f_opclk)\n\t\t\tret = wm8978_configure_pll(component);\n\n\t\t \n\n\t\tif (!ret)\n\t\t\twm8978->sysclk = clk_id;\n\t}\n\n\tif (wm8978->sysclk == WM8978_PLL && (!freq || clk_id == WM8978_MCLK)) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_CLOCKING, 0x100, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 7, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0);\n\t\twm8978->sysclk = WM8978_MCLK;\n\t\twm8978->f_pllout = 0;\n\t\twm8978->f_opclk = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int wm8978_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\t \n\tu16 iface = snd_soc_component_read(component, WM8978_AUDIO_INTERFACE) & ~0x198;\n\tu16 clk = snd_soc_component_read(component, WM8978_CLOCKING);\n\n\tdev_dbg(component->dev, \"%s\\n\", __func__);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tclk |= 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tclk &= ~1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x10;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x18;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x180;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x100;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8978_AUDIO_INTERFACE, iface);\n\tsnd_soc_component_write(component, WM8978_CLOCKING, clk);\n\n\treturn 0;\n}\n\n \nstatic int wm8978_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\t \n\tu16 iface_ctl = snd_soc_component_read(component, WM8978_AUDIO_INTERFACE) & ~0x60;\n\t \n\tu16 add_ctl = snd_soc_component_read(component, WM8978_ADDITIONAL_CONTROL) & ~0xe;\n\tu16 clking = snd_soc_component_read(component, WM8978_CLOCKING);\n\tenum wm8978_sysclk_src current_clk_id = (clking & 0x100) ?\n\t\tWM8978_PLL : WM8978_MCLK;\n\tunsigned int f_sel, diff, diff_best = INT_MAX;\n\tint i, best = 0;\n\n\tif (!wm8978->f_mclk)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface_ctl |= 0x20;\n\t\tbreak;\n\tcase 24:\n\t\tiface_ctl |= 0x40;\n\t\tbreak;\n\tcase 32:\n\t\tiface_ctl |= 0x60;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tadd_ctl |= 0x5 << 1;\n\t\tbreak;\n\tcase 11025:\n\t\tadd_ctl |= 0x4 << 1;\n\t\tbreak;\n\tcase 16000:\n\t\tadd_ctl |= 0x3 << 1;\n\t\tbreak;\n\tcase 22050:\n\t\tadd_ctl |= 0x2 << 1;\n\t\tbreak;\n\tcase 32000:\n\t\tadd_ctl |= 0x1 << 1;\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\t}\n\n\t \n\twm8978->f_256fs = params_rate(params) * 256;\n\n\tif (wm8978->sysclk == WM8978_MCLK) {\n\t\twm8978->mclk_idx = -1;\n\t\tf_sel = wm8978->f_mclk;\n\t} else {\n\t\tif (!wm8978->f_opclk) {\n\t\t\t \n\t\t\tint ret = wm8978_configure_pll(component);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tf_sel = wm8978->f_pllout;\n\t}\n\n\tif (wm8978->mclk_idx < 0) {\n\t\t \n\t\tif (f_sel < wm8978->f_256fs || f_sel > 12 * wm8978->f_256fs)\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {\n\t\t\tdiff = abs(wm8978->f_256fs * 3 -\n\t\t\t\t   f_sel * 3 * mclk_denominator[i] / mclk_numerator[i]);\n\n\t\t\tif (diff < diff_best) {\n\t\t\t\tdiff_best = diff;\n\t\t\t\tbest = i;\n\t\t\t}\n\n\t\t\tif (!diff)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tbest = wm8978->mclk_idx;\n\t\tdiff = 0;\n\t}\n\n\tif (diff)\n\t\tdev_warn(component->dev, \"Imprecise sampling rate: %uHz%s\\n\",\n\t\t\tf_sel * mclk_denominator[best] / mclk_numerator[best] / 256,\n\t\t\twm8978->sysclk == WM8978_MCLK ?\n\t\t\t\", consider using PLL\" : \"\");\n\n\tdev_dbg(component->dev, \"%s: width %d, rate %u, MCLK divisor #%d\\n\", __func__,\n\t\tparams_width(params), params_rate(params), best);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8978_CLOCKING, 0xe0, best << 5);\n\n\tsnd_soc_component_write(component, WM8978_AUDIO_INTERFACE, iface_ctl);\n\tsnd_soc_component_write(component, WM8978_ADDITIONAL_CONTROL, add_ctl);\n\n\tif (wm8978->sysclk != current_clk_id) {\n\t\tif (wm8978->sysclk == WM8978_PLL)\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8978_CLOCKING,\n\t\t\t\t\t    0x100, 0x100);\n\t\telse\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8978_CLOCKING, 0x100, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8978_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tdev_dbg(component->dev, \"%s: %d\\n\", __func__, mute);\n\n\tif (mute)\n\t\tsnd_soc_component_update_bits(component, WM8978_DAC_CONTROL, 0x40, 0x40);\n\telse\n\t\tsnd_soc_component_update_bits(component, WM8978_DAC_CONTROL, 0x40, 0);\n\n\treturn 0;\n}\n\nstatic int wm8978_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tu16 power1 = snd_soc_component_read(component, WM8978_POWER_MANAGEMENT_1) & ~3;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tpower1 |= 1;   \n\t\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, power1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tpower1 |= 0xc;\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1,\n\t\t\t\t      power1 | 0x3);\n\t\t\tmdelay(100);\n\t\t}\n\n\t\tpower1 |= 0x2;   \n\t\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, power1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, ~0x20, 0);\n\t\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_3, 0);\n\t\tbreak;\n\t}\n\n\tdev_dbg(component->dev, \"%s: %d, %x\\n\", __func__, level, power1);\n\n\treturn 0;\n}\n\n#define WM8978_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8978_dai_ops = {\n\t.hw_params\t= wm8978_hw_params,\n\t.mute_stream\t= wm8978_mute,\n\t.set_fmt\t= wm8978_set_dai_fmt,\n\t.set_clkdiv\t= wm8978_set_dai_clkdiv,\n\t.set_sysclk\t= wm8978_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\n \nstatic struct snd_soc_dai_driver wm8978_dai = {\n\t.name = \"wm8978-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8978_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8978_FORMATS,\n\t},\n\t.ops = &wm8978_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8978_suspend(struct snd_soc_component *component)\n{\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\t \n\tsnd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, 0);\n\n\tregcache_mark_dirty(wm8978->regmap);\n\n\treturn 0;\n}\n\nstatic int wm8978_resume(struct snd_soc_component *component)\n{\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\n\t \n\tregcache_sync(wm8978->regmap);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\tif (wm8978->f_pllout)\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);\n\n\treturn 0;\n}\n\n \nstatic const int update_reg[] = {\n\tWM8978_LEFT_DAC_DIGITAL_VOLUME,\n\tWM8978_RIGHT_DAC_DIGITAL_VOLUME,\n\tWM8978_LEFT_ADC_DIGITAL_VOLUME,\n\tWM8978_RIGHT_ADC_DIGITAL_VOLUME,\n\tWM8978_LEFT_INP_PGA_CONTROL,\n\tWM8978_RIGHT_INP_PGA_CONTROL,\n\tWM8978_LOUT1_HP_CONTROL,\n\tWM8978_ROUT1_HP_CONTROL,\n\tWM8978_LOUT2_SPK_CONTROL,\n\tWM8978_ROUT2_SPK_CONTROL,\n};\n\nstatic int wm8978_probe(struct snd_soc_component *component)\n{\n\tstruct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\t \n\twm8978->sysclk = WM8978_PLL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(update_reg); i++)\n\t\tsnd_soc_component_update_bits(component, update_reg[i], 0x100, 0x100);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8978 = {\n\t.probe\t\t\t= wm8978_probe,\n\t.suspend\t\t= wm8978_suspend,\n\t.resume\t\t\t= wm8978_resume,\n\t.set_bias_level\t\t= wm8978_set_bias_level,\n\t.controls\t\t= wm8978_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8978_snd_controls),\n\t.dapm_widgets\t\t= wm8978_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8978_dapm_widgets),\n\t.dapm_routes\t\t= wm8978_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8978_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8978_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8978_MAX_REGISTER,\n\t.volatile_reg = wm8978_volatile,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8978_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8978_reg_defaults),\n};\n\nstatic int wm8978_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8978_priv *wm8978;\n\tint ret;\n\n\twm8978 = devm_kzalloc(&i2c->dev, sizeof(struct wm8978_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8978 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8978->regmap = devm_regmap_init_i2c(i2c, &wm8978_regmap_config);\n\tif (IS_ERR(wm8978->regmap)) {\n\t\tret = PTR_ERR(wm8978->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8978);\n\n\t \n\tret = regmap_write(wm8978->regmap, WM8978_RESET, 0);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8978, &wm8978_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id wm8978_i2c_id[] = {\n\t{ \"wm8978\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8978_i2c_id);\n\nstatic const struct of_device_id wm8978_of_match[] = {\n\t{ .compatible = \"wlf,wm8978\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8978_of_match);\n\nstatic struct i2c_driver wm8978_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8978\",\n\t\t.of_match_table = wm8978_of_match,\n\t},\n\t.probe = wm8978_i2c_probe,\n\t.id_table = wm8978_i2c_id,\n};\n\nmodule_i2c_driver(wm8978_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8978 codec driver\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}