{
  "module_name": "wm8731.c",
  "hash_id": "4bd78724102692a6917d897e64f9150fa6c996756eb80d70d8123cb6e7f87bb4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8731.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/clk.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8731.h\"\n\nstatic const char *wm8731_supply_names[WM8731_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"HPVDD\",\n\t\"DCVDD\",\n\t\"DBVDD\",\n};\n\n \nstatic const struct reg_default wm8731_reg_defaults[] = {\n\t{ 0, 0x0097 },\n\t{ 1, 0x0097 },\n\t{ 2, 0x0079 },\n\t{ 3, 0x0079 },\n\t{ 4, 0x000a },\n\t{ 5, 0x0008 },\n\t{ 6, 0x009f },\n\t{ 7, 0x000a },\n\t{ 8, 0x0000 },\n\t{ 9, 0x0000 },\n};\n\nstatic bool wm8731_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == WM8731_RESET;\n}\n\n#define wm8731_reset(m)\tregmap_write(m, WM8731_RESET, 0)\n\nstatic const char *wm8731_input_select[] = {\"Line In\", \"Mic\"};\n\nstatic SOC_ENUM_SINGLE_DECL(wm8731_insel_enum,\n\t\t\t    WM8731_APANA, 2, wm8731_input_select);\n\nstatic int wm8731_deemph[] = { 0, 32000, 44100, 48000 };\n\nstatic int wm8731_set_deemph(struct snd_soc_component *component)\n{\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (wm8731->deemph) {\n\t\tbest = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(wm8731_deemph); i++) {\n\t\t\tif (abs(wm8731_deemph[i] - wm8731->playback_fs) <\n\t\t\t    abs(wm8731_deemph[best] - wm8731->playback_fs))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = best << 1;\n\t} else {\n\t\tbest = 0;\n\t\tval = 0;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d (%dHz)\\n\",\n\t\tbest, wm8731_deemph[best]);\n\n\treturn snd_soc_component_update_bits(component, WM8731_APDIGI, 0x6, val);\n}\n\nstatic int wm8731_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8731->deemph;\n\n\treturn 0;\n}\n\nstatic int wm8731_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\tint ret = 0;\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wm8731->lock);\n\tif (wm8731->deemph != deemph) {\n\t\twm8731->deemph = deemph;\n\n\t\twm8731_set_deemph(component);\n\n\t\tret = 1;\n\t}\n\tmutex_unlock(&wm8731->lock);\n\n\treturn ret;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(in_tlv, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(sidetone_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 2000, 0);\n\nstatic const struct snd_kcontrol_new wm8731_snd_controls[] = {\n\nSOC_DOUBLE_R_TLV(\"Master Playback Volume\", WM8731_LOUT1V, WM8731_ROUT1V,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Master Playback ZC Switch\", WM8731_LOUT1V, WM8731_ROUT1V,\n\t7, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8731_LINVOL, WM8731_RINVOL, 0, 31, 0,\n\t\t in_tlv),\nSOC_DOUBLE_R(\"Line Capture Switch\", WM8731_LINVOL, WM8731_RINVOL, 7, 1, 1),\n\nSOC_SINGLE_TLV(\"Mic Boost Volume\", WM8731_APANA, 0, 1, 0, mic_tlv),\nSOC_SINGLE(\"Mic Capture Switch\", WM8731_APANA, 1, 1, 1),\n\nSOC_SINGLE_TLV(\"Sidetone Playback Volume\", WM8731_APANA, 6, 3, 1,\n\t       sidetone_tlv),\n\nSOC_SINGLE(\"ADC High Pass Filter Switch\", WM8731_APDIGI, 0, 1, 1),\nSOC_SINGLE(\"Store DC Offset Switch\", WM8731_APDIGI, 4, 1, 0),\n\nSOC_SINGLE_BOOL_EXT(\"Playback Deemphasis Switch\", 0,\n\t\t    wm8731_get_deemph, wm8731_put_deemph),\n};\n\n \nstatic const struct snd_kcontrol_new wm8731_output_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8731_APANA, 3, 1, 0),\nSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", WM8731_APANA, 5, 1, 0),\nSOC_DAPM_SINGLE(\"HiFi Playback Switch\", WM8731_APANA, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8731_input_mux_controls =\nSOC_DAPM_ENUM(\"Input Select\", wm8731_insel_enum);\n\nstatic const struct snd_soc_dapm_widget wm8731_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"ACTIVE\",WM8731_ACTIVE, 0, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"OSC\", WM8731_PWR, 5, 1, NULL, 0),\nSND_SOC_DAPM_MIXER(\"Output Mixer\", WM8731_PWR, 4, 1,\n\t&wm8731_output_mixer_controls[0],\n\tARRAY_SIZE(wm8731_output_mixer_controls)),\nSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", WM8731_PWR, 3, 1),\nSND_SOC_DAPM_OUTPUT(\"LOUT\"),\nSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT\"),\nSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\nSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", WM8731_PWR, 2, 1),\nSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0, &wm8731_input_mux_controls),\nSND_SOC_DAPM_PGA(\"Line Input\", WM8731_PWR, 0, 1, NULL, 0),\nSND_SOC_DAPM_MICBIAS(\"Mic Bias\", WM8731_PWR, 1, 1),\nSND_SOC_DAPM_INPUT(\"MICIN\"),\nSND_SOC_DAPM_INPUT(\"RLINEIN\"),\nSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n};\n\nstatic int wm8731_check_osc(struct snd_soc_dapm_widget *source,\n\t\t\t    struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\n\treturn wm8731->sysclk_type == WM8731_SYSCLK_XTAL;\n}\n\nstatic const struct snd_soc_dapm_route wm8731_intercon[] = {\n\t{\"DAC\", NULL, \"OSC\", wm8731_check_osc},\n\t{\"ADC\", NULL, \"OSC\", wm8731_check_osc},\n\t{\"DAC\", NULL, \"ACTIVE\"},\n\t{\"ADC\", NULL, \"ACTIVE\"},\n\n\t \n\t{\"Output Mixer\", \"Line Bypass Switch\", \"Line Input\"},\n\t{\"Output Mixer\", \"HiFi Playback Switch\", \"DAC\"},\n\t{\"Output Mixer\", \"Mic Sidetone Switch\", \"Mic Bias\"},\n\n\t \n\t{\"RHPOUT\", NULL, \"Output Mixer\"},\n\t{\"ROUT\", NULL, \"Output Mixer\"},\n\t{\"LHPOUT\", NULL, \"Output Mixer\"},\n\t{\"LOUT\", NULL, \"Output Mixer\"},\n\n\t \n\t{\"Input Mux\", \"Line In\", \"Line Input\"},\n\t{\"Input Mux\", \"Mic\", \"Mic Bias\"},\n\t{\"ADC\", NULL, \"Input Mux\"},\n\n\t \n\t{\"Line Input\", NULL, \"LLINEIN\"},\n\t{\"Line Input\", NULL, \"RLINEIN\"},\n\t{\"Mic Bias\", NULL, \"MICIN\"},\n};\n\nstruct _coeff_div {\n\tu32 mclk;\n\tu32 rate;\n\tu16 fs;\n\tu8 sr:4;\n\tu8 bosr:1;\n\tu8 usb:1;\n};\n\n \nstatic const struct _coeff_div coeff_div[] = {\n\t \n\t{12288000, 48000, 256, 0x0, 0x0, 0x0},\n\t{18432000, 48000, 384, 0x0, 0x1, 0x0},\n\t{12000000, 48000, 250, 0x0, 0x0, 0x1},\n\n\t \n\t{12288000, 32000, 384, 0x6, 0x0, 0x0},\n\t{18432000, 32000, 576, 0x6, 0x1, 0x0},\n\t{12000000, 32000, 375, 0x6, 0x0, 0x1},\n\n\t \n\t{12288000, 8000, 1536, 0x3, 0x0, 0x0},\n\t{18432000, 8000, 2304, 0x3, 0x1, 0x0},\n\t{11289600, 8000, 1408, 0xb, 0x0, 0x0},\n\t{16934400, 8000, 2112, 0xb, 0x1, 0x0},\n\t{12000000, 8000, 1500, 0x3, 0x0, 0x1},\n\n\t \n\t{12288000, 96000, 128, 0x7, 0x0, 0x0},\n\t{18432000, 96000, 192, 0x7, 0x1, 0x0},\n\t{12000000, 96000, 125, 0x7, 0x0, 0x1},\n\n\t \n\t{11289600, 44100, 256, 0x8, 0x0, 0x0},\n\t{16934400, 44100, 384, 0x8, 0x1, 0x0},\n\t{12000000, 44100, 272, 0x8, 0x1, 0x1},\n\n\t \n\t{11289600, 88200, 128, 0xf, 0x0, 0x0},\n\t{16934400, 88200, 192, 0xf, 0x1, 0x0},\n\t{12000000, 88200, 136, 0xf, 0x1, 0x1},\n};\n\n \nstatic const unsigned int wm8731_rates_12000000[] = {\n\t8000, 32000, 44100, 48000, 96000, 88200,\n};\n\nstatic const unsigned int wm8731_rates_12288000_18432000[] = {\n\t8000, 32000, 48000, 96000,\n};\n\nstatic const unsigned int wm8731_rates_11289600_16934400[] = {\n\t8000, 44100, 88200,\n};\n\nstatic const struct snd_pcm_hw_constraint_list wm8731_constraints_12000000 = {\n\t.list = wm8731_rates_12000000,\n\t.count = ARRAY_SIZE(wm8731_rates_12000000),\n};\n\nstatic const\nstruct snd_pcm_hw_constraint_list wm8731_constraints_12288000_18432000 = {\n\t.list = wm8731_rates_12288000_18432000,\n\t.count = ARRAY_SIZE(wm8731_rates_12288000_18432000),\n};\n\nstatic const\nstruct snd_pcm_hw_constraint_list wm8731_constraints_11289600_16934400 = {\n\t.list = wm8731_rates_11289600_16934400,\n\t.count = ARRAY_SIZE(wm8731_rates_11289600_16934400),\n};\n\nstatic inline int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int wm8731_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8731_IFACE) & 0xfff3;\n\tint i = get_coeff(wm8731->sysclk, params_rate(params));\n\tu16 srate = (coeff_div[i].sr << 2) |\n\t\t(coeff_div[i].bosr << 1) | coeff_div[i].usb;\n\n\twm8731->playback_fs = params_rate(params);\n\n\tsnd_soc_component_write(component, WM8731_SRATE, srate);\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x0008;\n\t\tbreak;\n\tcase 32:\n\t\tiface |= 0x000c;\n\t\tbreak;\n\t}\n\n\twm8731_set_deemph(component);\n\n\tsnd_soc_component_write(component, WM8731_IFACE, iface);\n\treturn 0;\n}\n\nstatic int wm8731_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8731_APDIGI) & 0xfff7;\n\n\tif (mute)\n\t\tsnd_soc_component_write(component, WM8731_APDIGI, mute_reg | 0x8);\n\telse\n\t\tsnd_soc_component_write(component, WM8731_APDIGI, mute_reg);\n\treturn 0;\n}\n\nstatic int wm8731_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM8731_SYSCLK_XTAL:\n\tcase WM8731_SYSCLK_MCLK:\n\t\tif (wm8731->mclk && clk_set_rate(wm8731->mclk, freq))\n\t\t\treturn -EINVAL;\n\t\twm8731->sysclk_type = clk_id;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 0:\n\t\twm8731->constraints = NULL;\n\t\tbreak;\n\tcase 12000000:\n\t\twm8731->constraints = &wm8731_constraints_12000000;\n\t\tbreak;\n\tcase 12288000:\n\tcase 18432000:\n\t\twm8731->constraints = &wm8731_constraints_12288000_18432000;\n\t\tbreak;\n\tcase 16934400:\n\tcase 11289600:\n\t\twm8731->constraints = &wm8731_constraints_11289600_16934400;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twm8731->sysclk = freq;\n\n\tsnd_soc_dapm_sync(dapm);\n\n\treturn 0;\n}\n\n\nstatic int wm8731_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface |= 0x0040;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x0013;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x0003;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0090;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8731_IFACE, iface);\n\treturn 0;\n}\n\nstatic int wm8731_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tu16 reg;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tif (wm8731->mclk) {\n\t\t\tret = clk_prepare_enable(wm8731->mclk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8731->supplies),\n\t\t\t\t\t\t    wm8731->supplies);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\tregcache_sync(wm8731->regmap);\n\t\t}\n\n\t\t \n\t\treg = snd_soc_component_read(component, WM8731_PWR) & 0xff7f;\n\t\tsnd_soc_component_write(component, WM8731_PWR, reg | 0x0040);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (wm8731->mclk)\n\t\t\tclk_disable_unprepare(wm8731->mclk);\n\t\tsnd_soc_component_write(component, WM8731_PWR, 0xffff);\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8731->supplies),\n\t\t\t\t       wm8731->supplies);\n\t\tregcache_mark_dirty(wm8731->regmap);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int wm8731_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct wm8731_priv *wm8731 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (wm8731->constraints)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   wm8731->constraints);\n\n\treturn 0;\n}\n\n#define WM8731_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8731_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8731_dai_ops = {\n\t.startup\t= wm8731_startup,\n\t.hw_params\t= wm8731_hw_params,\n\t.mute_stream\t= wm8731_mute,\n\t.set_sysclk\t= wm8731_set_dai_sysclk,\n\t.set_fmt\t= wm8731_set_dai_fmt,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8731_dai = {\n\t.name = \"wm8731-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8731_RATES,\n\t\t.formats = WM8731_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8731_RATES,\n\t\t.formats = WM8731_FORMATS,},\n\t.ops = &wm8731_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8731 = {\n\t.set_bias_level\t\t= wm8731_set_bias_level,\n\t.controls\t\t= wm8731_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8731_snd_controls),\n\t.dapm_widgets\t\t= wm8731_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8731_dapm_widgets),\n\t.dapm_routes\t\t= wm8731_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8731_intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint wm8731_init(struct device *dev, struct wm8731_priv *wm8731)\n{\n\tint ret = 0, i;\n\n\twm8731->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(wm8731->mclk)) {\n\t\tret = PTR_ERR(wm8731->mclk);\n\t\tif (ret == -ENOENT) {\n\t\t\twm8731->mclk = NULL;\n\t\t\tdev_warn(dev, \"Assuming static MCLK\\n\");\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to get MCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmutex_init(&wm8731->lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8731->supplies); i++)\n\t\twm8731->supplies[i].supply = wm8731_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(wm8731->supplies),\n\t\t\t\t wm8731->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8731->supplies),\n\t\t\t\t    wm8731->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8731_reset(wm8731->regmap);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_regulator_enable;\n\t}\n\n\t \n\tregmap_write(wm8731->regmap, WM8731_PWR, 0x7f);\n\n\t \n\tregmap_update_bits(wm8731->regmap, WM8731_LOUT1V, 0x100, 0);\n\tregmap_update_bits(wm8731->regmap, WM8731_ROUT1V, 0x100, 0);\n\tregmap_update_bits(wm8731->regmap, WM8731_LINVOL, 0x100, 0);\n\tregmap_update_bits(wm8731->regmap, WM8731_RINVOL, 0x100, 0);\n\n\t \n\tregmap_update_bits(wm8731->regmap, WM8731_APANA, 0x8, 0);\n\n\tregcache_mark_dirty(wm8731->regmap);\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t&soc_component_dev_wm8731, &wm8731_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\tgoto err_regulator_enable;\n\t}\n\n\treturn 0;\n\nerr_regulator_enable:\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(wm8731->supplies), wm8731->supplies);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8731_init);\n\nconst struct regmap_config wm8731_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8731_RESET,\n\t.volatile_reg = wm8731_volatile,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8731_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8731_reg_defaults),\n};\nEXPORT_SYMBOL_GPL(wm8731_regmap);\n\nMODULE_DESCRIPTION(\"ASoC WM8731 driver\");\nMODULE_AUTHOR(\"Richard Purdie\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}