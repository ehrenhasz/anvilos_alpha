{
  "module_name": "max98373-i2c.c",
  "hash_id": "90ae0ee5493d6f087e2a3e01743c53a06f7f21878ace654788ce1bc8a66439fd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98373-i2c.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"max98373.h\"\n\nstatic const u32 max98373_i2c_cache_reg[] = {\n\tMAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK,\n\tMAX98373_R2055_MEAS_ADC_THERM_CH_READBACK,\n\tMAX98373_R20B6_BDE_CUR_STATE_READBACK,\n};\n\nstatic struct reg_default max98373_reg[] = {\n\t{MAX98373_R2000_SW_RESET, 0x00},\n\t{MAX98373_R2001_INT_RAW1, 0x00},\n\t{MAX98373_R2002_INT_RAW2, 0x00},\n\t{MAX98373_R2003_INT_RAW3, 0x00},\n\t{MAX98373_R2004_INT_STATE1, 0x00},\n\t{MAX98373_R2005_INT_STATE2, 0x00},\n\t{MAX98373_R2006_INT_STATE3, 0x00},\n\t{MAX98373_R2007_INT_FLAG1, 0x00},\n\t{MAX98373_R2008_INT_FLAG2, 0x00},\n\t{MAX98373_R2009_INT_FLAG3, 0x00},\n\t{MAX98373_R200A_INT_EN1, 0x00},\n\t{MAX98373_R200B_INT_EN2, 0x00},\n\t{MAX98373_R200C_INT_EN3, 0x00},\n\t{MAX98373_R200D_INT_FLAG_CLR1, 0x00},\n\t{MAX98373_R200E_INT_FLAG_CLR2, 0x00},\n\t{MAX98373_R200F_INT_FLAG_CLR3, 0x00},\n\t{MAX98373_R2010_IRQ_CTRL, 0x00},\n\t{MAX98373_R2014_THERM_WARN_THRESH, 0x10},\n\t{MAX98373_R2015_THERM_SHDN_THRESH, 0x27},\n\t{MAX98373_R2016_THERM_HYSTERESIS, 0x01},\n\t{MAX98373_R2017_THERM_FOLDBACK_SET, 0xC0},\n\t{MAX98373_R2018_THERM_FOLDBACK_EN, 0x00},\n\t{MAX98373_R201E_PIN_DRIVE_STRENGTH, 0x55},\n\t{MAX98373_R2020_PCM_TX_HIZ_EN_1, 0xFE},\n\t{MAX98373_R2021_PCM_TX_HIZ_EN_2, 0xFF},\n\t{MAX98373_R2022_PCM_TX_SRC_1, 0x00},\n\t{MAX98373_R2023_PCM_TX_SRC_2, 0x00},\n\t{MAX98373_R2024_PCM_DATA_FMT_CFG, 0xC0},\n\t{MAX98373_R2025_AUDIO_IF_MODE, 0x00},\n\t{MAX98373_R2026_PCM_CLOCK_RATIO, 0x04},\n\t{MAX98373_R2027_PCM_SR_SETUP_1, 0x08},\n\t{MAX98373_R2028_PCM_SR_SETUP_2, 0x88},\n\t{MAX98373_R2029_PCM_TO_SPK_MONO_MIX_1, 0x00},\n\t{MAX98373_R202A_PCM_TO_SPK_MONO_MIX_2, 0x00},\n\t{MAX98373_R202B_PCM_RX_EN, 0x00},\n\t{MAX98373_R202C_PCM_TX_EN, 0x00},\n\t{MAX98373_R202E_ICC_RX_CH_EN_1, 0x00},\n\t{MAX98373_R202F_ICC_RX_CH_EN_2, 0x00},\n\t{MAX98373_R2030_ICC_TX_HIZ_EN_1, 0xFF},\n\t{MAX98373_R2031_ICC_TX_HIZ_EN_2, 0xFF},\n\t{MAX98373_R2032_ICC_LINK_EN_CFG, 0x30},\n\t{MAX98373_R2034_ICC_TX_CNTL, 0x00},\n\t{MAX98373_R2035_ICC_TX_EN, 0x00},\n\t{MAX98373_R2036_SOUNDWIRE_CTRL, 0x05},\n\t{MAX98373_R203D_AMP_DIG_VOL_CTRL, 0x00},\n\t{MAX98373_R203E_AMP_PATH_GAIN, 0x08},\n\t{MAX98373_R203F_AMP_DSP_CFG, 0x02},\n\t{MAX98373_R2040_TONE_GEN_CFG, 0x00},\n\t{MAX98373_R2041_AMP_CFG, 0x03},\n\t{MAX98373_R2042_AMP_EDGE_RATE_CFG, 0x00},\n\t{MAX98373_R2043_AMP_EN, 0x00},\n\t{MAX98373_R2046_IV_SENSE_ADC_DSP_CFG, 0x04},\n\t{MAX98373_R2047_IV_SENSE_ADC_EN, 0x00},\n\t{MAX98373_R2051_MEAS_ADC_SAMPLING_RATE, 0x00},\n\t{MAX98373_R2052_MEAS_ADC_PVDD_FLT_CFG, 0x00},\n\t{MAX98373_R2053_MEAS_ADC_THERM_FLT_CFG, 0x00},\n\t{MAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK, 0x00},\n\t{MAX98373_R2055_MEAS_ADC_THERM_CH_READBACK, 0x00},\n\t{MAX98373_R2056_MEAS_ADC_PVDD_CH_EN, 0x00},\n\t{MAX98373_R2090_BDE_LVL_HOLD, 0x00},\n\t{MAX98373_R2091_BDE_GAIN_ATK_REL_RATE, 0x00},\n\t{MAX98373_R2092_BDE_CLIPPER_MODE, 0x00},\n\t{MAX98373_R2097_BDE_L1_THRESH, 0x00},\n\t{MAX98373_R2098_BDE_L2_THRESH, 0x00},\n\t{MAX98373_R2099_BDE_L3_THRESH, 0x00},\n\t{MAX98373_R209A_BDE_L4_THRESH, 0x00},\n\t{MAX98373_R209B_BDE_THRESH_HYST, 0x00},\n\t{MAX98373_R20A8_BDE_L1_CFG_1, 0x00},\n\t{MAX98373_R20A9_BDE_L1_CFG_2, 0x00},\n\t{MAX98373_R20AA_BDE_L1_CFG_3, 0x00},\n\t{MAX98373_R20AB_BDE_L2_CFG_1, 0x00},\n\t{MAX98373_R20AC_BDE_L2_CFG_2, 0x00},\n\t{MAX98373_R20AD_BDE_L2_CFG_3, 0x00},\n\t{MAX98373_R20AE_BDE_L3_CFG_1, 0x00},\n\t{MAX98373_R20AF_BDE_L3_CFG_2, 0x00},\n\t{MAX98373_R20B0_BDE_L3_CFG_3, 0x00},\n\t{MAX98373_R20B1_BDE_L4_CFG_1, 0x00},\n\t{MAX98373_R20B2_BDE_L4_CFG_2, 0x00},\n\t{MAX98373_R20B3_BDE_L4_CFG_3, 0x00},\n\t{MAX98373_R20B4_BDE_INFINITE_HOLD_RELEASE, 0x00},\n\t{MAX98373_R20B5_BDE_EN, 0x00},\n\t{MAX98373_R20B6_BDE_CUR_STATE_READBACK, 0x00},\n\t{MAX98373_R20D1_DHT_CFG, 0x01},\n\t{MAX98373_R20D2_DHT_ATTACK_CFG, 0x02},\n\t{MAX98373_R20D3_DHT_RELEASE_CFG, 0x03},\n\t{MAX98373_R20D4_DHT_EN, 0x00},\n\t{MAX98373_R20E0_LIMITER_THRESH_CFG, 0x00},\n\t{MAX98373_R20E1_LIMITER_ATK_REL_RATES, 0x00},\n\t{MAX98373_R20E2_LIMITER_EN, 0x00},\n\t{MAX98373_R20FE_DEVICE_AUTO_RESTART_CFG, 0x00},\n\t{MAX98373_R20FF_GLOBAL_SHDN, 0x00},\n\t{MAX98373_R21FF_REV_ID, 0x42},\n};\n\nstatic int max98373_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98373_priv *max98373 = snd_soc_component_get_drvdata(component);\n\tunsigned int format = 0;\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98373_PCM_MODE_CFG_PCM_BCLKEDGE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2026_PCM_CLOCK_RATIO,\n\t\t\t   MAX98373_PCM_MODE_CFG_PCM_BCLKEDGE,\n\t\t\t   invert);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = MAX98373_PCM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = MAX98373_PCM_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = MAX98373_PCM_FORMAT_TDM_MODE1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = MAX98373_PCM_FORMAT_TDM_MODE0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2024_PCM_DATA_FMT_CFG,\n\t\t\t   MAX98373_PCM_MODE_CFG_FORMAT_MASK,\n\t\t\t   format << MAX98373_PCM_MODE_CFG_FORMAT_SHIFT);\n\n\treturn 0;\n}\n\n \nstatic const int bclk_sel_table[] = {\n\t32, 48, 64, 96, 128, 192, 256, 384, 512, 320,\n};\n\nstatic int max98373_get_bclk_sel(int bclk)\n{\n\tint i;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bclk_sel_table); i++) {\n\t\tif (bclk_sel_table[i] == bclk)\n\t\t\treturn i + 2;\n\t}\n\treturn 0;\n}\n\nstatic int max98373_set_clock(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct max98373_priv *max98373 = snd_soc_component_get_drvdata(component);\n\t \n\tint blr_clk_ratio = params_channels(params) * max98373->ch_size;\n\tint value;\n\n\tif (!max98373->tdm_mode) {\n\t\t \n\t\tvalue = max98373_get_bclk_sel(blr_clk_ratio);\n\t\tif (!value) {\n\t\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2026_PCM_CLOCK_RATIO,\n\t\t\t\t   MAX98373_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t\t   value);\n\t}\n\treturn 0;\n}\n\nstatic int max98373_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98373_priv *max98373 = snd_soc_component_get_drvdata(component);\n\tunsigned int sampling_rate = 0;\n\tunsigned int chan_sz = 0;\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\tgoto err;\n\t}\n\n\tmax98373->ch_size = snd_pcm_format_width(params_format(params));\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2024_PCM_DATA_FMT_CFG,\n\t\t\t   MAX98373_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\tdev_dbg(component->dev, \"format supported %d\",\n\t\tparams_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_96000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"rate %d not supported\\n\",\n\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\n\t \n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2027_PCM_SR_SETUP_1,\n\t\t\t   MAX98373_PCM_SR_SET1_SR_MASK,\n\t\t\t   sampling_rate);\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2028_PCM_SR_SETUP_2,\n\t\t\t   MAX98373_PCM_SR_SET2_SR_MASK,\n\t\t\t   sampling_rate << MAX98373_PCM_SR_SET2_SR_SHIFT);\n\n\t \n\tif (max98373->interleave_mode &&\n\t    sampling_rate > MAX98373_PCM_SR_SET1_SR_16000)\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2028_PCM_SR_SETUP_2,\n\t\t\t\t   MAX98373_PCM_SR_SET2_IVADC_SR_MASK,\n\t\t\t\t   sampling_rate - 3);\n\telse\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2028_PCM_SR_SETUP_2,\n\t\t\t\t   MAX98373_PCM_SR_SET2_IVADC_SR_MASK,\n\t\t\t\t   sampling_rate);\n\n\treturn max98373_set_clock(component, params);\nerr:\n\treturn -EINVAL;\n}\n\nstatic int max98373_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98373_priv *max98373 = snd_soc_component_get_drvdata(component);\n\tint bsel = 0;\n\tunsigned int chan_sz = 0;\n\tunsigned int mask;\n\tint x, slot_found;\n\n\tif (!tx_mask && !rx_mask && !slots && !slot_width)\n\t\tmax98373->tdm_mode = false;\n\telse\n\t\tmax98373->tdm_mode = true;\n\n\t \n\tbsel = max98373_get_bclk_sel(slots * slot_width);\n\tif (bsel == 0) {\n\t\tdev_err(component->dev, \"BCLK %d not supported\\n\",\n\t\t\tslots * slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2026_PCM_CLOCK_RATIO,\n\t\t\t   MAX98373_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t   bsel);\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2024_PCM_DATA_FMT_CFG,\n\t\t\t   MAX98373_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\t \n\tslot_found = 0;\n\tmask = rx_mask;\n\tfor (x = 0 ; x < 16 ; x++, mask >>= 1) {\n\t\tif (mask & 0x1) {\n\t\t\tif (slot_found == 0)\n\t\t\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t\t\t   MAX98373_R2029_PCM_TO_SPK_MONO_MIX_1,\n\t\t\t\t\t\t   MAX98373_PCM_TO_SPK_CH0_SRC_MASK, x);\n\t\t\telse\n\t\t\t\tregmap_write(max98373->regmap,\n\t\t\t\t\t     MAX98373_R202A_PCM_TO_SPK_MONO_MIX_2,\n\t\t\t\t\t     x);\n\t\t\tslot_found++;\n\t\t\tif (slot_found > 1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2020_PCM_TX_HIZ_EN_1,\n\t\t     ~tx_mask & 0xFF);\n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2021_PCM_TX_HIZ_EN_2,\n\t\t     (~tx_mask & 0xFF00) >> 8);\n\n\treturn 0;\n}\n\n#define MAX98373_RATES SNDRV_PCM_RATE_8000_96000\n\n#define MAX98373_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops max98373_dai_ops = {\n\t.set_fmt = max98373_dai_set_fmt,\n\t.hw_params = max98373_dai_hw_params,\n\t.set_tdm_slot = max98373_dai_tdm_slot,\n};\n\nstatic bool max98373_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98373_R2000_SW_RESET:\n\tcase MAX98373_R2001_INT_RAW1 ... MAX98373_R200C_INT_EN3:\n\tcase MAX98373_R2010_IRQ_CTRL:\n\tcase MAX98373_R2014_THERM_WARN_THRESH\n\t\t... MAX98373_R2018_THERM_FOLDBACK_EN:\n\tcase MAX98373_R201E_PIN_DRIVE_STRENGTH\n\t\t... MAX98373_R2036_SOUNDWIRE_CTRL:\n\tcase MAX98373_R203D_AMP_DIG_VOL_CTRL ... MAX98373_R2043_AMP_EN:\n\tcase MAX98373_R2046_IV_SENSE_ADC_DSP_CFG\n\t\t... MAX98373_R2047_IV_SENSE_ADC_EN:\n\tcase MAX98373_R2051_MEAS_ADC_SAMPLING_RATE\n\t\t... MAX98373_R2056_MEAS_ADC_PVDD_CH_EN:\n\tcase MAX98373_R2090_BDE_LVL_HOLD ... MAX98373_R2092_BDE_CLIPPER_MODE:\n\tcase MAX98373_R2097_BDE_L1_THRESH\n\t\t... MAX98373_R209B_BDE_THRESH_HYST:\n\tcase MAX98373_R20A8_BDE_L1_CFG_1 ... MAX98373_R20B3_BDE_L4_CFG_3:\n\tcase MAX98373_R20B5_BDE_EN ... MAX98373_R20B6_BDE_CUR_STATE_READBACK:\n\tcase MAX98373_R20D1_DHT_CFG ... MAX98373_R20D4_DHT_EN:\n\tcase MAX98373_R20E0_LIMITER_THRESH_CFG ... MAX98373_R20E2_LIMITER_EN:\n\tcase MAX98373_R20FE_DEVICE_AUTO_RESTART_CFG\n\t\t... MAX98373_R20FF_GLOBAL_SHDN:\n\tcase MAX98373_R21FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98373_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98373_R2000_SW_RESET ... MAX98373_R2009_INT_FLAG3:\n\tcase MAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK:\n\tcase MAX98373_R2055_MEAS_ADC_THERM_CH_READBACK:\n\tcase MAX98373_R20B6_BDE_CUR_STATE_READBACK:\n\tcase MAX98373_R20FF_GLOBAL_SHDN:\n\tcase MAX98373_R21FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct snd_soc_dai_driver max98373_dai[] = {\n\t{\n\t\t.name = \"max98373-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98373_RATES,\n\t\t\t.formats = MAX98373_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98373_RATES,\n\t\t\t.formats = MAX98373_FORMATS,\n\t\t},\n\t\t.ops = &max98373_dai_ops,\n\t}\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max98373_suspend(struct device *dev)\n{\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < max98373->cache_num; i++)\n\t\tregmap_read(max98373->regmap, max98373->cache[i].reg, &max98373->cache[i].val);\n\n\tregcache_cache_only(max98373->regmap, true);\n\tregcache_mark_dirty(max98373->regmap);\n\treturn 0;\n}\n\nstatic int max98373_resume(struct device *dev)\n{\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98373->regmap, false);\n\tmax98373_reset(max98373, dev);\n\tregcache_sync(max98373->regmap);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops max98373_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max98373_suspend, max98373_resume)\n};\n\nstatic const struct regmap_config max98373_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = MAX98373_R21FF_REV_ID,\n\t.reg_defaults  = max98373_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98373_reg),\n\t.readable_reg = max98373_readable_register,\n\t.volatile_reg = max98373_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int max98373_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret = 0;\n\tint reg = 0;\n\tint i;\n\tstruct max98373_priv *max98373 = NULL;\n\n\tmax98373 = devm_kzalloc(&i2c->dev, sizeof(*max98373), GFP_KERNEL);\n\n\tif (!max98373) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(i2c, max98373);\n\n\t \n\tif (device_property_read_bool(&i2c->dev, \"maxim,interleave_mode\"))\n\t\tmax98373->interleave_mode = true;\n\telse\n\t\tmax98373->interleave_mode = false;\n\n\t \n\tmax98373->regmap = devm_regmap_init_i2c(i2c, &max98373_regmap);\n\tif (IS_ERR(max98373->regmap)) {\n\t\tret = PTR_ERR(max98373->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax98373->cache_num = ARRAY_SIZE(max98373_i2c_cache_reg);\n\tmax98373->cache = devm_kcalloc(&i2c->dev, max98373->cache_num,\n\t\t\t\t       sizeof(*max98373->cache),\n\t\t\t\t       GFP_KERNEL);\n\tif (!max98373->cache) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < max98373->cache_num; i++)\n\t\tmax98373->cache[i].reg = max98373_i2c_cache_reg[i];\n\n\t \n\tmax98373_slot_config(&i2c->dev, max98373);\n\n\t \n\tif (gpio_is_valid(max98373->reset_gpio)) {\n\t\tret = devm_gpio_request(&i2c->dev, max98373->reset_gpio,\n\t\t\t\t\t\"MAX98373_RESET\");\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"%s: Failed to request gpio %d\\n\",\n\t\t\t\t__func__, max98373->reset_gpio);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tgpio_direction_output(max98373->reset_gpio, 0);\n\t\tmsleep(50);\n\t\tgpio_direction_output(max98373->reset_gpio, 1);\n\t\tmsleep(20);\n\t}\n\n\t \n\tret = regmap_read(max98373->regmap,\n\t\t\t  MAX98373_R21FF_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to read: 0x%02X\\n\", MAX98373_R21FF_REV_ID);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"MAX98373 revisionID: 0x%02X\\n\", reg);\n\n\t \n\tret = devm_snd_soc_register_component(&i2c->dev, &soc_codec_dev_max98373,\n\t\t\t\t\t      max98373_dai, ARRAY_SIZE(max98373_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Failed to register codec: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98373_i2c_id[] = {\n\t{ \"max98373\", 0},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, max98373_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98373_of_match[] = {\n\t{ .compatible = \"maxim,max98373\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98373_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max98373_acpi_match[] = {\n\t{ \"MX98373\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, max98373_acpi_match);\n#endif\n\nstatic struct i2c_driver max98373_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98373\",\n\t\t.of_match_table = of_match_ptr(max98373_of_match),\n\t\t.acpi_match_table = ACPI_PTR(max98373_acpi_match),\n\t\t.pm = &max98373_pm,\n\t},\n\t.probe = max98373_i2c_probe,\n\t.id_table = max98373_i2c_id,\n};\n\nmodule_i2c_driver(max98373_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98373 driver\");\nMODULE_AUTHOR(\"Ryan Lee <ryans.lee@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}