{
  "module_name": "src4xxx.c",
  "hash_id": "a09188f4cb2bf8d2d84ff059a8c341b030ab91d8ecd053634dd291930fb95f91",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/src4xxx.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"src4xxx.h\"\n\nstruct src4xxx {\n\tstruct regmap *regmap;\n\tbool master[2];\n\tint mclk_hz;\n\tstruct device *dev;\n};\n\nenum {SRC4XXX_PORTA, SRC4XXX_PORTB};\n\n \nstatic const DECLARE_TLV_DB_SCALE(src_tlv, -12750, 50, 0);\n\nstatic const struct snd_kcontrol_new src4xxx_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"SRC Volume\",\n\t\tSRC4XXX_SCR_CTL_30, SRC4XXX_SCR_CTL_31, 0, 255, 1, src_tlv),\n};\n\n \nstatic const char * const port_out_src_text[] = {\n\t\"loopback\", \"other_port\", \"DIR\", \"SRC\"\n};\nstatic SOC_ENUM_SINGLE_DECL(porta_out_src_enum, SRC4XXX_PORTA_CTL_03, 4,\n\tport_out_src_text);\nstatic SOC_ENUM_SINGLE_DECL(portb_out_src_enum, SRC4XXX_PORTB_CTL_05, 4,\n\tport_out_src_text);\nstatic const struct snd_kcontrol_new porta_out_control =\n\tSOC_DAPM_ENUM(\"Port A source select\", porta_out_src_enum);\nstatic const struct snd_kcontrol_new portb_out_control =\n\tSOC_DAPM_ENUM(\"Port B source select\", portb_out_src_enum);\n\n \nstatic const char * const dit_mux_text[] = {\"Port A\", \"Port B\", \"DIR\", \"SRC\"};\nstatic SOC_ENUM_SINGLE_DECL(dit_mux_enum, SRC4XXX_TX_CTL_07, 3, dit_mux_text);\nstatic const struct snd_kcontrol_new dit_mux_control =\n\tSOC_DAPM_ENUM(\"DIT source\", dit_mux_enum);\n\n \nstatic const char * const src_in_text[] = {\"Port A\", \"Port B\", \"DIR\"};\nstatic SOC_ENUM_SINGLE_DECL(src_in_enum, SRC4XXX_SCR_CTL_2D, 0, src_in_text);\nstatic const struct snd_kcontrol_new src_in_control =\n\tSOC_DAPM_ENUM(\"SRC source select\", src_in_enum);\n\n \nstatic const char * const dir_in_text[] = {\"Ch 1\", \"Ch 2\", \"Ch 3\", \"Ch 4\"};\nstatic SOC_ENUM_SINGLE_DECL(dir_in_enum, SRC4XXX_RCV_CTL_0D, 0, dir_in_text);\nstatic const struct snd_kcontrol_new dir_in_control =\n\tSOC_DAPM_ENUM(\"Digital Input\", dir_in_enum);\n\nstatic const struct snd_soc_dapm_widget src4xxx_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"loopback_A\"),\n\tSND_SOC_DAPM_INPUT(\"other_port_A\"),\n\tSND_SOC_DAPM_INPUT(\"DIR_A\"),\n\tSND_SOC_DAPM_INPUT(\"SRC_A\"),\n\tSND_SOC_DAPM_MUX(\"Port A source\",\n\t\tSND_SOC_NOPM, 0, 0, &porta_out_control),\n\n\tSND_SOC_DAPM_INPUT(\"loopback_B\"),\n\tSND_SOC_DAPM_INPUT(\"other_port_B\"),\n\tSND_SOC_DAPM_INPUT(\"DIR_B\"),\n\tSND_SOC_DAPM_INPUT(\"SRC_B\"),\n\tSND_SOC_DAPM_MUX(\"Port B source\",\n\t\tSND_SOC_NOPM, 0, 0, &portb_out_control),\n\n\tSND_SOC_DAPM_INPUT(\"Port_A\"),\n\tSND_SOC_DAPM_INPUT(\"Port_B\"),\n\tSND_SOC_DAPM_INPUT(\"DIR_\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"DIR_OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SRC_OUT\"),\n\tSND_SOC_DAPM_MUX(\"DIT Out Src\", SRC4XXX_PWR_RST_01,\n\t\tSRC4XXX_ENABLE_DIT_SHIFT, 1, &dit_mux_control),\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF_A_RX\", \"Playback A\", 0,\n\t\tSRC4XXX_PWR_RST_01, SRC4XXX_ENABLE_PORT_A_SHIFT, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF_A_TX\", \"Capture A\", 0,\n\t\tSRC4XXX_PWR_RST_01, SRC4XXX_ENABLE_PORT_A_SHIFT, 1),\n\tSND_SOC_DAPM_AIF_IN(\"AIF_B_RX\", \"Playback B\", 0,\n\t\tSRC4XXX_PWR_RST_01, SRC4XXX_ENABLE_PORT_B_SHIFT, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF_B_TX\", \"Capture B\", 0,\n\t\tSRC4XXX_PWR_RST_01, SRC4XXX_ENABLE_PORT_B_SHIFT, 1),\n\n\tSND_SOC_DAPM_MUX(\"SRC source\", SND_SOC_NOPM, 0, 0, &src_in_control),\n\n\tSND_SOC_DAPM_INPUT(\"MCLK\"),\n\tSND_SOC_DAPM_INPUT(\"RXMCLKI\"),\n\tSND_SOC_DAPM_INPUT(\"RXMCLKO\"),\n\n\tSND_SOC_DAPM_INPUT(\"RX1\"),\n\tSND_SOC_DAPM_INPUT(\"RX2\"),\n\tSND_SOC_DAPM_INPUT(\"RX3\"),\n\tSND_SOC_DAPM_INPUT(\"RX4\"),\n\tSND_SOC_DAPM_MUX(\"Digital Input\", SRC4XXX_PWR_RST_01,\n\t\tSRC4XXX_ENABLE_DIR_SHIFT, 1, &dir_in_control),\n};\n\nstatic const struct snd_soc_dapm_route src4xxx_audio_routes[] = {\n\t \n\t{\"Port A source\", \"loopback\", \"loopback_A\"},\n\t{\"Port A source\", \"other_port\", \"other_port_A\"},\n\t{\"Port A source\", \"DIR\", \"DIR_A\"},\n\t{\"Port A source\", \"SRC\", \"SRC_A\"},\n\t{\"Port B source\", \"loopback\", \"loopback_B\"},\n\t{\"Port B source\", \"other_port\", \"other_port_B\"},\n\t{\"Port B source\", \"DIR\", \"DIR_B\"},\n\t{\"Port B source\", \"SRC\", \"SRC_B\"},\n\t \n\t{\"DIT Out Src\", \"Port A\", \"Capture A\"},\n\t{\"DIT Out Src\", \"Port B\", \"Capture B\"},\n\t{\"DIT Out Src\", \"DIR\", \"DIR_OUT\"},\n\t{\"DIT Out Src\", \"SRC\", \"SRC_OUT\"},\n\n\t \n\t{\"SRC source\", \"Port A\", \"Port_A\"},\n\t{\"SRC source\", \"Port B\", \"Port_B\"},\n\t{\"SRC source\", \"DIR\", \"DIR_\"},\n\t \n\t{\"SRC mclk source\", \"Master (MCLK)\", \"MCLK\"},\n\t{\"SRC mclk source\", \"Master (RXCLKI)\", \"RXMCLKI\"},\n\t{\"SRC mclk source\", \"Recovered receiver clk\", \"RXMCLKO\"},\n\t \n\t{\"Digital Input\", \"Ch 1\", \"RX1\"},\n\t{\"Digital Input\", \"Ch 2\", \"RX2\"},\n\t{\"Digital Input\", \"Ch 3\", \"RX3\"},\n\t{\"Digital Input\", \"Ch 4\", \"RX4\"},\n};\n\n\nstatic const struct snd_soc_component_driver src4xxx_driver = {\n\t.controls = src4xxx_controls,\n\t.num_controls = ARRAY_SIZE(src4xxx_controls),\n\n\t.dapm_widgets = src4xxx_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(src4xxx_dapm_widgets),\n\t.dapm_routes = src4xxx_audio_routes,\n\t.num_dapm_routes = ARRAY_SIZE(src4xxx_audio_routes),\n};\n\nstatic int src4xxx_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct src4xxx *src4xxx = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl = SRC4XXX_BUS_MASTER;\n\t\tsrc4xxx->master[dai->id] = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tctrl = 0;\n\t\tsrc4xxx->master[dai->id] = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl |= SRC4XXX_BUS_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl |= SRC4XXX_BUS_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl |= SRC4XXX_BUS_RIGHT_J_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tregmap_update_bits(src4xxx->regmap, SRC4XXX_BUS_FMT(dai->id),\n\t\tSRC4XXX_BUS_FMT_MS_MASK, ctrl);\n\n\treturn 0;\n}\n\nstatic int src4xxx_set_mclk_hz(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct src4xxx *src4xxx = snd_soc_component_get_drvdata(component);\n\n\tdev_info(component->dev, \"changing mclk rate from %d to %d Hz\\n\",\n\t\tsrc4xxx->mclk_hz, freq);\n\tsrc4xxx->mclk_hz = freq;\n\n\treturn 0;\n}\n\nstatic int src4xxx_hw_params(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct src4xxx *src4xxx = snd_soc_component_get_drvdata(component);\n\tunsigned int mclk_div;\n\tint val, pj, jd, d;\n\tint reg;\n\tint ret;\n\n\tswitch (dai->id) {\n\tcase SRC4XXX_PORTB:\n\t\treg = SRC4XXX_PORTB_CTL_06;\n\t\tbreak;\n\tdefault:\n\t\treg = SRC4XXX_PORTA_CTL_04;\n\t\tbreak;\n\t}\n\n\tif (src4xxx->master[dai->id]) {\n\t\tmclk_div = src4xxx->mclk_hz/params_rate(params);\n\t\tif (src4xxx->mclk_hz != mclk_div*params_rate(params)) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"mclk %d / rate %d has a remainder.\\n\",\n\t\t\t\tsrc4xxx->mclk_hz, params_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = ((int)mclk_div - 128) / 128;\n\t\tif ((val < 0) | (val > 3)) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"div register setting %d is out of range\\n\",\n\t\t\t\tval);\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"unsupported sample rate %d Hz for the master clock of %d Hz\\n\",\n\t\t\t\tparams_rate(params), src4xxx->mclk_hz);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = regmap_update_bits(src4xxx->regmap,\n\t\t\tSRC4XXX_TX_CTL_07, SRC4XXX_TX_MCLK_DIV_MASK,\n\t\t\tval<<SRC4XXX_TX_MCLK_DIV_SHIFT);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Couldn't set the TX's div register to %d << %d = 0x%x\\n\",\n\t\t\t\tval, SRC4XXX_TX_MCLK_DIV_SHIFT,\n\t\t\t\tval<<SRC4XXX_TX_MCLK_DIV_SHIFT);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tswitch (src4xxx->mclk_hz) {\n\t\tcase 24576000:\n\t\t\tpj = 0x22;\n\t\t\tjd = 0x00;\n\t\t\td = 0x00;\n\t\t\tbreak;\n\t\tcase 22579200:\n\t\t\tpj = 0x22;\n\t\t\tjd = 0x1b;\n\t\t\td = 0xa3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_info(component->dev,\n\t\t\t\t\"Couldn't set the RCV PLL as this master clock rate is unknown. Chosen regmap values may not match real world values.\\n\");\n\t\t\tpj = 0x0;\n\t\t\tjd = 0xff;\n\t\t\td = 0xff;\n\t\t\tbreak;\n\t\t}\n\t\tret = regmap_write(src4xxx->regmap, SRC4XXX_RCV_PLL_0F, pj);\n\t\tif (ret < 0)\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update PLL register 0x%x\\n\",\n\t\t\t\tSRC4XXX_RCV_PLL_0F);\n\t\tret = regmap_write(src4xxx->regmap, SRC4XXX_RCV_PLL_10, jd);\n\t\tif (ret < 0)\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update PLL register 0x%x\\n\",\n\t\t\t\tSRC4XXX_RCV_PLL_10);\n\t\tret = regmap_write(src4xxx->regmap, SRC4XXX_RCV_PLL_11, d);\n\t\tif (ret < 0)\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update PLL register 0x%x\\n\",\n\t\t\t\tSRC4XXX_RCV_PLL_11);\n\n\t\tret = regmap_update_bits(src4xxx->regmap,\n\t\t\tSRC4XXX_TX_CTL_07, SRC4XXX_TX_MCLK_DIV_MASK,\n\t\t\tval<<SRC4XXX_TX_MCLK_DIV_SHIFT);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Couldn't set the TX's div register to %d << %d = 0x%x\\n\",\n\t\t\t\tval, SRC4XXX_TX_MCLK_DIV_SHIFT,\n\t\t\t\tval<<SRC4XXX_TX_MCLK_DIV_SHIFT);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn regmap_update_bits(src4xxx->regmap, reg,\n\t\t\t\t\tSRC4XXX_MCLK_DIV_MASK, val);\n\t} else {\n\t\tdev_info(dai->dev, \"not setting up MCLK as not master\\n\");\n\t}\n\n\treturn 0;\n};\n\nstatic const struct snd_soc_dai_ops src4xxx_dai_ops = {\n\t.hw_params\t= src4xxx_hw_params,\n\t.set_sysclk\t= src4xxx_set_mclk_hz,\n\t.set_fmt\t= src4xxx_set_dai_fmt,\n};\n\n#define SRC4XXX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\tSNDRV_PCM_FMTBIT_S32_LE)\n#define SRC4XXX_RATES (SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000|\\\n\t\t\t\tSNDRV_PCM_RATE_88200|\\\n\t\t\t\tSNDRV_PCM_RATE_96000|\\\n\t\t\t\tSNDRV_PCM_RATE_176400|\\\n\t\t\t\tSNDRV_PCM_RATE_192000)\n\nstatic struct snd_soc_dai_driver src4xxx_dai_driver[] = {\n\t{\n\t\t.id = SRC4XXX_PORTA,\n\t\t.name = \"src4xxx-portA\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback A\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SRC4XXX_RATES,\n\t\t\t.formats = SRC4XXX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture A\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SRC4XXX_RATES,\n\t\t\t.formats = SRC4XXX_FORMATS,\n\t\t},\n\t\t.ops = &src4xxx_dai_ops,\n\t},\n\t{\n\t\t.id = SRC4XXX_PORTB,\n\t\t.name = \"src4xxx-portB\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback B\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SRC4XXX_RATES,\n\t\t\t.formats = SRC4XXX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture B\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SRC4XXX_RATES,\n\t\t\t.formats = SRC4XXX_FORMATS,\n\t\t},\n\t\t.ops = &src4xxx_dai_ops,\n\t},\n};\n\nstatic const struct reg_default src4xxx_reg_defaults[] = {\n\t{ SRC4XXX_PWR_RST_01,\t\t0x00 },  \n\t{ SRC4XXX_PORTA_CTL_03,\t\t0x00 },\n\t{ SRC4XXX_PORTA_CTL_04,\t\t0x00 },\n\t{ SRC4XXX_PORTB_CTL_05,\t\t0x00 },\n\t{ SRC4XXX_PORTB_CTL_06,\t\t0x00 },\n\t{ SRC4XXX_TX_CTL_07,\t\t0x00 },\n\t{ SRC4XXX_TX_CTL_08,\t\t0x00 },\n\t{ SRC4XXX_TX_CTL_09,\t\t0x00 },\n\t{ SRC4XXX_SRC_DIT_IRQ_MSK_0B,\t0x00 },\n\t{ SRC4XXX_SRC_DIT_IRQ_MODE_0C,\t0x00 },\n\t{ SRC4XXX_RCV_CTL_0D,\t\t0x00 },\n\t{ SRC4XXX_RCV_CTL_0E,\t\t0x00 },\n\t{ SRC4XXX_RCV_PLL_0F,\t\t0x00 },  \n\t{ SRC4XXX_RCV_PLL_10,\t\t0xff },  \n\t{ SRC4XXX_RCV_PLL_11,\t\t0xff },  \n\t{ SRC4XXX_RVC_IRQ_MSK_16,\t0x00 },\n\t{ SRC4XXX_RVC_IRQ_MSK_17,\t0x00 },\n\t{ SRC4XXX_RVC_IRQ_MODE_18,\t0x00 },\n\t{ SRC4XXX_RVC_IRQ_MODE_19,\t0x00 },\n\t{ SRC4XXX_RVC_IRQ_MODE_1A,\t0x00 },\n\t{ SRC4XXX_GPIO_1_1B,\t\t0x00 },\n\t{ SRC4XXX_GPIO_2_1C,\t\t0x00 },\n\t{ SRC4XXX_GPIO_3_1D,\t\t0x00 },\n\t{ SRC4XXX_GPIO_4_1E,\t\t0x00 },\n\t{ SRC4XXX_SCR_CTL_2D,\t\t0x00 },\n\t{ SRC4XXX_SCR_CTL_2E,\t\t0x00 },\n\t{ SRC4XXX_SCR_CTL_2F,\t\t0x00 },\n\t{ SRC4XXX_SCR_CTL_30,\t\t0x00 },\n\t{ SRC4XXX_SCR_CTL_31,\t\t0x00 },\n};\n\nint src4xxx_probe(struct device *dev, struct regmap *regmap,\n\t\t\tvoid (*switch_mode)(struct device *dev))\n{\n\tstruct src4xxx *src4xxx;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tsrc4xxx = devm_kzalloc(dev, sizeof(*src4xxx), GFP_KERNEL);\n\tif (!src4xxx)\n\t\treturn -ENOMEM;\n\n\tsrc4xxx->regmap = regmap;\n\tsrc4xxx->dev = dev;\n\tsrc4xxx->mclk_hz = 0;  \n\tdev_set_drvdata(dev, src4xxx);\n\n\tret = regmap_write(regmap, SRC4XXX_PWR_RST_01, SRC4XXX_RESET);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to issue reset: %d\\n\", ret);\n\tusleep_range(1, 500);  \n\tret = regmap_write(regmap, SRC4XXX_PWR_RST_01, SRC4XXX_POWER_DOWN);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to decommission reset: %d\\n\", ret);\n\tusleep_range(500, 1000);  \n\n\tret = regmap_update_bits(src4xxx->regmap, SRC4XXX_PWR_RST_01,\n\t\tSRC4XXX_POWER_ENABLE, SRC4XXX_POWER_ENABLE);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to port A and B : %d\\n\", ret);\n\n\t \n\tret = regmap_update_bits(src4xxx->regmap, SRC4XXX_RCV_CTL_0D,\n\t\tSRC4XXX_RXCLK_MCLK,\tSRC4XXX_RXCLK_MCLK);\n\tif (ret < 0)\n\t\tdev_err(dev,\n\t\t\t\"Failed to enable mclk as the PLL1 DIR reference : %d\\n\", ret);\n\n\t \n\tret = regmap_update_bits(src4xxx->regmap, SRC4XXX_RCV_CTL_0E,\n\t\tSRC4XXX_PLL2_DIV_8 | SRC4XXX_REC_MCLK_EN | SRC4XXX_PLL2_LOL,\n\t\tSRC4XXX_PLL2_DIV_8 | SRC4XXX_REC_MCLK_EN | SRC4XXX_PLL2_LOL);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to enable mclk rec and div : %d\\n\", ret);\n\n\tret = devm_snd_soc_register_component(dev, &src4xxx_driver,\n\t\t\tsrc4xxx_dai_driver, ARRAY_SIZE(src4xxx_dai_driver));\n\tif (ret == 0)\n\t\tdev_info(dev, \"src4392 probe ok %d\\n\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(src4xxx_probe);\n\nstatic bool src4xxx_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SRC4XXX_RES_00:\n\tcase SRC4XXX_GLOBAL_ITR_STS_02:\n\tcase SRC4XXX_SRC_DIT_STS_0A:\n\tcase SRC4XXX_NON_AUDIO_D_12:\n\tcase SRC4XXX_RVC_STS_13:\n\tcase SRC4XXX_RVC_STS_14:\n\tcase SRC4XXX_RVC_STS_15:\n\tcase SRC4XXX_SUB_CODE_1F:\n\tcase SRC4XXX_SUB_CODE_20:\n\tcase SRC4XXX_SUB_CODE_21:\n\tcase SRC4XXX_SUB_CODE_22:\n\tcase SRC4XXX_SUB_CODE_23:\n\tcase SRC4XXX_SUB_CODE_24:\n\tcase SRC4XXX_SUB_CODE_25:\n\tcase SRC4XXX_SUB_CODE_26:\n\tcase SRC4XXX_SUB_CODE_27:\n\tcase SRC4XXX_SUB_CODE_28:\n\tcase SRC4XXX_PC_PREAMBLE_HI_29:\n\tcase SRC4XXX_PC_PREAMBLE_LO_2A:\n\tcase SRC4XXX_PD_PREAMBLE_HI_2B:\n\tcase SRC4XXX_PC_PREAMBLE_LO_2C:\n\tcase SRC4XXX_IO_RATIO_32:\n\tcase SRC4XXX_IO_RATIO_33:\n\t\treturn true;\n\t}\n\n\tif (reg > SRC4XXX_IO_RATIO_33 && reg < SRC4XXX_PAGE_SEL_7F)\n\t\treturn true;\n\n\treturn false;\n}\n\nconst struct regmap_config src4xxx_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 8,\n\t.max_register = SRC4XXX_IO_RATIO_33,\n\n\t.reg_defaults = src4xxx_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(src4xxx_reg_defaults),\n\t.volatile_reg = src4xxx_volatile_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_GPL(src4xxx_regmap_config);\n\nMODULE_DESCRIPTION(\"ASoC SRC4XXX CODEC driver\");\nMODULE_AUTHOR(\"Matt Flax <flatmax@flatmax.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}