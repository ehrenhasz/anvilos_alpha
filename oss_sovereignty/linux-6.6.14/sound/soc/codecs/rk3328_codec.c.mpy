{
  "module_name": "rk3328_codec.c",
  "hash_id": "167c65c66387b4c530222c7b85f875d0d53bb0b97986aa54437fbcf4e06559c3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rk3328_codec.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <sound/dmaengine_pcm.h>\n#include <sound/pcm_params.h>\n#include \"rk3328_codec.h\"\n\n \n#define OUT_VOLUME\t(0x18)\n#define RK3328_GRF_SOC_CON2\t(0x0408)\n#define RK3328_GRF_SOC_CON10\t(0x0428)\n#define INITIAL_FREQ\t(11289600)\n\nstruct rk3328_codec_priv {\n\tstruct regmap *regmap;\n\tstruct gpio_desc *mute;\n\tstruct clk *mclk;\n\tstruct clk *pclk;\n\tunsigned int sclk;\n\tint spk_depop_time;  \n};\n\nstatic const struct reg_default rk3328_codec_reg_defaults[] = {\n\t{ CODEC_RESET, 0x03 },\n\t{ DAC_INIT_CTRL1, 0x00 },\n\t{ DAC_INIT_CTRL2, 0x50 },\n\t{ DAC_INIT_CTRL3, 0x0e },\n\t{ DAC_PRECHARGE_CTRL, 0x01 },\n\t{ DAC_PWR_CTRL, 0x00 },\n\t{ DAC_CLK_CTRL, 0x00 },\n\t{ HPMIX_CTRL, 0x00 },\n\t{ HPOUT_CTRL, 0x00 },\n\t{ HPOUTL_GAIN_CTRL, 0x00 },\n\t{ HPOUTR_GAIN_CTRL, 0x00 },\n\t{ HPOUT_POP_CTRL, 0x11 },\n};\n\nstatic int rk3328_codec_reset(struct rk3328_codec_priv *rk3328)\n{\n\tregmap_write(rk3328->regmap, CODEC_RESET, 0x00);\n\tmdelay(10);\n\tregmap_write(rk3328->regmap, CODEC_RESET, 0x03);\n\n\treturn 0;\n}\n\nstatic int rk3328_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tunsigned int val;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tval = PIN_DIRECTION_IN | DAC_I2S_MODE_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tval = PIN_DIRECTION_OUT | DAC_I2S_MODE_MASTER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(rk3328->regmap, DAC_INIT_CTRL1,\n\t\t\t   PIN_DIRECTION_MASK | DAC_I2S_MODE_MASK, val);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tval = DAC_MODE_PCM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = DAC_MODE_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = DAC_MODE_RJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = DAC_MODE_LJM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(rk3328->regmap, DAC_INIT_CTRL2,\n\t\t\t   DAC_MODE_MASK, val);\n\n\treturn 0;\n}\n\nstatic int rk3328_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tunsigned int val;\n\n\tif (mute)\n\t\tval = HPOUTL_MUTE | HPOUTR_MUTE;\n\telse\n\t\tval = HPOUTL_UNMUTE | HPOUTR_UNMUTE;\n\n\tregmap_update_bits(rk3328->regmap, HPOUT_CTRL,\n\t\t\t   HPOUTL_MUTE_MASK | HPOUTR_MUTE_MASK, val);\n\n\treturn 0;\n}\n\nstatic int rk3328_codec_power_on(struct rk3328_codec_priv *rk3328, int wait_ms)\n{\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_XCHARGE_MASK, DAC_CHARGE_PRECHARGE);\n\tmdelay(10);\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_MASK,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_ON);\n\tmdelay(wait_ms);\n\n\treturn 0;\n}\n\nstatic int rk3328_codec_power_off(struct rk3328_codec_priv *rk3328, int wait_ms)\n{\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_XCHARGE_MASK, DAC_CHARGE_DISCHARGE);\n\tmdelay(10);\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_MASK,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_ON);\n\tmdelay(wait_ms);\n\n\treturn 0;\n}\n\nstatic const struct rk3328_reg_msk_val playback_open_list[] = {\n\t{ DAC_PWR_CTRL, DAC_PWR_MASK, DAC_PWR_ON },\n\t{ DAC_PWR_CTRL, DACL_PATH_REFV_MASK | DACR_PATH_REFV_MASK,\n\t  DACL_PATH_REFV_ON | DACR_PATH_REFV_ON },\n\t{ DAC_PWR_CTRL, HPOUTL_ZERO_CROSSING_MASK | HPOUTR_ZERO_CROSSING_MASK,\n\t  HPOUTL_ZERO_CROSSING_ON | HPOUTR_ZERO_CROSSING_ON },\n\t{ HPOUT_POP_CTRL, HPOUTR_POP_MASK | HPOUTL_POP_MASK,\n\t  HPOUTR_POP_WORK | HPOUTL_POP_WORK },\n\t{ HPMIX_CTRL, HPMIXL_MASK | HPMIXR_MASK, HPMIXL_EN | HPMIXR_EN },\n\t{ HPMIX_CTRL, HPMIXL_INIT_MASK | HPMIXR_INIT_MASK,\n\t  HPMIXL_INIT_EN | HPMIXR_INIT_EN },\n\t{ HPOUT_CTRL, HPOUTL_MASK | HPOUTR_MASK, HPOUTL_EN | HPOUTR_EN },\n\t{ HPOUT_CTRL, HPOUTL_INIT_MASK | HPOUTR_INIT_MASK,\n\t  HPOUTL_INIT_EN | HPOUTR_INIT_EN },\n\t{ DAC_CLK_CTRL, DACL_REFV_MASK | DACR_REFV_MASK,\n\t  DACL_REFV_ON | DACR_REFV_ON },\n\t{ DAC_CLK_CTRL, DACL_CLK_MASK | DACR_CLK_MASK,\n\t  DACL_CLK_ON | DACR_CLK_ON },\n\t{ DAC_CLK_CTRL, DACL_MASK | DACR_MASK, DACL_ON | DACR_ON },\n\t{ DAC_CLK_CTRL, DACL_INIT_MASK | DACR_INIT_MASK,\n\t  DACL_INIT_ON | DACR_INIT_ON },\n\t{ DAC_SELECT, DACL_SELECT_MASK | DACR_SELECT_MASK,\n\t  DACL_SELECT | DACR_SELECT },\n\t{ HPMIX_CTRL, HPMIXL_INIT2_MASK | HPMIXR_INIT2_MASK,\n\t  HPMIXL_INIT2_EN | HPMIXR_INIT2_EN },\n\t{ HPOUT_CTRL, HPOUTL_MUTE_MASK | HPOUTR_MUTE_MASK,\n\t  HPOUTL_UNMUTE | HPOUTR_UNMUTE },\n};\n\nstatic int rk3328_codec_open_playback(struct rk3328_codec_priv *rk3328)\n{\n\tint i;\n\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_MASK,\n\t\t\t   DAC_CHARGE_CURRENT_I);\n\n\tfor (i = 0; i < ARRAY_SIZE(playback_open_list); i++) {\n\t\tregmap_update_bits(rk3328->regmap,\n\t\t\t\t   playback_open_list[i].reg,\n\t\t\t\t   playback_open_list[i].msk,\n\t\t\t\t   playback_open_list[i].val);\n\t\tmdelay(1);\n\t}\n\n\tmsleep(rk3328->spk_depop_time);\n\tgpiod_set_value(rk3328->mute, 0);\n\n\tregmap_update_bits(rk3328->regmap, HPOUTL_GAIN_CTRL,\n\t\t\t   HPOUTL_GAIN_MASK, OUT_VOLUME);\n\tregmap_update_bits(rk3328->regmap, HPOUTR_GAIN_CTRL,\n\t\t\t   HPOUTR_GAIN_MASK, OUT_VOLUME);\n\n\treturn 0;\n}\n\nstatic const struct rk3328_reg_msk_val playback_close_list[] = {\n\t{ HPMIX_CTRL, HPMIXL_INIT2_MASK | HPMIXR_INIT2_MASK,\n\t  HPMIXL_INIT2_DIS | HPMIXR_INIT2_DIS },\n\t{ DAC_SELECT, DACL_SELECT_MASK | DACR_SELECT_MASK,\n\t  DACL_UNSELECT | DACR_UNSELECT },\n\t{ HPOUT_CTRL, HPOUTL_MUTE_MASK | HPOUTR_MUTE_MASK,\n\t  HPOUTL_MUTE | HPOUTR_MUTE },\n\t{ HPOUT_CTRL, HPOUTL_INIT_MASK | HPOUTR_INIT_MASK,\n\t  HPOUTL_INIT_DIS | HPOUTR_INIT_DIS },\n\t{ HPOUT_CTRL, HPOUTL_MASK | HPOUTR_MASK, HPOUTL_DIS | HPOUTR_DIS },\n\t{ HPMIX_CTRL, HPMIXL_MASK | HPMIXR_MASK, HPMIXL_DIS | HPMIXR_DIS },\n\t{ DAC_CLK_CTRL, DACL_MASK | DACR_MASK, DACL_OFF | DACR_OFF },\n\t{ DAC_CLK_CTRL, DACL_CLK_MASK | DACR_CLK_MASK,\n\t  DACL_CLK_OFF | DACR_CLK_OFF },\n\t{ DAC_CLK_CTRL, DACL_REFV_MASK | DACR_REFV_MASK,\n\t  DACL_REFV_OFF | DACR_REFV_OFF },\n\t{ HPOUT_POP_CTRL, HPOUTR_POP_MASK | HPOUTL_POP_MASK,\n\t  HPOUTR_POP_XCHARGE | HPOUTL_POP_XCHARGE },\n\t{ DAC_PWR_CTRL, DACL_PATH_REFV_MASK | DACR_PATH_REFV_MASK,\n\t  DACL_PATH_REFV_OFF | DACR_PATH_REFV_OFF },\n\t{ DAC_PWR_CTRL, DAC_PWR_MASK, DAC_PWR_OFF },\n\t{ HPMIX_CTRL, HPMIXL_INIT_MASK | HPMIXR_INIT_MASK,\n\t  HPMIXL_INIT_DIS | HPMIXR_INIT_DIS },\n\t{ DAC_CLK_CTRL, DACL_INIT_MASK | DACR_INIT_MASK,\n\t  DACL_INIT_OFF | DACR_INIT_OFF },\n};\n\nstatic int rk3328_codec_close_playback(struct rk3328_codec_priv *rk3328)\n{\n\tsize_t i;\n\n\tgpiod_set_value(rk3328->mute, 1);\n\n\tregmap_update_bits(rk3328->regmap, HPOUTL_GAIN_CTRL,\n\t\t\t   HPOUTL_GAIN_MASK, 0);\n\tregmap_update_bits(rk3328->regmap, HPOUTR_GAIN_CTRL,\n\t\t\t   HPOUTR_GAIN_MASK, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(playback_close_list); i++) {\n\t\tregmap_update_bits(rk3328->regmap,\n\t\t\t\t   playback_close_list[i].reg,\n\t\t\t\t   playback_close_list[i].msk,\n\t\t\t\t   playback_close_list[i].val);\n\t\tmdelay(1);\n\t}\n\n\t \n\trk3328_codec_reset(rk3328);\n\n\tregmap_update_bits(rk3328->regmap, DAC_PRECHARGE_CTRL,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_MASK,\n\t\t\t   DAC_CHARGE_CURRENT_ALL_ON);\n\n\treturn 0;\n}\n\nstatic int rk3328_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tunsigned int val = 0;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tval = DAC_VDL_16BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tval = DAC_VDL_20BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tval = DAC_VDL_24BITS;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval = DAC_VDL_32BITS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tregmap_update_bits(rk3328->regmap, DAC_INIT_CTRL2, DAC_VDL_MASK, val);\n\n\tval = DAC_WL_32BITS | DAC_RST_DIS;\n\tregmap_update_bits(rk3328->regmap, DAC_INIT_CTRL3,\n\t\t\t   DAC_WL_MASK | DAC_RST_MASK, val);\n\n\treturn 0;\n}\n\nstatic int rk3328_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\n\treturn rk3328_codec_open_playback(rk3328);\n}\n\nstatic void rk3328_pcm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\n\trk3328_codec_close_playback(rk3328);\n}\n\nstatic const struct snd_soc_dai_ops rk3328_dai_ops = {\n\t.hw_params = rk3328_hw_params,\n\t.set_fmt = rk3328_set_dai_fmt,\n\t.mute_stream = rk3328_mute_stream,\n\t.startup = rk3328_pcm_startup,\n\t.shutdown = rk3328_pcm_shutdown,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver rk3328_dai[] = {\n\t{\n\t\t.name = \"rk3328-hifi\",\n\t\t.id = RK3328_HIFI,\n\t\t.playback = {\n\t\t\t.stream_name = \"HIFI Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S32_LE),\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HIFI Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t    SNDRV_PCM_FMTBIT_S32_LE),\n\t\t},\n\t\t.ops = &rk3328_dai_ops,\n\t},\n};\n\nstatic int rk3328_codec_probe(struct snd_soc_component *component)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\trk3328_codec_reset(rk3328);\n\trk3328_codec_power_on(rk3328, 0);\n\n\treturn 0;\n}\n\nstatic void rk3328_codec_remove(struct snd_soc_component *component)\n{\n\tstruct rk3328_codec_priv *rk3328 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\trk3328_codec_close_playback(rk3328);\n\trk3328_codec_power_off(rk3328, 0);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_rk3328 = {\n\t.probe = rk3328_codec_probe,\n\t.remove = rk3328_codec_remove,\n};\n\nstatic bool rk3328_codec_write_read_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CODEC_RESET:\n\tcase DAC_INIT_CTRL1:\n\tcase DAC_INIT_CTRL2:\n\tcase DAC_INIT_CTRL3:\n\tcase DAC_PRECHARGE_CTRL:\n\tcase DAC_PWR_CTRL:\n\tcase DAC_CLK_CTRL:\n\tcase HPMIX_CTRL:\n\tcase DAC_SELECT:\n\tcase HPOUT_CTRL:\n\tcase HPOUTL_GAIN_CTRL:\n\tcase HPOUTR_GAIN_CTRL:\n\tcase HPOUT_POP_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rk3328_codec_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CODEC_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rk3328_codec_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n\t.max_register = HPOUT_POP_CTRL,\n\t.writeable_reg = rk3328_codec_write_read_reg,\n\t.readable_reg = rk3328_codec_write_read_reg,\n\t.volatile_reg = rk3328_codec_volatile_reg,\n\t.reg_defaults = rk3328_codec_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rk3328_codec_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int rk3328_platform_probe(struct platform_device *pdev)\n{\n\tstruct device_node *rk3328_np = pdev->dev.of_node;\n\tstruct rk3328_codec_priv *rk3328;\n\tstruct regmap *grf;\n\tvoid __iomem *base;\n\tint ret = 0;\n\n\trk3328 = devm_kzalloc(&pdev->dev, sizeof(*rk3328), GFP_KERNEL);\n\tif (!rk3328)\n\t\treturn -ENOMEM;\n\n\tgrf = syscon_regmap_lookup_by_phandle(rk3328_np,\n\t\t\t\t\t      \"rockchip,grf\");\n\tif (IS_ERR(grf)) {\n\t\tdev_err(&pdev->dev, \"missing 'rockchip,grf'\\n\");\n\t\treturn PTR_ERR(grf);\n\t}\n\t \n\tregmap_write(grf, RK3328_GRF_SOC_CON2,\n\t\t     (BIT(14) << 16 | BIT(14)));\n\n\tret = of_property_read_u32(rk3328_np, \"spk-depop-time-ms\",\n\t\t\t\t   &rk3328->spk_depop_time);\n\tif (ret < 0) {\n\t\tdev_info(&pdev->dev, \"spk_depop_time use default value.\\n\");\n\t\trk3328->spk_depop_time = 200;\n\t}\n\n\trk3328->mute = gpiod_get_optional(&pdev->dev, \"mute\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(rk3328->mute))\n\t\treturn PTR_ERR(rk3328->mute);\n\t \n\tif (!rk3328->mute && of_machine_is_compatible(\"pine64,rock64\")) {\n\t\tdev_warn(&pdev->dev, \"assuming implicit control of GPIO_MUTE; update devicetree if possible\\n\");\n\t\tregmap_write(grf, RK3328_GRF_SOC_CON10, BIT(17) | BIT(1));\n\t}\n\n\trk3328->mclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(rk3328->mclk))\n\t\treturn PTR_ERR(rk3328->mclk);\n\n\tret = clk_prepare_enable(rk3328->mclk);\n\tif (ret)\n\t\treturn ret;\n\tclk_set_rate(rk3328->mclk, INITIAL_FREQ);\n\n\trk3328->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(rk3328->pclk)) {\n\t\tdev_err(&pdev->dev, \"can't get acodec pclk\\n\");\n\t\tret = PTR_ERR(rk3328->pclk);\n\t\tgoto err_unprepare_mclk;\n\t}\n\n\tret = clk_prepare_enable(rk3328->pclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable acodec pclk\\n\");\n\t\tgoto err_unprepare_mclk;\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto err_unprepare_pclk;\n\t}\n\n\trk3328->regmap = devm_regmap_init_mmio(&pdev->dev, base,\n\t\t\t\t\t       &rk3328_codec_regmap_config);\n\tif (IS_ERR(rk3328->regmap)) {\n\t\tret = PTR_ERR(rk3328->regmap);\n\t\tgoto err_unprepare_pclk;\n\t}\n\n\tplatform_set_drvdata(pdev, rk3328);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &soc_codec_rk3328,\n\t\t\t\t\t       rk3328_dai,\n\t\t\t\t\t       ARRAY_SIZE(rk3328_dai));\n\tif (ret)\n\t\tgoto err_unprepare_pclk;\n\n\treturn 0;\n\nerr_unprepare_pclk:\n\tclk_disable_unprepare(rk3328->pclk);\n\nerr_unprepare_mclk:\n\tclk_disable_unprepare(rk3328->mclk);\n\treturn ret;\n}\n\nstatic const struct of_device_id rk3328_codec_of_match[] __maybe_unused = {\n\t\t{ .compatible = \"rockchip,rk3328-codec\", },\n\t\t{},\n};\nMODULE_DEVICE_TABLE(of, rk3328_codec_of_match);\n\nstatic struct platform_driver rk3328_codec_driver = {\n\t.driver = {\n\t\t   .name = \"rk3328-codec\",\n\t\t   .of_match_table = of_match_ptr(rk3328_codec_of_match),\n\t},\n\t.probe = rk3328_platform_probe,\n};\nmodule_platform_driver(rk3328_codec_driver);\n\nMODULE_AUTHOR(\"Sugar Zhang <sugar.zhang@rock-chips.com>\");\nMODULE_DESCRIPTION(\"ASoC rk3328 codec driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}