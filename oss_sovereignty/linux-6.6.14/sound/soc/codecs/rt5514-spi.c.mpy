{
  "module_name": "rt5514-spi.c",
  "hash_id": "3dd1893aa1bc46b2de2af72e898b27fea89eeedb3654f4ebc07e98f998beef1c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt5514-spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/spi/spi.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_qos.h>\n#include <linux/sysfs.h>\n#include <linux/clk.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rt5514-spi.h\"\n\n#define DRV_NAME \"rt5514-spi\"\n\nstatic struct spi_device *rt5514_spi;\n\nstruct rt5514_dsp {\n\tstruct device *dev;\n\tstruct delayed_work copy_work;\n\tstruct mutex dma_lock;\n\tstruct snd_pcm_substream *substream;\n\tunsigned int buf_base, buf_limit, buf_rp;\n\tsize_t buf_size, get_size, dma_offset;\n};\n\nstatic const struct snd_pcm_hardware rt5514_spi_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t.period_bytes_min\t= PAGE_SIZE,\n\t.period_bytes_max\t= 0x20000 / 8,\n\t.periods_min\t\t= 8,\n\t.periods_max\t\t= 8,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= 0x20000,\n};\n\nstatic struct snd_soc_dai_driver rt5514_spi_dai = {\n\t.name = \"rt5514-dsp-cpu-dai\",\n\t.id = 0,\n\t.capture = {\n\t\t.stream_name = \"DSP Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n};\n\nstatic void rt5514_spi_copy_work(struct work_struct *work)\n{\n\tstruct rt5514_dsp *rt5514_dsp =\n\t\tcontainer_of(work, struct rt5514_dsp, copy_work.work);\n\tstruct snd_pcm_runtime *runtime;\n\tsize_t period_bytes, truncated_bytes = 0;\n\tunsigned int cur_wp, remain_data;\n\tu8 buf[8];\n\n\tmutex_lock(&rt5514_dsp->dma_lock);\n\tif (!rt5514_dsp->substream) {\n\t\tdev_err(rt5514_dsp->dev, \"No pcm substream\\n\");\n\t\tgoto done;\n\t}\n\n\truntime = rt5514_dsp->substream->runtime;\n\tperiod_bytes = snd_pcm_lib_period_bytes(rt5514_dsp->substream);\n\tif (!period_bytes) {\n\t\tschedule_delayed_work(&rt5514_dsp->copy_work, 5);\n\t\tgoto done;\n\t}\n\n\tif (rt5514_dsp->buf_size % period_bytes)\n\t\trt5514_dsp->buf_size = (rt5514_dsp->buf_size / period_bytes) *\n\t\t\tperiod_bytes;\n\n\tif (rt5514_dsp->get_size >= rt5514_dsp->buf_size) {\n\t\trt5514_spi_burst_read(RT5514_BUFFER_VOICE_WP, (u8 *)&buf,\n\t\t\tsizeof(buf));\n\t\tcur_wp = buf[0] | buf[1] << 8 | buf[2] << 16 |\n\t\t\t\t\tbuf[3] << 24;\n\n\t\tif (cur_wp >= rt5514_dsp->buf_rp)\n\t\t\tremain_data = (cur_wp - rt5514_dsp->buf_rp);\n\t\telse\n\t\t\tremain_data =\n\t\t\t\t(rt5514_dsp->buf_limit - rt5514_dsp->buf_rp) +\n\t\t\t\t(cur_wp - rt5514_dsp->buf_base);\n\n\t\tif (remain_data < period_bytes) {\n\t\t\tschedule_delayed_work(&rt5514_dsp->copy_work, 5);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (rt5514_dsp->buf_rp + period_bytes <= rt5514_dsp->buf_limit) {\n\t\trt5514_spi_burst_read(rt5514_dsp->buf_rp,\n\t\t\truntime->dma_area + rt5514_dsp->dma_offset,\n\t\t\tperiod_bytes);\n\n\t\tif (rt5514_dsp->buf_rp + period_bytes == rt5514_dsp->buf_limit)\n\t\t\trt5514_dsp->buf_rp = rt5514_dsp->buf_base;\n\t\telse\n\t\t\trt5514_dsp->buf_rp += period_bytes;\n\t} else {\n\t\ttruncated_bytes = rt5514_dsp->buf_limit - rt5514_dsp->buf_rp;\n\t\trt5514_spi_burst_read(rt5514_dsp->buf_rp,\n\t\t\truntime->dma_area + rt5514_dsp->dma_offset,\n\t\t\ttruncated_bytes);\n\n\t\trt5514_spi_burst_read(rt5514_dsp->buf_base,\n\t\t\truntime->dma_area + rt5514_dsp->dma_offset +\n\t\t\ttruncated_bytes, period_bytes - truncated_bytes);\n\n\t\trt5514_dsp->buf_rp = rt5514_dsp->buf_base + period_bytes -\n\t\t\ttruncated_bytes;\n\t}\n\n\trt5514_dsp->get_size += period_bytes;\n\trt5514_dsp->dma_offset += period_bytes;\n\tif (rt5514_dsp->dma_offset >= runtime->dma_bytes)\n\t\trt5514_dsp->dma_offset = 0;\n\n\tsnd_pcm_period_elapsed(rt5514_dsp->substream);\n\n\tschedule_delayed_work(&rt5514_dsp->copy_work, 5);\n\ndone:\n\tmutex_unlock(&rt5514_dsp->dma_lock);\n}\n\nstatic void rt5514_schedule_copy(struct rt5514_dsp *rt5514_dsp)\n{\n\tu8 buf[8];\n\n\tif (!rt5514_dsp->substream)\n\t\treturn;\n\n\trt5514_dsp->get_size = 0;\n\n\t \n\trt5514_spi_burst_read(RT5514_BUFFER_VOICE_BASE, (u8 *)&buf,\n\t\tsizeof(buf));\n\trt5514_dsp->buf_base = buf[0] | buf[1] << 8 | buf[2] << 16 |\n\t\t\t\tbuf[3] << 24;\n\n\trt5514_spi_burst_read(RT5514_BUFFER_VOICE_LIMIT, (u8 *)&buf,\n\t\tsizeof(buf));\n\trt5514_dsp->buf_limit = buf[0] | buf[1] << 8 | buf[2] << 16 |\n\t\t\t\tbuf[3] << 24;\n\n\trt5514_spi_burst_read(RT5514_BUFFER_VOICE_WP, (u8 *)&buf,\n\t\tsizeof(buf));\n\trt5514_dsp->buf_rp = buf[0] | buf[1] << 8 | buf[2] << 16 |\n\t\t\t\tbuf[3] << 24;\n\n\tif (rt5514_dsp->buf_rp % 8)\n\t\trt5514_dsp->buf_rp = (rt5514_dsp->buf_rp / 8) * 8;\n\n\trt5514_dsp->buf_size = rt5514_dsp->buf_limit - rt5514_dsp->buf_base;\n\n\tif (rt5514_dsp->buf_base && rt5514_dsp->buf_limit &&\n\t\trt5514_dsp->buf_rp && rt5514_dsp->buf_size)\n\t\tschedule_delayed_work(&rt5514_dsp->copy_work, 0);\n}\n\nstatic irqreturn_t rt5514_spi_irq(int irq, void *data)\n{\n\tstruct rt5514_dsp *rt5514_dsp = data;\n\n\trt5514_schedule_copy(rt5514_dsp);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int rt5514_spi_pcm_open(struct snd_soc_component *component,\n\t\t\t       struct snd_pcm_substream *substream)\n{\n\tsnd_soc_set_runtime_hwparams(substream, &rt5514_spi_pcm_hardware);\n\n\treturn 0;\n}\n\nstatic int rt5514_spi_hw_params(struct snd_soc_component *component,\n\t\t\t\tstruct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct rt5514_dsp *rt5514_dsp =\n\t\tsnd_soc_component_get_drvdata(component);\n\tu8 buf[8];\n\n\tmutex_lock(&rt5514_dsp->dma_lock);\n\trt5514_dsp->substream = substream;\n\trt5514_dsp->dma_offset = 0;\n\n\t \n\trt5514_spi_burst_read(RT5514_IRQ_CTRL, (u8 *)&buf, sizeof(buf));\n\tif (buf[0] & RT5514_IRQ_STATUS_BIT)\n\t\trt5514_schedule_copy(rt5514_dsp);\n\n\tmutex_unlock(&rt5514_dsp->dma_lock);\n\n\treturn 0;\n}\n\nstatic int rt5514_spi_hw_free(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_substream *substream)\n{\n\tstruct rt5514_dsp *rt5514_dsp =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&rt5514_dsp->dma_lock);\n\trt5514_dsp->substream = NULL;\n\tmutex_unlock(&rt5514_dsp->dma_lock);\n\n\tcancel_delayed_work_sync(&rt5514_dsp->copy_work);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t rt5514_spi_pcm_pointer(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct rt5514_dsp *rt5514_dsp =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\treturn bytes_to_frames(runtime, rt5514_dsp->dma_offset);\n}\n\n\nstatic int rt5514_spi_pcm_probe(struct snd_soc_component *component)\n{\n\tstruct rt5514_dsp *rt5514_dsp;\n\tint ret;\n\n\trt5514_dsp = devm_kzalloc(component->dev, sizeof(*rt5514_dsp),\n\t\t\tGFP_KERNEL);\n\tif (!rt5514_dsp)\n\t\treturn -ENOMEM;\n\n\trt5514_dsp->dev = &rt5514_spi->dev;\n\tmutex_init(&rt5514_dsp->dma_lock);\n\tINIT_DELAYED_WORK(&rt5514_dsp->copy_work, rt5514_spi_copy_work);\n\tsnd_soc_component_set_drvdata(component, rt5514_dsp);\n\n\tif (rt5514_spi->irq) {\n\t\tret = devm_request_threaded_irq(&rt5514_spi->dev,\n\t\t\trt5514_spi->irq, NULL, rt5514_spi_irq,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT, \"rt5514-spi\",\n\t\t\trt5514_dsp);\n\t\tif (ret)\n\t\t\tdev_err(&rt5514_spi->dev,\n\t\t\t\t\"%s Failed to reguest IRQ: %d\\n\", __func__,\n\t\t\t\tret);\n\t\telse\n\t\t\tdevice_init_wakeup(rt5514_dsp->dev, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt5514_spi_pcm_new(struct snd_soc_component *component,\n\t\t\t      struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver rt5514_spi_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.probe\t\t\t= rt5514_spi_pcm_probe,\n\t.open\t\t\t= rt5514_spi_pcm_open,\n\t.hw_params\t\t= rt5514_spi_hw_params,\n\t.hw_free\t\t= rt5514_spi_hw_free,\n\t.pointer\t\t= rt5514_spi_pcm_pointer,\n\t.pcm_construct\t\t= rt5514_spi_pcm_new,\n\t.legacy_dai_naming\t= 1,\n};\n\n \nint rt5514_spi_burst_read(unsigned int addr, u8 *rxbuf, size_t len)\n{\n\tu8 spi_cmd = RT5514_SPI_CMD_BURST_READ;\n\tint status;\n\tu8 write_buf[8];\n\tunsigned int i, end, offset = 0;\n\n\tstruct spi_message message;\n\tstruct spi_transfer x[3];\n\n\twhile (offset < len) {\n\t\tif (offset + RT5514_SPI_BUF_LEN <= len)\n\t\t\tend = RT5514_SPI_BUF_LEN;\n\t\telse\n\t\t\tend = len % RT5514_SPI_BUF_LEN;\n\n\t\twrite_buf[0] = spi_cmd;\n\t\twrite_buf[1] = ((addr + offset) & 0xff000000) >> 24;\n\t\twrite_buf[2] = ((addr + offset) & 0x00ff0000) >> 16;\n\t\twrite_buf[3] = ((addr + offset) & 0x0000ff00) >> 8;\n\t\twrite_buf[4] = ((addr + offset) & 0x000000ff) >> 0;\n\n\t\tspi_message_init(&message);\n\t\tmemset(x, 0, sizeof(x));\n\n\t\tx[0].len = 5;\n\t\tx[0].tx_buf = write_buf;\n\t\tspi_message_add_tail(&x[0], &message);\n\n\t\tx[1].len = 4;\n\t\tx[1].tx_buf = write_buf;\n\t\tspi_message_add_tail(&x[1], &message);\n\n\t\tx[2].len = end;\n\t\tx[2].rx_buf = rxbuf + offset;\n\t\tspi_message_add_tail(&x[2], &message);\n\n\t\tstatus = spi_sync(rt5514_spi, &message);\n\n\t\tif (status)\n\t\t\treturn false;\n\n\t\toffset += RT5514_SPI_BUF_LEN;\n\t}\n\n\tfor (i = 0; i < len; i += 8) {\n\t\twrite_buf[0] = rxbuf[i + 0];\n\t\twrite_buf[1] = rxbuf[i + 1];\n\t\twrite_buf[2] = rxbuf[i + 2];\n\t\twrite_buf[3] = rxbuf[i + 3];\n\t\twrite_buf[4] = rxbuf[i + 4];\n\t\twrite_buf[5] = rxbuf[i + 5];\n\t\twrite_buf[6] = rxbuf[i + 6];\n\t\twrite_buf[7] = rxbuf[i + 7];\n\n\t\trxbuf[i + 0] = write_buf[7];\n\t\trxbuf[i + 1] = write_buf[6];\n\t\trxbuf[i + 2] = write_buf[5];\n\t\trxbuf[i + 3] = write_buf[4];\n\t\trxbuf[i + 4] = write_buf[3];\n\t\trxbuf[i + 5] = write_buf[2];\n\t\trxbuf[i + 6] = write_buf[1];\n\t\trxbuf[i + 7] = write_buf[0];\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(rt5514_spi_burst_read);\n\n \nint rt5514_spi_burst_write(u32 addr, const u8 *txbuf, size_t len)\n{\n\tu8 spi_cmd = RT5514_SPI_CMD_BURST_WRITE;\n\tu8 *write_buf;\n\tunsigned int i, end, offset = 0;\n\n\twrite_buf = kmalloc(RT5514_SPI_BUF_LEN + 6, GFP_KERNEL);\n\n\tif (write_buf == NULL)\n\t\treturn -ENOMEM;\n\n\twhile (offset < len) {\n\t\tif (offset + RT5514_SPI_BUF_LEN <= len)\n\t\t\tend = RT5514_SPI_BUF_LEN;\n\t\telse\n\t\t\tend = len % RT5514_SPI_BUF_LEN;\n\n\t\twrite_buf[0] = spi_cmd;\n\t\twrite_buf[1] = ((addr + offset) & 0xff000000) >> 24;\n\t\twrite_buf[2] = ((addr + offset) & 0x00ff0000) >> 16;\n\t\twrite_buf[3] = ((addr + offset) & 0x0000ff00) >> 8;\n\t\twrite_buf[4] = ((addr + offset) & 0x000000ff) >> 0;\n\n\t\tfor (i = 0; i < end; i += 8) {\n\t\t\twrite_buf[i + 12] = txbuf[offset + i + 0];\n\t\t\twrite_buf[i + 11] = txbuf[offset + i + 1];\n\t\t\twrite_buf[i + 10] = txbuf[offset + i + 2];\n\t\t\twrite_buf[i +  9] = txbuf[offset + i + 3];\n\t\t\twrite_buf[i +  8] = txbuf[offset + i + 4];\n\t\t\twrite_buf[i +  7] = txbuf[offset + i + 5];\n\t\t\twrite_buf[i +  6] = txbuf[offset + i + 6];\n\t\t\twrite_buf[i +  5] = txbuf[offset + i + 7];\n\t\t}\n\n\t\twrite_buf[end + 5] = spi_cmd;\n\n\t\tspi_write(rt5514_spi, write_buf, end + 6);\n\n\t\toffset += RT5514_SPI_BUF_LEN;\n\t}\n\n\tkfree(write_buf);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rt5514_spi_burst_write);\n\nstatic int rt5514_spi_probe(struct spi_device *spi)\n{\n\tint ret;\n\n\trt5514_spi = spi;\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t\t      &rt5514_spi_component,\n\t\t\t\t\t      &rt5514_spi_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(&spi->dev, \"Failed to register component.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt5514_suspend(struct device *dev)\n{\n\tint irq = to_spi_device(dev)->irq;\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt5514_resume(struct device *dev)\n{\n\tstruct rt5514_dsp *rt5514_dsp = dev_get_drvdata(dev);\n\tint irq = to_spi_device(dev)->irq;\n\tu8 buf[8];\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(irq);\n\n\tif (rt5514_dsp) {\n\t\tif (rt5514_dsp->substream) {\n\t\t\trt5514_spi_burst_read(RT5514_IRQ_CTRL, (u8 *)&buf,\n\t\t\t\tsizeof(buf));\n\t\t\tif (buf[0] & RT5514_IRQ_STATUS_BIT)\n\t\t\t\trt5514_schedule_copy(rt5514_dsp);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt5514_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt5514_suspend, rt5514_resume)\n};\n\nstatic const struct of_device_id rt5514_of_match[] = {\n\t{ .compatible = \"realtek,rt5514\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt5514_of_match);\n\nstatic struct spi_driver rt5514_spi_driver = {\n\t.driver = {\n\t\t.name = \"rt5514\",\n\t\t.pm = &rt5514_pm_ops,\n\t\t.of_match_table = of_match_ptr(rt5514_of_match),\n\t},\n\t.probe = rt5514_spi_probe,\n};\nmodule_spi_driver(rt5514_spi_driver);\n\nMODULE_DESCRIPTION(\"RT5514 SPI driver\");\nMODULE_AUTHOR(\"Oder Chiou <oder_chiou@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}