{
  "module_name": "rt715.c",
  "hash_id": "b99f3fad32a197e0bbfba37b206fa8695a33c7ec25ed4999144c054f62150308",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt715.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/hda_verbs.h>\n\n#include \"rt715.h\"\n\nstatic int rt715_index_write(struct regmap *regmap, unsigned int reg,\n\t\tunsigned int value)\n{\n\tint ret;\n\tunsigned int addr = ((RT715_PRIV_INDEX_W_H) << 8) | reg;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to set private value: %08x <= %04x %d\\n\", ret,\n\t\t\taddr, value);\n\t}\n\n\treturn ret;\n}\n\nstatic int rt715_index_write_nid(struct regmap *regmap,\n\t\tunsigned int nid, unsigned int reg, unsigned int value)\n{\n\tint ret;\n\tunsigned int addr = ((RT715_PRIV_INDEX_W_H_2 | nid) << 8) | reg;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to set private value: %06x <= %04x ret=%d\\n\",\n\t\t\taddr, value, ret);\n\n\treturn ret;\n}\n\nstatic int rt715_index_read_nid(struct regmap *regmap,\n\t\tunsigned int nid, unsigned int reg, unsigned int *value)\n{\n\tint ret;\n\tunsigned int addr = ((RT715_PRIV_INDEX_W_H_2 | nid) << 8) | reg;\n\n\t*value = 0;\n\tret = regmap_read(regmap, addr, value);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to get private value: %06x => %04x ret=%d\\n\",\n\t\t\taddr, *value, ret);\n\n\treturn ret;\n}\n\nstatic int rt715_index_update_bits(struct regmap *regmap, unsigned int nid,\n\t\t\tunsigned int reg, unsigned int mask, unsigned int val)\n{\n\tunsigned int tmp, orig;\n\tint ret;\n\n\tret = rt715_index_read_nid(regmap, nid, reg, &orig);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\n\treturn rt715_index_write_nid(regmap, nid, reg, tmp);\n}\n\nstatic void rt715_reset(struct regmap *regmap)\n{\n\tregmap_write(regmap, RT715_FUNC_RESET, 0);\n\trt715_index_update_bits(regmap, RT715_VENDOR_REGISTERS,\n\t\tRT715_VD_CLEAR_CTRL, RT715_CLEAR_HIDDEN_REG,\n\t\tRT715_CLEAR_HIDDEN_REG);\n}\n\n\nstatic void rt715_get_gain(struct rt715_priv *rt715, unsigned int addr_h,\n\t\t\t\tunsigned int addr_l, unsigned int val_h,\n\t\t\t\tunsigned int *r_val, unsigned int *l_val)\n{\n\tint ret;\n\t \n\t*r_val = val_h << 8;\n\tret = regmap_read(rt715->regmap, addr_l, r_val);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to get R channel gain.\\n\");\n\n\t \n\tval_h |= 0x20;\n\t*l_val = val_h << 8;\n\tret = regmap_read(rt715->regmap, addr_h, l_val);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to get L channel gain.\\n\");\n}\n\n \nstatic int rt715_set_amp_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tunsigned int addr_h, addr_l, val_h, val_ll, val_lr;\n\tunsigned int read_ll, read_rl, i;\n\tunsigned int k_vol_changed = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_2ch_vol_ori[i]) {\n\t\t\tk_vol_changed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\taddr_h = mc->reg;\n\taddr_l = mc->rreg;\n\n\tif (mc->shift == RT715_DIR_OUT_SFT)  \n\t\tval_h = 0x80;\n\telse  \n\t\tval_h = 0x0;\n\n\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt715->regmap,\n\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\n\t \n\trt715->kctl_2ch_vol_ori[0] = ucontrol->value.integer.value[0];\n\t \n\tval_ll = ((ucontrol->value.integer.value[0]) & 0x7f);\n\tif (val_ll > mc->max)\n\t\tval_ll = mc->max;\n\t \n\tval_ll |= read_ll & 0x80;\n\n\t \n\trt715->kctl_2ch_vol_ori[1] = ucontrol->value.integer.value[1];\n\t \n\tval_lr = ((ucontrol->value.integer.value[1]) & 0x7f);\n\tif (val_lr > mc->max)\n\t\tval_lr = mc->max;\n\t \n\tval_lr |= read_rl & 0x80;\n\n\tfor (i = 0; i < 3; i++) {  \n\n\t\tif (val_ll == val_lr) {\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (3 << 4);\n\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t(val_h << 8) | val_ll);\n\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t(val_h << 8) | val_ll);\n\t\t} else {\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (1 << 5);\n\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (1 << 4);\n\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t(val_h << 8) | val_lr);\n\t\t}\n\t\t \n\t\tif (mc->shift == RT715_DIR_OUT_SFT)  \n\t\t\tval_h = 0x80;\n\t\telse  \n\t\t\tval_h = 0x0;\n\n\t\trt715_get_gain(rt715, addr_h, addr_l, val_h,\n\t\t\t\t&read_rl, &read_ll);\n\t\tif (read_rl == val_lr && read_ll == val_ll)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt715->regmap,\n\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\treturn k_vol_changed;\n}\n\nstatic int rt715_set_amp_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int addr_h, addr_l, val_h;\n\tunsigned int read_ll, read_rl;\n\n\taddr_h = mc->reg;\n\taddr_l = mc->rreg;\n\tif (mc->shift == RT715_DIR_OUT_SFT)  \n\t\tval_h = 0x80;\n\telse  \n\t\tval_h = 0x0;\n\n\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\tif (mc->invert) {\n\t\t \n\t\tread_ll = !(read_ll & 0x80);\n\t\tread_rl = !(read_rl & 0x80);\n\t} else {\n\t\t \n\t\tread_ll = read_ll & 0x7f;\n\t\tread_rl = read_rl & 0x7f;\n\t}\n\tucontrol->value.integer.value[0] = read_ll;\n\tucontrol->value.integer.value[1] = read_rl;\n\n\treturn 0;\n}\n\nstatic int rt715_set_main_switch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstatic const unsigned int capture_reg_H[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_H, RT715_SET_GAIN_LINE_ADC_H,\n\t\tRT715_SET_GAIN_MIX_ADC_H, RT715_SET_GAIN_MIX_ADC2_H };\n\tstatic const unsigned int capture_reg_L[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_L, RT715_SET_GAIN_LINE_ADC_L,\n\t\tRT715_SET_GAIN_MIX_ADC_L, RT715_SET_GAIN_MIX_ADC2_L };\n\tunsigned int addr_h, addr_l, val_h = 0x0, val_ll, val_lr;\n\tunsigned int k_shift = RT715_DIR_IN_SFT, k_changed = 0;\n\tunsigned int read_ll, read_rl, i, j, loop_cnt = 4;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_8ch_switch_ori[i])\n\t\t\tk_changed = 1;\n\t}\n\n\tfor (j = 0; j < loop_cnt; j++) {\n\t\t \n\t\taddr_h = capture_reg_H[j];\n\t\taddr_l = capture_reg_L[j];\n\t\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\t\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\t\tregmap_write(rt715->regmap,\n\t\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\n\t\t \n\t\t \n\t\trt715->kctl_8ch_switch_ori[j * 2] =\n\t\t\tucontrol->value.integer.value[j * 2];\n\t\tval_ll = (!ucontrol->value.integer.value[j * 2]) << 7;\n\t\t \n\t\tval_ll |= read_ll & 0x7f;\n\n\t\t \n\t\t \n\t\trt715->kctl_8ch_switch_ori[j * 2 + 1] =\n\t\t\tucontrol->value.integer.value[j * 2 + 1];\n\t\tval_lr = (!ucontrol->value.integer.value[j * 2 + 1]) << 7;\n\t\t \n\t\tval_lr |= read_rl & 0x7f;\n\n\t\tfor (i = 0; i < 3; i++) {  \n\n\t\t\tif (val_ll == val_lr) {\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (3 << 4);\n\t\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (1 << 5);\n\t\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (1 << 4);\n\t\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t\t(val_h << 8) | val_lr);\n\t\t\t}\n\t\t\tval_h = 0x0;\n\t\t\trt715_get_gain(rt715, addr_h, addr_l, val_h,\n\t\t\t\t\t&read_rl, &read_ll);\n\t\t\tif (read_rl == val_lr && read_ll == val_ll)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt715->regmap,\n\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\treturn k_changed;\n}\n\nstatic int rt715_set_main_switch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstatic const unsigned int capture_reg_H[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_H, RT715_SET_GAIN_LINE_ADC_H,\n\t\tRT715_SET_GAIN_MIX_ADC_H, RT715_SET_GAIN_MIX_ADC2_H };\n\tstatic const unsigned int capture_reg_L[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_L, RT715_SET_GAIN_LINE_ADC_L,\n\t\tRT715_SET_GAIN_MIX_ADC_L, RT715_SET_GAIN_MIX_ADC2_L };\n\tunsigned int addr_h, addr_l, val_h = 0x0, i, loop_cnt = 4;\n\tunsigned int read_ll, read_rl;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\taddr_h = capture_reg_H[i];\n\t\taddr_l = capture_reg_L[i];\n\t\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\t\tucontrol->value.integer.value[i * 2] = !(read_ll & 0x80);\n\t\tucontrol->value.integer.value[i * 2 + 1] = !(read_rl & 0x80);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt715_set_main_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstatic const unsigned int capture_reg_H[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_H, RT715_SET_GAIN_LINE_ADC_H,\n\t\tRT715_SET_GAIN_MIX_ADC_H, RT715_SET_GAIN_MIX_ADC2_H };\n\tstatic const unsigned int capture_reg_L[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_L, RT715_SET_GAIN_LINE_ADC_L,\n\t\tRT715_SET_GAIN_MIX_ADC_L, RT715_SET_GAIN_MIX_ADC2_L};\n\tunsigned int addr_h, addr_l, val_h = 0x0, val_ll, val_lr;\n\tunsigned int read_ll, read_rl, i, j, loop_cnt = 4, k_changed = 0;\n\tunsigned int k_shift = RT715_DIR_IN_SFT, k_max = 0x3f;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_8ch_vol_ori[i])\n\t\t\tk_changed = 1;\n\t}\n\n\tfor (j = 0; j < loop_cnt; j++) {\n\t\taddr_h = capture_reg_H[j];\n\t\taddr_l = capture_reg_L[j];\n\t\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\t\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\t\tregmap_write(rt715->regmap,\n\t\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\n\t\t \n\t\t \n\t\trt715->kctl_8ch_vol_ori[j * 2] = ucontrol->value.integer.value[j * 2];\n\t\tval_ll = ((ucontrol->value.integer.value[j * 2]) & 0x7f);\n\t\tif (val_ll > k_max)\n\t\t\tval_ll = k_max;\n\t\t \n\t\tval_ll |= read_ll & 0x80;\n\n\t\t \n\t\t \n\t\trt715->kctl_8ch_vol_ori[j * 2 + 1] =\n\t\t\tucontrol->value.integer.value[j * 2 + 1];\n\t\tval_lr = ((ucontrol->value.integer.value[j * 2 + 1]) & 0x7f);\n\t\tif (val_lr > k_max)\n\t\t\tval_lr = k_max;\n\t\t \n\t\tval_lr |= read_rl & 0x80;\n\n\t\tfor (i = 0; i < 3; i++) {  \n\t\t\tif (val_ll == val_lr) {\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (3 << 4);\n\t\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (1 << 5);\n\t\t\t\tregmap_write(rt715->regmap, addr_h,\n\t\t\t\t\t(val_h << 8) | val_ll);\n\t\t\t\t \n\t\t\t\tval_h = (1 << k_shift) | (1 << 4);\n\t\t\t\tregmap_write(rt715->regmap, addr_l,\n\t\t\t\t\t(val_h << 8) | val_lr);\n\t\t\t}\n\t\t\tval_h = 0x0;\n\t\t\trt715_get_gain(rt715, addr_h, addr_l, val_h,\n\t\t\t\t\t&read_rl, &read_ll);\n\t\t\tif (read_rl == val_lr && read_ll == val_ll)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt715->regmap,\n\t\t\t\tRT715_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\treturn k_changed;\n}\n\nstatic int rt715_set_main_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstatic const unsigned int capture_reg_H[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_H, RT715_SET_GAIN_LINE_ADC_H,\n\t\tRT715_SET_GAIN_MIX_ADC_H, RT715_SET_GAIN_MIX_ADC2_H };\n\tstatic const unsigned int capture_reg_L[] = {\n\t\tRT715_SET_GAIN_MIC_ADC_L, RT715_SET_GAIN_LINE_ADC_L,\n\t\tRT715_SET_GAIN_MIX_ADC_L, RT715_SET_GAIN_MIX_ADC2_L };\n\tunsigned int addr_h, addr_l, val_h = 0x0, i, loop_cnt = 4;\n\tunsigned int read_ll, read_rl;\n\n\tfor (i = 0; i < loop_cnt; i++) {\n\t\taddr_h = capture_reg_H[i];\n\t\taddr_l = capture_reg_L[i];\n\t\trt715_get_gain(rt715, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\t\tucontrol->value.integer.value[i * 2] = read_ll & 0x7f;\n\t\tucontrol->value.integer.value[i * 2 + 1] = read_rl & 0x7f;\n\t}\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(in_vol_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic int rt715_switch_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 8;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int rt715_vol_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 8;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0x3f;\n\treturn 0;\n}\n\n#define SOC_DOUBLE_R_EXT(xname, reg_left, reg_right, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n\n#define RT715_MAIN_SWITCH_EXT(xname, xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = rt715_switch_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n}\n\n#define RT715_MAIN_VOL_EXT_TLV(xname, xhandler_get, xhandler_put, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = rt715_vol_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n}\n\nstatic const struct snd_kcontrol_new rt715_snd_controls[] = {\n\t \n\tRT715_MAIN_SWITCH_EXT(\"Capture Switch\",\n\t\t\trt715_set_main_switch_get, rt715_set_main_switch_put),\n\t \n\tRT715_MAIN_VOL_EXT_TLV(\"Capture Volume\",\n\t\t\trt715_set_main_vol_get, rt715_set_main_vol_put, in_vol_tlv),\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"DMIC1 Boost\", RT715_SET_GAIN_DMIC1_H,\n\t\t\tRT715_SET_GAIN_DMIC1_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"DMIC2 Boost\", RT715_SET_GAIN_DMIC2_H,\n\t\t\tRT715_SET_GAIN_DMIC2_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"DMIC3 Boost\", RT715_SET_GAIN_DMIC3_H,\n\t\t\tRT715_SET_GAIN_DMIC3_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"DMIC4 Boost\", RT715_SET_GAIN_DMIC4_H,\n\t\t\tRT715_SET_GAIN_DMIC4_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"MIC1 Boost\", RT715_SET_GAIN_MIC1_H,\n\t\t\tRT715_SET_GAIN_MIC1_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"MIC2 Boost\", RT715_SET_GAIN_MIC2_H,\n\t\t\tRT715_SET_GAIN_MIC2_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"LINE1 Boost\", RT715_SET_GAIN_LINE1_H,\n\t\t\tRT715_SET_GAIN_LINE1_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"LINE2 Boost\", RT715_SET_GAIN_LINE2_H,\n\t\t\tRT715_SET_GAIN_LINE2_L, RT715_DIR_IN_SFT, 3, 0,\n\t\t\trt715_set_amp_gain_get, rt715_set_amp_gain_put,\n\t\t\tmic_vol_tlv),\n};\n\nstatic int rt715_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int reg, val;\n\tint ret;\n\n\t \n\treg = RT715_VERB_SET_CONNECT_SEL | e->reg;\n\tret = regmap_read(rt715->regmap, reg, &val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"%s: sdw read failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((e->reg == RT715_MUX_IN3 || e->reg == RT715_MUX_IN4) && (val > 0))\n\t\tval -= 1;\n\tucontrol->value.enumerated.item[0] = val;\n\n\treturn 0;\n}\n\nstatic int rt715_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\t\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, val2 = 0, change, reg;\n\tint ret;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\t \n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\treg = RT715_VERB_SET_CONNECT_SEL | e->reg;\n\tret = regmap_read(rt715->regmap, reg, &val2);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"%s: sdw read failed: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tif (val == val2)\n\t\tchange = 0;\n\telse\n\t\tchange = 1;\n\n\tif (change) {\n\t\treg = RT715_VERB_SET_CONNECT_SEL | e->reg;\n\t\tregmap_write(rt715->regmap, reg, val);\n\t}\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\t\t\t\t\titem[0], e, NULL);\n\n\treturn change;\n}\n\nstatic const char * const adc_22_23_mux_text[] = {\n\t\"MIC1\",\n\t\"MIC2\",\n\t\"LINE1\",\n\t\"LINE2\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\n \nstatic const unsigned int rt715_adc_24_25_values[] = {\n\t0,\n\t2,\n\t3,\n\t4,\n\t5,\n};\n\nstatic const char * const adc_24_mux_text[] = {\n\t\"MIC2\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\nstatic const char * const adc_25_mux_text[] = {\n\t\"MIC1\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt715_adc22_enum, RT715_MUX_IN1, 0, adc_22_23_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt715_adc23_enum, RT715_MUX_IN2, 0, adc_22_23_mux_text);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(rt715_adc24_enum,\n\tRT715_MUX_IN3, 0, 0xf,\n\tadc_24_mux_text, rt715_adc_24_25_values);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(rt715_adc25_enum,\n\tRT715_MUX_IN4, 0, 0xf,\n\tadc_25_mux_text, rt715_adc_24_25_values);\n\nstatic const struct snd_kcontrol_new rt715_adc22_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 22 Mux\", rt715_adc22_enum,\n\t\t\trt715_mux_get, rt715_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc23_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 23 Mux\", rt715_adc23_enum,\n\t\t\trt715_mux_get, rt715_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc24_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 24 Mux\", rt715_adc24_enum,\n\t\t\trt715_mux_get, rt715_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc25_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 25 Mux\", rt715_adc25_enum,\n\t\t\trt715_mux_get, rt715_mux_put);\n\nstatic const struct snd_soc_dapm_widget rt715_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC3\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC4\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2\"),\n\tSND_SOC_DAPM_ADC(\"ADC 07\", NULL, RT715_SET_STREAMID_MIC_ADC, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 08\", NULL, RT715_SET_STREAMID_LINE_ADC, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 09\", NULL, RT715_SET_STREAMID_MIX_ADC, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 27\", NULL, RT715_SET_STREAMID_MIX_ADC2, 4, 0),\n\tSND_SOC_DAPM_MUX(\"ADC 22 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc22_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 23 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc23_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 24 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc24_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 25 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc25_mux),\n\tSND_SOC_DAPM_AIF_OUT(\"DP4TX\", \"DP4 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP6TX\", \"DP6 Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route rt715_audio_map[] = {\n\t{\"DP6TX\", NULL, \"ADC 09\"},\n\t{\"DP6TX\", NULL, \"ADC 08\"},\n\t{\"DP4TX\", NULL, \"ADC 07\"},\n\t{\"DP4TX\", NULL, \"ADC 27\"},\n\t{\"ADC 09\", NULL, \"ADC 22 Mux\"},\n\t{\"ADC 08\", NULL, \"ADC 23 Mux\"},\n\t{\"ADC 07\", NULL, \"ADC 24 Mux\"},\n\t{\"ADC 27\", NULL, \"ADC 25 Mux\"},\n\t{\"ADC 22 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 22 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 22 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 22 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 22 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 22 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 22 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 22 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 23 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 23 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 23 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 23 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 23 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 23 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 23 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 23 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 24 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 24 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 24 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 24 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 24 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 25 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 25 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 25 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 25 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 25 Mux\", \"DMIC4\", \"DMIC4\"},\n};\n\nstatic int rt715_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (dapm->bias_level == SND_SOC_BIAS_STANDBY) {\n\t\t\tregmap_write(rt715->regmap,\n\t\t\t\t\t\tRT715_SET_AUDIO_POWER_STATE,\n\t\t\t\t\t\tAC_PWRST_D0);\n\t\t\tmsleep(RT715_POWER_UP_DELAY_MS);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_write(rt715->regmap,\n\t\t\t\t\tRT715_SET_AUDIO_POWER_STATE,\n\t\t\t\t\tAC_PWRST_D3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tdapm->bias_level = level;\n\treturn 0;\n}\n\nstatic int rt715_probe(struct snd_soc_component *component)\n{\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (!rt715->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_rt715 = {\n\t.probe = rt715_probe,\n\t.set_bias_level = rt715_set_bias_level,\n\t.controls = rt715_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt715_snd_controls),\n\t.dapm_widgets = rt715_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt715_dapm_widgets),\n\t.dapm_routes = rt715_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rt715_audio_map),\n\t.endianness = 1,\n};\n\nstatic int rt715_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt715_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt715_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval;\n\tunsigned int val = 0;\n\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt715->slave)\n\t\treturn -EINVAL;\n\n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tswitch (dai->id) {\n\tcase RT715_AIF1:\n\t\tport_config.num = 6;\n\t\trt715_index_write(rt715->regmap, RT715_SDW_INPUT_SEL, 0xa500);\n\t\tbreak;\n\tcase RT715_AIF2:\n\t\tport_config.num = 4;\n\t\trt715_index_write(rt715->regmap, RT715_SDW_INPUT_SEL, 0xa000);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI id %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = sdw_stream_add_slave(rt715->slave, &stream_config,\n\t\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\tswitch (params_rate(params)) {\n\t \n\t \n\tcase 44100:\n\t\tval |= 0x40 << 8;\n\t\tbreak;\n\tcase 48000:\n\t\tval |= 0x0 << 8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample rate %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_channels(params) <= 16) {\n\t\t \n\t\tval |= (params_channels(params) - 1);\n\t} else {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\t \n\tcase 8:\n\t\tbreak;\n\tcase 16:\n\t\tval |= (0x1 << 4);\n\t\tbreak;\n\tcase 20:\n\t\tval |= (0x2 << 4);\n\t\tbreak;\n\tcase 24:\n\t\tval |= (0x3 << 4);\n\t\tbreak;\n\tcase 32:\n\t\tval |= (0x4 << 4);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(rt715->regmap, RT715_MIC_ADC_FORMAT_H, val);\n\tregmap_write(rt715->regmap, RT715_MIC_LINE_FORMAT_H, val);\n\tregmap_write(rt715->regmap, RT715_MIX_ADC_FORMAT_H, val);\n\tregmap_write(rt715->regmap, RT715_MIX_ADC2_FORMAT_H, val);\n\n\treturn retval;\n}\n\nstatic int rt715_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt715_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt715->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt715->slave, sdw_stream);\n\treturn 0;\n}\n\n#define RT715_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define RT715_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt715_ops = {\n\t.hw_params\t= rt715_pcm_hw_params,\n\t.hw_free\t= rt715_pcm_hw_free,\n\t.set_stream\t= rt715_set_sdw_stream,\n\t.shutdown\t= rt715_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt715_dai[] = {\n\t{\n\t\t.name = \"rt715-aif1\",\n\t\t.id = RT715_AIF1,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP6 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT715_STEREO_RATES,\n\t\t\t.formats = RT715_FORMATS,\n\t\t},\n\t\t.ops = &rt715_ops,\n\t},\n\t{\n\t\t.name = \"rt715-aif2\",\n\t\t.id = RT715_AIF2,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP4 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT715_STEREO_RATES,\n\t\t\t.formats = RT715_FORMATS,\n\t\t},\n\t\t.ops = &rt715_ops,\n\t},\n};\n\n \n#define RT715_CLK_FREQ_9600000HZ 9600000\n#define RT715_CLK_FREQ_12000000HZ 12000000\n#define RT715_CLK_FREQ_6000000HZ 6000000\n#define RT715_CLK_FREQ_4800000HZ 4800000\n#define RT715_CLK_FREQ_2400000HZ 2400000\n#define RT715_CLK_FREQ_12288000HZ 12288000\n\nint rt715_clock_config(struct device *dev)\n{\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned int clk_freq, value;\n\n\tclk_freq = (rt715->params.curr_dr_freq >> 1);\n\n\tswitch (clk_freq) {\n\tcase RT715_CLK_FREQ_12000000HZ:\n\t\tvalue = 0x0;\n\t\tbreak;\n\tcase RT715_CLK_FREQ_6000000HZ:\n\t\tvalue = 0x1;\n\t\tbreak;\n\tcase RT715_CLK_FREQ_9600000HZ:\n\t\tvalue = 0x2;\n\t\tbreak;\n\tcase RT715_CLK_FREQ_4800000HZ:\n\t\tvalue = 0x3;\n\t\tbreak;\n\tcase RT715_CLK_FREQ_2400000HZ:\n\t\tvalue = 0x4;\n\t\tbreak;\n\tcase RT715_CLK_FREQ_12288000HZ:\n\t\tvalue = 0x5;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(rt715->regmap, 0xe0, value);\n\tregmap_write(rt715->regmap, 0xf0, value);\n\n\treturn 0;\n}\n\nint rt715_init(struct device *dev, struct regmap *sdw_regmap,\n\tstruct regmap *regmap, struct sdw_slave *slave)\n{\n\tstruct rt715_priv *rt715;\n\tint ret;\n\n\trt715 = devm_kzalloc(dev, sizeof(*rt715), GFP_KERNEL);\n\tif (!rt715)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt715);\n\trt715->slave = slave;\n\trt715->regmap = regmap;\n\trt715->sdw_regmap = sdw_regmap;\n\n\tregcache_cache_only(rt715->regmap, true);\n\n\t \n\trt715->hw_init = false;\n\trt715->first_hw_init = false;\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t\t\t\t&soc_codec_dev_rt715,\n\t\t\t\t\t\trt715_dai,\n\t\t\t\t\t\tARRAY_SIZE(rt715_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\treturn 0;\n}\n\nint rt715_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\n\tif (rt715->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt715->regmap, false);\n\n\t \n\tif (!rt715->first_hw_init)\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\trt715_reset(rt715->regmap);\n\n\t \n\tregmap_write(rt715->regmap, RT715_SET_GAIN_LINE_ADC_H, 0xb080);\n\tregmap_write(rt715->regmap, RT715_SET_GAIN_MIX_ADC_H, 0xb080);\n\t \n\tregmap_write(rt715->regmap, RT715_SET_GAIN_MIC_ADC_H, 0xb080);\n\tregmap_write(rt715->regmap, RT715_SET_GAIN_MIX_ADC2_H, 0xb080);\n\n\t \n\tregmap_write(rt715->regmap, RT715_SET_PIN_DMIC1, 0x20);\n\tregmap_write(rt715->regmap, RT715_SET_PIN_DMIC2, 0x20);\n\tregmap_write(rt715->regmap, RT715_SET_PIN_DMIC3, 0x20);\n\tregmap_write(rt715->regmap, RT715_SET_PIN_DMIC4, 0x20);\n\t \n\tregmap_write(rt715->regmap, RT715_SET_STREAMID_LINE_ADC, 0x10);\n\tregmap_write(rt715->regmap, RT715_SET_STREAMID_MIX_ADC, 0x10);\n\tregmap_write(rt715->regmap, RT715_SET_STREAMID_MIC_ADC, 0x10);\n\tregmap_write(rt715->regmap, RT715_SET_STREAMID_MIX_ADC2, 0x10);\n\t \n\tregmap_write(rt715->regmap, RT715_SET_DMIC1_CONFIG_DEFAULT1, 0xd0);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC1_CONFIG_DEFAULT2, 0x11);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC1_CONFIG_DEFAULT3, 0xa1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC1_CONFIG_DEFAULT4, 0x81);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC2_CONFIG_DEFAULT1, 0xd1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC2_CONFIG_DEFAULT2, 0x11);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC2_CONFIG_DEFAULT3, 0xa1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC2_CONFIG_DEFAULT4, 0x81);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC3_CONFIG_DEFAULT1, 0xd0);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC3_CONFIG_DEFAULT2, 0x11);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC3_CONFIG_DEFAULT3, 0xa1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC3_CONFIG_DEFAULT4, 0x81);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC4_CONFIG_DEFAULT1, 0xd1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC4_CONFIG_DEFAULT2, 0x11);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC4_CONFIG_DEFAULT3, 0xa1);\n\tregmap_write(rt715->regmap, RT715_SET_DMIC4_CONFIG_DEFAULT4, 0x81);\n\n\t \n\tregmap_write(rt715->regmap, RT715_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\n\tif (rt715->first_hw_init)\n\t\tregcache_mark_dirty(rt715->regmap);\n\telse\n\t\trt715->first_hw_init = true;\n\n\t \n\trt715->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"ASoC rt715 driver\");\nMODULE_DESCRIPTION(\"ASoC rt715 driver SDW\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}