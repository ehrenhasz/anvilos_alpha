{
  "module_name": "cs4265.c",
  "hash_id": "a672b1c5ce34ad26c85403b24e29bf45d614a911011e554bcf721f0379f68c79",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4265.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include \"cs4265.h\"\n\nstruct cs4265_private {\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpio;\n\tu8 format;\n\tu32 sysclk;\n};\n\nstatic const struct reg_default cs4265_reg_defaults[] = {\n\t{ CS4265_PWRCTL, 0x0F },\n\t{ CS4265_DAC_CTL, 0x08 },\n\t{ CS4265_ADC_CTL, 0x00 },\n\t{ CS4265_MCLK_FREQ, 0x00 },\n\t{ CS4265_SIG_SEL, 0x40 },\n\t{ CS4265_CHB_PGA_CTL, 0x00 },\n\t{ CS4265_CHA_PGA_CTL, 0x00 },\n\t{ CS4265_ADC_CTL2, 0x19 },\n\t{ CS4265_DAC_CHA_VOL, 0x00 },\n\t{ CS4265_DAC_CHB_VOL, 0x00 },\n\t{ CS4265_DAC_CTL2, 0xC0 },\n\t{ CS4265_SPDIF_CTL1, 0x00 },\n\t{ CS4265_SPDIF_CTL2, 0x00 },\n\t{ CS4265_INT_MASK, 0x00 },\n\t{ CS4265_STATUS_MODE_MSB, 0x00 },\n\t{ CS4265_STATUS_MODE_LSB, 0x00 },\n};\n\nstatic bool cs4265_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4265_CHIP_ID ... CS4265_MAX_REGISTER:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs4265_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4265_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(pga_tlv, -1200, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 0);\n\nstatic const char * const digital_input_mux_text[] = {\n\t\"SDIN1\", \"SDIN2\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(digital_input_mux_enum, CS4265_SIG_SEL, 7,\n\t\tdigital_input_mux_text);\n\nstatic const struct snd_kcontrol_new digital_input_mux =\n\tSOC_DAPM_ENUM(\"Digital Input Mux\", digital_input_mux_enum);\n\nstatic const char * const mic_linein_text[] = {\n\t\"MIC\", \"LINEIN\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(mic_linein_enum, CS4265_ADC_CTL2, 0,\n\t\tmic_linein_text);\n\nstatic const char * const cam_mode_text[] = {\n\t\"One Byte\", \"Two Byte\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(cam_mode_enum, CS4265_SPDIF_CTL1, 5,\n\t\tcam_mode_text);\n\nstatic const char * const cam_mono_stereo_text[] = {\n\t\"Stereo\", \"Mono\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(spdif_mono_stereo_enum, CS4265_SPDIF_CTL2, 2,\n\t\tcam_mono_stereo_text);\n\nstatic const char * const mono_select_text[] = {\n\t\"Channel A\", \"Channel B\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(spdif_mono_select_enum, CS4265_SPDIF_CTL2, 0,\n\t\tmono_select_text);\n\nstatic const struct snd_kcontrol_new mic_linein_mux =\n\tSOC_DAPM_ENUM(\"ADC Input Capture Mux\", mic_linein_enum);\n\nstatic const struct snd_kcontrol_new loopback_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS4265_SIG_SEL, 1, 1, 0);\n\nstatic const struct snd_kcontrol_new spdif_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", SND_SOC_NOPM, 0, 0, 0);\n\nstatic const struct snd_kcontrol_new dac_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", CS4265_PWRCTL, 1, 1, 0);\n\nstatic const struct snd_kcontrol_new cs4265_snd_controls[] = {\n\n\tSOC_DOUBLE_R_SX_TLV(\"PGA Volume\", CS4265_CHA_PGA_CTL,\n\t\t\t      CS4265_CHB_PGA_CTL, 0, 0x28, 0x30, pga_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC Volume\", CS4265_DAC_CHA_VOL,\n\t\t      CS4265_DAC_CHB_VOL, 0, 0xFF, 1, dac_tlv),\n\tSOC_SINGLE(\"De-emp 44.1kHz Switch\", CS4265_DAC_CTL, 1,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"DAC INV Switch\", CS4265_DAC_CTL2, 5,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"DAC Zero Cross Switch\", CS4265_DAC_CTL2, 6,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"DAC Soft Ramp Switch\", CS4265_DAC_CTL2, 7,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"ADC HPF Switch\", CS4265_ADC_CTL, 1,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"ADC Zero Cross Switch\", CS4265_ADC_CTL2, 3,\n\t\t\t\t1, 1),\n\tSOC_SINGLE(\"ADC Soft Ramp Switch\", CS4265_ADC_CTL2, 7,\n\t\t\t\t1, 0),\n\tSOC_SINGLE(\"E to F Buffer Disable Switch\", CS4265_SPDIF_CTL1,\n\t\t\t\t6, 1, 0),\n\tSOC_ENUM(\"C Data Access\", cam_mode_enum),\n\tSOC_SINGLE(\"Validity Bit Control Switch\", CS4265_SPDIF_CTL2,\n\t\t\t\t3, 1, 0),\n\tSOC_ENUM(\"SPDIF Mono/Stereo\", spdif_mono_stereo_enum),\n\tSOC_SINGLE(\"MMTLR Data Switch\", CS4265_SPDIF_CTL2, 0, 1, 0),\n\tSOC_ENUM(\"Mono Channel Select\", spdif_mono_select_enum),\n\tSND_SOC_BYTES(\"C Data Buffer\", CS4265_C_DATA_BUFF, 24),\n};\n\nstatic const struct snd_soc_dapm_widget cs4265_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_INPUT(\"LINEINL\"),\n\tSND_SOC_DAPM_INPUT(\"LINEINR\"),\n\tSND_SOC_DAPM_INPUT(\"MICL\"),\n\tSND_SOC_DAPM_INPUT(\"MICR\"),\n\n\tSND_SOC_DAPM_AIF_OUT(\"DOUT\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"SPDIFOUT\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"ADC Mux\", SND_SOC_NOPM, 0, 0, &mic_linein_mux),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", NULL, CS4265_PWRCTL, 2, 1),\n\tSND_SOC_DAPM_PGA(\"Pre-amp MIC\", CS4265_PWRCTL, 3,\n\t\t\t1, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &digital_input_mux),\n\n\tSND_SOC_DAPM_MIXER(\"SDIN1 Input Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"SDIN2 Input Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"SPDIF Transmitter\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&loopback_ctl),\n\tSND_SOC_DAPM_SWITCH(\"SPDIF\", CS4265_SPDIF_CTL2, 5, 1,\n\t\t\t&spdif_switch),\n\tSND_SOC_DAPM_SWITCH(\"DAC\", CS4265_PWRCTL, 1, 1,\n\t\t\t&dac_switch),\n\n\tSND_SOC_DAPM_AIF_IN(\"DIN1\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DIN2\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"TXIN\", NULL,  0,\n\t\t\tCS4265_SPDIF_CTL2, 5, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"LINEOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINEOUTR\"),\n\n};\n\nstatic const struct snd_soc_dapm_route cs4265_audio_map[] = {\n\n\t{\"DIN1\", NULL, \"DAI1 Playback\"},\n\t{\"DIN2\", NULL, \"DAI2 Playback\"},\n\t{\"SDIN1 Input Mixer\", NULL, \"DIN1\"},\n\t{\"SDIN2 Input Mixer\", NULL, \"DIN2\"},\n\t{\"Input Mux\", \"SDIN1\", \"SDIN1 Input Mixer\"},\n\t{\"Input Mux\", \"SDIN2\", \"SDIN2 Input Mixer\"},\n\t{\"DAC\", \"Switch\", \"Input Mux\"},\n\t{\"SPDIF\", \"Switch\", \"Input Mux\"},\n\t{\"LINEOUTL\", NULL, \"DAC\"},\n\t{\"LINEOUTR\", NULL, \"DAC\"},\n\t{\"SPDIFOUT\", NULL, \"SPDIF\"},\n\n\t{\"Pre-amp MIC\", NULL, \"MICL\"},\n\t{\"Pre-amp MIC\", NULL, \"MICR\"},\n\t{\"ADC Mux\", \"MIC\", \"Pre-amp MIC\"},\n\t{\"ADC Mux\", \"LINEIN\", \"LINEINL\"},\n\t{\"ADC Mux\", \"LINEIN\", \"LINEINR\"},\n\t{\"ADC\", NULL, \"ADC Mux\"},\n\t{\"DOUT\", NULL, \"ADC\"},\n\t{\"DAI1 Capture\", NULL, \"DOUT\"},\n\t{\"DAI2 Capture\", NULL, \"DOUT\"},\n\n\t \n\t{\"Loopback\", \"Switch\", \"ADC\"},\n\t{\"DAC\", NULL, \"Loopback\"},\n};\n\nstruct cs4265_clk_para {\n\tu32 mclk;\n\tu32 rate;\n\tu8 fm_mode;  \n\tu8 mclkdiv;\n};\n\nstatic const struct cs4265_clk_para clk_map_table[] = {\n\t \n\t{8192000, 32000, 0, 0},\n\t{12288000, 32000, 0, 1},\n\t{16384000, 32000, 0, 2},\n\t{24576000, 32000, 0, 3},\n\t{32768000, 32000, 0, 4},\n\n\t \n\t{11289600, 44100, 0, 0},\n\t{16934400, 44100, 0, 1},\n\t{22579200, 44100, 0, 2},\n\t{33868000, 44100, 0, 3},\n\t{45158400, 44100, 0, 4},\n\n\t \n\t{12288000, 48000, 0, 0},\n\t{18432000, 48000, 0, 1},\n\t{24576000, 48000, 0, 2},\n\t{36864000, 48000, 0, 3},\n\t{49152000, 48000, 0, 4},\n\n\t \n\t{8192000, 64000, 1, 0},\n\t{12288000, 64000, 1, 1},\n\t{16934400, 64000, 1, 2},\n\t{24576000, 64000, 1, 3},\n\t{32768000, 64000, 1, 4},\n\n\t \n\t{11289600, 88200, 1, 0},\n\t{16934400, 88200, 1, 1},\n\t{22579200, 88200, 1, 2},\n\t{33868000, 88200, 1, 3},\n\t{45158400, 88200, 1, 4},\n\n\t \n\t{12288000, 96000, 1, 0},\n\t{18432000, 96000, 1, 1},\n\t{24576000, 96000, 1, 2},\n\t{36864000, 96000, 1, 3},\n\t{49152000, 96000, 1, 4},\n\n\t \n\t{8192000, 128000, 2, 0},\n\t{12288000, 128000, 2, 1},\n\t{16934400, 128000, 2, 2},\n\t{24576000, 128000, 2, 3},\n\t{32768000, 128000, 2, 4},\n\n\t \n\t{11289600, 176400, 2, 0},\n\t{16934400, 176400, 2, 1},\n\t{22579200, 176400, 2, 2},\n\t{33868000, 176400, 2, 3},\n\t{49152000, 176400, 2, 4},\n\n\t \n\t{12288000, 192000, 2, 0},\n\t{18432000, 192000, 2, 1},\n\t{24576000, 192000, 2, 2},\n\t{36864000, 192000, 2, 3},\n\t{49152000, 192000, 2, 4},\n};\n\nstatic int cs4265_get_clk_index(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\n\t\tif (clk_map_table[i].rate == rate &&\n\t\t\t\tclk_map_table[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs4265_set_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\n\t\t\tunsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4265_private *cs4265 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tif (clk_id != 0) {\n\t\tdev_err(component->dev, \"Invalid clk_id %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\n\t\tif (clk_map_table[i].mclk == freq) {\n\t\t\tcs4265->sysclk = freq;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcs4265->sysclk = 0;\n\tdev_err(component->dev, \"Invalid freq parameter %d\\n\", freq);\n\treturn -EINVAL;\n}\n\nstatic int cs4265_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4265_private *cs4265 = snd_soc_component_get_drvdata(component);\n\tu8 iface = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tsnd_soc_component_update_bits(component, CS4265_ADC_CTL,\n\t\t\t\tCS4265_ADC_MASTER,\n\t\t\t\tCS4265_ADC_MASTER);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tsnd_soc_component_update_bits(component, CS4265_ADC_CTL,\n\t\t\t\tCS4265_ADC_MASTER,\n\t\t\t\t0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t  \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= SND_SOC_DAIFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tiface |= SND_SOC_DAIFMT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= SND_SOC_DAIFMT_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcs4265->format = iface;\n\treturn 0;\n}\n\nstatic int cs4265_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute) {\n\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\tCS4265_DAC_CTL_MUTE,\n\t\t\tCS4265_DAC_CTL_MUTE);\n\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\tCS4265_SPDIF_CTL2_MUTE,\n\t\t\tCS4265_SPDIF_CTL2_MUTE);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\tCS4265_DAC_CTL_MUTE,\n\t\t\t0);\n\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\tCS4265_SPDIF_CTL2_MUTE,\n\t\t\t0);\n\t}\n\treturn 0;\n}\n\nstatic int cs4265_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4265_private *cs4265 = snd_soc_component_get_drvdata(component);\n\tint index;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t\t((cs4265->format & SND_SOC_DAIFMT_FORMAT_MASK)\n\t\t== SND_SOC_DAIFMT_RIGHT_J))\n\t\treturn -EINVAL;\n\n\tindex = cs4265_get_clk_index(cs4265->sysclk, params_rate(params));\n\tif (index >= 0) {\n\t\tsnd_soc_component_update_bits(component, CS4265_ADC_CTL,\n\t\t\tCS4265_ADC_FM, clk_map_table[index].fm_mode << 6);\n\t\tsnd_soc_component_update_bits(component, CS4265_MCLK_FREQ,\n\t\t\tCS4265_MCLK_FREQ_MASK,\n\t\t\tclk_map_table[index].mclkdiv << 4);\n\n\t} else {\n\t\tdev_err(component->dev, \"can't get correct mclk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cs4265->format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\tCS4265_DAC_CTL_DIF, (1 << 4));\n\t\tsnd_soc_component_update_bits(component, CS4265_ADC_CTL,\n\t\t\tCS4265_ADC_DIF, (1 << 4));\n\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\tCS4265_SPDIF_CTL2_DIF, (1 << 6));\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tif (params_width(params) == 16) {\n\t\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\t\tCS4265_DAC_CTL_DIF, (2 << 4));\n\t\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\t\tCS4265_SPDIF_CTL2_DIF, (2 << 6));\n\t\t} else {\n\t\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\t\tCS4265_DAC_CTL_DIF, (3 << 4));\n\t\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\t\tCS4265_SPDIF_CTL2_DIF, (3 << 6));\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsnd_soc_component_update_bits(component, CS4265_DAC_CTL,\n\t\t\tCS4265_DAC_CTL_DIF, 0);\n\t\tsnd_soc_component_update_bits(component, CS4265_ADC_CTL,\n\t\t\tCS4265_ADC_DIF, 0);\n\t\tsnd_soc_component_update_bits(component, CS4265_SPDIF_CTL2,\n\t\t\tCS4265_SPDIF_CTL2_DIF, 0);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs4265_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, CS4265_PWRCTL,\n\t\t\tCS4265_PWRCTL_PDN, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_update_bits(component, CS4265_PWRCTL,\n\t\t\tCS4265_PWRCTL_PDN,\n\t\t\tCS4265_PWRCTL_PDN);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, CS4265_PWRCTL,\n\t\t\tCS4265_PWRCTL_PDN,\n\t\t\tCS4265_PWRCTL_PDN);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define CS4265_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 | \\\n\t\t\tSNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \\\n\t\t\tSNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)\n\n#define CS4265_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_U24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_U32_LE)\n\nstatic const struct snd_soc_dai_ops cs4265_ops = {\n\t.hw_params\t= cs4265_pcm_hw_params,\n\t.mute_stream\t= cs4265_mute,\n\t.set_fmt\t= cs4265_set_fmt,\n\t.set_sysclk\t= cs4265_set_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs4265_dai[] = {\n\t{\n\t\t.name = \"cs4265-dai1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DAI1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS4265_RATES,\n\t\t\t.formats = CS4265_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAI1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS4265_RATES,\n\t\t\t.formats = CS4265_FORMATS,\n\t\t},\n\t\t.ops = &cs4265_ops,\n\t},\n\t{\n\t\t.name = \"cs4265-dai2\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DAI2 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS4265_RATES,\n\t\t\t.formats = CS4265_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAI2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS4265_RATES,\n\t\t\t.formats = CS4265_FORMATS,\n\t\t},\n\t\t.ops = &cs4265_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver soc_component_cs4265 = {\n\t.set_bias_level\t\t= cs4265_set_bias_level,\n\t.controls\t\t= cs4265_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4265_snd_controls),\n\t.dapm_widgets\t\t= cs4265_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4265_dapm_widgets),\n\t.dapm_routes\t\t= cs4265_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4265_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs4265_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS4265_MAX_REGISTER,\n\t.reg_defaults = cs4265_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs4265_reg_defaults),\n\t.readable_reg = cs4265_readable_register,\n\t.volatile_reg = cs4265_volatile_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int cs4265_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs4265_private *cs4265;\n\tint ret;\n\tunsigned int devid = 0;\n\tunsigned int reg;\n\n\tcs4265 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs4265_private),\n\t\t\t       GFP_KERNEL);\n\tif (cs4265 == NULL)\n\t\treturn -ENOMEM;\n\n\tcs4265->regmap = devm_regmap_init_i2c(i2c_client, &cs4265_regmap);\n\tif (IS_ERR(cs4265->regmap)) {\n\t\tret = PTR_ERR(cs4265->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs4265->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\n\t\t\"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs4265->reset_gpio))\n\t\treturn PTR_ERR(cs4265->reset_gpio);\n\n\tif (cs4265->reset_gpio) {\n\t\tmdelay(1);\n\t\tgpiod_set_value_cansleep(cs4265->reset_gpio, 1);\n\t}\n\n\ti2c_set_clientdata(i2c_client, cs4265);\n\n\tret = regmap_read(cs4265->regmap, CS4265_CHIP_ID, &reg);\n\tif (ret) {\n\t\tdev_err(&i2c_client->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevid = reg & CS4265_CHIP_ID_MASK;\n\tif (devid != CS4265_CHIP_ID_VAL) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS4265 Part Number ID: 0x%x Expected: 0x%x\\n\",\n\t\t\tdevid >> 4, CS4265_CHIP_ID_VAL >> 4);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c_client->dev,\n\t\t\"CS4265 Version %x\\n\",\n\t\t\treg & CS4265_REV_ID_MASK);\n\n\tregmap_write(cs4265->regmap, CS4265_PWRCTL, 0x0F);\n\n\treturn devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_cs4265, cs4265_dai,\n\t\t\tARRAY_SIZE(cs4265_dai));\n}\n\nstatic void cs4265_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct cs4265_private *cs4265 = i2c_get_clientdata(i2c);\n\n\tif (cs4265->reset_gpio)\n\t\tgpiod_set_value_cansleep(cs4265->reset_gpio, 0);\n}\n\nstatic const struct of_device_id cs4265_of_match[] = {\n\t{ .compatible = \"cirrus,cs4265\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs4265_of_match);\n\nstatic const struct i2c_device_id cs4265_id[] = {\n\t{ \"cs4265\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cs4265_id);\n\nstatic struct i2c_driver cs4265_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs4265\",\n\t\t.of_match_table = cs4265_of_match,\n\t},\n\t.id_table = cs4265_id,\n\t.probe =    cs4265_i2c_probe,\n\t.remove =   cs4265_i2c_remove,\n};\n\nmodule_i2c_driver(cs4265_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS4265 driver\");\nMODULE_AUTHOR(\"Paul Handrigan, Cirrus Logic Inc, <paul.handrigan@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}