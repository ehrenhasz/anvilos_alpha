{
  "module_name": "cs42l52.c",
  "hash_id": "195fe447eb7c6bb848eb85dd031ffc3375e342ffb7b5a2e4aa5c642ee963e959",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l52.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs42l52.h>\n#include \"cs42l52.h\"\n\nstruct sp_config {\n\tu8 spc, format, spfs;\n\tu32 srate;\n};\n\nstruct  cs42l52_private {\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct device *dev;\n\tstruct sp_config config;\n\tstruct cs42l52_platform_data pdata;\n\tu32 sysclk;\n\tu8 mclksel;\n\tu32 mclk;\n\tu8 flags;\n\tstruct input_dev *beep;\n\tstruct work_struct beep_work;\n\tint beep_rate;\n};\n\nstatic const struct reg_default cs42l52_reg_defaults[] = {\n\t{ CS42L52_PWRCTL1, 0x9F },\t \n\t{ CS42L52_PWRCTL2, 0x07 },\t \n\t{ CS42L52_PWRCTL3, 0xFF },\t \n\t{ CS42L52_CLK_CTL, 0xA0 },\t \n\t{ CS42L52_IFACE_CTL1, 0x00 },\t \n\t{ CS42L52_ADC_PGA_A, 0x80 },\t \n\t{ CS42L52_ADC_PGA_B, 0x80 },\t \n\t{ CS42L52_ANALOG_HPF_CTL, 0xA5 },\t \n\t{ CS42L52_ADC_HPF_FREQ, 0x00 },\t \n\t{ CS42L52_ADC_MISC_CTL, 0x00 },\t \n\t{ CS42L52_PB_CTL1, 0x60 },\t \n\t{ CS42L52_MISC_CTL, 0x02 },\t \n\t{ CS42L52_PB_CTL2, 0x00 },\t \n\t{ CS42L52_MICA_CTL, 0x00 },\t \n\t{ CS42L52_MICB_CTL, 0x00 },\t \n\t{ CS42L52_PGAA_CTL, 0x00 },\t \n\t{ CS42L52_PGAB_CTL, 0x00 },\t \n\t{ CS42L52_PASSTHRUA_VOL, 0x00 },\t \n\t{ CS42L52_PASSTHRUB_VOL, 0x00 },\t \n\t{ CS42L52_ADCA_VOL, 0x00 },\t \n\t{ CS42L52_ADCB_VOL, 0x00 },\t \n\t{ CS42L52_ADCA_MIXER_VOL, 0x80 },\t \n\t{ CS42L52_ADCB_MIXER_VOL, 0x80 },\t \n\t{ CS42L52_PCMA_MIXER_VOL, 0x00 },\t \n\t{ CS42L52_PCMB_MIXER_VOL, 0x00 },\t \n\t{ CS42L52_BEEP_FREQ, 0x00 },\t \n\t{ CS42L52_BEEP_VOL, 0x00 },\t \n\t{ CS42L52_BEEP_TONE_CTL, 0x00 },\t \n\t{ CS42L52_TONE_CTL, 0x00 },\t \n\t{ CS42L52_MASTERA_VOL, 0x00 },\t \n\t{ CS42L52_MASTERB_VOL, 0x00 },\t \n\t{ CS42L52_HPA_VOL, 0x00 },\t \n\t{ CS42L52_HPB_VOL, 0x00 },\t \n\t{ CS42L52_SPKA_VOL, 0x00 },\t \n\t{ CS42L52_SPKB_VOL, 0x00 },\t \n\t{ CS42L52_ADC_PCM_MIXER, 0x00 },\t \n\t{ CS42L52_LIMITER_CTL1, 0x00 },\t \n\t{ CS42L52_LIMITER_CTL2, 0x7F },\t \n\t{ CS42L52_LIMITER_AT_RATE, 0xC0 },\t \n\t{ CS42L52_ALC_CTL, 0x00 },\t \n\t{ CS42L52_ALC_RATE, 0x3F },\t \n\t{ CS42L52_ALC_THRESHOLD, 0x3f },\t \n\t{ CS42L52_NOISE_GATE_CTL, 0x00 },\t \n\t{ CS42L52_CLK_STATUS, 0x00 },\t \n\t{ CS42L52_BATT_COMPEN, 0x00 },\t \n\t{ CS42L52_BATT_LEVEL, 0x00 },\t \n\t{ CS42L52_SPK_STATUS, 0x00 },\t \n\t{ CS42L52_TEM_CTL, 0x3B },\t \n\t{ CS42L52_THE_FOLDBACK, 0x00 },\t \n};\n\nstatic bool cs42l52_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L52_CHIP ... CS42L52_CHARGE_PUMP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42l52_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L52_IFACE_CTL2:\n\tcase CS42L52_CLK_STATUS:\n\tcase CS42L52_BATT_LEVEL:\n\tcase CS42L52_SPK_STATUS:\n\tcase CS42L52_CHARGE_PUMP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(hl_tlv, -10200, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(hpd_tlv, -9600, 50, 1);\n\nstatic DECLARE_TLV_DB_SCALE(ipd_tlv, -9600, 100, 0);\n\nstatic DECLARE_TLV_DB_SCALE(mic_tlv, 1600, 100, 0);\n\nstatic DECLARE_TLV_DB_SCALE(pga_tlv, -600, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(pass_tlv, -6000, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(mix_tlv, -5150, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(beep_tlv, -56, 200, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(limiter_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-3000, 600, 0),\n\t3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0)\n);\n\nstatic const char * const cs42l52_adca_text[] = {\n\t\"Input1A\", \"Input2A\", \"Input3A\", \"Input4A\", \"PGA Input Left\"};\n\nstatic const char * const cs42l52_adcb_text[] = {\n\t\"Input1B\", \"Input2B\", \"Input3B\", \"Input4B\", \"PGA Input Right\"};\n\nstatic SOC_ENUM_SINGLE_DECL(adca_enum,\n\t\t\t    CS42L52_ADC_PGA_A, 5, cs42l52_adca_text);\n\nstatic SOC_ENUM_SINGLE_DECL(adcb_enum,\n\t\t\t    CS42L52_ADC_PGA_B, 5, cs42l52_adcb_text);\n\nstatic const struct snd_kcontrol_new adca_mux =\n\tSOC_DAPM_ENUM(\"Left ADC Input Capture Mux\", adca_enum);\n\nstatic const struct snd_kcontrol_new adcb_mux =\n\tSOC_DAPM_ENUM(\"Right ADC Input Capture Mux\", adcb_enum);\n\nstatic const char * const mic_bias_level_text[] = {\n\t\"0.5 +VA\", \"0.6 +VA\", \"0.7 +VA\",\n\t\"0.8 +VA\", \"0.83 +VA\", \"0.91 +VA\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(mic_bias_level_enum,\n\t\t\t    CS42L52_IFACE_CTL2, 0, mic_bias_level_text);\n\nstatic const char * const cs42l52_mic_text[] = { \"MIC1\", \"MIC2\" };\n\nstatic SOC_ENUM_SINGLE_DECL(mica_enum,\n\t\t\t    CS42L52_MICA_CTL, 5, cs42l52_mic_text);\n\nstatic SOC_ENUM_SINGLE_DECL(micb_enum,\n\t\t\t    CS42L52_MICB_CTL, 5, cs42l52_mic_text);\n\nstatic const char * const digital_output_mux_text[] = {\"ADC\", \"DSP\"};\n\nstatic SOC_ENUM_SINGLE_DECL(digital_output_mux_enum,\n\t\t\t    CS42L52_ADC_MISC_CTL, 6,\n\t\t\t    digital_output_mux_text);\n\nstatic const struct snd_kcontrol_new digital_output_mux =\n\tSOC_DAPM_ENUM(\"Digital Output Mux\", digital_output_mux_enum);\n\nstatic const char * const hp_gain_num_text[] = {\n\t\"0.3959\", \"0.4571\", \"0.5111\", \"0.6047\",\n\t\"0.7099\", \"0.8399\", \"1.000\", \"1.1430\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(hp_gain_enum,\n\t\t\t    CS42L52_PB_CTL1, 5,\n\t\t\t    hp_gain_num_text);\n\nstatic const char * const beep_pitch_text[] = {\n\t\"C4\", \"C5\", \"D5\", \"E5\", \"F5\", \"G5\", \"A5\", \"B5\",\n\t\"C6\", \"D6\", \"E6\", \"F6\", \"G6\", \"A6\", \"B6\", \"C7\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_pitch_enum,\n\t\t\t    CS42L52_BEEP_FREQ, 4,\n\t\t\t    beep_pitch_text);\n\nstatic const char * const beep_ontime_text[] = {\n\t\"86 ms\", \"430 ms\", \"780 ms\", \"1.20 s\", \"1.50 s\",\n\t\"1.80 s\", \"2.20 s\", \"2.50 s\", \"2.80 s\", \"3.20 s\",\n\t\"3.50 s\", \"3.80 s\", \"4.20 s\", \"4.50 s\", \"4.80 s\", \"5.20 s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_ontime_enum,\n\t\t\t    CS42L52_BEEP_FREQ, 0,\n\t\t\t    beep_ontime_text);\n\nstatic const char * const beep_offtime_text[] = {\n\t\"1.23 s\", \"2.58 s\", \"3.90 s\", \"5.20 s\",\n\t\"6.60 s\", \"8.05 s\", \"9.35 s\", \"10.80 s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_offtime_enum,\n\t\t\t    CS42L52_BEEP_VOL, 5,\n\t\t\t    beep_offtime_text);\n\nstatic const char * const beep_config_text[] = {\n\t\"Off\", \"Single\", \"Multiple\", \"Continuous\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_config_enum,\n\t\t\t    CS42L52_BEEP_TONE_CTL, 6,\n\t\t\t    beep_config_text);\n\nstatic const char * const beep_bass_text[] = {\n\t\"50 Hz\", \"100 Hz\", \"200 Hz\", \"250 Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_bass_enum,\n\t\t\t    CS42L52_BEEP_TONE_CTL, 1,\n\t\t\t    beep_bass_text);\n\nstatic const char * const beep_treble_text[] = {\n\t\"5 kHz\", \"7 kHz\", \"10 kHz\", \" 15 kHz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(beep_treble_enum,\n\t\t\t    CS42L52_BEEP_TONE_CTL, 3,\n\t\t\t    beep_treble_text);\n\nstatic const char * const ng_threshold_text[] = {\n\t\"-34dB\", \"-37dB\", \"-40dB\", \"-43dB\",\n\t\"-46dB\", \"-52dB\", \"-58dB\", \"-64dB\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ng_threshold_enum,\n\t\t\t    CS42L52_NOISE_GATE_CTL, 2,\n\t\t\t    ng_threshold_text);\n\nstatic const char * const cs42l52_ng_delay_text[] = {\n\t\"50ms\", \"100ms\", \"150ms\", \"200ms\"};\n\nstatic SOC_ENUM_SINGLE_DECL(ng_delay_enum,\n\t\t\t    CS42L52_NOISE_GATE_CTL, 0,\n\t\t\t    cs42l52_ng_delay_text);\n\nstatic const char * const cs42l52_ng_type_text[] = {\n\t\"Apply Specific\", \"Apply All\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ng_type_enum,\n\t\t\t    CS42L52_NOISE_GATE_CTL, 6,\n\t\t\t    cs42l52_ng_type_text);\n\nstatic const char * const left_swap_text[] = {\n\t\"Left\", \"LR 2\", \"Right\"};\n\nstatic const char * const right_swap_text[] = {\n\t\"Right\", \"LR 2\", \"Left\"};\n\nstatic const unsigned int swap_values[] = { 0, 1, 3 };\n\nstatic const struct soc_enum adca_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L52_ADC_PCM_MIXER, 2, 3,\n\t\t\t      ARRAY_SIZE(left_swap_text),\n\t\t\t      left_swap_text,\n\t\t\t      swap_values);\n\nstatic const struct snd_kcontrol_new adca_mixer =\n\tSOC_DAPM_ENUM(\"Route\", adca_swap_enum);\n\nstatic const struct soc_enum pcma_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L52_ADC_PCM_MIXER, 6, 3,\n\t\t\t      ARRAY_SIZE(left_swap_text),\n\t\t\t      left_swap_text,\n\t\t\t      swap_values);\n\nstatic const struct snd_kcontrol_new pcma_mixer =\n\tSOC_DAPM_ENUM(\"Route\", pcma_swap_enum);\n\nstatic const struct soc_enum adcb_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L52_ADC_PCM_MIXER, 0, 3,\n\t\t\t      ARRAY_SIZE(right_swap_text),\n\t\t\t      right_swap_text,\n\t\t\t      swap_values);\n\nstatic const struct snd_kcontrol_new adcb_mixer =\n\tSOC_DAPM_ENUM(\"Route\", adcb_swap_enum);\n\nstatic const struct soc_enum pcmb_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L52_ADC_PCM_MIXER, 4, 3,\n\t\t\t      ARRAY_SIZE(right_swap_text),\n\t\t\t      right_swap_text,\n\t\t\t      swap_values);\n\nstatic const struct snd_kcontrol_new pcmb_mixer =\n\tSOC_DAPM_ENUM(\"Route\", pcmb_swap_enum);\n\n\nstatic const struct snd_kcontrol_new passthrul_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_MISC_CTL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new passthrur_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_MISC_CTL, 7, 1, 0);\n\nstatic const struct snd_kcontrol_new spkl_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_PWRCTL3, 0, 1, 1);\n\nstatic const struct snd_kcontrol_new spkr_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_PWRCTL3, 2, 1, 1);\n\nstatic const struct snd_kcontrol_new hpl_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_PWRCTL3, 4, 1, 1);\n\nstatic const struct snd_kcontrol_new hpr_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L52_PWRCTL3, 6, 1, 1);\n\nstatic const struct snd_kcontrol_new cs42l52_snd_controls[] = {\n\n\tSOC_DOUBLE_R_SX_TLV(\"Master Volume\", CS42L52_MASTERA_VOL,\n\t\t\t      CS42L52_MASTERB_VOL, 0, 0x34, 0xE4, hl_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Headphone Volume\", CS42L52_HPA_VOL,\n\t\t\t      CS42L52_HPB_VOL, 0, 0x34, 0xC0, hpd_tlv),\n\n\tSOC_ENUM(\"Headphone Analog Gain\", hp_gain_enum),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Speaker Volume\", CS42L52_SPKA_VOL,\n\t\t\t      CS42L52_SPKB_VOL, 0, 0x40, 0xC0, hl_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Bypass Volume\", CS42L52_PASSTHRUA_VOL,\n\t\t\t      CS42L52_PASSTHRUB_VOL, 0, 0x88, 0x90, pass_tlv),\n\n\tSOC_DOUBLE(\"Bypass Mute\", CS42L52_MISC_CTL, 4, 5, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"MIC Gain Volume\", CS42L52_MICA_CTL,\n\t\t\t      CS42L52_MICB_CTL, 0, 0x10, 0, mic_tlv),\n\n\tSOC_ENUM(\"MIC Bias Level\", mic_bias_level_enum),\n\n\tSOC_DOUBLE_R_SX_TLV(\"ADC Volume\", CS42L52_ADCA_VOL,\n\t\t\t      CS42L52_ADCB_VOL, 0, 0xA0, 0x78, ipd_tlv),\n\tSOC_DOUBLE_R_SX_TLV(\"ADC Mixer Volume\",\n\t\t\t     CS42L52_ADCA_MIXER_VOL, CS42L52_ADCB_MIXER_VOL,\n\t\t\t\t0, 0x19, 0x7F, mix_tlv),\n\n\tSOC_DOUBLE(\"ADC Switch\", CS42L52_ADC_MISC_CTL, 0, 1, 1, 0),\n\n\tSOC_DOUBLE_R(\"ADC Mixer Switch\", CS42L52_ADCA_MIXER_VOL,\n\t\t     CS42L52_ADCB_MIXER_VOL, 7, 1, 1),\n\n\tSOC_DOUBLE_R_SX_TLV(\"PGA Volume\", CS42L52_PGAA_CTL,\n\t\t\t    CS42L52_PGAB_CTL, 0, 0x28, 0x24, pga_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"PCM Mixer Volume\",\n\t\t\t    CS42L52_PCMA_MIXER_VOL, CS42L52_PCMB_MIXER_VOL,\n\t\t\t\t0, 0x19, 0x7f, mix_tlv),\n\tSOC_DOUBLE_R(\"PCM Mixer Switch\",\n\t\t     CS42L52_PCMA_MIXER_VOL, CS42L52_PCMB_MIXER_VOL, 7, 1, 1),\n\n\tSOC_ENUM(\"Beep Config\", beep_config_enum),\n\tSOC_ENUM(\"Beep Pitch\", beep_pitch_enum),\n\tSOC_ENUM(\"Beep on Time\", beep_ontime_enum),\n\tSOC_ENUM(\"Beep off Time\", beep_offtime_enum),\n\tSOC_SINGLE_SX_TLV(\"Beep Volume\", CS42L52_BEEP_VOL,\n\t\t\t0, 0x07, 0x1f, beep_tlv),\n\tSOC_SINGLE(\"Beep Mixer Switch\", CS42L52_BEEP_TONE_CTL, 5, 1, 1),\n\tSOC_ENUM(\"Beep Treble Corner Freq\", beep_treble_enum),\n\tSOC_ENUM(\"Beep Bass Corner Freq\", beep_bass_enum),\n\n\tSOC_SINGLE(\"Tone Control Switch\", CS42L52_BEEP_TONE_CTL, 0, 1, 1),\n\tSOC_SINGLE_TLV(\"Treble Gain Volume\",\n\t\t\t    CS42L52_TONE_CTL, 4, 15, 1, hl_tlv),\n\tSOC_SINGLE_TLV(\"Bass Gain Volume\",\n\t\t\t    CS42L52_TONE_CTL, 0, 15, 1, hl_tlv),\n\n\t \n\tSOC_SINGLE_TLV(\"Limiter Max Threshold Volume\",\n\t\t       CS42L52_LIMITER_CTL1, 5, 7, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"Limiter Cushion Threshold Volume\",\n\t\t       CS42L52_LIMITER_CTL1, 2, 7, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"Limiter Release Rate Volume\",\n\t\t       CS42L52_LIMITER_CTL2, 0, 63, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"Limiter Attack Rate Volume\",\n\t\t       CS42L52_LIMITER_AT_RATE, 0, 63, 0, limiter_tlv),\n\n\tSOC_SINGLE(\"Limiter SR Switch\", CS42L52_LIMITER_CTL1, 1, 1, 0),\n\tSOC_SINGLE(\"Limiter ZC Switch\", CS42L52_LIMITER_CTL1, 0, 1, 0),\n\tSOC_SINGLE(\"Limiter Switch\", CS42L52_LIMITER_CTL2, 7, 1, 0),\n\n\t \n\tSOC_SINGLE_TLV(\"ALC Attack Rate Volume\", CS42L52_ALC_CTL,\n\t\t       0, 63, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"ALC Release Rate Volume\", CS42L52_ALC_RATE,\n\t\t       0, 63, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Threshold Volume\", CS42L52_ALC_THRESHOLD,\n\t\t       5, 7, 0, limiter_tlv),\n\tSOC_SINGLE_TLV(\"ALC Min Threshold Volume\", CS42L52_ALC_THRESHOLD,\n\t\t       2, 7, 0, limiter_tlv),\n\n\tSOC_DOUBLE_R(\"ALC SR Capture Switch\", CS42L52_PGAA_CTL,\n\t\t     CS42L52_PGAB_CTL, 7, 1, 1),\n\tSOC_DOUBLE_R(\"ALC ZC Capture Switch\", CS42L52_PGAA_CTL,\n\t\t     CS42L52_PGAB_CTL, 6, 1, 1),\n\tSOC_DOUBLE(\"ALC Capture Switch\", CS42L52_ALC_CTL, 6, 7, 1, 0),\n\n\t \n\tSOC_ENUM(\"NG Type Switch\", ng_type_enum),\n\tSOC_SINGLE(\"NG Enable Switch\", CS42L52_NOISE_GATE_CTL, 6, 1, 0),\n\tSOC_SINGLE(\"NG Boost Switch\", CS42L52_NOISE_GATE_CTL, 5, 1, 1),\n\tSOC_ENUM(\"NG Threshold\", ng_threshold_enum),\n\tSOC_ENUM(\"NG Delay\", ng_delay_enum),\n\n\tSOC_DOUBLE(\"HPF Switch\", CS42L52_ANALOG_HPF_CTL, 5, 7, 1, 0),\n\n\tSOC_DOUBLE(\"Analog SR Switch\", CS42L52_ANALOG_HPF_CTL, 1, 3, 1, 1),\n\tSOC_DOUBLE(\"Analog ZC Switch\", CS42L52_ANALOG_HPF_CTL, 0, 2, 1, 1),\n\tSOC_SINGLE(\"Digital SR Switch\", CS42L52_MISC_CTL, 1, 1, 0),\n\tSOC_SINGLE(\"Digital ZC Switch\", CS42L52_MISC_CTL, 0, 1, 0),\n\tSOC_SINGLE(\"Deemphasis Switch\", CS42L52_MISC_CTL, 2, 1, 0),\n\n\tSOC_SINGLE(\"Batt Compensation Switch\", CS42L52_BATT_COMPEN, 7, 1, 0),\n\tSOC_SINGLE(\"Batt VP Monitor Switch\", CS42L52_BATT_COMPEN, 6, 1, 0),\n\tSOC_SINGLE(\"Batt VP ref\", CS42L52_BATT_COMPEN, 0, 0x0f, 0),\n\n\tSOC_SINGLE(\"PGA AIN1L Switch\", CS42L52_ADC_PGA_A, 0, 1, 0),\n\tSOC_SINGLE(\"PGA AIN1R Switch\", CS42L52_ADC_PGA_B, 0, 1, 0),\n\tSOC_SINGLE(\"PGA AIN2L Switch\", CS42L52_ADC_PGA_A, 1, 1, 0),\n\tSOC_SINGLE(\"PGA AIN2R Switch\", CS42L52_ADC_PGA_B, 1, 1, 0),\n\n\tSOC_SINGLE(\"PGA AIN3L Switch\", CS42L52_ADC_PGA_A, 2, 1, 0),\n\tSOC_SINGLE(\"PGA AIN3R Switch\", CS42L52_ADC_PGA_B, 2, 1, 0),\n\n\tSOC_SINGLE(\"PGA AIN4L Switch\", CS42L52_ADC_PGA_A, 3, 1, 0),\n\tSOC_SINGLE(\"PGA AIN4R Switch\", CS42L52_ADC_PGA_B, 3, 1, 0),\n\n\tSOC_SINGLE(\"PGA MICA Switch\", CS42L52_ADC_PGA_A, 4, 1, 0),\n\tSOC_SINGLE(\"PGA MICB Switch\", CS42L52_ADC_PGA_B, 4, 1, 0),\n\n};\n\nstatic const struct snd_kcontrol_new cs42l52_mica_controls[] = {\n\tSOC_ENUM(\"MICA Select\", mica_enum),\n};\n\nstatic const struct snd_kcontrol_new cs42l52_micb_controls[] = {\n\tSOC_ENUM(\"MICB Select\", micb_enum),\n};\n\nstatic int cs42l52_add_mic_controls(struct snd_soc_component *component)\n{\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\tstruct cs42l52_platform_data *pdata = &cs42l52->pdata;\n\n\tif (!pdata->mica_diff_cfg)\n\t\tsnd_soc_add_component_controls(component, cs42l52_mica_controls,\n\t\t\t\t     ARRAY_SIZE(cs42l52_mica_controls));\n\n\tif (!pdata->micb_diff_cfg)\n\t\tsnd_soc_add_component_controls(component, cs42l52_micb_controls,\n\t\t\t\t     ARRAY_SIZE(cs42l52_micb_controls));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs42l52_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_INPUT(\"AIN1L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4R\"),\n\tSND_SOC_DAPM_INPUT(\"MICA\"),\n\tSND_SOC_DAPM_INPUT(\"MICB\"),\n\tSND_SOC_DAPM_SIGGEN(\"Beep\"),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUTL\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUTR\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_ADC(\"ADC Left\", NULL, CS42L52_PWRCTL1, 1, 1),\n\tSND_SOC_DAPM_ADC(\"ADC Right\", NULL, CS42L52_PWRCTL1, 2, 1),\n\tSND_SOC_DAPM_PGA(\"PGA Left\", CS42L52_PWRCTL1, 3, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA Right\", CS42L52_PWRCTL1, 4, 1, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"ADC Left Mux\", SND_SOC_NOPM, 0, 0, &adca_mux),\n\tSND_SOC_DAPM_MUX(\"ADC Right Mux\", SND_SOC_NOPM, 0, 0, &adcb_mux),\n\n\tSND_SOC_DAPM_MUX(\"ADC Left Swap\", SND_SOC_NOPM,\n\t\t\t 0, 0, &adca_mixer),\n\tSND_SOC_DAPM_MUX(\"ADC Right Swap\", SND_SOC_NOPM,\n\t\t\t 0, 0, &adcb_mixer),\n\n\tSND_SOC_DAPM_MUX(\"Output Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &digital_output_mux),\n\n\tSND_SOC_DAPM_PGA(\"PGA MICA\", CS42L52_PWRCTL2, 1, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA MICB\", CS42L52_PWRCTL2, 2, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", CS42L52_PWRCTL2, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Charge Pump\", CS42L52_PWRCTL1, 7, 1, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"AIFINL\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINR\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_DAC(\"DAC Left\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Right\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"Bypass Left\", CS42L52_MISC_CTL,\n\t\t\t    6, 0, &passthrul_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Bypass Right\", CS42L52_MISC_CTL,\n\t\t\t    7, 0, &passthrur_ctl),\n\n\tSND_SOC_DAPM_MUX(\"PCM Left Swap\", SND_SOC_NOPM,\n\t\t\t 0, 0, &pcma_mixer),\n\tSND_SOC_DAPM_MUX(\"PCM Right Swap\", SND_SOC_NOPM,\n\t\t\t 0, 0, &pcmb_mixer),\n\n\tSND_SOC_DAPM_SWITCH(\"HP Left Amp\", SND_SOC_NOPM, 0, 0, &hpl_ctl),\n\tSND_SOC_DAPM_SWITCH(\"HP Right Amp\", SND_SOC_NOPM, 0, 0, &hpr_ctl),\n\n\tSND_SOC_DAPM_SWITCH(\"SPK Left Amp\", SND_SOC_NOPM, 0, 0, &spkl_ctl),\n\tSND_SOC_DAPM_SWITCH(\"SPK Right Amp\", SND_SOC_NOPM, 0, 0, &spkr_ctl),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTB\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTB\"),\n\n};\n\nstatic const struct snd_soc_dapm_route cs42l52_audio_map[] = {\n\n\t{\"Capture\", NULL, \"AIFOUTL\"},\n\t{\"Capture\", NULL, \"AIFOUTL\"},\n\n\t{\"AIFOUTL\", NULL, \"Output Mux\"},\n\t{\"AIFOUTR\", NULL, \"Output Mux\"},\n\n\t{\"Output Mux\", \"ADC\", \"ADC Left\"},\n\t{\"Output Mux\", \"ADC\", \"ADC Right\"},\n\n\t{\"ADC Left\", NULL, \"Charge Pump\"},\n\t{\"ADC Right\", NULL, \"Charge Pump\"},\n\n\t{\"Charge Pump\", NULL, \"ADC Left Mux\"},\n\t{\"Charge Pump\", NULL, \"ADC Right Mux\"},\n\n\t{\"ADC Left Mux\", \"Input1A\", \"AIN1L\"},\n\t{\"ADC Right Mux\", \"Input1B\", \"AIN1R\"},\n\t{\"ADC Left Mux\", \"Input2A\", \"AIN2L\"},\n\t{\"ADC Right Mux\", \"Input2B\", \"AIN2R\"},\n\t{\"ADC Left Mux\", \"Input3A\", \"AIN3L\"},\n\t{\"ADC Right Mux\", \"Input3B\", \"AIN3R\"},\n\t{\"ADC Left Mux\", \"Input4A\", \"AIN4L\"},\n\t{\"ADC Right Mux\", \"Input4B\", \"AIN4R\"},\n\t{\"ADC Left Mux\", \"PGA Input Left\", \"PGA Left\"},\n\t{\"ADC Right Mux\", \"PGA Input Right\" , \"PGA Right\"},\n\n\t{\"PGA Left\", \"Switch\", \"AIN1L\"},\n\t{\"PGA Right\", \"Switch\", \"AIN1R\"},\n\t{\"PGA Left\", \"Switch\", \"AIN2L\"},\n\t{\"PGA Right\", \"Switch\", \"AIN2R\"},\n\t{\"PGA Left\", \"Switch\", \"AIN3L\"},\n\t{\"PGA Right\", \"Switch\", \"AIN3R\"},\n\t{\"PGA Left\", \"Switch\", \"AIN4L\"},\n\t{\"PGA Right\", \"Switch\", \"AIN4R\"},\n\n\t{\"PGA Left\", \"Switch\", \"PGA MICA\"},\n\t{\"PGA MICA\", NULL, \"MICA\"},\n\n\t{\"PGA Right\", \"Switch\", \"PGA MICB\"},\n\t{\"PGA MICB\", NULL, \"MICB\"},\n\n\t{\"HPOUTA\", NULL, \"HP Left Amp\"},\n\t{\"HPOUTB\", NULL, \"HP Right Amp\"},\n\t{\"HP Left Amp\", NULL, \"Bypass Left\"},\n\t{\"HP Right Amp\", NULL, \"Bypass Right\"},\n\t{\"Bypass Left\", \"Switch\", \"PGA Left\"},\n\t{\"Bypass Right\", \"Switch\", \"PGA Right\"},\n\t{\"HP Left Amp\", \"Switch\", \"DAC Left\"},\n\t{\"HP Right Amp\", \"Switch\", \"DAC Right\"},\n\n\t{\"SPKOUTA\", NULL, \"SPK Left Amp\"},\n\t{\"SPKOUTB\", NULL, \"SPK Right Amp\"},\n\n\t{\"SPK Left Amp\", NULL, \"Beep\"},\n\t{\"SPK Right Amp\", NULL, \"Beep\"},\n\t{\"SPK Left Amp\", \"Switch\", \"Playback\"},\n\t{\"SPK Right Amp\", \"Switch\", \"Playback\"},\n\n\t{\"DAC Left\", NULL, \"Beep\"},\n\t{\"DAC Right\", NULL, \"Beep\"},\n\t{\"DAC Left\", NULL, \"Playback\"},\n\t{\"DAC Right\", NULL, \"Playback\"},\n\n\t{\"Output Mux\", \"DSP\", \"Playback\"},\n\t{\"Output Mux\", \"DSP\", \"Playback\"},\n\n\t{\"AIFINL\", NULL, \"Playback\"},\n\t{\"AIFINR\", NULL, \"Playback\"},\n\n};\n\nstruct cs42l52_clk_para {\n\tu32 mclk;\n\tu32 rate;\n\tu8 speed;\n\tu8 group;\n\tu8 videoclk;\n\tu8 ratio;\n\tu8 mclkdiv2;\n};\n\nstatic const struct cs42l52_clk_para clk_map_table[] = {\n\t \n\t{12288000, 8000, CLK_QS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{18432000, 8000, CLK_QS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{12000000, 8000, CLK_QS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 0},\n\t{24000000, 8000, CLK_QS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 1},\n\t{27000000, 8000, CLK_QS_MODE, CLK_32K, CLK_27M_MCLK, CLK_R_125, 0},\n\n\t \n\t{11289600, 11025, CLK_QS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{16934400, 11025, CLK_QS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\n\t \n\t{12288000, 16000, CLK_HS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{18432000, 16000, CLK_HS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{12000000, 16000, CLK_HS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 0},\n\t{24000000, 16000, CLK_HS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 1},\n\t{27000000, 16000, CLK_HS_MODE, CLK_32K, CLK_27M_MCLK, CLK_R_125, 1},\n\n\t \n\t{11289600, 22050, CLK_HS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{16934400, 22050, CLK_HS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\n\t \n\t{12288000, 32000, CLK_SS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{18432000, 32000, CLK_SS_MODE, CLK_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{12000000, 32000, CLK_SS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 0},\n\t{24000000, 32000, CLK_SS_MODE, CLK_32K, CLK_NO_27M, CLK_R_125, 1},\n\t{27000000, 32000, CLK_SS_MODE, CLK_32K, CLK_27M_MCLK, CLK_R_125, 0},\n\n\t \n\t{11289600, 44100, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{16934400, 44100, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\n\t \n\t{12288000, 48000, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{18432000, 48000, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{12000000, 48000, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_125, 0},\n\t{24000000, 48000, CLK_SS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_125, 1},\n\t{27000000, 48000, CLK_SS_MODE, CLK_NO_32K, CLK_27M_MCLK, CLK_R_125, 1},\n\n\t \n\t{11289600, 88200, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{16934400, 88200, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\n\t \n\t{12288000, 96000, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{18432000, 96000, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_128, 0},\n\t{12000000, 96000, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_125, 0},\n\t{24000000, 96000, CLK_DS_MODE, CLK_NO_32K, CLK_NO_27M, CLK_R_125, 1},\n};\n\nstatic int cs42l52_get_clk(int mclk, int rate)\n{\n\tint i, ret = -EINVAL;\n\tu_int mclk1, mclk2 = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_map_table); i++) {\n\t\tif (clk_map_table[i].rate == rate) {\n\t\t\tmclk1 = clk_map_table[i].mclk;\n\t\t\tif (abs(mclk - mclk1) < abs(mclk - mclk2)) {\n\t\t\t\tmclk2 = mclk1;\n\t\t\t\tret = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int cs42l52_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\n\tif ((freq >= CS42L52_MIN_CLK) && (freq <= CS42L52_MAX_CLK)) {\n\t\tcs42l52->sysclk = freq;\n\t} else {\n\t\tdev_err(component->dev, \"Invalid freq parameter\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs42l52_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\tu8 iface = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tiface = CS42L52_IFACE_CTL1_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tiface = CS42L52_IFACE_CTL1_SLAVE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t  \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= CS42L52_IFACE_CTL1_ADC_FMT_I2S |\n\t\t\t\tCS42L52_IFACE_CTL1_DAC_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tiface |= CS42L52_IFACE_CTL1_DAC_FMT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= CS42L52_IFACE_CTL1_ADC_FMT_LEFT_J |\n\t\t\t\tCS42L52_IFACE_CTL1_DAC_FMT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= CS42L52_IFACE_CTL1_DSP_MODE_EN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= CS42L52_IFACE_CTL1_INV_SCLK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= CS42L52_IFACE_CTL1_INV_SCLK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tcs42l52->config.format = iface;\n\tsnd_soc_component_write(component, CS42L52_IFACE_CTL1, cs42l52->config.format);\n\n\treturn 0;\n}\n\nstatic int cs42l52_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute)\n\t\tsnd_soc_component_update_bits(component, CS42L52_PB_CTL1,\n\t\t\t\t    CS42L52_PB_CTL1_MUTE_MASK,\n\t\t\t\tCS42L52_PB_CTL1_MUTE);\n\telse\n\t\tsnd_soc_component_update_bits(component, CS42L52_PB_CTL1,\n\t\t\t\t    CS42L52_PB_CTL1_MUTE_MASK,\n\t\t\t\tCS42L52_PB_CTL1_UNMUTE);\n\n\treturn 0;\n}\n\nstatic int cs42l52_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\tu32 clk = 0;\n\tint index;\n\n\tindex = cs42l52_get_clk(cs42l52->sysclk, params_rate(params));\n\tif (index >= 0) {\n\t\tcs42l52->sysclk = clk_map_table[index].mclk;\n\n\t\tclk |= (clk_map_table[index].speed << CLK_SPEED_SHIFT) |\n\t\t(clk_map_table[index].group << CLK_32K_SR_SHIFT) |\n\t\t(clk_map_table[index].videoclk << CLK_27M_MCLK_SHIFT) |\n\t\t(clk_map_table[index].ratio << CLK_RATIO_SHIFT) |\n\t\tclk_map_table[index].mclkdiv2;\n\n\t\tsnd_soc_component_write(component, CS42L52_CLK_CTL, clk);\n\t} else {\n\t\tdev_err(component->dev, \"can't get correct mclk\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l52_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, CS42L52_PWRCTL1,\n\t\t\t\t    CS42L52_PWRCTL1_PDN_CODEC, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_cache_only(cs42l52->regmap, false);\n\t\t\tregcache_sync(cs42l52->regmap);\n\t\t}\n\t\tsnd_soc_component_write(component, CS42L52_PWRCTL1, CS42L52_PWRCTL1_PDN_ALL);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component, CS42L52_PWRCTL1, CS42L52_PWRCTL1_PDN_ALL);\n\t\tregcache_cache_only(cs42l52->regmap, true);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define CS42L52_RATES (SNDRV_PCM_RATE_8000_96000)\n\n#define CS42L52_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_U18_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_U20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_U24_LE)\n\nstatic const struct snd_soc_dai_ops cs42l52_ops = {\n\t.hw_params\t= cs42l52_pcm_hw_params,\n\t.mute_stream\t= cs42l52_mute,\n\t.set_fmt\t= cs42l52_set_fmt,\n\t.set_sysclk\t= cs42l52_set_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs42l52_dai = {\n\t\t.name = \"cs42l52\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS42L52_RATES,\n\t\t\t.formats = CS42L52_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS42L52_RATES,\n\t\t\t.formats = CS42L52_FORMATS,\n\t\t},\n\t\t.ops = &cs42l52_ops,\n};\n\nstatic int beep_rates[] = {\n\t261, 522, 585, 667, 706, 774, 889, 1000,\n\t1043, 1200, 1333, 1412, 1600, 1714, 2000, 2182\n};\n\nstatic void cs42l52_beep_work(struct work_struct *work)\n{\n\tstruct cs42l52_private *cs42l52 =\n\t\tcontainer_of(work, struct cs42l52_private, beep_work);\n\tstruct snd_soc_component *component = cs42l52->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint i;\n\tint val = 0;\n\tint best = 0;\n\n\tif (cs42l52->beep_rate) {\n\t\tfor (i = 0; i < ARRAY_SIZE(beep_rates); i++) {\n\t\t\tif (abs(cs42l52->beep_rate - beep_rates[i]) <\n\t\t\t    abs(cs42l52->beep_rate - beep_rates[best]))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"Set beep rate %dHz for requested %dHz\\n\",\n\t\t\tbeep_rates[best], cs42l52->beep_rate);\n\n\t\tval = (best << CS42L52_BEEP_RATE_SHIFT);\n\n\t\tsnd_soc_dapm_enable_pin(dapm, \"Beep\");\n\t} else {\n\t\tdev_dbg(component->dev, \"Disabling beep\\n\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"Beep\");\n\t}\n\n\tsnd_soc_component_update_bits(component, CS42L52_BEEP_FREQ,\n\t\t\t    CS42L52_BEEP_RATE_MASK, val);\n\n\tsnd_soc_dapm_sync(dapm);\n}\n\n \nstatic int cs42l52_beep_event(struct input_dev *dev, unsigned int type,\n\t\t\t     unsigned int code, int hz)\n{\n\tstruct snd_soc_component *component = input_get_drvdata(dev);\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"Beep event %x %x\\n\", code, hz);\n\n\tswitch (code) {\n\tcase SND_BELL:\n\t\tif (hz)\n\t\t\thz = 261;\n\t\tbreak;\n\tcase SND_TONE:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tcs42l52->beep_rate = hz;\n\tschedule_work(&cs42l52->beep_work);\n\treturn 0;\n}\n\nstatic ssize_t beep_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cs42l52_private *cs42l52 = dev_get_drvdata(dev);\n\tlong int time;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &time);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tinput_event(cs42l52->beep, EV_SND, SND_TONE, time);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(beep);\n\nstatic void cs42l52_init_beep(struct snd_soc_component *component)\n{\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tcs42l52->beep = devm_input_allocate_device(component->dev);\n\tif (!cs42l52->beep) {\n\t\tdev_err(component->dev, \"Failed to allocate beep device\\n\");\n\t\treturn;\n\t}\n\n\tINIT_WORK(&cs42l52->beep_work, cs42l52_beep_work);\n\tcs42l52->beep_rate = 0;\n\n\tcs42l52->beep->name = \"CS42L52 Beep Generator\";\n\tcs42l52->beep->phys = dev_name(component->dev);\n\tcs42l52->beep->id.bustype = BUS_I2C;\n\n\tcs42l52->beep->evbit[0] = BIT_MASK(EV_SND);\n\tcs42l52->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\tcs42l52->beep->event = cs42l52_beep_event;\n\tcs42l52->beep->dev.parent = component->dev;\n\tinput_set_drvdata(cs42l52->beep, component);\n\n\tret = input_register_device(cs42l52->beep);\n\tif (ret != 0) {\n\t\tcs42l52->beep = NULL;\n\t\tdev_err(component->dev, \"Failed to register beep device\\n\");\n\t}\n\n\tret = device_create_file(component->dev, &dev_attr_beep);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to create keyclick file: %d\\n\",\n\t\t\tret);\n\t}\n}\n\nstatic void cs42l52_free_beep(struct snd_soc_component *component)\n{\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\n\tdevice_remove_file(component->dev, &dev_attr_beep);\n\tcancel_work_sync(&cs42l52->beep_work);\n\tcs42l52->beep = NULL;\n\n\tsnd_soc_component_update_bits(component, CS42L52_BEEP_TONE_CTL,\n\t\t\t    CS42L52_BEEP_EN_MASK, 0);\n}\n\nstatic int cs42l52_probe(struct snd_soc_component *component)\n{\n\tstruct cs42l52_private *cs42l52 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(cs42l52->regmap, true);\n\n\tcs42l52_add_mic_controls(component);\n\n\tcs42l52_init_beep(component);\n\n\tcs42l52->sysclk = CS42L52_DEFAULT_CLK;\n\tcs42l52->config.format = CS42L52_DEFAULT_FORMAT;\n\n\treturn 0;\n}\n\nstatic void cs42l52_remove(struct snd_soc_component *component)\n{\n\tcs42l52_free_beep(component);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs42l52 = {\n\t.probe\t\t\t= cs42l52_probe,\n\t.remove\t\t\t= cs42l52_remove,\n\t.set_bias_level\t\t= cs42l52_set_bias_level,\n\t.controls\t\t= cs42l52_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42l52_snd_controls),\n\t.dapm_widgets\t\t= cs42l52_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42l52_dapm_widgets),\n\t.dapm_routes\t\t= cs42l52_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42l52_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n \nstatic const struct reg_sequence cs42l52_threshold_patch[] = {\n\n\t{ 0x00, 0x99 },\n\t{ 0x3E, 0xBA },\n\t{ 0x47, 0x80 },\n\t{ 0x32, 0xBB },\n\t{ 0x32, 0x3B },\n\t{ 0x00, 0x00 },\n\n};\n\nstatic const struct regmap_config cs42l52_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS42L52_MAX_REGISTER,\n\t.reg_defaults = cs42l52_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs42l52_reg_defaults),\n\t.readable_reg = cs42l52_readable_register,\n\t.volatile_reg = cs42l52_volatile_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int cs42l52_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs42l52_private *cs42l52;\n\tstruct cs42l52_platform_data *pdata = dev_get_platdata(&i2c_client->dev);\n\tint ret;\n\tunsigned int devid;\n\tunsigned int reg;\n\tu32 val32;\n\n\tcs42l52 = devm_kzalloc(&i2c_client->dev, sizeof(*cs42l52), GFP_KERNEL);\n\tif (cs42l52 == NULL)\n\t\treturn -ENOMEM;\n\tcs42l52->dev = &i2c_client->dev;\n\n\tcs42l52->regmap = devm_regmap_init_i2c(i2c_client, &cs42l52_regmap);\n\tif (IS_ERR(cs42l52->regmap)) {\n\t\tret = PTR_ERR(cs42l52->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (pdata) {\n\t\tcs42l52->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(&i2c_client->dev, sizeof(*pdata),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tif (of_property_read_bool(i2c_client->dev.of_node,\n\t\t\t\t\"cirrus,mica-differential-cfg\"))\n\t\t\t\tpdata->mica_diff_cfg = true;\n\n\t\t\tif (of_property_read_bool(i2c_client->dev.of_node,\n\t\t\t\t\"cirrus,micb-differential-cfg\"))\n\t\t\t\tpdata->micb_diff_cfg = true;\n\n\t\t\tif (of_property_read_u32(i2c_client->dev.of_node,\n\t\t\t\t\"cirrus,micbias-lvl\", &val32) >= 0)\n\t\t\t\tpdata->micbias_lvl = val32;\n\n\t\t\tif (of_property_read_u32(i2c_client->dev.of_node,\n\t\t\t\t\"cirrus,chgfreq-divisor\", &val32) >= 0)\n\t\t\t\tpdata->chgfreq = val32;\n\n\t\t\tpdata->reset_gpio =\n\t\t\t\tof_get_named_gpio(i2c_client->dev.of_node,\n\t\t\t\t\t\t\"cirrus,reset-gpio\", 0);\n\t\t}\n\t\tcs42l52->pdata = *pdata;\n\t}\n\n\tif (cs42l52->pdata.reset_gpio) {\n\t\tret = devm_gpio_request_one(&i2c_client->dev,\n\t\t\t\t\t    cs42l52->pdata.reset_gpio,\n\t\t\t\t\t    GPIOF_OUT_INIT_HIGH,\n\t\t\t\t\t    \"CS42L52 /RST\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c_client->dev, \"Failed to request /RST %d: %d\\n\",\n\t\t\t\tcs42l52->pdata.reset_gpio, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tgpio_set_value_cansleep(cs42l52->pdata.reset_gpio, 0);\n\t\tgpio_set_value_cansleep(cs42l52->pdata.reset_gpio, 1);\n\t}\n\n\ti2c_set_clientdata(i2c_client, cs42l52);\n\n\tret = regmap_register_patch(cs42l52->regmap, cs42l52_threshold_patch,\n\t\t\t\t    ARRAY_SIZE(cs42l52_threshold_patch));\n\tif (ret != 0)\n\t\tdev_warn(cs42l52->dev, \"Failed to apply regmap patch: %d\\n\",\n\t\t\t ret);\n\n\tret = regmap_read(cs42l52->regmap, CS42L52_CHIP, &reg);\n\tif (ret) {\n\t\tdev_err(&i2c_client->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdevid = reg & CS42L52_CHIP_ID_MASK;\n\tif (devid != CS42L52_CHIP_ID) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS42L52 Device ID (%X). Expected %X\\n\",\n\t\t\tdevid, CS42L52_CHIP_ID);\n\t\treturn ret;\n\t}\n\n\tdev_info(&i2c_client->dev, \"Cirrus Logic CS42L52, Revision: %02X\\n\",\n\t\t reg & CS42L52_CHIP_REV_MASK);\n\n\t \n\tif (cs42l52->pdata.mica_diff_cfg)\n\t\tregmap_update_bits(cs42l52->regmap, CS42L52_MICA_CTL,\n\t\t\t\t   CS42L52_MIC_CTL_TYPE_MASK,\n\t\t\t\tcs42l52->pdata.mica_diff_cfg <<\n\t\t\t\tCS42L52_MIC_CTL_TYPE_SHIFT);\n\n\tif (cs42l52->pdata.micb_diff_cfg)\n\t\tregmap_update_bits(cs42l52->regmap, CS42L52_MICB_CTL,\n\t\t\t\t   CS42L52_MIC_CTL_TYPE_MASK,\n\t\t\t\tcs42l52->pdata.micb_diff_cfg <<\n\t\t\t\tCS42L52_MIC_CTL_TYPE_SHIFT);\n\n\tif (cs42l52->pdata.chgfreq)\n\t\tregmap_update_bits(cs42l52->regmap, CS42L52_CHARGE_PUMP,\n\t\t\t\t   CS42L52_CHARGE_PUMP_MASK,\n\t\t\t\tcs42l52->pdata.chgfreq <<\n\t\t\t\tCS42L52_CHARGE_PUMP_SHIFT);\n\n\tif (cs42l52->pdata.micbias_lvl)\n\t\tregmap_update_bits(cs42l52->regmap, CS42L52_IFACE_CTL2,\n\t\t\t\t   CS42L52_IFACE_CTL2_BIAS_LVL,\n\t\t\t\tcs42l52->pdata.micbias_lvl);\n\n\treturn devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs42l52, &cs42l52_dai, 1);\n}\n\nstatic const struct of_device_id cs42l52_of_match[] = {\n\t{ .compatible = \"cirrus,cs42l52\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs42l52_of_match);\n\n\nstatic const struct i2c_device_id cs42l52_id[] = {\n\t{ \"cs42l52\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cs42l52_id);\n\nstatic struct i2c_driver cs42l52_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs42l52\",\n\t\t.of_match_table = cs42l52_of_match,\n\t},\n\t.id_table = cs42l52_id,\n\t.probe = cs42l52_i2c_probe,\n};\n\nmodule_i2c_driver(cs42l52_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS42L52 driver\");\nMODULE_AUTHOR(\"Georgi Vlaev, Nucleus Systems Ltd, <joe@nucleusys.com>\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}