{
  "module_name": "cs4341.c",
  "hash_id": "4af1418d9175650618e8f6ffae32decfca67e5647b9057f140fca0c9bd7fd678",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4341.c",
  "human_readable_source": " \n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define CS4341_REG_MODE1\t0x00\n#define CS4341_REG_MODE2\t0x01\n#define CS4341_REG_MIX\t\t0x02\n#define CS4341_REG_VOLA\t\t0x03\n#define CS4341_REG_VOLB\t\t0x04\n\n#define CS4341_MODE2_DIF\t(7 << 4)\n#define CS4341_MODE2_DIF_I2S_24\t(0 << 4)\n#define CS4341_MODE2_DIF_I2S_16\t(1 << 4)\n#define CS4341_MODE2_DIF_LJ_24\t(2 << 4)\n#define CS4341_MODE2_DIF_RJ_24\t(3 << 4)\n#define CS4341_MODE2_DIF_RJ_16\t(5 << 4)\n#define CS4341_VOLX_MUTE\t(1 << 7)\n\nstruct cs4341_priv {\n\tunsigned int\t\tfmt;\n\tstruct regmap\t\t*regmap;\n\tstruct regmap_config\tregcfg;\n};\n\nstatic const struct reg_default cs4341_reg_defaults[] = {\n\t{ CS4341_REG_MODE1,\t0x00 },\n\t{ CS4341_REG_MODE2,\t0x82 },\n\t{ CS4341_REG_MIX,\t0x49 },\n\t{ CS4341_REG_VOLA,\t0x80 },\n\t{ CS4341_REG_VOLB,\t0x80 },\n};\n\nstatic int cs4341_set_fmt(struct snd_soc_dai *dai, unsigned int format)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4341_priv *cs4341 = snd_soc_component_get_drvdata(component);\n\n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcs4341->fmt = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs4341_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4341_priv *cs4341 = snd_soc_component_get_drvdata(component);\n\tunsigned int mode = 0;\n\tint b24 = 0;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tb24 = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported PCM format 0x%08x.\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cs4341->fmt) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmode = b24 ? CS4341_MODE2_DIF_I2S_24 : CS4341_MODE2_DIF_I2S_16;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tmode = CS4341_MODE2_DIF_LJ_24;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tmode = b24 ? CS4341_MODE2_DIF_RJ_24 : CS4341_MODE2_DIF_RJ_16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported DAI format 0x%08x.\\n\",\n\t\t\tcs4341->fmt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_component_update_bits(component, CS4341_REG_MODE2,\n\t\t\t\t\t     CS4341_MODE2_DIF, mode);\n}\n\nstatic int cs4341_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component, CS4341_REG_VOLA,\n\t\t\t\t\t    CS4341_VOLX_MUTE,\n\t\t\t\t\t    mute ? CS4341_VOLX_MUTE : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_soc_component_update_bits(component, CS4341_REG_VOLB,\n\t\t\t\t\t     CS4341_VOLX_MUTE,\n\t\t\t\t\t     mute ? CS4341_VOLX_MUTE : 0);\n}\n\nstatic DECLARE_TLV_DB_SCALE(out_tlv, -9000, 100, 0);\n\nstatic const char * const deemph[] = {\n\t\"None\", \"44.1k\", \"48k\", \"32k\",\n};\n\nstatic const struct soc_enum deemph_enum =\n\tSOC_ENUM_SINGLE(CS4341_REG_MODE2, 2, 4, deemph);\n\nstatic const char * const srzc[] = {\n\t\"Immediate\", \"Zero Cross\", \"Soft Ramp\", \"SR on ZC\",\n};\n\nstatic const struct soc_enum srzc_enum =\n\tSOC_ENUM_SINGLE(CS4341_REG_MIX, 5, 4, srzc);\n\n\nstatic const struct snd_soc_dapm_widget cs4341_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"HiFi DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"OutA\"),\n\tSND_SOC_DAPM_OUTPUT(\"OutB\"),\n};\n\nstatic const struct snd_soc_dapm_route cs4341_routes[] = {\n\t{ \"OutA\", NULL, \"HiFi DAC\" },\n\t{ \"OutB\", NULL, \"HiFi DAC\" },\n\t{ \"DAC Playback\", NULL, \"OutA\" },\n\t{ \"DAC Playback\", NULL, \"OutB\" },\n};\n\nstatic const struct snd_kcontrol_new cs4341_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\",\n\t\t\t CS4341_REG_VOLA, CS4341_REG_VOLB, 0, 90, 1, out_tlv),\n\tSOC_ENUM(\"De-Emphasis Control\", deemph_enum),\n\tSOC_ENUM(\"Soft Ramp Zero Cross Control\", srzc_enum),\n\tSOC_SINGLE(\"Auto-Mute Switch\", CS4341_REG_MODE2, 7, 1, 0),\n\tSOC_SINGLE(\"Popguard Transient Switch\", CS4341_REG_MODE2, 1, 1, 0),\n};\n\nstatic const struct snd_soc_dai_ops cs4341_dai_ops = {\n\t.set_fmt\t= cs4341_set_fmt,\n\t.hw_params\t= cs4341_hw_params,\n\t.mute_stream\t= cs4341_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs4341_dai = {\n\t.name\t\t\t= \"cs4341a-hifi\",\n\t.playback\t\t= {\n\t\t.stream_name\t= \"DAC Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_96000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.ops\t\t\t= &cs4341_dai_ops,\n\t.symmetric_rate\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver soc_component_cs4341 = {\n\t.controls\t\t= cs4341_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4341_controls),\n\t.dapm_widgets\t\t= cs4341_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4341_dapm_widgets),\n\t.dapm_routes\t\t= cs4341_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4341_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id __maybe_unused cs4341_dt_ids[] = {\n\t{ .compatible = \"cirrus,cs4341a\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs4341_dt_ids);\n\nstatic int cs4341_probe(struct device *dev)\n{\n\tstruct cs4341_priv *cs4341 = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs4341_reg_defaults); i++)\n\t\tregmap_write(cs4341->regmap, cs4341_reg_defaults[i].reg,\n\t\t\t     cs4341_reg_defaults[i].def);\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_cs4341,\n\t\t\t\t\t       &cs4341_dai, 1);\n}\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int cs4341_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct cs4341_priv *cs4341;\n\n\tcs4341 = devm_kzalloc(&i2c->dev, sizeof(*cs4341), GFP_KERNEL);\n\tif (!cs4341)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, cs4341);\n\n\tcs4341->regcfg.reg_bits\t\t= 8;\n\tcs4341->regcfg.val_bits\t\t= 8;\n\tcs4341->regcfg.max_register\t= CS4341_REG_VOLB;\n\tcs4341->regcfg.cache_type\t= REGCACHE_FLAT;\n\tcs4341->regcfg.reg_defaults\t= cs4341_reg_defaults;\n\tcs4341->regcfg.num_reg_defaults\t= ARRAY_SIZE(cs4341_reg_defaults);\n\tcs4341->regmap = devm_regmap_init_i2c(i2c, &cs4341->regcfg);\n\tif (IS_ERR(cs4341->regmap))\n\t\treturn PTR_ERR(cs4341->regmap);\n\n\treturn cs4341_probe(&i2c->dev);\n}\n\nstatic const struct i2c_device_id cs4341_i2c_id[] = {\n\t{ \"cs4341\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cs4341_i2c_id);\n\nstatic struct i2c_driver cs4341_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs4341-i2c\",\n\t\t.of_match_table = of_match_ptr(cs4341_dt_ids),\n\t},\n\t.probe = cs4341_i2c_probe,\n\t.id_table = cs4341_i2c_id,\n};\n#endif\n\n#if defined(CONFIG_SPI_MASTER)\nstatic bool cs4341_reg_readable(struct device *dev, unsigned int reg)\n{\n\treturn false;\n}\n\nstatic int cs4341_spi_probe(struct spi_device *spi)\n{\n\tstruct cs4341_priv *cs4341;\n\tint ret;\n\n\tcs4341 = devm_kzalloc(&spi->dev, sizeof(*cs4341), GFP_KERNEL);\n\tif (!cs4341)\n\t\treturn -ENOMEM;\n\n\tif (!spi->bits_per_word)\n\t\tspi->bits_per_word = 8;\n\tif (!spi->max_speed_hz)\n\t\tspi->max_speed_hz = 6000000;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, cs4341);\n\n\tcs4341->regcfg.reg_bits\t\t= 16;\n\tcs4341->regcfg.val_bits\t\t= 8;\n\tcs4341->regcfg.write_flag_mask\t= 0x20;\n\tcs4341->regcfg.max_register\t= CS4341_REG_VOLB;\n\tcs4341->regcfg.cache_type\t= REGCACHE_FLAT;\n\tcs4341->regcfg.readable_reg\t= cs4341_reg_readable;\n\tcs4341->regcfg.reg_defaults\t= cs4341_reg_defaults;\n\tcs4341->regcfg.num_reg_defaults\t= ARRAY_SIZE(cs4341_reg_defaults);\n\tcs4341->regmap = devm_regmap_init_spi(spi, &cs4341->regcfg);\n\tif (IS_ERR(cs4341->regmap))\n\t\treturn PTR_ERR(cs4341->regmap);\n\n\treturn cs4341_probe(&spi->dev);\n}\n\nstatic const struct spi_device_id cs4341_spi_ids[] = {\n\t{ \"cs4341a\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, cs4341_spi_ids);\n\nstatic struct spi_driver cs4341_spi_driver = {\n\t.driver = {\n\t\t.name = \"cs4341-spi\",\n\t\t.of_match_table = of_match_ptr(cs4341_dt_ids),\n\t},\n\t.probe = cs4341_spi_probe,\n\t.id_table = cs4341_spi_ids,\n};\n#endif\n\nstatic int __init cs4341_init(void)\n{\n\tint ret = 0;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&cs4341_i2c_driver);\n\tif (ret)\n\t\treturn ret;\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&cs4341_spi_driver);\n#endif\n\n\treturn ret;\n}\nmodule_init(cs4341_init);\n\nstatic void __exit cs4341_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&cs4341_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&cs4341_spi_driver);\n#endif\n}\nmodule_exit(cs4341_exit);\n\nMODULE_AUTHOR(\"Alexander Shiyan <shc_work@mail.ru>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS4341 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}