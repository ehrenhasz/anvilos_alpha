{
  "module_name": "wm8776.c",
  "hash_id": "1225c40c96cc47fc82be16e256c630d948a25d56b4308c21acfaa1e1c250a84c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8776.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8776.h\"\n\nenum wm8776_chip_type {\n\tWM8775 = 1,\n\tWM8776,\n};\n\n \nstruct wm8776_priv {\n\tstruct regmap *regmap;\n\tint sysclk[2];\n};\n\nstatic const struct reg_default wm8776_reg_defaults[] = {\n\t{  0, 0x79 },\n\t{  1, 0x79 },\n\t{  2, 0x79 },\n\t{  3, 0xff },\n\t{  4, 0xff },\n\t{  5, 0xff },\n\t{  6, 0x00 },\n\t{  7, 0x90 },\n\t{  8, 0x00 },\n\t{  9, 0x00 },\n\t{ 10, 0x22 },\n\t{ 11, 0x22 },\n\t{ 12, 0x22 },\n\t{ 13, 0x08 },\n\t{ 14, 0xcf },\n\t{ 15, 0xcf },\n\t{ 16, 0x7b },\n\t{ 17, 0x00 },\n\t{ 18, 0x32 },\n\t{ 19, 0x00 },\n\t{ 20, 0xa6 },\n\t{ 21, 0x01 },\n\t{ 22, 0x01 },\n};\n\nstatic bool wm8776_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8776_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8776_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8776_RESET, 0);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(hp_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -10350, 50, 1);\n\nstatic const struct snd_kcontrol_new wm8776_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", WM8776_HPLVOL, WM8776_HPRVOL,\n\t\t 0, 127, 0, hp_tlv),\nSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", WM8776_DACLVOL, WM8776_DACRVOL,\n\t\t 0, 255, 0, dac_tlv),\nSOC_SINGLE(\"Digital Playback ZC Switch\", WM8776_DACCTRL1, 0, 1, 0),\n\nSOC_SINGLE(\"Deemphasis Switch\", WM8776_DACCTRL2, 0, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8776_ADCLVOL, WM8776_ADCRVOL,\n\t\t 0, 255, 0, adc_tlv),\nSOC_DOUBLE(\"Capture Switch\", WM8776_ADCMUX, 7, 6, 1, 1),\nSOC_DOUBLE_R(\"Capture ZC Switch\", WM8776_ADCLVOL, WM8776_ADCRVOL, 8, 1, 0),\nSOC_SINGLE(\"Capture HPF Switch\", WM8776_ADCIFCTRL, 8, 1, 1),\n};\n\nstatic const struct snd_kcontrol_new inmix_controls[] = {\nSOC_DAPM_SINGLE(\"AIN1 Switch\", WM8776_ADCMUX, 0, 1, 0),\nSOC_DAPM_SINGLE(\"AIN2 Switch\", WM8776_ADCMUX, 1, 1, 0),\nSOC_DAPM_SINGLE(\"AIN3 Switch\", WM8776_ADCMUX, 2, 1, 0),\nSOC_DAPM_SINGLE(\"AIN4 Switch\", WM8776_ADCMUX, 3, 1, 0),\nSOC_DAPM_SINGLE(\"AIN5 Switch\", WM8776_ADCMUX, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new outmix_controls[] = {\nSOC_DAPM_SINGLE(\"DAC Switch\", WM8776_OUTMUX, 0, 1, 0),\nSOC_DAPM_SINGLE(\"AUX Switch\", WM8776_OUTMUX, 1, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Switch\", WM8776_OUTMUX, 2, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8776_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"AUX\"),\n\nSND_SOC_DAPM_INPUT(\"AIN1\"),\nSND_SOC_DAPM_INPUT(\"AIN2\"),\nSND_SOC_DAPM_INPUT(\"AIN3\"),\nSND_SOC_DAPM_INPUT(\"AIN4\"),\nSND_SOC_DAPM_INPUT(\"AIN5\"),\n\nSND_SOC_DAPM_MIXER(\"Input Mixer\", WM8776_PWRDOWN, 6, 1,\n\t\t   inmix_controls, ARRAY_SIZE(inmix_controls)),\n\nSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", WM8776_PWRDOWN, 1, 1),\nSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", WM8776_PWRDOWN, 2, 1),\n\nSND_SOC_DAPM_MIXER(\"Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t   outmix_controls, ARRAY_SIZE(outmix_controls)),\n\nSND_SOC_DAPM_PGA(\"Headphone PGA\", WM8776_PWRDOWN, 3, 1, NULL, 0),\n\nSND_SOC_DAPM_OUTPUT(\"VOUT\"),\n\nSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route routes[] = {\n\t{ \"Input Mixer\", \"AIN1 Switch\", \"AIN1\" },\n\t{ \"Input Mixer\", \"AIN2 Switch\", \"AIN2\" },\n\t{ \"Input Mixer\", \"AIN3 Switch\", \"AIN3\" },\n\t{ \"Input Mixer\", \"AIN4 Switch\", \"AIN4\" },\n\t{ \"Input Mixer\", \"AIN5 Switch\", \"AIN5\" },\n\n\t{ \"ADC\", NULL, \"Input Mixer\" },\n\n\t{ \"Output Mixer\", \"DAC Switch\", \"DAC\" },\n\t{ \"Output Mixer\", \"AUX Switch\", \"AUX\" },\n\t{ \"Output Mixer\", \"Bypass Switch\", \"Input Mixer\" },\n\n\t{ \"VOUT\", NULL, \"Output Mixer\" },\n\n\t{ \"Headphone PGA\", NULL, \"Output Mixer\" },\n\n\t{ \"HPOUTL\", NULL, \"Headphone PGA\" },\n\t{ \"HPOUTR\", NULL, \"Headphone PGA\" },\n};\n\nstatic int wm8776_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint reg, iface, master;\n\n\tswitch (dai->driver->id) {\n\tcase WM8776_DAI_DAC:\n\t\treg = WM8776_DACIFCTRL;\n\t\tmaster = 0x80;\n\t\tbreak;\n\tcase WM8776_DAI_ADC:\n\t\treg = WM8776_ADCIFCTRL;\n\t\tmaster = 0x100;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tiface = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x00c;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x008;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x004;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, reg, 0xf, iface);\n\tsnd_soc_component_update_bits(component, WM8776_MSTRCTRL, 0x180, master);\n\n\treturn 0;\n}\n\nstatic int mclk_ratios[] = {\n\t128,\n\t192,\n\t256,\n\t384,\n\t512,\n\t768,\n};\n\nstatic int wm8776_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8776_priv *wm8776 = snd_soc_component_get_drvdata(component);\n\tint iface_reg, iface;\n\tint ratio_shift, master;\n\tint i;\n\n\tswitch (dai->driver->id) {\n\tcase WM8776_DAI_DAC:\n\t\tiface_reg = WM8776_DACIFCTRL;\n\t\tmaster = 0x80;\n\t\tratio_shift = 4;\n\t\tbreak;\n\tcase WM8776_DAI_ADC:\n\t\tiface_reg = WM8776_ADCIFCTRL;\n\t\tmaster = 0x100;\n\t\tratio_shift = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tiface = 0;\n\t\tbreak;\n\tcase 20:\n\t\tiface = 0x10;\n\t\tbreak;\n\tcase 24:\n\t\tiface = 0x20;\n\t\tbreak;\n\tcase 32:\n\t\tiface = 0x30;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample size: %i\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (snd_soc_component_read(component, WM8776_MSTRCTRL) & master) {\n\t\tfor (i = 0; i < ARRAY_SIZE(mclk_ratios); i++) {\n\t\t\tif (wm8776->sysclk[dai->driver->id] / params_rate(params)\n\t\t\t    == mclk_ratios[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(mclk_ratios)) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Unable to configure MCLK ratio %d/%d\\n\",\n\t\t\t\twm8776->sysclk[dai->driver->id], params_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"MCLK is %dfs\\n\", mclk_ratios[i]);\n\n\t\tsnd_soc_component_update_bits(component, WM8776_MSTRCTRL,\n\t\t\t\t    0x7 << ratio_shift, i << ratio_shift);\n\t} else {\n\t\tdev_dbg(component->dev, \"DAI in slave mode\\n\");\n\t}\n\n\tsnd_soc_component_update_bits(component, iface_reg, 0x30, iface);\n\n\treturn 0;\n}\n\nstatic int wm8776_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\treturn snd_soc_component_write(component, WM8776_DACMUTE, !!mute);\n}\n\nstatic int wm8776_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8776_priv *wm8776 = snd_soc_component_get_drvdata(component);\n\n\tif (WARN_ON(dai->driver->id >= ARRAY_SIZE(wm8776->sysclk)))\n\t\treturn -EINVAL;\n\n\twm8776->sysclk[dai->driver->id] = freq;\n\n\treturn 0;\n}\n\nstatic int wm8776_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8776_priv *wm8776 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_sync(wm8776->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8776_PWRDOWN, 1, 0);\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8776_PWRDOWN, 1, 1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define WM8776_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8776_dac_ops = {\n\t.mute_stream\t= wm8776_mute,\n\t.hw_params      = wm8776_hw_params,\n\t.set_fmt        = wm8776_set_fmt,\n\t.set_sysclk     = wm8776_set_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops wm8776_adc_ops = {\n\t.hw_params      = wm8776_hw_params,\n\t.set_fmt        = wm8776_set_fmt,\n\t.set_sysclk     = wm8776_set_sysclk,\n};\n\nstatic struct snd_soc_dai_driver wm8776_dai[] = {\n\t{\n\t\t.name = \"wm8776-hifi-playback\",\n\t\t.id\t= WM8776_DAI_DAC,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min = 32000,\n\t\t\t.rate_max = 192000,\n\t\t\t.formats = WM8776_FORMATS,\n\t\t},\n\t\t.ops = &wm8776_dac_ops,\n\t},\n\t{\n\t\t.name = \"wm8776-hifi-capture\",\n\t\t.id\t= WM8776_DAI_ADC,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t\t.rate_min = 32000,\n\t\t\t.rate_max = 96000,\n\t\t\t.formats = WM8776_FORMATS,\n\t\t},\n\t\t.ops = &wm8776_adc_ops,\n\t},\n};\n\nstatic int wm8776_probe(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\tret = wm8776_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8776_HPRVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8776_DACRVOL, 0x100, 0x100);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8776 = {\n\t.probe\t\t\t= wm8776_probe,\n\t.set_bias_level\t\t= wm8776_set_bias_level,\n\t.controls\t\t= wm8776_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8776_snd_controls),\n\t.dapm_widgets\t\t= wm8776_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8776_dapm_widgets),\n\t.dapm_routes\t\t= routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8776_of_match[] = {\n\t{ .compatible = \"wlf,wm8776\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8776_of_match);\n\nstatic const struct regmap_config wm8776_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8776_RESET,\n\n\t.reg_defaults = wm8776_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8776_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8776_volatile,\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8776_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8776_priv *wm8776;\n\tint ret;\n\n\twm8776 = devm_kzalloc(&spi->dev, sizeof(struct wm8776_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8776 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8776->regmap = devm_regmap_init_spi(spi, &wm8776_regmap);\n\tif (IS_ERR(wm8776->regmap))\n\t\treturn PTR_ERR(wm8776->regmap);\n\n\tspi_set_drvdata(spi, wm8776);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_dev_wm8776, wm8776_dai, ARRAY_SIZE(wm8776_dai));\n\n\treturn ret;\n}\n\nstatic struct spi_driver wm8776_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8776\",\n\t\t.of_match_table = wm8776_of_match,\n\t},\n\t.probe\t\t= wm8776_spi_probe,\n};\n#endif  \n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8776_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8776_priv *wm8776;\n\tint ret;\n\n\twm8776 = devm_kzalloc(&i2c->dev, sizeof(struct wm8776_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8776 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8776->regmap = devm_regmap_init_i2c(i2c, &wm8776_regmap);\n\tif (IS_ERR(wm8776->regmap))\n\t\treturn PTR_ERR(wm8776->regmap);\n\n\ti2c_set_clientdata(i2c, wm8776);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8776, wm8776_dai, ARRAY_SIZE(wm8776_dai));\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8776_i2c_id[] = {\n\t{ \"wm8775\", WM8775 },\n\t{ \"wm8776\", WM8776 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8776_i2c_id);\n\nstatic struct i2c_driver wm8776_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8776\",\n\t\t.of_match_table = wm8776_of_match,\n\t},\n\t.probe = wm8776_i2c_probe,\n\t.id_table = wm8776_i2c_id,\n};\n#endif\n\nstatic int __init wm8776_modinit(void)\n{\n\tint ret = 0;\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8776_i2c_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8776 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8776_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8776 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\nmodule_init(wm8776_modinit);\n\nstatic void __exit wm8776_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8776_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8776_spi_driver);\n#endif\n}\nmodule_exit(wm8776_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8776 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}