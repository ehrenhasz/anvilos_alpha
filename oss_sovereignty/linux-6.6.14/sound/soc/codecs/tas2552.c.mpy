{
  "module_name": "tas2552.c",
  "hash_id": "d5f62f15edbace2748515739dfe575d9c6595ba42aa502a1431b3e1e39c2823c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2552.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n#include <sound/tas2552-plat.h>\n#include <dt-bindings/sound/tas2552.h>\n\n#include \"tas2552.h\"\n\nstatic const struct reg_default tas2552_reg_defs[] = {\n\t{TAS2552_CFG_1, 0x22},\n\t{TAS2552_CFG_3, 0x80},\n\t{TAS2552_DOUT, 0x00},\n\t{TAS2552_OUTPUT_DATA, 0xc0},\n\t{TAS2552_PDM_CFG, 0x01},\n\t{TAS2552_PGA_GAIN, 0x00},\n\t{TAS2552_BOOST_APT_CTRL, 0x0f},\n\t{TAS2552_RESERVED_0D, 0xbe},\n\t{TAS2552_LIMIT_RATE_HYS, 0x08},\n\t{TAS2552_CFG_2, 0xef},\n\t{TAS2552_SER_CTRL_1, 0x00},\n\t{TAS2552_SER_CTRL_2, 0x00},\n\t{TAS2552_PLL_CTRL_1, 0x10},\n\t{TAS2552_PLL_CTRL_2, 0x00},\n\t{TAS2552_PLL_CTRL_3, 0x00},\n\t{TAS2552_BTIP, 0x8f},\n\t{TAS2552_BTS_CTRL, 0x80},\n\t{TAS2552_LIMIT_RELEASE, 0x04},\n\t{TAS2552_LIMIT_INT_COUNT, 0x00},\n\t{TAS2552_EDGE_RATE_CTRL, 0x40},\n\t{TAS2552_VBAT_DATA, 0x00},\n};\n\n#define TAS2552_NUM_SUPPLIES\t3\nstatic const char *tas2552_supply_names[TAS2552_NUM_SUPPLIES] = {\n\t\"vbat\",\t\t \n\t\"iovdd\",\t \n\t\"avdd\",\t\t \n};\n\nstruct tas2552_data {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\tstruct i2c_client *tas2552_client;\n\tstruct regulator_bulk_data supplies[TAS2552_NUM_SUPPLIES];\n\tstruct gpio_desc *enable_gpio;\n\tunsigned char regs[TAS2552_VBAT_DATA];\n\tunsigned int pll_clkin;\n\tint pll_clk_id;\n\tunsigned int pdm_clk;\n\tint pdm_clk_id;\n\n\tunsigned int dai_fmt;\n\tunsigned int tdm_delay;\n};\n\nstatic int tas2552_post_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_write(component, TAS2552_RESERVED_0D, 0xc0);\n\t\tsnd_soc_component_update_bits(component, TAS2552_LIMIT_RATE_HYS, (1 << 5),\n\t\t\t\t    (1 << 5));\n\t\tsnd_soc_component_update_bits(component, TAS2552_CFG_2, 1, 0);\n\t\tsnd_soc_component_update_bits(component, TAS2552_CFG_1, TAS2552_SWS, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, TAS2552_CFG_1, TAS2552_SWS,\n\t\t\t\t    TAS2552_SWS);\n\t\tsnd_soc_component_update_bits(component, TAS2552_CFG_2, 1, 1);\n\t\tsnd_soc_component_update_bits(component, TAS2552_LIMIT_RATE_HYS, (1 << 5), 0);\n\t\tsnd_soc_component_write(component, TAS2552_RESERVED_0D, 0xbe);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic const char * const tas2552_input_texts[] = {\n\t\"Digital\", \"Analog\" };\nstatic SOC_ENUM_SINGLE_DECL(tas2552_input_mux_enum, TAS2552_CFG_3, 7,\n\t\t\t    tas2552_input_texts);\n\nstatic const struct snd_kcontrol_new tas2552_input_mux_control =\n\tSOC_DAPM_ENUM(\"Route\", tas2552_input_mux_enum);\n\nstatic const struct snd_soc_dapm_widget tas2552_dapm_widgets[] =\n{\n\tSND_SOC_DAPM_INPUT(\"IN\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Input selection\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas2552_input_mux_control),\n\n\tSND_SOC_DAPM_AIF_IN(\"DAC IN\", \"DAC Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"ClassD\", TAS2552_CFG_2, 7, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL\", TAS2552_CFG_2, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_POST(\"Post Event\", tas2552_post_event),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT\")\n};\n\nstatic const struct snd_soc_dapm_route tas2552_audio_map[] = {\n\t{\"DAC\", NULL, \"DAC IN\"},\n\t{\"Input selection\", \"Digital\", \"DAC\"},\n\t{\"Input selection\", \"Analog\", \"IN\"},\n\t{\"ClassD\", NULL, \"Input selection\"},\n\t{\"OUT\", NULL, \"ClassD\"},\n\t{\"ClassD\", NULL, \"PLL\"},\n};\n\n#ifdef CONFIG_PM\nstatic void tas2552_sw_shutdown(struct tas2552_data *tas2552, int sw_shutdown)\n{\n\tu8 cfg1_reg = 0;\n\n\tif (!tas2552->component)\n\t\treturn;\n\n\tif (sw_shutdown)\n\t\tcfg1_reg = TAS2552_SWS;\n\n\tsnd_soc_component_update_bits(tas2552->component, TAS2552_CFG_1, TAS2552_SWS,\n\t\t\t    cfg1_reg);\n}\n#endif\n\nstatic int tas2552_setup_pll(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(component->dev);\n\tbool bypass_pll = false;\n\tunsigned int pll_clk = params_rate(params) * 512;\n\tunsigned int pll_clkin = tas2552->pll_clkin;\n\tu8 pll_enable;\n\n\tif (!pll_clkin) {\n\t\tif (tas2552->pll_clk_id != TAS2552_PLL_CLKIN_BCLK)\n\t\t\treturn -EINVAL;\n\n\t\tpll_clkin = snd_soc_params_to_bclk(params);\n\t\tpll_clkin += tas2552->tdm_delay;\n\t}\n\n\tpll_enable = snd_soc_component_read(component, TAS2552_CFG_2) & TAS2552_PLL_ENABLE;\n\tsnd_soc_component_update_bits(component, TAS2552_CFG_2, TAS2552_PLL_ENABLE, 0);\n\n\tif (pll_clkin == pll_clk)\n\t\tbypass_pll = true;\n\n\tif (bypass_pll) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, TAS2552_PLL_CTRL_2,\n\t\t\t\t    TAS2552_PLL_BYPASS, TAS2552_PLL_BYPASS);\n\t} else {\n\t\t \n\t\tunsigned int d, q, t;\n\t\tu8 j;\n\t\tu8 pll_sel = (tas2552->pll_clk_id << 3) & TAS2552_PLL_SRC_MASK;\n\t\tu8 p = snd_soc_component_read(component, TAS2552_PLL_CTRL_1);\n\n\t\tp = (p >> 7);\n\nrecalc:\n\t\tt = (pll_clk * 2) << p;\n\t\tj = t / pll_clkin;\n\t\td = t % pll_clkin;\n\t\tt = pll_clkin / 10000;\n\t\tq = d / (t + 1);\n\t\td = q + ((9999 - pll_clkin % 10000) * (d / t - q)) / 10000;\n\n\t\tif (d && (pll_clkin < 512000 || pll_clkin > 9200000)) {\n\t\t\tif (tas2552->pll_clk_id == TAS2552_PLL_CLKIN_BCLK) {\n\t\t\t\tpll_clkin = 1800000;\n\t\t\t\tpll_sel = (TAS2552_PLL_CLKIN_1_8_FIXED << 3) &\n\t\t\t\t\t\t\tTAS2552_PLL_SRC_MASK;\n\t\t\t} else {\n\t\t\t\tpll_clkin = snd_soc_params_to_bclk(params);\n\t\t\t\tpll_clkin += tas2552->tdm_delay;\n\t\t\t\tpll_sel = (TAS2552_PLL_CLKIN_BCLK << 3) &\n\t\t\t\t\t\t\tTAS2552_PLL_SRC_MASK;\n\t\t\t}\n\t\t\tgoto recalc;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, TAS2552_CFG_1, TAS2552_PLL_SRC_MASK,\n\t\t\t\t    pll_sel);\n\n\t\tsnd_soc_component_update_bits(component, TAS2552_PLL_CTRL_1,\n\t\t\t\t    TAS2552_PLL_J_MASK, j);\n\t\t \n\t\tsnd_soc_component_write(component, TAS2552_PLL_CTRL_2,\n\t\t\t      TAS2552_PLL_D_UPPER(d));\n\t\tsnd_soc_component_write(component, TAS2552_PLL_CTRL_3,\n\t\t\t      TAS2552_PLL_D_LOWER(d));\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, TAS2552_CFG_2, TAS2552_PLL_ENABLE,\n\t\t\t    pll_enable);\n\n\treturn 0;\n}\n\nstatic int tas2552_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(component->dev);\n\tint cpf;\n\tu8 ser_ctrl1_reg, wclk_rate;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tser_ctrl1_reg = TAS2552_WORDLENGTH_16BIT;\n\t\tcpf = 32 + tas2552->tdm_delay;\n\t\tbreak;\n\tcase 20:\n\t\tser_ctrl1_reg = TAS2552_WORDLENGTH_20BIT;\n\t\tcpf = 64 + tas2552->tdm_delay;\n\t\tbreak;\n\tcase 24:\n\t\tser_ctrl1_reg = TAS2552_WORDLENGTH_24BIT;\n\t\tcpf = 64 + tas2552->tdm_delay;\n\t\tbreak;\n\tcase 32:\n\t\tser_ctrl1_reg = TAS2552_WORDLENGTH_32BIT;\n\t\tcpf = 64 + tas2552->tdm_delay;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Not supported sample size: %d\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cpf <= 32)\n\t\tser_ctrl1_reg |= TAS2552_CLKSPERFRAME_32;\n\telse if (cpf <= 64)\n\t\tser_ctrl1_reg |= TAS2552_CLKSPERFRAME_64;\n\telse if (cpf <= 128)\n\t\tser_ctrl1_reg |= TAS2552_CLKSPERFRAME_128;\n\telse\n\t\tser_ctrl1_reg |= TAS2552_CLKSPERFRAME_256;\n\n\tsnd_soc_component_update_bits(component, TAS2552_SER_CTRL_1,\n\t\t\t    TAS2552_WORDLENGTH_MASK | TAS2552_CLKSPERFRAME_MASK,\n\t\t\t    ser_ctrl1_reg);\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_8KHZ;\n\t\tbreak;\n\tcase 11025:\n\tcase 12000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_11_12KHZ;\n\t\tbreak;\n\tcase 16000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_16KHZ;\n\t\tbreak;\n\tcase 22050:\n\tcase 24000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_22_24KHZ;\n\t\tbreak;\n\tcase 32000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_32KHZ;\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_44_48KHZ;\n\t\tbreak;\n\tcase 88200:\n\tcase 96000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_88_96KHZ;\n\t\tbreak;\n\tcase 176400:\n\tcase 192000:\n\t\twclk_rate = TAS2552_WCLK_FREQ_176_192KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Not supported sample rate: %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, TAS2552_CFG_3, TAS2552_WCLK_FREQ_MASK,\n\t\t\t    wclk_rate);\n\n\treturn tas2552_setup_pll(component, params);\n}\n\n#define TAS2552_DAI_FMT_MASK\t(TAS2552_BCLKDIR | \\\n\t\t\t\t TAS2552_WCLKDIR | \\\n\t\t\t\t TAS2552_DATAFORMAT_MASK)\nstatic int tas2552_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\tint delay = 0;\n\n\t \n\tif (tas2552->dai_fmt == SND_SOC_DAIFMT_DSP_A)\n\t\tdelay += (tas2552->tdm_delay + 1);\n\telse if (tas2552->dai_fmt == SND_SOC_DAIFMT_DSP_B)\n\t\tdelay += tas2552->tdm_delay;\n\n\t \n\tsnd_soc_component_write(component, TAS2552_SER_CTRL_2, delay);\n\n\treturn 0;\n}\n\nstatic int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(component->dev);\n\tu8 serial_format;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tserial_format = 0x00;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tserial_format = TAS2552_WCLKDIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tserial_format = TAS2552_BCLKDIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tserial_format = (TAS2552_BCLKDIR | TAS2552_WCLKDIR);\n\t\tbreak;\n\tdefault:\n\t\tdev_vdbg(component->dev, \"DAI Format master is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\n\t\t       SND_SOC_DAIFMT_INV_MASK)) {\n\tcase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF):\n\tcase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF):\n\t\tserial_format |= TAS2552_DATAFORMAT_DSP;\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF):\n\t\tserial_format |= TAS2552_DATAFORMAT_RIGHT_J;\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\n\t\tserial_format |= TAS2552_DATAFORMAT_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\tdev_vdbg(component->dev, \"DAI Format is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\ttas2552->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tsnd_soc_component_update_bits(component, TAS2552_SER_CTRL_1, TAS2552_DAI_FMT_MASK,\n\t\t\t    serial_format);\n\treturn 0;\n}\n\nstatic int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t  unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(component->dev);\n\tu8 reg, mask, val;\n\n\tswitch (clk_id) {\n\tcase TAS2552_PLL_CLKIN_MCLK:\n\tcase TAS2552_PLL_CLKIN_IVCLKIN:\n\t\tif (freq < 512000 || freq > 24576000) {\n\t\t\t \n\t\t\tdev_warn(component->dev, \"Out of range PLL_CLKIN: %u\\n\",\n\t\t\t\t freq);\n\t\t\tclk_id = TAS2552_PLL_CLKIN_BCLK;\n\t\t\tfreq = 0;\n\t\t}\n\t\tfallthrough;\n\tcase TAS2552_PLL_CLKIN_BCLK:\n\tcase TAS2552_PLL_CLKIN_1_8_FIXED:\n\t\tmask = TAS2552_PLL_SRC_MASK;\n\t\tval = (clk_id << 3) & mask;  \n\t\treg = TAS2552_CFG_1;\n\t\ttas2552->pll_clk_id = clk_id;\n\t\ttas2552->pll_clkin = freq;\n\t\tbreak;\n\tcase TAS2552_PDM_CLK_PLL:\n\tcase TAS2552_PDM_CLK_IVCLKIN:\n\tcase TAS2552_PDM_CLK_BCLK:\n\tcase TAS2552_PDM_CLK_MCLK:\n\t\tmask = TAS2552_PDM_CLK_SEL_MASK;\n\t\tval = (clk_id >> 1) & mask;  \n\t\treg = TAS2552_PDM_CFG;\n\t\ttas2552->pdm_clk_id = clk_id;\n\t\ttas2552->pdm_clk = freq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clk id: %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int tas2552_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\tunsigned int lsb;\n\n\tif (unlikely(!tx_mask)) {\n\t\tdev_err(component->dev, \"tx masks need to be non 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlsb = __ffs(tx_mask);\n\tif ((lsb + 1) != __fls(tx_mask)) {\n\t\tdev_err(component->dev, \"Invalid mask, slots must be adjacent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttas2552->tdm_delay = lsb * slot_width;\n\n\t \n\tsnd_soc_component_update_bits(component, TAS2552_DOUT,\n\t\t\t    TAS2552_SDOUT_TRISTATE, TAS2552_SDOUT_TRISTATE);\n\n\treturn 0;\n}\n\nstatic int tas2552_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tu8 cfg1_reg = 0;\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute)\n\t\tcfg1_reg |= TAS2552_MUTE;\n\n\tsnd_soc_component_update_bits(component, TAS2552_CFG_1, TAS2552_MUTE, cfg1_reg);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int tas2552_runtime_suspend(struct device *dev)\n{\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\n\n\ttas2552_sw_shutdown(tas2552, 1);\n\n\tregcache_cache_only(tas2552->regmap, true);\n\tregcache_mark_dirty(tas2552->regmap);\n\n\tgpiod_set_value(tas2552->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int tas2552_runtime_resume(struct device *dev)\n{\n\tstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\n\n\tgpiod_set_value(tas2552->enable_gpio, 1);\n\n\ttas2552_sw_shutdown(tas2552, 0);\n\n\tregcache_cache_only(tas2552->regmap, false);\n\tregcache_sync(tas2552->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops tas2552_pm = {\n\tSET_RUNTIME_PM_OPS(tas2552_runtime_suspend, tas2552_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct snd_soc_dai_ops tas2552_speaker_dai_ops = {\n\t.hw_params\t= tas2552_hw_params,\n\t.prepare\t= tas2552_prepare,\n\t.set_sysclk\t= tas2552_set_dai_sysclk,\n\t.set_fmt\t= tas2552_set_dai_fmt,\n\t.set_tdm_slot\t= tas2552_set_dai_tdm_slot,\n\t.mute_stream\t= tas2552_mute,\n\t.no_capture_mute = 1,\n};\n\n \n#define TAS2552_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\n \nstatic struct snd_soc_dai_driver tas2552_dai[] = {\n\t{\n\t\t.name = \"tas2552-amplifier\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = TAS2552_FORMATS,\n\t\t},\n\t\t.ops = &tas2552_speaker_dai_ops,\n\t},\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -700, 100, 0);\n\nstatic const char * const tas2552_din_source_select[] = {\n\t\"Muted\",\n\t\"Left\",\n\t\"Right\",\n\t\"Left + Right average\",\n};\nstatic SOC_ENUM_SINGLE_DECL(tas2552_din_source_enum,\n\t\t\t    TAS2552_CFG_3, 3,\n\t\t\t    tas2552_din_source_select);\n\nstatic const struct snd_kcontrol_new tas2552_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Driver Playback Volume\",\n\t\t\t TAS2552_PGA_GAIN, 0, 0x1f, 0, dac_tlv),\n\tSOC_ENUM(\"DIN source\", tas2552_din_source_enum),\n};\n\nstatic int tas2552_component_probe(struct snd_soc_component *component)\n{\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\ttas2552->component = component;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\n\t\t\t\t    tas2552->supplies);\n\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value(tas2552->enable_gpio, 1);\n\n\tret = pm_runtime_resume_and_get(component->dev);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Enabling device failed: %d\\n\",\n\t\t\tret);\n\t\tgoto probe_fail;\n\t}\n\n\tsnd_soc_component_update_bits(component, TAS2552_CFG_1, TAS2552_MUTE, TAS2552_MUTE);\n\tsnd_soc_component_write(component, TAS2552_CFG_3, TAS2552_I2S_OUT_SEL |\n\t\t\t\t\t    TAS2552_DIN_SRC_SEL_AVG_L_R);\n\tsnd_soc_component_write(component, TAS2552_OUTPUT_DATA,\n\t\t      TAS2552_PDM_DATA_SEL_V_I |\n\t\t      TAS2552_R_DATA_OUT(TAS2552_DATA_OUT_V_DATA));\n\tsnd_soc_component_write(component, TAS2552_BOOST_APT_CTRL, TAS2552_APT_DELAY_200 |\n\t\t\t\t\t\t     TAS2552_APT_THRESH_20_17);\n\n\tsnd_soc_component_write(component, TAS2552_CFG_2, TAS2552_BOOST_EN | TAS2552_APT_EN |\n\t\t\t\t\t    TAS2552_LIM_EN);\n\n\treturn 0;\n\nprobe_fail:\n\tpm_runtime_put_noidle(component->dev);\n\tgpiod_set_value(tas2552->enable_gpio, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\n\t\t\t\t\ttas2552->supplies);\n\treturn ret;\n}\n\nstatic void tas2552_component_remove(struct snd_soc_component *component)\n{\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\n\tpm_runtime_put(component->dev);\n\n\tgpiod_set_value(tas2552->enable_gpio, 0);\n};\n\n#ifdef CONFIG_PM\nstatic int tas2552_suspend(struct snd_soc_component *component)\n{\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\n\t\t\t\t\ttas2552->supplies);\n\n\tif (ret != 0)\n\t\tdev_err(component->dev, \"Failed to disable supplies: %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int tas2552_resume(struct snd_soc_component *component)\n{\n\tstruct tas2552_data *tas2552 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\n\t\t\t\t    tas2552->supplies);\n\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\",\n\t\t\tret);\n\t}\n\n\treturn ret;\n}\n#else\n#define tas2552_suspend NULL\n#define tas2552_resume NULL\n#endif\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas2552 = {\n\t.probe\t\t\t= tas2552_component_probe,\n\t.remove\t\t\t= tas2552_component_remove,\n\t.suspend\t\t= tas2552_suspend,\n\t.resume\t\t\t= tas2552_resume,\n\t.controls\t\t= tas2552_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas2552_snd_controls),\n\t.dapm_widgets\t\t= tas2552_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas2552_dapm_widgets),\n\t.dapm_routes\t\t= tas2552_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas2552_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config tas2552_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = TAS2552_MAX_REG,\n\t.reg_defaults = tas2552_reg_defs,\n\t.num_reg_defaults = ARRAY_SIZE(tas2552_reg_defs),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int tas2552_probe(struct i2c_client *client)\n{\n\tstruct device *dev;\n\tstruct tas2552_data *data;\n\tint ret;\n\tint i;\n\n\tdev = &client->dev;\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (data == NULL)\n\t\treturn -ENOMEM;\n\n\tdata->enable_gpio = devm_gpiod_get_optional(dev, \"enable\",\n\t\t\t\t\t\t    GPIOD_OUT_LOW);\n\tif (IS_ERR(data->enable_gpio))\n\t\treturn PTR_ERR(data->enable_gpio);\n\n\tdata->tas2552_client = client;\n\tdata->regmap = devm_regmap_init_i2c(client, &tas2552_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->supplies); i++)\n\t\tdata->supplies[i].supply = tas2552_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),\n\t\t\t\t      data->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_set_autosuspend_delay(&client->dev, 1000);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\tpm_runtime_mark_last_busy(&client->dev);\n\tpm_runtime_put_sync_autosuspend(&client->dev);\n\n\tdev_set_drvdata(&client->dev, data);\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t      &soc_component_dev_tas2552,\n\t\t\t\t      tas2552_dai, ARRAY_SIZE(tas2552_dai));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Failed to register component: %d\\n\", ret);\n\t\tpm_runtime_get_noresume(&client->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void tas2552_i2c_remove(struct i2c_client *client)\n{\n\tpm_runtime_disable(&client->dev);\n}\n\nstatic const struct i2c_device_id tas2552_id[] = {\n\t{ \"tas2552\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas2552_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tas2552_of_match[] = {\n\t{ .compatible = \"ti,tas2552\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tas2552_of_match);\n#endif\n\nstatic struct i2c_driver tas2552_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas2552\",\n\t\t.of_match_table = of_match_ptr(tas2552_of_match),\n\t\t.pm = &tas2552_pm,\n\t},\n\t.probe = tas2552_probe,\n\t.remove = tas2552_i2c_remove,\n\t.id_table = tas2552_id,\n};\n\nmodule_i2c_driver(tas2552_i2c_driver);\n\nMODULE_AUTHOR(\"Dan Muprhy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"TAS2552 Audio amplifier driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}