{
  "module_name": "nau8822.c",
  "hash_id": "5112d3dd0454fa9822c9245f2268dcf517669b90fdb4bfa32098fe6dcf14b472",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8822.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <asm/div64.h>\n#include \"nau8822.h\"\n\n#define NAU_PLL_FREQ_MAX 100000000\n#define NAU_PLL_FREQ_MIN 90000000\n#define NAU_PLL_REF_MAX 33000000\n#define NAU_PLL_REF_MIN 8000000\n#define NAU_PLL_OPTOP_MIN 6\n\nstatic const int nau8822_mclk_scaler[] = { 10, 15, 20, 30, 40, 60, 80, 120 };\n\nstatic const struct reg_default nau8822_reg_defaults[] = {\n\t{ NAU8822_REG_POWER_MANAGEMENT_1, 0x0000 },\n\t{ NAU8822_REG_POWER_MANAGEMENT_2, 0x0000 },\n\t{ NAU8822_REG_POWER_MANAGEMENT_3, 0x0000 },\n\t{ NAU8822_REG_AUDIO_INTERFACE, 0x0050 },\n\t{ NAU8822_REG_COMPANDING_CONTROL, 0x0000 },\n\t{ NAU8822_REG_CLOCKING, 0x0140 },\n\t{ NAU8822_REG_ADDITIONAL_CONTROL, 0x0000 },\n\t{ NAU8822_REG_GPIO_CONTROL, 0x0000 },\n\t{ NAU8822_REG_JACK_DETECT_CONTROL_1, 0x0000 },\n\t{ NAU8822_REG_DAC_CONTROL, 0x0000 },\n\t{ NAU8822_REG_LEFT_DAC_DIGITAL_VOLUME, 0x00ff },\n\t{ NAU8822_REG_RIGHT_DAC_DIGITAL_VOLUME, 0x00ff },\n\t{ NAU8822_REG_JACK_DETECT_CONTROL_2, 0x0000 },\n\t{ NAU8822_REG_ADC_CONTROL, 0x0100 },\n\t{ NAU8822_REG_LEFT_ADC_DIGITAL_VOLUME, 0x00ff },\n\t{ NAU8822_REG_RIGHT_ADC_DIGITAL_VOLUME, 0x00ff },\n\t{ NAU8822_REG_EQ1, 0x012c },\n\t{ NAU8822_REG_EQ2, 0x002c },\n\t{ NAU8822_REG_EQ3, 0x002c },\n\t{ NAU8822_REG_EQ4, 0x002c },\n\t{ NAU8822_REG_EQ5, 0x002c },\n\t{ NAU8822_REG_DAC_LIMITER_1, 0x0032 },\n\t{ NAU8822_REG_DAC_LIMITER_2, 0x0000 },\n\t{ NAU8822_REG_NOTCH_FILTER_1, 0x0000 },\n\t{ NAU8822_REG_NOTCH_FILTER_2, 0x0000 },\n\t{ NAU8822_REG_NOTCH_FILTER_3, 0x0000 },\n\t{ NAU8822_REG_NOTCH_FILTER_4, 0x0000 },\n\t{ NAU8822_REG_ALC_CONTROL_1, 0x0038 },\n\t{ NAU8822_REG_ALC_CONTROL_2, 0x000b },\n\t{ NAU8822_REG_ALC_CONTROL_3, 0x0032 },\n\t{ NAU8822_REG_NOISE_GATE, 0x0010 },\n\t{ NAU8822_REG_PLL_N, 0x0008 },\n\t{ NAU8822_REG_PLL_K1, 0x000c },\n\t{ NAU8822_REG_PLL_K2, 0x0093 },\n\t{ NAU8822_REG_PLL_K3, 0x00e9 },\n\t{ NAU8822_REG_3D_CONTROL, 0x0000 },\n\t{ NAU8822_REG_RIGHT_SPEAKER_CONTROL, 0x0000 },\n\t{ NAU8822_REG_INPUT_CONTROL, 0x0033 },\n\t{ NAU8822_REG_LEFT_INP_PGA_CONTROL, 0x0010 },\n\t{ NAU8822_REG_RIGHT_INP_PGA_CONTROL, 0x0010 },\n\t{ NAU8822_REG_LEFT_ADC_BOOST_CONTROL, 0x0100 },\n\t{ NAU8822_REG_RIGHT_ADC_BOOST_CONTROL, 0x0100 },\n\t{ NAU8822_REG_OUTPUT_CONTROL, 0x0002 },\n\t{ NAU8822_REG_LEFT_MIXER_CONTROL, 0x0001 },\n\t{ NAU8822_REG_RIGHT_MIXER_CONTROL, 0x0001 },\n\t{ NAU8822_REG_LHP_VOLUME, 0x0039 },\n\t{ NAU8822_REG_RHP_VOLUME, 0x0039 },\n\t{ NAU8822_REG_LSPKOUT_VOLUME, 0x0039 },\n\t{ NAU8822_REG_RSPKOUT_VOLUME, 0x0039 },\n\t{ NAU8822_REG_AUX2_MIXER, 0x0001 },\n\t{ NAU8822_REG_AUX1_MIXER, 0x0001 },\n\t{ NAU8822_REG_POWER_MANAGEMENT_4, 0x0000 },\n\t{ NAU8822_REG_LEFT_TIME_SLOT, 0x0000 },\n\t{ NAU8822_REG_MISC, 0x0020 },\n\t{ NAU8822_REG_RIGHT_TIME_SLOT, 0x0000 },\n\t{ NAU8822_REG_DEVICE_REVISION, 0x007f },\n\t{ NAU8822_REG_DEVICE_ID, 0x001a },\n\t{ NAU8822_REG_DAC_DITHER, 0x0114 },\n\t{ NAU8822_REG_ALC_ENHANCE_1, 0x0000 },\n\t{ NAU8822_REG_ALC_ENHANCE_2, 0x0000 },\n\t{ NAU8822_REG_192KHZ_SAMPLING, 0x0008 },\n\t{ NAU8822_REG_MISC_CONTROL, 0x0000 },\n\t{ NAU8822_REG_INPUT_TIEOFF, 0x0000 },\n\t{ NAU8822_REG_POWER_REDUCTION, 0x0000 },\n\t{ NAU8822_REG_AGC_PEAK2PEAK, 0x0000 },\n\t{ NAU8822_REG_AGC_PEAK_DETECT, 0x0000 },\n\t{ NAU8822_REG_AUTOMUTE_CONTROL, 0x0000 },\n\t{ NAU8822_REG_OUTPUT_TIEOFF, 0x0000 },\n};\n\nstatic bool nau8822_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8822_REG_RESET ... NAU8822_REG_JACK_DETECT_CONTROL_1:\n\tcase NAU8822_REG_DAC_CONTROL ... NAU8822_REG_LEFT_ADC_DIGITAL_VOLUME:\n\tcase NAU8822_REG_RIGHT_ADC_DIGITAL_VOLUME:\n\tcase NAU8822_REG_EQ1 ... NAU8822_REG_EQ5:\n\tcase NAU8822_REG_DAC_LIMITER_1 ... NAU8822_REG_DAC_LIMITER_2:\n\tcase NAU8822_REG_NOTCH_FILTER_1 ... NAU8822_REG_NOTCH_FILTER_4:\n\tcase NAU8822_REG_ALC_CONTROL_1 ...NAU8822_REG_PLL_K3:\n\tcase NAU8822_REG_3D_CONTROL:\n\tcase NAU8822_REG_RIGHT_SPEAKER_CONTROL:\n\tcase NAU8822_REG_INPUT_CONTROL ... NAU8822_REG_LEFT_ADC_BOOST_CONTROL:\n\tcase NAU8822_REG_RIGHT_ADC_BOOST_CONTROL ... NAU8822_REG_AUX1_MIXER:\n\tcase NAU8822_REG_POWER_MANAGEMENT_4 ... NAU8822_REG_DEVICE_ID:\n\tcase NAU8822_REG_DAC_DITHER:\n\tcase NAU8822_REG_ALC_ENHANCE_1 ... NAU8822_REG_MISC_CONTROL:\n\tcase NAU8822_REG_INPUT_TIEOFF ... NAU8822_REG_OUTPUT_TIEOFF:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8822_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8822_REG_RESET ... NAU8822_REG_JACK_DETECT_CONTROL_1:\n\tcase NAU8822_REG_DAC_CONTROL ... NAU8822_REG_LEFT_ADC_DIGITAL_VOLUME:\n\tcase NAU8822_REG_RIGHT_ADC_DIGITAL_VOLUME:\n\tcase NAU8822_REG_EQ1 ... NAU8822_REG_EQ5:\n\tcase NAU8822_REG_DAC_LIMITER_1 ... NAU8822_REG_DAC_LIMITER_2:\n\tcase NAU8822_REG_NOTCH_FILTER_1 ... NAU8822_REG_NOTCH_FILTER_4:\n\tcase NAU8822_REG_ALC_CONTROL_1 ...NAU8822_REG_PLL_K3:\n\tcase NAU8822_REG_3D_CONTROL:\n\tcase NAU8822_REG_RIGHT_SPEAKER_CONTROL:\n\tcase NAU8822_REG_INPUT_CONTROL ... NAU8822_REG_LEFT_ADC_BOOST_CONTROL:\n\tcase NAU8822_REG_RIGHT_ADC_BOOST_CONTROL ... NAU8822_REG_AUX1_MIXER:\n\tcase NAU8822_REG_POWER_MANAGEMENT_4 ... NAU8822_REG_DEVICE_ID:\n\tcase NAU8822_REG_DAC_DITHER:\n\tcase NAU8822_REG_ALC_ENHANCE_1 ... NAU8822_REG_MISC_CONTROL:\n\tcase NAU8822_REG_INPUT_TIEOFF ... NAU8822_REG_OUTPUT_TIEOFF:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8822_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8822_REG_RESET:\n\tcase NAU8822_REG_DEVICE_REVISION:\n\tcase NAU8822_REG_DEVICE_ID:\n\tcase NAU8822_REG_AGC_PEAK2PEAK:\n\tcase NAU8822_REG_AGC_PEAK_DETECT:\n\tcase NAU8822_REG_AUTOMUTE_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int nau8822_eq_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tint i, reg;\n\tu16 reg_val, *val;\n\t__be16 tmp;\n\n\tval = (u16 *)ucontrol->value.bytes.data;\n\treg = NAU8822_REG_EQ1;\n\tfor (i = 0; i < params->max / sizeof(u16); i++) {\n\t\treg_val = snd_soc_component_read(component, reg + i);\n\t\t \n\t\ttmp = cpu_to_be16(reg_val);\n\t\tmemcpy(val + i, &tmp, sizeof(tmp));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nau8822_eq_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tvoid *data;\n\tu16 *val, value;\n\tint i, reg, ret;\n\t__be16 *tmp;\n\n\tdata = kmemdup(ucontrol->value.bytes.data,\n\t\tparams->max, GFP_KERNEL | GFP_DMA);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tval = (u16 *)data;\n\treg = NAU8822_REG_EQ1;\n\tfor (i = 0; i < params->max / sizeof(u16); i++) {\n\t\t \n\t\ttmp = (__be16 *)(val + i);\n\t\tvalue = be16_to_cpup(tmp);\n\t\tret = snd_soc_component_write(component, reg + i, value);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t    \"EQ configuration fail, register: %x ret: %d\\n\",\n\t\t\t    reg + i, ret);\n\t\t\tkfree(data);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tkfree(data);\n\n\treturn 0;\n}\n\nstatic const char * const nau8822_companding[] = {\n\t\"Off\", \"NC\", \"u-law\", \"A-law\"};\n\nstatic const struct soc_enum nau8822_companding_adc_enum =\n\tSOC_ENUM_SINGLE(NAU8822_REG_COMPANDING_CONTROL, NAU8822_ADCCM_SFT,\n\t\tARRAY_SIZE(nau8822_companding), nau8822_companding);\n\nstatic const struct soc_enum nau8822_companding_dac_enum =\n\tSOC_ENUM_SINGLE(NAU8822_REG_COMPANDING_CONTROL, NAU8822_DACCM_SFT,\n\t\tARRAY_SIZE(nau8822_companding), nau8822_companding);\n\nstatic const char * const nau8822_eqmode[] = {\"Capture\", \"Playback\"};\n\nstatic const struct soc_enum nau8822_eqmode_enum =\n\tSOC_ENUM_SINGLE(NAU8822_REG_EQ1, NAU8822_EQM_SFT,\n\t\tARRAY_SIZE(nau8822_eqmode), nau8822_eqmode);\n\nstatic const char * const nau8822_alc1[] = {\"Off\", \"Right\", \"Left\", \"Both\"};\nstatic const char * const nau8822_alc3[] = {\"Normal\", \"Limiter\"};\n\nstatic const struct soc_enum nau8822_alc_enable_enum =\n\tSOC_ENUM_SINGLE(NAU8822_REG_ALC_CONTROL_1, NAU8822_ALCEN_SFT,\n\t\tARRAY_SIZE(nau8822_alc1), nau8822_alc1);\n\nstatic const struct soc_enum nau8822_alc_mode_enum =\n\tSOC_ENUM_SINGLE(NAU8822_REG_ALC_CONTROL_3, NAU8822_ALCM_SFT,\n\t\tARRAY_SIZE(nau8822_alc3), nau8822_alc3);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_boost_tlv, 0, 2000, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, -1500, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(limiter_tlv, 0, 100, 0);\n\nstatic const struct snd_kcontrol_new nau8822_snd_controls[] = {\n\tSOC_ENUM(\"ADC Companding\", nau8822_companding_adc_enum),\n\tSOC_ENUM(\"DAC Companding\", nau8822_companding_dac_enum),\n\n\tSOC_ENUM(\"EQ Function\", nau8822_eqmode_enum),\n\tSND_SOC_BYTES_EXT(\"EQ Parameters\", 10,\n\t\t  nau8822_eq_get, nau8822_eq_put),\n\n\tSOC_DOUBLE(\"DAC Inversion Switch\",\n\t\tNAU8822_REG_DAC_CONTROL, 0, 1, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"PCM Volume\",\n\t\tNAU8822_REG_LEFT_DAC_DIGITAL_VOLUME,\n\t\tNAU8822_REG_RIGHT_DAC_DIGITAL_VOLUME, 0, 255, 0, digital_tlv),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\",\n\t\tNAU8822_REG_ADC_CONTROL, 8, 1, 0),\n\tSOC_SINGLE(\"High Pass Cut Off\",\n\t\tNAU8822_REG_ADC_CONTROL, 4, 7, 0),\n\n\tSOC_DOUBLE(\"ADC Inversion Switch\",\n\t\tNAU8822_REG_ADC_CONTROL, 0, 1, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"ADC Volume\",\n\t\tNAU8822_REG_LEFT_ADC_DIGITAL_VOLUME,\n\t\tNAU8822_REG_RIGHT_ADC_DIGITAL_VOLUME, 0, 255, 0, digital_tlv),\n\n\tSOC_SINGLE(\"DAC Limiter Switch\",\n\t\tNAU8822_REG_DAC_LIMITER_1, 8, 1, 0),\n\tSOC_SINGLE(\"DAC Limiter Decay\",\n\t\tNAU8822_REG_DAC_LIMITER_1, 4, 15, 0),\n\tSOC_SINGLE(\"DAC Limiter Attack\",\n\t\tNAU8822_REG_DAC_LIMITER_1, 0, 15, 0),\n\tSOC_SINGLE(\"DAC Limiter Threshold\",\n\t\tNAU8822_REG_DAC_LIMITER_2, 4, 7, 0),\n\tSOC_SINGLE_TLV(\"DAC Limiter Volume\",\n\t\tNAU8822_REG_DAC_LIMITER_2, 0, 12, 0, limiter_tlv),\n\n\tSOC_ENUM(\"ALC Mode\", nau8822_alc_mode_enum),\n\tSOC_ENUM(\"ALC Enable Switch\", nau8822_alc_enable_enum),\n\tSOC_SINGLE(\"ALC Min Gain\",\n\t\tNAU8822_REG_ALC_CONTROL_1, 0, 7, 0),\n\tSOC_SINGLE(\"ALC Max Gain\",\n\t\tNAU8822_REG_ALC_CONTROL_1, 3, 7, 0),\n\tSOC_SINGLE(\"ALC Hold\",\n\t\tNAU8822_REG_ALC_CONTROL_2, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Target\",\n\t\tNAU8822_REG_ALC_CONTROL_2, 0, 15, 0),\n\tSOC_SINGLE(\"ALC Decay\",\n\t\tNAU8822_REG_ALC_CONTROL_3, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Attack\",\n\t\tNAU8822_REG_ALC_CONTROL_3, 0, 10, 0),\n\tSOC_SINGLE(\"ALC Noise Gate Switch\",\n\t\tNAU8822_REG_NOISE_GATE, 3, 1, 0),\n\tSOC_SINGLE(\"ALC Noise Gate Threshold\",\n\t\tNAU8822_REG_NOISE_GATE, 0, 7, 0),\n\n\tSOC_DOUBLE_R(\"PGA ZC Switch\",\n\t\tNAU8822_REG_LEFT_INP_PGA_CONTROL,\n\t\tNAU8822_REG_RIGHT_INP_PGA_CONTROL,\n\t\t7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"PGA Volume\",\n\t\tNAU8822_REG_LEFT_INP_PGA_CONTROL,\n\t\tNAU8822_REG_RIGHT_INP_PGA_CONTROL, 0, 63, 0, inpga_tlv),\n\n\tSOC_DOUBLE_R(\"Headphone ZC Switch\",\n\t\tNAU8822_REG_LHP_VOLUME,\n\t\tNAU8822_REG_RHP_VOLUME, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Headphone Playback Switch\",\n\t\tNAU8822_REG_LHP_VOLUME,\n\t\tNAU8822_REG_RHP_VOLUME, 6, 1, 1),\n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\",\n\t\tNAU8822_REG_LHP_VOLUME,\n\t\tNAU8822_REG_RHP_VOLUME,\t0, 63, 0, spk_tlv),\n\n\tSOC_DOUBLE_R(\"Speaker ZC Switch\",\n\t\tNAU8822_REG_LSPKOUT_VOLUME,\n\t\tNAU8822_REG_RSPKOUT_VOLUME, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Speaker Playback Switch\",\n\t\tNAU8822_REG_LSPKOUT_VOLUME,\n\t\tNAU8822_REG_RSPKOUT_VOLUME, 6, 1, 1),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\tNAU8822_REG_LSPKOUT_VOLUME,\n\t\tNAU8822_REG_RSPKOUT_VOLUME, 0, 63, 0, spk_tlv),\n\n\tSOC_DOUBLE_R(\"AUXOUT Playback Switch\",\n\t\tNAU8822_REG_AUX2_MIXER,\n\t\tNAU8822_REG_AUX1_MIXER, 6, 1, 1),\n\n\tSOC_DOUBLE_R_TLV(\"PGA Boost Volume\",\n\t\tNAU8822_REG_LEFT_ADC_BOOST_CONTROL,\n\t\tNAU8822_REG_RIGHT_ADC_BOOST_CONTROL, 8, 1, 0, pga_boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"L2/R2 Boost Volume\",\n\t\tNAU8822_REG_LEFT_ADC_BOOST_CONTROL,\n\t\tNAU8822_REG_RIGHT_ADC_BOOST_CONTROL, 4, 7, 0, boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"Aux Boost Volume\",\n\t\tNAU8822_REG_LEFT_ADC_BOOST_CONTROL,\n\t\tNAU8822_REG_RIGHT_ADC_BOOST_CONTROL, 0, 7, 0, boost_tlv),\n\n\tSOC_SINGLE(\"DAC 128x Oversampling Switch\",\n\t\tNAU8822_REG_DAC_CONTROL, 5, 1, 0),\n\tSOC_SINGLE(\"ADC 128x Oversampling Switch\",\n\t\tNAU8822_REG_ADC_CONTROL, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8822_left_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"LINMIX Switch\",\n\t\tNAU8822_REG_LEFT_MIXER_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"LAUX Switch\",\n\t\tNAU8822_REG_LEFT_MIXER_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"LDAC Switch\",\n\t\tNAU8822_REG_LEFT_MIXER_CONTROL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"RDAC Switch\",\n\t\tNAU8822_REG_OUTPUT_CONTROL, 5, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8822_right_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"RINMIX Switch\",\n\t\tNAU8822_REG_RIGHT_MIXER_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"RAUX Switch\",\n\t\tNAU8822_REG_RIGHT_MIXER_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"RDAC Switch\",\n\t\tNAU8822_REG_RIGHT_MIXER_CONTROL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"LDAC Switch\",\n\t\tNAU8822_REG_OUTPUT_CONTROL, 6, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8822_auxout1_mixer[] = {\n\tSOC_DAPM_SINGLE(\"RDAC Switch\", NAU8822_REG_AUX1_MIXER, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"RMIX Switch\", NAU8822_REG_AUX1_MIXER, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"RINMIX Switch\", NAU8822_REG_AUX1_MIXER, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"LDAC Switch\", NAU8822_REG_AUX1_MIXER, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"LMIX Switch\", NAU8822_REG_AUX1_MIXER, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8822_auxout2_mixer[] = {\n\tSOC_DAPM_SINGLE(\"LDAC Switch\", NAU8822_REG_AUX2_MIXER, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"LMIX Switch\", NAU8822_REG_AUX2_MIXER, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"LINMIX Switch\", NAU8822_REG_AUX2_MIXER, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUX1MIX Output Switch\",\n\t\tNAU8822_REG_AUX2_MIXER, 3, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8822_left_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"L2 Switch\", NAU8822_REG_INPUT_CONTROL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", NAU8822_REG_INPUT_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", NAU8822_REG_INPUT_CONTROL, 0, 1, 0),\n};\nstatic const struct snd_kcontrol_new nau8822_right_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"R2 Switch\", NAU8822_REG_INPUT_CONTROL, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", NAU8822_REG_INPUT_CONTROL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", NAU8822_REG_INPUT_CONTROL, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8822_loopback =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8822_REG_COMPANDING_CONTROL,\n\t\tNAU8822_ADDAP_SFT, 1, 0);\n\nstatic int check_mclk_select_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tunsigned int value;\n\n\tvalue = snd_soc_component_read(component, NAU8822_REG_CLOCKING);\n\n\treturn (value & NAU8822_CLKM_MASK);\n}\n\nstatic const struct snd_soc_dapm_widget nau8822_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left HiFi Playback\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3, 0, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right HiFi Playback\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3, 1, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left HiFi Capture\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 0, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right HiFi Capture\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 1, 0),\n\n\tSOC_MIXER_ARRAY(\"Left Output Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3, 2, 0, nau8822_left_out_mixer),\n\tSOC_MIXER_ARRAY(\"Right Output Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3,\t3, 0, nau8822_right_out_mixer),\n\tSOC_MIXER_ARRAY(\"AUX1 Output Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_1, 7, 0, nau8822_auxout1_mixer),\n\tSOC_MIXER_ARRAY(\"AUX2 Output Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_1,\t6, 0, nau8822_auxout2_mixer),\n\n\tSOC_MIXER_ARRAY(\"Left Input Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2,\n\t\t2, 0, nau8822_left_input_mixer),\n\tSOC_MIXER_ARRAY(\"Right Input Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2,\n\t\t3, 0, nau8822_right_input_mixer),\n\n\tSND_SOC_DAPM_PGA(\"Left Boost Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Boost Mixer\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Capture PGA\",\n\t\tNAU8822_REG_LEFT_INP_PGA_CONTROL, 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Capture PGA\",\n\t\tNAU8822_REG_RIGHT_INP_PGA_CONTROL, 6, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Headphone Out\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 7, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Headphone Out\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_2, 8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Speaker Out\",\n\t\t NAU8822_REG_POWER_MANAGEMENT_3, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Speaker Out\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3,\t5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"AUX1 Out\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3,\t8, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"AUX2 Out\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_3,\t7, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_1,\t4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL\",\n\t\tNAU8822_REG_POWER_MANAGEMENT_1,\t5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"Digital Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t&nau8822_loopback),\n\n\tSND_SOC_DAPM_INPUT(\"LMICN\"),\n\tSND_SOC_DAPM_INPUT(\"LMICP\"),\n\tSND_SOC_DAPM_INPUT(\"RMICN\"),\n\tSND_SOC_DAPM_INPUT(\"RMICP\"),\n\tSND_SOC_DAPM_INPUT(\"LAUX\"),\n\tSND_SOC_DAPM_INPUT(\"RAUX\"),\n\tSND_SOC_DAPM_INPUT(\"L2\"),\n\tSND_SOC_DAPM_INPUT(\"R2\"),\n\tSND_SOC_DAPM_OUTPUT(\"LHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"LSPK\"),\n\tSND_SOC_DAPM_OUTPUT(\"RSPK\"),\n\tSND_SOC_DAPM_OUTPUT(\"AUXOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"AUXOUT2\"),\n};\n\nstatic const struct snd_soc_dapm_route nau8822_dapm_routes[] = {\n\t{\"Right DAC\", NULL, \"PLL\", check_mclk_select_pll},\n\t{\"Left DAC\", NULL, \"PLL\", check_mclk_select_pll},\n\n\t \n\t{\"Right Output Mixer\", \"LDAC Switch\", \"Left DAC\"},\n\t{\"Right Output Mixer\", \"RDAC Switch\", \"Right DAC\"},\n\t{\"Right Output Mixer\", \"RAUX Switch\", \"RAUX\"},\n\t{\"Right Output Mixer\", \"RINMIX Switch\", \"Right Boost Mixer\"},\n\n\t{\"Left Output Mixer\", \"LDAC Switch\", \"Left DAC\"},\n\t{\"Left Output Mixer\", \"RDAC Switch\", \"Right DAC\"},\n\t{\"Left Output Mixer\", \"LAUX Switch\", \"LAUX\"},\n\t{\"Left Output Mixer\", \"LINMIX Switch\", \"Left Boost Mixer\"},\n\n\t \n\t{\"AUX1 Output Mixer\", \"RDAC Switch\", \"Right DAC\"},\n\t{\"AUX1 Output Mixer\", \"RMIX Switch\", \"Right Output Mixer\"},\n\t{\"AUX1 Output Mixer\", \"RINMIX Switch\", \"Right Boost Mixer\"},\n\t{\"AUX1 Output Mixer\", \"LDAC Switch\", \"Left DAC\"},\n\t{\"AUX1 Output Mixer\", \"LMIX Switch\", \"Left Output Mixer\"},\n\n\t{\"AUX2 Output Mixer\", \"LDAC Switch\", \"Left DAC\"},\n\t{\"AUX2 Output Mixer\", \"LMIX Switch\", \"Left Output Mixer\"},\n\t{\"AUX2 Output Mixer\", \"LINMIX Switch\", \"Left Boost Mixer\"},\n\t{\"AUX2 Output Mixer\", \"AUX1MIX Output Switch\", \"AUX1 Output Mixer\"},\n\n\t \n\t{\"Right Headphone Out\", NULL, \"Right Output Mixer\"},\n\t{\"RHP\", NULL, \"Right Headphone Out\"},\n\n\t{\"Left Headphone Out\", NULL, \"Left Output Mixer\"},\n\t{\"LHP\", NULL, \"Left Headphone Out\"},\n\n\t{\"Right Speaker Out\", NULL, \"Right Output Mixer\"},\n\t{\"RSPK\", NULL, \"Right Speaker Out\"},\n\n\t{\"Left Speaker Out\", NULL, \"Left Output Mixer\"},\n\t{\"LSPK\", NULL, \"Left Speaker Out\"},\n\n\t{\"AUX1 Out\", NULL, \"AUX1 Output Mixer\"},\n\t{\"AUX2 Out\", NULL, \"AUX2 Output Mixer\"},\n\t{\"AUXOUT1\", NULL, \"AUX1 Out\"},\n\t{\"AUXOUT2\", NULL, \"AUX2 Out\"},\n\n\t \n\t{\"Right ADC\", NULL, \"PLL\", check_mclk_select_pll},\n\t{\"Left ADC\", NULL, \"PLL\", check_mclk_select_pll},\n\n\t{\"Right ADC\", NULL, \"Right Boost Mixer\"},\n\n\t{\"Right Boost Mixer\", NULL, \"RAUX\"},\n\t{\"Right Boost Mixer\", NULL, \"Right Capture PGA\"},\n\t{\"Right Boost Mixer\", NULL, \"R2\"},\n\n\t{\"Left ADC\", NULL, \"Left Boost Mixer\"},\n\n\t{\"Left Boost Mixer\", NULL, \"LAUX\"},\n\t{\"Left Boost Mixer\", NULL, \"Left Capture PGA\"},\n\t{\"Left Boost Mixer\", NULL, \"L2\"},\n\n\t \n\t{\"Right Capture PGA\", NULL, \"Right Input Mixer\"},\n\t{\"Left Capture PGA\", NULL, \"Left Input Mixer\"},\n\n\t \n\t{\"Right Capture PGA\", NULL, \"Mic Bias\"},\n\t{\"Left Capture PGA\", NULL, \"Mic Bias\"},\n\n\t{\"Right Input Mixer\", \"R2 Switch\", \"R2\"},\n\t{\"Right Input Mixer\", \"MicN Switch\", \"RMICN\"},\n\t{\"Right Input Mixer\", \"MicP Switch\", \"RMICP\"},\n\n\t{\"Left Input Mixer\", \"L2 Switch\", \"L2\"},\n\t{\"Left Input Mixer\", \"MicN Switch\", \"LMICN\"},\n\t{\"Left Input Mixer\", \"MicP Switch\", \"LMICP\"},\n\n\t \n\t{\"Digital Loopback\", \"Switch\", \"Left ADC\"},\n\t{\"Digital Loopback\", \"Switch\", \"Right ADC\"},\n\t{\"Left DAC\", NULL, \"Digital Loopback\"},\n\t{\"Right DAC\", NULL, \"Digital Loopback\"},\n};\n\nstatic int nau8822_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\n\tnau8822->div_id = clk_id;\n\tnau8822->sysclk = freq;\n\tdev_dbg(component->dev, \"master sysclk %dHz, source %s\\n\", freq,\n\t\tclk_id == NAU8822_CLK_PLL ? \"PLL\" : \"MCLK\");\n\n\treturn 0;\n}\n\nstatic int nau8822_calc_pll(unsigned int pll_in, unsigned int fs,\n\t\t\t\tstruct nau8822_pll *pll_param)\n{\n\tu64 f2, f2_max, pll_ratio;\n\tint i, scal_sel;\n\n\tif (pll_in > NAU_PLL_REF_MAX || pll_in < NAU_PLL_REF_MIN)\n\t\treturn -EINVAL;\n\tf2_max = 0;\n\tscal_sel = ARRAY_SIZE(nau8822_mclk_scaler);\n\n\tfor (i = 0; i < scal_sel; i++) {\n\t\tf2 = 256 * fs * 4 * nau8822_mclk_scaler[i] / 10;\n\t\tif (f2 > NAU_PLL_FREQ_MIN && f2 < NAU_PLL_FREQ_MAX &&\n\t\t\tf2_max < f2) {\n\t\t\tf2_max = f2;\n\t\t\tscal_sel = i;\n\t\t}\n\t}\n\n\tif (ARRAY_SIZE(nau8822_mclk_scaler) == scal_sel)\n\t\treturn -EINVAL;\n\tpll_param->mclk_scaler = scal_sel;\n\tf2 = f2_max;\n\n\t \n\tpll_ratio = div_u64(f2 << 28, pll_in);\n\tpll_param->pre_factor = 0;\n\tif (((pll_ratio >> 28) & 0xF) < NAU_PLL_OPTOP_MIN) {\n\t\tpll_ratio <<= 1;\n\t\tpll_param->pre_factor = 1;\n\t}\n\tpll_param->pll_int = (pll_ratio >> 28) & 0xF;\n\tpll_param->pll_frac = ((pll_ratio & 0xFFFFFFF) >> 4);\n\n\treturn 0;\n}\n\nstatic int nau8822_config_clkdiv(struct snd_soc_dai *dai, int div, int rate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\tstruct nau8822_pll *pll = &nau8822->pll;\n\tint i, sclk, imclk;\n\n\tswitch (nau8822->div_id) {\n\tcase NAU8822_CLK_MCLK:\n\t\t \n\t\tdiv = 0;\n\t\timclk = rate * 256;\n\t\tfor (i = 1; i < ARRAY_SIZE(nau8822_mclk_scaler); i++) {\n\t\t\tsclk = (nau8822->sysclk * 10) /\tnau8822_mclk_scaler[i];\n\t\t\tif (sclk < imclk)\n\t\t\t\tbreak;\n\t\t\tdiv = i;\n\t\t}\n\t\tdev_dbg(component->dev, \"master clock prescaler %x for fs %d\\n\",\n\t\t\tdiv, rate);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_CLOCKING, NAU8822_MCLKSEL_MASK,\n\t\t\t(div << NAU8822_MCLKSEL_SFT));\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_CLOCKING, NAU8822_CLKM_MASK,\n\t\t\tNAU8822_CLKM_MCLK);\n\t\tbreak;\n\n\tcase NAU8822_CLK_PLL:\n\t\t \n\t\tif (pll->mclk_scaler != div) {\n\t\t\tdev_err(component->dev,\n\t\t\t\"master clock prescaler not meet PLL parameters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_CLOCKING, NAU8822_MCLKSEL_MASK,\n\t\t\t(div << NAU8822_MCLKSEL_SFT));\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_CLOCKING, NAU8822_CLKM_MASK,\n\t\t\tNAU8822_CLKM_PLL);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8822_set_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\tstruct nau8822_pll *pll_param = &nau8822->pll;\n\tint ret, fs;\n\n\tif (freq_in == pll_param->freq_in &&\n\t    freq_out == pll_param->freq_out)\n\t\treturn 0;\n\n\tif (freq_out == 0) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_1, NAU8822_PLL_EN_MASK, NAU8822_PLL_OFF);\n\t\treturn 0;\n\t}\n\n\tfs = freq_out / 256;\n\n\tret = nau8822_calc_pll(freq_in, fs, pll_param);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\",\n\t\t\tfreq_in);\n\t\treturn ret;\n\t}\n\n\tdev_info(component->dev,\n\t\t\"pll_int=%x pll_frac=%x mclk_scaler=%x pre_factor=%x\\n\",\n\t\tpll_param->pll_int, pll_param->pll_frac,\n\t\tpll_param->mclk_scaler, pll_param->pre_factor);\n\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_POWER_MANAGEMENT_1, NAU8822_PLL_EN_MASK, NAU8822_PLL_OFF);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_PLL_N, NAU8822_PLLMCLK_DIV2 | NAU8822_PLLN_MASK,\n\t\t(pll_param->pre_factor ? NAU8822_PLLMCLK_DIV2 : 0) |\n\t\tpll_param->pll_int);\n\tsnd_soc_component_write(component,\n\t\tNAU8822_REG_PLL_K1, (pll_param->pll_frac >> NAU8822_PLLK1_SFT) &\n\t\tNAU8822_PLLK1_MASK);\n\tsnd_soc_component_write(component,\n\t\tNAU8822_REG_PLL_K2, (pll_param->pll_frac >> NAU8822_PLLK2_SFT) &\n\t\tNAU8822_PLLK2_MASK);\n\tsnd_soc_component_write(component,\n\t\tNAU8822_REG_PLL_K3, pll_param->pll_frac & NAU8822_PLLK3_MASK);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_CLOCKING, NAU8822_MCLKSEL_MASK,\n\t\tpll_param->mclk_scaler << NAU8822_MCLKSEL_SFT);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_CLOCKING, NAU8822_CLKM_MASK, NAU8822_CLKM_PLL);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_POWER_MANAGEMENT_1, NAU8822_PLL_EN_MASK, NAU8822_PLL_ON);\n\n\tpll_param->freq_in = freq_in;\n\tpll_param->freq_out = freq_out;\n\n\treturn 0;\n}\n\nstatic int nau8822_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 ctrl1_val = 0, ctrl2_val = 0;\n\n\tdev_dbg(component->dev, \"%s\\n\", __func__);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl2_val |= 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tctrl2_val &= ~1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= 0x10;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= 0x8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= 0x18;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tctrl1_val |= 0x180;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= 0x100;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tctrl1_val |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_AUDIO_INTERFACE,\n\t\tNAU8822_AIFMT_MASK | NAU8822_LRP_MASK | NAU8822_BCLKP_MASK,\n\t\tctrl1_val);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_CLOCKING, NAU8822_CLKIOEN_MASK, ctrl2_val);\n\n\treturn 0;\n}\n\nstatic int nau8822_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\tint val_len = 0, val_rate = 0;\n\tunsigned int ctrl_val, bclk_fs, bclk_div;\n\n\t \n\tctrl_val = snd_soc_component_read(component, NAU8822_REG_CLOCKING);\n\tif (ctrl_val & NAU8822_CLK_MASTER) {\n\t\t \n\t\tbclk_fs = snd_soc_params_to_bclk(params) / params_rate(params);\n\t\tif (bclk_fs <= 32)\n\t\t\tbclk_div = NAU8822_BCLKDIV_8;\n\t\telse if (bclk_fs <= 64)\n\t\t\tbclk_div = NAU8822_BCLKDIV_4;\n\t\telse if (bclk_fs <= 128)\n\t\t\tbclk_div = NAU8822_BCLKDIV_2;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tsnd_soc_component_update_bits(component, NAU8822_REG_CLOCKING,\n\t\t\t\tNAU8822_BCLKSEL_MASK, bclk_div);\n\t}\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tval_len |= NAU8822_WLEN_20;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tval_len |= NAU8822_WLEN_24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tval_len |= NAU8822_WLEN_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tval_rate |= NAU8822_SMPLR_8K;\n\t\tbreak;\n\tcase 11025:\n\t\tval_rate |= NAU8822_SMPLR_12K;\n\t\tbreak;\n\tcase 16000:\n\t\tval_rate |= NAU8822_SMPLR_16K;\n\t\tbreak;\n\tcase 22050:\n\t\tval_rate |= NAU8822_SMPLR_24K;\n\t\tbreak;\n\tcase 32000:\n\t\tval_rate |= NAU8822_SMPLR_32K;\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_AUDIO_INTERFACE, NAU8822_WLEN_MASK, val_len);\n\tsnd_soc_component_update_bits(component,\n\t\tNAU8822_REG_ADDITIONAL_CONTROL, NAU8822_SMPLR_MASK, val_rate);\n\n\t \n\tif (nau8822->div_id == NAU8822_CLK_MCLK)\n\t\tnau8822_config_clkdiv(dai, 0, params_rate(params));\n\n\treturn 0;\n}\n\nstatic int nau8822_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tdev_dbg(component->dev, \"%s: %d\\n\", __func__, mute);\n\n\tif (mute)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_DAC_CONTROL, 0x40, 0x40);\n\telse\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_DAC_CONTROL, 0x40, 0);\n\n\treturn 0;\n}\n\nstatic int nau8822_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_1,\n\t\t\tNAU8822_REFIMP_MASK, NAU8822_REFIMP_80K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_1,\n\t\t\tNAU8822_IOBUF_EN | NAU8822_ABIAS_EN,\n\t\t\tNAU8822_IOBUF_EN | NAU8822_ABIAS_EN);\n\n\t\tif (snd_soc_component_get_bias_level(component) ==\n\t\t\tSND_SOC_BIAS_OFF) {\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tNAU8822_REG_POWER_MANAGEMENT_1,\n\t\t\t\tNAU8822_REFIMP_MASK, NAU8822_REFIMP_3K);\n\t\t\tmdelay(100);\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_1,\n\t\t\tNAU8822_REFIMP_MASK, NAU8822_REFIMP_300K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_1, 0);\n\t\tsnd_soc_component_write(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_component_write(component,\n\t\t\tNAU8822_REG_POWER_MANAGEMENT_3, 0);\n\t\tbreak;\n\t}\n\n\tdev_dbg(component->dev, \"%s: %d\\n\", __func__, level);\n\n\treturn 0;\n}\n\n#define NAU8822_RATES (SNDRV_PCM_RATE_8000_48000)\n\n#define NAU8822_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops nau8822_dai_ops = {\n\t.hw_params\t= nau8822_hw_params,\n\t.mute_stream\t= nau8822_mute,\n\t.set_fmt\t= nau8822_set_dai_fmt,\n\t.set_sysclk\t= nau8822_set_dai_sysclk,\n\t.set_pll\t= nau8822_set_pll,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver nau8822_dai = {\n\t.name = \"nau8822-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = NAU8822_RATES,\n\t\t.formats = NAU8822_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = NAU8822_RATES,\n\t\t.formats = NAU8822_FORMATS,\n\t},\n\t.ops = &nau8822_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int nau8822_suspend(struct snd_soc_component *component)\n{\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\n\tregcache_mark_dirty(nau8822->regmap);\n\n\treturn 0;\n}\n\nstatic int nau8822_resume(struct snd_soc_component *component)\n{\n\tstruct nau8822 *nau8822 = snd_soc_component_get_drvdata(component);\n\n\tregcache_sync(nau8822->regmap);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\treturn 0;\n}\n\n \nstatic const int update_reg[] = {\n\tNAU8822_REG_LEFT_DAC_DIGITAL_VOLUME,\n\tNAU8822_REG_RIGHT_DAC_DIGITAL_VOLUME,\n\tNAU8822_REG_LEFT_ADC_DIGITAL_VOLUME,\n\tNAU8822_REG_RIGHT_ADC_DIGITAL_VOLUME,\n\tNAU8822_REG_LEFT_INP_PGA_CONTROL,\n\tNAU8822_REG_RIGHT_INP_PGA_CONTROL,\n\tNAU8822_REG_LHP_VOLUME,\n\tNAU8822_REG_RHP_VOLUME,\n\tNAU8822_REG_LSPKOUT_VOLUME,\n\tNAU8822_REG_RSPKOUT_VOLUME,\n};\n\nstatic int nau8822_probe(struct snd_soc_component *component)\n{\n\tint i;\n\tstruct device_node *of_node = component->dev->of_node;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(update_reg); i++)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tupdate_reg[i], 0x100, 0x100);\n\n\t \n\tif (of_property_read_bool(of_node, \"nuvoton,spk-btl\"))\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t      NAU8822_REG_RIGHT_SPEAKER_CONTROL,\n\t\t\t\t\t      NAU8822_RSUBBYP, NAU8822_RSUBBYP);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_nau8822 = {\n\t.probe\t\t\t\t= nau8822_probe,\n\t.suspend\t\t\t= nau8822_suspend,\n\t.resume\t\t\t\t= nau8822_resume,\n\t.set_bias_level\t\t\t= nau8822_set_bias_level,\n\t.controls\t\t\t= nau8822_snd_controls,\n\t.num_controls\t\t\t= ARRAY_SIZE(nau8822_snd_controls),\n\t.dapm_widgets\t\t\t= nau8822_dapm_widgets,\n\t.num_dapm_widgets\t\t= ARRAY_SIZE(nau8822_dapm_widgets),\n\t.dapm_routes\t\t\t= nau8822_dapm_routes,\n\t.num_dapm_routes\t\t= ARRAY_SIZE(nau8822_dapm_routes),\n\t.idle_bias_on\t\t\t= 1,\n\t.use_pmdown_time\t\t= 1,\n\t.endianness\t\t\t= 1,\n};\n\nstatic const struct regmap_config nau8822_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = NAU8822_REG_MAX_REGISTER,\n\t.volatile_reg = nau8822_volatile,\n\n\t.readable_reg = nau8822_readable_reg,\n\t.writeable_reg = nau8822_writeable_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8822_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8822_reg_defaults),\n};\n\nstatic int nau8822_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8822 *nau8822 = dev_get_platdata(dev);\n\tint ret;\n\n\tif (!nau8822) {\n\t\tnau8822 = devm_kzalloc(dev, sizeof(*nau8822), GFP_KERNEL);\n\t\tif (nau8822 == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\ti2c_set_clientdata(i2c, nau8822);\n\n\tnau8822->regmap = devm_regmap_init_i2c(i2c, &nau8822_regmap_config);\n\tif (IS_ERR(nau8822->regmap)) {\n\t\tret = PTR_ERR(nau8822->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tnau8822->dev = dev;\n\n\t \n\tret = regmap_write(nau8822->regmap, NAU8822_REG_RESET, 0x00);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &soc_component_dev_nau8822,\n\t\t\t\t\t\t&nau8822_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id nau8822_i2c_id[] = {\n\t{ \"nau8822\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8822_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8822_of_match[] = {\n\t{ .compatible = \"nuvoton,nau8822\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, nau8822_of_match);\n#endif\n\nstatic struct i2c_driver nau8822_i2c_driver = {\n\t.driver = {\n\t\t.name = \"nau8822\",\n\t\t.of_match_table = of_match_ptr(nau8822_of_match),\n\t},\n\t.probe = nau8822_i2c_probe,\n\t.id_table = nau8822_i2c_id,\n};\nmodule_i2c_driver(nau8822_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC NAU8822 codec driver\");\nMODULE_AUTHOR(\"David Lin <ctlin0@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}