{
  "module_name": "adau1761.c",
  "hash_id": "8cb90c5ae6008c2faeebf066007359febd7aca38b839e666d582dcded889c6f3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau1761.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/platform_data/adau17x1.h>\n\n#include \"adau17x1.h\"\n#include \"adau1761.h\"\n\n#define ADAU1761_DIGMIC_JACKDETECT\t0x4008\n#define ADAU1761_REC_MIXER_LEFT0\t0x400a\n#define ADAU1761_REC_MIXER_LEFT1\t0x400b\n#define ADAU1761_REC_MIXER_RIGHT0\t0x400c\n#define ADAU1761_REC_MIXER_RIGHT1\t0x400d\n#define ADAU1761_LEFT_DIFF_INPUT_VOL\t0x400e\n#define ADAU1761_RIGHT_DIFF_INPUT_VOL\t0x400f\n#define ADAU1761_ALC_CTRL0\t\t0x4011\n#define ADAU1761_ALC_CTRL1\t\t0x4012\n#define ADAU1761_ALC_CTRL2\t\t0x4013\n#define ADAU1761_ALC_CTRL3\t\t0x4014\n#define ADAU1761_PLAY_LR_MIXER_LEFT\t0x4020\n#define ADAU1761_PLAY_MIXER_LEFT0\t0x401c\n#define ADAU1761_PLAY_MIXER_LEFT1\t0x401d\n#define ADAU1761_PLAY_MIXER_RIGHT0\t0x401e\n#define ADAU1761_PLAY_MIXER_RIGHT1\t0x401f\n#define ADAU1761_PLAY_LR_MIXER_RIGHT\t0x4021\n#define ADAU1761_PLAY_MIXER_MONO\t0x4022\n#define ADAU1761_PLAY_HP_LEFT_VOL\t0x4023\n#define ADAU1761_PLAY_HP_RIGHT_VOL\t0x4024\n#define ADAU1761_PLAY_LINE_LEFT_VOL\t0x4025\n#define ADAU1761_PLAY_LINE_RIGHT_VOL\t0x4026\n#define ADAU1761_PLAY_MONO_OUTPUT_VOL\t0x4027\n#define ADAU1761_POP_CLICK_SUPPRESS\t0x4028\n#define ADAU1761_JACK_DETECT_PIN\t0x4031\n#define ADAU1761_DEJITTER\t\t0x4036\n#define ADAU1761_CLK_ENABLE0\t\t0x40f9\n#define ADAU1761_CLK_ENABLE1\t\t0x40fa\n\n#define ADAU1761_DIGMIC_JACKDETECT_ACTIVE_LOW\tBIT(0)\n#define ADAU1761_DIGMIC_JACKDETECT_DIGMIC\tBIT(5)\n\n#define ADAU1761_DIFF_INPUT_VOL_LDEN\t\tBIT(0)\n\n#define ADAU1761_PLAY_MONO_OUTPUT_VOL_MODE_HP\tBIT(0)\n#define ADAU1761_PLAY_MONO_OUTPUT_VOL_UNMUTE\tBIT(1)\n\n#define ADAU1761_PLAY_HP_RIGHT_VOL_MODE_HP\tBIT(0)\n\n#define ADAU1761_PLAY_LINE_LEFT_VOL_MODE_HP\tBIT(0)\n\n#define ADAU1761_PLAY_LINE_RIGHT_VOL_MODE_HP\tBIT(0)\n\n\n#define ADAU1761_FIRMWARE \"adau1761.bin\"\n\nstatic const struct reg_default adau1761_reg_defaults[] = {\n\t{ ADAU1761_DEJITTER,\t\t\t0x03 },\n\t{ ADAU1761_DIGMIC_JACKDETECT,\t\t0x00 },\n\t{ ADAU1761_REC_MIXER_LEFT0,\t\t0x00 },\n\t{ ADAU1761_REC_MIXER_LEFT1,\t\t0x00 },\n\t{ ADAU1761_REC_MIXER_RIGHT0,\t\t0x00 },\n\t{ ADAU1761_REC_MIXER_RIGHT1,\t\t0x00 },\n\t{ ADAU1761_LEFT_DIFF_INPUT_VOL,\t\t0x00 },\n\t{ ADAU1761_ALC_CTRL0,\t\t\t0x00 },\n\t{ ADAU1761_ALC_CTRL1,\t\t\t0x00 },\n\t{ ADAU1761_ALC_CTRL2,\t\t\t0x00 },\n\t{ ADAU1761_ALC_CTRL3,\t\t\t0x00 },\n\t{ ADAU1761_RIGHT_DIFF_INPUT_VOL,\t0x00 },\n\t{ ADAU1761_PLAY_LR_MIXER_LEFT,\t\t0x00 },\n\t{ ADAU1761_PLAY_MIXER_LEFT0,\t\t0x00 },\n\t{ ADAU1761_PLAY_MIXER_LEFT1,\t\t0x00 },\n\t{ ADAU1761_PLAY_MIXER_RIGHT0,\t\t0x00 },\n\t{ ADAU1761_PLAY_MIXER_RIGHT1,\t\t0x00 },\n\t{ ADAU1761_PLAY_LR_MIXER_RIGHT,\t\t0x00 },\n\t{ ADAU1761_PLAY_MIXER_MONO,\t\t0x00 },\n\t{ ADAU1761_PLAY_HP_LEFT_VOL,\t\t0x00 },\n\t{ ADAU1761_PLAY_HP_RIGHT_VOL,\t\t0x00 },\n\t{ ADAU1761_PLAY_LINE_LEFT_VOL,\t\t0x00 },\n\t{ ADAU1761_PLAY_LINE_RIGHT_VOL,\t\t0x00 },\n\t{ ADAU1761_PLAY_MONO_OUTPUT_VOL,\t0x00 },\n\t{ ADAU1761_POP_CLICK_SUPPRESS,\t\t0x00 },\n\t{ ADAU1761_JACK_DETECT_PIN,\t\t0x00 },\n\t{ ADAU1761_CLK_ENABLE0,\t\t\t0x00 },\n\t{ ADAU1761_CLK_ENABLE1,\t\t\t0x00 },\n\t{ ADAU17X1_CLOCK_CONTROL,\t\t0x00 },\n\t{ ADAU17X1_PLL_CONTROL,\t\t\t0x00 },\n\t{ ADAU17X1_REC_POWER_MGMT,\t\t0x00 },\n\t{ ADAU17X1_MICBIAS,\t\t\t0x00 },\n\t{ ADAU17X1_SERIAL_PORT0,\t\t0x00 },\n\t{ ADAU17X1_SERIAL_PORT1,\t\t0x00 },\n\t{ ADAU17X1_CONVERTER0,\t\t\t0x00 },\n\t{ ADAU17X1_CONVERTER1,\t\t\t0x00 },\n\t{ ADAU17X1_LEFT_INPUT_DIGITAL_VOL,\t0x00 },\n\t{ ADAU17X1_RIGHT_INPUT_DIGITAL_VOL,\t0x00 },\n\t{ ADAU17X1_ADC_CONTROL,\t\t\t0x00 },\n\t{ ADAU17X1_PLAY_POWER_MGMT,\t\t0x00 },\n\t{ ADAU17X1_DAC_CONTROL0,\t\t0x00 },\n\t{ ADAU17X1_DAC_CONTROL1,\t\t0x00 },\n\t{ ADAU17X1_DAC_CONTROL2,\t\t0x00 },\n\t{ ADAU17X1_SERIAL_PORT_PAD,\t\t0xaa },\n\t{ ADAU17X1_CONTROL_PORT_PAD0,\t\t0xaa },\n\t{ ADAU17X1_CONTROL_PORT_PAD1,\t\t0x00 },\n\t{ ADAU17X1_DSP_SAMPLING_RATE,\t\t0x01 },\n\t{ ADAU17X1_SERIAL_INPUT_ROUTE,\t\t0x00 },\n\t{ ADAU17X1_SERIAL_OUTPUT_ROUTE,\t\t0x00 },\n\t{ ADAU17X1_DSP_ENABLE,\t\t\t0x00 },\n\t{ ADAU17X1_DSP_RUN,\t\t\t0x00 },\n\t{ ADAU17X1_SERIAL_SAMPLING_RATE,\t0x00 },\n};\n\nstatic const DECLARE_TLV_DB_SCALE(adau1761_sing_in_tlv, -1500, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_diff_in_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_out_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_sidetone_tlv, -1800, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_boost_tlv, -600, 600, 1);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_pga_boost_tlv, -2000, 2000, 1);\n\nstatic const DECLARE_TLV_DB_SCALE(adau1761_alc_max_gain_tlv, -1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_alc_target_tlv, -2850, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1761_alc_ng_threshold_tlv, -7650, 150, 0);\n\nstatic const unsigned int adau1761_bias_select_values[] = {\n\t0, 2, 3,\n};\n\nstatic const char * const adau1761_bias_select_text[] = {\n\t\"Normal operation\", \"Enhanced performance\", \"Power saving\",\n};\n\nstatic const char * const adau1761_bias_select_extreme_text[] = {\n\t\"Normal operation\", \"Extreme power saving\", \"Enhanced performance\",\n\t\"Power saving\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1761_adc_bias_enum,\n\t\tADAU17X1_REC_POWER_MGMT, 3, adau1761_bias_select_extreme_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_hp_bias_enum,\n\t\tADAU17X1_PLAY_POWER_MGMT, 6, adau1761_bias_select_extreme_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_dac_bias_enum,\n\t\tADAU17X1_PLAY_POWER_MGMT, 4, adau1761_bias_select_extreme_text);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1761_playback_bias_enum,\n\t\tADAU17X1_PLAY_POWER_MGMT, 2, 0x3, adau1761_bias_select_text,\n\t\tadau1761_bias_select_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1761_capture_bias_enum,\n\t\tADAU17X1_REC_POWER_MGMT, 1, 0x3, adau1761_bias_select_text,\n\t\tadau1761_bias_select_values);\n\nstatic const unsigned int adau1761_pga_slew_time_values[] = {\n\t3, 0, 1, 2,\n};\n\nstatic const char * const adau1761_pga_slew_time_text[] = {\n\t\"Off\",\n\t\"24 ms\",\n\t\"48 ms\",\n\t\"96 ms\",\n};\n\nstatic const char * const adau1761_alc_function_text[] = {\n\t\"Off\",\n\t\"Right\",\n\t\"Left\",\n\t\"Stereo\",\n\t\"DSP control\",\n};\n\nstatic const char * const adau1761_alc_hold_time_text[] = {\n\t\"2.67 ms\",\n\t\"5.34 ms\",\n\t\"10.68 ms\",\n\t\"21.36 ms\",\n\t\"42.72 ms\",\n\t\"85.44 ms\",\n\t\"170.88 ms\",\n\t\"341.76 ms\",\n\t\"683.52 ms\",\n\t\"1367 ms\",\n\t\"2734.1 ms\",\n\t\"5468.2 ms\",\n\t\"10936 ms\",\n\t\"21873 ms\",\n\t\"43745 ms\",\n\t\"87491 ms\",\n};\n\nstatic const char * const adau1761_alc_attack_time_text[] = {\n\t\"6 ms\",\n\t\"12 ms\",\n\t\"24 ms\",\n\t\"48 ms\",\n\t\"96 ms\",\n\t\"192 ms\",\n\t\"384 ms\",\n\t\"768 ms\",\n\t\"1540 ms\",\n\t\"3070 ms\",\n\t\"6140 ms\",\n\t\"12290 ms\",\n\t\"24580 ms\",\n\t\"49150 ms\",\n\t\"98300 ms\",\n\t\"196610 ms\",\n};\n\nstatic const char * const adau1761_alc_decay_time_text[] = {\n\t\"24 ms\",\n\t\"48 ms\",\n\t\"96 ms\",\n\t\"192 ms\",\n\t\"384 ms\",\n\t\"768 ms\",\n\t\"15400 ms\",\n\t\"30700 ms\",\n\t\"61400 ms\",\n\t\"12290 ms\",\n\t\"24580 ms\",\n\t\"49150 ms\",\n\t\"98300 ms\",\n\t\"196610 ms\",\n\t\"393220 ms\",\n\t\"786430 ms\",\n};\n\nstatic const char * const adau1761_alc_ng_type_text[] = {\n\t\"Hold\",\n\t\"Mute\",\n\t\"Fade\",\n\t\"Fade + Mute\",\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1761_pga_slew_time_enum,\n\t\tADAU1761_ALC_CTRL0, 6, 0x3, adau1761_pga_slew_time_text,\n\t\tadau1761_pga_slew_time_values);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_alc_function_enum,\n\t\tADAU1761_ALC_CTRL0, 0, adau1761_alc_function_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_alc_hold_time_enum,\n\t\tADAU1761_ALC_CTRL1, 4, adau1761_alc_hold_time_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_alc_attack_time_enum,\n\t\tADAU1761_ALC_CTRL2, 4, adau1761_alc_attack_time_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_alc_decay_time_enum,\n\t\tADAU1761_ALC_CTRL2, 0, adau1761_alc_decay_time_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1761_alc_ng_type_enum,\n\t\tADAU1761_ALC_CTRL3, 6, adau1761_alc_ng_type_text);\n\nstatic const struct snd_kcontrol_new adau1761_jack_detect_controls[] = {\n\tSOC_SINGLE(\"Speaker Auto-mute Switch\", ADAU1761_DIGMIC_JACKDETECT,\n\t\t4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new adau1761_differential_mode_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Capture Volume\", ADAU1761_LEFT_DIFF_INPUT_VOL,\n\t\tADAU1761_RIGHT_DIFF_INPUT_VOL, 2, 0x3f, 0,\n\t\tadau1761_diff_in_tlv),\n\tSOC_DOUBLE_R(\"Capture Switch\", ADAU1761_LEFT_DIFF_INPUT_VOL,\n\t\tADAU1761_RIGHT_DIFF_INPUT_VOL, 1, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"PGA Boost Capture Volume\", ADAU1761_REC_MIXER_LEFT1,\n\t\tADAU1761_REC_MIXER_RIGHT1, 3, 2, 0, adau1761_pga_boost_tlv),\n\n\tSOC_ENUM(\"PGA Capture Slew Time\", adau1761_pga_slew_time_enum),\n\n\tSOC_SINGLE_TLV(\"ALC Capture Max Gain Volume\", ADAU1761_ALC_CTRL0,\n\t\t3, 7, 0, adau1761_alc_max_gain_tlv),\n\tSOC_ENUM(\"ALC Capture Function\", adau1761_alc_function_enum),\n\tSOC_ENUM(\"ALC Capture Hold Time\", adau1761_alc_hold_time_enum),\n\tSOC_SINGLE_TLV(\"ALC Capture Target Volume\", ADAU1761_ALC_CTRL1,\n\t\t0, 15, 0, adau1761_alc_target_tlv),\n\tSOC_ENUM(\"ALC Capture Attack Time\", adau1761_alc_decay_time_enum),\n\tSOC_ENUM(\"ALC Capture Decay Time\", adau1761_alc_attack_time_enum),\n\tSOC_ENUM(\"ALC Capture Noise Gate Type\", adau1761_alc_ng_type_enum),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Switch\",\n\t\tADAU1761_ALC_CTRL3, 5, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Capture Noise Gate Threshold Volume\",\n\t\tADAU1761_ALC_CTRL3, 0, 31, 0, adau1761_alc_ng_threshold_tlv),\n};\n\nstatic const struct snd_kcontrol_new adau1761_single_mode_controls[] = {\n\tSOC_SINGLE_TLV(\"Input 1 Capture Volume\", ADAU1761_REC_MIXER_LEFT0,\n\t\t4, 7, 0, adau1761_sing_in_tlv),\n\tSOC_SINGLE_TLV(\"Input 2 Capture Volume\", ADAU1761_REC_MIXER_LEFT0,\n\t\t1, 7, 0, adau1761_sing_in_tlv),\n\tSOC_SINGLE_TLV(\"Input 3 Capture Volume\", ADAU1761_REC_MIXER_RIGHT0,\n\t\t4, 7, 0, adau1761_sing_in_tlv),\n\tSOC_SINGLE_TLV(\"Input 4 Capture Volume\", ADAU1761_REC_MIXER_RIGHT0,\n\t\t1, 7, 0, adau1761_sing_in_tlv),\n};\n\nstatic const struct snd_kcontrol_new adau1761_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Aux Capture Volume\", ADAU1761_REC_MIXER_LEFT1,\n\t\tADAU1761_REC_MIXER_RIGHT1, 0, 7, 0, adau1761_sing_in_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", ADAU1761_PLAY_HP_LEFT_VOL,\n\t\tADAU1761_PLAY_HP_RIGHT_VOL, 2, 0x3f, 0, adau1761_out_tlv),\n\tSOC_DOUBLE_R(\"Headphone Playback Switch\", ADAU1761_PLAY_HP_LEFT_VOL,\n\t\tADAU1761_PLAY_HP_RIGHT_VOL, 1, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Lineout Playback Volume\", ADAU1761_PLAY_LINE_LEFT_VOL,\n\t\tADAU1761_PLAY_LINE_RIGHT_VOL, 2, 0x3f, 0, adau1761_out_tlv),\n\tSOC_DOUBLE_R(\"Lineout Playback Switch\", ADAU1761_PLAY_LINE_LEFT_VOL,\n\t\tADAU1761_PLAY_LINE_RIGHT_VOL, 1, 1, 0),\n\n\tSOC_ENUM(\"ADC Bias\", adau1761_adc_bias_enum),\n\tSOC_ENUM(\"DAC Bias\", adau1761_dac_bias_enum),\n\tSOC_ENUM(\"Capture Bias\", adau1761_capture_bias_enum),\n\tSOC_ENUM(\"Playback Bias\", adau1761_playback_bias_enum),\n\tSOC_ENUM(\"Headphone Bias\", adau1761_hp_bias_enum),\n};\n\nstatic const struct snd_kcontrol_new adau1761_mono_controls[] = {\n\tSOC_SINGLE_TLV(\"Mono Playback Volume\", ADAU1761_PLAY_MONO_OUTPUT_VOL,\n\t\t2, 0x3f, 0, adau1761_out_tlv),\n\tSOC_SINGLE(\"Mono Playback Switch\", ADAU1761_PLAY_MONO_OUTPUT_VOL,\n\t\t1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new adau1761_left_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Left DAC Switch\",\n\t\tADAU1761_PLAY_MIXER_LEFT0, 5, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Right DAC Switch\",\n\t\tADAU1761_PLAY_MIXER_LEFT0, 6, 1, 0),\n\tSOC_DAPM_SINGLE_TLV(\"Aux Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_LEFT0, 1, 8, 0, adau1761_sidetone_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Right Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_LEFT1, 4, 8, 0, adau1761_sidetone_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Left Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_LEFT1, 0, 8, 0, adau1761_sidetone_tlv),\n};\n\nstatic const struct snd_kcontrol_new adau1761_right_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Left DAC Switch\",\n\t\tADAU1761_PLAY_MIXER_RIGHT0, 5, 1, 0),\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Right DAC Switch\",\n\t\tADAU1761_PLAY_MIXER_RIGHT0, 6, 1, 0),\n\tSOC_DAPM_SINGLE_TLV(\"Aux Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_RIGHT0, 1, 8, 0, adau1761_sidetone_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Right Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_RIGHT1, 4, 8, 0, adau1761_sidetone_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Left Bypass Volume\",\n\t\tADAU1761_PLAY_MIXER_RIGHT1, 0, 8, 0, adau1761_sidetone_tlv),\n};\n\nstatic const struct snd_kcontrol_new adau1761_left_lr_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"Left Volume\",\n\t\tADAU1761_PLAY_LR_MIXER_LEFT, 1, 2, 0, adau1761_boost_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Right Volume\",\n\t\tADAU1761_PLAY_LR_MIXER_LEFT, 3, 2, 0, adau1761_boost_tlv),\n};\n\nstatic const struct snd_kcontrol_new adau1761_right_lr_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"Left Volume\",\n\t\tADAU1761_PLAY_LR_MIXER_RIGHT, 1, 2, 0, adau1761_boost_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Right Volume\",\n\t\tADAU1761_PLAY_LR_MIXER_RIGHT, 3, 2, 0, adau1761_boost_tlv),\n};\n\nstatic const char * const adau1761_input_mux_text[] = {\n\t\"ADC\", \"DMIC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1761_input_mux_enum,\n\tADAU17X1_ADC_CONTROL, 2, adau1761_input_mux_text);\n\nstatic const struct snd_kcontrol_new adau1761_input_mux_control =\n\tSOC_DAPM_ENUM(\"Input Select\", adau1761_input_mux_enum);\n\nstatic int adau1761_dejitter_fixup(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\t \n\tregmap_write(adau->regmap, ADAU1761_DEJITTER, 0);\n\tif (!adau->master)\n\t\tregmap_write(adau->regmap, ADAU1761_DEJITTER, 3);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget adau1x61_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Left Input Mixer\", ADAU1761_REC_MIXER_LEFT0, 0, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Right Input Mixer\", ADAU1761_REC_MIXER_RIGHT0, 0, 0,\n\t\tNULL, 0),\n\n\tSOC_MIXER_ARRAY(\"Left Playback Mixer\", ADAU1761_PLAY_MIXER_LEFT0,\n\t\t0, 0, adau1761_left_mixer_controls),\n\tSOC_MIXER_ARRAY(\"Right Playback Mixer\", ADAU1761_PLAY_MIXER_RIGHT0,\n\t\t0, 0, adau1761_right_mixer_controls),\n\tSOC_MIXER_ARRAY(\"Left LR Playback Mixer\", ADAU1761_PLAY_LR_MIXER_LEFT,\n\t\t0, 0, adau1761_left_lr_mixer_controls),\n\tSOC_MIXER_ARRAY(\"Right LR Playback Mixer\", ADAU1761_PLAY_LR_MIXER_RIGHT,\n\t\t0, 0, adau1761_right_lr_mixer_controls),\n\n\tSND_SOC_DAPM_SUPPLY(\"Headphone\", ADAU1761_PLAY_HP_LEFT_VOL,\n\t\t0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"SYSCLK\", 2, SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_POST(\"Dejitter fixup\", adau1761_dejitter_fixup),\n\n\tSND_SOC_DAPM_INPUT(\"LAUX\"),\n\tSND_SOC_DAPM_INPUT(\"RAUX\"),\n\tSND_SOC_DAPM_INPUT(\"LINP\"),\n\tSND_SOC_DAPM_INPUT(\"LINN\"),\n\tSND_SOC_DAPM_INPUT(\"RINP\"),\n\tSND_SOC_DAPM_INPUT(\"RINN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"LHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHP\"),\n};\n\nstatic const struct snd_soc_dapm_widget adau1761_mono_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Mono Playback Mixer\", ADAU1761_PLAY_MIXER_MONO,\n\t\t0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\n};\n\nstatic const struct snd_soc_dapm_widget adau1761_capless_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY_S(\"Headphone VGND\", 1, ADAU1761_PLAY_MIXER_MONO,\n\t\t0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau1x61_dapm_routes[] = {\n\t{ \"Left Input Mixer\", NULL, \"LINP\" },\n\t{ \"Left Input Mixer\", NULL, \"LINN\" },\n\t{ \"Left Input Mixer\", NULL, \"LAUX\" },\n\n\t{ \"Right Input Mixer\", NULL, \"RINP\" },\n\t{ \"Right Input Mixer\", NULL, \"RINN\" },\n\t{ \"Right Input Mixer\", NULL, \"RAUX\" },\n\n\t{ \"Left Playback Mixer\", NULL, \"Left Playback Enable\"},\n\t{ \"Right Playback Mixer\", NULL, \"Right Playback Enable\"},\n\t{ \"Left LR Playback Mixer\", NULL, \"Left Playback Enable\"},\n\t{ \"Right LR Playback Mixer\", NULL, \"Right Playback Enable\"},\n\n\t{ \"Left Playback Mixer\", \"Left DAC Switch\", \"Left DAC\" },\n\t{ \"Left Playback Mixer\", \"Right DAC Switch\", \"Right DAC\" },\n\n\t{ \"Right Playback Mixer\", \"Left DAC Switch\", \"Left DAC\" },\n\t{ \"Right Playback Mixer\", \"Right DAC Switch\", \"Right DAC\" },\n\n\t{ \"Left LR Playback Mixer\", \"Left Volume\", \"Left Playback Mixer\" },\n\t{ \"Left LR Playback Mixer\", \"Right Volume\", \"Right Playback Mixer\" },\n\n\t{ \"Right LR Playback Mixer\", \"Left Volume\", \"Left Playback Mixer\" },\n\t{ \"Right LR Playback Mixer\", \"Right Volume\", \"Right Playback Mixer\" },\n\n\t{ \"LHP\", NULL, \"Left Playback Mixer\" },\n\t{ \"RHP\", NULL, \"Right Playback Mixer\" },\n\n\t{ \"LHP\", NULL, \"Headphone\" },\n\t{ \"RHP\", NULL, \"Headphone\" },\n\n\t{ \"LOUT\", NULL, \"Left LR Playback Mixer\" },\n\t{ \"ROUT\", NULL, \"Right LR Playback Mixer\" },\n\n\t{ \"Left Playback Mixer\", \"Aux Bypass Volume\", \"LAUX\" },\n\t{ \"Left Playback Mixer\", \"Left Bypass Volume\", \"Left Input Mixer\" },\n\t{ \"Left Playback Mixer\", \"Right Bypass Volume\", \"Right Input Mixer\" },\n\t{ \"Right Playback Mixer\", \"Aux Bypass Volume\", \"RAUX\" },\n\t{ \"Right Playback Mixer\", \"Left Bypass Volume\", \"Left Input Mixer\" },\n\t{ \"Right Playback Mixer\", \"Right Bypass Volume\", \"Right Input Mixer\" },\n};\n\nstatic const struct snd_soc_dapm_route adau1761_mono_dapm_routes[] = {\n\t{ \"Mono Playback Mixer\", NULL, \"Left Playback Mixer\" },\n\t{ \"Mono Playback Mixer\", NULL, \"Right Playback Mixer\" },\n\n\t{ \"MONOOUT\", NULL, \"Mono Playback Mixer\" },\n};\n\nstatic const struct snd_soc_dapm_route adau1761_capless_dapm_routes[] = {\n\t{ \"Headphone\", NULL, \"Headphone VGND\" },\n};\n\nstatic const struct snd_soc_dapm_widget adau1761_dmic_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"Left Decimator Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau1761_input_mux_control),\n\tSND_SOC_DAPM_MUX(\"Right Decimator Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adau1761_input_mux_control),\n\n\tSND_SOC_DAPM_INPUT(\"DMIC\"),\n};\n\nstatic const struct snd_soc_dapm_route adau1761_dmic_routes[] = {\n\t{ \"Left Decimator Mux\", \"ADC\", \"Left Input Mixer\" },\n\t{ \"Left Decimator Mux\", \"DMIC\", \"DMIC\" },\n\t{ \"Right Decimator Mux\", \"ADC\", \"Right Input Mixer\" },\n\t{ \"Right Decimator Mux\", \"DMIC\", \"DMIC\" },\n\n\t{ \"Left Decimator\", NULL, \"Left Decimator Mux\" },\n\t{ \"Right Decimator\", NULL, \"Right Decimator Mux\" },\n};\n\nstatic const struct snd_soc_dapm_route adau1761_no_dmic_routes[] = {\n\t{ \"Left Decimator\", NULL, \"Left Input Mixer\" },\n\t{ \"Right Decimator\", NULL, \"Right Input Mixer\" },\n};\n\nstatic const struct snd_soc_dapm_widget adau1761_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Serial Port Clock\", ADAU1761_CLK_ENABLE0,\n\t\t0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Serial Input Routing Clock\", ADAU1761_CLK_ENABLE0,\n\t\t1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Serial Output Routing Clock\", ADAU1761_CLK_ENABLE0,\n\t\t3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Decimator Resync Clock\", ADAU1761_CLK_ENABLE0,\n\t\t4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Interpolator Resync Clock\", ADAU1761_CLK_ENABLE0,\n\t\t2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Slew Clock\", ADAU1761_CLK_ENABLE0, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ALC Clock\", ADAU1761_CLK_ENABLE0, 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"Digital Clock 0\", 1, ADAU1761_CLK_ENABLE1,\n\t\t0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"Digital Clock 1\", 1, ADAU1761_CLK_ENABLE1,\n\t\t1, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau1761_dapm_routes[] = {\n\t{ \"Left Decimator\", NULL, \"Digital Clock 0\", },\n\t{ \"Right Decimator\", NULL, \"Digital Clock 0\", },\n\t{ \"Left DAC\", NULL, \"Digital Clock 0\", },\n\t{ \"Right DAC\", NULL, \"Digital Clock 0\", },\n\n\t{ \"AIFCLK\", NULL, \"Digital Clock 1\" },\n\n\t{ \"Playback\", NULL, \"Serial Port Clock\" },\n\t{ \"Capture\", NULL, \"Serial Port Clock\" },\n\t{ \"Playback\", NULL, \"Serial Input Routing Clock\" },\n\t{ \"Capture\", NULL, \"Serial Output Routing Clock\" },\n\n\t{ \"Left Decimator\", NULL, \"Decimator Resync Clock\" },\n\t{ \"Right Decimator\", NULL, \"Decimator Resync Clock\" },\n\t{ \"Left DAC\", NULL, \"Interpolator Resync Clock\" },\n\t{ \"Right DAC\", NULL, \"Interpolator Resync Clock\" },\n\n\t{ \"Slew Clock\", NULL, \"Digital Clock 0\" },\n\t{ \"Right Playback Mixer\", NULL, \"Slew Clock\" },\n\t{ \"Left Playback Mixer\", NULL, \"Slew Clock\" },\n\n\t{ \"Left Input Mixer\", NULL, \"ALC Clock\" },\n\t{ \"Right Input Mixer\", NULL, \"ALC Clock\" },\n\n\t{ \"Digital Clock 0\", NULL, \"SYSCLK\" },\n\t{ \"Digital Clock 1\", NULL, \"SYSCLK\" },\n};\n\nstatic const struct snd_soc_dapm_route adau1761_dapm_dsp_routes[] = {\n\t{ \"DSP\", NULL, \"Digital Clock 0\" },\n};\n\nstatic int adau1761_compatibility_probe(struct device *dev)\n{\n\tstruct adau *adau = dev_get_drvdata(dev);\n\tstruct regmap *regmap = adau->regmap;\n\tint val, ret = 0;\n\n\t \n\tif (adau->type != ADAU1361)\n\t\treturn 0;\n\n\tregcache_cache_bypass(regmap, true);\n\n\t \n\tregmap_write(regmap, ADAU17X1_CLOCK_CONTROL,\n\t\tADAU17X1_CLOCK_CONTROL_SYSCLK_EN);\n\n\t \n\tregmap_write(regmap, ADAU17X1_SERIAL_SAMPLING_RATE, 1);\n\tret = regmap_read(regmap, ADAU17X1_SERIAL_SAMPLING_RATE, &val);\n\tif (ret)\n\t\tgoto exit;\n\tif (val != 1)\n\t\tgoto exit;\n\tregmap_write(regmap, ADAU17X1_SERIAL_SAMPLING_RATE, 0);\n\tret = regmap_read(regmap, ADAU17X1_SERIAL_SAMPLING_RATE, &val);\n\tif (ret)\n\t\tgoto exit;\n\tif (val != 0)\n\t\tgoto exit;\n\n\tadau->type = ADAU1761_AS_1361;\nexit:\n\t \n\tregmap_write(regmap, ADAU17X1_CLOCK_CONTROL, 0);\n\tregcache_cache_bypass(regmap, false);\n\treturn ret;\n}\n\nstatic int adau1761_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregcache_cache_only(adau->regmap, false);\n\t\tregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\n\t\t\tADAU17X1_CLOCK_CONTROL_SYSCLK_EN,\n\t\t\tADAU17X1_CLOCK_CONTROL_SYSCLK_EN);\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tregcache_sync(adau->regmap);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\n\t\t\tADAU17X1_CLOCK_CONTROL_SYSCLK_EN, 0);\n\t\tregcache_cache_only(adau->regmap, true);\n\t\tbreak;\n\n\t}\n\treturn 0;\n}\n\nstatic enum adau1761_output_mode adau1761_get_lineout_mode(\n\tstruct snd_soc_component *component)\n{\n\tstruct adau1761_platform_data *pdata = component->dev->platform_data;\n\n\tif (pdata)\n\t\treturn pdata->lineout_mode;\n\n\treturn ADAU1761_OUTPUT_MODE_LINE;\n}\n\nstatic int adau1761_setup_digmic_jackdetect(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau1761_platform_data *pdata = component->dev->platform_data;\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tenum adau1761_digmic_jackdet_pin_mode mode;\n\tunsigned int val = 0;\n\tint ret;\n\n\tif (pdata)\n\t\tmode = pdata->digmic_jackdetect_pin_mode;\n\telse\n\t\tmode = ADAU1761_DIGMIC_JACKDET_PIN_MODE_NONE;\n\n\tswitch (mode) {\n\tcase ADAU1761_DIGMIC_JACKDET_PIN_MODE_JACKDETECT:\n\t\tswitch (pdata->jackdetect_debounce_time) {\n\t\tcase ADAU1761_JACKDETECT_DEBOUNCE_5MS:\n\t\tcase ADAU1761_JACKDETECT_DEBOUNCE_10MS:\n\t\tcase ADAU1761_JACKDETECT_DEBOUNCE_20MS:\n\t\tcase ADAU1761_JACKDETECT_DEBOUNCE_40MS:\n\t\t\tval |= pdata->jackdetect_debounce_time << 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pdata->jackdetect_active_low)\n\t\t\tval |= ADAU1761_DIGMIC_JACKDETECT_ACTIVE_LOW;\n\n\t\tret = snd_soc_add_component_controls(component,\n\t\t\tadau1761_jack_detect_controls,\n\t\t\tARRAY_SIZE(adau1761_jack_detect_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tcase ADAU1761_DIGMIC_JACKDET_PIN_MODE_NONE:\n\t\tret = snd_soc_dapm_add_routes(dapm, adau1761_no_dmic_routes,\n\t\t\tARRAY_SIZE(adau1761_no_dmic_routes));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase ADAU1761_DIGMIC_JACKDET_PIN_MODE_DIGMIC:\n\t\tret = snd_soc_dapm_new_controls(dapm, adau1761_dmic_widgets,\n\t\t\tARRAY_SIZE(adau1761_dmic_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, adau1761_dmic_routes,\n\t\t\tARRAY_SIZE(adau1761_dmic_routes));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval |= ADAU1761_DIGMIC_JACKDETECT_DIGMIC;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(adau->regmap, ADAU1761_DIGMIC_JACKDETECT, val);\n\n\treturn 0;\n}\n\nstatic int adau1761_setup_headphone_mode(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tstruct adau1761_platform_data *pdata = component->dev->platform_data;\n\tenum adau1761_output_mode mode;\n\tint ret;\n\n\tif (pdata)\n\t\tmode = pdata->headphone_mode;\n\telse\n\t\tmode = ADAU1761_OUTPUT_MODE_HEADPHONE;\n\n\tswitch (mode) {\n\tcase ADAU1761_OUTPUT_MODE_LINE:\n\t\tbreak;\n\tcase ADAU1761_OUTPUT_MODE_HEADPHONE_CAPLESS:\n\t\tregmap_update_bits(adau->regmap, ADAU1761_PLAY_MONO_OUTPUT_VOL,\n\t\t\tADAU1761_PLAY_MONO_OUTPUT_VOL_MODE_HP |\n\t\t\tADAU1761_PLAY_MONO_OUTPUT_VOL_UNMUTE,\n\t\t\tADAU1761_PLAY_MONO_OUTPUT_VOL_MODE_HP |\n\t\t\tADAU1761_PLAY_MONO_OUTPUT_VOL_UNMUTE);\n\t\tfallthrough;\n\tcase ADAU1761_OUTPUT_MODE_HEADPHONE:\n\t\tregmap_update_bits(adau->regmap, ADAU1761_PLAY_HP_RIGHT_VOL,\n\t\t\tADAU1761_PLAY_HP_RIGHT_VOL_MODE_HP,\n\t\t\tADAU1761_PLAY_HP_RIGHT_VOL_MODE_HP);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode == ADAU1761_OUTPUT_MODE_HEADPHONE_CAPLESS) {\n\t\tret = snd_soc_dapm_new_controls(dapm,\n\t\t\tadau1761_capless_dapm_widgets,\n\t\t\tARRAY_SIZE(adau1761_capless_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = snd_soc_dapm_add_routes(dapm,\n\t\t\tadau1761_capless_dapm_routes,\n\t\t\tARRAY_SIZE(adau1761_capless_dapm_routes));\n\t} else {\n\t\tret = snd_soc_add_component_controls(component, adau1761_mono_controls,\n\t\t\tARRAY_SIZE(adau1761_mono_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = snd_soc_dapm_new_controls(dapm,\n\t\t\tadau1761_mono_dapm_widgets,\n\t\t\tARRAY_SIZE(adau1761_mono_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = snd_soc_dapm_add_routes(dapm,\n\t\t\tadau1761_mono_dapm_routes,\n\t\t\tARRAY_SIZE(adau1761_mono_dapm_routes));\n\t}\n\n\treturn ret;\n}\n\nstatic bool adau1761_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADAU1761_DIGMIC_JACKDETECT:\n\tcase ADAU1761_REC_MIXER_LEFT0:\n\tcase ADAU1761_REC_MIXER_LEFT1:\n\tcase ADAU1761_REC_MIXER_RIGHT0:\n\tcase ADAU1761_REC_MIXER_RIGHT1:\n\tcase ADAU1761_LEFT_DIFF_INPUT_VOL:\n\tcase ADAU1761_RIGHT_DIFF_INPUT_VOL:\n\tcase ADAU1761_PLAY_LR_MIXER_LEFT:\n\tcase ADAU1761_PLAY_MIXER_LEFT0:\n\tcase ADAU1761_PLAY_MIXER_LEFT1:\n\tcase ADAU1761_PLAY_MIXER_RIGHT0:\n\tcase ADAU1761_PLAY_MIXER_RIGHT1:\n\tcase ADAU1761_PLAY_LR_MIXER_RIGHT:\n\tcase ADAU1761_PLAY_MIXER_MONO:\n\tcase ADAU1761_PLAY_HP_LEFT_VOL:\n\tcase ADAU1761_PLAY_HP_RIGHT_VOL:\n\tcase ADAU1761_PLAY_LINE_LEFT_VOL:\n\tcase ADAU1761_PLAY_LINE_RIGHT_VOL:\n\tcase ADAU1761_PLAY_MONO_OUTPUT_VOL:\n\tcase ADAU1761_POP_CLICK_SUPPRESS:\n\tcase ADAU1761_JACK_DETECT_PIN:\n\tcase ADAU1761_DEJITTER:\n\tcase ADAU1761_CLK_ENABLE0:\n\tcase ADAU1761_CLK_ENABLE1:\n\tcase ADAU1761_ALC_CTRL0:\n\tcase ADAU1761_ALC_CTRL1:\n\tcase ADAU1761_ALC_CTRL2:\n\tcase ADAU1761_ALC_CTRL3:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn adau17x1_readable_register(dev, reg);\n}\n\nstatic int adau1761_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adau1761_platform_data *pdata = component->dev->platform_data;\n\tstruct adau *adau = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = adau17x1_add_widgets(component);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pdata && pdata->input_differential) {\n\t\tregmap_update_bits(adau->regmap, ADAU1761_LEFT_DIFF_INPUT_VOL,\n\t\t\tADAU1761_DIFF_INPUT_VOL_LDEN,\n\t\t\tADAU1761_DIFF_INPUT_VOL_LDEN);\n\t\tregmap_update_bits(adau->regmap, ADAU1761_RIGHT_DIFF_INPUT_VOL,\n\t\t\tADAU1761_DIFF_INPUT_VOL_LDEN,\n\t\t\tADAU1761_DIFF_INPUT_VOL_LDEN);\n\t\tret = snd_soc_add_component_controls(component,\n\t\t\tadau1761_differential_mode_controls,\n\t\t\tARRAY_SIZE(adau1761_differential_mode_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = snd_soc_add_component_controls(component,\n\t\t\tadau1761_single_mode_controls,\n\t\t\tARRAY_SIZE(adau1761_single_mode_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (adau1761_get_lineout_mode(component)) {\n\tcase ADAU1761_OUTPUT_MODE_LINE:\n\t\tbreak;\n\tcase ADAU1761_OUTPUT_MODE_HEADPHONE:\n\t\tregmap_update_bits(adau->regmap, ADAU1761_PLAY_LINE_LEFT_VOL,\n\t\t\tADAU1761_PLAY_LINE_LEFT_VOL_MODE_HP,\n\t\t\tADAU1761_PLAY_LINE_LEFT_VOL_MODE_HP);\n\t\tregmap_update_bits(adau->regmap, ADAU1761_PLAY_LINE_RIGHT_VOL,\n\t\t\tADAU1761_PLAY_LINE_RIGHT_VOL_MODE_HP,\n\t\t\tADAU1761_PLAY_LINE_RIGHT_VOL_MODE_HP);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = adau1761_setup_headphone_mode(component);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adau1761_setup_digmic_jackdetect(component);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (adau->type == ADAU1761 || adau->type == ADAU1761_AS_1361) {\n\t\tret = snd_soc_dapm_new_controls(dapm, adau1761_dapm_widgets,\n\t\t\tARRAY_SIZE(adau1761_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, adau1761_dapm_routes,\n\t\t\tARRAY_SIZE(adau1761_dapm_routes));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tif (adau->type == ADAU1761) {\n\t\tret = snd_soc_dapm_add_routes(dapm, adau1761_dapm_dsp_routes,\n\t\t\tARRAY_SIZE(adau1761_dapm_dsp_routes));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tif  (adau->type == ADAU1761_AS_1361) {\n\t\tregmap_write(adau->regmap, ADAU17X1_SERIAL_INPUT_ROUTE, 0x01);\n\t\tregmap_write(adau->regmap, ADAU17X1_SERIAL_OUTPUT_ROUTE, 0x01);\n\t}\n\tret = adau17x1_add_routes(component);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver adau1761_component_driver = {\n\t.probe\t\t\t= adau1761_component_probe,\n\t.resume\t\t\t= adau17x1_resume,\n\t.set_bias_level\t\t= adau1761_set_bias_level,\n\t.controls\t\t= adau1761_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adau1761_controls),\n\t.dapm_widgets\t\t= adau1x61_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adau1x61_dapm_widgets),\n\t.dapm_routes\t\t= adau1x61_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(adau1x61_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n#define ADAU1761_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \\\n\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver adau1361_dai_driver = {\n\t.name = \"adau-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 4,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = ADAU1761_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 4,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = ADAU1761_FORMATS,\n\t},\n\t.ops = &adau17x1_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver adau1761_dai_driver = {\n\t.name = \"adau-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = ADAU1761_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = ADAU1761_FORMATS,\n\t},\n\t.ops = &adau17x1_dai_ops,\n};\n\nint adau1761_probe(struct device *dev, struct regmap *regmap,\n\tenum adau17x1_type type, void (*switch_mode)(struct device *dev))\n{\n\tstruct snd_soc_dai_driver *dai_drv;\n\tconst char *firmware_name;\n\tint ret;\n\n\tif (type == ADAU1361) {\n\t\tdai_drv = &adau1361_dai_driver;\n\t\tfirmware_name = NULL;\n\t} else {\n\t\tdai_drv = &adau1761_dai_driver;\n\t\tfirmware_name = ADAU1761_FIRMWARE;\n\t}\n\n\tret = adau17x1_probe(dev, regmap, type, switch_mode, firmware_name);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adau1761_compatibility_probe(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregcache_cache_only(regmap, true);\n\n\treturn devm_snd_soc_register_component(dev, &adau1761_component_driver,\n\t\t\t\t\t       dai_drv, 1);\n}\nEXPORT_SYMBOL_GPL(adau1761_probe);\n\nconst struct regmap_config adau1761_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 16,\n\t.max_register = 0x40fa,\n\t.reg_defaults = adau1761_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adau1761_reg_defaults),\n\t.readable_reg = adau1761_readable_register,\n\t.volatile_reg = adau17x1_volatile_register,\n\t.precious_reg = adau17x1_precious_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(adau1761_regmap_config);\n\nMODULE_DESCRIPTION(\"ASoC ADAU1361/ADAU1461/ADAU1761/ADAU1961 CODEC driver\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}