{
  "module_name": "cs4349.c",
  "hash_id": "83a0222c9a998564519fb919b2025f88e6db01102aff9b457b06dff8ee5179a3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4349.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include \"cs4349.h\"\n\n\nstatic const struct reg_default cs4349_reg_defaults[] = {\n\t{ 2, 0x00 },\t \n\t{ 3, 0x09 },\t \n\t{ 4, 0x81 },\t \n\t{ 5, 0x00 },\t \n\t{ 6, 0x00 },\t \n\t{ 7, 0xB1 },\t \n\t{ 8, 0x1C },\t \n};\n\n \nstruct  cs4349_private {\n\tstruct regmap\t\t\t*regmap;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tunsigned int\t\t\tmode;\n\tint\t\t\t\trate;\n};\n\nstatic bool cs4349_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4349_CHIPID ... CS4349_MISC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs4349_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4349_MODE ...  CS4349_MISC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int cs4349_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4349_private *cs4349 = snd_soc_component_get_drvdata(component);\n\tunsigned int fmt;\n\n\tfmt = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tswitch (fmt) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcs4349->mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs4349_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4349_private *cs4349 = snd_soc_component_get_drvdata(component);\n\tint fmt, ret;\n\n\tcs4349->rate = params_rate(params);\n\n\tswitch (cs4349->mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfmt = DIF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfmt = DIF_LEFT_JST;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tfmt = DIF_RGHT_JST16;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tfmt = DIF_RGHT_JST24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, CS4349_MODE, DIF_MASK,\n\t\t\t\t  MODE_FORMAT(fmt));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cs4349_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint reg;\n\n\treg = 0;\n\tif (mute)\n\t\treg = MUTE_AB_MASK;\n\n\treturn snd_soc_component_update_bits(component, CS4349_MUTE, MUTE_AB_MASK, reg);\n}\n\nstatic DECLARE_TLV_DB_SCALE(dig_tlv, -12750, 50, 0);\n\nstatic const char * const chan_mix_texts[] = {\n\t\"Mute\", \"MuteA\", \"MuteA SwapB\", \"MuteA MonoB\", \"SwapA MuteB\",\n\t\"BothR\", \"Swap\", \"SwapA MonoB\", \"MuteB\", \"Normal\", \"BothL\",\n\t\"MonoB\", \"MonoA MuteB\", \"MonoA\", \"MonoA SwapB\", \"Mono\",\n\t \n};\n\nstatic const char * const fm_texts[] = {\n\t\"Auto\", \"Single\", \"Double\", \"Quad\",\n};\n\nstatic const char * const deemph_texts[] = {\n\t\"None\", \"44.1k\", \"48k\", \"32k\",\n};\n\nstatic const char * const softr_zeroc_texts[] = {\n\t\"Immediate\", \"Zero Cross\", \"Soft Ramp\", \"SR on ZC\",\n};\n\nstatic int deemph_values[] = {\n\t0, 4, 8, 12,\n};\n\nstatic int softr_zeroc_values[] = {\n\t0, 64, 128, 192,\n};\n\nstatic const struct soc_enum chan_mix_enum =\n\tSOC_ENUM_SINGLE(CS4349_VMI, 0,\n\t\t\tARRAY_SIZE(chan_mix_texts),\n\t\t\tchan_mix_texts);\n\nstatic const struct soc_enum fm_mode_enum =\n\tSOC_ENUM_SINGLE(CS4349_MODE, 0,\n\t\t\tARRAY_SIZE(fm_texts),\n\t\t\tfm_texts);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(deemph_enum, CS4349_MODE, 0, DEM_MASK,\n\t\t\t\tdeemph_texts, deemph_values);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(softr_zeroc_enum, CS4349_RMPFLT, 0,\n\t\t\t\tSR_ZC_MASK, softr_zeroc_texts,\n\t\t\t\tsoftr_zeroc_values);\n\nstatic const struct snd_kcontrol_new cs4349_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\",\n\t\t\t CS4349_VOLA, CS4349_VOLB, 0, 0xFF, 1, dig_tlv),\n\tSOC_ENUM(\"Functional Mode\", fm_mode_enum),\n\tSOC_ENUM(\"De-Emphasis Control\", deemph_enum),\n\tSOC_ENUM(\"Soft Ramp Zero Cross Control\", softr_zeroc_enum),\n\tSOC_ENUM(\"Channel Mixer\", chan_mix_enum),\n\tSOC_SINGLE(\"VolA = VolB Switch\", CS4349_VMI, 7, 1, 0),\n\tSOC_SINGLE(\"InvertA Switch\", CS4349_VMI, 6, 1, 0),\n\tSOC_SINGLE(\"InvertB Switch\", CS4349_VMI, 5, 1, 0),\n\tSOC_SINGLE(\"Auto-Mute Switch\", CS4349_MUTE, 7, 1, 0),\n\tSOC_SINGLE(\"MUTEC A = B Switch\", CS4349_MUTE, 5, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp Up Switch\", CS4349_RMPFLT, 5, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp Down Switch\", CS4349_RMPFLT, 4, 1, 0),\n\tSOC_SINGLE(\"Slow Roll Off Filter Switch\", CS4349_RMPFLT, 2, 1, 0),\n\tSOC_SINGLE(\"Freeze Switch\", CS4349_MISC, 5, 1, 0),\n\tSOC_SINGLE(\"Popguard Switch\", CS4349_MISC, 4, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget cs4349_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"HiFi DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"OutputA\"),\n\tSND_SOC_DAPM_OUTPUT(\"OutputB\"),\n};\n\nstatic const struct snd_soc_dapm_route cs4349_routes[] = {\n\t{\"DAC Playback\", NULL, \"OutputA\"},\n\t{\"DAC Playback\", NULL, \"OutputB\"},\n\n\t{\"OutputA\", NULL, \"HiFi DAC\"},\n\t{\"OutputB\", NULL, \"HiFi DAC\"},\n};\n\n#define CS4349_PCM_FORMATS (SNDRV_PCM_FMTBIT_S8  | SNDRV_PCM_FMTBIT_S16_LE  | \\\n\t\t\tSNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE  | \\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\n#define CS4349_PCM_RATES SNDRV_PCM_RATE_8000_192000\n\nstatic const struct snd_soc_dai_ops cs4349_dai_ops = {\n\t.hw_params\t= cs4349_pcm_hw_params,\n\t.set_fmt\t= cs4349_set_dai_fmt,\n\t.mute_stream\t= cs4349_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs4349_dai = {\n\t.name = \"cs4349_hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"DAC Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= CS4349_PCM_RATES,\n\t\t.formats\t= CS4349_PCM_FORMATS,\n\t},\n\t.ops = &cs4349_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs4349 = {\n\t.controls\t\t= cs4349_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4349_snd_controls),\n\t.dapm_widgets\t\t= cs4349_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4349_dapm_widgets),\n\t.dapm_routes\t\t= cs4349_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4349_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs4349_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\n\t.max_register\t\t= CS4349_MISC,\n\t.reg_defaults\t\t= cs4349_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(cs4349_reg_defaults),\n\t.readable_reg\t\t= cs4349_readable_register,\n\t.writeable_reg\t\t= cs4349_writeable_register,\n\t.cache_type\t\t= REGCACHE_MAPLE,\n};\n\nstatic int cs4349_i2c_probe(struct i2c_client *client)\n{\n\tstruct cs4349_private *cs4349;\n\tint ret;\n\n\tcs4349 = devm_kzalloc(&client->dev, sizeof(*cs4349), GFP_KERNEL);\n\tif (!cs4349)\n\t\treturn -ENOMEM;\n\n\tcs4349->regmap = devm_regmap_init_i2c(client, &cs4349_regmap);\n\tif (IS_ERR(cs4349->regmap)) {\n\t\tret = PTR_ERR(cs4349->regmap);\n\t\tdev_err(&client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs4349->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs4349->reset_gpio))\n\t\treturn PTR_ERR(cs4349->reset_gpio);\n\n\tgpiod_set_value_cansleep(cs4349->reset_gpio, 1);\n\n\ti2c_set_clientdata(client, cs4349);\n\n\treturn devm_snd_soc_register_component(&client->dev,\n\t\t&soc_component_dev_cs4349,\n\t\t&cs4349_dai, 1);\n}\n\nstatic void cs4349_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs4349_private *cs4349 = i2c_get_clientdata(client);\n\n\t \n\tgpiod_set_value_cansleep(cs4349->reset_gpio, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int cs4349_runtime_suspend(struct device *dev)\n{\n\tstruct cs4349_private *cs4349 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(cs4349->regmap, CS4349_MISC, PWR_DWN, PWR_DWN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_cache_only(cs4349->regmap, true);\n\n\t \n\tgpiod_set_value_cansleep(cs4349->reset_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int cs4349_runtime_resume(struct device *dev)\n{\n\tstruct cs4349_private *cs4349 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(cs4349->regmap, CS4349_MISC, PWR_DWN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(cs4349->reset_gpio, 1);\n\n\tregcache_cache_only(cs4349->regmap, false);\n\tregcache_sync(cs4349->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops cs4349_runtime_pm = {\n\tSET_RUNTIME_PM_OPS(cs4349_runtime_suspend, cs4349_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id cs4349_of_match[] = {\n\t{ .compatible = \"cirrus,cs4349\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cs4349_of_match);\n\nstatic const struct i2c_device_id cs4349_i2c_id[] = {\n\t{\"cs4349\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs4349_i2c_id);\n\nstatic struct i2c_driver cs4349_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"cs4349\",\n\t\t.of_match_table\t= cs4349_of_match,\n\t\t.pm = &cs4349_runtime_pm,\n\t},\n\t.id_table\t= cs4349_i2c_id,\n\t.probe\t\t= cs4349_i2c_probe,\n\t.remove\t\t= cs4349_i2c_remove,\n};\n\nmodule_i2c_driver(cs4349_i2c_driver);\n\nMODULE_AUTHOR(\"Tim Howe <tim.howe@cirrus.com>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS4349 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}