{
  "module_name": "aw88395_device.c",
  "hash_id": "4d58e0dd779dab4a8520c49944d77d20f6c11bb671889a1042e8a6fd0abd5927",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/aw88395/aw88395_device.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/crc32.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include \"aw88395_device.h\"\n#include \"aw88395_reg.h\"\n\nstatic int aw_dev_dsp_write_16bit(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int dsp_data)\n{\n\tint ret;\n\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, dsp_addr);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write addr error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMDAT_REG, (u16)dsp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write data error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_write_32bit(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int dsp_data)\n{\n\tu16 temp_data;\n\tint ret;\n\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, dsp_addr);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write addr error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\ttemp_data = dsp_data & AW88395_DSP_16_DATA_MASK;\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMDAT_REG, (u16)temp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write datal error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\ttemp_data = dsp_data >> 16;\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMDAT_REG, (u16)temp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write datah error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_write(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int dsp_data, unsigned char data_type)\n{\n\tu32 reg_value;\n\tint ret;\n\n\tmutex_lock(&aw_dev->dsp_lock);\n\tswitch (data_type) {\n\tcase AW88395_DSP_16_DATA:\n\t\tret = aw_dev_dsp_write_16bit(aw_dev, dsp_addr, dsp_data);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"write dsp_addr[0x%x] 16-bit dsp_data[0x%x] failed\",\n\t\t\t\t\t(u32)dsp_addr, dsp_data);\n\t\tbreak;\n\tcase AW88395_DSP_32_DATA:\n\t\tret = aw_dev_dsp_write_32bit(aw_dev, dsp_addr, dsp_data);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"write dsp_addr[0x%x] 32-bit dsp_data[0x%x] failed\",\n\t\t\t\t\t(u32)dsp_addr, dsp_data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"data type[%d] unsupported\", data_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (regmap_read(aw_dev->regmap, AW88395_ID_REG, &reg_value))\n\t\tdev_err(aw_dev->dev, \"%s fail to clear chip state. Err=%d\\n\", __func__, ret);\n\tmutex_unlock(&aw_dev->dsp_lock);\n\n\treturn ret;\n}\n\nstatic int aw_dev_dsp_read_16bit(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int *dsp_data)\n{\n\tunsigned int temp_data;\n\tint ret;\n\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, dsp_addr);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(aw_dev->regmap, AW88395_DSPMDAT_REG, &temp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s read error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\t*dsp_data = temp_data;\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_read_32bit(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int *dsp_data)\n{\n\tunsigned int temp_data;\n\tint ret;\n\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, dsp_addr);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s write error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(aw_dev->regmap, AW88395_DSPMDAT_REG, &temp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s read error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\t*dsp_data = temp_data;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_DSPMDAT_REG, &temp_data);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s read error, ret=%d\", __func__, ret);\n\t\treturn ret;\n\t}\n\t*dsp_data |= (temp_data << 16);\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_read(struct aw_device *aw_dev,\n\t\tunsigned short dsp_addr, unsigned int *dsp_data, unsigned char data_type)\n{\n\tu32 reg_value;\n\tint ret;\n\n\tmutex_lock(&aw_dev->dsp_lock);\n\tswitch (data_type) {\n\tcase AW88395_DSP_16_DATA:\n\t\tret = aw_dev_dsp_read_16bit(aw_dev, dsp_addr, dsp_data);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"read dsp_addr[0x%x] 16-bit dsp_data[0x%x] failed\",\n\t\t\t\t\t(u32)dsp_addr, *dsp_data);\n\t\tbreak;\n\tcase AW88395_DSP_32_DATA:\n\t\tret = aw_dev_dsp_read_32bit(aw_dev, dsp_addr, dsp_data);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"read dsp_addr[0x%x] 32r-bit dsp_data[0x%x] failed\",\n\t\t\t\t\t(u32)dsp_addr, *dsp_data);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"data type[%d] unsupported\", data_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tif (regmap_read(aw_dev->regmap, AW88395_ID_REG, &reg_value))\n\t\tdev_err(aw_dev->dev, \"%s fail to clear chip state. Err=%d\\n\", __func__, ret);\n\tmutex_unlock(&aw_dev->dsp_lock);\n\n\treturn ret;\n}\n\n\nstatic int aw_dev_read_chipid(struct aw_device *aw_dev, u16 *chip_id)\n{\n\tint reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_CHIP_ID_REG, &reg_val);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"%s read chipid error. ret = %d\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(aw_dev->dev, \"chip id = %x\\n\", reg_val);\n\t*chip_id = reg_val;\n\n\treturn 0;\n}\n\nstatic unsigned int reg_val_to_db(unsigned int value)\n{\n\treturn (((value >> AW88395_VOL_6DB_START) * AW88395_VOLUME_STEP_DB) +\n\t\t\t((value & 0x3f) % AW88395_VOLUME_STEP_DB));\n}\n\nstatic unsigned short db_to_reg_val(unsigned short value)\n{\n\treturn (((value / AW88395_VOLUME_STEP_DB) << AW88395_VOL_6DB_START) +\n\t\t\t(value % AW88395_VOLUME_STEP_DB));\n}\n\nstatic int aw_dev_dsp_fw_check(struct aw_device *aw_dev)\n{\n\tstruct aw_sec_data_desc *dsp_fw_desc;\n\tstruct aw_prof_desc *set_prof_desc;\n\tu16 base_addr = AW88395_DSP_FW_ADDR;\n\tu16 addr = base_addr;\n\tu32 dsp_val;\n\tu16 bin_val;\n\tint ret, i;\n\n\tret = aw88395_dev_get_prof_data(aw_dev, aw_dev->prof_cur, &set_prof_desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdsp_fw_desc = &set_prof_desc->sec_desc[AW88395_DATA_TYPE_DSP_FW];\n\n\tfor (i = 0; i < AW88395_FW_CHECK_PART; i++) {\n\t\tret = aw_dev_dsp_read(aw_dev, addr, &dsp_val, AW88395_DSP_16_DATA);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"dsp read failed\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tbin_val = be16_to_cpup((void *)&dsp_fw_desc->data[2 * (addr - base_addr)]);\n\n\t\tif (dsp_val != bin_val) {\n\t\t\tdev_err(aw_dev->dev, \"fw check failed, addr[0x%x], read[0x%x] != bindata[0x%x]\",\n\t\t\t\t\taddr, dsp_val, bin_val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddr += (dsp_fw_desc->len / 2) / AW88395_FW_CHECK_PART;\n\t\tif ((addr - base_addr) > dsp_fw_desc->len) {\n\t\t\tdev_err(aw_dev->dev, \"fw check failed, addr[0x%x] too large\", addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_set_volume(struct aw_device *aw_dev, unsigned int value)\n{\n\tstruct aw_volume_desc *vol_desc = &aw_dev->volume_desc;\n\tunsigned int reg_value;\n\tu16 real_value, volume;\n\tint ret;\n\n\tvolume = min((value + vol_desc->init_volume), (unsigned int)AW88395_MUTE_VOL);\n\treal_value = db_to_reg_val(volume);\n\n\t \n\tret = regmap_read(aw_dev->regmap, AW88395_SYSCTRL2_REG, &reg_value);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(aw_dev->dev, \"value 0x%x , reg:0x%x\", value, real_value);\n\n\t \n\treal_value = (real_value << AW88395_VOL_START_BIT) | (reg_value & AW88395_VOL_MASK);\n\n\t \n\tret = regmap_write(aw_dev->regmap, AW88395_SYSCTRL2_REG, real_value);\n\n\treturn ret;\n}\n\nvoid aw88395_dev_set_volume(struct aw_device *aw_dev, unsigned short set_vol)\n{\n\tint ret;\n\n\tret = aw_dev_set_volume(aw_dev, set_vol);\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"set volume failed\");\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_set_volume);\n\nstatic void aw_dev_fade_in(struct aw_device *aw_dev)\n{\n\tstruct aw_volume_desc *desc = &aw_dev->volume_desc;\n\tu16 fade_in_vol = desc->ctl_volume;\n\tint fade_step = aw_dev->fade_step;\n\tint i;\n\n\tif (!aw_dev->fade_en)\n\t\treturn;\n\n\tif (fade_step == 0 || aw_dev->fade_in_time == 0) {\n\t\taw_dev_set_volume(aw_dev, fade_in_vol);\n\t\treturn;\n\t}\n\n\tfor (i = AW88395_MUTE_VOL; i >= fade_in_vol; i -= fade_step) {\n\t\taw_dev_set_volume(aw_dev, i);\n\t\tusleep_range(aw_dev->fade_in_time, aw_dev->fade_in_time + 10);\n\t}\n\n\tif (i != fade_in_vol)\n\t\taw_dev_set_volume(aw_dev, fade_in_vol);\n}\n\nstatic void aw_dev_fade_out(struct aw_device *aw_dev)\n{\n\tstruct aw_volume_desc *desc = &aw_dev->volume_desc;\n\tint fade_step = aw_dev->fade_step;\n\tint i;\n\n\tif (!aw_dev->fade_en)\n\t\treturn;\n\n\tif (fade_step == 0 || aw_dev->fade_out_time == 0) {\n\t\taw_dev_set_volume(aw_dev, AW88395_MUTE_VOL);\n\t\treturn;\n\t}\n\n\tfor (i = desc->ctl_volume; i <= AW88395_MUTE_VOL; i += fade_step) {\n\t\taw_dev_set_volume(aw_dev, i);\n\t\tusleep_range(aw_dev->fade_out_time, aw_dev->fade_out_time + 10);\n\t}\n\n\tif (i != AW88395_MUTE_VOL) {\n\t\taw_dev_set_volume(aw_dev, AW88395_MUTE_VOL);\n\t\tusleep_range(aw_dev->fade_out_time, aw_dev->fade_out_time + 10);\n\t}\n}\n\nstatic int aw_dev_modify_dsp_cfg(struct aw_device *aw_dev,\n\t\t\tunsigned int addr, unsigned int dsp_data, unsigned char data_type)\n{\n\tstruct aw_sec_data_desc *crc_dsp_cfg = &aw_dev->crc_dsp_cfg;\n\tunsigned int addr_offset;\n\t__le16 data1;\n\t__le32 data2;\n\n\tdev_dbg(aw_dev->dev, \"addr:0x%x, dsp_data:0x%x\", addr, dsp_data);\n\n\taddr_offset = (addr - AW88395_DSP_CFG_ADDR) * 2;\n\tif (addr_offset > crc_dsp_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"addr_offset[%d] > crc_dsp_cfg->len[%d]\",\n\t\t\t\taddr_offset, crc_dsp_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\tswitch (data_type) {\n\tcase AW88395_DSP_16_DATA:\n\t\tdata1 = cpu_to_le16((u16)dsp_data);\n\t\tmemcpy(crc_dsp_cfg->data + addr_offset, (u8 *)&data1, 2);\n\t\tbreak;\n\tcase AW88395_DSP_32_DATA:\n\t\tdata2 = cpu_to_le32(dsp_data);\n\t\tmemcpy(crc_dsp_cfg->data + addr_offset, (u8 *)&data2, 4);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"data type[%d] unsupported\", data_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_set_cali_re(struct aw_device *aw_dev)\n{\n\tu32 cali_re;\n\tint ret;\n\n\tcali_re = AW88395_SHOW_RE_TO_DSP_RE((aw_dev->cali_desc.cali_re +\n\t\taw_dev->cali_desc.ra), AW88395_DSP_RE_SHIFT);\n\n\t \n\tret = aw_dev_dsp_write(aw_dev,\n\t\t\tAW88395_DSP_REG_CFG_ADPZ_RE, cali_re, AW88395_DSP_32_DATA);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"set cali re error\");\n\t\treturn ret;\n\t}\n\n\tret = aw_dev_modify_dsp_cfg(aw_dev, AW88395_DSP_REG_CFG_ADPZ_RE,\n\t\t\t\tcali_re, AW88395_DSP_32_DATA);\n\tif (ret)\n\t\tdev_err(aw_dev->dev, \"modify dsp cfg failed\");\n\n\treturn ret;\n}\n\nstatic void aw_dev_i2s_tx_enable(struct aw_device *aw_dev, bool flag)\n{\n\tint ret;\n\n\tif (flag) {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_I2SCFG1_REG,\n\t\t\t~AW88395_I2STXEN_MASK, AW88395_I2STXEN_ENABLE_VALUE);\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_I2SCFG1_REG,\n\t\t\t~AW88395_I2STXEN_MASK, AW88395_I2STXEN_DISABLE_VALUE);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n}\n\nstatic int aw_dev_dsp_set_crc32(struct aw_device *aw_dev)\n{\n\tstruct aw_sec_data_desc *crc_dsp_cfg = &aw_dev->crc_dsp_cfg;\n\tu32 crc_value, crc_data_len;\n\n\t \n\tcrc_data_len = (AW88395_DSP_REG_CRC_ADDR - AW88395_DSP_CFG_ADDR) * 2;\n\tif (crc_data_len > crc_dsp_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"crc data len :%d > cfg_data len:%d\",\n\t\t\tcrc_data_len, crc_dsp_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (crc_data_len & 0x11) {\n\t\tdev_err(aw_dev->dev, \"The crc data len :%d unsupport\", crc_data_len);\n\t\treturn -EINVAL;\n\t}\n\n\tcrc_value = __crc32c_le(0xFFFFFFFF, crc_dsp_cfg->data, crc_data_len) ^ 0xFFFFFFFF;\n\n\treturn aw_dev_dsp_write(aw_dev, AW88395_DSP_REG_CRC_ADDR, crc_value,\n\t\t\t\t\t\tAW88395_DSP_32_DATA);\n}\n\nstatic void aw_dev_dsp_check_crc_enable(struct aw_device *aw_dev, bool flag)\n{\n\tint ret;\n\n\tif (flag) {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_HAGCCFG7_REG,\n\t\t\t~AW88395_AGC_DSP_CTL_MASK, AW88395_AGC_DSP_CTL_ENABLE_VALUE);\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_HAGCCFG7_REG,\n\t\t\t~AW88395_AGC_DSP_CTL_MASK, AW88395_AGC_DSP_CTL_DISABLE_VALUE);\n\t}\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n}\n\nstatic int aw_dev_dsp_check_st(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < AW88395_DSP_ST_CHECK_MAX; i++) {\n\t\tret = regmap_read(aw_dev->regmap, AW88395_SYSST_REG, &reg_val);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"read reg0x%x failed\", AW88395_SYSST_REG);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((reg_val & (~AW88395_DSPS_MASK)) != AW88395_DSPS_NORMAL_VALUE) {\n\t\t\tdev_err(aw_dev->dev, \"check dsp st fail,reg_val:0x%04x\", reg_val);\n\t\t\tret = -EPERM;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdev_dbg(aw_dev->dev, \"dsp st check ok, reg_val:0x%04x\", reg_val);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void aw_dev_dsp_enable(struct aw_device *aw_dev, bool is_enable)\n{\n\tint ret;\n\n\tif (is_enable) {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t\t~AW88395_DSPBY_MASK, AW88395_DSPBY_WORKING_VALUE);\n\t\tif (ret)\n\t\t\tdev_dbg(aw_dev->dev, \"enable dsp failed\");\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t\t~AW88395_DSPBY_MASK, AW88395_DSPBY_BYPASS_VALUE);\n\t\tif (ret)\n\t\t\tdev_dbg(aw_dev->dev, \"disable dsp failed\");\n\t}\n}\n\nstatic int aw_dev_dsp_check_crc32(struct aw_device *aw_dev)\n{\n\tint ret;\n\n\tif (aw_dev->dsp_cfg == AW88395_DEV_DSP_BYPASS) {\n\t\tdev_info(aw_dev->dev, \"dsp bypass\");\n\t\treturn 0;\n\t}\n\n\tret = aw_dev_dsp_set_crc32(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"set dsp crc32 failed\");\n\t\treturn ret;\n\t}\n\n\taw_dev_dsp_check_crc_enable(aw_dev, true);\n\n\t \n\taw_dev_dsp_enable(aw_dev, true);\n\tusleep_range(AW88395_5000_US, AW88395_5000_US + 100);\n\n\tret = aw_dev_dsp_check_st(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"check crc32 fail\");\n\t} else {\n\t\taw_dev_dsp_check_crc_enable(aw_dev, false);\n\t\taw_dev->dsp_crc_st = AW88395_DSP_CRC_OK;\n\t}\n\n\treturn ret;\n}\n\nstatic void aw_dev_pwd(struct aw_device *aw_dev, bool pwd)\n{\n\tint ret;\n\n\tif (pwd) {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_PWDN_MASK,\tAW88395_PWDN_POWER_DOWN_VALUE);\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_PWDN_MASK,\tAW88395_PWDN_WORKING_VALUE);\n\t}\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n}\n\nstatic void aw_dev_amppd(struct aw_device *aw_dev, bool amppd)\n{\n\tint ret;\n\n\tif (amppd) {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_AMPPD_MASK, AW88395_AMPPD_POWER_DOWN_VALUE);\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_AMPPD_MASK, AW88395_AMPPD_WORKING_VALUE);\n\t}\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n}\n\nvoid aw88395_dev_mute(struct aw_device *aw_dev, bool is_mute)\n{\n\tint ret;\n\n\tif (is_mute) {\n\t\taw_dev_fade_out(aw_dev);\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_HMUTE_MASK, AW88395_HMUTE_ENABLE_VALUE);\n\t} else {\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_SYSCTRL_REG,\n\t\t\t\t~AW88395_HMUTE_MASK, AW88395_HMUTE_DISABLE_VALUE);\n\t\taw_dev_fade_in(aw_dev);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_mute);\n\nstatic int aw_dev_get_icalk(struct aw_device *aw_dev, int16_t *icalk)\n{\n\tunsigned int reg_val;\n\tu16 reg_icalk;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_EFRM2_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_icalk = reg_val & (~AW88395_EF_ISN_GESLP_MASK);\n\n\tif (reg_icalk & (~AW88395_EF_ISN_GESLP_SIGN_MASK))\n\t\treg_icalk = reg_icalk | AW88395_EF_ISN_GESLP_SIGN_NEG;\n\n\t*icalk = (int16_t)reg_icalk;\n\n\treturn ret;\n}\n\nstatic int aw_dev_get_vcalk(struct aw_device *aw_dev, int16_t *vcalk)\n{\n\tunsigned int reg_val;\n\tu16 reg_vcalk;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_EFRH_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_val = reg_val >> AW88395_EF_VSENSE_GAIN_SHIFT;\n\n\treg_vcalk = (u16)reg_val & (~AW88395_EF_VSN_GESLP_MASK);\n\n\tif (reg_vcalk & (~AW88395_EF_VSN_GESLP_SIGN_MASK))\n\t\treg_vcalk = reg_vcalk | AW88395_EF_VSN_GESLP_SIGN_NEG;\n\n\t*vcalk = (int16_t)reg_vcalk;\n\n\treturn ret;\n}\n\nstatic int aw_dev_get_vcalk_dac(struct aw_device *aw_dev, int16_t *vcalk)\n{\n\tunsigned int reg_val;\n\tu16 reg_vcalk;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_EFRM2_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_vcalk = reg_val >> AW88395_EF_DAC_GESLP_SHIFT;\n\n\tif (reg_vcalk & AW88395_EF_DAC_GESLP_SIGN_MASK)\n\t\treg_vcalk = reg_vcalk | AW88395_EF_DAC_GESLP_SIGN_NEG;\n\n\t*vcalk = (int16_t)reg_vcalk;\n\n\treturn ret;\n}\n\nstatic int aw_dev_vsense_select(struct aw_device *aw_dev, int *vsense_select)\n{\n\tunsigned int vsense_reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_I2SCFG3_REG, &vsense_reg_val);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"read vsense_reg_val failed\");\n\t\treturn ret;\n\t}\n\tdev_dbg(aw_dev->dev, \"vsense_reg = 0x%x\", vsense_reg_val);\n\n\tif (vsense_reg_val & (~AW88395_VDSEL_MASK)) {\n\t\t*vsense_select = AW88395_DEV_VDSEL_VSENSE;\n\t\tdev_dbg(aw_dev->dev, \"vsense outside\");\n\t} else {\n\t\t*vsense_select = AW88395_DEV_VDSEL_DAC;\n\t\tdev_dbg(aw_dev->dev, \"vsense inside\");\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_set_vcalb(struct aw_device *aw_dev)\n{\n\tint16_t icalk_val, vcalk_val;\n\tint icalk, vsense_select;\n\tu32 vcalb_adj, reg_val;\n\tint vcalb, vcalk;\n\tint ret;\n\n\tret = aw_dev_dsp_read(aw_dev, AW88395_DSP_REG_VCALB, &vcalb_adj, AW88395_DSP_16_DATA);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"read vcalb_adj failed\");\n\t\treturn ret;\n\t}\n\n\tret = aw_dev_vsense_select(aw_dev, &vsense_select);\n\tif (ret)\n\t\treturn ret;\n\tdev_dbg(aw_dev->dev, \"vsense_select = %d\", vsense_select);\n\n\tret = aw_dev_get_icalk(aw_dev, &icalk_val);\n\tif (ret)\n\t\treturn ret;\n\ticalk = AW88395_CABL_BASE_VALUE + AW88395_ICABLK_FACTOR * icalk_val;\n\n\tswitch (vsense_select) {\n\tcase AW88395_DEV_VDSEL_VSENSE:\n\t\tret = aw_dev_get_vcalk(aw_dev, &vcalk_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvcalk = AW88395_CABL_BASE_VALUE + AW88395_VCABLK_FACTOR * vcalk_val;\n\t\tvcalb = AW88395_VCAL_FACTOR * AW88395_VSCAL_FACTOR /\n\t\t\tAW88395_ISCAL_FACTOR * icalk / vcalk * vcalb_adj;\n\n\t\tdev_dbg(aw_dev->dev, \"vcalk_factor=%d, vscal_factor=%d, icalk=%d, vcalk=%d\",\n\t\t\t\tAW88395_VCABLK_FACTOR, AW88395_VSCAL_FACTOR, icalk, vcalk);\n\t\tbreak;\n\tcase AW88395_DEV_VDSEL_DAC:\n\t\tret = aw_dev_get_vcalk_dac(aw_dev, &vcalk_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tvcalk = AW88395_CABL_BASE_VALUE + AW88395_VCABLK_FACTOR_DAC * vcalk_val;\n\t\tvcalb = AW88395_VCAL_FACTOR * AW88395_VSCAL_FACTOR_DAC /\n\t\t\tAW88395_ISCAL_FACTOR * icalk / vcalk * vcalb_adj;\n\n\t\tdev_dbg(aw_dev->dev, \"vcalk_dac_factor=%d, vscal_dac_factor=%d, icalk=%d, vcalk=%d\",\n\t\t\t\tAW88395_VCABLK_FACTOR_DAC,\n\t\t\t\tAW88395_VSCAL_FACTOR_DAC, icalk, vcalk);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupport vsense status\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vcalk == 0) || (AW88395_ISCAL_FACTOR == 0)) {\n\t\tdev_err(aw_dev->dev, \"vcalk:%d or desc->iscal_factor:%d unsupported\",\n\t\t\tvcalk, AW88395_ISCAL_FACTOR);\n\t\treturn -EINVAL;\n\t}\n\n\tvcalb = vcalb >> AW88395_VCALB_ADJ_FACTOR;\n\treg_val = (u32)vcalb;\n\n\tdev_dbg(aw_dev->dev, \"vcalb=%d, reg_val=0x%x, vcalb_adj =0x%x\",\n\t\t\t\tvcalb, reg_val, vcalb_adj);\n\n\tret = aw_dev_dsp_write(aw_dev, AW88395_DSP_REG_VCALB, reg_val, AW88395_DSP_16_DATA);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"write vcalb failed\");\n\t\treturn ret;\n\t}\n\n\tret = aw_dev_modify_dsp_cfg(aw_dev, AW88395_DSP_REG_VCALB,\n\t\t\t\t\t(u32)reg_val, AW88395_DSP_16_DATA);\n\tif (ret)\n\t\tdev_err(aw_dev->dev, \"modify dsp cfg failed\");\n\n\treturn ret;\n}\n\nstatic int aw_dev_get_cali_f0_delay(struct aw_device *aw_dev)\n{\n\tstruct aw_cali_delay_desc *desc = &aw_dev->cali_delay_desc;\n\tu32 cali_delay;\n\tint ret;\n\n\tret = aw_dev_dsp_read(aw_dev,\n\t\t\tAW88395_DSP_CALI_F0_DELAY, &cali_delay, AW88395_DSP_16_DATA);\n\tif (ret)\n\t\tdev_err(aw_dev->dev, \"read cali delay failed, ret=%d\", ret);\n\telse\n\t\tdesc->delay = AW88395_CALI_DELAY_CACL(cali_delay);\n\n\tdev_dbg(aw_dev->dev, \"read cali delay: %d ms\", desc->delay);\n\n\treturn ret;\n}\n\nstatic void aw_dev_get_int_status(struct aw_device *aw_dev, unsigned short *int_status)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_SYSINT_REG, &reg_val);\n\tif (ret)\n\t\tdev_err(aw_dev->dev, \"read interrupt reg fail, ret=%d\", ret);\n\telse\n\t\t*int_status = reg_val;\n\n\tdev_dbg(aw_dev->dev, \"read interrupt reg = 0x%04x\", *int_status);\n}\n\nstatic void aw_dev_clear_int_status(struct aw_device *aw_dev)\n{\n\tu16 int_status;\n\n\t \n\taw_dev_get_int_status(aw_dev, &int_status);\n\t \n\taw_dev_get_int_status(aw_dev, &int_status);\n\tif (int_status)\n\t\tdev_info(aw_dev->dev, \"int status(%d) is not cleaned.\\n\", int_status);\n}\n\nstatic int aw_dev_get_iis_status(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_SYSST_REG, &reg_val);\n\tif (ret)\n\t\treturn -EIO;\n\tif ((reg_val & AW88395_BIT_PLL_CHECK) != AW88395_BIT_PLL_CHECK) {\n\t\tdev_err(aw_dev->dev, \"check pll lock fail,reg_val:0x%04x\", reg_val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_check_mode1_pll(struct aw_device *aw_dev)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < AW88395_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = aw_dev_get_iis_status(aw_dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"mode1 iis signal check error\");\n\t\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EPERM;\n}\n\nstatic int aw_dev_check_mode2_pll(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret, i;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_PLLCTRL1_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_val &= (~AW88395_CCO_MUX_MASK);\n\tif (reg_val == AW88395_CCO_MUX_DIVIDED_VALUE) {\n\t\tdev_dbg(aw_dev->dev, \"CCO_MUX is already divider\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tret = regmap_update_bits(aw_dev->regmap, AW88395_PLLCTRL1_REG,\n\t\t\t~AW88395_CCO_MUX_MASK, AW88395_CCO_MUX_DIVIDED_VALUE);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < AW88395_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = aw_dev_get_iis_status(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"mode2 iis signal check error\");\n\t\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tret = regmap_update_bits(aw_dev->regmap, AW88395_PLLCTRL1_REG,\n\t\t\t~AW88395_CCO_MUX_MASK, AW88395_CCO_MUX_BYPASS_VALUE);\n\tif (ret == 0) {\n\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\tfor (i = 0; i < AW88395_DEV_SYSST_CHECK_MAX; i++) {\n\t\t\tret = aw_dev_check_mode1_pll(aw_dev);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw_dev->dev, \"mode2 switch to mode1, iis signal check error\");\n\t\t\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_dev_check_syspll(struct aw_device *aw_dev)\n{\n\tint ret;\n\n\tret = aw_dev_check_mode1_pll(aw_dev);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev, \"mode1 check iis failed try switch to mode2 check\");\n\t\tret = aw_dev_check_mode2_pll(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"mode2 check iis failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_dev_check_sysst(struct aw_device *aw_dev)\n{\n\tunsigned int check_val;\n\tunsigned int reg_val;\n\tint ret, i;\n\n\tfor (i = 0; i < AW88395_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = regmap_read(aw_dev->regmap, AW88395_SYSST_REG, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcheck_val = reg_val & (~AW88395_BIT_SYSST_CHECK_MASK)\n\t\t\t\t\t\t\t& AW88395_BIT_SYSST_CHECK;\n\t\tif (check_val != AW88395_BIT_SYSST_CHECK) {\n\t\t\tdev_err(aw_dev->dev, \"check sysst fail, cnt=%d, reg_val=0x%04x, check:0x%x\",\n\t\t\t\ti, reg_val, AW88395_BIT_SYSST_CHECK);\n\t\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EPERM;\n}\n\nstatic int aw_dev_check_sysint(struct aw_device *aw_dev)\n{\n\tu16 reg_val;\n\n\taw_dev_get_int_status(aw_dev, &reg_val);\n\n\tif (reg_val & AW88395_BIT_SYSINT_CHECK) {\n\t\tdev_err(aw_dev->dev, \"pa stop check fail:0x%04x\", reg_val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void aw_dev_get_cur_mode_st(struct aw_device *aw_dev)\n{\n\tstruct aw_profctrl_desc *profctrl_desc = &aw_dev->profctrl_desc;\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_SYSCTRL_REG, &reg_val);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n\t\treturn;\n\t}\n\tif ((reg_val & (~AW88395_RCV_MODE_MASK)) == AW88395_RCV_MODE_RECEIVER_VALUE)\n\t\tprofctrl_desc->cur_mode = AW88395_RCV_MODE;\n\telse\n\t\tprofctrl_desc->cur_mode = AW88395_NOT_RCV_MODE;\n}\n\nstatic void aw_dev_get_dsp_config(struct aw_device *aw_dev, unsigned char *dsp_cfg)\n{\n\tunsigned int reg_val = 0;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_SYSCTRL_REG, &reg_val);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev, \"%s failed\", __func__);\n\t\treturn;\n\t}\n\tif (reg_val & (~AW88395_DSPBY_MASK))\n\t\t*dsp_cfg = AW88395_DEV_DSP_BYPASS;\n\telse\n\t\t*dsp_cfg = AW88395_DEV_DSP_WORK;\n}\n\nstatic void aw_dev_select_memclk(struct aw_device *aw_dev, unsigned char flag)\n{\n\tint ret;\n\n\tswitch (flag) {\n\tcase AW88395_DEV_MEMCLK_PLL:\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_DBGCTRL_REG,\n\t\t\t\t\t~AW88395_MEM_CLKSEL_MASK,\n\t\t\t\t\tAW88395_MEM_CLKSEL_DAP_HCLK_VALUE);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"memclk select pll failed\");\n\t\tbreak;\n\tcase AW88395_DEV_MEMCLK_OSC:\n\t\tret = regmap_update_bits(aw_dev->regmap, AW88395_DBGCTRL_REG,\n\t\t\t\t\t~AW88395_MEM_CLKSEL_MASK,\n\t\t\t\t\tAW88395_MEM_CLKSEL_OSC_CLK_VALUE);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"memclk select OSC failed\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unknown memclk config, flag=0x%x\", flag);\n\t\tbreak;\n\t}\n}\n\nstatic int aw_dev_get_dsp_status(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88395_WDT_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\tif (!(reg_val & (~AW88395_WDT_CNT_MASK)))\n\t\tret = -EPERM;\n\n\treturn ret;\n}\n\nstatic int aw_dev_get_vmax(struct aw_device *aw_dev, unsigned int *vmax)\n{\n\treturn aw_dev_dsp_read(aw_dev, AW88395_DSP_REG_VMAX, vmax, AW88395_DSP_16_DATA);\n}\n\nstatic int aw_dev_update_reg_container(struct aw_device *aw_dev,\n\t\t\t\tunsigned char *data, unsigned int len)\n{\n\tstruct aw_volume_desc *vol_desc = &aw_dev->volume_desc;\n\tunsigned int read_val;\n\tint16_t *reg_data;\n\tint data_len;\n\tu16 read_vol;\n\tu16 reg_val;\n\tu8 reg_addr;\n\tint i, ret;\n\n\treg_data = (int16_t *)data;\n\tdata_len = len >> 1;\n\n\tif (data_len & 0x1) {\n\t\tdev_err(aw_dev->dev, \"data len:%d unsupported\",\tdata_len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < data_len; i += 2) {\n\t\treg_addr = reg_data[i];\n\t\treg_val = reg_data[i + 1];\n\n\t\tif (reg_addr == AW88395_SYSCTRL_REG) {\n\t\t\tret = regmap_read(aw_dev->regmap, reg_addr, &read_val);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tread_val &= (~AW88395_HMUTE_MASK);\n\t\t\treg_val &= AW88395_HMUTE_MASK;\n\t\t\treg_val |= read_val;\n\t\t}\n\t\tif (reg_addr == AW88395_HAGCCFG7_REG)\n\t\t\treg_val &= AW88395_AGC_DSP_CTL_MASK;\n\n\t\tif (reg_addr == AW88395_I2SCFG1_REG) {\n\t\t\t \n\t\t\treg_val &= AW88395_I2STXEN_MASK;\n\t\t\treg_val |= AW88395_I2STXEN_DISABLE_VALUE;\n\t\t}\n\n\t\tif (reg_addr == AW88395_SYSCTRL2_REG) {\n\t\t\tread_vol = (reg_val & (~AW88395_VOL_MASK)) >>\n\t\t\t\tAW88395_VOL_START_BIT;\n\t\t\taw_dev->volume_desc.init_volume =\n\t\t\t\treg_val_to_db(read_vol);\n\t\t}\n\t\tret = regmap_write(aw_dev->regmap, reg_addr, reg_val);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\n\taw_dev_get_cur_mode_st(aw_dev);\n\n\tif (aw_dev->prof_cur != aw_dev->prof_index) {\n\t\t \n\t\tvol_desc->ctl_volume = 0;\n\t} else {\n\t\t \n\t\taw_dev_set_volume(aw_dev, vol_desc->ctl_volume);\n\t}\n\n\t \n\tif (aw_dev->fade_en)\n\t\taw_dev_set_volume(aw_dev, AW88395_MUTE_VOL);\n\n\taw_dev_get_dsp_config(aw_dev, &aw_dev->dsp_cfg);\n\n\treturn ret;\n}\n\nstatic int aw_dev_reg_update(struct aw_device *aw_dev,\n\t\t\t\t\tunsigned char *data, unsigned int len)\n{\n\tint ret;\n\n\tif (!len || !data) {\n\t\tdev_err(aw_dev->dev, \"reg data is null or len is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = aw_dev_update_reg_container(aw_dev, data, len);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"reg update failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_get_ra(struct aw_cali_desc *cali_desc)\n{\n\tstruct aw_device *aw_dev =\n\t\tcontainer_of(cali_desc, struct aw_device, cali_desc);\n\tu32 dsp_ra;\n\tint ret;\n\n\tret = aw_dev_dsp_read(aw_dev, AW88395_DSP_REG_CFG_ADPZ_RA,\n\t\t\t\t&dsp_ra, AW88395_DSP_32_DATA);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"read ra error\");\n\t\treturn ret;\n\t}\n\n\tcali_desc->ra = AW88395_DSP_RE_TO_SHOW_RE(dsp_ra,\n\t\t\t\t\tAW88395_DSP_RE_SHIFT);\n\n\treturn ret;\n}\n\nstatic int aw_dev_dsp_update_container(struct aw_device *aw_dev,\n\t\t\tunsigned char *data, unsigned int len, unsigned short base)\n{\n\tint i, ret;\n\n#ifdef AW88395_DSP_I2C_WRITES\n\tu32 tmp_len;\n\n\tmutex_lock(&aw_dev->dsp_lock);\n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, base);\n\tif (ret)\n\t\tgoto error_operation;\n\n\tfor (i = 0; i < len; i += AW88395_MAX_RAM_WRITE_BYTE_SIZE) {\n\t\tif ((len - i) < AW88395_MAX_RAM_WRITE_BYTE_SIZE)\n\t\t\ttmp_len = len - i;\n\t\telse\n\t\t\ttmp_len = AW88395_MAX_RAM_WRITE_BYTE_SIZE;\n\n\t\tret = regmap_raw_write(aw_dev->regmap, AW88395_DSPMDAT_REG,\n\t\t\t\t\t&data[i], tmp_len);\n\t\tif (ret)\n\t\t\tgoto error_operation;\n\t}\n\tmutex_unlock(&aw_dev->dsp_lock);\n#else\n\t__be16 reg_val;\n\n\tmutex_lock(&aw_dev->dsp_lock);\n\t \n\tret = regmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, base);\n\tif (ret)\n\t\tgoto error_operation;\n\tfor (i = 0; i < len; i += 2) {\n\t\treg_val = cpu_to_be16p((u16 *)(data + i));\n\t\tret = regmap_write(aw_dev->regmap, AW88395_DSPMDAT_REG,\n\t\t\t\t\t(u16)reg_val);\n\t\tif (ret)\n\t\t\tgoto error_operation;\n\t}\n\tmutex_unlock(&aw_dev->dsp_lock);\n#endif\n\n\treturn 0;\n\nerror_operation:\n\tmutex_unlock(&aw_dev->dsp_lock);\n\treturn ret;\n}\n\nstatic int aw_dev_dsp_update_fw(struct aw_device *aw_dev,\n\t\t\tunsigned char *data, unsigned int len)\n{\n\n\tdev_dbg(aw_dev->dev, \"dsp firmware len:%d\", len);\n\n\tif (!len || !data) {\n\t\tdev_err(aw_dev->dev, \"dsp firmware data is null or len is 0\");\n\t\treturn -EINVAL;\n\t}\n\taw_dev_dsp_update_container(aw_dev, data, len, AW88395_DSP_FW_ADDR);\n\taw_dev->dsp_fw_len = len;\n\n\treturn 0;\n}\n\nstatic int aw_dev_copy_to_crc_dsp_cfg(struct aw_device *aw_dev,\n\t\t\tunsigned char *data, unsigned int size)\n{\n\tstruct aw_sec_data_desc *crc_dsp_cfg = &aw_dev->crc_dsp_cfg;\n\n\tif (!crc_dsp_cfg->data) {\n\t\tcrc_dsp_cfg->data = devm_kzalloc(aw_dev->dev, size, GFP_KERNEL);\n\t\tif (!crc_dsp_cfg->data)\n\t\t\treturn -ENOMEM;\n\t\tcrc_dsp_cfg->len = size;\n\t} else if (crc_dsp_cfg->len < size) {\n\t\tdevm_kfree(aw_dev->dev, crc_dsp_cfg->data);\n\t\tcrc_dsp_cfg->data = devm_kzalloc(aw_dev->dev, size, GFP_KERNEL);\n\t\tif (!crc_dsp_cfg->data)\n\t\t\treturn -ENOMEM;\n\t\tcrc_dsp_cfg->len = size;\n\t}\n\tmemcpy(crc_dsp_cfg->data, data, size);\n\tswab16_array((u16 *)crc_dsp_cfg->data, size >> 1);\n\n\treturn 0;\n}\n\nstatic int aw_dev_dsp_update_cfg(struct aw_device *aw_dev,\n\t\t\tunsigned char *data, unsigned int len)\n{\n\tint ret;\n\n\tdev_dbg(aw_dev->dev, \"dsp config len:%d\", len);\n\n\tif (!len || !data) {\n\t\tdev_err(aw_dev->dev, \"dsp config data is null or len is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\taw_dev_dsp_update_container(aw_dev, data, len, AW88395_DSP_CFG_ADDR);\n\taw_dev->dsp_cfg_len = len;\n\n\tret = aw_dev_copy_to_crc_dsp_cfg(aw_dev, data, len);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aw_dev_set_vcalb(aw_dev);\n\tif (ret)\n\t\treturn ret;\n\tret = aw_dev_get_ra(&aw_dev->cali_desc);\n\tif (ret)\n\t\treturn ret;\n\tret = aw_dev_get_cali_f0_delay(aw_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aw_dev_get_vmax(aw_dev, &aw_dev->vmax_desc.init_vmax);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"get vmax failed\");\n\t\treturn ret;\n\t}\n\tdev_dbg(aw_dev->dev, \"get init vmax:0x%x\", aw_dev->vmax_desc.init_vmax);\n\taw_dev->dsp_crc_st = AW88395_DSP_CRC_NA;\n\n\treturn 0;\n}\n\nstatic int aw_dev_check_sram(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\n\tmutex_lock(&aw_dev->dsp_lock);\n\t \n\tregmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, AW88395_DSP_ODD_NUM_BIT_TEST);\n\tregmap_read(aw_dev->regmap, AW88395_DSPMADD_REG, &reg_val);\n\tif (reg_val != AW88395_DSP_ODD_NUM_BIT_TEST) {\n\t\tdev_err(aw_dev->dev, \"check reg 0x40 odd bit failed, read[0x%x] != write[0x%x]\",\n\t\t\t\treg_val, AW88395_DSP_ODD_NUM_BIT_TEST);\n\t\tgoto error;\n\t}\n\n\t \n\tregmap_write(aw_dev->regmap, AW88395_DSPMADD_REG, AW88395_DSP_EVEN_NUM_BIT_TEST);\n\tregmap_read(aw_dev->regmap, AW88395_DSPMADD_REG, &reg_val);\n\tif (reg_val != AW88395_DSP_EVEN_NUM_BIT_TEST) {\n\t\tdev_err(aw_dev->dev, \"check reg 0x40 even bit failed, read[0x%x] != write[0x%x]\",\n\t\t\t\treg_val, AW88395_DSP_EVEN_NUM_BIT_TEST);\n\t\tgoto error;\n\t}\n\n\t \n\taw_dev_dsp_write_16bit(aw_dev, AW88395_DSP_FW_ADDR,\tAW88395_DSP_EVEN_NUM_BIT_TEST);\n\taw_dev_dsp_read_16bit(aw_dev, AW88395_DSP_FW_ADDR, &reg_val);\n\tif (reg_val != AW88395_DSP_EVEN_NUM_BIT_TEST) {\n\t\tdev_err(aw_dev->dev, \"check dsp fw addr failed, read[0x%x] != write[0x%x]\",\n\t\t\t\t\t\treg_val, AW88395_DSP_EVEN_NUM_BIT_TEST);\n\t\tgoto error;\n\t}\n\n\t \n\taw_dev_dsp_write_16bit(aw_dev, AW88395_DSP_CFG_ADDR, AW88395_DSP_ODD_NUM_BIT_TEST);\n\taw_dev_dsp_read_16bit(aw_dev, AW88395_DSP_CFG_ADDR, &reg_val);\n\tif (reg_val != AW88395_DSP_ODD_NUM_BIT_TEST) {\n\t\tdev_err(aw_dev->dev, \"check dsp cfg failed, read[0x%x] != write[0x%x]\",\n\t\t\t\t\t\treg_val, AW88395_DSP_ODD_NUM_BIT_TEST);\n\t\tgoto error;\n\t}\n\tmutex_unlock(&aw_dev->dsp_lock);\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&aw_dev->dsp_lock);\n\treturn -EPERM;\n}\n\nint aw88395_dev_fw_update(struct aw_device *aw_dev, bool up_dsp_fw_en, bool force_up_en)\n{\n\tstruct aw_prof_desc *prof_index_desc;\n\tstruct aw_sec_data_desc *sec_desc;\n\tchar *prof_name;\n\tint ret;\n\n\tif ((aw_dev->prof_cur == aw_dev->prof_index) &&\n\t\t\t(force_up_en == AW88395_FORCE_UPDATE_OFF)) {\n\t\tdev_dbg(aw_dev->dev, \"scene no change, not update\");\n\t\treturn 0;\n\t}\n\n\tif (aw_dev->fw_status == AW88395_DEV_FW_FAILED) {\n\t\tdev_err(aw_dev->dev, \"fw status[%d] error\", aw_dev->fw_status);\n\t\treturn -EPERM;\n\t}\n\n\tprof_name = aw88395_dev_get_prof_name(aw_dev, aw_dev->prof_index);\n\n\tdev_dbg(aw_dev->dev, \"start update %s\", prof_name);\n\n\tret = aw88395_dev_get_prof_data(aw_dev, aw_dev->prof_index, &prof_index_desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsec_desc = prof_index_desc->sec_desc;\n\tret = aw_dev_reg_update(aw_dev, sec_desc[AW88395_DATA_TYPE_REG].data,\n\t\t\t\t\tsec_desc[AW88395_DATA_TYPE_REG].len);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"update reg failed\");\n\t\treturn ret;\n\t}\n\n\taw88395_dev_mute(aw_dev, true);\n\n\tif (aw_dev->dsp_cfg == AW88395_DEV_DSP_WORK)\n\t\taw_dev_dsp_enable(aw_dev, false);\n\n\taw_dev_select_memclk(aw_dev, AW88395_DEV_MEMCLK_OSC);\n\n\tif (up_dsp_fw_en) {\n\t\tret = aw_dev_check_sram(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"check sram failed\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tdev_dbg(aw_dev->dev, \"fw_ver: [%x]\", prof_index_desc->fw_ver);\n\t\tret = aw_dev_dsp_update_fw(aw_dev, sec_desc[AW88395_DATA_TYPE_DSP_FW].data,\n\t\t\t\t\tsec_desc[AW88395_DATA_TYPE_DSP_FW].len);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"update dsp fw failed\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tret = aw_dev_dsp_update_cfg(aw_dev, sec_desc[AW88395_DATA_TYPE_DSP_CFG].data,\n\t\t\t\t\tsec_desc[AW88395_DATA_TYPE_DSP_CFG].len);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"update dsp cfg failed\");\n\t\tgoto error;\n\t}\n\n\taw_dev_select_memclk(aw_dev, AW88395_DEV_MEMCLK_PLL);\n\n\taw_dev->prof_cur = aw_dev->prof_index;\n\n\treturn 0;\n\nerror:\n\taw_dev_select_memclk(aw_dev, AW88395_DEV_MEMCLK_PLL);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_fw_update);\n\nstatic int aw_dev_dsp_check(struct aw_device *aw_dev)\n{\n\tint ret, i;\n\n\tswitch (aw_dev->dsp_cfg) {\n\tcase AW88395_DEV_DSP_BYPASS:\n\t\tdev_dbg(aw_dev->dev, \"dsp bypass\");\n\t\tret = 0;\n\t\tbreak;\n\tcase AW88395_DEV_DSP_WORK:\n\t\taw_dev_dsp_enable(aw_dev, false);\n\t\taw_dev_dsp_enable(aw_dev, true);\n\t\tusleep_range(AW88395_1000_US, AW88395_1000_US + 10);\n\t\tfor (i = 0; i < AW88395_DEV_DSP_CHECK_MAX; i++) {\n\t\t\tret = aw_dev_get_dsp_status(aw_dev);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(aw_dev->dev, \"dsp wdt status error=%d\", ret);\n\t\t\t\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unknown dsp cfg=%d\", aw_dev->dsp_cfg);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void aw_dev_update_cali_re(struct aw_cali_desc *cali_desc)\n{\n\tstruct aw_device *aw_dev =\n\t\tcontainer_of(cali_desc, struct aw_device, cali_desc);\n\tint ret;\n\n\tif ((aw_dev->cali_desc.cali_re < AW88395_CALI_RE_MAX) &&\n\t\t(aw_dev->cali_desc.cali_re > AW88395_CALI_RE_MIN)) {\n\n\t\tret = aw_dev_dsp_set_cali_re(aw_dev);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"set cali re failed\");\n\t}\n}\n\nint aw88395_dev_start(struct aw_device *aw_dev)\n{\n\tint ret;\n\n\tif (aw_dev->status == AW88395_DEV_PW_ON) {\n\t\tdev_info(aw_dev->dev, \"already power on\");\n\t\treturn 0;\n\t}\n\t \n\taw_dev_pwd(aw_dev, false);\n\tusleep_range(AW88395_2000_US, AW88395_2000_US + 10);\n\n\tret = aw_dev_check_syspll(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"pll check failed cannot start\");\n\t\tgoto pll_check_fail;\n\t}\n\n\t \n\taw_dev_amppd(aw_dev, false);\n\tusleep_range(AW88395_1000_US, AW88395_1000_US + 50);\n\n\t \n\tret = aw_dev_check_sysst(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"sysst check failed\");\n\t\tgoto sysst_check_fail;\n\t}\n\n\tif (aw_dev->dsp_cfg == AW88395_DEV_DSP_WORK) {\n\t\t \n\t\taw_dev_dsp_enable(aw_dev, false);\n\t\tret = aw_dev_dsp_fw_check(aw_dev);\n\t\tif (ret)\n\t\t\tgoto dev_dsp_fw_check_fail;\n\n\t\taw_dev_update_cali_re(&aw_dev->cali_desc);\n\n\t\tif (aw_dev->dsp_crc_st != AW88395_DSP_CRC_OK) {\n\t\t\tret = aw_dev_dsp_check_crc32(aw_dev);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(aw_dev->dev, \"dsp crc check failed\");\n\t\t\t\tgoto crc_check_fail;\n\t\t\t}\n\t\t}\n\n\t\tret = aw_dev_dsp_check(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"dsp status check failed\");\n\t\t\tgoto dsp_check_fail;\n\t\t}\n\t} else {\n\t\tdev_dbg(aw_dev->dev, \"start pa with dsp bypass\");\n\t}\n\n\t \n\taw_dev_i2s_tx_enable(aw_dev, true);\n\n\t \n\taw88395_dev_mute(aw_dev, false);\n\t \n\taw_dev_clear_int_status(aw_dev);\n\taw_dev->status = AW88395_DEV_PW_ON;\n\n\treturn 0;\n\ndsp_check_fail:\ncrc_check_fail:\n\taw_dev_dsp_enable(aw_dev, false);\ndev_dsp_fw_check_fail:\nsysst_check_fail:\n\taw_dev_clear_int_status(aw_dev);\n\taw_dev_amppd(aw_dev, true);\npll_check_fail:\n\taw_dev_pwd(aw_dev, true);\n\taw_dev->status = AW88395_DEV_PW_OFF;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_start);\n\nint aw88395_dev_stop(struct aw_device *aw_dev)\n{\n\tstruct aw_sec_data_desc *dsp_cfg =\n\t\t&aw_dev->prof_info.prof_desc[aw_dev->prof_cur].sec_desc[AW88395_DATA_TYPE_DSP_CFG];\n\tstruct aw_sec_data_desc *dsp_fw =\n\t\t&aw_dev->prof_info.prof_desc[aw_dev->prof_cur].sec_desc[AW88395_DATA_TYPE_DSP_FW];\n\tint int_st = 0;\n\tint ret;\n\n\tif (aw_dev->status == AW88395_DEV_PW_OFF) {\n\t\tdev_info(aw_dev->dev, \"already power off\");\n\t\treturn 0;\n\t}\n\n\taw_dev->status = AW88395_DEV_PW_OFF;\n\n\t \n\taw88395_dev_mute(aw_dev, true);\n\tusleep_range(AW88395_4000_US, AW88395_4000_US + 100);\n\n\t \n\taw_dev_i2s_tx_enable(aw_dev, false);\n\tusleep_range(AW88395_1000_US, AW88395_1000_US + 100);\n\n\t \n\tint_st = aw_dev_check_sysint(aw_dev);\n\n\t \n\taw_dev_dsp_enable(aw_dev, false);\n\n\t \n\taw_dev_amppd(aw_dev, true);\n\n\tif (int_st < 0) {\n\t\t \n\t\taw_dev_select_memclk(aw_dev, AW88395_DEV_MEMCLK_OSC);\n\t\tret = aw_dev_dsp_update_fw(aw_dev, dsp_fw->data, dsp_fw->len);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"update dsp fw failed\");\n\t\tret = aw_dev_dsp_update_cfg(aw_dev, dsp_cfg->data, dsp_cfg->len);\n\t\tif (ret)\n\t\t\tdev_err(aw_dev->dev, \"update dsp cfg failed\");\n\t\taw_dev_select_memclk(aw_dev, AW88395_DEV_MEMCLK_PLL);\n\t}\n\n\t \n\taw_dev_pwd(aw_dev, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_stop);\n\nint aw88395_dev_init(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tint ret;\n\n\tif ((!aw_dev) || (!aw_cfg)) {\n\t\tpr_err(\"aw_dev is NULL or aw_cfg is NULL\");\n\t\treturn -ENOMEM;\n\t}\n\tret = aw88395_dev_cfg_load(aw_dev, aw_cfg);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"aw_dev acf parse failed\");\n\t\treturn -EINVAL;\n\t}\n\taw_dev->fade_in_time = AW88395_1000_US / 10;\n\taw_dev->fade_out_time = AW88395_1000_US >> 1;\n\taw_dev->prof_cur = aw_dev->prof_info.prof_desc[0].id;\n\taw_dev->prof_index = aw_dev->prof_info.prof_desc[0].id;\n\n\tret = aw88395_dev_fw_update(aw_dev, AW88395_FORCE_UPDATE_ON,\tAW88395_DSP_FW_UPDATE_ON);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"fw update failed ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\taw88395_dev_mute(aw_dev, true);\n\tusleep_range(AW88395_4000_US, AW88395_4000_US + 100);\n\n\t \n\taw_dev_i2s_tx_enable(aw_dev, false);\n\tusleep_range(AW88395_1000_US, AW88395_1000_US + 100);\n\n\t \n\taw_dev_dsp_enable(aw_dev, false);\n\t \n\taw_dev_amppd(aw_dev, true);\n\t \n\taw_dev_pwd(aw_dev, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_init);\n\nstatic void aw88395_parse_channel_dt(struct aw_device *aw_dev)\n{\n\tstruct device_node *np = aw_dev->dev->of_node;\n\tu32 channel_value;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"sound-channel\", &channel_value);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev,\n\t\t\t\"read sound-channel failed,use default 0\");\n\t\taw_dev->channel = AW88395_DEV_DEFAULT_CH;\n\t\treturn;\n\t}\n\n\tdev_dbg(aw_dev->dev, \"read sound-channel value is: %d\",\n\t\t\tchannel_value);\n\taw_dev->channel = channel_value;\n}\n\nstatic void aw88395_parse_fade_enable_dt(struct aw_device *aw_dev)\n{\n\tstruct device_node *np = aw_dev->dev->of_node;\n\tu32 fade_en;\n\tint ret;\n\n\tret = of_property_read_u32(np, \"fade-enable\", &fade_en);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev,\n\t\t\t\"read fade-enable failed, close fade_in_out\");\n\t\tfade_en = AW88395_FADE_IN_OUT_DEFAULT;\n\t}\n\n\tdev_dbg(aw_dev->dev, \"read fade-enable value is: %d\", fade_en);\n\n\taw_dev->fade_en = fade_en;\n}\n\nstatic int aw_dev_init(struct aw_device *aw_dev)\n{\n\taw_dev->chip_id = AW88395_CHIP_ID;\n\t \n\taw_dev->acf = NULL;\n\taw_dev->prof_info.prof_desc = NULL;\n\taw_dev->prof_info.count = 0;\n\taw_dev->prof_info.prof_type = AW88395_DEV_NONE_TYPE_ID;\n\taw_dev->channel = 0;\n\taw_dev->fw_status = AW88395_DEV_FW_FAILED;\n\n\taw_dev->fade_step = AW88395_VOLUME_STEP_DB;\n\taw_dev->volume_desc.ctl_volume = AW88395_VOL_DEFAULT_VALUE;\n\taw88395_parse_channel_dt(aw_dev);\n\taw88395_parse_fade_enable_dt(aw_dev);\n\n\treturn 0;\n}\n\nint aw88395_dev_get_profile_count(struct aw_device *aw_dev)\n{\n\treturn aw_dev->prof_info.count;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_get_profile_count);\n\nint aw88395_dev_get_profile_index(struct aw_device *aw_dev)\n{\n\treturn aw_dev->prof_index;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_get_profile_index);\n\nint aw88395_dev_set_profile_index(struct aw_device *aw_dev, int index)\n{\n\t \n\tif ((index >= aw_dev->prof_info.count) || (index < 0))\n\t\treturn -EINVAL;\n\t \n\tif (aw_dev->prof_index == index)\n\t\treturn -EINVAL;\n\n\taw_dev->prof_index = index;\n\tdev_dbg(aw_dev->dev, \"set prof[%s]\",\n\t\taw_dev->prof_info.prof_name_list[aw_dev->prof_info.prof_desc[index].id]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_set_profile_index);\n\nchar *aw88395_dev_get_prof_name(struct aw_device *aw_dev, int index)\n{\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tstruct aw_prof_desc *prof_desc;\n\n\tif ((index >= aw_dev->prof_info.count) || (index < 0)) {\n\t\tdev_err(aw_dev->dev, \"index[%d] overflow count[%d]\",\n\t\t\tindex, aw_dev->prof_info.count);\n\t\treturn NULL;\n\t}\n\n\tprof_desc = &aw_dev->prof_info.prof_desc[index];\n\n\treturn prof_info->prof_name_list[prof_desc->id];\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_get_prof_name);\n\nint aw88395_dev_get_prof_data(struct aw_device *aw_dev, int index,\n\t\t\tstruct aw_prof_desc **prof_desc)\n{\n\tif ((index >= aw_dev->prof_info.count) || (index < 0)) {\n\t\tdev_err(aw_dev->dev, \"%s: index[%d] overflow count[%d]\\n\",\n\t\t\t\t__func__, index, aw_dev->prof_info.count);\n\t\treturn -EINVAL;\n\t}\n\n\t*prof_desc = &aw_dev->prof_info.prof_desc[index];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_get_prof_data);\n\nint aw88395_init(struct aw_device **aw_dev, struct i2c_client *i2c, struct regmap *regmap)\n{\n\tu16 chip_id;\n\tint ret;\n\n\tif (*aw_dev) {\n\t\tdev_info(&i2c->dev, \"it should be initialized here.\\n\");\n\t} else {\n\t\t*aw_dev = devm_kzalloc(&i2c->dev, sizeof(struct aw_device), GFP_KERNEL);\n\t\tif (!(*aw_dev))\n\t\t\treturn -ENOMEM;\n\t}\n\n\t(*aw_dev)->i2c = i2c;\n\t(*aw_dev)->dev = &i2c->dev;\n\t(*aw_dev)->regmap = regmap;\n\tmutex_init(&(*aw_dev)->dsp_lock);\n\n\t \n\tret = aw_dev_read_chipid((*aw_dev), &chip_id);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"dev_read_chipid failed ret=%d\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (chip_id) {\n\tcase AW88395_CHIP_ID:\n\t\tret = aw_dev_init((*aw_dev));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err((*aw_dev)->dev, \"unsupported device\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(aw88395_init);\n\nMODULE_DESCRIPTION(\"AW88395 device lib\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}