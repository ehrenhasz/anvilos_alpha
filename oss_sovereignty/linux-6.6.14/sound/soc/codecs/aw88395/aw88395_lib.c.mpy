{
  "module_name": "aw88395_lib.c",
  "hash_id": "e0191c11bb1240065e561238ae044527cd967c13986f91253b38b953f6bbbe43",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/aw88395/aw88395_lib.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/crc8.h>\n#include <linux/i2c.h>\n#include \"aw88395_lib.h\"\n#include \"aw88395_device.h\"\n#include \"aw88395_reg.h\"\n\n#define AW88395_CRC8_POLYNOMIAL 0x8C\nDECLARE_CRC8_TABLE(aw_crc8_table);\n\nstatic char *profile_name[AW88395_PROFILE_MAX] = {\n\t\"Music\", \"Voice\", \"Voip\", \"Ringtone\",\n\t\"Ringtone_hs\", \"Lowpower\", \"Bypass\",\n\t\"Mmi\", \"Fm\", \"Notification\", \"Receiver\"\n};\n\nstatic int aw_parse_bin_header(struct aw_device *aw_dev, struct aw_bin *bin);\n\nstatic int aw_check_sum(struct aw_device *aw_dev, struct aw_bin *bin, int bin_num)\n{\n\tunsigned char *p_check_sum;\n\tunsigned int sum_data = 0;\n\tunsigned int check_sum;\n\tunsigned int i, len;\n\n\tp_check_sum = &(bin->info.data[(bin->header_info[bin_num].valid_data_addr -\n\t\t\t\t\t\tbin->header_info[bin_num].header_len)]);\n\tlen = bin->header_info[bin_num].bin_data_len + bin->header_info[bin_num].header_len;\n\tcheck_sum = le32_to_cpup((void *)p_check_sum);\n\n\tfor (i = 4; i < len; i++)\n\t\tsum_data += *(p_check_sum + i);\n\n\tdev_dbg(aw_dev->dev, \"%s -- check_sum = %p, check_sum = 0x%x, sum_data = 0x%x\",\n\t\t\t\t\t__func__, p_check_sum, check_sum, sum_data);\n\tif (sum_data != check_sum) {\n\t\tdev_err(aw_dev->dev, \"%s. CheckSum Fail.bin_num=%d, CheckSum:0x%x, SumData:0x%x\",\n\t\t\t\t__func__, bin_num, check_sum, sum_data);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_check_data_version(struct aw_device *aw_dev, struct aw_bin *bin, int bin_num)\n{\n\tif (bin->header_info[bin_num].bin_data_ver < DATA_VERSION_V1 ||\n\t\tbin->header_info[bin_num].bin_data_ver > DATA_VERSION_MAX) {\n\t\tdev_err(aw_dev->dev, \"aw_bin_parse Unrecognized this bin data version\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_check_register_num(struct aw_device *aw_dev, struct aw_bin *bin, int bin_num)\n{\n\tstruct bin_header_info temp_info = bin->header_info[bin_num];\n\tunsigned int check_register_num, parse_register_num;\n\tunsigned char *p_check_sum;\n\n\tp_check_sum = &(bin->info.data[(temp_info.valid_data_addr)]);\n\n\tparse_register_num = le32_to_cpup((void *)p_check_sum);\n\tcheck_register_num = (bin->header_info[bin_num].bin_data_len - CHECK_REGISTER_NUM_OFFSET) /\n\t\t\t\t(bin->header_info[bin_num].reg_byte_len +\n\t\t\t\tbin->header_info[bin_num].data_byte_len);\n\tdev_dbg(aw_dev->dev, \"%s,parse_register_num = 0x%x,check_register_num = 0x%x\\n\",\n\t\t\t\t__func__, parse_register_num, check_register_num);\n\tif (parse_register_num != check_register_num) {\n\t\tdev_err(aw_dev->dev, \"%s parse_register_num = 0x%x,check_register_num = 0x%x\\n\",\n\t\t\t\t__func__, parse_register_num, check_register_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbin->header_info[bin_num].reg_num = parse_register_num;\n\tbin->header_info[bin_num].valid_data_len = temp_info.bin_data_len - VALID_DATA_LEN;\n\tbin->header_info[bin_num].valid_data_addr = temp_info.valid_data_addr + VALID_DATA_ADDR;\n\n\treturn 0;\n}\n\nstatic int aw_check_dsp_reg_num(struct aw_device *aw_dev, struct aw_bin *bin, int bin_num)\n{\n\tstruct bin_header_info temp_info = bin->header_info[bin_num];\n\tunsigned int check_dsp_reg_num, parse_dsp_reg_num;\n\tunsigned char *p_check_sum;\n\n\tp_check_sum = &(bin->info.data[(temp_info.valid_data_addr)]);\n\n\tparse_dsp_reg_num = le32_to_cpup((void *)(p_check_sum + PARSE_DSP_REG_NUM));\n\tbin->header_info[bin_num].reg_data_byte_len =\n\t\t\tle32_to_cpup((void *)(p_check_sum + REG_DATA_BYTP_LEN));\n\tcheck_dsp_reg_num = (bin->header_info[bin_num].bin_data_len - CHECK_DSP_REG_NUM) /\n\t\t\t\tbin->header_info[bin_num].reg_data_byte_len;\n\tdev_dbg(aw_dev->dev, \"%s bin_num = %d, parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\",\n\t\t\t\t\t__func__, bin_num, check_dsp_reg_num, check_dsp_reg_num);\n\tif (parse_dsp_reg_num != check_dsp_reg_num) {\n\t\tdev_err(aw_dev->dev, \"aw_bin_parse check dsp reg num error\\n\");\n\t\tdev_err(aw_dev->dev, \"%s parse_dsp_reg_num = 0x%x, check_dsp_reg_num = 0x%x\",\n\t\t\t\t\t__func__, check_dsp_reg_num, check_dsp_reg_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbin->header_info[bin_num].download_addr = le32_to_cpup((void *)p_check_sum);\n\tbin->header_info[bin_num].reg_num = parse_dsp_reg_num;\n\tbin->header_info[bin_num].valid_data_len = temp_info.bin_data_len - DSP_VALID_DATA_LEN;\n\tbin->header_info[bin_num].valid_data_addr = temp_info.valid_data_addr +\n\t\t\t\t\t\t\t\tDSP_VALID_DATA_ADDR;\n\n\treturn 0;\n}\n\nstatic int aw_check_soc_app_num(struct aw_device *aw_dev, struct aw_bin *bin, int bin_num)\n{\n\tstruct bin_header_info temp_info = bin->header_info[bin_num];\n\tunsigned int check_soc_app_num, parse_soc_app_num;\n\tunsigned char *p_check_sum;\n\n\tp_check_sum = &(bin->info.data[(temp_info.valid_data_addr)]);\n\n\tbin->header_info[bin_num].app_version = le32_to_cpup((void *)p_check_sum);\n\tparse_soc_app_num = le32_to_cpup((void *)(p_check_sum + PARSE_SOC_APP_NUM));\n\tcheck_soc_app_num = bin->header_info[bin_num].bin_data_len - CHECK_SOC_APP_NUM;\n\tdev_dbg(aw_dev->dev, \"%s bin_num = %d, parse_soc_app_num=0x%x, check_soc_app_num = 0x%x\\n\",\n\t\t\t\t\t__func__, bin_num, parse_soc_app_num, check_soc_app_num);\n\tif (parse_soc_app_num != check_soc_app_num) {\n\t\tdev_err(aw_dev->dev, \"%s parse_soc_app_num=0x%x, check_soc_app_num = 0x%x\\n\",\n\t\t\t\t\t__func__, parse_soc_app_num, check_soc_app_num);\n\t\treturn -EINVAL;\n\t}\n\n\tbin->header_info[bin_num].reg_num = parse_soc_app_num;\n\tbin->header_info[bin_num].download_addr = le32_to_cpup((void *)(p_check_sum +\n\t\t\t\t\t\t\t\tAPP_DOWNLOAD_ADDR));\n\tbin->header_info[bin_num].valid_data_len = temp_info.bin_data_len - APP_VALID_DATA_LEN;\n\tbin->header_info[bin_num].valid_data_addr = temp_info.valid_data_addr +\n\t\t\t\t\t\t\t\tAPP_VALID_DATA_ADDR;\n\n\treturn 0;\n}\n\nstatic void aw_get_single_bin_header(struct aw_bin *bin)\n{\n\tmemcpy((void *)&bin->header_info[bin->all_bin_parse_num], bin->p_addr, DATA_LEN);\n\n\tbin->header_info[bin->all_bin_parse_num].header_len = HEADER_LEN;\n\tbin->all_bin_parse_num += 1;\n}\n\nstatic int aw_parse_one_of_multi_bins(struct aw_device *aw_dev, unsigned int bin_num,\n\t\t\t\t\tint bin_serial_num, struct aw_bin *bin)\n{\n\tstruct bin_header_info aw_bin_header_info;\n\tunsigned int bin_start_addr;\n\tunsigned int valid_data_len;\n\n\tif (bin->info.len < sizeof(struct bin_header_info)) {\n\t\tdev_err(aw_dev->dev, \"bin_header_info size[%d] overflow file size[%d]\\n\",\n\t\t\t\t(int)sizeof(struct bin_header_info), bin->info.len);\n\t\treturn -EINVAL;\n\t}\n\n\taw_bin_header_info = bin->header_info[bin->all_bin_parse_num - 1];\n\tif (!bin_serial_num) {\n\t\tbin_start_addr = le32_to_cpup((void *)(bin->p_addr + START_ADDR_OFFSET));\n\t\tbin->p_addr += (HEADER_LEN + bin_start_addr);\n\t\tbin->header_info[bin->all_bin_parse_num].valid_data_addr =\n\t\t\taw_bin_header_info.valid_data_addr + VALID_DATA_ADDR + 8 * bin_num +\n\t\t\tVALID_DATA_ADDR_OFFSET;\n\t} else {\n\t\tvalid_data_len = aw_bin_header_info.bin_data_len;\n\t\tbin->p_addr += (HDADER_LEN + valid_data_len);\n\t\tbin->header_info[bin->all_bin_parse_num].valid_data_addr =\n\t\t    aw_bin_header_info.valid_data_addr + aw_bin_header_info.bin_data_len +\n\t\t    VALID_DATA_ADDR_OFFSET;\n\t}\n\n\treturn aw_parse_bin_header(aw_dev, bin);\n}\n\nstatic int aw_get_multi_bin_header(struct aw_device *aw_dev, struct aw_bin *bin)\n{\n\tunsigned int bin_num, i;\n\tint ret;\n\n\tbin_num = le32_to_cpup((void *)(bin->p_addr + VALID_DATA_ADDR_OFFSET));\n\tif (bin->multi_bin_parse_num == 1)\n\t\tbin->header_info[bin->all_bin_parse_num].valid_data_addr =\n\t\t\t\t\t\t\tVALID_DATA_ADDR_OFFSET;\n\n\taw_get_single_bin_header(bin);\n\n\tfor (i = 0; i < bin_num; i++) {\n\t\tdev_dbg(aw_dev->dev, \"aw_bin_parse enter multi bin for is %d\\n\", i);\n\t\tret = aw_parse_one_of_multi_bins(aw_dev, bin_num, i, bin);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_parse_bin_header(struct aw_device *aw_dev, struct aw_bin *bin)\n{\n\tunsigned int bin_data_type;\n\n\tif (bin->info.len < sizeof(struct bin_header_info)) {\n\t\tdev_err(aw_dev->dev, \"bin_header_info size[%d] overflow file size[%d]\\n\",\n\t\t\t\t(int)sizeof(struct bin_header_info), bin->info.len);\n\t\treturn -EINVAL;\n\t}\n\n\tbin_data_type = le32_to_cpup((void *)(bin->p_addr + BIN_DATA_TYPE_OFFSET));\n\tdev_dbg(aw_dev->dev, \"aw_bin_parse bin_data_type 0x%x\\n\", bin_data_type);\n\tswitch (bin_data_type) {\n\tcase DATA_TYPE_REGISTER:\n\tcase DATA_TYPE_DSP_REG:\n\tcase DATA_TYPE_SOC_APP:\n\t\tbin->single_bin_parse_num += 1;\n\t\tdev_dbg(aw_dev->dev, \"%s bin->single_bin_parse_num is %d\\n\", __func__,\n\t\t\t\t\t\tbin->single_bin_parse_num);\n\t\tif (!bin->multi_bin_parse_num)\n\t\t\tbin->header_info[bin->all_bin_parse_num].valid_data_addr =\n\t\t\t\t\t\t\t\tVALID_DATA_ADDR_OFFSET;\n\t\taw_get_single_bin_header(bin);\n\t\treturn 0;\n\tcase DATA_TYPE_MULTI_BINS:\n\t\tbin->multi_bin_parse_num += 1;\n\t\tdev_dbg(aw_dev->dev, \"%s bin->multi_bin_parse_num is %d\\n\", __func__,\n\t\t\t\t\t\tbin->multi_bin_parse_num);\n\t\treturn aw_get_multi_bin_header(aw_dev, bin);\n\tdefault:\n\t\tdev_dbg(aw_dev->dev, \"%s There is no corresponding type\\n\", __func__);\n\t\treturn 0;\n\t}\n}\n\nstatic int aw_check_bin_header_version(struct aw_device *aw_dev, struct aw_bin *bin)\n{\n\tunsigned int header_version;\n\n\theader_version = le32_to_cpup((void *)(bin->p_addr + HEADER_VERSION_OFFSET));\n\tdev_dbg(aw_dev->dev, \"aw_bin_parse header_version 0x%x\\n\", header_version);\n\n\tswitch (header_version) {\n\tcase HEADER_VERSION_V1:\n\t\treturn aw_parse_bin_header(aw_dev, bin);\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"aw_bin_parse Unrecognized this bin header version\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int aw_parsing_bin_file(struct aw_device *aw_dev, struct aw_bin *bin)\n{\n\tint ret = -EINVAL;\n\tint i;\n\n\tif (!bin) {\n\t\tdev_err(aw_dev->dev, \"aw_bin_parse bin is NULL\\n\");\n\t\treturn ret;\n\t}\n\tbin->p_addr = bin->info.data;\n\tbin->all_bin_parse_num = 0;\n\tbin->multi_bin_parse_num = 0;\n\tbin->single_bin_parse_num = 0;\n\n\tret = aw_check_bin_header_version(aw_dev, bin);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"aw_bin_parse check bin header version error\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < bin->all_bin_parse_num; i++) {\n\t\tret = aw_check_sum(aw_dev, bin, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"aw_bin_parse check sum data error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = aw_check_data_version(aw_dev, bin, i);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"aw_bin_parse check data version error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (bin->header_info[i].bin_data_ver == DATA_VERSION_V1) {\n\t\t\tswitch (bin->header_info[i].bin_data_type) {\n\t\t\tcase DATA_TYPE_REGISTER:\n\t\t\t\tret = aw_check_register_num(aw_dev, bin, i);\n\t\t\t\tbreak;\n\t\t\tcase DATA_TYPE_DSP_REG:\n\t\t\t\tret = aw_check_dsp_reg_num(aw_dev, bin, i);\n\t\t\t\tbreak;\n\t\t\tcase DATA_TYPE_SOC_APP:\n\t\t\t\tret = aw_check_soc_app_num(aw_dev, bin, i);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbin->header_info[i].valid_data_len =\n\t\t\t\t\t\tbin->header_info[i].bin_data_len;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_raw_reg(unsigned char *data, unsigned int data_len,\n\t\tstruct aw_prof_desc *prof_desc)\n{\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].data = data;\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].len = data_len;\n\n\tprof_desc->prof_st = AW88395_PROFILE_OK;\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_raw_dsp_cfg(unsigned char *data, unsigned int data_len,\n\t\tstruct aw_prof_desc *prof_desc)\n{\n\tif (data_len & 0x01)\n\t\treturn -EINVAL;\n\n\tswab16_array((u16 *)data, data_len >> 1);\n\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_CFG].data = data;\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_CFG].len = data_len;\n\n\tprof_desc->prof_st = AW88395_PROFILE_OK;\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_raw_dsp_fw(unsigned char *data,\tunsigned int data_len,\n\t\tstruct aw_prof_desc *prof_desc)\n{\n\tif (data_len & 0x01)\n\t\treturn -EINVAL;\n\n\tswab16_array((u16 *)data, data_len >> 1);\n\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_FW].data = data;\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_FW].len = data_len;\n\n\tprof_desc->prof_st = AW88395_PROFILE_OK;\n\n\treturn 0;\n}\n\nstatic int aw_dev_prof_parse_multi_bin(struct aw_device *aw_dev, unsigned char *data,\n\t\t\t\tunsigned int data_len, struct aw_prof_desc *prof_desc)\n{\n\tstruct aw_bin *aw_bin;\n\tint ret;\n\tint i;\n\n\taw_bin = devm_kzalloc(aw_dev->dev, data_len + sizeof(struct aw_bin), GFP_KERNEL);\n\tif (!aw_bin)\n\t\treturn -ENOMEM;\n\n\taw_bin->info.len = data_len;\n\tmemcpy(aw_bin->info.data, data, data_len);\n\n\tret = aw_parsing_bin_file(aw_dev, aw_bin);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"parse bin failed\");\n\t\tgoto parse_bin_failed;\n\t}\n\n\tfor (i = 0; i < aw_bin->all_bin_parse_num; i++) {\n\t\tswitch (aw_bin->header_info[i].bin_data_type) {\n\t\tcase DATA_TYPE_REGISTER:\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].len =\n\t\t\t\t\taw_bin->header_info[i].valid_data_len;\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].data =\n\t\t\t\t\tdata + aw_bin->header_info[i].valid_data_addr;\n\t\t\tbreak;\n\t\tcase DATA_TYPE_DSP_REG:\n\t\t\tif (aw_bin->header_info[i].valid_data_len & 0x01) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto parse_bin_failed;\n\t\t\t}\n\n\t\t\tswab16_array((u16 *)(data + aw_bin->header_info[i].valid_data_addr),\n\t\t\t\t\taw_bin->header_info[i].valid_data_len >> 1);\n\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_CFG].len =\n\t\t\t\t\taw_bin->header_info[i].valid_data_len;\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_CFG].data =\n\t\t\t\t\tdata + aw_bin->header_info[i].valid_data_addr;\n\t\t\tbreak;\n\t\tcase DATA_TYPE_DSP_FW:\n\t\tcase DATA_TYPE_SOC_APP:\n\t\t\tif (aw_bin->header_info[i].valid_data_len & 0x01) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto parse_bin_failed;\n\t\t\t}\n\n\t\t\tswab16_array((u16 *)(data + aw_bin->header_info[i].valid_data_addr),\n\t\t\t\t\taw_bin->header_info[i].valid_data_len >> 1);\n\n\t\t\tprof_desc->fw_ver = aw_bin->header_info[i].app_version;\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_FW].len =\n\t\t\t\t\taw_bin->header_info[i].valid_data_len;\n\t\t\tprof_desc->sec_desc[AW88395_DATA_TYPE_DSP_FW].data =\n\t\t\t\t\tdata + aw_bin->header_info[i].valid_data_addr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(aw_dev->dev, \"bin_data_type not found\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tprof_desc->prof_st = AW88395_PROFILE_OK;\n\tret =  0;\n\nparse_bin_failed:\n\tdevm_kfree(aw_dev->dev, aw_bin);\n\treturn ret;\n}\n\nstatic int aw_dev_parse_reg_bin_with_hdr(struct aw_device *aw_dev,\n\t\t\tuint8_t *data, uint32_t data_len, struct aw_prof_desc *prof_desc)\n{\n\tstruct aw_bin *aw_bin;\n\tint ret;\n\n\taw_bin = devm_kzalloc(aw_dev->dev, data_len + sizeof(*aw_bin), GFP_KERNEL);\n\tif (!aw_bin)\n\t\treturn -ENOMEM;\n\n\taw_bin->info.len = data_len;\n\tmemcpy(aw_bin->info.data, data, data_len);\n\n\tret = aw_parsing_bin_file(aw_dev, aw_bin);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"parse bin failed\");\n\t\tgoto parse_bin_failed;\n\t}\n\n\tif ((aw_bin->all_bin_parse_num != 1) ||\n\t\t(aw_bin->header_info[0].bin_data_type != DATA_TYPE_REGISTER)) {\n\t\tdev_err(aw_dev->dev, \"bin num or type error\");\n\t\tret = -EINVAL;\n\t\tgoto parse_bin_failed;\n\t}\n\n\tif (aw_bin->header_info[0].valid_data_len % 4) {\n\t\tdev_err(aw_dev->dev, \"bin data len get error!\");\n\t\tret = -EINVAL;\n\t\tgoto parse_bin_failed;\n\t}\n\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].data =\n\t\t\t\tdata + aw_bin->header_info[0].valid_data_addr;\n\tprof_desc->sec_desc[AW88395_DATA_TYPE_REG].len =\n\t\t\t\taw_bin->header_info[0].valid_data_len;\n\tprof_desc->prof_st = AW88395_PROFILE_OK;\n\n\tdevm_kfree(aw_dev->dev, aw_bin);\n\taw_bin = NULL;\n\n\treturn 0;\n\nparse_bin_failed:\n\tdevm_kfree(aw_dev->dev, aw_bin);\n\taw_bin = NULL;\n\treturn ret;\n}\n\nstatic int aw_dev_parse_data_by_sec_type(struct aw_device *aw_dev, struct aw_cfg_hdr *cfg_hdr,\n\t\t\tstruct aw_cfg_dde *cfg_dde, struct aw_prof_desc *scene_prof_desc)\n{\n\tswitch (cfg_dde->data_type) {\n\tcase ACF_SEC_TYPE_REG:\n\t\treturn aw_dev_parse_raw_reg((u8 *)cfg_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, scene_prof_desc);\n\tcase ACF_SEC_TYPE_DSP_CFG:\n\t\treturn aw_dev_parse_raw_dsp_cfg((u8 *)cfg_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, scene_prof_desc);\n\tcase ACF_SEC_TYPE_DSP_FW:\n\t\treturn aw_dev_parse_raw_dsp_fw(\n\t\t\t\t(u8 *)cfg_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, scene_prof_desc);\n\tcase ACF_SEC_TYPE_MULTIPLE_BIN:\n\t\treturn aw_dev_prof_parse_multi_bin(\n\t\t\t\taw_dev, (u8 *)cfg_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, scene_prof_desc);\n\tcase ACF_SEC_TYPE_HDR_REG:\n\t\treturn aw_dev_parse_reg_bin_with_hdr(aw_dev, (u8 *)cfg_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, scene_prof_desc);\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"%s cfg_dde->data_type = %d\\n\", __func__, cfg_dde->data_type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_dev_type(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *prof_hdr, struct aw_all_prof_info *all_prof_info)\n{\n\tstruct aw_cfg_dde *cfg_dde =\n\t\t(struct aw_cfg_dde *)((char *)prof_hdr + prof_hdr->hdr_offset);\n\tint sec_num = 0;\n\tint ret, i;\n\n\tfor (i = 0; i < prof_hdr->ddt_num; i++) {\n\t\tif ((aw_dev->i2c->adapter->nr == cfg_dde[i].dev_bus) &&\n\t\t    (aw_dev->i2c->addr == cfg_dde[i].dev_addr) &&\n\t\t    (cfg_dde[i].type == AW88395_DEV_TYPE_ID) &&\n\t\t    (cfg_dde[i].data_type != ACF_SEC_TYPE_MONITOR)) {\n\t\t\tif (cfg_dde[i].dev_profile >= AW88395_PROFILE_MAX) {\n\t\t\t\tdev_err(aw_dev->dev, \"dev_profile [%d] overflow\",\n\t\t\t\t\t\t\tcfg_dde[i].dev_profile);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = aw_dev_parse_data_by_sec_type(aw_dev, prof_hdr, &cfg_dde[i],\n\t\t\t\t\t&all_prof_info->prof_desc[cfg_dde[i].dev_profile]);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw_dev->dev, \"parse failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsec_num++;\n\t\t}\n\t}\n\n\tif (sec_num == 0) {\n\t\tdev_dbg(aw_dev->dev, \"get dev type num is %d, please use default\", sec_num);\n\t\treturn AW88395_DEV_TYPE_NONE;\n\t}\n\n\treturn AW88395_DEV_TYPE_OK;\n}\n\nstatic int aw_dev_parse_dev_default_type(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *prof_hdr, struct aw_all_prof_info *all_prof_info)\n{\n\tstruct aw_cfg_dde *cfg_dde =\n\t\t(struct aw_cfg_dde *)((char *)prof_hdr + prof_hdr->hdr_offset);\n\tint sec_num = 0;\n\tint ret, i;\n\n\tfor (i = 0; i < prof_hdr->ddt_num; i++) {\n\t\tif ((aw_dev->channel == cfg_dde[i].dev_index) &&\n\t\t    (cfg_dde[i].type == AW88395_DEV_DEFAULT_TYPE_ID) &&\n\t\t    (cfg_dde[i].data_type != ACF_SEC_TYPE_MONITOR)) {\n\t\t\tif (cfg_dde[i].dev_profile >= AW88395_PROFILE_MAX) {\n\t\t\t\tdev_err(aw_dev->dev, \"dev_profile [%d] overflow\",\n\t\t\t\t\tcfg_dde[i].dev_profile);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tret = aw_dev_parse_data_by_sec_type(aw_dev, prof_hdr, &cfg_dde[i],\n\t\t\t\t\t&all_prof_info->prof_desc[cfg_dde[i].dev_profile]);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw_dev->dev, \"parse failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsec_num++;\n\t\t}\n\t}\n\n\tif (sec_num == 0) {\n\t\tdev_err(aw_dev->dev, \"get dev default type failed, get num[%d]\", sec_num);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88261_dev_cfg_get_valid_prof(struct aw_device *aw_dev,\n\t\t\t\tstruct aw_all_prof_info all_prof_info)\n{\n\tstruct aw_prof_desc *prof_desc = all_prof_info.prof_desc;\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tint num = 0;\n\tint i;\n\n\tfor (i = 0; i < AW88395_PROFILE_MAX; i++) {\n\t\tif (prof_desc[i].prof_st == AW88395_PROFILE_OK)\n\t\t\tprof_info->count++;\n\t}\n\n\tdev_dbg(aw_dev->dev, \"get valid profile:%d\", aw_dev->prof_info.count);\n\n\tif (!prof_info->count) {\n\t\tdev_err(aw_dev->dev, \"no profile data\");\n\t\treturn -EPERM;\n\t}\n\n\tprof_info->prof_desc = devm_kcalloc(aw_dev->dev,\n\t\t\t\t\tprof_info->count, sizeof(struct aw_prof_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prof_info->prof_desc)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < AW88395_PROFILE_MAX; i++) {\n\t\tif (prof_desc[i].prof_st == AW88395_PROFILE_OK) {\n\t\t\tif (num >= prof_info->count) {\n\t\t\t\tdev_err(aw_dev->dev, \"overflow count[%d]\",\n\t\t\t\t\t\tprof_info->count);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tprof_info->prof_desc[num] = prof_desc[i];\n\t\t\tprof_info->prof_desc[num].id = i;\n\t\t\tnum++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88395_dev_cfg_get_valid_prof(struct aw_device *aw_dev,\n\t\t\t\tstruct aw_all_prof_info all_prof_info)\n{\n\tstruct aw_prof_desc *prof_desc = all_prof_info.prof_desc;\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tstruct aw_sec_data_desc *sec_desc;\n\tint num = 0;\n\tint i;\n\n\tfor (i = 0; i < AW88395_PROFILE_MAX; i++) {\n\t\tif (prof_desc[i].prof_st == AW88395_PROFILE_OK) {\n\t\t\tsec_desc = prof_desc[i].sec_desc;\n\t\t\tif ((sec_desc[AW88395_DATA_TYPE_REG].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_REG].len != 0) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_CFG].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_CFG].len != 0) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_FW].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_FW].len != 0))\n\t\t\t\tprof_info->count++;\n\t\t}\n\t}\n\n\tdev_dbg(aw_dev->dev, \"get valid profile:%d\", aw_dev->prof_info.count);\n\n\tif (!prof_info->count) {\n\t\tdev_err(aw_dev->dev, \"no profile data\");\n\t\treturn -EPERM;\n\t}\n\n\tprof_info->prof_desc = devm_kcalloc(aw_dev->dev,\n\t\t\t\t\tprof_info->count, sizeof(struct aw_prof_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prof_info->prof_desc)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < AW88395_PROFILE_MAX; i++) {\n\t\tif (prof_desc[i].prof_st == AW88395_PROFILE_OK) {\n\t\t\tsec_desc = prof_desc[i].sec_desc;\n\t\t\tif ((sec_desc[AW88395_DATA_TYPE_REG].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_REG].len != 0) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_CFG].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_CFG].len != 0) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_FW].data != NULL) &&\n\t\t\t    (sec_desc[AW88395_DATA_TYPE_DSP_FW].len != 0)) {\n\t\t\t\tif (num >= prof_info->count) {\n\t\t\t\t\tdev_err(aw_dev->dev, \"overflow count[%d]\",\n\t\t\t\t\t\t\tprof_info->count);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tprof_info->prof_desc[num] = prof_desc[i];\n\t\t\t\tprof_info->prof_desc[num].id = i;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_load_cfg_by_hdr(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *prof_hdr)\n{\n\tstruct aw_all_prof_info *all_prof_info;\n\tint ret;\n\n\tall_prof_info = devm_kzalloc(aw_dev->dev, sizeof(struct aw_all_prof_info), GFP_KERNEL);\n\tif (!all_prof_info)\n\t\treturn -ENOMEM;\n\n\tret = aw_dev_parse_dev_type(aw_dev, prof_hdr, all_prof_info);\n\tif (ret < 0) {\n\t\tgoto exit;\n\t} else if (ret == AW88395_DEV_TYPE_NONE) {\n\t\tdev_dbg(aw_dev->dev, \"get dev type num is 0, parse default dev\");\n\t\tret = aw_dev_parse_dev_default_type(aw_dev, prof_hdr, all_prof_info);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t}\n\n\tswitch (aw_dev->chip_id) {\n\tcase AW88395_CHIP_ID:\n\t\tret = aw88395_dev_cfg_get_valid_prof(aw_dev, *all_prof_info);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tbreak;\n\tcase AW88261_CHIP_ID:\n\t\tret = aw88261_dev_cfg_get_valid_prof(aw_dev, *all_prof_info);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"valid prof unsupported\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\taw_dev->prof_info.prof_name_list = profile_name;\n\nexit:\n\tdevm_kfree(aw_dev->dev, all_prof_info);\n\treturn ret;\n}\n\nstatic int aw_dev_create_prof_name_list_v1(struct aw_device *aw_dev)\n{\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tstruct aw_prof_desc *prof_desc = prof_info->prof_desc;\n\tint i;\n\n\tif (!prof_desc) {\n\t\tdev_err(aw_dev->dev, \"prof_desc is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tprof_info->prof_name_list = devm_kzalloc(aw_dev->dev,\n\t\t\t\t\tprof_info->count * PROFILE_STR_MAX,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prof_info->prof_name_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < prof_info->count; i++) {\n\t\tprof_desc[i].id = i;\n\t\tprof_info->prof_name_list[i] = prof_desc[i].prf_str;\n\t\tdev_dbg(aw_dev->dev, \"prof name is %s\", prof_info->prof_name_list[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_get_dde_type_info(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tstruct aw_cfg_hdr *cfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\tstruct aw_cfg_dde_v1 *cfg_dde =\n\t\t(struct aw_cfg_dde_v1 *)(aw_cfg->data + cfg_hdr->hdr_offset);\n\tint default_num = 0;\n\tint dev_num = 0;\n\tunsigned int i;\n\n\tfor (i = 0; i < cfg_hdr->ddt_num; i++) {\n\t\tif (cfg_dde[i].type == AW88395_DEV_TYPE_ID)\n\t\t\tdev_num++;\n\n\t\tif (cfg_dde[i].type == AW88395_DEV_DEFAULT_TYPE_ID)\n\t\t\tdefault_num++;\n\t}\n\n\tif (dev_num != 0) {\n\t\taw_dev->prof_info.prof_type = AW88395_DEV_TYPE_ID;\n\t} else if (default_num != 0) {\n\t\taw_dev->prof_info.prof_type = AW88395_DEV_DEFAULT_TYPE_ID;\n\t} else {\n\t\tdev_err(aw_dev->dev, \"can't find scene\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_get_dev_scene_count_v1(struct aw_device *aw_dev, struct aw_container *aw_cfg,\n\t\t\t\t\t\tunsigned int *scene_num)\n{\n\tstruct aw_cfg_hdr *cfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\tstruct aw_cfg_dde_v1 *cfg_dde =\n\t\t(struct aw_cfg_dde_v1 *)(aw_cfg->data + cfg_hdr->hdr_offset);\n\tunsigned int i;\n\tint ret;\n\n\tswitch (aw_dev->chip_id) {\n\tcase AW88395_CHIP_ID:\n\t\tfor (i = 0; i < cfg_hdr->ddt_num; ++i) {\n\t\t\tif ((cfg_dde[i].data_type == ACF_SEC_TYPE_MULTIPLE_BIN) &&\n\t\t\t    (aw_dev->chip_id == cfg_dde[i].chip_id) &&\n\t\t\t    (aw_dev->i2c->adapter->nr == cfg_dde[i].dev_bus) &&\n\t\t\t    (aw_dev->i2c->addr == cfg_dde[i].dev_addr))\n\t\t\t\t(*scene_num)++;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase AW88261_CHIP_ID:\n\t\tfor (i = 0; i < cfg_hdr->ddt_num; ++i) {\n\t\t\tif (((cfg_dde[i].data_type == ACF_SEC_TYPE_REG) ||\n\t\t\t     (cfg_dde[i].data_type == ACF_SEC_TYPE_HDR_REG)) &&\n\t\t\t    (aw_dev->chip_id == cfg_dde[i].chip_id) &&\n\t\t\t    (aw_dev->i2c->adapter->nr == cfg_dde[i].dev_bus) &&\n\t\t\t    (aw_dev->i2c->addr == cfg_dde[i].dev_addr))\n\t\t\t\t(*scene_num)++;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported device\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_get_default_scene_count_v1(struct aw_device *aw_dev,\n\t\t\t\t\t\tstruct aw_container *aw_cfg,\n\t\t\t\t\t\tunsigned int *scene_num)\n{\n\tstruct aw_cfg_hdr *cfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\tstruct aw_cfg_dde_v1 *cfg_dde =\n\t\t(struct aw_cfg_dde_v1 *)(aw_cfg->data + cfg_hdr->hdr_offset);\n\tunsigned int i;\n\tint ret;\n\n\tswitch (aw_dev->chip_id) {\n\tcase AW88395_CHIP_ID:\n\t\tfor (i = 0; i < cfg_hdr->ddt_num; ++i) {\n\t\t\tif ((cfg_dde[i].data_type == ACF_SEC_TYPE_MULTIPLE_BIN) &&\n\t\t\t    (aw_dev->chip_id == cfg_dde[i].chip_id) &&\n\t\t\t    (aw_dev->channel == cfg_dde[i].dev_index))\n\t\t\t\t(*scene_num)++;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase AW88261_CHIP_ID:\n\t\tfor (i = 0; i < cfg_hdr->ddt_num; ++i) {\n\t\t\tif (((cfg_dde[i].data_type == ACF_SEC_TYPE_REG) ||\n\t\t\t     (cfg_dde[i].data_type == ACF_SEC_TYPE_HDR_REG)) &&\n\t\t\t    (aw_dev->chip_id == cfg_dde[i].chip_id) &&\n\t\t\t    (aw_dev->channel == cfg_dde[i].dev_index))\n\t\t\t\t(*scene_num)++;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported device\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_dev_parse_scene_count_v1(struct aw_device *aw_dev,\n\t\t\t\t\t\t\tstruct aw_container *aw_cfg,\n\t\t\t\t\t\t\tunsigned int *count)\n{\n\tint ret;\n\n\tret = aw_get_dde_type_info(aw_dev, aw_cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (aw_dev->prof_info.prof_type) {\n\tcase AW88395_DEV_TYPE_ID:\n\t\tret = aw_get_dev_scene_count_v1(aw_dev, aw_cfg, count);\n\t\tbreak;\n\tcase AW88395_DEV_DEFAULT_TYPE_ID:\n\t\tret = aw_get_default_scene_count_v1(aw_dev, aw_cfg, count);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported prof_type[%x]\", aw_dev->prof_info.prof_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_dev_parse_data_by_sec_type_v1(struct aw_device *aw_dev,\n\t\t\t\t\t\t\tstruct aw_cfg_hdr *prof_hdr,\n\t\t\t\t\t\t\tstruct aw_cfg_dde_v1 *cfg_dde,\n\t\t\t\t\t\t\tint *cur_scene_id)\n{\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tint ret;\n\n\tswitch (cfg_dde->data_type) {\n\tcase ACF_SEC_TYPE_MULTIPLE_BIN:\n\t\tret = aw_dev_prof_parse_multi_bin(aw_dev, (u8 *)prof_hdr + cfg_dde->data_offset,\n\t\t\t\t\tcfg_dde->data_size, &prof_info->prof_desc[*cur_scene_id]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"parse multi bin failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tprof_info->prof_desc[*cur_scene_id].prf_str = cfg_dde->dev_profile_str;\n\t\tprof_info->prof_desc[*cur_scene_id].id = cfg_dde->dev_profile;\n\t\t(*cur_scene_id)++;\n\t\tbreak;\n\tcase ACF_SEC_TYPE_HDR_REG:\n\t\tret =  aw_dev_parse_reg_bin_with_hdr(aw_dev,\n\t\t\t\t(uint8_t *)prof_hdr + cfg_dde->data_offset,\n\t\t\t\tcfg_dde->data_size, &prof_info->prof_desc[*cur_scene_id]);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"parse reg bin with hdr failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tprof_info->prof_desc[*cur_scene_id].prf_str = cfg_dde->dev_profile_str;\n\t\tprof_info->prof_desc[*cur_scene_id].id = cfg_dde->dev_profile;\n\t\t(*cur_scene_id)++;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported SEC_TYPE [%d]\", cfg_dde->data_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_dev_type_v1(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *prof_hdr)\n{\n\tstruct aw_cfg_dde_v1 *cfg_dde =\n\t\t(struct aw_cfg_dde_v1 *)((char *)prof_hdr + prof_hdr->hdr_offset);\n\tint cur_scene_id = 0;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < prof_hdr->ddt_num; i++) {\n\t\tif ((aw_dev->i2c->adapter->nr == cfg_dde[i].dev_bus) &&\n\t\t    (aw_dev->i2c->addr == cfg_dde[i].dev_addr) &&\n\t\t    (aw_dev->chip_id == cfg_dde[i].chip_id)) {\n\t\t\tret = aw_dev_parse_data_by_sec_type_v1(aw_dev, prof_hdr,\n\t\t\t\t\t\t\t&cfg_dde[i], &cur_scene_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw_dev->dev, \"parse failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cur_scene_id == 0) {\n\t\tdev_err(aw_dev->dev, \"get dev type failed, get num [%d]\", cur_scene_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_default_type_v1(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *prof_hdr)\n{\n\tstruct aw_cfg_dde_v1 *cfg_dde =\n\t\t(struct aw_cfg_dde_v1 *)((char *)prof_hdr + prof_hdr->hdr_offset);\n\tint cur_scene_id = 0;\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < prof_hdr->ddt_num; i++) {\n\t\tif ((aw_dev->channel == cfg_dde[i].dev_index) &&\n\t\t\t(aw_dev->chip_id == cfg_dde[i].chip_id)) {\n\t\t\tret = aw_dev_parse_data_by_sec_type_v1(aw_dev, prof_hdr,\n\t\t\t\t\t\t\t&cfg_dde[i], &cur_scene_id);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw_dev->dev, \"parse failed\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cur_scene_id == 0) {\n\t\tdev_err(aw_dev->dev, \"get dev default type failed, get num[%d]\", cur_scene_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_parse_by_hdr_v1(struct aw_device *aw_dev,\n\t\tstruct aw_cfg_hdr *cfg_hdr)\n{\n\tint ret;\n\n\tswitch (aw_dev->prof_info.prof_type) {\n\tcase AW88395_DEV_TYPE_ID:\n\t\tret = aw_dev_parse_dev_type_v1(aw_dev, cfg_hdr);\n\t\tbreak;\n\tcase AW88395_DEV_DEFAULT_TYPE_ID:\n\t\tret = aw_dev_parse_default_type_v1(aw_dev, cfg_hdr);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"prof type matched failed, get num[%d]\",\n\t\t\taw_dev->prof_info.prof_type);\n\t\tret =  -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int aw_dev_load_cfg_by_hdr_v1(struct aw_device *aw_dev,\n\t\t\t\t\t\tstruct aw_container *aw_cfg)\n{\n\tstruct aw_cfg_hdr *cfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tint ret;\n\n\tret = aw_dev_parse_scene_count_v1(aw_dev, aw_cfg, &prof_info->count);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"get scene count failed\");\n\t\treturn ret;\n\t}\n\n\tprof_info->prof_desc = devm_kcalloc(aw_dev->dev,\n\t\t\t\t\tprof_info->count, sizeof(struct aw_prof_desc),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prof_info->prof_desc)\n\t\treturn -ENOMEM;\n\n\tret = aw_dev_parse_by_hdr_v1(aw_dev, cfg_hdr);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"parse hdr failed\");\n\t\treturn ret;\n\t}\n\n\tret = aw_dev_create_prof_name_list_v1(aw_dev);\n\tif (ret < 0) {\n\t\tdev_err(aw_dev->dev, \"create prof name list failed\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint aw88395_dev_cfg_load(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tstruct aw_cfg_hdr *cfg_hdr;\n\tint ret;\n\n\tcfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\n\tswitch (cfg_hdr->hdr_version) {\n\tcase AW88395_CFG_HDR_VER:\n\t\tret = aw_dev_load_cfg_by_hdr(aw_dev, cfg_hdr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"hdr_version[0x%x] parse failed\",\n\t\t\t\t\t\tcfg_hdr->hdr_version);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase AW88395_CFG_HDR_VER_V1:\n\t\tret = aw_dev_load_cfg_by_hdr_v1(aw_dev, aw_cfg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(aw_dev->dev, \"hdr_version[0x%x] parse failed\",\n\t\t\t\t\t\tcfg_hdr->hdr_version);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported hdr_version [0x%x]\", cfg_hdr->hdr_version);\n\t\treturn -EINVAL;\n\t}\n\taw_dev->fw_status = AW88395_DEV_FW_OK;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_cfg_load);\n\nstatic int aw_dev_check_cfg_by_hdr(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tunsigned int end_data_offset;\n\tstruct aw_cfg_hdr *cfg_hdr;\n\tstruct aw_cfg_dde *cfg_dde;\n\tunsigned int act_data = 0;\n\tunsigned int hdr_ddt_len;\n\tunsigned int i;\n\tu8 act_crc8;\n\n\tcfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\t \n\tif (cfg_hdr->id != ACF_FILE_ID) {\n\t\tdev_err(aw_dev->dev, \"not acf type file\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr_ddt_len = cfg_hdr->hdr_offset + cfg_hdr->ddt_size;\n\tif (hdr_ddt_len > aw_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"hdr_len with ddt_len [%d] overflow file size[%d]\",\n\t\tcfg_hdr->hdr_offset, aw_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcfg_dde = (struct aw_cfg_dde *)((char *)aw_cfg->data + cfg_hdr->hdr_offset);\n\tact_data += hdr_ddt_len;\n\tfor (i = 0; i < cfg_hdr->ddt_num; i++)\n\t\tact_data += cfg_dde[i].data_size;\n\n\tif (act_data != aw_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"act_data[%d] not equal to file size[%d]!\",\n\t\t\tact_data, aw_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cfg_hdr->ddt_num; i++) {\n\t\t \n\t\tend_data_offset = cfg_dde[i].data_offset + cfg_dde[i].data_size;\n\t\tif (end_data_offset > aw_cfg->len) {\n\t\t\tdev_err(aw_dev->dev, \"ddt_num[%d] end_data_offset[%d] overflow size[%d]\",\n\t\t\t\ti, end_data_offset, aw_cfg->len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tact_crc8 = crc8(aw_crc8_table, aw_cfg->data + cfg_dde[i].data_offset,\n\t\t\t\t\t\t\tcfg_dde[i].data_size, 0);\n\t\tif (act_crc8 != cfg_dde[i].data_crc) {\n\t\t\tdev_err(aw_dev->dev, \"ddt_num[%d] act_crc8:0x%x != data_crc:0x%x\",\n\t\t\t\ti, (u32)act_crc8, cfg_dde[i].data_crc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int aw_dev_check_acf_by_hdr_v1(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tstruct aw_cfg_dde_v1 *cfg_dde;\n\tunsigned int end_data_offset;\n\tstruct aw_cfg_hdr *cfg_hdr;\n\tunsigned int act_data = 0;\n\tunsigned int hdr_ddt_len;\n\tu8 act_crc8;\n\tint i;\n\n\tcfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\n\t \n\tif (cfg_hdr->id != ACF_FILE_ID) {\n\t\tdev_err(aw_dev->dev, \"not acf type file\");\n\t\treturn -EINVAL;\n\t}\n\n\thdr_ddt_len = cfg_hdr->hdr_offset + cfg_hdr->ddt_size;\n\tif (hdr_ddt_len > aw_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"hdrlen with ddt_len [%d] overflow file size[%d]\",\n\t\tcfg_hdr->hdr_offset, aw_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcfg_dde = (struct aw_cfg_dde_v1 *)((char *)aw_cfg->data + cfg_hdr->hdr_offset);\n\tact_data += hdr_ddt_len;\n\tfor (i = 0; i < cfg_hdr->ddt_num; i++)\n\t\tact_data += cfg_dde[i].data_size;\n\n\tif (act_data != aw_cfg->len) {\n\t\tdev_err(aw_dev->dev, \"act_data[%d] not equal to file size[%d]!\",\n\t\t\tact_data, aw_cfg->len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cfg_hdr->ddt_num; i++) {\n\t\t \n\t\tend_data_offset = cfg_dde[i].data_offset + cfg_dde[i].data_size;\n\t\tif (end_data_offset > aw_cfg->len) {\n\t\t\tdev_err(aw_dev->dev, \"ddt_num[%d] end_data_offset[%d] overflow size[%d]\",\n\t\t\t\ti, end_data_offset, aw_cfg->len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tact_crc8 = crc8(aw_crc8_table, aw_cfg->data + cfg_dde[i].data_offset,\n\t\t\t\t\t\t\t\t\tcfg_dde[i].data_size, 0);\n\t\tif (act_crc8 != cfg_dde[i].data_crc) {\n\t\t\tdev_err(aw_dev->dev, \"ddt_num[%d] act_crc8:0x%x != data_crc 0x%x\",\n\t\t\t\ti, (u32)act_crc8, cfg_dde[i].data_crc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint aw88395_dev_load_acf_check(struct aw_device *aw_dev, struct aw_container *aw_cfg)\n{\n\tstruct aw_cfg_hdr *cfg_hdr;\n\n\tif (!aw_cfg) {\n\t\tdev_err(aw_dev->dev, \"aw_prof is NULL\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (aw_cfg->len < sizeof(struct aw_cfg_hdr)) {\n\t\tdev_err(aw_dev->dev, \"cfg hdr size[%d] overflow file size[%d]\",\n\t\t\taw_cfg->len, (int)sizeof(struct aw_cfg_hdr));\n\t\treturn -EINVAL;\n\t}\n\n\tcrc8_populate_lsb(aw_crc8_table, AW88395_CRC8_POLYNOMIAL);\n\n\tcfg_hdr = (struct aw_cfg_hdr *)aw_cfg->data;\n\tswitch (cfg_hdr->hdr_version) {\n\tcase AW88395_CFG_HDR_VER:\n\t\treturn aw_dev_check_cfg_by_hdr(aw_dev, aw_cfg);\n\tcase AW88395_CFG_HDR_VER_V1:\n\t\treturn aw_dev_check_acf_by_hdr_v1(aw_dev, aw_cfg);\n\tdefault:\n\t\tdev_err(aw_dev->dev, \"unsupported hdr_version [0x%x]\", cfg_hdr->hdr_version);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(aw88395_dev_load_acf_check);\n\nMODULE_DESCRIPTION(\"AW88395 ACF File Parsing Lib\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}