{
  "module_name": "aw88395.c",
  "hash_id": "df47a06b9cdbb0da23455baaaec1060dfc7265a184efc2604b40f5b744d503bb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/aw88395/aw88395.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"aw88395.h\"\n#include \"aw88395_device.h\"\n#include \"aw88395_lib.h\"\n#include \"aw88395_reg.h\"\n\nstatic const struct regmap_config aw88395_remap_config = {\n\t.val_bits = 16,\n\t.reg_bits = 8,\n\t.max_register = AW88395_REG_MAX - 1,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic void aw88395_start_pa(struct aw88395 *aw88395)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < AW88395_START_RETRIES; i++) {\n\t\tret = aw88395_dev_start(aw88395->aw_pa);\n\t\tif (ret) {\n\t\t\tdev_err(aw88395->aw_pa->dev, \"aw88395 device start failed. retry = %d\", i);\n\t\t\tret = aw88395_dev_fw_update(aw88395->aw_pa, AW88395_DSP_FW_UPDATE_ON, true);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(aw88395->aw_pa->dev, \"fw update failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(aw88395->aw_pa->dev, \"start success\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void aw88395_startup_work(struct work_struct *work)\n{\n\tstruct aw88395 *aw88395 =\n\t\tcontainer_of(work, struct aw88395, start_work.work);\n\n\tmutex_lock(&aw88395->lock);\n\taw88395_start_pa(aw88395);\n\tmutex_unlock(&aw88395->lock);\n}\n\nstatic void aw88395_start(struct aw88395 *aw88395, bool sync_start)\n{\n\tint ret;\n\n\tif (aw88395->aw_pa->fw_status != AW88395_DEV_FW_OK)\n\t\treturn;\n\n\tif (aw88395->aw_pa->status == AW88395_DEV_PW_ON)\n\t\treturn;\n\n\tret = aw88395_dev_fw_update(aw88395->aw_pa, AW88395_DSP_FW_UPDATE_OFF, true);\n\tif (ret < 0) {\n\t\tdev_err(aw88395->aw_pa->dev, \"fw update failed.\");\n\t\treturn;\n\t}\n\n\tif (sync_start == AW88395_SYNC_START)\n\t\taw88395_start_pa(aw88395);\n\telse\n\t\tqueue_delayed_work(system_wq,\n\t\t\t&aw88395->start_work,\n\t\t\tAW88395_START_WORK_DELAY_MS);\n}\n\nstatic struct snd_soc_dai_driver aw88395_dai[] = {\n\t{\n\t\t.name = \"aw88395-aif\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"Speaker_Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = AW88395_RATES,\n\t\t\t.formats = AW88395_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Speaker_Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = AW88395_RATES,\n\t\t\t.formats = AW88395_FORMATS,\n\t\t},\n\t},\n};\n\nstatic int aw88395_get_fade_in_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\n\tucontrol->value.integer.value[0] = aw_dev->fade_in_time;\n\n\treturn 0;\n}\n\nstatic int aw88395_set_fade_in_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\tint time;\n\n\ttime = ucontrol->value.integer.value[0];\n\n\tif (time < mc->min || time > mc->max)\n\t\treturn -EINVAL;\n\n\tif (time != aw_dev->fade_in_time) {\n\t\taw_dev->fade_in_time = time;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88395_get_fade_out_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\n\tucontrol->value.integer.value[0] = aw_dev->fade_out_time;\n\n\treturn 0;\n}\n\nstatic int aw88395_set_fade_out_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\tint time;\n\n\ttime = ucontrol->value.integer.value[0];\n\tif (time < mc->min || time > mc->max)\n\t\treturn -EINVAL;\n\n\tif (time != aw_dev->fade_out_time) {\n\t\taw_dev->fade_out_time = time;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88395_profile_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tconst char *prof_name;\n\tchar *name;\n\tint count;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\n\tcount = aw88395_dev_get_profile_count(aw88395->aw_pa);\n\tif (count <= 0) {\n\t\tuinfo->value.enumerated.items = 0;\n\t\treturn 0;\n\t}\n\n\tuinfo->value.enumerated.items = count;\n\n\tif (uinfo->value.enumerated.item >= count)\n\t\tuinfo->value.enumerated.item = count - 1;\n\n\tname = uinfo->value.enumerated.name;\n\tcount = uinfo->value.enumerated.item;\n\n\tprof_name = aw88395_dev_get_prof_name(aw88395->aw_pa, count);\n\tif (!prof_name) {\n\t\tstrscpy(uinfo->value.enumerated.name, \"null\",\n\t\t\t\t\t\tstrlen(\"null\") + 1);\n\t\treturn 0;\n\t}\n\n\tstrscpy(name, prof_name, sizeof(uinfo->value.enumerated.name));\n\n\treturn 0;\n}\n\nstatic int aw88395_profile_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = aw88395_dev_get_profile_index(aw88395->aw_pa);\n\n\treturn 0;\n}\n\nstatic int aw88395_profile_set(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tint ret;\n\n\t \n\tmutex_lock(&aw88395->lock);\n\tret = aw88395_dev_set_profile_index(aw88395->aw_pa, ucontrol->value.integer.value[0]);\n\tif (ret < 0) {\n\t\tdev_dbg(codec->dev, \"profile index does not change\");\n\t\tmutex_unlock(&aw88395->lock);\n\t\treturn 0;\n\t}\n\n\tif (aw88395->aw_pa->status) {\n\t\taw88395_dev_stop(aw88395->aw_pa);\n\t\taw88395_start(aw88395, AW88395_SYNC_START);\n\t}\n\n\tmutex_unlock(&aw88395->lock);\n\n\treturn 1;\n}\n\nstatic int aw88395_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tstruct aw_volume_desc *vol_desc = &aw88395->aw_pa->volume_desc;\n\n\tucontrol->value.integer.value[0] = vol_desc->ctl_volume;\n\n\treturn 0;\n}\n\nstatic int aw88395_volume_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tstruct aw_volume_desc *vol_desc = &aw88395->aw_pa->volume_desc;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint value;\n\n\tvalue = ucontrol->value.integer.value[0];\n\tif (value < mc->min || value > mc->max)\n\t\treturn -EINVAL;\n\n\tif (vol_desc->ctl_volume != value) {\n\t\tvol_desc->ctl_volume = value;\n\t\taw88395_dev_set_volume(aw88395->aw_pa, vol_desc->ctl_volume);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88395_get_fade_step(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = aw88395->aw_pa->fade_step;\n\n\treturn 0;\n}\n\nstatic int aw88395_set_fade_step(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint value;\n\n\tvalue = ucontrol->value.integer.value[0];\n\tif (value < mc->min || value > mc->max)\n\t\treturn -EINVAL;\n\n\tif (aw88395->aw_pa->fade_step != value) {\n\t\taw88395->aw_pa->fade_step = value;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88395_re_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\n\tucontrol->value.integer.value[0] = aw_dev->cali_desc.cali_re;\n\n\treturn 0;\n}\n\nstatic int aw88395_re_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct aw_device *aw_dev = aw88395->aw_pa;\n\tint value;\n\n\tvalue = ucontrol->value.integer.value[0];\n\tif (value < mc->min || value > mc->max)\n\t\treturn -EINVAL;\n\n\tif (aw_dev->cali_desc.cali_re != value) {\n\t\taw_dev->cali_desc.cali_re = value;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new aw88395_controls[] = {\n\tSOC_SINGLE_EXT(\"PCM Playback Volume\", AW88395_SYSCTRL2_REG,\n\t\t6, AW88395_MUTE_VOL, 0, aw88395_volume_get,\n\t\taw88395_volume_set),\n\tSOC_SINGLE_EXT(\"Fade Step\", 0, 0, AW88395_MUTE_VOL, 0,\n\t\taw88395_get_fade_step, aw88395_set_fade_step),\n\tSOC_SINGLE_EXT(\"Volume Ramp Up Step\", 0, 0, FADE_TIME_MAX, FADE_TIME_MIN,\n\t\taw88395_get_fade_in_time, aw88395_set_fade_in_time),\n\tSOC_SINGLE_EXT(\"Volume Ramp Down Step\", 0, 0, FADE_TIME_MAX, FADE_TIME_MIN,\n\t\taw88395_get_fade_out_time, aw88395_set_fade_out_time),\n\tSOC_SINGLE_EXT(\"Calib\", 0, 0, 100, 0,\n\t\taw88395_re_get, aw88395_re_set),\n\tAW88395_PROFILE_EXT(\"Profile Set\", aw88395_profile_info,\n\t\taw88395_profile_get, aw88395_profile_set),\n};\n\nstatic int aw88395_playback_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *k, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&aw88395->lock);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\taw88395_start(aw88395, AW88395_ASYNC_START);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\taw88395_dev_stop(aw88395->aw_pa);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&aw88395->lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget aw88395_dapm_widgets[] = {\n\t  \n\tSND_SOC_DAPM_AIF_IN_E(\"AIF_RX\", \"Speaker_Playback\", 0, 0, 0, 0,\n\t\t\t\t\taw88395_playback_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"DAC Output\"),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"AIF_TX\", \"Speaker_Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_INPUT(\"ADC Input\"),\n};\n\nstatic const struct snd_soc_dapm_route aw88395_audio_map[] = {\n\t{\"DAC Output\", NULL, \"AIF_RX\"},\n\t{\"AIF_TX\", NULL, \"ADC Input\"},\n};\n\nstatic int aw88395_codec_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tINIT_DELAYED_WORK(&aw88395->start_work, aw88395_startup_work);\n\n\t \n\tret = snd_soc_dapm_new_controls(dapm, aw88395_dapm_widgets,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88395_dapm_widgets));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dapm_add_routes(dapm, aw88395_audio_map,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88395_audio_map));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_add_component_controls(component, aw88395_controls,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88395_controls));\n\n\treturn ret;\n}\n\nstatic void aw88395_codec_remove(struct snd_soc_component *aw_codec)\n{\n\tstruct aw88395 *aw88395 = snd_soc_component_get_drvdata(aw_codec);\n\n\tcancel_delayed_work_sync(&aw88395->start_work);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_aw88395 = {\n\t.probe = aw88395_codec_probe,\n\t.remove = aw88395_codec_remove,\n};\n\nstatic struct aw88395 *aw88395_malloc_init(struct i2c_client *i2c)\n{\n\tstruct aw88395 *aw88395 = devm_kzalloc(&i2c->dev,\n\t\t\tsizeof(struct aw88395), GFP_KERNEL);\n\tif (!aw88395)\n\t\treturn NULL;\n\n\tmutex_init(&aw88395->lock);\n\n\treturn aw88395;\n}\n\nstatic void aw88395_hw_reset(struct aw88395 *aw88395)\n{\n\tif (aw88395->reset_gpio) {\n\t\tgpiod_set_value_cansleep(aw88395->reset_gpio, 0);\n\t\tusleep_range(AW88395_1000_US, AW88395_1000_US + 10);\n\t\tgpiod_set_value_cansleep(aw88395->reset_gpio, 1);\n\t\tusleep_range(AW88395_1000_US, AW88395_1000_US + 10);\n\t} else {\n\t\tdev_err(aw88395->aw_pa->dev, \"%s failed\", __func__);\n\t}\n}\n\nstatic int aw88395_request_firmware_file(struct aw88395 *aw88395)\n{\n\tconst struct firmware *cont = NULL;\n\tint ret;\n\n\taw88395->aw_pa->fw_status = AW88395_DEV_FW_FAILED;\n\n\tret = request_firmware(&cont, AW88395_ACF_FILE, aw88395->aw_pa->dev);\n\tif ((ret < 0) || (!cont)) {\n\t\tdev_err(aw88395->aw_pa->dev, \"load [%s] failed!\", AW88395_ACF_FILE);\n\t\treturn ret;\n\t}\n\n\tdev_info(aw88395->aw_pa->dev, \"loaded %s - size: %zu\\n\",\n\t\t\tAW88395_ACF_FILE, cont ? cont->size : 0);\n\n\taw88395->aw_cfg = devm_kzalloc(aw88395->aw_pa->dev, cont->size + sizeof(int), GFP_KERNEL);\n\tif (!aw88395->aw_cfg) {\n\t\trelease_firmware(cont);\n\t\treturn -ENOMEM;\n\t}\n\taw88395->aw_cfg->len = (int)cont->size;\n\tmemcpy(aw88395->aw_cfg->data, cont->data, cont->size);\n\trelease_firmware(cont);\n\n\tret = aw88395_dev_load_acf_check(aw88395->aw_pa, aw88395->aw_cfg);\n\tif (ret < 0) {\n\t\tdev_err(aw88395->aw_pa->dev, \"Load [%s] failed ....!\", AW88395_ACF_FILE);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(aw88395->aw_pa->dev, \"%s : bin load success\\n\", __func__);\n\n\tmutex_lock(&aw88395->lock);\n\t \n\tret = aw88395_dev_init(aw88395->aw_pa, aw88395->aw_cfg);\n\tif (ret < 0)\n\t\tdev_err(aw88395->aw_pa->dev, \"dev init failed\");\n\tmutex_unlock(&aw88395->lock);\n\n\treturn ret;\n}\n\nstatic int aw88395_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct aw88395 *aw88395;\n\tint ret;\n\n\tif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C)) {\n\t\tdev_err(&i2c->dev, \"check_functionality failed\");\n\t\treturn -EIO;\n\t}\n\n\taw88395 = aw88395_malloc_init(i2c);\n\tif (!aw88395) {\n\t\tdev_err(&i2c->dev, \"malloc aw88395 failed\");\n\t\treturn -ENOMEM;\n\t}\n\ti2c_set_clientdata(i2c, aw88395);\n\n\taw88395->reset_gpio = devm_gpiod_get_optional(&i2c->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(aw88395->reset_gpio))\n\t\tdev_info(&i2c->dev, \"reset gpio not defined\\n\");\n\n\t \n\taw88395_hw_reset(aw88395);\n\n\taw88395->regmap = devm_regmap_init_i2c(i2c, &aw88395_remap_config);\n\tif (IS_ERR(aw88395->regmap)) {\n\t\tret = PTR_ERR(aw88395->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = aw88395_init(&aw88395->aw_pa, i2c, aw88395->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = aw88395_request_firmware_file(aw88395);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"%s failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_codec_dev_aw88395,\n\t\t\taw88395_dai, ARRAY_SIZE(aw88395_dai));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"failed to register aw88395: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id aw88395_i2c_id[] = {\n\t{ AW88395_I2C_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, aw88395_i2c_id);\n\nstatic struct i2c_driver aw88395_i2c_driver = {\n\t.driver = {\n\t\t.name = AW88395_I2C_NAME,\n\t},\n\t.probe = aw88395_i2c_probe,\n\t.id_table = aw88395_i2c_id,\n};\nmodule_i2c_driver(aw88395_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC AW88395 Smart PA Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}