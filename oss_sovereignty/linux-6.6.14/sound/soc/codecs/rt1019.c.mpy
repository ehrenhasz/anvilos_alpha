{
  "module_name": "rt1019.c",
  "hash_id": "2400f3ad5119e98211b9ba449755769d23c7c592a0b80ed1b466a15af7b318e1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1019.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rl6231.h\"\n#include \"rt1019.h\"\n\nstatic const struct reg_default rt1019_reg[] = {\n\t{ 0x0000, 0x00 },\n\t{ 0x0011, 0x04 },\n\t{ 0x0013, 0x00 },\n\t{ 0x0019, 0x30 },\n\t{ 0x001b, 0x01 },\n\t{ 0x005c, 0x00 },\n\t{ 0x005e, 0x10 },\n\t{ 0x005f, 0xec },\n\t{ 0x0061, 0x10 },\n\t{ 0x0062, 0x19 },\n\t{ 0x0066, 0x08 },\n\t{ 0x0100, 0x80 },\n\t{ 0x0100, 0x51 },\n\t{ 0x0102, 0x23 },\n\t{ 0x0311, 0x00 },\n\t{ 0x0312, 0x3e },\n\t{ 0x0313, 0x86 },\n\t{ 0x0400, 0x03 },\n\t{ 0x0401, 0x02 },\n\t{ 0x0402, 0x01 },\n\t{ 0x0504, 0xff },\n\t{ 0x0505, 0x24 },\n\t{ 0x0b00, 0x50 },\n\t{ 0x0b01, 0xc3 },\n};\n\nstatic bool rt1019_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1019_PWR_STRP_2:\n\tcase RT1019_VER_ID:\n\tcase RT1019_VEND_ID_1:\n\tcase RT1019_VEND_ID_2:\n\tcase RT1019_DEV_ID_1:\n\tcase RT1019_DEV_ID_2:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1019_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1019_RESET:\n\tcase RT1019_IDS_CTRL:\n\tcase RT1019_ASEL_CTRL:\n\tcase RT1019_PWR_STRP_2:\n\tcase RT1019_BEEP_TONE:\n\tcase RT1019_VER_ID:\n\tcase RT1019_VEND_ID_1:\n\tcase RT1019_VEND_ID_2:\n\tcase RT1019_DEV_ID_1:\n\tcase RT1019_DEV_ID_2:\n\tcase RT1019_SDB_CTRL:\n\tcase RT1019_CLK_TREE_1:\n\tcase RT1019_CLK_TREE_2:\n\tcase RT1019_CLK_TREE_3:\n\tcase RT1019_PLL_1:\n\tcase RT1019_PLL_2:\n\tcase RT1019_PLL_3:\n\tcase RT1019_TDM_1:\n\tcase RT1019_TDM_2:\n\tcase RT1019_TDM_3:\n\tcase RT1019_DMIX_MONO_1:\n\tcase RT1019_DMIX_MONO_2:\n\tcase RT1019_BEEP_1:\n\tcase RT1019_BEEP_2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9525, 75, 0);\n\nstatic const char * const rt1019_din_source_select[] = {\n\t\"Left\",\n\t\"Right\",\n\t\"Left + Right average\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1019_mono_lr_sel, RT1019_IDS_CTRL, 0,\n\trt1019_din_source_select);\n\nstatic const struct snd_kcontrol_new rt1019_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"DAC Playback Volume\", RT1019_DMIX_MONO_1, 0,\n\t\t127, 0, dac_vol_tlv),\n\tSOC_ENUM(\"Mono LR Select\", rt1019_mono_lr_sel),\n};\n\nstatic int r1019_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_write(component, RT1019_SDB_CTRL, 0xb);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_write(component, RT1019_SDB_CTRL, 0xa);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt1019_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"AIF Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0,\n\t\tr1019_dac_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"SPO\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1019_dapm_routes[] = {\n\t{ \"DAC\", NULL, \"AIFRX\" },\n\t{ \"SPO\", NULL, \"DAC\" },\n};\n\nstatic int rt1019_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1019_priv *rt1019 = snd_soc_component_get_drvdata(component);\n\tint pre_div, bclk_ms, frame_size;\n\tunsigned int val_len = 0, sys_div_da_filter = 0;\n\tunsigned int sys_dac_osr = 0, sys_fifo_clk = 0;\n\tunsigned int sys_clk_cal = 0, sys_asrc_in = 0;\n\n\trt1019->lrck = params_rate(params);\n\tpre_div = rl6231_get_clk_info(rt1019->sysclk, rt1019->lrck);\n\tif (pre_div < 0) {\n\t\tdev_err(component->dev, \"Unsupported clock setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0) {\n\t\tdev_err(component->dev, \"Unsupported frame size: %d\\n\", frame_size);\n\t\treturn -EINVAL;\n\t}\n\n\tbclk_ms = frame_size > 32;\n\trt1019->bclk = rt1019->lrck * (32 << bclk_ms);\n\n\tdev_dbg(dai->dev, \"bclk is %dHz and lrck is %dHz\\n\",\n\t\trt1019->bclk, rt1019->lrck);\n\tdev_dbg(dai->dev, \"bclk_ms is %d and pre_div is %d for iis %d\\n\",\n\t\t\t\tbclk_ms, pre_div, dai->id);\n\n\tswitch (pre_div) {\n\tcase 0:\n\t\tsys_div_da_filter = RT1019_SYS_DIV_DA_FIL_DIV1;\n\t\tsys_dac_osr = RT1019_SYS_DA_OSR_DIV1;\n\t\tsys_asrc_in = RT1019_ASRC_256FS_DIV1;\n\t\tsys_fifo_clk = RT1019_SEL_FIFO_DIV1;\n\t\tsys_clk_cal = RT1019_SEL_CLK_CAL_DIV1;\n\t\tbreak;\n\tcase 1:\n\t\tsys_div_da_filter = RT1019_SYS_DIV_DA_FIL_DIV2;\n\t\tsys_dac_osr = RT1019_SYS_DA_OSR_DIV2;\n\t\tsys_asrc_in = RT1019_ASRC_256FS_DIV2;\n\t\tsys_fifo_clk = RT1019_SEL_FIFO_DIV2;\n\t\tsys_clk_cal = RT1019_SEL_CLK_CAL_DIV2;\n\t\tbreak;\n\tcase 3:\n\t\tsys_div_da_filter = RT1019_SYS_DIV_DA_FIL_DIV4;\n\t\tsys_dac_osr = RT1019_SYS_DA_OSR_DIV4;\n\t\tsys_asrc_in = RT1019_ASRC_256FS_DIV4;\n\t\tsys_fifo_clk = RT1019_SEL_FIFO_DIV4;\n\t\tsys_clk_cal = RT1019_SEL_CLK_CAL_DIV4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tval_len = RT1019_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len = RT1019_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len = RT1019_I2S_DL_32;\n\t\tbreak;\n\tcase 8:\n\t\tval_len = RT1019_I2S_DL_8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1019_TDM_2, RT1019_I2S_DL_MASK,\n\t\t\tval_len);\n\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_1,\n\t\t\tRT1019_SEL_FIFO_MASK, sys_fifo_clk);\n\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_2,\n\t\t\tRT1019_SYS_DIV_DA_FIL_MASK | RT1019_SYS_DA_OSR_MASK |\n\t\t\tRT1019_ASRC_256FS_MASK, sys_div_da_filter | sys_dac_osr |\n\t\t\tsys_asrc_in);\n\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_3,\n\t\t\tRT1019_SEL_CLK_CAL_MASK, sys_clk_cal);\n\n\treturn 0;\n}\n\nstatic int rt1019_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int reg_val = 0, reg_val2 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg_val2 |= RT1019_TDM_BCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg_val |= RT1019_I2S_DF_LEFT;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg_val |= RT1019_I2S_DF_PCM_A_R;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\treg_val |= RT1019_I2S_DF_PCM_B_R;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1019_TDM_2,\n\t\tRT1019_I2S_DF_MASK, reg_val);\n\tsnd_soc_component_update_bits(component, RT1019_TDM_1,\n\t\tRT1019_TDM_BCLK_MASK, reg_val2);\n\n\treturn 0;\n}\n\nstatic int rt1019_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1019_priv *rt1019 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tif (freq == rt1019->sysclk && clk_id == rt1019->sysclk_src)\n\t\treturn 0;\n\n\tswitch (clk_id) {\n\tcase RT1019_SCLK_S_BCLK:\n\t\treg_val |= RT1019_CLK_SYS_PRE_SEL_BCLK;\n\t\tbreak;\n\n\tcase RT1019_SCLK_S_PLL:\n\t\treg_val |= RT1019_CLK_SYS_PRE_SEL_PLL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\trt1019->sysclk = freq;\n\trt1019->sysclk_src = clk_id;\n\n\tdev_dbg(dai->dev, \"Sysclk is %dHz and clock id is %d\\n\", freq, clk_id);\n\n\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_1,\n\t\tRT1019_CLK_SYS_PRE_SEL_MASK, reg_val);\n\n\treturn 0;\n}\n\nstatic int rt1019_set_dai_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1019_priv *rt1019 = snd_soc_component_get_drvdata(component);\n\tstruct rl6231_pll_code pll_code;\n\tint ret;\n\n\tif (!freq_in || !freq_out) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\t\trt1019->pll_in = 0;\n\t\trt1019->pll_out = 0;\n\t\treturn 0;\n\t}\n\n\tif (source == rt1019->pll_src && freq_in == rt1019->pll_in &&\n\t\tfreq_out == rt1019->pll_out)\n\t\treturn 0;\n\n\tswitch (source) {\n\tcase RT1019_PLL_S_BCLK:\n\t\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_1,\n\t\t\tRT1019_PLL_SRC_MASK, RT1019_PLL_SRC_SEL_BCLK);\n\t\tbreak;\n\n\tcase RT1019_PLL_S_RC25M:\n\t\tsnd_soc_component_update_bits(component, RT1019_CLK_TREE_1,\n\t\t\tRT1019_PLL_SRC_MASK, RT1019_PLL_SRC_SEL_RC);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown PLL source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"bypass=%d m=%d n=%d k=%d\\n\",\n\t\tpll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\n\t\tpll_code.n_code, pll_code.k_code);\n\n\tsnd_soc_component_update_bits(component, RT1019_PWR_STRP_2,\n\t\tRT1019_AUTO_BITS_SEL_MASK | RT1019_AUTO_CLK_SEL_MASK,\n\t\tRT1019_AUTO_BITS_SEL_MANU | RT1019_AUTO_CLK_SEL_MANU);\n\tsnd_soc_component_update_bits(component, RT1019_PLL_1,\n\t\tRT1019_PLL_M_MASK | RT1019_PLL_M_BP_MASK | RT1019_PLL_Q_8_8_MASK,\n\t\t((pll_code.m_bp ? 0 : pll_code.m_code) << RT1019_PLL_M_SFT) |\n\t\t(pll_code.m_bp << RT1019_PLL_M_BP_SFT) |\n\t\t((pll_code.n_code >> 8) & RT1019_PLL_Q_8_8_MASK));\n\tsnd_soc_component_update_bits(component, RT1019_PLL_2,\n\t\tRT1019_PLL_Q_7_0_MASK, pll_code.n_code & RT1019_PLL_Q_7_0_MASK);\n\tsnd_soc_component_update_bits(component, RT1019_PLL_3,\n\t\tRT1019_PLL_K_MASK, pll_code.k_code);\n\n\trt1019->pll_in = freq_in;\n\trt1019->pll_out = freq_out;\n\trt1019->pll_src = source;\n\n\treturn 0;\n}\n\nstatic int rt1019_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int cn = 0, cl = 0, rx_slotnum;\n\tint ret = 0, first_bit;\n\n\tswitch (slots) {\n\tcase 4:\n\t\tcn = RT1019_I2S_TX_4CH;\n\t\tbreak;\n\tcase 6:\n\t\tcn = RT1019_I2S_TX_6CH;\n\t\tbreak;\n\tcase 8:\n\t\tcn = RT1019_I2S_TX_8CH;\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slot_width) {\n\tcase 20:\n\t\tcl = RT1019_TDM_CL_20;\n\t\tbreak;\n\tcase 24:\n\t\tcl = RT1019_TDM_CL_24;\n\t\tbreak;\n\tcase 32:\n\t\tcl = RT1019_TDM_CL_32;\n\t\tbreak;\n\tcase 8:\n\t\tcl = RT1019_TDM_CL_8;\n\t\tbreak;\n\tcase 16:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\trx_slotnum = hweight_long(rx_mask);\n\tif (rx_slotnum != 1) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"too many rx slots or zero slot\\n\");\n\t\tgoto _set_tdm_err_;\n\t}\n\t \n\tfirst_bit = __ffs(rx_mask);\n\tswitch (first_bit) {\n\tcase 0:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1019_TDM_3,\n\t\t\tRT1019_TDM_I2S_TX_L_DAC1_1_MASK |\n\t\t\tRT1019_TDM_I2S_TX_R_DAC1_1_MASK,\n\t\t\t(first_bit << RT1019_TDM_I2S_TX_L_DAC1_1_SFT) |\n\t\t\t((first_bit + 1) << RT1019_TDM_I2S_TX_R_DAC1_1_SFT));\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\tcase 5:\n\tcase 7:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1019_TDM_3,\n\t\t\tRT1019_TDM_I2S_TX_L_DAC1_1_MASK |\n\t\t\tRT1019_TDM_I2S_TX_R_DAC1_1_MASK,\n\t\t\t((first_bit - 1) << RT1019_TDM_I2S_TX_L_DAC1_1_SFT) |\n\t\t\t(first_bit << RT1019_TDM_I2S_TX_R_DAC1_1_SFT));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto _set_tdm_err_;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1019_TDM_1,\n\t\tRT1019_TDM_CL_MASK, cl);\n\tsnd_soc_component_update_bits(component, RT1019_TDM_2,\n\t\tRT1019_I2S_CH_TX_MASK, cn);\n\n_set_tdm_err_:\n\treturn ret;\n}\n\nstatic int rt1019_probe(struct snd_soc_component *component)\n{\n\tstruct rt1019_priv *rt1019 = snd_soc_component_get_drvdata(component);\n\n\trt1019->component = component;\n\tsnd_soc_component_write(component, RT1019_SDB_CTRL, 0xa);\n\n\treturn 0;\n}\n\n#define RT1019_STEREO_RATES SNDRV_PCM_RATE_8000_192000\n#define RT1019_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt1019_aif_dai_ops = {\n\t.hw_params = rt1019_hw_params,\n\t.set_fmt = rt1019_set_dai_fmt,\n\t.set_sysclk = rt1019_set_dai_sysclk,\n\t.set_pll = rt1019_set_dai_pll,\n\t.set_tdm_slot = rt1019_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver rt1019_dai[] = {\n\t{\n\t\t.name = \"rt1019-aif\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1019_STEREO_RATES,\n\t\t\t.formats = RT1019_FORMATS,\n\t\t},\n\t\t.ops = &rt1019_aif_dai_ops,\n\t}\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt1019 = {\n\t.probe\t\t\t= rt1019_probe,\n\t.controls\t\t= rt1019_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(rt1019_snd_controls),\n\t.dapm_widgets\t\t= rt1019_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(rt1019_dapm_widgets),\n\t.dapm_routes\t\t= rt1019_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(rt1019_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt1019_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.max_register = RT1019_BEEP_2,\n\t.volatile_reg = rt1019_volatile_register,\n\t.readable_reg = rt1019_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = rt1019_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt1019_reg),\n};\n\nstatic const struct i2c_device_id rt1019_i2c_id[] = {\n\t{ \"rt1019\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1019_i2c_id);\n\nstatic const struct of_device_id rt1019_of_match[] __maybe_unused = {\n\t{ .compatible = \"realtek,rt1019\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt1019_of_match);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt1019_acpi_match[] = {\n\t{ \"10EC1019\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, rt1019_acpi_match);\n#endif\n\nstatic int rt1019_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt1019_priv *rt1019;\n\tint ret;\n\tunsigned int val, val2, dev_id;\n\n\trt1019 = devm_kzalloc(&i2c->dev, sizeof(struct rt1019_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (!rt1019)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt1019);\n\n\trt1019->regmap = devm_regmap_init_i2c(i2c, &rt1019_regmap);\n\tif (IS_ERR(rt1019->regmap)) {\n\t\tret = PTR_ERR(rt1019->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt1019->regmap, RT1019_DEV_ID_1, &val);\n\tregmap_read(rt1019->regmap, RT1019_DEV_ID_2, &val2);\n\tdev_id = val << 8 | val2;\n\tif (dev_id != RT1019_DEVICE_ID_VAL && dev_id != RT1019_DEVICE_ID_VAL2) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register 0x%x is not rt1019\\n\", dev_id);\n\t\treturn -ENODEV;\n\t}\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t&soc_component_dev_rt1019, rt1019_dai, ARRAY_SIZE(rt1019_dai));\n}\n\nstatic struct i2c_driver rt1019_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1019\",\n\t\t.of_match_table = of_match_ptr(rt1019_of_match),\n\t\t.acpi_match_table = ACPI_PTR(rt1019_acpi_match),\n\t},\n\t.probe = rt1019_i2c_probe,\n\t.id_table = rt1019_i2c_id,\n};\nmodule_i2c_driver(rt1019_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1019 driver\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}