{
  "module_name": "adau1372.c",
  "hash_id": "8ce729ba7407cda79eb8df108b554450dd05f84c398d56ab0e6b794ece010deb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau1372.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/soc.h>\n\n#include \"adau1372.h\"\n#include \"adau-utils.h\"\n\nstruct adau1372 {\n\tstruct regmap *regmap;\n\tvoid (*switch_mode)(struct device *dev);\n\tbool use_pll;\n\tbool enabled;\n\tbool clock_provider;\n\n\tstruct snd_pcm_hw_constraint_list rate_constraints;\n\tunsigned int slot_width;\n\n\tstruct clk *mclk;\n\tstruct gpio_desc *pd_gpio;\n\tstruct device *dev;\n};\n\n#define ADAU1372_REG_CLK_CTRL\t\t0x00\n#define ADAU1372_REG_PLL(x)\t\t(0x01 + (x))\n#define ADAU1372_REG_DAC_SOURCE\t\t0x11\n#define ADAU1372_REG_SOUT_SOURCE_0_1\t0x13\n#define ADAU1372_REG_SOUT_SOURCE_2_3\t0x14\n#define ADAU1372_REG_SOUT_SOURCE_4_5\t0x15\n#define ADAU1372_REG_SOUT_SOURCE_6_7\t0x16\n#define ADAU1372_REG_ADC_SDATA_CH\t0x17\n#define ADAU1372_REG_ASRCO_SOURCE_0_1\t0x18\n#define ADAU1372_REG_ASRCO_SOURCE_2_3\t0x19\n#define ADAU1372_REG_ASRC_MODE\t\t0x1a\n#define ADAU1372_REG_ADC_CTRL0\t\t0x1b\n#define ADAU1372_REG_ADC_CTRL1\t\t0x1c\n#define ADAU1372_REG_ADC_CTRL2\t\t0x1d\n#define ADAU1372_REG_ADC_CTRL3\t\t0x1e\n#define ADAU1372_REG_ADC_VOL(x)\t\t(0x1f + (x))\n#define ADAU1372_REG_PGA_CTRL(x)\t(0x23 + (x))\n#define ADAU1372_REG_PGA_BOOST\t\t0x28\n#define ADAU1372_REG_MICBIAS\t\t0x2d\n#define ADAU1372_REG_DAC_CTRL\t\t0x2e\n#define ADAU1372_REG_DAC_VOL(x)\t\t(0x2f + (x))\n#define ADAU1372_REG_OP_STAGE_MUTE\t0x31\n#define ADAU1372_REG_SAI0\t\t0x32\n#define ADAU1372_REG_SAI1\t\t0x33\n#define ADAU1372_REG_SOUT_CTRL\t\t0x34\n#define ADAU1372_REG_MODE_MP(x)\t\t(0x38 + (x))\n#define ADAU1372_REG_OP_STAGE_CTRL\t0x43\n#define ADAU1372_REG_DECIM_PWR\t\t0x44\n#define ADAU1372_REG_INTERP_PWR\t\t0x45\n#define ADAU1372_REG_BIAS_CTRL0\t\t0x46\n#define ADAU1372_REG_BIAS_CTRL1\t\t0x47\n\n#define ADAU1372_CLK_CTRL_PLL_EN\tBIT(7)\n#define ADAU1372_CLK_CTRL_XTAL_DIS\tBIT(4)\n#define ADAU1372_CLK_CTRL_CLKSRC\tBIT(3)\n#define ADAU1372_CLK_CTRL_CC_MDIV\tBIT(1)\n#define ADAU1372_CLK_CTRL_MCLK_EN\tBIT(0)\n\n#define ADAU1372_SAI0_DELAY1\t\t(0x0 << 6)\n#define ADAU1372_SAI0_DELAY0\t\t(0x1 << 6)\n#define ADAU1372_SAI0_DELAY_MASK\t(0x3 << 6)\n#define ADAU1372_SAI0_SAI_I2S\t\t(0x0 << 4)\n#define ADAU1372_SAI0_SAI_TDM2\t\t(0x1 << 4)\n#define ADAU1372_SAI0_SAI_TDM4\t\t(0x2 << 4)\n#define ADAU1372_SAI0_SAI_TDM8\t\t(0x3 << 4)\n#define ADAU1372_SAI0_SAI_MASK\t\t(0x3 << 4)\n#define ADAU1372_SAI0_FS_48\t\t0x0\n#define ADAU1372_SAI0_FS_8\t\t0x1\n#define ADAU1372_SAI0_FS_12\t\t0x2\n#define ADAU1372_SAI0_FS_16\t\t0x3\n#define ADAU1372_SAI0_FS_24\t\t0x4\n#define ADAU1372_SAI0_FS_32\t\t0x5\n#define ADAU1372_SAI0_FS_96\t\t0x6\n#define ADAU1372_SAI0_FS_192\t\t0x7\n#define ADAU1372_SAI0_FS_MASK\t\t0xf\n\n#define ADAU1372_SAI1_TDM_TS\t\tBIT(7)\n#define ADAU1372_SAI1_BCLK_TDMC\t\tBIT(6)\n#define ADAU1372_SAI1_LR_MODE\t\tBIT(5)\n#define ADAU1372_SAI1_LR_POL\t\tBIT(4)\n#define ADAU1372_SAI1_BCLKRATE\t\tBIT(2)\n#define ADAU1372_SAI1_BCLKEDGE\t\tBIT(1)\n#define ADAU1372_SAI1_MS\t\tBIT(0)\n\nstatic const unsigned int adau1372_rates[] = {\n\t[ADAU1372_SAI0_FS_8] = 8000,\n\t[ADAU1372_SAI0_FS_12] = 12000,\n\t[ADAU1372_SAI0_FS_16] = 16000,\n\t[ADAU1372_SAI0_FS_24] = 24000,\n\t[ADAU1372_SAI0_FS_32] = 32000,\n\t[ADAU1372_SAI0_FS_48] = 48000,\n\t[ADAU1372_SAI0_FS_96] = 96000,\n\t[ADAU1372_SAI0_FS_192] = 192000,\n};\n\n \n#define ADAU1372_RATE_MASK_TDM8 0x17\n \n#define ADAU1372_RATE_MASK_TDM4_MASTER (ADAU1372_RATE_MASK_TDM8 | 0x48 | 0x20)\n \n#define ADAU1372_RATE_MASK_TDM4 (ADAU1372_RATE_MASK_TDM4_MASTER | 0x20)\n \n#define ADAU1372_RATE_MASK_TDM2 (ADAU1372_RATE_MASK_TDM4 | 0x80)\n\nstatic const DECLARE_TLV_DB_MINMAX(adau1372_digital_tlv, -9563, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1372_pga_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(adau1372_pga_boost_tlv, 0, 1000, 0);\n\nstatic const char * const adau1372_bias_text[] = {\n\t\"Normal operation\", \"Extreme power saving\", \"Enhanced performance\",\n\t\"Power saving\",\n};\n\nstatic const unsigned int adau1372_bias_adc_values[] = {\n\t0, 2, 3,\n};\n\nstatic const char * const adau1372_bias_adc_text[] = {\n\t\"Normal operation\", \"Enhanced performance\", \"Power saving\",\n};\n\nstatic const char * const adau1372_bias_dac_text[] = {\n\t\"Normal operation\", \"Power saving\", \"Superior performance\",\n\t\"Enhanced performance\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1372_bias_hp_enum,\n\tADAU1372_REG_BIAS_CTRL0, 6, adau1372_bias_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1372_bias_afe0_1_enum,\n\tADAU1372_REG_BIAS_CTRL0, 4, adau1372_bias_text);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_bias_adc2_3_enum,\n\tADAU1372_REG_BIAS_CTRL0, 2, 0x3, adau1372_bias_adc_text,\n\tadau1372_bias_adc_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_bias_adc0_1_enum,\n\tADAU1372_REG_BIAS_CTRL0, 0, 0x3, adau1372_bias_adc_text,\n\tadau1372_bias_adc_values);\nstatic SOC_ENUM_SINGLE_DECL(adau1372_bias_afe2_3_enum,\n\tADAU1372_REG_BIAS_CTRL1, 4, adau1372_bias_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1372_bias_mic_enum,\n\tADAU1372_REG_BIAS_CTRL1, 2, adau1372_bias_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1372_bias_dac_enum,\n\tADAU1372_REG_BIAS_CTRL1, 0, adau1372_bias_dac_text);\n\nstatic const char * const adau1372_hpf_text[] = {\n\t\"Off\",\n\t\"1 Hz\",\n\t\"4 Hz\",\n\t\"8 Hz\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1372_hpf0_1_enum, ADAU1372_REG_ADC_CTRL2, 5,\n\t\t\t    adau1372_hpf_text);\nstatic SOC_ENUM_SINGLE_DECL(adau1372_hpf2_3_enum, ADAU1372_REG_ADC_CTRL3, 5,\n\t\t\t    adau1372_hpf_text);\nstatic const struct snd_kcontrol_new adau1372_controls[] = {\n\tSOC_SINGLE_TLV(\"ADC 0 Capture Volume\", ADAU1372_REG_ADC_VOL(0),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE_TLV(\"ADC 1 Capture Volume\", ADAU1372_REG_ADC_VOL(1),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE_TLV(\"ADC 2 Capture Volume\", ADAU1372_REG_ADC_VOL(2),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE_TLV(\"ADC 3 Capture Volume\", ADAU1372_REG_ADC_VOL(3),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE(\"ADC 0 Capture Switch\", ADAU1372_REG_ADC_CTRL0, 3, 1, 1),\n\tSOC_SINGLE(\"ADC 1 Capture Switch\", ADAU1372_REG_ADC_CTRL0, 4, 1, 1),\n\tSOC_SINGLE(\"ADC 2 Capture Switch\", ADAU1372_REG_ADC_CTRL1, 3, 1, 1),\n\tSOC_SINGLE(\"ADC 3 Capture Switch\", ADAU1372_REG_ADC_CTRL1, 4, 1, 1),\n\n\tSOC_ENUM(\"ADC 0+1 High-Pass-Filter\", adau1372_hpf0_1_enum),\n\tSOC_ENUM(\"ADC 2+3 High-Pass-Filter\", adau1372_hpf2_3_enum),\n\n\tSOC_SINGLE_TLV(\"PGA 0 Capture Volume\", ADAU1372_REG_PGA_CTRL(0),\n\t\t       0, 0x3f, 0, adau1372_pga_tlv),\n\tSOC_SINGLE_TLV(\"PGA 1 Capture Volume\", ADAU1372_REG_PGA_CTRL(1),\n\t\t       0, 0x3f, 0, adau1372_pga_tlv),\n\tSOC_SINGLE_TLV(\"PGA 2 Capture Volume\", ADAU1372_REG_PGA_CTRL(2),\n\t\t       0, 0x3f, 0, adau1372_pga_tlv),\n\tSOC_SINGLE_TLV(\"PGA 3 Capture Volume\", ADAU1372_REG_PGA_CTRL(3),\n\t\t       0, 0x3f, 0, adau1372_pga_tlv),\n\tSOC_SINGLE_TLV(\"PGA 0 Boost Capture Volume\", ADAU1372_REG_PGA_BOOST,\n\t\t       0, 1, 0, adau1372_pga_boost_tlv),\n\tSOC_SINGLE_TLV(\"PGA 1 Boost Capture Volume\", ADAU1372_REG_PGA_BOOST,\n\t\t       1, 1, 0, adau1372_pga_boost_tlv),\n\tSOC_SINGLE_TLV(\"PGA 2 Boost Capture Volume\", ADAU1372_REG_PGA_BOOST,\n\t\t       2, 1, 0, adau1372_pga_boost_tlv),\n\tSOC_SINGLE_TLV(\"PGA 3 Boost Capture Volume\", ADAU1372_REG_PGA_BOOST,\n\t\t       3, 1, 0, adau1372_pga_boost_tlv),\n\tSOC_SINGLE(\"PGA 0 Capture Switch\", ADAU1372_REG_PGA_CTRL(0), 7, 1, 0),\n\tSOC_SINGLE(\"PGA 1 Capture Switch\", ADAU1372_REG_PGA_CTRL(1), 7, 1, 0),\n\tSOC_SINGLE(\"PGA 2 Capture Switch\", ADAU1372_REG_PGA_CTRL(2), 7, 1, 0),\n\tSOC_SINGLE(\"PGA 3 Capture Switch\", ADAU1372_REG_PGA_CTRL(3), 7, 1, 0),\n\n\tSOC_SINGLE_TLV(\"DAC 0 Playback Volume\", ADAU1372_REG_DAC_VOL(0),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE_TLV(\"DAC 1 Playback Volume\", ADAU1372_REG_DAC_VOL(1),\n\t\t       0, 0xff, 1, adau1372_digital_tlv),\n\tSOC_SINGLE(\"DAC 0 Playback Switch\", ADAU1372_REG_DAC_CTRL, 3, 1, 1),\n\tSOC_SINGLE(\"DAC 1 Playback Switch\", ADAU1372_REG_DAC_CTRL, 4, 1, 1),\n\n\tSOC_ENUM(\"Headphone Bias\", adau1372_bias_hp_enum),\n\tSOC_ENUM(\"Microphone Bias\", adau1372_bias_mic_enum),\n\tSOC_ENUM(\"AFE 0+1 Bias\", adau1372_bias_afe0_1_enum),\n\tSOC_ENUM(\"AFE 2+3 Bias\", adau1372_bias_afe2_3_enum),\n\tSOC_ENUM(\"ADC 0+1 Bias\", adau1372_bias_adc0_1_enum),\n\tSOC_ENUM(\"ADC 2+3 Bias\", adau1372_bias_adc2_3_enum),\n\tSOC_ENUM(\"DAC 0+1 Bias\", adau1372_bias_dac_enum),\n};\n\nstatic const char * const adau1372_decimator_mux_text[] = {\n\t\"ADC\",\n\t\"DMIC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1372_decimator0_1_mux_enum, ADAU1372_REG_ADC_CTRL2,\n\t\t\t    2, adau1372_decimator_mux_text);\n\nstatic const struct snd_kcontrol_new adau1372_decimator0_1_mux_control =\n\tSOC_DAPM_ENUM(\"Decimator 0+1 Capture Mux\", adau1372_decimator0_1_mux_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(adau1372_decimator2_3_mux_enum, ADAU1372_REG_ADC_CTRL3,\n\t\t\t    2, adau1372_decimator_mux_text);\n\nstatic const struct snd_kcontrol_new adau1372_decimator2_3_mux_control =\n\tSOC_DAPM_ENUM(\"Decimator 2+3 Capture Mux\", adau1372_decimator2_3_mux_enum);\n\nstatic const unsigned int adau1372_asrco_mux_values[] = {\n\t4, 5, 6, 7,\n};\n\nstatic const char * const adau1372_asrco_mux_text[] = {\n\t\"Decimator0\",\n\t\"Decimator1\",\n\t\"Decimator2\",\n\t\"Decimator3\",\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_asrco0_mux_enum, ADAU1372_REG_ASRCO_SOURCE_0_1,\n\t\t\t\t  0, 0xf, adau1372_asrco_mux_text, adau1372_asrco_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_asrco1_mux_enum, ADAU1372_REG_ASRCO_SOURCE_0_1,\n\t\t\t\t  4, 0xf, adau1372_asrco_mux_text, adau1372_asrco_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_asrco2_mux_enum, ADAU1372_REG_ASRCO_SOURCE_2_3,\n\t\t\t\t  0, 0xf, adau1372_asrco_mux_text, adau1372_asrco_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_asrco3_mux_enum, ADAU1372_REG_ASRCO_SOURCE_2_3,\n\t\t\t\t  4, 0xf, adau1372_asrco_mux_text, adau1372_asrco_mux_values);\n\nstatic const struct snd_kcontrol_new adau1372_asrco0_mux_control =\n\tSOC_DAPM_ENUM(\"Output ASRC0 Capture Mux\", adau1372_asrco0_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_asrco1_mux_control =\n\tSOC_DAPM_ENUM(\"Output ASRC1 Capture Mux\", adau1372_asrco1_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_asrco2_mux_control =\n\tSOC_DAPM_ENUM(\"Output ASRC2 Capture Mux\", adau1372_asrco2_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_asrco3_mux_control =\n\tSOC_DAPM_ENUM(\"Output ASRC3 Capture Mux\", adau1372_asrco3_mux_enum);\n\nstatic const unsigned int adau1372_sout_mux_values[] = {\n\t4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n};\n\nstatic const char * const adau1372_sout_mux_text[] = {\n\t\"Output ASRC0\",\n\t\"Output ASRC1\",\n\t\"Output ASRC2\",\n\t\"Output ASRC3\",\n\t\"Serial Input 0\",\n\t\"Serial Input 1\",\n\t\"Serial Input 2\",\n\t\"Serial Input 3\",\n\t\"Serial Input 4\",\n\t\"Serial Input 5\",\n\t\"Serial Input 6\",\n\t\"Serial Input 7\",\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout0_mux_enum, ADAU1372_REG_SOUT_SOURCE_0_1,\n\t\t\t\t  0, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout1_mux_enum, ADAU1372_REG_SOUT_SOURCE_0_1,\n\t\t\t\t  4, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout2_mux_enum, ADAU1372_REG_SOUT_SOURCE_2_3,\n\t\t\t\t  0, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout3_mux_enum, ADAU1372_REG_SOUT_SOURCE_2_3,\n\t\t\t\t  4, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout4_mux_enum, ADAU1372_REG_SOUT_SOURCE_4_5,\n\t\t\t\t  0, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout5_mux_enum, ADAU1372_REG_SOUT_SOURCE_4_5,\n\t\t\t\t  4, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout6_mux_enum, ADAU1372_REG_SOUT_SOURCE_6_7,\n\t\t\t\t  0, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_sout7_mux_enum, ADAU1372_REG_SOUT_SOURCE_6_7,\n\t\t\t\t  4, 0xf, adau1372_sout_mux_text, adau1372_sout_mux_values);\n\nstatic const struct snd_kcontrol_new adau1372_sout0_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 0 Capture Mux\", adau1372_sout0_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout1_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 1 Capture Mux\", adau1372_sout1_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout2_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 2 Capture Mux\", adau1372_sout2_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout3_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 3 Capture Mux\", adau1372_sout3_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout4_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 4 Capture Mux\", adau1372_sout4_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout5_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 5 Capture Mux\", adau1372_sout5_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout6_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 6 Capture Mux\", adau1372_sout6_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_sout7_mux_control =\n\tSOC_DAPM_ENUM(\"Serial Output 7 Capture Mux\", adau1372_sout7_mux_enum);\n\nstatic const char * const adau1372_asrci_mux_text[] = {\n\t\"Serial Input 0+1\",\n\t\"Serial Input 2+3\",\n\t\"Serial Input 4+5\",\n\t\"Serial Input 6+7\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adau1372_asrci_mux_enum,\n\tADAU1372_REG_ASRC_MODE, 2, adau1372_asrci_mux_text);\n\nstatic const struct snd_kcontrol_new adau1372_asrci_mux_control =\n\tSOC_DAPM_ENUM(\"Input ASRC Playback Mux\", adau1372_asrci_mux_enum);\n\nstatic const unsigned int adau1372_dac_mux_values[] = {\n\t12, 13\n};\n\nstatic const char * const adau1372_dac_mux_text[] = {\n\t\"Input ASRC0\",\n\t\"Input ASRC1\",\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_dac0_mux_enum, ADAU1372_REG_DAC_SOURCE,\n\t\t\t\t  0, 0xf, adau1372_dac_mux_text, adau1372_dac_mux_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(adau1372_dac1_mux_enum, ADAU1372_REG_DAC_SOURCE,\n\t\t\t\t  4, 0xf, adau1372_dac_mux_text, adau1372_dac_mux_values);\n\nstatic const struct snd_kcontrol_new adau1372_dac0_mux_control =\n\tSOC_DAPM_ENUM(\"DAC 0 Playback Mux\", adau1372_dac0_mux_enum);\nstatic const struct snd_kcontrol_new adau1372_dac1_mux_control =\n\tSOC_DAPM_ENUM(\"DAC 1 Playback Mux\", adau1372_dac1_mux_enum);\n\nstatic const struct snd_soc_dapm_widget adau1372_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"AIN0\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC0_1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2_3\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS0\", ADAU1372_REG_MICBIAS, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS1\", ADAU1372_REG_MICBIAS, 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"PGA0\", ADAU1372_REG_PGA_CTRL(0), 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA1\", ADAU1372_REG_PGA_CTRL(1), 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA2\", ADAU1372_REG_PGA_CTRL(2), 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA3\", ADAU1372_REG_PGA_CTRL(3), 6, 1, NULL, 0),\n\tSND_SOC_DAPM_ADC(\"ADC0\", NULL, ADAU1372_REG_ADC_CTRL2, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC1\", NULL, ADAU1372_REG_ADC_CTRL2, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADC2\", NULL, ADAU1372_REG_ADC_CTRL3, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC3\", NULL, ADAU1372_REG_ADC_CTRL3, 1, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"ADC0 Filter\", ADAU1372_REG_DECIM_PWR, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC1 Filter\", ADAU1372_REG_DECIM_PWR, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC2 Filter\", ADAU1372_REG_DECIM_PWR, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC3 Filter\", ADAU1372_REG_DECIM_PWR, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Output ASRC0 Decimator\", ADAU1372_REG_DECIM_PWR, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Output ASRC1 Decimator\", ADAU1372_REG_DECIM_PWR, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Output ASRC2 Decimator\", ADAU1372_REG_DECIM_PWR, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Output ASRC3 Decimator\", ADAU1372_REG_DECIM_PWR, 7, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Decimator0 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_decimator0_1_mux_control),\n\tSND_SOC_DAPM_MUX(\"Decimator1 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_decimator0_1_mux_control),\n\tSND_SOC_DAPM_MUX(\"Decimator2 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_decimator2_3_mux_control),\n\tSND_SOC_DAPM_MUX(\"Decimator3 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_decimator2_3_mux_control),\n\n\tSND_SOC_DAPM_MUX(\"Output ASRC0 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrco0_mux_control),\n\tSND_SOC_DAPM_MUX(\"Output ASRC1 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrco1_mux_control),\n\tSND_SOC_DAPM_MUX(\"Output ASRC2 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrco2_mux_control),\n\tSND_SOC_DAPM_MUX(\"Output ASRC3 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrco3_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 0 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout0_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 1 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout1_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 2 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout2_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 3 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout3_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 4 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout4_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 5 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout5_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 6 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout6_mux_control),\n\tSND_SOC_DAPM_MUX(\"Serial Output 7 Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &adau1372_sout7_mux_control),\n\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 1\", NULL, 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 2\", NULL, 2, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 3\", NULL, 3, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 4\", NULL, 4, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 5\", NULL, 5, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 6\", NULL, 6, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Serial Input 7\", NULL, 7, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 0\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 1\", NULL, 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 2\", NULL, 2, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 3\", NULL, 3, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 4\", NULL, 4, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 5\", NULL, 5, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 6\", NULL, 6, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Serial Output 7\", NULL, 7, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Output ASRC Supply\", ADAU1372_REG_ASRC_MODE, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Input ASRC Supply\", ADAU1372_REG_ASRC_MODE, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC1 Modulator\", ADAU1372_REG_INTERP_PWR, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAC0 Modulator\", ADAU1372_REG_INTERP_PWR, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Input ASRC1 Interpolator\", ADAU1372_REG_INTERP_PWR, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Input ASRC0 Interpolator\", ADAU1372_REG_INTERP_PWR, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Input ASRC0 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrci_mux_control),\n\tSND_SOC_DAPM_MUX(\"Input ASRC1 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_asrci_mux_control),\n\n\tSND_SOC_DAPM_MUX(\"DAC 0 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_dac0_mux_control),\n\tSND_SOC_DAPM_MUX(\"DAC 1 Mux\", SND_SOC_NOPM, 0, 0, &adau1372_dac1_mux_control),\n\n\tSND_SOC_DAPM_DAC(\"DAC0\", NULL, ADAU1372_REG_DAC_CTRL, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC1\", NULL, ADAU1372_REG_DAC_CTRL, 1, 0),\n\n\tSND_SOC_DAPM_OUT_DRV(\"OP_STAGE_LP\", ADAU1372_REG_OP_STAGE_CTRL, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"OP_STAGE_LN\", ADAU1372_REG_OP_STAGE_CTRL, 1, 1, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"OP_STAGE_RP\", ADAU1372_REG_OP_STAGE_CTRL, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"OP_STAGE_RN\", ADAU1372_REG_OP_STAGE_CTRL, 3, 1, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\n};\n\n#define ADAU1372_SOUT_ROUTES(x) \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Output ASRC0\", \"Output ASRC0 Mux\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Output ASRC1\", \"Output ASRC1 Mux\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Output ASRC2\", \"Output ASRC2 Mux\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Output ASRC3\", \"Output ASRC3 Mux\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 0\", \"Serial Input 0\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 1\", \"Serial Input 1\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 2\", \"Serial Input 2\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 3\", \"Serial Input 3\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 4\", \"Serial Input 4\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 5\", \"Serial Input 5\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 6\", \"Serial Input 6\" }, \\\n\t{ \"Serial Output \" #x \" Capture Mux\", \"Serial Input 7\", \"Serial Input 7\" }, \\\n\t{ \"Serial Output \" #x, NULL, \"Serial Output \" #x \" Capture Mux\" }, \\\n\t{ \"Capture\", NULL, \"Serial Output \" #x }\n\n#define ADAU1372_ASRCO_ROUTES(x) \\\n\t{ \"Output ASRC\" #x \" Mux\", \"Decimator0\", \"Decimator0 Mux\" }, \\\n\t{ \"Output ASRC\" #x \" Mux\", \"Decimator1\", \"Decimator1 Mux\" }, \\\n\t{ \"Output ASRC\" #x \" Mux\", \"Decimator2\", \"Decimator2 Mux\" }, \\\n\t{ \"Output ASRC\" #x \" Mux\", \"Decimator3\", \"Decimator3 Mux\" }\n\nstatic const struct snd_soc_dapm_route adau1372_dapm_routes[] = {\n\t{ \"PGA0\", NULL, \"AIN0\" },\n\t{ \"PGA1\", NULL, \"AIN1\" },\n\t{ \"PGA2\", NULL, \"AIN2\" },\n\t{ \"PGA3\", NULL, \"AIN3\" },\n\n\t{ \"ADC0\", NULL, \"PGA0\" },\n\t{ \"ADC1\", NULL, \"PGA1\" },\n\t{ \"ADC2\", NULL, \"PGA2\" },\n\t{ \"ADC3\", NULL, \"PGA3\" },\n\n\t{ \"Decimator0 Mux\", \"ADC\", \"ADC0\" },\n\t{ \"Decimator1 Mux\", \"ADC\", \"ADC1\" },\n\t{ \"Decimator2 Mux\", \"ADC\", \"ADC2\" },\n\t{ \"Decimator3 Mux\", \"ADC\", \"ADC3\" },\n\n\t{ \"Decimator0 Mux\", \"DMIC\", \"DMIC0_1\" },\n\t{ \"Decimator1 Mux\", \"DMIC\", \"DMIC0_1\" },\n\t{ \"Decimator2 Mux\", \"DMIC\", \"DMIC2_3\" },\n\t{ \"Decimator3 Mux\", \"DMIC\", \"DMIC2_3\" },\n\n\t{ \"Decimator0 Mux\", NULL, \"ADC0 Filter\" },\n\t{ \"Decimator1 Mux\", NULL, \"ADC1 Filter\" },\n\t{ \"Decimator2 Mux\", NULL, \"ADC2 Filter\" },\n\t{ \"Decimator3 Mux\", NULL, \"ADC3 Filter\" },\n\n\t{ \"Output ASRC0 Mux\", NULL, \"Output ASRC Supply\" },\n\t{ \"Output ASRC1 Mux\", NULL, \"Output ASRC Supply\" },\n\t{ \"Output ASRC2 Mux\", NULL, \"Output ASRC Supply\" },\n\t{ \"Output ASRC3 Mux\", NULL, \"Output ASRC Supply\" },\n\t{ \"Output ASRC0 Mux\", NULL, \"Output ASRC0 Decimator\" },\n\t{ \"Output ASRC1 Mux\", NULL, \"Output ASRC1 Decimator\" },\n\t{ \"Output ASRC2 Mux\", NULL, \"Output ASRC2 Decimator\" },\n\t{ \"Output ASRC3 Mux\", NULL, \"Output ASRC3 Decimator\" },\n\n\tADAU1372_ASRCO_ROUTES(0),\n\tADAU1372_ASRCO_ROUTES(1),\n\tADAU1372_ASRCO_ROUTES(2),\n\tADAU1372_ASRCO_ROUTES(3),\n\n\tADAU1372_SOUT_ROUTES(0),\n\tADAU1372_SOUT_ROUTES(1),\n\tADAU1372_SOUT_ROUTES(2),\n\tADAU1372_SOUT_ROUTES(3),\n\tADAU1372_SOUT_ROUTES(4),\n\tADAU1372_SOUT_ROUTES(5),\n\tADAU1372_SOUT_ROUTES(6),\n\tADAU1372_SOUT_ROUTES(7),\n\n\t{ \"Serial Input 0\", NULL, \"Playback\" },\n\t{ \"Serial Input 1\", NULL, \"Playback\" },\n\t{ \"Serial Input 2\", NULL, \"Playback\" },\n\t{ \"Serial Input 3\", NULL, \"Playback\" },\n\t{ \"Serial Input 4\", NULL, \"Playback\" },\n\t{ \"Serial Input 5\", NULL, \"Playback\" },\n\t{ \"Serial Input 6\", NULL, \"Playback\" },\n\t{ \"Serial Input 7\", NULL, \"Playback\" },\n\n\t{ \"Input ASRC0 Mux\", \"Serial Input 0+1\", \"Serial Input 0\" },\n\t{ \"Input ASRC1 Mux\", \"Serial Input 0+1\", \"Serial Input 1\" },\n\t{ \"Input ASRC0 Mux\", \"Serial Input 2+3\", \"Serial Input 2\" },\n\t{ \"Input ASRC1 Mux\", \"Serial Input 2+3\", \"Serial Input 3\" },\n\t{ \"Input ASRC0 Mux\", \"Serial Input 4+5\", \"Serial Input 4\" },\n\t{ \"Input ASRC1 Mux\", \"Serial Input 4+5\", \"Serial Input 5\" },\n\t{ \"Input ASRC0 Mux\", \"Serial Input 6+7\", \"Serial Input 6\" },\n\t{ \"Input ASRC1 Mux\", \"Serial Input 6+7\", \"Serial Input 7\" },\n\t{ \"Input ASRC0 Mux\", NULL, \"Input ASRC Supply\" },\n\t{ \"Input ASRC1 Mux\", NULL, \"Input ASRC Supply\" },\n\t{ \"Input ASRC0 Mux\", NULL, \"Input ASRC0 Interpolator\" },\n\t{ \"Input ASRC1 Mux\", NULL, \"Input ASRC1 Interpolator\" },\n\n\t{ \"DAC 0 Mux\", \"Input ASRC0\", \"Input ASRC0 Mux\" },\n\t{ \"DAC 0 Mux\", \"Input ASRC1\", \"Input ASRC1 Mux\" },\n\t{ \"DAC 1 Mux\", \"Input ASRC0\", \"Input ASRC0 Mux\" },\n\t{ \"DAC 1 Mux\", \"Input ASRC1\", \"Input ASRC1 Mux\" },\n\n\t{ \"DAC0\", NULL, \"DAC 0 Mux\" },\n\t{ \"DAC1\", NULL, \"DAC 1 Mux\" },\n\t{ \"DAC0\", NULL, \"DAC0 Modulator\" },\n\t{ \"DAC1\", NULL, \"DAC1 Modulator\" },\n\n\t{ \"OP_STAGE_LP\", NULL, \"DAC0\" },\n\t{ \"OP_STAGE_LN\", NULL, \"DAC0\" },\n\t{ \"OP_STAGE_RP\", NULL, \"DAC1\" },\n\t{ \"OP_STAGE_RN\", NULL, \"DAC1\" },\n\n\t{ \"HPOUTL\", NULL, \"OP_STAGE_LP\" },\n\t{ \"HPOUTL\", NULL, \"OP_STAGE_LN\" },\n\t{ \"HPOUTR\", NULL, \"OP_STAGE_RP\" },\n\t{ \"HPOUTR\", NULL, \"OP_STAGE_RN\" },\n};\n\nstatic int adau1372_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct adau1372 *adau1372 = snd_soc_dai_get_drvdata(dai);\n\tunsigned int sai0 = 0, sai1 = 0;\n\tbool invert_lrclk = false;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tadau1372->clock_provider = true;\n\t\tsai1 |= ADAU1372_SAI1_MS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tadau1372->clock_provider = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tinvert_lrclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert_lrclk = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert_lrclk = false;\n\t\tsai1 |= ADAU1372_SAI1_BCLKEDGE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tinvert_lrclk = true;\n\t\tsai1 |= ADAU1372_SAI1_BCLKEDGE;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsai0 |= ADAU1372_SAI0_DELAY1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsai0 |= ADAU1372_SAI0_DELAY0;\n\t\tinvert_lrclk = !invert_lrclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tsai0 |= ADAU1372_SAI0_DELAY1;\n\t\tsai1 |= ADAU1372_SAI1_LR_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tsai0 |= ADAU1372_SAI0_DELAY0;\n\t\tsai1 |= ADAU1372_SAI1_LR_MODE;\n\t\tbreak;\n\t}\n\n\tif (invert_lrclk)\n\t\tsai1 |= ADAU1372_SAI1_LR_POL;\n\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI0, ADAU1372_SAI0_DELAY_MASK, sai0);\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI1,\n\t\t\t   ADAU1372_SAI1_MS | ADAU1372_SAI1_BCLKEDGE |\n\t\t\t   ADAU1372_SAI1_LR_MODE | ADAU1372_SAI1_LR_POL, sai1);\n\n\treturn 0;\n}\n\nstatic int adau1372_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct adau1372 *adau1372 = snd_soc_dai_get_drvdata(dai);\n\tunsigned int rate = params_rate(params);\n\tunsigned int slot_width;\n\tunsigned int sai0, sai1;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adau1372_rates); i++) {\n\t\tif (rate == adau1372_rates[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(adau1372_rates))\n\t\treturn -EINVAL;\n\n\tsai0 = i;\n\n\tslot_width = adau1372->slot_width;\n\tif (slot_width == 0)\n\t\tslot_width = params_width(params);\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tsai1 = ADAU1372_SAI1_BCLKRATE;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tsai1 = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI0, ADAU1372_SAI0_FS_MASK, sai0);\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI1, ADAU1372_SAI1_BCLKRATE, sai1);\n\n\treturn 0;\n}\n\nstatic int adau1372_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t unsigned int rx_mask, int slots, int width)\n{\n\tstruct adau1372 *adau1372 = snd_soc_dai_get_drvdata(dai);\n\tunsigned int sai0, sai1;\n\n\t \n\tif (slots == 0) {\n\t\t \n\t\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI0,\n\t\t\t\t   ADAU1372_SAI0_SAI_MASK, ADAU1372_SAI0_SAI_I2S);\n\t\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM2;\n\t\tadau1372->slot_width = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((tx_mask & ~0xff) != 0 || (rx_mask & ~0xff) != 0)\n\t\treturn -EINVAL;\n\n\tswitch (width) {\n\tcase 16:\n\t\tsai1 = ADAU1372_SAI1_BCLK_TDMC;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tsai1 = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slots) {\n\tcase 2:\n\t\tsai0 = ADAU1372_SAI0_SAI_TDM2;\n\t\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM2;\n\t\tbreak;\n\tcase 4:\n\t\tsai0 = ADAU1372_SAI0_SAI_TDM4;\n\t\tif (adau1372->clock_provider)\n\t\t\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM4_MASTER;\n\t\telse\n\t\t\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM4;\n\t\tbreak;\n\tcase 8:\n\t\tsai0 = ADAU1372_SAI0_SAI_TDM8;\n\t\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tadau1372->slot_width = width;\n\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI0, ADAU1372_SAI0_SAI_MASK, sai0);\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI1, ADAU1372_SAI1_BCLK_TDMC, sai1);\n\n\t \n\tregmap_write(adau1372->regmap, ADAU1372_REG_SOUT_CTRL, ~tx_mask);\n\n\treturn 0;\n}\n\nstatic int adau1372_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct adau1372 *adau1372 = snd_soc_dai_get_drvdata(dai);\n\tunsigned int sai1;\n\n\tif (tristate)\n\t\tsai1 = ADAU1372_SAI1_TDM_TS;\n\telse\n\t\tsai1 = 0;\n\n\treturn regmap_update_bits(adau1372->regmap, ADAU1372_REG_SAI1, ADAU1372_SAI1_TDM_TS, sai1);\n}\n\nstatic int adau1372_startup(struct snd_pcm_substream *substream, struct snd_soc_dai *dai)\n{\n\tstruct adau1372 *adau1372 = snd_soc_dai_get_drvdata(dai);\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &adau1372->rate_constraints);\n\n\treturn 0;\n}\n\nstatic void adau1372_enable_pll(struct adau1372 *adau1372)\n{\n\tunsigned int val, timeout = 0;\n\tint ret;\n\n\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_CLK_CTRL,\n\t\t\t   ADAU1372_CLK_CTRL_PLL_EN, ADAU1372_CLK_CTRL_PLL_EN);\n\tdo {\n\t\t \n\t\tusleep_range(1000, 2000);\n\t\tret = regmap_read(adau1372->regmap, ADAU1372_REG_PLL(5), &val);\n\t\tif (ret)\n\t\t\tbreak;\n\t\ttimeout++;\n\t} while (!(val & 1) && timeout < 3);\n\n\tif (ret < 0 || !(val & 1))\n\t\tdev_err(adau1372->dev, \"Failed to lock PLL\\n\");\n}\n\nstatic void adau1372_set_power(struct adau1372 *adau1372, bool enable)\n{\n\tif (adau1372->enabled == enable)\n\t\treturn;\n\n\tif (enable) {\n\t\tunsigned int clk_ctrl = ADAU1372_CLK_CTRL_MCLK_EN;\n\n\t\tclk_prepare_enable(adau1372->mclk);\n\t\tif (adau1372->pd_gpio)\n\t\t\tgpiod_set_value(adau1372->pd_gpio, 0);\n\n\t\tif (adau1372->switch_mode)\n\t\t\tadau1372->switch_mode(adau1372->dev);\n\n\t\tregcache_cache_only(adau1372->regmap, false);\n\n\t\t \n\t\tif (adau1372->use_pll) {\n\t\t\tadau1372_enable_pll(adau1372);\n\t\t\tclk_ctrl |= ADAU1372_CLK_CTRL_CLKSRC;\n\t\t}\n\n\t\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_CLK_CTRL,\n\t\t\t\t   ADAU1372_CLK_CTRL_MCLK_EN | ADAU1372_CLK_CTRL_CLKSRC, clk_ctrl);\n\t\tregcache_sync(adau1372->regmap);\n\t} else {\n\t\tif (adau1372->pd_gpio) {\n\t\t\t \n\t\t\tgpiod_set_value(adau1372->pd_gpio, 1);\n\t\t\tregcache_mark_dirty(adau1372->regmap);\n\t\t} else {\n\t\t\tregmap_update_bits(adau1372->regmap, ADAU1372_REG_CLK_CTRL,\n\t\t\t\t\t   ADAU1372_CLK_CTRL_MCLK_EN | ADAU1372_CLK_CTRL_PLL_EN, 0);\n\t\t}\n\t\tclk_disable_unprepare(adau1372->mclk);\n\t\tregcache_cache_only(adau1372->regmap, true);\n\t}\n\n\tadau1372->enabled = enable;\n}\n\nstatic int adau1372_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct adau1372 *adau1372 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tadau1372_set_power(adau1372, true);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tadau1372_set_power(adau1372, false);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver adau1372_driver = {\n\t.set_bias_level = adau1372_set_bias_level,\n\t.controls = adau1372_controls,\n\t.num_controls = ARRAY_SIZE(adau1372_controls),\n\t.dapm_widgets = adau1372_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(adau1372_dapm_widgets),\n\t.dapm_routes = adau1372_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(adau1372_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic const struct snd_soc_dai_ops adau1372_dai_ops = {\n\t.set_fmt = adau1372_set_dai_fmt,\n\t.set_tdm_slot = adau1372_set_tdm_slot,\n\t.set_tristate = adau1372_set_tristate,\n\t.hw_params = adau1372_hw_params,\n\t.startup = adau1372_startup,\n};\n\n#define ADAU1372_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver adau1372_dai_driver = {\n\t.name = \"adau1372\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = ADAU1372_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = ADAU1372_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &adau1372_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int adau1372_setup_pll(struct adau1372 *adau1372, unsigned int rate)\n{\n\tu8 regs[5];\n\tunsigned int i;\n\tint ret;\n\n\tret = adau_calc_pll_cfg(rate, 49152000, regs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++)\n\t\tregmap_write(adau1372->regmap, ADAU1372_REG_PLL(i), regs[i]);\n\n\treturn 0;\n}\n\nint adau1372_probe(struct device *dev, struct regmap *regmap,\n\t\t   void (*switch_mode)(struct device *dev))\n{\n\tstruct adau1372 *adau1372;\n\tunsigned int clk_ctrl;\n\tunsigned long rate;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tadau1372 = devm_kzalloc(dev, sizeof(*adau1372), GFP_KERNEL);\n\tif (!adau1372)\n\t\treturn -ENOMEM;\n\n\tadau1372->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(adau1372->mclk))\n\t\treturn PTR_ERR(adau1372->mclk);\n\n\tadau1372->pd_gpio = devm_gpiod_get_optional(dev, \"powerdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(adau1372->pd_gpio))\n\t\treturn PTR_ERR(adau1372->pd_gpio);\n\n\tadau1372->regmap = regmap;\n\tadau1372->switch_mode = switch_mode;\n\tadau1372->dev = dev;\n\tadau1372->rate_constraints.list = adau1372_rates;\n\tadau1372->rate_constraints.count = ARRAY_SIZE(adau1372_rates);\n\tadau1372->rate_constraints.mask = ADAU1372_RATE_MASK_TDM2;\n\n\tdev_set_drvdata(dev, adau1372);\n\n\t \n\trate = clk_get_rate(adau1372->mclk);\n\n\tswitch (rate) {\n\tcase 12288000:\n\t\tclk_ctrl = ADAU1372_CLK_CTRL_CC_MDIV;\n\t\tbreak;\n\tcase 24576000:\n\t\tclk_ctrl = 0;\n\t\tbreak;\n\tdefault:\n\t\tclk_ctrl = 0;\n\t\tret = adau1372_setup_pll(adau1372, rate);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tadau1372->use_pll = true;\n\t\tbreak;\n\t}\n\n\t \n\tregcache_cache_only(regmap, true);\n\n\tregmap_update_bits(regmap, ADAU1372_REG_CLK_CTRL, ADAU1372_CLK_CTRL_CC_MDIV, clk_ctrl);\n\n\t \n\tregmap_write(regmap, ADAU1372_REG_MODE_MP(1), 0x00);  \n\tregmap_write(regmap, ADAU1372_REG_MODE_MP(6), 0x12);  \n\n\tregmap_write(regmap, ADAU1372_REG_OP_STAGE_MUTE, 0x0);\n\n\tregmap_write(regmap, 0x7, 0x01);  \n\n\treturn  devm_snd_soc_register_component(dev, &adau1372_driver, &adau1372_dai_driver, 1);\n}\nEXPORT_SYMBOL(adau1372_probe);\n\nstatic const struct reg_default adau1372_reg_defaults[] = {\n\t{ ADAU1372_REG_CLK_CTRL,\t\t0x00 },\n\t{ ADAU1372_REG_PLL(0),\t\t\t0x00 },\n\t{ ADAU1372_REG_PLL(1),\t\t\t0x00 },\n\t{ ADAU1372_REG_PLL(2),\t\t\t0x00 },\n\t{ ADAU1372_REG_PLL(3),\t\t\t0x00 },\n\t{ ADAU1372_REG_PLL(4),\t\t\t0x00 },\n\t{ ADAU1372_REG_PLL(5),\t\t\t0x00 },\n\t{ ADAU1372_REG_DAC_SOURCE,\t\t0x10 },\n\t{ ADAU1372_REG_SOUT_SOURCE_0_1,\t\t0x54 },\n\t{ ADAU1372_REG_SOUT_SOURCE_2_3,\t\t0x76 },\n\t{ ADAU1372_REG_SOUT_SOURCE_4_5,\t\t0x54 },\n\t{ ADAU1372_REG_SOUT_SOURCE_6_7,\t\t0x76 },\n\t{ ADAU1372_REG_ADC_SDATA_CH,\t\t0x04 },\n\t{ ADAU1372_REG_ASRCO_SOURCE_0_1,\t0x10 },\n\t{ ADAU1372_REG_ASRCO_SOURCE_2_3,\t0x32 },\n\t{ ADAU1372_REG_ASRC_MODE,\t\t0x00 },\n\t{ ADAU1372_REG_ADC_CTRL0,\t\t0x19 },\n\t{ ADAU1372_REG_ADC_CTRL1,\t\t0x19 },\n\t{ ADAU1372_REG_ADC_CTRL2,\t\t0x00 },\n\t{ ADAU1372_REG_ADC_CTRL3,\t\t0x00 },\n\t{ ADAU1372_REG_ADC_VOL(0),\t\t0x00 },\n\t{ ADAU1372_REG_ADC_VOL(1),\t\t0x00 },\n\t{ ADAU1372_REG_ADC_VOL(2),\t\t0x00 },\n\t{ ADAU1372_REG_ADC_VOL(3),\t\t0x00 },\n\t{ ADAU1372_REG_PGA_CTRL(0),\t\t0x40 },\n\t{ ADAU1372_REG_PGA_CTRL(1),\t\t0x40 },\n\t{ ADAU1372_REG_PGA_CTRL(2),\t\t0x40 },\n\t{ ADAU1372_REG_PGA_CTRL(3),\t\t0x40 },\n\t{ ADAU1372_REG_PGA_BOOST,\t\t0x00 },\n\t{ ADAU1372_REG_MICBIAS,\t\t\t0x00 },\n\t{ ADAU1372_REG_DAC_CTRL,\t\t0x18 },\n\t{ ADAU1372_REG_DAC_VOL(0),\t\t0x00 },\n\t{ ADAU1372_REG_DAC_VOL(1),\t\t0x00 },\n\t{ ADAU1372_REG_OP_STAGE_MUTE,\t\t0x0f },\n\t{ ADAU1372_REG_SAI0,\t\t\t0x00 },\n\t{ ADAU1372_REG_SAI1,\t\t\t0x00 },\n\t{ ADAU1372_REG_SOUT_CTRL,\t\t0x00 },\n\t{ ADAU1372_REG_MODE_MP(0),\t\t0x00 },\n\t{ ADAU1372_REG_MODE_MP(1),\t\t0x10 },\n\t{ ADAU1372_REG_MODE_MP(4),\t\t0x00 },\n\t{ ADAU1372_REG_MODE_MP(5),\t\t0x00 },\n\t{ ADAU1372_REG_MODE_MP(6),\t\t0x11 },\n\t{ ADAU1372_REG_OP_STAGE_CTRL,\t\t0x0f },\n\t{ ADAU1372_REG_DECIM_PWR,\t\t0x00 },\n\t{ ADAU1372_REG_INTERP_PWR,\t\t0x00 },\n\t{ ADAU1372_REG_BIAS_CTRL0,\t\t0x00 },\n\t{ ADAU1372_REG_BIAS_CTRL1,\t\t0x00 },\n};\n\nstatic bool adau1372_volatile_register(struct device *dev, unsigned int reg)\n{\n\tif (reg == ADAU1372_REG_PLL(5))\n\t\treturn true;\n\n\treturn false;\n}\n\nconst struct regmap_config adau1372_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 16,\n\t.max_register = 0x4d,\n\n\t.reg_defaults = adau1372_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adau1372_reg_defaults),\n\t.volatile_reg = adau1372_volatile_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(adau1372_regmap_config);\n\nMODULE_DESCRIPTION(\"ASoC ADAU1372 CODEC driver\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}