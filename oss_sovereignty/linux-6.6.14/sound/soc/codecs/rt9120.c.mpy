{
  "module_name": "rt9120.c",
  "hash_id": "0ecf52e0e92ee6286c66985b9ac4d27b5a9f86d42dfd59a78ccd066ac5a8c831",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt9120.c",
  "human_readable_source": "\n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define RT9120_REG_DEVID\t0x00\n#define RT9120_REG_I2SFMT\t0x02\n#define RT9120_REG_I2SWL\t0x03\n#define RT9120_REG_SDIOSEL\t0x04\n#define RT9120_REG_SYSCTL\t0x05\n#define RT9120_REG_SPKGAIN\t0x07\n#define RT9120_REG_VOLRAMP\t0x0A\n#define RT9120_REG_ERRRPT\t0x10\n#define RT9120_REG_MSVOL\t0x20\n#define RT9120_REG_SWRESET\t0x40\n#define RT9120_REG_INTERCFG\t0x63\n#define RT9120_REG_INTERNAL0\t0x65\n#define RT9120_REG_INTERNAL1\t0x69\n#define RT9120_REG_UVPOPT\t0x6C\n#define RT9120_REG_DIGCFG\t0xF8\n\n#define RT9120_VID_MASK\t\tGENMASK(15, 8)\n#define RT9120_SWRST_MASK\tBIT(7)\n#define RT9120_MUTE_MASK\tGENMASK(5, 4)\n#define RT9120_I2SFMT_MASK\tGENMASK(4, 2)\n#define RT9120_I2SFMT_SHIFT\t2\n#define RT9120_CFG_FMT_I2S\t0\n#define RT9120_CFG_FMT_LEFTJ\t1\n#define RT9120_CFG_FMT_RIGHTJ\t2\n#define RT9120_CFG_FMT_DSPA\t3\n#define RT9120_CFG_FMT_DSPB\t7\n#define RT9120_AUDBIT_MASK\tGENMASK(1, 0)\n#define RT9120_CFG_AUDBIT_16\t0\n#define RT9120_CFG_AUDBIT_20\t1\n#define RT9120_CFG_AUDBIT_24\t2\n#define RT9120_AUDWL_MASK\tGENMASK(5, 0)\n#define RT9120_CFG_WORDLEN_16\t16\n#define RT9120_CFG_WORDLEN_24\t24\n#define RT9120_CFG_WORDLEN_32\t32\n#define RT9120_DVDD_UVSEL_MASK\tGENMASK(5, 4)\n#define RT9120_AUTOSYNC_MASK\tBIT(6)\n\n#define RT9120_VENDOR_ID\t0x42\n#define RT9120S_VENDOR_ID\t0x43\n#define RT9120_RESET_WAITMS\t20\n#define RT9120_CHIPON_WAITMS\t20\n#define RT9120_AMPON_WAITMS\t50\n#define RT9120_AMPOFF_WAITMS\t100\n#define RT9120_LVAPP_THRESUV\t2000000\n\n \n#define RT9120_RATES_MASK\t(SNDRV_PCM_RATE_8000_192000 &\\\n\t\t\t\t ~SNDRV_PCM_RATE_176400)\n#define RT9120_FMTS_MASK\t(SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nenum {\n\tCHIP_IDX_RT9120 = 0,\n\tCHIP_IDX_RT9120S,\n\tCHIP_IDX_MAX\n};\n\nstruct rt9120_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *pwdnn_gpio;\n\tint chip_idx;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -1039375, 625, 1);\n\n \nstatic const DECLARE_TLV_DB_RANGE(classd_tlv,\n\t0, 3, TLV_DB_SCALE_ITEM(600, 200, 0),\n\t4, 7, TLV_DB_SCALE_ITEM(1300, 100, 0)\n);\n\nstatic const char * const sdo_select_text[] = {\n\t\"None\", \"INTF\", \"Final\", \"RMS Detect\"\n};\n\nstatic const struct soc_enum sdo_select_enum =\n\tSOC_ENUM_SINGLE(RT9120_REG_SDIOSEL, 4, ARRAY_SIZE(sdo_select_text),\n\t\t\tsdo_select_text);\n\nstatic const struct snd_kcontrol_new rt9120_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"MS Volume\", RT9120_REG_MSVOL, 0, 2047, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"SPK Gain Volume\", RT9120_REG_SPKGAIN, 0, 7, 0, classd_tlv),\n\tSOC_SINGLE(\"PBTL Switch\", RT9120_REG_SYSCTL, 3, 1, 0),\n\tSOC_ENUM(\"SDO Select\", sdo_select_enum),\n};\n\nstatic int internal_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_write(comp, RT9120_REG_ERRRPT, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(RT9120_AMPON_WAITMS);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tmsleep(RT9120_AMPOFF_WAITMS);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt9120_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"DMIX\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"LDAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"RDAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PWND\", RT9120_REG_SYSCTL, 6, 1,\n\t\t\t    internal_power_event, SND_SOC_DAPM_PRE_PMU |\n\t\t\t    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA(\"SPKL PA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPKR PA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n};\n\nstatic const struct snd_soc_dapm_route rt9120_dapm_routes[] = {\n\t{ \"DMIX\", NULL, \"AIF Playback\" },\n\t \n\t{ \"LDAC\", NULL, \"PWND\" },\n\t{ \"LDAC\", NULL, \"DMIX\" },\n\t{ \"SPKL PA\", NULL, \"LDAC\" },\n\t{ \"SPKL\", NULL, \"SPKL PA\" },\n\t \n\t{ \"RDAC\", NULL, \"PWND\" },\n\t{ \"RDAC\", NULL, \"DMIX\" },\n\t{ \"SPKR PA\", NULL, \"RDAC\" },\n\t{ \"SPKR\", NULL, \"SPKR PA\" },\n\t \n\t{ \"AIF Capture\", NULL, \"LDAC\" },\n\t{ \"AIF Capture\", NULL, \"RDAC\" },\n};\n\nstatic int rt9120_codec_probe(struct snd_soc_component *comp)\n{\n\tstruct rt9120_data *data = snd_soc_component_get_drvdata(comp);\n\n\tsnd_soc_component_init_regmap(comp, data->regmap);\n\n\tpm_runtime_get_sync(comp->dev);\n\n\t \n\tif (data->chip_idx == CHIP_IDX_RT9120S) {\n\t\tsnd_soc_component_write(comp, RT9120_REG_INTERCFG, 0xde);\n\t\tsnd_soc_component_write(comp, RT9120_REG_INTERNAL0, 0x66);\n\t} else\n\t\tsnd_soc_component_write(comp, RT9120_REG_INTERNAL0, 0x04);\n\n\tpm_runtime_mark_last_busy(comp->dev);\n\tpm_runtime_put(comp->dev);\n\n\treturn 0;\n}\n\nstatic int rt9120_codec_suspend(struct snd_soc_component *comp)\n{\n\treturn pm_runtime_force_suspend(comp->dev);\n}\n\nstatic int rt9120_codec_resume(struct snd_soc_component *comp)\n{\n\treturn pm_runtime_force_resume(comp->dev);\n}\n\nstatic const struct snd_soc_component_driver rt9120_component_driver = {\n\t.probe = rt9120_codec_probe,\n\t.suspend = rt9120_codec_suspend,\n\t.resume = rt9120_codec_resume,\n\t.controls = rt9120_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt9120_snd_controls),\n\t.dapm_widgets = rt9120_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt9120_dapm_widgets),\n\t.dapm_routes = rt9120_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt9120_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic int rt9120_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tunsigned int format;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = RT9120_CFG_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = RT9120_CFG_FMT_LEFTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tformat = RT9120_CFG_FMT_RIGHTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = RT9120_CFG_FMT_DSPA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = RT9120_CFG_FMT_DSPB;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(comp, RT9120_REG_I2SFMT,\n\t\t\t\t      RT9120_I2SFMT_MASK,\n\t\t\t\t      format << RT9120_I2SFMT_SHIFT);\n\treturn 0;\n}\n\nstatic int rt9120_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *param,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tunsigned int param_width, param_slot_width, auto_sync;\n\tint width, fs;\n\n\tswitch (width = params_width(param)) {\n\tcase 16:\n\t\tparam_width = RT9120_CFG_AUDBIT_16;\n\t\tbreak;\n\tcase 20:\n\t\tparam_width = RT9120_CFG_AUDBIT_20;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tparam_width = RT9120_CFG_AUDBIT_24;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported data width [%d]\\n\", width);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(comp, RT9120_REG_I2SFMT,\n\t\t\t\t      RT9120_AUDBIT_MASK, param_width);\n\n\tswitch (width = params_physical_width(param)) {\n\tcase 16:\n\t\tparam_slot_width = RT9120_CFG_WORDLEN_16;\n\t\tbreak;\n\tcase 24:\n\t\tparam_slot_width = RT9120_CFG_WORDLEN_24;\n\t\tbreak;\n\tcase 32:\n\t\tparam_slot_width = RT9120_CFG_WORDLEN_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported slot width [%d]\\n\", width);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(comp, RT9120_REG_I2SWL,\n\t\t\t\t      RT9120_AUDWL_MASK, param_slot_width);\n\n\tfs = width * params_channels(param);\n\t \n\tif (fs % 48 == 0)\n\t\tauto_sync = 0;\n\telse\n\t\tauto_sync = RT9120_AUTOSYNC_MASK;\n\n\tsnd_soc_component_update_bits(comp, RT9120_REG_DIGCFG,\n\t\t\t\t      RT9120_AUTOSYNC_MASK, auto_sync);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rt9120_dai_ops = {\n\t.set_fmt = rt9120_set_fmt,\n\t.hw_params = rt9120_hw_params,\n};\n\nstatic struct snd_soc_dai_driver rt9120_dai = {\n\t.name = \"rt9120_aif\",\n\t.playback = {\n\t\t.stream_name = \"AIF Playback\",\n\t\t.rates = RT9120_RATES_MASK,\n\t\t.formats = RT9120_FMTS_MASK,\n\t\t.rate_max = 192000,\n\t\t.rate_min = 8000,\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t},\n\t.capture = {\n\t\t.stream_name = \"AIF Capture\",\n\t\t.rates = RT9120_RATES_MASK,\n\t\t.formats = RT9120_FMTS_MASK,\n\t\t.rate_max = 192000,\n\t\t.rate_min = 8000,\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t},\n\t.ops = &rt9120_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n};\n\nstatic const struct regmap_range rt9120_rd_yes_ranges[] = {\n\tregmap_reg_range(0x00, 0x0C),\n\tregmap_reg_range(0x10, 0x15),\n\tregmap_reg_range(0x20, 0x27),\n\tregmap_reg_range(0x30, 0x38),\n\tregmap_reg_range(0x3A, 0x40),\n\tregmap_reg_range(0x63, 0x63),\n\tregmap_reg_range(0x65, 0x65),\n\tregmap_reg_range(0x69, 0x69),\n\tregmap_reg_range(0x6C, 0x6C),\n\tregmap_reg_range(0xF8, 0xF8)\n};\n\nstatic const struct regmap_access_table rt9120_rd_table = {\n\t.yes_ranges = rt9120_rd_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rt9120_rd_yes_ranges),\n};\n\nstatic const struct regmap_range rt9120_wr_yes_ranges[] = {\n\tregmap_reg_range(0x00, 0x00),\n\tregmap_reg_range(0x02, 0x0A),\n\tregmap_reg_range(0x10, 0x15),\n\tregmap_reg_range(0x20, 0x27),\n\tregmap_reg_range(0x30, 0x38),\n\tregmap_reg_range(0x3A, 0x3D),\n\tregmap_reg_range(0x40, 0x40),\n\tregmap_reg_range(0x63, 0x63),\n\tregmap_reg_range(0x65, 0x65),\n\tregmap_reg_range(0x69, 0x69),\n\tregmap_reg_range(0x6C, 0x6C),\n\tregmap_reg_range(0xF8, 0xF8)\n};\n\nstatic const struct regmap_access_table rt9120_wr_table = {\n\t.yes_ranges = rt9120_wr_yes_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(rt9120_wr_yes_ranges),\n};\n\nstatic bool rt9120_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00 ... 0x01:\n\tcase 0x10:\n\tcase 0x30 ... 0x40:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int rt9120_get_reg_size(unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00:\n\tcase 0x20 ... 0x27:\n\t\treturn 2;\n\tcase 0x30 ... 0x3D:\n\t\treturn 3;\n\tcase 0x3E ... 0x3F:\n\t\treturn 4;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int rt9120_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct rt9120_data *data = context;\n\tstruct i2c_client *i2c = to_i2c_client(data->dev);\n\tint size = rt9120_get_reg_size(reg);\n\tu8 raw[4] = {0};\n\tint ret;\n\n\tret = i2c_smbus_read_i2c_block_data(i2c, reg, size, raw);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != size)\n\t\treturn -EIO;\n\n\tswitch (size) {\n\tcase 4:\n\t\t*val = be32_to_cpup((__be32 *)raw);\n\t\tbreak;\n\tcase 3:\n\t\t*val = raw[0] << 16 | raw[1] << 8 | raw[2];\n\t\tbreak;\n\tcase 2:\n\t\t*val = be16_to_cpup((__be16 *)raw);\n\t\tbreak;\n\tdefault:\n\t\t*val = raw[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int rt9120_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct rt9120_data *data = context;\n\tstruct i2c_client *i2c = to_i2c_client(data->dev);\n\tint size = rt9120_get_reg_size(reg);\n\t__be32 be32_val;\n\tu8 *rawp = (u8 *)&be32_val;\n\tint offs = 4 - size;\n\n\tbe32_val = cpu_to_be32(val);\n\treturn i2c_smbus_write_i2c_block_data(i2c, reg, size, rawp + offs);\n}\n\nstatic const struct reg_default rt9120_reg_defaults[] = {\n\t{ .reg = 0x02, .def = 0x02 },\n\t{ .reg = 0x03, .def = 0xf2 },\n\t{ .reg = 0x04, .def = 0x01 },\n\t{ .reg = 0x05, .def = 0xc0 },\n\t{ .reg = 0x06, .def = 0x28 },\n\t{ .reg = 0x07, .def = 0x04 },\n\t{ .reg = 0x08, .def = 0xff },\n\t{ .reg = 0x09, .def = 0x01 },\n\t{ .reg = 0x0a, .def = 0x01 },\n\t{ .reg = 0x0b, .def = 0x00 },\n\t{ .reg = 0x0c, .def = 0x04 },\n\t{ .reg = 0x11, .def = 0x30 },\n\t{ .reg = 0x12, .def = 0x08 },\n\t{ .reg = 0x13, .def = 0x12 },\n\t{ .reg = 0x14, .def = 0x09 },\n\t{ .reg = 0x15, .def = 0x00 },\n\t{ .reg = 0x20, .def = 0x7ff },\n\t{ .reg = 0x21, .def = 0x180 },\n\t{ .reg = 0x22, .def = 0x180 },\n\t{ .reg = 0x23, .def = 0x00 },\n\t{ .reg = 0x24, .def = 0x80 },\n\t{ .reg = 0x25, .def = 0x180 },\n\t{ .reg = 0x26, .def = 0x640 },\n\t{ .reg = 0x27, .def = 0x180 },\n\t{ .reg = 0x63, .def = 0x5e },\n\t{ .reg = 0x65, .def = 0x66 },\n\t{ .reg = 0x6c, .def = 0xe0 },\n\t{ .reg = 0xf8, .def = 0x44 },\n};\n\nstatic const struct regmap_config rt9120_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.max_register = RT9120_REG_DIGCFG,\n\t.reg_defaults = rt9120_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt9120_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.reg_read = rt9120_reg_read,\n\t.reg_write = rt9120_reg_write,\n\n\t.volatile_reg = rt9120_volatile_reg,\n\t.wr_table = &rt9120_wr_table,\n\t.rd_table = &rt9120_rd_table,\n};\n\nstatic int rt9120_check_vendor_info(struct rt9120_data *data)\n{\n\tunsigned int devid;\n\tint ret;\n\n\tret = regmap_read(data->regmap, RT9120_REG_DEVID, &devid);\n\tif (ret)\n\t\treturn ret;\n\n\tdevid = FIELD_GET(RT9120_VID_MASK, devid);\n\tswitch (devid) {\n\tcase RT9120_VENDOR_ID:\n\t\tdata->chip_idx = CHIP_IDX_RT9120;\n\t\tbreak;\n\tcase RT9120S_VENDOR_ID:\n\t\tdata->chip_idx = CHIP_IDX_RT9120S;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(data->dev, \"DEVID not correct [0x%0x]\\n\", devid);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt9120_do_register_reset(struct rt9120_data *data)\n{\n\tint ret;\n\n\tret = regmap_write(data->regmap, RT9120_REG_SWRESET,\n\t\t\t   RT9120_SWRST_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(RT9120_RESET_WAITMS);\n\treturn 0;\n}\n\nstatic int rt9120_probe(struct i2c_client *i2c)\n{\n\tstruct rt9120_data *data;\n\tstruct regulator *dvdd_supply;\n\tint dvdd_supply_volt, ret;\n\n\tdata = devm_kzalloc(&i2c->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &i2c->dev;\n\ti2c_set_clientdata(i2c, data);\n\n\tdata->pwdnn_gpio = devm_gpiod_get_optional(&i2c->dev, \"pwdnn\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(data->pwdnn_gpio)) {\n\t\tdev_err(&i2c->dev, \"Failed to initialize 'pwdnn' gpio\\n\");\n\t\treturn PTR_ERR(data->pwdnn_gpio);\n\t} else if (data->pwdnn_gpio) {\n\t\tdev_dbg(&i2c->dev, \"'pwdnn' from low to high, wait chip on\\n\");\n\t\tmsleep(RT9120_CHIPON_WAITMS);\n\t}\n\n\tdata->regmap = devm_regmap_init(&i2c->dev, NULL, data,\n\t\t\t\t\t&rt9120_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap [%d]\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rt9120_check_vendor_info(data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to check vendor info\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rt9120_do_register_reset(data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to do register reset\\n\");\n\t\treturn ret;\n\t}\n\n\tdvdd_supply = devm_regulator_get(&i2c->dev, \"dvdd\");\n\tif (IS_ERR(dvdd_supply)) {\n\t\tdev_err(&i2c->dev, \"No dvdd regulator found\\n\");\n\t\treturn PTR_ERR(dvdd_supply);\n\t}\n\n\tdvdd_supply_volt = regulator_get_voltage(dvdd_supply);\n\tif (dvdd_supply_volt <= RT9120_LVAPP_THRESUV) {\n\t\tdev_dbg(&i2c->dev, \"dvdd low voltage design\\n\");\n\t\tret = regmap_update_bits(data->regmap, RT9120_REG_UVPOPT,\n\t\t\t\t\t RT9120_DVDD_UVSEL_MASK, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&i2c->dev, \"Failed to config dvdd uvsel\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&i2c->dev, 1000);\n\tpm_runtime_use_autosuspend(&i2c->dev);\n\tpm_runtime_set_active(&i2c->dev);\n\tpm_runtime_mark_last_busy(&i2c->dev);\n\tpm_runtime_enable(&i2c->dev);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t       &rt9120_component_driver,\n\t\t\t\t\t       &rt9120_dai, 1);\n}\n\nstatic void rt9120_remove(struct i2c_client *i2c)\n{\n\tpm_runtime_disable(&i2c->dev);\n\tpm_runtime_set_suspended(&i2c->dev);\n}\n\nstatic int __maybe_unused rt9120_runtime_suspend(struct device *dev)\n{\n\tstruct rt9120_data *data = dev_get_drvdata(dev);\n\n\tif (data->pwdnn_gpio) {\n\t\tregcache_cache_only(data->regmap, true);\n\t\tregcache_mark_dirty(data->regmap);\n\t\tgpiod_set_value(data->pwdnn_gpio, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt9120_runtime_resume(struct device *dev)\n{\n\tstruct rt9120_data *data = dev_get_drvdata(dev);\n\n\tif (data->pwdnn_gpio) {\n\t\tgpiod_set_value(data->pwdnn_gpio, 1);\n\t\tmsleep(RT9120_CHIPON_WAITMS);\n\t\tregcache_cache_only(data->regmap, false);\n\t\tregcache_sync(data->regmap);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt9120_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rt9120_runtime_suspend, rt9120_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id __maybe_unused rt9120_device_table[] = {\n\t{ .compatible = \"richtek,rt9120\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rt9120_device_table);\n\nstatic struct i2c_driver rt9120_driver = {\n\t.driver = {\n\t\t.name = \"rt9120\",\n\t\t.of_match_table = rt9120_device_table,\n\t\t.pm = &rt9120_pm_ops,\n\t},\n\t.probe = rt9120_probe,\n\t.remove = rt9120_remove,\n};\nmodule_i2c_driver(rt9120_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"RT9120 Audio Amplifier Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}