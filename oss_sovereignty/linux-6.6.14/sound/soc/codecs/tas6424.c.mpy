{
  "module_name": "tas6424.c",
  "hash_id": "a47385c3e21b99f1a78ea131090d16207ac66799fef488ed8411a2a86aafd076",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas6424.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"tas6424.h\"\n\n \n#define TAS6424_FAULT_CHECK_INTERVAL 200\n\nstatic const char * const tas6424_supply_names[] = {\n\t\"dvdd\",  \n\t\"vbat\",  \n\t\"pvdd\",  \n};\n#define TAS6424_NUM_SUPPLIES ARRAY_SIZE(tas6424_supply_names)\n\nstruct tas6424_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[TAS6424_NUM_SUPPLIES];\n\tstruct delayed_work fault_check_work;\n\tunsigned int last_cfault;\n\tunsigned int last_fault1;\n\tunsigned int last_fault2;\n\tunsigned int last_warn;\n\tstruct gpio_desc *standby_gpio;\n\tstruct gpio_desc *mute_gpio;\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -10350, 50, 0);\n\nstatic const struct snd_kcontrol_new tas6424_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Driver CH1 Playback Volume\",\n\t\t       TAS6424_CH1_VOL_CTRL, 0, 0xff, 0, dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver CH2 Playback Volume\",\n\t\t       TAS6424_CH2_VOL_CTRL, 0, 0xff, 0, dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver CH3 Playback Volume\",\n\t\t       TAS6424_CH3_VOL_CTRL, 0, 0xff, 0, dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver CH4 Playback Volume\",\n\t\t       TAS6424_CH4_VOL_CTRL, 0, 0xff, 0, dac_tlv),\n\tSOC_SINGLE_STROBE(\"Auto Diagnostics Switch\", TAS6424_DC_DIAG_CTRL1,\n\t\t\t  TAS6424_LDGBYPASS_SHIFT, 1),\n};\n\nstatic int tas6424_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct tas6424_data *tas6424 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s() event=0x%0x\\n\", __func__, event);\n\n\tif (event & SND_SOC_DAPM_POST_PMU) {\n\t\t \n\t\tmsleep(12);\n\n\t\t \n\t\ttas6424->last_fault1 = 0;\n\t\ttas6424->last_fault2 = 0;\n\t\ttas6424->last_warn = 0;\n\t\tschedule_delayed_work(&tas6424->fault_check_work,\n\t\t\t\t      msecs_to_jiffies(TAS6424_FAULT_CHECK_INTERVAL));\n\t} else if (event & SND_SOC_DAPM_PRE_PMD) {\n\t\t \n\t\tcancel_delayed_work_sync(&tas6424->fault_check_work);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget tas6424_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"DAC IN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0, tas6424_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\")\n};\n\nstatic const struct snd_soc_dapm_route tas6424_audio_map[] = {\n\t{ \"DAC\", NULL, \"DAC IN\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n};\n\nstatic int tas6424_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int rate = params_rate(params);\n\tunsigned int width = params_width(params);\n\tu8 sap_ctrl = 0;\n\n\tdev_dbg(component->dev, \"%s() rate=%u width=%u\\n\", __func__, rate, width);\n\n\tswitch (rate) {\n\tcase 44100:\n\t\tsap_ctrl |= TAS6424_SAP_RATE_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsap_ctrl |= TAS6424_SAP_RATE_48000;\n\t\tbreak;\n\tcase 96000:\n\t\tsap_ctrl |= TAS6424_SAP_RATE_96000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported sample rate: %u\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (width) {\n\tcase 16:\n\t\tsap_ctrl |= TAS6424_SAP_TDM_SLOT_SZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported sample width: %u\\n\", width);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, TAS6424_SAP_CTRL,\n\t\t\t    TAS6424_SAP_RATE_MASK |\n\t\t\t    TAS6424_SAP_TDM_SLOT_SZ_16,\n\t\t\t    sap_ctrl);\n\n\treturn 0;\n}\n\nstatic int tas6424_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 serial_format = 0;\n\n\tdev_dbg(component->dev, \"%s() fmt=0x%0x\\n\", __func__, fmt);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clocking\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock signal polarity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tserial_format |= TAS6424_SAP_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tserial_format |= TAS6424_SAP_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tserial_format |= TAS6424_SAP_LEFTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tserial_format |= TAS6424_SAP_LEFTJ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI interface format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, TAS6424_SAP_CTRL,\n\t\t\t    TAS6424_SAP_FMT_MASK, serial_format);\n\n\treturn 0;\n}\n\nstatic int tas6424_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int first_slot, last_slot;\n\tbool sap_tdm_slot_last;\n\n\tdev_dbg(component->dev, \"%s() tx_mask=%d rx_mask=%d\\n\", __func__,\n\t\ttx_mask, rx_mask);\n\n\tif (!tx_mask || !rx_mask)\n\t\treturn 0;  \n\n\t \n\tfirst_slot = __ffs(tx_mask);\n\tlast_slot = __fls(rx_mask);\n\n\tif (last_slot - first_slot != 4) {\n\t\tdev_err(component->dev, \"tdm mask must cover 4 contiguous slots\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (first_slot) {\n\tcase 0:\n\t\tsap_tdm_slot_last = false;\n\t\tbreak;\n\tcase 4:\n\t\tsap_tdm_slot_last = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"tdm mask must start at slot 0 or 4\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, TAS6424_SAP_CTRL, TAS6424_SAP_TDM_SLOT_LAST,\n\t\t\t    sap_tdm_slot_last ? TAS6424_SAP_TDM_SLOT_LAST : 0);\n\n\treturn 0;\n}\n\nstatic int tas6424_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas6424_data *tas6424 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tdev_dbg(component->dev, \"%s() mute=%d\\n\", __func__, mute);\n\n\tif (tas6424->mute_gpio) {\n\t\tgpiod_set_value_cansleep(tas6424->mute_gpio, mute);\n\t\treturn 0;\n\t}\n\n\tif (mute)\n\t\tval = TAS6424_ALL_STATE_MUTE;\n\telse\n\t\tval = TAS6424_ALL_STATE_PLAY;\n\n\tsnd_soc_component_write(component, TAS6424_CH_STATE_CTRL, val);\n\n\treturn 0;\n}\n\nstatic int tas6424_power_off(struct snd_soc_component *component)\n{\n\tstruct tas6424_data *tas6424 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tsnd_soc_component_write(component, TAS6424_CH_STATE_CTRL, TAS6424_ALL_STATE_HIZ);\n\n\tregcache_cache_only(tas6424->regmap, true);\n\tregcache_mark_dirty(tas6424->regmap);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(tas6424->supplies),\n\t\t\t\t     tas6424->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to disable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tas6424_power_on(struct snd_soc_component *component)\n{\n\tstruct tas6424_data *tas6424 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tu8 chan_states;\n\tint no_auto_diags = 0;\n\tunsigned int reg_val;\n\n\tif (!regmap_read(tas6424->regmap, TAS6424_DC_DIAG_CTRL1, &reg_val))\n\t\tno_auto_diags = reg_val & TAS6424_LDGBYPASS_MASK;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas6424->supplies),\n\t\t\t\t    tas6424->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(tas6424->regmap, false);\n\n\tret = regcache_sync(tas6424->regmap);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to sync regcache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (tas6424->mute_gpio) {\n\t\tgpiod_set_value_cansleep(tas6424->mute_gpio, 0);\n\t\t \n\t\tchan_states = TAS6424_ALL_STATE_PLAY;\n\t} else {\n\t\tchan_states = TAS6424_ALL_STATE_MUTE;\n\t}\n\tsnd_soc_component_write(component, TAS6424_CH_STATE_CTRL, chan_states);\n\n\t \n\tif (!no_auto_diags)\n\t\tmsleep(230);\n\n\treturn 0;\n}\n\nstatic int tas6424_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tdev_dbg(component->dev, \"%s() level=%d\\n\", __func__, level);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\ttas6424_power_on(component);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\ttas6424_power_off(component);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_component_driver soc_codec_dev_tas6424 = {\n\t.set_bias_level\t\t= tas6424_set_bias_level,\n\t.controls\t\t= tas6424_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas6424_snd_controls),\n\t.dapm_widgets\t\t= tas6424_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas6424_dapm_widgets),\n\t.dapm_routes\t\t= tas6424_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas6424_audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops tas6424_speaker_dai_ops = {\n\t.hw_params\t= tas6424_hw_params,\n\t.set_fmt\t= tas6424_set_dai_fmt,\n\t.set_tdm_slot\t= tas6424_set_dai_tdm_slot,\n\t.mute_stream\t= tas6424_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver tas6424_dai[] = {\n\t{\n\t\t.name = \"tas6424-amplifier\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = TAS6424_RATES,\n\t\t\t.formats = TAS6424_FORMATS,\n\t\t},\n\t\t.ops = &tas6424_speaker_dai_ops,\n\t},\n};\n\nstatic void tas6424_fault_check_work(struct work_struct *work)\n{\n\tstruct tas6424_data *tas6424 = container_of(work, struct tas6424_data,\n\t\t\t\t\t\t    fault_check_work.work);\n\tstruct device *dev = tas6424->dev;\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(tas6424->regmap, TAS6424_CHANNEL_FAULT, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read CHANNEL_FAULT register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (!reg) {\n\t\ttas6424->last_cfault = reg;\n\t\tgoto check_global_fault1_reg;\n\t}\n\n\t \n\tif ((reg & TAS6424_FAULT_OC_CH1) && !(tas6424->last_cfault & TAS6424_FAULT_OC_CH1))\n\t\tdev_crit(dev, \"experienced a channel 1 overcurrent fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_OC_CH2) && !(tas6424->last_cfault & TAS6424_FAULT_OC_CH2))\n\t\tdev_crit(dev, \"experienced a channel 2 overcurrent fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_OC_CH3) && !(tas6424->last_cfault & TAS6424_FAULT_OC_CH3))\n\t\tdev_crit(dev, \"experienced a channel 3 overcurrent fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_OC_CH4) && !(tas6424->last_cfault & TAS6424_FAULT_OC_CH4))\n\t\tdev_crit(dev, \"experienced a channel 4 overcurrent fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_DC_CH1) && !(tas6424->last_cfault & TAS6424_FAULT_DC_CH1))\n\t\tdev_crit(dev, \"experienced a channel 1 DC fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_DC_CH2) && !(tas6424->last_cfault & TAS6424_FAULT_DC_CH2))\n\t\tdev_crit(dev, \"experienced a channel 2 DC fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_DC_CH3) && !(tas6424->last_cfault & TAS6424_FAULT_DC_CH3))\n\t\tdev_crit(dev, \"experienced a channel 3 DC fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_DC_CH4) && !(tas6424->last_cfault & TAS6424_FAULT_DC_CH4))\n\t\tdev_crit(dev, \"experienced a channel 4 DC fault\\n\");\n\n\t \n\ttas6424->last_cfault = reg;\n\ncheck_global_fault1_reg:\n\tret = regmap_read(tas6424->regmap, TAS6424_GLOB_FAULT1, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read GLOB_FAULT1 register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\treg &= TAS6424_FAULT_PVDD_OV |\n\t       TAS6424_FAULT_VBAT_OV |\n\t       TAS6424_FAULT_PVDD_UV |\n\t       TAS6424_FAULT_VBAT_UV;\n\n\tif (!reg) {\n\t\ttas6424->last_fault1 = reg;\n\t\tgoto check_global_fault2_reg;\n\t}\n\n\tif ((reg & TAS6424_FAULT_PVDD_OV) && !(tas6424->last_fault1 & TAS6424_FAULT_PVDD_OV))\n\t\tdev_crit(dev, \"experienced a PVDD overvoltage fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_VBAT_OV) && !(tas6424->last_fault1 & TAS6424_FAULT_VBAT_OV))\n\t\tdev_crit(dev, \"experienced a VBAT overvoltage fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_PVDD_UV) && !(tas6424->last_fault1 & TAS6424_FAULT_PVDD_UV))\n\t\tdev_crit(dev, \"experienced a PVDD undervoltage fault\\n\");\n\n\tif ((reg & TAS6424_FAULT_VBAT_UV) && !(tas6424->last_fault1 & TAS6424_FAULT_VBAT_UV))\n\t\tdev_crit(dev, \"experienced a VBAT undervoltage fault\\n\");\n\n\t \n\ttas6424->last_fault1 = reg;\n\ncheck_global_fault2_reg:\n\tret = regmap_read(tas6424->regmap, TAS6424_GLOB_FAULT2, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read GLOB_FAULT2 register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\treg &= TAS6424_FAULT_OTSD |\n\t       TAS6424_FAULT_OTSD_CH1 |\n\t       TAS6424_FAULT_OTSD_CH2 |\n\t       TAS6424_FAULT_OTSD_CH3 |\n\t       TAS6424_FAULT_OTSD_CH4;\n\n\tif (!reg) {\n\t\ttas6424->last_fault2 = reg;\n\t\tgoto check_warn_reg;\n\t}\n\n\tif ((reg & TAS6424_FAULT_OTSD) && !(tas6424->last_fault2 & TAS6424_FAULT_OTSD))\n\t\tdev_crit(dev, \"experienced a global overtemp shutdown\\n\");\n\n\tif ((reg & TAS6424_FAULT_OTSD_CH1) && !(tas6424->last_fault2 & TAS6424_FAULT_OTSD_CH1))\n\t\tdev_crit(dev, \"experienced an overtemp shutdown on CH1\\n\");\n\n\tif ((reg & TAS6424_FAULT_OTSD_CH2) && !(tas6424->last_fault2 & TAS6424_FAULT_OTSD_CH2))\n\t\tdev_crit(dev, \"experienced an overtemp shutdown on CH2\\n\");\n\n\tif ((reg & TAS6424_FAULT_OTSD_CH3) && !(tas6424->last_fault2 & TAS6424_FAULT_OTSD_CH3))\n\t\tdev_crit(dev, \"experienced an overtemp shutdown on CH3\\n\");\n\n\tif ((reg & TAS6424_FAULT_OTSD_CH4) && !(tas6424->last_fault2 & TAS6424_FAULT_OTSD_CH4))\n\t\tdev_crit(dev, \"experienced an overtemp shutdown on CH4\\n\");\n\n\t \n\ttas6424->last_fault2 = reg;\n\ncheck_warn_reg:\n\tret = regmap_read(tas6424->regmap, TAS6424_WARN, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read WARN register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\treg &= TAS6424_WARN_VDD_UV |\n\t       TAS6424_WARN_VDD_POR |\n\t       TAS6424_WARN_VDD_OTW |\n\t       TAS6424_WARN_VDD_OTW_CH1 |\n\t       TAS6424_WARN_VDD_OTW_CH2 |\n\t       TAS6424_WARN_VDD_OTW_CH3 |\n\t       TAS6424_WARN_VDD_OTW_CH4;\n\n\tif (!reg) {\n\t\ttas6424->last_warn = reg;\n\t\tgoto out;\n\t}\n\n\tif ((reg & TAS6424_WARN_VDD_UV) && !(tas6424->last_warn & TAS6424_WARN_VDD_UV))\n\t\tdev_warn(dev, \"experienced a VDD under voltage condition\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_POR) && !(tas6424->last_warn & TAS6424_WARN_VDD_POR))\n\t\tdev_warn(dev, \"experienced a VDD POR condition\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_OTW) && !(tas6424->last_warn & TAS6424_WARN_VDD_OTW))\n\t\tdev_warn(dev, \"experienced a global overtemp warning\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_OTW_CH1) && !(tas6424->last_warn & TAS6424_WARN_VDD_OTW_CH1))\n\t\tdev_warn(dev, \"experienced an overtemp warning on CH1\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_OTW_CH2) && !(tas6424->last_warn & TAS6424_WARN_VDD_OTW_CH2))\n\t\tdev_warn(dev, \"experienced an overtemp warning on CH2\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_OTW_CH3) && !(tas6424->last_warn & TAS6424_WARN_VDD_OTW_CH3))\n\t\tdev_warn(dev, \"experienced an overtemp warning on CH3\\n\");\n\n\tif ((reg & TAS6424_WARN_VDD_OTW_CH4) && !(tas6424->last_warn & TAS6424_WARN_VDD_OTW_CH4))\n\t\tdev_warn(dev, \"experienced an overtemp warning on CH4\\n\");\n\n\t \n\ttas6424->last_warn = reg;\n\n\t \n\tret = regmap_write_bits(tas6424->regmap, TAS6424_MISC_CTRL3,\n\t\t\t\tTAS6424_CLEAR_FAULT, TAS6424_CLEAR_FAULT);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write MISC_CTRL3 register: %d\\n\", ret);\n\n\tret = regmap_write_bits(tas6424->regmap, TAS6424_MISC_CTRL3,\n\t\t\t\tTAS6424_CLEAR_FAULT, 0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write MISC_CTRL3 register: %d\\n\", ret);\n\nout:\n\t \n\tschedule_delayed_work(&tas6424->fault_check_work,\n\t\t\t      msecs_to_jiffies(TAS6424_FAULT_CHECK_INTERVAL));\n}\n\nstatic const struct reg_default tas6424_reg_defaults[] = {\n\t{ TAS6424_MODE_CTRL,\t\t0x00 },\n\t{ TAS6424_MISC_CTRL1,\t\t0x32 },\n\t{ TAS6424_MISC_CTRL2,\t\t0x62 },\n\t{ TAS6424_SAP_CTRL,\t\t0x04 },\n\t{ TAS6424_CH_STATE_CTRL,\t0x55 },\n\t{ TAS6424_CH1_VOL_CTRL,\t\t0xcf },\n\t{ TAS6424_CH2_VOL_CTRL,\t\t0xcf },\n\t{ TAS6424_CH3_VOL_CTRL,\t\t0xcf },\n\t{ TAS6424_CH4_VOL_CTRL,\t\t0xcf },\n\t{ TAS6424_DC_DIAG_CTRL1,\t0x00 },\n\t{ TAS6424_DC_DIAG_CTRL2,\t0x11 },\n\t{ TAS6424_DC_DIAG_CTRL3,\t0x11 },\n\t{ TAS6424_PIN_CTRL,\t\t0xff },\n\t{ TAS6424_AC_DIAG_CTRL1,\t0x00 },\n\t{ TAS6424_MISC_CTRL3,\t\t0x00 },\n\t{ TAS6424_CLIP_CTRL,\t\t0x01 },\n\t{ TAS6424_CLIP_WINDOW,\t\t0x14 },\n\t{ TAS6424_CLIP_WARN,\t\t0x00 },\n\t{ TAS6424_CBC_STAT,\t\t0x00 },\n\t{ TAS6424_MISC_CTRL4,\t\t0x40 },\n};\n\nstatic bool tas6424_is_writable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS6424_MODE_CTRL:\n\tcase TAS6424_MISC_CTRL1:\n\tcase TAS6424_MISC_CTRL2:\n\tcase TAS6424_SAP_CTRL:\n\tcase TAS6424_CH_STATE_CTRL:\n\tcase TAS6424_CH1_VOL_CTRL:\n\tcase TAS6424_CH2_VOL_CTRL:\n\tcase TAS6424_CH3_VOL_CTRL:\n\tcase TAS6424_CH4_VOL_CTRL:\n\tcase TAS6424_DC_DIAG_CTRL1:\n\tcase TAS6424_DC_DIAG_CTRL2:\n\tcase TAS6424_DC_DIAG_CTRL3:\n\tcase TAS6424_PIN_CTRL:\n\tcase TAS6424_AC_DIAG_CTRL1:\n\tcase TAS6424_MISC_CTRL3:\n\tcase TAS6424_CLIP_CTRL:\n\tcase TAS6424_CLIP_WINDOW:\n\tcase TAS6424_CLIP_WARN:\n\tcase TAS6424_CBC_STAT:\n\tcase TAS6424_MISC_CTRL4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tas6424_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS6424_DC_LOAD_DIAG_REP12:\n\tcase TAS6424_DC_LOAD_DIAG_REP34:\n\tcase TAS6424_DC_LOAD_DIAG_REPLO:\n\tcase TAS6424_CHANNEL_STATE:\n\tcase TAS6424_CHANNEL_FAULT:\n\tcase TAS6424_GLOB_FAULT1:\n\tcase TAS6424_GLOB_FAULT2:\n\tcase TAS6424_WARN:\n\tcase TAS6424_AC_LOAD_DIAG_REP1:\n\tcase TAS6424_AC_LOAD_DIAG_REP2:\n\tcase TAS6424_AC_LOAD_DIAG_REP3:\n\tcase TAS6424_AC_LOAD_DIAG_REP4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tas6424_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.writeable_reg = tas6424_is_writable_reg,\n\t.volatile_reg = tas6424_is_volatile_reg,\n\n\t.max_register = TAS6424_MAX,\n\t.reg_defaults = tas6424_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(tas6424_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tas6424_of_ids[] = {\n\t{ .compatible = \"ti,tas6424\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tas6424_of_ids);\n#endif\n\nstatic int tas6424_i2c_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tas6424_data *tas6424;\n\tint ret;\n\tint i;\n\n\ttas6424 = devm_kzalloc(dev, sizeof(*tas6424), GFP_KERNEL);\n\tif (!tas6424)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(dev, tas6424);\n\n\ttas6424->dev = dev;\n\n\ttas6424->regmap = devm_regmap_init_i2c(client, &tas6424_regmap_config);\n\tif (IS_ERR(tas6424->regmap)) {\n\t\tret = PTR_ERR(tas6424->regmap);\n\t\tdev_err(dev, \"unable to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\ttas6424->standby_gpio = devm_gpiod_get_optional(dev, \"standby\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(tas6424->standby_gpio)) {\n\t\tif (PTR_ERR(tas6424->standby_gpio) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(dev, \"failed to get standby GPIO: %ld\\n\",\n\t\t\tPTR_ERR(tas6424->standby_gpio));\n\t\ttas6424->standby_gpio = NULL;\n\t}\n\n\t \n\ttas6424->mute_gpio = devm_gpiod_get_optional(dev, \"mute\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(tas6424->mute_gpio)) {\n\t\tif (PTR_ERR(tas6424->mute_gpio) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(dev, \"failed to get nmute GPIO: %ld\\n\",\n\t\t\tPTR_ERR(tas6424->mute_gpio));\n\t\ttas6424->mute_gpio = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tas6424->supplies); i++)\n\t\ttas6424->supplies[i].supply = tas6424_supply_names[i];\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(tas6424->supplies),\n\t\t\t\t      tas6424->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas6424->supplies),\n\t\t\t\t    tas6424->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(tas6424->regmap, TAS6424_MODE_CTRL,\n\t\t\t\t TAS6424_RESET, TAS6424_RESET);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to reset device: %d\\n\", ret);\n\t\tgoto disable_regs;\n\t}\n\n\tINIT_DELAYED_WORK(&tas6424->fault_check_work, tas6424_fault_check_work);\n\n\tret = devm_snd_soc_register_component(dev, &soc_codec_dev_tas6424,\n\t\t\t\t     tas6424_dai, ARRAY_SIZE(tas6424_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register codec: %d\\n\", ret);\n\t\tgoto disable_regs;\n\t}\n\n\treturn 0;\n\ndisable_regs:\n\tregulator_bulk_disable(ARRAY_SIZE(tas6424->supplies), tas6424->supplies);\n\treturn ret;\n}\n\nstatic void tas6424_i2c_remove(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tas6424_data *tas6424 = dev_get_drvdata(dev);\n\tint ret;\n\n\tcancel_delayed_work_sync(&tas6424->fault_check_work);\n\n\t \n\tif (tas6424->standby_gpio)\n\t\tgpiod_set_value_cansleep(tas6424->standby_gpio, 1);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(tas6424->supplies),\n\t\t\t\t     tas6424->supplies);\n\tif (ret < 0)\n\t\tdev_err(dev, \"unable to disable supplies: %d\\n\", ret);\n}\n\nstatic const struct i2c_device_id tas6424_i2c_ids[] = {\n\t{ \"tas6424\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas6424_i2c_ids);\n\nstatic struct i2c_driver tas6424_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas6424\",\n\t\t.of_match_table = of_match_ptr(tas6424_of_ids),\n\t},\n\t.probe = tas6424_i2c_probe,\n\t.remove = tas6424_i2c_remove,\n\t.id_table = tas6424_i2c_ids,\n};\nmodule_i2c_driver(tas6424_i2c_driver);\n\nMODULE_AUTHOR(\"Andreas Dannenberg <dannenberg@ti.com>\");\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"TAS6424 Audio amplifier driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}