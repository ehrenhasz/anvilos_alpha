{
  "module_name": "tas5805m.c",
  "hash_id": "b1fa6274a02fecdcdcc8d5deb064497c748bbc4090c6c0571cf08942512a2915",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas5805m.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/atomic.h>\n#include <linux/workqueue.h>\n\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n\n \n#define REG_PAGE\t\t0x00\n#define REG_DEVICE_CTRL_1\t0x02\n#define REG_DEVICE_CTRL_2\t0x03\n#define REG_SIG_CH_CTRL\t\t0x28\n#define REG_SAP_CTRL_1\t\t0x33\n#define REG_FS_MON\t\t0x37\n#define REG_BCK_MON\t\t0x38\n#define REG_CLKDET_STATUS\t0x39\n#define REG_VOL_CTL\t\t0x4c\n#define REG_AGAIN\t\t0x54\n#define REG_ADR_PIN_CTRL\t0x60\n#define REG_ADR_PIN_CONFIG\t0x61\n#define REG_CHAN_FAULT\t\t0x70\n#define REG_GLOBAL_FAULT1\t0x71\n#define REG_GLOBAL_FAULT2\t0x72\n#define REG_FAULT\t\t0x78\n#define REG_BOOK\t\t0x7f\n\n \n#define DCTRL2_MODE_DEEP_SLEEP\t0x00\n#define DCTRL2_MODE_SLEEP\t0x01\n#define DCTRL2_MODE_HIZ\t\t0x02\n#define DCTRL2_MODE_PLAY\t0x03\n\n#define DCTRL2_MUTE\t\t0x08\n#define DCTRL2_DIS_DSP\t\t0x10\n\n \nstatic const uint8_t dsp_cfg_preboot[] = {\n\t0x00, 0x00, 0x7f, 0x00, 0x03, 0x02, 0x01, 0x11,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x7f, 0x00, 0x03, 0x02,\n};\n\nstatic const uint32_t tas5805m_volume[] = {\n\t0x0000001B,   0x0000001E,  \n\t0x00000021,   0x00000025,  \n\t0x0000002A,   0x0000002F,  \n\t0x00000035,   0x0000003B,  \n\t0x00000043,   0x0000004B,  \n\t0x00000054,   0x0000005E,  \n\t0x0000006A,   0x00000076,  \n\t0x00000085,   0x00000095,  \n\t0x000000A7,   0x000000BC,  \n\t0x000000D3,   0x000000EC,  \n\t0x00000109,   0x0000012A,  \n\t0x0000014E,   0x00000177,  \n\t0x000001A4,   0x000001D8,  \n\t0x00000211,   0x00000252,  \n\t0x0000029A,   0x000002EC,  \n\t0x00000347,   0x000003AD,  \n\t0x00000420,   0x000004A1,  \n\t0x00000532,   0x000005D4,  \n\t0x0000068A,   0x00000756,  \n\t0x0000083B,   0x0000093C,  \n\t0x00000A5D,   0x00000BA0,  \n\t0x00000D0C,   0x00000EA3,  \n\t0x0000106C,   0x0000126D,  \n\t0x000014AD,   0x00001733,  \n\t0x00001A07,   0x00001D34,  \n\t0x000020C5,   0x000024C4,  \n\t0x00002941,   0x00002E49,  \n\t0x000033EF,   0x00003A45,  \n\t0x00004161,   0x0000495C,  \n\t0x0000524F,   0x00005C5A,  \n\t0x0000679F,   0x00007444,  \n\t0x00008274,   0x0000925F,  \n\t0x0000A43B,   0x0000B845,  \n\t0x0000CEC1,   0x0000E7FB,  \n\t0x00010449,   0x0001240C,  \n\t0x000147AE,   0x00016FAA,  \n\t0x00019C86,   0x0001CEDC,  \n\t0x00020756,   0x000246B5,  \n\t0x00028DCF,   0x0002DD96,  \n\t0x00033718,   0x00039B87,  \n\t0x00040C37,   0x00048AA7,  \n\t0x00051884,   0x0005B7B1,  \n\t0x00066A4A,   0x000732AE,  \n\t0x00081385,   0x00090FCC,  \n\t0x000A2ADB,   0x000B6873,  \n\t0x000CCCCD,   0x000E5CA1,  \n\t0x00101D3F,   0x0012149A,  \n\t0x00144961,   0x0016C311,  \n\t0x00198A13,   0x001CA7D7,  \n\t0x002026F3,   0x00241347,  \n\t0x00287A27,   0x002D6A86,  \n\t0x0032F52D,   0x00392CEE,  \n\t0x004026E7,   0x0047FACD,  \n\t0x0050C336,   0x005A9DF8,  \n\t0x0065AC8C,   0x00721483,  \n\t0x00800000,   0x008F9E4D,  \n\t0x00A12478,   0x00B4CE08,  \n\t0x00CADDC8,   0x00E39EA9,  \n\t0x00FF64C1,   0x011E8E6A,  \n\t0x0141857F,   0x0168C0C6,  \n\t0x0194C584,   0x01C62940,  \n\t0x01FD93C2,   0x023BC148,  \n\t0x02818508,   0x02CFCC01,  \n\t0x0327A01A,   0x038A2BAD,  \n\t0x03F8BD7A,   0x0474CD1B,  \n\t0x05000000,   0x059C2F02,  \n\t0x064B6CAE,   0x07100C4D,  \n\t0x07ECA9CD,   0x08E43299,  \n\t0x09F9EF8E,   0x0B319025,  \n\t0x0C8F36F2,   0x0E1787B8,  \n\t0x0FCFB725,   0x11BD9C84,  \n\t0x13E7C594,   0x16558CCB,  \n\t0x190F3254,   0x1C1DF80E,  \n\t0x1F8C4107,   0x2365B4BF,  \n\t0x27B766C2,   0x2C900313,  \n\t0x32000000,   0x3819D612,  \n\t0x3EF23ECA,   0x46A07B07,  \n\t0x4F3EA203,   0x58E9F9F9,  \n\t0x63C35B8E,   0x6FEFA16D,  \n\t0x7D982575,  \n};\n\n#define TAS5805M_VOLUME_MAX\t((int)ARRAY_SIZE(tas5805m_volume) - 1)\n#define TAS5805M_VOLUME_MIN\t0\n\nstruct tas5805m_priv {\n\tstruct i2c_client\t\t*i2c;\n\tstruct regulator\t\t*pvdd;\n\tstruct gpio_desc\t\t*gpio_pdn_n;\n\n\tuint8_t\t\t\t\t*dsp_cfg_data;\n\tint\t\t\t\tdsp_cfg_len;\n\n\tstruct regmap\t\t\t*regmap;\n\n\tint\t\t\t\tvol[2];\n\tbool\t\t\t\tis_powered;\n\tbool\t\t\t\tis_muted;\n\n\tstruct work_struct\t\twork;\n\tstruct mutex\t\t\tlock;\n};\n\nstatic void set_dsp_scale(struct regmap *rm, int offset, int vol)\n{\n\tuint8_t v[4];\n\tuint32_t x = tas5805m_volume[vol];\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tv[3 - i] = x;\n\t\tx >>= 8;\n\t}\n\n\tregmap_bulk_write(rm, offset, v, ARRAY_SIZE(v));\n}\n\nstatic void tas5805m_refresh(struct tas5805m_priv *tas5805m)\n{\n\tstruct regmap *rm = tas5805m->regmap;\n\n\tdev_dbg(&tas5805m->i2c->dev, \"refresh: is_muted=%d, vol=%d/%d\\n\",\n\t\ttas5805m->is_muted, tas5805m->vol[0], tas5805m->vol[1]);\n\n\tregmap_write(rm, REG_PAGE, 0x00);\n\tregmap_write(rm, REG_BOOK, 0x8c);\n\tregmap_write(rm, REG_PAGE, 0x2a);\n\n\t \n\tset_dsp_scale(rm, 0x24, tas5805m->vol[0]);\n\tset_dsp_scale(rm, 0x28, tas5805m->vol[1]);\n\n\tregmap_write(rm, REG_PAGE, 0x00);\n\tregmap_write(rm, REG_BOOK, 0x00);\n\n\t \n\tregmap_write(rm, REG_DEVICE_CTRL_2,\n\t\t(tas5805m->is_muted ? DCTRL2_MUTE : 0) |\n\t\tDCTRL2_MODE_PLAY);\n}\n\nstatic int tas5805m_vol_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 2;\n\n\tuinfo->value.integer.min = TAS5805M_VOLUME_MIN;\n\tuinfo->value.integer.max = TAS5805M_VOLUME_MAX;\n\treturn 0;\n}\n\nstatic int tas5805m_vol_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tas5805m_priv *tas5805m =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&tas5805m->lock);\n\tucontrol->value.integer.value[0] = tas5805m->vol[0];\n\tucontrol->value.integer.value[1] = tas5805m->vol[1];\n\tmutex_unlock(&tas5805m->lock);\n\n\treturn 0;\n}\n\nstatic inline int volume_is_valid(int v)\n{\n\treturn (v >= TAS5805M_VOLUME_MIN) && (v <= TAS5805M_VOLUME_MAX);\n}\n\nstatic int tas5805m_vol_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tas5805m_priv *tas5805m =\n\t\tsnd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (!(volume_is_valid(ucontrol->value.integer.value[0]) &&\n\t      volume_is_valid(ucontrol->value.integer.value[1])))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&tas5805m->lock);\n\tif (tas5805m->vol[0] != ucontrol->value.integer.value[0] ||\n\t    tas5805m->vol[1] != ucontrol->value.integer.value[1]) {\n\t\ttas5805m->vol[0] = ucontrol->value.integer.value[0];\n\t\ttas5805m->vol[1] = ucontrol->value.integer.value[1];\n\t\tdev_dbg(component->dev, \"set vol=%d/%d (is_powered=%d)\\n\",\n\t\t\ttas5805m->vol[0], tas5805m->vol[1],\n\t\t\ttas5805m->is_powered);\n\t\tif (tas5805m->is_powered)\n\t\t\ttas5805m_refresh(tas5805m);\n\t\tret = 1;\n\t}\n\tmutex_unlock(&tas5805m->lock);\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new tas5805m_snd_controls[] = {\n\t{\n\t\t.iface\t= SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name\t= \"Master Playback Volume\",\n\t\t.access\t= SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info\t= tas5805m_vol_info,\n\t\t.get\t= tas5805m_vol_get,\n\t\t.put\t= tas5805m_vol_put,\n\t},\n};\n\nstatic void send_cfg(struct regmap *rm,\n\t\t     const uint8_t *s, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i + 1 < len; i += 2)\n\t\tregmap_write(rm, s[i], s[i + 1]);\n}\n\n \nstatic int tas5805m_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas5805m_priv *tas5805m =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tdev_dbg(component->dev, \"clock start\\n\");\n\t\tschedule_work(&tas5805m->work);\n\t\tbreak;\n\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void do_work(struct work_struct *work)\n{\n\tstruct tas5805m_priv *tas5805m =\n\t       container_of(work, struct tas5805m_priv, work);\n\tstruct regmap *rm = tas5805m->regmap;\n\n\tdev_dbg(&tas5805m->i2c->dev, \"DSP startup\\n\");\n\n\tmutex_lock(&tas5805m->lock);\n\t \n\tusleep_range(5000, 10000);\n\tsend_cfg(rm, dsp_cfg_preboot, ARRAY_SIZE(dsp_cfg_preboot));\n\tusleep_range(5000, 15000);\n\tsend_cfg(rm, tas5805m->dsp_cfg_data, tas5805m->dsp_cfg_len);\n\n\ttas5805m->is_powered = true;\n\ttas5805m_refresh(tas5805m);\n\tmutex_unlock(&tas5805m->lock);\n}\n\nstatic int tas5805m_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct tas5805m_priv *tas5805m =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct regmap *rm = tas5805m->regmap;\n\n\tif (event & SND_SOC_DAPM_PRE_PMD) {\n\t\tunsigned int chan, global1, global2;\n\n\t\tdev_dbg(component->dev, \"DSP shutdown\\n\");\n\t\tcancel_work_sync(&tas5805m->work);\n\n\t\tmutex_lock(&tas5805m->lock);\n\t\tif (tas5805m->is_powered) {\n\t\t\ttas5805m->is_powered = false;\n\n\t\t\tregmap_write(rm, REG_PAGE, 0x00);\n\t\t\tregmap_write(rm, REG_BOOK, 0x00);\n\n\t\t\tregmap_read(rm, REG_CHAN_FAULT, &chan);\n\t\t\tregmap_read(rm, REG_GLOBAL_FAULT1, &global1);\n\t\t\tregmap_read(rm, REG_GLOBAL_FAULT2, &global2);\n\n\t\t\tdev_dbg(component->dev, \"fault regs: CHAN=%02x, \"\n\t\t\t\t\"GLOBAL1=%02x, GLOBAL2=%02x\\n\",\n\t\t\t\tchan, global1, global2);\n\n\t\t\tregmap_write(rm, REG_DEVICE_CTRL_2, DCTRL2_MODE_HIZ);\n\t\t}\n\t\tmutex_unlock(&tas5805m->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_route tas5805m_audio_map[] = {\n\t{ \"DAC\", NULL, \"DAC IN\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n};\n\nstatic const struct snd_soc_dapm_widget tas5805m_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"DAC IN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0,\n\t\ttas5805m_dac_event, SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\")\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_tas5805m = {\n\t.controls\t\t= tas5805m_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas5805m_snd_controls),\n\t.dapm_widgets\t\t= tas5805m_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas5805m_dapm_widgets),\n\t.dapm_routes\t\t= tas5805m_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas5805m_audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int tas5805m_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas5805m_priv *tas5805m =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&tas5805m->lock);\n\tdev_dbg(component->dev, \"set mute=%d (is_powered=%d)\\n\",\n\t\tmute, tas5805m->is_powered);\n\n\ttas5805m->is_muted = mute;\n\tif (tas5805m->is_powered)\n\t\ttas5805m_refresh(tas5805m);\n\tmutex_unlock(&tas5805m->lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tas5805m_dai_ops = {\n\t.trigger\t\t= tas5805m_trigger,\n\t.mute_stream\t\t= tas5805m_mute,\n\t.no_capture_mute\t= 1,\n};\n\nstatic struct snd_soc_dai_driver tas5805m_dai = {\n\t.name\t\t= \"tas5805m-amplifier\",\n\t.playback\t= {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= SNDRV_PCM_RATE_48000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.ops\t\t= &tas5805m_dai_ops,\n};\n\nstatic const struct regmap_config tas5805m_regmap = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\n\t \n\t.cache_type\t= REGCACHE_NONE,\n};\n\nstatic int tas5805m_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct regmap *regmap;\n\tstruct tas5805m_priv *tas5805m;\n\tchar filename[128];\n\tconst char *config_name;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tregmap = devm_regmap_init_i2c(i2c, &tas5805m_regmap);\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"unable to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttas5805m = devm_kzalloc(dev, sizeof(struct tas5805m_priv), GFP_KERNEL);\n\tif (!tas5805m)\n\t\treturn -ENOMEM;\n\n\ttas5805m->i2c = i2c;\n\ttas5805m->pvdd = devm_regulator_get(dev, \"pvdd\");\n\tif (IS_ERR(tas5805m->pvdd)) {\n\t\tdev_err(dev, \"failed to get pvdd supply: %ld\\n\",\n\t\t\tPTR_ERR(tas5805m->pvdd));\n\t\treturn PTR_ERR(tas5805m->pvdd);\n\t}\n\n\tdev_set_drvdata(dev, tas5805m);\n\ttas5805m->regmap = regmap;\n\ttas5805m->gpio_pdn_n = devm_gpiod_get(dev, \"pdn\", GPIOD_OUT_LOW);\n\tif (IS_ERR(tas5805m->gpio_pdn_n)) {\n\t\tdev_err(dev, \"error requesting PDN gpio: %ld\\n\",\n\t\t\tPTR_ERR(tas5805m->gpio_pdn_n));\n\t\treturn PTR_ERR(tas5805m->gpio_pdn_n);\n\t}\n\n\t \n\tif (device_property_read_string(dev, \"ti,dsp-config-name\",\n\t\t\t\t\t&config_name))\n\t\tconfig_name = \"default\";\n\n\tsnprintf(filename, sizeof(filename), \"tas5805m_dsp_%s.bin\",\n\t\t config_name);\n\tret = request_firmware(&fw, filename, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((fw->size < 2) || (fw->size & 1)) {\n\t\tdev_err(dev, \"firmware is invalid\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -EINVAL;\n\t}\n\n\ttas5805m->dsp_cfg_len = fw->size;\n\ttas5805m->dsp_cfg_data = devm_kmemdup(dev, fw->data, fw->size, GFP_KERNEL);\n\tif (!tas5805m->dsp_cfg_data) {\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\trelease_firmware(fw);\n\n\t \n\ttas5805m->vol[0] = TAS5805M_VOLUME_MIN;\n\ttas5805m->vol[1] = TAS5805M_VOLUME_MIN;\n\n\tret = regulator_enable(tas5805m->pvdd);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable pvdd: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(100000, 150000);\n\tgpiod_set_value(tas5805m->gpio_pdn_n, 1);\n\tusleep_range(10000, 15000);\n\n\tINIT_WORK(&tas5805m->work, do_work);\n\tmutex_init(&tas5805m->lock);\n\n\t \n\tret = snd_soc_register_component(dev, &soc_codec_dev_tas5805m,\n\t\t\t\t\t &tas5805m_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"unable to register codec: %d\\n\", ret);\n\t\tgpiod_set_value(tas5805m->gpio_pdn_n, 0);\n\t\tregulator_disable(tas5805m->pvdd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void tas5805m_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct tas5805m_priv *tas5805m = dev_get_drvdata(dev);\n\n\tcancel_work_sync(&tas5805m->work);\n\tsnd_soc_unregister_component(dev);\n\tgpiod_set_value(tas5805m->gpio_pdn_n, 0);\n\tusleep_range(10000, 15000);\n\tregulator_disable(tas5805m->pvdd);\n}\n\nstatic const struct i2c_device_id tas5805m_i2c_id[] = {\n\t{ \"tas5805m\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas5805m_i2c_id);\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tas5805m_of_match[] = {\n\t{ .compatible = \"ti,tas5805m\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tas5805m_of_match);\n#endif\n\nstatic struct i2c_driver tas5805m_i2c_driver = {\n\t.probe\t\t= tas5805m_i2c_probe,\n\t.remove\t\t= tas5805m_i2c_remove,\n\t.id_table\t= tas5805m_i2c_id,\n\t.driver\t\t= {\n\t\t.name\t\t= \"tas5805m\",\n\t\t.of_match_table = of_match_ptr(tas5805m_of_match),\n\t},\n};\n\nmodule_i2c_driver(tas5805m_i2c_driver);\n\nMODULE_AUTHOR(\"Andy Liu <andy-liu@ti.com>\");\nMODULE_AUTHOR(\"Daniel Beer <daniel.beer@igorinstitute.com>\");\nMODULE_DESCRIPTION(\"TAS5805M Audio Amplifier Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}