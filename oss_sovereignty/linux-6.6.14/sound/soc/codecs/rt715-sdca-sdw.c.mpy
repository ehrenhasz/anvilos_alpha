{
  "module_name": "rt715-sdca-sdw.c",
  "hash_id": "90671a06b18df04cc1786f61b01ee42d264137cc9af42ae72803c337a0aab333",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt715-sdca-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"rt715-sdca.h\"\n#include \"rt715-sdca-sdw.h\"\n\nstatic bool rt715_sdca_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x201a ... 0x2027:\n\tcase 0x2029 ... 0x202a:\n\tcase 0x202d ... 0x2034:\n\tcase 0x2200 ... 0x2204:\n\tcase 0x2206 ... 0x2212:\n\tcase 0x2230 ... 0x2239:\n\tcase 0x2f5b:\n\tcase SDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_SMPU_TRIG_ST_EN,\n\t\tRT715_SDCA_SMPU_TRIG_ST_CTRL, CH_00):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt715_sdca_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x201b:\n\tcase 0x201c:\n\tcase 0x201d:\n\tcase 0x201f:\n\tcase 0x2021:\n\tcase 0x2023:\n\tcase 0x2230:\n\tcase 0x202d ... 0x202f:  \n\tcase 0x2200 ... 0x2212:  \n\tcase 0x2f07:\n\tcase 0x2f1b ... 0x2f1e:\n\tcase 0x2f30 ... 0x2f34:\n\tcase 0x2f50 ... 0x2f51:\n\tcase 0x2f53 ... 0x2f59:\n\tcase 0x2f5c ... 0x2f5f:\n\tcase SDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_SMPU_TRIG_ST_EN,\n\t\tRT715_SDCA_SMPU_TRIG_ST_CTRL, CH_00):  \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt715_sdca_mbq_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000:\n\tcase 0x200002b:\n\tcase 0x2000036:\n\tcase 0x2000037:\n\tcase 0x2000039:\n\tcase 0x2000044:\n\tcase 0x6100000:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt715_sdca_mbq_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt715_sdca_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt715_sdca_readable_register,\n\t.volatile_reg = rt715_sdca_volatile_register,\n\t.max_register = 0x43ffffff,\n\t.reg_defaults = rt715_reg_defaults_sdca,\n\t.num_reg_defaults = ARRAY_SIZE(rt715_reg_defaults_sdca),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct regmap_config rt715_sdca_mbq_regmap = {\n\t.name = \"sdw-mbq\",\n\t.reg_bits = 32,\n\t.val_bits = 16,\n\t.readable_reg = rt715_sdca_mbq_readable_register,\n\t.volatile_reg = rt715_sdca_mbq_volatile_register,\n\t.max_register = 0x43ffffff,\n\t.reg_defaults = rt715_mbq_reg_defaults_sdca,\n\t.num_reg_defaults = ARRAY_SIZE(rt715_mbq_reg_defaults_sdca),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt715_sdca_update_status(struct sdw_slave *slave,\n\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct rt715_sdca_priv *rt715 = dev_get_drvdata(&slave->dev);\n\n\t \n\tif (rt715->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt715_sdca_io_init(&slave->dev, slave);\n}\n\nstatic int rt715_sdca_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = 0x50; \n\tprop->sink_ports = 0x0;\t \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\tsizeof(*prop->src_dpn_prop),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tdpn = prop->src_dpn_prop;\n\ti = 0;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 200;\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops rt715_sdca_slave_ops = {\n\t.read_prop = rt715_sdca_read_prop,\n\t.update_status = rt715_sdca_update_status,\n};\n\nstatic int rt715_sdca_sdw_probe(struct sdw_slave *slave,\n\t\t\t   const struct sdw_device_id *id)\n{\n\tstruct regmap *mbq_regmap, *regmap;\n\n\t \n\tmbq_regmap = devm_regmap_init_sdw_mbq(slave, &rt715_sdca_mbq_regmap);\n\tif (IS_ERR(mbq_regmap))\n\t\treturn PTR_ERR(mbq_regmap);\n\n\tregmap = devm_regmap_init_sdw(slave, &rt715_sdca_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt715_sdca_init(&slave->dev, mbq_regmap, regmap, slave);\n}\n\nstatic int rt715_sdca_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt715_sdca_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x715, 0x3, 0x1, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x714, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt715_sdca_id);\n\nstatic int __maybe_unused rt715_dev_suspend(struct device *dev)\n{\n\tstruct rt715_sdca_priv *rt715 = dev_get_drvdata(dev);\n\n\tif (!rt715->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt715->regmap, true);\n\tregcache_mark_dirty(rt715->regmap);\n\tregcache_cache_only(rt715->mbq_regmap, true);\n\tregcache_mark_dirty(rt715->mbq_regmap);\n\n\treturn 0;\n}\n\n#define RT715_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt715_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt715_sdca_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt715->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->enumeration_complete,\n\t\t\t\t\t   msecs_to_jiffies(RT715_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Enumeration not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt715->regmap, false);\n\tregcache_sync_region(rt715->regmap,\n\t\tSDW_SDCA_CTL(FUN_JACK_CODEC, RT715_SDCA_ST_EN, RT715_SDCA_ST_CTRL,\n\t\t\tCH_00),\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_SMPU_TRIG_ST_EN,\n\t\t\tRT715_SDCA_SMPU_TRIG_ST_CTRL, CH_00));\n\tregcache_cache_only(rt715->mbq_regmap, false);\n\tregcache_sync_region(rt715->mbq_regmap, 0x2000000, 0x61020ff);\n\tregcache_sync_region(rt715->mbq_regmap,\n\t\tSDW_SDCA_CTL(FUN_JACK_CODEC, RT715_SDCA_ST_EN, RT715_SDCA_ST_CTRL,\n\t\t\tCH_00),\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_SMPU_TRIG_ST_EN,\n\t\t\tRT715_SDCA_SMPU_TRIG_ST_CTRL, CH_00));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt715_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt715_dev_suspend, rt715_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt715_dev_suspend, rt715_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt715_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt715-sdca\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt715_pm,\n\t},\n\t.probe = rt715_sdca_sdw_probe,\n\t.remove = rt715_sdca_sdw_remove,\n\t.ops = &rt715_sdca_slave_ops,\n\t.id_table = rt715_sdca_id,\n};\nmodule_sdw_driver(rt715_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT715 driver SDW SDCA\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}