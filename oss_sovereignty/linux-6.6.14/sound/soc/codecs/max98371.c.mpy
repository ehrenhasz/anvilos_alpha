{
  "module_name": "max98371.c",
  "hash_id": "0784713749c86761ff24a7cb09bf73d7a224c786dceb1691d9924a94205f3114",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98371.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"max98371.h\"\n\nstatic const char *const monomix_text[] = {\n\t\"Left\", \"Right\", \"LeftRightDiv2\",\n};\n\nstatic const char *const hpf_cutoff_txt[] = {\n\t\"Disable\", \"DC Block\", \"50Hz\",\n\t\"100Hz\", \"200Hz\", \"400Hz\", \"800Hz\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98371_monomix, MAX98371_MONOMIX_CFG, 0,\n\t\tmonomix_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98371_hpf_cutoff, MAX98371_HPF, 0,\n\t\thpf_cutoff_txt);\n\nstatic const DECLARE_TLV_DB_RANGE(max98371_dht_min_gain,\n\t0, 1, TLV_DB_SCALE_ITEM(537, 66, 0),\n\t2, 3, TLV_DB_SCALE_ITEM(677, 82, 0),\n\t4, 5, TLV_DB_SCALE_ITEM(852, 104, 0),\n\t6, 7, TLV_DB_SCALE_ITEM(1072, 131, 0),\n\t8, 9, TLV_DB_SCALE_ITEM(1350, 165, 0),\n\t10, 11, TLV_DB_SCALE_ITEM(1699, 101, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98371_dht_max_gain,\n\t0, 1, TLV_DB_SCALE_ITEM(537, 66, 0),\n\t2, 3, TLV_DB_SCALE_ITEM(677, 82, 0),\n\t4, 5, TLV_DB_SCALE_ITEM(852, 104, 0),\n\t6, 7, TLV_DB_SCALE_ITEM(1072, 131, 0),\n\t8, 9, TLV_DB_SCALE_ITEM(1350, 165, 0),\n\t10, 11, TLV_DB_SCALE_ITEM(1699, 208, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98371_dht_rot_gain,\n\t0, 1, TLV_DB_SCALE_ITEM(-50, -50, 0),\n\t2, 6, TLV_DB_SCALE_ITEM(-100, -100, 0),\n\t7, 8, TLV_DB_SCALE_ITEM(-800, -200, 0),\n\t9, 11, TLV_DB_SCALE_ITEM(-1200, -300, 0),\n\t12, 13, TLV_DB_SCALE_ITEM(-2000, -200, 0),\n\t14, 15, TLV_DB_SCALE_ITEM(-2500, -500, 0),\n);\n\nstatic const struct reg_default max98371_reg[] = {\n\t{ 0x01, 0x00 },\n\t{ 0x02, 0x00 },\n\t{ 0x03, 0x00 },\n\t{ 0x04, 0x00 },\n\t{ 0x05, 0x00 },\n\t{ 0x06, 0x00 },\n\t{ 0x07, 0x00 },\n\t{ 0x08, 0x00 },\n\t{ 0x09, 0x00 },\n\t{ 0x0A, 0x00 },\n\t{ 0x10, 0x06 },\n\t{ 0x11, 0x08 },\n\t{ 0x14, 0x80 },\n\t{ 0x15, 0x00 },\n\t{ 0x16, 0x00 },\n\t{ 0x18, 0x00 },\n\t{ 0x19, 0x00 },\n\t{ 0x1C, 0x00 },\n\t{ 0x1D, 0x00 },\n\t{ 0x1E, 0x00 },\n\t{ 0x1F, 0x00 },\n\t{ 0x20, 0x00 },\n\t{ 0x21, 0x00 },\n\t{ 0x22, 0x00 },\n\t{ 0x23, 0x00 },\n\t{ 0x24, 0x00 },\n\t{ 0x25, 0x00 },\n\t{ 0x26, 0x00 },\n\t{ 0x27, 0x00 },\n\t{ 0x28, 0x00 },\n\t{ 0x29, 0x00 },\n\t{ 0x2A, 0x00 },\n\t{ 0x2B, 0x00 },\n\t{ 0x2C, 0x00 },\n\t{ 0x2D, 0x00 },\n\t{ 0x2E, 0x0B },\n\t{ 0x31, 0x00 },\n\t{ 0x32, 0x18 },\n\t{ 0x33, 0x00 },\n\t{ 0x34, 0x00 },\n\t{ 0x36, 0x00 },\n\t{ 0x37, 0x00 },\n\t{ 0x38, 0x00 },\n\t{ 0x39, 0x00 },\n\t{ 0x3A, 0x00 },\n\t{ 0x3B, 0x00 },\n\t{ 0x3C, 0x00 },\n\t{ 0x3D, 0x00 },\n\t{ 0x3E, 0x00 },\n\t{ 0x3F, 0x00 },\n\t{ 0x40, 0x00 },\n\t{ 0x41, 0x00 },\n\t{ 0x42, 0x00 },\n\t{ 0x43, 0x00 },\n\t{ 0x4A, 0x00 },\n\t{ 0x4B, 0x00 },\n\t{ 0x4C, 0x00 },\n\t{ 0x4D, 0x00 },\n\t{ 0x4E, 0x00 },\n\t{ 0x50, 0x00 },\n\t{ 0x51, 0x00 },\n\t{ 0x55, 0x00 },\n\t{ 0x58, 0x00 },\n\t{ 0x59, 0x00 },\n\t{ 0x5C, 0x00 },\n\t{ 0xFF, 0x43 },\n};\n\nstatic bool max98371_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98371_IRQ_CLEAR1:\n\tcase MAX98371_IRQ_CLEAR2:\n\tcase MAX98371_IRQ_CLEAR3:\n\tcase MAX98371_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98371_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98371_SOFT_RESET:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n};\n\nstatic const DECLARE_TLV_DB_RANGE(max98371_gain_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(0, 50, 0),\n\t8, 10, TLV_DB_SCALE_ITEM(400, 100, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -6300, 50, 1);\n\nstatic const struct snd_kcontrol_new max98371_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98371_GAIN,\n\t\t\tMAX98371_GAIN_SHIFT, (1<<MAX98371_GAIN_WIDTH)-1, 0,\n\t\t\tmax98371_gain_tlv),\n\tSOC_SINGLE_TLV(\"Digital Volume\", MAX98371_DIGITAL_GAIN, 0,\n\t\t\t(1<<MAX98371_DIGITAL_GAIN_WIDTH)-1, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"Speaker DHT Max Volume\", MAX98371_GAIN,\n\t\t\t0, (1<<MAX98371_DHT_MAX_WIDTH)-1, 0,\n\t\t\tmax98371_dht_max_gain),\n\tSOC_SINGLE_TLV(\"Speaker DHT Min Volume\", MAX98371_DHT_GAIN,\n\t\t\t0, (1<<MAX98371_DHT_GAIN_WIDTH)-1, 0,\n\t\t\tmax98371_dht_min_gain),\n\tSOC_SINGLE_TLV(\"Speaker DHT Rotation Volume\", MAX98371_DHT_GAIN,\n\t\t\t0, (1<<MAX98371_DHT_ROT_WIDTH)-1, 0,\n\t\t\tmax98371_dht_rot_gain),\n\tSOC_SINGLE(\"DHT Attack Step\", MAX98371_DHT, MAX98371_DHT_STEP, 3, 0),\n\tSOC_SINGLE(\"DHT Attack Rate\", MAX98371_DHT, 0, 7, 0),\n\tSOC_ENUM(\"Monomix Select\", max98371_monomix),\n\tSOC_ENUM(\"HPF Cutoff\", max98371_hpf_cutoff),\n};\n\nstatic int max98371_dai_set_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98371_priv *max98371 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI clock mode unsupported\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval |= MAX98371_DAI_RIGHT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval |= MAX98371_DAI_LEFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI wrong mode unsupported\");\n\t\treturn -EINVAL;\n\t}\n\tregmap_update_bits(max98371->regmap, MAX98371_FMT,\n\t\t\tMAX98371_FMT_MODE_MASK, val);\n\treturn 0;\n}\n\nstatic int max98371_dai_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98371_priv *max98371 = snd_soc_component_get_drvdata(component);\n\tint blr_clk_ratio, ch_size, channels = params_channels(params);\n\tint rate = params_rate(params);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S8:\n\t\tregmap_update_bits(max98371->regmap, MAX98371_FMT,\n\t\t\t\tMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_16);\n\t\tch_size = 8;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tregmap_update_bits(max98371->regmap, MAX98371_FMT,\n\t\t\t\tMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_16);\n\t\tch_size = 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tregmap_update_bits(max98371->regmap, MAX98371_FMT,\n\t\t\t\tMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_32);\n\t\tch_size = 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tregmap_update_bits(max98371->regmap, MAX98371_FMT,\n\t\t\t\tMAX98371_FMT_MASK, MAX98371_DAI_CHANSZ_32);\n\t\tch_size = 32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tblr_clk_ratio = channels * ch_size;\n\tswitch (blr_clk_ratio) {\n\tcase 32:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_DAI_CLK,\n\t\t\tMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_32);\n\t\tbreak;\n\tcase 48:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_DAI_CLK,\n\t\t\tMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_48);\n\t\tbreak;\n\tcase 64:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_DAI_CLK,\n\t\t\tMAX98371_DAI_BSEL_MASK, MAX98371_DAI_BSEL_64);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (rate) {\n\tcase 32000:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_SPK_SR,\n\t\t\tMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_32);\n\t\tbreak;\n\tcase 44100:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_SPK_SR,\n\t\t\tMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_44);\n\t\tbreak;\n\tcase 48000:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_SPK_SR,\n\t\t\tMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_48);\n\t\tbreak;\n\tcase 88200:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_SPK_SR,\n\t\t\tMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_88);\n\t\tbreak;\n\tcase 96000:\n\t\tregmap_update_bits(max98371->regmap,\n\t\t\tMAX98371_SPK_SR,\n\t\t\tMAX98371_SPK_SR_MASK, MAX98371_SPK_SR_96);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_update_bits(max98371->regmap, MAX98371_MONOMIX_SRC,\n\t\t\tMAX98371_MONOMIX_SRC_MASK, MONOMIX_RX_0_1);\n\tregmap_update_bits(max98371->regmap, MAX98371_DAI_CHANNEL,\n\t\t\tMAX98371_CHANNEL_MASK, MAX98371_CHANNEL_MASK);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget max98371_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, MAX98371_SPK_ENABLE, 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Global Enable\", MAX98371_GLOBAL_ENABLE,\n\t\t0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"SPK_OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route max98371_audio_map[] = {\n\t{\"DAC\", NULL, \"HiFi Playback\"},\n\t{\"SPK_OUT\", NULL, \"DAC\"},\n\t{\"SPK_OUT\", NULL, \"Global Enable\"},\n};\n\n#define MAX98371_RATES SNDRV_PCM_RATE_8000_48000\n#define MAX98371_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE | \\\n\t\tSNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE)\n\nstatic const struct snd_soc_dai_ops max98371_dai_ops = {\n\t.set_fmt = max98371_dai_set_fmt,\n\t.hw_params = max98371_dai_hw_params,\n};\n\nstatic struct snd_soc_dai_driver max98371_dai[] = {\n\t{\n\t\t.name = \"max98371-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = MAX98371_FORMATS,\n\t\t},\n\t\t.ops = &max98371_dai_ops,\n\t}\n};\n\nstatic const struct snd_soc_component_driver max98371_component = {\n\t.controls\t\t= max98371_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98371_snd_controls),\n\t.dapm_routes\t\t= max98371_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98371_audio_map),\n\t.dapm_widgets\t\t= max98371_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98371_dapm_widgets),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98371_regmap = {\n\t.reg_bits         = 8,\n\t.val_bits         = 8,\n\t.max_register     = MAX98371_VERSION,\n\t.reg_defaults     = max98371_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98371_reg),\n\t.volatile_reg     = max98371_volatile_register,\n\t.readable_reg     = max98371_readable_register,\n\t.cache_type       = REGCACHE_RBTREE,\n};\n\nstatic int max98371_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max98371_priv *max98371;\n\tint ret, reg;\n\n\tmax98371 = devm_kzalloc(&i2c->dev,\n\t\t\tsizeof(*max98371), GFP_KERNEL);\n\tif (!max98371)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max98371);\n\tmax98371->regmap = devm_regmap_init_i2c(i2c, &max98371_regmap);\n\tif (IS_ERR(max98371->regmap)) {\n\t\tret = PTR_ERR(max98371->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(max98371->regmap, MAX98371_VERSION, &reg);\n\tif (ret < 0) {\n\t\tdev_info(&i2c->dev, \"device error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"device version %x\\n\", reg);\n\n\tret = devm_snd_soc_register_component(&i2c->dev, &max98371_component,\n\t\t\tmax98371_dai, ARRAY_SIZE(max98371_dai));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98371_i2c_id[] = {\n\t{ \"max98371\", 0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(i2c, max98371_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98371_of_match[] = {\n\t{ .compatible = \"maxim,max98371\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98371_of_match);\n#endif\n\nstatic struct i2c_driver max98371_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98371\",\n\t\t.of_match_table = of_match_ptr(max98371_of_match),\n\t},\n\t.probe = max98371_i2c_probe,\n\t.id_table = max98371_i2c_id,\n};\n\nmodule_i2c_driver(max98371_i2c_driver);\n\nMODULE_AUTHOR(\"anish kumar <yesanishhere@gmail.com>\");\nMODULE_DESCRIPTION(\"ALSA SoC MAX98371 driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}