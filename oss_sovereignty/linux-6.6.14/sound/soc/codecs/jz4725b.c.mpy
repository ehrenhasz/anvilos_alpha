{
  "module_name": "jz4725b.c",
  "hash_id": "1f0da5c548c13395547c2d36a31e432d9f7e8dc8e9582a365c6b39f0ca5f376e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/jz4725b.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n\n#include <linux/delay.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define ICDC_RGADW_OFFSET\t\t0x00\n#define ICDC_RGDATA_OFFSET\t\t0x04\n\n \n#define ICDC_RGADW_RGWR\t\t\tBIT(16)\n\n#define ICDC_RGADW_RGADDR_OFFSET\t8\n#define\tICDC_RGADW_RGADDR_MASK\t\tGENMASK(14, ICDC_RGADW_RGADDR_OFFSET)\n\n#define ICDC_RGADW_RGDIN_OFFSET\t\t0\n#define\tICDC_RGADW_RGDIN_MASK\t\tGENMASK(7, ICDC_RGADW_RGDIN_OFFSET)\n\n \n#define ICDC_RGDATA_IRQ\t\t\tBIT(8)\n\n#define ICDC_RGDATA_RGDOUT_OFFSET\t0\n#define ICDC_RGDATA_RGDOUT_MASK\t\tGENMASK(7, ICDC_RGDATA_RGDOUT_OFFSET)\n\n \nenum {\n\tJZ4725B_CODEC_REG_AICR,\n\tJZ4725B_CODEC_REG_CR1,\n\tJZ4725B_CODEC_REG_CR2,\n\tJZ4725B_CODEC_REG_CCR1,\n\tJZ4725B_CODEC_REG_CCR2,\n\tJZ4725B_CODEC_REG_PMR1,\n\tJZ4725B_CODEC_REG_PMR2,\n\tJZ4725B_CODEC_REG_CRR,\n\tJZ4725B_CODEC_REG_ICR,\n\tJZ4725B_CODEC_REG_IFR,\n\tJZ4725B_CODEC_REG_CGR1,\n\tJZ4725B_CODEC_REG_CGR2,\n\tJZ4725B_CODEC_REG_CGR3,\n\tJZ4725B_CODEC_REG_CGR4,\n\tJZ4725B_CODEC_REG_CGR5,\n\tJZ4725B_CODEC_REG_CGR6,\n\tJZ4725B_CODEC_REG_CGR7,\n\tJZ4725B_CODEC_REG_CGR8,\n\tJZ4725B_CODEC_REG_CGR9,\n\tJZ4725B_CODEC_REG_CGR10,\n\tJZ4725B_CODEC_REG_TR1,\n\tJZ4725B_CODEC_REG_TR2,\n\tJZ4725B_CODEC_REG_CR3,\n\tJZ4725B_CODEC_REG_AGC1,\n\tJZ4725B_CODEC_REG_AGC2,\n\tJZ4725B_CODEC_REG_AGC3,\n\tJZ4725B_CODEC_REG_AGC4,\n\tJZ4725B_CODEC_REG_AGC5,\n};\n\n#define REG_AICR_CONFIG1_OFFSET\t\t0\n#define REG_AICR_CONFIG1_MASK\t\t(0xf << REG_AICR_CONFIG1_OFFSET)\n\n#define REG_CR1_SB_MICBIAS_OFFSET\t7\n#define REG_CR1_MONO_OFFSET\t\t6\n#define REG_CR1_DAC_MUTE_OFFSET\t\t5\n#define REG_CR1_HP_DIS_OFFSET\t\t4\n#define REG_CR1_DACSEL_OFFSET\t\t3\n#define REG_CR1_BYPASS_OFFSET\t\t2\n\n#define REG_CR2_DAC_DEEMP_OFFSET\t7\n#define REG_CR2_DAC_ADWL_OFFSET\t\t5\n#define REG_CR2_DAC_ADWL_MASK\t\t(0x3 << REG_CR2_DAC_ADWL_OFFSET)\n#define REG_CR2_ADC_ADWL_OFFSET\t\t3\n#define REG_CR2_ADC_ADWL_MASK\t\t(0x3 << REG_CR2_ADC_ADWL_OFFSET)\n#define REG_CR2_ADC_HPF_OFFSET\t\t2\n\n#define REG_CR3_SB_MIC1_OFFSET\t\t7\n#define REG_CR3_SB_MIC2_OFFSET\t\t6\n#define REG_CR3_SIDETONE1_OFFSET\t5\n#define REG_CR3_SIDETONE2_OFFSET\t4\n#define REG_CR3_MICDIFF_OFFSET\t\t3\n#define REG_CR3_MICSTEREO_OFFSET\t2\n#define REG_CR3_INSEL_OFFSET\t\t0\n#define REG_CR3_INSEL_MASK\t\t(0x3 << REG_CR3_INSEL_OFFSET)\n\n#define REG_CCR1_CONFIG4_OFFSET\t\t0\n#define REG_CCR1_CONFIG4_MASK\t\t(0xf << REG_CCR1_CONFIG4_OFFSET)\n\n#define REG_CCR2_DFREQ_OFFSET\t\t4\n#define REG_CCR2_DFREQ_MASK\t\t(0xf << REG_CCR2_DFREQ_OFFSET)\n#define REG_CCR2_AFREQ_OFFSET\t\t0\n#define REG_CCR2_AFREQ_MASK\t\t(0xf << REG_CCR2_AFREQ_OFFSET)\n\n#define REG_PMR1_SB_DAC_OFFSET\t\t7\n#define REG_PMR1_SB_OUT_OFFSET\t\t6\n#define REG_PMR1_SB_MIX_OFFSET\t\t5\n#define REG_PMR1_SB_ADC_OFFSET\t\t4\n#define REG_PMR1_SB_LIN_OFFSET\t\t3\n#define REG_PMR1_SB_IND_OFFSET\t\t0\n\n#define REG_PMR2_LRGI_OFFSET\t\t7\n#define REG_PMR2_RLGI_OFFSET\t\t6\n#define REG_PMR2_LRGOD_OFFSET\t\t5\n#define REG_PMR2_RLGOD_OFFSET\t\t4\n#define REG_PMR2_GIM_OFFSET\t\t3\n#define REG_PMR2_SB_MC_OFFSET\t\t2\n#define REG_PMR2_SB_OFFSET\t\t1\n#define REG_PMR2_SB_SLEEP_OFFSET\t0\n\n#define REG_IFR_RAMP_UP_DONE_OFFSET\t3\n#define REG_IFR_RAMP_DOWN_DONE_OFFSET\t2\n\n#define REG_CGR1_GODL_OFFSET\t\t4\n#define REG_CGR1_GODL_MASK\t\t(0xf << REG_CGR1_GODL_OFFSET)\n#define REG_CGR1_GODR_OFFSET\t\t0\n#define REG_CGR1_GODR_MASK\t\t(0xf << REG_CGR1_GODR_OFFSET)\n\n#define REG_CGR2_GO1R_OFFSET\t\t0\n#define REG_CGR2_GO1R_MASK\t\t(0x1f << REG_CGR2_GO1R_OFFSET)\n\n#define REG_CGR3_GO1L_OFFSET\t\t0\n#define REG_CGR3_GO1L_MASK\t\t(0x1f << REG_CGR3_GO1L_OFFSET)\n\n#define REG_CGR4_GO2R_OFFSET\t\t0\n#define REG_CGR4_GO2R_MASK\t\t(0x1f << REG_CGR4_GO2R_OFFSET)\n\n#define REG_CGR5_GO2L_OFFSET\t\t0\n#define REG_CGR5_GO2L_MASK\t\t(0x1f << REG_CGR5_GO2L_OFFSET)\n\n#define REG_CGR6_GO3R_OFFSET\t\t0\n#define REG_CGR6_GO3R_MASK\t\t(0x1f << REG_CGR6_GO3R_OFFSET)\n\n#define REG_CGR7_GO3L_OFFSET\t\t0\n#define REG_CGR7_GO3L_MASK\t\t(0x1f << REG_CGR7_GO3L_OFFSET)\n\n#define REG_CGR8_GOR_OFFSET\t\t0\n#define REG_CGR8_GOR_MASK\t\t(0x1f << REG_CGR8_GOR_OFFSET)\n\n#define REG_CGR9_GOL_OFFSET\t\t0\n#define REG_CGR9_GOL_MASK\t\t(0x1f << REG_CGR9_GOL_OFFSET)\n\n#define REG_CGR10_GIL_OFFSET\t\t0\n#define REG_CGR10_GIR_OFFSET\t\t4\n\nstruct jz_icdc {\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(jz4725b_adc_tlv,     0, 150, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(jz4725b_dac_tlv, -2250, 150, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(jz4725b_mix_tlv,\n\t 0, 11, TLV_DB_SCALE_ITEM(-2250,   0, 0),\n\t12, 31, TLV_DB_SCALE_ITEM(-2250, 150, 0),\n);\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(jz4725b_out_tlv,\n\t 0, 11, TLV_DB_SCALE_ITEM(-3350, 200, 0),\n\t12, 23, TLV_DB_SCALE_ITEM(-1050, 100, 0),\n\t24, 31, TLV_DB_SCALE_ITEM(  100,  50, 0),\n);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(jz4725b_mic_boost_tlv, 0, 2000, 0);\n\nstatic const char * const jz4725b_mic_mode_texts[] = {\n\t\"Single Ended\", \"Differential\",\n};\n\nstatic const struct soc_enum jz4725b_mic_mode_enum =\n\tSOC_ENUM_SINGLE(JZ4725B_CODEC_REG_CR3, REG_CR3_MICDIFF_OFFSET,\n\t\t\t2, jz4725b_mic_mode_texts);\n\nstatic const struct snd_kcontrol_new jz4725b_codec_controls[] = {\n\tSOC_DOUBLE_TLV(\"DAC Playback Volume\",\n\t\t       JZ4725B_CODEC_REG_CGR1,\n\t\t       REG_CGR1_GODL_OFFSET,\n\t\t       REG_CGR1_GODR_OFFSET,\n\t\t       0xf, 1, jz4725b_dac_tlv),\n\tSOC_DOUBLE_TLV(\"Master Capture Volume\",\n\t\t       JZ4725B_CODEC_REG_CGR10,\n\t\t       REG_CGR10_GIL_OFFSET,\n\t\t       REG_CGR10_GIR_OFFSET,\n\t\t       0xf, 0, jz4725b_adc_tlv),\n\tSOC_DOUBLE_R_TLV(\"Mixer Line In Bypass Playback Volume\",\n\t\t\t JZ4725B_CODEC_REG_CGR3,\n\t\t\t JZ4725B_CODEC_REG_CGR2,\n\t\t\t REG_CGR2_GO1R_OFFSET,\n\t\t\t 0x1f, 1, jz4725b_mix_tlv),\n\tSOC_DOUBLE_R_TLV(\"Mixer Mic 1 Bypass Playback Volume\",\n\t\t\t JZ4725B_CODEC_REG_CGR5,\n\t\t\t JZ4725B_CODEC_REG_CGR4,\n\t\t\t REG_CGR4_GO2R_OFFSET,\n\t\t\t 0x1f, 1, jz4725b_mix_tlv),\n\tSOC_DOUBLE_R_TLV(\"Mixer Mic 2 Bypass Playback Volume\",\n\t\t\t JZ4725B_CODEC_REG_CGR7,\n\t\t\t JZ4725B_CODEC_REG_CGR6,\n\t\t\t REG_CGR6_GO3R_OFFSET,\n\t\t\t 0x1f, 1, jz4725b_mix_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\",\n\t\t\t JZ4725B_CODEC_REG_CGR9,\n\t\t\t JZ4725B_CODEC_REG_CGR8,\n\t\t\t REG_CGR8_GOR_OFFSET,\n\t\t\t 0x1f, 1, jz4725b_out_tlv),\n\n\tSOC_SINGLE(\"DAC Playback Switch\", JZ4725B_CODEC_REG_CR1,\n\t\t   REG_CR1_DAC_MUTE_OFFSET, 1, 1),\n\n\tSOC_SINGLE(\"Deemphasize Filter Playback Switch\",\n\t\t   JZ4725B_CODEC_REG_CR2,\n\t\t   REG_CR2_DAC_DEEMP_OFFSET, 1, 0),\n\n\tSOC_SINGLE(\"High-Pass Filter Capture Switch\",\n\t\t   JZ4725B_CODEC_REG_CR2,\n\t\t   REG_CR2_ADC_HPF_OFFSET, 1, 0),\n\n\tSOC_ENUM(\"Mic Mode Capture Switch\", jz4725b_mic_mode_enum),\n\n\tSOC_SINGLE_TLV(\"Mic1 Boost Capture Volume\",\n\t\t       JZ4725B_CODEC_REG_PMR2,\n\t\t       REG_PMR2_GIM_OFFSET,\n\t\t       1, 0, jz4725b_mic_boost_tlv),\n};\n\nstatic const char * const jz4725b_codec_adc_src_texts[] = {\n\t\"Mic 1\", \"Mic 2\", \"Line In\", \"Mixer\",\n};\nstatic const unsigned int jz4725b_codec_adc_src_values[] = { 0, 1, 2, 3, };\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4725b_codec_adc_src_enum,\n\t\t\t\t  JZ4725B_CODEC_REG_CR3,\n\t\t\t\t  REG_CR3_INSEL_OFFSET,\n\t\t\t\t  REG_CR3_INSEL_MASK,\n\t\t\t\t  jz4725b_codec_adc_src_texts,\n\t\t\t\t  jz4725b_codec_adc_src_values);\nstatic const struct snd_kcontrol_new jz4725b_codec_adc_src_ctrl =\n\tSOC_DAPM_ENUM(\"ADC Source Capture Route\", jz4725b_codec_adc_src_enum);\n\nstatic const struct snd_kcontrol_new jz4725b_codec_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line In Bypass Playback Switch\", JZ4725B_CODEC_REG_CR1,\n\t\t\tREG_CR1_BYPASS_OFFSET, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mic 1 Bypass Playback Switch\", JZ4725B_CODEC_REG_CR3,\n\t\t\tREG_CR3_SIDETONE1_OFFSET, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mic 2 Bypass Playback Switch\", JZ4725B_CODEC_REG_CR3,\n\t\t\tREG_CR3_SIDETONE2_OFFSET, 1, 0),\n};\n\nstatic int jz4725b_out_stage_enable(struct snd_soc_dapm_widget *w,\n\t\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t\t    int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tstruct jz_icdc *icdc = snd_soc_component_get_drvdata(codec);\n\tstruct regmap *map = icdc->regmap;\n\tunsigned int val;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn regmap_clear_bits(map, JZ4725B_CODEC_REG_IFR,\n\t\t\t\t\t BIT(REG_IFR_RAMP_UP_DONE_OFFSET));\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\treturn regmap_read_poll_timeout(map, JZ4725B_CODEC_REG_IFR,\n\t\t\t       val, val & BIT(REG_IFR_RAMP_UP_DONE_OFFSET),\n\t\t\t       100000, 500000);\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\treturn regmap_clear_bits(map, JZ4725B_CODEC_REG_IFR,\n\t\t\t\tBIT(REG_IFR_RAMP_DOWN_DONE_OFFSET));\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn regmap_read_poll_timeout(map, JZ4725B_CODEC_REG_IFR,\n\t\t\t       val, val & BIT(REG_IFR_RAMP_DOWN_DONE_OFFSET),\n\t\t\t       100000, 500000);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct snd_soc_dapm_widget jz4725b_codec_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\",\n\t\t\t JZ4725B_CODEC_REG_PMR1, REG_PMR1_SB_DAC_OFFSET, 1),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\",\n\t\t\t JZ4725B_CODEC_REG_PMR1, REG_PMR1_SB_ADC_OFFSET, 1),\n\n\tSND_SOC_DAPM_MUX(\"ADC Source Capture Route\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4725b_codec_adc_src_ctrl),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Mixer\", JZ4725B_CODEC_REG_PMR1,\n\t\t\t   REG_PMR1_SB_MIX_OFFSET, 1,\n\t\t\t   jz4725b_codec_mixer_controls,\n\t\t\t   ARRAY_SIZE(jz4725b_codec_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"DAC to Mixer\", JZ4725B_CODEC_REG_CR1,\n\t\t\t   REG_CR1_DACSEL_OFFSET, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Line In\", JZ4725B_CODEC_REG_PMR1,\n\t\t\t   REG_PMR1_SB_LIN_OFFSET, 1, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"HP Out\", JZ4725B_CODEC_REG_CR1,\n\t\t\t   REG_CR1_HP_DIS_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Mic 1\", JZ4725B_CODEC_REG_CR3,\n\t\t\t   REG_CR3_SB_MIC1_OFFSET, 1, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Mic 2\", JZ4725B_CODEC_REG_CR3,\n\t\t\t   REG_CR3_SB_MIC2_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER_E(\"Out Stage\", JZ4725B_CODEC_REG_PMR1,\n\t\t\t     REG_PMR1_SB_OUT_OFFSET, 1, NULL, 0,\n\t\t\t     jz4725b_out_stage_enable,\n\t\t\t     SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t     SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MIXER(\"Mixer to ADC\", JZ4725B_CODEC_REG_PMR1,\n\t\t\t   REG_PMR1_SB_IND_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", JZ4725B_CODEC_REG_CR1,\n\t\t\t    REG_CR1_SB_MICBIAS_OFFSET, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"MIC1P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1N\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2N\"),\n\n\tSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n\tSND_SOC_DAPM_INPUT(\"RLINEIN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\n};\n\nstatic const struct snd_soc_dapm_route jz4725b_codec_dapm_routes[] = {\n\t{\"Mic 1\", NULL, \"MIC1P\"},\n\t{\"Mic 1\", NULL, \"MIC1N\"},\n\t{\"Mic 2\", NULL, \"MIC2P\"},\n\t{\"Mic 2\", NULL, \"MIC2N\"},\n\n\t{\"Line In\", NULL, \"LLINEIN\"},\n\t{\"Line In\", NULL, \"RLINEIN\"},\n\n\t{\"Mixer\", \"Mic 1 Bypass Playback Switch\", \"Mic 1\"},\n\t{\"Mixer\", \"Mic 2 Bypass Playback Switch\", \"Mic 2\"},\n\t{\"Mixer\", \"Line In Bypass Playback Switch\", \"Line In\"},\n\t{\"DAC to Mixer\", NULL, \"DAC\"},\n\t{\"Mixer\", NULL, \"DAC to Mixer\"},\n\n\t{\"Mixer to ADC\", NULL, \"Mixer\"},\n\t{\"ADC Source Capture Route\", \"Mixer\", \"Mixer to ADC\"},\n\t{\"ADC Source Capture Route\", \"Line In\", \"Line In\"},\n\t{\"ADC Source Capture Route\", \"Mic 1\", \"Mic 1\"},\n\t{\"ADC Source Capture Route\", \"Mic 2\", \"Mic 2\"},\n\t{\"ADC\", NULL, \"ADC Source Capture Route\"},\n\n\t{\"Out Stage\", NULL, \"Mixer\"},\n\t{\"HP Out\", NULL, \"Out Stage\"},\n\t{\"LHPOUT\", NULL, \"HP Out\"},\n\t{\"RHPOUT\", NULL, \"HP Out\"},\n};\n\nstatic int jz4725b_codec_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct jz_icdc *icdc = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map = icdc->regmap;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tregmap_clear_bits(map, JZ4725B_CODEC_REG_PMR2,\n\t\t\t\t  BIT(REG_PMR2_SB_SLEEP_OFFSET));\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tregmap_clear_bits(map, JZ4725B_CODEC_REG_PMR2,\n\t\t\t\t  BIT(REG_PMR2_SB_OFFSET));\n\t\tmsleep(224);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_set_bits(map, JZ4725B_CODEC_REG_PMR2,\n\t\t\t\tBIT(REG_PMR2_SB_SLEEP_OFFSET));\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_set_bits(map, JZ4725B_CODEC_REG_PMR2,\n\t\t\t\tBIT(REG_PMR2_SB_OFFSET));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4725b_codec_dev_probe(struct snd_soc_component *component)\n{\n\tstruct jz_icdc *icdc = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map = icdc->regmap;\n\n\tclk_prepare_enable(icdc->clk);\n\n\t \n\tregmap_write(map, JZ4725B_CODEC_REG_AICR,\n\t\t     0xf << REG_AICR_CONFIG1_OFFSET);\n\tregmap_write(map, JZ4725B_CODEC_REG_CCR1,\n\t\t     0x0 << REG_CCR1_CONFIG4_OFFSET);\n\n\treturn 0;\n}\n\nstatic void jz4725b_codec_dev_remove(struct snd_soc_component *component)\n{\n\tstruct jz_icdc *icdc = snd_soc_component_get_drvdata(component);\n\n\tclk_disable_unprepare(icdc->clk);\n}\n\nstatic const struct snd_soc_component_driver jz4725b_codec = {\n\t.probe\t\t\t= jz4725b_codec_dev_probe,\n\t.remove\t\t\t= jz4725b_codec_dev_remove,\n\t.set_bias_level\t\t= jz4725b_codec_set_bias_level,\n\t.controls\t\t= jz4725b_codec_controls,\n\t.num_controls\t\t= ARRAY_SIZE(jz4725b_codec_controls),\n\t.dapm_widgets\t\t= jz4725b_codec_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(jz4725b_codec_dapm_widgets),\n\t.dapm_routes\t\t= jz4725b_codec_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(jz4725b_codec_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.use_pmdown_time\t= 1,\n};\n\nstatic const unsigned int jz4725b_codec_sample_rates[] = {\n\t96000, 48000, 44100, 32000,\n\t24000, 22050, 16000, 12000,\n\t11025, 9600, 8000,\n};\n\nstatic int jz4725b_codec_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct jz_icdc *icdc = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int rate, bit_width;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbit_width = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tbit_width = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tbit_width = 2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tbit_width = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (rate = 0; rate < ARRAY_SIZE(jz4725b_codec_sample_rates); rate++) {\n\t\tif (jz4725b_codec_sample_rates[rate] == params_rate(params))\n\t\t\tbreak;\n\t}\n\n\tif (rate == ARRAY_SIZE(jz4725b_codec_sample_rates))\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(icdc->regmap,\n\t\t\t\t   JZ4725B_CODEC_REG_CR2,\n\t\t\t\t   REG_CR2_DAC_ADWL_MASK,\n\t\t\t\t   bit_width << REG_CR2_DAC_ADWL_OFFSET);\n\n\t\tregmap_update_bits(icdc->regmap,\n\t\t\t\t   JZ4725B_CODEC_REG_CCR2,\n\t\t\t\t   REG_CCR2_DFREQ_MASK,\n\t\t\t\t   rate << REG_CCR2_DFREQ_OFFSET);\n\t} else {\n\t\tregmap_update_bits(icdc->regmap,\n\t\t\t\t   JZ4725B_CODEC_REG_CR2,\n\t\t\t\t   REG_CR2_ADC_ADWL_MASK,\n\t\t\t\t   bit_width << REG_CR2_ADC_ADWL_OFFSET);\n\n\t\tregmap_update_bits(icdc->regmap,\n\t\t\t\t   JZ4725B_CODEC_REG_CCR2,\n\t\t\t\t   REG_CCR2_AFREQ_MASK,\n\t\t\t\t   rate << REG_CCR2_AFREQ_OFFSET);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops jz4725b_codec_dai_ops = {\n\t.hw_params = jz4725b_codec_hw_params,\n};\n\n#define JZ_ICDC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_3LE)\n\nstatic struct snd_soc_dai_driver jz4725b_codec_dai = {\n\t.name = \"jz4725b-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_ICDC_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_ICDC_FORMATS,\n\t},\n\t.ops = &jz4725b_codec_dai_ops,\n};\n\nstatic bool jz4725b_codec_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == JZ4725B_CODEC_REG_IFR;\n}\n\nstatic bool jz4725b_codec_can_access_reg(struct device *dev, unsigned int reg)\n{\n\treturn (reg != JZ4725B_CODEC_REG_TR1) && (reg != JZ4725B_CODEC_REG_TR2);\n}\n\nstatic int jz4725b_codec_io_wait(struct jz_icdc *icdc)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(icdc->base + ICDC_RGADW_OFFSET, reg,\n\t\t\t\t  !(reg & ICDC_RGADW_RGWR), 1000, 10000);\n}\n\nstatic int jz4725b_codec_reg_read(void *context, unsigned int reg,\n\t\t\t\t  unsigned int *val)\n{\n\tstruct jz_icdc *icdc = context;\n\tunsigned int i;\n\tu32 tmp;\n\tint ret;\n\n\tret = jz4725b_codec_io_wait(icdc);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = readl(icdc->base + ICDC_RGADW_OFFSET);\n\ttmp = (tmp & ~ICDC_RGADW_RGADDR_MASK)\n\t    | (reg << ICDC_RGADW_RGADDR_OFFSET);\n\twritel(tmp, icdc->base + ICDC_RGADW_OFFSET);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\t*val = readl(icdc->base + ICDC_RGDATA_OFFSET) &\n\t\t\tICDC_RGDATA_RGDOUT_MASK;\n\n\treturn 0;\n}\n\nstatic int jz4725b_codec_reg_write(void *context, unsigned int reg,\n\t\t\t\t   unsigned int val)\n{\n\tstruct jz_icdc *icdc = context;\n\tint ret;\n\n\tret = jz4725b_codec_io_wait(icdc);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(ICDC_RGADW_RGWR | (reg << ICDC_RGADW_RGADDR_OFFSET) | val,\n\t\t\ticdc->base + ICDC_RGADW_OFFSET);\n\n\tret = jz4725b_codec_io_wait(icdc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const u8 jz4725b_codec_reg_defaults[] = {\n\t0x0c, 0xaa, 0x78, 0x00, 0x00, 0xff, 0x03, 0x51,\n\t0x3f, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04,\n\t0x04, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0xc0, 0x34,\n\t0x07, 0x44, 0x1f, 0x00,\n};\n\nstatic const struct regmap_config jz4725b_codec_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 8,\n\n\t.max_register = JZ4725B_CODEC_REG_AGC5,\n\t.volatile_reg = jz4725b_codec_volatile,\n\t.readable_reg = jz4725b_codec_can_access_reg,\n\t.writeable_reg = jz4725b_codec_can_access_reg,\n\n\t.reg_read = jz4725b_codec_reg_read,\n\t.reg_write = jz4725b_codec_reg_write,\n\n\t.reg_defaults_raw = jz4725b_codec_reg_defaults,\n\t.num_reg_defaults_raw = ARRAY_SIZE(jz4725b_codec_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int jz4725b_codec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz_icdc *icdc;\n\tint ret;\n\n\ticdc = devm_kzalloc(dev, sizeof(*icdc), GFP_KERNEL);\n\tif (!icdc)\n\t\treturn -ENOMEM;\n\n\ticdc->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(icdc->base))\n\t\treturn PTR_ERR(icdc->base);\n\n\ticdc->regmap = devm_regmap_init(dev, NULL, icdc,\n\t\t\t\t\t&jz4725b_codec_regmap_config);\n\tif (IS_ERR(icdc->regmap))\n\t\treturn PTR_ERR(icdc->regmap);\n\n\ticdc->clk = devm_clk_get(&pdev->dev, \"aic\");\n\tif (IS_ERR(icdc->clk))\n\t\treturn PTR_ERR(icdc->clk);\n\n\tplatform_set_drvdata(pdev, icdc);\n\n\tret = devm_snd_soc_register_component(dev, &jz4725b_codec,\n\t\t\t\t\t      &jz4725b_codec_dai, 1);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register codec\\n\");\n\n\treturn ret;\n}\n\nstatic const struct of_device_id jz4725b_codec_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4725b-codec\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, jz4725b_codec_of_matches);\n\nstatic struct platform_driver jz4725b_codec_driver = {\n\t.probe = jz4725b_codec_probe,\n\t.driver = {\n\t\t.name = \"jz4725b-codec\",\n\t\t.of_match_table = jz4725b_codec_of_matches,\n\t},\n};\nmodule_platform_driver(jz4725b_codec_driver);\n\nMODULE_DESCRIPTION(\"JZ4725B SoC internal codec driver\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}