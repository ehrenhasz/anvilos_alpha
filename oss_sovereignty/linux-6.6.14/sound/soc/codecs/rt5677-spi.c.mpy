{
  "module_name": "rt5677-spi.c",
  "hash_id": "bec6cb5a5c345f5ea5bb0d6ea23fac4b66a08deb33843bd59c404de61661d3c9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt5677-spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/input.h>\n#include <linux/spi/spi.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/uaccess.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_qos.h>\n#include <linux/sysfs.h>\n#include <linux/clk.h>\n#include <linux/firmware.h>\n#include <linux/acpi.h>\n\n#include <sound/soc.h>\n\n#include \"rt5677.h\"\n#include \"rt5677-spi.h\"\n\n#define DRV_NAME \"rt5677spi\"\n\n#define RT5677_SPI_BURST_LEN\t240\n#define RT5677_SPI_HEADER\t5\n#define RT5677_SPI_FREQ\t\t6000000\n\n \n#define RT5677_SPI_WRITE_BURST\t0x5\n#define RT5677_SPI_READ_BURST\t0x4\n#define RT5677_SPI_WRITE_32\t0x3\n#define RT5677_SPI_READ_32\t0x2\n#define RT5677_SPI_WRITE_16\t0x1\n#define RT5677_SPI_READ_16\t0x0\n\n#define RT5677_BUF_BYTES_TOTAL\t\t0x20000\n#define RT5677_MIC_BUF_ADDR\t\t0x60030000\n#define RT5677_MODEL_ADDR\t\t0x5FFC9800\n#define RT5677_MIC_BUF_BYTES\t\t((u32)(RT5677_BUF_BYTES_TOTAL - \\\n\t\t\t\t\tsizeof(u32)))\n#define RT5677_MIC_BUF_FIRST_READ_SIZE\t0x10000\n\nstatic struct spi_device *g_spi;\nstatic DEFINE_MUTEX(spi_mutex);\n\nstruct rt5677_dsp {\n\tstruct device *dev;\n\tstruct delayed_work copy_work;\n\tstruct mutex dma_lock;\n\tstruct snd_pcm_substream *substream;\n\tsize_t dma_offset;\t \n\tsize_t avail_bytes;\t \n\tu32 mic_read_offset;\t \n\tbool new_hotword;\t \n};\n\nstatic const struct snd_pcm_hardware rt5677_spi_pcm_hardware = {\n\t.info\t\t\t= SNDRV_PCM_INFO_MMAP |\n\t\t\t\t  SNDRV_PCM_INFO_MMAP_VALID |\n\t\t\t\t  SNDRV_PCM_INFO_INTERLEAVED,\n\t.formats\t\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t.period_bytes_min\t= PAGE_SIZE,\n\t.period_bytes_max\t= RT5677_BUF_BYTES_TOTAL / 8,\n\t.periods_min\t\t= 8,\n\t.periods_max\t\t= 8,\n\t.channels_min\t\t= 1,\n\t.channels_max\t\t= 1,\n\t.buffer_bytes_max\t= RT5677_BUF_BYTES_TOTAL,\n};\n\nstatic struct snd_soc_dai_driver rt5677_spi_dai = {\n\t \n\t.name = \"rt5677-dsp-cpu-dai\",\n\t.id = 0,\n\t.capture = {\n\t\t.stream_name = \"DSP Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n};\n\n \nstatic int rt5677_spi_pcm_open(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tsnd_soc_set_runtime_hwparams(substream, &rt5677_spi_pcm_hardware);\n\treturn 0;\n}\n\nstatic int rt5677_spi_pcm_close(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *codec_component =\n\t\t\tsnd_soc_rtdcom_lookup(rtd, \"rt5677\");\n\tstruct rt5677_priv *rt5677 =\n\t\t\tsnd_soc_component_get_drvdata(codec_component);\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&rt5677_dsp->copy_work);\n\trt5677->set_dsp_vad(codec_component, false);\n\treturn 0;\n}\n\nstatic int rt5677_spi_hw_params(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *hw_params)\n{\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&rt5677_dsp->dma_lock);\n\trt5677_dsp->substream = substream;\n\tmutex_unlock(&rt5677_dsp->dma_lock);\n\n\treturn 0;\n}\n\nstatic int rt5677_spi_hw_free(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&rt5677_dsp->dma_lock);\n\trt5677_dsp->substream = NULL;\n\tmutex_unlock(&rt5677_dsp->dma_lock);\n\n\treturn 0;\n}\n\nstatic int rt5677_spi_prepare(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);\n\tstruct snd_soc_component *rt5677_component =\n\t\t\tsnd_soc_rtdcom_lookup(rtd, \"rt5677\");\n\tstruct rt5677_priv *rt5677 =\n\t\t\tsnd_soc_component_get_drvdata(rt5677_component);\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\trt5677->set_dsp_vad(rt5677_component, true);\n\trt5677_dsp->dma_offset = 0;\n\trt5677_dsp->avail_bytes = 0;\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t rt5677_spi_pcm_pointer(\n\t\tstruct snd_soc_component *component,\n\t\tstruct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\treturn bytes_to_frames(runtime, rt5677_dsp->dma_offset);\n}\n\nstatic int rt5677_spi_mic_write_offset(u32 *mic_write_offset)\n{\n\tint ret;\n\t \n\tret = rt5677_spi_read(RT5677_MIC_BUF_ADDR, mic_write_offset,\n\t\t\tsizeof(u32));\n\tif (ret)\n\t\treturn ret;\n\t \n\t*mic_write_offset = *mic_write_offset - sizeof(u32);\n\treturn *mic_write_offset < RT5677_MIC_BUF_BYTES ? 0 : -EFAULT;\n}\n\n \nstatic int rt5677_spi_copy_block(struct rt5677_dsp *rt5677_dsp,\n\t\tu32 begin, u32 end)\n{\n\tstruct snd_pcm_runtime *runtime = rt5677_dsp->substream->runtime;\n\tsize_t bytes_per_frame = frames_to_bytes(runtime, 1);\n\tsize_t first_chunk_len, second_chunk_len;\n\tint ret;\n\n\tif (begin > end || runtime->dma_bytes < 2 * bytes_per_frame) {\n\t\tdev_err(rt5677_dsp->dev,\n\t\t\t\"Invalid copy from (%u, %u), dma_area size %zu\\n\",\n\t\t\tbegin, end, runtime->dma_bytes);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (begin == end)\n\t\treturn 0;\n\n\t \n\tif (end - begin > runtime->dma_bytes - bytes_per_frame)\n\t\tbegin = end - (runtime->dma_bytes - bytes_per_frame);\n\n\t \n\tfirst_chunk_len = end - begin;\n\tsecond_chunk_len = 0;\n\tif (rt5677_dsp->dma_offset + first_chunk_len > runtime->dma_bytes) {\n\t\t \n\t\tsecond_chunk_len = first_chunk_len;\n\t\tfirst_chunk_len = runtime->dma_bytes - rt5677_dsp->dma_offset;\n\t\tsecond_chunk_len -= first_chunk_len;\n\t}\n\n\t \n\tret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) + begin,\n\t\t\truntime->dma_area + rt5677_dsp->dma_offset,\n\t\t\tfirst_chunk_len);\n\tif (ret)\n\t\treturn ret;\n\trt5677_dsp->dma_offset += first_chunk_len;\n\tif (rt5677_dsp->dma_offset == runtime->dma_bytes)\n\t\trt5677_dsp->dma_offset = 0;\n\n\t \n\tif (second_chunk_len) {\n\t\tret = rt5677_spi_read(RT5677_MIC_BUF_ADDR + sizeof(u32) +\n\t\t\t\tbegin + first_chunk_len, runtime->dma_area,\n\t\t\t\tsecond_chunk_len);\n\t\tif (!ret)\n\t\t\trt5677_dsp->dma_offset = second_chunk_len;\n\t}\n\treturn ret;\n}\n\n \nstatic int rt5677_spi_copy(struct rt5677_dsp *rt5677_dsp, u32 amount)\n{\n\tint ret = 0;\n\tu32 target;\n\n\tif (amount == 0)\n\t\treturn ret;\n\n\ttarget = rt5677_dsp->mic_read_offset + amount;\n\t \n\tret |= rt5677_spi_copy_block(rt5677_dsp, rt5677_dsp->mic_read_offset,\n\t\t\tmin(target, RT5677_MIC_BUF_BYTES));\n\n\tif (target >= RT5677_MIC_BUF_BYTES) {\n\t\t \n\t\ttarget -= RT5677_MIC_BUF_BYTES;\n\t\tret |= rt5677_spi_copy_block(rt5677_dsp, 0, target);\n\t}\n\n\tif (!ret)\n\t\trt5677_dsp->mic_read_offset = target;\n\treturn ret;\n}\n\n \nstatic void rt5677_spi_copy_work(struct work_struct *work)\n{\n\tstruct rt5677_dsp *rt5677_dsp =\n\t\tcontainer_of(work, struct rt5677_dsp, copy_work.work);\n\tstruct snd_pcm_runtime *runtime;\n\tu32 mic_write_offset;\n\tsize_t new_bytes, copy_bytes, period_bytes;\n\tunsigned int delay;\n\tint ret = 0;\n\n\t \n\tmutex_lock(&rt5677_dsp->dma_lock);\n\tif (!rt5677_dsp->substream) {\n\t\tdev_err(rt5677_dsp->dev, \"No pcm substream\\n\");\n\t\tgoto done;\n\t}\n\n\truntime = rt5677_dsp->substream->runtime;\n\n\tif (rt5677_spi_mic_write_offset(&mic_write_offset)) {\n\t\tdev_err(rt5677_dsp->dev, \"No mic_write_offset\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tif (rt5677_dsp->new_hotword) {\n\t\trt5677_dsp->new_hotword = false;\n\t\t \n\t\tif (mic_write_offset < RT5677_MIC_BUF_FIRST_READ_SIZE)\n\t\t\trt5677_dsp->mic_read_offset = RT5677_MIC_BUF_BYTES -\n\t\t\t\t\t(RT5677_MIC_BUF_FIRST_READ_SIZE -\n\t\t\t\t\tmic_write_offset);\n\t\telse\n\t\t\trt5677_dsp->mic_read_offset = mic_write_offset -\n\t\t\t\t\tRT5677_MIC_BUF_FIRST_READ_SIZE;\n\t}\n\n\t \n\tif (rt5677_dsp->mic_read_offset <= mic_write_offset)\n\t\tnew_bytes = mic_write_offset - rt5677_dsp->mic_read_offset;\n\telse\n\t\tnew_bytes = RT5677_MIC_BUF_BYTES + mic_write_offset\n\t\t\t\t- rt5677_dsp->mic_read_offset;\n\n\t \n\tperiod_bytes = snd_pcm_lib_period_bytes(rt5677_dsp->substream);\n\twhile (new_bytes) {\n\t\tcopy_bytes = min(new_bytes, period_bytes\n\t\t\t\t- rt5677_dsp->avail_bytes);\n\t\tret = rt5677_spi_copy(rt5677_dsp, copy_bytes);\n\t\tif (ret) {\n\t\t\tdev_err(rt5677_dsp->dev, \"Copy failed %d\\n\", ret);\n\t\t\tgoto done;\n\t\t}\n\t\trt5677_dsp->avail_bytes += copy_bytes;\n\t\tif (rt5677_dsp->avail_bytes >= period_bytes) {\n\t\t\tsnd_pcm_period_elapsed(rt5677_dsp->substream);\n\t\t\trt5677_dsp->avail_bytes = 0;\n\t\t}\n\t\tnew_bytes -= copy_bytes;\n\t}\n\n\tdelay = bytes_to_frames(runtime, period_bytes) / (runtime->rate / 1000);\n\tschedule_delayed_work(&rt5677_dsp->copy_work, msecs_to_jiffies(delay));\ndone:\n\tmutex_unlock(&rt5677_dsp->dma_lock);\n}\n\nstatic int rt5677_spi_pcm_new(struct snd_soc_component *component,\n\t\t\t      struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\treturn 0;\n}\n\nstatic int rt5677_spi_pcm_probe(struct snd_soc_component *component)\n{\n\tstruct rt5677_dsp *rt5677_dsp;\n\n\trt5677_dsp = devm_kzalloc(component->dev, sizeof(*rt5677_dsp),\n\t\t\tGFP_KERNEL);\n\tif (!rt5677_dsp)\n\t\treturn -ENOMEM;\n\trt5677_dsp->dev = &g_spi->dev;\n\tmutex_init(&rt5677_dsp->dma_lock);\n\tINIT_DELAYED_WORK(&rt5677_dsp->copy_work, rt5677_spi_copy_work);\n\n\tsnd_soc_component_set_drvdata(component, rt5677_dsp);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver rt5677_spi_dai_component = {\n\t.name\t\t\t= DRV_NAME,\n\t.probe\t\t\t= rt5677_spi_pcm_probe,\n\t.open\t\t\t= rt5677_spi_pcm_open,\n\t.close\t\t\t= rt5677_spi_pcm_close,\n\t.hw_params\t\t= rt5677_spi_hw_params,\n\t.hw_free\t\t= rt5677_spi_hw_free,\n\t.prepare\t\t= rt5677_spi_prepare,\n\t.pointer\t\t= rt5677_spi_pcm_pointer,\n\t.pcm_construct\t\t= rt5677_spi_pcm_new,\n\t.legacy_dai_naming\t= 1,\n};\n\n \nstatic u8 rt5677_spi_select_cmd(bool read, u32 align, u32 remain, u32 *len)\n{\n\tu8 cmd;\n\n\tif (align == 4 || remain <= 4) {\n\t\tcmd = RT5677_SPI_READ_32;\n\t\t*len = 4;\n\t} else {\n\t\tcmd = RT5677_SPI_READ_BURST;\n\t\t*len = (((remain - 1) >> 3) + 1) << 3;\n\t\t*len = min_t(u32, *len, RT5677_SPI_BURST_LEN);\n\t}\n\treturn read ? cmd : cmd + 1;\n}\n\n \nstatic void rt5677_spi_reverse(u8 *dst, u32 dstlen, const u8 *src, u32 srclen)\n{\n\tu32 w, i, si;\n\tu32 word_size = min_t(u32, dstlen, 8);\n\n\tfor (w = 0; w < dstlen; w += word_size) {\n\t\tfor (i = 0; i < word_size && i + w < dstlen; i++) {\n\t\t\tsi = w + word_size - i - 1;\n\t\t\tdst[w + i] = si < srclen ? src[si] : 0;\n\t\t}\n\t}\n}\n\n \nint rt5677_spi_read(u32 addr, void *rxbuf, size_t len)\n{\n\tu32 offset;\n\tint status = 0;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\t \n\tu8 header[RT5677_SPI_HEADER + 4];\n\tu8 body[RT5677_SPI_BURST_LEN];\n\tu8 spi_cmd;\n\tu8 *cb = rxbuf;\n\n\tif (!g_spi)\n\t\treturn -ENODEV;\n\n\tif ((addr & 3) || (len & 3)) {\n\t\tdev_err(&g_spi->dev, \"Bad read align 0x%x(%zu)\\n\", addr, len);\n\t\treturn -EACCES;\n\t}\n\n\tmemset(t, 0, sizeof(t));\n\tt[0].tx_buf = header;\n\tt[0].len = sizeof(header);\n\tt[0].speed_hz = RT5677_SPI_FREQ;\n\tt[1].rx_buf = body;\n\tt[1].speed_hz = RT5677_SPI_FREQ;\n\tspi_message_init_with_transfers(&m, t, ARRAY_SIZE(t));\n\n\tfor (offset = 0; offset < len; offset += t[1].len) {\n\t\tspi_cmd = rt5677_spi_select_cmd(true, (addr + offset) & 7,\n\t\t\t\tlen - offset, &t[1].len);\n\n\t\t \n\t\theader[0] = spi_cmd;\n\t\theader[1] = ((addr + offset) & 0xff000000) >> 24;\n\t\theader[2] = ((addr + offset) & 0x00ff0000) >> 16;\n\t\theader[3] = ((addr + offset) & 0x0000ff00) >> 8;\n\t\theader[4] = ((addr + offset) & 0x000000ff) >> 0;\n\n\t\tmutex_lock(&spi_mutex);\n\t\tstatus |= spi_sync(g_spi, &m);\n\t\tmutex_unlock(&spi_mutex);\n\n\n\t\t \n\t\trt5677_spi_reverse(cb + offset, len - offset, body, t[1].len);\n\t}\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt5677_spi_read);\n\n \nint rt5677_spi_write(u32 addr, const void *txbuf, size_t len)\n{\n\tu32 offset;\n\tint status = 0;\n\tstruct spi_transfer t;\n\tstruct spi_message m;\n\t \n\tu8 buf[RT5677_SPI_HEADER + RT5677_SPI_BURST_LEN + 1];\n\tu8 *body = buf + RT5677_SPI_HEADER;\n\tu8 spi_cmd;\n\tconst u8 *cb = txbuf;\n\n\tif (!g_spi)\n\t\treturn -ENODEV;\n\n\tif (addr & 3) {\n\t\tdev_err(&g_spi->dev, \"Bad write align 0x%x(%zu)\\n\", addr, len);\n\t\treturn -EACCES;\n\t}\n\n\tmemset(&t, 0, sizeof(t));\n\tt.tx_buf = buf;\n\tt.speed_hz = RT5677_SPI_FREQ;\n\tspi_message_init_with_transfers(&m, &t, 1);\n\n\tfor (offset = 0; offset < len;) {\n\t\tspi_cmd = rt5677_spi_select_cmd(false, (addr + offset) & 7,\n\t\t\t\tlen - offset, &t.len);\n\n\t\t \n\t\tbuf[0] = spi_cmd;\n\t\tbuf[1] = ((addr + offset) & 0xff000000) >> 24;\n\t\tbuf[2] = ((addr + offset) & 0x00ff0000) >> 16;\n\t\tbuf[3] = ((addr + offset) & 0x0000ff00) >> 8;\n\t\tbuf[4] = ((addr + offset) & 0x000000ff) >> 0;\n\n\t\t \n\t\trt5677_spi_reverse(body, t.len, cb + offset, len - offset);\n\t\toffset += t.len;\n\t\tt.len += RT5677_SPI_HEADER + 1;\n\n\t\tmutex_lock(&spi_mutex);\n\t\tstatus |= spi_sync(g_spi, &m);\n\t\tmutex_unlock(&spi_mutex);\n\t}\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(rt5677_spi_write);\n\nint rt5677_spi_write_firmware(u32 addr, const struct firmware *fw)\n{\n\treturn rt5677_spi_write(addr, fw->data, fw->size);\n}\nEXPORT_SYMBOL_GPL(rt5677_spi_write_firmware);\n\nvoid rt5677_spi_hotword_detected(void)\n{\n\tstruct rt5677_dsp *rt5677_dsp;\n\n\tif (!g_spi)\n\t\treturn;\n\n\trt5677_dsp = dev_get_drvdata(&g_spi->dev);\n\tif (!rt5677_dsp) {\n\t\tdev_err(&g_spi->dev, \"Can't get rt5677_dsp\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&rt5677_dsp->dma_lock);\n\tdev_info(rt5677_dsp->dev, \"Hotword detected\\n\");\n\trt5677_dsp->new_hotword = true;\n\tmutex_unlock(&rt5677_dsp->dma_lock);\n\n\tschedule_delayed_work(&rt5677_dsp->copy_work, 0);\n}\nEXPORT_SYMBOL_GPL(rt5677_spi_hotword_detected);\n\nstatic int rt5677_spi_probe(struct spi_device *spi)\n{\n\tint ret;\n\n\tg_spi = spi;\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t\t      &rt5677_spi_dai_component,\n\t\t\t\t\t      &rt5677_spi_dai, 1);\n\tif (ret < 0)\n\t\tdev_err(&spi->dev, \"Failed to register component.\\n\");\n\n\treturn ret;\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt5677_spi_acpi_id[] = {\n\t{ \"RT5677AA\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, rt5677_spi_acpi_id);\n#endif\n\nstatic struct spi_driver rt5677_spi_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.acpi_match_table = ACPI_PTR(rt5677_spi_acpi_id),\n\t},\n\t.probe = rt5677_spi_probe,\n};\nmodule_spi_driver(rt5677_spi_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT5677 SPI driver\");\nMODULE_AUTHOR(\"Oder Chiou <oder_chiou@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}