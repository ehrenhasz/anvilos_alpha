{
  "module_name": "nau8810.c",
  "hash_id": "2a50bbf19d25fdf5e895bb1b88bb3b07fb59f354049931046e89526c7393660a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8810.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"nau8810.h\"\n\n#define NAU_PLL_FREQ_MAX 100000000\n#define NAU_PLL_FREQ_MIN 90000000\n#define NAU_PLL_REF_MAX 33000000\n#define NAU_PLL_REF_MIN 8000000\n#define NAU_PLL_OPTOP_MIN 6\n\n\nstatic const int nau8810_mclk_scaler[] = { 10, 15, 20, 30, 40, 60, 80, 120 };\n\nstatic const struct reg_default nau8810_reg_defaults[] = {\n\t{ NAU8810_REG_POWER1, 0x0000 },\n\t{ NAU8810_REG_POWER2, 0x0000 },\n\t{ NAU8810_REG_POWER3, 0x0000 },\n\t{ NAU8810_REG_IFACE, 0x0050 },\n\t{ NAU8810_REG_COMP, 0x0000 },\n\t{ NAU8810_REG_CLOCK, 0x0140 },\n\t{ NAU8810_REG_SMPLR, 0x0000 },\n\t{ NAU8810_REG_DAC, 0x0000 },\n\t{ NAU8810_REG_DACGAIN, 0x00FF },\n\t{ NAU8810_REG_ADC, 0x0100 },\n\t{ NAU8810_REG_ADCGAIN, 0x00FF },\n\t{ NAU8810_REG_EQ1, 0x012C },\n\t{ NAU8810_REG_EQ2, 0x002C },\n\t{ NAU8810_REG_EQ3, 0x002C },\n\t{ NAU8810_REG_EQ4, 0x002C },\n\t{ NAU8810_REG_EQ5, 0x002C },\n\t{ NAU8810_REG_DACLIM1, 0x0032 },\n\t{ NAU8810_REG_DACLIM2, 0x0000 },\n\t{ NAU8810_REG_NOTCH1, 0x0000 },\n\t{ NAU8810_REG_NOTCH2, 0x0000 },\n\t{ NAU8810_REG_NOTCH3, 0x0000 },\n\t{ NAU8810_REG_NOTCH4, 0x0000 },\n\t{ NAU8810_REG_ALC1, 0x0038 },\n\t{ NAU8810_REG_ALC2, 0x000B },\n\t{ NAU8810_REG_ALC3, 0x0032 },\n\t{ NAU8810_REG_NOISEGATE, 0x0000 },\n\t{ NAU8810_REG_PLLN, 0x0008 },\n\t{ NAU8810_REG_PLLK1, 0x000C },\n\t{ NAU8810_REG_PLLK2, 0x0093 },\n\t{ NAU8810_REG_PLLK3, 0x00E9 },\n\t{ NAU8810_REG_ATTEN, 0x0000 },\n\t{ NAU8810_REG_INPUT_SIGNAL, 0x0003 },\n\t{ NAU8810_REG_PGAGAIN, 0x0010 },\n\t{ NAU8810_REG_ADCBOOST, 0x0100 },\n\t{ NAU8810_REG_OUTPUT, 0x0002 },\n\t{ NAU8810_REG_SPKMIX, 0x0001 },\n\t{ NAU8810_REG_SPKGAIN, 0x0039 },\n\t{ NAU8810_REG_MONOMIX, 0x0001 },\n\t{ NAU8810_REG_POWER4, 0x0000 },\n\t{ NAU8810_REG_TSLOTCTL1, 0x0000 },\n\t{ NAU8810_REG_TSLOTCTL2, 0x0020 },\n\t{ NAU8810_REG_DEVICE_REVID, 0x0000 },\n\t{ NAU8810_REG_I2C_DEVICEID, 0x001A },\n\t{ NAU8810_REG_ADDITIONID, 0x00CA },\n\t{ NAU8810_REG_RESERVE, 0x0124 },\n\t{ NAU8810_REG_OUTCTL, 0x0001 },\n\t{ NAU8810_REG_ALC1ENHAN1, 0x0010 },\n\t{ NAU8810_REG_ALC1ENHAN2, 0x0000 },\n\t{ NAU8810_REG_MISCCTL, 0x0000 },\n\t{ NAU8810_REG_OUTTIEOFF, 0x0000 },\n\t{ NAU8810_REG_AGCP2POUT, 0x0000 },\n\t{ NAU8810_REG_AGCPOUT, 0x0000 },\n\t{ NAU8810_REG_AMTCTL, 0x0000 },\n\t{ NAU8810_REG_OUTTIEOFFMAN, 0x0000 },\n};\n\nstatic bool nau8810_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8810_REG_RESET ... NAU8810_REG_SMPLR:\n\tcase NAU8810_REG_DAC ... NAU8810_REG_DACGAIN:\n\tcase NAU8810_REG_ADC ... NAU8810_REG_ADCGAIN:\n\tcase NAU8810_REG_EQ1 ... NAU8810_REG_EQ5:\n\tcase NAU8810_REG_DACLIM1 ... NAU8810_REG_DACLIM2:\n\tcase NAU8810_REG_NOTCH1 ... NAU8810_REG_NOTCH4:\n\tcase NAU8810_REG_ALC1 ... NAU8810_REG_ATTEN:\n\tcase NAU8810_REG_INPUT_SIGNAL ... NAU8810_REG_PGAGAIN:\n\tcase NAU8810_REG_ADCBOOST:\n\tcase NAU8810_REG_OUTPUT ... NAU8810_REG_SPKMIX:\n\tcase NAU8810_REG_SPKGAIN:\n\tcase NAU8810_REG_MONOMIX:\n\tcase NAU8810_REG_POWER4 ... NAU8810_REG_TSLOTCTL2:\n\tcase NAU8810_REG_DEVICE_REVID ... NAU8810_REG_RESERVE:\n\tcase NAU8810_REG_OUTCTL ... NAU8810_REG_ALC1ENHAN2:\n\tcase NAU8810_REG_MISCCTL:\n\tcase NAU8810_REG_OUTTIEOFF ... NAU8810_REG_OUTTIEOFFMAN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8810_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8810_REG_RESET ... NAU8810_REG_SMPLR:\n\tcase NAU8810_REG_DAC ... NAU8810_REG_DACGAIN:\n\tcase NAU8810_REG_ADC ... NAU8810_REG_ADCGAIN:\n\tcase NAU8810_REG_EQ1 ... NAU8810_REG_EQ5:\n\tcase NAU8810_REG_DACLIM1 ... NAU8810_REG_DACLIM2:\n\tcase NAU8810_REG_NOTCH1 ... NAU8810_REG_NOTCH4:\n\tcase NAU8810_REG_ALC1 ... NAU8810_REG_ATTEN:\n\tcase NAU8810_REG_INPUT_SIGNAL ... NAU8810_REG_PGAGAIN:\n\tcase NAU8810_REG_ADCBOOST:\n\tcase NAU8810_REG_OUTPUT ... NAU8810_REG_SPKMIX:\n\tcase NAU8810_REG_SPKGAIN:\n\tcase NAU8810_REG_MONOMIX:\n\tcase NAU8810_REG_POWER4 ... NAU8810_REG_TSLOTCTL2:\n\tcase NAU8810_REG_OUTCTL ... NAU8810_REG_ALC1ENHAN2:\n\tcase NAU8810_REG_MISCCTL:\n\tcase NAU8810_REG_OUTTIEOFF ... NAU8810_REG_OUTTIEOFFMAN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8810_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8810_REG_RESET:\n\tcase NAU8810_REG_DEVICE_REVID ... NAU8810_REG_RESERVE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int nau8810_eq_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tint i, reg, reg_val;\n\tu16 *val;\n\n\tval = (u16 *)ucontrol->value.bytes.data;\n\treg = NAU8810_REG_EQ1;\n\tfor (i = 0; i < params->max / sizeof(u16); i++) {\n\t\tregmap_read(nau8810->regmap, reg + i, &reg_val);\n\t\t \n\t\treg_val = cpu_to_be16(reg_val);\n\t\tmemcpy(val + i, &reg_val, sizeof(reg_val));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int nau8810_eq_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tvoid *data;\n\tu16 *val, value;\n\tint i, reg, ret;\n\n\tdata = kmemdup(ucontrol->value.bytes.data,\n\t\tparams->max, GFP_KERNEL | GFP_DMA);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tval = (u16 *)data;\n\treg = NAU8810_REG_EQ1;\n\tfor (i = 0; i < params->max / sizeof(u16); i++) {\n\t\t \n\t\tvalue = be16_to_cpu(*(val + i));\n\t\tret = regmap_write(nau8810->regmap, reg + i, value);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"EQ configuration fail, register: %x ret: %d\\n\",\n\t\t\t\treg + i, ret);\n\t\t\tkfree(data);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tkfree(data);\n\n\treturn 0;\n}\n\nstatic const char * const nau8810_companding[] = {\n\t\"Off\", \"NC\", \"u-law\", \"A-law\" };\n\nstatic const struct soc_enum nau8810_companding_adc_enum =\n\tSOC_ENUM_SINGLE(NAU8810_REG_COMP, NAU8810_ADCCM_SFT,\n\t\tARRAY_SIZE(nau8810_companding), nau8810_companding);\n\nstatic const struct soc_enum nau8810_companding_dac_enum =\n\tSOC_ENUM_SINGLE(NAU8810_REG_COMP, NAU8810_DACCM_SFT,\n\t\tARRAY_SIZE(nau8810_companding), nau8810_companding);\n\nstatic const char * const nau8810_deemp[] = {\n\t\"None\", \"32kHz\", \"44.1kHz\", \"48kHz\" };\n\nstatic const struct soc_enum nau8810_deemp_enum =\n\tSOC_ENUM_SINGLE(NAU8810_REG_DAC, NAU8810_DEEMP_SFT,\n\t\tARRAY_SIZE(nau8810_deemp), nau8810_deemp);\n\nstatic const char * const nau8810_eqmode[] = {\"Capture\", \"Playback\" };\n\nstatic const struct soc_enum nau8810_eqmode_enum =\n\tSOC_ENUM_SINGLE(NAU8810_REG_EQ1, NAU8810_EQM_SFT,\n\t\tARRAY_SIZE(nau8810_eqmode), nau8810_eqmode);\n\nstatic const char * const nau8810_alc[] = {\"Normal\", \"Limiter\" };\n\nstatic const struct soc_enum nau8810_alc_enum =\n\tSOC_ENUM_SINGLE(NAU8810_REG_ALC3, NAU8810_ALCM_SFT,\n\t\tARRAY_SIZE(nau8810_alc), nau8810_alc);\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);\n\nstatic const struct snd_kcontrol_new nau8810_snd_controls[] = {\n\tSOC_ENUM(\"ADC Companding\", nau8810_companding_adc_enum),\n\tSOC_ENUM(\"DAC Companding\", nau8810_companding_dac_enum),\n\tSOC_ENUM(\"DAC De-emphasis\", nau8810_deemp_enum),\n\n\tSOC_ENUM(\"EQ Function\", nau8810_eqmode_enum),\n\tSND_SOC_BYTES_EXT(\"EQ Parameters\", 10,\n\t\t  nau8810_eq_get, nau8810_eq_put),\n\n\tSOC_SINGLE(\"DAC Inversion Switch\", NAU8810_REG_DAC,\n\t\tNAU8810_DACPL_SFT, 1, 0),\n\tSOC_SINGLE_TLV(\"Playback Volume\", NAU8810_REG_DACGAIN,\n\t\tNAU8810_DACGAIN_SFT, 0xff, 0, digital_tlv),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\", NAU8810_REG_ADC,\n\t\tNAU8810_HPFEN_SFT, 1, 0),\n\tSOC_SINGLE(\"High Pass Cut Off\", NAU8810_REG_ADC,\n\t\tNAU8810_HPF_SFT, 0x7, 0),\n\n\tSOC_SINGLE(\"ADC Inversion Switch\", NAU8810_REG_ADC,\n\t\tNAU8810_ADCPL_SFT, 1, 0),\n\tSOC_SINGLE_TLV(\"Capture Volume\", NAU8810_REG_ADCGAIN,\n\t\tNAU8810_ADCGAIN_SFT, 0xff, 0, digital_tlv),\n\n\tSOC_SINGLE_TLV(\"EQ1 Volume\", NAU8810_REG_EQ1,\n\t\tNAU8810_EQ1GC_SFT, 0x18, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ2 Volume\", NAU8810_REG_EQ2,\n\t\tNAU8810_EQ2GC_SFT, 0x18, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ3 Volume\", NAU8810_REG_EQ3,\n\t\tNAU8810_EQ3GC_SFT, 0x18, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ4 Volume\", NAU8810_REG_EQ4,\n\t\tNAU8810_EQ4GC_SFT, 0x18, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ5 Volume\", NAU8810_REG_EQ5,\n\t\tNAU8810_EQ5GC_SFT, 0x18, 1, eq_tlv),\n\n\tSOC_SINGLE(\"DAC Limiter Switch\", NAU8810_REG_DACLIM1,\n\t\tNAU8810_DACLIMEN_SFT, 1, 0),\n\tSOC_SINGLE(\"DAC Limiter Decay\", NAU8810_REG_DACLIM1,\n\t\tNAU8810_DACLIMDCY_SFT, 0xf, 0),\n\tSOC_SINGLE(\"DAC Limiter Attack\", NAU8810_REG_DACLIM1,\n\t\tNAU8810_DACLIMATK_SFT, 0xf, 0),\n\tSOC_SINGLE(\"DAC Limiter Threshold\", NAU8810_REG_DACLIM2,\n\t\tNAU8810_DACLIMTHL_SFT, 0x7, 0),\n\tSOC_SINGLE(\"DAC Limiter Boost\", NAU8810_REG_DACLIM2,\n\t\tNAU8810_DACLIMBST_SFT, 0xf, 0),\n\n\tSOC_ENUM(\"ALC Mode\", nau8810_alc_enum),\n\tSOC_SINGLE(\"ALC Enable Switch\", NAU8810_REG_ALC1,\n\t\tNAU8810_ALCEN_SFT, 1, 0),\n\tSOC_SINGLE(\"ALC Max Volume\", NAU8810_REG_ALC1,\n\t\tNAU8810_ALCMXGAIN_SFT, 0x7, 0),\n\tSOC_SINGLE(\"ALC Min Volume\", NAU8810_REG_ALC1,\n\t\tNAU8810_ALCMINGAIN_SFT, 0x7, 0),\n\tSOC_SINGLE(\"ALC ZC Switch\", NAU8810_REG_ALC2,\n\t\tNAU8810_ALCZC_SFT, 1, 0),\n\tSOC_SINGLE(\"ALC Hold\", NAU8810_REG_ALC2,\n\t\tNAU8810_ALCHT_SFT, 0xf, 0),\n\tSOC_SINGLE(\"ALC Target\", NAU8810_REG_ALC2,\n\t\tNAU8810_ALCSL_SFT, 0xf, 0),\n\tSOC_SINGLE(\"ALC Decay\", NAU8810_REG_ALC3,\n\t\tNAU8810_ALCDCY_SFT, 0xf, 0),\n\tSOC_SINGLE(\"ALC Attack\", NAU8810_REG_ALC3,\n\t\tNAU8810_ALCATK_SFT, 0xf, 0),\n\tSOC_SINGLE(\"ALC Noise Gate Switch\", NAU8810_REG_NOISEGATE,\n\t\tNAU8810_ALCNEN_SFT, 1, 0),\n\tSOC_SINGLE(\"ALC Noise Gate Threshold\", NAU8810_REG_NOISEGATE,\n\t\tNAU8810_ALCNTH_SFT, 0x7, 0),\n\n\tSOC_SINGLE(\"PGA ZC Switch\", NAU8810_REG_PGAGAIN,\n\t\tNAU8810_PGAZC_SFT, 1, 0),\n\tSOC_SINGLE_TLV(\"PGA Volume\", NAU8810_REG_PGAGAIN,\n\t\tNAU8810_PGAGAIN_SFT, 0x3f, 0, inpga_tlv),\n\n\tSOC_SINGLE(\"Speaker ZC Switch\", NAU8810_REG_SPKGAIN,\n\t\tNAU8810_SPKZC_SFT, 1, 0),\n\tSOC_SINGLE(\"Speaker Mute Switch\", NAU8810_REG_SPKGAIN,\n\t\tNAU8810_SPKMT_SFT, 1, 0),\n\tSOC_SINGLE_TLV(\"Speaker Volume\", NAU8810_REG_SPKGAIN,\n\t\tNAU8810_SPKGAIN_SFT, 0x3f, 0, spk_tlv),\n\n\tSOC_SINGLE(\"Capture Boost(+20dB)\", NAU8810_REG_ADCBOOST,\n\t\tNAU8810_PGABST_SFT, 1, 0),\n\tSOC_SINGLE(\"Mono Mute Switch\", NAU8810_REG_MONOMIX,\n\t\tNAU8810_MOUTMXMT_SFT, 1, 0),\n\n\tSOC_SINGLE(\"DAC Oversampling Rate(128x) Switch\", NAU8810_REG_DAC,\n\t\tNAU8810_DACOS_SFT, 1, 0),\n\tSOC_SINGLE(\"ADC Oversampling Rate(128x) Switch\", NAU8810_REG_ADC,\n\t\tNAU8810_ADCOS_SFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8810_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"AUX Bypass Switch\", NAU8810_REG_SPKMIX,\n\t\tNAU8810_AUXSPK_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", NAU8810_REG_SPKMIX,\n\t\tNAU8810_BYPSPK_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", NAU8810_REG_SPKMIX,\n\t\tNAU8810_DACSPK_SFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8810_mono_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"AUX Bypass Switch\", NAU8810_REG_MONOMIX,\n\t\tNAU8810_AUXMOUT_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", NAU8810_REG_MONOMIX,\n\t\tNAU8810_BYPMOUT_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", NAU8810_REG_MONOMIX,\n\t\tNAU8810_DACMOUT_SFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8810_pgaboost_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"AUX PGA Switch\", NAU8810_REG_ADCBOOST,\n\t\tNAU8810_AUXBSTGAIN_SFT, 0x7, 0),\n\tSOC_DAPM_SINGLE(\"PGA Mute Switch\", NAU8810_REG_PGAGAIN,\n\t\tNAU8810_PGAMT_SFT, 1, 1),\n\tSOC_DAPM_SINGLE(\"PMIC PGA Switch\", NAU8810_REG_ADCBOOST,\n\t\tNAU8810_PMICBSTGAIN_SFT, 0x7, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8810_inpga[] = {\n\tSOC_DAPM_SINGLE(\"AUX Switch\", NAU8810_REG_INPUT_SIGNAL,\n\t\tNAU8810_AUXPGA_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", NAU8810_REG_INPUT_SIGNAL,\n\t\tNAU8810_NMICPGA_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", NAU8810_REG_INPUT_SIGNAL,\n\t\tNAU8810_PMICPGA_SFT, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new nau8810_loopback =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8810_REG_COMP,\n\t\tNAU8810_ADDAP_SFT, 1, 0);\n\nstatic int check_mclk_select_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tunsigned int value;\n\n\tregmap_read(nau8810->regmap, NAU8810_REG_CLOCK, &value);\n\treturn (value & NAU8810_CLKM_MASK);\n}\n\nstatic int check_mic_enabled(struct snd_soc_dapm_widget *source,\n\tstruct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tunsigned int value;\n\n\tregmap_read(nau8810->regmap, NAU8810_REG_INPUT_SIGNAL, &value);\n\tif (value & NAU8810_PMICPGA_EN || value & NAU8810_NMICPGA_EN)\n\t\treturn 1;\n\tregmap_read(nau8810->regmap, NAU8810_REG_ADCBOOST, &value);\n\tif (value & NAU8810_PMICBSTGAIN_MASK)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget nau8810_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Speaker Mixer\", NAU8810_REG_POWER3,\n\t\tNAU8810_SPKMX_EN_SFT, 0, &nau8810_speaker_mixer_controls[0],\n\t\tARRAY_SIZE(nau8810_speaker_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mono Mixer\", NAU8810_REG_POWER3,\n\t\tNAU8810_MOUTMX_EN_SFT, 0, &nau8810_mono_mixer_controls[0],\n\t\tARRAY_SIZE(nau8810_mono_mixer_controls)),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", NAU8810_REG_POWER3,\n\t\tNAU8810_DAC_EN_SFT, 0),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", NAU8810_REG_POWER2,\n\t\tNAU8810_ADC_EN_SFT, 0),\n\tSND_SOC_DAPM_PGA(\"SpkN Out\", NAU8810_REG_POWER3,\n\t\tNAU8810_NSPK_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SpkP Out\", NAU8810_REG_POWER3,\n\t\tNAU8810_PSPK_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mono Out\", NAU8810_REG_POWER3,\n\t\tNAU8810_MOUT_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Input PGA\", NAU8810_REG_POWER2,\n\t\tNAU8810_PGA_EN_SFT, 0, nau8810_inpga,\n\t\tARRAY_SIZE(nau8810_inpga)),\n\tSND_SOC_DAPM_MIXER(\"Input Boost Stage\", NAU8810_REG_POWER2,\n\t\tNAU8810_BST_EN_SFT, 0, nau8810_pgaboost_mixer_controls,\n\t\tARRAY_SIZE(nau8810_pgaboost_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"AUX Input\", NAU8810_REG_POWER1,\n\t\tNAU8810_AUX_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", NAU8810_REG_POWER1,\n\t\tNAU8810_MICBIAS_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL\", NAU8810_REG_POWER1,\n\t\tNAU8810_PLL_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"Digital Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t&nau8810_loopback),\n\n\tSND_SOC_DAPM_INPUT(\"AUX\"),\n\tSND_SOC_DAPM_INPUT(\"MICN\"),\n\tSND_SOC_DAPM_INPUT(\"MICP\"),\n\tSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTN\"),\n};\n\nstatic const struct snd_soc_dapm_route nau8810_dapm_routes[] = {\n\t{\"DAC\", NULL, \"PLL\", check_mclk_select_pll},\n\n\t \n\t{\"Mono Mixer\", \"AUX Bypass Switch\", \"AUX Input\"},\n\t{\"Mono Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Mono Mixer\", \"Line Bypass Switch\", \"Input Boost Stage\"},\n\n\t \n\t{\"Speaker Mixer\", \"AUX Bypass Switch\", \"AUX Input\"},\n\t{\"Speaker Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Speaker Mixer\", \"Line Bypass Switch\", \"Input Boost Stage\"},\n\n\t \n\t{\"Mono Out\", NULL, \"Mono Mixer\"},\n\t{\"MONOOUT\", NULL, \"Mono Out\"},\n\t{\"SpkN Out\", NULL, \"Speaker Mixer\"},\n\t{\"SpkP Out\", NULL, \"Speaker Mixer\"},\n\t{\"SPKOUTN\", NULL, \"SpkN Out\"},\n\t{\"SPKOUTP\", NULL, \"SpkP Out\"},\n\n\t \n\t{\"ADC\", NULL, \"Input Boost Stage\"},\n\t{\"ADC\", NULL, \"PLL\", check_mclk_select_pll},\n\t{\"Input Boost Stage\", \"AUX PGA Switch\", \"AUX Input\"},\n\t{\"Input Boost Stage\", \"PGA Mute Switch\", \"Input PGA\"},\n\t{\"Input Boost Stage\", \"PMIC PGA Switch\", \"MICP\"},\n\n\t \n\t{\"Input PGA\", NULL, \"Mic Bias\", check_mic_enabled},\n\t{\"Input PGA\", \"AUX Switch\", \"AUX Input\"},\n\t{\"Input PGA\", \"MicN Switch\", \"MICN\"},\n\t{\"Input PGA\", \"MicP Switch\", \"MICP\"},\n\t{\"AUX Input\", NULL, \"AUX\"},\n\n\t \n\t{\"Digital Loopback\", \"Switch\", \"ADC\"},\n\t{\"DAC\", NULL, \"Digital Loopback\"},\n};\n\nstatic int nau8810_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\n\tnau8810->clk_id = clk_id;\n\tnau8810->sysclk = freq;\n\tdev_dbg(nau8810->dev, \"master sysclk %dHz, source %s\\n\",\n\t\tfreq, clk_id == NAU8810_SCLK_PLL ? \"PLL\" : \"MCLK\");\n\n\treturn 0;\n}\n\nstatic int nau8810_calc_pll(unsigned int pll_in,\n\tunsigned int fs, struct nau8810_pll *pll_param)\n{\n\tu64 f2, f2_max, pll_ratio;\n\tint i, scal_sel;\n\n\tif (pll_in > NAU_PLL_REF_MAX || pll_in < NAU_PLL_REF_MIN)\n\t\treturn -EINVAL;\n\n\tf2_max = 0;\n\tscal_sel = ARRAY_SIZE(nau8810_mclk_scaler);\n\tfor (i = 0; i < ARRAY_SIZE(nau8810_mclk_scaler); i++) {\n\t\tf2 = 256ULL * fs * 4 * nau8810_mclk_scaler[i];\n\t\tf2 = div_u64(f2, 10);\n\t\tif (f2 > NAU_PLL_FREQ_MIN && f2 < NAU_PLL_FREQ_MAX &&\n\t\t\tf2_max < f2) {\n\t\t\tf2_max = f2;\n\t\t\tscal_sel = i;\n\t\t}\n\t}\n\tif (ARRAY_SIZE(nau8810_mclk_scaler) == scal_sel)\n\t\treturn -EINVAL;\n\tpll_param->mclk_scaler = scal_sel;\n\tf2 = f2_max;\n\n\t \n\tpll_ratio = div_u64(f2 << 28, pll_in);\n\tpll_param->pre_factor = 0;\n\tif (((pll_ratio >> 28) & 0xF) < NAU_PLL_OPTOP_MIN) {\n\t\tpll_ratio <<= 1;\n\t\tpll_param->pre_factor = 1;\n\t}\n\tpll_param->pll_int = (pll_ratio >> 28) & 0xF;\n\tpll_param->pll_frac = ((pll_ratio & 0xFFFFFFF) >> 4);\n\n\treturn 0;\n}\n\nstatic int nau8810_set_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map = nau8810->regmap;\n\tstruct nau8810_pll *pll_param = &nau8810->pll;\n\tint ret, fs;\n\n\tfs = freq_out / 256;\n\tret = nau8810_calc_pll(freq_in, fs, pll_param);\n\tif (ret < 0) {\n\t\tdev_err(nau8810->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\tdev_info(nau8810->dev, \"pll_int=%x pll_frac=%x mclk_scaler=%x pre_factor=%x\\n\",\n\t\tpll_param->pll_int, pll_param->pll_frac, pll_param->mclk_scaler,\n\t\tpll_param->pre_factor);\n\n\tregmap_update_bits(map, NAU8810_REG_PLLN,\n\t\tNAU8810_PLLMCLK_DIV2 | NAU8810_PLLN_MASK,\n\t\t(pll_param->pre_factor ? NAU8810_PLLMCLK_DIV2 : 0) |\n\t\tpll_param->pll_int);\n\tregmap_write(map, NAU8810_REG_PLLK1,\n\t\t(pll_param->pll_frac >> NAU8810_PLLK1_SFT) &\n\t\tNAU8810_PLLK1_MASK);\n\tregmap_write(map, NAU8810_REG_PLLK2,\n\t\t(pll_param->pll_frac >> NAU8810_PLLK2_SFT) &\n\t\tNAU8810_PLLK2_MASK);\n\tregmap_write(map, NAU8810_REG_PLLK3,\n\t\tpll_param->pll_frac & NAU8810_PLLK3_MASK);\n\tregmap_update_bits(map, NAU8810_REG_CLOCK, NAU8810_MCLKSEL_MASK,\n\t\tpll_param->mclk_scaler << NAU8810_MCLKSEL_SFT);\n\tregmap_update_bits(map, NAU8810_REG_CLOCK,\n\t\tNAU8810_CLKM_MASK, NAU8810_CLKM_PLL);\n\n\treturn 0;\n}\n\nstatic int nau8810_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tu16 ctrl1_val = 0, ctrl2_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl2_val |= NAU8810_CLKIO_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= NAU8810_AIFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= NAU8810_AIFMT_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= NAU8810_AIFMT_PCM_A;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tctrl1_val |= NAU8810_BCLKP_IB | NAU8810_FSP_IF;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= NAU8810_BCLKP_IB;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tctrl1_val |= NAU8810_FSP_IF;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_IFACE,\n\t\tNAU8810_AIFMT_MASK | NAU8810_FSP_IF |\n\t\tNAU8810_BCLKP_IB, ctrl1_val);\n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\n\t\tNAU8810_CLKIO_MASK, ctrl2_val);\n\n\treturn 0;\n}\n\nstatic int nau8810_mclk_clkdiv(struct nau8810 *nau8810, int rate)\n{\n\tint i, sclk, imclk = rate * 256, div = 0;\n\n\tif (!nau8810->sysclk) {\n\t\tdev_err(nau8810->dev, \"Make mclk div configuration fail because of invalid system clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 1; i < ARRAY_SIZE(nau8810_mclk_scaler); i++) {\n\t\tsclk = (nau8810->sysclk * 10) /\n\t\t\tnau8810_mclk_scaler[i];\n\t\tif (sclk < imclk)\n\t\t\tbreak;\n\t\tdiv = i;\n\t}\n\tdev_dbg(nau8810->dev,\n\t\t\"master clock prescaler %x for fs %d\\n\", div, rate);\n\n\t \n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\n\t\tNAU8810_MCLKSEL_MASK, (div << NAU8810_MCLKSEL_SFT));\n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\n\t\tNAU8810_CLKM_MASK, NAU8810_CLKM_MCLK);\n\n\treturn 0;\n}\n\nstatic int nau8810_pcm_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tint val_len = 0, val_rate = 0, ret = 0;\n\tunsigned int ctrl_val, bclk_fs, bclk_div;\n\n\t \n\tregmap_read(nau8810->regmap, NAU8810_REG_CLOCK, &ctrl_val);\n\tif (ctrl_val & NAU8810_CLKIO_MASTER) {\n\t\t \n\t\tbclk_fs = snd_soc_params_to_bclk(params) / params_rate(params);\n\t\tif (bclk_fs <= 32)\n\t\t\tbclk_div = NAU8810_BCLKDIV_8;\n\t\telse if (bclk_fs <= 64)\n\t\t\tbclk_div = NAU8810_BCLKDIV_4;\n\t\telse if (bclk_fs <= 128)\n\t\t\tbclk_div = NAU8810_BCLKDIV_2;\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\n\t\t\tNAU8810_BCLKSEL_MASK, bclk_div);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= NAU8810_WLEN_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= NAU8810_WLEN_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len |= NAU8810_WLEN_32;\n\t\tbreak;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tval_rate |= NAU8810_SMPLR_8K;\n\t\tbreak;\n\tcase 11025:\n\t\tval_rate |= NAU8810_SMPLR_12K;\n\t\tbreak;\n\tcase 16000:\n\t\tval_rate |= NAU8810_SMPLR_16K;\n\t\tbreak;\n\tcase 22050:\n\t\tval_rate |= NAU8810_SMPLR_24K;\n\t\tbreak;\n\tcase 32000:\n\t\tval_rate |= NAU8810_SMPLR_32K;\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\t}\n\n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_IFACE,\n\t\tNAU8810_WLEN_MASK, val_len);\n\tregmap_update_bits(nau8810->regmap, NAU8810_REG_SMPLR,\n\t\tNAU8810_SMPLR_MASK, val_rate);\n\n\t \n\tif (nau8810->clk_id == NAU8810_SCLK_MCLK) {\n\t\tret = nau8810_mclk_clkdiv(nau8810, params_rate(params));\n\t\tif (ret < 0)\n\t\t\tdev_err(nau8810->dev, \"MCLK div configuration fail\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int nau8810_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct nau8810 *nau8810 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *map = nau8810->regmap;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tregmap_update_bits(map, NAU8810_REG_POWER1,\n\t\t\tNAU8810_REFIMP_MASK, NAU8810_REFIMP_80K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_update_bits(map, NAU8810_REG_POWER1,\n\t\t\tNAU8810_IOBUF_EN | NAU8810_ABIAS_EN,\n\t\t\tNAU8810_IOBUF_EN | NAU8810_ABIAS_EN);\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_sync(map);\n\t\t\tregmap_update_bits(map, NAU8810_REG_POWER1,\n\t\t\t\tNAU8810_REFIMP_MASK, NAU8810_REFIMP_3K);\n\t\t\tmdelay(100);\n\t\t}\n\t\tregmap_update_bits(map, NAU8810_REG_POWER1,\n\t\t\tNAU8810_REFIMP_MASK, NAU8810_REFIMP_300K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_write(map, NAU8810_REG_POWER1, 0);\n\t\tregmap_write(map, NAU8810_REG_POWER2, 0);\n\t\tregmap_write(map, NAU8810_REG_POWER3, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\n#define NAU8810_RATES (SNDRV_PCM_RATE_8000_48000)\n\n#define NAU8810_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops nau8810_ops = {\n\t.hw_params = nau8810_pcm_hw_params,\n\t.set_fmt = nau8810_set_dai_fmt,\n\t.set_sysclk = nau8810_set_sysclk,\n\t.set_pll = nau8810_set_pll,\n};\n\nstatic struct snd_soc_dai_driver nau8810_dai = {\n\t.name = \"nau8810-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,    \n\t\t.rates = NAU8810_RATES,\n\t\t.formats = NAU8810_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,    \n\t\t.rates = NAU8810_RATES,\n\t\t.formats = NAU8810_FORMATS,\n\t},\n\t.ops = &nau8810_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic const struct regmap_config nau8810_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = NAU8810_REG_MAX,\n\t.readable_reg = nau8810_readable_reg,\n\t.writeable_reg = nau8810_writeable_reg,\n\t.volatile_reg = nau8810_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8810_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8810_reg_defaults),\n};\n\nstatic const struct snd_soc_component_driver nau8810_component_driver = {\n\t.set_bias_level\t\t= nau8810_set_bias_level,\n\t.controls\t\t= nau8810_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(nau8810_snd_controls),\n\t.dapm_widgets\t\t= nau8810_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(nau8810_dapm_widgets),\n\t.dapm_routes\t\t= nau8810_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(nau8810_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int nau8810_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8810 *nau8810 = dev_get_platdata(dev);\n\n\tif (!nau8810) {\n\t\tnau8810 = devm_kzalloc(dev, sizeof(*nau8810), GFP_KERNEL);\n\t\tif (!nau8810)\n\t\t\treturn -ENOMEM;\n\t}\n\ti2c_set_clientdata(i2c, nau8810);\n\n\tnau8810->regmap = devm_regmap_init_i2c(i2c, &nau8810_regmap_config);\n\tif (IS_ERR(nau8810->regmap))\n\t\treturn PTR_ERR(nau8810->regmap);\n\tnau8810->dev = dev;\n\n\tregmap_write(nau8810->regmap, NAU8810_REG_RESET, 0x00);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t&nau8810_component_driver, &nau8810_dai, 1);\n}\n\nstatic const struct i2c_device_id nau8810_i2c_id[] = {\n\t{ \"nau8810\", 0 },\n\t{ \"nau8812\", 0 },\n\t{ \"nau8814\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8810_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8810_of_match[] = {\n\t{ .compatible = \"nuvoton,nau8810\", },\n\t{ .compatible = \"nuvoton,nau8812\", },\n\t{ .compatible = \"nuvoton,nau8814\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, nau8810_of_match);\n#endif\n\nstatic struct i2c_driver nau8810_i2c_driver = {\n\t.driver = {\n\t\t.name = \"nau8810\",\n\t\t.of_match_table = of_match_ptr(nau8810_of_match),\n\t},\n\t.probe = nau8810_i2c_probe,\n\t.id_table = nau8810_i2c_id,\n};\n\nmodule_i2c_driver(nau8810_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC NAU8810 driver\");\nMODULE_AUTHOR(\"David Lin <ctlin0@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}