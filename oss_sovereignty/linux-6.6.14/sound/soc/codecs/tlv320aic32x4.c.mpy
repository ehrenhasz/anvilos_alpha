{
  "module_name": "tlv320aic32x4.c",
  "hash_id": "9974e7452f58bade94e7b45fa9748507c0db7f301c59946be2a4abda83e6246a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic32x4.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/cdev.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/of_clk.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/tlv320aic32x4.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"tlv320aic32x4.h\"\n\nstruct aic32x4_priv {\n\tstruct regmap *regmap;\n\tu32 power_cfg;\n\tu32 micpga_routing;\n\tbool swapdacs;\n\tint rstn_gpio;\n\tconst char *mclk_name;\n\n\tstruct regulator *supply_ldo;\n\tstruct regulator *supply_iov;\n\tstruct regulator *supply_dv;\n\tstruct regulator *supply_av;\n\n\tstruct aic32x4_setup_data *setup;\n\tstruct device *dev;\n\tenum aic32x4_type type;\n\n\tunsigned int fmt;\n};\n\nstatic int aic32x4_reset_adc(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu32 adc_reg;\n\n\t \n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tadc_reg = snd_soc_component_read(component, AIC32X4_ADCSETUP);\n\t\tsnd_soc_component_write(component, AIC32X4_ADCSETUP, adc_reg |\n\t\t\t\t\tAIC32X4_LADC_EN | AIC32X4_RADC_EN);\n\t\tsnd_soc_component_write(component, AIC32X4_ADCSETUP, adc_reg);\n\t\tbreak;\n\t}\n\treturn 0;\n};\n\nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, AIC32X4_MICBIAS,\n\t\t\t\tAIC32x4_MICBIAS_MASK,\n\t\t\t\tAIC32X4_MICBIAS_LDOIN |\n\t\t\t\tAIC32X4_MICBIAS_2075V);\n\t\tprintk(KERN_DEBUG \"%s: Mic Bias will be turned ON\\n\", __func__);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, AIC32X4_MICBIAS,\n\t\t\t\tAIC32x4_MICBIAS_MASK, 0);\n\t\tprintk(KERN_DEBUG \"%s: Mic Bias will be turned OFF\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int aic32x4_get_mfp1_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\n\tval = snd_soc_component_read(component, AIC32X4_DINCTL);\n\n\tucontrol->value.integer.value[0] = (val & 0x01);\n\n\treturn 0;\n};\n\nstatic int aic32x4_set_mfp2_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\tu8 gpio_check;\n\n\tval = snd_soc_component_read(component, AIC32X4_DOUTCTL);\n\tgpio_check = (val & AIC32X4_MFP_GPIO_ENABLED);\n\tif (gpio_check != AIC32X4_MFP_GPIO_ENABLED) {\n\t\tprintk(KERN_ERR \"%s: MFP2 is not configure as a GPIO output\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucontrol->value.integer.value[0] == (val & AIC32X4_MFP2_GPIO_OUT_HIGH))\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= ucontrol->value.integer.value[0];\n\telse\n\t\tval &= ~AIC32X4_MFP2_GPIO_OUT_HIGH;\n\n\tsnd_soc_component_write(component, AIC32X4_DOUTCTL, val);\n\n\treturn 0;\n};\n\nstatic int aic32x4_get_mfp3_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\n\tval = snd_soc_component_read(component, AIC32X4_SCLKCTL);\n\n\tucontrol->value.integer.value[0] = (val & 0x01);\n\n\treturn 0;\n};\n\nstatic int aic32x4_set_mfp4_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\tu8 gpio_check;\n\n\tval = snd_soc_component_read(component, AIC32X4_MISOCTL);\n\tgpio_check = (val & AIC32X4_MFP_GPIO_ENABLED);\n\tif (gpio_check != AIC32X4_MFP_GPIO_ENABLED) {\n\t\tprintk(KERN_ERR \"%s: MFP4 is not configure as a GPIO output\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucontrol->value.integer.value[0] == (val & AIC32X4_MFP5_GPIO_OUT_HIGH))\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= ucontrol->value.integer.value[0];\n\telse\n\t\tval &= ~AIC32X4_MFP5_GPIO_OUT_HIGH;\n\n\tsnd_soc_component_write(component, AIC32X4_MISOCTL, val);\n\n\treturn 0;\n};\n\nstatic int aic32x4_get_mfp5_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\n\tval = snd_soc_component_read(component, AIC32X4_GPIOCTL);\n\tucontrol->value.integer.value[0] = ((val & 0x2) >> 1);\n\n\treturn 0;\n};\n\nstatic int aic32x4_set_mfp5_gpio(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tu8 val;\n\tu8 gpio_check;\n\n\tval = snd_soc_component_read(component, AIC32X4_GPIOCTL);\n\tgpio_check = (val & AIC32X4_MFP5_GPIO_OUTPUT);\n\tif (gpio_check != AIC32X4_MFP5_GPIO_OUTPUT) {\n\t\tprintk(KERN_ERR \"%s: MFP5 is not configure as a GPIO output\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucontrol->value.integer.value[0] == (val & 0x1))\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval |= ucontrol->value.integer.value[0];\n\telse\n\t\tval &= 0xfe;\n\n\tsnd_soc_component_write(component, AIC32X4_GPIOCTL, val);\n\n\treturn 0;\n};\n\nstatic const struct snd_kcontrol_new aic32x4_mfp1[] = {\n\tSOC_SINGLE_BOOL_EXT(\"MFP1 GPIO\", 0, aic32x4_get_mfp1_gpio, NULL),\n};\n\nstatic const struct snd_kcontrol_new aic32x4_mfp2[] = {\n\tSOC_SINGLE_BOOL_EXT(\"MFP2 GPIO\", 0, NULL, aic32x4_set_mfp2_gpio),\n};\n\nstatic const struct snd_kcontrol_new aic32x4_mfp3[] = {\n\tSOC_SINGLE_BOOL_EXT(\"MFP3 GPIO\", 0, aic32x4_get_mfp3_gpio, NULL),\n};\n\nstatic const struct snd_kcontrol_new aic32x4_mfp4[] = {\n\tSOC_SINGLE_BOOL_EXT(\"MFP4 GPIO\", 0, NULL, aic32x4_set_mfp4_gpio),\n};\n\nstatic const struct snd_kcontrol_new aic32x4_mfp5[] = {\n\tSOC_SINGLE_BOOL_EXT(\"MFP5 GPIO\", 0, aic32x4_get_mfp5_gpio,\n\t\taic32x4_set_mfp5_gpio),\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(tlv_step_0_5, 0, 50, 0);\n \nstatic DECLARE_TLV_DB_SCALE(tlv_pcm, -6350, 50, 0);\n \nstatic DECLARE_TLV_DB_SCALE(tlv_driver_gain, -600, 100, 0);\n \nstatic DECLARE_TLV_DB_SCALE(tlv_adc_vol, -1200, 50, 0);\n \nstatic DECLARE_TLV_DB_SCALE(tlv_tas_driver_gain, -5850, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(tlv_amp_vol, 0, 600, 1);\n\nstatic const char * const lo_cm_text[] = {\n\t\"Full Chip\", \"1.65V\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(lo_cm_enum, AIC32X4_CMMODE, 3, lo_cm_text);\n\nstatic const char * const ptm_text[] = {\n\t\"P3\", \"P2\", \"P1\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(l_ptm_enum, AIC32X4_LPLAYBACK, 2, ptm_text);\nstatic SOC_ENUM_SINGLE_DECL(r_ptm_enum, AIC32X4_RPLAYBACK, 2, ptm_text);\n\nstatic const struct snd_kcontrol_new aic32x4_snd_controls[] = {\n\tSOC_DOUBLE_R_S_TLV(\"PCM Playback Volume\", AIC32X4_LDACVOL,\n\t\t\tAIC32X4_RDACVOL, 0, -0x7f, 0x30, 7, 0, tlv_pcm),\n\tSOC_ENUM(\"DAC Left Playback PowerTune Switch\", l_ptm_enum),\n\tSOC_ENUM(\"DAC Right Playback PowerTune Switch\", r_ptm_enum),\n\tSOC_DOUBLE_R_S_TLV(\"HP Driver Gain Volume\", AIC32X4_HPLGAIN,\n\t\t\tAIC32X4_HPRGAIN, 0, -0x6, 0x1d, 5, 0,\n\t\t\ttlv_driver_gain),\n\tSOC_DOUBLE_R_S_TLV(\"LO Driver Gain Volume\", AIC32X4_LOLGAIN,\n\t\t\tAIC32X4_LORGAIN, 0, -0x6, 0x1d, 5, 0,\n\t\t\ttlv_driver_gain),\n\tSOC_DOUBLE_R(\"HP DAC Playback Switch\", AIC32X4_HPLGAIN,\n\t\t\tAIC32X4_HPRGAIN, 6, 0x01, 1),\n\tSOC_DOUBLE_R(\"LO DAC Playback Switch\", AIC32X4_LOLGAIN,\n\t\t\tAIC32X4_LORGAIN, 6, 0x01, 1),\n\tSOC_ENUM(\"LO Playback Common Mode Switch\", lo_cm_enum),\n\tSOC_DOUBLE_R(\"Mic PGA Switch\", AIC32X4_LMICPGAVOL,\n\t\t\tAIC32X4_RMICPGAVOL, 7, 0x01, 1),\n\n\tSOC_SINGLE(\"ADCFGA Left Mute Switch\", AIC32X4_ADCFGA, 7, 1, 0),\n\tSOC_SINGLE(\"ADCFGA Right Mute Switch\", AIC32X4_ADCFGA, 3, 1, 0),\n\n\tSOC_DOUBLE_R_S_TLV(\"ADC Level Volume\", AIC32X4_LADCVOL,\n\t\t\tAIC32X4_RADCVOL, 0, -0x18, 0x28, 6, 0, tlv_adc_vol),\n\tSOC_DOUBLE_R_TLV(\"PGA Level Volume\", AIC32X4_LMICPGAVOL,\n\t\t\tAIC32X4_RMICPGAVOL, 0, 0x5f, 0, tlv_step_0_5),\n\n\tSOC_SINGLE(\"Auto-mute Switch\", AIC32X4_DACMUTE, 4, 7, 0),\n\n\tSOC_SINGLE(\"AGC Left Switch\", AIC32X4_LAGC1, 7, 1, 0),\n\tSOC_SINGLE(\"AGC Right Switch\", AIC32X4_RAGC1, 7, 1, 0),\n\tSOC_DOUBLE_R(\"AGC Target Level\", AIC32X4_LAGC1, AIC32X4_RAGC1,\n\t\t\t4, 0x07, 0),\n\tSOC_DOUBLE_R(\"AGC Gain Hysteresis\", AIC32X4_LAGC1, AIC32X4_RAGC1,\n\t\t\t0, 0x03, 0),\n\tSOC_DOUBLE_R(\"AGC Hysteresis\", AIC32X4_LAGC2, AIC32X4_RAGC2,\n\t\t\t6, 0x03, 0),\n\tSOC_DOUBLE_R(\"AGC Noise Threshold\", AIC32X4_LAGC2, AIC32X4_RAGC2,\n\t\t\t1, 0x1F, 0),\n\tSOC_DOUBLE_R(\"AGC Max PGA\", AIC32X4_LAGC3, AIC32X4_RAGC3,\n\t\t\t0, 0x7F, 0),\n\tSOC_DOUBLE_R(\"AGC Attack Time\", AIC32X4_LAGC4, AIC32X4_RAGC4,\n\t\t\t3, 0x1F, 0),\n\tSOC_DOUBLE_R(\"AGC Decay Time\", AIC32X4_LAGC5, AIC32X4_RAGC5,\n\t\t\t3, 0x1F, 0),\n\tSOC_DOUBLE_R(\"AGC Noise Debounce\", AIC32X4_LAGC6, AIC32X4_RAGC6,\n\t\t\t0, 0x1F, 0),\n\tSOC_DOUBLE_R(\"AGC Signal Debounce\", AIC32X4_LAGC7, AIC32X4_RAGC7,\n\t\t\t0, 0x0F, 0),\n};\n\nstatic const struct snd_kcontrol_new hpl_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"L_DAC Switch\", AIC32X4_HPLROUTE, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1_L Switch\", AIC32X4_HPLROUTE, 2, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new hpr_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"R_DAC Switch\", AIC32X4_HPRROUTE, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1_R Switch\", AIC32X4_HPRROUTE, 2, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new lol_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"L_DAC Switch\", AIC32X4_LOLROUTE, 3, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new lor_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"R_DAC Switch\", AIC32X4_LORROUTE, 3, 1, 0),\n};\n\nstatic const char * const resistor_text[] = {\n\t\"Off\", \"10 kOhm\", \"20 kOhm\", \"40 kOhm\",\n};\n\n \nstatic SOC_ENUM_SINGLE_DECL(in1l_lpga_p_enum, AIC32X4_LMICPGAPIN, 6, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in2l_lpga_p_enum, AIC32X4_LMICPGAPIN, 4, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in3l_lpga_p_enum, AIC32X4_LMICPGAPIN, 2, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in1r_lpga_p_enum, AIC32X4_LMICPGAPIN, 0, resistor_text);\n\nstatic SOC_ENUM_SINGLE_DECL(cml_lpga_n_enum, AIC32X4_LMICPGANIN, 6, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in2r_lpga_n_enum, AIC32X4_LMICPGANIN, 4, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in3r_lpga_n_enum, AIC32X4_LMICPGANIN, 2, resistor_text);\n\nstatic const struct snd_kcontrol_new in1l_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN1_L L+ Switch\", in1l_lpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in2l_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN2_L L+ Switch\", in2l_lpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in3l_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN3_L L+ Switch\", in3l_lpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in1r_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN1_R L+ Switch\", in1r_lpga_p_enum),\n};\nstatic const struct snd_kcontrol_new cml_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"CM_L L- Switch\", cml_lpga_n_enum),\n};\nstatic const struct snd_kcontrol_new in2r_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN2_R L- Switch\", in2r_lpga_n_enum),\n};\nstatic const struct snd_kcontrol_new in3r_to_lmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN3_R L- Switch\", in3r_lpga_n_enum),\n};\n\n \nstatic SOC_ENUM_SINGLE_DECL(in1r_rpga_p_enum, AIC32X4_RMICPGAPIN, 6, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in2r_rpga_p_enum, AIC32X4_RMICPGAPIN, 4, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in3r_rpga_p_enum, AIC32X4_RMICPGAPIN, 2, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in2l_rpga_p_enum, AIC32X4_RMICPGAPIN, 0, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(cmr_rpga_n_enum, AIC32X4_RMICPGANIN, 6, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in1l_rpga_n_enum, AIC32X4_RMICPGANIN, 4, resistor_text);\nstatic SOC_ENUM_SINGLE_DECL(in3l_rpga_n_enum, AIC32X4_RMICPGANIN, 2, resistor_text);\n\nstatic const struct snd_kcontrol_new in1r_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN1_R R+ Switch\", in1r_rpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in2r_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN2_R R+ Switch\", in2r_rpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in3r_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN3_R R+ Switch\", in3r_rpga_p_enum),\n};\nstatic const struct snd_kcontrol_new in2l_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN2_L R+ Switch\", in2l_rpga_p_enum),\n};\nstatic const struct snd_kcontrol_new cmr_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"CM_R R- Switch\", cmr_rpga_n_enum),\n};\nstatic const struct snd_kcontrol_new in1l_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN1_L R- Switch\", in1l_rpga_n_enum),\n};\nstatic const struct snd_kcontrol_new in3l_to_rmixer_controls[] = {\n\tSOC_DAPM_ENUM(\"IN3_L R- Switch\", in3l_rpga_n_enum),\n};\n\nstatic const struct snd_soc_dapm_widget aic32x4_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", AIC32X4_DACSETUP, 7, 0),\n\tSND_SOC_DAPM_MIXER(\"HPL Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &hpl_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(hpl_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"HPL Power\", AIC32X4_OUTPWRCTL, 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"LOL Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &lol_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(lol_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"LOL Power\", AIC32X4_OUTPWRCTL, 3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", AIC32X4_DACSETUP, 6, 0),\n\tSND_SOC_DAPM_MIXER(\"HPR Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &hpr_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(hpr_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"HPR Power\", AIC32X4_OUTPWRCTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"LOR Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &lor_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(lor_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"LOR Power\", AIC32X4_OUTPWRCTL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", AIC32X4_ADCSETUP, 6, 0),\n\tSND_SOC_DAPM_MUX(\"IN1_R to Right Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin1r_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN2_R to Right Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin2r_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN3_R to Right Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin3r_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN2_L to Right Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin2l_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"CM_R to Right Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tcmr_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN1_L to Right Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin1l_to_rmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN3_L to Right Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin3l_to_rmixer_controls),\n\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", AIC32X4_ADCSETUP, 7, 0),\n\tSND_SOC_DAPM_MUX(\"IN1_L to Left Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin1l_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN2_L to Left Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin2l_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN3_L to Left Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin3l_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN1_R to Left Mixer Positive Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin1r_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"CM_L to Left Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tcml_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN2_R to Left Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin2r_to_lmixer_controls),\n\tSND_SOC_DAPM_MUX(\"IN3_R to Left Mixer Negative Resistor\", SND_SOC_NOPM, 0, 0,\n\t\t\tin3r_to_lmixer_controls),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", AIC32X4_MICBIAS, 6, 0, mic_bias_event,\n\t\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_POST(\"ADC Reset\", aic32x4_reset_adc),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOR\"),\n\tSND_SOC_DAPM_INPUT(\"IN1_L\"),\n\tSND_SOC_DAPM_INPUT(\"IN1_R\"),\n\tSND_SOC_DAPM_INPUT(\"IN2_L\"),\n\tSND_SOC_DAPM_INPUT(\"IN2_R\"),\n\tSND_SOC_DAPM_INPUT(\"IN3_L\"),\n\tSND_SOC_DAPM_INPUT(\"IN3_R\"),\n\tSND_SOC_DAPM_INPUT(\"CM_L\"),\n\tSND_SOC_DAPM_INPUT(\"CM_R\"),\n};\n\nstatic const struct snd_soc_dapm_route aic32x4_dapm_routes[] = {\n\t \n\t{\"HPL Output Mixer\", \"L_DAC Switch\", \"Left DAC\"},\n\t{\"HPL Output Mixer\", \"IN1_L Switch\", \"IN1_L\"},\n\n\t{\"HPL Power\", NULL, \"HPL Output Mixer\"},\n\t{\"HPL\", NULL, \"HPL Power\"},\n\n\t{\"LOL Output Mixer\", \"L_DAC Switch\", \"Left DAC\"},\n\n\t{\"LOL Power\", NULL, \"LOL Output Mixer\"},\n\t{\"LOL\", NULL, \"LOL Power\"},\n\n\t \n\t{\"HPR Output Mixer\", \"R_DAC Switch\", \"Right DAC\"},\n\t{\"HPR Output Mixer\", \"IN1_R Switch\", \"IN1_R\"},\n\n\t{\"HPR Power\", NULL, \"HPR Output Mixer\"},\n\t{\"HPR\", NULL, \"HPR Power\"},\n\n\t{\"LOR Output Mixer\", \"R_DAC Switch\", \"Right DAC\"},\n\n\t{\"LOR Power\", NULL, \"LOR Output Mixer\"},\n\t{\"LOR\", NULL, \"LOR Power\"},\n\n\t \n\t{\"Right ADC\", NULL, \"IN1_R to Right Mixer Positive Resistor\"},\n\t{\"IN1_R to Right Mixer Positive Resistor\", \"10 kOhm\", \"IN1_R\"},\n\t{\"IN1_R to Right Mixer Positive Resistor\", \"20 kOhm\", \"IN1_R\"},\n\t{\"IN1_R to Right Mixer Positive Resistor\", \"40 kOhm\", \"IN1_R\"},\n\n\t{\"Right ADC\", NULL, \"IN2_R to Right Mixer Positive Resistor\"},\n\t{\"IN2_R to Right Mixer Positive Resistor\", \"10 kOhm\", \"IN2_R\"},\n\t{\"IN2_R to Right Mixer Positive Resistor\", \"20 kOhm\", \"IN2_R\"},\n\t{\"IN2_R to Right Mixer Positive Resistor\", \"40 kOhm\", \"IN2_R\"},\n\n\t{\"Right ADC\", NULL, \"IN3_R to Right Mixer Positive Resistor\"},\n\t{\"IN3_R to Right Mixer Positive Resistor\", \"10 kOhm\", \"IN3_R\"},\n\t{\"IN3_R to Right Mixer Positive Resistor\", \"20 kOhm\", \"IN3_R\"},\n\t{\"IN3_R to Right Mixer Positive Resistor\", \"40 kOhm\", \"IN3_R\"},\n\n\t{\"Right ADC\", NULL, \"IN2_L to Right Mixer Positive Resistor\"},\n\t{\"IN2_L to Right Mixer Positive Resistor\", \"10 kOhm\", \"IN2_L\"},\n\t{\"IN2_L to Right Mixer Positive Resistor\", \"20 kOhm\", \"IN2_L\"},\n\t{\"IN2_L to Right Mixer Positive Resistor\", \"40 kOhm\", \"IN2_L\"},\n\n\t{\"Right ADC\", NULL, \"CM_R to Right Mixer Negative Resistor\"},\n\t{\"CM_R to Right Mixer Negative Resistor\", \"10 kOhm\", \"CM_R\"},\n\t{\"CM_R to Right Mixer Negative Resistor\", \"20 kOhm\", \"CM_R\"},\n\t{\"CM_R to Right Mixer Negative Resistor\", \"40 kOhm\", \"CM_R\"},\n\n\t{\"Right ADC\", NULL, \"IN1_L to Right Mixer Negative Resistor\"},\n\t{\"IN1_L to Right Mixer Negative Resistor\", \"10 kOhm\", \"IN1_L\"},\n\t{\"IN1_L to Right Mixer Negative Resistor\", \"20 kOhm\", \"IN1_L\"},\n\t{\"IN1_L to Right Mixer Negative Resistor\", \"40 kOhm\", \"IN1_L\"},\n\n\t{\"Right ADC\", NULL, \"IN3_L to Right Mixer Negative Resistor\"},\n\t{\"IN3_L to Right Mixer Negative Resistor\", \"10 kOhm\", \"IN3_L\"},\n\t{\"IN3_L to Right Mixer Negative Resistor\", \"20 kOhm\", \"IN3_L\"},\n\t{\"IN3_L to Right Mixer Negative Resistor\", \"40 kOhm\", \"IN3_L\"},\n\n\t \n\t{\"Left ADC\", NULL, \"IN1_L to Left Mixer Positive Resistor\"},\n\t{\"IN1_L to Left Mixer Positive Resistor\", \"10 kOhm\", \"IN1_L\"},\n\t{\"IN1_L to Left Mixer Positive Resistor\", \"20 kOhm\", \"IN1_L\"},\n\t{\"IN1_L to Left Mixer Positive Resistor\", \"40 kOhm\", \"IN1_L\"},\n\n\t{\"Left ADC\", NULL, \"IN2_L to Left Mixer Positive Resistor\"},\n\t{\"IN2_L to Left Mixer Positive Resistor\", \"10 kOhm\", \"IN2_L\"},\n\t{\"IN2_L to Left Mixer Positive Resistor\", \"20 kOhm\", \"IN2_L\"},\n\t{\"IN2_L to Left Mixer Positive Resistor\", \"40 kOhm\", \"IN2_L\"},\n\n\t{\"Left ADC\", NULL, \"IN3_L to Left Mixer Positive Resistor\"},\n\t{\"IN3_L to Left Mixer Positive Resistor\", \"10 kOhm\", \"IN3_L\"},\n\t{\"IN3_L to Left Mixer Positive Resistor\", \"20 kOhm\", \"IN3_L\"},\n\t{\"IN3_L to Left Mixer Positive Resistor\", \"40 kOhm\", \"IN3_L\"},\n\n\t{\"Left ADC\", NULL, \"IN1_R to Left Mixer Positive Resistor\"},\n\t{\"IN1_R to Left Mixer Positive Resistor\", \"10 kOhm\", \"IN1_R\"},\n\t{\"IN1_R to Left Mixer Positive Resistor\", \"20 kOhm\", \"IN1_R\"},\n\t{\"IN1_R to Left Mixer Positive Resistor\", \"40 kOhm\", \"IN1_R\"},\n\n\t{\"Left ADC\", NULL, \"CM_L to Left Mixer Negative Resistor\"},\n\t{\"CM_L to Left Mixer Negative Resistor\", \"10 kOhm\", \"CM_L\"},\n\t{\"CM_L to Left Mixer Negative Resistor\", \"20 kOhm\", \"CM_L\"},\n\t{\"CM_L to Left Mixer Negative Resistor\", \"40 kOhm\", \"CM_L\"},\n\n\t{\"Left ADC\", NULL, \"IN2_R to Left Mixer Negative Resistor\"},\n\t{\"IN2_R to Left Mixer Negative Resistor\", \"10 kOhm\", \"IN2_R\"},\n\t{\"IN2_R to Left Mixer Negative Resistor\", \"20 kOhm\", \"IN2_R\"},\n\t{\"IN2_R to Left Mixer Negative Resistor\", \"40 kOhm\", \"IN2_R\"},\n\n\t{\"Left ADC\", NULL, \"IN3_R to Left Mixer Negative Resistor\"},\n\t{\"IN3_R to Left Mixer Negative Resistor\", \"10 kOhm\", \"IN3_R\"},\n\t{\"IN3_R to Left Mixer Negative Resistor\", \"20 kOhm\", \"IN3_R\"},\n\t{\"IN3_R to Left Mixer Negative Resistor\", \"40 kOhm\", \"IN3_R\"},\n};\n\nstatic const struct regmap_range_cfg aic32x4_regmap_pages[] = {\n\t{\n\t\t.selector_reg = 0,\n\t\t.selector_mask\t= 0xff,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t\t.range_min = 0,\n\t\t.range_max = AIC32X4_REFPOWERUP,\n\t},\n};\n\nconst struct regmap_config aic32x4_regmap_config = {\n\t.max_register = AIC32X4_REFPOWERUP,\n\t.ranges = aic32x4_regmap_pages,\n\t.num_ranges = ARRAY_SIZE(aic32x4_regmap_pages),\n};\nEXPORT_SYMBOL(aic32x4_regmap_config);\n\nstatic int aic32x4_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct clk *mclk;\n\tstruct clk *pll;\n\n\tpll = devm_clk_get(component->dev, \"pll\");\n\tif (IS_ERR(pll))\n\t\treturn PTR_ERR(pll);\n\n\tmclk = clk_get_parent(pll);\n\n\treturn clk_set_rate(mclk, freq);\n}\n\nstatic int aic32x4_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\tu8 iface_reg_1 = 0;\n\tu8 iface_reg_2 = 0;\n\tu8 iface_reg_3 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface_reg_1 |= AIC32X4_BCLKMASTER | AIC32X4_WCLKMASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"aic32x4: invalid clock provider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface_reg_1 |= (AIC32X4_DSP_MODE <<\n\t\t\t\tAIC32X4_IFACE1_DATATYPE_SHIFT);\n\t\tiface_reg_3 |= AIC32X4_BCLKINV_MASK;  \n\t\tiface_reg_2 = 0x01;  \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface_reg_1 |= (AIC32X4_DSP_MODE <<\n\t\t\t\tAIC32X4_IFACE1_DATATYPE_SHIFT);\n\t\tiface_reg_3 |= AIC32X4_BCLKINV_MASK;  \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tiface_reg_1 |= (AIC32X4_RIGHT_JUSTIFIED_MODE <<\n\t\t\t\tAIC32X4_IFACE1_DATATYPE_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface_reg_1 |= (AIC32X4_LEFT_JUSTIFIED_MODE <<\n\t\t\t\tAIC32X4_IFACE1_DATATYPE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"aic32x4: invalid DAI interface format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taic32x4->fmt = fmt;\n\n\tsnd_soc_component_update_bits(component, AIC32X4_IFACE1,\n\t\t\t\tAIC32X4_IFACE1_DATATYPE_MASK |\n\t\t\t\tAIC32X4_IFACE1_MASTER_MASK, iface_reg_1);\n\tsnd_soc_component_update_bits(component, AIC32X4_IFACE2,\n\t\t\t\tAIC32X4_DATA_OFFSET_MASK, iface_reg_2);\n\tsnd_soc_component_update_bits(component, AIC32X4_IFACE3,\n\t\t\t\tAIC32X4_BCLKINV_MASK, iface_reg_3);\n\n\treturn 0;\n}\n\nstatic int aic32x4_set_aosr(struct snd_soc_component *component, u8 aosr)\n{\n\treturn snd_soc_component_write(component, AIC32X4_AOSR, aosr);\n}\n\nstatic int aic32x4_set_dosr(struct snd_soc_component *component, u16 dosr)\n{\n\tsnd_soc_component_write(component, AIC32X4_DOSRMSB, dosr >> 8);\n\tsnd_soc_component_write(component, AIC32X4_DOSRLSB,\n\t\t      (dosr & 0xff));\n\n\treturn 0;\n}\n\nstatic int aic32x4_set_processing_blocks(struct snd_soc_component *component,\n\t\t\t\t\t\tu8 r_block, u8 p_block)\n{\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\n\tif (aic32x4->type == AIC32X4_TYPE_TAS2505) {\n\t\tif (r_block || p_block > 3)\n\t\t\treturn -EINVAL;\n\n\t\tsnd_soc_component_write(component, AIC32X4_DACSPB, p_block);\n\t} else {  \n\t\tif (r_block > 18 || p_block > 25)\n\t\t\treturn -EINVAL;\n\n\t\tsnd_soc_component_write(component, AIC32X4_ADCSPB, r_block);\n\t\tsnd_soc_component_write(component, AIC32X4_DACSPB, p_block);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic32x4_setup_clocks(struct snd_soc_component *component,\n\t\t\t\tunsigned int sample_rate, unsigned int channels,\n\t\t\t\tunsigned int bit_depth)\n{\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\tu8 aosr;\n\tu16 dosr;\n\tu8 adc_resource_class, dac_resource_class;\n\tu8 madc, nadc, mdac, ndac, max_nadc, min_mdac, max_ndac;\n\tu8 dosr_increment;\n\tu16 max_dosr, min_dosr;\n\tunsigned long adc_clock_rate, dac_clock_rate;\n\tint ret;\n\n\tstatic struct clk_bulk_data clocks[] = {\n\t\t{ .id = \"pll\" },\n\t\t{ .id = \"nadc\" },\n\t\t{ .id = \"madc\" },\n\t\t{ .id = \"ndac\" },\n\t\t{ .id = \"mdac\" },\n\t\t{ .id = \"bdiv\" },\n\t};\n\tret = devm_clk_bulk_get(component->dev, ARRAY_SIZE(clocks), clocks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sample_rate <= 48000) {\n\t\taosr = 128;\n\t\tadc_resource_class = 6;\n\t\tdac_resource_class = 8;\n\t\tdosr_increment = 8;\n\t\tif (aic32x4->type == AIC32X4_TYPE_TAS2505)\n\t\t\taic32x4_set_processing_blocks(component, 0, 1);\n\t\telse\n\t\t\taic32x4_set_processing_blocks(component, 1, 1);\n\t} else if (sample_rate <= 96000) {\n\t\taosr = 64;\n\t\tadc_resource_class = 6;\n\t\tdac_resource_class = 8;\n\t\tdosr_increment = 4;\n\t\tif (aic32x4->type == AIC32X4_TYPE_TAS2505)\n\t\t\taic32x4_set_processing_blocks(component, 0, 1);\n\t\telse\n\t\t\taic32x4_set_processing_blocks(component, 1, 9);\n\t} else if (sample_rate == 192000) {\n\t\taosr = 32;\n\t\tadc_resource_class = 3;\n\t\tdac_resource_class = 4;\n\t\tdosr_increment = 2;\n\t\tif (aic32x4->type == AIC32X4_TYPE_TAS2505)\n\t\t\taic32x4_set_processing_blocks(component, 0, 1);\n\t\telse\n\t\t\taic32x4_set_processing_blocks(component, 13, 19);\n\t} else {\n\t\tdev_err(component->dev, \"Sampling rate not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((aic32x4->fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)\n\t\tchannels = 2;\n\n\tmadc = DIV_ROUND_UP((32 * adc_resource_class), aosr);\n\tmax_dosr = (AIC32X4_MAX_DOSR_FREQ / sample_rate / dosr_increment) *\n\t\t\tdosr_increment;\n\tmin_dosr = (AIC32X4_MIN_DOSR_FREQ / sample_rate / dosr_increment) *\n\t\t\tdosr_increment;\n\tmax_nadc = AIC32X4_MAX_CODEC_CLKIN_FREQ / (madc * aosr * sample_rate);\n\n\tfor (nadc = max_nadc; nadc > 0; --nadc) {\n\t\tadc_clock_rate = nadc * madc * aosr * sample_rate;\n\t\tfor (dosr = max_dosr; dosr >= min_dosr;\n\t\t\t\tdosr -= dosr_increment) {\n\t\t\tmin_mdac = DIV_ROUND_UP((32 * dac_resource_class), dosr);\n\t\t\tmax_ndac = AIC32X4_MAX_CODEC_CLKIN_FREQ /\n\t\t\t\t\t(min_mdac * dosr * sample_rate);\n\t\t\tfor (mdac = min_mdac; mdac <= 128; ++mdac) {\n\t\t\t\tfor (ndac = max_ndac; ndac > 0; --ndac) {\n\t\t\t\t\tdac_clock_rate = ndac * mdac * dosr *\n\t\t\t\t\t\t\tsample_rate;\n\t\t\t\t\tif (dac_clock_rate == adc_clock_rate) {\n\t\t\t\t\t\tif (clk_round_rate(clocks[0].clk, dac_clock_rate) == 0)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tclk_set_rate(clocks[0].clk,\n\t\t\t\t\t\t\tdac_clock_rate);\n\n\t\t\t\t\t\tclk_set_rate(clocks[1].clk,\n\t\t\t\t\t\t\tsample_rate * aosr *\n\t\t\t\t\t\t\tmadc);\n\t\t\t\t\t\tclk_set_rate(clocks[2].clk,\n\t\t\t\t\t\t\tsample_rate * aosr);\n\t\t\t\t\t\taic32x4_set_aosr(component,\n\t\t\t\t\t\t\taosr);\n\n\t\t\t\t\t\tclk_set_rate(clocks[3].clk,\n\t\t\t\t\t\t\tsample_rate * dosr *\n\t\t\t\t\t\t\tmdac);\n\t\t\t\t\t\tclk_set_rate(clocks[4].clk,\n\t\t\t\t\t\t\tsample_rate * dosr);\n\t\t\t\t\t\taic32x4_set_dosr(component,\n\t\t\t\t\t\t\tdosr);\n\n\t\t\t\t\t\tclk_set_rate(clocks[5].clk,\n\t\t\t\t\t\t\tsample_rate * channels *\n\t\t\t\t\t\t\tbit_depth);\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_err(component->dev,\n\t\t\"Could not set clocks to support sample rate.\\n\");\n\treturn -EINVAL;\n}\n\nstatic int aic32x4_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\tu8 iface1_reg = 0;\n\tu8 dacsetup_reg = 0;\n\n\taic32x4_setup_clocks(component, params_rate(params),\n\t\t\t     params_channels(params),\n\t\t\t     params_physical_width(params));\n\n\tswitch (params_physical_width(params)) {\n\tcase 16:\n\t\tiface1_reg |= (AIC32X4_WORD_LEN_16BITS <<\n\t\t\t\t   AIC32X4_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tcase 20:\n\t\tiface1_reg |= (AIC32X4_WORD_LEN_20BITS <<\n\t\t\t\t   AIC32X4_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tcase 24:\n\t\tiface1_reg |= (AIC32X4_WORD_LEN_24BITS <<\n\t\t\t\t   AIC32X4_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tcase 32:\n\t\tiface1_reg |= (AIC32X4_WORD_LEN_32BITS <<\n\t\t\t\t   AIC32X4_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\t}\n\tsnd_soc_component_update_bits(component, AIC32X4_IFACE1,\n\t\t\t\tAIC32X4_IFACE1_DATALEN_MASK, iface1_reg);\n\n\tif (params_channels(params) == 1) {\n\t\tdacsetup_reg = AIC32X4_RDAC2LCHN | AIC32X4_LDAC2LCHN;\n\t} else {\n\t\tif (aic32x4->swapdacs)\n\t\t\tdacsetup_reg = AIC32X4_RDAC2LCHN | AIC32X4_LDAC2RCHN;\n\t\telse\n\t\t\tdacsetup_reg = AIC32X4_LDAC2LCHN | AIC32X4_RDAC2RCHN;\n\t}\n\tsnd_soc_component_update_bits(component, AIC32X4_DACSETUP,\n\t\t\t\tAIC32X4_DAC_CHAN_MASK, dacsetup_reg);\n\n\treturn 0;\n}\n\nstatic int aic32x4_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tsnd_soc_component_update_bits(component, AIC32X4_DACMUTE,\n\t\t\t\tAIC32X4_MUTEON, mute ? AIC32X4_MUTEON : 0);\n\n\treturn 0;\n}\n\nstatic int aic32x4_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tint ret;\n\n\tstatic struct clk_bulk_data clocks[] = {\n\t\t{ .id = \"madc\" },\n\t\t{ .id = \"mdac\" },\n\t\t{ .id = \"bdiv\" },\n\t};\n\n\tret = devm_clk_bulk_get(component->dev, ARRAY_SIZE(clocks), clocks);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tret = clk_bulk_prepare_enable(ARRAY_SIZE(clocks), clocks);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to enable clocks\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tbreak;\n\n\t\tclk_bulk_disable_unprepare(ARRAY_SIZE(clocks), clocks);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define AIC32X4_RATES\tSNDRV_PCM_RATE_8000_192000\n#define AIC32X4_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t\t\t | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_3LE \\\n\t\t\t | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops aic32x4_ops = {\n\t.hw_params = aic32x4_hw_params,\n\t.mute_stream = aic32x4_mute,\n\t.set_fmt = aic32x4_set_dai_fmt,\n\t.set_sysclk = aic32x4_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver aic32x4_dai = {\n\t.name = \"tlv320aic32x4-hifi\",\n\t.playback = {\n\t\t\t .stream_name = \"Playback\",\n\t\t\t .channels_min = 1,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = AIC32X4_RATES,\n\t\t\t .formats = AIC32X4_FORMATS,},\n\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = AIC32X4_RATES,\n\t\t\t.formats = AIC32X4_FORMATS,},\n\t.ops = &aic32x4_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic void aic32x4_setup_gpios(struct snd_soc_component *component)\n{\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\n\t \n\t \n\tif (aic32x4->setup->gpio_func[0] != AIC32X4_MFPX_DEFAULT_VALUE) {\n\t\tsnd_soc_component_write(component, AIC32X4_DINCTL,\n\t\t\t  aic32x4->setup->gpio_func[0]);\n\t\tsnd_soc_add_component_controls(component, aic32x4_mfp1,\n\t\t\tARRAY_SIZE(aic32x4_mfp1));\n\t}\n\n\t \n\tif (aic32x4->setup->gpio_func[1] != AIC32X4_MFPX_DEFAULT_VALUE) {\n\t\tsnd_soc_component_write(component, AIC32X4_DOUTCTL,\n\t\t\t  aic32x4->setup->gpio_func[1]);\n\t\tsnd_soc_add_component_controls(component, aic32x4_mfp2,\n\t\t\tARRAY_SIZE(aic32x4_mfp2));\n\t}\n\n\t \n\tif (aic32x4->setup->gpio_func[2] != AIC32X4_MFPX_DEFAULT_VALUE) {\n\t\tsnd_soc_component_write(component, AIC32X4_SCLKCTL,\n\t\t\t  aic32x4->setup->gpio_func[2]);\n\t\tsnd_soc_add_component_controls(component, aic32x4_mfp3,\n\t\t\tARRAY_SIZE(aic32x4_mfp3));\n\t}\n\n\t \n\tif (aic32x4->setup->gpio_func[3] != AIC32X4_MFPX_DEFAULT_VALUE) {\n\t\tsnd_soc_component_write(component, AIC32X4_MISOCTL,\n\t\t\t  aic32x4->setup->gpio_func[3]);\n\t\tsnd_soc_add_component_controls(component, aic32x4_mfp4,\n\t\t\tARRAY_SIZE(aic32x4_mfp4));\n\t}\n\n\t \n\tif (aic32x4->setup->gpio_func[4] != AIC32X4_MFPX_DEFAULT_VALUE) {\n\t\tsnd_soc_component_write(component, AIC32X4_GPIOCTL,\n\t\t\t  aic32x4->setup->gpio_func[4]);\n\t\tsnd_soc_add_component_controls(component, aic32x4_mfp5,\n\t\t\tARRAY_SIZE(aic32x4_mfp5));\n\t}\n}\n\nstatic int aic32x4_component_probe(struct snd_soc_component *component)\n{\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\tu32 tmp_reg;\n\tint ret;\n\n\tstatic struct clk_bulk_data clocks[] = {\n\t\t{ .id = \"codec_clkin\" },\n\t\t{ .id = \"pll\" },\n\t\t{ .id = \"bdiv\" },\n\t\t{ .id = \"mdac\" },\n\t};\n\n\tret = devm_clk_bulk_get(component->dev, ARRAY_SIZE(clocks), clocks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (aic32x4->setup)\n\t\taic32x4_setup_gpios(component);\n\n\tclk_set_parent(clocks[0].clk, clocks[1].clk);\n\tclk_set_parent(clocks[2].clk, clocks[3].clk);\n\n\t \n\tif (aic32x4->power_cfg & AIC32X4_PWR_MICBIAS_2075_LDOIN) {\n\t\tsnd_soc_component_write(component, AIC32X4_MICBIAS,\n\t\t\t\tAIC32X4_MICBIAS_LDOIN | AIC32X4_MICBIAS_2075V);\n\t}\n\tif (aic32x4->power_cfg & AIC32X4_PWR_AVDD_DVDD_WEAK_DISABLE)\n\t\tsnd_soc_component_write(component, AIC32X4_PWRCFG, AIC32X4_AVDDWEAKDISABLE);\n\n\ttmp_reg = (aic32x4->power_cfg & AIC32X4_PWR_AIC32X4_LDO_ENABLE) ?\n\t\t\tAIC32X4_LDOCTLEN : 0;\n\tsnd_soc_component_write(component, AIC32X4_LDOCTL, tmp_reg);\n\n\ttmp_reg = snd_soc_component_read(component, AIC32X4_CMMODE);\n\tif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_LDOIN_RANGE_18_36)\n\t\ttmp_reg |= AIC32X4_LDOIN_18_36;\n\tif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_HP_LDOIN_POWERED)\n\t\ttmp_reg |= AIC32X4_LDOIN2HP;\n\tsnd_soc_component_write(component, AIC32X4_CMMODE, tmp_reg);\n\n\t \n\tif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_LMIC_IN2R_10K)\n\t\tsnd_soc_component_write(component, AIC32X4_LMICPGANIN,\n\t\t\t\tAIC32X4_LMICPGANIN_IN2R_10K);\n\telse\n\t\tsnd_soc_component_write(component, AIC32X4_LMICPGANIN,\n\t\t\t\tAIC32X4_LMICPGANIN_CM1L_10K);\n\tif (aic32x4->micpga_routing & AIC32X4_MICPGA_ROUTE_RMIC_IN1L_10K)\n\t\tsnd_soc_component_write(component, AIC32X4_RMICPGANIN,\n\t\t\t\tAIC32X4_RMICPGANIN_IN1L_10K);\n\telse\n\t\tsnd_soc_component_write(component, AIC32X4_RMICPGANIN,\n\t\t\t\tAIC32X4_RMICPGANIN_CM1R_10K);\n\n\t \n\ttmp_reg = snd_soc_component_read(component, AIC32X4_ADCSETUP);\n\tsnd_soc_component_write(component, AIC32X4_ADCSETUP, tmp_reg |\n\t\t\t\tAIC32X4_LADC_EN | AIC32X4_RADC_EN);\n\tsnd_soc_component_write(component, AIC32X4_ADCSETUP, tmp_reg);\n\n\t \n\tsnd_soc_component_write(component, AIC32X4_REFPOWERUP,\n\t\t\t\tAIC32X4_REFPOWERUP_40MS);\n\tmsleep(40);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_aic32x4 = {\n\t.probe\t\t\t= aic32x4_component_probe,\n\t.set_bias_level\t\t= aic32x4_set_bias_level,\n\t.controls\t\t= aic32x4_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(aic32x4_snd_controls),\n\t.dapm_widgets\t\t= aic32x4_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aic32x4_dapm_widgets),\n\t.dapm_routes\t\t= aic32x4_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aic32x4_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_kcontrol_new aic32x4_tas2505_snd_controls[] = {\n\tSOC_SINGLE_S8_TLV(\"PCM Playback Volume\",\n\t\t\t  AIC32X4_LDACVOL, -0x7f, 0x30, tlv_pcm),\n\tSOC_ENUM(\"DAC Playback PowerTune Switch\", l_ptm_enum),\n\n\tSOC_SINGLE_TLV(\"HP Driver Gain Volume\",\n\t\t\tAIC32X4_HPLGAIN, 0, 0x74, 1, tlv_tas_driver_gain),\n\tSOC_SINGLE(\"HP DAC Playback Switch\", AIC32X4_HPLGAIN, 6, 1, 1),\n\n\tSOC_SINGLE_TLV(\"Speaker Driver Playback Volume\",\n\t\t\tTAS2505_SPKVOL1, 0, 0x74, 1, tlv_tas_driver_gain),\n\tSOC_SINGLE_TLV(\"Speaker Amplifier Playback Volume\",\n\t\t\tTAS2505_SPKVOL2, 4, 5, 0, tlv_amp_vol),\n\n\tSOC_SINGLE(\"Auto-mute Switch\", AIC32X4_DACMUTE, 4, 7, 0),\n};\n\nstatic const struct snd_kcontrol_new hp_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC Switch\", AIC32X4_HPLROUTE, 3, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget aic32x4_tas2505_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", AIC32X4_DACSETUP, 7, 0),\n\tSND_SOC_DAPM_MIXER(\"HP Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &hp_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(hp_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"HP Power\", AIC32X4_OUTPWRCTL, 5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Speaker Driver\", TAS2505_SPK, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HP\"),\n\tSND_SOC_DAPM_OUTPUT(\"Speaker\"),\n};\n\nstatic const struct snd_soc_dapm_route aic32x4_tas2505_dapm_routes[] = {\n\t \n\t{\"HP Output Mixer\", \"DAC Switch\", \"DAC\"},\n\n\t{\"HP Power\", NULL, \"HP Output Mixer\"},\n\t{\"HP\", NULL, \"HP Power\"},\n\n\t{\"Speaker Driver\", NULL, \"DAC\"},\n\t{\"Speaker\", NULL, \"Speaker Driver\"},\n};\n\nstatic struct snd_soc_dai_driver aic32x4_tas2505_dai = {\n\t.name = \"tas2505-hifi\",\n\t.playback = {\n\t\t\t .stream_name = \"Playback\",\n\t\t\t .channels_min = 1,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t .formats = AIC32X4_FORMATS,},\n\t.ops = &aic32x4_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int aic32x4_tas2505_component_probe(struct snd_soc_component *component)\n{\n\tstruct aic32x4_priv *aic32x4 = snd_soc_component_get_drvdata(component);\n\tu32 tmp_reg;\n\tint ret;\n\n\tstatic struct clk_bulk_data clocks[] = {\n\t\t{ .id = \"codec_clkin\" },\n\t\t{ .id = \"pll\" },\n\t\t{ .id = \"bdiv\" },\n\t\t{ .id = \"mdac\" },\n\t};\n\n\tret = devm_clk_bulk_get(component->dev, ARRAY_SIZE(clocks), clocks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (aic32x4->setup)\n\t\taic32x4_setup_gpios(component);\n\n\tclk_set_parent(clocks[0].clk, clocks[1].clk);\n\tclk_set_parent(clocks[2].clk, clocks[3].clk);\n\n\t \n\tif (aic32x4->power_cfg & AIC32X4_PWR_AVDD_DVDD_WEAK_DISABLE)\n\t\tsnd_soc_component_write(component, AIC32X4_PWRCFG, AIC32X4_AVDDWEAKDISABLE);\n\n\ttmp_reg = (aic32x4->power_cfg & AIC32X4_PWR_AIC32X4_LDO_ENABLE) ?\n\t\t\tAIC32X4_LDOCTLEN : 0;\n\tsnd_soc_component_write(component, AIC32X4_LDOCTL, tmp_reg);\n\n\ttmp_reg = snd_soc_component_read(component, AIC32X4_CMMODE);\n\tif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_LDOIN_RANGE_18_36)\n\t\ttmp_reg |= AIC32X4_LDOIN_18_36;\n\tif (aic32x4->power_cfg & AIC32X4_PWR_CMMODE_HP_LDOIN_POWERED)\n\t\ttmp_reg |= AIC32X4_LDOIN2HP;\n\tsnd_soc_component_write(component, AIC32X4_CMMODE, tmp_reg);\n\n\t \n\tsnd_soc_component_write(component, TAS2505_REFPOWERUP,\n\t\t\t\tAIC32X4_REFPOWERUP_40MS);\n\tmsleep(40);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_aic32x4_tas2505 = {\n\t.probe\t\t\t= aic32x4_tas2505_component_probe,\n\t.set_bias_level\t\t= aic32x4_set_bias_level,\n\t.controls\t\t= aic32x4_tas2505_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(aic32x4_tas2505_snd_controls),\n\t.dapm_widgets\t\t= aic32x4_tas2505_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(aic32x4_tas2505_dapm_widgets),\n\t.dapm_routes\t\t= aic32x4_tas2505_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(aic32x4_tas2505_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int aic32x4_parse_dt(struct aic32x4_priv *aic32x4,\n\t\tstruct device_node *np)\n{\n\tstruct aic32x4_setup_data *aic32x4_setup;\n\tint ret;\n\n\taic32x4_setup = devm_kzalloc(aic32x4->dev, sizeof(*aic32x4_setup),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!aic32x4_setup)\n\t\treturn -ENOMEM;\n\n\tret = of_property_match_string(np, \"clock-names\", \"mclk\");\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\taic32x4->mclk_name = of_clk_get_parent_name(np, ret);\n\n\taic32x4->swapdacs = false;\n\taic32x4->micpga_routing = 0;\n\taic32x4->rstn_gpio = of_get_named_gpio(np, \"reset-gpios\", 0);\n\n\tif (of_property_read_u32_array(np, \"aic32x4-gpio-func\",\n\t\t\t\taic32x4_setup->gpio_func, 5) >= 0)\n\t\taic32x4->setup = aic32x4_setup;\n\treturn 0;\n}\n\nstatic void aic32x4_disable_regulators(struct aic32x4_priv *aic32x4)\n{\n\tregulator_disable(aic32x4->supply_iov);\n\n\tif (!IS_ERR(aic32x4->supply_ldo))\n\t\tregulator_disable(aic32x4->supply_ldo);\n\n\tif (!IS_ERR(aic32x4->supply_dv))\n\t\tregulator_disable(aic32x4->supply_dv);\n\n\tif (!IS_ERR(aic32x4->supply_av))\n\t\tregulator_disable(aic32x4->supply_av);\n}\n\nstatic int aic32x4_setup_regulators(struct device *dev,\n\t\tstruct aic32x4_priv *aic32x4)\n{\n\tint ret = 0;\n\n\taic32x4->supply_ldo = devm_regulator_get_optional(dev, \"ldoin\");\n\taic32x4->supply_iov = devm_regulator_get(dev, \"iov\");\n\taic32x4->supply_dv = devm_regulator_get_optional(dev, \"dv\");\n\taic32x4->supply_av = devm_regulator_get_optional(dev, \"av\");\n\n\t \n\n\tif (IS_ERR(aic32x4->supply_iov)) {\n\t\tdev_err(dev, \"Missing supply 'iov'\\n\");\n\t\treturn PTR_ERR(aic32x4->supply_iov);\n\t}\n\n\tif (IS_ERR(aic32x4->supply_ldo)) {\n\t\tif (PTR_ERR(aic32x4->supply_ldo) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\tif (IS_ERR(aic32x4->supply_dv)) {\n\t\t\tdev_err(dev, \"Missing supply 'dv' or 'ldoin'\\n\");\n\t\t\treturn PTR_ERR(aic32x4->supply_dv);\n\t\t}\n\t\tif (IS_ERR(aic32x4->supply_av)) {\n\t\t\tdev_err(dev, \"Missing supply 'av' or 'ldoin'\\n\");\n\t\t\treturn PTR_ERR(aic32x4->supply_av);\n\t\t}\n\t} else {\n\t\tif (PTR_ERR(aic32x4->supply_dv) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tif (PTR_ERR(aic32x4->supply_av) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t}\n\n\tret = regulator_enable(aic32x4->supply_iov);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable regulator iov\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR(aic32x4->supply_ldo)) {\n\t\tret = regulator_enable(aic32x4->supply_ldo);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator ldo\\n\");\n\t\t\tgoto error_ldo;\n\t\t}\n\t}\n\n\tif (!IS_ERR(aic32x4->supply_dv)) {\n\t\tret = regulator_enable(aic32x4->supply_dv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator dv\\n\");\n\t\t\tgoto error_dv;\n\t\t}\n\t}\n\n\tif (!IS_ERR(aic32x4->supply_av)) {\n\t\tret = regulator_enable(aic32x4->supply_av);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator av\\n\");\n\t\t\tgoto error_av;\n\t\t}\n\t}\n\n\tif (!IS_ERR(aic32x4->supply_ldo) && IS_ERR(aic32x4->supply_av))\n\t\taic32x4->power_cfg |= AIC32X4_PWR_AIC32X4_LDO_ENABLE;\n\n\treturn 0;\n\nerror_av:\n\tif (!IS_ERR(aic32x4->supply_dv))\n\t\tregulator_disable(aic32x4->supply_dv);\n\nerror_dv:\n\tif (!IS_ERR(aic32x4->supply_ldo))\n\t\tregulator_disable(aic32x4->supply_ldo);\n\nerror_ldo:\n\tregulator_disable(aic32x4->supply_iov);\n\treturn ret;\n}\n\nint aic32x4_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct aic32x4_priv *aic32x4;\n\tstruct aic32x4_pdata *pdata = dev->platform_data;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\taic32x4 = devm_kzalloc(dev, sizeof(struct aic32x4_priv),\n\t\t\t\t   GFP_KERNEL);\n\tif (aic32x4 == NULL)\n\t\treturn -ENOMEM;\n\n\taic32x4->dev = dev;\n\taic32x4->type = (uintptr_t)dev_get_drvdata(dev);\n\n\tdev_set_drvdata(dev, aic32x4);\n\n\tif (pdata) {\n\t\taic32x4->power_cfg = pdata->power_cfg;\n\t\taic32x4->swapdacs = pdata->swapdacs;\n\t\taic32x4->micpga_routing = pdata->micpga_routing;\n\t\taic32x4->rstn_gpio = pdata->rstn_gpio;\n\t\taic32x4->mclk_name = \"mclk\";\n\t} else if (np) {\n\t\tret = aic32x4_parse_dt(aic32x4, np);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to parse DT node\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\taic32x4->power_cfg = 0;\n\t\taic32x4->swapdacs = false;\n\t\taic32x4->micpga_routing = 0;\n\t\taic32x4->rstn_gpio = -1;\n\t\taic32x4->mclk_name = \"mclk\";\n\t}\n\n\tif (gpio_is_valid(aic32x4->rstn_gpio)) {\n\t\tret = devm_gpio_request_one(dev, aic32x4->rstn_gpio,\n\t\t\t\tGPIOF_OUT_INIT_LOW, \"tlv320aic32x4 rstn\");\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tret = aic32x4_setup_regulators(dev, aic32x4);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to setup regulators\\n\");\n\t\treturn ret;\n\t}\n\n\tif (gpio_is_valid(aic32x4->rstn_gpio)) {\n\t\tndelay(10);\n\t\tgpio_set_value_cansleep(aic32x4->rstn_gpio, 1);\n\t\tmdelay(1);\n\t}\n\n\tret = regmap_write(regmap, AIC32X4_RESET, 0x01);\n\tif (ret)\n\t\tgoto err_disable_regulators;\n\n\tret = aic32x4_register_clocks(dev, aic32x4->mclk_name);\n\tif (ret)\n\t\tgoto err_disable_regulators;\n\n\tswitch (aic32x4->type) {\n\tcase AIC32X4_TYPE_TAS2505:\n\t\tret = devm_snd_soc_register_component(dev,\n\t\t\t&soc_component_dev_aic32x4_tas2505, &aic32x4_tas2505_dai, 1);\n\t\tbreak;\n\tdefault:\n\t\tret = devm_snd_soc_register_component(dev,\n\t\t\t&soc_component_dev_aic32x4, &aic32x4_dai, 1);\n\t}\n\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register component\\n\");\n\t\tgoto err_disable_regulators;\n\t}\n\n\treturn 0;\n\nerr_disable_regulators:\n\taic32x4_disable_regulators(aic32x4);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(aic32x4_probe);\n\nvoid aic32x4_remove(struct device *dev)\n{\n\tstruct aic32x4_priv *aic32x4 = dev_get_drvdata(dev);\n\n\taic32x4_disable_regulators(aic32x4);\n}\nEXPORT_SYMBOL(aic32x4_remove);\n\nMODULE_DESCRIPTION(\"ASoC tlv320aic32x4 codec driver\");\nMODULE_AUTHOR(\"Javier Martin <javier.martin@vista-silicon.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}