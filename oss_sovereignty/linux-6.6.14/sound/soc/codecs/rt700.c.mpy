{
  "module_name": "rt700.c",
  "hash_id": "552deb8a56732f13d6362db55c7224fd38b028df39a10b4734ffe2edc3f89ad9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt700.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/hda_verbs.h>\n#include <sound/jack.h>\n\n#include \"rt700.h\"\n\nstatic int rt700_index_write(struct regmap *regmap,\n\t\tunsigned int reg, unsigned int value)\n{\n\tint ret;\n\tunsigned int addr = (RT700_PRIV_INDEX_W_H << 8) | reg;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to set private value: %06x <= %04x ret=%d\\n\",\n\t\t\taddr, value, ret);\n\n\treturn ret;\n}\n\nstatic int rt700_index_read(struct regmap *regmap,\n\t\tunsigned int reg, unsigned int *value)\n{\n\tint ret;\n\tunsigned int addr = (RT700_PRIV_INDEX_W_H << 8) | reg;\n\n\t*value = 0;\n\tret = regmap_read(regmap, addr, value);\n\tif (ret < 0)\n\t\tpr_err(\"Failed to get private value: %06x => %04x ret=%d\\n\",\n\t\t\taddr, *value, ret);\n\n\treturn ret;\n}\n\nstatic unsigned int rt700_button_detect(struct rt700_priv *rt700)\n{\n\tunsigned int btn_type = 0, val80, val81;\n\tint ret;\n\n\tret = rt700_index_read(rt700->regmap, RT700_IRQ_FLAG_TABLE1, &val80);\n\tif (ret < 0)\n\t\tgoto read_error;\n\tret = rt700_index_read(rt700->regmap, RT700_IRQ_FLAG_TABLE2, &val81);\n\tif (ret < 0)\n\t\tgoto read_error;\n\n\tval80 &= 0x0381;\n\tval81 &= 0xff00;\n\n\tswitch (val80) {\n\tcase 0x0200:\n\tcase 0x0100:\n\tcase 0x0080:\n\t\tbtn_type |= SND_JACK_BTN_0;\n\t\tbreak;\n\tcase 0x0001:\n\t\tbtn_type |= SND_JACK_BTN_3;\n\t\tbreak;\n\t}\n\tswitch (val81) {\n\tcase 0x8000:\n\tcase 0x4000:\n\tcase 0x2000:\n\t\tbtn_type |= SND_JACK_BTN_1;\n\t\tbreak;\n\tcase 0x1000:\n\tcase 0x0800:\n\tcase 0x0400:\n\t\tbtn_type |= SND_JACK_BTN_2;\n\t\tbreak;\n\tcase 0x0200:\n\tcase 0x0100:\n\t\tbtn_type |= SND_JACK_BTN_3;\n\t\tbreak;\n\t}\nread_error:\n\treturn btn_type;\n}\n\nstatic int rt700_headset_detect(struct rt700_priv *rt700)\n{\n\tunsigned int buf, loop = 0;\n\tint ret;\n\tunsigned int jack_status = 0, reg;\n\n\tret = rt700_index_read(rt700->regmap,\n\t\t\t\t\tRT700_COMBO_JACK_AUTO_CTL2, &buf);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\twhile (loop < 500 &&\n\t\t(buf & RT700_COMBOJACK_AUTO_DET_STATUS) == 0) {\n\t\tloop++;\n\n\t\tusleep_range(9000, 10000);\n\t\tret = rt700_index_read(rt700->regmap,\n\t\t\t\t\tRT700_COMBO_JACK_AUTO_CTL2, &buf);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\n\t\treg = RT700_VERB_GET_PIN_SENSE | RT700_HP_OUT;\n\t\tret = regmap_read(rt700->regmap, reg, &jack_status);\n\t\tif ((jack_status & (1 << 31)) == 0)\n\t\t\tgoto remove_error;\n\t}\n\n\tif (loop >= 500)\n\t\tgoto to_error;\n\n\tif (buf & RT700_COMBOJACK_AUTO_DET_TRS)\n\t\trt700->jack_type = SND_JACK_HEADPHONE;\n\telse if ((buf & RT700_COMBOJACK_AUTO_DET_CTIA) ||\n\t\t(buf & RT700_COMBOJACK_AUTO_DET_OMTP))\n\t\trt700->jack_type = SND_JACK_HEADSET;\n\n\treturn 0;\n\nto_error:\n\tret = -ETIMEDOUT;\n\tpr_err_ratelimited(\"Time-out error in %s\\n\", __func__);\n\treturn ret;\nio_error:\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n\treturn ret;\nremove_error:\n\tpr_err_ratelimited(\"Jack removal in %s\\n\", __func__);\n\treturn -ENODEV;\n}\n\nstatic void rt700_jack_detect_handler(struct work_struct *work)\n{\n\tstruct rt700_priv *rt700 =\n\t\tcontainer_of(work, struct rt700_priv, jack_detect_work.work);\n\tint btn_type = 0, ret;\n\tunsigned int jack_status = 0, reg;\n\n\tif (!rt700->hs_jack)\n\t\treturn;\n\n\tif (!snd_soc_card_is_instantiated(rt700->component->card))\n\t\treturn;\n\n\treg = RT700_VERB_GET_PIN_SENSE | RT700_HP_OUT;\n\tret = regmap_read(rt700->regmap, reg, &jack_status);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\t \n\tif (jack_status & (1 << 31)) {\n\t\t \n\t\tif (rt700->jack_type == 0) {\n\t\t\tret = rt700_headset_detect(rt700);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tif (rt700->jack_type == SND_JACK_HEADSET)\n\t\t\t\tbtn_type = rt700_button_detect(rt700);\n\t\t} else if (rt700->jack_type == SND_JACK_HEADSET) {\n\t\t\t \n\t\t\tbtn_type = rt700_button_detect(rt700);\n\t\t}\n\t} else {\n\t\t \n\t\trt700->jack_type = 0;\n\t}\n\n\tdev_dbg(&rt700->slave->dev,\n\t\t\"in %s, jack_type=0x%x\\n\", __func__, rt700->jack_type);\n\tdev_dbg(&rt700->slave->dev,\n\t\t\"in %s, btn_type=0x%x\\n\", __func__, btn_type);\n\n\tsnd_soc_jack_report(rt700->hs_jack, rt700->jack_type | btn_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\tif (btn_type) {\n\t\t \n\t\tsnd_soc_jack_report(rt700->hs_jack, rt700->jack_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt700->jack_btn_check_work, msecs_to_jiffies(200));\n\t}\n\n\treturn;\n\nio_error:\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n}\n\nstatic void rt700_btn_check_handler(struct work_struct *work)\n{\n\tstruct rt700_priv *rt700 = container_of(work, struct rt700_priv,\n\t\tjack_btn_check_work.work);\n\tint btn_type = 0, ret;\n\tunsigned int jack_status = 0, reg;\n\n\treg = RT700_VERB_GET_PIN_SENSE | RT700_HP_OUT;\n\tret = regmap_read(rt700->regmap, reg, &jack_status);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\t \n\tif (jack_status & (1 << 31)) {\n\t\tif (rt700->jack_type == SND_JACK_HEADSET) {\n\t\t\t \n\t\t\tbtn_type = rt700_button_detect(rt700);\n\t\t}\n\t} else {\n\t\trt700->jack_type = 0;\n\t}\n\n\t \n\tret = rt700_index_read(rt700->regmap, RT700_COMBO_JACK_AUTO_CTL2, &reg);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\tif ((reg & 0xf0) == 0xf0)\n\t\tbtn_type = 0;\n\n\tdev_dbg(&rt700->slave->dev,\n\t\t\"%s, btn_type=0x%x\\n\",\t__func__, btn_type);\n\tsnd_soc_jack_report(rt700->hs_jack, rt700->jack_type | btn_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\tif (btn_type) {\n\t\t \n\t\tsnd_soc_jack_report(rt700->hs_jack, rt700->jack_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt700->jack_btn_check_work, msecs_to_jiffies(200));\n\t}\n\n\treturn;\n\nio_error:\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n}\n\nstatic void rt700_jack_init(struct rt700_priv *rt700)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(rt700->component);\n\n\t \n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\n\tif (rt700->hs_jack) {\n\t\t \n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_MIC2_UNSOLICITED_ENABLE, 0x82);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_HP_UNSOLICITED_ENABLE, 0x81);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_INLINE_UNSOLICITED_ENABLE, 0x83);\n\t\trt700_index_write(rt700->regmap, 0x10, 0x2420);\n\t\trt700_index_write(rt700->regmap, 0x19, 0x2e11);\n\n\t\tdev_dbg(&rt700->slave->dev, \"in %s enable\\n\", __func__);\n\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt700->jack_detect_work, msecs_to_jiffies(250));\n\t} else {\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_MIC2_UNSOLICITED_ENABLE, 0x00);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_HP_UNSOLICITED_ENABLE, 0x00);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_INLINE_UNSOLICITED_ENABLE, 0x00);\n\n\t\tdev_dbg(&rt700->slave->dev, \"in %s disable\\n\", __func__);\n\t}\n\n\t \n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n}\n\nstatic int rt700_set_jack_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *hs_jack, void *data)\n{\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt700->hs_jack = hs_jack;\n\n\t \n\tif (!rt700->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume_and_get(component->dev);\n\tif (ret < 0) {\n\t\tif (ret != -EACCES) {\n\t\t\tdev_err(component->dev, \"%s: failed to resume %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tdev_dbg(component->dev,\t\"%s: skipping jack init for now\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\trt700_jack_init(rt700);\n\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n\n\treturn 0;\n}\n\nstatic void rt700_get_gain(struct rt700_priv *rt700, unsigned int addr_h,\n\t\t\t\tunsigned int addr_l, unsigned int val_h,\n\t\t\t\tunsigned int *r_val, unsigned int *l_val)\n{\n\t \n\t*r_val = (val_h << 8);\n\tregmap_read(rt700->regmap, addr_l, r_val);\n\n\t \n\tval_h |= 0x20;\n\t*l_val = (val_h << 8);\n\tregmap_read(rt700->regmap, addr_h, l_val);\n}\n\n \nstatic int rt700_set_amp_gain_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tunsigned int addr_h, addr_l, val_h, val_ll, val_lr;\n\tunsigned int read_ll, read_rl;\n\tint i;\n\n\t \n\taddr_h = mc->reg;\n\taddr_l = mc->rreg;\n\tif (mc->shift == RT700_DIR_OUT_SFT)  \n\t\tval_h = 0x80;\n\telse  \n\t\tval_h = 0x0;\n\n\trt700_get_gain(rt700, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\t \n\tif (mc->invert) {\n\t\t \n\t\tval_ll = (mc->max - ucontrol->value.integer.value[0]) << 7;\n\t\t \n\t\tread_ll = read_ll & 0x7f;\n\t\tval_ll |= read_ll;\n\t} else {\n\t\t \n\t\tval_ll = ((ucontrol->value.integer.value[0]) & 0x7f);\n\t\tif (val_ll > mc->max)\n\t\t\tval_ll = mc->max;\n\t\t \n\t\tread_ll = read_ll & 0x80;\n\t\tval_ll |= read_ll;\n\t}\n\n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt700->regmap,\n\t\t\t\tRT700_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\n\t \n\tif (mc->invert) {\n\t\t \n\t\tval_lr = (mc->max - ucontrol->value.integer.value[1]) << 7;\n\t\t \n\t\tread_rl = read_rl & 0x7f;\n\t\tval_lr |= read_rl;\n\t} else {\n\t\t \n\t\tval_lr = ((ucontrol->value.integer.value[1]) & 0x7f);\n\t\tif (val_lr > mc->max)\n\t\t\tval_lr = mc->max;\n\t\t \n\t\tread_rl = read_rl & 0x80;\n\t\tval_lr |= read_rl;\n\t}\n\n\tfor (i = 0; i < 3; i++) {  \n\t\tif (val_ll == val_lr) {\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (3 << 4);\n\t\t\tregmap_write(rt700->regmap,\n\t\t\t\taddr_h, (val_h << 8 | val_ll));\n\t\t\tregmap_write(rt700->regmap,\n\t\t\t\taddr_l, (val_h << 8 | val_ll));\n\t\t} else {\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (1 << 5);\n\t\t\tregmap_write(rt700->regmap,\n\t\t\t\taddr_h, (val_h << 8 | val_ll));\n\n\t\t\t \n\t\t\tval_h = (1 << mc->shift) | (1 << 4);\n\t\t\tregmap_write(rt700->regmap,\n\t\t\t\taddr_l, (val_h << 8 | val_lr));\n\t\t}\n\t\t \n\t\tif (mc->shift == RT700_DIR_OUT_SFT)  \n\t\t\tval_h = 0x80;\n\t\telse  \n\t\t\tval_h = 0x0;\n\n\t\trt700_get_gain(rt700, addr_h, addr_l, val_h,\n\t\t\t\t\t&read_rl, &read_ll);\n\t\tif (read_rl == val_lr && read_ll == val_ll)\n\t\t\tbreak;\n\t}\n\n\tif (dapm->bias_level <= SND_SOC_BIAS_STANDBY)\n\t\tregmap_write(rt700->regmap,\n\t\t\t\tRT700_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\treturn 0;\n}\n\nstatic int rt700_set_amp_gain_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int addr_h, addr_l, val_h;\n\tunsigned int read_ll, read_rl;\n\n\taddr_h = mc->reg;\n\taddr_l = mc->rreg;\n\tif (mc->shift == RT700_DIR_OUT_SFT)  \n\t\tval_h = 0x80;\n\telse  \n\t\tval_h = 0x0;\n\n\trt700_get_gain(rt700, addr_h, addr_l, val_h, &read_rl, &read_ll);\n\n\tif (mc->invert) {\n\t\t \n\t\tread_ll = !((read_ll & 0x80) >> RT700_MUTE_SFT);\n\t\tread_rl = !((read_rl & 0x80) >> RT700_MUTE_SFT);\n\t} else {\n\t\t \n\t\tread_ll = read_ll & 0x7f;\n\t\tread_rl = read_rl & 0x7f;\n\t}\n\tucontrol->value.integer.value[0] = read_ll;\n\tucontrol->value.integer.value[1] = read_rl;\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(out_vol_tlv, -6525, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(in_vol_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic const struct snd_kcontrol_new rt700_snd_controls[] = {\n\tSOC_DOUBLE_R_EXT_TLV(\"DAC Front Playback Volume\",\n\t\tRT700_SET_GAIN_DAC1_H, RT700_SET_GAIN_DAC1_L,\n\t\tRT700_DIR_OUT_SFT, 0x57, 0,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put, out_vol_tlv),\n\tSOC_DOUBLE_R_EXT(\"ADC 08 Capture Switch\",\n\t\tRT700_SET_GAIN_ADC2_H, RT700_SET_GAIN_ADC2_L,\n\t\tRT700_DIR_IN_SFT, 1, 1,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put),\n\tSOC_DOUBLE_R_EXT(\"ADC 09 Capture Switch\",\n\t\tRT700_SET_GAIN_ADC1_H,\tRT700_SET_GAIN_ADC1_L,\n\t\tRT700_DIR_IN_SFT, 1, 1,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put),\n\tSOC_DOUBLE_R_EXT_TLV(\"ADC 08 Capture Volume\",\n\t\tRT700_SET_GAIN_ADC2_H,\tRT700_SET_GAIN_ADC2_L,\n\t\tRT700_DIR_IN_SFT, 0x3f, 0,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put, in_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"ADC 09 Capture Volume\",\n\t\tRT700_SET_GAIN_ADC1_H, RT700_SET_GAIN_ADC1_L,\n\t\tRT700_DIR_IN_SFT, 0x3f, 0,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put, in_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"AMIC Volume\",\n\t\tRT700_SET_GAIN_AMIC_H,\tRT700_SET_GAIN_AMIC_L,\n\t\tRT700_DIR_IN_SFT, 3, 0,\n\t\trt700_set_amp_gain_get, rt700_set_amp_gain_put, mic_vol_tlv),\n};\n\nstatic int rt700_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg, val = 0, nid;\n\tint ret;\n\n\tif (strstr(ucontrol->id.name, \"HPO Mux\"))\n\t\tnid = RT700_HP_OUT;\n\telse if (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tnid = RT700_MIXER_IN1;\n\telse if (strstr(ucontrol->id.name, \"ADC 23 Mux\"))\n\t\tnid = RT700_MIXER_IN2;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\treg = RT700_VERB_SET_CONNECT_SEL | nid;\n\tret = regmap_read(rt700->regmap, reg, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tucontrol->value.enumerated.item[0] = val;\n\n\treturn 0;\n}\n\nstatic int rt700_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, val2 = 0, change, reg, nid;\n\tint ret;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tif (strstr(ucontrol->id.name, \"HPO Mux\"))\n\t\tnid = RT700_HP_OUT;\n\telse if (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tnid = RT700_MIXER_IN1;\n\telse if (strstr(ucontrol->id.name, \"ADC 23 Mux\"))\n\t\tnid = RT700_MIXER_IN2;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\treg = RT700_VERB_SET_CONNECT_SEL | nid;\n\tret = regmap_read(rt700->regmap, reg, &val2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val == val2)\n\t\tchange = 0;\n\telse\n\t\tchange = 1;\n\n\tif (change) {\n\t\treg = RT700_VERB_SET_CONNECT_SEL | nid;\n\t\tregmap_write(rt700->regmap, reg, val);\n\t}\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\t\t\t\t\titem[0], e, NULL);\n\n\treturn change;\n}\n\nstatic const char * const adc_mux_text[] = {\n\t\"MIC2\",\n\t\"LINE1\",\n\t\"LINE2\",\n\t\"DMIC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt700_adc22_enum, SND_SOC_NOPM, 0, adc_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt700_adc23_enum, SND_SOC_NOPM, 0, adc_mux_text);\n\nstatic const struct snd_kcontrol_new rt700_adc22_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 22 Mux\", rt700_adc22_enum,\n\t\t\trt700_mux_get, rt700_mux_put);\n\nstatic const struct snd_kcontrol_new rt700_adc23_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 23 Mux\", rt700_adc23_enum,\n\t\t\trt700_mux_get, rt700_mux_put);\n\nstatic const char * const out_mux_text[] = {\n\t\"Front\",\n\t\"Surround\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt700_hp_enum, SND_SOC_NOPM, 0, out_mux_text);\n\nstatic const struct snd_kcontrol_new rt700_hp_mux =\n\tSOC_DAPM_ENUM_EXT(\"HP Mux\", rt700_hp_enum,\n\t\t\trt700_mux_get, rt700_mux_put);\n\nstatic int rt700_dac_front_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_DAC1, 0x10);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_DAC1, 0x00);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt700_dac_surround_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_DAC2, 0x10);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_DAC2, 0x00);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt700_adc_09_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_ADC1, 0x10);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_ADC1, 0x00);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt700_adc_08_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_ADC2, 0x10);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_STREAMID_ADC2, 0x00);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt700_hpo_mux_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_h = (1 << RT700_DIR_OUT_SFT) | (0x3 << 4);\n\tunsigned int val_l;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tval_l = 0x00;\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_GAIN_HP_H, (val_h << 8 | val_l));\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tval_l = (1 << RT700_MUTE_SFT);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_GAIN_HP_H, (val_h << 8 | val_l));\n\t\tusleep_range(50000, 55000);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt700_spk_pga_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_h = (1 << RT700_DIR_OUT_SFT) | (0x3 << 4);\n\tunsigned int val_l;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tval_l = 0x00;\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_GAIN_SPK_H, (val_h << 8 | val_l));\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tval_l = (1 << RT700_MUTE_SFT);\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_GAIN_SPK_H, (val_h << 8 | val_l));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt700_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"HP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2\"),\n\tSND_SOC_DAPM_DAC_E(\"DAC Front\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt700_dac_front_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DAC Surround\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt700_dac_surround_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_MUX_E(\"HPO Mux\", SND_SOC_NOPM, 0, 0, &rt700_hp_mux,\n\t\trt700_hpo_mux_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"SPK PGA\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt700_spk_pga_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC 09\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt700_adc_09_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC 08\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt700_adc_08_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_MUX(\"ADC 22 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt700_adc22_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 23 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt700_adc23_mux),\n\tSND_SOC_DAPM_AIF_IN(\"DP1RX\", \"DP1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DP3RX\", \"DP3 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP2TX\", \"DP2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP4TX\", \"DP4 Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route rt700_audio_map[] = {\n\t{\"DAC Front\", NULL, \"DP1RX\"},\n\t{\"DAC Surround\", NULL, \"DP3RX\"},\n\t{\"DP2TX\", NULL, \"ADC 09\"},\n\t{\"DP4TX\", NULL, \"ADC 08\"},\n\t{\"ADC 09\", NULL, \"ADC 22 Mux\"},\n\t{\"ADC 08\", NULL, \"ADC 23 Mux\"},\n\t{\"ADC 22 Mux\", \"DMIC\", \"DMIC1\"},\n\t{\"ADC 22 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 22 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 22 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 23 Mux\", \"DMIC\", \"DMIC2\"},\n\t{\"ADC 23 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 23 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 23 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"HPO Mux\", \"Front\", \"DAC Front\"},\n\t{\"HPO Mux\", \"Surround\", \"DAC Surround\"},\n\t{\"HP\", NULL, \"HPO Mux\"},\n\t{\"SPK PGA\", NULL, \"DAC Front\"},\n\t{\"SPK\", NULL, \"SPK PGA\"},\n};\n\nstatic int rt700_probe(struct snd_soc_component *component)\n{\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt700->component = component;\n\n\tif (!rt700->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rt700_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (dapm->bias_level == SND_SOC_BIAS_STANDBY) {\n\t\t\tregmap_write(rt700->regmap,\n\t\t\t\tRT700_SET_AUDIO_POWER_STATE,\n\t\t\t\tAC_PWRST_D0);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_write(rt700->regmap,\n\t\t\tRT700_SET_AUDIO_POWER_STATE,\n\t\t\tAC_PWRST_D3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tdapm->bias_level = level;\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_rt700 = {\n\t.probe = rt700_probe,\n\t.set_bias_level = rt700_set_bias_level,\n\t.controls = rt700_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt700_snd_controls),\n\t.dapm_widgets = rt700_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt700_dapm_widgets),\n\t.dapm_routes = rt700_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rt700_audio_map),\n\t.set_jack = rt700_set_jack_detect,\n\t.endianness = 1,\n};\n\nstatic int rt700_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt700_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt700_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval;\n\tunsigned int val = 0;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt700->slave)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_config.num = 1;\n\telse\n\t\tport_config.num = 2;\n\n\tswitch (dai->id) {\n\tcase RT700_AIF1:\n\t\tbreak;\n\tcase RT700_AIF2:\n\t\tport_config.num += 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI id %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = sdw_stream_add_slave(rt700->slave, &stream_config,\n\t\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\tif (params_channels(params) <= 16) {\n\t\t \n\t\tval |= (params_channels(params) - 1);\n\t} else {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\t \n\tcase 8:\n\t\tbreak;\n\tcase 16:\n\t\tval |= (0x1 << 4);\n\t\tbreak;\n\tcase 20:\n\t\tval |= (0x2 << 4);\n\t\tbreak;\n\tcase 24:\n\t\tval |= (0x3 << 4);\n\t\tbreak;\n\tcase 32:\n\t\tval |= (0x4 << 4);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(rt700->regmap, RT700_DAC_FORMAT_H, val);\n\tregmap_write(rt700->regmap, RT700_ADC_FORMAT_H, val);\n\n\treturn retval;\n}\n\nstatic int rt700_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt700_priv *rt700 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt700->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt700->slave, sdw_stream);\n\treturn 0;\n}\n\n#define RT700_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define RT700_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt700_ops = {\n\t.hw_params\t= rt700_pcm_hw_params,\n\t.hw_free\t= rt700_pcm_hw_free,\n\t.set_stream\t= rt700_set_sdw_stream,\n\t.shutdown\t= rt700_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt700_dai[] = {\n\t{\n\t\t.name = \"rt700-aif1\",\n\t\t.id = RT700_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT700_STEREO_RATES,\n\t\t\t.formats = RT700_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT700_STEREO_RATES,\n\t\t\t.formats = RT700_FORMATS,\n\t\t},\n\t\t.ops = &rt700_ops,\n\t},\n\t{\n\t\t.name = \"rt700-aif2\",\n\t\t.id = RT700_AIF2,\n\t\t.playback = {\n\t\t\t.stream_name = \"DP3 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT700_STEREO_RATES,\n\t\t\t.formats = RT700_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP4 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT700_STEREO_RATES,\n\t\t\t.formats = RT700_FORMATS,\n\t\t},\n\t\t.ops = &rt700_ops,\n\t},\n};\n\n \n#define RT700_CLK_FREQ_9600000HZ 9600000\n#define RT700_CLK_FREQ_12000000HZ 12000000\n#define RT700_CLK_FREQ_6000000HZ 6000000\n#define RT700_CLK_FREQ_4800000HZ 4800000\n#define RT700_CLK_FREQ_2400000HZ 2400000\n#define RT700_CLK_FREQ_12288000HZ 12288000\n\nint rt700_clock_config(struct device *dev)\n{\n\tstruct rt700_priv *rt700 = dev_get_drvdata(dev);\n\tunsigned int clk_freq, value;\n\n\tclk_freq = (rt700->params.curr_dr_freq >> 1);\n\n\tswitch (clk_freq) {\n\tcase RT700_CLK_FREQ_12000000HZ:\n\t\tvalue = 0x0;\n\t\tbreak;\n\tcase RT700_CLK_FREQ_6000000HZ:\n\t\tvalue = 0x1;\n\t\tbreak;\n\tcase RT700_CLK_FREQ_9600000HZ:\n\t\tvalue = 0x2;\n\t\tbreak;\n\tcase RT700_CLK_FREQ_4800000HZ:\n\t\tvalue = 0x3;\n\t\tbreak;\n\tcase RT700_CLK_FREQ_2400000HZ:\n\t\tvalue = 0x4;\n\t\tbreak;\n\tcase RT700_CLK_FREQ_12288000HZ:\n\t\tvalue = 0x5;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(rt700->regmap, 0xe0, value);\n\tregmap_write(rt700->regmap, 0xf0, value);\n\n\tdev_dbg(dev, \"%s complete, clk_freq=%d\\n\", __func__, clk_freq);\n\n\treturn 0;\n}\n\nint rt700_init(struct device *dev, struct regmap *sdw_regmap,\n\t\t\tstruct regmap *regmap, struct sdw_slave *slave)\n\n{\n\tstruct rt700_priv *rt700;\n\tint ret;\n\n\trt700 = devm_kzalloc(dev, sizeof(*rt700), GFP_KERNEL);\n\tif (!rt700)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt700);\n\trt700->slave = slave;\n\trt700->sdw_regmap = sdw_regmap;\n\trt700->regmap = regmap;\n\n\tregcache_cache_only(rt700->regmap, true);\n\n\tmutex_init(&rt700->disable_irq_lock);\n\n\tINIT_DELAYED_WORK(&rt700->jack_detect_work,\n\t\t\t  rt700_jack_detect_handler);\n\tINIT_DELAYED_WORK(&rt700->jack_btn_check_work,\n\t\t\t  rt700_btn_check_handler);\n\n\t \n\trt700->hw_init = false;\n\trt700->first_hw_init = false;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t\t&soc_codec_dev_rt700,\n\t\t\t\trt700_dai,\n\t\t\t\tARRAY_SIZE(rt700_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\tdev_dbg(&slave->dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nint rt700_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt700_priv *rt700 = dev_get_drvdata(dev);\n\n\trt700->disable_irq = false;\n\n\tif (rt700->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt700->regmap, false);\n\tif (rt700->first_hw_init)\n\t\tregcache_cache_bypass(rt700->regmap, true);\n\n\t \n\tif (!rt700->first_hw_init)\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\t \n\tregmap_write(rt700->regmap, 0xff01, 0x0000);\n\tregmap_write(rt700->regmap, 0x7520, 0x001a);\n\tregmap_write(rt700->regmap, 0x7420, 0xc003);\n\n\t \n\tregmap_write(rt700->regmap, RT700_SET_AUDIO_POWER_STATE, AC_PWRST_D0);\n\t \n\tregmap_write(rt700->regmap, RT700_SET_PIN_HP, 0x40);\n\tregmap_write(rt700->regmap, RT700_SET_PIN_SPK, 0x40);\n\tregmap_write(rt700->regmap, RT700_SET_EAPD_SPK, RT700_EAPD_HIGH);\n\tregmap_write(rt700->regmap, RT700_SET_PIN_DMIC1, 0x20);\n\tregmap_write(rt700->regmap, RT700_SET_PIN_DMIC2, 0x20);\n\tregmap_write(rt700->regmap, RT700_SET_PIN_MIC2, 0x20);\n\n\t \n\tregmap_write(rt700->regmap, 0x4f12, 0x91);\n\tregmap_write(rt700->regmap, 0x4e12, 0xd6);\n\tregmap_write(rt700->regmap, 0x4d12, 0x11);\n\tregmap_write(rt700->regmap, 0x4c12, 0x20);\n\tregmap_write(rt700->regmap, 0x4f13, 0x91);\n\tregmap_write(rt700->regmap, 0x4e13, 0xd6);\n\tregmap_write(rt700->regmap, 0x4d13, 0x11);\n\tregmap_write(rt700->regmap, 0x4c13, 0x21);\n\n\tregmap_write(rt700->regmap, 0x4f19, 0x02);\n\tregmap_write(rt700->regmap, 0x4e19, 0xa1);\n\tregmap_write(rt700->regmap, 0x4d19, 0x90);\n\tregmap_write(rt700->regmap, 0x4c19, 0x80);\n\n\t \n\tregmap_write(rt700->regmap,  0x371b, 0x40);\n\tregmap_write(rt700->regmap,  0x731b, 0xb0);\n\tregmap_write(rt700->regmap,  0x839b, 0x00);\n\n\t \n\trt700_index_write(rt700->regmap, 0x4a, 0x201b);\n\trt700_index_write(rt700->regmap, 0x45, 0x5089);\n\trt700_index_write(rt700->regmap, 0x6b, 0x5064);\n\trt700_index_write(rt700->regmap, 0x48, 0xd249);\n\n\t \n\tregmap_write(rt700->regmap, RT700_SET_AUDIO_POWER_STATE, AC_PWRST_D3);\n\n\t \n\tif (rt700->hs_jack)\n\t\trt700_jack_init(rt700);\n\n\tif (rt700->first_hw_init) {\n\t\tregcache_cache_bypass(rt700->regmap, false);\n\t\tregcache_mark_dirty(rt700->regmap);\n\t} else\n\t\trt700->first_hw_init = true;\n\n\t \n\trt700->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete\\n\", __func__);\n\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"ASoC RT700 driver SDW\");\nMODULE_AUTHOR(\"Shuming Fan <shumingf@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}