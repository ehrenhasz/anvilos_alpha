{
  "module_name": "sdw-mockup.c",
  "hash_id": "136a8f9c794ee937884986e0623e2e12b019f8bfb255088683c168796e32e826",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sdw-mockup.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n\nstruct  sdw_mockup_priv {\n\tstruct sdw_slave *slave;\n};\n\nstatic int sdw_mockup_component_probe(struct snd_soc_component *component)\n{\n\treturn 0;\n}\n\nstatic void sdw_mockup_component_remove(struct snd_soc_component *component)\n{\n}\n\nstatic const struct snd_soc_component_driver snd_soc_sdw_mockup_component = {\n\t.probe = sdw_mockup_component_probe,\n\t.remove = sdw_mockup_component_remove,\n\t.endianness = 1,\n};\n\nstatic int sdw_mockup_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\t     int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void sdw_mockup_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int sdw_mockup_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sdw_mockup_priv *sdw_mockup = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\tint ret;\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!sdw_mockup->slave)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_config.num = 1;\n\telse\n\t\tport_config.num = 8;\n\n\tret = sdw_stream_add_slave(sdw_mockup->slave, &stream_config,\n\t\t\t\t   &port_config, 1, sdw_stream);\n\tif (ret)\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\n\treturn ret;\n}\n\nstatic int sdw_mockup_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sdw_mockup_priv *sdw_mockup = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_mockup->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(sdw_mockup->slave, sdw_stream);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sdw_mockup_ops = {\n\t.hw_params\t= sdw_mockup_pcm_hw_params,\n\t.hw_free\t= sdw_mockup_pcm_hw_free,\n\t.set_stream\t= sdw_mockup_set_sdw_stream,\n\t.shutdown\t= sdw_mockup_shutdown,\n};\n\nstatic struct snd_soc_dai_driver sdw_mockup_dai[] = {\n\t{\n\t\t.name = \"sdw-mockup-aif1\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP8 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t},\n\t\t.ops = &sdw_mockup_ops,\n\t},\n};\n\nstatic int sdw_mockup_update_status(struct sdw_slave *slave,\n\t\t\t\t    enum sdw_slave_status status)\n{\n\treturn 0;\n}\n\nstatic int sdw_mockup_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval;\n\tint i, j;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->paging_support = false;\n\n\t \n\tprop->source_ports = BIT(8);\n\tprop->sink_ports = BIT(1);\n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t  sizeof(*prop->src_dpn_prop),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t   sizeof(*prop->sink_dpn_prop),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[j].num = bit;\n\t\tdpn[j].type = SDW_DPN_FULL;\n\t\tdpn[j].simple_ch_prep_sm = true;\n\t\tj++;\n\t}\n\n\tprop->simple_clk_stop_capable = true;\n\n\t \n\tprop->wake_capable = 0;\n\n\treturn 0;\n}\n\nstatic int sdw_mockup_bus_config(struct sdw_slave *slave,\n\t\t\t\t struct sdw_bus_params *params)\n{\n\treturn 0;\n}\n\nstatic int sdw_mockup_interrupt_callback(struct sdw_slave *slave,\n\t\t\t\t\t struct sdw_slave_intr_status *status)\n{\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops sdw_mockup_slave_ops = {\n\t.read_prop = sdw_mockup_read_prop,\n\t.interrupt_callback = sdw_mockup_interrupt_callback,\n\t.update_status = sdw_mockup_update_status,\n\t.bus_config = sdw_mockup_bus_config,\n};\n\nstatic int sdw_mockup_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct device *dev = &slave->dev;\n\tstruct sdw_mockup_priv *sdw_mockup;\n\tint ret;\n\n\tsdw_mockup = devm_kzalloc(dev, sizeof(*sdw_mockup), GFP_KERNEL);\n\tif (!sdw_mockup)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, sdw_mockup);\n\tsdw_mockup->slave = slave;\n\n\tslave->is_mockup_device = true;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t\t\t       &snd_soc_sdw_mockup_component,\n\t\t\t\t\t       sdw_mockup_dai,\n\t\t\t\t\t       ARRAY_SIZE(sdw_mockup_dai));\n\n\treturn ret;\n}\n\nstatic int sdw_mockup_sdw_remove(struct sdw_slave *slave)\n{\n\treturn 0;\n}\n\n \nstatic const struct sdw_device_id sdw_mockup_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x0105, 0xAAAA, 0x0, 0, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x0105, 0xAA55, 0x0, 0, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x0105, 0x55AA, 0x0, 0, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x0105, 0x5555, 0x0, 0, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, sdw_mockup_id);\n\nstatic struct sdw_driver sdw_mockup_sdw_driver = {\n\t.driver = {\n\t\t.name = \"sdw-mockup\",\n\t\t.owner = THIS_MODULE,\n\t},\n\t.probe = sdw_mockup_sdw_probe,\n\t.remove = sdw_mockup_sdw_remove,\n\t.ops = &sdw_mockup_slave_ops,\n\t.id_table = sdw_mockup_id,\n};\nmodule_sdw_driver(sdw_mockup_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC SDW mockup codec driver\");\nMODULE_AUTHOR(\"Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}