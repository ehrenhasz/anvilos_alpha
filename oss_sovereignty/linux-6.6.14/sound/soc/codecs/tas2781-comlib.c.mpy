{
  "module_name": "tas2781-comlib.c",
  "hash_id": "79ebcac28b4d559e90e34e80fd08443a31850f2d2bcc4ce48b9530528f6c7677",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2781-comlib.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/crc8.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tas2781.h>\n\n#define TASDEVICE_CRC8_POLYNOMIAL\t0x4d\n\nstatic const struct regmap_range_cfg tasdevice_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 256 * 128,\n\t\t.selector_reg = TASDEVICE_PAGE_SELECT,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t},\n};\n\nstatic const struct regmap_config tasdevice_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_NONE,\n\t.ranges = tasdevice_ranges,\n\t.num_ranges = ARRAY_SIZE(tasdevice_ranges),\n\t.max_register = 256 * 128,\n};\n\nstatic int tasdevice_change_chn_book(struct tasdevice_priv *tas_priv,\n\tunsigned short chn, int book)\n{\n\tstruct i2c_client *client = (struct i2c_client *)tas_priv->client;\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct tasdevice *tasdev = &tas_priv->tasdevice[chn];\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tif (client->addr != tasdev->dev_addr) {\n\t\t\tclient->addr = tasdev->dev_addr;\n\t\t\t \n\t\t\tret = regmap_write(map, TASDEVICE_PAGE_SELECT, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (tasdev->cur_book != book) {\n\t\t\tret = regmap_write(map, TASDEVICE_BOOKCTL_REG, book);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\ttasdev->cur_book = book;\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\t}\n\nout:\n\treturn ret;\n}\n\nint tasdevice_dev_read(struct tasdevice_priv *tas_priv,\n\tunsigned short chn, unsigned int reg, unsigned int *val)\n{\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tret = tasdevice_change_chn_book(tas_priv, chn,\n\t\t\tTASDEVICE_BOOK_ID(reg));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = regmap_read(map, TASDEVICE_PGRG(reg), val);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\", __func__, ret);\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dev_read);\n\nint tasdevice_dev_write(struct tasdevice_priv *tas_priv,\n\tunsigned short chn, unsigned int reg, unsigned int value)\n{\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tret = tasdevice_change_chn_book(tas_priv, chn,\n\t\t\tTASDEVICE_BOOK_ID(reg));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = regmap_write(map, TASDEVICE_PGRG(reg),\n\t\t\tvalue);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\", __func__, ret);\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dev_write);\n\nint tasdevice_dev_bulk_write(\n\tstruct tasdevice_priv *tas_priv, unsigned short chn,\n\tunsigned int reg, unsigned char *data,\n\tunsigned int len)\n{\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tret = tasdevice_change_chn_book(tas_priv, chn,\n\t\t\tTASDEVICE_BOOK_ID(reg));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = regmap_bulk_write(map, TASDEVICE_PGRG(reg),\n\t\t\tdata, len);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\", __func__, ret);\n\t} else {\n\t\tret = -EINVAL;\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dev_bulk_write);\n\nint tasdevice_dev_bulk_read(struct tasdevice_priv *tas_priv,\n\tunsigned short chn, unsigned int reg, unsigned char *data,\n\tunsigned int len)\n{\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tret = tasdevice_change_chn_book(tas_priv, chn,\n\t\t\tTASDEVICE_BOOK_ID(reg));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = regmap_bulk_read(map, TASDEVICE_PGRG(reg), data, len);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\", __func__, ret);\n\t} else\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dev_bulk_read);\n\nint tasdevice_dev_update_bits(\n\tstruct tasdevice_priv *tas_priv, unsigned short chn,\n\tunsigned int reg, unsigned int mask, unsigned int value)\n{\n\tint ret = 0;\n\n\tif (chn < tas_priv->ndev) {\n\t\tstruct regmap *map = tas_priv->regmap;\n\n\t\tret = tasdevice_change_chn_book(tas_priv, chn,\n\t\t\tTASDEVICE_BOOK_ID(reg));\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = regmap_update_bits(map, TASDEVICE_PGRG(reg),\n\t\t\tmask, value);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"%s, E=%d\\n\", __func__, ret);\n\t} else {\n\t\tdev_err(tas_priv->dev, \"%s, no such channel(%d)\\n\", __func__,\n\t\t\tchn);\n\t\tret = -EINVAL;\n\t}\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dev_update_bits);\n\nstruct tasdevice_priv *tasdevice_kzalloc(struct i2c_client *i2c)\n{\n\tstruct tasdevice_priv *tas_priv;\n\n\ttas_priv = devm_kzalloc(&i2c->dev, sizeof(*tas_priv), GFP_KERNEL);\n\tif (!tas_priv)\n\t\treturn NULL;\n\ttas_priv->dev = &i2c->dev;\n\ttas_priv->client = (void *)i2c;\n\n\treturn tas_priv;\n}\nEXPORT_SYMBOL_GPL(tasdevice_kzalloc);\n\nvoid tas2781_reset(struct tasdevice_priv *tas_dev)\n{\n\tint ret, i;\n\n\tif (tas_dev->reset) {\n\t\tgpiod_set_value_cansleep(tas_dev->reset, 0);\n\t\tusleep_range(500, 1000);\n\t\tgpiod_set_value_cansleep(tas_dev->reset, 1);\n\t} else {\n\t\tfor (i = 0; i < tas_dev->ndev; i++) {\n\t\t\tret = tasdevice_dev_write(tas_dev, i,\n\t\t\t\tTAS2781_REG_SWRESET,\n\t\t\t\tTAS2781_REG_SWRESET_RESET);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(tas_dev->dev,\n\t\t\t\t\t\"dev %d swreset fail, %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t}\n\t}\n\tusleep_range(1000, 1050);\n}\nEXPORT_SYMBOL_GPL(tas2781_reset);\n\nint tascodec_init(struct tasdevice_priv *tas_priv, void *codec,\n\tvoid (*cont)(const struct firmware *fw, void *context))\n{\n\tint ret = 0;\n\n\t \n\tmutex_lock(&tas_priv->codec_lock);\n\n\tscnprintf(tas_priv->rca_binaryname, 64, \"%sRCA%d.bin\",\n\t\ttas_priv->dev_name, tas_priv->ndev);\n\tcrc8_populate_msb(tas_priv->crc8_lkp_tbl, TASDEVICE_CRC8_POLYNOMIAL);\n\ttas_priv->codec = codec;\n\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\ttas_priv->rca_binaryname, tas_priv->dev, GFP_KERNEL, tas_priv,\n\t\tcont);\n\tif (ret)\n\t\tdev_err(tas_priv->dev, \"request_firmware_nowait err:0x%08x\\n\",\n\t\t\tret);\n\n\t \n\tmutex_unlock(&tas_priv->codec_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tascodec_init);\n\nint tasdevice_init(struct tasdevice_priv *tas_priv)\n{\n\tint ret = 0;\n\tint i;\n\n\ttas_priv->regmap = devm_regmap_init_i2c(tas_priv->client,\n\t\t&tasdevice_regmap);\n\tif (IS_ERR(tas_priv->regmap)) {\n\t\tret = PTR_ERR(tas_priv->regmap);\n\t\tdev_err(tas_priv->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\ttas_priv->cur_prog = -1;\n\ttas_priv->cur_conf = -1;\n\n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\ttas_priv->tasdevice[i].cur_book = -1;\n\t\ttas_priv->tasdevice[i].cur_prog = -1;\n\t\ttas_priv->tasdevice[i].cur_conf = -1;\n\t}\n\n\tmutex_init(&tas_priv->codec_lock);\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tasdevice_init);\n\nstatic void tasdev_dsp_prog_blk_remove(struct tasdevice_prog *prog)\n{\n\tstruct tasdevice_data *tas_dt;\n\tstruct tasdev_blk *blk;\n\tunsigned int i;\n\n\tif (!prog)\n\t\treturn;\n\n\ttas_dt = &(prog->dev_data);\n\n\tif (!tas_dt->dev_blks)\n\t\treturn;\n\n\tfor (i = 0; i < tas_dt->nr_blk; i++) {\n\t\tblk = &(tas_dt->dev_blks[i]);\n\t\tkfree(blk->data);\n\t}\n\tkfree(tas_dt->dev_blks);\n}\n\nstatic void tasdev_dsp_prog_remove(struct tasdevice_prog *prog,\n\tunsigned short nr)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttasdev_dsp_prog_blk_remove(&prog[i]);\n\tkfree(prog);\n}\n\nstatic void tasdev_dsp_cfg_blk_remove(struct tasdevice_config *cfg)\n{\n\tstruct tasdevice_data *tas_dt;\n\tstruct tasdev_blk *blk;\n\tunsigned int i;\n\n\tif (cfg) {\n\t\ttas_dt = &(cfg->dev_data);\n\n\t\tif (!tas_dt->dev_blks)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < tas_dt->nr_blk; i++) {\n\t\t\tblk = &(tas_dt->dev_blks[i]);\n\t\t\tkfree(blk->data);\n\t\t}\n\t\tkfree(tas_dt->dev_blks);\n\t}\n}\n\nstatic void tasdev_dsp_cfg_remove(struct tasdevice_config *config,\n\tunsigned short nr)\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttasdev_dsp_cfg_blk_remove(&config[i]);\n\tkfree(config);\n}\n\nvoid tasdevice_dsp_remove(void *context)\n{\n\tstruct tasdevice_priv *tas_dev = (struct tasdevice_priv *) context;\n\tstruct tasdevice_fw *tas_fmw = tas_dev->fmw;\n\n\tif (!tas_dev->fmw)\n\t\treturn;\n\n\tif (tas_fmw->programs)\n\t\ttasdev_dsp_prog_remove(tas_fmw->programs,\n\t\t\ttas_fmw->nr_programs);\n\tif (tas_fmw->configs)\n\t\ttasdev_dsp_cfg_remove(tas_fmw->configs,\n\t\t\ttas_fmw->nr_configurations);\n\tkfree(tas_fmw);\n\ttas_dev->fmw = NULL;\n}\nEXPORT_SYMBOL_GPL(tasdevice_dsp_remove);\n\nvoid tasdevice_remove(struct tasdevice_priv *tas_priv)\n{\n\tif (gpio_is_valid(tas_priv->irq_info.irq_gpio))\n\t\tgpio_free(tas_priv->irq_info.irq_gpio);\n\tkfree(tas_priv->acpi_subsystem_id);\n\tmutex_destroy(&tas_priv->codec_lock);\n}\nEXPORT_SYMBOL_GPL(tasdevice_remove);\n\nstatic int tasdevice_clamp(int val, int max, unsigned int invert)\n{\n\tif (val > max)\n\t\tval = max;\n\tif (invert)\n\t\tval = max - val;\n\tif (val < 0)\n\t\tval = 0;\n\treturn val;\n}\n\nint tasdevice_amp_putvol(struct tasdevice_priv *tas_priv,\n\tstruct snd_ctl_elem_value *ucontrol, struct soc_mixer_control *mc)\n{\n\tunsigned int invert = mc->invert;\n\tunsigned char mask;\n\tint max = mc->max;\n\tint err_cnt = 0;\n\tint val, i, ret;\n\n\tmask = (1 << fls(max)) - 1;\n\tmask <<= mc->shift;\n\tval = tasdevice_clamp(ucontrol->value.integer.value[0], max, invert);\n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\tret = tasdevice_dev_update_bits(tas_priv, i,\n\t\t\tmc->reg, mask, (unsigned int)(val << mc->shift));\n\t\tif (!ret)\n\t\t\tcontinue;\n\t\terr_cnt++;\n\t\tdev_err(tas_priv->dev, \"set AMP vol error in dev %d\\n\", i);\n\t}\n\n\t \n\treturn (err_cnt == tas_priv->ndev) ? 0 : 1;\n}\nEXPORT_SYMBOL_GPL(tasdevice_amp_putvol);\n\nint tasdevice_amp_getvol(struct tasdevice_priv *tas_priv,\n\tstruct snd_ctl_elem_value *ucontrol, struct soc_mixer_control *mc)\n{\n\tunsigned int invert = mc->invert;\n\tunsigned char mask = 0;\n\tint max = mc->max;\n\tint ret = 0;\n\tint val;\n\n\t \n\tret = tasdevice_dev_read(tas_priv, 0, mc->reg, &val);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"%s, get AMP vol error\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tmask = (1 << fls(max)) - 1;\n\tmask <<= mc->shift;\n\tval = (val & mask) >> mc->shift;\n\tval = tasdevice_clamp(val, max, invert);\n\tucontrol->value.integer.value[0] = val;\n\nout:\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(tasdevice_amp_getvol);\n\nint tasdevice_digital_putvol(struct tasdevice_priv *tas_priv,\n\tstruct snd_ctl_elem_value *ucontrol, struct soc_mixer_control *mc)\n{\n\tunsigned int invert = mc->invert;\n\tint max = mc->max;\n\tint err_cnt = 0;\n\tint ret;\n\tint val, i;\n\n\tval = tasdevice_clamp(ucontrol->value.integer.value[0], max, invert);\n\n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\tret = tasdevice_dev_write(tas_priv, i, mc->reg,\n\t\t\t(unsigned int)val);\n\t\tif (!ret)\n\t\t\tcontinue;\n\t\terr_cnt++;\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"set digital vol err in dev %d\\n\", i);\n\t}\n\n\t \n\treturn (err_cnt == tas_priv->ndev) ? 0 : 1;\n\n}\nEXPORT_SYMBOL_GPL(tasdevice_digital_putvol);\n\nint tasdevice_digital_getvol(struct tasdevice_priv *tas_priv,\n\tstruct snd_ctl_elem_value *ucontrol, struct soc_mixer_control *mc)\n{\n\tunsigned int invert = mc->invert;\n\tint max = mc->max;\n\tint ret, val;\n\n\t \n\tret = tasdevice_dev_read(tas_priv, 0, mc->reg, &val);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"%s, get digital vol error\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\tval = tasdevice_clamp(val, max, invert);\n\tucontrol->value.integer.value[0] = val;\n\nout:\n\treturn ret;\n\n}\nEXPORT_SYMBOL_GPL(tasdevice_digital_getvol);\n\nMODULE_DESCRIPTION(\"TAS2781 common library\");\nMODULE_AUTHOR(\"Shenghao Ding, TI, <shenghao-ding@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}