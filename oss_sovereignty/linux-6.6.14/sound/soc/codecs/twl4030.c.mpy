{
  "module_name": "twl4030.c",
  "hash_id": "3cfd56620159af90e99645a6a2b68502dfcda4376e4904e5eb435711f3fae8bd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/twl4030.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/mfd/twl.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n \n#include <linux/mfd/twl4030-audio.h>\n\n \n#define TWL4030_PMBR1_REG\t\t0x0D\n \n#define TWL4030_GPIO6_PWM0_MUTE(value)\t((value & 0x03) << 2)\n\n#define TWL4030_CACHEREGNUM\t(TWL4030_REG_MISC_SET_2 + 1)\n\nstruct twl4030_board_params {\n\tunsigned int digimic_delay;  \n\tunsigned int ramp_delay_value;\n\tunsigned int offset_cncl_path;\n\tunsigned int hs_extmute:1;\n\tint hs_extmute_gpio;\n};\n\n \nstruct twl4030_priv {\n\tunsigned int codec_powered;\n\n\t \n\tunsigned int apll_enabled;\n\n\tstruct snd_pcm_substream *master_substream;\n\tstruct snd_pcm_substream *slave_substream;\n\n\tunsigned int configured;\n\tunsigned int rate;\n\tunsigned int sample_bits;\n\tunsigned int channels;\n\n\tunsigned int sysclk;\n\n\t \n\tu8 hsl_enabled, hsr_enabled;\n\tu8 earpiece_enabled;\n\tu8 predrivel_enabled, predriver_enabled;\n\tu8 carkitl_enabled, carkitr_enabled;\n\tu8 ctl_cache[TWL4030_REG_PRECKR_CTL - TWL4030_REG_EAR_CTL + 1];\n\n\tstruct twl4030_board_params *board_params;\n};\n\nstatic void tw4030_init_ctl_cache(struct twl4030_priv *twl4030)\n{\n\tint i;\n\tu8 byte;\n\n\tfor (i = TWL4030_REG_EAR_CTL; i <= TWL4030_REG_PRECKR_CTL; i++) {\n\t\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &byte, i);\n\t\ttwl4030->ctl_cache[i - TWL4030_REG_EAR_CTL] = byte;\n\t}\n}\n\nstatic unsigned int twl4030_read(struct snd_soc_component *component, unsigned int reg)\n{\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 value = 0;\n\n\tif (reg >= TWL4030_CACHEREGNUM)\n\t\treturn -EIO;\n\n\tswitch (reg) {\n\tcase TWL4030_REG_EAR_CTL:\n\tcase TWL4030_REG_PREDL_CTL:\n\tcase TWL4030_REG_PREDR_CTL:\n\tcase TWL4030_REG_PRECKL_CTL:\n\tcase TWL4030_REG_PRECKR_CTL:\n\tcase TWL4030_REG_HS_GAIN_SET:\n\t\tvalue = twl4030->ctl_cache[reg - TWL4030_REG_EAR_CTL];\n\t\tbreak;\n\tdefault:\n\t\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &value, reg);\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic bool twl4030_can_write_to_chip(struct twl4030_priv *twl4030,\n\t\t\t\t      unsigned int reg)\n{\n\tbool write_to_reg = false;\n\n\t \n\tswitch (reg) {\n\tcase TWL4030_REG_EAR_CTL:\n\t\tif (twl4030->earpiece_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tcase TWL4030_REG_PREDL_CTL:\n\t\tif (twl4030->predrivel_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tcase TWL4030_REG_PREDR_CTL:\n\t\tif (twl4030->predriver_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tcase TWL4030_REG_PRECKL_CTL:\n\t\tif (twl4030->carkitl_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tcase TWL4030_REG_PRECKR_CTL:\n\t\tif (twl4030->carkitr_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tcase TWL4030_REG_HS_GAIN_SET:\n\t\tif (twl4030->hsl_enabled || twl4030->hsr_enabled)\n\t\t\twrite_to_reg = true;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\twrite_to_reg = true;\n\t\tbreak;\n\t}\n\n\treturn write_to_reg;\n}\n\nstatic int twl4030_write(struct snd_soc_component *component, unsigned int reg,\n\t\t\t unsigned int value)\n{\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\t \n\tswitch (reg) {\n\tcase TWL4030_REG_EAR_CTL:\n\tcase TWL4030_REG_PREDL_CTL:\n\tcase TWL4030_REG_PREDR_CTL:\n\tcase TWL4030_REG_PRECKL_CTL:\n\tcase TWL4030_REG_PRECKR_CTL:\n\tcase TWL4030_REG_HS_GAIN_SET:\n\t\ttwl4030->ctl_cache[reg - TWL4030_REG_EAR_CTL] = value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (twl4030_can_write_to_chip(twl4030, reg))\n\t\treturn twl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, value, reg);\n\n\treturn 0;\n}\n\nstatic inline void twl4030_wait_ms(int time)\n{\n\tif (time < 60) {\n\t\ttime *= 1000;\n\t\tusleep_range(time, time + 500);\n\t} else {\n\t\tmsleep(time);\n\t}\n}\n\nstatic void twl4030_codec_enable(struct snd_soc_component *component, int enable)\n{\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tint mode;\n\n\tif (enable == twl4030->codec_powered)\n\t\treturn;\n\n\tif (enable)\n\t\tmode = twl4030_audio_enable_resource(TWL4030_AUDIO_RES_POWER);\n\telse\n\t\tmode = twl4030_audio_disable_resource(TWL4030_AUDIO_RES_POWER);\n\n\tif (mode >= 0)\n\t\ttwl4030->codec_powered = enable;\n\n\t \n\t \n\tudelay(10);\n}\n\nstatic void\ntwl4030_get_board_param_values(struct twl4030_board_params *board_params,\n\t\t\t       struct device_node *node)\n{\n\tint value;\n\n\tof_property_read_u32(node, \"ti,digimic_delay\", &board_params->digimic_delay);\n\tof_property_read_u32(node, \"ti,ramp_delay_value\", &board_params->ramp_delay_value);\n\tof_property_read_u32(node, \"ti,offset_cncl_path\", &board_params->offset_cncl_path);\n\tif (!of_property_read_u32(node, \"ti,hs_extmute\", &value))\n\t\tboard_params->hs_extmute = value;\n\n\tboard_params->hs_extmute_gpio = of_get_named_gpio(node, \"ti,hs_extmute_gpio\", 0);\n\tif (gpio_is_valid(board_params->hs_extmute_gpio))\n\t\tboard_params->hs_extmute = 1;\n}\n\nstatic struct twl4030_board_params*\ntwl4030_get_board_params(struct snd_soc_component *component)\n{\n\tstruct twl4030_board_params *board_params = NULL;\n\tstruct device_node *twl4030_codec_node = NULL;\n\n\ttwl4030_codec_node = of_get_child_by_name(component->dev->parent->of_node,\n\t\t\t\t\t\t  \"codec\");\n\n\tif (twl4030_codec_node) {\n\t\tboard_params = devm_kzalloc(component->dev,\n\t\t\t\t\t    sizeof(struct twl4030_board_params),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!board_params) {\n\t\t\tof_node_put(twl4030_codec_node);\n\t\t\treturn NULL;\n\t\t}\n\t\ttwl4030_get_board_param_values(board_params, twl4030_codec_node);\n\t\tof_node_put(twl4030_codec_node);\n\t}\n\n\treturn board_params;\n}\n\nstatic void twl4030_init_chip(struct snd_soc_component *component)\n{\n\tstruct twl4030_board_params *board_params;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 reg, byte;\n\tint i = 0;\n\n\tboard_params = twl4030_get_board_params(component);\n\n\tif (board_params && board_params->hs_extmute) {\n\t\tif (gpio_is_valid(board_params->hs_extmute_gpio)) {\n\t\t\tint ret;\n\n\t\t\tif (!board_params->hs_extmute_gpio)\n\t\t\t\tdev_warn(component->dev,\n\t\t\t\t\t\"Extmute GPIO is 0 is this correct?\\n\");\n\n\t\t\tret = gpio_request_one(board_params->hs_extmute_gpio,\n\t\t\t\t\t       GPIOF_OUT_INIT_LOW,\n\t\t\t\t\t       \"hs_extmute\");\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to get hs_extmute GPIO\\n\");\n\t\t\t\tboard_params->hs_extmute_gpio = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tu8 pin_mux;\n\n\t\t\t \n\t\t\ttwl_i2c_read_u8(TWL4030_MODULE_INTBR, &pin_mux,\n\t\t\t\t\tTWL4030_PMBR1_REG);\n\t\t\tpin_mux &= ~TWL4030_GPIO6_PWM0_MUTE(0x03);\n\t\t\tpin_mux |= TWL4030_GPIO6_PWM0_MUTE(0x02);\n\t\t\ttwl_i2c_write_u8(TWL4030_MODULE_INTBR, pin_mux,\n\t\t\t\t\t TWL4030_PMBR1_REG);\n\t\t}\n\t}\n\n\t \n\ttw4030_init_ctl_cache(twl4030);\n\n\t \n\treg = twl4030_read(component, TWL4030_REG_MISC_SET_1);\n\ttwl4030_write(component, TWL4030_REG_MISC_SET_1,\n\t\t      reg | TWL4030_SMOOTH_ANAVOL_EN);\n\n\ttwl4030_write(component, TWL4030_REG_OPTION,\n\t\t      TWL4030_ATXL1_EN | TWL4030_ATXR1_EN |\n\t\t      TWL4030_ARXL2_EN | TWL4030_ARXR2_EN);\n\n\t \n\ttwl4030_write(component, TWL4030_REG_ARXR2_APGA_CTL, 0x32);\n\n\t \n\tif (!board_params)\n\t\treturn;\n\n\ttwl4030->board_params = board_params;\n\n\treg = twl4030_read(component, TWL4030_REG_HS_POPN_SET);\n\treg &= ~TWL4030_RAMP_DELAY;\n\treg |= (board_params->ramp_delay_value << 2);\n\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, reg);\n\n\t \n\ttwl4030_codec_enable(component, 1);\n\n\treg = twl4030_read(component, TWL4030_REG_ANAMICL);\n\treg &= ~TWL4030_OFFSET_CNCL_SEL;\n\treg |= board_params->offset_cncl_path;\n\ttwl4030_write(component, TWL4030_REG_ANAMICL,\n\t\t      reg | TWL4030_CNCL_OFFSET_START);\n\n\t \n\tmsleep(20);\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\ttwl_set_regcache_bypass(TWL4030_MODULE_AUDIO_VOICE, true);\n\t\ttwl_i2c_read_u8(TWL4030_MODULE_AUDIO_VOICE, &byte,\n\t\t\t\tTWL4030_REG_ANAMICL);\n\t\ttwl_set_regcache_bypass(TWL4030_MODULE_AUDIO_VOICE, false);\n\t} while ((i++ < 100) &&\n\t\t ((byte & TWL4030_CNCL_OFFSET_START) ==\n\t\t  TWL4030_CNCL_OFFSET_START));\n\n\ttwl4030_codec_enable(component, 0);\n}\n\nstatic void twl4030_apll_enable(struct snd_soc_component *component, int enable)\n{\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tif (enable) {\n\t\ttwl4030->apll_enabled++;\n\t\tif (twl4030->apll_enabled == 1)\n\t\t\ttwl4030_audio_enable_resource(\n\t\t\t\t\t\t\tTWL4030_AUDIO_RES_APLL);\n\t} else {\n\t\ttwl4030->apll_enabled--;\n\t\tif (!twl4030->apll_enabled)\n\t\t\ttwl4030_audio_disable_resource(\n\t\t\t\t\t\t\tTWL4030_AUDIO_RES_APLL);\n\t}\n}\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_earpiece_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_EAR_CTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL1\", TWL4030_REG_EAR_CTL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL2\", TWL4030_REG_EAR_CTL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR1\", TWL4030_REG_EAR_CTL, 3, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_predrivel_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_PREDL_CTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL1\", TWL4030_REG_PREDL_CTL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL2\", TWL4030_REG_PREDL_CTL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR2\", TWL4030_REG_PREDL_CTL, 3, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_predriver_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_PREDR_CTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR1\", TWL4030_REG_PREDR_CTL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR2\", TWL4030_REG_PREDR_CTL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL2\", TWL4030_REG_PREDR_CTL, 3, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_hsol_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_HS_SEL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL1\", TWL4030_REG_HS_SEL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL2\", TWL4030_REG_HS_SEL, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_hsor_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_HS_SEL, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR1\", TWL4030_REG_HS_SEL, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR2\", TWL4030_REG_HS_SEL, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_carkitl_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_PRECKL_CTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL1\", TWL4030_REG_PRECKL_CTL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioL2\", TWL4030_REG_PRECKL_CTL, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_carkitr_controls[] = {\n\tSOC_DAPM_SINGLE(\"Voice\", TWL4030_REG_PRECKR_CTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR1\", TWL4030_REG_PRECKR_CTL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AudioR2\", TWL4030_REG_PRECKR_CTL, 2, 1, 0),\n};\n\n \nstatic const char *twl4030_handsfreel_texts[] =\n\t\t{\"Voice\", \"AudioL1\", \"AudioL2\", \"AudioR2\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_handsfreel_enum,\n\t\t\t    TWL4030_REG_HFL_CTL, 0,\n\t\t\t    twl4030_handsfreel_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_handsfreel_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_handsfreel_enum);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_handsfreelmute_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\n\n \nstatic const char *twl4030_handsfreer_texts[] =\n\t\t{\"Voice\", \"AudioR1\", \"AudioR2\", \"AudioL2\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_handsfreer_enum,\n\t\t\t    TWL4030_REG_HFR_CTL, 0,\n\t\t\t    twl4030_handsfreer_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_handsfreer_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_handsfreer_enum);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_handsfreermute_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\n\n \n \nstatic const char *twl4030_vibra_texts[] =\n\t\t{\"AudioL1\", \"AudioR1\", \"AudioL2\", \"AudioR2\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_vibra_enum,\n\t\t\t    TWL4030_REG_VIBRA_CTL, 2,\n\t\t\t    twl4030_vibra_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_vibra_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_vibra_enum);\n\n \nstatic const char *twl4030_vibrapath_texts[] =\n\t\t{\"Local vibrator\", \"Audio\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_vibrapath_enum,\n\t\t\t    TWL4030_REG_VIBRA_CTL, 4,\n\t\t\t    twl4030_vibrapath_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_vibrapath_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_vibrapath_enum);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_analoglmic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Main Mic Capture Switch\",\n\t\t\tTWL4030_REG_ANAMICL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Headset Mic Capture Switch\",\n\t\t\tTWL4030_REG_ANAMICL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUXL Capture Switch\",\n\t\t\tTWL4030_REG_ANAMICL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Carkit Mic Capture Switch\",\n\t\t\tTWL4030_REG_ANAMICL, 3, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_analogrmic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Sub Mic Capture Switch\", TWL4030_REG_ANAMICR, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUXR Capture Switch\", TWL4030_REG_ANAMICR, 2, 1, 0),\n};\n\n \nstatic const char *twl4030_micpathtx1_texts[] =\n\t\t{\"Analog\", \"Digimic0\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_micpathtx1_enum,\n\t\t\t    TWL4030_REG_ADCMICSEL, 0,\n\t\t\t    twl4030_micpathtx1_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_micpathtx1_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_micpathtx1_enum);\n\n \nstatic const char *twl4030_micpathtx2_texts[] =\n\t\t{\"Analog\", \"Digimic1\"};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_micpathtx2_enum,\n\t\t\t    TWL4030_REG_ADCMICSEL, 2,\n\t\t\t    twl4030_micpathtx2_texts);\n\nstatic const struct snd_kcontrol_new twl4030_dapm_micpathtx2_control =\nSOC_DAPM_ENUM(\"Route\", twl4030_micpathtx2_enum);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_abypassr1_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL4030_REG_ARXR1_APGA_CTL, 2, 1, 0);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_abypassl1_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL4030_REG_ARXL1_APGA_CTL, 2, 1, 0);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_abypassr2_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL4030_REG_ARXR2_APGA_CTL, 2, 1, 0);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_abypassl2_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL4030_REG_ARXL2_APGA_CTL, 2, 1, 0);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_abypassv_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL4030_REG_VDL_APGA_CTL, 2, 1, 0);\n\n \nstatic const DECLARE_TLV_DB_RANGE(twl4030_dapm_dbypass_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-3000, 600, 1),\n\t2, 3, TLV_DB_SCALE_ITEM(-2400, 0, 0),\n\t4, 7, TLV_DB_SCALE_ITEM(-1800, 600, 0)\n);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_dbypassl_control =\n\tSOC_DAPM_SINGLE_TLV(\"Volume\",\n\t\t\tTWL4030_REG_ATX2ARXPGA, 3, 7, 0,\n\t\t\ttwl4030_dapm_dbypass_tlv);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_dbypassr_control =\n\tSOC_DAPM_SINGLE_TLV(\"Volume\",\n\t\t\tTWL4030_REG_ATX2ARXPGA, 0, 7, 0,\n\t\t\ttwl4030_dapm_dbypass_tlv);\n\n \nstatic DECLARE_TLV_DB_SCALE(twl4030_dapm_dbypassv_tlv, -5100, 100, 1);\n\n \nstatic const struct snd_kcontrol_new twl4030_dapm_dbypassv_control =\n\tSOC_DAPM_SINGLE_TLV(\"Volume\",\n\t\t\tTWL4030_REG_VSTPGA, 0, 0x29, 0,\n\t\t\ttwl4030_dapm_dbypassv_tlv);\n\n \n#define TWL4030_OUTPUT_PGA(pin_name, reg, mask)\t\t\t\t\\\nstatic int pin_name##pga_event(struct snd_soc_dapm_widget *w,\t\t\\\n\t\t\t       struct snd_kcontrol *kcontrol, int event) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\t\\\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component); \\\n\t\t\t\t\t\t\t\t\t\\\n\tswitch (event) {\t\t\t\t\t\t\\\n\tcase SND_SOC_DAPM_POST_PMU:\t\t\t\t\t\\\n\t\ttwl4030->pin_name##_enabled = 1;\t\t\t\\\n\t\ttwl4030_write(component, reg, twl4030_read(component, reg));\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase SND_SOC_DAPM_POST_PMD:\t\t\t\t\t\\\n\t\ttwl4030->pin_name##_enabled = 0;\t\t\t\\\n\t\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, 0, reg);\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn 0;\t\t\t\t\t\t\t\\\n}\n\nTWL4030_OUTPUT_PGA(earpiece, TWL4030_REG_EAR_CTL, TWL4030_EAR_GAIN);\nTWL4030_OUTPUT_PGA(predrivel, TWL4030_REG_PREDL_CTL, TWL4030_PREDL_GAIN);\nTWL4030_OUTPUT_PGA(predriver, TWL4030_REG_PREDR_CTL, TWL4030_PREDR_GAIN);\nTWL4030_OUTPUT_PGA(carkitl, TWL4030_REG_PRECKL_CTL, TWL4030_PRECKL_GAIN);\nTWL4030_OUTPUT_PGA(carkitr, TWL4030_REG_PRECKR_CTL, TWL4030_PRECKR_GAIN);\n\nstatic void handsfree_ramp(struct snd_soc_component *component, int reg, int ramp)\n{\n\tunsigned char hs_ctl;\n\n\ths_ctl = twl4030_read(component, reg);\n\n\tif (ramp) {\n\t\t \n\t\ths_ctl |= TWL4030_HF_CTL_REF_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t\tudelay(10);\n\t\ths_ctl |= TWL4030_HF_CTL_RAMP_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t\tudelay(40);\n\t\ths_ctl |= TWL4030_HF_CTL_LOOP_EN;\n\t\ths_ctl |= TWL4030_HF_CTL_HB_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t} else {\n\t\t \n\t\ths_ctl &= ~TWL4030_HF_CTL_LOOP_EN;\n\t\ths_ctl &= ~TWL4030_HF_CTL_HB_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t\ths_ctl &= ~TWL4030_HF_CTL_RAMP_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t\tudelay(40);\n\t\ths_ctl &= ~TWL4030_HF_CTL_REF_EN;\n\t\ttwl4030_write(component, reg, hs_ctl);\n\t}\n}\n\nstatic int handsfreelpga_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\thandsfree_ramp(component, TWL4030_REG_HFL_CTL, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\thandsfree_ramp(component, TWL4030_REG_HFL_CTL, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int handsfreerpga_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\thandsfree_ramp(component, TWL4030_REG_HFR_CTL, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\thandsfree_ramp(component, TWL4030_REG_HFR_CTL, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int vibramux_event(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\ttwl4030_write(component, TWL4030_REG_VIBRA_SET, 0xff);\n\treturn 0;\n}\n\nstatic int apll_event(struct snd_soc_dapm_widget *w,\n\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\ttwl4030_apll_enable(component, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\ttwl4030_apll_enable(component, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int aif_event(struct snd_soc_dapm_widget *w,\n\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu8 audio_if;\n\n\taudio_if = twl4030_read(component, TWL4030_REG_AUDIO_IF);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\t \n\t\ttwl4030_apll_enable(component, 1);\n\n\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF,\n\t\t\t      audio_if | TWL4030_AIF_EN);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF,\n\t\t\t      audio_if &  ~TWL4030_AIF_EN);\n\t\ttwl4030_apll_enable(component, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void headset_ramp(struct snd_soc_component *component, int ramp)\n{\n\tunsigned char hs_gain, hs_pop;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tstruct twl4030_board_params *board_params = twl4030->board_params;\n\t \n\tstatic const unsigned int ramp_base[] = {\n\t\t524288, 1048576, 2097152, 4194304,\n\t\t8388608, 16777216, 33554432, 67108864\n\t};\n\tunsigned int delay;\n\n\ths_gain = twl4030_read(component, TWL4030_REG_HS_GAIN_SET);\n\ths_pop = twl4030_read(component, TWL4030_REG_HS_POPN_SET);\n\tdelay = (ramp_base[(hs_pop & TWL4030_RAMP_DELAY) >> 2] /\n\t\ttwl4030->sysclk) + 1;\n\n\t \n\tif (board_params && board_params->hs_extmute) {\n\t\tif (gpio_is_valid(board_params->hs_extmute_gpio)) {\n\t\t\tgpio_set_value(board_params->hs_extmute_gpio, 1);\n\t\t} else {\n\t\t\ths_pop |= TWL4030_EXTMUTE;\n\t\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t\t}\n\t}\n\n\tif (ramp) {\n\t\t \n\t\ths_pop |= TWL4030_VMID_EN;\n\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t\t \n\t\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, hs_gain,\n\t\t\t\t TWL4030_REG_HS_GAIN_SET);\n\t\ths_pop |= TWL4030_RAMP_EN;\n\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t\t \n\t\ttwl4030_wait_ms(delay);\n\t} else {\n\t\t \n\t\ths_pop &= ~TWL4030_RAMP_EN;\n\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t\t \n\t\ttwl4030_wait_ms(delay);\n\t\t \n\t\ttwl_i2c_write_u8(TWL4030_MODULE_AUDIO_VOICE, hs_gain & (~0x0f),\n\t\t\t\t TWL4030_REG_HS_GAIN_SET);\n\n\t\ths_pop &= ~TWL4030_VMID_EN;\n\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t}\n\n\t \n\tif (board_params && board_params->hs_extmute) {\n\t\tif (gpio_is_valid(board_params->hs_extmute_gpio)) {\n\t\t\tgpio_set_value(board_params->hs_extmute_gpio, 0);\n\t\t} else {\n\t\t\ths_pop &= ~TWL4030_EXTMUTE;\n\t\t\ttwl4030_write(component, TWL4030_REG_HS_POPN_SET, hs_pop);\n\t\t}\n\t}\n}\n\nstatic int headsetlpga_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tif (!twl4030->hsr_enabled)\n\t\t\theadset_ramp(component, 1);\n\n\t\ttwl4030->hsl_enabled = 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tif (!twl4030->hsr_enabled)\n\t\t\theadset_ramp(component, 0);\n\n\t\ttwl4030->hsl_enabled = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int headsetrpga_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tif (!twl4030->hsl_enabled)\n\t\t\theadset_ramp(component, 1);\n\n\t\ttwl4030->hsr_enabled = 1;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tif (!twl4030->hsl_enabled)\n\t\t\theadset_ramp(component, 0);\n\n\t\ttwl4030->hsr_enabled = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int digimic_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tstruct twl4030_board_params *board_params = twl4030->board_params;\n\n\tif (board_params && board_params->digimic_delay)\n\t\ttwl4030_wait_ms(board_params->digimic_delay);\n\treturn 0;\n}\n\n \nstatic int snd_soc_get_volsw_twl4030(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint mask = (1 << fls(max)) - 1;\n\n\tucontrol->value.integer.value[0] =\n\t\t(twl4030_read(component, reg) >> shift) & mask;\n\tif (ucontrol->value.integer.value[0])\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmax + 1 - ucontrol->value.integer.value[0];\n\n\tif (shift != rshift) {\n\t\tucontrol->value.integer.value[1] =\n\t\t\t(twl4030_read(component, reg) >> rshift) & mask;\n\t\tif (ucontrol->value.integer.value[1])\n\t\t\tucontrol->value.integer.value[1] =\n\t\t\t\tmax + 1 - ucontrol->value.integer.value[1];\n\t}\n\n\treturn 0;\n}\n\nstatic int snd_soc_put_volsw_twl4030(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg = mc->reg;\n\tunsigned int shift = mc->shift;\n\tunsigned int rshift = mc->rshift;\n\tint max = mc->max;\n\tint mask = (1 << fls(max)) - 1;\n\tunsigned short val, val2, val_mask;\n\n\tval = (ucontrol->value.integer.value[0] & mask);\n\n\tval_mask = mask << shift;\n\tif (val)\n\t\tval = max + 1 - val;\n\tval = val << shift;\n\tif (shift != rshift) {\n\t\tval2 = (ucontrol->value.integer.value[1] & mask);\n\t\tval_mask |= mask << rshift;\n\t\tif (val2)\n\t\t\tval2 = max + 1 - val2;\n\t\tval |= val2 << rshift;\n\t}\n\treturn snd_soc_component_update_bits(component, reg, val_mask, val);\n}\n\nstatic int snd_soc_get_volsw_r2_twl4030(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tint max = mc->max;\n\tint mask = (1<<fls(max))-1;\n\n\tucontrol->value.integer.value[0] =\n\t\t(twl4030_read(component, reg) >> shift) & mask;\n\tucontrol->value.integer.value[1] =\n\t\t(twl4030_read(component, reg2) >> shift) & mask;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tucontrol->value.integer.value[0] =\n\t\t\tmax + 1 - ucontrol->value.integer.value[0];\n\tif (ucontrol->value.integer.value[1])\n\t\tucontrol->value.integer.value[1] =\n\t\t\tmax + 1 - ucontrol->value.integer.value[1];\n\n\treturn 0;\n}\n\nstatic int snd_soc_put_volsw_r2_twl4030(struct snd_kcontrol *kcontrol,\n\t\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tunsigned int shift = mc->shift;\n\tint max = mc->max;\n\tint mask = (1 << fls(max)) - 1;\n\tint err;\n\tunsigned short val, val2, val_mask;\n\n\tval_mask = mask << shift;\n\tval = (ucontrol->value.integer.value[0] & mask);\n\tval2 = (ucontrol->value.integer.value[1] & mask);\n\n\tif (val)\n\t\tval = max + 1 - val;\n\tif (val2)\n\t\tval2 = max + 1 - val2;\n\n\tval = val << shift;\n\tval2 = val2 << shift;\n\n\terr = snd_soc_component_update_bits(component, reg, val_mask, val);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = snd_soc_component_update_bits(component, reg2, val_mask, val2);\n\treturn err;\n}\n\n \nstatic const char *twl4030_op_modes_texts[] = {\n\t\"Option 2 (voice/audio)\", \"Option 1 (audio)\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_op_modes_enum,\n\t\t\t    TWL4030_REG_CODEC_MODE, 0,\n\t\t\t    twl4030_op_modes_texts);\n\nstatic int snd_soc_put_twl4030_opmode_enum_double(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tif (twl4030->configured) {\n\t\tdev_err(component->dev,\n\t\t\t\"operation mode cannot be changed on-the-fly\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn snd_soc_put_enum_double(kcontrol, ucontrol);\n}\n\n \nstatic DECLARE_TLV_DB_SCALE(digital_fine_tlv, -6300, 100, 1);\n\n \nstatic DECLARE_TLV_DB_SCALE(digital_coarse_tlv, 0, 600, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(digital_voice_downlink_tlv, -3700, 100, 1);\n\n \nstatic DECLARE_TLV_DB_SCALE(analog_tlv, -2400, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(output_tvl, -1200, 600, 1);\n\n \nstatic DECLARE_TLV_DB_SCALE(output_ear_tvl, -600, 600, 1);\n\n \nstatic DECLARE_TLV_DB_SCALE(digital_capture_tlv, 0, 100, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(input_gain_tlv, 0, 600, 0);\n\n \nstatic const char *twl4030_avadc_clk_priority_texts[] = {\n\t\"Voice high priority\", \"HiFi high priority\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_avadc_clk_priority_enum,\n\t\t\t    TWL4030_REG_AVADC_CTL, 2,\n\t\t\t    twl4030_avadc_clk_priority_texts);\n\nstatic const char *twl4030_rampdelay_texts[] = {\n\t\"27/20/14 ms\", \"55/40/27 ms\", \"109/81/55 ms\", \"218/161/109 ms\",\n\t\"437/323/218 ms\", \"874/645/437 ms\", \"1748/1291/874 ms\",\n\t\"3495/2581/1748 ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_rampdelay_enum,\n\t\t\t    TWL4030_REG_HS_POPN_SET, 2,\n\t\t\t    twl4030_rampdelay_texts);\n\n \nstatic const char *twl4030_vibradirmode_texts[] = {\n\t\"Vibra H-bridge direction\", \"Audio data MSB\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_vibradirmode_enum,\n\t\t\t    TWL4030_REG_VIBRA_CTL, 5,\n\t\t\t    twl4030_vibradirmode_texts);\n\n \nstatic const char *twl4030_vibradir_texts[] = {\n\t\"Positive polarity\", \"Negative polarity\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_vibradir_enum,\n\t\t\t    TWL4030_REG_VIBRA_CTL, 1,\n\t\t\t    twl4030_vibradir_texts);\n\n \nstatic const char *twl4030_digimicswap_texts[] = {\n\t\"Not swapped\", \"Swapped\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(twl4030_digimicswap_enum,\n\t\t\t    TWL4030_REG_MISC_SET_1, 0,\n\t\t\t    twl4030_digimicswap_texts);\n\nstatic const struct snd_kcontrol_new twl4030_snd_controls[] = {\n\t \n\tSOC_ENUM_EXT(\"Codec Operation Mode\", twl4030_op_modes_enum,\n\t\tsnd_soc_get_enum_double,\n\t\tsnd_soc_put_twl4030_opmode_enum_double),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"DAC1 Digital Fine Playback Volume\",\n\t\tTWL4030_REG_ARXL1PGA, TWL4030_REG_ARXR1PGA,\n\t\t0, 0x3f, 0, digital_fine_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Digital Fine Playback Volume\",\n\t\tTWL4030_REG_ARXL2PGA, TWL4030_REG_ARXR2PGA,\n\t\t0, 0x3f, 0, digital_fine_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"DAC1 Digital Coarse Playback Volume\",\n\t\tTWL4030_REG_ARXL1PGA, TWL4030_REG_ARXR1PGA,\n\t\t6, 0x2, 0, digital_coarse_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Digital Coarse Playback Volume\",\n\t\tTWL4030_REG_ARXL2PGA, TWL4030_REG_ARXR2PGA,\n\t\t6, 0x2, 0, digital_coarse_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"DAC1 Analog Playback Volume\",\n\t\tTWL4030_REG_ARXL1_APGA_CTL, TWL4030_REG_ARXR1_APGA_CTL,\n\t\t3, 0x12, 1, analog_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Analog Playback Volume\",\n\t\tTWL4030_REG_ARXL2_APGA_CTL, TWL4030_REG_ARXR2_APGA_CTL,\n\t\t3, 0x12, 1, analog_tlv),\n\tSOC_DOUBLE_R(\"DAC1 Analog Playback Switch\",\n\t\tTWL4030_REG_ARXL1_APGA_CTL, TWL4030_REG_ARXR1_APGA_CTL,\n\t\t1, 1, 0),\n\tSOC_DOUBLE_R(\"DAC2 Analog Playback Switch\",\n\t\tTWL4030_REG_ARXL2_APGA_CTL, TWL4030_REG_ARXR2_APGA_CTL,\n\t\t1, 1, 0),\n\n\t \n\tSOC_SINGLE_TLV(\"DAC Voice Digital Downlink Volume\",\n\t\tTWL4030_REG_VRXPGA, 0, 0x31, 0, digital_voice_downlink_tlv),\n\n\tSOC_SINGLE_TLV(\"DAC Voice Analog Downlink Volume\",\n\t\tTWL4030_REG_VDL_APGA_CTL, 3, 0x12, 1, analog_tlv),\n\n\tSOC_SINGLE(\"DAC Voice Analog Downlink Switch\",\n\t\tTWL4030_REG_VDL_APGA_CTL, 1, 1, 0),\n\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"PreDriv Playback Volume\",\n\t\tTWL4030_REG_PREDL_CTL, TWL4030_REG_PREDR_CTL,\n\t\t4, 3, 0, snd_soc_get_volsw_r2_twl4030,\n\t\tsnd_soc_put_volsw_r2_twl4030, output_tvl),\n\n\tSOC_DOUBLE_EXT_TLV(\"Headset Playback Volume\",\n\t\tTWL4030_REG_HS_GAIN_SET, 0, 2, 3, 0, snd_soc_get_volsw_twl4030,\n\t\tsnd_soc_put_volsw_twl4030, output_tvl),\n\n\tSOC_DOUBLE_R_EXT_TLV(\"Carkit Playback Volume\",\n\t\tTWL4030_REG_PRECKL_CTL, TWL4030_REG_PRECKR_CTL,\n\t\t4, 3, 0, snd_soc_get_volsw_r2_twl4030,\n\t\tsnd_soc_put_volsw_r2_twl4030, output_tvl),\n\n\tSOC_SINGLE_EXT_TLV(\"Earpiece Playback Volume\",\n\t\tTWL4030_REG_EAR_CTL, 4, 3, 0, snd_soc_get_volsw_twl4030,\n\t\tsnd_soc_put_volsw_twl4030, output_ear_tvl),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"TX1 Digital Capture Volume\",\n\t\tTWL4030_REG_ATXL1PGA, TWL4030_REG_ATXR1PGA,\n\t\t0, 0x1f, 0, digital_capture_tlv),\n\tSOC_DOUBLE_R_TLV(\"TX2 Digital Capture Volume\",\n\t\tTWL4030_REG_AVTXL2PGA, TWL4030_REG_AVTXR2PGA,\n\t\t0, 0x1f, 0, digital_capture_tlv),\n\n\tSOC_DOUBLE_TLV(\"Analog Capture Volume\", TWL4030_REG_ANAMIC_GAIN,\n\t\t0, 3, 5, 0, input_gain_tlv),\n\n\tSOC_ENUM(\"AVADC Clock Priority\", twl4030_avadc_clk_priority_enum),\n\n\tSOC_ENUM(\"HS ramp delay\", twl4030_rampdelay_enum),\n\n\tSOC_ENUM(\"Vibra H-bridge mode\", twl4030_vibradirmode_enum),\n\tSOC_ENUM(\"Vibra H-bridge direction\", twl4030_vibradir_enum),\n\n\tSOC_ENUM(\"Digimic LR Swap\", twl4030_digimicswap_enum),\n};\n\nstatic const struct snd_soc_dapm_widget twl4030_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"MAINMIC\"),\n\tSND_SOC_DAPM_INPUT(\"HSMIC\"),\n\tSND_SOC_DAPM_INPUT(\"AUXL\"),\n\tSND_SOC_DAPM_INPUT(\"CARKITMIC\"),\n\t \n\tSND_SOC_DAPM_INPUT(\"SUBMIC\"),\n\tSND_SOC_DAPM_INPUT(\"AUXR\"),\n\t \n\tSND_SOC_DAPM_INPUT(\"DIGIMIC0\"),\n\tSND_SOC_DAPM_INPUT(\"DIGIMIC1\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"EARPIECE\"),\n\tSND_SOC_DAPM_OUTPUT(\"PREDRIVEL\"),\n\tSND_SOC_DAPM_OUTPUT(\"PREDRIVER\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSOR\"),\n\tSND_SOC_DAPM_OUTPUT(\"CARKITL\"),\n\tSND_SOC_DAPM_OUTPUT(\"CARKITR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HFL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HFR\"),\n\tSND_SOC_DAPM_OUTPUT(\"VIBRA\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"Virtual HiFi OUT\"),\n\tSND_SOC_DAPM_INPUT(\"Virtual HiFi IN\"),\n\tSND_SOC_DAPM_OUTPUT(\"Virtual Voice OUT\"),\n\n\t \n\tSND_SOC_DAPM_DAC(\"DAC Right1\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Left1\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Right2\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Left2\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Voice\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"VAIFIN\", \"Voice Playback\", 0,\n\t\t\t    TWL4030_REG_VOICE_IF, 6, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"Right1 Analog Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_abypassr1_control),\n\tSND_SOC_DAPM_SWITCH(\"Left1 Analog Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_abypassl1_control),\n\tSND_SOC_DAPM_SWITCH(\"Right2 Analog Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_abypassr2_control),\n\tSND_SOC_DAPM_SWITCH(\"Left2 Analog Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_abypassl2_control),\n\tSND_SOC_DAPM_SWITCH(\"Voice Analog Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_abypassv_control),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"FM Loop Enable\", TWL4030_REG_MISC_SET_1, 5, 0,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"Left Digital Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_dbypassl_control),\n\tSND_SOC_DAPM_SWITCH(\"Right Digital Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_dbypassr_control),\n\tSND_SOC_DAPM_SWITCH(\"Voice Digital Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_dbypassv_control),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Digital R1 Playback Mixer\",\n\t\t\tTWL4030_REG_AVDAC_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Digital L1 Playback Mixer\",\n\t\t\tTWL4030_REG_AVDAC_CTL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Digital R2 Playback Mixer\",\n\t\t\tTWL4030_REG_AVDAC_CTL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Digital L2 Playback Mixer\",\n\t\t\tTWL4030_REG_AVDAC_CTL, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Digital Voice Playback Mixer\",\n\t\t\tTWL4030_REG_AVDAC_CTL, 4, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Analog R1 Playback Mixer\",\n\t\t\tTWL4030_REG_ARXR1_APGA_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Analog L1 Playback Mixer\",\n\t\t\tTWL4030_REG_ARXL1_APGA_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Analog R2 Playback Mixer\",\n\t\t\tTWL4030_REG_ARXR2_APGA_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Analog L2 Playback Mixer\",\n\t\t\tTWL4030_REG_ARXL2_APGA_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Analog Voice Playback Mixer\",\n\t\t\tTWL4030_REG_VDL_APGA_CTL, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"APLL Enable\", SND_SOC_NOPM, 0, 0, apll_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_SUPPLY(\"AIF Enable\", SND_SOC_NOPM, 0, 0, aif_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU|SND_SOC_DAPM_POST_PMD),\n\n\t \n\t \n\tSND_SOC_DAPM_MIXER(\"Earpiece Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_earpiece_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_earpiece_controls)),\n\tSND_SOC_DAPM_PGA_E(\"Earpiece PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, earpiecepga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\t \n\tSND_SOC_DAPM_MIXER(\"PredriveL Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_predrivel_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_predrivel_controls)),\n\tSND_SOC_DAPM_PGA_E(\"PredriveL PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, predrivelpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MIXER(\"PredriveR Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_predriver_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_predriver_controls)),\n\tSND_SOC_DAPM_PGA_E(\"PredriveR PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, predriverpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\t \n\tSND_SOC_DAPM_MIXER(\"HeadsetL Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_hsol_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_hsol_controls)),\n\tSND_SOC_DAPM_PGA_E(\"HeadsetL PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, headsetlpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MIXER(\"HeadsetR Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_hsor_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_hsor_controls)),\n\tSND_SOC_DAPM_PGA_E(\"HeadsetR PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, headsetrpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\t \n\tSND_SOC_DAPM_MIXER(\"CarkitL Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_carkitl_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_carkitl_controls)),\n\tSND_SOC_DAPM_PGA_E(\"CarkitL PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, carkitlpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MIXER(\"CarkitR Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_carkitr_controls[0],\n\t\t\tARRAY_SIZE(twl4030_dapm_carkitr_controls)),\n\tSND_SOC_DAPM_PGA_E(\"CarkitR PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, carkitrpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\n\t \n\t \n\tSND_SOC_DAPM_MUX(\"HandsfreeL Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&twl4030_dapm_handsfreel_control),\n\tSND_SOC_DAPM_SWITCH(\"HandsfreeL\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_handsfreelmute_control),\n\tSND_SOC_DAPM_PGA_E(\"HandsfreeL PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, handsfreelpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MUX(\"HandsfreeR Mux\", SND_SOC_NOPM, 5, 0,\n\t\t&twl4030_dapm_handsfreer_control),\n\tSND_SOC_DAPM_SWITCH(\"HandsfreeR\", SND_SOC_NOPM, 0, 0,\n\t\t\t&twl4030_dapm_handsfreermute_control),\n\tSND_SOC_DAPM_PGA_E(\"HandsfreeR PGA\", SND_SOC_NOPM,\n\t\t\t0, 0, NULL, 0, handsfreerpga_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_POST_PMD),\n\t \n\tSND_SOC_DAPM_MUX_E(\"Vibra Mux\", TWL4030_REG_VIBRA_CTL, 0, 0,\n\t\t\t   &twl4030_dapm_vibra_control, vibramux_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_MUX(\"Vibra Route\", SND_SOC_NOPM, 0, 0,\n\t\t&twl4030_dapm_vibrapath_control),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC Virtual Left1\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Virtual Right1\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Virtual Left2\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Virtual Right2\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"VAIFOUT\", \"Voice Capture\", 0,\n\t\t\t     TWL4030_REG_VOICE_IF, 5, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"TX1 Capture Route\", SND_SOC_NOPM, 0, 0,\n\t\t&twl4030_dapm_micpathtx1_control),\n\tSND_SOC_DAPM_MUX(\"TX2 Capture Route\", SND_SOC_NOPM, 0, 0,\n\t\t&twl4030_dapm_micpathtx2_control),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Analog Left\",\n\t\tTWL4030_REG_ANAMICL, 4, 0,\n\t\t&twl4030_dapm_analoglmic_controls[0],\n\t\tARRAY_SIZE(twl4030_dapm_analoglmic_controls)),\n\tSND_SOC_DAPM_MIXER(\"Analog Right\",\n\t\tTWL4030_REG_ANAMICR, 4, 0,\n\t\t&twl4030_dapm_analogrmic_controls[0],\n\t\tARRAY_SIZE(twl4030_dapm_analogrmic_controls)),\n\n\tSND_SOC_DAPM_PGA(\"ADC Physical Left\",\n\t\tTWL4030_REG_AVADC_CTL, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC Physical Right\",\n\t\tTWL4030_REG_AVADC_CTL, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_E(\"Digimic0 Enable\",\n\t\tTWL4030_REG_ADCMICSEL, 1, 0, NULL, 0,\n\t\tdigimic_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_PGA_E(\"Digimic1 Enable\",\n\t\tTWL4030_REG_ADCMICSEL, 3, 0, NULL, 0,\n\t\tdigimic_event, SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_SUPPLY(\"micbias1 select\", TWL4030_REG_MICBIAS_CTL, 5, 0,\n\t\t\t    NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"micbias2 select\", TWL4030_REG_MICBIAS_CTL, 6, 0,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 1\",\n\t\t\t    TWL4030_REG_MICBIAS_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 2\",\n\t\t\t    TWL4030_REG_MICBIAS_CTL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headset Mic Bias\",\n\t\t\t    TWL4030_REG_MICBIAS_CTL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"VIF Enable\", TWL4030_REG_VOICE_IF, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t \n\t{\"DAC Right1\", NULL, \"HiFi Playback\"},\n\t{\"DAC Left1\", NULL, \"HiFi Playback\"},\n\t{\"DAC Right2\", NULL, \"HiFi Playback\"},\n\t{\"DAC Left2\", NULL, \"HiFi Playback\"},\n\t{\"DAC Voice\", NULL, \"VAIFIN\"},\n\n\t \n\t{\"HiFi Capture\", NULL, \"ADC Virtual Left1\"},\n\t{\"HiFi Capture\", NULL, \"ADC Virtual Right1\"},\n\t{\"HiFi Capture\", NULL, \"ADC Virtual Left2\"},\n\t{\"HiFi Capture\", NULL, \"ADC Virtual Right2\"},\n\t{\"VAIFOUT\", NULL, \"ADC Virtual Left2\"},\n\t{\"VAIFOUT\", NULL, \"ADC Virtual Right2\"},\n\t{\"VAIFOUT\", NULL, \"VIF Enable\"},\n\n\t{\"Digital L1 Playback Mixer\", NULL, \"DAC Left1\"},\n\t{\"Digital R1 Playback Mixer\", NULL, \"DAC Right1\"},\n\t{\"Digital L2 Playback Mixer\", NULL, \"DAC Left2\"},\n\t{\"Digital R2 Playback Mixer\", NULL, \"DAC Right2\"},\n\t{\"Digital Voice Playback Mixer\", NULL, \"DAC Voice\"},\n\n\t \n\t{\"Digital Voice Playback Mixer\", NULL, \"APLL Enable\"},\n\n\t{\"DAC Left1\", NULL, \"AIF Enable\"},\n\t{\"DAC Right1\", NULL, \"AIF Enable\"},\n\t{\"DAC Left2\", NULL, \"AIF Enable\"},\n\t{\"DAC Right1\", NULL, \"AIF Enable\"},\n\t{\"DAC Voice\", NULL, \"VIF Enable\"},\n\n\t{\"Digital R2 Playback Mixer\", NULL, \"AIF Enable\"},\n\t{\"Digital L2 Playback Mixer\", NULL, \"AIF Enable\"},\n\n\t{\"Analog L1 Playback Mixer\", NULL, \"Digital L1 Playback Mixer\"},\n\t{\"Analog R1 Playback Mixer\", NULL, \"Digital R1 Playback Mixer\"},\n\t{\"Analog L2 Playback Mixer\", NULL, \"Digital L2 Playback Mixer\"},\n\t{\"Analog R2 Playback Mixer\", NULL, \"Digital R2 Playback Mixer\"},\n\t{\"Analog Voice Playback Mixer\", NULL, \"Digital Voice Playback Mixer\"},\n\n\t \n\t \n\t{\"Earpiece Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"Earpiece Mixer\", \"AudioL1\", \"Analog L1 Playback Mixer\"},\n\t{\"Earpiece Mixer\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"Earpiece Mixer\", \"AudioR1\", \"Analog R1 Playback Mixer\"},\n\t{\"Earpiece PGA\", NULL, \"Earpiece Mixer\"},\n\t \n\t{\"PredriveL Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"PredriveL Mixer\", \"AudioL1\", \"Analog L1 Playback Mixer\"},\n\t{\"PredriveL Mixer\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"PredriveL Mixer\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"PredriveL PGA\", NULL, \"PredriveL Mixer\"},\n\t \n\t{\"PredriveR Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"PredriveR Mixer\", \"AudioR1\", \"Analog R1 Playback Mixer\"},\n\t{\"PredriveR Mixer\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"PredriveR Mixer\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"PredriveR PGA\", NULL, \"PredriveR Mixer\"},\n\t \n\t{\"HeadsetL Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"HeadsetL Mixer\", \"AudioL1\", \"Analog L1 Playback Mixer\"},\n\t{\"HeadsetL Mixer\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"HeadsetL PGA\", NULL, \"HeadsetL Mixer\"},\n\t \n\t{\"HeadsetR Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"HeadsetR Mixer\", \"AudioR1\", \"Analog R1 Playback Mixer\"},\n\t{\"HeadsetR Mixer\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"HeadsetR PGA\", NULL, \"HeadsetR Mixer\"},\n\t \n\t{\"CarkitL Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"CarkitL Mixer\", \"AudioL1\", \"Analog L1 Playback Mixer\"},\n\t{\"CarkitL Mixer\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"CarkitL PGA\", NULL, \"CarkitL Mixer\"},\n\t \n\t{\"CarkitR Mixer\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"CarkitR Mixer\", \"AudioR1\", \"Analog R1 Playback Mixer\"},\n\t{\"CarkitR Mixer\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"CarkitR PGA\", NULL, \"CarkitR Mixer\"},\n\t \n\t{\"HandsfreeL Mux\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"HandsfreeL Mux\", \"AudioL1\", \"Analog L1 Playback Mixer\"},\n\t{\"HandsfreeL Mux\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"HandsfreeL Mux\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"HandsfreeL\", \"Switch\", \"HandsfreeL Mux\"},\n\t{\"HandsfreeL PGA\", NULL, \"HandsfreeL\"},\n\t \n\t{\"HandsfreeR Mux\", \"Voice\", \"Analog Voice Playback Mixer\"},\n\t{\"HandsfreeR Mux\", \"AudioR1\", \"Analog R1 Playback Mixer\"},\n\t{\"HandsfreeR Mux\", \"AudioR2\", \"Analog R2 Playback Mixer\"},\n\t{\"HandsfreeR Mux\", \"AudioL2\", \"Analog L2 Playback Mixer\"},\n\t{\"HandsfreeR\", \"Switch\", \"HandsfreeR Mux\"},\n\t{\"HandsfreeR PGA\", NULL, \"HandsfreeR\"},\n\t \n\t{\"Vibra Mux\", \"AudioL1\", \"DAC Left1\"},\n\t{\"Vibra Mux\", \"AudioR1\", \"DAC Right1\"},\n\t{\"Vibra Mux\", \"AudioL2\", \"DAC Left2\"},\n\t{\"Vibra Mux\", \"AudioR2\", \"DAC Right2\"},\n\n\t \n\t \n\t{\"Virtual HiFi OUT\", NULL, \"DAC Left1\"},\n\t{\"Virtual HiFi OUT\", NULL, \"DAC Right1\"},\n\t{\"Virtual HiFi OUT\", NULL, \"DAC Left2\"},\n\t{\"Virtual HiFi OUT\", NULL, \"DAC Right2\"},\n\t \n\t{\"Virtual Voice OUT\", NULL, \"Digital Voice Playback Mixer\"},\n\t \n\t{\"EARPIECE\", NULL, \"Earpiece PGA\"},\n\t{\"PREDRIVEL\", NULL, \"PredriveL PGA\"},\n\t{\"PREDRIVER\", NULL, \"PredriveR PGA\"},\n\t{\"HSOL\", NULL, \"HeadsetL PGA\"},\n\t{\"HSOR\", NULL, \"HeadsetR PGA\"},\n\t{\"CARKITL\", NULL, \"CarkitL PGA\"},\n\t{\"CARKITR\", NULL, \"CarkitR PGA\"},\n\t{\"HFL\", NULL, \"HandsfreeL PGA\"},\n\t{\"HFR\", NULL, \"HandsfreeR PGA\"},\n\t{\"Vibra Route\", \"Audio\", \"Vibra Mux\"},\n\t{\"VIBRA\", NULL, \"Vibra Route\"},\n\n\t \n\t \n\t{\"ADC Virtual Left1\", NULL, \"Virtual HiFi IN\"},\n\t{\"ADC Virtual Right1\", NULL, \"Virtual HiFi IN\"},\n\t{\"ADC Virtual Left2\", NULL, \"Virtual HiFi IN\"},\n\t{\"ADC Virtual Right2\", NULL, \"Virtual HiFi IN\"},\n\t \n\t{\"Analog Left\", \"Main Mic Capture Switch\", \"MAINMIC\"},\n\t{\"Analog Left\", \"Headset Mic Capture Switch\", \"HSMIC\"},\n\t{\"Analog Left\", \"AUXL Capture Switch\", \"AUXL\"},\n\t{\"Analog Left\", \"Carkit Mic Capture Switch\", \"CARKITMIC\"},\n\n\t{\"Analog Right\", \"Sub Mic Capture Switch\", \"SUBMIC\"},\n\t{\"Analog Right\", \"AUXR Capture Switch\", \"AUXR\"},\n\n\t{\"ADC Physical Left\", NULL, \"Analog Left\"},\n\t{\"ADC Physical Right\", NULL, \"Analog Right\"},\n\n\t{\"Digimic0 Enable\", NULL, \"DIGIMIC0\"},\n\t{\"Digimic1 Enable\", NULL, \"DIGIMIC1\"},\n\n\t{\"DIGIMIC0\", NULL, \"micbias1 select\"},\n\t{\"DIGIMIC1\", NULL, \"micbias2 select\"},\n\n\t \n\t{\"TX1 Capture Route\", \"Analog\", \"ADC Physical Left\"},\n\t{\"TX1 Capture Route\", \"Digimic0\", \"Digimic0 Enable\"},\n\t \n\t{\"TX1 Capture Route\", \"Analog\", \"ADC Physical Right\"},\n\t{\"TX1 Capture Route\", \"Digimic0\", \"Digimic0 Enable\"},\n\t \n\t{\"TX2 Capture Route\", \"Analog\", \"ADC Physical Left\"},\n\t{\"TX2 Capture Route\", \"Digimic1\", \"Digimic1 Enable\"},\n\t \n\t{\"TX2 Capture Route\", \"Analog\", \"ADC Physical Right\"},\n\t{\"TX2 Capture Route\", \"Digimic1\", \"Digimic1 Enable\"},\n\n\t{\"ADC Virtual Left1\", NULL, \"TX1 Capture Route\"},\n\t{\"ADC Virtual Right1\", NULL, \"TX1 Capture Route\"},\n\t{\"ADC Virtual Left2\", NULL, \"TX2 Capture Route\"},\n\t{\"ADC Virtual Right2\", NULL, \"TX2 Capture Route\"},\n\n\t{\"ADC Virtual Left1\", NULL, \"AIF Enable\"},\n\t{\"ADC Virtual Right1\", NULL, \"AIF Enable\"},\n\t{\"ADC Virtual Left2\", NULL, \"AIF Enable\"},\n\t{\"ADC Virtual Right2\", NULL, \"AIF Enable\"},\n\n\t \n\t{\"Right1 Analog Loopback\", \"Switch\", \"Analog Right\"},\n\t{\"Left1 Analog Loopback\", \"Switch\", \"Analog Left\"},\n\t{\"Right2 Analog Loopback\", \"Switch\", \"Analog Right\"},\n\t{\"Left2 Analog Loopback\", \"Switch\", \"Analog Left\"},\n\t{\"Voice Analog Loopback\", \"Switch\", \"Analog Left\"},\n\n\t \n\t{\"Right1 Analog Loopback\", NULL, \"FM Loop Enable\"},\n\t{\"Left1 Analog Loopback\", NULL, \"FM Loop Enable\"},\n\t{\"Right2 Analog Loopback\", NULL, \"FM Loop Enable\"},\n\t{\"Left2 Analog Loopback\", NULL, \"FM Loop Enable\"},\n\t{\"Voice Analog Loopback\", NULL, \"FM Loop Enable\"},\n\n\t{\"Analog R1 Playback Mixer\", NULL, \"Right1 Analog Loopback\"},\n\t{\"Analog L1 Playback Mixer\", NULL, \"Left1 Analog Loopback\"},\n\t{\"Analog R2 Playback Mixer\", NULL, \"Right2 Analog Loopback\"},\n\t{\"Analog L2 Playback Mixer\", NULL, \"Left2 Analog Loopback\"},\n\t{\"Analog Voice Playback Mixer\", NULL, \"Voice Analog Loopback\"},\n\n\t \n\t{\"Right Digital Loopback\", \"Volume\", \"TX1 Capture Route\"},\n\t{\"Left Digital Loopback\", \"Volume\", \"TX1 Capture Route\"},\n\t{\"Voice Digital Loopback\", \"Volume\", \"TX2 Capture Route\"},\n\n\t{\"Digital R2 Playback Mixer\", NULL, \"Right Digital Loopback\"},\n\t{\"Digital L2 Playback Mixer\", NULL, \"Left Digital Loopback\"},\n\t{\"Digital Voice Playback Mixer\", NULL, \"Voice Digital Loopback\"},\n\n};\n\nstatic int twl4030_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\ttwl4030_codec_enable(component, 1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\ttwl4030_codec_enable(component, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void twl4030_constraints(struct twl4030_priv *twl4030,\n\t\t\t\tstruct snd_pcm_substream *mst_substream)\n{\n\tstruct snd_pcm_substream *slv_substream;\n\n\t \n\tif (mst_substream == twl4030->master_substream)\n\t\tslv_substream = twl4030->slave_substream;\n\telse if (mst_substream == twl4030->slave_substream)\n\t\tslv_substream = twl4030->master_substream;\n\telse  \n\t\treturn;\n\n\t \n\tsnd_pcm_hw_constraint_single(slv_substream->runtime,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\ttwl4030->rate);\n\n\tsnd_pcm_hw_constraint_single(slv_substream->runtime,\n\t\t\t\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\n\t\t\t\ttwl4030->sample_bits);\n\n\tsnd_pcm_hw_constraint_single(slv_substream->runtime,\n\t\t\t\tSNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\ttwl4030->channels);\n}\n\n \nstatic void twl4030_tdm_enable(struct snd_soc_component *component, int direction,\n\t\t\t       int enable)\n{\n\tu8 reg, mask;\n\n\treg = twl4030_read(component, TWL4030_REG_OPTION);\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmask = TWL4030_ARXL1_VRX_EN | TWL4030_ARXR1_EN;\n\telse\n\t\tmask = TWL4030_ATXL2_VTXL_EN | TWL4030_ATXR2_VTXR_EN;\n\n\tif (enable)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\n\ttwl4030_write(component, TWL4030_REG_OPTION, reg);\n}\n\nstatic int twl4030_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tif (twl4030->master_substream) {\n\t\ttwl4030->slave_substream = substream;\n\t\t \n\t\tif (twl4030->configured)\n\t\t\ttwl4030_constraints(twl4030, twl4030->master_substream);\n\t} else {\n\t\tif (!(twl4030_read(component, TWL4030_REG_CODEC_MODE) &\n\t\t\tTWL4030_OPTION_1)) {\n\t\t\t \n\t\t\tsnd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t\t     2);\n\t\t}\n\t\ttwl4030->master_substream = substream;\n\t}\n\n\treturn 0;\n}\n\nstatic void twl4030_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tif (twl4030->master_substream == substream)\n\t\ttwl4030->master_substream = twl4030->slave_substream;\n\n\ttwl4030->slave_substream = NULL;\n\n\t \n\tif (!twl4030->master_substream)\n\t\ttwl4030->configured = 0;\n\t else if (!twl4030->master_substream->runtime->channels)\n\t\ttwl4030->configured = 0;\n\n\t  \n\tif (substream->runtime->channels == 4)\n\t\ttwl4030_tdm_enable(component, substream->stream, 0);\n}\n\nstatic int twl4030_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 mode, old_mode, format, old_format;\n\n\t  \n\tif (params_channels(params) == 4) {\n\t\tformat = twl4030_read(component, TWL4030_REG_AUDIO_IF);\n\t\tmode = twl4030_read(component, TWL4030_REG_CODEC_MODE);\n\n\t\t \n\t\tif ((mode & TWL4030_OPTION_1) &&\n\t\t    ((format & TWL4030_AIF_FORMAT) == TWL4030_AIF_FORMAT_TDM))\n\t\t\ttwl4030_tdm_enable(component, substream->stream, 1);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (twl4030->configured)\n\t\t \n\t\treturn 0;\n\n\t \n\told_mode = twl4030_read(component,\n\t\t\t\tTWL4030_REG_CODEC_MODE) & ~TWL4030_CODECPDZ;\n\tmode = old_mode & ~TWL4030_APLL_RATE;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tmode |= TWL4030_APLL_RATE_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tmode |= TWL4030_APLL_RATE_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tmode |= TWL4030_APLL_RATE_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tmode |= TWL4030_APLL_RATE_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tmode |= TWL4030_APLL_RATE_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tmode |= TWL4030_APLL_RATE_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tmode |= TWL4030_APLL_RATE_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tmode |= TWL4030_APLL_RATE_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tmode |= TWL4030_APLL_RATE_48000;\n\t\tbreak;\n\tcase 96000:\n\t\tmode |= TWL4030_APLL_RATE_96000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: unknown rate %d\\n\", __func__,\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\told_format = twl4030_read(component, TWL4030_REG_AUDIO_IF);\n\tformat = old_format;\n\tformat &= ~TWL4030_DATA_WIDTH;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tformat |= TWL4030_DATA_WIDTH_16S_16W;\n\t\tbreak;\n\tcase 32:\n\t\tformat |= TWL4030_DATA_WIDTH_32S_24W;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: unsupported bits/sample %d\\n\",\n\t\t\t__func__, params_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (format != old_format || mode != old_mode) {\n\t\tif (twl4030->codec_powered) {\n\t\t\t \n\t\t\ttwl4030_codec_enable(component, 0);\n\t\t\ttwl4030_write(component, TWL4030_REG_CODEC_MODE, mode);\n\t\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF, format);\n\t\t\ttwl4030_codec_enable(component, 1);\n\t\t} else {\n\t\t\ttwl4030_write(component, TWL4030_REG_CODEC_MODE, mode);\n\t\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF, format);\n\t\t}\n\t}\n\n\t \n\ttwl4030->configured = 1;\n\ttwl4030->rate = params_rate(params);\n\ttwl4030->sample_bits = hw_param_interval(params,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\n\ttwl4030->channels = params_channels(params);\n\n\t \n\tif (twl4030->slave_substream)\n\t\ttwl4030_constraints(twl4030, substream);\n\n\treturn 0;\n}\n\nstatic int twl4030_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\n\t\t\t\t  unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase 19200000:\n\tcase 26000000:\n\tcase 38400000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported HFCLKIN: %u\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((freq / 1000) != twl4030->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"Mismatch in HFCLKIN: %u (configured: %u)\\n\",\n\t\t\tfreq, twl4030->sysclk * 1000);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 old_format, format;\n\n\t \n\told_format = twl4030_read(component, TWL4030_REG_AUDIO_IF);\n\tformat = old_format;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tformat &= ~(TWL4030_AIF_SLAVE_EN);\n\t\tformat &= ~(TWL4030_CLK256FS_EN);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tformat |= TWL4030_AIF_SLAVE_EN;\n\t\tformat |= TWL4030_CLK256FS_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tformat &= ~TWL4030_AIF_FORMAT;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat |= TWL4030_AIF_FORMAT_CODEC;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat |= TWL4030_AIF_FORMAT_TDM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (format != old_format) {\n\t\tif (twl4030->codec_powered) {\n\t\t\t \n\t\t\ttwl4030_codec_enable(component, 0);\n\t\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF, format);\n\t\t\ttwl4030_codec_enable(component, 1);\n\t\t} else {\n\t\t\ttwl4030_write(component, TWL4030_REG_AUDIO_IF, format);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 reg = twl4030_read(component, TWL4030_REG_AUDIO_IF);\n\n\tif (tristate)\n\t\treg |= TWL4030_AIF_TRI_EN;\n\telse\n\t\treg &= ~TWL4030_AIF_TRI_EN;\n\n\treturn twl4030_write(component, TWL4030_REG_AUDIO_IF, reg);\n}\n\n \nstatic void twl4030_voice_enable(struct snd_soc_component *component, int direction,\n\t\t\t\t int enable)\n{\n\tu8 reg, mask;\n\n\treg = twl4030_read(component, TWL4030_REG_OPTION);\n\n\tif (direction == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmask = TWL4030_ARXL1_VRX_EN;\n\telse\n\t\tmask = TWL4030_ATXL2_VTXL_EN | TWL4030_ATXR2_VTXR_EN;\n\n\tif (enable)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\n\ttwl4030_write(component, TWL4030_REG_OPTION, reg);\n}\n\nstatic int twl4030_voice_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 mode;\n\n\t \n\tif (twl4030->sysclk != 26000) {\n\t\tdev_err(component->dev,\n\t\t\t\"%s: HFCLKIN is %u KHz, voice interface needs 26MHz\\n\",\n\t\t\t__func__, twl4030->sysclk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmode = twl4030_read(component, TWL4030_REG_CODEC_MODE)\n\t\t& TWL4030_OPT_MODE;\n\n\tif (mode != TWL4030_OPTION_2) {\n\t\tdev_err(component->dev, \"%s: the codec mode is not option2\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void twl4030_voice_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\t \n\ttwl4030_voice_enable(component, substream->stream, 0);\n}\n\nstatic int twl4030_voice_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 old_mode, mode;\n\n\t \n\ttwl4030_voice_enable(component, substream->stream, 1);\n\n\t \n\told_mode = twl4030_read(component,\n\t\t\t\tTWL4030_REG_CODEC_MODE) & ~TWL4030_CODECPDZ;\n\tmode = old_mode;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tmode &= ~(TWL4030_SEL_16K);\n\t\tbreak;\n\tcase 16000:\n\t\tmode |= TWL4030_SEL_16K;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: unknown rate %d\\n\", __func__,\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (mode != old_mode) {\n\t\tif (twl4030->codec_powered) {\n\t\t\t \n\t\t\ttwl4030_codec_enable(component, 0);\n\t\t\ttwl4030_write(component, TWL4030_REG_CODEC_MODE, mode);\n\t\t\ttwl4030_codec_enable(component, 1);\n\t\t} else {\n\t\t\ttwl4030_write(component, TWL4030_REG_CODEC_MODE, mode);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_voice_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\n\tif (freq != 26000000) {\n\t\tdev_err(component->dev,\n\t\t\t\"%s: HFCLKIN is %u KHz, voice interface needs 26MHz\\n\",\n\t\t\t__func__, freq / 1000);\n\t\treturn -EINVAL;\n\t}\n\tif ((freq / 1000) != twl4030->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"Mismatch in HFCLKIN: %u (configured: %u)\\n\",\n\t\t\tfreq, twl4030->sysclk * 1000);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int twl4030_voice_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t     unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tu8 old_format, format;\n\n\t \n\told_format = twl4030_read(component, TWL4030_REG_VOICE_IF);\n\tformat = old_format;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tformat &= ~(TWL4030_VIF_SLAVE_EN);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tformat |= TWL4030_VIF_SLAVE_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tformat &= ~(TWL4030_VIF_FORMAT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tformat |= TWL4030_VIF_FORMAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (format != old_format) {\n\t\tif (twl4030->codec_powered) {\n\t\t\t \n\t\t\ttwl4030_codec_enable(component, 0);\n\t\t\ttwl4030_write(component, TWL4030_REG_VOICE_IF, format);\n\t\t\ttwl4030_codec_enable(component, 1);\n\t\t} else {\n\t\t\ttwl4030_write(component, TWL4030_REG_VOICE_IF, format);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int twl4030_voice_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 reg = twl4030_read(component, TWL4030_REG_VOICE_IF);\n\n\tif (tristate)\n\t\treg |= TWL4030_VIF_TRI_EN;\n\telse\n\t\treg &= ~TWL4030_VIF_TRI_EN;\n\n\treturn twl4030_write(component, TWL4030_REG_VOICE_IF, reg);\n}\n\n#define TWL4030_RATES\t (SNDRV_PCM_RATE_8000_48000)\n#define TWL4030_FORMATS\t (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops twl4030_dai_hifi_ops = {\n\t.startup\t= twl4030_startup,\n\t.shutdown\t= twl4030_shutdown,\n\t.hw_params\t= twl4030_hw_params,\n\t.set_sysclk\t= twl4030_set_dai_sysclk,\n\t.set_fmt\t= twl4030_set_dai_fmt,\n\t.set_tristate\t= twl4030_set_tristate,\n};\n\nstatic const struct snd_soc_dai_ops twl4030_dai_voice_ops = {\n\t.startup\t= twl4030_voice_startup,\n\t.shutdown\t= twl4030_voice_shutdown,\n\t.hw_params\t= twl4030_voice_hw_params,\n\t.set_sysclk\t= twl4030_voice_set_dai_sysclk,\n\t.set_fmt\t= twl4030_voice_set_dai_fmt,\n\t.set_tristate\t= twl4030_voice_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver twl4030_dai[] = {\n{\n\t.name = \"twl4030-hifi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 4,\n\t\t.rates = TWL4030_RATES | SNDRV_PCM_RATE_96000,\n\t\t.formats = TWL4030_FORMATS,\n\t\t.sig_bits = 24,},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 4,\n\t\t.rates = TWL4030_RATES,\n\t\t.formats = TWL4030_FORMATS,\n\t\t.sig_bits = 24,},\n\t.ops = &twl4030_dai_hifi_ops,\n},\n{\n\t.name = \"twl4030-voice\",\n\t.playback = {\n\t\t.stream_name = \"Voice Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.stream_name = \"Voice Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &twl4030_dai_voice_ops,\n},\n};\n\nstatic int twl4030_soc_probe(struct snd_soc_component *component)\n{\n\tstruct twl4030_priv *twl4030;\n\n\ttwl4030 = devm_kzalloc(component->dev, sizeof(struct twl4030_priv),\n\t\t\t       GFP_KERNEL);\n\tif (!twl4030)\n\t\treturn -ENOMEM;\n\tsnd_soc_component_set_drvdata(component, twl4030);\n\t \n\ttwl4030->sysclk = twl4030_audio_get_mclk() / 1000;\n\n\ttwl4030_init_chip(component);\n\n\treturn 0;\n}\n\nstatic void twl4030_soc_remove(struct snd_soc_component *component)\n{\n\tstruct twl4030_priv *twl4030 = snd_soc_component_get_drvdata(component);\n\tstruct twl4030_board_params *board_params = twl4030->board_params;\n\n\tif (board_params && board_params->hs_extmute &&\n\t    gpio_is_valid(board_params->hs_extmute_gpio))\n\t\tgpio_free(board_params->hs_extmute_gpio);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_twl4030 = {\n\t.probe\t\t\t= twl4030_soc_probe,\n\t.remove\t\t\t= twl4030_soc_remove,\n\t.read\t\t\t= twl4030_read,\n\t.write\t\t\t= twl4030_write,\n\t.set_bias_level\t\t= twl4030_set_bias_level,\n\t.controls\t\t= twl4030_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(twl4030_snd_controls),\n\t.dapm_widgets\t\t= twl4030_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(twl4030_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int twl4030_codec_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &soc_component_dev_twl4030,\n\t\t\t\t      twl4030_dai, ARRAY_SIZE(twl4030_dai));\n}\n\nMODULE_ALIAS(\"platform:twl4030-codec\");\n\nstatic struct platform_driver twl4030_codec_driver = {\n\t.probe\t\t= twl4030_codec_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"twl4030-codec\",\n\t},\n};\n\nmodule_platform_driver(twl4030_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC TWL4030 codec driver\");\nMODULE_AUTHOR(\"Steve Sakoman\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}