{
  "module_name": "wm9712.c",
  "hash_id": "5a160d80687ff76984d27c1d0251e4aa5da6e6f95605143c9016970d2a9e23a9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm9712.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mfd/wm97xx.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/ac97/codec.h>\n#include <sound/ac97/compat.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define WM9712_VENDOR_ID 0x574d4c12\n#define WM9712_VENDOR_ID_MASK 0xffffffff\n\nstruct wm9712_priv {\n\tstruct snd_ac97 *ac97;\n\tunsigned int hp_mixer[2];\n\tstruct mutex lock;\n\tstruct wm97xx_platform_data *mfd_pdata;\n};\n\nstatic const struct reg_default wm9712_reg_defaults[] = {\n\t{ 0x02, 0x8000 },\n\t{ 0x04, 0x8000 },\n\t{ 0x06, 0x8000 },\n\t{ 0x08, 0x0f0f },\n\t{ 0x0a, 0xaaa0 },\n\t{ 0x0c, 0xc008 },\n\t{ 0x0e, 0x6808 },\n\t{ 0x10, 0xe808 },\n\t{ 0x12, 0xaaa0 },\n\t{ 0x14, 0xad00 },\n\t{ 0x16, 0x8000 },\n\t{ 0x18, 0xe808 },\n\t{ 0x1a, 0x3000 },\n\t{ 0x1c, 0x8000 },\n\t{ 0x20, 0x0000 },\n\t{ 0x22, 0x0000 },\n\t{ 0x26, 0x000f },\n\t{ 0x28, 0x0605 },\n\t{ 0x2a, 0x0410 },\n\t{ 0x2c, 0xbb80 },\n\t{ 0x2e, 0xbb80 },\n\t{ 0x32, 0xbb80 },\n\t{ 0x34, 0x2000 },\n\t{ 0x4c, 0xf83e },\n\t{ 0x4e, 0xffff },\n\t{ 0x50, 0x0000 },\n\t{ 0x52, 0x0000 },\n\t{ 0x56, 0xf83e },\n\t{ 0x58, 0x0008 },\n\t{ 0x5c, 0x0000 },\n\t{ 0x60, 0xb032 },\n\t{ 0x62, 0x3e00 },\n\t{ 0x64, 0x0000 },\n\t{ 0x76, 0x0006 },\n\t{ 0x78, 0x0001 },\n\t{ 0x7a, 0x0000 },\n};\n\nstatic bool wm9712_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AC97_REC_GAIN:\n\t\treturn true;\n\tdefault:\n\t\treturn regmap_ac97_default_volatile(dev, reg);\n\t}\n}\n\nstatic const struct regmap_config wm9712_regmap_config = {\n\t.reg_bits = 16,\n\t.reg_stride = 2,\n\t.val_bits = 16,\n\t.max_register = 0x7e,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm9712_volatile_reg,\n\n\t.reg_defaults = wm9712_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm9712_reg_defaults),\n};\n\n#define HPL_MIXER\t0x0\n#define HPR_MIXER\t0x1\n\nstatic const char *wm9712_alc_select[] = {\"None\", \"Left\", \"Right\", \"Stereo\"};\nstatic const char *wm9712_alc_mux[] = {\"Stereo\", \"Left\", \"Right\", \"None\"};\nstatic const char *wm9712_out3_src[] = {\"Left\", \"VREF\", \"Left + Right\",\n\t\"Mono\"};\nstatic const char *wm9712_spk_src[] = {\"Speaker Mix\", \"Headphone Mix\"};\nstatic const char *wm9712_rec_adc[] = {\"Stereo\", \"Left\", \"Right\", \"Mute\"};\nstatic const char *wm9712_base[] = {\"Linear Control\", \"Adaptive Boost\"};\nstatic const char *wm9712_rec_gain[] = {\"+1.5dB Steps\", \"+0.75dB Steps\"};\nstatic const char *wm9712_mic[] = {\"Mic 1\", \"Differential\", \"Mic 2\",\n\t\"Stereo\"};\nstatic const char *wm9712_rec_sel[] = {\"Mic\", \"NC\", \"NC\", \"Speaker Mixer\",\n\t\"Line\", \"Headphone Mixer\", \"Phone Mixer\", \"Phone\"};\nstatic const char *wm9712_ng_type[] = {\"Constant Gain\", \"Mute\"};\nstatic const char *wm9712_diff_sel[] = {\"Mic\", \"Line\"};\n\nstatic const DECLARE_TLV_DB_SCALE(main_tlv, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, 0, 2000, 0);\n\nstatic const struct soc_enum wm9712_enum[] = {\nSOC_ENUM_SINGLE(AC97_PCI_SVID, 14, 4, wm9712_alc_select),\nSOC_ENUM_SINGLE(AC97_VIDEO, 12, 4, wm9712_alc_mux),\nSOC_ENUM_SINGLE(AC97_AUX, 9, 4, wm9712_out3_src),\nSOC_ENUM_SINGLE(AC97_AUX, 8, 2, wm9712_spk_src),\nSOC_ENUM_SINGLE(AC97_REC_SEL, 12, 4, wm9712_rec_adc),\nSOC_ENUM_SINGLE(AC97_MASTER_TONE, 15, 2, wm9712_base),\nSOC_ENUM_DOUBLE(AC97_REC_GAIN, 14, 6, 2, wm9712_rec_gain),\nSOC_ENUM_SINGLE(AC97_MIC, 5, 4, wm9712_mic),\nSOC_ENUM_SINGLE(AC97_REC_SEL, 8, 8, wm9712_rec_sel),\nSOC_ENUM_SINGLE(AC97_REC_SEL, 0, 8, wm9712_rec_sel),\nSOC_ENUM_SINGLE(AC97_PCI_SVID, 5, 2, wm9712_ng_type),\nSOC_ENUM_SINGLE(0x5c, 8, 2, wm9712_diff_sel),\n};\n\nstatic const struct snd_kcontrol_new wm9712_snd_ac97_controls[] = {\nSOC_DOUBLE(\"Speaker Playback Volume\", AC97_MASTER, 8, 0, 31, 1),\nSOC_SINGLE(\"Speaker Playback Switch\", AC97_MASTER, 15, 1, 1),\nSOC_DOUBLE(\"Headphone Playback Volume\", AC97_HEADPHONE, 8, 0, 31, 1),\nSOC_SINGLE(\"Headphone Playback Switch\", AC97_HEADPHONE, 15, 1, 1),\nSOC_DOUBLE(\"PCM Playback Volume\", AC97_PCM, 8, 0, 31, 1),\n\nSOC_SINGLE(\"Speaker Playback ZC Switch\", AC97_MASTER, 7, 1, 0),\nSOC_SINGLE(\"Speaker Playback Invert Switch\", AC97_MASTER, 6, 1, 0),\nSOC_SINGLE(\"Headphone Playback ZC Switch\", AC97_HEADPHONE, 7, 1, 0),\nSOC_SINGLE(\"Mono Playback ZC Switch\", AC97_MASTER_MONO, 7, 1, 0),\nSOC_SINGLE(\"Mono Playback Volume\", AC97_MASTER_MONO, 0, 31, 1),\nSOC_SINGLE(\"Mono Playback Switch\", AC97_MASTER_MONO, 15, 1, 1),\n\nSOC_SINGLE(\"ALC Target Volume\", AC97_CODEC_CLASS_REV, 12, 15, 0),\nSOC_SINGLE(\"ALC Hold Time\", AC97_CODEC_CLASS_REV, 8, 15, 0),\nSOC_SINGLE(\"ALC Decay Time\", AC97_CODEC_CLASS_REV, 4, 15, 0),\nSOC_SINGLE(\"ALC Attack Time\", AC97_CODEC_CLASS_REV, 0, 15, 0),\nSOC_ENUM(\"ALC Function\", wm9712_enum[0]),\nSOC_SINGLE(\"ALC Max Volume\", AC97_PCI_SVID, 11, 7, 0),\nSOC_SINGLE(\"ALC ZC Timeout\", AC97_PCI_SVID, 9, 3, 1),\nSOC_SINGLE(\"ALC ZC Switch\", AC97_PCI_SVID, 8, 1, 0),\nSOC_SINGLE(\"ALC NG Switch\", AC97_PCI_SVID, 7, 1, 0),\nSOC_ENUM(\"ALC NG Type\", wm9712_enum[10]),\nSOC_SINGLE(\"ALC NG Threshold\", AC97_PCI_SVID, 0, 31, 1),\n\nSOC_SINGLE(\"Mic Headphone  Volume\", AC97_VIDEO, 12, 7, 1),\nSOC_SINGLE(\"ALC Headphone Volume\", AC97_VIDEO, 7, 7, 1),\n\nSOC_SINGLE(\"Out3 Switch\", AC97_AUX, 15, 1, 1),\nSOC_SINGLE(\"Out3 ZC Switch\", AC97_AUX, 7, 1, 1),\nSOC_SINGLE(\"Out3 Volume\", AC97_AUX, 0, 31, 1),\n\nSOC_SINGLE(\"PCBeep Bypass Headphone Volume\", AC97_PC_BEEP, 12, 7, 1),\nSOC_SINGLE(\"PCBeep Bypass Speaker Volume\", AC97_PC_BEEP, 8, 7, 1),\nSOC_SINGLE(\"PCBeep Bypass Phone Volume\", AC97_PC_BEEP, 4, 7, 1),\n\nSOC_SINGLE(\"Aux Playback Headphone Volume\", AC97_CD, 12, 7, 1),\nSOC_SINGLE(\"Aux Playback Speaker Volume\", AC97_CD, 8, 7, 1),\nSOC_SINGLE(\"Aux Playback Phone Volume\", AC97_CD, 4, 7, 1),\n\nSOC_SINGLE(\"Phone Volume\", AC97_PHONE, 0, 15, 1),\nSOC_DOUBLE(\"Line Capture Volume\", AC97_LINE, 8, 0, 31, 1),\n\nSOC_SINGLE_TLV(\"Capture Boost Switch\", AC97_REC_SEL, 14, 1, 0, boost_tlv),\nSOC_SINGLE_TLV(\"Capture to Phone Boost Switch\", AC97_REC_SEL, 11, 1, 1,\n\t       boost_tlv),\n\nSOC_SINGLE(\"3D Upper Cut-off Switch\", AC97_3D_CONTROL, 5, 1, 1),\nSOC_SINGLE(\"3D Lower Cut-off Switch\", AC97_3D_CONTROL, 4, 1, 1),\nSOC_SINGLE(\"3D Playback Volume\", AC97_3D_CONTROL, 0, 15, 0),\n\nSOC_ENUM(\"Bass Control\", wm9712_enum[5]),\nSOC_SINGLE(\"Bass Cut-off Switch\", AC97_MASTER_TONE, 12, 1, 1),\nSOC_SINGLE(\"Tone Cut-off Switch\", AC97_MASTER_TONE, 4, 1, 1),\nSOC_SINGLE(\"Playback Attenuate (-6dB) Switch\", AC97_MASTER_TONE, 6, 1, 0),\nSOC_SINGLE(\"Bass Volume\", AC97_MASTER_TONE, 8, 15, 1),\nSOC_SINGLE(\"Treble Volume\", AC97_MASTER_TONE, 0, 15, 1),\n\nSOC_SINGLE(\"Capture Switch\", AC97_REC_GAIN, 15, 1, 1),\nSOC_ENUM(\"Capture Volume Steps\", wm9712_enum[6]),\nSOC_DOUBLE(\"Capture Volume\", AC97_REC_GAIN, 8, 0, 63, 0),\nSOC_SINGLE(\"Capture ZC Switch\", AC97_REC_GAIN, 7, 1, 0),\n\nSOC_SINGLE_TLV(\"Mic 1 Volume\", AC97_MIC, 8, 31, 1, main_tlv),\nSOC_SINGLE_TLV(\"Mic 2 Volume\", AC97_MIC, 0, 31, 1, main_tlv),\nSOC_SINGLE_TLV(\"Mic Boost Volume\", AC97_MIC, 7, 1, 0, boost_tlv),\n};\n\nstatic const unsigned int wm9712_mixer_mute_regs[] = {\n\tAC97_VIDEO,\n\tAC97_PCM,\n\tAC97_LINE,\n\tAC97_PHONE,\n\tAC97_CD,\n\tAC97_PC_BEEP,\n};\n\n \nstatic int wm9712_hp_mixer_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(dapm);\n\tstruct wm9712_priv *wm9712 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = ucontrol->value.integer.value[0];\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int mixer, mask, shift, old;\n\tstruct snd_soc_dapm_update update = {};\n\tbool change;\n\n\tmixer = mc->shift >> 8;\n\tshift = mc->shift & 0xff;\n\tmask = 1 << shift;\n\n\tmutex_lock(&wm9712->lock);\n\told = wm9712->hp_mixer[mixer];\n\tif (ucontrol->value.integer.value[0])\n\t\twm9712->hp_mixer[mixer] |= mask;\n\telse\n\t\twm9712->hp_mixer[mixer] &= ~mask;\n\n\tchange = old != wm9712->hp_mixer[mixer];\n\tif (change) {\n\t\tupdate.kcontrol = kcontrol;\n\t\tupdate.reg = wm9712_mixer_mute_regs[shift];\n\t\tupdate.mask = 0x8000;\n\t\tif ((wm9712->hp_mixer[0] & mask) ||\n\t\t    (wm9712->hp_mixer[1] & mask))\n\t\t\tupdate.val = 0x0;\n\t\telse\n\t\t\tupdate.val = 0x8000;\n\n\t\tsnd_soc_dapm_mixer_update_power(dapm, kcontrol, val,\n\t\t\t&update);\n\t}\n\n\tmutex_unlock(&wm9712->lock);\n\n\treturn change;\n}\n\nstatic int wm9712_hp_mixer_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(dapm);\n\tstruct wm9712_priv *wm9712 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int shift, mixer;\n\n\tmixer = mc->shift >> 8;\n\tshift = mc->shift & 0xff;\n\n\tucontrol->value.integer.value[0] =\n\t\t(wm9712->hp_mixer[mixer] >> shift) & 1;\n\n\treturn 0;\n}\n\n#define WM9712_HP_MIXER_CTRL(xname, xmixer, xshift) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = wm9712_hp_mixer_get, .put = wm9712_hp_mixer_put, \\\n\t.private_value = SOC_SINGLE_VALUE(SND_SOC_NOPM, \\\n\t\t(xmixer << 8) | xshift, 1, 0, 0) \\\n}\n\n \nstatic const struct snd_kcontrol_new wm9712_hpl_mixer_controls[] = {\n\tWM9712_HP_MIXER_CTRL(\"PCBeep Bypass Switch\", HPL_MIXER, 5),\n\tWM9712_HP_MIXER_CTRL(\"Aux Playback Switch\", HPL_MIXER, 4),\n\tWM9712_HP_MIXER_CTRL(\"Phone Bypass Switch\", HPL_MIXER, 3),\n\tWM9712_HP_MIXER_CTRL(\"Line Bypass Switch\", HPL_MIXER, 2),\n\tWM9712_HP_MIXER_CTRL(\"PCM Playback Switch\", HPL_MIXER, 1),\n\tWM9712_HP_MIXER_CTRL(\"Mic Sidetone Switch\", HPL_MIXER, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm9712_hpr_mixer_controls[] = {\n\tWM9712_HP_MIXER_CTRL(\"PCBeep Bypass Switch\", HPR_MIXER, 5),\n\tWM9712_HP_MIXER_CTRL(\"Aux Playback Switch\", HPR_MIXER, 4),\n\tWM9712_HP_MIXER_CTRL(\"Phone Bypass Switch\", HPR_MIXER, 3),\n\tWM9712_HP_MIXER_CTRL(\"Line Bypass Switch\", HPR_MIXER, 2),\n\tWM9712_HP_MIXER_CTRL(\"PCM Playback Switch\", HPR_MIXER, 1),\n\tWM9712_HP_MIXER_CTRL(\"Mic Sidetone Switch\", HPR_MIXER, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm9712_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PCBeep Bypass Switch\", AC97_PC_BEEP, 11, 1, 1),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", AC97_CD, 11, 1, 1),\n\tSOC_DAPM_SINGLE(\"Phone Bypass Switch\", AC97_PHONE, 14, 1, 1),\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", AC97_LINE, 14, 1, 1),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", AC97_PCM, 14, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new wm9712_phone_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PCBeep Bypass Switch\", AC97_PC_BEEP, 7, 1, 1),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", AC97_CD, 7, 1, 1),\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", AC97_LINE, 13, 1, 1),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", AC97_PCM, 13, 1, 1),\n\tSOC_DAPM_SINGLE(\"Mic 1 Sidetone Switch\", AC97_MIC, 14, 1, 1),\n\tSOC_DAPM_SINGLE(\"Mic 2 Sidetone Switch\", AC97_MIC, 13, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new wm9712_alc_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[1]);\n\n \nstatic const struct snd_kcontrol_new wm9712_out3_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[2]);\n\n \nstatic const struct snd_kcontrol_new wm9712_spk_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[3]);\n\n \nstatic const struct snd_kcontrol_new wm9712_capture_phone_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[4]);\n\n \nstatic const struct snd_kcontrol_new wm9712_capture_selectl_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[8]);\n\n \nstatic const struct snd_kcontrol_new wm9712_capture_selectr_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[9]);\n\n \nstatic const struct snd_kcontrol_new wm9712_mic_src_controls =\nSOC_DAPM_ENUM(\"Mic Source Select\", wm9712_enum[7]);\n\n \nstatic const struct snd_kcontrol_new wm9712_diff_sel_controls =\nSOC_DAPM_ENUM(\"Route\", wm9712_enum[11]);\n\nstatic const struct snd_soc_dapm_widget wm9712_dapm_widgets[] = {\nSND_SOC_DAPM_MUX(\"ALC Sidetone Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_alc_mux_controls),\nSND_SOC_DAPM_MUX(\"Out3 Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_out3_mux_controls),\nSND_SOC_DAPM_MUX(\"Speaker Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_spk_mux_controls),\nSND_SOC_DAPM_MUX(\"Capture Phone Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_capture_phone_mux_controls),\nSND_SOC_DAPM_MUX(\"Left Capture Select\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_capture_selectl_controls),\nSND_SOC_DAPM_MUX(\"Right Capture Select\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_capture_selectr_controls),\nSND_SOC_DAPM_MUX(\"Left Mic Select Source\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_mic_src_controls),\nSND_SOC_DAPM_MUX(\"Right Mic Select Source\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_mic_src_controls),\nSND_SOC_DAPM_MUX(\"Differential Source\", SND_SOC_NOPM, 0, 0,\n\t&wm9712_diff_sel_controls),\nSND_SOC_DAPM_MIXER(\"AC97 Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_MIXER(\"Left HP Mixer\", AC97_INT_PAGING, 9, 1,\n\t&wm9712_hpl_mixer_controls[0], ARRAY_SIZE(wm9712_hpl_mixer_controls)),\nSND_SOC_DAPM_MIXER(\"Right HP Mixer\", AC97_INT_PAGING, 8, 1,\n\t&wm9712_hpr_mixer_controls[0], ARRAY_SIZE(wm9712_hpr_mixer_controls)),\nSND_SOC_DAPM_MIXER(\"Phone Mixer\", AC97_INT_PAGING, 6, 1,\n\t&wm9712_phone_mixer_controls[0], ARRAY_SIZE(wm9712_phone_mixer_controls)),\nSND_SOC_DAPM_MIXER(\"Speaker Mixer\", AC97_INT_PAGING, 7, 1,\n\t&wm9712_speaker_mixer_controls[0],\n\tARRAY_SIZE(wm9712_speaker_mixer_controls)),\nSND_SOC_DAPM_MIXER(\"Mono Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_DAC(\"Left DAC\", \"Left HiFi Playback\", AC97_INT_PAGING, 14, 1),\nSND_SOC_DAPM_DAC(\"Right DAC\", \"Right HiFi Playback\", AC97_INT_PAGING, 13, 1),\nSND_SOC_DAPM_DAC(\"Aux DAC\", \"Aux Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_ADC(\"Left ADC\", \"Left HiFi Capture\", AC97_INT_PAGING, 12, 1),\nSND_SOC_DAPM_ADC(\"Right ADC\", \"Right HiFi Capture\", AC97_INT_PAGING, 11, 1),\nSND_SOC_DAPM_PGA(\"Headphone PGA\", AC97_INT_PAGING, 4, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Speaker PGA\", AC97_INT_PAGING, 3, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Out 3 PGA\", AC97_INT_PAGING, 5, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Line PGA\", AC97_INT_PAGING, 2, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Phone PGA\", AC97_INT_PAGING, 1, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Mic PGA\", AC97_INT_PAGING, 0, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Differential Mic\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_MICBIAS(\"Mic Bias\", AC97_INT_PAGING, 10, 1),\nSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\nSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\nSND_SOC_DAPM_OUTPUT(\"OUT3\"),\nSND_SOC_DAPM_INPUT(\"LINEINL\"),\nSND_SOC_DAPM_INPUT(\"LINEINR\"),\nSND_SOC_DAPM_INPUT(\"PHONE\"),\nSND_SOC_DAPM_INPUT(\"PCBEEP\"),\nSND_SOC_DAPM_INPUT(\"MIC1\"),\nSND_SOC_DAPM_INPUT(\"MIC2\"),\n};\n\nstatic const struct snd_soc_dapm_route wm9712_audio_map[] = {\n\t \n\t{\"AC97 Mixer\", NULL, \"Left DAC\"},\n\t{\"AC97 Mixer\", NULL, \"Right DAC\"},\n\n\t \n\t{\"Left HP Mixer\", \"PCBeep Bypass Switch\", \"PCBEEP\"},\n\t{\"Left HP Mixer\", \"Aux Playback Switch\",  \"Aux DAC\"},\n\t{\"Left HP Mixer\", \"Phone Bypass Switch\",  \"Phone PGA\"},\n\t{\"Left HP Mixer\", \"Line Bypass Switch\",   \"Line PGA\"},\n\t{\"Left HP Mixer\", \"PCM Playback Switch\",  \"Left DAC\"},\n\t{\"Left HP Mixer\", \"Mic Sidetone Switch\",  \"Mic PGA\"},\n\t{\"Left HP Mixer\", NULL,  \"ALC Sidetone Mux\"},\n\n\t \n\t{\"Right HP Mixer\", \"PCBeep Bypass Switch\", \"PCBEEP\"},\n\t{\"Right HP Mixer\", \"Aux Playback Switch\",  \"Aux DAC\"},\n\t{\"Right HP Mixer\", \"Phone Bypass Switch\",  \"Phone PGA\"},\n\t{\"Right HP Mixer\", \"Line Bypass Switch\",   \"Line PGA\"},\n\t{\"Right HP Mixer\", \"PCM Playback Switch\",  \"Right DAC\"},\n\t{\"Right HP Mixer\", \"Mic Sidetone Switch\",  \"Mic PGA\"},\n\t{\"Right HP Mixer\", NULL,  \"ALC Sidetone Mux\"},\n\n\t \n\t{\"Speaker Mixer\", \"PCBeep Bypass Switch\", \"PCBEEP\"},\n\t{\"Speaker Mixer\", \"Line Bypass Switch\",   \"Line PGA\"},\n\t{\"Speaker Mixer\", \"PCM Playback Switch\",  \"AC97 Mixer\"},\n\t{\"Speaker Mixer\", \"Phone Bypass Switch\",  \"Phone PGA\"},\n\t{\"Speaker Mixer\", \"Aux Playback Switch\",  \"Aux DAC\"},\n\n\t \n\t{\"Phone Mixer\", \"PCBeep Bypass Switch\",  \"PCBEEP\"},\n\t{\"Phone Mixer\", \"Line Bypass Switch\",    \"Line PGA\"},\n\t{\"Phone Mixer\", \"Aux Playback Switch\",   \"Aux DAC\"},\n\t{\"Phone Mixer\", \"PCM Playback Switch\",   \"AC97 Mixer\"},\n\t{\"Phone Mixer\", \"Mic 1 Sidetone Switch\", \"Mic PGA\"},\n\t{\"Phone Mixer\", \"Mic 2 Sidetone Switch\", \"Mic PGA\"},\n\n\t \n\t{\"Line PGA\", NULL, \"LINEINL\"},\n\t{\"Line PGA\", NULL, \"LINEINR\"},\n\t{\"Phone PGA\", NULL, \"PHONE\"},\n\t{\"Mic PGA\", NULL, \"MIC1\"},\n\t{\"Mic PGA\", NULL, \"MIC2\"},\n\n\t \n\t{\"Differential Mic\", NULL, \"MIC1\"},\n\t{\"Differential Mic\", NULL, \"MIC2\"},\n\t{\"Left Mic Select Source\", \"Mic 1\", \"MIC1\"},\n\t{\"Left Mic Select Source\", \"Mic 2\", \"MIC2\"},\n\t{\"Left Mic Select Source\", \"Stereo\", \"MIC1\"},\n\t{\"Left Mic Select Source\", \"Differential\", \"Differential Mic\"},\n\t{\"Right Mic Select Source\", \"Mic 1\", \"MIC1\"},\n\t{\"Right Mic Select Source\", \"Mic 2\", \"MIC2\"},\n\t{\"Right Mic Select Source\", \"Stereo\", \"MIC2\"},\n\t{\"Right Mic Select Source\", \"Differential\", \"Differential Mic\"},\n\n\t \n\t{\"Left Capture Select\", \"Mic\", \"MIC1\"},\n\t{\"Left Capture Select\", \"Speaker Mixer\", \"Speaker Mixer\"},\n\t{\"Left Capture Select\", \"Line\", \"LINEINL\"},\n\t{\"Left Capture Select\", \"Headphone Mixer\", \"Left HP Mixer\"},\n\t{\"Left Capture Select\", \"Phone Mixer\", \"Phone Mixer\"},\n\t{\"Left Capture Select\", \"Phone\", \"PHONE\"},\n\n\t \n\t{\"Right Capture Select\", \"Mic\", \"MIC2\"},\n\t{\"Right Capture Select\", \"Speaker Mixer\", \"Speaker Mixer\"},\n\t{\"Right Capture Select\", \"Line\", \"LINEINR\"},\n\t{\"Right Capture Select\", \"Headphone Mixer\", \"Right HP Mixer\"},\n\t{\"Right Capture Select\", \"Phone Mixer\", \"Phone Mixer\"},\n\t{\"Right Capture Select\", \"Phone\", \"PHONE\"},\n\n\t \n\t{\"ALC Sidetone Mux\", \"Stereo\", \"Left Capture Select\"},\n\t{\"ALC Sidetone Mux\", \"Stereo\", \"Right Capture Select\"},\n\t{\"ALC Sidetone Mux\", \"Left\", \"Left Capture Select\"},\n\t{\"ALC Sidetone Mux\", \"Right\", \"Right Capture Select\"},\n\n\t \n\t{\"Left ADC\", NULL, \"Left Capture Select\"},\n\t{\"Right ADC\", NULL, \"Right Capture Select\"},\n\n\t \n\t{\"MONOOUT\", NULL, \"Phone Mixer\"},\n\t{\"HPOUTL\", NULL, \"Headphone PGA\"},\n\t{\"Headphone PGA\", NULL, \"Left HP Mixer\"},\n\t{\"HPOUTR\", NULL, \"Headphone PGA\"},\n\t{\"Headphone PGA\", NULL, \"Right HP Mixer\"},\n\n\t \n\t{\"Mono Mixer\", NULL, \"Left HP Mixer\"},\n\t{\"Mono Mixer\", NULL, \"Right HP Mixer\"},\n\n\t \n\t{\"Out3 Mux\", \"Left\", \"Left HP Mixer\"},\n\t{\"Out3 Mux\", \"Mono\", \"Phone Mixer\"},\n\t{\"Out3 Mux\", \"Left + Right\", \"Mono Mixer\"},\n\t{\"Out 3 PGA\", NULL, \"Out3 Mux\"},\n\t{\"OUT3\", NULL, \"Out 3 PGA\"},\n\n\t \n\t{\"Speaker Mux\", \"Speaker Mix\", \"Speaker Mixer\"},\n\t{\"Speaker Mux\", \"Headphone Mix\", \"Mono Mixer\"},\n\t{\"Speaker PGA\", NULL, \"Speaker Mux\"},\n\t{\"LOUT2\", NULL, \"Speaker PGA\"},\n\t{\"ROUT2\", NULL, \"Speaker PGA\"},\n};\n\nstatic int ac97_prepare(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint reg;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_soc_component_update_bits(component, AC97_EXTENDED_STATUS, 0x1, 0x1);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treg = AC97_PCM_FRONT_DAC_RATE;\n\telse\n\t\treg = AC97_PCM_LR_ADC_RATE;\n\n\treturn snd_soc_component_write(component, reg, runtime->rate);\n}\n\nstatic int ac97_aux_prepare(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tsnd_soc_component_update_bits(component, AC97_EXTENDED_STATUS, 0x1, 0x1);\n\tsnd_soc_component_update_bits(component, AC97_PCI_SID, 0x8000, 0x8000);\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -ENODEV;\n\n\treturn snd_soc_component_write(component, AC97_PCM_SURR_DAC_RATE, runtime->rate);\n}\n\n#define WM9712_AC97_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_44100 |\\\n\t\tSNDRV_PCM_RATE_48000)\n\nstatic const struct snd_soc_dai_ops wm9712_dai_ops_hifi = {\n\t.prepare\t= ac97_prepare,\n};\n\nstatic const struct snd_soc_dai_ops wm9712_dai_ops_aux = {\n\t.prepare\t= ac97_aux_prepare,\n};\n\nstatic struct snd_soc_dai_driver wm9712_dai[] = {\n{\n\t.name = \"wm9712-hifi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM9712_AC97_RATES,\n\t\t.formats = SND_SOC_STD_AC97_FMTS,},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM9712_AC97_RATES,\n\t\t.formats = SND_SOC_STD_AC97_FMTS,},\n\t.ops = &wm9712_dai_ops_hifi,\n},\n{\n\t.name = \"wm9712-aux\",\n\t.playback = {\n\t\t.stream_name = \"Aux Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = WM9712_AC97_RATES,\n\t\t.formats = SND_SOC_STD_AC97_FMTS,},\n\t.ops = &wm9712_dai_ops_aux,\n}\n};\n\nstatic int wm9712_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_write(component, AC97_POWERDOWN, 0x0000);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_write(component, AC97_EXTENDED_MSTATUS, 0xffff);\n\t\tsnd_soc_component_write(component, AC97_POWERDOWN, 0xffff);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int wm9712_soc_resume(struct snd_soc_component *component)\n{\n\tstruct wm9712_priv *wm9712 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_ac97_reset(wm9712->ac97, true, WM9712_VENDOR_ID,\n\t\tWM9712_VENDOR_ID_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\tif (ret == 0)\n\t\tsnd_soc_component_cache_sync(component);\n\n\treturn ret;\n}\n\nstatic int wm9712_soc_probe(struct snd_soc_component *component)\n{\n\tstruct wm9712_priv *wm9712 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *regmap;\n\n\tif (wm9712->mfd_pdata) {\n\t\twm9712->ac97 = wm9712->mfd_pdata->ac97;\n\t\tregmap = wm9712->mfd_pdata->regmap;\n\t} else if (IS_ENABLED(CONFIG_SND_SOC_AC97_BUS)) {\n\t\tint ret;\n\n\t\twm9712->ac97 = snd_soc_new_ac97_component(component, WM9712_VENDOR_ID,\n\t\t\t\t\t\t      WM9712_VENDOR_ID_MASK);\n\t\tif (IS_ERR(wm9712->ac97)) {\n\t\t\tret = PTR_ERR(wm9712->ac97);\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to register AC97 codec: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tregmap = regmap_init_ac97(wm9712->ac97, &wm9712_regmap_config);\n\t\tif (IS_ERR(regmap)) {\n\t\t\tsnd_soc_free_ac97_component(wm9712->ac97);\n\t\t\treturn PTR_ERR(regmap);\n\t\t}\n\t} else {\n\t\treturn -ENXIO;\n\t}\n\n\tsnd_soc_component_init_regmap(component, regmap);\n\n\t \n\tsnd_soc_component_update_bits(component, AC97_VIDEO, 0x3000, 0x3000);\n\n\treturn 0;\n}\n\nstatic void wm9712_soc_remove(struct snd_soc_component *component)\n{\n\tstruct wm9712_priv *wm9712 = snd_soc_component_get_drvdata(component);\n\n\tif (IS_ENABLED(CONFIG_SND_SOC_AC97_BUS) && !wm9712->mfd_pdata) {\n\t\tsnd_soc_component_exit_regmap(component);\n\t\tsnd_soc_free_ac97_component(wm9712->ac97);\n\t}\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm9712 = {\n\t.probe\t\t\t= wm9712_soc_probe,\n\t.remove\t\t\t= wm9712_soc_remove,\n\t.resume\t\t\t= wm9712_soc_resume,\n\t.set_bias_level\t\t= wm9712_set_bias_level,\n\t.controls\t\t= wm9712_snd_ac97_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm9712_snd_ac97_controls),\n\t.dapm_widgets\t\t= wm9712_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm9712_dapm_widgets),\n\t.dapm_routes\t\t= wm9712_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm9712_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm9712_probe(struct platform_device *pdev)\n{\n\tstruct wm9712_priv *wm9712;\n\n\twm9712 = devm_kzalloc(&pdev->dev, sizeof(*wm9712), GFP_KERNEL);\n\tif (wm9712 == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wm9712->lock);\n\n\twm9712->mfd_pdata = dev_get_platdata(&pdev->dev);\n\tplatform_set_drvdata(pdev, wm9712);\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_component_dev_wm9712, wm9712_dai, ARRAY_SIZE(wm9712_dai));\n}\n\nstatic struct platform_driver wm9712_component_driver = {\n\t.driver = {\n\t\t.name = \"wm9712-codec\",\n\t},\n\n\t.probe = wm9712_probe,\n};\n\nmodule_platform_driver(wm9712_component_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM9711/WM9712 driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}