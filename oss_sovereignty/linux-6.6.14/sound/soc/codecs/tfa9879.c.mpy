{
  "module_name": "tfa9879.c",
  "hash_id": "0f67113a0fe9d0e78cf662872f40fa385b5e69933a2a354e79642db64e5c726c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tfa9879.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/pcm_params.h>\n\n#include \"tfa9879.h\"\n\nstruct tfa9879_priv {\n\tstruct regmap *regmap;\n\tint lsb_justified;\n};\n\nstatic int tfa9879_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tfa9879_priv *tfa9879 = snd_soc_component_get_drvdata(component);\n\tint fs;\n\tint i2s_set = 0;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tfs = TFA9879_I2S_FS_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tfs = TFA9879_I2S_FS_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tfs = TFA9879_I2S_FS_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tfs = TFA9879_I2S_FS_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tfs = TFA9879_I2S_FS_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tfs = TFA9879_I2S_FS_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tfs = TFA9879_I2S_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tfs = TFA9879_I2S_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tfs = TFA9879_I2S_FS_48000;\n\t\tbreak;\n\tcase 64000:\n\t\tfs = TFA9879_I2S_FS_64000;\n\t\tbreak;\n\tcase 88200:\n\t\tfs = TFA9879_I2S_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tfs = TFA9879_I2S_FS_96000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\ti2s_set = TFA9879_I2S_SET_LSB_J_16;\n\t\tbreak;\n\tcase 24:\n\t\ti2s_set = TFA9879_I2S_SET_LSB_J_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tfa9879->lsb_justified)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t      TFA9879_SERIAL_INTERFACE_1,\n\t\t\t\t\t      TFA9879_I2S_SET_MASK,\n\t\t\t\t\t      i2s_set << TFA9879_I2S_SET_SHIFT);\n\n\tsnd_soc_component_update_bits(component, TFA9879_SERIAL_INTERFACE_1,\n\t\t\t\t      TFA9879_I2S_FS_MASK,\n\t\t\t\t      fs << TFA9879_I2S_FS_SHIFT);\n\treturn 0;\n}\n\nstatic int tfa9879_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tsnd_soc_component_update_bits(component, TFA9879_MISC_CONTROL,\n\t\t\t\t      TFA9879_S_MUTE_MASK,\n\t\t\t\t      !!mute << TFA9879_S_MUTE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int tfa9879_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tfa9879_priv *tfa9879 = snd_soc_component_get_drvdata(component);\n\tint i2s_set;\n\tint sck_pol;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tsck_pol = TFA9879_SCK_POL_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tsck_pol = TFA9879_SCK_POL_INVERSE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\ttfa9879->lsb_justified = 0;\n\t\ti2s_set = TFA9879_I2S_SET_I2S_24;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ttfa9879->lsb_justified = 0;\n\t\ti2s_set = TFA9879_I2S_SET_MSB_J_24;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\ttfa9879->lsb_justified = 1;\n\t\ti2s_set = TFA9879_I2S_SET_LSB_J_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, TFA9879_SERIAL_INTERFACE_1,\n\t\t\t\t      TFA9879_SCK_POL_MASK,\n\t\t\t\t      sck_pol << TFA9879_SCK_POL_SHIFT);\n\tsnd_soc_component_update_bits(component, TFA9879_SERIAL_INTERFACE_1,\n\t\t\t\t      TFA9879_I2S_SET_MASK,\n\t\t\t\t      i2s_set << TFA9879_I2S_SET_SHIFT);\n\treturn 0;\n}\n\nstatic const struct reg_default tfa9879_regs[] = {\n\t{ TFA9879_DEVICE_CONTROL,\t0x0000 },  \n\t{ TFA9879_SERIAL_INTERFACE_1,\t0x0a18 },  \n\t{ TFA9879_PCM_IOM2_FORMAT_1,\t0x0007 },  \n\t{ TFA9879_SERIAL_INTERFACE_2,\t0x0a18 },  \n\t{ TFA9879_PCM_IOM2_FORMAT_2,\t0x0007 },  \n\t{ TFA9879_EQUALIZER_A1,\t\t0x59dd },  \n\t{ TFA9879_EQUALIZER_A2,\t\t0xc63e },  \n\t{ TFA9879_EQUALIZER_B1,\t\t0x651a },  \n\t{ TFA9879_EQUALIZER_B2,\t\t0xe53e },  \n\t{ TFA9879_EQUALIZER_C1,\t\t0x4616 },  \n\t{ TFA9879_EQUALIZER_C2,\t\t0xd33e },  \n\t{ TFA9879_EQUALIZER_D1,\t\t0x4df3 },  \n\t{ TFA9879_EQUALIZER_D2,\t\t0xea3e },  \n\t{ TFA9879_EQUALIZER_E1,\t\t0x5ee0 },  \n\t{ TFA9879_EQUALIZER_E2,\t\t0xf93e },  \n\t{ TFA9879_BYPASS_CONTROL,\t0x0093 },  \n\t{ TFA9879_DYNAMIC_RANGE_COMPR,\t0x92ba },  \n\t{ TFA9879_BASS_TREBLE,\t\t0x12a5 },  \n\t{ TFA9879_HIGH_PASS_FILTER,\t0x0004 },  \n\t{ TFA9879_VOLUME_CONTROL,\t0x10bd },  \n\t{ TFA9879_MISC_CONTROL,\t\t0x0000 },  \n};\n\nstatic bool tfa9879_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == TFA9879_MISC_STATUS;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(volume_tlv, -7050, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(tb_gain_tlv, -1800, 200, 0);\nstatic const char * const tb_freq_text[] = {\n\t\"Low\", \"Mid\", \"High\"\n};\nstatic const struct soc_enum treble_freq_enum =\n\tSOC_ENUM_SINGLE(TFA9879_BASS_TREBLE, TFA9879_F_TRBLE_SHIFT,\n\t\t\tARRAY_SIZE(tb_freq_text), tb_freq_text);\nstatic const struct soc_enum bass_freq_enum =\n\tSOC_ENUM_SINGLE(TFA9879_BASS_TREBLE, TFA9879_F_BASS_SHIFT,\n\t\t\tARRAY_SIZE(tb_freq_text), tb_freq_text);\n\nstatic const struct snd_kcontrol_new tfa9879_controls[] = {\n\tSOC_SINGLE_TLV(\"PCM Playback Volume\", TFA9879_VOLUME_CONTROL,\n\t\t       TFA9879_VOL_SHIFT, 0xbd, 1, volume_tlv),\n\tSOC_SINGLE_TLV(\"Treble Volume\", TFA9879_BASS_TREBLE,\n\t\t       TFA9879_G_TRBLE_SHIFT, 18, 0, tb_gain_tlv),\n\tSOC_SINGLE_TLV(\"Bass Volume\", TFA9879_BASS_TREBLE,\n\t\t       TFA9879_G_BASS_SHIFT, 18, 0, tb_gain_tlv),\n\tSOC_ENUM(\"Treble Corner Freq\", treble_freq_enum),\n\tSOC_ENUM(\"Bass Corner Freq\", bass_freq_enum),\n};\n\nstatic const struct snd_soc_dapm_widget tfa9879_dapm_widgets[] = {\nSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_DAC(\"DAC\", NULL, TFA9879_DEVICE_CONTROL, TFA9879_OPMODE_SHIFT, 0),\nSND_SOC_DAPM_OUTPUT(\"LINEOUT\"),\nSND_SOC_DAPM_SUPPLY(\"POWER\", TFA9879_DEVICE_CONTROL, TFA9879_POWERUP_SHIFT, 0,\n\t\t    NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route tfa9879_dapm_routes[] = {\n\t{ \"DAC\", NULL, \"AIFINL\" },\n\t{ \"DAC\", NULL, \"AIFINR\" },\n\n\t{ \"LINEOUT\", NULL, \"DAC\" },\n\n\t{ \"DAC\", NULL, \"POWER\" },\n};\n\nstatic const struct snd_soc_component_driver tfa9879_component = {\n\t.controls\t\t= tfa9879_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tfa9879_controls),\n\t.dapm_widgets\t\t= tfa9879_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tfa9879_dapm_widgets),\n\t.dapm_routes\t\t= tfa9879_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tfa9879_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config tfa9879_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.volatile_reg = tfa9879_volatile_reg,\n\t.max_register = TFA9879_MISC_STATUS,\n\t.reg_defaults = tfa9879_regs,\n\t.num_reg_defaults = ARRAY_SIZE(tfa9879_regs),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct snd_soc_dai_ops tfa9879_dai_ops = {\n\t.hw_params = tfa9879_hw_params,\n\t.mute_stream = tfa9879_mute_stream,\n\t.set_fmt = tfa9879_set_fmt,\n\t.no_capture_mute = 1,\n};\n\n#define TFA9879_RATES SNDRV_PCM_RATE_8000_96000\n\n#define TFA9879_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver tfa9879_dai = {\n\t.name = \"tfa9879-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = TFA9879_RATES,\n\t\t.formats = TFA9879_FORMATS, },\n\t.ops = &tfa9879_dai_ops,\n};\n\nstatic int tfa9879_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct tfa9879_priv *tfa9879;\n\tint i;\n\n\ttfa9879 = devm_kzalloc(&i2c->dev, sizeof(*tfa9879), GFP_KERNEL);\n\tif (!tfa9879)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, tfa9879);\n\n\ttfa9879->regmap = devm_regmap_init_i2c(i2c, &tfa9879_regmap);\n\tif (IS_ERR(tfa9879->regmap))\n\t\treturn PTR_ERR(tfa9879->regmap);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tfa9879_regs); i++)\n\t\tregmap_write(tfa9879->regmap,\n\t\t\t     tfa9879_regs[i].reg, tfa9879_regs[i].def);\n\n\treturn devm_snd_soc_register_component(&i2c->dev, &tfa9879_component,\n\t\t\t\t\t       &tfa9879_dai, 1);\n}\n\nstatic const struct i2c_device_id tfa9879_i2c_id[] = {\n\t{ \"tfa9879\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tfa9879_i2c_id);\n\nstatic const struct of_device_id tfa9879_of_match[] = {\n\t{ .compatible = \"nxp,tfa9879\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tfa9879_of_match);\n\nstatic struct i2c_driver tfa9879_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tfa9879\",\n\t\t.of_match_table = tfa9879_of_match,\n\t},\n\t.probe = tfa9879_i2c_probe,\n\t.id_table = tfa9879_i2c_id,\n};\n\nmodule_i2c_driver(tfa9879_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC NXP Semiconductors TFA9879 driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}