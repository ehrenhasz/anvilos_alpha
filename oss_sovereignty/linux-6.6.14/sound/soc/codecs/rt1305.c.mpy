{
  "module_name": "rt1305.c",
  "hash_id": "7d3cbb3021b66a01cff03680b94ac84ecc71abc0f9c005b2ab677b516a869211",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1305.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rl6231.h\"\n#include \"rt1305.h\"\n\n\n#define RT1305_PR_RANGE_BASE (0xff + 1)\n#define RT1305_PR_SPACING 0x100\n\n#define RT1305_PR_BASE (RT1305_PR_RANGE_BASE + (0 * RT1305_PR_SPACING))\n\n\nstatic const struct regmap_range_cfg rt1305_ranges[] = {\n\t{\n\t\t.name = \"PR\",\n\t\t.range_min = RT1305_PR_BASE,\n\t\t.range_max = RT1305_PR_BASE + 0xff,\n\t\t.selector_reg = RT1305_PRIV_INDEX,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0x0,\n\t\t.window_start = RT1305_PRIV_DATA,\n\t\t.window_len = 0x1,\n\t},\n};\n\n\nstatic const struct reg_sequence init_list[] = {\n\n\t{ RT1305_PR_BASE + 0xcf, 0x5548 },\n\t{ RT1305_PR_BASE + 0x5d, 0x0442 },\n\t{ RT1305_PR_BASE + 0xc1, 0x0320 },\n\n\t{ RT1305_POWER_STATUS, 0x0000 },\n\n\t{ RT1305_SPK_TEMP_PROTECTION_1, 0xd6de },\n\t{ RT1305_SPK_TEMP_PROTECTION_2, 0x0707 },\n\t{ RT1305_SPK_TEMP_PROTECTION_3, 0x4090 },\n\n\t{ RT1305_DAC_SET_1, 0xdfdf },\t \n\t{ RT1305_ADC_SET_3, 0x0219 },\n\t{ RT1305_ADC_SET_1, 0x170f },\t \n\n};\n#define RT1305_INIT_REG_LEN ARRAY_SIZE(init_list)\n\nstruct rt1305_priv {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\n\tint sysclk;\n\tint sysclk_src;\n\tint lrck;\n\tint bclk;\n\tint master;\n\n\tint pll_src;\n\tint pll_in;\n\tint pll_out;\n};\n\nstatic const struct reg_default rt1305_reg[] = {\n\n\t{ 0x04, 0x0400 },\n\t{ 0x05, 0x0880 },\n\t{ 0x06, 0x0000 },\n\t{ 0x07, 0x3100 },\n\t{ 0x08, 0x8000 },\n\t{ 0x09, 0x0000 },\n\t{ 0x0a, 0x087e },\n\t{ 0x0b, 0x0020 },\n\t{ 0x0c, 0x0802 },\n\t{ 0x0d, 0x0020 },\n\t{ 0x10, 0x1d1d },\n\t{ 0x11, 0x1d1d },\n\t{ 0x12, 0xffff },\n\t{ 0x14, 0x000c },\n\t{ 0x16, 0x1717 },\n\t{ 0x17, 0x4000 },\n\t{ 0x18, 0x0019 },\n\t{ 0x20, 0x0000 },\n\t{ 0x22, 0x0000 },\n\t{ 0x24, 0x0000 },\n\t{ 0x26, 0x0000 },\n\t{ 0x28, 0x0000 },\n\t{ 0x2a, 0x4000 },\n\t{ 0x2b, 0x3000 },\n\t{ 0x2d, 0x6000 },\n\t{ 0x2e, 0x0000 },\n\t{ 0x2f, 0x8000 },\n\t{ 0x32, 0x0000 },\n\t{ 0x39, 0x0001 },\n\t{ 0x3a, 0x0000 },\n\t{ 0x3b, 0x1020 },\n\t{ 0x3c, 0x0000 },\n\t{ 0x3d, 0x0000 },\n\t{ 0x3e, 0x4c00 },\n\t{ 0x3f, 0x3000 },\n\t{ 0x40, 0x000c },\n\t{ 0x42, 0x0400 },\n\t{ 0x46, 0xc22c },\n\t{ 0x47, 0x0000 },\n\t{ 0x4b, 0x0000 },\n\t{ 0x4c, 0x0300 },\n\t{ 0x4f, 0xf000 },\n\t{ 0x50, 0xc200 },\n\t{ 0x51, 0x1f1f },\n\t{ 0x52, 0x01f0 },\n\t{ 0x53, 0x407f },\n\t{ 0x54, 0xffff },\n\t{ 0x58, 0x4005 },\n\t{ 0x5e, 0x0000 },\n\t{ 0x5f, 0x0000 },\n\t{ 0x60, 0xee13 },\n\t{ 0x62, 0x0000 },\n\t{ 0x63, 0x5f5f },\n\t{ 0x64, 0x0040 },\n\t{ 0x65, 0x4000 },\n\t{ 0x66, 0x4004 },\n\t{ 0x67, 0x0306 },\n\t{ 0x68, 0x8c04 },\n\t{ 0x69, 0xe021 },\n\t{ 0x6a, 0x0000 },\n\t{ 0x6c, 0xaaaa },\n\t{ 0x70, 0x0333 },\n\t{ 0x71, 0x3330 },\n\t{ 0x72, 0x3333 },\n\t{ 0x73, 0x3300 },\n\t{ 0x74, 0x0000 },\n\t{ 0x75, 0x0000 },\n\t{ 0x76, 0x0000 },\n\t{ 0x7a, 0x0003 },\n\t{ 0x7c, 0x10ec },\n\t{ 0x7e, 0x6251 },\n\t{ 0x80, 0x0800 },\n\t{ 0x81, 0x4000 },\n\t{ 0x82, 0x0000 },\n\t{ 0x90, 0x7a01 },\n\t{ 0x91, 0x8431 },\n\t{ 0x92, 0x0180 },\n\t{ 0x93, 0x0000 },\n\t{ 0x94, 0x0000 },\n\t{ 0x95, 0x0000 },\n\t{ 0x96, 0x0000 },\n\t{ 0x97, 0x0000 },\n\t{ 0x98, 0x0000 },\n\t{ 0x99, 0x0000 },\n\t{ 0x9a, 0x0000 },\n\t{ 0x9b, 0x0000 },\n\t{ 0x9c, 0x0000 },\n\t{ 0x9d, 0x0000 },\n\t{ 0x9e, 0x0000 },\n\t{ 0x9f, 0x0000 },\n\t{ 0xa0, 0x0000 },\n\t{ 0xb0, 0x8200 },\n\t{ 0xb1, 0x00ff },\n\t{ 0xb2, 0x0008 },\n\t{ 0xc0, 0x0200 },\n\t{ 0xc1, 0x0000 },\n\t{ 0xc2, 0x0000 },\n\t{ 0xc3, 0x0000 },\n\t{ 0xc4, 0x0000 },\n\t{ 0xc5, 0x0000 },\n\t{ 0xc6, 0x0000 },\n\t{ 0xc7, 0x0000 },\n\t{ 0xc8, 0x0000 },\n\t{ 0xc9, 0x0000 },\n\t{ 0xca, 0x0200 },\n\t{ 0xcb, 0x0000 },\n\t{ 0xcc, 0x0000 },\n\t{ 0xcd, 0x0000 },\n\t{ 0xce, 0x0000 },\n\t{ 0xcf, 0x0000 },\n\t{ 0xd0, 0x0000 },\n\t{ 0xd1, 0x0000 },\n\t{ 0xd2, 0x0000 },\n\t{ 0xd3, 0x0000 },\n\t{ 0xd4, 0x0200 },\n\t{ 0xd5, 0x0000 },\n\t{ 0xd6, 0x0000 },\n\t{ 0xd7, 0x0000 },\n\t{ 0xd8, 0x0000 },\n\t{ 0xd9, 0x0000 },\n\t{ 0xda, 0x0000 },\n\t{ 0xdb, 0x0000 },\n\t{ 0xdc, 0x0000 },\n\t{ 0xdd, 0x0000 },\n\t{ 0xde, 0x0200 },\n\t{ 0xdf, 0x0000 },\n\t{ 0xe0, 0x0000 },\n\t{ 0xe1, 0x0000 },\n\t{ 0xe2, 0x0000 },\n\t{ 0xe3, 0x0000 },\n\t{ 0xe4, 0x0000 },\n\t{ 0xe5, 0x0000 },\n\t{ 0xe6, 0x0000 },\n\t{ 0xe7, 0x0000 },\n\t{ 0xe8, 0x0200 },\n\t{ 0xe9, 0x0000 },\n\t{ 0xea, 0x0000 },\n\t{ 0xeb, 0x0000 },\n\t{ 0xec, 0x0000 },\n\t{ 0xed, 0x0000 },\n\t{ 0xee, 0x0000 },\n\t{ 0xef, 0x0000 },\n\t{ 0xf0, 0x0000 },\n\t{ 0xf1, 0x0000 },\n\t{ 0xf2, 0x0200 },\n\t{ 0xf3, 0x0000 },\n\t{ 0xf4, 0x0000 },\n\t{ 0xf5, 0x0000 },\n\t{ 0xf6, 0x0000 },\n\t{ 0xf7, 0x0000 },\n\t{ 0xf8, 0x0000 },\n\t{ 0xf9, 0x0000 },\n\t{ 0xfa, 0x0000 },\n\t{ 0xfb, 0x0000 },\n};\n\nstatic int rt1305_reg_init(struct snd_soc_component *component)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\tregmap_multi_reg_write(rt1305->regmap, init_list, RT1305_INIT_REG_LEN);\n\treturn 0;\n}\n\nstatic bool rt1305_volatile_register(struct device *dev, unsigned int reg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rt1305_ranges); i++) {\n\t\tif (reg >= rt1305_ranges[i].range_min &&\n\t\t\treg <= rt1305_ranges[i].range_max) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tswitch (reg) {\n\tcase RT1305_RESET:\n\tcase RT1305_SPDIF_IN_SET_1:\n\tcase RT1305_SPDIF_IN_SET_2:\n\tcase RT1305_SPDIF_IN_SET_3:\n\tcase RT1305_POWER_CTRL_2:\n\tcase RT1305_CLOCK_DETECT:\n\tcase RT1305_BIQUAD_SET_1:\n\tcase RT1305_BIQUAD_SET_2:\n\tcase RT1305_EQ_SET_2:\n\tcase RT1305_SPK_TEMP_PROTECTION_0:\n\tcase RT1305_SPK_TEMP_PROTECTION_2:\n\tcase RT1305_SPK_DC_DETECT_1:\n\tcase RT1305_SILENCE_DETECT:\n\tcase RT1305_VERSION_ID:\n\tcase RT1305_VENDOR_ID:\n\tcase RT1305_DEVICE_ID:\n\tcase RT1305_EFUSE_1:\n\tcase RT1305_EFUSE_3:\n\tcase RT1305_DC_CALIB_1:\n\tcase RT1305_DC_CALIB_3:\n\tcase RT1305_DAC_OFFSET_1:\n\tcase RT1305_DAC_OFFSET_2:\n\tcase RT1305_DAC_OFFSET_3:\n\tcase RT1305_DAC_OFFSET_4:\n\tcase RT1305_DAC_OFFSET_5:\n\tcase RT1305_DAC_OFFSET_6:\n\tcase RT1305_DAC_OFFSET_7:\n\tcase RT1305_DAC_OFFSET_8:\n\tcase RT1305_DAC_OFFSET_9:\n\tcase RT1305_DAC_OFFSET_10:\n\tcase RT1305_DAC_OFFSET_11:\n\tcase RT1305_TRIM_1:\n\tcase RT1305_TRIM_2:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1305_readable_register(struct device *dev, unsigned int reg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rt1305_ranges); i++) {\n\t\tif (reg >= rt1305_ranges[i].range_min &&\n\t\t\treg <= rt1305_ranges[i].range_max) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tswitch (reg) {\n\tcase RT1305_RESET:\n\tcase RT1305_CLK_1 ... RT1305_CAL_EFUSE_CLOCK:\n\tcase RT1305_PLL0_1 ... RT1305_PLL1_2:\n\tcase RT1305_MIXER_CTRL_1:\n\tcase RT1305_MIXER_CTRL_2:\n\tcase RT1305_DAC_SET_1:\n\tcase RT1305_DAC_SET_2:\n\tcase RT1305_ADC_SET_1:\n\tcase RT1305_ADC_SET_2:\n\tcase RT1305_ADC_SET_3:\n\tcase RT1305_PATH_SET:\n\tcase RT1305_SPDIF_IN_SET_1:\n\tcase RT1305_SPDIF_IN_SET_2:\n\tcase RT1305_SPDIF_IN_SET_3:\n\tcase RT1305_SPDIF_OUT_SET_1:\n\tcase RT1305_SPDIF_OUT_SET_2:\n\tcase RT1305_SPDIF_OUT_SET_3:\n\tcase RT1305_I2S_SET_1:\n\tcase RT1305_I2S_SET_2:\n\tcase RT1305_PBTL_MONO_MODE_SRC:\n\tcase RT1305_MANUALLY_I2C_DEVICE:\n\tcase RT1305_POWER_STATUS:\n\tcase RT1305_POWER_CTRL_1:\n\tcase RT1305_POWER_CTRL_2:\n\tcase RT1305_POWER_CTRL_3:\n\tcase RT1305_POWER_CTRL_4:\n\tcase RT1305_POWER_CTRL_5:\n\tcase RT1305_CLOCK_DETECT:\n\tcase RT1305_BIQUAD_SET_1:\n\tcase RT1305_BIQUAD_SET_2:\n\tcase RT1305_ADJUSTED_HPF_1:\n\tcase RT1305_ADJUSTED_HPF_2:\n\tcase RT1305_EQ_SET_1:\n\tcase RT1305_EQ_SET_2:\n\tcase RT1305_SPK_TEMP_PROTECTION_0:\n\tcase RT1305_SPK_TEMP_PROTECTION_1:\n\tcase RT1305_SPK_TEMP_PROTECTION_2:\n\tcase RT1305_SPK_TEMP_PROTECTION_3:\n\tcase RT1305_SPK_DC_DETECT_1:\n\tcase RT1305_SPK_DC_DETECT_2:\n\tcase RT1305_LOUDNESS:\n\tcase RT1305_THERMAL_FOLD_BACK_1:\n\tcase RT1305_THERMAL_FOLD_BACK_2:\n\tcase RT1305_SILENCE_DETECT ... RT1305_SPK_EXCURSION_LIMITER_7:\n\tcase RT1305_VERSION_ID:\n\tcase RT1305_VENDOR_ID:\n\tcase RT1305_DEVICE_ID:\n\tcase RT1305_EFUSE_1:\n\tcase RT1305_EFUSE_2:\n\tcase RT1305_EFUSE_3:\n\tcase RT1305_DC_CALIB_1:\n\tcase RT1305_DC_CALIB_2:\n\tcase RT1305_DC_CALIB_3:\n\tcase RT1305_DAC_OFFSET_1 ... RT1305_DAC_OFFSET_14:\n\tcase RT1305_TRIM_1:\n\tcase RT1305_TRIM_2:\n\tcase RT1305_TUNE_INTERNAL_OSC:\n\tcase RT1305_BIQUAD1_H0_L_28_16 ... RT1305_BIQUAD3_A2_R_15_0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9435, 37, 0);\n\nstatic const char * const rt1305_rx_data_ch_select[] = {\n\t\"LR\",\n\t\"RL\",\n\t\"Copy L\",\n\t\"Copy R\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1305_rx_data_ch_enum, RT1305_I2S_SET_2, 2,\n\trt1305_rx_data_ch_select);\n\nstatic void rt1305_reset(struct regmap *regmap)\n{\n\tregmap_write(regmap, RT1305_RESET, 0);\n}\n\nstatic const struct snd_kcontrol_new rt1305_snd_controls[] = {\n\tSOC_DOUBLE_TLV(\"DAC Playback Volume\", RT1305_DAC_SET_1,\n\t\t\t8, 0, 0xff, 0, dac_vol_tlv),\n\n\t \n\tSOC_ENUM(\"RX Channel Select\", rt1305_rx_data_ch_enum),\n};\n\nstatic int rt1305_is_rc_clk_from_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, RT1305_CLK_1);\n\n\tif (rt1305->sysclk_src == RT1305_FS_SYS_PRE_S_PLL1 &&\n\t\t(val & RT1305_SEL_PLL_SRC_2_RCCLK))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int rt1305_is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\tif (rt1305->sysclk_src == RT1305_FS_SYS_PRE_S_PLL1)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int rt1305_classd_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, RT1305_POWER_CTRL_1,\n\t\t\tRT1305_POW_PDB_JD_MASK, RT1305_POW_PDB_JD);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, RT1305_POWER_CTRL_1,\n\t\t\tRT1305_POW_PDB_JD_MASK, 0);\n\t\tusleep_range(150000, 200000);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new rt1305_sto_dac_l =\n\tSOC_DAPM_SINGLE(\"Switch\", RT1305_DAC_SET_2,\n\t\tRT1305_DVOL_MUTE_L_EN_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new rt1305_sto_dac_r =\n\tSOC_DAPM_SINGLE(\"Switch\", RT1305_DAC_SET_2,\n\t\tRT1305_DVOL_MUTE_R_EN_SFT, 1, 1);\n\nstatic const struct snd_soc_dapm_widget rt1305_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"PLL0\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_PLL0_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL1\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_PLL1_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MBIAS\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_MBIAS_LV_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"BG MBIAS\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_BG_MBIAS_LV_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"LDO2\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_LDO2_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"BG2\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_BG2_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"LDO2 IB2\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_LDO2_IB2_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VREF\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_VREF_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VREF1\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_VREF1_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VREF2\", RT1305_POWER_CTRL_1,\n\t\tRT1305_POW_VREF2_BIT, 0, NULL, 0),\n\n\n\tSND_SOC_DAPM_SUPPLY(\"DISC VREF\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_DISC_VREF_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"FASTB VREF\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_FASTB_VREF_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ULTRA FAST VREF\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_ULTRA_FAST_VREF_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CHOP DAC\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_CKXEN_DAC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CKGEN DAC\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_EN_CKGEN_DAC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CLAMP\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_CLAMP_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"BUFL\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_BUFL_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"BUFR\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_BUFR_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CKGEN ADC\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_EN_CKGEN_ADC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC3 L\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_ADC3_L_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC3 R\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_ADC3_R_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"TRIOSC\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_TRIOSC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"AVDD1\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POR_AVDD1_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"AVDD2\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POR_AVDD2_BIT, 0, NULL, 0),\n\n\n\tSND_SOC_DAPM_SUPPLY(\"VSENSE R\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_VSENSE_RCH_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VSENSE L\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_VSENSE_LCH_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ISENSE R\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_ISENSE_RCH_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ISENSE L\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_ISENSE_LCH_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"POR AVDD1\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_POR_AVDD1_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"POR AVDD2\", RT1305_POWER_CTRL_3,\n\t\tRT1305_POW_POR_AVDD2_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VCM 6172\", RT1305_POWER_CTRL_3,\n\t\tRT1305_EN_VCM_6172_BIT, 0, NULL, 0),\n\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RX\", \"AIF1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"DAC L Power\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_DAC1_L_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAC R Power\", RT1305_POWER_CTRL_2,\n\t\tRT1305_POW_DAC1_R_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SWITCH(\"DAC L\", SND_SOC_NOPM, 0, 0, &rt1305_sto_dac_l),\n\tSND_SOC_DAPM_SWITCH(\"DAC R\", SND_SOC_NOPM, 0, 0, &rt1305_sto_dac_r),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"CLASS D\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt1305_classd_event,\n\t\tSND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1305_dapm_routes[] = {\n\n\t{ \"DAC\", NULL, \"AIF1RX\" },\n\n\t{ \"DAC\", NULL, \"PLL0\", rt1305_is_rc_clk_from_pll },\n\t{ \"DAC\", NULL, \"PLL1\", rt1305_is_sys_clk_from_pll },\n\n\t{ \"DAC\", NULL, \"MBIAS\" },\n\t{ \"DAC\", NULL, \"BG MBIAS\" },\n\t{ \"DAC\", NULL, \"LDO2\" },\n\t{ \"DAC\", NULL, \"BG2\" },\n\t{ \"DAC\", NULL, \"LDO2 IB2\" },\n\t{ \"DAC\", NULL, \"VREF\" },\n\t{ \"DAC\", NULL, \"VREF1\" },\n\t{ \"DAC\", NULL, \"VREF2\" },\n\n\t{ \"DAC\", NULL, \"DISC VREF\" },\n\t{ \"DAC\", NULL, \"FASTB VREF\" },\n\t{ \"DAC\", NULL, \"ULTRA FAST VREF\" },\n\t{ \"DAC\", NULL, \"CHOP DAC\" },\n\t{ \"DAC\", NULL, \"CKGEN DAC\" },\n\t{ \"DAC\", NULL, \"CLAMP\" },\n\t{ \"DAC\", NULL, \"CKGEN ADC\" },\n\t{ \"DAC\", NULL, \"TRIOSC\" },\n\t{ \"DAC\", NULL, \"AVDD1\" },\n\t{ \"DAC\", NULL, \"AVDD2\" },\n\n\t{ \"DAC\", NULL, \"POR AVDD1\" },\n\t{ \"DAC\", NULL, \"POR AVDD2\" },\n\t{ \"DAC\", NULL, \"VCM 6172\" },\n\n\t{ \"DAC L\", \"Switch\", \"DAC\" },\n\t{ \"DAC R\", \"Switch\", \"DAC\" },\n\n\t{ \"DAC R\", NULL, \"VSENSE R\" },\n\t{ \"DAC L\", NULL, \"VSENSE L\" },\n\t{ \"DAC R\", NULL, \"ISENSE R\" },\n\t{ \"DAC L\", NULL, \"ISENSE L\" },\n\t{ \"DAC L\", NULL, \"ADC3 L\" },\n\t{ \"DAC R\", NULL, \"ADC3 R\" },\n\t{ \"DAC L\", NULL, \"BUFL\" },\n\t{ \"DAC R\", NULL, \"BUFR\" },\n\t{ \"DAC L\", NULL, \"DAC L Power\" },\n\t{ \"DAC R\", NULL, \"DAC R Power\" },\n\n\t{ \"CLASS D\", NULL, \"DAC L\" },\n\t{ \"CLASS D\", NULL, \"DAC R\" },\n\n\t{ \"SPOL\", NULL, \"CLASS D\" },\n\t{ \"SPOR\", NULL, \"CLASS D\" },\n};\n\nstatic int rt1305_get_clk_info(int sclk, int rate)\n{\n\tint i;\n\tstatic const int pd[] = {1, 2, 3, 4, 6, 8, 12, 16};\n\n\tif (sclk <= 0 || rate <= 0)\n\t\treturn -EINVAL;\n\n\trate = rate << 8;\n\tfor (i = 0; i < ARRAY_SIZE(pd); i++)\n\t\tif (sclk == rate * pd[i])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int rt1305_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0, val_clk, mask_clk;\n\tint pre_div, bclk_ms, frame_size;\n\n\trt1305->lrck = params_rate(params);\n\tpre_div = rt1305_get_clk_info(rt1305->sysclk, rt1305->lrck);\n\tif (pre_div < 0) {\n\t\tdev_warn(component->dev, \"Force using PLL \");\n\t\tsnd_soc_dai_set_pll(dai, 0, RT1305_PLL1_S_BCLK,\n\t\t\trt1305->lrck * 64, rt1305->lrck * 256);\n\t\tsnd_soc_dai_set_sysclk(dai, RT1305_FS_SYS_PRE_S_PLL1,\n\t\t\trt1305->lrck * 256, SND_SOC_CLOCK_IN);\n\t\tpre_div = 0;\n\t}\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0) {\n\t\tdev_err(component->dev, \"Unsupported frame size: %d\\n\",\n\t\t\tframe_size);\n\t\treturn -EINVAL;\n\t}\n\n\tbclk_ms = frame_size > 32;\n\trt1305->bclk = rt1305->lrck * (32 << bclk_ms);\n\n\tdev_dbg(component->dev, \"bclk_ms is %d and pre_div is %d for iis %d\\n\",\n\t\t\t\tbclk_ms, pre_div, dai->id);\n\n\tdev_dbg(component->dev, \"lrck is %dHz and pre_div is %d for iis %d\\n\",\n\t\t\t\trt1305->lrck, pre_div, dai->id);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= RT1305_I2S_DL_SEL_16B;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= RT1305_I2S_DL_SEL_20B;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= RT1305_I2S_DL_SEL_24B;\n\t\tbreak;\n\tcase 8:\n\t\tval_len |= RT1305_I2S_DL_SEL_8B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dai->id) {\n\tcase RT1305_AIF1:\n\t\tmask_clk = RT1305_DIV_FS_SYS_MASK;\n\t\tval_clk = pre_div << RT1305_DIV_FS_SYS_SFT;\n\t\tsnd_soc_component_update_bits(component, RT1305_I2S_SET_2,\n\t\t\tRT1305_I2S_DL_SEL_MASK,\n\t\t\tval_len);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid dai->id: %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1305_CLK_2,\n\t\tmask_clk, val_clk);\n\n\treturn 0;\n}\n\nstatic int rt1305_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0, reg1_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\treg_val |= RT1305_SEL_I2S_OUT_MODE_M;\n\t\trt1305->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\treg_val |= RT1305_SEL_I2S_OUT_MODE_S;\n\t\trt1305->master = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg1_val |= RT1305_I2S_BCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg1_val |= RT1305_I2S_DF_SEL_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg1_val |= RT1305_I2S_DF_SEL_PCM_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\treg1_val |= RT1305_I2S_DF_SEL_PCM_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dai->id) {\n\tcase RT1305_AIF1:\n\t\tsnd_soc_component_update_bits(component, RT1305_I2S_SET_1,\n\t\t\tRT1305_SEL_I2S_OUT_MODE_MASK, reg_val);\n\t\tsnd_soc_component_update_bits(component, RT1305_I2S_SET_2,\n\t\t\tRT1305_I2S_DF_SEL_MASK | RT1305_I2S_BCLK_MASK,\n\t\t\treg1_val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid dai->id: %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int rt1305_set_component_sysclk(struct snd_soc_component *component,\n\t\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tif (freq == rt1305->sysclk && clk_id == rt1305->sysclk_src)\n\t\treturn 0;\n\n\tswitch (clk_id) {\n\tcase RT1305_FS_SYS_PRE_S_MCLK:\n\t\treg_val |= RT1305_SEL_FS_SYS_PRE_MCLK;\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1305_CLOCK_DETECT, RT1305_SEL_CLK_DET_SRC_MASK,\n\t\t\tRT1305_SEL_CLK_DET_SRC_MCLK);\n\t\tbreak;\n\tcase RT1305_FS_SYS_PRE_S_PLL1:\n\t\treg_val |= RT1305_SEL_FS_SYS_PRE_PLL;\n\t\tbreak;\n\tcase RT1305_FS_SYS_PRE_S_RCCLK:\n\t\treg_val |= RT1305_SEL_FS_SYS_PRE_RCCLK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, RT1305_CLK_1,\n\t\tRT1305_SEL_FS_SYS_PRE_MASK, reg_val);\n\trt1305->sysclk = freq;\n\trt1305->sysclk_src = clk_id;\n\n\tdev_dbg(component->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq, clk_id);\n\n\treturn 0;\n}\n\nstatic int rt1305_set_component_pll(struct snd_soc_component *component,\n\t\tint pll_id, int source, unsigned int freq_in,\n\t\tunsigned int freq_out)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\tstruct rl6231_pll_code pll_code;\n\tint ret;\n\n\tif (source == rt1305->pll_src && freq_in == rt1305->pll_in &&\n\t    freq_out == rt1305->pll_out)\n\t\treturn 0;\n\n\tif (!freq_in || !freq_out) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\n\t\trt1305->pll_in = 0;\n\t\trt1305->pll_out = 0;\n\t\tsnd_soc_component_update_bits(component, RT1305_CLK_1,\n\t\t\tRT1305_SEL_FS_SYS_PRE_MASK | RT1305_SEL_PLL_SRC_1_MASK,\n\t\t\tRT1305_SEL_FS_SYS_PRE_PLL | RT1305_SEL_PLL_SRC_1_BCLK);\n\t\treturn 0;\n\t}\n\n\tswitch (source) {\n\tcase RT1305_PLL2_S_MCLK:\n\t\tsnd_soc_component_update_bits(component, RT1305_CLK_1,\n\t\t\tRT1305_SEL_PLL_SRC_2_MASK | RT1305_SEL_PLL_SRC_1_MASK |\n\t\t\tRT1305_DIV_PLL_SRC_2_MASK,\n\t\t\tRT1305_SEL_PLL_SRC_2_MCLK | RT1305_SEL_PLL_SRC_1_PLL2);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1305_CLOCK_DETECT, RT1305_SEL_CLK_DET_SRC_MASK,\n\t\t\tRT1305_SEL_CLK_DET_SRC_MCLK);\n\t\tbreak;\n\tcase RT1305_PLL1_S_BCLK:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1305_CLK_1, RT1305_SEL_PLL_SRC_1_MASK,\n\t\t\tRT1305_SEL_PLL_SRC_1_BCLK);\n\t\tbreak;\n\tcase RT1305_PLL2_S_RCCLK:\n\t\tsnd_soc_component_update_bits(component, RT1305_CLK_1,\n\t\t\tRT1305_SEL_PLL_SRC_2_MASK | RT1305_SEL_PLL_SRC_1_MASK |\n\t\t\tRT1305_DIV_PLL_SRC_2_MASK,\n\t\t\tRT1305_SEL_PLL_SRC_2_RCCLK | RT1305_SEL_PLL_SRC_1_PLL2);\n\t\tfreq_in = 98304000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown PLL Source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"bypass=%d m=%d n=%d k=%d\\n\",\n\t\tpll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\n\t\tpll_code.n_code, pll_code.k_code);\n\n\tsnd_soc_component_write(component, RT1305_PLL1_1,\n\t\t((pll_code.m_bp ? 0 : pll_code.m_code) << RT1305_PLL_1_M_SFT) |\n\t\t(pll_code.m_bp << RT1305_PLL_1_M_BYPASS_SFT) |\n\t\tpll_code.n_code);\n\tsnd_soc_component_write(component, RT1305_PLL1_2,\n\t\tpll_code.k_code);\n\n\trt1305->pll_in = freq_in;\n\trt1305->pll_out = freq_out;\n\trt1305->pll_src = source;\n\n\treturn 0;\n}\n\nstatic int rt1305_probe(struct snd_soc_component *component)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\trt1305->component = component;\n\n\t \n\trt1305_reg_init(component);\n\n\treturn 0;\n}\n\nstatic void rt1305_remove(struct snd_soc_component *component)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\trt1305_reset(rt1305->regmap);\n}\n\n#ifdef CONFIG_PM\nstatic int rt1305_suspend(struct snd_soc_component *component)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1305->regmap, true);\n\tregcache_mark_dirty(rt1305->regmap);\n\n\treturn 0;\n}\n\nstatic int rt1305_resume(struct snd_soc_component *component)\n{\n\tstruct rt1305_priv *rt1305 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1305->regmap, false);\n\tregcache_sync(rt1305->regmap);\n\n\treturn 0;\n}\n#else\n#define rt1305_suspend NULL\n#define rt1305_resume NULL\n#endif\n\n#define RT1305_STEREO_RATES SNDRV_PCM_RATE_8000_192000\n#define RT1305_FORMATS (SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops rt1305_aif_dai_ops = {\n\t.hw_params = rt1305_hw_params,\n\t.set_fmt = rt1305_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver rt1305_dai[] = {\n\t{\n\t\t.name = \"rt1305-aif\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1305_STEREO_RATES,\n\t\t\t.formats = RT1305_FORMATS,\n\t\t},\n\t\t.ops = &rt1305_aif_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt1305 = {\n\t.probe = rt1305_probe,\n\t.remove = rt1305_remove,\n\t.suspend = rt1305_suspend,\n\t.resume = rt1305_resume,\n\t.controls = rt1305_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1305_snd_controls),\n\t.dapm_widgets = rt1305_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1305_dapm_widgets),\n\t.dapm_routes = rt1305_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1305_dapm_routes),\n\t.set_sysclk = rt1305_set_component_sysclk,\n\t.set_pll = rt1305_set_component_pll,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt1305_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = RT1305_MAX_REG + 1 + (ARRAY_SIZE(rt1305_ranges) *\n\t\t\t\t\t       RT1305_PR_SPACING),\n\t.volatile_reg = rt1305_volatile_register,\n\t.readable_reg = rt1305_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = rt1305_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt1305_reg),\n\t.ranges = rt1305_ranges,\n\t.num_ranges = ARRAY_SIZE(rt1305_ranges),\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id rt1305_of_match[] = {\n\t{ .compatible = \"realtek,rt1305\", },\n\t{ .compatible = \"realtek,rt1306\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt1305_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt1305_acpi_match[] = {\n\t{\"10EC1305\", 0,},\n\t{\"10EC1306\", 0,},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt1305_acpi_match);\n#endif\n\nstatic const struct i2c_device_id rt1305_i2c_id[] = {\n\t{ \"rt1305\", 0 },\n\t{ \"rt1306\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1305_i2c_id);\n\nstatic void rt1305_calibrate(struct rt1305_priv *rt1305)\n{\n\tunsigned int valmsb, vallsb, offsetl, offsetr;\n\tunsigned int rh, rl, rhl, r0ohm;\n\tu64 r0l, r0r;\n\n\tregcache_cache_bypass(rt1305->regmap, true);\n\n\trt1305_reset(rt1305->regmap);\n\tregmap_write(rt1305->regmap, RT1305_ADC_SET_3, 0x0219);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xcf, 0x5548);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xc1, 0x0320);\n\tregmap_write(rt1305->regmap, RT1305_CLOCK_DETECT, 0x1000);\n\tregmap_write(rt1305->regmap, RT1305_CLK_1, 0x0600);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xffd0);\n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0080);\n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0880);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_1, 0x0dfe);\n\n\t \n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x5d, 0x0442);\n\n\tregmap_write(rt1305->regmap, RT1305_CAL_EFUSE_CLOCK, 0xb000);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xc3, 0xd4a0);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xcc, 0x00cc);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xc1, 0x0320);\n\tregmap_write(rt1305->regmap, RT1305_POWER_STATUS, 0x0000);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_2, 0xffff);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfc20);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x06, 0x00c0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfca0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfce0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfcf0);\n\n\t \n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0080);\n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0880);\n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0880);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfce0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfca0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfc20);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x06, 0x0000);\n\tregmap_write(rt1305->regmap, RT1305_EFUSE_1, 0x0000);\n\n\tregmap_read(rt1305->regmap, RT1305_DAC_OFFSET_5, &valmsb);\n\tregmap_read(rt1305->regmap, RT1305_DAC_OFFSET_6, &vallsb);\n\toffsetl = valmsb << 16 | vallsb;\n\tregmap_read(rt1305->regmap, RT1305_DAC_OFFSET_7, &valmsb);\n\tregmap_read(rt1305->regmap, RT1305_DAC_OFFSET_8, &vallsb);\n\toffsetr = valmsb << 16 | vallsb;\n\tpr_info(\"DC offsetl=0x%x, offsetr=0x%x\\n\", offsetl, offsetr);\n\n\t \n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x5d, 0x9542);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0xfcf0);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_2, 0xffff);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_1, 0x1dfe);\n\tregmap_write(rt1305->regmap, RT1305_SILENCE_DETECT, 0x0e13);\n\tregmap_write(rt1305->regmap, RT1305_CLK_1, 0x0650);\n\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x50, 0x0064);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x51, 0x0770);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x52, 0xc30c);\n\tregmap_write(rt1305->regmap, RT1305_SPK_TEMP_PROTECTION_1, 0x8200);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xd4, 0xfb00);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xd4, 0xff80);\n\tmsleep(2000);\n\tregmap_read(rt1305->regmap, RT1305_PR_BASE + 0x55, &rh);\n\tregmap_read(rt1305->regmap, RT1305_PR_BASE + 0x56, &rl);\n\trhl = (rh << 16) | rl;\n\tr0ohm = (rhl*10) / 33554432;\n\n\tpr_debug(\"Left_rhl = 0x%x rh=0x%x rl=0x%x\\n\", rhl, rh, rl);\n\tpr_info(\"Left channel %d.%dohm\\n\", (r0ohm/10), (r0ohm%10));\n\n\tr0l = 562949953421312ULL;\n\tif (rhl != 0)\n\t\tdo_div(r0l, rhl);\n\tpr_debug(\"Left_r0 = 0x%llx\\n\", r0l);\n\n\tregmap_write(rt1305->regmap, RT1305_SPK_TEMP_PROTECTION_1, 0x9200);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xd4, 0xfb00);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xd4, 0xff80);\n\tmsleep(2000);\n\tregmap_read(rt1305->regmap, RT1305_PR_BASE + 0x55, &rh);\n\tregmap_read(rt1305->regmap, RT1305_PR_BASE + 0x56, &rl);\n\trhl = (rh << 16) | rl;\n\tr0ohm = (rhl*10) / 33554432;\n\n\tpr_debug(\"Right_rhl = 0x%x rh=0x%x rl=0x%x\\n\", rhl, rh, rl);\n\tpr_info(\"Right channel %d.%dohm\\n\", (r0ohm/10), (r0ohm%10));\n\n\tr0r = 562949953421312ULL;\n\tif (rhl != 0)\n\t\tdo_div(r0r, rhl);\n\tpr_debug(\"Right_r0 = 0x%llx\\n\", r0r);\n\n\tregmap_write(rt1305->regmap, RT1305_SPK_TEMP_PROTECTION_1, 0xc2ec);\n\n\tif ((r0l > R0_UPPER) && (r0l < R0_LOWER) &&\n\t\t(r0r > R0_UPPER) && (r0r < R0_LOWER)) {\n\t\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x4e,\n\t\t\t(r0l >> 16) & 0xffff);\n\t\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x4f,\n\t\t\tr0l & 0xffff);\n\t\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xfe,\n\t\t\t((r0r >> 16) & 0xffff) | 0xf800);\n\t\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0xfd,\n\t\t\tr0r & 0xffff);\n\t} else {\n\t\tpr_err(\"R0 calibration failed\\n\");\n\t}\n\n\t \n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_1, 0x0dfe);\n\tusleep_range(200000, 400000);\n\tregmap_write(rt1305->regmap, RT1305_PR_BASE + 0x5d, 0x0442);\n\tregmap_write(rt1305->regmap, RT1305_CLOCK_DETECT, 0x3000);\n\tregmap_write(rt1305->regmap, RT1305_CLK_1, 0x0400);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_1, 0x0000);\n\tregmap_write(rt1305->regmap, RT1305_CAL_EFUSE_CLOCK, 0x8000);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_2, 0x1020);\n\tregmap_write(rt1305->regmap, RT1305_POWER_CTRL_3, 0x0000);\n\n\tregcache_cache_bypass(rt1305->regmap, false);\n}\n\nstatic int rt1305_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt1305_priv *rt1305;\n\tint ret;\n\tunsigned int val;\n\n\trt1305 = devm_kzalloc(&i2c->dev, sizeof(struct rt1305_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (rt1305 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt1305);\n\n\trt1305->regmap = devm_regmap_init_i2c(i2c, &rt1305_regmap);\n\tif (IS_ERR(rt1305->regmap)) {\n\t\tret = PTR_ERR(rt1305->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt1305->regmap, RT1305_DEVICE_ID, &val);\n\tif (val != RT1305_DEVICE_ID_NUM) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %x is not rt1305\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\trt1305_reset(rt1305->regmap);\n\trt1305_calibrate(rt1305);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_rt1305,\n\t\t\trt1305_dai, ARRAY_SIZE(rt1305_dai));\n}\n\nstatic void rt1305_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct rt1305_priv *rt1305 = i2c_get_clientdata(client);\n\n\trt1305_reset(rt1305->regmap);\n}\n\n\nstatic struct i2c_driver rt1305_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1305\",\n#if defined(CONFIG_OF)\n\t\t.of_match_table = rt1305_of_match,\n#endif\n#if defined(CONFIG_ACPI)\n\t\t.acpi_match_table = ACPI_PTR(rt1305_acpi_match)\n#endif\n\t},\n\t.probe = rt1305_i2c_probe,\n\t.shutdown = rt1305_i2c_shutdown,\n\t.id_table = rt1305_i2c_id,\n};\nmodule_i2c_driver(rt1305_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1305 amplifier driver\");\nMODULE_AUTHOR(\"Shuming Fan <shumingf@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}