{
  "module_name": "ts3a227e.c",
  "hash_id": "1efcbbb9bbe679ada19fd7d215432b8dff590a9bedaf139441aff168f61ec9bb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ts3a227e.c",
  "human_readable_source": "\n \n\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/input.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/soc.h>\n\n#include \"ts3a227e.h\"\n\nstruct ts3a227e {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct snd_soc_jack *jack;\n\tbool plugged;\n\tbool mic_present;\n\tunsigned int buttons_held;\n\tint irq;\n};\n\n \nstatic const int ts3a227e_buttons[] = {\n\tSND_JACK_BTN_0,\n\tSND_JACK_BTN_1,\n\tSND_JACK_BTN_2,\n\tSND_JACK_BTN_3,\n};\n\n#define TS3A227E_NUM_BUTTONS 4\n#define TS3A227E_JACK_MASK (SND_JACK_HEADPHONE | \\\n\t\t\t    SND_JACK_MICROPHONE | \\\n\t\t\t    SND_JACK_BTN_0 | \\\n\t\t\t    SND_JACK_BTN_1 | \\\n\t\t\t    SND_JACK_BTN_2 | \\\n\t\t\t    SND_JACK_BTN_3)\n\n \n#define TS3A227E_REG_DEVICE_ID\t\t0x00\n#define TS3A227E_REG_INTERRUPT\t\t0x01\n#define TS3A227E_REG_KP_INTERRUPT\t0x02\n#define TS3A227E_REG_INTERRUPT_DISABLE\t0x03\n#define TS3A227E_REG_SETTING_1\t\t0x04\n#define TS3A227E_REG_SETTING_2\t\t0x05\n#define TS3A227E_REG_SETTING_3\t\t0x06\n#define TS3A227E_REG_SWITCH_CONTROL_1\t0x07\n#define TS3A227E_REG_SWITCH_CONTROL_2\t0x08\n#define TS3A227E_REG_SWITCH_STATUS_1\t0x09\n#define TS3A227E_REG_SWITCH_STATUS_2\t0x0a\n#define TS3A227E_REG_ACCESSORY_STATUS\t0x0b\n#define TS3A227E_REG_ADC_OUTPUT\t\t0x0c\n#define TS3A227E_REG_KP_THRESHOLD_1\t0x0d\n#define TS3A227E_REG_KP_THRESHOLD_2\t0x0e\n#define TS3A227E_REG_KP_THRESHOLD_3\t0x0f\n\n \n#define INS_REM_EVENT 0x01\n#define DETECTION_COMPLETE_EVENT 0x02\n\n \n#define PRESS_MASK(idx) (0x01 << (2 * (idx)))\n#define RELEASE_MASK(idx) (0x02 << (2 * (idx)))\n\n \n#define INS_REM_INT_DISABLE 0x01\n#define DETECTION_COMPLETE_INT_DISABLE 0x02\n#define ADC_COMPLETE_INT_DISABLE 0x04\n#define INTB_DISABLE 0x08\n\n \n#define DEBOUNCE_INSERTION_SETTING_SFT (0)\n#define DEBOUNCE_INSERTION_SETTING_MASK (0x7 << DEBOUNCE_PRESS_SETTING_SFT)\n\n \n#define KP_ENABLE 0x04\n\n \n#define MICBIAS_SETTING_SFT 3\n#define MICBIAS_SETTING_MASK (0x7 << MICBIAS_SETTING_SFT)\n#define DEBOUNCE_RELEASE_SETTING_SFT 2\n#define DEBOUNCE_RELEASE_SETTING_MASK (0x1 << DEBOUNCE_RELEASE_SETTING_SFT)\n#define DEBOUNCE_PRESS_SETTING_SFT 0\n#define DEBOUNCE_PRESS_SETTING_MASK (0x3 << DEBOUNCE_PRESS_SETTING_SFT)\n\n \n#define TYPE_3_POLE 0x01\n#define TYPE_4_POLE_OMTP 0x02\n#define TYPE_4_POLE_STANDARD 0x04\n#define JACK_INSERTED 0x08\n#define EITHER_MIC_MASK (TYPE_4_POLE_OMTP | TYPE_4_POLE_STANDARD)\n\nstatic const struct reg_default ts3a227e_reg_defaults[] = {\n\t{ TS3A227E_REG_DEVICE_ID, 0x10 },\n\t{ TS3A227E_REG_INTERRUPT, 0x00 },\n\t{ TS3A227E_REG_KP_INTERRUPT, 0x00 },\n\t{ TS3A227E_REG_INTERRUPT_DISABLE, 0x08 },\n\t{ TS3A227E_REG_SETTING_1, 0x23 },\n\t{ TS3A227E_REG_SETTING_2, 0x00 },\n\t{ TS3A227E_REG_SETTING_3, 0x0e },\n\t{ TS3A227E_REG_SWITCH_CONTROL_1, 0x00 },\n\t{ TS3A227E_REG_SWITCH_CONTROL_2, 0x00 },\n\t{ TS3A227E_REG_SWITCH_STATUS_1, 0x0c },\n\t{ TS3A227E_REG_SWITCH_STATUS_2, 0x00 },\n\t{ TS3A227E_REG_ACCESSORY_STATUS, 0x00 },\n\t{ TS3A227E_REG_ADC_OUTPUT, 0x00 },\n\t{ TS3A227E_REG_KP_THRESHOLD_1, 0x20 },\n\t{ TS3A227E_REG_KP_THRESHOLD_2, 0x40 },\n\t{ TS3A227E_REG_KP_THRESHOLD_3, 0x68 },\n};\n\nstatic bool ts3a227e_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TS3A227E_REG_DEVICE_ID ... TS3A227E_REG_KP_THRESHOLD_3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ts3a227e_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TS3A227E_REG_INTERRUPT_DISABLE ... TS3A227E_REG_SWITCH_CONTROL_2:\n\tcase TS3A227E_REG_KP_THRESHOLD_1 ... TS3A227E_REG_KP_THRESHOLD_3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool ts3a227e_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TS3A227E_REG_INTERRUPT ... TS3A227E_REG_INTERRUPT_DISABLE:\n\tcase TS3A227E_REG_SETTING_1 ... TS3A227E_REG_SETTING_2:\n\tcase TS3A227E_REG_SWITCH_STATUS_1 ... TS3A227E_REG_ADC_OUTPUT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void ts3a227e_jack_report(struct ts3a227e *ts3a227e)\n{\n\tunsigned int i;\n\tint report = 0;\n\n\tif (!ts3a227e->jack)\n\t\treturn;\n\n\tif (ts3a227e->plugged)\n\t\treport = SND_JACK_HEADPHONE;\n\tif (ts3a227e->mic_present)\n\t\treport |= SND_JACK_MICROPHONE;\n\tfor (i = 0; i < TS3A227E_NUM_BUTTONS; i++) {\n\t\tif (ts3a227e->buttons_held & (1 << i))\n\t\t\treport |= ts3a227e_buttons[i];\n\t}\n\tsnd_soc_jack_report(ts3a227e->jack, report, TS3A227E_JACK_MASK);\n}\n\nstatic void ts3a227e_new_jack_state(struct ts3a227e *ts3a227e, unsigned acc_reg)\n{\n\tbool plugged, mic_present;\n\n\tplugged = !!(acc_reg & JACK_INSERTED);\n\tmic_present = plugged && !!(acc_reg & EITHER_MIC_MASK);\n\n\tts3a227e->plugged = plugged;\n\n\tif (mic_present != ts3a227e->mic_present) {\n\t\tts3a227e->mic_present = mic_present;\n\t\tts3a227e->buttons_held = 0;\n\t\tif (mic_present) {\n\t\t\t \n\t\t\tregmap_update_bits(ts3a227e->regmap,\n\t\t\t\t\t   TS3A227E_REG_SETTING_2,\n\t\t\t\t\t   KP_ENABLE, KP_ENABLE);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t ts3a227e_interrupt(int irq, void *data)\n{\n\tstruct ts3a227e *ts3a227e = (struct ts3a227e *)data;\n\tstruct regmap *regmap = ts3a227e->regmap;\n\tunsigned int int_reg, kp_int_reg, acc_reg, i;\n\tstruct device *dev = ts3a227e->dev;\n\tint ret;\n\n\t \n\tret = regmap_read(regmap, TS3A227E_REG_INTERRUPT, &int_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to clear interrupt ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (int_reg & (DETECTION_COMPLETE_EVENT | INS_REM_EVENT)) {\n\t\tregmap_read(regmap, TS3A227E_REG_ACCESSORY_STATUS, &acc_reg);\n\t\tts3a227e_new_jack_state(ts3a227e, acc_reg);\n\t}\n\n\t \n\tret = regmap_read(regmap, TS3A227E_REG_KP_INTERRUPT, &kp_int_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to clear key interrupt ret=%d\\n\", ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tfor (i = 0; i < TS3A227E_NUM_BUTTONS; i++) {\n\t\tif (kp_int_reg & PRESS_MASK(i))\n\t\t\tts3a227e->buttons_held |= (1 << i);\n\t\tif (kp_int_reg & RELEASE_MASK(i))\n\t\t\tts3a227e->buttons_held &= ~(1 << i);\n\t}\n\n\tts3a227e_jack_report(ts3a227e);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint ts3a227e_enable_jack_detect(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_jack *jack)\n{\n\tstruct ts3a227e *ts3a227e = snd_soc_component_get_drvdata(component);\n\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_1, KEY_VOICECOMMAND);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_2, KEY_VOLUMEUP);\n\tsnd_jack_set_key(jack->jack, SND_JACK_BTN_3, KEY_VOLUMEDOWN);\n\n\tts3a227e->jack = jack;\n\tts3a227e_jack_report(ts3a227e);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ts3a227e_enable_jack_detect);\n\nstatic int ts3a227e_set_jack(struct snd_soc_component *component,\n\t\t\t     struct snd_soc_jack *jack, void *data)\n{\n\tif (jack == NULL)\n\t\treturn -EINVAL;\n\n\treturn ts3a227e_enable_jack_detect(component, jack);\n}\n\nstatic int ts3a227e_get_jack_type(struct snd_soc_component *component)\n{\n\treturn SND_JACK_HEADSET;\n}\n\nstatic const struct snd_soc_component_driver ts3a227e_soc_driver = {\n\t.name = \"ti,ts3a227e\",\n\t.set_jack = ts3a227e_set_jack,\n\t.get_jack_type = ts3a227e_get_jack_type,\n};\n\nstatic const struct regmap_config ts3a227e_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 8,\n\n\t.max_register = TS3A227E_REG_KP_THRESHOLD_3,\n\t.readable_reg = ts3a227e_readable_reg,\n\t.writeable_reg = ts3a227e_writeable_reg,\n\t.volatile_reg = ts3a227e_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = ts3a227e_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ts3a227e_reg_defaults),\n};\n\nstatic int ts3a227e_parse_device_property(struct ts3a227e *ts3a227e,\n\t\t\t\tstruct device *dev)\n{\n\tu32 value;\n\tu32 value_ms;\n\tu32 setting3_value = 0;\n\tu32 setting3_mask = 0;\n\tint err;\n\n\terr = device_property_read_u32(dev, \"ti,micbias\", &value);\n\tif (!err) {\n\t\tsetting3_mask = MICBIAS_SETTING_MASK;\n\t\tsetting3_value = (value << MICBIAS_SETTING_SFT) &\n\t\t\t\t MICBIAS_SETTING_MASK;\n\t}\n\n\terr = device_property_read_u32(dev, \"ti,debounce-release-ms\",\n\t\t\t\t       &value_ms);\n\tif (!err) {\n\t\tvalue = (value_ms > 10);\n\t\tsetting3_mask |= DEBOUNCE_RELEASE_SETTING_MASK;\n\t\tsetting3_value |= (value << DEBOUNCE_RELEASE_SETTING_SFT) &\n\t\t\t\t  DEBOUNCE_RELEASE_SETTING_MASK;\n\t}\n\n\terr = device_property_read_u32(dev, \"ti,debounce-press-ms\", &value_ms);\n\tif (!err) {\n\t\tvalue = (value_ms + 20) / 40;\n\t\tif (value > 3)\n\t\t\tvalue = 3;\n\t\tsetting3_mask |= DEBOUNCE_PRESS_SETTING_MASK;\n\t\tsetting3_value |= (value << DEBOUNCE_PRESS_SETTING_SFT) &\n\t\t\t\t  DEBOUNCE_PRESS_SETTING_MASK;\n\t}\n\n\tif (setting3_mask)\n\t\tregmap_update_bits(ts3a227e->regmap, TS3A227E_REG_SETTING_3,\n\t\t\t\t   setting3_mask, setting3_value);\n\n\terr = device_property_read_u32(dev, \"ti,debounce-insertion-ms\",\n\t\t\t\t       &value_ms);\n\tif (!err) {\n\t\tif (value_ms < 165)\n\t\t\tvalue = (value_ms + 15) / 30;\n\t\telse if (value_ms < 1500)\n\t\t\tvalue = 6;\n\t\telse\n\t\t\tvalue = 7;\n\t\tregmap_update_bits(ts3a227e->regmap, TS3A227E_REG_SETTING_1,\n\t\t\t\t   DEBOUNCE_INSERTION_SETTING_MASK,\n\t\t\t\t   (value << DEBOUNCE_INSERTION_SETTING_SFT) &\n\t\t\t\t\t   DEBOUNCE_INSERTION_SETTING_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int ts3a227e_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ts3a227e *ts3a227e;\n\tstruct device *dev = &i2c->dev;\n\tint ret;\n\tunsigned int acc_reg;\n\n\tts3a227e = devm_kzalloc(&i2c->dev, sizeof(*ts3a227e), GFP_KERNEL);\n\tif (ts3a227e == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, ts3a227e);\n\tts3a227e->dev = dev;\n\tts3a227e->irq = i2c->irq;\n\n\tts3a227e->regmap = devm_regmap_init_i2c(i2c, &ts3a227e_regmap_config);\n\tif (IS_ERR(ts3a227e->regmap))\n\t\treturn PTR_ERR(ts3a227e->regmap);\n\n\tret = ts3a227e_parse_device_property(ts3a227e, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to parse device property: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(dev, i2c->irq, NULL, ts3a227e_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\t\"TS3A227E\", ts3a227e);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot request irq %d (%d)\\n\", i2c->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev, &ts3a227e_soc_driver,\n\t\t\t\t\t      NULL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_update_bits(ts3a227e->regmap, TS3A227E_REG_INTERRUPT_DISABLE,\n\t\t\t   INTB_DISABLE | ADC_COMPLETE_INT_DISABLE,\n\t\t\t   ADC_COMPLETE_INT_DISABLE);\n\n\t \n\tregmap_read(ts3a227e->regmap, TS3A227E_REG_ACCESSORY_STATUS, &acc_reg);\n\tts3a227e_new_jack_state(ts3a227e, acc_reg);\n\tts3a227e_jack_report(ts3a227e);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ts3a227e_suspend(struct device *dev)\n{\n\tstruct ts3a227e *ts3a227e = dev_get_drvdata(dev);\n\n\tdev_dbg(ts3a227e->dev, \"suspend disable irq\\n\");\n\tdisable_irq(ts3a227e->irq);\n\n\treturn 0;\n}\n\nstatic int ts3a227e_resume(struct device *dev)\n{\n\tstruct ts3a227e *ts3a227e = dev_get_drvdata(dev);\n\n\tdev_dbg(ts3a227e->dev, \"resume enable irq\\n\");\n\tenable_irq(ts3a227e->irq);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops ts3a227e_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ts3a227e_suspend, ts3a227e_resume)\n};\n\nstatic const struct i2c_device_id ts3a227e_i2c_ids[] = {\n\t{ \"ts3a227e\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ts3a227e_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ts3a227e_of_match[] = {\n\t{ .compatible = \"ti,ts3a227e\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ts3a227e_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic struct acpi_device_id ts3a227e_acpi_match[] = {\n\t{ \"104C227E\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, ts3a227e_acpi_match);\n#endif\n\nstatic struct i2c_driver ts3a227e_driver = {\n\t.driver = {\n\t\t.name = \"ts3a227e\",\n\t\t.pm = &ts3a227e_pm,\n\t\t.of_match_table = of_match_ptr(ts3a227e_of_match),\n\t\t.acpi_match_table = ACPI_PTR(ts3a227e_acpi_match),\n\t},\n\t.probe = ts3a227e_i2c_probe,\n\t.id_table = ts3a227e_i2c_ids,\n};\nmodule_i2c_driver(ts3a227e_driver);\n\nMODULE_DESCRIPTION(\"ASoC ts3a227e driver\");\nMODULE_AUTHOR(\"Dylan Reid <dgreid@chromium.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}