{
  "module_name": "rt712-sdca-dmic.c",
  "hash_id": "7b92659cbd6fc6986fd503687e0b700198b435b18693db815470a33b4fa7f904",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt712-sdca-dmic.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include \"rt712-sdca.h\"\n#include \"rt712-sdca-dmic.h\"\n\nstatic bool rt712_sdca_dmic_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x201a ... 0x201f:\n\tcase 0x2029 ... 0x202a:\n\tcase 0x202d ... 0x2034:\n\tcase 0x2230 ... 0x2232:\n\tcase 0x2f01 ... 0x2f0a:\n\tcase 0x2f35 ... 0x2f36:\n\tcase 0x2f52:\n\tcase 0x2f58 ... 0x2f59:\n\tcase 0x3201:\n\tcase 0x320c:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt712_sdca_dmic_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x201b:\n\tcase 0x201c:\n\tcase 0x201d:\n\tcase 0x201f:\n\tcase 0x202d ... 0x202f:\n\tcase 0x2230:\n\tcase 0x2f01:\n\tcase 0x2f35:\n\tcase 0x320c:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt712_sdca_dmic_mbq_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000 ... 0x200008e:\n\tcase 0x5300000 ... 0x530000e:\n\tcase 0x5400000 ... 0x540000e:\n\tcase 0x5600000 ... 0x5600008:\n\tcase 0x5700000 ... 0x570000d:\n\tcase 0x5800000 ... 0x5800021:\n\tcase 0x5900000 ... 0x5900028:\n\tcase 0x5a00000 ... 0x5a00009:\n\tcase 0x5b00000 ... 0x5b00051:\n\tcase 0x5c00000 ... 0x5c0009a:\n\tcase 0x5d00000 ... 0x5d00009:\n\tcase 0x5f00000 ... 0x5f00030:\n\tcase 0x6100000 ... 0x6100068:\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_VOLUME, CH_01):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_VOLUME, CH_02):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_VOLUME, CH_03):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_VOLUME, CH_04):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PLATFORM_FU15, RT712_SDCA_CTL_FU_CH_GAIN, CH_01):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PLATFORM_FU15, RT712_SDCA_CTL_FU_CH_GAIN, CH_02):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PLATFORM_FU15, RT712_SDCA_CTL_FU_CH_GAIN, CH_03):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PLATFORM_FU15, RT712_SDCA_CTL_FU_CH_GAIN, CH_04):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt712_sdca_dmic_mbq_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000:\n\tcase 0x200001a:\n\tcase 0x2000024:\n\tcase 0x2000046:\n\tcase 0x200008a:\n\tcase 0x5800000:\n\tcase 0x5800001:\n\tcase 0x6100008:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt712_sdca_dmic_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt712_sdca_dmic_readable_register,\n\t.volatile_reg = rt712_sdca_dmic_volatile_register,\n\t.max_register = 0x40981300,\n\t.reg_defaults = rt712_sdca_dmic_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt712_sdca_dmic_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct regmap_config rt712_sdca_dmic_mbq_regmap = {\n\t.name = \"sdw-mbq\",\n\t.reg_bits = 32,\n\t.val_bits = 16,\n\t.readable_reg = rt712_sdca_dmic_mbq_readable_register,\n\t.volatile_reg = rt712_sdca_dmic_mbq_volatile_register,\n\t.max_register = 0x40800f14,\n\t.reg_defaults = rt712_sdca_dmic_mbq_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt712_sdca_dmic_mbq_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt712_sdca_dmic_index_write(struct rt712_sdca_dmic_priv *rt712,\n\t\tunsigned int nid, unsigned int reg, unsigned int value)\n{\n\tint ret;\n\tstruct regmap *regmap = rt712->mbq_regmap;\n\tunsigned int addr = (nid << 20) | reg;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt712->slave->dev,\n\t\t\t\"Failed to set private value: %06x <= %04x ret=%d\\n\",\n\t\t\taddr, value, ret);\n\n\treturn ret;\n}\n\nstatic int rt712_sdca_dmic_index_read(struct rt712_sdca_dmic_priv *rt712,\n\t\tunsigned int nid, unsigned int reg, unsigned int *value)\n{\n\tint ret;\n\tstruct regmap *regmap = rt712->mbq_regmap;\n\tunsigned int addr = (nid << 20) | reg;\n\n\tret = regmap_read(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt712->slave->dev,\n\t\t\t\"Failed to get private value: %06x => %04x ret=%d\\n\",\n\t\t\taddr, *value, ret);\n\n\treturn ret;\n}\n\nstatic int rt712_sdca_dmic_index_update_bits(struct rt712_sdca_dmic_priv *rt712,\n\tunsigned int nid, unsigned int reg, unsigned int mask, unsigned int val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = rt712_sdca_dmic_index_read(rt712, nid, reg, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_mask_bits(&tmp, mask, val);\n\treturn rt712_sdca_dmic_index_write(rt712, nid, reg, tmp);\n}\n\nstatic int rt712_sdca_dmic_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt712_sdca_dmic_priv *rt712 = dev_get_drvdata(dev);\n\n\tif (rt712->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt712->regmap, false);\n\tregcache_cache_only(rt712->mbq_regmap, false);\n\tif (rt712->first_hw_init) {\n\t\tregcache_cache_bypass(rt712->regmap, true);\n\t\tregcache_cache_bypass(rt712->mbq_regmap, true);\n\t} else {\n\t\t \n\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_ADC0A_08_PDE_FLOAT_CTL, 0x1112);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_ADC0B_11_PDE_FLOAT_CTL, 0x1111);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_DMIC1_2_PDE_FLOAT_CTL, 0x1111);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_I2S_IN_OUT_PDE_FLOAT_CTL, 0x1155);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_DMIC_ENT_FLOAT_CTL, 0x2626);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_ADC_ENT_FLOAT_CTL, 0x1e19);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_DMIC_GAIN_ENT_FLOAT_CTL0, 0x1515);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_ADC_VOL_CH_FLOAT_CTL2, 0x0304);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_DMIC_GAIN_ENT_FLOAT_CTL2, 0x0304);\n\trt712_sdca_dmic_index_write(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_HDA_LEGACY_CONFIG_CTL0, 0x0050);\n\tregmap_write(rt712->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_IT26, RT712_SDCA_CTL_VENDOR_DEF, 0), 0x01);\n\trt712_sdca_dmic_index_write(rt712, RT712_ULTRA_SOUND_DET,\n\t\tRT712_ULTRA_SOUND_DETECTOR6, 0x3200);\n\tregmap_write(rt712->regmap, RT712_RC_CAL, 0x23);\n\tregmap_write(rt712->regmap, 0x2f52, 0x00);\n\n\tif (rt712->first_hw_init) {\n\t\tregcache_cache_bypass(rt712->regmap, false);\n\t\tregcache_mark_dirty(rt712->regmap);\n\t\tregcache_cache_bypass(rt712->mbq_regmap, false);\n\t\tregcache_mark_dirty(rt712->mbq_regmap);\n\t} else\n\t\trt712->first_hw_init = true;\n\n\t \n\trt712->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete\\n\", __func__);\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_set_gain_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt712_sdca_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct rt712_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt712_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tunsigned int regvalue, ctl, i;\n\tunsigned int adc_vol_flag = 0;\n\tconst unsigned int interval_offset = 0xc0;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\t \n\tfor (i = 0; i < p->count; i++) {\n\t\tregmap_read(rt712->mbq_regmap, p->reg_base + i, &regvalue);\n\n\t\tif (!adc_vol_flag)  \n\t\t\tctl = regvalue / 0x0a00;\n\t\telse {  \n\t\t\tif (adc_vol_flag)\n\t\t\t\tctl = p->max - (((0x1e00 - regvalue) & 0xffff) / interval_offset);\n\t\t\telse\n\t\t\t\tctl = p->max - (((0 - regvalue) & 0xffff) / interval_offset);\n\t\t}\n\n\t\tucontrol->value.integer.value[i] = ctl;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_set_gain_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt712_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt712_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tstruct rt712_sdca_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tunsigned int gain_val[4];\n\tunsigned int i, adc_vol_flag = 0, changed = 0;\n\tunsigned int regvalue[4];\n\tconst unsigned int interval_offset = 0xc0;\n\tint err;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\t \n\tfor (i = 0; i < p->count; i++) {\n\t\tregmap_read(rt712->mbq_regmap, p->reg_base + i, &regvalue[i]);\n\n\t\tgain_val[i] = ucontrol->value.integer.value[i];\n\t\tif (gain_val[i] > p->max)\n\t\t\tgain_val[i] = p->max;\n\n\t\tif (!adc_vol_flag)  \n\t\t\tgain_val[i] = gain_val[i] * 0x0a00;\n\t\telse {  \n\t\t\tgain_val[i] = 0x1e00 - ((p->max - gain_val[i]) * interval_offset);\n\t\t\tgain_val[i] &= 0xffff;\n\t\t}\n\n\t\tif (regvalue[i] != gain_val[i])\n\t\t\tchanged = 1;\n\t}\n\n\tif (!changed)\n\t\treturn 0;\n\n\tfor (i = 0; i < p->count; i++) {\n\t\terr = regmap_write(rt712->mbq_regmap, p->reg_base + i, gain_val[i]);\n\t\tif (err < 0)\n\t\t\tdev_err(&rt712->slave->dev, \"0x%08x can't be set\\n\", p->reg_base + i);\n\t}\n\n\treturn changed;\n}\n\nstatic int rt712_sdca_set_fu1e_capture_ctl(struct rt712_sdca_dmic_priv *rt712)\n{\n\tint err, i;\n\tunsigned int ch_mute;\n\n\tfor (i = 0; i < ARRAY_SIZE(rt712->fu1e_mixer_mute); i++) {\n\t\tch_mute = (rt712->fu1e_dapm_mute || rt712->fu1e_mixer_mute[i]) ? 0x01 : 0x00;\n\t\terr = regmap_write(rt712->regmap,\n\t\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E,\n\t\t\t\tRT712_SDCA_CTL_FU_MUTE, CH_01) + i, ch_mute);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_fu1e_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct rt712_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt712_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tunsigned int i;\n\n\tfor (i = 0; i < p->count; i++)\n\t\tucontrol->value.integer.value[i] = !rt712->fu1e_mixer_mute[i];\n\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_fu1e_capture_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct rt712_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt712_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tint err, changed = 0, i;\n\n\tfor (i = 0; i < p->count; i++) {\n\t\tif (rt712->fu1e_mixer_mute[i] != !ucontrol->value.integer.value[i])\n\t\t\tchanged = 1;\n\t\trt712->fu1e_mixer_mute[i] = !ucontrol->value.integer.value[i];\n\t}\n\n\terr = rt712_sdca_set_fu1e_capture_ctl(rt712);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn changed;\n}\n\nstatic int rt712_sdca_fu_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct rt712_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt712_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\n\tif (p->max == 1)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = p->count;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = p->max;\n\treturn 0;\n}\n\n#define RT712_SDCA_PR_VALUE(xreg_base, xcount, xmax, xinvert) \\\n\t((unsigned long)&(struct rt712_sdca_dmic_kctrl_priv) \\\n\t\t{.reg_base = xreg_base, .count = xcount, .max = xmax, \\\n\t\t.invert = xinvert})\n\n#define RT712_SDCA_FU_CTRL(xname, reg_base, xmax, xinvert, xcount) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = rt712_sdca_fu_info, \\\n\t.get = rt712_sdca_dmic_fu1e_capture_get, \\\n\t.put = rt712_sdca_dmic_fu1e_capture_put, \\\n\t.private_value = RT712_SDCA_PR_VALUE(reg_base, xcount, xmax, xinvert)}\n\n#define RT712_SDCA_EXT_TLV(xname, reg_base, xhandler_get,\\\n\t xhandler_put, xcount, xmax, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = rt712_sdca_fu_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = RT712_SDCA_PR_VALUE(reg_base, xcount, xmax, 0) }\n\nstatic const DECLARE_TLV_DB_SCALE(in_vol_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic const struct snd_kcontrol_new rt712_sdca_dmic_snd_controls[] = {\n\tRT712_SDCA_FU_CTRL(\"FU1E Capture Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_MUTE, CH_01),\n\t\t1, 1, 4),\n\tRT712_SDCA_EXT_TLV(\"FU1E Capture Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_USER_FU1E, RT712_SDCA_CTL_FU_VOLUME, CH_01),\n\t\trt712_sdca_dmic_set_gain_get, rt712_sdca_dmic_set_gain_put, 4, 0x3f, in_vol_tlv),\n\tRT712_SDCA_EXT_TLV(\"FU15 Boost Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PLATFORM_FU15, RT712_SDCA_CTL_FU_CH_GAIN, CH_01),\n\t\trt712_sdca_dmic_set_gain_get, rt712_sdca_dmic_set_gain_put, 4, 3, mic_vol_tlv),\n};\n\nstatic int rt712_sdca_dmic_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0, mask_sft;\n\n\tif (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 8;\n\telse if (strstr(ucontrol->id.name, \"ADC 26 Mux\"))\n\t\tmask_sft = 4;\n\telse\n\t\treturn -EINVAL;\n\n\trt712_sdca_dmic_index_read(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_HDA_LEGACY_MUX_CTL0, &val);\n\n\tucontrol->value.enumerated.item[0] = (val >> mask_sft) & 0x7;\n\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, val2 = 0, change, mask_sft;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tif (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 8;\n\telse if (strstr(ucontrol->id.name, \"ADC 26 Mux\"))\n\t\tmask_sft = 4;\n\telse\n\t\treturn -EINVAL;\n\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\trt712_sdca_dmic_index_read(rt712, RT712_VENDOR_HDA_CTL,\n\t\tRT712_HDA_LEGACY_MUX_CTL0, &val2);\n\tval2 = (0x7 << mask_sft) & val2;\n\n\tif (val == val2)\n\t\tchange = 0;\n\telse\n\t\tchange = 1;\n\n\tif (change)\n\t\trt712_sdca_dmic_index_update_bits(rt712, RT712_VENDOR_HDA_CTL,\n\t\t\tRT712_HDA_LEGACY_MUX_CTL0, 0x7 << mask_sft,\n\t\t\tval << mask_sft);\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\titem[0], e, NULL);\n\n\treturn change;\n}\n\nstatic const char * const adc_mux_text[] = {\n\t\"DMIC1\",\n\t\"DMIC2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt712_adc25_enum, SND_SOC_NOPM, 0, adc_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt712_adc26_enum, SND_SOC_NOPM, 0, adc_mux_text);\n\nstatic const struct snd_kcontrol_new rt712_sdca_dmic_adc25_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 25 Mux\", rt712_adc25_enum,\n\t\t\trt712_sdca_dmic_mux_get, rt712_sdca_dmic_mux_put);\n\nstatic const struct snd_kcontrol_new rt712_sdca_dmic_adc26_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 26 Mux\", rt712_adc26_enum,\n\t\t\trt712_sdca_dmic_mux_get, rt712_sdca_dmic_mux_put);\n\nstatic int rt712_sdca_dmic_fu1e_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\trt712->fu1e_dapm_mute = false;\n\t\trt712_sdca_set_fu1e_capture_ctl(rt712);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\trt712->fu1e_dapm_mute = true;\n\t\trt712_sdca_set_fu1e_capture_ctl(rt712);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_pde11_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt712->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PDE11,\n\t\t\t\tRT712_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt712->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_PDE11,\n\t\t\t\tRT712_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt712_sdca_dmic_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PDE 11\", SND_SOC_NOPM, 0, 0,\n\t\trt712_sdca_dmic_pde11_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"FU 1E\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt712_sdca_dmic_fu1e_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_MUX(\"ADC 25 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt712_sdca_dmic_adc25_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 26 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt712_sdca_dmic_adc26_mux),\n\n\tSND_SOC_DAPM_AIF_OUT(\"DP2TX\", \"DP2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route rt712_sdca_dmic_audio_map[] = {\n\t{\"DP2TX\", NULL, \"FU 1E\"},\n\n\t{\"FU 1E\", NULL, \"PDE 11\"},\n\t{\"FU 1E\", NULL, \"ADC 25 Mux\"},\n\t{\"FU 1E\", NULL, \"ADC 26 Mux\"},\n\t{\"ADC 25 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 25 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 26 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 26 Mux\", \"DMIC2\", \"DMIC2\"},\n};\n\nstatic int rt712_sdca_dmic_probe(struct snd_soc_component *component)\n{\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt712->component = component;\n\n\tif (!rt712->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_sdca_dev_rt712_dmic = {\n\t.probe = rt712_sdca_dmic_probe,\n\t.controls = rt712_sdca_dmic_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt712_sdca_dmic_snd_controls),\n\t.dapm_widgets = rt712_sdca_dmic_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt712_sdca_dmic_dapm_widgets),\n\t.dapm_routes = rt712_sdca_dmic_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rt712_sdca_dmic_audio_map),\n\t.endianness = 1,\n};\n\nstatic int rt712_sdca_dmic_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt712_sdca_dmic_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt712_sdca_dmic_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config;\n\tstruct sdw_port_config port_config;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval, num_channels;\n\tunsigned int sampling_rate;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt712->slave)\n\t\treturn -EINVAL;\n\n\tstream_config.frame_rate = params_rate(params);\n\tstream_config.ch_count = params_channels(params);\n\tstream_config.bps = snd_pcm_format_width(params_format(params));\n\tstream_config.direction = SDW_DATA_DIR_TX;\n\n\tnum_channels = params_channels(params);\n\tport_config.ch_mask = GENMASK(num_channels - 1, 0);\n\tport_config.num = 2;\n\n\tretval = sdw_stream_add_slave(rt712->slave, &stream_config,\n\t\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\tif (params_channels(params) > 4) {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 16000:\n\t\tsampling_rate = RT712_SDCA_RATE_16000HZ;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = RT712_SDCA_RATE_32000HZ;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = RT712_SDCA_RATE_44100HZ;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = RT712_SDCA_RATE_48000HZ;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = RT712_SDCA_RATE_96000HZ;\n\t\tbreak;\n\tcase 192000:\n\t\tsampling_rate = RT712_SDCA_RATE_192000HZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(rt712->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_CS1F, RT712_SDCA_CTL_SAMPLE_FREQ_INDEX, 0),\n\t\tsampling_rate);\n\tregmap_write(rt712->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT712_SDCA_ENT_CS1C, RT712_SDCA_CTL_SAMPLE_FREQ_INDEX, 0),\n\t\tsampling_rate);\n\n\treturn 0;\n}\n\nstatic int rt712_sdca_dmic_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt712_sdca_dmic_priv *rt712 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt712->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt712->slave, sdw_stream);\n\treturn 0;\n}\n\n#define RT712_STEREO_RATES (SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)\n#define RT712_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops rt712_sdca_dmic_ops = {\n\t.hw_params\t= rt712_sdca_dmic_hw_params,\n\t.hw_free\t= rt712_sdca_dmic_hw_free,\n\t.set_stream\t= rt712_sdca_dmic_set_sdw_stream,\n\t.shutdown\t= rt712_sdca_dmic_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt712_sdca_dmic_dai[] = {\n\t{\n\t\t.name = \"rt712-sdca-dmic-aif1\",\n\t\t.id = RT712_AIF1,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = RT712_STEREO_RATES,\n\t\t\t.formats = RT712_FORMATS,\n\t\t},\n\t\t.ops = &rt712_sdca_dmic_ops,\n\t},\n};\n\nstatic int rt712_sdca_dmic_init(struct device *dev, struct regmap *regmap,\n\t\t\tstruct regmap *mbq_regmap, struct sdw_slave *slave)\n{\n\tstruct rt712_sdca_dmic_priv *rt712;\n\tint ret;\n\n\trt712 = devm_kzalloc(dev, sizeof(*rt712), GFP_KERNEL);\n\tif (!rt712)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt712);\n\trt712->slave = slave;\n\trt712->regmap = regmap;\n\trt712->mbq_regmap = mbq_regmap;\n\n\tregcache_cache_only(rt712->regmap, true);\n\tregcache_cache_only(rt712->mbq_regmap, true);\n\n\t \n\trt712->hw_init = false;\n\trt712->first_hw_init = false;\n\trt712->fu1e_dapm_mute = true;\n\trt712->fu1e_mixer_mute[0] = rt712->fu1e_mixer_mute[1] =\n\t\trt712->fu1e_mixer_mute[2] = rt712->fu1e_mixer_mute[3] = true;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t&soc_sdca_dev_rt712_dmic,\n\t\t\trt712_sdca_dmic_dai,\n\t\t\tARRAY_SIZE(rt712_sdca_dmic_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\n\nstatic int rt712_sdca_dmic_update_status(struct sdw_slave *slave,\n\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct rt712_sdca_dmic_priv *rt712 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt712->hw_init = false;\n\n\t \n\tif (rt712->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt712_sdca_dmic_io_init(&slave->dev, slave);\n}\n\nstatic int rt712_sdca_dmic_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = BIT(2);  \n\tprop->sink_ports = 0;\n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->src_dpn_prop), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 200;\n\n\t \n\tprop->wake_capable = 1;\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt712_sdca_dmic_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1712, 0x3, 0x1, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1713, 0x3, 0x1, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1716, 0x3, 0x1, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1717, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt712_sdca_dmic_id);\n\nstatic int __maybe_unused rt712_sdca_dmic_dev_suspend(struct device *dev)\n{\n\tstruct rt712_sdca_dmic_priv *rt712 = dev_get_drvdata(dev);\n\n\tif (!rt712->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt712->regmap, true);\n\tregcache_cache_only(rt712->mbq_regmap, true);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt712_sdca_dmic_dev_system_suspend(struct device *dev)\n{\n\tstruct rt712_sdca_dmic_priv *rt712_sdca = dev_get_drvdata(dev);\n\n\tif (!rt712_sdca->hw_init)\n\t\treturn 0;\n\n\treturn rt712_sdca_dmic_dev_suspend(dev);\n}\n\n#define RT712_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt712_sdca_dmic_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt712_sdca_dmic_priv *rt712 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt712->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT712_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt712->regmap, false);\n\tregcache_sync(rt712->regmap);\n\tregcache_cache_only(rt712->mbq_regmap, false);\n\tregcache_sync(rt712->mbq_regmap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt712_sdca_dmic_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt712_sdca_dmic_dev_system_suspend, rt712_sdca_dmic_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt712_sdca_dmic_dev_suspend, rt712_sdca_dmic_dev_resume, NULL)\n};\n\n\nstatic struct sdw_slave_ops rt712_sdca_dmic_slave_ops = {\n\t.read_prop = rt712_sdca_dmic_read_prop,\n\t.update_status = rt712_sdca_dmic_update_status,\n};\n\nstatic int rt712_sdca_dmic_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct regmap *regmap, *mbq_regmap;\n\n\t \n\tmbq_regmap = devm_regmap_init_sdw_mbq(slave, &rt712_sdca_dmic_mbq_regmap);\n\tif (IS_ERR(mbq_regmap))\n\t\treturn PTR_ERR(mbq_regmap);\n\n\tregmap = devm_regmap_init_sdw(slave, &rt712_sdca_dmic_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt712_sdca_dmic_init(&slave->dev, regmap, mbq_regmap, slave);\n}\n\nstatic int rt712_sdca_dmic_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic struct sdw_driver rt712_sdca_dmic_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt712-sdca-dmic\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt712_sdca_dmic_pm,\n\t},\n\t.probe = rt712_sdca_dmic_sdw_probe,\n\t.remove = rt712_sdca_dmic_sdw_remove,\n\t.ops = &rt712_sdca_dmic_slave_ops,\n\t.id_table = rt712_sdca_dmic_id,\n};\nmodule_sdw_driver(rt712_sdca_dmic_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT712 SDCA DMIC SDW driver\");\nMODULE_AUTHOR(\"Shuming Fan <shumingf@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}