{
  "module_name": "nau8540.c",
  "hash_id": "5a54792daec3e29506221781fb7c468dd58fe5262d8d564b304ffd7b9f3a04a0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8540.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include \"nau8540.h\"\n\n\n#define NAU_FREF_MAX 13500000\n#define NAU_FVCO_MAX 100000000\n#define NAU_FVCO_MIN 90000000\n\n \n#define CLK_ADC_MAX 6144000\n\n \nstatic const struct nau8540_fll_attr mclk_src_scaling[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x2 },\n\t{ 4, 0x3 },\n\t{ 8, 0x4 },\n\t{ 16, 0x5 },\n\t{ 32, 0x6 },\n\t{ 3, 0x7 },\n\t{ 6, 0xa },\n\t{ 12, 0xb },\n\t{ 24, 0xc },\n};\n\n \nstatic const struct nau8540_fll_attr fll_ratio[] = {\n\t{ 512000, 0x01 },\n\t{ 256000, 0x02 },\n\t{ 128000, 0x04 },\n\t{ 64000, 0x08 },\n\t{ 32000, 0x10 },\n\t{ 8000, 0x20 },\n\t{ 4000, 0x40 },\n};\n\nstatic const struct nau8540_fll_attr fll_pre_scalar[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x1 },\n\t{ 4, 0x2 },\n\t{ 8, 0x3 },\n};\n\n \nstatic const struct nau8540_osr_attr osr_adc_sel[] = {\n\t{ 32, 3 },\t \n\t{ 64, 2 },\t \n\t{ 128, 1 },\t \n\t{ 256, 0 },\t \n};\n\nstatic const struct reg_default nau8540_reg_defaults[] = {\n\t{NAU8540_REG_POWER_MANAGEMENT, 0x0000},\n\t{NAU8540_REG_CLOCK_CTRL, 0x0000},\n\t{NAU8540_REG_CLOCK_SRC, 0x0000},\n\t{NAU8540_REG_FLL1, 0x0001},\n\t{NAU8540_REG_FLL2, 0x3126},\n\t{NAU8540_REG_FLL3, 0x0008},\n\t{NAU8540_REG_FLL4, 0x0010},\n\t{NAU8540_REG_FLL5, 0xC000},\n\t{NAU8540_REG_FLL6, 0x6000},\n\t{NAU8540_REG_FLL_VCO_RSV, 0xF13C},\n\t{NAU8540_REG_PCM_CTRL0, 0x000B},\n\t{NAU8540_REG_PCM_CTRL1, 0x3010},\n\t{NAU8540_REG_PCM_CTRL2, 0x0800},\n\t{NAU8540_REG_PCM_CTRL3, 0x0000},\n\t{NAU8540_REG_PCM_CTRL4, 0x000F},\n\t{NAU8540_REG_ALC_CONTROL_1, 0x0000},\n\t{NAU8540_REG_ALC_CONTROL_2, 0x700B},\n\t{NAU8540_REG_ALC_CONTROL_3, 0x0022},\n\t{NAU8540_REG_ALC_CONTROL_4, 0x1010},\n\t{NAU8540_REG_ALC_CONTROL_5, 0x1010},\n\t{NAU8540_REG_NOTCH_FIL1_CH1, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL2_CH1, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL1_CH2, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL2_CH2, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL1_CH3, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL2_CH3, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL1_CH4, 0x0000},\n\t{NAU8540_REG_NOTCH_FIL2_CH4, 0x0000},\n\t{NAU8540_REG_HPF_FILTER_CH12, 0x0000},\n\t{NAU8540_REG_HPF_FILTER_CH34, 0x0000},\n\t{NAU8540_REG_ADC_SAMPLE_RATE, 0x0002},\n\t{NAU8540_REG_DIGITAL_GAIN_CH1, 0x0400},\n\t{NAU8540_REG_DIGITAL_GAIN_CH2, 0x0400},\n\t{NAU8540_REG_DIGITAL_GAIN_CH3, 0x0400},\n\t{NAU8540_REG_DIGITAL_GAIN_CH4, 0x0400},\n\t{NAU8540_REG_DIGITAL_MUX, 0x00E4},\n\t{NAU8540_REG_GPIO_CTRL, 0x0000},\n\t{NAU8540_REG_MISC_CTRL, 0x0000},\n\t{NAU8540_REG_I2C_CTRL, 0xEFFF},\n\t{NAU8540_REG_VMID_CTRL, 0x0000},\n\t{NAU8540_REG_MUTE, 0x0000},\n\t{NAU8540_REG_ANALOG_ADC1, 0x0011},\n\t{NAU8540_REG_ANALOG_ADC2, 0x0020},\n\t{NAU8540_REG_ANALOG_PWR, 0x0000},\n\t{NAU8540_REG_MIC_BIAS, 0x0004},\n\t{NAU8540_REG_REFERENCE, 0x0000},\n\t{NAU8540_REG_FEPGA1, 0x0000},\n\t{NAU8540_REG_FEPGA2, 0x0000},\n\t{NAU8540_REG_FEPGA3, 0x0101},\n\t{NAU8540_REG_FEPGA4, 0x0101},\n\t{NAU8540_REG_PWR, 0x0000},\n};\n\nstatic bool nau8540_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8540_REG_POWER_MANAGEMENT ... NAU8540_REG_FLL_VCO_RSV:\n\tcase NAU8540_REG_PCM_CTRL0 ... NAU8540_REG_PCM_CTRL4:\n\tcase NAU8540_REG_ALC_CONTROL_1 ... NAU8540_REG_ALC_CONTROL_5:\n\tcase NAU8540_REG_ALC_GAIN_CH12 ... NAU8540_REG_ADC_SAMPLE_RATE:\n\tcase NAU8540_REG_DIGITAL_GAIN_CH1 ... NAU8540_REG_DIGITAL_MUX:\n\tcase NAU8540_REG_P2P_CH1 ... NAU8540_REG_I2C_CTRL:\n\tcase NAU8540_REG_I2C_DEVICE_ID:\n\tcase NAU8540_REG_VMID_CTRL ... NAU8540_REG_MUTE:\n\tcase NAU8540_REG_ANALOG_ADC1 ... NAU8540_REG_PWR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\nstatic bool nau8540_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8540_REG_SW_RESET ... NAU8540_REG_FLL_VCO_RSV:\n\tcase NAU8540_REG_PCM_CTRL0 ... NAU8540_REG_PCM_CTRL4:\n\tcase NAU8540_REG_ALC_CONTROL_1 ... NAU8540_REG_ALC_CONTROL_5:\n\tcase NAU8540_REG_NOTCH_FIL1_CH1 ... NAU8540_REG_ADC_SAMPLE_RATE:\n\tcase NAU8540_REG_DIGITAL_GAIN_CH1 ... NAU8540_REG_DIGITAL_MUX:\n\tcase NAU8540_REG_GPIO_CTRL ... NAU8540_REG_I2C_CTRL:\n\tcase NAU8540_REG_RST:\n\tcase NAU8540_REG_VMID_CTRL ... NAU8540_REG_MUTE:\n\tcase NAU8540_REG_ANALOG_ADC1 ... NAU8540_REG_PWR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8540_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8540_REG_SW_RESET:\n\tcase NAU8540_REG_ALC_GAIN_CH12 ... NAU8540_REG_ALC_STATUS:\n\tcase NAU8540_REG_P2P_CH1 ... NAU8540_REG_PEAK_CH4:\n\tcase NAU8540_REG_I2C_DEVICE_ID:\n\tcase NAU8540_REG_RST:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n\nstatic const DECLARE_TLV_DB_MINMAX(adc_vol_tlv, -12800, 3600);\nstatic const DECLARE_TLV_DB_MINMAX(fepga_gain_tlv, -100, 3600);\n\nstatic const struct snd_kcontrol_new nau8540_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Mic1 Volume\", NAU8540_REG_DIGITAL_GAIN_CH1,\n\t\t0, 0x520, 0, adc_vol_tlv),\n\tSOC_SINGLE_TLV(\"Mic2 Volume\", NAU8540_REG_DIGITAL_GAIN_CH2,\n\t\t0, 0x520, 0, adc_vol_tlv),\n\tSOC_SINGLE_TLV(\"Mic3 Volume\", NAU8540_REG_DIGITAL_GAIN_CH3,\n\t\t0, 0x520, 0, adc_vol_tlv),\n\tSOC_SINGLE_TLV(\"Mic4 Volume\", NAU8540_REG_DIGITAL_GAIN_CH4,\n\t\t0, 0x520, 0, adc_vol_tlv),\n\n\tSOC_SINGLE_TLV(\"Frontend PGA1 Volume\", NAU8540_REG_FEPGA3,\n\t\t0, 0x25, 0, fepga_gain_tlv),\n\tSOC_SINGLE_TLV(\"Frontend PGA2 Volume\", NAU8540_REG_FEPGA3,\n\t\t8, 0x25, 0, fepga_gain_tlv),\n\tSOC_SINGLE_TLV(\"Frontend PGA3 Volume\", NAU8540_REG_FEPGA4,\n\t\t0, 0x25, 0, fepga_gain_tlv),\n\tSOC_SINGLE_TLV(\"Frontend PGA4 Volume\", NAU8540_REG_FEPGA4,\n\t\t8, 0x25, 0, fepga_gain_tlv),\n};\n\nstatic const char * const adc_channel[] = {\n\t\"ADC channel 1\", \"ADC channel 2\", \"ADC channel 3\", \"ADC channel 4\"\n};\nstatic SOC_ENUM_SINGLE_DECL(\n\tdigital_ch4_enum, NAU8540_REG_DIGITAL_MUX, 6, adc_channel);\n\nstatic const struct snd_kcontrol_new digital_ch4_mux =\n\tSOC_DAPM_ENUM(\"Digital CH4 Select\", digital_ch4_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tdigital_ch3_enum, NAU8540_REG_DIGITAL_MUX, 4, adc_channel);\n\nstatic const struct snd_kcontrol_new digital_ch3_mux =\n\tSOC_DAPM_ENUM(\"Digital CH3 Select\", digital_ch3_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tdigital_ch2_enum, NAU8540_REG_DIGITAL_MUX, 2, adc_channel);\n\nstatic const struct snd_kcontrol_new digital_ch2_mux =\n\tSOC_DAPM_ENUM(\"Digital CH2 Select\", digital_ch2_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tdigital_ch1_enum, NAU8540_REG_DIGITAL_MUX, 0, adc_channel);\n\nstatic const struct snd_kcontrol_new digital_ch1_mux =\n\tSOC_DAPM_ENUM(\"Digital CH1 Select\", digital_ch1_enum);\n\nstatic int adc_power_control(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\tmsleep(300);\n\t\t \n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL1,\n\t\t\tNAU8540_I2S_DO12_TRI, 0);\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL2,\n\t\t\tNAU8540_I2S_DO34_TRI, 0);\n\t} else if (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL1,\n\t\t\tNAU8540_I2S_DO12_TRI, NAU8540_I2S_DO12_TRI);\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL2,\n\t\t\tNAU8540_I2S_DO34_TRI, NAU8540_I2S_DO34_TRI);\n\t}\n\treturn 0;\n}\n\nstatic int aiftx_power_control(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tregmap_write(nau8540->regmap, NAU8540_REG_RST, 0x0001);\n\t\tregmap_write(nau8540->regmap, NAU8540_REG_RST, 0x0000);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget nau8540_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS2\", NAU8540_REG_MIC_BIAS, 11, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS1\", NAU8540_REG_MIC_BIAS, 10, 0, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"MIC3\"),\n\tSND_SOC_DAPM_INPUT(\"MIC4\"),\n\n\tSND_SOC_DAPM_PGA(\"Frontend PGA1\", NAU8540_REG_PWR, 12, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Frontend PGA2\", NAU8540_REG_PWR, 13, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Frontend PGA3\", NAU8540_REG_PWR, 14, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Frontend PGA4\", NAU8540_REG_PWR, 15, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC_E(\"ADC1\", NULL,\n\t\tNAU8540_REG_POWER_MANAGEMENT, 0, 0, adc_power_control,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC2\", NULL,\n\t\tNAU8540_REG_POWER_MANAGEMENT, 1, 0, adc_power_control,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC3\", NULL,\n\t\tNAU8540_REG_POWER_MANAGEMENT, 2, 0, adc_power_control,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC4\", NULL,\n\t\tNAU8540_REG_POWER_MANAGEMENT, 3, 0, adc_power_control,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_PGA(\"ADC CH1\", NAU8540_REG_ANALOG_PWR, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC CH2\", NAU8540_REG_ANALOG_PWR, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC CH3\", NAU8540_REG_ANALOG_PWR, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC CH4\", NAU8540_REG_ANALOG_PWR, 3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Digital CH4 Mux\",\n\t\tSND_SOC_NOPM, 0, 0, &digital_ch4_mux),\n\tSND_SOC_DAPM_MUX(\"Digital CH3 Mux\",\n\t\tSND_SOC_NOPM, 0, 0, &digital_ch3_mux),\n\tSND_SOC_DAPM_MUX(\"Digital CH2 Mux\",\n\t\tSND_SOC_NOPM, 0, 0, &digital_ch2_mux),\n\tSND_SOC_DAPM_MUX(\"Digital CH1 Mux\",\n\t\tSND_SOC_NOPM, 0, 0, &digital_ch1_mux),\n\n\tSND_SOC_DAPM_AIF_OUT_E(\"AIFTX\", \"Capture\", 0, SND_SOC_NOPM, 0, 0,\n\t\taiftx_power_control, SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route nau8540_dapm_routes[] = {\n\t{\"Frontend PGA1\", NULL, \"MIC1\"},\n\t{\"Frontend PGA2\", NULL, \"MIC2\"},\n\t{\"Frontend PGA3\", NULL, \"MIC3\"},\n\t{\"Frontend PGA4\", NULL, \"MIC4\"},\n\n\t{\"ADC1\", NULL, \"Frontend PGA1\"},\n\t{\"ADC2\", NULL, \"Frontend PGA2\"},\n\t{\"ADC3\", NULL, \"Frontend PGA3\"},\n\t{\"ADC4\", NULL, \"Frontend PGA4\"},\n\n\t{\"ADC CH1\", NULL, \"ADC1\"},\n\t{\"ADC CH2\", NULL, \"ADC2\"},\n\t{\"ADC CH3\", NULL, \"ADC3\"},\n\t{\"ADC CH4\", NULL, \"ADC4\"},\n\n\t{\"ADC1\", NULL, \"MICBIAS1\"},\n\t{\"ADC2\", NULL, \"MICBIAS1\"},\n\t{\"ADC3\", NULL, \"MICBIAS2\"},\n\t{\"ADC4\", NULL, \"MICBIAS2\"},\n\n\t{\"Digital CH1 Mux\", \"ADC channel 1\", \"ADC CH1\"},\n\t{\"Digital CH1 Mux\", \"ADC channel 2\", \"ADC CH2\"},\n\t{\"Digital CH1 Mux\", \"ADC channel 3\", \"ADC CH3\"},\n\t{\"Digital CH1 Mux\", \"ADC channel 4\", \"ADC CH4\"},\n\n\t{\"Digital CH2 Mux\", \"ADC channel 1\", \"ADC CH1\"},\n\t{\"Digital CH2 Mux\", \"ADC channel 2\", \"ADC CH2\"},\n\t{\"Digital CH2 Mux\", \"ADC channel 3\", \"ADC CH3\"},\n\t{\"Digital CH2 Mux\", \"ADC channel 4\", \"ADC CH4\"},\n\n\t{\"Digital CH3 Mux\", \"ADC channel 1\", \"ADC CH1\"},\n\t{\"Digital CH3 Mux\", \"ADC channel 2\", \"ADC CH2\"},\n\t{\"Digital CH3 Mux\", \"ADC channel 3\", \"ADC CH3\"},\n\t{\"Digital CH3 Mux\", \"ADC channel 4\", \"ADC CH4\"},\n\n\t{\"Digital CH4 Mux\", \"ADC channel 1\", \"ADC CH1\"},\n\t{\"Digital CH4 Mux\", \"ADC channel 2\", \"ADC CH2\"},\n\t{\"Digital CH4 Mux\", \"ADC channel 3\", \"ADC CH3\"},\n\t{\"Digital CH4 Mux\", \"ADC channel 4\", \"ADC CH4\"},\n\n\t{\"AIFTX\", NULL, \"Digital CH1 Mux\"},\n\t{\"AIFTX\", NULL, \"Digital CH2 Mux\"},\n\t{\"AIFTX\", NULL, \"Digital CH3 Mux\"},\n\t{\"AIFTX\", NULL, \"Digital CH4 Mux\"},\n};\n\nstatic const struct nau8540_osr_attr *\nnau8540_get_osr(struct nau8540 *nau8540)\n{\n\tunsigned int osr;\n\n\tregmap_read(nau8540->regmap, NAU8540_REG_ADC_SAMPLE_RATE, &osr);\n\tosr &= NAU8540_ADC_OSR_MASK;\n\tif (osr >= ARRAY_SIZE(osr_adc_sel))\n\t\treturn NULL;\n\treturn &osr_adc_sel[osr];\n}\n\nstatic int nau8540_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\tconst struct nau8540_osr_attr *osr;\n\n\tosr = nau8540_get_osr(nau8540);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    0, CLK_ADC_MAX / osr->osr);\n}\n\nstatic int nau8540_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0;\n\tconst struct nau8540_osr_attr *osr;\n\n\t \n\tosr = nau8540_get_osr(nau8540);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\tif (params_rate(params) * osr->osr > CLK_ADC_MAX)\n\t\treturn -EINVAL;\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_CLOCK_SRC,\n\t\tNAU8540_CLK_ADC_SRC_MASK,\n\t\tosr->clk_src << NAU8540_CLK_ADC_SRC_SFT);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= NAU8540_I2S_DL_16;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= NAU8540_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= NAU8540_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len |= NAU8540_I2S_DL_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL0,\n\t\tNAU8540_I2S_DL_MASK, val_len);\n\n\treturn 0;\n}\n\nstatic int nau8540_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl1_val = 0, ctrl2_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl2_val |= NAU8540_I2S_MS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= NAU8540_I2S_BP_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= NAU8540_I2S_DF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= NAU8540_I2S_DF_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl1_val |= NAU8540_I2S_DF_RIGTH;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= NAU8540_I2S_DF_PCM_AB;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl1_val |= NAU8540_I2S_DF_PCM_AB;\n\t\tctrl1_val |= NAU8540_I2S_PCMB_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL0,\n\t\tNAU8540_I2S_DL_MASK | NAU8540_I2S_DF_MASK |\n\t\tNAU8540_I2S_BP_INV | NAU8540_I2S_PCMB_EN, ctrl1_val);\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL1,\n\t\tNAU8540_I2S_MS_MASK | NAU8540_I2S_DO12_OE, ctrl2_val);\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL2,\n\t\tNAU8540_I2S_DO34_OE, 0);\n\n\treturn 0;\n}\n\n \nstatic int nau8540_set_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl2_val = 0, ctrl4_val = 0;\n\n\tif (slots > 4 || ((tx_mask & 0xf0) && (tx_mask & 0xf)))\n\t\treturn -EINVAL;\n\n\tctrl4_val |= (NAU8540_TDM_MODE | NAU8540_TDM_OFFSET_EN);\n\tif (tx_mask & 0xf0) {\n\t\tctrl2_val = 4 * slot_width;\n\t\tctrl4_val |= (tx_mask >> 4);\n\t} else {\n\t\tctrl4_val |= tx_mask;\n\t}\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL4,\n\t\tNAU8540_TDM_MODE | NAU8540_TDM_OFFSET_EN |\n\t\tNAU8540_TDM_TX_MASK, ctrl4_val);\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL1,\n\t\tNAU8540_I2S_DO12_OE, NAU8540_I2S_DO12_OE);\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL2,\n\t\tNAU8540_I2S_DO34_OE | NAU8540_I2S_TSLOT_L_MASK,\n\t\tNAU8540_I2S_DO34_OE | ctrl2_val);\n\n\treturn 0;\n}\n\n\nstatic const struct snd_soc_dai_ops nau8540_dai_ops = {\n\t.startup = nau8540_dai_startup,\n\t.hw_params = nau8540_hw_params,\n\t.set_fmt = nau8540_set_fmt,\n\t.set_tdm_slot = nau8540_set_tdm_slot,\n};\n\n#define NAU8540_RATES SNDRV_PCM_RATE_8000_48000\n#define NAU8540_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver nau8540_dai = {\n\t.name = \"nau8540-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 4,\n\t\t.rates = NAU8540_RATES,\n\t\t.formats = NAU8540_FORMATS,\n\t},\n\t.ops = &nau8540_dai_ops,\n};\n\n \nstatic int nau8540_calc_fll_param(unsigned int fll_in,\n\tunsigned int fs, struct nau8540_fll *fll_param)\n{\n\tu64 fvco, fvco_max;\n\tunsigned int fref, i, fvco_sel;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_pre_scalar); i++) {\n\t\tfref = fll_in / fll_pre_scalar[i].param;\n\t\tif (fref <= NAU_FREF_MAX)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_pre_scalar))\n\t\treturn -EINVAL;\n\tfll_param->clk_ref_div = fll_pre_scalar[i].val;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_ratio); i++) {\n\t\tif (fref >= fll_ratio[i].param)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_ratio))\n\t\treturn -EINVAL;\n\tfll_param->ratio = fll_ratio[i].val;\n\n\t \n\tfvco_max = 0;\n\tfvco_sel = ARRAY_SIZE(mclk_src_scaling);\n\tfor (i = 0; i < ARRAY_SIZE(mclk_src_scaling); i++) {\n\t\tfvco = 256ULL * fs * 2 * mclk_src_scaling[i].param;\n\t\tif (fvco > NAU_FVCO_MIN && fvco < NAU_FVCO_MAX &&\n\t\t\tfvco_max < fvco) {\n\t\t\tfvco_max = fvco;\n\t\t\tfvco_sel = i;\n\t\t}\n\t}\n\tif (ARRAY_SIZE(mclk_src_scaling) == fvco_sel)\n\t\treturn -EINVAL;\n\tfll_param->mclk_src = mclk_src_scaling[fvco_sel].val;\n\n\t \n\tfvco = div_u64(fvco_max << 16, fref * fll_param->ratio);\n\tfll_param->fll_int = (fvco >> 16) & 0x3FF;\n\tfll_param->fll_frac = fvco & 0xFFFF;\n\treturn 0;\n}\n\nstatic void nau8540_fll_apply(struct regmap *regmap,\n\tstruct nau8540_fll *fll_param)\n{\n\tregmap_update_bits(regmap, NAU8540_REG_CLOCK_SRC,\n\t\tNAU8540_CLK_SRC_MASK | NAU8540_CLK_MCLK_SRC_MASK,\n\t\tNAU8540_CLK_SRC_MCLK | fll_param->mclk_src);\n\tregmap_update_bits(regmap, NAU8540_REG_FLL1,\n\t\tNAU8540_FLL_RATIO_MASK | NAU8540_ICTRL_LATCH_MASK,\n\t\tfll_param->ratio | (0x6 << NAU8540_ICTRL_LATCH_SFT));\n\t \n\tregmap_write(regmap, NAU8540_REG_FLL2, fll_param->fll_frac);\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_FLL3,\n\t\tNAU8540_FLL_INTEGER_MASK, fll_param->fll_int);\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_FLL4,\n\t\tNAU8540_FLL_REF_DIV_MASK,\n\t\tfll_param->clk_ref_div << NAU8540_FLL_REF_DIV_SFT);\n\tregmap_update_bits(regmap, NAU8540_REG_FLL5,\n\t\tNAU8540_FLL_CLK_SW_MASK, NAU8540_FLL_CLK_SW_REF);\n\tregmap_update_bits(regmap,\n\t\tNAU8540_REG_FLL6, NAU8540_DCO_EN, 0);\n\tif (fll_param->fll_frac) {\n\t\tregmap_update_bits(regmap, NAU8540_REG_FLL5,\n\t\t\tNAU8540_FLL_PDB_DAC_EN | NAU8540_FLL_LOOP_FTR_EN |\n\t\t\tNAU8540_FLL_FTR_SW_MASK,\n\t\t\tNAU8540_FLL_PDB_DAC_EN | NAU8540_FLL_LOOP_FTR_EN |\n\t\t\tNAU8540_FLL_FTR_SW_FILTER);\n\t\tregmap_update_bits(regmap, NAU8540_REG_FLL6,\n\t\t\tNAU8540_SDM_EN | NAU8540_CUTOFF500,\n\t\t\tNAU8540_SDM_EN | NAU8540_CUTOFF500);\n\t} else {\n\t\tregmap_update_bits(regmap, NAU8540_REG_FLL5,\n\t\t\tNAU8540_FLL_PDB_DAC_EN | NAU8540_FLL_LOOP_FTR_EN |\n\t\t\tNAU8540_FLL_FTR_SW_MASK, NAU8540_FLL_FTR_SW_ACCU);\n\t\tregmap_update_bits(regmap, NAU8540_REG_FLL6,\n\t\t\tNAU8540_SDM_EN | NAU8540_CUTOFF500, 0);\n\t}\n}\n\n \nstatic int nau8540_set_pll(struct snd_soc_component *component, int pll_id, int source,\n\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\tstruct nau8540_fll fll_param;\n\tint ret, fs;\n\n\tswitch (pll_id) {\n\tcase NAU8540_CLK_FLL_MCLK:\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_FLL3,\n\t\t\tNAU8540_FLL_CLK_SRC_MASK | NAU8540_GAIN_ERR_MASK,\n\t\t\tNAU8540_FLL_CLK_SRC_MCLK | 0);\n\t\tbreak;\n\n\tcase NAU8540_CLK_FLL_BLK:\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_FLL3,\n\t\t\tNAU8540_FLL_CLK_SRC_MASK | NAU8540_GAIN_ERR_MASK,\n\t\t\tNAU8540_FLL_CLK_SRC_BLK |\n\t\t\t(0xf << NAU8540_GAIN_ERR_SFT));\n\t\tbreak;\n\n\tcase NAU8540_CLK_FLL_FS:\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_FLL3,\n\t\t\tNAU8540_FLL_CLK_SRC_MASK | NAU8540_GAIN_ERR_MASK,\n\t\t\tNAU8540_FLL_CLK_SRC_FS |\n\t\t\t(0xf << NAU8540_GAIN_ERR_SFT));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(nau8540->dev, \"Invalid clock id (%d)\\n\", pll_id);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(nau8540->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq_out, pll_id);\n\n\tfs = freq_out / 256;\n\tret = nau8540_calc_fll_param(freq_in, fs, &fll_param);\n\tif (ret < 0) {\n\t\tdev_err(nau8540->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\tdev_dbg(nau8540->dev, \"mclk_src=%x ratio=%x fll_frac=%x fll_int=%x clk_ref_div=%x\\n\",\n\t\tfll_param.mclk_src, fll_param.ratio, fll_param.fll_frac,\n\t\tfll_param.fll_int, fll_param.clk_ref_div);\n\n\tnau8540_fll_apply(nau8540->regmap, &fll_param);\n\tmdelay(2);\n\tregmap_update_bits(nau8540->regmap, NAU8540_REG_CLOCK_SRC,\n\t\tNAU8540_CLK_SRC_MASK, NAU8540_CLK_SRC_VCO);\n\n\treturn 0;\n}\n\nstatic int nau8540_set_sysclk(struct snd_soc_component *component,\n\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase NAU8540_CLK_DIS:\n\tcase NAU8540_CLK_MCLK:\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_CLOCK_SRC,\n\t\t\tNAU8540_CLK_SRC_MASK, NAU8540_CLK_SRC_MCLK);\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_FLL6,\n\t\t\tNAU8540_DCO_EN, 0);\n\t\tbreak;\n\n\tcase NAU8540_CLK_INTERNAL:\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_FLL6,\n\t\t\tNAU8540_DCO_EN, NAU8540_DCO_EN);\n\t\tregmap_update_bits(nau8540->regmap, NAU8540_REG_CLOCK_SRC,\n\t\t\tNAU8540_CLK_SRC_MASK, NAU8540_CLK_SRC_VCO);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(nau8540->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(nau8540->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq, clk_id);\n\n\treturn 0;\n}\n\nstatic void nau8540_reset_chip(struct regmap *regmap)\n{\n\tregmap_write(regmap, NAU8540_REG_SW_RESET, 0x00);\n\tregmap_write(regmap, NAU8540_REG_SW_RESET, 0x00);\n}\n\nstatic void nau8540_init_regs(struct nau8540 *nau8540)\n{\n\tstruct regmap *regmap = nau8540->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_VMID_CTRL,\n\t\tNAU8540_VMID_EN | NAU8540_VMID_SEL_MASK,\n\t\tNAU8540_VMID_EN | (0x2 << NAU8540_VMID_SEL_SFT));\n\tregmap_update_bits(regmap, NAU8540_REG_REFERENCE,\n\t\tNAU8540_PRECHARGE_DIS | NAU8540_GLOBAL_BIAS_EN,\n\t\tNAU8540_PRECHARGE_DIS | NAU8540_GLOBAL_BIAS_EN);\n\tmdelay(2);\n\tregmap_update_bits(regmap, NAU8540_REG_MIC_BIAS,\n\t\tNAU8540_PU_PRE, NAU8540_PU_PRE);\n\tregmap_update_bits(regmap, NAU8540_REG_CLOCK_CTRL,\n\t\tNAU8540_CLK_ADC_EN | NAU8540_CLK_I2S_EN,\n\t\tNAU8540_CLK_ADC_EN | NAU8540_CLK_I2S_EN);\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_ADC_SAMPLE_RATE,\n\t\tNAU8540_CH_SYNC | NAU8540_ADC_OSR_MASK,\n\t\tNAU8540_CH_SYNC | NAU8540_ADC_OSR_64);\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_FEPGA1,\n\t\tNAU8540_FEPGA1_MODCH2_SHT | NAU8540_FEPGA1_MODCH1_SHT,\n\t\tNAU8540_FEPGA1_MODCH2_SHT | NAU8540_FEPGA1_MODCH1_SHT);\n\tregmap_update_bits(regmap, NAU8540_REG_FEPGA2,\n\t\tNAU8540_FEPGA2_MODCH4_SHT | NAU8540_FEPGA2_MODCH3_SHT,\n\t\tNAU8540_FEPGA2_MODCH4_SHT | NAU8540_FEPGA2_MODCH3_SHT);\n\t \n\tregmap_update_bits(regmap, NAU8540_REG_PCM_CTRL1,\n\t\tNAU8540_I2S_DO12_TRI, NAU8540_I2S_DO12_TRI);\n\tregmap_update_bits(regmap, NAU8540_REG_PCM_CTRL2,\n\t\tNAU8540_I2S_DO34_TRI, NAU8540_I2S_DO34_TRI);\n}\n\nstatic int __maybe_unused nau8540_suspend(struct snd_soc_component *component)\n{\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(nau8540->regmap, true);\n\tregcache_mark_dirty(nau8540->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8540_resume(struct snd_soc_component *component)\n{\n\tstruct nau8540 *nau8540 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(nau8540->regmap, false);\n\tregcache_sync(nau8540->regmap);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver nau8540_component_driver = {\n\t.set_sysclk\t\t= nau8540_set_sysclk,\n\t.set_pll\t\t= nau8540_set_pll,\n\t.suspend\t\t= nau8540_suspend,\n\t.resume\t\t\t= nau8540_resume,\n\t.controls\t\t= nau8540_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(nau8540_snd_controls),\n\t.dapm_widgets\t\t= nau8540_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(nau8540_dapm_widgets),\n\t.dapm_routes\t\t= nau8540_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(nau8540_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config nau8540_regmap_config = {\n\t.val_bits = 16,\n\t.reg_bits = 16,\n\n\t.max_register = NAU8540_REG_MAX,\n\t.readable_reg = nau8540_readable_reg,\n\t.writeable_reg = nau8540_writeable_reg,\n\t.volatile_reg = nau8540_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8540_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8540_reg_defaults),\n};\n\nstatic int nau8540_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8540 *nau8540 = dev_get_platdata(dev);\n\tint ret, value;\n\n\tif (!nau8540) {\n\t\tnau8540 = devm_kzalloc(dev, sizeof(*nau8540), GFP_KERNEL);\n\t\tif (!nau8540)\n\t\t\treturn -ENOMEM;\n\t}\n\ti2c_set_clientdata(i2c, nau8540);\n\n\tnau8540->regmap = devm_regmap_init_i2c(i2c, &nau8540_regmap_config);\n\tif (IS_ERR(nau8540->regmap))\n\t\treturn PTR_ERR(nau8540->regmap);\n\tret = regmap_read(nau8540->regmap, NAU8540_REG_I2C_DEVICE_ID, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device id from the NAU85L40: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tnau8540->dev = dev;\n\tnau8540_reset_chip(nau8540->regmap);\n\tnau8540_init_regs(nau8540);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t&nau8540_component_driver, &nau8540_dai, 1);\n}\n\nstatic const struct i2c_device_id nau8540_i2c_ids[] = {\n\t{ \"nau8540\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8540_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8540_of_ids[] = {\n\t{ .compatible = \"nuvoton,nau8540\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nau8540_of_ids);\n#endif\n\nstatic struct i2c_driver nau8540_i2c_driver = {\n\t.driver = {\n\t\t.name = \"nau8540\",\n\t\t.of_match_table = of_match_ptr(nau8540_of_ids),\n\t},\n\t.probe = nau8540_i2c_probe,\n\t.id_table = nau8540_i2c_ids,\n};\nmodule_i2c_driver(nau8540_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC NAU85L40 driver\");\nMODULE_AUTHOR(\"John Hsu <KCHSU0@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}