{
  "module_name": "cs42l73.c",
  "hash_id": "17de2cf97edd8463c9385d1d341ec51e9338d31b8a551a32dd9c3235ab059a6c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l73.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of_gpio.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs42l73.h>\n#include \"cs42l73.h\"\n#include \"cirrus_legacy.h\"\n\nstruct sp_config {\n\tu8 spc, mmcc, spfs;\n\tu32 srate;\n};\nstruct  cs42l73_private {\n\tstruct cs42l73_platform_data pdata;\n\tstruct sp_config config[3];\n\tstruct regmap *regmap;\n\tu32 sysclk;\n\tu8 mclksel;\n\tu32 mclk;\n\tint shutdwn_delay;\n};\n\nstatic const struct reg_default cs42l73_reg_defaults[] = {\n\t{ 6, 0xF1 },\t \n\t{ 7, 0xDF },\t \n\t{ 8, 0x3F },\t \n\t{ 9, 0x50 },\t \n\t{ 10, 0x53 },\t \n\t{ 11, 0x00 },\t \n\t{ 12, 0x00 },\t \n\t{ 13, 0x15 },\t \n\t{ 14, 0x00 },\t \n\t{ 15, 0x15 },\t \n\t{ 16, 0x00 },\t \n\t{ 17, 0x15 },\t \n\t{ 18, 0x00 },\t \n\t{ 19, 0x06 },\t \n\t{ 20, 0x00 },\t \n\t{ 21, 0x00 },\t \n\t{ 22, 0x00 },\t \n\t{ 23, 0x00 },\t \n\t{ 24, 0x00 },\t \n\t{ 25, 0x00 },\t \n\t{ 26, 0x00 },\t \n\t{ 27, 0x00 },\t \n\t{ 28, 0x00 },\t \n\t{ 29, 0x00 },\t \n\t{ 30, 0x00 },\t \n\t{ 31, 0x00 },\t \n\t{ 32, 0x00 },\t \n\t{ 33, 0x00 },\t \n\t{ 34, 0x00 },\t \n\t{ 35, 0x00 },\t \n\t{ 36, 0x00 },\t \n\t{ 37, 0x00 },\t \n\t{ 38, 0x00 },\t \n\t{ 39, 0x7F },\t \n\t{ 40, 0x00 },\t \n\t{ 41, 0x00 },\t \n\t{ 42, 0x3F },\t \n\t{ 43, 0x00 },\t \n\t{ 44, 0x00 },\t \n\t{ 45, 0x3F },\t \n\t{ 46, 0x00 },\t \n\t{ 47, 0x00 },\t \n\t{ 48, 0x3F },\t \n\t{ 49, 0x00 },\t \n\t{ 50, 0x00 },\t \n\t{ 51, 0x00 },\t \n\t{ 52, 0x18 },\t \n\t{ 53, 0x3F },\t \n\t{ 54, 0x3F },\t \n\t{ 55, 0x3F },\t \n\t{ 56, 0x3F },\t \n\t{ 57, 0x3F },\t \n\t{ 58, 0x3F },\t \n\t{ 59, 0x3F },\t \n\t{ 60, 0x3F },\t \n\t{ 61, 0x3F },\t \n\t{ 62, 0x3F },\t \n\t{ 63, 0x3F },\t \n\t{ 64, 0x3F },\t \n\t{ 65, 0x3F },\t \n\t{ 66, 0x3F },\t \n\t{ 67, 0x3F },\t \n\t{ 68, 0x3F },\t \n\t{ 69, 0x3F },\t \n\t{ 70, 0x3F },\t \n\t{ 71, 0x3F },\t \n\t{ 72, 0x3F },\t \n\t{ 73, 0x3F },\t \n\t{ 74, 0x3F },\t \n\t{ 75, 0x3F },\t \n\t{ 76, 0x3F },\t \n\t{ 77, 0x3F },\t \n\t{ 78, 0x3F },\t \n\t{ 79, 0x3F },\t \n\t{ 80, 0x3F },\t \n\t{ 81, 0x3F },\t \n\t{ 82, 0x3F },\t \n\t{ 83, 0x3F },\t \n\t{ 84, 0x3F },\t \n\t{ 85, 0xAA },\t \n\t{ 86, 0x3F },\t \n\t{ 87, 0x3F },\t \n\t{ 88, 0x3F },\t \n\t{ 89, 0x3F },\t \n\t{ 90, 0x3F },\t \n\t{ 91, 0x3F },\t \n\t{ 92, 0x3F },\t \n\t{ 93, 0x3F },\t \n\t{ 94, 0x00 },\t \n\t{ 95, 0x00 },\t \n};\n\nstatic bool cs42l73_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L73_IS1:\n\tcase CS42L73_IS2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42l73_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L73_DEVID_AB ... CS42L73_DEVID_E:\n\tcase CS42L73_REVID ... CS42L73_IM2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_RANGE(hpaloa_tlv,\n\t0, 13, TLV_DB_SCALE_ITEM(-7600, 200, 0),\n\t14, 75, TLV_DB_SCALE_ITEM(-4900, 100, 0)\n);\n\nstatic DECLARE_TLV_DB_SCALE(adc_boost_tlv, 0, 2500, 0);\n\nstatic DECLARE_TLV_DB_SCALE(hl_tlv, -10200, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(ipd_tlv, -9600, 100, 0);\n\nstatic DECLARE_TLV_DB_SCALE(micpga_tlv, -600, 50, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(limiter_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-3000, 600, 0),\n\t3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(attn_tlv, -6300, 100, 1);\n\nstatic const char * const cs42l73_pgaa_text[] = { \"Line A\", \"Mic 1\" };\nstatic const char * const cs42l73_pgab_text[] = { \"Line B\", \"Mic 2\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pgaa_enum,\n\t\t\t    CS42L73_ADCIPC, 3,\n\t\t\t    cs42l73_pgaa_text);\n\nstatic SOC_ENUM_SINGLE_DECL(pgab_enum,\n\t\t\t    CS42L73_ADCIPC, 7,\n\t\t\t    cs42l73_pgab_text);\n\nstatic const struct snd_kcontrol_new pgaa_mux =\n\tSOC_DAPM_ENUM(\"Left Analog Input Capture Mux\", pgaa_enum);\n\nstatic const struct snd_kcontrol_new pgab_mux =\n\tSOC_DAPM_ENUM(\"Right Analog Input Capture Mux\", pgab_enum);\n\nstatic const struct snd_kcontrol_new input_left_mixer[] = {\n\tSOC_DAPM_SINGLE(\"ADC Left Input\", CS42L73_PWRCTL1,\n\t\t\t5, 1, 1),\n\tSOC_DAPM_SINGLE(\"DMIC Left Input\", CS42L73_PWRCTL1,\n\t\t\t4, 1, 1),\n};\n\nstatic const struct snd_kcontrol_new input_right_mixer[] = {\n\tSOC_DAPM_SINGLE(\"ADC Right Input\", CS42L73_PWRCTL1,\n\t\t\t7, 1, 1),\n\tSOC_DAPM_SINGLE(\"DMIC Right Input\", CS42L73_PWRCTL1,\n\t\t\t6, 1, 1),\n};\n\nstatic const char * const cs42l73_ng_delay_text[] = {\n\t\"50ms\", \"100ms\", \"150ms\", \"200ms\" };\n\nstatic SOC_ENUM_SINGLE_DECL(ng_delay_enum,\n\t\t\t    CS42L73_NGCAB, 0,\n\t\t\t    cs42l73_ng_delay_text);\n\nstatic const char * const cs42l73_mono_mix_texts[] = {\n\t\"Left\", \"Right\", \"Mono Mix\"};\n\nstatic const unsigned int cs42l73_mono_mix_values[] = { 0, 1, 2 };\n\nstatic const struct soc_enum spk_asp_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L73_MMIXCTL, 6, 3,\n\t\t\t      ARRAY_SIZE(cs42l73_mono_mix_texts),\n\t\t\t      cs42l73_mono_mix_texts,\n\t\t\t      cs42l73_mono_mix_values);\n\nstatic const struct snd_kcontrol_new spk_asp_mixer =\n\tSOC_DAPM_ENUM(\"Route\", spk_asp_enum);\n\nstatic const struct soc_enum spk_xsp_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L73_MMIXCTL, 4, 3,\n\t\t\t      ARRAY_SIZE(cs42l73_mono_mix_texts),\n\t\t\t      cs42l73_mono_mix_texts,\n\t\t\t      cs42l73_mono_mix_values);\n\nstatic const struct snd_kcontrol_new spk_xsp_mixer =\n\tSOC_DAPM_ENUM(\"Route\", spk_xsp_enum);\n\nstatic const struct soc_enum esl_asp_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L73_MMIXCTL, 2, 3,\n\t\t\t      ARRAY_SIZE(cs42l73_mono_mix_texts),\n\t\t\t      cs42l73_mono_mix_texts,\n\t\t\t      cs42l73_mono_mix_values);\n\nstatic const struct snd_kcontrol_new esl_asp_mixer =\n\tSOC_DAPM_ENUM(\"Route\", esl_asp_enum);\n\nstatic const struct soc_enum esl_xsp_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L73_MMIXCTL, 0, 3,\n\t\t\t      ARRAY_SIZE(cs42l73_mono_mix_texts),\n\t\t\t      cs42l73_mono_mix_texts,\n\t\t\t      cs42l73_mono_mix_values);\n\nstatic const struct snd_kcontrol_new esl_xsp_mixer =\n\tSOC_DAPM_ENUM(\"Route\", esl_xsp_enum);\n\nstatic const char * const cs42l73_ip_swap_text[] = {\n\t\"Stereo\", \"Mono A\", \"Mono B\", \"Swap A-B\"};\n\nstatic SOC_ENUM_SINGLE_DECL(ip_swap_enum,\n\t\t\t    CS42L73_MIOPC, 6,\n\t\t\t    cs42l73_ip_swap_text);\n\nstatic const char * const cs42l73_spo_mixer_text[] = {\"Mono\", \"Stereo\"};\n\nstatic SOC_ENUM_SINGLE_DECL(vsp_output_mux_enum,\n\t\t\t    CS42L73_MIXERCTL, 5,\n\t\t\t    cs42l73_spo_mixer_text);\n\nstatic SOC_ENUM_SINGLE_DECL(xsp_output_mux_enum,\n\t\t\t    CS42L73_MIXERCTL, 4,\n\t\t\t    cs42l73_spo_mixer_text);\n\nstatic const struct snd_kcontrol_new hp_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L73_PWRCTL3, 0, 1, 1);\n\nstatic const struct snd_kcontrol_new lo_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L73_PWRCTL3, 1, 1, 1);\n\nstatic const struct snd_kcontrol_new spk_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L73_PWRCTL3, 2, 1, 1);\n\nstatic const struct snd_kcontrol_new spklo_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L73_PWRCTL3, 4, 1, 1);\n\nstatic const struct snd_kcontrol_new ear_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L73_PWRCTL3, 3, 1, 1);\n\nstatic const struct snd_kcontrol_new cs42l73_snd_controls[] = {\n\tSOC_DOUBLE_R_SX_TLV(\"Headphone Analog Playback Volume\",\n\t\t\tCS42L73_HPAAVOL, CS42L73_HPBAVOL, 0,\n\t\t\t0x41, 0x4B, hpaloa_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"LineOut Analog Playback Volume\", CS42L73_LOAAVOL,\n\t\t\tCS42L73_LOBAVOL, 0, 0x41, 0x4B, hpaloa_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Input PGA Analog Volume\", CS42L73_MICAPREPGAAVOL,\n\t\t\tCS42L73_MICBPREPGABVOL, 0, 0x34,\n\t\t\t0x24, micpga_tlv),\n\n\tSOC_DOUBLE_R(\"MIC Preamp Switch\", CS42L73_MICAPREPGAAVOL,\n\t\t\tCS42L73_MICBPREPGABVOL, 6, 1, 1),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Input Path Digital Volume\", CS42L73_IPADVOL,\n\t\t\tCS42L73_IPBDVOL, 0, 0xA0, 0x6C, ipd_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"HL Digital Playback Volume\",\n\t\t\tCS42L73_HLADVOL, CS42L73_HLBDVOL,\n\t\t\t0, 0x34, 0xE4, hl_tlv),\n\n\tSOC_SINGLE_TLV(\"ADC A Boost Volume\",\n\t\t\tCS42L73_ADCIPC, 2, 0x01, 1, adc_boost_tlv),\n\n\tSOC_SINGLE_TLV(\"ADC B Boost Volume\",\n\t\t       CS42L73_ADCIPC, 6, 0x01, 1, adc_boost_tlv),\n\n\tSOC_SINGLE_SX_TLV(\"Speakerphone Digital Volume\",\n\t\t\t    CS42L73_SPKDVOL, 0, 0x34, 0xE4, hl_tlv),\n\n\tSOC_SINGLE_SX_TLV(\"Ear Speaker Digital Volume\",\n\t\t\t    CS42L73_ESLDVOL, 0, 0x34, 0xE4, hl_tlv),\n\n\tSOC_DOUBLE_R(\"Headphone Analog Playback Switch\", CS42L73_HPAAVOL,\n\t\t\tCS42L73_HPBAVOL, 7, 1, 1),\n\n\tSOC_DOUBLE_R(\"LineOut Analog Playback Switch\", CS42L73_LOAAVOL,\n\t\t\tCS42L73_LOBAVOL, 7, 1, 1),\n\tSOC_DOUBLE(\"Input Path Digital Switch\", CS42L73_ADCIPC, 0, 4, 1, 1),\n\tSOC_DOUBLE(\"HL Digital Playback Switch\", CS42L73_PBDC, 0,\n\t\t\t1, 1, 1),\n\tSOC_SINGLE(\"Speakerphone Digital Playback Switch\", CS42L73_PBDC, 2, 1,\n\t\t\t1),\n\tSOC_SINGLE(\"Ear Speaker Digital Playback Switch\", CS42L73_PBDC, 3, 1,\n\t\t\t1),\n\n\tSOC_SINGLE(\"PGA Soft-Ramp Switch\", CS42L73_MIOPC, 3, 1, 0),\n\tSOC_SINGLE(\"Analog Zero Cross Switch\", CS42L73_MIOPC, 2, 1, 0),\n\tSOC_SINGLE(\"Digital Soft-Ramp Switch\", CS42L73_MIOPC, 1, 1, 0),\n\tSOC_SINGLE(\"Analog Output Soft-Ramp Switch\", CS42L73_MIOPC, 0, 1, 0),\n\n\tSOC_DOUBLE(\"ADC Signal Polarity Switch\", CS42L73_ADCIPC, 1, 5, 1,\n\t\t\t0),\n\n\tSOC_SINGLE(\"HL Limiter Attack Rate\", CS42L73_LIMARATEHL, 0, 0x3F,\n\t\t\t0),\n\tSOC_SINGLE(\"HL Limiter Release Rate\", CS42L73_LIMRRATEHL, 0,\n\t\t\t0x3F, 0),\n\n\n\tSOC_SINGLE(\"HL Limiter Switch\", CS42L73_LIMRRATEHL, 7, 1, 0),\n\tSOC_SINGLE(\"HL Limiter All Channels Switch\", CS42L73_LIMRRATEHL, 6, 1,\n\t\t\t0),\n\n\tSOC_SINGLE_TLV(\"HL Limiter Max Threshold Volume\", CS42L73_LMAXHL, 5, 7,\n\t\t\t1, limiter_tlv),\n\n\tSOC_SINGLE_TLV(\"HL Limiter Cushion Volume\", CS42L73_LMAXHL, 2, 7, 1,\n\t\t\tlimiter_tlv),\n\n\tSOC_SINGLE(\"SPK Limiter Attack Rate Volume\", CS42L73_LIMARATESPK, 0,\n\t\t\t0x3F, 0),\n\tSOC_SINGLE(\"SPK Limiter Release Rate Volume\", CS42L73_LIMRRATESPK, 0,\n\t\t\t0x3F, 0),\n\tSOC_SINGLE(\"SPK Limiter Switch\", CS42L73_LIMRRATESPK, 7, 1, 0),\n\tSOC_SINGLE(\"SPK Limiter All Channels Switch\", CS42L73_LIMRRATESPK,\n\t\t\t6, 1, 0),\n\tSOC_SINGLE_TLV(\"SPK Limiter Max Threshold Volume\", CS42L73_LMAXSPK, 5,\n\t\t\t7, 1, limiter_tlv),\n\n\tSOC_SINGLE_TLV(\"SPK Limiter Cushion Volume\", CS42L73_LMAXSPK, 2, 7, 1,\n\t\t\tlimiter_tlv),\n\n\tSOC_SINGLE(\"ESL Limiter Attack Rate Volume\", CS42L73_LIMARATEESL, 0,\n\t\t\t0x3F, 0),\n\tSOC_SINGLE(\"ESL Limiter Release Rate Volume\", CS42L73_LIMRRATEESL, 0,\n\t\t\t0x3F, 0),\n\tSOC_SINGLE(\"ESL Limiter Switch\", CS42L73_LIMRRATEESL, 7, 1, 0),\n\tSOC_SINGLE_TLV(\"ESL Limiter Max Threshold Volume\", CS42L73_LMAXESL, 5,\n\t\t\t7, 1, limiter_tlv),\n\n\tSOC_SINGLE_TLV(\"ESL Limiter Cushion Volume\", CS42L73_LMAXESL, 2, 7, 1,\n\t\t\tlimiter_tlv),\n\n\tSOC_SINGLE(\"ALC Attack Rate Volume\", CS42L73_ALCARATE, 0, 0x3F, 0),\n\tSOC_SINGLE(\"ALC Release Rate Volume\", CS42L73_ALCRRATE, 0, 0x3F, 0),\n\tSOC_DOUBLE(\"ALC Switch\", CS42L73_ALCARATE, 6, 7, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Max Threshold Volume\", CS42L73_ALCMINMAX, 5, 7, 0,\n\t\t\tlimiter_tlv),\n\tSOC_SINGLE_TLV(\"ALC Min Threshold Volume\", CS42L73_ALCMINMAX, 2, 7, 0,\n\t\t\tlimiter_tlv),\n\n\tSOC_DOUBLE(\"NG Enable Switch\", CS42L73_NGCAB, 6, 7, 1, 0),\n\tSOC_SINGLE(\"NG Boost Switch\", CS42L73_NGCAB, 5, 1, 0),\n\t \n\tSOC_SINGLE(\"NG Threshold\", CS42L73_NGCAB, 2, 7, 0),\n\tSOC_ENUM(\"NG Delay\", ng_delay_enum),\n\n\tSOC_DOUBLE_R_TLV(\"XSP-IP Volume\",\n\t\t\tCS42L73_XSPAIPAA, CS42L73_XSPBIPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"XSP-XSP Volume\",\n\t\t\tCS42L73_XSPAXSPAA, CS42L73_XSPBXSPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"XSP-ASP Volume\",\n\t\t\tCS42L73_XSPAASPAA, CS42L73_XSPAASPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"XSP-VSP Volume\",\n\t\t\tCS42L73_XSPAVSPMA, CS42L73_XSPBVSPMA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"ASP-IP Volume\",\n\t\t\tCS42L73_ASPAIPAA, CS42L73_ASPBIPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"ASP-XSP Volume\",\n\t\t\tCS42L73_ASPAXSPAA, CS42L73_ASPBXSPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"ASP-ASP Volume\",\n\t\t\tCS42L73_ASPAASPAA, CS42L73_ASPBASPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"ASP-VSP Volume\",\n\t\t\tCS42L73_ASPAVSPMA, CS42L73_ASPBVSPMA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"VSP-IP Volume\",\n\t\t\tCS42L73_VSPAIPAA, CS42L73_VSPBIPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"VSP-XSP Volume\",\n\t\t\tCS42L73_VSPAXSPAA, CS42L73_VSPBXSPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"VSP-ASP Volume\",\n\t\t\tCS42L73_VSPAASPAA, CS42L73_VSPBASPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"VSP-VSP Volume\",\n\t\t\tCS42L73_VSPAVSPMA, CS42L73_VSPBVSPMA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HL-IP Volume\",\n\t\t\tCS42L73_HLAIPAA, CS42L73_HLBIPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"HL-XSP Volume\",\n\t\t\tCS42L73_HLAXSPAA, CS42L73_HLBXSPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"HL-ASP Volume\",\n\t\t\tCS42L73_HLAASPAA, CS42L73_HLBASPBA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\tSOC_DOUBLE_R_TLV(\"HL-VSP Volume\",\n\t\t\tCS42L73_HLAVSPMA, CS42L73_HLBVSPMA, 0, 0x3F, 1,\n\t\t\tattn_tlv),\n\n\tSOC_SINGLE_TLV(\"SPK-IP Mono Volume\",\n\t\t\tCS42L73_SPKMIPMA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"SPK-XSP Mono Volume\",\n\t\t\tCS42L73_SPKMXSPA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"SPK-ASP Mono Volume\",\n\t\t\tCS42L73_SPKMASPA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"SPK-VSP Mono Volume\",\n\t\t\tCS42L73_SPKMVSPMA, 0, 0x3F, 1, attn_tlv),\n\n\tSOC_SINGLE_TLV(\"ESL-IP Mono Volume\",\n\t\t\tCS42L73_ESLMIPMA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"ESL-XSP Mono Volume\",\n\t\t\tCS42L73_ESLMXSPA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"ESL-ASP Mono Volume\",\n\t\t\tCS42L73_ESLMASPA, 0, 0x3F, 1, attn_tlv),\n\tSOC_SINGLE_TLV(\"ESL-VSP Mono Volume\",\n\t\t\tCS42L73_ESLMVSPMA, 0, 0x3F, 1, attn_tlv),\n\n\tSOC_ENUM(\"IP Digital Swap/Mono Select\", ip_swap_enum),\n\n\tSOC_ENUM(\"VSPOUT Mono/Stereo Select\", vsp_output_mux_enum),\n\tSOC_ENUM(\"XSPOUT Mono/Stereo Select\", xsp_output_mux_enum),\n};\n\nstatic int cs42l73_spklo_spk_amp_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tpriv->shutdwn_delay = 150;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\nstatic int cs42l73_ear_amp_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tif (priv->shutdwn_delay < 50)\n\t\t\tpriv->shutdwn_delay = 50;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\n\nstatic int cs42l73_hp_amp_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tif (priv->shutdwn_delay < 30)\n\t\t\tpriv->shutdwn_delay = 30;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs42l73_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMICA\"),\n\tSND_SOC_DAPM_INPUT(\"DMICB\"),\n\tSND_SOC_DAPM_INPUT(\"LINEINA\"),\n\tSND_SOC_DAPM_INPUT(\"LINEINB\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_SUPPLY(\"MIC1 Bias\", CS42L73_PWRCTL2, 6, 1, NULL, 0),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_SUPPLY(\"MIC2 Bias\", CS42L73_PWRCTL2, 7, 1, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"XSPOUTL\", NULL,  0,\n\t\t\tCS42L73_PWRCTL2, 1, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"XSPOUTR\", NULL,  0,\n\t\t\tCS42L73_PWRCTL2, 1, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPOUTL\", NULL,  0,\n\t\t\tCS42L73_PWRCTL2, 3, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPOUTR\", NULL,  0,\n\t\t\tCS42L73_PWRCTL2, 3, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"VSPINOUT\", NULL,  0,\n\t\t\tCS42L73_PWRCTL2, 4, 1),\n\n\tSND_SOC_DAPM_PGA(\"PGA Left\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA Right\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"PGA Left Mux\", SND_SOC_NOPM, 0, 0, &pgaa_mux),\n\tSND_SOC_DAPM_MUX(\"PGA Right Mux\", SND_SOC_NOPM, 0, 0, &pgab_mux),\n\n\tSND_SOC_DAPM_ADC(\"ADC Left\", NULL, CS42L73_PWRCTL1, 7, 1),\n\tSND_SOC_DAPM_ADC(\"ADC Right\", NULL, CS42L73_PWRCTL1, 5, 1),\n\tSND_SOC_DAPM_ADC(\"DMIC Left\", NULL, CS42L73_PWRCTL1, 6, 1),\n\tSND_SOC_DAPM_ADC(\"DMIC Right\", NULL, CS42L73_PWRCTL1, 4, 1),\n\n\tSND_SOC_DAPM_MIXER_NAMED_CTL(\"Input Left Capture\", SND_SOC_NOPM,\n\t\t\t 0, 0, input_left_mixer,\n\t\t\t ARRAY_SIZE(input_left_mixer)),\n\n\tSND_SOC_DAPM_MIXER_NAMED_CTL(\"Input Right Capture\", SND_SOC_NOPM,\n\t\t\t0, 0, input_right_mixer,\n\t\t\tARRAY_SIZE(input_right_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"ASPL Output Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"ASPR Output Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"XSPL Output Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"XSPR Output Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"VSP Output Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"XSPINL\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 0, 1),\n\tSND_SOC_DAPM_AIF_IN(\"XSPINR\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 0, 1),\n\tSND_SOC_DAPM_AIF_IN(\"XSPINM\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 0, 1),\n\n\tSND_SOC_DAPM_AIF_IN(\"ASPINL\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 2, 1),\n\tSND_SOC_DAPM_AIF_IN(\"ASPINR\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 2, 1),\n\tSND_SOC_DAPM_AIF_IN(\"ASPINM\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 2, 1),\n\n\tSND_SOC_DAPM_AIF_IN(\"VSPINOUT\", NULL, 0,\n\t\t\t\tCS42L73_PWRCTL2, 4, 1),\n\n\tSND_SOC_DAPM_MIXER(\"HL Left Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"HL Right Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"SPK Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"ESL Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"ESL-XSP Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &esl_xsp_mixer),\n\n\tSND_SOC_DAPM_MUX(\"ESL-ASP Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &esl_asp_mixer),\n\n\tSND_SOC_DAPM_MUX(\"SPK-ASP Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &spk_asp_mixer),\n\n\tSND_SOC_DAPM_MUX(\"SPK-XSP Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &spk_xsp_mixer),\n\n\tSND_SOC_DAPM_PGA(\"HL Left DAC\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HL Right DAC\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPK DAC\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ESL DAC\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH_E(\"HP Amp\",  CS42L73_PWRCTL3, 0, 1,\n\t\t\t    &hp_amp_ctl, cs42l73_hp_amp_event,\n\t\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH(\"LO Amp\", CS42L73_PWRCTL3, 1, 1,\n\t\t\t    &lo_amp_ctl),\n\tSND_SOC_DAPM_SWITCH_E(\"SPK Amp\", CS42L73_PWRCTL3, 2, 1,\n\t\t\t&spk_amp_ctl, cs42l73_spklo_spk_amp_event,\n\t\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH_E(\"EAR Amp\", CS42L73_PWRCTL3, 3, 1,\n\t\t\t    &ear_amp_ctl, cs42l73_ear_amp_event,\n\t\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH_E(\"SPKLO Amp\", CS42L73_PWRCTL3, 4, 1,\n\t\t\t    &spklo_amp_ctl, cs42l73_spklo_spk_amp_event,\n\t\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTB\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINEOUTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINEOUTB\"),\n\tSND_SOC_DAPM_OUTPUT(\"EAROUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKLINEOUT\"),\n};\n\nstatic const struct snd_soc_dapm_route cs42l73_audio_map[] = {\n\n\t \n\t{\"EAROUT\", NULL, \"EAR Amp\"},\n\t{\"SPKLINEOUT\", NULL, \"SPKLO Amp\"},\n\n\t{\"EAR Amp\", \"Switch\", \"ESL DAC\"},\n\t{\"SPKLO Amp\", \"Switch\", \"ESL DAC\"},\n\n\t{\"ESL DAC\", \"ESL-ASP Mono Volume\", \"ESL Mixer\"},\n\t{\"ESL DAC\", \"ESL-XSP Mono Volume\", \"ESL Mixer\"},\n\t{\"ESL DAC\", \"ESL-VSP Mono Volume\", \"VSPINOUT\"},\n\t \n\t{\"ESL DAC\", \"ESL-IP Mono Volume\", \"Input Left Capture\"},\n\t{\"ESL DAC\", \"ESL-IP Mono Volume\", \"Input Right Capture\"},\n\n\t{\"ESL Mixer\", NULL, \"ESL-ASP Mux\"},\n\t{\"ESL Mixer\", NULL, \"ESL-XSP Mux\"},\n\n\t{\"ESL-ASP Mux\", \"Left\", \"ASPINL\"},\n\t{\"ESL-ASP Mux\", \"Right\", \"ASPINR\"},\n\t{\"ESL-ASP Mux\", \"Mono Mix\", \"ASPINM\"},\n\n\t{\"ESL-XSP Mux\", \"Left\", \"XSPINL\"},\n\t{\"ESL-XSP Mux\", \"Right\", \"XSPINR\"},\n\t{\"ESL-XSP Mux\", \"Mono Mix\", \"XSPINM\"},\n\n\t \n\t{\"SPKOUT\", NULL, \"SPK Amp\"},\n\t{\"SPK Amp\", \"Switch\", \"SPK DAC\"},\n\n\t{\"SPK DAC\", \"SPK-ASP Mono Volume\", \"SPK Mixer\"},\n\t{\"SPK DAC\", \"SPK-XSP Mono Volume\", \"SPK Mixer\"},\n\t{\"SPK DAC\", \"SPK-VSP Mono Volume\", \"VSPINOUT\"},\n\t \n\t{\"SPK DAC\", \"SPK-IP Mono Volume\", \"Input Left Capture\"},\n\t{\"SPK DAC\", \"SPK-IP Mono Volume\", \"Input Right Capture\"},\n\n\t{\"SPK Mixer\", NULL, \"SPK-ASP Mux\"},\n\t{\"SPK Mixer\", NULL, \"SPK-XSP Mux\"},\n\n\t{\"SPK-ASP Mux\", \"Left\", \"ASPINL\"},\n\t{\"SPK-ASP Mux\", \"Mono Mix\", \"ASPINM\"},\n\t{\"SPK-ASP Mux\", \"Right\", \"ASPINR\"},\n\n\t{\"SPK-XSP Mux\", \"Left\", \"XSPINL\"},\n\t{\"SPK-XSP Mux\", \"Mono Mix\", \"XSPINM\"},\n\t{\"SPK-XSP Mux\", \"Right\", \"XSPINR\"},\n\n\t \n\t{\"HPOUTA\", NULL, \"HP Amp\"},\n\t{\"HPOUTB\", NULL, \"HP Amp\"},\n\t{\"LINEOUTA\", NULL, \"LO Amp\"},\n\t{\"LINEOUTB\", NULL, \"LO Amp\"},\n\n\t{\"HP Amp\", \"Switch\", \"HL Left DAC\"},\n\t{\"HP Amp\", \"Switch\", \"HL Right DAC\"},\n\t{\"LO Amp\", \"Switch\", \"HL Left DAC\"},\n\t{\"LO Amp\", \"Switch\", \"HL Right DAC\"},\n\n\t{\"HL Left DAC\", \"HL-XSP Volume\", \"HL Left Mixer\"},\n\t{\"HL Right DAC\", \"HL-XSP Volume\", \"HL Right Mixer\"},\n\t{\"HL Left DAC\", \"HL-ASP Volume\", \"HL Left Mixer\"},\n\t{\"HL Right DAC\", \"HL-ASP Volume\", \"HL Right Mixer\"},\n\t{\"HL Left DAC\", \"HL-VSP Volume\", \"HL Left Mixer\"},\n\t{\"HL Right DAC\", \"HL-VSP Volume\", \"HL Right Mixer\"},\n\t \n\t{\"HL Left DAC\", \"HL-IP Volume\", \"HL Left Mixer\"},\n\t{\"HL Right DAC\", \"HL-IP Volume\", \"HL Right Mixer\"},\n\t{\"HL Left Mixer\", NULL, \"Input Left Capture\"},\n\t{\"HL Right Mixer\", NULL, \"Input Right Capture\"},\n\n\t{\"HL Left Mixer\", NULL, \"ASPINL\"},\n\t{\"HL Right Mixer\", NULL, \"ASPINR\"},\n\t{\"HL Left Mixer\", NULL, \"XSPINL\"},\n\t{\"HL Right Mixer\", NULL, \"XSPINR\"},\n\t{\"HL Left Mixer\", NULL, \"VSPINOUT\"},\n\t{\"HL Right Mixer\", NULL, \"VSPINOUT\"},\n\n\t{\"ASPINL\", NULL, \"ASP Playback\"},\n\t{\"ASPINM\", NULL, \"ASP Playback\"},\n\t{\"ASPINR\", NULL, \"ASP Playback\"},\n\t{\"XSPINL\", NULL, \"XSP Playback\"},\n\t{\"XSPINM\", NULL, \"XSP Playback\"},\n\t{\"XSPINR\", NULL, \"XSP Playback\"},\n\t{\"VSPINOUT\", NULL, \"VSP Playback\"},\n\n\t \n\t{\"MIC1\", NULL, \"MIC1 Bias\"},\n\t{\"PGA Left Mux\", \"Mic 1\", \"MIC1\"},\n\t{\"MIC2\", NULL, \"MIC2 Bias\"},\n\t{\"PGA Right Mux\", \"Mic 2\", \"MIC2\"},\n\n\t{\"PGA Left Mux\", \"Line A\", \"LINEINA\"},\n\t{\"PGA Right Mux\", \"Line B\", \"LINEINB\"},\n\n\t{\"PGA Left\", NULL, \"PGA Left Mux\"},\n\t{\"PGA Right\", NULL, \"PGA Right Mux\"},\n\n\t{\"ADC Left\", NULL, \"PGA Left\"},\n\t{\"ADC Right\", NULL, \"PGA Right\"},\n\t{\"DMIC Left\", NULL, \"DMICA\"},\n\t{\"DMIC Right\", NULL, \"DMICB\"},\n\n\t{\"Input Left Capture\", \"ADC Left Input\", \"ADC Left\"},\n\t{\"Input Right Capture\", \"ADC Right Input\", \"ADC Right\"},\n\t{\"Input Left Capture\", \"DMIC Left Input\", \"DMIC Left\"},\n\t{\"Input Right Capture\", \"DMIC Right Input\", \"DMIC Right\"},\n\n\t \n\t{\"ASPL Output Mixer\", NULL, \"Input Left Capture\"},\n\t{\"ASPR Output Mixer\", NULL, \"Input Right Capture\"},\n\n\t{\"ASPOUTL\", \"ASP-IP Volume\", \"ASPL Output Mixer\"},\n\t{\"ASPOUTR\", \"ASP-IP Volume\", \"ASPR Output Mixer\"},\n\n\t \n\t{\"XSPL Output Mixer\", NULL, \"Input Left Capture\"},\n\t{\"XSPR Output Mixer\", NULL, \"Input Right Capture\"},\n\n\t{\"XSPOUTL\", \"XSP-IP Volume\", \"XSPL Output Mixer\"},\n\t{\"XSPOUTR\", \"XSP-IP Volume\", \"XSPR Output Mixer\"},\n\n\t{\"XSPOUTL\", NULL, \"XSPL Output Mixer\"},\n\t{\"XSPOUTR\", NULL, \"XSPR Output Mixer\"},\n\n\t \n\t{\"VSP Output Mixer\", NULL, \"Input Left Capture\"},\n\t{\"VSP Output Mixer\", NULL, \"Input Right Capture\"},\n\n\t{\"VSPINOUT\", \"VSP-IP Volume\", \"VSP Output Mixer\"},\n\n\t{\"VSPINOUT\", NULL, \"VSP Output Mixer\"},\n\n\t{\"ASP Capture\", NULL, \"ASPOUTL\"},\n\t{\"ASP Capture\", NULL, \"ASPOUTR\"},\n\t{\"XSP Capture\", NULL, \"XSPOUTL\"},\n\t{\"XSP Capture\", NULL, \"XSPOUTR\"},\n\t{\"VSP Capture\", NULL, \"VSPINOUT\"},\n};\n\nstruct cs42l73_mclk_div {\n\tu32 mclk;\n\tu32 srate;\n\tu8 mmcc;\n};\n\nstatic const struct cs42l73_mclk_div cs42l73_mclk_coeffs[] = {\n\t \n\t{5644800, 11025, 0x30},\n\t{5644800, 22050, 0x20},\n\t{5644800, 44100, 0x10},\n\n\t{6000000,  8000, 0x39},\n\t{6000000, 11025, 0x33},\n\t{6000000, 12000, 0x31},\n\t{6000000, 16000, 0x29},\n\t{6000000, 22050, 0x23},\n\t{6000000, 24000, 0x21},\n\t{6000000, 32000, 0x19},\n\t{6000000, 44100, 0x13},\n\t{6000000, 48000, 0x11},\n\n\t{6144000,  8000, 0x38},\n\t{6144000, 12000, 0x30},\n\t{6144000, 16000, 0x28},\n\t{6144000, 24000, 0x20},\n\t{6144000, 32000, 0x18},\n\t{6144000, 48000, 0x10},\n\n\t{6500000,  8000, 0x3C},\n\t{6500000, 11025, 0x35},\n\t{6500000, 12000, 0x34},\n\t{6500000, 16000, 0x2C},\n\t{6500000, 22050, 0x25},\n\t{6500000, 24000, 0x24},\n\t{6500000, 32000, 0x1C},\n\t{6500000, 44100, 0x15},\n\t{6500000, 48000, 0x14},\n\n\t{6400000,  8000, 0x3E},\n\t{6400000, 11025, 0x37},\n\t{6400000, 12000, 0x36},\n\t{6400000, 16000, 0x2E},\n\t{6400000, 22050, 0x27},\n\t{6400000, 24000, 0x26},\n\t{6400000, 32000, 0x1E},\n\t{6400000, 44100, 0x17},\n\t{6400000, 48000, 0x16},\n};\n\nstruct cs42l73_mclkx_div {\n\tu32 mclkx;\n\tu8 ratio;\n\tu8 mclkdiv;\n};\n\nstatic const struct cs42l73_mclkx_div cs42l73_mclkx_coeffs[] = {\n\t{5644800,  1, 0},\t \n\t{6000000,  1, 0},\t \n\t{6144000,  1, 0},\t \n\t{11289600, 2, 2},\t \n\t{12288000, 2, 2},\t \n\t{12000000, 2, 2},\t \n\t{13000000, 2, 2},\t \n\t{19200000, 3, 3},\t \n\t{24000000, 4, 4},\t \n\t{26000000, 4, 4},\t \n\t{38400000, 6, 5}\t \n};\n\nstatic int cs42l73_get_mclkx_coeff(int mclkx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l73_mclkx_coeffs); i++) {\n\t\tif (cs42l73_mclkx_coeffs[i].mclkx == mclkx)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs42l73_get_mclk_coeff(int mclk, int srate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l73_mclk_coeffs); i++) {\n\t\tif (cs42l73_mclk_coeffs[i].mclk == mclk &&\n\t\t    cs42l73_mclk_coeffs[i].srate == srate)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n\n}\n\nstatic int cs42l73_set_mclk(struct snd_soc_dai *dai, unsigned int freq)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\n\tint mclkx_coeff;\n\tu32 mclk = 0;\n\tu8 dmmcc = 0;\n\n\t \n\tmclkx_coeff = cs42l73_get_mclkx_coeff(freq);\n\tif (mclkx_coeff < 0)\n\t\treturn mclkx_coeff;\n\n\tmclk = cs42l73_mclkx_coeffs[mclkx_coeff].mclkx /\n\t\tcs42l73_mclkx_coeffs[mclkx_coeff].ratio;\n\n\tdev_dbg(component->dev, \"MCLK%u %u  <-> internal MCLK %u\\n\",\n\t\t priv->mclksel + 1, cs42l73_mclkx_coeffs[mclkx_coeff].mclkx,\n\t\t mclk);\n\n\tdmmcc = (priv->mclksel << 4) |\n\t\t(cs42l73_mclkx_coeffs[mclkx_coeff].mclkdiv << 1);\n\n\tsnd_soc_component_write(component, CS42L73_DMMCC, dmmcc);\n\n\tpriv->sysclk = mclkx_coeff;\n\tpriv->mclk = mclk;\n\n\treturn 0;\n}\n\nstatic int cs42l73_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t      int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase CS42L73_CLKID_MCLK1:\n\t\tbreak;\n\tcase CS42L73_CLKID_MCLK2:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((cs42l73_set_mclk(dai, freq)) < 0) {\n\t\tdev_err(component->dev, \"Unable to set MCLK for dai %s\\n\",\n\t\t\tdai->name);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->mclksel = clk_id;\n\n\treturn 0;\n}\n\nstatic int cs42l73_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\tu8 id = codec_dai->id;\n\tunsigned int inv, format;\n\tu8 spc, mmcc;\n\n\tspc = snd_soc_component_read(component, CS42L73_SPC(id));\n\tmmcc = snd_soc_component_read(component, CS42L73_MMCC(id));\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmmcc |= CS42L73_MS_MASTER;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmmcc &= ~CS42L73_MS_MASTER;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tformat = (fmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\tinv = (fmt & SND_SOC_DAIFMT_INV_MASK);\n\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tspc &= ~CS42L73_SPDIF_PCM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tif (mmcc & CS42L73_MS_MASTER) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"PCM format in slave mode only\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (id == CS42L73_ASP) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"PCM format is not supported on ASP port\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tspc |= CS42L73_SPDIF_PCM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (spc & CS42L73_SPDIF_PCM) {\n\t\t \n\t\tspc &= ~(CS42L73_PCM_MODE_MASK | CS42L73_PCM_BIT_ORDER);\n\t\tswitch (format) {\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\tif (inv == SND_SOC_DAIFMT_IB_IF)\n\t\t\t\tspc |= CS42L73_PCM_MODE0;\n\t\t\tif (inv == SND_SOC_DAIFMT_IB_NF)\n\t\t\t\tspc |= CS42L73_PCM_MODE1;\n\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t\tif (inv == SND_SOC_DAIFMT_IB_IF)\n\t\t\t\tspc |= CS42L73_PCM_MODE1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpriv->config[id].spc = spc;\n\tpriv->config[id].mmcc = mmcc;\n\n\treturn 0;\n}\n\nstatic const unsigned int cs42l73_asrc_rates[] = {\n\t8000, 11025, 12000, 16000, 22050,\n\t24000, 32000, 44100, 48000\n};\n\nstatic unsigned int cs42l73_get_xspfs_coeff(u32 rate)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(cs42l73_asrc_rates); i++) {\n\t\tif (cs42l73_asrc_rates[i] == rate)\n\t\t\treturn i + 1;\n\t}\n\treturn 0;\t\t \n}\n\nstatic void cs42l73_update_asrc(struct snd_soc_component *component, int id, int srate)\n{\n\tu8 spfs = 0;\n\n\tif (srate > 0)\n\t\tspfs = cs42l73_get_xspfs_coeff(srate);\n\n\tswitch (id) {\n\tcase CS42L73_XSP:\n\t\tsnd_soc_component_update_bits(component, CS42L73_VXSPFS, 0x0f, spfs);\n\tbreak;\n\tcase CS42L73_ASP:\n\t\tsnd_soc_component_update_bits(component, CS42L73_ASPC, 0x3c, spfs << 2);\n\tbreak;\n\tcase CS42L73_VSP:\n\t\tsnd_soc_component_update_bits(component, CS42L73_VXSPFS, 0xf0, spfs << 4);\n\tbreak;\n\tdefault:\n\tbreak;\n\t}\n}\n\nstatic int cs42l73_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l73_private *priv = snd_soc_component_get_drvdata(component);\n\tint id = dai->id;\n\tint mclk_coeff;\n\tint srate = params_rate(params);\n\n\tif (priv->config[id].mmcc & CS42L73_MS_MASTER) {\n\t\t \n\t\t \n\t\tmclk_coeff =\n\t\t    cs42l73_get_mclk_coeff(priv->mclk, srate);\n\n\t\tif (mclk_coeff < 0)\n\t\t\treturn -EINVAL;\n\n\t\tdev_dbg(component->dev,\n\t\t\t \"DAI[%d]: MCLK %u, srate %u, MMCC[5:0] = %x\\n\",\n\t\t\t id, priv->mclk, srate,\n\t\t\t cs42l73_mclk_coeffs[mclk_coeff].mmcc);\n\n\t\tpriv->config[id].mmcc &= 0xC0;\n\t\tpriv->config[id].mmcc |= cs42l73_mclk_coeffs[mclk_coeff].mmcc;\n\t\tpriv->config[id].spc &= 0xFC;\n\t\t \n\t\tif (priv->mclk >= 6400000)\n\t\t\tpriv->config[id].spc |= CS42L73_MCK_SCLK_64FS;\n\t\telse\n\t\t\tpriv->config[id].spc |= CS42L73_MCK_SCLK_MCLK;\n\t} else {\n\t\t \n\t\tpriv->config[id].spc &= 0xFC;\n\t\tpriv->config[id].spc |= CS42L73_MCK_SCLK_64FS;\n\t}\n\t \n\tpriv->config[id].srate = srate;\n\n\tsnd_soc_component_write(component, CS42L73_SPC(id), priv->config[id].spc);\n\tsnd_soc_component_write(component, CS42L73_MMCC(id), priv->config[id].mmcc);\n\n\tcs42l73_update_asrc(component, id, srate);\n\n\treturn 0;\n}\n\nstatic int cs42l73_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct cs42l73_private *cs42l73 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tsnd_soc_component_update_bits(component, CS42L73_DMMCC, CS42L73_MCLKDIS, 0);\n\t\tsnd_soc_component_update_bits(component, CS42L73_PWRCTL1, CS42L73_PDN, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_cache_only(cs42l73->regmap, false);\n\t\t\tregcache_sync(cs42l73->regmap);\n\t\t}\n\t\tsnd_soc_component_update_bits(component, CS42L73_PWRCTL1, CS42L73_PDN, 1);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, CS42L73_PWRCTL1, CS42L73_PDN, 1);\n\t\tif (cs42l73->shutdwn_delay > 0) {\n\t\t\tmdelay(cs42l73->shutdwn_delay);\n\t\t\tcs42l73->shutdwn_delay = 0;\n\t\t} else {\n\t\t\tmdelay(15);  \n\t\t}\n\t\tsnd_soc_component_update_bits(component, CS42L73_DMMCC, CS42L73_MCLKDIS, 1);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int cs42l73_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint id = dai->id;\n\n\treturn snd_soc_component_update_bits(component, CS42L73_SPC(id), CS42L73_SP_3ST,\n\t\t\t\t   tristate << 7);\n}\n\nstatic const struct snd_pcm_hw_constraint_list constraints_12_24 = {\n\t.count  = ARRAY_SIZE(cs42l73_asrc_rates),\n\t.list   = cs42l73_asrc_rates,\n};\n\nstatic int cs42l73_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t&constraints_12_24);\n\treturn 0;\n}\n\n\n#define CS42L73_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops cs42l73_ops = {\n\t.startup = cs42l73_pcm_startup,\n\t.hw_params = cs42l73_pcm_hw_params,\n\t.set_fmt = cs42l73_set_dai_fmt,\n\t.set_sysclk = cs42l73_set_sysclk,\n\t.set_tristate = cs42l73_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver cs42l73_dai[] = {\n\t{\n\t\t.name = \"cs42l73-xsp\",\n\t\t.id = CS42L73_XSP,\n\t\t.playback = {\n\t\t\t.stream_name = \"XSP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"XSP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.ops = &cs42l73_ops,\n\t\t.symmetric_rate = 1,\n\t },\n\t{\n\t\t.name = \"cs42l73-asp\",\n\t\t.id = CS42L73_ASP,\n\t\t.playback = {\n\t\t\t.stream_name = \"ASP Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"ASP Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.ops = &cs42l73_ops,\n\t\t.symmetric_rate = 1,\n\t },\n\t{\n\t\t.name = \"cs42l73-vsp\",\n\t\t.id = CS42L73_VSP,\n\t\t.playback = {\n\t\t\t.stream_name = \"VSP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"VSP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS42L73_FORMATS,\n\t\t},\n\t\t.ops = &cs42l73_ops,\n\t\t.symmetric_rate = 1,\n\t }\n};\n\nstatic int cs42l73_probe(struct snd_soc_component *component)\n{\n\tstruct cs42l73_private *cs42l73 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (cs42l73->pdata.chgfreq)\n\t\tsnd_soc_component_update_bits(component, CS42L73_CPFCHC,\n\t\t\t\t    CS42L73_CHARGEPUMP_MASK,\n\t\t\t\t\tcs42l73->pdata.chgfreq << 4);\n\n\t \n\tcs42l73->mclksel = CS42L73_CLKID_MCLK1;\n\tcs42l73->mclk = 0;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs42l73 = {\n\t.probe\t\t\t= cs42l73_probe,\n\t.set_bias_level\t\t= cs42l73_set_bias_level,\n\t.controls\t\t= cs42l73_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42l73_snd_controls),\n\t.dapm_widgets\t\t= cs42l73_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42l73_dapm_widgets),\n\t.dapm_routes\t\t= cs42l73_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42l73_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs42l73_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS42L73_MAX_REGISTER,\n\t.reg_defaults = cs42l73_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs42l73_reg_defaults),\n\t.volatile_reg = cs42l73_volatile_register,\n\t.readable_reg = cs42l73_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int cs42l73_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs42l73_private *cs42l73;\n\tstruct cs42l73_platform_data *pdata = dev_get_platdata(&i2c_client->dev);\n\tint ret, devid;\n\tunsigned int reg;\n\tu32 val32;\n\n\tcs42l73 = devm_kzalloc(&i2c_client->dev, sizeof(*cs42l73), GFP_KERNEL);\n\tif (!cs42l73)\n\t\treturn -ENOMEM;\n\n\tcs42l73->regmap = devm_regmap_init_i2c(i2c_client, &cs42l73_regmap);\n\tif (IS_ERR(cs42l73->regmap)) {\n\t\tret = PTR_ERR(cs42l73->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs42l73->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(&i2c_client->dev, sizeof(*pdata),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tif (of_property_read_u32(i2c_client->dev.of_node,\n\t\t\t\t\"chgfreq\", &val32) >= 0)\n\t\t\t\tpdata->chgfreq = val32;\n\t\t}\n\t\tpdata->reset_gpio = of_get_named_gpio(i2c_client->dev.of_node,\n\t\t\t\t\t\t\"reset-gpio\", 0);\n\t\tcs42l73->pdata = *pdata;\n\t}\n\n\ti2c_set_clientdata(i2c_client, cs42l73);\n\n\tif (cs42l73->pdata.reset_gpio) {\n\t\tret = devm_gpio_request_one(&i2c_client->dev,\n\t\t\t\t\t    cs42l73->pdata.reset_gpio,\n\t\t\t\t\t    GPIOF_OUT_INIT_HIGH,\n\t\t\t\t\t    \"CS42L73 /RST\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c_client->dev, \"Failed to request /RST %d: %d\\n\",\n\t\t\t\tcs42l73->pdata.reset_gpio, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tgpio_set_value_cansleep(cs42l73->pdata.reset_gpio, 0);\n\t\tgpio_set_value_cansleep(cs42l73->pdata.reset_gpio, 1);\n\t}\n\n\t \n\tdevid = cirrus_read_device_id(cs42l73->regmap, CS42L73_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(&i2c_client->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\tif (devid != CS42L73_DEVID) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS42L73 Device ID (%X). Expected %X\\n\",\n\t\t\tdevid, CS42L73_DEVID);\n\t\tgoto err_reset;\n\t}\n\n\tret = regmap_read(cs42l73->regmap, CS42L73_REVID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err_reset;\n\t}\n\n\tdev_info(&i2c_client->dev,\n\t\t \"Cirrus Logic CS42L73, Revision: %02X\\n\", reg & 0xFF);\n\n\tret = devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs42l73, cs42l73_dai,\n\t\t\tARRAY_SIZE(cs42l73_dai));\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\treturn 0;\n\nerr_reset:\n\tgpio_set_value_cansleep(cs42l73->pdata.reset_gpio, 0);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id cs42l73_of_match[] = {\n\t{ .compatible = \"cirrus,cs42l73\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs42l73_of_match);\n\nstatic const struct i2c_device_id cs42l73_id[] = {\n\t{\"cs42l73\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs42l73_id);\n\nstatic struct i2c_driver cs42l73_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"cs42l73\",\n\t\t   .of_match_table = cs42l73_of_match,\n\t\t   },\n\t.id_table = cs42l73_id,\n\t.probe = cs42l73_i2c_probe,\n\n};\n\nmodule_i2c_driver(cs42l73_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS42L73 driver\");\nMODULE_AUTHOR(\"Georgi Vlaev, Nucleus Systems Ltd, <joe@nucleusys.com>\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}