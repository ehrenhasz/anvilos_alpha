{
  "module_name": "sma1303.c",
  "hash_id": "ab34fc90c52022bc87b20d3aac3556cc61eb11a377334646d6cb3ab5308841eb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sma1303.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/of_device.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n\n#include \"sma1303.h\"\n\n#define CHECK_PERIOD_TIME 1  \n#define MAX_CONTROL_NAME 48\n\n#define PLL_MATCH(_input_clk_name, _output_clk_name, _input_clk,\\\n\t\t_post_n, _n, _vco,  _p_cp)\\\n{\\\n\t.input_clk_name\t\t= _input_clk_name,\\\n\t.output_clk_name\t= _output_clk_name,\\\n\t.input_clk\t\t= _input_clk,\\\n\t.post_n\t\t\t= _post_n,\\\n\t.n\t\t\t= _n,\\\n\t.vco\t\t\t= _vco,\\\n\t.p_cp\t\t= _p_cp,\\\n}\n\nenum sma1303_type {\n\tSMA1303,\n};\n\nstruct sma1303_pll_match {\n\tchar *input_clk_name;\n\tchar *output_clk_name;\n\tunsigned int input_clk;\n\tunsigned int post_n;\n\tunsigned int n;\n\tunsigned int vco;\n\tunsigned int p_cp;\n};\n\nstruct sma1303_priv {\n\tenum sma1303_type devtype;\n\tstruct attribute_group *attr_grp;\n\tstruct delayed_work check_fault_work;\n\tstruct device *dev;\n\tstruct kobject *kobj;\n\tstruct regmap *regmap;\n\tstruct sma1303_pll_match *pll_matches;\n\tbool amp_power_status;\n\tbool force_mute_status;\n\tint num_of_pll_matches;\n\tint retry_cnt;\n\tunsigned int amp_mode;\n\tunsigned int cur_vol;\n\tunsigned int format;\n\tunsigned int frame_size;\n\tunsigned int init_vol;\n\tunsigned int last_bclk;\n\tunsigned int last_ocp_val;\n\tunsigned int last_over_temp;\n\tunsigned int rev_num;\n\tunsigned int sys_clk_id;\n\tunsigned int tdm_slot_rx;\n\tunsigned int tdm_slot_tx;\n\tunsigned int tsdw_cnt;\n\tlong check_fault_period;\n\tlong check_fault_status;\n};\n\nstatic struct sma1303_pll_match sma1303_pll_matches[] = {\nPLL_MATCH(\"1.411MHz\",  \"24.595MHz\", 1411200,  0x07, 0xF4, 0x8B, 0x03),\nPLL_MATCH(\"1.536MHz\",  \"24.576MHz\", 1536000,  0x07, 0xE0, 0x8B, 0x03),\nPLL_MATCH(\"3.072MHz\",  \"24.576MHz\", 3072000,  0x07, 0x70, 0x8B, 0x03),\nPLL_MATCH(\"6.144MHz\",  \"24.576MHz\", 6144000,  0x07, 0x70, 0x8B, 0x07),\nPLL_MATCH(\"12.288MHz\", \"24.576MHz\", 12288000, 0x07, 0x70, 0x8B, 0x0B),\nPLL_MATCH(\"19.2MHz\",   \"24.343MHz\", 19200000, 0x07, 0x47, 0x8B, 0x0A),\nPLL_MATCH(\"24.576MHz\", \"24.576MHz\", 24576000, 0x07, 0x70, 0x8B, 0x0F),\n};\n\nstatic int sma1303_startup(struct snd_soc_component *);\nstatic int sma1303_shutdown(struct snd_soc_component *);\n\nstatic const struct reg_default sma1303_reg_def[] = {\n\t{ 0x00, 0x80 },\n\t{ 0x01, 0x00 },\n\t{ 0x02, 0x00 },\n\t{ 0x03, 0x11 },\n\t{ 0x04, 0x17 },\n\t{ 0x09, 0x00 },\n\t{ 0x0A, 0x31 },\n\t{ 0x0B, 0x98 },\n\t{ 0x0C, 0x84 },\n\t{ 0x0D, 0x07 },\n\t{ 0x0E, 0x3F },\n\t{ 0x10, 0x00 },\n\t{ 0x11, 0x00 },\n\t{ 0x12, 0x00 },\n\t{ 0x14, 0x5C },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x0F },\n\t{ 0x17, 0x0F },\n\t{ 0x18, 0x0F },\n\t{ 0x19, 0x00 },\n\t{ 0x1A, 0x00 },\n\t{ 0x1B, 0x00 },\n\t{ 0x23, 0x19 },\n\t{ 0x24, 0x00 },\n\t{ 0x25, 0x00 },\n\t{ 0x26, 0x04 },\n\t{ 0x33, 0x00 },\n\t{ 0x36, 0x92 },\n\t{ 0x37, 0x27 },\n\t{ 0x3B, 0x5A },\n\t{ 0x3C, 0x20 },\n\t{ 0x3D, 0x00 },\n\t{ 0x3E, 0x03 },\n\t{ 0x3F, 0x0C },\n\t{ 0x8B, 0x07 },\n\t{ 0x8C, 0x70 },\n\t{ 0x8D, 0x8B },\n\t{ 0x8E, 0x6F },\n\t{ 0x8F, 0x03 },\n\t{ 0x90, 0x26 },\n\t{ 0x91, 0x42 },\n\t{ 0x92, 0xE0 },\n\t{ 0x94, 0x35 },\n\t{ 0x95, 0x0C },\n\t{ 0x96, 0x42 },\n\t{ 0x97, 0x95 },\n\t{ 0xA0, 0x00 },\n\t{ 0xA1, 0x3B },\n\t{ 0xA2, 0xC8 },\n\t{ 0xA3, 0x28 },\n\t{ 0xA4, 0x40 },\n\t{ 0xA5, 0x01 },\n\t{ 0xA6, 0x41 },\n\t{ 0xA7, 0x00 },\n};\n\nstatic bool sma1303_readable_register(struct device *dev, unsigned int reg)\n{\n\tbool result;\n\n\tif (reg > SMA1303_FF_DEVICE_INDEX)\n\t\treturn false;\n\n\tswitch (reg) {\n\tcase SMA1303_00_SYSTEM_CTRL ... SMA1303_04_INPUT1_CTRL4:\n\tcase SMA1303_09_OUTPUT_CTRL ... SMA1303_0E_MUTE_VOL_CTRL:\n\tcase SMA1303_10_SYSTEM_CTRL1 ... SMA1303_12_SYSTEM_CTRL3:\n\tcase SMA1303_14_MODULATOR ... SMA1303_1B_BASS_SPK7:\n\tcase SMA1303_23_COMP_LIM1 ... SMA1303_26_COMP_LIM4:\n\tcase SMA1303_33_SDM_CTRL ... SMA1303_34_OTP_DATA1:\n\tcase SMA1303_36_PROTECTION  ... SMA1303_38_OTP_TRM0:\n\tcase SMA1303_3B_TEST1  ... SMA1303_3F_ATEST2:\n\tcase SMA1303_8B_PLL_POST_N ... SMA1303_92_FDPEC_CTRL:\n\tcase SMA1303_94_BOOST_CTRL1 ... SMA1303_97_BOOST_CTRL4:\n\tcase SMA1303_A0_PAD_CTRL0 ... SMA1303_A7_CLK_MON:\n\tcase SMA1303_FA_STATUS1 ... SMA1303_FB_STATUS2:\n\t\tresult = true;\n\t\tbreak;\n\tcase SMA1303_FF_DEVICE_INDEX:\n\t\tresult = true;\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic bool sma1303_writeable_register(struct device *dev, unsigned int reg)\n{\n\tbool result;\n\n\tif (reg > SMA1303_FF_DEVICE_INDEX)\n\t\treturn false;\n\n\tswitch (reg) {\n\tcase SMA1303_00_SYSTEM_CTRL ... SMA1303_04_INPUT1_CTRL4:\n\tcase SMA1303_09_OUTPUT_CTRL ... SMA1303_0E_MUTE_VOL_CTRL:\n\tcase SMA1303_10_SYSTEM_CTRL1 ... SMA1303_12_SYSTEM_CTRL3:\n\tcase SMA1303_14_MODULATOR ... SMA1303_1B_BASS_SPK7:\n\tcase SMA1303_23_COMP_LIM1 ... SMA1303_26_COMP_LIM4:\n\tcase SMA1303_33_SDM_CTRL:\n\tcase SMA1303_36_PROTECTION  ... SMA1303_37_SLOPE_CTRL:\n\tcase SMA1303_3B_TEST1  ... SMA1303_3F_ATEST2:\n\tcase SMA1303_8B_PLL_POST_N ... SMA1303_92_FDPEC_CTRL:\n\tcase SMA1303_94_BOOST_CTRL1 ... SMA1303_97_BOOST_CTRL4:\n\tcase SMA1303_A0_PAD_CTRL0 ... SMA1303_A7_CLK_MON:\n\t\tresult = true;\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic bool sma1303_volatile_register(struct device *dev, unsigned int reg)\n{\n\tbool result;\n\n\tswitch (reg) {\n\tcase SMA1303_FA_STATUS1 ... SMA1303_FB_STATUS2:\n\t\tresult = true;\n\t\tbreak;\n\tcase SMA1303_FF_DEVICE_INDEX:\n\t\tresult = true;\n\t\tbreak;\n\tdefault:\n\t\tresult = false;\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(sma1303_spk_tlv, -6000, 50, 0);\n\nstatic int sma1303_regmap_write(struct sma1303_priv *sma1303,\n\t\t\t\tunsigned int reg, unsigned int val)\n{\n\tint ret = 0;\n\tint cnt = sma1303->retry_cnt;\n\n\twhile (cnt--) {\n\t\tret = regmap_write(sma1303->regmap, reg, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sma1303->dev,\n\t\t\t\t\t\"Failed to write [0x%02X]\\n\", reg);\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int sma1303_regmap_update_bits(struct sma1303_priv *sma1303,\n\tunsigned int reg, unsigned int mask, unsigned int val, bool *change)\n{\n\tint ret = 0;\n\tint cnt = sma1303->retry_cnt;\n\n\twhile (cnt--) {\n\t\tret = regmap_update_bits_check(sma1303->regmap, reg,\n\t\t\t\tmask, val, change);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sma1303->dev,\n\t\t\t\t\t\"Failed to update [0x%02X]\\n\", reg);\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int sma1303_regmap_read(struct sma1303_priv *sma1303,\n\t\t\tunsigned int reg, unsigned int *val)\n{\n\tint ret = 0;\n\tint cnt = sma1303->retry_cnt;\n\n\twhile (cnt--) {\n\t\tret = regmap_read(sma1303->regmap, reg, val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(sma1303->dev,\n\t\t\t\t\t\"Failed to read [0x%02X]\\n\", reg);\n\t\t} else\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const char * const sma1303_aif_in_source_text[] = {\n\t\"Mono\", \"Left\", \"Right\"};\nstatic const char * const sma1303_aif_out_source_text[] = {\n\t\"Disable\", \"After_FmtC\", \"After_Mixer\", \"After_DSP\", \"After_Post\",\n\t\t\"Clk_PLL\", \"Clk_OSC\"};\nstatic const char * const sma1303_tdm_slot_text[] = {\n\t\"Slot0\", \"Slot1\", \"Slot2\", \"Slot3\",\n\t\"Slot4\", \"Slot5\", \"Slot6\", \"Slot7\"};\n\nstatic const struct soc_enum sma1303_aif_in_source_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sma1303_aif_in_source_text),\n\t\t\tsma1303_aif_in_source_text);\nstatic const struct soc_enum sma1303_aif_out_source_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sma1303_aif_out_source_text),\n\t\t\tsma1303_aif_out_source_text);\nstatic const struct soc_enum sma1303_tdm_slot_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(sma1303_tdm_slot_text),\n\t\t\tsma1303_tdm_slot_text);\n\nstatic int sma1303_force_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = (int)sma1303->force_mute_status;\n\tdev_dbg(sma1303->dev, \"%s : Force Mute %s\\n\", __func__,\n\t\t\tsma1303->force_mute_status ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nstatic int sma1303_force_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tbool change = false, val = (bool)ucontrol->value.integer.value[0];\n\n\tif (sma1303->force_mute_status == val)\n\t\tchange = false;\n\telse {\n\t\tchange = true;\n\t\tsma1303->force_mute_status = val;\n\t}\n\tdev_dbg(sma1303->dev, \"%s : Force Mute %s\\n\", __func__,\n\t\t\tsma1303->force_mute_status ? \"ON\" : \"OFF\");\n\n\treturn change;\n}\n\nstatic int sma1303_postscaler_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint val, ret;\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_90_POSTSCALER, &val);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = (val & 0x7E) >> 1;\n\n\treturn 0;\n}\n\nstatic int sma1303_postscaler_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret, val = (int)ucontrol->value.integer.value[0];\n\tbool change;\n\n\tret = sma1303_regmap_update_bits(sma1303,\n\t\t\tSMA1303_90_POSTSCALER, 0x7E, (val << 1), &change);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn change;\n}\n\nstatic int sma1303_tdm_slot_rx_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint val, ret;\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_A5_TDM1, &val);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = (val & 0x38) >> 3;\n\tsma1303->tdm_slot_rx = ucontrol->value.integer.value[0];\n\n\treturn 0;\n}\n\nstatic int sma1303_tdm_slot_rx_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret, val = (int)ucontrol->value.integer.value[0];\n\tbool change;\n\n\tret = sma1303_regmap_update_bits(sma1303,\n\t\t\tSMA1303_A5_TDM1, 0x38, (val << 3), &change);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn change;\n}\n\nstatic int sma1303_tdm_slot_tx_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint val, ret;\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_A6_TDM2, &val);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = (val & 0x38) >> 3;\n\tsma1303->tdm_slot_tx = ucontrol->value.integer.value[0];\n\n\treturn 0;\n}\n\nstatic int sma1303_tdm_slot_tx_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret, val = (int)ucontrol->value.integer.value[0];\n\tbool change;\n\n\tret = sma1303_regmap_update_bits(sma1303,\n\t\t\tSMA1303_A6_TDM2, 0x38, (val << 3), &change);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn change;\n}\n\nstatic int sma1303_startup(struct snd_soc_component *component)\n{\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tbool change = false, temp = false;\n\n\tsma1303_regmap_update_bits(sma1303, SMA1303_8E_PLL_CTRL,\n\t\t\tSMA1303_PLL_PD2_MASK, SMA1303_PLL_OPERATION2, &temp);\n\tif (temp == true)\n\t\tchange = true;\n\n\tsma1303_regmap_update_bits(sma1303, SMA1303_00_SYSTEM_CTRL,\n\t\t\tSMA1303_POWER_MASK, SMA1303_POWER_ON, &temp);\n\tif (temp == true)\n\t\tchange = true;\n\n\tif (sma1303->amp_mode == SMA1303_MONO) {\n\t\tsma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_10_SYSTEM_CTRL1,\n\t\t\t\tSMA1303_SPK_MODE_MASK,\n\t\t\t\tSMA1303_SPK_MONO,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\n\t} else {\n\t\tsma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_10_SYSTEM_CTRL1,\n\t\t\t\tSMA1303_SPK_MODE_MASK,\n\t\t\t\tSMA1303_SPK_STEREO,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\t}\n\n\tif (sma1303->check_fault_status) {\n\t\tif (sma1303->check_fault_period > 0)\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tsma1303->check_fault_period * HZ);\n\t\telse\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tCHECK_PERIOD_TIME * HZ);\n\t}\n\n\tsma1303->amp_power_status = true;\n\n\treturn change;\n}\n\nstatic int sma1303_shutdown(struct snd_soc_component *component)\n{\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tbool change = false, temp = false;\n\n\tcancel_delayed_work_sync(&sma1303->check_fault_work);\n\n\tsma1303_regmap_update_bits(sma1303, SMA1303_10_SYSTEM_CTRL1,\n\t\t\tSMA1303_SPK_MODE_MASK, SMA1303_SPK_OFF, &temp);\n\tif (temp == true)\n\t\tchange = true;\n\n\tsma1303_regmap_update_bits(sma1303, SMA1303_00_SYSTEM_CTRL,\n\t\t\tSMA1303_POWER_MASK, SMA1303_POWER_OFF, &temp);\n\tif (temp == true)\n\t\tchange = true;\n\tsma1303_regmap_update_bits(sma1303, SMA1303_8E_PLL_CTRL,\n\t\t\tSMA1303_PLL_PD2_MASK, SMA1303_PLL_PD2, &temp);\n\tif (temp == true)\n\t\tchange = true;\n\n\tsma1303->amp_power_status = false;\n\n\treturn change;\n}\n\nstatic int sma1303_aif_in_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tunsigned int mux = dapm_kcontrol_get_value(w->kcontrols[0]);\n\tint ret = 0;\n\tbool change = false, temp = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tswitch (mux) {\n\t\tcase 0:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_11_SYSTEM_CTRL2,\n\t\t\t\t\tSMA1303_MONOMIX_MASK,\n\t\t\t\t\tSMA1303_MONOMIX_ON,\n\t\t\t\t\t&change);\n\t\t\tsma1303->amp_mode = SMA1303_MONO;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_11_SYSTEM_CTRL2,\n\t\t\t\t\tSMA1303_MONOMIX_MASK,\n\t\t\t\t\tSMA1303_MONOMIX_OFF,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_11_SYSTEM_CTRL2,\n\t\t\t\t\tSMA1303_LR_DATA_SW_MASK,\n\t\t\t\t\tSMA1303_LR_DATA_SW_NORMAL,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tsma1303->amp_mode = SMA1303_STEREO;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_11_SYSTEM_CTRL2,\n\t\t\t\t\tSMA1303_MONOMIX_MASK,\n\t\t\t\t\tSMA1303_MONOMIX_OFF,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_11_SYSTEM_CTRL2,\n\t\t\t\t\tSMA1303_LR_DATA_SW_MASK,\n\t\t\t\t\tSMA1303_LR_DATA_SW_SWAP,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tsma1303->amp_mode = SMA1303_STEREO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sma1303->dev, \"%s : Invalid value (%d)\\n\",\n\t\t\t\t\t\t\t\t__func__, mux);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(sma1303->dev, \"%s : Source : %s\\n\", __func__,\n\t\t\t\t\tsma1303_aif_in_source_text[mux]);\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn change;\n}\n\nstatic int sma1303_aif_out_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tunsigned int mux = dapm_kcontrol_get_value(w->kcontrols[0]);\n\tint ret = 0;\n\tbool change = false, temp = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tswitch (mux) {\n\t\tcase 0:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_NORMAL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\t\tSMA1303_PORT_OUT_SEL_MASK,\n\t\t\t\t\tSMA1303_OUT_SEL_DISABLE,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_NORMAL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\t\tSMA1303_PORT_OUT_SEL_MASK,\n\t\t\t\t\tSMA1303_FORMAT_CONVERTER,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_NORMAL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\t\tSMA1303_PORT_OUT_SEL_MASK,\n\t\t\t\t\tSMA1303_MIXER_OUTPUT,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_NORMAL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\t\tSMA1303_PORT_OUT_SEL_MASK,\n\t\t\t\t\tSMA1303_SPEAKER_PATH,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_NORMAL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\t\tSMA1303_PORT_OUT_SEL_MASK,\n\t\t\t\t\tSMA1303_POSTSCALER_OUTPUT,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_CLK_OUT_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_MON_OSC_PLL_MASK,\n\t\t\t\t\tSMA1303_PLL_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_TEST_CLKO_EN_MASK,\n\t\t\t\t\tSMA1303_CLK_OUT_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\t\tSMA1303_MON_OSC_PLL_MASK,\n\t\t\t\t\tSMA1303_OSC_SDO,\n\t\t\t\t\t&temp);\n\t\t\tif (temp == true)\n\t\t\t\tchange = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(sma1303->dev, \"%s : Invalid value (%d)\\n\",\n\t\t\t\t\t\t\t\t__func__, mux);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(sma1303->dev, \"%s : Source : %s\\n\", __func__,\n\t\t\t\t\tsma1303_aif_out_source_text[mux]);\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn change;\n}\n\nstatic int sma1303_sdo_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\tbool change = false, temp = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\"%s : SND_SOC_DAPM_PRE_PMU\\n\", __func__);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\tSMA1303_PORT_CONFIG_MASK,\n\t\t\t\tSMA1303_OUTPUT_PORT_ENABLE,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\tSMA1303_SDO_OUTPUT_MASK,\n\t\t\t\tSMA1303_NORMAL_OUT,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\"%s : SND_SOC_DAPM_POST_PMD\\n\", __func__);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_09_OUTPUT_CTRL,\n\t\t\t\tSMA1303_PORT_CONFIG_MASK,\n\t\t\t\tSMA1303_INPUT_PORT_ONLY,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A3_TOP_MAN2,\n\t\t\t\tSMA1303_SDO_OUTPUT_MASK,\n\t\t\t\tSMA1303_HIGH_Z_OUT,\n\t\t\t\t&temp);\n\t\tif (temp == true)\n\t\t\tchange = true;\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn change;\n}\n\nstatic int sma1303_post_scaler_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\tbool change = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\t\"%s : SND_SOC_DAPM_PRE_PMU\\n\", __func__);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_90_POSTSCALER,\n\t\t\t\tSMA1303_BYP_POST_MASK,\n\t\t\t\tSMA1303_EN_POST_SCALER,\n\t\t\t\t&change);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\t\"%s : SND_SOC_DAPM_POST_PMD\\n\", __func__);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_90_POSTSCALER,\n\t\t\t\tSMA1303_BYP_POST_MASK,\n\t\t\t\tSMA1303_BYP_POST_SCALER,\n\t\t\t\t&change);\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn change;\n}\n\nstatic int sma1303_power_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\"%s : SND_SOC_DAPM_POST_PMU\\n\", __func__);\n\t\tret = sma1303_startup(component);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tdev_dbg(sma1303->dev,\n\t\t\t\"%s : SND_SOC_DAPM_PRE_PMD\\n\", __func__);\n\t\tret = sma1303_shutdown(component);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new sma1303_aif_in_source_control =\n\tSOC_DAPM_ENUM(\"AIF IN Source\", sma1303_aif_in_source_enum);\nstatic const struct snd_kcontrol_new sma1303_aif_out_source_control =\n\tSOC_DAPM_ENUM(\"AIF OUT Source\", sma1303_aif_out_source_enum);\nstatic const struct snd_kcontrol_new sma1303_sdo_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\nstatic const struct snd_kcontrol_new sma1303_post_scaler_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\nstatic const struct snd_kcontrol_new sma1303_enable_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\n\nstatic const struct snd_kcontrol_new sma1303_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", SMA1303_0A_SPK_VOL,\n\t\t0, 167, 1, sma1303_spk_tlv),\n\tSOC_SINGLE_BOOL_EXT(\"Force Mute Switch\", 0,\n\t\tsma1303_force_mute_get, sma1303_force_mute_put),\n\tSOC_SINGLE_EXT(\"Postscaler Gain\", SMA1303_90_POSTSCALER, 1, 0x30, 0,\n\t\tsma1303_postscaler_get, sma1303_postscaler_put),\n\tSOC_ENUM_EXT(\"TDM RX Slot Position\", sma1303_tdm_slot_enum,\n\t\t\tsma1303_tdm_slot_rx_get, sma1303_tdm_slot_rx_put),\n\tSOC_ENUM_EXT(\"TDM TX Slot Position\", sma1303_tdm_slot_enum,\n\t\t\tsma1303_tdm_slot_tx_get, sma1303_tdm_slot_tx_put),\n};\n\nstatic const struct snd_soc_dapm_widget sma1303_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\tSND_SOC_DAPM_INPUT(\"SDO\"),\n\n\t \n\tSND_SOC_DAPM_MUX_E(\"AIF IN Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t&sma1303_aif_in_source_control,\n\t\t\tsma1303_aif_in_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_MUX_E(\"AIF OUT Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t&sma1303_aif_out_source_control,\n\t\t\tsma1303_aif_out_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_SWITCH_E(\"SDO Enable\", SND_SOC_NOPM, 0, 0,\n\t\t\t&sma1303_sdo_control,\n\t\t\tsma1303_sdo_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MIXER(\"Entry\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SWITCH_E(\"Post Scaler\", SND_SOC_NOPM, 0, 1,\n\t\t\t&sma1303_post_scaler_control,\n\t\t\tsma1303_post_scaler_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUT_DRV_E(\"AMP Power\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\tsma1303_power_event,\n\t\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SWITCH(\"AMP Enable\", SND_SOC_NOPM, 0, 1,\n\t\t\t&sma1303_enable_control),\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF IN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF OUT\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route sma1303_audio_map[] = {\n\t \n\t{\"AIF IN Source\", \"Mono\", \"AIF IN\"},\n\t{\"AIF IN Source\", \"Left\", \"AIF IN\"},\n\t{\"AIF IN Source\", \"Right\", \"AIF IN\"},\n\n\t{\"SDO Enable\", \"Switch\", \"AIF IN\"},\n\t{\"AIF OUT Source\", \"Disable\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"After_FmtC\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"After_Mixer\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"After_DSP\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"After_Post\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"Clk_PLL\", \"SDO Enable\"},\n\t{\"AIF OUT Source\", \"Clk_OSC\", \"SDO Enable\"},\n\n\t{\"Entry\", NULL, \"AIF OUT Source\"},\n\t{\"Entry\", NULL, \"AIF IN Source\"},\n\n\t{\"Post Scaler\", \"Switch\", \"Entry\"},\n\t{\"AMP Power\", NULL, \"Entry\"},\n\t{\"AMP Power\", NULL, \"Entry\"},\n\n\t{\"AMP Enable\", \"Switch\", \"AMP Power\"},\n\t{\"SPK\", NULL, \"AMP Enable\"},\n\n\t \n\t{\"AIF OUT\", NULL, \"AMP Enable\"},\n};\n\nstatic int sma1303_setup_pll(struct snd_soc_component *component,\n\t\tunsigned int bclk)\n{\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\n\tint i = 0, ret = 0;\n\n\tdev_dbg(component->dev, \"%s : BCLK = %dHz\\n\",\n\t\t__func__, bclk);\n\n\tif (sma1303->sys_clk_id == SMA1303_PLL_CLKIN_MCLK) {\n\t\tdev_dbg(component->dev, \"%s : MCLK is not supported\\n\",\n\t\t__func__);\n\t} else if (sma1303->sys_clk_id == SMA1303_PLL_CLKIN_BCLK) {\n\t\tfor (i = 0; i < sma1303->num_of_pll_matches; i++) {\n\t\t\tif (sma1303->pll_matches[i].input_clk == bclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == sma1303->num_of_pll_matches) {\n\t\t\tdev_dbg(component->dev, \"%s : No matching value between pll table and SCK\\n\",\n\t\t\t\t\t__func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A2_TOP_MAN1,\n\t\t\t\tSMA1303_PLL_PD_MASK|SMA1303_PLL_REF_CLK_MASK,\n\t\t\t\tSMA1303_PLL_OPERATION|SMA1303_PLL_SCK,\n\t\t\t\tNULL);\n\t}\n\n\tret += sma1303_regmap_write(sma1303,\n\t\t\tSMA1303_8B_PLL_POST_N,\n\t\t\tsma1303->pll_matches[i].post_n);\n\n\tret += sma1303_regmap_write(sma1303,\n\t\t\tSMA1303_8C_PLL_N,\n\t\t\tsma1303->pll_matches[i].n);\n\n\tret += sma1303_regmap_write(sma1303,\n\t\t\tSMA1303_8D_PLL_A_SETTING,\n\t\t\tsma1303->pll_matches[i].vco);\n\n\tret += sma1303_regmap_write(sma1303,\n\t\t\tSMA1303_8F_PLL_P_CP,\n\t\t\tsma1303->pll_matches[i].p_cp);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sma1303_dai_hw_params_amp(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tunsigned int bclk = 0;\n\tint ret = 0;\n\n\tif (sma1303->format == SND_SOC_DAIFMT_DSP_A)\n\t\tbclk = params_rate(params) * sma1303->frame_size;\n\telse\n\t\tbclk = params_rate(params) * params_physical_width(params)\n\t\t\t* params_channels(params);\n\n\tdev_dbg(component->dev,\n\t\t\t\"%s : rate = %d : bit size = %d : channel = %d\\n\",\n\t\t\t__func__, params_rate(params), params_width(params),\n\t\t\tparams_channels(params));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (sma1303->sys_clk_id == SMA1303_PLL_CLKIN_BCLK) {\n\t\t\tif (sma1303->last_bclk != bclk) {\n\t\t\t\tsma1303_setup_pll(component, bclk);\n\t\t\t\tsma1303->last_bclk = bclk;\n\t\t\t}\n\t\t}\n\n\t\tswitch (params_rate(params)) {\n\t\tcase 8000:\n\t\tcase 12000:\n\t\tcase 16000:\n\t\tcase 24000:\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\tcase 96000:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A2_TOP_MAN1,\n\t\t\t\t\tSMA1303_DAC_DN_CONV_MASK,\n\t\t\t\t\tSMA1303_DAC_DN_CONV_DISABLE,\n\t\t\t\t\tNULL);\n\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\t\tSMA1303_LEFTPOL_MASK,\n\t\t\t\t\tSMA1303_LOW_FIRST_CH,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\n\t\tcase 192000:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A2_TOP_MAN1,\n\t\t\t\t\tSMA1303_DAC_DN_CONV_MASK,\n\t\t\t\t\tSMA1303_DAC_DN_CONV_ENABLE,\n\t\t\t\t\tNULL);\n\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\t\tSMA1303_LEFTPOL_MASK,\n\t\t\t\t\tSMA1303_HIGH_FIRST_CH,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"%s not support rate : %d\\n\",\n\t\t\t\t__func__, params_rate(params));\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else {\n\n\t\tswitch (params_format(params)) {\n\n\t\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"%s set format SNDRV_PCM_FORMAT_S16_LE\\n\",\n\t\t\t\t__func__);\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\t\tSMA1303_SCK_RATE_MASK,\n\t\t\t\t\tSMA1303_SCK_32FS,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\n\t\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"%s set format SNDRV_PCM_FORMAT_S24_LE\\n\",\n\t\t\t\t__func__);\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\t\tSMA1303_SCK_RATE_MASK,\n\t\t\t\t\tSMA1303_SCK_64FS,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"%s set format SNDRV_PCM_FORMAT_S32_LE\\n\",\n\t\t\t\t__func__);\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\t\tSMA1303_SCK_RATE_MASK,\n\t\t\t\t\tSMA1303_SCK_64FS,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"%s not support data bit : %d\\n\", __func__,\n\t\t\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (sma1303->format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_I2S_MODE_MASK,\n\t\t\t\tSMA1303_STANDARD_I2S,\n\t\t\t\tNULL);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\tSMA1303_O_FORMAT_MASK,\n\t\t\t\tSMA1303_O_FMT_I2S,\n\t\t\t\tNULL);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_I2S_MODE_MASK,\n\t\t\t\tSMA1303_LJ,\n\t\t\t\tNULL);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\tSMA1303_O_FORMAT_MASK,\n\t\t\t\tSMA1303_O_FMT_LJ,\n\t\t\t\tNULL);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\t\tSMA1303_I2S_MODE_MASK,\n\t\t\t\t\tSMA1303_RJ_16BIT,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\t\tSMA1303_I2S_MODE_MASK,\n\t\t\t\t\tSMA1303_RJ_24BIT,\n\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_I2S_MODE_MASK,\n\t\t\t\tSMA1303_STANDARD_I2S,\n\t\t\t\tNULL);\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\tSMA1303_O_FORMAT_MASK,\n\t\t\t\tSMA1303_O_FMT_TDM,\n\t\t\t\tNULL);\n\t\tbreak;\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"%s not support data bit : %d\\n\", __func__,\n\t\t\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sma1303_dai_set_sysclk_amp(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase SMA1303_EXTERNAL_CLOCK_19_2:\n\t\tbreak;\n\tcase SMA1303_EXTERNAL_CLOCK_24_576:\n\t\tbreak;\n\tcase SMA1303_PLL_CLKIN_MCLK:\n\t\tbreak;\n\tcase SMA1303_PLL_CLKIN_BCLK:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clk id: %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\tsma1303->sys_clk_id = clk_id;\n\treturn 0;\n}\n\nstatic int sma1303_dai_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\treturn ret;\n\n\tif (mute) {\n\t\tdev_dbg(component->dev, \"%s : %s\\n\", __func__, \"MUTE\");\n\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_0E_MUTE_VOL_CTRL,\n\t\t\t\tSMA1303_SPK_MUTE_MASK,\n\t\t\t\tSMA1303_SPK_MUTE,\n\t\t\t\tNULL);\n\n\t\t \n\t\tmsleep(55);\n\t} else {\n\t\tif (!sma1303->force_mute_status) {\n\t\t\tdev_dbg(component->dev, \"%s : %s\\n\",\n\t\t\t\t\t__func__, \"UNMUTE\");\n\t\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_0E_MUTE_VOL_CTRL,\n\t\t\t\t\tSMA1303_SPK_MUTE_MASK,\n\t\t\t\t\tSMA1303_SPK_UNMUTE,\n\t\t\t\t\tNULL);\n\t\t} else {\n\t\t\tdev_dbg(sma1303->dev,\n\t\t\t\t\t\"%s : FORCE MUTE!!!\\n\", __func__);\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int sma1303_dai_set_fmt_amp(struct snd_soc_dai *dai,\n\t\t\t\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component  = dai->component;\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tdev_dbg(component->dev,\n\t\t\t\t\"%s : %s\\n\", __func__, \"I2S/TDM Device mode\");\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_CONTROLLER_DEVICE_MASK,\n\t\t\t\tSMA1303_DEVICE_MODE,\n\t\t\t\tNULL);\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tdev_dbg(component->dev,\n\t\t\t\"%s : %s\\n\", __func__, \"I2S/TDM Controller mode\");\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_CONTROLLER_DEVICE_MASK,\n\t\t\t\tSMA1303_CONTROLLER_MODE,\n\t\t\t\tNULL);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"Unsupported Controller/Device : 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tsma1303->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"Unsupported Audio Interface Format : 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tdev_dbg(component->dev, \"%s : %s\\n\",\n\t\t\t__func__, \"Invert BCLK + Normal Frame\");\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_SCK_RISING_MASK,\n\t\t\t\tSMA1303_SCK_RISING_EDGE,\n\t\t\t\tNULL);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tdev_dbg(component->dev, \"%s : %s\\n\",\n\t\t\t__func__, \"Invert BCLK + Invert Frame\");\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_LEFTPOL_MASK|SMA1303_SCK_RISING_MASK,\n\t\t\t\tSMA1303_HIGH_FIRST_CH|SMA1303_SCK_RISING_EDGE,\n\t\t\t\tNULL);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tdev_dbg(component->dev, \"%s : %s\\n\",\n\t\t\t__func__, \"Normal BCLK + Invert Frame\");\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_01_INPUT1_CTRL1,\n\t\t\t\tSMA1303_LEFTPOL_MASK,\n\t\t\t\tSMA1303_HIGH_FIRST_CH,\n\t\t\t\tNULL);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tdev_dbg(component->dev, \"%s : %s\\n\",\n\t\t\t__func__, \"Normal BCLK + Normal Frame\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\t\"Unsupported Bit & Frameclock : 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int sma1303_dai_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tdev_dbg(component->dev, \"%s : slots = %d, slot_width - %d\\n\",\n\t\t\t__func__, slots, slot_width);\n\n\tsma1303->frame_size = slot_width * slots;\n\n\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A4_TOP_MAN3,\n\t\t\t\tSMA1303_O_FORMAT_MASK,\n\t\t\t\tSMA1303_O_FMT_TDM,\n\t\t\t\tNULL);\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A6_TDM2,\n\t\t\t\t\tSMA1303_TDM_DL_MASK,\n\t\t\t\t\tSMA1303_TDM_DL_16,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase 32:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A6_TDM2,\n\t\t\t\t\tSMA1303_TDM_DL_MASK,\n\t\t\t\t\tSMA1303_TDM_DL_32,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s not support TDM %d slot_width\\n\",\n\t\t\t\t\t__func__, slot_width);\n\t\tbreak;\n\t}\n\n\tswitch (slots) {\n\tcase 4:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A6_TDM2,\n\t\t\t\t\tSMA1303_TDM_N_SLOT_MASK,\n\t\t\t\t\tSMA1303_TDM_N_SLOT_4,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tcase 8:\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A6_TDM2,\n\t\t\t\t\tSMA1303_TDM_N_SLOT_MASK,\n\t\t\t\t\tSMA1303_TDM_N_SLOT_8,\n\t\t\t\t\tNULL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s not support TDM %d slots\\n\",\n\t\t\t\t__func__, slots);\n\t\tbreak;\n\t}\n\n\tif (sma1303->tdm_slot_rx < slots)\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A5_TDM1,\n\t\t\t\t\tSMA1303_TDM_SLOT1_RX_POS_MASK,\n\t\t\t\t\t(sma1303->tdm_slot_rx) << 3,\n\t\t\t\t\tNULL);\n\telse\n\t\tdev_err(component->dev, \"%s Incorrect tdm-slot-rx %d set\\n\",\n\t\t\t\t\t__func__, sma1303->tdm_slot_rx);\n\n\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A5_TDM1,\n\t\t\t\tSMA1303_TDM_CLK_POL_MASK,\n\t\t\t\tSMA1303_TDM_CLK_POL_RISE,\n\t\t\t\tNULL);\n\n\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\tSMA1303_A5_TDM1,\n\t\t\t\tSMA1303_TDM_TX_MODE_MASK,\n\t\t\t\tSMA1303_TDM_TX_MONO,\n\t\t\t\tNULL);\n\n\tif (sma1303->tdm_slot_tx < slots)\n\t\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\t\t\tSMA1303_A6_TDM2,\n\t\t\t\t\tSMA1303_TDM_SLOT1_TX_POS_MASK,\n\t\t\t\t\t(sma1303->tdm_slot_tx) << 3,\n\t\t\t\t\tNULL);\n\telse\n\t\tdev_err(component->dev, \"%s Incorrect tdm-slot-tx %d set\\n\",\n\t\t\t\t__func__, sma1303->tdm_slot_tx);\n\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sma1303_dai_ops_amp = {\n\t.set_sysclk = sma1303_dai_set_sysclk_amp,\n\t.set_fmt = sma1303_dai_set_fmt_amp,\n\t.hw_params = sma1303_dai_hw_params_amp,\n\t.mute_stream = sma1303_dai_mute,\n\t.set_tdm_slot = sma1303_dai_set_tdm_slot,\n};\n\n#define SMA1303_RATES SNDRV_PCM_RATE_8000_192000\n#define SMA1303_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver sma1303_dai[] = {\n\t{\n\t\t.name = \"sma1303-amplifier\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SMA1303_RATES,\n\t\t\t.formats = SMA1303_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SMA1303_RATES,\n\t\t\t.formats = SMA1303_FORMATS,\n\t\t},\n\t\t.ops = &sma1303_dai_ops_amp,\n\t},\n};\n\nstatic void sma1303_check_fault_worker(struct work_struct *work)\n{\n\tstruct sma1303_priv *sma1303 =\n\t\tcontainer_of(work, struct sma1303_priv, check_fault_work.work);\n\tint ret = 0;\n\tunsigned int over_temp, ocp_val, uvlo_val;\n\n\tif (sma1303->tsdw_cnt)\n\t\tret = sma1303_regmap_read(sma1303,\n\t\t\tSMA1303_0A_SPK_VOL, &sma1303->cur_vol);\n\telse\n\t\tret = sma1303_regmap_read(sma1303,\n\t\t\tSMA1303_0A_SPK_VOL, &sma1303->init_vol);\n\n\tif (ret != 0) {\n\t\tdev_err(sma1303->dev,\n\t\t\t\"failed to read SMA1303_0A_SPK_VOL : %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_FA_STATUS1, &over_temp);\n\tif (ret != 0) {\n\t\tdev_err(sma1303->dev,\n\t\t\t\"failed to read SMA1303_FA_STATUS1 : %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_FB_STATUS2, &ocp_val);\n\tif (ret != 0) {\n\t\tdev_err(sma1303->dev,\n\t\t\t\"failed to read SMA1303_FB_STATUS2 : %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = sma1303_regmap_read(sma1303, SMA1303_FF_DEVICE_INDEX, &uvlo_val);\n\tif (ret != 0) {\n\t\tdev_err(sma1303->dev,\n\t\t\t\"failed to read SMA1303_FF_DEVICE_INDEX : %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (~over_temp & SMA1303_OT1_OK_STATUS) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : OT1(Over Temperature Level 1)\\n\", __func__);\n\n\t\tif ((sma1303->cur_vol + 6) <= 0xFF)\n\t\t\tsma1303_regmap_write(sma1303,\n\t\t\t\tSMA1303_0A_SPK_VOL, sma1303->cur_vol + 6);\n\n\t\tsma1303->tsdw_cnt++;\n\t} else if (sma1303->tsdw_cnt) {\n\t\tsma1303_regmap_write(sma1303,\n\t\t\t\tSMA1303_0A_SPK_VOL, sma1303->init_vol);\n\t\tsma1303->tsdw_cnt = 0;\n\t\tsma1303->cur_vol = sma1303->init_vol;\n\t}\n\n\tif (~over_temp & SMA1303_OT2_OK_STATUS) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : OT2(Over Temperature Level 2)\\n\", __func__);\n\t}\n\tif (ocp_val & SMA1303_OCP_SPK_STATUS) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : OCP_SPK(Over Current Protect SPK)\\n\", __func__);\n\t}\n\tif (ocp_val & SMA1303_OCP_BST_STATUS) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : OCP_BST(Over Current Protect Boost)\\n\", __func__);\n\t}\n\tif ((ocp_val & SMA1303_CLK_MON_STATUS) && (sma1303->amp_power_status)) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : CLK_FAULT(No clock input)\\n\", __func__);\n\t}\n\tif (uvlo_val & SMA1303_UVLO_BST_STATUS) {\n\t\tdev_crit(sma1303->dev,\n\t\t\t\"%s : UVLO(Under Voltage Lock Out)\\n\", __func__);\n\t}\n\n\tif ((over_temp != sma1303->last_over_temp) ||\n\t\t(ocp_val != sma1303->last_ocp_val)) {\n\n\t\tdev_crit(sma1303->dev, \"Please check AMP status\");\n\t\tdev_dbg(sma1303->dev, \"STATUS1=0x%02X : STATUS2=0x%02X\\n\",\n\t\t\t\tover_temp, ocp_val);\n\t\tsma1303->last_over_temp = over_temp;\n\t\tsma1303->last_ocp_val = ocp_val;\n\t}\n\n\tif (sma1303->check_fault_status) {\n\t\tif (sma1303->check_fault_period > 0)\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tsma1303->check_fault_period * HZ);\n\t\telse\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tCHECK_PERIOD_TIME * HZ);\n\t}\n\n\tif (!(~over_temp & SMA1303_OT1_OK_STATUS)\n\t\t\t&& !(~over_temp & SMA1303_OT2_OK_STATUS)\n\t\t\t&& !(ocp_val & SMA1303_OCP_SPK_STATUS)\n\t\t\t&& !(ocp_val & SMA1303_OCP_BST_STATUS)\n\t\t\t&& !(ocp_val & SMA1303_CLK_MON_STATUS)\n\t\t\t&& !(uvlo_val & SMA1303_UVLO_BST_STATUS)) {\n\t}\n}\n\nstatic int sma1303_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_sync(dapm);\n\n\treturn 0;\n}\n\nstatic void sma1303_remove(struct snd_soc_component *component)\n{\n\tstruct sma1303_priv *sma1303 = snd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&sma1303->check_fault_work);\n}\n\nstatic const struct snd_soc_component_driver sma1303_component = {\n\t.probe = sma1303_probe,\n\t.remove = sma1303_remove,\n\t.controls = sma1303_snd_controls,\n\t.num_controls = ARRAY_SIZE(sma1303_snd_controls),\n\t.dapm_widgets = sma1303_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(sma1303_dapm_widgets),\n\t.dapm_routes = sma1303_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(sma1303_audio_map),\n};\n\nstatic const struct regmap_config sma_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = SMA1303_FF_DEVICE_INDEX,\n\t.readable_reg = sma1303_readable_register,\n\t.writeable_reg = sma1303_writeable_register,\n\t.volatile_reg = sma1303_volatile_register,\n\n\t.cache_type = REGCACHE_NONE,\n\t.reg_defaults = sma1303_reg_def,\n\t.num_reg_defaults = ARRAY_SIZE(sma1303_reg_def),\n};\n\nstatic ssize_t check_fault_period_show(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sma1303_priv *sma1303 = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", sma1303->check_fault_period);\n}\n\nstatic ssize_t check_fault_period_store(struct device *dev,\n\tstruct device_attribute *devattr, const char *buf, size_t count)\n{\n\tstruct sma1303_priv *sma1303 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtol(buf, 10, &sma1303->check_fault_period);\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn (ssize_t)count;\n}\n\nstatic DEVICE_ATTR_RW(check_fault_period);\n\nstatic ssize_t check_fault_status_show(struct device *dev,\n\tstruct device_attribute *devattr, char *buf)\n{\n\tstruct sma1303_priv *sma1303 = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%ld\\n\", sma1303->check_fault_status);\n}\n\nstatic ssize_t check_fault_status_store(struct device *dev,\n\tstruct device_attribute *devattr, const char *buf, size_t count)\n{\n\tstruct sma1303_priv *sma1303 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = kstrtol(buf, 10, &sma1303->check_fault_status);\n\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (sma1303->check_fault_status) {\n\t\tif (sma1303->check_fault_period > 0)\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tsma1303->check_fault_period * HZ);\n\t\telse\n\t\t\tqueue_delayed_work(system_freezable_wq,\n\t\t\t\t&sma1303->check_fault_work,\n\t\t\t\t\tCHECK_PERIOD_TIME * HZ);\n\t}\n\n\treturn (ssize_t)count;\n}\n\nstatic DEVICE_ATTR_RW(check_fault_status);\n\nstatic struct attribute *sma1303_attr[] = {\n\t&dev_attr_check_fault_period.attr,\n\t&dev_attr_check_fault_status.attr,\n\tNULL,\n};\n\nstatic struct attribute_group sma1303_attr_group = {\n\t.attrs = sma1303_attr,\n};\n\nstatic int sma1303_i2c_probe(struct i2c_client *client)\n{\n\tstruct sma1303_priv *sma1303;\n\tint ret, i = 0;\n\tunsigned int device_info, status, otp_stat;\n\n\tsma1303 = devm_kzalloc(&client->dev,\n\t\t\t\tsizeof(struct sma1303_priv), GFP_KERNEL);\n\tif (!sma1303)\n\t\treturn -ENOMEM;\n\tsma1303->dev = &client->dev;\n\n\tsma1303->regmap = devm_regmap_init_i2c(client, &sma_i2c_regmap);\n\tif (IS_ERR(sma1303->regmap)) {\n\t\tret = PTR_ERR(sma1303->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate register map: %d\\n\", ret);\n\n\t\treturn ret;\n\t}\n\n\tret = sma1303_regmap_read(sma1303,\n\t\t\tSMA1303_FF_DEVICE_INDEX, &device_info);\n\n\tif ((ret != 0) || ((device_info & 0xF8) != SMA1303_DEVICE_ID)) {\n\t\tdev_err(&client->dev, \"device initialization error (%d 0x%02X)\",\n\t\t\t\tret, device_info);\n\t}\n\tdev_dbg(&client->dev, \"chip version 0x%02X\\n\", device_info);\n\n\tret += sma1303_regmap_update_bits(sma1303,\n\t\t\tSMA1303_00_SYSTEM_CTRL,\n\t\t\tSMA1303_RESETBYI2C_MASK, SMA1303_RESETBYI2C_RESET,\n\t\t\tNULL);\n\n\tret += sma1303_regmap_read(sma1303, SMA1303_FF_DEVICE_INDEX, &status);\n\tsma1303->rev_num = status & SMA1303_REV_NUM_STATUS;\n\tif (sma1303->rev_num == SMA1303_REV_NUM_TV0)\n\t\tdev_dbg(&client->dev, \"SMA1303 Trimming Version 0\\n\");\n\telse if (sma1303->rev_num == SMA1303_REV_NUM_TV1)\n\t\tdev_dbg(&client->dev, \"SMA1303 Trimming Version 1\\n\");\n\n\tret += sma1303_regmap_read(sma1303, SMA1303_FB_STATUS2, &otp_stat);\n\tif (ret < 0)\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to read, register: %02X, ret: %d\\n\",\n\t\t\t\tSMA1303_FF_DEVICE_INDEX, ret);\n\n\tif (((sma1303->rev_num == SMA1303_REV_NUM_TV0) &&\n\t\t((otp_stat & 0x0E) == SMA1303_OTP_STAT_OK_0)) ||\n\t\t((sma1303->rev_num != SMA1303_REV_NUM_TV0) &&\n\t\t((otp_stat & 0x0C) == SMA1303_OTP_STAT_OK_1)))\n\t\tdev_dbg(&client->dev, \"SMA1303 OTP Status Successful\\n\");\n\telse\n\t\tdev_dbg(&client->dev, \"SMA1303 OTP Status Fail\\n\");\n\n\tfor (i = 0; i < (unsigned int)ARRAY_SIZE(sma1303_reg_def); i++)\n\t\tret += sma1303_regmap_write(sma1303,\n\t\t\t\tsma1303_reg_def[i].reg,\n\t\t\t\tsma1303_reg_def[i].def);\n\n\tsma1303->amp_mode = SMA1303_MONO;\n\tsma1303->amp_power_status = false;\n\tsma1303->check_fault_period = CHECK_PERIOD_TIME;\n\tsma1303->check_fault_status = true;\n\tsma1303->force_mute_status = false;\n\tsma1303->init_vol = 0x31;\n\tsma1303->cur_vol = sma1303->init_vol;\n\tsma1303->last_bclk = 0;\n\tsma1303->last_ocp_val = 0x08;\n\tsma1303->last_over_temp = 0xC0;\n\tsma1303->tsdw_cnt = 0;\n\tsma1303->retry_cnt = SMA1303_I2C_RETRY_COUNT;\n\tsma1303->tdm_slot_rx = 0;\n\tsma1303->tdm_slot_tx = 0;\n\tsma1303->sys_clk_id = SMA1303_PLL_CLKIN_BCLK;\n\n\tsma1303->dev = &client->dev;\n\tsma1303->kobj = &client->dev.kobj;\n\n\tINIT_DELAYED_WORK(&sma1303->check_fault_work,\n\t\tsma1303_check_fault_worker);\n\n\ti2c_set_clientdata(client, sma1303);\n\n\tsma1303->pll_matches = sma1303_pll_matches;\n\tsma1303->num_of_pll_matches =\n\t\tARRAY_SIZE(sma1303_pll_matches);\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t&sma1303_component, sma1303_dai, 1);\n\tif (ret) {\n\t\tdev_err(&client->dev, \"Failed to register component\");\n\n\t\treturn ret;\n\t}\n\n\tsma1303->attr_grp = &sma1303_attr_group;\n\tret = sysfs_create_group(sma1303->kobj, sma1303->attr_grp);\n\tif (ret) {\n\t\tdev_err(&client->dev,\n\t\t\t\"failed to create attribute group [%d]\\n\", ret);\n\t\tsma1303->attr_grp = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void sma1303_i2c_remove(struct i2c_client *client)\n{\n\tstruct sma1303_priv *sma1303 =\n\t\t(struct sma1303_priv *) i2c_get_clientdata(client);\n\n\tcancel_delayed_work_sync(&sma1303->check_fault_work);\n}\n\nstatic const struct i2c_device_id sma1303_i2c_id[] = {\n\t{\"sma1303\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, sma1303_i2c_id);\n\nstatic const struct of_device_id sma1303_of_match[] = {\n\t{ .compatible = \"irondevice,sma1303\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sma1303_of_match);\n\nstatic struct i2c_driver sma1303_i2c_driver = {\n\t.driver = {\n\t\t.name = \"sma1303\",\n\t\t.of_match_table = sma1303_of_match,\n\t},\n\t.probe = sma1303_i2c_probe,\n\t.remove = sma1303_i2c_remove,\n\t.id_table = sma1303_i2c_id,\n};\n\nmodule_i2c_driver(sma1303_i2c_driver);\n\nMODULE_DESCRIPTION(\"ALSA SoC SMA1303 driver\");\nMODULE_AUTHOR(\"Gyuhwa Park, <gyuhwa.park@irondevice.com>\");\nMODULE_AUTHOR(\"Kiseok Jo, <kiseok.jo@irondevice.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}