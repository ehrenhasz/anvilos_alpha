{
  "module_name": "tscs42xx.c",
  "hash_id": "bbf39f78b12d8d108a079586d8cb5e217ef37662f9285519ef91f8f7bab3d301",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tscs42xx.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/clk.h>\n#include <sound/tlv.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n#include \"tscs42xx.h\"\n\n#define COEFF_SIZE 3\n#define BIQUAD_COEFF_COUNT 5\n#define BIQUAD_SIZE (COEFF_SIZE * BIQUAD_COEFF_COUNT)\n\n#define COEFF_RAM_MAX_ADDR 0xcd\n#define COEFF_RAM_COEFF_COUNT (COEFF_RAM_MAX_ADDR + 1)\n#define COEFF_RAM_SIZE (COEFF_SIZE * COEFF_RAM_COEFF_COUNT)\n\nstruct tscs42xx {\n\n\tint bclk_ratio;\n\tint samplerate;\n\tstruct mutex audio_params_lock;\n\n\tu8 coeff_ram[COEFF_RAM_SIZE];\n\tbool coeff_ram_synced;\n\tstruct mutex coeff_ram_lock;\n\n\tstruct mutex pll_lock;\n\n\tstruct regmap *regmap;\n\n\tstruct clk *sysclk;\n\tint sysclk_src_id;\n};\n\nstruct coeff_ram_ctl {\n\tunsigned int addr;\n\tstruct soc_bytes_ext bytes_ext;\n};\n\nstatic bool tscs42xx_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_DACCRWRL:\n\tcase R_DACCRWRM:\n\tcase R_DACCRWRH:\n\tcase R_DACCRRDL:\n\tcase R_DACCRRDM:\n\tcase R_DACCRRDH:\n\tcase R_DACCRSTAT:\n\tcase R_DACCRADDR:\n\tcase R_PLLCTL0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tscs42xx_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_DACCRWRL:\n\tcase R_DACCRWRM:\n\tcase R_DACCRWRH:\n\tcase R_DACCRRDL:\n\tcase R_DACCRRDM:\n\tcase R_DACCRRDH:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tscs42xx_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.volatile_reg = tscs42xx_volatile,\n\t.precious_reg = tscs42xx_precious,\n\t.max_register = R_DACMBCREL3H,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.can_multi_write = true,\n};\n\n#define MAX_PLL_LOCK_20MS_WAITS 1\nstatic bool plls_locked(struct snd_soc_component *component)\n{\n\tint ret;\n\tint count = MAX_PLL_LOCK_20MS_WAITS;\n\n\tdo {\n\t\tret = snd_soc_component_read(component, R_PLLCTL0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to read PLL lock status (%d)\\n\", ret);\n\t\t\treturn false;\n\t\t} else if (ret > 0) {\n\t\t\treturn true;\n\t\t}\n\t\tmsleep(20);\n\t} while (count--);\n\n\treturn false;\n}\n\nstatic int sample_rate_to_pll_freq_out(int sample_rate)\n{\n\tswitch (sample_rate) {\n\tcase 11025:\n\tcase 22050:\n\tcase 44100:\n\tcase 88200:\n\t\treturn 112896000;\n\tcase 8000:\n\tcase 16000:\n\tcase 32000:\n\tcase 48000:\n\tcase 96000:\n\t\treturn 122880000;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n#define DACCRSTAT_MAX_TRYS 10\nstatic int write_coeff_ram(struct snd_soc_component *component, u8 *coeff_ram,\n\tunsigned int addr, unsigned int coeff_cnt)\n{\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tint cnt;\n\tint trys;\n\tint ret;\n\n\tfor (cnt = 0; cnt < coeff_cnt; cnt++, addr++) {\n\n\t\tfor (trys = 0; trys < DACCRSTAT_MAX_TRYS; trys++) {\n\t\t\tret = snd_soc_component_read(component, R_DACCRSTAT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to read stat (%d)\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (trys == DACCRSTAT_MAX_TRYS) {\n\t\t\tret = -EIO;\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"dac coefficient write error (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(tscs42xx->regmap, R_DACCRADDR, addr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to write dac ram address (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_bulk_write(tscs42xx->regmap, R_DACCRWRL,\n\t\t\t&coeff_ram[addr * COEFF_SIZE],\n\t\t\tCOEFF_SIZE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to write dac ram (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int power_up_audio_plls(struct snd_soc_component *component)\n{\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tint freq_out;\n\tint ret;\n\tunsigned int mask;\n\tunsigned int val;\n\n\tfreq_out = sample_rate_to_pll_freq_out(tscs42xx->samplerate);\n\tswitch (freq_out) {\n\tcase 122880000:  \n\t\tmask = RM_PLLCTL1C_PDB_PLL1;\n\t\tval = RV_PLLCTL1C_PDB_PLL1_ENABLE;\n\t\tbreak;\n\tcase 112896000:  \n\t\tmask = RM_PLLCTL1C_PDB_PLL2;\n\t\tval = RV_PLLCTL1C_PDB_PLL2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev,\n\t\t\t\t\"Unrecognized PLL output freq (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&tscs42xx->pll_lock);\n\n\tret = snd_soc_component_update_bits(component, R_PLLCTL1C, mask, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to turn PLL on (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (!plls_locked(component)) {\n\t\tdev_err(component->dev, \"Failed to lock plls\\n\");\n\t\tret = -ENOMSG;\n\t\tgoto exit;\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs42xx->pll_lock);\n\n\treturn ret;\n}\n\nstatic int power_down_audio_plls(struct snd_soc_component *component)\n{\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&tscs42xx->pll_lock);\n\n\tret = snd_soc_component_update_bits(component, R_PLLCTL1C,\n\t\t\tRM_PLLCTL1C_PDB_PLL1,\n\t\t\tRV_PLLCTL1C_PDB_PLL1_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to turn PLL off (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = snd_soc_component_update_bits(component, R_PLLCTL1C,\n\t\t\tRM_PLLCTL1C_PDB_PLL2,\n\t\t\tRV_PLLCTL1C_PDB_PLL2_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to turn PLL off (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs42xx->pll_lock);\n\n\treturn ret;\n}\n\nstatic int coeff_ram_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\n\tmutex_lock(&tscs42xx->coeff_ram_lock);\n\n\tmemcpy(ucontrol->value.bytes.data,\n\t\t&tscs42xx->coeff_ram[ctl->addr * COEFF_SIZE], params->max);\n\n\tmutex_unlock(&tscs42xx->coeff_ram_lock);\n\n\treturn 0;\n}\n\nstatic int coeff_ram_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\tunsigned int coeff_cnt = params->max / COEFF_SIZE;\n\tint ret;\n\n\tmutex_lock(&tscs42xx->coeff_ram_lock);\n\n\ttscs42xx->coeff_ram_synced = false;\n\n\tmemcpy(&tscs42xx->coeff_ram[ctl->addr * COEFF_SIZE],\n\t\tucontrol->value.bytes.data, params->max);\n\n\tmutex_lock(&tscs42xx->pll_lock);\n\n\tif (plls_locked(component)) {\n\t\tret = write_coeff_ram(component, tscs42xx->coeff_ram,\n\t\t\tctl->addr, coeff_cnt);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to flush coeff ram cache (%d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t\ttscs42xx->coeff_ram_synced = true;\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs42xx->pll_lock);\n\n\tmutex_unlock(&tscs42xx->coeff_ram_lock);\n\n\treturn ret;\n}\n\n \nstatic char const * const input_select_text[] = {\n\t\"Line 1\", \"Line 2\", \"Line 3\", \"D2S\"\n};\n\nstatic const struct soc_enum left_input_select_enum =\nSOC_ENUM_SINGLE(R_INSELL, FB_INSELL, ARRAY_SIZE(input_select_text),\n\t\tinput_select_text);\n\nstatic const struct snd_kcontrol_new left_input_select =\nSOC_DAPM_ENUM(\"LEFT_INPUT_SELECT_ENUM\", left_input_select_enum);\n\n \nstatic const struct soc_enum right_input_select_enum =\nSOC_ENUM_SINGLE(R_INSELR, FB_INSELR, ARRAY_SIZE(input_select_text),\n\t\tinput_select_text);\n\nstatic const struct snd_kcontrol_new right_input_select =\nSOC_DAPM_ENUM(\"RIGHT_INPUT_SELECT_ENUM\", right_input_select_enum);\n\n \nstatic char const * const ch_map_select_text[] = {\n\t\"Normal\", \"Left to Right\", \"Right to Left\", \"Swap\"\n};\n\nstatic const struct soc_enum ch_map_select_enum =\nSOC_ENUM_SINGLE(R_AIC2, FB_AIC2_ADCDSEL, ARRAY_SIZE(ch_map_select_text),\n\t\tch_map_select_text);\n\nstatic int dapm_vref_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tmsleep(20);\n\treturn 0;\n}\n\nstatic int dapm_micb_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tmsleep(20);\n\treturn 0;\n}\n\nstatic int pll_event(struct snd_soc_dapm_widget *w,\n\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tint ret;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tret = power_up_audio_plls(component);\n\telse\n\t\tret = power_down_audio_plls(component);\n\n\treturn ret;\n}\n\nstatic int dac_event(struct snd_soc_dapm_widget *w,\n\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&tscs42xx->coeff_ram_lock);\n\n\tif (!tscs42xx->coeff_ram_synced) {\n\t\tret = write_coeff_ram(component, tscs42xx->coeff_ram, 0x00,\n\t\t\tCOEFF_RAM_COEFF_COUNT);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\t\ttscs42xx->coeff_ram_synced = true;\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs42xx->coeff_ram_lock);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget tscs42xx_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_SUPPLY_S(\"Vref\", 1, R_PWRM2, FB_PWRM2_VREF, 0,\n\t\tdapm_vref_event, SND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_PRE_PMD),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"PLL\", SND_SOC_NOPM, 0, 0, pll_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_DAC_E(\"DAC L\", \"HiFi Playback\", R_PWRM2, FB_PWRM2_HPL, 0,\n\t\t\tdac_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_DAC_E(\"DAC R\", \"HiFi Playback\", R_PWRM2, FB_PWRM2_HPR, 0,\n\t\t\tdac_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"Headphone L\"),\n\tSND_SOC_DAPM_OUTPUT(\"Headphone R\"),\n\n\t \n\tSND_SOC_DAPM_DAC_E(\"ClassD L\", \"HiFi Playback\",\n\t\tR_PWRM2, FB_PWRM2_SPKL, 0,\n\t\tdac_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_DAC_E(\"ClassD R\", \"HiFi Playback\",\n\t\tR_PWRM2, FB_PWRM2_SPKR, 0,\n\t\tdac_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"Speaker L\"),\n\tSND_SOC_DAPM_OUTPUT(\"Speaker R\"),\n\n\t \n\tSND_SOC_DAPM_PGA(\"Analog In PGA L\", R_PWRM1, FB_PWRM1_PGAL, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Analog In PGA R\", R_PWRM1, FB_PWRM1_PGAR, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Analog Boost L\", R_PWRM1, FB_PWRM1_BSTL, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Analog Boost R\", R_PWRM1, FB_PWRM1_BSTR, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC Mute\", R_CNVRTR0, FB_CNVRTR0_HPOR, true, NULL, 0),\n\tSND_SOC_DAPM_ADC(\"ADC L\", \"HiFi Capture\", R_PWRM1, FB_PWRM1_ADCL, 0),\n\tSND_SOC_DAPM_ADC(\"ADC R\", \"HiFi Capture\", R_PWRM1, FB_PWRM1_ADCR, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Input L Capture Route\", R_PWRM2,\n\t\t\tFB_PWRM2_INSELL, 0, &left_input_select),\n\tSND_SOC_DAPM_MUX(\"Input R Capture Route\", R_PWRM2,\n\t\t\tFB_PWRM2_INSELR, 0, &right_input_select),\n\n\t \n\tSND_SOC_DAPM_SUPPLY_S(\"Digital Mic Enable\", 2, R_DMICCTL,\n\t\tFB_DMICCTL_DMICEN, 0, NULL,\n\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_PRE_PMD),\n\n\t \n\tSND_SOC_DAPM_SUPPLY_S(\"Mic Bias\", 2, R_PWRM1, FB_PWRM1_MICB,\n\t\t0, dapm_micb_event, SND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_PRE_PMD),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"Line In 1 L\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 1 R\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 2 L\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 2 R\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 3 L\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 3 R\"),\n};\n\nstatic const struct snd_soc_dapm_route tscs42xx_intercon[] = {\n\t{\"DAC L\", NULL, \"PLL\"},\n\t{\"DAC R\", NULL, \"PLL\"},\n\t{\"DAC L\", NULL, \"Vref\"},\n\t{\"DAC R\", NULL, \"Vref\"},\n\t{\"Headphone L\", NULL, \"DAC L\"},\n\t{\"Headphone R\", NULL, \"DAC R\"},\n\n\t{\"ClassD L\", NULL, \"PLL\"},\n\t{\"ClassD R\", NULL, \"PLL\"},\n\t{\"ClassD L\", NULL, \"Vref\"},\n\t{\"ClassD R\", NULL, \"Vref\"},\n\t{\"Speaker L\", NULL, \"ClassD L\"},\n\t{\"Speaker R\", NULL, \"ClassD R\"},\n\n\t{\"Input L Capture Route\", NULL, \"Vref\"},\n\t{\"Input R Capture Route\", NULL, \"Vref\"},\n\n\t{\"Mic Bias\", NULL, \"Vref\"},\n\n\t{\"Input L Capture Route\", \"Line 1\", \"Line In 1 L\"},\n\t{\"Input R Capture Route\", \"Line 1\", \"Line In 1 R\"},\n\t{\"Input L Capture Route\", \"Line 2\", \"Line In 2 L\"},\n\t{\"Input R Capture Route\", \"Line 2\", \"Line In 2 R\"},\n\t{\"Input L Capture Route\", \"Line 3\", \"Line In 3 L\"},\n\t{\"Input R Capture Route\", \"Line 3\", \"Line In 3 R\"},\n\n\t{\"Analog In PGA L\", NULL, \"Input L Capture Route\"},\n\t{\"Analog In PGA R\", NULL, \"Input R Capture Route\"},\n\t{\"Analog Boost L\", NULL, \"Analog In PGA L\"},\n\t{\"Analog Boost R\", NULL, \"Analog In PGA R\"},\n\t{\"ADC Mute\", NULL, \"Analog Boost L\"},\n\t{\"ADC Mute\", NULL, \"Analog Boost R\"},\n\t{\"ADC L\", NULL, \"PLL\"},\n\t{\"ADC R\", NULL, \"PLL\"},\n\t{\"ADC L\", NULL, \"ADC Mute\"},\n\t{\"ADC R\", NULL, \"ADC Mute\"},\n};\n\n \n\nstatic char const * const eq_band_enable_text[] = {\n\t\"Prescale only\",\n\t\"Band1\",\n\t\"Band1:2\",\n\t\"Band1:3\",\n\t\"Band1:4\",\n\t\"Band1:5\",\n\t\"Band1:6\",\n};\n\nstatic char const * const level_detection_text[] = {\n\t\"Average\",\n\t\"Peak\",\n};\n\nstatic char const * const level_detection_window_text[] = {\n\t\"512 Samples\",\n\t\"64 Samples\",\n};\n\nstatic char const * const compressor_ratio_text[] = {\n\t\"Reserved\", \"1.5:1\", \"2:1\", \"3:1\", \"4:1\", \"5:1\", \"6:1\",\n\t\"7:1\", \"8:1\", \"9:1\", \"10:1\", \"11:1\", \"12:1\", \"13:1\", \"14:1\",\n\t\"15:1\", \"16:1\", \"17:1\", \"18:1\", \"19:1\", \"20:1\",\n};\n\nstatic DECLARE_TLV_DB_SCALE(hpvol_scale, -8850, 75, 0);\nstatic DECLARE_TLV_DB_SCALE(spkvol_scale, -7725, 75, 0);\nstatic DECLARE_TLV_DB_SCALE(dacvol_scale, -9563, 38, 0);\nstatic DECLARE_TLV_DB_SCALE(adcvol_scale, -7125, 38, 0);\nstatic DECLARE_TLV_DB_SCALE(invol_scale, -1725, 75, 0);\nstatic DECLARE_TLV_DB_SCALE(mic_boost_scale, 0, 1000, 0);\nstatic DECLARE_TLV_DB_MINMAX(mugain_scale, 0, 4650);\nstatic DECLARE_TLV_DB_MINMAX(compth_scale, -9562, 0);\n\nstatic const struct soc_enum eq1_band_enable_enum =\n\tSOC_ENUM_SINGLE(R_CONFIG1, FB_CONFIG1_EQ1_BE,\n\t\tARRAY_SIZE(eq_band_enable_text), eq_band_enable_text);\n\nstatic const struct soc_enum eq2_band_enable_enum =\n\tSOC_ENUM_SINGLE(R_CONFIG1, FB_CONFIG1_EQ2_BE,\n\t\tARRAY_SIZE(eq_band_enable_text), eq_band_enable_text);\n\nstatic const struct soc_enum cle_level_detection_enum =\n\tSOC_ENUM_SINGLE(R_CLECTL, FB_CLECTL_LVL_MODE,\n\t\tARRAY_SIZE(level_detection_text),\n\t\tlevel_detection_text);\n\nstatic const struct soc_enum cle_level_detection_window_enum =\n\tSOC_ENUM_SINGLE(R_CLECTL, FB_CLECTL_WINDOWSEL,\n\t\tARRAY_SIZE(level_detection_window_text),\n\t\tlevel_detection_window_text);\n\nstatic const struct soc_enum mbc_level_detection_enums[] = {\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE1,\n\t\tARRAY_SIZE(level_detection_text),\n\t\t\tlevel_detection_text),\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE2,\n\t\tARRAY_SIZE(level_detection_text),\n\t\t\tlevel_detection_text),\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE3,\n\t\tARRAY_SIZE(level_detection_text),\n\t\t\tlevel_detection_text),\n};\n\nstatic const struct soc_enum mbc_level_detection_window_enums[] = {\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL1,\n\t\tARRAY_SIZE(level_detection_window_text),\n\t\t\tlevel_detection_window_text),\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL2,\n\t\tARRAY_SIZE(level_detection_window_text),\n\t\t\tlevel_detection_window_text),\n\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL3,\n\t\tARRAY_SIZE(level_detection_window_text),\n\t\t\tlevel_detection_window_text),\n};\n\nstatic const struct soc_enum compressor_ratio_enum =\n\tSOC_ENUM_SINGLE(R_CMPRAT, FB_CMPRAT,\n\t\tARRAY_SIZE(compressor_ratio_text), compressor_ratio_text);\n\nstatic const struct soc_enum dac_mbc1_compressor_ratio_enum =\n\tSOC_ENUM_SINGLE(R_DACMBCRAT1, FB_DACMBCRAT1_RATIO,\n\t\tARRAY_SIZE(compressor_ratio_text), compressor_ratio_text);\n\nstatic const struct soc_enum dac_mbc2_compressor_ratio_enum =\n\tSOC_ENUM_SINGLE(R_DACMBCRAT2, FB_DACMBCRAT2_RATIO,\n\t\tARRAY_SIZE(compressor_ratio_text), compressor_ratio_text);\n\nstatic const struct soc_enum dac_mbc3_compressor_ratio_enum =\n\tSOC_ENUM_SINGLE(R_DACMBCRAT3, FB_DACMBCRAT3_RATIO,\n\t\tARRAY_SIZE(compressor_ratio_text), compressor_ratio_text);\n\nstatic int bytes_info_ext(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *ucontrol)\n{\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\n\tucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tucontrol->count = params->max;\n\n\treturn 0;\n}\n\n#define COEFF_RAM_CTL(xname, xcount, xaddr) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = bytes_info_ext, \\\n\t.get = coeff_ram_get, .put = coeff_ram_put, \\\n\t.private_value = (unsigned long)&(struct coeff_ram_ctl) { \\\n\t\t.addr = xaddr, \\\n\t\t.bytes_ext = {.max = xcount, }, \\\n\t} \\\n}\n\nstatic const struct snd_kcontrol_new tscs42xx_snd_controls[] = {\n\t \n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", R_HPVOLL, R_HPVOLR,\n\t\t\tFB_HPVOLL, 0x7F, 0, hpvol_scale),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\", R_SPKVOLL, R_SPKVOLR,\n\t\t\tFB_SPKVOLL, 0x7F, 0, spkvol_scale),\n\tSOC_DOUBLE_R_TLV(\"Master Volume\", R_DACVOLL, R_DACVOLR,\n\t\t\tFB_DACVOLL, 0xFF, 0, dacvol_scale),\n\tSOC_DOUBLE_R_TLV(\"PCM Volume\", R_ADCVOLL, R_ADCVOLR,\n\t\t\tFB_ADCVOLL, 0xFF, 0, adcvol_scale),\n\tSOC_DOUBLE_R_TLV(\"Input Volume\", R_INVOLL, R_INVOLR,\n\t\t\tFB_INVOLL, 0x3F, 0, invol_scale),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Mic Boost Volume\", R_INSELL, R_INSELR,\n\t\t\tFB_INSELL_MICBSTL, FV_INSELL_MICBSTL_30DB,\n\t\t\t0, mic_boost_scale),\n\n\t \n\tSOC_ENUM(\"Input Channel Map\", ch_map_select_enum),\n\n\t \n\tSOC_SINGLE(\"Mic Bias Boost Switch\", 0x71, 0x07, 1, 0),\n\n\t \n\tSOC_SINGLE(\"Headphone Auto Switching Switch\",\n\t\t\tR_CTL, FB_CTL_HPSWEN, 1, 0),\n\tSOC_SINGLE(\"Headphone Detect Polarity Toggle Switch\",\n\t\t\tR_CTL, FB_CTL_HPSWPOL, 1, 0),\n\n\t \n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad1\", BIQUAD_SIZE, 0x00),\n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad2\", BIQUAD_SIZE, 0x05),\n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad3\", BIQUAD_SIZE, 0x0a),\n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad4\", BIQUAD_SIZE, 0x0f),\n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad5\", BIQUAD_SIZE, 0x14),\n\tCOEFF_RAM_CTL(\"Cascade1L BiQuad6\", BIQUAD_SIZE, 0x19),\n\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad1\", BIQUAD_SIZE, 0x20),\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad2\", BIQUAD_SIZE, 0x25),\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad3\", BIQUAD_SIZE, 0x2a),\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad4\", BIQUAD_SIZE, 0x2f),\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad5\", BIQUAD_SIZE, 0x34),\n\tCOEFF_RAM_CTL(\"Cascade1R BiQuad6\", BIQUAD_SIZE, 0x39),\n\n\tCOEFF_RAM_CTL(\"Cascade1L Prescale\", COEFF_SIZE, 0x1f),\n\tCOEFF_RAM_CTL(\"Cascade1R Prescale\", COEFF_SIZE, 0x3f),\n\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad1\", BIQUAD_SIZE, 0x40),\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad2\", BIQUAD_SIZE, 0x45),\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad3\", BIQUAD_SIZE, 0x4a),\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad4\", BIQUAD_SIZE, 0x4f),\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad5\", BIQUAD_SIZE, 0x54),\n\tCOEFF_RAM_CTL(\"Cascade2L BiQuad6\", BIQUAD_SIZE, 0x59),\n\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad1\", BIQUAD_SIZE, 0x60),\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad2\", BIQUAD_SIZE, 0x65),\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad3\", BIQUAD_SIZE, 0x6a),\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad4\", BIQUAD_SIZE, 0x6f),\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad5\", BIQUAD_SIZE, 0x74),\n\tCOEFF_RAM_CTL(\"Cascade2R BiQuad6\", BIQUAD_SIZE, 0x79),\n\n\tCOEFF_RAM_CTL(\"Cascade2L Prescale\", COEFF_SIZE, 0x5f),\n\tCOEFF_RAM_CTL(\"Cascade2R Prescale\", COEFF_SIZE, 0x7f),\n\n\tCOEFF_RAM_CTL(\"Bass Extraction BiQuad1\", BIQUAD_SIZE, 0x80),\n\tCOEFF_RAM_CTL(\"Bass Extraction BiQuad2\", BIQUAD_SIZE, 0x85),\n\n\tCOEFF_RAM_CTL(\"Bass Non Linear Function 1\", COEFF_SIZE, 0x8a),\n\tCOEFF_RAM_CTL(\"Bass Non Linear Function 2\", COEFF_SIZE, 0x8b),\n\n\tCOEFF_RAM_CTL(\"Bass Limiter BiQuad\", BIQUAD_SIZE, 0x8c),\n\n\tCOEFF_RAM_CTL(\"Bass Cut Off BiQuad\", BIQUAD_SIZE, 0x91),\n\n\tCOEFF_RAM_CTL(\"Bass Mix\", COEFF_SIZE, 0x96),\n\n\tCOEFF_RAM_CTL(\"Treb Extraction BiQuad1\", BIQUAD_SIZE, 0x97),\n\tCOEFF_RAM_CTL(\"Treb Extraction BiQuad2\", BIQUAD_SIZE, 0x9c),\n\n\tCOEFF_RAM_CTL(\"Treb Non Linear Function 1\", COEFF_SIZE, 0xa1),\n\tCOEFF_RAM_CTL(\"Treb Non Linear Function 2\", COEFF_SIZE, 0xa2),\n\n\tCOEFF_RAM_CTL(\"Treb Limiter BiQuad\", BIQUAD_SIZE, 0xa3),\n\n\tCOEFF_RAM_CTL(\"Treb Cut Off BiQuad\", BIQUAD_SIZE, 0xa8),\n\n\tCOEFF_RAM_CTL(\"Treb Mix\", COEFF_SIZE, 0xad),\n\n\tCOEFF_RAM_CTL(\"3D\", COEFF_SIZE, 0xae),\n\n\tCOEFF_RAM_CTL(\"3D Mix\", COEFF_SIZE, 0xaf),\n\n\tCOEFF_RAM_CTL(\"MBC1 BiQuad1\", BIQUAD_SIZE, 0xb0),\n\tCOEFF_RAM_CTL(\"MBC1 BiQuad2\", BIQUAD_SIZE, 0xb5),\n\n\tCOEFF_RAM_CTL(\"MBC2 BiQuad1\", BIQUAD_SIZE, 0xba),\n\tCOEFF_RAM_CTL(\"MBC2 BiQuad2\", BIQUAD_SIZE, 0xbf),\n\n\tCOEFF_RAM_CTL(\"MBC3 BiQuad1\", BIQUAD_SIZE, 0xc4),\n\tCOEFF_RAM_CTL(\"MBC3 BiQuad2\", BIQUAD_SIZE, 0xc9),\n\n\t \n\tSOC_SINGLE(\"EQ1 Switch\", R_CONFIG1, FB_CONFIG1_EQ1_EN, 1, 0),\n\tSOC_SINGLE(\"EQ2 Switch\", R_CONFIG1, FB_CONFIG1_EQ2_EN, 1, 0),\n\tSOC_ENUM(\"EQ1 Band Enable\", eq1_band_enable_enum),\n\tSOC_ENUM(\"EQ2 Band Enable\", eq2_band_enable_enum),\n\n\t \n\tSOC_ENUM(\"CLE Level Detect\",\n\t\tcle_level_detection_enum),\n\tSOC_ENUM(\"CLE Level Detect Win\",\n\t\tcle_level_detection_window_enum),\n\tSOC_SINGLE(\"Expander Switch\",\n\t\tR_CLECTL, FB_CLECTL_EXP_EN, 1, 0),\n\tSOC_SINGLE(\"Limiter Switch\",\n\t\tR_CLECTL, FB_CLECTL_LIMIT_EN, 1, 0),\n\tSOC_SINGLE(\"Comp Switch\",\n\t\tR_CLECTL, FB_CLECTL_COMP_EN, 1, 0),\n\tSOC_SINGLE_TLV(\"CLE Make-Up Gain Volume\",\n\t\tR_MUGAIN, FB_MUGAIN_CLEMUG, 0x1f, 0, mugain_scale),\n\tSOC_SINGLE_TLV(\"Comp Thresh Volume\",\n\t\tR_COMPTH, FB_COMPTH, 0xff, 0, compth_scale),\n\tSOC_ENUM(\"Comp Ratio\", compressor_ratio_enum),\n\tSND_SOC_BYTES(\"Comp Atk Time\", R_CATKTCL, 2),\n\n\t \n\tSOC_SINGLE(\"3D Switch\", R_FXCTL, FB_FXCTL_3DEN, 1, 0),\n\tSOC_SINGLE(\"Treble Switch\", R_FXCTL, FB_FXCTL_TEEN, 1, 0),\n\tSOC_SINGLE(\"Treble Bypass Switch\", R_FXCTL, FB_FXCTL_TNLFBYPASS, 1, 0),\n\tSOC_SINGLE(\"Bass Switch\", R_FXCTL, FB_FXCTL_BEEN, 1, 0),\n\tSOC_SINGLE(\"Bass Bypass Switch\", R_FXCTL, FB_FXCTL_BNLFBYPASS, 1, 0),\n\n\t \n\tSOC_SINGLE(\"MBC Band1 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN1, 1, 0),\n\tSOC_SINGLE(\"MBC Band2 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN2, 1, 0),\n\tSOC_SINGLE(\"MBC Band3 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN3, 1, 0),\n\tSOC_ENUM(\"MBC Band1 Level Detect\",\n\t\tmbc_level_detection_enums[0]),\n\tSOC_ENUM(\"MBC Band2 Level Detect\",\n\t\tmbc_level_detection_enums[1]),\n\tSOC_ENUM(\"MBC Band3 Level Detect\",\n\t\tmbc_level_detection_enums[2]),\n\tSOC_ENUM(\"MBC Band1 Level Detect Win\",\n\t\tmbc_level_detection_window_enums[0]),\n\tSOC_ENUM(\"MBC Band2 Level Detect Win\",\n\t\tmbc_level_detection_window_enums[1]),\n\tSOC_ENUM(\"MBC Band3 Level Detect Win\",\n\t\tmbc_level_detection_window_enums[2]),\n\n\tSOC_SINGLE(\"MBC1 Phase Invert Switch\",\n\t\tR_DACMBCMUG1, FB_DACMBCMUG1_PHASE, 1, 0),\n\tSOC_SINGLE_TLV(\"DAC MBC1 Make-Up Gain Volume\",\n\t\tR_DACMBCMUG1, FB_DACMBCMUG1_MUGAIN, 0x1f, 0, mugain_scale),\n\tSOC_SINGLE_TLV(\"DAC MBC1 Comp Thresh Volume\",\n\t\tR_DACMBCTHR1, FB_DACMBCTHR1_THRESH, 0xff, 0, compth_scale),\n\tSOC_ENUM(\"DAC MBC1 Comp Ratio\",\n\t\tdac_mbc1_compressor_ratio_enum),\n\tSND_SOC_BYTES(\"DAC MBC1 Comp Atk Time\", R_DACMBCATK1L, 2),\n\tSND_SOC_BYTES(\"DAC MBC1 Comp Rel Time Const\",\n\t\tR_DACMBCREL1L, 2),\n\n\tSOC_SINGLE(\"MBC2 Phase Invert Switch\",\n\t\tR_DACMBCMUG2, FB_DACMBCMUG2_PHASE, 1, 0),\n\tSOC_SINGLE_TLV(\"DAC MBC2 Make-Up Gain Volume\",\n\t\tR_DACMBCMUG2, FB_DACMBCMUG2_MUGAIN, 0x1f, 0, mugain_scale),\n\tSOC_SINGLE_TLV(\"DAC MBC2 Comp Thresh Volume\",\n\t\tR_DACMBCTHR2, FB_DACMBCTHR2_THRESH, 0xff, 0, compth_scale),\n\tSOC_ENUM(\"DAC MBC2 Comp Ratio\",\n\t\tdac_mbc2_compressor_ratio_enum),\n\tSND_SOC_BYTES(\"DAC MBC2 Comp Atk Time\", R_DACMBCATK2L, 2),\n\tSND_SOC_BYTES(\"DAC MBC2 Comp Rel Time Const\",\n\t\tR_DACMBCREL2L, 2),\n\n\tSOC_SINGLE(\"MBC3 Phase Invert Switch\",\n\t\tR_DACMBCMUG3, FB_DACMBCMUG3_PHASE, 1, 0),\n\tSOC_SINGLE_TLV(\"DAC MBC3 Make-Up Gain Volume\",\n\t\tR_DACMBCMUG3, FB_DACMBCMUG3_MUGAIN, 0x1f, 0, mugain_scale),\n\tSOC_SINGLE_TLV(\"DAC MBC3 Comp Thresh Volume\",\n\t\tR_DACMBCTHR3, FB_DACMBCTHR3_THRESH, 0xff, 0, compth_scale),\n\tSOC_ENUM(\"DAC MBC3 Comp Ratio\",\n\t\tdac_mbc3_compressor_ratio_enum),\n\tSND_SOC_BYTES(\"DAC MBC3 Comp Atk Time\", R_DACMBCATK3L, 2),\n\tSND_SOC_BYTES(\"DAC MBC3 Comp Rel Time Const\",\n\t\tR_DACMBCREL3L, 2),\n};\n\nstatic int setup_sample_format(struct snd_soc_component *component,\n\t\tsnd_pcm_format_t format)\n{\n\tunsigned int width;\n\tint ret;\n\n\tswitch (format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\twidth = RV_AIC1_WL_16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\twidth = RV_AIC1_WL_20;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\twidth = RV_AIC1_WL_24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\twidth = RV_AIC1_WL_32;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported format width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_AIC1, RM_AIC1_WL, width);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set sample width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_sample_rate(struct snd_soc_component *component,\n\t\tunsigned int rate)\n{\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tunsigned int br, bm;\n\tint ret;\n\n\tswitch (rate) {\n\tcase 8000:\n\t\tbr = RV_DACSR_DBR_32;\n\t\tbm = RV_DACSR_DBM_PT25;\n\t\tbreak;\n\tcase 16000:\n\t\tbr = RV_DACSR_DBR_32;\n\t\tbm = RV_DACSR_DBM_PT5;\n\t\tbreak;\n\tcase 24000:\n\t\tbr = RV_DACSR_DBR_48;\n\t\tbm = RV_DACSR_DBM_PT5;\n\t\tbreak;\n\tcase 32000:\n\t\tbr = RV_DACSR_DBR_32;\n\t\tbm = RV_DACSR_DBM_1;\n\t\tbreak;\n\tcase 48000:\n\t\tbr = RV_DACSR_DBR_48;\n\t\tbm = RV_DACSR_DBM_1;\n\t\tbreak;\n\tcase 96000:\n\t\tbr = RV_DACSR_DBR_48;\n\t\tbm = RV_DACSR_DBM_2;\n\t\tbreak;\n\tcase 11025:\n\t\tbr = RV_DACSR_DBR_44_1;\n\t\tbm = RV_DACSR_DBM_PT25;\n\t\tbreak;\n\tcase 22050:\n\t\tbr = RV_DACSR_DBR_44_1;\n\t\tbm = RV_DACSR_DBM_PT5;\n\t\tbreak;\n\tcase 44100:\n\t\tbr = RV_DACSR_DBR_44_1;\n\t\tbm = RV_DACSR_DBM_1;\n\t\tbreak;\n\tcase 88200:\n\t\tbr = RV_DACSR_DBR_44_1;\n\t\tbm = RV_DACSR_DBM_2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample rate %d\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_DACSR, RM_DACSR_DBR, br);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_DACSR, RM_DACSR_DBM, bm);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_ADCSR, RM_DACSR_DBR, br);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_ADCSR, RM_DACSR_DBM, bm);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&tscs42xx->audio_params_lock);\n\n\ttscs42xx->samplerate = rate;\n\n\tmutex_unlock(&tscs42xx->audio_params_lock);\n\n\treturn 0;\n}\n\nstruct reg_setting {\n\tunsigned int addr;\n\tunsigned int val;\n\tunsigned int mask;\n};\n\n#define PLL_REG_SETTINGS_COUNT 13\nstruct pll_ctl {\n\tint input_freq;\n\tstruct reg_setting settings[PLL_REG_SETTINGS_COUNT];\n};\n\n#define PLL_CTL(f, rt, rd, r1b_l, r9, ra, rb,\t\t\\\n\t\trc, r12, r1b_h, re, rf, r10, r11)\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.input_freq = f,\t\t\t\\\n\t\t.settings = {\t\t\t\t\\\n\t\t\t{R_TIMEBASE,  rt,   0xFF},\t\\\n\t\t\t{R_PLLCTLD,   rd,   0xFF},\t\\\n\t\t\t{R_PLLCTL1B, r1b_l, 0x0F},\t\\\n\t\t\t{R_PLLCTL9,   r9,   0xFF},\t\\\n\t\t\t{R_PLLCTLA,   ra,   0xFF},\t\\\n\t\t\t{R_PLLCTLB,   rb,   0xFF},\t\\\n\t\t\t{R_PLLCTLC,   rc,   0xFF},\t\\\n\t\t\t{R_PLLCTL12, r12,   0xFF},\t\\\n\t\t\t{R_PLLCTL1B, r1b_h, 0xF0},\t\\\n\t\t\t{R_PLLCTLE,   re,   0xFF},\t\\\n\t\t\t{R_PLLCTLF,   rf,   0xFF},\t\\\n\t\t\t{R_PLLCTL10, r10,   0xFF},\t\\\n\t\t\t{R_PLLCTL11, r11,   0xFF},\t\\\n\t\t},\t\t\t\t\t\\\n\t}\n\nstatic const struct pll_ctl pll_ctls[] = {\n\tPLL_CTL(1411200, 0x05,\n\t\t0x39, 0x04, 0x07, 0x02, 0xC3, 0x04,\n\t\t0x1B, 0x10, 0x03, 0x03, 0xD0, 0x02),\n\tPLL_CTL(1536000, 0x05,\n\t\t0x1A, 0x04, 0x02, 0x03, 0xE0, 0x01,\n\t\t0x1A, 0x10, 0x02, 0x03, 0xB9, 0x01),\n\tPLL_CTL(2822400, 0x0A,\n\t\t0x23, 0x04, 0x07, 0x04, 0xC3, 0x04,\n\t\t0x22, 0x10, 0x05, 0x03, 0x58, 0x02),\n\tPLL_CTL(3072000, 0x0B,\n\t\t0x22, 0x04, 0x07, 0x03, 0x48, 0x03,\n\t\t0x1A, 0x10, 0x04, 0x03, 0xB9, 0x01),\n\tPLL_CTL(5644800, 0x15,\n\t\t0x23, 0x04, 0x0E, 0x04, 0xC3, 0x04,\n\t\t0x1A, 0x10, 0x08, 0x03, 0xE0, 0x01),\n\tPLL_CTL(6144000, 0x17,\n\t\t0x1A, 0x04, 0x08, 0x03, 0xE0, 0x01,\n\t\t0x1A, 0x10, 0x08, 0x03, 0xB9, 0x01),\n\tPLL_CTL(12000000, 0x2E,\n\t\t0x1B, 0x04, 0x19, 0x03, 0x00, 0x03,\n\t\t0x2A, 0x10, 0x19, 0x05, 0x98, 0x04),\n\tPLL_CTL(19200000, 0x4A,\n\t\t0x13, 0x04, 0x14, 0x03, 0x80, 0x01,\n\t\t0x1A, 0x10, 0x19, 0x03, 0xB9, 0x01),\n\tPLL_CTL(22000000, 0x55,\n\t\t0x2A, 0x04, 0x37, 0x05, 0x00, 0x06,\n\t\t0x22, 0x10, 0x26, 0x03, 0x49, 0x02),\n\tPLL_CTL(22579200, 0x57,\n\t\t0x22, 0x04, 0x31, 0x03, 0x20, 0x03,\n\t\t0x1A, 0x10, 0x1D, 0x03, 0xB3, 0x01),\n\tPLL_CTL(24000000, 0x5D,\n\t\t0x13, 0x04, 0x19, 0x03, 0x80, 0x01,\n\t\t0x1B, 0x10, 0x19, 0x05, 0x4C, 0x02),\n\tPLL_CTL(24576000, 0x5F,\n\t\t0x13, 0x04, 0x1D, 0x03, 0xB3, 0x01,\n\t\t0x22, 0x10, 0x40, 0x03, 0x72, 0x03),\n\tPLL_CTL(27000000, 0x68,\n\t\t0x22, 0x04, 0x4B, 0x03, 0x00, 0x04,\n\t\t0x2A, 0x10, 0x7D, 0x03, 0x20, 0x06),\n\tPLL_CTL(36000000, 0x8C,\n\t\t0x1B, 0x04, 0x4B, 0x03, 0x00, 0x03,\n\t\t0x2A, 0x10, 0x7D, 0x03, 0x98, 0x04),\n\tPLL_CTL(25000000, 0x61,\n\t\t0x1B, 0x04, 0x37, 0x03, 0x2B, 0x03,\n\t\t0x1A, 0x10, 0x2A, 0x03, 0x39, 0x02),\n\tPLL_CTL(26000000, 0x65,\n\t\t0x23, 0x04, 0x41, 0x05, 0x00, 0x06,\n\t\t0x1A, 0x10, 0x26, 0x03, 0xEF, 0x01),\n\tPLL_CTL(12288000, 0x2F,\n\t\t0x1A, 0x04, 0x12, 0x03, 0x1C, 0x02,\n\t\t0x22, 0x10, 0x20, 0x03, 0x72, 0x03),\n\tPLL_CTL(40000000, 0x9B,\n\t\t0x22, 0x08, 0x7D, 0x03, 0x80, 0x04,\n\t\t0x23, 0x10, 0x7D, 0x05, 0xE4, 0x06),\n\tPLL_CTL(512000, 0x01,\n\t\t0x22, 0x04, 0x01, 0x03, 0xD0, 0x02,\n\t\t0x1B, 0x10, 0x01, 0x04, 0x72, 0x03),\n\tPLL_CTL(705600, 0x02,\n\t\t0x22, 0x04, 0x02, 0x03, 0x15, 0x04,\n\t\t0x22, 0x10, 0x01, 0x04, 0x80, 0x02),\n\tPLL_CTL(1024000, 0x03,\n\t\t0x22, 0x04, 0x02, 0x03, 0xD0, 0x02,\n\t\t0x1B, 0x10, 0x02, 0x04, 0x72, 0x03),\n\tPLL_CTL(2048000, 0x07,\n\t\t0x22, 0x04, 0x04, 0x03, 0xD0, 0x02,\n\t\t0x1B, 0x10, 0x04, 0x04, 0x72, 0x03),\n\tPLL_CTL(2400000, 0x08,\n\t\t0x22, 0x04, 0x05, 0x03, 0x00, 0x03,\n\t\t0x23, 0x10, 0x05, 0x05, 0x98, 0x04),\n};\n\nstatic const struct pll_ctl *get_pll_ctl(int input_freq)\n{\n\tint i;\n\tconst struct pll_ctl *pll_ctl = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_ctls); ++i)\n\t\tif (input_freq == pll_ctls[i].input_freq) {\n\t\t\tpll_ctl = &pll_ctls[i];\n\t\t\tbreak;\n\t\t}\n\n\treturn pll_ctl;\n}\n\nstatic int set_pll_ctl_from_input_freq(struct snd_soc_component *component,\n\t\tconst int input_freq)\n{\n\tint ret;\n\tint i;\n\tconst struct pll_ctl *pll_ctl;\n\n\tpll_ctl = get_pll_ctl(input_freq);\n\tif (!pll_ctl) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"No PLL input entry for %d (%d)\\n\",\n\t\t\tinput_freq, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PLL_REG_SETTINGS_COUNT; ++i) {\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tpll_ctl->settings[i].addr,\n\t\t\tpll_ctl->settings[i].mask,\n\t\t\tpll_ctl->settings[i].val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to set pll ctl (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs42xx_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *codec_dai)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\tret = setup_sample_format(component, params_format(params));\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to setup sample format (%d)\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = setup_sample_rate(component, params_rate(params));\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to setup sample rate (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int dac_mute(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_CNVRTR1, RM_CNVRTR1_DACMU,\n\t\tRV_CNVRTR1_DACMU_ENABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to mute DAC (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int dac_unmute(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_CNVRTR1, RM_CNVRTR1_DACMU,\n\t\tRV_CNVRTR1_DACMU_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to unmute DAC (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int adc_mute(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_CNVRTR0, RM_CNVRTR0_ADCMU, RV_CNVRTR0_ADCMU_ENABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to mute ADC (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int adc_unmute(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_CNVRTR0, RM_CNVRTR0_ADCMU, RV_CNVRTR0_ADCMU_DISABLE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to unmute ADC (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs42xx_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint ret;\n\n\tif (mute)\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = dac_mute(component);\n\t\telse\n\t\t\tret = adc_mute(component);\n\telse\n\t\tif (stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tret = dac_unmute(component);\n\t\telse\n\t\t\tret = adc_unmute(component);\n\n\treturn ret;\n}\n\nstatic int tscs42xx_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint ret;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\tR_AIC1, RM_AIC1_MS, RV_AIC1_MS_MASTER);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set codec DAI master (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported format (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs42xx_set_dai_bclk_ratio(struct snd_soc_dai *codec_dai,\n\t\tunsigned int ratio)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tunsigned int value;\n\tint ret = 0;\n\n\tswitch (ratio) {\n\tcase 32:\n\t\tvalue = RV_DACSR_DBCM_32;\n\t\tbreak;\n\tcase 40:\n\t\tvalue = RV_DACSR_DBCM_40;\n\t\tbreak;\n\tcase 64:\n\t\tvalue = RV_DACSR_DBCM_64;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported bclk ratio (%d)\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_DACSR, RM_DACSR_DBCM, value);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set DAC BCLK ratio (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_ADCSR, RM_ADCSR_ABCM, value);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set ADC BCLK ratio (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&tscs42xx->audio_params_lock);\n\n\ttscs42xx->bclk_ratio = ratio;\n\n\tmutex_unlock(&tscs42xx->audio_params_lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tscs42xx_dai_ops = {\n\t.hw_params\t= tscs42xx_hw_params,\n\t.mute_stream\t= tscs42xx_mute_stream,\n\t.set_fmt\t= tscs42xx_set_dai_fmt,\n\t.set_bclk_ratio = tscs42xx_set_dai_bclk_ratio,\n};\n\nstatic int part_is_valid(struct tscs42xx *tscs42xx)\n{\n\tint val;\n\tint ret;\n\tunsigned int reg;\n\n\tret = regmap_read(tscs42xx->regmap, R_DEVIDH, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = reg << 8;\n\tret = regmap_read(tscs42xx->regmap, R_DEVIDL, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval |= reg;\n\n\tswitch (val) {\n\tcase 0x4A74:\n\tcase 0x4A73:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int set_sysclk(struct snd_soc_component *component)\n{\n\tstruct tscs42xx *tscs42xx = snd_soc_component_get_drvdata(component);\n\tunsigned long freq;\n\tint ret;\n\n\tswitch (tscs42xx->sysclk_src_id) {\n\tcase TSCS42XX_PLL_SRC_XTAL:\n\tcase TSCS42XX_PLL_SRC_MCLK1:\n\t\tret = snd_soc_component_write(component, R_PLLREFSEL,\n\t\t\t\tRV_PLLREFSEL_PLL1_REF_SEL_XTAL_MCLK1 |\n\t\t\t\tRV_PLLREFSEL_PLL2_REF_SEL_XTAL_MCLK1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set pll reference input (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase TSCS42XX_PLL_SRC_MCLK2:\n\t\tret = snd_soc_component_write(component, R_PLLREFSEL,\n\t\t\t\tRV_PLLREFSEL_PLL1_REF_SEL_MCLK2 |\n\t\t\t\tRV_PLLREFSEL_PLL2_REF_SEL_MCLK2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set PLL reference (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"pll src is unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfreq = clk_get_rate(tscs42xx->sysclk);\n\tret = set_pll_ctl_from_input_freq(component, freq);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"Failed to setup PLL input freq (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs42xx_probe(struct snd_soc_component *component)\n{\n\treturn set_sysclk(component);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_tscs42xx = {\n\t.probe\t\t\t= tscs42xx_probe,\n\t.dapm_widgets\t\t= tscs42xx_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tscs42xx_dapm_widgets),\n\t.dapm_routes\t\t= tscs42xx_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(tscs42xx_intercon),\n\t.controls\t\t= tscs42xx_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tscs42xx_snd_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic inline void init_coeff_ram_cache(struct tscs42xx *tscs42xx)\n{\n\tstatic const u8 norm_addrs[] = {\n\t\t0x00, 0x05, 0x0a, 0x0f, 0x14, 0x19, 0x1f, 0x20, 0x25, 0x2a,\n\t\t0x2f, 0x34, 0x39, 0x3f, 0x40, 0x45, 0x4a, 0x4f, 0x54, 0x59,\n\t\t0x5f, 0x60, 0x65, 0x6a, 0x6f, 0x74, 0x79, 0x7f, 0x80, 0x85,\n\t\t0x8c, 0x91, 0x96, 0x97, 0x9c, 0xa3, 0xa8, 0xad, 0xaf, 0xb0,\n\t\t0xb5, 0xba, 0xbf, 0xc4, 0xc9,\n\t};\n\tu8 *coeff_ram = tscs42xx->coeff_ram;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(norm_addrs); i++)\n\t\tcoeff_ram[((norm_addrs[i] + 1) * COEFF_SIZE) - 1] = 0x40;\n}\n\n#define TSCS42XX_RATES SNDRV_PCM_RATE_8000_96000\n\n#define TSCS42XX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t| SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver tscs42xx_dai = {\n\t.name = \"tscs42xx-HiFi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = TSCS42XX_RATES,\n\t\t.formats = TSCS42XX_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = TSCS42XX_RATES,\n\t\t.formats = TSCS42XX_FORMATS,},\n\t.ops = &tscs42xx_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_channels = 1,\n\t.symmetric_sample_bits = 1,\n};\n\nstatic const struct reg_sequence tscs42xx_patch[] = {\n\t{ R_AIC2, RV_AIC2_BLRCM_DAC_BCLK_LRCLK_SHARED },\n};\n\nstatic char const * const src_names[TSCS42XX_PLL_SRC_CNT] = {\n\t\"xtal\", \"mclk1\", \"mclk2\"};\n\nstatic int tscs42xx_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct tscs42xx *tscs42xx;\n\tint src;\n\tint ret;\n\n\ttscs42xx = devm_kzalloc(&i2c->dev, sizeof(*tscs42xx), GFP_KERNEL);\n\tif (!tscs42xx) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to allocate memory for data (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(i2c, tscs42xx);\n\n\tfor (src = TSCS42XX_PLL_SRC_XTAL; src < TSCS42XX_PLL_SRC_CNT; src++) {\n\t\ttscs42xx->sysclk = devm_clk_get(&i2c->dev, src_names[src]);\n\t\tif (!IS_ERR(tscs42xx->sysclk)) {\n\t\t\tbreak;\n\t\t} else if (PTR_ERR(tscs42xx->sysclk) != -ENOENT) {\n\t\t\tret = PTR_ERR(tscs42xx->sysclk);\n\t\t\tdev_err(&i2c->dev, \"Failed to get sysclk (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (src == TSCS42XX_PLL_SRC_CNT) {\n\t\tret = -EINVAL;\n\t\tdev_err(&i2c->dev, \"Failed to get a valid clock name (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\ttscs42xx->sysclk_src_id = src;\n\n\ttscs42xx->regmap = devm_regmap_init_i2c(i2c, &tscs42xx_regmap);\n\tif (IS_ERR(tscs42xx->regmap)) {\n\t\tret = PTR_ERR(tscs42xx->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_coeff_ram_cache(tscs42xx);\n\n\tret = part_is_valid(tscs42xx);\n\tif (ret <= 0) {\n\t\tdev_err(&i2c->dev, \"No valid part (%d)\\n\", ret);\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(tscs42xx->regmap, R_RESET, RV_RESET_ENABLE);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to reset device (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_register_patch(tscs42xx->regmap, tscs42xx_patch,\n\t\t\tARRAY_SIZE(tscs42xx_patch));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to apply patch (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&tscs42xx->audio_params_lock);\n\tmutex_init(&tscs42xx->coeff_ram_lock);\n\tmutex_init(&tscs42xx->pll_lock);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_codec_dev_tscs42xx, &tscs42xx_dai, 1);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to register codec (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tscs42xx_i2c_id[] = {\n\t{ \"tscs42A1\", 0 },\n\t{ \"tscs42A2\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tscs42xx_i2c_id);\n\nstatic const struct of_device_id tscs42xx_of_match[] = {\n\t{ .compatible = \"tempo,tscs42A1\", },\n\t{ .compatible = \"tempo,tscs42A2\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tscs42xx_of_match);\n\nstatic struct i2c_driver tscs42xx_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tscs42xx\",\n\t\t.of_match_table = tscs42xx_of_match,\n\t},\n\t.probe = tscs42xx_i2c_probe,\n\t.id_table = tscs42xx_i2c_id,\n};\n\nmodule_i2c_driver(tscs42xx_i2c_driver);\n\nMODULE_AUTHOR(\"Tempo Semiconductor <steven.eckhoff.opensource@gmail.com\");\nMODULE_DESCRIPTION(\"ASoC TSCS42xx driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}