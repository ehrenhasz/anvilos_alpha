{
  "module_name": "wcd-clsh-v2.c",
  "hash_id": "5cf32eb9fcd666ae727ffd1c82d259973d58abdef1dc7843f078343c432df09e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wcd-clsh-v2.c",
  "human_readable_source": "\n\n\n\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include \"wcd9335.h\"\n#include \"wcd-clsh-v2.h\"\n\nstruct wcd_clsh_ctrl {\n\tint state;\n\tint mode;\n\tint flyback_users;\n\tint buck_users;\n\tint clsh_users;\n\tint codec_version;\n\tstruct snd_soc_component *comp;\n};\n\n \n#define WCD9XXX_A_CDC_RX0_RX_PATH_CFG0\t\t\tWCD9335_REG(0xB, 0x42)\n#define WCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK\t\tBIT(6)\n#define WCD9XXX_A_CDC_RX_PATH_CLSH_ENABLE\t\tBIT(6)\n#define WCD9XXX_A_CDC_RX_PATH_CLSH_DISABLE\t\t0\n#define WCD9XXX_A_CDC_RX1_RX_PATH_CFG0\t\t\tWCD9335_REG(0xB, 0x56)\n#define WCD9XXX_A_CDC_RX2_RX_PATH_CFG0\t\t\tWCD9335_REG(0xB, 0x6A)\n#define WCD9XXX_A_CDC_CLSH_K1_MSB\t\t\tWCD9335_REG(0xC, 0x08)\n#define WCD9XXX_A_CDC_CLSH_K1_MSB_COEF_MASK\t\tGENMASK(3, 0)\n#define WCD9XXX_A_CDC_CLSH_K1_LSB\t\t\tWCD9335_REG(0xC, 0x09)\n#define WCD9XXX_A_CDC_CLSH_K1_LSB_COEF_MASK\t\tGENMASK(7, 0)\n#define WCD9XXX_A_ANA_RX_SUPPLIES\t\t\tWCD9335_REG(0x6, 0x08)\n#define WCD9XXX_A_ANA_RX_REGULATOR_MODE_MASK\t\tBIT(1)\n#define WCD9XXX_A_ANA_RX_REGULATOR_MODE_CLS_H\t\t0\n#define WCD9XXX_A_ANA_RX_REGULATOR_MODE_CLS_AB\t\tBIT(1)\n#define WCD9XXX_A_ANA_RX_VNEG_PWR_LVL_MASK\t\tBIT(2)\n#define WCD9XXX_A_ANA_RX_VNEG_PWR_LVL_UHQA\t\tBIT(2)\n#define WCD9XXX_A_ANA_RX_VNEG_PWR_LVL_DEFAULT\t\t0\n#define WCD9XXX_A_ANA_RX_VPOS_PWR_LVL_MASK\t\tBIT(3)\n#define WCD9XXX_A_ANA_RX_VPOS_PWR_LVL_UHQA\t\tBIT(3)\n#define WCD9XXX_A_ANA_RX_VPOS_PWR_LVL_DEFAULT\t\t0\n#define WCD9XXX_A_ANA_RX_VNEG_EN_MASK\t\t\tBIT(6)\n#define WCD9XXX_A_ANA_RX_VNEG_EN_SHIFT\t\t\t6\n#define WCD9XXX_A_ANA_RX_VNEG_ENABLE\t\t\tBIT(6)\n#define WCD9XXX_A_ANA_RX_VNEG_DISABLE\t\t\t0\n#define WCD9XXX_A_ANA_RX_VPOS_EN_MASK\t\t\tBIT(7)\n#define WCD9XXX_A_ANA_RX_VPOS_EN_SHIFT\t\t\t7\n#define WCD9XXX_A_ANA_RX_VPOS_ENABLE\t\t\tBIT(7)\n#define WCD9XXX_A_ANA_RX_VPOS_DISABLE\t\t\t0\n#define WCD9XXX_A_ANA_HPH\t\t\t\tWCD9335_REG(0x6, 0x09)\n#define WCD9XXX_A_ANA_HPH_PWR_LEVEL_MASK\t\tGENMASK(3, 2)\n#define WCD9XXX_A_ANA_HPH_PWR_LEVEL_UHQA\t\t0x08\n#define WCD9XXX_A_ANA_HPH_PWR_LEVEL_LP\t\t\t0x04\n#define WCD9XXX_A_ANA_HPH_PWR_LEVEL_NORMAL\t\t0x0\n#define WCD9XXX_A_CDC_CLSH_CRC\t\t\t\tWCD9335_REG(0xC, 0x01)\n#define WCD9XXX_A_CDC_CLSH_CRC_CLK_EN_MASK\t\tBIT(0)\n#define WCD9XXX_A_CDC_CLSH_CRC_CLK_ENABLE\t\tBIT(0)\n#define WCD9XXX_A_CDC_CLSH_CRC_CLK_DISABLE\t\t0\n#define WCD9XXX_FLYBACK_EN\t\t\t\tWCD9335_REG(0x6, 0xA4)\n#define WCD9XXX_FLYBACK_EN_DELAY_SEL_MASK\t\tGENMASK(6, 5)\n#define WCD9XXX_FLYBACK_EN_DELAY_26P25_US\t\t0x40\n#define WCD9XXX_FLYBACK_EN_RESET_BY_EXT_MASK\t\tBIT(4)\n#define WCD9XXX_FLYBACK_EN_PWDN_WITHOUT_DELAY\t\tBIT(4)\n#define WCD9XXX_FLYBACK_EN_PWDN_WITH_DELAY\t\t\t0\n#define WCD9XXX_RX_BIAS_FLYB_BUFF\t\t\tWCD9335_REG(0x6, 0xC7)\n#define WCD9XXX_RX_BIAS_FLYB_VNEG_5_UA_MASK\t\tGENMASK(7, 4)\n#define WCD9XXX_RX_BIAS_FLYB_VPOS_5_UA_MASK\t\tGENMASK(3, 0)\n#define WCD9XXX_HPH_L_EN\t\t\t\tWCD9335_REG(0x6, 0xD3)\n#define WCD9XXX_HPH_CONST_SEL_L_MASK\t\t\tGENMASK(7, 3)\n#define WCD9XXX_HPH_CONST_SEL_BYPASS\t\t\t0\n#define WCD9XXX_HPH_CONST_SEL_LP_PATH\t\t\t0x40\n#define WCD9XXX_HPH_CONST_SEL_HQ_PATH\t\t\t0x80\n#define WCD9XXX_HPH_R_EN\t\t\t\tWCD9335_REG(0x6, 0xD6)\n#define WCD9XXX_HPH_REFBUFF_UHQA_CTL\t\t\tWCD9335_REG(0x6, 0xDD)\n#define WCD9XXX_HPH_REFBUFF_UHQA_GAIN_MASK\t\tGENMASK(2, 0)\n#define WCD9XXX_CLASSH_CTRL_VCL_2                       WCD9335_REG(0x6, 0x9B)\n#define WCD9XXX_CLASSH_CTRL_VCL_2_VREF_FILT_1_MASK\tGENMASK(5, 4)\n#define WCD9XXX_CLASSH_CTRL_VCL_VREF_FILT_R_50KOHM\t0x20\n#define WCD9XXX_CLASSH_CTRL_VCL_VREF_FILT_R_0KOHM\t0x0\n#define WCD9XXX_CDC_RX1_RX_PATH_CTL\t\t\tWCD9335_REG(0xB, 0x55)\n#define WCD9XXX_CDC_RX2_RX_PATH_CTL\t\t\tWCD9335_REG(0xB, 0x69)\n#define WCD9XXX_CDC_CLK_RST_CTRL_MCLK_CONTROL\t\tWCD9335_REG(0xD, 0x41)\n#define WCD9XXX_CDC_CLK_RST_CTRL_MCLK_EN_MASK\t\tBIT(0)\n#define WCD9XXX_CDC_CLK_RST_CTRL_MCLK_11P3_EN_MASK\tBIT(1)\n#define WCD9XXX_CLASSH_CTRL_CCL_1                       WCD9335_REG(0x6, 0x9C)\n#define WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_MASK\tGENMASK(7, 4)\n#define WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_50MA\t0x50\n#define WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_30MA\t0x30\n\n#define WCD9XXX_BASE_ADDRESS\t\t\t\t0x3000\n#define WCD9XXX_ANA_RX_SUPPLIES\t\t\t\t(WCD9XXX_BASE_ADDRESS+0x008)\n#define WCD9XXX_ANA_HPH\t\t\t\t\t(WCD9XXX_BASE_ADDRESS+0x009)\n#define WCD9XXX_CLASSH_MODE_2\t\t\t\t(WCD9XXX_BASE_ADDRESS+0x098)\n#define WCD9XXX_CLASSH_MODE_3\t\t\t\t(WCD9XXX_BASE_ADDRESS+0x099)\n#define WCD9XXX_FLYBACK_VNEG_CTRL_1\t\t\t(WCD9XXX_BASE_ADDRESS+0x0A5)\n#define WCD9XXX_FLYBACK_VNEG_CTRL_4\t\t\t(WCD9XXX_BASE_ADDRESS+0x0A8)\n#define WCD9XXX_FLYBACK_VNEGDAC_CTRL_2\t\t\t(WCD9XXX_BASE_ADDRESS+0x0AF)\n#define WCD9XXX_RX_BIAS_HPH_LOWPOWER\t\t\t(WCD9XXX_BASE_ADDRESS+0x0BF)\n#define WCD9XXX_V3_RX_BIAS_FLYB_BUFF\t\t\t(WCD9XXX_BASE_ADDRESS+0x0C7)\n#define WCD9XXX_HPH_PA_CTL1\t\t\t\t(WCD9XXX_BASE_ADDRESS+0x0D1)\n#define WCD9XXX_HPH_NEW_INT_PA_MISC2\t\t\t(WCD9XXX_BASE_ADDRESS+0x138)\n\n#define CLSH_REQ_ENABLE\t\ttrue\n#define CLSH_REQ_DISABLE\tfalse\n#define WCD_USLEEP_RANGE\t50\n\nenum {\n\tDAC_GAIN_0DB = 0,\n\tDAC_GAIN_0P2DB,\n\tDAC_GAIN_0P4DB,\n\tDAC_GAIN_0P6DB,\n\tDAC_GAIN_0P8DB,\n\tDAC_GAIN_M0P2DB,\n\tDAC_GAIN_M0P4DB,\n\tDAC_GAIN_M0P6DB,\n};\n\nstatic inline void wcd_enable_clsh_block(struct wcd_clsh_ctrl *ctrl,\n\t\t\t\t\t bool enable)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif ((enable && ++ctrl->clsh_users == 1) ||\n\t    (!enable && --ctrl->clsh_users == 0))\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_CDC_CLSH_CRC,\n\t\t\t\t      WCD9XXX_A_CDC_CLSH_CRC_CLK_EN_MASK,\n\t\t\t\t      enable);\n\tif (ctrl->clsh_users < 0)\n\t\tctrl->clsh_users = 0;\n}\n\nstatic inline void wcd_clsh_set_buck_mode(struct snd_soc_component *comp,\n\t\t\t\t\t  int mode)\n{\n\t \n\tif (mode == CLS_H_HIFI)\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VPOS_PWR_LVL_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VPOS_PWR_LVL_UHQA);\n\telse\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VPOS_PWR_LVL_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VPOS_PWR_LVL_DEFAULT);\n}\n\nstatic void wcd_clsh_v3_set_buck_mode(struct snd_soc_component *component,\n\t\t\t\t\t  int mode)\n{\n\tif (mode == CLS_H_HIFI || mode == CLS_H_LOHIFI ||\n\t    mode == CLS_AB_HIFI || mode == CLS_AB_LOHIFI)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t0x08, 0x08);  \n\telse\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t0x08, 0x00);  \n}\n\nstatic inline void wcd_clsh_set_flyback_mode(struct snd_soc_component *comp,\n\t\t\t\t\t     int mode)\n{\n\t \n\tif (mode == CLS_H_HIFI)\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VNEG_PWR_LVL_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VNEG_PWR_LVL_UHQA);\n\telse\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VNEG_PWR_LVL_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_VNEG_PWR_LVL_DEFAULT);\n}\n\nstatic void wcd_clsh_buck_ctrl(struct wcd_clsh_ctrl *ctrl,\n\t\t\t       int mode,\n\t\t\t       bool enable)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\t \n\tif ((enable && (++ctrl->buck_users == 1)) ||\n\t   (!enable && (--ctrl->buck_users == 0)))\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\tWCD9XXX_A_ANA_RX_VPOS_EN_MASK,\n\t\t\t\tenable << WCD9XXX_A_ANA_RX_VPOS_EN_SHIFT);\n\t \n\tusleep_range(500, 500 + WCD_USLEEP_RANGE);\n}\n\nstatic void wcd_clsh_v3_buck_ctrl(struct snd_soc_component *component,\n\t\t\t       struct wcd_clsh_ctrl *ctrl,\n\t\t\t       int mode,\n\t\t\t       bool enable)\n{\n\t \n\tif ((enable && (++ctrl->buck_users == 1)) ||\n\t   (!enable && (--ctrl->buck_users == 0))) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t(1 << 7), (enable << 7));\n\t\t \n\t\tusleep_range(500, 510);\n\t\tif (mode == CLS_H_LOHIFI || mode == CLS_H_ULP ||\n\t\t\tmode == CLS_H_HIFI || mode == CLS_H_LP)\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tWCD9XXX_CLASSH_MODE_3,\n\t\t\t\t\t0x02, 0x00);\n\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tWCD9XXX_CLASSH_MODE_2,\n\t\t\t\t\t0xFF, 0x3A);\n\t\t \n\t\tusleep_range(500, 500 + WCD_USLEEP_RANGE);\n\t}\n}\n\nstatic void wcd_clsh_flyback_ctrl(struct wcd_clsh_ctrl *ctrl,\n\t\t\t\t  int mode,\n\t\t\t\t  bool enable)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\t \n\tif ((enable && (++ctrl->flyback_users == 1)) ||\n\t   (!enable && (--ctrl->flyback_users == 0))) {\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\tWCD9XXX_A_ANA_RX_VNEG_EN_MASK,\n\t\t\t\tenable << WCD9XXX_A_ANA_RX_VNEG_EN_SHIFT);\n\t\t \n\t\tusleep_range(100, 110);\n\t}\n\t \n\tusleep_range(500, 500 + WCD_USLEEP_RANGE);\n}\n\nstatic void wcd_clsh_set_gain_path(struct wcd_clsh_ctrl *ctrl, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\tint val = 0;\n\n\tswitch (mode) {\n\tcase CLS_H_NORMAL:\n\tcase CLS_AB:\n\t\tval = WCD9XXX_HPH_CONST_SEL_BYPASS;\n\t\tbreak;\n\tcase CLS_H_HIFI:\n\t\tval = WCD9XXX_HPH_CONST_SEL_HQ_PATH;\n\t\tbreak;\n\tcase CLS_H_LP:\n\t\tval = WCD9XXX_HPH_CONST_SEL_LP_PATH;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_update_bits(comp, WCD9XXX_HPH_L_EN,\n\t\t\t\t\tWCD9XXX_HPH_CONST_SEL_L_MASK,\n\t\t\t\t\tval);\n\n\tsnd_soc_component_update_bits(comp, WCD9XXX_HPH_R_EN,\n\t\t\t\t\tWCD9XXX_HPH_CONST_SEL_L_MASK,\n\t\t\t\t\tval);\n}\n\nstatic void wcd_clsh_v2_set_hph_mode(struct snd_soc_component *comp, int mode)\n{\n\tint val = 0, gain = 0, res_val;\n\tint ipeak = WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_50MA;\n\n\tres_val = WCD9XXX_CLASSH_CTRL_VCL_VREF_FILT_R_0KOHM;\n\tswitch (mode) {\n\tcase CLS_H_NORMAL:\n\t\tres_val = WCD9XXX_CLASSH_CTRL_VCL_VREF_FILT_R_50KOHM;\n\t\tval = WCD9XXX_A_ANA_HPH_PWR_LEVEL_NORMAL;\n\t\tgain = DAC_GAIN_0DB;\n\t\tipeak = WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_50MA;\n\t\tbreak;\n\tcase CLS_AB:\n\t\tval = WCD9XXX_A_ANA_HPH_PWR_LEVEL_NORMAL;\n\t\tgain = DAC_GAIN_0DB;\n\t\tipeak = WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_50MA;\n\t\tbreak;\n\tcase CLS_H_HIFI:\n\t\tval = WCD9XXX_A_ANA_HPH_PWR_LEVEL_UHQA;\n\t\tgain = DAC_GAIN_M0P2DB;\n\t\tipeak = WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_50MA;\n\t\tbreak;\n\tcase CLS_H_LP:\n\t\tval = WCD9XXX_A_ANA_HPH_PWR_LEVEL_LP;\n\t\tipeak = WCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_30MA;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_HPH,\n\t\t\t\t\tWCD9XXX_A_ANA_HPH_PWR_LEVEL_MASK, val);\n\tsnd_soc_component_update_bits(comp, WCD9XXX_CLASSH_CTRL_VCL_2,\n\t\t\t\tWCD9XXX_CLASSH_CTRL_VCL_2_VREF_FILT_1_MASK,\n\t\t\t\tres_val);\n\tif (mode != CLS_H_LP)\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_HPH_REFBUFF_UHQA_CTL,\n\t\t\t\t\tWCD9XXX_HPH_REFBUFF_UHQA_GAIN_MASK,\n\t\t\t\t\tgain);\n\tsnd_soc_component_update_bits(comp, WCD9XXX_CLASSH_CTRL_CCL_1,\n\t\t\t\tWCD9XXX_CLASSH_CTRL_CCL_1_DELTA_IPEAK_MASK,\n\t\t\t\tipeak);\n}\n\nstatic void wcd_clsh_v3_set_hph_mode(struct snd_soc_component *component,\n\t\t\t\t  int mode)\n{\n\tu8 val;\n\n\tswitch (mode) {\n\tcase CLS_H_NORMAL:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase CLS_AB:\n\tcase CLS_H_ULP:\n\t\tval = 0x0C;\n\t\tbreak;\n\tcase CLS_AB_HIFI:\n\tcase CLS_H_HIFI:\n\t\tval = 0x08;\n\t\tbreak;\n\tcase CLS_H_LP:\n\tcase CLS_H_LOHIFI:\n\tcase CLS_AB_LP:\n\tcase CLS_AB_LOHIFI:\n\t\tval = 0x04;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s:Invalid mode %d\\n\", __func__, mode);\n\t\treturn;\n\t}\n\n\tsnd_soc_component_update_bits(component, WCD9XXX_ANA_HPH, 0x0C, val);\n}\n\nvoid wcd_clsh_set_hph_mode(struct wcd_clsh_ctrl *ctrl, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (ctrl->codec_version >= WCD937X)\n\t\twcd_clsh_v3_set_hph_mode(comp, mode);\n\telse\n\t\twcd_clsh_v2_set_hph_mode(comp, mode);\n\n}\nEXPORT_SYMBOL_GPL(wcd_clsh_set_hph_mode);\n\nstatic void wcd_clsh_set_flyback_current(struct snd_soc_component *comp,\n\t\t\t\t\t int mode)\n{\n\n\tsnd_soc_component_update_bits(comp, WCD9XXX_RX_BIAS_FLYB_BUFF,\n\t\t\t\tWCD9XXX_RX_BIAS_FLYB_VPOS_5_UA_MASK, 0x0A);\n\tsnd_soc_component_update_bits(comp, WCD9XXX_RX_BIAS_FLYB_BUFF,\n\t\t\t\tWCD9XXX_RX_BIAS_FLYB_VNEG_5_UA_MASK, 0x0A);\n\t \n\tusleep_range(100, 110);\n}\n\nstatic void wcd_clsh_set_buck_regulator_mode(struct snd_soc_component *comp,\n\t\t\t\t\t     int mode)\n{\n\tif (mode == CLS_AB)\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_REGULATOR_MODE_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_REGULATOR_MODE_CLS_AB);\n\telse\n\t\tsnd_soc_component_update_bits(comp, WCD9XXX_A_ANA_RX_SUPPLIES,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_REGULATOR_MODE_MASK,\n\t\t\t\t\tWCD9XXX_A_ANA_RX_REGULATOR_MODE_CLS_H);\n}\n\nstatic void wcd_clsh_v3_set_buck_regulator_mode(struct snd_soc_component *component,\n\t\t\t\t\t\tint mode)\n{\n\tsnd_soc_component_update_bits(component, WCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t    0x02, 0x00);\n}\n\nstatic void wcd_clsh_v3_set_flyback_mode(struct snd_soc_component *component,\n\t\t\t\t\t\tint mode)\n{\n\tif (mode == CLS_H_HIFI || mode == CLS_H_LOHIFI ||\n\t    mode == CLS_AB_HIFI || mode == CLS_AB_LOHIFI) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t0x04, 0x04);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_FLYBACK_VNEG_CTRL_4,\n\t\t\t\t0xF0, 0x80);\n\t} else {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t0x04, 0x00);  \n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_FLYBACK_VNEG_CTRL_4,\n\t\t\t\t0xF0, 0x70);\n\t}\n}\n\nstatic void wcd_clsh_v3_force_iq_ctl(struct snd_soc_component *component,\n\t\t\t\t\t int mode, bool enable)\n{\n\tif (enable) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_FLYBACK_VNEGDAC_CTRL_2,\n\t\t\t\t0xE0, 0xA0);\n\t\t \n\t\tusleep_range(100, 110);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_CLASSH_MODE_3,\n\t\t\t\t0x02, 0x02);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_CLASSH_MODE_2,\n\t\t\t\t0xFF, 0x1C);\n\t\tif (mode == CLS_H_LOHIFI || mode == CLS_AB_LOHIFI) {\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tWCD9XXX_HPH_NEW_INT_PA_MISC2,\n\t\t\t\t\t0x20, 0x20);\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tWCD9XXX_RX_BIAS_HPH_LOWPOWER,\n\t\t\t\t\t0xF0, 0xC0);\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tWCD9XXX_HPH_PA_CTL1,\n\t\t\t\t\t0x0E, 0x02);\n\t\t}\n\t} else {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_HPH_NEW_INT_PA_MISC2,\n\t\t\t\t0x20, 0x00);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_RX_BIAS_HPH_LOWPOWER,\n\t\t\t\t0xF0, 0x80);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_HPH_PA_CTL1,\n\t\t\t\t0x0E, 0x06);\n\t}\n}\n\nstatic void wcd_clsh_v3_flyback_ctrl(struct snd_soc_component *component,\n\t\t\t\t  struct wcd_clsh_ctrl *ctrl,\n\t\t\t\t  int mode,\n\t\t\t\t  bool enable)\n{\n\t \n\tif ((enable && (++ctrl->flyback_users == 1)) ||\n\t   (!enable && (--ctrl->flyback_users == 0))) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_FLYBACK_VNEG_CTRL_1,\n\t\t\t\t0xE0, 0xE0);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_ANA_RX_SUPPLIES,\n\t\t\t\t(1 << 6), (enable << 6));\n\t\t \n\t\tusleep_range(100, 110);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tWCD9XXX_FLYBACK_VNEGDAC_CTRL_2,\n\t\t\t\t0xE0, 0xE0);\n\t\t \n\t\tusleep_range(500, 500 + WCD_USLEEP_RANGE);\n\t}\n}\n\nstatic void wcd_clsh_v3_set_flyback_current(struct snd_soc_component *component,\n\t\t\t\tint mode)\n{\n\tsnd_soc_component_update_bits(component, WCD9XXX_V3_RX_BIAS_FLYB_BUFF,\n\t\t\t\t0x0F, 0x0A);\n\tsnd_soc_component_update_bits(component, WCD9XXX_V3_RX_BIAS_FLYB_BUFF,\n\t\t\t\t0xF0, 0xA0);\n\t \n\tusleep_range(100, 110);\n}\n\nstatic void wcd_clsh_v3_state_aux(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t      bool is_enable, int mode)\n{\n\tstruct snd_soc_component *component = ctrl->comp;\n\n\tif (is_enable) {\n\t\twcd_clsh_v3_set_buck_mode(component, mode);\n\t\twcd_clsh_v3_set_flyback_mode(component, mode);\n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_flyback_current(component, mode);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, mode, true);\n\t} else {\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, mode, false);\n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, mode, false);\n\t\twcd_clsh_v3_set_flyback_mode(component, CLS_H_NORMAL);\n\t\twcd_clsh_v3_set_buck_mode(component, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_state_lo(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t      bool is_enable, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (mode != CLS_AB) {\n\t\tdev_err(comp->dev, \"%s: LO cannot be in this mode: %d\\n\",\n\t\t\t__func__, mode);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\twcd_clsh_set_buck_regulator_mode(comp, mode);\n\t\twcd_clsh_set_buck_mode(comp, mode);\n\t\twcd_clsh_set_flyback_mode(comp, mode);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, true);\n\t\twcd_clsh_set_flyback_current(comp, mode);\n\t\twcd_clsh_buck_ctrl(ctrl, mode, true);\n\t} else {\n\t\twcd_clsh_buck_ctrl(ctrl, mode, false);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, false);\n\t\twcd_clsh_set_flyback_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_regulator_mode(comp, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_v3_state_hph_r(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t\t bool is_enable, int mode)\n{\n\tstruct snd_soc_component *component = ctrl->comp;\n\n\tif (mode == CLS_H_NORMAL) {\n\t\tdev_dbg(component->dev, \"%s: Normal mode not applicable for hph_r\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\twcd_clsh_v3_set_buck_regulator_mode(component, mode);\n\t\twcd_clsh_v3_set_flyback_mode(component, mode);\n\t\twcd_clsh_v3_force_iq_ctl(component, mode, true);\n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_flyback_current(component, mode);\n\t\twcd_clsh_v3_set_buck_mode(component, mode);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_hph_mode(component, mode);\n\t} else {\n\t\twcd_clsh_v3_set_hph_mode(component, CLS_H_NORMAL);\n\n\t\t \n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_force_iq_ctl(component, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_set_flyback_mode(component, CLS_H_NORMAL);\n\t\twcd_clsh_v3_set_buck_mode(component, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_state_hph_r(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t\t bool is_enable, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (mode == CLS_H_NORMAL) {\n\t\tdev_err(comp->dev, \"%s: Normal mode not applicable for hph_r\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\tif (mode != CLS_AB) {\n\t\t\twcd_enable_clsh_block(ctrl, true);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_MSB,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_MSB_COEF_MASK,\n\t\t\t\t\t0x00);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_LSB,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_LSB_COEF_MASK,\n\t\t\t\t\t0xC0);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX2_RX_PATH_CFG0,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_ENABLE);\n\t\t}\n\t\twcd_clsh_set_buck_regulator_mode(comp, mode);\n\t\twcd_clsh_set_flyback_mode(comp, mode);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, true);\n\t\twcd_clsh_set_flyback_current(comp, mode);\n\t\twcd_clsh_set_buck_mode(comp, mode);\n\t\twcd_clsh_buck_ctrl(ctrl, mode, true);\n\t\twcd_clsh_v2_set_hph_mode(comp, mode);\n\t\twcd_clsh_set_gain_path(ctrl, mode);\n\t} else {\n\t\twcd_clsh_v2_set_hph_mode(comp, CLS_H_NORMAL);\n\n\t\tif (mode != CLS_AB) {\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX2_RX_PATH_CFG0,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_DISABLE);\n\t\t\twcd_enable_clsh_block(ctrl, false);\n\t\t}\n\t\t \n\t\twcd_clsh_buck_ctrl(ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_flyback_ctrl(ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_set_flyback_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_regulator_mode(comp, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_v3_state_hph_l(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t\t bool is_enable, int mode)\n{\n\tstruct snd_soc_component *component = ctrl->comp;\n\n\tif (mode == CLS_H_NORMAL) {\n\t\tdev_dbg(component->dev, \"%s: Normal mode not applicable for hph_l\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\twcd_clsh_v3_set_buck_regulator_mode(component, mode);\n\t\twcd_clsh_v3_set_flyback_mode(component, mode);\n\t\twcd_clsh_v3_force_iq_ctl(component, mode, true);\n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_flyback_current(component, mode);\n\t\twcd_clsh_v3_set_buck_mode(component, mode);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_hph_mode(component, mode);\n\t} else {\n\t\twcd_clsh_v3_set_hph_mode(component, CLS_H_NORMAL);\n\n\t\t \n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_force_iq_ctl(component, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_set_flyback_mode(component, CLS_H_NORMAL);\n\t\twcd_clsh_v3_set_buck_mode(component, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_state_hph_l(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t\t bool is_enable, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (mode == CLS_H_NORMAL) {\n\t\tdev_err(comp->dev, \"%s: Normal mode not applicable for hph_l\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\tif (mode != CLS_AB) {\n\t\t\twcd_enable_clsh_block(ctrl, true);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_MSB,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_MSB_COEF_MASK,\n\t\t\t\t\t0x00);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_LSB,\n\t\t\t\t\tWCD9XXX_A_CDC_CLSH_K1_LSB_COEF_MASK,\n\t\t\t\t\t0xC0);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX1_RX_PATH_CFG0,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_ENABLE);\n\t\t}\n\t\twcd_clsh_set_buck_regulator_mode(comp, mode);\n\t\twcd_clsh_set_flyback_mode(comp, mode);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, true);\n\t\twcd_clsh_set_flyback_current(comp, mode);\n\t\twcd_clsh_set_buck_mode(comp, mode);\n\t\twcd_clsh_buck_ctrl(ctrl, mode, true);\n\t\twcd_clsh_v2_set_hph_mode(comp, mode);\n\t\twcd_clsh_set_gain_path(ctrl, mode);\n\t} else {\n\t\twcd_clsh_v2_set_hph_mode(comp, CLS_H_NORMAL);\n\n\t\tif (mode != CLS_AB) {\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX1_RX_PATH_CFG0,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\t    WCD9XXX_A_CDC_RX_PATH_CLSH_DISABLE);\n\t\t\twcd_enable_clsh_block(ctrl, false);\n\t\t}\n\t\t \n\t\twcd_clsh_buck_ctrl(ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_flyback_ctrl(ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_set_flyback_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_regulator_mode(comp, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_v3_state_ear(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t       bool is_enable, int mode)\n{\n\tstruct snd_soc_component *component = ctrl->comp;\n\n\tif (is_enable) {\n\t\twcd_clsh_v3_set_buck_regulator_mode(component, mode);\n\t\twcd_clsh_v3_set_flyback_mode(component, mode);\n\t\twcd_clsh_v3_force_iq_ctl(component, mode, true);\n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_flyback_current(component, mode);\n\t\twcd_clsh_v3_set_buck_mode(component, mode);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, mode, true);\n\t\twcd_clsh_v3_set_hph_mode(component, mode);\n\t} else {\n\t\twcd_clsh_v3_set_hph_mode(component, CLS_H_NORMAL);\n\n\t\t \n\t\twcd_clsh_v3_flyback_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_buck_ctrl(component, ctrl, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_force_iq_ctl(component, CLS_H_NORMAL, false);\n\t\twcd_clsh_v3_set_flyback_mode(component, CLS_H_NORMAL);\n\t\twcd_clsh_v3_set_buck_mode(component, CLS_H_NORMAL);\n\t}\n}\n\nstatic void wcd_clsh_state_ear(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t       bool is_enable, int mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (mode != CLS_H_NORMAL) {\n\t\tdev_err(comp->dev, \"%s: mode: %d cannot be used for EAR\\n\",\n\t\t\t__func__, mode);\n\t\treturn;\n\t}\n\n\tif (is_enable) {\n\t\twcd_enable_clsh_block(ctrl, true);\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_RX0_RX_PATH_CFG0,\n\t\t\t\t\tWCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\tWCD9XXX_A_CDC_RX_PATH_CLSH_ENABLE);\n\t\twcd_clsh_set_buck_mode(comp, mode);\n\t\twcd_clsh_set_flyback_mode(comp, mode);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, true);\n\t\twcd_clsh_set_flyback_current(comp, mode);\n\t\twcd_clsh_buck_ctrl(ctrl, mode, true);\n\t} else {\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\tWCD9XXX_A_CDC_RX0_RX_PATH_CFG0,\n\t\t\t\t\tWCD9XXX_A_CDC_RX_PATH_CLSH_EN_MASK,\n\t\t\t\t\tWCD9XXX_A_CDC_RX_PATH_CLSH_DISABLE);\n\t\twcd_enable_clsh_block(ctrl, false);\n\t\twcd_clsh_buck_ctrl(ctrl, mode, false);\n\t\twcd_clsh_flyback_ctrl(ctrl, mode, false);\n\t\twcd_clsh_set_flyback_mode(comp, CLS_H_NORMAL);\n\t\twcd_clsh_set_buck_mode(comp, CLS_H_NORMAL);\n\t}\n}\n\nstatic int _wcd_clsh_ctrl_set_state(struct wcd_clsh_ctrl *ctrl, int req_state,\n\t\t\t\t    bool is_enable, int mode)\n{\n\tswitch (req_state) {\n\tcase WCD_CLSH_STATE_EAR:\n\t\tif (ctrl->codec_version >= WCD937X)\n\t\t\twcd_clsh_v3_state_ear(ctrl, req_state, is_enable, mode);\n\t\telse\n\t\t\twcd_clsh_state_ear(ctrl, req_state, is_enable, mode);\n\t\tbreak;\n\tcase WCD_CLSH_STATE_HPHL:\n\t\tif (ctrl->codec_version >= WCD937X)\n\t\t\twcd_clsh_v3_state_hph_l(ctrl, req_state, is_enable, mode);\n\t\telse\n\t\t\twcd_clsh_state_hph_l(ctrl, req_state, is_enable, mode);\n\t\tbreak;\n\tcase WCD_CLSH_STATE_HPHR:\n\t\tif (ctrl->codec_version >= WCD937X)\n\t\t\twcd_clsh_v3_state_hph_r(ctrl, req_state, is_enable, mode);\n\t\telse\n\t\t\twcd_clsh_state_hph_r(ctrl, req_state, is_enable, mode);\n\t\tbreak;\n\tcase WCD_CLSH_STATE_LO:\n\t\tif (ctrl->codec_version < WCD937X)\n\t\t\twcd_clsh_state_lo(ctrl, req_state, is_enable, mode);\n\t\tbreak;\n\tcase WCD_CLSH_STATE_AUX:\n\t\tif (ctrl->codec_version >= WCD937X)\n\t\t\twcd_clsh_v3_state_aux(ctrl, req_state, is_enable, mode);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool wcd_clsh_is_state_valid(int state)\n{\n\tswitch (state) {\n\tcase WCD_CLSH_STATE_IDLE:\n\tcase WCD_CLSH_STATE_EAR:\n\tcase WCD_CLSH_STATE_HPHL:\n\tcase WCD_CLSH_STATE_HPHR:\n\tcase WCD_CLSH_STATE_LO:\n\tcase WCD_CLSH_STATE_AUX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t};\n}\n\n \nint wcd_clsh_ctrl_set_state(struct wcd_clsh_ctrl *ctrl,\n\t\t\t    enum wcd_clsh_event clsh_event,\n\t\t\t    int nstate,\n\t\t\t    enum wcd_clsh_mode mode)\n{\n\tstruct snd_soc_component *comp = ctrl->comp;\n\n\tif (nstate == ctrl->state)\n\t\treturn 0;\n\n\tif (!wcd_clsh_is_state_valid(nstate)) {\n\t\tdev_err(comp->dev, \"Class-H not a valid new state:\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (clsh_event) {\n\tcase WCD_CLSH_EVENT_PRE_DAC:\n\t\t_wcd_clsh_ctrl_set_state(ctrl, nstate, CLSH_REQ_ENABLE, mode);\n\t\tbreak;\n\tcase WCD_CLSH_EVENT_POST_PA:\n\t\t_wcd_clsh_ctrl_set_state(ctrl, nstate, CLSH_REQ_DISABLE, mode);\n\t\tbreak;\n\t}\n\n\tctrl->state = nstate;\n\tctrl->mode = mode;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wcd_clsh_ctrl_set_state);\n\nint wcd_clsh_ctrl_get_state(struct wcd_clsh_ctrl *ctrl)\n{\n\treturn ctrl->state;\n}\nEXPORT_SYMBOL_GPL(wcd_clsh_ctrl_get_state);\n\nstruct wcd_clsh_ctrl *wcd_clsh_ctrl_alloc(struct snd_soc_component *comp,\n\t\t\t\t\t  int version)\n{\n\tstruct wcd_clsh_ctrl *ctrl;\n\n\tctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctrl->state = WCD_CLSH_STATE_IDLE;\n\tctrl->comp = comp;\n\tctrl->codec_version = version;\n\n\treturn ctrl;\n}\nEXPORT_SYMBOL_GPL(wcd_clsh_ctrl_alloc);\n\nvoid wcd_clsh_ctrl_free(struct wcd_clsh_ctrl *ctrl)\n{\n\tkfree(ctrl);\n}\nEXPORT_SYMBOL_GPL(wcd_clsh_ctrl_free);\n\nMODULE_DESCRIPTION(\"WCD93XX Class-H driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}