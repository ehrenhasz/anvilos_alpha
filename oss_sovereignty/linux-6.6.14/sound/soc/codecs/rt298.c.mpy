{
  "module_name": "rt298.c",
  "hash_id": "acb9ae1595a1bea49f4503e4f4a78ed6ad1b6cd0c01d74e0e166114874577198",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt298.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/dmi.h>\n#include <linux/acpi.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/jack.h>\n#include <linux/workqueue.h>\n#include <sound/rt298.h>\n\n#include \"rl6347a.h\"\n#include \"rt298.h\"\n\n#define RT298_VENDOR_ID 0x10ec0298\n\nstruct rt298_priv {\n\tstruct reg_default *index_cache;\n\tint index_cache_size;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct rt298_platform_data pdata;\n\tstruct i2c_client *i2c;\n\tstruct snd_soc_jack *jack;\n\tstruct delayed_work jack_detect_work;\n\tint sys_clk;\n\tint clk_id;\n\tint is_hp_in;\n};\n\nstatic const struct reg_default rt298_index_def[] = {\n\t{ 0x01, 0xa5a8 },\n\t{ 0x02, 0x8e95 },\n\t{ 0x03, 0x0002 },\n\t{ 0x04, 0xaf67 },\n\t{ 0x08, 0x200f },\n\t{ 0x09, 0xd010 },\n\t{ 0x0a, 0x0100 },\n\t{ 0x0b, 0x0000 },\n\t{ 0x0d, 0x2800 },\n\t{ 0x0f, 0x0022 },\n\t{ 0x19, 0x0217 },\n\t{ 0x20, 0x0020 },\n\t{ 0x33, 0x0208 },\n\t{ 0x46, 0x0300 },\n\t{ 0x49, 0x4004 },\n\t{ 0x4f, 0x50c9 },\n\t{ 0x50, 0x3000 },\n\t{ 0x63, 0x1b02 },\n\t{ 0x67, 0x1111 },\n\t{ 0x68, 0x1016 },\n\t{ 0x69, 0x273f },\n};\n#define INDEX_CACHE_SIZE ARRAY_SIZE(rt298_index_def)\n\nstatic const struct reg_default rt298_reg[] = {\n\t{ 0x00170500, 0x00000400 },\n\t{ 0x00220000, 0x00000031 },\n\t{ 0x00239000, 0x0000007f },\n\t{ 0x0023a000, 0x0000007f },\n\t{ 0x00270500, 0x00000400 },\n\t{ 0x00370500, 0x00000400 },\n\t{ 0x00870500, 0x00000400 },\n\t{ 0x00920000, 0x00000031 },\n\t{ 0x00935000, 0x000000c3 },\n\t{ 0x00936000, 0x000000c3 },\n\t{ 0x00970500, 0x00000400 },\n\t{ 0x00b37000, 0x00000097 },\n\t{ 0x00b37200, 0x00000097 },\n\t{ 0x00b37300, 0x00000097 },\n\t{ 0x00c37000, 0x00000000 },\n\t{ 0x00c37100, 0x00000080 },\n\t{ 0x01270500, 0x00000400 },\n\t{ 0x01370500, 0x00000400 },\n\t{ 0x01371f00, 0x411111f0 },\n\t{ 0x01439000, 0x00000080 },\n\t{ 0x0143a000, 0x00000080 },\n\t{ 0x01470700, 0x00000000 },\n\t{ 0x01470500, 0x00000400 },\n\t{ 0x01470c00, 0x00000000 },\n\t{ 0x01470100, 0x00000000 },\n\t{ 0x01837000, 0x00000000 },\n\t{ 0x01870500, 0x00000400 },\n\t{ 0x02050000, 0x00000000 },\n\t{ 0x02139000, 0x00000080 },\n\t{ 0x0213a000, 0x00000080 },\n\t{ 0x02170100, 0x00000000 },\n\t{ 0x02170500, 0x00000400 },\n\t{ 0x02170700, 0x00000000 },\n\t{ 0x02270100, 0x00000000 },\n\t{ 0x02370100, 0x00000000 },\n\t{ 0x01870700, 0x00000020 },\n\t{ 0x00830000, 0x000000c3 },\n\t{ 0x00930000, 0x000000c3 },\n\t{ 0x01270700, 0x00000000 },\n};\n\nstatic bool rt298_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0 ... 0xff:\n\tcase RT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\n\tcase RT298_GET_HP_SENSE:\n\tcase RT298_GET_MIC1_SENSE:\n\tcase RT298_PROC_COEF:\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_MIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_SPK_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_HP_OUT, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n\n}\n\nstatic bool rt298_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0 ... 0xff:\n\tcase RT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\n\tcase RT298_GET_HP_SENSE:\n\tcase RT298_GET_MIC1_SENSE:\n\tcase RT298_SET_AUDIO_POWER:\n\tcase RT298_SET_HPO_POWER:\n\tcase RT298_SET_SPK_POWER:\n\tcase RT298_SET_DMIC1_POWER:\n\tcase RT298_SPK_MUX:\n\tcase RT298_HPO_MUX:\n\tcase RT298_ADC0_MUX:\n\tcase RT298_ADC1_MUX:\n\tcase RT298_SET_MIC1:\n\tcase RT298_SET_PIN_HPO:\n\tcase RT298_SET_PIN_SPK:\n\tcase RT298_SET_PIN_DMIC1:\n\tcase RT298_SPK_EAPD:\n\tcase RT298_SET_AMP_GAIN_HPO:\n\tcase RT298_SET_DMIC2_DEFAULT:\n\tcase RT298_DACL_GAIN:\n\tcase RT298_DACR_GAIN:\n\tcase RT298_ADCL_GAIN:\n\tcase RT298_ADCR_GAIN:\n\tcase RT298_MIC_GAIN:\n\tcase RT298_SPOL_GAIN:\n\tcase RT298_SPOR_GAIN:\n\tcase RT298_HPOL_GAIN:\n\tcase RT298_HPOR_GAIN:\n\tcase RT298_F_DAC_SWITCH:\n\tcase RT298_F_RECMIX_SWITCH:\n\tcase RT298_REC_MIC_SWITCH:\n\tcase RT298_REC_I2S_SWITCH:\n\tcase RT298_REC_LINE_SWITCH:\n\tcase RT298_REC_BEEP_SWITCH:\n\tcase RT298_DAC_FORMAT:\n\tcase RT298_ADC_FORMAT:\n\tcase RT298_COEF_INDEX:\n\tcase RT298_PROC_COEF:\n\tcase RT298_SET_AMP_GAIN_ADC_IN1:\n\tcase RT298_SET_AMP_GAIN_ADC_IN2:\n\tcase RT298_SET_POWER(RT298_DAC_OUT1):\n\tcase RT298_SET_POWER(RT298_DAC_OUT2):\n\tcase RT298_SET_POWER(RT298_ADC_IN1):\n\tcase RT298_SET_POWER(RT298_ADC_IN2):\n\tcase RT298_SET_POWER(RT298_DMIC2):\n\tcase RT298_SET_POWER(RT298_MIC1):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_MIC1, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_SPK_OUT, 0):\n\tcase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_HP_OUT, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic void rt298_index_sync(struct snd_soc_component *component)\n{\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tfor (i = 0; i < INDEX_CACHE_SIZE; i++) {\n\t\tsnd_soc_component_write(component, rt298->index_cache[i].reg,\n\t\t\t\t  rt298->index_cache[i].def);\n\t}\n}\n#endif\n\nstatic int rt298_support_power_controls[] = {\n\tRT298_DAC_OUT1,\n\tRT298_DAC_OUT2,\n\tRT298_ADC_IN1,\n\tRT298_ADC_IN2,\n\tRT298_MIC1,\n\tRT298_DMIC1,\n\tRT298_DMIC2,\n\tRT298_SPK_OUT,\n\tRT298_HP_OUT,\n};\n#define RT298_POWER_REG_LEN ARRAY_SIZE(rt298_support_power_controls)\n\nstatic int rt298_jack_detect(struct rt298_priv *rt298, bool *hp, bool *mic)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\tunsigned int val, buf;\n\n\t*hp = false;\n\t*mic = false;\n\n\tif (!rt298->component)\n\t\treturn -EINVAL;\n\n\tdapm = snd_soc_component_get_dapm(rt298->component);\n\n\tif (rt298->pdata.cbj_en) {\n\t\tregmap_read(rt298->regmap, RT298_GET_HP_SENSE, &buf);\n\t\t*hp = buf & 0x80000000;\n\t\tif (*hp == rt298->is_hp_in)\n\t\t\treturn -1;\n\t\trt298->is_hp_in = *hp;\n\t\tif (*hp) {\n\t\t\t \n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_DC_GAIN, 0x200, 0x200);\n\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"HV\");\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"VREF\");\n\t\t\t \n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"LDO1\");\n\t\t\tsnd_soc_dapm_sync(dapm);\n\n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_POWER_CTRL1, 0x1001, 0);\n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_POWER_CTRL2, 0x4, 0x4);\n\n\t\t\tregmap_write(rt298->regmap, RT298_SET_MIC1, 0x24);\n\t\t\tmsleep(50);\n\n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_CBJ_CTRL1, 0xfcc0, 0xd400);\n\t\t\tmsleep(300);\n\t\t\tregmap_read(rt298->regmap, RT298_CBJ_CTRL2, &val);\n\n\t\t\tif (0x0070 == (val & 0x0070)) {\n\t\t\t\t*mic = true;\n\t\t\t} else {\n\t\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\t\tRT298_CBJ_CTRL1, 0xfcc0, 0xe400);\n\t\t\t\tmsleep(300);\n\t\t\t\tregmap_read(rt298->regmap,\n\t\t\t\t\tRT298_CBJ_CTRL2, &val);\n\t\t\t\tif (0x0070 == (val & 0x0070)) {\n\t\t\t\t\t*mic = true;\n\t\t\t\t} else {\n\t\t\t\t\t*mic = false;\n\t\t\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\t\t\tRT298_CBJ_CTRL1,\n\t\t\t\t\t\t0xfcc0, 0xc400);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_DC_GAIN, 0x200, 0x0);\n\n\t\t} else {\n\t\t\t*mic = false;\n\t\t\tregmap_write(rt298->regmap, RT298_SET_MIC1, 0x20);\n\t\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_CBJ_CTRL1, 0x0400, 0x0000);\n\t\t}\n\t} else {\n\t\tregmap_read(rt298->regmap, RT298_GET_HP_SENSE, &buf);\n\t\t*hp = buf & 0x80000000;\n\t\tregmap_read(rt298->regmap, RT298_GET_MIC1_SENSE, &buf);\n\t\t*mic = buf & 0x80000000;\n\t}\n\tif (!*mic) {\n\t\tsnd_soc_dapm_disable_pin(dapm, \"HV\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"VREF\");\n\t}\n\tif (!*hp)\n\t\tsnd_soc_dapm_disable_pin(dapm, \"LDO1\");\n\tsnd_soc_dapm_sync(dapm);\n\n\tpr_debug(\"*hp = %d *mic = %d\\n\", *hp, *mic);\n\n\treturn 0;\n}\n\nstatic void rt298_jack_detect_work(struct work_struct *work)\n{\n\tstruct rt298_priv *rt298 =\n\t\tcontainer_of(work, struct rt298_priv, jack_detect_work.work);\n\tint status = 0;\n\tbool hp = false;\n\tbool mic = false;\n\n\tif (rt298_jack_detect(rt298, &hp, &mic) < 0)\n\t\treturn;\n\n\tif (hp)\n\t\tstatus |= SND_JACK_HEADPHONE;\n\n\tif (mic)\n\t\tstatus |= SND_JACK_MICROPHONE;\n\n\tsnd_soc_jack_report(rt298->jack, status,\n\t\tSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\n}\n\nstatic int rt298_mic_detect(struct snd_soc_component *component,\n\t\t\t    struct snd_soc_jack *jack, void *data)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\trt298->jack = jack;\n\n\tif (jack) {\n\t\t \n\t\tif (rt298->jack->status & SND_JACK_HEADPHONE)\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"LDO1\");\n\t\tif (rt298->jack->status & SND_JACK_MICROPHONE) {\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"HV\");\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"VREF\");\n\t\t}\n\t\tregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x2, 0x2);\n\t\t \n\t\tsnd_soc_jack_report(rt298->jack, rt298->jack->status,\n\t\t\t\t    SND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\n\t} else {\n\t\t \n\t\tregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x2, 0x0);\n\t\tsnd_soc_dapm_disable_pin(dapm, \"HV\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"VREF\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"LDO1\");\n\t}\n\tsnd_soc_dapm_sync(dapm);\n\n\treturn 0;\n}\n\nstatic int is_mclk_mode(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\tif (rt298->clk_id == RT298_SCLK_S_MCLK)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(out_vol_tlv, -6350, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic const struct snd_kcontrol_new rt298_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC0 Playback Volume\", RT298_DACL_GAIN,\n\t\t\t    RT298_DACR_GAIN, 0, 0x7f, 0, out_vol_tlv),\n\tSOC_DOUBLE_R_TLV(\"ADC0 Capture Volume\", RT298_ADCL_GAIN,\n\t\t\t    RT298_ADCR_GAIN, 0, 0x7f, 0, out_vol_tlv),\n\tSOC_SINGLE_TLV(\"AMIC Volume\", RT298_MIC_GAIN,\n\t\t\t    0, 0x3, 0, mic_vol_tlv),\n\tSOC_DOUBLE_R(\"Speaker Playback Switch\", RT298_SPOL_GAIN,\n\t\t\t    RT298_SPOR_GAIN, RT298_MUTE_SFT, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new rt298_front_mix[] = {\n\tSOC_DAPM_SINGLE(\"DAC Switch\",  RT298_F_DAC_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n\tSOC_DAPM_SINGLE(\"RECMIX Switch\", RT298_F_RECMIX_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new rt298_rec_mix[] = {\n\tSOC_DAPM_SINGLE(\"Mic1 Switch\", RT298_REC_MIC_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n\tSOC_DAPM_SINGLE(\"I2S Switch\", RT298_REC_I2S_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n\tSOC_DAPM_SINGLE(\"Line1 Switch\", RT298_REC_LINE_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n\tSOC_DAPM_SINGLE(\"Beep Switch\", RT298_REC_BEEP_SWITCH,\n\t\t\tRT298_MUTE_SFT, 1, 1),\n};\n\nstatic const struct snd_kcontrol_new spo_enable_control =\n\tSOC_DAPM_SINGLE(\"Switch\", RT298_SET_PIN_SPK,\n\t\t\tRT298_SET_PIN_SFT, 1, 0);\n\nstatic const struct snd_kcontrol_new hpol_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT298_HPOL_GAIN,\n\t\t\tRT298_MUTE_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new hpor_enable_control =\n\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", RT298_HPOR_GAIN,\n\t\t\tRT298_MUTE_SFT, 1, 1);\n\n \nstatic const char * const rt298_adc_src[] = {\n\t\"Mic\", \"RECMIX\", \"Dmic\"\n};\n\nstatic const int rt298_adc_values[] = {\n\t0, 4, 5,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(\n\trt298_adc0_enum, RT298_ADC0_MUX, RT298_ADC_SEL_SFT,\n\tRT298_ADC_SEL_MASK, rt298_adc_src, rt298_adc_values);\n\nstatic const struct snd_kcontrol_new rt298_adc0_mux =\n\tSOC_DAPM_ENUM(\"ADC 0 source\", rt298_adc0_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(\n\trt298_adc1_enum, RT298_ADC1_MUX, RT298_ADC_SEL_SFT,\n\tRT298_ADC_SEL_MASK, rt298_adc_src, rt298_adc_values);\n\nstatic const struct snd_kcontrol_new rt298_adc1_mux =\n\tSOC_DAPM_ENUM(\"ADC 1 source\", rt298_adc1_enum);\n\nstatic const char * const rt298_dac_src[] = {\n\t\"Front\", \"Surround\"\n};\n \nstatic SOC_ENUM_SINGLE_DECL(rt298_hpo_enum, RT298_HPO_MUX,\n\t\t\t\t0, rt298_dac_src);\n\nstatic const struct snd_kcontrol_new rt298_hpo_mux =\nSOC_DAPM_ENUM(\"HPO source\", rt298_hpo_enum);\n\n \nstatic SOC_ENUM_SINGLE_DECL(rt298_spo_enum, RT298_SPK_MUX,\n\t\t\t\t0, rt298_dac_src);\n\nstatic const struct snd_kcontrol_new rt298_spo_mux =\nSOC_DAPM_ENUM(\"SPO source\", rt298_spo_enum);\n\nstatic int rt298_spk_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_write(component,\n\t\t\tRT298_SPK_EAPD, RT298_SET_EAPD_HIGH);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_write(component,\n\t\t\tRT298_SPK_EAPD, RT298_SET_EAPD_LOW);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt298_set_dmic1_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_write(component, RT298_SET_PIN_DMIC1, 0x20);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_write(component, RT298_SET_PIN_DMIC1, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt298_adc_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tunsigned int nid;\n\n\tnid = (w->reg >> 20) & 0xff;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tVERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),\n\t\t\t0x7080, 0x7000);\n\t\t  \n\t\tif (!(snd_soc_component_read(component, RT298_VAD_CTRL) & 0x200)) {\n\t\t\tpr_info(\"NO MCLK\\n\");\n\t\t\tswitch (nid) {\n\t\t\tcase RT298_ADC_IN1:\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tRT298_D_FILTER_CTRL, 0x2, 0x2);\n\t\t\t\tmdelay(10);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tRT298_D_FILTER_CTRL, 0x2, 0x0);\n\t\t\t\tbreak;\n\t\t\tcase RT298_ADC_IN2:\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tRT298_D_FILTER_CTRL, 0x4, 0x4);\n\t\t\t\tmdelay(10);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\tRT298_D_FILTER_CTRL, 0x4, 0x0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tVERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),\n\t\t\t0x7080, 0x7080);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt298_mic1_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_A_BIAS_CTRL3, 0xc000, 0x8000);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_A_BIAS_CTRL2, 0xc000, 0x8000);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_A_BIAS_CTRL3, 0xc000, 0x0000);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_A_BIAS_CTRL2, 0xc000, 0x0000);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt298_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_SUPPLY_S(\"HV\", 1, RT298_POWER_CTRL1,\n\t\t12, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VREF\", RT298_POWER_CTRL1,\n\t\t0, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"BG_MBIAS\", 1, RT298_POWER_CTRL2,\n\t\t1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"LDO1\", 1, RT298_POWER_CTRL2,\n\t\t2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"LDO2\", 1, RT298_POWER_CTRL2,\n\t\t3, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"VREF1\", 1, RT298_POWER_CTRL2,\n\t\t4, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"LV\", 2, RT298_POWER_CTRL1,\n\t\t13, 1, NULL, 0),\n\n\n\tSND_SOC_DAPM_SUPPLY(\"MCLK MODE\", RT298_PLL_CTRL1,\n\t\t5, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC1 Input Buffer\", SND_SOC_NOPM,\n\t\t0, 0, rt298_mic1_event, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"DMIC1 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"Beep\"),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"DMIC1\", RT298_SET_POWER(RT298_DMIC1), 0, 1,\n\t\tNULL, 0, rt298_set_dmic1_event,\n\t\tSND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_PGA(\"DMIC2\", RT298_SET_POWER(RT298_DMIC2), 0, 1,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC Receiver\", SND_SOC_NOPM,\n\t\t0, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"RECMIX\", SND_SOC_NOPM, 0, 0,\n\t\trt298_rec_mix, ARRAY_SIZE(rt298_rec_mix)),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC 0\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 1\", NULL, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_MUX_E(\"ADC 0 Mux\", RT298_SET_POWER(RT298_ADC_IN1), 0, 1,\n\t\t&rt298_adc0_mux, rt298_adc_event, SND_SOC_DAPM_PRE_PMD |\n\t\tSND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_MUX_E(\"ADC 1 Mux\", RT298_SET_POWER(RT298_ADC_IN2), 0, 1,\n\t\t&rt298_adc1_mux, rt298_adc_event, SND_SOC_DAPM_PRE_PMD |\n\t\tSND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RX\", \"AIF1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX\", \"AIF1 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF2RX\", \"AIF2 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2TX\", \"AIF2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\t \n\tSND_SOC_DAPM_DAC(\"DAC 0\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC 1\", NULL, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"SPK Mux\", SND_SOC_NOPM, 0, 0, &rt298_spo_mux),\n\tSND_SOC_DAPM_MUX(\"HPO Mux\", SND_SOC_NOPM, 0, 0, &rt298_hpo_mux),\n\n\tSND_SOC_DAPM_SUPPLY(\"HP Power\", RT298_SET_PIN_HPO,\n\t\tRT298_SET_PIN_SFT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Front\", RT298_SET_POWER(RT298_DAC_OUT1), 0, 1,\n\t\t\trt298_front_mix, ARRAY_SIZE(rt298_front_mix)),\n\tSND_SOC_DAPM_PGA(\"Surround\", RT298_SET_POWER(RT298_DAC_OUT2), 0, 1,\n\t\t\tNULL, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH_E(\"SPO\", SND_SOC_NOPM, 0, 0,\n\t\t&spo_enable_control, rt298_spk_event,\n\t\tSND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_SWITCH(\"HPO L\", SND_SOC_NOPM, 0, 0,\n\t\t&hpol_enable_control),\n\tSND_SOC_DAPM_SWITCH(\"HPO R\", SND_SOC_NOPM, 0, 0,\n\t\t&hpor_enable_control),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"SPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPO Pin\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPDIF\"),\n};\n\nstatic const struct snd_soc_dapm_route rt298_dapm_routes[] = {\n\n\t{\"ADC 0\", NULL, \"MCLK MODE\", is_mclk_mode},\n\t{\"ADC 1\", NULL, \"MCLK MODE\", is_mclk_mode},\n\t{\"Front\", NULL, \"MCLK MODE\", is_mclk_mode},\n\t{\"Surround\", NULL, \"MCLK MODE\", is_mclk_mode},\n\n\t{\"HP Power\", NULL, \"LDO1\"},\n\t{\"HP Power\", NULL, \"LDO2\"},\n\t{\"HP Power\", NULL, \"LV\"},\n\t{\"HP Power\", NULL, \"VREF1\"},\n\t{\"HP Power\", NULL, \"BG_MBIAS\"},\n\n\t{\"MIC1\", NULL, \"LDO1\"},\n\t{\"MIC1\", NULL, \"LDO2\"},\n\t{\"MIC1\", NULL, \"HV\"},\n\t{\"MIC1\", NULL, \"LV\"},\n\t{\"MIC1\", NULL, \"VREF\"},\n\t{\"MIC1\", NULL, \"VREF1\"},\n\t{\"MIC1\", NULL, \"BG_MBIAS\"},\n\t{\"MIC1\", NULL, \"MIC1 Input Buffer\"},\n\n\t{\"SPO\", NULL, \"LDO1\"},\n\t{\"SPO\", NULL, \"LDO2\"},\n\t{\"SPO\", NULL, \"HV\"},\n\t{\"SPO\", NULL, \"LV\"},\n\t{\"SPO\", NULL, \"VREF\"},\n\t{\"SPO\", NULL, \"VREF1\"},\n\t{\"SPO\", NULL, \"BG_MBIAS\"},\n\n\t{\"DMIC1\", NULL, \"DMIC1 Pin\"},\n\t{\"DMIC2\", NULL, \"DMIC2 Pin\"},\n\t{\"DMIC1\", NULL, \"DMIC Receiver\"},\n\t{\"DMIC2\", NULL, \"DMIC Receiver\"},\n\n\t{\"RECMIX\", \"Beep Switch\", \"Beep\"},\n\t{\"RECMIX\", \"Line1 Switch\", \"LINE1\"},\n\t{\"RECMIX\", \"Mic1 Switch\", \"MIC1\"},\n\n\t{\"ADC 0 Mux\", \"Dmic\", \"DMIC1\"},\n\t{\"ADC 0 Mux\", \"RECMIX\", \"RECMIX\"},\n\t{\"ADC 0 Mux\", \"Mic\", \"MIC1\"},\n\t{\"ADC 1 Mux\", \"Dmic\", \"DMIC2\"},\n\t{\"ADC 1 Mux\", \"RECMIX\", \"RECMIX\"},\n\t{\"ADC 1 Mux\", \"Mic\", \"MIC1\"},\n\n\t{\"ADC 0\", NULL, \"ADC 0 Mux\"},\n\t{\"ADC 1\", NULL, \"ADC 1 Mux\"},\n\n\t{\"AIF1TX\", NULL, \"ADC 0\"},\n\t{\"AIF2TX\", NULL, \"ADC 1\"},\n\n\t{\"DAC 0\", NULL, \"AIF1RX\"},\n\t{\"DAC 1\", NULL, \"AIF2RX\"},\n\n\t{\"Front\", \"DAC Switch\", \"DAC 0\"},\n\t{\"Front\", \"RECMIX Switch\", \"RECMIX\"},\n\n\t{\"Surround\", NULL, \"DAC 1\"},\n\n\t{\"SPK Mux\", \"Front\", \"Front\"},\n\t{\"SPK Mux\", \"Surround\", \"Surround\"},\n\n\t{\"HPO Mux\", \"Front\", \"Front\"},\n\t{\"HPO Mux\", \"Surround\", \"Surround\"},\n\n\t{\"SPO\", \"Switch\", \"SPK Mux\"},\n\t{\"HPO L\", \"Switch\", \"HPO Mux\"},\n\t{\"HPO R\", \"Switch\", \"HPO Mux\"},\n\t{\"HPO L\", NULL, \"HP Power\"},\n\t{\"HPO R\", NULL, \"HP Power\"},\n\n\t{\"SPOL\", NULL, \"SPO\"},\n\t{\"SPOR\", NULL, \"SPO\"},\n\t{\"HPO Pin\", NULL, \"HPO L\"},\n\t{\"HPO Pin\", NULL, \"HPO R\"},\n};\n\nstatic int rt298_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\tint d_len_code;\n\n\tswitch (params_rate(params)) {\n\t \n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample rate %d\\n\",\n\t\t\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\tswitch (rt298->sys_clk) {\n\tcase 12288000:\n\tcase 24576000:\n\t\tif (params_rate(params) != 48000) {\n\t\t\tdev_err(component->dev, \"Sys_clk is not matched (%d %d)\\n\",\n\t\t\t\t\tparams_rate(params), rt298->sys_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 11289600:\n\tcase 22579200:\n\t\tif (params_rate(params) != 44100) {\n\t\t\tdev_err(component->dev, \"Sys_clk is not matched (%d %d)\\n\",\n\t\t\t\t\tparams_rate(params), rt298->sys_clk);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (params_channels(params) <= 16) {\n\t\t \n\t\tval |= (params_channels(params) - 1);\n\t} else {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\td_len_code = 0;\n\tswitch (params_width(params)) {\n\t \n\tcase 16:\n\t\td_len_code = 0;\n\t\tval |= (0x1 << 4);\n\t\tbreak;\n\tcase 32:\n\t\td_len_code = 2;\n\t\tval |= (0x4 << 4);\n\t\tbreak;\n\tcase 20:\n\t\td_len_code = 1;\n\t\tval |= (0x2 << 4);\n\t\tbreak;\n\tcase 24:\n\t\td_len_code = 2;\n\t\tval |= (0x3 << 4);\n\t\tbreak;\n\tcase 8:\n\t\td_len_code = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component,\n\t\tRT298_I2S_CTRL1, 0x0018, d_len_code << 3);\n\tdev_dbg(component->dev, \"format val = 0x%x\\n\", val);\n\n\tsnd_soc_component_update_bits(component, RT298_DAC_FORMAT, 0x407f, val);\n\tsnd_soc_component_update_bits(component, RT298_ADC_FORMAT, 0x407f, val);\n\n\treturn 0;\n}\n\nstatic int rt298_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x800, 0x800);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x800, 0x0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x300, 0x0);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x300, 0x1 << 8);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x300, 0x2 << 8);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x300, 0x3 << 8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\t \n\tsnd_soc_component_update_bits(component, RT298_DAC_FORMAT, 0x8000, 0);\n\tsnd_soc_component_update_bits(component, RT298_ADC_FORMAT, 0x8000, 0);\n\n\treturn 0;\n}\n\nstatic int rt298_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s freq=%d\\n\", __func__, freq);\n\n\tif (RT298_SCLK_S_MCLK == clk_id) {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x0100, 0x0);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_PLL_CTRL1, 0x20, 0x20);\n\t} else {\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x0100, 0x0100);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_PLL_CTRL1, 0x20, 0x0);\n\t}\n\n\tswitch (freq) {\n\tcase 19200000:\n\t\tif (RT298_SCLK_S_MCLK == clk_id) {\n\t\t\tdev_err(component->dev, \"Should not use MCLK\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x40, 0x40);\n\t\tbreak;\n\tcase 24000000:\n\t\tif (RT298_SCLK_S_MCLK == clk_id) {\n\t\t\tdev_err(component->dev, \"Should not use MCLK\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x40, 0x0);\n\t\tbreak;\n\tcase 12288000:\n\tcase 11289600:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x8, 0x0);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_CLK_DIV, 0xfc1e, 0x0004);\n\t\tbreak;\n\tcase 24576000:\n\tcase 22579200:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL2, 0x8, 0x8);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_CLK_DIV, 0xfc1e, 0x5406);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported system clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trt298->sys_clk = freq;\n\trt298->clk_id = clk_id;\n\n\treturn 0;\n}\n\nstatic int rt298_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tdev_dbg(component->dev, \"%s ratio=%d\\n\", __func__, ratio);\n\tif (50 == ratio)\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x1000, 0x1000);\n\telse\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT298_I2S_CTRL1, 0x1000, 0x0);\n\n\n\treturn 0;\n}\n\nstatic int rt298_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (SND_SOC_BIAS_STANDBY ==\n\t\t\tsnd_soc_component_get_bias_level(component)) {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT298_SET_AUDIO_POWER, AC_PWRST_D0);\n\t\t\tsnd_soc_component_update_bits(component, 0x0d, 0x200, 0x200);\n\t\t\tsnd_soc_component_update_bits(component, 0x52, 0x80, 0x0);\n\t\t\tmdelay(20);\n\t\t\tsnd_soc_component_update_bits(component, 0x0d, 0x200, 0x0);\n\t\t\tsnd_soc_component_update_bits(component, 0x52, 0x80, 0x80);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_write(component,\n\t\t\tRT298_SET_AUDIO_POWER, AC_PWRST_D3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t rt298_irq(int irq, void *data)\n{\n\tstruct rt298_priv *rt298 = data;\n\tbool hp = false;\n\tbool mic = false;\n\tint ret, status = 0;\n\n\tret = rt298_jack_detect(rt298, &hp, &mic);\n\n\t \n\tregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x1, 0x1);\n\n\tif (ret == 0) {\n\t\tif (hp)\n\t\t\tstatus |= SND_JACK_HEADPHONE;\n\n\t\tif (mic)\n\t\t\tstatus |= SND_JACK_MICROPHONE;\n\n\t\tsnd_soc_jack_report(rt298->jack, status,\n\t\t\tSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\n\n\t\tpm_wakeup_event(&rt298->i2c->dev, 300);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rt298_probe(struct snd_soc_component *component)\n{\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\trt298->component = component;\n\tINIT_DELAYED_WORK(&rt298->jack_detect_work, rt298_jack_detect_work);\n\n\tif (rt298->i2c->irq)\n\t\tschedule_delayed_work(&rt298->jack_detect_work,\n\t\t\t\t      msecs_to_jiffies(1250));\n\treturn 0;\n}\n\nstatic void rt298_remove(struct snd_soc_component *component)\n{\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&rt298->jack_detect_work);\n\trt298->component = NULL;\n}\n\n#ifdef CONFIG_PM\nstatic int rt298_suspend(struct snd_soc_component *component)\n{\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\trt298->is_hp_in = -1;\n\tregcache_cache_only(rt298->regmap, true);\n\tregcache_mark_dirty(rt298->regmap);\n\n\treturn 0;\n}\n\nstatic int rt298_resume(struct snd_soc_component *component)\n{\n\tstruct rt298_priv *rt298 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt298->regmap, false);\n\trt298_index_sync(component);\n\tregcache_sync(rt298->regmap);\n\n\treturn 0;\n}\n#else\n#define rt298_suspend NULL\n#define rt298_resume NULL\n#endif\n\n#define RT298_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define RT298_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt298_aif_dai_ops = {\n\t.hw_params = rt298_hw_params,\n\t.set_fmt = rt298_set_dai_fmt,\n\t.set_sysclk = rt298_set_dai_sysclk,\n\t.set_bclk_ratio = rt298_set_bclk_ratio,\n};\n\nstatic struct snd_soc_dai_driver rt298_dai[] = {\n\t{\n\t\t.name = \"rt298-aif1\",\n\t\t.id = RT298_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT298_STEREO_RATES,\n\t\t\t.formats = RT298_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT298_STEREO_RATES,\n\t\t\t.formats = RT298_FORMATS,\n\t\t},\n\t\t.ops = &rt298_aif_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{\n\t\t.name = \"rt298-aif2\",\n\t\t.id = RT298_AIF2,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF2 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT298_STEREO_RATES,\n\t\t\t.formats = RT298_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT298_STEREO_RATES,\n\t\t\t.formats = RT298_FORMATS,\n\t\t},\n\t\t.ops = &rt298_aif_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt298 = {\n\t.probe\t\t\t= rt298_probe,\n\t.remove\t\t\t= rt298_remove,\n\t.suspend\t\t= rt298_suspend,\n\t.resume\t\t\t= rt298_resume,\n\t.set_bias_level\t\t= rt298_set_bias_level,\n\t.set_jack\t\t= rt298_mic_detect,\n\t.controls\t\t= rt298_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(rt298_snd_controls),\n\t.dapm_widgets\t\t= rt298_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(rt298_dapm_widgets),\n\t.dapm_routes\t\t= rt298_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(rt298_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt298_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.max_register = 0x02370100,\n\t.volatile_reg = rt298_volatile_register,\n\t.readable_reg = rt298_readable_register,\n\t.reg_write = rl6347a_hw_write,\n\t.reg_read = rl6347a_hw_read,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = rt298_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt298_reg),\n};\n\nstatic const struct i2c_device_id rt298_i2c_id[] = {\n\t{\"rt298\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rt298_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt298_acpi_match[] = {\n\t{ \"INT343A\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt298_acpi_match);\n#endif\n\nstatic const struct dmi_system_id force_combo_jack_table[] = {\n\t{\n\t\t.ident = \"Intel Broxton P\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corp\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Broxton P\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"Intel Gemini Lake\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corp\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Geminilake\")\n\t\t}\n\t},\n\t{\n\t\t.ident = \"Intel Kabylake R RVP\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corporation\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Kabylake Client platform\")\n\t\t}\n\t},\n\t{ }\n};\n\nstatic int rt298_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt298_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct rt298_priv *rt298;\n\tstruct device *dev = &i2c->dev;\n\tconst struct acpi_device_id *acpiid;\n\tint i, ret;\n\n\trt298 = devm_kzalloc(&i2c->dev,\tsizeof(*rt298),\n\t\t\t\tGFP_KERNEL);\n\tif (NULL == rt298)\n\t\treturn -ENOMEM;\n\n\trt298->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt298_regmap);\n\tif (IS_ERR(rt298->regmap)) {\n\t\tret = PTR_ERR(rt298->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt298->regmap,\n\t\tRT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &ret);\n\tif (ret != RT298_VENDOR_ID) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %#x is not rt298\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\trt298->index_cache = devm_kmemdup(&i2c->dev, rt298_index_def,\n\t\t\t\t\t  sizeof(rt298_index_def), GFP_KERNEL);\n\tif (!rt298->index_cache)\n\t\treturn -ENOMEM;\n\n\trt298->index_cache_size = INDEX_CACHE_SIZE;\n\trt298->i2c = i2c;\n\ti2c_set_clientdata(i2c, rt298);\n\n\t \n\tfor (i = 0; i < INDEX_CACHE_SIZE; i++)\n\t\tregmap_write(rt298->regmap, rt298->index_cache[i].reg,\n\t\t\t\trt298->index_cache[i].def);\n\tfor (i = 0; i < ARRAY_SIZE(rt298_reg); i++)\n\t\tregmap_write(rt298->regmap, rt298_reg[i].reg,\n\t\t\t\trt298_reg[i].def);\n\n\tif (pdata)\n\t\trt298->pdata = *pdata;\n\n\t \n\tacpiid = acpi_match_device(dev->driver->acpi_match_table, dev);\n\tif (acpiid && acpiid->driver_data) {\n\t\trt298->pdata = *(struct rt298_platform_data *)\n\t\t\t\tacpiid->driver_data;\n\t}\n\n\tif (dmi_check_system(force_combo_jack_table)) {\n\t\trt298->pdata.cbj_en = true;\n\t\trt298->pdata.gpio2_en = false;\n\t}\n\n\t \n\tregmap_update_bits(rt298->regmap, 0x04, 0x80, 0x80);\n\tregmap_update_bits(rt298->regmap, 0x1b, 0x860, 0x860);\n\t \n\tregmap_update_bits(rt298->regmap, 0x08, 0x20, 0x20);\n\n\tregmap_write(rt298->regmap, RT298_SET_AUDIO_POWER, AC_PWRST_D3);\n\n\tfor (i = 0; i < RT298_POWER_REG_LEN; i++)\n\t\tregmap_write(rt298->regmap,\n\t\t\tRT298_SET_POWER(rt298_support_power_controls[i]),\n\t\t\tAC_PWRST_D1);\n\n\tif (!rt298->pdata.cbj_en) {\n\t\tregmap_write(rt298->regmap, RT298_CBJ_CTRL2, 0x0000);\n\t\tregmap_write(rt298->regmap, RT298_MIC1_DET_CTRL, 0x0816);\n\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\t\tRT298_CBJ_CTRL1, 0xf000, 0xb000);\n\t} else {\n\t\tregmap_update_bits(rt298->regmap,\n\t\t\t\t\tRT298_CBJ_CTRL1, 0xf000, 0x5000);\n\t}\n\n\tmdelay(10);\n\n\tif (!rt298->pdata.gpio2_en)\n\t\tregmap_write(rt298->regmap, RT298_SET_DMIC2_DEFAULT, 0x40);\n\telse\n\t\tregmap_write(rt298->regmap, RT298_SET_DMIC2_DEFAULT, 0);\n\n\tmdelay(10);\n\n\tregmap_write(rt298->regmap, RT298_MISC_CTRL1, 0x0000);\n\tregmap_update_bits(rt298->regmap,\n\t\t\t\tRT298_WIND_FILTER_CTRL, 0x0082, 0x0082);\n\n\tregmap_write(rt298->regmap, RT298_UNSOLICITED_INLINE_CMD, 0x81);\n\tregmap_write(rt298->regmap, RT298_UNSOLICITED_HP_OUT, 0x82);\n\tregmap_write(rt298->regmap, RT298_UNSOLICITED_MIC1, 0x84);\n\tregmap_update_bits(rt298->regmap, RT298_IRQ_FLAG_CTRL, 0x2, 0x2);\n\n\trt298->is_hp_in = -1;\n\n\tif (rt298->i2c->irq) {\n\t\tret = request_threaded_irq(rt298->i2c->irq, NULL, rt298_irq,\n\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT, \"rt298\", rt298);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to reguest IRQ: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_rt298,\n\t\t\t\t     rt298_dai, ARRAY_SIZE(rt298_dai));\n\n\treturn ret;\n}\n\nstatic void rt298_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct rt298_priv *rt298 = i2c_get_clientdata(i2c);\n\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, rt298);\n}\n\n\nstatic struct i2c_driver rt298_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"rt298\",\n\t\t   .acpi_match_table = ACPI_PTR(rt298_acpi_match),\n\t\t   },\n\t.probe = rt298_i2c_probe,\n\t.remove = rt298_i2c_remove,\n\t.id_table = rt298_i2c_id,\n};\n\nmodule_i2c_driver(rt298_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT298 driver\");\nMODULE_AUTHOR(\"Bard Liao <bardliao@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}