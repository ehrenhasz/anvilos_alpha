{
  "module_name": "twl6040.c",
  "hash_id": "8597672ee2a3e8c855ccf942eec75664a43c328c778237e2bbea7a76512a41fd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/twl6040.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/mfd/twl6040.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"twl6040.h\"\n\nenum twl6040_dai_id {\n\tTWL6040_DAI_LEGACY = 0,\n\tTWL6040_DAI_UL,\n\tTWL6040_DAI_DL1,\n\tTWL6040_DAI_DL2,\n\tTWL6040_DAI_VIB,\n};\n\n#define TWL6040_RATES\t\tSNDRV_PCM_RATE_8000_96000\n#define TWL6040_FORMATS\t(SNDRV_PCM_FMTBIT_S32_LE)\n\n#define TWL6040_OUTHS_0dB 0x00\n#define TWL6040_OUTHS_M30dB 0x0F\n#define TWL6040_OUTHF_0dB 0x03\n#define TWL6040_OUTHF_M52dB 0x1D\n\n#define TWL6040_CACHEREGNUM\t(TWL6040_REG_STATUS + 1)\n\nstruct twl6040_jack_data {\n\tstruct snd_soc_jack *jack;\n\tstruct delayed_work work;\n\tint report;\n};\n\n \nstruct twl6040_data {\n\tint plug_irq;\n\tint codec_powered;\n\tint pll;\n\tint pll_power_mode;\n\tint hs_power_mode;\n\tint hs_power_mode_locked;\n\tbool dl1_unmuted;\n\tbool dl2_unmuted;\n\tu8 dl12_cache[TWL6040_REG_HFRCTL - TWL6040_REG_HSLCTL + 1];\n\tunsigned int clk_in;\n\tunsigned int sysclk;\n\tstruct twl6040_jack_data hs_jack;\n\tstruct snd_soc_component *component;\n\tstruct mutex mutex;\n};\n\n \nstatic const unsigned int lp_rates[] = {\n\t8000,\n\t11250,\n\t16000,\n\t22500,\n\t32000,\n\t44100,\n\t48000,\n\t88200,\n\t96000,\n};\n\nstatic const unsigned int hp_rates[] = {\n\t8000,\n\t16000,\n\t32000,\n\t48000,\n\t96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list sysclk_constraints[] = {\n\t{ .count = ARRAY_SIZE(lp_rates), .list = lp_rates, },\n\t{ .count = ARRAY_SIZE(hp_rates), .list = hp_rates, },\n};\n\n#define to_twl6040(component)\tdev_get_drvdata((component)->dev->parent)\n\nstatic unsigned int twl6040_read(struct snd_soc_component *component, unsigned int reg)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\tu8 value;\n\n\tif (reg >= TWL6040_CACHEREGNUM)\n\t\treturn -EIO;\n\n\tswitch (reg) {\n\tcase TWL6040_REG_HSLCTL:\n\tcase TWL6040_REG_HSRCTL:\n\tcase TWL6040_REG_EARCTL:\n\tcase TWL6040_REG_HFLCTL:\n\tcase TWL6040_REG_HFRCTL:\n\t\tvalue = priv->dl12_cache[reg - TWL6040_REG_HSLCTL];\n\t\tbreak;\n\tdefault:\n\t\tvalue = twl6040_reg_read(twl6040, reg);\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic bool twl6040_can_write_to_chip(struct snd_soc_component *component,\n\t\t\t\t  unsigned int reg)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (reg) {\n\tcase TWL6040_REG_HSLCTL:\n\tcase TWL6040_REG_HSRCTL:\n\tcase TWL6040_REG_EARCTL:\n\t\t \n\t\treturn priv->dl1_unmuted;\n\tcase TWL6040_REG_HFLCTL:\n\tcase TWL6040_REG_HFRCTL:\n\t\treturn priv->dl2_unmuted;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic inline void twl6040_update_dl12_cache(struct snd_soc_component *component,\n\t\t\t\t\t     u8 reg, u8 value)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (reg) {\n\tcase TWL6040_REG_HSLCTL:\n\tcase TWL6040_REG_HSRCTL:\n\tcase TWL6040_REG_EARCTL:\n\tcase TWL6040_REG_HFLCTL:\n\tcase TWL6040_REG_HFRCTL:\n\t\tpriv->dl12_cache[reg - TWL6040_REG_HSLCTL] = value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int twl6040_write(struct snd_soc_component *component,\n\t\t\tunsigned int reg, unsigned int value)\n{\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\n\tif (reg >= TWL6040_CACHEREGNUM)\n\t\treturn -EIO;\n\n\ttwl6040_update_dl12_cache(component, reg, value);\n\tif (twl6040_can_write_to_chip(component, reg))\n\t\treturn twl6040_reg_write(twl6040, reg, value);\n\telse\n\t\treturn 0;\n}\n\nstatic void twl6040_init_chip(struct snd_soc_component *component)\n{\n\ttwl6040_read(component, TWL6040_REG_TRIM1);\n\ttwl6040_read(component, TWL6040_REG_TRIM2);\n\ttwl6040_read(component, TWL6040_REG_TRIM3);\n\ttwl6040_read(component, TWL6040_REG_HSOTRIM);\n\ttwl6040_read(component, TWL6040_REG_HFOTRIM);\n\n\t \n\t \n\ttwl6040_write(component, TWL6040_REG_MICLCTL, 0x18);\n\ttwl6040_write(component, TWL6040_REG_MICRCTL, 0x18);\n\n\t \n\ttwl6040_write(component, TWL6040_REG_HSGAIN, 0xff);\n\ttwl6040_write(component, TWL6040_REG_EARCTL, 0x1e);\n\ttwl6040_write(component, TWL6040_REG_HFLGAIN, 0x1d);\n\ttwl6040_write(component, TWL6040_REG_HFRGAIN, 0x1d);\n\ttwl6040_write(component, TWL6040_REG_LINEGAIN, 0);\n}\n\n \nstatic int headset_power_mode(struct snd_soc_component *component, int high_perf)\n{\n\tint hslctl, hsrctl;\n\tint mask = TWL6040_HSDRVMODE | TWL6040_HSDACMODE;\n\n\thslctl = twl6040_read(component, TWL6040_REG_HSLCTL);\n\thsrctl = twl6040_read(component, TWL6040_REG_HSRCTL);\n\n\tif (high_perf) {\n\t\thslctl &= ~mask;\n\t\thsrctl &= ~mask;\n\t} else {\n\t\thslctl |= mask;\n\t\thsrctl |= mask;\n\t}\n\n\ttwl6040_write(component, TWL6040_REG_HSLCTL, hslctl);\n\ttwl6040_write(component, TWL6040_REG_HSRCTL, hsrctl);\n\n\treturn 0;\n}\n\nstatic int twl6040_hs_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu8 hslctl, hsrctl;\n\n\t \n\thslctl = twl6040_read(component, TWL6040_REG_HSLCTL);\n\thsrctl = twl6040_read(component, TWL6040_REG_HSRCTL);\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\thslctl |= TWL6040_HSDACENA;\n\t\thsrctl |= TWL6040_HSDACENA;\n\t} else {\n\t\thslctl &= ~TWL6040_HSDACENA;\n\t\thsrctl &= ~TWL6040_HSDACENA;\n\t}\n\ttwl6040_write(component, TWL6040_REG_HSLCTL, hslctl);\n\ttwl6040_write(component, TWL6040_REG_HSRCTL, hsrctl);\n\n\tmsleep(1);\n\treturn 0;\n}\n\nstatic int twl6040_ep_drv_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\t \n\t\tpriv->hs_power_mode_locked = 1;\n\t\tret = headset_power_mode(component, 1);\n\t} else {\n\t\tpriv->hs_power_mode_locked = 0;\n\t\tret = headset_power_mode(component, priv->hs_power_mode);\n\t}\n\n\tmsleep(1);\n\n\treturn ret;\n}\n\nstatic void twl6040_hs_jack_report(struct snd_soc_component *component,\n\t\t\t\t   struct snd_soc_jack *jack, int report)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint status;\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tstatus = twl6040_read(component, TWL6040_REG_STATUS);\n\tif (status & TWL6040_PLUGCOMP)\n\t\tsnd_soc_jack_report(jack, report, report);\n\telse\n\t\tsnd_soc_jack_report(jack, 0, report);\n\n\tmutex_unlock(&priv->mutex);\n}\n\nvoid twl6040_hs_jack_detect(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_jack *jack, int report)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct twl6040_jack_data *hs_jack = &priv->hs_jack;\n\n\ths_jack->jack = jack;\n\ths_jack->report = report;\n\n\ttwl6040_hs_jack_report(component, hs_jack->jack, hs_jack->report);\n}\nEXPORT_SYMBOL_GPL(twl6040_hs_jack_detect);\n\nstatic void twl6040_accessory_work(struct work_struct *work)\n{\n\tstruct twl6040_data *priv = container_of(work,\n\t\t\t\t\tstruct twl6040_data, hs_jack.work.work);\n\tstruct snd_soc_component *component = priv->component;\n\tstruct twl6040_jack_data *hs_jack = &priv->hs_jack;\n\n\ttwl6040_hs_jack_report(component, hs_jack->jack, hs_jack->report);\n}\n\n \nstatic irqreturn_t twl6040_audio_handler(int irq, void *data)\n{\n\tstruct snd_soc_component *component = data;\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &priv->hs_jack.work, msecs_to_jiffies(200));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int twl6040_soc_dapm_put_vibra_enum(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int val;\n\n\t \n\tval = twl6040_read(component, e->reg);\n\tif (val & TWL6040_VIBENA && !(val & TWL6040_VIBSEL))\n\t\treturn -EBUSY;\n\n\treturn snd_soc_dapm_put_enum_double(kcontrol, ucontrol);\n}\n\n \nstatic DECLARE_TLV_DB_SCALE(mic_preamp_tlv, -600, 600, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(mic_amp_tlv, 600, 600, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(afm_amp_tlv, -1800, 600, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(hs_tlv, -3000, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(hf_tlv, -5200, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(ep_tlv, -2400, 200, 0);\n\n \nstatic const char *twl6040_amicl_texts[] =\n\t{\"Headset Mic\", \"Main Mic\", \"Aux/FM Left\", \"Off\"};\n\n \nstatic const char *twl6040_amicr_texts[] =\n\t{\"Headset Mic\", \"Sub Mic\", \"Aux/FM Right\", \"Off\"};\n\nstatic const struct soc_enum twl6040_enum[] = {\n\tSOC_ENUM_SINGLE(TWL6040_REG_MICLCTL, 3,\n\t\t\tARRAY_SIZE(twl6040_amicl_texts), twl6040_amicl_texts),\n\tSOC_ENUM_SINGLE(TWL6040_REG_MICRCTL, 3,\n\t\t\tARRAY_SIZE(twl6040_amicr_texts), twl6040_amicr_texts),\n};\n\nstatic const char *twl6040_hs_texts[] = {\n\t\"Off\", \"HS DAC\", \"Line-In amp\"\n};\n\nstatic const struct soc_enum twl6040_hs_enum[] = {\n\tSOC_ENUM_SINGLE(TWL6040_REG_HSLCTL, 5, ARRAY_SIZE(twl6040_hs_texts),\n\t\t\ttwl6040_hs_texts),\n\tSOC_ENUM_SINGLE(TWL6040_REG_HSRCTL, 5, ARRAY_SIZE(twl6040_hs_texts),\n\t\t\ttwl6040_hs_texts),\n};\n\nstatic const char *twl6040_hf_texts[] = {\n\t\"Off\", \"HF DAC\", \"Line-In amp\"\n};\n\nstatic const struct soc_enum twl6040_hf_enum[] = {\n\tSOC_ENUM_SINGLE(TWL6040_REG_HFLCTL, 2, ARRAY_SIZE(twl6040_hf_texts),\n\t\t\ttwl6040_hf_texts),\n\tSOC_ENUM_SINGLE(TWL6040_REG_HFRCTL, 2, ARRAY_SIZE(twl6040_hf_texts),\n\t\t\ttwl6040_hf_texts),\n};\n\nstatic const char *twl6040_vibrapath_texts[] = {\n\t\"Input FF\", \"Audio PDM\"\n};\n\nstatic const struct soc_enum twl6040_vibra_enum[] = {\n\tSOC_ENUM_SINGLE(TWL6040_REG_VIBCTLL, 1,\n\t\t\tARRAY_SIZE(twl6040_vibrapath_texts),\n\t\t\ttwl6040_vibrapath_texts),\n\tSOC_ENUM_SINGLE(TWL6040_REG_VIBCTLR, 1,\n\t\t\tARRAY_SIZE(twl6040_vibrapath_texts),\n\t\t\ttwl6040_vibrapath_texts),\n};\n\nstatic const struct snd_kcontrol_new amicl_control =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_enum[0]);\n\nstatic const struct snd_kcontrol_new amicr_control =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_enum[1]);\n\n \nstatic const struct snd_kcontrol_new hsl_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_hs_enum[0]);\n\nstatic const struct snd_kcontrol_new hsr_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_hs_enum[1]);\n\n \nstatic const struct snd_kcontrol_new hfl_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_hf_enum[0]);\n\nstatic const struct snd_kcontrol_new hfr_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", twl6040_hf_enum[1]);\n\nstatic const struct snd_kcontrol_new ep_path_enable_control =\n\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\n\nstatic const struct snd_kcontrol_new auxl_switch_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL6040_REG_HFLCTL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new auxr_switch_control =\n\tSOC_DAPM_SINGLE(\"Switch\", TWL6040_REG_HFRCTL, 6, 1, 0);\n\n \nstatic const struct snd_kcontrol_new vibral_mux_controls =\n\tSOC_DAPM_ENUM_EXT(\"Route\", twl6040_vibra_enum[0],\n\t\tsnd_soc_dapm_get_enum_double,\n\t\ttwl6040_soc_dapm_put_vibra_enum);\n\nstatic const struct snd_kcontrol_new vibrar_mux_controls =\n\tSOC_DAPM_ENUM_EXT(\"Route\", twl6040_vibra_enum[1],\n\t\tsnd_soc_dapm_get_enum_double,\n\t\ttwl6040_soc_dapm_put_vibra_enum);\n\n \nstatic const char *twl6040_power_mode_texts[] = {\n\t\"Low-Power\", \"High-Performance\",\n};\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(twl6040_power_mode_enum,\n\t\t\t\ttwl6040_power_mode_texts);\n\nstatic int twl6040_headset_power_get_enum(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = priv->hs_power_mode;\n\n\treturn 0;\n}\n\nstatic int twl6040_headset_power_put_enum(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint high_perf = ucontrol->value.enumerated.item[0];\n\tint ret = 0;\n\n\tif (!priv->hs_power_mode_locked)\n\t\tret = headset_power_mode(component, high_perf);\n\n\tif (!ret)\n\t\tpriv->hs_power_mode = high_perf;\n\n\treturn ret;\n}\n\nstatic int twl6040_pll_get_enum(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = priv->pll_power_mode;\n\n\treturn 0;\n}\n\nstatic int twl6040_pll_put_enum(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tpriv->pll_power_mode = ucontrol->value.enumerated.item[0];\n\n\treturn 0;\n}\n\nint twl6040_get_dl1_gain(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tif (snd_soc_dapm_get_pin_status(dapm, \"EP\"))\n\t\treturn -1;  \n\n\tif (snd_soc_dapm_get_pin_status(dapm, \"HSOR\") ||\n\t\tsnd_soc_dapm_get_pin_status(dapm, \"HSOL\")) {\n\n\t\tu8 val = twl6040_read(component, TWL6040_REG_HSLCTL);\n\t\tif (val & TWL6040_HSDACMODE)\n\t\t\t \n\t\t\treturn -8;  \n\t\telse\n\t\t\t \n\t\t\treturn -1;  \n\t}\n\treturn 0;  \n}\nEXPORT_SYMBOL_GPL(twl6040_get_dl1_gain);\n\nint twl6040_get_clk_id(struct snd_soc_component *component)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\treturn priv->pll_power_mode;\n}\nEXPORT_SYMBOL_GPL(twl6040_get_clk_id);\n\nint twl6040_get_trim_value(struct snd_soc_component *component, enum twl6040_trim trim)\n{\n\tif (unlikely(trim >= TWL6040_TRIM_INVAL))\n\t\treturn -EINVAL;\n\n\treturn twl6040_read(component, TWL6040_REG_TRIM1 + trim);\n}\nEXPORT_SYMBOL_GPL(twl6040_get_trim_value);\n\nint twl6040_get_hs_step_size(struct snd_soc_component *component)\n{\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\n\tif (twl6040_get_revid(twl6040) < TWL6040_REV_ES1_3)\n\t\t \n\t\treturn 2;\n\telse\n\t\t \n\t\treturn 1;\n}\nEXPORT_SYMBOL_GPL(twl6040_get_hs_step_size);\n\nstatic const struct snd_kcontrol_new twl6040_snd_controls[] = {\n\t \n\tSOC_DOUBLE_TLV(\"Capture Preamplifier Volume\",\n\t\tTWL6040_REG_MICGAIN, 6, 7, 1, 1, mic_preamp_tlv),\n\tSOC_DOUBLE_TLV(\"Capture Volume\",\n\t\tTWL6040_REG_MICGAIN, 0, 3, 4, 0, mic_amp_tlv),\n\n\t \n\tSOC_DOUBLE_TLV(\"Aux FM Volume\",\n\t\tTWL6040_REG_LINEGAIN, 0, 3, 7, 0, afm_amp_tlv),\n\n\t \n\tSOC_DOUBLE_TLV(\"Headset Playback Volume\",\n\t\tTWL6040_REG_HSGAIN, 0, 4, 0xF, 1, hs_tlv),\n\tSOC_DOUBLE_R_TLV(\"Handsfree Playback Volume\",\n\t\tTWL6040_REG_HFLGAIN, TWL6040_REG_HFRGAIN, 0, 0x1D, 1, hf_tlv),\n\tSOC_SINGLE_TLV(\"Earphone Playback Volume\",\n\t\tTWL6040_REG_EARCTL, 1, 0xF, 1, ep_tlv),\n\n\tSOC_ENUM_EXT(\"Headset Power Mode\", twl6040_power_mode_enum,\n\t\ttwl6040_headset_power_get_enum,\n\t\ttwl6040_headset_power_put_enum),\n\n\t \n\tSOC_SINGLE(\"Headset Mono to Stereo Playback Switch\",\n\t\tTWL6040_REG_HSRCTL, 7, 1, 0),\n\n\t \n\tSOC_SINGLE(\"Handsfree Mono to Stereo Playback Switch\",\n\t\tTWL6040_REG_HFRCTL, 5, 1, 0),\n\n\tSOC_ENUM_EXT(\"PLL Selection\", twl6040_power_mode_enum,\n\t\ttwl6040_pll_get_enum, twl6040_pll_put_enum),\n};\n\nstatic const struct snd_soc_dapm_widget twl6040_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"MAINMIC\"),\n\tSND_SOC_DAPM_INPUT(\"HSMIC\"),\n\tSND_SOC_DAPM_INPUT(\"SUBMIC\"),\n\tSND_SOC_DAPM_INPUT(\"AFML\"),\n\tSND_SOC_DAPM_INPUT(\"AFMR\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HSOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSOR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HFL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HFR\"),\n\tSND_SOC_DAPM_OUTPUT(\"EP\"),\n\tSND_SOC_DAPM_OUTPUT(\"AUXL\"),\n\tSND_SOC_DAPM_OUTPUT(\"AUXR\"),\n\tSND_SOC_DAPM_OUTPUT(\"VIBRAL\"),\n\tSND_SOC_DAPM_OUTPUT(\"VIBRAR\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Analog Left Capture Route\",\n\t\t\tSND_SOC_NOPM, 0, 0, &amicl_control),\n\tSND_SOC_DAPM_MUX(\"Analog Right Capture Route\",\n\t\t\tSND_SOC_NOPM, 0, 0, &amicr_control),\n\n\t \n\tSND_SOC_DAPM_PGA(\"MicAmpL\",\n\t\t\tTWL6040_REG_MICLCTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"MicAmpR\",\n\t\t\tTWL6040_REG_MICRCTL, 0, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA(\"AFMAmpL\",\n\t\t\tTWL6040_REG_MICLCTL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"AFMAmpR\",\n\t\t\tTWL6040_REG_MICRCTL, 1, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC Left\", NULL, TWL6040_REG_MICLCTL, 2, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Right\", NULL, TWL6040_REG_MICRCTL, 2, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Headset Mic Bias\",\n\t\t\t    TWL6040_REG_AMICBCTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Main Mic Bias\",\n\t\t\t    TWL6040_REG_AMICBCTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Digital Mic1 Bias\",\n\t\t\t    TWL6040_REG_DMICBCTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Digital Mic2 Bias\",\n\t\t\t    TWL6040_REG_DMICBCTL, 4, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_DAC(\"HSDAC Left\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"HSDAC Right\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"HFDAC Left\", NULL, TWL6040_REG_HFLCTL, 0, 0),\n\tSND_SOC_DAPM_DAC(\"HFDAC Right\", NULL, TWL6040_REG_HFRCTL, 0, 0),\n\t \n\tSND_SOC_DAPM_DAC(\"VIBRA DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"Handsfree Left Playback\",\n\t\t\tSND_SOC_NOPM, 0, 0, &hfl_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Handsfree Right Playback\",\n\t\t\tSND_SOC_NOPM, 0, 0, &hfr_mux_controls),\n\t \n\tSND_SOC_DAPM_MUX(\"Headset Left Playback\",\n\t\t\tSND_SOC_NOPM, 0, 0, &hsl_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Headset Right Playback\",\n\t\t\tSND_SOC_NOPM, 0, 0, &hsr_mux_controls),\n\n\tSND_SOC_DAPM_MUX(\"Vibra Left Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&vibral_mux_controls),\n\tSND_SOC_DAPM_MUX(\"Vibra Right Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&vibrar_mux_controls),\n\n\tSND_SOC_DAPM_SWITCH(\"Earphone Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&ep_path_enable_control),\n\tSND_SOC_DAPM_SWITCH(\"AUXL Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&auxl_switch_control),\n\tSND_SOC_DAPM_SWITCH(\"AUXR Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t&auxr_switch_control),\n\n\t \n\tSND_SOC_DAPM_OUT_DRV(\"HF Left Driver\",\n\t\t\tTWL6040_REG_HFLCTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"HF Right Driver\",\n\t\t\tTWL6040_REG_HFRCTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"HS Left Driver\",\n\t\t\tTWL6040_REG_HSLCTL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"HS Right Driver\",\n\t\t\tTWL6040_REG_HSRCTL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV_E(\"Earphone Driver\",\n\t\t\tTWL6040_REG_EARCTL, 0, 0, NULL, 0,\n\t\t\ttwl6040_ep_drv_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUT_DRV(\"Vibra Left Driver\",\n\t\t\tTWL6040_REG_VIBCTLL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Vibra Right Driver\",\n\t\t\tTWL6040_REG_VIBCTLR, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Vibra Left Control\", TWL6040_REG_VIBCTLL, 2, 0,\n\t\t\t    NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Vibra Right Control\", TWL6040_REG_VIBCTLR, 2, 0,\n\t\t\t    NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"HSDAC Power\", 1, SND_SOC_NOPM, 0, 0,\n\t\t\t      twl6040_hs_dac_event,\n\t\t\t      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_PGA(\"HF Left PGA\",\n\t\t\tTWL6040_REG_HFLCTL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HF Right PGA\",\n\t\t\tTWL6040_REG_HFRCTL, 1, 0, NULL, 0),\n\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t \n\t{\"HSDAC Left\", NULL, \"Legacy Playback\"},\n\t{\"HSDAC Left\", NULL, \"Headset Playback\"},\n\t{\"HSDAC Right\", NULL, \"Legacy Playback\"},\n\t{\"HSDAC Right\", NULL, \"Headset Playback\"},\n\n\t{\"HFDAC Left\", NULL, \"Legacy Playback\"},\n\t{\"HFDAC Left\", NULL, \"Handsfree Playback\"},\n\t{\"HFDAC Right\", NULL, \"Legacy Playback\"},\n\t{\"HFDAC Right\", NULL, \"Handsfree Playback\"},\n\n\t{\"VIBRA DAC\", NULL, \"Legacy Playback\"},\n\t{\"VIBRA DAC\", NULL, \"Vibra Playback\"},\n\n\t \n\t{\"Legacy Capture\" , NULL, \"ADC Left\"},\n\t{\"Capture\", NULL, \"ADC Left\"},\n\t{\"Legacy Capture\", NULL, \"ADC Right\"},\n\t{\"Capture\" , NULL, \"ADC Right\"},\n\n\t \n\t{\"Analog Left Capture Route\", \"Headset Mic\", \"HSMIC\"},\n\t{\"Analog Left Capture Route\", \"Main Mic\", \"MAINMIC\"},\n\t{\"Analog Left Capture Route\", \"Aux/FM Left\", \"AFML\"},\n\n\t{\"Analog Right Capture Route\", \"Headset Mic\", \"HSMIC\"},\n\t{\"Analog Right Capture Route\", \"Sub Mic\", \"SUBMIC\"},\n\t{\"Analog Right Capture Route\", \"Aux/FM Right\", \"AFMR\"},\n\n\t{\"MicAmpL\", NULL, \"Analog Left Capture Route\"},\n\t{\"MicAmpR\", NULL, \"Analog Right Capture Route\"},\n\n\t{\"ADC Left\", NULL, \"MicAmpL\"},\n\t{\"ADC Right\", NULL, \"MicAmpR\"},\n\n\t \n\t{\"AFMAmpL\", NULL, \"AFML\"},\n\t{\"AFMAmpR\", NULL, \"AFMR\"},\n\n\t{\"HSDAC Left\", NULL, \"HSDAC Power\"},\n\t{\"HSDAC Right\", NULL, \"HSDAC Power\"},\n\n\t{\"Headset Left Playback\", \"HS DAC\", \"HSDAC Left\"},\n\t{\"Headset Left Playback\", \"Line-In amp\", \"AFMAmpL\"},\n\n\t{\"Headset Right Playback\", \"HS DAC\", \"HSDAC Right\"},\n\t{\"Headset Right Playback\", \"Line-In amp\", \"AFMAmpR\"},\n\n\t{\"HS Left Driver\", NULL, \"Headset Left Playback\"},\n\t{\"HS Right Driver\", NULL, \"Headset Right Playback\"},\n\n\t{\"HSOL\", NULL, \"HS Left Driver\"},\n\t{\"HSOR\", NULL, \"HS Right Driver\"},\n\n\t \n\t{\"Earphone Playback\", \"Switch\", \"HSDAC Left\"},\n\t{\"Earphone Driver\", NULL, \"Earphone Playback\"},\n\t{\"EP\", NULL, \"Earphone Driver\"},\n\n\t{\"Handsfree Left Playback\", \"HF DAC\", \"HFDAC Left\"},\n\t{\"Handsfree Left Playback\", \"Line-In amp\", \"AFMAmpL\"},\n\n\t{\"Handsfree Right Playback\", \"HF DAC\", \"HFDAC Right\"},\n\t{\"Handsfree Right Playback\", \"Line-In amp\", \"AFMAmpR\"},\n\n\t{\"HF Left PGA\", NULL, \"Handsfree Left Playback\"},\n\t{\"HF Right PGA\", NULL, \"Handsfree Right Playback\"},\n\n\t{\"HF Left Driver\", NULL, \"HF Left PGA\"},\n\t{\"HF Right Driver\", NULL, \"HF Right PGA\"},\n\n\t{\"HFL\", NULL, \"HF Left Driver\"},\n\t{\"HFR\", NULL, \"HF Right Driver\"},\n\n\t{\"AUXL Playback\", \"Switch\", \"HF Left PGA\"},\n\t{\"AUXR Playback\", \"Switch\", \"HF Right PGA\"},\n\n\t{\"AUXL\", NULL, \"AUXL Playback\"},\n\t{\"AUXR\", NULL, \"AUXR Playback\"},\n\n\t \n\t{\"Vibra Left Playback\", \"Audio PDM\", \"VIBRA DAC\"},\n\t{\"Vibra Right Playback\", \"Audio PDM\", \"VIBRA DAC\"},\n\n\t{\"Vibra Left Driver\", NULL, \"Vibra Left Playback\"},\n\t{\"Vibra Right Driver\", NULL, \"Vibra Right Playback\"},\n\t{\"Vibra Left Driver\", NULL, \"Vibra Left Control\"},\n\t{\"Vibra Right Driver\", NULL, \"Vibra Right Control\"},\n\n\t{\"VIBRAL\", NULL, \"Vibra Left Driver\"},\n\t{\"VIBRAR\", NULL, \"Vibra Right Driver\"},\n};\n\nstatic int twl6040_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (priv->codec_powered) {\n\t\t\t \n\t\t\tret = twl6040_set_pll(twl6040, TWL6040_SYSCLK_SEL_LPPLL,\n\t\t\t\t\t      32768, 19200000);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = twl6040_power(twl6040, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tpriv->codec_powered = 1;\n\n\t\t \n\t\ttwl6040_write(component, TWL6040_REG_GPOCTL, 0x02);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (!priv->codec_powered)\n\t\t\tbreak;\n\n\t\ttwl6040_power(twl6040, 0);\n\t\tpriv->codec_powered = 0;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int twl6040_startup(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t&sysclk_constraints[priv->pll_power_mode]);\n\n\treturn 0;\n}\n\nstatic int twl6040_hw_params(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint rate;\n\n\trate = params_rate(params);\n\tswitch (rate) {\n\tcase 11250:\n\tcase 22500:\n\tcase 44100:\n\tcase 88200:\n\t\t \n\t\tif (unlikely(priv->pll == TWL6040_SYSCLK_SEL_HPPLL)) {\n\t\t\tdev_err(component->dev, \"HPPLL does not support rate %d\\n\",\n\t\t\t\trate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->sysclk = 17640000;\n\t\tbreak;\n\tcase 8000:\n\tcase 16000:\n\tcase 32000:\n\tcase 48000:\n\tcase 96000:\n\t\tpriv->sysclk = 19200000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported rate %d\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int twl6040_prepare(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (!priv->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"no mclk configured, call set_sysclk() on init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = twl6040_set_pll(twl6040, priv->pll, priv->clk_in, priv->sysclk);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Can not set PLL (%d)\\n\", ret);\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int twl6040_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase TWL6040_SYSCLK_SEL_LPPLL:\n\tcase TWL6040_SYSCLK_SEL_HPPLL:\n\t\tpriv->pll = clk_id;\n\t\tpriv->clk_in = freq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unknown clk_id %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void twl6040_mute_path(struct snd_soc_component *component, enum twl6040_dai_id id,\n\t\t\t     int mute)\n{\n\tstruct twl6040 *twl6040 = to_twl6040(component);\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\tint hslctl, hsrctl, earctl;\n\tint hflctl, hfrctl;\n\n\tswitch (id) {\n\tcase TWL6040_DAI_DL1:\n\t\thslctl = twl6040_read(component, TWL6040_REG_HSLCTL);\n\t\thsrctl = twl6040_read(component, TWL6040_REG_HSRCTL);\n\t\tearctl = twl6040_read(component, TWL6040_REG_EARCTL);\n\n\t\tif (mute) {\n\t\t\t \n\t\t\tearctl &= ~0x01;\n\t\t\thslctl &= ~(TWL6040_HSDRVENA | TWL6040_HSDACENA);\n\t\t\thsrctl &= ~(TWL6040_HSDRVENA | TWL6040_HSDACENA);\n\n\t\t}\n\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_EARCTL, earctl);\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HSLCTL, hslctl);\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HSRCTL, hsrctl);\n\t\tpriv->dl1_unmuted = !mute;\n\t\tbreak;\n\tcase TWL6040_DAI_DL2:\n\t\thflctl = twl6040_read(component, TWL6040_REG_HFLCTL);\n\t\thfrctl = twl6040_read(component, TWL6040_REG_HFRCTL);\n\n\t\tif (mute) {\n\t\t\t \n\t\t\thflctl &= ~(TWL6040_HFDACENA | TWL6040_HFPGAENA |\n\t\t\t\t    TWL6040_HFDRVENA | TWL6040_HFSWENA);\n\t\t\thfrctl &= ~(TWL6040_HFDACENA | TWL6040_HFPGAENA |\n\t\t\t\t    TWL6040_HFDRVENA | TWL6040_HFSWENA);\n\t\t}\n\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HFLCTL, hflctl);\n\t\ttwl6040_reg_write(twl6040, TWL6040_REG_HFRCTL, hfrctl);\n\t\tpriv->dl2_unmuted = !mute;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int twl6040_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tswitch (dai->id) {\n\tcase TWL6040_DAI_LEGACY:\n\t\ttwl6040_mute_path(dai->component, TWL6040_DAI_DL1, mute);\n\t\ttwl6040_mute_path(dai->component, TWL6040_DAI_DL2, mute);\n\t\tbreak;\n\tcase TWL6040_DAI_DL1:\n\tcase TWL6040_DAI_DL2:\n\t\ttwl6040_mute_path(dai->component, dai->id, mute);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops twl6040_dai_ops = {\n\t.startup\t= twl6040_startup,\n\t.hw_params\t= twl6040_hw_params,\n\t.prepare\t= twl6040_prepare,\n\t.set_sysclk\t= twl6040_set_dai_sysclk,\n\t.mute_stream\t= twl6040_mute_stream,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver twl6040_dai[] = {\n{\n\t.name = \"twl6040-legacy\",\n\t.id = TWL6040_DAI_LEGACY,\n\t.playback = {\n\t\t.stream_name = \"Legacy Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 5,\n\t\t.rates = TWL6040_RATES,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Legacy Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = TWL6040_RATES,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.ops = &twl6040_dai_ops,\n},\n{\n\t.name = \"twl6040-ul\",\n\t.id = TWL6040_DAI_UL,\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = TWL6040_RATES,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.ops = &twl6040_dai_ops,\n},\n{\n\t.name = \"twl6040-dl1\",\n\t.id = TWL6040_DAI_DL1,\n\t.playback = {\n\t\t.stream_name = \"Headset Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = TWL6040_RATES,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.ops = &twl6040_dai_ops,\n},\n{\n\t.name = \"twl6040-dl2\",\n\t.id = TWL6040_DAI_DL2,\n\t.playback = {\n\t\t.stream_name = \"Handsfree Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = TWL6040_RATES,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.ops = &twl6040_dai_ops,\n},\n{\n\t.name = \"twl6040-vib\",\n\t.id = TWL6040_DAI_VIB,\n\t.playback = {\n\t\t.stream_name = \"Vibra Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.formats = TWL6040_FORMATS,\n\t},\n\t.ops = &twl6040_dai_ops,\n},\n};\n\nstatic int twl6040_probe(struct snd_soc_component *component)\n{\n\tstruct twl6040_data *priv;\n\tstruct platform_device *pdev = to_platform_device(component->dev);\n\tint ret = 0;\n\n\tpriv = devm_kzalloc(component->dev, sizeof(*priv), GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_component_set_drvdata(component, priv);\n\n\tpriv->component = component;\n\n\tpriv->plug_irq = platform_get_irq(pdev, 0);\n\tif (priv->plug_irq < 0)\n\t\treturn priv->plug_irq;\n\n\tINIT_DELAYED_WORK(&priv->hs_jack.work, twl6040_accessory_work);\n\n\tmutex_init(&priv->mutex);\n\n\tret = request_threaded_irq(priv->plug_irq, NULL,\n\t\t\t\t\ttwl6040_audio_handler,\n\t\t\t\t\tIRQF_NO_SUSPEND | IRQF_ONESHOT,\n\t\t\t\t\t\"twl6040_irq_plug\", component);\n\tif (ret) {\n\t\tdev_err(component->dev, \"PLUG IRQ request failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\ttwl6040_init_chip(component);\n\n\treturn 0;\n}\n\nstatic void twl6040_remove(struct snd_soc_component *component)\n{\n\tstruct twl6040_data *priv = snd_soc_component_get_drvdata(component);\n\n\tfree_irq(priv->plug_irq, component);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_twl6040 = {\n\t.probe\t\t\t= twl6040_probe,\n\t.remove\t\t\t= twl6040_remove,\n\t.read\t\t\t= twl6040_read,\n\t.write\t\t\t= twl6040_write,\n\t.set_bias_level\t\t= twl6040_set_bias_level,\n\t.controls\t\t= twl6040_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(twl6040_snd_controls),\n\t.dapm_widgets\t\t= twl6040_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(twl6040_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int twl6040_codec_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &soc_component_dev_twl6040,\n\t\t\t\t      twl6040_dai, ARRAY_SIZE(twl6040_dai));\n}\n\nstatic struct platform_driver twl6040_codec_driver = {\n\t.driver = {\n\t\t.name = \"twl6040-codec\",\n\t},\n\t.probe = twl6040_codec_probe,\n};\n\nmodule_platform_driver(twl6040_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC TWL6040 codec driver\");\nMODULE_AUTHOR(\"Misael Lopez Cruz\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}