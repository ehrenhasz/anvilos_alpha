{
  "module_name": "max98927.c",
  "hash_id": "3d5d7c196609bf52684ca9ef3e6745c47cbeb5a329636405fc635f248145db43",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98927.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_gpio.h>\n#include <sound/tlv.h>\n#include \"max98927.h\"\n\nstatic struct reg_default max98927_reg[] = {\n\t{MAX98927_R0001_INT_RAW1,  0x00},\n\t{MAX98927_R0002_INT_RAW2,  0x00},\n\t{MAX98927_R0003_INT_RAW3,  0x00},\n\t{MAX98927_R0004_INT_STATE1,  0x00},\n\t{MAX98927_R0005_INT_STATE2,  0x00},\n\t{MAX98927_R0006_INT_STATE3,  0x00},\n\t{MAX98927_R0007_INT_FLAG1,  0x00},\n\t{MAX98927_R0008_INT_FLAG2,  0x00},\n\t{MAX98927_R0009_INT_FLAG3,  0x00},\n\t{MAX98927_R000A_INT_EN1,  0x00},\n\t{MAX98927_R000B_INT_EN2,  0x00},\n\t{MAX98927_R000C_INT_EN3,  0x00},\n\t{MAX98927_R000D_INT_FLAG_CLR1,  0x00},\n\t{MAX98927_R000E_INT_FLAG_CLR2,  0x00},\n\t{MAX98927_R000F_INT_FLAG_CLR3,  0x00},\n\t{MAX98927_R0010_IRQ_CTRL,  0x00},\n\t{MAX98927_R0011_CLK_MON,  0x00},\n\t{MAX98927_R0012_WDOG_CTRL,  0x00},\n\t{MAX98927_R0013_WDOG_RST,  0x00},\n\t{MAX98927_R0014_MEAS_ADC_THERM_WARN_THRESH,  0x75},\n\t{MAX98927_R0015_MEAS_ADC_THERM_SHDN_THRESH,  0x8c},\n\t{MAX98927_R0016_MEAS_ADC_THERM_HYSTERESIS,  0x08},\n\t{MAX98927_R0017_PIN_CFG,  0x55},\n\t{MAX98927_R0018_PCM_RX_EN_A,  0x00},\n\t{MAX98927_R0019_PCM_RX_EN_B,  0x00},\n\t{MAX98927_R001A_PCM_TX_EN_A,  0x00},\n\t{MAX98927_R001B_PCM_TX_EN_B,  0x00},\n\t{MAX98927_R001C_PCM_TX_HIZ_CTRL_A,  0x00},\n\t{MAX98927_R001D_PCM_TX_HIZ_CTRL_B,  0x00},\n\t{MAX98927_R001E_PCM_TX_CH_SRC_A,  0x00},\n\t{MAX98927_R001F_PCM_TX_CH_SRC_B,  0x00},\n\t{MAX98927_R0020_PCM_MODE_CFG,  0x40},\n\t{MAX98927_R0021_PCM_MASTER_MODE,  0x00},\n\t{MAX98927_R0022_PCM_CLK_SETUP,  0x22},\n\t{MAX98927_R0023_PCM_SR_SETUP1,  0x00},\n\t{MAX98927_R0024_PCM_SR_SETUP2,  0x00},\n\t{MAX98927_R0025_PCM_TO_SPK_MONOMIX_A,  0x00},\n\t{MAX98927_R0026_PCM_TO_SPK_MONOMIX_B,  0x00},\n\t{MAX98927_R0027_ICC_RX_EN_A,  0x00},\n\t{MAX98927_R0028_ICC_RX_EN_B,  0x00},\n\t{MAX98927_R002B_ICC_TX_EN_A,  0x00},\n\t{MAX98927_R002C_ICC_TX_EN_B,  0x00},\n\t{MAX98927_R002E_ICC_HIZ_MANUAL_MODE,  0x00},\n\t{MAX98927_R002F_ICC_TX_HIZ_EN_A,  0x00},\n\t{MAX98927_R0030_ICC_TX_HIZ_EN_B,  0x00},\n\t{MAX98927_R0031_ICC_LNK_EN,  0x00},\n\t{MAX98927_R0032_PDM_TX_EN,  0x00},\n\t{MAX98927_R0033_PDM_TX_HIZ_CTRL,  0x00},\n\t{MAX98927_R0034_PDM_TX_CTRL,  0x00},\n\t{MAX98927_R0035_PDM_RX_CTRL,  0x00},\n\t{MAX98927_R0036_AMP_VOL_CTRL,  0x00},\n\t{MAX98927_R0037_AMP_DSP_CFG,  0x02},\n\t{MAX98927_R0038_TONE_GEN_DC_CFG,  0x00},\n\t{MAX98927_R0039_DRE_CTRL,  0x01},\n\t{MAX98927_R003A_AMP_EN,  0x00},\n\t{MAX98927_R003B_SPK_SRC_SEL,  0x00},\n\t{MAX98927_R003C_SPK_GAIN,  0x00},\n\t{MAX98927_R003D_SSM_CFG,  0x04},\n\t{MAX98927_R003E_MEAS_EN,  0x00},\n\t{MAX98927_R003F_MEAS_DSP_CFG,  0x04},\n\t{MAX98927_R0040_BOOST_CTRL0,  0x00},\n\t{MAX98927_R0041_BOOST_CTRL3,  0x00},\n\t{MAX98927_R0042_BOOST_CTRL1,  0x00},\n\t{MAX98927_R0043_MEAS_ADC_CFG,  0x00},\n\t{MAX98927_R0044_MEAS_ADC_BASE_MSB,  0x01},\n\t{MAX98927_R0045_MEAS_ADC_BASE_LSB,  0x00},\n\t{MAX98927_R0046_ADC_CH0_DIVIDE,  0x00},\n\t{MAX98927_R0047_ADC_CH1_DIVIDE,  0x00},\n\t{MAX98927_R0048_ADC_CH2_DIVIDE,  0x00},\n\t{MAX98927_R0049_ADC_CH0_FILT_CFG,  0x00},\n\t{MAX98927_R004A_ADC_CH1_FILT_CFG,  0x00},\n\t{MAX98927_R004B_ADC_CH2_FILT_CFG,  0x00},\n\t{MAX98927_R004C_MEAS_ADC_CH0_READ,  0x00},\n\t{MAX98927_R004D_MEAS_ADC_CH1_READ,  0x00},\n\t{MAX98927_R004E_MEAS_ADC_CH2_READ,  0x00},\n\t{MAX98927_R0051_BROWNOUT_STATUS,  0x00},\n\t{MAX98927_R0052_BROWNOUT_EN,  0x00},\n\t{MAX98927_R0053_BROWNOUT_INFINITE_HOLD,  0x00},\n\t{MAX98927_R0054_BROWNOUT_INFINITE_HOLD_CLR,  0x00},\n\t{MAX98927_R0055_BROWNOUT_LVL_HOLD,  0x00},\n\t{MAX98927_R005A_BROWNOUT_LVL1_THRESH,  0x00},\n\t{MAX98927_R005B_BROWNOUT_LVL2_THRESH,  0x00},\n\t{MAX98927_R005C_BROWNOUT_LVL3_THRESH,  0x00},\n\t{MAX98927_R005D_BROWNOUT_LVL4_THRESH,  0x00},\n\t{MAX98927_R005E_BROWNOUT_THRESH_HYSTERYSIS,  0x00},\n\t{MAX98927_R005F_BROWNOUT_AMP_LIMITER_ATK_REL,  0x00},\n\t{MAX98927_R0060_BROWNOUT_AMP_GAIN_ATK_REL,  0x00},\n\t{MAX98927_R0061_BROWNOUT_AMP1_CLIP_MODE,  0x00},\n\t{MAX98927_R0072_BROWNOUT_LVL1_CUR_LIMIT,  0x00},\n\t{MAX98927_R0073_BROWNOUT_LVL1_AMP1_CTRL1,  0x00},\n\t{MAX98927_R0074_BROWNOUT_LVL1_AMP1_CTRL2,  0x00},\n\t{MAX98927_R0075_BROWNOUT_LVL1_AMP1_CTRL3,  0x00},\n\t{MAX98927_R0076_BROWNOUT_LVL2_CUR_LIMIT,  0x00},\n\t{MAX98927_R0077_BROWNOUT_LVL2_AMP1_CTRL1,  0x00},\n\t{MAX98927_R0078_BROWNOUT_LVL2_AMP1_CTRL2,  0x00},\n\t{MAX98927_R0079_BROWNOUT_LVL2_AMP1_CTRL3,  0x00},\n\t{MAX98927_R007A_BROWNOUT_LVL3_CUR_LIMIT,  0x00},\n\t{MAX98927_R007B_BROWNOUT_LVL3_AMP1_CTRL1,  0x00},\n\t{MAX98927_R007C_BROWNOUT_LVL3_AMP1_CTRL2,  0x00},\n\t{MAX98927_R007D_BROWNOUT_LVL3_AMP1_CTRL3,  0x00},\n\t{MAX98927_R007E_BROWNOUT_LVL4_CUR_LIMIT,  0x00},\n\t{MAX98927_R007F_BROWNOUT_LVL4_AMP1_CTRL1,  0x00},\n\t{MAX98927_R0080_BROWNOUT_LVL4_AMP1_CTRL2,  0x00},\n\t{MAX98927_R0081_BROWNOUT_LVL4_AMP1_CTRL3,  0x00},\n\t{MAX98927_R0082_ENV_TRACK_VOUT_HEADROOM,  0x00},\n\t{MAX98927_R0083_ENV_TRACK_BOOST_VOUT_DELAY,  0x00},\n\t{MAX98927_R0084_ENV_TRACK_REL_RATE,  0x00},\n\t{MAX98927_R0085_ENV_TRACK_HOLD_RATE,  0x00},\n\t{MAX98927_R0086_ENV_TRACK_CTRL,  0x00},\n\t{MAX98927_R0087_ENV_TRACK_BOOST_VOUT_READ,  0x00},\n\t{MAX98927_R00FF_GLOBAL_SHDN,  0x00},\n\t{MAX98927_R0100_SOFT_RESET,  0x00},\n\t{MAX98927_R01FF_REV_ID,  0x40},\n};\n\nstatic int max98927_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\tunsigned int mode = 0;\n\tunsigned int format = 0;\n\tbool use_pdm = false;\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmax98927->provider = false;\n\t\tmode = MAX98927_PCM_MASTER_MODE_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tmax98927->provider = true;\n\t\tmode = MAX98927_PCM_MASTER_MODE_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI clock mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98927->regmap, MAX98927_R0021_PCM_MASTER_MODE,\n\t\t\t   MAX98927_PCM_MASTER_MODE_MASK, mode);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98927_PCM_MODE_CFG_PCM_BCLKEDGE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98927->regmap, MAX98927_R0020_PCM_MODE_CFG,\n\t\t\t   MAX98927_PCM_MODE_CFG_PCM_BCLKEDGE, invert);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = MAX98927_PCM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = MAX98927_PCM_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = MAX98927_PCM_FORMAT_TDM_MODE1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = MAX98927_PCM_FORMAT_TDM_MODE0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_PDM:\n\t\tuse_pdm = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmax98927->iface = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tif (!use_pdm) {\n\t\t \n\t\tregmap_update_bits(max98927->regmap, MAX98927_R0018_PCM_RX_EN_A,\n\t\t\t\t   MAX98927_PCM_RX_CH0_EN | MAX98927_PCM_RX_CH1_EN,\n\t\t\t\t   MAX98927_PCM_RX_CH0_EN | MAX98927_PCM_RX_CH1_EN);\n\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R0020_PCM_MODE_CFG,\n\t\t\t\t   MAX98927_PCM_MODE_CFG_FORMAT_MASK,\n\t\t\t\t   format << MAX98927_PCM_MODE_CFG_FORMAT_SHIFT);\n\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R003B_SPK_SRC_SEL,\n\t\t\t\t   MAX98927_SPK_SRC_MASK, 0);\n\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R0035_PDM_RX_CTRL,\n\t\t\t\t   MAX98927_PDM_RX_EN_MASK, 0);\n\t} else {\n\t\t \n\t\tregmap_update_bits(max98927->regmap, MAX98927_R0035_PDM_RX_CTRL,\n\t\t\t\t   MAX98927_PDM_RX_EN_MASK, 1);\n\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R003B_SPK_SRC_SEL,\n\t\t\t\t   MAX98927_SPK_SRC_MASK, 3);\n\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R0018_PCM_RX_EN_A,\n\t\t\t\t   MAX98927_PCM_RX_CH0_EN | MAX98927_PCM_RX_CH1_EN,\n\t\t\t\t   0);\n\t}\n\treturn 0;\n}\n\n \nstatic const int rate_table[] = {\n\t5644800, 6000000, 6144000, 6500000,\n\t9600000, 11289600, 12000000, 12288000,\n\t13000000, 19200000,\n};\n\n \nstatic const int bclk_sel_table[] = {\n\t32, 48, 64, 96, 128, 192, 256, 384, 512,\n};\n\nstatic int max98927_get_bclk_sel(int bclk)\n{\n\tint i;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bclk_sel_table); i++) {\n\t\tif (bclk_sel_table[i] == bclk)\n\t\t\treturn i + 2;\n\t}\n\treturn 0;\n}\nstatic int max98927_set_clock(struct max98927_priv *max98927,\n\tstruct snd_pcm_hw_params *params)\n{\n\tstruct snd_soc_component *component = max98927->component;\n\t \n\tint blr_clk_ratio = params_channels(params) * max98927->ch_size;\n\tint value;\n\n\tif (max98927->provider) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n\t\t\tif (rate_table[i] >= max98927->sysclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(rate_table)) {\n\t\t\tdev_err(component->dev, \"failed to find proper clock rate.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R0021_PCM_MASTER_MODE,\n\t\t\t\t   MAX98927_PCM_MASTER_MODE_MCLK_MASK,\n\t\t\t\t   i << MAX98927_PCM_MASTER_MODE_MCLK_RATE_SHIFT);\n\t}\n\n\tif (!max98927->tdm_mode) {\n\t\t \n\t\tvalue = max98927_get_bclk_sel(blr_clk_ratio);\n\t\tif (!value) {\n\t\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R0022_PCM_CLK_SETUP,\n\t\t\t\t   MAX98927_PCM_CLK_SETUP_BSEL_MASK, value);\n\t}\n\treturn 0;\n}\n\nstatic int max98927_dai_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\tunsigned int sampling_rate = 0;\n\tunsigned int chan_sz = 0;\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\tgoto err;\n\t}\n\n\tmax98927->ch_size = snd_pcm_format_width(params_format(params));\n\n\tregmap_update_bits(max98927->regmap, MAX98927_R0020_PCM_MODE_CFG,\n\t\t\t   MAX98927_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\tdev_dbg(component->dev, \"format supported %d\",\n\t\tparams_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98927_PCM_SR_SET1_SR_48000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"rate %d not supported\\n\",\n\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\t \n\tregmap_update_bits(max98927->regmap, MAX98927_R0023_PCM_SR_SETUP1,\n\t\t\t   MAX98927_PCM_SR_SET1_SR_MASK, sampling_rate);\n\tregmap_update_bits(max98927->regmap, MAX98927_R0024_PCM_SR_SETUP2,\n\t\t\t   MAX98927_PCM_SR_SET2_SR_MASK,\n\t\t\t   sampling_rate << MAX98927_PCM_SR_SET2_SR_SHIFT);\n\n\t \n\tif (max98927->interleave_mode &&\n\t    sampling_rate > MAX98927_PCM_SR_SET1_SR_16000)\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R0024_PCM_SR_SETUP2,\n\t\t\t\t   MAX98927_PCM_SR_SET2_IVADC_SR_MASK,\n\t\t\t\t   sampling_rate - 3);\n\telse\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R0024_PCM_SR_SETUP2,\n\t\t\t\t   MAX98927_PCM_SR_SET2_IVADC_SR_MASK,\n\t\t\t\t   sampling_rate);\n\treturn max98927_set_clock(max98927, params);\nerr:\n\treturn -EINVAL;\n}\n\nstatic int max98927_dai_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask,\n\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\tint bsel = 0;\n\tunsigned int chan_sz = 0;\n\n\tmax98927->tdm_mode = true;\n\n\t \n\tbsel = max98927_get_bclk_sel(slots * slot_width);\n\tif (bsel == 0) {\n\t\tdev_err(component->dev, \"BCLK %d not supported\\n\",\n\t\t\tslots * slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98927->regmap, MAX98927_R0022_PCM_CLK_SETUP,\n\t\t\t   MAX98927_PCM_CLK_SETUP_BSEL_MASK, bsel);\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98927_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98927->regmap, MAX98927_R0020_PCM_MODE_CFG,\n\t\t\t   MAX98927_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0018_PCM_RX_EN_A,\n\t\t     rx_mask & 0xFF);\n\tregmap_write(max98927->regmap, MAX98927_R0019_PCM_RX_EN_B,\n\t\t     (rx_mask & 0xFF00) >> 8);\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R001A_PCM_TX_EN_A,\n\t\t     tx_mask & 0xFF);\n\tregmap_write(max98927->regmap, MAX98927_R001B_PCM_TX_EN_B,\n\t\t     (tx_mask & 0xFF00) >> 8);\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R001C_PCM_TX_HIZ_CTRL_A,\n\t\t     ~tx_mask & 0xFF);\n\tregmap_write(max98927->regmap, MAX98927_R001D_PCM_TX_HIZ_CTRL_B,\n\t\t     (~tx_mask & 0xFF00) >> 8);\n\n\treturn 0;\n}\n\n#define MAX98927_RATES SNDRV_PCM_RATE_8000_48000\n\n#define MAX98927_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int max98927_dai_set_sysclk(struct snd_soc_dai *dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\n\tmax98927->sysclk = freq;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops max98927_dai_ops = {\n\t.set_sysclk = max98927_dai_set_sysclk,\n\t.set_fmt = max98927_dai_set_fmt,\n\t.hw_params = max98927_dai_hw_params,\n\t.set_tdm_slot = max98927_dai_tdm_slot,\n};\n\nstatic int max98927_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tmax98927->tdm_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R003A_AMP_EN,\n\t\t\t\t   MAX98927_AMP_EN_MASK, 1);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R00FF_GLOBAL_SHDN,\n\t\t\t\t   MAX98927_GLOBAL_EN_MASK, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R00FF_GLOBAL_SHDN,\n\t\t\t\t   MAX98927_GLOBAL_EN_MASK, 0);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R003A_AMP_EN,\n\t\t\t\t   MAX98927_AMP_EN_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic const char * const max98927_switch_text[] = {\n\t\"Left\", \"Right\", \"LeftRight\"};\n\nstatic const struct soc_enum dai_sel_enum =\n\tSOC_ENUM_SINGLE(MAX98927_R0025_PCM_TO_SPK_MONOMIX_A,\n\t\t\tMAX98927_PCM_TO_SPK_MONOMIX_CFG_SHIFT, 3,\n\t\t\tmax98927_switch_text);\n\nstatic const struct snd_kcontrol_new max98927_dai_controls =\n\tSOC_DAPM_ENUM(\"DAI Sel\", dai_sel_enum);\n\nstatic const struct snd_kcontrol_new max98927_vi_control =\n\tSOC_DAPM_SINGLE(\"Switch\", MAX98927_R003F_MEAS_DSP_CFG, 2, 1, 0);\n\nstatic const struct snd_soc_dapm_widget max98927_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"Amp Enable\", \"HiFi Playback\", MAX98927_R003A_AMP_EN,\n\t\t\t   0, 0, max98927_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MUX(\"DAI Sel Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &max98927_dai_controls),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n\tSND_SOC_DAPM_AIF_OUT(\"Voltage Sense\", \"HiFi Capture\",  0,\n\t\t\t     MAX98927_R003E_MEAS_EN, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Current Sense\", \"HiFi Capture\",  0,\n\t\t\t     MAX98927_R003E_MEAS_EN, 1, 0),\n\tSND_SOC_DAPM_SWITCH(\"VI Sense\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &max98927_vi_control),\n\tSND_SOC_DAPM_SIGGEN(\"VMON\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON\"),\n};\n\nstatic DECLARE_TLV_DB_SCALE(max98927_spk_tlv, 300, 300, 0);\nstatic DECLARE_TLV_DB_SCALE(max98927_digital_tlv, -1600, 25, 0);\n\nstatic bool max98927_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98927_R0001_INT_RAW1 ... MAX98927_R0028_ICC_RX_EN_B:\n\tcase MAX98927_R002B_ICC_TX_EN_A ... MAX98927_R002C_ICC_TX_EN_B:\n\tcase MAX98927_R002E_ICC_HIZ_MANUAL_MODE\n\t\t... MAX98927_R004E_MEAS_ADC_CH2_READ:\n\tcase MAX98927_R0051_BROWNOUT_STATUS\n\t\t... MAX98927_R0055_BROWNOUT_LVL_HOLD:\n\tcase MAX98927_R005A_BROWNOUT_LVL1_THRESH\n\t\t... MAX98927_R0061_BROWNOUT_AMP1_CLIP_MODE:\n\tcase MAX98927_R0072_BROWNOUT_LVL1_CUR_LIMIT\n\t\t... MAX98927_R0087_ENV_TRACK_BOOST_VOUT_READ:\n\tcase MAX98927_R00FF_GLOBAL_SHDN:\n\tcase MAX98927_R0100_SOFT_RESET:\n\tcase MAX98927_R01FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98927_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98927_R0001_INT_RAW1 ... MAX98927_R0009_INT_FLAG3:\n\tcase MAX98927_R004C_MEAS_ADC_CH0_READ:\n\tcase MAX98927_R004D_MEAS_ADC_CH1_READ:\n\tcase MAX98927_R004E_MEAS_ADC_CH2_READ:\n\tcase MAX98927_R0051_BROWNOUT_STATUS:\n\tcase MAX98927_R0087_ENV_TRACK_BOOST_VOUT_READ:\n\tcase MAX98927_R01FF_REV_ID:\n\tcase MAX98927_R0100_SOFT_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char * const max98927_boost_voltage_text[] = {\n\t\"6.5V\", \"6.625V\", \"6.75V\", \"6.875V\", \"7V\", \"7.125V\", \"7.25V\", \"7.375V\",\n\t\"7.5V\", \"7.625V\", \"7.75V\", \"7.875V\", \"8V\", \"8.125V\", \"8.25V\", \"8.375V\",\n\t\"8.5V\", \"8.625V\", \"8.75V\", \"8.875V\", \"9V\", \"9.125V\", \"9.25V\", \"9.375V\",\n\t\"9.5V\", \"9.625V\", \"9.75V\", \"9.875V\", \"10V\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98927_boost_voltage,\n\t\tMAX98927_R0040_BOOST_CTRL0, 0,\n\t\tmax98927_boost_voltage_text);\n\nstatic const char * const max98927_current_limit_text[] = {\n\t\"1.00A\", \"1.10A\", \"1.20A\", \"1.30A\", \"1.40A\", \"1.50A\", \"1.60A\", \"1.70A\",\n\t\"1.80A\", \"1.90A\", \"2.00A\", \"2.10A\", \"2.20A\", \"2.30A\", \"2.40A\", \"2.50A\",\n\t\"2.60A\", \"2.70A\", \"2.80A\", \"2.90A\", \"3.00A\", \"3.10A\", \"3.20A\", \"3.30A\",\n\t\"3.40A\", \"3.50A\", \"3.60A\", \"3.70A\", \"3.80A\", \"3.90A\", \"4.00A\", \"4.10A\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98927_current_limit,\n\t\tMAX98927_R0042_BOOST_CTRL1, 1,\n\t\tmax98927_current_limit_text);\n\nstatic const struct snd_kcontrol_new max98927_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98927_R003C_SPK_GAIN, 0, 6, 0,\n\t\t       max98927_spk_tlv),\n\tSOC_SINGLE_TLV(\"Digital Volume\", MAX98927_R0036_AMP_VOL_CTRL,\n\t\t       0, (1 << MAX98927_AMP_VOL_WIDTH) - 1, 0,\n\t\t       max98927_digital_tlv),\n\tSOC_SINGLE(\"Amp DSP Switch\", MAX98927_R0052_BROWNOUT_EN,\n\t\t   MAX98927_BROWNOUT_DSP_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Ramp Switch\", MAX98927_R0037_AMP_DSP_CFG,\n\t\t   MAX98927_AMP_DSP_CFG_RMP_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DRE Switch\", MAX98927_R0039_DRE_CTRL, MAX98927_DRE_EN_SHIFT,\n\t\t   1, 0),\n\tSOC_SINGLE(\"Volume Location Switch\", MAX98927_R0036_AMP_VOL_CTRL,\n\t\t   MAX98927_AMP_VOL_SEL_SHIFT, 1, 0),\n\tSOC_ENUM(\"Boost Output Voltage\", max98927_boost_voltage),\n\tSOC_ENUM(\"Current Limit\", max98927_current_limit),\n};\n\nstatic const struct snd_soc_dapm_route max98927_audio_map[] = {\n\t \n\t{\"DAI Sel Mux\", \"Left\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"Right\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"LeftRight\", \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"DAI Sel Mux\"},\n\t \n\t{ \"VI Sense\", \"Switch\", \"VMON\" },\n\t{ \"VI Sense\", \"Switch\", \"IMON\" },\n\t{ \"Voltage Sense\", NULL, \"VI Sense\" },\n\t{ \"Current Sense\", NULL, \"VI Sense\" },\n};\n\nstatic struct snd_soc_dai_driver max98927_dai[] = {\n\t{\n\t\t.name = \"max98927-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98927_RATES,\n\t\t\t.formats = MAX98927_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98927_RATES,\n\t\t\t.formats = MAX98927_FORMATS,\n\t\t},\n\t\t.ops = &max98927_dai_ops,\n\t}\n};\n\nstatic int max98927_probe(struct snd_soc_component *component)\n{\n\tstruct max98927_priv *max98927 = snd_soc_component_get_drvdata(component);\n\n\tmax98927->component = component;\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0100_SOFT_RESET,\n\t\t     MAX98927_SOFT_RESET);\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R001C_PCM_TX_HIZ_CTRL_A, 0xFF);\n\tregmap_write(max98927->regmap, MAX98927_R001D_PCM_TX_HIZ_CTRL_B, 0xFF);\n\tregmap_write(max98927->regmap, MAX98927_R0025_PCM_TO_SPK_MONOMIX_A,\n\t\t     0x80);\n\tregmap_write(max98927->regmap, MAX98927_R0026_PCM_TO_SPK_MONOMIX_B,\n\t\t     0x1);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0036_AMP_VOL_CTRL, 0x38);\n\tregmap_write(max98927->regmap, MAX98927_R003C_SPK_GAIN, 0x05);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0037_AMP_DSP_CFG, 0x03);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R003F_MEAS_DSP_CFG, 0xF7);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0040_BOOST_CTRL0, 0x1C);\n\tregmap_write(max98927->regmap, MAX98927_R0042_BOOST_CTRL1, 0x3E);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0043_MEAS_ADC_CFG, 0x04);\n\tregmap_write(max98927->regmap, MAX98927_R0044_MEAS_ADC_BASE_MSB, 0x00);\n\tregmap_write(max98927->regmap, MAX98927_R0045_MEAS_ADC_BASE_LSB, 0x24);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R007F_BROWNOUT_LVL4_AMP1_CTRL1,\n\t\t     0x06);\n\t \n\tregmap_write(max98927->regmap, MAX98927_R0082_ENV_TRACK_VOUT_HEADROOM,\n\t\t     0x08);\n\tregmap_write(max98927->regmap, MAX98927_R0086_ENV_TRACK_CTRL, 0x01);\n\tregmap_write(max98927->regmap, MAX98927_R0087_ENV_TRACK_BOOST_VOUT_READ,\n\t\t     0x10);\n\n\t \n\tregmap_write(max98927->regmap, MAX98927_R001E_PCM_TX_CH_SRC_A,\n\t\t     (max98927->i_l_slot << MAX98927_PCM_TX_CH_SRC_A_I_SHIFT | max98927->v_l_slot) & 0xFF);\n\n\tif (max98927->v_l_slot < 8) {\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R001C_PCM_TX_HIZ_CTRL_A,\n\t\t\t\t   1 << max98927->v_l_slot, 0);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R001A_PCM_TX_EN_A,\n\t\t\t\t   1 << max98927->v_l_slot,\n\t\t\t\t   1 << max98927->v_l_slot);\n\t} else {\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R001D_PCM_TX_HIZ_CTRL_B,\n\t\t\t\t   1 << (max98927->v_l_slot - 8), 0);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R001B_PCM_TX_EN_B,\n\t\t\t\t   1 << (max98927->v_l_slot - 8),\n\t\t\t\t   1 << (max98927->v_l_slot - 8));\n\t}\n\n\tif (max98927->i_l_slot < 8) {\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R001C_PCM_TX_HIZ_CTRL_A,\n\t\t\t\t   1 << max98927->i_l_slot, 0);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R001A_PCM_TX_EN_A,\n\t\t\t\t   1 << max98927->i_l_slot,\n\t\t\t\t   1 << max98927->i_l_slot);\n\t} else {\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R001D_PCM_TX_HIZ_CTRL_B,\n\t\t\t\t   1 << (max98927->i_l_slot - 8), 0);\n\t\tregmap_update_bits(max98927->regmap, MAX98927_R001B_PCM_TX_EN_B,\n\t\t\t\t   1 << (max98927->i_l_slot - 8),\n\t\t\t\t   1 << (max98927->i_l_slot - 8));\n\t}\n\n\t \n\tif (max98927->interleave_mode)\n\t\tregmap_update_bits(max98927->regmap,\n\t\t\t\t   MAX98927_R001F_PCM_TX_CH_SRC_B,\n\t\t\t\t   MAX98927_PCM_TX_CH_INTERLEAVE_MASK,\n\t\t\t\t   MAX98927_PCM_TX_CH_INTERLEAVE_MASK);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max98927_suspend(struct device *dev)\n{\n\tstruct max98927_priv *max98927 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98927->regmap, true);\n\tregcache_mark_dirty(max98927->regmap);\n\treturn 0;\n}\nstatic int max98927_resume(struct device *dev)\n{\n\tstruct max98927_priv *max98927 = dev_get_drvdata(dev);\n\n\tregmap_write(max98927->regmap, MAX98927_R0100_SOFT_RESET,\n\t\t     MAX98927_SOFT_RESET);\n\tregcache_cache_only(max98927->regmap, false);\n\tregcache_sync(max98927->regmap);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops max98927_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max98927_suspend, max98927_resume)\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98927 = {\n\t.probe\t\t\t= max98927_probe,\n\t.controls\t\t= max98927_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98927_snd_controls),\n\t.dapm_widgets\t\t= max98927_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98927_dapm_widgets),\n\t.dapm_routes\t\t= max98927_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98927_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98927_regmap = {\n\t.reg_bits         = 16,\n\t.val_bits         = 8,\n\t.max_register     = MAX98927_R01FF_REV_ID,\n\t.reg_defaults     = max98927_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98927_reg),\n\t.readable_reg\t  = max98927_readable_register,\n\t.volatile_reg\t  = max98927_volatile_reg,\n\t.cache_type       = REGCACHE_RBTREE,\n};\n\nstatic void max98927_slot_config(struct i2c_client *i2c,\n\tstruct max98927_priv *max98927)\n{\n\tint value;\n\tstruct device *dev = &i2c->dev;\n\n\tif (!device_property_read_u32(dev, \"vmon-slot-no\", &value))\n\t\tmax98927->v_l_slot = value & 0xF;\n\telse\n\t\tmax98927->v_l_slot = 0;\n\n\tif (!device_property_read_u32(dev, \"imon-slot-no\", &value))\n\t\tmax98927->i_l_slot = value & 0xF;\n\telse\n\t\tmax98927->i_l_slot = 1;\n}\n\nstatic int max98927_i2c_probe(struct i2c_client *i2c)\n{\n\n\tint ret = 0, value;\n\tint reg = 0;\n\tstruct max98927_priv *max98927 = NULL;\n\n\tmax98927 = devm_kzalloc(&i2c->dev, sizeof(*max98927), GFP_KERNEL);\n\tif (!max98927) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(i2c, max98927);\n\n\t \n\tif (of_property_read_bool(i2c->dev.of_node, \"maxim,interleave-mode\")) {\n\t\tmax98927->interleave_mode = true;\n\t} else {\n\t\tif (!of_property_read_u32(i2c->dev.of_node, \"interleave_mode\",\n\t\t\t\t\t  &value))\n\t\t\tif (value > 0)\n\t\t\t\tmax98927->interleave_mode = true;\n\t}\n\n\t \n\tmax98927->regmap\n\t\t= devm_regmap_init_i2c(i2c, &max98927_regmap);\n\tif (IS_ERR(max98927->regmap)) {\n\t\tret = PTR_ERR(max98927->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax98927->reset_gpio = devm_gpiod_get_optional(&i2c->dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tif (IS_ERR(max98927->reset_gpio)) {\n\t\tret = PTR_ERR(max98927->reset_gpio);\n\t\treturn dev_err_probe(&i2c->dev, ret, \"failed to request GPIO reset pin\");\n\t}\n\n\tif (max98927->reset_gpio) {\n\t\tgpiod_set_value_cansleep(max98927->reset_gpio, 0);\n\t\t \n\t\tusleep_range(5000, 6000);\n\t}\n\n\t \n\tret = regmap_read(max98927->regmap, MAX98927_R01FF_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to read: 0x%02X\\n\", MAX98927_R01FF_REV_ID);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"MAX98927 revisionID: 0x%02X\\n\", reg);\n\n\t \n\tmax98927_slot_config(i2c, max98927);\n\n\t \n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t&soc_component_dev_max98927,\n\t\tmax98927_dai, ARRAY_SIZE(max98927_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Failed to register component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void max98927_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct max98927_priv *max98927 = i2c_get_clientdata(i2c);\n\n\tif (max98927->reset_gpio)\n\t\tgpiod_set_value_cansleep(max98927->reset_gpio, 1);\n}\n\nstatic const struct i2c_device_id max98927_i2c_id[] = {\n\t{ \"max98927\", 0},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, max98927_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98927_of_match[] = {\n\t{ .compatible = \"maxim,max98927\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98927_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max98927_acpi_match[] = {\n\t{ \"MX98927\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, max98927_acpi_match);\n#endif\n\nstatic struct i2c_driver max98927_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98927\",\n\t\t.of_match_table = of_match_ptr(max98927_of_match),\n\t\t.acpi_match_table = ACPI_PTR(max98927_acpi_match),\n\t\t.pm = &max98927_pm,\n\t},\n\t.probe = max98927_i2c_probe,\n\t.remove = max98927_i2c_remove,\n\t.id_table = max98927_i2c_id,\n};\n\nmodule_i2c_driver(max98927_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98927 driver\");\nMODULE_AUTHOR(\"Ryan Lee <ryans.lee@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}