{
  "module_name": "tlv320aic23.c",
  "hash_id": "e4dd534c96a171b47216596b46fd69b2332cbbadae32a49b50ed245e27d047cf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic23.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n\n#include \"tlv320aic23.h\"\n\n \nstatic const struct reg_default tlv320aic23_reg[] = {\n\t{  0, 0x0097 },\n\t{  1, 0x0097 },\n\t{  2, 0x00F9 },\n\t{  3, 0x00F9 },\n\t{  4, 0x001A },\n\t{  5, 0x0004 },\n\t{  6, 0x0007 },\n\t{  7, 0x0001 },\n\t{  8, 0x0020 },\n\t{  9, 0x0000 },\n};\n\nconst struct regmap_config tlv320aic23_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = TLV320AIC23_RESET,\n\t.reg_defaults = tlv320aic23_reg,\n\t.num_reg_defaults = ARRAY_SIZE(tlv320aic23_reg),\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL(tlv320aic23_regmap);\n\nstatic const char *rec_src_text[] = { \"Line\", \"Mic\" };\nstatic const char *deemph_text[] = {\"None\", \"32Khz\", \"44.1Khz\", \"48Khz\"};\n\nstatic SOC_ENUM_SINGLE_DECL(rec_src_enum,\n\t\t\t    TLV320AIC23_ANLG, 2, rec_src_text);\n\nstatic const struct snd_kcontrol_new tlv320aic23_rec_src_mux_controls =\nSOC_DAPM_ENUM(\"Input Select\", rec_src_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(tlv320aic23_deemph,\n\t\t\t    TLV320AIC23_DIGT, 1, deemph_text);\n\nstatic const DECLARE_TLV_DB_SCALE(out_gain_tlv, -12100, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(input_gain_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(sidetone_vol_tlv, -1800, 300, 0);\n\nstatic int snd_soc_tlv320aic23_put_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tu16 val, reg;\n\n\tval = (ucontrol->value.integer.value[0] & 0x07);\n\n\t \n\tval = (val >= 4) ? 4  : (3 - val);\n\n\treg = snd_soc_component_read(component, TLV320AIC23_ANLG) & (~0x1C0);\n\tsnd_soc_component_write(component, TLV320AIC23_ANLG, reg | (val << 6));\n\n\treturn 0;\n}\n\nstatic int snd_soc_tlv320aic23_get_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tu16 val;\n\n\tval = snd_soc_component_read(component, TLV320AIC23_ANLG) & (0x1C0);\n\tval = val >> 6;\n\tval = (val >= 4) ? 4  : (3 -  val);\n\tucontrol->value.integer.value[0] = val;\n\treturn 0;\n\n}\n\nstatic const struct snd_kcontrol_new tlv320aic23_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", TLV320AIC23_LCHNVOL,\n\t\t\t TLV320AIC23_RCHNVOL, 0, 127, 0, out_gain_tlv),\n\tSOC_SINGLE(\"Digital Playback Switch\", TLV320AIC23_DIGT, 3, 1, 1),\n\tSOC_DOUBLE_R(\"Line Input Switch\", TLV320AIC23_LINVOL,\n\t\t     TLV320AIC23_RINVOL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Line Input Volume\", TLV320AIC23_LINVOL,\n\t\t\t TLV320AIC23_RINVOL, 0, 31, 0, input_gain_tlv),\n\tSOC_SINGLE(\"Mic Input Switch\", TLV320AIC23_ANLG, 1, 1, 1),\n\tSOC_SINGLE(\"Mic Booster Switch\", TLV320AIC23_ANLG, 0, 1, 0),\n\tSOC_SINGLE_EXT_TLV(\"Sidetone Volume\", TLV320AIC23_ANLG, 6, 4, 0,\n\t\t\t   snd_soc_tlv320aic23_get_volsw,\n\t\t\t   snd_soc_tlv320aic23_put_volsw, sidetone_vol_tlv),\n\tSOC_ENUM(\"Playback De-emphasis\", tlv320aic23_deemph),\n};\n\n \nstatic const struct snd_kcontrol_new tlv320aic23_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", TLV320AIC23_ANLG, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", TLV320AIC23_ANLG, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"Playback Switch\", TLV320AIC23_ANLG, 4, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget tlv320aic23_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", TLV320AIC23_PWR, 3, 1),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", TLV320AIC23_PWR, 2, 1),\n\tSND_SOC_DAPM_MUX(\"Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tlv320aic23_rec_src_mux_controls),\n\tSND_SOC_DAPM_MIXER(\"Output Mixer\", TLV320AIC23_PWR, 4, 1,\n\t\t\t   &tlv320aic23_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(tlv320aic23_output_mixer_controls)),\n\tSND_SOC_DAPM_PGA(\"Line Input\", TLV320AIC23_PWR, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mic Input\", TLV320AIC23_PWR, 1, 1, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\n\tSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n\tSND_SOC_DAPM_INPUT(\"RLINEIN\"),\n\n\tSND_SOC_DAPM_INPUT(\"MICIN\"),\n};\n\nstatic const struct snd_soc_dapm_route tlv320aic23_intercon[] = {\n\t \n\t{\"Output Mixer\", \"Line Bypass Switch\", \"Line Input\"},\n\t{\"Output Mixer\", \"Playback Switch\", \"DAC\"},\n\t{\"Output Mixer\", \"Mic Sidetone Switch\", \"Mic Input\"},\n\n\t \n\t{\"RHPOUT\", NULL, \"Output Mixer\"},\n\t{\"LHPOUT\", NULL, \"Output Mixer\"},\n\t{\"LOUT\", NULL, \"Output Mixer\"},\n\t{\"ROUT\", NULL, \"Output Mixer\"},\n\n\t \n\t{\"Line Input\", NULL, \"LLINEIN\"},\n\t{\"Line Input\", NULL, \"RLINEIN\"},\n\t{\"Mic Input\", NULL, \"MICIN\"},\n\n\t \n\t{\"Capture Source\", \"Line\", \"Line Input\"},\n\t{\"Capture Source\", \"Mic\", \"Mic Input\"},\n\t{\"ADC\", NULL, \"Capture Source\"},\n\n};\n\n \nstruct aic23 {\n\tstruct regmap *regmap;\n\tint mclk;\n\tint requested_adc;\n\tint requested_dac;\n};\n\n \n\n \nstatic const int bosr_usb_divisor_table[] = {\n\t128, 125, 192, 136\n};\n#define LOWER_GROUP ((1<<0) | (1<<1) | (1<<2) | (1<<3) | (1<<6) | (1<<7))\n#define UPPER_GROUP ((1<<8) | (1<<9) | (1<<10) | (1<<11)        | (1<<15))\nstatic const unsigned short sr_valid_mask[] = {\n\tLOWER_GROUP|UPPER_GROUP,\t \n\tLOWER_GROUP,\t\t\t \n\tLOWER_GROUP|UPPER_GROUP,\t \n\tUPPER_GROUP,\t\t\t \n};\n \n#define SR_MULT (11*12)\n#define A(x) (SR_MULT/x)\nstatic const unsigned char sr_adc_mult_table[] = {\n\tA(2), A(2), A(12), A(12),  0, 0, A(3), A(1),\n\tA(2), A(2), A(11), A(11),  0, 0, 0, A(1)\n};\nstatic const unsigned char sr_dac_mult_table[] = {\n\tA(2), A(12), A(2), A(12),  0, 0, A(3), A(1),\n\tA(2), A(11), A(2), A(11),  0, 0, 0, A(1)\n};\n\nstatic unsigned get_score(int adc, int adc_l, int adc_h, int need_adc,\n\t\tint dac, int dac_l, int dac_h, int need_dac)\n{\n\tif ((adc >= adc_l) && (adc <= adc_h) &&\n\t\t\t(dac >= dac_l) && (dac <= dac_h)) {\n\t\tint diff_adc = need_adc - adc;\n\t\tint diff_dac = need_dac - dac;\n\t\treturn abs(diff_adc) + abs(diff_dac);\n\t}\n\treturn UINT_MAX;\n}\n\nstatic int find_rate(int mclk, u32 need_adc, u32 need_dac)\n{\n\tint i, j;\n\tint best_i = -1;\n\tint best_j = -1;\n\tint best_div = 0;\n\tunsigned best_score = UINT_MAX;\n\tint adc_l, adc_h, dac_l, dac_h;\n\n\tneed_adc *= SR_MULT;\n\tneed_dac *= SR_MULT;\n\t \n\tadc_l = need_adc - (need_adc >> 5);\n\tadc_h = need_adc + (need_adc >> 5);\n\tdac_l = need_dac - (need_dac >> 5);\n\tdac_h = need_dac + (need_dac >> 5);\n\tfor (i = 0; i < ARRAY_SIZE(bosr_usb_divisor_table); i++) {\n\t\tint base = mclk / bosr_usb_divisor_table[i];\n\t\tint mask = sr_valid_mask[i];\n\t\tfor (j = 0; j < ARRAY_SIZE(sr_adc_mult_table);\n\t\t\t\tj++, mask >>= 1) {\n\t\t\tint adc;\n\t\t\tint dac;\n\t\t\tint score;\n\t\t\tif ((mask & 1) == 0)\n\t\t\t\tcontinue;\n\t\t\tadc = base * sr_adc_mult_table[j];\n\t\t\tdac = base * sr_dac_mult_table[j];\n\t\t\tscore = get_score(adc, adc_l, adc_h, need_adc,\n\t\t\t\t\tdac, dac_l, dac_h, need_dac);\n\t\t\tif (best_score > score) {\n\t\t\t\tbest_score = score;\n\t\t\t\tbest_i = i;\n\t\t\t\tbest_j = j;\n\t\t\t\tbest_div = 0;\n\t\t\t}\n\t\t\tscore = get_score((adc >> 1), adc_l, adc_h, need_adc,\n\t\t\t\t\t(dac >> 1), dac_l, dac_h, need_dac);\n\t\t\t \n\t\t\tif ((score != UINT_MAX) && (best_score >= score)) {\n\t\t\t\tbest_score = score;\n\t\t\t\tbest_i = i;\n\t\t\t\tbest_j = j;\n\t\t\t\tbest_div = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn (best_j << 2) | best_i | (best_div << TLV320AIC23_CLKIN_SHIFT);\n}\n\n#ifdef DEBUG\nstatic void get_current_sample_rates(struct snd_soc_component *component, int mclk,\n\t\tu32 *sample_rate_adc, u32 *sample_rate_dac)\n{\n\tint src = snd_soc_component_read(component, TLV320AIC23_SRATE);\n\tint sr = (src >> 2) & 0x0f;\n\tint val = (mclk / bosr_usb_divisor_table[src & 3]);\n\tint adc = (val * sr_adc_mult_table[sr]) / SR_MULT;\n\tint dac = (val * sr_dac_mult_table[sr]) / SR_MULT;\n\tif (src & TLV320AIC23_CLKIN_HALF) {\n\t\tadc >>= 1;\n\t\tdac >>= 1;\n\t}\n\t*sample_rate_adc = adc;\n\t*sample_rate_dac = dac;\n}\n#endif\n\nstatic int set_sample_rate_control(struct snd_soc_component *component, int mclk,\n\t\tu32 sample_rate_adc, u32 sample_rate_dac)\n{\n\t \n\tint data = find_rate(mclk, sample_rate_adc, sample_rate_dac);\n\tif (data < 0) {\n\t\tprintk(KERN_ERR \"%s:Invalid rate %u,%u requested\\n\",\n\t\t\t\t__func__, sample_rate_adc, sample_rate_dac);\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_write(component, TLV320AIC23_SRATE, data);\n#ifdef DEBUG\n\t{\n\t\tu32 adc, dac;\n\t\tget_current_sample_rates(component, mclk, &adc, &dac);\n\t\tprintk(KERN_DEBUG \"actual samplerate = %u,%u reg=%x\\n\",\n\t\t\tadc, dac, data);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int tlv320aic23_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 iface_reg;\n\tint ret;\n\tstruct aic23 *aic23 = snd_soc_component_get_drvdata(component);\n\tu32 sample_rate_adc = aic23->requested_adc;\n\tu32 sample_rate_dac = aic23->requested_dac;\n\tu32 sample_rate = params_rate(params);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\taic23->requested_dac = sample_rate_dac = sample_rate;\n\t\tif (!sample_rate_adc)\n\t\t\tsample_rate_adc = sample_rate;\n\t} else {\n\t\taic23->requested_adc = sample_rate_adc = sample_rate;\n\t\tif (!sample_rate_dac)\n\t\t\tsample_rate_dac = sample_rate;\n\t}\n\tret = set_sample_rate_control(component, aic23->mclk, sample_rate_adc,\n\t\t\tsample_rate_dac);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tiface_reg = snd_soc_component_read(component, TLV320AIC23_DIGT_FMT) & ~(0x03 << 2);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface_reg |= (0x01 << 2);\n\t\tbreak;\n\tcase 24:\n\t\tiface_reg |= (0x02 << 2);\n\t\tbreak;\n\tcase 32:\n\t\tiface_reg |= (0x03 << 2);\n\t\tbreak;\n\t}\n\tsnd_soc_component_write(component, TLV320AIC23_DIGT_FMT, iface_reg);\n\n\treturn 0;\n}\n\nstatic int tlv320aic23_pcm_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\t \n\tsnd_soc_component_write(component, TLV320AIC23_ACTIVE, 0x0001);\n\n\treturn 0;\n}\n\nstatic void tlv320aic23_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic23 *aic23 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!snd_soc_component_active(component)) {\n\t\tudelay(50);\n\t\tsnd_soc_component_write(component, TLV320AIC23_ACTIVE, 0x0);\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\taic23->requested_dac = 0;\n\telse\n\t\taic23->requested_adc = 0;\n}\n\nstatic int tlv320aic23_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 reg;\n\n\treg = snd_soc_component_read(component, TLV320AIC23_DIGT);\n\tif (mute)\n\t\treg |= TLV320AIC23_DACM_MUTE;\n\n\telse\n\t\treg &= ~TLV320AIC23_DACM_MUTE;\n\n\tsnd_soc_component_write(component, TLV320AIC23_DIGT, reg);\n\n\treturn 0;\n}\n\nstatic int tlv320aic23_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t   unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface_reg;\n\n\tiface_reg = snd_soc_component_read(component, TLV320AIC23_DIGT_FMT) & (~0x03);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface_reg |= TLV320AIC23_MS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tiface_reg &= ~TLV320AIC23_MS_MASTER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface_reg |= TLV320AIC23_FOR_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface_reg |= TLV320AIC23_LRP_ON;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface_reg |= TLV320AIC23_FOR_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface_reg |= TLV320AIC23_FOR_LJUST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\tsnd_soc_component_write(component, TLV320AIC23_DIGT_FMT, iface_reg);\n\n\treturn 0;\n}\n\nstatic int tlv320aic23_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t      int clk_id, unsigned int freq, int dir)\n{\n\tstruct aic23 *aic23 = snd_soc_dai_get_drvdata(codec_dai);\n\taic23->mclk = freq;\n\treturn 0;\n}\n\nstatic int tlv320aic23_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t      enum snd_soc_bias_level level)\n{\n\tu16 reg = snd_soc_component_read(component, TLV320AIC23_PWR) & 0x17f;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\t \n\t\treg &= ~(TLV320AIC23_DEVICE_PWR_OFF | TLV320AIC23_OSC_OFF | \\\n\t\t\tTLV320AIC23_DAC_OFF);\n\t\tsnd_soc_component_write(component, TLV320AIC23_PWR, reg);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tsnd_soc_component_write(component, TLV320AIC23_PWR,\n\t\t\t      reg | TLV320AIC23_CLK_OFF);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_write(component, TLV320AIC23_ACTIVE, 0x0);\n\t\tsnd_soc_component_write(component, TLV320AIC23_PWR, 0x1ff);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define AIC23_RATES\tSNDRV_PCM_RATE_8000_96000\n#define AIC23_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops tlv320aic23_dai_ops = {\n\t.prepare\t= tlv320aic23_pcm_prepare,\n\t.hw_params\t= tlv320aic23_hw_params,\n\t.shutdown\t= tlv320aic23_shutdown,\n\t.mute_stream\t= tlv320aic23_mute,\n\t.set_fmt\t= tlv320aic23_set_dai_fmt,\n\t.set_sysclk\t= tlv320aic23_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver tlv320aic23_dai = {\n\t.name = \"tlv320aic23-hifi\",\n\t.playback = {\n\t\t     .stream_name = \"Playback\",\n\t\t     .channels_min = 2,\n\t\t     .channels_max = 2,\n\t\t     .rates = AIC23_RATES,\n\t\t     .formats = AIC23_FORMATS,},\n\t.capture = {\n\t\t    .stream_name = \"Capture\",\n\t\t    .channels_min = 2,\n\t\t    .channels_max = 2,\n\t\t    .rates = AIC23_RATES,\n\t\t    .formats = AIC23_FORMATS,},\n\t.ops = &tlv320aic23_dai_ops,\n};\n\nstatic int tlv320aic23_resume(struct snd_soc_component *component)\n{\n\tstruct aic23 *aic23 = snd_soc_component_get_drvdata(component);\n\tregcache_mark_dirty(aic23->regmap);\n\tregcache_sync(aic23->regmap);\n\n\treturn 0;\n}\n\nstatic int tlv320aic23_component_probe(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_write(component, TLV320AIC23_RESET, 0);\n\n\tsnd_soc_component_write(component, TLV320AIC23_DIGT, TLV320AIC23_DEEMP_44K);\n\n\t \n\tsnd_soc_component_update_bits(component, TLV320AIC23_LINVOL,\n\t\t\t    TLV320AIC23_LIM_MUTED, TLV320AIC23_LRS_ENABLED);\n\n\tsnd_soc_component_update_bits(component, TLV320AIC23_RINVOL,\n\t\t\t    TLV320AIC23_LIM_MUTED, TLV320AIC23_LRS_ENABLED);\n\n\tsnd_soc_component_update_bits(component, TLV320AIC23_ANLG,\n\t\t\t    TLV320AIC23_BYPASS_ON | TLV320AIC23_MICM_MUTED,\n\t\t\t    0);\n\n\t \n\tsnd_soc_component_write(component, TLV320AIC23_LCHNVOL,\n\t\t      TLV320AIC23_DEFAULT_OUT_VOL & TLV320AIC23_OUT_VOL_MASK);\n\tsnd_soc_component_write(component, TLV320AIC23_RCHNVOL,\n\t\t      TLV320AIC23_DEFAULT_OUT_VOL & TLV320AIC23_OUT_VOL_MASK);\n\n\tsnd_soc_component_write(component, TLV320AIC23_ACTIVE, 0x1);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_tlv320aic23 = {\n\t.probe\t\t\t= tlv320aic23_component_probe,\n\t.resume\t\t\t= tlv320aic23_resume,\n\t.set_bias_level\t\t= tlv320aic23_set_bias_level,\n\t.controls\t\t= tlv320aic23_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tlv320aic23_snd_controls),\n\t.dapm_widgets\t\t= tlv320aic23_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tlv320aic23_dapm_widgets),\n\t.dapm_routes\t\t= tlv320aic23_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(tlv320aic23_intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint tlv320aic23_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct aic23 *aic23;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\taic23 = devm_kzalloc(dev, sizeof(struct aic23), GFP_KERNEL);\n\tif (aic23 == NULL)\n\t\treturn -ENOMEM;\n\n\taic23->regmap = regmap;\n\n\tdev_set_drvdata(dev, aic23);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t      &soc_component_dev_tlv320aic23,\n\t\t\t\t      &tlv320aic23_dai, 1);\n}\nEXPORT_SYMBOL(tlv320aic23_probe);\n\nMODULE_DESCRIPTION(\"ASoC TLV320AIC23 codec driver\");\nMODULE_AUTHOR(\"Arun KS <arunks@mistralsolutions.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}