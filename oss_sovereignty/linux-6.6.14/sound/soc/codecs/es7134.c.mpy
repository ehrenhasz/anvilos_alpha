{
  "module_name": "es7134.c",
  "hash_id": "a010d2012d0367ee749cb8babcb3dc77c7969b13cfd5fd80e3dd57b8f197290e",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/es7134.c",
  "human_readable_source": "\n \n\n#include <linux/of_platform.h>\n#include <linux/module.h>\n#include <sound/soc.h>\n\n \n\nstruct es7134_clock_mode {\n\tunsigned int rate_min;\n\tunsigned int rate_max;\n\tunsigned int *mclk_fs;\n\tunsigned int mclk_fs_num;\n};\n\nstruct es7134_chip {\n\tstruct snd_soc_dai_driver *dai_drv;\n\tconst struct es7134_clock_mode *modes;\n\tunsigned int mode_num;\n\tconst struct snd_soc_dapm_widget *extra_widgets;\n\tunsigned int extra_widget_num;\n\tconst struct snd_soc_dapm_route *extra_routes;\n\tunsigned int extra_route_num;\n};\n\nstruct es7134_data {\n\tunsigned int mclk;\n\tconst struct es7134_chip *chip;\n};\n\nstatic int es7134_check_mclk(struct snd_soc_dai *dai,\n\t\t\t     struct es7134_data *priv,\n\t\t\t     unsigned int rate)\n{\n\tunsigned int mfs = priv->mclk / rate;\n\tint i, j;\n\n\tfor (i = 0; i < priv->chip->mode_num; i++) {\n\t\tconst struct es7134_clock_mode *mode = &priv->chip->modes[i];\n\n\t\tif (rate < mode->rate_min || rate > mode->rate_max)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < mode->mclk_fs_num; j++) {\n\t\t\tif (mode->mclk_fs[j] == mfs)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(dai->dev, \"unsupported mclk_fs %u for rate %u\\n\",\n\t\t\tmfs, rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdev_err(dai->dev, \"unsupported rate: %u\\n\", rate);\n\treturn -EINVAL;\n}\n\nstatic int es7134_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct es7134_data *priv = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tif (!priv->mclk)\n\t\treturn 0;\n\n\treturn es7134_check_mclk(dai, priv, params_rate(params));\n}\n\nstatic int es7134_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq, int dir)\n{\n\tstruct es7134_data *priv = snd_soc_dai_get_drvdata(dai);\n\n\tif (dir == SND_SOC_CLOCK_IN && clk_id == 0) {\n\t\tpriv->mclk = freq;\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int es7134_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tfmt &= (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK |\n\t\tSND_SOC_DAIFMT_MASTER_MASK);\n\n\tif (fmt != (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t    SND_SOC_DAIFMT_CBC_CFC)) {\n\t\tdev_err(codec_dai->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int es7134_component_probe(struct snd_soc_component *c)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(c);\n\tstruct es7134_data *priv = snd_soc_component_get_drvdata(c);\n\tconst struct es7134_chip *chip = priv->chip;\n\tint ret;\n\n\tif (chip->extra_widget_num) {\n\t\tret = snd_soc_dapm_new_controls(dapm, chip->extra_widgets,\n\t\t\t\t\t\tchip->extra_widget_num);\n\t\tif (ret) {\n\t\t\tdev_err(c->dev, \"failed to add extra widgets\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (chip->extra_route_num) {\n\t\tret = snd_soc_dapm_add_routes(dapm, chip->extra_routes,\n\t\t\t\t\t      chip->extra_route_num);\n\t\tif (ret) {\n\t\t\tdev_err(c->dev, \"failed to add extra routes\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops es7134_dai_ops = {\n\t.set_fmt\t= es7134_set_fmt,\n\t.hw_params\t= es7134_hw_params,\n\t.set_sysclk\t= es7134_set_sysclk,\n};\n\nstatic struct snd_soc_dai_driver es7134_dai = {\n\t.name = \"es7134-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = (SNDRV_PCM_RATE_8000_48000 |\n\t\t\t  SNDRV_PCM_RATE_88200      |\n\t\t\t  SNDRV_PCM_RATE_96000      |\n\t\t\t  SNDRV_PCM_RATE_176400     |\n\t\t\t  SNDRV_PCM_RATE_192000),\n\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE  |\n\t\t\t    SNDRV_PCM_FMTBIT_S18_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE),\n\t},\n\t.ops = &es7134_dai_ops,\n};\n\nstatic const struct es7134_clock_mode es7134_modes[] = {\n\t{\n\t\t \n\t\t.rate_min = 8000,\n\t\t.rate_max = 50000,\n\t\t.mclk_fs = (unsigned int[]) { 256, 384, 512, 768, 1024 },\n\t\t.mclk_fs_num = 5,\n\t}, {\n\t\t \n\t\t.rate_min = 84000,\n\t\t.rate_max = 100000,\n\t\t.mclk_fs = (unsigned int[]) { 128, 192, 256, 384, 512 },\n\t\t.mclk_fs_num = 5,\n\t}, {\n\t\t \n\t\t.rate_min = 167000,\n\t\t.rate_max = 192000,\n\t\t.mclk_fs = (unsigned int[]) { 128, 192, 256 },\n\t\t.mclk_fs_num = 3,\n\t},\n};\n\n \nstatic const struct snd_soc_dapm_route es7134_extra_routes[] = {\n\t{ \"Playback\", NULL, \"VDD\", }\n};\n\nstatic const struct es7134_chip es7134_chip __maybe_unused = {\n\t.dai_drv = &es7134_dai,\n\t.modes = es7134_modes,\n\t.mode_num = ARRAY_SIZE(es7134_modes),\n\t.extra_routes = es7134_extra_routes,\n\t.extra_route_num = ARRAY_SIZE(es7134_extra_routes),\n};\n\nstatic const struct snd_soc_dapm_widget es7134_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"AOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUTR\"),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDD\", 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route es7134_dapm_routes[] = {\n\t{ \"AOUTL\", NULL, \"DAC\" },\n\t{ \"AOUTR\", NULL, \"DAC\" },\n\t{ \"DAC\", NULL, \"VDD\" },\n};\n\nstatic const struct snd_soc_component_driver es7134_component_driver = {\n\t.probe\t\t\t= es7134_component_probe,\n\t.dapm_widgets\t\t= es7134_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(es7134_dapm_widgets),\n\t.dapm_routes\t\t= es7134_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(es7134_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver es7154_dai = {\n\t.name = \"es7154-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = (SNDRV_PCM_RATE_8000_48000 |\n\t\t\t  SNDRV_PCM_RATE_88200      |\n\t\t\t  SNDRV_PCM_RATE_96000),\n\t\t.formats = (SNDRV_PCM_FMTBIT_S16_LE  |\n\t\t\t    SNDRV_PCM_FMTBIT_S18_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE),\n\t},\n\t.ops = &es7134_dai_ops,\n};\n\nstatic const struct es7134_clock_mode es7154_modes[] = {\n\t{\n\t\t \n\t\t.rate_min = 8000,\n\t\t.rate_max = 50000,\n\t\t.mclk_fs = (unsigned int[]) { 32, 64, 128, 192, 256,\n\t\t\t\t\t      384, 512, 768, 1024 },\n\t\t.mclk_fs_num = 9,\n\t}, {\n\t\t \n\t\t.rate_min = 84000,\n\t\t.rate_max = 100000,\n\t\t.mclk_fs = (unsigned int[]) { 128, 192, 256, 384, 512,\n\t\t\t\t\t      768, 1024},\n\t\t.mclk_fs_num = 7,\n\t}\n};\n\n \nstatic const struct snd_soc_dapm_widget es7154_extra_widgets[] = {\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"PVDD\", 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route es7154_extra_routes[] = {\n\t{ \"Playback\", NULL, \"PVDD\", }\n};\n\nstatic const struct es7134_chip es7154_chip __maybe_unused = {\n\t.dai_drv = &es7154_dai,\n\t.modes = es7154_modes,\n\t.mode_num = ARRAY_SIZE(es7154_modes),\n\t.extra_routes = es7154_extra_routes,\n\t.extra_route_num = ARRAY_SIZE(es7154_extra_routes),\n\t.extra_widgets = es7154_extra_widgets,\n\t.extra_widget_num = ARRAY_SIZE(es7154_extra_widgets),\n};\n\nstatic int es7134_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct es7134_data *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->chip = of_device_get_match_data(dev);\n\tif (!priv->chip) {\n\t\tdev_err(dev, \"failed to match device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &es7134_component_driver,\n\t\t\t\t      priv->chip->dai_drv, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id es7134_ids[] = {\n\t{ .compatible = \"everest,es7134\", .data = &es7134_chip },\n\t{ .compatible = \"everest,es7144\", .data = &es7134_chip },\n\t{ .compatible = \"everest,es7154\", .data = &es7154_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, es7134_ids);\n#endif\n\nstatic struct platform_driver es7134_driver = {\n\t.driver = {\n\t\t.name = \"es7134\",\n\t\t.of_match_table = of_match_ptr(es7134_ids),\n\t},\n\t.probe = es7134_probe,\n};\n\nmodule_platform_driver(es7134_driver);\n\nMODULE_DESCRIPTION(\"ASoC ES7134 audio codec driver\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}