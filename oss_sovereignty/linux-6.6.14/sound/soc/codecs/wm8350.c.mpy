{
  "module_name": "wm8350.c",
  "hash_id": "8c84d02c4a41fcc693214361eda30a95b9d307e3cfd2a5e947344908d711f221",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8350.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/wm8350/audio.h>\n#include <linux/mfd/wm8350/core.h>\n#include <linux/regulator/consumer.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <trace/events/asoc.h>\n\n#include \"wm8350.h\"\n\n#define WM8350_OUTn_0dB 0x39\n\n#define WM8350_RAMP_NONE\t0\n#define WM8350_RAMP_UP\t\t1\n#define WM8350_RAMP_DOWN\t2\n\n \nstatic const char *supply_names[] = {\n\t\"AVDD\",\n\t\"HPVDD\",\n};\n\nstruct wm8350_output {\n\tu16 active;\n\tu16 left_vol;\n\tu16 right_vol;\n\tu16 ramp;\n\tu16 mute;\n};\n\nstruct wm8350_jack_data {\n\tstruct snd_soc_jack *jack;\n\tstruct delayed_work work;\n\tint report;\n\tint short_report;\n};\n\nstruct wm8350_data {\n\tstruct wm8350 *wm8350;\n\tstruct wm8350_output out1;\n\tstruct wm8350_output out2;\n\tstruct wm8350_jack_data hpl;\n\tstruct wm8350_jack_data hpr;\n\tstruct wm8350_jack_data mic;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n\tint fll_freq_out;\n\tint fll_freq_in;\n\tstruct delayed_work pga_work;\n};\n\n \nstatic inline int wm8350_out1_ramp_step(struct wm8350_data *wm8350_data)\n{\n\tstruct wm8350_output *out1 = &wm8350_data->out1;\n\tstruct wm8350 *wm8350 = wm8350_data->wm8350;\n\tint left_complete = 0, right_complete = 0;\n\tu16 reg, val;\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_LOUT1_VOLUME);\n\tval = (reg & WM8350_OUT1L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\n\n\tif (out1->ramp == WM8350_RAMP_UP) {\n\t\t \n\t\tif (val < out1->left_vol) {\n\t\t\tval++;\n\t\t\treg &= ~WM8350_OUT1L_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1L_VOL_SHIFT));\n\t\t} else\n\t\t\tleft_complete = 1;\n\t} else if (out1->ramp == WM8350_RAMP_DOWN) {\n\t\t \n\t\tif (val > 0) {\n\t\t\tval--;\n\t\t\treg &= ~WM8350_OUT1L_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1L_VOL_SHIFT));\n\t\t} else\n\t\t\tleft_complete = 1;\n\t} else\n\t\treturn 1;\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_ROUT1_VOLUME);\n\tval = (reg & WM8350_OUT1R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\n\tif (out1->ramp == WM8350_RAMP_UP) {\n\t\t \n\t\tif (val < out1->right_vol) {\n\t\t\tval++;\n\t\t\treg &= ~WM8350_OUT1R_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1R_VOL_SHIFT));\n\t\t} else\n\t\t\tright_complete = 1;\n\t} else if (out1->ramp == WM8350_RAMP_DOWN) {\n\t\t \n\t\tif (val > 0) {\n\t\t\tval--;\n\t\t\treg &= ~WM8350_OUT1R_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1R_VOL_SHIFT));\n\t\t} else\n\t\t\tright_complete = 1;\n\t}\n\n\t \n\tif (!left_complete || !right_complete)\n\t\twm8350_set_bits(wm8350, WM8350_LOUT1_VOLUME, WM8350_OUT1_VU);\n\n\treturn left_complete & right_complete;\n}\n\n \nstatic inline int wm8350_out2_ramp_step(struct wm8350_data *wm8350_data)\n{\n\tstruct wm8350_output *out2 = &wm8350_data->out2;\n\tstruct wm8350 *wm8350 = wm8350_data->wm8350;\n\tint left_complete = 0, right_complete = 0;\n\tu16 reg, val;\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_LOUT2_VOLUME);\n\tval = (reg & WM8350_OUT2L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\n\tif (out2->ramp == WM8350_RAMP_UP) {\n\t\t \n\t\tif (val < out2->left_vol) {\n\t\t\tval++;\n\t\t\treg &= ~WM8350_OUT2L_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1L_VOL_SHIFT));\n\t\t} else\n\t\t\tleft_complete = 1;\n\t} else if (out2->ramp == WM8350_RAMP_DOWN) {\n\t\t \n\t\tif (val > 0) {\n\t\t\tval--;\n\t\t\treg &= ~WM8350_OUT2L_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1L_VOL_SHIFT));\n\t\t} else\n\t\t\tleft_complete = 1;\n\t} else\n\t\treturn 1;\n\n\t \n\treg = wm8350_reg_read(wm8350, WM8350_ROUT2_VOLUME);\n\tval = (reg & WM8350_OUT2R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\n\tif (out2->ramp == WM8350_RAMP_UP) {\n\t\t \n\t\tif (val < out2->right_vol) {\n\t\t\tval++;\n\t\t\treg &= ~WM8350_OUT2R_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1R_VOL_SHIFT));\n\t\t} else\n\t\t\tright_complete = 1;\n\t} else if (out2->ramp == WM8350_RAMP_DOWN) {\n\t\t \n\t\tif (val > 0) {\n\t\t\tval--;\n\t\t\treg &= ~WM8350_OUT2R_VOL_MASK;\n\t\t\twm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME,\n\t\t\t\t\t reg | (val << WM8350_OUT1R_VOL_SHIFT));\n\t\t} else\n\t\t\tright_complete = 1;\n\t}\n\n\t \n\tif (!left_complete || !right_complete)\n\t\twm8350_set_bits(wm8350, WM8350_LOUT2_VOLUME, WM8350_OUT2_VU);\n\n\treturn left_complete & right_complete;\n}\n\n \nstatic void wm8350_pga_work(struct work_struct *work)\n{\n\tstruct wm8350_data *wm8350_data =\n\t\tcontainer_of(work, struct wm8350_data, pga_work.work);\n\tstruct wm8350_output *out1 = &wm8350_data->out1,\n\t    *out2 = &wm8350_data->out2;\n\tint i, out1_complete, out2_complete;\n\n\t \n\tif (out1->ramp == WM8350_RAMP_NONE && out2->ramp == WM8350_RAMP_NONE)\n\t\treturn;\n\n\t \n\tfor (i = 0; i <= 63; i++) {\n\t\tout1_complete = 1;\n\t\tout2_complete = 1;\n\t\tif (out1->ramp != WM8350_RAMP_NONE)\n\t\t\tout1_complete = wm8350_out1_ramp_step(wm8350_data);\n\t\tif (out2->ramp != WM8350_RAMP_NONE)\n\t\t\tout2_complete = wm8350_out2_ramp_step(wm8350_data);\n\n\t\t \n\t\tif (out1_complete && out2_complete)\n\t\t\tbreak;\n\n\t\t \n\t\tif (out1->ramp == WM8350_RAMP_UP ||\n\t\t    out2->ramp == WM8350_RAMP_UP) {\n\t\t\t \n\t\t\tif (i >= WM8350_OUTn_0dB)\n\t\t\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t\t\t       (2));\n\t\t\telse\n\t\t\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t\t\t       (1));\n\t\t} else\n\t\t\tudelay(50);\t \n\t}\n\n\tout1->ramp = WM8350_RAMP_NONE;\n\tout2->ramp = WM8350_RAMP_NONE;\n}\n\n \n\nstatic int pga_event(struct snd_soc_dapm_widget *w,\n\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8350_data *wm8350_data = snd_soc_component_get_drvdata(component);\n\tstruct wm8350_output *out;\n\n\tswitch (w->shift) {\n\tcase 0:\n\tcase 1:\n\t\tout = &wm8350_data->out1;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tout = &wm8350_data->out2;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Invalid shift %d\\n\", w->shift);\n\t\treturn -1;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tout->ramp = WM8350_RAMP_UP;\n\t\tout->active = 1;\n\n\t\tschedule_delayed_work(&wm8350_data->pga_work,\n\t\t\t\t      msecs_to_jiffies(1));\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tout->ramp = WM8350_RAMP_DOWN;\n\t\tout->active = 0;\n\n\t\tschedule_delayed_work(&wm8350_data->pga_work,\n\t\t\t\t      msecs_to_jiffies(1));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_put_volsw_2r_vu(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8350_data *wm8350_priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350_output *out = NULL;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint ret;\n\tunsigned int reg = mc->reg;\n\tu16 val;\n\n\t \n\tswitch (reg) {\n\tcase WM8350_LOUT1_VOLUME:\n\t\tout = &wm8350_priv->out1;\n\t\tbreak;\n\tcase WM8350_LOUT2_VOLUME:\n\t\tout = &wm8350_priv->out2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (out) {\n\t\tout->left_vol = ucontrol->value.integer.value[0];\n\t\tout->right_vol = ucontrol->value.integer.value[1];\n\t\tif (!out->active)\n\t\t\treturn 1;\n\t}\n\n\tret = snd_soc_put_volsw(kcontrol, ucontrol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = snd_soc_component_read(component, reg);\n\tsnd_soc_component_write(component, reg, val | WM8350_OUT1_VU);\n\treturn 1;\n}\n\nstatic int wm8350_get_volsw_2r(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8350_data *wm8350_priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350_output *out1 = &wm8350_priv->out1;\n\tstruct wm8350_output *out2 = &wm8350_priv->out2;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int reg = mc->reg;\n\n\t \n\tswitch (reg) {\n\tcase WM8350_LOUT1_VOLUME:\n\t\tucontrol->value.integer.value[0] = out1->left_vol;\n\t\tucontrol->value.integer.value[1] = out1->right_vol;\n\t\treturn 0;\n\n\tcase WM8350_LOUT2_VOLUME:\n\t\tucontrol->value.integer.value[0] = out2->left_vol;\n\t\tucontrol->value.integer.value[1] = out2->right_vol;\n\t\treturn 0;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn snd_soc_get_volsw(kcontrol, ucontrol);\n}\n\nstatic const char *wm8350_deemp[] = { \"None\", \"32kHz\", \"44.1kHz\", \"48kHz\" };\nstatic const char *wm8350_pol[] = { \"Normal\", \"Inv R\", \"Inv L\", \"Inv L & R\" };\nstatic const char *wm8350_dacmutem[] = { \"Normal\", \"Soft\" };\nstatic const char *wm8350_dacmutes[] = { \"Fast\", \"Slow\" };\nstatic const char *wm8350_adcfilter[] = { \"None\", \"High Pass\" };\nstatic const char *wm8350_adchp[] = { \"44.1kHz\", \"8kHz\", \"16kHz\", \"32kHz\" };\nstatic const char *wm8350_lr[] = { \"Left\", \"Right\" };\n\nstatic const struct soc_enum wm8350_enum[] = {\n\tSOC_ENUM_SINGLE(WM8350_DAC_CONTROL, 4, 4, wm8350_deemp),\n\tSOC_ENUM_SINGLE(WM8350_DAC_CONTROL, 0, 4, wm8350_pol),\n\tSOC_ENUM_SINGLE(WM8350_DAC_MUTE_VOLUME, 14, 2, wm8350_dacmutem),\n\tSOC_ENUM_SINGLE(WM8350_DAC_MUTE_VOLUME, 13, 2, wm8350_dacmutes),\n\tSOC_ENUM_SINGLE(WM8350_ADC_CONTROL, 15, 2, wm8350_adcfilter),\n\tSOC_ENUM_SINGLE(WM8350_ADC_CONTROL, 8, 4, wm8350_adchp),\n\tSOC_ENUM_SINGLE(WM8350_ADC_CONTROL, 0, 4, wm8350_pol),\n\tSOC_ENUM_SINGLE(WM8350_INPUT_MIXER_VOLUME, 15, 2, wm8350_lr),\n};\n\nstatic DECLARE_TLV_DB_SCALE(pre_amp_tlv, -1200, 3525, 0);\nstatic DECLARE_TLV_DB_SCALE(out_pga_tlv, -5700, 600, 0);\nstatic DECLARE_TLV_DB_SCALE(dac_pcm_tlv, -7163, 36, 1);\nstatic DECLARE_TLV_DB_SCALE(adc_pcm_tlv, -12700, 50, 1);\nstatic DECLARE_TLV_DB_SCALE(out_mix_tlv, -1500, 300, 1);\n\nstatic const DECLARE_TLV_DB_RANGE(capture_sd_tlv,\n\t0, 12, TLV_DB_SCALE_ITEM(-3600, 300, 1),\n\t13, 15, TLV_DB_SCALE_ITEM(0, 0, 0)\n);\n\nstatic const struct snd_kcontrol_new wm8350_snd_controls[] = {\n\tSOC_ENUM(\"Playback Deemphasis\", wm8350_enum[0]),\n\tSOC_ENUM(\"Playback DAC Inversion\", wm8350_enum[1]),\n\tSOC_DOUBLE_R_EXT_TLV(\"Playback PCM Volume\",\n\t\t\t\tWM8350_DAC_DIGITAL_VOLUME_L,\n\t\t\t\tWM8350_DAC_DIGITAL_VOLUME_R,\n\t\t\t\t0, 255, 0, wm8350_get_volsw_2r,\n\t\t\t\twm8350_put_volsw_2r_vu, dac_pcm_tlv),\n\tSOC_ENUM(\"Playback PCM Mute Function\", wm8350_enum[2]),\n\tSOC_ENUM(\"Playback PCM Mute Speed\", wm8350_enum[3]),\n\tSOC_ENUM(\"Capture PCM Filter\", wm8350_enum[4]),\n\tSOC_ENUM(\"Capture PCM HP Filter\", wm8350_enum[5]),\n\tSOC_ENUM(\"Capture ADC Inversion\", wm8350_enum[6]),\n\tSOC_DOUBLE_R_EXT_TLV(\"Capture PCM Volume\",\n\t\t\t\tWM8350_ADC_DIGITAL_VOLUME_L,\n\t\t\t\tWM8350_ADC_DIGITAL_VOLUME_R,\n\t\t\t\t0, 255, 0, wm8350_get_volsw_2r,\n\t\t\t\twm8350_put_volsw_2r_vu, adc_pcm_tlv),\n\tSOC_DOUBLE_TLV(\"Capture Sidetone Volume\",\n\t\t       WM8350_ADC_DIVIDER,\n\t\t       8, 4, 15, 1, capture_sd_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"Capture Volume\",\n\t\t\t\tWM8350_LEFT_INPUT_VOLUME,\n\t\t\t\tWM8350_RIGHT_INPUT_VOLUME,\n\t\t\t\t2, 63, 0, wm8350_get_volsw_2r,\n\t\t\t\twm8350_put_volsw_2r_vu, pre_amp_tlv),\n\tSOC_DOUBLE_R(\"Capture ZC Switch\",\n\t\t     WM8350_LEFT_INPUT_VOLUME,\n\t\t     WM8350_RIGHT_INPUT_VOLUME, 13, 1, 0),\n\tSOC_SINGLE_TLV(\"Left Input Left Sidetone Volume\",\n\t\t       WM8350_OUTPUT_LEFT_MIXER_VOLUME, 1, 7, 0, out_mix_tlv),\n\tSOC_SINGLE_TLV(\"Left Input Right Sidetone Volume\",\n\t\t       WM8350_OUTPUT_LEFT_MIXER_VOLUME,\n\t\t       5, 7, 0, out_mix_tlv),\n\tSOC_SINGLE_TLV(\"Left Input Bypass Volume\",\n\t\t       WM8350_OUTPUT_LEFT_MIXER_VOLUME,\n\t\t       9, 7, 0, out_mix_tlv),\n\tSOC_SINGLE_TLV(\"Right Input Left Sidetone Volume\",\n\t\t       WM8350_OUTPUT_RIGHT_MIXER_VOLUME,\n\t\t       1, 7, 0, out_mix_tlv),\n\tSOC_SINGLE_TLV(\"Right Input Right Sidetone Volume\",\n\t\t       WM8350_OUTPUT_RIGHT_MIXER_VOLUME,\n\t\t       5, 7, 0, out_mix_tlv),\n\tSOC_SINGLE_TLV(\"Right Input Bypass Volume\",\n\t\t       WM8350_OUTPUT_RIGHT_MIXER_VOLUME,\n\t\t       13, 7, 0, out_mix_tlv),\n\tSOC_SINGLE(\"Left Input Mixer +20dB Switch\",\n\t\t   WM8350_INPUT_MIXER_VOLUME_L, 0, 1, 0),\n\tSOC_SINGLE(\"Right Input Mixer +20dB Switch\",\n\t\t   WM8350_INPUT_MIXER_VOLUME_R, 0, 1, 0),\n\tSOC_SINGLE_TLV(\"Out4 Capture Volume\",\n\t\t       WM8350_INPUT_MIXER_VOLUME,\n\t\t       1, 7, 0, out_mix_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"Out1 Playback Volume\",\n\t\t\t\tWM8350_LOUT1_VOLUME,\n\t\t\t\tWM8350_ROUT1_VOLUME,\n\t\t\t\t2, 63, 0, wm8350_get_volsw_2r,\n\t\t\t\twm8350_put_volsw_2r_vu, out_pga_tlv),\n\tSOC_DOUBLE_R(\"Out1 Playback ZC Switch\",\n\t\t     WM8350_LOUT1_VOLUME,\n\t\t     WM8350_ROUT1_VOLUME, 13, 1, 0),\n\tSOC_DOUBLE_R_EXT_TLV(\"Out2 Playback Volume\",\n\t\t\t\tWM8350_LOUT2_VOLUME,\n\t\t\t\tWM8350_ROUT2_VOLUME,\n\t\t\t\t2, 63, 0, wm8350_get_volsw_2r,\n\t\t\t\twm8350_put_volsw_2r_vu, out_pga_tlv),\n\tSOC_DOUBLE_R(\"Out2 Playback ZC Switch\", WM8350_LOUT2_VOLUME,\n\t\t     WM8350_ROUT2_VOLUME, 13, 1, 0),\n\tSOC_SINGLE(\"Out2 Right Invert Switch\", WM8350_ROUT2_VOLUME, 10, 1, 0),\n\tSOC_SINGLE_TLV(\"Out2 Beep Volume\", WM8350_BEEP_VOLUME,\n\t\t       5, 7, 0, out_mix_tlv),\n\n\tSOC_DOUBLE_R(\"Out1 Playback Switch\",\n\t\t     WM8350_LOUT1_VOLUME,\n\t\t     WM8350_ROUT1_VOLUME,\n\t\t     14, 1, 1),\n\tSOC_DOUBLE_R(\"Out2 Playback Switch\",\n\t\t     WM8350_LOUT2_VOLUME,\n\t\t     WM8350_ROUT2_VOLUME,\n\t\t     14, 1, 1),\n};\n\n \n\n \nstatic const struct snd_kcontrol_new wm8350_left_play_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Playback Switch\",\n\t\t\tWM8350_LEFT_MIXER_CONTROL, 11, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Bypass Switch\",\n\t\t\tWM8350_LEFT_MIXER_CONTROL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Playback Switch\",\n\t\t\tWM8350_LEFT_MIXER_CONTROL, 12, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Sidetone Switch\",\n\t\t\tWM8350_LEFT_MIXER_CONTROL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Sidetone Switch\",\n\t\t\tWM8350_LEFT_MIXER_CONTROL, 1, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_right_play_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Playback Switch\",\n\t\t\tWM8350_RIGHT_MIXER_CONTROL, 12, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Bypass Switch\",\n\t\t\tWM8350_RIGHT_MIXER_CONTROL, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Playback Switch\",\n\t\t\tWM8350_RIGHT_MIXER_CONTROL, 11, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Sidetone Switch\",\n\t\t\tWM8350_RIGHT_MIXER_CONTROL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Sidetone Switch\",\n\t\t\tWM8350_RIGHT_MIXER_CONTROL, 1, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_out4_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Right Playback Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 12, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Playback Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 11, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Capture Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 9, 1, 0),\n\tSOC_DAPM_SINGLE(\"Out3 Playback Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Mixer Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Mixer Switch\",\n\t\t\tWM8350_OUT4_MIXER_CONTROL, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_out3_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left Playback Switch\",\n\t\t\tWM8350_OUT3_MIXER_CONTROL, 11, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Capture Switch\",\n\t\t\tWM8350_OUT3_MIXER_CONTROL, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"Out4 Playback Switch\",\n\t\t\tWM8350_OUT3_MIXER_CONTROL, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Mixer Switch\",\n\t\t\tWM8350_OUT3_MIXER_CONTROL, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_left_capt_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"L2 Capture Volume\",\n\t\t\t    WM8350_INPUT_MIXER_VOLUME_L, 1, 7, 0, out_mix_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"L3 Capture Volume\",\n\t\t\t    WM8350_INPUT_MIXER_VOLUME_L, 9, 7, 0, out_mix_tlv),\n\tSOC_DAPM_SINGLE(\"PGA Capture Switch\",\n\t\t\tWM8350_LEFT_INPUT_VOLUME, 14, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_right_capt_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"L2 Capture Volume\",\n\t\t\t    WM8350_INPUT_MIXER_VOLUME_R, 5, 7, 0, out_mix_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"L3 Capture Volume\",\n\t\t\t    WM8350_INPUT_MIXER_VOLUME_R, 13, 7, 0, out_mix_tlv),\n\tSOC_DAPM_SINGLE(\"PGA Capture Switch\",\n\t\t\tWM8350_RIGHT_INPUT_VOLUME, 14, 1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_left_mic_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"INN Capture Switch\", WM8350_INPUT_CONTROL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"INP Capture Switch\", WM8350_INPUT_CONTROL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Capture Switch\", WM8350_INPUT_CONTROL, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_right_mic_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"INN Capture Switch\", WM8350_INPUT_CONTROL, 9, 1, 0),\n\tSOC_DAPM_SINGLE(\"INP Capture Switch\", WM8350_INPUT_CONTROL, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Capture Switch\", WM8350_INPUT_CONTROL, 10, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8350_beep_switch_controls =\nSOC_DAPM_SINGLE(\"Switch\", WM8350_BEEP_VOLUME, 15, 1, 1);\n\n \nstatic const struct snd_kcontrol_new wm8350_out4_capture_controls =\nSOC_DAPM_ENUM(\"Route\", wm8350_enum[7]);\n\nstatic const struct snd_soc_dapm_widget wm8350_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_PGA(\"IN3R PGA\", WM8350_POWER_MGMT_2, 11, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"IN3L PGA\", WM8350_POWER_MGMT_2, 10, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_E(\"Right Out2 PGA\", WM8350_POWER_MGMT_3, 3, 0, NULL,\n\t\t\t   0, pga_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Left Out2 PGA\", WM8350_POWER_MGMT_3, 2, 0, NULL, 0,\n\t\t\t   pga_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Right Out1 PGA\", WM8350_POWER_MGMT_3, 1, 0, NULL,\n\t\t\t   0, pga_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Left Out1 PGA\", WM8350_POWER_MGMT_3, 0, 0, NULL, 0,\n\t\t\t   pga_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_MIXER(\"Right Capture Mixer\", WM8350_POWER_MGMT_2,\n\t\t\t   7, 0, &wm8350_right_capt_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_right_capt_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Capture Mixer\", WM8350_POWER_MGMT_2,\n\t\t\t   6, 0, &wm8350_left_capt_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_left_capt_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Out4 Mixer\", WM8350_POWER_MGMT_2, 5, 0,\n\t\t\t   &wm8350_out4_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_out4_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Out3 Mixer\", WM8350_POWER_MGMT_2, 4, 0,\n\t\t\t   &wm8350_out3_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_out3_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Playback Mixer\", WM8350_POWER_MGMT_2, 1, 0,\n\t\t\t   &wm8350_right_play_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_right_play_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Playback Mixer\", WM8350_POWER_MGMT_2, 0, 0,\n\t\t\t   &wm8350_left_play_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_left_play_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Mic Mixer\", WM8350_POWER_MGMT_2, 8, 0,\n\t\t\t   &wm8350_left_mic_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_left_mic_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Mic Mixer\", WM8350_POWER_MGMT_2, 9, 0,\n\t\t\t   &wm8350_right_mic_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8350_right_mic_mixer_controls)),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Out2 Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"Beep\", WM8350_POWER_MGMT_3, 7, 0,\n\t\t\t    &wm8350_beep_switch_controls),\n\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\",\n\t\t\t WM8350_POWER_MGMT_4, 3, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\",\n\t\t\t WM8350_POWER_MGMT_4, 2, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\",\n\t\t\t WM8350_POWER_MGMT_4, 5, 0),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\",\n\t\t\t WM8350_POWER_MGMT_4, 4, 0),\n\n\tSND_SOC_DAPM_MICBIAS(\"Mic Bias\", WM8350_POWER_MGMT_1, 4, 0),\n\n\tSND_SOC_DAPM_MUX(\"Out4 Capture Channel\", SND_SOC_NOPM, 0, 0,\n\t\t\t &wm8350_out4_capture_controls),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT1R\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1L\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2R\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2L\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT4\"),\n\n\tSND_SOC_DAPM_INPUT(\"IN1RN\"),\n\tSND_SOC_DAPM_INPUT(\"IN1RP\"),\n\tSND_SOC_DAPM_INPUT(\"IN2R\"),\n\tSND_SOC_DAPM_INPUT(\"IN1LP\"),\n\tSND_SOC_DAPM_INPUT(\"IN1LN\"),\n\tSND_SOC_DAPM_INPUT(\"IN2L\"),\n\tSND_SOC_DAPM_INPUT(\"IN3R\"),\n\tSND_SOC_DAPM_INPUT(\"IN3L\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8350_dapm_routes[] = {\n\n\t \n\t{\"Left Playback Mixer\", \"Playback Switch\", \"Left DAC\"},\n\t{\"Left Playback Mixer\", \"Left Bypass Switch\", \"IN3L PGA\"},\n\t{\"Left Playback Mixer\", \"Right Playback Switch\", \"Right DAC\"},\n\t{\"Left Playback Mixer\", \"Left Sidetone Switch\", \"Left Mic Mixer\"},\n\t{\"Left Playback Mixer\", \"Right Sidetone Switch\", \"Right Mic Mixer\"},\n\n\t \n\t{\"Right Playback Mixer\", \"Playback Switch\", \"Right DAC\"},\n\t{\"Right Playback Mixer\", \"Right Bypass Switch\", \"IN3R PGA\"},\n\t{\"Right Playback Mixer\", \"Left Playback Switch\", \"Left DAC\"},\n\t{\"Right Playback Mixer\", \"Left Sidetone Switch\", \"Left Mic Mixer\"},\n\t{\"Right Playback Mixer\", \"Right Sidetone Switch\", \"Right Mic Mixer\"},\n\n\t \n\t{\"Out4 Mixer\", \"Right Playback Switch\", \"Right DAC\"},\n\t{\"Out4 Mixer\", \"Left Playback Switch\", \"Left DAC\"},\n\t{\"Out4 Mixer\", \"Right Capture Switch\", \"Right Capture Mixer\"},\n\t{\"Out4 Mixer\", \"Out3 Playback Switch\", \"Out3 Mixer\"},\n\t{\"Out4 Mixer\", \"Right Mixer Switch\", \"Right Playback Mixer\"},\n\t{\"Out4 Mixer\", \"Left Mixer Switch\", \"Left Playback Mixer\"},\n\t{\"OUT4\", NULL, \"Out4 Mixer\"},\n\n\t \n\t{\"Out3 Mixer\", \"Left Playback Switch\", \"Left DAC\"},\n\t{\"Out3 Mixer\", \"Left Capture Switch\", \"Left Capture Mixer\"},\n\t{\"Out3 Mixer\", \"Left Mixer Switch\", \"Left Playback Mixer\"},\n\t{\"Out3 Mixer\", \"Out4 Playback Switch\", \"Out4 Mixer\"},\n\t{\"OUT3\", NULL, \"Out3 Mixer\"},\n\n\t \n\t{\"Right Out2 PGA\", NULL, \"Right Playback Mixer\"},\n\t{\"Left Out2 PGA\", NULL, \"Left Playback Mixer\"},\n\t{\"OUT2L\", NULL, \"Left Out2 PGA\"},\n\t{\"OUT2R\", NULL, \"Right Out2 PGA\"},\n\n\t \n\t{\"Right Out1 PGA\", NULL, \"Right Playback Mixer\"},\n\t{\"Left Out1 PGA\", NULL, \"Left Playback Mixer\"},\n\t{\"OUT1L\", NULL, \"Left Out1 PGA\"},\n\t{\"OUT1R\", NULL, \"Right Out1 PGA\"},\n\n\t \n\t{\"Left ADC\", NULL, \"Left Capture Mixer\"},\n\t{\"Right ADC\", NULL, \"Right Capture Mixer\"},\n\n\t \n\t{\"Left Capture Mixer\", \"L2 Capture Volume\", \"IN2L\"},\n\t{\"Left Capture Mixer\", \"L3 Capture Volume\", \"IN3L PGA\"},\n\t{\"Left Capture Mixer\", \"PGA Capture Switch\", \"Left Mic Mixer\"},\n\t{\"Left Capture Mixer\", NULL, \"Out4 Capture Channel\"},\n\n\t \n\t{\"Right Capture Mixer\", \"L2 Capture Volume\", \"IN2R\"},\n\t{\"Right Capture Mixer\", \"L3 Capture Volume\", \"IN3R PGA\"},\n\t{\"Right Capture Mixer\", \"PGA Capture Switch\", \"Right Mic Mixer\"},\n\t{\"Right Capture Mixer\", NULL, \"Out4 Capture Channel\"},\n\n\t \n\t{\"IN3L PGA\", NULL, \"IN3L\"},\n\t{\"IN3R PGA\", NULL, \"IN3R\"},\n\n\t \n\t{\"Left Mic Mixer\", \"INN Capture Switch\", \"IN1LN\"},\n\t{\"Left Mic Mixer\", \"INP Capture Switch\", \"IN1LP\"},\n\t{\"Left Mic Mixer\", \"IN2 Capture Switch\", \"IN2L\"},\n\n\t \n\t{\"Right Mic Mixer\", \"INN Capture Switch\", \"IN1RN\"},\n\t{\"Right Mic Mixer\", \"INP Capture Switch\", \"IN1RP\"},\n\t{\"Right Mic Mixer\", \"IN2 Capture Switch\", \"IN2R\"},\n\n\t \n\t{\"Out4 Capture Channel\", NULL, \"Out4 Mixer\"},\n\n\t \n\t{\"Beep\", NULL, \"IN3R PGA\"},\n};\n\nstatic int wm8350_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8350_data *wm8350_data = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = wm8350_data->wm8350;\n\tu16 fll_4;\n\n\tswitch (clk_id) {\n\tcase WM8350_MCLK_SEL_MCLK:\n\t\twm8350_clear_bits(wm8350, WM8350_CLOCK_CONTROL_1,\n\t\t\t\t  WM8350_MCLK_SEL);\n\t\tbreak;\n\tcase WM8350_MCLK_SEL_PLL_MCLK:\n\tcase WM8350_MCLK_SEL_PLL_DAC:\n\tcase WM8350_MCLK_SEL_PLL_ADC:\n\tcase WM8350_MCLK_SEL_PLL_32K:\n\t\twm8350_set_bits(wm8350, WM8350_CLOCK_CONTROL_1,\n\t\t\t\tWM8350_MCLK_SEL);\n\t\tfll_4 = snd_soc_component_read(component, WM8350_FLL_CONTROL_4) &\n\t\t    ~WM8350_FLL_CLK_SRC_MASK;\n\t\tsnd_soc_component_write(component, WM8350_FLL_CONTROL_4, fll_4 | clk_id);\n\t\tbreak;\n\t}\n\n\t \n\tif (dir == SND_SOC_CLOCK_OUT)\n\t\twm8350_set_bits(wm8350, WM8350_CLOCK_CONTROL_2,\n\t\t\t\tWM8350_MCLK_DIR);\n\telse\n\t\twm8350_clear_bits(wm8350, WM8350_CLOCK_CONTROL_2,\n\t\t\t\t  WM8350_MCLK_DIR);\n\n\treturn 0;\n}\n\nstatic int wm8350_set_clkdiv(struct snd_soc_dai *codec_dai, int div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 val;\n\n\tswitch (div_id) {\n\tcase WM8350_ADC_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_ADC_DIVIDER) &\n\t\t    ~WM8350_ADC_CLKDIV_MASK;\n\t\tsnd_soc_component_write(component, WM8350_ADC_DIVIDER, val | div);\n\t\tbreak;\n\tcase WM8350_DAC_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_DAC_CLOCK_CONTROL) &\n\t\t    ~WM8350_DAC_CLKDIV_MASK;\n\t\tsnd_soc_component_write(component, WM8350_DAC_CLOCK_CONTROL, val | div);\n\t\tbreak;\n\tcase WM8350_BCLK_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_CLOCK_CONTROL_1) &\n\t\t    ~WM8350_BCLK_DIV_MASK;\n\t\tsnd_soc_component_write(component, WM8350_CLOCK_CONTROL_1, val | div);\n\t\tbreak;\n\tcase WM8350_OPCLK_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_CLOCK_CONTROL_1) &\n\t\t    ~WM8350_OPCLK_DIV_MASK;\n\t\tsnd_soc_component_write(component, WM8350_CLOCK_CONTROL_1, val | div);\n\t\tbreak;\n\tcase WM8350_SYS_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_CLOCK_CONTROL_1) &\n\t\t    ~WM8350_MCLK_DIV_MASK;\n\t\tsnd_soc_component_write(component, WM8350_CLOCK_CONTROL_1, val | div);\n\t\tbreak;\n\tcase WM8350_DACLR_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_DAC_LR_RATE) &\n\t\t    ~WM8350_DACLRC_RATE_MASK;\n\t\tsnd_soc_component_write(component, WM8350_DAC_LR_RATE, val | div);\n\t\tbreak;\n\tcase WM8350_ADCLR_CLKDIV:\n\t\tval = snd_soc_component_read(component, WM8350_ADC_LR_RATE) &\n\t\t    ~WM8350_ADCLRC_RATE_MASK;\n\t\tsnd_soc_component_write(component, WM8350_ADC_LR_RATE, val | div);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = snd_soc_component_read(component, WM8350_AI_FORMATING) &\n\t    ~(WM8350_AIF_BCLK_INV | WM8350_AIF_LRCLK_INV | WM8350_AIF_FMT_MASK);\n\tu16 master = snd_soc_component_read(component, WM8350_AI_DAC_CONTROL) &\n\t    ~WM8350_BCLK_MSTR;\n\tu16 dac_lrc = snd_soc_component_read(component, WM8350_DAC_LR_RATE) &\n\t    ~WM8350_DACLRC_ENA;\n\tu16 adc_lrc = snd_soc_component_read(component, WM8350_ADC_LR_RATE) &\n\t    ~WM8350_ADCLRC_ENA;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster |= WM8350_BCLK_MSTR;\n\t\tdac_lrc |= WM8350_DACLRC_ENA;\n\t\tadc_lrc |= WM8350_ADCLRC_ENA;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x2 << 8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x1 << 8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x3 << 8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x3 << 8 | WM8350_AIF_LRCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= WM8350_AIF_LRCLK_INV | WM8350_AIF_BCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= WM8350_AIF_BCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= WM8350_AIF_LRCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8350_AI_FORMATING, iface);\n\tsnd_soc_component_write(component, WM8350_AI_DAC_CONTROL, master);\n\tsnd_soc_component_write(component, WM8350_DAC_LR_RATE, dac_lrc);\n\tsnd_soc_component_write(component, WM8350_ADC_LR_RATE, adc_lrc);\n\treturn 0;\n}\n\nstatic int wm8350_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *codec_dai)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8350_data *wm8350_data = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = wm8350_data->wm8350;\n\tu16 iface = snd_soc_component_read(component, WM8350_AI_FORMATING) &\n\t    ~WM8350_AIF_WL_MASK;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x1 << 10;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x2 << 10;\n\t\tbreak;\n\tcase 32:\n\t\tiface |= 0x3 << 10;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8350_AI_FORMATING, iface);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (params_rate(params) < 24000)\n\t\t\twm8350_set_bits(wm8350, WM8350_DAC_MUTE_VOLUME,\n\t\t\t\t\tWM8350_DAC_SB_FILT);\n\t\telse\n\t\t\twm8350_clear_bits(wm8350, WM8350_DAC_MUTE_VOLUME,\n\t\t\t\t\t  WM8350_DAC_SB_FILT);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8350_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val;\n\n\tif (mute)\n\t\tval = WM8350_DAC_MUTE_ENA;\n\telse\n\t\tval = 0;\n\n\tsnd_soc_component_update_bits(component, WM8350_DAC_MUTE, WM8350_DAC_MUTE_ENA, val);\n\n\treturn 0;\n}\n\n \nstruct _fll_div {\n\tint div;\t\t \n\tint n;\n\tint k;\n\tint ratio;\t\t \n};\n\n \n#define FIXED_FLL_SIZE ((1 << 16) * 10)\n\nstatic inline int fll_factors(struct _fll_div *fll_div, unsigned int input,\n\t\t\t      unsigned int output)\n{\n\tu64 Kpart;\n\tunsigned int t1, t2, K, Nmod;\n\n\tif (output >= 2815250 && output <= 3125000)\n\t\tfll_div->div = 0x4;\n\telse if (output >= 5625000 && output <= 6250000)\n\t\tfll_div->div = 0x3;\n\telse if (output >= 11250000 && output <= 12500000)\n\t\tfll_div->div = 0x2;\n\telse if (output >= 22500000 && output <= 25000000)\n\t\tfll_div->div = 0x1;\n\telse {\n\t\tprintk(KERN_ERR \"wm8350: fll freq %d out of range\\n\", output);\n\t\treturn -EINVAL;\n\t}\n\n\tif (input > 48000)\n\t\tfll_div->ratio = 1;\n\telse\n\t\tfll_div->ratio = 8;\n\n\tt1 = output * (1 << (fll_div->div + 1));\n\tt2 = input * fll_div->ratio;\n\n\tfll_div->n = t1 / t2;\n\tNmod = t1 % t2;\n\n\tif (Nmod) {\n\t\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\t\tdo_div(Kpart, t2);\n\t\tK = Kpart & 0xFFFFFFFF;\n\n\t\t \n\t\tif ((K % 10) >= 5)\n\t\t\tK += 5;\n\n\t\t \n\t\tK /= 10;\n\t\tfll_div->k = K;\n\t} else\n\t\tfll_div->k = 0;\n\n\treturn 0;\n}\n\nstatic int wm8350_set_fll(struct snd_soc_dai *codec_dai,\n\t\t\t  int pll_id, int source, unsigned int freq_in,\n\t\t\t  unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8350_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tstruct _fll_div fll_div;\n\tint ret = 0;\n\tu16 fll_1, fll_4;\n\n\tif (freq_in == priv->fll_freq_in && freq_out == priv->fll_freq_out)\n\t\treturn 0;\n\n\t \n\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4,\n\t\t\t  WM8350_FLL_ENA | WM8350_FLL_OSC_ENA);\n\n\tif (freq_out == 0 || freq_in == 0)\n\t\treturn ret;\n\n\tret = fll_factors(&fll_div, freq_in, freq_out);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_dbg(wm8350->dev,\n\t\t\"FLL in %u FLL out %u N 0x%x K 0x%x div %d ratio %d\",\n\t\tfreq_in, freq_out, fll_div.n, fll_div.k, fll_div.div,\n\t\tfll_div.ratio);\n\n\t \n\tfll_1 = snd_soc_component_read(component, WM8350_FLL_CONTROL_1) &\n\t    ~(WM8350_FLL_OUTDIV_MASK | WM8350_FLL_RSP_RATE_MASK | 0xc000);\n\tsnd_soc_component_write(component, WM8350_FLL_CONTROL_1,\n\t\t\t   fll_1 | (fll_div.div << 8) | 0x50);\n\tsnd_soc_component_write(component, WM8350_FLL_CONTROL_2,\n\t\t\t   (fll_div.ratio << 11) | (fll_div.\n\t\t\t\t\t\t    n & WM8350_FLL_N_MASK));\n\tsnd_soc_component_write(component, WM8350_FLL_CONTROL_3, fll_div.k);\n\tfll_4 = snd_soc_component_read(component, WM8350_FLL_CONTROL_4) &\n\t    ~(WM8350_FLL_FRAC | WM8350_FLL_SLOW_LOCK_REF);\n\tsnd_soc_component_write(component, WM8350_FLL_CONTROL_4,\n\t\t\t   fll_4 | (fll_div.k ? WM8350_FLL_FRAC : 0) |\n\t\t\t   (fll_div.ratio == 8 ? WM8350_FLL_SLOW_LOCK_REF : 0));\n\n\t \n\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_FLL_OSC_ENA);\n\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_FLL_ENA);\n\n\tpriv->fll_freq_out = freq_out;\n\tpriv->fll_freq_in = freq_in;\n\n\treturn 0;\n}\n\nstatic int wm8350_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8350_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tstruct wm8350_audio_platform_data *platform =\n\t\twm8350->codec.platform_data;\n\tu16 pm1;\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\n\t\t    ~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\n\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t pm1 | WM8350_VMID_50K |\n\t\t\t\t platform->codec_current_on << 14);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1);\n\t\tpm1 &= ~WM8350_VMID_MASK;\n\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t pm1 | WM8350_VMID_50K);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t\t\t    priv->supplies);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_4,\n\t\t\t\t\tWM8350_SYSCLK_ENA);\n\n\t\t\t \n\t\t\twm8350_set_bits(wm8350, WM8350_DAC_MUTE,\n\t\t\t\t\tWM8350_DAC_MUTE_ENA);\n\n\t\t\t \n\t\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\n\t\t\t\t\t platform->dis_out1 |\n\t\t\t\t\t (platform->dis_out2 << 2) |\n\t\t\t\t\t (platform->dis_out3 << 4) |\n\t\t\t\t\t (platform->dis_out4 << 6));\n\n\t\t\t \n\t\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t\t       (platform->\n\t\t\t\t\t\t\tcap_discharge_msecs));\n\n\t\t\t \n\t\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\n\t\t\t\t\t (platform->vmid_s_curve << 8));\n\n\t\t\t \n\t\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t\t (platform->\n\t\t\t\t\t  codec_current_charge << 14) |\n\t\t\t\t\t WM8350_VMID_5K | WM8350_VMIDEN |\n\t\t\t\t\t WM8350_VBUFEN);\n\n\t\t\t \n\t\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t\t       (platform->\n\t\t\t\t\t\t\tvmid_charge_msecs));\n\n\t\t\t \n\t\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\n\t\t\t    ~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\n\t\t\tpm1 |= WM8350_VMID_300K |\n\t\t\t\t(platform->codec_current_standby << 14);\n\t\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t\t pm1);\n\n\n\t\t\t \n\t\t\tpm1 |= WM8350_BIASEN;\n\t\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\n\n\t\t\t \n\t\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL, 0);\n\n\t\t} else {\n\t\t\t \n\t\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\n\t\t\t    ~(WM8350_VMID_MASK | WM8350_CODEC_ISEL_MASK);\n\t\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t\t pm1 | WM8350_VMID_300K |\n\t\t\t\t\t (platform->\n\t\t\t\t\t  codec_current_standby << 14));\n\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\n\t\t \n\t\twm8350_set_bits(wm8350, WM8350_DAC_MUTE, WM8350_DAC_MUTE_ENA);\n\n\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_3,\n\t\t\t\tWM8350_OUT1L_ENA | WM8350_OUT1R_ENA |\n\t\t\t\tWM8350_OUT2L_ENA | WM8350_OUT2R_ENA);\n\n\t\t \n\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\n\t\t\t\t (platform->vmid_s_curve << 8));\n\n\t\t \n\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\n\t\t    ~WM8350_VMIDEN;\n\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\n\n\t\t \n\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t       (platform->\n\t\t\t\t\t\tvmid_discharge_msecs));\n\n\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL,\n\t\t\t\t (platform->vmid_s_curve << 8) |\n\t\t\t\t platform->dis_out1 |\n\t\t\t\t (platform->dis_out2 << 2) |\n\t\t\t\t (platform->dis_out3 << 4) |\n\t\t\t\t (platform->dis_out4 << 6));\n\n\t\t \n\t\tpm1 = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_1) &\n\t\t    ~(WM8350_VBUFEN | WM8350_VMID_MASK);\n\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t pm1 | WM8350_OUTPUT_DRAIN_EN);\n\n\t\t \n\t\tschedule_timeout_interruptible(msecs_to_jiffies\n\t\t\t\t\t       (platform->drain_msecs));\n\n\t\tpm1 &= ~WM8350_BIASEN;\n\t\twm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);\n\n\t\t \n\t\twm8350_reg_write(wm8350, WM8350_ANTI_POP_CONTROL, 0);\n\n\t\twm8350_clear_bits(wm8350, WM8350_LOUT1_VOLUME,\n\t\t\t\t  WM8350_OUT1L_ENA);\n\t\twm8350_clear_bits(wm8350, WM8350_ROUT1_VOLUME,\n\t\t\t\t  WM8350_OUT1R_ENA);\n\t\twm8350_clear_bits(wm8350, WM8350_LOUT2_VOLUME,\n\t\t\t\t  WM8350_OUT2L_ENA);\n\t\twm8350_clear_bits(wm8350, WM8350_ROUT2_VOLUME,\n\t\t\t\t  WM8350_OUT2R_ENA);\n\n\t\t \n\t\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4,\n\t\t\t\t  WM8350_SYSCLK_ENA);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t       priv->supplies);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void wm8350_hp_work(struct wm8350_data *priv,\n\t\t\t   struct wm8350_jack_data *jack,\n\t\t\t   u16 mask)\n{\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tu16 reg;\n\tint report;\n\n\treg = wm8350_reg_read(wm8350, WM8350_JACK_PIN_STATUS);\n\tif (reg & mask)\n\t\treport = jack->report;\n\telse\n\t\treport = 0;\n\n\tsnd_soc_jack_report(jack->jack, report, jack->report);\n\n}\n\nstatic void wm8350_hpl_work(struct work_struct *work)\n{\n\tstruct wm8350_data *priv =\n\t    container_of(work, struct wm8350_data, hpl.work.work);\n\n\twm8350_hp_work(priv, &priv->hpl, WM8350_JACK_L_LVL);\n}\n\nstatic void wm8350_hpr_work(struct work_struct *work)\n{\n\tstruct wm8350_data *priv =\n\t    container_of(work, struct wm8350_data, hpr.work.work);\n\t\n\twm8350_hp_work(priv, &priv->hpr, WM8350_JACK_R_LVL);\n}\n\nstatic irqreturn_t wm8350_hpl_jack_handler(int irq, void *data)\n{\n\tstruct wm8350_data *priv = data;\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\n\ttrace_snd_soc_jack_irq(\"WM8350 HPL\");\n#endif\n\n\tif (device_may_wakeup(wm8350->dev))\n\t\tpm_wakeup_event(wm8350->dev, 250);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &priv->hpl.work, msecs_to_jiffies(200));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wm8350_hpr_jack_handler(int irq, void *data)\n{\n\tstruct wm8350_data *priv = data;\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\n\ttrace_snd_soc_jack_irq(\"WM8350 HPR\");\n#endif\n\n\tif (device_may_wakeup(wm8350->dev))\n\t\tpm_wakeup_event(wm8350->dev, 250);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &priv->hpr.work, msecs_to_jiffies(200));\n\n\treturn IRQ_HANDLED;\n}\n\n \nint wm8350_hp_jack_detect(struct snd_soc_component *component, enum wm8350_jack which,\n\t\t\t  struct snd_soc_jack *jack, int report)\n{\n\tstruct wm8350_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tint ena;\n\n\tswitch (which) {\n\tcase WM8350_JDL:\n\t\tpriv->hpl.jack = jack;\n\t\tpriv->hpl.report = report;\n\t\tena = WM8350_JDL_ENA;\n\t\tbreak;\n\n\tcase WM8350_JDR:\n\t\tpriv->hpr.jack = jack;\n\t\tpriv->hpr.report = report;\n\t\tena = WM8350_JDR_ENA;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (report) {\n\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\n\t\twm8350_set_bits(wm8350, WM8350_JACK_DETECT, ena);\n\t} else {\n\t\twm8350_clear_bits(wm8350, WM8350_JACK_DETECT, ena);\n\t}\n\n\t \n\tswitch (which) {\n\tcase WM8350_JDL:\n\t\twm8350_hpl_jack_handler(0, priv);\n\t\tbreak;\n\tcase WM8350_JDR:\n\t\twm8350_hpr_jack_handler(0, priv);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_hp_jack_detect);\n\nstatic irqreturn_t wm8350_mic_handler(int irq, void *data)\n{\n\tstruct wm8350_data *priv = data;\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\tu16 reg;\n\tint report = 0;\n\n#ifndef CONFIG_SND_SOC_WM8350_MODULE\n\ttrace_snd_soc_jack_irq(\"WM8350 mic\");\n#endif\n\n\treg = wm8350_reg_read(wm8350, WM8350_JACK_PIN_STATUS);\n\tif (reg & WM8350_JACK_MICSCD_LVL)\n\t\treport |= priv->mic.short_report;\n\tif (reg & WM8350_JACK_MICSD_LVL)\n\t\treport |= priv->mic.report;\n\n\tsnd_soc_jack_report(priv->mic.jack, report,\n\t\t\t    priv->mic.report | priv->mic.short_report);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint wm8350_mic_jack_detect(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_jack *jack,\n\t\t\t   int detect_report, int short_report)\n{\n\tstruct wm8350_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = priv->wm8350;\n\n\tpriv->mic.jack = jack;\n\tpriv->mic.report = detect_report;\n\tpriv->mic.short_report = short_report;\n\n\tif (detect_report || short_report) {\n\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\n\t\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\tWM8350_MIC_DET_ENA);\n\t} else {\n\t\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_1,\n\t\t\t\t  WM8350_MIC_DET_ENA);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm8350_mic_jack_detect);\n\n#define WM8350_RATES (SNDRV_PCM_RATE_8000_96000)\n\n#define WM8350_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8350_dai_ops = {\n\t .hw_params\t= wm8350_pcm_hw_params,\n\t .mute_stream\t= wm8350_mute,\n\t .set_fmt\t= wm8350_set_dai_fmt,\n\t .set_sysclk\t= wm8350_set_dai_sysclk,\n\t .set_pll\t= wm8350_set_fll,\n\t .set_clkdiv\t= wm8350_set_clkdiv,\n\t .no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8350_dai = {\n\t.name = \"wm8350-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8350_RATES,\n\t\t.formats = WM8350_FORMATS,\n\t},\n\t.capture = {\n\t\t .stream_name = \"Capture\",\n\t\t .channels_min = 1,\n\t\t .channels_max = 2,\n\t\t .rates = WM8350_RATES,\n\t\t .formats = WM8350_FORMATS,\n\t },\n\t.ops = &wm8350_dai_ops,\n};\n\nstatic  int wm8350_component_probe(struct snd_soc_component *component)\n{\n\tstruct wm8350 *wm8350 = dev_get_platdata(component->dev);\n\tstruct wm8350_data *priv;\n\tstruct wm8350_output *out1;\n\tstruct wm8350_output *out2;\n\tint ret, i;\n\n\tif (wm8350->codec.platform_data == NULL) {\n\t\tdev_err(component->dev, \"No audio platform data supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(component->dev, sizeof(struct wm8350_data),\n\t\t\t    GFP_KERNEL);\n\tif (priv == NULL)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_component_init_regmap(component, wm8350->regmap);\n\tsnd_soc_component_set_drvdata(component, priv);\n\n\tpriv->wm8350 = wm8350;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(wm8350->dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t priv->supplies);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\n\n\tINIT_DELAYED_WORK(&priv->pga_work, wm8350_pga_work);\n\tINIT_DELAYED_WORK(&priv->hpl.work, wm8350_hpl_work);\n\tINIT_DELAYED_WORK(&priv->hpr.work, wm8350_hpr_work);\n\n\t \n\twm8350_set_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\n\n\t \n\tsnd_soc_component_write(component, WM8350_SECURITY, 0xa7);\n\tsnd_soc_component_write(component, 0xde, 0x13);\n\tsnd_soc_component_write(component, WM8350_SECURITY, 0);\n\n\t \n\tout1 = &priv->out1;\n\tout2 = &priv->out2;\n\tout1->left_vol = (wm8350_reg_read(wm8350, WM8350_LOUT1_VOLUME) &\n\t\t\t  WM8350_OUT1L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\n\tout1->right_vol = (wm8350_reg_read(wm8350, WM8350_ROUT1_VOLUME) &\n\t\t\t   WM8350_OUT1R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\n\tout2->left_vol = (wm8350_reg_read(wm8350, WM8350_LOUT2_VOLUME) &\n\t\t\t  WM8350_OUT2L_VOL_MASK) >> WM8350_OUT1L_VOL_SHIFT;\n\tout2->right_vol = (wm8350_reg_read(wm8350, WM8350_ROUT2_VOLUME) &\n\t\t\t   WM8350_OUT2R_VOL_MASK) >> WM8350_OUT1R_VOL_SHIFT;\n\twm8350_reg_write(wm8350, WM8350_LOUT1_VOLUME, 0);\n\twm8350_reg_write(wm8350, WM8350_ROUT1_VOLUME, 0);\n\twm8350_reg_write(wm8350, WM8350_LOUT2_VOLUME, 0);\n\twm8350_reg_write(wm8350, WM8350_ROUT2_VOLUME, 0);\n\n\t \n\twm8350_set_bits(wm8350, WM8350_LOUT1_VOLUME,\n\t\t\tWM8350_OUT1_VU | WM8350_OUT1L_MUTE);\n\twm8350_set_bits(wm8350, WM8350_LOUT2_VOLUME,\n\t\t\tWM8350_OUT2_VU | WM8350_OUT2L_MUTE);\n\twm8350_set_bits(wm8350, WM8350_ROUT1_VOLUME,\n\t\t\tWM8350_OUT1_VU | WM8350_OUT1R_MUTE);\n\twm8350_set_bits(wm8350, WM8350_ROUT2_VOLUME,\n\t\t\tWM8350_OUT2_VU | WM8350_OUT2R_MUTE);\n\n\t \n\twm8350_clear_bits(wm8350, WM8350_AI_FORMATING, WM8350_AIF_TRI);\n\n\t \n\twm8350_clear_bits(wm8350, WM8350_ADC_DAC_COMP,\n\t\t\t  WM8350_DAC_COMP | WM8350_LOOPBACK);\n\n\t \n\twm8350_clear_bits(wm8350, WM8350_JACK_DETECT,\n\t\t\t  WM8350_JDL_ENA | WM8350_JDR_ENA);\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_L,\n\t\t\t    wm8350_hpl_jack_handler, 0, \"Left jack detect\",\n\t\t\t    priv);\n\tif (ret != 0)\n\t\tgoto err;\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_R,\n\t\t\t    wm8350_hpr_jack_handler, 0, \"Right jack detect\",\n\t\t\t    priv);\n\tif (ret != 0)\n\t\tgoto free_jck_det_l;\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_CODEC_MICSCD,\n\t\t\t    wm8350_mic_handler, 0, \"Microphone short\", priv);\n\tif (ret != 0)\n\t\tgoto free_jck_det_r;\n\n\tret = wm8350_register_irq(wm8350, WM8350_IRQ_CODEC_MICD,\n\t\t\t    wm8350_mic_handler, 0, \"Microphone detect\", priv);\n\tif (ret != 0)\n\t\tgoto free_micscd;\n\n\treturn 0;\n\nfree_micscd:\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_MICSCD, priv);\nfree_jck_det_r:\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_R, priv);\nfree_jck_det_l:\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_L, priv);\nerr:\n\treturn ret;\n}\n\nstatic void wm8350_component_remove(struct snd_soc_component *component)\n{\n\tstruct wm8350_data *priv = snd_soc_component_get_drvdata(component);\n\tstruct wm8350 *wm8350 = dev_get_platdata(component->dev);\n\n\twm8350_clear_bits(wm8350, WM8350_JACK_DETECT,\n\t\t\t  WM8350_JDL_ENA | WM8350_JDR_ENA);\n\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_4, WM8350_TOCLK_ENA);\n\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_MICD, priv);\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_MICSCD, priv);\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_L, priv);\n\twm8350_free_irq(wm8350, WM8350_IRQ_CODEC_JCK_DET_R, priv);\n\n\tpriv->hpl.jack = NULL;\n\tpriv->hpr.jack = NULL;\n\tpriv->mic.jack = NULL;\n\n\tcancel_delayed_work_sync(&priv->hpl.work);\n\tcancel_delayed_work_sync(&priv->hpr.work);\n\n\t \n\tflush_delayed_work(&priv->pga_work);\n\n\twm8350_clear_bits(wm8350, WM8350_POWER_MGMT_5, WM8350_CODEC_ENA);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8350 = {\n\t.probe\t\t\t= wm8350_component_probe,\n\t.remove\t\t\t= wm8350_component_remove,\n\t.set_bias_level\t\t= wm8350_set_bias_level,\n\t.controls\t\t= wm8350_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8350_snd_controls),\n\t.dapm_widgets\t\t= wm8350_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8350_dapm_widgets),\n\t.dapm_routes\t\t= wm8350_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8350_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm8350_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_component_dev_wm8350,\n\t\t\t&wm8350_dai, 1);\n}\n\nstatic struct platform_driver wm8350_codec_driver = {\n\t.driver = {\n\t\t   .name = \"wm8350-codec\",\n\t\t   },\n\t.probe = wm8350_probe,\n};\n\nmodule_platform_driver(wm8350_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8350 driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:wm8350-codec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}