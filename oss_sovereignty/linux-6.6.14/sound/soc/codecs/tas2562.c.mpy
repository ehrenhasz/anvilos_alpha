{
  "module_name": "tas2562.c",
  "hash_id": "328264b6b87fde801c5d995a27af62eb0710b607e1add55dd7017446523d10a1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2562.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/delay.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"tas2562.h\"\n\n#define TAS2562_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FORMAT_S32_LE)\n\n \nstatic const unsigned int float_vol_db_lookup[] = {\n0x00000d43, 0x000010b2, 0x00001505, 0x00001a67, 0x00002151,\n0x000029f1, 0x000034cd, 0x00004279, 0x000053af, 0x0000695b,\n0x0000695b, 0x0000a6fa, 0x0000d236, 0x000108a4, 0x00014d2a,\n0x0001a36e, 0x00021008, 0x000298c0, 0x000344df, 0x00041d8f,\n0x00052e5a, 0x000685c8, 0x00083621, 0x000a566d, 0x000d03a7,\n0x0010624d, 0x0014a050, 0x0019f786, 0x0020b0bc, 0x0029279d,\n0x0033cf8d, 0x004139d3, 0x00521d50, 0x00676044, 0x0082248a,\n0x00a3d70a, 0x00ce4328, 0x0103ab3d, 0x0146e75d, 0x019b8c27,\n0x02061b89, 0x028c423f, 0x03352529, 0x0409c2b0, 0x05156d68,\n0x080e9f96, 0x0a24b062, 0x0cc509ab, 0x10137987, 0x143d1362,\n0x197a967f, 0x2013739e, 0x28619ae9, 0x32d64617, 0x40000000\n};\n\nstruct tas2562_data {\n\tstruct snd_soc_component *component;\n\tstruct gpio_desc *sdz_gpio;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct i2c_client *client;\n\tint v_sense_slot;\n\tint i_sense_slot;\n\tint volume_lvl;\n\tint model_id;\n\tbool dac_powered;\n\tbool unmuted;\n};\n\nenum tas256x_model {\n\tTAS2562,\n\tTAS2563,\n\tTAS2564,\n\tTAS2110,\n};\n\nstatic int tas2562_set_samplerate(struct tas2562_data *tas2562, int samplerate)\n{\n\tint samp_rate;\n\tint ramp_rate;\n\n\tswitch (samplerate) {\n\tcase 7350:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_7305_8KHZ;\n\t\tbreak;\n\tcase 8000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_7305_8KHZ;\n\t\tbreak;\n\tcase 14700:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_14_7_16KHZ;\n\t\tbreak;\n\tcase 16000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_14_7_16KHZ;\n\t\tbreak;\n\tcase 22050:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_22_05_24KHZ;\n\t\tbreak;\n\tcase 24000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_22_05_24KHZ;\n\t\tbreak;\n\tcase 29400:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_29_4_32KHZ;\n\t\tbreak;\n\tcase 32000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_29_4_32KHZ;\n\t\tbreak;\n\tcase 44100:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_44_1_48KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_44_1_48KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_88_2_96KHZ;\n\t\tbreak;\n\tcase 96000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_88_2_96KHZ;\n\t\tbreak;\n\tcase 176400:\n\t\tramp_rate = TAS2562_TDM_CFG0_RAMPRATE_44_1;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_176_4_192KHZ;\n\t\tbreak;\n\tcase 192000:\n\t\tramp_rate = 0;\n\t\tsamp_rate = TAS2562_TDM_CFG0_SAMPRATE_176_4_192KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(tas2562->dev, \"%s, unsupported sample rate, %d\\n\",\n\t\t\t__func__, samplerate);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(tas2562->component, TAS2562_TDM_CFG0,\n\t\tTAS2562_TDM_CFG0_RAMPRATE_MASK,\tramp_rate);\n\tsnd_soc_component_update_bits(tas2562->component, TAS2562_TDM_CFG0,\n\t\tTAS2562_TDM_CFG0_SAMPRATE_MASK,\tsamp_rate);\n\n\treturn 0;\n}\n\nstatic int tas2562_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\tunsigned int tx_mask, unsigned int rx_mask,\n\t\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\tint left_slot, right_slot;\n\tint slots_cfg;\n\tint ret;\n\n\tif (!tx_mask) {\n\t\tdev_err(component->dev, \"tx masks must not be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (slots == 1) {\n\t\tif (tx_mask != 1)\n\t\t\treturn -EINVAL;\n\n\t\tleft_slot = 0;\n\t\tright_slot = 0;\n\t} else {\n\t\tleft_slot = __ffs(tx_mask);\n\t\ttx_mask &= ~(1 << left_slot);\n\t\tif (tx_mask == 0) {\n\t\t\tright_slot = left_slot;\n\t\t} else {\n\t\t\tright_slot = __ffs(tx_mask);\n\t\t}\n\t}\n\n\tslots_cfg = (right_slot << TAS2562_RIGHT_SLOT_SHIFT) | left_slot;\n\n\tret = snd_soc_component_write(component, TAS2562_TDM_CFG3, slots_cfg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_MASK,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_16B);\n\t\tbreak;\n\tcase 24:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_MASK,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_24B);\n\t\tbreak;\n\tcase 32:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_MASK,\n\t\t\t\t\t\t    TAS2562_TDM_CFG2_RXLEN_32B);\n\t\tbreak;\n\n\tcase 0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2562->dev, \"slot width not supported\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2562_TDM_CFG5,\n\t\t\t\t\t    TAS2562_TDM_CFG5_VSNS_SLOT_MASK,\n\t\t\t\t\t    tas2562->v_sense_slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2562_TDM_CFG6,\n\t\t\t\t\t    TAS2562_TDM_CFG6_ISNS_SLOT_MASK,\n\t\t\t\t\t    tas2562->i_sense_slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2562_set_bitwidth(struct tas2562_data *tas2562, int bitwidth)\n{\n\tint ret;\n\tint val;\n\tint sense_en;\n\n\tswitch (bitwidth) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tsnd_soc_component_update_bits(tas2562->component,\n\t\t\t\t\t      TAS2562_TDM_CFG2,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_MASK,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_16B);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tsnd_soc_component_update_bits(tas2562->component,\n\t\t\t\t\t      TAS2562_TDM_CFG2,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_MASK,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_24B);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tsnd_soc_component_update_bits(tas2562->component,\n\t\t\t\t\t      TAS2562_TDM_CFG2,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_MASK,\n\t\t\t\t\t      TAS2562_TDM_CFG2_RXWLEN_32B);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(tas2562->dev, \"Unsupported bitwidth format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = snd_soc_component_read(tas2562->component, TAS2562_PWR_CTRL);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & (1 << TAS2562_VSENSE_POWER_EN))\n\t\tsense_en = 0;\n\telse\n\t\tsense_en = TAS2562_TDM_CFG5_VSNS_EN;\n\n\tret = snd_soc_component_update_bits(tas2562->component, TAS2562_TDM_CFG5,\n\t\tTAS2562_TDM_CFG5_VSNS_EN, sense_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & (1 << TAS2562_ISENSE_POWER_EN))\n\t\tsense_en = 0;\n\telse\n\t\tsense_en = TAS2562_TDM_CFG6_ISNS_EN;\n\n\tret = snd_soc_component_update_bits(tas2562->component, TAS2562_TDM_CFG6,\n\t\tTAS2562_TDM_CFG6_ISNS_EN, sense_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2562_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = tas2562_set_bitwidth(tas2562, params_format(params));\n\tif (ret) {\n\t\tdev_err(tas2562->dev, \"set bitwidth failed, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tas2562_set_samplerate(tas2562, params_rate(params));\n\tif (ret)\n\t\tdev_err(tas2562->dev, \"set sample rate failed, %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tas2562_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\tu8 asi_cfg_1 = 0;\n\tu8 tdm_rx_start_slot = 0;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tasi_cfg_1 = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tasi_cfg_1 |= TAS2562_TDM_CFG1_RX_FALLING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2562->dev, \"ASI format Inverse is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2562_TDM_CFG1,\n\t\t\t\t\t    TAS2562_TDM_CFG1_RX_EDGE_MASK,\n\t\t\t\t\t    asi_cfg_1);\n\tif (ret < 0) {\n\t\tdev_err(tas2562->dev, \"Failed to set RX edge\\n\");\n\t\treturn ret;\n\t}\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\ttdm_rx_start_slot = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\ttdm_rx_start_slot = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2562->dev,\n\t\t\t\"DAI Format is not found, fmt=0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2562_TDM_CFG1,\n\t\t\t\tTAS2562_RX_OFF_MASK, (tdm_rx_start_slot << 1));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2562_update_pwr_ctrl(struct tas2562_data *tas2562)\n{\n\tstruct snd_soc_component *component = tas2562->component;\n\tunsigned int val;\n\tint ret;\n\n\tif (tas2562->dac_powered)\n\t\tval = tas2562->unmuted ?\n\t\t\tTAS2562_ACTIVE : TAS2562_MUTE;\n\telse\n\t\tval = TAS2562_SHUTDOWN;\n\n\tret = snd_soc_component_update_bits(component, TAS2562_PWR_CTRL,\n\t\t\t\t\t    TAS2562_MODE_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2562_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(dai->component);\n\n\ttas2562->unmuted = !mute;\n\treturn tas2562_update_pwr_ctrl(tas2562);\n}\n\nstatic int tas2562_codec_probe(struct snd_soc_component *component)\n{\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\n\ttas2562->component = component;\n\n\tif (tas2562->sdz_gpio)\n\t\tgpiod_set_value_cansleep(tas2562->sdz_gpio, 1);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int tas2562_suspend(struct snd_soc_component *component)\n{\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(tas2562->regmap, true);\n\tregcache_mark_dirty(tas2562->regmap);\n\n\tif (tas2562->sdz_gpio)\n\t\tgpiod_set_value_cansleep(tas2562->sdz_gpio, 0);\n\n\treturn 0;\n}\n\nstatic int tas2562_resume(struct snd_soc_component *component)\n{\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\n\tif (tas2562->sdz_gpio)\n\t\tgpiod_set_value_cansleep(tas2562->sdz_gpio, 1);\n\n\tregcache_cache_only(tas2562->regmap, false);\n\n\treturn regcache_sync(tas2562->regmap);\n}\n#else\n#define tas2562_suspend NULL\n#define tas2562_resume NULL\n#endif\n\nstatic const char * const tas2562_ASI1_src[] = {\n\t\"I2C offset\", \"Left\", \"Right\", \"LeftRightDiv2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(tas2562_ASI1_src_enum, TAS2562_TDM_CFG2, 4,\n\t\t\t    tas2562_ASI1_src);\n\nstatic const struct snd_kcontrol_new tas2562_asi1_mux =\n\tSOC_DAPM_ENUM(\"ASI1 Source\", tas2562_ASI1_src_enum);\n\nstatic int tas2562_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\ttas2562->dac_powered = true;\n\t\tret = tas2562_update_pwr_ctrl(tas2562);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\ttas2562->dac_powered = false;\n\t\tret = tas2562_update_pwr_ctrl(tas2562);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2562->dev, \"Not supported evevt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int tas2562_volume_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = tas2562->volume_lvl;\n\treturn 0;\n}\n\nstatic int tas2562_volume_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tas2562_data *tas2562 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tu32 reg_val;\n\n\treg_val = float_vol_db_lookup[ucontrol->value.integer.value[0]/2];\n\tret = snd_soc_component_write(component, TAS2562_DVC_CFG4,\n\t\t\t\t      (reg_val & 0xff));\n\tif (ret)\n\t\treturn ret;\n\tret = snd_soc_component_write(component, TAS2562_DVC_CFG3,\n\t\t\t\t      ((reg_val >> 8) & 0xff));\n\tif (ret)\n\t\treturn ret;\n\tret = snd_soc_component_write(component, TAS2562_DVC_CFG2,\n\t\t\t\t      ((reg_val >> 16) & 0xff));\n\tif (ret)\n\t\treturn ret;\n\tret = snd_soc_component_write(component, TAS2562_DVC_CFG1,\n\t\t\t\t      ((reg_val >> 24) & 0xff));\n\tif (ret)\n\t\treturn ret;\n\n\ttas2562->volume_lvl = ucontrol->value.integer.value[0];\n\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(dvc_tlv, -11000, 100, 0);\n\nstatic DECLARE_TLV_DB_SCALE(tas2562_dac_tlv, 850, 50, 0);\n\nstatic const struct snd_kcontrol_new isense_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", TAS2562_PWR_CTRL, TAS2562_ISENSE_POWER_EN,\n\t\t\t1, 1);\n\nstatic const struct snd_kcontrol_new vsense_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", TAS2562_PWR_CTRL, TAS2562_VSENSE_POWER_EN,\n\t\t\t1, 1);\n\nstatic const struct snd_kcontrol_new tas2562_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Amp Gain Volume\", TAS2562_PB_CFG1, 1, 0x1c, 0,\n\t\t       tas2562_dac_tlv),\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Digital Volume Control\",\n\t\t.index = 0,\n\t\t.tlv.p = dvc_tlv,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.info = snd_soc_info_volsw,\n\t\t.get = tas2562_volume_control_get,\n\t\t.put = tas2562_volume_control_put,\n\t\t.private_value = SOC_SINGLE_VALUE(TAS2562_DVC_CFG1, 0, 110, 0, 0),\n\t},\n};\n\nstatic const struct snd_soc_dapm_widget tas2110_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"ASI1\", \"ASI1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"ASI1 Sel\", SND_SOC_NOPM, 0, 0, &tas2562_asi1_mux),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0, tas2562_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route tas2110_audio_map[] = {\n\t{\"ASI1 Sel\", \"I2C offset\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Left\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Right\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"LeftRightDiv2\", \"ASI1\"},\n\t{ \"DAC\", NULL, \"ASI1 Sel\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas2110 = {\n\t.probe\t\t\t= tas2562_codec_probe,\n\t.suspend\t\t= tas2562_suspend,\n\t.resume\t\t\t= tas2562_resume,\n\t.controls\t\t= tas2562_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas2562_snd_controls),\n\t.dapm_widgets\t\t= tas2110_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas2110_dapm_widgets),\n\t.dapm_routes\t\t= tas2110_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas2110_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_dapm_widget tas2562_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"ASI1\", \"ASI1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"ASI1 Sel\", SND_SOC_NOPM, 0, 0, &tas2562_asi1_mux),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0, tas2562_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SWITCH(\"ISENSE\", TAS2562_PWR_CTRL, 3, 1, &isense_switch),\n\tSND_SOC_DAPM_SWITCH(\"VSENSE\", TAS2562_PWR_CTRL, 2, 1, &vsense_switch),\n\tSND_SOC_DAPM_SIGGEN(\"VMON\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route tas2562_audio_map[] = {\n\t{\"ASI1 Sel\", \"I2C offset\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Left\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Right\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"LeftRightDiv2\", \"ASI1\"},\n\t{ \"DAC\", NULL, \"ASI1 Sel\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n\t{\"ISENSE\", \"Switch\", \"IMON\"},\n\t{\"VSENSE\", \"Switch\", \"VMON\"},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas2562 = {\n\t.probe\t\t\t= tas2562_codec_probe,\n\t.suspend\t\t= tas2562_suspend,\n\t.resume\t\t\t= tas2562_resume,\n\t.controls\t\t= tas2562_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas2562_snd_controls),\n\t.dapm_widgets\t\t= tas2562_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas2562_dapm_widgets),\n\t.dapm_routes\t\t= tas2562_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas2562_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops tas2562_speaker_dai_ops = {\n\t.hw_params\t= tas2562_hw_params,\n\t.set_fmt\t= tas2562_set_dai_fmt,\n\t.set_tdm_slot\t= tas2562_set_dai_tdm_slot,\n\t.mute_stream\t= tas2562_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver tas2562_dai[] = {\n\t{\n\t\t.name = \"tas2562-amplifier\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name    = \"ASI1 Playback\",\n\t\t\t.channels_min   = 2,\n\t\t\t.channels_max   = 2,\n\t\t\t.rates      = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats    = TAS2562_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name    = \"ASI1 Capture\",\n\t\t\t.channels_min   = 0,\n\t\t\t.channels_max   = 2,\n\t\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats\t= TAS2562_FORMATS,\n\t\t},\n\t\t.ops = &tas2562_speaker_dai_ops,\n\t},\n};\n\nstatic const struct regmap_range_cfg tas2562_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 5 * 128,\n\t\t.selector_reg = TAS2562_PAGE_CTRL,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t},\n};\n\nstatic const struct reg_default tas2562_reg_defaults[] = {\n\t{ TAS2562_PAGE_CTRL, 0x00 },\n\t{ TAS2562_SW_RESET, 0x00 },\n\t{ TAS2562_PWR_CTRL, 0x0e },\n\t{ TAS2562_PB_CFG1, 0x20 },\n\t{ TAS2562_TDM_CFG0, 0x09 },\n\t{ TAS2562_TDM_CFG1, 0x02 },\n\t{ TAS2562_DVC_CFG1, 0x40 },\n\t{ TAS2562_DVC_CFG2, 0x40 },\n\t{ TAS2562_DVC_CFG3, 0x00 },\n\t{ TAS2562_DVC_CFG4, 0x00 },\n};\n\nstatic const struct regmap_config tas2562_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 5 * 128,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = tas2562_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(tas2562_reg_defaults),\n\t.ranges = tas2562_ranges,\n\t.num_ranges = ARRAY_SIZE(tas2562_ranges),\n};\n\nstatic int tas2562_parse_dt(struct tas2562_data *tas2562)\n{\n\tstruct device *dev = tas2562->dev;\n\tint ret = 0;\n\n\ttas2562->sdz_gpio = devm_gpiod_get_optional(dev, \"shutdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tas2562->sdz_gpio)) {\n\t\tif (PTR_ERR(tas2562->sdz_gpio) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\ttas2562->sdz_gpio = NULL;\n\t}\n\n\t \n\tif (tas2562->sdz_gpio == NULL) {\n\t\ttas2562->sdz_gpio = devm_gpiod_get_optional(dev, \"shut-down\",\n\t\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(tas2562->sdz_gpio))\n\t\t\tif (PTR_ERR(tas2562->sdz_gpio) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\ttas2562->sdz_gpio = NULL;\n\t}\n\n\tif (tas2562->model_id == TAS2110)\n\t\treturn ret;\n\n\tret = fwnode_property_read_u32(dev->fwnode, \"ti,imon-slot-no\",\n\t\t\t&tas2562->i_sense_slot);\n\tif (ret) {\n\t\tdev_err(dev, \"Property %s is missing setting default slot\\n\",\n\t\t\t\"ti,imon-slot-no\");\n\t\ttas2562->i_sense_slot = 0;\n\t}\n\n\n\tret = fwnode_property_read_u32(dev->fwnode, \"ti,vmon-slot-no\",\n\t\t\t&tas2562->v_sense_slot);\n\tif (ret) {\n\t\tdev_info(dev, \"Property %s is missing setting default slot\\n\",\n\t\t\t\"ti,vmon-slot-no\");\n\t\ttas2562->v_sense_slot = 2;\n\t}\n\n\tif (tas2562->v_sense_slot < tas2562->i_sense_slot) {\n\t\tdev_err(dev, \"Vsense slot must be greater than Isense slot\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id tas2562_id[] = {\n\t{ \"tas2562\", TAS2562 },\n\t{ \"tas2563\", TAS2563 },\n\t{ \"tas2564\", TAS2564 },\n\t{ \"tas2110\", TAS2110 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas2562_id);\n\nstatic int tas2562_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tas2562_data *data;\n\tint ret;\n\tconst struct i2c_device_id *id;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tid = i2c_match_id(tas2562_id, client);\n\tdata->client = client;\n\tdata->dev = &client->dev;\n\tdata->model_id = id->driver_data;\n\n\ttas2562_parse_dt(data);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &tas2562_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tdev_err(dev, \"failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&client->dev, data);\n\n\tif (data->model_id == TAS2110)\n\t\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t\t\t       &soc_component_dev_tas2110,\n\t\t\t\t\t\t       tas2562_dai,\n\t\t\t\t\t\t       ARRAY_SIZE(tas2562_dai));\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_dev_tas2562,\n\t\t\t\t\t       tas2562_dai,\n\t\t\t\t\t       ARRAY_SIZE(tas2562_dai));\n\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tas2562_of_match[] = {\n\t{ .compatible = \"ti,tas2562\", },\n\t{ .compatible = \"ti,tas2563\", },\n\t{ .compatible = \"ti,tas2564\", },\n\t{ .compatible = \"ti,tas2110\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tas2562_of_match);\n#endif\n\nstatic struct i2c_driver tas2562_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas2562\",\n\t\t.of_match_table = of_match_ptr(tas2562_of_match),\n\t},\n\t.probe = tas2562_probe,\n\t.id_table = tas2562_id,\n};\n\nmodule_i2c_driver(tas2562_i2c_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"TAS2562 Audio amplifier driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}