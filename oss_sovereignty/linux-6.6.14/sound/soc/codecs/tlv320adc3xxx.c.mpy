{
  "module_name": "tlv320adc3xxx.c",
  "hash_id": "f7cd0972048e03599e29f08429ea690761a6fed337a1fa75a154848f86cb4356",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320adc3xxx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <dt-bindings/sound/tlv320adc3xxx.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/io.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio/driver.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/cdev.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n\n \n\n#define ADC3XXX_MICBIAS_PINS\t\t2\n\n \n#define ADC3XXX_GPIOS_MAX\t\t2\n\n#define ADC3XXX_RATES\t\tSNDRV_PCM_RATE_8000_96000\n#define ADC3XXX_FORMATS\t\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\n \n#define ADC3XXX_PLL_AUTO\t0  \n#define ADC3XXX_PLL_ENABLE\t1  \n#define ADC3XXX_PLL_BYPASS\t2  \n\n \n\n#define ADC3XXX_PAGE_SIZE\t\t128\n#define ADC3XXX_REG(page, reg)\t\t((page * ADC3XXX_PAGE_SIZE) + reg)\n\n \n\n#define ADC3XXX_PAGE_SELECT\t\t\tADC3XXX_REG(0, 0)\n#define ADC3XXX_RESET\t\t\t\tADC3XXX_REG(0, 1)\n\n \n\n#define ADC3XXX_CLKGEN_MUX\t\t\tADC3XXX_REG(0, 4)\n#define ADC3XXX_PLL_PROG_PR\t\t\tADC3XXX_REG(0, 5)\n#define ADC3XXX_PLL_PROG_J\t\t\tADC3XXX_REG(0, 6)\n#define ADC3XXX_PLL_PROG_D_MSB\t\t\tADC3XXX_REG(0, 7)\n#define ADC3XXX_PLL_PROG_D_LSB\t\t\tADC3XXX_REG(0, 8)\n\n \n\n#define ADC3XXX_ADC_NADC\t\t\tADC3XXX_REG(0, 18)\n#define ADC3XXX_ADC_MADC\t\t\tADC3XXX_REG(0, 19)\n#define ADC3XXX_ADC_AOSR\t\t\tADC3XXX_REG(0, 20)\n#define ADC3XXX_ADC_IADC\t\t\tADC3XXX_REG(0, 21)\n\n \n\n#define ADC3XXX_CLKOUT_MUX\t\t\tADC3XXX_REG(0, 25)\n#define ADC3XXX_CLKOUT_M_DIV\t\t\tADC3XXX_REG(0, 26)\n#define ADC3XXX_INTERFACE_CTRL_1\t\tADC3XXX_REG(0, 27)\n#define ADC3XXX_CH_OFFSET_1\t\t\tADC3XXX_REG(0, 28)\n#define ADC3XXX_INTERFACE_CTRL_2\t\tADC3XXX_REG(0, 29)\n#define ADC3XXX_BCLK_N_DIV\t\t\tADC3XXX_REG(0, 30)\n#define ADC3XXX_INTERFACE_CTRL_3\t\tADC3XXX_REG(0, 31)\n#define ADC3XXX_INTERFACE_CTRL_4\t\tADC3XXX_REG(0, 32)\n#define ADC3XXX_INTERFACE_CTRL_5\t\tADC3XXX_REG(0, 33)\n#define ADC3XXX_I2S_SYNC\t\t\tADC3XXX_REG(0, 34)\n \n#define ADC3XXX_ADC_FLAG\t\t\tADC3XXX_REG(0, 36)\n#define ADC3XXX_CH_OFFSET_2\t\t\tADC3XXX_REG(0, 37)\n#define ADC3XXX_I2S_TDM_CTRL\t\t\tADC3XXX_REG(0, 38)\n \n#define ADC3XXX_INTR_FLAG_1\t\t\tADC3XXX_REG(0, 42)\n#define ADC3XXX_INTR_FLAG_2\t\t\tADC3XXX_REG(0, 43)\n \n#define ADC3XXX_INTR_FLAG_ADC1\t\t\tADC3XXX_REG(0, 45)\n \n#define ADC3XXX_INTR_FLAG_ADC2\t\t\tADC3XXX_REG(0, 47)\n#define ADC3XXX_INT1_CTRL\t\t\tADC3XXX_REG(0, 48)\n#define ADC3XXX_INT2_CTRL\t\t\tADC3XXX_REG(0, 49)\n \n#define ADC3XXX_GPIO2_CTRL\t\t\tADC3XXX_REG(0, 51)\n#define ADC3XXX_GPIO1_CTRL\t\t\tADC3XXX_REG(0, 52)\n#define ADC3XXX_DOUT_CTRL\t\t\tADC3XXX_REG(0, 53)\n \n#define ADC3XXX_SYNC_CTRL_1\t\t\tADC3XXX_REG(0, 57)\n#define ADC3XXX_SYNC_CTRL_2\t\t\tADC3XXX_REG(0, 58)\n#define ADC3XXX_CIC_GAIN_CTRL\t\t\tADC3XXX_REG(0, 59)\n \n#define ADC3XXX_PRB_SELECT\t\t\tADC3XXX_REG(0, 61)\n#define ADC3XXX_INST_MODE_CTRL\t\t\tADC3XXX_REG(0, 62)\n \n#define ADC3XXX_MIC_POLARITY_CTRL\t\tADC3XXX_REG(0, 80)\n#define ADC3XXX_ADC_DIGITAL\t\t\tADC3XXX_REG(0, 81)\n#define\tADC3XXX_ADC_FGA\t\t\t\tADC3XXX_REG(0, 82)\n#define ADC3XXX_LADC_VOL\t\t\tADC3XXX_REG(0, 83)\n#define ADC3XXX_RADC_VOL\t\t\tADC3XXX_REG(0, 84)\n#define ADC3XXX_ADC_PHASE_COMP\t\t\tADC3XXX_REG(0, 85)\n#define ADC3XXX_LEFT_CHN_AGC_1\t\t\tADC3XXX_REG(0, 86)\n#define ADC3XXX_LEFT_CHN_AGC_2\t\t\tADC3XXX_REG(0, 87)\n#define ADC3XXX_LEFT_CHN_AGC_3\t\t\tADC3XXX_REG(0, 88)\n#define ADC3XXX_LEFT_CHN_AGC_4\t\t\tADC3XXX_REG(0, 89)\n#define ADC3XXX_LEFT_CHN_AGC_5\t\t\tADC3XXX_REG(0, 90)\n#define ADC3XXX_LEFT_CHN_AGC_6\t\t\tADC3XXX_REG(0, 91)\n#define ADC3XXX_LEFT_CHN_AGC_7\t\t\tADC3XXX_REG(0, 92)\n#define ADC3XXX_LEFT_AGC_GAIN\t\t\tADC3XXX_REG(0, 93)\n#define ADC3XXX_RIGHT_CHN_AGC_1\t\t\tADC3XXX_REG(0, 94)\n#define ADC3XXX_RIGHT_CHN_AGC_2\t\t\tADC3XXX_REG(0, 95)\n#define ADC3XXX_RIGHT_CHN_AGC_3\t\t\tADC3XXX_REG(0, 96)\n#define ADC3XXX_RIGHT_CHN_AGC_4\t\t\tADC3XXX_REG(0, 97)\n#define ADC3XXX_RIGHT_CHN_AGC_5\t\t\tADC3XXX_REG(0, 98)\n#define ADC3XXX_RIGHT_CHN_AGC_6\t\t\tADC3XXX_REG(0, 99)\n#define ADC3XXX_RIGHT_CHN_AGC_7\t\t\tADC3XXX_REG(0, 100)\n#define ADC3XXX_RIGHT_AGC_GAIN\t\t\tADC3XXX_REG(0, 101)\n \n\n \n\n \n#define ADC3XXX_DITHER_CTRL\t\t\tADC3XXX_REG(1, 26)\n \n#define ADC3XXX_MICBIAS_CTRL\t\t\tADC3XXX_REG(1, 51)\n#define ADC3XXX_LEFT_PGA_SEL_1\t\t\tADC3XXX_REG(1, 52)\n \n#define ADC3XXX_LEFT_PGA_SEL_2\t\t\tADC3XXX_REG(1, 54)\n#define ADC3XXX_RIGHT_PGA_SEL_1\t\t\tADC3XXX_REG(1, 55)\n#define ADC3XXX_RIGHT_PGA_SEL_2\t\t\tADC3XXX_REG(1, 57)\n#define ADC3XXX_LEFT_APGA_CTRL\t\t\tADC3XXX_REG(1, 59)\n#define ADC3XXX_RIGHT_APGA_CTRL\t\t\tADC3XXX_REG(1, 60)\n#define ADC3XXX_LOW_CURRENT_MODES\t\tADC3XXX_REG(1, 61)\n#define ADC3XXX_ANALOG_PGA_FLAGS\t\tADC3XXX_REG(1, 62)\n \n\n \n#define ADC3XXX_LEFT_ADC_IIR_COEFF_N0_MSB\tADC3XXX_REG(4, 8)\n#define ADC3XXX_LEFT_ADC_IIR_COEFF_N0_LSB\tADC3XXX_REG(4, 9)\n#define ADC3XXX_LEFT_ADC_IIR_COEFF_N1_MSB\tADC3XXX_REG(4, 10)\n#define ADC3XXX_LEFT_ADC_IIR_COEFF_N1_LSB\tADC3XXX_REG(4, 11)\n#define ADC3XXX_LEFT_ADC_IIR_COEFF_D1_MSB\tADC3XXX_REG(4, 12)\n#define ADC3XXX_LEFT_ADC_IIR_COEFF_D1_LSB\tADC3XXX_REG(4, 13)\n\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_N0_MSB\tADC3XXX_REG(4, 72)\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_N0_LSB\tADC3XXX_REG(4, 73)\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_N1_MSB\tADC3XXX_REG(4, 74)\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_N1_LSB\tADC3XXX_REG(4, 75)\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_D1_MSB\tADC3XXX_REG(4, 76)\n#define ADC3XXX_RIGHT_ADC_IIR_COEFF_D1_LSB\tADC3XXX_REG(4, 77)\n\n \n\n \n#define ADC3XXX_ENABLE_PLL_SHIFT\t7\n#define ADC3XXX_ENABLE_PLL\t\t(1 << ADC3XXX_ENABLE_PLL_SHIFT)\n#define ADC3XXX_ENABLE_NADC_SHIFT\t7\n#define ADC3XXX_ENABLE_NADC\t\t(1 << ADC3XXX_ENABLE_NADC_SHIFT)\n#define ADC3XXX_ENABLE_MADC_SHIFT\t7\n#define ADC3XXX_ENABLE_MADC\t\t(1 << ADC3XXX_ENABLE_MADC_SHIFT)\n#define ADC3XXX_ENABLE_BCLK_SHIFT\t7\n#define ADC3XXX_ENABLE_BCLK\t\t(1 << ADC3XXX_ENABLE_BCLK_SHIFT)\n\n \n#define ADC3XXX_LADC_PWR_ON\t\t0x80\n#define ADC3XXX_RADC_PWR_ON\t\t0x40\n\n#define ADC3XXX_SOFT_RESET\t\t0x01\n#define ADC3XXX_BCLK_MASTER\t\t0x08\n#define ADC3XXX_WCLK_MASTER\t\t0x04\n\n \n#define ADC3XXX_FORMAT_MASK\t\t0xc0\n#define ADC3XXX_FORMAT_SHIFT\t\t6\n#define ADC3XXX_WLENGTH_MASK\t\t0x30\n#define ADC3XXX_WLENGTH_SHIFT\t\t4\n#define ADC3XXX_CLKDIR_MASK\t\t0x0c\n#define ADC3XXX_CLKDIR_SHIFT\t\t2\n\n \n#define ADC3XXX_FORMAT_I2S\t\t(0 << ADC3XXX_FORMAT_SHIFT)\n#define ADC3XXX_FORMAT_DSP\t\t(1 << ADC3XXX_FORMAT_SHIFT)\n#define ADC3XXX_FORMAT_RJF\t\t(2 << ADC3XXX_FORMAT_SHIFT)\n#define ADC3XXX_FORMAT_LJF\t\t(3 << ADC3XXX_FORMAT_SHIFT)\n\n#define ADC3XXX_IFACE_16BITS\t\t(0 << ADC3XXX_WLENGTH_SHIFT)\n#define ADC3XXX_IFACE_20BITS\t\t(1 << ADC3XXX_WLENGTH_SHIFT)\n#define ADC3XXX_IFACE_24BITS\t\t(2 << ADC3XXX_WLENGTH_SHIFT)\n#define ADC3XXX_IFACE_32BITS\t\t(3 << ADC3XXX_WLENGTH_SHIFT)\n\n \n#define ADC3XXX_PLLP_SHIFT\t\t4\n#define ADC3XXX_PLLR_SHIFT\t\t0\n#define ADC3XXX_PLL_PR_MASK\t\t0x7f\n#define ADC3XXX_PLLJ_MASK\t\t0x3f\n#define ADC3XXX_PLLD_MSB_MASK\t\t0x3f\n#define ADC3XXX_PLLD_LSB_MASK\t\t0xff\n#define ADC3XXX_NADC_MASK\t\t0x7f\n#define ADC3XXX_MADC_MASK\t\t0x7f\n#define ADC3XXX_AOSR_MASK\t\t0xff\n#define ADC3XXX_IADC_MASK\t\t0xff\n#define ADC3XXX_BDIV_MASK\t\t0x7f\n\n \n#define ADC3XXX_PLL_CLKIN_SHIFT\t\t2\n#define ADC3XXX_PLL_CLKIN_MCLK\t\t0x0\n#define ADC3XXX_PLL_CLKIN_BCLK\t\t0x1\n#define ADC3XXX_PLL_CLKIN_ZERO\t\t0x3\n\n \n#define ADC3XXX_CODEC_CLKIN_SHIFT\t0\n#define ADC3XXX_CODEC_CLKIN_MCLK\t0x0\n#define ADC3XXX_CODEC_CLKIN_BCLK\t0x1\n#define ADC3XXX_CODEC_CLKIN_PLL_CLK\t0x3\n\n#define ADC3XXX_USE_PLL\t((ADC3XXX_PLL_CLKIN_MCLK << ADC3XXX_PLL_CLKIN_SHIFT) | \\\n\t\t\t (ADC3XXX_CODEC_CLKIN_PLL_CLK << ADC3XXX_CODEC_CLKIN_SHIFT))\n#define ADC3XXX_NO_PLL\t((ADC3XXX_PLL_CLKIN_ZERO << ADC3XXX_PLL_CLKIN_SHIFT) | \\\n\t\t\t (ADC3XXX_CODEC_CLKIN_MCLK << ADC3XXX_CODEC_CLKIN_SHIFT))\n\n \n#define ADC3XXX_LPGA_MUTE\t\t0x80\n#define ADC3XXX_RPGA_MUTE\t\t0x80\n\n#define ADC3XXX_LPGA_GAIN_MASK\t\t0x7f\n#define ADC3XXX_RPGA_GAIN_MASK\t\t0x7f\n\n \n#define ADC3XXX_ADC_LOW_CURR_MODE\t0x01\n\n \n#define ADC3XXX_LCH_SEL1_SHIFT\t\t0\n#define ADC3XXX_LCH_SEL2_SHIFT\t\t2\n#define ADC3XXX_LCH_SEL3_SHIFT\t\t4\n#define ADC3XXX_LCH_SEL4_SHIFT\t\t6\n\n#define ADC3XXX_LCH_SEL1X_SHIFT\t\t0\n#define ADC3XXX_LCH_SEL2X_SHIFT\t\t2\n#define ADC3XXX_LCH_SEL3X_SHIFT\t\t4\n#define ADC3XXX_LCH_COMMON_MODE\t\t0x40\n#define ADC3XXX_BYPASS_LPGA\t\t0x80\n\n \n#define ADC3XXX_RCH_SEL1_SHIFT\t\t0\n#define ADC3XXX_RCH_SEL2_SHIFT\t\t2\n#define ADC3XXX_RCH_SEL3_SHIFT\t\t4\n#define ADC3XXX_RCH_SEL4_SHIFT\t\t6\n\n#define ADC3XXX_RCH_SEL1X_SHIFT\t\t0\n#define ADC3XXX_RCH_SEL2X_SHIFT\t\t2\n#define ADC3XXX_RCH_SEL3X_SHIFT\t\t4\n#define ADC3XXX_RCH_COMMON_MODE\t\t0x40\n#define ADC3XXX_BYPASS_RPGA\t\t0x80\n\n \n#define ADC3XXX_MICBIAS_MASK\t\t0x3\n#define ADC3XXX_MICBIAS1_SHIFT\t\t5\n#define ADC3XXX_MICBIAS2_SHIFT\t\t3\n\n#define ADC3XXX_ADC_MAX_VOLUME\t\t64\n#define ADC3XXX_ADC_POS_VOL\t\t24\n\n \n#define ADC3XXX_GPIO_CTRL_CFG_MASK\t\t0x3c\n#define ADC3XXX_GPIO_CTRL_CFG_SHIFT\t\t2\n#define ADC3XXX_GPIO_CTRL_OUTPUT_CTRL_MASK\t0x01\n#define ADC3XXX_GPIO_CTRL_OUTPUT_CTRL_SHIFT\t0\n#define ADC3XXX_GPIO_CTRL_INPUT_VALUE_MASK\t0x02\n#define ADC3XXX_GPIO_CTRL_INPUT_VALUE_SHIFT\t1\n\nenum adc3xxx_type {\n\tADC3001 = 0,\n\tADC3101\n};\n\nstruct adc3xxx {\n\tstruct device *dev;\n\tenum adc3xxx_type type;\n\tstruct clk *mclk;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *rst_pin;\n\tunsigned int pll_mode;\n\tunsigned int sysclk;\n\tunsigned int gpio_cfg[ADC3XXX_GPIOS_MAX];  \n\tunsigned int micbias_vg[ADC3XXX_MICBIAS_PINS];\n\tint master;\n\tu8 page_no;\n\tint use_pll;\n\tstruct gpio_chip gpio_chip;\n};\n\nstatic const unsigned int adc3xxx_gpio_ctrl_reg[ADC3XXX_GPIOS_MAX] = {\n\tADC3XXX_GPIO1_CTRL,\n\tADC3XXX_GPIO2_CTRL\n};\n\nstatic const unsigned int adc3xxx_micbias_shift[ADC3XXX_MICBIAS_PINS] = {\n\tADC3XXX_MICBIAS1_SHIFT,\n\tADC3XXX_MICBIAS2_SHIFT\n};\n\nstatic const struct reg_default adc3xxx_defaults[] = {\n\t \n\t{ 0, 0x00 },    { 1, 0x00 },    { 2, 0x00 },    { 3, 0x00 },\n\t{ 4, 0x00 },    { 5, 0x11 },    { 6, 0x04 },    { 7, 0x00 },\n\t{ 8, 0x00 },    { 9, 0x00 },    { 10, 0x00 },   { 11, 0x00 },\n\t{ 12, 0x00 },   { 13, 0x00 },   { 14, 0x00 },   { 15, 0x00 },\n\t{ 16, 0x00 },   { 17, 0x00 },   { 18, 0x01 },   { 19, 0x01 },\n\t{ 20, 0x80 },   { 21, 0x80 },   { 22, 0x04 },   { 23, 0x00 },\n\t{ 24, 0x00 },   { 25, 0x00 },   { 26, 0x01 },   { 27, 0x00 },\n\t{ 28, 0x00 },   { 29, 0x02 },   { 30, 0x01 },   { 31, 0x00 },\n\t{ 32, 0x00 },   { 33, 0x10 },   { 34, 0x00 },   { 35, 0x00 },\n\t{ 36, 0x00 },   { 37, 0x00 },   { 38, 0x02 },   { 39, 0x00 },\n\t{ 40, 0x00 },   { 41, 0x00 },   { 42, 0x00 },   { 43, 0x00 },\n\t{ 44, 0x00 },   { 45, 0x00 },   { 46, 0x00 },   { 47, 0x00 },\n\t{ 48, 0x00 },   { 49, 0x00 },   { 50, 0x00 },   { 51, 0x00 },\n\t{ 52, 0x00 },   { 53, 0x12 },   { 54, 0x00 },   { 55, 0x00 },\n\t{ 56, 0x00 },   { 57, 0x00 },   { 58, 0x00 },   { 59, 0x44 },\n\t{ 60, 0x00 },   { 61, 0x01 },   { 62, 0x00 },   { 63, 0x00 },\n\t{ 64, 0x00 },   { 65, 0x00 },   { 66, 0x00 },   { 67, 0x00 },\n\t{ 68, 0x00 },   { 69, 0x00 },   { 70, 0x00 },   { 71, 0x00 },\n\t{ 72, 0x00 },   { 73, 0x00 },   { 74, 0x00 },   { 75, 0x00 },\n\t{ 76, 0x00 },   { 77, 0x00 },   { 78, 0x00 },   { 79, 0x00 },\n\t{ 80, 0x00 },   { 81, 0x00 },   { 82, 0x88 },   { 83, 0x00 },\n\t{ 84, 0x00 },   { 85, 0x00 },   { 86, 0x00 },   { 87, 0x00 },\n\t{ 88, 0x7f },   { 89, 0x00 },   { 90, 0x00 },   { 91, 0x00 },\n\t{ 92, 0x00 },   { 93, 0x00 },   { 94, 0x00 },   { 95, 0x00 },\n\t{ 96, 0x7f },   { 97, 0x00 },   { 98, 0x00 },   { 99, 0x00 },\n\t{ 100, 0x00 },  { 101, 0x00 },  { 102, 0x00 },  { 103, 0x00 },\n\t{ 104, 0x00 },  { 105, 0x00 },  { 106, 0x00 },  { 107, 0x00 },\n\t{ 108, 0x00 },  { 109, 0x00 },  { 110, 0x00 },  { 111, 0x00 },\n\t{ 112, 0x00 },  { 113, 0x00 },  { 114, 0x00 },  { 115, 0x00 },\n\t{ 116, 0x00 },  { 117, 0x00 },  { 118, 0x00 },  { 119, 0x00 },\n\t{ 120, 0x00 },  { 121, 0x00 },  { 122, 0x00 },  { 123, 0x00 },\n\t{ 124, 0x00 },  { 125, 0x00 },  { 126, 0x00 },  { 127, 0x00 },\n\n\t \n\t{ 128, 0x00 },  { 129, 0x00 },  { 130, 0x00 },  { 131, 0x00 },\n\t{ 132, 0x00 },  { 133, 0x00 },  { 134, 0x00 },  { 135, 0x00 },\n\t{ 136, 0x00 },  { 137, 0x00 },  { 138, 0x00 },  { 139, 0x00 },\n\t{ 140, 0x00 },  { 141, 0x00 },  { 142, 0x00 },  { 143, 0x00 },\n\t{ 144, 0x00 },  { 145, 0x00 },  { 146, 0x00 },  { 147, 0x00 },\n\t{ 148, 0x00 },  { 149, 0x00 },  { 150, 0x00 },  { 151, 0x00 },\n\t{ 152, 0x00 },  { 153, 0x00 },  { 154, 0x00 },  { 155, 0x00 },\n\t{ 156, 0x00 },  { 157, 0x00 },  { 158, 0x00 },  { 159, 0x00 },\n\t{ 160, 0x00 },  { 161, 0x00 },  { 162, 0x00 },  { 163, 0x00 },\n\t{ 164, 0x00 },  { 165, 0x00 },  { 166, 0x00 },  { 167, 0x00 },\n\t{ 168, 0x00 },  { 169, 0x00 },  { 170, 0x00 },  { 171, 0x00 },\n\t{ 172, 0x00 },  { 173, 0x00 },  { 174, 0x00 },  { 175, 0x00 },\n\t{ 176, 0x00 },  { 177, 0x00 },  { 178, 0x00 },  { 179, 0x00 },\n\t{ 180, 0xff },  { 181, 0x00 },  { 182, 0x3f },  { 183, 0xff },\n\t{ 184, 0x00 },  { 185, 0x3f },  { 186, 0x00 },  { 187, 0x80 },\n\t{ 188, 0x80 },  { 189, 0x00 },  { 190, 0x00 },  { 191, 0x00 },\n\n\t \n\t{ 1024, 0x00 },\t\t\t{ 1026, 0x01 },\t{ 1027, 0x17 },\n\t{ 1028, 0x01 }, { 1029, 0x17 }, { 1030, 0x7d }, { 1031, 0xd3 },\n\t{ 1032, 0x7f }, { 1033, 0xff }, { 1034, 0x00 }, { 1035, 0x00 },\n\t{ 1036, 0x00 }, { 1037, 0x00 }, { 1038, 0x7f }, { 1039, 0xff },\n\t{ 1040, 0x00 }, { 1041, 0x00 }, { 1042, 0x00 }, { 1043, 0x00 },\n\t{ 1044, 0x00 }, { 1045, 0x00 }, { 1046, 0x00 }, { 1047, 0x00 },\n\t{ 1048, 0x7f }, { 1049, 0xff }, { 1050, 0x00 }, { 1051, 0x00 },\n\t{ 1052, 0x00 }, { 1053, 0x00 }, { 1054, 0x00 }, { 1055, 0x00 },\n\t{ 1056, 0x00 }, { 1057, 0x00 }, { 1058, 0x7f }, { 1059, 0xff },\n\t{ 1060, 0x00 }, { 1061, 0x00 }, { 1062, 0x00 }, { 1063, 0x00 },\n\t{ 1064, 0x00 }, { 1065, 0x00 }, { 1066, 0x00 }, { 1067, 0x00 },\n\t{ 1068, 0x7f }, { 1069, 0xff }, { 1070, 0x00 }, { 1071, 0x00 },\n\t{ 1072, 0x00 }, { 1073, 0x00 }, { 1074, 0x00 }, { 1075, 0x00 },\n\t{ 1076, 0x00 }, { 1077, 0x00 }, { 1078, 0x7f }, { 1079, 0xff },\n\t{ 1080, 0x00 }, { 1081, 0x00 }, { 1082, 0x00 }, { 1083, 0x00 },\n\t{ 1084, 0x00 }, { 1085, 0x00 }, { 1086, 0x00 }, { 1087, 0x00 },\n\t{ 1088, 0x00 }, { 1089, 0x00 }, { 1090, 0x00 }, { 1091, 0x00 },\n\t{ 1092, 0x00 }, { 1093, 0x00 }, { 1094, 0x00 }, { 1095, 0x00 },\n\t{ 1096, 0x00 }, { 1097, 0x00 }, { 1098, 0x00 }, { 1099, 0x00 },\n\t{ 1100, 0x00 }, { 1101, 0x00 }, { 1102, 0x00 }, { 1103, 0x00 },\n\t{ 1104, 0x00 }, { 1105, 0x00 }, { 1106, 0x00 }, { 1107, 0x00 },\n\t{ 1108, 0x00 }, { 1109, 0x00 }, { 1110, 0x00 }, { 1111, 0x00 },\n\t{ 1112, 0x00 }, { 1113, 0x00 }, { 1114, 0x00 }, { 1115, 0x00 },\n\t{ 1116, 0x00 }, { 1117, 0x00 }, { 1118, 0x00 }, { 1119, 0x00 },\n\t{ 1120, 0x00 }, { 1121, 0x00 }, { 1122, 0x00 }, { 1123, 0x00 },\n\t{ 1124, 0x00 }, { 1125, 0x00 }, { 1126, 0x00 }, { 1127, 0x00 },\n\t{ 1128, 0x00 }, { 1129, 0x00 }, { 1130, 0x00 }, { 1131, 0x00 },\n\t{ 1132, 0x00 }, { 1133, 0x00 }, { 1134, 0x00 }, { 1135, 0x00 },\n\t{ 1136, 0x00 }, { 1137, 0x00 }, { 1138, 0x00 }, { 1139, 0x00 },\n\t{ 1140, 0x00 }, { 1141, 0x00 }, { 1142, 0x00 }, { 1143, 0x00 },\n\t{ 1144, 0x00 }, { 1145, 0x00 }, { 1146, 0x00 }, { 1147, 0x00 },\n\t{ 1148, 0x00 }, { 1149, 0x00 }, { 1150, 0x00 }, { 1151, 0x00 },\n};\n\nstatic bool adc3xxx_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ADC3XXX_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_range_cfg adc3xxx_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 5 * ADC3XXX_PAGE_SIZE,\n\t\t.selector_reg = ADC3XXX_PAGE_SELECT,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = ADC3XXX_PAGE_SIZE,\n\t}\n};\n\nstatic const struct regmap_config adc3xxx_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = adc3xxx_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adc3xxx_defaults),\n\n\t.volatile_reg = adc3xxx_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.ranges = adc3xxx_ranges,\n\t.num_ranges = ARRAY_SIZE(adc3xxx_ranges),\n\t.max_register = 5 * ADC3XXX_PAGE_SIZE,\n};\n\nstruct adc3xxx_rate_divs {\n\tu32 mclk;\n\tu32 rate;\n\tu8 pll_p;\n\tu8 pll_r;\n\tu8 pll_j;\n\tu16 pll_d;\n\tu8 nadc;\n\tu8 madc;\n\tu8 aosr;\n};\n\n \nstatic const struct adc3xxx_rate_divs adc3xxx_divs[] = {\n\t \n\t \n\t{ 12000000, 8000, 1, 1, 7, 1680, 42, 2, 128 },\n\t{ 12288000, 8000, 1, 1, 7, 0000, 42, 2, 128 },\n\t \n\t{ 12000000, 11025, 1, 1, 6, 8208, 29, 2, 128 },\n\t \n\t{ 12000000, 16000, 1, 1, 7, 1680, 21, 2, 128 },\n\t{ 12288000, 16000, 1, 1, 7, 0000, 21, 2, 128 },\n\t \n\t{ 12000000, 22050, 1, 1, 7, 560, 15, 2, 128 },\n\t \n\t{ 12000000, 32000, 1, 1, 8, 1920, 12, 2, 128 },\n\t{ 12288000, 32000, 1, 1, 8, 0000, 12, 2, 128 },\n\t \n\t{ 12000000, 44100, 1, 1, 7, 5264, 8, 2, 128 },\n\t \n\t{ 12000000, 48000, 1, 1, 7, 1680, 7, 2, 128 },\n\t{ 12288000, 48000, 1, 1, 7, 0000, 7, 2, 128 },\n\t{ 24576000, 48000, 1, 1, 3, 5000, 7, 2, 128 },  \n\t{ 24576000, 48000, 0, 0, 0, 0000, 2, 2, 128 },  \n\t \n\t{ 12000000, 88200, 1, 1, 7, 5264, 4, 4, 64 },\n\t \n\t{ 12000000, 96000, 1, 1, 8, 1920, 4, 4, 64 },\n};\n\nstatic int adc3xxx_get_divs(struct device *dev, int mclk, int rate, int pll_mode)\n{\n\tint i;\n\n\tdev_dbg(dev, \"mclk = %d, rate = %d, clock mode %u\\n\",\n\t\tmclk, rate, pll_mode);\n\tfor (i = 0; i < ARRAY_SIZE(adc3xxx_divs); i++) {\n\t\tconst struct adc3xxx_rate_divs *mode = &adc3xxx_divs[i];\n\n\t\t \n\t\tif ((pll_mode == ADC3XXX_PLL_BYPASS && mode->pll_p) ||\n\t\t    (pll_mode == ADC3XXX_PLL_ENABLE && !mode->pll_p))\n\t\t\tcontinue;\n\n\t\tif (mode->rate == rate && mode->mclk == mclk)\n\t\t\treturn i;\n\t}\n\n\tdev_info(dev, \"Master clock rate %d and sample rate %d is not supported\\n\",\n\t\t mclk, rate);\n\treturn -EINVAL;\n}\n\nstatic int adc3xxx_pll_delay(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\t \n\tusleep_range(10000, 20000);\n\n\treturn 0;\n}\n\nstatic int adc3xxx_coefficient_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tint numcoeff = kcontrol->private_value >> 16;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = numcoeff;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffff;  \n\treturn 0;\n}\n\nstatic int adc3xxx_coefficient_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint numcoeff  = kcontrol->private_value >> 16;\n\tint reg = kcontrol->private_value & 0xffff;\n\tint index = 0;\n\n\tfor (index = 0; index < numcoeff; index++) {\n\t\tunsigned int value_msb, value_lsb, value;\n\n\t\tvalue_msb = snd_soc_component_read(component, reg++);\n\t\tif ((int)value_msb < 0)\n\t\t\treturn (int)value_msb;\n\n\t\tvalue_lsb = snd_soc_component_read(component, reg++);\n\t\tif ((int)value_lsb < 0)\n\t\t\treturn (int)value_lsb;\n\n\t\tvalue = (value_msb << 8) | value_lsb;\n\t\tucontrol->value.integer.value[index] = value;\n\t}\n\n\treturn 0;\n}\n\nstatic int adc3xxx_coefficient_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tint numcoeff  = kcontrol->private_value >> 16;\n\tint reg = kcontrol->private_value & 0xffff;\n\tint index = 0;\n\tint ret;\n\n\tfor (index = 0; index < numcoeff; index++) {\n\t\tunsigned int value = ucontrol->value.integer.value[index];\n\t\tunsigned int value_msb = (value >> 8) & 0xff;\n\t\tunsigned int value_lsb = value & 0xff;\n\n\t\tret = snd_soc_component_write(component, reg++, value_msb);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_component_write(component, reg++, value_lsb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n#define TI_COEFFICIENTS(xname, reg, numcoeffs) { \\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \\\n\t.name = xname, \\\n\t.info = adc3xxx_coefficient_info, \\\n\t.get = adc3xxx_coefficient_get,\\\n\t.put = adc3xxx_coefficient_put, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.private_value = reg | (numcoeffs << 16) \\\n}\n\nstatic const char * const adc_softstepping_text[] = { \"1 step\", \"2 step\", \"off\" };\nstatic SOC_ENUM_SINGLE_DECL(adc_softstepping_enum, ADC3XXX_ADC_DIGITAL, 0,\n\t\t\t    adc_softstepping_text);\n\nstatic const char * const multiplier_text[] = { \"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\", \"128\" };\nstatic SOC_ENUM_SINGLE_DECL(left_agc_attack_mult_enum,\n\t\t\t    ADC3XXX_LEFT_CHN_AGC_4, 0, multiplier_text);\nstatic SOC_ENUM_SINGLE_DECL(right_agc_attack_mult_enum,\n\t\t\t    ADC3XXX_RIGHT_CHN_AGC_4, 0, multiplier_text);\nstatic SOC_ENUM_SINGLE_DECL(left_agc_decay_mult_enum,\n\t\t\t    ADC3XXX_LEFT_CHN_AGC_5, 0, multiplier_text);\nstatic SOC_ENUM_SINGLE_DECL(right_agc_decay_mult_enum,\n\t\t\t    ADC3XXX_RIGHT_CHN_AGC_5, 0, multiplier_text);\n\nstatic const char * const dither_dc_offset_text[] = {\n\t\"0mV\", \"15mV\", \"30mV\", \"45mV\", \"60mV\", \"75mV\", \"90mV\", \"105mV\",\n\t\"-15mV\", \"-30mV\", \"-45mV\", \"-60mV\", \"-75mV\", \"-90mV\", \"-105mV\"\n};\nstatic const unsigned int dither_dc_offset_values[] = {\n\t0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15\n};\nstatic SOC_VALUE_ENUM_DOUBLE_DECL(dither_dc_offset_enum,\n\t\t\t\t  ADC3XXX_DITHER_CTRL,\n\t\t\t\t  4, 0, 0xf, dither_dc_offset_text,\n\t\t\t\t  dither_dc_offset_values);\n\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, 0, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -1200, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_fine_tlv, -40, 10, 0);\n \n \nstatic const DECLARE_TLV_DB_RANGE(agc_target_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(-2400, 0, 0),\n\t1, 3, TLV_DB_SCALE_ITEM(-2000, 300, 0),\n\t4, 6, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t7, 7, TLV_DB_SCALE_ITEM(-550, 0, 0));\n \nstatic const DECLARE_TLV_DB_RANGE(agc_thresh_tlv,\n\t0, 30, TLV_DB_SCALE_ITEM(-9000, 200, 0),\n\t31, 31, TLV_DB_SCALE_ITEM(0, 0, 1));  \n \nstatic const DECLARE_TLV_DB_RANGE(agc_hysteresis_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(100, 100, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(400, 0, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(0, 0, 1));  \nstatic const DECLARE_TLV_DB_SCALE(agc_max_tlv, 0, 50, 0);\n \nstatic const DECLARE_TLV_DB_SCALE(input_attenuation_tlv, -600, 600, 0);\n\nstatic const struct snd_kcontrol_new adc3xxx_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"PGA Capture Volume\", ADC3XXX_LEFT_APGA_CTRL,\n\t\t\t ADC3XXX_RIGHT_APGA_CTRL, 0, 80, 0, pga_tlv),\n\tSOC_DOUBLE(\"PGA Capture Switch\", ADC3XXX_ADC_FGA, 7, 3, 1, 1),\n\tSOC_DOUBLE_R(\"AGC Capture Switch\", ADC3XXX_LEFT_CHN_AGC_1,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_1, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"AGC Target Level Capture Volume\", ADC3XXX_LEFT_CHN_AGC_1,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_2, 4, 0x07, 1, agc_target_tlv),\n\tSOC_DOUBLE_R_TLV(\"AGC Noise Threshold Capture Volume\", ADC3XXX_LEFT_CHN_AGC_2,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_2, 1, 0x1f, 1, agc_thresh_tlv),\n\tSOC_DOUBLE_R_TLV(\"AGC Hysteresis Capture Volume\", ADC3XXX_LEFT_CHN_AGC_2,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_2, 6, 3, 0, agc_hysteresis_tlv),\n\tSOC_DOUBLE_R(\"AGC Clip Stepping Capture Switch\", ADC3XXX_LEFT_CHN_AGC_2,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_2, 0, 1, 0),\n\t \n\tSOC_DOUBLE_R_TLV(\"AGC Maximum Capture Volume\", ADC3XXX_LEFT_CHN_AGC_3,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_3, 0, 0x50, 0, agc_max_tlv),\n\tSOC_DOUBLE_R(\"AGC Attack Time\", ADC3XXX_LEFT_CHN_AGC_4,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_4, 3, 0x1f, 0),\n\t \n\tSOC_ENUM(\"AGC Left Attack Time Multiplier\", left_agc_attack_mult_enum),\n\tSOC_ENUM(\"AGC Right Attack Time Multiplier\", right_agc_attack_mult_enum),\n\tSOC_DOUBLE_R(\"AGC Decay Time\", ADC3XXX_LEFT_CHN_AGC_5,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_5, 3, 0x1f, 0),\n\tSOC_ENUM(\"AGC Left Decay Time Multiplier\", left_agc_decay_mult_enum),\n\tSOC_ENUM(\"AGC Right Decay Time Multiplier\", right_agc_decay_mult_enum),\n\tSOC_DOUBLE_R(\"AGC Noise Debounce\", ADC3XXX_LEFT_CHN_AGC_6,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_6, 0, 0x1f, 0),\n\tSOC_DOUBLE_R(\"AGC Signal Debounce\", ADC3XXX_LEFT_CHN_AGC_7,\n\t\t     ADC3XXX_RIGHT_CHN_AGC_7, 0, 0x0f, 0),\n\t \n\tSOC_DOUBLE_R_S_TLV(\"AGC Applied Capture Volume\", ADC3XXX_LEFT_AGC_GAIN,\n\t\t\t   ADC3XXX_RIGHT_AGC_GAIN, 0, -24, 40, 6, 0, adc_tlv),\n\t \n\tSOC_ENUM(\"ADC Soft Stepping\", adc_softstepping_enum),\n\t \n\tSOC_SINGLE_TLV(\"Left Input IN_1L Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_1, 0, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input IN_2L Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_1, 2, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input IN_3L Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_1, 4, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input IN_1R Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_2, 0, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input DIF_2L_3L Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_1, 6, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input DIF_1L_1R Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_2, 4, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Left Input DIF_2R_3R Capture Volume\",\n\t\t       ADC3XXX_LEFT_PGA_SEL_2, 2, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input IN_1R Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_1, 0, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input IN_2R Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_1, 2, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input IN_3R Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_1, 4, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input IN_1L Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_2, 0, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input DIF_2R_3R Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_1, 6, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input DIF_1L_1R Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_2, 4, 1, 1, input_attenuation_tlv),\n\tSOC_SINGLE_TLV(\"Right Input DIF_2L_3L Capture Volume\",\n\t\t       ADC3XXX_RIGHT_PGA_SEL_2, 2, 1, 1, input_attenuation_tlv),\n\tSOC_DOUBLE_R_S_TLV(\"ADC Volume Control Capture Volume\", ADC3XXX_LADC_VOL,\n\t\t\t   ADC3XXX_RADC_VOL, 0, -24, 40, 6, 0, adc_tlv),\n\t \n\tSOC_DOUBLE_TLV(\"ADC Fine Volume Control Capture Volume\", ADC3XXX_ADC_FGA,\n\t\t       4, 0, 4, 1, adc_fine_tlv),\n\tSOC_SINGLE(\"Left ADC Unselected CM Bias Capture Switch\",\n\t\t   ADC3XXX_LEFT_PGA_SEL_2, 6, 1, 0),\n\tSOC_SINGLE(\"Right ADC Unselected CM Bias Capture Switch\",\n\t\t   ADC3XXX_RIGHT_PGA_SEL_2, 6, 1, 0),\n\tSOC_ENUM(\"Dither Control DC Offset\", dither_dc_offset_enum),\n\n\t \n\t \n\n\tTI_COEFFICIENTS(\"Left ADC IIR Coefficients N0 N1 D1\",\n\t\t\tADC3XXX_LEFT_ADC_IIR_COEFF_N0_MSB, 3),\n\n\tTI_COEFFICIENTS(\"Right ADC IIR Coefficients N0 N1 D1\",\n\t\t\tADC3XXX_RIGHT_ADC_IIR_COEFF_N0_MSB, 3),\n};\n\n \nstatic const struct snd_kcontrol_new left_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN_1L Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_1, 1, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_2L Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_1, 3, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_3L Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_1, 5, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_2L_3L Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_1, 7, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_1L_1R Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_2, 5, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_2R_3R Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_2, 3, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_1R Capture Switch\",\n\t\t\tADC3XXX_LEFT_PGA_SEL_2, 1, 0x1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new right_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"IN_1R Capture Switch\",\n\t\t\tADC3XXX_RIGHT_PGA_SEL_1, 1, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_2R Capture Switch\",\n\t\t\tADC3XXX_RIGHT_PGA_SEL_1, 3, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_3R Capture Switch\",\n\t\t\t ADC3XXX_RIGHT_PGA_SEL_1, 5, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_2R_3R Capture Switch\",\n\t\t\t ADC3XXX_RIGHT_PGA_SEL_1, 7, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_1L_1R Capture Switch\",\n\t\t\t ADC3XXX_RIGHT_PGA_SEL_2, 5, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"DIF_2L_3L Capture Switch\",\n\t\t\t ADC3XXX_RIGHT_PGA_SEL_2, 3, 0x1, 1),\n\tSOC_DAPM_SINGLE(\"IN_1L Capture Switch\",\n\t\t\t ADC3XXX_RIGHT_PGA_SEL_2, 1, 0x1, 1),\n};\n\n \nstatic const struct snd_kcontrol_new left_input_dmic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left ADC Capture Switch\",\n\t\t\tADC3XXX_ADC_DIGITAL, 3, 0x1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new right_input_dmic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Right ADC Capture Switch\",\n\t\t\tADC3XXX_ADC_DIGITAL, 2, 0x1, 0),\n};\n\n \nstatic const struct snd_soc_dapm_widget adc3xxx_dapm_widgets[] = {\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Left Input\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &left_input_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(left_input_mixer_controls)),\n\t \n\tSND_SOC_DAPM_MIXER(\"Right Input\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &right_input_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(right_input_mixer_controls)),\n\t \n\tSND_SOC_DAPM_PGA(\"Left PGA\", ADC3XXX_LEFT_APGA_CTRL, 7, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right PGA\", ADC3XXX_RIGHT_APGA_CTRL, 7, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Left DMic Input\", SND_SOC_NOPM, 0, 0,\n\t\t\t&left_input_dmic_controls[0],\n\t\t\tARRAY_SIZE(left_input_dmic_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right DMic Input\", SND_SOC_NOPM, 0, 0,\n\t\t\t&right_input_dmic_controls[0],\n\t\t\tARRAY_SIZE(right_input_dmic_controls)),\n\n\t \n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", ADC3XXX_ADC_DIGITAL, 7, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", ADC3XXX_ADC_DIGITAL, 6, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"IN_1L\"),\n\tSND_SOC_DAPM_INPUT(\"IN_1R\"),\n\tSND_SOC_DAPM_INPUT(\"IN_2L\"),\n\tSND_SOC_DAPM_INPUT(\"IN_2R\"),\n\tSND_SOC_DAPM_INPUT(\"IN_3L\"),\n\tSND_SOC_DAPM_INPUT(\"IN_3R\"),\n\tSND_SOC_DAPM_INPUT(\"DIFL_1L_1R\"),\n\tSND_SOC_DAPM_INPUT(\"DIFL_2L_3L\"),\n\tSND_SOC_DAPM_INPUT(\"DIFL_2R_3R\"),\n\tSND_SOC_DAPM_INPUT(\"DIFR_1L_1R\"),\n\tSND_SOC_DAPM_INPUT(\"DIFR_2L_3L\"),\n\tSND_SOC_DAPM_INPUT(\"DIFR_2R_3R\"),\n\tSND_SOC_DAPM_INPUT(\"DMic_L\"),\n\tSND_SOC_DAPM_INPUT(\"DMic_R\"),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"AIF_OUT\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"PLL_CLK\", ADC3XXX_PLL_PROG_PR, ADC3XXX_ENABLE_PLL_SHIFT,\n\t\t\t    0, adc3xxx_pll_delay, SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_SUPPLY(\"ADC_CLK\", ADC3XXX_ADC_NADC, ADC3XXX_ENABLE_NADC_SHIFT,\n\t\t\t    0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC_MOD_CLK\", ADC3XXX_ADC_MADC, ADC3XXX_ENABLE_MADC_SHIFT,\n\t\t\t    0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"BCLK\", ADC3XXX_BCLK_N_DIV, ADC3XXX_ENABLE_BCLK_SHIFT,\n\t\t\t    0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route adc3xxx_intercon[] = {\n\t \n\t{ \"Left Input\", \"IN_1L Capture Switch\", \"IN_1L\" },\n\t{ \"Left Input\", \"IN_2L Capture Switch\", \"IN_2L\" },\n\t{ \"Left Input\", \"IN_3L Capture Switch\", \"IN_3L\" },\n\t{ \"Left Input\", \"DIF_2L_3L Capture Switch\", \"DIFL_2L_3L\" },\n\t{ \"Left Input\", \"DIF_1L_1R Capture Switch\", \"DIFL_1L_1R\" },\n\t{ \"Left Input\", \"DIF_2R_3R Capture Switch\", \"DIFL_2R_3R\" },\n\t{ \"Left Input\", \"IN_1R Capture Switch\", \"IN_1R\" },\n\n\t \n\t{ \"Left PGA\", NULL, \"Left Input\" },\n\n\t \n\t{ \"Left ADC\", NULL, \"Left PGA\" },\n\n\t \n\t{ \"Right Input\", \"IN_1R Capture Switch\", \"IN_1R\" },\n\t{ \"Right Input\", \"IN_2R Capture Switch\", \"IN_2R\" },\n\t{ \"Right Input\", \"IN_3R Capture Switch\", \"IN_3R\" },\n\t{ \"Right Input\", \"DIF_2R_3R Capture Switch\", \"DIFR_2R_3R\" },\n\t{ \"Right Input\", \"DIF_1L_1R Capture Switch\", \"DIFR_1L_1R\" },\n\t{ \"Right Input\", \"DIF_2L_3L Capture Switch\", \"DIFR_2L_3L\" },\n\t{ \"Right Input\", \"IN_1L Capture Switch\", \"IN_1L\" },\n\n\t \n\t{ \"Right PGA\", NULL, \"Right Input\" },\n\n\t \n\t{ \"Right ADC\", NULL, \"Right PGA\" },\n\n\t \n\t{ \"Left DMic Input\", \"Left ADC Capture Switch\", \"DMic_L\" },\n\n\t \n\t{ \"Left ADC\", NULL, \"Left DMic Input\" },\n\n\t \n\t{ \"Right DMic Input\", \"Right ADC Capture Switch\", \"DMic_R\" },\n\n\t \n\t{ \"Right ADC\", NULL, \"Right DMic Input\" },\n\n\t \n\t{ \"AIF_OUT\", NULL, \"Left ADC\" },\n\t{ \"AIF_OUT\", NULL, \"Right ADC\" },\n\n\t \n\t{ \"ADC_MOD_CLK\", NULL, \"ADC_CLK\" },\n\t{ \"Left ADC\", NULL, \"ADC_MOD_CLK\" },\n\t{ \"Right ADC\", NULL, \"ADC_MOD_CLK\" },\n\n\t{ \"BCLK\", NULL, \"ADC_CLK\" },\n};\n\nstatic const struct snd_soc_dapm_route adc3xxx_pll_intercon[] = {\n\t{ \"ADC_CLK\", NULL, \"PLL_CLK\" },\n};\n\nstatic const struct snd_soc_dapm_route adc3xxx_bclk_out_intercon[] = {\n\t{ \"AIF_OUT\", NULL, \"BCLK\" }\n};\n\nstatic int adc3xxx_gpio_request(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct adc3xxx *adc3xxx = gpiochip_get_data(chip);\n\n\tif (offset >= ADC3XXX_GPIOS_MAX)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (adc3xxx->gpio_cfg[offset] != 0 &&\n\t    adc3xxx->gpio_cfg[offset] != ADC3XXX_GPIO_GPO + 1)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int adc3xxx_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset, int value)\n{\n\tstruct adc3xxx *adc3xxx = gpiochip_get_data(chip);\n\n\t \n\treturn regmap_update_bits(adc3xxx->regmap,\n\t\t\t\t  adc3xxx_gpio_ctrl_reg[offset],\n\t\t\t\t  ADC3XXX_GPIO_CTRL_CFG_MASK |\n\t\t\t\t  ADC3XXX_GPIO_CTRL_OUTPUT_CTRL_MASK,\n\t\t\t\t  ADC3XXX_GPIO_GPO << ADC3XXX_GPIO_CTRL_CFG_SHIFT |\n\t\t\t\t  !!value << ADC3XXX_GPIO_CTRL_OUTPUT_CTRL_SHIFT);\n}\n\n \nstatic void adc3xxx_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     int value)\n{\n\t(void) adc3xxx_gpio_direction_out(chip, offset, value);\n}\n\n \nstatic int adc3xxx_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct adc3xxx *adc3xxx = gpiochip_get_data(chip);\n\tunsigned int regval;\n\tint ret;\n\n\t \n\tret = regmap_read(adc3xxx->regmap, adc3xxx_gpio_ctrl_reg[offset], &regval);\n\tif (ret)\n\t\treturn ret;\n\treturn !!(regval & ADC3XXX_GPIO_CTRL_OUTPUT_CTRL_MASK);\n}\n\nstatic const struct gpio_chip adc3xxx_gpio_chip = {\n\t.label\t\t\t= \"adc3xxx\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.request\t\t= adc3xxx_gpio_request,\n\t.direction_output\t= adc3xxx_gpio_direction_out,\n\t.set\t\t\t= adc3xxx_gpio_set,\n\t.get\t\t\t= adc3xxx_gpio_get,\n\t.can_sleep\t\t= 1,\n};\n\nstatic void adc3xxx_free_gpio(struct adc3xxx *adc3xxx)\n{\n#ifdef CONFIG_GPIOLIB\n\tgpiochip_remove(&adc3xxx->gpio_chip);\n#endif\n}\n\nstatic void adc3xxx_init_gpio(struct adc3xxx *adc3xxx)\n{\n\tint gpio, micbias;\n\tint ret;\n\n\tadc3xxx->gpio_chip = adc3xxx_gpio_chip;\n\tadc3xxx->gpio_chip.ngpio = ADC3XXX_GPIOS_MAX;\n\tadc3xxx->gpio_chip.parent = adc3xxx->dev;\n\tadc3xxx->gpio_chip.base = -1;\n\n\tret = gpiochip_add_data(&adc3xxx->gpio_chip, adc3xxx);\n\tif (ret)\n\t\tdev_err(adc3xxx->dev, \"Failed to add gpios: %d\\n\", ret);\n\n\t \n\tfor (gpio = 0; gpio < ADC3XXX_GPIOS_MAX; gpio++) {\n\t\tunsigned int cfg = adc3xxx->gpio_cfg[gpio];\n\n\t\tif (cfg) {\n\t\t\tcfg--;  \n\t\t\tregmap_update_bits(adc3xxx->regmap,\n\t\t\t\t\t   adc3xxx_gpio_ctrl_reg[gpio],\n\t\t\t\t\t   ADC3XXX_GPIO_CTRL_CFG_MASK,\n\t\t\t\t\t   cfg << ADC3XXX_GPIO_CTRL_CFG_SHIFT);\n\t\t}\n\t}\n\n\t \n\tfor (micbias = 0; micbias < ADC3XXX_MICBIAS_PINS; micbias++) {\n\t\tunsigned int vg = adc3xxx->micbias_vg[micbias];\n\n\t\tregmap_update_bits(adc3xxx->regmap,\n\t\t\t\t   ADC3XXX_MICBIAS_CTRL,\n\t\t\t\t   ADC3XXX_MICBIAS_MASK << adc3xxx_micbias_shift[micbias],\n\t\t\t\t   vg << adc3xxx_micbias_shift[micbias]);\n\t}\n}\n\nstatic int adc3xxx_parse_dt_gpio(struct adc3xxx *adc3xxx,\n\t\t\t\t const char *propname, unsigned int *cfg)\n{\n\tstruct device *dev = adc3xxx->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int val;\n\n\tif (!of_property_read_u32(np, propname, &val)) {\n\t\tif (val & ~15 || val == 7 || val >= 11) {\n\t\t\tdev_err(dev, \"Invalid property value for '%s'\\n\", propname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val == ADC3XXX_GPIO_GPI)\n\t\t\tdev_warn(dev, \"GPIO Input read not yet implemented\\n\");\n\t\t*cfg = val + 1;  \n\t}\n\treturn 0;\n}\n\nstatic int adc3xxx_parse_dt_micbias(struct adc3xxx *adc3xxx,\n\t\t\t\t    const char *propname, unsigned int *vg)\n{\n\tstruct device *dev = adc3xxx->dev;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int val;\n\n\tif (!of_property_read_u32(np, propname, &val)) {\n\t\tif (val > ADC3XXX_MICBIAS_AVDD) {\n\t\t\tdev_err(dev, \"Invalid property value for '%s'\\n\", propname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*vg = val;\n\t}\n\treturn 0;\n}\n\nstatic int adc3xxx_parse_pll_mode(uint32_t val, unsigned int *pll_mode)\n{\n\tif (val != ADC3XXX_PLL_ENABLE && val != ADC3XXX_PLL_BYPASS &&\n\t    val != ADC3XXX_PLL_AUTO)\n\t\treturn -EINVAL;\n\n\t*pll_mode = val;\n\n\treturn 0;\n}\n\nstatic void adc3xxx_setup_pll(struct snd_soc_component *component,\n\t\t\t      int div_entry)\n{\n\tint i = div_entry;\n\n\t \n\tsnd_soc_component_write(component, ADC3XXX_PLL_PROG_PR,\n\t\t\t\t(adc3xxx_divs[i].pll_p << ADC3XXX_PLLP_SHIFT) |\n\t\t\t\t(adc3xxx_divs[i].pll_r << ADC3XXX_PLLR_SHIFT));\n\t \n\tsnd_soc_component_write(component, ADC3XXX_PLL_PROG_J,\n\t\t\t\tadc3xxx_divs[i].pll_j & ADC3XXX_PLLJ_MASK);\n\t \n\tsnd_soc_component_write(component, ADC3XXX_PLL_PROG_D_LSB,\n\t\t\t\tadc3xxx_divs[i].pll_d & ADC3XXX_PLLD_LSB_MASK);\n\tsnd_soc_component_write(component, ADC3XXX_PLL_PROG_D_MSB,\n\t\t\t\t(adc3xxx_divs[i].pll_d >> 8) & ADC3XXX_PLLD_MSB_MASK);\n}\n\nstatic int adc3xxx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(dai->component);\n\tstruct adc3xxx *adc3xxx = snd_soc_component_get_drvdata(component);\n\tint i, width = 16;\n\tu8 iface_len, bdiv;\n\n\ti = adc3xxx_get_divs(component->dev, adc3xxx->sysclk,\n\t\t\t     params_rate(params), adc3xxx->pll_mode);\n\n\tif (i < 0)\n\t\treturn i;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tiface_len = ADC3XXX_IFACE_16BITS;\n\t\twidth = 16;\n\t\tbreak;\n\tcase 20:\n\t\tiface_len = ADC3XXX_IFACE_20BITS;\n\t\twidth = 20;\n\t\tbreak;\n\tcase 24:\n\t\tiface_len = ADC3XXX_IFACE_24BITS;\n\t\twidth = 24;\n\t\tbreak;\n\tcase 32:\n\t\tiface_len = ADC3XXX_IFACE_32BITS;\n\t\twidth = 32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported serial data format\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, ADC3XXX_INTERFACE_CTRL_1,\n\t\t\t\t      ADC3XXX_WLENGTH_MASK, iface_len);\n\tif (adc3xxx_divs[i].pll_p) {  \n\t\tadc3xxx_setup_pll(component, i);\n\t\tsnd_soc_component_write(component, ADC3XXX_CLKGEN_MUX, ADC3XXX_USE_PLL);\n\t\tif (!adc3xxx->use_pll) {\n\t\t\tsnd_soc_dapm_add_routes(dapm, adc3xxx_pll_intercon,\n\t\t\t\t\t\tARRAY_SIZE(adc3xxx_pll_intercon));\n\t\t\tadc3xxx->use_pll = 1;\n\t\t}\n\t} else {\n\t\tsnd_soc_component_write(component, ADC3XXX_CLKGEN_MUX, ADC3XXX_NO_PLL);\n\t\tif (adc3xxx->use_pll) {\n\t\t\tsnd_soc_dapm_del_routes(dapm, adc3xxx_pll_intercon,\n\t\t\t\t\t\tARRAY_SIZE(adc3xxx_pll_intercon));\n\t\t\tadc3xxx->use_pll = 0;\n\t\t}\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, ADC3XXX_ADC_NADC,\n\t\t\t\t      ADC3XXX_NADC_MASK, adc3xxx_divs[i].nadc);\n\t \n\tsnd_soc_component_update_bits(component, ADC3XXX_ADC_MADC,\n\t\t\t\t      ADC3XXX_MADC_MASK, adc3xxx_divs[i].madc);\n\t \n\tsnd_soc_component_update_bits(component, ADC3XXX_ADC_AOSR,\n\t\t\t\t      ADC3XXX_AOSR_MASK, adc3xxx_divs[i].aosr);\n\t \n\t \n\tbdiv = (adc3xxx_divs[i].aosr * adc3xxx_divs[i].madc) / (2 * width);\n\tsnd_soc_component_update_bits(component, ADC3XXX_BCLK_N_DIV,\n\t\t\t\t      ADC3XXX_BDIV_MASK, bdiv);\n\n\treturn 0;\n}\n\nstatic const char *adc3xxx_pll_mode_text(int pll_mode)\n{\n\tswitch (pll_mode) {\n\tcase ADC3XXX_PLL_AUTO:\n\t\treturn \"PLL auto\";\n\tcase ADC3XXX_PLL_ENABLE:\n\t\treturn \"PLL enable\";\n\tcase ADC3XXX_PLL_BYPASS:\n\t\treturn \"PLL bypass\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"PLL unknown\";\n}\n\nstatic int adc3xxx_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct adc3xxx *adc3xxx = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = adc3xxx_parse_pll_mode(clk_id, &adc3xxx->pll_mode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tadc3xxx->sysclk = freq;\n\tdev_dbg(component->dev, \"Set sysclk to %u Hz, %s\\n\",\n\t\tfreq, adc3xxx_pll_mode_text(adc3xxx->pll_mode));\n\treturn 0;\n}\n\nstatic int adc3xxx_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adc3xxx *adc3xxx = snd_soc_component_get_drvdata(component);\n\tu8 clkdir = 0, format = 0;\n\tint master = 0;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tmaster = 1;\n\t\tclkdir = ADC3XXX_BCLK_MASTER | ADC3XXX_WCLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock setup\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK)) {\n\tcase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF:\n\t\tformat = ADC3XXX_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_IB_NF:\n\t\tformat = ADC3XXX_FORMAT_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF:\n\t\tformat = ADC3XXX_FORMAT_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J | SND_SOC_DAIFMT_NB_NF:\n\t\tformat = ADC3XXX_FORMAT_RJF;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF:\n\t\tformat = ADC3XXX_FORMAT_LJF;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (master && !adc3xxx->master)\n\t\tsnd_soc_dapm_add_routes(dapm, adc3xxx_bclk_out_intercon,\n\t\t\t\t\tARRAY_SIZE(adc3xxx_bclk_out_intercon));\n\telse if (!master && adc3xxx->master)\n\t\tsnd_soc_dapm_del_routes(dapm, adc3xxx_bclk_out_intercon,\n\t\t\t\t\tARRAY_SIZE(adc3xxx_bclk_out_intercon));\n\tadc3xxx->master = master;\n\n\t \n\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t    ADC3XXX_INTERFACE_CTRL_1,\n\t\t\t\t\t    ADC3XXX_CLKDIR_MASK | ADC3XXX_FORMAT_MASK,\n\t\t\t\t\t    clkdir | format);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops adc3xxx_dai_ops = {\n\t.hw_params\t= adc3xxx_hw_params,\n\t.set_sysclk\t= adc3xxx_set_dai_sysclk,\n\t.set_fmt\t= adc3xxx_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver adc3xxx_dai = {\n\t.name = \"tlv320adc3xxx-hifi\",\n\t.capture = {\n\t\t    .stream_name = \"Capture\",\n\t\t    .channels_min = 1,\n\t\t    .channels_max = 2,\n\t\t    .rates = ADC3XXX_RATES,\n\t\t    .formats = ADC3XXX_FORMATS,\n\t\t   },\n\t.ops = &adc3xxx_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_adc3xxx = {\n\t.controls\t\t= adc3xxx_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adc3xxx_snd_controls),\n\t.dapm_widgets\t\t= adc3xxx_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adc3xxx_dapm_widgets),\n\t.dapm_routes\t\t= adc3xxx_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(adc3xxx_intercon),\n\t.endianness\t\t= 1,\n};\n\nstatic const struct i2c_device_id adc3xxx_i2c_id[] = {\n\t{ \"tlv320adc3001\", ADC3001 },\n\t{ \"tlv320adc3101\", ADC3101 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, adc3xxx_i2c_id);\n\nstatic int adc3xxx_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct adc3xxx *adc3xxx = NULL;\n\tconst struct i2c_device_id *id;\n\tint ret;\n\n\tadc3xxx = devm_kzalloc(dev, sizeof(struct adc3xxx), GFP_KERNEL);\n\tif (!adc3xxx)\n\t\treturn -ENOMEM;\n\tadc3xxx->dev = dev;\n\n\tadc3xxx->rst_pin = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(adc3xxx->rst_pin)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(adc3xxx->rst_pin),\n\t\t\t\t     \"Failed to request rst_pin\\n\");\n\t}\n\n\tadc3xxx->mclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(adc3xxx->mclk)) {\n\t\t \n\t\treturn dev_err_probe(dev, PTR_ERR(adc3xxx->mclk),\n\t\t\t\t     \"Failed to acquire MCLK\\n\");\n\t} else if (adc3xxx->mclk) {\n\t\tret = clk_prepare_enable(adc3xxx->mclk);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdev_dbg(dev, \"Enabled MCLK, freq %lu Hz\\n\", clk_get_rate(adc3xxx->mclk));\n\t}\n\n\tret = adc3xxx_parse_dt_gpio(adc3xxx, \"ti,dmdin-gpio1\", &adc3xxx->gpio_cfg[0]);\n\tif (ret < 0)\n\t\tgoto err_unprepare_mclk;\n\tret = adc3xxx_parse_dt_gpio(adc3xxx, \"ti,dmclk-gpio2\", &adc3xxx->gpio_cfg[1]);\n\tif (ret < 0)\n\t\tgoto err_unprepare_mclk;\n\tret = adc3xxx_parse_dt_micbias(adc3xxx, \"ti,micbias1-vg\", &adc3xxx->micbias_vg[0]);\n\tif (ret < 0)\n\t\tgoto err_unprepare_mclk;\n\tret = adc3xxx_parse_dt_micbias(adc3xxx, \"ti,micbias2-vg\", &adc3xxx->micbias_vg[1]);\n\tif (ret < 0)\n\t\tgoto err_unprepare_mclk;\n\n\tadc3xxx->regmap = devm_regmap_init_i2c(i2c, &adc3xxx_regmap);\n\tif (IS_ERR(adc3xxx->regmap)) {\n\t\tret = PTR_ERR(adc3xxx->regmap);\n\t\tgoto err_unprepare_mclk;\n\t}\n\n\ti2c_set_clientdata(i2c, adc3xxx);\n\n\tid = i2c_match_id(adc3xxx_i2c_id, i2c);\n\tadc3xxx->type = id->driver_data;\n\n\t \n\tgpiod_set_value_cansleep(adc3xxx->rst_pin, 1);\n\tusleep_range(2000, 100000);  \n\tgpiod_set_value_cansleep(adc3xxx->rst_pin, 0);\n\n\t \n\tadc3xxx_init_gpio(adc3xxx);\n\n\tret = snd_soc_register_component(dev,\n\t\t\t&soc_component_dev_adc3xxx, &adc3xxx_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register codec: %d\\n\", ret);\n\t\tgoto err_unprepare_mclk;\n\t}\n\n\treturn 0;\n\nerr_unprepare_mclk:\n\tclk_disable_unprepare(adc3xxx->mclk);\n\treturn ret;\n}\n\nstatic void __exit adc3xxx_i2c_remove(struct i2c_client *client)\n{\n\tstruct adc3xxx *adc3xxx = i2c_get_clientdata(client);\n\n\tif (adc3xxx->mclk)\n\t\tclk_disable_unprepare(adc3xxx->mclk);\n\tadc3xxx_free_gpio(adc3xxx);\n\tsnd_soc_unregister_component(&client->dev);\n}\n\nstatic const struct of_device_id tlv320adc3xxx_of_match[] = {\n\t{ .compatible = \"ti,tlv320adc3001\", },\n\t{ .compatible = \"ti,tlv320adc3101\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tlv320adc3xxx_of_match);\n\nstatic struct i2c_driver adc3xxx_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"tlv320adc3xxx-codec\",\n\t\t   .of_match_table = tlv320adc3xxx_of_match,\n\t\t  },\n\t.probe = adc3xxx_i2c_probe,\n\t.remove = __exit_p(adc3xxx_i2c_remove),\n\t.id_table = adc3xxx_i2c_id,\n};\n\nmodule_i2c_driver(adc3xxx_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC TLV320ADC3xxx codec driver\");\nMODULE_AUTHOR(\"shahina.s@mistralsolutions.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}