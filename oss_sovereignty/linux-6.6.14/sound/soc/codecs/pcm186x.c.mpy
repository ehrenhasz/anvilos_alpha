{
  "module_name": "pcm186x.c",
  "hash_id": "e222004e7e1e00c3e0a80234a88c63ca43377057fff007d8e26b54739e6037a4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm186x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"pcm186x.h\"\n\nstatic const char * const pcm186x_supply_names[] = {\n\t\"avdd\",\t\t \n\t\"dvdd\",\t\t \n\t\"iovdd\",\t \n};\n#define PCM186x_NUM_SUPPLIES ARRAY_SIZE(pcm186x_supply_names)\n\nstruct pcm186x_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[PCM186x_NUM_SUPPLIES];\n\tunsigned int sysclk;\n\tunsigned int tdm_offset;\n\tbool is_tdm_mode;\n\tbool is_provider_mode;\n};\n\nstatic const DECLARE_TLV_DB_SCALE(pcm186x_pga_tlv, -1200, 50, 0);\n\nstatic const struct snd_kcontrol_new pcm1863_snd_controls[] = {\n\tSOC_DOUBLE_R_S_TLV(\"ADC Capture Volume\", PCM186X_PGA_VAL_CH1_L,\n\t\t\t   PCM186X_PGA_VAL_CH1_R, 0, -24, 80, 7, 0,\n\t\t\t   pcm186x_pga_tlv),\n};\n\nstatic const struct snd_kcontrol_new pcm1865_snd_controls[] = {\n\tSOC_DOUBLE_R_S_TLV(\"ADC1 Capture Volume\", PCM186X_PGA_VAL_CH1_L,\n\t\t\t   PCM186X_PGA_VAL_CH1_R, 0, -24, 80, 7, 0,\n\t\t\t   pcm186x_pga_tlv),\n\tSOC_DOUBLE_R_S_TLV(\"ADC2 Capture Volume\", PCM186X_PGA_VAL_CH2_L,\n\t\t\t   PCM186X_PGA_VAL_CH2_R, 0, -24, 80, 7, 0,\n\t\t\t   pcm186x_pga_tlv),\n};\n\nstatic const unsigned int pcm186x_adc_input_channel_sel_value[] = {\n\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t0x10, 0x20, 0x30\n};\n\nstatic const char * const pcm186x_adcl_input_channel_sel_text[] = {\n\t\"No Select\",\n\t\"VINL1[SE]\",\t\t\t\t\t \n\t\"VINL2[SE]\",\t\t\t\t\t \n\t\"VINL2[SE] + VINL1[SE]\",\n\t\"VINL3[SE]\",\n\t\"VINL3[SE] + VINL1[SE]\",\n\t\"VINL3[SE] + VINL2[SE]\",\n\t\"VINL3[SE] + VINL2[SE] + VINL1[SE]\",\n\t\"VINL4[SE]\",\n\t\"VINL4[SE] + VINL1[SE]\",\n\t\"VINL4[SE] + VINL2[SE]\",\n\t\"VINL4[SE] + VINL2[SE] + VINL1[SE]\",\n\t\"VINL4[SE] + VINL3[SE]\",\n\t\"VINL4[SE] + VINL3[SE] + VINL1[SE]\",\n\t\"VINL4[SE] + VINL3[SE] + VINL2[SE]\",\n\t\"VINL4[SE] + VINL3[SE] + VINL2[SE] + VINL1[SE]\",\n\t\"{VIN1P, VIN1M}[DIFF]\",\n\t\"{VIN4P, VIN4M}[DIFF]\",\n\t\"{VIN1P, VIN1M}[DIFF] + {VIN4P, VIN4M}[DIFF]\"\n};\n\nstatic const char * const pcm186x_adcr_input_channel_sel_text[] = {\n\t\"No Select\",\n\t\"VINR1[SE]\",\t\t\t\t\t \n\t\"VINR2[SE]\",\t\t\t\t\t \n\t\"VINR2[SE] + VINR1[SE]\",\n\t\"VINR3[SE]\",\n\t\"VINR3[SE] + VINR1[SE]\",\n\t\"VINR3[SE] + VINR2[SE]\",\n\t\"VINR3[SE] + VINR2[SE] + VINR1[SE]\",\n\t\"VINR4[SE]\",\n\t\"VINR4[SE] + VINR1[SE]\",\n\t\"VINR4[SE] + VINR2[SE]\",\n\t\"VINR4[SE] + VINR2[SE] + VINR1[SE]\",\n\t\"VINR4[SE] + VINR3[SE]\",\n\t\"VINR4[SE] + VINR3[SE] + VINR1[SE]\",\n\t\"VINR4[SE] + VINR3[SE] + VINR2[SE]\",\n\t\"VINR4[SE] + VINR3[SE] + VINR2[SE] + VINR1[SE]\",\n\t\"{VIN2P, VIN2M}[DIFF]\",\n\t\"{VIN3P, VIN3M}[DIFF]\",\n\t\"{VIN2P, VIN2M}[DIFF] + {VIN3P, VIN3M}[DIFF]\"\n};\n\nstatic const struct soc_enum pcm186x_adc_input_channel_sel[] = {\n\tSOC_VALUE_ENUM_SINGLE(PCM186X_ADC1_INPUT_SEL_L, 0,\n\t\t\t      PCM186X_ADC_INPUT_SEL_MASK,\n\t\t\t      ARRAY_SIZE(pcm186x_adcl_input_channel_sel_text),\n\t\t\t      pcm186x_adcl_input_channel_sel_text,\n\t\t\t      pcm186x_adc_input_channel_sel_value),\n\tSOC_VALUE_ENUM_SINGLE(PCM186X_ADC1_INPUT_SEL_R, 0,\n\t\t\t      PCM186X_ADC_INPUT_SEL_MASK,\n\t\t\t      ARRAY_SIZE(pcm186x_adcr_input_channel_sel_text),\n\t\t\t      pcm186x_adcr_input_channel_sel_text,\n\t\t\t      pcm186x_adc_input_channel_sel_value),\n\tSOC_VALUE_ENUM_SINGLE(PCM186X_ADC2_INPUT_SEL_L, 0,\n\t\t\t      PCM186X_ADC_INPUT_SEL_MASK,\n\t\t\t      ARRAY_SIZE(pcm186x_adcl_input_channel_sel_text),\n\t\t\t      pcm186x_adcl_input_channel_sel_text,\n\t\t\t      pcm186x_adc_input_channel_sel_value),\n\tSOC_VALUE_ENUM_SINGLE(PCM186X_ADC2_INPUT_SEL_R, 0,\n\t\t\t      PCM186X_ADC_INPUT_SEL_MASK,\n\t\t\t      ARRAY_SIZE(pcm186x_adcr_input_channel_sel_text),\n\t\t\t      pcm186x_adcr_input_channel_sel_text,\n\t\t\t      pcm186x_adc_input_channel_sel_value),\n};\n\nstatic const struct snd_kcontrol_new pcm186x_adc_mux_controls[] = {\n\tSOC_DAPM_ENUM(\"ADC1 Left Input\", pcm186x_adc_input_channel_sel[0]),\n\tSOC_DAPM_ENUM(\"ADC1 Right Input\", pcm186x_adc_input_channel_sel[1]),\n\tSOC_DAPM_ENUM(\"ADC2 Left Input\", pcm186x_adc_input_channel_sel[2]),\n\tSOC_DAPM_ENUM(\"ADC2 Right Input\", pcm186x_adc_input_channel_sel[3]),\n};\n\nstatic const struct snd_soc_dapm_widget pcm1863_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"VINL1\"),\n\tSND_SOC_DAPM_INPUT(\"VINR1\"),\n\tSND_SOC_DAPM_INPUT(\"VINL2\"),\n\tSND_SOC_DAPM_INPUT(\"VINR2\"),\n\tSND_SOC_DAPM_INPUT(\"VINL3\"),\n\tSND_SOC_DAPM_INPUT(\"VINR3\"),\n\tSND_SOC_DAPM_INPUT(\"VINL4\"),\n\tSND_SOC_DAPM_INPUT(\"VINR4\"),\n\n\tSND_SOC_DAPM_MUX(\"ADC Left Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[0]),\n\tSND_SOC_DAPM_MUX(\"ADC Right Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[1]),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", PCM186X_POWER_CTRL, 1,  1),\n};\n\nstatic const struct snd_soc_dapm_widget pcm1865_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"VINL1\"),\n\tSND_SOC_DAPM_INPUT(\"VINR1\"),\n\tSND_SOC_DAPM_INPUT(\"VINL2\"),\n\tSND_SOC_DAPM_INPUT(\"VINR2\"),\n\tSND_SOC_DAPM_INPUT(\"VINL3\"),\n\tSND_SOC_DAPM_INPUT(\"VINR3\"),\n\tSND_SOC_DAPM_INPUT(\"VINL4\"),\n\tSND_SOC_DAPM_INPUT(\"VINR4\"),\n\n\tSND_SOC_DAPM_MUX(\"ADC1 Left Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[0]),\n\tSND_SOC_DAPM_MUX(\"ADC1 Right Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[1]),\n\tSND_SOC_DAPM_MUX(\"ADC2 Left Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[2]),\n\tSND_SOC_DAPM_MUX(\"ADC2 Right Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &pcm186x_adc_mux_controls[3]),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC1\", \"HiFi Capture 1\", PCM186X_POWER_CTRL, 1,  1),\n\tSND_SOC_DAPM_ADC(\"ADC2\", \"HiFi Capture 2\", PCM186X_POWER_CTRL, 1,  1),\n};\n\nstatic const struct snd_soc_dapm_route pcm1863_dapm_routes[] = {\n\t{ \"ADC Left Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC Left Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC\", NULL, \"ADC Left Capture Source\" },\n\n\t{ \"ADC Right Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC Right Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC\", NULL, \"ADC Right Capture Source\" },\n};\n\nstatic const struct snd_soc_dapm_route pcm1865_dapm_routes[] = {\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC1 Left Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC1\", NULL, \"ADC1 Left Capture Source\" },\n\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC1 Right Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC1\", NULL, \"ADC1 Right Capture Source\" },\n\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC2 Left Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC2\", NULL, \"ADC2 Left Capture Source\" },\n\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINL1\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINR1\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINL2\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINR2\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINL3\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINR3\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINL4\" },\n\t{ \"ADC2 Right Capture Source\", NULL, \"VINR4\" },\n\n\t{ \"ADC2\", NULL, \"ADC2 Right Capture Source\" },\n};\n\nstatic int pcm186x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int rate = params_rate(params);\n\tsnd_pcm_format_t format = params_format(params);\n\tunsigned int width = params_width(params);\n\tunsigned int channels = params_channels(params);\n\tunsigned int div_lrck;\n\tunsigned int div_bck;\n\tu8 tdm_tx_sel = 0;\n\tu8 pcm_cfg = 0;\n\n\tdev_dbg(component->dev, \"%s() rate=%u format=0x%x width=%u channels=%u\\n\",\n\t\t__func__, rate, format, width, channels);\n\n\tswitch (width) {\n\tcase 16:\n\t\tpcm_cfg = PCM186X_PCM_CFG_RX_WLEN_16 <<\n\t\t\t  PCM186X_PCM_CFG_RX_WLEN_SHIFT |\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_16 <<\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_SHIFT;\n\t\tbreak;\n\tcase 20:\n\t\tpcm_cfg = PCM186X_PCM_CFG_RX_WLEN_20 <<\n\t\t\t  PCM186X_PCM_CFG_RX_WLEN_SHIFT |\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_20 <<\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_SHIFT;\n\t\tbreak;\n\tcase 24:\n\t\tpcm_cfg = PCM186X_PCM_CFG_RX_WLEN_24 <<\n\t\t\t  PCM186X_PCM_CFG_RX_WLEN_SHIFT |\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_24 <<\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_SHIFT;\n\t\tbreak;\n\tcase 32:\n\t\tpcm_cfg = PCM186X_PCM_CFG_RX_WLEN_32 <<\n\t\t\t  PCM186X_PCM_CFG_RX_WLEN_SHIFT |\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_32 <<\n\t\t\t  PCM186X_PCM_CFG_TX_WLEN_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, PCM186X_PCM_CFG,\n\t\t\t    PCM186X_PCM_CFG_RX_WLEN_MASK |\n\t\t\t    PCM186X_PCM_CFG_TX_WLEN_MASK,\n\t\t\t    pcm_cfg);\n\n\tdiv_lrck = width * channels;\n\n\tif (priv->is_tdm_mode) {\n\t\t \n\t\tswitch (channels) {\n\t\tcase 2:\n\t\t\ttdm_tx_sel = PCM186X_TDM_TX_SEL_2CH;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttdm_tx_sel = PCM186X_TDM_TX_SEL_4CH;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\ttdm_tx_sel = PCM186X_TDM_TX_SEL_6CH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, PCM186X_TDM_TX_SEL,\n\t\t\t\t    PCM186X_TDM_TX_SEL_MASK, tdm_tx_sel);\n\n\t\t \n\t\tdiv_lrck = 256;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, PCM186X_PCM_CFG,\n\t\t\t\t    PCM186X_PCM_CFG_TDM_LRCK_MODE,\n\t\t\t\t    PCM186X_PCM_CFG_TDM_LRCK_MODE);\n\t}\n\n\t \n\tif (priv->is_provider_mode) {\n\t\tdiv_bck = priv->sysclk / (div_lrck * rate);\n\n\t\tdev_dbg(component->dev,\n\t\t\t\"%s() master_clk=%u div_bck=%u div_lrck=%u\\n\",\n\t\t\t__func__, priv->sysclk, div_bck, div_lrck);\n\n\t\tsnd_soc_component_write(component, PCM186X_BCK_DIV, div_bck - 1);\n\t\tsnd_soc_component_write(component, PCM186X_LRK_DIV, div_lrck - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int pcm186x_set_fmt(struct snd_soc_dai *dai, unsigned int format)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\tu8 clk_ctrl = 0;\n\tu8 pcm_cfg = 0;\n\n\tdev_dbg(component->dev, \"%s() format=0x%x\\n\", __func__, format);\n\n\tswitch (format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tif (!priv->sysclk) {\n\t\t\tdev_err(component->dev, \"operating in provider mode requires sysclock to be configured\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclk_ctrl |= PCM186X_CLK_CTRL_MST_MODE;\n\t\tpriv->is_provider_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tpriv->is_provider_mode = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI master/slave interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Inverted DAI clocks not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tpcm_cfg = PCM186X_PCM_CFG_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tpcm_cfg = PCM186X_PCM_CFG_FMT_LEFTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tpriv->tdm_offset += 1;\n\t\tfallthrough;\n\t\t \n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tpriv->is_tdm_mode = true;\n\t\tpcm_cfg = PCM186X_PCM_CFG_FMT_TDM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, PCM186X_CLK_CTRL,\n\t\t\t    PCM186X_CLK_CTRL_MST_MODE, clk_ctrl);\n\n\tsnd_soc_component_write(component, PCM186X_TDM_TX_OFFSET, priv->tdm_offset);\n\n\tsnd_soc_component_update_bits(component, PCM186X_PCM_CFG,\n\t\t\t    PCM186X_PCM_CFG_FMT_MASK, pcm_cfg);\n\n\treturn 0;\n}\n\nstatic int pcm186x_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int first_slot, last_slot, tdm_offset;\n\n\tdev_dbg(component->dev,\n\t\t\"%s() tx_mask=0x%x rx_mask=0x%x slots=%d slot_width=%d\\n\",\n\t\t__func__, tx_mask, rx_mask, slots, slot_width);\n\n\tif (!tx_mask) {\n\t\tdev_err(component->dev, \"tdm tx mask must not be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfirst_slot = __ffs(tx_mask);\n\tlast_slot = __fls(tx_mask);\n\n\tif (last_slot - first_slot != hweight32(tx_mask) - 1) {\n\t\tdev_err(component->dev, \"tdm tx mask must be contiguous\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttdm_offset = first_slot * slot_width;\n\n\tif (tdm_offset > 255) {\n\t\tdev_err(component->dev, \"tdm tx slot selection out of bounds\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->tdm_offset = tdm_offset;\n\n\treturn 0;\n}\n\nstatic int pcm186x_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t  unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s() clk_id=%d freq=%u dir=%d\\n\",\n\t\t__func__, clk_id, freq, dir);\n\n\tpriv->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops pcm186x_dai_ops = {\n\t.set_sysclk = pcm186x_set_dai_sysclk,\n\t.set_tdm_slot = pcm186x_set_tdm_slot,\n\t.set_fmt = pcm186x_set_fmt,\n\t.hw_params = pcm186x_hw_params,\n};\n\nstatic struct snd_soc_dai_driver pcm1863_dai = {\n\t.name = \"pcm1863-aif\",\n\t.capture = {\n\t\t .stream_name = \"Capture\",\n\t\t .channels_min = 1,\n\t\t .channels_max = 2,\n\t\t .rates = PCM186X_RATES,\n\t\t .formats = PCM186X_FORMATS,\n\t },\n\t.ops = &pcm186x_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver pcm1865_dai = {\n\t.name = \"pcm1865-aif\",\n\t.capture = {\n\t\t .stream_name = \"Capture\",\n\t\t .channels_min = 1,\n\t\t .channels_max = 4,\n\t\t .rates = PCM186X_RATES,\n\t\t .formats = PCM186X_FORMATS,\n\t },\n\t.ops = &pcm186x_dai_ops,\n};\n\nstatic int pcm186x_power_on(struct snd_soc_component *component)\n{\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t    priv->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(priv->regmap, false);\n\tret = regcache_sync(priv->regmap);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to restore cache\\n\");\n\t\tregcache_cache_only(priv->regmap, true);\n\t\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t       priv->supplies);\n\t\treturn ret;\n\t}\n\n\tsnd_soc_component_update_bits(component, PCM186X_POWER_CTRL,\n\t\t\t    PCM186X_PWR_CTRL_PWRDN, 0);\n\n\treturn 0;\n}\n\nstatic int pcm186x_power_off(struct snd_soc_component *component)\n{\n\tstruct pcm186x_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_update_bits(component, PCM186X_POWER_CTRL,\n\t\t\t    PCM186X_PWR_CTRL_PWRDN, PCM186X_PWR_CTRL_PWRDN);\n\n\tregcache_cache_only(priv->regmap, true);\n\n\treturn regulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t     priv->supplies);\n}\n\nstatic int pcm186x_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tdev_dbg(component->dev, \"## %s: %d -> %d\\n\", __func__,\n\t\tsnd_soc_component_get_bias_level(component), level);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tpcm186x_power_on(component);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tpcm186x_power_off(component);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_component_driver soc_codec_dev_pcm1863 = {\n\t.set_bias_level\t\t= pcm186x_set_bias_level,\n\t.controls\t\t= pcm1863_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm1863_snd_controls),\n\t.dapm_widgets\t\t= pcm1863_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm1863_dapm_widgets),\n\t.dapm_routes\t\t= pcm1863_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm1863_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_component_driver soc_codec_dev_pcm1865 = {\n\t.set_bias_level\t\t= pcm186x_set_bias_level,\n\t.controls\t\t= pcm1865_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm1865_snd_controls),\n\t.dapm_widgets\t\t= pcm1865_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm1865_dapm_widgets),\n\t.dapm_routes\t\t= pcm1865_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm1865_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic bool pcm186x_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PCM186X_PAGE:\n\tcase PCM186X_DEVICE_STATUS:\n\tcase PCM186X_FSAMPLE_STATUS:\n\tcase PCM186X_DIV_STATUS:\n\tcase PCM186X_CLK_STATUS:\n\tcase PCM186X_SUPPLY_STATUS:\n\tcase PCM186X_MMAP_STAT_CTRL:\n\tcase PCM186X_MMAP_ADDRESS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_range_cfg pcm186x_range = {\n\t.name = \"Pages\",\n\t.range_max = PCM186X_MAX_REGISTER,\n\t.selector_reg = PCM186X_PAGE,\n\t.selector_mask = 0xff,\n\t.window_len = PCM186X_PAGE_LEN,\n};\n\nconst struct regmap_config pcm186x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.volatile_reg = pcm186x_volatile,\n\n\t.ranges = &pcm186x_range,\n\t.num_ranges = 1,\n\n\t.max_register = PCM186X_MAX_REGISTER,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL_GPL(pcm186x_regmap);\n\nint pcm186x_probe(struct device *dev, enum pcm186x_type type, int irq,\n\t\t  struct regmap *regmap)\n{\n\tstruct pcm186x_priv *priv;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct pcm186x_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\tpriv->regmap = regmap;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->supplies); i++)\n\t\tpriv->supplies[i].supply = pcm186x_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t    priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(regmap, PCM186X_PAGE, PCM186X_RESET);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to write device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t     priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed disable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (type) {\n\tcase PCM1865:\n\tcase PCM1864:\n\t\tret = devm_snd_soc_register_component(dev, &soc_codec_dev_pcm1865,\n\t\t\t\t\t     &pcm1865_dai, 1);\n\t\tbreak;\n\tcase PCM1863:\n\tcase PCM1862:\n\tdefault:\n\t\tret = devm_snd_soc_register_component(dev, &soc_codec_dev_pcm1863,\n\t\t\t\t\t     &pcm1863_dai, 1);\n\t}\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pcm186x_probe);\n\nMODULE_AUTHOR(\"Andreas Dannenberg <dannenberg@ti.com>\");\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_DESCRIPTION(\"PCM186x Universal Audio ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}