{
  "module_name": "cs35l36.c",
  "hash_id": "7ca4442d4292d35ca30ccbbddf8ba2c4e40f9a985cc5d21f851734685139b316",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l36.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <linux/gpio.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs35l36.h>\n#include <linux/of_irq.h>\n#include <linux/completion.h>\n\n#include \"cs35l36.h\"\n\n \n#define CS35L36_VALID_PDATA 0x80000000\n\nstatic const char * const cs35l36_supplies[] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstruct  cs35l36_private {\n\tstruct device *dev;\n\tstruct cs35l36_platform_data pdata;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[2];\n\tint num_supplies;\n\tint clksrc;\n\tint chip_version;\n\tint rev_id;\n\tint ldm_mode_sel;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstruct cs35l36_pll_config {\n\tint freq;\n\tint clk_cfg;\n\tint fll_igain;\n};\n\nstatic const struct cs35l36_pll_config cs35l36_pll_sysclk[] = {\n\t{32768,\t\t0x00, 0x05},\n\t{8000,\t\t0x01, 0x03},\n\t{11025,\t\t0x02, 0x03},\n\t{12000,\t\t0x03, 0x03},\n\t{16000,\t\t0x04, 0x04},\n\t{22050,\t\t0x05, 0x04},\n\t{24000,\t\t0x06, 0x04},\n\t{32000,\t\t0x07, 0x05},\n\t{44100,\t\t0x08, 0x05},\n\t{48000,\t\t0x09, 0x05},\n\t{88200,\t\t0x0A, 0x06},\n\t{96000,\t\t0x0B, 0x06},\n\t{128000,\t0x0C, 0x07},\n\t{176400,\t0x0D, 0x07},\n\t{192000,\t0x0E, 0x07},\n\t{256000,\t0x0F, 0x08},\n\t{352800,\t0x10, 0x08},\n\t{384000,\t0x11, 0x08},\n\t{512000,\t0x12, 0x09},\n\t{705600,\t0x13, 0x09},\n\t{750000,\t0x14, 0x09},\n\t{768000,\t0x15, 0x09},\n\t{1000000,\t0x16, 0x0A},\n\t{1024000,\t0x17, 0x0A},\n\t{1200000,\t0x18, 0x0A},\n\t{1411200,\t0x19, 0x0A},\n\t{1500000,\t0x1A, 0x0A},\n\t{1536000,\t0x1B, 0x0A},\n\t{2000000,\t0x1C, 0x0A},\n\t{2048000,\t0x1D, 0x0A},\n\t{2400000,\t0x1E, 0x0A},\n\t{2822400,\t0x1F, 0x0A},\n\t{3000000,\t0x20, 0x0A},\n\t{3072000,\t0x21, 0x0A},\n\t{3200000,\t0x22, 0x0A},\n\t{4000000,\t0x23, 0x0A},\n\t{4096000,\t0x24, 0x0A},\n\t{4800000,\t0x25, 0x0A},\n\t{5644800,\t0x26, 0x0A},\n\t{6000000,\t0x27, 0x0A},\n\t{6144000,\t0x28, 0x0A},\n\t{6250000,\t0x29, 0x08},\n\t{6400000,\t0x2A, 0x0A},\n\t{6500000,\t0x2B, 0x08},\n\t{6750000,\t0x2C, 0x09},\n\t{7526400,\t0x2D, 0x0A},\n\t{8000000,\t0x2E, 0x0A},\n\t{8192000,\t0x2F, 0x0A},\n\t{9600000,\t0x30, 0x0A},\n\t{11289600,\t0x31, 0x0A},\n\t{12000000,\t0x32, 0x0A},\n\t{12288000,\t0x33, 0x0A},\n\t{12500000,\t0x34, 0x08},\n\t{12800000,\t0x35, 0x0A},\n\t{13000000,\t0x36, 0x0A},\n\t{13500000,\t0x37, 0x0A},\n\t{19200000,\t0x38, 0x0A},\n\t{22579200,\t0x39, 0x0A},\n\t{24000000,\t0x3A, 0x0A},\n\t{24576000,\t0x3B, 0x0A},\n\t{25000000,\t0x3C, 0x0A},\n\t{25600000,\t0x3D, 0x0A},\n\t{26000000,\t0x3E, 0x0A},\n\t{27000000,\t0x3F, 0x0A},\n};\n\nstatic struct reg_default cs35l36_reg[] = {\n\t{CS35L36_TESTKEY_CTRL,\t\t\t0x00000000},\n\t{CS35L36_USERKEY_CTL,\t\t\t0x00000000},\n\t{CS35L36_OTP_CTRL1,\t\t\t0x00002460},\n\t{CS35L36_OTP_CTRL2,\t\t\t0x00000000},\n\t{CS35L36_OTP_CTRL3,\t\t\t0x00000000},\n\t{CS35L36_OTP_CTRL4,\t\t\t0x00000000},\n\t{CS35L36_OTP_CTRL5,\t\t\t0x00000000},\n\t{CS35L36_PAC_CTL1,\t\t\t0x00000004},\n\t{CS35L36_PAC_CTL2,\t\t\t0x00000000},\n\t{CS35L36_PAC_CTL3,\t\t\t0x00000000},\n\t{CS35L36_PWR_CTRL1,\t\t\t0x00000000},\n\t{CS35L36_PWR_CTRL2,\t\t\t0x00003321},\n\t{CS35L36_PWR_CTRL3,\t\t\t0x01000010},\n\t{CS35L36_CTRL_OVRRIDE,\t\t\t0x00000002},\n\t{CS35L36_AMP_OUT_MUTE,\t\t\t0x00000000},\n\t{CS35L36_OTP_TRIM_STATUS,\t\t0x00000000},\n\t{CS35L36_DISCH_FILT,\t\t\t0x00000000},\n\t{CS35L36_PROTECT_REL_ERR,\t\t0x00000000},\n\t{CS35L36_PAD_INTERFACE,\t\t\t0x00000038},\n\t{CS35L36_PLL_CLK_CTRL,\t\t\t0x00000010},\n\t{CS35L36_GLOBAL_CLK_CTRL,\t\t0x00000003},\n\t{CS35L36_ADC_CLK_CTRL,\t\t\t0x00000000},\n\t{CS35L36_SWIRE_CLK_CTRL,\t\t0x00000000},\n\t{CS35L36_SP_SCLK_CLK_CTRL,\t\t0x00000000},\n\t{CS35L36_MDSYNC_EN,\t\t\t0x00000000},\n\t{CS35L36_MDSYNC_TX_ID,\t\t\t0x00000000},\n\t{CS35L36_MDSYNC_PWR_CTRL,\t\t0x00000000},\n\t{CS35L36_MDSYNC_DATA_TX,\t\t0x00000000},\n\t{CS35L36_MDSYNC_TX_STATUS,\t\t0x00000002},\n\t{CS35L36_MDSYNC_RX_STATUS,\t\t0x00000000},\n\t{CS35L36_MDSYNC_ERR_STATUS,\t\t0x00000000},\n\t{CS35L36_BSTCVRT_VCTRL1,\t\t0x00000000},\n\t{CS35L36_BSTCVRT_VCTRL2,\t\t0x00000001},\n\t{CS35L36_BSTCVRT_PEAK_CUR,\t\t0x0000004A},\n\t{CS35L36_BSTCVRT_SFT_RAMP,\t\t0x00000003},\n\t{CS35L36_BSTCVRT_COEFF,\t\t\t0x00002424},\n\t{CS35L36_BSTCVRT_SLOPE_LBST,\t\t0x00005800},\n\t{CS35L36_BSTCVRT_SW_FREQ,\t\t0x00010000},\n\t{CS35L36_BSTCVRT_DCM_CTRL,\t\t0x00002001},\n\t{CS35L36_BSTCVRT_DCM_MODE_FORCE,\t0x00000000},\n\t{CS35L36_BSTCVRT_OVERVOLT_CTRL,\t\t0x00000130},\n\t{CS35L36_VPI_LIMIT_MODE,\t\t0x00000000},\n\t{CS35L36_VPI_LIMIT_MINMAX,\t\t0x00003000},\n\t{CS35L36_VPI_VP_THLD,\t\t\t0x00101010},\n\t{CS35L36_VPI_TRACK_CTRL,\t\t0x00000000},\n\t{CS35L36_VPI_TRIG_MODE_CTRL,\t\t0x00000000},\n\t{CS35L36_VPI_TRIG_STEPS,\t\t0x00000000},\n\t{CS35L36_VI_SPKMON_FILT,\t\t0x00000003},\n\t{CS35L36_VI_SPKMON_GAIN,\t\t0x00000909},\n\t{CS35L36_VI_SPKMON_IP_SEL,\t\t0x00000000},\n\t{CS35L36_DTEMP_WARN_THLD,\t\t0x00000002},\n\t{CS35L36_DTEMP_STATUS,\t\t\t0x00000000},\n\t{CS35L36_VPVBST_FS_SEL,\t\t\t0x00000001},\n\t{CS35L36_VPVBST_VP_CTRL,\t\t0x000001C0},\n\t{CS35L36_VPVBST_VBST_CTRL,\t\t0x000001C0},\n\t{CS35L36_ASP_TX_PIN_CTRL,\t\t0x00000028},\n\t{CS35L36_ASP_RATE_CTRL,\t\t\t0x00090000},\n\t{CS35L36_ASP_FORMAT,\t\t\t0x00000002},\n\t{CS35L36_ASP_FRAME_CTRL,\t\t0x00180018},\n\t{CS35L36_ASP_TX1_TX2_SLOT,\t\t0x00010000},\n\t{CS35L36_ASP_TX3_TX4_SLOT,\t\t0x00030002},\n\t{CS35L36_ASP_TX5_TX6_SLOT,\t\t0x00050004},\n\t{CS35L36_ASP_TX7_TX8_SLOT,\t\t0x00070006},\n\t{CS35L36_ASP_RX1_SLOT,\t\t\t0x00000000},\n\t{CS35L36_ASP_RX_TX_EN,\t\t\t0x00000000},\n\t{CS35L36_ASP_RX1_SEL,\t\t\t0x00000008},\n\t{CS35L36_ASP_TX1_SEL,\t\t\t0x00000018},\n\t{CS35L36_ASP_TX2_SEL,\t\t\t0x00000019},\n\t{CS35L36_ASP_TX3_SEL,\t\t\t0x00000028},\n\t{CS35L36_ASP_TX4_SEL,\t\t\t0x00000029},\n\t{CS35L36_ASP_TX5_SEL,\t\t\t0x00000020},\n\t{CS35L36_ASP_TX6_SEL,\t\t\t0x00000000},\n\t{CS35L36_SWIRE_P1_TX1_SEL,\t\t0x00000018},\n\t{CS35L36_SWIRE_P1_TX2_SEL,\t\t0x00000019},\n\t{CS35L36_SWIRE_P2_TX1_SEL,\t\t0x00000028},\n\t{CS35L36_SWIRE_P2_TX2_SEL,\t\t0x00000029},\n\t{CS35L36_SWIRE_P2_TX3_SEL,\t\t0x00000020},\n\t{CS35L36_SWIRE_DP1_FIFO_CFG,\t\t0x0000001B},\n\t{CS35L36_SWIRE_DP2_FIFO_CFG,\t\t0x0000001B},\n\t{CS35L36_SWIRE_DP3_FIFO_CFG,\t\t0x0000001B},\n\t{CS35L36_SWIRE_PCM_RX_DATA,\t\t0x00000000},\n\t{CS35L36_SWIRE_FS_SEL,\t\t\t0x00000001},\n\t{CS35L36_AMP_DIG_VOL_CTRL,\t\t0x00008000},\n\t{CS35L36_VPBR_CFG,\t\t\t0x02AA1905},\n\t{CS35L36_VBBR_CFG,\t\t\t0x02AA1905},\n\t{CS35L36_VPBR_STATUS,\t\t\t0x00000000},\n\t{CS35L36_VBBR_STATUS,\t\t\t0x00000000},\n\t{CS35L36_OVERTEMP_CFG,\t\t\t0x00000001},\n\t{CS35L36_AMP_ERR_VOL,\t\t\t0x00000000},\n\t{CS35L36_CLASSH_CFG,\t\t\t0x000B0405},\n\t{CS35L36_CLASSH_FET_DRV_CFG,\t\t0x00000111},\n\t{CS35L36_NG_CFG,\t\t\t0x00000033},\n\t{CS35L36_AMP_GAIN_CTRL,\t\t\t0x00000273},\n\t{CS35L36_PWM_MOD_IO_CTRL,\t\t0x00000000},\n\t{CS35L36_PWM_MOD_STATUS,\t\t0x00000000},\n\t{CS35L36_DAC_MSM_CFG,\t\t\t0x00000000},\n\t{CS35L36_AMP_SLOPE_CTRL,\t\t0x00000B00},\n\t{CS35L36_AMP_PDM_VOLUME,\t\t0x00000000},\n\t{CS35L36_AMP_PDM_RATE_CTRL,\t\t0x00000000},\n\t{CS35L36_PDM_CH_SEL,\t\t\t0x00000000},\n\t{CS35L36_AMP_NG_CTRL,\t\t\t0x0000212F},\n\t{CS35L36_PDM_HIGHFILT_CTRL,\t\t0x00000000},\n\t{CS35L36_PAC_INT0_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT1_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT2_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT3_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT4_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT5_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT6_CTRL,\t\t\t0x00000001},\n\t{CS35L36_PAC_INT7_CTRL,\t\t\t0x00000001},\n};\n\nstatic bool cs35l36_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L36_SW_RESET:\n\tcase CS35L36_SW_REV:\n\tcase CS35L36_HW_REV:\n\tcase CS35L36_TESTKEY_CTRL:\n\tcase CS35L36_USERKEY_CTL:\n\tcase CS35L36_OTP_MEM30:\n\tcase CS35L36_OTP_CTRL1:\n\tcase CS35L36_OTP_CTRL2:\n\tcase CS35L36_OTP_CTRL3:\n\tcase CS35L36_OTP_CTRL4:\n\tcase CS35L36_OTP_CTRL5:\n\tcase CS35L36_PAC_CTL1:\n\tcase CS35L36_PAC_CTL2:\n\tcase CS35L36_PAC_CTL3:\n\tcase CS35L36_DEVICE_ID:\n\tcase CS35L36_FAB_ID:\n\tcase CS35L36_REV_ID:\n\tcase CS35L36_PWR_CTRL1:\n\tcase CS35L36_PWR_CTRL2:\n\tcase CS35L36_PWR_CTRL3:\n\tcase CS35L36_CTRL_OVRRIDE:\n\tcase CS35L36_AMP_OUT_MUTE:\n\tcase CS35L36_OTP_TRIM_STATUS:\n\tcase CS35L36_DISCH_FILT:\n\tcase CS35L36_PROTECT_REL_ERR:\n\tcase CS35L36_PAD_INTERFACE:\n\tcase CS35L36_PLL_CLK_CTRL:\n\tcase CS35L36_GLOBAL_CLK_CTRL:\n\tcase CS35L36_ADC_CLK_CTRL:\n\tcase CS35L36_SWIRE_CLK_CTRL:\n\tcase CS35L36_SP_SCLK_CLK_CTRL:\n\tcase CS35L36_TST_FS_MON0:\n\tcase CS35L36_MDSYNC_EN:\n\tcase CS35L36_MDSYNC_TX_ID:\n\tcase CS35L36_MDSYNC_PWR_CTRL:\n\tcase CS35L36_MDSYNC_DATA_TX:\n\tcase CS35L36_MDSYNC_TX_STATUS:\n\tcase CS35L36_MDSYNC_RX_STATUS:\n\tcase CS35L36_MDSYNC_ERR_STATUS:\n\tcase CS35L36_BSTCVRT_VCTRL1:\n\tcase CS35L36_BSTCVRT_VCTRL2:\n\tcase CS35L36_BSTCVRT_PEAK_CUR:\n\tcase CS35L36_BSTCVRT_SFT_RAMP:\n\tcase CS35L36_BSTCVRT_COEFF:\n\tcase CS35L36_BSTCVRT_SLOPE_LBST:\n\tcase CS35L36_BSTCVRT_SW_FREQ:\n\tcase CS35L36_BSTCVRT_DCM_CTRL:\n\tcase CS35L36_BSTCVRT_DCM_MODE_FORCE:\n\tcase CS35L36_BSTCVRT_OVERVOLT_CTRL:\n\tcase CS35L36_BST_TST_MANUAL:\n\tcase CS35L36_BST_ANA2_TEST:\n\tcase CS35L36_VPI_LIMIT_MODE:\n\tcase CS35L36_VPI_LIMIT_MINMAX:\n\tcase CS35L36_VPI_VP_THLD:\n\tcase CS35L36_VPI_TRACK_CTRL:\n\tcase CS35L36_VPI_TRIG_MODE_CTRL:\n\tcase CS35L36_VPI_TRIG_STEPS:\n\tcase CS35L36_VI_SPKMON_FILT:\n\tcase CS35L36_VI_SPKMON_GAIN:\n\tcase CS35L36_VI_SPKMON_IP_SEL:\n\tcase CS35L36_DTEMP_WARN_THLD:\n\tcase CS35L36_DTEMP_STATUS:\n\tcase CS35L36_VPVBST_FS_SEL:\n\tcase CS35L36_VPVBST_VP_CTRL:\n\tcase CS35L36_VPVBST_VBST_CTRL:\n\tcase CS35L36_ASP_TX_PIN_CTRL:\n\tcase CS35L36_ASP_RATE_CTRL:\n\tcase CS35L36_ASP_FORMAT:\n\tcase CS35L36_ASP_FRAME_CTRL:\n\tcase CS35L36_ASP_TX1_TX2_SLOT:\n\tcase CS35L36_ASP_TX3_TX4_SLOT:\n\tcase CS35L36_ASP_TX5_TX6_SLOT:\n\tcase CS35L36_ASP_TX7_TX8_SLOT:\n\tcase CS35L36_ASP_RX1_SLOT:\n\tcase CS35L36_ASP_RX_TX_EN:\n\tcase CS35L36_ASP_RX1_SEL:\n\tcase CS35L36_ASP_TX1_SEL:\n\tcase CS35L36_ASP_TX2_SEL:\n\tcase CS35L36_ASP_TX3_SEL:\n\tcase CS35L36_ASP_TX4_SEL:\n\tcase CS35L36_ASP_TX5_SEL:\n\tcase CS35L36_ASP_TX6_SEL:\n\tcase CS35L36_SWIRE_P1_TX1_SEL:\n\tcase CS35L36_SWIRE_P1_TX2_SEL:\n\tcase CS35L36_SWIRE_P2_TX1_SEL:\n\tcase CS35L36_SWIRE_P2_TX2_SEL:\n\tcase CS35L36_SWIRE_P2_TX3_SEL:\n\tcase CS35L36_SWIRE_DP1_FIFO_CFG:\n\tcase CS35L36_SWIRE_DP2_FIFO_CFG:\n\tcase CS35L36_SWIRE_DP3_FIFO_CFG:\n\tcase CS35L36_SWIRE_PCM_RX_DATA:\n\tcase CS35L36_SWIRE_FS_SEL:\n\tcase CS35L36_AMP_DIG_VOL_CTRL:\n\tcase CS35L36_VPBR_CFG:\n\tcase CS35L36_VBBR_CFG:\n\tcase CS35L36_VPBR_STATUS:\n\tcase CS35L36_VBBR_STATUS:\n\tcase CS35L36_OVERTEMP_CFG:\n\tcase CS35L36_AMP_ERR_VOL:\n\tcase CS35L36_CLASSH_CFG:\n\tcase CS35L36_CLASSH_FET_DRV_CFG:\n\tcase CS35L36_NG_CFG:\n\tcase CS35L36_AMP_GAIN_CTRL:\n\tcase CS35L36_PWM_MOD_IO_CTRL:\n\tcase CS35L36_PWM_MOD_STATUS:\n\tcase CS35L36_DAC_MSM_CFG:\n\tcase CS35L36_AMP_SLOPE_CTRL:\n\tcase CS35L36_AMP_PDM_VOLUME:\n\tcase CS35L36_AMP_PDM_RATE_CTRL:\n\tcase CS35L36_PDM_CH_SEL:\n\tcase CS35L36_AMP_NG_CTRL:\n\tcase CS35L36_PDM_HIGHFILT_CTRL:\n\tcase CS35L36_INT1_STATUS:\n\tcase CS35L36_INT2_STATUS:\n\tcase CS35L36_INT3_STATUS:\n\tcase CS35L36_INT4_STATUS:\n\tcase CS35L36_INT1_RAW_STATUS:\n\tcase CS35L36_INT2_RAW_STATUS:\n\tcase CS35L36_INT3_RAW_STATUS:\n\tcase CS35L36_INT4_RAW_STATUS:\n\tcase CS35L36_INT1_MASK:\n\tcase CS35L36_INT2_MASK:\n\tcase CS35L36_INT3_MASK:\n\tcase CS35L36_INT4_MASK:\n\tcase CS35L36_INT1_EDGE_LVL_CTRL:\n\tcase CS35L36_INT3_EDGE_LVL_CTRL:\n\tcase CS35L36_PAC_INT_STATUS:\n\tcase CS35L36_PAC_INT_RAW_STATUS:\n\tcase CS35L36_PAC_INT_FLUSH_CTRL:\n\tcase CS35L36_PAC_INT0_CTRL:\n\tcase CS35L36_PAC_INT1_CTRL:\n\tcase CS35L36_PAC_INT2_CTRL:\n\tcase CS35L36_PAC_INT3_CTRL:\n\tcase CS35L36_PAC_INT4_CTRL:\n\tcase CS35L36_PAC_INT5_CTRL:\n\tcase CS35L36_PAC_INT6_CTRL:\n\tcase CS35L36_PAC_INT7_CTRL:\n\t\treturn true;\n\tdefault:\n\t\tif (reg >= CS35L36_PAC_PMEM_WORD0 &&\n\t\t\treg <= CS35L36_PAC_PMEM_WORD1023)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\nstatic bool cs35l36_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L36_TESTKEY_CTRL:\n\tcase CS35L36_USERKEY_CTL:\n\tcase CS35L36_TST_FS_MON0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l36_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L36_SW_RESET:\n\tcase CS35L36_SW_REV:\n\tcase CS35L36_HW_REV:\n\tcase CS35L36_TESTKEY_CTRL:\n\tcase CS35L36_USERKEY_CTL:\n\tcase CS35L36_DEVICE_ID:\n\tcase CS35L36_FAB_ID:\n\tcase CS35L36_REV_ID:\n\tcase CS35L36_INT1_STATUS:\n\tcase CS35L36_INT2_STATUS:\n\tcase CS35L36_INT3_STATUS:\n\tcase CS35L36_INT4_STATUS:\n\tcase CS35L36_INT1_RAW_STATUS:\n\tcase CS35L36_INT2_RAW_STATUS:\n\tcase CS35L36_INT3_RAW_STATUS:\n\tcase CS35L36_INT4_RAW_STATUS:\n\tcase CS35L36_INT1_MASK:\n\tcase CS35L36_INT2_MASK:\n\tcase CS35L36_INT3_MASK:\n\tcase CS35L36_INT4_MASK:\n\tcase CS35L36_INT1_EDGE_LVL_CTRL:\n\tcase CS35L36_INT3_EDGE_LVL_CTRL:\n\tcase CS35L36_PAC_INT_STATUS:\n\tcase CS35L36_PAC_INT_RAW_STATUS:\n\tcase CS35L36_PAC_INT_FLUSH_CTRL:\n\t\treturn true;\n\tdefault:\n\t\tif (reg >= CS35L36_PAC_PMEM_WORD0 &&\n\t\t\treg <= CS35L36_PAC_PMEM_WORD1023)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_RANGE(dig_vol_tlv, 0, 912,\n\t\t\t\t  TLV_DB_MINMAX_ITEM(-10200, 1200));\nstatic DECLARE_TLV_DB_SCALE(amp_gain_tlv, 0, 1, 1);\n\nstatic const char * const cs35l36_pcm_sftramp_text[] =  {\n\t\"Off\", \".5ms\", \"1ms\", \"2ms\", \"4ms\", \"8ms\", \"15ms\", \"30ms\"};\n\nstatic SOC_ENUM_SINGLE_DECL(pcm_sft_ramp, CS35L36_AMP_DIG_VOL_CTRL, 0,\n\t\t\t    cs35l36_pcm_sftramp_text);\n\nstatic int cs35l36_ldm_sel_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = cs35l36->ldm_mode_sel;\n\n\treturn 0;\n}\n\nstatic int cs35l36_ldm_sel_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tint val = (ucontrol->value.integer.value[0]) ? CS35L36_NG_AMP_EN_MASK :\n\t\t\t\t\t\t       0;\n\n\tcs35l36->ldm_mode_sel = val;\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_NG_CFG,\n\t\t\t   CS35L36_NG_AMP_EN_MASK, val);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new cs35l36_aud_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"Digital PCM Volume\", CS35L36_AMP_DIG_VOL_CTRL,\n\t\t3, 0x4D0, 0x390, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Analog PCM Volume\", CS35L36_AMP_GAIN_CTRL, 5, 0x13, 0,\n\t\tamp_gain_tlv),\n\tSOC_ENUM(\"PCM Soft Ramp\", pcm_sft_ramp),\n\tSOC_SINGLE(\"Amp Gain Zero-Cross Switch\", CS35L36_AMP_GAIN_CTRL,\n\t\tCS35L36_AMP_ZC_SHIFT, 1, 0),\n\tSOC_SINGLE(\"PDM LDM Enter Ramp Switch\", CS35L36_DAC_MSM_CFG,\n\t\tCS35L36_PDM_LDM_ENTER_SHIFT, 1, 0),\n\tSOC_SINGLE(\"PDM LDM Exit Ramp Switch\", CS35L36_DAC_MSM_CFG,\n\t\tCS35L36_PDM_LDM_EXIT_SHIFT, 1, 0),\n\tSOC_SINGLE_BOOL_EXT(\"LDM Select Switch\", 0, cs35l36_ldm_sel_get,\n\t\tcs35l36_ldm_sel_put),\n};\n\nstatic int cs35l36_main_amp_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tu32 reg;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PWR_CTRL1,\n\t\t\t\t   CS35L36_GLOBAL_EN_MASK,\n\t\t\t\t   1 << CS35L36_GLOBAL_EN_SHIFT);\n\n\t\tusleep_range(2000, 2100);\n\n\t\tregmap_read(cs35l36->regmap, CS35L36_INT4_RAW_STATUS, &reg);\n\n\t\tif (WARN_ON_ONCE(reg & CS35L36_PLL_UNLOCK_MASK))\n\t\t\tdev_crit(cs35l36->dev, \"PLL Unlocked\\n\");\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_RX1_SEL,\n\t\t\t\t   CS35L36_PCM_RX_SEL_MASK,\n\t\t\t\t   CS35L36_PCM_RX_SEL_PCM);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_AMP_OUT_MUTE,\n\t\t\t\t   CS35L36_AMP_MUTE_MASK,\n\t\t\t\t   0 << CS35L36_AMP_MUTE_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_RX1_SEL,\n\t\t\t\t   CS35L36_PCM_RX_SEL_MASK,\n\t\t\t\t   CS35L36_PCM_RX_SEL_ZERO);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_AMP_OUT_MUTE,\n\t\t\t\t   CS35L36_AMP_MUTE_MASK,\n\t\t\t\t   1 << CS35L36_AMP_MUTE_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PWR_CTRL1,\n\t\t\t\t   CS35L36_GLOBAL_EN_MASK,\n\t\t\t\t   0 << CS35L36_GLOBAL_EN_SHIFT);\n\n\t\tusleep_range(2000, 2100);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l36_boost_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (!cs35l36->pdata.extern_boost)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PWR_CTRL2,\n\t\t\t\t\t   CS35L36_BST_EN_MASK,\n\t\t\t\t\t   CS35L36_BST_EN <<\n\t\t\t\t\t   CS35L36_BST_EN_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (!cs35l36->pdata.extern_boost)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PWR_CTRL2,\n\t\t\t\t\t   CS35L36_BST_EN_MASK,\n\t\t\t\t\t   CS35L36_BST_DIS_VP <<\n\t\t\t\t\t   CS35L36_BST_EN_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const cs35l36_chan_text[] = {\n\t\"RX1\",\n\t\"RX2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(chansel_enum, CS35L36_ASP_RX1_SLOT, 0,\n\t\t\t    cs35l36_chan_text);\n\nstatic const struct snd_kcontrol_new cs35l36_chan_mux =\n\t\tSOC_DAPM_ENUM(\"Input Mux\", chansel_enum);\n\nstatic const struct snd_kcontrol_new amp_enable_ctrl =\n\t\tSOC_DAPM_SINGLE_AUTODISABLE(\"Switch\", CS35L36_AMP_OUT_MUTE,\n\t\t\t\t\t    CS35L36_AMP_MUTE_SHIFT, 1, 1);\n\nstatic const struct snd_kcontrol_new boost_ctrl =\n\t\tSOC_DAPM_SINGLE_VIRT(\"Switch\", 1);\n\nstatic const char * const asp_tx_src_text[] = {\n\t\"Zero Fill\", \"ASPRX1\", \"VMON\", \"IMON\", \"ERRVOL\", \"VPMON\", \"VBSTMON\"\n};\n\nstatic const unsigned int asp_tx_src_values[] = {\n\t0x00, 0x08, 0x18, 0x19, 0x20, 0x28, 0x29\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx1_src_enum, CS35L36_ASP_TX1_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx1_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX1SRC\", asp_tx1_src_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx2_src_enum, CS35L36_ASP_TX2_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx2_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX2SRC\", asp_tx2_src_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx3_src_enum, CS35L36_ASP_TX3_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx3_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX3SRC\", asp_tx3_src_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx4_src_enum, CS35L36_ASP_TX4_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx4_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX4SRC\", asp_tx4_src_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx5_src_enum, CS35L36_ASP_TX5_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx5_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX5SRC\", asp_tx5_src_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(asp_tx6_src_enum, CS35L36_ASP_TX6_SEL, 0,\n\t\t\t\t  CS35L36_APS_TX_SEL_MASK, asp_tx_src_text,\n\t\t\t\t  asp_tx_src_values);\n\nstatic const struct snd_kcontrol_new asp_tx6_src =\n\t\tSOC_DAPM_ENUM(\"ASPTX6SRC\", asp_tx6_src_enum);\n\nstatic const struct snd_soc_dapm_widget cs35l36_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"Channel Mux\", SND_SOC_NOPM, 0, 0, &cs35l36_chan_mux),\n\tSND_SOC_DAPM_AIF_IN(\"SDIN\", NULL, 0, CS35L36_ASP_RX_TX_EN, 16, 0),\n\n\tSND_SOC_DAPM_OUT_DRV_E(\"Main AMP\", CS35L36_PWR_CTRL2, 0, 0, NULL, 0,\n\t\t\t       cs35l36_main_amp_event, SND_SOC_DAPM_POST_PMD |\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\tSND_SOC_DAPM_SWITCH(\"AMP Enable\", SND_SOC_NOPM, 0, 1, &amp_enable_ctrl),\n\tSND_SOC_DAPM_MIXER(\"CLASS H\", CS35L36_PWR_CTRL3, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SWITCH_E(\"BOOST Enable\", SND_SOC_NOPM, 0, 0, &boost_ctrl,\n\t\t\t      cs35l36_boost_event, SND_SOC_DAPM_POST_PMD |\n\t\t\t      SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX1\", NULL, 0, CS35L36_ASP_RX_TX_EN, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX2\", NULL, 1, CS35L36_ASP_RX_TX_EN, 1, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX3\", NULL, 2, CS35L36_ASP_RX_TX_EN, 2, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX4\", NULL, 3, CS35L36_ASP_RX_TX_EN, 3, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX5\", NULL, 4, CS35L36_ASP_RX_TX_EN, 4, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX6\", NULL, 5, CS35L36_ASP_RX_TX_EN, 5, 0),\n\n\tSND_SOC_DAPM_MUX(\"ASPTX1SRC\", SND_SOC_NOPM, 0, 0, &asp_tx1_src),\n\tSND_SOC_DAPM_MUX(\"ASPTX2SRC\", SND_SOC_NOPM, 0, 0, &asp_tx2_src),\n\tSND_SOC_DAPM_MUX(\"ASPTX3SRC\", SND_SOC_NOPM, 0, 0, &asp_tx3_src),\n\tSND_SOC_DAPM_MUX(\"ASPTX4SRC\", SND_SOC_NOPM, 0, 0, &asp_tx4_src),\n\tSND_SOC_DAPM_MUX(\"ASPTX5SRC\", SND_SOC_NOPM, 0, 0, &asp_tx5_src),\n\tSND_SOC_DAPM_MUX(\"ASPTX6SRC\", SND_SOC_NOPM, 0, 0, &asp_tx6_src),\n\n\tSND_SOC_DAPM_ADC(\"VMON ADC\", NULL, CS35L36_PWR_CTRL2, 12, 0),\n\tSND_SOC_DAPM_ADC(\"IMON ADC\", NULL, CS35L36_PWR_CTRL2, 13, 0),\n\tSND_SOC_DAPM_ADC(\"VPMON ADC\", NULL, CS35L36_PWR_CTRL2, 8, 0),\n\tSND_SOC_DAPM_ADC(\"VBSTMON ADC\", NULL, CS35L36_PWR_CTRL2, 9, 0),\n\n\tSND_SOC_DAPM_INPUT(\"VP\"),\n\tSND_SOC_DAPM_INPUT(\"VBST\"),\n\tSND_SOC_DAPM_INPUT(\"VSENSE\"),\n};\n\nstatic const struct snd_soc_dapm_route cs35l36_audio_map[] = {\n\t{\"VPMON ADC\", NULL, \"VP\"},\n\t{\"VBSTMON ADC\", NULL, \"VBST\"},\n\t{\"IMON ADC\", NULL, \"VSENSE\"},\n\t{\"VMON ADC\", NULL, \"VSENSE\"},\n\n\t{\"ASPTX1SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX1SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX1SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX1SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX2SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX2SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX2SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX2SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX3SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX3SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX3SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX3SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX4SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX4SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX4SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX4SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX5SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX5SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX5SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX5SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX6SRC\", \"IMON\", \"IMON ADC\"},\n\t{\"ASPTX6SRC\", \"VMON\", \"VMON ADC\"},\n\t{\"ASPTX6SRC\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASPTX6SRC\", \"VPMON\", \"VPMON ADC\"},\n\n\t{\"ASPTX1\", NULL, \"ASPTX1SRC\"},\n\t{\"ASPTX2\", NULL, \"ASPTX2SRC\"},\n\t{\"ASPTX3\", NULL, \"ASPTX3SRC\"},\n\t{\"ASPTX4\", NULL, \"ASPTX4SRC\"},\n\t{\"ASPTX5\", NULL, \"ASPTX5SRC\"},\n\t{\"ASPTX6\", NULL, \"ASPTX6SRC\"},\n\n\t{\"AMP Capture\", NULL, \"ASPTX1\"},\n\t{\"AMP Capture\", NULL, \"ASPTX2\"},\n\t{\"AMP Capture\", NULL, \"ASPTX3\"},\n\t{\"AMP Capture\", NULL, \"ASPTX4\"},\n\t{\"AMP Capture\", NULL, \"ASPTX5\"},\n\t{\"AMP Capture\", NULL, \"ASPTX6\"},\n\n\t{\"AMP Enable\", \"Switch\", \"AMP Playback\"},\n\t{\"SDIN\", NULL, \"AMP Enable\"},\n\t{\"Channel Mux\", \"RX1\", \"SDIN\"},\n\t{\"Channel Mux\", \"RX2\", \"SDIN\"},\n\t{\"BOOST Enable\", \"Switch\", \"Channel Mux\"},\n\t{\"CLASS H\", NULL, \"BOOST Enable\"},\n\t{\"Main AMP\", NULL, \"Channel Mux\"},\n\t{\"Main AMP\", NULL, \"CLASS H\"},\n\t{\"SPK\", NULL, \"Main AMP\"},\n};\n\nstatic int cs35l36_set_dai_fmt(struct snd_soc_dai *component_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component_dai->component);\n\tunsigned int asp_fmt, lrclk_fmt, sclk_fmt, clock_provider, clk_frc;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tclock_provider = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tclock_provider = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_TX_PIN_CTRL,\n\t\t\t\tCS35L36_SCLK_MSTR_MASK,\n\t\t\t\tclock_provider << CS35L36_SCLK_MSTR_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_RATE_CTRL,\n\t\t\t\tCS35L36_LRCLK_MSTR_MASK,\n\t\t\t\tclock_provider << CS35L36_LRCLK_MSTR_SHIFT);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\n\tcase SND_SOC_DAIFMT_CONT:\n\t\tclk_frc = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_GATED:\n\t\tclk_frc = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_TX_PIN_CTRL,\n\t\t\t   CS35L36_SCLK_FRC_MASK, clk_frc <<\n\t\t\t   CS35L36_SCLK_FRC_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_RATE_CTRL,\n\t\t\t   CS35L36_LRCLK_FRC_MASK, clk_frc <<\n\t\t\t   CS35L36_LRCLK_FRC_SHIFT);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tasp_fmt = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tasp_fmt = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrclk_fmt = 1;\n\t\tsclk_fmt = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tlrclk_fmt = 0;\n\t\tsclk_fmt = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tlrclk_fmt = 1;\n\t\tsclk_fmt = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tlrclk_fmt = 0;\n\t\tsclk_fmt = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_RATE_CTRL,\n\t\t\t   CS35L36_LRCLK_INV_MASK,\n\t\t\t   lrclk_fmt << CS35L36_LRCLK_INV_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_TX_PIN_CTRL,\n\t\t\t   CS35L36_SCLK_INV_MASK,\n\t\t\t   sclk_fmt << CS35L36_SCLK_INV_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_FORMAT,\n\t\t\t   CS35L36_ASP_FMT_MASK, asp_fmt);\n\n\treturn 0;\n}\n\nstruct cs35l36_global_fs_config {\n\tint rate;\n\tint fs_cfg;\n};\n\nstatic const struct cs35l36_global_fs_config cs35l36_fs_rates[] = {\n\t{12000, 0x01},\n\t{24000, 0x02},\n\t{48000, 0x03},\n\t{96000, 0x04},\n\t{192000, 0x05},\n\t{384000, 0x06},\n\t{11025, 0x09},\n\t{22050, 0x0A},\n\t{44100, 0x0B},\n\t{88200, 0x0C},\n\t{176400, 0x0D},\n\t{8000, 0x11},\n\t{16000, 0x12},\n\t{32000, 0x13},\n};\n\nstatic int cs35l36_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(dai->component);\n\tunsigned int asp_width, global_fs = params_rate(params);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l36_fs_rates); i++) {\n\t\tif (global_fs == cs35l36_fs_rates[i].rate)\n\t\t\tregmap_update_bits(cs35l36->regmap,\n\t\t\t\t\t   CS35L36_GLOBAL_CLK_CTRL,\n\t\t\t\t\t   CS35L36_GLOBAL_FS_MASK,\n\t\t\t\t\t   cs35l36_fs_rates[i].fs_cfg <<\n\t\t\t\t\t   CS35L36_GLOBAL_FS_SHIFT);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tasp_width = CS35L36_ASP_WIDTH_16;\n\t\tbreak;\n\tcase 24:\n\t\tasp_width = CS35L36_ASP_WIDTH_24;\n\t\tbreak;\n\tcase 32:\n\t\tasp_width = CS35L36_ASP_WIDTH_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_FRAME_CTRL,\n\t\t\t\t   CS35L36_ASP_RX_WIDTH_MASK,\n\t\t\t\t   asp_width << CS35L36_ASP_RX_WIDTH_SHIFT);\n\t} else {\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_FRAME_CTRL,\n\t\t\t\t   CS35L36_ASP_TX_WIDTH_MASK,\n\t\t\t\t   asp_width << CS35L36_ASP_TX_WIDTH_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l36_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t  unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tint fs1, fs2;\n\n\tif (freq > CS35L36_FS_NOM_6MHZ) {\n\t\tfs1 = CS35L36_FS1_DEFAULT_VAL;\n\t\tfs2 = CS35L36_FS2_DEFAULT_VAL;\n\t} else {\n\t\tfs1 = 3 * DIV_ROUND_UP(CS35L36_FS_NOM_6MHZ * 4, freq) + 4;\n\t\tfs2 = 5 * DIV_ROUND_UP(CS35L36_FS_NOM_6MHZ * 4, freq) + 4;\n\t}\n\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\tCS35L36_TEST_UNLOCK1);\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\tCS35L36_TEST_UNLOCK2);\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_TST_FS_MON0,\n\t\t\t   CS35L36_FS1_WINDOW_MASK | CS35L36_FS2_WINDOW_MASK,\n\t\t\t   fs1 | (fs2 << CS35L36_FS2_WINDOW_SHIFT));\n\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\tCS35L36_TEST_LOCK1);\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\tCS35L36_TEST_LOCK2);\n\treturn 0;\n}\n\nstatic const struct cs35l36_pll_config *cs35l36_get_clk_config(\n\t\tstruct cs35l36_private *cs35l36, int freq)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l36_pll_sysclk); i++) {\n\t\tif (cs35l36_pll_sysclk[i].freq == freq)\n\t\t\treturn &cs35l36_pll_sysclk[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic const unsigned int cs35l36_src_rates[] = {\n\t8000, 12000, 11025, 16000, 22050, 24000, 32000,\n\t44100, 48000, 88200, 96000, 176400, 192000, 384000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs35l36_constraints = {\n\t.count  = ARRAY_SIZE(cs35l36_src_rates),\n\t.list   = cs35l36_src_rates,\n};\n\nstatic int cs35l36_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE, &cs35l36_constraints);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l36_ops = {\n\t.startup = cs35l36_pcm_startup,\n\t.set_fmt = cs35l36_set_dai_fmt,\n\t.hw_params = cs35l36_pcm_hw_params,\n\t.set_sysclk = cs35l36_dai_set_sysclk,\n};\n\nstatic struct snd_soc_dai_driver cs35l36_dai[] = {\n\t{\n\t\t.name = \"cs35l36-pcm\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AMP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L36_RX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AMP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L36_TX_FORMATS,\n\t\t},\n\t\t.ops = &cs35l36_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic int cs35l36_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\tint clk_id, int source, unsigned int freq,\n\t\t\t\tint dir)\n{\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tconst struct cs35l36_pll_config *clk_cfg;\n\tint prev_clksrc;\n\tbool pdm_switch;\n\n\tprev_clksrc = cs35l36->clksrc;\n\n\tswitch (clk_id) {\n\tcase 0:\n\t\tcs35l36->clksrc = CS35L36_PLLSRC_SCLK;\n\t\tbreak;\n\tcase 1:\n\t\tcs35l36->clksrc = CS35L36_PLLSRC_LRCLK;\n\t\tbreak;\n\tcase 2:\n\t\tcs35l36->clksrc = CS35L36_PLLSRC_PDMCLK;\n\t\tbreak;\n\tcase 3:\n\t\tcs35l36->clksrc = CS35L36_PLLSRC_SELF;\n\t\tbreak;\n\tcase 4:\n\t\tcs35l36->clksrc = CS35L36_PLLSRC_MCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tclk_cfg = cs35l36_get_clk_config(cs35l36, freq);\n\tif (clk_cfg == NULL) {\n\t\tdev_err(component->dev, \"Invalid CLK Config Freq: %d\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_PLL_OPENLOOP_MASK,\n\t\t\t   1 << CS35L36_PLL_OPENLOOP_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_REFCLK_FREQ_MASK,\n\t\t\t   clk_cfg->clk_cfg << CS35L36_REFCLK_FREQ_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_PLL_REFCLK_EN_MASK,\n\t\t\t   0 << CS35L36_PLL_REFCLK_EN_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_PLL_CLK_SEL_MASK,\n\t\t\t   cs35l36->clksrc);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_PLL_OPENLOOP_MASK,\n\t\t\t   0 << CS35L36_PLL_OPENLOOP_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_CLK_CTRL,\n\t\t\t   CS35L36_PLL_REFCLK_EN_MASK,\n\t\t\t   1 << CS35L36_PLL_REFCLK_EN_SHIFT);\n\n\tif (cs35l36->rev_id == CS35L36_REV_A0) {\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK2);\n\n\t\tregmap_write(cs35l36->regmap, CS35L36_DCO_CTRL, 0x00036DA8);\n\t\tregmap_write(cs35l36->regmap, CS35L36_MISC_CTRL, 0x0100EE0E);\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_LOOP_PARAMS,\n\t\t\t\t   CS35L36_PLL_IGAIN_MASK,\n\t\t\t\t   CS35L36_PLL_IGAIN <<\n\t\t\t\t   CS35L36_PLL_IGAIN_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PLL_LOOP_PARAMS,\n\t\t\t\t   CS35L36_PLL_FFL_IGAIN_MASK,\n\t\t\t\t   clk_cfg->fll_igain);\n\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_LOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_LOCK2);\n\t}\n\n\tif (cs35l36->clksrc == CS35L36_PLLSRC_PDMCLK) {\n\t\tpdm_switch = cs35l36->ldm_mode_sel &&\n\t\t\t     (prev_clksrc != CS35L36_PLLSRC_PDMCLK);\n\n\t\tif (pdm_switch)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_NG_CFG,\n\t\t\t\t\t   CS35L36_NG_DELAY_MASK,\n\t\t\t\t\t   0 << CS35L36_NG_DELAY_SHIFT);\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_DAC_MSM_CFG,\n\t\t\t\t   CS35L36_PDM_MODE_MASK,\n\t\t\t\t   1 << CS35L36_PDM_MODE_SHIFT);\n\n\t\tif (pdm_switch)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_NG_CFG,\n\t\t\t\t\t   CS35L36_NG_DELAY_MASK,\n\t\t\t\t\t   3 << CS35L36_NG_DELAY_SHIFT);\n\t} else {\n\t\tpdm_switch = cs35l36->ldm_mode_sel &&\n\t\t\t     (prev_clksrc == CS35L36_PLLSRC_PDMCLK);\n\n\t\tif (pdm_switch)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_NG_CFG,\n\t\t\t\t\t   CS35L36_NG_DELAY_MASK,\n\t\t\t\t\t   0 << CS35L36_NG_DELAY_SHIFT);\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_DAC_MSM_CFG,\n\t\t\t\t   CS35L36_PDM_MODE_MASK,\n\t\t\t\t   0 << CS35L36_PDM_MODE_SHIFT);\n\n\t\tif (pdm_switch)\n\t\t\tregmap_update_bits(cs35l36->regmap, CS35L36_NG_CFG,\n\t\t\t\t\t   CS35L36_NG_DELAY_MASK,\n\t\t\t\t\t   3 << CS35L36_NG_DELAY_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l36_boost_inductor(struct cs35l36_private *cs35l36, int inductor)\n{\n\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_COEFF,\n\t\t\t   CS35L36_BSTCVRT_K1_MASK, 0x3C);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_COEFF,\n\t\t\t   CS35L36_BSTCVRT_K2_MASK,\n\t\t\t   0x3C << CS35L36_BSTCVRT_K2_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_SW_FREQ,\n\t\t\t   CS35L36_BSTCVRT_CCMFREQ_MASK, 0x00);\n\n\tswitch (inductor) {\n\tcase 1000:  \n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_SLOPE_LBST,\n\t\t\t\t   CS35L36_BSTCVRT_SLOPE_MASK,\n\t\t\t\t   0x75 << CS35L36_BSTCVRT_SLOPE_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_SLOPE_LBST,\n\t\t\t\t   CS35L36_BSTCVRT_LBSTVAL_MASK, 0x00);\n\t\tbreak;\n\tcase 1200:  \n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_SLOPE_LBST,\n\t\t\t\t   CS35L36_BSTCVRT_SLOPE_MASK,\n\t\t\t\t   0x6B << CS35L36_BSTCVRT_SLOPE_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_SLOPE_LBST,\n\t\t\t\t   CS35L36_BSTCVRT_LBSTVAL_MASK, 0x01);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l36->dev, \"%s Invalid Inductor Value %d uH\\n\",\n\t\t\t__func__, inductor);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l36_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l36_private *cs35l36 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif ((cs35l36->rev_id == CS35L36_REV_A0) && cs35l36->pdata.dcm_mode) {\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_DCM_CTRL,\n\t\t\t\t   CS35L36_DCM_AUTO_MASK,\n\t\t\t\t   CS35L36_DCM_AUTO_MASK);\n\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK2);\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BST_TST_MANUAL,\n\t\t\t\t   CS35L36_BST_MAN_IPKCOMP_MASK,\n\t\t\t\t   0 << CS35L36_BST_MAN_IPKCOMP_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BST_TST_MANUAL,\n\t\t\t\t   CS35L36_BST_MAN_IPKCOMP_EN_MASK,\n\t\t\t\t   CS35L36_BST_MAN_IPKCOMP_EN_MASK);\n\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t\tCS35L36_TEST_LOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t\tCS35L36_TEST_LOCK2);\n\t}\n\n\tif (cs35l36->pdata.amp_pcm_inv)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_AMP_DIG_VOL_CTRL,\n\t\t\t\t   CS35L36_AMP_PCM_INV_MASK,\n\t\t\t\t   CS35L36_AMP_PCM_INV_MASK);\n\n\tif (cs35l36->pdata.multi_amp_mode)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_ASP_TX_PIN_CTRL,\n\t\t\t\t   CS35L36_ASP_TX_HIZ_MASK,\n\t\t\t\t   CS35L36_ASP_TX_HIZ_MASK);\n\n\tif (cs35l36->pdata.imon_pol_inv)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_VI_SPKMON_FILT,\n\t\t\t\t   CS35L36_IMON_POL_MASK, 0);\n\n\tif (cs35l36->pdata.vmon_pol_inv)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_VI_SPKMON_FILT,\n\t\t\t\t   CS35L36_VMON_POL_MASK, 0);\n\n\tif (cs35l36->pdata.bst_vctl)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_VCTRL1,\n\t\t\t\t   CS35L35_BSTCVRT_CTL_MASK,\n\t\t\t\t   cs35l36->pdata.bst_vctl);\n\n\tif (cs35l36->pdata.bst_vctl_sel)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_VCTRL2,\n\t\t\t\t   CS35L35_BSTCVRT_CTL_SEL_MASK,\n\t\t\t\t   cs35l36->pdata.bst_vctl_sel);\n\n\tif (cs35l36->pdata.bst_ipk)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_PEAK_CUR,\n\t\t\t\t   CS35L36_BST_IPK_MASK,\n\t\t\t\t   cs35l36->pdata.bst_ipk);\n\n\tif (cs35l36->pdata.boost_ind) {\n\t\tret = cs35l36_boost_inductor(cs35l36, cs35l36->pdata.boost_ind);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cs35l36->dev,\n\t\t\t\t\"Boost inductor config failed(%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cs35l36->pdata.temp_warn_thld)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_DTEMP_WARN_THLD,\n\t\t\t\t   CS35L36_TEMP_THLD_MASK,\n\t\t\t\t   cs35l36->pdata.temp_warn_thld);\n\n\tif (cs35l36->pdata.irq_drv_sel)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PAD_INTERFACE,\n\t\t\t\t   CS35L36_INT_DRV_SEL_MASK,\n\t\t\t\t   cs35l36->pdata.irq_drv_sel <<\n\t\t\t\t   CS35L36_INT_DRV_SEL_SHIFT);\n\n\tif (cs35l36->pdata.irq_gpio_sel)\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PAD_INTERFACE,\n\t\t\t\t   CS35L36_INT_GPIO_SEL_MASK,\n\t\t\t\t   cs35l36->pdata.irq_gpio_sel <<\n\t\t\t\t   CS35L36_INT_GPIO_SEL_SHIFT);\n\n\t \n\tif (cs35l36->chip_version == CS35L36_10V_L36) {\n\t\tregmap_update_bits(cs35l36->regmap,\n\t\t\t\t   CS35L36_BSTCVRT_OVERVOLT_CTRL,\n\t\t\t\t   CS35L36_BST_OVP_THLD_MASK,\n\t\t\t\t   CS35L36_BST_OVP_THLD_11V);\n\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_UNLOCK2);\n\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BST_ANA2_TEST,\n\t\t\t\t   CS35L36_BST_OVP_TRIM_MASK,\n\t\t\t\t   CS35L36_BST_OVP_TRIM_11V <<\n\t\t\t\t   CS35L36_BST_OVP_TRIM_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_VCTRL2,\n\t\t\t\t   CS35L36_BST_CTRL_LIM_MASK,\n\t\t\t\t   1 << CS35L36_BST_CTRL_LIM_SHIFT);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_BSTCVRT_VCTRL1,\n\t\t\t\t   CS35L35_BSTCVRT_CTL_MASK,\n\t\t\t\t   CS35L36_BST_CTRL_10V_CLAMP);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_LOCK1);\n\t\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t\t     CS35L36_TEST_LOCK2);\n\t}\n\n\t \n\tregmap_update_bits(cs35l36->regmap, CS35L36_CTRL_OVRRIDE,\n\t\t\t   CS35L36_SYNC_GLOBAL_OVR_MASK,\n\t\t\t   0 << CS35L36_SYNC_GLOBAL_OVR_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l36 = {\n\t.probe\t\t\t= &cs35l36_component_probe,\n\t.set_sysclk\t\t= cs35l36_component_set_sysclk,\n\t.dapm_widgets\t\t= cs35l36_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs35l36_dapm_widgets),\n\t.dapm_routes\t\t= cs35l36_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs35l36_audio_map),\n\t.controls\t\t= cs35l36_aud_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs35l36_aud_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct regmap_config cs35l36_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = CS35L36_PAC_PMEM_WORD1023,\n\t.reg_defaults = cs35l36_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l36_reg),\n\t.precious_reg = cs35l36_precious_reg,\n\t.volatile_reg = cs35l36_volatile_reg,\n\t.readable_reg = cs35l36_readable_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic irqreturn_t cs35l36_irq(int irq, void *data)\n{\n\tstruct cs35l36_private *cs35l36 = data;\n\tunsigned int status[4];\n\tunsigned int masks[4];\n\tint ret = IRQ_NONE;\n\n\t \n\tregmap_bulk_read(cs35l36->regmap, CS35L36_INT1_STATUS, status,\n\t\t\t ARRAY_SIZE(status));\n\n\tregmap_bulk_read(cs35l36->regmap, CS35L36_INT1_MASK, masks,\n\t\t\t ARRAY_SIZE(masks));\n\n\t \n\tif (!(status[0] & ~masks[0]) && !(status[1] & ~masks[1]) &&\n\t\t!(status[2] & ~masks[2]) && !(status[3] & ~masks[3])) {\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (status[2] & CS35L36_AMP_SHORT_ERR) {\n\t\tdev_crit(cs35l36->dev, \"Amp short error\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR_RLS,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT3_STATUS,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR,\n\t\t\t\t   CS35L36_AMP_SHORT_ERR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L36_TEMP_WARN) {\n\t\tdev_crit(cs35l36->dev, \"Over temperature warning\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_WARN_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_WARN_ERR_RLS,\n\t\t\t\t   CS35L36_TEMP_WARN_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_WARN_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT1_STATUS,\n\t\t\t\t   CS35L36_TEMP_WARN, CS35L36_TEMP_WARN);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L36_TEMP_ERR) {\n\t\tdev_crit(cs35l36->dev, \"Over temperature error\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, CS35L36_TEMP_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT1_STATUS,\n\t\t\t\t   CS35L36_TEMP_ERR, CS35L36_TEMP_ERR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L36_BST_OVP_ERR) {\n\t\tdev_crit(cs35l36->dev, \"VBST Over Voltage error\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, CS35L36_TEMP_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_TEMP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT1_STATUS,\n\t\t\t\t   CS35L36_BST_OVP_ERR, CS35L36_BST_OVP_ERR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L36_BST_DCM_UVP_ERR) {\n\t\tdev_crit(cs35l36->dev, \"DCM VBST Under Voltage Error\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_UVP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_UVP_ERR_RLS,\n\t\t\t\t   CS35L36_BST_UVP_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_UVP_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT1_STATUS,\n\t\t\t\t   CS35L36_BST_DCM_UVP_ERR,\n\t\t\t\t   CS35L36_BST_DCM_UVP_ERR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L36_BST_SHORT_ERR) {\n\t\tdev_crit(cs35l36->dev, \"LBST SHORT error!\\n\");\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_SHORT_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_SHORT_ERR_RLS,\n\t\t\t\t   CS35L36_BST_SHORT_ERR_RLS);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_PROTECT_REL_ERR,\n\t\t\t\t   CS35L36_BST_SHORT_ERR_RLS, 0);\n\t\tregmap_update_bits(cs35l36->regmap, CS35L36_INT1_STATUS,\n\t\t\t\t   CS35L36_BST_SHORT_ERR,\n\t\t\t\t   CS35L36_BST_SHORT_ERR);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int cs35l36_handle_of_data(struct i2c_client *i2c_client,\n\t\t\t\tstruct cs35l36_platform_data *pdata)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tstruct cs35l36_vpbr_cfg *vpbr_config = &pdata->vpbr_config;\n\tstruct device_node *vpbr_node;\n\tunsigned int val;\n\tint ret;\n\n\tif (!np)\n\t\treturn 0;\n\n\tret = of_property_read_u32(np, \"cirrus,boost-ctl-millivolt\", &val);\n\tif (!ret) {\n\t\tif (val < 2550 || val > 12000) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Voltage %d mV\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdata->bst_vctl = (((val - 2550) / 100) + 1) << 1;\n\t} else {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Unable to find required parameter 'cirrus,boost-ctl-millivolt'\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(np, \"cirrus,boost-ctl-select\", &val);\n\tif (!ret)\n\t\tpdata->bst_vctl_sel = val | CS35L36_VALID_PDATA;\n\n\tret = of_property_read_u32(np, \"cirrus,boost-peak-milliamp\", &val);\n\tif (!ret) {\n\t\tif (val < 1600 || val > 4500) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Peak Current %u mA\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpdata->bst_ipk = (val - 1600) / 50;\n\t} else {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Unable to find required parameter 'cirrus,boost-peak-milliamp'\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdata->multi_amp_mode = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,multi-amp-mode\");\n\n\tpdata->dcm_mode = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,dcm-mode-enable\");\n\n\tpdata->amp_pcm_inv = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,amp-pcm-inv\");\n\n\tpdata->imon_pol_inv = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,imon-pol-inv\");\n\n\tpdata->vmon_pol_inv = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,vmon-pol-inv\");\n\n\tif (of_property_read_u32(np, \"cirrus,temp-warn-threshold\", &val) >= 0)\n\t\tpdata->temp_warn_thld = val | CS35L36_VALID_PDATA;\n\n\tif (of_property_read_u32(np, \"cirrus,boost-ind-nanohenry\", &val) >= 0) {\n\t\tpdata->boost_ind = val;\n\t} else {\n\t\tdev_err(&i2c_client->dev, \"Inductor not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,irq-drive-select\", &val) >= 0)\n\t\tpdata->irq_drv_sel = val | CS35L36_VALID_PDATA;\n\n\tif (of_property_read_u32(np, \"cirrus,irq-gpio-select\", &val) >= 0)\n\t\tpdata->irq_gpio_sel = val | CS35L36_VALID_PDATA;\n\n\t \n\tvpbr_node = of_get_child_by_name(np, \"cirrus,vpbr-config\");\n\tvpbr_config->is_present = vpbr_node ? true : false;\n\tif (vpbr_config->is_present) {\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-en\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_en = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-thld\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_thld = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-atk-rate\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_atk_rate = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-atk-vol\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_atk_vol = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-max-attn\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_max_attn = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-wait\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_wait = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-rel-rate\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_rel_rate = val;\n\t\tif (of_property_read_u32(vpbr_node, \"cirrus,vpbr-mute-en\",\n\t\t\t\t\t &val) >= 0)\n\t\t\tvpbr_config->vpbr_mute_en = val;\n\t}\n\tof_node_put(vpbr_node);\n\n\treturn 0;\n}\n\nstatic int cs35l36_pac(struct cs35l36_private *cs35l36)\n{\n\tint ret, count;\n\tunsigned int val;\n\n\tif (cs35l36->rev_id != CS35L36_REV_B0)\n\t\treturn 0;\n\n\t \n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t     CS35L36_TEST_UNLOCK1);\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t     CS35L36_TEST_UNLOCK2);\n\n\tusleep_range(9500, 10500);\n\n\tregmap_write(cs35l36->regmap, CS35L36_PAC_CTL1,\n\t\t     CS35L36_PAC_RESET);\n\tregmap_write(cs35l36->regmap, CS35L36_PAC_CTL3,\n\t\t     CS35L36_PAC_MEM_ACCESS);\n\tregmap_write(cs35l36->regmap, CS35L36_PAC_PMEM_WORD0,\n\t\t     CS35L36_B0_PAC_PATCH);\n\n\tregmap_write(cs35l36->regmap, CS35L36_PAC_CTL3,\n\t\t     CS35L36_PAC_MEM_ACCESS_CLR);\n\tregmap_write(cs35l36->regmap, CS35L36_PAC_CTL1,\n\t\t     CS35L36_PAC_ENABLE_MASK);\n\n\tusleep_range(9500, 10500);\n\n\tret = regmap_read(cs35l36->regmap, CS35L36_INT4_STATUS, &val);\n\tif (ret < 0) {\n\t\tdev_err(cs35l36->dev, \"Failed to read int4_status %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcount = 0;\n\twhile (!(val & CS35L36_MCU_CONFIG_CLR)) {\n\t\tusleep_range(100, 200);\n\t\tcount++;\n\n\t\tret = regmap_read(cs35l36->regmap, CS35L36_INT4_STATUS,\n\t\t\t\t  &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cs35l36->dev, \"Failed to read int4_status %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (count >= 100)\n\t\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(cs35l36->regmap, CS35L36_INT4_STATUS,\n\t\t     CS35L36_MCU_CONFIG_CLR);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PAC_CTL1,\n\t\t\t   CS35L36_PAC_ENABLE_MASK, 0);\n\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t     CS35L36_TEST_LOCK1);\n\tregmap_write(cs35l36->regmap, CS35L36_TESTKEY_CTRL,\n\t\t     CS35L36_TEST_LOCK2);\n\n\treturn 0;\n}\n\nstatic void cs35l36_apply_vpbr_config(struct cs35l36_private *cs35l36)\n{\n\tstruct cs35l36_platform_data *pdata = &cs35l36->pdata;\n\tstruct cs35l36_vpbr_cfg *vpbr_config = &pdata->vpbr_config;\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PWR_CTRL3,\n\t\t\t   CS35L36_VPBR_EN_MASK,\n\t\t\t   vpbr_config->vpbr_en <<\n\t\t\t   CS35L36_VPBR_EN_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_THLD_MASK,\n\t\t\t   vpbr_config->vpbr_thld <<\n\t\t\t   CS35L36_VPBR_THLD_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_MAX_ATTN_MASK,\n\t\t\t   vpbr_config->vpbr_max_attn <<\n\t\t\t   CS35L36_VPBR_MAX_ATTN_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_ATK_VOL_MASK,\n\t\t\t   vpbr_config->vpbr_atk_vol <<\n\t\t\t   CS35L36_VPBR_ATK_VOL_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_ATK_RATE_MASK,\n\t\t\t   vpbr_config->vpbr_atk_rate <<\n\t\t\t   CS35L36_VPBR_ATK_RATE_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_WAIT_MASK,\n\t\t\t   vpbr_config->vpbr_wait <<\n\t\t\t   CS35L36_VPBR_WAIT_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_REL_RATE_MASK,\n\t\t\t   vpbr_config->vpbr_rel_rate <<\n\t\t\t   CS35L36_VPBR_REL_RATE_SHIFT);\n\tregmap_update_bits(cs35l36->regmap, CS35L36_VPBR_CFG,\n\t\t\t   CS35L36_VPBR_MUTE_EN_MASK,\n\t\t\t   vpbr_config->vpbr_mute_en <<\n\t\t\t   CS35L36_VPBR_MUTE_EN_SHIFT);\n}\n\nstatic const struct reg_sequence cs35l36_reva0_errata_patch[] = {\n\t{ CS35L36_TESTKEY_CTRL,\t\tCS35L36_TEST_UNLOCK1 },\n\t{ CS35L36_TESTKEY_CTRL,\t\tCS35L36_TEST_UNLOCK2 },\n\t \n\t{ CS35L36_OTP_CTRL1,\t\t0x00002060 },\n\t{ CS35L36_OTP_CTRL2,\t\t0x00000001 },\n\t{ CS35L36_OTP_CTRL1,\t\t0x00002460 },\n\t{ CS35L36_OTP_CTRL2,\t\t0x00000001 },\n\t{ 0x00002088,\t\t\t0x012A1838 },\n\t{ 0x00003014,\t\t\t0x0100EE0E },\n\t{ 0x00003008,\t\t\t0x0008184A },\n\t{ 0x00007418,\t\t\t0x509001C8 },\n\t{ 0x00007064,\t\t\t0x0929A800 },\n\t{ 0x00002D10,\t\t\t0x0002C01C },\n\t{ 0x0000410C,\t\t\t0x00000A11 },\n\t{ 0x00006E08,\t\t\t0x8B19140C },\n\t{ 0x00006454,\t\t\t0x0300000A },\n\t{ CS35L36_AMP_NG_CTRL,\t\t0x000020EF },\n\t{ 0x00007E34,\t\t\t0x0000000E },\n\t{ 0x0000410C,\t\t\t0x00000A11 },\n\t{ 0x00007410,\t\t\t0x20514B00 },\n\t \n\t{ CS35L36_CTRL_OVRRIDE,\t\t0x00000000 },\n\t{ CS35L36_PAC_INT0_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT1_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT2_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT3_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT4_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT5_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT6_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT7_CTRL,\t0x00860001 },\n\t{ CS35L36_PAC_INT_FLUSH_CTRL,\t0x000000FF },\n\t{ CS35L36_TESTKEY_CTRL,\t\tCS35L36_TEST_LOCK1 },\n\t{ CS35L36_TESTKEY_CTRL,\t\tCS35L36_TEST_LOCK2 },\n};\n\nstatic const struct reg_sequence cs35l36_revb0_errata_patch[] = {\n\t{ CS35L36_TESTKEY_CTRL,\tCS35L36_TEST_UNLOCK1 },\n\t{ CS35L36_TESTKEY_CTRL, CS35L36_TEST_UNLOCK2 },\n\t{ 0x00007064,\t\t0x0929A800 },\n\t{ 0x00007850,\t\t0x00002FA9 },\n\t{ 0x00007854,\t\t0x0003F1D5 },\n\t{ 0x00007858,\t\t0x0003F5E3 },\n\t{ 0x0000785C,\t\t0x00001137 },\n\t{ 0x00007860,\t\t0x0001A7A5 },\n\t{ 0x00007864,\t\t0x0002F16A },\n\t{ 0x00007868,\t\t0x00003E21 },\n\t{ 0x00007848,\t\t0x00000001 },\n\t{ 0x00003854,\t\t0x05180240 },\n\t{ 0x00007418,\t\t0x509001C8 },\n\t{ 0x0000394C,\t\t0x028764BD },\n\t{ CS35L36_TESTKEY_CTRL,\tCS35L36_TEST_LOCK1 },\n\t{ CS35L36_TESTKEY_CTRL, CS35L36_TEST_LOCK2 },\n};\n\nstatic int cs35l36_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs35l36_private *cs35l36;\n\tstruct device *dev = &i2c_client->dev;\n\tstruct cs35l36_platform_data *pdata = dev_get_platdata(dev);\n\tstruct irq_data *irq_d;\n\tint ret, irq_pol, chip_irq_pol, i;\n\tu32 reg_id, reg_revid, l37_id_reg;\n\n\tcs35l36 = devm_kzalloc(dev, sizeof(struct cs35l36_private), GFP_KERNEL);\n\tif (!cs35l36)\n\t\treturn -ENOMEM;\n\n\tcs35l36->dev = dev;\n\n\ti2c_set_clientdata(i2c_client, cs35l36);\n\tcs35l36->regmap = devm_regmap_init_i2c(i2c_client, &cs35l36_regmap);\n\tif (IS_ERR(cs35l36->regmap)) {\n\t\tret = PTR_ERR(cs35l36->regmap);\n\t\tdev_err(dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs35l36->num_supplies = ARRAY_SIZE(cs35l36_supplies);\n\tfor (i = 0; i < ARRAY_SIZE(cs35l36_supplies); i++)\n\t\tcs35l36->supplies[i].supply = cs35l36_supplies[i];\n\n\tret = devm_regulator_bulk_get(dev, cs35l36->num_supplies,\n\t\t\t\t      cs35l36->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs35l36->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(dev, sizeof(struct cs35l36_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tret = cs35l36_handle_of_data(i2c_client, pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t}\n\n\t\tcs35l36->pdata = *pdata;\n\t}\n\n\tret = regulator_bulk_enable(cs35l36->num_supplies, cs35l36->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs35l36->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l36->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l36->reset_gpio);\n\t\tcs35l36->reset_gpio = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_info(dev, \"Reset line busy, assuming shared reset\\n\");\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to get reset GPIO: %d\\n\", ret);\n\t\t\tgoto err_disable_regs;\n\t\t}\n\t}\n\n\tif (cs35l36->reset_gpio)\n\t\tgpiod_set_value_cansleep(cs35l36->reset_gpio, 1);\n\n\tusleep_range(2000, 2100);\n\n\t \n\tret = regmap_read(cs35l36->regmap, CS35L36_SW_RESET, &reg_id);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Get Device ID failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (reg_id != CS35L36_CHIP_ID) {\n\t\tdev_err(dev, \"Device ID (%X). Expected ID %X\\n\", reg_id,\n\t\t\tCS35L36_CHIP_ID);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l36->regmap, CS35L36_REV_ID, &reg_revid);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Get Revision ID failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tcs35l36->rev_id = reg_revid >> 8;\n\n\tret = regmap_read(cs35l36->regmap, CS35L36_OTP_MEM30, &l37_id_reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Failed to read otp_id Register %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tif ((l37_id_reg & CS35L36_OTP_REV_MASK) == CS35L36_OTP_REV_L37)\n\t\tcs35l36->chip_version = CS35L36_12V_L37;\n\telse\n\t\tcs35l36->chip_version = CS35L36_10V_L36;\n\n\tswitch (cs35l36->rev_id) {\n\tcase CS35L36_REV_A0:\n\t\tret = regmap_register_patch(cs35l36->regmap,\n\t\t\t\tcs35l36_reva0_errata_patch,\n\t\t\t\tARRAY_SIZE(cs35l36_reva0_errata_patch));\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to apply A0 errata patch %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase CS35L36_REV_B0:\n\t\tret = cs35l36_pac(cs35l36);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to Trim OTP %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = regmap_register_patch(cs35l36->regmap,\n\t\t\t\tcs35l36_revb0_errata_patch,\n\t\t\t\tARRAY_SIZE(cs35l36_revb0_errata_patch));\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to apply B0 errata patch %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (pdata->vpbr_config.is_present)\n\t\tcs35l36_apply_vpbr_config(cs35l36);\n\n\tirq_d = irq_get_irq_data(i2c_client->irq);\n\tif (!irq_d) {\n\t\tdev_err(&i2c_client->dev, \"Invalid IRQ: %d\\n\", i2c_client->irq);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tirq_pol = irqd_get_trigger_type(irq_d);\n\n\tswitch (irq_pol) {\n\tcase IRQF_TRIGGER_FALLING:\n\tcase IRQF_TRIGGER_LOW:\n\t\tchip_irq_pol = 0;\n\t\tbreak;\n\tcase IRQF_TRIGGER_RISING:\n\tcase IRQF_TRIGGER_HIGH:\n\t\tchip_irq_pol = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l36->dev, \"Invalid IRQ polarity: %d\\n\", irq_pol);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PAD_INTERFACE,\n\t\t\t   CS35L36_INT_POL_SEL_MASK,\n\t\t\t   chip_irq_pol << CS35L36_INT_POL_SEL_SHIFT);\n\n\tret = devm_request_threaded_irq(dev, i2c_client->irq, NULL, cs35l36_irq,\n\t\t\t\t\tIRQF_ONESHOT | irq_pol, \"cs35l36\",\n\t\t\t\t\tcs35l36);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tregmap_update_bits(cs35l36->regmap, CS35L36_PAD_INTERFACE,\n\t\t\t   CS35L36_INT_OUTPUT_EN_MASK, 1);\n\n\t \n\tregmap_write(cs35l36->regmap, CS35L36_INT1_MASK,\n\t\t     CS35L36_INT1_MASK_DEFAULT);\n\tregmap_write(cs35l36->regmap, CS35L36_INT3_MASK,\n\t\t     CS35L36_INT3_MASK_DEFAULT);\n\n\tdev_info(&i2c_client->dev, \"Cirrus Logic CS35L%d, Revision: %02X\\n\",\n\t\t cs35l36->chip_version, reg_revid >> 8);\n\n\tret =  devm_snd_soc_register_component(dev, &soc_component_dev_cs35l36,\n\t\t\t\t\t       cs35l36_dai,\n\t\t\t\t\t       ARRAY_SIZE(cs35l36_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s: Register component failed %d\\n\", __func__,\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tgpiod_set_value_cansleep(cs35l36->reset_gpio, 0);\n\nerr_disable_regs:\n\tregulator_bulk_disable(cs35l36->num_supplies, cs35l36->supplies);\n\treturn ret;\n}\n\nstatic void cs35l36_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs35l36_private *cs35l36 = i2c_get_clientdata(client);\n\n\t \n\tregmap_write(cs35l36->regmap, CS35L36_INT1_MASK,\n\t\t     CS35L36_INT1_MASK_RESET);\n\tregmap_write(cs35l36->regmap, CS35L36_INT3_MASK,\n\t\t     CS35L36_INT3_MASK_RESET);\n\n\tif (cs35l36->reset_gpio)\n\t\tgpiod_set_value_cansleep(cs35l36->reset_gpio, 0);\n\n\tregulator_bulk_disable(cs35l36->num_supplies, cs35l36->supplies);\n}\nstatic const struct of_device_id cs35l36_of_match[] = {\n\t{.compatible = \"cirrus,cs35l36\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs35l36_of_match);\n\nstatic const struct i2c_device_id cs35l36_id[] = {\n\t{\"cs35l36\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs35l36_id);\n\nstatic struct i2c_driver cs35l36_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs35l36\",\n\t\t.of_match_table = cs35l36_of_match,\n\t},\n\t.id_table = cs35l36_id,\n\t.probe = cs35l36_i2c_probe,\n\t.remove = cs35l36_i2c_remove,\n};\nmodule_i2c_driver(cs35l36_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS35L36 driver\");\nMODULE_AUTHOR(\"James Schulman, Cirrus Logic Inc, <james.schulman@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}