{
  "module_name": "cs35l41-lib.c",
  "hash_id": "9e38730c76dcf47b5b72ba645ba1d7b9c8eeaecb7b32385889336fe2824d9a2b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l41-lib.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/dev_printk.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/firmware/cirrus/wmfw.h>\n\n#include <sound/cs35l41.h>\n\nstatic const struct reg_default cs35l41_reg[] = {\n\t{ CS35L41_PWR_CTRL1,\t\t\t0x00000000 },\n\t{ CS35L41_PWR_CTRL2,\t\t\t0x00000000 },\n\t{ CS35L41_PWR_CTRL3,\t\t\t0x01000010 },\n\t{ CS35L41_GPIO_PAD_CONTROL,\t\t0x00000000 },\n\t{ CS35L41_GLOBAL_CLK_CTRL,\t\t0x00000003 },\n\t{ CS35L41_TST_FS_MON0,\t\t\t0x00020016 },\n\t{ CS35L41_BSTCVRT_COEFF,\t\t0x00002424 },\n\t{ CS35L41_BSTCVRT_SLOPE_LBST,\t\t0x00007500 },\n\t{ CS35L41_BSTCVRT_PEAK_CUR,\t\t0x0000004A },\n\t{ CS35L41_SP_ENABLES,\t\t\t0x00000000 },\n\t{ CS35L41_SP_RATE_CTRL,\t\t\t0x00000028 },\n\t{ CS35L41_SP_FORMAT,\t\t\t0x18180200 },\n\t{ CS35L41_SP_HIZ_CTRL,\t\t\t0x00000002 },\n\t{ CS35L41_SP_FRAME_TX_SLOT,\t\t0x03020100 },\n\t{ CS35L41_SP_FRAME_RX_SLOT,\t\t0x00000100 },\n\t{ CS35L41_SP_TX_WL,\t\t\t0x00000018 },\n\t{ CS35L41_SP_RX_WL,\t\t\t0x00000018 },\n\t{ CS35L41_DAC_PCM1_SRC,\t\t\t0x00000008 },\n\t{ CS35L41_ASP_TX1_SRC,\t\t\t0x00000018 },\n\t{ CS35L41_ASP_TX2_SRC,\t\t\t0x00000019 },\n\t{ CS35L41_ASP_TX3_SRC,\t\t\t0x00000000 },\n\t{ CS35L41_ASP_TX4_SRC,\t\t\t0x00000000 },\n\t{ CS35L41_DSP1_RX1_SRC,\t\t\t0x00000008 },\n\t{ CS35L41_DSP1_RX2_SRC,\t\t\t0x00000009 },\n\t{ CS35L41_DSP1_RX3_SRC,\t\t\t0x00000018 },\n\t{ CS35L41_DSP1_RX4_SRC,\t\t\t0x00000019 },\n\t{ CS35L41_DSP1_RX5_SRC,\t\t\t0x00000020 },\n\t{ CS35L41_DSP1_RX6_SRC,\t\t\t0x00000021 },\n\t{ CS35L41_DSP1_RX7_SRC,\t\t\t0x0000003A },\n\t{ CS35L41_DSP1_RX8_SRC,\t\t\t0x0000003B },\n\t{ CS35L41_NGATE1_SRC,\t\t\t0x00000008 },\n\t{ CS35L41_NGATE2_SRC,\t\t\t0x00000009 },\n\t{ CS35L41_AMP_DIG_VOL_CTRL,\t\t0x00008000 },\n\t{ CS35L41_CLASSH_CFG,\t\t\t0x000B0405 },\n\t{ CS35L41_WKFET_CFG,\t\t\t0x00000111 },\n\t{ CS35L41_NG_CFG,\t\t\t0x00000033 },\n\t{ CS35L41_AMP_GAIN_CTRL,\t\t0x00000000 },\n\t{ CS35L41_IRQ1_MASK1,\t\t\t0xFFFFFFFF },\n\t{ CS35L41_IRQ1_MASK2,\t\t\t0xFFFFFFFF },\n\t{ CS35L41_IRQ1_MASK3,\t\t\t0xFFFF87FF },\n\t{ CS35L41_IRQ1_MASK4,\t\t\t0xFEFFFFFF },\n\t{ CS35L41_GPIO1_CTRL1,\t\t\t0x81000001 },\n\t{ CS35L41_GPIO2_CTRL1,\t\t\t0x81000001 },\n\t{ CS35L41_MIXER_NGATE_CFG,\t\t0x00000000 },\n\t{ CS35L41_MIXER_NGATE_CH1_CFG,\t\t0x00000303 },\n\t{ CS35L41_MIXER_NGATE_CH2_CFG,\t\t0x00000303 },\n\t{ CS35L41_DSP1_CCM_CORE_CTRL,\t\t0x00000101 },\n};\n\nstatic bool cs35l41_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L41_DEVID:\n\tcase CS35L41_REVID:\n\tcase CS35L41_FABID:\n\tcase CS35L41_RELID:\n\tcase CS35L41_OTPID:\n\tcase CS35L41_TEST_KEY_CTL:\n\tcase CS35L41_USER_KEY_CTL:\n\tcase CS35L41_OTP_CTRL0:\n\tcase CS35L41_OTP_CTRL3:\n\tcase CS35L41_OTP_CTRL4:\n\tcase CS35L41_OTP_CTRL5:\n\tcase CS35L41_OTP_CTRL6:\n\tcase CS35L41_OTP_CTRL7:\n\tcase CS35L41_OTP_CTRL8:\n\tcase CS35L41_PWR_CTRL1:\n\tcase CS35L41_PWR_CTRL2:\n\tcase CS35L41_PWR_CTRL3:\n\tcase CS35L41_CTRL_OVRRIDE:\n\tcase CS35L41_AMP_OUT_MUTE:\n\tcase CS35L41_PROTECT_REL_ERR_IGN:\n\tcase CS35L41_GPIO_PAD_CONTROL:\n\tcase CS35L41_JTAG_CONTROL:\n\tcase CS35L41_PWRMGT_CTL:\n\tcase CS35L41_WAKESRC_CTL:\n\tcase CS35L41_PWRMGT_STS:\n\tcase CS35L41_PLL_CLK_CTRL:\n\tcase CS35L41_DSP_CLK_CTRL:\n\tcase CS35L41_GLOBAL_CLK_CTRL:\n\tcase CS35L41_DATA_FS_SEL:\n\tcase CS35L41_TST_FS_MON0:\n\tcase CS35L41_MDSYNC_EN:\n\tcase CS35L41_MDSYNC_TX_ID:\n\tcase CS35L41_MDSYNC_PWR_CTRL:\n\tcase CS35L41_MDSYNC_DATA_TX:\n\tcase CS35L41_MDSYNC_TX_STATUS:\n\tcase CS35L41_MDSYNC_DATA_RX:\n\tcase CS35L41_MDSYNC_RX_STATUS:\n\tcase CS35L41_MDSYNC_ERR_STATUS:\n\tcase CS35L41_MDSYNC_SYNC_PTE2:\n\tcase CS35L41_MDSYNC_SYNC_PTE3:\n\tcase CS35L41_MDSYNC_SYNC_MSM_STATUS:\n\tcase CS35L41_BSTCVRT_VCTRL1:\n\tcase CS35L41_BSTCVRT_VCTRL2:\n\tcase CS35L41_BSTCVRT_PEAK_CUR:\n\tcase CS35L41_BSTCVRT_SFT_RAMP:\n\tcase CS35L41_BSTCVRT_COEFF:\n\tcase CS35L41_BSTCVRT_SLOPE_LBST:\n\tcase CS35L41_BSTCVRT_SW_FREQ:\n\tcase CS35L41_BSTCVRT_DCM_CTRL:\n\tcase CS35L41_BSTCVRT_DCM_MODE_FORCE:\n\tcase CS35L41_BSTCVRT_OVERVOLT_CTRL:\n\tcase CS35L41_VI_VOL_POL:\n\tcase CS35L41_DTEMP_WARN_THLD:\n\tcase CS35L41_DTEMP_CFG:\n\tcase CS35L41_DTEMP_EN:\n\tcase CS35L41_VPVBST_FS_SEL:\n\tcase CS35L41_SP_ENABLES:\n\tcase CS35L41_SP_RATE_CTRL:\n\tcase CS35L41_SP_FORMAT:\n\tcase CS35L41_SP_HIZ_CTRL:\n\tcase CS35L41_SP_FRAME_TX_SLOT:\n\tcase CS35L41_SP_FRAME_RX_SLOT:\n\tcase CS35L41_SP_TX_WL:\n\tcase CS35L41_SP_RX_WL:\n\tcase CS35L41_DAC_PCM1_SRC:\n\tcase CS35L41_ASP_TX1_SRC:\n\tcase CS35L41_ASP_TX2_SRC:\n\tcase CS35L41_ASP_TX3_SRC:\n\tcase CS35L41_ASP_TX4_SRC:\n\tcase CS35L41_DSP1_RX1_SRC:\n\tcase CS35L41_DSP1_RX2_SRC:\n\tcase CS35L41_DSP1_RX3_SRC:\n\tcase CS35L41_DSP1_RX4_SRC:\n\tcase CS35L41_DSP1_RX5_SRC:\n\tcase CS35L41_DSP1_RX6_SRC:\n\tcase CS35L41_DSP1_RX7_SRC:\n\tcase CS35L41_DSP1_RX8_SRC:\n\tcase CS35L41_NGATE1_SRC:\n\tcase CS35L41_NGATE2_SRC:\n\tcase CS35L41_AMP_DIG_VOL_CTRL:\n\tcase CS35L41_VPBR_CFG:\n\tcase CS35L41_VBBR_CFG:\n\tcase CS35L41_VPBR_STATUS:\n\tcase CS35L41_VBBR_STATUS:\n\tcase CS35L41_OVERTEMP_CFG:\n\tcase CS35L41_AMP_ERR_VOL:\n\tcase CS35L41_VOL_STATUS_TO_DSP:\n\tcase CS35L41_CLASSH_CFG:\n\tcase CS35L41_WKFET_CFG:\n\tcase CS35L41_NG_CFG:\n\tcase CS35L41_AMP_GAIN_CTRL:\n\tcase CS35L41_DAC_MSM_CFG:\n\tcase CS35L41_IRQ1_CFG:\n\tcase CS35L41_IRQ1_STATUS:\n\tcase CS35L41_IRQ1_STATUS1:\n\tcase CS35L41_IRQ1_STATUS2:\n\tcase CS35L41_IRQ1_STATUS3:\n\tcase CS35L41_IRQ1_STATUS4:\n\tcase CS35L41_IRQ1_RAW_STATUS1:\n\tcase CS35L41_IRQ1_RAW_STATUS2:\n\tcase CS35L41_IRQ1_RAW_STATUS3:\n\tcase CS35L41_IRQ1_RAW_STATUS4:\n\tcase CS35L41_IRQ1_MASK1:\n\tcase CS35L41_IRQ1_MASK2:\n\tcase CS35L41_IRQ1_MASK3:\n\tcase CS35L41_IRQ1_MASK4:\n\tcase CS35L41_IRQ1_FRC1:\n\tcase CS35L41_IRQ1_FRC2:\n\tcase CS35L41_IRQ1_FRC3:\n\tcase CS35L41_IRQ1_FRC4:\n\tcase CS35L41_IRQ1_EDGE1:\n\tcase CS35L41_IRQ1_EDGE4:\n\tcase CS35L41_IRQ1_POL1:\n\tcase CS35L41_IRQ1_POL2:\n\tcase CS35L41_IRQ1_POL3:\n\tcase CS35L41_IRQ1_POL4:\n\tcase CS35L41_IRQ1_DB3:\n\tcase CS35L41_IRQ2_CFG:\n\tcase CS35L41_IRQ2_STATUS:\n\tcase CS35L41_IRQ2_STATUS1:\n\tcase CS35L41_IRQ2_STATUS2:\n\tcase CS35L41_IRQ2_STATUS3:\n\tcase CS35L41_IRQ2_STATUS4:\n\tcase CS35L41_IRQ2_RAW_STATUS1:\n\tcase CS35L41_IRQ2_RAW_STATUS2:\n\tcase CS35L41_IRQ2_RAW_STATUS3:\n\tcase CS35L41_IRQ2_RAW_STATUS4:\n\tcase CS35L41_IRQ2_MASK1:\n\tcase CS35L41_IRQ2_MASK2:\n\tcase CS35L41_IRQ2_MASK3:\n\tcase CS35L41_IRQ2_MASK4:\n\tcase CS35L41_IRQ2_FRC1:\n\tcase CS35L41_IRQ2_FRC2:\n\tcase CS35L41_IRQ2_FRC3:\n\tcase CS35L41_IRQ2_FRC4:\n\tcase CS35L41_IRQ2_EDGE1:\n\tcase CS35L41_IRQ2_EDGE4:\n\tcase CS35L41_IRQ2_POL1:\n\tcase CS35L41_IRQ2_POL2:\n\tcase CS35L41_IRQ2_POL3:\n\tcase CS35L41_IRQ2_POL4:\n\tcase CS35L41_IRQ2_DB3:\n\tcase CS35L41_GPIO_STATUS1:\n\tcase CS35L41_GPIO1_CTRL1:\n\tcase CS35L41_GPIO2_CTRL1:\n\tcase CS35L41_MIXER_NGATE_CFG:\n\tcase CS35L41_MIXER_NGATE_CH1_CFG:\n\tcase CS35L41_MIXER_NGATE_CH2_CFG:\n\tcase CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:\n\tcase CS35L41_CLOCK_DETECT_1:\n\tcase CS35L41_DIE_STS1:\n\tcase CS35L41_DIE_STS2:\n\tcase CS35L41_TEMP_CAL1:\n\tcase CS35L41_TEMP_CAL2:\n\tcase CS35L41_DSP1_TIMESTAMP_COUNT:\n\tcase CS35L41_DSP1_SYS_ID:\n\tcase CS35L41_DSP1_SYS_VERSION:\n\tcase CS35L41_DSP1_SYS_CORE_ID:\n\tcase CS35L41_DSP1_SYS_AHB_ADDR:\n\tcase CS35L41_DSP1_SYS_XSRAM_SIZE:\n\tcase CS35L41_DSP1_SYS_YSRAM_SIZE:\n\tcase CS35L41_DSP1_SYS_PSRAM_SIZE:\n\tcase CS35L41_DSP1_SYS_PM_BOOT_SIZE:\n\tcase CS35L41_DSP1_SYS_FEATURES:\n\tcase CS35L41_DSP1_SYS_FIR_FILTERS:\n\tcase CS35L41_DSP1_SYS_LMS_FILTERS:\n\tcase CS35L41_DSP1_SYS_XM_BANK_SIZE:\n\tcase CS35L41_DSP1_SYS_YM_BANK_SIZE:\n\tcase CS35L41_DSP1_SYS_PM_BANK_SIZE:\n\tcase CS35L41_DSP1_RX1_RATE:\n\tcase CS35L41_DSP1_RX2_RATE:\n\tcase CS35L41_DSP1_RX3_RATE:\n\tcase CS35L41_DSP1_RX4_RATE:\n\tcase CS35L41_DSP1_RX5_RATE:\n\tcase CS35L41_DSP1_RX6_RATE:\n\tcase CS35L41_DSP1_RX7_RATE:\n\tcase CS35L41_DSP1_RX8_RATE:\n\tcase CS35L41_DSP1_TX1_RATE:\n\tcase CS35L41_DSP1_TX2_RATE:\n\tcase CS35L41_DSP1_TX3_RATE:\n\tcase CS35L41_DSP1_TX4_RATE:\n\tcase CS35L41_DSP1_TX5_RATE:\n\tcase CS35L41_DSP1_TX6_RATE:\n\tcase CS35L41_DSP1_TX7_RATE:\n\tcase CS35L41_DSP1_TX8_RATE:\n\tcase CS35L41_DSP1_SCRATCH1:\n\tcase CS35L41_DSP1_SCRATCH2:\n\tcase CS35L41_DSP1_SCRATCH3:\n\tcase CS35L41_DSP1_SCRATCH4:\n\tcase CS35L41_DSP1_CCM_CORE_CTRL:\n\tcase CS35L41_DSP1_CCM_CLK_OVERRIDE:\n\tcase CS35L41_DSP1_XM_MSTR_EN:\n\tcase CS35L41_DSP1_XM_CORE_PRI:\n\tcase CS35L41_DSP1_XM_AHB_PACK_PL_PRI:\n\tcase CS35L41_DSP1_XM_AHB_UP_PL_PRI:\n\tcase CS35L41_DSP1_XM_ACCEL_PL0_PRI:\n\tcase CS35L41_DSP1_XM_NPL0_PRI:\n\tcase CS35L41_DSP1_YM_MSTR_EN:\n\tcase CS35L41_DSP1_YM_CORE_PRI:\n\tcase CS35L41_DSP1_YM_AHB_PACK_PL_PRI:\n\tcase CS35L41_DSP1_YM_AHB_UP_PL_PRI:\n\tcase CS35L41_DSP1_YM_ACCEL_PL0_PRI:\n\tcase CS35L41_DSP1_YM_NPL0_PRI:\n\tcase CS35L41_DSP1_MPU_XM_ACCESS0:\n\tcase CS35L41_DSP1_MPU_YM_ACCESS0:\n\tcase CS35L41_DSP1_MPU_WNDW_ACCESS0:\n\tcase CS35L41_DSP1_MPU_XREG_ACCESS0:\n\tcase CS35L41_DSP1_MPU_YREG_ACCESS0:\n\tcase CS35L41_DSP1_MPU_XM_ACCESS1:\n\tcase CS35L41_DSP1_MPU_YM_ACCESS1:\n\tcase CS35L41_DSP1_MPU_WNDW_ACCESS1:\n\tcase CS35L41_DSP1_MPU_XREG_ACCESS1:\n\tcase CS35L41_DSP1_MPU_YREG_ACCESS1:\n\tcase CS35L41_DSP1_MPU_XM_ACCESS2:\n\tcase CS35L41_DSP1_MPU_YM_ACCESS2:\n\tcase CS35L41_DSP1_MPU_WNDW_ACCESS2:\n\tcase CS35L41_DSP1_MPU_XREG_ACCESS2:\n\tcase CS35L41_DSP1_MPU_YREG_ACCESS2:\n\tcase CS35L41_DSP1_MPU_XM_ACCESS3:\n\tcase CS35L41_DSP1_MPU_YM_ACCESS3:\n\tcase CS35L41_DSP1_MPU_WNDW_ACCESS3:\n\tcase CS35L41_DSP1_MPU_XREG_ACCESS3:\n\tcase CS35L41_DSP1_MPU_YREG_ACCESS3:\n\tcase CS35L41_DSP1_MPU_XM_VIO_ADDR:\n\tcase CS35L41_DSP1_MPU_XM_VIO_STATUS:\n\tcase CS35L41_DSP1_MPU_YM_VIO_ADDR:\n\tcase CS35L41_DSP1_MPU_YM_VIO_STATUS:\n\tcase CS35L41_DSP1_MPU_PM_VIO_ADDR:\n\tcase CS35L41_DSP1_MPU_PM_VIO_STATUS:\n\tcase CS35L41_DSP1_MPU_LOCK_CONFIG:\n\tcase CS35L41_DSP1_MPU_WDT_RST_CTRL:\n\tcase CS35L41_OTP_TRIM_1:\n\tcase CS35L41_OTP_TRIM_2:\n\tcase CS35L41_OTP_TRIM_3:\n\tcase CS35L41_OTP_TRIM_4:\n\tcase CS35L41_OTP_TRIM_5:\n\tcase CS35L41_OTP_TRIM_6:\n\tcase CS35L41_OTP_TRIM_7:\n\tcase CS35L41_OTP_TRIM_8:\n\tcase CS35L41_OTP_TRIM_9:\n\tcase CS35L41_OTP_TRIM_10:\n\tcase CS35L41_OTP_TRIM_11:\n\tcase CS35L41_OTP_TRIM_12:\n\tcase CS35L41_OTP_TRIM_13:\n\tcase CS35L41_OTP_TRIM_14:\n\tcase CS35L41_OTP_TRIM_15:\n\tcase CS35L41_OTP_TRIM_16:\n\tcase CS35L41_OTP_TRIM_17:\n\tcase CS35L41_OTP_TRIM_18:\n\tcase CS35L41_OTP_TRIM_19:\n\tcase CS35L41_OTP_TRIM_20:\n\tcase CS35L41_OTP_TRIM_21:\n\tcase CS35L41_OTP_TRIM_22:\n\tcase CS35L41_OTP_TRIM_23:\n\tcase CS35L41_OTP_TRIM_24:\n\tcase CS35L41_OTP_TRIM_25:\n\tcase CS35L41_OTP_TRIM_26:\n\tcase CS35L41_OTP_TRIM_27:\n\tcase CS35L41_OTP_TRIM_28:\n\tcase CS35L41_OTP_TRIM_29:\n\tcase CS35L41_OTP_TRIM_30:\n\tcase CS35L41_OTP_TRIM_31:\n\tcase CS35L41_OTP_TRIM_32:\n\tcase CS35L41_OTP_TRIM_33:\n\tcase CS35L41_OTP_TRIM_34:\n\tcase CS35L41_OTP_TRIM_35:\n\tcase CS35L41_OTP_TRIM_36:\n\tcase CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:\n\tcase CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:\n\tcase CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:\n\tcase CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:\n\tcase CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:\n\tcase CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:\n\tcase CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:\n\tcase CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:\n\t \n\tcase CS35L41_PLL_OVR:\n\tcase CS35L41_BST_TEST_DUTY:\n\tcase CS35L41_DIGPWM_IOCTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l41_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L41_TEST_KEY_CTL:\n\tcase CS35L41_USER_KEY_CTL:\n\tcase CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:\n\tcase CS35L41_TST_FS_MON0:\n\tcase CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:\n\tcase CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:\n\tcase CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l41_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L41_DEVID:\n\tcase CS35L41_SFT_RESET:\n\tcase CS35L41_FABID:\n\tcase CS35L41_REVID:\n\tcase CS35L41_OTPID:\n\tcase CS35L41_TEST_KEY_CTL:\n\tcase CS35L41_USER_KEY_CTL:\n\tcase CS35L41_PWRMGT_CTL:\n\tcase CS35L41_WAKESRC_CTL:\n\tcase CS35L41_PWRMGT_STS:\n\tcase CS35L41_DTEMP_EN:\n\tcase CS35L41_IRQ1_STATUS:\n\tcase CS35L41_IRQ1_STATUS1:\n\tcase CS35L41_IRQ1_STATUS2:\n\tcase CS35L41_IRQ1_STATUS3:\n\tcase CS35L41_IRQ1_STATUS4:\n\tcase CS35L41_IRQ1_RAW_STATUS1:\n\tcase CS35L41_IRQ1_RAW_STATUS2:\n\tcase CS35L41_IRQ1_RAW_STATUS3:\n\tcase CS35L41_IRQ1_RAW_STATUS4:\n\tcase CS35L41_IRQ2_STATUS:\n\tcase CS35L41_IRQ2_STATUS1:\n\tcase CS35L41_IRQ2_STATUS2:\n\tcase CS35L41_IRQ2_STATUS3:\n\tcase CS35L41_IRQ2_STATUS4:\n\tcase CS35L41_IRQ2_RAW_STATUS1:\n\tcase CS35L41_IRQ2_RAW_STATUS2:\n\tcase CS35L41_IRQ2_RAW_STATUS3:\n\tcase CS35L41_IRQ2_RAW_STATUS4:\n\tcase CS35L41_GPIO_STATUS1:\n\tcase CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:\n\tcase CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:\n\tcase CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:\n\tcase CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:\n\tcase CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:\n\tcase CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:\n\tcase CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:\n\tcase CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:\n\tcase CS35L41_DSP1_SCRATCH1:\n\tcase CS35L41_DSP1_SCRATCH2:\n\tcase CS35L41_DSP1_SCRATCH3:\n\tcase CS35L41_DSP1_SCRATCH4:\n\tcase CS35L41_DSP1_CCM_CLK_OVERRIDE ... CS35L41_DSP1_WDT_STATUS:\n\tcase CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct cs35l41_otp_packed_element_t otp_map_1[] = {\n\t \n\t{ 0x00002030,\t0,\t4 },  \n\t{ 0x00002030,\t7,\t1 },  \n\t{ 0x0000208c,\t24,\t6 },  \n\t{ 0x00002090,\t14,\t4 },  \n\t{ 0x00002090,\t10,\t4 },  \n\t{ 0x0000300C,\t11,\t4 },  \n\t{ 0x0000394C,\t23,\t2 },  \n\t{ 0x00003950,\t0,\t7 },  \n\t{ 0x00003950,\t8,\t7 },  \n\t{ 0x00003950,\t16,\t8 },  \n\t{ 0x00003950,\t24,\t8 },  \n\t{ 0x00003954,\t0,\t7 },  \n\t{ 0x00003954,\t8,\t7 },  \n\t{ 0x00003954,\t16,\t8 },  \n\t{ 0x00003954,\t24,\t8 },  \n\t{ 0x00003958,\t0,\t7 },  \n\t{ 0x00003958,\t8,\t7 },  \n\t{ 0x00003958,\t16,\t8 },  \n\t{ 0x00003958,\t24,\t8 },  \n\t{ 0x0000395C,\t0,\t7 },  \n\t{ 0x0000395C,\t8,\t7 },  \n\t{ 0x0000395C,\t16,\t8 },  \n\t{ 0x0000395C,\t24,\t8 },  \n\t{ 0x0000416C,\t0,\t8 },  \n\t{ 0x00004160,\t0,\t7 },  \n\t{ 0x0000416C,\t8,\t8 },  \n\t{ 0x00004160,\t16,\t10 },  \n\t{ 0x0000416C,\t16,\t12 },  \n\t{ 0x0000416C,\t28,\t1 },  \n\t{ 0x00004170,\t0,\t6 },  \n\t{ 0x00004170,\t6,\t1 },  \n\t{ 0x00004170,\t8,\t6 },  \n\t{ 0x00004170,\t14,\t1 },  \n\t{ 0x00004170,\t16,\t9 },  \n\t{ 0x00004360,\t0,\t5 },  \n\t{ 0x00004360,\t6,\t9 },  \n\t{ 0x00004448,\t0,\t8 },  \n\t{ 0x00004448,\t8,\t8 },  \n\t{ 0x00004448,\t16,\t8 },  \n\t{ 0x00004448,\t24,\t8 },  \n\t{ 0x0000444C,\t0,\t3 },  \n\t{ 0x00006E30,\t0,\t5 },  \n\t{ 0x00006E30,\t8,\t5 },  \n\t{ 0x00006E30,\t16,\t5 },  \n\t{ 0x00006E30,\t24,\t5 },  \n\t{ 0x00006E34,\t0,\t5 },  \n\t{ 0x00006E34,\t8,\t5 },  \n\t{ 0x00006E34,\t16,\t5 },  \n\t{ 0x00006E34,\t24,\t5 },  \n\t{ 0x00006E38,\t0,\t5 },  \n\t{ 0x00006E38,\t8,\t5 },  \n\t{ 0x00006E38,\t16,\t5 },  \n\t{ 0x00006E38,\t24,\t5 },  \n\t{ 0x00006E3C,\t0,\t5 },  \n\t{ 0x00006E3C,\t8,\t5 },  \n\t{ 0x00006E3C,\t16,\t5 },  \n\t{ 0x00006E3C,\t24,\t5 },  \n\t{ 0x00006E40,\t0,\t5 },  \n\t{ 0x00006E40,\t8,\t5 },  \n\t{ 0x00006E40,\t16,\t5 },  \n\t{ 0x00006E40,\t24,\t5 },  \n\t{ 0x00006E44,\t0,\t5 },  \n\t{ 0x00006E48,\t0,\t10 },  \n\t{ 0x00006E48,\t10,\t10 },  \n\t{ 0x00006E48,\t20,\t10 },  \n\t{ 0x00006E4C,\t0,\t10 },  \n\t{ 0x00006E4C,\t10,\t10 },  \n\t{ 0x00006E4C,\t20,\t10 },  \n\t{ 0x00006E50,\t0,\t10 },  \n\t{ 0x00006E50,\t10,\t10 },  \n\t{ 0x00006E50,\t20,\t10 },  \n\t{ 0x00006E54,\t0,\t10 },  \n\t{ 0x00006E54,\t10,\t10 },  \n\t{ 0x00006E54,\t20,\t10 },  \n\t{ 0x00006E58,\t0,\t10 },  \n\t{ 0x00006E58,\t10,\t10 },  \n\t{ 0x00006E58,\t20,\t10 },  \n\t{ 0x00006E5C,\t0,\t10 },  \n\t{ 0x00006E5C,\t10,\t10 },  \n\t{ 0x00006E5C,\t20,\t10 },  \n\t{ 0x00006E60,\t0,\t10 },  \n\t{ 0x00006E60,\t10,\t10 },  \n\t{ 0x00006E60,\t20,\t10 },  \n\t{ 0x00006E64,\t0,\t10 },  \n\t{ 0x00007418,\t7,\t5 },  \n\t{ 0x0000741C,\t0,\t5 },  \n\t{ 0x0000741C,\t11,\t4 },  \n\t{ 0x0000741C,\t19,\t4 },  \n\t{ 0x00007434,\t17,\t1 },  \n\t{ 0x00007434,\t18,\t7 },  \n\t{ 0x00007068,\t0,\t9 },  \n\t{ 0x0000410C,\t7,\t1 },  \n\t{ 0x0000400C,\t0,\t7 },  \n\t{ 0x00000000,\t0,\t1 },  \n\t{ 0x00017040,\t0,\t8 },  \n\t{ 0x00017040,\t8,\t8 },  \n\t{ 0x00017040,\t16,\t8 },  \n\t{ 0x00017040,\t24,\t8 },  \n\t{ 0x00017044,\t0,\t24 },  \n};\n\nstatic const struct cs35l41_otp_packed_element_t otp_map_2[] = {\n\t \n\t{ 0x00002030,\t0,\t4 },  \n\t{ 0x00002030,\t7,\t1 },  \n\t{ 0x0000208c,\t24,\t6 },  \n\t{ 0x00002090,\t14,\t4 },  \n\t{ 0x00002090,\t10,\t4 },  \n\t{ 0x0000300C,\t11,\t4 },  \n\t{ 0x0000394C,\t23,\t2 },  \n\t{ 0x00003950,\t0,\t7 },  \n\t{ 0x00003950,\t8,\t7 },  \n\t{ 0x00003950,\t16,\t8 },  \n\t{ 0x00003950,\t24,\t8 },  \n\t{ 0x00003954,\t0,\t7 },  \n\t{ 0x00003954,\t8,\t7 },  \n\t{ 0x00003954,\t16,\t8 },  \n\t{ 0x00003954,\t24,\t8 },  \n\t{ 0x00003958,\t0,\t7 },  \n\t{ 0x00003958,\t8,\t7 },  \n\t{ 0x00003958,\t16,\t8 },  \n\t{ 0x00003958,\t24,\t8 },  \n\t{ 0x0000395C,\t0,\t7 },  \n\t{ 0x0000395C,\t8,\t7 },  \n\t{ 0x0000395C,\t16,\t8 },  \n\t{ 0x0000395C,\t24,\t8 },  \n\t{ 0x0000416C,\t0,\t8 },  \n\t{ 0x00004160,\t0,\t7 },  \n\t{ 0x0000416C,\t8,\t8 },  \n\t{ 0x00004160,\t16,\t10 },  \n\t{ 0x0000416C,\t16,\t12 },  \n\t{ 0x0000416C,\t28,\t1 },  \n\t{ 0x00004170,\t0,\t6 },  \n\t{ 0x00004170,\t6,\t1 },  \n\t{ 0x00004170,\t8,\t6 },  \n\t{ 0x00004170,\t14,\t1 },  \n\t{ 0x00004170,\t16,\t9 },  \n\t{ 0x00004360,\t0,\t5 },  \n\t{ 0x00004360,\t6,\t9 },  \n\t{ 0x00004448,\t0,\t8 },  \n\t{ 0x00004448,\t8,\t8 },  \n\t{ 0x00004448,\t16,\t8 },  \n\t{ 0x00004448,\t24,\t8 },  \n\t{ 0x0000444C,\t0,\t3 },  \n\t{ 0x00006E30,\t0,\t5 },  \n\t{ 0x00006E30,\t8,\t5 },  \n\t{ 0x00006E30,\t16,\t5 },  \n\t{ 0x00006E30,\t24,\t5 },  \n\t{ 0x00006E34,\t0,\t5 },  \n\t{ 0x00006E34,\t8,\t5 },  \n\t{ 0x00006E34,\t16,\t5 },  \n\t{ 0x00006E34,\t24,\t5 },  \n\t{ 0x00006E38,\t0,\t5 },  \n\t{ 0x00006E38,\t8,\t5 },  \n\t{ 0x00006E38,\t16,\t5 },  \n\t{ 0x00006E38,\t24,\t5 },  \n\t{ 0x00006E3C,\t0,\t5 },  \n\t{ 0x00006E3C,\t8,\t5 },  \n\t{ 0x00006E3C,\t16,\t5 },  \n\t{ 0x00006E3C,\t24,\t5 },  \n\t{ 0x00006E40,\t0,\t5 },  \n\t{ 0x00006E40,\t8,\t5 },  \n\t{ 0x00006E40,\t16,\t5 },  \n\t{ 0x00006E40,\t24,\t5 },  \n\t{ 0x00006E44,\t0,\t5 },  \n\t{ 0x00006E48,\t0,\t10 },  \n\t{ 0x00006E48,\t10,\t10 },  \n\t{ 0x00006E48,\t20,\t10 },  \n\t{ 0x00006E4C,\t0,\t10 },  \n\t{ 0x00006E4C,\t10,\t10 },  \n\t{ 0x00006E4C,\t20,\t10 },  \n\t{ 0x00006E50,\t0,\t10 },  \n\t{ 0x00006E50,\t10,\t10 },  \n\t{ 0x00006E50,\t20,\t10 },  \n\t{ 0x00006E54,\t0,\t10 },  \n\t{ 0x00006E54,\t10,\t10 },  \n\t{ 0x00006E54,\t20,\t10 },  \n\t{ 0x00006E58,\t0,\t10 },  \n\t{ 0x00006E58,\t10,\t10 },  \n\t{ 0x00006E58,\t20,\t10 },  \n\t{ 0x00006E5C,\t0,\t10 },  \n\t{ 0x00006E5C,\t10,\t10 },  \n\t{ 0x00006E5C,\t20,\t10 },  \n\t{ 0x00006E60,\t0,\t10 },  \n\t{ 0x00006E60,\t10,\t10 },  \n\t{ 0x00006E60,\t20,\t10 },  \n\t{ 0x00006E64,\t0,\t10 },  \n\t{ 0x00007418,\t7,\t5 },  \n\t{ 0x0000741C,\t0,\t5 },  \n\t{ 0x0000741C,\t11,\t4 },  \n\t{ 0x0000741C,\t19,\t4 },  \n\t{ 0x00007434,\t17,\t1 },  \n\t{ 0x00007434,\t18,\t7 },  \n\t{ 0x00007068,\t0,\t9 },  \n\t{ 0x0000410C,\t7,\t1 },  \n\t{ 0x0000400C,\t0,\t7 },  \n\t{ 0x00004000,\t11,\t1 },  \n\t{ 0x00017040,\t0,\t8 },  \n\t{ 0x00017040,\t8,\t8 },  \n\t{ 0x00017040,\t16,\t8 },  \n\t{ 0x00017040,\t24,\t8 },  \n\t{ 0x00017044,\t0,\t24 },  \n};\n\nstatic const struct reg_sequence cs35l41_reva0_errata_patch[] = {\n\t{ 0x00003854,\t\t\t 0x05180240 },\n\t{ CS35L41_VIMON_SPKMON_RESYNC,\t 0x00000000 },\n\t{ 0x00004310,\t\t\t 0x00000000 },\n\t{ CS35L41_VPVBST_FS_SEL,\t 0x00000000 },\n\t{ CS35L41_OTP_TRIM_30,\t\t 0x9091A1C8 },\n\t{ 0x00003014,\t\t\t 0x0200EE0E },\n\t{ CS35L41_BSTCVRT_DCM_CTRL,\t 0x00000051 },\n\t{ 0x00000054,\t\t\t 0x00000004 },\n\t{ CS35L41_IRQ1_DB3,\t\t 0x00000000 },\n\t{ CS35L41_IRQ2_DB3,\t\t 0x00000000 },\n\t{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_PWR_CTRL2,\t\t 0x00000000 },\n\t{ CS35L41_AMP_GAIN_CTRL,\t 0x00000000 },\n\t{ CS35L41_ASP_TX3_SRC,\t\t 0x00000000 },\n\t{ CS35L41_ASP_TX4_SRC,\t\t 0x00000000 },\n};\n\nstatic const struct reg_sequence cs35l41_revb0_errata_patch[] = {\n\t{ CS35L41_VIMON_SPKMON_RESYNC,\t 0x00000000 },\n\t{ 0x00004310,\t\t\t 0x00000000 },\n\t{ CS35L41_VPVBST_FS_SEL,\t 0x00000000 },\n\t{ CS35L41_BSTCVRT_DCM_CTRL,\t 0x00000051 },\n\t{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_PWR_CTRL2,\t\t 0x00000000 },\n\t{ CS35L41_AMP_GAIN_CTRL,\t 0x00000000 },\n\t{ CS35L41_ASP_TX3_SRC,\t\t 0x00000000 },\n\t{ CS35L41_ASP_TX4_SRC,\t\t 0x00000000 },\n};\n\nstatic const struct reg_sequence cs35l41_revb2_errata_patch[] = {\n\t{ CS35L41_VIMON_SPKMON_RESYNC,\t 0x00000000 },\n\t{ 0x00004310,\t\t\t 0x00000000 },\n\t{ CS35L41_VPVBST_FS_SEL,\t 0x00000000 },\n\t{ CS35L41_BSTCVRT_DCM_CTRL,\t 0x00000051 },\n\t{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },\n\t{ CS35L41_PWR_CTRL2,\t\t 0x00000000 },\n\t{ CS35L41_AMP_GAIN_CTRL,\t 0x00000000 },\n\t{ CS35L41_ASP_TX3_SRC,\t\t 0x00000000 },\n\t{ CS35L41_ASP_TX4_SRC,\t\t 0x00000000 },\n};\n\nstatic const struct reg_sequence cs35l41_fs_errata_patch[] = {\n\t{ CS35L41_DSP1_RX1_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX2_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX3_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX4_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX5_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX6_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX7_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_RX8_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX1_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX2_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX3_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX4_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX5_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX6_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX7_RATE,\t0x00000001 },\n\t{ CS35L41_DSP1_TX8_RATE,\t0x00000001 },\n};\n\nstatic const struct cs35l41_otp_map_element_t cs35l41_otp_map_map[] = {\n\t{\n\t\t.id = 0x01,\n\t\t.map = otp_map_1,\n\t\t.num_elements = ARRAY_SIZE(otp_map_1),\n\t\t.bit_offset = 16,\n\t\t.word_offset = 2,\n\t},\n\t{\n\t\t.id = 0x02,\n\t\t.map = otp_map_2,\n\t\t.num_elements = ARRAY_SIZE(otp_map_2),\n\t\t.bit_offset = 16,\n\t\t.word_offset = 2,\n\t},\n\t{\n\t\t.id = 0x03,\n\t\t.map = otp_map_2,\n\t\t.num_elements = ARRAY_SIZE(otp_map_2),\n\t\t.bit_offset = 16,\n\t\t.word_offset = 2,\n\t},\n\t{\n\t\t.id = 0x06,\n\t\t.map = otp_map_2,\n\t\t.num_elements = ARRAY_SIZE(otp_map_2),\n\t\t.bit_offset = 16,\n\t\t.word_offset = 2,\n\t},\n\t{\n\t\t.id = 0x08,\n\t\t.map = otp_map_1,\n\t\t.num_elements = ARRAY_SIZE(otp_map_1),\n\t\t.bit_offset = 16,\n\t\t.word_offset = 2,\n\t},\n};\n\nstruct regmap_config cs35l41_regmap_i2c = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = CS35L41_REGSTRIDE,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = CS35L41_LASTREG,\n\t.reg_defaults = cs35l41_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),\n\t.volatile_reg = cs35l41_volatile_reg,\n\t.readable_reg = cs35l41_readable_reg,\n\t.precious_reg = cs35l41_precious_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(cs35l41_regmap_i2c);\n\nstruct regmap_config cs35l41_regmap_spi = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.pad_bits = 16,\n\t.reg_stride = CS35L41_REGSTRIDE,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = CS35L41_LASTREG,\n\t.reg_defaults = cs35l41_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),\n\t.volatile_reg = cs35l41_volatile_reg,\n\t.readable_reg = cs35l41_readable_reg,\n\t.precious_reg = cs35l41_precious_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(cs35l41_regmap_spi);\n\nstatic const struct cs35l41_otp_map_element_t *cs35l41_find_otp_map(u32 otp_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l41_otp_map_map); i++) {\n\t\tif (cs35l41_otp_map_map[i].id == otp_id)\n\t\t\treturn &cs35l41_otp_map_map[i];\n\t}\n\n\treturn NULL;\n}\n\nint cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap)\n{\n\tstatic const struct reg_sequence unlock[] = {\n\t\t{ CS35L41_TEST_KEY_CTL, 0x00000055 },\n\t\t{ CS35L41_TEST_KEY_CTL, 0x000000AA },\n\t};\n\tint ret;\n\n\tret = regmap_multi_reg_write(regmap, unlock, ARRAY_SIZE(unlock));\n\tif (ret)\n\t\tdev_err(dev, \"Failed to unlock test key: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_test_key_unlock);\n\nint cs35l41_test_key_lock(struct device *dev, struct regmap *regmap)\n{\n\tstatic const struct reg_sequence unlock[] = {\n\t\t{ CS35L41_TEST_KEY_CTL, 0x000000CC },\n\t\t{ CS35L41_TEST_KEY_CTL, 0x00000033 },\n\t};\n\tint ret;\n\n\tret = regmap_multi_reg_write(regmap, unlock, ARRAY_SIZE(unlock));\n\tif (ret)\n\t\tdev_err(dev, \"Failed to lock test key: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_test_key_lock);\n\n \nint cs35l41_otp_unpack(struct device *dev, struct regmap *regmap)\n{\n\tconst struct cs35l41_otp_map_element_t *otp_map_match;\n\tconst struct cs35l41_otp_packed_element_t *otp_map;\n\tint bit_offset, word_offset, ret, i;\n\tunsigned int bit_sum = 8;\n\tu32 otp_val, otp_id_reg;\n\tu32 *otp_mem;\n\n\totp_mem = kmalloc_array(CS35L41_OTP_SIZE_WORDS, sizeof(*otp_mem), GFP_KERNEL);\n\tif (!otp_mem)\n\t\treturn -ENOMEM;\n\n\tret = regmap_read(regmap, CS35L41_OTPID, &otp_id_reg);\n\tif (ret) {\n\t\tdev_err(dev, \"Read OTP ID failed: %d\\n\", ret);\n\t\tgoto err_otp_unpack;\n\t}\n\n\totp_map_match = cs35l41_find_otp_map(otp_id_reg);\n\n\tif (!otp_map_match) {\n\t\tdev_err(dev, \"OTP Map matching ID %d not found\\n\", otp_id_reg);\n\t\tret = -EINVAL;\n\t\tgoto err_otp_unpack;\n\t}\n\n\tret = regmap_bulk_read(regmap, CS35L41_OTP_MEM0, otp_mem, CS35L41_OTP_SIZE_WORDS);\n\tif (ret) {\n\t\tdev_err(dev, \"Read OTP Mem failed: %d\\n\", ret);\n\t\tgoto err_otp_unpack;\n\t}\n\n\totp_map = otp_map_match->map;\n\n\tbit_offset = otp_map_match->bit_offset;\n\tword_offset = otp_map_match->word_offset;\n\n\tfor (i = 0; i < otp_map_match->num_elements; i++) {\n\t\tdev_dbg(dev, \"bitoffset= %d, word_offset=%d, bit_sum mod 32=%d, otp_map[i].size = %u\\n\",\n\t\t\tbit_offset, word_offset, bit_sum % 32, otp_map[i].size);\n\t\tif (bit_offset + otp_map[i].size - 1 >= 32) {\n\t\t\totp_val = (otp_mem[word_offset] &\n\t\t\t\t\tGENMASK(31, bit_offset)) >> bit_offset;\n\t\t\totp_val |= (otp_mem[++word_offset] &\n\t\t\t\t\tGENMASK(bit_offset + otp_map[i].size - 33, 0)) <<\n\t\t\t\t\t(32 - bit_offset);\n\t\t\tbit_offset += otp_map[i].size - 32;\n\t\t} else if (bit_offset + otp_map[i].size - 1 >= 0) {\n\t\t\totp_val = (otp_mem[word_offset] &\n\t\t\t\t   GENMASK(bit_offset + otp_map[i].size - 1, bit_offset)\n\t\t\t\t  ) >> bit_offset;\n\t\t\tbit_offset += otp_map[i].size;\n\t\t} else  \n\t\t\totp_val = 0;\n\n\t\tbit_sum += otp_map[i].size;\n\n\t\tif (bit_offset == 32) {\n\t\t\tbit_offset = 0;\n\t\t\tword_offset++;\n\t\t}\n\n\t\tif (otp_map[i].reg != 0) {\n\t\t\tret = regmap_update_bits(regmap, otp_map[i].reg,\n\t\t\t\t\t\t GENMASK(otp_map[i].shift + otp_map[i].size - 1,\n\t\t\t\t\t\t\t otp_map[i].shift),\n\t\t\t\t\t\t otp_val << otp_map[i].shift);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Write OTP val failed: %d\\n\", ret);\n\t\t\t\tgoto err_otp_unpack;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = 0;\n\nerr_otp_unpack:\n\tkfree(otp_mem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_otp_unpack);\n\n \nint cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid)\n{\n\tchar *rev;\n\tint ret;\n\n\tswitch (reg_revid) {\n\tcase CS35L41_REVID_A0:\n\t\tret = regmap_register_patch(reg, cs35l41_reva0_errata_patch,\n\t\t\t\t\t    ARRAY_SIZE(cs35l41_reva0_errata_patch));\n\t\trev = \"A0\";\n\t\tbreak;\n\tcase CS35L41_REVID_B0:\n\t\tret = regmap_register_patch(reg, cs35l41_revb0_errata_patch,\n\t\t\t\t\t    ARRAY_SIZE(cs35l41_revb0_errata_patch));\n\t\trev = \"B0\";\n\t\tbreak;\n\tcase CS35L41_REVID_B2:\n\t\tret = regmap_register_patch(reg, cs35l41_revb2_errata_patch,\n\t\t\t\t\t    ARRAY_SIZE(cs35l41_revb2_errata_patch));\n\t\trev = \"B2\";\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\trev = \"XX\";\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to apply %s errata patch: %d\\n\", rev, ret);\n\n\tret = regmap_write(reg, CS35L41_DSP1_CCM_CORE_CTRL, 0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Write CCM_CORE_CTRL failed: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_register_errata_patch);\n\nint cs35l41_set_channels(struct device *dev, struct regmap *reg,\n\t\t\t unsigned int tx_num, unsigned int *tx_slot,\n\t\t\t unsigned int rx_num, unsigned int *rx_slot)\n{\n\tunsigned int val, mask;\n\tint i;\n\n\tif (tx_num > 4 || rx_num > 2)\n\t\treturn -EINVAL;\n\n\tval = 0;\n\tmask = 0;\n\tfor (i = 0; i < rx_num; i++) {\n\t\tdev_dbg(dev, \"rx slot %d position = %d\\n\", i, rx_slot[i]);\n\t\tval |= rx_slot[i] << (i * 8);\n\t\tmask |= 0x3F << (i * 8);\n\t}\n\tregmap_update_bits(reg, CS35L41_SP_FRAME_RX_SLOT, mask, val);\n\n\tval = 0;\n\tmask = 0;\n\tfor (i = 0; i < tx_num; i++) {\n\t\tdev_dbg(dev, \"tx slot %d position = %d\\n\", i, tx_slot[i]);\n\t\tval |= tx_slot[i] << (i * 8);\n\t\tmask |= 0x3F << (i * 8);\n\t}\n\tregmap_update_bits(reg, CS35L41_SP_FRAME_TX_SLOT, mask, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l41_set_channels);\n\nstatic const unsigned char cs35l41_bst_k1_table[4][5] = {\n\t{ 0x24, 0x32, 0x32, 0x4F, 0x57 },\n\t{ 0x24, 0x32, 0x32, 0x4F, 0x57 },\n\t{ 0x40, 0x32, 0x32, 0x4F, 0x57 },\n\t{ 0x40, 0x32, 0x32, 0x4F, 0x57 }\n};\n\nstatic const unsigned char cs35l41_bst_k2_table[4][5] = {\n\t{ 0x24, 0x49, 0x66, 0xA3, 0xEA },\n\t{ 0x24, 0x49, 0x66, 0xA3, 0xEA },\n\t{ 0x48, 0x49, 0x66, 0xA3, 0xEA },\n\t{ 0x48, 0x49, 0x66, 0xA3, 0xEA }\n};\n\nstatic const unsigned char cs35l41_bst_slope_table[4] = {\n\t0x75, 0x6B, 0x3B, 0x28\n};\n\nstatic int cs35l41_boost_config(struct device *dev, struct regmap *regmap, int boost_ind,\n\t\t\t\tint boost_cap, int boost_ipk)\n{\n\tunsigned char bst_lbst_val, bst_cbst_range, bst_ipk_scaled;\n\tint ret;\n\n\tswitch (boost_ind) {\n\tcase 1000:\t \n\t\tbst_lbst_val = 0;\n\t\tbreak;\n\tcase 1200:\t \n\t\tbst_lbst_val = 1;\n\t\tbreak;\n\tcase 1500:\t \n\t\tbst_lbst_val = 2;\n\t\tbreak;\n\tcase 2200:\t \n\t\tbst_lbst_val = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid boost inductor value: %d nH\\n\", boost_ind);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (boost_cap) {\n\tcase 0 ... 19:\n\t\tbst_cbst_range = 0;\n\t\tbreak;\n\tcase 20 ... 50:\n\t\tbst_cbst_range = 1;\n\t\tbreak;\n\tcase 51 ... 100:\n\t\tbst_cbst_range = 2;\n\t\tbreak;\n\tcase 101 ... 200:\n\t\tbst_cbst_range = 3;\n\t\tbreak;\n\tdefault:\n\t\tif (boost_cap < 0) {\n\t\t\tdev_err(dev, \"Invalid boost capacitor value: %d nH\\n\", boost_cap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tbst_cbst_range = 4;\n\t}\n\n\tif (boost_ipk < 1600 || boost_ipk > 4500) {\n\t\tdev_err(dev, \"Invalid boost inductor peak current: %d mA\\n\", boost_ipk);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(regmap, CS35L41_BSTCVRT_COEFF,\n\t\t\t\t CS35L41_BST_K1_MASK | CS35L41_BST_K2_MASK,\n\t\t\t\t cs35l41_bst_k1_table[bst_lbst_val][bst_cbst_range]\n\t\t\t\t\t<< CS35L41_BST_K1_SHIFT |\n\t\t\t\t cs35l41_bst_k2_table[bst_lbst_val][bst_cbst_range]\n\t\t\t\t\t<< CS35L41_BST_K2_SHIFT);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write boost coefficients: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(regmap, CS35L41_BSTCVRT_SLOPE_LBST,\n\t\t\t\t CS35L41_BST_SLOPE_MASK | CS35L41_BST_LBST_VAL_MASK,\n\t\t\t\t cs35l41_bst_slope_table[bst_lbst_val]\n\t\t\t\t\t<< CS35L41_BST_SLOPE_SHIFT |\n\t\t\t\t bst_lbst_val << CS35L41_BST_LBST_VAL_SHIFT);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write boost slope/inductor value: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbst_ipk_scaled = ((boost_ipk - 1600) / 50) + 0x10;\n\n\tret = regmap_update_bits(regmap, CS35L41_BSTCVRT_PEAK_CUR, CS35L41_BST_IPK_MASK,\n\t\t\t\t bst_ipk_scaled << CS35L41_BST_IPK_SHIFT);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to write boost inductor peak current: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_update_bits(regmap, CS35L41_PWR_CTRL2, CS35L41_BST_EN_MASK,\n\t\t\t   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence cs35l41_safe_to_reset[] = {\n\t{ 0x00000040,\t\t\t0x00000055 },\n\t{ 0x00000040,\t\t\t0x000000AA },\n\t{ 0x0000393C,\t\t\t0x000000C0, 6000},\n\t{ 0x0000393C,\t\t\t0x00000000 },\n\t{ 0x00007414,\t\t\t0x00C82222 },\n\t{ 0x0000742C,\t\t\t0x00000000 },\n\t{ 0x00000040,\t\t\t0x000000CC },\n\t{ 0x00000040,\t\t\t0x00000033 },\n};\n\nstatic const struct reg_sequence cs35l41_active_to_safe_start[] = {\n\t{ 0x00000040,\t\t\t0x00000055 },\n\t{ 0x00000040,\t\t\t0x000000AA },\n\t{ 0x00007438,\t\t\t0x00585941 },\n\t{ CS35L41_PWR_CTRL1,\t\t0x00000000 },\n\t{ 0x0000742C,\t\t\t0x00000009 },\n};\n\nstatic const struct reg_sequence cs35l41_active_to_safe_end[] = {\n\t{ 0x00007438,\t\t\t0x00580941 },\n\t{ 0x00000040,\t\t\t0x000000CC },\n\t{ 0x00000040,\t\t\t0x00000033 },\n};\n\nstatic const struct reg_sequence cs35l41_safe_to_active_start[] = {\n\t{ 0x00000040,\t\t\t0x00000055 },\n\t{ 0x00000040,\t\t\t0x000000AA },\n\t{ 0x0000742C,\t\t\t0x0000000F },\n\t{ 0x0000742C,\t\t\t0x00000079 },\n\t{ 0x00007438,\t\t\t0x00585941 },\n\t{ CS35L41_PWR_CTRL1,\t\t0x00000001 }, \n};\n\nstatic const struct reg_sequence cs35l41_safe_to_active_en_spk[] = {\n\t{ 0x0000742C,\t\t\t0x000000F9 },\n\t{ 0x00007438,\t\t\t0x00580941 },\n};\n\nstatic const struct reg_sequence cs35l41_reset_to_safe[] = {\n\t{ 0x00000040,\t\t\t0x00000055 },\n\t{ 0x00000040,\t\t\t0x000000AA },\n\t{ 0x00007438,\t\t\t0x00585941 },\n\t{ 0x00007414,\t\t\t0x08C82222 },\n\t{ 0x0000742C,\t\t\t0x00000009 },\n\t{ 0x00000040,\t\t\t0x000000CC },\n\t{ 0x00000040,\t\t\t0x00000033 },\n};\n\nstatic const struct reg_sequence cs35l41_actv_seq[] = {\n\t \n\t{CS35L41_MDSYNC_EN,        0x00003000},\n\t \n\t{CS35L41_BSTCVRT_VCTRL2,    0x00000002},\n};\n\nstatic const struct reg_sequence cs35l41_pass_seq[] = {\n\t \n\t{CS35L41_MDSYNC_EN,        0x00001000},\n\t \n\t{CS35L41_PWR_CTRL2,        0x00003300},\n\t \n\t{CS35L41_BSTCVRT_VCTRL2,    0x00000002},\n};\n\nint cs35l41_init_boost(struct device *dev, struct regmap *regmap,\n\t\t       struct cs35l41_hw_cfg *hw_cfg)\n{\n\tint ret;\n\n\tswitch (hw_cfg->bst_type) {\n\tcase CS35L41_SHD_BOOST_ACTV:\n\t\tregmap_multi_reg_write(regmap, cs35l41_actv_seq, ARRAY_SIZE(cs35l41_actv_seq));\n\t\tfallthrough;\n\tcase CS35L41_INT_BOOST:\n\t\tret = cs35l41_boost_config(dev, regmap, hw_cfg->bst_ind,\n\t\t\t\t\t   hw_cfg->bst_cap, hw_cfg->bst_ipk);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Error in Boost DT config: %d\\n\", ret);\n\t\tbreak;\n\tcase CS35L41_EXT_BOOST:\n\tcase CS35L41_EXT_BOOST_NO_VSPK_SWITCH:\n\t\t \n\t\tregmap_write(regmap, CS35L41_GPIO1_CTRL1, 0x00000001);\n\t\tregmap_multi_reg_write(regmap, cs35l41_reset_to_safe,\n\t\t\t\t       ARRAY_SIZE(cs35l41_reset_to_safe));\n\t\tret = regmap_update_bits(regmap, CS35L41_PWR_CTRL2, CS35L41_BST_EN_MASK,\n\t\t\t\t\t CS35L41_BST_DIS_FET_OFF << CS35L41_BST_EN_SHIFT);\n\t\tbreak;\n\tcase CS35L41_SHD_BOOST_PASS:\n\t\tret = regmap_multi_reg_write(regmap, cs35l41_pass_seq,\n\t\t\t\t\t     ARRAY_SIZE(cs35l41_pass_seq));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Boost type %d not supported\\n\", hw_cfg->bst_type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_init_boost);\n\nbool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type)\n{\n\tswitch (b_type) {\n\t \n\tcase CS35L41_EXT_BOOST_NO_VSPK_SWITCH:\n\t\treturn false;\n\tcase CS35L41_EXT_BOOST:\n\t\tregmap_write(regmap, CS35L41_GPIO1_CTRL1, 0x00000001);\n\t\tregmap_multi_reg_write(regmap, cs35l41_safe_to_reset,\n\t\t\t\t       ARRAY_SIZE(cs35l41_safe_to_reset));\n\t\treturn true;\n\tdefault:\n\t\treturn true;\n\t}\n}\nEXPORT_SYMBOL_GPL(cs35l41_safe_reset);\n\n \nint cs35l41_global_enable(struct device *dev, struct regmap *regmap, enum cs35l41_boost_type b_type,\n\t\t\t  int enable, bool firmware_running)\n{\n\tint ret;\n\tunsigned int gpio1_func, pad_control, pwr_ctrl1, pwr_ctrl3, int_status, pup_pdn_mask;\n\tunsigned int pwr_ctl1_val;\n\tstruct reg_sequence cs35l41_mdsync_down_seq[] = {\n\t\t{CS35L41_PWR_CTRL3,\t\t0},\n\t\t{CS35L41_GPIO_PAD_CONTROL,\t0},\n\t\t{CS35L41_PWR_CTRL1,\t\t0, 3000},\n\t};\n\n\tpup_pdn_mask = enable ? CS35L41_PUP_DONE_MASK : CS35L41_PDN_DONE_MASK;\n\n\tret = regmap_read(regmap, CS35L41_PWR_CTRL1, &pwr_ctl1_val);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((pwr_ctl1_val & CS35L41_GLOBAL_EN_MASK) && enable) {\n\t\tdev_dbg(dev, \"Cannot set Global Enable - already set.\\n\");\n\t\treturn 0;\n\t} else if (!(pwr_ctl1_val & CS35L41_GLOBAL_EN_MASK) && !enable) {\n\t\tdev_dbg(dev, \"Cannot unset Global Enable - not set.\\n\");\n\t\treturn 0;\n\t}\n\n\tswitch (b_type) {\n\tcase CS35L41_SHD_BOOST_ACTV:\n\tcase CS35L41_SHD_BOOST_PASS:\n\t\tregmap_read(regmap, CS35L41_PWR_CTRL3, &pwr_ctrl3);\n\t\tregmap_read(regmap, CS35L41_GPIO_PAD_CONTROL, &pad_control);\n\n\t\tpwr_ctrl3 &= ~CS35L41_SYNC_EN_MASK;\n\t\tpwr_ctrl1 = enable << CS35L41_GLOBAL_EN_SHIFT;\n\n\t\tgpio1_func = enable ? CS35L41_GPIO1_MDSYNC : CS35L41_GPIO1_HIZ;\n\t\tgpio1_func <<= CS35L41_GPIO1_CTRL_SHIFT;\n\n\t\tpad_control &= ~CS35L41_GPIO1_CTRL_MASK;\n\t\tpad_control |= gpio1_func & CS35L41_GPIO1_CTRL_MASK;\n\n\t\tcs35l41_mdsync_down_seq[0].def = pwr_ctrl3;\n\t\tcs35l41_mdsync_down_seq[1].def = pad_control;\n\t\tcs35l41_mdsync_down_seq[2].def = pwr_ctrl1;\n\n\t\tret = regmap_multi_reg_write(regmap, cs35l41_mdsync_down_seq,\n\t\t\t\t\t     ARRAY_SIZE(cs35l41_mdsync_down_seq));\n\t\t \n\t\tif (ret || enable)\n\t\t\treturn ret;\n\n\t\tret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1,\n\t\t\t\t\tint_status, int_status & pup_pdn_mask,\n\t\t\t\t\t1000, 100000);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Enable(%d) failed: %d\\n\", enable, ret);\n\n\t\t \n\t\tregmap_write(regmap, CS35L41_IRQ1_STATUS1, pup_pdn_mask);\n\t\tbreak;\n\tcase CS35L41_INT_BOOST:\n\t\tret = regmap_update_bits(regmap, CS35L41_PWR_CTRL1, CS35L41_GLOBAL_EN_MASK,\n\t\t\t\t\t enable << CS35L41_GLOBAL_EN_SHIFT);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"CS35L41_PWR_CTRL1 set failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1,\n\t\t\t\t\tint_status, int_status & pup_pdn_mask,\n\t\t\t\t\t1000, 100000);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Enable(%d) failed: %d\\n\", enable, ret);\n\n\t\t \n\t\tregmap_write(regmap, CS35L41_IRQ1_STATUS1, pup_pdn_mask);\n\t\tbreak;\n\tcase CS35L41_EXT_BOOST:\n\tcase CS35L41_EXT_BOOST_NO_VSPK_SWITCH:\n\t\tif (enable) {\n\t\t\t \n\t\t\tret = regmap_multi_reg_write(regmap, cs35l41_safe_to_active_start,\n\t\t\t\t\t\t     ARRAY_SIZE(cs35l41_safe_to_active_start));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1, int_status,\n\t\t\t\t       int_status & CS35L41_PUP_DONE_MASK, 1000, 100000);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed waiting for CS35L41_PUP_DONE_MASK: %d\\n\", ret);\n\t\t\t\t \n\t\t\t\tcs35l41_test_key_lock(dev, regmap);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tregmap_write(regmap, CS35L41_IRQ1_STATUS1, CS35L41_PUP_DONE_MASK);\n\n\t\t\tif (firmware_running)\n\t\t\t\tret = cs35l41_set_cspl_mbox_cmd(dev, regmap,\n\t\t\t\t\t\t\t\tCSPL_MBOX_CMD_SPK_OUT_ENABLE);\n\t\t\telse\n\t\t\t\tret = regmap_multi_reg_write(regmap, cs35l41_safe_to_active_en_spk,\n\t\t\t\t\t\t\tARRAY_SIZE(cs35l41_safe_to_active_en_spk));\n\n\t\t\t \n\t\t\tcs35l41_test_key_lock(dev, regmap);\n\t\t} else {\n\t\t\t \n\t\t\tret = regmap_multi_reg_write(regmap, cs35l41_active_to_safe_start,\n\t\t\t\t\t\t     ARRAY_SIZE(cs35l41_active_to_safe_start));\n\t\t\tif (ret) {\n\t\t\t\t \n\t\t\t\tcs35l41_test_key_lock(dev, regmap);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = regmap_read_poll_timeout(regmap, CS35L41_IRQ1_STATUS1, int_status,\n\t\t\t\t       int_status & CS35L41_PDN_DONE_MASK, 1000, 100000);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed waiting for CS35L41_PDN_DONE_MASK: %d\\n\", ret);\n\t\t\t\t \n\t\t\t\tcs35l41_test_key_lock(dev, regmap);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tregmap_write(regmap, CS35L41_IRQ1_STATUS1, CS35L41_PDN_DONE_MASK);\n\n\t\t\t \n\t\t\tret = regmap_multi_reg_write(regmap, cs35l41_active_to_safe_end,\n\t\t\t\t\t\t     ARRAY_SIZE(cs35l41_active_to_safe_end));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_global_enable);\n\n \nint cs35l41_mdsync_up(struct regmap *regmap)\n{\n\treturn regmap_update_bits(regmap, CS35L41_PWR_CTRL3,\n\t\t\t\t  CS35L41_SYNC_EN_MASK, CS35L41_SYNC_EN_MASK);\n}\nEXPORT_SYMBOL_GPL(cs35l41_mdsync_up);\n\nint cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg)\n{\n\tstruct cs35l41_gpio_cfg *gpio1 = &hw_cfg->gpio1;\n\tstruct cs35l41_gpio_cfg *gpio2 = &hw_cfg->gpio2;\n\tint irq_pol = IRQF_TRIGGER_NONE;\n\n\tregmap_update_bits(regmap, CS35L41_GPIO1_CTRL1,\n\t\t\t   CS35L41_GPIO_POL_MASK | CS35L41_GPIO_DIR_MASK,\n\t\t\t   gpio1->pol_inv << CS35L41_GPIO_POL_SHIFT |\n\t\t\t   !gpio1->out_en << CS35L41_GPIO_DIR_SHIFT);\n\n\tregmap_update_bits(regmap, CS35L41_GPIO2_CTRL1,\n\t\t\t   CS35L41_GPIO_POL_MASK | CS35L41_GPIO_DIR_MASK,\n\t\t\t   gpio2->pol_inv << CS35L41_GPIO_POL_SHIFT |\n\t\t\t   !gpio2->out_en << CS35L41_GPIO_DIR_SHIFT);\n\n\tif (gpio1->valid)\n\t\tregmap_update_bits(regmap, CS35L41_GPIO_PAD_CONTROL, CS35L41_GPIO1_CTRL_MASK,\n\t\t\t\t   gpio1->func << CS35L41_GPIO1_CTRL_SHIFT);\n\n\tif (gpio2->valid) {\n\t\tregmap_update_bits(regmap, CS35L41_GPIO_PAD_CONTROL, CS35L41_GPIO2_CTRL_MASK,\n\t\t\t\t   gpio2->func << CS35L41_GPIO2_CTRL_SHIFT);\n\n\t\tswitch (gpio2->func) {\n\t\tcase CS35L41_GPIO2_INT_PUSH_PULL_LOW:\n\t\tcase CS35L41_GPIO2_INT_OPEN_DRAIN:\n\t\t\tirq_pol = IRQF_TRIGGER_LOW;\n\t\t\tbreak;\n\t\tcase CS35L41_GPIO2_INT_PUSH_PULL_HIGH:\n\t\t\tirq_pol = IRQF_TRIGGER_HIGH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn irq_pol;\n}\nEXPORT_SYMBOL_GPL(cs35l41_gpio_config);\n\nstatic const struct cs_dsp_region cs35l41_dsp1_regions[] = {\n\t{ .type = WMFW_HALO_PM_PACKED,\t.base = CS35L41_DSP1_PMEM_0 },\n\t{ .type = WMFW_HALO_XM_PACKED,\t.base = CS35L41_DSP1_XMEM_PACK_0 },\n\t{ .type = WMFW_HALO_YM_PACKED,\t.base = CS35L41_DSP1_YMEM_PACK_0 },\n\t{. type = WMFW_ADSP2_XM,\t.base = CS35L41_DSP1_XMEM_UNPACK24_0},\n\t{. type = WMFW_ADSP2_YM,\t.base = CS35L41_DSP1_YMEM_UNPACK24_0},\n};\n\nvoid cs35l41_configure_cs_dsp(struct device *dev, struct regmap *reg, struct cs_dsp *dsp)\n{\n\tdsp->num = 1;\n\tdsp->type = WMFW_HALO;\n\tdsp->rev = 0;\n\tdsp->dev = dev;\n\tdsp->regmap = reg;\n\tdsp->base = CS35L41_DSP1_CTRL_BASE;\n\tdsp->base_sysinfo = CS35L41_DSP1_SYS_ID;\n\tdsp->mem = cs35l41_dsp1_regions;\n\tdsp->num_mems = ARRAY_SIZE(cs35l41_dsp1_regions);\n\tdsp->lock_regions = 0xFFFFFFFF;\n}\nEXPORT_SYMBOL_GPL(cs35l41_configure_cs_dsp);\n\nstatic bool cs35l41_check_cspl_mbox_sts(enum cs35l41_cspl_mbox_cmd cmd,\n\t\t\t\t\tenum cs35l41_cspl_mbox_status sts)\n{\n\tswitch (cmd) {\n\tcase CSPL_MBOX_CMD_NONE:\n\tcase CSPL_MBOX_CMD_UNKNOWN_CMD:\n\t\treturn true;\n\tcase CSPL_MBOX_CMD_PAUSE:\n\tcase CSPL_MBOX_CMD_OUT_OF_HIBERNATE:\n\t\treturn (sts == CSPL_MBOX_STS_PAUSED);\n\tcase CSPL_MBOX_CMD_RESUME:\n\t\treturn (sts == CSPL_MBOX_STS_RUNNING);\n\tcase CSPL_MBOX_CMD_REINIT:\n\t\treturn (sts == CSPL_MBOX_STS_RUNNING);\n\tcase CSPL_MBOX_CMD_STOP_PRE_REINIT:\n\t\treturn (sts == CSPL_MBOX_STS_RDY_FOR_REINIT);\n\tcase CSPL_MBOX_CMD_SPK_OUT_ENABLE:\n\t\treturn (sts == CSPL_MBOX_STS_RUNNING);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,\n\t\t\t      enum cs35l41_cspl_mbox_cmd cmd)\n{\n\tunsigned int sts = 0, i;\n\tint ret;\n\n\t\n\tret = regmap_write(regmap, CS35L41_DSP_VIRT1_MBOX_1, cmd);\n\tif (ret < 0) {\n\t\tif (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)\n\t\t\tdev_err(dev, \"Failed to write MBOX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t\n\tfor (i = 0; i < 5; i++) {\n\t\tusleep_range(1000, 1100);\n\n\t\tret = regmap_read(regmap, CS35L41_DSP_MBOX_2, &sts);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to read MBOX STS: %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cs35l41_check_cspl_mbox_sts(cmd, sts))\n\t\t\tdev_dbg(dev, \"[%u] cmd %u returned invalid sts %u\", i, cmd, sts);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)\n\t\tdev_err(dev, \"Failed to set mailbox cmd %u (status %u)\\n\", cmd, sts);\n\n\treturn -ENOMSG;\n}\nEXPORT_SYMBOL_GPL(cs35l41_set_cspl_mbox_cmd);\n\nint cs35l41_write_fs_errata(struct device *dev, struct regmap *regmap)\n{\n\tint ret;\n\n\tret = regmap_multi_reg_write(regmap, cs35l41_fs_errata_patch,\n\t\t\t\t     ARRAY_SIZE(cs35l41_fs_errata_patch));\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to write fs errata: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_write_fs_errata);\n\nint cs35l41_enter_hibernate(struct device *dev, struct regmap *regmap,\n\t\t\t    enum cs35l41_boost_type b_type)\n{\n\tif (!cs35l41_safe_reset(regmap, b_type)) {\n\t\tdev_dbg(dev, \"System does not support Suspend\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"Enter hibernate\\n\");\n\tregmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0088);\n\tregmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0188);\n\n\t\n\tregmap_write(regmap, CS35L41_DSP_VIRT1_MBOX_1, CSPL_MBOX_CMD_HIBERNATE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l41_enter_hibernate);\n\nstatic void cs35l41_wait_for_pwrmgt_sts(struct device *dev, struct regmap *regmap)\n{\n\tconst int pwrmgt_retries = 10;\n\tunsigned int sts;\n\tint i, ret;\n\n\tfor (i = 0; i < pwrmgt_retries; i++) {\n\t\tret = regmap_read(regmap, CS35L41_PWRMGT_STS, &sts);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to read PWRMGT_STS: %d\\n\", ret);\n\t\telse if (!(sts & CS35L41_WR_PEND_STS_MASK))\n\t\t\treturn;\n\n\t\tudelay(20);\n\t}\n\n\tdev_err(dev, \"Timed out reading PWRMGT_STS\\n\");\n}\n\nint cs35l41_exit_hibernate(struct device *dev, struct regmap *regmap)\n{\n\tconst int wake_retries = 20;\n\tconst int sleep_retries = 5;\n\tint ret, i, j;\n\n\tfor (i = 0; i < sleep_retries; i++) {\n\t\tdev_dbg(dev, \"Exit hibernate\\n\");\n\n\t\tfor (j = 0; j < wake_retries; j++) {\n\t\t\tret = cs35l41_set_cspl_mbox_cmd(dev, regmap,\n\t\t\t\t\t\t\tCSPL_MBOX_CMD_OUT_OF_HIBERNATE);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(100, 200);\n\t\t}\n\n\t\tif (j < wake_retries) {\n\t\t\tdev_dbg(dev, \"Wake success at cycle: %d\\n\", j);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_err(dev, \"Wake failed, re-enter hibernate: %d\\n\", ret);\n\n\t\tcs35l41_wait_for_pwrmgt_sts(dev, regmap);\n\t\tregmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0088);\n\n\t\tcs35l41_wait_for_pwrmgt_sts(dev, regmap);\n\t\tregmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0188);\n\n\t\tcs35l41_wait_for_pwrmgt_sts(dev, regmap);\n\t\tregmap_write(regmap, CS35L41_PWRMGT_CTL, 0x3);\n\t}\n\n\tdev_err(dev, \"Timed out waking device\\n\");\n\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_GPL(cs35l41_exit_hibernate);\n\nMODULE_DESCRIPTION(\"CS35L41 library\");\nMODULE_AUTHOR(\"David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>\");\nMODULE_AUTHOR(\"Lucas Tanure, Cirrus Logic Inc, <tanureal@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}