{
  "module_name": "tas2781-fmwlib.c",
  "hash_id": "e27eb9fd7cbad25a22d31a65d75eff33a95721e11106e110b61ebbc069036440",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2781-fmwlib.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/crc8.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/tas2781.h>\n\n\n#define ERROR_PRAM_CRCCHK\t\t\t0x0000000\n#define ERROR_YRAM_CRCCHK\t\t\t0x0000001\n#define\tPPC_DRIVER_CRCCHK\t\t\t0x00000200\n\n#define TAS2781_SA_COEFF_SWAP_REG\t\tTASDEVICE_REG(0, 0x35, 0x2c)\n#define TAS2781_YRAM_BOOK1\t\t\t140\n#define TAS2781_YRAM1_PAGE\t\t\t42\n#define TAS2781_YRAM1_START_REG\t\t\t88\n\n#define TAS2781_YRAM2_START_PAGE\t\t43\n#define TAS2781_YRAM2_END_PAGE\t\t\t49\n#define TAS2781_YRAM2_START_REG\t\t\t8\n#define TAS2781_YRAM2_END_REG\t\t\t127\n\n#define TAS2781_YRAM3_PAGE\t\t\t50\n#define TAS2781_YRAM3_START_REG\t\t\t8\n#define TAS2781_YRAM3_END_REG\t\t\t27\n\n \n#define TAS2781_YRAM_BOOK2\t\t\t0\n#define TAS2781_YRAM4_START_PAGE\t\t50\n#define TAS2781_YRAM4_END_PAGE\t\t\t60\n\n#define TAS2781_YRAM5_PAGE\t\t\t61\n#define TAS2781_YRAM5_START_REG\t\t\tTAS2781_YRAM3_START_REG\n#define TAS2781_YRAM5_END_REG\t\t\tTAS2781_YRAM3_END_REG\n\n#define TASDEVICE_MAXPROGRAM_NUM_KERNEL\t\t\t5\n#define TASDEVICE_MAXCONFIG_NUM_KERNEL_MULTIPLE_AMPS\t64\n#define TASDEVICE_MAXCONFIG_NUM_KERNEL\t\t\t10\n#define MAIN_ALL_DEVICES_1X\t\t\t\t0x01\n#define MAIN_DEVICE_A_1X\t\t\t\t0x02\n#define MAIN_DEVICE_B_1X\t\t\t\t0x03\n#define MAIN_DEVICE_C_1X\t\t\t\t0x04\n#define MAIN_DEVICE_D_1X\t\t\t\t0x05\n#define COEFF_DEVICE_A_1X\t\t\t\t0x12\n#define COEFF_DEVICE_B_1X\t\t\t\t0x13\n#define COEFF_DEVICE_C_1X\t\t\t\t0x14\n#define COEFF_DEVICE_D_1X\t\t\t\t0x15\n#define PRE_DEVICE_A_1X\t\t\t\t\t0x22\n#define PRE_DEVICE_B_1X\t\t\t\t\t0x23\n#define PRE_DEVICE_C_1X\t\t\t\t\t0x24\n#define PRE_DEVICE_D_1X\t\t\t\t\t0x25\n#define PRE_SOFTWARE_RESET_DEVICE_A\t\t\t0x41\n#define PRE_SOFTWARE_RESET_DEVICE_B\t\t\t0x42\n#define PRE_SOFTWARE_RESET_DEVICE_C\t\t\t0x43\n#define PRE_SOFTWARE_RESET_DEVICE_D\t\t\t0x44\n#define POST_SOFTWARE_RESET_DEVICE_A\t\t\t0x45\n#define POST_SOFTWARE_RESET_DEVICE_B\t\t\t0x46\n#define POST_SOFTWARE_RESET_DEVICE_C\t\t\t0x47\n#define POST_SOFTWARE_RESET_DEVICE_D\t\t\t0x48\n\nstruct tas_crc {\n\tunsigned char offset;\n\tunsigned char len;\n};\n\nstatic const char deviceNumber[TASDEVICE_DSP_TAS_MAX_DEVICE] = {\n\t1, 2, 1, 2, 1, 1, 0, 2, 4, 3, 1, 2, 3, 4\n};\n\nstatic struct tasdevice_config_info *tasdevice_add_config(\n\tstruct tasdevice_priv *tas_priv, unsigned char *config_data,\n\tunsigned int config_size, int *status)\n{\n\tstruct tasdevice_config_info *cfg_info;\n\tstruct tasdev_blk_data **bk_da;\n\tunsigned int config_offset = 0;\n\tunsigned int i;\n\n\t \n\tcfg_info = kzalloc(sizeof(struct tasdevice_config_info), GFP_KERNEL);\n\tif (!cfg_info) {\n\t\t*status = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tas_priv->rcabin.fw_hdr.binary_version_num >= 0x105) {\n\t\tif (config_offset + 64 > (int)config_size) {\n\t\t\t*status = -EINVAL;\n\t\t\tdev_err(tas_priv->dev, \"add conf: Out of boundary\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tconfig_offset += 64;\n\t}\n\n\tif (config_offset + 4 > (int)config_size) {\n\t\t*status = -EINVAL;\n\t\tdev_err(tas_priv->dev, \"add config: Out of boundary\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tcfg_info->nblocks =\n\t\tbe32_to_cpup((__be32 *)&config_data[config_offset]);\n\tconfig_offset += 4;\n\n\t \n\tbk_da = cfg_info->blk_data = kcalloc(cfg_info->nblocks,\n\t\tsizeof(struct tasdev_blk_data *), GFP_KERNEL);\n\tif (!bk_da) {\n\t\t*status = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcfg_info->real_nblocks = 0;\n\tfor (i = 0; i < cfg_info->nblocks; i++) {\n\t\tif (config_offset + 12 > config_size) {\n\t\t\t*status = -EINVAL;\n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"%s: Out of boundary: i = %d nblocks = %u!\\n\",\n\t\t\t\t__func__, i, cfg_info->nblocks);\n\t\t\tbreak;\n\t\t}\n\t\tbk_da[i] = kzalloc(sizeof(struct tasdev_blk_data), GFP_KERNEL);\n\t\tif (!bk_da[i]) {\n\t\t\t*status = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbk_da[i]->dev_idx = config_data[config_offset];\n\t\tconfig_offset++;\n\n\t\tbk_da[i]->block_type = config_data[config_offset];\n\t\tconfig_offset++;\n\n\t\tif (bk_da[i]->block_type == TASDEVICE_BIN_BLK_PRE_POWER_UP) {\n\t\t\tif (bk_da[i]->dev_idx == 0)\n\t\t\t\tcfg_info->active_dev =\n\t\t\t\t\t(1 << tas_priv->ndev) - 1;\n\t\t\telse\n\t\t\t\tcfg_info->active_dev |= 1 <<\n\t\t\t\t\t(bk_da[i]->dev_idx - 1);\n\n\t\t}\n\t\tbk_da[i]->yram_checksum =\n\t\t\tbe16_to_cpup((__be16 *)&config_data[config_offset]);\n\t\tconfig_offset += 2;\n\t\tbk_da[i]->block_size =\n\t\t\tbe32_to_cpup((__be32 *)&config_data[config_offset]);\n\t\tconfig_offset += 4;\n\n\t\tbk_da[i]->n_subblks =\n\t\t\tbe32_to_cpup((__be32 *)&config_data[config_offset]);\n\n\t\tconfig_offset += 4;\n\n\t\tif (config_offset + bk_da[i]->block_size > config_size) {\n\t\t\t*status = -EINVAL;\n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"%s: Out of boundary: i = %d blks = %u!\\n\",\n\t\t\t\t__func__, i, cfg_info->nblocks);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tbk_da[i]->regdata = kmemdup(&config_data[config_offset],\n\t\t\tbk_da[i]->block_size, GFP_KERNEL);\n\t\tif (!bk_da[i]->regdata) {\n\t\t\t*status = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tconfig_offset += bk_da[i]->block_size;\n\t\tcfg_info->real_nblocks += 1;\n\t}\n\nout:\n\treturn cfg_info;\n}\n\nint tasdevice_rca_parser(void *context, const struct firmware *fmw)\n{\n\tstruct tasdevice_priv *tas_priv = context;\n\tstruct tasdevice_config_info **cfg_info;\n\tstruct tasdevice_rca_hdr *fw_hdr;\n\tstruct tasdevice_rca *rca;\n\tunsigned int total_config_sz = 0;\n\tunsigned char *buf;\n\tint offset = 0;\n\tint ret = 0;\n\tint i;\n\n\trca = &(tas_priv->rcabin);\n\tfw_hdr = &(rca->fw_hdr);\n\tif (!fmw || !fmw->data) {\n\t\tdev_err(tas_priv->dev, \"Failed to read %s\\n\",\n\t\t\ttas_priv->rca_binaryname);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tbuf = (unsigned char *)fmw->data;\n\n\tfw_hdr->img_sz = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\tif (fw_hdr->img_sz != fmw->size) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"File size not match, %d %u\", (int)fmw->size,\n\t\t\tfw_hdr->img_sz);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfw_hdr->checksum = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\tfw_hdr->binary_version_num = be32_to_cpup((__be32 *)&buf[offset]);\n\tif (fw_hdr->binary_version_num < 0x103) {\n\t\tdev_err(tas_priv->dev, \"File version 0x%04x is too low\",\n\t\t\tfw_hdr->binary_version_num);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 4;\n\tfw_hdr->drv_fw_version = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 8;\n\tfw_hdr->plat_type = buf[offset];\n\toffset += 1;\n\tfw_hdr->dev_family = buf[offset];\n\toffset += 1;\n\tfw_hdr->reserve = buf[offset];\n\toffset += 1;\n\tfw_hdr->ndev = buf[offset];\n\toffset += 1;\n\tif (fw_hdr->ndev != tas_priv->ndev) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"ndev(%u) in rcabin mismatch ndev(%u) in DTS\\n\",\n\t\t\tfw_hdr->ndev, tas_priv->ndev);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (offset + TASDEVICE_DEVICE_SUM > fw_hdr->img_sz) {\n\t\tdev_err(tas_priv->dev, \"rca_ready: Out of boundary!\\n\");\n\t\tret = -EINVAL;\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TASDEVICE_DEVICE_SUM; i++, offset++)\n\t\tfw_hdr->devs[i] = buf[offset];\n\n\tfw_hdr->nconfig = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\n\tfor (i = 0; i < TASDEVICE_CONFIG_SUM; i++) {\n\t\tfw_hdr->config_size[i] = be32_to_cpup((__be32 *)&buf[offset]);\n\t\toffset += 4;\n\t\ttotal_config_sz += fw_hdr->config_size[i];\n\t}\n\n\tif (fw_hdr->img_sz - total_config_sz != (unsigned int)offset) {\n\t\tdev_err(tas_priv->dev, \"Bin file error!\\n\");\n\t\tret = -EINVAL;\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tgoto out;\n\t}\n\n\tcfg_info = kcalloc(fw_hdr->nconfig, sizeof(*cfg_info), GFP_KERNEL);\n\tif (!cfg_info) {\n\t\tret = -ENOMEM;\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tgoto out;\n\t}\n\trca->cfg_info = cfg_info;\n\trca->ncfgs = 0;\n\tfor (i = 0; i < (int)fw_hdr->nconfig; i++) {\n\t\trca->ncfgs += 1;\n\t\tcfg_info[i] = tasdevice_add_config(tas_priv, &buf[offset],\n\t\t\tfw_hdr->config_size[i], &ret);\n\t\tif (ret) {\n\t\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += (int)fw_hdr->config_size[i];\n\t}\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_rca_parser, SND_SOC_TAS2781_FMWLIB);\n\nstatic int fw_parse_block_data_kernel(struct tasdevice_fw *tas_fmw,\n\tstruct tasdev_blk *block, const struct firmware *fmw, int offset)\n{\n\tconst unsigned char *data = fmw->data;\n\n\tif (offset + 16 > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tblock->type = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\tblock->is_pchksum_present = data[offset];\n\toffset++;\n\n\tblock->pchksum = data[offset];\n\toffset++;\n\n\tblock->is_ychksum_present = data[offset];\n\toffset++;\n\n\tblock->ychksum = data[offset];\n\toffset++;\n\n\tblock->blk_size = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\tblock->nr_subblocks = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\tif (offset + block->blk_size > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: nSublocks error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tblock->data = kmemdup(&data[offset], block->blk_size, GFP_KERNEL);\n\tif (!block->data) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\toffset += block->blk_size;\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_data_kernel(struct tasdevice_fw *tas_fmw,\n\tstruct tasdevice_data *img_data, const struct firmware *fmw,\n\tint offset)\n{\n\tconst unsigned char *data = fmw->data;\n\tstruct tasdev_blk *blk;\n\tunsigned int i;\n\n\tif (offset + 4 > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\timg_data->nr_blk = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\timg_data->dev_blks = kcalloc(img_data->nr_blk,\n\t\tsizeof(struct tasdev_blk), GFP_KERNEL);\n\tif (!img_data->dev_blks) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < img_data->nr_blk; i++) {\n\t\tblk = &(img_data->dev_blks[i]);\n\t\toffset = fw_parse_block_data_kernel(tas_fmw, blk, fmw, offset);\n\t\tif (offset < 0) {\n\t\t\toffset = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_program_data_kernel(\n\tstruct tasdevice_priv *tas_priv, struct tasdevice_fw *tas_fmw,\n\tconst struct firmware *fmw, int offset)\n{\n\tstruct tasdevice_prog *program;\n\tunsigned int i;\n\n\tfor (i = 0; i < tas_fmw->nr_programs; i++) {\n\t\tprogram = &(tas_fmw->programs[i]);\n\t\tif (offset + 72 > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"%s: mpName error\\n\", __func__);\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\toffset += 72;\n\n\t\toffset = fw_parse_data_kernel(tas_fmw, &(program->dev_data),\n\t\t\tfmw, offset);\n\t\tif (offset < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_configuration_data_kernel(\n\tstruct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw, const struct firmware *fmw, int offset)\n{\n\tconst unsigned char *data = fmw->data;\n\tstruct tasdevice_config *config;\n\tunsigned int i;\n\n\tfor (i = 0; i < tas_fmw->nr_configurations; i++) {\n\t\tconfig = &(tas_fmw->configs[i]);\n\t\tif (offset + 80 > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"%s: mpName error\\n\", __func__);\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(config->name, &data[offset], 64);\n\t\t \n\t\toffset += 80;\n\n\t\toffset = fw_parse_data_kernel(tas_fmw, &(config->dev_data),\n\t\t\tfmw, offset);\n\t\tif (offset < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_variable_header_kernel(\n\tstruct tasdevice_priv *tas_priv, const struct firmware *fmw,\n\tint offset)\n{\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tstruct tasdevice_dspfw_hdr *fw_hdr = &(tas_fmw->fw_hdr);\n\tstruct tasdevice_prog *program;\n\tstruct tasdevice_config *config;\n\tconst unsigned char *buf = fmw->data;\n\tunsigned short max_confs;\n\tunsigned int i;\n\n\tif (offset + 12 + 4 * TASDEVICE_MAXPROGRAM_NUM_KERNEL > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\tfw_hdr->device_family = be16_to_cpup((__be16 *)&buf[offset]);\n\tif (fw_hdr->device_family != 0) {\n\t\tdev_err(tas_priv->dev, \"%s:not TAS device\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 2;\n\tfw_hdr->device = be16_to_cpup((__be16 *)&buf[offset]);\n\tif (fw_hdr->device >= TASDEVICE_DSP_TAS_MAX_DEVICE ||\n\t\tfw_hdr->device == 6) {\n\t\tdev_err(tas_priv->dev, \"Unsupported dev %d\\n\", fw_hdr->device);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 2;\n\tfw_hdr->ndev = deviceNumber[fw_hdr->device];\n\n\tif (fw_hdr->ndev != tas_priv->ndev) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: ndev(%u) in dspbin mismatch ndev(%u) in DTS\\n\",\n\t\t\t__func__, fw_hdr->ndev, tas_priv->ndev);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttas_fmw->nr_programs = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\n\tif (tas_fmw->nr_programs == 0 || tas_fmw->nr_programs >\n\t\tTASDEVICE_MAXPROGRAM_NUM_KERNEL) {\n\t\tdev_err(tas_priv->dev, \"mnPrograms is invalid\\n\");\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttas_fmw->programs = kcalloc(tas_fmw->nr_programs,\n\t\tsizeof(struct tasdevice_prog), GFP_KERNEL);\n\tif (!tas_fmw->programs) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < tas_fmw->nr_programs; i++) {\n\t\tprogram = &(tas_fmw->programs[i]);\n\t\tprogram->prog_size = be32_to_cpup((__be32 *)&buf[offset]);\n\t\toffset += 4;\n\t}\n\n\t \n\toffset += 4 * (TASDEVICE_MAXPROGRAM_NUM_KERNEL - tas_fmw->nr_programs);\n\n\ttas_fmw->nr_configurations = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\n\t \n\tmax_confs = (fw_hdr->ndev >= 4) ?\n\t\tTASDEVICE_MAXCONFIG_NUM_KERNEL_MULTIPLE_AMPS :\n\t\tTASDEVICE_MAXCONFIG_NUM_KERNEL;\n\tif (tas_fmw->nr_configurations == 0 ||\n\t\ttas_fmw->nr_configurations > max_confs) {\n\t\tdev_err(tas_priv->dev, \"%s: Conf is invalid\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (offset + 4 * max_confs > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: mpConfigurations err\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttas_fmw->configs = kcalloc(tas_fmw->nr_configurations,\n\t\tsizeof(struct tasdevice_config), GFP_KERNEL);\n\tif (!tas_fmw->configs) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < tas_fmw->nr_programs; i++) {\n\t\tconfig = &(tas_fmw->configs[i]);\n\t\tconfig->cfg_size = be32_to_cpup((__be32 *)&buf[offset]);\n\t\toffset += 4;\n\t}\n\n\t \n\toffset += 4 * (max_confs - tas_fmw->nr_programs);\n\nout:\n\treturn offset;\n}\n\nstatic int tasdevice_process_block(void *context, unsigned char *data,\n\tunsigned char dev_idx, int sublocksize)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *)context;\n\tint subblk_offset, chn, chnend, rc;\n\tunsigned char subblk_typ = data[1];\n\tint blktyp = dev_idx & 0xC0;\n\tint idx = dev_idx & 0x3F;\n\tbool is_err = false;\n\n\tif (idx) {\n\t\tchn = idx - 1;\n\t\tchnend = idx;\n\t} else {\n\t\tchn = 0;\n\t\tchnend = tas_priv->ndev;\n\t}\n\n\tfor (; chn < chnend; chn++) {\n\t\tif (tas_priv->tasdevice[chn].is_loading == false)\n\t\t\tcontinue;\n\n\t\tis_err = false;\n\t\tsubblk_offset = 2;\n\t\tswitch (subblk_typ) {\n\t\tcase TASDEVICE_CMD_SING_W: {\n\t\t\tint i;\n\t\t\tunsigned short len = be16_to_cpup((__be16 *)&data[2]);\n\n\t\t\tsubblk_offset += 2;\n\t\t\tif (subblk_offset + 4 * len > sublocksize) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"process_block: Out of boundary\\n\");\n\t\t\t\tis_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\trc = tasdevice_dev_write(tas_priv, chn,\n\t\t\t\t\tTASDEVICE_REG(data[subblk_offset],\n\t\t\t\t\t\tdata[subblk_offset + 1],\n\t\t\t\t\t\tdata[subblk_offset + 2]),\n\t\t\t\t\tdata[subblk_offset + 3]);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tis_err = true;\n\t\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"process_block: single write error\\n\");\n\t\t\t\t}\n\t\t\t\tsubblk_offset += 4;\n\t\t\t}\n\t\t}\n\t\t\tbreak;\n\t\tcase TASDEVICE_CMD_BURST: {\n\t\t\tunsigned short len = be16_to_cpup((__be16 *)&data[2]);\n\n\t\t\tsubblk_offset += 2;\n\t\t\tif (subblk_offset + 4 + len > sublocksize) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: BST Out of boundary\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tis_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (len % 4) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s:Bst-len(%u)not div by 4\\n\",\n\t\t\t\t\t__func__, len);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trc = tasdevice_dev_bulk_write(tas_priv, chn,\n\t\t\t\tTASDEVICE_REG(data[subblk_offset],\n\t\t\t\tdata[subblk_offset + 1],\n\t\t\t\tdata[subblk_offset + 2]),\n\t\t\t\t&(data[subblk_offset + 4]), len);\n\t\t\tif (rc < 0) {\n\t\t\t\tis_err = true;\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: bulk_write error = %d\\n\",\n\t\t\t\t\t__func__, rc);\n\t\t\t}\n\t\t\tsubblk_offset += (len + 4);\n\t\t}\n\t\t\tbreak;\n\t\tcase TASDEVICE_CMD_DELAY: {\n\t\t\tunsigned int sleep_time = 0;\n\n\t\t\tif (subblk_offset + 2 > sublocksize) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: delay Out of boundary\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tis_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsleep_time = be16_to_cpup((__be16 *)&data[2]) * 1000;\n\t\t\tusleep_range(sleep_time, sleep_time + 50);\n\t\t\tsubblk_offset += 2;\n\t\t}\n\t\t\tbreak;\n\t\tcase TASDEVICE_CMD_FIELD_W:\n\t\t\tif (subblk_offset + 6 > sublocksize) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: bit write Out of boundary\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tis_err = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trc = tasdevice_dev_update_bits(tas_priv, chn,\n\t\t\t\tTASDEVICE_REG(data[subblk_offset + 2],\n\t\t\t\tdata[subblk_offset + 3],\n\t\t\t\tdata[subblk_offset + 4]),\n\t\t\t\tdata[subblk_offset + 1],\n\t\t\t\tdata[subblk_offset + 5]);\n\t\t\tif (rc < 0) {\n\t\t\t\tis_err = true;\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: update_bits error = %d\\n\",\n\t\t\t\t\t__func__, rc);\n\t\t\t}\n\t\t\tsubblk_offset += 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (is_err == true && blktyp != 0) {\n\t\t\tif (blktyp == 0x80) {\n\t\t\t\ttas_priv->tasdevice[chn].cur_prog = -1;\n\t\t\t\ttas_priv->tasdevice[chn].cur_conf = -1;\n\t\t\t} else\n\t\t\t\ttas_priv->tasdevice[chn].cur_conf = -1;\n\t\t}\n\t}\n\n\treturn subblk_offset;\n}\n\nvoid tasdevice_select_cfg_blk(void *pContext, int conf_no,\n\tunsigned char block_type)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) pContext;\n\tstruct tasdevice_rca *rca = &(tas_priv->rcabin);\n\tstruct tasdevice_config_info **cfg_info = rca->cfg_info;\n\tstruct tasdev_blk_data **blk_data;\n\tint j, k, chn, chnend;\n\n\tif (conf_no >= rca->ncfgs || conf_no < 0 || !cfg_info) {\n\t\tdev_err(tas_priv->dev, \"conf_no should be not more than %u\\n\",\n\t\t\trca->ncfgs);\n\t\treturn;\n\t}\n\tblk_data = cfg_info[conf_no]->blk_data;\n\n\tfor (j = 0; j < (int)cfg_info[conf_no]->real_nblocks; j++) {\n\t\tunsigned int length = 0, rc = 0;\n\n\t\tif (block_type > 5 || block_type < 2) {\n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"block_type should be in range from 2 to 5\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (block_type != blk_data[j]->block_type)\n\t\t\tcontinue;\n\n\t\tfor (k = 0; k < (int)blk_data[j]->n_subblks; k++) {\n\t\t\tif (blk_data[j]->dev_idx) {\n\t\t\t\tchn = blk_data[j]->dev_idx - 1;\n\t\t\t\tchnend = blk_data[j]->dev_idx;\n\t\t\t} else {\n\t\t\t\tchn = 0;\n\t\t\t\tchnend = tas_priv->ndev;\n\t\t\t}\n\t\t\tfor (; chn < chnend; chn++)\n\t\t\t\ttas_priv->tasdevice[chn].is_loading = true;\n\n\t\t\trc = tasdevice_process_block(tas_priv,\n\t\t\t\tblk_data[j]->regdata + length,\n\t\t\t\tblk_data[j]->dev_idx,\n\t\t\t\tblk_data[j]->block_size - length);\n\t\t\tlength += rc;\n\t\t\tif (blk_data[j]->block_size < length) {\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: %u %u out of boundary\\n\",\n\t\t\t\t\t__func__, length,\n\t\t\t\t\tblk_data[j]->block_size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (length != blk_data[j]->block_size)\n\t\t\tdev_err(tas_priv->dev, \"%s: %u %u size is not same\\n\",\n\t\t\t\t__func__, length, blk_data[j]->block_size);\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_select_cfg_blk, SND_SOC_TAS2781_FMWLIB);\n\nstatic int tasdevice_load_block_kernel(\n\tstruct tasdevice_priv *tasdevice, struct tasdev_blk *block)\n{\n\tstruct tasdevice_dspfw_hdr *fw_hdr = &(tasdevice->fmw->fw_hdr);\n\tstruct tasdevice_fw_fixed_hdr *fw_fixed_hdr = &(fw_hdr->fixed_hdr);\n\tconst unsigned int blk_size = block->blk_size;\n\tunsigned int i, length;\n\tunsigned char *data = block->data;\n\tunsigned char dev_idx = 0;\n\n\tif (fw_fixed_hdr->ppcver >= PPC3_VERSION_TAS2781) {\n\t\tswitch (block->type) {\n\t\tcase MAIN_ALL_DEVICES_1X:\n\t\t\tdev_idx = 0x80;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_A_1X:\n\t\t\tdev_idx = 0x81;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_A_1X:\n\t\tcase PRE_DEVICE_A_1X:\n\t\tcase PRE_SOFTWARE_RESET_DEVICE_A:\n\t\tcase POST_SOFTWARE_RESET_DEVICE_A:\n\t\t\tdev_idx = 0xC1;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_B_1X:\n\t\t\tdev_idx = 0x82;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_B_1X:\n\t\tcase PRE_DEVICE_B_1X:\n\t\tcase PRE_SOFTWARE_RESET_DEVICE_B:\n\t\tcase POST_SOFTWARE_RESET_DEVICE_B:\n\t\t\tdev_idx = 0xC2;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_C_1X:\n\t\t\tdev_idx = 0x83;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_C_1X:\n\t\tcase PRE_DEVICE_C_1X:\n\t\tcase PRE_SOFTWARE_RESET_DEVICE_C:\n\t\tcase POST_SOFTWARE_RESET_DEVICE_C:\n\t\t\tdev_idx = 0xC3;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_D_1X:\n\t\t\tdev_idx = 0x84;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_D_1X:\n\t\tcase PRE_DEVICE_D_1X:\n\t\tcase PRE_SOFTWARE_RESET_DEVICE_D:\n\t\tcase POST_SOFTWARE_RESET_DEVICE_D:\n\t\t\tdev_idx = 0xC4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(tasdevice->dev,\n\t\t\t\t\"%s: load block: Other Type = 0x%02x\\n\",\n\t\t\t\t__func__, block->type);\n\t\t\tbreak;\n\t\t}\n\t} else if (fw_fixed_hdr->ppcver >=\n\tPPC3_VERSION) {\n\t\tswitch (block->type) {\n\t\tcase MAIN_ALL_DEVICES_1X:\n\t\t\tdev_idx = 0x80;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_A_1X:\n\t\t\tdev_idx = 0x81;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_A_1X:\n\t\tcase PRE_DEVICE_A_1X:\n\t\t\tdev_idx = 0xC1;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_B_1X:\n\t\t\tdev_idx = 0x82;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_B_1X:\n\t\tcase PRE_DEVICE_B_1X:\n\t\t\tdev_idx = 0xC2;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_C_1X:\n\t\t\tdev_idx = 0x83;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_C_1X:\n\t\tcase PRE_DEVICE_C_1X:\n\t\t\tdev_idx = 0xC3;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_D_1X:\n\t\t\tdev_idx = 0x84;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_D_1X:\n\t\tcase PRE_DEVICE_D_1X:\n\t\t\tdev_idx = 0xC4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(tasdevice->dev,\n\t\t\t\t\"%s: load block: Other Type = 0x%02x\\n\",\n\t\t\t\t__func__, block->type);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (block->type) {\n\t\tcase MAIN_ALL_DEVICES:\n\t\t\tdev_idx = 0|0x80;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_A:\n\t\t\tdev_idx = 0x81;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_A:\n\t\tcase PRE_DEVICE_A:\n\t\t\tdev_idx = 0xC1;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_B:\n\t\t\tdev_idx = 0x82;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_B:\n\t\tcase PRE_DEVICE_B:\n\t\t\tdev_idx = 0xC2;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_C:\n\t\t\tdev_idx = 0x83;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_C:\n\t\tcase PRE_DEVICE_C:\n\t\t\tdev_idx = 0xC3;\n\t\t\tbreak;\n\t\tcase MAIN_DEVICE_D:\n\t\t\tdev_idx = 0x84;\n\t\t\tbreak;\n\t\tcase COEFF_DEVICE_D:\n\t\tcase PRE_DEVICE_D:\n\t\t\tdev_idx = 0xC4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_info(tasdevice->dev,\n\t\t\t\t\"%s: load block: Other Type = 0x%02x\\n\",\n\t\t\t\t__func__, block->type);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0, length = 0; i < block->nr_subblocks; i++) {\n\t\tint rc = tasdevice_process_block(tasdevice, data + length,\n\t\t\tdev_idx, blk_size - length);\n\t\tif (rc < 0) {\n\t\t\tdev_err(tasdevice->dev,\n\t\t\t\t\"%s: %u %u sublock write error\\n\",\n\t\t\t\t__func__, length, blk_size);\n\t\t\tbreak;\n\t\t}\n\t\tlength += (unsigned int)rc;\n\t\tif (blk_size < length) {\n\t\t\tdev_err(tasdevice->dev, \"%s: %u %u out of boundary\\n\",\n\t\t\t\t__func__, length, blk_size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_parse_variable_hdr(struct tasdevice_priv\n\t*tas_priv, struct tasdevice_dspfw_hdr *fw_hdr,\n\tconst struct firmware *fmw, int offset)\n{\n\tconst unsigned char *buf = fmw->data;\n\tint len = strlen((char *)&buf[offset]);\n\n\tlen++;\n\n\tif (offset + len + 8 > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffset += len;\n\n\tfw_hdr->device_family = be32_to_cpup((__be32 *)&buf[offset]);\n\tif (fw_hdr->device_family != 0) {\n\t\tdev_err(tas_priv->dev, \"%s: not TAS device\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 4;\n\n\tfw_hdr->device = be32_to_cpup((__be32 *)&buf[offset]);\n\tif (fw_hdr->device >= TASDEVICE_DSP_TAS_MAX_DEVICE ||\n\t\tfw_hdr->device == 6) {\n\t\tdev_err(tas_priv->dev, \"Unsupported dev %d\\n\", fw_hdr->device);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 4;\n\tfw_hdr->ndev = deviceNumber[fw_hdr->device];\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_variable_header_git(struct tasdevice_priv\n\t*tas_priv, const struct firmware *fmw, int offset)\n{\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tstruct tasdevice_dspfw_hdr *fw_hdr = &(tas_fmw->fw_hdr);\n\n\toffset = fw_parse_variable_hdr(tas_priv, fw_hdr, fmw, offset);\n\tif (offset < 0)\n\t\tgoto out;\n\tif (fw_hdr->ndev != tas_priv->ndev) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: ndev(%u) in dspbin mismatch ndev(%u) in DTS\\n\",\n\t\t\t__func__, fw_hdr->ndev, tas_priv->ndev);\n\t\toffset = -EINVAL;\n\t}\n\nout:\n\treturn offset;\n}\n\nstatic int fw_parse_block_data(struct tasdevice_fw *tas_fmw,\n\tstruct tasdev_blk *block, const struct firmware *fmw, int offset)\n{\n\tunsigned char *data = (unsigned char *)fmw->data;\n\tint n;\n\n\tif (offset + 8 > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: Type error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\tblock->type = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\tif (tas_fmw->fw_hdr.fixed_hdr.drv_ver >= PPC_DRIVER_CRCCHK) {\n\t\tif (offset + 8 > fmw->size) {\n\t\t\tdev_err(tas_fmw->dev, \"PChkSumPresent error\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tblock->is_pchksum_present = data[offset];\n\t\toffset++;\n\n\t\tblock->pchksum = data[offset];\n\t\toffset++;\n\n\t\tblock->is_ychksum_present = data[offset];\n\t\toffset++;\n\n\t\tblock->ychksum = data[offset];\n\t\toffset++;\n\t} else {\n\t\tblock->is_pchksum_present = 0;\n\t\tblock->is_ychksum_present = 0;\n\t}\n\n\tblock->nr_cmds = be32_to_cpup((__be32 *)&data[offset]);\n\toffset += 4;\n\n\tn = block->nr_cmds * 4;\n\tif (offset + n > fmw->size) {\n\t\tdev_err(tas_fmw->dev,\n\t\t\t\"%s: File Size(%lu) error offset = %d n = %d\\n\",\n\t\t\t__func__, (unsigned long)fmw->size, offset, n);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\t \n\tblock->data = kmemdup(&data[offset], n, GFP_KERNEL);\n\tif (!block->data) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\toffset += n;\n\nout:\n\treturn offset;\n}\n\n \nstatic int fw_parse_data(struct tasdevice_fw *tas_fmw,\n\tstruct tasdevice_data *img_data, const struct firmware *fmw,\n\tint offset)\n{\n\tconst unsigned char *data = (unsigned char *)fmw->data;\n\tstruct tasdev_blk *blk;\n\tunsigned int i;\n\tint n;\n\n\tif (offset + 64 > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: Name error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy(img_data->name, &data[offset], 64);\n\toffset += 64;\n\n\tn = strlen((char *)&data[offset]);\n\tn++;\n\tif (offset + n + 2 > fmw->size) {\n\t\tdev_err(tas_fmw->dev, \"%s: Description error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += n;\n\timg_data->nr_blk = be16_to_cpup((__be16 *)&data[offset]);\n\toffset += 2;\n\n\timg_data->dev_blks = kcalloc(img_data->nr_blk,\n\t\tsizeof(struct tasdev_blk), GFP_KERNEL);\n\tif (!img_data->dev_blks) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < img_data->nr_blk; i++) {\n\t\tblk = &(img_data->dev_blks[i]);\n\t\toffset = fw_parse_block_data(tas_fmw, blk, fmw, offset);\n\t\tif (offset < 0) {\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn offset;\n}\n\n \nstatic int fw_parse_program_data(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw, const struct firmware *fmw, int offset)\n{\n\tunsigned char *buf = (unsigned char *)fmw->data;\n\tstruct tasdevice_prog *program;\n\tint i;\n\n\tif (offset + 2 > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\ttas_fmw->nr_programs = be16_to_cpup((__be16 *)&buf[offset]);\n\toffset += 2;\n\n\tif (tas_fmw->nr_programs == 0) {\n\t\t \n\t\tdev_info(tas_priv->dev, \"%s: No Programs data, maybe calbin\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\n\ttas_fmw->programs =\n\t\tkcalloc(tas_fmw->nr_programs, sizeof(struct tasdevice_prog),\n\t\t\tGFP_KERNEL);\n\tif (!tas_fmw->programs) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < tas_fmw->nr_programs; i++) {\n\t\tint n = 0;\n\n\t\tprogram = &(tas_fmw->programs[i]);\n\t\tif (offset + 64 > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"%s: mpName error\\n\", __func__);\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += 64;\n\n\t\tn = strlen((char *)&buf[offset]);\n\t\t \n\t\tn += 6;\n\t\tif (offset + n > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"Description err\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += n;\n\n\t\toffset = fw_parse_data(tas_fmw, &(program->dev_data), fmw,\n\t\t\toffset);\n\t\tif (offset < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn offset;\n}\n\n \nstatic int fw_parse_configuration_data(\n\tstruct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw,\n\tconst struct firmware *fmw, int offset)\n{\n\tunsigned char *data = (unsigned char *)fmw->data;\n\tstruct tasdevice_config *config;\n\tunsigned int i;\n\tint n;\n\n\tif (offset + 2 > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\ttas_fmw->nr_configurations = be16_to_cpup((__be16 *)&data[offset]);\n\toffset += 2;\n\n\tif (tas_fmw->nr_configurations == 0) {\n\t\tdev_err(tas_priv->dev, \"%s: Conf is zero\\n\", __func__);\n\t\t \n\t\tgoto out;\n\t}\n\ttas_fmw->configs = kcalloc(tas_fmw->nr_configurations,\n\t\t\tsizeof(struct tasdevice_config), GFP_KERNEL);\n\tif (!tas_fmw->configs) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < tas_fmw->nr_configurations; i++) {\n\t\tconfig = &(tas_fmw->configs[i]);\n\t\tif (offset + 64 > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"File Size err\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(config->name, &data[offset], 64);\n\t\toffset += 64;\n\n\t\tn = strlen((char *)&data[offset]);\n\t\tn += 15;\n\t\tif (offset + n > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"Description err\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += n;\n\n\t\toffset = fw_parse_data(tas_fmw, &(config->dev_data),\n\t\t\tfmw, offset);\n\t\tif (offset < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn offset;\n}\n\nstatic bool check_inpage_yram_rg(struct tas_crc *cd,\n\tunsigned char reg, unsigned char len)\n{\n\tbool in = false;\n\n\n\tif (reg <= TAS2781_YRAM5_END_REG &&\n\t\treg >= TAS2781_YRAM5_START_REG) {\n\t\tif (reg + len > TAS2781_YRAM5_END_REG)\n\t\t\tcd->len = TAS2781_YRAM5_END_REG - reg + 1;\n\t\telse\n\t\t\tcd->len = len;\n\t\tcd->offset = reg;\n\t\tin = true;\n\t} else if (reg < TAS2781_YRAM5_START_REG) {\n\t\tif (reg + len > TAS2781_YRAM5_START_REG) {\n\t\t\tcd->offset = TAS2781_YRAM5_START_REG;\n\t\t\tcd->len = len - TAS2781_YRAM5_START_REG + reg;\n\t\t\tin = true;\n\t\t}\n\t}\n\n\treturn in;\n}\n\nstatic bool check_inpage_yram_bk1(struct tas_crc *cd,\n\tunsigned char page, unsigned char reg, unsigned char len)\n{\n\tbool in = false;\n\n\tif (page == TAS2781_YRAM1_PAGE) {\n\t\tif (reg >= TAS2781_YRAM1_START_REG) {\n\t\t\tcd->offset = reg;\n\t\t\tcd->len = len;\n\t\t\tin = true;\n\t\t} else if (reg + len > TAS2781_YRAM1_START_REG) {\n\t\t\tcd->offset = TAS2781_YRAM1_START_REG;\n\t\t\tcd->len = len - TAS2781_YRAM1_START_REG + reg;\n\t\t\tin = true;\n\t\t}\n\t} else if (page == TAS2781_YRAM3_PAGE)\n\t\tin = check_inpage_yram_rg(cd, reg, len);\n\n\treturn in;\n}\n\n \nstatic bool check_inpage_yram(struct tas_crc *cd, unsigned char book,\n\tunsigned char page, unsigned char reg, unsigned char len)\n{\n\tbool in = false;\n\n\tif (book == TAS2781_YRAM_BOOK1) {\n\t\tin = check_inpage_yram_bk1(cd, page, reg, len);\n\t\tgoto end;\n\t}\n\tif (book == TAS2781_YRAM_BOOK2 && page == TAS2781_YRAM5_PAGE)\n\t\tin = check_inpage_yram_rg(cd, reg, len);\n\nend:\n\treturn in;\n}\n\nstatic bool check_inblock_yram_bk(struct tas_crc *cd,\n\tunsigned char page, unsigned char reg, unsigned char len)\n{\n\tbool in = false;\n\n\tif ((page >= TAS2781_YRAM4_START_PAGE &&\n\t\tpage <= TAS2781_YRAM4_END_PAGE) ||\n\t\t(page >= TAS2781_YRAM2_START_PAGE &&\n\t\tpage <= TAS2781_YRAM2_END_PAGE)) {\n\t\tif (reg <= TAS2781_YRAM2_END_REG &&\n\t\t\treg >= TAS2781_YRAM2_START_REG) {\n\t\t\tcd->offset = reg;\n\t\t\tcd->len = len;\n\t\t\tin = true;\n\t\t} else if (reg < TAS2781_YRAM2_START_REG) {\n\t\t\tif (reg + len - 1 >= TAS2781_YRAM2_START_REG) {\n\t\t\t\tcd->offset = TAS2781_YRAM2_START_REG;\n\t\t\t\tcd->len = reg + len - TAS2781_YRAM2_START_REG;\n\t\t\t\tin = true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn in;\n}\n\n \nstatic bool check_inblock_yram(struct tas_crc *cd, unsigned char book,\n\tunsigned char page, unsigned char reg, unsigned char len)\n{\n\tbool in = false;\n\n\tif (book == TAS2781_YRAM_BOOK1 || book == TAS2781_YRAM_BOOK2)\n\t\tin = check_inblock_yram_bk(cd, page, reg, len);\n\n\treturn in;\n}\n\nstatic bool check_yram(struct tas_crc *cd, unsigned char book,\n\tunsigned char page, unsigned char reg, unsigned char len)\n{\n\tbool in;\n\n\tin = check_inpage_yram(cd, book, page, reg, len);\n\tif (in)\n\t\tgoto end;\n\tin = check_inblock_yram(cd, book, page, reg, len);\n\nend:\n\treturn in;\n}\n\nstatic int tasdev_multibytes_chksum(struct tasdevice_priv *tasdevice,\n\tunsigned short chn, unsigned char book, unsigned char page,\n\tunsigned char reg, unsigned int len)\n{\n\tstruct tas_crc crc_data;\n\tunsigned char crc_chksum = 0;\n\tunsigned char nBuf1[128];\n\tint ret = 0;\n\tint i;\n\tbool in;\n\n\tif ((reg + len - 1) > 127) {\n\t\tret = -EINVAL;\n\t\tdev_err(tasdevice->dev, \"firmware error\\n\");\n\t\tgoto end;\n\t}\n\n\tif ((book == TASDEVICE_BOOK_ID(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (page == TASDEVICE_PAGE_ID(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (reg == TASDEVICE_PAGE_REG(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (len == 4)) {\n\t\t \n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tin = check_yram(&crc_data, book, page, reg, len);\n\tif (!in)\n\t\tgoto end;\n\n\tif (len == 1) {\n\t\tdev_err(tasdevice->dev, \"firmware error\\n\");\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tret = tasdevice_dev_bulk_read(tasdevice, chn,\n\t\tTASDEVICE_REG(book, page, crc_data.offset),\n\t\tnBuf1, crc_data.len);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tfor (i = 0; i < crc_data.len; i++) {\n\t\tif ((book == TASDEVICE_BOOK_ID(TAS2781_SA_COEFF_SWAP_REG))\n\t\t\t&& (page == TASDEVICE_PAGE_ID(\n\t\t\tTAS2781_SA_COEFF_SWAP_REG))\n\t\t\t&& ((i + crc_data.offset)\n\t\t\t>= TASDEVICE_PAGE_REG(TAS2781_SA_COEFF_SWAP_REG))\n\t\t\t&& ((i + crc_data.offset)\n\t\t\t<= (TASDEVICE_PAGE_REG(TAS2781_SA_COEFF_SWAP_REG)\n\t\t\t+ 4)))\n\t\t\t \n\t\t\tcontinue;\n\t\telse\n\t\t\tcrc_chksum += crc8(tasdevice->crc8_lkp_tbl, &nBuf1[i],\n\t\t\t\t1, 0);\n\t}\n\n\tret = crc_chksum;\n\nend:\n\treturn ret;\n}\n\nstatic int do_singlereg_checksum(struct tasdevice_priv *tasdevice,\n\tunsigned short chl, unsigned char book, unsigned char page,\n\tunsigned char reg, unsigned char val)\n{\n\tstruct tas_crc crc_data;\n\tunsigned int nData1;\n\tint ret = 0;\n\tbool in;\n\n\tif ((book == TASDEVICE_BOOK_ID(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (page == TASDEVICE_PAGE_ID(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (reg >= TASDEVICE_PAGE_REG(TAS2781_SA_COEFF_SWAP_REG))\n\t\t&& (reg <= (TASDEVICE_PAGE_REG(\n\t\tTAS2781_SA_COEFF_SWAP_REG) + 4))) {\n\t\t \n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tin = check_yram(&crc_data, book, page, reg, 1);\n\tif (!in)\n\t\tgoto end;\n\tret = tasdevice_dev_read(tasdevice, chl,\n\t\tTASDEVICE_REG(book, page, reg), &nData1);\n\tif (ret < 0)\n\t\tgoto end;\n\n\tif (nData1 != val) {\n\t\tdev_err(tasdevice->dev,\n\t\t\t\"B[0x%x]P[0x%x]R[0x%x] W[0x%x], R[0x%x]\\n\",\n\t\t\tbook, page, reg, val, nData1);\n\t\ttasdevice->tasdevice[chl].err_code |= ERROR_YRAM_CRCCHK;\n\t\tret = -EAGAIN;\n\t\tgoto end;\n\t}\n\n\tret = crc8(tasdevice->crc8_lkp_tbl, &val, 1, 0);\n\nend:\n\treturn ret;\n}\n\nstatic void set_err_prg_cfg(unsigned int type, struct tasdevice *dev)\n{\n\tif ((type == MAIN_ALL_DEVICES) || (type == MAIN_DEVICE_A)\n\t\t|| (type == MAIN_DEVICE_B) || (type == MAIN_DEVICE_C)\n\t\t|| (type == MAIN_DEVICE_D))\n\t\tdev->cur_prog = -1;\n\telse\n\t\tdev->cur_conf = -1;\n}\n\nstatic int tasdev_bytes_chksum(struct tasdevice_priv *tas_priv,\n\tstruct tasdev_blk *block, int chn, unsigned char book,\n\tunsigned char page, unsigned char reg, unsigned int len,\n\tunsigned char val, unsigned char *crc_chksum)\n{\n\tint ret;\n\n\tif (len > 1)\n\t\tret = tasdev_multibytes_chksum(tas_priv, chn, book, page, reg,\n\t\t\tlen);\n\telse\n\t\tret = do_singlereg_checksum(tas_priv, chn, book, page, reg,\n\t\t\tval);\n\n\tif (ret > 0) {\n\t\t*crc_chksum += (unsigned char)ret;\n\t\tgoto end;\n\t}\n\n\tif (ret != -EAGAIN)\n\t\tgoto end;\n\n\tblock->nr_retry--;\n\tif (block->nr_retry > 0)\n\t\tgoto end;\n\n\tset_err_prg_cfg(block->type, &tas_priv->tasdevice[chn]);\n\nend:\n\treturn ret;\n}\n\nstatic int tasdev_multibytes_wr(struct tasdevice_priv *tas_priv,\n\tstruct tasdev_blk *block, int chn, unsigned char book,\n\tunsigned char page, unsigned char reg, unsigned char *data,\n\tunsigned int len, unsigned int *nr_cmds,\n\tunsigned char *crc_chksum)\n{\n\tint ret;\n\n\tif (len > 1) {\n\t\tret = tasdevice_dev_bulk_write(tas_priv, chn,\n\t\t\tTASDEVICE_REG(book, page, reg), data + 3, len);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tif (block->is_ychksum_present)\n\t\t\tret = tasdev_bytes_chksum(tas_priv, block, chn,\n\t\t\t\tbook, page, reg, len, 0, crc_chksum);\n\t} else {\n\t\tret = tasdevice_dev_write(tas_priv, chn,\n\t\t\tTASDEVICE_REG(book, page, reg), data[3]);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\t\tif (block->is_ychksum_present)\n\t\t\tret = tasdev_bytes_chksum(tas_priv, block, chn, book,\n\t\t\t\tpage, reg, 1, data[3], crc_chksum);\n\t}\n\n\tif (!block->is_ychksum_present || ret >= 0) {\n\t\t*nr_cmds += 1;\n\t\tif (len >= 2)\n\t\t\t*nr_cmds += ((len - 2) / 4) + 1;\n\t}\n\nend:\n\treturn ret;\n}\n\nstatic int tasdev_block_chksum(struct tasdevice_priv *tas_priv,\n\tstruct tasdev_blk *block, int chn)\n{\n\tunsigned int nr_value;\n\tint ret;\n\n\tret = tasdevice_dev_read(tas_priv, chn, TASDEVICE_I2CChecksum,\n\t\t&nr_value);\n\tif (ret < 0) {\n\t\tdev_err(tas_priv->dev, \"%s: Chn %d\\n\", __func__, chn);\n\t\tset_err_prg_cfg(block->type, &tas_priv->tasdevice[chn]);\n\t\tgoto end;\n\t}\n\n\tif ((nr_value & 0xff) != block->pchksum) {\n\t\tdev_err(tas_priv->dev, \"%s: Blk PChkSum Chn %d \", __func__,\n\t\t\tchn);\n\t\tdev_err(tas_priv->dev, \"PChkSum = 0x%x, Reg = 0x%x\\n\",\n\t\t\tblock->pchksum, (nr_value & 0xff));\n\t\ttas_priv->tasdevice[chn].err_code |= ERROR_PRAM_CRCCHK;\n\t\tret = -EAGAIN;\n\t\tblock->nr_retry--;\n\n\t\tif (block->nr_retry <= 0)\n\t\t\tset_err_prg_cfg(block->type,\n\t\t\t\t&tas_priv->tasdevice[chn]);\n\t} else\n\t\ttas_priv->tasdevice[chn].err_code &= ~ERROR_PRAM_CRCCHK;\n\nend:\n\treturn ret;\n}\n\nstatic int tasdev_load_blk(struct tasdevice_priv *tas_priv,\n\tstruct tasdev_blk *block, int chn)\n{\n\tunsigned int sleep_time;\n\tunsigned int len;\n\tunsigned int nr_cmds;\n\tunsigned char *data = block->data;\n\tunsigned char crc_chksum = 0;\n\tunsigned char offset;\n\tunsigned char book;\n\tunsigned char page;\n\tunsigned char val;\n\tint ret = 0;\n\n\twhile (block->nr_retry > 0) {\n\t\tif (block->is_pchksum_present) {\n\t\t\tret = tasdevice_dev_write(tas_priv, chn,\n\t\t\t\tTASDEVICE_I2CChecksum, 0);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (block->is_ychksum_present)\n\t\t\tcrc_chksum = 0;\n\n\t\tnr_cmds = 0;\n\n\t\twhile (nr_cmds < block->nr_cmds) {\n\t\t\tdata = block->data + nr_cmds * 4;\n\n\t\t\tbook = data[0];\n\t\t\tpage = data[1];\n\t\t\toffset = data[2];\n\t\t\tval = data[3];\n\n\t\t\tnr_cmds++;\n\t\t\t \n\t\t\tif (offset <= 0x7F) {\n\t\t\t\tret = tasdevice_dev_write(tas_priv, chn,\n\t\t\t\t\tTASDEVICE_REG(book, page, offset),\n\t\t\t\t\tval);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto end;\n\t\t\t\tif (block->is_ychksum_present) {\n\t\t\t\t\tret = tasdev_bytes_chksum(tas_priv,\n\t\t\t\t\t\tblock, chn, book, page, offset,\n\t\t\t\t\t\t1, val, &crc_chksum);\n\t\t\t\t\tif (ret < 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (offset == 0x81) {\n\t\t\t\t \n\t\t\t\tsleep_time = ((book << 8) + page)*1000;\n\t\t\t\tusleep_range(sleep_time, sleep_time + 50);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t \n\t\t\tif (offset == 0x85) {\n\t\t\t\tdata += 4;\n\t\t\t\tlen = (book << 8) + page;\n\t\t\t\tbook = data[0];\n\t\t\t\tpage = data[1];\n\t\t\t\toffset = data[2];\n\t\t\t\tret = tasdev_multibytes_wr(tas_priv,\n\t\t\t\t\tblock, chn, book, page, offset, data,\n\t\t\t\t\tlen, &nr_cmds, &crc_chksum);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret == -EAGAIN) {\n\t\t\tif (block->nr_retry > 0)\n\t\t\t\tcontinue;\n\t\t} else if (ret < 0)  \n\t\t\tbreak;\n\n\t\tif (block->is_pchksum_present) {\n\t\t\tret = tasdev_block_chksum(tas_priv, block, chn);\n\t\t\tif (ret == -EAGAIN) {\n\t\t\t\tif (block->nr_retry > 0)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (ret < 0)  \n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (block->is_ychksum_present) {\n\t\t\t \n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"Blk YChkSum: FW = 0x%x, YCRC = 0x%x\\n\",\n\t\t\t\tblock->ychksum, crc_chksum);\n\n\t\t\ttas_priv->tasdevice[chn].err_code &=\n\t\t\t\t~ERROR_YRAM_CRCCHK;\n\t\t\tret = 0;\n\t\t}\n\t\t \n\t\tbreak;\n\t}\n\nend:\n\treturn ret;\n}\n\nstatic int tasdevice_load_block(struct tasdevice_priv *tas_priv,\n\tstruct tasdev_blk *block)\n{\n\tint chnend = 0;\n\tint ret = 0;\n\tint chn = 0;\n\tint rc = 0;\n\n\tswitch (block->type) {\n\tcase MAIN_ALL_DEVICES:\n\t\tchn = 0;\n\t\tchnend = tas_priv->ndev;\n\t\tbreak;\n\tcase MAIN_DEVICE_A:\n\tcase COEFF_DEVICE_A:\n\tcase PRE_DEVICE_A:\n\t\tchn = 0;\n\t\tchnend = 1;\n\t\tbreak;\n\tcase MAIN_DEVICE_B:\n\tcase COEFF_DEVICE_B:\n\tcase PRE_DEVICE_B:\n\t\tchn = 1;\n\t\tchnend = 2;\n\t\tbreak;\n\tcase MAIN_DEVICE_C:\n\tcase COEFF_DEVICE_C:\n\tcase PRE_DEVICE_C:\n\t\tchn = 2;\n\t\tchnend = 3;\n\t\tbreak;\n\tcase MAIN_DEVICE_D:\n\tcase COEFF_DEVICE_D:\n\tcase PRE_DEVICE_D:\n\t\tchn = 3;\n\t\tchnend = 4;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(tas_priv->dev, \"load blk: Other Type = 0x%02x\\n\",\n\t\t\tblock->type);\n\t\tbreak;\n\t}\n\n\tfor (; chn < chnend; chn++) {\n\t\tblock->nr_retry = 6;\n\t\tif (tas_priv->tasdevice[chn].is_loading == false)\n\t\t\tcontinue;\n\t\tret = tasdev_load_blk(tas_priv, block, chn);\n\t\tif (ret < 0)\n\t\t\tdev_err(tas_priv->dev, \"dev %d, Blk (%d) load error\\n\",\n\t\t\t\tchn, block->type);\n\t\trc |= ret;\n\t}\n\n\treturn rc;\n}\n\nstatic int dspfw_default_callback(struct tasdevice_priv *tas_priv,\n\tunsigned int drv_ver, unsigned int ppcver)\n{\n\tint rc = 0;\n\n\tif (drv_ver == 0x100) {\n\t\tif (ppcver >= PPC3_VERSION) {\n\t\t\ttas_priv->fw_parse_variable_header =\n\t\t\t\tfw_parse_variable_header_kernel;\n\t\t\ttas_priv->fw_parse_program_data =\n\t\t\t\tfw_parse_program_data_kernel;\n\t\t\ttas_priv->fw_parse_configuration_data =\n\t\t\t\tfw_parse_configuration_data_kernel;\n\t\t\ttas_priv->tasdevice_load_block =\n\t\t\t\ttasdevice_load_block_kernel;\n\t\t} else {\n\t\t\tswitch (ppcver) {\n\t\t\tcase 0x00:\n\t\t\t\ttas_priv->fw_parse_variable_header =\n\t\t\t\t\tfw_parse_variable_header_git;\n\t\t\t\ttas_priv->fw_parse_program_data =\n\t\t\t\t\tfw_parse_program_data;\n\t\t\t\ttas_priv->fw_parse_configuration_data =\n\t\t\t\t\tfw_parse_configuration_data;\n\t\t\t\ttas_priv->tasdevice_load_block =\n\t\t\t\t\ttasdevice_load_block;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\t\"%s: PPCVer must be 0x0 or 0x%02x\",\n\t\t\t\t\t__func__, PPC3_VERSION);\n\t\t\t\tdev_err(tas_priv->dev, \" Current:0x%02x\\n\",\n\t\t\t\t\tppcver);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"DrvVer must be 0x0, 0x230 or above 0x230 \");\n\t\tdev_err(tas_priv->dev, \"current is 0x%02x\\n\", drv_ver);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nstatic int load_calib_data(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_data *dev_data)\n{\n\tstruct tasdev_blk *block;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < dev_data->nr_blk; i++) {\n\t\tblock = &(dev_data->dev_blks[i]);\n\t\tret = tasdevice_load_block(tas_priv, block);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fw_parse_header(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw, const struct firmware *fmw, int offset)\n{\n\tstruct tasdevice_dspfw_hdr *fw_hdr = &(tas_fmw->fw_hdr);\n\tstruct tasdevice_fw_fixed_hdr *fw_fixed_hdr = &(fw_hdr->fixed_hdr);\n\tconst unsigned char magic_number[] = { 0x35, 0x35, 0x35, 0x32 };\n\tconst unsigned char *buf = (unsigned char *)fmw->data;\n\n\tif (offset + 92 > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: File Size error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (memcmp(&buf[offset], magic_number, 4)) {\n\t\tdev_err(tas_priv->dev, \"%s: Magic num NOT match\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 4;\n\n\t \n\tfw_fixed_hdr->fwsize = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 4;\n\tif (fw_fixed_hdr->fwsize != fmw->size) {\n\t\tdev_err(tas_priv->dev, \"File size not match, %lu %u\",\n\t\t\t(unsigned long)fmw->size, fw_fixed_hdr->fwsize);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\toffset += 4;\n\tfw_fixed_hdr->ppcver = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 8;\n\tfw_fixed_hdr->drv_ver = be32_to_cpup((__be32 *)&buf[offset]);\n\toffset += 72;\n\n out:\n\treturn offset;\n}\n\nstatic int fw_parse_variable_hdr_cal(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw, const struct firmware *fmw, int offset)\n{\n\tstruct tasdevice_dspfw_hdr *fw_hdr = &(tas_fmw->fw_hdr);\n\n\toffset = fw_parse_variable_hdr(tas_priv, fw_hdr, fmw, offset);\n\tif (offset < 0)\n\t\tgoto out;\n\tif (fw_hdr->ndev != 1) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: calbin must be 1, but currently ndev(%u)\\n\",\n\t\t\t__func__, fw_hdr->ndev);\n\t\toffset = -EINVAL;\n\t}\n\nout:\n\treturn offset;\n}\n\n \nstatic int fw_parse_calibration_data(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_fw *tas_fmw, const struct firmware *fmw, int offset)\n{\n\tstruct tasdevice_calibration *calibration;\n\tunsigned char *data = (unsigned char *)fmw->data;\n\tunsigned int i, n;\n\n\tif (offset + 2 > fmw->size) {\n\t\tdev_err(tas_priv->dev, \"%s: Calibrations error\\n\", __func__);\n\t\toffset = -EINVAL;\n\t\tgoto out;\n\t}\n\ttas_fmw->nr_calibrations = be16_to_cpup((__be16 *)&data[offset]);\n\toffset += 2;\n\n\tif (tas_fmw->nr_calibrations != 1) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: only supports one calibration (%d)!\\n\",\n\t\t\t__func__, tas_fmw->nr_calibrations);\n\t\tgoto out;\n\t}\n\n\ttas_fmw->calibrations = kcalloc(tas_fmw->nr_calibrations,\n\t\tsizeof(struct tasdevice_calibration), GFP_KERNEL);\n\tif (!tas_fmw->calibrations) {\n\t\toffset = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < tas_fmw->nr_calibrations; i++) {\n\t\tif (offset + 64 > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"Calibrations error\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tcalibration = &(tas_fmw->calibrations[i]);\n\t\toffset += 64;\n\n\t\tn = strlen((char *)&data[offset]);\n\t\t \n\t\tn += 3;\n\t\tif (offset + n > fmw->size) {\n\t\t\tdev_err(tas_priv->dev, \"Description err\\n\");\n\t\t\toffset = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += n;\n\n\t\toffset = fw_parse_data(tas_fmw, &(calibration->dev_data), fmw,\n\t\t\toffset);\n\t\tif (offset < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\treturn offset;\n}\n\nint tas2781_load_calibration(void *context, char *file_name,\n\tunsigned short i)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *)context;\n\tstruct tasdevice *tasdev = &(tas_priv->tasdevice[i]);\n\tconst struct firmware *fw_entry;\n\tstruct tasdevice_fw *tas_fmw;\n\tstruct firmware fmw;\n\tint offset = 0;\n\tint ret;\n\n\tret = request_firmware(&fw_entry, file_name, tas_priv->dev);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"%s: Request firmware %s failed\\n\",\n\t\t\t__func__, file_name);\n\t\tgoto out;\n\t}\n\n\tif (!fw_entry->size) {\n\t\tdev_err(tas_priv->dev, \"%s: file read error: size = %lu\\n\",\n\t\t\t__func__, (unsigned long)fw_entry->size);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfmw.size = fw_entry->size;\n\tfmw.data = fw_entry->data;\n\n\ttas_fmw = tasdev->cali_data_fmw = kzalloc(sizeof(struct tasdevice_fw),\n\t\tGFP_KERNEL);\n\tif (!tasdev->cali_data_fmw) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttas_fmw->dev = tas_priv->dev;\n\toffset = fw_parse_header(tas_priv, tas_fmw, &fmw, offset);\n\tif (offset == -EINVAL) {\n\t\tdev_err(tas_priv->dev, \"fw_parse_header EXIT!\\n\");\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = fw_parse_variable_hdr_cal(tas_priv, tas_fmw, &fmw, offset);\n\tif (offset == -EINVAL) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: fw_parse_variable_header_cal EXIT!\\n\", __func__);\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = fw_parse_program_data(tas_priv, tas_fmw, &fmw, offset);\n\tif (offset < 0) {\n\t\tdev_err(tas_priv->dev, \"fw_parse_program_data EXIT!\\n\");\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = fw_parse_configuration_data(tas_priv, tas_fmw, &fmw, offset);\n\tif (offset < 0) {\n\t\tdev_err(tas_priv->dev, \"fw_parse_configuration_data EXIT!\\n\");\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = fw_parse_calibration_data(tas_priv, tas_fmw, &fmw, offset);\n\tif (offset < 0) {\n\t\tdev_err(tas_priv->dev, \"fw_parse_calibration_data EXIT!\\n\");\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\nout:\n\tif (fw_entry)\n\t\trelease_firmware(fw_entry);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(tas2781_load_calibration, SND_SOC_TAS2781_FMWLIB);\n\nstatic int tasdevice_dspfw_ready(const struct firmware *fmw,\n\tvoid *context)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_fw_fixed_hdr *fw_fixed_hdr;\n\tstruct tasdevice_fw *tas_fmw;\n\tint offset = 0;\n\tint ret = 0;\n\n\tif (!fmw || !fmw->data) {\n\t\tdev_err(tas_priv->dev, \"%s: Failed to read firmware %s\\n\",\n\t\t\t__func__, tas_priv->coef_binaryname);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttas_priv->fmw = kzalloc(sizeof(struct tasdevice_fw), GFP_KERNEL);\n\tif (!tas_priv->fmw) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\ttas_fmw = tas_priv->fmw;\n\ttas_fmw->dev = tas_priv->dev;\n\toffset = fw_parse_header(tas_priv, tas_fmw, fmw, offset);\n\n\tif (offset == -EINVAL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfw_fixed_hdr = &(tas_fmw->fw_hdr.fixed_hdr);\n\t \n\tswitch (fw_fixed_hdr->drv_ver) {\n\tcase 0x301:\n\tcase 0x302:\n\tcase 0x502:\n\tcase 0x503:\n\t\ttas_priv->fw_parse_variable_header =\n\t\t\tfw_parse_variable_header_kernel;\n\t\ttas_priv->fw_parse_program_data =\n\t\t\tfw_parse_program_data_kernel;\n\t\ttas_priv->fw_parse_configuration_data =\n\t\t\tfw_parse_configuration_data_kernel;\n\t\ttas_priv->tasdevice_load_block =\n\t\t\ttasdevice_load_block_kernel;\n\t\tbreak;\n\tcase 0x202:\n\tcase 0x400:\n\t\ttas_priv->fw_parse_variable_header =\n\t\t\tfw_parse_variable_header_git;\n\t\ttas_priv->fw_parse_program_data =\n\t\t\tfw_parse_program_data;\n\t\ttas_priv->fw_parse_configuration_data =\n\t\t\tfw_parse_configuration_data;\n\t\ttas_priv->tasdevice_load_block =\n\t\t\ttasdevice_load_block;\n\t\tbreak;\n\tdefault:\n\t\tret = dspfw_default_callback(tas_priv,\n\t\t\tfw_fixed_hdr->drv_ver, fw_fixed_hdr->ppcver);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\toffset = tas_priv->fw_parse_variable_header(tas_priv, fmw, offset);\n\tif (offset < 0) {\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = tas_priv->fw_parse_program_data(tas_priv, tas_fmw, fmw,\n\t\toffset);\n\tif (offset < 0) {\n\t\tret = offset;\n\t\tgoto out;\n\t}\n\toffset = tas_priv->fw_parse_configuration_data(tas_priv,\n\t\ttas_fmw, fmw, offset);\n\tif (offset < 0)\n\t\tret = offset;\n\nout:\n\treturn ret;\n}\n\nint tasdevice_dsp_parser(void *context)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *)context;\n\tconst struct firmware *fw_entry;\n\tint ret;\n\n\tret = request_firmware(&fw_entry, tas_priv->coef_binaryname,\n\t\ttas_priv->dev);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"%s: load %s error\\n\", __func__,\n\t\t\ttas_priv->coef_binaryname);\n\t\tgoto out;\n\t}\n\n\tret = tasdevice_dspfw_ready(fw_entry, tas_priv);\n\trelease_firmware(fw_entry);\n\tfw_entry = NULL;\n\nout:\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_dsp_parser, SND_SOC_TAS2781_FMWLIB);\n\nstatic void tas2781_clear_calfirmware(struct tasdevice_fw *tas_fmw)\n{\n\tstruct tasdevice_calibration *calibration;\n\tstruct tasdev_blk *block;\n\tstruct tasdevice_data *im;\n\tunsigned int blks;\n\tint i;\n\n\tif (!tas_fmw->calibrations)\n\t\tgoto out;\n\n\tfor (i = 0; i < tas_fmw->nr_calibrations; i++) {\n\t\tcalibration = &(tas_fmw->calibrations[i]);\n\t\tif (!calibration)\n\t\t\tcontinue;\n\n\t\tim = &(calibration->dev_data);\n\n\t\tif (!im->dev_blks)\n\t\t\tcontinue;\n\n\t\tfor (blks = 0; blks < im->nr_blk; blks++) {\n\t\t\tblock = &(im->dev_blks[blks]);\n\t\t\tif (!block)\n\t\t\t\tcontinue;\n\t\t\tkfree(block->data);\n\t\t}\n\t\tkfree(im->dev_blks);\n\t}\n\tkfree(tas_fmw->calibrations);\nout:\n\tkfree(tas_fmw);\n}\n\nvoid tasdevice_calbin_remove(void *context)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice *tasdev;\n\tint i;\n\n\tif (!tas_priv)\n\t\treturn;\n\n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\ttasdev = &(tas_priv->tasdevice[i]);\n\t\tif (!tasdev->cali_data_fmw)\n\t\t\tcontinue;\n\t\ttas2781_clear_calfirmware(tasdev->cali_data_fmw);\n\t\ttasdev->cali_data_fmw = NULL;\n\t}\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_calbin_remove, SND_SOC_TAS2781_FMWLIB);\n\nvoid tasdevice_config_info_remove(void *context)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_rca *rca = &(tas_priv->rcabin);\n\tstruct tasdevice_config_info **ci = rca->cfg_info;\n\tint i, j;\n\n\tif (!ci)\n\t\treturn;\n\tfor (i = 0; i < rca->ncfgs; i++) {\n\t\tif (!ci[i])\n\t\t\tcontinue;\n\t\tif (ci[i]->blk_data) {\n\t\t\tfor (j = 0; j < (int)ci[i]->real_nblocks; j++) {\n\t\t\t\tif (!ci[i]->blk_data[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tkfree(ci[i]->blk_data[j]->regdata);\n\t\t\t\tkfree(ci[i]->blk_data[j]);\n\t\t\t}\n\t\t\tkfree(ci[i]->blk_data);\n\t\t}\n\t\tkfree(ci[i]);\n\t}\n\tkfree(ci);\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_config_info_remove, SND_SOC_TAS2781_FMWLIB);\n\nstatic int tasdevice_load_data(struct tasdevice_priv *tas_priv,\n\tstruct tasdevice_data *dev_data)\n{\n\tstruct tasdev_blk *block;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < dev_data->nr_blk; i++) {\n\t\tblock = &(dev_data->dev_blks[i]);\n\t\tret = tas_priv->tasdevice_load_block(tas_priv, block);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint tasdevice_select_tuningprm_cfg(void *context, int prm_no,\n\tint cfg_no, int rca_conf_no)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_rca *rca = &(tas_priv->rcabin);\n\tstruct tasdevice_config_info **cfg_info = rca->cfg_info;\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tstruct tasdevice_prog *program;\n\tstruct tasdevice_config *conf;\n\tint prog_status = 0;\n\tint status, i;\n\n\tif (!tas_fmw) {\n\t\tdev_err(tas_priv->dev, \"%s: Firmware is NULL\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (cfg_no >= tas_fmw->nr_configurations) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: cfg(%d) is not in range of conf %u\\n\",\n\t\t\t__func__, cfg_no, tas_fmw->nr_configurations);\n\t\tgoto out;\n\t}\n\n\tif (prm_no >= tas_fmw->nr_programs) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: prm(%d) is not in range of Programs %u\\n\",\n\t\t\t__func__, prm_no, tas_fmw->nr_programs);\n\t\tgoto out;\n\t}\n\n\tif (rca_conf_no >= rca->ncfgs || rca_conf_no < 0 ||\n\t\t!cfg_info) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"conf_no:%d should be in range from 0 to %u\\n\",\n\t\t\trca_conf_no, rca->ncfgs-1);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0, prog_status = 0; i < tas_priv->ndev; i++) {\n\t\tif (cfg_info[rca_conf_no]->active_dev & (1 << i)) {\n\t\t\tif (prm_no >= 0\n\t\t\t\t&& (tas_priv->tasdevice[i].cur_prog != prm_no\n\t\t\t\t|| tas_priv->force_fwload_status)) {\n\t\t\t\ttas_priv->tasdevice[i].cur_conf = -1;\n\t\t\t\ttas_priv->tasdevice[i].is_loading = true;\n\t\t\t\tprog_status++;\n\t\t\t}\n\t\t} else\n\t\t\ttas_priv->tasdevice[i].is_loading = false;\n\t\ttas_priv->tasdevice[i].is_loaderr = false;\n\t}\n\n\tif (prog_status) {\n\t\tprogram = &(tas_fmw->programs[prm_no]);\n\t\ttasdevice_load_data(tas_priv, &(program->dev_data));\n\t\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\t\tif (tas_priv->tasdevice[i].is_loaderr == true)\n\t\t\t\tcontinue;\n\t\t\telse if (tas_priv->tasdevice[i].is_loaderr == false\n\t\t\t\t&& tas_priv->tasdevice[i].is_loading == true) {\n\t\t\t\tstruct tasdevice_fw *cal_fmw =\n\t\t\t\t\ttas_priv->tasdevice[i].cali_data_fmw;\n\n\t\t\t\tif (cal_fmw) {\n\t\t\t\t\tstruct tasdevice_calibration\n\t\t\t\t\t\t*cal = cal_fmw->calibrations;\n\n\t\t\t\t\tif (cal)\n\t\t\t\t\t\tload_calib_data(tas_priv,\n\t\t\t\t\t\t\t&(cal->dev_data));\n\t\t\t\t}\n\t\t\t\ttas_priv->tasdevice[i].cur_prog = prm_no;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0, status = 0; i < tas_priv->ndev; i++) {\n\t\tif (cfg_no >= 0\n\t\t\t&& tas_priv->tasdevice[i].cur_conf != cfg_no\n\t\t\t&& (cfg_info[rca_conf_no]->active_dev & (1 << i))\n\t\t\t&& (tas_priv->tasdevice[i].is_loaderr == false)) {\n\t\t\tstatus++;\n\t\t\ttas_priv->tasdevice[i].is_loading = true;\n\t\t} else\n\t\t\ttas_priv->tasdevice[i].is_loading = false;\n\t}\n\n\tif (status) {\n\t\tconf = &(tas_fmw->configs[cfg_no]);\n\t\tstatus = 0;\n\t\ttasdevice_load_data(tas_priv, &(conf->dev_data));\n\t\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\t\tif (tas_priv->tasdevice[i].is_loaderr == true) {\n\t\t\t\tstatus |= 1 << (i + 4);\n\t\t\t\tcontinue;\n\t\t\t} else if (tas_priv->tasdevice[i].is_loaderr == false\n\t\t\t\t&& tas_priv->tasdevice[i].is_loading == true)\n\t\t\t\ttas_priv->tasdevice[i].cur_conf = cfg_no;\n\t\t}\n\t} else\n\t\tdev_dbg(tas_priv->dev, \"%s: Unneeded loading dsp conf %d\\n\",\n\t\t\t__func__, cfg_no);\n\n\tstatus |= cfg_info[rca_conf_no]->active_dev;\n\nout:\n\treturn prog_status;\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_select_tuningprm_cfg,\n\tSND_SOC_TAS2781_FMWLIB);\n\nint tasdevice_prmg_load(void *context, int prm_no)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tstruct tasdevice_prog *program;\n\tint prog_status = 0;\n\tint i;\n\n\tif (!tas_fmw) {\n\t\tdev_err(tas_priv->dev, \"%s: Firmware is NULL\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (prm_no >= tas_fmw->nr_programs) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: prm(%d) is not in range of Programs %u\\n\",\n\t\t\t__func__, prm_no, tas_fmw->nr_programs);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0, prog_status = 0; i < tas_priv->ndev; i++) {\n\t\tif (prm_no >= 0 && tas_priv->tasdevice[i].cur_prog != prm_no) {\n\t\t\ttas_priv->tasdevice[i].cur_conf = -1;\n\t\t\ttas_priv->tasdevice[i].is_loading = true;\n\t\t\tprog_status++;\n\t\t}\n\t}\n\n\tif (prog_status) {\n\t\tprogram = &(tas_fmw->programs[prm_no]);\n\t\ttasdevice_load_data(tas_priv, &(program->dev_data));\n\t\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\t\tif (tas_priv->tasdevice[i].is_loaderr == true)\n\t\t\t\tcontinue;\n\t\t\telse if (tas_priv->tasdevice[i].is_loaderr == false\n\t\t\t\t&& tas_priv->tasdevice[i].is_loading == true)\n\t\t\t\ttas_priv->tasdevice[i].cur_prog = prm_no;\n\t\t}\n\t}\n\nout:\n\treturn prog_status;\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_prmg_load, SND_SOC_TAS2781_FMWLIB);\n\nint tasdevice_prmg_calibdata_load(void *context, int prm_no)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tstruct tasdevice_prog *program;\n\tint prog_status = 0;\n\tint i;\n\n\tif (!tas_fmw) {\n\t\tdev_err(tas_priv->dev, \"%s: Firmware is NULL\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (prm_no >= tas_fmw->nr_programs) {\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"%s: prm(%d) is not in range of Programs %u\\n\",\n\t\t\t__func__, prm_no, tas_fmw->nr_programs);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0, prog_status = 0; i < tas_priv->ndev; i++) {\n\t\tif (prm_no >= 0 && tas_priv->tasdevice[i].cur_prog != prm_no) {\n\t\t\ttas_priv->tasdevice[i].cur_conf = -1;\n\t\t\ttas_priv->tasdevice[i].is_loading = true;\n\t\t\tprog_status++;\n\t\t}\n\t\ttas_priv->tasdevice[i].is_loaderr = false;\n\t}\n\n\tif (prog_status) {\n\t\tprogram = &(tas_fmw->programs[prm_no]);\n\t\ttasdevice_load_data(tas_priv, &(program->dev_data));\n\t\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\t\tif (tas_priv->tasdevice[i].is_loaderr == true)\n\t\t\t\tcontinue;\n\t\t\telse if (tas_priv->tasdevice[i].is_loaderr == false\n\t\t\t\t&& tas_priv->tasdevice[i].is_loading == true) {\n\t\t\t\tstruct tasdevice_fw *cal_fmw =\n\t\t\t\t\ttas_priv->tasdevice[i].cali_data_fmw;\n\n\t\t\t\tif (cal_fmw) {\n\t\t\t\t\tstruct tasdevice_calibration *cal =\n\t\t\t\t\t\tcal_fmw->calibrations;\n\n\t\t\t\t\tif (cal)\n\t\t\t\t\t\tload_calib_data(tas_priv,\n\t\t\t\t\t\t\t&(cal->dev_data));\n\t\t\t\t}\n\t\t\t\ttas_priv->tasdevice[i].cur_prog = prm_no;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn prog_status;\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_prmg_calibdata_load,\n\tSND_SOC_TAS2781_FMWLIB);\n\nvoid tasdevice_tuning_switch(void *context, int state)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\tstruct tasdevice_fw *tas_fmw = tas_priv->fmw;\n\tint profile_cfg_id = tas_priv->rcabin.profile_cfg_id;\n\n\tif (tas_priv->fw_state == TASDEVICE_DSP_FW_FAIL) {\n\t\tdev_err(tas_priv->dev, \"DSP bin file not loaded\\n\");\n\t\treturn;\n\t}\n\n\tif (state == 0) {\n\t\tif (tas_priv->cur_prog < tas_fmw->nr_programs) {\n\t\t\t \n\t\t\tprofile_cfg_id = tas_priv->rcabin.profile_cfg_id;\n\t\t\ttasdevice_select_tuningprm_cfg(tas_priv,\n\t\t\t\ttas_priv->cur_prog, tas_priv->cur_conf,\n\t\t\t\tprofile_cfg_id);\n\t\t}\n\n\t\ttasdevice_select_cfg_blk(tas_priv, profile_cfg_id,\n\t\t\tTASDEVICE_BIN_BLK_PRE_POWER_UP);\n\t} else\n\t\ttasdevice_select_cfg_blk(tas_priv, profile_cfg_id,\n\t\t\tTASDEVICE_BIN_BLK_PRE_SHUTDOWN);\n}\nEXPORT_SYMBOL_NS_GPL(tasdevice_tuning_switch,\n\tSND_SOC_TAS2781_FMWLIB);\n\nMODULE_DESCRIPTION(\"Texas Firmware Support\");\nMODULE_AUTHOR(\"Shenghao Ding, TI, <shenghao-ding@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}