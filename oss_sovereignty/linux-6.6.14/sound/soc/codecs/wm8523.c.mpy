{
  "module_name": "wm8523.c",
  "hash_id": "1f6e28881ebff7649c356ec3f50a7b7d75ed5fd1f738cb3ef9d4fee7fd93d81d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8523.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8523.h\"\n\n#define WM8523_NUM_SUPPLIES 2\nstatic const char *wm8523_supply_names[WM8523_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"LINEVDD\",\n};\n\n#define WM8523_NUM_RATES 7\n\n \nstruct wm8523_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8523_NUM_SUPPLIES];\n\tunsigned int sysclk;\n\tunsigned int rate_constraint_list[WM8523_NUM_RATES];\n\tstruct snd_pcm_hw_constraint_list rate_constraint;\n};\n\nstatic const struct reg_default wm8523_reg_defaults[] = {\n\t{ 2, 0x0000 },      \n\t{ 3, 0x1812 },      \n\t{ 4, 0x0000 },      \n\t{ 5, 0x0001 },      \n\t{ 6, 0x0190 },      \n\t{ 7, 0x0190 },      \n\t{ 8, 0x0000 },      \n};\n\nstatic bool wm8523_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8523_DEVICE_ID:\n\tcase WM8523_REVISION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -10000, 25, 0);\n\nstatic const char *wm8523_zd_count_text[] = {\n\t\"1024\",\n\t\"2048\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(wm8523_zc_count, WM8523_ZERO_DETECT, 0,\n\t\t\t    wm8523_zd_count_text);\n\nstatic const struct snd_kcontrol_new wm8523_controls[] = {\nSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8523_DAC_GAINL, WM8523_DAC_GAINR,\n\t\t 0, 448, 0, dac_tlv),\nSOC_SINGLE(\"ZC Switch\", WM8523_DAC_CTRL3, 4, 1, 0),\nSOC_SINGLE(\"Playback Deemphasis Switch\", WM8523_AIF_CTRL1, 8, 1, 0),\nSOC_DOUBLE(\"Playback Switch\", WM8523_DAC_CTRL3, 2, 3, 1, 1),\nSOC_SINGLE(\"Volume Ramp Up Switch\", WM8523_DAC_CTRL3, 1, 1, 0),\nSOC_SINGLE(\"Volume Ramp Down Switch\", WM8523_DAC_CTRL3, 0, 1, 0),\nSOC_ENUM(\"Zero Detect Count\", wm8523_zc_count),\n};\n\nstatic const struct snd_soc_dapm_widget wm8523_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8523_dapm_routes[] = {\n\t{ \"LINEVOUTL\", NULL, \"DAC\" },\n\t{ \"LINEVOUTR\", NULL, \"DAC\" },\n};\n\nstatic const struct {\n\tint value;\n\tint ratio;\n} lrclk_ratios[WM8523_NUM_RATES] = {\n\t{ 1, 128 },\n\t{ 2, 192 },\n\t{ 3, 256 },\n\t{ 4, 384 },\n\t{ 5, 512 },\n\t{ 6, 768 },\n\t{ 7, 1152 },\n};\n\nstatic const struct {\n\tint value;\n\tint ratio;\n} bclk_ratios[] = {\n\t{ 2, 32 },\n\t{ 3, 64 },\n\t{ 4, 128 },\n};\n\nstatic int wm8523_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8523_priv *wm8523 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!wm8523->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"No MCLK configured, call set_sysclk() on init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &wm8523->rate_constraint);\n\n\treturn 0;\n}\n\nstatic int wm8523_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8523_priv *wm8523 = snd_soc_component_get_drvdata(component);\n\tint i;\n\tu16 aifctrl1 = snd_soc_component_read(component, WM8523_AIF_CTRL1);\n\tu16 aifctrl2 = snd_soc_component_read(component, WM8523_AIF_CTRL2);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {\n\t\tif (wm8523->sysclk / params_rate(params) ==\n\t\t    lrclk_ratios[i].ratio)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == ARRAY_SIZE(lrclk_ratios)) {\n\t\tdev_err(component->dev, \"MCLK/fs ratio %d unsupported\\n\",\n\t\t\twm8523->sysclk / params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\taifctrl2 &= ~WM8523_SR_MASK;\n\taifctrl2 |= lrclk_ratios[i].value;\n\n\tif (aifctrl1 & WM8523_AIF_MSTR) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(bclk_ratios); i++)\n\t\t\tif (params_width(params) * 2 <= bclk_ratios[i].ratio)\n\t\t\t\tbreak;\n\n\t\tif (i == ARRAY_SIZE(bclk_ratios)) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"No matching BCLK/fs ratio for word length %d\\n\",\n\t\t\t\tparams_width(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taifctrl2 &= ~WM8523_BCLKDIV_MASK;\n\t\taifctrl2 |= bclk_ratios[i].value << WM8523_BCLKDIV_SHIFT;\n\t}\n\n\taifctrl1 &= ~WM8523_WL_MASK;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\taifctrl1 |= 0x8;\n\t\tbreak;\n\tcase 24:\n\t\taifctrl1 |= 0x10;\n\t\tbreak;\n\tcase 32:\n\t\taifctrl1 |= 0x18;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8523_AIF_CTRL1, aifctrl1);\n\tsnd_soc_component_write(component, WM8523_AIF_CTRL2, aifctrl2);\n\n\treturn 0;\n}\n\nstatic int wm8523_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8523_priv *wm8523 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint i;\n\n\twm8523->sysclk = freq;\n\n\twm8523->rate_constraint.count = 0;\n\tfor (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {\n\t\tval = freq / lrclk_ratios[i].ratio;\n\t\t \n\t\tswitch (val) {\n\t\tcase 8000:\n\t\tcase 11025:\n\t\tcase 16000:\n\t\tcase 22050:\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\tcase 64000:\n\t\tcase 88200:\n\t\tcase 96000:\n\t\tcase 176400:\n\t\tcase 192000:\n\t\t\tdev_dbg(component->dev, \"Supported sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t\twm8523->rate_constraint_list[i] = val;\n\t\t\twm8523->rate_constraint.count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(component->dev, \"Skipping sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t}\n\t}\n\n\t \n\tif (wm8523->rate_constraint.count == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n\nstatic int wm8523_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 aifctrl1 = snd_soc_component_read(component, WM8523_AIF_CTRL1);\n\n\taifctrl1 &= ~(WM8523_BCLK_INV_MASK | WM8523_LRCLK_INV_MASK |\n\t\t      WM8523_FMT_MASK | WM8523_AIF_MSTR_MASK);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taifctrl1 |= WM8523_AIF_MSTR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taifctrl1 |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taifctrl1 |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taifctrl1 |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taifctrl1 |= 0x0023;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\taifctrl1 |= WM8523_BCLK_INV | WM8523_LRCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\taifctrl1 |= WM8523_BCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\taifctrl1 |= WM8523_LRCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8523_AIF_CTRL1, aifctrl1);\n\n\treturn 0;\n}\n\nstatic int wm8523_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8523_priv *wm8523 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8523_PSCTRL1,\n\t\t\t\t    WM8523_SYS_ENA_MASK, 3);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8523->supplies),\n\t\t\t\t\t\t    wm8523->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\t\t\tregcache_sync(wm8523->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8523_PSCTRL1,\n\t\t\t\t\t    WM8523_SYS_ENA_MASK, 1);\n\n\t\t\tmsleep(100);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8523_PSCTRL1,\n\t\t\t\t    WM8523_SYS_ENA_MASK, 2);\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8523_PSCTRL1,\n\t\t\t\t    WM8523_SYS_ENA_MASK, 0);\n\t\tmsleep(100);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8523->supplies),\n\t\t\t\t       wm8523->supplies);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8523_RATES SNDRV_PCM_RATE_8000_192000\n\n#define WM8523_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8523_dai_ops = {\n\t.startup\t= wm8523_startup,\n\t.hw_params\t= wm8523_hw_params,\n\t.set_sysclk\t= wm8523_set_dai_sysclk,\n\t.set_fmt\t= wm8523_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver wm8523_dai = {\n\t.name = \"wm8523-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,   \n\t\t.channels_max = 2,\n\t\t.rates = WM8523_RATES,\n\t\t.formats = WM8523_FORMATS,\n\t},\n\t.ops = &wm8523_dai_ops,\n};\n\nstatic int wm8523_probe(struct snd_soc_component *component)\n{\n\tstruct wm8523_priv *wm8523 = snd_soc_component_get_drvdata(component);\n\n\twm8523->rate_constraint.list = &wm8523->rate_constraint_list[0];\n\twm8523->rate_constraint.count =\n\t\tARRAY_SIZE(wm8523->rate_constraint_list);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8523_DAC_GAINR,\n\t\t\t    WM8523_DACR_VU, WM8523_DACR_VU);\n\tsnd_soc_component_update_bits(component, WM8523_DAC_CTRL3, WM8523_ZC, WM8523_ZC);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8523 = {\n\t.probe\t\t\t= wm8523_probe,\n\t.set_bias_level\t\t= wm8523_set_bias_level,\n\t.controls\t\t= wm8523_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8523_controls),\n\t.dapm_widgets\t\t= wm8523_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8523_dapm_widgets),\n\t.dapm_routes\t\t= wm8523_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8523_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8523_of_match[] = {\n\t{ .compatible = \"wlf,wm8523\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, wm8523_of_match);\n\nstatic const struct regmap_config wm8523_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = WM8523_ZERO_DETECT,\n\n\t.reg_defaults = wm8523_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8523_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8523_volatile_register,\n};\n\nstatic int wm8523_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8523_priv *wm8523;\n\tunsigned int val;\n\tint ret, i;\n\n\twm8523 = devm_kzalloc(&i2c->dev, sizeof(struct wm8523_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8523 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8523->regmap = devm_regmap_init_i2c(i2c, &wm8523_regmap);\n\tif (IS_ERR(wm8523->regmap)) {\n\t\tret = PTR_ERR(wm8523->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to create regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8523->supplies); i++)\n\t\twm8523->supplies[i].supply = wm8523_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8523->supplies),\n\t\t\t\t      wm8523->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8523->supplies),\n\t\t\t\t    wm8523->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm8523->regmap, WM8523_DEVICE_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read ID register\\n\");\n\t\tgoto err_enable;\n\t}\n\tif (val != 0x8523) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM8523, ID is %x\\n\", ret);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = regmap_read(wm8523->regmap, WM8523_REVISION, &val);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read revision register\\n\");\n\t\tgoto err_enable;\n\t}\n\tdev_info(&i2c->dev, \"revision %c\\n\",\n\t\t (val & WM8523_CHIP_REV_MASK) + 'A');\n\n\tret = regmap_write(wm8523->regmap, WM8523_DEVICE_ID, 0x8523);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to reset device: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8523->supplies), wm8523->supplies);\n\n\ti2c_set_clientdata(i2c, wm8523);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8523, &wm8523_dai, 1);\n\n\treturn ret;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8523->supplies), wm8523->supplies);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8523_i2c_id[] = {\n\t{ \"wm8523\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8523_i2c_id);\n\nstatic struct i2c_driver wm8523_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8523\",\n\t\t.of_match_table = wm8523_of_match,\n\t},\n\t.probe = wm8523_i2c_probe,\n\t.id_table = wm8523_i2c_id,\n};\n\nmodule_i2c_driver(wm8523_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8523 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}