{
  "module_name": "wm8993.c",
  "hash_id": "ed010e70294798daf0132e2f08e274bcac977902c31b40378971f9f340c5dda4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8993.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/wm8993.h>\n\n#include \"wm8993.h\"\n#include \"wm_hubs.h\"\n\n#define WM8993_NUM_SUPPLIES 6\nstatic const char *wm8993_supply_names[WM8993_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"CPVDD\",\n\t\"SPKVDD\",\n};\n\nstatic const struct reg_default wm8993_reg_defaults[] = {\n\t{ 1,   0x0000 },      \n\t{ 2,   0x6000 },      \n\t{ 3,   0x0000 },      \n\t{ 4,   0x4050 },      \n\t{ 5,   0x4000 },      \n\t{ 6,   0x01C8 },      \n\t{ 7,   0x0000 },      \n\t{ 8,   0x0000 },      \n\t{ 9,   0x0040 },      \n\t{ 10,  0x0004 },      \n\t{ 11,  0x00C0 },      \n\t{ 12,  0x00C0 },      \n\t{ 13,  0x0000 },      \n\t{ 14,  0x0300 },      \n\t{ 15,  0x00C0 },      \n\t{ 16,  0x00C0 },      \n\t{ 18,  0x0000 },      \n\t{ 19,  0x0010 },      \n\t{ 20,  0x0000 },      \n\t{ 21,  0x0000 },      \n\t{ 22,  0x8000 },      \n\t{ 23,  0x0800 },      \n\t{ 24,  0x008B },      \n\t{ 25,  0x008B },      \n\t{ 26,  0x008B },      \n\t{ 27,  0x008B },      \n\t{ 28,  0x006D },      \n\t{ 29,  0x006D },      \n\t{ 30,  0x0066 },      \n\t{ 31,  0x0020 },      \n\t{ 32,  0x0079 },      \n\t{ 33,  0x0079 },      \n\t{ 34,  0x0003 },      \n\t{ 35,  0x0003 },      \n\t{ 36,  0x0011 },      \n\t{ 37,  0x0100 },      \n\t{ 38,  0x0079 },      \n\t{ 39,  0x0079 },      \n\t{ 40,  0x0000 },      \n\t{ 41,  0x0000 },      \n\t{ 42,  0x0000 },      \n\t{ 43,  0x0000 },      \n\t{ 44,  0x0000 },      \n\t{ 45,  0x0000 },      \n\t{ 46,  0x0000 },      \n\t{ 47,  0x0000 },      \n\t{ 48,  0x0000 },      \n\t{ 49,  0x0000 },      \n\t{ 50,  0x0000 },      \n\t{ 51,  0x0000 },      \n\t{ 52,  0x0000 },      \n\t{ 53,  0x0000 },      \n\t{ 54,  0x0000 },      \n\t{ 55,  0x0000 },      \n\t{ 56,  0x0000 },      \n\t{ 57,  0x0000 },      \n\t{ 58,  0x0000 },      \n\t{ 60,  0x0000 },      \n\t{ 61,  0x0000 },      \n\t{ 62,  0x0000 },      \n\t{ 63,  0x2EE0 },      \n\t{ 64,  0x0002 },      \n\t{ 65,  0x2287 },      \n\t{ 66,  0x025F },      \n\t{ 67,  0x0000 },      \n\t{ 69,  0x0002 },      \n\t{ 70,  0x0000 },      \n\t{ 71,  0x0000 },      \n\t{ 72,  0x0000 },      \n\t{ 73,  0x0000 },      \n\t{ 74,  0x0000 },      \n\t{ 75,  0x0000 },      \n\t{ 76,  0x1F25 },      \n\t{ 81,  0x0000 },      \n\t{ 85,  0x054A },      \n\t{ 87,  0x0000 },      \n\t{ 96,  0x0100 },      \n\t{ 98,  0x0000 },      \n\t{ 99,  0x000C },      \n\t{ 100, 0x000C },      \n\t{ 101, 0x000C },      \n\t{ 102, 0x000C },      \n\t{ 103, 0x000C },      \n\t{ 104, 0x0FCA },      \n\t{ 105, 0x0400 },      \n\t{ 106, 0x00D8 },      \n\t{ 107, 0x1EB5 },      \n\t{ 108, 0xF145 },      \n\t{ 109, 0x0B75 },      \n\t{ 110, 0x01C5 },      \n\t{ 111, 0x1C58 },      \n\t{ 112, 0xF373 },      \n\t{ 113, 0x0A54 },      \n\t{ 114, 0x0558 },      \n\t{ 115, 0x168E },      \n\t{ 116, 0xF829 },      \n\t{ 117, 0x07AD },      \n\t{ 118, 0x1103 },      \n\t{ 119, 0x0564 },      \n\t{ 120, 0x0559 },      \n\t{ 121, 0x4000 },      \n\t{ 122, 0x0000 },      \n\t{ 123, 0x0F08 },      \n\t{ 124, 0x0000 },      \n\t{ 125, 0x0080 },      \n\t{ 126, 0x0000 },      \n};\n\nstatic struct {\n\tint ratio;\n\tint clk_sys_rate;\n} clk_sys_rates[] = {\n\t{ 64,   0 },\n\t{ 128,  1 },\n\t{ 192,  2 },\n\t{ 256,  3 },\n\t{ 384,  4 },\n\t{ 512,  5 },\n\t{ 768,  6 },\n\t{ 1024, 7 },\n\t{ 1408, 8 },\n\t{ 1536, 9 },\n};\n\nstatic struct {\n\tint rate;\n\tint sample_rate;\n} sample_rates[] = {\n\t{ 8000,  0  },\n\t{ 11025, 1  },\n\t{ 12000, 1  },\n\t{ 16000, 2  },\n\t{ 22050, 3  },\n\t{ 24000, 3  },\n\t{ 32000, 4  },\n\t{ 44100, 5  },\n\t{ 48000, 5  },\n};\n\nstatic struct {\n\tint div;  \n\tint bclk_div;\n} bclk_divs[] = {\n\t{ 10,  0  },\n\t{ 15,  1  },\n\t{ 20,  2  },\n\t{ 30,  3  },\n\t{ 40,  4  },\n\t{ 55,  5  },\n\t{ 60,  6  },\n\t{ 80,  7  },\n\t{ 110, 8  },\n\t{ 120, 9  },\n\t{ 160, 10 },\n\t{ 220, 11 },\n\t{ 240, 12 },\n\t{ 320, 13 },\n\t{ 440, 14 },\n\t{ 480, 15 },\n};\n\nstruct wm8993_priv {\n\tstruct wm_hubs_data hubs_data;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8993_NUM_SUPPLIES];\n\tstruct wm8993_platform_data pdata;\n\tstruct completion fll_lock;\n\tint master;\n\tint sysclk_source;\n\tint tdm_slots;\n\tint tdm_width;\n\tunsigned int mclk_rate;\n\tunsigned int sysclk_rate;\n\tunsigned int fs;\n\tunsigned int bclk;\n\tunsigned int fll_fref;\n\tunsigned int fll_fout;\n\tint fll_src;\n};\n\nstatic bool wm8993_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8993_SOFTWARE_RESET:\n\tcase WM8993_GPIO_CTRL_1:\n\tcase WM8993_DC_SERVO_0:\n\tcase WM8993_DC_SERVO_READBACK_0:\n\tcase WM8993_DC_SERVO_READBACK_1:\n\tcase WM8993_DC_SERVO_READBACK_2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8993_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8993_SOFTWARE_RESET:\n\tcase WM8993_POWER_MANAGEMENT_1:\n\tcase WM8993_POWER_MANAGEMENT_2:\n\tcase WM8993_POWER_MANAGEMENT_3:\n\tcase WM8993_AUDIO_INTERFACE_1:\n\tcase WM8993_AUDIO_INTERFACE_2:\n\tcase WM8993_CLOCKING_1:\n\tcase WM8993_CLOCKING_2:\n\tcase WM8993_AUDIO_INTERFACE_3:\n\tcase WM8993_AUDIO_INTERFACE_4:\n\tcase WM8993_DAC_CTRL:\n\tcase WM8993_LEFT_DAC_DIGITAL_VOLUME:\n\tcase WM8993_RIGHT_DAC_DIGITAL_VOLUME:\n\tcase WM8993_DIGITAL_SIDE_TONE:\n\tcase WM8993_ADC_CTRL:\n\tcase WM8993_LEFT_ADC_DIGITAL_VOLUME:\n\tcase WM8993_RIGHT_ADC_DIGITAL_VOLUME:\n\tcase WM8993_GPIO_CTRL_1:\n\tcase WM8993_GPIO1:\n\tcase WM8993_IRQ_DEBOUNCE:\n\tcase WM8993_GPIOCTRL_2:\n\tcase WM8993_GPIO_POL:\n\tcase WM8993_LEFT_LINE_INPUT_1_2_VOLUME:\n\tcase WM8993_LEFT_LINE_INPUT_3_4_VOLUME:\n\tcase WM8993_RIGHT_LINE_INPUT_1_2_VOLUME:\n\tcase WM8993_RIGHT_LINE_INPUT_3_4_VOLUME:\n\tcase WM8993_LEFT_OUTPUT_VOLUME:\n\tcase WM8993_RIGHT_OUTPUT_VOLUME:\n\tcase WM8993_LINE_OUTPUTS_VOLUME:\n\tcase WM8993_HPOUT2_VOLUME:\n\tcase WM8993_LEFT_OPGA_VOLUME:\n\tcase WM8993_RIGHT_OPGA_VOLUME:\n\tcase WM8993_SPKMIXL_ATTENUATION:\n\tcase WM8993_SPKMIXR_ATTENUATION:\n\tcase WM8993_SPKOUT_MIXERS:\n\tcase WM8993_SPKOUT_BOOST:\n\tcase WM8993_SPEAKER_VOLUME_LEFT:\n\tcase WM8993_SPEAKER_VOLUME_RIGHT:\n\tcase WM8993_INPUT_MIXER2:\n\tcase WM8993_INPUT_MIXER3:\n\tcase WM8993_INPUT_MIXER4:\n\tcase WM8993_INPUT_MIXER5:\n\tcase WM8993_INPUT_MIXER6:\n\tcase WM8993_OUTPUT_MIXER1:\n\tcase WM8993_OUTPUT_MIXER2:\n\tcase WM8993_OUTPUT_MIXER3:\n\tcase WM8993_OUTPUT_MIXER4:\n\tcase WM8993_OUTPUT_MIXER5:\n\tcase WM8993_OUTPUT_MIXER6:\n\tcase WM8993_HPOUT2_MIXER:\n\tcase WM8993_LINE_MIXER1:\n\tcase WM8993_LINE_MIXER2:\n\tcase WM8993_SPEAKER_MIXER:\n\tcase WM8993_ADDITIONAL_CONTROL:\n\tcase WM8993_ANTIPOP1:\n\tcase WM8993_ANTIPOP2:\n\tcase WM8993_MICBIAS:\n\tcase WM8993_FLL_CONTROL_1:\n\tcase WM8993_FLL_CONTROL_2:\n\tcase WM8993_FLL_CONTROL_3:\n\tcase WM8993_FLL_CONTROL_4:\n\tcase WM8993_FLL_CONTROL_5:\n\tcase WM8993_CLOCKING_3:\n\tcase WM8993_CLOCKING_4:\n\tcase WM8993_MW_SLAVE_CONTROL:\n\tcase WM8993_BUS_CONTROL_1:\n\tcase WM8993_WRITE_SEQUENCER_0:\n\tcase WM8993_WRITE_SEQUENCER_1:\n\tcase WM8993_WRITE_SEQUENCER_2:\n\tcase WM8993_WRITE_SEQUENCER_3:\n\tcase WM8993_WRITE_SEQUENCER_4:\n\tcase WM8993_WRITE_SEQUENCER_5:\n\tcase WM8993_CHARGE_PUMP_1:\n\tcase WM8993_CLASS_W_0:\n\tcase WM8993_DC_SERVO_0:\n\tcase WM8993_DC_SERVO_1:\n\tcase WM8993_DC_SERVO_3:\n\tcase WM8993_DC_SERVO_READBACK_0:\n\tcase WM8993_DC_SERVO_READBACK_1:\n\tcase WM8993_DC_SERVO_READBACK_2:\n\tcase WM8993_ANALOGUE_HP_0:\n\tcase WM8993_EQ1:\n\tcase WM8993_EQ2:\n\tcase WM8993_EQ3:\n\tcase WM8993_EQ4:\n\tcase WM8993_EQ5:\n\tcase WM8993_EQ6:\n\tcase WM8993_EQ7:\n\tcase WM8993_EQ8:\n\tcase WM8993_EQ9:\n\tcase WM8993_EQ10:\n\tcase WM8993_EQ11:\n\tcase WM8993_EQ12:\n\tcase WM8993_EQ13:\n\tcase WM8993_EQ14:\n\tcase WM8993_EQ15:\n\tcase WM8993_EQ16:\n\tcase WM8993_EQ17:\n\tcase WM8993_EQ18:\n\tcase WM8993_EQ19:\n\tcase WM8993_EQ20:\n\tcase WM8993_EQ21:\n\tcase WM8993_EQ22:\n\tcase WM8993_EQ23:\n\tcase WM8993_EQ24:\n\tcase WM8993_DIGITAL_PULLS:\n\tcase WM8993_DRC_CONTROL_1:\n\tcase WM8993_DRC_CONTROL_2:\n\tcase WM8993_DRC_CONTROL_3:\n\tcase WM8993_DRC_CONTROL_4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct _fll_div {\n\tu16 fll_fratio;\n\tu16 fll_outdiv;\n\tu16 fll_clk_ref_div;\n\tu16 n;\n\tu16 k;\n};\n\n \n#define FIXED_FLL_SIZE ((1 << 16) * 10)\n\nstatic struct {\n\tunsigned int min;\n\tunsigned int max;\n\tu16 fll_fratio;\n\tint ratio;\n} fll_fratios[] = {\n\t{       0,    64000, 4, 16 },\n\t{   64000,   128000, 3,  8 },\n\t{  128000,   256000, 2,  4 },\n\t{  256000,  1000000, 1,  2 },\n\t{ 1000000, 13500000, 0,  1 },\n};\n\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\n\t\t       unsigned int Fout)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod, target;\n\tunsigned int div;\n\tint i;\n\n\t \n\tdiv = 1;\n\tfll_div->fll_clk_ref_div = 0;\n\twhile ((Fref / div) > 13500000) {\n\t\tdiv *= 2;\n\t\tfll_div->fll_clk_ref_div++;\n\n\t\tif (div > 8) {\n\t\t\tpr_err(\"Can't scale %dMHz input down to <=13.5MHz\\n\",\n\t\t\t       Fref);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpr_debug(\"Fref=%u Fout=%u\\n\", Fref, Fout);\n\n\t \n\tFref /= div;\n\n\t \n\tdiv = 0;\n\ttarget = Fout * 2;\n\twhile (target < 90000000) {\n\t\tdiv++;\n\t\ttarget *= 2;\n\t\tif (div > 7) {\n\t\t\tpr_err(\"Unable to find FLL_OUTDIV for Fout=%uHz\\n\",\n\t\t\t       Fout);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfll_div->fll_outdiv = div;\n\n\tpr_debug(\"Fvco=%dHz\\n\", target);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\n\t\tif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\n\t\t\tfll_div->fll_fratio = fll_fratios[i].fll_fratio;\n\t\t\ttarget /= fll_fratios[i].ratio;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(fll_fratios)) {\n\t\tpr_err(\"Unable to find FLL_FRATIO for Fref=%uHz\\n\", Fref);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tNdiv = target / Fref;\n\n\tfll_div->n = Ndiv;\n\tNmod = target % Fref;\n\tpr_debug(\"Nmod=%d\\n\", Nmod);\n\n\t \n\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, Fref);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tfll_div->k = K / 10;\n\n\tpr_debug(\"N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\\n\",\n\t\t fll_div->n, fll_div->k,\n\t\t fll_div->fll_fratio, fll_div->fll_outdiv,\n\t\t fll_div->fll_clk_ref_div);\n\n\treturn 0;\n}\n\nstatic int _wm8993_set_fll(struct snd_soc_component *component, int fll_id, int source,\n\t\t\t  unsigned int Fref, unsigned int Fout)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tstruct i2c_client *i2c = to_i2c_client(component->dev);\n\tu16 reg1, reg4, reg5;\n\tstruct _fll_div fll_div;\n\tunsigned int timeout;\n\tint ret;\n\n\t \n\tif (Fref == wm8993->fll_fref && Fout == wm8993->fll_fout)\n\t\treturn 0;\n\n\t \n\tif (Fout == 0) {\n\t\tdev_dbg(component->dev, \"FLL disabled\\n\");\n\t\twm8993->fll_fref = 0;\n\t\twm8993->fll_fout = 0;\n\n\t\treg1 = snd_soc_component_read(component, WM8993_FLL_CONTROL_1);\n\t\treg1 &= ~WM8993_FLL_ENA;\n\t\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_1, reg1);\n\n\t\treturn 0;\n\t}\n\n\tret = fll_factors(&fll_div, Fref, Fout);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treg5 = snd_soc_component_read(component, WM8993_FLL_CONTROL_5);\n\treg5 &= ~WM8993_FLL_CLK_SRC_MASK;\n\n\tswitch (fll_id) {\n\tcase WM8993_FLL_MCLK:\n\t\tbreak;\n\n\tcase WM8993_FLL_LRCLK:\n\t\treg5 |= 1;\n\t\tbreak;\n\n\tcase WM8993_FLL_BCLK:\n\t\treg5 |= 2;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown FLL ID %d\\n\", fll_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treg1 = snd_soc_component_read(component, WM8993_FLL_CONTROL_1);\n\treg1 &= ~WM8993_FLL_ENA;\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_1, reg1);\n\n\t \n\tif (fll_div.k)\n\t\treg1 |= WM8993_FLL_FRAC_MASK;\n\telse\n\t\treg1 &= ~WM8993_FLL_FRAC_MASK;\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_1, reg1);\n\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_2,\n\t\t      (fll_div.fll_outdiv << WM8993_FLL_OUTDIV_SHIFT) |\n\t\t      (fll_div.fll_fratio << WM8993_FLL_FRATIO_SHIFT));\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_3, fll_div.k);\n\n\treg4 = snd_soc_component_read(component, WM8993_FLL_CONTROL_4);\n\treg4 &= ~WM8993_FLL_N_MASK;\n\treg4 |= fll_div.n << WM8993_FLL_N_SHIFT;\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_4, reg4);\n\n\treg5 &= ~WM8993_FLL_CLK_REF_DIV_MASK;\n\treg5 |= fll_div.fll_clk_ref_div << WM8993_FLL_CLK_REF_DIV_SHIFT;\n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_5, reg5);\n\n\t \n\tif (i2c->irq)\n\t\ttimeout = msecs_to_jiffies(20);\n\telse if (Fref < 1000000)\n\t\ttimeout = msecs_to_jiffies(3);\n\telse\n\t\ttimeout = msecs_to_jiffies(1);\n\n\ttry_wait_for_completion(&wm8993->fll_lock);\n\n\t \n\tsnd_soc_component_write(component, WM8993_FLL_CONTROL_1, reg1 | WM8993_FLL_ENA);\n\n\ttimeout = wait_for_completion_timeout(&wm8993->fll_lock, timeout);\n\tif (i2c->irq && !timeout)\n\t\tdev_warn(component->dev, \"Timed out waiting for FLL\\n\");\n\n\tdev_dbg(component->dev, \"FLL enabled at %dHz->%dHz\\n\", Fref, Fout);\n\n\twm8993->fll_fref = Fref;\n\twm8993->fll_fout = Fout;\n\twm8993->fll_src = source;\n\n\treturn 0;\n}\n\nstatic int wm8993_set_fll(struct snd_soc_dai *dai, int fll_id, int source,\n\t\t\t  unsigned int Fref, unsigned int Fout)\n{\n\treturn _wm8993_set_fll(dai->component, fll_id, source, Fref, Fout);\n}\n\nstatic int configure_clock(struct snd_soc_component *component)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg;\n\n\t \n\tswitch (wm8993->sysclk_source) {\n\tcase WM8993_SYSCLK_MCLK:\n\t\tdev_dbg(component->dev, \"Using %dHz MCLK\\n\", wm8993->mclk_rate);\n\n\t\treg = snd_soc_component_read(component, WM8993_CLOCKING_2);\n\t\treg &= ~(WM8993_MCLK_DIV | WM8993_SYSCLK_SRC);\n\t\tif (wm8993->mclk_rate > 13500000) {\n\t\t\treg |= WM8993_MCLK_DIV;\n\t\t\twm8993->sysclk_rate = wm8993->mclk_rate / 2;\n\t\t} else {\n\t\t\treg &= ~WM8993_MCLK_DIV;\n\t\t\twm8993->sysclk_rate = wm8993->mclk_rate;\n\t\t}\n\t\tsnd_soc_component_write(component, WM8993_CLOCKING_2, reg);\n\t\tbreak;\n\n\tcase WM8993_SYSCLK_FLL:\n\t\tdev_dbg(component->dev, \"Using %dHz FLL clock\\n\",\n\t\t\twm8993->fll_fout);\n\n\t\treg = snd_soc_component_read(component, WM8993_CLOCKING_2);\n\t\treg |= WM8993_SYSCLK_SRC;\n\t\tif (wm8993->fll_fout > 13500000) {\n\t\t\treg |= WM8993_MCLK_DIV;\n\t\t\twm8993->sysclk_rate = wm8993->fll_fout / 2;\n\t\t} else {\n\t\t\treg &= ~WM8993_MCLK_DIV;\n\t\t\twm8993->sysclk_rate = wm8993->fll_fout;\n\t\t}\n\t\tsnd_soc_component_write(component, WM8993_CLOCKING_2, reg);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"System clock not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"CLK_SYS is %dHz\\n\", wm8993->sysclk_rate);\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(sidetone_tlv, -3600, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_comp_threash, -4500, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_comp_amp, -2250, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_min_tlv, -1800, 600, 0);\nstatic const DECLARE_TLV_DB_RANGE(drc_max_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(1200, 600, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(3600, 0, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(drc_qr_tlv, 1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_startup_tlv, -1800, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -7200, 75, 1);\nstatic const DECLARE_TLV_DB_SCALE(dac_boost_tlv, 0, 600, 0);\n\nstatic const char *dac_deemph_text[] = {\n\t\"None\",\n\t\"32kHz\",\n\t\"44.1kHz\",\n\t\"48kHz\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dac_deemph,\n\t\t\t    WM8993_DAC_CTRL, 4, dac_deemph_text);\n\nstatic const char *adc_hpf_text[] = {\n\t\"Hi-Fi\",\n\t\"Voice 1\",\n\t\"Voice 2\",\n\t\"Voice 3\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adc_hpf,\n\t\t\t    WM8993_ADC_CTRL, 5, adc_hpf_text);\n\nstatic const char *drc_path_text[] = {\n\t\"ADC\",\n\t\"DAC\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_path,\n\t\t\t    WM8993_DRC_CONTROL_1, 14, drc_path_text);\n\nstatic const char *drc_r0_text[] = {\n\t\"1\",\n\t\"1/2\",\n\t\"1/4\",\n\t\"1/8\",\n\t\"1/16\",\n\t\"0\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_r0,\n\t\t\t    WM8993_DRC_CONTROL_3, 8, drc_r0_text);\n\nstatic const char *drc_r1_text[] = {\n\t\"1\",\n\t\"1/2\",\n\t\"1/4\",\n\t\"1/8\",\n\t\"0\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_r1,\n\t\t\t    WM8993_DRC_CONTROL_4, 13, drc_r1_text);\n\nstatic const char *drc_attack_text[] = {\n\t\"Reserved\",\n\t\"181us\",\n\t\"363us\",\n\t\"726us\",\n\t\"1.45ms\",\n\t\"2.9ms\",\n\t\"5.8ms\",\n\t\"11.6ms\",\n\t\"23.2ms\",\n\t\"46.4ms\",\n\t\"92.8ms\",\n\t\"185.6ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_attack,\n\t\t\t    WM8993_DRC_CONTROL_2, 12, drc_attack_text);\n\nstatic const char *drc_decay_text[] = {\n\t\"186ms\",\n\t\"372ms\",\n\t\"743ms\",\n\t\"1.49s\",\n\t\"2.97ms\",\n\t\"5.94ms\",\n\t\"11.89ms\",\n\t\"23.78ms\",\n\t\"47.56ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_decay,\n\t\t\t    WM8993_DRC_CONTROL_2, 8, drc_decay_text);\n\nstatic const char *drc_ff_text[] = {\n\t\"5 samples\",\n\t\"9 samples\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_ff,\n\t\t\t    WM8993_DRC_CONTROL_3, 7, drc_ff_text);\n\nstatic const char *drc_qr_rate_text[] = {\n\t\"0.725ms\",\n\t\"1.45ms\",\n\t\"5.8ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_qr_rate,\n\t\t\t    WM8993_DRC_CONTROL_3, 0, drc_qr_rate_text);\n\nstatic const char *drc_smooth_text[] = {\n\t\"Low\",\n\t\"Medium\",\n\t\"High\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_smooth,\n\t\t\t    WM8993_DRC_CONTROL_1, 4, drc_smooth_text);\n\nstatic const struct snd_kcontrol_new wm8993_snd_controls[] = {\nSOC_DOUBLE_TLV(\"Digital Sidetone Volume\", WM8993_DIGITAL_SIDE_TONE,\n\t       5, 9, 12, 0, sidetone_tlv),\n\nSOC_SINGLE(\"DRC Switch\", WM8993_DRC_CONTROL_1, 15, 1, 0),\nSOC_ENUM(\"DRC Path\", drc_path),\nSOC_SINGLE_TLV(\"DRC Compressor Threshold Volume\", WM8993_DRC_CONTROL_2,\n\t       2, 60, 1, drc_comp_threash),\nSOC_SINGLE_TLV(\"DRC Compressor Amplitude Volume\", WM8993_DRC_CONTROL_3,\n\t       11, 30, 1, drc_comp_amp),\nSOC_ENUM(\"DRC R0\", drc_r0),\nSOC_ENUM(\"DRC R1\", drc_r1),\nSOC_SINGLE_TLV(\"DRC Minimum Volume\", WM8993_DRC_CONTROL_1, 2, 3, 1,\n\t       drc_min_tlv),\nSOC_SINGLE_TLV(\"DRC Maximum Volume\", WM8993_DRC_CONTROL_1, 0, 3, 0,\n\t       drc_max_tlv),\nSOC_ENUM(\"DRC Attack Rate\", drc_attack),\nSOC_ENUM(\"DRC Decay Rate\", drc_decay),\nSOC_ENUM(\"DRC FF Delay\", drc_ff),\nSOC_SINGLE(\"DRC Anti-clip Switch\", WM8993_DRC_CONTROL_1, 9, 1, 0),\nSOC_SINGLE(\"DRC Quick Release Switch\", WM8993_DRC_CONTROL_1, 10, 1, 0),\nSOC_SINGLE_TLV(\"DRC Quick Release Volume\", WM8993_DRC_CONTROL_3, 2, 3, 0,\n\t       drc_qr_tlv),\nSOC_ENUM(\"DRC Quick Release Rate\", drc_qr_rate),\nSOC_SINGLE(\"DRC Smoothing Switch\", WM8993_DRC_CONTROL_1, 11, 1, 0),\nSOC_SINGLE(\"DRC Smoothing Hysteresis Switch\", WM8993_DRC_CONTROL_1, 8, 1, 0),\nSOC_ENUM(\"DRC Smoothing Hysteresis Threshold\", drc_smooth),\nSOC_SINGLE_TLV(\"DRC Startup Volume\", WM8993_DRC_CONTROL_4, 8, 18, 0,\n\t       drc_startup_tlv),\n\nSOC_SINGLE(\"EQ Switch\", WM8993_EQ1, 0, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8993_LEFT_ADC_DIGITAL_VOLUME,\n\t\t WM8993_RIGHT_ADC_DIGITAL_VOLUME, 1, 96, 0, digital_tlv),\nSOC_SINGLE(\"ADC High Pass Filter Switch\", WM8993_ADC_CTRL, 8, 1, 0),\nSOC_ENUM(\"ADC High Pass Filter Mode\", adc_hpf),\n\nSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8993_LEFT_DAC_DIGITAL_VOLUME,\n\t\t WM8993_RIGHT_DAC_DIGITAL_VOLUME, 1, 96, 0, digital_tlv),\nSOC_SINGLE_TLV(\"Playback Boost Volume\", WM8993_AUDIO_INTERFACE_2, 10, 3, 0,\n\t       dac_boost_tlv),\nSOC_ENUM(\"DAC Deemphasis\", dac_deemph),\n\nSOC_SINGLE_TLV(\"SPKL DAC Volume\", WM8993_SPKMIXL_ATTENUATION,\n\t       2, 1, 1, wm_hubs_spkmix_tlv),\n\nSOC_SINGLE_TLV(\"SPKR DAC Volume\", WM8993_SPKMIXR_ATTENUATION,\n\t       2, 1, 1, wm_hubs_spkmix_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm8993_eq_controls[] = {\nSOC_SINGLE_TLV(\"EQ1 Volume\", WM8993_EQ2, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Volume\", WM8993_EQ3, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Volume\", WM8993_EQ4, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Volume\", WM8993_EQ5, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ5 Volume\", WM8993_EQ6, 0, 24, 0, eq_tlv),\n};\n\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn configure_clock(component);\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new left_speaker_mixer[] = {\nSOC_DAPM_SINGLE(\"Input Switch\", WM8993_SPEAKER_MIXER, 7, 1, 0),\nSOC_DAPM_SINGLE(\"IN1LP Switch\", WM8993_SPEAKER_MIXER, 5, 1, 0),\nSOC_DAPM_SINGLE(\"Output Switch\", WM8993_SPEAKER_MIXER, 3, 1, 0),\nSOC_DAPM_SINGLE(\"DAC Switch\", WM8993_SPEAKER_MIXER, 6, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_speaker_mixer[] = {\nSOC_DAPM_SINGLE(\"Input Switch\", WM8993_SPEAKER_MIXER, 6, 1, 0),\nSOC_DAPM_SINGLE(\"IN1RP Switch\", WM8993_SPEAKER_MIXER, 4, 1, 0),\nSOC_DAPM_SINGLE(\"Output Switch\", WM8993_SPEAKER_MIXER, 2, 1, 0),\nSOC_DAPM_SINGLE(\"DAC Switch\", WM8993_SPEAKER_MIXER, 0, 1, 0),\n};\n\nstatic const char *aif_text[] = {\n\t\"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(aifoutl_enum,\n\t\t\t    WM8993_AUDIO_INTERFACE_1, 15, aif_text);\n\nstatic const struct snd_kcontrol_new aifoutl_mux =\n\tSOC_DAPM_ENUM(\"AIFOUTL Mux\", aifoutl_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifoutr_enum,\n\t\t\t    WM8993_AUDIO_INTERFACE_1, 14, aif_text);\n\nstatic const struct snd_kcontrol_new aifoutr_mux =\n\tSOC_DAPM_ENUM(\"AIFOUTR Mux\", aifoutr_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifinl_enum,\n\t\t\t    WM8993_AUDIO_INTERFACE_2, 15, aif_text);\n\nstatic const struct snd_kcontrol_new aifinl_mux =\n\tSOC_DAPM_ENUM(\"AIFINL Mux\", aifinl_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifinr_enum,\n\t\t\t    WM8993_AUDIO_INTERFACE_2, 14, aif_text);\n\nstatic const struct snd_kcontrol_new aifinr_mux =\n\tSOC_DAPM_ENUM(\"AIFINR Mux\", aifinr_enum);\n\nstatic const char *sidetone_text[] = {\n\t\"None\", \"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(sidetonel_enum,\n\t\t\t    WM8993_DIGITAL_SIDE_TONE, 2, sidetone_text);\n\nstatic const struct snd_kcontrol_new sidetonel_mux =\n\tSOC_DAPM_ENUM(\"Left Sidetone\", sidetonel_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(sidetoner_enum,\n\t\t\t    WM8993_DIGITAL_SIDE_TONE, 0, sidetone_text);\n\nstatic const struct snd_kcontrol_new sidetoner_mux =\n\tSOC_DAPM_ENUM(\"Right Sidetone\", sidetoner_enum);\n\nstatic const struct snd_soc_dapm_widget wm8993_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"CLK_SYS\", WM8993_BUS_CONTROL_1, 1, 0, clk_sys_event,\n\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_SUPPLY(\"TOCLK\", WM8993_CLOCKING_1, 14, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"CLK_DSP\", WM8993_CLOCKING_3, 0, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"VMID\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_ADC(\"ADCL\", NULL, WM8993_POWER_MANAGEMENT_2, 1, 0),\nSND_SOC_DAPM_ADC(\"ADCR\", NULL, WM8993_POWER_MANAGEMENT_2, 0, 0),\n\nSND_SOC_DAPM_MUX(\"AIFOUTL Mux\", SND_SOC_NOPM, 0, 0, &aifoutl_mux),\nSND_SOC_DAPM_MUX(\"AIFOUTR Mux\", SND_SOC_NOPM, 0, 0, &aifoutr_mux),\n\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTL\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTR\", \"Capture\", 1, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_MUX(\"DACL Mux\", SND_SOC_NOPM, 0, 0, &aifinl_mux),\nSND_SOC_DAPM_MUX(\"DACR Mux\", SND_SOC_NOPM, 0, 0, &aifinr_mux),\n\nSND_SOC_DAPM_MUX(\"DACL Sidetone\", SND_SOC_NOPM, 0, 0, &sidetonel_mux),\nSND_SOC_DAPM_MUX(\"DACR Sidetone\", SND_SOC_NOPM, 0, 0, &sidetoner_mux),\n\nSND_SOC_DAPM_DAC(\"DACL\", NULL, WM8993_POWER_MANAGEMENT_3, 1, 0),\nSND_SOC_DAPM_DAC(\"DACR\", NULL, WM8993_POWER_MANAGEMENT_3, 0, 0),\n\nSND_SOC_DAPM_MUX(\"Left Headphone Mux\", SND_SOC_NOPM, 0, 0, &wm_hubs_hpl_mux),\nSND_SOC_DAPM_MUX(\"Right Headphone Mux\", SND_SOC_NOPM, 0, 0, &wm_hubs_hpr_mux),\n\nSND_SOC_DAPM_MIXER(\"SPKL\", WM8993_POWER_MANAGEMENT_3, 8, 0,\n\t\t   left_speaker_mixer, ARRAY_SIZE(left_speaker_mixer)),\nSND_SOC_DAPM_MIXER(\"SPKR\", WM8993_POWER_MANAGEMENT_3, 9, 0,\n\t\t   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),\nSND_SOC_DAPM_PGA(\"Direct Voice\", SND_SOC_NOPM, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route routes[] = {\n\t{ \"MICBIAS1\", NULL, \"VMID\" },\n\t{ \"MICBIAS2\", NULL, \"VMID\" },\n\n\t{ \"ADCL\", NULL, \"CLK_SYS\" },\n\t{ \"ADCL\", NULL, \"CLK_DSP\" },\n\t{ \"ADCR\", NULL, \"CLK_SYS\" },\n\t{ \"ADCR\", NULL, \"CLK_DSP\" },\n\n\t{ \"AIFOUTL Mux\", \"Left\", \"ADCL\" },\n\t{ \"AIFOUTL Mux\", \"Right\", \"ADCR\" },\n\t{ \"AIFOUTR Mux\", \"Left\", \"ADCL\" },\n\t{ \"AIFOUTR Mux\", \"Right\", \"ADCR\" },\n\n\t{ \"AIFOUTL\", NULL, \"AIFOUTL Mux\" },\n\t{ \"AIFOUTR\", NULL, \"AIFOUTR Mux\" },\n\n\t{ \"DACL Mux\", \"Left\", \"AIFINL\" },\n\t{ \"DACL Mux\", \"Right\", \"AIFINR\" },\n\t{ \"DACR Mux\", \"Left\", \"AIFINL\" },\n\t{ \"DACR Mux\", \"Right\", \"AIFINR\" },\n\n\t{ \"DACL Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACL Sidetone\", \"Right\", \"ADCR\" },\n\t{ \"DACR Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACR Sidetone\", \"Right\", \"ADCR\" },\n\n\t{ \"DACL\", NULL, \"CLK_SYS\" },\n\t{ \"DACL\", NULL, \"CLK_DSP\" },\n\t{ \"DACL\", NULL, \"DACL Mux\" },\n\t{ \"DACL\", NULL, \"DACL Sidetone\" },\n\t{ \"DACR\", NULL, \"CLK_SYS\" },\n\t{ \"DACR\", NULL, \"CLK_DSP\" },\n\t{ \"DACR\", NULL, \"DACR Mux\" },\n\t{ \"DACR\", NULL, \"DACR Sidetone\" },\n\n\t{ \"Left Output Mixer\", \"DAC Switch\", \"DACL\" },\n\n\t{ \"Right Output Mixer\", \"DAC Switch\", \"DACR\" },\n\n\t{ \"Left Output PGA\", NULL, \"CLK_SYS\" },\n\n\t{ \"Right Output PGA\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPKL\", \"DAC Switch\", \"DACL\" },\n\t{ \"SPKL\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPKR\", \"DAC Switch\", \"DACR\" },\n\t{ \"SPKR\", NULL, \"CLK_SYS\" },\n\n\t{ \"Left Headphone Mux\", \"DAC\", \"DACL\" },\n\t{ \"Right Headphone Mux\", \"DAC\", \"DACR\" },\n};\n\nstatic int wm8993_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\twm_hubs_set_bias_level(component, level);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8993_VMID_SEL_MASK, 0x2);\n\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_2,\n\t\t\t\t    WM8993_TSHUT_ENA, WM8993_TSHUT_ENA);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8993->supplies),\n\t\t\t\t\t\t    wm8993->supplies);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\tregcache_cache_only(wm8993->regmap, false);\n\t\t\tregcache_sync(wm8993->regmap);\n\n\t\t\twm_hubs_vmid_ena(component);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8993_ANTIPOP2,\n\t\t\t\t\t    WM8993_STARTUP_BIAS_ENA |\n\t\t\t\t\t    WM8993_VMID_BUF_ENA |\n\t\t\t\t\t    WM8993_VMID_RAMP_MASK |\n\t\t\t\t\t    WM8993_BIAS_SRC,\n\t\t\t\t\t    WM8993_STARTUP_BIAS_ENA |\n\t\t\t\t\t    WM8993_VMID_BUF_ENA |\n\t\t\t\t\t    WM8993_VMID_RAMP_MASK |\n\t\t\t\t\t    WM8993_BIAS_SRC);\n\n\t\t\t \n\t\t\tif (!wm8993->pdata.lineout1_diff ||\n\t\t\t    !wm8993->pdata.lineout2_diff)\n\t\t\t\tsnd_soc_component_update_bits(component, WM8993_ANTIPOP1,\n\t\t\t\t\t\t WM8993_LINEOUT_VMID_BUF_ENA,\n\t\t\t\t\t\t WM8993_LINEOUT_VMID_BUF_ENA);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8993_VMID_SEL_MASK |\n\t\t\t\t\t    WM8993_BIAS_ENA,\n\t\t\t\t\t    WM8993_BIAS_ENA | 0x2);\n\t\t\tmsleep(32);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8993_ANTIPOP2,\n\t\t\t\t\t    WM8993_BIAS_SRC |\n\t\t\t\t\t    WM8993_STARTUP_BIAS_ENA, 0);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8993_VMID_SEL_MASK, 0x4);\n\n\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_2,\n\t\t\t\t    WM8993_TSHUT_ENA, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8993_ANTIPOP1,\n\t\t\t\t    WM8993_LINEOUT_VMID_BUF_ENA, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8993_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8993_VMID_SEL_MASK | WM8993_BIAS_ENA,\n\t\t\t\t    0);\n\n\t\tsnd_soc_component_update_bits(component, WM8993_ANTIPOP2,\n\t\t\t\t    WM8993_STARTUP_BIAS_ENA |\n\t\t\t\t    WM8993_VMID_BUF_ENA |\n\t\t\t\t    WM8993_VMID_RAMP_MASK |\n\t\t\t\t    WM8993_BIAS_SRC, 0);\n\n\t\tregcache_cache_only(wm8993->regmap, true);\n\t\tregcache_mark_dirty(wm8993->regmap);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies),\n\t\t\t\t       wm8993->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8993_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM8993_SYSCLK_MCLK:\n\t\twm8993->mclk_rate = freq;\n\t\tfallthrough;\n\tcase WM8993_SYSCLK_FLL:\n\t\twm8993->sysclk_source = clk_id;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8993_set_dai_fmt(struct snd_soc_dai *dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tunsigned int aif1 = snd_soc_component_read(component, WM8993_AUDIO_INTERFACE_1);\n\tunsigned int aif4 = snd_soc_component_read(component, WM8993_AUDIO_INTERFACE_4);\n\n\taif1 &= ~(WM8993_BCLK_DIR | WM8993_AIF_BCLK_INV |\n\t\t  WM8993_AIF_LRCLK_INV | WM8993_AIF_FMT_MASK);\n\taif4 &= ~WM8993_LRCLK_DIR;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\twm8993->master = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\taif4 |= WM8993_LRCLK_DIR;\n\t\twm8993->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\taif1 |= WM8993_BCLK_DIR;\n\t\twm8993->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif1 |= WM8993_BCLK_DIR;\n\t\taif4 |= WM8993_LRCLK_DIR;\n\t\twm8993->master = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif1 |= WM8993_AIF_LRCLK_INV;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif1 |= 0x18;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif1 |= 0x10;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif1 |= 0x8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8993_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif1 |= WM8993_AIF_BCLK_INV | WM8993_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8993_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif1 |= WM8993_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8993_AUDIO_INTERFACE_1, aif1);\n\tsnd_soc_component_write(component, WM8993_AUDIO_INTERFACE_4, aif4);\n\n\treturn 0;\n}\n\nstatic int wm8993_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tint ret, i, best, best_val, cur_val;\n\tunsigned int clocking1, clocking3, aif1, aif4;\n\n\tclocking1 = snd_soc_component_read(component, WM8993_CLOCKING_1);\n\tclocking1 &= ~WM8993_BCLK_DIV_MASK;\n\n\tclocking3 = snd_soc_component_read(component, WM8993_CLOCKING_3);\n\tclocking3 &= ~(WM8993_CLK_SYS_RATE_MASK | WM8993_SAMPLE_RATE_MASK);\n\n\taif1 = snd_soc_component_read(component, WM8993_AUDIO_INTERFACE_1);\n\taif1 &= ~WM8993_AIF_WL_MASK;\n\n\taif4 = snd_soc_component_read(component, WM8993_AUDIO_INTERFACE_4);\n\taif4 &= ~WM8993_LRCLK_RATE_MASK;\n\n\t \n\twm8993->fs = params_rate(params);\n\twm8993->bclk = 2 * wm8993->fs;\n\tif (wm8993->tdm_slots) {\n\t\tdev_dbg(component->dev, \"Configuring for %d %d bit TDM slots\\n\",\n\t\t\twm8993->tdm_slots, wm8993->tdm_width);\n\t\twm8993->bclk *= wm8993->tdm_width * wm8993->tdm_slots;\n\t} else {\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\twm8993->bclk *= 16;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\twm8993->bclk *= 20;\n\t\t\taif1 |= 0x8;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\twm8993->bclk *= 24;\n\t\t\taif1 |= 0x10;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\twm8993->bclk *= 32;\n\t\t\taif1 |= 0x18;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"Target BCLK is %dHz\\n\", wm8993->bclk);\n\n\tret = configure_clock(component);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tbest = 0;\n\tbest_val = abs((wm8993->sysclk_rate / clk_sys_rates[0].ratio)\n\t\t       - wm8993->fs);\n\tfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\n\t\tcur_val = abs((wm8993->sysclk_rate /\n\t\t\t       clk_sys_rates[i].ratio) - wm8993->fs);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected CLK_SYS_RATIO of %d\\n\",\n\t\tclk_sys_rates[best].ratio);\n\tclocking3 |= (clk_sys_rates[best].clk_sys_rate\n\t\t      << WM8993_CLK_SYS_RATE_SHIFT);\n\n\t \n\tbest = 0;\n\tbest_val = abs(wm8993->fs - sample_rates[0].rate);\n\tfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\n\t\t \n\t\tcur_val = abs(wm8993->fs - sample_rates[i].rate);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected SAMPLE_RATE of %dHz\\n\",\n\t\tsample_rates[best].rate);\n\tclocking3 |= (sample_rates[best].sample_rate\n\t\t      << WM8993_SAMPLE_RATE_SHIFT);\n\n\t \n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\n\t\tcur_val = ((wm8993->sysclk_rate * 10) / bclk_divs[i].div)\n\t\t\t- wm8993->bclk;\n\t\tif (cur_val < 0)  \n\t\t\tbreak;\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\twm8993->bclk = (wm8993->sysclk_rate * 10) / bclk_divs[best].div;\n\tdev_dbg(component->dev, \"Selected BCLK_DIV of %d for %dHz BCLK\\n\",\n\t\tbclk_divs[best].div, wm8993->bclk);\n\tclocking1 |= bclk_divs[best].bclk_div << WM8993_BCLK_DIV_SHIFT;\n\n\t \n\tdev_dbg(component->dev, \"LRCLK_RATE is %d\\n\", wm8993->bclk / wm8993->fs);\n\taif4 |= wm8993->bclk / wm8993->fs;\n\n\tsnd_soc_component_write(component, WM8993_CLOCKING_1, clocking1);\n\tsnd_soc_component_write(component, WM8993_CLOCKING_3, clocking3);\n\tsnd_soc_component_write(component, WM8993_AUDIO_INTERFACE_1, aif1);\n\tsnd_soc_component_write(component, WM8993_AUDIO_INTERFACE_4, aif4);\n\n\t \n\tif (wm8993->pdata.num_retune_configs) {\n\t\tu16 eq1 = snd_soc_component_read(component, WM8993_EQ1);\n\t\tstruct wm8993_retune_mobile_setting *s;\n\n\t\tbest = 0;\n\t\tbest_val = abs(wm8993->pdata.retune_configs[0].rate\n\t\t\t       - wm8993->fs);\n\t\tfor (i = 0; i < wm8993->pdata.num_retune_configs; i++) {\n\t\t\tcur_val = abs(wm8993->pdata.retune_configs[i].rate\n\t\t\t\t      - wm8993->fs);\n\t\t\tif (cur_val < best_val) {\n\t\t\t\tbest_val = cur_val;\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\ts = &wm8993->pdata.retune_configs[best];\n\n\t\tdev_dbg(component->dev, \"ReTune Mobile %s tuned for %dHz\\n\",\n\t\t\ts->name, s->rate);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8993_EQ1, WM8993_EQ_ENA, 0);\n\n\t\tfor (i = 1; i < ARRAY_SIZE(s->config); i++)\n\t\t\tsnd_soc_component_write(component, WM8993_EQ1 + i, s->config[i]);\n\n\t\tsnd_soc_component_update_bits(component, WM8993_EQ1, WM8993_EQ_ENA, eq1);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8993_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM8993_DAC_CTRL);\n\n\tif (mute)\n\t\treg |= WM8993_DAC_MUTE;\n\telse\n\t\treg &= ~WM8993_DAC_MUTE;\n\n\tsnd_soc_component_write(component, WM8993_DAC_CTRL, reg);\n\n\treturn 0;\n}\n\nstatic int wm8993_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tint aif1 = 0;\n\tint aif2 = 0;\n\n\t \n\tif (slots == 0) {\n\t\twm8993->tdm_slots = 0;\n\t\tgoto out;\n\t}\n\n\t \n\taif1 |= WM8993_AIFADC_TDM;\n\taif2 |= WM8993_AIFDAC_TDM;\n\n\tswitch (rx_mask) {\n\tcase 3:\n\t\tbreak;\n\tcase 0xc:\n\t\taif1 |= WM8993_AIFADC_TDM_CHAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tswitch (tx_mask) {\n\tcase 3:\n\t\tbreak;\n\tcase 0xc:\n\t\taif2 |= WM8993_AIFDAC_TDM_CHAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout:\n\twm8993->tdm_width = slot_width;\n\twm8993->tdm_slots = slots / 2;\n\n\tsnd_soc_component_update_bits(component, WM8993_AUDIO_INTERFACE_1,\n\t\t\t    WM8993_AIFADC_TDM | WM8993_AIFADC_TDM_CHAN, aif1);\n\tsnd_soc_component_update_bits(component, WM8993_AUDIO_INTERFACE_2,\n\t\t\t    WM8993_AIFDAC_TDM | WM8993_AIFDAC_TDM_CHAN, aif2);\n\n\treturn 0;\n}\n\nstatic irqreturn_t wm8993_irq(int irq, void *data)\n{\n\tstruct wm8993_priv *wm8993 = data;\n\tint mask, val, ret;\n\n\tret = regmap_read(wm8993->regmap, WM8993_GPIO_CTRL_1, &val);\n\tif (ret != 0) {\n\t\tdev_err(wm8993->dev, \"Failed to read interrupt status: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = regmap_read(wm8993->regmap, WM8993_GPIOCTRL_2, &mask);\n\tif (ret != 0) {\n\t\tdev_err(wm8993->dev, \"Failed to read interrupt mask: %d\\n\",\n\t\t\tret);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tval &= ~(mask | WM8993_IRQ);\n\tif (!val)\n\t\treturn IRQ_NONE;\n\n\tif (val & WM8993_TEMPOK_EINT)\n\t\tdev_crit(wm8993->dev, \"Thermal warning\\n\");\n\n\tif (val & WM8993_FLL_LOCK_EINT) {\n\t\tdev_dbg(wm8993->dev, \"FLL locked\\n\");\n\t\tcomplete(&wm8993->fll_lock);\n\t}\n\n\tret = regmap_write(wm8993->regmap, WM8993_GPIO_CTRL_1, val);\n\tif (ret != 0)\n\t\tdev_err(wm8993->dev, \"Failed to ack interrupt: %d\\n\", ret);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct snd_soc_dai_ops wm8993_ops = {\n\t.set_sysclk = wm8993_set_sysclk,\n\t.set_fmt = wm8993_set_dai_fmt,\n\t.hw_params = wm8993_hw_params,\n\t.mute_stream = wm8993_mute,\n\t.set_pll = wm8993_set_fll,\n\t.set_tdm_slot = wm8993_set_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\n#define WM8993_RATES SNDRV_PCM_RATE_8000_48000\n\n#define WM8993_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver wm8993_dai = {\n\t.name = \"wm8993-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8993_RATES,\n\t\t.formats = WM8993_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.capture = {\n\t\t .stream_name = \"Capture\",\n\t\t .channels_min = 1,\n\t\t .channels_max = 2,\n\t\t .rates = WM8993_RATES,\n\t\t .formats = WM8993_FORMATS,\n\t\t .sig_bits = 24,\n\t },\n\t.ops = &wm8993_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8993_probe(struct snd_soc_component *component)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\twm8993->hubs_data.hp_startup_mode = 1;\n\twm8993->hubs_data.dcs_codes_l = -2;\n\twm8993->hubs_data.dcs_codes_r = -2;\n\twm8993->hubs_data.series_startup = 1;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8993_RIGHT_DAC_DIGITAL_VOLUME,\n\t\t\t    WM8993_DAC_VU, WM8993_DAC_VU);\n\tsnd_soc_component_update_bits(component, WM8993_RIGHT_ADC_DIGITAL_VOLUME,\n\t\t\t    WM8993_ADC_VU, WM8993_ADC_VU);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8993_ANALOGUE_HP_0,\n\t\t\t    WM8993_HPOUT1_AUTO_PU, 0);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8993_CLOCKING_4, WM8993_SR_MODE, 0);\n\n\twm_hubs_handle_analogue_pdata(component, wm8993->pdata.lineout1_diff,\n\t\t\t\t      wm8993->pdata.lineout2_diff,\n\t\t\t\t      wm8993->pdata.lineout1fb,\n\t\t\t\t      wm8993->pdata.lineout2fb,\n\t\t\t\t      wm8993->pdata.jd_scthr,\n\t\t\t\t      wm8993->pdata.jd_thr,\n\t\t\t\t      wm8993->pdata.micbias1_delay,\n\t\t\t\t      wm8993->pdata.micbias2_delay,\n\t\t\t\t      wm8993->pdata.micbias1_lvl,\n\t\t\t\t      wm8993->pdata.micbias2_lvl);\n\n\tsnd_soc_add_component_controls(component, wm8993_snd_controls,\n\t\t\t     ARRAY_SIZE(wm8993_snd_controls));\n\tif (wm8993->pdata.num_retune_configs != 0) {\n\t\tdev_dbg(component->dev, \"Using ReTune Mobile\\n\");\n\t} else {\n\t\tdev_dbg(component->dev, \"No ReTune Mobile, using normal EQ\\n\");\n\t\tsnd_soc_add_component_controls(component, wm8993_eq_controls,\n\t\t\t\t     ARRAY_SIZE(wm8993_eq_controls));\n\t}\n\n\tsnd_soc_dapm_new_controls(dapm, wm8993_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(wm8993_dapm_widgets));\n\twm_hubs_add_analogue_controls(component);\n\n\tsnd_soc_dapm_add_routes(dapm, routes, ARRAY_SIZE(routes));\n\twm_hubs_add_analogue_routes(component, wm8993->pdata.lineout1_diff,\n\t\t\t\t    wm8993->pdata.lineout2_diff);\n\n\t \n\tif (wm8993->pdata.lineout1_diff && wm8993->pdata.lineout2_diff)\n\t\tdapm->idle_bias_off = 1;\n\n\treturn 0;\n\n}\n\n#ifdef CONFIG_PM\nstatic int wm8993_suspend(struct snd_soc_component *component)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tint fll_fout = wm8993->fll_fout;\n\tint fll_fref  = wm8993->fll_fref;\n\tint ret;\n\n\t \n\tret = _wm8993_set_fll(component, 0, 0, 0, 0);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to stop FLL\\n\");\n\t\treturn ret;\n\t}\n\n\twm8993->fll_fout = fll_fout;\n\twm8993->fll_fref = fll_fref;\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\n\treturn 0;\n}\n\nstatic int wm8993_resume(struct snd_soc_component *component)\n{\n\tstruct wm8993_priv *wm8993 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\t \n\tif (wm8993->fll_fout) {\n\t\tint fll_fout = wm8993->fll_fout;\n\t\tint fll_fref  = wm8993->fll_fref;\n\n\t\twm8993->fll_fref = 0;\n\t\twm8993->fll_fout = 0;\n\n\t\tret = _wm8993_set_fll(component, 0, wm8993->fll_src,\n\t\t\t\t     fll_fref, fll_fout);\n\t\tif (ret != 0)\n\t\t\tdev_err(component->dev, \"Failed to restart FLL\\n\");\n\t}\n\n\treturn 0;\n}\n#else\n#define wm8993_suspend NULL\n#define wm8993_resume NULL\n#endif\n\n \nstatic const struct reg_sequence wm8993_regmap_patch[] = {\n\t{ 0x44, 3 },\n\t{ 0x56, 3 },\n\t{ 0x44, 0 },\n};\n\nstatic const struct regmap_config wm8993_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM8993_MAX_REGISTER,\n\t.volatile_reg = wm8993_volatile,\n\t.readable_reg = wm8993_readable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8993_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8993_reg_defaults),\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8993 = {\n\t.probe\t\t\t= wm8993_probe,\n\t.suspend\t\t= wm8993_suspend,\n\t.resume\t\t\t= wm8993_resume,\n\t.set_bias_level\t\t= wm8993_set_bias_level,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm8993_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8993_priv *wm8993;\n\tunsigned int reg;\n\tint ret, i;\n\n\twm8993 = devm_kzalloc(&i2c->dev, sizeof(struct wm8993_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8993 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8993->dev = &i2c->dev;\n\tinit_completion(&wm8993->fll_lock);\n\n\twm8993->regmap = devm_regmap_init_i2c(i2c, &wm8993_regmap);\n\tif (IS_ERR(wm8993->regmap)) {\n\t\tret = PTR_ERR(wm8993->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8993);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8993->supplies); i++)\n\t\twm8993->supplies[i].supply = wm8993_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8993->supplies),\n\t\t\t\t wm8993->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8993->supplies),\n\t\t\t\t    wm8993->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm8993->regmap, WM8993_SOFTWARE_RESET, &reg);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tif (reg != 0x8993) {\n\t\tdev_err(&i2c->dev, \"Invalid ID register value %x\\n\", reg);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = regmap_write(wm8993->regmap, WM8993_SOFTWARE_RESET, 0xffff);\n\tif (ret != 0)\n\t\tgoto err_enable;\n\n\tret = regmap_register_patch(wm8993->regmap, wm8993_regmap_patch,\n\t\t\t\t    ARRAY_SIZE(wm8993_regmap_patch));\n\tif (ret != 0)\n\t\tdev_warn(wm8993->dev, \"Failed to apply regmap patch: %d\\n\",\n\t\t\t ret);\n\n\tif (i2c->irq) {\n\t\t \n\t\tret = regmap_update_bits(wm8993->regmap, WM8993_GPIO1,\n\t\t\t\t\t WM8993_GPIO1_PD |\n\t\t\t\t\t WM8993_GPIO1_SEL_MASK, 7);\n\t\tif (ret != 0)\n\t\t\tgoto err_enable;\n\n\t\tret = request_threaded_irq(i2c->irq, NULL, wm8993_irq,\n\t\t\t\t\t   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t\t   \"wm8993\", wm8993);\n\t\tif (ret != 0)\n\t\t\tgoto err_enable;\n\n\t}\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\n\n\tregcache_cache_only(wm8993->regmap, true);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8993, &wm8993_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\tgoto err_irq;\n\t}\n\n\treturn 0;\n\nerr_irq:\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, wm8993);\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\n\treturn ret;\n}\n\nstatic void wm8993_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct wm8993_priv *wm8993 = i2c_get_clientdata(i2c);\n\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, wm8993);\n\tregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\n}\n\nstatic const struct i2c_device_id wm8993_i2c_id[] = {\n\t{ \"wm8993\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8993_i2c_id);\n\nstatic struct i2c_driver wm8993_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8993\",\n\t},\n\t.probe =    wm8993_i2c_probe,\n\t.remove =   wm8993_i2c_remove,\n\t.id_table = wm8993_i2c_id,\n};\n\nmodule_i2c_driver(wm8993_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8993 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}