{
  "module_name": "pcm3168a.c",
  "hash_id": "1dad9e43a2ea7d712559276687a64a7beaa3f6f0995fa7160c6c925a7da13215",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm3168a.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"pcm3168a.h\"\n\n#define PCM3168A_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE)\n\n#define PCM3168A_FMT_I2S\t\t0x0\n#define PCM3168A_FMT_LEFT_J\t\t0x1\n#define PCM3168A_FMT_RIGHT_J\t\t0x2\n#define PCM3168A_FMT_RIGHT_J_16\t\t0x3\n#define PCM3168A_FMT_DSP_A\t\t0x4\n#define PCM3168A_FMT_DSP_B\t\t0x5\n#define PCM3168A_FMT_I2S_TDM\t\t0x6\n#define PCM3168A_FMT_LEFT_J_TDM\t\t0x7\n\nstatic const char *const pcm3168a_supply_names[] = {\n\t\"VDD1\",\n\t\"VDD2\",\n\t\"VCCAD1\",\n\t\"VCCAD2\",\n\t\"VCCDA1\",\n\t\"VCCDA2\"\n};\n\n#define PCM3168A_DAI_DAC\t\t0\n#define PCM3168A_DAI_ADC\t\t1\n\n \nstruct pcm3168a_io_params {\n\tbool provider_mode;\n\tunsigned int format;\n\tint tdm_slots;\n\tu32 tdm_mask;\n\tint slot_width;\n};\n\nstruct pcm3168a_priv {\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(pcm3168a_supply_names)];\n\tstruct regmap *regmap;\n\tstruct clk *scki;\n\tstruct gpio_desc *gpio_rst;\n\tunsigned long sysclk;\n\n\tstruct pcm3168a_io_params io_params[2];\n\tstruct snd_soc_dai_driver dai_drv[2];\n};\n\nstatic const char *const pcm3168a_roll_off[] = { \"Sharp\", \"Slow\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_d1_roll_off, PCM3168A_DAC_OP_FLT,\n\t\tPCM3168A_DAC_FLT_SHIFT, pcm3168a_roll_off);\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_d2_roll_off, PCM3168A_DAC_OP_FLT,\n\t\tPCM3168A_DAC_FLT_SHIFT + 1, pcm3168a_roll_off);\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_d3_roll_off, PCM3168A_DAC_OP_FLT,\n\t\tPCM3168A_DAC_FLT_SHIFT + 2, pcm3168a_roll_off);\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_d4_roll_off, PCM3168A_DAC_OP_FLT,\n\t\tPCM3168A_DAC_FLT_SHIFT + 3, pcm3168a_roll_off);\n\nstatic const char *const pcm3168a_volume_type[] = {\n\t\t\"Individual\", \"Master + Individual\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_dac_volume_type, PCM3168A_DAC_ATT_DEMP_ZF,\n\t\tPCM3168A_DAC_ATMDDA_SHIFT, pcm3168a_volume_type);\n\nstatic const char *const pcm3168a_att_speed_mult[] = { \"2048\", \"4096\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_dac_att_mult, PCM3168A_DAC_ATT_DEMP_ZF,\n\t\tPCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_att_speed_mult);\n\nstatic const char *const pcm3168a_demp[] = {\n\t\t\"Disabled\", \"48khz\", \"44.1khz\", \"32khz\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_dac_demp, PCM3168A_DAC_ATT_DEMP_ZF,\n\t\tPCM3168A_DAC_DEMP_SHIFT, pcm3168a_demp);\n\nstatic const char *const pcm3168a_zf_func[] = {\n\t\t\"DAC 1/2/3/4 AND\", \"DAC 1/2/3/4 OR\", \"DAC 1/2/3 AND\",\n\t\t\"DAC 1/2/3 OR\", \"DAC 4 AND\", \"DAC 4 OR\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_func, PCM3168A_DAC_ATT_DEMP_ZF,\n\t\tPCM3168A_DAC_AZRO_SHIFT, pcm3168a_zf_func);\n\nstatic const char *const pcm3168a_pol[] = { \"Active High\", \"Active Low\" };\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_dac_zf_pol, PCM3168A_DAC_ATT_DEMP_ZF,\n\t\tPCM3168A_DAC_ATSPDA_SHIFT, pcm3168a_pol);\n\nstatic const char *const pcm3168a_con[] = { \"Differential\", \"Single-Ended\" };\n\nstatic SOC_ENUM_DOUBLE_DECL(pcm3168a_adc1_con, PCM3168A_ADC_SEAD,\n\t\t\t\t0, 1, pcm3168a_con);\nstatic SOC_ENUM_DOUBLE_DECL(pcm3168a_adc2_con, PCM3168A_ADC_SEAD,\n\t\t\t\t2, 3, pcm3168a_con);\nstatic SOC_ENUM_DOUBLE_DECL(pcm3168a_adc3_con, PCM3168A_ADC_SEAD,\n\t\t\t\t4, 5, pcm3168a_con);\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_adc_volume_type, PCM3168A_ADC_ATT_OVF,\n\t\tPCM3168A_ADC_ATMDAD_SHIFT, pcm3168a_volume_type);\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_adc_att_mult, PCM3168A_ADC_ATT_OVF,\n\t\tPCM3168A_ADC_ATSPAD_SHIFT, pcm3168a_att_speed_mult);\n\nstatic SOC_ENUM_SINGLE_DECL(pcm3168a_adc_ov_pol, PCM3168A_ADC_ATT_OVF,\n\t\tPCM3168A_ADC_OVFP_SHIFT, pcm3168a_pol);\n\n \nstatic const DECLARE_TLV_DB_SCALE(pcm3168a_dac_tlv, -10050, 50, 1);\n\n \nstatic const DECLARE_TLV_DB_SCALE(pcm3168a_adc_tlv, -10050, 50, 1);\n\nstatic const struct snd_kcontrol_new pcm3168a_snd_controls[] = {\n\tSOC_SINGLE(\"DAC Power-Save Switch\", PCM3168A_DAC_PWR_MST_FMT,\n\t\t\tPCM3168A_DAC_PSMDA_SHIFT, 1, 1),\n\tSOC_ENUM(\"DAC1 Digital Filter roll-off\", pcm3168a_d1_roll_off),\n\tSOC_ENUM(\"DAC2 Digital Filter roll-off\", pcm3168a_d2_roll_off),\n\tSOC_ENUM(\"DAC3 Digital Filter roll-off\", pcm3168a_d3_roll_off),\n\tSOC_ENUM(\"DAC4 Digital Filter roll-off\", pcm3168a_d4_roll_off),\n\tSOC_DOUBLE(\"DAC1 Invert Switch\", PCM3168A_DAC_INV, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"DAC2 Invert Switch\", PCM3168A_DAC_INV, 2, 3, 1, 0),\n\tSOC_DOUBLE(\"DAC3 Invert Switch\", PCM3168A_DAC_INV, 4, 5, 1, 0),\n\tSOC_DOUBLE(\"DAC4 Invert Switch\", PCM3168A_DAC_INV, 6, 7, 1, 0),\n\tSOC_ENUM(\"DAC Volume Control Type\", pcm3168a_dac_volume_type),\n\tSOC_ENUM(\"DAC Volume Rate Multiplier\", pcm3168a_dac_att_mult),\n\tSOC_ENUM(\"DAC De-Emphasis\", pcm3168a_dac_demp),\n\tSOC_ENUM(\"DAC Zero Flag Function\", pcm3168a_dac_zf_func),\n\tSOC_ENUM(\"DAC Zero Flag Polarity\", pcm3168a_dac_zf_pol),\n\tSOC_SINGLE_RANGE_TLV(\"Master Playback Volume\",\n\t\t\tPCM3168A_DAC_VOL_MASTER, 0, 54, 255, 0,\n\t\t\tpcm3168a_dac_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC1 Playback Volume\",\n\t\t\tPCM3168A_DAC_VOL_CHAN_START,\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 1,\n\t\t\t0, 54, 255, 0, pcm3168a_dac_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC2 Playback Volume\",\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 2,\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 3,\n\t\t\t0, 54, 255, 0, pcm3168a_dac_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC3 Playback Volume\",\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 4,\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 5,\n\t\t\t0, 54, 255, 0, pcm3168a_dac_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC4 Playback Volume\",\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 6,\n\t\t\tPCM3168A_DAC_VOL_CHAN_START + 7,\n\t\t\t0, 54, 255, 0, pcm3168a_dac_tlv),\n\tSOC_SINGLE(\"ADC1 High-Pass Filter Switch\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_BYP_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC2 High-Pass Filter Switch\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_BYP_SHIFT + 1, 1, 1),\n\tSOC_SINGLE(\"ADC3 High-Pass Filter Switch\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_BYP_SHIFT + 2, 1, 1),\n\tSOC_ENUM(\"ADC1 Connection Type\", pcm3168a_adc1_con),\n\tSOC_ENUM(\"ADC2 Connection Type\", pcm3168a_adc2_con),\n\tSOC_ENUM(\"ADC3 Connection Type\", pcm3168a_adc3_con),\n\tSOC_DOUBLE(\"ADC1 Invert Switch\", PCM3168A_ADC_INV, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"ADC2 Invert Switch\", PCM3168A_ADC_INV, 2, 3, 1, 0),\n\tSOC_DOUBLE(\"ADC3 Invert Switch\", PCM3168A_ADC_INV, 4, 5, 1, 0),\n\tSOC_DOUBLE(\"ADC1 Mute Switch\", PCM3168A_ADC_MUTE, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"ADC2 Mute Switch\", PCM3168A_ADC_MUTE, 2, 3, 1, 0),\n\tSOC_DOUBLE(\"ADC3 Mute Switch\", PCM3168A_ADC_MUTE, 4, 5, 1, 0),\n\tSOC_ENUM(\"ADC Volume Control Type\", pcm3168a_adc_volume_type),\n\tSOC_ENUM(\"ADC Volume Rate Multiplier\", pcm3168a_adc_att_mult),\n\tSOC_ENUM(\"ADC Overflow Flag Polarity\", pcm3168a_adc_ov_pol),\n\tSOC_SINGLE_RANGE_TLV(\"Master Capture Volume\",\n\t\t\tPCM3168A_ADC_VOL_MASTER, 0, 14, 255, 0,\n\t\t\tpcm3168a_adc_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"ADC1 Capture Volume\",\n\t\t\tPCM3168A_ADC_VOL_CHAN_START,\n\t\t\tPCM3168A_ADC_VOL_CHAN_START + 1,\n\t\t\t0, 14, 255, 0, pcm3168a_adc_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"ADC2 Capture Volume\",\n\t\t\tPCM3168A_ADC_VOL_CHAN_START + 2,\n\t\t\tPCM3168A_ADC_VOL_CHAN_START + 3,\n\t\t\t0, 14, 255, 0, pcm3168a_adc_tlv),\n\tSOC_DOUBLE_R_RANGE_TLV(\"ADC3 Capture Volume\",\n\t\t\tPCM3168A_ADC_VOL_CHAN_START + 4,\n\t\t\tPCM3168A_ADC_VOL_CHAN_START + 5,\n\t\t\t0, 14, 255, 0, pcm3168a_adc_tlv)\n};\n\nstatic const struct snd_soc_dapm_widget pcm3168a_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC1\", \"Playback\", PCM3168A_DAC_OP_FLT,\n\t\t\tPCM3168A_DAC_OPEDA_SHIFT, 1),\n\tSND_SOC_DAPM_DAC(\"DAC2\", \"Playback\", PCM3168A_DAC_OP_FLT,\n\t\t\tPCM3168A_DAC_OPEDA_SHIFT + 1, 1),\n\tSND_SOC_DAPM_DAC(\"DAC3\", \"Playback\", PCM3168A_DAC_OP_FLT,\n\t\t\tPCM3168A_DAC_OPEDA_SHIFT + 2, 1),\n\tSND_SOC_DAPM_DAC(\"DAC4\", \"Playback\", PCM3168A_DAC_OP_FLT,\n\t\t\tPCM3168A_DAC_OPEDA_SHIFT + 3, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"AOUT1L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT1R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT2L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT2R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT3L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT3R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT4L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT4R\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC1\", \"Capture\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_PSVAD_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC2\", \"Capture\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_PSVAD_SHIFT + 1, 1),\n\tSND_SOC_DAPM_ADC(\"ADC3\", \"Capture\", PCM3168A_ADC_PWR_HPFB,\n\t\t\tPCM3168A_ADC_PSVAD_SHIFT + 2, 1),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3R\")\n};\n\nstatic const struct snd_soc_dapm_route pcm3168a_dapm_routes[] = {\n\t \n\t{ \"AOUT1L\", NULL, \"DAC1\" },\n\t{ \"AOUT1R\", NULL, \"DAC1\" },\n\n\t{ \"AOUT2L\", NULL, \"DAC2\" },\n\t{ \"AOUT2R\", NULL, \"DAC2\" },\n\n\t{ \"AOUT3L\", NULL, \"DAC3\" },\n\t{ \"AOUT3R\", NULL, \"DAC3\" },\n\n\t{ \"AOUT4L\", NULL, \"DAC4\" },\n\t{ \"AOUT4R\", NULL, \"DAC4\" },\n\n\t \n\t{ \"ADC1\", NULL, \"AIN1L\" },\n\t{ \"ADC1\", NULL, \"AIN1R\" },\n\n\t{ \"ADC2\", NULL, \"AIN2L\" },\n\t{ \"ADC2\", NULL, \"AIN2R\" },\n\n\t{ \"ADC3\", NULL, \"AIN3L\" },\n\t{ \"ADC3\", NULL, \"AIN3R\" }\n};\n\nstatic unsigned int pcm3168a_scki_ratios[] = {\n\t768,\n\t512,\n\t384,\n\t256,\n\t192,\n\t128\n};\n\n#define PCM3168A_NUM_SCKI_RATIOS_DAC\tARRAY_SIZE(pcm3168a_scki_ratios)\n#define PCM3168A_NUM_SCKI_RATIOS_ADC\t(ARRAY_SIZE(pcm3168a_scki_ratios) - 2)\n\n#define PCM3168A_MAX_SYSCLK\t\t36864000\n\nstatic int pcm3168a_reset(struct pcm3168a_priv *pcm3168a)\n{\n\tint ret;\n\n\tret = regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));\n\n\treturn regmap_write(pcm3168a->regmap, PCM3168A_RST_SMODE,\n\t\t\tPCM3168A_MRST_MASK | PCM3168A_SRST_MASK);\n}\n\nstatic int pcm3168a_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);\n\n\tregmap_write(pcm3168a->regmap, PCM3168A_DAC_MUTE, mute ? 0xff : 0);\n\n\treturn 0;\n}\n\nstatic int pcm3168a_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\t \n\tif (freq == 0)\n\t\treturn 0;\n\n\tif (freq > PCM3168A_MAX_SYSCLK)\n\t\treturn -EINVAL;\n\n\tret = clk_set_rate(pcm3168a->scki, freq);\n\tif (ret)\n\t\treturn ret;\n\n\tpcm3168a->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic void pcm3168a_update_fixup_pcm_stream(struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);\n\tstruct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];\n\tu64 formats = SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE;\n\tunsigned int channel_max = dai->id == PCM3168A_DAI_DAC ? 8 : 6;\n\n\tif (io_params->format == SND_SOC_DAIFMT_RIGHT_J) {\n\t\t \n\t\tformats |= SNDRV_PCM_FMTBIT_S16_LE;\n\n\t\t \n\t\tif (io_params->tdm_slots != 2)\n\t\t\tchannel_max = 2;\n\t}\n\n\tif (dai->id == PCM3168A_DAI_DAC) {\n\t\tdai->driver->playback.channels_max = channel_max;\n\t\tdai->driver->playback.formats = formats;\n\t} else {\n\t\tdai->driver->capture.channels_max = channel_max;\n\t\tdai->driver->capture.formats = formats;\n\t}\n}\n\nstatic int pcm3168a_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);\n\tstruct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];\n\tbool provider_mode;\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tprovider_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tprovider_mode = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported provider mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tio_params->provider_mode = provider_mode;\n\tio_params->format = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\tpcm3168a_update_fixup_pcm_stream(dai);\n\n\treturn 0;\n}\n\nstatic int pcm3168a_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t unsigned int rx_mask, int slots,\n\t\t\t\t int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);\n\tstruct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];\n\n\tif (tx_mask >= (1<<slots) || rx_mask >= (1<<slots)) {\n\t\tdev_err(component->dev,\n\t\t\t\"Bad tdm mask tx: 0x%08x rx: 0x%08x slots %d\\n\",\n\t\t\ttx_mask, rx_mask, slots);\n\t\treturn -EINVAL;\n\t}\n\n\tif (slot_width &&\n\t    (slot_width != 16 && slot_width != 24 && slot_width != 32 )) {\n\t\tdev_err(component->dev, \"Unsupported slot_width %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tio_params->tdm_slots = slots;\n\tio_params->slot_width = slot_width;\n\t \n\tif (dai->id == PCM3168A_DAI_DAC)\n\t\tio_params->tdm_mask = tx_mask;\n\telse\n\t\tio_params->tdm_mask = rx_mask;\n\n\tpcm3168a_update_fixup_pcm_stream(dai);\n\n\treturn 0;\n}\n\nstatic int pcm3168a_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm3168a_priv *pcm3168a = snd_soc_component_get_drvdata(component);\n\tstruct pcm3168a_io_params *io_params = &pcm3168a->io_params[dai->id];\n\tbool provider_mode, tdm_mode;\n\tunsigned int format;\n\tunsigned int reg, mask, ms, ms_shift, fmt, fmt_shift, ratio, tdm_slots;\n\tint i, num_scki_ratios, slot_width;\n\n\tif (dai->id == PCM3168A_DAI_DAC) {\n\t\tnum_scki_ratios = PCM3168A_NUM_SCKI_RATIOS_DAC;\n\t\treg = PCM3168A_DAC_PWR_MST_FMT;\n\t\tmask = PCM3168A_DAC_MSDA_MASK | PCM3168A_DAC_FMT_MASK;\n\t\tms_shift = PCM3168A_DAC_MSDA_SHIFT;\n\t\tfmt_shift = PCM3168A_DAC_FMT_SHIFT;\n\t} else {\n\t\tnum_scki_ratios = PCM3168A_NUM_SCKI_RATIOS_ADC;\n\t\treg = PCM3168A_ADC_MST_FMT;\n\t\tmask = PCM3168A_ADC_MSAD_MASK | PCM3168A_ADC_FMTAD_MASK;\n\t\tms_shift = PCM3168A_ADC_MSAD_SHIFT;\n\t\tfmt_shift = PCM3168A_ADC_FMTAD_SHIFT;\n\t}\n\n\tprovider_mode = io_params->provider_mode;\n\n\tif (provider_mode) {\n\t\tratio = pcm3168a->sysclk / params_rate(params);\n\n\t\tfor (i = 0; i < num_scki_ratios; i++) {\n\t\t\tif (pcm3168a_scki_ratios[i] == ratio)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == num_scki_ratios) {\n\t\t\tdev_err(component->dev, \"unsupported sysclk ratio\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tms = (i + 1);\n\t} else {\n\t\tms = 0;\n\t}\n\n\tformat = io_params->format;\n\n\tif (io_params->slot_width)\n\t\tslot_width = io_params->slot_width;\n\telse\n\t\tslot_width = params_width(params);\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tif (provider_mode || (format != SND_SOC_DAIFMT_RIGHT_J)) {\n\t\t\tdev_err(component->dev, \"16-bit slots are supported only for consumer mode using right justified\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tif (provider_mode || (format == SND_SOC_DAIFMT_DSP_A) ||\n\t\t    \t\t     (format == SND_SOC_DAIFMT_DSP_B)) {\n\t\t\tdev_err(component->dev, \"24-bit slots not supported in provider mode, or consumer mode using DSP\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported frame size: %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tif (io_params->tdm_slots)\n\t\ttdm_slots = io_params->tdm_slots;\n\telse\n\t\ttdm_slots = params_channels(params);\n\n\t \n\ttdm_mode = (tdm_slots > 2);\n\n\tif (tdm_mode) {\n\t\tswitch (format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"TDM is supported under DSP/I2S/Left_J only\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfmt = tdm_mode ? PCM3168A_FMT_I2S_TDM : PCM3168A_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfmt = tdm_mode ? PCM3168A_FMT_LEFT_J_TDM : PCM3168A_FMT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tfmt = (slot_width == 16) ? PCM3168A_FMT_RIGHT_J_16 :\n\t\t\t\t\t   PCM3168A_FMT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tfmt = tdm_mode ? PCM3168A_FMT_I2S_TDM : PCM3168A_FMT_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tfmt = tdm_mode ? PCM3168A_FMT_LEFT_J_TDM : PCM3168A_FMT_DSP_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(pcm3168a->regmap, reg, mask,\n\t\t\t(ms << ms_shift) | (fmt << fmt_shift));\n\n\treturn 0;\n}\n\nstatic u64 pcm3168a_dai_formats[] = {\n\t \n\n\t \n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J,\n\t \n\tSND_SOC_POSSIBLE_DAIFMT_RIGHT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B,\n};\n\nstatic const struct snd_soc_dai_ops pcm3168a_dai_ops = {\n\t.set_fmt\t= pcm3168a_set_dai_fmt,\n\t.set_sysclk\t= pcm3168a_set_dai_sysclk,\n\t.hw_params\t= pcm3168a_hw_params,\n\t.mute_stream\t= pcm3168a_mute,\n\t.set_tdm_slot\t= pcm3168a_set_tdm_slot,\n\t.no_capture_mute = 1,\n\t.auto_selectable_formats\t= pcm3168a_dai_formats,\n\t.num_auto_selectable_formats\t= ARRAY_SIZE(pcm3168a_dai_formats),\n};\n\nstatic struct snd_soc_dai_driver pcm3168a_dais[] = {\n\t{\n\t\t.name = \"pcm3168a-dac\",\n\t\t.id = PCM3168A_DAI_DAC,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = PCM3168A_FORMATS\n\t\t},\n\t\t.ops = &pcm3168a_dai_ops\n\t},\n\t{\n\t\t.name = \"pcm3168a-adc\",\n\t\t.id = PCM3168A_DAI_ADC,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 6,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = PCM3168A_FORMATS\n\t\t},\n\t\t.ops = &pcm3168a_dai_ops\n\t},\n};\n\nstatic const struct reg_default pcm3168a_reg_default[] = {\n\t{ PCM3168A_RST_SMODE, PCM3168A_MRST_MASK | PCM3168A_SRST_MASK },\n\t{ PCM3168A_DAC_PWR_MST_FMT, 0x00 },\n\t{ PCM3168A_DAC_OP_FLT, 0x00 },\n\t{ PCM3168A_DAC_INV, 0x00 },\n\t{ PCM3168A_DAC_MUTE, 0x00 },\n\t{ PCM3168A_DAC_ZERO, 0x00 },\n\t{ PCM3168A_DAC_ATT_DEMP_ZF, 0x00 },\n\t{ PCM3168A_DAC_VOL_MASTER, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 1, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 2, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 3, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 4, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 5, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 6, 0xff },\n\t{ PCM3168A_DAC_VOL_CHAN_START + 7, 0xff },\n\t{ PCM3168A_ADC_SMODE, 0x00 },\n\t{ PCM3168A_ADC_MST_FMT, 0x00 },\n\t{ PCM3168A_ADC_PWR_HPFB, 0x00 },\n\t{ PCM3168A_ADC_SEAD, 0x00 },\n\t{ PCM3168A_ADC_INV, 0x00 },\n\t{ PCM3168A_ADC_MUTE, 0x00 },\n\t{ PCM3168A_ADC_OV, 0x00 },\n\t{ PCM3168A_ADC_ATT_OVF, 0x00 },\n\t{ PCM3168A_ADC_VOL_MASTER, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START + 1, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START + 2, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START + 3, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START + 4, 0xd3 },\n\t{ PCM3168A_ADC_VOL_CHAN_START + 5, 0xd3 }\n};\n\nstatic bool pcm3168a_readable_register(struct device *dev, unsigned int reg)\n{\n\tif (reg >= PCM3168A_RST_SMODE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool pcm3168a_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase PCM3168A_RST_SMODE:\n\tcase PCM3168A_DAC_ZERO:\n\tcase PCM3168A_ADC_OV:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool pcm3168a_writeable_register(struct device *dev, unsigned int reg)\n{\n\tif (reg < PCM3168A_RST_SMODE)\n\t\treturn false;\n\n\tswitch (reg) {\n\tcase PCM3168A_DAC_ZERO:\n\tcase PCM3168A_ADC_OV:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nconst struct regmap_config pcm3168a_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = PCM3168A_ADC_VOL_CHAN_START + 5,\n\t.reg_defaults = pcm3168a_reg_default,\n\t.num_reg_defaults = ARRAY_SIZE(pcm3168a_reg_default),\n\t.readable_reg = pcm3168a_readable_register,\n\t.volatile_reg = pcm3168a_volatile_register,\n\t.writeable_reg = pcm3168a_writeable_register,\n\t.cache_type = REGCACHE_FLAT\n};\nEXPORT_SYMBOL_GPL(pcm3168a_regmap);\n\nstatic const struct snd_soc_component_driver pcm3168a_driver = {\n\t.controls\t\t= pcm3168a_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm3168a_snd_controls),\n\t.dapm_widgets\t\t= pcm3168a_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm3168a_dapm_widgets),\n\t.dapm_routes\t\t= pcm3168a_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm3168a_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint pcm3168a_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct pcm3168a_priv *pcm3168a;\n\tint ret, i;\n\n\tpcm3168a = devm_kzalloc(dev, sizeof(*pcm3168a), GFP_KERNEL);\n\tif (pcm3168a == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, pcm3168a);\n\n\t \n\tpcm3168a->gpio_rst = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\tGPIOD_OUT_LOW |\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(pcm3168a->gpio_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcm3168a->gpio_rst),\n\t\t\t\t     \"failed to acquire RST gpio\\n\");\n\n\tpcm3168a->scki = devm_clk_get(dev, \"scki\");\n\tif (IS_ERR(pcm3168a->scki))\n\t\treturn dev_err_probe(dev, PTR_ERR(pcm3168a->scki),\n\t\t\t\t     \"failed to acquire clock 'scki'\\n\");\n\n\tret = clk_prepare_enable(pcm3168a->scki);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable mclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpcm3168a->sysclk = clk_get_rate(pcm3168a->scki);\n\n\tfor (i = 0; i < ARRAY_SIZE(pcm3168a->supplies); i++)\n\t\tpcm3168a->supplies[i].supply = pcm3168a_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev,\n\t\t\tARRAY_SIZE(pcm3168a->supplies), pcm3168a->supplies);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to request supplies\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),\n\t\t\t\t    pcm3168a->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\tpcm3168a->regmap = regmap;\n\tif (IS_ERR(pcm3168a->regmap)) {\n\t\tret = PTR_ERR(pcm3168a->regmap);\n\t\tdev_err(dev, \"failed to allocate regmap: %d\\n\", ret);\n\t\tgoto err_regulator;\n\t}\n\n\tif (pcm3168a->gpio_rst) {\n\t\t \n\t\tmsleep(DIV_ROUND_UP(3846 * 1000, pcm3168a->sysclk));\n\t} else {\n\t\tret = pcm3168a_reset(pcm3168a);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to reset device: %d\\n\", ret);\n\t\t\tgoto err_regulator;\n\t\t}\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\tmemcpy(pcm3168a->dai_drv, pcm3168a_dais, sizeof(pcm3168a->dai_drv));\n\tret = devm_snd_soc_register_component(dev, &pcm3168a_driver,\n\t\t\t\t\t      pcm3168a->dai_drv,\n\t\t\t\t\t      ARRAY_SIZE(pcm3168a->dai_drv));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register component: %d\\n\", ret);\n\t\tgoto err_regulator;\n\t}\n\n\treturn 0;\n\nerr_regulator:\n\tregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\n\t\t\tpcm3168a->supplies);\nerr_clk:\n\tclk_disable_unprepare(pcm3168a->scki);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(pcm3168a_probe);\n\nstatic void pcm3168a_disable(struct device *dev)\n{\n\tstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\n\n\tregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\n\t\t\t       pcm3168a->supplies);\n\tclk_disable_unprepare(pcm3168a->scki);\n}\n\nvoid pcm3168a_remove(struct device *dev)\n{\n\tstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\n\n\t \n\tgpiod_set_value_cansleep(pcm3168a->gpio_rst, 1);\n\tpm_runtime_disable(dev);\n#ifndef CONFIG_PM\n\tpcm3168a_disable(dev);\n#endif\n}\nEXPORT_SYMBOL_GPL(pcm3168a_remove);\n\n#ifdef CONFIG_PM\nstatic int pcm3168a_rt_resume(struct device *dev)\n{\n\tstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(pcm3168a->scki);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable mclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(pcm3168a->supplies),\n\t\t\t\t    pcm3168a->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\tret = pcm3168a_reset(pcm3168a);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to reset device: %d\\n\", ret);\n\t\tgoto err_regulator;\n\t}\n\n\tregcache_cache_only(pcm3168a->regmap, false);\n\n\tregcache_mark_dirty(pcm3168a->regmap);\n\n\tret = regcache_sync(pcm3168a->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to sync regmap: %d\\n\", ret);\n\t\tgoto err_regulator;\n\t}\n\n\treturn 0;\n\nerr_regulator:\n\tregulator_bulk_disable(ARRAY_SIZE(pcm3168a->supplies),\n\t\t\t       pcm3168a->supplies);\nerr_clk:\n\tclk_disable_unprepare(pcm3168a->scki);\n\n\treturn ret;\n}\n\nstatic int pcm3168a_rt_suspend(struct device *dev)\n{\n\tstruct pcm3168a_priv *pcm3168a = dev_get_drvdata(dev);\n\n\tregcache_cache_only(pcm3168a->regmap, true);\n\n\tpcm3168a_disable(dev);\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops pcm3168a_pm_ops = {\n\tSET_RUNTIME_PM_OPS(pcm3168a_rt_suspend, pcm3168a_rt_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(pcm3168a_pm_ops);\n\nMODULE_DESCRIPTION(\"PCM3168A codec driver\");\nMODULE_AUTHOR(\"Damien Horsley <Damien.Horsley@imgtec.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}