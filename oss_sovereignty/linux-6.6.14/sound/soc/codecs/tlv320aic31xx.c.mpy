{
  "module_name": "tlv320aic31xx.c",
  "hash_id": "efd9fc016bd96f09bb386105dbba7241a966d1e1fa9c4bfb7ee2e529c79c55c0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic31xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <dt-bindings/sound/tlv320aic31xx.h>\n\n#include \"tlv320aic31xx.h\"\n\nstatic int aic31xx_set_jack(struct snd_soc_component *component,\n                            struct snd_soc_jack *jack, void *data);\n\nstatic const struct reg_default aic31xx_reg_defaults[] = {\n\t{ AIC31XX_CLKMUX, 0x00 },\n\t{ AIC31XX_PLLPR, 0x11 },\n\t{ AIC31XX_PLLJ, 0x04 },\n\t{ AIC31XX_PLLDMSB, 0x00 },\n\t{ AIC31XX_PLLDLSB, 0x00 },\n\t{ AIC31XX_NDAC, 0x01 },\n\t{ AIC31XX_MDAC, 0x01 },\n\t{ AIC31XX_DOSRMSB, 0x00 },\n\t{ AIC31XX_DOSRLSB, 0x80 },\n\t{ AIC31XX_NADC, 0x01 },\n\t{ AIC31XX_MADC, 0x01 },\n\t{ AIC31XX_AOSR, 0x80 },\n\t{ AIC31XX_IFACE1, 0x00 },\n\t{ AIC31XX_DATA_OFFSET, 0x00 },\n\t{ AIC31XX_IFACE2, 0x00 },\n\t{ AIC31XX_BCLKN, 0x01 },\n\t{ AIC31XX_DACSETUP, 0x14 },\n\t{ AIC31XX_DACMUTE, 0x0c },\n\t{ AIC31XX_LDACVOL, 0x00 },\n\t{ AIC31XX_RDACVOL, 0x00 },\n\t{ AIC31XX_ADCSETUP, 0x00 },\n\t{ AIC31XX_ADCFGA, 0x80 },\n\t{ AIC31XX_ADCVOL, 0x00 },\n\t{ AIC31XX_HPDRIVER, 0x04 },\n\t{ AIC31XX_SPKAMP, 0x06 },\n\t{ AIC31XX_DACMIXERROUTE, 0x00 },\n\t{ AIC31XX_LANALOGHPL, 0x7f },\n\t{ AIC31XX_RANALOGHPR, 0x7f },\n\t{ AIC31XX_LANALOGSPL, 0x7f },\n\t{ AIC31XX_RANALOGSPR, 0x7f },\n\t{ AIC31XX_HPLGAIN, 0x02 },\n\t{ AIC31XX_HPRGAIN, 0x02 },\n\t{ AIC31XX_SPLGAIN, 0x00 },\n\t{ AIC31XX_SPRGAIN, 0x00 },\n\t{ AIC31XX_MICBIAS, 0x00 },\n\t{ AIC31XX_MICPGA, 0x80 },\n\t{ AIC31XX_MICPGAPI, 0x00 },\n\t{ AIC31XX_MICPGAMI, 0x00 },\n};\n\nstatic bool aic31xx_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AIC31XX_PAGECTL:  \n\tcase AIC31XX_RESET:  \n\tcase AIC31XX_OT_FLAG:\n\tcase AIC31XX_ADCFLAG:\n\tcase AIC31XX_DACFLAG1:\n\tcase AIC31XX_DACFLAG2:\n\tcase AIC31XX_OFFLAG:  \n\tcase AIC31XX_INTRDACFLAG:  \n\tcase AIC31XX_INTRADCFLAG:  \n\tcase AIC31XX_INTRDACFLAG2:\n\tcase AIC31XX_INTRADCFLAG2:\n\tcase AIC31XX_HSDETECT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool aic31xx_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AIC31XX_OT_FLAG:\n\tcase AIC31XX_ADCFLAG:\n\tcase AIC31XX_DACFLAG1:\n\tcase AIC31XX_DACFLAG2:\n\tcase AIC31XX_OFFLAG:  \n\tcase AIC31XX_INTRDACFLAG:  \n\tcase AIC31XX_INTRADCFLAG:  \n\tcase AIC31XX_INTRDACFLAG2:\n\tcase AIC31XX_INTRADCFLAG2:\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const struct regmap_range_cfg aic31xx_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 12 * 128,\n\t\t.selector_reg = AIC31XX_PAGECTL,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t},\n};\n\nstatic const struct regmap_config aic31xx_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = aic31xx_writeable,\n\t.volatile_reg = aic31xx_volatile,\n\t.reg_defaults = aic31xx_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(aic31xx_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n\t.ranges = aic31xx_ranges,\n\t.num_ranges = ARRAY_SIZE(aic31xx_ranges),\n\t.max_register = 12 * 128,\n};\n\nstatic const char * const aic31xx_supply_names[] = {\n\t\"HPVDD\",\n\t\"SPRVDD\",\n\t\"SPLVDD\",\n\t\"AVDD\",\n\t\"IOVDD\",\n\t\"DVDD\",\n};\n\n#define AIC31XX_NUM_SUPPLIES ARRAY_SIZE(aic31xx_supply_names)\n\nstruct aic31xx_disable_nb {\n\tstruct notifier_block nb;\n\tstruct aic31xx_priv *aic31xx;\n};\n\nstruct aic31xx_priv {\n\tstruct snd_soc_component *component;\n\tu8 i2c_regs_status;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tenum aic31xx_type codec_type;\n\tstruct gpio_desc *gpio_reset;\n\tint micbias_vg;\n\tstruct aic31xx_pdata pdata;\n\tstruct regulator_bulk_data supplies[AIC31XX_NUM_SUPPLIES];\n\tstruct aic31xx_disable_nb disable_nb[AIC31XX_NUM_SUPPLIES];\n\tstruct snd_soc_jack *jack;\n\tu32 sysclk_id;\n\tunsigned int sysclk;\n\tu8 p_div;\n\tint rate_div_line;\n\tbool master_dapm_route_applied;\n\tint irq;\n\tu8 ocmv;  \n};\n\nstruct aic31xx_rate_divs {\n\tu32 mclk_p;\n\tu32 rate;\n\tu8 pll_r;\n\tu8 pll_j;\n\tu16 pll_d;\n\tu16 dosr;\n\tu8 ndac;\n\tu8 mdac;\n\tu8 aosr;\n\tu8 nadc;\n\tu8 madc;\n};\n\n \nstatic const struct aic31xx_rate_divs aic31xx_divs[] = {\n\t \n\t \n\t{  512000,   8000,\t4, 48,   0,\t128,  48,  2,   128,  48,  2},\n\t{12000000,   8000,\t1, 8, 1920,\t128,  48,  2,\t128,  48,  2},\n\t{12000000,   8000,\t1, 8, 1920,\t128,  32,  3,\t128,  32,  3},\n\t{12500000,   8000,\t1, 7, 8643,\t128,  48,  2,\t128,  48,  2},\n\t \n\t{  705600,  11025,\t3, 48,   0,\t128,  24,  3,\t128,  24,  3},\n\t{12000000,  11025,\t1, 7, 5264,\t128,  32,  2,\t128,  32,  2},\n\t{12000000,  11025,\t1, 8, 4672,\t128,  24,  3,\t128,  24,  3},\n\t{12500000,  11025,\t1, 7, 2253,\t128,  32,  2,\t128,  32,  2},\n\t \n\t{  512000,  16000,\t4, 48,   0,\t128,  16,  3,\t128,  16,  3},\n\t{ 1024000,  16000,\t2, 48,   0,\t128,  16,  3,\t128,  16,  3},\n\t{12000000,  16000,\t1, 8, 1920,\t128,  24,  2,\t128,  24,  2},\n\t{12000000,  16000,\t1, 8, 1920,\t128,  16,  3,\t128,  16,  3},\n\t{12500000,  16000,\t1, 7, 8643,\t128,  24,  2,\t128,  24,  2},\n\t \n\t{  705600,  22050,\t4, 36,   0,\t128,  12,  3,\t128,  12,  3},\n\t{ 1411200,  22050,\t2, 36,   0,\t128,  12,  3,\t128,  12,  3},\n\t{12000000,  22050,\t1, 7, 5264,\t128,  16,  2,\t128,  16,  2},\n\t{12000000,  22050,\t1, 8, 4672,\t128,  12,  3,\t128,  12,  3},\n\t{12500000,  22050,\t1, 7, 2253,\t128,  16,  2,\t128,  16,  2},\n\t \n\t{ 1024000,  32000,      2, 48,   0,\t128,  12,  2,\t128,  12,  2},\n\t{ 2048000,  32000,      1, 48,   0,\t128,  12,  2,\t128,  12,  2},\n\t{12000000,  32000,\t1, 8, 1920,\t128,  12,  2,\t128,  12,  2},\n\t{12000000,  32000,\t1, 8, 1920,\t128,   8,  3,\t128,   8,  3},\n\t{12500000,  32000,\t1, 7, 8643,\t128,  12,  2,\t128,  12,  2},\n\t \n\t{ 1411200,  44100,\t2, 32,   0,\t128,   8,  2,\t128,   8,  2},\n\t{ 2822400,  44100,\t1, 32,   0,\t128,   8,  2,\t128,   8,  2},\n\t{12000000,  44100,\t1, 7, 5264,\t128,   8,  2,\t128,   8,  2},\n\t{12000000,  44100,\t1, 8, 4672,\t128,   6,  3,\t128,   6,  3},\n\t{12500000,  44100,\t1, 7, 2253,\t128,   8,  2,\t128,   8,  2},\n\t \n\t{ 1536000,  48000,\t2, 32,   0,\t128,   8,  2,\t128,   8,  2},\n\t{ 3072000,  48000,\t1, 32,   0,\t128,   8,  2,\t128,   8,  2},\n\t{12000000,  48000,\t1, 8, 1920,\t128,   8,  2,\t128,   8,  2},\n\t{12000000,  48000,\t1, 7, 6800,\t 96,   5,  4,\t 96,   5,  4},\n\t{12500000,  48000,\t1, 7, 8643,\t128,   8,  2,\t128,   8,  2},\n\t \n\t{ 2822400,  88200,\t2, 16,   0,\t 64,   8,  2,\t 64,   8,  2},\n\t{ 5644800,  88200,\t1, 16,   0,\t 64,   8,  2,\t 64,   8,  2},\n\t{12000000,  88200,\t1, 7, 5264,\t 64,   8,  2,\t 64,   8,  2},\n\t{12000000,  88200,\t1, 8, 4672,\t 64,   6,  3,\t 64,   6,  3},\n\t{12500000,  88200,\t1, 7, 2253,\t 64,   8,  2,\t 64,   8,  2},\n\t \n\t{ 3072000,  96000,\t2, 16,   0,\t 64,   8,  2,\t 64,   8,  2},\n\t{ 6144000,  96000,\t1, 16,   0,\t 64,   8,  2,\t 64,   8,  2},\n\t{12000000,  96000,\t1, 8, 1920,\t 64,   8,  2,\t 64,   8,  2},\n\t{12000000,  96000,\t1, 7, 6800,\t 48,   5,  4,\t 48,   5,  4},\n\t{12500000,  96000,\t1, 7, 8643,\t 64,   8,  2,\t 64,   8,  2},\n\t \n\t{ 5644800, 176400,\t2, 8,    0,\t 32,   8,  2,\t 32,   8,  2},\n\t{11289600, 176400,\t1, 8,    0,\t 32,   8,  2,\t 32,   8,  2},\n\t{12000000, 176400,\t1, 7, 5264,\t 32,   8,  2,\t 32,   8,  2},\n\t{12000000, 176400,\t1, 8, 4672,\t 32,   6,  3,\t 32,   6,  3},\n\t{12500000, 176400,\t1, 7, 2253,\t 32,   8,  2,\t 32,   8,  2},\n\t \n\t{ 6144000, 192000,\t2, 8,\t 0,\t 32,   8,  2,\t 32,   8,  2},\n\t{12288000, 192000,\t1, 8,\t 0,\t 32,   8,  2,\t 32,   8,  2},\n\t{12000000, 192000,\t1, 8, 1920,\t 32,   8,  2,\t 32,   8,  2},\n\t{12000000, 192000,\t1, 7, 6800,\t 24,   5,  4,\t 24,   5,  4},\n\t{12500000, 192000,\t1, 7, 8643,\t 32,   8,  2,\t 32,   8,  2},\n};\n\nstatic const char * const ldac_in_text[] = {\n\t\"Off\", \"Left Data\", \"Right Data\", \"Mono\"\n};\n\nstatic const char * const rdac_in_text[] = {\n\t\"Off\", \"Right Data\", \"Left Data\", \"Mono\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ldac_in_enum, AIC31XX_DACSETUP, 4, ldac_in_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rdac_in_enum, AIC31XX_DACSETUP, 2, rdac_in_text);\n\nstatic const char * const mic_select_text[] = {\n\t\"Off\", \"FFR 10 Ohm\", \"FFR 20 Ohm\", \"FFR 40 Ohm\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(mic1lp_p_enum, AIC31XX_MICPGAPI, 6,\n\tmic_select_text);\nstatic SOC_ENUM_SINGLE_DECL(mic1rp_p_enum, AIC31XX_MICPGAPI, 4,\n\tmic_select_text);\nstatic SOC_ENUM_SINGLE_DECL(mic1lm_p_enum, AIC31XX_MICPGAPI, 2,\n\tmic_select_text);\n\nstatic SOC_ENUM_SINGLE_DECL(mic1lm_m_enum, AIC31XX_MICPGAMI, 4,\n\tmic_select_text);\n\nstatic const char * const hp_poweron_time_text[] = {\n\t\"0us\", \"15.3us\", \"153us\", \"1.53ms\", \"15.3ms\", \"76.2ms\",\n\t\"153ms\", \"304ms\", \"610ms\", \"1.22s\", \"3.04s\", \"6.1s\" };\n\nstatic SOC_ENUM_SINGLE_DECL(hp_poweron_time_enum, AIC31XX_HPPOP, 3,\n\thp_poweron_time_text);\n\nstatic const char * const hp_rampup_step_text[] = {\n\t\"0ms\", \"0.98ms\", \"1.95ms\", \"3.9ms\" };\n\nstatic SOC_ENUM_SINGLE_DECL(hp_rampup_step_enum, AIC31XX_HPPOP, 1,\n\thp_rampup_step_text);\n\nstatic const char * const vol_soft_step_mode_text[] = {\n\t\"fast\", \"slow\", \"disabled\" };\n\nstatic SOC_ENUM_SINGLE_DECL(vol_soft_step_mode_enum, AIC31XX_DACSETUP, 0,\n\tvol_soft_step_mode_text);\n\nstatic const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -6350, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_fgain_tlv, 0, 10, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_cgain_tlv, -2000, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_pga_tlv, 0, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(hp_drv_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(class_D_drv_tlv, 600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(hp_vol_tlv, -6350, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(sp_vol_tlv, -6350, 50, 0);\n\n \nstatic const struct snd_kcontrol_new common31xx_snd_controls[] = {\n\tSOC_DOUBLE_R_S_TLV(\"DAC Playback Volume\", AIC31XX_LDACVOL,\n\t\t\t   AIC31XX_RDACVOL, 0, -127, 48, 7, 0, dac_vol_tlv),\n\n\tSOC_DOUBLE_R(\"HP Driver Playback Switch\", AIC31XX_HPLGAIN,\n\t\t     AIC31XX_HPRGAIN, 2, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"HP Driver Playback Volume\", AIC31XX_HPLGAIN,\n\t\t\t AIC31XX_HPRGAIN, 3, 0x09, 0, hp_drv_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"HP Analog Playback Volume\", AIC31XX_LANALOGHPL,\n\t\t\t AIC31XX_RANALOGHPR, 0, 0x7F, 1, hp_vol_tlv),\n\n\t \n\tSOC_ENUM(\"HP Output Driver Power-On time\", hp_poweron_time_enum),\n\tSOC_ENUM(\"HP Output Driver Ramp-up step\", hp_rampup_step_enum),\n\n\tSOC_ENUM(\"Volume Soft Stepping\", vol_soft_step_mode_enum),\n};\n\nstatic const struct snd_kcontrol_new aic31xx_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"ADC Fine Capture Volume\", AIC31XX_ADCFGA, 4, 4, 1,\n\t\t       adc_fgain_tlv),\n\n\tSOC_SINGLE(\"ADC Capture Switch\", AIC31XX_ADCFGA, 7, 1, 1),\n\tSOC_DOUBLE_R_S_TLV(\"ADC Capture Volume\", AIC31XX_ADCVOL, AIC31XX_ADCVOL,\n\t\t\t   0, -24, 40, 6, 0, adc_cgain_tlv),\n\n\tSOC_SINGLE_TLV(\"Mic PGA Capture Volume\", AIC31XX_MICPGA, 0,\n\t\t       119, 0, mic_pga_tlv),\n};\n\nstatic const struct snd_kcontrol_new aic311x_snd_controls[] = {\n\tSOC_DOUBLE_R(\"Speaker Driver Playback Switch\", AIC31XX_SPLGAIN,\n\t\t     AIC31XX_SPRGAIN, 2, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Speaker Driver Playback Volume\", AIC31XX_SPLGAIN,\n\t\t\t AIC31XX_SPRGAIN, 3, 3, 0, class_D_drv_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Speaker Analog Playback Volume\", AIC31XX_LANALOGSPL,\n\t\t\t AIC31XX_RANALOGSPR, 0, 0x7F, 1, sp_vol_tlv),\n};\n\nstatic const struct snd_kcontrol_new aic310x_snd_controls[] = {\n\tSOC_SINGLE(\"Speaker Driver Playback Switch\", AIC31XX_SPLGAIN,\n\t\t   2, 1, 0),\n\tSOC_SINGLE_TLV(\"Speaker Driver Playback Volume\", AIC31XX_SPLGAIN,\n\t\t       3, 3, 0, class_D_drv_tlv),\n\n\tSOC_SINGLE_TLV(\"Speaker Analog Playback Volume\", AIC31XX_LANALOGSPL,\n\t\t       0, 0x7F, 1, sp_vol_tlv),\n};\n\nstatic const struct snd_kcontrol_new ldac_in_control =\n\tSOC_DAPM_ENUM(\"DAC Left Input\", ldac_in_enum);\n\nstatic const struct snd_kcontrol_new rdac_in_control =\n\tSOC_DAPM_ENUM(\"DAC Right Input\", rdac_in_enum);\n\nstatic int aic31xx_wait_bits(struct aic31xx_priv *aic31xx, unsigned int reg,\n\t\t\t     unsigned int mask, unsigned int wbits, int sleep,\n\t\t\t     int count)\n{\n\tunsigned int bits;\n\tint counter = count;\n\tint ret = regmap_read(aic31xx->regmap, reg, &bits);\n\n\twhile ((bits & mask) != wbits && counter && !ret) {\n\t\tusleep_range(sleep, sleep * 2);\n\t\tret = regmap_read(aic31xx->regmap, reg, &bits);\n\t\tcounter--;\n\t}\n\tif ((bits & mask) != wbits) {\n\t\tdev_err(aic31xx->dev,\n\t\t\t\"%s: Failed! 0x%x was 0x%x expected 0x%x (%d, 0x%x, %d us)\\n\",\n\t\t\t__func__, reg, bits, wbits, ret, mask,\n\t\t\t(count - counter) * sleep);\n\t\tret = -1;\n\t}\n\treturn ret;\n}\n\n#define WIDGET_BIT(reg, shift) (((shift) << 8) | (reg))\n\nstatic int aic31xx_dapm_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tunsigned int reg = AIC31XX_DACFLAG1;\n\tunsigned int mask;\n\tunsigned int timeout = 500 * USEC_PER_MSEC;\n\n\tswitch (WIDGET_BIT(w->reg, w->shift)) {\n\tcase WIDGET_BIT(AIC31XX_DACSETUP, 7):\n\t\tmask = AIC31XX_LDACPWRSTATUS_MASK;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_DACSETUP, 6):\n\t\tmask = AIC31XX_RDACPWRSTATUS_MASK;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_HPDRIVER, 7):\n\t\tmask = AIC31XX_HPLDRVPWRSTATUS_MASK;\n\t\tif (event == SND_SOC_DAPM_POST_PMU)\n\t\t\ttimeout = 7 * USEC_PER_SEC;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_HPDRIVER, 6):\n\t\tmask = AIC31XX_HPRDRVPWRSTATUS_MASK;\n\t\tif (event == SND_SOC_DAPM_POST_PMU)\n\t\t\ttimeout = 7 * USEC_PER_SEC;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_SPKAMP, 7):\n\t\tmask = AIC31XX_SPLDRVPWRSTATUS_MASK;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_SPKAMP, 6):\n\t\tmask = AIC31XX_SPRDRVPWRSTATUS_MASK;\n\t\tbreak;\n\tcase WIDGET_BIT(AIC31XX_ADCSETUP, 7):\n\t\tmask = AIC31XX_ADCPWRSTATUS_MASK;\n\t\treg = AIC31XX_ADCFLAG;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown widget '%s' calling %s\\n\",\n\t\t\tw->name, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\treturn aic31xx_wait_bits(aic31xx, reg, mask, mask,\n\t\t\t\t5000, timeout / 5000);\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn aic31xx_wait_bits(aic31xx, reg, mask, 0,\n\t\t\t\t5000, timeout / 5000);\n\tdefault:\n\t\tdev_dbg(component->dev,\n\t\t\t\"Unhandled dapm widget event %d from %s\\n\",\n\t\t\tevent, w->name);\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new aic31xx_left_output_switches[] = {\n\tSOC_DAPM_SINGLE(\"From Left DAC\", AIC31XX_DACMIXERROUTE, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"From MIC1LP\", AIC31XX_DACMIXERROUTE, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"From MIC1RP\", AIC31XX_DACMIXERROUTE, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aic31xx_right_output_switches[] = {\n\tSOC_DAPM_SINGLE(\"From Right DAC\", AIC31XX_DACMIXERROUTE, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"From MIC1RP\", AIC31XX_DACMIXERROUTE, 1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new dac31xx_left_output_switches[] = {\n\tSOC_DAPM_SINGLE(\"From Left DAC\", AIC31XX_DACMIXERROUTE, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"From AIN1\", AIC31XX_DACMIXERROUTE, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"From AIN2\", AIC31XX_DACMIXERROUTE, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new dac31xx_right_output_switches[] = {\n\tSOC_DAPM_SINGLE(\"From Right DAC\", AIC31XX_DACMIXERROUTE, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"From AIN2\", AIC31XX_DACMIXERROUTE, 1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new p_term_mic1lp =\n\tSOC_DAPM_ENUM(\"MIC1LP P-Terminal\", mic1lp_p_enum);\n\nstatic const struct snd_kcontrol_new p_term_mic1rp =\n\tSOC_DAPM_ENUM(\"MIC1RP P-Terminal\", mic1rp_p_enum);\n\nstatic const struct snd_kcontrol_new p_term_mic1lm =\n\tSOC_DAPM_ENUM(\"MIC1LM P-Terminal\", mic1lm_p_enum);\n\nstatic const struct snd_kcontrol_new m_term_mic1lm =\n\tSOC_DAPM_ENUM(\"MIC1LM M-Terminal\", mic1lm_m_enum);\n\nstatic const struct snd_kcontrol_new aic31xx_dapm_hpl_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", AIC31XX_LANALOGHPL, 7, 1, 0);\n\nstatic const struct snd_kcontrol_new aic31xx_dapm_hpr_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", AIC31XX_RANALOGHPR, 7, 1, 0);\n\nstatic const struct snd_kcontrol_new aic31xx_dapm_spl_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", AIC31XX_LANALOGSPL, 7, 1, 0);\n\nstatic const struct snd_kcontrol_new aic31xx_dapm_spr_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", AIC31XX_RANALOGSPR, 7, 1, 0);\n\nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, AIC31XX_MICBIAS,\n\t\t\t\t    AIC31XX_MICBIAS_MASK,\n\t\t\t\t    aic31xx->micbias_vg <<\n\t\t\t\t    AIC31XX_MICBIAS_SHIFT);\n\t\tdev_dbg(component->dev, \"%s: turned on\\n\", __func__);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\t \n\t\tsnd_soc_component_update_bits(component, AIC31XX_MICBIAS,\n\t\t\t\t    AIC31XX_MICBIAS_MASK, 0);\n\t\tdev_dbg(component->dev, \"%s: turned off\\n\", __func__);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget common31xx_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"AIF IN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"DAC Left Input\",\n\t\t\t SND_SOC_NOPM, 0, 0, &ldac_in_control),\n\tSND_SOC_DAPM_MUX(\"DAC Right Input\",\n\t\t\t SND_SOC_NOPM, 0, 0, &rdac_in_control),\n\t \n\tSND_SOC_DAPM_DAC_E(\"DAC Left\", \"Left Playback\",\n\t\t\t   AIC31XX_DACSETUP, 7, 0, aic31xx_dapm_power_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_DAC_E(\"DAC Right\", \"Right Playback\",\n\t\t\t   AIC31XX_DACSETUP, 6, 0, aic31xx_dapm_power_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"HP Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aic31xx_dapm_hpl_switch),\n\tSND_SOC_DAPM_SWITCH(\"HP Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aic31xx_dapm_hpr_switch),\n\n\t \n\tSND_SOC_DAPM_OUT_DRV_E(\"HPL Driver\", AIC31XX_HPDRIVER, 7, 0,\n\t\t\t       NULL, 0, aic31xx_dapm_power_event,\n\t\t\t       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUT_DRV_E(\"HPR Driver\", AIC31XX_HPDRIVER, 6, 0,\n\t\t\t       NULL, 0, aic31xx_dapm_power_event,\n\t\t\t       SND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", SND_SOC_NOPM, 0, 0, mic_bias_event,\n\t\t\t    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Activate I2S clocks\", AIC31XX_IFACE2, 2, 0,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n};\n\nstatic const struct snd_soc_dapm_widget dac31xx_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Output Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t   dac31xx_left_output_switches,\n\t\t\t   ARRAY_SIZE(dac31xx_left_output_switches)),\n\tSND_SOC_DAPM_MIXER(\"Output Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t   dac31xx_right_output_switches,\n\t\t\t   ARRAY_SIZE(dac31xx_right_output_switches)),\n};\n\nstatic const struct snd_soc_dapm_widget aic31xx_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"MIC1LP\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1RP\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1LM\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"MIC1LP P-Terminal\", SND_SOC_NOPM, 0, 0,\n\t\t\t &p_term_mic1lp),\n\tSND_SOC_DAPM_MUX(\"MIC1RP P-Terminal\", SND_SOC_NOPM, 0, 0,\n\t\t\t &p_term_mic1rp),\n\tSND_SOC_DAPM_MUX(\"MIC1LM P-Terminal\", SND_SOC_NOPM, 0, 0,\n\t\t\t &p_term_mic1lm),\n\n\t \n\tSND_SOC_DAPM_ADC_E(\"ADC\", \"Capture\", AIC31XX_ADCSETUP, 7, 0,\n\t\t\t   aic31xx_dapm_power_event, SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MUX(\"MIC1LM M-Terminal\", SND_SOC_NOPM, 0, 0,\n\t\t\t &m_term_mic1lm),\n\n\t \n\tSND_SOC_DAPM_PGA(\"MIC_GAIN_CTL\", AIC31XX_MICPGA,\n\t\t\t 7, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Output Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t   aic31xx_left_output_switches,\n\t\t\t   ARRAY_SIZE(aic31xx_left_output_switches)),\n\tSND_SOC_DAPM_MIXER(\"Output Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t   aic31xx_right_output_switches,\n\t\t\t   ARRAY_SIZE(aic31xx_right_output_switches)),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIF OUT\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_widget aic311x_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_OUT_DRV_E(\"SPL ClassD\", AIC31XX_SPKAMP, 7, 0, NULL, 0,\n\t\t\t       aic31xx_dapm_power_event, SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUT_DRV_E(\"SPR ClassD\", AIC31XX_SPKAMP, 6, 0, NULL, 0,\n\t\t\t       aic31xx_dapm_power_event, SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH(\"Speaker Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aic31xx_dapm_spl_switch),\n\tSND_SOC_DAPM_SWITCH(\"Speaker Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aic31xx_dapm_spr_switch),\n\tSND_SOC_DAPM_OUTPUT(\"SPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPR\"),\n};\n\n \nstatic const struct snd_soc_dapm_widget aic310x_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUT_DRV_E(\"SPK ClassD\", AIC31XX_SPKAMP, 7, 0, NULL, 0,\n\t\t\t       aic31xx_dapm_power_event, SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH(\"Speaker\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &aic31xx_dapm_spl_switch),\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n};\n\nstatic const struct snd_soc_dapm_route\ncommon31xx_audio_map[] = {\n\t \n\t{\"DAC Left Input\", \"Left Data\", \"AIF IN\"},\n\t{\"DAC Left Input\", \"Right Data\", \"AIF IN\"},\n\t{\"DAC Left Input\", \"Mono\", \"AIF IN\"},\n\t{\"DAC Right Input\", \"Left Data\", \"AIF IN\"},\n\t{\"DAC Right Input\", \"Right Data\", \"AIF IN\"},\n\t{\"DAC Right Input\", \"Mono\", \"AIF IN\"},\n\t{\"DAC Left\", NULL, \"DAC Left Input\"},\n\t{\"DAC Right\", NULL, \"DAC Right Input\"},\n\n\t \n\t{\"HP Left\", \"Switch\", \"Output Left\"},\n\t{\"HPL Driver\", NULL, \"HP Left\"},\n\t{\"HPL\", NULL, \"HPL Driver\"},\n\n\t \n\t{\"HP Right\", \"Switch\", \"Output Right\"},\n\t{\"HPR Driver\", NULL, \"HP Right\"},\n\t{\"HPR\", NULL, \"HPR Driver\"},\n};\n\nstatic const struct snd_soc_dapm_route\ndac31xx_audio_map[] = {\n\t \n\t{\"Output Left\", \"From Left DAC\", \"DAC Left\"},\n\t{\"Output Left\", \"From AIN1\", \"AIN1\"},\n\t{\"Output Left\", \"From AIN2\", \"AIN2\"},\n\n\t \n\t{\"Output Right\", \"From Right DAC\", \"DAC Right\"},\n\t{\"Output Right\", \"From AIN2\", \"AIN2\"},\n};\n\nstatic const struct snd_soc_dapm_route\naic31xx_audio_map[] = {\n\t \n\t{\"MIC1LP P-Terminal\", \"FFR 10 Ohm\", \"MIC1LP\"},\n\t{\"MIC1LP P-Terminal\", \"FFR 20 Ohm\", \"MIC1LP\"},\n\t{\"MIC1LP P-Terminal\", \"FFR 40 Ohm\", \"MIC1LP\"},\n\t{\"MIC1RP P-Terminal\", \"FFR 10 Ohm\", \"MIC1RP\"},\n\t{\"MIC1RP P-Terminal\", \"FFR 20 Ohm\", \"MIC1RP\"},\n\t{\"MIC1RP P-Terminal\", \"FFR 40 Ohm\", \"MIC1RP\"},\n\t{\"MIC1LM P-Terminal\", \"FFR 10 Ohm\", \"MIC1LM\"},\n\t{\"MIC1LM P-Terminal\", \"FFR 20 Ohm\", \"MIC1LM\"},\n\t{\"MIC1LM P-Terminal\", \"FFR 40 Ohm\", \"MIC1LM\"},\n\n\t{\"MIC1LM M-Terminal\", \"FFR 10 Ohm\", \"MIC1LM\"},\n\t{\"MIC1LM M-Terminal\", \"FFR 20 Ohm\", \"MIC1LM\"},\n\t{\"MIC1LM M-Terminal\", \"FFR 40 Ohm\", \"MIC1LM\"},\n\n\t{\"MIC_GAIN_CTL\", NULL, \"MIC1LP P-Terminal\"},\n\t{\"MIC_GAIN_CTL\", NULL, \"MIC1RP P-Terminal\"},\n\t{\"MIC_GAIN_CTL\", NULL, \"MIC1LM P-Terminal\"},\n\t{\"MIC_GAIN_CTL\", NULL, \"MIC1LM M-Terminal\"},\n\n\t{\"ADC\", NULL, \"MIC_GAIN_CTL\"},\n\n\t{\"AIF OUT\", NULL, \"ADC\"},\n\n\t \n\t{\"Output Left\", \"From Left DAC\", \"DAC Left\"},\n\t{\"Output Left\", \"From MIC1LP\", \"MIC1LP\"},\n\t{\"Output Left\", \"From MIC1RP\", \"MIC1RP\"},\n\n\t \n\t{\"Output Right\", \"From Right DAC\", \"DAC Right\"},\n\t{\"Output Right\", \"From MIC1RP\", \"MIC1RP\"},\n};\n\nstatic const struct snd_soc_dapm_route\naic311x_audio_map[] = {\n\t \n\t{\"Speaker Left\", \"Switch\", \"Output Left\"},\n\t{\"SPL ClassD\", NULL, \"Speaker Left\"},\n\t{\"SPL\", NULL, \"SPL ClassD\"},\n\n\t \n\t{\"Speaker Right\", \"Switch\", \"Output Right\"},\n\t{\"SPR ClassD\", NULL, \"Speaker Right\"},\n\t{\"SPR\", NULL, \"SPR ClassD\"},\n};\n\nstatic const struct snd_soc_dapm_route\naic310x_audio_map[] = {\n\t \n\t{\"Speaker\", \"Switch\", \"Output Left\"},\n\t{\"SPK ClassD\", NULL, \"Speaker\"},\n\t{\"SPK\", NULL, \"SPK ClassD\"},\n};\n\n \nstatic const struct snd_soc_dapm_route\ncommon31xx_cm_audio_map[] = {\n\t{\"HPL\", NULL, \"AIF IN\"},\n\t{\"HPR\", NULL, \"AIF IN\"},\n\n\t{\"AIF IN\", NULL, \"Activate I2S clocks\"},\n};\n\nstatic const struct snd_soc_dapm_route\naic31xx_cm_audio_map[] = {\n\t{\"AIF OUT\", NULL, \"MIC1LP\"},\n\t{\"AIF OUT\", NULL, \"MIC1RP\"},\n\t{\"AIF OUT\", NULL, \"MIC1LM\"},\n\n\t{\"AIF OUT\", NULL, \"Activate I2S clocks\"},\n};\n\nstatic int aic31xx_add_controls(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\n\tif (!(aic31xx->codec_type & DAC31XX_BIT))\n\t\tret = snd_soc_add_component_controls(\n\t\t\tcomponent, aic31xx_snd_controls,\n\t\t\tARRAY_SIZE(aic31xx_snd_controls));\n\tif (ret)\n\t\treturn ret;\n\n\tif (aic31xx->codec_type & AIC31XX_STEREO_CLASS_D_BIT)\n\t\tret = snd_soc_add_component_controls(\n\t\t\tcomponent, aic311x_snd_controls,\n\t\t\tARRAY_SIZE(aic311x_snd_controls));\n\telse\n\t\tret = snd_soc_add_component_controls(\n\t\t\tcomponent, aic310x_snd_controls,\n\t\t\tARRAY_SIZE(aic310x_snd_controls));\n\n\treturn ret;\n}\n\nstatic int aic31xx_add_widgets(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (aic31xx->codec_type & DAC31XX_BIT) {\n\t\tret = snd_soc_dapm_new_controls(\n\t\t\tdapm, dac31xx_dapm_widgets,\n\t\t\tARRAY_SIZE(dac31xx_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, dac31xx_audio_map,\n\t\t\t\t\t      ARRAY_SIZE(dac31xx_audio_map));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = snd_soc_dapm_new_controls(\n\t\t\tdapm, aic31xx_dapm_widgets,\n\t\t\tARRAY_SIZE(aic31xx_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, aic31xx_audio_map,\n\t\t\t\t\t      ARRAY_SIZE(aic31xx_audio_map));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (aic31xx->codec_type & AIC31XX_STEREO_CLASS_D_BIT) {\n\t\tret = snd_soc_dapm_new_controls(\n\t\t\tdapm, aic311x_dapm_widgets,\n\t\t\tARRAY_SIZE(aic311x_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, aic311x_audio_map,\n\t\t\t\t\t      ARRAY_SIZE(aic311x_audio_map));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = snd_soc_dapm_new_controls(\n\t\t\tdapm, aic310x_dapm_widgets,\n\t\t\tARRAY_SIZE(aic310x_dapm_widgets));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, aic310x_audio_map,\n\t\t\t\t\t      ARRAY_SIZE(aic310x_audio_map));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int aic31xx_setup_pll(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_hw_params *params)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint bclk_score = snd_soc_params_to_frame_size(params);\n\tint mclk_p;\n\tint bclk_n = 0;\n\tint match = -1;\n\tint i;\n\n\tif (!aic31xx->sysclk || !aic31xx->p_div) {\n\t\tdev_err(component->dev, \"Master clock not supplied\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmclk_p = aic31xx->sysclk / aic31xx->p_div;\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_CLKMUX,\n\t\t\t    AIC31XX_CODEC_CLKIN_MASK, AIC31XX_CODEC_CLKIN_PLL);\n\tsnd_soc_component_update_bits(component, AIC31XX_IFACE2,\n\t\t\t    AIC31XX_BDIVCLK_MASK, AIC31XX_DAC2BCLK);\n\n\tfor (i = 0; i < ARRAY_SIZE(aic31xx_divs); i++) {\n\t\tif (aic31xx_divs[i].rate == params_rate(params) &&\n\t\t    aic31xx_divs[i].mclk_p == mclk_p) {\n\t\t\tint s =\t(aic31xx_divs[i].dosr * aic31xx_divs[i].mdac) %\n\t\t\t\tsnd_soc_params_to_frame_size(params);\n\t\t\tint bn = (aic31xx_divs[i].dosr * aic31xx_divs[i].mdac) /\n\t\t\t\tsnd_soc_params_to_frame_size(params);\n\t\t\tif (s < bclk_score && bn > 0) {\n\t\t\t\tmatch = i;\n\t\t\t\tbclk_n = bn;\n\t\t\t\tbclk_score = s;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (match == -1) {\n\t\tdev_err(component->dev,\n\t\t\t\"%s: Sample rate (%u) and format not supported\\n\",\n\t\t\t__func__, params_rate(params));\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tif (bclk_score != 0) {\n\t\tdev_warn(component->dev, \"Can not produce exact bitclock\");\n\t\t \n\t}\n\ti = match;\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_PLLPR, AIC31XX_PLL_MASK,\n\t\t\t    (aic31xx->p_div << 4) | aic31xx_divs[i].pll_r);\n\tsnd_soc_component_write(component, AIC31XX_PLLJ, aic31xx_divs[i].pll_j);\n\n\tsnd_soc_component_write(component, AIC31XX_PLLDMSB,\n\t\t      aic31xx_divs[i].pll_d >> 8);\n\tsnd_soc_component_write(component, AIC31XX_PLLDLSB,\n\t\t      aic31xx_divs[i].pll_d & 0xff);\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_NDAC, AIC31XX_PLL_MASK,\n\t\t\t    aic31xx_divs[i].ndac);\n\tsnd_soc_component_update_bits(component, AIC31XX_MDAC, AIC31XX_PLL_MASK,\n\t\t\t    aic31xx_divs[i].mdac);\n\n\tsnd_soc_component_write(component, AIC31XX_DOSRMSB, aic31xx_divs[i].dosr >> 8);\n\tsnd_soc_component_write(component, AIC31XX_DOSRLSB, aic31xx_divs[i].dosr & 0xff);\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_NADC, AIC31XX_PLL_MASK,\n\t\t\t    aic31xx_divs[i].nadc ? aic31xx_divs[i].nadc : 1);\n\tsnd_soc_component_update_bits(component, AIC31XX_MADC, AIC31XX_PLL_MASK,\n\t\t\t    aic31xx_divs[i].madc ? aic31xx_divs[i].madc : 1);\n\n\tsnd_soc_component_write(component, AIC31XX_AOSR, aic31xx_divs[i].aosr);\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_BCLKN,\n\t\t\t    AIC31XX_PLL_MASK, bclk_n);\n\n\taic31xx->rate_div_line = i;\n\n\tdev_dbg(component->dev,\n\t\t\"pll %d.%04d/%d dosr %d n %d m %d aosr %d n %d m %d bclk_n %d\\n\",\n\t\taic31xx_divs[i].pll_j,\n\t\taic31xx_divs[i].pll_d,\n\t\taic31xx->p_div,\n\t\taic31xx_divs[i].dosr,\n\t\taic31xx_divs[i].ndac,\n\t\taic31xx_divs[i].mdac,\n\t\taic31xx_divs[i].aosr,\n\t\taic31xx_divs[i].nadc,\n\t\taic31xx_divs[i].madc,\n\t\tbclk_n\n\t);\n\n\treturn 0;\n}\n\nstatic int aic31xx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tu8 data = 0;\n\n\tdev_dbg(component->dev, \"## %s: width %d rate %d\\n\",\n\t\t__func__, params_width(params),\n\t\tparams_rate(params));\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tdata = (AIC31XX_WORD_LEN_20BITS <<\n\t\t\tAIC31XX_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tcase 24:\n\t\tdata = (AIC31XX_WORD_LEN_24BITS <<\n\t\t\tAIC31XX_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tcase 32:\n\t\tdata = (AIC31XX_WORD_LEN_32BITS <<\n\t\t\tAIC31XX_IFACE1_DATALEN_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: Unsupported width %d\\n\",\n\t\t\t__func__, params_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIC31XX_IFACE1,\n\t\t\t    AIC31XX_IFACE1_DATALEN_MASK,\n\t\t\t    data);\n\n\t \n\tif (aic31xx->sysclk_id == AIC31XX_PLL_CLKIN_BCLK) {\n\t\taic31xx->sysclk = params_rate(params) * params_width(params) *\n\t\t\t\t  params_channels(params);\n\t\taic31xx->p_div = 1;\n\t}\n\n\treturn aic31xx_setup_pll(component, params);\n}\n\nstatic int aic31xx_dac_mute(struct snd_soc_dai *codec_dai, int mute,\n\t\t\t    int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tif (mute) {\n\t\tsnd_soc_component_update_bits(component, AIC31XX_DACMUTE,\n\t\t\t\t    AIC31XX_DACMUTE_MASK,\n\t\t\t\t    AIC31XX_DACMUTE_MASK);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, AIC31XX_DACMUTE,\n\t\t\t\t    AIC31XX_DACMUTE_MASK, 0x0);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic31xx_clock_master_routes(struct snd_soc_component *component,\n\t\t\t\t       unsigned int fmt)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tfmt &= SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tif (fmt == SND_SOC_DAIFMT_CBC_CFC &&\n\t    aic31xx->master_dapm_route_applied) {\n\t\t \n\t\tret = snd_soc_dapm_del_routes(dapm, common31xx_cm_audio_map,\n\t\t\t\t\tARRAY_SIZE(common31xx_cm_audio_map));\n\t\tif (!ret && !(aic31xx->codec_type & DAC31XX_BIT))\n\t\t\tret = snd_soc_dapm_del_routes(dapm,\n\t\t\t\t\taic31xx_cm_audio_map,\n\t\t\t\t\tARRAY_SIZE(aic31xx_cm_audio_map));\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taic31xx->master_dapm_route_applied = false;\n\t} else if (fmt != SND_SOC_DAIFMT_CBC_CFC &&\n\t\t   !aic31xx->master_dapm_route_applied) {\n\t\t \n\t\tret = snd_soc_dapm_add_routes(dapm, common31xx_cm_audio_map,\n\t\t\t\t\tARRAY_SIZE(common31xx_cm_audio_map));\n\t\tif (!ret && !(aic31xx->codec_type & DAC31XX_BIT))\n\t\t\tret = snd_soc_dapm_add_routes(dapm,\n\t\t\t\t\taic31xx_cm_audio_map,\n\t\t\t\t\tARRAY_SIZE(aic31xx_cm_audio_map));\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taic31xx->master_dapm_route_applied = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int aic31xx_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t       unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 iface_reg1 = 0;\n\tu8 iface_reg2 = 0;\n\tu8 dsp_a_val = 0;\n\n\tdev_dbg(component->dev, \"## %s: fmt = 0x%x\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface_reg1 |= AIC31XX_BCLK_MASTER | AIC31XX_WCLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tiface_reg1 |= AIC31XX_WCLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tiface_reg1 |= AIC31XX_BCLK_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock provider\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface_reg2 |= AIC31XX_BCLKINV_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI clock signal polarity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tdsp_a_val = 0x1;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tiface_reg2 ^= AIC31XX_BCLKINV_MASK;\n\t\tiface_reg1 |= (AIC31XX_DSP_MODE <<\n\t\t\t       AIC31XX_IFACE1_DATATYPE_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tiface_reg1 |= (AIC31XX_RIGHT_JUSTIFIED_MODE <<\n\t\t\t       AIC31XX_IFACE1_DATATYPE_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface_reg1 |= (AIC31XX_LEFT_JUSTIFIED_MODE <<\n\t\t\t       AIC31XX_IFACE1_DATATYPE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI interface format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AIC31XX_IFACE1,\n\t\t\t    AIC31XX_IFACE1_DATATYPE_MASK |\n\t\t\t    AIC31XX_IFACE1_MASTER_MASK,\n\t\t\t    iface_reg1);\n\tsnd_soc_component_update_bits(component, AIC31XX_DATA_OFFSET,\n\t\t\t    AIC31XX_DATA_OFFSET_MASK,\n\t\t\t    dsp_a_val);\n\tsnd_soc_component_update_bits(component, AIC31XX_IFACE2,\n\t\t\t    AIC31XX_BCLKINV_MASK,\n\t\t\t    iface_reg2);\n\n\treturn aic31xx_clock_master_routes(component, fmt);\n}\n\nstatic int aic31xx_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tdev_dbg(component->dev, \"## %s: clk_id = %d, freq = %d, dir = %d\\n\",\n\t\t__func__, clk_id, freq, dir);\n\n\tfor (i = 1; i < 8; i++)\n\t\tif (freq / i <= 20000000)\n\t\t\tbreak;\n\tif (freq/i > 20000000) {\n\t\tdev_err(aic31xx->dev, \"%s: Too high mclk frequency %u\\n\",\n\t\t\t__func__, freq);\n\t\treturn -EINVAL;\n\t}\n\taic31xx->p_div = i;\n\n\tfor (i = 0; i < ARRAY_SIZE(aic31xx_divs); i++)\n\t\tif (aic31xx_divs[i].mclk_p == freq / aic31xx->p_div)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(aic31xx_divs)) {\n\t\tdev_err(aic31xx->dev, \"%s: Unsupported frequency %d\\n\",\n\t\t\t__func__, freq);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_CLKMUX, AIC31XX_PLL_CLKIN_MASK,\n\t\t\t    clk_id << AIC31XX_PLL_CLKIN_SHIFT);\n\n\taic31xx->sysclk_id = clk_id;\n\taic31xx->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int aic31xx_regulator_event(struct notifier_block *nb,\n\t\t\t\t   unsigned long event, void *data)\n{\n\tstruct aic31xx_disable_nb *disable_nb =\n\t\tcontainer_of(nb, struct aic31xx_disable_nb, nb);\n\tstruct aic31xx_priv *aic31xx = disable_nb->aic31xx;\n\n\tif (event & REGULATOR_EVENT_DISABLE) {\n\t\t \n\t\tif (aic31xx->gpio_reset)\n\t\t\tgpiod_set_value(aic31xx->gpio_reset, 1);\n\n\t\tregcache_mark_dirty(aic31xx->regmap);\n\t\tdev_dbg(aic31xx->dev, \"## %s: DISABLE received\\n\", __func__);\n\t}\n\n\treturn 0;\n}\n\nstatic int aic31xx_reset(struct aic31xx_priv *aic31xx)\n{\n\tint ret = 0;\n\n\tif (aic31xx->gpio_reset) {\n\t\tgpiod_set_value(aic31xx->gpio_reset, 1);\n\t\tndelay(10);  \n\t\tgpiod_set_value(aic31xx->gpio_reset, 0);\n\t} else {\n\t\tret = regmap_write(aic31xx->regmap, AIC31XX_RESET, 1);\n\t}\n\tmdelay(1);  \n\n\treturn ret;\n}\n\nstatic void aic31xx_clk_on(struct snd_soc_component *component)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tu8 mask = AIC31XX_PM_MASK;\n\tu8 on = AIC31XX_PM_MASK;\n\n\tdev_dbg(component->dev, \"codec clock -> on (rate %d)\\n\",\n\t\taic31xx_divs[aic31xx->rate_div_line].rate);\n\tsnd_soc_component_update_bits(component, AIC31XX_PLLPR, mask, on);\n\tmdelay(10);\n\tsnd_soc_component_update_bits(component, AIC31XX_NDAC, mask, on);\n\tsnd_soc_component_update_bits(component, AIC31XX_MDAC, mask, on);\n\tif (aic31xx_divs[aic31xx->rate_div_line].nadc)\n\t\tsnd_soc_component_update_bits(component, AIC31XX_NADC, mask, on);\n\tif (aic31xx_divs[aic31xx->rate_div_line].madc)\n\t\tsnd_soc_component_update_bits(component, AIC31XX_MADC, mask, on);\n\tsnd_soc_component_update_bits(component, AIC31XX_BCLKN, mask, on);\n}\n\nstatic void aic31xx_clk_off(struct snd_soc_component *component)\n{\n\tu8 mask = AIC31XX_PM_MASK;\n\tu8 off = 0;\n\n\tdev_dbg(component->dev, \"codec clock -> off\\n\");\n\tsnd_soc_component_update_bits(component, AIC31XX_BCLKN, mask, off);\n\tsnd_soc_component_update_bits(component, AIC31XX_MADC, mask, off);\n\tsnd_soc_component_update_bits(component, AIC31XX_NADC, mask, off);\n\tsnd_soc_component_update_bits(component, AIC31XX_MDAC, mask, off);\n\tsnd_soc_component_update_bits(component, AIC31XX_NDAC, mask, off);\n\tsnd_soc_component_update_bits(component, AIC31XX_PLLPR, mask, off);\n}\n\nstatic int aic31xx_power_on(struct snd_soc_component *component)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(aic31xx->supplies),\n\t\t\t\t    aic31xx->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(aic31xx->regmap, false);\n\n\t \n\tret = aic31xx_reset(aic31xx);\n\tif (ret < 0)\n\t\tdev_err(aic31xx->dev, \"Could not reset device: %d\\n\", ret);\n\n\tret = regcache_sync(aic31xx->regmap);\n\tif (ret) {\n\t\tdev_err(component->dev,\n\t\t\t\"Failed to restore cache: %d\\n\", ret);\n\t\tregcache_cache_only(aic31xx->regmap, true);\n\t\tregulator_bulk_disable(ARRAY_SIZE(aic31xx->supplies),\n\t\t\t\t       aic31xx->supplies);\n\t\treturn ret;\n\t}\n\n\t \n\taic31xx_set_jack(component, aic31xx->jack, NULL);\n\n\treturn 0;\n}\n\nstatic void aic31xx_power_off(struct snd_soc_component *component)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(aic31xx->regmap, true);\n\tregulator_bulk_disable(ARRAY_SIZE(aic31xx->supplies),\n\t\t\t       aic31xx->supplies);\n}\n\nstatic int aic31xx_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tdev_dbg(component->dev, \"## %s: %d -> %d\\n\", __func__,\n\t\tsnd_soc_component_get_bias_level(component), level);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY)\n\t\t\taic31xx_clk_on(component);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tswitch (snd_soc_component_get_bias_level(component)) {\n\t\tcase SND_SOC_BIAS_OFF:\n\t\t\taic31xx_power_on(component);\n\t\t\tbreak;\n\t\tcase SND_SOC_BIAS_PREPARE:\n\t\t\taic31xx_clk_off(component);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY)\n\t\t\taic31xx_power_off(component);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int aic31xx_set_jack(struct snd_soc_component *component,\n\t\t\t    struct snd_soc_jack *jack, void *data)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\n\taic31xx->jack = jack;\n\n\t \n\tregmap_write(aic31xx->regmap, AIC31XX_HSDETECT,\n\t\t     jack ? AIC31XX_HSD_ENABLE : 0);\n\n\treturn 0;\n}\n\nstatic int aic31xx_codec_probe(struct snd_soc_component *component)\n{\n\tstruct aic31xx_priv *aic31xx = snd_soc_component_get_drvdata(component);\n\tint i, ret;\n\n\tdev_dbg(aic31xx->dev, \"## %s\\n\", __func__);\n\n\taic31xx->component = component;\n\n\tfor (i = 0; i < ARRAY_SIZE(aic31xx->supplies); i++) {\n\t\taic31xx->disable_nb[i].nb.notifier_call =\n\t\t\taic31xx_regulator_event;\n\t\taic31xx->disable_nb[i].aic31xx = aic31xx;\n\t\tret = devm_regulator_register_notifier(\n\t\t\t\t\t\taic31xx->supplies[i].consumer,\n\t\t\t\t\t\t&aic31xx->disable_nb[i].nb);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to request regulator notifier: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tregcache_cache_only(aic31xx->regmap, true);\n\tregcache_mark_dirty(aic31xx->regmap);\n\n\tret = aic31xx_add_controls(component);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aic31xx_add_widgets(component);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsnd_soc_component_update_bits(component, AIC31XX_HPDRIVER,\n\t\t\t\t      AIC31XX_HPD_OCMV_MASK,\n\t\t\t\t      aic31xx->ocmv << AIC31XX_HPD_OCMV_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_driver_aic31xx = {\n\t.probe\t\t\t= aic31xx_codec_probe,\n\t.set_jack\t\t= aic31xx_set_jack,\n\t.set_bias_level\t\t= aic31xx_set_bias_level,\n\t.controls\t\t= common31xx_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(common31xx_snd_controls),\n\t.dapm_widgets\t\t= common31xx_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(common31xx_dapm_widgets),\n\t.dapm_routes\t\t= common31xx_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(common31xx_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops aic31xx_dai_ops = {\n\t.hw_params\t= aic31xx_hw_params,\n\t.set_sysclk\t= aic31xx_set_dai_sysclk,\n\t.set_fmt\t= aic31xx_set_dai_fmt,\n\t.mute_stream\t= aic31xx_dac_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver dac31xx_dai_driver[] = {\n\t{\n\t\t.name = \"tlv320dac31xx-hifi\",\n\t\t.playback = {\n\t\t\t.stream_name\t = \"Playback\",\n\t\t\t.channels_min\t = 2,\n\t\t\t.channels_max\t = 2,\n\t\t\t.rates\t\t = AIC31XX_RATES,\n\t\t\t.formats\t = AIC31XX_FORMATS,\n\t\t},\n\t\t.ops = &aic31xx_dai_ops,\n\t\t.symmetric_rate = 1,\n\t}\n};\n\nstatic struct snd_soc_dai_driver aic31xx_dai_driver[] = {\n\t{\n\t\t.name = \"tlv320aic31xx-hifi\",\n\t\t.playback = {\n\t\t\t.stream_name\t = \"Playback\",\n\t\t\t.channels_min\t = 2,\n\t\t\t.channels_max\t = 2,\n\t\t\t.rates\t\t = AIC31XX_RATES,\n\t\t\t.formats\t = AIC31XX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name\t = \"Capture\",\n\t\t\t.channels_min\t = 2,\n\t\t\t.channels_max\t = 2,\n\t\t\t.rates\t\t = AIC31XX_RATES,\n\t\t\t.formats\t = AIC31XX_FORMATS,\n\t\t},\n\t\t.ops = &aic31xx_dai_ops,\n\t\t.symmetric_rate = 1,\n\t}\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id tlv320aic31xx_of_match[] = {\n\t{ .compatible = \"ti,tlv320aic310x\" },\n\t{ .compatible = \"ti,tlv320aic311x\" },\n\t{ .compatible = \"ti,tlv320aic3100\" },\n\t{ .compatible = \"ti,tlv320aic3110\" },\n\t{ .compatible = \"ti,tlv320aic3120\" },\n\t{ .compatible = \"ti,tlv320aic3111\" },\n\t{ .compatible = \"ti,tlv320dac3100\" },\n\t{ .compatible = \"ti,tlv320dac3101\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tlv320aic31xx_of_match);\n#endif  \n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id aic31xx_acpi_match[] = {\n\t{ \"10TI3100\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, aic31xx_acpi_match);\n#endif\n\nstatic irqreturn_t aic31xx_irq(int irq, void *data)\n{\n\tstruct aic31xx_priv *aic31xx = data;\n\tstruct device *dev = aic31xx->dev;\n\tunsigned int value;\n\tbool handled = false;\n\tint ret;\n\n\tret = regmap_read(aic31xx->regmap, AIC31XX_INTRDACFLAG, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read interrupt mask: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (value)\n\t\thandled = true;\n\telse\n\t\tgoto read_overflow;\n\n\tif (value & AIC31XX_HPLSCDETECT)\n\t\tdev_err(dev, \"Short circuit on Left output is detected\\n\");\n\tif (value & AIC31XX_HPRSCDETECT)\n\t\tdev_err(dev, \"Short circuit on Right output is detected\\n\");\n\tif (value & (AIC31XX_HSPLUG | AIC31XX_BUTTONPRESS)) {\n\t\tunsigned int val;\n\t\tint status = 0;\n\n\t\tret = regmap_read(aic31xx->regmap, AIC31XX_INTRDACFLAG2,\n\t\t\t\t  &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to read interrupt mask: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (val & AIC31XX_BUTTONPRESS)\n\t\t\tstatus |= SND_JACK_BTN_0;\n\n\t\tret = regmap_read(aic31xx->regmap, AIC31XX_HSDETECT, &val);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to read headset type: %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tswitch ((val & AIC31XX_HSD_TYPE_MASK) >>\n\t\t\tAIC31XX_HSD_TYPE_SHIFT) {\n\t\tcase AIC31XX_HSD_HP:\n\t\t\tstatus |= SND_JACK_HEADPHONE;\n\t\t\tbreak;\n\t\tcase AIC31XX_HSD_HS:\n\t\t\tstatus |= SND_JACK_HEADSET;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (aic31xx->jack)\n\t\t\tsnd_soc_jack_report(aic31xx->jack, status,\n\t\t\t\t\t    AIC31XX_JACK_MASK);\n\t}\n\tif (value & ~(AIC31XX_HPLSCDETECT |\n\t\t      AIC31XX_HPRSCDETECT |\n\t\t      AIC31XX_HSPLUG |\n\t\t      AIC31XX_BUTTONPRESS))\n\t\tdev_err(dev, \"Unknown DAC interrupt flags: 0x%08x\\n\", value);\n\nread_overflow:\n\tret = regmap_read(aic31xx->regmap, AIC31XX_OFFLAG, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read overflow flag: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (value)\n\t\thandled = true;\n\telse\n\t\tgoto exit;\n\n\tif (value & AIC31XX_DAC_OF_LEFT)\n\t\tdev_warn(dev, \"Left-channel DAC overflow has occurred\\n\");\n\tif (value & AIC31XX_DAC_OF_RIGHT)\n\t\tdev_warn(dev, \"Right-channel DAC overflow has occurred\\n\");\n\tif (value & AIC31XX_DAC_OF_SHIFTER)\n\t\tdev_warn(dev, \"DAC barrel shifter overflow has occurred\\n\");\n\tif (value & AIC31XX_ADC_OF)\n\t\tdev_warn(dev, \"ADC overflow has occurred\\n\");\n\tif (value & AIC31XX_ADC_OF_SHIFTER)\n\t\tdev_warn(dev, \"ADC barrel shifter overflow has occurred\\n\");\n\tif (value & ~(AIC31XX_DAC_OF_LEFT |\n\t\t      AIC31XX_DAC_OF_RIGHT |\n\t\t      AIC31XX_DAC_OF_SHIFTER |\n\t\t      AIC31XX_ADC_OF |\n\t\t      AIC31XX_ADC_OF_SHIFTER))\n\t\tdev_warn(dev, \"Unknown overflow interrupt flags: 0x%08x\\n\", value);\n\nexit:\n\tif (handled)\n\t\treturn IRQ_HANDLED;\n\telse\n\t\treturn IRQ_NONE;\n}\n\nstatic void aic31xx_configure_ocmv(struct aic31xx_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tint dvdd, avdd;\n\tu32 value;\n\n\tif (dev->fwnode &&\n\t    fwnode_property_read_u32(dev->fwnode, \"ai31xx-ocmv\", &value)) {\n\t\t \n\t\tif (value <= 3) {\n\t\t\tpriv->ocmv = value;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tavdd = regulator_get_voltage(priv->supplies[3].consumer);\n\tdvdd = regulator_get_voltage(priv->supplies[5].consumer);\n\n\tif (avdd > 3600000 || dvdd > 1950000) {\n\t\tdev_warn(dev,\n\t\t\t \"Too high supply voltage(s) AVDD: %d, DVDD: %d\\n\",\n\t\t\t avdd, dvdd);\n\t} else if (avdd == 3600000 && dvdd == 1950000) {\n\t\tpriv->ocmv = AIC31XX_HPD_OCMV_1_8V;\n\t} else if (avdd >= 3300000 && dvdd >= 1800000) {\n\t\tpriv->ocmv = AIC31XX_HPD_OCMV_1_65V;\n\t} else if (avdd >= 3000000 && dvdd >= 1650000) {\n\t\tpriv->ocmv = AIC31XX_HPD_OCMV_1_5V;\n\t} else if (avdd >= 2700000 && dvdd >= 1525000) {\n\t\tpriv->ocmv = AIC31XX_HPD_OCMV_1_35V;\n\t} else {\n\t\tdev_warn(dev,\n\t\t\t \"Invalid supply voltage(s) AVDD: %d, DVDD: %d\\n\",\n\t\t\t avdd, dvdd);\n\t}\n}\n\nstatic const struct i2c_device_id aic31xx_i2c_id[] = {\n\t{ \"tlv320aic310x\", AIC3100 },\n\t{ \"tlv320aic311x\", AIC3110 },\n\t{ \"tlv320aic3100\", AIC3100 },\n\t{ \"tlv320aic3110\", AIC3110 },\n\t{ \"tlv320aic3120\", AIC3120 },\n\t{ \"tlv320aic3111\", AIC3111 },\n\t{ \"tlv320dac3100\", DAC3100 },\n\t{ \"tlv320dac3101\", DAC3101 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, aic31xx_i2c_id);\n\nstatic int aic31xx_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct aic31xx_priv *aic31xx;\n\tunsigned int micbias_value = MICBIAS_2_0V;\n\tconst struct i2c_device_id *id = i2c_match_id(aic31xx_i2c_id, i2c);\n\tint i, ret;\n\n\tdev_dbg(&i2c->dev, \"## %s: %s codec_type = %d\\n\", __func__,\n\t\tid->name, (int)id->driver_data);\n\n\taic31xx = devm_kzalloc(&i2c->dev, sizeof(*aic31xx), GFP_KERNEL);\n\tif (!aic31xx)\n\t\treturn -ENOMEM;\n\n\taic31xx->regmap = devm_regmap_init_i2c(i2c, &aic31xx_i2c_regmap);\n\tif (IS_ERR(aic31xx->regmap)) {\n\t\tret = PTR_ERR(aic31xx->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tregcache_cache_only(aic31xx->regmap, true);\n\n\taic31xx->dev = &i2c->dev;\n\taic31xx->irq = i2c->irq;\n\n\taic31xx->codec_type = id->driver_data;\n\n\tdev_set_drvdata(aic31xx->dev, aic31xx);\n\n\tfwnode_property_read_u32(aic31xx->dev->fwnode, \"ai31xx-micbias-vg\",\n\t\t\t\t &micbias_value);\n\tswitch (micbias_value) {\n\tcase MICBIAS_2_0V:\n\tcase MICBIAS_2_5V:\n\tcase MICBIAS_AVDDV:\n\t\taic31xx->micbias_vg = micbias_value;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(aic31xx->dev, \"Bad ai31xx-micbias-vg value %d\\n\",\n\t\t\tmicbias_value);\n\t\taic31xx->micbias_vg = MICBIAS_2_0V;\n\t}\n\n\tif (dev_get_platdata(aic31xx->dev)) {\n\t\tmemcpy(&aic31xx->pdata, dev_get_platdata(aic31xx->dev), sizeof(aic31xx->pdata));\n\t\taic31xx->codec_type = aic31xx->pdata.codec_type;\n\t\taic31xx->micbias_vg = aic31xx->pdata.micbias_vg;\n\t}\n\n\taic31xx->gpio_reset = devm_gpiod_get_optional(aic31xx->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(aic31xx->gpio_reset))\n\t\treturn dev_err_probe(aic31xx->dev, PTR_ERR(aic31xx->gpio_reset),\n\t\t\t\t     \"not able to acquire gpio\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(aic31xx->supplies); i++)\n\t\taic31xx->supplies[i].supply = aic31xx_supply_names[i];\n\n\tret = devm_regulator_bulk_get(aic31xx->dev,\n\t\t\t\t      ARRAY_SIZE(aic31xx->supplies),\n\t\t\t\t      aic31xx->supplies);\n\tif (ret)\n\t\treturn dev_err_probe(aic31xx->dev, ret, \"Failed to request supplies\\n\");\n\n\taic31xx_configure_ocmv(aic31xx);\n\n\tif (aic31xx->irq > 0) {\n\t\tregmap_update_bits(aic31xx->regmap, AIC31XX_GPIO1,\n\t\t\t\t   AIC31XX_GPIO1_FUNC_MASK,\n\t\t\t\t   AIC31XX_GPIO1_INT1 <<\n\t\t\t\t   AIC31XX_GPIO1_FUNC_SHIFT);\n\n\t\tregmap_write(aic31xx->regmap, AIC31XX_INT1CTRL,\n\t\t\t     AIC31XX_HSPLUGDET |\n\t\t\t     AIC31XX_BUTTONPRESSDET |\n\t\t\t     AIC31XX_SC |\n\t\t\t     AIC31XX_ENGINE);\n\n\t\tret = devm_request_threaded_irq(aic31xx->dev, aic31xx->irq,\n\t\t\t\t\t\tNULL, aic31xx_irq,\n\t\t\t\t\t\tIRQF_ONESHOT, \"aic31xx-irq\",\n\t\t\t\t\t\taic31xx);\n\t\tif (ret) {\n\t\t\tdev_err(aic31xx->dev, \"Unable to request IRQ\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (aic31xx->codec_type & DAC31XX_BIT)\n\t\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_codec_driver_aic31xx,\n\t\t\t\tdac31xx_dai_driver,\n\t\t\t\tARRAY_SIZE(dac31xx_dai_driver));\n\telse\n\t\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_codec_driver_aic31xx,\n\t\t\t\taic31xx_dai_driver,\n\t\t\t\tARRAY_SIZE(aic31xx_dai_driver));\n}\n\nstatic struct i2c_driver aic31xx_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"tlv320aic31xx-codec\",\n\t\t.of_match_table = of_match_ptr(tlv320aic31xx_of_match),\n\t\t.acpi_match_table = ACPI_PTR(aic31xx_acpi_match),\n\t},\n\t.probe\t\t= aic31xx_i2c_probe,\n\t.id_table\t= aic31xx_i2c_id,\n};\nmodule_i2c_driver(aic31xx_i2c_driver);\n\nMODULE_AUTHOR(\"Jyri Sarha <jsarha@ti.com>\");\nMODULE_DESCRIPTION(\"ASoC TLV320AIC31xx CODEC Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}