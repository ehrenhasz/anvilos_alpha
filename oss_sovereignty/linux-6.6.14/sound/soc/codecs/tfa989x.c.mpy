{
  "module_name": "tfa989x.c",
  "hash_id": "b7ffa1ca403bb8d6e09b06f1af50e02813584808c676038b82b295527e5922db",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tfa989x.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n\n#define TFA989X_STATUSREG\t\t0x00\n#define TFA989X_BATTERYVOLTAGE\t\t0x01\n#define TFA989X_TEMPERATURE\t\t0x02\n#define TFA989X_REVISIONNUMBER\t\t0x03\n#define TFA989X_REVISIONNUMBER_REV_MSK\tGENMASK(7, 0)\t \n#define TFA989X_I2SREG\t\t\t0x04\n#define TFA989X_I2SREG_RCV\t\t2\t \n#define TFA989X_I2SREG_CHSA\t\t6\t \n#define TFA989X_I2SREG_CHSA_MSK\t\tGENMASK(7, 6)\n#define TFA989X_I2SREG_I2SSR\t\t12\t \n#define TFA989X_I2SREG_I2SSR_MSK\tGENMASK(15, 12)\n#define TFA989X_BAT_PROT\t\t0x05\n#define TFA989X_AUDIO_CTR\t\t0x06\n#define TFA989X_DCDCBOOST\t\t0x07\n#define TFA989X_SPKR_CALIBRATION\t0x08\n#define TFA989X_SYS_CTRL\t\t0x09\n#define TFA989X_SYS_CTRL_PWDN\t\t0\t \n#define TFA989X_SYS_CTRL_I2CR\t\t1\t \n#define TFA989X_SYS_CTRL_CFE\t\t2\t \n#define TFA989X_SYS_CTRL_AMPE\t\t3\t \n#define TFA989X_SYS_CTRL_DCA\t\t4\t \n#define TFA989X_SYS_CTRL_SBSL\t\t5\t \n#define TFA989X_SYS_CTRL_AMPC\t\t6\t \n#define TFA989X_I2S_SEL_REG\t\t0x0a\n#define TFA989X_I2S_SEL_REG_SPKR_MSK\tGENMASK(10, 9)\t \n#define TFA989X_I2S_SEL_REG_DCFG_MSK\tGENMASK(14, 11)\t \n#define TFA989X_HIDE_UNHIDE_KEY\t0x40\n#define TFA989X_PWM_CONTROL\t\t0x41\n#define TFA989X_CURRENTSENSE1\t\t0x46\n#define TFA989X_CURRENTSENSE2\t\t0x47\n#define TFA989X_CURRENTSENSE3\t\t0x48\n#define TFA989X_CURRENTSENSE4\t\t0x49\n\n#define TFA9890_REVISION\t\t0x80\n#define TFA9895_REVISION\t\t0x12\n#define TFA9897_REVISION\t\t0x97\n\nstruct tfa989x_rev {\n\tunsigned int rev;\n\tint (*init)(struct regmap *regmap);\n};\n\nstruct tfa989x {\n\tconst struct tfa989x_rev *rev;\n\tstruct regulator *vddd_supply;\n\tstruct gpio_desc *rcv_gpiod;\n};\n\nstatic bool tfa989x_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg > TFA989X_REVISIONNUMBER;\n}\n\nstatic bool tfa989x_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg < TFA989X_REVISIONNUMBER;\n}\n\nstatic const struct regmap_config tfa989x_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.writeable_reg\t= tfa989x_writeable_reg,\n\t.volatile_reg\t= tfa989x_volatile_reg,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic const char * const chsa_text[] = { \"Left\", \"Right\",   };\nstatic SOC_ENUM_SINGLE_DECL(chsa_enum, TFA989X_I2SREG, TFA989X_I2SREG_CHSA, chsa_text);\nstatic const struct snd_kcontrol_new chsa_mux = SOC_DAPM_ENUM(\"Amp Input\", chsa_enum);\n\nstatic const struct snd_soc_dapm_widget tfa989x_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n\tSND_SOC_DAPM_SUPPLY(\"POWER\", TFA989X_SYS_CTRL, TFA989X_SYS_CTRL_PWDN, 1, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"AMPE\", TFA989X_SYS_CTRL, TFA989X_SYS_CTRL_AMPE, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Amp Input\", SND_SOC_NOPM, 0, 0, &chsa_mux),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"HiFi Playback\", 1, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route tfa989x_dapm_routes[] = {\n\t{\"OUT\", NULL, \"AMPE\"},\n\t{\"AMPE\", NULL, \"POWER\"},\n\t{\"AMPE\", NULL, \"Amp Input\"},\n\t{\"Amp Input\", \"Left\", \"AIFINL\"},\n\t{\"Amp Input\", \"Right\", \"AIFINR\"},\n};\n\nstatic int tfa989x_put_mode(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tfa989x *tfa989x = snd_soc_component_get_drvdata(component);\n\n\tgpiod_set_value_cansleep(tfa989x->rcv_gpiod, ucontrol->value.enumerated.item[0]);\n\n\treturn snd_soc_put_enum_double(kcontrol, ucontrol);\n}\n\nstatic const char * const mode_text[] = { \"Speaker\", \"Receiver\" };\nstatic SOC_ENUM_SINGLE_DECL(mode_enum, TFA989X_I2SREG, TFA989X_I2SREG_RCV, mode_text);\nstatic const struct snd_kcontrol_new tfa989x_mode_controls[] = {\n\tSOC_ENUM_EXT(\"Mode\", mode_enum, snd_soc_get_enum_double, tfa989x_put_mode),\n};\n\nstatic int tfa989x_probe(struct snd_soc_component *component)\n{\n\tstruct tfa989x *tfa989x = snd_soc_component_get_drvdata(component);\n\n\tif (tfa989x->rev->rev == TFA9897_REVISION)\n\t\treturn snd_soc_add_component_controls(component, tfa989x_mode_controls,\n\t\t\t\t\t\t      ARRAY_SIZE(tfa989x_mode_controls));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver tfa989x_component = {\n\t.probe\t\t\t= tfa989x_probe,\n\t.dapm_widgets\t\t= tfa989x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tfa989x_dapm_widgets),\n\t.dapm_routes\t\t= tfa989x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tfa989x_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const unsigned int tfa989x_rates[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000\n};\n\nstatic int tfa989x_find_sample_rate(unsigned int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tfa989x_rates); ++i)\n\t\tif (tfa989x_rates[i] == rate)\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int tfa989x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint sr;\n\n\tsr = tfa989x_find_sample_rate(params_rate(params));\n\tif (sr < 0)\n\t\treturn sr;\n\n\treturn snd_soc_component_update_bits(component, TFA989X_I2SREG,\n\t\t\t\t\t     TFA989X_I2SREG_I2SSR_MSK,\n\t\t\t\t\t     sr << TFA989X_I2SREG_I2SSR);\n}\n\nstatic const struct snd_soc_dai_ops tfa989x_dai_ops = {\n\t.hw_params = tfa989x_hw_params,\n};\n\nstatic struct snd_soc_dai_driver tfa989x_dai = {\n\t.name = \"tfa989x-hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"HiFi Playback\",\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S16_LE,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_48000,\n\t\t.rate_min\t= 8000,\n\t\t.rate_max\t= 48000,\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t},\n\t.ops = &tfa989x_dai_ops,\n};\n\nstatic int tfa9890_init(struct regmap *regmap)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(regmap, TFA989X_HIDE_UNHIDE_KEY, 0x5a6b);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_set_bits(regmap, 0x59, 0x3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(regmap, TFA989X_HIDE_UNHIDE_KEY, 0x0000);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(regmap, TFA989X_CURRENTSENSE2, 0x7BE1);\n}\n\nstatic const struct tfa989x_rev tfa9890_rev = {\n\t.rev\t= TFA9890_REVISION,\n\t.init\t= tfa9890_init,\n};\n\nstatic const struct reg_sequence tfa9895_reg_init[] = {\n\t \n\t{ TFA989X_BAT_PROT, 0x13ab },\n\t{ TFA989X_AUDIO_CTR, 0x001f },\n\n\t \n\t{ TFA989X_SPKR_CALIBRATION, 0x3c4e },\n\n\t \n\t{ TFA989X_SYS_CTRL, 0x024d },\n\t{ TFA989X_PWM_CONTROL, 0x0308 },\n\t{ TFA989X_CURRENTSENSE4, 0x0e82 },\n};\n\nstatic int tfa9895_init(struct regmap *regmap)\n{\n\treturn regmap_multi_reg_write(regmap, tfa9895_reg_init,\n\t\t\t\t      ARRAY_SIZE(tfa9895_reg_init));\n}\n\nstatic const struct tfa989x_rev tfa9895_rev = {\n\t.rev\t= TFA9895_REVISION,\n\t.init\t= tfa9895_init,\n};\n\nstatic int tfa9897_init(struct regmap *regmap)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(regmap, TFA989X_CURRENTSENSE3, 0x0300);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_clear_bits(regmap, TFA989X_CURRENTSENSE4, 0x1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_write(regmap, 0x14, 0x0);\n}\n\nstatic const struct tfa989x_rev tfa9897_rev = {\n\t.rev\t= TFA9897_REVISION,\n\t.init\t= tfa9897_init,\n};\n\n \nstatic int tfa989x_dsp_bypass(struct regmap *regmap)\n{\n\tint ret;\n\n\t \n\tret = regmap_clear_bits(regmap, TFA989X_I2SREG, TFA989X_I2SREG_CHSA_MSK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TFA989X_I2S_SEL_REG,\n\t\t\t\t TFA989X_I2S_SEL_REG_DCFG_MSK |\n\t\t\t\t TFA989X_I2S_SEL_REG_SPKR_MSK,\n\t\t\t\t TFA989X_I2S_SEL_REG_SPKR_MSK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn regmap_clear_bits(regmap, TFA989X_SYS_CTRL,\n\t\t\t\t BIT(TFA989X_SYS_CTRL_DCA) |\n\t\t\t\t BIT(TFA989X_SYS_CTRL_CFE) |\n\t\t\t\t BIT(TFA989X_SYS_CTRL_AMPC));\n}\n\nstatic void tfa989x_regulator_disable(void *data)\n{\n\tstruct tfa989x *tfa989x = data;\n\n\tregulator_disable(tfa989x->vddd_supply);\n}\n\nstatic int tfa989x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tconst struct tfa989x_rev *rev;\n\tstruct tfa989x *tfa989x;\n\tstruct regmap *regmap;\n\tunsigned int val;\n\tint ret;\n\n\trev = device_get_match_data(dev);\n\tif (!rev) {\n\t\tdev_err(dev, \"unknown device revision\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttfa989x = devm_kzalloc(dev, sizeof(*tfa989x), GFP_KERNEL);\n\tif (!tfa989x)\n\t\treturn -ENOMEM;\n\n\ttfa989x->rev = rev;\n\ti2c_set_clientdata(i2c, tfa989x);\n\n\ttfa989x->vddd_supply = devm_regulator_get(dev, \"vddd\");\n\tif (IS_ERR(tfa989x->vddd_supply))\n\t\treturn dev_err_probe(dev, PTR_ERR(tfa989x->vddd_supply),\n\t\t\t\t     \"Failed to get vddd regulator\\n\");\n\n\tif (tfa989x->rev->rev == TFA9897_REVISION) {\n\t\ttfa989x->rcv_gpiod = devm_gpiod_get_optional(dev, \"rcv\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(tfa989x->rcv_gpiod))\n\t\t\treturn PTR_ERR(tfa989x->rcv_gpiod);\n\t}\n\n\tregmap = devm_regmap_init_i2c(i2c, &tfa989x_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = regulator_enable(tfa989x->vddd_supply);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable vddd regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, tfa989x_regulator_disable, tfa989x);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregcache_cache_bypass(regmap, true);\n\n\t \n\tregmap_read(regmap, TFA989X_REVISIONNUMBER, &val);\n\n\tret = regmap_read(regmap, TFA989X_REVISIONNUMBER, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to read revision number: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tval &= TFA989X_REVISIONNUMBER_REV_MSK;\n\tif (val != rev->rev) {\n\t\tdev_err(dev, \"invalid revision number, expected %#x, got %#x\\n\",\n\t\t\trev->rev, val);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_write(regmap, TFA989X_SYS_CTRL, BIT(TFA989X_SYS_CTRL_I2CR));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to reset I2C registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rev->init(regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize registers: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tfa989x_dsp_bypass(regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable DSP bypass: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tregcache_cache_bypass(regmap, false);\n\n\treturn devm_snd_soc_register_component(dev, &tfa989x_component,\n\t\t\t\t\t       &tfa989x_dai, 1);\n}\n\nstatic const struct of_device_id tfa989x_of_match[] = {\n\t{ .compatible = \"nxp,tfa9890\", .data = &tfa9890_rev },\n\t{ .compatible = \"nxp,tfa9895\", .data = &tfa9895_rev },\n\t{ .compatible = \"nxp,tfa9897\", .data = &tfa9897_rev },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tfa989x_of_match);\n\nstatic struct i2c_driver tfa989x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tfa989x\",\n\t\t.of_match_table = tfa989x_of_match,\n\t},\n\t.probe = tfa989x_i2c_probe,\n};\nmodule_i2c_driver(tfa989x_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC NXP/Goodix TFA989X (TFA1) driver\");\nMODULE_AUTHOR(\"Stephan Gerhold <stephan@gerhold.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}