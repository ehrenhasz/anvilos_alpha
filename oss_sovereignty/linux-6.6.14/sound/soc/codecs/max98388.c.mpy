{
  "module_name": "max98388.c",
  "hash_id": "72389a192d9b6992a9e8d7e7b6ab1e4f3c26b12398386a8b3464086a4f5a04e8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98388.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"max98388.h\"\n\nstatic struct reg_default max98388_reg[] = {\n\t{MAX98388_R2000_SW_RESET, 0x00},\n\t{MAX98388_R2001_INT_RAW1, 0x00},\n\t{MAX98388_R2002_INT_RAW2, 0x00},\n\t{MAX98388_R2004_INT_STATE1, 0x00},\n\t{MAX98388_R2005_INT_STATE2, 0x00},\n\t{MAX98388_R2020_THERM_WARN_THRESH, 0x0A},\n\t{MAX98388_R2031_SPK_MON_THRESH, 0x58},\n\t{MAX98388_R2032_SPK_MON_LD_SEL, 0x08},\n\t{MAX98388_R2033_SPK_MON_DURATION, 0x02},\n\t{MAX98388_R2037_ERR_MON_CTRL, 0x01},\n\t{MAX98388_R2040_PCM_MODE_CFG, 0xC0},\n\t{MAX98388_R2041_PCM_CLK_SETUP, 0x04},\n\t{MAX98388_R2042_PCM_SR_SETUP, 0x88},\n\t{MAX98388_R2044_PCM_TX_CTRL1, 0x00},\n\t{MAX98388_R2045_PCM_TX_CTRL2, 0x00},\n\t{MAX98388_R2050_PCM_TX_HIZ_CTRL1, 0xFF},\n\t{MAX98388_R2051_PCM_TX_HIZ_CTRL2, 0xFF},\n\t{MAX98388_R2052_PCM_TX_HIZ_CTRL3, 0xFF},\n\t{MAX98388_R2053_PCM_TX_HIZ_CTRL4, 0xFF},\n\t{MAX98388_R2054_PCM_TX_HIZ_CTRL5, 0xFF},\n\t{MAX98388_R2055_PCM_TX_HIZ_CTRL6, 0xFF},\n\t{MAX98388_R2056_PCM_TX_HIZ_CTRL7, 0xFF},\n\t{MAX98388_R2057_PCM_TX_HIZ_CTRL8, 0xFF},\n\t{MAX98388_R2058_PCM_RX_SRC1, 0x00},\n\t{MAX98388_R2059_PCM_RX_SRC2, 0x01},\n\t{MAX98388_R205C_PCM_TX_DRIVE_STRENGTH, 0x00},\n\t{MAX98388_R205D_PCM_TX_SRC_EN, 0x00},\n\t{MAX98388_R205E_PCM_RX_EN, 0x00},\n\t{MAX98388_R205F_PCM_TX_EN, 0x00},\n\t{MAX98388_R2090_SPK_CH_VOL_CTRL, 0x00},\n\t{MAX98388_R2091_SPK_CH_CFG, 0x02},\n\t{MAX98388_R2092_SPK_AMP_OUT_CFG, 0x03},\n\t{MAX98388_R2093_SPK_AMP_SSM_CFG, 0x01},\n\t{MAX98388_R2094_SPK_AMP_ER_CTRL, 0x00},\n\t{MAX98388_R209E_SPK_CH_PINK_NOISE_EN, 0x00},\n\t{MAX98388_R209F_SPK_CH_AMP_EN, 0x00},\n\t{MAX98388_R20A0_IV_DATA_DSP_CTRL, 0x10},\n\t{MAX98388_R20A7_IV_DATA_EN, 0x00},\n\t{MAX98388_R20E0_BP_ALC_THRESH, 0x04},\n\t{MAX98388_R20E1_BP_ALC_RATES, 0x20},\n\t{MAX98388_R20E2_BP_ALC_ATTEN, 0x06},\n\t{MAX98388_R20E3_BP_ALC_REL, 0x02},\n\t{MAX98388_R20E4_BP_ALC_MUTE, 0x33},\n\t{MAX98388_R20EE_BP_INF_HOLD_REL, 0x00},\n\t{MAX98388_R20EF_BP_ALC_EN, 0x00},\n\t{MAX98388_R210E_AUTO_RESTART, 0x00},\n\t{MAX98388_R210F_GLOBAL_EN, 0x00},\n\t{MAX98388_R22FF_REV_ID, 0x00},\n};\n\nstatic int max98388_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(max98388->regmap,\n\t\t\t     MAX98388_R210F_GLOBAL_EN, 1);\n\t\tusleep_range(30000, 31000);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(max98388->regmap,\n\t\t\t     MAX98388_R210F_GLOBAL_EN, 0);\n\t\tusleep_range(30000, 31000);\n\t\tmax98388->tdm_mode = false;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic const char * const max98388_monomix_switch_text[] = {\n\t\"Left\", \"Right\", \"LeftRight\"};\n\nstatic const struct soc_enum dai_sel_enum =\n\tSOC_ENUM_SINGLE(MAX98388_R2058_PCM_RX_SRC1,\n\t\t\tMAX98388_PCM_TO_SPK_MONOMIX_CFG_SHIFT,\n\t\t\t3, max98388_monomix_switch_text);\n\nstatic const struct snd_kcontrol_new max98388_dai_controls =\n\tSOC_DAPM_ENUM(\"DAI Sel\", dai_sel_enum);\n\nstatic const struct snd_kcontrol_new max98388_vi_control =\n\tSOC_DAPM_SINGLE(\"Switch\", MAX98388_R205F_PCM_TX_EN, 0, 1, 0);\n\nstatic const struct snd_soc_dapm_widget max98388_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"Amp Enable\", \"HiFi Playback\",\n\t\t\t   MAX98388_R205E_PCM_RX_EN, 0, 0, max98388_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_MUX(\"DAI Sel Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &max98388_dai_controls),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n\tSND_SOC_DAPM_AIF_OUT(\"Voltage Sense\", \"HiFi Capture\", 0,\n\t\t\t     MAX98388_R20A7_IV_DATA_EN, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Current Sense\", \"HiFi Capture\", 0,\n\t\t\t     MAX98388_R20A7_IV_DATA_EN, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Voltage\", NULL,\n\t\t\t MAX98388_R205D_PCM_TX_SRC_EN, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Current\", NULL,\n\t\t\t MAX98388_R205D_PCM_TX_SRC_EN, 1, 0),\n\tSND_SOC_DAPM_SWITCH(\"VI Sense\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &max98388_vi_control),\n\tSND_SOC_DAPM_SIGGEN(\"VMON\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON\"),\n};\n\nstatic DECLARE_TLV_DB_SCALE(max98388_digital_tlv, -6350, 50, 1);\nstatic DECLARE_TLV_DB_SCALE(max98388_amp_gain_tlv, -300, 300, 0);\n\nstatic const char * const max98388_alc_max_atten_text[] = {\n\t\"0dBFS\", \"-1dBFS\", \"-2dBFS\", \"-3dBFS\", \"-4dBFS\", \"-5dBFS\",\n\t\"-6dBFS\", \"-7dBFS\", \"-8dBFS\", \"-9dBFS\", \"-10dBFS\", \"-11dBFS\",\n\t\"-12dBFS\", \"-13dBFS\", \"-14dBFS\", \"-15dBFS\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_max_atten_enum,\n\t\t\t    MAX98388_R20E2_BP_ALC_ATTEN,\n\t\t\t    MAX98388_ALC_MAX_ATTEN_SHIFT,\n\t\t\t    max98388_alc_max_atten_text);\n\nstatic const char * const max98388_thermal_warn_text[] = {\n\t\"95C\", \"105C\", \"115C\", \"125C\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_thermal_warning_thresh_enum,\n\t\t\t    MAX98388_R2020_THERM_WARN_THRESH,\n\t\t\t    MAX98388_THERM_WARN_THRESH_SHIFT,\n\t\t\t    max98388_thermal_warn_text);\n\nstatic const char * const max98388_thermal_shutdown_text[] = {\n\t\"135C\", \"145C\", \"155C\", \"165C\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_thermal_shutdown_thresh_enum,\n\t\t\t    MAX98388_R2020_THERM_WARN_THRESH,\n\t\t\t    MAX98388_THERM_SHDN_THRESH_SHIFT,\n\t\t\t    max98388_thermal_shutdown_text);\n\nstatic const char * const max98388_alc_thresh_single_text[] = {\n\t\"3.625V\", \"3.550V\", \"3.475V\", \"3.400V\", \"3.325V\", \"3.250V\",\n\t\"3.175V\", \"3.100V\", \"3.025V\", \"2.950V\", \"2.875V\", \"2.800V\",\n\t\"2.725V\", \"2.650V\", \"2.575V\", \"2.500V\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_thresh_single_enum,\n\t\t\t    MAX98388_R20E0_BP_ALC_THRESH,\n\t\t\t    MAX98388_ALC_THRESH_SHIFT,\n\t\t\t    max98388_alc_thresh_single_text);\n\nstatic const char * const max98388_alc_attack_rate_text[] = {\n\t\"0\", \"10us\", \"20us\", \"40us\", \"80us\", \"160us\",\n\t\"320us\", \"640us\", \"1.28ms\", \"2.56ms\", \"5.12ms\", \"10.24ms\",\n\t\"20.48ms\", \"40.96ms\", \"81.92ms\", \"163.84ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_attack_rate_enum,\n\t\t\t    MAX98388_R20E1_BP_ALC_RATES,\n\t\t\t    MAX98388_ALC_ATTACK_RATE_SHIFT,\n\t\t\t    max98388_alc_attack_rate_text);\n\nstatic const char * const max98388_alc_release_rate_text[] = {\n\t\"20us\", \"40us\", \"80us\", \"160us\", \"320us\", \"640us\",\n\t\"1.28ms\", \"2.56ms\", \"5.12ms\", \"10.24ms\", \"20.48ms\", \"40.96ms\",\n\t\"81.92ms\", \"163.84ms\", \"327.68ms\", \"655.36ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_release_rate_enum,\n\t\t\t    MAX98388_R20E1_BP_ALC_RATES,\n\t\t\t    MAX98388_ALC_RELEASE_RATE_SHIFT,\n\t\t\t    max98388_alc_release_rate_text);\n\nstatic const char * const max98388_alc_debounce_text[] = {\n\t\"0.01ms\", \"0.1ms\", \"1ms\", \"10ms\", \"100ms\", \"250ms\", \"500ms\", \"hold\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_debouce_enum,\n\t\t\t    MAX98388_R20E3_BP_ALC_REL,\n\t\t\t    MAX98388_ALC_DEBOUNCE_TIME_SHIFT,\n\t\t\t    max98388_alc_debounce_text);\n\nstatic const char * const max98388_alc_mute_delay_text[] = {\n\t\"0.01ms\", \"0.05ms\", \"0.1ms\", \"0.5ms\", \"1ms\", \"5ms\", \"25ms\", \"250ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_alc_mute_delay_enum,\n\t\t\t    MAX98388_R20E4_BP_ALC_MUTE,\n\t\t\t    MAX98388_ALC_MUTE_DELAY_SHIFT,\n\t\t\t    max98388_alc_mute_delay_text);\n\nstatic const char * const max98388_spkmon_duration_text[] = {\n\t\"10ms\", \"25ms\", \"50ms\", \"75ms\", \"100ms\", \"200ms\", \"300ms\", \"400ms\",\n\t\"500ms\", \"600ms\", \"700ms\", \"800ms\", \"900ms\", \"1000ms\", \"1100ms\", \"1200ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_spkmon_duration_enum,\n\t\t\t    MAX98388_R2033_SPK_MON_DURATION,\n\t\t\t    MAX98388_SPKMON_DURATION_SHIFT,\n\t\t\t    max98388_spkmon_duration_text);\n\nstatic const char * const max98388_spkmon_thresh_text[] = {\n\t\"0.03V\", \"0.06V\", \"0.09V\", \"0.12V\", \"0.15V\", \"0.18V\", \"0.20V\", \"0.23V\",\n\t\"0.26V\", \"0.29V\", \"0.32V\", \"0.35V\", \"0.38V\", \"0.41V\", \"0.44V\", \"0.47V\",\n\t\"0.50V\", \"0.53V\", \"0.56V\", \"0.58V\", \"0.61V\", \"0.64V\", \"0.67V\", \"0.70V\",\n\t\"0.73V\", \"0.76V\", \"0.79V\", \"0.82V\", \"0.85V\", \"0.88V\", \"0.91V\", \"0.94V\",\n\t\"0.96V\", \"0.99V\", \"1.02V\", \"1.05V\", \"1.08V\", \"1.11V\", \"1.14V\", \"1.17V\",\n\t\"1.20V\", \"1.23V\", \"1.26V\", \"1.29V\", \"1.32V\", \"1.35V\", \"1.37V\", \"1.40V\",\n\t\"1.43V\", \"1.46V\", \"1.49V\", \"1.52V\", \"1.55V\", \"1.58V\", \"1.61V\", \"1.64V\",\n\t\"1.67V\", \"1.70V\", \"1.73V\", \"1.75V\", \"1.78V\", \"1.81V\", \"1.84V\", \"1.87V\",\n\t\"1.90V\", \"1.93V\", \"1.96V\", \"1.99V\", \"2.02V\", \"2.05V\", \"2.08V\", \"2.11V\",\n\t\"2.13V\", \"2.16V\", \"2.19V\", \"2.22V\", \"2.25V\", \"2.28V\", \"2.31V\", \"2.34V\",\n\t\"2.37V\", \"2.40V\", \"2.43V\", \"2.46V\", \"2.49V\", \"2.51V\", \"2.54V\", \"2.57V\",\n\t\"2.60V\", \"2.63V\", \"2.66V\", \"2.69V\", \"2.72V\", \"2.75V\", \"2.78V\", \"2.81V\",\n\t\"2.84V\", \"2.87V\", \"2.89V\", \"2.92V\", \"2.95V\", \"2.98V\", \"3.01V\", \"3.04V\",\n\t\"3.07V\", \"3.10V\", \"3.13V\", \"3.16V\", \"3.19V\", \"3.22V\", \"3.25V\", \"3.27V\",\n\t\"3.30V\", \"3.33V\", \"3.36V\", \"3.39V\", \"3.42V\", \"3.45V\", \"3.48V\", \"3.51V\",\n\t\"3.54V\", \"3.57V\", \"3.60V\", \"3.63V\", \"3.66V\", \"3.68V\", \"3.71V\", \"3.74V\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_spkmon_thresh_enum,\n\t\t\t    MAX98388_R2031_SPK_MON_THRESH,\n\t\t\t    MAX98388_SPKMON_THRESH_SHIFT,\n\t\t\t    max98388_spkmon_thresh_text);\n\nstatic const char * const max98388_spkmon_load_text[] = {\n\t\"2.00ohm\", \"2.25ohm\", \"2.50ohm\", \"2.75ohm\", \"3.00ohm\", \"3.25ohm\",\n\t\"3.50ohm\", \"3.75ohm\", \"4.00ohm\", \"4.25ohm\", \"4.50ohm\", \"4.75ohm\",\n\t\"5.00ohm\", \"5.25ohm\", \"5.50ohm\", \"5.75ohm\", \"6.00ohm\", \"6.25ohm\",\n\t\"6.50ohm\", \"6.75ohm\", \"7.00ohm\", \"7.25ohm\", \"7.50ohm\", \"7.75ohm\",\n\t\"8.00ohm\", \"8.25ohm\", \"8.50ohm\", \"8.75ohm\", \"9.00ohm\", \"9.25ohm\",\n\t\"9.50ohm\", \"9.75ohm\", \"10.00ohm\", \"10.25ohm\", \"10.50ohm\", \"10.75ohm\",\n\t\"11.00ohm\", \"11.25ohm\", \"11.50ohm\", \"11.75ohm\",\t\"12.00ohm\", \"12.25ohm\",\n\t\"12.50ohm\", \"12.75ohm\", \"13.00ohm\", \"13.25ohm\", \"13.50ohm\", \"13.75ohm\",\n\t\"14.00ohm\", \"14.25ohm\", \"14.50ohm\", \"14.75ohm\", \"15.00ohm\", \"15.25ohm\",\n\t\"15.50ohm\", \"15.75ohm\", \"16.00ohm\", \"16.25ohm\", \"16.50ohm\", \"16.75ohm\",\n\t\"17.00ohm\", \"17.25ohm\", \"17.50ohm\", \"17.75ohm\", \"18.00ohm\", \"18.25ohm\",\n\t\"18.50ohm\", \"18.75ohm\", \"19.00ohm\", \"19.25ohm\", \"19.50ohm\", \"19.75ohm\",\n\t\"20.00ohm\", \"20.25ohm\", \"20.50ohm\", \"20.75ohm\", \"21.00ohm\", \"21.25ohm\",\n\t\"21.50ohm\", \"21.75ohm\",\t\"22.00ohm\", \"22.25ohm\", \"22.50ohm\", \"22.75ohm\",\n\t\"23.00ohm\", \"23.25ohm\", \"23.50ohm\", \"23.75ohm\",\t\"24.00ohm\", \"24.25ohm\",\n\t\"24.50ohm\", \"24.75ohm\", \"25.00ohm\", \"25.25ohm\", \"25.50ohm\", \"25.75ohm\",\n\t\"26.00ohm\", \"26.25ohm\", \"26.50ohm\", \"26.75ohm\", \"27.00ohm\", \"27.25ohm\",\n\t\"27.50ohm\", \"27.75ohm\",\t\"28.00ohm\", \"28.25ohm\", \"28.50ohm\", \"28.75ohm\",\n\t\"29.00ohm\", \"29.25ohm\", \"29.50ohm\", \"29.75ohm\",\t\"30.00ohm\", \"30.25ohm\",\n\t\"30.50ohm\", \"30.75ohm\", \"31.00ohm\", \"31.25ohm\", \"31.50ohm\", \"31.75ohm\",\n\t\"32.00ohm\", \"32.25ohm\", \"32.50ohm\", \"32.75ohm\", \"33.00ohm\", \"33.25ohm\",\n\t\"33.50ohm\", \"33.75ohm\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_spkmon_load_enum,\n\t\t\t    MAX98388_R2032_SPK_MON_LD_SEL,\n\t\t\t    MAX98388_SPKMON_LOAD_SHIFT,\n\t\t\t    max98388_spkmon_load_text);\n\nstatic const char * const max98388_edge_rate_text[] = {\n\t\"Normal\", \"Reduced\", \"Maximum\", \"Increased\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_edge_rate_falling_enum,\n\t\t\t    MAX98388_R2094_SPK_AMP_ER_CTRL,\n\t\t\t    MAX98388_EDGE_RATE_FALL_SHIFT,\n\t\t\t    max98388_edge_rate_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_edge_rate_rising_enum,\n\t\t\t    MAX98388_R2094_SPK_AMP_ER_CTRL,\n\t\t\t    MAX98388_EDGE_RATE_RISE_SHIFT,\n\t\t\t    max98388_edge_rate_text);\n\nstatic const char * const max98388_ssm_mod_text[] = {\n\t\"1.5%\", \"3.0%\", \"4.5%\", \"6.0%\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98388_ssm_mod_enum,\n\t\t\t    MAX98388_R2093_SPK_AMP_SSM_CFG,\n\t\t\t    MAX98388_SPK_AMP_SSM_MOD_SHIFT,\n\t\t\t    max98388_ssm_mod_text);\n\nstatic const struct snd_kcontrol_new max98388_snd_controls[] = {\n\tSOC_SINGLE(\"Ramp Up Switch\", MAX98388_R2091_SPK_CH_CFG,\n\t\t   MAX98388_SPK_CFG_VOL_RMPUP_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Ramp Down Switch\", MAX98388_R2091_SPK_CH_CFG,\n\t\t   MAX98388_SPK_CFG_VOL_RMPDN_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"OP Mode Switch\", MAX98388_R2092_SPK_AMP_OUT_CFG,\n\t\t   MAX98388_SPK_AMP_OUT_MODE_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"OVC Autorestart Switch\", MAX98388_R210E_AUTO_RESTART,\n\t\t   MAX98388_OVC_AUTORESTART_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"THERM Autorestart Switch\", MAX98388_R210E_AUTO_RESTART,\n\t\t   MAX98388_THERM_AUTORESTART_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"UVLO Autorestart Switch\", MAX98388_R210E_AUTO_RESTART,\n\t\t   MAX98388_PVDD_UVLO_AUTORESTART_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"CMON Autorestart Switch\", MAX98388_R210E_AUTO_RESTART,\n\t\t   MAX98388_CMON_AUTORESTART_SHIFT, 1, 0),\n\tSOC_SINGLE(\"CLK Monitor Switch\", MAX98388_R2037_ERR_MON_CTRL,\n\t\t   MAX98388_CLOCK_MON_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"Pinknoise Gen Switch\", MAX98388_R209E_SPK_CH_PINK_NOISE_EN,\n\t\t   MAX98388_PINK_NOISE_GEN_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"Dither Switch\", MAX98388_R2091_SPK_CH_CFG,\n\t\t   MAX98388_SPK_CFG_DITH_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"VI Dither Switch\", MAX98388_R20A0_IV_DATA_DSP_CTRL,\n\t\t   MAX98388_AMP_DSP_CTRL_DITH_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE(\"DC Blocker Switch\", MAX98388_R2091_SPK_CH_CFG,\n\t\t   MAX98388_SPK_CFG_DCBLK_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Voltage DC Blocker Switch\", MAX98388_R20A0_IV_DATA_DSP_CTRL,\n\t\t   MAX98388_AMP_DSP_CTRL_VOL_DCBLK_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Current DC Blocker Switch\", MAX98388_R20A0_IV_DATA_DSP_CTRL,\n\t\t   MAX98388_AMP_DSP_CTRL_CUR_DCBLK_SHIFT, 1, 0),\n\t \n\tSOC_SINGLE_TLV(\"Digital Volume\", MAX98388_R2090_SPK_CH_VOL_CTRL,\n\t\t       0, 0x7F, 1, max98388_digital_tlv),\n\t \n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98388_R2092_SPK_AMP_OUT_CFG,\n\t\t       0, 5, 0, max98388_amp_gain_tlv),\n\tSOC_ENUM(\"Thermal Warn Thresh\", max98388_thermal_warning_thresh_enum),\n\tSOC_ENUM(\"Thermal SHDN Thresh\", max98388_thermal_shutdown_thresh_enum),\n\t \n\tSOC_SINGLE(\"ALC Switch\", MAX98388_R20EF_BP_ALC_EN, 0, 1, 0),\n\tSOC_ENUM(\"ALC Thresh\", max98388_alc_thresh_single_enum),\n\tSOC_ENUM(\"ALC Attack Rate\", max98388_alc_attack_rate_enum),\n\tSOC_ENUM(\"ALC Release Rate\", max98388_alc_release_rate_enum),\n\tSOC_ENUM(\"ALC Max Atten\", max98388_alc_max_atten_enum),\n\tSOC_ENUM(\"ALC Debounce Time\", max98388_alc_debouce_enum),\n\tSOC_SINGLE(\"ALC Unmute Ramp Switch\", MAX98388_R20E4_BP_ALC_MUTE,\n\t\t   MAX98388_ALC_UNMUTE_RAMP_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Mute Ramp Switch\", MAX98388_R20E4_BP_ALC_MUTE,\n\t\t   MAX98388_ALC_MUTE_RAMP_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Mute Switch\", MAX98388_R20E4_BP_ALC_MUTE,\n\t\t   MAX98388_ALC_MUTE_EN_SHIFT, 1, 0),\n\tSOC_ENUM(\"ALC Mute Delay\", max98388_alc_mute_delay_enum),\n\t \n\tSOC_SINGLE(\"SPKMON Switch\", MAX98388_R2037_ERR_MON_CTRL,\n\t\t   MAX98388_SPK_MON_SHIFT, 1, 0),\n\tSOC_ENUM(\"SPKMON Thresh\", max98388_spkmon_thresh_enum),\n\tSOC_ENUM(\"SPKMON Load\", max98388_spkmon_load_enum),\n\tSOC_ENUM(\"SPKMON Duration\", max98388_spkmon_duration_enum),\n\t \n\tSOC_ENUM(\"Fall Slew Rate\", max98388_edge_rate_falling_enum),\n\tSOC_ENUM(\"Rise Slew Rate\", max98388_edge_rate_rising_enum),\n\tSOC_SINGLE(\"AMP SSM Switch\", MAX98388_R2093_SPK_AMP_SSM_CFG,\n\t\t   MAX98388_SPK_AMP_SSM_EN_SHIFT, 1, 0),\n\tSOC_ENUM(\"AMP SSM Mod\", max98388_ssm_mod_enum),\n};\n\nstatic const struct snd_soc_dapm_route max98388_audio_map[] = {\n\t \n\t{\"DAI Sel Mux\", \"Left\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"Right\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"LeftRight\", \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"DAI Sel Mux\"},\n\t \n\t{ \"ADC Voltage\", NULL, \"VMON\"},\n\t{ \"ADC Current\", NULL, \"IMON\"},\n\t{ \"VI Sense\", \"Switch\", \"ADC Voltage\"},\n\t{ \"VI Sense\", \"Switch\", \"ADC Current\"},\n\t{ \"Voltage Sense\", NULL, \"VI Sense\"},\n\t{ \"Current Sense\", NULL, \"VI Sense\"},\n};\n\nstatic void max98388_reset(struct max98388_priv *max98388, struct device *dev)\n{\n\tint ret, reg, count;\n\n\t \n\tret = regmap_update_bits(max98388->regmap,\n\t\t\t\t MAX98388_R2000_SW_RESET,\n\t\t\t\t MAX98388_SOFT_RESET,\n\t\t\t\t MAX98388_SOFT_RESET);\n\tif (ret)\n\t\tdev_err(dev, \"Reset command failed. (ret:%d)\\n\", ret);\n\n\tcount = 0;\n\twhile (count < 3) {\n\t\tusleep_range(10000, 11000);\n\t\t \n\t\tret = regmap_read(max98388->regmap,\n\t\t\t\t  MAX98388_R22FF_REV_ID, &reg);\n\t\tif (!ret) {\n\t\t\tdev_info(dev, \"Reset completed (retry:%d)\\n\", count);\n\t\t\treturn;\n\t\t}\n\t\tcount++;\n\t}\n\tdev_err(dev, \"Reset failed. (ret:%d)\\n\", ret);\n}\n\nstatic int max98388_probe(struct snd_soc_component *component)\n{\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\n\t \n\tmax98388_reset(max98388, component->dev);\n\n\t \n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R2059_PCM_RX_SRC2,\n\t\t     0x10);\n\n\t \n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R2091_SPK_CH_CFG,\n\t\t     0x1);\n\t \n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R20A0_IV_DATA_DSP_CTRL,\n\t\t     0x3);\n\t \n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R2044_PCM_TX_CTRL1,\n\t\t     max98388->v_slot);\n\n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R2045_PCM_TX_CTRL2,\n\t\t     max98388->i_slot);\n\t \n\tregmap_write(max98388->regmap,\n\t\t     MAX98388_R210E_AUTO_RESTART, 0xF);\n\t \n\tif (max98388->interleave_mode)\n\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t   MAX98388_R2040_PCM_MODE_CFG,\n\t\t\t\t   MAX98388_PCM_TX_CH_INTERLEAVE_MASK,\n\t\t\t\t   MAX98388_PCM_TX_CH_INTERLEAVE_MASK);\n\n\t \n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R209F_SPK_CH_AMP_EN,\n\t\t\t   MAX98388_SPK_EN_MASK, 1);\n\n\treturn 0;\n}\n\nstatic int max98388_dai_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\tunsigned int format = 0;\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98388_PCM_MODE_CFG_PCM_BCLKEDGE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R2041_PCM_CLK_SETUP,\n\t\t\t   MAX98388_PCM_MODE_CFG_PCM_BCLKEDGE,\n\t\t\t   invert);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = MAX98388_PCM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = MAX98388_PCM_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = MAX98388_PCM_FORMAT_TDM_MODE1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = MAX98388_PCM_FORMAT_TDM_MODE0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R2040_PCM_MODE_CFG,\n\t\t\t   MAX98388_PCM_MODE_CFG_FORMAT_MASK,\n\t\t\t   format << MAX98388_PCM_MODE_CFG_FORMAT_SHIFT);\n\n\treturn 0;\n}\n\n \nstatic const int bclk_sel_table[] = {\n\t32, 48, 64, 96, 128, 192, 256, 384, 512, 320,\n};\n\nstatic int max98388_get_bclk_sel(int bclk)\n{\n\tint i;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bclk_sel_table); i++) {\n\t\tif (bclk_sel_table[i] == bclk)\n\t\t\treturn i + 2;\n\t}\n\treturn 0;\n}\n\nstatic int max98388_set_clock(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\t \n\tint blr_clk_ratio = params_channels(params) * max98388->ch_size;\n\tint value;\n\n\tif (!max98388->tdm_mode) {\n\t\t \n\t\tvalue = max98388_get_bclk_sel(blr_clk_ratio);\n\t\tif (!value) {\n\t\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t   MAX98388_R2041_PCM_CLK_SETUP,\n\t\t\t\t   MAX98388_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t\t   value);\n\t}\n\treturn 0;\n}\n\nstatic int max98388_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\tunsigned int sampling_rate = 0;\n\tunsigned int chan_sz = 0;\n\tint ret, reg;\n\tint status = 0;\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\tgoto err;\n\t}\n\n\tmax98388->ch_size = snd_pcm_format_width(params_format(params));\n\n\tret = regmap_read(max98388->regmap,\n\t\t\t  MAX98388_R2040_PCM_MODE_CFG, &reg);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (chan_sz != (reg & MAX98388_PCM_MODE_CFG_CHANSZ_MASK))\t{\n\t\tret = regmap_read(max98388->regmap,\n\t\t\t\t  MAX98388_R210F_GLOBAL_EN, &status);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (status) {\n\t\t\tregmap_write(max98388->regmap,\n\t\t\t\t     MAX98388_R210F_GLOBAL_EN, 0);\n\t\t\tusleep_range(30000, 31000);\n\t\t}\n\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t   MAX98388_R2040_PCM_MODE_CFG,\n\t\t\t\t   MAX98388_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\t}\n\tdev_dbg(component->dev, \"format supported %d\",\n\t\tparams_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98388_PCM_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98388_PCM_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98388_PCM_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98388_PCM_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98388_PCM_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98388_PCM_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98388_PCM_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98388_PCM_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98388_PCM_SR_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tsampling_rate = MAX98388_PCM_SR_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = MAX98388_PCM_SR_96000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"rate %d not supported\\n\",\n\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\n\t \n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R2042_PCM_SR_SETUP,\n\t\t\t   MAX98388_PCM_SR_MASK,\n\t\t\t   sampling_rate);\n\n\t \n\tif (max98388->interleave_mode &&\n\t    sampling_rate > MAX98388_PCM_SR_16000)\n\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t   MAX98388_R2042_PCM_SR_SETUP,\n\t\t\t\t   MAX98388_PCM_SR_IV_MASK,\n\t\t\t\t   (sampling_rate - 3) << MAX98388_PCM_SR_IV_SHIFT);\n\telse\n\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t   MAX98388_R2042_PCM_SR_SETUP,\n\t\t\t\t   MAX98388_PCM_SR_IV_MASK,\n\t\t\t\t   sampling_rate << MAX98388_PCM_SR_IV_SHIFT);\n\n\tret = max98388_set_clock(component, params);\n\n\tif (status) {\n\t\tregmap_write(max98388->regmap,\n\t\t\t     MAX98388_R210F_GLOBAL_EN, 1);\n\t\tusleep_range(30000, 31000);\n\t}\n\n\treturn ret;\n\nerr:\n\treturn -EINVAL;\n}\n\n#define MAX_NUM_SLOTS 16\n#define MAX_NUM_CH 2\n\nstatic int max98388_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98388_priv *max98388 = snd_soc_component_get_drvdata(component);\n\tint bsel = 0;\n\tunsigned int chan_sz = 0;\n\tunsigned int mask;\n\tint cnt, slot_found;\n\tint addr, bits;\n\n\tif (!tx_mask && !rx_mask && !slots && !slot_width)\n\t\tmax98388->tdm_mode = false;\n\telse\n\t\tmax98388->tdm_mode = true;\n\n\t \n\tbsel = max98388_get_bclk_sel(slots * slot_width);\n\tif (bsel == 0) {\n\t\tdev_err(component->dev, \"BCLK %d not supported\\n\",\n\t\t\tslots * slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R2041_PCM_CLK_SETUP,\n\t\t\t   MAX98388_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t   bsel);\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98388_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98388->regmap,\n\t\t\t   MAX98388_R2040_PCM_MODE_CFG,\n\t\t\t   MAX98388_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\t \n\tslot_found = 0;\n\tmask = rx_mask;\n\tfor (cnt = 0 ; cnt < MAX_NUM_SLOTS ; cnt++, mask >>= 1) {\n\t\tif (mask & 0x1) {\n\t\t\tif (slot_found == 0)\n\t\t\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t\t\t   MAX98388_R2059_PCM_RX_SRC2,\n\t\t\t\t\t\t   MAX98388_RX_SRC_CH0_SHIFT,\n\t\t\t\t\t\t   cnt);\n\t\t\telse\n\t\t\t\tregmap_update_bits(max98388->regmap,\n\t\t\t\t\t\t   MAX98388_R2059_PCM_RX_SRC2,\n\t\t\t\t\t\t   MAX98388_RX_SRC_CH1_SHIFT,\n\t\t\t\t\t\t   cnt);\n\t\t\tslot_found++;\n\t\t\tif (slot_found >= MAX_NUM_CH)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tslot_found = 0;\n\tmask = tx_mask;\n\tfor (cnt = 0 ; cnt < MAX_NUM_SLOTS ; cnt++, mask >>= 1) {\n\t\tif (mask & 0x1) {\n\t\t\taddr = MAX98388_R2044_PCM_TX_CTRL1 + (cnt / 8);\n\t\t\tbits = cnt % 8;\n\t\t\tregmap_update_bits(max98388->regmap, addr, bits, bits);\n\t\t\tif (slot_found >= MAX_NUM_CH)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define MAX98388_RATES SNDRV_PCM_RATE_8000_96000\n\n#define MAX98388_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops max98388_dai_ops = {\n\t.set_fmt = max98388_dai_set_fmt,\n\t.hw_params = max98388_dai_hw_params,\n\t.set_tdm_slot = max98388_dai_tdm_slot,\n};\n\nstatic bool max98388_readable_register(struct device *dev,\n\t\t\t\t       unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98388_R2001_INT_RAW1 ... MAX98388_R2002_INT_RAW2:\n\tcase MAX98388_R2004_INT_STATE1... MAX98388_R2005_INT_STATE2:\n\tcase MAX98388_R2020_THERM_WARN_THRESH:\n\tcase MAX98388_R2031_SPK_MON_THRESH\n\t\t... MAX98388_R2033_SPK_MON_DURATION:\n\tcase MAX98388_R2037_ERR_MON_CTRL:\n\tcase MAX98388_R2040_PCM_MODE_CFG\n\t\t... MAX98388_R2042_PCM_SR_SETUP:\n\tcase MAX98388_R2044_PCM_TX_CTRL1\n\t\t... MAX98388_R2045_PCM_TX_CTRL2:\n\tcase MAX98388_R2050_PCM_TX_HIZ_CTRL1\n\t\t... MAX98388_R2059_PCM_RX_SRC2:\n\tcase MAX98388_R205C_PCM_TX_DRIVE_STRENGTH\n\t\t... MAX98388_R205F_PCM_TX_EN:\n\tcase MAX98388_R2090_SPK_CH_VOL_CTRL\n\t\t... MAX98388_R2094_SPK_AMP_ER_CTRL:\n\tcase MAX98388_R209E_SPK_CH_PINK_NOISE_EN\n\t\t... MAX98388_R209F_SPK_CH_AMP_EN:\n\tcase MAX98388_R20A0_IV_DATA_DSP_CTRL:\n\tcase MAX98388_R20A7_IV_DATA_EN:\n\tcase MAX98388_R20E0_BP_ALC_THRESH ... MAX98388_R20E4_BP_ALC_MUTE:\n\tcase MAX98388_R20EE_BP_INF_HOLD_REL ... MAX98388_R20EF_BP_ALC_EN:\n\tcase MAX98388_R210E_AUTO_RESTART:\n\tcase MAX98388_R210F_GLOBAL_EN:\n\tcase MAX98388_R22FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98388_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98388_R2001_INT_RAW1 ... MAX98388_R2005_INT_STATE2:\n\tcase MAX98388_R210F_GLOBAL_EN:\n\tcase MAX98388_R22FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct snd_soc_dai_driver max98388_dai[] = {\n\t{\n\t\t.name = \"max98388-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98388_RATES,\n\t\t\t.formats = MAX98388_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98388_RATES,\n\t\t\t.formats = MAX98388_FORMATS,\n\t\t},\n\t\t.ops = &max98388_dai_ops,\n\t}\n};\n\nstatic int max98388_suspend(struct device *dev)\n{\n\tstruct max98388_priv *max98388 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98388->regmap, true);\n\tregcache_mark_dirty(max98388->regmap);\n\n\treturn 0;\n}\n\nstatic int max98388_resume(struct device *dev)\n{\n\tstruct max98388_priv *max98388 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98388->regmap, false);\n\tmax98388_reset(max98388, dev);\n\tregcache_sync(max98388->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops max98388_pm = {\n\tSYSTEM_SLEEP_PM_OPS(max98388_suspend, max98388_resume)\n};\n\nstatic const struct regmap_config max98388_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = MAX98388_R22FF_REV_ID,\n\t.reg_defaults  = max98388_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98388_reg),\n\t.readable_reg = max98388_readable_register,\n\t.volatile_reg = max98388_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_max98388 = {\n\t.probe\t\t\t= max98388_probe,\n\t.controls\t\t= max98388_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98388_snd_controls),\n\t.dapm_widgets\t\t= max98388_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98388_dapm_widgets),\n\t.dapm_routes\t\t= max98388_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98388_audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void max98388_read_deveice_property(struct device *dev,\n\t\t\t\t\t   struct max98388_priv *max98388)\n{\n\tint value;\n\n\tif (!device_property_read_u32(dev, \"adi,vmon-slot-no\", &value))\n\t\tmax98388->v_slot = value & 0xF;\n\telse\n\t\tmax98388->v_slot = 0;\n\n\tif (!device_property_read_u32(dev, \"adi,imon-slot-no\", &value))\n\t\tmax98388->i_slot = value & 0xF;\n\telse\n\t\tmax98388->i_slot = 1;\n\n\tif (device_property_read_bool(dev, \"adi,interleave-mode\"))\n\t\tmax98388->interleave_mode = true;\n\telse\n\t\tmax98388->interleave_mode = false;\n}\n\nstatic int max98388_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret = 0;\n\tint reg = 0;\n\n\tstruct max98388_priv *max98388 = NULL;\n\n\tmax98388 = devm_kzalloc(&i2c->dev, sizeof(*max98388), GFP_KERNEL);\n\tif (!max98388)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max98388);\n\n\t \n\tmax98388->regmap = devm_regmap_init_i2c(i2c, &max98388_regmap);\n\tif (IS_ERR(max98388->regmap))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(max98388->regmap),\n\t\t\t\t     \"Failed to allocate register map.\\n\");\n\n\t \n\tmax98388_read_deveice_property(&i2c->dev, max98388);\n\n\t \n\tmax98388->reset_gpio = devm_gpiod_get_optional(&i2c->dev,\n\t\t\t\t\t\t       \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(max98388->reset_gpio))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(max98388->reset_gpio),\n\t\t\t\t     \"Unable to request GPIO\\n\");\n\n\tif (max98388->reset_gpio) {\n\t\tusleep_range(5000, 6000);\n\t\tgpiod_set_value_cansleep(max98388->reset_gpio, 0);\n\t\t \n\t\tusleep_range(5000, 6000);\n\t}\n\n\t \n\tret = regmap_read(max98388->regmap,\n\t\t\t  MAX98388_R22FF_REV_ID, &reg);\n\tif (ret < 0)\n\t\treturn dev_err_probe(&i2c->dev, ret,\n\t\t\t\t     \"Failed to read the revision ID\\n\");\n\n\tdev_info(&i2c->dev, \"MAX98388 revisionID: 0x%02X\\n\", reg);\n\n\t \n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t      &soc_codec_dev_max98388,\n\t\t\t\t\t      max98388_dai,\n\t\t\t\t\t      ARRAY_SIZE(max98388_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Failed to register codec: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98388_i2c_id[] = {\n\t{ \"max98388\", 0},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, max98388_i2c_id);\n\nstatic const struct of_device_id max98388_of_match[] = {\n\t{ .compatible = \"adi,max98388\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98388_of_match);\n\nstatic const struct acpi_device_id max98388_acpi_match[] = {\n\t{ \"ADS8388\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, max98388_acpi_match);\n\nstatic struct i2c_driver max98388_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98388\",\n\t\t.of_match_table = max98388_of_match,\n\t\t.acpi_match_table = max98388_acpi_match,\n\t\t.pm = pm_sleep_ptr(&max98388_pm),\n\t},\n\t.probe = max98388_i2c_probe,\n\t.id_table = max98388_i2c_id,\n};\n\nmodule_i2c_driver(max98388_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98388 driver\");\nMODULE_AUTHOR(\"Ryan Lee <ryans.lee@analog.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}