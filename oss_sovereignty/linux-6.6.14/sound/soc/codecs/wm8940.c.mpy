{
  "module_name": "wm8940.c",
  "hash_id": "152f0c17fb1e2623f59a8b5f7fecb53b429c7e365c99e63baa3df4ce63a5f0df",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8940.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8940.h\"\n\nstruct wm8940_priv {\n\tunsigned int mclk;\n\tunsigned int fs;\n\n\tstruct regmap *regmap;\n};\n\nstatic bool wm8940_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8940_SOFTRESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8940_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8940_SOFTRESET:\n\tcase WM8940_POWER1:\n\tcase WM8940_POWER2:\n\tcase WM8940_POWER3:\n\tcase WM8940_IFACE:\n\tcase WM8940_COMPANDINGCTL:\n\tcase WM8940_CLOCK:\n\tcase WM8940_ADDCNTRL:\n\tcase WM8940_GPIO:\n\tcase WM8940_CTLINT:\n\tcase WM8940_DAC:\n\tcase WM8940_DACVOL:\n\tcase WM8940_ADC:\n\tcase WM8940_ADCVOL:\n\tcase WM8940_NOTCH1:\n\tcase WM8940_NOTCH2:\n\tcase WM8940_NOTCH3:\n\tcase WM8940_NOTCH4:\n\tcase WM8940_NOTCH5:\n\tcase WM8940_NOTCH6:\n\tcase WM8940_NOTCH7:\n\tcase WM8940_NOTCH8:\n\tcase WM8940_DACLIM1:\n\tcase WM8940_DACLIM2:\n\tcase WM8940_ALC1:\n\tcase WM8940_ALC2:\n\tcase WM8940_ALC3:\n\tcase WM8940_NOISEGATE:\n\tcase WM8940_PLLN:\n\tcase WM8940_PLLK1:\n\tcase WM8940_PLLK2:\n\tcase WM8940_PLLK3:\n\tcase WM8940_ALC4:\n\tcase WM8940_INPUTCTL:\n\tcase WM8940_PGAGAIN:\n\tcase WM8940_ADCBOOST:\n\tcase WM8940_OUTPUTCTL:\n\tcase WM8940_SPKMIX:\n\tcase WM8940_SPKVOL:\n\tcase WM8940_MONOMIX:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default wm8940_reg_defaults[] = {\n\t{  0x1, 0x0000 },  \n\t{  0x2, 0x0000 },  \n\t{  0x3, 0x0000 },  \n\t{  0x4, 0x0010 },  \n\t{  0x5, 0x0000 },  \n\t{  0x6, 0x0140 },  \n\t{  0x7, 0x0000 },  \n\t{  0x8, 0x0000 },  \n\t{  0x9, 0x0002 },  \n\t{  0xa, 0x0000 },  \n\t{  0xb, 0x00FF },  \n\n\t{  0xe, 0x0100 },  \n\t{  0xf, 0x00FF },  \n\t{ 0x10, 0x0000 },  \n\t{ 0x11, 0x0000 },  \n\t{ 0x12, 0x0000 },  \n\t{ 0x13, 0x0000 },  \n\t{ 0x14, 0x0000 },  \n\t{ 0x15, 0x0000 },  \n\t{ 0x16, 0x0000 },  \n\t{ 0x17, 0x0000 },  \n\t{ 0x18, 0x0032 },  \n\t{ 0x19, 0x0000 },  \n\n\t{ 0x20, 0x0038 },  \n\t{ 0x21, 0x000B },  \n\t{ 0x22, 0x0032 },  \n\t{ 0x23, 0x0000 },  \n\t{ 0x24, 0x0041 },  \n\t{ 0x25, 0x000C },  \n\t{ 0x26, 0x0093 },  \n\t{ 0x27, 0x00E9 },  \n\n\t{ 0x2a, 0x0030 },  \n\n\t{ 0x2c, 0x0002 },  \n\t{ 0x2d, 0x0050 },  \n\n\t{ 0x2f, 0x0002 },  \n\n\t{ 0x31, 0x0002 },  \n\t{ 0x32, 0x0000 },  \n\n\t{ 0x36, 0x0079 },  \n\n\t{ 0x38, 0x0000 },  \n};\n\nstatic const char *wm8940_companding[] = { \"Off\", \"NC\", \"u-law\", \"A-law\" };\nstatic SOC_ENUM_SINGLE_DECL(wm8940_adc_companding_enum,\n\t\t\t    WM8940_COMPANDINGCTL, 1, wm8940_companding);\nstatic SOC_ENUM_SINGLE_DECL(wm8940_dac_companding_enum,\n\t\t\t    WM8940_COMPANDINGCTL, 3, wm8940_companding);\n\nstatic const char *wm8940_alc_mode_text[] = {\"ALC\", \"Limiter\"};\nstatic SOC_ENUM_SINGLE_DECL(wm8940_alc_mode_enum,\n\t\t\t    WM8940_ALC3, 8, wm8940_alc_mode_text);\n\nstatic const char *wm8940_mic_bias_level_text[] = {\"0.9\", \"0.65\"};\nstatic SOC_ENUM_SINGLE_DECL(wm8940_mic_bias_level_enum,\n\t\t\t    WM8940_INPUTCTL, 8, wm8940_mic_bias_level_text);\n\nstatic const char *wm8940_filter_mode_text[] = {\"Audio\", \"Application\"};\nstatic SOC_ENUM_SINGLE_DECL(wm8940_filter_mode_enum,\n\t\t\t    WM8940_ADC, 7, wm8940_filter_mode_text);\n\nstatic DECLARE_TLV_DB_SCALE(wm8940_spk_vol_tlv, -5700, 100, 1);\nstatic DECLARE_TLV_DB_SCALE(wm8940_att_tlv, -1000, 1000, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_pga_vol_tlv, -1200, 75, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_alc_min_tlv, -1200, 600, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_alc_max_tlv, 675, 600, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_alc_tar_tlv, -2250, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_lim_boost_tlv, 0, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_lim_thresh_tlv, -600, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(wm8940_adc_tlv, -12750, 50, 1);\nstatic DECLARE_TLV_DB_SCALE(wm8940_capture_boost_vol_tlv, 0, 2000, 0);\n\nstatic const struct snd_kcontrol_new wm8940_snd_controls[] = {\n\tSOC_SINGLE(\"Digital Loopback Switch\", WM8940_COMPANDINGCTL,\n\t\t   6, 1, 0),\n\tSOC_ENUM(\"DAC Companding\", wm8940_dac_companding_enum),\n\tSOC_ENUM(\"ADC Companding\", wm8940_adc_companding_enum),\n\n\tSOC_ENUM(\"ALC Mode\", wm8940_alc_mode_enum),\n\tSOC_SINGLE(\"ALC Switch\", WM8940_ALC1, 8, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Capture Max Gain\", WM8940_ALC1,\n\t\t       3, 7, 1, wm8940_alc_max_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Min Gain\", WM8940_ALC1,\n\t\t       0, 7, 0, wm8940_alc_min_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Target\", WM8940_ALC2,\n\t\t       0, 14, 0, wm8940_alc_tar_tlv),\n\tSOC_SINGLE(\"ALC Capture Hold\", WM8940_ALC2, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Decay\", WM8940_ALC3, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Attach\", WM8940_ALC3, 0, 10, 0),\n\tSOC_SINGLE(\"ALC ZC Switch\", WM8940_ALC4, 1, 1, 0),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Switch\", WM8940_NOISEGATE,\n\t\t   3, 1, 0),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Threshold\", WM8940_NOISEGATE,\n\t\t   0, 7, 0),\n\n\tSOC_SINGLE(\"DAC Playback Limiter Switch\", WM8940_DACLIM1, 8, 1, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Attack\", WM8940_DACLIM1, 0, 9, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Decay\", WM8940_DACLIM1, 4, 11, 0),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Threshold\", WM8940_DACLIM2,\n\t\t       4, 9, 1, wm8940_lim_thresh_tlv),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Boost\", WM8940_DACLIM2,\n\t\t       0, 12, 0, wm8940_lim_boost_tlv),\n\n\tSOC_SINGLE(\"Capture PGA ZC Switch\", WM8940_PGAGAIN, 7, 1, 0),\n\tSOC_SINGLE_TLV(\"Capture PGA Volume\", WM8940_PGAGAIN,\n\t\t       0, 63, 0, wm8940_pga_vol_tlv),\n\tSOC_SINGLE_TLV(\"Digital Playback Volume\", WM8940_DACVOL,\n\t\t       0, 255, 0, wm8940_adc_tlv),\n\tSOC_SINGLE_TLV(\"Digital Capture Volume\", WM8940_ADCVOL,\n\t\t       0, 255, 0, wm8940_adc_tlv),\n\tSOC_ENUM(\"Mic Bias Level\", wm8940_mic_bias_level_enum),\n\tSOC_SINGLE_TLV(\"Capture Boost Volue\", WM8940_ADCBOOST,\n\t\t       8, 1, 0, wm8940_capture_boost_vol_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Playback Volume\", WM8940_SPKVOL,\n\t\t       0, 63, 0, wm8940_spk_vol_tlv),\n\tSOC_SINGLE(\"Speaker Playback Switch\", WM8940_SPKVOL,  6, 1, 1),\n\n\tSOC_SINGLE_TLV(\"Speaker Mixer Line Bypass Volume\", WM8940_SPKVOL,\n\t\t       8, 1, 1, wm8940_att_tlv),\n\tSOC_SINGLE(\"Speaker Playback ZC Switch\", WM8940_SPKVOL, 7, 1, 0),\n\n\tSOC_SINGLE(\"Mono Out Switch\", WM8940_MONOMIX, 6, 1, 1),\n\tSOC_SINGLE_TLV(\"Mono Mixer Line Bypass Volume\", WM8940_MONOMIX,\n\t\t       7, 1, 1, wm8940_att_tlv),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\", WM8940_ADC, 8, 1, 0),\n\tSOC_ENUM(\"High Pass Filter Mode\", wm8940_filter_mode_enum),\n\tSOC_SINGLE(\"High Pass Filter Cut Off\", WM8940_ADC, 4, 7, 0),\n\tSOC_SINGLE(\"ADC Inversion Switch\", WM8940_ADC, 0, 1, 0),\n\tSOC_SINGLE(\"DAC Inversion Switch\", WM8940_DAC, 0, 1, 0),\n\tSOC_SINGLE(\"DAC Auto Mute Switch\", WM8940_DAC, 2, 1, 0),\n\tSOC_SINGLE(\"ZC Timeout Clock Switch\", WM8940_ADDCNTRL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8940_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8940_SPKMIX, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8940_SPKMIX, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8940_SPKMIX, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8940_mono_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8940_MONOMIX, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Playback Switch\", WM8940_MONOMIX, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8940_MONOMIX, 0, 1, 0),\n};\n\nstatic DECLARE_TLV_DB_SCALE(wm8940_boost_vol_tlv, -1500, 300, 1);\nstatic const struct snd_kcontrol_new wm8940_input_boost_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic PGA Switch\", WM8940_PGAGAIN, 6, 1, 1),\n\tSOC_DAPM_SINGLE_TLV(\"Aux Volume\", WM8940_ADCBOOST,\n\t\t\t    0, 7, 0, wm8940_boost_vol_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"Mic Volume\", WM8940_ADCBOOST,\n\t\t\t    4, 7, 0, wm8940_boost_vol_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm8940_micpga_controls[] = {\n\tSOC_DAPM_SINGLE(\"AUX Switch\", WM8940_INPUTCTL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"MICP Switch\", WM8940_INPUTCTL, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"MICN Switch\", WM8940_INPUTCTL, 1, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8940_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Speaker Mixer\", WM8940_POWER3, 2, 0,\n\t\t\t   &wm8940_speaker_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8940_speaker_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mono Mixer\", WM8940_POWER3, 3, 0,\n\t\t\t   &wm8940_mono_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(wm8940_mono_mixer_controls)),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", WM8940_POWER3, 0, 0),\n\n\tSND_SOC_DAPM_PGA(\"SpkN Out\", WM8940_POWER3, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SpkP Out\", WM8940_POWER3, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mono Out\", WM8940_POWER3, 7, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"MONOOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTN\"),\n\n\tSND_SOC_DAPM_PGA(\"Aux Input\", WM8940_POWER1, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", WM8940_POWER2, 0, 0),\n\tSND_SOC_DAPM_MIXER(\"Mic PGA\", WM8940_POWER2, 2, 0,\n\t\t\t   &wm8940_micpga_controls[0],\n\t\t\t   ARRAY_SIZE(wm8940_micpga_controls)),\n\tSND_SOC_DAPM_MIXER(\"Boost Mixer\", WM8940_POWER2, 4, 0,\n\t\t\t   &wm8940_input_boost_controls[0],\n\t\t\t   ARRAY_SIZE(wm8940_input_boost_controls)),\n\tSND_SOC_DAPM_MICBIAS(\"Mic Bias\", WM8940_POWER1, 4, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MICN\"),\n\tSND_SOC_DAPM_INPUT(\"MICP\"),\n\tSND_SOC_DAPM_INPUT(\"AUX\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8940_dapm_routes[] = {\n\t \n\t{\"Mono Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Mono Mixer\", \"Aux Playback Switch\", \"Aux Input\"},\n\t{\"Mono Mixer\", \"Line Bypass Switch\", \"Boost Mixer\"},\n\n\t \n\t{\"Speaker Mixer\", \"PCM Playback Switch\", \"DAC\"},\n\t{\"Speaker Mixer\", \"Aux Playback Switch\", \"Aux Input\"},\n\t{\"Speaker Mixer\", \"Line Bypass Switch\", \"Boost Mixer\"},\n\n\t \n\t{\"Mono Out\", NULL, \"Mono Mixer\"},\n\t{\"MONOOUT\", NULL, \"Mono Out\"},\n\t{\"SpkN Out\", NULL, \"Speaker Mixer\"},\n\t{\"SpkP Out\", NULL, \"Speaker Mixer\"},\n\t{\"SPKOUTN\", NULL, \"SpkN Out\"},\n\t{\"SPKOUTP\", NULL, \"SpkP Out\"},\n\n\t \n\t{\"Mic PGA\", \"MICN Switch\", \"MICN\"},\n\t{\"Mic PGA\", \"MICP Switch\", \"MICP\"},\n\t{\"Mic PGA\", \"AUX Switch\", \"AUX\"},\n\n\t \n\t{\"Boost Mixer\", \"Mic PGA Switch\", \"Mic PGA\"},\n\t{\"Boost Mixer\", \"Mic Volume\",  \"MICP\"},\n\t{\"Boost Mixer\", \"Aux Volume\", \"Aux Input\"},\n\n\t{\"ADC\", NULL, \"Boost Mixer\"},\n};\n\n#define wm8940_reset(c) snd_soc_component_write(c, WM8940_SOFTRESET, 0);\n\nstatic int wm8940_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = snd_soc_component_read(component, WM8940_IFACE) & 0xFE67;\n\tu16 clk = snd_soc_component_read(component, WM8940_CLOCK) & 0x1fe;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tclk |= 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_write(component, WM8940_CLOCK, clk);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= (2 << 3);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= (1 << 3);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= (3 << 3);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= (3 << 3) | (1 << 7);\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= (1 << 7);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= (1 << 8);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= (1 << 8) | (1 << 7);\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8940_IFACE, iface);\n\n\treturn 0;\n}\n\nstatic int wm8940_update_clocks(struct snd_soc_dai *dai);\nstatic int wm8940_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8940_priv *priv = snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8940_IFACE) & 0xFD9F;\n\tu16 addcntrl = snd_soc_component_read(component, WM8940_ADDCNTRL) & 0xFFF1;\n\tu16 companding =  snd_soc_component_read(component,\n\t\t\t\t\t\tWM8940_COMPANDINGCTL) & 0xFFDF;\n\tint ret;\n\n\tpriv->fs = params_rate(params);\n\tret = wm8940_update_clocks(dai);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE\n\t    && params_channels(params) == 2)\n\t\tiface |= (1 << 9);\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\taddcntrl |= (0x5 << 1);\n\t\tbreak;\n\tcase 11025:\n\t\taddcntrl |= (0x4 << 1);\n\t\tbreak;\n\tcase 16000:\n\t\taddcntrl |= (0x3 << 1);\n\t\tbreak;\n\tcase 22050:\n\t\taddcntrl |= (0x2 << 1);\n\t\tbreak;\n\tcase 32000:\n\t\taddcntrl |= (0x1 << 1);\n\t\tbreak;\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\t}\n\tret = snd_soc_component_write(component, WM8940_ADDCNTRL, addcntrl);\n\tif (ret)\n\t\tgoto error_ret;\n\n\tswitch (params_width(params)) {\n\tcase 8:\n\t\tcompanding = companding | (1 << 5);\n\t\tbreak;\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= (1 << 5);\n\t\tbreak;\n\tcase 24:\n\t\tiface |= (2 << 5);\n\t\tbreak;\n\tcase 32:\n\t\tiface |= (3 << 5);\n\t\tbreak;\n\t}\n\tret = snd_soc_component_write(component, WM8940_COMPANDINGCTL, companding);\n\tif (ret)\n\t\tgoto error_ret;\n\tret = snd_soc_component_write(component, WM8940_IFACE, iface);\n\nerror_ret:\n\treturn ret;\n}\n\nstatic int wm8940_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8940_DAC) & 0xffbf;\n\n\tif (mute)\n\t\tmute_reg |= 0x40;\n\n\treturn snd_soc_component_write(component, WM8940_DAC, mute_reg);\n}\n\nstatic int wm8940_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8940_priv *wm8940 = snd_soc_component_get_drvdata(component);\n\tu16 val;\n\tu16 pwr_reg = snd_soc_component_read(component, WM8940_POWER1) & 0x1F0;\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\t \n\t\tpwr_reg |= (1 << 2) | (1 << 3);\n\t\t \n\t\tval = snd_soc_component_read(component, WM8940_OUTPUTCTL);\n\t\tret = snd_soc_component_write(component, WM8940_OUTPUTCTL, val | 0x2);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tret = snd_soc_component_write(component, WM8940_POWER1, pwr_reg | 0x1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tpwr_reg |= (1 << 2) | (1 << 3);\n\t\tret = snd_soc_component_write(component, WM8940_POWER1, pwr_reg | 0x1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regcache_sync(wm8940->regmap);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev, \"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpwr_reg |= (1 << 2) | (1 << 3);\n\t\t \n\t\tret = snd_soc_component_write(component, WM8940_POWER1, pwr_reg | 0x2);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tret = snd_soc_component_write(component, WM8940_POWER1, pwr_reg);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstruct pll_ {\n\tunsigned int pre_scale:2;\n\tunsigned int n:4;\n\tunsigned int k;\n};\n\nstatic struct pll_ pll_div;\n\n \n#define FIXED_PLL_SIZE ((1 << 24) * 10)\nstatic void pll_factors(unsigned int target, unsigned int source)\n{\n\tunsigned long long Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\t \n\tNdiv = target / source;\n\n\tif (Ndiv > 12) {\n\t\tsource <<= 1;\n\t\t \n\t\tpll_div.pre_scale = 0;\n\t\tNdiv = target / source;\n\t} else if (Ndiv < 3) {\n\t\tsource >>= 2;\n\t\t \n\t\tpll_div.pre_scale = 3;\n\t\tNdiv = target / source;\n\t} else if (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\t \n\t\tpll_div.pre_scale = 2;\n\t\tNdiv = target / source;\n\t} else\n\t\tpll_div.pre_scale = 1;\n\n\tif ((Ndiv < 6) || (Ndiv > 12))\n\t\tprintk(KERN_WARNING\n\t\t\t\"WM8940 N value %d outwith recommended range!d\\n\",\n\t\t\tNdiv);\n\n\tpll_div.n = Ndiv;\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\t \n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tK /= 10;\n\n\tpll_div.k = K;\n}\n\n \nstatic int wm8940_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8940_POWER1);\n\tsnd_soc_component_write(component, WM8940_POWER1, reg & 0x1df);\n\n\tif (freq_in == 0 || freq_out == 0) {\n\t\t \n\t\treg = snd_soc_component_read(component, WM8940_CLOCK);\n\t\tsnd_soc_component_write(component, WM8940_CLOCK, reg & 0x0ff);\n\t\t \n\t\tsnd_soc_component_write(component, WM8940_PLLN, (1 << 7));\n\t\treturn 0;\n\t}\n\n\t \n\tpll_factors(freq_out*4, freq_in);\n\tif (pll_div.k)\n\t\tsnd_soc_component_write(component, WM8940_PLLN,\n\t\t\t     (pll_div.pre_scale << 4) | pll_div.n | (1 << 6));\n\telse  \n\t\tsnd_soc_component_write(component, WM8940_PLLN,\n\t\t\t     (pll_div.pre_scale << 4) | pll_div.n);\n\tsnd_soc_component_write(component, WM8940_PLLK1, pll_div.k >> 18);\n\tsnd_soc_component_write(component, WM8940_PLLK2, (pll_div.k >> 9) & 0x1ff);\n\tsnd_soc_component_write(component, WM8940_PLLK3, pll_div.k & 0x1ff);\n\t \n\treg = snd_soc_component_read(component, WM8940_POWER1);\n\tsnd_soc_component_write(component, WM8940_POWER1, reg | 0x020);\n\n\t \n\treg = snd_soc_component_read(component, WM8940_CLOCK);\n\tsnd_soc_component_write(component, WM8940_CLOCK, reg | 0x100);\n\n\treturn 0;\n}\n\nstatic int wm8940_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\t\t\t int div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\tint ret = 0;\n\n\tswitch (div_id) {\n\tcase WM8940_BCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8940_CLOCK) & 0xFFE3;\n\t\tret = snd_soc_component_write(component, WM8940_CLOCK, reg | (div << 2));\n\t\tbreak;\n\tcase WM8940_MCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8940_CLOCK) & 0xFF1F;\n\t\tret = snd_soc_component_write(component, WM8940_CLOCK, reg | (div << 5));\n\t\tbreak;\n\tcase WM8940_OPCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8940_GPIO) & 0xFFCF;\n\t\tret = snd_soc_component_write(component, WM8940_GPIO, reg | (div << 4));\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic unsigned int wm8940_get_mclkdiv(unsigned int f_in, unsigned int f_out,\n\t\t\t\t       int *mclkdiv)\n{\n\tunsigned int ratio = 2 * f_in / f_out;\n\n\tif (ratio <= 2) {\n\t\t*mclkdiv = WM8940_MCLKDIV_1;\n\t\tratio = 2;\n\t} else if (ratio == 3) {\n\t\t*mclkdiv = WM8940_MCLKDIV_1_5;\n\t} else if (ratio == 4) {\n\t\t*mclkdiv = WM8940_MCLKDIV_2;\n\t} else if (ratio <= 6) {\n\t\t*mclkdiv = WM8940_MCLKDIV_3;\n\t\tratio = 6;\n\t} else if (ratio <= 8) {\n\t\t*mclkdiv = WM8940_MCLKDIV_4;\n\t\tratio = 8;\n\t} else if (ratio <= 12) {\n\t\t*mclkdiv = WM8940_MCLKDIV_6;\n\t\tratio = 12;\n\t} else if (ratio <= 16) {\n\t\t*mclkdiv = WM8940_MCLKDIV_8;\n\t\tratio = 16;\n\t} else {\n\t\t*mclkdiv = WM8940_MCLKDIV_12;\n\t\tratio = 24;\n\t}\n\n\treturn f_out * ratio / 2;\n}\n\nstatic int wm8940_update_clocks(struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct wm8940_priv *priv = snd_soc_component_get_drvdata(codec);\n\tunsigned int fs256;\n\tunsigned int fpll = 0;\n\tunsigned int f;\n\tint mclkdiv;\n\n\tif (!priv->mclk || !priv->fs)\n\t\treturn 0;\n\n\tfs256 = 256 * priv->fs;\n\n\tf = wm8940_get_mclkdiv(priv->mclk, fs256, &mclkdiv);\n\tif (f != priv->mclk) {\n\t\t \n\t\tfpll = wm8940_get_mclkdiv(22500000, fs256, &mclkdiv);\n\t}\n\n\twm8940_set_dai_pll(dai, 0, 0, priv->mclk, fpll);\n\twm8940_set_dai_clkdiv(dai, WM8940_MCLKDIV, mclkdiv);\n\n\treturn 0;\n}\n\nstatic int wm8940_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct wm8940_priv *priv = snd_soc_component_get_drvdata(codec);\n\n\tif (dir != SND_SOC_CLOCK_IN)\n\t\treturn -EINVAL;\n\n\tpriv->mclk = freq;\n\n\treturn wm8940_update_clocks(dai);\n}\n\n#define WM8940_RATES SNDRV_PCM_RATE_8000_48000\n\n#define WM8940_FORMATS (SNDRV_PCM_FMTBIT_S8 |\t\t\t\t\\\n\t\t\tSNDRV_PCM_FMTBIT_S16_LE |\t\t\t\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE |\t\t\t\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\t\t\t\\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8940_dai_ops = {\n\t.hw_params = wm8940_i2s_hw_params,\n\t.set_sysclk = wm8940_set_dai_sysclk,\n\t.mute_stream = wm8940_mute,\n\t.set_fmt = wm8940_set_dai_fmt,\n\t.set_clkdiv = wm8940_set_dai_clkdiv,\n\t.set_pll = wm8940_set_dai_pll,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8940_dai = {\n\t.name = \"wm8940-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8940_RATES,\n\t\t.formats = WM8940_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8940_RATES,\n\t\t.formats = WM8940_FORMATS,\n\t},\n\t.ops = &wm8940_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8940_probe(struct snd_soc_component *component)\n{\n\tstruct wm8940_setup_data *pdata = component->dev->platform_data;\n\tint ret;\n\tu16 reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8940_SOFTRESET);\n\tif (reg != WM8940_CHIP_ID) {\n\t\tdev_err(component->dev, \"Wrong wm8940 chip ID: 0x%x\\n\", reg);\n\t\treturn -ENODEV;\n\t}\n\n\tret = wm8940_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\treturn ret;\n\t}\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\tret = snd_soc_component_write(component, WM8940_POWER1, 0x180);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pdata) {\n\t\treg = snd_soc_component_read(component, WM8940_OUTPUTCTL);\n\t\tret = snd_soc_component_write(component, WM8940_OUTPUTCTL, reg | pdata->vroi);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8940 = {\n\t.probe\t\t\t= wm8940_probe,\n\t.set_bias_level\t\t= wm8940_set_bias_level,\n\t.controls\t\t= wm8940_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8940_snd_controls),\n\t.dapm_widgets\t\t= wm8940_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8940_dapm_widgets),\n\t.dapm_routes\t\t= wm8940_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8940_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8940_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM8940_MONOMIX,\n\t.reg_defaults = wm8940_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8940_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.readable_reg = wm8940_readable_register,\n\t.volatile_reg = wm8940_volatile_register,\n};\n\nstatic int wm8940_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8940_priv *wm8940;\n\tint ret;\n\n\twm8940 = devm_kzalloc(&i2c->dev, sizeof(struct wm8940_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8940 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8940->regmap = devm_regmap_init_i2c(i2c, &wm8940_regmap);\n\tif (IS_ERR(wm8940->regmap))\n\t\treturn PTR_ERR(wm8940->regmap);\n\n\ti2c_set_clientdata(i2c, wm8940);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8940, &wm8940_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8940_i2c_id[] = {\n\t{ \"wm8940\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8940_i2c_id);\n\nstatic const struct of_device_id wm8940_of_match[] = {\n\t{ .compatible = \"wlf,wm8940\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8940_of_match);\n\nstatic struct i2c_driver wm8940_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8940\",\n\t\t.of_match_table = wm8940_of_match,\n\t},\n\t.probe = wm8940_i2c_probe,\n\t.id_table = wm8940_i2c_id,\n};\n\nmodule_i2c_driver(wm8940_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8940 driver\");\nMODULE_AUTHOR(\"Jonathan Cameron\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}