{
  "module_name": "rt5682-sdw.c",
  "hash_id": "37ebe48e7bb4b47d810eca6fbd1f942e3f60b16fe466acf913da87b6f4bf73b2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt5682-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/acpi.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mutex.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/jack.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rt5682.h\"\n\n#define RT5682_SDW_ADDR_L\t\t\t0x3000\n#define RT5682_SDW_ADDR_H\t\t\t0x3001\n#define RT5682_SDW_DATA_L\t\t\t0x3004\n#define RT5682_SDW_DATA_H\t\t\t0x3005\n#define RT5682_SDW_CMD\t\t\t\t0x3008\n\nstatic int rt5682_sdw_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\tunsigned int data_l, data_h;\n\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_CMD, 0);\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_H, (reg >> 8) & 0xff);\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_L, (reg & 0xff));\n\tregmap_read(rt5682->sdw_regmap, RT5682_SDW_DATA_H, &data_h);\n\tregmap_read(rt5682->sdw_regmap, RT5682_SDW_DATA_L, &data_l);\n\n\t*val = (data_h << 8) | data_l;\n\n\tdev_vdbg(dev, \"[%s] %04x => %04x\\n\", __func__, reg, *val);\n\n\treturn 0;\n}\n\nstatic int rt5682_sdw_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_CMD, 1);\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_H, (reg >> 8) & 0xff);\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_L, (reg & 0xff));\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_DATA_H, (val >> 8) & 0xff);\n\tregmap_write(rt5682->sdw_regmap, RT5682_SDW_DATA_L, (val & 0xff));\n\n\tdev_vdbg(dev, \"[%s] %04x <= %04x\\n\", __func__, reg, val);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config rt5682_sdw_indirect_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.max_register = RT5682_I2C_MODE,\n\t.volatile_reg = rt5682_volatile_register,\n\t.readable_reg = rt5682_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = rt5682_reg,\n\t.num_reg_defaults = RT5682_REG_NUM,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.reg_read = rt5682_sdw_read,\n\t.reg_write = rt5682_sdw_write,\n};\n\nstatic int rt5682_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\t int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt5682_sdw_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt5682_sdw_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt5682_priv *rt5682 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval;\n\tunsigned int val_p = 0, val_c = 0, osr_p = 0, osr_c = 0;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\tif (!sdw_stream)\n\t\treturn -ENOMEM;\n\n\tif (!rt5682->slave)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_config.num = 1;\n\telse\n\t\tport_config.num = 2;\n\n\tretval = sdw_stream_add_slave(rt5682->slave, &stream_config,\n\t\t\t\t      &port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 48000:\n\t\tval_p = RT5682_SDW_REF_1_48K;\n\t\tval_c = RT5682_SDW_REF_2_48K;\n\t\tbreak;\n\tcase 96000:\n\t\tval_p = RT5682_SDW_REF_1_96K;\n\t\tval_c = RT5682_SDW_REF_2_96K;\n\t\tbreak;\n\tcase 192000:\n\t\tval_p = RT5682_SDW_REF_1_192K;\n\t\tval_c = RT5682_SDW_REF_2_192K;\n\t\tbreak;\n\tcase 32000:\n\t\tval_p = RT5682_SDW_REF_1_32K;\n\t\tval_c = RT5682_SDW_REF_2_32K;\n\t\tbreak;\n\tcase 24000:\n\t\tval_p = RT5682_SDW_REF_1_24K;\n\t\tval_c = RT5682_SDW_REF_2_24K;\n\t\tbreak;\n\tcase 16000:\n\t\tval_p = RT5682_SDW_REF_1_16K;\n\t\tval_c = RT5682_SDW_REF_2_16K;\n\t\tbreak;\n\tcase 12000:\n\t\tval_p = RT5682_SDW_REF_1_12K;\n\t\tval_c = RT5682_SDW_REF_2_12K;\n\t\tbreak;\n\tcase 8000:\n\t\tval_p = RT5682_SDW_REF_1_8K;\n\t\tval_c = RT5682_SDW_REF_2_8K;\n\t\tbreak;\n\tcase 44100:\n\t\tval_p = RT5682_SDW_REF_1_44K;\n\t\tval_c = RT5682_SDW_REF_2_44K;\n\t\tbreak;\n\tcase 88200:\n\t\tval_p = RT5682_SDW_REF_1_88K;\n\t\tval_c = RT5682_SDW_REF_2_88K;\n\t\tbreak;\n\tcase 176400:\n\t\tval_p = RT5682_SDW_REF_1_176K;\n\t\tval_c = RT5682_SDW_REF_2_176K;\n\t\tbreak;\n\tcase 22050:\n\t\tval_p = RT5682_SDW_REF_1_22K;\n\t\tval_c = RT5682_SDW_REF_2_22K;\n\t\tbreak;\n\tcase 11025:\n\t\tval_p = RT5682_SDW_REF_1_11K;\n\t\tval_c = RT5682_SDW_REF_2_11K;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_rate(params) <= 48000) {\n\t\tosr_p = RT5682_DAC_OSR_D_8;\n\t\tosr_c = RT5682_ADC_OSR_D_8;\n\t} else if (params_rate(params) <= 96000) {\n\t\tosr_p = RT5682_DAC_OSR_D_4;\n\t\tosr_c = RT5682_ADC_OSR_D_4;\n\t} else {\n\t\tosr_p = RT5682_DAC_OSR_D_2;\n\t\tosr_c = RT5682_ADC_OSR_D_2;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(rt5682->regmap, RT5682_SDW_REF_CLK,\n\t\t\tRT5682_SDW_REF_1_MASK, val_p);\n\t\tregmap_update_bits(rt5682->regmap, RT5682_ADDA_CLK_1,\n\t\t\tRT5682_DAC_OSR_MASK, osr_p);\n\t} else {\n\t\tregmap_update_bits(rt5682->regmap, RT5682_SDW_REF_CLK,\n\t\t\tRT5682_SDW_REF_2_MASK, val_c);\n\t\tregmap_update_bits(rt5682->regmap, RT5682_ADDA_CLK_1,\n\t\t\tRT5682_ADC_OSR_MASK, osr_c);\n\t}\n\n\treturn retval;\n}\n\nstatic int rt5682_sdw_hw_free(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt5682_priv *rt5682 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt5682->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt5682->slave, sdw_stream);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rt5682_sdw_ops = {\n\t.hw_params\t= rt5682_sdw_hw_params,\n\t.hw_free\t= rt5682_sdw_hw_free,\n\t.set_stream\t= rt5682_set_sdw_stream,\n\t.shutdown\t= rt5682_sdw_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt5682_dai[] = {\n\t{\n\t\t.name = \"rt5682-aif1\",\n\t\t.id = RT5682_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.ops = &rt5682_aif1_dai_ops,\n\t},\n\t{\n\t\t.name = \"rt5682-aif2\",\n\t\t.id = RT5682_AIF2,\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.ops = &rt5682_aif2_dai_ops,\n\t},\n\t{\n\t\t.name = \"rt5682-sdw\",\n\t\t.id = RT5682_SDW,\n\t\t.playback = {\n\t\t\t.stream_name = \"SDW Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"SDW Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.ops = &rt5682_sdw_ops,\n\t},\n};\n\nstatic int rt5682_sdw_init(struct device *dev, struct regmap *regmap,\n\t\t\t   struct sdw_slave *slave)\n{\n\tstruct rt5682_priv *rt5682;\n\tint ret;\n\n\trt5682 = devm_kzalloc(dev, sizeof(*rt5682), GFP_KERNEL);\n\tif (!rt5682)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt5682);\n\trt5682->slave = slave;\n\trt5682->sdw_regmap = regmap;\n\trt5682->is_sdw = true;\n\n\tmutex_init(&rt5682->disable_irq_lock);\n\n\trt5682->regmap = devm_regmap_init(dev, NULL, dev,\n\t\t\t\t\t  &rt5682_sdw_indirect_regmap);\n\tif (IS_ERR(rt5682->regmap)) {\n\t\tret = PTR_ERR(rt5682->regmap);\n\t\tdev_err(dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\n\tret = rt5682_get_ldo1(rt5682, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_only(rt5682->sdw_regmap, true);\n\tregcache_cache_only(rt5682->regmap, true);\n\n\t \n\trt5682->hw_init = false;\n\trt5682->first_hw_init = false;\n\n\tmutex_init(&rt5682->calibrate_mutex);\n\tINIT_DELAYED_WORK(&rt5682->jack_detect_work,\n\t\trt5682_jack_detect_handler);\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t\t\t      &rt5682_soc_component_dev,\n\t\t\t\t\t      rt5682_dai, ARRAY_SIZE(rt5682_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int rt5682_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\tint ret = 0, loop = 10;\n\tunsigned int val;\n\n\trt5682->disable_irq = false;\n\n\tif (rt5682->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt5682->sdw_regmap, false);\n\tregcache_cache_only(rt5682->regmap, false);\n\tif (rt5682->first_hw_init)\n\t\tregcache_cache_bypass(rt5682->regmap, true);\n\n\t \n\tif (!rt5682->first_hw_init)\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\twhile (loop > 0) {\n\t\tregmap_read(rt5682->regmap, RT5682_DEVICE_ID, &val);\n\t\tif (val == DEVICE_ID)\n\t\t\tbreak;\n\t\tdev_warn(dev, \"Device with ID register %x is not rt5682\\n\", val);\n\t\tusleep_range(30000, 30005);\n\t\tloop--;\n\t}\n\n\tif (val != DEVICE_ID) {\n\t\tdev_err(dev, \"Device with ID register %x is not rt5682\\n\", val);\n\t\tret = -ENODEV;\n\t\tgoto err_nodev;\n\t}\n\n\trt5682_calibrate(rt5682);\n\n\tif (rt5682->first_hw_init) {\n\t\tregcache_cache_bypass(rt5682->regmap, false);\n\t\tregcache_mark_dirty(rt5682->regmap);\n\t\tregcache_sync(rt5682->regmap);\n\n\t\t \n\t\tregmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_2,\n\t\t\tRT5682_EXT_JD_SRC, RT5682_EXT_JD_SRC_MANUAL);\n\n\t\tgoto reinit;\n\t}\n\n\trt5682_apply_patch_list(rt5682, dev);\n\n\tregmap_write(rt5682->regmap, RT5682_DEPOP_1, 0x0000);\n\n\tregmap_update_bits(rt5682->regmap, RT5682_PWR_ANLG_1,\n\t\tRT5682_LDO1_DVO_MASK | RT5682_HP_DRIVER_MASK,\n\t\tRT5682_LDO1_DVO_12 | RT5682_HP_DRIVER_5X);\n\tregmap_write(rt5682->regmap, RT5682_MICBIAS_2, 0x0080);\n\tregmap_write(rt5682->regmap, RT5682_TEST_MODE_CTRL_1, 0x0000);\n\tregmap_update_bits(rt5682->regmap, RT5682_BIAS_CUR_CTRL_8,\n\t\tRT5682_HPA_CP_BIAS_CTRL_MASK, RT5682_HPA_CP_BIAS_3UA);\n\tregmap_update_bits(rt5682->regmap, RT5682_CHARGE_PUMP_1,\n\t\tRT5682_CP_CLK_HP_MASK, RT5682_CP_CLK_HP_300KHZ);\n\tregmap_update_bits(rt5682->regmap, RT5682_HP_CHARGE_PUMP_1,\n\t\tRT5682_PM_HP_MASK, RT5682_PM_HP_HV);\n\n\t \n\tregmap_write(rt5682->regmap, RT5682_PLL2_INTERNAL, 0xa266);\n\tregmap_write(rt5682->regmap, RT5682_PLL2_CTRL_1, 0x1700);\n\tregmap_write(rt5682->regmap, RT5682_PLL2_CTRL_2, 0x0006);\n\tregmap_write(rt5682->regmap, RT5682_PLL2_CTRL_3, 0x2600);\n\tregmap_write(rt5682->regmap, RT5682_PLL2_CTRL_4, 0x0c8f);\n\tregmap_write(rt5682->regmap, RT5682_PLL_TRACK_2, 0x3000);\n\tregmap_write(rt5682->regmap, RT5682_PLL_TRACK_3, 0x4000);\n\tregmap_update_bits(rt5682->regmap, RT5682_GLB_CLK,\n\t\tRT5682_SCLK_SRC_MASK | RT5682_PLL2_SRC_MASK,\n\t\tRT5682_SCLK_SRC_PLL2 | RT5682_PLL2_SRC_SDW);\n\n\tregmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_2,\n\t\tRT5682_EXT_JD_SRC, RT5682_EXT_JD_SRC_MANUAL);\n\tregmap_write(rt5682->regmap, RT5682_CBJ_CTRL_1, 0xd142);\n\tregmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_5, 0x0700, 0x0600);\n\tregmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_3,\n\t\tRT5682_CBJ_IN_BUF_EN, RT5682_CBJ_IN_BUF_EN);\n\tregmap_update_bits(rt5682->regmap, RT5682_SAR_IL_CMD_1,\n\t\tRT5682_SAR_POW_MASK, RT5682_SAR_POW_EN);\n\tregmap_update_bits(rt5682->regmap, RT5682_RC_CLK_CTRL,\n\t\tRT5682_POW_IRQ | RT5682_POW_JDH |\n\t\tRT5682_POW_ANA, RT5682_POW_IRQ |\n\t\tRT5682_POW_JDH | RT5682_POW_ANA);\n\tregmap_update_bits(rt5682->regmap, RT5682_PWR_ANLG_2,\n\t\tRT5682_PWR_JDH, RT5682_PWR_JDH);\n\tregmap_update_bits(rt5682->regmap, RT5682_IRQ_CTRL_2,\n\t\tRT5682_JD1_EN_MASK | RT5682_JD1_IRQ_MASK,\n\t\tRT5682_JD1_EN | RT5682_JD1_IRQ_PUL);\n\nreinit:\n\tmod_delayed_work(system_power_efficient_wq,\n\t\t&rt5682->jack_detect_work, msecs_to_jiffies(250));\n\n\t \n\trt5682->hw_init = true;\n\trt5682->first_hw_init = true;\n\nerr_nodev:\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete: %d\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic bool rt5682_sdw_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00e0:\n\tcase 0x00f0:\n\tcase 0x3000:\n\tcase 0x3001:\n\tcase 0x3004:\n\tcase 0x3005:\n\tcase 0x3008:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt5682_sdw_regmap = {\n\t.name = \"sdw\",\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.max_register = RT5682_I2C_MODE,\n\t.readable_reg = rt5682_sdw_readable_register,\n\t.cache_type = REGCACHE_NONE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt5682_update_status(struct sdw_slave *slave,\n\t\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt5682->hw_init = false;\n\n\t \n\tif (rt5682->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt5682_io_init(&slave->dev, slave);\n}\n\nstatic int rt5682_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_IMPL_DEF | SDW_SCP_INT1_BUS_CLASH |\n\t\tSDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = false;\n\n\t \n\tprop->source_ports = 0x4;\t \n\tprop->sink_ports = 0x2;\t\t \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t  sizeof(*prop->src_dpn_prop),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t   sizeof(*prop->sink_dpn_prop),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 20;\n\n\t \n\tprop->wake_capable = 1;\n\n\treturn 0;\n}\n\n \n#define RT5682_CLK_FREQ_9600000HZ 9600000\n#define RT5682_CLK_FREQ_12000000HZ 12000000\n#define RT5682_CLK_FREQ_6000000HZ 6000000\n#define RT5682_CLK_FREQ_4800000HZ 4800000\n#define RT5682_CLK_FREQ_2400000HZ 2400000\n#define RT5682_CLK_FREQ_12288000HZ 12288000\n\nstatic int rt5682_clock_config(struct device *dev)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\tunsigned int clk_freq, value;\n\n\tclk_freq = (rt5682->params.curr_dr_freq >> 1);\n\n\tswitch (clk_freq) {\n\tcase RT5682_CLK_FREQ_12000000HZ:\n\t\tvalue = 0x0;\n\t\tbreak;\n\tcase RT5682_CLK_FREQ_6000000HZ:\n\t\tvalue = 0x1;\n\t\tbreak;\n\tcase RT5682_CLK_FREQ_9600000HZ:\n\t\tvalue = 0x2;\n\t\tbreak;\n\tcase RT5682_CLK_FREQ_4800000HZ:\n\t\tvalue = 0x3;\n\t\tbreak;\n\tcase RT5682_CLK_FREQ_2400000HZ:\n\t\tvalue = 0x4;\n\t\tbreak;\n\tcase RT5682_CLK_FREQ_12288000HZ:\n\t\tvalue = 0x5;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(rt5682->sdw_regmap, 0xe0, value);\n\tregmap_write(rt5682->sdw_regmap, 0xf0, value);\n\n\tdev_dbg(dev, \"%s complete, clk_freq=%d\\n\", __func__, clk_freq);\n\n\treturn 0;\n}\n\nstatic int rt5682_bus_config(struct sdw_slave *slave,\n\t\t\t\t\tstruct sdw_bus_params *params)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(&slave->dev);\n\tint ret;\n\n\tmemcpy(&rt5682->params, params, sizeof(*params));\n\n\tret = rt5682_clock_config(&slave->dev);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev, \"Invalid clk config\");\n\n\treturn ret;\n}\n\nstatic int rt5682_interrupt_callback(struct sdw_slave *slave,\n\t\t\t\t\tstruct sdw_slave_intr_status *status)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(&slave->dev);\n\n\tdev_dbg(&slave->dev,\n\t\t\"%s control_port_stat=%x\", __func__, status->control_port);\n\n\tmutex_lock(&rt5682->disable_irq_lock);\n\tif (status->control_port & 0x4 && !rt5682->disable_irq) {\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt5682->jack_detect_work, msecs_to_jiffies(rt5682->irq_work_delay_time));\n\t}\n\tmutex_unlock(&rt5682->disable_irq_lock);\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops rt5682_slave_ops = {\n\t.read_prop = rt5682_read_prop,\n\t.interrupt_callback = rt5682_interrupt_callback,\n\t.update_status = rt5682_update_status,\n\t.bus_config = rt5682_bus_config,\n};\n\nstatic int rt5682_sdw_probe(struct sdw_slave *slave,\n\t\t\t   const struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &rt5682_sdw_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn -EINVAL;\n\n\treturn rt5682_sdw_init(&slave->dev, regmap, slave);\n}\n\nstatic int rt5682_sdw_remove(struct sdw_slave *slave)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(&slave->dev);\n\n\tif (rt5682->hw_init)\n\t\tcancel_delayed_work_sync(&rt5682->jack_detect_work);\n\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt5682_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x5682, 0x2, 0, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt5682_id);\n\nstatic int __maybe_unused rt5682_dev_suspend(struct device *dev)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\n\tif (!rt5682->hw_init)\n\t\treturn 0;\n\n\tcancel_delayed_work_sync(&rt5682->jack_detect_work);\n\n\tregcache_cache_only(rt5682->sdw_regmap, true);\n\tregcache_cache_only(rt5682->regmap, true);\n\tregcache_mark_dirty(rt5682->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt5682_dev_system_suspend(struct device *dev)\n{\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tint ret;\n\n\tif (!rt5682->hw_init)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&rt5682->disable_irq_lock);\n\trt5682->disable_irq = true;\n\tret = sdw_update_no_pm(slave, SDW_SCP_INTMASK1,\n\t\t\t       SDW_SCP_INT1_IMPL_DEF, 0);\n\tmutex_unlock(&rt5682->disable_irq_lock);\n\n\tif (ret < 0) {\n\t\t \n\t\tdev_dbg(&slave->dev, \"%s: could not disable imp-def interrupts\\n:\", __func__);\n\t}\n\n\treturn rt5682_dev_suspend(dev);\n}\n\nstatic int __maybe_unused rt5682_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt5682_priv *rt5682 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt5682->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request) {\n\t\tif (rt5682->disable_irq == true) {\n\t\t\tmutex_lock(&rt5682->disable_irq_lock);\n\t\t\tsdw_write_no_pm(slave, SDW_SCP_INTMASK1, SDW_SCP_INT1_IMPL_DEF);\n\t\t\trt5682->disable_irq = false;\n\t\t\tmutex_unlock(&rt5682->disable_irq_lock);\n\t\t}\n\t\tgoto regmap_sync;\n\t}\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT5682_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt5682->sdw_regmap, false);\n\tregcache_cache_only(rt5682->regmap, false);\n\tregcache_sync(rt5682->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt5682_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt5682_dev_system_suspend, rt5682_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt5682_dev_suspend, rt5682_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt5682_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt5682\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt5682_pm,\n\t},\n\t.probe = rt5682_sdw_probe,\n\t.remove = rt5682_sdw_remove,\n\t.ops = &rt5682_slave_ops,\n\t.id_table = rt5682_id,\n};\nmodule_sdw_driver(rt5682_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT5682 driver SDW\");\nMODULE_AUTHOR(\"Oder Chiou <oder_chiou@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}