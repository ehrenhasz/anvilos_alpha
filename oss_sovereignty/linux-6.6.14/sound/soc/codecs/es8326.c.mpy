{
  "module_name": "es8326.c",
  "hash_id": "2ff3adf6d326ca65b38e99495e88101c0b9eda948390cb5cefd086f25720c220",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/es8326.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <sound/jack.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n#include \"es8326.h\"\n\nstruct es8326_priv {\n\tstruct clk *mclk;\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct delayed_work jack_detect_work;\n\tstruct delayed_work button_press_work;\n\tstruct snd_soc_jack *jack;\n\tint irq;\n\t \n\tstruct mutex lock;\n\tu8 mic1_src;\n\tu8 mic2_src;\n\tu8 jack_pol;\n\tu8 interrupt_src;\n\tu8 interrupt_clk;\n\tbool jd_inverted;\n\tunsigned int sysclk;\n\n\tbool calibrated;\n\tint version;\n\tint hp;\n\tint jack_remove_retry;\n};\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(dac_vol_tlv, -9550, 50, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_vol_tlv, -9550, 50, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_analog_pga_tlv, 0, 300, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_pga_tlv, 0, 600, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(softramp_rate, 0, 100, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(drc_target_tlv, -3200, 200, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(drc_recovery_tlv, -125, 250, 0);\n\nstatic const char *const winsize[] = {\n\t\"0.25db/2  LRCK\",\n\t\"0.25db/4  LRCK\",\n\t\"0.25db/8  LRCK\",\n\t\"0.25db/16  LRCK\",\n\t\"0.25db/32  LRCK\",\n\t\"0.25db/64  LRCK\",\n\t\"0.25db/128  LRCK\",\n\t\"0.25db/256  LRCK\",\n\t\"0.25db/512  LRCK\",\n\t\"0.25db/1024  LRCK\",\n\t\"0.25db/2048  LRCK\",\n\t\"0.25db/4096  LRCK\",\n\t\"0.25db/8192  LRCK\",\n\t\"0.25db/16384  LRCK\",\n\t\"0.25db/32768  LRCK\",\n\t\"0.25db/65536  LRCK\",\n};\n\nstatic const char *const dacpol_txt[] =\t{\n\t\"Normal\", \"R Invert\", \"L Invert\", \"L + R Invert\" };\n\nstatic const struct soc_enum dacpol =\n\tSOC_ENUM_SINGLE(ES8326_DAC_DSM, 4, 4, dacpol_txt);\nstatic const struct soc_enum alc_winsize =\n\tSOC_ENUM_SINGLE(ES8326_ADC_RAMPRATE, 4, 16, winsize);\nstatic const struct soc_enum drc_winsize =\n\tSOC_ENUM_SINGLE(ES8326_DRC_WINSIZE, 4, 16, winsize);\n\nstatic const struct snd_kcontrol_new es8326_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"DAC Playback Volume\", ES8326_DAC_VOL, 0, 0xbf, 0, dac_vol_tlv),\n\tSOC_ENUM(\"Playback Polarity\", dacpol),\n\tSOC_SINGLE_TLV(\"DAC Ramp Rate\", ES8326_DAC_RAMPRATE, 0, 0x0f, 0, softramp_rate),\n\tSOC_SINGLE_TLV(\"DRC Recovery Level\", ES8326_DRC_RECOVERY, 0, 4, 0, drc_recovery_tlv),\n\tSOC_ENUM(\"DRC Winsize\", drc_winsize),\n\tSOC_SINGLE_TLV(\"DRC Target Level\", ES8326_DRC_WINSIZE, 0, 0x0f, 0, drc_target_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"ADC Capture Volume\", ES8326_ADC1_VOL, ES8326_ADC2_VOL, 0, 0xff, 0,\n\t\t\t adc_vol_tlv),\n\tSOC_DOUBLE_TLV(\"ADC PGA Volume\", ES8326_ADC_SCALE, 4, 0, 5, 0, adc_pga_tlv),\n\tSOC_SINGLE_TLV(\"ADC PGA Gain Volume\", ES8326_PGAGAIN, 0, 10, 0, adc_analog_pga_tlv),\n\tSOC_SINGLE_TLV(\"ADC Ramp Rate\", ES8326_ADC_RAMPRATE, 0, 0x0f, 0, softramp_rate),\n\tSOC_SINGLE(\"ALC Capture Switch\", ES8326_ALC_RECOVERY, 3, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Capture Recovery Level\", ES8326_ALC_LEVEL,\n\t\t\t0, 4, 0, drc_recovery_tlv),\n\tSOC_ENUM(\"ALC Capture Winsize\", alc_winsize),\n\tSOC_SINGLE_TLV(\"ALC Capture Target Level\", ES8326_ALC_LEVEL,\n\t\t\t0, 0x0f, 0, drc_target_tlv),\n\n};\n\nstatic const struct snd_soc_dapm_widget es8326_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"MIC3\"),\n\tSND_SOC_DAPM_INPUT(\"MIC4\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC L\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC R\", NULL, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"I2S OUT\", \"I2S1 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"I2S IN\", \"I2S1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_PGA(\"ADC L1\", ES8326_ADC_MUTE, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC R1\", ES8326_ADC_MUTE, 1, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC L2\", ES8326_ADC_MUTE, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"ADC R2\", ES8326_ADC_MUTE, 3, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_DAC(\"Right DAC\", NULL, ES8326_ANA_PDN, 0, 1),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", NULL, ES8326_ANA_PDN, 1, 1),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS1\", ES8326_ANA_MICBIAS, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS2\", ES8326_ANA_MICBIAS, 3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"LHPMIX\", ES8326_DAC2HPMIX, 7, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"RHPMIX\", ES8326_DAC2HPMIX, 3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route es8326_dapm_routes[] = {\n\t{\"ADC L1\", NULL, \"MIC1\"},\n\t{\"ADC R1\", NULL, \"MIC2\"},\n\t{\"ADC L2\", NULL, \"MIC3\"},\n\t{\"ADC R2\", NULL, \"MIC4\"},\n\n\t{\"ADC L\", NULL, \"ADC L1\"},\n\t{\"ADC R\", NULL, \"ADC R1\"},\n\t{\"ADC L\", NULL, \"ADC L2\"},\n\t{\"ADC R\", NULL, \"ADC R2\"},\n\n\t{\"I2S OUT\", NULL, \"ADC L\"},\n\t{\"I2S OUT\", NULL, \"ADC R\"},\n\n\t{\"Right DAC\", NULL, \"I2S IN\"},\n\t{\"Left DAC\", NULL, \"I2S IN\"},\n\n\t{\"LHPMIX\", NULL, \"Left DAC\"},\n\t{\"RHPMIX\", NULL, \"Right DAC\"},\n\n\t{\"HPOL\", NULL, \"LHPMIX\"},\n\t{\"HPOR\", NULL, \"RHPMIX\"},\n};\n\nstatic bool es8326_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ES8326_HPL_OFFSET_INI:\n\tcase ES8326_HPR_OFFSET_INI:\n\tcase ES8326_HPDET_STA:\n\tcase ES8326_CTIA_OMTP_STA:\n\tcase ES8326_CSM_MUTE_STA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config es8326_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n\t.volatile_reg = es8326_volatile_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstruct _coeff_div {\n\tu16 fs;\n\tu32 rate;\n\tu32 mclk;\n\tu8 reg4;\n\tu8 reg5;\n\tu8 reg6;\n\tu8 reg7;\n\tu8 reg8;\n\tu8 reg9;\n\tu8 rega;\n\tu8 regb;\n};\n\n \n \nstatic const struct _coeff_div coeff_div[] = {\n\t{32, 8000, 256000, 0x60, 0x00, 0x0F, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{32, 16000, 512000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{32, 44100, 1411200, 0x00, 0x00, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{32, 48000, 1536000, 0x00, 0x00, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{36, 8000, 288000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x23, 0x47},\n\t{36, 16000, 576000, 0x20, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x23, 0x47},\n\t{48, 8000, 384000, 0x60, 0x02, 0x1F, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{48, 16000, 768000, 0x20, 0x02, 0x0F, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{48, 48000, 2304000, 0x00, 0x02, 0x0D, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{64, 8000, 512000, 0x60, 0x00, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{64, 16000, 1024000, 0x20, 0x00, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},\n\n\t{64, 44100, 2822400, 0x00, 0x00, 0x11, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{64, 48000, 3072000, 0x00, 0x00, 0x11, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{72, 8000, 576000, 0x20, 0x00, 0x13, 0x35, 0x0A, 0x1B, 0x23, 0x47},\n\t{72, 16000, 1152000, 0x20, 0x00, 0x05, 0x75, 0x0A, 0x1B, 0x23, 0x47},\n\t{96, 8000, 768000, 0x60, 0x02, 0x1D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{96, 16000, 1536000, 0x20, 0x02, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{100, 48000, 4800000, 0x04, 0x04, 0x3F, 0x6D, 0x38, 0x08, 0x4f, 0x1f},\n\t{125, 48000, 6000000, 0x04, 0x04, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},\n\t{128, 8000, 1024000, 0x60, 0x00, 0x13, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{128, 16000, 2048000, 0x20, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\n\t{128, 44100, 5644800, 0x00, 0x00, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{128, 48000, 6144000, 0x00, 0x00, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{144, 8000, 1152000, 0x20, 0x00, 0x03, 0x35, 0x0A, 0x1B, 0x23, 0x47},\n\t{144, 16000, 2304000, 0x20, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x23, 0x47},\n\t{192, 8000, 1536000, 0x60, 0x02, 0x0D, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{192, 16000, 3072000, 0x20, 0x02, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{200, 48000, 9600000, 0x04, 0x04, 0x0F, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{250, 48000, 12000000, 0x04, 0x04, 0x0F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},\n\t{256, 8000, 2048000, 0x60, 0x00, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{256, 16000, 4096000, 0x20, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\n\t{256, 44100, 11289600, 0x00, 0x00, 0x10, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{256, 48000, 12288000, 0x00, 0x00, 0x30, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{288, 8000, 2304000, 0x20, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x23, 0x47},\n\t{384, 8000, 3072000, 0x60, 0x02, 0x05, 0x75, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{384, 16000, 6144000, 0x20, 0x02, 0x03, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{384, 48000, 18432000, 0x00, 0x02, 0x01, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{400, 48000, 19200000, 0x09, 0x04, 0x0f, 0x6d, 0x3a, 0x0A, 0x4F, 0x1F},\n\t{500, 48000, 24000000, 0x18, 0x04, 0x1F, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{512, 8000, 4096000, 0x60, 0x00, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{512, 16000, 8192000, 0x20, 0x00, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\n\t{512, 44100, 22579200, 0x00, 0x00, 0x00, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{512, 48000, 24576000, 0x00, 0x00, 0x00, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{768, 8000, 6144000, 0x60, 0x02, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{768, 16000, 12288000, 0x20, 0x02, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{800, 48000, 38400000, 0x00, 0x18, 0x13, 0x2D, 0x0A, 0x0A, 0x1F, 0x1F},\n\t{1024, 8000, 8192000, 0x60, 0x00, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{1024, 16000, 16384000, 0x20, 0x00, 0x00, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{1152, 16000, 18432000, 0x20, 0x08, 0x11, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{1536, 8000, 12288000, 0x60, 0x02, 0x01, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\n\t{1536, 16000, 24576000, 0x20, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x3F},\n\t{1625, 8000, 13000000, 0x0C, 0x18, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},\n\t{1625, 16000, 26000000, 0x0C, 0x18, 0x1F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},\n\t{2048, 8000, 16384000, 0x60, 0x00, 0x00, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{2304, 8000, 18432000, 0x40, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x5F},\n\t{3072, 8000, 24576000, 0x60, 0x02, 0x10, 0x35, 0x0A, 0x1B, 0x1F, 0x7F},\n\t{3250, 8000, 26000000, 0x0C, 0x18, 0x0F, 0x2D, 0x0A, 0x0A, 0x27, 0x27},\n\n};\n\nstatic inline int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int es8326_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *codec = codec_dai->component;\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(codec);\n\n\tes8326->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int es8326_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 iface = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tsnd_soc_component_update_bits(component, ES8326_RESET,\n\t\t\t\t\t      ES8326_MASTER_MODE_EN, ES8326_MASTER_MODE_EN);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdev_err(component->dev, \"Codec driver does not support right justified\\n\");\n\t\treturn -EINVAL;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= ES8326_DAIFMT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= ES8326_DAIFMT_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= ES8326_DAIFMT_DSP_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, ES8326_FMT, ES8326_DAIFMT_MASK, iface);\n\n\treturn 0;\n}\n\nstatic int es8326_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\tu8 srate = 0;\n\tint coeff;\n\n\tcoeff = get_coeff(es8326->sysclk, params_rate(params));\n\t \n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tsrate |= ES8326_S16_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tsrate |= ES8326_S20_3_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tsrate |= ES8326_S18_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tsrate |= ES8326_S24_LE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tsrate |= ES8326_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, ES8326_FMT, ES8326_DATA_LEN_MASK, srate);\n\n\tif (coeff >= 0) {\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_DIV1,\n\t\t\t     coeff_div[coeff].reg4);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_DIV2,\n\t\t\t     coeff_div[coeff].reg5);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_DLL,\n\t\t\t     coeff_div[coeff].reg6);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_MUX,\n\t\t\t     coeff_div[coeff].reg7);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_ADC_SEL,\n\t\t\t     coeff_div[coeff].reg8);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_DAC_SEL,\n\t\t\t     coeff_div[coeff].reg9);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_ADC_OSR,\n\t\t\t     coeff_div[coeff].rega);\n\t\tregmap_write(es8326->regmap,  ES8326_CLK_DAC_OSR,\n\t\t\t     coeff_div[coeff].regb);\n\t} else {\n\t\tdev_warn(component->dev, \"Clock coefficients do not match\");\n\t}\n\n\treturn 0;\n}\n\nstatic int es8326_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\tunsigned int offset_l, offset_r;\n\n\tif (mute) {\n\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);\n\t\tregmap_update_bits(es8326->regmap, ES8326_DAC_MUTE,\n\t\t\t\tES8326_MUTE_MASK, ES8326_MUTE);\n\t\tregmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xf0);\n\t} else {\n\t\tif (!es8326->calibrated) {\n\t\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_FORCE_CAL);\n\t\t\tmsleep(30);\n\t\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);\n\t\t\tregmap_read(es8326->regmap, ES8326_HPL_OFFSET_INI, &offset_l);\n\t\t\tregmap_read(es8326->regmap, ES8326_HPR_OFFSET_INI, &offset_r);\n\t\t\tregmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);\n\t\t\tregmap_write(es8326->regmap, ES8326_HPL_OFFSET_INI, offset_l);\n\t\t\tregmap_write(es8326->regmap, ES8326_HPR_OFFSET_INI, offset_r);\n\t\t\tes8326->calibrated = true;\n\t\t}\n\t\tregmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa0);\n\t\tregmap_write(es8326->regmap, ES8326_HP_VOL, 0x80);\n\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_ON);\n\t\tregmap_update_bits(es8326->regmap, ES8326_DAC_MUTE,\n\t\t\t\tES8326_MUTE_MASK, ~(ES8326_MUTE));\n\t}\n\treturn 0;\n}\n\nstatic int es8326_set_bias_level(struct snd_soc_component *codec,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(codec);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tret = clk_prepare_enable(es8326->mclk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tregmap_write(es8326->regmap, ES8326_RESET, 0x9f);\n\t\tmsleep(20);\n\t\tregmap_update_bits(es8326->regmap, ES8326_DAC_DSM, 0x01, 0x00);\n\t\tregmap_write(es8326->regmap, ES8326_INTOUT_IO, es8326->interrupt_clk);\n\t\tregmap_write(es8326->regmap, ES8326_SDINOUT1_IO,\n\t\t\t    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));\n\t\tregmap_write(es8326->regmap, ES8326_VMIDSEL, 0x0E);\n\t\tregmap_write(es8326->regmap, ES8326_PGA_PDN, 0x40);\n\t\tregmap_write(es8326->regmap, ES8326_ANA_PDN, 0x00);\n\t\tregmap_update_bits(es8326->regmap,  ES8326_CLK_CTL, 0x20, 0x20);\n\t\tregmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_ON);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tclk_disable_unprepare(es8326->mclk);\n\t\tregmap_write(es8326->regmap, ES8326_ANA_PDN, 0x3b);\n\t\tregmap_write(es8326->regmap, ES8326_VMIDSEL, 0x00);\n\t\tregmap_update_bits(es8326->regmap, ES8326_CLK_CTL, 0x20, 0x00);\n\t\tregmap_write(es8326->regmap, ES8326_SDINOUT1_IO, ES8326_IO_INPUT);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define es8326_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops es8326_ops = {\n\t.hw_params = es8326_pcm_hw_params,\n\t.set_fmt = es8326_set_dai_fmt,\n\t.set_sysclk = es8326_set_dai_sysclk,\n\t.mute_stream = es8326_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver es8326_dai = {\n\t.name = \"ES8326 HiFi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = es8326_FORMATS,\n\t\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = es8326_FORMATS,\n\t\t},\n\t.ops = &es8326_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic void es8326_enable_micbias(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"MICBIAS1\");\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"MICBIAS2\");\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\nstatic void es8326_disable_micbias(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"MICBIAS1\");\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"MICBIAS2\");\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\n \nstatic void es8326_jack_button_handler(struct work_struct *work)\n{\n\tstruct es8326_priv *es8326 =\n\t\tcontainer_of(work, struct es8326_priv, button_press_work.work);\n\tstruct snd_soc_component *comp = es8326->component;\n\tunsigned int iface;\n\tstatic int button_to_report, press_count;\n\tstatic int prev_button, cur_button;\n\n\tif (!(es8326->jack->status & SND_JACK_HEADSET))  \n\t\treturn;\n\n\tmutex_lock(&es8326->lock);\n\tiface = snd_soc_component_read(comp, ES8326_HPDET_STA);\n\tswitch (iface) {\n\tcase 0x93:\n\t\t \n\t\tcur_button = SND_JACK_BTN_0;\n\t\tbreak;\n\tcase 0x6f:\n\tcase 0x4b:\n\t\t \n\t\tcur_button = SND_JACK_BTN_1;\n\t\tbreak;\n\tcase 0x27:\n\t\t \n\t\tcur_button = SND_JACK_BTN_2;\n\t\tbreak;\n\tcase 0x1e:\n\tcase 0xe2:\n\t\t \n\t\tcur_button = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((prev_button == cur_button) && (cur_button != 0)) {\n\t\tpress_count++;\n\t\tif (press_count > 3) {\n\t\t\t \n\t\t\tsnd_soc_jack_report(es8326->jack, cur_button,\n\t\t\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2);\n\t\t\tpress_count = 0;\n\t\t}\n\t\tbutton_to_report = cur_button;\n\t\tqueue_delayed_work(system_wq, &es8326->button_press_work,\n\t\t\t\t   msecs_to_jiffies(35));\n\t} else if (prev_button != cur_button) {\n\t\t \n\t\tprev_button = cur_button;\n\t\tqueue_delayed_work(system_wq, &es8326->button_press_work,\n\t\t\t\t   msecs_to_jiffies(35));\n\t} else {\n\t\t \n\t\tif (button_to_report != 0) {\n\t\t\tsnd_soc_jack_report(es8326->jack, button_to_report,\n\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2);\n\t\t\tsnd_soc_jack_report(es8326->jack, 0,\n\t\t\t\t    SND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2);\n\t\t\tbutton_to_report = 0;\n\t\t}\n\t}\n\tmutex_unlock(&es8326->lock);\n}\n\nstatic void es8326_jack_detect_handler(struct work_struct *work)\n{\n\tstruct es8326_priv *es8326 =\n\t\tcontainer_of(work, struct es8326_priv, jack_detect_work.work);\n\tstruct snd_soc_component *comp = es8326->component;\n\tunsigned int iface;\n\n\tmutex_lock(&es8326->lock);\n\tiface = snd_soc_component_read(comp, ES8326_HPDET_STA);\n\tdev_dbg(comp->dev, \"gpio flag %#04x\", iface);\n\n\tif (es8326->jack_remove_retry == 1) {\n\t\tif (iface & ES8326_HPINSERT_FLAG)\n\t\t\tes8326->jack_remove_retry = 2;\n\t\telse\n\t\t\tes8326->jack_remove_retry = 0;\n\n\t\tdev_dbg(comp->dev, \"remove event check, set HPJACK_POL normal, cnt = %d\\n\",\n\t\t\t\tes8326->jack_remove_retry);\n\t\t \n\t\tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE,\n\t\t\t\t\tES8326_HP_DET_JACK_POL, (es8326->jd_inverted ?\n\t\t\t\t\t~es8326->jack_pol : es8326->jack_pol));\n\t\tgoto exit;\n\t}\n\n\tif ((iface & ES8326_HPINSERT_FLAG) == 0) {\n\t\t \n\t\tdev_dbg(comp->dev, \"No headset detected\\n\");\n\t\tes8326_disable_micbias(es8326->component);\n\t\tif (es8326->jack->status & SND_JACK_HEADPHONE) {\n\t\t\tdev_dbg(comp->dev, \"Report hp remove event\\n\");\n\t\t\tsnd_soc_jack_report(es8326->jack, 0, SND_JACK_HEADSET);\n\t\t\t \n\t\t\tregmap_write(es8326->regmap, ES8326_ADC_SCALE, 0x33);\n\t\t\tregmap_write(es8326->regmap, ES8326_ADC1_SRC, 0x44);\n\t\t\tregmap_write(es8326->regmap, ES8326_ADC2_SRC, 0x66);\n\t\t\tes8326->hp = 0;\n\t\t}\n\t\tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);\n\t\t \n\t\tif (es8326->jack_remove_retry == 0) {\n\t\t\tes8326->jack_remove_retry = 1;\n\t\t\tdev_dbg(comp->dev, \"remove event check, invert HPJACK_POL, cnt = %d\\n\",\n\t\t\t\t\tes8326->jack_remove_retry);\n\t\t\tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE,\n\t\t\t\t\tES8326_HP_DET_JACK_POL, (es8326->jd_inverted ?\n\t\t\t\t\tes8326->jack_pol : ~es8326->jack_pol));\n\n\t\t} else {\n\t\t\tes8326->jack_remove_retry = 0;\n\t\t}\n\t} else if ((iface & ES8326_HPINSERT_FLAG) == ES8326_HPINSERT_FLAG) {\n\t\tes8326->jack_remove_retry = 0;\n\t\tif (es8326->hp == 0) {\n\t\t\tdev_dbg(comp->dev, \"First insert, start OMTP/CTIA type check\\n\");\n\t\t\t \n\t\t\tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x01);\n\t\t\tusleep_range(50000, 70000);\n\t\t\tregmap_update_bits(es8326->regmap, ES8326_HPDET_TYPE, 0x03, 0x00);\n\t\t\tqueue_delayed_work(system_wq, &es8326->jack_detect_work,\n\t\t\t\t\tmsecs_to_jiffies(100));\n\t\t\tes8326->hp = 1;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (es8326->jack->status & SND_JACK_HEADSET) {\n\t\t\t \n\t\t\tdev_dbg(comp->dev, \"button pressed\\n\");\n\t\t\tqueue_delayed_work(system_wq, &es8326->button_press_work, 10);\n\t\t\tgoto exit;\n\t\t}\n\t\tif ((iface & ES8326_HPBUTTON_FLAG) == 0x01) {\n\t\t\tdev_dbg(comp->dev, \"Headphone detected\\n\");\n\t\t\tsnd_soc_jack_report(es8326->jack,\n\t\t\t\t\tSND_JACK_HEADPHONE, SND_JACK_HEADSET);\n\t\t} else {\n\t\t\tdev_dbg(comp->dev, \"Headset detected\\n\");\n\t\t\tsnd_soc_jack_report(es8326->jack,\n\t\t\t\t\tSND_JACK_HEADSET, SND_JACK_HEADSET);\n\n\t\t\tregmap_write(es8326->regmap, ES8326_ADC_SCALE, 0x33);\n\t\t\tregmap_update_bits(es8326->regmap, ES8326_PGA_PDN,\n\t\t\t\t\t0x08, 0x08);\n\t\t\tregmap_update_bits(es8326->regmap, ES8326_PGAGAIN,\n\t\t\t\t\t0x80, 0x80);\n\t\t\tregmap_write(es8326->regmap, ES8326_ADC1_SRC, 0x00);\n\t\t\tregmap_write(es8326->regmap, ES8326_ADC2_SRC, 0x00);\n\t\t\tregmap_update_bits(es8326->regmap, ES8326_PGA_PDN,\n\t\t\t\t\t0x08, 0x00);\n\t\t\tusleep_range(10000, 15000);\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&es8326->lock);\n}\n\nstatic irqreturn_t es8326_irq(int irq, void *dev_id)\n{\n\tstruct es8326_priv *es8326 = dev_id;\n\tstruct snd_soc_component *comp = es8326->component;\n\n\tif (!es8326->jack)\n\t\tgoto out;\n\n\tes8326_enable_micbias(comp);\n\n\tif (es8326->jack->status & SND_JACK_HEADSET)\n\t\tqueue_delayed_work(system_wq, &es8326->jack_detect_work,\n\t\t\t\t   msecs_to_jiffies(10));\n\telse\n\t\tqueue_delayed_work(system_wq, &es8326->jack_detect_work,\n\t\t\t\t   msecs_to_jiffies(600));\n\nout:\n\treturn IRQ_HANDLED;\n}\n\nstatic int es8326_calibrate(struct snd_soc_component *component)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg;\n\tunsigned int offset_l, offset_r;\n\n\tregmap_read(es8326->regmap, ES8326_CHIP_VERSION, &reg);\n\tes8326->version = reg;\n\n\tif ((es8326->version == ES8326_VERSION_B) && (es8326->calibrated == false)) {\n\t\tdev_dbg(component->dev, \"ES8326_VERSION_B, calibrating\\n\");\n\t\tregmap_write(es8326->regmap, ES8326_CLK_INV, 0xc0);\n\t\tregmap_write(es8326->regmap, ES8326_CLK_DIV1, 0x01);\n\t\tregmap_write(es8326->regmap, ES8326_CLK_DLL, 0x30);\n\t\tregmap_write(es8326->regmap, ES8326_CLK_MUX, 0xed);\n\t\tregmap_write(es8326->regmap, ES8326_CLK_TRI, 0xc1);\n\t\tregmap_write(es8326->regmap, ES8326_DAC_MUTE, 0x03);\n\t\tregmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7f);\n\t\tregmap_write(es8326->regmap, ES8326_VMIDLOW, 0x33);\n\t\tregmap_write(es8326->regmap, ES8326_DAC2HPMIX, 0x88);\n\t\tregmap_write(es8326->regmap, ES8326_HP_VOL, 0x80);\n\t\tregmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);\n\t\tregmap_write(es8326->regmap, ES8326_RESET, 0xc0);\n\t\tusleep_range(15000, 20000);\n\n\t\tregmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, ES8326_HP_OFF);\n\t\tregmap_read(es8326->regmap, ES8326_CSM_MUTE_STA, &reg);\n\t\tif ((reg & 0xf0) != 0x40)\n\t\t\tmsleep(50);\n\n\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, 0xd4);\n\t\tmsleep(200);\n\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, 0x4d);\n\t\tmsleep(200);\n\t\tregmap_write(es8326->regmap, ES8326_HP_CAL, ES8326_HP_OFF);\n\t\tregmap_read(es8326->regmap, ES8326_HPL_OFFSET_INI, &offset_l);\n\t\tregmap_read(es8326->regmap, ES8326_HPR_OFFSET_INI, &offset_r);\n\t\tregmap_write(es8326->regmap, ES8326_HP_OFFSET_CAL, 0x8c);\n\t\tregmap_write(es8326->regmap, ES8326_HPL_OFFSET_INI, offset_l);\n\t\tregmap_write(es8326->regmap, ES8326_HPR_OFFSET_INI, offset_r);\n\t\tregmap_write(es8326->regmap, ES8326_CLK_INV, 0x00);\n\n\t\tes8326->calibrated = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int es8326_resume(struct snd_soc_component *component)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(es8326->regmap, false);\n\tregcache_sync(es8326->regmap);\n\n\t \n\tregmap_write(es8326->regmap, ES8326_RESET, 0x1f);\n\tregmap_write(es8326->regmap, ES8326_VMIDSEL, 0x0E);\n\tusleep_range(10000, 15000);\n\tregmap_write(es8326->regmap, ES8326_HPJACK_TIMER, 0x88);\n\t \n\tregmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x81);\n\tregmap_write(es8326->regmap, ES8326_CLK_RESAMPLE, 0x05);\n\n\t \n\tregmap_write(es8326->regmap, ES8326_CLK_DIV_CPC, 0x84);\n\tregmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_ON);\n\t \n\tregmap_write(es8326->regmap, ES8326_RESET, 0x17);\n\t \n\tregmap_write(es8326->regmap, ES8326_HP_MISC, 0x08);\n\tregmap_write(es8326->regmap, ES8326_PULLUP_CTL, 0x00);\n\n\t \n\tregmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa7);\n\tusleep_range(2000, 5000);\n\tregmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0xab);\n\tusleep_range(2000, 5000);\n\tregmap_write(es8326->regmap, ES8326_HP_DRIVER_REF, 0xbb);\n\tusleep_range(2000, 5000);\n\tregmap_write(es8326->regmap, ES8326_HP_DRIVER, 0xa1);\n\n\tregmap_write(es8326->regmap, ES8326_CLK_INV, 0x00);\n\tregmap_write(es8326->regmap, ES8326_CLK_VMIDS1, 0xc4);\n\tregmap_write(es8326->regmap, ES8326_CLK_VMIDS2, 0x81);\n\tregmap_write(es8326->regmap, ES8326_CLK_CAL_TIME, 0x00);\n\t \n\tes8326_calibrate(component);\n\t \n\tregmap_write(es8326->regmap, ES8326_HP_CAL, 0x00);\n\t \n\tregmap_write(es8326->regmap, ES8326_ANA_LP, 0xf0);\n\n\t \n\tregmap_write(es8326->regmap, ES8326_ANA_MICBIAS, 0x4f);\n\tregmap_write(es8326->regmap, ES8326_SYS_BIAS, 0x08);\n\tregmap_write(es8326->regmap, ES8326_ANA_VSEL, 0x7F);\n\t \n\tregmap_write(es8326->regmap, ES8326_VMIDLOW, 0x23);\n\t \n\tregmap_write(es8326->regmap, ES8326_DAC_DSM, 0x08);\n\tregmap_write(es8326->regmap, ES8326_DAC_VPPSCALE, 0x15);\n\n\tregmap_write(es8326->regmap, ES8326_INT_SOURCE,\n\t\t    (ES8326_INT_SRC_PIN9 | ES8326_INT_SRC_BUTTON));\n\tregmap_write(es8326->regmap, ES8326_INTOUT_IO,\n\t\t     es8326->interrupt_clk);\n\tregmap_write(es8326->regmap, ES8326_SDINOUT1_IO,\n\t\t    (ES8326_IO_DMIC_CLK << ES8326_SDINOUT1_SHIFT));\n\tregmap_write(es8326->regmap, ES8326_SDINOUT23_IO, ES8326_IO_INPUT);\n\n\tregmap_write(es8326->regmap, ES8326_ANA_PDN, 0x3b);\n\tregmap_write(es8326->regmap, ES8326_RESET, ES8326_CSM_ON);\n\tregmap_update_bits(es8326->regmap, ES8326_PGAGAIN, ES8326_MIC_SEL_MASK,\n\t\t\t   ES8326_MIC1_SEL);\n\n\tregmap_update_bits(es8326->regmap, ES8326_DAC_MUTE, ES8326_MUTE_MASK,\n\t\t\t   ES8326_MUTE);\n\n\tregmap_write(es8326->regmap, ES8326_HPDET_TYPE, 0x80 |\n\t\t\t((es8326->version == ES8326_VERSION_B) ?\n\t\t\t(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol) :\n\t\t\t(ES8326_HP_DET_SRC_PIN9 | es8326->jack_pol | 0x04)));\n\n\tes8326->jack_remove_retry = 0;\n\tes8326->hp = 0;\n\treturn 0;\n}\n\nstatic int es8326_suspend(struct snd_soc_component *component)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\n\tcancel_delayed_work_sync(&es8326->jack_detect_work);\n\tes8326_disable_micbias(component);\n\tes8326->calibrated = false;\n\tregmap_write(es8326->regmap, ES8326_CLK_CTL, ES8326_CLK_OFF);\n\tregcache_cache_only(es8326->regmap, true);\n\tregcache_mark_dirty(es8326->regmap);\n\n\t \n\tregmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x01);\n\tusleep_range(1000, 3000);\n\tregmap_write(es8326->regmap, ES8326_CSM_I2C_STA, 0x00);\n\treturn 0;\n}\n\nstatic int es8326_probe(struct snd_soc_component *component)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tes8326->component = component;\n\tes8326->jd_inverted = device_property_read_bool(component->dev,\n\t\t\t\t\t\t\t\"everest,jack-detect-inverted\");\n\n\tret = device_property_read_u8(component->dev, \"everest,mic1-src\", &es8326->mic1_src);\n\tif (ret != 0) {\n\t\tdev_dbg(component->dev, \"mic1-src return %d\", ret);\n\t\tes8326->mic1_src = ES8326_ADC_AMIC;\n\t}\n\tdev_dbg(component->dev, \"mic1-src %x\", es8326->mic1_src);\n\n\tret = device_property_read_u8(component->dev, \"everest,mic2-src\", &es8326->mic2_src);\n\tif (ret != 0) {\n\t\tdev_dbg(component->dev, \"mic2-src return %d\", ret);\n\t\tes8326->mic2_src = ES8326_ADC_DMIC;\n\t}\n\tdev_dbg(component->dev, \"mic2-src %x\", es8326->mic2_src);\n\n\tret = device_property_read_u8(component->dev, \"everest,jack-pol\", &es8326->jack_pol);\n\tif (ret != 0) {\n\t\tdev_dbg(component->dev, \"jack-pol return %d\", ret);\n\t\tes8326->jack_pol = ES8326_HP_TYPE_AUTO;\n\t}\n\tdev_dbg(component->dev, \"jack-pol %x\", es8326->jack_pol);\n\n\tret = device_property_read_u8(component->dev, \"everest,interrupt-src\",\n\t\t\t\t      &es8326->interrupt_src);\n\tif (ret != 0) {\n\t\tdev_dbg(component->dev, \"interrupt-src return %d\", ret);\n\t\tes8326->interrupt_src = ES8326_HP_DET_SRC_PIN9;\n\t}\n\tdev_dbg(component->dev, \"interrupt-src %x\", es8326->interrupt_src);\n\n\tret = device_property_read_u8(component->dev, \"everest,interrupt-clk\",\n\t\t\t\t      &es8326->interrupt_clk);\n\tif (ret != 0) {\n\t\tdev_dbg(component->dev, \"interrupt-clk return %d\", ret);\n\t\tes8326->interrupt_clk = 0x45;\n\t}\n\tdev_dbg(component->dev, \"interrupt-clk %x\", es8326->interrupt_clk);\n\n\tes8326_resume(component);\n\treturn 0;\n}\n\nstatic void es8326_enable_jack_detect(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_jack *jack)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&es8326->lock);\n\tif (es8326->jd_inverted)\n\t\tsnd_soc_component_update_bits(component, ES8326_HPDET_TYPE,\n\t\t\t\t\t      ES8326_HP_DET_JACK_POL, ~es8326->jack_pol);\n\tes8326->jack = jack;\n\n\tmutex_unlock(&es8326->lock);\n\tes8326_irq(es8326->irq, es8326);\n}\n\nstatic void es8326_disable_jack_detect(struct snd_soc_component *component)\n{\n\tstruct es8326_priv *es8326 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"Enter into %s\\n\", __func__);\n\tif (!es8326->jack)\n\t\treturn;  \n\tcancel_delayed_work_sync(&es8326->jack_detect_work);\n\n\tmutex_lock(&es8326->lock);\n\tif (es8326->jack->status & SND_JACK_MICROPHONE) {\n\t\tes8326_disable_micbias(component);\n\t\tsnd_soc_jack_report(es8326->jack, 0, SND_JACK_HEADSET);\n\t}\n\tes8326->jack = NULL;\n\tmutex_unlock(&es8326->lock);\n}\n\nstatic int es8326_set_jack(struct snd_soc_component *component,\n\t\t\tstruct snd_soc_jack *jack, void *data)\n{\n\tif (jack)\n\t\tes8326_enable_jack_detect(component, jack);\n\telse\n\t\tes8326_disable_jack_detect(component);\n\n\treturn 0;\n}\n\nstatic void es8326_remove(struct snd_soc_component *component)\n{\n\tes8326_disable_jack_detect(component);\n\tes8326_set_bias_level(component, SND_SOC_BIAS_OFF);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_es8326 = {\n\t.probe\t\t= es8326_probe,\n\t.remove\t\t= es8326_remove,\n\t.resume\t\t= es8326_resume,\n\t.suspend\t= es8326_suspend,\n\t.set_bias_level = es8326_set_bias_level,\n\t.set_jack\t= es8326_set_jack,\n\t.dapm_widgets\t= es8326_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(es8326_dapm_widgets),\n\t.dapm_routes\t\t= es8326_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(es8326_dapm_routes),\n\t.controls\t\t= es8326_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(es8326_snd_controls),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int es8326_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct es8326_priv *es8326;\n\tint ret;\n\n\tes8326 = devm_kzalloc(&i2c->dev, sizeof(struct es8326_priv), GFP_KERNEL);\n\tif (!es8326)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, es8326);\n\tes8326->i2c = i2c;\n\tmutex_init(&es8326->lock);\n\tes8326->regmap = devm_regmap_init_i2c(i2c, &es8326_regmap_config);\n\tif (IS_ERR(es8326->regmap)) {\n\t\tret = PTR_ERR(es8326->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tes8326->irq = i2c->irq;\n\tINIT_DELAYED_WORK(&es8326->jack_detect_work,\n\t\t\t  es8326_jack_detect_handler);\n\tINIT_DELAYED_WORK(&es8326->button_press_work,\n\t\t\t  es8326_jack_button_handler);\n\t \n\tret = devm_request_threaded_irq(&i2c->dev, es8326->irq, NULL, es8326_irq,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"es8326\", es8326);\n\tif (ret) {\n\t\tdev_warn(&i2c->dev, \"Failed to request IRQ: %d: %d\\n\",\n\t\tes8326->irq, ret);\n\t\tes8326->irq = -ENXIO;\n\t}\n\n\tes8326->mclk = devm_clk_get_optional(&i2c->dev, \"mclk\");\n\tif (IS_ERR(es8326->mclk)) {\n\t\tdev_err(&i2c->dev, \"unable to get mclk\\n\");\n\t\treturn PTR_ERR(es8326->mclk);\n\t}\n\tif (!es8326->mclk)\n\t\tdev_warn(&i2c->dev, \"assuming static mclk\\n\");\n\n\tret = clk_prepare_enable(es8326->mclk);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"unable to enable mclk\\n\");\n\t\treturn ret;\n\t}\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t&soc_component_dev_es8326,\n\t\t\t\t\t&es8326_dai, 1);\n}\n\nstatic const struct i2c_device_id es8326_i2c_id[] = {\n\t{\"es8326\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, es8326_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id es8326_of_match[] = {\n\t{ .compatible = \"everest,es8326\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, es8326_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id es8326_acpi_match[] = {\n\t{\"ESSX8326\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, es8326_acpi_match);\n#endif\n\nstatic struct i2c_driver es8326_i2c_driver = {\n\t.driver = {\n\t\t.name = \"es8326\",\n\t\t.acpi_match_table = ACPI_PTR(es8326_acpi_match),\n\t\t.of_match_table = of_match_ptr(es8326_of_match),\n\t},\n\t.probe = es8326_i2c_probe,\n\t.id_table = es8326_i2c_id,\n};\nmodule_i2c_driver(es8326_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC es8326 driver\");\nMODULE_AUTHOR(\"David Yang <yangxiaohua@everest-semi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}