{
  "module_name": "ak4375.c",
  "hash_id": "ba45d05116d1fc07f1df36c446444e9cf4e7abdfefc7bf9c531a55ea72c42ff9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4375.c",
  "human_readable_source": "\n\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n \n#define AK4375_00_POWER_MANAGEMENT1\t\t0x00\n#define PMPLL\t\t\t\t\tBIT(0)\t \n#define AK4375_01_POWER_MANAGEMENT2\t\t0x01\n#define PMCP1\t\t\t\t\tBIT(0)\t \n#define PMCP2\t\t\t\t\tBIT(1)\t \n#define PMLDO1P\t\t\t\t\tBIT(4)\n#define PMLDO1N\t\t\t\t\tBIT(5)\n#define PMLDO\t\t\t\t\t(PMLDO1P | PMLDO1N)\n#define AK4375_02_POWER_MANAGEMENT3\t\t0x02\n#define AK4375_03_POWER_MANAGEMENT4\t\t0x03\n#define AK4375_04_OUTPUT_MODE_SETTING\t\t0x04\n#define AK4375_05_CLOCK_MODE_SELECT\t\t0x05\n#define FS_MASK\t\t\t\t\tGENMASK(4, 0)\n#define FS_8KHZ\t\t\t\t\t0x00\n#define FS_11_025KHZ\t\t\t\t0x01\n#define FS_16KHZ\t\t\t\t0x04\n#define FS_22_05KHZ\t\t\t\t0x05\n#define FS_32KHZ\t\t\t\t0x08\n#define FS_44_1KHZ\t\t\t\t0x09\n#define FS_48KHZ\t\t\t\t0x0a\n#define FS_88_2KHZ\t\t\t\t0x0d\n#define FS_96KHZ\t\t\t\t0x0e\n#define FS_176_4KHZ\t\t\t\t0x11\n#define FS_192KHZ\t\t\t\t0x12\n#define CM_MASK\t\t\t\t\tGENMASK(6, 5)\t \n#define CM_0\t\t\t\t\t(0x0 << 5)\n#define CM_1\t\t\t\t\t(0x1 << 5)\n#define CM_2\t\t\t\t\t(0x2 << 5)\n#define CM_3\t\t\t\t\t(0x3 << 5)\n#define AK4375_06_DIGITAL_FILTER_SELECT\t\t0x06\n#define DADFSEL\t\t\t\t\tBIT(5)\t \n#define DASL\t\t\t\t\tBIT(6)\n#define DASD\t\t\t\t\tBIT(7)\n#define AK4375_07_DAC_MONO_MIXING\t\t0x07\n#define DACMUTE_MASK\t\t\t\t(GENMASK(5, 4) | GENMASK(1, 0))  \n#define AK4375_08_JITTER_CLEANER_SETTING1\t0x08\n#define AK4375_09_JITTER_CLEANER_SETTING2\t0x09\n#define AK4375_0A_JITTER_CLEANER_SETTING3\t0x0a\n#define SELDAIN\t\t\t\t\tBIT(1)\t \n#define XCKSEL\t\t\t\t\tBIT(6)\t \n#define XCKCPSEL\t\t\t\tBIT(7)\t \n#define AK4375_0B_LCH_OUTPUT_VOLUME\t\t0x0b\n#define AK4375_0C_RCH_OUTPUT_VOLUME\t\t0x0c\n#define AK4375_0D_HP_VOLUME_CONTROL\t\t0x0d\n#define AK4375_0E_PLL_CLK_SOURCE_SELECT\t\t0x0e\n#define PLS\t\t\t\t\tBIT(0)\t \n#define AK4375_0F_PLL_REF_CLK_DIVIDER1\t\t0x0f\t \n#define AK4375_10_PLL_REF_CLK_DIVIDER2\t\t0x10\t \n#define AK4375_11_PLL_FB_CLK_DIVIDER1\t\t0x11\t \n#define AK4375_12_PLL_FB_CLK_DIVIDER2\t\t0x12\t \n#define AK4375_13_SRC_CLK_SOURCE\t\t0x13\t \n#define SRCCKS\t\t\t\t\tBIT(0)\t \n#define DIV\t\t\t\t\tBIT(4)\n#define AK4375_14_DAC_CLK_DIVIDER\t\t0x14\n#define AK4375_15_AUDIO_IF_FORMAT\t\t0x15\n#define DEVICEID_MASK\t\t\t\tGENMASK(7, 5)\n#define AK4375_24_MODE_CONTROL\t\t\t0x24\n\n#define AK4375_PLL_FREQ_OUT_112896000\t\t112896000\t \n#define AK4375_PLL_FREQ_OUT_122880000\t\t122880000\t \n\n#define DEVICEID_AK4375\t\t\t\t0x00\n#define DEVICEID_AK4375A\t\t\t0x01\n#define DEVICEID_AK4376A\t\t\t0x02\n#define DEVICEID_AK4377\t\t\t\t0x03\n#define DEVICEID_AK4331\t\t\t\t0x07\n\nstatic const char * const supply_names[] = {\n\t\"avdd\", \"tvdd\"\n};\n\nstruct ak4375_drvdata {\n\tstruct snd_soc_dai_driver *dai_drv;\n\tconst struct snd_soc_component_driver *comp_drv;\n};\n\nstruct ak4375_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *pdn_gpiod;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n\tunsigned int rate;\n\tunsigned int pld;\n\tu8 mute_save;\n};\n\nstatic const struct reg_default ak4375_reg_defaults[] = {\n\t{ 0x00, 0x00 }, { 0x01, 0x00 }, { 0x02, 0x00 },\n\t{ 0x03, 0x00 }, { 0x04, 0x00 }, { 0x05, 0x00 },\n\t{ 0x06, 0x00 }, { 0x07, 0x00 }, { 0x08, 0x00 },\n\t{ 0x09, 0x00 }, { 0x0a, 0x00 }, { 0x0b, 0x19 },\n\t{ 0x0c, 0x19 }, { 0x0d, 0x75 }, { 0x0e, 0x01 },\n\t{ 0x0f, 0x00 }, { 0x10, 0x00 }, { 0x11, 0x00 },\n\t{ 0x12, 0x00 }, { 0x13, 0x00 }, { 0x14, 0x00 },\n\t{ 0x15, 0x00 }, { 0x24, 0x00 },\n};\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -1250, 50, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(hpg_tlv, -4200, 20, 0);\n\nstatic const char * const ak4375_ovolcn_select_texts[]\t= { \"Dependent\", \"Independent\" };\nstatic const char * const ak4375_mdac_select_texts[]\t= { \"x1\", \"x1/2\" };\nstatic const char * const ak4375_cpmode_select_texts[]\t= {\n\t\"Automatic Switching\",\n\t\"+-VDD Operation\",\n\t\"+-1/2VDD Operation\"\n};\n\n \nstatic const char * const ak4375_digfil_select_texts[] = {\n\t\"Sharp Roll-Off Filter\",\n\t\"Slow Roll-Off Filter\",\n\t\"Short delay Sharp Roll-Off Filter\",\n\t\"Short delay Slow Roll-Off Filter\",\n};\n\nstatic const struct soc_enum ak4375_ovolcn_enum =\n\tSOC_ENUM_SINGLE(AK4375_0B_LCH_OUTPUT_VOLUME, 7,\n\t\t\tARRAY_SIZE(ak4375_ovolcn_select_texts), ak4375_ovolcn_select_texts);\nstatic const struct soc_enum ak4375_mdacl_enum =\n\tSOC_ENUM_SINGLE(AK4375_07_DAC_MONO_MIXING, 2,\n\t\t\tARRAY_SIZE(ak4375_mdac_select_texts), ak4375_mdac_select_texts);\nstatic const struct soc_enum ak4375_mdacr_enum =\n\tSOC_ENUM_SINGLE(AK4375_07_DAC_MONO_MIXING, 6,\n\t\t\tARRAY_SIZE(ak4375_mdac_select_texts), ak4375_mdac_select_texts);\nstatic const struct soc_enum ak4375_cpmode_enum =\n\tSOC_ENUM_SINGLE(AK4375_03_POWER_MANAGEMENT4, 2,\n\t\t\tARRAY_SIZE(ak4375_cpmode_select_texts), ak4375_cpmode_select_texts);\nstatic const struct soc_enum ak4375_digfil_enum =\n\tSOC_ENUM_SINGLE(AK4375_06_DIGITAL_FILTER_SELECT, 6,\n\t\t\tARRAY_SIZE(ak4375_digfil_select_texts), ak4375_digfil_select_texts);\n\nstatic const struct snd_kcontrol_new ak4375_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Digital Output Volume\", AK4375_0B_LCH_OUTPUT_VOLUME,\n\t\t\t AK4375_0C_RCH_OUTPUT_VOLUME, 0, 0x1f, 0, dac_tlv),\n\tSOC_SINGLE_TLV(\"HP-Amp Analog Volume\",\n\t\t       AK4375_0D_HP_VOLUME_CONTROL, 0, 0x1f, 0, hpg_tlv),\n\n\tSOC_DOUBLE(\"DAC Signal Invert Switch\", AK4375_07_DAC_MONO_MIXING, 3, 7, 1, 0),\n\n\tSOC_ENUM(\"Digital Volume Control\", ak4375_ovolcn_enum),\n\tSOC_ENUM(\"DACL Signal Level\", ak4375_mdacl_enum),\n\tSOC_ENUM(\"DACR Signal Level\", ak4375_mdacr_enum),\n\tSOC_ENUM(\"Charge Pump Mode\", ak4375_cpmode_enum),\n\tSOC_ENUM(\"DAC Digital Filter Mode\", ak4375_digfil_enum),\n};\n\nstatic const struct snd_kcontrol_new ak4375_hpl_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"LDACL Switch\", AK4375_07_DAC_MONO_MIXING, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"RDACL Switch\", AK4375_07_DAC_MONO_MIXING, 1, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new ak4375_hpr_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"LDACR Switch\", AK4375_07_DAC_MONO_MIXING, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"RDACR Switch\", AK4375_07_DAC_MONO_MIXING, 5, 1, 0),\n};\n\nstatic int ak4375_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, AK4375_00_POWER_MANAGEMENT1, PMPLL, PMPLL);\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMCP1, PMCP1);\n\t\tusleep_range(6500, 7000);\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMLDO, PMLDO);\n\t\tusleep_range(1000, 2000);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMCP2, PMCP2);\n\t\tusleep_range(4500, 5000);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMCP2, 0x0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMLDO, 0x0);\n\t\tsnd_soc_component_update_bits(component, AK4375_01_POWER_MANAGEMENT2, PMCP1, 0x0);\n\t\tsnd_soc_component_update_bits(component, AK4375_00_POWER_MANAGEMENT1, PMPLL, 0x0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget ak4375_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, AK4375_02_POWER_MANAGEMENT3, 0, 0, ak4375_dac_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_AIF_IN(\"SDTI\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\n\tSND_SOC_DAPM_MIXER(\"HPR Mixer\", AK4375_03_POWER_MANAGEMENT4, 1, 0,\n\t\t\t   &ak4375_hpr_mixer_controls[0], ARRAY_SIZE(ak4375_hpr_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"HPL Mixer\", AK4375_03_POWER_MANAGEMENT4, 0, 0,\n\t\t\t   &ak4375_hpl_mixer_controls[0], ARRAY_SIZE(ak4375_hpl_mixer_controls)),\n};\n\nstatic const struct snd_soc_dapm_route ak4375_intercon[] = {\n\t{ \"DAC\",\tNULL,\t\t\"SDTI\" },\n\n\t{ \"HPL Mixer\",\t\"LDACL Switch\",\t\"DAC\" },\n\t{ \"HPL Mixer\",\t\"RDACL Switch\",\t\"DAC\" },\n\t{ \"HPR Mixer\",\t\"LDACR Switch\",\t\"DAC\" },\n\t{ \"HPR Mixer\",\t\"RDACR Switch\",\t\"DAC\" },\n\n\t{ \"HPL\",\tNULL,\t\t\"HPL Mixer\" },\n\t{ \"HPR\",\tNULL,\t\t\"HPR Mixer\" },\n};\n\nstatic int ak4375_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4375_priv *ak4375 = snd_soc_component_get_drvdata(component);\n\tunsigned int freq_in, freq_out;\n\n\tak4375->rate = params_rate(params);\n\n\tif (ak4375->rate <= 96000)\n\t\tak4375->pld = 0;\n\telse\n\t\tak4375->pld = 1;\n\n\tfreq_in = 32 * ak4375->rate / (ak4375->pld + 1);\n\n\tif ((ak4375->rate % 8000) == 0)\n\t\tfreq_out = AK4375_PLL_FREQ_OUT_122880000;\n\telse\n\t\tfreq_out = AK4375_PLL_FREQ_OUT_112896000;\n\n\treturn snd_soc_dai_set_pll(dai, 0, 0, freq_in, freq_out);\n}\n\nstatic int ak4375_dai_set_pll(struct snd_soc_dai *dai, int pll_id, int source,\n\t\t\t      unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4375_priv *ak4375 = snd_soc_component_get_drvdata(component);\n\tunsigned int mclk, plm, mdiv, div;\n\tu8 cms, fs, cm;\n\n\tcms = snd_soc_component_read(component, AK4375_05_CLOCK_MODE_SELECT);\n\tfs = cms & ~FS_MASK;\n\tcm = cms & ~CM_MASK;\n\n\tswitch (ak4375->rate) {\n\tcase 8000:\n\t\tfs |= FS_8KHZ;\n\t\tbreak;\n\tcase 11025:\n\t\tfs |= FS_11_025KHZ;\n\t\tbreak;\n\tcase 16000:\n\t\tfs |= FS_16KHZ;\n\t\tbreak;\n\tcase 22050:\n\t\tfs |= FS_22_05KHZ;\n\t\tbreak;\n\tcase 32000:\n\t\tfs |= FS_32KHZ;\n\t\tbreak;\n\tcase 44100:\n\t\tfs |= FS_44_1KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tfs |= FS_48KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tfs |= FS_88_2KHZ;\n\t\tbreak;\n\tcase 96000:\n\t\tfs |= FS_96KHZ;\n\t\tbreak;\n\tcase 176400:\n\t\tfs |= FS_176_4KHZ;\n\t\tbreak;\n\tcase 192000:\n\t\tfs |= FS_192KHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ak4375->rate <= 24000) {\n\t\tcm |= CM_1;\n\t\tmclk = 512 * ak4375->rate;\n\t\tmdiv = freq_out / mclk - 1;\n\t\tdiv = 0;\n\t} else if (ak4375->rate <= 96000) {\n\t\tcm |= CM_0;\n\t\tmclk = 256 * ak4375->rate;\n\t\tmdiv = freq_out / mclk - 1;\n\t\tdiv = 0;\n\t} else {\n\t\tcm |= CM_3;\n\t\tmclk = 128 * ak4375->rate;\n\t\tmdiv = 4;\n\t\tdiv = 1;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, AK4375_05_CLOCK_MODE_SELECT, FS_MASK, fs);\n\tsnd_soc_component_update_bits(component, AK4375_05_CLOCK_MODE_SELECT, CM_MASK, cm);\n\n\tsnd_soc_component_write(component, AK4375_0F_PLL_REF_CLK_DIVIDER1,\n\t\t\t\t(ak4375->pld & 0xff00) >> 8);\n\tsnd_soc_component_write(component, AK4375_10_PLL_REF_CLK_DIVIDER2,\n\t\t\t\tak4375->pld & 0x00ff);\n\n\tplm = freq_out / freq_in - 1;\n\tsnd_soc_component_write(component, AK4375_11_PLL_FB_CLK_DIVIDER1, (plm & 0xff00) >> 8);\n\tsnd_soc_component_write(component, AK4375_12_PLL_FB_CLK_DIVIDER2, plm & 0x00ff);\n\n\tsnd_soc_component_update_bits(component, AK4375_13_SRC_CLK_SOURCE, DIV, div);\n\n\t \n\tsnd_soc_component_update_bits(component, AK4375_13_SRC_CLK_SOURCE, SRCCKS, SRCCKS);\n\n\tsnd_soc_component_write(component, AK4375_14_DAC_CLK_DIVIDER, mdiv);\n\n\tdev_dbg(ak4375->dev, \"rate=%d mclk=%d f_in=%d f_out=%d PLD=%d PLM=%d MDIV=%d DIV=%d\\n\",\n\t\tak4375->rate, mclk, freq_in, freq_out, ak4375->pld, plm, mdiv, div);\n\n\treturn 0;\n}\n\nstatic int ak4375_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4375_priv *ak4375 = snd_soc_component_get_drvdata(component);\n\tu8 val = snd_soc_component_read(component, AK4375_07_DAC_MONO_MIXING);\n\n\tdev_dbg(ak4375->dev, \"mute=%d val=%d\\n\", mute, val);\n\n\tif (mute) {\n\t\tak4375->mute_save = val & DACMUTE_MASK;\n\t\tval &= ~DACMUTE_MASK;\n\t} else {\n\t\tval |= ak4375->mute_save;\n\t}\n\n\tsnd_soc_component_write(component, AK4375_07_DAC_MONO_MIXING, val);\n\n\treturn 0;\n}\n\n#define AK4375_RATES\t(SNDRV_PCM_RATE_8000_48000 |\\\n\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\\\n\t\t\t SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)\n\n#define AK4375_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops ak4375_dai_ops = {\n\t.hw_params\t= ak4375_hw_params,\n\t.mute_stream\t= ak4375_mute,\n\t.set_pll\t= ak4375_dai_set_pll,\n};\n\nstatic struct snd_soc_dai_driver ak4375_dai = {\n\t.name = \"ak4375-hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"HiFi Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= AK4375_RATES,\n\t\t.rate_min\t= 8000,\n\t\t.rate_max\t= 192000,\n\t\t.formats\t= AK4375_FORMATS,\n\t},\n\t.ops = &ak4375_dai_ops,\n};\n\nstatic void ak4375_power_off(struct ak4375_priv *ak4375)\n{\n\tgpiod_set_value_cansleep(ak4375->pdn_gpiod, 0);\n\tusleep_range(1000, 2000);\n\n\tregulator_bulk_disable(ARRAY_SIZE(ak4375->supplies), ak4375->supplies);\n}\n\nstatic int ak4375_power_on(struct ak4375_priv *ak4375)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ak4375->supplies), ak4375->supplies);\n\tif (ret < 0) {\n\t\tdev_err(ak4375->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tusleep_range(3000, 4000);\n\n\tgpiod_set_value_cansleep(ak4375->pdn_gpiod, 1);\n\tusleep_range(1000, 2000);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ak4375_runtime_suspend(struct device *dev)\n{\n\tstruct ak4375_priv *ak4375 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(ak4375->regmap, true);\n\tak4375_power_off(ak4375);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ak4375_runtime_resume(struct device *dev)\n{\n\tstruct ak4375_priv *ak4375 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ak4375_power_on(ak4375);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_cache_only(ak4375->regmap, false);\n\tregcache_mark_dirty(ak4375->regmap);\n\n\treturn regcache_sync(ak4375->regmap);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_ak4375 = {\n\t.controls\t\t= ak4375_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4375_snd_controls),\n\t.dapm_widgets\t\t= ak4375_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4375_dapm_widgets),\n\t.dapm_routes\t\t= ak4375_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4375_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4375_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= AK4375_24_MODE_CONTROL,\n\t.reg_defaults\t\t= ak4375_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(ak4375_reg_defaults),\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct ak4375_drvdata ak4375_drvdata = {\n\t.dai_drv = &ak4375_dai,\n\t.comp_drv = &soc_codec_dev_ak4375,\n};\n\nstatic const struct dev_pm_ops ak4375_pm = {\n\tSET_RUNTIME_PM_OPS(ak4375_runtime_suspend, ak4375_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic int ak4375_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak4375_priv *ak4375;\n\tconst struct ak4375_drvdata *drvdata;\n\tunsigned int deviceid;\n\tint ret, i;\n\n\tak4375 = devm_kzalloc(&i2c->dev, sizeof(*ak4375), GFP_KERNEL);\n\tif (!ak4375)\n\t\treturn -ENOMEM;\n\n\tak4375->regmap = devm_regmap_init_i2c(i2c, &ak4375_regmap);\n\tif (IS_ERR(ak4375->regmap))\n\t\treturn PTR_ERR(ak4375->regmap);\n\n\ti2c_set_clientdata(i2c, ak4375);\n\tak4375->dev = &i2c->dev;\n\n\tdrvdata = of_device_get_match_data(&i2c->dev);\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tak4375->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(ak4375->dev, ARRAY_SIZE(ak4375->supplies), ak4375->supplies);\n\tif (ret < 0) {\n\t\tdev_err(ak4375->dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tak4375->pdn_gpiod = devm_gpiod_get_optional(ak4375->dev, \"pdn\", GPIOD_OUT_LOW);\n\tif (IS_ERR(ak4375->pdn_gpiod))\n\t\treturn dev_err_probe(ak4375->dev, PTR_ERR(ak4375->pdn_gpiod),\n\t\t\t\t     \"failed to get pdn\\n\");\n\n\tret = ak4375_power_on(ak4375);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tregcache_cache_bypass(ak4375->regmap, true);\n\n\tret = regmap_read(ak4375->regmap, AK4375_15_AUDIO_IF_FORMAT, &deviceid);\n\tif (ret < 0) {\n\t\tdev_err(ak4375->dev, \"unable to read DEVICEID!\\n\");\n\t\treturn ret;\n\t}\n\n\tregcache_cache_bypass(ak4375->regmap, false);\n\n\tdeviceid = (deviceid & DEVICEID_MASK) >> 5;\n\n\tswitch (deviceid) {\n\tcase DEVICEID_AK4331:\n\t\tdev_err(ak4375->dev, \"found untested AK4331\\n\");\n\t\treturn -EINVAL;\n\tcase DEVICEID_AK4375:\n\t\tdev_dbg(ak4375->dev, \"found AK4375\\n\");\n\t\tbreak;\n\tcase DEVICEID_AK4375A:\n\t\tdev_dbg(ak4375->dev, \"found AK4375A\\n\");\n\t\tbreak;\n\tcase DEVICEID_AK4376A:\n\t\tdev_err(ak4375->dev, \"found unsupported AK4376/A!\\n\");\n\t\treturn -EINVAL;\n\tcase DEVICEID_AK4377:\n\t\tdev_err(ak4375->dev, \"found unsupported AK4377!\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tdev_err(ak4375->dev, \"unrecognized DEVICEID!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpm_runtime_set_active(ak4375->dev);\n\tpm_runtime_enable(ak4375->dev);\n\n\tret = devm_snd_soc_register_component(ak4375->dev, drvdata->comp_drv,\n\t\t\t\t\t      drvdata->dai_drv, 1);\n\tif (ret < 0) {\n\t\tdev_err(ak4375->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ak4375_i2c_remove(struct i2c_client *i2c)\n{\n\tpm_runtime_disable(&i2c->dev);\n}\n\nstatic const struct of_device_id ak4375_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4375\", .data = &ak4375_drvdata },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ak4375_of_match);\n\nstatic struct i2c_driver ak4375_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4375\",\n\t\t.pm = &ak4375_pm,\n\t\t.of_match_table = ak4375_of_match,\n\t},\n\t.probe = ak4375_i2c_probe,\n\t.remove = ak4375_i2c_remove,\n};\nmodule_i2c_driver(ak4375_i2c_driver);\n\nMODULE_AUTHOR(\"Vincent Knecht <vincent.knecht@mailoo.org>\");\nMODULE_DESCRIPTION(\"ASoC AK4375 DAC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}