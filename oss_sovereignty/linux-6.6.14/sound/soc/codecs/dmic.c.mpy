{
  "module_name": "dmic.c",
  "hash_id": "a2b44d0954e2721d89d0752dd3bb8c2c8544ad44784b70b6cda63e7a412244db",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/dmic.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n#define MAX_MODESWITCH_DELAY 70\nstatic int modeswitch_delay;\nmodule_param(modeswitch_delay, uint, 0644);\n\nstatic int wakeup_delay;\nmodule_param(wakeup_delay, uint, 0644);\n\nstruct dmic {\n\tstruct gpio_desc *gpio_en;\n\tint wakeup_delay;\n\t \n\tint modeswitch_delay;\n};\n\nstatic int dmic_daiops_trigger(struct snd_pcm_substream *substream,\n\t\t\t       int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct dmic *dmic = snd_soc_component_get_drvdata(component);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (dmic->modeswitch_delay)\n\t\t\tmdelay(dmic->modeswitch_delay);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops dmic_dai_ops = {\n\t.trigger\t= dmic_daiops_trigger,\n};\n\nstatic int dmic_aif_event(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol, int event) {\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct dmic *dmic = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (dmic->gpio_en)\n\t\t\tgpiod_set_value_cansleep(dmic->gpio_en, 1);\n\n\t\tif (dmic->wakeup_delay)\n\t\t\tmsleep(dmic->wakeup_delay);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (dmic->gpio_en)\n\t\t\tgpiod_set_value_cansleep(dmic->gpio_en, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct snd_soc_dai_driver dmic_dai = {\n\t.name = \"dmic-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE\n\t\t\t| SNDRV_PCM_FMTBIT_S24_LE\n\t\t\t| SNDRV_PCM_FMTBIT_S16_LE\n\t\t\t| SNDRV_PCM_FMTBIT_DSD_U8\n\t\t\t| SNDRV_PCM_FMTBIT_DSD_U16_LE\n\t\t\t| SNDRV_PCM_FMTBIT_DSD_U32_LE,\n\t},\n\t.ops    = &dmic_dai_ops,\n};\n\nstatic int dmic_component_probe(struct snd_soc_component *component)\n{\n\tstruct dmic *dmic;\n\n\tdmic = devm_kzalloc(component->dev, sizeof(*dmic), GFP_KERNEL);\n\tif (!dmic)\n\t\treturn -ENOMEM;\n\n\tdmic->gpio_en = devm_gpiod_get_optional(component->dev,\n\t\t\t\t\t\t\"dmicen\", GPIOD_OUT_LOW);\n\tif (IS_ERR(dmic->gpio_en))\n\t\treturn PTR_ERR(dmic->gpio_en);\n\n\tdevice_property_read_u32(component->dev, \"wakeup-delay-ms\",\n\t\t\t\t &dmic->wakeup_delay);\n\tdevice_property_read_u32(component->dev, \"modeswitch-delay-ms\",\n\t\t\t\t &dmic->modeswitch_delay);\n\tif (wakeup_delay)\n\t\tdmic->wakeup_delay  = wakeup_delay;\n\tif (modeswitch_delay)\n\t\tdmic->modeswitch_delay  = modeswitch_delay;\n\n\tif (dmic->modeswitch_delay > MAX_MODESWITCH_DELAY)\n\t\tdmic->modeswitch_delay = MAX_MODESWITCH_DELAY;\n\n\tsnd_soc_component_set_drvdata(component, dmic);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget dmic_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_OUT_E(\"DMIC AIF\", \"Capture\", 0,\n\t\t\t       SND_SOC_NOPM, 0, 0, dmic_aif_event,\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_INPUT(\"DMic\"),\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t{\"DMIC AIF\", NULL, \"DMic\"},\n};\n\nstatic const struct snd_soc_component_driver soc_dmic = {\n\t.probe\t\t\t= dmic_component_probe,\n\t.dapm_widgets\t\t= dmic_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(dmic_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int dmic_dev_probe(struct platform_device *pdev)\n{\n\tint err;\n\tu32 chans;\n\tstruct snd_soc_dai_driver *dai_drv = &dmic_dai;\n\n\tif (pdev->dev.of_node) {\n\t\terr = of_property_read_u32(pdev->dev.of_node, \"num-channels\", &chans);\n\t\tif (err && (err != -EINVAL))\n\t\t\treturn err;\n\n\t\tif (!err) {\n\t\t\tif (chans < 1 || chans > 8)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdai_drv = devm_kzalloc(&pdev->dev, sizeof(*dai_drv), GFP_KERNEL);\n\t\t\tif (!dai_drv)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tmemcpy(dai_drv, &dmic_dai, sizeof(*dai_drv));\n\t\t\tdai_drv->capture.channels_max = chans;\n\t\t}\n\t}\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_dmic, dai_drv, 1);\n}\n\nMODULE_ALIAS(\"platform:dmic-codec\");\n\nstatic const struct of_device_id dmic_dev_match[] = {\n\t{.compatible = \"dmic-codec\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dmic_dev_match);\n\nstatic struct platform_driver dmic_driver = {\n\t.driver = {\n\t\t.name = \"dmic-codec\",\n\t\t.of_match_table = dmic_dev_match,\n\t},\n\t.probe = dmic_dev_probe,\n};\n\nmodule_platform_driver(dmic_driver);\n\nMODULE_DESCRIPTION(\"Generic DMIC driver\");\nMODULE_AUTHOR(\"Liam Girdwood <lrg@slimlogic.co.uk>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}