{
  "module_name": "tas571x.c",
  "hash_id": "20e9c24ecf07a961acdb26d71302553942b03f43a79b0db70b6754c1662ae2fc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas571x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/stddef.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <asm/unaligned.h>\n\n#include \"tas571x.h\"\n\n#define TAS571X_MAX_SUPPLIES\t\t6\n\nstruct tas571x_chip {\n\tconst char\t\t\t*const *supply_names;\n\tint\t\t\t\tnum_supply_names;\n\tconst struct snd_kcontrol_new\t*controls;\n\tint\t\t\t\tnum_controls;\n\tconst struct regmap_config\t*regmap_config;\n\tint\t\t\t\tvol_reg_size;\n};\n\nstruct tas571x_private {\n\tconst struct tas571x_chip\t*chip;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regulator_bulk_data\tsupplies[TAS571X_MAX_SUPPLIES];\n\tstruct clk\t\t\t*mclk;\n\tunsigned int\t\t\tformat;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct gpio_desc\t\t*pdn_gpio;\n\tstruct snd_soc_component_driver\tcomponent_driver;\n};\n\nstatic int tas571x_register_size(struct tas571x_private *priv, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS571X_MVOL_REG:\n\tcase TAS571X_CH1_VOL_REG:\n\tcase TAS571X_CH2_VOL_REG:\n\t\treturn priv->chip->vol_reg_size;\n\tcase TAS571X_INPUT_MUX_REG:\n\tcase TAS571X_CH4_SRC_SELECT_REG:\n\tcase TAS571X_PWM_MUX_REG:\n\tcase TAS5717_CH1_RIGHT_CH_MIX_REG:\n\tcase TAS5717_CH1_LEFT_CH_MIX_REG:\n\tcase TAS5717_CH2_LEFT_CH_MIX_REG:\n\tcase TAS5717_CH2_RIGHT_CH_MIX_REG:\n\t\treturn 4;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int tas571x_reg_write(void *context, unsigned int reg,\n\t\t\t     unsigned int value)\n{\n\tstruct i2c_client *client = context;\n\tstruct tas571x_private *priv = i2c_get_clientdata(client);\n\tunsigned int i, size;\n\tuint8_t buf[5];\n\tint ret;\n\n\tsize = tas571x_register_size(priv, reg);\n\tbuf[0] = reg;\n\n\tfor (i = size; i >= 1; --i) {\n\t\tbuf[i] = value;\n\t\tvalue >>= 8;\n\t}\n\n\tret = i2c_master_send(client, buf, size + 1);\n\tif (ret == size + 1)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int tas571x_reg_read(void *context, unsigned int reg,\n\t\t\t    unsigned int *value)\n{\n\tstruct i2c_client *client = context;\n\tstruct tas571x_private *priv = i2c_get_clientdata(client);\n\tuint8_t send_buf, recv_buf[4];\n\tstruct i2c_msg msgs[2];\n\tunsigned int size;\n\tunsigned int i;\n\tint ret;\n\n\tsize = tas571x_register_size(priv, reg);\n\tsend_buf = reg;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].len = sizeof(send_buf);\n\tmsgs[0].buf = &send_buf;\n\tmsgs[0].flags = 0;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].len = size;\n\tmsgs[1].buf = recv_buf;\n\tmsgs[1].flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\t*value = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\t*value <<= 8;\n\t\t*value |= recv_buf[i];\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tas571x_reg_write_multiword(struct i2c_client *client,\n\t\tunsigned int reg, const long values[], size_t len)\n{\n\tsize_t i;\n\tuint8_t *buf, *p;\n\tint ret;\n\tsize_t send_size = 1 + len * sizeof(uint32_t);\n\n\tbuf = kzalloc(send_size, GFP_KERNEL | GFP_DMA);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[0] = reg;\n\n\tfor (i = 0, p = buf + 1; i < len; i++, p += sizeof(uint32_t))\n\t\tput_unaligned_be32(values[i], p);\n\n\tret = i2c_master_send(client, buf, send_size);\n\n\tkfree(buf);\n\n\tif (ret == send_size)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\n \nstatic int tas571x_reg_read_multiword(struct i2c_client *client,\n\t\tunsigned int reg, long values[], size_t len)\n{\n\tunsigned int i;\n\tuint8_t send_buf;\n\tuint8_t *recv_buf, *p;\n\tstruct i2c_msg msgs[2];\n\tunsigned int recv_size = len * sizeof(uint32_t);\n\tint ret;\n\n\trecv_buf = kzalloc(recv_size, GFP_KERNEL | GFP_DMA);\n\tif (!recv_buf)\n\t\treturn -ENOMEM;\n\n\tsend_buf = reg;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].len = sizeof(send_buf);\n\tmsgs[0].buf = &send_buf;\n\tmsgs[0].flags = 0;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].len = recv_size;\n\tmsgs[1].buf = recv_buf;\n\tmsgs[1].flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\tgoto err_ret;\n\telse if (ret != ARRAY_SIZE(msgs)) {\n\t\tret = -EIO;\n\t\tgoto err_ret;\n\t}\n\n\tfor (i = 0, p = recv_buf; i < len; i++, p += sizeof(uint32_t))\n\t\tvalues[i] = get_unaligned_be32(p);\n\nerr_ret:\n\tkfree(recv_buf);\n\treturn ret;\n}\n\n \n\nstatic int tas571x_coefficient_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint numcoef = kcontrol->private_value >> 16;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = numcoef;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 0xffffffff;\n\treturn 0;\n}\n\nstatic int tas571x_coefficient_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct i2c_client *i2c = to_i2c_client(component->dev);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\n\treturn tas571x_reg_read_multiword(i2c, index,\n\t\tucontrol->value.integer.value, numcoef);\n}\n\nstatic int tas571x_coefficient_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct i2c_client *i2c = to_i2c_client(component->dev);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\n\treturn tas571x_reg_write_multiword(i2c, index,\n\t\tucontrol->value.integer.value, numcoef);\n}\n\nstatic int tas571x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int format)\n{\n\tstruct tas571x_private *priv = snd_soc_component_get_drvdata(dai->component);\n\n\tpriv->format = format;\n\n\treturn 0;\n}\n\nstatic int tas571x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct tas571x_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tu32 val;\n\n\tswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = 0x03;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = 0x06;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (params_width(params) >= 24)\n\t\tval += 2;\n\telse if (params_width(params) >= 20)\n\t\tval += 1;\n\n\treturn regmap_update_bits(priv->regmap, TAS571X_SDI_REG,\n\t\t\t\t  TAS571X_SDI_FMT_MASK, val);\n}\n\nstatic int tas571x_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 sysctl2;\n\tint ret;\n\n\tsysctl2 = mute ? TAS571X_SYS_CTRL_2_SDN_MASK : 0;\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\t    TAS571X_SYS_CTRL_2_REG,\n\t\t     TAS571X_SYS_CTRL_2_SDN_MASK,\n\t\t     sysctl2);\n\tusleep_range(1000, 2000);\n\n\treturn ret;\n}\n\nstatic int tas571x_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct tas571x_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tif (!IS_ERR(priv->mclk)) {\n\t\t\t\tret = clk_prepare_enable(priv->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable master clock: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (!IS_ERR(priv->mclk))\n\t\t\tclk_disable_unprepare(priv->mclk);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tas571x_dai_ops = {\n\t.set_fmt\t= tas571x_set_dai_fmt,\n\t.hw_params\t= tas571x_hw_params,\n\t.mute_stream\t= tas571x_mute,\n\t.no_capture_mute = 1,\n};\n\n\n#define BIQUAD_COEFS(xname, reg) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = tas571x_coefficient_info, \\\n\t.get = tas571x_coefficient_get,\\\n\t.put = tas571x_coefficient_put, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.private_value = reg | (5 << 16) }\n\nstatic const char *const tas5711_supply_names[] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"PVDD_A\",\n\t\"PVDD_B\",\n\t\"PVDD_C\",\n\t\"PVDD_D\",\n};\n\nstatic const DECLARE_TLV_DB_SCALE(tas5711_volume_tlv, -10350, 50, 1);\n\nstatic const struct snd_kcontrol_new tas5711_controls[] = {\n\tSOC_SINGLE_TLV(\"Master Volume\",\n\t\t       TAS571X_MVOL_REG,\n\t\t       0, 0xff, 1, tas5711_volume_tlv),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\t\t TAS571X_CH1_VOL_REG,\n\t\t\t TAS571X_CH2_VOL_REG,\n\t\t\t 0, 0xff, 1, tas5711_volume_tlv),\n\tSOC_DOUBLE(\"Speaker Switch\",\n\t\t   TAS571X_SOFT_MUTE_REG,\n\t\t   TAS571X_SOFT_MUTE_CH1_SHIFT, TAS571X_SOFT_MUTE_CH2_SHIFT,\n\t\t   1, 1),\n};\n\nstatic const struct regmap_range tas571x_readonly_regs_range[] = {\n\tregmap_reg_range(TAS571X_CLK_CTRL_REG,  TAS571X_DEV_ID_REG),\n};\n\nstatic const struct regmap_range tas571x_volatile_regs_range[] = {\n\tregmap_reg_range(TAS571X_CLK_CTRL_REG,  TAS571X_ERR_STATUS_REG),\n\tregmap_reg_range(TAS571X_OSC_TRIM_REG,  TAS571X_OSC_TRIM_REG),\n};\n\nstatic const struct regmap_access_table tas571x_write_regs = {\n\t.no_ranges =\ttas571x_readonly_regs_range,\n\t.n_no_ranges =\tARRAY_SIZE(tas571x_readonly_regs_range),\n};\n\nstatic const struct regmap_access_table tas571x_volatile_regs = {\n\t.yes_ranges =\ttas571x_volatile_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(tas571x_volatile_regs_range),\n\n};\n\nstatic const struct reg_default tas5711_reg_defaults[] = {\n\t{ 0x04, 0x05 },\n\t{ 0x05, 0x40 },\n\t{ 0x06, 0x00 },\n\t{ 0x07, 0xff },\n\t{ 0x08, 0x30 },\n\t{ 0x09, 0x30 },\n\t{ 0x1b, 0x82 },\n};\n\nstatic const struct regmap_config tas5711_regmap_config = {\n\t.reg_bits\t\t\t= 8,\n\t.val_bits\t\t\t= 32,\n\t.max_register\t\t\t= 0xff,\n\t.reg_read\t\t\t= tas571x_reg_read,\n\t.reg_write\t\t\t= tas571x_reg_write,\n\t.reg_defaults\t\t\t= tas5711_reg_defaults,\n\t.num_reg_defaults\t\t= ARRAY_SIZE(tas5711_reg_defaults),\n\t.cache_type\t\t\t= REGCACHE_RBTREE,\n\t.wr_table\t\t\t= &tas571x_write_regs,\n\t.volatile_table\t\t\t= &tas571x_volatile_regs,\n};\n\nstatic const struct tas571x_chip tas5711_chip = {\n\t.supply_names\t\t\t= tas5711_supply_names,\n\t.num_supply_names\t\t= ARRAY_SIZE(tas5711_supply_names),\n\t.controls\t\t\t= tas5711_controls,\n\t.num_controls\t\t\t= ARRAY_SIZE(tas5711_controls),\n\t.regmap_config\t\t\t= &tas5711_regmap_config,\n\t.vol_reg_size\t\t\t= 1,\n};\n\nstatic const struct regmap_range tas5707_volatile_regs_range[] = {\n\tregmap_reg_range(TAS571X_CLK_CTRL_REG,  TAS571X_ERR_STATUS_REG),\n\tregmap_reg_range(TAS571X_OSC_TRIM_REG,  TAS571X_OSC_TRIM_REG),\n\tregmap_reg_range(TAS5707_CH1_BQ0_REG, TAS5707_CH2_BQ6_REG),\n};\n\nstatic const struct regmap_access_table tas5707_volatile_regs = {\n\t.yes_ranges =\ttas5707_volatile_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(tas5707_volatile_regs_range),\n\n};\n\nstatic const DECLARE_TLV_DB_SCALE(tas5707_volume_tlv, -7900, 50, 1);\n\nstatic const char * const tas5707_volume_slew_step_txt[] = {\n\t\"256\", \"512\", \"1024\", \"2048\",\n};\n\nstatic const unsigned int tas5707_volume_slew_step_values[] = {\n\t3, 0, 1, 2,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(tas5707_volume_slew_step_enum,\n\t\t\t\t  TAS571X_VOL_CFG_REG, 0, 0x3,\n\t\t\t\t  tas5707_volume_slew_step_txt,\n\t\t\t\t  tas5707_volume_slew_step_values);\n\nstatic const struct snd_kcontrol_new tas5707_controls[] = {\n\tSOC_SINGLE_TLV(\"Master Volume\",\n\t\t       TAS571X_MVOL_REG,\n\t\t       0, 0xff, 1, tas5707_volume_tlv),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\t\t TAS571X_CH1_VOL_REG,\n\t\t\t TAS571X_CH2_VOL_REG,\n\t\t\t 0, 0xff, 1, tas5707_volume_tlv),\n\tSOC_DOUBLE(\"Speaker Switch\",\n\t\t   TAS571X_SOFT_MUTE_REG,\n\t\t   TAS571X_SOFT_MUTE_CH1_SHIFT, TAS571X_SOFT_MUTE_CH2_SHIFT,\n\t\t   1, 1),\n\n\tSOC_ENUM(\"Slew Rate Steps\", tas5707_volume_slew_step_enum),\n\n\tBIQUAD_COEFS(\"CH1 - Biquad 0\", TAS5707_CH1_BQ0_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 1\", TAS5707_CH1_BQ1_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 2\", TAS5707_CH1_BQ2_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 3\", TAS5707_CH1_BQ3_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 4\", TAS5707_CH1_BQ4_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 5\", TAS5707_CH1_BQ5_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 6\", TAS5707_CH1_BQ6_REG),\n\n\tBIQUAD_COEFS(\"CH2 - Biquad 0\", TAS5707_CH2_BQ0_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 1\", TAS5707_CH2_BQ1_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 2\", TAS5707_CH2_BQ2_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 3\", TAS5707_CH2_BQ3_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 4\", TAS5707_CH2_BQ4_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 5\", TAS5707_CH2_BQ5_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 6\", TAS5707_CH2_BQ6_REG),\n};\n\nstatic const struct reg_default tas5707_reg_defaults[] = {\n\t{TAS571X_CLK_CTRL_REG,\t\t0x6c},\n\t{TAS571X_DEV_ID_REG,\t\t0x70},\n\t{TAS571X_ERR_STATUS_REG,\t0x00},\n\t{TAS571X_SYS_CTRL_1_REG,\t0xa0},\n\t{TAS571X_SDI_REG,\t\t0x05},\n\t{TAS571X_SYS_CTRL_2_REG,\t0x40},\n\t{TAS571X_SOFT_MUTE_REG,\t\t0x00},\n\t{TAS571X_MVOL_REG,\t\t0xff},\n\t{TAS571X_CH1_VOL_REG,\t\t0x30},\n\t{TAS571X_CH2_VOL_REG,\t\t0x30},\n\t{TAS571X_VOL_CFG_REG,\t\t0x91},\n\t{TAS571X_MODULATION_LIMIT_REG,\t0x02},\n\t{TAS571X_IC_DELAY_CH1_REG,\t0xac},\n\t{TAS571X_IC_DELAY_CH2_REG,\t0x54},\n\t{TAS571X_IC_DELAY_CH3_REG,\t0xac},\n\t{TAS571X_IC_DELAY_CH4_REG,\t0x54},\n\t{TAS571X_START_STOP_PERIOD_REG,\t0x0f},\n\t{TAS571X_OSC_TRIM_REG,\t\t0x82},\n\t{TAS571X_BKND_ERR_REG,\t\t0x02},\n\t{TAS571X_INPUT_MUX_REG,\t\t0x17772},\n\t{TAS571X_PWM_MUX_REG,\t\t0x1021345},\n};\n\nstatic const struct regmap_config tas5707_regmap_config = {\n\t.reg_bits\t\t\t= 8,\n\t.val_bits\t\t\t= 32,\n\t.max_register\t\t\t= 0xff,\n\t.reg_read\t\t\t= tas571x_reg_read,\n\t.reg_write\t\t\t= tas571x_reg_write,\n\t.reg_defaults\t\t\t= tas5707_reg_defaults,\n\t.num_reg_defaults\t\t= ARRAY_SIZE(tas5707_reg_defaults),\n\t.cache_type\t\t\t= REGCACHE_RBTREE,\n\t.wr_table\t\t\t= &tas571x_write_regs,\n\t.volatile_table\t\t\t= &tas5707_volatile_regs,\n};\n\nstatic const struct tas571x_chip tas5707_chip = {\n\t.supply_names\t\t\t= tas5711_supply_names,\n\t.num_supply_names\t\t= ARRAY_SIZE(tas5711_supply_names),\n\t.controls\t\t\t= tas5707_controls,\n\t.num_controls\t\t\t= ARRAY_SIZE(tas5707_controls),\n\t.regmap_config\t\t\t= &tas5707_regmap_config,\n\t.vol_reg_size\t\t\t= 1,\n};\n\nstatic const char *const tas5717_supply_names[] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"HPVDD\",\n\t\"PVDD_AB\",\n\t\"PVDD_CD\",\n};\n\nstatic const DECLARE_TLV_DB_SCALE(tas5717_volume_tlv, -10375, 25, 0);\n\nstatic const struct snd_kcontrol_new tas5717_controls[] = {\n\t \n\tSOC_SINGLE_TLV(\"Master Volume\",\n\t\t       TAS571X_MVOL_REG, 1, 0x1ff, 1,\n\t\t       tas5717_volume_tlv),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\t\t TAS571X_CH1_VOL_REG, TAS571X_CH2_VOL_REG,\n\t\t\t 1, 0x1ff, 1, tas5717_volume_tlv),\n\tSOC_DOUBLE(\"Speaker Switch\",\n\t\t   TAS571X_SOFT_MUTE_REG,\n\t\t   TAS571X_SOFT_MUTE_CH1_SHIFT, TAS571X_SOFT_MUTE_CH2_SHIFT,\n\t\t   1, 1),\n\n\tSOC_DOUBLE_R_RANGE(\"CH1 Mixer Volume\",\n\t\t\t   TAS5717_CH1_LEFT_CH_MIX_REG,\n\t\t\t   TAS5717_CH1_RIGHT_CH_MIX_REG,\n\t\t\t   16, 0, 0x80, 0),\n\n\tSOC_DOUBLE_R_RANGE(\"CH2 Mixer Volume\",\n\t\t\t   TAS5717_CH2_LEFT_CH_MIX_REG,\n\t\t\t   TAS5717_CH2_RIGHT_CH_MIX_REG,\n\t\t\t   16, 0, 0x80, 0),\n\n\t \n\tBIQUAD_COEFS(\"CH1 - Biquad 0\", TAS5717_CH1_BQ0_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 1\", TAS5717_CH1_BQ1_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 2\", TAS5717_CH1_BQ2_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 3\", TAS5717_CH1_BQ3_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 4\", TAS5717_CH1_BQ4_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 5\", TAS5717_CH1_BQ5_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 6\", TAS5717_CH1_BQ6_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 7\", TAS5717_CH1_BQ7_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 8\", TAS5717_CH1_BQ8_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 9\", TAS5717_CH1_BQ9_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 10\", TAS5717_CH1_BQ10_REG),\n\tBIQUAD_COEFS(\"CH1 - Biquad 11\", TAS5717_CH1_BQ11_REG),\n\n\tBIQUAD_COEFS(\"CH2 - Biquad 0\", TAS5717_CH2_BQ0_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 1\", TAS5717_CH2_BQ1_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 2\", TAS5717_CH2_BQ2_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 3\", TAS5717_CH2_BQ3_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 4\", TAS5717_CH2_BQ4_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 5\", TAS5717_CH2_BQ5_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 6\", TAS5717_CH2_BQ6_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 7\", TAS5717_CH2_BQ7_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 8\", TAS5717_CH2_BQ8_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 9\", TAS5717_CH2_BQ9_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 10\", TAS5717_CH2_BQ10_REG),\n\tBIQUAD_COEFS(\"CH2 - Biquad 11\", TAS5717_CH2_BQ11_REG),\n\n\tBIQUAD_COEFS(\"CH3 - Biquad 0\", TAS5717_CH3_BQ0_REG),\n\tBIQUAD_COEFS(\"CH3 - Biquad 1\", TAS5717_CH3_BQ1_REG),\n\n\tBIQUAD_COEFS(\"CH4 - Biquad 0\", TAS5717_CH4_BQ0_REG),\n\tBIQUAD_COEFS(\"CH4 - Biquad 1\", TAS5717_CH4_BQ1_REG),\n};\n\nstatic const struct reg_default tas5717_reg_defaults[] = {\n\t{ 0x04, 0x05 },\n\t{ 0x05, 0x40 },\n\t{ 0x06, 0x00 },\n\t{ 0x07, 0x03ff },\n\t{ 0x08, 0x00c0 },\n\t{ 0x09, 0x00c0 },\n\t{ 0x1b, 0x82 },\n\t{ TAS5717_CH1_RIGHT_CH_MIX_REG, 0x0 },\n\t{ TAS5717_CH1_LEFT_CH_MIX_REG, 0x800000},\n\t{ TAS5717_CH2_LEFT_CH_MIX_REG, 0x0 },\n\t{ TAS5717_CH2_RIGHT_CH_MIX_REG, 0x800000},\n};\n\nstatic const struct regmap_config tas5717_regmap_config = {\n\t.reg_bits\t\t\t= 8,\n\t.val_bits\t\t\t= 32,\n\t.max_register\t\t\t= 0xff,\n\t.reg_read\t\t\t= tas571x_reg_read,\n\t.reg_write\t\t\t= tas571x_reg_write,\n\t.reg_defaults\t\t\t= tas5717_reg_defaults,\n\t.num_reg_defaults\t\t= ARRAY_SIZE(tas5717_reg_defaults),\n\t.cache_type\t\t\t= REGCACHE_RBTREE,\n\t.wr_table\t\t\t= &tas571x_write_regs,\n\t.volatile_table\t\t\t= &tas571x_volatile_regs,\n};\n\n \nstatic const struct tas571x_chip tas5717_chip = {\n\t.supply_names\t\t\t= tas5717_supply_names,\n\t.num_supply_names\t\t= ARRAY_SIZE(tas5717_supply_names),\n\t.controls\t\t\t= tas5717_controls,\n\t.num_controls\t\t\t= ARRAY_SIZE(tas5717_controls),\n\t.regmap_config\t\t\t= &tas5717_regmap_config,\n\t.vol_reg_size\t\t\t= 2,\n};\n\nstatic const char *const tas5721_supply_names[] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"DRVDD\",\n\t\"PVDD\",\n};\n\nstatic const struct snd_kcontrol_new tas5721_controls[] = {\n\tSOC_SINGLE_TLV(\"Master Volume\",\n\t\t       TAS571X_MVOL_REG,\n\t\t       0, 0xff, 1, tas5711_volume_tlv),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\",\n\t\t\t TAS571X_CH1_VOL_REG,\n\t\t\t TAS571X_CH2_VOL_REG,\n\t\t\t 0, 0xff, 1, tas5711_volume_tlv),\n\tSOC_DOUBLE(\"Speaker Switch\",\n\t\t   TAS571X_SOFT_MUTE_REG,\n\t\t   TAS571X_SOFT_MUTE_CH1_SHIFT, TAS571X_SOFT_MUTE_CH2_SHIFT,\n\t\t   1, 1),\n};\n\nstatic const struct reg_default tas5721_reg_defaults[] = {\n\t{TAS571X_CLK_CTRL_REG,\t\t0x6c},\n\t{TAS571X_DEV_ID_REG,\t\t0x00},\n\t{TAS571X_ERR_STATUS_REG,\t0x00},\n\t{TAS571X_SYS_CTRL_1_REG,\t0xa0},\n\t{TAS571X_SDI_REG,\t\t0x05},\n\t{TAS571X_SYS_CTRL_2_REG,\t0x40},\n\t{TAS571X_SOFT_MUTE_REG,\t\t0x00},\n\t{TAS571X_MVOL_REG,\t\t0xff},\n\t{TAS571X_CH1_VOL_REG,\t\t0x30},\n\t{TAS571X_CH2_VOL_REG,\t\t0x30},\n\t{TAS571X_CH3_VOL_REG,\t\t0x30},\n\t{TAS571X_VOL_CFG_REG,\t\t0x91},\n\t{TAS571X_MODULATION_LIMIT_REG,\t0x02},\n\t{TAS571X_IC_DELAY_CH1_REG,\t0xac},\n\t{TAS571X_IC_DELAY_CH2_REG,\t0x54},\n\t{TAS571X_IC_DELAY_CH3_REG,\t0xac},\n\t{TAS571X_IC_DELAY_CH4_REG,\t0x54},\n\t{TAS571X_PWM_CH_SDN_GROUP_REG,\t0x30},\n\t{TAS571X_START_STOP_PERIOD_REG,\t0x0f},\n\t{TAS571X_OSC_TRIM_REG,\t\t0x82},\n\t{TAS571X_BKND_ERR_REG,\t\t0x02},\n\t{TAS571X_INPUT_MUX_REG,\t\t0x17772},\n\t{TAS571X_CH4_SRC_SELECT_REG,\t0x4303},\n\t{TAS571X_PWM_MUX_REG,\t\t0x1021345},\n};\n\nstatic const struct regmap_config tas5721_regmap_config = {\n\t.reg_bits\t\t\t= 8,\n\t.val_bits\t\t\t= 32,\n\t.max_register\t\t\t= 0xff,\n\t.reg_read\t\t\t= tas571x_reg_read,\n\t.reg_write\t\t\t= tas571x_reg_write,\n\t.reg_defaults\t\t\t= tas5721_reg_defaults,\n\t.num_reg_defaults\t\t= ARRAY_SIZE(tas5721_reg_defaults),\n\t.cache_type\t\t\t= REGCACHE_RBTREE,\n\t.wr_table\t\t\t= &tas571x_write_regs,\n\t.volatile_table\t\t\t= &tas571x_volatile_regs,\n};\n\nstatic const char *const tas5733_supply_names[] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"PVDD\",\n};\n\nstatic const struct reg_default tas5733_reg_defaults[] = {\n\t{TAS571X_CLK_CTRL_REG,          0x6c},\n\t{TAS571X_DEV_ID_REG,            0x00},\n\t{TAS571X_ERR_STATUS_REG,        0x00},\n\t{TAS571X_SYS_CTRL_1_REG,        0xa0},\n\t{TAS571X_SDI_REG,               0x05},\n\t{TAS571X_SYS_CTRL_2_REG,        0x40},\n\t{TAS571X_SOFT_MUTE_REG,         0x07},\n\t{TAS571X_MVOL_REG,              0x03ff},\n\t{TAS571X_CH1_VOL_REG,           0x00c0},\n\t{TAS571X_CH2_VOL_REG,           0x00c0},\n\t{TAS571X_CH3_VOL_REG,           0x00c0},\n\t{TAS571X_VOL_CFG_REG,           0xf0},\n\t{TAS571X_MODULATION_LIMIT_REG,  0x07},\n\t{TAS571X_IC_DELAY_CH1_REG,      0xb8},\n\t{TAS571X_IC_DELAY_CH2_REG,      0x60},\n\t{TAS571X_IC_DELAY_CH3_REG,      0xa0},\n\t{TAS571X_IC_DELAY_CH4_REG,      0x48},\n\t{TAS571X_PWM_CH_SDN_GROUP_REG,  0x30},\n\t{TAS571X_START_STOP_PERIOD_REG, 0x68},\n\t{TAS571X_OSC_TRIM_REG,          0x82},\n\t{TAS571X_BKND_ERR_REG,          0x02},\n\t{TAS571X_INPUT_MUX_REG,         0x00897772},\n\t{TAS571X_PWM_MUX_REG,           0x01021345},\n\t{TAS5717_CH1_RIGHT_CH_MIX_REG,  0x00},\n\t{TAS5717_CH1_LEFT_CH_MIX_REG,   0x800000},\n\t{TAS5717_CH2_LEFT_CH_MIX_REG,   0x00},\n\t{TAS5717_CH2_RIGHT_CH_MIX_REG,  0x800000},\n};\n\nstatic const struct regmap_config tas5733_regmap_config = {\n\t.reg_bits                       = 8,\n\t.val_bits                       = 32,\n\t.max_register                   = 0xff,\n\t.reg_read                       = tas571x_reg_read,\n\t.reg_write                      = tas571x_reg_write,\n\t.reg_defaults                   = tas5733_reg_defaults,\n\t.num_reg_defaults               = ARRAY_SIZE(tas5733_reg_defaults),\n\t.cache_type                     = REGCACHE_RBTREE,\n\t.wr_table                       = &tas571x_write_regs,\n\t.volatile_table                 = &tas571x_volatile_regs,\n};\n\nstatic const struct tas571x_chip tas5733_chip = {\n\t.supply_names                   = tas5733_supply_names,\n\t.num_supply_names               = ARRAY_SIZE(tas5733_supply_names),\n\t.controls                       = tas5717_controls,\n\t.num_controls                   = ARRAY_SIZE(tas5717_controls),\n\t.regmap_config                  = &tas5733_regmap_config,\n\t.vol_reg_size                   = 2,\n};\n\nstatic const struct tas571x_chip tas5721_chip = {\n\t.supply_names\t\t\t= tas5721_supply_names,\n\t.num_supply_names\t\t= ARRAY_SIZE(tas5721_supply_names),\n\t.controls\t\t\t= tas5721_controls,\n\t.num_controls\t\t\t= ARRAY_SIZE(tas5721_controls),\n\t.regmap_config\t\t\t= &tas5721_regmap_config,\n\t.vol_reg_size\t\t\t= 1,\n};\n\nstatic const struct snd_soc_dapm_widget tas571x_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DACL\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DACR\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT_A\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT_B\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT_C\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT_D\"),\n};\n\nstatic const struct snd_soc_dapm_route tas571x_dapm_routes[] = {\n\t{ \"DACL\",  NULL, \"Playback\" },\n\t{ \"DACR\",  NULL, \"Playback\" },\n\n\t{ \"OUT_A\", NULL, \"DACL\" },\n\t{ \"OUT_B\", NULL, \"DACL\" },\n\t{ \"OUT_C\", NULL, \"DACR\" },\n\t{ \"OUT_D\", NULL, \"DACR\" },\n};\n\nstatic const struct snd_soc_component_driver tas571x_component = {\n\t.set_bias_level\t\t= tas571x_set_bias_level,\n\t.dapm_widgets\t\t= tas571x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas571x_dapm_widgets),\n\t.dapm_routes\t\t= tas571x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas571x_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver tas571x_dai = {\n\t.name = \"tas571x-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &tas571x_dai_ops,\n};\n\nstatic const struct of_device_id tas571x_of_match[] __maybe_unused;\nstatic const struct i2c_device_id tas571x_i2c_id[];\n\nstatic int tas571x_i2c_probe(struct i2c_client *client)\n{\n\tstruct tas571x_private *priv;\n\tstruct device *dev = &client->dev;\n\tconst struct of_device_id *of_id;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(client, priv);\n\n\tof_id = of_match_device(tas571x_of_match, dev);\n\tif (of_id)\n\t\tpriv->chip = of_id->data;\n\telse {\n\t\tconst struct i2c_device_id *id =\n\t\t\ti2c_match_id(tas571x_i2c_id, client);\n\t\tpriv->chip = (void *) id->driver_data;\n\t}\n\n\tpriv->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(priv->mclk) && PTR_ERR(priv->mclk) != -ENOENT) {\n\t\tdev_err(dev, \"Failed to request mclk: %ld\\n\",\n\t\t\tPTR_ERR(priv->mclk));\n\t\treturn PTR_ERR(priv->mclk);\n\t}\n\n\tif (WARN_ON(priv->chip->num_supply_names > TAS571X_MAX_SUPPLIES))\n\t\treturn -EINVAL;\n\tfor (i = 0; i < priv->chip->num_supply_names; i++)\n\t\tpriv->supplies[i].supply = priv->chip->supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, priv->chip->num_supply_names,\n\t\t\t\t      priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regulator_bulk_enable(priv->chip->num_supply_names,\n\t\t\t\t    priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->regmap = devm_regmap_init(dev, NULL, client,\n\t\t\t\t\tpriv->chip->regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tgoto disable_regs;\n\t}\n\n\tpriv->pdn_gpio = devm_gpiod_get_optional(dev, \"pdn\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->pdn_gpio)) {\n\t\tdev_err(dev, \"error requesting pdn_gpio: %ld\\n\",\n\t\t\tPTR_ERR(priv->pdn_gpio));\n\t\tret = PTR_ERR(priv->pdn_gpio);\n\t\tgoto disable_regs;\n\t}\n\n\tpriv->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(priv->reset_gpio)) {\n\t\tdev_err(dev, \"error requesting reset_gpio: %ld\\n\",\n\t\t\tPTR_ERR(priv->reset_gpio));\n\t\tret = PTR_ERR(priv->reset_gpio);\n\t\tgoto disable_regs;\n\t} else if (priv->reset_gpio) {\n\t\t \n\t\tusleep_range(100, 200);\n\t\tgpiod_set_value(priv->reset_gpio, 0);\n\t\tusleep_range(13500, 20000);\n\t}\n\n\tret = regmap_write(priv->regmap, TAS571X_OSC_TRIM_REG, 0);\n\tif (ret)\n\t\tgoto disable_regs;\n\n\tusleep_range(50000, 60000);\n\n\tmemcpy(&priv->component_driver, &tas571x_component, sizeof(priv->component_driver));\n\tpriv->component_driver.controls = priv->chip->controls;\n\tpriv->component_driver.num_controls = priv->chip->num_controls;\n\n\tif (priv->chip->vol_reg_size == 2) {\n\t\t \n\t\tret = regmap_update_bits(priv->regmap, TAS571X_MVOL_REG, 1, 0);\n\t\tif (ret)\n\t\t\tgoto disable_regs;\n\t}\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t      &priv->component_driver,\n\t\t\t\t      &tas571x_dai, 1);\n\tif (ret)\n\t\tgoto disable_regs;\n\n\treturn ret;\n\ndisable_regs:\n\tregulator_bulk_disable(priv->chip->num_supply_names, priv->supplies);\n\treturn ret;\n}\n\nstatic void tas571x_i2c_remove(struct i2c_client *client)\n{\n\tstruct tas571x_private *priv = i2c_get_clientdata(client);\n\n\tregulator_bulk_disable(priv->chip->num_supply_names, priv->supplies);\n}\n\nstatic const struct of_device_id tas571x_of_match[] __maybe_unused = {\n\t{ .compatible = \"ti,tas5707\", .data = &tas5707_chip, },\n\t{ .compatible = \"ti,tas5711\", .data = &tas5711_chip, },\n\t{ .compatible = \"ti,tas5717\", .data = &tas5717_chip, },\n\t{ .compatible = \"ti,tas5719\", .data = &tas5717_chip, },\n\t{ .compatible = \"ti,tas5721\", .data = &tas5721_chip, },\n\t{ .compatible = \"ti,tas5733\", .data = &tas5733_chip, },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tas571x_of_match);\n\nstatic const struct i2c_device_id tas571x_i2c_id[] = {\n\t{ \"tas5707\", (kernel_ulong_t) &tas5707_chip },\n\t{ \"tas5711\", (kernel_ulong_t) &tas5711_chip },\n\t{ \"tas5717\", (kernel_ulong_t) &tas5717_chip },\n\t{ \"tas5719\", (kernel_ulong_t) &tas5717_chip },\n\t{ \"tas5721\", (kernel_ulong_t) &tas5721_chip },\n\t{ \"tas5733\", (kernel_ulong_t) &tas5733_chip },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas571x_i2c_id);\n\nstatic struct i2c_driver tas571x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas571x\",\n\t\t.of_match_table = of_match_ptr(tas571x_of_match),\n\t},\n\t.probe = tas571x_i2c_probe,\n\t.remove = tas571x_i2c_remove,\n\t.id_table = tas571x_i2c_id,\n};\nmodule_i2c_driver(tas571x_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC TAS571x driver\");\nMODULE_AUTHOR(\"Kevin Cernekee <cernekee@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}