{
  "module_name": "lpass-va-macro.c",
  "hash_id": "44bdee19fc3fb94a417fcf92401642acdcb55bb9d83f92443f4c1bd47b8373ad",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/lpass-va-macro.c",
  "human_readable_source": "\n\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_clk.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"lpass-macro-common.h\"\n\n \n#define CDC_VA_CLK_RST_CTRL_MCLK_CONTROL\t(0x0000)\n#define CDC_VA_MCLK_CONTROL_EN\t\t\tBIT(0)\n#define CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL\t(0x0004)\n#define CDC_VA_FS_CONTROL_EN\t\t\tBIT(0)\n#define CDC_VA_FS_COUNTER_CLR\t\t\tBIT(1)\n#define CDC_VA_CLK_RST_CTRL_SWR_CONTROL\t\t(0x0008)\n#define CDC_VA_SWR_RESET_MASK\t\tBIT(1)\n#define CDC_VA_SWR_RESET_ENABLE\t\tBIT(1)\n#define CDC_VA_SWR_CLK_EN_MASK\t\tBIT(0)\n#define CDC_VA_SWR_CLK_ENABLE\t\tBIT(0)\n#define CDC_VA_TOP_CSR_TOP_CFG0\t\t\t(0x0080)\n#define CDC_VA_FS_BROADCAST_EN\t\t\tBIT(1)\n#define CDC_VA_TOP_CSR_DMIC0_CTL\t\t(0x0084)\n#define CDC_VA_TOP_CSR_DMIC1_CTL\t\t(0x0088)\n#define CDC_VA_TOP_CSR_DMIC2_CTL\t\t(0x008C)\n#define CDC_VA_TOP_CSR_DMIC3_CTL\t\t(0x0090)\n#define CDC_VA_DMIC_EN_MASK\t\t\tBIT(0)\n#define CDC_VA_DMIC_ENABLE\t\t\tBIT(0)\n#define CDC_VA_DMIC_CLK_SEL_MASK\t\tGENMASK(3, 1)\n#define CDC_VA_DMIC_CLK_SEL_SHFT\t\t1\n#define CDC_VA_DMIC_CLK_SEL_DIV0\t\t0x0\n#define CDC_VA_DMIC_CLK_SEL_DIV1\t\t0x2\n#define CDC_VA_DMIC_CLK_SEL_DIV2\t\t0x4\n#define CDC_VA_DMIC_CLK_SEL_DIV3\t\t0x6\n#define CDC_VA_DMIC_CLK_SEL_DIV4\t\t0x8\n#define CDC_VA_DMIC_CLK_SEL_DIV5\t\t0xa\n#define CDC_VA_TOP_CSR_DMIC_CFG\t\t\t(0x0094)\n#define CDC_VA_RESET_ALL_DMICS_MASK\t\tBIT(7)\n#define CDC_VA_RESET_ALL_DMICS_RESET\t\tBIT(7)\n#define CDC_VA_RESET_ALL_DMICS_DISABLE\t\t0\n#define CDC_VA_DMIC3_FREQ_CHANGE_MASK\t\tBIT(3)\n#define CDC_VA_DMIC3_FREQ_CHANGE_EN\t\tBIT(3)\n#define CDC_VA_DMIC2_FREQ_CHANGE_MASK\t\tBIT(2)\n#define CDC_VA_DMIC2_FREQ_CHANGE_EN\t\tBIT(2)\n#define CDC_VA_DMIC1_FREQ_CHANGE_MASK\t\tBIT(1)\n#define CDC_VA_DMIC1_FREQ_CHANGE_EN\t\tBIT(1)\n#define CDC_VA_DMIC0_FREQ_CHANGE_MASK\t\tBIT(0)\n#define CDC_VA_DMIC0_FREQ_CHANGE_EN\t\tBIT(0)\n#define CDC_VA_DMIC_FREQ_CHANGE_DISABLE\t\t0\n#define CDC_VA_TOP_CSR_DEBUG_BUS\t\t(0x009C)\n#define CDC_VA_TOP_CSR_DEBUG_EN\t\t\t(0x00A0)\n#define CDC_VA_TOP_CSR_TX_I2S_CTL\t\t(0x00A4)\n#define CDC_VA_TOP_CSR_I2S_CLK\t\t\t(0x00A8)\n#define CDC_VA_TOP_CSR_I2S_RESET\t\t(0x00AC)\n#define CDC_VA_TOP_CSR_CORE_ID_0\t\t(0x00C0)\n#define CDC_VA_TOP_CSR_CORE_ID_1\t\t(0x00C4)\n#define CDC_VA_TOP_CSR_CORE_ID_2\t\t(0x00C8)\n#define CDC_VA_TOP_CSR_CORE_ID_3\t\t(0x00CC)\n#define CDC_VA_TOP_CSR_SWR_MIC_CTL0\t\t(0x00D0)\n#define CDC_VA_TOP_CSR_SWR_MIC_CTL1\t\t(0x00D4)\n#define CDC_VA_TOP_CSR_SWR_MIC_CTL2\t\t(0x00D8)\n#define CDC_VA_SWR_MIC_CLK_SEL_0_1_MASK\t\t(0xEE)\n#define CDC_VA_SWR_MIC_CLK_SEL_0_1_DIV1\t\t(0xCC)\n#define CDC_VA_TOP_CSR_SWR_CTRL\t\t\t(0x00DC)\n#define CDC_VA_INP_MUX_ADC_MUX0_CFG0\t\t(0x0100)\n#define CDC_VA_INP_MUX_ADC_MUX0_CFG1\t\t(0x0104)\n#define CDC_VA_INP_MUX_ADC_MUX1_CFG0\t\t(0x0108)\n#define CDC_VA_INP_MUX_ADC_MUX1_CFG1\t\t(0x010C)\n#define CDC_VA_INP_MUX_ADC_MUX2_CFG0\t\t(0x0110)\n#define CDC_VA_INP_MUX_ADC_MUX2_CFG1\t\t(0x0114)\n#define CDC_VA_INP_MUX_ADC_MUX3_CFG0\t\t(0x0118)\n#define CDC_VA_INP_MUX_ADC_MUX3_CFG1\t\t(0x011C)\n#define CDC_VA_TX0_TX_PATH_CTL\t\t\t(0x0400)\n#define CDC_VA_TX_PATH_CLK_EN_MASK\t\tBIT(5)\n#define CDC_VA_TX_PATH_CLK_EN\t\t\tBIT(5)\n#define CDC_VA_TX_PATH_CLK_DISABLE\t\t0\n#define CDC_VA_TX_PATH_PGA_MUTE_EN_MASK\t\tBIT(4)\n#define CDC_VA_TX_PATH_PGA_MUTE_EN\t\tBIT(4)\n#define CDC_VA_TX_PATH_PGA_MUTE_DISABLE\t\t0\n#define CDC_VA_TX0_TX_PATH_CFG0\t\t\t(0x0404)\n#define CDC_VA_ADC_MODE_MASK\t\t\tGENMASK(2, 1)\n#define CDC_VA_ADC_MODE_SHIFT\t\t\t1\n#define  TX_HPF_CUT_OFF_FREQ_MASK\t\tGENMASK(6, 5)\n#define  CF_MIN_3DB_4HZ\t\t\t0x0\n#define  CF_MIN_3DB_75HZ\t\t0x1\n#define  CF_MIN_3DB_150HZ\t\t0x2\n#define CDC_VA_TX0_TX_PATH_CFG1\t\t\t(0x0408)\n#define CDC_VA_TX0_TX_VOL_CTL\t\t\t(0x040C)\n#define CDC_VA_TX0_TX_PATH_SEC0\t\t\t(0x0410)\n#define CDC_VA_TX0_TX_PATH_SEC1\t\t\t(0x0414)\n#define CDC_VA_TX0_TX_PATH_SEC2\t\t\t(0x0418)\n#define CDC_VA_TX_HPF_CUTOFF_FREQ_CHANGE_MASK\tBIT(1)\n#define CDC_VA_TX_HPF_CUTOFF_FREQ_CHANGE_REQ\tBIT(1)\n#define CDC_VA_TX_HPF_ZERO_GATE_MASK\t\tBIT(0)\n#define CDC_VA_TX_HPF_ZERO_NO_GATE\t\tBIT(0)\n#define CDC_VA_TX_HPF_ZERO_GATE\t\t\t0\n#define CDC_VA_TX0_TX_PATH_SEC3\t\t\t(0x041C)\n#define CDC_VA_TX0_TX_PATH_SEC4\t\t\t(0x0420)\n#define CDC_VA_TX0_TX_PATH_SEC5\t\t\t(0x0424)\n#define CDC_VA_TX0_TX_PATH_SEC6\t\t\t(0x0428)\n#define CDC_VA_TX0_TX_PATH_SEC7\t\t\t(0x042C)\n#define CDC_VA_TX1_TX_PATH_CTL\t\t\t(0x0480)\n#define CDC_VA_TX1_TX_PATH_CFG0\t\t\t(0x0484)\n#define CDC_VA_TX1_TX_PATH_CFG1\t\t\t(0x0488)\n#define CDC_VA_TX1_TX_VOL_CTL\t\t\t(0x048C)\n#define CDC_VA_TX1_TX_PATH_SEC0\t\t\t(0x0490)\n#define CDC_VA_TX1_TX_PATH_SEC1\t\t\t(0x0494)\n#define CDC_VA_TX1_TX_PATH_SEC2\t\t\t(0x0498)\n#define CDC_VA_TX1_TX_PATH_SEC3\t\t\t(0x049C)\n#define CDC_VA_TX1_TX_PATH_SEC4\t\t\t(0x04A0)\n#define CDC_VA_TX1_TX_PATH_SEC5\t\t\t(0x04A4)\n#define CDC_VA_TX1_TX_PATH_SEC6\t\t\t(0x04A8)\n#define CDC_VA_TX2_TX_PATH_CTL\t\t\t(0x0500)\n#define CDC_VA_TX2_TX_PATH_CFG0\t\t\t(0x0504)\n#define CDC_VA_TX2_TX_PATH_CFG1\t\t\t(0x0508)\n#define CDC_VA_TX2_TX_VOL_CTL\t\t\t(0x050C)\n#define CDC_VA_TX2_TX_PATH_SEC0\t\t\t(0x0510)\n#define CDC_VA_TX2_TX_PATH_SEC1\t\t\t(0x0514)\n#define CDC_VA_TX2_TX_PATH_SEC2\t\t\t(0x0518)\n#define CDC_VA_TX2_TX_PATH_SEC3\t\t\t(0x051C)\n#define CDC_VA_TX2_TX_PATH_SEC4\t\t\t(0x0520)\n#define CDC_VA_TX2_TX_PATH_SEC5\t\t\t(0x0524)\n#define CDC_VA_TX2_TX_PATH_SEC6\t\t\t(0x0528)\n#define CDC_VA_TX3_TX_PATH_CTL\t\t\t(0x0580)\n#define CDC_VA_TX3_TX_PATH_CFG0\t\t\t(0x0584)\n#define CDC_VA_TX_PATH_ADC_DMIC_SEL_MASK\tBIT(7)\n#define CDC_VA_TX_PATH_ADC_DMIC_SEL_DMIC\tBIT(7)\n#define CDC_VA_TX_PATH_ADC_DMIC_SEL_ADC\t\t0\n#define CDC_VA_TX3_TX_PATH_CFG1\t\t\t(0x0588)\n#define CDC_VA_TX3_TX_VOL_CTL\t\t\t(0x058C)\n#define CDC_VA_TX3_TX_PATH_SEC0\t\t\t(0x0590)\n#define CDC_VA_TX3_TX_PATH_SEC1\t\t\t(0x0594)\n#define CDC_VA_TX3_TX_PATH_SEC2\t\t\t(0x0598)\n#define CDC_VA_TX3_TX_PATH_SEC3\t\t\t(0x059C)\n#define CDC_VA_TX3_TX_PATH_SEC4\t\t\t(0x05A0)\n#define CDC_VA_TX3_TX_PATH_SEC5\t\t\t(0x05A4)\n#define CDC_VA_TX3_TX_PATH_SEC6\t\t\t(0x05A8)\n\n#define VA_MAX_OFFSET\t\t\t\t(0x07A8)\n\n#define VA_MACRO_NUM_DECIMATORS 4\n#define VA_MACRO_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\\\n\t\t\tSNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000 |\\\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)\n#define VA_MACRO_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\tSNDRV_PCM_FMTBIT_S24_LE |\\\n\t\tSNDRV_PCM_FMTBIT_S24_3LE)\n\n#define VA_MACRO_MCLK_FREQ 9600000\n#define VA_MACRO_TX_PATH_OFFSET 0x80\n#define VA_MACRO_SWR_MIC_MUX_SEL_MASK 0xF\n#define VA_MACRO_ADC_MUX_CFG_OFFSET 0x8\n\nstatic const DECLARE_TLV_DB_SCALE(digital_gain, -8400, 100, -8400);\n\nenum {\n\tVA_MACRO_AIF_INVALID = 0,\n\tVA_MACRO_AIF1_CAP,\n\tVA_MACRO_AIF2_CAP,\n\tVA_MACRO_AIF3_CAP,\n\tVA_MACRO_MAX_DAIS,\n};\n\nenum {\n\tVA_MACRO_DEC0,\n\tVA_MACRO_DEC1,\n\tVA_MACRO_DEC2,\n\tVA_MACRO_DEC3,\n\tVA_MACRO_DEC4,\n\tVA_MACRO_DEC5,\n\tVA_MACRO_DEC6,\n\tVA_MACRO_DEC7,\n\tVA_MACRO_DEC_MAX,\n};\n\nenum {\n\tVA_MACRO_CLK_DIV_2,\n\tVA_MACRO_CLK_DIV_3,\n\tVA_MACRO_CLK_DIV_4,\n\tVA_MACRO_CLK_DIV_6,\n\tVA_MACRO_CLK_DIV_8,\n\tVA_MACRO_CLK_DIV_16,\n};\n\n#define VA_NUM_CLKS_MAX\t\t3\n\nstruct va_macro {\n\tstruct device *dev;\n\tunsigned long active_ch_mask[VA_MACRO_MAX_DAIS];\n\tunsigned long active_ch_cnt[VA_MACRO_MAX_DAIS];\n\tu16 dmic_clk_div;\n\tbool has_swr_master;\n\n\tint dec_mode[VA_MACRO_NUM_DECIMATORS];\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\tstruct clk *macro;\n\tstruct clk *dcodec;\n\tstruct clk *fsgen;\n\tstruct clk_hw hw;\n\tstruct lpass_macro *pds;\n\n\ts32 dmic_0_1_clk_cnt;\n\ts32 dmic_2_3_clk_cnt;\n\ts32 dmic_4_5_clk_cnt;\n\ts32 dmic_6_7_clk_cnt;\n\tu8 dmic_0_1_clk_div;\n\tu8 dmic_2_3_clk_div;\n\tu8 dmic_4_5_clk_div;\n\tu8 dmic_6_7_clk_div;\n};\n\n#define to_va_macro(_hw) container_of(_hw, struct va_macro, hw)\n\nstruct va_macro_data {\n\tbool has_swr_master;\n};\n\nstatic const struct va_macro_data sm8250_va_data = {\n\t.has_swr_master = false,\n};\n\nstatic const struct va_macro_data sm8450_va_data = {\n\t.has_swr_master = true,\n};\n\nstatic bool va_is_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CDC_VA_TOP_CSR_CORE_ID_0:\n\tcase CDC_VA_TOP_CSR_CORE_ID_1:\n\tcase CDC_VA_TOP_CSR_CORE_ID_2:\n\tcase CDC_VA_TOP_CSR_CORE_ID_3:\n\tcase CDC_VA_TOP_CSR_DMIC0_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC1_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC2_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC3_CTL:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const struct reg_default va_defaults[] = {\n\t \n\t{ CDC_VA_CLK_RST_CTRL_MCLK_CONTROL, 0x00},\n\t{ CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL, 0x00},\n\t{ CDC_VA_CLK_RST_CTRL_SWR_CONTROL, 0x00},\n\t{ CDC_VA_TOP_CSR_TOP_CFG0, 0x00},\n\t{ CDC_VA_TOP_CSR_DMIC0_CTL, 0x00},\n\t{ CDC_VA_TOP_CSR_DMIC1_CTL, 0x00},\n\t{ CDC_VA_TOP_CSR_DMIC2_CTL, 0x00},\n\t{ CDC_VA_TOP_CSR_DMIC3_CTL, 0x00},\n\t{ CDC_VA_TOP_CSR_DMIC_CFG, 0x80},\n\t{ CDC_VA_TOP_CSR_DEBUG_BUS, 0x00},\n\t{ CDC_VA_TOP_CSR_DEBUG_EN, 0x00},\n\t{ CDC_VA_TOP_CSR_TX_I2S_CTL, 0x0C},\n\t{ CDC_VA_TOP_CSR_I2S_CLK, 0x00},\n\t{ CDC_VA_TOP_CSR_I2S_RESET, 0x00},\n\t{ CDC_VA_TOP_CSR_CORE_ID_0, 0x00},\n\t{ CDC_VA_TOP_CSR_CORE_ID_1, 0x00},\n\t{ CDC_VA_TOP_CSR_CORE_ID_2, 0x00},\n\t{ CDC_VA_TOP_CSR_CORE_ID_3, 0x00},\n\t{ CDC_VA_TOP_CSR_SWR_MIC_CTL0, 0xEE},\n\t{ CDC_VA_TOP_CSR_SWR_MIC_CTL1, 0xEE},\n\t{ CDC_VA_TOP_CSR_SWR_MIC_CTL2, 0xEE},\n\t{ CDC_VA_TOP_CSR_SWR_CTRL, 0x06},\n\n\t \n\t{ CDC_VA_INP_MUX_ADC_MUX0_CFG0, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX0_CFG1, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX1_CFG0, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX1_CFG1, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX2_CFG0, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX2_CFG1, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX3_CFG0, 0x00},\n\t{ CDC_VA_INP_MUX_ADC_MUX3_CFG1, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_CTL, 0x04},\n\t{ CDC_VA_TX0_TX_PATH_CFG0, 0x10},\n\t{ CDC_VA_TX0_TX_PATH_CFG1, 0x0B},\n\t{ CDC_VA_TX0_TX_VOL_CTL, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_SEC0, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_SEC1, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_SEC2, 0x01},\n\t{ CDC_VA_TX0_TX_PATH_SEC3, 0x3C},\n\t{ CDC_VA_TX0_TX_PATH_SEC4, 0x20},\n\t{ CDC_VA_TX0_TX_PATH_SEC5, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_SEC6, 0x00},\n\t{ CDC_VA_TX0_TX_PATH_SEC7, 0x25},\n\t{ CDC_VA_TX1_TX_PATH_CTL, 0x04},\n\t{ CDC_VA_TX1_TX_PATH_CFG0, 0x10},\n\t{ CDC_VA_TX1_TX_PATH_CFG1, 0x0B},\n\t{ CDC_VA_TX1_TX_VOL_CTL, 0x00},\n\t{ CDC_VA_TX1_TX_PATH_SEC0, 0x00},\n\t{ CDC_VA_TX1_TX_PATH_SEC1, 0x00},\n\t{ CDC_VA_TX1_TX_PATH_SEC2, 0x01},\n\t{ CDC_VA_TX1_TX_PATH_SEC3, 0x3C},\n\t{ CDC_VA_TX1_TX_PATH_SEC4, 0x20},\n\t{ CDC_VA_TX1_TX_PATH_SEC5, 0x00},\n\t{ CDC_VA_TX1_TX_PATH_SEC6, 0x00},\n\t{ CDC_VA_TX2_TX_PATH_CTL, 0x04},\n\t{ CDC_VA_TX2_TX_PATH_CFG0, 0x10},\n\t{ CDC_VA_TX2_TX_PATH_CFG1, 0x0B},\n\t{ CDC_VA_TX2_TX_VOL_CTL, 0x00},\n\t{ CDC_VA_TX2_TX_PATH_SEC0, 0x00},\n\t{ CDC_VA_TX2_TX_PATH_SEC1, 0x00},\n\t{ CDC_VA_TX2_TX_PATH_SEC2, 0x01},\n\t{ CDC_VA_TX2_TX_PATH_SEC3, 0x3C},\n\t{ CDC_VA_TX2_TX_PATH_SEC4, 0x20},\n\t{ CDC_VA_TX2_TX_PATH_SEC5, 0x00},\n\t{ CDC_VA_TX2_TX_PATH_SEC6, 0x00},\n\t{ CDC_VA_TX3_TX_PATH_CTL, 0x04},\n\t{ CDC_VA_TX3_TX_PATH_CFG0, 0x10},\n\t{ CDC_VA_TX3_TX_PATH_CFG1, 0x0B},\n\t{ CDC_VA_TX3_TX_VOL_CTL, 0x00},\n\t{ CDC_VA_TX3_TX_PATH_SEC0, 0x00},\n\t{ CDC_VA_TX3_TX_PATH_SEC1, 0x00},\n\t{ CDC_VA_TX3_TX_PATH_SEC2, 0x01},\n\t{ CDC_VA_TX3_TX_PATH_SEC3, 0x3C},\n\t{ CDC_VA_TX3_TX_PATH_SEC4, 0x20},\n\t{ CDC_VA_TX3_TX_PATH_SEC5, 0x00},\n\t{ CDC_VA_TX3_TX_PATH_SEC6, 0x00},\n};\n\nstatic bool va_is_rw_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CDC_VA_CLK_RST_CTRL_MCLK_CONTROL:\n\tcase CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL:\n\tcase CDC_VA_CLK_RST_CTRL_SWR_CONTROL:\n\tcase CDC_VA_TOP_CSR_TOP_CFG0:\n\tcase CDC_VA_TOP_CSR_DMIC0_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC1_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC2_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC3_CTL:\n\tcase CDC_VA_TOP_CSR_DMIC_CFG:\n\tcase CDC_VA_TOP_CSR_SWR_MIC_CTL0:\n\tcase CDC_VA_TOP_CSR_SWR_MIC_CTL1:\n\tcase CDC_VA_TOP_CSR_SWR_MIC_CTL2:\n\tcase CDC_VA_TOP_CSR_DEBUG_BUS:\n\tcase CDC_VA_TOP_CSR_DEBUG_EN:\n\tcase CDC_VA_TOP_CSR_TX_I2S_CTL:\n\tcase CDC_VA_TOP_CSR_I2S_CLK:\n\tcase CDC_VA_TOP_CSR_I2S_RESET:\n\tcase CDC_VA_INP_MUX_ADC_MUX0_CFG0:\n\tcase CDC_VA_INP_MUX_ADC_MUX0_CFG1:\n\tcase CDC_VA_INP_MUX_ADC_MUX1_CFG0:\n\tcase CDC_VA_INP_MUX_ADC_MUX1_CFG1:\n\tcase CDC_VA_INP_MUX_ADC_MUX2_CFG0:\n\tcase CDC_VA_INP_MUX_ADC_MUX2_CFG1:\n\tcase CDC_VA_INP_MUX_ADC_MUX3_CFG0:\n\tcase CDC_VA_INP_MUX_ADC_MUX3_CFG1:\n\tcase CDC_VA_TX0_TX_PATH_CTL:\n\tcase CDC_VA_TX0_TX_PATH_CFG0:\n\tcase CDC_VA_TX0_TX_PATH_CFG1:\n\tcase CDC_VA_TX0_TX_VOL_CTL:\n\tcase CDC_VA_TX0_TX_PATH_SEC0:\n\tcase CDC_VA_TX0_TX_PATH_SEC1:\n\tcase CDC_VA_TX0_TX_PATH_SEC2:\n\tcase CDC_VA_TX0_TX_PATH_SEC3:\n\tcase CDC_VA_TX0_TX_PATH_SEC4:\n\tcase CDC_VA_TX0_TX_PATH_SEC5:\n\tcase CDC_VA_TX0_TX_PATH_SEC6:\n\tcase CDC_VA_TX0_TX_PATH_SEC7:\n\tcase CDC_VA_TX1_TX_PATH_CTL:\n\tcase CDC_VA_TX1_TX_PATH_CFG0:\n\tcase CDC_VA_TX1_TX_PATH_CFG1:\n\tcase CDC_VA_TX1_TX_VOL_CTL:\n\tcase CDC_VA_TX1_TX_PATH_SEC0:\n\tcase CDC_VA_TX1_TX_PATH_SEC1:\n\tcase CDC_VA_TX1_TX_PATH_SEC2:\n\tcase CDC_VA_TX1_TX_PATH_SEC3:\n\tcase CDC_VA_TX1_TX_PATH_SEC4:\n\tcase CDC_VA_TX1_TX_PATH_SEC5:\n\tcase CDC_VA_TX1_TX_PATH_SEC6:\n\tcase CDC_VA_TX2_TX_PATH_CTL:\n\tcase CDC_VA_TX2_TX_PATH_CFG0:\n\tcase CDC_VA_TX2_TX_PATH_CFG1:\n\tcase CDC_VA_TX2_TX_VOL_CTL:\n\tcase CDC_VA_TX2_TX_PATH_SEC0:\n\tcase CDC_VA_TX2_TX_PATH_SEC1:\n\tcase CDC_VA_TX2_TX_PATH_SEC2:\n\tcase CDC_VA_TX2_TX_PATH_SEC3:\n\tcase CDC_VA_TX2_TX_PATH_SEC4:\n\tcase CDC_VA_TX2_TX_PATH_SEC5:\n\tcase CDC_VA_TX2_TX_PATH_SEC6:\n\tcase CDC_VA_TX3_TX_PATH_CTL:\n\tcase CDC_VA_TX3_TX_PATH_CFG0:\n\tcase CDC_VA_TX3_TX_PATH_CFG1:\n\tcase CDC_VA_TX3_TX_VOL_CTL:\n\tcase CDC_VA_TX3_TX_PATH_SEC0:\n\tcase CDC_VA_TX3_TX_PATH_SEC1:\n\tcase CDC_VA_TX3_TX_PATH_SEC2:\n\tcase CDC_VA_TX3_TX_PATH_SEC3:\n\tcase CDC_VA_TX3_TX_PATH_SEC4:\n\tcase CDC_VA_TX3_TX_PATH_SEC5:\n\tcase CDC_VA_TX3_TX_PATH_SEC6:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool va_is_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CDC_VA_TOP_CSR_CORE_ID_0:\n\tcase CDC_VA_TOP_CSR_CORE_ID_1:\n\tcase CDC_VA_TOP_CSR_CORE_ID_2:\n\tcase CDC_VA_TOP_CSR_CORE_ID_3:\n\t\treturn true;\n\t}\n\n\treturn va_is_rw_register(dev, reg);\n}\n\nstatic const struct regmap_config va_regmap_config = {\n\t.name = \"va_macro\",\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.cache_type = REGCACHE_FLAT,\n\t.reg_defaults = va_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(va_defaults),\n\t.max_register = VA_MAX_OFFSET,\n\t.volatile_reg = va_is_volatile_register,\n\t.readable_reg = va_is_readable_register,\n\t.writeable_reg = va_is_rw_register,\n};\n\nstatic int va_clk_rsc_fs_gen_request(struct va_macro *va, bool enable)\n{\n\tstruct regmap *regmap = va->regmap;\n\n\tif (enable) {\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_MCLK_CONTROL,\n\t\t\t\t   CDC_VA_MCLK_CONTROL_EN,\n\t\t\t\t   CDC_VA_MCLK_CONTROL_EN);\n\t\t \n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL,\n\t\t\t\t   CDC_VA_FS_CONTROL_EN | CDC_VA_FS_COUNTER_CLR,\n\t\t\t\t   CDC_VA_FS_CONTROL_EN | CDC_VA_FS_COUNTER_CLR);\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL,\n\t\t\t\t   CDC_VA_FS_CONTROL_EN | CDC_VA_FS_COUNTER_CLR,\n\t\t\t\t   CDC_VA_FS_CONTROL_EN);\n\n\t\tregmap_update_bits(regmap, CDC_VA_TOP_CSR_TOP_CFG0,\n\t\t\t\t   CDC_VA_FS_BROADCAST_EN,\n\t\t\t\t   CDC_VA_FS_BROADCAST_EN);\n\t} else {\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_MCLK_CONTROL,\n\t\t\t\t   CDC_VA_MCLK_CONTROL_EN, 0x0);\n\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_FS_CNT_CONTROL,\n\t\t\t\t   CDC_VA_FS_CONTROL_EN, 0x0);\n\n\t\tregmap_update_bits(regmap, CDC_VA_TOP_CSR_TOP_CFG0,\n\t\t\t\t   CDC_VA_FS_BROADCAST_EN, 0x0);\n\t}\n\n\treturn 0;\n}\n\nstatic int va_macro_mclk_enable(struct va_macro *va, bool mclk_enable)\n{\n\tstruct regmap *regmap = va->regmap;\n\n\tif (mclk_enable) {\n\t\tva_clk_rsc_fs_gen_request(va, true);\n\t\tregcache_mark_dirty(regmap);\n\t\tregcache_sync_region(regmap, 0x0, VA_MAX_OFFSET);\n\t} else {\n\t\tva_clk_rsc_fs_gen_request(va, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int va_macro_mclk_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tstruct va_macro *va = snd_soc_component_get_drvdata(comp);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn clk_prepare_enable(va->fsgen);\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tclk_disable_unprepare(va->fsgen);\n\t}\n\n\treturn 0;\n}\n\nstatic int va_macro_put_dec_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *widget =\n\t\tsnd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(widget->dapm);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int val;\n\tu16 mic_sel_reg;\n\n\tval = ucontrol->value.enumerated.item[0];\n\n\tswitch (e->reg) {\n\tcase CDC_VA_INP_MUX_ADC_MUX0_CFG0:\n\t\tmic_sel_reg = CDC_VA_TX0_TX_PATH_CFG0;\n\t\tbreak;\n\tcase CDC_VA_INP_MUX_ADC_MUX1_CFG0:\n\t\tmic_sel_reg = CDC_VA_TX1_TX_PATH_CFG0;\n\t\tbreak;\n\tcase CDC_VA_INP_MUX_ADC_MUX2_CFG0:\n\t\tmic_sel_reg = CDC_VA_TX2_TX_PATH_CFG0;\n\t\tbreak;\n\tcase CDC_VA_INP_MUX_ADC_MUX3_CFG0:\n\t\tmic_sel_reg = CDC_VA_TX3_TX_PATH_CFG0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: e->reg: 0x%x not expected\\n\",\n\t\t\t__func__, e->reg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (val != 0)\n\t\tsnd_soc_component_update_bits(component, mic_sel_reg,\n\t\t\t\t\t      CDC_VA_TX_PATH_ADC_DMIC_SEL_MASK,\n\t\t\t\t\t      CDC_VA_TX_PATH_ADC_DMIC_SEL_DMIC);\n\n\treturn snd_soc_dapm_put_enum_double(kcontrol, ucontrol);\n}\n\nstatic int va_macro_tx_mixer_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *widget =\n\t\tsnd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_component *component =\n\t\t\t\tsnd_soc_dapm_to_component(widget->dapm);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tu32 dai_id = widget->shift;\n\tu32 dec_id = mc->shift;\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\n\tif (test_bit(dec_id, &va->active_ch_mask[dai_id]))\n\t\tucontrol->value.integer.value[0] = 1;\n\telse\n\t\tucontrol->value.integer.value[0] = 0;\n\n\treturn 0;\n}\n\nstatic int va_macro_tx_mixer_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_widget *widget =\n\t\t\t\t\tsnd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_component *component =\n\t\t\t\tsnd_soc_dapm_to_component(widget->dapm);\n\tstruct snd_soc_dapm_update *update = NULL;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tu32 dai_id = widget->shift;\n\tu32 dec_id = mc->shift;\n\tu32 enable = ucontrol->value.integer.value[0];\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\n\tif (enable) {\n\t\tset_bit(dec_id, &va->active_ch_mask[dai_id]);\n\t\tva->active_ch_cnt[dai_id]++;\n\t} else {\n\t\tclear_bit(dec_id, &va->active_ch_mask[dai_id]);\n\t\tva->active_ch_cnt[dai_id]--;\n\t}\n\n\tsnd_soc_dapm_mixer_update_power(widget->dapm, kcontrol, enable, update);\n\n\treturn 0;\n}\n\nstatic int va_dmic_clk_enable(struct snd_soc_component *component,\n\t\t\t      u32 dmic, bool enable)\n{\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\tu16 dmic_clk_reg;\n\ts32 *dmic_clk_cnt;\n\tu8 *dmic_clk_div;\n\tu8 freq_change_mask;\n\tu8 clk_div;\n\n\tswitch (dmic) {\n\tcase 0:\n\tcase 1:\n\t\tdmic_clk_cnt = &(va->dmic_0_1_clk_cnt);\n\t\tdmic_clk_div = &(va->dmic_0_1_clk_div);\n\t\tdmic_clk_reg = CDC_VA_TOP_CSR_DMIC0_CTL;\n\t\tfreq_change_mask = CDC_VA_DMIC0_FREQ_CHANGE_MASK;\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tdmic_clk_cnt = &(va->dmic_2_3_clk_cnt);\n\t\tdmic_clk_div = &(va->dmic_2_3_clk_div);\n\t\tdmic_clk_reg = CDC_VA_TOP_CSR_DMIC1_CTL;\n\t\tfreq_change_mask = CDC_VA_DMIC1_FREQ_CHANGE_MASK;\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tdmic_clk_cnt = &(va->dmic_4_5_clk_cnt);\n\t\tdmic_clk_div = &(va->dmic_4_5_clk_div);\n\t\tdmic_clk_reg = CDC_VA_TOP_CSR_DMIC2_CTL;\n\t\tfreq_change_mask = CDC_VA_DMIC2_FREQ_CHANGE_MASK;\n\t\tbreak;\n\tcase 6:\n\tcase 7:\n\t\tdmic_clk_cnt = &(va->dmic_6_7_clk_cnt);\n\t\tdmic_clk_div = &(va->dmic_6_7_clk_div);\n\t\tdmic_clk_reg = CDC_VA_TOP_CSR_DMIC3_CTL;\n\t\tfreq_change_mask = CDC_VA_DMIC3_FREQ_CHANGE_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s: Invalid DMIC Selection\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (enable) {\n\t\tclk_div = va->dmic_clk_div;\n\t\t(*dmic_clk_cnt)++;\n\t\tif (*dmic_clk_cnt == 1) {\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t      CDC_VA_TOP_CSR_DMIC_CFG,\n\t\t\t\t\t      CDC_VA_RESET_ALL_DMICS_MASK,\n\t\t\t\t\t      CDC_VA_RESET_ALL_DMICS_DISABLE);\n\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\tCDC_VA_DMIC_CLK_SEL_MASK,\n\t\t\t\t\tclk_div << CDC_VA_DMIC_CLK_SEL_SHFT);\n\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\t\t      CDC_VA_DMIC_EN_MASK,\n\t\t\t\t\t\t      CDC_VA_DMIC_ENABLE);\n\t\t} else {\n\t\t\tif (*dmic_clk_div > clk_div) {\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\tCDC_VA_TOP_CSR_DMIC_CFG,\n\t\t\t\t\t\tfreq_change_mask,\n\t\t\t\t\t\tfreq_change_mask);\n\t\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\t\tCDC_VA_DMIC_CLK_SEL_MASK,\n\t\t\t\t\t\tclk_div << CDC_VA_DMIC_CLK_SEL_SHFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t      CDC_VA_TOP_CSR_DMIC_CFG,\n\t\t\t\t\t      freq_change_mask,\n\t\t\t\t\t      CDC_VA_DMIC_FREQ_CHANGE_DISABLE);\n\t\t\t} else {\n\t\t\t\tclk_div = *dmic_clk_div;\n\t\t\t}\n\t\t}\n\t\t*dmic_clk_div = clk_div;\n\t} else {\n\t\t(*dmic_clk_cnt)--;\n\t\tif (*dmic_clk_cnt  == 0) {\n\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\t\t      CDC_VA_DMIC_EN_MASK, 0);\n\t\t\tclk_div = 0;\n\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\t\tCDC_VA_DMIC_CLK_SEL_MASK,\n\t\t\t\t\t\tclk_div << CDC_VA_DMIC_CLK_SEL_SHFT);\n\t\t} else {\n\t\t\tclk_div = va->dmic_clk_div;\n\t\t\tif (*dmic_clk_div > clk_div) {\n\t\t\t\tclk_div = va->dmic_clk_div;\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t\tCDC_VA_TOP_CSR_DMIC_CFG,\n\t\t\t\t\t\t\tfreq_change_mask,\n\t\t\t\t\t\t\tfreq_change_mask);\n\t\t\t\tsnd_soc_component_update_bits(component, dmic_clk_reg,\n\t\t\t\t\t\tCDC_VA_DMIC_CLK_SEL_MASK,\n\t\t\t\t\t\tclk_div << CDC_VA_DMIC_CLK_SEL_SHFT);\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t      CDC_VA_TOP_CSR_DMIC_CFG,\n\t\t\t\t\t\t      freq_change_mask,\n\t\t\t\t\t\t      CDC_VA_DMIC_FREQ_CHANGE_DISABLE);\n\t\t\t} else {\n\t\t\t\tclk_div = *dmic_clk_div;\n\t\t\t}\n\t\t}\n\t\t*dmic_clk_div = clk_div;\n\t}\n\n\treturn 0;\n}\n\nstatic int va_macro_enable_dmic(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tunsigned int dmic = w->shift;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tva_dmic_clk_enable(comp, dmic, true);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tva_dmic_clk_enable(comp, dmic, false);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int va_macro_enable_dec(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tunsigned int decimator;\n\tu16 tx_vol_ctl_reg, dec_cfg_reg, hpf_gate_reg;\n\tu16 tx_gain_ctl_reg;\n\tu8 hpf_cut_off_freq;\n\n\tstruct va_macro *va = snd_soc_component_get_drvdata(comp);\n\n\tdecimator = w->shift;\n\n\ttx_vol_ctl_reg = CDC_VA_TX0_TX_PATH_CTL +\n\t\t\t\tVA_MACRO_TX_PATH_OFFSET * decimator;\n\thpf_gate_reg = CDC_VA_TX0_TX_PATH_SEC2 +\n\t\t\t\tVA_MACRO_TX_PATH_OFFSET * decimator;\n\tdec_cfg_reg = CDC_VA_TX0_TX_PATH_CFG0 +\n\t\t\t\tVA_MACRO_TX_PATH_OFFSET * decimator;\n\ttx_gain_ctl_reg = CDC_VA_TX0_TX_VOL_CTL +\n\t\t\t\tVA_MACRO_TX_PATH_OFFSET * decimator;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\tdec_cfg_reg, CDC_VA_ADC_MODE_MASK,\n\t\t\tva->dec_mode[decimator] << CDC_VA_ADC_MODE_SHIFT);\n\t\t \n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(comp, tx_vol_ctl_reg,\n\t\t\t\t\t      CDC_VA_TX_PATH_CLK_EN_MASK,\n\t\t\t\t\t      CDC_VA_TX_PATH_CLK_EN);\n\t\tsnd_soc_component_update_bits(comp, hpf_gate_reg,\n\t\t\t\t\t      CDC_VA_TX_HPF_ZERO_GATE_MASK,\n\t\t\t\t\t      CDC_VA_TX_HPF_ZERO_GATE);\n\n\t\tusleep_range(1000, 1010);\n\t\thpf_cut_off_freq = (snd_soc_component_read(comp, dec_cfg_reg) &\n\t\t\t\t    TX_HPF_CUT_OFF_FREQ_MASK) >> 5;\n\n\t\tif (hpf_cut_off_freq != CF_MIN_3DB_150HZ) {\n\t\t\tsnd_soc_component_update_bits(comp, dec_cfg_reg,\n\t\t\t\t\t\t      TX_HPF_CUT_OFF_FREQ_MASK,\n\t\t\t\t\t\t      CF_MIN_3DB_150HZ << 5);\n\n\t\t\tsnd_soc_component_update_bits(comp, hpf_gate_reg,\n\t\t\t\t      CDC_VA_TX_HPF_CUTOFF_FREQ_CHANGE_MASK,\n\t\t\t\t      CDC_VA_TX_HPF_CUTOFF_FREQ_CHANGE_REQ);\n\n\t\t\t \n\t\t\tusleep_range(1000, 1010);\n\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\thpf_gate_reg,\n\t\t\t\tCDC_VA_TX_HPF_CUTOFF_FREQ_CHANGE_MASK,\n\t\t\t\t0x0);\n\t\t}\n\n\n\t\tusleep_range(1000, 1010);\n\t\tsnd_soc_component_update_bits(comp, hpf_gate_reg,\n\t\t\t\t\t      CDC_VA_TX_HPF_ZERO_GATE_MASK,\n\t\t\t\t\t      CDC_VA_TX_HPF_ZERO_NO_GATE);\n\t\t \n\t\tusleep_range(6000, 6010);\n\t\t \n\t\tsnd_soc_component_write(comp, tx_gain_ctl_reg,\n\t\t\tsnd_soc_component_read(comp, tx_gain_ctl_reg));\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tsnd_soc_component_update_bits(comp, tx_vol_ctl_reg,\n\t\t\t\t\t\tCDC_VA_TX_PATH_CLK_EN_MASK,\n\t\t\t\t\t\tCDC_VA_TX_PATH_CLK_DISABLE);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int va_macro_dec_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct va_macro *va = snd_soc_component_get_drvdata(comp);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tint path = e->shift_l;\n\n\tucontrol->value.enumerated.item[0] = va->dec_mode[path];\n\n\treturn 0;\n}\n\nstatic int va_macro_dec_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tint value = ucontrol->value.enumerated.item[0];\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tint path = e->shift_l;\n\tstruct va_macro *va = snd_soc_component_get_drvdata(comp);\n\n\tva->dec_mode[path] = value;\n\n\treturn 0;\n}\n\nstatic int va_macro_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tint tx_fs_rate;\n\tstruct snd_soc_component *component = dai->component;\n\tu32 decimator, sample_rate;\n\tu16 tx_fs_reg;\n\tstruct device *va_dev = component->dev;\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\n\tsample_rate = params_rate(params);\n\tswitch (sample_rate) {\n\tcase 8000:\n\t\ttx_fs_rate = 0;\n\t\tbreak;\n\tcase 16000:\n\t\ttx_fs_rate = 1;\n\t\tbreak;\n\tcase 32000:\n\t\ttx_fs_rate = 3;\n\t\tbreak;\n\tcase 48000:\n\t\ttx_fs_rate = 4;\n\t\tbreak;\n\tcase 96000:\n\t\ttx_fs_rate = 5;\n\t\tbreak;\n\tcase 192000:\n\t\ttx_fs_rate = 6;\n\t\tbreak;\n\tcase 384000:\n\t\ttx_fs_rate = 7;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(va_dev, \"%s: Invalid TX sample rate: %d\\n\",\n\t\t\t__func__, params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_set_bit(decimator, &va->active_ch_mask[dai->id],\n\t\t\t VA_MACRO_DEC_MAX) {\n\t\ttx_fs_reg = CDC_VA_TX0_TX_PATH_CTL +\n\t\t\t    VA_MACRO_TX_PATH_OFFSET * decimator;\n\t\tsnd_soc_component_update_bits(component, tx_fs_reg, 0x0F,\n\t\t\t\t\t      tx_fs_rate);\n\t}\n\treturn 0;\n}\n\nstatic int va_macro_get_channel_map(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int *tx_num, unsigned int *tx_slot,\n\t\t\t\t    unsigned int *rx_num, unsigned int *rx_slot)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct device *va_dev = component->dev;\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\n\tswitch (dai->id) {\n\tcase VA_MACRO_AIF1_CAP:\n\tcase VA_MACRO_AIF2_CAP:\n\tcase VA_MACRO_AIF3_CAP:\n\t\t*tx_slot = va->active_ch_mask[dai->id];\n\t\t*tx_num = va->active_ch_cnt[dai->id];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(va_dev, \"%s: Invalid AIF\\n\", __func__);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int va_macro_digital_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\tu16 tx_vol_ctl_reg, decimator;\n\n\tfor_each_set_bit(decimator, &va->active_ch_mask[dai->id],\n\t\t\t VA_MACRO_DEC_MAX) {\n\t\ttx_vol_ctl_reg = CDC_VA_TX0_TX_PATH_CTL +\n\t\t\t\t\tVA_MACRO_TX_PATH_OFFSET * decimator;\n\t\tif (mute)\n\t\t\tsnd_soc_component_update_bits(component, tx_vol_ctl_reg,\n\t\t\t\t\tCDC_VA_TX_PATH_PGA_MUTE_EN_MASK,\n\t\t\t\t\tCDC_VA_TX_PATH_PGA_MUTE_EN);\n\t\telse\n\t\t\tsnd_soc_component_update_bits(component, tx_vol_ctl_reg,\n\t\t\t\t\tCDC_VA_TX_PATH_PGA_MUTE_EN_MASK,\n\t\t\t\t\tCDC_VA_TX_PATH_PGA_MUTE_DISABLE);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops va_macro_dai_ops = {\n\t.hw_params = va_macro_hw_params,\n\t.get_channel_map = va_macro_get_channel_map,\n\t.mute_stream = va_macro_digital_mute,\n};\n\nstatic struct snd_soc_dai_driver va_macro_dais[] = {\n\t{\n\t\t.name = \"va_macro_tx1\",\n\t\t.id = VA_MACRO_AIF1_CAP,\n\t\t.capture = {\n\t\t\t.stream_name = \"VA_AIF1 Capture\",\n\t\t\t.rates = VA_MACRO_RATES,\n\t\t\t.formats = VA_MACRO_FORMATS,\n\t\t\t.rate_max = 192000,\n\t\t\t.rate_min = 8000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t},\n\t\t.ops = &va_macro_dai_ops,\n\t},\n\t{\n\t\t.name = \"va_macro_tx2\",\n\t\t.id = VA_MACRO_AIF2_CAP,\n\t\t.capture = {\n\t\t\t.stream_name = \"VA_AIF2 Capture\",\n\t\t\t.rates = VA_MACRO_RATES,\n\t\t\t.formats = VA_MACRO_FORMATS,\n\t\t\t.rate_max = 192000,\n\t\t\t.rate_min = 8000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t},\n\t\t.ops = &va_macro_dai_ops,\n\t},\n\t{\n\t\t.name = \"va_macro_tx3\",\n\t\t.id = VA_MACRO_AIF3_CAP,\n\t\t.capture = {\n\t\t\t.stream_name = \"VA_AIF3 Capture\",\n\t\t\t.rates = VA_MACRO_RATES,\n\t\t\t.formats = VA_MACRO_FORMATS,\n\t\t\t.rate_max = 192000,\n\t\t\t.rate_min = 8000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t},\n\t\t.ops = &va_macro_dai_ops,\n\t},\n};\n\nstatic const char * const adc_mux_text[] = {\n\t\"VA_DMIC\", \"SWR_MIC\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(va_dec0_enum, CDC_VA_INP_MUX_ADC_MUX0_CFG1,\n\t\t   0, adc_mux_text);\nstatic SOC_ENUM_SINGLE_DECL(va_dec1_enum, CDC_VA_INP_MUX_ADC_MUX1_CFG1,\n\t\t   0, adc_mux_text);\nstatic SOC_ENUM_SINGLE_DECL(va_dec2_enum, CDC_VA_INP_MUX_ADC_MUX2_CFG1,\n\t\t   0, adc_mux_text);\nstatic SOC_ENUM_SINGLE_DECL(va_dec3_enum, CDC_VA_INP_MUX_ADC_MUX3_CFG1,\n\t\t   0, adc_mux_text);\n\nstatic const struct snd_kcontrol_new va_dec0_mux = SOC_DAPM_ENUM(\"va_dec0\",\n\t\t\t\t\t\t\t\t va_dec0_enum);\nstatic const struct snd_kcontrol_new va_dec1_mux = SOC_DAPM_ENUM(\"va_dec1\",\n\t\t\t\t\t\t\t\t va_dec1_enum);\nstatic const struct snd_kcontrol_new va_dec2_mux = SOC_DAPM_ENUM(\"va_dec2\",\n\t\t\t\t\t\t\t\t va_dec2_enum);\nstatic const struct snd_kcontrol_new va_dec3_mux = SOC_DAPM_ENUM(\"va_dec3\",\n\t\t\t\t\t\t\t\t va_dec3_enum);\n\nstatic const char * const dmic_mux_text[] = {\n\t\"ZERO\", \"DMIC0\", \"DMIC1\", \"DMIC2\", \"DMIC3\",\n\t\"DMIC4\", \"DMIC5\", \"DMIC6\", \"DMIC7\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(va_dmic0_enum, CDC_VA_INP_MUX_ADC_MUX0_CFG0,\n\t\t\t4, dmic_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(va_dmic1_enum, CDC_VA_INP_MUX_ADC_MUX1_CFG0,\n\t\t\t4, dmic_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(va_dmic2_enum, CDC_VA_INP_MUX_ADC_MUX2_CFG0,\n\t\t\t4, dmic_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(va_dmic3_enum, CDC_VA_INP_MUX_ADC_MUX3_CFG0,\n\t\t\t4, dmic_mux_text);\n\nstatic const struct snd_kcontrol_new va_dmic0_mux = SOC_DAPM_ENUM_EXT(\"va_dmic0\",\n\t\t\t va_dmic0_enum, snd_soc_dapm_get_enum_double,\n\t\t\t va_macro_put_dec_enum);\n\nstatic const struct snd_kcontrol_new va_dmic1_mux = SOC_DAPM_ENUM_EXT(\"va_dmic1\",\n\t\t\t va_dmic1_enum, snd_soc_dapm_get_enum_double,\n\t\t\t va_macro_put_dec_enum);\n\nstatic const struct snd_kcontrol_new va_dmic2_mux = SOC_DAPM_ENUM_EXT(\"va_dmic2\",\n\t\t\t va_dmic2_enum, snd_soc_dapm_get_enum_double,\n\t\t\t va_macro_put_dec_enum);\n\nstatic const struct snd_kcontrol_new va_dmic3_mux = SOC_DAPM_ENUM_EXT(\"va_dmic3\",\n\t\t\t va_dmic3_enum, snd_soc_dapm_get_enum_double,\n\t\t\t va_macro_put_dec_enum);\n\nstatic const struct snd_kcontrol_new va_aif1_cap_mixer[] = {\n\tSOC_SINGLE_EXT(\"DEC0\", SND_SOC_NOPM, VA_MACRO_DEC0, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC1\", SND_SOC_NOPM, VA_MACRO_DEC1, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC2\", SND_SOC_NOPM, VA_MACRO_DEC2, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC3\", SND_SOC_NOPM, VA_MACRO_DEC3, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC4\", SND_SOC_NOPM, VA_MACRO_DEC4, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC5\", SND_SOC_NOPM, VA_MACRO_DEC5, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC6\", SND_SOC_NOPM, VA_MACRO_DEC6, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC7\", SND_SOC_NOPM, VA_MACRO_DEC7, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n};\n\nstatic const struct snd_kcontrol_new va_aif2_cap_mixer[] = {\n\tSOC_SINGLE_EXT(\"DEC0\", SND_SOC_NOPM, VA_MACRO_DEC0, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC1\", SND_SOC_NOPM, VA_MACRO_DEC1, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC2\", SND_SOC_NOPM, VA_MACRO_DEC2, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC3\", SND_SOC_NOPM, VA_MACRO_DEC3, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC4\", SND_SOC_NOPM, VA_MACRO_DEC4, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC5\", SND_SOC_NOPM, VA_MACRO_DEC5, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC6\", SND_SOC_NOPM, VA_MACRO_DEC6, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC7\", SND_SOC_NOPM, VA_MACRO_DEC7, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n};\n\nstatic const struct snd_kcontrol_new va_aif3_cap_mixer[] = {\n\tSOC_SINGLE_EXT(\"DEC0\", SND_SOC_NOPM, VA_MACRO_DEC0, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC1\", SND_SOC_NOPM, VA_MACRO_DEC1, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC2\", SND_SOC_NOPM, VA_MACRO_DEC2, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC3\", SND_SOC_NOPM, VA_MACRO_DEC3, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC4\", SND_SOC_NOPM, VA_MACRO_DEC4, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC5\", SND_SOC_NOPM, VA_MACRO_DEC5, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC6\", SND_SOC_NOPM, VA_MACRO_DEC6, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n\tSOC_SINGLE_EXT(\"DEC7\", SND_SOC_NOPM, VA_MACRO_DEC7, 1, 0,\n\t\t\tva_macro_tx_mixer_get, va_macro_tx_mixer_put),\n};\n\nstatic const struct snd_soc_dapm_widget va_macro_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_OUT(\"VA_AIF1 CAP\", \"VA_AIF1 Capture\", 0,\n\t\tSND_SOC_NOPM, VA_MACRO_AIF1_CAP, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"VA_AIF2 CAP\", \"VA_AIF2 Capture\", 0,\n\t\tSND_SOC_NOPM, VA_MACRO_AIF2_CAP, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"VA_AIF3 CAP\", \"VA_AIF3 Capture\", 0,\n\t\tSND_SOC_NOPM, VA_MACRO_AIF3_CAP, 0),\n\n\tSND_SOC_DAPM_MIXER(\"VA_AIF1_CAP Mixer\", SND_SOC_NOPM,\n\t\tVA_MACRO_AIF1_CAP, 0,\n\t\tva_aif1_cap_mixer, ARRAY_SIZE(va_aif1_cap_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"VA_AIF2_CAP Mixer\", SND_SOC_NOPM,\n\t\tVA_MACRO_AIF2_CAP, 0,\n\t\tva_aif2_cap_mixer, ARRAY_SIZE(va_aif2_cap_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"VA_AIF3_CAP Mixer\", SND_SOC_NOPM,\n\t\tVA_MACRO_AIF3_CAP, 0,\n\t\tva_aif3_cap_mixer, ARRAY_SIZE(va_aif3_cap_mixer)),\n\n\tSND_SOC_DAPM_MUX(\"VA DMIC MUX0\", SND_SOC_NOPM, 0, 0, &va_dmic0_mux),\n\tSND_SOC_DAPM_MUX(\"VA DMIC MUX1\", SND_SOC_NOPM, 0, 0, &va_dmic1_mux),\n\tSND_SOC_DAPM_MUX(\"VA DMIC MUX2\", SND_SOC_NOPM, 0, 0, &va_dmic2_mux),\n\tSND_SOC_DAPM_MUX(\"VA DMIC MUX3\", SND_SOC_NOPM, 0, 0, &va_dmic3_mux),\n\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"vdd-micb\", 0, 0),\n\tSND_SOC_DAPM_INPUT(\"DMIC0 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC1 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC3 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC4 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC5 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC6 Pin\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC7 Pin\"),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC0\", NULL, SND_SOC_NOPM, 0, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC1\", NULL, SND_SOC_NOPM, 1, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC2\", NULL, SND_SOC_NOPM, 2, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC3\", NULL, SND_SOC_NOPM, 3, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC4\", NULL, SND_SOC_NOPM, 4, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC5\", NULL, SND_SOC_NOPM, 5, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC6\", NULL, SND_SOC_NOPM, 6, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_ADC_E(\"VA DMIC7\", NULL, SND_SOC_NOPM, 7, 0,\n\t\tva_macro_enable_dmic, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_INPUT(\"VA SWR_ADC0\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_ADC1\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_ADC2\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_ADC3\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC0\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC3\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC4\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC5\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC6\"),\n\tSND_SOC_DAPM_INPUT(\"VA SWR_MIC7\"),\n\n\tSND_SOC_DAPM_MUX_E(\"VA DEC0 MUX\", SND_SOC_NOPM, VA_MACRO_DEC0, 0,\n\t\t\t   &va_dec0_mux, va_macro_enable_dec,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MUX_E(\"VA DEC1 MUX\", SND_SOC_NOPM, VA_MACRO_DEC1, 0,\n\t\t\t   &va_dec1_mux, va_macro_enable_dec,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MUX_E(\"VA DEC2 MUX\", SND_SOC_NOPM, VA_MACRO_DEC2, 0,\n\t\t\t   &va_dec2_mux, va_macro_enable_dec,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MUX_E(\"VA DEC3 MUX\", SND_SOC_NOPM, VA_MACRO_DEC3, 0,\n\t\t\t   &va_dec3_mux, va_macro_enable_dec,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"VA_MCLK\", -1, SND_SOC_NOPM, 0, 0,\n\t\t\t      va_macro_mclk_event,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route va_audio_map[] = {\n\t{\"VA_AIF1 CAP\", NULL, \"VA_MCLK\"},\n\t{\"VA_AIF2 CAP\", NULL, \"VA_MCLK\"},\n\t{\"VA_AIF3 CAP\", NULL, \"VA_MCLK\"},\n\n\t{\"VA_AIF1 CAP\", NULL, \"VA_AIF1_CAP Mixer\"},\n\t{\"VA_AIF2 CAP\", NULL, \"VA_AIF2_CAP Mixer\"},\n\t{\"VA_AIF3 CAP\", NULL, \"VA_AIF3_CAP Mixer\"},\n\n\t{\"VA_AIF1_CAP Mixer\", \"DEC0\", \"VA DEC0 MUX\"},\n\t{\"VA_AIF1_CAP Mixer\", \"DEC1\", \"VA DEC1 MUX\"},\n\t{\"VA_AIF1_CAP Mixer\", \"DEC2\", \"VA DEC2 MUX\"},\n\t{\"VA_AIF1_CAP Mixer\", \"DEC3\", \"VA DEC3 MUX\"},\n\n\t{\"VA_AIF2_CAP Mixer\", \"DEC0\", \"VA DEC0 MUX\"},\n\t{\"VA_AIF2_CAP Mixer\", \"DEC1\", \"VA DEC1 MUX\"},\n\t{\"VA_AIF2_CAP Mixer\", \"DEC2\", \"VA DEC2 MUX\"},\n\t{\"VA_AIF2_CAP Mixer\", \"DEC3\", \"VA DEC3 MUX\"},\n\n\t{\"VA_AIF3_CAP Mixer\", \"DEC0\", \"VA DEC0 MUX\"},\n\t{\"VA_AIF3_CAP Mixer\", \"DEC1\", \"VA DEC1 MUX\"},\n\t{\"VA_AIF3_CAP Mixer\", \"DEC2\", \"VA DEC2 MUX\"},\n\t{\"VA_AIF3_CAP Mixer\", \"DEC3\", \"VA DEC3 MUX\"},\n\n\t{\"VA DEC0 MUX\", \"VA_DMIC\", \"VA DMIC MUX0\"},\n\t{\"VA DMIC MUX0\", \"DMIC0\", \"VA DMIC0\"},\n\t{\"VA DMIC MUX0\", \"DMIC1\", \"VA DMIC1\"},\n\t{\"VA DMIC MUX0\", \"DMIC2\", \"VA DMIC2\"},\n\t{\"VA DMIC MUX0\", \"DMIC3\", \"VA DMIC3\"},\n\t{\"VA DMIC MUX0\", \"DMIC4\", \"VA DMIC4\"},\n\t{\"VA DMIC MUX0\", \"DMIC5\", \"VA DMIC5\"},\n\t{\"VA DMIC MUX0\", \"DMIC6\", \"VA DMIC6\"},\n\t{\"VA DMIC MUX0\", \"DMIC7\", \"VA DMIC7\"},\n\n\t{\"VA DEC1 MUX\", \"VA_DMIC\", \"VA DMIC MUX1\"},\n\t{\"VA DMIC MUX1\", \"DMIC0\", \"VA DMIC0\"},\n\t{\"VA DMIC MUX1\", \"DMIC1\", \"VA DMIC1\"},\n\t{\"VA DMIC MUX1\", \"DMIC2\", \"VA DMIC2\"},\n\t{\"VA DMIC MUX1\", \"DMIC3\", \"VA DMIC3\"},\n\t{\"VA DMIC MUX1\", \"DMIC4\", \"VA DMIC4\"},\n\t{\"VA DMIC MUX1\", \"DMIC5\", \"VA DMIC5\"},\n\t{\"VA DMIC MUX1\", \"DMIC6\", \"VA DMIC6\"},\n\t{\"VA DMIC MUX1\", \"DMIC7\", \"VA DMIC7\"},\n\n\t{\"VA DEC2 MUX\", \"VA_DMIC\", \"VA DMIC MUX2\"},\n\t{\"VA DMIC MUX2\", \"DMIC0\", \"VA DMIC0\"},\n\t{\"VA DMIC MUX2\", \"DMIC1\", \"VA DMIC1\"},\n\t{\"VA DMIC MUX2\", \"DMIC2\", \"VA DMIC2\"},\n\t{\"VA DMIC MUX2\", \"DMIC3\", \"VA DMIC3\"},\n\t{\"VA DMIC MUX2\", \"DMIC4\", \"VA DMIC4\"},\n\t{\"VA DMIC MUX2\", \"DMIC5\", \"VA DMIC5\"},\n\t{\"VA DMIC MUX2\", \"DMIC6\", \"VA DMIC6\"},\n\t{\"VA DMIC MUX2\", \"DMIC7\", \"VA DMIC7\"},\n\n\t{\"VA DEC3 MUX\", \"VA_DMIC\", \"VA DMIC MUX3\"},\n\t{\"VA DMIC MUX3\", \"DMIC0\", \"VA DMIC0\"},\n\t{\"VA DMIC MUX3\", \"DMIC1\", \"VA DMIC1\"},\n\t{\"VA DMIC MUX3\", \"DMIC2\", \"VA DMIC2\"},\n\t{\"VA DMIC MUX3\", \"DMIC3\", \"VA DMIC3\"},\n\t{\"VA DMIC MUX3\", \"DMIC4\", \"VA DMIC4\"},\n\t{\"VA DMIC MUX3\", \"DMIC5\", \"VA DMIC5\"},\n\t{\"VA DMIC MUX3\", \"DMIC6\", \"VA DMIC6\"},\n\t{\"VA DMIC MUX3\", \"DMIC7\", \"VA DMIC7\"},\n\n\t{ \"VA DMIC0\", NULL, \"DMIC0 Pin\" },\n\t{ \"VA DMIC1\", NULL, \"DMIC1 Pin\" },\n\t{ \"VA DMIC2\", NULL, \"DMIC2 Pin\" },\n\t{ \"VA DMIC3\", NULL, \"DMIC3 Pin\" },\n\t{ \"VA DMIC4\", NULL, \"DMIC4 Pin\" },\n\t{ \"VA DMIC5\", NULL, \"DMIC5 Pin\" },\n\t{ \"VA DMIC6\", NULL, \"DMIC6 Pin\" },\n\t{ \"VA DMIC7\", NULL, \"DMIC7 Pin\" },\n};\n\nstatic const char * const dec_mode_mux_text[] = {\n\t\"ADC_DEFAULT\", \"ADC_LOW_PWR\", \"ADC_HIGH_PERF\",\n};\n\nstatic const struct soc_enum dec_mode_mux_enum[] = {\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(dec_mode_mux_text),\n\t\t\tdec_mode_mux_text),\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 1, ARRAY_SIZE(dec_mode_mux_text),\n\t\t\tdec_mode_mux_text),\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 2,  ARRAY_SIZE(dec_mode_mux_text),\n\t\t\tdec_mode_mux_text),\n\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 3, ARRAY_SIZE(dec_mode_mux_text),\n\t\t\tdec_mode_mux_text),\n};\n\nstatic const struct snd_kcontrol_new va_macro_snd_controls[] = {\n\tSOC_SINGLE_S8_TLV(\"VA_DEC0 Volume\", CDC_VA_TX0_TX_VOL_CTL,\n\t\t\t  -84, 40, digital_gain),\n\tSOC_SINGLE_S8_TLV(\"VA_DEC1 Volume\", CDC_VA_TX1_TX_VOL_CTL,\n\t\t\t  -84, 40, digital_gain),\n\tSOC_SINGLE_S8_TLV(\"VA_DEC2 Volume\", CDC_VA_TX2_TX_VOL_CTL,\n\t\t\t  -84, 40, digital_gain),\n\tSOC_SINGLE_S8_TLV(\"VA_DEC3 Volume\", CDC_VA_TX3_TX_VOL_CTL,\n\t\t\t  -84, 40, digital_gain),\n\n\tSOC_ENUM_EXT(\"VA_DEC0 MODE\", dec_mode_mux_enum[0],\n\t\t     va_macro_dec_mode_get, va_macro_dec_mode_put),\n\tSOC_ENUM_EXT(\"VA_DEC1 MODE\", dec_mode_mux_enum[1],\n\t\t     va_macro_dec_mode_get, va_macro_dec_mode_put),\n\tSOC_ENUM_EXT(\"VA_DEC2 MODE\", dec_mode_mux_enum[2],\n\t\t     va_macro_dec_mode_get, va_macro_dec_mode_put),\n\tSOC_ENUM_EXT(\"VA_DEC3 MODE\", dec_mode_mux_enum[3],\n\t\t     va_macro_dec_mode_get, va_macro_dec_mode_put),\n};\n\nstatic int va_macro_component_probe(struct snd_soc_component *component)\n{\n\tstruct va_macro *va = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_init_regmap(component, va->regmap);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver va_macro_component_drv = {\n\t.name = \"VA MACRO\",\n\t.probe = va_macro_component_probe,\n\t.controls = va_macro_snd_controls,\n\t.num_controls = ARRAY_SIZE(va_macro_snd_controls),\n\t.dapm_widgets = va_macro_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(va_macro_dapm_widgets),\n\t.dapm_routes = va_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(va_audio_map),\n};\n\nstatic int fsgen_gate_enable(struct clk_hw *hw)\n{\n\tstruct va_macro *va = to_va_macro(hw);\n\tstruct regmap *regmap = va->regmap;\n\tint ret;\n\n\tret = va_macro_mclk_enable(va, true);\n\tif (va->has_swr_master)\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_SWR_CONTROL,\n\t\t\t\t   CDC_VA_SWR_CLK_EN_MASK, CDC_VA_SWR_CLK_ENABLE);\n\n\treturn ret;\n}\n\nstatic void fsgen_gate_disable(struct clk_hw *hw)\n{\n\tstruct va_macro *va = to_va_macro(hw);\n\tstruct regmap *regmap = va->regmap;\n\n\tif (va->has_swr_master)\n\t\tregmap_update_bits(regmap, CDC_VA_CLK_RST_CTRL_SWR_CONTROL,\n\t\t\t   CDC_VA_SWR_CLK_EN_MASK, 0x0);\n\n\tva_macro_mclk_enable(va, false);\n}\n\nstatic int fsgen_gate_is_enabled(struct clk_hw *hw)\n{\n\tstruct va_macro *va = to_va_macro(hw);\n\tint val;\n\n\tregmap_read(va->regmap, CDC_VA_TOP_CSR_TOP_CFG0, &val);\n\n\treturn  !!(val & CDC_VA_FS_BROADCAST_EN);\n}\n\nstatic const struct clk_ops fsgen_gate_ops = {\n\t.prepare = fsgen_gate_enable,\n\t.unprepare = fsgen_gate_disable,\n\t.is_enabled = fsgen_gate_is_enabled,\n};\n\nstatic int va_macro_register_fsgen_output(struct va_macro *va)\n{\n\tstruct clk *parent = va->mclk;\n\tstruct device *dev = va->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst char *parent_clk_name;\n\tconst char *clk_name = \"fsgen\";\n\tstruct clk_init_data init;\n\tint ret;\n\n\tparent_clk_name = __clk_get_name(parent);\n\n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\n\tinit.name = clk_name;\n\tinit.ops = &fsgen_gate_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &parent_clk_name;\n\tinit.num_parents = 1;\n\tva->hw.init = &init;\n\tret = devm_clk_hw_register(va->dev, &va->hw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, &va->hw);\n}\n\nstatic int va_macro_validate_dmic_sample_rate(u32 dmic_sample_rate,\n\t\t\t\t\t      struct va_macro *va)\n{\n\tu32 div_factor;\n\tu32 mclk_rate = VA_MACRO_MCLK_FREQ;\n\n\tif (!dmic_sample_rate || mclk_rate % dmic_sample_rate != 0)\n\t\tgoto undefined_rate;\n\n\tdiv_factor = mclk_rate / dmic_sample_rate;\n\n\tswitch (div_factor) {\n\tcase 2:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_2;\n\t\tbreak;\n\tcase 3:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_3;\n\t\tbreak;\n\tcase 4:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_4;\n\t\tbreak;\n\tcase 6:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_6;\n\t\tbreak;\n\tcase 8:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_8;\n\t\tbreak;\n\tcase 16:\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_16;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto undefined_rate;\n\t}\n\n\treturn dmic_sample_rate;\n\nundefined_rate:\n\tdev_err(va->dev, \"%s: Invalid rate %d, for mclk %d\\n\",\n\t\t__func__, dmic_sample_rate, mclk_rate);\n\tdmic_sample_rate = 0;\n\n\treturn dmic_sample_rate;\n}\n\nstatic int va_macro_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct va_macro_data *data;\n\tstruct va_macro *va;\n\tvoid __iomem *base;\n\tu32 sample_rate = 0;\n\tint ret;\n\n\tva = devm_kzalloc(dev, sizeof(*va), GFP_KERNEL);\n\tif (!va)\n\t\treturn -ENOMEM;\n\n\tva->dev = dev;\n\n\tva->macro = devm_clk_get_optional(dev, \"macro\");\n\tif (IS_ERR(va->macro))\n\t\treturn dev_err_probe(dev, PTR_ERR(va->macro), \"unable to get macro clock\\n\");\n\n\tva->dcodec = devm_clk_get_optional(dev, \"dcodec\");\n\tif (IS_ERR(va->dcodec))\n\t\treturn dev_err_probe(dev, PTR_ERR(va->dcodec), \"unable to get dcodec clock\\n\");\n\n\tva->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(va->mclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(va->mclk), \"unable to get mclk clock\\n\");\n\n\tva->pds = lpass_macro_pds_init(dev);\n\tif (IS_ERR(va->pds))\n\t\treturn PTR_ERR(va->pds);\n\n\tret = of_property_read_u32(dev->of_node, \"qcom,dmic-sample-rate\",\n\t\t\t\t   &sample_rate);\n\tif (ret) {\n\t\tdev_err(dev, \"qcom,dmic-sample-rate dt entry missing\\n\");\n\t\tva->dmic_clk_div = VA_MACRO_CLK_DIV_2;\n\t} else {\n\t\tret = va_macro_validate_dmic_sample_rate(sample_rate, va);\n\t\tif (!ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto err;\n\t}\n\n\tva->regmap = devm_regmap_init_mmio(dev, base,  &va_regmap_config);\n\tif (IS_ERR(va->regmap)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdev_set_drvdata(dev, va);\n\n\tdata = of_device_get_match_data(dev);\n\tva->has_swr_master = data->has_swr_master;\n\n\t \n\tclk_set_rate(va->mclk, 2 * VA_MACRO_MCLK_FREQ);\n\n\tret = clk_prepare_enable(va->macro);\n\tif (ret)\n\t\tgoto err;\n\n\tret = clk_prepare_enable(va->dcodec);\n\tif (ret)\n\t\tgoto err_dcodec;\n\n\tret = clk_prepare_enable(va->mclk);\n\tif (ret)\n\t\tgoto err_mclk;\n\n\tif (va->has_swr_master) {\n\t\t \n\t\tregmap_update_bits(va->regmap, CDC_VA_TOP_CSR_SWR_MIC_CTL0,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_MASK,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_DIV1);\n\t\tregmap_update_bits(va->regmap, CDC_VA_TOP_CSR_SWR_MIC_CTL1,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_MASK,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_DIV1);\n\t\tregmap_update_bits(va->regmap, CDC_VA_TOP_CSR_SWR_MIC_CTL2,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_MASK,\n\t\t\t\t  CDC_VA_SWR_MIC_CLK_SEL_0_1_DIV1);\n\n\t}\n\n\tif (va->has_swr_master) {\n\t\tregmap_update_bits(va->regmap, CDC_VA_CLK_RST_CTRL_SWR_CONTROL,\n\t\t\t\t   CDC_VA_SWR_RESET_MASK,  CDC_VA_SWR_RESET_ENABLE);\n\t\tregmap_update_bits(va->regmap, CDC_VA_CLK_RST_CTRL_SWR_CONTROL,\n\t\t\t\t   CDC_VA_SWR_CLK_EN_MASK, CDC_VA_SWR_CLK_ENABLE);\n\t\tregmap_update_bits(va->regmap, CDC_VA_CLK_RST_CTRL_SWR_CONTROL,\n\t\t\t\t   CDC_VA_SWR_RESET_MASK, 0x0);\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &va_macro_component_drv,\n\t\t\t\t\t      va_macro_dais,\n\t\t\t\t\t      ARRAY_SIZE(va_macro_dais));\n\tif (ret)\n\t\tgoto err_clkout;\n\n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tret = va_macro_register_fsgen_output(va);\n\tif (ret)\n\t\tgoto err_clkout;\n\n\tva->fsgen = clk_hw_get_clk(&va->hw, \"fsgen\");\n\tif (IS_ERR(va->fsgen)) {\n\t\tret = PTR_ERR(va->fsgen);\n\t\tgoto err_clkout;\n\t}\n\n\treturn 0;\n\nerr_clkout:\n\tclk_disable_unprepare(va->mclk);\nerr_mclk:\n\tclk_disable_unprepare(va->dcodec);\nerr_dcodec:\n\tclk_disable_unprepare(va->macro);\nerr:\n\tlpass_macro_pds_exit(va->pds);\n\n\treturn ret;\n}\n\nstatic void va_macro_remove(struct platform_device *pdev)\n{\n\tstruct va_macro *va = dev_get_drvdata(&pdev->dev);\n\n\tclk_disable_unprepare(va->mclk);\n\tclk_disable_unprepare(va->dcodec);\n\tclk_disable_unprepare(va->macro);\n\n\tlpass_macro_pds_exit(va->pds);\n}\n\nstatic int __maybe_unused va_macro_runtime_suspend(struct device *dev)\n{\n\tstruct va_macro *va = dev_get_drvdata(dev);\n\n\tregcache_cache_only(va->regmap, true);\n\tregcache_mark_dirty(va->regmap);\n\n\tclk_disable_unprepare(va->mclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused va_macro_runtime_resume(struct device *dev)\n{\n\tstruct va_macro *va = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(va->mclk);\n\tif (ret) {\n\t\tdev_err(va->dev, \"unable to prepare mclk\\n\");\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(va->regmap, false);\n\tregcache_sync(va->regmap);\n\n\treturn 0;\n}\n\n\nstatic const struct dev_pm_ops va_macro_pm_ops = {\n\tSET_RUNTIME_PM_OPS(va_macro_runtime_suspend, va_macro_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id va_macro_dt_match[] = {\n\t{ .compatible = \"qcom,sc7280-lpass-va-macro\", .data = &sm8250_va_data },\n\t{ .compatible = \"qcom,sm8250-lpass-va-macro\", .data = &sm8250_va_data },\n\t{ .compatible = \"qcom,sm8450-lpass-va-macro\", .data = &sm8450_va_data },\n\t{ .compatible = \"qcom,sc8280xp-lpass-va-macro\", .data = &sm8450_va_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, va_macro_dt_match);\n\nstatic struct platform_driver va_macro_driver = {\n\t.driver = {\n\t\t.name = \"va_macro\",\n\t\t.of_match_table = va_macro_dt_match,\n\t\t.suppress_bind_attrs = true,\n\t\t.pm = &va_macro_pm_ops,\n\t},\n\t.probe = va_macro_probe,\n\t.remove_new = va_macro_remove,\n};\n\nmodule_platform_driver(va_macro_driver);\nMODULE_DESCRIPTION(\"VA macro driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}