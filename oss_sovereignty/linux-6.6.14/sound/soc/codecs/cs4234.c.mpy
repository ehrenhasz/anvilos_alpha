{
  "module_name": "cs4234.c",
  "hash_id": "01237667a3f5155f6070df9791cbd870317fc1f3c07338f9712ab8cba79b772d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4234.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/workqueue.h>\n\n#include \"cs4234.h\"\n\nstruct cs4234 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpio;\n\tstruct regulator_bulk_data core_supplies[2];\n\tint num_core_supplies;\n\tstruct completion vq_ramp_complete;\n\tstruct delayed_work vq_ramp_delay;\n\tstruct clk *mclk;\n\tunsigned long mclk_rate;\n\tunsigned long lrclk_rate;\n\tunsigned int format;\n\tstruct snd_ratnum rate_dividers[2];\n\tstruct snd_pcm_hw_constraint_ratnums rate_constraint;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -8992, 38, 0);\n\nstatic const char * const cs4234_dac14_delay_text[] = {\n\t  \"0us\", \"100us\", \"150us\", \"200us\", \"225us\", \"250us\", \"275us\", \"300us\",\n\t\"325us\", \"350us\", \"375us\", \"400us\", \"425us\", \"450us\", \"475us\", \"500us\",\n};\nstatic SOC_ENUM_SINGLE_DECL(cs4234_dac14_group_delay, CS4234_TPS_CTRL,\n\t\t\t    CS4234_GRP_DELAY_SHIFT, cs4234_dac14_delay_text);\n\nstatic const char * const cs4234_noise_gate_text[] = {\n\t\"72dB\",  \"78dB\",  \"84dB\", \"90dB\", \"96dB\", \"102dB\", \"138dB\", \"Disabled\",\n};\nstatic SOC_ENUM_SINGLE_DECL(cs4234_ll_noise_gate, CS4234_LOW_LAT_CTRL1,\n\t\t\t    CS4234_LL_NG_SHIFT, cs4234_noise_gate_text);\nstatic SOC_ENUM_SINGLE_DECL(cs4234_dac14_noise_gate, CS4234_DAC_CTRL1,\n\t\t\t    CS4234_DAC14_NG_SHIFT, cs4234_noise_gate_text);\nstatic SOC_ENUM_SINGLE_DECL(cs4234_dac5_noise_gate, CS4234_DAC_CTRL2,\n\t\t\t    CS4234_DAC5_NG_SHIFT, cs4234_noise_gate_text);\n\nstatic const char * const cs4234_dac5_config_fltr_sel_text[] = {\n\t\"Interpolation Filter\", \"Sample and Hold\"\n};\nstatic SOC_ENUM_SINGLE_DECL(cs4234_dac5_config_fltr_sel, CS4234_DAC_CTRL1,\n\t\t\t    CS4234_DAC5_CFG_FLTR_SHIFT,\n\t\t\t    cs4234_dac5_config_fltr_sel_text);\n\nstatic const char * const cs4234_mute_delay_text[] = {\n\t\"1x\",  \"4x\",  \"16x\", \"64x\",\n};\nstatic SOC_ENUM_SINGLE_DECL(cs4234_mute_delay, CS4234_VOLUME_MODE,\n\t\t\t    CS4234_MUTE_DELAY_SHIFT, cs4234_mute_delay_text);\n\nstatic const char * const cs4234_minmax_delay_text[] = {\n\t\"1x\",  \"2x\",  \"4x\", \"8x\", \"16x\",  \"32x\", \"64x\", \"128x\",\n};\nstatic SOC_ENUM_SINGLE_DECL(cs4234_min_delay, CS4234_VOLUME_MODE,\n\t\t\t    CS4234_MIN_DELAY_SHIFT, cs4234_minmax_delay_text);\nstatic SOC_ENUM_SINGLE_DECL(cs4234_max_delay, CS4234_VOLUME_MODE,\n\t\t\t    CS4234_MAX_DELAY_SHIFT, cs4234_minmax_delay_text);\n\nstatic int cs4234_dac14_grp_delay_put(struct snd_kcontrol *kctrl,\n\t\t\t\t      struct snd_ctl_elem_value *uctrl)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kctrl);\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tunsigned int val = 0;\n\tint ret = 0;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tregmap_read(cs4234->regmap, CS4234_ADC_CTRL2, &val);\n\tif ((val & 0x0F) != 0x0F) { \n\t\tret = -EBUSY;\n\t\tdev_err(component->dev, \"Can't change group delay while ADC are ON\\n\");\n\t\tgoto exit;\n\t}\n\n\tregmap_read(cs4234->regmap, CS4234_DAC_CTRL4, &val);\n\tif ((val & 0x1F) != 0x1F) { \n\t\tret = -EBUSY;\n\t\tdev_err(component->dev, \"Can't change group delay while DAC are ON\\n\");\n\t\tgoto exit;\n\t}\n\n\tret = snd_soc_put_enum_double(kctrl, uctrl);\nexit:\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn ret;\n}\n\nstatic void cs4234_vq_ramp_done(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct cs4234 *cs4234 = container_of(dw, struct cs4234, vq_ramp_delay);\n\n\tcomplete_all(&cs4234->vq_ramp_complete);\n}\n\nstatic int cs4234_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tswitch (snd_soc_component_get_bias_level(component)) {\n\t\tcase SND_SOC_BIAS_STANDBY:\n\t\t\twait_for_completion(&cs4234->vq_ramp_complete);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs4234_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"SDRX1\", NULL,  0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDRX2\", NULL,  1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDRX3\", NULL,  2, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDRX4\", NULL,  3, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"SDRX5\", NULL,  4, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_DAC(\"DAC1\", NULL, CS4234_DAC_CTRL4, CS4234_PDN_DAC1_SHIFT, 1),\n\tSND_SOC_DAPM_DAC(\"DAC2\", NULL, CS4234_DAC_CTRL4, CS4234_PDN_DAC2_SHIFT, 1),\n\tSND_SOC_DAPM_DAC(\"DAC3\", NULL, CS4234_DAC_CTRL4, CS4234_PDN_DAC3_SHIFT, 1),\n\tSND_SOC_DAPM_DAC(\"DAC4\", NULL, CS4234_DAC_CTRL4, CS4234_PDN_DAC4_SHIFT, 1),\n\tSND_SOC_DAPM_DAC(\"DAC5\", NULL, CS4234_DAC_CTRL4, CS4234_PDN_DAC5_SHIFT, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"AOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT4\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT5\"),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC1\", NULL, CS4234_ADC_CTRL2, CS4234_PDN_ADC1_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC2\", NULL, CS4234_ADC_CTRL2, CS4234_PDN_ADC2_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC3\", NULL, CS4234_ADC_CTRL2, CS4234_PDN_ADC3_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC4\", NULL, CS4234_ADC_CTRL2, CS4234_PDN_ADC4_SHIFT, 1),\n\n\tSND_SOC_DAPM_AIF_OUT(\"SDTX1\", NULL, 0, SND_SOC_NOPM, 0, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"SDTX2\", NULL, 1, SND_SOC_NOPM, 0, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"SDTX3\", NULL, 2, SND_SOC_NOPM, 0, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"SDTX4\", NULL, 3, SND_SOC_NOPM, 0, 1),\n};\n\nstatic const struct snd_soc_dapm_route cs4234_dapm_routes[] = {\n\t \n\t{ \"AOUT1\", NULL, \"DAC1\" },\n\t{ \"AOUT2\", NULL, \"DAC2\" },\n\t{ \"AOUT3\", NULL, \"DAC3\" },\n\t{ \"AOUT4\", NULL, \"DAC4\" },\n\t{ \"AOUT5\", NULL, \"DAC5\" },\n\n\t{ \"DAC1\", NULL, \"SDRX1\" },\n\t{ \"DAC2\", NULL, \"SDRX2\" },\n\t{ \"DAC3\", NULL, \"SDRX3\" },\n\t{ \"DAC4\", NULL, \"SDRX4\" },\n\t{ \"DAC5\", NULL, \"SDRX5\" },\n\n\t{ \"SDRX1\", NULL, \"Playback\" },\n\t{ \"SDRX2\", NULL, \"Playback\" },\n\t{ \"SDRX3\", NULL, \"Playback\" },\n\t{ \"SDRX4\", NULL, \"Playback\" },\n\t{ \"SDRX5\", NULL, \"Playback\" },\n\n\t \n\t{ \"ADC1\", NULL, \"AIN1\" },\n\t{ \"ADC2\", NULL, \"AIN2\" },\n\t{ \"ADC3\", NULL, \"AIN3\" },\n\t{ \"ADC4\", NULL, \"AIN4\" },\n\n\t{ \"SDTX1\", NULL, \"ADC1\" },\n\t{ \"SDTX2\", NULL, \"ADC2\" },\n\t{ \"SDTX3\", NULL, \"ADC3\" },\n\t{ \"SDTX4\", NULL, \"ADC4\" },\n\n\t{ \"Capture\", NULL, \"SDTX1\" },\n\t{ \"Capture\", NULL, \"SDTX2\" },\n\t{ \"Capture\", NULL, \"SDTX3\" },\n\t{ \"Capture\", NULL, \"SDTX4\" },\n};\n\nstatic const struct snd_kcontrol_new cs4234_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Master Volume\", CS4234_MASTER_VOL, 0, 0xff, 1, dac_tlv),\n\tSOC_SINGLE_TLV(\"DAC1 Volume\", CS4234_DAC1_VOL, 0, 0xff, 1, dac_tlv),\n\tSOC_SINGLE_TLV(\"DAC2 Volume\", CS4234_DAC2_VOL, 0, 0xff, 1, dac_tlv),\n\tSOC_SINGLE_TLV(\"DAC3 Volume\", CS4234_DAC3_VOL, 0, 0xff, 1, dac_tlv),\n\tSOC_SINGLE_TLV(\"DAC4 Volume\", CS4234_DAC4_VOL, 0, 0xff, 1, dac_tlv),\n\tSOC_SINGLE_TLV(\"DAC5 Volume\", CS4234_DAC5_VOL, 0, 0xff, 1, dac_tlv),\n\n\tSOC_SINGLE(\"DAC5 Soft Ramp Switch\", CS4234_DAC_CTRL3, CS4234_DAC5_ATT_SHIFT, 1, 1),\n\tSOC_SINGLE(\"DAC1-4 Soft Ramp Switch\", CS4234_DAC_CTRL3, CS4234_DAC14_ATT_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"ADC HPF Switch\", CS4234_ADC_CTRL1, CS4234_ENA_HPF_SHIFT, 1, 0),\n\n\tSOC_ENUM_EXT(\"DAC1-4 Group Delay\", cs4234_dac14_group_delay,\n\t\t     snd_soc_get_enum_double, cs4234_dac14_grp_delay_put),\n\n\tSOC_SINGLE(\"ADC1 Invert Switch\", CS4234_ADC_CTRL1, CS4234_INV_ADC1_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2 Invert Switch\", CS4234_ADC_CTRL1, CS4234_INV_ADC2_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC3 Invert Switch\", CS4234_ADC_CTRL1, CS4234_INV_ADC3_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC4 Invert Switch\", CS4234_ADC_CTRL1, CS4234_INV_ADC4_SHIFT, 1, 0),\n\n\tSOC_SINGLE(\"DAC1 Invert Switch\", CS4234_DAC_CTRL2, CS4234_INV_DAC1_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC2 Invert Switch\", CS4234_DAC_CTRL2, CS4234_INV_DAC2_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC3 Invert Switch\", CS4234_DAC_CTRL2, CS4234_INV_DAC3_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC4 Invert Switch\", CS4234_DAC_CTRL2, CS4234_INV_DAC4_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC5 Invert Switch\", CS4234_DAC_CTRL2, CS4234_INV_DAC5_SHIFT, 1, 0),\n\n\tSOC_SINGLE(\"ADC1 Switch\", CS4234_ADC_CTRL2, CS4234_MUTE_ADC1_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC2 Switch\", CS4234_ADC_CTRL2, CS4234_MUTE_ADC2_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC3 Switch\", CS4234_ADC_CTRL2, CS4234_MUTE_ADC3_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC4 Switch\", CS4234_ADC_CTRL2, CS4234_MUTE_ADC4_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"DAC1 Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_DAC1_SHIFT, 1, 1),\n\tSOC_SINGLE(\"DAC2 Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_DAC2_SHIFT, 1, 1),\n\tSOC_SINGLE(\"DAC3 Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_DAC3_SHIFT, 1, 1),\n\tSOC_SINGLE(\"DAC4 Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_DAC4_SHIFT, 1, 1),\n\tSOC_SINGLE(\"DAC5 Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_DAC5_SHIFT, 1, 1),\n\tSOC_SINGLE(\"Low-latency Switch\", CS4234_DAC_CTRL3, CS4234_MUTE_LL_SHIFT, 1, 1),\n\n\tSOC_SINGLE(\"DAC1 Low-latency Invert Switch\", CS4234_LOW_LAT_CTRL1,\n\t\t   CS4234_INV_LL1_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC2 Low-latency Invert Switch\", CS4234_LOW_LAT_CTRL1,\n\t\t   CS4234_INV_LL2_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC3 Low-latency Invert Switch\", CS4234_LOW_LAT_CTRL1,\n\t\t   CS4234_INV_LL3_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC4 Low-latency Invert Switch\", CS4234_LOW_LAT_CTRL1,\n\t\t   CS4234_INV_LL4_SHIFT, 1, 0),\n\n\tSOC_ENUM(\"Low-latency Noise Gate\", cs4234_ll_noise_gate),\n\tSOC_ENUM(\"DAC1-4 Noise Gate\", cs4234_dac14_noise_gate),\n\tSOC_ENUM(\"DAC5 Noise Gate\", cs4234_dac5_noise_gate),\n\n\tSOC_SINGLE(\"DAC1-4 De-emphasis Switch\", CS4234_DAC_CTRL1,\n\t\t   CS4234_DAC14_DE_SHIFT, 1, 0),\n\tSOC_SINGLE(\"DAC5 De-emphasis Switch\", CS4234_DAC_CTRL1,\n\t\t   CS4234_DAC5_DE_SHIFT, 1, 0),\n\n\tSOC_SINGLE(\"DAC5 Master Controlled Switch\", CS4234_DAC_CTRL1,\n\t\t   CS4234_DAC5_MVC_SHIFT, 1, 0),\n\n\tSOC_ENUM(\"DAC5 Filter\", cs4234_dac5_config_fltr_sel),\n\n\tSOC_ENUM(\"Mute Delay\", cs4234_mute_delay),\n\tSOC_ENUM(\"Ramp Minimum Delay\", cs4234_min_delay),\n\tSOC_ENUM(\"Ramp Maximum Delay\", cs4234_max_delay),\n\n};\n\nstatic int cs4234_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(component);\n\tunsigned int sp_ctrl = 0;\n\n\tcs4234->format = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\tswitch (cs4234->format) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsp_ctrl |= CS4234_LEFT_J << CS4234_SP_FORMAT_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tsp_ctrl |= CS4234_I2S << CS4234_SP_FORMAT_SHIFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:  \n\t\tsp_ctrl |= CS4234_TDM << CS4234_SP_FORMAT_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tif (cs4234->format == SND_SOC_DAIFMT_DSP_A) {\n\t\t\tdev_err(component->dev, \"Unsupported DSP A format in master mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsp_ctrl |= CS4234_MST_SLV_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported master/slave mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tsp_ctrl |= CS4234_INVT_SCLK_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported inverted clock setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs4234->regmap, CS4234_SP_CTRL,\n\t\t\t   CS4234_SP_FORMAT_MASK | CS4234_MST_SLV_MASK | CS4234_INVT_SCLK_MASK,\n\t\t\t   sp_ctrl);\n\n\treturn 0;\n}\n\nstatic int cs4234_dai_hw_params(struct snd_pcm_substream *sub,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(component);\n\tunsigned int mclk_mult, double_speed = 0;\n\tint ret = 0, rate_ad, sample_width;\n\n\tcs4234->lrclk_rate = params_rate(params);\n\tmclk_mult = cs4234->mclk_rate / cs4234->lrclk_rate;\n\n\tif (cs4234->lrclk_rate > 48000) {\n\t\tdouble_speed = 1;\n\t\tmclk_mult *= 2;\n\t}\n\n\tswitch (mclk_mult) {\n\tcase 256:\n\tcase 384:\n\tcase 512:\n\t\tregmap_update_bits(cs4234->regmap, CS4234_CLOCK_SP,\n\t\t\t\t   CS4234_SPEED_MODE_MASK,\n\t\t\t\t   double_speed << CS4234_SPEED_MODE_SHIFT);\n\t\tregmap_update_bits(cs4234->regmap, CS4234_CLOCK_SP,\n\t\t\t\t   CS4234_MCLK_RATE_MASK,\n\t\t\t\t   ((mclk_mult / 128) - 2) << CS4234_MCLK_RATE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported mclk/lrclk rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cs4234->lrclk_rate) {\n\tcase 48000:\n\tcase 96000:\n\t\trate_ad = CS4234_48K;\n\t\tbreak;\n\tcase 44100:\n\tcase 88200:\n\t\trate_ad = CS4234_44K1;\n\t\tbreak;\n\tcase 32000:\n\tcase 64000:\n\t\trate_ad = CS4234_32K;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported LR clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\tregmap_update_bits(cs4234->regmap, CS4234_CLOCK_SP, CS4234_BASE_RATE_MASK,\n\t\t\t   rate_ad << CS4234_BASE_RATE_SHIFT);\n\n\tsample_width = params_width(params);\n\tswitch (sample_width) {\n\tcase 16:\n\t\tsample_width = 0;\n\t\tbreak;\n\tcase 18:\n\t\tsample_width = 1;\n\t\tbreak;\n\tcase 20:\n\t\tsample_width = 2;\n\t\tbreak;\n\tcase 24:\n\t\tsample_width = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample width\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (sub->stream == SNDRV_PCM_STREAM_CAPTURE)\n\t\tregmap_update_bits(cs4234->regmap, CS4234_SAMPLE_WIDTH,\n\t\t\t\t   CS4234_SDOUTX_SW_MASK,\n\t\t\t\t   sample_width << CS4234_SDOUTX_SW_SHIFT);\n\telse\n\t\tregmap_update_bits(cs4234->regmap, CS4234_SAMPLE_WIDTH,\n\t\t\t\tCS4234_INPUT_SW_MASK | CS4234_LOW_LAT_SW_MASK | CS4234_DAC5_SW_MASK,\n\t\t\t\tsample_width << CS4234_INPUT_SW_SHIFT |\n\t\t\t\tsample_width << CS4234_LOW_LAT_SW_SHIFT |\n\t\t\t\tsample_width << CS4234_DAC5_SW_SHIFT);\n\n\treturn ret;\n}\n\n \n#define CS4234_MCLK_SCALE  64\n\nstatic const struct snd_ratnum cs4234_dividers[] = {\n\t{\n\t\t.num = 0,\n\t\t.den_min = 256 / CS4234_MCLK_SCALE,\n\t\t.den_max = 512 / CS4234_MCLK_SCALE,\n\t\t.den_step = 128 / CS4234_MCLK_SCALE,\n\t},\n\t{\n\t\t.num = 0,\n\t\t.den_min = 128 / CS4234_MCLK_SCALE,\n\t\t.den_max = 192 / CS4234_MCLK_SCALE,\n\t\t.den_step = 64 / CS4234_MCLK_SCALE,\n\t},\n};\n\nstatic int cs4234_dai_rule_rate(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\n{\n\tstruct cs4234 *cs4234 = rule->private;\n\tint mclk = cs4234->mclk_rate;\n\tstruct snd_interval ranges[] = {\n\t\t{  \n\t\t\t.min = mclk / clamp(mclk / 30000, 256, 512),\n\t\t\t.max = mclk / clamp(mclk / 50000, 256, 512),\n\t\t},\n\t\t{  \n\t\t\t.min = mclk / clamp(mclk / 60000,  128, 256),\n\t\t\t.max = mclk / clamp(mclk / 100000, 128, 256),\n\t\t},\n\t};\n\n\treturn snd_interval_ranges(hw_param_interval(params, rule->var),\n\t\t\t\t   ARRAY_SIZE(ranges), ranges, 0);\n}\n\nstatic int cs4234_dai_startup(struct snd_pcm_substream *sub, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(comp);\n\tint i, ret;\n\n\tswitch (cs4234->format) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcs4234->rate_constraint.nrats = 2;\n\n\t\t \n\t\tif (sub->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tret = snd_pcm_hw_constraint_mask64(\n\t\t\t\t\t\tsub->runtime,\n\t\t\t\t\t\tSNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t\t\tSNDRV_PCM_FMTBIT_S24_3LE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = snd_pcm_hw_constraint_minmax(sub->runtime,\n\t\t\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t\t\t   1, 4);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcs4234->rate_constraint.nrats = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"Startup unsupported DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < cs4234->rate_constraint.nrats; i++)\n\t\tcs4234->rate_dividers[i].num = cs4234->mclk_rate / CS4234_MCLK_SCALE;\n\n\tret = snd_pcm_hw_constraint_ratnums(sub->runtime, 0,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    &cs4234->rate_constraint);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn snd_pcm_hw_rule_add(sub->runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   cs4234_dai_rule_rate, cs4234, -1);\n}\n\nstatic int cs4234_dai_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t   unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4234 *cs4234 = snd_soc_component_get_drvdata(component);\n\tunsigned int slot_offset, dac5_slot, dac5_mask_group;\n\tuint8_t dac5_masks[4];\n\n\tif (slot_width != 32) {\n\t\tdev_err(component->dev, \"Unsupported slot width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tslot_offset = ffs(tx_mask) - 1;\n\ttx_mask >>= slot_offset;\n\tif ((slot_offset % 4) || ((tx_mask != 0x0F) && (tx_mask != 0x1F))) {\n\t\tdev_err(component->dev, \"Unsupported tx slots allocation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs4234->regmap, CS4234_SP_DATA_SEL, CS4234_DAC14_SRC_MASK,\n\t\t\t   (slot_offset / 4) << CS4234_DAC14_SRC_SHIFT);\n\tregmap_update_bits(cs4234->regmap, CS4234_SP_DATA_SEL, CS4234_LL_SRC_MASK,\n\t\t\t   (slot_offset / 4) << CS4234_LL_SRC_SHIFT);\n\n\tif (tx_mask == 0x1F) {\n\t\tdac5_slot = slot_offset + 4;\n\t\tmemset(dac5_masks, 0xFF, sizeof(dac5_masks));\n\t\tdac5_mask_group = dac5_slot / 8;\n\t\tdac5_slot %= 8;\n\t\tdac5_masks[dac5_mask_group] ^= BIT(7 - dac5_slot);\n\t\tregmap_bulk_write(cs4234->regmap,\n\t\t\t\t  CS4234_SDIN1_MASK1,\n\t\t\t\t  dac5_masks,\n\t\t\t\t  ARRAY_SIZE(dac5_masks));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs4234_dai_ops = {\n\t.set_fmt\t= cs4234_dai_set_fmt,\n\t.hw_params\t= cs4234_dai_hw_params,\n\t.startup\t= cs4234_dai_startup,\n\t.set_tdm_slot\t= cs4234_dai_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver cs4234_dai[] = {\n\t{\n\t\t.name = \"cs4234-dai\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 5,\n\t\t\t.rates = CS4234_PCM_RATES,\n\t\t\t.formats = CS4234_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = CS4234_PCM_RATES,\n\t\t\t.formats = CS4234_FORMATS,\n\t\t},\n\t\t.ops = &cs4234_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic const struct reg_default cs4234_default_reg[] = {\n\t{ CS4234_CLOCK_SP,\t 0x04},\n\t{ CS4234_SAMPLE_WIDTH,\t 0xFF},\n\t{ CS4234_SP_CTRL,\t 0x48},\n\t{ CS4234_SP_DATA_SEL,\t 0x01},\n\t{ CS4234_SDIN1_MASK1,\t 0xFF},\n\t{ CS4234_SDIN1_MASK2,\t 0xFF},\n\t{ CS4234_SDIN2_MASK1,\t 0xFF},\n\t{ CS4234_SDIN2_MASK2,\t 0xFF},\n\t{ CS4234_TPS_CTRL,\t 0x00},\n\t{ CS4234_ADC_CTRL1,\t 0xC0},\n\t{ CS4234_ADC_CTRL2,\t 0xFF},\n\t{ CS4234_LOW_LAT_CTRL1,\t 0xE0},\n\t{ CS4234_DAC_CTRL1,\t 0xE0},\n\t{ CS4234_DAC_CTRL2,\t 0xE0},\n\t{ CS4234_DAC_CTRL3,\t 0xBF},\n\t{ CS4234_DAC_CTRL4,\t 0x1F},\n\t{ CS4234_VOLUME_MODE,\t 0x87},\n\t{ CS4234_MASTER_VOL,\t 0x10},\n\t{ CS4234_DAC1_VOL,\t 0x10},\n\t{ CS4234_DAC2_VOL,\t 0x10},\n\t{ CS4234_DAC3_VOL,\t 0x10},\n\t{ CS4234_DAC4_VOL,\t 0x10},\n\t{ CS4234_DAC5_VOL,\t 0x10},\n\t{ CS4234_INT_CTRL,\t 0x40},\n\t{ CS4234_INT_MASK1,\t 0x10},\n\t{ CS4234_INT_MASK2,\t 0x20},\n};\n\nstatic bool cs4234_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4234_DEVID_AB ... CS4234_DEVID_EF:\n\tcase CS4234_REVID ... CS4234_DAC5_VOL:\n\tcase CS4234_INT_CTRL ... CS4234_MAX_REGISTER:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs4234_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4234_INT_NOTIFY1:\n\tcase CS4234_INT_NOTIFY2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs4234_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS4234_DEVID_AB ... CS4234_REVID:\n\tcase CS4234_INT_NOTIFY1 ... CS4234_INT_NOTIFY2:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic const struct snd_soc_component_driver soc_component_cs4234 = {\n\t.dapm_widgets\t\t= cs4234_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4234_dapm_widgets),\n\t.dapm_routes\t\t= cs4234_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4234_dapm_routes),\n\t.controls\t\t= cs4234_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4234_snd_controls),\n\t.set_bias_level\t\t= cs4234_set_bias_level,\n\t.idle_bias_on\t\t= 1,\n\t.suspend_bias_off\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs4234_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS4234_MAX_REGISTER,\n\t.readable_reg = cs4234_readable_register,\n\t.volatile_reg = cs4234_volatile_reg,\n\t.writeable_reg = cs4234_writeable_register,\n\t.reg_defaults = cs4234_default_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs4234_default_reg),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const char * const cs4234_core_supplies[] = {\n\t\"VA\",\n\t\"VL\",\n};\n\nstatic void cs4234_shutdown(struct cs4234 *cs4234)\n{\n\tcancel_delayed_work_sync(&cs4234->vq_ramp_delay);\n\treinit_completion(&cs4234->vq_ramp_complete);\n\n\tregmap_update_bits(cs4234->regmap, CS4234_DAC_CTRL4, CS4234_VQ_RAMP_MASK,\n\t\t\t   CS4234_VQ_RAMP_MASK);\n\tmsleep(50);\n\tregcache_cache_only(cs4234->regmap, true);\n\t \n\tregmap_update_bits(cs4234->regmap, CS4234_DAC_CTRL4, CS4234_VQ_RAMP_MASK, 0);\n\tgpiod_set_value_cansleep(cs4234->reset_gpio, 0);\n\tregulator_bulk_disable(cs4234->num_core_supplies, cs4234->core_supplies);\n\tclk_disable_unprepare(cs4234->mclk);\n}\n\nstatic int cs4234_powerup(struct cs4234 *cs4234)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(cs4234->mclk);\n\tif (ret) {\n\t\tdev_err(cs4234->dev, \"Failed to enable mclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(cs4234->num_core_supplies, cs4234->core_supplies);\n\tif (ret) {\n\t\tdev_err(cs4234->dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\tclk_disable_unprepare(cs4234->mclk);\n\t\treturn ret;\n\t}\n\n\tusleep_range(CS4234_HOLD_RESET_TIME_US, 2 * CS4234_HOLD_RESET_TIME_US);\n\tgpiod_set_value_cansleep(cs4234->reset_gpio, 1);\n\n\t \n\tusleep_range(CS4234_BOOT_TIME_US, CS4234_BOOT_TIME_US * 2);\n\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &cs4234->vq_ramp_delay,\n\t\t\t   msecs_to_jiffies(CS4234_VQ_CHARGE_MS));\n\n\treturn 0;\n}\n\nstatic int cs4234_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs4234 *cs4234;\n\tstruct device *dev = &i2c_client->dev;\n\tunsigned int revid;\n\tuint32_t devid;\n\tuint8_t ids[3];\n\tint ret = 0, i;\n\n\tcs4234 = devm_kzalloc(dev, sizeof(*cs4234), GFP_KERNEL);\n\tif (!cs4234)\n\t\treturn -ENOMEM;\n\ti2c_set_clientdata(i2c_client, cs4234);\n\tcs4234->dev = dev;\n\tinit_completion(&cs4234->vq_ramp_complete);\n\tINIT_DELAYED_WORK(&cs4234->vq_ramp_delay, cs4234_vq_ramp_done);\n\n\tcs4234->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs4234->reset_gpio))\n\t\treturn PTR_ERR(cs4234->reset_gpio);\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs4234->core_supplies) < ARRAY_SIZE(cs4234_core_supplies));\n\n\tcs4234->num_core_supplies = ARRAY_SIZE(cs4234_core_supplies);\n\tfor (i = 0; i < ARRAY_SIZE(cs4234_core_supplies); i++)\n\t\tcs4234->core_supplies[i].supply = cs4234_core_supplies[i];\n\n\tret = devm_regulator_bulk_get(dev, cs4234->num_core_supplies, cs4234->core_supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request core supplies %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs4234->mclk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(cs4234->mclk)) {\n\t\tret = PTR_ERR(cs4234->mclk);\n\t\tdev_err(dev, \"Failed to get the mclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcs4234->mclk_rate = clk_get_rate(cs4234->mclk);\n\n\tif (cs4234->mclk_rate < 7680000 || cs4234->mclk_rate > 25600000) {\n\t\tdev_err(dev, \"Invalid Master Clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcs4234->regmap = devm_regmap_init_i2c(i2c_client, &cs4234_regmap);\n\tif (IS_ERR(cs4234->regmap)) {\n\t\tret = PTR_ERR(cs4234->regmap);\n\t\tdev_err(dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cs4234_powerup(cs4234);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_bulk_read(cs4234->regmap, CS4234_DEVID_AB, ids, ARRAY_SIZE(ids));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read DEVID: %d\\n\", ret);\n\t\tgoto fail_shutdown;\n\t}\n\n\tdevid = (ids[0] << 16) | (ids[1] << 8) | ids[2];\n\tif (devid != CS4234_SUPPORTED_ID) {\n\t\tdev_err(dev, \"Unknown device ID: %x\\n\", devid);\n\t\tret = -EINVAL;\n\t\tgoto fail_shutdown;\n\t}\n\n\tret = regmap_read(cs4234->regmap, CS4234_REVID, &revid);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read CS4234_REVID: %d\\n\", ret);\n\t\tgoto fail_shutdown;\n\t}\n\n\tdev_info(dev, \"Cirrus Logic CS4234, Alpha Rev: %02X, Numeric Rev: %02X\\n\",\n\t\t (revid & 0xF0) >> 4, revid & 0x0F);\n\n\tret = regulator_get_voltage(cs4234->core_supplies[CS4234_SUPPLY_VA].consumer);\n\tswitch (ret) {\n\tcase 3135000 ... 3650000:\n\t\tregmap_update_bits(cs4234->regmap, CS4234_ADC_CTRL1,\n\t\t\t\t   CS4234_VA_SEL_MASK,\n\t\t\t\t   CS4234_3V3 << CS4234_VA_SEL_SHIFT);\n\t\tbreak;\n\tcase 4750000 ... 5250000:\n\t\tregmap_update_bits(cs4234->regmap, CS4234_ADC_CTRL1,\n\t\t\t\t   CS4234_VA_SEL_MASK,\n\t\t\t\t   CS4234_5V << CS4234_VA_SEL_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid VA voltage\\n\");\n\t\tret = -EINVAL;\n\t\tgoto fail_shutdown;\n\t}\n\n\tpm_runtime_set_active(&i2c_client->dev);\n\tpm_runtime_enable(&i2c_client->dev);\n\n\tmemcpy(&cs4234->rate_dividers, &cs4234_dividers, sizeof(cs4234_dividers));\n\tcs4234->rate_constraint.rats = cs4234->rate_dividers;\n\n\tret = snd_soc_register_component(dev, &soc_component_cs4234, cs4234_dai,\n\t\t\t\t\t ARRAY_SIZE(cs4234_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register component:%d\\n\", ret);\n\t\tpm_runtime_disable(&i2c_client->dev);\n\t\tgoto fail_shutdown;\n\t}\n\n\treturn ret;\n\nfail_shutdown:\n\tcs4234_shutdown(cs4234);\n\n\treturn ret;\n}\n\nstatic void cs4234_i2c_remove(struct i2c_client *i2c_client)\n{\n\tstruct cs4234 *cs4234 = i2c_get_clientdata(i2c_client);\n\tstruct device *dev = &i2c_client->dev;\n\n\tsnd_soc_unregister_component(dev);\n\tpm_runtime_disable(dev);\n\tcs4234_shutdown(cs4234);\n}\n\nstatic int __maybe_unused cs4234_runtime_resume(struct device *dev)\n{\n\tstruct cs4234 *cs4234 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = cs4234_powerup(cs4234);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_mark_dirty(cs4234->regmap);\n\tregcache_cache_only(cs4234->regmap, false);\n\tret = regcache_sync(cs4234->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to sync regmap: %d\\n\", ret);\n\t\tcs4234_shutdown(cs4234);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs4234_runtime_suspend(struct device *dev)\n{\n\tstruct cs4234 *cs4234 = dev_get_drvdata(dev);\n\n\tcs4234_shutdown(cs4234);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cs4234_pm = {\n\tSET_RUNTIME_PM_OPS(cs4234_runtime_suspend, cs4234_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id cs4234_of_match[] = {\n\t{ .compatible = \"cirrus,cs4234\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs4234_of_match);\n\nstatic struct i2c_driver cs4234_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs4234\",\n\t\t.pm = &cs4234_pm,\n\t\t.of_match_table = cs4234_of_match,\n\t},\n\t.probe =\tcs4234_i2c_probe,\n\t.remove =\tcs4234_i2c_remove,\n};\nmodule_i2c_driver(cs4234_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC Cirrus Logic CS4234 driver\");\nMODULE_AUTHOR(\"Lucas Tanure <tanureal@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}