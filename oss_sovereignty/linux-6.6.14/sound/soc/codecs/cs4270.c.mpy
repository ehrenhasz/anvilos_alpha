{
  "module_name": "cs4270.c",
  "hash_id": "5623485d0944c3895d404ffb6493a9401a9beb9ed9d23e3a9fa205fc47e82d6f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4270.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n\n#define CS4270_FORMATS (SNDRV_PCM_FMTBIT_S8      | SNDRV_PCM_FMTBIT_S16_LE  | \\\n\t\t\tSNDRV_PCM_FMTBIT_S18_3LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\n \n#define CS4270_CHIPID\t0x01\t \n#define CS4270_PWRCTL\t0x02\t \n#define CS4270_MODE\t0x03\t \n#define CS4270_FORMAT\t0x04\t \n#define CS4270_TRANS\t0x05\t \n#define CS4270_MUTE\t0x06\t \n#define CS4270_VOLA\t0x07\t \n#define CS4270_VOLB\t0x08\t \n\n#define CS4270_FIRSTREG\t0x01\n#define CS4270_LASTREG\t0x08\n#define CS4270_NUMREGS\t(CS4270_LASTREG - CS4270_FIRSTREG + 1)\n#define CS4270_I2C_INCR\t0x80\n\n \n#define CS4270_CHIPID_ID\t0xF0\n#define CS4270_CHIPID_REV\t0x0F\n#define CS4270_PWRCTL_FREEZE\t0x80\n#define CS4270_PWRCTL_PDN_ADC\t0x20\n#define CS4270_PWRCTL_PDN_DAC\t0x02\n#define CS4270_PWRCTL_PDN\t0x01\n#define CS4270_PWRCTL_PDN_ALL\t\\\n\t(CS4270_PWRCTL_PDN_ADC | CS4270_PWRCTL_PDN_DAC | CS4270_PWRCTL_PDN)\n#define CS4270_MODE_SPEED_MASK\t0x30\n#define CS4270_MODE_1X\t\t0x00\n#define CS4270_MODE_2X\t\t0x10\n#define CS4270_MODE_4X\t\t0x20\n#define CS4270_MODE_SLAVE\t0x30\n#define CS4270_MODE_DIV_MASK\t0x0E\n#define CS4270_MODE_DIV1\t0x00\n#define CS4270_MODE_DIV15\t0x02\n#define CS4270_MODE_DIV2\t0x04\n#define CS4270_MODE_DIV3\t0x06\n#define CS4270_MODE_DIV4\t0x08\n#define CS4270_MODE_POPGUARD\t0x01\n#define CS4270_FORMAT_FREEZE_A\t0x80\n#define CS4270_FORMAT_FREEZE_B\t0x40\n#define CS4270_FORMAT_LOOPBACK\t0x20\n#define CS4270_FORMAT_DAC_MASK\t0x18\n#define CS4270_FORMAT_DAC_LJ\t0x00\n#define CS4270_FORMAT_DAC_I2S\t0x08\n#define CS4270_FORMAT_DAC_RJ16\t0x18\n#define CS4270_FORMAT_DAC_RJ24\t0x10\n#define CS4270_FORMAT_ADC_MASK\t0x01\n#define CS4270_FORMAT_ADC_LJ\t0x00\n#define CS4270_FORMAT_ADC_I2S\t0x01\n#define CS4270_TRANS_ONE_VOL\t0x80\n#define CS4270_TRANS_SOFT\t0x40\n#define CS4270_TRANS_ZERO\t0x20\n#define CS4270_TRANS_INV_ADC_A\t0x08\n#define CS4270_TRANS_INV_ADC_B\t0x10\n#define CS4270_TRANS_INV_DAC_A\t0x02\n#define CS4270_TRANS_INV_DAC_B\t0x04\n#define CS4270_TRANS_DEEMPH\t0x01\n#define CS4270_MUTE_AUTO\t0x20\n#define CS4270_MUTE_ADC_A\t0x08\n#define CS4270_MUTE_ADC_B\t0x10\n#define CS4270_MUTE_POLARITY\t0x04\n#define CS4270_MUTE_DAC_A\t0x01\n#define CS4270_MUTE_DAC_B\t0x02\n\n \nstatic const struct reg_default cs4270_reg_defaults[] = {\n\t{ 2, 0x00 },\n\t{ 3, 0x30 },\n\t{ 4, 0x00 },\n\t{ 5, 0x60 },\n\t{ 6, 0x20 },\n\t{ 7, 0x00 },\n\t{ 8, 0x00 },\n};\n\nstatic const char *supply_names[] = {\n\t\"va\", \"vd\", \"vlc\"\n};\n\n \nstruct cs4270_private {\n\tstruct regmap *regmap;\n\tunsigned int mclk;  \n\tunsigned int mode;  \n\tunsigned int slave_mode;\n\tunsigned int manual_mute;\n\n\t \n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n\n\t \n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic const struct snd_soc_dapm_widget cs4270_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"AINL\"),\nSND_SOC_DAPM_INPUT(\"AINR\"),\n\nSND_SOC_DAPM_OUTPUT(\"AOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"AOUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route cs4270_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"AINL\" },\n\t{ \"Capture\", NULL, \"AINR\" },\n\n\t{ \"AOUTL\", NULL, \"Playback\" },\n\t{ \"AOUTR\", NULL, \"Playback\" },\n};\n\n \nstruct cs4270_mode_ratios {\n\tunsigned int ratio;\n\tu8 speed_mode;\n\tu8 mclk;\n};\n\nstatic struct cs4270_mode_ratios cs4270_mode_ratios[] = {\n\t{64, CS4270_MODE_4X, CS4270_MODE_DIV1},\n#ifndef CONFIG_SND_SOC_CS4270_VD33_ERRATA\n\t{96, CS4270_MODE_4X, CS4270_MODE_DIV15},\n#endif\n\t{128, CS4270_MODE_2X, CS4270_MODE_DIV1},\n\t{192, CS4270_MODE_4X, CS4270_MODE_DIV3},\n\t{256, CS4270_MODE_1X, CS4270_MODE_DIV1},\n\t{384, CS4270_MODE_2X, CS4270_MODE_DIV3},\n\t{512, CS4270_MODE_1X, CS4270_MODE_DIV2},\n\t{768, CS4270_MODE_1X, CS4270_MODE_DIV3},\n\t{1024, CS4270_MODE_1X, CS4270_MODE_DIV4}\n};\n\n \n#define NUM_MCLK_RATIOS\t\tARRAY_SIZE(cs4270_mode_ratios)\n\nstatic bool cs4270_reg_is_readable(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= CS4270_FIRSTREG) && (reg <= CS4270_LASTREG);\n}\n\nstatic bool cs4270_reg_is_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tif ((reg < CS4270_FIRSTREG) || (reg > CS4270_LASTREG))\n\t\treturn true;\n\n\treturn reg == CS4270_CHIPID;\n}\n\n \nstatic int cs4270_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\n\tcs4270->mclk = freq;\n\treturn 0;\n}\n\n \nstatic int cs4270_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcs4270->mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"invalid dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs4270->slave_mode = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs4270->slave_mode = 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(component->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cs4270_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tunsigned int i;\n\tunsigned int rate;\n\tunsigned int ratio;\n\tint reg;\n\n\t \n\n\trate = params_rate(params);\t \n\tratio = cs4270->mclk / rate;\t \n\n\tfor (i = 0; i < NUM_MCLK_RATIOS; i++) {\n\t\tif (cs4270_mode_ratios[i].ratio == ratio)\n\t\t\tbreak;\n\t}\n\n\tif (i == NUM_MCLK_RATIOS) {\n\t\t \n\t\tdev_err(component->dev, \"could not find matching ratio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\treg = snd_soc_component_read(component, CS4270_MODE);\n\treg &= ~(CS4270_MODE_SPEED_MASK | CS4270_MODE_DIV_MASK);\n\treg |= cs4270_mode_ratios[i].mclk;\n\n\tif (cs4270->slave_mode)\n\t\treg |= CS4270_MODE_SLAVE;\n\telse\n\t\treg |= cs4270_mode_ratios[i].speed_mode;\n\n\tret = snd_soc_component_write(component, CS4270_MODE, reg);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"i2c write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\treg = snd_soc_component_read(component, CS4270_FORMAT);\n\treg &= ~(CS4270_FORMAT_DAC_MASK | CS4270_FORMAT_ADC_MASK);\n\n\tswitch (cs4270->mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\treg |= CS4270_FORMAT_DAC_I2S | CS4270_FORMAT_ADC_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg |= CS4270_FORMAT_DAC_LJ | CS4270_FORMAT_ADC_LJ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_write(component, CS4270_FORMAT, reg);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"i2c write failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int cs4270_dai_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint reg6;\n\n\treg6 = snd_soc_component_read(component, CS4270_MUTE);\n\n\tif (mute)\n\t\treg6 |= CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B;\n\telse {\n\t\treg6 &= ~(CS4270_MUTE_DAC_A | CS4270_MUTE_DAC_B);\n\t\treg6 |= cs4270->manual_mute;\n\t}\n\n\treturn snd_soc_component_write(component, CS4270_MUTE, reg6);\n}\n\n \nstatic int cs4270_soc_put_mute(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint left = !ucontrol->value.integer.value[0];\n\tint right = !ucontrol->value.integer.value[1];\n\n\tcs4270->manual_mute = (left ? CS4270_MUTE_DAC_A : 0) |\n\t\t\t      (right ? CS4270_MUTE_DAC_B : 0);\n\n\treturn snd_soc_put_volsw(kcontrol, ucontrol);\n}\n\n \nstatic const struct snd_kcontrol_new cs4270_snd_controls[] = {\n\tSOC_DOUBLE_R(\"Master Playback Volume\",\n\t\tCS4270_VOLA, CS4270_VOLB, 0, 0xFF, 1),\n\tSOC_SINGLE(\"Digital Sidetone Switch\", CS4270_FORMAT, 5, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp Switch\", CS4270_TRANS, 6, 1, 0),\n\tSOC_SINGLE(\"Zero Cross Switch\", CS4270_TRANS, 5, 1, 0),\n\tSOC_SINGLE(\"De-emphasis filter\", CS4270_TRANS, 0, 1, 0),\n\tSOC_SINGLE(\"Popguard Switch\", CS4270_MODE, 0, 1, 1),\n\tSOC_SINGLE(\"Auto-Mute Switch\", CS4270_MUTE, 5, 1, 0),\n\tSOC_DOUBLE(\"Master Capture Switch\", CS4270_MUTE, 3, 4, 1, 1),\n\tSOC_DOUBLE_EXT(\"Master Playback Switch\", CS4270_MUTE, 0, 1, 1, 1,\n\t\tsnd_soc_get_volsw, cs4270_soc_put_mute),\n};\n\nstatic const struct snd_soc_dai_ops cs4270_dai_ops = {\n\t.hw_params\t= cs4270_hw_params,\n\t.set_sysclk\t= cs4270_set_dai_sysclk,\n\t.set_fmt\t= cs4270_set_dai_fmt,\n\t.mute_stream\t= cs4270_dai_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs4270_dai = {\n\t.name = \"cs4270-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 4000,\n\t\t.rate_max = 216000,\n\t\t.formats = CS4270_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 4000,\n\t\t.rate_max = 216000,\n\t\t.formats = CS4270_FORMATS,\n\t},\n\t.ops = &cs4270_dai_ops,\n};\n\n \nstatic int cs4270_probe(struct snd_soc_component *component)\n{\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\t \n\tret = snd_soc_component_update_bits(component, CS4270_MUTE, CS4270_MUTE_AUTO, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"i2c write failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_component_update_bits(component, CS4270_TRANS,\n\t\tCS4270_TRANS_SOFT | CS4270_TRANS_ZERO, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"i2c write failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\n\t\t\t\t    cs4270->supplies);\n\n\treturn ret;\n}\n\n \nstatic void cs4270_remove(struct snd_soc_component *component)\n{\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies), cs4270->supplies);\n};\n\n#ifdef CONFIG_PM\n\n \n\nstatic int cs4270_soc_suspend(struct snd_soc_component *component)\n{\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint reg, ret;\n\n\treg = snd_soc_component_read(component, CS4270_PWRCTL) | CS4270_PWRCTL_PDN_ALL;\n\tif (reg < 0)\n\t\treturn reg;\n\n\tret = snd_soc_component_write(component, CS4270_PWRCTL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs4270->supplies),\n\t\t\t       cs4270->supplies);\n\n\treturn 0;\n}\n\nstatic int cs4270_soc_resume(struct snd_soc_component *component)\n{\n\tstruct cs4270_private *cs4270 = snd_soc_component_get_drvdata(component);\n\tint reg, ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs4270->supplies),\n\t\t\t\t    cs4270->supplies);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tndelay(500);\n\n\t \n\tregcache_sync(cs4270->regmap);\n\n\t \n\treg = snd_soc_component_read(component, CS4270_PWRCTL);\n\treg &= ~CS4270_PWRCTL_PDN_ALL;\n\n\treturn snd_soc_component_write(component, CS4270_PWRCTL, reg);\n}\n#else\n#define cs4270_soc_suspend\tNULL\n#define cs4270_soc_resume\tNULL\n#endif  \n\n \nstatic const struct snd_soc_component_driver soc_component_device_cs4270 = {\n\t.probe\t\t\t= cs4270_probe,\n\t.remove\t\t\t= cs4270_remove,\n\t.suspend\t\t= cs4270_soc_suspend,\n\t.resume\t\t\t= cs4270_soc_resume,\n\t.controls\t\t= cs4270_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4270_snd_controls),\n\t.dapm_widgets\t\t= cs4270_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4270_dapm_widgets),\n\t.dapm_routes\t\t= cs4270_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4270_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n \nstatic const struct of_device_id cs4270_of_match[] = {\n\t{ .compatible = \"cirrus,cs4270\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs4270_of_match);\n\nstatic const struct regmap_config cs4270_regmap = {\n\t.reg_bits =\t\t8,\n\t.val_bits =\t\t8,\n\t.max_register =\t\tCS4270_LASTREG,\n\t.reg_defaults =\t\tcs4270_reg_defaults,\n\t.num_reg_defaults =\tARRAY_SIZE(cs4270_reg_defaults),\n\t.cache_type =\t\tREGCACHE_MAPLE,\n\t.write_flag_mask =\tCS4270_I2C_INCR,\n\n\t.readable_reg =\t\tcs4270_reg_is_readable,\n\t.volatile_reg =\t\tcs4270_reg_is_volatile,\n};\n\n \nstatic void cs4270_i2c_remove(struct i2c_client *i2c_client)\n{\n\tstruct cs4270_private *cs4270 = i2c_get_clientdata(i2c_client);\n\n\tgpiod_set_value_cansleep(cs4270->reset_gpio, 0);\n}\n\n \nstatic int cs4270_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs4270_private *cs4270;\n\tunsigned int val;\n\tint ret, i;\n\n\tcs4270 = devm_kzalloc(&i2c_client->dev, sizeof(struct cs4270_private),\n\t\t\t      GFP_KERNEL);\n\tif (!cs4270)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tcs4270->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\t\t\t      ARRAY_SIZE(cs4270->supplies),\n\t\t\t\t      cs4270->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcs4270->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev, \"reset\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(cs4270->reset_gpio)) {\n\t\tdev_dbg(&i2c_client->dev, \"Error getting CS4270 reset GPIO\\n\");\n\t\treturn PTR_ERR(cs4270->reset_gpio);\n\t}\n\n\tif (cs4270->reset_gpio) {\n\t\tdev_dbg(&i2c_client->dev, \"Found reset GPIO\\n\");\n\t\tgpiod_set_value_cansleep(cs4270->reset_gpio, 1);\n\t}\n\n\t \n\tndelay(500);\n\n\tcs4270->regmap = devm_regmap_init_i2c(i2c_client, &cs4270_regmap);\n\tif (IS_ERR(cs4270->regmap))\n\t\treturn PTR_ERR(cs4270->regmap);\n\n\t \n\tret = regmap_read(cs4270->regmap, CS4270_CHIPID, &val);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"failed to read i2c at addr %X\\n\",\n\t\t       i2c_client->addr);\n\t\treturn ret;\n\t}\n\t \n\tif ((val & 0xF0) != 0xC0) {\n\t\tdev_err(&i2c_client->dev, \"device at addr %X is not a CS4270\\n\",\n\t\t       i2c_client->addr);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&i2c_client->dev, \"found device at i2c address %X\\n\",\n\t\ti2c_client->addr);\n\tdev_info(&i2c_client->dev, \"hardware revision %X\\n\", val & 0xF);\n\n\ti2c_set_clientdata(i2c_client, cs4270);\n\n\tret = devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_device_cs4270, &cs4270_dai, 1);\n\treturn ret;\n}\n\n \nstatic const struct i2c_device_id cs4270_id[] = {\n\t{\"cs4270\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cs4270_id);\n\n \nstatic struct i2c_driver cs4270_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs4270\",\n\t\t.of_match_table = cs4270_of_match,\n\t},\n\t.id_table = cs4270_id,\n\t.probe = cs4270_i2c_probe,\n\t.remove = cs4270_i2c_remove,\n};\n\nmodule_i2c_driver(cs4270_i2c_driver);\n\nMODULE_AUTHOR(\"Timur Tabi <timur@freescale.com>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS4270 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}