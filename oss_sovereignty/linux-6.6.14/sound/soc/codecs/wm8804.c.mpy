{
  "module_name": "wm8804.c",
  "hash_id": "9a525d6490c3f918cbba4d142daee90012c991aa50f241bf6da200ca03472991",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8804.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/of_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/soc-dapm.h>\n\n#include \"wm8804.h\"\n\n#define WM8804_NUM_SUPPLIES 2\nstatic const char *wm8804_supply_names[WM8804_NUM_SUPPLIES] = {\n\t\"PVDD\",\n\t\"DVDD\"\n};\n\nstatic const struct reg_default wm8804_reg_defaults[] = {\n\t{ 3,  0x21 },      \n\t{ 4,  0xFD },      \n\t{ 5,  0x36 },      \n\t{ 6,  0x07 },      \n\t{ 7,  0x16 },      \n\t{ 8,  0x18 },      \n\t{ 9,  0xFF },      \n\t{ 10, 0x00 },      \n\t{ 18, 0x00 },      \n\t{ 19, 0x00 },      \n\t{ 20, 0x00 },      \n\t{ 21, 0x71 },      \n\t{ 22, 0x0B },      \n\t{ 23, 0x70 },      \n\t{ 24, 0x57 },      \n\t{ 26, 0x42 },      \n\t{ 27, 0x06 },      \n\t{ 28, 0x06 },      \n\t{ 29, 0x80 },      \n\t{ 30, 0x07 },      \n};\n\nstruct wm8804_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8804_NUM_SUPPLIES];\n\tstruct notifier_block disable_nb[WM8804_NUM_SUPPLIES];\n\tint mclk_div;\n\n\tstruct gpio_desc *reset;\n\n\tint aif_pwr;\n};\n\nstatic int txsrc_put(struct snd_kcontrol *kcontrol,\n\t\t     struct snd_ctl_elem_value *ucontrol);\n\nstatic int wm8804_aif_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event);\n\n \n#define WM8804_REGULATOR_EVENT(n) \\\nstatic int wm8804_regulator_event_##n(struct notifier_block *nb, \\\n\t\t\t\t      unsigned long event, void *data)    \\\n{ \\\n\tstruct wm8804_priv *wm8804 = container_of(nb, struct wm8804_priv, \\\n\t\t\t\t\t\t  disable_nb[n]); \\\n\tif (event & REGULATOR_EVENT_DISABLE) { \\\n\t\tregcache_mark_dirty(wm8804->regmap);\t\\\n\t} \\\n\treturn 0; \\\n}\n\nWM8804_REGULATOR_EVENT(0)\nWM8804_REGULATOR_EVENT(1)\n\nstatic const char *txsrc_text[] = { \"S/PDIF RX\", \"AIF\" };\nstatic SOC_ENUM_SINGLE_DECL(txsrc, WM8804_SPDTX4, 6, txsrc_text);\n\nstatic const struct snd_kcontrol_new wm8804_tx_source_mux[] = {\n\tSOC_DAPM_ENUM_EXT(\"Input Source\", txsrc,\n\t\t\t  snd_soc_dapm_get_enum_double, txsrc_put),\n};\n\nstatic const struct snd_soc_dapm_widget wm8804_dapm_widgets[] = {\nSND_SOC_DAPM_OUTPUT(\"SPDIF Out\"),\nSND_SOC_DAPM_INPUT(\"SPDIF In\"),\n\nSND_SOC_DAPM_PGA(\"SPDIFTX\", WM8804_PWRDN, 2, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"SPDIFRX\", WM8804_PWRDN, 1, 1, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"Tx Source\", SND_SOC_NOPM, 6, 0, wm8804_tx_source_mux),\n\nSND_SOC_DAPM_AIF_OUT_E(\"AIFTX\", NULL, 0, SND_SOC_NOPM, 0, 0, wm8804_aif_event,\n\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_AIF_IN_E(\"AIFRX\", NULL, 0, SND_SOC_NOPM, 0, 0, wm8804_aif_event,\n\t\t      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route wm8804_dapm_routes[] = {\n\t{ \"AIFRX\", NULL, \"Playback\" },\n\t{ \"Tx Source\", \"AIF\", \"AIFRX\" },\n\n\t{ \"SPDIFRX\", NULL, \"SPDIF In\" },\n\t{ \"Tx Source\", \"S/PDIF RX\", \"SPDIFRX\" },\n\n\t{ \"SPDIFTX\", NULL, \"Tx Source\" },\n\t{ \"SPDIF Out\", NULL, \"SPDIFTX\" },\n\n\t{ \"AIFTX\", NULL, \"SPDIFRX\" },\n\t{ \"Capture\", NULL, \"AIFTX\" },\n};\n\nstatic int wm8804_aif_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8804_priv *wm8804 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tif (!wm8804->aif_pwr)\n\t\t\tsnd_soc_component_update_bits(component, WM8804_PWRDN, 0x10, 0x0);\n\t\twm8804->aif_pwr++;\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\twm8804->aif_pwr--;\n\t\tif (!wm8804->aif_pwr)\n\t\t\tsnd_soc_component_update_bits(component, WM8804_PWRDN, 0x10, 0x10);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int txsrc_put(struct snd_kcontrol *kcontrol,\n\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int val = ucontrol->value.enumerated.item[0] << e->shift_l;\n\tunsigned int mask = 1 << e->shift_l;\n\tunsigned int txpwr;\n\n\tif (val != 0 && val != mask)\n\t\treturn -EINVAL;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tif (snd_soc_component_test_bits(component, e->reg, mask, val)) {\n\t\t \n\t\ttxpwr = snd_soc_component_read(component, WM8804_PWRDN) & 0x4;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8804_PWRDN, 0x4, 0x4);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, e->reg, mask, val);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8804_PWRDN, 0x4, txpwr);\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\treturn 0;\n}\n\nstatic bool wm8804_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8804_RST_DEVID1:\n\tcase WM8804_DEVID2:\n\tcase WM8804_DEVREV:\n\tcase WM8804_INTSTAT:\n\tcase WM8804_SPDSTAT:\n\tcase WM8804_RXCHAN1:\n\tcase WM8804_RXCHAN2:\n\tcase WM8804_RXCHAN3:\n\tcase WM8804_RXCHAN4:\n\tcase WM8804_RXCHAN5:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8804_soft_reset(struct wm8804_priv *wm8804)\n{\n\treturn regmap_write(wm8804->regmap, WM8804_RST_DEVID1, 0x0);\n}\n\nstatic int wm8804_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component;\n\tu16 format, master, bcp, lrp;\n\n\tcomponent = dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tformat = 0x0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = 0x1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8804_AIFTX, 0x3, format);\n\tsnd_soc_component_update_bits(component, WM8804_AIFRX, 0x3, format);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8804_AIFRX, 0x40, master << 6);\n\n\tbcp = lrp = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbcp = lrp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbcp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrp = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown polarity configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8804_AIFTX, 0x10 | 0x20,\n\t\t\t    (bcp << 4) | (lrp << 5));\n\tsnd_soc_component_update_bits(component, WM8804_AIFRX, 0x10 | 0x20,\n\t\t\t    (bcp << 4) | (lrp << 5));\n\treturn 0;\n}\n\nstatic int wm8804_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component;\n\tu16 blen;\n\n\tcomponent = dai->component;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tblen = 0x0;\n\t\tbreak;\n\tcase 20:\n\t\tblen = 0x1;\n\t\tbreak;\n\tcase 24:\n\t\tblen = 0x2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported word length: %u\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8804_AIFTX, 0xc, blen << 2);\n\tsnd_soc_component_update_bits(component, WM8804_AIFRX, 0xc, blen << 2);\n\n\treturn 0;\n}\n\nstruct pll_div {\n\tu32 prescale:1;\n\tu32 mclkdiv:1;\n\tu32 freqmode:2;\n\tu32 n:4;\n\tu32 k:22;\n};\n\n \nstatic struct {\n\tunsigned int div;\n\tunsigned int freqmode;\n\tunsigned int mclkdiv;\n} post_table[] = {\n\t{  2,  0, 0 },\n\t{  4,  0, 1 },\n\t{  4,  1, 0 },\n\t{  8,  1, 1 },\n\t{  8,  2, 0 },\n\t{ 16,  2, 1 },\n\t{ 12,  3, 0 },\n\t{ 24,  3, 1 }\n};\n\n#define FIXED_PLL_SIZE ((1ULL << 22) * 10)\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\n\t\t       unsigned int source, unsigned int mclk_div)\n{\n\tu64 Kpart;\n\tunsigned long int K, Ndiv, Nmod, tmp;\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(post_table); i++) {\n\t\ttmp = target * post_table[i].div;\n\t\tif ((tmp >= 90000000 && tmp <= 100000000) &&\n\t\t    (mclk_div == post_table[i].mclkdiv)) {\n\t\t\tpll_div->freqmode = post_table[i].freqmode;\n\t\t\tpll_div->mclkdiv = post_table[i].mclkdiv;\n\t\t\ttarget *= post_table[i].div;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(post_table)) {\n\t\tpr_err(\"%s: Unable to scale output frequency: %uHz\\n\",\n\t\t       __func__, target);\n\t\treturn -EINVAL;\n\t}\n\n\tpll_div->prescale = 0;\n\tNdiv = target / source;\n\tif (Ndiv < 5) {\n\t\tsource >>= 1;\n\t\tpll_div->prescale = 1;\n\t\tNdiv = target / source;\n\t}\n\n\tif (Ndiv < 5 || Ndiv > 13) {\n\t\tpr_err(\"%s: WM8804 N value is not within the recommended range: %lu\\n\",\n\t\t       __func__, Ndiv);\n\t\treturn -EINVAL;\n\t}\n\tpll_div->n = Ndiv;\n\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (u64)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xffffffff;\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\tK /= 10;\n\tpll_div->k = K;\n\n\treturn 0;\n}\n\nstatic int wm8804_set_pll(struct snd_soc_dai *dai, int pll_id,\n\t\t\t  int source, unsigned int freq_in,\n\t\t\t  unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8804_priv *wm8804 = snd_soc_component_get_drvdata(component);\n\tbool change;\n\n\tif (!freq_in || !freq_out) {\n\t\t \n\t\tregmap_update_bits_check(wm8804->regmap, WM8804_PWRDN,\n\t\t\t\t\t 0x1, 0x1, &change);\n\t\tif (change)\n\t\t\tpm_runtime_put(wm8804->dev);\n\t} else {\n\t\tint ret;\n\t\tstruct pll_div pll_div;\n\n\t\tret = pll_factors(&pll_div, freq_out, freq_in,\n\t\t\t\t  wm8804->mclk_div);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tregmap_update_bits_check(wm8804->regmap, WM8804_PWRDN,\n\t\t\t\t\t 0x1, 0x1, &change);\n\t\tif (!change)\n\t\t\tpm_runtime_get_sync(wm8804->dev);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8804_PLL4, 0xf | 0x10,\n\t\t\t\t    pll_div.n | (pll_div.prescale << 4));\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8804_PLL5, 0x3 | 0x8,\n\t\t\t\t    pll_div.freqmode | (pll_div.mclkdiv << 3));\n\t\t \n\t\tsnd_soc_component_write(component, WM8804_PLL1, pll_div.k & 0xff);\n\t\tsnd_soc_component_write(component, WM8804_PLL2, (pll_div.k >> 8) & 0xff);\n\t\tsnd_soc_component_write(component, WM8804_PLL3, pll_div.k >> 16);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8804_PWRDN, 0x1, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8804_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component;\n\n\tcomponent = dai->component;\n\n\tswitch (clk_id) {\n\tcase WM8804_TX_CLKSRC_MCLK:\n\t\tif ((freq >= 10000000 && freq <= 14400000)\n\t\t\t\t|| (freq >= 16280000 && freq <= 27000000))\n\t\t\tsnd_soc_component_update_bits(component, WM8804_PLL6, 0x80, 0x80);\n\t\telse {\n\t\t\tdev_err(dai->dev, \"OSCCLOCK is not within the \"\n\t\t\t\t\"recommended range: %uHz\\n\", freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WM8804_TX_CLKSRC_PLL:\n\t\tsnd_soc_component_update_bits(component, WM8804_PLL6, 0x80, 0);\n\t\tbreak;\n\tcase WM8804_CLKOUT_SRC_CLK1:\n\t\tsnd_soc_component_update_bits(component, WM8804_PLL6, 0x8, 0);\n\t\tbreak;\n\tcase WM8804_CLKOUT_SRC_OSCCLK:\n\t\tsnd_soc_component_update_bits(component, WM8804_PLL6, 0x8, 0x8);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown clock source: %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8804_set_clkdiv(struct snd_soc_dai *dai,\n\t\t\t     int div_id, int div)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8804_priv *wm8804;\n\n\tcomponent = dai->component;\n\tswitch (div_id) {\n\tcase WM8804_CLKOUT_DIV:\n\t\tsnd_soc_component_update_bits(component, WM8804_PLL5, 0x30,\n\t\t\t\t    (div & 0x3) << 4);\n\t\tbreak;\n\tcase WM8804_MCLK_DIV:\n\t\twm8804 = snd_soc_component_get_drvdata(component);\n\t\twm8804->mclk_div = div;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown clock divider: %d\\n\", div_id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wm8804_dai_ops = {\n\t.hw_params = wm8804_hw_params,\n\t.set_fmt = wm8804_set_fmt,\n\t.set_sysclk = wm8804_set_sysclk,\n\t.set_clkdiv = wm8804_set_clkdiv,\n\t.set_pll = wm8804_set_pll\n};\n\n#define WM8804_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\n#define WM8804_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\t      SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 | \\\n\t\t      SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | \\\n\t\t      SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)\n\nstatic struct snd_soc_dai_driver wm8804_dai = {\n\t.name = \"wm8804-spdif\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8804_RATES,\n\t\t.formats = WM8804_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8804_RATES,\n\t\t.formats = WM8804_FORMATS,\n\t},\n\t.ops = &wm8804_dai_ops,\n\t.symmetric_rate = 1\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8804 = {\n\t.dapm_widgets\t\t= wm8804_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8804_dapm_widgets),\n\t.dapm_routes\t\t= wm8804_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8804_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nconst struct regmap_config wm8804_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = WM8804_MAX_REGISTER,\n\t.volatile_reg = wm8804_volatile,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8804_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8804_reg_defaults),\n};\nEXPORT_SYMBOL_GPL(wm8804_regmap_config);\n\nint wm8804_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct wm8804_priv *wm8804;\n\tunsigned int id1, id2;\n\tint i, ret;\n\n\twm8804 = devm_kzalloc(dev, sizeof(*wm8804), GFP_KERNEL);\n\tif (!wm8804)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, wm8804);\n\n\twm8804->dev = dev;\n\twm8804->regmap = regmap;\n\n\twm8804->reset = devm_gpiod_get_optional(dev, \"wlf,reset\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(wm8804->reset)) {\n\t\tret = PTR_ERR(wm8804->reset);\n\t\tdev_err(dev, \"Failed to get reset line: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++)\n\t\twm8804->supplies[i].supply = wm8804_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(wm8804->supplies),\n\t\t\t\t      wm8804->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8804->disable_nb[0].notifier_call = wm8804_regulator_event_0;\n\twm8804->disable_nb[1].notifier_call = wm8804_regulator_event_1;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wm8804->supplies); i++) {\n\t\tstruct regulator *regulator = wm8804->supplies[i].consumer;\n\n\t\tret = devm_regulator_register_notifier(regulator,\n\t\t\t\t\t\t       &wm8804->disable_nb[i]);\n\t\tif (ret != 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to register regulator notifier: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\n\t\t\t\t    wm8804->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(wm8804->reset, 1);\n\n\tret = regmap_read(regmap, WM8804_RST_DEVID1, &id1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\tret = regmap_read(regmap, WM8804_DEVID2, &id2);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\tid2 = (id2 << 8) | id1;\n\n\tif (id2 != 0x8805) {\n\t\tdev_err(dev, \"Invalid device ID: %#x\\n\", id2);\n\t\tret = -EINVAL;\n\t\tgoto err_reg_enable;\n\t}\n\n\tret = regmap_read(regmap, WM8804_DEVREV, &id1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device revision: %d\\n\",\n\t\t\tret);\n\t\tgoto err_reg_enable;\n\t}\n\tdev_info(dev, \"revision %c\\n\", id1 + 'A');\n\n\tif (!wm8804->reset) {\n\t\tret = wm8804_soft_reset(wm8804);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to issue reset: %d\\n\", ret);\n\t\t\tgoto err_reg_enable;\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &soc_component_dev_wm8804,\n\t\t\t\t     &wm8804_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\treturn 0;\n\nerr_reg_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies), wm8804->supplies);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm8804_probe);\n\nvoid wm8804_remove(struct device *dev)\n{\n\tpm_runtime_disable(dev);\n}\nEXPORT_SYMBOL_GPL(wm8804_remove);\n\n#if IS_ENABLED(CONFIG_PM)\nstatic int wm8804_runtime_resume(struct device *dev)\n{\n\tstruct wm8804_priv *wm8804 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8804->supplies),\n\t\t\t\t    wm8804->supplies);\n\tif (ret) {\n\t\tdev_err(wm8804->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_sync(wm8804->regmap);\n\n\t \n\tregmap_update_bits(wm8804->regmap, WM8804_PWRDN, 0x8, 0x0);\n\n\treturn 0;\n}\n\nstatic int wm8804_runtime_suspend(struct device *dev)\n{\n\tstruct wm8804_priv *wm8804 = dev_get_drvdata(dev);\n\n\t \n\tregmap_update_bits(wm8804->regmap, WM8804_PWRDN, 0x8, 0x8);\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8804->supplies),\n\t\t\t       wm8804->supplies);\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops wm8804_pm = {\n\tSET_RUNTIME_PM_OPS(wm8804_runtime_suspend, wm8804_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(wm8804_pm);\n\nMODULE_DESCRIPTION(\"ASoC WM8804 driver\");\nMODULE_AUTHOR(\"Dimitris Papastamos <dp@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}