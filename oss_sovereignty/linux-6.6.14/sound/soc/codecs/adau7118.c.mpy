{
  "module_name": "adau7118.c",
  "hash_id": "1c51dc843848d3f6b7affdeaba4b05ddcd5b33645e382e243540aca200704555",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau7118.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n\n#include \"adau7118.h\"\n\n#define ADAU7118_DEC_RATIO_MASK\t\tGENMASK(1, 0)\n#define ADAU7118_DEC_RATIO(x)\t\tFIELD_PREP(ADAU7118_DEC_RATIO_MASK, x)\n#define ADAU7118_CLK_MAP_MASK\t\tGENMASK(7, 4)\n#define ADAU7118_SLOT_WIDTH_MASK\tGENMASK(5, 4)\n#define ADAU7118_SLOT_WIDTH(x)\t\tFIELD_PREP(ADAU7118_SLOT_WIDTH_MASK, x)\n#define ADAU7118_TRISTATE_MASK\t\tBIT(6)\n#define ADAU7118_TRISTATE(x)\t\tFIELD_PREP(ADAU7118_TRISTATE_MASK, x)\n#define ADAU7118_DATA_FMT_MASK\t\tGENMASK(3, 1)\n#define ADAU7118_DATA_FMT(x)\t\tFIELD_PREP(ADAU7118_DATA_FMT_MASK, x)\n#define ADAU7118_SAI_MODE_MASK\t\tBIT(0)\n#define ADAU7118_SAI_MODE(x)\t\tFIELD_PREP(ADAU7118_SAI_MODE_MASK, x)\n#define ADAU7118_LRCLK_BCLK_POL_MASK\tGENMASK(1, 0)\n#define ADAU7118_LRCLK_BCLK_POL(x) \\\n\t\t\t\tFIELD_PREP(ADAU7118_LRCLK_BCLK_POL_MASK, x)\n#define ADAU7118_SPT_SLOT_MASK\t\tGENMASK(7, 4)\n#define ADAU7118_SPT_SLOT(x)\t\tFIELD_PREP(ADAU7118_SPT_SLOT_MASK, x)\n#define ADAU7118_FULL_SOFT_R_MASK\tBIT(1)\n#define ADAU7118_FULL_SOFT_R(x)\t\tFIELD_PREP(ADAU7118_FULL_SOFT_R_MASK, x)\n\nstruct adau7118_data {\n\tstruct regmap *map;\n\tstruct device *dev;\n\tstruct regulator *iovdd;\n\tstruct regulator *dvdd;\n\tu32 slot_width;\n\tu32 slots;\n\tbool hw_mode;\n\tbool right_j;\n};\n\n \nstatic const struct snd_kcontrol_new adau7118_dapm_pdm_control[4] = {\n\tSOC_DAPM_SINGLE(\"Capture Switch\", ADAU7118_REG_ENABLES, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Capture Switch\", ADAU7118_REG_ENABLES, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Capture Switch\", ADAU7118_REG_ENABLES, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Capture Switch\", ADAU7118_REG_ENABLES, 3, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget adau7118_widgets_sw[] = {\n\t \n\tSND_SOC_DAPM_SWITCH(\"PDM0\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adau7118_dapm_pdm_control[0]),\n\tSND_SOC_DAPM_SWITCH(\"PDM1\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adau7118_dapm_pdm_control[1]),\n\tSND_SOC_DAPM_SWITCH(\"PDM2\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adau7118_dapm_pdm_control[2]),\n\tSND_SOC_DAPM_SWITCH(\"PDM3\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &adau7118_dapm_pdm_control[3]),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"PDM_CLK0\", ADAU7118_REG_ENABLES, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PDM_CLK1\", ADAU7118_REG_ENABLES, 5, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX1\", \"Capture\", 0, ADAU7118_REG_SPT_CX(0),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX2\", \"Capture\", 0, ADAU7118_REG_SPT_CX(1),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX3\", \"Capture\", 0, ADAU7118_REG_SPT_CX(2),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX4\", \"Capture\", 0, ADAU7118_REG_SPT_CX(3),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX5\", \"Capture\", 0, ADAU7118_REG_SPT_CX(4),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX6\", \"Capture\", 0, ADAU7118_REG_SPT_CX(5),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX7\", \"Capture\", 0, ADAU7118_REG_SPT_CX(6),\n\t\t\t     0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX8\", \"Capture\", 0, ADAU7118_REG_SPT_CX(7),\n\t\t\t     0, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau7118_routes_sw[] = {\n\t{ \"PDM0\", \"Capture Switch\", \"PDM_DAT0\" },\n\t{ \"PDM1\", \"Capture Switch\", \"PDM_DAT1\" },\n\t{ \"PDM2\", \"Capture Switch\", \"PDM_DAT2\" },\n\t{ \"PDM3\", \"Capture Switch\", \"PDM_DAT3\" },\n\t{ \"AIF1TX1\", NULL, \"PDM0\" },\n\t{ \"AIF1TX2\", NULL, \"PDM0\" },\n\t{ \"AIF1TX3\", NULL, \"PDM1\" },\n\t{ \"AIF1TX4\", NULL, \"PDM1\" },\n\t{ \"AIF1TX5\", NULL, \"PDM2\" },\n\t{ \"AIF1TX6\", NULL, \"PDM2\" },\n\t{ \"AIF1TX7\", NULL, \"PDM3\" },\n\t{ \"AIF1TX8\", NULL, \"PDM3\" },\n\t{ \"Capture\", NULL, \"PDM_CLK0\" },\n\t{ \"Capture\", NULL, \"PDM_CLK1\" },\n};\n\nstatic const struct snd_soc_dapm_widget adau7118_widgets_hw[] = {\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau7118_routes_hw[] = {\n\t{ \"AIF1TX\", NULL, \"PDM_DAT0\" },\n\t{ \"AIF1TX\", NULL, \"PDM_DAT1\" },\n\t{ \"AIF1TX\", NULL, \"PDM_DAT2\" },\n\t{ \"AIF1TX\", NULL, \"PDM_DAT3\" },\n};\n\nstatic const struct snd_soc_dapm_widget adau7118_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"PDM_DAT0\"),\n\tSND_SOC_DAPM_INPUT(\"PDM_DAT1\"),\n\tSND_SOC_DAPM_INPUT(\"PDM_DAT2\"),\n\tSND_SOC_DAPM_INPUT(\"PDM_DAT3\"),\n};\n\nstatic int adau7118_set_channel_map(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_num, unsigned int *tx_slot,\n\t\t\t\t    unsigned int rx_num, unsigned int *rx_slot)\n{\n\tstruct adau7118_data *st =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tint chan, ret;\n\n\tdev_dbg(st->dev, \"Set channel map, %d\", tx_num);\n\n\tfor (chan = 0; chan < tx_num; chan++) {\n\t\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\tADAU7118_REG_SPT_CX(chan),\n\t\t\t\t\tADAU7118_SPT_SLOT_MASK,\n\t\t\t\t\tADAU7118_SPT_SLOT(tx_slot[chan]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adau7118_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct adau7118_data *st =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tint ret = 0;\n\tu32 regval;\n\n\tdev_dbg(st->dev, \"Set format, fmt:%d\\n\", fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t\t    ADAU7118_DATA_FMT_MASK,\n\t\t\t\t\t\t    ADAU7118_DATA_FMT(0));\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t\t    ADAU7118_DATA_FMT_MASK,\n\t\t\t\t\t\t    ADAU7118_DATA_FMT(1));\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tst->right_j = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(st->dev, \"Invalid format %d\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tregval = ADAU7118_LRCLK_BCLK_POL(0);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tregval = ADAU7118_LRCLK_BCLK_POL(2);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tregval = ADAU7118_LRCLK_BCLK_POL(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tregval = ADAU7118_LRCLK_BCLK_POL(3);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(st->dev, \"Invalid Inv mask %d\",\n\t\t\tfmt & SND_SOC_DAIFMT_INV_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t    ADAU7118_REG_SPT_CTRL2,\n\t\t\t\t\t    ADAU7118_LRCLK_BCLK_POL_MASK,\n\t\t\t\t\t    regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int adau7118_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct adau7118_data *st =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\tdev_dbg(st->dev, \"Set tristate, %d\\n\", tristate);\n\n\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t    ADAU7118_TRISTATE_MASK,\n\t\t\t\t\t    ADAU7118_TRISTATE(tristate));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int adau7118_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t unsigned int rx_mask, int slots,\n\t\t\t\t int slot_width)\n{\n\tstruct adau7118_data *st =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tint ret = 0;\n\tu32 regval;\n\n\tdev_dbg(st->dev, \"Set tdm, slots:%d width:%d\\n\", slots, slot_width);\n\n\tswitch (slot_width) {\n\tcase 32:\n\t\tregval = ADAU7118_SLOT_WIDTH(0);\n\t\tbreak;\n\tcase 24:\n\t\tregval = ADAU7118_SLOT_WIDTH(2);\n\t\tbreak;\n\tcase 16:\n\t\tregval = ADAU7118_SLOT_WIDTH(1);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(st->dev, \"Invalid slot width:%d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t    ADAU7118_SLOT_WIDTH_MASK, regval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tst->slot_width = slot_width;\n\tst->slots = slots;\n\n\treturn 0;\n}\n\nstatic int adau7118_hw_params(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct adau7118_data *st =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\tu32 data_width = params_width(params), slots_width;\n\tint ret;\n\tu32 regval;\n\n\tif (!st->slots) {\n\t\t \n\t\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t\t    ADAU7118_SAI_MODE_MASK,\n\t\t\t\t\t\t    ADAU7118_SAI_MODE(0));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tslots_width = 32;\n\t} else {\n\t\tslots_width = st->slot_width;\n\t}\n\n\tif (data_width > slots_width) {\n\t\tdev_err(st->dev, \"Invalid data_width:%d, slots_width:%d\",\n\t\t\tdata_width, slots_width);\n\t\treturn -EINVAL;\n\t}\n\n\tif (st->right_j) {\n\t\tswitch (slots_width - data_width) {\n\t\tcase 8:\n\t\t\t \n\t\t\tregval = ADAU7118_DATA_FMT(2);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\t \n\t\t\tregval = ADAU7118_DATA_FMT(3);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\t \n\t\t\tregval = ADAU7118_DATA_FMT(4);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(st->dev,\n\t\t\t\t\"Cannot set right_j setting, slot_w:%d, data_w:%d\\n\",\n\t\t\t\t\tslots_width, data_width);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t\t    ADAU7118_REG_SPT_CTRL1,\n\t\t\t\t\t\t    ADAU7118_DATA_FMT_MASK,\n\t\t\t\t\t\t    regval);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adau7118_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct adau7118_data *st = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tdev_dbg(st->dev, \"Set bias level %d\\n\", level);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) ==\n\t\t\t\t\t\t\tSND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tret = regulator_enable(st->iovdd);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tret = regulator_enable(st->dvdd);\n\t\t\tif (ret) {\n\t\t\t\tregulator_disable(st->iovdd);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (st->hw_mode)\n\t\t\t\treturn 0;\n\n\t\t\tregcache_cache_only(st->map, false);\n\t\t\t \n\t\t\tret = snd_soc_component_cache_sync(component);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tret = regulator_disable(st->dvdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_disable(st->iovdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (st->hw_mode)\n\t\t\treturn 0;\n\n\t\t \n\t\tregcache_mark_dirty(st->map);\n\t\tregcache_cache_only(st->map, true);\n\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int adau7118_component_probe(struct snd_soc_component *component)\n{\n\tstruct adau7118_data *st = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\t\t\t\tsnd_soc_component_get_dapm(component);\n\tint ret = 0;\n\n\tif (st->hw_mode) {\n\t\tret = snd_soc_dapm_new_controls(dapm, adau7118_widgets_hw,\n\t\t\t\t\tARRAY_SIZE(adau7118_widgets_hw));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, adau7118_routes_hw,\n\t\t\t\t\t      ARRAY_SIZE(adau7118_routes_hw));\n\t} else {\n\t\tsnd_soc_component_init_regmap(component, st->map);\n\t\tret = snd_soc_dapm_new_controls(dapm, adau7118_widgets_sw,\n\t\t\t\t\tARRAY_SIZE(adau7118_widgets_sw));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, adau7118_routes_sw,\n\t\t\t\t\t      ARRAY_SIZE(adau7118_routes_sw));\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops adau7118_ops = {\n\t.hw_params = adau7118_hw_params,\n\t.set_channel_map = adau7118_set_channel_map,\n\t.set_fmt = adau7118_set_fmt,\n\t.set_tdm_slot = adau7118_set_tdm_slot,\n\t.set_tristate = adau7118_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver adau7118_dai = {\n\t.name = \"adau7118-hifi-capture\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\tSNDRV_PCM_FMTBIT_S20_LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_3LE,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 4000,\n\t\t.rate_max = 192000,\n\t\t.sig_bits = 24,\n\t},\n};\n\nstatic const struct snd_soc_component_driver adau7118_component_driver = {\n\t.probe\t\t\t= adau7118_component_probe,\n\t.set_bias_level\t\t= adau7118_set_bias_level,\n\t.dapm_widgets\t\t= adau7118_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adau7118_widgets),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int adau7118_regulator_setup(struct adau7118_data *st)\n{\n\tst->iovdd = devm_regulator_get(st->dev, \"iovdd\");\n\tif (IS_ERR(st->iovdd)) {\n\t\tdev_err(st->dev, \"Could not get iovdd: %ld\\n\",\n\t\t\tPTR_ERR(st->iovdd));\n\t\treturn PTR_ERR(st->iovdd);\n\t}\n\n\tst->dvdd = devm_regulator_get(st->dev, \"dvdd\");\n\tif (IS_ERR(st->dvdd)) {\n\t\tdev_err(st->dev, \"Could not get dvdd: %ld\\n\",\n\t\t\tPTR_ERR(st->dvdd));\n\t\treturn PTR_ERR(st->dvdd);\n\t}\n\t \n\tif (!st->hw_mode) {\n\t\tregcache_mark_dirty(st->map);\n\t\tregcache_cache_only(st->map, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int adau7118_parset_dt(const struct adau7118_data *st)\n{\n\tint ret;\n\tu32 dec_ratio = 0;\n\t \n\tu32 clk_map[4], regval;\n\n\tif (st->hw_mode)\n\t\treturn 0;\n\n\tret = device_property_read_u32(st->dev, \"adi,decimation-ratio\",\n\t\t\t\t       &dec_ratio);\n\tif (!ret) {\n\t\tswitch (dec_ratio) {\n\t\tcase 64:\n\t\t\tregval = ADAU7118_DEC_RATIO(0);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tregval = ADAU7118_DEC_RATIO(1);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tregval = ADAU7118_DEC_RATIO(2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(st->dev, \"Invalid dec ratio: %u\", dec_ratio);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = regmap_update_bits(st->map,\n\t\t\t\t\t ADAU7118_REG_DEC_RATIO_CLK_MAP,\n\t\t\t\t\t ADAU7118_DEC_RATIO_MASK, regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = device_property_read_u32_array(st->dev, \"adi,pdm-clk-map\",\n\t\t\t\t\t     clk_map, ARRAY_SIZE(clk_map));\n\tif (!ret) {\n\t\tint pdm;\n\t\tu32 _clk_map = 0;\n\n\t\tfor (pdm = 0; pdm < ARRAY_SIZE(clk_map); pdm++)\n\t\t\t_clk_map |= (clk_map[pdm] << (pdm + 4));\n\n\t\tret = regmap_update_bits(st->map,\n\t\t\t\t\t ADAU7118_REG_DEC_RATIO_CLK_MAP,\n\t\t\t\t\t ADAU7118_CLK_MAP_MASK, _clk_map);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint adau7118_probe(struct device *dev, struct regmap *map, bool hw_mode)\n{\n\tstruct adau7118_data *st;\n\tint ret;\n\n\tst = devm_kzalloc(dev, sizeof(*st), GFP_KERNEL);\n\tif (!st)\n\t\treturn -ENOMEM;\n\n\tst->dev = dev;\n\tst->hw_mode = hw_mode;\n\tdev_set_drvdata(dev, st);\n\n\tif (!hw_mode) {\n\t\tst->map = map;\n\t\tadau7118_dai.ops = &adau7118_ops;\n\t\t \n\t\tret = regmap_update_bits(map, ADAU7118_REG_RESET,\n\t\t\t\t\t ADAU7118_FULL_SOFT_R_MASK,\n\t\t\t\t\t ADAU7118_FULL_SOFT_R(1));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = adau7118_parset_dt(st);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adau7118_regulator_setup(st);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t\t       &adau7118_component_driver,\n\t\t\t\t\t       &adau7118_dai, 1);\n}\nEXPORT_SYMBOL_GPL(adau7118_probe);\n\nMODULE_AUTHOR(\"Nuno Sa <nuno.sa@analog.com>\");\nMODULE_DESCRIPTION(\"ADAU7118 8 channel PDM-to-I2S/TDM Converter driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}