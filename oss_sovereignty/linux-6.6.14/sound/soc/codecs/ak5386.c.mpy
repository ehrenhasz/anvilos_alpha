{
  "module_name": "ak5386.c",
  "hash_id": "c1cdb79b15a0da51f1b66fe07c9c18ff4951340821efbab2a98fdd8f141fe6bc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak5386.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_device.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/initval.h>\n\nstatic const char * const supply_names[] = {\n\t\"va\", \"vd\"\n};\n\nstruct ak5386_priv {\n\tint reset_gpio;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n};\n\nstatic const struct snd_soc_dapm_widget ak5386_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"AINL\"),\nSND_SOC_DAPM_INPUT(\"AINR\"),\n};\n\nstatic const struct snd_soc_dapm_route ak5386_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"AINL\" },\n\t{ \"Capture\", NULL, \"AINR\" },\n};\n\nstatic int ak5386_soc_probe(struct snd_soc_component *component)\n{\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\treturn regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n\nstatic void ak5386_soc_remove(struct snd_soc_component *component)\n{\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n\n#ifdef CONFIG_PM\nstatic int ak5386_soc_suspend(struct snd_soc_component *component)\n{\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\treturn 0;\n}\n\nstatic int ak5386_soc_resume(struct snd_soc_component *component)\n{\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\treturn regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n#else\n#define ak5386_soc_suspend\tNULL\n#define ak5386_soc_resume\tNULL\n#endif  \n\nstatic const struct snd_soc_component_driver soc_component_ak5386 = {\n\t.probe\t\t\t= ak5386_soc_probe,\n\t.remove\t\t\t= ak5386_soc_remove,\n\t.suspend\t\t= ak5386_soc_suspend,\n\t.resume\t\t\t= ak5386_soc_resume,\n\t.dapm_widgets\t\t= ak5386_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak5386_dapm_widgets),\n\t.dapm_routes\t\t= ak5386_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak5386_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int ak5386_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tformat &= SND_SOC_DAIFMT_FORMAT_MASK;\n\tif (format != SND_SOC_DAIFMT_LEFT_J &&\n\t    format != SND_SOC_DAIFMT_I2S) {\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ak5386_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\n\t \n\n\tif (gpio_is_valid(priv->reset_gpio))\n\t\tgpio_set_value(priv->reset_gpio, 1);\n\n\treturn 0;\n}\n\nstatic int ak5386_hw_free(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak5386_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tif (gpio_is_valid(priv->reset_gpio))\n\t\tgpio_set_value(priv->reset_gpio, 0);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ak5386_dai_ops = {\n\t.set_fmt\t= ak5386_set_dai_fmt,\n\t.hw_params\t= ak5386_hw_params,\n\t.hw_free\t= ak5386_hw_free,\n};\n\nstatic struct snd_soc_dai_driver ak5386_dai = {\n\t.name\t\t= \"ak5386-hifi\",\n\t.capture\t= {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= SNDRV_PCM_FMTBIT_S8     |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\t  SNDRV_PCM_FMTBIT_S24_3LE,\n\t},\n\t.ops\t= &ak5386_dai_ops,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ak5386_dt_ids[] = {\n\t{ .compatible = \"asahi-kasei,ak5386\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ak5386_dt_ids);\n#endif\n\nstatic int ak5386_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ak5386_priv *priv;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reset_gpio = -EINVAL;\n\tdev_set_drvdata(dev, priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (of_match_device(of_match_ptr(ak5386_dt_ids), dev))\n\t\tpriv->reset_gpio = of_get_named_gpio(dev->of_node,\n\t\t\t\t\t\t      \"reset-gpio\", 0);\n\n\tif (gpio_is_valid(priv->reset_gpio))\n\t\tif (devm_gpio_request_one(dev, priv->reset_gpio,\n\t\t\t\t\t  GPIOF_OUT_INIT_LOW,\n\t\t\t\t\t  \"AK5386 Reset\"))\n\t\t\tpriv->reset_gpio = -EINVAL;\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_ak5386,\n\t\t\t\t      &ak5386_dai, 1);\n}\n\nstatic struct platform_driver ak5386_driver = {\n\t.probe\t\t= ak5386_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"ak5386\",\n\t\t.of_match_table = of_match_ptr(ak5386_dt_ids),\n\t},\n};\n\nmodule_platform_driver(ak5386_driver);\n\nMODULE_DESCRIPTION(\"ASoC driver for AK5386 ADC\");\nMODULE_AUTHOR(\"Daniel Mack <zonque@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}