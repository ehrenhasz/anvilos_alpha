{
  "module_name": "cs35l56-shared.c",
  "hash_id": "cdb470d809f4f1fdd80b64825ab76c266fc140a2becd0023d9c434eac63e4847",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l56-shared.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include \"cs35l56.h\"\n\nstatic const struct reg_sequence cs35l56_patch[] = {\n\t \n\t{ CS35L56_MAIN_RENDER_USER_MUTE,\t0x00000000 },\n\t{ CS35L56_MAIN_RENDER_USER_VOLUME,\t0x00000000 },\n\t{ CS35L56_MAIN_POSTURE_NUMBER,\t\t0x00000000 },\n};\n\nint cs35l56_set_patch(struct cs35l56_base *cs35l56_base)\n{\n\treturn regmap_register_patch(cs35l56_base->regmap, cs35l56_patch,\n\t\t\t\t     ARRAY_SIZE(cs35l56_patch));\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_set_patch, SND_SOC_CS35L56_SHARED);\n\nstatic const struct reg_default cs35l56_reg_defaults[] = {\n\t{ CS35L56_ASP1_ENABLES1,\t\t0x00000000 },\n\t{ CS35L56_ASP1_CONTROL1,\t\t0x00000028 },\n\t{ CS35L56_ASP1_CONTROL2,\t\t0x18180200 },\n\t{ CS35L56_ASP1_CONTROL3,\t\t0x00000002 },\n\t{ CS35L56_ASP1_FRAME_CONTROL1,\t\t0x03020100 },\n\t{ CS35L56_ASP1_FRAME_CONTROL5,\t\t0x00020100 },\n\t{ CS35L56_ASP1_DATA_CONTROL1,\t\t0x00000018 },\n\t{ CS35L56_ASP1_DATA_CONTROL5,\t\t0x00000018 },\n\t{ CS35L56_ASP1TX1_INPUT,\t\t0x00000018 },\n\t{ CS35L56_ASP1TX2_INPUT,\t\t0x00000019 },\n\t{ CS35L56_ASP1TX3_INPUT,\t\t0x00000020 },\n\t{ CS35L56_ASP1TX4_INPUT,\t\t0x00000028 },\n\t{ CS35L56_SWIRE_DP3_CH1_INPUT,\t\t0x00000018 },\n\t{ CS35L56_SWIRE_DP3_CH2_INPUT,\t\t0x00000019 },\n\t{ CS35L56_SWIRE_DP3_CH3_INPUT,\t\t0x00000029 },\n\t{ CS35L56_SWIRE_DP3_CH4_INPUT,\t\t0x00000028 },\n\t{ CS35L56_IRQ1_CFG,\t\t\t0x00000000 },\n\t{ CS35L56_IRQ1_MASK_1,\t\t\t0x83ffffff },\n\t{ CS35L56_IRQ1_MASK_2,\t\t\t0xffff7fff },\n\t{ CS35L56_IRQ1_MASK_4,\t\t\t0xe0ffffff },\n\t{ CS35L56_IRQ1_MASK_8,\t\t\t0xfc000fff },\n\t{ CS35L56_IRQ1_MASK_18,\t\t\t0x1f7df0ff },\n\t{ CS35L56_IRQ1_MASK_20,\t\t\t0x15c00000 },\n\t{ CS35L56_MAIN_RENDER_USER_MUTE,\t0x00000000 },\n\t{ CS35L56_MAIN_RENDER_USER_VOLUME,\t0x00000000 },\n\t{ CS35L56_MAIN_POSTURE_NUMBER,\t\t0x00000000 },\n};\n\nstatic bool cs35l56_is_dsp_memory(unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L56_DSP1_XMEM_PACKED_0 ... CS35L56_DSP1_XMEM_PACKED_6143:\n\tcase CS35L56_DSP1_XMEM_UNPACKED32_0 ... CS35L56_DSP1_XMEM_UNPACKED32_4095:\n\tcase CS35L56_DSP1_XMEM_UNPACKED24_0 ... CS35L56_DSP1_XMEM_UNPACKED24_8191:\n\tcase CS35L56_DSP1_YMEM_PACKED_0 ... CS35L56_DSP1_YMEM_PACKED_4604:\n\tcase CS35L56_DSP1_YMEM_UNPACKED32_0 ... CS35L56_DSP1_YMEM_UNPACKED32_3070:\n\tcase CS35L56_DSP1_YMEM_UNPACKED24_0 ... CS35L56_DSP1_YMEM_UNPACKED24_6141:\n\tcase CS35L56_DSP1_PMEM_0 ... CS35L56_DSP1_PMEM_5114:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l56_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L56_DEVID:\n\tcase CS35L56_REVID:\n\tcase CS35L56_RELID:\n\tcase CS35L56_OTPID:\n\tcase CS35L56_SFT_RESET:\n\tcase CS35L56_GLOBAL_ENABLES:\n\tcase CS35L56_BLOCK_ENABLES:\n\tcase CS35L56_BLOCK_ENABLES2:\n\tcase CS35L56_REFCLK_INPUT:\n\tcase CS35L56_GLOBAL_SAMPLE_RATE:\n\tcase CS35L56_ASP1_ENABLES1:\n\tcase CS35L56_ASP1_CONTROL1:\n\tcase CS35L56_ASP1_CONTROL2:\n\tcase CS35L56_ASP1_CONTROL3:\n\tcase CS35L56_ASP1_FRAME_CONTROL1:\n\tcase CS35L56_ASP1_FRAME_CONTROL5:\n\tcase CS35L56_ASP1_DATA_CONTROL1:\n\tcase CS35L56_ASP1_DATA_CONTROL5:\n\tcase CS35L56_DACPCM1_INPUT:\n\tcase CS35L56_DACPCM2_INPUT:\n\tcase CS35L56_ASP1TX1_INPUT:\n\tcase CS35L56_ASP1TX2_INPUT:\n\tcase CS35L56_ASP1TX3_INPUT:\n\tcase CS35L56_ASP1TX4_INPUT:\n\tcase CS35L56_DSP1RX1_INPUT:\n\tcase CS35L56_DSP1RX2_INPUT:\n\tcase CS35L56_SWIRE_DP3_CH1_INPUT:\n\tcase CS35L56_SWIRE_DP3_CH2_INPUT:\n\tcase CS35L56_SWIRE_DP3_CH3_INPUT:\n\tcase CS35L56_SWIRE_DP3_CH4_INPUT:\n\tcase CS35L56_IRQ1_CFG:\n\tcase CS35L56_IRQ1_STATUS:\n\tcase CS35L56_IRQ1_EINT_1 ... CS35L56_IRQ1_EINT_8:\n\tcase CS35L56_IRQ1_EINT_18:\n\tcase CS35L56_IRQ1_EINT_20:\n\tcase CS35L56_IRQ1_MASK_1:\n\tcase CS35L56_IRQ1_MASK_2:\n\tcase CS35L56_IRQ1_MASK_4:\n\tcase CS35L56_IRQ1_MASK_8:\n\tcase CS35L56_IRQ1_MASK_18:\n\tcase CS35L56_IRQ1_MASK_20:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_1:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_2:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_3:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_4:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_5:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_6:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_7:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_8:\n\tcase CS35L56_DSP_RESTRICT_STS1:\n\tcase CS35L56_DSP1_SYS_INFO_ID ... CS35L56_DSP1_SYS_INFO_END:\n\tcase CS35L56_DSP1_AHBM_WINDOW_DEBUG_0:\n\tcase CS35L56_DSP1_AHBM_WINDOW_DEBUG_1:\n\tcase CS35L56_DSP1_SCRATCH1:\n\tcase CS35L56_DSP1_SCRATCH2:\n\tcase CS35L56_DSP1_SCRATCH3:\n\tcase CS35L56_DSP1_SCRATCH4:\n\t\treturn true;\n\tdefault:\n\t\treturn cs35l56_is_dsp_memory(reg);\n\t}\n}\n\nstatic bool cs35l56_precious_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L56_DSP1_XMEM_PACKED_0 ... CS35L56_DSP1_XMEM_PACKED_6143:\n\tcase CS35L56_DSP1_YMEM_PACKED_0 ... CS35L56_DSP1_YMEM_PACKED_4604:\n\tcase CS35L56_DSP1_PMEM_0 ... CS35L56_DSP1_PMEM_5114:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l56_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L56_DEVID:\n\tcase CS35L56_REVID:\n\tcase CS35L56_RELID:\n\tcase CS35L56_OTPID:\n\tcase CS35L56_SFT_RESET:\n\tcase CS35L56_GLOBAL_ENABLES:\t\t    \n\tcase CS35L56_BLOCK_ENABLES:\t\t    \n\tcase CS35L56_BLOCK_ENABLES2:\t\t    \n\tcase CS35L56_REFCLK_INPUT:\t\t    \n\tcase CS35L56_GLOBAL_SAMPLE_RATE:\t    \n\tcase CS35L56_DACPCM1_INPUT:\t\t    \n\tcase CS35L56_DACPCM2_INPUT:\t\t    \n\tcase CS35L56_DSP1RX1_INPUT:\t\t    \n\tcase CS35L56_DSP1RX2_INPUT:\t\t    \n\tcase CS35L56_IRQ1_STATUS:\n\tcase CS35L56_IRQ1_EINT_1 ... CS35L56_IRQ1_EINT_8:\n\tcase CS35L56_IRQ1_EINT_18:\n\tcase CS35L56_IRQ1_EINT_20:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_1:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_2:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_3:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_4:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_5:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_6:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_7:\n\tcase CS35L56_DSP_VIRTUAL1_MBOX_8:\n\tcase CS35L56_DSP_RESTRICT_STS1:\n\tcase CS35L56_DSP1_SYS_INFO_ID ... CS35L56_DSP1_SYS_INFO_END:\n\tcase CS35L56_DSP1_AHBM_WINDOW_DEBUG_0:\n\tcase CS35L56_DSP1_AHBM_WINDOW_DEBUG_1:\n\tcase CS35L56_DSP1_SCRATCH1:\n\tcase CS35L56_DSP1_SCRATCH2:\n\tcase CS35L56_DSP1_SCRATCH3:\n\tcase CS35L56_DSP1_SCRATCH4:\n\t\treturn true;\n\tcase CS35L56_MAIN_RENDER_USER_MUTE:\n\tcase CS35L56_MAIN_RENDER_USER_VOLUME:\n\tcase CS35L56_MAIN_POSTURE_NUMBER:\n\t\treturn false;\n\tdefault:\n\t\treturn cs35l56_is_dsp_memory(reg);\n\t}\n}\n\nint cs35l56_mbox_send(struct cs35l56_base *cs35l56_base, unsigned int command)\n{\n\tunsigned int val;\n\tint ret;\n\n\tregmap_write(cs35l56_base->regmap, CS35L56_DSP_VIRTUAL1_MBOX_1, command);\n\tret = regmap_read_poll_timeout(cs35l56_base->regmap, CS35L56_DSP_VIRTUAL1_MBOX_1,\n\t\t\t\t       val, (val == 0),\n\t\t\t\t       CS35L56_MBOX_POLL_US, CS35L56_MBOX_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_warn(cs35l56_base->dev, \"MBOX command %#x failed: %d\\n\", command, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_mbox_send, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_firmware_shutdown(struct cs35l56_base *cs35l56_base)\n{\n\tint ret;\n\tunsigned int reg;\n\tunsigned int val;\n\n\tret = cs35l56_mbox_send(cs35l56_base, CS35L56_MBOX_CMD_SHUTDOWN);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cs35l56_base->rev < CS35L56_REVID_B0)\n\t\treg = CS35L56_DSP1_PM_CUR_STATE_A1;\n\telse\n\t\treg = CS35L56_DSP1_PM_CUR_STATE;\n\n\tret = regmap_read_poll_timeout(cs35l56_base->regmap,  reg,\n\t\t\t\t       val, (val == CS35L56_HALO_STATE_SHUTDOWN),\n\t\t\t\t       CS35L56_HALO_STATE_POLL_US,\n\t\t\t\t       CS35L56_HALO_STATE_TIMEOUT_US);\n\tif (ret < 0)\n\t\tdev_err(cs35l56_base->dev, \"Failed to poll PM_CUR_STATE to 1 is %d (ret %d)\\n\",\n\t\t\tval, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_firmware_shutdown, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_wait_for_firmware_boot(struct cs35l56_base *cs35l56_base)\n{\n\tunsigned int reg;\n\tunsigned int val;\n\tint read_ret, poll_ret;\n\n\tif (cs35l56_base->rev < CS35L56_REVID_B0)\n\t\treg = CS35L56_DSP1_HALO_STATE_A1;\n\telse\n\t\treg = CS35L56_DSP1_HALO_STATE;\n\n\t \n\tpoll_ret = read_poll_timeout(regmap_read, read_ret,\n\t\t\t\t     (val < 0xFFFF) && (val >= CS35L56_HALO_STATE_BOOT_DONE),\n\t\t\t\t     CS35L56_HALO_STATE_POLL_US,\n\t\t\t\t     CS35L56_HALO_STATE_TIMEOUT_US,\n\t\t\t\t     false,\n\t\t\t\t     cs35l56_base->regmap, reg, &val);\n\n\tif (poll_ret) {\n\t\tdev_err(cs35l56_base->dev, \"Firmware boot timed out(%d): HALO_STATE=%#x\\n\",\n\t\t\tread_ret, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_wait_for_firmware_boot, SND_SOC_CS35L56_SHARED);\n\nvoid cs35l56_wait_control_port_ready(void)\n{\n\t \n\tusleep_range(CS35L56_CONTROL_PORT_READY_US, 2 * CS35L56_CONTROL_PORT_READY_US);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_wait_control_port_ready, SND_SOC_CS35L56_SHARED);\n\nvoid cs35l56_wait_min_reset_pulse(void)\n{\n\t \n\tusleep_range(CS35L56_RESET_PULSE_MIN_US, 2 * CS35L56_RESET_PULSE_MIN_US);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_wait_min_reset_pulse, SND_SOC_CS35L56_SHARED);\n\nstatic const struct reg_sequence cs35l56_system_reset_seq[] = {\n\tREG_SEQ0(CS35L56_DSP_VIRTUAL1_MBOX_1, CS35L56_MBOX_CMD_SYSTEM_RESET),\n};\n\nvoid cs35l56_system_reset(struct cs35l56_base *cs35l56_base, bool is_soundwire)\n{\n\t \n\tregcache_cache_only(cs35l56_base->regmap, true);\n\tregmap_multi_reg_write_bypassed(cs35l56_base->regmap,\n\t\t\t\t\tcs35l56_system_reset_seq,\n\t\t\t\t\tARRAY_SIZE(cs35l56_system_reset_seq));\n\n\t \n\tif (is_soundwire)\n\t\treturn;\n\n\tcs35l56_wait_control_port_ready();\n\tregcache_cache_only(cs35l56_base->regmap, false);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_system_reset, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_irq_request(struct cs35l56_base *cs35l56_base, int irq)\n{\n\tint ret;\n\n\tif (!irq)\n\t\treturn 0;\n\n\tret = devm_request_threaded_irq(cs35l56_base->dev, irq, NULL, cs35l56_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | IRQF_TRIGGER_LOW,\n\t\t\t\t\t\"cs35l56\", cs35l56_base);\n\tif (!ret)\n\t\tcs35l56_base->irq = irq;\n\telse\n\t\tdev_err(cs35l56_base->dev, \"Failed to get IRQ: %d\\n\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_irq_request, SND_SOC_CS35L56_SHARED);\n\nirqreturn_t cs35l56_irq(int irq, void *data)\n{\n\tstruct cs35l56_base *cs35l56_base = data;\n\tunsigned int status1 = 0, status8 = 0, status20 = 0;\n\tunsigned int mask1, mask8, mask20;\n\tunsigned int val;\n\tint rv;\n\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (!cs35l56_base->init_done)\n\t\treturn IRQ_NONE;\n\n\tmutex_lock(&cs35l56_base->irq_lock);\n\n\trv = pm_runtime_resume_and_get(cs35l56_base->dev);\n\tif (rv < 0) {\n\t\tdev_err(cs35l56_base->dev, \"irq: failed to get pm_runtime: %d\\n\", rv);\n\t\tgoto err_unlock;\n\t}\n\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_STATUS, &val);\n\tif ((val & CS35L56_IRQ1_STS_MASK) == 0) {\n\t\tdev_dbg(cs35l56_base->dev, \"Spurious IRQ: no pending interrupt\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_EINT_1, &status1);\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_MASK_1, &mask1);\n\tstatus1 &= ~mask1;\n\tregmap_write(cs35l56_base->regmap, CS35L56_IRQ1_EINT_1, status1);\n\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_EINT_8, &status8);\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_MASK_8, &mask8);\n\tstatus8 &= ~mask8;\n\tregmap_write(cs35l56_base->regmap, CS35L56_IRQ1_EINT_8, status8);\n\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_EINT_20, &status20);\n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_MASK_20, &mask20);\n\tstatus20 &= ~mask20;\n\t \n\tregmap_write(cs35l56_base->regmap, CS35L56_IRQ1_MASK_20, 0xffffffff);\n\n\tdev_dbg(cs35l56_base->dev, \"%s: %#x %#x\\n\", __func__, status1, status8);\n\n\t \n\tif (!status1 && !status8 && !status20)\n\t\tgoto err;\n\n\tif (status1 & CS35L56_AMP_SHORT_ERR_EINT1_MASK)\n\t\tdev_crit(cs35l56_base->dev, \"Amp short error\\n\");\n\n\tif (status8 & CS35L56_TEMP_ERR_EINT1_MASK)\n\t\tdev_crit(cs35l56_base->dev, \"Overtemp error\\n\");\n\n\tret = IRQ_HANDLED;\n\nerr:\n\tpm_runtime_put(cs35l56_base->dev);\nerr_unlock:\n\tmutex_unlock(&cs35l56_base->irq_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_irq, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_is_fw_reload_needed(struct cs35l56_base *cs35l56_base)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (!cs35l56_base->fw_patched)\n\t\treturn false;\n\n\t \n\tif (cs35l56_base->reset_gpio)\n\t\treturn true;\n\n\t \n\tif (cs35l56_base->secured)\n\t\treturn true;\n\n\tret = pm_runtime_resume_and_get(cs35l56_base->dev);\n\tif (ret) {\n\t\tdev_err(cs35l56_base->dev, \"Failed to runtime_get: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(cs35l56_base->regmap, CS35L56_PROTECTION_STATUS, &val);\n\tif (ret)\n\t\tdev_err(cs35l56_base->dev, \"Failed to read PROTECTION_STATUS: %d\\n\", ret);\n\telse\n\t\tret = !!(val & CS35L56_FIRMWARE_MISSING);\n\n\tpm_runtime_put_autosuspend(cs35l56_base->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_is_fw_reload_needed, SND_SOC_CS35L56_SHARED);\n\nstatic const struct reg_sequence cs35l56_hibernate_seq[] = {\n\t \n\tREG_SEQ0(CS35L56_DSP_VIRTUAL1_MBOX_1, CS35L56_MBOX_CMD_HIBERNATE_NOW),\n};\n\nstatic const struct reg_sequence cs35l56_hibernate_wake_seq[] = {\n\tREG_SEQ0(CS35L56_DSP_VIRTUAL1_MBOX_1, CS35L56_MBOX_CMD_WAKEUP),\n};\n\nint cs35l56_runtime_suspend_common(struct cs35l56_base *cs35l56_base)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (!cs35l56_base->init_done)\n\t\treturn 0;\n\n\t \n\tret = regmap_read_poll_timeout(cs35l56_base->regmap,\n\t\t\t\t       CS35L56_TRANSDUCER_ACTUAL_PS,\n\t\t\t\t       val, (val >= CS35L56_PS3),\n\t\t\t\t       CS35L56_PS3_POLL_US,\n\t\t\t\t       CS35L56_PS3_TIMEOUT_US);\n\tif (ret)\n\t\tdev_warn(cs35l56_base->dev, \"PS3 wait failed: %d\\n\", ret);\n\n\t \n\tregmap_write(cs35l56_base->regmap, CS35L56_IRQ1_EINT_4, CS35L56_OTP_BOOT_DONE_MASK);\n\n\tif (!cs35l56_base->can_hibernate) {\n\t\tregcache_cache_only(cs35l56_base->regmap, true);\n\t\tdev_dbg(cs35l56_base->dev, \"Suspended: no hibernate\");\n\n\t\treturn 0;\n\t}\n\n\t \n\tcs35l56_mbox_send(cs35l56_base, CS35L56_MBOX_CMD_ALLOW_AUTO_HIBERNATE);\n\n\t \n\tregcache_cache_only(cs35l56_base->regmap, true);\n\n\tregmap_multi_reg_write_bypassed(cs35l56_base->regmap,\n\t\t\t\t\tcs35l56_hibernate_seq,\n\t\t\t\t\tARRAY_SIZE(cs35l56_hibernate_seq));\n\n\tdev_dbg(cs35l56_base->dev, \"Suspended: hibernate\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_runtime_suspend_common, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_runtime_resume_common(struct cs35l56_base *cs35l56_base, bool is_soundwire)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (!cs35l56_base->init_done)\n\t\treturn 0;\n\n\tif (!cs35l56_base->can_hibernate)\n\t\tgoto out_sync;\n\n\tif (!is_soundwire) {\n\t\t \n\t\tregmap_multi_reg_write_bypassed(cs35l56_base->regmap,\n\t\t\t\t\t\tcs35l56_hibernate_wake_seq,\n\t\t\t\t\t\tARRAY_SIZE(cs35l56_hibernate_wake_seq));\n\n\t\tcs35l56_wait_control_port_ready();\n\t}\n\nout_sync:\n\tregcache_cache_only(cs35l56_base->regmap, false);\n\n\tret = cs35l56_wait_for_firmware_boot(cs35l56_base);\n\tif (ret) {\n\t\tdev_err(cs35l56_base->dev, \"Hibernate wake failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = cs35l56_mbox_send(cs35l56_base, CS35L56_MBOX_CMD_PREVENT_AUTO_HIBERNATE);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tregmap_read(cs35l56_base->regmap, CS35L56_IRQ1_EINT_4, &val);\n\tif (val & CS35L56_OTP_BOOT_DONE_MASK) {\n\t\tdev_dbg(cs35l56_base->dev, \"Registers reset in suspend\\n\");\n\t\tregcache_mark_dirty(cs35l56_base->regmap);\n\t}\n\n\tregcache_sync(cs35l56_base->regmap);\n\n\tdev_dbg(cs35l56_base->dev, \"Resumed\");\n\n\treturn 0;\n\nerr:\n\tregmap_write(cs35l56_base->regmap, CS35L56_DSP_VIRTUAL1_MBOX_1,\n\t\t     CS35L56_MBOX_CMD_HIBERNATE_NOW);\n\n\tregcache_cache_only(cs35l56_base->regmap, true);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_runtime_resume_common, SND_SOC_CS35L56_SHARED);\n\nstatic const struct cs_dsp_region cs35l56_dsp1_regions[] = {\n\t{ .type = WMFW_HALO_PM_PACKED,\t.base = CS35L56_DSP1_PMEM_0 },\n\t{ .type = WMFW_HALO_XM_PACKED,\t.base = CS35L56_DSP1_XMEM_PACKED_0 },\n\t{ .type = WMFW_HALO_YM_PACKED,\t.base = CS35L56_DSP1_YMEM_PACKED_0 },\n\t{ .type = WMFW_ADSP2_XM,\t.base = CS35L56_DSP1_XMEM_UNPACKED24_0 },\n\t{ .type = WMFW_ADSP2_YM,\t.base = CS35L56_DSP1_YMEM_UNPACKED24_0 },\n};\n\nvoid cs35l56_init_cs_dsp(struct cs35l56_base *cs35l56_base, struct cs_dsp *cs_dsp)\n{\n\tcs_dsp->num = 1;\n\tcs_dsp->type = WMFW_HALO;\n\tcs_dsp->rev = 0;\n\tcs_dsp->dev = cs35l56_base->dev;\n\tcs_dsp->regmap = cs35l56_base->regmap;\n\tcs_dsp->base = CS35L56_DSP1_CORE_BASE;\n\tcs_dsp->base_sysinfo = CS35L56_DSP1_SYS_INFO_ID;\n\tcs_dsp->mem = cs35l56_dsp1_regions;\n\tcs_dsp->num_mems = ARRAY_SIZE(cs35l56_dsp1_regions);\n\tcs_dsp->no_core_startstop = true;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_init_cs_dsp, SND_SOC_CS35L56_SHARED);\n\nint cs35l56_hw_init(struct cs35l56_base *cs35l56_base)\n{\n\tint ret;\n\tunsigned int devid, revid, otpid, secured;\n\n\t \n\tif (!cs35l56_base->reset_gpio)\n\t\tregmap_read(cs35l56_base->regmap, CS35L56_DSP_VIRTUAL1_MBOX_1, &devid);\n\n\tcs35l56_wait_control_port_ready();\n\n\t \n\tret = regmap_read(cs35l56_base->regmap, CS35L56_REVID, &revid);\n\tif (ret < 0) {\n\t\tdev_err(cs35l56_base->dev, \"Get Revision ID failed\\n\");\n\t\treturn ret;\n\t}\n\tcs35l56_base->rev = revid & (CS35L56_AREVID_MASK | CS35L56_MTLREVID_MASK);\n\n\tret = cs35l56_wait_for_firmware_boot(cs35l56_base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(cs35l56_base->regmap, CS35L56_DEVID, &devid);\n\tif (ret < 0) {\n\t\tdev_err(cs35l56_base->dev, \"Get Device ID failed\\n\");\n\t\treturn ret;\n\t}\n\tdevid &= CS35L56_DEVID_MASK;\n\n\tswitch (devid) {\n\tcase 0x35A56:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l56_base->dev, \"Unknown device %x\\n\", devid);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(cs35l56_base->regmap, CS35L56_DSP_RESTRICT_STS1, &secured);\n\tif (ret) {\n\t\tdev_err(cs35l56_base->dev, \"Get Secure status failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (secured & CS35L56_RESTRICTED_MASK)\n\t\tcs35l56_base->secured = true;\n\n\tret = regmap_read(cs35l56_base->regmap, CS35L56_OTPID, &otpid);\n\tif (ret < 0) {\n\t\tdev_err(cs35l56_base->dev, \"Get OTP ID failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(cs35l56_base->dev, \"Cirrus Logic CS35L56%s Rev %02X OTP%d\\n\",\n\t\t cs35l56_base->secured ? \"s\" : \"\", cs35l56_base->rev, otpid);\n\n\t \n\tregmap_write(cs35l56_base->regmap, CS35L56_IRQ1_MASK_20, 0xffffffff);\n\tregmap_update_bits(cs35l56_base->regmap, CS35L56_IRQ1_MASK_1,\n\t\t\t   CS35L56_AMP_SHORT_ERR_EINT1_MASK,\n\t\t\t   0);\n\tregmap_update_bits(cs35l56_base->regmap, CS35L56_IRQ1_MASK_8,\n\t\t\t   CS35L56_TEMP_ERR_EINT1_MASK,\n\t\t\t   0);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_hw_init, SND_SOC_CS35L56_SHARED);\n\nstatic const u32 cs35l56_bclk_valid_for_pll_freq_table[] = {\n\t[0x0C] = 128000,\n\t[0x0F] = 256000,\n\t[0x11] = 384000,\n\t[0x12] = 512000,\n\t[0x15] = 768000,\n\t[0x17] = 1024000,\n\t[0x1A] = 1500000,\n\t[0x1B] = 1536000,\n\t[0x1C] = 2000000,\n\t[0x1D] = 2048000,\n\t[0x1E] = 2400000,\n\t[0x20] = 3000000,\n\t[0x21] = 3072000,\n\t[0x23] = 4000000,\n\t[0x24] = 4096000,\n\t[0x25] = 4800000,\n\t[0x27] = 6000000,\n\t[0x28] = 6144000,\n\t[0x29] = 6250000,\n\t[0x2A] = 6400000,\n\t[0x2E] = 8000000,\n\t[0x2F] = 8192000,\n\t[0x30] = 9600000,\n\t[0x32] = 12000000,\n\t[0x33] = 12288000,\n\t[0x37] = 13500000,\n\t[0x38] = 19200000,\n\t[0x39] = 22579200,\n\t[0x3B] = 24576000,\n};\n\nint cs35l56_get_bclk_freq_id(unsigned int freq)\n{\n\tint i;\n\n\tif (freq == 0)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cs35l56_bclk_valid_for_pll_freq_table); ++i) {\n\t\tif (cs35l56_bclk_valid_for_pll_freq_table[i] == freq)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_get_bclk_freq_id, SND_SOC_CS35L56_SHARED);\n\nstatic const char * const cs35l56_supplies[ ] = {\n\t\"VDD_P\",\n\t\"VDD_IO\",\n\t\"VDD_A\",\n};\n\nvoid cs35l56_fill_supply_names(struct regulator_bulk_data *data)\n{\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs35l56_supplies) != CS35L56_NUM_BULK_SUPPLIES);\n\tfor (i = 0; i < ARRAY_SIZE(cs35l56_supplies); i++)\n\t\tdata[i].supply = cs35l56_supplies[i];\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_fill_supply_names, SND_SOC_CS35L56_SHARED);\n\nconst char * const cs35l56_tx_input_texts[] = {\n\t\"None\", \"ASP1RX1\", \"ASP1RX2\", \"VMON\", \"IMON\", \"ERRVOL\", \"CLASSH\",\n\t\"VDDBMON\", \"VBSTMON\", \"DSP1TX1\", \"DSP1TX2\", \"DSP1TX3\", \"DSP1TX4\",\n\t\"DSP1TX5\", \"DSP1TX6\", \"DSP1TX7\", \"DSP1TX8\", \"TEMPMON\",\n\t\"INTERPOLATOR\", \"SDW1RX1\", \"SDW1RX2\",\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_tx_input_texts, SND_SOC_CS35L56_SHARED);\n\nconst unsigned int cs35l56_tx_input_values[] = {\n\tCS35L56_INPUT_SRC_NONE,\n\tCS35L56_INPUT_SRC_ASP1RX1,\n\tCS35L56_INPUT_SRC_ASP1RX2,\n\tCS35L56_INPUT_SRC_VMON,\n\tCS35L56_INPUT_SRC_IMON,\n\tCS35L56_INPUT_SRC_ERR_VOL,\n\tCS35L56_INPUT_SRC_CLASSH,\n\tCS35L56_INPUT_SRC_VDDBMON,\n\tCS35L56_INPUT_SRC_VBSTMON,\n\tCS35L56_INPUT_SRC_DSP1TX1,\n\tCS35L56_INPUT_SRC_DSP1TX2,\n\tCS35L56_INPUT_SRC_DSP1TX3,\n\tCS35L56_INPUT_SRC_DSP1TX4,\n\tCS35L56_INPUT_SRC_DSP1TX5,\n\tCS35L56_INPUT_SRC_DSP1TX6,\n\tCS35L56_INPUT_SRC_DSP1TX7,\n\tCS35L56_INPUT_SRC_DSP1TX8,\n\tCS35L56_INPUT_SRC_TEMPMON,\n\tCS35L56_INPUT_SRC_INTERPOLATOR,\n\tCS35L56_INPUT_SRC_SWIRE_DP1_CHANNEL1,\n\tCS35L56_INPUT_SRC_SWIRE_DP1_CHANNEL2,\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_tx_input_values, SND_SOC_CS35L56_SHARED);\n\nstruct regmap_config cs35l56_regmap_i2c = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = CS35L56_DSP1_PMEM_5114,\n\t.reg_defaults = cs35l56_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l56_reg_defaults),\n\t.volatile_reg = cs35l56_volatile_reg,\n\t.readable_reg = cs35l56_readable_reg,\n\t.precious_reg = cs35l56_precious_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_regmap_i2c, SND_SOC_CS35L56_SHARED);\n\nstruct regmap_config cs35l56_regmap_spi = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.pad_bits = 16,\n\t.reg_stride = 4,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = CS35L56_DSP1_PMEM_5114,\n\t.reg_defaults = cs35l56_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l56_reg_defaults),\n\t.volatile_reg = cs35l56_volatile_reg,\n\t.readable_reg = cs35l56_readable_reg,\n\t.precious_reg = cs35l56_precious_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_regmap_spi, SND_SOC_CS35L56_SHARED);\n\nstruct regmap_config cs35l56_regmap_sdw = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n\t.max_register = CS35L56_DSP1_PMEM_5114,\n\t.reg_defaults = cs35l56_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l56_reg_defaults),\n\t.volatile_reg = cs35l56_volatile_reg,\n\t.readable_reg = cs35l56_readable_reg,\n\t.precious_reg = cs35l56_precious_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_regmap_sdw, SND_SOC_CS35L56_SHARED);\n\nMODULE_DESCRIPTION(\"ASoC CS35L56 Shared\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Simon Trimmer <simont@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}