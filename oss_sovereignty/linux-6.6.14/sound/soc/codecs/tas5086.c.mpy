{
  "module_name": "tas5086.c",
  "hash_id": "882865a2945fd629a399177ab929ba0340999d5d842ecb9e5c227117066082e2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas5086.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/tas5086.h>\n\n#define TAS5086_PCM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  |\t\t\\\n\t\t\t     SNDRV_PCM_FMTBIT_S20_3LE |\t\t\\\n\t\t\t     SNDRV_PCM_FMTBIT_S24_3LE)\n\n#define TAS5086_PCM_RATES   (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100  | \\\n\t\t\t     SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200  | \\\n\t\t\t     SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \\\n\t\t\t     SNDRV_PCM_RATE_192000)\n\n \n#define TAS5086_CLOCK_CONTROL\t\t0x00\t \n#define TAS5086_CLOCK_RATE(val)\t\t(val << 5)\n#define TAS5086_CLOCK_RATE_MASK\t\t(0x7 << 5)\n#define TAS5086_CLOCK_RATIO(val)\t(val << 2)\n#define TAS5086_CLOCK_RATIO_MASK\t(0x7 << 2)\n#define TAS5086_CLOCK_SCLK_RATIO_48\t(1 << 1)\n#define TAS5086_CLOCK_VALID\t\t(1 << 0)\n\n#define TAS5086_DEEMPH_MASK\t\t0x03\n#define TAS5086_SOFT_MUTE_ALL\t\t0x3f\n\n#define TAS5086_DEV_ID\t\t\t0x01\t \n#define TAS5086_ERROR_STATUS\t\t0x02\t \n#define TAS5086_SYS_CONTROL_1\t\t0x03\t \n#define TAS5086_SERIAL_DATA_IF\t\t0x04\t \n#define TAS5086_SYS_CONTROL_2\t\t0x05\t \n#define TAS5086_SOFT_MUTE\t\t0x06\t \n#define TAS5086_MASTER_VOL\t\t0x07\t \n#define TAS5086_CHANNEL_VOL(X)\t\t(0x08 + (X))\t \n#define TAS5086_VOLUME_CONTROL\t\t0x09\t \n#define TAS5086_MOD_LIMIT\t\t0x10\t \n#define TAS5086_PWM_START\t\t0x18\t \n#define TAS5086_SURROUND\t\t0x19\t \n#define TAS5086_SPLIT_CAP_CHARGE\t0x1a\t \n#define TAS5086_OSC_TRIM\t\t0x1b\t \n#define TAS5086_BKNDERR \t\t0x1c\n#define TAS5086_INPUT_MUX\t\t0x20\n#define TAS5086_PWM_OUTPUT_MUX\t\t0x25\n\n#define TAS5086_MAX_REGISTER\t\tTAS5086_PWM_OUTPUT_MUX\n\n#define TAS5086_PWM_START_MIDZ_FOR_START_1\t(1 << 7)\n#define TAS5086_PWM_START_MIDZ_FOR_START_2\t(1 << 6)\n#define TAS5086_PWM_START_CHANNEL_MASK\t\t(0x3f)\n\n \nstatic const struct reg_default tas5086_reg_defaults[] = {\n\t{ 0x00,\t0x6c },\n\t{ 0x01,\t0x03 },\n\t{ 0x02,\t0x00 },\n\t{ 0x03,\t0xa0 },\n\t{ 0x04,\t0x05 },\n\t{ 0x05,\t0x60 },\n\t{ 0x06,\t0x00 },\n\t{ 0x07,\t0xff },\n\t{ 0x08,\t0x30 },\n\t{ 0x09,\t0x30 },\n\t{ 0x0a,\t0x30 },\n\t{ 0x0b,\t0x30 },\n\t{ 0x0c,\t0x30 },\n\t{ 0x0d,\t0x30 },\n\t{ 0x0e,\t0xb1 },\n\t{ 0x0f,\t0x00 },\n\t{ 0x10,\t0x02 },\n\t{ 0x11,\t0x00 },\n\t{ 0x12,\t0x00 },\n\t{ 0x13,\t0x00 },\n\t{ 0x14,\t0x00 },\n\t{ 0x15,\t0x00 },\n\t{ 0x16,\t0x00 },\n\t{ 0x17,\t0x00 },\n\t{ 0x18,\t0x3f },\n\t{ 0x19,\t0x00 },\n\t{ 0x1a,\t0x18 },\n\t{ 0x1b,\t0x82 },\n\t{ 0x1c,\t0x05 },\n};\n\nstatic int tas5086_register_size(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS5086_CLOCK_CONTROL ... TAS5086_BKNDERR:\n\t\treturn 1;\n\tcase TAS5086_INPUT_MUX:\n\tcase TAS5086_PWM_OUTPUT_MUX:\n\t\treturn 4;\n\t}\n\n\tdev_err(dev, \"Unsupported register address: %d\\n\", reg);\n\treturn 0;\n}\n\nstatic bool tas5086_accessible_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x0f:\n\tcase 0x11 ... 0x17:\n\tcase 0x1d ... 0x1f:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool tas5086_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS5086_DEV_ID:\n\tcase TAS5086_ERROR_STATUS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool tas5086_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn tas5086_accessible_reg(dev, reg) && (reg != TAS5086_DEV_ID);\n}\n\nstatic int tas5086_reg_write(void *context, unsigned int reg,\n\t\t\t      unsigned int value)\n{\n\tstruct i2c_client *client = context;\n\tunsigned int i, size;\n\tuint8_t buf[5];\n\tint ret;\n\n\tsize = tas5086_register_size(&client->dev, reg);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tbuf[0] = reg;\n\n\tfor (i = size; i >= 1; --i) {\n\t\tbuf[i] = value;\n\t\tvalue >>= 8;\n\t}\n\n\tret = i2c_master_send(client, buf, size + 1);\n\tif (ret == size + 1)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn -EIO;\n}\n\nstatic int tas5086_reg_read(void *context, unsigned int reg,\n\t\t\t     unsigned int *value)\n{\n\tstruct i2c_client *client = context;\n\tuint8_t send_buf, recv_buf[4];\n\tstruct i2c_msg msgs[2];\n\tunsigned int size;\n\tunsigned int i;\n\tint ret;\n\n\tsize = tas5086_register_size(&client->dev, reg);\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tsend_buf = reg;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].len = sizeof(send_buf);\n\tmsgs[0].buf = &send_buf;\n\tmsgs[0].flags = 0;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].len = size;\n\tmsgs[1].buf = recv_buf;\n\tmsgs[1].flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (ret != ARRAY_SIZE(msgs))\n\t\treturn -EIO;\n\n\t*value = 0;\n\n\tfor (i = 0; i < size; i++) {\n\t\t*value <<= 8;\n\t\t*value |= recv_buf[i];\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const supply_names[] = {\n\t\"dvdd\", \"avdd\"\n};\n\nstruct tas5086_private {\n\tstruct regmap\t*regmap;\n\tunsigned int\tmclk, sclk;\n\tunsigned int\tformat;\n\tbool\t\tdeemph;\n\tunsigned int\tcharge_period;\n\tunsigned int\tpwm_start_mid_z;\n\t \n\tint\t\trate;\n\t \n\tint\t\tgpio_nreset;\n\tstruct\t\tregulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n};\n\nstatic int tas5086_deemph[] = { 0, 32000, 44100, 48000 };\n\nstatic int tas5086_set_deemph(struct snd_soc_component *component)\n{\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tint i, val = 0;\n\n\tif (priv->deemph) {\n\t\tfor (i = 0; i < ARRAY_SIZE(tas5086_deemph); i++) {\n\t\t\tif (tas5086_deemph[i] == priv->rate) {\n\t\t\t\tval = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn regmap_update_bits(priv->regmap, TAS5086_SYS_CONTROL_1,\n\t\t\t\t  TAS5086_DEEMPH_MASK, val);\n}\n\nstatic int tas5086_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = priv->deemph;\n\n\treturn 0;\n}\n\nstatic int tas5086_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\n\tpriv->deemph = ucontrol->value.integer.value[0];\n\n\treturn tas5086_set_deemph(component);\n}\n\n\nstatic int tas5086_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase TAS5086_CLK_IDX_MCLK:\n\t\tpriv->mclk = freq;\n\t\tbreak;\n\tcase TAS5086_CLK_IDX_SCLK:\n\t\tpriv->sclk = freq;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tas5086_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t       unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\n\t \n\tif ((format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC) {\n\t\tdev_err(component->dev, \"Invalid clocking mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->format = format;\n\n\treturn 0;\n}\n\nstatic const int tas5086_sample_rates[] = {\n\t32000, 38000, 44100, 48000, 88200, 96000, 176400, 192000\n};\n\nstatic const int tas5086_ratios[] = {\n\t64, 128, 192, 256, 384, 512\n};\n\nstatic int index_in_array(const int *array, int len, int needle)\n{\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (array[i] == needle)\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic int tas5086_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tint val;\n\tint ret;\n\n\tpriv->rate = params_rate(params);\n\n\t \n\tval = index_in_array(tas5086_sample_rates,\n\t\t\t     ARRAY_SIZE(tas5086_sample_rates), priv->rate);\n\n\tif (val < 0) {\n\t\tdev_err(component->dev, \"Invalid sample rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\n\t\t\t\t TAS5086_CLOCK_RATE_MASK,\n\t\t\t\t TAS5086_CLOCK_RATE(val));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tval = index_in_array(tas5086_ratios, ARRAY_SIZE(tas5086_ratios),\n\t\t\t     priv->mclk / priv->rate);\n\tif (val < 0) {\n\t\tdev_err(component->dev, \"Invalid MCLK / Fs ratio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\n\t\t\t\t TAS5086_CLOCK_RATIO_MASK,\n\t\t\t\t TAS5086_CLOCK_RATIO(val));\n\tif (ret < 0)\n\t\treturn ret;\n\n\n\tret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\n\t\t\t\t TAS5086_CLOCK_SCLK_RATIO_48,\n\t\t\t\t (priv->sclk == 48 * priv->rate) ? \n\t\t\t\t\tTAS5086_CLOCK_SCLK_RATIO_48 : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = 0x00;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = 0x03;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = 0x06;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n        case 16:\n\t\tval += 0;\n                break;\n\tcase 20:\n\t\tval += 1;\n\t\tbreak;\n\tcase 24:\n\t\tval += 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid bit width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(priv->regmap, TAS5086_SERIAL_DATA_IF, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->regmap, TAS5086_CLOCK_CONTROL,\n\t\t\t\t TAS5086_CLOCK_VALID, TAS5086_CLOCK_VALID);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tas5086_set_deemph(component);\n}\n\nstatic int tas5086_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\n\tif (mute)\n\t\tval = TAS5086_SOFT_MUTE_ALL;\n\n\treturn regmap_write(priv->regmap, TAS5086_SOFT_MUTE, val);\n}\n\nstatic void tas5086_reset(struct tas5086_private *priv)\n{\n\tif (gpio_is_valid(priv->gpio_nreset)) {\n\t\t \n\t\tgpio_direction_output(priv->gpio_nreset, 0);\n\t\tudelay(1);\n\t\tgpio_set_value(priv->gpio_nreset, 1);\n\n\t\t \n\t\tmsleep(15);\n\t}\n}\n\n \nstatic const int tas5086_charge_period[] = {\n\t  13000,  16900,   23400,   31200,   41600,   54600,   72800,   96200,\n\t 130000, 156000,  234000,  312000,  416000,  546000,  728000,  962000,\n\t1300000, 169000, 2340000, 3120000, 4160000, 5460000, 7280000, 9620000,\n};\n\nstatic int tas5086_init(struct device *dev, struct tas5086_private *priv)\n{\n\tint ret, i;\n\n\t \n\tif (priv->pwm_start_mid_z)\n\t\tregmap_write(priv->regmap, TAS5086_PWM_START,\n\t\t\t     TAS5086_PWM_START_MIDZ_FOR_START_1 |\n\t\t\t\tpriv->pwm_start_mid_z);\n\n\t \n\tif (priv->charge_period == 0) {\n\t\tregmap_write(priv->regmap, TAS5086_SPLIT_CAP_CHARGE, 0);\n\t} else {\n\t\ti = index_in_array(tas5086_charge_period,\n\t\t\t\t   ARRAY_SIZE(tas5086_charge_period),\n\t\t\t\t   priv->charge_period);\n\t\tif (i >= 0)\n\t\t\tregmap_write(priv->regmap, TAS5086_SPLIT_CAP_CHARGE,\n\t\t\t\t     i + 0x08);\n\t\telse\n\t\t\tdev_warn(dev,\n\t\t\t\t \"Invalid split-cap charge period of %d ns.\\n\",\n\t\t\t\t priv->charge_period);\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, TAS5086_OSC_TRIM, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->regmap, TAS5086_SYS_CONTROL_2, 0x20);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->regmap, TAS5086_SOFT_MUTE,\n\t\t\t   TAS5086_SOFT_MUTE_ALL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(tas5086_dac_tlv, -10350, 50, 1);\n\nstatic const struct snd_kcontrol_new tas5086_controls[] = {\n\tSOC_SINGLE_TLV(\"Master Playback Volume\", TAS5086_MASTER_VOL,\n\t\t       0, 0xff, 1, tas5086_dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"Channel 1/2 Playback Volume\",\n\t\t\t TAS5086_CHANNEL_VOL(0), TAS5086_CHANNEL_VOL(1),\n\t\t\t 0, 0xff, 1, tas5086_dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"Channel 3/4 Playback Volume\",\n\t\t\t TAS5086_CHANNEL_VOL(2), TAS5086_CHANNEL_VOL(3),\n\t\t\t 0, 0xff, 1, tas5086_dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"Channel 5/6 Playback Volume\",\n\t\t\t TAS5086_CHANNEL_VOL(4), TAS5086_CHANNEL_VOL(5),\n\t\t\t 0, 0xff, 1, tas5086_dac_tlv),\n\tSOC_SINGLE_BOOL_EXT(\"De-emphasis Switch\", 0,\n\t\t\t    tas5086_get_deemph, tas5086_put_deemph),\n};\n\n \nstatic const char *tas5086_dapm_sdin_texts[] =\n{\n\t\"SDIN1-L\", \"SDIN1-R\", \"SDIN2-L\", \"SDIN2-R\",\n\t\"SDIN3-L\", \"SDIN3-R\", \"Ground (0)\", \"nc\"\n};\n\nstatic const struct soc_enum tas5086_dapm_input_mux_enum[] = {\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 20, 8, tas5086_dapm_sdin_texts),\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 16, 8, tas5086_dapm_sdin_texts),\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 12, 8, tas5086_dapm_sdin_texts),\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 8,  8, tas5086_dapm_sdin_texts),\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 4,  8, tas5086_dapm_sdin_texts),\n\tSOC_ENUM_SINGLE(TAS5086_INPUT_MUX, 0,  8, tas5086_dapm_sdin_texts),\n};\n\nstatic const struct snd_kcontrol_new tas5086_dapm_input_mux_controls[] = {\n\tSOC_DAPM_ENUM(\"Channel 1 input\", tas5086_dapm_input_mux_enum[0]),\n\tSOC_DAPM_ENUM(\"Channel 2 input\", tas5086_dapm_input_mux_enum[1]),\n\tSOC_DAPM_ENUM(\"Channel 3 input\", tas5086_dapm_input_mux_enum[2]),\n\tSOC_DAPM_ENUM(\"Channel 4 input\", tas5086_dapm_input_mux_enum[3]),\n\tSOC_DAPM_ENUM(\"Channel 5 input\", tas5086_dapm_input_mux_enum[4]),\n\tSOC_DAPM_ENUM(\"Channel 6 input\", tas5086_dapm_input_mux_enum[5]),\n};\n\n \nstatic const char *tas5086_dapm_channel_texts[] =\n\t{ \"Channel 1 Mux\", \"Channel 2 Mux\", \"Channel 3 Mux\",\n\t  \"Channel 4 Mux\", \"Channel 5 Mux\", \"Channel 6 Mux\" };\n\nstatic const struct soc_enum tas5086_dapm_output_mux_enum[] = {\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 20, 6, tas5086_dapm_channel_texts),\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 16, 6, tas5086_dapm_channel_texts),\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 12, 6, tas5086_dapm_channel_texts),\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 8,  6, tas5086_dapm_channel_texts),\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 4,  6, tas5086_dapm_channel_texts),\n\tSOC_ENUM_SINGLE(TAS5086_PWM_OUTPUT_MUX, 0,  6, tas5086_dapm_channel_texts),\n};\n\nstatic const struct snd_kcontrol_new tas5086_dapm_output_mux_controls[] = {\n\tSOC_DAPM_ENUM(\"PWM1 Output\", tas5086_dapm_output_mux_enum[0]),\n\tSOC_DAPM_ENUM(\"PWM2 Output\", tas5086_dapm_output_mux_enum[1]),\n\tSOC_DAPM_ENUM(\"PWM3 Output\", tas5086_dapm_output_mux_enum[2]),\n\tSOC_DAPM_ENUM(\"PWM4 Output\", tas5086_dapm_output_mux_enum[3]),\n\tSOC_DAPM_ENUM(\"PWM5 Output\", tas5086_dapm_output_mux_enum[4]),\n\tSOC_DAPM_ENUM(\"PWM6 Output\", tas5086_dapm_output_mux_enum[5]),\n};\n\nstatic const struct snd_soc_dapm_widget tas5086_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"SDIN1-L\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN1-R\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN2-L\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN2-R\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN3-L\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN3-R\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN4-L\"),\n\tSND_SOC_DAPM_INPUT(\"SDIN4-R\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"PWM1\"),\n\tSND_SOC_DAPM_OUTPUT(\"PWM2\"),\n\tSND_SOC_DAPM_OUTPUT(\"PWM3\"),\n\tSND_SOC_DAPM_OUTPUT(\"PWM4\"),\n\tSND_SOC_DAPM_OUTPUT(\"PWM5\"),\n\tSND_SOC_DAPM_OUTPUT(\"PWM6\"),\n\n\tSND_SOC_DAPM_MUX(\"Channel 1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[0]),\n\tSND_SOC_DAPM_MUX(\"Channel 2 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[1]),\n\tSND_SOC_DAPM_MUX(\"Channel 3 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[2]),\n\tSND_SOC_DAPM_MUX(\"Channel 4 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[3]),\n\tSND_SOC_DAPM_MUX(\"Channel 5 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[4]),\n\tSND_SOC_DAPM_MUX(\"Channel 6 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_input_mux_controls[5]),\n\n\tSND_SOC_DAPM_MUX(\"PWM1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[0]),\n\tSND_SOC_DAPM_MUX(\"PWM2 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[1]),\n\tSND_SOC_DAPM_MUX(\"PWM3 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[2]),\n\tSND_SOC_DAPM_MUX(\"PWM4 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[3]),\n\tSND_SOC_DAPM_MUX(\"PWM5 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[4]),\n\tSND_SOC_DAPM_MUX(\"PWM6 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &tas5086_dapm_output_mux_controls[5]),\n};\n\nstatic const struct snd_soc_dapm_route tas5086_dapm_routes[] = {\n\t \n\t{ \"Channel 1 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 1 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 1 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 1 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 1 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 1 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 2 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 2 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 2 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 2 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 2 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 2 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 2 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 3 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 3 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 3 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 3 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 3 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 3 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 4 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 4 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 4 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 4 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 4 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 4 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 5 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 5 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 5 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 5 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 5 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 5 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t{ \"Channel 6 Mux\", \"SDIN1-L\", \"SDIN1-L\" },\n\t{ \"Channel 6 Mux\", \"SDIN1-R\", \"SDIN1-R\" },\n\t{ \"Channel 6 Mux\", \"SDIN2-L\", \"SDIN2-L\" },\n\t{ \"Channel 6 Mux\", \"SDIN2-R\", \"SDIN2-R\" },\n\t{ \"Channel 6 Mux\", \"SDIN3-L\", \"SDIN3-L\" },\n\t{ \"Channel 6 Mux\", \"SDIN3-R\", \"SDIN3-R\" },\n\n\t \n\t{ \"PWM1 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 1 Mux\", \"Channel 1 Mux\" },\n\n\t{ \"PWM1 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 2 Mux\", \"Channel 2 Mux\" },\n\n\t{ \"PWM1 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 3 Mux\", \"Channel 3 Mux\" },\n\n\t{ \"PWM1 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 4 Mux\", \"Channel 4 Mux\" },\n\n\t{ \"PWM1 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 5 Mux\", \"Channel 5 Mux\" },\n\n\t{ \"PWM1 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\t{ \"PWM2 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\t{ \"PWM3 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\t{ \"PWM4 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\t{ \"PWM5 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\t{ \"PWM6 Mux\", \"Channel 6 Mux\", \"Channel 6 Mux\" },\n\n\t \n\t{ \"PWM1\", NULL, \"PWM1 Mux\" },\n\t{ \"PWM2\", NULL, \"PWM2 Mux\" },\n\t{ \"PWM3\", NULL, \"PWM3 Mux\" },\n\t{ \"PWM4\", NULL, \"PWM4 Mux\" },\n\t{ \"PWM5\", NULL, \"PWM5 Mux\" },\n\t{ \"PWM6\", NULL, \"PWM6 Mux\" },\n\n};\n\nstatic const struct snd_soc_dai_ops tas5086_dai_ops = {\n\t.hw_params\t= tas5086_hw_params,\n\t.set_sysclk\t= tas5086_set_dai_sysclk,\n\t.set_fmt\t= tas5086_set_dai_fmt,\n\t.mute_stream\t= tas5086_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver tas5086_dai = {\n\t.name = \"tas5086-hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 6,\n\t\t.rates\t\t= TAS5086_PCM_RATES,\n\t\t.formats\t= TAS5086_PCM_FORMATS,\n\t},\n\t.ops = &tas5086_dai_ops,\n};\n\n#ifdef CONFIG_PM\nstatic int tas5086_soc_suspend(struct snd_soc_component *component)\n{\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\t \n\tret = regmap_write(priv->regmap, TAS5086_SYS_CONTROL_2, 0x60);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\n\treturn 0;\n}\n\nstatic int tas5086_soc_resume(struct snd_soc_component *component)\n{\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttas5086_reset(priv);\n\tregcache_mark_dirty(priv->regmap);\n\n\tret = tas5086_init(component->dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regcache_sync(priv->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\n#define tas5086_soc_suspend\tNULL\n#define tas5086_soc_resume\tNULL\n#endif  \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tas5086_dt_ids[] = {\n\t{ .compatible = \"ti,tas5086\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tas5086_dt_ids);\n#endif\n\nstatic int tas5086_probe(struct snd_soc_component *component)\n{\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\tint i, ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->pwm_start_mid_z = 0;\n\tpriv->charge_period = 1300000;  \n\n\tif (of_match_device(of_match_ptr(tas5086_dt_ids), component->dev)) {\n\t\tstruct device_node *of_node = component->dev->of_node;\n\n\t\tof_property_read_u32(of_node, \"ti,charge-period\",\n\t\t\t\t     &priv->charge_period);\n\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tchar name[25];\n\n\t\t\tsnprintf(name, sizeof(name),\n\t\t\t\t \"ti,mid-z-channel-%d\", i + 1);\n\n\t\t\tif (of_property_read_bool(of_node, name))\n\t\t\t\tpriv->pwm_start_mid_z |= 1 << i;\n\t\t}\n\t}\n\n\ttas5086_reset(priv);\n\tret = tas5086_init(component->dev, priv);\n\tif (ret < 0)\n\t\tgoto exit_disable_regulators;\n\n\t \n\tret = regmap_write(priv->regmap, TAS5086_MASTER_VOL, 0x30);\n\tif (ret < 0)\n\t\tgoto exit_disable_regulators;\n\n\treturn 0;\n\nexit_disable_regulators:\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\n\treturn ret;\n}\n\nstatic void tas5086_remove(struct snd_soc_component *component)\n{\n\tstruct tas5086_private *priv = snd_soc_component_get_drvdata(component);\n\n\tif (gpio_is_valid(priv->gpio_nreset))\n\t\t \n\t\tgpio_set_value(priv->gpio_nreset, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas5086 = {\n\t.probe\t\t\t= tas5086_probe,\n\t.remove\t\t\t= tas5086_remove,\n\t.suspend\t\t= tas5086_soc_suspend,\n\t.resume\t\t\t= tas5086_soc_resume,\n\t.controls\t\t= tas5086_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas5086_controls),\n\t.dapm_widgets\t\t= tas5086_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas5086_dapm_widgets),\n\t.dapm_routes\t\t= tas5086_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas5086_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct i2c_device_id tas5086_i2c_id[] = {\n\t{ \"tas5086\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas5086_i2c_id);\n\nstatic const struct regmap_config tas5086_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 32,\n\t.max_register\t\t= TAS5086_MAX_REGISTER,\n\t.reg_defaults\t\t= tas5086_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(tas5086_reg_defaults),\n\t.cache_type\t\t= REGCACHE_RBTREE,\n\t.volatile_reg\t\t= tas5086_volatile_reg,\n\t.writeable_reg\t\t= tas5086_writeable_reg,\n\t.readable_reg\t\t= tas5086_accessible_reg,\n\t.reg_read\t\t= tas5086_reg_read,\n\t.reg_write\t\t= tas5086_reg_write,\n};\n\nstatic int tas5086_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct tas5086_private *priv;\n\tstruct device *dev = &i2c->dev;\n\tint gpio_nreset = -EINVAL;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->regmap = devm_regmap_init(dev, NULL, i2c, &tas5086_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to create regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tif (of_match_device(of_match_ptr(tas5086_dt_ids), dev)) {\n\t\tstruct device_node *of_node = dev->of_node;\n\t\tgpio_nreset = of_get_named_gpio(of_node, \"reset-gpio\", 0);\n\t}\n\n\tif (gpio_is_valid(gpio_nreset))\n\t\tif (devm_gpio_request(dev, gpio_nreset, \"TAS5086 Reset\"))\n\t\t\tgpio_nreset = -EINVAL;\n\n\tpriv->gpio_nreset = gpio_nreset;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttas5086_reset(priv);\n\n\t \n\tret = regmap_read(priv->regmap, TAS5086_DEV_ID, &i);\n\tif (ret == 0 && i != 0x3) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to identify TAS5086 codec (got %02x)\\n\", i);\n\t\tret = -ENODEV;\n\t}\n\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\n\tif (ret == 0)\n\t\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t     &soc_component_dev_tas5086,\n\t\t\t\t\t     &tas5086_dai, 1);\n\n\treturn ret;\n}\n\nstatic void tas5086_i2c_remove(struct i2c_client *i2c)\n{}\n\nstatic struct i2c_driver tas5086_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"tas5086\",\n\t\t.of_match_table = of_match_ptr(tas5086_dt_ids),\n\t},\n\t.id_table\t= tas5086_i2c_id,\n\t.probe\t\t= tas5086_i2c_probe,\n\t.remove\t\t= tas5086_i2c_remove,\n};\n\nmodule_i2c_driver(tas5086_i2c_driver);\n\nMODULE_AUTHOR(\"Daniel Mack <zonque@gmail.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TAS5086 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}