{
  "module_name": "wcd-mbhc-v2.c",
  "hash_id": "6c412095b0169033f1ff38e9c25923d5b152477254c2539a3a9b03c17f00f4d4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wcd-mbhc-v2.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/printk.h>\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include \"wcd-mbhc-v2.h\"\n\n#define HS_DETECT_PLUG_TIME_MS\t\t(3 * 1000)\n#define MBHC_BUTTON_PRESS_THRESHOLD_MIN\t250\n#define GND_MIC_SWAP_THRESHOLD\t\t4\n#define WCD_FAKE_REMOVAL_MIN_PERIOD_MS\t100\n#define HPHL_CROSS_CONN_THRESHOLD\t100\n#define HS_VREF_MIN_VAL\t\t\t1400\n#define FAKE_REM_RETRY_ATTEMPTS\t\t3\n#define WCD_MBHC_ADC_HS_THRESHOLD_MV\t1700\n#define WCD_MBHC_ADC_HPH_THRESHOLD_MV\t75\n#define WCD_MBHC_ADC_MICBIAS_MV\t\t1800\n#define WCD_MBHC_FAKE_INS_RETRY\t\t4\n\n#define WCD_MBHC_JACK_MASK (SND_JACK_HEADSET | SND_JACK_LINEOUT | \\\n\t\t\t   SND_JACK_MECHANICAL)\n\n#define WCD_MBHC_JACK_BUTTON_MASK (SND_JACK_BTN_0 | SND_JACK_BTN_1 | \\\n\t\t\t\t  SND_JACK_BTN_2 | SND_JACK_BTN_3 | \\\n\t\t\t\t  SND_JACK_BTN_4 | SND_JACK_BTN_5)\n\nenum wcd_mbhc_adc_mux_ctl {\n\tMUX_CTL_AUTO = 0,\n\tMUX_CTL_IN2P,\n\tMUX_CTL_IN3P,\n\tMUX_CTL_IN4P,\n\tMUX_CTL_HPH_L,\n\tMUX_CTL_HPH_R,\n\tMUX_CTL_NONE,\n};\n\nstruct wcd_mbhc {\n\tstruct device *dev;\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_jack *jack;\n\tstruct wcd_mbhc_config *cfg;\n\tconst struct wcd_mbhc_cb *mbhc_cb;\n\tconst struct wcd_mbhc_intr *intr_ids;\n\tstruct wcd_mbhc_field *fields;\n\t \n\tstruct delayed_work mbhc_btn_dwork;\n\t \n\tstruct work_struct correct_plug_swch;\n\tstruct mutex lock;\n\tint buttons_pressed;\n\tu32 hph_status;  \n\tu8 current_plug;\n\tbool is_btn_press;\n\tbool in_swch_irq_handler;\n\tbool hs_detect_work_stop;\n\tbool is_hs_recording;\n\tbool extn_cable_hph_rem;\n\tbool force_linein;\n\tbool impedance_detect;\n\tunsigned long event_state;\n\tunsigned long jiffies_atreport;\n\t \n\tuint32_t zl, zr;\n\t \n\tenum wcd_mbhc_hph_type hph_type;\n\t \n\tint mbhc_detection_logic;\n};\n\nstatic inline int wcd_mbhc_write_field(const struct wcd_mbhc *mbhc,\n\t\t\t\t       int field, int val)\n{\n\tif (!mbhc->fields[field].reg)\n\t\treturn 0;\n\n\treturn snd_soc_component_write_field(mbhc->component,\n\t\t\t\t\t     mbhc->fields[field].reg,\n\t\t\t\t\t     mbhc->fields[field].mask, val);\n}\n\nstatic inline int wcd_mbhc_read_field(const struct wcd_mbhc *mbhc, int field)\n{\n\tif (!mbhc->fields[field].reg)\n\t\treturn 0;\n\n\treturn snd_soc_component_read_field(mbhc->component,\n\t\t\t\t\t    mbhc->fields[field].reg,\n\t\t\t\t\t    mbhc->fields[field].mask);\n}\n\nstatic void wcd_program_hs_vref(struct wcd_mbhc *mbhc)\n{\n\tu32 reg_val = ((mbhc->cfg->v_hs_max - HS_VREF_MIN_VAL) / 100);\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_HS_VREF, reg_val);\n}\n\nstatic void wcd_program_btn_threshold(const struct wcd_mbhc *mbhc, bool micbias)\n{\n\tstruct snd_soc_component *component = mbhc->component;\n\n\tmbhc->mbhc_cb->set_btn_thr(component, mbhc->cfg->btn_low,\n\t\t\t\t   mbhc->cfg->btn_high,\n\t\t\t\t   mbhc->cfg->num_btn, micbias);\n}\n\nstatic void wcd_mbhc_curr_micbias_control(const struct wcd_mbhc *mbhc,\n\t\t\t\t\t  const enum wcd_mbhc_cs_mb_en_flag cs_mb_en)\n{\n\n\t \n\tif (mbhc->mbhc_cb->mbhc_micbias_control)\n\t\treturn;\n\n\tswitch (cs_mb_en) {\n\tcase WCD_MBHC_EN_CS:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MICB_CTRL, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 3);\n\t\t \n\t\twcd_program_btn_threshold(mbhc, false);\n\t\tbreak;\n\tcase WCD_MBHC_EN_MB:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t\t \n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MICB_CTRL, 2);\n\t\t \n\t\twcd_program_btn_threshold(mbhc, true);\n\t\tbreak;\n\tcase WCD_MBHC_EN_PULLUP:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 3);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MICB_CTRL, 1);\n\t\t \n\t\twcd_program_btn_threshold(mbhc, true);\n\t\tbreak;\n\tcase WCD_MBHC_EN_NONE:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MICB_CTRL, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mbhc->dev, \"%s: Invalid parameter\", __func__);\n\t\tbreak;\n\t}\n}\n\nint wcd_mbhc_event_notify(struct wcd_mbhc *mbhc, unsigned long event)\n{\n\n\tstruct snd_soc_component *component;\n\tbool micbias2 = false;\n\n\tif (!mbhc)\n\t\treturn 0;\n\n\tcomponent = mbhc->component;\n\n\tif (mbhc->mbhc_cb->micbias_enable_status)\n\t\tmicbias2 = mbhc->mbhc_cb->micbias_enable_status(component, MIC_BIAS_2);\n\n\tswitch (event) {\n\t \n\tcase WCD_EVENT_POST_DAPM_MICBIAS_2_ON:\n\t\tmbhc->is_hs_recording = true;\n\t\tbreak;\n\tcase WCD_EVENT_POST_MICBIAS_2_ON:\n\t\t \n\t\tif (mbhc->mbhc_cb->mbhc_micbias_control) {\n\t\t\tif (wcd_mbhc_read_field(mbhc, WCD_MBHC_FSM_EN))\n\t\t\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\t\t} else {\n\t\t\tmbhc->is_hs_recording = true;\n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_MB);\n\t\t}\n\t\tbreak;\n\tcase WCD_EVENT_PRE_MICBIAS_2_OFF:\n\t\t \n\t\tif (mbhc->mbhc_cb->mbhc_micbias_control ) {\n\t\t\tif (wcd_mbhc_read_field(mbhc, WCD_MBHC_FSM_EN))\n\t\t\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 3);\n\t\t}\n\t\tbreak;\n\t \n\tcase WCD_EVENT_POST_DAPM_MICBIAS_2_OFF:\n\t\tmbhc->is_hs_recording = false;\n\t\tbreak;\n\tcase WCD_EVENT_POST_MICBIAS_2_OFF:\n\t\tif (!mbhc->mbhc_cb->mbhc_micbias_control)\n\t\t\tmbhc->is_hs_recording = false;\n\n\t\t \n\t\tif ((test_bit(WCD_MBHC_EVENT_PA_HPHL, &mbhc->event_state)) ||\n\t\t    (test_bit(WCD_MBHC_EVENT_PA_HPHR, &mbhc->event_state)))\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_PULLUP);\n\t\telse\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_CS);\n\n\t\tbreak;\n\tcase WCD_EVENT_POST_HPHL_PA_OFF:\n\t\tclear_bit(WCD_MBHC_EVENT_PA_HPHL, &mbhc->event_state);\n\n\t\t \n\t\tif (micbias2)\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_MB);\n\t\telse\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_CS);\n\t\tbreak;\n\tcase WCD_EVENT_POST_HPHR_PA_OFF:\n\t\tclear_bit(WCD_MBHC_EVENT_PA_HPHR, &mbhc->event_state);\n\t\t \n\t\tif (micbias2)\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_MB);\n\t\telse\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_CS);\n\t\tbreak;\n\tcase WCD_EVENT_PRE_HPHL_PA_ON:\n\t\tset_bit(WCD_MBHC_EVENT_PA_HPHL, &mbhc->event_state);\n\t\t \n\t\tif (micbias2)\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_MB);\n\t\telse\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_PULLUP);\n\t\tbreak;\n\tcase WCD_EVENT_PRE_HPHR_PA_ON:\n\t\tset_bit(WCD_MBHC_EVENT_PA_HPHR, &mbhc->event_state);\n\t\t \n\t\tif (micbias2)\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_MB);\n\t\telse\n\t\t\t \n\t\t\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_PULLUP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wcd_mbhc_event_notify);\n\nstatic int wcd_cancel_btn_work(struct wcd_mbhc *mbhc)\n{\n\treturn cancel_delayed_work_sync(&mbhc->mbhc_btn_dwork);\n}\n\nstatic void wcd_micbias_disable(struct wcd_mbhc *mbhc)\n{\n\tstruct snd_soc_component *component = mbhc->component;\n\n\tif (mbhc->mbhc_cb->mbhc_micbias_control)\n\t\tmbhc->mbhc_cb->mbhc_micbias_control(component, MIC_BIAS_2, MICB_DISABLE);\n\n\tif (mbhc->mbhc_cb->mbhc_micb_ctrl_thr_mic)\n\t\tmbhc->mbhc_cb->mbhc_micb_ctrl_thr_mic(component, MIC_BIAS_2, false);\n\n\tif (mbhc->mbhc_cb->set_micbias_value) {\n\t\tmbhc->mbhc_cb->set_micbias_value(component);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MICB_CTRL, 0);\n\t}\n}\n\nstatic void wcd_mbhc_report_plug_removal(struct wcd_mbhc *mbhc,\n\t\t\t\t\t enum snd_jack_types jack_type)\n{\n\tmbhc->hph_status &= ~jack_type;\n\t \n\tif (!wcd_cancel_btn_work(mbhc) && mbhc->buttons_pressed) {\n\t\tsnd_soc_jack_report(mbhc->jack, 0, mbhc->buttons_pressed);\n\t\tmbhc->buttons_pressed &= ~WCD_MBHC_JACK_BUTTON_MASK;\n\t}\n\n\twcd_micbias_disable(mbhc);\n\tmbhc->hph_type = WCD_MBHC_HPH_NONE;\n\tmbhc->zl = mbhc->zr = 0;\n\tsnd_soc_jack_report(mbhc->jack, mbhc->hph_status, WCD_MBHC_JACK_MASK);\n\tmbhc->current_plug = MBHC_PLUG_TYPE_NONE;\n\tmbhc->force_linein = false;\n}\n\nstatic void wcd_mbhc_compute_impedance(struct wcd_mbhc *mbhc)\n{\n\n\tif (!mbhc->impedance_detect)\n\t\treturn;\n\n\tif (mbhc->cfg->linein_th != 0) {\n\t\tu8 fsm_en = wcd_mbhc_read_field(mbhc, WCD_MBHC_FSM_EN);\n\t\t \n\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_MUX_CTL, MUX_CTL_AUTO);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t\tmbhc->mbhc_cb->compute_impedance(mbhc->component, &mbhc->zl, &mbhc->zr);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, fsm_en);\n\t}\n}\n\nstatic void wcd_mbhc_report_plug_insertion(struct wcd_mbhc *mbhc,\n\t\t\t\t\t   enum snd_jack_types jack_type)\n{\n\tbool is_pa_on;\n\t \n\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADSET &&\n\t    jack_type == SND_JACK_HEADPHONE)\n\t\tmbhc->hph_status &= ~SND_JACK_HEADSET;\n\n\t \n\tswitch (jack_type) {\n\tcase SND_JACK_HEADPHONE:\n\t\tmbhc->current_plug = MBHC_PLUG_TYPE_HEADPHONE;\n\t\tbreak;\n\tcase SND_JACK_HEADSET:\n\t\tmbhc->current_plug = MBHC_PLUG_TYPE_HEADSET;\n\t\tmbhc->jiffies_atreport = jiffies;\n\t\tbreak;\n\tcase SND_JACK_LINEOUT:\n\t\tmbhc->current_plug = MBHC_PLUG_TYPE_HIGH_HPH;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\tis_pa_on = wcd_mbhc_read_field(mbhc, WCD_MBHC_HPH_PA_EN);\n\n\tif (!is_pa_on) {\n\t\twcd_mbhc_compute_impedance(mbhc);\n\t\tif ((mbhc->zl > mbhc->cfg->linein_th) &&\n\t\t    (mbhc->zr > mbhc->cfg->linein_th) &&\n\t\t    (jack_type == SND_JACK_HEADPHONE)) {\n\t\t\tjack_type = SND_JACK_LINEOUT;\n\t\t\tmbhc->force_linein = true;\n\t\t\tmbhc->current_plug = MBHC_PLUG_TYPE_HIGH_HPH;\n\t\t\tif (mbhc->hph_status) {\n\t\t\t\tmbhc->hph_status &= ~(SND_JACK_HEADSET |\n\t\t\t\t\t\t      SND_JACK_LINEOUT);\n\t\t\t\tsnd_soc_jack_report(mbhc->jack,\tmbhc->hph_status,\n\t\t\t\t\t\t    WCD_MBHC_JACK_MASK);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (is_pa_on && mbhc->force_linein) {\n\t\tjack_type = SND_JACK_LINEOUT;\n\t\tmbhc->current_plug = MBHC_PLUG_TYPE_HIGH_HPH;\n\t\tif (mbhc->hph_status) {\n\t\t\tmbhc->hph_status &= ~(SND_JACK_HEADSET |\n\t\t\t\t\t      SND_JACK_LINEOUT);\n\t\t\tsnd_soc_jack_report(mbhc->jack,\tmbhc->hph_status,\n\t\t\t\t\t    WCD_MBHC_JACK_MASK);\n\t\t}\n\t}\n\n\tmbhc->hph_status |= jack_type;\n\n\tif (jack_type == SND_JACK_HEADPHONE && mbhc->mbhc_cb->mbhc_micb_ramp_control)\n\t\tmbhc->mbhc_cb->mbhc_micb_ramp_control(mbhc->component, false);\n\n\tsnd_soc_jack_report(mbhc->jack, (mbhc->hph_status | SND_JACK_MECHANICAL),\n\t\t\t    WCD_MBHC_JACK_MASK);\n}\n\nstatic void wcd_mbhc_report_plug(struct wcd_mbhc *mbhc, int insertion,\n\t\t\t\t enum snd_jack_types jack_type)\n{\n\n\tWARN_ON(!mutex_is_locked(&mbhc->lock));\n\n\tif (!insertion)  \n\t\twcd_mbhc_report_plug_removal(mbhc, jack_type);\n\telse\n\t\twcd_mbhc_report_plug_insertion(mbhc, jack_type);\n\n}\n\nstatic void wcd_cancel_hs_detect_plug(struct wcd_mbhc *mbhc,\n\t\t\t\t      struct work_struct *work)\n{\n\tmbhc->hs_detect_work_stop = true;\n\tmutex_unlock(&mbhc->lock);\n\tcancel_work_sync(work);\n\tmutex_lock(&mbhc->lock);\n}\n\nstatic void wcd_mbhc_cancel_pending_work(struct wcd_mbhc *mbhc)\n{\n\t \n\twcd_cancel_btn_work(mbhc);\n\t \n\twcd_cancel_hs_detect_plug(mbhc,\t&mbhc->correct_plug_swch);\n}\n\nstatic void wcd_mbhc_elec_hs_report_unplug(struct wcd_mbhc *mbhc)\n{\n\twcd_mbhc_cancel_pending_work(mbhc);\n\t \n\twcd_mbhc_report_plug(mbhc, 1, SND_JACK_LINEOUT);\n\t \n\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_rem_intr);\n\twcd_mbhc_curr_micbias_control(mbhc, WCD_MBHC_EN_NONE);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC, 3);\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_DETECTION_TYPE, 1);\n\tenable_irq(mbhc->intr_ids->mbhc_hs_ins_intr);\n}\n\nstatic void wcd_mbhc_find_plug_and_report(struct wcd_mbhc *mbhc,\n\t\t\t\t   enum wcd_mbhc_plug_type plug_type)\n{\n\tif (mbhc->current_plug == plug_type)\n\t\treturn;\n\n\tmutex_lock(&mbhc->lock);\n\n\tswitch (plug_type) {\n\tcase MBHC_PLUG_TYPE_HEADPHONE:\n\t\twcd_mbhc_report_plug(mbhc, 1, SND_JACK_HEADPHONE);\n\t\tbreak;\n\tcase MBHC_PLUG_TYPE_HEADSET:\n\t\twcd_mbhc_report_plug(mbhc, 1, SND_JACK_HEADSET);\n\t\tbreak;\n\tcase MBHC_PLUG_TYPE_HIGH_HPH:\n\t\twcd_mbhc_report_plug(mbhc, 1, SND_JACK_LINEOUT);\n\t\tbreak;\n\tcase MBHC_PLUG_TYPE_GND_MIC_SWAP:\n\t\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADPHONE)\n\t\t\twcd_mbhc_report_plug(mbhc, 0, SND_JACK_HEADPHONE);\n\t\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADSET)\n\t\t\twcd_mbhc_report_plug(mbhc, 0, SND_JACK_HEADSET);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected current plug_type %d, plug_type %d\\n\",\n\t\t     mbhc->current_plug, plug_type);\n\t\tbreak;\n\t}\n\tmutex_unlock(&mbhc->lock);\n}\n\nstatic void wcd_schedule_hs_detect_plug(struct wcd_mbhc *mbhc,\n\t\t\t\t\t    struct work_struct *work)\n{\n\tWARN_ON(!mutex_is_locked(&mbhc->lock));\n\tmbhc->hs_detect_work_stop = false;\n\tschedule_work(work);\n}\n\nstatic void wcd_mbhc_adc_detect_plug_type(struct wcd_mbhc *mbhc)\n{\n\tstruct snd_soc_component *component = mbhc->component;\n\n\tWARN_ON(!mutex_is_locked(&mbhc->lock));\n\n\tif (mbhc->mbhc_cb->hph_pull_down_ctrl)\n\t\tmbhc->mbhc_cb->hph_pull_down_ctrl(component, false);\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 0);\n\n\tif (mbhc->mbhc_cb->mbhc_micbias_control) {\n\t\tmbhc->mbhc_cb->mbhc_micbias_control(component, MIC_BIAS_2,\n\t\t\t\t\t\t    MICB_ENABLE);\n\t\twcd_schedule_hs_detect_plug(mbhc, &mbhc->correct_plug_swch);\n\t}\n}\n\nstatic irqreturn_t wcd_mbhc_mech_plug_detect_irq(int irq, void *data)\n{\n\tstruct snd_soc_component *component;\n\tenum snd_jack_types jack_type;\n\tstruct wcd_mbhc *mbhc = data;\n\tbool detection_type;\n\n\tcomponent = mbhc->component;\n\tmutex_lock(&mbhc->lock);\n\n\tmbhc->in_swch_irq_handler = true;\n\n\twcd_mbhc_cancel_pending_work(mbhc);\n\n\tdetection_type = wcd_mbhc_read_field(mbhc, WCD_MBHC_MECH_DETECTION_TYPE);\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_MECH_DETECTION_TYPE, !detection_type);\n\n\t \n\tif (mbhc->mbhc_cb->mbhc_micb_ramp_control)\n\t\tmbhc->mbhc_cb->mbhc_micb_ramp_control(component, true);\n\n\tif (detection_type) {\n\t\tif (mbhc->current_plug != MBHC_PLUG_TYPE_NONE)\n\t\t\tgoto exit;\n\t\t \n\t\tmbhc->mbhc_cb->mbhc_bias(component, true);\n\t\tmbhc->is_btn_press = false;\n\t\twcd_mbhc_adc_detect_plug_type(mbhc);\n\t} else {\n\t\t \n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\t\tmbhc->extn_cable_hph_rem = false;\n\n\t\tif (mbhc->current_plug == MBHC_PLUG_TYPE_NONE)\n\t\t\tgoto exit;\n\n\t\tmbhc->is_btn_press = false;\n\t\tswitch (mbhc->current_plug) {\n\t\tcase MBHC_PLUG_TYPE_HEADPHONE:\n\t\t\tjack_type = SND_JACK_HEADPHONE;\n\t\t\tbreak;\n\t\tcase MBHC_PLUG_TYPE_HEADSET:\n\t\t\tjack_type = SND_JACK_HEADSET;\n\t\t\tbreak;\n\t\tcase MBHC_PLUG_TYPE_HIGH_HPH:\n\t\t\tif (mbhc->mbhc_detection_logic == WCD_DETECTION_ADC)\n\t\t\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_ISRC_EN, 0);\n\t\t\tjack_type = SND_JACK_LINEOUT;\n\t\t\tbreak;\n\t\tcase MBHC_PLUG_TYPE_GND_MIC_SWAP:\n\t\t\tdev_err(mbhc->dev, \"Ground and Mic Swapped on plug\\n\");\n\t\t\tgoto exit;\n\t\tdefault:\n\t\t\tdev_err(mbhc->dev, \"Invalid current plug: %d\\n\",\n\t\t\t\tmbhc->current_plug);\n\t\t\tgoto exit;\n\t\t}\n\t\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_rem_intr);\n\t\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_ins_intr);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_DETECTION_TYPE, 1);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC, 0);\n\t\twcd_mbhc_report_plug(mbhc, 0, jack_type);\n\t}\n\nexit:\n\tmbhc->in_swch_irq_handler = false;\n\tmutex_unlock(&mbhc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int wcd_mbhc_get_button_mask(struct wcd_mbhc *mbhc)\n{\n\tint mask = 0;\n\tint btn;\n\n\tbtn = wcd_mbhc_read_field(mbhc, WCD_MBHC_BTN_RESULT);\n\n\tswitch (btn) {\n\tcase 0:\n\t\tmask = SND_JACK_BTN_0;\n\t\tbreak;\n\tcase 1:\n\t\tmask = SND_JACK_BTN_1;\n\t\tbreak;\n\tcase 2:\n\t\tmask = SND_JACK_BTN_2;\n\t\tbreak;\n\tcase 3:\n\t\tmask = SND_JACK_BTN_3;\n\t\tbreak;\n\tcase 4:\n\t\tmask = SND_JACK_BTN_4;\n\t\tbreak;\n\tcase 5:\n\t\tmask = SND_JACK_BTN_5;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mask;\n}\n\nstatic void wcd_btn_long_press_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct wcd_mbhc *mbhc = container_of(dwork, struct wcd_mbhc, mbhc_btn_dwork);\n\n\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADSET)\n\t\tsnd_soc_jack_report(mbhc->jack, mbhc->buttons_pressed,\n\t\t\t\t    mbhc->buttons_pressed);\n}\n\nstatic irqreturn_t wcd_mbhc_btn_press_handler(int irq, void *data)\n{\n\tstruct wcd_mbhc *mbhc = data;\n\tint mask;\n\tunsigned long msec_val;\n\n\tmutex_lock(&mbhc->lock);\n\twcd_cancel_btn_work(mbhc);\n\tmbhc->is_btn_press = true;\n\tmsec_val = jiffies_to_msecs(jiffies - mbhc->jiffies_atreport);\n\n\t \n\tif (msec_val < MBHC_BUTTON_PRESS_THRESHOLD_MIN)\n\t\tgoto done;\n\n\t \n\tif (mbhc->in_swch_irq_handler)\n\t\tgoto done;\n\n\t \n\tif (mbhc->current_plug != MBHC_PLUG_TYPE_HEADSET)\n\t\tgoto done;\n\n\tmask = wcd_mbhc_get_button_mask(mbhc);\n\tmbhc->buttons_pressed |= mask;\n\tif (schedule_delayed_work(&mbhc->mbhc_btn_dwork, msecs_to_jiffies(400)) == 0)\n\t\tWARN(1, \"Button pressed twice without release event\\n\");\ndone:\n\tmutex_unlock(&mbhc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcd_mbhc_btn_release_handler(int irq, void *data)\n{\n\tstruct wcd_mbhc *mbhc = data;\n\tint ret;\n\n\tmutex_lock(&mbhc->lock);\n\tif (mbhc->is_btn_press)\n\t\tmbhc->is_btn_press = false;\n\telse  \n\t\tgoto exit;\n\n\tif (!(mbhc->buttons_pressed & WCD_MBHC_JACK_BUTTON_MASK))\n\t\tgoto exit;\n\n\tret = wcd_cancel_btn_work(mbhc);\n\tif (ret == 0) {  \n\t\tsnd_soc_jack_report(mbhc->jack,\t0, mbhc->buttons_pressed);\n\t} else {\n\t\tif (!mbhc->in_swch_irq_handler) {\n\t\t\t \n\t\t\tsnd_soc_jack_report(mbhc->jack, mbhc->buttons_pressed,\n\t\t\t\t\t    mbhc->buttons_pressed);\n\t\t\tsnd_soc_jack_report(mbhc->jack,\t0, mbhc->buttons_pressed);\n\t\t}\n\t}\n\tmbhc->buttons_pressed &= ~WCD_MBHC_JACK_BUTTON_MASK;\nexit:\n\tmutex_unlock(&mbhc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcd_mbhc_hph_ocp_irq(struct wcd_mbhc *mbhc, bool hphr)\n{\n\n\t \n\tdev_err(mbhc->dev, \"MBHC Over Current on %s detected\\n\",\n\t\thphr ? \"HPHR\" : \"HPHL\");\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_OCP_FSM_EN, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_OCP_FSM_EN, 1);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcd_mbhc_hphl_ocp_irq(int irq, void *data)\n{\n\treturn wcd_mbhc_hph_ocp_irq(data, false);\n}\n\nstatic irqreturn_t wcd_mbhc_hphr_ocp_irq(int irq, void *data)\n{\n\treturn wcd_mbhc_hph_ocp_irq(data, true);\n}\n\nstatic int wcd_mbhc_initialise(struct wcd_mbhc *mbhc)\n{\n\tstruct snd_soc_component *component = mbhc->component;\n\tint ret;\n\n\tret = pm_runtime_get_sync(component->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(component->dev,\n\t\t\t\t    \"pm_runtime_get_sync failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tpm_runtime_put_noidle(component->dev);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&mbhc->lock);\n\n\t \n\tif (mbhc->mbhc_cb->hph_pull_up_control_v2)\n\t\tmbhc->mbhc_cb->hph_pull_up_control_v2(component,\n\t\t\t\t\t\t      HS_PULLUP_I_DEFAULT);\n\telse if (mbhc->mbhc_cb->hph_pull_up_control)\n\t\tmbhc->mbhc_cb->hph_pull_up_control(component, I_DEFAULT);\n\telse\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_HS_L_DET_PULL_UP_CTRL, 3);\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_HPHL_PLUG_TYPE, mbhc->cfg->hphl_swh);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_GND_PLUG_TYPE, mbhc->cfg->gnd_swh);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_SW_HPH_LP_100K_TO_GND, 1);\n\tif (mbhc->cfg->gnd_det_en && mbhc->mbhc_cb->mbhc_gnd_det_ctrl)\n\t\tmbhc->mbhc_cb->mbhc_gnd_det_ctrl(component, true);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_HS_L_DET_PULL_UP_COMP_CTRL, 1);\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_L_DET_EN, 1);\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_INSREM_DBNC, 6);\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_DBNC, 2);\n\n\t \n\tmbhc->mbhc_cb->mbhc_bias(component, true);\n\t \n\tif (mbhc->mbhc_cb->clk_setup)\n\t\tmbhc->mbhc_cb->clk_setup(component, true);\n\n\t \n\twcd_program_hs_vref(mbhc);\n\n\twcd_program_btn_threshold(mbhc, false);\n\n\tmutex_unlock(&mbhc->lock);\n\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n\n\treturn 0;\n}\n\nstatic int wcd_mbhc_get_micbias(struct wcd_mbhc *mbhc)\n{\n\tint micbias = 0;\n\n\tif (mbhc->mbhc_cb->get_micbias_val) {\n\t\tmbhc->mbhc_cb->get_micbias_val(mbhc->component, &micbias);\n\t} else {\n\t\tu8 vout_ctl = 0;\n\t\t \n\t\tvout_ctl = wcd_mbhc_read_field(mbhc, WCD_MBHC_MICB2_VOUT);\n\t\t \n\t\tmicbias = 1000 + (vout_ctl * 50);\n\t}\n\treturn micbias;\n}\n\nstatic int wcd_get_voltage_from_adc(u8 val, int micbias)\n{\n\t \n\treturn ((val * 125 * micbias)/(WCD_MBHC_ADC_MICBIAS_MV * 10));\n}\n\nstatic int wcd_measure_adc_continuous(struct wcd_mbhc *mbhc)\n{\n\tu8 adc_result;\n\tint output_mv;\n\tint retry = 3;\n\tu8 adc_en;\n\n\t \n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC, 0x00);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, 1);\n\t \n\tadc_en = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_EN);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 0);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_MUX_CTL, MUX_CTL_IN2P);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 1);\n\n\twhile (retry--) {\n\t\t \n\t\tusleep_range(3000, 3100);\n\t\tadc_result = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_RESULT);\n\t}\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, adc_en);\n\t \n\toutput_mv = wcd_get_voltage_from_adc(adc_result, wcd_mbhc_get_micbias(mbhc));\n\n\treturn output_mv;\n}\n\nstatic int wcd_measure_adc_once(struct wcd_mbhc *mbhc, int mux_ctl)\n{\n\tstruct device *dev = mbhc->dev;\n\tu8 adc_timeout = 0;\n\tu8 adc_complete = 0;\n\tu8 adc_result;\n\tint retry = 6;\n\tint ret;\n\tint output_mv = 0;\n\tu8 adc_en;\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, 0);\n\t \n\tadc_en = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_EN);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_MUX_CTL, mux_ctl);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 1);\n\n\twhile (retry--) {\n\t\t \n\t\tusleep_range(600, 610);\n\n\t\t \n\t\tadc_timeout = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_TIMEOUT);\n\t\tif (adc_timeout)\n\t\t\tcontinue;\n\n\t\t \n\t\tadc_complete = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_COMPLETE);\n\t\tif (!adc_complete)\n\t\t\tcontinue;\n\n\t\t \n\t\tadc_result = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_RESULT);\n\n\t\t \n\t\toutput_mv = wcd_get_voltage_from_adc(adc_result,\n\t\t\t\t\t\twcd_mbhc_get_micbias(mbhc));\n\t\tbreak;\n\t}\n\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, adc_en);\n\n\tif (retry <= 0) {\n\t\tdev_err(dev, \"%s: adc complete: %d, adc timeout: %d\\n\",\n\t\t\t__func__, adc_complete, adc_timeout);\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = output_mv;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int wcd_check_cross_conn(struct wcd_mbhc *mbhc)\n{\n\tu8 adc_mode, elect_ctl, adc_en, fsm_en;\n\tint hphl_adc_res, hphr_adc_res;\n\tbool is_cross_conn = false;\n\n\t \n\tif (wcd_mbhc_read_field(mbhc, WCD_MBHC_HPH_PA_EN))\n\t\treturn -EINVAL;\n\n\t \n\telect_ctl = wcd_mbhc_read_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC, 0);\n\n\t \n\tadc_mode = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_MODE);\n\t \n\tadc_en = wcd_mbhc_read_field(mbhc, WCD_MBHC_ADC_EN);\n\t \n\tfsm_en = wcd_mbhc_read_field(mbhc, WCD_MBHC_FSM_EN);\n\n\t \n\thphl_adc_res = wcd_measure_adc_once(mbhc, MUX_CTL_HPH_L);\n\tif (hphl_adc_res < 0)\n\t\treturn hphl_adc_res;\n\n\t \n\thphr_adc_res = wcd_measure_adc_once(mbhc, MUX_CTL_HPH_R);\n\tif (hphr_adc_res < 0)\n\t\treturn hphr_adc_res;\n\n\tif (hphl_adc_res > HPHL_CROSS_CONN_THRESHOLD ||\n\t    hphr_adc_res > HPHL_CROSS_CONN_THRESHOLD)\n\t\tis_cross_conn = true;\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 0);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_MUX_CTL, MUX_CTL_AUTO);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, 1);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, adc_en);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, adc_mode);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_FSM_EN, fsm_en);\n\t \n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_SCHMT_ISRC, elect_ctl);\n\n\treturn is_cross_conn;\n}\n\nstatic int wcd_mbhc_adc_get_hs_thres(struct wcd_mbhc *mbhc)\n{\n\tint hs_threshold, micbias_mv;\n\n\tmicbias_mv = wcd_mbhc_get_micbias(mbhc);\n\tif (mbhc->cfg->hs_thr) {\n\t\tif (mbhc->cfg->micb_mv == micbias_mv)\n\t\t\ths_threshold = mbhc->cfg->hs_thr;\n\t\telse\n\t\t\ths_threshold = (mbhc->cfg->hs_thr *\n\t\t\t\tmicbias_mv) / mbhc->cfg->micb_mv;\n\t} else {\n\t\ths_threshold = ((WCD_MBHC_ADC_HS_THRESHOLD_MV *\n\t\t\tmicbias_mv) / WCD_MBHC_ADC_MICBIAS_MV);\n\t}\n\treturn hs_threshold;\n}\n\nstatic int wcd_mbhc_adc_get_hph_thres(struct wcd_mbhc *mbhc)\n{\n\tint hph_threshold, micbias_mv;\n\n\tmicbias_mv = wcd_mbhc_get_micbias(mbhc);\n\tif (mbhc->cfg->hph_thr) {\n\t\tif (mbhc->cfg->micb_mv == micbias_mv)\n\t\t\thph_threshold = mbhc->cfg->hph_thr;\n\t\telse\n\t\t\thph_threshold = (mbhc->cfg->hph_thr *\n\t\t\t\tmicbias_mv) / mbhc->cfg->micb_mv;\n\t} else {\n\t\thph_threshold = ((WCD_MBHC_ADC_HPH_THRESHOLD_MV *\n\t\t\tmicbias_mv) / WCD_MBHC_ADC_MICBIAS_MV);\n\t}\n\treturn hph_threshold;\n}\n\nstatic void wcd_mbhc_adc_update_fsm_source(struct wcd_mbhc *mbhc,\n\t\t\t\t\t   enum wcd_mbhc_plug_type plug_type)\n{\n\tbool micbias2 = false;\n\n\tswitch (plug_type) {\n\tcase MBHC_PLUG_TYPE_HEADPHONE:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 3);\n\t\tbreak;\n\tcase MBHC_PLUG_TYPE_HEADSET:\n\t\tif (mbhc->mbhc_cb->micbias_enable_status)\n\t\t\tmicbias2 = mbhc->mbhc_cb->micbias_enable_status(mbhc->component,\n\t\t\t\t\t\t\t\t\tMIC_BIAS_2);\n\n\t\tif (!mbhc->is_hs_recording && !micbias2)\n\t\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 3);\n\t\tbreak;\n\tdefault:\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\t\tbreak;\n\n\t}\n}\n\nstatic void wcd_mbhc_bcs_enable(struct wcd_mbhc *mbhc, int plug_type, bool enable)\n{\n\tswitch (plug_type) {\n\tcase MBHC_PLUG_TYPE_HEADSET:\n\tcase MBHC_PLUG_TYPE_HEADPHONE:\n\t\tif (mbhc->mbhc_cb->bcs_enable)\n\t\t\tmbhc->mbhc_cb->bcs_enable(mbhc->component, enable);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int wcd_mbhc_get_plug_from_adc(struct wcd_mbhc *mbhc, int adc_result)\n\n{\n\tenum wcd_mbhc_plug_type plug_type;\n\tu32 hph_thr, hs_thr;\n\n\ths_thr = wcd_mbhc_adc_get_hs_thres(mbhc);\n\thph_thr = wcd_mbhc_adc_get_hph_thres(mbhc);\n\n\tif (adc_result < hph_thr)\n\t\tplug_type = MBHC_PLUG_TYPE_HEADPHONE;\n\telse if (adc_result > hs_thr)\n\t\tplug_type = MBHC_PLUG_TYPE_HIGH_HPH;\n\telse\n\t\tplug_type = MBHC_PLUG_TYPE_HEADSET;\n\n\treturn plug_type;\n}\n\nstatic int wcd_mbhc_get_spl_hs_thres(struct wcd_mbhc *mbhc)\n{\n\tint hs_threshold, micbias_mv;\n\n\tmicbias_mv = wcd_mbhc_get_micbias(mbhc);\n\tif (mbhc->cfg->hs_thr && mbhc->cfg->micb_mv != WCD_MBHC_ADC_MICBIAS_MV) {\n\t\tif (mbhc->cfg->micb_mv == micbias_mv)\n\t\t\ths_threshold = mbhc->cfg->hs_thr;\n\t\telse\n\t\t\ths_threshold = (mbhc->cfg->hs_thr * micbias_mv) / mbhc->cfg->micb_mv;\n\t} else {\n\t\ths_threshold = ((WCD_MBHC_ADC_HS_THRESHOLD_MV * micbias_mv) /\n\t\t\t\t\t\t\tWCD_MBHC_ADC_MICBIAS_MV);\n\t}\n\treturn hs_threshold;\n}\n\nstatic bool wcd_mbhc_check_for_spl_headset(struct wcd_mbhc *mbhc)\n{\n\tbool is_spl_hs = false;\n\tint output_mv, hs_threshold, hph_threshold;\n\n\tif (!mbhc->mbhc_cb->mbhc_micb_ctrl_thr_mic)\n\t\treturn false;\n\n\t \n\tmbhc->mbhc_cb->mbhc_micb_ctrl_thr_mic(mbhc->component, MIC_BIAS_2, true);\n\tusleep_range(10000, 10100);\n\n\toutput_mv = wcd_measure_adc_once(mbhc, MUX_CTL_IN2P);\n\ths_threshold = wcd_mbhc_get_spl_hs_thres(mbhc);\n\thph_threshold = wcd_mbhc_adc_get_hph_thres(mbhc);\n\n\tif (!(output_mv > hs_threshold || output_mv < hph_threshold))\n\t\tis_spl_hs = true;\n\n\t \n\tif (!is_spl_hs) {\n\t\tmbhc->mbhc_cb->mbhc_micb_ctrl_thr_mic(mbhc->component, MIC_BIAS_2, false);\n\t\t \n\t\tusleep_range(10000, 10100);\n\t}\n\n\treturn is_spl_hs;\n}\n\nstatic void wcd_correct_swch_plug(struct work_struct *work)\n{\n\tstruct wcd_mbhc *mbhc;\n\tstruct snd_soc_component *component;\n\tenum wcd_mbhc_plug_type plug_type = MBHC_PLUG_TYPE_INVALID;\n\tunsigned long timeout;\n\tint pt_gnd_mic_swap_cnt = 0;\n\tint output_mv, cross_conn, hs_threshold, try = 0, micbias_mv;\n\tbool is_spl_hs = false;\n\tbool is_pa_on;\n\tint ret;\n\n\tmbhc = container_of(work, struct wcd_mbhc, correct_plug_swch);\n\tcomponent = mbhc->component;\n\n\tret = pm_runtime_get_sync(component->dev);\n\tif (ret < 0 && ret != -EACCES) {\n\t\tdev_err_ratelimited(component->dev,\n\t\t\t\t    \"pm_runtime_get_sync failed in %s, ret %d\\n\",\n\t\t\t\t    __func__, ret);\n\t\tpm_runtime_put_noidle(component->dev);\n\t\treturn;\n\t}\n\tmicbias_mv = wcd_mbhc_get_micbias(mbhc);\n\ths_threshold = wcd_mbhc_adc_get_hs_thres(mbhc);\n\n\t \n\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_ins_intr);\n\n\t \n\tdo {\n\t\tcross_conn = wcd_check_cross_conn(mbhc);\n\t\ttry++;\n\t} while (try < GND_MIC_SWAP_THRESHOLD);\n\n\tif (cross_conn > 0) {\n\t\tplug_type = MBHC_PLUG_TYPE_GND_MIC_SWAP;\n\t\tdev_err(mbhc->dev, \"cross connection found, Plug type %d\\n\",\n\t\t\tplug_type);\n\t\tgoto correct_plug_type;\n\t}\n\n\t \n\toutput_mv = wcd_measure_adc_continuous(mbhc);\n\tplug_type = wcd_mbhc_get_plug_from_adc(mbhc, output_mv);\n\n\t \n\tswitch (plug_type) {\n\tcase MBHC_PLUG_TYPE_HEADPHONE:\n\t\twcd_mbhc_find_plug_and_report(mbhc, plug_type);\n\t\tbreak;\n\tcase MBHC_PLUG_TYPE_HEADSET:\n\t\twcd_mbhc_find_plug_and_report(mbhc, plug_type);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 0);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ncorrect_plug_type:\n\n\t \n\twcd_mbhc_bcs_enable(mbhc, plug_type, false);\n\n\ttimeout = jiffies + msecs_to_jiffies(HS_DETECT_PLUG_TIME_MS);\n\n\twhile (!time_after(jiffies, timeout)) {\n\t\tif (mbhc->hs_detect_work_stop) {\n\t\t\twcd_micbias_disable(mbhc);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmsleep(180);\n\t\t \n\t\toutput_mv = wcd_measure_adc_once(mbhc, MUX_CTL_IN2P);\n\t\tplug_type = wcd_mbhc_get_plug_from_adc(mbhc, output_mv);\n\t\tis_pa_on = wcd_mbhc_read_field(mbhc, WCD_MBHC_HPH_PA_EN);\n\n\t\tif (output_mv > hs_threshold && !is_spl_hs) {\n\t\t\tis_spl_hs = wcd_mbhc_check_for_spl_headset(mbhc);\n\t\t\toutput_mv = wcd_measure_adc_once(mbhc, MUX_CTL_IN2P);\n\n\t\t\tif (is_spl_hs) {\n\t\t\t\ths_threshold *= wcd_mbhc_get_micbias(mbhc);\n\t\t\t\ths_threshold /= micbias_mv;\n\t\t\t}\n\t\t}\n\n\t\tif ((output_mv <= hs_threshold) && !is_pa_on) {\n\t\t\t \n\t\t\tcross_conn = wcd_check_cross_conn(mbhc);\n\t\t\tif (cross_conn > 0) {  \n\t\t\t\tpt_gnd_mic_swap_cnt++;\n\t\t\t\tif (pt_gnd_mic_swap_cnt < GND_MIC_SWAP_THRESHOLD)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tplug_type = MBHC_PLUG_TYPE_GND_MIC_SWAP;\n\t\t\t} else if (!cross_conn) {  \n\t\t\t\tpt_gnd_mic_swap_cnt = 0;\n\t\t\t\tplug_type = wcd_mbhc_get_plug_from_adc(mbhc, output_mv);\n\t\t\t\tcontinue;\n\t\t\t} else  \n\t\t\t\tcontinue;\n\n\t\t\tif (pt_gnd_mic_swap_cnt == GND_MIC_SWAP_THRESHOLD) {\n\t\t\t\t \n\t\t\t\tif (mbhc->cfg->swap_gnd_mic) {\n\t\t\t\t\tif (mbhc->cfg->swap_gnd_mic(component, true))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (output_mv > hs_threshold || mbhc->force_linein)\n\t\t\tplug_type = MBHC_PLUG_TYPE_HIGH_HPH;\n\t}\n\n\twcd_mbhc_bcs_enable(mbhc, plug_type, true);\n\n\tif (plug_type == MBHC_PLUG_TYPE_HIGH_HPH) {\n\t\tif (is_spl_hs)\n\t\t\tplug_type = MBHC_PLUG_TYPE_HEADSET;\n\t\telse\n\t\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_ELECT_ISRC_EN, 1);\n\t}\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 0);\n\twcd_mbhc_find_plug_and_report(mbhc, plug_type);\n\n\t \n\tif (plug_type == MBHC_PLUG_TYPE_HEADSET)\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 1);\n\telse\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 0);\n\n\tif (mbhc->mbhc_cb->mbhc_micbias_control)\n\t\twcd_mbhc_adc_update_fsm_source(mbhc, plug_type);\n\nexit:\n\tif (mbhc->mbhc_cb->mbhc_micbias_control )\n\t\tmbhc->mbhc_cb->mbhc_micbias_control(component, MIC_BIAS_2, MICB_DISABLE);\n\n\t \n\tif (plug_type == MBHC_PLUG_TYPE_HEADPHONE) {\n\t\twcd_micbias_disable(mbhc);\n\t\t \n\t\tenable_irq(mbhc->intr_ids->mbhc_hs_ins_intr);\n\t}\n\n\tif (mbhc->mbhc_cb->hph_pull_down_ctrl)\n\t\tmbhc->mbhc_cb->hph_pull_down_ctrl(component, true);\n\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n}\n\nstatic irqreturn_t wcd_mbhc_adc_hs_rem_irq(int irq, void *data)\n{\n\tstruct wcd_mbhc *mbhc = data;\n\tunsigned long timeout;\n\tint adc_threshold, output_mv, retry = 0;\n\n\tmutex_lock(&mbhc->lock);\n\ttimeout = jiffies + msecs_to_jiffies(WCD_FAKE_REMOVAL_MIN_PERIOD_MS);\n\tadc_threshold = wcd_mbhc_adc_get_hs_thres(mbhc);\n\n\tdo {\n\t\tretry++;\n\t\t \n\t\tusleep_range(10000, 10100);\n\t\toutput_mv = wcd_measure_adc_once(mbhc, MUX_CTL_IN2P);\n\n\t\t \n\t\tif ((output_mv <= adc_threshold) && retry > FAKE_REM_RETRY_ATTEMPTS)\n\t\t\tgoto exit;\n\t} while (!time_after(jiffies, timeout));\n\n\t \n\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADPHONE)\n\t\tmbhc->extn_cable_hph_rem = true;\n\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_MODE, 0);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_ADC_EN, 0);\n\twcd_mbhc_elec_hs_report_unplug(mbhc);\n\twcd_mbhc_write_field(mbhc, WCD_MBHC_BTN_ISRC_CTL, 0);\n\nexit:\n\tmutex_unlock(&mbhc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcd_mbhc_adc_hs_ins_irq(int irq, void *data)\n{\n\tstruct wcd_mbhc *mbhc = data;\n\tu8 clamp_state;\n\tu8 clamp_retry = WCD_MBHC_FAKE_INS_RETRY;\n\n\t \n\tif (mbhc->extn_cable_hph_rem == true) {\n\t\tmbhc->extn_cable_hph_rem = false;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdo {\n\t\tclamp_state = wcd_mbhc_read_field(mbhc, WCD_MBHC_IN2P_CLAMP_STATE);\n\t\tif (clamp_state)\n\t\t\treturn IRQ_HANDLED;\n\t\t \n\t\tusleep_range(30000, 30100);\n\t} while (--clamp_retry);\n\n\t \n\tif (mbhc->current_plug == MBHC_PLUG_TYPE_HEADPHONE) {\n\t\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_ins_intr);\n\t\twcd_mbhc_write_field(mbhc, WCD_MBHC_DETECTION_DONE, 1);\n\t\twcd_mbhc_find_plug_and_report(mbhc, MBHC_PLUG_TYPE_HEADSET);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint wcd_mbhc_get_impedance(struct wcd_mbhc *mbhc, uint32_t *zl,\tuint32_t *zr)\n{\n\t*zl = mbhc->zl;\n\t*zr = mbhc->zr;\n\n\tif (*zl && *zr)\n\t\treturn 0;\n\telse\n\t\treturn -EINVAL;\n}\nEXPORT_SYMBOL(wcd_mbhc_get_impedance);\n\nvoid wcd_mbhc_set_hph_type(struct wcd_mbhc *mbhc, int hph_type)\n{\n\tmbhc->hph_type = hph_type;\n}\nEXPORT_SYMBOL(wcd_mbhc_set_hph_type);\n\nint wcd_mbhc_get_hph_type(struct wcd_mbhc *mbhc)\n{\n\treturn mbhc->hph_type;\n}\nEXPORT_SYMBOL(wcd_mbhc_get_hph_type);\n\nint wcd_mbhc_start(struct wcd_mbhc *mbhc, struct wcd_mbhc_config *cfg,\n\t\t   struct snd_soc_jack *jack)\n{\n\tif (!mbhc || !cfg || !jack)\n\t\treturn -EINVAL;\n\n\tmbhc->cfg = cfg;\n\tmbhc->jack = jack;\n\n\treturn wcd_mbhc_initialise(mbhc);\n}\nEXPORT_SYMBOL(wcd_mbhc_start);\n\nvoid wcd_mbhc_stop(struct wcd_mbhc *mbhc)\n{\n\tmbhc->current_plug = MBHC_PLUG_TYPE_NONE;\n\tmbhc->hph_status = 0;\n\tdisable_irq_nosync(mbhc->intr_ids->hph_left_ocp);\n\tdisable_irq_nosync(mbhc->intr_ids->hph_right_ocp);\n}\nEXPORT_SYMBOL(wcd_mbhc_stop);\n\nint wcd_dt_parse_mbhc_data(struct device *dev, struct wcd_mbhc_config *cfg)\n{\n\tstruct device_node *np = dev->of_node;\n\tint ret, i, microvolt;\n\n\tif (of_property_read_bool(np, \"qcom,hphl-jack-type-normally-closed\"))\n\t\tcfg->hphl_swh = false;\n\telse\n\t\tcfg->hphl_swh = true;\n\n\tif (of_property_read_bool(np, \"qcom,ground-jack-type-normally-closed\"))\n\t\tcfg->gnd_swh = false;\n\telse\n\t\tcfg->gnd_swh = true;\n\n\tret = of_property_read_u32(np, \"qcom,mbhc-headset-vthreshold-microvolt\",\n\t\t\t\t   &microvolt);\n\tif (ret)\n\t\tdev_dbg(dev, \"missing qcom,mbhc-hs-mic-max-vthreshold--microvolt in dt node\\n\");\n\telse\n\t\tcfg->hs_thr = microvolt/1000;\n\n\tret = of_property_read_u32(np, \"qcom,mbhc-headphone-vthreshold-microvolt\",\n\t\t\t\t   &microvolt);\n\tif (ret)\n\t\tdev_dbg(dev, \"missing qcom,mbhc-hs-mic-min-vthreshold-microvolt\tentry\\n\");\n\telse\n\t\tcfg->hph_thr = microvolt/1000;\n\n\tret = of_property_read_u32_array(np,\n\t\t\t\t\t \"qcom,mbhc-buttons-vthreshold-microvolt\",\n\t\t\t\t\t &cfg->btn_high[0],\n\t\t\t\t\t WCD_MBHC_DEF_BUTTONS);\n\tif (ret)\n\t\tdev_err(dev, \"missing qcom,mbhc-buttons-vthreshold-microvolt entry\\n\");\n\n\tfor (i = 0; i < WCD_MBHC_DEF_BUTTONS; i++) {\n\t\tif (ret)  \n\t\t\tcfg->btn_high[i] = 500000;\n\t\telse\n\t\t\t \n\t\t\tcfg->btn_high[i] = cfg->btn_high[i]/1000;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(wcd_dt_parse_mbhc_data);\n\nstruct wcd_mbhc *wcd_mbhc_init(struct snd_soc_component *component,\n\t\t\t       const struct wcd_mbhc_cb *mbhc_cb,\n\t\t\t       const struct wcd_mbhc_intr *intr_ids,\n\t\t\t       struct wcd_mbhc_field *fields,\n\t\t\t       bool impedance_det_en)\n{\n\tstruct device *dev = component->dev;\n\tstruct wcd_mbhc *mbhc;\n\tint ret;\n\n\tif (!intr_ids || !fields || !mbhc_cb || !mbhc_cb->mbhc_bias || !mbhc_cb->set_btn_thr) {\n\t\tdev_err(dev, \"%s: Insufficient mbhc configuration\\n\", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tmbhc = kzalloc(sizeof(*mbhc), GFP_KERNEL);\n\tif (!mbhc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmbhc->component = component;\n\tmbhc->dev = dev;\n\tmbhc->intr_ids = intr_ids;\n\tmbhc->mbhc_cb = mbhc_cb;\n\tmbhc->fields = fields;\n\tmbhc->mbhc_detection_logic = WCD_DETECTION_ADC;\n\n\tif (mbhc_cb->compute_impedance)\n\t\tmbhc->impedance_detect = impedance_det_en;\n\n\tINIT_DELAYED_WORK(&mbhc->mbhc_btn_dwork, wcd_btn_long_press_fn);\n\n\tmutex_init(&mbhc->lock);\n\n\tINIT_WORK(&mbhc->correct_plug_swch, wcd_correct_swch_plug);\n\n\tret = request_threaded_irq(mbhc->intr_ids->mbhc_sw_intr, NULL,\n\t\t\t\t\twcd_mbhc_mech_plug_detect_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"mbhc sw intr\", mbhc);\n\tif (ret)\n\t\tgoto err_free_mbhc;\n\n\tret = request_threaded_irq(mbhc->intr_ids->mbhc_btn_press_intr, NULL,\n\t\t\t\t\twcd_mbhc_btn_press_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"Button Press detect\", mbhc);\n\tif (ret)\n\t\tgoto err_free_sw_intr;\n\n\tret = request_threaded_irq(mbhc->intr_ids->mbhc_btn_release_intr, NULL,\n\t\t\t\t\twcd_mbhc_btn_release_handler,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"Button Release detect\", mbhc);\n\tif (ret)\n\t\tgoto err_free_btn_press_intr;\n\n\tret = request_threaded_irq(mbhc->intr_ids->mbhc_hs_ins_intr, NULL,\n\t\t\t\t\twcd_mbhc_adc_hs_ins_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"Elect Insert\", mbhc);\n\tif (ret)\n\t\tgoto err_free_btn_release_intr;\n\n\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_ins_intr);\n\n\tret = request_threaded_irq(mbhc->intr_ids->mbhc_hs_rem_intr, NULL,\n\t\t\t\t\twcd_mbhc_adc_hs_rem_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"Elect Remove\", mbhc);\n\tif (ret)\n\t\tgoto err_free_hs_ins_intr;\n\n\tdisable_irq_nosync(mbhc->intr_ids->mbhc_hs_rem_intr);\n\n\tret = request_threaded_irq(mbhc->intr_ids->hph_left_ocp, NULL,\n\t\t\t\t\twcd_mbhc_hphl_ocp_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"HPH_L OCP detect\", mbhc);\n\tif (ret)\n\t\tgoto err_free_hs_rem_intr;\n\n\tret = request_threaded_irq(mbhc->intr_ids->hph_right_ocp, NULL,\n\t\t\t\t\twcd_mbhc_hphr_ocp_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_RISING,\n\t\t\t\t\t\"HPH_R OCP detect\", mbhc);\n\tif (ret)\n\t\tgoto err_free_hph_left_ocp;\n\n\treturn mbhc;\n\nerr_free_hph_left_ocp:\n\tfree_irq(mbhc->intr_ids->hph_left_ocp, mbhc);\nerr_free_hs_rem_intr:\n\tfree_irq(mbhc->intr_ids->mbhc_hs_rem_intr, mbhc);\nerr_free_hs_ins_intr:\n\tfree_irq(mbhc->intr_ids->mbhc_hs_ins_intr, mbhc);\nerr_free_btn_release_intr:\n\tfree_irq(mbhc->intr_ids->mbhc_btn_release_intr, mbhc);\nerr_free_btn_press_intr:\n\tfree_irq(mbhc->intr_ids->mbhc_btn_press_intr, mbhc);\nerr_free_sw_intr:\n\tfree_irq(mbhc->intr_ids->mbhc_sw_intr, mbhc);\nerr_free_mbhc:\n\tkfree(mbhc);\n\n\tdev_err(dev, \"Failed to request mbhc interrupts %d\\n\", ret);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(wcd_mbhc_init);\n\nvoid wcd_mbhc_deinit(struct wcd_mbhc *mbhc)\n{\n\tfree_irq(mbhc->intr_ids->hph_right_ocp, mbhc);\n\tfree_irq(mbhc->intr_ids->hph_left_ocp, mbhc);\n\tfree_irq(mbhc->intr_ids->mbhc_hs_rem_intr, mbhc);\n\tfree_irq(mbhc->intr_ids->mbhc_hs_ins_intr, mbhc);\n\tfree_irq(mbhc->intr_ids->mbhc_btn_release_intr, mbhc);\n\tfree_irq(mbhc->intr_ids->mbhc_btn_press_intr, mbhc);\n\tfree_irq(mbhc->intr_ids->mbhc_sw_intr, mbhc);\n\n\tmutex_lock(&mbhc->lock);\n\twcd_cancel_hs_detect_plug(mbhc,\t&mbhc->correct_plug_swch);\n\tmutex_unlock(&mbhc->lock);\n\n\tkfree(mbhc);\n}\nEXPORT_SYMBOL(wcd_mbhc_deinit);\n\nstatic int __init mbhc_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit mbhc_exit(void)\n{\n}\n\nmodule_init(mbhc_init);\nmodule_exit(mbhc_exit);\n\nMODULE_DESCRIPTION(\"wcd MBHC v2 module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}