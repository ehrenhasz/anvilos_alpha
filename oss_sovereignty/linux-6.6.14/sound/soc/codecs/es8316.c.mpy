{
  "module_name": "es8316.c",
  "hash_id": "84b91694c2d378925b2034a31de154bb3d52bff308adaa3514d77f40fdeaf889",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/es8316.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/mod_devicetable.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n#include <sound/jack.h>\n#include \"es8316.h\"\n\n \n#define NR_SUPPORTED_MCLK_LRCK_RATIOS ARRAY_SIZE(supported_mclk_lrck_ratios)\nstatic const unsigned int supported_mclk_lrck_ratios[] = {\n\t256, 384, 400, 500, 512, 768, 1024\n};\n\nstruct es8316_priv {\n\tstruct mutex lock;\n\tstruct clk *mclk;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct snd_soc_jack *jack;\n\tint irq;\n\tunsigned int sysclk;\n\tunsigned int allowed_rates[NR_SUPPORTED_MCLK_LRCK_RATIOS];\n\tstruct snd_pcm_hw_constraint_list sysclk_constraints;\n\tbool jd_inverted;\n};\n\n \nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(dac_vol_tlv, -9600, 50, 1);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(adc_vol_tlv, -9600, 50, 1);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(alc_max_gain_tlv, -650, 150, 0);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_SCALE(alc_min_gain_tlv, -1200, 150, 0);\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(alc_target_tlv,\n\t0, 10, TLV_DB_SCALE_ITEM(-1650, 150, 0),\n\t11, 11, TLV_DB_SCALE_ITEM(-150, 0, 0),\n);\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(hpmixer_gain_tlv,\n\t0, 4, TLV_DB_SCALE_ITEM(-1200, 150, 0),\n\t8, 11, TLV_DB_SCALE_ITEM(-450, 150, 0),\n);\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(adc_pga_gain_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(-350, 0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(0, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(250, 0, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(450, 0, 0),\n\t4, 7, TLV_DB_SCALE_ITEM(700, 300, 0),\n\t8, 10, TLV_DB_SCALE_ITEM(1800, 300, 0),\n);\n\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(hpout_vol_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(-4800, 0, 0),\n\t1, 3, TLV_DB_SCALE_ITEM(-2400, 1200, 0),\n);\n\nstatic const char * const ng_type_txt[] =\n\t{ \"Constant PGA Gain\", \"Mute ADC Output\" };\nstatic const struct soc_enum ng_type =\n\tSOC_ENUM_SINGLE(ES8316_ADC_ALC_NG, 6, 2, ng_type_txt);\n\nstatic const char * const adcpol_txt[] = { \"Normal\", \"Invert\" };\nstatic const struct soc_enum adcpol =\n\tSOC_ENUM_SINGLE(ES8316_ADC_MUTE, 1, 2, adcpol_txt);\nstatic const char *const dacpol_txt[] =\n\t{ \"Normal\", \"R Invert\", \"L Invert\", \"L + R Invert\" };\nstatic const struct soc_enum dacpol =\n\tSOC_ENUM_SINGLE(ES8316_DAC_SET1, 0, 4, dacpol_txt);\n\nstatic const struct snd_kcontrol_new es8316_snd_controls[] = {\n\tSOC_DOUBLE_TLV(\"Headphone Playback Volume\", ES8316_CPHP_ICAL_VOL,\n\t\t       4, 0, 3, 1, hpout_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Mixer Volume\", ES8316_HPMIX_VOL,\n\t\t       4, 0, 11, 0, hpmixer_gain_tlv),\n\n\tSOC_ENUM(\"Playback Polarity\", dacpol),\n\tSOC_DOUBLE_R_TLV(\"DAC Playback Volume\", ES8316_DAC_VOLL,\n\t\t\t ES8316_DAC_VOLR, 0, 0xc0, 1, dac_vol_tlv),\n\tSOC_SINGLE(\"DAC Soft Ramp Switch\", ES8316_DAC_SET1, 4, 1, 1),\n\tSOC_SINGLE(\"DAC Soft Ramp Rate\", ES8316_DAC_SET1, 2, 4, 0),\n\tSOC_SINGLE(\"DAC Notch Filter Switch\", ES8316_DAC_SET2, 6, 1, 0),\n\tSOC_SINGLE(\"DAC Double Fs Switch\", ES8316_DAC_SET2, 7, 1, 0),\n\tSOC_SINGLE(\"DAC Stereo Enhancement\", ES8316_DAC_SET3, 0, 7, 0),\n\tSOC_SINGLE(\"DAC Mono Mix Switch\", ES8316_DAC_SET3, 3, 1, 0),\n\n\tSOC_ENUM(\"Capture Polarity\", adcpol),\n\tSOC_SINGLE(\"Mic Boost Switch\", ES8316_ADC_D2SEPGA, 0, 1, 0),\n\tSOC_SINGLE_TLV(\"ADC Capture Volume\", ES8316_ADC_VOLUME,\n\t\t       0, 0xc0, 1, adc_vol_tlv),\n\tSOC_SINGLE_TLV(\"ADC PGA Gain Volume\", ES8316_ADC_PGAGAIN,\n\t\t       4, 10, 0, adc_pga_gain_tlv),\n\tSOC_SINGLE(\"ADC Soft Ramp Switch\", ES8316_ADC_MUTE, 4, 1, 0),\n\tSOC_SINGLE(\"ADC Double Fs Switch\", ES8316_ADC_DMIC, 4, 1, 0),\n\n\tSOC_SINGLE(\"ALC Capture Switch\", ES8316_ADC_ALC1, 6, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Capture Max Volume\", ES8316_ADC_ALC1, 0, 28, 0,\n\t\t       alc_max_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Min Volume\", ES8316_ADC_ALC2, 0, 28, 0,\n\t\t       alc_min_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Target Volume\", ES8316_ADC_ALC3, 4, 11, 0,\n\t\t       alc_target_tlv),\n\tSOC_SINGLE(\"ALC Capture Hold Time\", ES8316_ADC_ALC3, 0, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Decay Time\", ES8316_ADC_ALC4, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Attack Time\", ES8316_ADC_ALC4, 0, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Switch\", ES8316_ADC_ALC_NG,\n\t\t   5, 1, 0),\n\tSOC_SINGLE(\"ALC Capture Noise Gate Threshold\", ES8316_ADC_ALC_NG,\n\t\t   0, 31, 0),\n\tSOC_ENUM(\"ALC Capture Noise Gate Type\", ng_type),\n};\n\n \nstatic const char * const es8316_analog_in_txt[] = {\n\t\t\"lin1-rin1\",\n\t\t\"lin2-rin2\",\n\t\t\"lin1-rin1 with 20db Boost\",\n\t\t\"lin2-rin2 with 20db Boost\"\n};\nstatic const unsigned int es8316_analog_in_values[] = { 0, 1, 2, 3 };\nstatic const struct soc_enum es8316_analog_input_enum =\n\tSOC_VALUE_ENUM_SINGLE(ES8316_ADC_PDN_LINSEL, 4, 3,\n\t\t\t      ARRAY_SIZE(es8316_analog_in_txt),\n\t\t\t      es8316_analog_in_txt,\n\t\t\t      es8316_analog_in_values);\nstatic const struct snd_kcontrol_new es8316_analog_in_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8316_analog_input_enum);\n\nstatic const char * const es8316_dmic_txt[] = {\n\t\t\"dmic disable\",\n\t\t\"dmic data at high level\",\n\t\t\"dmic data at low level\",\n};\nstatic const unsigned int es8316_dmic_values[] = { 0, 2, 3 };\nstatic const struct soc_enum es8316_dmic_src_enum =\n\tSOC_VALUE_ENUM_SINGLE(ES8316_ADC_DMIC, 0, 3,\n\t\t\t      ARRAY_SIZE(es8316_dmic_txt),\n\t\t\t      es8316_dmic_txt,\n\t\t\t      es8316_dmic_values);\nstatic const struct snd_kcontrol_new es8316_dmic_src_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8316_dmic_src_enum);\n\n \nstatic const char * const es8316_hpmux_texts[] = {\n\t\"lin1-rin1\",\n\t\"lin2-rin2\",\n\t\"lin-rin with Boost\",\n\t\"lin-rin with Boost and PGA\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(es8316_left_hpmux_enum, ES8316_HPMIX_SEL,\n\t4, es8316_hpmux_texts);\n\nstatic const struct snd_kcontrol_new es8316_left_hpmux_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8316_left_hpmux_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(es8316_right_hpmux_enum, ES8316_HPMIX_SEL,\n\t0, es8316_hpmux_texts);\n\nstatic const struct snd_kcontrol_new es8316_right_hpmux_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8316_right_hpmux_enum);\n\n \nstatic const struct snd_kcontrol_new es8316_out_left_mix[] = {\n\tSOC_DAPM_SINGLE(\"LLIN Switch\", ES8316_HPMIX_SWITCH, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left DAC Switch\", ES8316_HPMIX_SWITCH, 7, 1, 0),\n};\nstatic const struct snd_kcontrol_new es8316_out_right_mix[] = {\n\tSOC_DAPM_SINGLE(\"RLIN Switch\", ES8316_HPMIX_SWITCH, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC Switch\", ES8316_HPMIX_SWITCH, 3, 1, 0),\n};\n\n \nstatic const char * const es8316_dacsrc_texts[] = {\n\t\"LDATA TO LDAC, RDATA TO RDAC\",\n\t\"LDATA TO LDAC, LDATA TO RDAC\",\n\t\"RDATA TO LDAC, RDATA TO RDAC\",\n\t\"RDATA TO LDAC, LDATA TO RDAC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(es8316_dacsrc_mux_enum, ES8316_DAC_SET1,\n\t6, es8316_dacsrc_texts);\n\nstatic const struct snd_kcontrol_new es8316_dacsrc_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", es8316_dacsrc_mux_enum);\n\nstatic const struct snd_soc_dapm_widget es8316_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Bias\", ES8316_SYS_PDN, 3, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Analog power\", ES8316_SYS_PDN, 4, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", ES8316_SYS_PDN, 5, 1, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"DMIC\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Differential Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &es8316_analog_in_mux_controls),\n\n\tSND_SOC_DAPM_SUPPLY(\"ADC Vref\", ES8316_SYS_PDN, 1, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC bias\", ES8316_SYS_PDN, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC Clock\", ES8316_CLKMGR_CLKSW, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Line input PGA\", ES8316_ADC_PDN_LINSEL,\n\t\t\t 7, 1, NULL, 0),\n\tSND_SOC_DAPM_ADC(\"Mono ADC\", NULL, ES8316_ADC_PDN_LINSEL, 6, 1),\n\tSND_SOC_DAPM_MUX(\"Digital Mic Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &es8316_dmic_src_controls),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"I2S OUT\", \"I2S1 Capture\",  1,\n\t\t\t     ES8316_SERDATA_ADC, 6, 1),\n\tSND_SOC_DAPM_AIF_IN(\"I2S IN\", \"I2S1 Playback\", 0,\n\t\t\t    SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"DAC Source Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &es8316_dacsrc_mux_controls),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC Vref\", ES8316_SYS_PDN, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAC Clock\", ES8316_CLKMGR_CLKSW, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", NULL, ES8316_DAC_PDN, 0, 1),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", NULL, ES8316_DAC_PDN, 4, 1),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Left Headphone Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &es8316_left_hpmux_controls),\n\tSND_SOC_DAPM_MUX(\"Right Headphone Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &es8316_right_hpmux_controls),\n\tSND_SOC_DAPM_MIXER(\"Left Headphone Mixer\", ES8316_HPMIX_PDN,\n\t\t\t   5, 1, &es8316_out_left_mix[0],\n\t\t\t   ARRAY_SIZE(es8316_out_left_mix)),\n\tSND_SOC_DAPM_MIXER(\"Right Headphone Mixer\", ES8316_HPMIX_PDN,\n\t\t\t   1, 1, &es8316_out_right_mix[0],\n\t\t\t   ARRAY_SIZE(es8316_out_right_mix)),\n\tSND_SOC_DAPM_PGA(\"Left Headphone Mixer Out\", ES8316_HPMIX_PDN,\n\t\t\t 4, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Headphone Mixer Out\", ES8316_HPMIX_PDN,\n\t\t\t 0, 1, NULL, 0),\n\n\tSND_SOC_DAPM_OUT_DRV(\"Left Headphone Charge Pump\", ES8316_CPHP_OUTEN,\n\t\t\t     6, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Right Headphone Charge Pump\", ES8316_CPHP_OUTEN,\n\t\t\t     2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Charge Pump\", ES8316_CPHP_PDN2,\n\t\t\t    5, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Charge Pump Clock\", ES8316_CLKMGR_CLKSW,\n\t\t\t    4, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUT_DRV(\"Left Headphone Driver\", ES8316_CPHP_OUTEN,\n\t\t\t     5, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Right Headphone Driver\", ES8316_CPHP_OUTEN,\n\t\t\t     1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Out\", ES8316_CPHP_PDN1, 2, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Left Headphone ical\", ES8316_CPHP_ICAL_VOL,\n\t\t\t    7, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Right Headphone ical\", ES8316_CPHP_ICAL_VOL,\n\t\t\t    3, 1, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route es8316_dapm_routes[] = {\n\t \n\t{\"MIC1\", NULL, \"Mic Bias\"},\n\t{\"MIC2\", NULL, \"Mic Bias\"},\n\t{\"MIC1\", NULL, \"Bias\"},\n\t{\"MIC2\", NULL, \"Bias\"},\n\t{\"MIC1\", NULL, \"Analog power\"},\n\t{\"MIC2\", NULL, \"Analog power\"},\n\n\t{\"Differential Mux\", \"lin1-rin1\", \"MIC1\"},\n\t{\"Differential Mux\", \"lin2-rin2\", \"MIC2\"},\n\t{\"Line input PGA\", NULL, \"Differential Mux\"},\n\n\t{\"Mono ADC\", NULL, \"ADC Clock\"},\n\t{\"Mono ADC\", NULL, \"ADC Vref\"},\n\t{\"Mono ADC\", NULL, \"ADC bias\"},\n\t{\"Mono ADC\", NULL, \"Line input PGA\"},\n\n\t \n\t{\"Mono ADC\", NULL, \"DAC Clock\"},\n\n\t{\"Digital Mic Mux\", \"dmic disable\", \"Mono ADC\"},\n\n\t{\"I2S OUT\", NULL, \"Digital Mic Mux\"},\n\n\t \n\t{\"DAC Source Mux\", \"LDATA TO LDAC, RDATA TO RDAC\", \"I2S IN\"},\n\n\t{\"Left DAC\", NULL, \"DAC Clock\"},\n\t{\"Right DAC\", NULL, \"DAC Clock\"},\n\n\t{\"Left DAC\", NULL, \"DAC Vref\"},\n\t{\"Right DAC\", NULL, \"DAC Vref\"},\n\n\t{\"Left DAC\", NULL, \"DAC Source Mux\"},\n\t{\"Right DAC\", NULL, \"DAC Source Mux\"},\n\n\t{\"Left Headphone Mux\", \"lin-rin with Boost and PGA\", \"Line input PGA\"},\n\t{\"Right Headphone Mux\", \"lin-rin with Boost and PGA\", \"Line input PGA\"},\n\n\t{\"Left Headphone Mixer\", \"LLIN Switch\", \"Left Headphone Mux\"},\n\t{\"Left Headphone Mixer\", \"Left DAC Switch\", \"Left DAC\"},\n\n\t{\"Right Headphone Mixer\", \"RLIN Switch\", \"Right Headphone Mux\"},\n\t{\"Right Headphone Mixer\", \"Right DAC Switch\", \"Right DAC\"},\n\n\t{\"Left Headphone Mixer Out\", NULL, \"Left Headphone Mixer\"},\n\t{\"Right Headphone Mixer Out\", NULL, \"Right Headphone Mixer\"},\n\n\t{\"Left Headphone Charge Pump\", NULL, \"Left Headphone Mixer Out\"},\n\t{\"Right Headphone Charge Pump\", NULL, \"Right Headphone Mixer Out\"},\n\n\t{\"Left Headphone Charge Pump\", NULL, \"Headphone Charge Pump\"},\n\t{\"Right Headphone Charge Pump\", NULL, \"Headphone Charge Pump\"},\n\n\t{\"Left Headphone Charge Pump\", NULL, \"Headphone Charge Pump Clock\"},\n\t{\"Right Headphone Charge Pump\", NULL, \"Headphone Charge Pump Clock\"},\n\n\t{\"Left Headphone Driver\", NULL, \"Left Headphone Charge Pump\"},\n\t{\"Right Headphone Driver\", NULL, \"Right Headphone Charge Pump\"},\n\n\t{\"HPOL\", NULL, \"Left Headphone Driver\"},\n\t{\"HPOR\", NULL, \"Right Headphone Driver\"},\n\n\t{\"HPOL\", NULL, \"Left Headphone ical\"},\n\t{\"HPOR\", NULL, \"Right Headphone ical\"},\n\n\t{\"Headphone Out\", NULL, \"Bias\"},\n\t{\"Headphone Out\", NULL, \"Analog power\"},\n\t{\"HPOL\", NULL, \"Headphone Out\"},\n\t{\"HPOR\", NULL, \"Headphone Out\"},\n};\n\nstatic int es8316_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\tint i, ret;\n\tint count = 0;\n\n\tes8316->sysclk = freq;\n\tes8316->sysclk_constraints.list = NULL;\n\tes8316->sysclk_constraints.count = 0;\n\n\tif (freq == 0)\n\t\treturn 0;\n\n\tret = clk_set_rate(es8316->mclk, freq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < NR_SUPPORTED_MCLK_LRCK_RATIOS; i++) {\n\t\tconst unsigned int ratio = supported_mclk_lrck_ratios[i];\n\n\t\tif (freq % ratio == 0)\n\t\t\tes8316->allowed_rates[count++] = freq / ratio;\n\t}\n\n\tif (count) {\n\t\tes8316->sysclk_constraints.list = es8316->allowed_rates;\n\t\tes8316->sysclk_constraints.count = count;\n\t}\n\n\treturn 0;\n}\n\nstatic int es8316_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 serdata1 = 0;\n\tu8 serdata2 = 0;\n\tu8 clksw;\n\tu8 mask;\n\n\tif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) == SND_SOC_DAIFMT_CBP_CFP)\n\t\tserdata1 |= ES8316_SERDATA1_MASTER;\n\n\tif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) != SND_SOC_DAIFMT_I2S) {\n\t\tdev_err(component->dev, \"Codec driver only supports I2S format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tserdata1 |= ES8316_SERDATA1_BCLK_INV;\n\t\tserdata2 |= ES8316_SERDATA2_ADCLRP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tserdata1 |= ES8316_SERDATA1_BCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tserdata2 |= ES8316_SERDATA2_ADCLRP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmask = ES8316_SERDATA1_MASTER | ES8316_SERDATA1_BCLK_INV;\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA1, mask, serdata1);\n\n\tmask = ES8316_SERDATA2_FMT_MASK | ES8316_SERDATA2_ADCLRP;\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA_ADC, mask, serdata2);\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA_DAC, mask, serdata2);\n\n\t \n\tclksw = ES8316_CLKMGR_CLKSW_MCLK_ON | ES8316_CLKMGR_CLKSW_BCLK_ON;\n\tsnd_soc_component_update_bits(component, ES8316_CLKMGR_CLKSW, clksw, clksw);\n\n\treturn 0;\n}\n\nstatic int es8316_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\tif (es8316->sysclk_constraints.list)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t   &es8316->sysclk_constraints);\n\n\treturn 0;\n}\n\nstatic int es8316_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\tu8 wordlen = 0;\n\tu8 bclk_divider;\n\tu16 lrck_divider;\n\tint i;\n\n\t \n\tfor (i = 0; i < NR_SUPPORTED_MCLK_LRCK_RATIOS; i++) {\n\t\tconst unsigned int ratio = supported_mclk_lrck_ratios[i];\n\n\t\tif (es8316->sysclk % ratio != 0)\n\t\t\tcontinue;\n\t\tif (es8316->sysclk / ratio == params_rate(params))\n\t\t\tbreak;\n\t}\n\tif (i == NR_SUPPORTED_MCLK_LRCK_RATIOS)\n\t\treturn -EINVAL;\n\tlrck_divider = es8316->sysclk / params_rate(params);\n\tbclk_divider = lrck_divider / 4;\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\twordlen = ES8316_SERDATA2_LEN_16;\n\t\tbclk_divider /= 16;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\twordlen = ES8316_SERDATA2_LEN_20;\n\t\tbclk_divider /= 20;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\twordlen = ES8316_SERDATA2_LEN_24;\n\t\tbclk_divider /= 24;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\twordlen = ES8316_SERDATA2_LEN_32;\n\t\tbclk_divider /= 32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA_DAC,\n\t\t\t    ES8316_SERDATA2_LEN_MASK, wordlen);\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA_ADC,\n\t\t\t    ES8316_SERDATA2_LEN_MASK, wordlen);\n\tsnd_soc_component_update_bits(component, ES8316_SERDATA1, 0x1f, bclk_divider);\n\tsnd_soc_component_update_bits(component, ES8316_CLKMGR_ADCDIV1, 0x0f, lrck_divider >> 8);\n\tsnd_soc_component_update_bits(component, ES8316_CLKMGR_ADCDIV2, 0xff, lrck_divider & 0xff);\n\tsnd_soc_component_update_bits(component, ES8316_CLKMGR_DACDIV1, 0x0f, lrck_divider >> 8);\n\tsnd_soc_component_update_bits(component, ES8316_CLKMGR_DACDIV2, 0xff, lrck_divider & 0xff);\n\treturn 0;\n}\n\nstatic int es8316_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tsnd_soc_component_update_bits(dai->component, ES8316_DAC_SET1, 0x20,\n\t\t\t    mute ? 0x20 : 0);\n\treturn 0;\n}\n\n#define ES8316_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops es8316_ops = {\n\t.startup = es8316_pcm_startup,\n\t.hw_params = es8316_pcm_hw_params,\n\t.set_fmt = es8316_set_dai_fmt,\n\t.set_sysclk = es8316_set_dai_sysclk,\n\t.mute_stream = es8316_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver es8316_dai = {\n\t.name = \"ES8316 HiFi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = ES8316_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = ES8316_FORMATS,\n\t},\n\t.ops = &es8316_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic void es8316_enable_micbias_for_mic_gnd_short_detect(\n\tstruct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"Bias\");\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"Analog power\");\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"Mic Bias\");\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\tmsleep(20);\n}\n\nstatic void es8316_disable_micbias_for_mic_gnd_short_detect(\n\tstruct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Mic Bias\");\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Analog power\");\n\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"Bias\");\n\tsnd_soc_dapm_sync_unlocked(dapm);\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\nstatic irqreturn_t es8316_irq(int irq, void *data)\n{\n\tstruct es8316_priv *es8316 = data;\n\tstruct snd_soc_component *comp = es8316->component;\n\tunsigned int flags;\n\n\tmutex_lock(&es8316->lock);\n\n\tregmap_read(es8316->regmap, ES8316_GPIO_FLAG, &flags);\n\tif (flags == 0x00)\n\t\tgoto out;  \n\n\t \n\tif (!es8316->jack)\n\t\tgoto out;\n\n\tif (es8316->jd_inverted)\n\t\tflags ^= ES8316_GPIO_FLAG_HP_NOT_INSERTED;\n\n\tdev_dbg(comp->dev, \"gpio flags %#04x\\n\", flags);\n\tif (flags & ES8316_GPIO_FLAG_HP_NOT_INSERTED) {\n\t\t \n\t\tif (es8316->jack->status & SND_JACK_MICROPHONE)\n\t\t\tes8316_disable_micbias_for_mic_gnd_short_detect(comp);\n\n\t\tif (es8316->jack->status & SND_JACK_HEADPHONE) {\n\t\t\tsnd_soc_jack_report(es8316->jack, 0,\n\t\t\t\t\t    SND_JACK_HEADSET | SND_JACK_BTN_0);\n\t\t\tdev_dbg(comp->dev, \"jack unplugged\\n\");\n\t\t}\n\t} else if (!(es8316->jack->status & SND_JACK_HEADPHONE)) {\n\t\t \n\t\tes8316_enable_micbias_for_mic_gnd_short_detect(comp);\n\t\tregmap_read(es8316->regmap, ES8316_GPIO_FLAG, &flags);\n\t\tif (es8316->jd_inverted)\n\t\t\tflags ^= ES8316_GPIO_FLAG_HP_NOT_INSERTED;\n\t\tdev_dbg(comp->dev, \"gpio flags %#04x\\n\", flags);\n\t\tif (flags & ES8316_GPIO_FLAG_HP_NOT_INSERTED) {\n\t\t\t \n\t\t\tes8316_disable_micbias_for_mic_gnd_short_detect(comp);\n\t\t} else if (flags & ES8316_GPIO_FLAG_GM_NOT_SHORTED) {\n\t\t\t \n\t\t\tsnd_soc_jack_report(es8316->jack,\n\t\t\t\t\t    SND_JACK_HEADSET,\n\t\t\t\t\t    SND_JACK_HEADSET);\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tsnd_soc_jack_report(es8316->jack,\n\t\t\t\t\t    SND_JACK_HEADPHONE,\n\t\t\t\t\t    SND_JACK_HEADSET);\n\t\t\t \n\t\t\tes8316_disable_micbias_for_mic_gnd_short_detect(comp);\n\t\t}\n\t} else if (es8316->jack->status & SND_JACK_MICROPHONE) {\n\t\t \n\t\tif (flags & ES8316_GPIO_FLAG_GM_NOT_SHORTED) {\n\t\t\t \n\t\t\tsnd_soc_jack_report(es8316->jack, 0, SND_JACK_BTN_0);\n\t\t} else {\n\t\t\t \n\t\t\tsnd_soc_jack_report(es8316->jack,\n\t\t\t\t\t    SND_JACK_BTN_0,\n\t\t\t\t\t    SND_JACK_BTN_0);\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&es8316->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void es8316_enable_jack_detect(struct snd_soc_component *component,\n\t\t\t\t      struct snd_soc_jack *jack)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\t \n\tes8316->jd_inverted = device_property_read_bool(component->dev,\n\t\t\t\t\t\t\t\"everest,jack-detect-inverted\");\n\n\tmutex_lock(&es8316->lock);\n\n\tes8316->jack = jack;\n\n\tif (es8316->jack->status & SND_JACK_MICROPHONE)\n\t\tes8316_enable_micbias_for_mic_gnd_short_detect(component);\n\n\tsnd_soc_component_update_bits(component, ES8316_GPIO_DEBOUNCE,\n\t\t\t\t      ES8316_GPIO_ENABLE_INTERRUPT,\n\t\t\t\t      ES8316_GPIO_ENABLE_INTERRUPT);\n\n\tmutex_unlock(&es8316->lock);\n\n\t \n\tenable_irq(es8316->irq);\n\tes8316_irq(es8316->irq, es8316);\n}\n\nstatic void es8316_disable_jack_detect(struct snd_soc_component *component)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\tif (!es8316->jack)\n\t\treturn;  \n\n\tdisable_irq(es8316->irq);\n\n\tmutex_lock(&es8316->lock);\n\n\tsnd_soc_component_update_bits(component, ES8316_GPIO_DEBOUNCE,\n\t\t\t\t      ES8316_GPIO_ENABLE_INTERRUPT, 0);\n\n\tif (es8316->jack->status & SND_JACK_MICROPHONE) {\n\t\tes8316_disable_micbias_for_mic_gnd_short_detect(component);\n\t\tsnd_soc_jack_report(es8316->jack, 0, SND_JACK_BTN_0);\n\t}\n\n\tes8316->jack = NULL;\n\n\tmutex_unlock(&es8316->lock);\n}\n\nstatic int es8316_set_jack(struct snd_soc_component *component,\n\t\t\t   struct snd_soc_jack *jack, void *data)\n{\n\tif (jack)\n\t\tes8316_enable_jack_detect(component, jack);\n\telse\n\t\tes8316_disable_jack_detect(component);\n\n\treturn 0;\n}\n\nstatic int es8316_probe(struct snd_soc_component *component)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tes8316->component = component;\n\n\tes8316->mclk = devm_clk_get_optional(component->dev, \"mclk\");\n\tif (IS_ERR(es8316->mclk)) {\n\t\tdev_err(component->dev, \"unable to get mclk\\n\");\n\t\treturn PTR_ERR(es8316->mclk);\n\t}\n\tif (!es8316->mclk)\n\t\tdev_warn(component->dev, \"assuming static mclk\\n\");\n\n\tret = clk_prepare_enable(es8316->mclk);\n\tif (ret) {\n\t\tdev_err(component->dev, \"unable to enable mclk\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_soc_component_write(component, ES8316_RESET, 0x3f);\n\tusleep_range(5000, 5500);\n\tsnd_soc_component_write(component, ES8316_RESET, ES8316_RESET_CSM_ON);\n\tmsleep(30);\n\n\t \n\tsnd_soc_component_write(component, ES8316_SYS_VMIDSEL, 0xff);\n\n\t \n\tsnd_soc_component_write(component, ES8316_CLKMGR_ADCOSR, 0x32);\n\n\treturn 0;\n}\n\nstatic void es8316_remove(struct snd_soc_component *component)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\tclk_disable_unprepare(es8316->mclk);\n}\n\nstatic int es8316_resume(struct snd_soc_component *component)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(es8316->regmap, false);\n\tregcache_sync(es8316->regmap);\n\n\treturn 0;\n}\n\nstatic int es8316_suspend(struct snd_soc_component *component)\n{\n\tstruct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(es8316->regmap, true);\n\tregcache_mark_dirty(es8316->regmap);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_es8316 = {\n\t.probe\t\t\t= es8316_probe,\n\t.remove\t\t\t= es8316_remove,\n\t.resume\t\t\t= es8316_resume,\n\t.suspend\t\t= es8316_suspend,\n\t.set_jack\t\t= es8316_set_jack,\n\t.controls\t\t= es8316_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(es8316_snd_controls),\n\t.dapm_widgets\t\t= es8316_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(es8316_dapm_widgets),\n\t.dapm_routes\t\t= es8316_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(es8316_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic bool es8316_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase ES8316_GPIO_FLAG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config es8316_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.max_register = 0x53,\n\t.volatile_reg = es8316_volatile_reg,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int es8316_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct device *dev = &i2c_client->dev;\n\tstruct es8316_priv *es8316;\n\tint ret;\n\n\tes8316 = devm_kzalloc(&i2c_client->dev, sizeof(struct es8316_priv),\n\t\t\t      GFP_KERNEL);\n\tif (es8316 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c_client, es8316);\n\n\tes8316->regmap = devm_regmap_init_i2c(i2c_client, &es8316_regmap);\n\tif (IS_ERR(es8316->regmap))\n\t\treturn PTR_ERR(es8316->regmap);\n\n\tes8316->irq = i2c_client->irq;\n\tmutex_init(&es8316->lock);\n\n\tif (es8316->irq > 0) {\n\t\tret = devm_request_threaded_irq(dev, es8316->irq, NULL, es8316_irq,\n\t\t\t\t\t\tIRQF_TRIGGER_HIGH | IRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t\t\"es8316\", es8316);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to get IRQ %d: %d\\n\", es8316->irq, ret);\n\t\t\tes8316->irq = -ENXIO;\n\t\t}\n\t}\n\n\treturn devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t\t      &soc_component_dev_es8316,\n\t\t\t\t      &es8316_dai, 1);\n}\n\nstatic const struct i2c_device_id es8316_i2c_id[] = {\n\t{\"es8316\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, es8316_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id es8316_of_match[] = {\n\t{ .compatible = \"everest,es8316\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, es8316_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id es8316_acpi_match[] = {\n\t{\"ESSX8316\", 0},\n\t{\"ESSX8336\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, es8316_acpi_match);\n#endif\n\nstatic struct i2c_driver es8316_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"es8316\",\n\t\t.acpi_match_table\t= ACPI_PTR(es8316_acpi_match),\n\t\t.of_match_table\t\t= of_match_ptr(es8316_of_match),\n\t},\n\t.probe\t\t= es8316_i2c_probe,\n\t.id_table\t= es8316_i2c_id,\n};\nmodule_i2c_driver(es8316_i2c_driver);\n\nMODULE_DESCRIPTION(\"Everest Semi ES8316 ALSA SoC Codec Driver\");\nMODULE_AUTHOR(\"David Yang <yangxiaohua@everest-semi.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}