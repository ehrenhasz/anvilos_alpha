{
  "module_name": "cs35l45.c",
  "hash_id": "1b937b31f6d254cb4356b6fdcb5abe2a973d32e7b97d19607db8b13c83f359e0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l45.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/firmware.h>\n#include <linux/regulator/consumer.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"cs35l45.h\"\n\nstatic bool cs35l45_check_cspl_mbox_sts(const enum cs35l45_cspl_mboxcmd cmd,\n\t\t\t\t\tenum cs35l45_cspl_mboxstate sts)\n{\n\tswitch (cmd) {\n\tcase CSPL_MBOX_CMD_NONE:\n\tcase CSPL_MBOX_CMD_UNKNOWN_CMD:\n\t\treturn true;\n\tcase CSPL_MBOX_CMD_PAUSE:\n\tcase CSPL_MBOX_CMD_OUT_OF_HIBERNATE:\n\t\treturn (sts == CSPL_MBOX_STS_PAUSED);\n\tcase CSPL_MBOX_CMD_RESUME:\n\t\treturn (sts == CSPL_MBOX_STS_RUNNING);\n\tcase CSPL_MBOX_CMD_REINIT:\n\t\treturn (sts == CSPL_MBOX_STS_RUNNING);\n\tcase CSPL_MBOX_CMD_STOP_PRE_REINIT:\n\t\treturn (sts == CSPL_MBOX_STS_RDY_FOR_REINIT);\n\tcase CSPL_MBOX_CMD_HIBERNATE:\n\t\treturn (sts == CSPL_MBOX_STS_HIBERNATE);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int cs35l45_set_cspl_mbox_cmd(struct cs35l45_private *cs35l45,\n\t\t\t\t      struct regmap *regmap,\n\t\t\t\t      const enum cs35l45_cspl_mboxcmd cmd)\n{\n\tunsigned int sts = 0, i;\n\tint ret;\n\n\tif (!cs35l45->dsp.cs_dsp.running) {\n\t\tdev_err(cs35l45->dev, \"DSP not running\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t\n\tret = regmap_write(regmap, CS35L45_DSP_VIRT1_MBOX_1, cmd);\n\tif (ret < 0) {\n\t\tif (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)\n\t\t\tdev_err(cs35l45->dev, \"Failed to write MBOX: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t\n\tfor (i = 0; i < 5; i++) {\n\t\tusleep_range(1000, 1100);\n\n\t\tret = regmap_read(regmap, CS35L45_DSP_MBOX_2, &sts);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cs35l45->dev, \"Failed to read MBOX STS: %d\\n\", ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cs35l45_check_cspl_mbox_sts(cmd, sts))\n\t\t\tdev_dbg(cs35l45->dev, \"[%u] cmd %u returned invalid sts %u\", i, cmd, sts);\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)\n\t\tdev_err(cs35l45->dev, \"Failed to set mailbox cmd %u (status %u)\\n\", cmd, sts);\n\n\treturn -ENOMSG;\n}\n\nstatic int cs35l45_global_en_ev(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(cs35l45->dev, \"%s event : %x\\n\", __func__, event);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(cs35l45->regmap, CS35L45_GLOBAL_ENABLES,\n\t\t\t     CS35L45_GLOBAL_EN_MASK);\n\n\t\tusleep_range(CS35L45_POST_GLOBAL_EN_US, CS35L45_POST_GLOBAL_EN_US + 100);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tusleep_range(CS35L45_PRE_GLOBAL_DIS_US, CS35L45_PRE_GLOBAL_DIS_US + 100);\n\n\t\tregmap_write(cs35l45->regmap, CS35L45_GLOBAL_ENABLES, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l45_dsp_preload_ev(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (cs35l45->dsp.cs_dsp.booted)\n\t\t\treturn 0;\n\n\t\treturn wm_adsp_early_event(w, kcontrol, event);\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (cs35l45->dsp.cs_dsp.running)\n\t\t\treturn 0;\n\n\t\tregmap_set_bits(cs35l45->regmap, CS35L45_PWRMGT_CTL,\n\t\t\t\t   CS35L45_MEM_RDY_MASK);\n\n\t\treturn wm_adsp_event(w, kcontrol, event);\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tif (cs35l45->dsp.preloaded)\n\t\t\treturn 0;\n\n\t\tif (cs35l45->dsp.cs_dsp.running) {\n\t\t\tret = wm_adsp_event(w, kcontrol, event);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn wm_adsp_early_event(w, kcontrol, event);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int cs35l45_dsp_audio_ev(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\treturn cs35l45_set_cspl_mbox_cmd(cs35l45, cs35l45->regmap,\n\t\t\t\t\t\t CSPL_MBOX_CMD_RESUME);\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\treturn cs35l45_set_cspl_mbox_cmd(cs35l45, cs35l45->regmap,\n\t\t\t\t\t\t CSPL_MBOX_CMD_PAUSE);\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const cs35l45_asp_tx_txt[] = {\n\t\"Zero\", \"ASP_RX1\", \"ASP_RX2\",\n\t\"VMON\", \"IMON\", \"ERR_VOL\",\n\t\"VDD_BATTMON\", \"VDD_BSTMON\",\n\t\"DSP_TX1\", \"DSP_TX2\",\n\t\"Interpolator\", \"IL_TARGET\",\n};\n\nstatic const unsigned int cs35l45_asp_tx_val[] = {\n\tCS35L45_PCM_SRC_ZERO, CS35L45_PCM_SRC_ASP_RX1, CS35L45_PCM_SRC_ASP_RX2,\n\tCS35L45_PCM_SRC_VMON, CS35L45_PCM_SRC_IMON, CS35L45_PCM_SRC_ERR_VOL,\n\tCS35L45_PCM_SRC_VDD_BATTMON, CS35L45_PCM_SRC_VDD_BSTMON,\n\tCS35L45_PCM_SRC_DSP_TX1, CS35L45_PCM_SRC_DSP_TX2,\n\tCS35L45_PCM_SRC_INTERPOLATOR, CS35L45_PCM_SRC_IL_TARGET,\n};\n\nstatic const struct soc_enum cs35l45_asp_tx_enums[] = {\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_ASPTX1_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_asp_tx_txt), cs35l45_asp_tx_txt,\n\t\t\t      cs35l45_asp_tx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_ASPTX2_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_asp_tx_txt), cs35l45_asp_tx_txt,\n\t\t\t      cs35l45_asp_tx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_ASPTX3_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_asp_tx_txt), cs35l45_asp_tx_txt,\n\t\t\t      cs35l45_asp_tx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_ASPTX4_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_asp_tx_txt), cs35l45_asp_tx_txt,\n\t\t\t      cs35l45_asp_tx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_ASPTX5_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_asp_tx_txt), cs35l45_asp_tx_txt,\n\t\t\t      cs35l45_asp_tx_val),\n};\n\nstatic const char * const cs35l45_dsp_rx_txt[] = {\n\t\"Zero\", \"ASP_RX1\", \"ASP_RX2\",\n\t\"VMON\", \"IMON\", \"ERR_VOL\",\n\t\"CLASSH_TGT\", \"VDD_BATTMON\",\n\t\"VDD_BSTMON\", \"TEMPMON\",\n};\n\nstatic const unsigned int cs35l45_dsp_rx_val[] = {\n\tCS35L45_PCM_SRC_ZERO, CS35L45_PCM_SRC_ASP_RX1, CS35L45_PCM_SRC_ASP_RX2,\n\tCS35L45_PCM_SRC_VMON, CS35L45_PCM_SRC_IMON, CS35L45_PCM_SRC_ERR_VOL,\n\tCS35L45_PCM_SRC_CLASSH_TGT, CS35L45_PCM_SRC_VDD_BATTMON,\n\tCS35L45_PCM_SRC_VDD_BSTMON, CS35L45_PCM_SRC_TEMPMON,\n};\n\nstatic const struct soc_enum cs35l45_dsp_rx_enums[] = {\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX1_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX2_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX3_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX4_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX5_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX6_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX7_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DSP1RX8_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dsp_rx_txt), cs35l45_dsp_rx_txt,\n\t\t\t      cs35l45_dsp_rx_val),\n};\n\nstatic const char * const cs35l45_dac_txt[] = {\n\t\"Zero\", \"ASP_RX1\", \"ASP_RX2\", \"DSP_TX1\", \"DSP_TX2\"\n};\n\nstatic const unsigned int cs35l45_dac_val[] = {\n\tCS35L45_PCM_SRC_ZERO, CS35L45_PCM_SRC_ASP_RX1, CS35L45_PCM_SRC_ASP_RX2,\n\tCS35L45_PCM_SRC_DSP_TX1, CS35L45_PCM_SRC_DSP_TX2\n};\n\nstatic const struct soc_enum cs35l45_dacpcm_enums[] = {\n\tSOC_VALUE_ENUM_SINGLE(CS35L45_DACPCM1_INPUT, 0, CS35L45_PCM_SRC_MASK,\n\t\t\t      ARRAY_SIZE(cs35l45_dac_txt), cs35l45_dac_txt,\n\t\t\t      cs35l45_dac_val),\n};\n\nstatic const struct snd_kcontrol_new cs35l45_asp_muxes[] = {\n\tSOC_DAPM_ENUM(\"ASP_TX1 Source\", cs35l45_asp_tx_enums[0]),\n\tSOC_DAPM_ENUM(\"ASP_TX2 Source\", cs35l45_asp_tx_enums[1]),\n\tSOC_DAPM_ENUM(\"ASP_TX3 Source\", cs35l45_asp_tx_enums[2]),\n\tSOC_DAPM_ENUM(\"ASP_TX4 Source\", cs35l45_asp_tx_enums[3]),\n\tSOC_DAPM_ENUM(\"ASP_TX5 Source\", cs35l45_asp_tx_enums[4]),\n};\n\nstatic const struct snd_kcontrol_new cs35l45_dsp_muxes[] = {\n\tSOC_DAPM_ENUM(\"DSP_RX1 Source\", cs35l45_dsp_rx_enums[0]),\n\tSOC_DAPM_ENUM(\"DSP_RX2 Source\", cs35l45_dsp_rx_enums[1]),\n\tSOC_DAPM_ENUM(\"DSP_RX3 Source\", cs35l45_dsp_rx_enums[2]),\n\tSOC_DAPM_ENUM(\"DSP_RX4 Source\", cs35l45_dsp_rx_enums[3]),\n\tSOC_DAPM_ENUM(\"DSP_RX5 Source\", cs35l45_dsp_rx_enums[4]),\n\tSOC_DAPM_ENUM(\"DSP_RX6 Source\", cs35l45_dsp_rx_enums[5]),\n\tSOC_DAPM_ENUM(\"DSP_RX7 Source\", cs35l45_dsp_rx_enums[6]),\n\tSOC_DAPM_ENUM(\"DSP_RX8 Source\", cs35l45_dsp_rx_enums[7]),\n};\n\nstatic const struct snd_kcontrol_new cs35l45_dac_muxes[] = {\n\tSOC_DAPM_ENUM(\"DACPCM Source\", cs35l45_dacpcm_enums[0]),\n};\n\nstatic const struct snd_soc_dapm_widget cs35l45_dapm_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"DSP1 Preload\", NULL),\n\tSND_SOC_DAPM_SUPPLY_S(\"DSP1 Preloader\", 100, SND_SOC_NOPM, 0, 0,\n\t\t\t\tcs35l45_dsp_preload_ev,\n\t\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUT_DRV_E(\"DSP1\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t\tcs35l45_dsp_audio_ev,\n\t\t\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"GLOBAL_EN\", SND_SOC_NOPM, 0, 0,\n\t\t\t    cs35l45_global_en_ev,\n\t\t\t    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"ASP_EN\", CS35L45_BLOCK_ENABLES2, CS35L45_ASP_EN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SIGGEN(\"VMON_SRC\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON_SRC\"),\n\tSND_SOC_DAPM_SIGGEN(\"VDD_BATTMON_SRC\"),\n\tSND_SOC_DAPM_SIGGEN(\"VDD_BSTMON_SRC\"),\n\tSND_SOC_DAPM_SIGGEN(\"ERR_VOL\"),\n\tSND_SOC_DAPM_SIGGEN(\"AMP_INTP\"),\n\tSND_SOC_DAPM_SIGGEN(\"IL_TARGET\"),\n\tSND_SOC_DAPM_ADC(\"VMON\", NULL, CS35L45_BLOCK_ENABLES, CS35L45_VMON_EN_SHIFT, 0),\n\tSND_SOC_DAPM_ADC(\"IMON\", NULL, CS35L45_BLOCK_ENABLES, CS35L45_IMON_EN_SHIFT, 0),\n\tSND_SOC_DAPM_ADC(\"VDD_BATTMON\", NULL, CS35L45_BLOCK_ENABLES,\n\t\t\t CS35L45_VDD_BATTMON_EN_SHIFT, 0),\n\tSND_SOC_DAPM_ADC(\"VDD_BSTMON\", NULL, CS35L45_BLOCK_ENABLES,\n\t\t\t CS35L45_VDD_BSTMON_EN_SHIFT, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"ASP_RX1\", NULL, 0, CS35L45_ASP_ENABLES1, CS35L45_ASP_RX1_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_IN(\"ASP_RX2\", NULL, 1, CS35L45_ASP_ENABLES1, CS35L45_ASP_RX2_EN_SHIFT, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_TX1\", NULL, 0, CS35L45_ASP_ENABLES1, CS35L45_ASP_TX1_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_TX2\", NULL, 1, CS35L45_ASP_ENABLES1, CS35L45_ASP_TX2_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_TX3\", NULL, 2, CS35L45_ASP_ENABLES1, CS35L45_ASP_TX3_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_TX4\", NULL, 3, CS35L45_ASP_ENABLES1, CS35L45_ASP_TX4_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_TX5\", NULL, 3, CS35L45_ASP_ENABLES1, CS35L45_ASP_TX5_EN_SHIFT, 0),\n\n\tSND_SOC_DAPM_MUX(\"ASP_TX1 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_asp_muxes[0]),\n\tSND_SOC_DAPM_MUX(\"ASP_TX2 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_asp_muxes[1]),\n\tSND_SOC_DAPM_MUX(\"ASP_TX3 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_asp_muxes[2]),\n\tSND_SOC_DAPM_MUX(\"ASP_TX4 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_asp_muxes[3]),\n\tSND_SOC_DAPM_MUX(\"ASP_TX5 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_asp_muxes[4]),\n\n\tSND_SOC_DAPM_MUX(\"DSP_RX1 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[0]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX2 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[1]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX3 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[2]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX4 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[3]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX5 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[4]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX6 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[5]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX7 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[6]),\n\tSND_SOC_DAPM_MUX(\"DSP_RX8 Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dsp_muxes[7]),\n\n\tSND_SOC_DAPM_MUX(\"DACPCM Source\", SND_SOC_NOPM, 0, 0, &cs35l45_dac_muxes[0]),\n\n\tSND_SOC_DAPM_OUT_DRV(\"AMP\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n};\n\n#define CS35L45_ASP_MUX_ROUTE(name) \\\n\t{ name\" Source\", \"ASP_RX1\",\t \"ASP_RX1\" }, \\\n\t{ name\" Source\", \"ASP_RX2\",\t \"ASP_RX2\" }, \\\n\t{ name\" Source\", \"DSP_TX1\",\t \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP_TX2\",\t \"DSP1\" }, \\\n\t{ name\" Source\", \"VMON\",\t \"VMON\" }, \\\n\t{ name\" Source\", \"IMON\",\t \"IMON\" }, \\\n\t{ name\" Source\", \"ERR_VOL\",\t \"ERR_VOL\" }, \\\n\t{ name\" Source\", \"VDD_BATTMON\",\t \"VDD_BATTMON\" }, \\\n\t{ name\" Source\", \"VDD_BSTMON\",\t \"VDD_BSTMON\" }, \\\n\t{ name\" Source\", \"Interpolator\", \"AMP_INTP\" }, \\\n\t{ name\" Source\", \"IL_TARGET\",\t \"IL_TARGET\" }\n\n#define CS35L45_DSP_MUX_ROUTE(name) \\\n\t{ name\" Source\", \"ASP_RX1\",\t\"ASP_RX1\" }, \\\n\t{ name\" Source\", \"ASP_RX2\",\t\"ASP_RX2\" }\n\n#define CS35L45_DAC_MUX_ROUTE(name) \\\n\t{ name\" Source\", \"ASP_RX1\",\t\"ASP_RX1\" }, \\\n\t{ name\" Source\", \"ASP_RX2\",\t\"ASP_RX2\" }, \\\n\t{ name\" Source\", \"DSP_TX1\",\t\"DSP1\" }, \\\n\t{ name\" Source\", \"DSP_TX2\",\t\"DSP1\" }\n\nstatic const struct snd_soc_dapm_route cs35l45_dapm_routes[] = {\n\t \n\t{ \"VMON\", NULL, \"VMON_SRC\" },\n\t{ \"IMON\", NULL, \"IMON_SRC\" },\n\t{ \"VDD_BATTMON\", NULL, \"VDD_BATTMON_SRC\" },\n\t{ \"VDD_BSTMON\", NULL, \"VDD_BSTMON_SRC\" },\n\n\t{ \"Capture\", NULL, \"ASP_TX1\"},\n\t{ \"Capture\", NULL, \"ASP_TX2\"},\n\t{ \"Capture\", NULL, \"ASP_TX3\"},\n\t{ \"Capture\", NULL, \"ASP_TX4\"},\n\t{ \"Capture\", NULL, \"ASP_TX5\"},\n\t{ \"ASP_TX1\", NULL, \"ASP_TX1 Source\"},\n\t{ \"ASP_TX2\", NULL, \"ASP_TX2 Source\"},\n\t{ \"ASP_TX3\", NULL, \"ASP_TX3 Source\"},\n\t{ \"ASP_TX4\", NULL, \"ASP_TX4 Source\"},\n\t{ \"ASP_TX5\", NULL, \"ASP_TX5 Source\"},\n\n\t{ \"ASP_TX1\", NULL, \"ASP_EN\" },\n\t{ \"ASP_TX2\", NULL, \"ASP_EN\" },\n\t{ \"ASP_TX3\", NULL, \"ASP_EN\" },\n\t{ \"ASP_TX4\", NULL, \"ASP_EN\" },\n\t{ \"ASP_TX1\", NULL, \"GLOBAL_EN\" },\n\t{ \"ASP_TX2\", NULL, \"GLOBAL_EN\" },\n\t{ \"ASP_TX3\", NULL, \"GLOBAL_EN\" },\n\t{ \"ASP_TX4\", NULL, \"GLOBAL_EN\" },\n\t{ \"ASP_TX5\", NULL, \"GLOBAL_EN\" },\n\n\tCS35L45_ASP_MUX_ROUTE(\"ASP_TX1\"),\n\tCS35L45_ASP_MUX_ROUTE(\"ASP_TX2\"),\n\tCS35L45_ASP_MUX_ROUTE(\"ASP_TX3\"),\n\tCS35L45_ASP_MUX_ROUTE(\"ASP_TX4\"),\n\tCS35L45_ASP_MUX_ROUTE(\"ASP_TX5\"),\n\n\t \n\t{ \"ASP_RX1\", NULL, \"Playback\" },\n\t{ \"ASP_RX2\", NULL, \"Playback\" },\n\t{ \"ASP_RX1\", NULL, \"ASP_EN\" },\n\t{ \"ASP_RX2\", NULL, \"ASP_EN\" },\n\n\t{ \"AMP\", NULL, \"DACPCM Source\"},\n\t{ \"AMP\", NULL, \"GLOBAL_EN\"},\n\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX1\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX2\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX3\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX4\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX5\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX6\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX7\"),\n\tCS35L45_DSP_MUX_ROUTE(\"DSP_RX8\"),\n\n\t{\"DSP1\", NULL, \"DSP_RX1 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX2 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX3 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX4 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX5 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX6 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX7 Source\"},\n\t{\"DSP1\", NULL, \"DSP_RX8 Source\"},\n\n\t{\"DSP1 Preload\", NULL, \"DSP1 Preloader\"},\n\t{\"DSP1\", NULL, \"DSP1 Preloader\"},\n\n\tCS35L45_DAC_MUX_ROUTE(\"DACPCM\"),\n\n\t{ \"SPK\", NULL, \"AMP\"},\n};\n\nstatic const DECLARE_TLV_DB_SCALE(cs35l45_dig_pcm_vol_tlv, -10225, 25, true);\n\nstatic const struct snd_kcontrol_new cs35l45_controls[] = {\n\t \n\tSOC_SINGLE_S_TLV(\"Digital PCM Volume\",\n\t\t\t CS35L45_AMP_PCM_CONTROL,\n\t\t\t CS35L45_AMP_VOL_PCM_SHIFT + 1,\n\t\t\t -409, 48,\n\t\t\t (CS35L45_AMP_VOL_PCM_WIDTH - 1) - 1,\n\t\t\t 0, cs35l45_dig_pcm_vol_tlv),\n\tWM_ADSP2_PRELOAD_SWITCH(\"DSP1\", 1),\n\tWM_ADSP_FW_CONTROL(\"DSP1\", 0),\n};\n\nstatic int cs35l45_set_pll(struct cs35l45_private *cs35l45, unsigned int freq)\n{\n\tunsigned int val;\n\tint freq_id;\n\n\tfreq_id = cs35l45_get_clk_freq_id(freq);\n\tif (freq_id < 0) {\n\t\tdev_err(cs35l45->dev, \"Invalid freq: %u\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_read(cs35l45->regmap, CS35L45_REFCLK_INPUT, &val);\n\tval = (val & CS35L45_PLL_REFCLK_FREQ_MASK) >> CS35L45_PLL_REFCLK_FREQ_SHIFT;\n\tif (val == freq_id)\n\t\treturn 0;\n\n\tregmap_set_bits(cs35l45->regmap, CS35L45_REFCLK_INPUT, CS35L45_PLL_OPEN_LOOP_MASK);\n\tregmap_update_bits(cs35l45->regmap, CS35L45_REFCLK_INPUT,\n\t\t\t   CS35L45_PLL_REFCLK_FREQ_MASK,\n\t\t\t   freq_id << CS35L45_PLL_REFCLK_FREQ_SHIFT);\n\tregmap_clear_bits(cs35l45->regmap, CS35L45_REFCLK_INPUT, CS35L45_PLL_REFCLK_EN_MASK);\n\tregmap_clear_bits(cs35l45->regmap, CS35L45_REFCLK_INPUT, CS35L45_PLL_OPEN_LOOP_MASK);\n\tregmap_set_bits(cs35l45->regmap, CS35L45_REFCLK_INPUT, CS35L45_PLL_REFCLK_EN_MASK);\n\n\treturn 0;\n}\n\nstatic int cs35l45_asp_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(codec_dai->component);\n\tunsigned int asp_fmt, fsync_inv, bclk_inv;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l45->dev, \"Invalid DAI clocking\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tasp_fmt = CS35l45_ASP_FMT_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tasp_fmt = CS35L45_ASP_FMT_I2S;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l45->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tfsync_inv = 1;\n\t\tbclk_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tfsync_inv = 0;\n\t\tbclk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tfsync_inv = 1;\n\t\tbclk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tfsync_inv = 0;\n\t\tbclk_inv = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(cs35l45->dev, \"Invalid DAI clock polarity\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_CONTROL2,\n\t\t\t   CS35L45_ASP_FMT_MASK |\n\t\t\t   CS35L45_ASP_FSYNC_INV_MASK |\n\t\t\t   CS35L45_ASP_BCLK_INV_MASK,\n\t\t\t   (asp_fmt << CS35L45_ASP_FMT_SHIFT) |\n\t\t\t   (fsync_inv << CS35L45_ASP_FSYNC_INV_SHIFT) |\n\t\t\t   (bclk_inv << CS35L45_ASP_BCLK_INV_SHIFT));\n\n\treturn 0;\n}\n\nstatic int cs35l45_asp_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int asp_width, asp_wl, global_fs, slot_multiple, asp_fmt;\n\tint bclk;\n\n\tswitch (params_rate(params)) {\n\tcase 44100:\n\t\tglobal_fs = CS35L45_44P100_KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tglobal_fs = CS35L45_48P0_KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tglobal_fs = CS35L45_88P200_KHZ;\n\t\tbreak;\n\tcase 96000:\n\t\tglobal_fs = CS35L45_96P0_KHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(cs35l45->dev, \"Unsupported sample rate (%d)\\n\",\n\t\t\t params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l45->regmap, CS35L45_GLOBAL_SAMPLE_RATE,\n\t\t\t   CS35L45_GLOBAL_FS_MASK,\n\t\t\t   global_fs << CS35L45_GLOBAL_FS_SHIFT);\n\n\tasp_wl = params_width(params);\n\n\tif (cs35l45->slot_width)\n\t\tasp_width = cs35l45->slot_width;\n\telse\n\t\tasp_width = params_width(params);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_CONTROL2,\n\t\t\t\t   CS35L45_ASP_WIDTH_RX_MASK,\n\t\t\t\t   asp_width << CS35L45_ASP_WIDTH_RX_SHIFT);\n\n\t\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_DATA_CONTROL5,\n\t\t\t\t   CS35L45_ASP_WL_MASK,\n\t\t\t\t   asp_wl << CS35L45_ASP_WL_SHIFT);\n\t} else {\n\t\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_CONTROL2,\n\t\t\t\t   CS35L45_ASP_WIDTH_TX_MASK,\n\t\t\t\t   asp_width << CS35L45_ASP_WIDTH_TX_SHIFT);\n\n\t\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_DATA_CONTROL1,\n\t\t\t\t   CS35L45_ASP_WL_MASK,\n\t\t\t\t   asp_wl << CS35L45_ASP_WL_SHIFT);\n\t}\n\n\tif (cs35l45->sysclk_set)\n\t\treturn 0;\n\n\t \n\tregmap_read(cs35l45->regmap, CS35L45_ASP_CONTROL2, &asp_fmt);\n\tasp_fmt = (asp_fmt & CS35L45_ASP_FMT_MASK) >> CS35L45_ASP_FMT_SHIFT;\n\tif (asp_fmt == CS35L45_ASP_FMT_I2S)\n\t\tslot_multiple = 2;\n\telse\n\t\tslot_multiple = 1;\n\n\tbclk = snd_soc_tdm_params_to_bclk(params, asp_width,\n\t\t\t\t\t  cs35l45->slot_count, slot_multiple);\n\n\treturn cs35l45_set_pll(cs35l45, bclk);\n}\n\nstatic int cs35l45_asp_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (slot_width && ((slot_width < 16) || (slot_width > 128)))\n\t\treturn -EINVAL;\n\n\tcs35l45->slot_width = slot_width;\n\tcs35l45->slot_count = slots;\n\n\treturn 0;\n}\n\nstatic int cs35l45_asp_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(dai->component);\n\tint ret;\n\n\tif (clk_id != 0) {\n\t\tdev_err(cs35l45->dev, \"Invalid clk_id %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tcs35l45->sysclk_set = false;\n\tif (freq == 0)\n\t\treturn 0;\n\n\tret = cs35l45_set_pll(cs35l45, freq);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tcs35l45->sysclk_set = true;\n\n\treturn 0;\n}\n\nstatic int cs35l45_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int global_fs, val, hpf_tune;\n\n\tif (mute)\n\t\treturn 0;\n\n\tregmap_read(cs35l45->regmap, CS35L45_GLOBAL_SAMPLE_RATE, &global_fs);\n\tglobal_fs = (global_fs & CS35L45_GLOBAL_FS_MASK) >> CS35L45_GLOBAL_FS_SHIFT;\n\tswitch (global_fs) {\n\tcase CS35L45_44P100_KHZ:\n\t\thpf_tune = CS35L45_HPF_44P1;\n\t\tbreak;\n\tcase CS35L45_88P200_KHZ:\n\t\thpf_tune = CS35L45_HPF_88P2;\n\t\tbreak;\n\tdefault:\n\t\thpf_tune = CS35l45_HPF_DEFAULT;\n\t\tbreak;\n\t}\n\n\tregmap_read(cs35l45->regmap, CS35L45_AMP_PCM_HPF_TST, &val);\n\tif (val != hpf_tune) {\n\t\tstruct reg_sequence hpf_override_seq[] = {\n\t\t\t{ 0x00000040,\t\t\t0x00000055 },\n\t\t\t{ 0x00000040,\t\t\t0x000000AA },\n\t\t\t{ 0x00000044,\t\t\t0x00000055 },\n\t\t\t{ 0x00000044,\t\t\t0x000000AA },\n\t\t\t{ CS35L45_AMP_PCM_HPF_TST,\thpf_tune },\n\t\t\t{ 0x00000040,\t\t\t0x00000000 },\n\t\t\t{ 0x00000044,\t\t\t0x00000000 },\n\t\t};\n\t\tregmap_multi_reg_write(cs35l45->regmap, hpf_override_seq,\n\t\t\t\t       ARRAY_SIZE(hpf_override_seq));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l45_asp_dai_ops = {\n\t.set_fmt = cs35l45_asp_set_fmt,\n\t.hw_params = cs35l45_asp_hw_params,\n\t.set_tdm_slot = cs35l45_asp_set_tdm_slot,\n\t.set_sysclk = cs35l45_asp_set_sysclk,\n\t.mute_stream = cs35l45_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver cs35l45_dai[] = {\n\t{\n\t\t.name = \"cs35l45\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS35L45_RATES,\n\t\t\t.formats = CS35L45_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 5,\n\t\t\t.rates = CS35L45_RATES,\n\t\t\t.formats = CS35L45_FORMATS,\n\t\t},\n\t\t.symmetric_rate = true,\n\t\t.symmetric_sample_bits = true,\n\t\t.ops = &cs35l45_asp_dai_ops,\n\t},\n};\n\nstatic int cs35l45_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(component);\n\n\treturn wm_adsp2_component_probe(&cs35l45->dsp, component);\n}\n\nstatic void cs35l45_component_remove(struct snd_soc_component *component)\n{\n\tstruct cs35l45_private *cs35l45 = snd_soc_component_get_drvdata(component);\n\n\twm_adsp2_component_remove(&cs35l45->dsp, component);\n}\n\nstatic const struct snd_soc_component_driver cs35l45_component = {\n\t.probe = cs35l45_component_probe,\n\t.remove = cs35l45_component_remove,\n\n\t.dapm_widgets = cs35l45_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(cs35l45_dapm_widgets),\n\n\t.dapm_routes = cs35l45_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(cs35l45_dapm_routes),\n\n\t.controls = cs35l45_controls,\n\t.num_controls = ARRAY_SIZE(cs35l45_controls),\n\n\t.name = \"cs35l45\",\n\n\t.endianness = 1,\n};\n\nstatic void cs35l45_setup_hibernate(struct cs35l45_private *cs35l45)\n{\n\tunsigned int wksrc;\n\n\tif (cs35l45->bus_type == CONTROL_BUS_I2C)\n\t\twksrc = CS35L45_WKSRC_I2C;\n\telse\n\t\twksrc = CS35L45_WKSRC_SPI;\n\n\tregmap_update_bits(cs35l45->regmap, CS35L45_WAKESRC_CTL,\n\t\t\t   CS35L45_WKSRC_EN_MASK,\n\t\t\t   wksrc << CS35L45_WKSRC_EN_SHIFT);\n\n\tregmap_set_bits(cs35l45->regmap, CS35L45_WAKESRC_CTL,\n\t\t\t   CS35L45_UPDT_WKCTL_MASK);\n\n\tregmap_update_bits(cs35l45->regmap, CS35L45_WKI2C_CTL,\n\t\t\t   CS35L45_WKI2C_ADDR_MASK, cs35l45->i2c_addr);\n\n\tregmap_set_bits(cs35l45->regmap, CS35L45_WKI2C_CTL,\n\t\t\t   CS35L45_UPDT_WKI2C_MASK);\n}\n\nstatic int cs35l45_enter_hibernate(struct cs35l45_private *cs35l45)\n{\n\tdev_dbg(cs35l45->dev, \"Enter hibernate\\n\");\n\n\tcs35l45_setup_hibernate(cs35l45);\n\n\tregmap_set_bits(cs35l45->regmap, CS35L45_IRQ1_MASK_2, CS35L45_DSP_VIRT2_MBOX_MASK);\n\n\t\n\tregmap_write(cs35l45->regmap, CS35L45_DSP_VIRT1_MBOX_1, CSPL_MBOX_CMD_HIBERNATE);\n\n\treturn 0;\n}\n\nstatic int cs35l45_exit_hibernate(struct cs35l45_private *cs35l45)\n{\n\tconst int wake_retries = 20;\n\tconst int sleep_retries = 5;\n\tint ret, i, j;\n\n\tfor (i = 0; i < sleep_retries; i++) {\n\t\tdev_dbg(cs35l45->dev, \"Exit hibernate\\n\");\n\n\t\tfor (j = 0; j < wake_retries; j++) {\n\t\t\tret = cs35l45_set_cspl_mbox_cmd(cs35l45, cs35l45->regmap,\n\t\t\t\t\t  CSPL_MBOX_CMD_OUT_OF_HIBERNATE);\n\t\t\tif (!ret) {\n\t\t\t\tdev_dbg(cs35l45->dev, \"Wake success at cycle: %d\\n\", j);\n\t\t\t\tregmap_clear_bits(cs35l45->regmap, CS35L45_IRQ1_MASK_2,\n\t\t\t\t\t\t CS35L45_DSP_VIRT2_MBOX_MASK);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tusleep_range(100, 200);\n\t\t}\n\n\t\tdev_err(cs35l45->dev, \"Wake failed, re-enter hibernate: %d\\n\", ret);\n\n\t\tcs35l45_setup_hibernate(cs35l45);\n\t}\n\n\tdev_err(cs35l45->dev, \"Timed out waking device\\n\");\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int cs35l45_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\n\tif (!cs35l45->dsp.preloaded || !cs35l45->dsp.cs_dsp.running)\n\t\treturn 0;\n\n\tcs35l45_enter_hibernate(cs35l45);\n\n\tregcache_cache_only(cs35l45->regmap, true);\n\tregcache_mark_dirty(cs35l45->regmap);\n\n\tdev_dbg(cs35l45->dev, \"Runtime suspended\\n\");\n\n\treturn 0;\n}\n\nstatic int cs35l45_runtime_resume(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (!cs35l45->dsp.preloaded || !cs35l45->dsp.cs_dsp.running)\n\t\treturn 0;\n\n\tdev_dbg(cs35l45->dev, \"Runtime resume\\n\");\n\n\tregcache_cache_only(cs35l45->regmap, false);\n\n\tret = cs35l45_exit_hibernate(cs35l45);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regcache_sync(cs35l45->regmap);\n\tif (ret != 0)\n\t\tdev_warn(cs35l45->dev, \"regcache_sync failed: %d\\n\", ret);\n\n\t \n\tregmap_clear_bits(cs35l45->regmap, CS35L45_ERROR_RELEASE, CS35L45_GLOBAL_ERR_RLS_MASK);\n\tregmap_set_bits(cs35l45->regmap, CS35L45_ERROR_RELEASE, CS35L45_GLOBAL_ERR_RLS_MASK);\n\tregmap_clear_bits(cs35l45->regmap, CS35L45_ERROR_RELEASE, CS35L45_GLOBAL_ERR_RLS_MASK);\n\treturn ret;\n}\n\nstatic int cs35l45_sys_suspend(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l45->dev, \"System suspend, disabling IRQ\\n\");\n\tdisable_irq(cs35l45->irq);\n\n\treturn 0;\n}\n\nstatic int cs35l45_sys_suspend_noirq(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l45->dev, \"Late system suspend, reenabling IRQ\\n\");\n\tenable_irq(cs35l45->irq);\n\n\treturn 0;\n}\n\nstatic int cs35l45_sys_resume_noirq(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l45->dev, \"Early system resume, disabling IRQ\\n\");\n\tdisable_irq(cs35l45->irq);\n\n\treturn 0;\n}\n\nstatic int cs35l45_sys_resume(struct device *dev)\n{\n\tstruct cs35l45_private *cs35l45 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l45->dev, \"System resume, reenabling IRQ\\n\");\n\tenable_irq(cs35l45->irq);\n\n\treturn 0;\n}\n\nstatic int cs35l45_apply_property_config(struct cs35l45_private *cs35l45)\n{\n\tstruct device_node *node = cs35l45->dev->of_node;\n\tunsigned int gpio_regs[] = {CS35L45_GPIO1_CTRL1, CS35L45_GPIO2_CTRL1,\n\t\t\t\t    CS35L45_GPIO3_CTRL1};\n\tunsigned int pad_regs[] = {CS35L45_SYNC_GPIO1,\n\t\t\t\t   CS35L45_INTB_GPIO2_MCLK_REF, CS35L45_GPIO3};\n\tstruct device_node *child;\n\tunsigned int val;\n\tchar of_name[32];\n\tint ret, i;\n\n\tif (!node)\n\t\treturn 0;\n\n\tfor (i = 0; i < CS35L45_NUM_GPIOS; i++) {\n\t\tsprintf(of_name, \"cirrus,gpio-ctrl%d\", i + 1);\n\t\tchild = of_get_child_by_name(node, of_name);\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\tret = of_property_read_u32(child, \"gpio-dir\", &val);\n\t\tif (!ret)\n\t\t\tregmap_update_bits(cs35l45->regmap, gpio_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_DIR_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_DIR_SHIFT);\n\n\t\tret = of_property_read_u32(child, \"gpio-lvl\", &val);\n\t\tif (!ret)\n\t\t\tregmap_update_bits(cs35l45->regmap, gpio_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_LVL_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_LVL_SHIFT);\n\n\t\tret = of_property_read_u32(child, \"gpio-op-cfg\", &val);\n\t\tif (!ret)\n\t\t\tregmap_update_bits(cs35l45->regmap, gpio_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_OP_CFG_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_OP_CFG_SHIFT);\n\n\t\tret = of_property_read_u32(child, \"gpio-pol\", &val);\n\t\tif (!ret)\n\t\t\tregmap_update_bits(cs35l45->regmap, gpio_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_POL_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_POL_SHIFT);\n\n\t\tret = of_property_read_u32(child, \"gpio-ctrl\", &val);\n\t\tif (!ret)\n\t\t\tregmap_update_bits(cs35l45->regmap, pad_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_CTRL_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_CTRL_SHIFT);\n\n\t\tret = of_property_read_u32(child, \"gpio-invert\", &val);\n\t\tif (!ret) {\n\t\t\tregmap_update_bits(cs35l45->regmap, pad_regs[i],\n\t\t\t\t\t   CS35L45_GPIO_INVERT_MASK,\n\t\t\t\t\t   val << CS35L45_GPIO_INVERT_SHIFT);\n\t\t\tif (i == 1)\n\t\t\t\tcs35l45->irq_invert = val;\n\t\t}\n\n\t\tof_node_put(child);\n\t}\n\n\tif (device_property_read_u32(cs35l45->dev,\n\t\t\t\t     \"cirrus,asp-sdout-hiz-ctrl\", &val) == 0) {\n\t\tregmap_update_bits(cs35l45->regmap, CS35L45_ASP_CONTROL3,\n\t\t\t\t   CS35L45_ASP_DOUT_HIZ_CTRL_MASK,\n\t\t\t\t   val << CS35L45_ASP_DOUT_HIZ_CTRL_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l45_dsp_virt2_mbox3_irq_handle(struct cs35l45_private *cs35l45,\n\t\t\t\t\t      const unsigned int cmd,\n\t\t\t\t\t      unsigned int data)\n{\n\tstatic char *speak_status = \"Unknown\";\n\n\tswitch (cmd) {\n\tcase EVENT_SPEAKER_STATUS:\n\t\tswitch (data) {\n\t\tcase 1:\n\t\t\tspeak_status = \"All Clear\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tspeak_status = \"Open Circuit\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tspeak_status = \"Short Circuit\";\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_info(cs35l45->dev, \"MBOX event (SPEAKER_STATUS): %s\\n\",\n\t\t\t speak_status);\n\t\tbreak;\n\tcase EVENT_BOOT_DONE:\n\t\tdev_dbg(cs35l45->dev, \"MBOX event (BOOT_DONE)\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l45->dev, \"MBOX event not supported %u\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t cs35l45_dsp_virt2_mbox_cb(int irq, void *data)\n{\n\tstruct cs35l45_private *cs35l45 = data;\n\tunsigned int mbox_val;\n\tint ret = 0;\n\n\tret = regmap_read(cs35l45->regmap, CS35L45_DSP_VIRT2_MBOX_3, &mbox_val);\n\tif (!ret && mbox_val)\n\t\tcs35l45_dsp_virt2_mbox3_irq_handle(cs35l45, mbox_val & CS35L45_MBOX3_CMD_MASK,\n\t\t\t\t(mbox_val & CS35L45_MBOX3_DATA_MASK) >> CS35L45_MBOX3_DATA_SHIFT);\n\n\t \n\tret = regmap_read(cs35l45->regmap, CS35L45_DSP_VIRT2_MBOX_4, &mbox_val);\n\tif (!ret && mbox_val != 0) {\n\t\tdev_err(cs35l45->dev, \"Spurious DSP MBOX4 IRQ\\n\");\n\t}\n\n\treturn IRQ_RETVAL(ret);\n}\n\nstatic irqreturn_t cs35l45_pll_unlock(int irq, void *data)\n{\n\tstruct cs35l45_private *cs35l45 = data;\n\n\tdev_dbg(cs35l45->dev, \"PLL unlock detected!\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l45_pll_lock(int irq, void *data)\n{\n\tstruct cs35l45_private *cs35l45 = data;\n\n\tdev_dbg(cs35l45->dev, \"PLL lock detected!\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cs35l45_spk_safe_err(int irq, void *data);\n\nstatic const struct cs35l45_irq cs35l45_irqs[] = {\n\tCS35L45_IRQ(AMP_SHORT_ERR, \"Amplifier short error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(UVLO_VDDBATT_ERR, \"VDDBATT undervoltage error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(BST_SHORT_ERR, \"Boost inductor error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(BST_UVP_ERR, \"Boost undervoltage error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(TEMP_ERR, \"Overtemperature error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(AMP_CAL_ERR, \"Amplifier calibration error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(UVLO_VDDLV_ERR, \"LV threshold detector error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(GLOBAL_ERROR, \"Global error\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(DSP_WDT_EXPIRE, \"DSP Watchdog Timer\", cs35l45_spk_safe_err),\n\tCS35L45_IRQ(PLL_UNLOCK_FLAG_RISE, \"PLL unlock\", cs35l45_pll_unlock),\n\tCS35L45_IRQ(PLL_LOCK_FLAG, \"PLL lock\", cs35l45_pll_lock),\n\tCS35L45_IRQ(DSP_VIRT2_MBOX, \"DSP virtual MBOX 2 write flag\", cs35l45_dsp_virt2_mbox_cb),\n};\n\nstatic irqreturn_t cs35l45_spk_safe_err(int irq, void *data)\n{\n\tstruct cs35l45_private *cs35l45 = data;\n\tint i;\n\n\ti = irq - regmap_irq_get_virq(cs35l45->irq_data, 0);\n\n\tdev_err(cs35l45->dev, \"%s condition detected!\\n\", cs35l45_irqs[i].name);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct regmap_irq cs35l45_reg_irqs[] = {\n\tCS35L45_REG_IRQ(IRQ1_EINT_1, AMP_SHORT_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_1, UVLO_VDDBATT_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_1, BST_SHORT_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_1, BST_UVP_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_1, TEMP_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_3, AMP_CAL_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_18, UVLO_VDDLV_ERR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_18, GLOBAL_ERROR),\n\tCS35L45_REG_IRQ(IRQ1_EINT_2, DSP_WDT_EXPIRE),\n\tCS35L45_REG_IRQ(IRQ1_EINT_3, PLL_UNLOCK_FLAG_RISE),\n\tCS35L45_REG_IRQ(IRQ1_EINT_3, PLL_LOCK_FLAG),\n\tCS35L45_REG_IRQ(IRQ1_EINT_2, DSP_VIRT2_MBOX),\n};\n\nstatic const struct regmap_irq_chip cs35l45_regmap_irq_chip = {\n\t.name = \"cs35l45 IRQ1 Controller\",\n\t.main_status = CS35L45_IRQ1_STATUS,\n\t.status_base = CS35L45_IRQ1_EINT_1,\n\t.mask_base = CS35L45_IRQ1_MASK_1,\n\t.ack_base = CS35L45_IRQ1_EINT_1,\n\t.num_regs = 18,\n\t.irqs = cs35l45_reg_irqs,\n\t.num_irqs = ARRAY_SIZE(cs35l45_reg_irqs),\n\t.runtime_pm = true,\n};\n\nstatic int cs35l45_initialize(struct cs35l45_private *cs35l45)\n{\n\tstruct device *dev = cs35l45->dev;\n\tunsigned int dev_id[5];\n\tunsigned int sts;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(cs35l45->regmap, CS35L45_IRQ1_EINT_4, sts,\n\t\t\t\t       (sts & CS35L45_OTP_BOOT_DONE_STS_MASK),\n\t\t\t\t       1000, 5000);\n\tif (ret < 0) {\n\t\tdev_err(cs35l45->dev, \"Timeout waiting for OTP boot\\n\");\n\t\treturn ret;\n\t}\n\n\tret = regmap_bulk_read(cs35l45->regmap, CS35L45_DEVID, dev_id, ARRAY_SIZE(dev_id));\n\tif (ret) {\n\t\tdev_err(cs35l45->dev, \"Get Device ID failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (dev_id[0]) {\n\tcase 0x35A450:\n\tcase 0x35A460:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l45->dev, \"Bad DEVID 0x%x\\n\", dev_id[0]);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(cs35l45->dev, \"Cirrus Logic CS35L45: REVID %02X OTPID %02X\\n\",\n\t\t dev_id[1], dev_id[4]);\n\n\tregmap_write(cs35l45->regmap, CS35L45_IRQ1_EINT_4,\n\t\t     CS35L45_OTP_BOOT_DONE_STS_MASK | CS35L45_OTP_BUSY_MASK);\n\n\tret = cs35l45_apply_patch(cs35l45);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to apply init patch %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cs35l45_apply_property_config(cs35l45);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence cs35l45_fs_errata_patch[] = {\n\t{0x02B80080,\t\t\t0x00000001},\n\t{0x02B80088,\t\t\t0x00000001},\n\t{0x02B80090,\t\t\t0x00000001},\n\t{0x02B80098,\t\t\t0x00000001},\n\t{0x02B800A0,\t\t\t0x00000001},\n\t{0x02B800A8,\t\t\t0x00000001},\n\t{0x02B800B0,\t\t\t0x00000001},\n\t{0x02B800B8,\t\t\t0x00000001},\n\t{0x02B80280,\t\t\t0x00000001},\n\t{0x02B80288,\t\t\t0x00000001},\n\t{0x02B80290,\t\t\t0x00000001},\n\t{0x02B80298,\t\t\t0x00000001},\n\t{0x02B802A0,\t\t\t0x00000001},\n\t{0x02B802A8,\t\t\t0x00000001},\n\t{0x02B802B0,\t\t\t0x00000001},\n\t{0x02B802B8,\t\t\t0x00000001},\n};\n\nstatic const struct cs_dsp_region cs35l45_dsp1_regions[] = {\n\t{ .type = WMFW_HALO_PM_PACKED,\t.base = CS35L45_DSP1_PMEM_0 },\n\t{ .type = WMFW_HALO_XM_PACKED,\t.base = CS35L45_DSP1_XMEM_PACK_0 },\n\t{ .type = WMFW_HALO_YM_PACKED,\t.base = CS35L45_DSP1_YMEM_PACK_0 },\n\t{. type = WMFW_ADSP2_XM,\t.base = CS35L45_DSP1_XMEM_UNPACK24_0},\n\t{. type = WMFW_ADSP2_YM,\t.base = CS35L45_DSP1_YMEM_UNPACK24_0},\n};\n\nstatic int cs35l45_dsp_init(struct cs35l45_private *cs35l45)\n{\n\tstruct wm_adsp *dsp = &cs35l45->dsp;\n\tint ret;\n\n\tdsp->part = \"cs35l45\";\n\tdsp->fw = 9;  \n\tdsp->toggle_preload = true;\n\tdsp->cs_dsp.num = 1;\n\tdsp->cs_dsp.type = WMFW_HALO;\n\tdsp->cs_dsp.rev = 0;\n\tdsp->cs_dsp.dev = cs35l45->dev;\n\tdsp->cs_dsp.regmap = cs35l45->regmap;\n\tdsp->cs_dsp.base = CS35L45_DSP1_CLOCK_FREQ;\n\tdsp->cs_dsp.base_sysinfo = CS35L45_DSP1_SYS_ID;\n\tdsp->cs_dsp.mem = cs35l45_dsp1_regions;\n\tdsp->cs_dsp.num_mems = ARRAY_SIZE(cs35l45_dsp1_regions);\n\tdsp->cs_dsp.lock_regions = 0xFFFFFFFF;\n\n\tret = wm_halo_init(dsp);\n\n\tregmap_multi_reg_write(cs35l45->regmap, cs35l45_fs_errata_patch,\n\t\t\t\t\t\t   ARRAY_SIZE(cs35l45_fs_errata_patch));\n\n\treturn ret;\n}\n\nint cs35l45_probe(struct cs35l45_private *cs35l45)\n{\n\tstruct device *dev = cs35l45->dev;\n\tunsigned long irq_pol = IRQF_ONESHOT | IRQF_SHARED;\n\tint ret, i, irq;\n\n\tcs35l45->vdd_batt = devm_regulator_get(dev, \"vdd-batt\");\n\tif (IS_ERR(cs35l45->vdd_batt))\n\t\treturn dev_err_probe(dev, PTR_ERR(cs35l45->vdd_batt),\n\t\t\t\t     \"Failed to request vdd-batt\\n\");\n\n\tcs35l45->vdd_a = devm_regulator_get(dev, \"vdd-a\");\n\tif (IS_ERR(cs35l45->vdd_a))\n\t\treturn dev_err_probe(dev, PTR_ERR(cs35l45->vdd_a),\n\t\t\t\t     \"Failed to request vdd-a\\n\");\n\n\t \n\tret = regulator_enable(cs35l45->vdd_batt);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable vdd-batt\\n\");\n\n\tret = regulator_enable(cs35l45->vdd_a);\n\tif (ret < 0)\n\t\treturn dev_err_probe(dev, ret, \"Failed to enable vdd-a\\n\");\n\n\t \n\tcs35l45->reset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l45->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l45->reset_gpio);\n\t\tcs35l45->reset_gpio = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_dbg(dev, \"Reset line busy, assuming shared reset\\n\");\n\t\t} else {\n\t\t\tdev_err_probe(dev, ret, \"Failed to get reset GPIO\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (cs35l45->reset_gpio) {\n\t\tusleep_range(CS35L45_RESET_HOLD_US, CS35L45_RESET_HOLD_US + 100);\n\t\tgpiod_set_value_cansleep(cs35l45->reset_gpio, 1);\n\t}\n\n\tusleep_range(CS35L45_RESET_US, CS35L45_RESET_US + 100);\n\n\tret = cs35l45_initialize(cs35l45);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tret = cs35l45_dsp_init(cs35l45);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tpm_runtime_set_autosuspend_delay(cs35l45->dev, 3000);\n\tpm_runtime_use_autosuspend(cs35l45->dev);\n\tpm_runtime_mark_last_busy(cs35l45->dev);\n\tpm_runtime_set_active(cs35l45->dev);\n\tpm_runtime_get_noresume(cs35l45->dev);\n\tpm_runtime_enable(cs35l45->dev);\n\n\tif (cs35l45->irq) {\n\t\tif (cs35l45->irq_invert)\n\t\t\tirq_pol |= IRQF_TRIGGER_HIGH;\n\t\telse\n\t\t\tirq_pol |= IRQF_TRIGGER_LOW;\n\n\t\tret = devm_regmap_add_irq_chip(dev, cs35l45->regmap, cs35l45->irq, irq_pol, 0,\n\t\t\t\t\t       &cs35l45_regmap_irq_chip, &cs35l45->irq_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register IRQ chip: %d\\n\", ret);\n\t\t\tgoto err_dsp;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cs35l45_irqs); i++) {\n\t\t\tirq = regmap_irq_get_virq(cs35l45->irq_data, cs35l45_irqs[i].irq);\n\t\t\tif (irq < 0) {\n\t\t\t\tdev_err(dev, \"Failed to get %s\\n\", cs35l45_irqs[i].name);\n\t\t\t\tret = irq;\n\t\t\t\tgoto err_dsp;\n\t\t\t}\n\n\t\t\tret = devm_request_threaded_irq(dev, irq, NULL, cs35l45_irqs[i].handler,\n\t\t\t\t\t\t\tirq_pol, cs35l45_irqs[i].name, cs35l45);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Failed to request IRQ %s: %d\\n\",\n\t\t\t\t\tcs35l45_irqs[i].name, ret);\n\t\t\t\tgoto err_dsp;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = devm_snd_soc_register_component(dev, &cs35l45_component,\n\t\t\t\t\t      cs35l45_dai,\n\t\t\t\t\t      ARRAY_SIZE(cs35l45_dai));\n\tif (ret < 0)\n\t\tgoto err_dsp;\n\n\tpm_runtime_put_autosuspend(cs35l45->dev);\n\n\treturn 0;\n\nerr_dsp:\n\tpm_runtime_disable(cs35l45->dev);\n\tpm_runtime_put_noidle(cs35l45->dev);\n\twm_adsp2_remove(&cs35l45->dsp);\n\nerr_reset:\n\tgpiod_set_value_cansleep(cs35l45->reset_gpio, 0);\nerr:\n\tregulator_disable(cs35l45->vdd_a);\n\tregulator_disable(cs35l45->vdd_batt);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l45_probe, SND_SOC_CS35L45);\n\nvoid cs35l45_remove(struct cs35l45_private *cs35l45)\n{\n\tpm_runtime_get_sync(cs35l45->dev);\n\tpm_runtime_disable(cs35l45->dev);\n\twm_adsp2_remove(&cs35l45->dsp);\n\n\tgpiod_set_value_cansleep(cs35l45->reset_gpio, 0);\n\n\tpm_runtime_put_noidle(cs35l45->dev);\n\tregulator_disable(cs35l45->vdd_a);\n\t \n\tregulator_disable(cs35l45->vdd_batt);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l45_remove, SND_SOC_CS35L45);\n\nEXPORT_GPL_DEV_PM_OPS(cs35l45_pm_ops) = {\n\tRUNTIME_PM_OPS(cs35l45_runtime_suspend, cs35l45_runtime_resume, NULL)\n\n\tSYSTEM_SLEEP_PM_OPS(cs35l45_sys_suspend, cs35l45_sys_resume)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l45_sys_suspend_noirq, cs35l45_sys_resume_noirq)\n};\n\nMODULE_DESCRIPTION(\"ASoC CS35L45 driver\");\nMODULE_AUTHOR(\"James Schulman, Cirrus Logic Inc, <james.schulman@cirrus.com>\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}