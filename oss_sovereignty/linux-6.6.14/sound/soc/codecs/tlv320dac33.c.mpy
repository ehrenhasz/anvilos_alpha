{
  "module_name": "tlv320dac33.c",
  "hash_id": "2a699400ea1a0bb54dc3e4dd0c756c17d42970d920f2b995efc9f233e68ed932",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320dac33.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/tlv320dac33-plat.h>\n#include \"tlv320dac33.h\"\n\n \n#define DAC33_FIFO_SIZE_16BIT\t6144\n#define DAC33_FIFO_SIZE_24BIT\t4096\n#define DAC33_MODE7_MARGIN\t10\t \n\n#define BURST_BASEFREQ_HZ\t49152000\n\n#define SAMPLES_TO_US(rate, samples) \\\n\t(1000000000 / (((rate) * 1000) / (samples)))\n\n#define US_TO_SAMPLES(rate, us) \\\n\t((rate) / (1000000 / ((us) < 1000000 ? (us) : 1000000)))\n\n#define UTHR_FROM_PERIOD_SIZE(samples, playrate, burstrate) \\\n\t(((samples)*5000) / (((burstrate)*5000) / ((burstrate) - (playrate))))\n\nstatic void dac33_calculate_times(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_component *component);\nstatic int dac33_prepare_chip(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_component *component);\n\nenum dac33_state {\n\tDAC33_IDLE = 0,\n\tDAC33_PREFILL,\n\tDAC33_PLAYBACK,\n\tDAC33_FLUSH,\n};\n\nenum dac33_fifo_modes {\n\tDAC33_FIFO_BYPASS = 0,\n\tDAC33_FIFO_MODE1,\n\tDAC33_FIFO_MODE7,\n\tDAC33_FIFO_LAST_MODE,\n};\n\n#define DAC33_NUM_SUPPLIES 3\nstatic const char *dac33_supply_names[DAC33_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"IOVDD\",\n};\n\nstruct tlv320dac33_priv {\n\tstruct mutex mutex;\n\tstruct work_struct work;\n\tstruct snd_soc_component *component;\n\tstruct regulator_bulk_data supplies[DAC33_NUM_SUPPLIES];\n\tstruct snd_pcm_substream *substream;\n\tint power_gpio;\n\tint chip_power;\n\tint irq;\n\tunsigned int refclk;\n\n\tunsigned int alarm_threshold;\t \n\tenum dac33_fifo_modes fifo_mode; \n\tunsigned int fifo_size;\t\t \n\tunsigned int nsample;\t\t \n\tint mode1_latency;\t\t \n\tu8 burst_bclkdiv;\t\t \n\tu8 *reg_cache;\n\tunsigned int burst_rate;\t \n\n\tint keep_bclk;\t\t\t \n\tspinlock_t lock;\n\tunsigned long long t_stamp1;\t \n\tunsigned long long t_stamp2;\t \n\n\tunsigned int mode1_us_burst;\t \n\tunsigned int mode7_us_to_lthr;\t \n\n\tunsigned int uthr;\n\n\tenum dac33_state state;\n\tstruct i2c_client *i2c;\n};\n\nstatic const u8 dac33_reg[DAC33_CACHEREGNUM] = {\n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x80,  \n0x80, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00,              \n \n            0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n\n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x80,              \n \n            0x80, 0x80,  \n\n0x80, 0x00, 0x00,        \n \n                  0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00, 0x00, 0x00, 0x00,  \n0x00,                    \n\n      0xda, 0x33, 0x03,  \n};\n\n \nstatic inline unsigned int dac33_read_reg_cache(struct snd_soc_component *component,\n\t\t\t\t\t\tunsigned reg)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 *cache = dac33->reg_cache;\n\tif (reg >= DAC33_CACHEREGNUM)\n\t\treturn 0;\n\n\treturn cache[reg];\n}\n\nstatic inline void dac33_write_reg_cache(struct snd_soc_component *component,\n\t\t\t\t\t u8 reg, u8 value)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 *cache = dac33->reg_cache;\n\tif (reg >= DAC33_CACHEREGNUM)\n\t\treturn;\n\n\tcache[reg] = value;\n}\n\nstatic int dac33_read(struct snd_soc_component *component, unsigned int reg,\n\t\t      u8 *value)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint val, ret = 0;\n\n\t*value = reg & 0xff;\n\n\t \n\tif (dac33->chip_power) {\n\t\tval = i2c_smbus_read_byte_data(dac33->i2c, value[0]);\n\t\tif (val < 0) {\n\t\t\tdev_err(component->dev, \"Read failed (%d)\\n\", val);\n\t\t\tvalue[0] = dac33_read_reg_cache(component, reg);\n\t\t\tret = val;\n\t\t} else {\n\t\t\tvalue[0] = val;\n\t\t\tdac33_write_reg_cache(component, reg, val);\n\t\t}\n\t} else {\n\t\tvalue[0] = dac33_read_reg_cache(component, reg);\n\t}\n\n\treturn ret;\n}\n\nstatic int dac33_write(struct snd_soc_component *component, unsigned int reg,\n\t\t       unsigned int value)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 data[2];\n\tint ret = 0;\n\n\t \n\tdata[0] = reg & 0xff;\n\tdata[1] = value & 0xff;\n\n\tdac33_write_reg_cache(component, data[0], data[1]);\n\tif (dac33->chip_power) {\n\t\tret = i2c_master_send(dac33->i2c, data, 2);\n\t\tif (ret != 2)\n\t\t\tdev_err(component->dev, \"Write failed (%d)\\n\", ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int dac33_write_locked(struct snd_soc_component *component, unsigned int reg,\n\t\t\t      unsigned int value)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&dac33->mutex);\n\tret = dac33_write(component, reg, value);\n\tmutex_unlock(&dac33->mutex);\n\n\treturn ret;\n}\n\n#define DAC33_I2C_ADDR_AUTOINC\t0x80\nstatic int dac33_write16(struct snd_soc_component *component, unsigned int reg,\n\t\t       unsigned int value)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 data[3];\n\tint ret = 0;\n\n\t \n\tdata[0] = reg & 0xff;\n\tdata[1] = (value >> 8) & 0xff;\n\tdata[2] = value & 0xff;\n\n\tdac33_write_reg_cache(component, data[0], data[1]);\n\tdac33_write_reg_cache(component, data[0] + 1, data[2]);\n\n\tif (dac33->chip_power) {\n\t\t \n\t\tdata[0] |= DAC33_I2C_ADDR_AUTOINC;\n\t\tret = i2c_master_send(dac33->i2c, data, 3);\n\t\tif (ret != 3)\n\t\t\tdev_err(component->dev, \"Write failed (%d)\\n\", ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic void dac33_init_chip(struct snd_soc_component *component)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\tif (unlikely(!dac33->chip_power))\n\t\treturn;\n\n\t \n\tdac33_write(component, DAC33_DAC_CTRL_A, DAC33_DACRATE(0));\n\t \n\tdac33_write(component, DAC33_DAC_CTRL_B, DAC33_DACSRCR_RIGHT |\n\t\t\t\t\t     DAC33_DACSRCL_LEFT);\n\t \n\tdac33_write(component, DAC33_DAC_CTRL_C, 0x00);\n\n\t \n\tdac33_write(component, DAC33_ANA_VOL_SOFT_STEP_CTRL, DAC33_VOLCLKEN);\n\n\t \n\tdac33_write(component, DAC33_LDAC_DIG_VOL_CTRL,\n\t\t    dac33_read_reg_cache(component, DAC33_LDAC_DIG_VOL_CTRL));\n\tdac33_write(component, DAC33_RDAC_DIG_VOL_CTRL,\n\t\t    dac33_read_reg_cache(component, DAC33_RDAC_DIG_VOL_CTRL));\n\n\tdac33_write(component, DAC33_LINEL_TO_LLO_VOL,\n\t\t    dac33_read_reg_cache(component, DAC33_LINEL_TO_LLO_VOL));\n\tdac33_write(component, DAC33_LINER_TO_RLO_VOL,\n\t\t    dac33_read_reg_cache(component, DAC33_LINER_TO_RLO_VOL));\n\n\tdac33_write(component, DAC33_OUT_AMP_CTRL,\n\t\t    dac33_read_reg_cache(component, DAC33_OUT_AMP_CTRL));\n\n\tdac33_write(component, DAC33_LDAC_PWR_CTRL,\n\t\t    dac33_read_reg_cache(component, DAC33_LDAC_PWR_CTRL));\n\tdac33_write(component, DAC33_RDAC_PWR_CTRL,\n\t\t    dac33_read_reg_cache(component, DAC33_RDAC_PWR_CTRL));\n}\n\nstatic inline int dac33_read_id(struct snd_soc_component *component)\n{\n\tint i, ret = 0;\n\tu8 reg;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = dac33_read(component, DAC33_DEVICE_ID_MSB + i, &reg);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void dac33_soft_power(struct snd_soc_component *component, int power)\n{\n\tu8 reg;\n\n\treg = dac33_read_reg_cache(component, DAC33_PWR_CTRL);\n\tif (power)\n\t\treg |= DAC33_PDNALLB;\n\telse\n\t\treg &= ~(DAC33_PDNALLB | DAC33_OSCPDNB |\n\t\t\t DAC33_DACRPDNB | DAC33_DACLPDNB);\n\tdac33_write(component, DAC33_PWR_CTRL, reg);\n}\n\nstatic inline void dac33_disable_digital(struct snd_soc_component *component)\n{\n\tu8 reg;\n\n\t \n\treg = dac33_read_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_B);\n\treg &= ~DAC33_BCLKON;\n\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_B, reg);\n\n\t \n\treg = dac33_read_reg_cache(component, DAC33_PWR_CTRL);\n\treg &= ~(DAC33_OSCPDNB | DAC33_DACRPDNB | DAC33_DACLPDNB);\n\tdac33_write(component, DAC33_PWR_CTRL, reg);\n}\n\nstatic int dac33_hard_power(struct snd_soc_component *component, int power)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tmutex_lock(&dac33->mutex);\n\n\t \n\tif (unlikely(power == dac33->chip_power)) {\n\t\tdev_dbg(component->dev, \"Trying to set the same power state: %s\\n\",\n\t\t\tpower ? \"ON\" : \"OFF\");\n\t\tgoto exit;\n\t}\n\n\tif (power) {\n\t\tret = regulator_bulk_enable(ARRAY_SIZE(dac33->supplies),\n\t\t\t\t\t  dac33->supplies);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to enable supplies: %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (dac33->power_gpio >= 0)\n\t\t\tgpio_set_value(dac33->power_gpio, 1);\n\n\t\tdac33->chip_power = 1;\n\t} else {\n\t\tdac33_soft_power(component, 0);\n\t\tif (dac33->power_gpio >= 0)\n\t\t\tgpio_set_value(dac33->power_gpio, 0);\n\n\t\tret = regulator_bulk_disable(ARRAY_SIZE(dac33->supplies),\n\t\t\t\t\t     dac33->supplies);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to disable supplies: %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tdac33->chip_power = 0;\n\t}\n\nexit:\n\tmutex_unlock(&dac33->mutex);\n\treturn ret;\n}\n\nstatic int dac33_playback_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (likely(dac33->substream)) {\n\t\t\tdac33_calculate_times(dac33->substream, component);\n\t\t\tdac33_prepare_chip(dac33->substream, component);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdac33_disable_digital(component);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int dac33_get_fifo_mode(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = dac33->fifo_mode;\n\n\treturn 0;\n}\n\nstatic int dac33_set_fifo_mode(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (dac33->fifo_mode == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\t \n\tif (snd_soc_component_active(component))\n\t\treturn -EPERM;\n\n\tif (ucontrol->value.enumerated.item[0] >= DAC33_FIFO_LAST_MODE)\n\t\tret = -EINVAL;\n\telse\n\t\tdac33->fifo_mode = ucontrol->value.enumerated.item[0];\n\n\treturn ret;\n}\n\n \nstatic const char *dac33_fifo_mode_texts[] = {\n\t\"Bypass\", \"Mode 1\", \"Mode 7\"\n};\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(dac33_fifo_mode_enum, dac33_fifo_mode_texts);\n\n \nstatic const char *lr_lineout_gain_texts[] = {\n\t\"Line -12dB DAC 0dB\", \"Line -6dB DAC 6dB\",\n\t\"Line 0dB DAC 12dB\", \"Line 6dB DAC 18dB\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(l_lineout_gain_enum,\n\t\t\t    DAC33_LDAC_PWR_CTRL, 0,\n\t\t\t    lr_lineout_gain_texts);\n\nstatic SOC_ENUM_SINGLE_DECL(r_lineout_gain_enum,\n\t\t\t    DAC33_RDAC_PWR_CTRL, 0,\n\t\t\t    lr_lineout_gain_texts);\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_digivol_tlv, -6350, 50, 0);\n\nstatic const struct snd_kcontrol_new dac33_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC Digital Playback Volume\",\n\t\tDAC33_LDAC_DIG_VOL_CTRL, DAC33_RDAC_DIG_VOL_CTRL,\n\t\t0, 0x7f, 1, dac_digivol_tlv),\n\tSOC_DOUBLE_R(\"DAC Digital Playback Switch\",\n\t\t DAC33_LDAC_DIG_VOL_CTRL, DAC33_RDAC_DIG_VOL_CTRL, 7, 1, 1),\n\tSOC_DOUBLE_R(\"Line to Line Out Volume\",\n\t\t DAC33_LINEL_TO_LLO_VOL, DAC33_LINER_TO_RLO_VOL, 0, 127, 1),\n\tSOC_ENUM(\"Left Line Output Gain\", l_lineout_gain_enum),\n\tSOC_ENUM(\"Right Line Output Gain\", r_lineout_gain_enum),\n};\n\nstatic const struct snd_kcontrol_new dac33_mode_snd_controls[] = {\n\tSOC_ENUM_EXT(\"FIFO Mode\", dac33_fifo_mode_enum,\n\t\t dac33_get_fifo_mode, dac33_set_fifo_mode),\n};\n\n \nstatic const struct snd_kcontrol_new dac33_dapm_abypassl_control =\n\tSOC_DAPM_SINGLE(\"Switch\", DAC33_LINEL_TO_LLO_VOL, 7, 1, 1);\n\nstatic const struct snd_kcontrol_new dac33_dapm_abypassr_control =\n\tSOC_DAPM_SINGLE(\"Switch\", DAC33_LINER_TO_RLO_VOL, 7, 1, 1);\n\n \nstatic const char *dac33_lr_lom_texts[] = {\"DAC\", \"LOP\"};\n\nstatic SOC_ENUM_SINGLE_DECL(dac33_left_lom_enum,\n\t\t\t    DAC33_OUT_AMP_CTRL, 3,\n\t\t\t    dac33_lr_lom_texts);\n\nstatic const struct snd_kcontrol_new dac33_dapm_left_lom_control =\nSOC_DAPM_ENUM(\"Route\", dac33_left_lom_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(dac33_right_lom_enum,\n\t\t\t    DAC33_OUT_AMP_CTRL, 2,\n\t\t\t    dac33_lr_lom_texts);\n\nstatic const struct snd_kcontrol_new dac33_dapm_right_lom_control =\nSOC_DAPM_ENUM(\"Route\", dac33_right_lom_enum);\n\nstatic const struct snd_soc_dapm_widget dac33_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"LEFT_LO\"),\n\tSND_SOC_DAPM_OUTPUT(\"RIGHT_LO\"),\n\n\tSND_SOC_DAPM_INPUT(\"LINEL\"),\n\tSND_SOC_DAPM_INPUT(\"LINER\"),\n\n\tSND_SOC_DAPM_DAC(\"DACL\", \"Left Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DACR\", \"Right Playback\", SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"Analog Left Bypass\", SND_SOC_NOPM, 0, 0,\n\t\t\t\t&dac33_dapm_abypassl_control),\n\tSND_SOC_DAPM_SWITCH(\"Analog Right Bypass\", SND_SOC_NOPM, 0, 0,\n\t\t\t\t&dac33_dapm_abypassr_control),\n\n\tSND_SOC_DAPM_MUX(\"Left LOM Inverted From\", SND_SOC_NOPM, 0, 0,\n\t\t&dac33_dapm_left_lom_control),\n\tSND_SOC_DAPM_MUX(\"Right LOM Inverted From\", SND_SOC_NOPM, 0, 0,\n\t\t&dac33_dapm_right_lom_control),\n\t \n\tSND_SOC_DAPM_PGA(\"Left Bypass PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Bypass PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_mixer, \"Output Left Amplifier\",\n\t\t\t DAC33_OUT_AMP_PWR_CTRL, 6, 3, 3, 0),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_mixer, \"Output Right Amplifier\",\n\t\t\t DAC33_OUT_AMP_PWR_CTRL, 4, 3, 3, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Left DAC Power\",\n\t\t\t    DAC33_LDAC_PWR_CTRL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Right DAC Power\",\n\t\t\t    DAC33_RDAC_PWR_CTRL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Codec Power\",\n\t\t\t    DAC33_PWR_CTRL, 4, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PRE(\"Pre Playback\", dac33_playback_event),\n\tSND_SOC_DAPM_POST(\"Post Playback\", dac33_playback_event),\n};\n\nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t \n\t{\"Analog Left Bypass\", \"Switch\", \"LINEL\"},\n\t{\"Analog Right Bypass\", \"Switch\", \"LINER\"},\n\n\t{\"Output Left Amplifier\", NULL, \"DACL\"},\n\t{\"Output Right Amplifier\", NULL, \"DACR\"},\n\n\t{\"Left Bypass PGA\", NULL, \"Analog Left Bypass\"},\n\t{\"Right Bypass PGA\", NULL, \"Analog Right Bypass\"},\n\n\t{\"Left LOM Inverted From\", \"DAC\", \"Left Bypass PGA\"},\n\t{\"Right LOM Inverted From\", \"DAC\", \"Right Bypass PGA\"},\n\t{\"Left LOM Inverted From\", \"LOP\", \"Analog Left Bypass\"},\n\t{\"Right LOM Inverted From\", \"LOP\", \"Analog Right Bypass\"},\n\n\t{\"Output Left Amplifier\", NULL, \"Left LOM Inverted From\"},\n\t{\"Output Right Amplifier\", NULL, \"Right LOM Inverted From\"},\n\n\t{\"DACL\", NULL, \"Left DAC Power\"},\n\t{\"DACR\", NULL, \"Right DAC Power\"},\n\n\t{\"Left Bypass PGA\", NULL, \"Left DAC Power\"},\n\t{\"Right Bypass PGA\", NULL, \"Right DAC Power\"},\n\n\t \n\t{\"LEFT_LO\", NULL, \"Output Left Amplifier\"},\n\t{\"RIGHT_LO\", NULL, \"Output Right Amplifier\"},\n\n\t{\"LEFT_LO\", NULL, \"Codec Power\"},\n\t{\"RIGHT_LO\", NULL, \"Codec Power\"},\n};\n\nstatic int dac33_set_bias_level(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_bias_level level)\n{\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tret = dac33_hard_power(component, 1);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t\tdac33_init_chip(component);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\treturn 0;\n\t\tret = dac33_hard_power(component, 0);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void dac33_prefill_handler(struct tlv320dac33_priv *dac33)\n{\n\tstruct snd_soc_component *component = dac33->component;\n\tunsigned int delay;\n\tunsigned long flags;\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\tdac33_write16(component, DAC33_NSAMPLE_MSB,\n\t\t\tDAC33_THRREG(dac33->nsample));\n\n\t\t \n\t\tspin_lock_irqsave(&dac33->lock, flags);\n\t\tdac33->t_stamp2 = ktime_to_us(ktime_get());\n\t\tdac33->t_stamp1 = dac33->t_stamp2;\n\t\tspin_unlock_irqrestore(&dac33->lock, flags);\n\n\t\tdac33_write16(component, DAC33_PREFILL_MSB,\n\t\t\t\tDAC33_THRREG(dac33->alarm_threshold));\n\t\t \n\t\tdelay = SAMPLES_TO_US(dac33->burst_rate,\n\t\t\t\t     dac33->alarm_threshold) + 1000;\n\t\tusleep_range(delay, delay + 500);\n\t\tdac33_write(component, DAC33_FIFO_IRQ_MASK, DAC33_MAT);\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\t \n\t\tspin_lock_irqsave(&dac33->lock, flags);\n\t\tdac33->t_stamp1 = ktime_to_us(ktime_get());\n\t\t \n\t\tdac33->t_stamp1 -= dac33->mode7_us_to_lthr;\n\t\tspin_unlock_irqrestore(&dac33->lock, flags);\n\n\t\tdac33_write16(component, DAC33_PREFILL_MSB,\n\t\t\t\tDAC33_THRREG(DAC33_MODE7_MARGIN));\n\n\t\t \n\t\tdac33_write(component, DAC33_FIFO_IRQ_MASK, DAC33_MUT);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(component->dev, \"Unhandled FIFO mode: %d\\n\",\n\t\t\t\t\t\t\tdac33->fifo_mode);\n\t\tbreak;\n\t}\n}\n\nstatic inline void dac33_playback_handler(struct tlv320dac33_priv *dac33)\n{\n\tstruct snd_soc_component *component = dac33->component;\n\tunsigned long flags;\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\t \n\t\tspin_lock_irqsave(&dac33->lock, flags);\n\t\tdac33->t_stamp2 = ktime_to_us(ktime_get());\n\t\tspin_unlock_irqrestore(&dac33->lock, flags);\n\n\t\tdac33_write16(component, DAC33_NSAMPLE_MSB,\n\t\t\t\tDAC33_THRREG(dac33->nsample));\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_warn(component->dev, \"Unhandled FIFO mode: %d\\n\",\n\t\t\t\t\t\t\tdac33->fifo_mode);\n\t\tbreak;\n\t}\n}\n\nstatic void dac33_work(struct work_struct *work)\n{\n\tstruct snd_soc_component *component;\n\tstruct tlv320dac33_priv *dac33;\n\tu8 reg;\n\n\tdac33 = container_of(work, struct tlv320dac33_priv, work);\n\tcomponent = dac33->component;\n\n\tmutex_lock(&dac33->mutex);\n\tswitch (dac33->state) {\n\tcase DAC33_PREFILL:\n\t\tdac33->state = DAC33_PLAYBACK;\n\t\tdac33_prefill_handler(dac33);\n\t\tbreak;\n\tcase DAC33_PLAYBACK:\n\t\tdac33_playback_handler(dac33);\n\t\tbreak;\n\tcase DAC33_IDLE:\n\t\tbreak;\n\tcase DAC33_FLUSH:\n\t\tdac33->state = DAC33_IDLE;\n\t\t \n\t\tdac33_write(component, DAC33_FIFO_IRQ_MASK, 0);\n\n\t\t \n\t\treg = dac33_read_reg_cache(component, DAC33_FIFO_CTRL_A);\n\t\treg |= DAC33_FIFOFLUSH;\n\t\tdac33_write(component, DAC33_FIFO_CTRL_A, reg);\n\t\tbreak;\n\t}\n\tmutex_unlock(&dac33->mutex);\n}\n\nstatic irqreturn_t dac33_interrupt_handler(int irq, void *dev)\n{\n\tstruct snd_soc_component *component = dev;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dac33->lock, flags);\n\tdac33->t_stamp1 = ktime_to_us(ktime_get());\n\tspin_unlock_irqrestore(&dac33->lock, flags);\n\n\t \n\tif (dac33->fifo_mode != DAC33_FIFO_MODE7)\n\t\tschedule_work(&dac33->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dac33_oscwait(struct snd_soc_component *component)\n{\n\tint timeout = 60;\n\tu8 reg;\n\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\tdac33_read(component, DAC33_INT_OSC_STATUS, &reg);\n\t} while (((reg & 0x03) != DAC33_OSCSTATUS_NORMAL) && timeout--);\n\tif ((reg & 0x03) != DAC33_OSCSTATUS_NORMAL)\n\t\tdev_err(component->dev,\n\t\t\t\"internal oscillator calibration failed\\n\");\n}\n\nstatic int dac33_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\t \n\tdac33->substream = substream;\n\n\treturn 0;\n}\n\nstatic void dac33_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\tdac33->substream = NULL;\n}\n\n#define CALC_BURST_RATE(bclkdiv, bclk_per_sample) \\\n\t(BURST_BASEFREQ_HZ / bclkdiv / bclk_per_sample)\nstatic int dac33_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 44100:\n\tcase 48000:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported rate %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tdac33->fifo_size = DAC33_FIFO_SIZE_16BIT;\n\t\tdac33->burst_rate = CALC_BURST_RATE(dac33->burst_bclkdiv, 32);\n\t\tbreak;\n\tcase 32:\n\t\tdac33->fifo_size = DAC33_FIFO_SIZE_24BIT;\n\t\tdac33->burst_rate = CALC_BURST_RATE(dac33->burst_bclkdiv, 64);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported width %d\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#define CALC_OSCSET(rate, refclk) ( \\\n\t((((rate * 10000) / refclk) * 4096) + 7000) / 10000)\n#define CALC_RATIOSET(rate, refclk) ( \\\n\t((((refclk  * 100000) / rate) * 16384) + 50000) / 100000)\n\n \nstatic int dac33_prepare_chip(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_component *component)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tunsigned int oscset, ratioset, pwr_ctrl, reg_tmp;\n\tu8 aictrl_a, aictrl_b, fifoctrl_a;\n\n\tswitch (substream->runtime->rate) {\n\tcase 44100:\n\tcase 48000:\n\t\toscset = CALC_OSCSET(substream->runtime->rate, dac33->refclk);\n\t\tratioset = CALC_RATIOSET(substream->runtime->rate,\n\t\t\t\t\t dac33->refclk);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported rate %d\\n\",\n\t\t\tsubstream->runtime->rate);\n\t\treturn -EINVAL;\n\t}\n\n\n\taictrl_a = dac33_read_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_A);\n\taictrl_a &= ~(DAC33_NCYCL_MASK | DAC33_WLEN_MASK);\n\t \n\tfifoctrl_a = dac33_read_reg_cache(component, DAC33_FIFO_CTRL_A);\n\tfifoctrl_a &= ~DAC33_FIFOFLUSH;\n\n\tfifoctrl_a &= ~DAC33_WIDTH;\n\tswitch (substream->runtime->format) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\taictrl_a |= (DAC33_NCYCL_16 | DAC33_WLEN_16);\n\t\tfifoctrl_a |= DAC33_WIDTH;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\taictrl_a |= (DAC33_NCYCL_32 | DAC33_WLEN_24);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported format %d\\n\",\n\t\t\tsubstream->runtime->format);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&dac33->mutex);\n\n\tif (!dac33->chip_power) {\n\t\t \n\t\tmutex_unlock(&dac33->mutex);\n\t\treturn 0;\n\t}\n\n\tdac33_soft_power(component, 0);\n\tdac33_soft_power(component, 1);\n\n\treg_tmp = dac33_read_reg_cache(component, DAC33_INT_OSC_CTRL);\n\tdac33_write(component, DAC33_INT_OSC_CTRL, reg_tmp);\n\n\t \n\tdac33_write16(component, DAC33_INT_OSC_FREQ_RAT_A, oscset);\n\n\t \n\tdac33_write(component, DAC33_CALIB_TIME, 96);\n\n\t \n\tdac33_write(component, DAC33_INT_OSC_CTRL_B, DAC33_ADJTHRSHLD(2) |\n\t\t\t\t\t\t DAC33_ADJSTEP(1));\n\n\t \n\tdac33_write(component, DAC33_INT_OSC_CTRL_C, DAC33_REFDIV(4));\n\n\tpwr_ctrl = dac33_read_reg_cache(component, DAC33_PWR_CTRL);\n\tpwr_ctrl |= DAC33_OSCPDNB | DAC33_DACRPDNB | DAC33_DACLPDNB;\n\tdac33_write(component, DAC33_PWR_CTRL, pwr_ctrl);\n\n\tdac33_oscwait(component);\n\n\tif (dac33->fifo_mode) {\n\t\t \n\t\t \n\t\tdac33_write(component, DAC33_ASRC_CTRL_A, DAC33_SRCLKDIV(1));\n\t\tdac33_write(component, DAC33_ASRC_CTRL_B, 1);  \n\n\t\t \n\t\tdac33_write16(component, DAC33_SRC_REF_CLK_RATIO_A, ratioset);\n\n\t\t \n\t\tdac33_write(component, DAC33_INTP_CTRL_A, DAC33_INTPM_AHIGH);\n\t} else {\n\t\t \n\t\t \n\t\tdac33_write(component, DAC33_ASRC_CTRL_A, DAC33_SRCBYP);\n\t\tdac33_write(component, DAC33_ASRC_CTRL_B, 0);  \n\t}\n\n\t \n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\tdac33_write(component, DAC33_FIFO_IRQ_MODE_B,\n\t\t\t    DAC33_ATM(DAC33_FIFO_IRQ_MODE_LEVEL));\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\tdac33_write(component, DAC33_FIFO_IRQ_MODE_A,\n\t\t\tDAC33_UTM(DAC33_FIFO_IRQ_MODE_LEVEL));\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\taictrl_b = dac33_read_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_B);\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\t \n\t\tfifoctrl_a &= ~DAC33_FBYPAS;\n\t\tfifoctrl_a &= ~DAC33_FAUTO;\n\t\tif (dac33->keep_bclk)\n\t\t\taictrl_b |= DAC33_BCLKON;\n\t\telse\n\t\t\taictrl_b &= ~DAC33_BCLKON;\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\t \n\t\tfifoctrl_a &= ~DAC33_FBYPAS;\n\t\tfifoctrl_a |= DAC33_FAUTO;\n\t\tif (dac33->keep_bclk)\n\t\t\taictrl_b |= DAC33_BCLKON;\n\t\telse\n\t\t\taictrl_b &= ~DAC33_BCLKON;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tfifoctrl_a |= DAC33_FBYPAS;\n\t\taictrl_b |= DAC33_BCLKON;\n\t\tbreak;\n\t}\n\n\tdac33_write(component, DAC33_FIFO_CTRL_A, fifoctrl_a);\n\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_A, aictrl_a);\n\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_B, aictrl_b);\n\n\t \n\tif (dac33->fifo_mode)\n\t\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_C,\n\t\t\t\t\t\t\tdac33->burst_bclkdiv);\n\telse\n\t\tif (substream->runtime->format == SNDRV_PCM_FORMAT_S16_LE)\n\t\t\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_C, 32);\n\t\telse\n\t\t\tdac33_write(component, DAC33_SER_AUDIOIF_CTRL_C, 16);\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\tdac33_write16(component, DAC33_ATHR_MSB,\n\t\t\t      DAC33_THRREG(dac33->alarm_threshold));\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\t \n\t\tdac33_write16(component, DAC33_UTHR_MSB, DAC33_THRREG(dac33->uthr));\n\t\tdac33_write16(component, DAC33_LTHR_MSB,\n\t\t\t      DAC33_THRREG(DAC33_MODE7_MARGIN));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&dac33->mutex);\n\n\treturn 0;\n}\n\nstatic void dac33_calculate_times(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_component *component)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tunsigned int period_size = substream->runtime->period_size;\n\tunsigned int rate = substream->runtime->rate;\n\tunsigned int nsample_limit;\n\n\t \n\tif (!dac33->fifo_mode)\n\t\treturn;\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_MODE1:\n\t\t \n\t\tdac33->alarm_threshold = US_TO_SAMPLES(rate,\n\t\t\t\t\t\tdac33->mode1_latency);\n\t\tnsample_limit = dac33->fifo_size - dac33->alarm_threshold;\n\n\t\tif (period_size <= dac33->alarm_threshold)\n\t\t\t \n\t\t\tdac33->nsample = period_size *\n\t\t\t\t((dac33->alarm_threshold / period_size) +\n\t\t\t\t ((dac33->alarm_threshold % period_size) ?\n\t\t\t\t1 : 0));\n\t\telse if (period_size > nsample_limit)\n\t\t\tdac33->nsample = nsample_limit;\n\t\telse\n\t\t\tdac33->nsample = period_size;\n\n\t\tdac33->mode1_us_burst = SAMPLES_TO_US(dac33->burst_rate,\n\t\t\t\t\t\t      dac33->nsample);\n\t\tdac33->t_stamp1 = 0;\n\t\tdac33->t_stamp2 = 0;\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\tdac33->uthr = UTHR_FROM_PERIOD_SIZE(period_size, rate,\n\t\t\t\t\t\t    dac33->burst_rate) + 9;\n\t\tif (dac33->uthr > (dac33->fifo_size - DAC33_MODE7_MARGIN))\n\t\t\tdac33->uthr = dac33->fifo_size - DAC33_MODE7_MARGIN;\n\t\tif (dac33->uthr < (DAC33_MODE7_MARGIN + 10))\n\t\t\tdac33->uthr = (DAC33_MODE7_MARGIN + 10);\n\n\t\tdac33->mode7_us_to_lthr =\n\t\t\t\tSAMPLES_TO_US(substream->runtime->rate,\n\t\t\t\t\tdac33->uthr - DAC33_MODE7_MARGIN + 1);\n\t\tdac33->t_stamp1 = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n}\n\nstatic int dac33_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (dac33->fifo_mode) {\n\t\t\tdac33->state = DAC33_PREFILL;\n\t\t\tschedule_work(&dac33->work);\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tif (dac33->fifo_mode) {\n\t\t\tdac33->state = DAC33_FLUSH;\n\t\t\tschedule_work(&dac33->work);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic snd_pcm_sframes_t dac33_dai_delay(\n\t\t\tstruct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tunsigned long long t0, t1, t_now;\n\tunsigned int time_delta, uthr;\n\tint samples_out, samples_in, samples;\n\tsnd_pcm_sframes_t delay = 0;\n\tunsigned long flags;\n\n\tswitch (dac33->fifo_mode) {\n\tcase DAC33_FIFO_BYPASS:\n\t\tbreak;\n\tcase DAC33_FIFO_MODE1:\n\t\tspin_lock_irqsave(&dac33->lock, flags);\n\t\tt0 = dac33->t_stamp1;\n\t\tt1 = dac33->t_stamp2;\n\t\tspin_unlock_irqrestore(&dac33->lock, flags);\n\t\tt_now = ktime_to_us(ktime_get());\n\n\t\t \n\t\tif (!t1)\n\t\t\tgoto out;\n\n\t\tif (t0 > t1) {\n\t\t\t \n\t\t\ttime_delta = t_now - t0;\n\t\t\tsamples_out = time_delta ? US_TO_SAMPLES(\n\t\t\t\t\t\tsubstream->runtime->rate,\n\t\t\t\t\t\ttime_delta) : 0;\n\n\t\t\tif (likely(dac33->alarm_threshold > samples_out))\n\t\t\t\tdelay = dac33->alarm_threshold - samples_out;\n\t\t\telse\n\t\t\t\tdelay = 0;\n\t\t} else if ((t_now - t1) <= dac33->mode1_us_burst) {\n\t\t\t \n\t\t\ttime_delta = t_now - t0;\n\t\t\tsamples_out = time_delta ? US_TO_SAMPLES(\n\t\t\t\t\t\tsubstream->runtime->rate,\n\t\t\t\t\t\ttime_delta) : 0;\n\n\t\t\ttime_delta = t_now - t1;\n\t\t\tsamples_in = time_delta ? US_TO_SAMPLES(\n\t\t\t\t\t\tdac33->burst_rate,\n\t\t\t\t\t\ttime_delta) : 0;\n\n\t\t\tsamples = dac33->alarm_threshold;\n\t\t\tsamples += (samples_in - samples_out);\n\n\t\t\tif (likely(samples > 0))\n\t\t\t\tdelay = samples;\n\t\t\telse\n\t\t\t\tdelay = 0;\n\t\t} else {\n\t\t\t \n\t\t\ttime_delta = t_now - t0;\n\t\t\tsamples_out = time_delta ? US_TO_SAMPLES(\n\t\t\t\t\t\tsubstream->runtime->rate,\n\t\t\t\t\t\ttime_delta) : 0;\n\n\t\t\tsamples_in = dac33->nsample;\n\t\t\tsamples = dac33->alarm_threshold;\n\t\t\tsamples += (samples_in - samples_out);\n\n\t\t\tif (likely(samples > 0))\n\t\t\t\tdelay = samples > dac33->fifo_size ?\n\t\t\t\t\tdac33->fifo_size : samples;\n\t\t\telse\n\t\t\t\tdelay = 0;\n\t\t}\n\t\tbreak;\n\tcase DAC33_FIFO_MODE7:\n\t\tspin_lock_irqsave(&dac33->lock, flags);\n\t\tt0 = dac33->t_stamp1;\n\t\tuthr = dac33->uthr;\n\t\tspin_unlock_irqrestore(&dac33->lock, flags);\n\t\tt_now = ktime_to_us(ktime_get());\n\n\t\t \n\t\tif (!t0)\n\t\t\tgoto out;\n\n\t\tif (t_now <= t0) {\n\t\t\t \n\t\t\tdelay = uthr;\n\t\t\tgoto out;\n\t\t}\n\n\t\ttime_delta = t_now - t0;\n\t\tif (time_delta <= dac33->mode7_us_to_lthr) {\n\t\t\t \n\t\t\tsamples_out = US_TO_SAMPLES(\n\t\t\t\t\tsubstream->runtime->rate,\n\t\t\t\t\ttime_delta);\n\n\t\t\tif (likely(uthr > samples_out))\n\t\t\t\tdelay = uthr - samples_out;\n\t\t\telse\n\t\t\t\tdelay = 0;\n\t\t} else {\n\t\t\t \n\t\t\ttime_delta = time_delta - dac33->mode7_us_to_lthr;\n\n\t\t\tsamples_out = US_TO_SAMPLES(\n\t\t\t\t\tsubstream->runtime->rate,\n\t\t\t\t\ttime_delta);\n\t\t\tsamples_in = US_TO_SAMPLES(\n\t\t\t\t\tdac33->burst_rate,\n\t\t\t\t\ttime_delta);\n\t\t\tdelay = DAC33_MODE7_MARGIN + samples_in - samples_out;\n\n\t\t\tif (unlikely(delay > uthr))\n\t\t\t\tdelay = uthr;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(component->dev, \"Unhandled FIFO mode: %d\\n\",\n\t\t\t\t\t\t\tdac33->fifo_mode);\n\t\tbreak;\n\t}\nout:\n\treturn delay;\n}\n\nstatic int dac33_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 ioc_reg, asrcb_reg;\n\n\tioc_reg = dac33_read_reg_cache(component, DAC33_INT_OSC_CTRL);\n\tasrcb_reg = dac33_read_reg_cache(component, DAC33_ASRC_CTRL_B);\n\tswitch (clk_id) {\n\tcase TLV320DAC33_MCLK:\n\t\tioc_reg |= DAC33_REFSEL;\n\t\tasrcb_reg |= DAC33_SRCREFSEL;\n\t\tbreak;\n\tcase TLV320DAC33_SLEEPCLK:\n\t\tioc_reg &= ~DAC33_REFSEL;\n\t\tasrcb_reg &= ~DAC33_SRCREFSEL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock ID (%d)\\n\", clk_id);\n\t\tbreak;\n\t}\n\tdac33->refclk = freq;\n\n\tdac33_write_reg_cache(component, DAC33_INT_OSC_CTRL, ioc_reg);\n\tdac33_write_reg_cache(component, DAC33_ASRC_CTRL_B, asrcb_reg);\n\n\treturn 0;\n}\n\nstatic int dac33_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t     unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tu8 aictrl_a, aictrl_b;\n\n\taictrl_a = dac33_read_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_A);\n\taictrl_b = dac33_read_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_B);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\taictrl_a |= (DAC33_MSBCLK | DAC33_MSWCLK);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tif (dac33->fifo_mode) {\n\t\t\tdev_err(component->dev, \"FIFO mode requires provider mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\taictrl_a &= ~(DAC33_MSBCLK | DAC33_MSWCLK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\taictrl_a &= ~DAC33_AFMT_MASK;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taictrl_a |= DAC33_AFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taictrl_a |= DAC33_AFMT_DSP;\n\t\taictrl_b &= ~DAC33_DATA_DELAY_MASK;\n\t\taictrl_b |= DAC33_DATA_DELAY(0);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\taictrl_a |= DAC33_AFMT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taictrl_a |= DAC33_AFMT_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported format (%u)\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tdac33_write_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_A, aictrl_a);\n\tdac33_write_reg_cache(component, DAC33_SER_AUDIOIF_CTRL_B, aictrl_b);\n\n\treturn 0;\n}\n\nstatic int dac33_soc_probe(struct snd_soc_component *component)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tdac33->component = component;\n\n\t \n\tret = dac33_hard_power(component, 1);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to power up component: %d\\n\", ret);\n\t\tgoto err_power;\n\t}\n\tret = dac33_read_id(component);\n\tdac33_hard_power(component, 0);\n\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\tret = -ENODEV;\n\t\tgoto err_power;\n\t}\n\n\t \n\tif (dac33->irq >= 0) {\n\t\tret = request_irq(dac33->irq, dac33_interrupt_handler,\n\t\t\t\t  IRQF_TRIGGER_RISING,\n\t\t\t\t  component->name, component);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Could not request IRQ%d (%d)\\n\",\n\t\t\t\t\t\tdac33->irq, ret);\n\t\t\tdac33->irq = -1;\n\t\t}\n\t\tif (dac33->irq != -1) {\n\t\t\tINIT_WORK(&dac33->work, dac33_work);\n\t\t}\n\t}\n\n\t \n\tif (dac33->irq >= 0)\n\t\tsnd_soc_add_component_controls(component, dac33_mode_snd_controls,\n\t\t\t\t     ARRAY_SIZE(dac33_mode_snd_controls));\n\nerr_power:\n\treturn ret;\n}\n\nstatic void dac33_soc_remove(struct snd_soc_component *component)\n{\n\tstruct tlv320dac33_priv *dac33 = snd_soc_component_get_drvdata(component);\n\n\tif (dac33->irq >= 0) {\n\t\tfree_irq(dac33->irq, dac33->component);\n\t\tflush_work(&dac33->work);\n\t}\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_tlv320dac33 = {\n\t.read\t\t\t= dac33_read_reg_cache,\n\t.write\t\t\t= dac33_write_locked,\n\t.set_bias_level\t\t= dac33_set_bias_level,\n\t.probe\t\t\t= dac33_soc_probe,\n\t.remove\t\t\t= dac33_soc_remove,\n\t.controls\t\t= dac33_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(dac33_snd_controls),\n\t.dapm_widgets\t\t= dac33_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(dac33_dapm_widgets),\n\t.dapm_routes\t\t= audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n#define DAC33_RATES\t(SNDRV_PCM_RATE_44100 | \\\n\t\t\t SNDRV_PCM_RATE_48000)\n#define DAC33_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops dac33_dai_ops = {\n\t.startup\t= dac33_startup,\n\t.shutdown\t= dac33_shutdown,\n\t.hw_params\t= dac33_hw_params,\n\t.trigger\t= dac33_pcm_trigger,\n\t.delay\t\t= dac33_dai_delay,\n\t.set_sysclk\t= dac33_set_dai_sysclk,\n\t.set_fmt\t= dac33_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver dac33_dai = {\n\t.name = \"tlv320dac33-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = DAC33_RATES,\n\t\t.formats = DAC33_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &dac33_dai_ops,\n};\n\nstatic int dac33_i2c_probe(struct i2c_client *client)\n{\n\tstruct tlv320dac33_platform_data *pdata;\n\tstruct tlv320dac33_priv *dac33;\n\tint ret, i;\n\n\tif (client->dev.platform_data == NULL) {\n\t\tdev_err(&client->dev, \"Platform data not set\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpdata = client->dev.platform_data;\n\n\tdac33 = devm_kzalloc(&client->dev, sizeof(struct tlv320dac33_priv),\n\t\t\t     GFP_KERNEL);\n\tif (dac33 == NULL)\n\t\treturn -ENOMEM;\n\n\tdac33->reg_cache = devm_kmemdup(&client->dev,\n\t\t\t\t\tdac33_reg,\n\t\t\t\t\tARRAY_SIZE(dac33_reg) * sizeof(u8),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!dac33->reg_cache)\n\t\treturn -ENOMEM;\n\n\tdac33->i2c = client;\n\tmutex_init(&dac33->mutex);\n\tspin_lock_init(&dac33->lock);\n\n\ti2c_set_clientdata(client, dac33);\n\n\tdac33->power_gpio = pdata->power_gpio;\n\tdac33->burst_bclkdiv = pdata->burst_bclkdiv;\n\tdac33->keep_bclk = pdata->keep_bclk;\n\tdac33->mode1_latency = pdata->mode1_latency;\n\tif (!dac33->mode1_latency)\n\t\tdac33->mode1_latency = 10000;  \n\tdac33->irq = client->irq;\n\t \n\tdac33->fifo_mode = DAC33_FIFO_BYPASS;\n\n\t \n\tif (dac33->power_gpio >= 0) {\n\t\tret = gpio_request(dac33->power_gpio, \"tlv320dac33 reset\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&client->dev,\n\t\t\t\t\"Failed to request reset GPIO (%d)\\n\",\n\t\t\t\tdac33->power_gpio);\n\t\t\tgoto err_gpio;\n\t\t}\n\t\tgpio_direction_output(dac33->power_gpio, 0);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dac33->supplies); i++)\n\t\tdac33->supplies[i].supply = dac33_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&client->dev, ARRAY_SIZE(dac33->supplies),\n\t\t\t\t dac33->supplies);\n\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\tgoto err_get;\n\t}\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t&soc_component_dev_tlv320dac33, &dac33_dai, 1);\n\tif (ret < 0)\n\t\tgoto err_get;\n\n\treturn ret;\nerr_get:\n\tif (dac33->power_gpio >= 0)\n\t\tgpio_free(dac33->power_gpio);\nerr_gpio:\n\treturn ret;\n}\n\nstatic void dac33_i2c_remove(struct i2c_client *client)\n{\n\tstruct tlv320dac33_priv *dac33 = i2c_get_clientdata(client);\n\n\tif (unlikely(dac33->chip_power))\n\t\tdac33_hard_power(dac33->component, 0);\n\n\tif (dac33->power_gpio >= 0)\n\t\tgpio_free(dac33->power_gpio);\n}\n\nstatic const struct i2c_device_id tlv320dac33_i2c_id[] = {\n\t{\n\t\t.name = \"tlv320dac33\",\n\t\t.driver_data = 0,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, tlv320dac33_i2c_id);\n\nstatic struct i2c_driver tlv320dac33_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tlv320dac33-codec\",\n\t},\n\t.probe\t\t= dac33_i2c_probe,\n\t.remove\t\t= dac33_i2c_remove,\n\t.id_table\t= tlv320dac33_i2c_id,\n};\n\nmodule_i2c_driver(tlv320dac33_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC TLV320DAC33 codec driver\");\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}