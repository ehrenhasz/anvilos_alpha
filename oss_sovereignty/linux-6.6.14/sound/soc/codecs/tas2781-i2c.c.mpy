{
  "module_name": "tas2781-i2c.c",
  "hash_id": "cb5b80acb8544ab8188a24e0a9b1e0ec2efe0899ee2b16ba2c7f1cc88e7a55d5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2781-i2c.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/crc8.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tas2781.h>\n#include <sound/tlv.h>\n#include <sound/tas2781-tlv.h>\n\nstatic const struct i2c_device_id tasdevice_id[] = {\n\t{ \"tas2781\", TAS2781 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, tasdevice_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tasdevice_of_match[] = {\n\t{ .compatible = \"ti,tas2781\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tasdevice_of_match);\n#endif\n\n \nstatic int tas2781_digital_getvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_digital_getvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_digital_putvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_digital_putvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_amp_getvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_amp_getvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_amp_putvol(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv =\n\t\tsnd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\n\treturn tasdevice_amp_putvol(tas_priv, ucontrol, mc);\n}\n\nstatic int tas2781_force_fwload_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = (int)tas_priv->force_fwload_status;\n\tdev_dbg(tas_priv->dev, \"%s : Force FWload %s\\n\", __func__,\n\t\t\ttas_priv->force_fwload_status ? \"ON\" : \"OFF\");\n\n\treturn 0;\n}\n\nstatic int tas2781_force_fwload_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tbool change, val = (bool)ucontrol->value.integer.value[0];\n\n\tif (tas_priv->force_fwload_status == val)\n\t\tchange = false;\n\telse {\n\t\tchange = true;\n\t\ttas_priv->force_fwload_status = val;\n\t}\n\tdev_dbg(tas_priv->dev, \"%s : Force FWload %s\\n\", __func__,\n\t\ttas_priv->force_fwload_status ? \"ON\" : \"OFF\");\n\n\treturn change;\n}\n\nstatic const struct snd_kcontrol_new tas2781_snd_controls[] = {\n\tSOC_SINGLE_RANGE_EXT_TLV(\"Speaker Analog Gain\", TAS2781_AMP_LEVEL,\n\t\t1, 0, 20, 0, tas2781_amp_getvol,\n\t\ttas2781_amp_putvol, amp_vol_tlv),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"Speaker Digital Gain\", TAS2781_DVC_LVL,\n\t\t0, 0, 200, 1, tas2781_digital_getvol,\n\t\ttas2781_digital_putvol, dvc_tlv),\n\tSOC_SINGLE_BOOL_EXT(\"Speaker Force Firmware Load\", 0,\n\t\ttas2781_force_fwload_get, tas2781_force_fwload_put),\n};\n\nstatic int tasdevice_set_profile_id(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tint ret = 0;\n\n\tif (tas_priv->rcabin.profile_cfg_id !=\n\t\tucontrol->value.integer.value[0]) {\n\t\ttas_priv->rcabin.profile_cfg_id =\n\t\t\tucontrol->value.integer.value[0];\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_info_programs(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = (int)tas_fw->nr_programs;\n\n\treturn 0;\n}\n\nstatic int tasdevice_info_configurations(\n\tstruct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *codec =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tstruct tasdevice_fw *tas_fw = tas_priv->fmw;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = (int)tas_fw->nr_configurations - 1;\n\n\treturn 0;\n}\n\nstatic int tasdevice_info_profile(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = tas_priv->rcabin.ncfgs - 1;\n\n\treturn 0;\n}\n\nstatic int tasdevice_get_profile_id(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = tas_priv->rcabin.profile_cfg_id;\n\n\treturn 0;\n}\n\nstatic int tasdevice_create_control(struct tasdevice_priv *tas_priv)\n{\n\tstruct snd_kcontrol_new *prof_ctrls;\n\tint nr_controls = 1;\n\tint mix_index = 0;\n\tint ret;\n\tchar *name;\n\n\tprof_ctrls = devm_kcalloc(tas_priv->dev, nr_controls,\n\t\tsizeof(prof_ctrls[0]), GFP_KERNEL);\n\tif (!prof_ctrls) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tname = devm_kzalloc(tas_priv->dev, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\tGFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tscnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, \"Speaker Profile Id\");\n\tprof_ctrls[mix_index].name = name;\n\tprof_ctrls[mix_index].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tprof_ctrls[mix_index].info = tasdevice_info_profile;\n\tprof_ctrls[mix_index].get = tasdevice_get_profile_id;\n\tprof_ctrls[mix_index].put = tasdevice_set_profile_id;\n\tmix_index++;\n\n\tret = snd_soc_add_component_controls(tas_priv->codec,\n\t\tprof_ctrls, nr_controls < mix_index ? nr_controls : mix_index);\n\nout:\n\treturn ret;\n}\n\nstatic int tasdevice_program_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = tas_priv->cur_prog;\n\n\treturn 0;\n}\n\nstatic int tasdevice_program_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tunsigned int nr_program = ucontrol->value.integer.value[0];\n\tint ret = 0;\n\n\tif (tas_priv->cur_prog != nr_program) {\n\t\ttas_priv->cur_prog = nr_program;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_configuration_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = tas_priv->cur_conf;\n\n\treturn 0;\n}\n\nstatic int tasdevice_configuration_put(\n\tstruct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tunsigned int nr_configuration = ucontrol->value.integer.value[0];\n\tint ret = 0;\n\n\tif (tas_priv->cur_conf != nr_configuration) {\n\t\ttas_priv->cur_conf = nr_configuration;\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_dsp_create_ctrls(\n\tstruct tasdevice_priv *tas_priv)\n{\n\tstruct snd_kcontrol_new *dsp_ctrls;\n\tchar *prog_name, *conf_name;\n\tint nr_controls = 2;\n\tint mix_index = 0;\n\tint ret;\n\n\t \n\tdsp_ctrls = devm_kcalloc(tas_priv->dev, nr_controls,\n\t\tsizeof(dsp_ctrls[0]), GFP_KERNEL);\n\tif (!dsp_ctrls) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tprog_name = devm_kzalloc(tas_priv->dev,\n\t\tSNDRV_CTL_ELEM_ID_NAME_MAXLEN, GFP_KERNEL);\n\tconf_name = devm_kzalloc(tas_priv->dev, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\tGFP_KERNEL);\n\tif (!prog_name || !conf_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tscnprintf(prog_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\t\"Speaker Program Id\");\n\tdsp_ctrls[mix_index].name = prog_name;\n\tdsp_ctrls[mix_index].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tdsp_ctrls[mix_index].info = tasdevice_info_programs;\n\tdsp_ctrls[mix_index].get = tasdevice_program_get;\n\tdsp_ctrls[mix_index].put = tasdevice_program_put;\n\tmix_index++;\n\n\tscnprintf(conf_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\t\"Speaker Config Id\");\n\tdsp_ctrls[mix_index].name = conf_name;\n\tdsp_ctrls[mix_index].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tdsp_ctrls[mix_index].info = tasdevice_info_configurations;\n\tdsp_ctrls[mix_index].get = tasdevice_configuration_get;\n\tdsp_ctrls[mix_index].put = tasdevice_configuration_put;\n\tmix_index++;\n\n\tret = snd_soc_add_component_controls(tas_priv->codec, dsp_ctrls,\n\t\tnr_controls < mix_index ? nr_controls : mix_index);\n\nout:\n\treturn ret;\n}\n\nstatic void tasdevice_fw_ready(const struct firmware *fmw,\n\tvoid *context)\n{\n\tstruct tasdevice_priv *tas_priv = context;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&tas_priv->codec_lock);\n\n\tret = tasdevice_rca_parser(tas_priv, fmw);\n\tif (ret)\n\t\tgoto out;\n\ttasdevice_create_control(tas_priv);\n\n\ttasdevice_dsp_remove(tas_priv);\n\ttasdevice_calbin_remove(tas_priv);\n\ttas_priv->fw_state = TASDEVICE_DSP_FW_PENDING;\n\tscnprintf(tas_priv->coef_binaryname, 64, \"%s_coef.bin\",\n\t\ttas_priv->dev_name);\n\tret = tasdevice_dsp_parser(tas_priv);\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"dspfw load %s error\\n\",\n\t\t\ttas_priv->coef_binaryname);\n\t\ttas_priv->fw_state = TASDEVICE_DSP_FW_FAIL;\n\t\tgoto out;\n\t}\n\ttasdevice_dsp_create_ctrls(tas_priv);\n\n\ttas_priv->fw_state = TASDEVICE_DSP_FW_ALL_OK;\n\n\t \n\tfor (i = 0; i < tas_priv->ndev; i++) {\n\t\tscnprintf(tas_priv->cal_binaryname[i], 64, \"%s_cal_0x%02x.bin\",\n\t\t\ttas_priv->dev_name, tas_priv->tasdevice[i].dev_addr);\n\t\tret = tas2781_load_calibration(tas_priv,\n\t\t\ttas_priv->cal_binaryname[i], i);\n\t\tif (ret != 0)\n\t\t\tdev_err(tas_priv->dev,\n\t\t\t\t\"%s: load %s error, default will effect\\n\",\n\t\t\t\t__func__, tas_priv->cal_binaryname[i]);\n\t}\n\n\ttasdevice_prmg_calibdata_load(tas_priv, 0);\n\ttas_priv->cur_prog = 0;\nout:\n\tif (tas_priv->fw_state == TASDEVICE_DSP_FW_FAIL) {\n\t\t \n\t\ttasdevice_config_info_remove(tas_priv);\n\t\ttasdevice_dsp_remove(tas_priv);\n\t}\n\tmutex_unlock(&tas_priv->codec_lock);\n\tif (fmw)\n\t\trelease_firmware(fmw);\n}\n\nstatic int tasdevice_dapm_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tint state = 0;\n\n\t \n\tmutex_lock(&tas_priv->codec_lock);\n\tif (event == SND_SOC_DAPM_PRE_PMD)\n\t\tstate = 1;\n\ttasdevice_tuning_switch(tas_priv, state);\n\t \n\tmutex_unlock(&tas_priv->codec_lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget tasdevice_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"ASI\", \"ASI Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT_E(\"ASI OUT\", \"ASI Capture\", 0, SND_SOC_NOPM,\n\t\t0, 0, tasdevice_dapm_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SPK(\"SPK\", tasdevice_dapm_event),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC\")\n};\n\nstatic const struct snd_soc_dapm_route tasdevice_audio_map[] = {\n\t{\"SPK\", NULL, \"ASI\"},\n\t{\"OUT\", NULL, \"SPK\"},\n\t{\"ASI OUT\", NULL, \"DMIC\"}\n};\n\nstatic int tasdevice_startup(struct snd_pcm_substream *substream,\n\t\t\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\tint ret = 0;\n\n\tif (tas_priv->fw_state != TASDEVICE_DSP_FW_ALL_OK) {\n\t\tdev_err(tas_priv->dev, \"DSP bin file not loaded\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int tasdevice_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct tasdevice_priv *tas_priv = snd_soc_dai_get_drvdata(dai);\n\tunsigned int slot_width;\n\tunsigned int fsrate;\n\tint bclk_rate;\n\tint rc = 0;\n\n\tfsrate = params_rate(params);\n\tswitch (fsrate) {\n\tcase 48000:\n\tcase 44100:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas_priv->dev, \"%s: incorrect sample rate = %u\\n\",\n\t\t\t__func__, fsrate);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tslot_width = params_width(params);\n\tswitch (slot_width) {\n\tcase 16:\n\tcase 20:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas_priv->dev, \"%s: incorrect slot width = %u\\n\",\n\t\t\t__func__, slot_width);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbclk_rate = snd_soc_params_to_bclk(params);\n\tif (bclk_rate < 0) {\n\t\tdev_err(tas_priv->dev, \"%s: incorrect bclk rate = %d\\n\",\n\t\t\t__func__, bclk_rate);\n\t\trc = bclk_rate;\n\t\tgoto out;\n\t}\n\nout:\n\treturn rc;\n}\n\nstatic int tasdevice_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct tasdevice_priv *tas_priv = snd_soc_dai_get_drvdata(codec_dai);\n\n\ttas_priv->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tasdevice_dai_ops = {\n\t.startup = tasdevice_startup,\n\t.hw_params = tasdevice_hw_params,\n\t.set_sysclk = tasdevice_set_dai_sysclk,\n};\n\nstatic struct snd_soc_dai_driver tasdevice_dai_driver[] = {\n\t{\n\t\t.name = \"tas2781_codec\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates\t = TASDEVICE_RATES,\n\t\t\t.formats\t= TASDEVICE_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates\t = TASDEVICE_RATES,\n\t\t\t.formats\t= TASDEVICE_FORMATS,\n\t\t},\n\t\t.ops = &tasdevice_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic int tasdevice_codec_probe(struct snd_soc_component *codec)\n{\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\treturn tascodec_init(tas_priv, codec, tasdevice_fw_ready);\n}\n\nstatic void tasdevice_deinit(void *context)\n{\n\tstruct tasdevice_priv *tas_priv = (struct tasdevice_priv *) context;\n\n\ttasdevice_config_info_remove(tas_priv);\n\ttasdevice_dsp_remove(tas_priv);\n\ttasdevice_calbin_remove(tas_priv);\n\ttas_priv->fw_state = TASDEVICE_DSP_FW_PENDING;\n}\n\nstatic void tasdevice_codec_remove(\n\tstruct snd_soc_component *codec)\n{\n\tstruct tasdevice_priv *tas_priv = snd_soc_component_get_drvdata(codec);\n\n\ttasdevice_deinit(tas_priv);\n}\n\nstatic const struct snd_soc_component_driver\n\tsoc_codec_driver_tasdevice = {\n\t.probe\t\t\t= tasdevice_codec_probe,\n\t.remove\t\t\t= tasdevice_codec_remove,\n\t.controls\t\t= tas2781_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas2781_snd_controls),\n\t.dapm_widgets\t\t= tasdevice_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tasdevice_dapm_widgets),\n\t.dapm_routes\t\t= tasdevice_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tasdevice_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void tasdevice_parse_dt(struct tasdevice_priv *tas_priv)\n{\n\tstruct i2c_client *client = (struct i2c_client *)tas_priv->client;\n\tunsigned int dev_addrs[TASDEVICE_MAX_CHANNELS];\n\tint rc, i, ndev = 0;\n\n\tif (tas_priv->isacpi) {\n\t\tndev = device_property_read_u32_array(&client->dev,\n\t\t\t\"ti,audio-slots\", NULL, 0);\n\t\tif (ndev <= 0) {\n\t\t\tndev = 1;\n\t\t\tdev_addrs[0] = client->addr;\n\t\t} else {\n\t\t\tndev = (ndev < ARRAY_SIZE(dev_addrs))\n\t\t\t\t? ndev : ARRAY_SIZE(dev_addrs);\n\t\t\tndev = device_property_read_u32_array(&client->dev,\n\t\t\t\t\"ti,audio-slots\", dev_addrs, ndev);\n\t\t}\n\n\t\ttas_priv->irq_info.irq_gpio =\n\t\t\tacpi_dev_gpio_irq_get(ACPI_COMPANION(&client->dev), 0);\n\t} else {\n\t\tstruct device_node *np = tas_priv->dev->of_node;\n#ifdef CONFIG_OF\n\t\tconst __be32 *reg, *reg_end;\n\t\tint len, sw, aw;\n\n\t\taw = of_n_addr_cells(np);\n\t\tsw = of_n_size_cells(np);\n\t\tif (sw == 0) {\n\t\t\treg = (const __be32 *)of_get_property(np,\n\t\t\t\t\"reg\", &len);\n\t\t\treg_end = reg + len/sizeof(*reg);\n\t\t\tndev = 0;\n\t\t\tdo {\n\t\t\t\tdev_addrs[ndev] = of_read_number(reg, aw);\n\t\t\t\treg += aw;\n\t\t\t\tndev++;\n\t\t\t} while (reg < reg_end);\n\t\t} else {\n\t\t\tndev = 1;\n\t\t\tdev_addrs[0] = client->addr;\n\t\t}\n#else\n\t\tndev = 1;\n\t\tdev_addrs[0] = client->addr;\n#endif\n\t\ttas_priv->irq_info.irq_gpio = of_irq_get(np, 0);\n\t}\n\ttas_priv->ndev = ndev;\n\tfor (i = 0; i < ndev; i++)\n\t\ttas_priv->tasdevice[i].dev_addr = dev_addrs[i];\n\n\ttas_priv->reset = devm_gpiod_get_optional(&client->dev,\n\t\t\t\"reset-gpios\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tas_priv->reset))\n\t\tdev_err(tas_priv->dev, \"%s Can't get reset GPIO\\n\",\n\t\t\t__func__);\n\n\tstrcpy(tas_priv->dev_name, tasdevice_id[tas_priv->chip_id].name);\n\n\tif (gpio_is_valid(tas_priv->irq_info.irq_gpio)) {\n\t\trc = gpio_request(tas_priv->irq_info.irq_gpio,\n\t\t\t\t\"AUDEV-IRQ\");\n\t\tif (!rc) {\n\t\t\tgpio_direction_input(\n\t\t\t\ttas_priv->irq_info.irq_gpio);\n\n\t\t\ttas_priv->irq_info.irq =\n\t\t\t\tgpio_to_irq(tas_priv->irq_info.irq_gpio);\n\t\t} else\n\t\t\tdev_err(tas_priv->dev, \"%s: GPIO %d request error\\n\",\n\t\t\t\t__func__, tas_priv->irq_info.irq_gpio);\n\t} else\n\t\tdev_err(tas_priv->dev,\n\t\t\t\"Looking up irq-gpio property failed %d\\n\",\n\t\t\ttas_priv->irq_info.irq_gpio);\n}\n\nstatic int tasdevice_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct i2c_device_id *id = i2c_match_id(tasdevice_id, i2c);\n\tconst struct acpi_device_id *acpi_id;\n\tstruct tasdevice_priv *tas_priv;\n\tint ret;\n\n\ttas_priv = tasdevice_kzalloc(i2c);\n\tif (!tas_priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&i2c->dev, tas_priv);\n\n\tif (ACPI_HANDLE(&i2c->dev)) {\n\t\tacpi_id = acpi_match_device(i2c->dev.driver->acpi_match_table,\n\t\t\t\t&i2c->dev);\n\t\tif (!acpi_id) {\n\t\t\tdev_err(&i2c->dev, \"No driver data\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\ttas_priv->chip_id = acpi_id->driver_data;\n\t\ttas_priv->isacpi = true;\n\t} else {\n\t\ttas_priv->chip_id = id ? id->driver_data : 0;\n\t\ttas_priv->isacpi = false;\n\t}\n\n\ttasdevice_parse_dt(tas_priv);\n\n\tret = tasdevice_init(tas_priv);\n\tif (ret)\n\t\tgoto err;\n\n\tret = devm_snd_soc_register_component(tas_priv->dev,\n\t\t&soc_codec_driver_tasdevice,\n\t\ttasdevice_dai_driver, ARRAY_SIZE(tasdevice_dai_driver));\n\tif (ret) {\n\t\tdev_err(tas_priv->dev, \"%s: codec register error:0x%08x\\n\",\n\t\t\t__func__, ret);\n\t\tgoto err;\n\t}\nerr:\n\tif (ret < 0)\n\t\ttasdevice_remove(tas_priv);\n\treturn ret;\n}\n\nstatic void tasdevice_i2c_remove(struct i2c_client *client)\n{\n\tstruct tasdevice_priv *tas_priv = i2c_get_clientdata(client);\n\n\ttasdevice_remove(tas_priv);\n}\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id tasdevice_acpi_match[] = {\n\t{ \"TAS2781\", TAS2781 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(acpi, tasdevice_acpi_match);\n#endif\n\nstatic struct i2c_driver tasdevice_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas2781-codec\",\n\t\t.of_match_table = of_match_ptr(tasdevice_of_match),\n#ifdef CONFIG_ACPI\n\t\t.acpi_match_table = ACPI_PTR(tasdevice_acpi_match),\n#endif\n\t},\n\t.probe\t= tasdevice_i2c_probe,\n\t.remove = tasdevice_i2c_remove,\n\t.id_table = tasdevice_id,\n};\n\nmodule_i2c_driver(tasdevice_i2c_driver);\n\nMODULE_AUTHOR(\"Shenghao Ding <shenghao-ding@ti.com>\");\nMODULE_AUTHOR(\"Kevin Lu <kevin-lu@ti.com>\");\nMODULE_DESCRIPTION(\"ASoC TAS2781 Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_TAS2781_FMWLIB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}