{
  "module_name": "pcm179x.c",
  "hash_id": "16f6c17654f41c10b1a50c96edcc504e24af8c7a7e6656a2b6bff02b4c801f21",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm179x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/of.h>\n\n#include \"pcm179x.h\"\n\n#define PCM179X_DAC_VOL_LEFT\t0x10\n#define PCM179X_DAC_VOL_RIGHT\t0x11\n#define PCM179X_FMT_CONTROL\t0x12\n#define PCM179X_MODE_CONTROL\t0x13\n#define PCM179X_SOFT_MUTE\tPCM179X_FMT_CONTROL\n\n#define PCM179X_FMT_MASK\t0x70\n#define PCM179X_FMT_SHIFT\t4\n#define PCM179X_MUTE_MASK\t0x01\n#define PCM179X_MUTE_SHIFT\t0\n#define PCM179X_ATLD_ENABLE\t(1 << 7)\n\nstatic const struct reg_default pcm179x_reg_defaults[] = {\n\t{ 0x10, 0xff },\n\t{ 0x11, 0xff },\n\t{ 0x12, 0x50 },\n\t{ 0x13, 0x00 },\n\t{ 0x14, 0x00 },\n\t{ 0x15, 0x01 },\n\t{ 0x16, 0x00 },\n\t{ 0x17, 0x00 },\n};\n\nstatic bool pcm179x_accessible_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg >= 0x10 && reg <= 0x17;\n}\n\nstatic bool pcm179x_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tbool accessible;\n\n\taccessible = pcm179x_accessible_reg(dev, reg);\n\n\treturn accessible && reg != 0x16 && reg != 0x17;\n}\n\nstruct pcm179x_private {\n\tstruct regmap *regmap;\n\tunsigned int format;\n\tunsigned int rate;\n};\n\nstatic int pcm179x_set_dai_fmt(struct snd_soc_dai *codec_dai,\n                             unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct pcm179x_private *priv = snd_soc_component_get_drvdata(component);\n\n\tpriv->format = format;\n\n\treturn 0;\n}\n\nstatic int pcm179x_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm179x_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regmap_update_bits(priv->regmap, PCM179X_SOFT_MUTE,\n\t\t\t\t PCM179X_MUTE_MASK, !!mute);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int pcm179x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm179x_private *priv = snd_soc_component_get_drvdata(component);\n\tint val = 0, ret;\n\n\tpriv->rate = params_rate(params);\n\n\tswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tval = 2;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tswitch (params_width(params)) {\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tval = 5;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tval = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = val << PCM179X_FMT_SHIFT | PCM179X_ATLD_ENABLE;\n\n\tret = regmap_update_bits(priv->regmap, PCM179X_FMT_CONTROL,\n\t\t\t\t PCM179X_FMT_MASK | PCM179X_ATLD_ENABLE, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops pcm179x_dai_ops = {\n\t.set_fmt\t= pcm179x_set_dai_fmt,\n\t.hw_params\t= pcm179x_hw_params,\n\t.mute_stream\t= pcm179x_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic const DECLARE_TLV_DB_SCALE(pcm179x_dac_tlv, -12000, 50, 1);\n\nstatic const struct snd_kcontrol_new pcm179x_controls[] = {\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC Playback Volume\", PCM179X_DAC_VOL_LEFT,\n\t\t\t PCM179X_DAC_VOL_RIGHT, 0, 0xf, 0xff, 0,\n\t\t\t pcm179x_dac_tlv),\n\tSOC_SINGLE(\"DAC Invert Output Switch\", PCM179X_MODE_CONTROL, 7, 1, 0),\n\tSOC_SINGLE(\"DAC Rolloff Filter Switch\", PCM179X_MODE_CONTROL, 1, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget pcm179x_dapm_widgets[] = {\nSND_SOC_DAPM_OUTPUT(\"IOUTL+\"),\nSND_SOC_DAPM_OUTPUT(\"IOUTL-\"),\nSND_SOC_DAPM_OUTPUT(\"IOUTR+\"),\nSND_SOC_DAPM_OUTPUT(\"IOUTR-\"),\n};\n\nstatic const struct snd_soc_dapm_route pcm179x_dapm_routes[] = {\n\t{ \"IOUTL+\", NULL, \"Playback\" },\n\t{ \"IOUTL-\", NULL, \"Playback\" },\n\t{ \"IOUTR+\", NULL, \"Playback\" },\n\t{ \"IOUTR-\", NULL, \"Playback\" },\n};\n\nstatic struct snd_soc_dai_driver pcm179x_dai = {\n\t.name = \"pcm179x-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 10000,\n\t\t.rate_max = 200000,\n\t\t.formats = PCM1792A_FORMATS, },\n\t.ops = &pcm179x_dai_ops,\n};\n\nconst struct regmap_config pcm179x_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= 23,\n\t.reg_defaults\t\t= pcm179x_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(pcm179x_reg_defaults),\n\t.writeable_reg\t\t= pcm179x_writeable_reg,\n\t.readable_reg\t\t= pcm179x_accessible_reg,\n};\nEXPORT_SYMBOL_GPL(pcm179x_regmap_config);\n\nstatic const struct snd_soc_component_driver soc_component_dev_pcm179x = {\n\t.controls\t\t= pcm179x_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm179x_controls),\n\t.dapm_widgets\t\t= pcm179x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm179x_dapm_widgets),\n\t.dapm_routes\t\t= pcm179x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm179x_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint pcm179x_common_init(struct device *dev, struct regmap *regmap)\n{\n\tstruct pcm179x_private *pcm179x;\n\n\tpcm179x = devm_kzalloc(dev, sizeof(struct pcm179x_private),\n\t\t\t\tGFP_KERNEL);\n\tif (!pcm179x)\n\t\treturn -ENOMEM;\n\n\tpcm179x->regmap = regmap;\n\tdev_set_drvdata(dev, pcm179x);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t&soc_component_dev_pcm179x, &pcm179x_dai, 1);\n}\nEXPORT_SYMBOL_GPL(pcm179x_common_init);\n\nMODULE_DESCRIPTION(\"ASoC PCM179X driver\");\nMODULE_AUTHOR(\"Michael Trimarchi <michael@amarulasolutions.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}