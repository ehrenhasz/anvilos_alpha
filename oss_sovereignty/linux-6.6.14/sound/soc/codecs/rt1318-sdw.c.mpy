{
  "module_name": "rt1318-sdw.c",
  "hash_id": "08e75cf6c0590be2a41bebc8b842362b77594968082f20055c52fd397ead5418",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1318-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/dmi.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include \"rt1318-sdw.h\"\n\nstatic const struct reg_sequence rt1318_blind_write[] = {\n\t{ 0xc001, 0x43 },\n\t{ 0xc003, 0xa2 },\n\t{ 0xc004, 0x44 },\n\t{ 0xc005, 0x44 },\n\t{ 0xc006, 0x33 },\n\t{ 0xc007, 0x64 },\n\t{ 0xc320, 0x20 },\n\t{ 0xf203, 0x18 },\n\t{ 0xf211, 0x00 },\n\t{ 0xf212, 0x26 },\n\t{ 0xf20d, 0x17 },\n\t{ 0xf214, 0x06 },\n\t{ 0xf20e, 0x00 },\n\t{ 0xf223, 0x7f },\n\t{ 0xf224, 0xdb },\n\t{ 0xf225, 0xee },\n\t{ 0xf226, 0x3f },\n\t{ 0xf227, 0x0f },\n\t{ 0xf21a, 0x78 },\n\t{ 0xf242, 0x3c },\n\t{ 0xc321, 0x0b },\n\t{ 0xc200, 0xd8 },\n\t{ 0xc201, 0x27 },\n\t{ 0xc202, 0x0f },\n\t{ 0xf800, 0x20 },\n\t{ 0xdf00, 0x10 },\n\t{ 0xdf5f, 0x01 },\n\t{ 0xdf60, 0xa7 },\n\t{ 0xc400, 0x0e },\n\t{ 0xc401, 0x43 },\n\t{ 0xc402, 0xe0 },\n\t{ 0xc403, 0x00 },\n\t{ 0xc404, 0x4c },\n\t{ 0xc407, 0x02 },\n\t{ 0xc408, 0x3f },\n\t{ 0xc300, 0x01 },\n\t{ 0xc206, 0x78 },\n\t{ 0xc203, 0x84 },\n\t{ 0xc120, 0xc0 },\n\t{ 0xc121, 0x03 },\n\t{ 0xe000, 0x88 },\n\t{ 0xc321, 0x09 },\n\t{ 0xc322, 0x01 },\n\t{ 0xe706, 0x0f },\n\t{ 0xe707, 0x30 },\n\t{ 0xe806, 0x0f },\n\t{ 0xe807, 0x30 },\n\t{ 0xed00, 0xb0 },\n\t{ 0xce04, 0x02 },\n\t{ 0xce05, 0x63 },\n\t{ 0xce06, 0x68 },\n\t{ 0xce07, 0x07 },\n\t{ 0xcf04, 0x02 },\n\t{ 0xcf05, 0x63 },\n\t{ 0xcf06, 0x68 },\n\t{ 0xcf07, 0x07 },\n\t{ 0xce60, 0xe3 },\n\t{ 0xc130, 0x51 },\n\t{ 0xf102, 0x00 },\n\t{ 0xf103, 0x00 },\n\t{ 0xf104, 0xf5 },\n\t{ 0xf105, 0x06 },\n\t{ 0xf109, 0x9b },\n\t{ 0xf10a, 0x0b },\n\t{ 0xf10b, 0x4c },\n\t{ 0xf10b, 0x5c },\n\t{ 0xf102, 0x00 },\n\t{ 0xf103, 0x00 },\n\t{ 0xf104, 0xf5 },\n\t{ 0xf105, 0x0b },\n\t{ 0xf109, 0x03 },\n\t{ 0xf10a, 0x0b },\n\t{ 0xf10b, 0x4c },\n\t{ 0xf10b, 0x5c },\n\t{ 0xf102, 0x00 },\n\t{ 0xf103, 0x00 },\n\t{ 0xf104, 0xf5 },\n\t{ 0xf105, 0x0c },\n\t{ 0xf109, 0x7f },\n\t{ 0xf10a, 0x0b },\n\t{ 0xf10b, 0x4c },\n\t{ 0xf10b, 0x5c },\n\n\t{ 0xe604, 0x00 },\n\t{ 0xdb00, 0x0c },\n\t{ 0xdd00, 0x0c },\n\t{ 0xdc19, 0x00 },\n\t{ 0xdc1a, 0xff },\n\t{ 0xdc1b, 0xff },\n\t{ 0xdc1c, 0xff },\n\t{ 0xdc1d, 0x00 },\n\t{ 0xdc1e, 0x00 },\n\t{ 0xdc1f, 0x00 },\n\t{ 0xdc20, 0xff },\n\t{ 0xde19, 0x00 },\n\t{ 0xde1a, 0xff },\n\t{ 0xde1b, 0xff },\n\t{ 0xde1c, 0xff },\n\t{ 0xde1d, 0x00 },\n\t{ 0xde1e, 0x00 },\n\t{ 0xde1f, 0x00 },\n\t{ 0xde20, 0xff },\n\t{ 0xdb32, 0x00 },\n\t{ 0xdd32, 0x00 },\n\t{ 0xdb33, 0x0a },\n\t{ 0xdd33, 0x0a },\n\t{ 0xdb34, 0x1a },\n\t{ 0xdd34, 0x1a },\n\t{ 0xdb17, 0xef },\n\t{ 0xdd17, 0xef },\n\t{ 0xdba7, 0x00 },\n\t{ 0xdba8, 0x64 },\n\t{ 0xdda7, 0x00 },\n\t{ 0xdda8, 0x64 },\n\t{ 0xdb19, 0x40 },\n\t{ 0xdd19, 0x40 },\n\t{ 0xdb00, 0x4c },\n\t{ 0xdb01, 0x79 },\n\t{ 0xdd01, 0x79 },\n\t{ 0xdb04, 0x05 },\n\t{ 0xdb05, 0x03 },\n\t{ 0xdd04, 0x05 },\n\t{ 0xdd05, 0x03 },\n\t{ 0xdbbb, 0x09 },\n\t{ 0xdbbc, 0x30 },\n\t{ 0xdbbd, 0xf0 },\n\t{ 0xdbbe, 0xf1 },\n\t{ 0xddbb, 0x09 },\n\t{ 0xddbc, 0x30 },\n\t{ 0xddbd, 0xf0 },\n\t{ 0xddbe, 0xf1 },\n\t{ 0xdb01, 0x79 },\n\t{ 0xdd01, 0x79 },\n\t{ 0xdc52, 0xef },\n\t{ 0xde52, 0xef },\n\t{ 0x2f55, 0x22 },\n};\n\nstatic const struct reg_default rt1318_reg_defaults[] = {\n\t{ 0x3000, 0x00 },\n\t{ 0x3004, 0x01 },\n\t{ 0x3005, 0x23 },\n\t{ 0x3202, 0x00 },\n\t{ 0x3203, 0x01 },\n\t{ 0x3206, 0x00 },\n\t{ 0xc000, 0x00 },\n\t{ 0xc001, 0x43 },\n\t{ 0xc003, 0x22 },\n\t{ 0xc004, 0x44 },\n\t{ 0xc005, 0x44 },\n\t{ 0xc006, 0x33 },\n\t{ 0xc007, 0x64 },\n\t{ 0xc008, 0x05 },\n\t{ 0xc00a, 0xfc },\n\t{ 0xc00b, 0x0f },\n\t{ 0xc00c, 0x0e },\n\t{ 0xc00d, 0xef },\n\t{ 0xc00e, 0xe5 },\n\t{ 0xc00f, 0xff },\n\t{ 0xc120, 0xc0 },\n\t{ 0xc121, 0x00 },\n\t{ 0xc122, 0x00 },\n\t{ 0xc123, 0x14 },\n\t{ 0xc125, 0x00 },\n\t{ 0xc200, 0x00 },\n\t{ 0xc201, 0x00 },\n\t{ 0xc202, 0x00 },\n\t{ 0xc203, 0x04 },\n\t{ 0xc204, 0x00 },\n\t{ 0xc205, 0x00 },\n\t{ 0xc206, 0x68 },\n\t{ 0xc207, 0x70 },\n\t{ 0xc208, 0x00 },\n\t{ 0xc20a, 0x00 },\n\t{ 0xc20b, 0x01 },\n\t{ 0xc20c, 0x7f },\n\t{ 0xc20d, 0x01 },\n\t{ 0xc20e, 0x7f },\n\t{ 0xc300, 0x00 },\n\t{ 0xc301, 0x00 },\n\t{ 0xc303, 0x80 },\n\t{ 0xc320, 0x00 },\n\t{ 0xc321, 0x09 },\n\t{ 0xc322, 0x02 },\n\t{ 0xc410, 0x04 },\n\t{ 0xc430, 0x00 },\n\t{ 0xc431, 0x00 },\n\t{ 0xca00, 0x10 },\n\t{ 0xca01, 0x00 },\n\t{ 0xca02, 0x0b },\n\t{ 0xca10, 0x10 },\n\t{ 0xca11, 0x00 },\n\t{ 0xca12, 0x0b },\n\t{ 0xdd93, 0x00 },\n\t{ 0xdd94, 0x64 },\n\t{ 0xe300, 0xa0 },\n\t{ 0xed00, 0x80 },\n\t{ 0xed01, 0x0f },\n\t{ 0xed02, 0xff },\n\t{ 0xed03, 0x00 },\n\t{ 0xed04, 0x00 },\n\t{ 0xed05, 0x0f },\n\t{ 0xed06, 0xff },\n\t{ 0xf010, 0x10 },\n\t{ 0xf011, 0xec },\n\t{ 0xf012, 0x68 },\n\t{ 0xf013, 0x21 },\n\t{ 0xf800, 0x00 },\n\t{ 0xf801, 0x12 },\n\t{ 0xf802, 0xe0 },\n\t{ 0xf803, 0x2f },\n\t{ 0xf804, 0x00 },\n\t{ 0xf805, 0x00 },\n\t{ 0xf806, 0x07 },\n\t{ 0xf807, 0xff },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_UDMPU21, RT1318_SDCA_CTL_UDMPU_CLUSTER, 0), 0x00 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_L), 0x01 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_R), 0x01 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_PDE23, RT1318_SDCA_CTL_REQ_POWER_STATE, 0), 0x03 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_CS21, RT1318_SDCA_CTL_SAMPLE_FREQ_INDEX, 0), 0x09 },\n};\n\nstatic bool rt1318_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f55:\n\tcase 0x3000:\n\tcase 0x3004 ... 0x3005:\n\tcase 0x3202 ... 0x3203:\n\tcase 0x3206:\n\tcase 0xc000 ... 0xc00f:\n\tcase 0xc120 ... 0xc125:\n\tcase 0xc200 ... 0xc20e:\n\tcase 0xc300 ... 0xc303:\n\tcase 0xc320 ... 0xc322:\n\tcase 0xc410:\n\tcase 0xc430 ... 0xc431:\n\tcase 0xca00 ... 0xca02:\n\tcase 0xca10 ... 0xca12:\n\tcase 0xcb00 ... 0xcb0b:\n\tcase 0xcc00 ... 0xcce5:\n\tcase 0xcd00 ... 0xcde5:\n\tcase 0xce00 ... 0xce6a:\n\tcase 0xcf00 ... 0xcf53:\n\tcase 0xd000 ... 0xd0cc:\n\tcase 0xd100 ... 0xd1b9:\n\tcase 0xdb00 ... 0xdc53:\n\tcase 0xdd00 ... 0xde53:\n\tcase 0xdf00 ... 0xdf6b:\n\tcase 0xe300:\n\tcase 0xeb00 ... 0xebcc:\n\tcase 0xec00 ... 0xecb9:\n\tcase 0xed00 ... 0xed06:\n\tcase 0xf010 ... 0xf014:\n\tcase 0xf800 ... 0xf807:\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_UDMPU21, RT1318_SDCA_CTL_UDMPU_CLUSTER, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_R):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_PDE23, RT1318_SDCA_CTL_REQ_POWER_STATE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_CS21, RT1318_SDCA_CTL_SAMPLE_FREQ_INDEX, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_SAPU, RT1318_SDCA_CTL_SAPU_PROTECTION_MODE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_SAPU, RT1318_SDCA_CTL_SAPU_PROTECTION_STATUS, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1318_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f55:\n\tcase 0x3000 ... 0x3001:\n\tcase 0xc000:\n\tcase 0xc301:\n\tcase 0xc410:\n\tcase 0xc430 ... 0xc431:\n\tcase 0xdb06:\n\tcase 0xdb12:\n\tcase 0xdb1d ... 0xdb1f:\n\tcase 0xdb35:\n\tcase 0xdb37:\n\tcase 0xdb8a ... 0xdb92:\n\tcase 0xdbc5 ... 0xdbc8:\n\tcase 0xdc2b ... 0xdc49:\n\tcase 0xdd0b:\n\tcase 0xdd12:\n\tcase 0xdd1d ... 0xdd1f:\n\tcase 0xdd35:\n\tcase 0xdd8a ... 0xdd92:\n\tcase 0xddc5 ... 0xddc8:\n\tcase 0xde2b ... 0xde44:\n\tcase 0xdf4a ... 0xdf55:\n\tcase 0xe224 ... 0xe23b:\n\tcase 0xea01:\n\tcase 0xebc5:\n\tcase 0xebc8:\n\tcase 0xebcb ... 0xebcc:\n\tcase 0xed03 ... 0xed06:\n\tcase 0xf010 ... 0xf014:\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_SAPU, RT1318_SDCA_CTL_SAPU_PROTECTION_MODE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_SAPU, RT1318_SDCA_CTL_SAPU_PROTECTION_STATUS, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt1318_sdw_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt1318_readable_register,\n\t.volatile_reg = rt1318_volatile_register,\n\t.max_register = 0x41081488,\n\t.reg_defaults = rt1318_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt1318_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt1318_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval;\n\tint i, j;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = BIT(2);\n\tprop->sink_ports = BIT(1);\n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->src_dpn_prop), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->sink_dpn_prop), GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[j].num = bit;\n\t\tdpn[j].type = SDW_DPN_FULL;\n\t\tdpn[j].simple_ch_prep_sm = true;\n\t\tdpn[j].ch_prep_timeout = 10;\n\t\tj++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 20;\n\n\treturn 0;\n}\n\nstatic int rt1318_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt1318_sdw_priv *rt1318 = dev_get_drvdata(dev);\n\n\tif (rt1318->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt1318->regmap, false);\n\tif (rt1318->first_hw_init) {\n\t\tregcache_cache_bypass(rt1318->regmap, true);\n\t} else {\n\t\t \n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\t \n\tregmap_multi_reg_write(rt1318->regmap, rt1318_blind_write,\n\t\tARRAY_SIZE(rt1318_blind_write));\n\n\tif (rt1318->first_hw_init) {\n\t\tregcache_cache_bypass(rt1318->regmap, false);\n\t\tregcache_mark_dirty(rt1318->regmap);\n\t}\n\n\t \n\trt1318->first_hw_init = true;\n\trt1318->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete\\n\", __func__);\n\treturn 0;\n}\n\nstatic int rt1318_update_status(struct sdw_slave *slave,\n\t\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct  rt1318_sdw_priv *rt1318 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt1318->hw_init = false;\n\n\t \n\tif (rt1318->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt1318_io_init(&slave->dev, slave);\n}\n\nstatic int rt1318_classd_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt1318_sdw_priv *rt1318 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt1318->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_PDE23,\n\t\t\t\tRT1318_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt1318->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_PDE23,\n\t\t\t\tRT1318_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const rt1318_rx_data_ch_select[] = {\n\t\"L,R\",\n\t\"L,L\",\n\t\"L,R\",\n\t\"L,L+R\",\n\t\"R,L\",\n\t\"R,R\",\n\t\"R,L+R\",\n\t\"L+R,L\",\n\t\"L+R,R\",\n\t\"L+R,L+R\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1318_rx_data_ch_enum,\n\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_UDMPU21, RT1318_SDCA_CTL_UDMPU_CLUSTER, 0), 0,\n\trt1318_rx_data_ch_select);\n\nstatic const struct snd_kcontrol_new rt1318_snd_controls[] = {\n\n\t \n\tSOC_ENUM(\"RX Channel Select\", rt1318_rx_data_ch_enum),\n};\n\nstatic const struct snd_kcontrol_new rt1318_sto_dac =\n\tSOC_DAPM_DOUBLE_R(\"Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_FU21, RT1318_SDCA_CTL_FU_MUTE, CH_R),\n\t\t0, 1, 1);\n\nstatic const struct snd_soc_dapm_widget rt1318_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"DP1RX\", \"DP1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP2TX\", \"DP2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"DAC\", SND_SOC_NOPM, 0, 0, &rt1318_sto_dac),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"CLASS D\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt1318_classd_event, SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOR\"),\n\t \n\tSND_SOC_DAPM_PGA(\"FB Data\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SIGGEN(\"FB Gen\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1318_dapm_routes[] = {\n\t{ \"DAC\", \"Switch\", \"DP1RX\" },\n\t{ \"CLASS D\", NULL, \"DAC\" },\n\t{ \"SPOL\", NULL, \"CLASS D\" },\n\t{ \"SPOR\", NULL, \"CLASS D\" },\n\n\t{ \"FB Data\", NULL, \"FB Gen\" },\n\t{ \"DP2TX\", NULL, \"FB Data\" },\n};\n\nstatic int rt1318_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt1318_sdw_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt1318_sdw_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1318_sdw_priv *rt1318 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config;\n\tstruct sdw_port_config port_config;\n\tenum sdw_data_direction direction;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval, port, num_channels, ch_mask;\n\tunsigned int sampling_rate;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt1318->sdw_slave)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdirection = SDW_DATA_DIR_RX;\n\t\tport = 1;\n\t} else {\n\t\tdirection = SDW_DATA_DIR_TX;\n\t\tport = 2;\n\t}\n\n\tnum_channels = params_channels(params);\n\tch_mask = (1 << num_channels) - 1;\n\n\tstream_config.frame_rate = params_rate(params);\n\tstream_config.ch_count = num_channels;\n\tstream_config.bps = snd_pcm_format_width(params_format(params));\n\tstream_config.direction = direction;\n\n\tport_config.ch_mask = ch_mask;\n\tport_config.num = port;\n\n\tretval = sdw_stream_add_slave(rt1318->sdw_slave, &stream_config,\n\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 16000:\n\t\tsampling_rate = RT1318_SDCA_RATE_16000HZ;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = RT1318_SDCA_RATE_32000HZ;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = RT1318_SDCA_RATE_44100HZ;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = RT1318_SDCA_RATE_48000HZ;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = RT1318_SDCA_RATE_96000HZ;\n\t\tbreak;\n\tcase 192000:\n\t\tsampling_rate = RT1318_SDCA_RATE_192000HZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(rt1318->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1318_SDCA_ENT_CS21, RT1318_SDCA_CTL_SAMPLE_FREQ_INDEX, 0),\n\t\tsampling_rate);\n\n\treturn 0;\n}\n\nstatic int rt1318_sdw_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1318_sdw_priv *rt1318 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt1318->sdw_slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt1318->sdw_slave, sdw_stream);\n\treturn 0;\n}\n\n \nstatic const struct sdw_slave_ops rt1318_slave_ops = {\n\t.read_prop = rt1318_read_prop,\n\t.update_status = rt1318_update_status,\n};\n\nstatic int rt1318_sdw_component_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\tstruct rt1318_sdw_priv *rt1318 = snd_soc_component_get_drvdata(component);\n\n\trt1318->component = component;\n\n\tif (!rt1318->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tdev_dbg(&rt1318->sdw_slave->dev, \"%s pm_runtime_resume, ret=%d\", __func__, ret);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_sdw_rt1318 = {\n\t.probe = rt1318_sdw_component_probe,\n\t.controls = rt1318_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1318_snd_controls),\n\t.dapm_widgets = rt1318_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1318_dapm_widgets),\n\t.dapm_routes = rt1318_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1318_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic const struct snd_soc_dai_ops rt1318_aif_dai_ops = {\n\t.hw_params = rt1318_sdw_hw_params,\n\t.hw_free\t= rt1318_sdw_pcm_hw_free,\n\t.set_stream\t= rt1318_set_sdw_stream,\n\t.shutdown\t= rt1318_sdw_shutdown,\n};\n\n#define RT1318_STEREO_RATES (SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)\n#define RT1318_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | \\\n\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver rt1318_sdw_dai[] = {\n\t{\n\t\t.name = \"rt1318-aif\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1318_STEREO_RATES,\n\t\t\t.formats = RT1318_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1318_STEREO_RATES,\n\t\t\t.formats = RT1318_FORMATS,\n\t\t},\n\t\t.ops = &rt1318_aif_dai_ops,\n\t},\n};\n\nstatic int rt1318_sdw_init(struct device *dev, struct regmap *regmap,\n\t\t\t\tstruct sdw_slave *slave)\n{\n\tstruct rt1318_sdw_priv *rt1318;\n\tint ret;\n\n\trt1318 = devm_kzalloc(dev, sizeof(*rt1318), GFP_KERNEL);\n\tif (!rt1318)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt1318);\n\trt1318->sdw_slave = slave;\n\trt1318->regmap = regmap;\n\n\tregcache_cache_only(rt1318->regmap, true);\n\n\t \n\trt1318->hw_init = false;\n\trt1318->first_hw_init = false;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t\t&soc_component_sdw_rt1318,\n\t\t\t\trt1318_sdw_dai,\n\t\t\t\tARRAY_SIZE(rt1318_sdw_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int rt1318_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &rt1318_sdw_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt1318_sdw_init(&slave->dev, regmap, slave);\n}\n\nstatic int rt1318_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt1318_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1318, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt1318_id);\n\nstatic int __maybe_unused rt1318_dev_suspend(struct device *dev)\n{\n\tstruct rt1318_sdw_priv *rt1318 = dev_get_drvdata(dev);\n\n\tif (!rt1318->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt1318->regmap, true);\n\treturn 0;\n}\n\n#define RT1318_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt1318_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt1318_sdw_priv *rt1318 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt1318->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT1318_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt1318->regmap, false);\n\tregcache_sync(rt1318->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt1318_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt1318_dev_suspend, rt1318_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt1318_dev_suspend, rt1318_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt1318_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt1318-sdca\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt1318_pm,\n\t},\n\t.probe = rt1318_sdw_probe,\n\t.remove = rt1318_sdw_remove,\n\t.ops = &rt1318_slave_ops,\n\t.id_table = rt1318_id,\n};\nmodule_sdw_driver(rt1318_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1318 driver SDCA SDW\");\nMODULE_AUTHOR(\"Shuming Fan <shumingf@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}