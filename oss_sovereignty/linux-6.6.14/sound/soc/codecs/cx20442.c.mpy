{
  "module_name": "cx20442.c",
  "hash_id": "94690b3d96452da21ddd4b4835ba137a05678467d765b3263cc5b78d05793358",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cx20442.c",
  "human_readable_source": "\n \n\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\n#include \"cx20442.h\"\n\n\nstruct cx20442_priv {\n\tstruct tty_struct *tty;\n\tstruct regulator *por;\n\tu8 reg_cache;\n};\n\n#define CX20442_PM\t\t0x0\n\n#define CX20442_TELIN\t\t0\n#define CX20442_TELOUT\t\t1\n#define CX20442_MIC\t\t2\n#define CX20442_SPKOUT\t\t3\n#define CX20442_AGC\t\t4\n\nstatic const struct snd_soc_dapm_widget cx20442_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"TELOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"AGCOUT\"),\n\n\tSND_SOC_DAPM_MIXER(\"SPKOUT Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"TELOUT Amp\", CX20442_PM, CX20442_TELOUT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPKOUT Amp\", CX20442_PM, CX20442_SPKOUT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPKOUT AGC\", CX20442_PM, CX20442_AGC, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Input Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MICBIAS(\"TELIN Bias\", CX20442_PM, CX20442_TELIN, 0),\n\tSND_SOC_DAPM_MICBIAS(\"MIC Bias\", CX20442_PM, CX20442_MIC, 0),\n\n\tSND_SOC_DAPM_PGA(\"MIC AGC\", CX20442_PM, CX20442_AGC, 0, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"TELIN\"),\n\tSND_SOC_DAPM_INPUT(\"MIC\"),\n\tSND_SOC_DAPM_INPUT(\"AGCIN\"),\n};\n\nstatic const struct snd_soc_dapm_route cx20442_audio_map[] = {\n\t{\"TELOUT\", NULL, \"TELOUT Amp\"},\n\n\t{\"SPKOUT\", NULL, \"SPKOUT Mixer\"},\n\t{\"SPKOUT Mixer\", NULL, \"SPKOUT Amp\"},\n\n\t{\"TELOUT Amp\", NULL, \"DAC\"},\n\t{\"SPKOUT Amp\", NULL, \"DAC\"},\n\n\t{\"SPKOUT Mixer\", NULL, \"SPKOUT AGC\"},\n\t{\"SPKOUT AGC\", NULL, \"AGCIN\"},\n\n\t{\"AGCOUT\", NULL, \"MIC AGC\"},\n\t{\"MIC AGC\", NULL, \"MIC\"},\n\n\t{\"MIC Bias\", NULL, \"MIC\"},\n\t{\"Input Mixer\", NULL, \"MIC Bias\"},\n\n\t{\"TELIN Bias\", NULL, \"TELIN\"},\n\t{\"Input Mixer\", NULL, \"TELIN Bias\"},\n\n\t{\"ADC\", NULL, \"Input Mixer\"},\n};\n\nstatic unsigned int cx20442_read_reg_cache(struct snd_soc_component *component,\n\t\t\t\t\t   unsigned int reg)\n{\n\tstruct cx20442_priv *cx20442 = snd_soc_component_get_drvdata(component);\n\n\tif (reg >= 1)\n\t\treturn -EINVAL;\n\n\treturn cx20442->reg_cache;\n}\n\nenum v253_vls {\n\tV253_VLS_NONE = 0,\n\tV253_VLS_T,\n\tV253_VLS_L,\n\tV253_VLS_LT,\n\tV253_VLS_S,\n\tV253_VLS_ST,\n\tV253_VLS_M,\n\tV253_VLS_MST,\n\tV253_VLS_S1,\n\tV253_VLS_S1T,\n\tV253_VLS_MS1T,\n\tV253_VLS_M1,\n\tV253_VLS_M1ST,\n\tV253_VLS_M1S1T,\n\tV253_VLS_H,\n\tV253_VLS_HT,\n\tV253_VLS_MS,\n\tV253_VLS_MS1,\n\tV253_VLS_M1S,\n\tV253_VLS_M1S1,\n\tV253_VLS_TEST,\n};\n\nstatic int cx20442_pm_to_v253_vls(u8 value)\n{\n\tswitch (value & ~(1 << CX20442_AGC)) {\n\tcase 0:\n\t\treturn V253_VLS_T;\n\tcase (1 << CX20442_SPKOUT):\n\tcase (1 << CX20442_MIC):\n\tcase (1 << CX20442_SPKOUT) | (1 << CX20442_MIC):\n\t\treturn V253_VLS_M1S1;\n\tcase (1 << CX20442_TELOUT):\n\tcase (1 << CX20442_TELIN):\n\tcase (1 << CX20442_TELOUT) | (1 << CX20442_TELIN):\n\t\treturn V253_VLS_L;\n\tcase (1 << CX20442_TELOUT) | (1 << CX20442_MIC):\n\t\treturn V253_VLS_NONE;\n\t}\n\treturn -EINVAL;\n}\nstatic int cx20442_pm_to_v253_vsp(u8 value)\n{\n\tswitch (value & ~(1 << CX20442_AGC)) {\n\tcase (1 << CX20442_SPKOUT):\n\tcase (1 << CX20442_MIC):\n\tcase (1 << CX20442_SPKOUT) | (1 << CX20442_MIC):\n\t\treturn (bool)(value & (1 << CX20442_AGC));\n\t}\n\treturn (value & (1 << CX20442_AGC)) ? -EINVAL : 0;\n}\n\nstatic int cx20442_write(struct snd_soc_component *component, unsigned int reg,\n\t\t\t\t\t\t\tunsigned int value)\n{\n\tstruct cx20442_priv *cx20442 = snd_soc_component_get_drvdata(component);\n\tint vls, vsp, old, len;\n\tchar buf[18];\n\n\tif (reg >= 1)\n\t\treturn -EINVAL;\n\n\t \n\tif (!cx20442->tty || !cx20442->tty->ops->write)\n\t\treturn -EIO;\n\n\told = cx20442->reg_cache;\n\tcx20442->reg_cache = value;\n\n\tvls = cx20442_pm_to_v253_vls(value);\n\tif (vls < 0)\n\t\treturn vls;\n\n\tvsp = cx20442_pm_to_v253_vsp(value);\n\tif (vsp < 0)\n\t\treturn vsp;\n\n\tif ((vls == V253_VLS_T) ||\n\t\t\t(vls == cx20442_pm_to_v253_vls(old))) {\n\t\tif (vsp == cx20442_pm_to_v253_vsp(old))\n\t\t\treturn 0;\n\t\tlen = snprintf(buf, ARRAY_SIZE(buf), \"at+vsp=%d\\r\", vsp);\n\t} else if (vsp == cx20442_pm_to_v253_vsp(old))\n\t\tlen = snprintf(buf, ARRAY_SIZE(buf), \"at+vls=%d\\r\", vls);\n\telse\n\t\tlen = snprintf(buf, ARRAY_SIZE(buf),\n\t\t\t\t\t\"at+vls=%d;+vsp=%d\\r\", vls, vsp);\n\n\tif (unlikely(len > (ARRAY_SIZE(buf) - 1)))\n\t\treturn -ENOMEM;\n\n\tdev_dbg(component->dev, \"%s: %s\\n\", __func__, buf);\n\tif (cx20442->tty->ops->write(cx20442->tty, buf, len) != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \n\n \nstatic const char v253_init[] = \"ate0m0q0+fclass=8\\r\";\n\n \nstatic int v253_open(struct tty_struct *tty)\n{\n\tint ret, len = strlen(v253_init);\n\n\t \n\tif (!tty->ops->write)\n\t\treturn -EINVAL;\n\n\t \n\tif (!tty->disc_data)\n\t\treturn -ENODEV;\n\n\ttty->receive_room = 16;\n\tif (tty->ops->write(tty, v253_init, len) != len) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\t \n\treturn 0;\nerr:\n\ttty->disc_data = NULL;\n\treturn ret;\n}\n\n \nstatic void v253_close(struct tty_struct *tty)\n{\n\tstruct snd_soc_component *component = tty->disc_data;\n\tstruct cx20442_priv *cx20442;\n\n\ttty->disc_data = NULL;\n\n\tif (!component)\n\t\treturn;\n\n\tcx20442 = snd_soc_component_get_drvdata(component);\n\n\t \n\tcx20442->tty = NULL;\n\tcomponent->card->pop_time = 0;\n}\n\n \nstatic void v253_hangup(struct tty_struct *tty)\n{\n\tv253_close(tty);\n}\n\n \nstatic void v253_receive(struct tty_struct *tty, const u8 *cp, const u8 *fp,\n\t\t\t size_t count)\n{\n\tstruct snd_soc_component *component = tty->disc_data;\n\tstruct cx20442_priv *cx20442;\n\n\tif (!component)\n\t\treturn;\n\n\tcx20442 = snd_soc_component_get_drvdata(component);\n\n\tif (!cx20442->tty) {\n\t\t \n\n\t\t \n\t\tcx20442->tty = tty;\n\t\tcomponent->card->pop_time = 1;\n\t}\n}\n\nstruct tty_ldisc_ops v253_ops = {\n\t.name = \"cx20442\",\n\t.owner = THIS_MODULE,\n\t.open = v253_open,\n\t.close = v253_close,\n\t.hangup = v253_hangup,\n\t.receive_buf = v253_receive,\n};\nEXPORT_SYMBOL_GPL(v253_ops);\n\n\n \n\nstatic struct snd_soc_dai_driver cx20442_dai = {\n\t.name = \"cx20442-voice\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n};\n\nstatic int cx20442_set_bias_level(struct snd_soc_component *component,\n\t\tenum snd_soc_bias_level level)\n{\n\tstruct cx20442_priv *cx20442 = snd_soc_component_get_drvdata(component);\n\tint err = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (snd_soc_component_get_bias_level(component) != SND_SOC_BIAS_STANDBY)\n\t\t\tbreak;\n\t\tif (IS_ERR(cx20442->por))\n\t\t\terr = PTR_ERR(cx20442->por);\n\t\telse\n\t\t\terr = regulator_enable(cx20442->por);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) != SND_SOC_BIAS_PREPARE)\n\t\t\tbreak;\n\t\tif (IS_ERR(cx20442->por))\n\t\t\terr = PTR_ERR(cx20442->por);\n\t\telse\n\t\t\terr = regulator_disable(cx20442->por);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int cx20442_component_probe(struct snd_soc_component *component)\n{\n\tstruct cx20442_priv *cx20442;\n\n\tcx20442 = kzalloc(sizeof(struct cx20442_priv), GFP_KERNEL);\n\tif (cx20442 == NULL)\n\t\treturn -ENOMEM;\n\n\tcx20442->por = regulator_get(component->dev, \"POR\");\n\tif (IS_ERR(cx20442->por)) {\n\t\tint err = PTR_ERR(cx20442->por);\n\n\t\tdev_warn(component->dev, \"failed to get POR supply (%d)\", err);\n\t\t \n\t\tif (err == -ENODEV)\n\t\t\terr = -EPROBE_DEFER;\n\t\tkfree(cx20442);\n\t\treturn err;\n\t}\n\n\tcx20442->tty = NULL;\n\n\tsnd_soc_component_set_drvdata(component, cx20442);\n\tcomponent->card->pop_time = 0;\n\n\treturn 0;\n}\n\n \nstatic void cx20442_component_remove(struct snd_soc_component *component)\n{\n\tstruct cx20442_priv *cx20442 = snd_soc_component_get_drvdata(component);\n\n\tif (cx20442->tty) {\n\t\tstruct tty_struct *tty = cx20442->tty;\n\t\ttty_hangup(tty);\n\t}\n\n\tif (!IS_ERR(cx20442->por)) {\n\t\t \n\t\tregulator_put(cx20442->por);\n\t}\n\n\tsnd_soc_component_set_drvdata(component, NULL);\n\tkfree(cx20442);\n}\n\nstatic const struct snd_soc_component_driver cx20442_component_dev = {\n\t.probe\t\t\t= cx20442_component_probe,\n\t.remove\t\t\t= cx20442_component_remove,\n\t.set_bias_level\t\t= cx20442_set_bias_level,\n\t.read\t\t\t= cx20442_read_reg_cache,\n\t.write\t\t\t= cx20442_write,\n\t.dapm_widgets\t\t= cx20442_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cx20442_dapm_widgets),\n\t.dapm_routes\t\t= cx20442_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cx20442_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int cx20442_platform_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&cx20442_component_dev, &cx20442_dai, 1);\n}\n\nstatic struct platform_driver cx20442_platform_driver = {\n\t.driver = {\n\t\t.name = \"cx20442-codec\",\n\t\t},\n\t.probe = cx20442_platform_probe,\n};\n\nmodule_platform_driver(cx20442_platform_driver);\n\nMODULE_DESCRIPTION(\"ASoC CX20442-11 voice modem codec driver\");\nMODULE_AUTHOR(\"Janusz Krzysztofik\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:cx20442-codec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}