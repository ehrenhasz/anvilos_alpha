{
  "module_name": "simple-mux.c",
  "hash_id": "85b019fa2d56155b9a198397e78e912b1855fc07799cf81ad4508c709881f7a2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/simple-mux.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n\nstruct simple_mux {\n\tstruct gpio_desc *gpiod_mux;\n\tunsigned int mux;\n};\n\nstatic const char * const simple_mux_texts[] = {\n\t\"Input 1\", \"Input 2\"\n};\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(simple_mux_enum, simple_mux_texts);\n\nstatic int simple_mux_control_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(dapm);\n\tstruct simple_mux *priv = snd_soc_component_get_drvdata(c);\n\n\tucontrol->value.enumerated.item[0] = priv->mux;\n\n\treturn 0;\n}\n\nstatic int simple_mux_control_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(dapm);\n\tstruct simple_mux *priv = snd_soc_component_get_drvdata(c);\n\n\tif (ucontrol->value.enumerated.item[0] > e->items)\n\t\treturn -EINVAL;\n\n\tif (priv->mux == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tpriv->mux = ucontrol->value.enumerated.item[0];\n\n\tgpiod_set_value_cansleep(priv->gpiod_mux, priv->mux);\n\n\treturn snd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\t\t\t\t     ucontrol->value.enumerated.item[0],\n\t\t\t\t\t     e, NULL);\n}\n\nstatic unsigned int simple_mux_read(struct snd_soc_component *component,\n\t\t\t\t    unsigned int reg)\n{\n\tstruct simple_mux *priv = snd_soc_component_get_drvdata(component);\n\n\treturn priv->mux;\n}\n\nstatic const struct snd_kcontrol_new simple_mux_mux =\n\tSOC_DAPM_ENUM_EXT(\"Muxer\", simple_mux_enum, simple_mux_control_get, simple_mux_control_put);\n\nstatic const struct snd_soc_dapm_widget simple_mux_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"IN1\"),\n\tSND_SOC_DAPM_INPUT(\"IN2\"),\n\tSND_SOC_DAPM_MUX(\"MUX\", SND_SOC_NOPM, 0, 0, &simple_mux_mux),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route simple_mux_dapm_routes[] = {\n\t{ \"OUT\", NULL, \"MUX\" },\n\t{ \"MUX\", \"Input 1\", \"IN1\" },\n\t{ \"MUX\", \"Input 2\", \"IN2\" },\n};\n\nstatic const struct snd_soc_component_driver simple_mux_component_driver = {\n\t.dapm_widgets\t\t= simple_mux_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(simple_mux_dapm_widgets),\n\t.dapm_routes\t\t= simple_mux_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(simple_mux_dapm_routes),\n\t.read\t\t\t= simple_mux_read,\n};\n\nstatic int simple_mux_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct simple_mux *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\n\tpriv->gpiod_mux = devm_gpiod_get(dev, \"mux\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->gpiod_mux))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->gpiod_mux),\n\t\t\t\t     \"Failed to get 'mux' gpio\");\n\n\treturn devm_snd_soc_register_component(dev, &simple_mux_component_driver, NULL, 0);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id simple_mux_ids[] = {\n\t{ .compatible = \"simple-audio-mux\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, simple_mux_ids);\n#endif\n\nstatic struct platform_driver simple_mux_driver = {\n\t.driver = {\n\t\t.name = \"simple-mux\",\n\t\t.of_match_table = of_match_ptr(simple_mux_ids),\n\t},\n\t.probe = simple_mux_probe,\n};\n\nmodule_platform_driver(simple_mux_driver);\n\nMODULE_DESCRIPTION(\"ASoC Simple Audio Mux driver\");\nMODULE_AUTHOR(\"Alexandre Belloni <alexandre.belloni@bootlin.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}