{
  "module_name": "ak4104.c",
  "hash_id": "0b7f149ada1683d27f1b7114d8aee42324c71a32216820def546b89eef2a88d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4104.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/of_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n \n#define AK4104_REG_CONTROL1\t\t0x00\n#define AK4104_REG_RESERVED\t\t0x01\n#define AK4104_REG_CONTROL2\t\t0x02\n#define AK4104_REG_TX\t\t\t0x03\n#define AK4104_REG_CHN_STATUS(x)\t((x) + 0x04)\n#define AK4104_NUM_REGS\t\t\t10\n\n#define AK4104_REG_MASK\t\t\t0x1f\n#define AK4104_READ\t\t\t0xc0\n#define AK4104_WRITE\t\t\t0xe0\n#define AK4104_RESERVED_VAL\t\t0x5b\n\n \n#define AK4104_CONTROL1_RSTN\t\t(1 << 0)\n#define AK4104_CONTROL1_PW\t\t(1 << 1)\n#define AK4104_CONTROL1_DIF0\t\t(1 << 2)\n#define AK4104_CONTROL1_DIF1\t\t(1 << 3)\n\n#define AK4104_CONTROL2_SEL0\t\t(1 << 0)\n#define AK4104_CONTROL2_SEL1\t\t(1 << 1)\n#define AK4104_CONTROL2_MODE\t\t(1 << 2)\n\n#define AK4104_TX_TXE\t\t\t(1 << 0)\n#define AK4104_TX_V\t\t\t(1 << 1)\n\nstruct ak4104_private {\n\tstruct regmap *regmap;\n\tstruct regulator *regulator;\n};\n\nstatic const struct snd_soc_dapm_widget ak4104_dapm_widgets[] = {\nSND_SOC_DAPM_PGA(\"TXE\", AK4104_REG_TX, AK4104_TX_TXE, 0, NULL, 0),\n\nSND_SOC_DAPM_OUTPUT(\"TX\"),\n};\n\nstatic const struct snd_soc_dapm_route ak4104_dapm_routes[] = {\n\t{ \"TXE\", NULL, \"Playback\" },\n\t{ \"TX\", NULL, \"TXE\" },\n};\n\nstatic int ak4104_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ak4104_private *ak4104 = snd_soc_component_get_drvdata(component);\n\tint val = 0;\n\tint ret;\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval |= AK4104_CONTROL1_DIF0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= AK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"invalid dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(ak4104->regmap, AK4104_REG_CONTROL1,\n\t\t\t\t AK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1,\n\t\t\t\t val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ak4104_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4104_private *ak4104 = snd_soc_component_get_drvdata(component);\n\tint ret, val = 0;\n\n\t \n\tval |= IEC958_AES0_CON_NOT_COPYRIGHT;\n\tregmap_write(ak4104->regmap, AK4104_REG_CHN_STATUS(0), val);\n\n\tval = 0;\n\n\tswitch (params_rate(params)) {\n\tcase 22050:\n\t\tval |= IEC958_AES3_CON_FS_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tval |= IEC958_AES3_CON_FS_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tval |= IEC958_AES3_CON_FS_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tval |= IEC958_AES3_CON_FS_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tval |= IEC958_AES3_CON_FS_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tval |= IEC958_AES3_CON_FS_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tval |= IEC958_AES3_CON_FS_96000;\n\t\tbreak;\n\tcase 176400:\n\t\tval |= IEC958_AES3_CON_FS_176400;\n\t\tbreak;\n\tcase 192000:\n\t\tval |= IEC958_AES3_CON_FS_192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported sampling rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(ak4104->regmap, AK4104_REG_CHN_STATUS(3), val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ak4101_dai_ops = {\n\t.hw_params = ak4104_hw_params,\n\t.set_fmt = ak4104_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver ak4104_dai = {\n\t.name = \"ak4104-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\n\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\n\t\t\t SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE  |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE\n\t},\n\t.ops = &ak4101_dai_ops,\n};\n\nstatic int ak4104_probe(struct snd_soc_component *component)\n{\n\tstruct ak4104_private *ak4104 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_enable(ak4104->regulator);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unable to enable regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_update_bits(ak4104->regmap, AK4104_REG_CONTROL1,\n\t\t\t\t AK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN,\n\t\t\t\t AK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN);\n\tif (ret < 0)\n\t\tgoto exit_disable_regulator;\n\n\t \n\tret = regmap_update_bits(ak4104->regmap, AK4104_REG_TX,\n\t\t\t\t AK4104_TX_TXE, AK4104_TX_TXE);\n\tif (ret < 0)\n\t\tgoto exit_disable_regulator;\n\n\treturn 0;\n\nexit_disable_regulator:\n\tregulator_disable(ak4104->regulator);\n\treturn ret;\n}\n\nstatic void ak4104_remove(struct snd_soc_component *component)\n{\n\tstruct ak4104_private *ak4104 = snd_soc_component_get_drvdata(component);\n\n\tregmap_update_bits(ak4104->regmap, AK4104_REG_CONTROL1,\n\t\t\t   AK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN, 0);\n\tregulator_disable(ak4104->regulator);\n}\n\n#ifdef CONFIG_PM\nstatic int ak4104_soc_suspend(struct snd_soc_component *component)\n{\n\tstruct ak4104_private *priv = snd_soc_component_get_drvdata(component);\n\n\tregulator_disable(priv->regulator);\n\n\treturn 0;\n}\n\nstatic int ak4104_soc_resume(struct snd_soc_component *component)\n{\n\tstruct ak4104_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_enable(priv->regulator);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\n#define ak4104_soc_suspend\tNULL\n#define ak4104_soc_resume\tNULL\n#endif  \n\nstatic const struct snd_soc_component_driver soc_component_device_ak4104 = {\n\t.probe\t\t\t= ak4104_probe,\n\t.remove\t\t\t= ak4104_remove,\n\t.suspend\t\t= ak4104_soc_suspend,\n\t.resume\t\t\t= ak4104_soc_resume,\n\t.dapm_widgets\t\t= ak4104_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4104_dapm_widgets),\n\t.dapm_routes\t\t= ak4104_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4104_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4104_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = AK4104_NUM_REGS - 1,\n\t.read_flag_mask = AK4104_READ,\n\t.write_flag_mask = AK4104_WRITE,\n\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int ak4104_spi_probe(struct spi_device *spi)\n{\n\tstruct ak4104_private *ak4104;\n\tstruct gpio_desc *reset_gpiod;\n\tunsigned int val;\n\tint ret;\n\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_0;\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tak4104 = devm_kzalloc(&spi->dev, sizeof(struct ak4104_private),\n\t\t\t      GFP_KERNEL);\n\tif (ak4104 == NULL)\n\t\treturn -ENOMEM;\n\n\tak4104->regulator = devm_regulator_get(&spi->dev, \"vdd\");\n\tif (IS_ERR(ak4104->regulator)) {\n\t\tret = PTR_ERR(ak4104->regulator);\n\t\tdev_err(&spi->dev, \"Unable to get Vdd regulator: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tak4104->regmap = devm_regmap_init_spi(spi, &ak4104_regmap);\n\tif (IS_ERR(ak4104->regmap)) {\n\t\tret = PTR_ERR(ak4104->regmap);\n\t\treturn ret;\n\t}\n\n\treset_gpiod = devm_gpiod_get_optional(&spi->dev, \"reset\",\n\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (PTR_ERR(reset_gpiod) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tret = regmap_read(ak4104->regmap, AK4104_REG_RESERVED, &val);\n\tif (ret != 0)\n\t\treturn ret;\n\tif (val != AK4104_RESERVED_VAL)\n\t\treturn -ENODEV;\n\n\tspi_set_drvdata(spi, ak4104);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_device_ak4104, &ak4104_dai, 1);\n\treturn ret;\n}\n\nstatic const struct of_device_id ak4104_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4104\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ak4104_of_match);\n\nstatic const struct spi_device_id ak4104_id_table[] = {\n\t{ \"ak4104\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ak4104_id_table);\n\nstatic struct spi_driver ak4104_spi_driver = {\n\t.driver  = {\n\t\t.name   = \"ak4104\",\n\t\t.of_match_table = ak4104_of_match,\n\t},\n\t.id_table = ak4104_id_table,\n\t.probe  = ak4104_spi_probe,\n};\n\nmodule_spi_driver(ak4104_spi_driver);\n\nMODULE_AUTHOR(\"Daniel Mack <daniel@caiaq.de>\");\nMODULE_DESCRIPTION(\"Asahi Kasei AK4104 ALSA SoC driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}