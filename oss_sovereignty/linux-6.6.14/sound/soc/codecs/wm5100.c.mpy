{
  "module_name": "wm5100.c",
  "hash_id": "07fd1e8b6445bbe8725bc17307047ab403109e931326150966998e3cf46c96e2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm5100.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/pm.h>\n#include <linux/gcd.h>\n#include <linux/gpio/driver.h>\n#include <linux/gpio.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/fixed.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/wm5100.h>\n\n#include \"wm5100.h\"\n\n#define WM5100_NUM_CORE_SUPPLIES 2\nstatic const char *wm5100_core_supply_names[WM5100_NUM_CORE_SUPPLIES] = {\n\t\"DBVDD1\",\n\t\"LDOVDD\",  \n};\n\n#define WM5100_AIFS     3\n#define WM5100_SYNC_SRS 3\n\nstruct wm5100_fll {\n\tint fref;\n\tint fout;\n\tint src;\n\tstruct completion lock;\n};\n\n \nstruct wm5100_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\n\tstruct regulator_bulk_data core_supplies[WM5100_NUM_CORE_SUPPLIES];\n\n\tint rev;\n\n\tint sysclk;\n\tint asyncclk;\n\n\tbool aif_async[WM5100_AIFS];\n\tbool aif_symmetric[WM5100_AIFS];\n\tint sr_ref[WM5100_SYNC_SRS];\n\n\tbool out_ena[2];\n\n\tstruct snd_soc_jack *jack;\n\tbool jack_detecting;\n\tbool jack_mic;\n\tint jack_mode;\n\tint jack_flips;\n\n\tstruct wm5100_fll fll[2];\n\n\tstruct wm5100_pdata pdata;\n\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gpio_chip;\n#endif\n};\n\nstatic int wm5100_sr_code[] = {\n\t0,\n\t12000,\n\t24000,\n\t48000,\n\t96000,\n\t192000,\n\t384000,\n\t768000,\n\t0,\n\t11025,\n\t22050,\n\t44100,\n\t88200,\n\t176400,\n\t352800,\n\t705600,\n\t4000,\n\t8000,\n\t16000,\n\t32000,\n\t64000,\n\t128000,\n\t256000,\n\t512000,\n};\n\nstatic int wm5100_sr_regs[WM5100_SYNC_SRS] = {\n\tWM5100_CLOCKING_4,\n\tWM5100_CLOCKING_5,\n\tWM5100_CLOCKING_6,\n};\n\nstatic int wm5100_alloc_sr(struct snd_soc_component *component, int rate)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tint sr_code, sr_free, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\n\t\tif (wm5100_sr_code[i] == rate)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(wm5100_sr_code)) {\n\t\tdev_err(component->dev, \"Unsupported sample rate: %dHz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\tsr_code = i;\n\n\tif ((wm5100->sysclk % rate) == 0) {\n\t\t \n\t\tsr_free = -1;\n\t\tfor (i = 0; i < ARRAY_SIZE(wm5100_sr_regs); i++) {\n\t\t\tif (!wm5100->sr_ref[i] && sr_free == -1) {\n\t\t\t\tsr_free = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((snd_soc_component_read(component, wm5100_sr_regs[i]) &\n\t\t\t     WM5100_SAMPLE_RATE_1_MASK) == sr_code)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i < ARRAY_SIZE(wm5100_sr_regs)) {\n\t\t\twm5100->sr_ref[i]++;\n\t\t\tdev_dbg(component->dev, \"SR %dHz, slot %d, ref %d\\n\",\n\t\t\t\trate, i, wm5100->sr_ref[i]);\n\t\t\treturn i;\n\t\t}\n\n\t\tif (sr_free == -1) {\n\t\t\tdev_err(component->dev, \"All SR slots already in use\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"Allocating SR slot %d for %dHz\\n\",\n\t\t\tsr_free, rate);\n\t\twm5100->sr_ref[sr_free]++;\n\t\tsnd_soc_component_update_bits(component, wm5100_sr_regs[sr_free],\n\t\t\t\t    WM5100_SAMPLE_RATE_1_MASK,\n\t\t\t\t    sr_code);\n\n\t\treturn sr_free;\n\n\t} else {\n\t\tdev_err(component->dev,\n\t\t\t\"SR %dHz incompatible with %dHz SYSCLK and %dHz ASYNCCLK\\n\",\n\t\t\trate, wm5100->sysclk, wm5100->asyncclk);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void wm5100_free_sr(struct snd_soc_component *component, int rate)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tint i, sr_code;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\n\t\tif (wm5100_sr_code[i] == rate)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(wm5100_sr_code)) {\n\t\tdev_err(component->dev, \"Unsupported sample rate: %dHz\\n\", rate);\n\t\treturn;\n\t}\n\tsr_code = wm5100_sr_code[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100_sr_regs); i++) {\n\t\tif (!wm5100->sr_ref[i])\n\t\t\tcontinue;\n\n\t\tif ((snd_soc_component_read(component, wm5100_sr_regs[i]) &\n\t\t     WM5100_SAMPLE_RATE_1_MASK) == sr_code)\n\t\t\tbreak;\n\t}\n\tif (i < ARRAY_SIZE(wm5100_sr_regs)) {\n\t\twm5100->sr_ref[i]--;\n\t\tdev_dbg(component->dev, \"Dereference SR %dHz, count now %d\\n\",\n\t\t\trate, wm5100->sr_ref[i]);\n\t} else {\n\t\tdev_warn(component->dev, \"Freeing unreferenced sample rate %dHz\\n\",\n\t\t\t rate);\n\t}\n}\n\nstatic int wm5100_reset(struct wm5100_priv *wm5100)\n{\n\tif (wm5100->pdata.reset) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.reset, 0);\n\t\tgpio_set_value_cansleep(wm5100->pdata.reset, 1);\n\n\t\treturn 0;\n\t} else {\n\t\treturn regmap_write(wm5100->regmap, WM5100_SOFTWARE_RESET, 0);\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(in_tlv, -6300, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(mixer_tlv, -3200, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(out_tlv, -6400, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);\n\nstatic const char *wm5100_mixer_texts[] = {\n\t\"None\",\n\t\"Tone Generator 1\",\n\t\"Tone Generator 2\",\n\t\"AEC loopback\",\n\t\"IN1L\",\n\t\"IN1R\",\n\t\"IN2L\",\n\t\"IN2R\",\n\t\"IN3L\",\n\t\"IN3R\",\n\t\"IN4L\",\n\t\"IN4R\",\n\t\"AIF1RX1\",\n\t\"AIF1RX2\",\n\t\"AIF1RX3\",\n\t\"AIF1RX4\",\n\t\"AIF1RX5\",\n\t\"AIF1RX6\",\n\t\"AIF1RX7\",\n\t\"AIF1RX8\",\n\t\"AIF2RX1\",\n\t\"AIF2RX2\",\n\t\"AIF3RX1\",\n\t\"AIF3RX2\",\n\t\"EQ1\",\n\t\"EQ2\",\n\t\"EQ3\",\n\t\"EQ4\",\n\t\"DRC1L\",\n\t\"DRC1R\",\n\t\"LHPF1\",\n\t\"LHPF2\",\n\t\"LHPF3\",\n\t\"LHPF4\",\n\t\"DSP1.1\",\n\t\"DSP1.2\",\n\t\"DSP1.3\",\n\t\"DSP1.4\",\n\t\"DSP1.5\",\n\t\"DSP1.6\",\n\t\"DSP2.1\",\n\t\"DSP2.2\",\n\t\"DSP2.3\",\n\t\"DSP2.4\",\n\t\"DSP2.5\",\n\t\"DSP2.6\",\n\t\"DSP3.1\",\n\t\"DSP3.2\",\n\t\"DSP3.3\",\n\t\"DSP3.4\",\n\t\"DSP3.5\",\n\t\"DSP3.6\",\n\t\"ASRC1L\",\n\t\"ASRC1R\",\n\t\"ASRC2L\",\n\t\"ASRC2R\",\n\t\"ISRC1INT1\",\n\t\"ISRC1INT2\",\n\t\"ISRC1INT3\",\n\t\"ISRC1INT4\",\n\t\"ISRC2INT1\",\n\t\"ISRC2INT2\",\n\t\"ISRC2INT3\",\n\t\"ISRC2INT4\",\n\t\"ISRC1DEC1\",\n\t\"ISRC1DEC2\",\n\t\"ISRC1DEC3\",\n\t\"ISRC1DEC4\",\n\t\"ISRC2DEC1\",\n\t\"ISRC2DEC2\",\n\t\"ISRC2DEC3\",\n\t\"ISRC2DEC4\",\n};\n\nstatic int wm5100_mixer_values[] = {\n\t0x00,\n\t0x04,    \n\t0x05,\n\t0x08,    \n\t0x10,    \n\t0x11,\n\t0x12,\n\t0x13,\n\t0x14,\n\t0x15,\n\t0x16,\n\t0x17,\n\t0x20,    \n\t0x21,\n\t0x22,\n\t0x23,\n\t0x24,\n\t0x25,\n\t0x26,\n\t0x27,\n\t0x28,\n\t0x29,\n\t0x30,    \n\t0x31,\n\t0x50,    \n\t0x51,\n\t0x52,\n\t0x53,\n\t0x54,\n\t0x58,    \n\t0x59,\n\t0x60,    \n\t0x61,    \n\t0x62,    \n\t0x63,    \n\t0x68,    \n\t0x69,\n\t0x6a,\n\t0x6b,\n\t0x6c,\n\t0x6d,\n\t0x70,    \n\t0x71,\n\t0x72,\n\t0x73,\n\t0x74,\n\t0x75,\n\t0x78,    \n\t0x79,\n\t0x7a,\n\t0x7b,\n\t0x7c,\n\t0x7d,\n\t0x90,    \n\t0x91,\n\t0x92,    \n\t0x93,\n\t0xa0,    \n\t0xa1,\n\t0xa2,\n\t0xa3,\n\t0xa4,    \n\t0xa5,\n\t0xa6,\n\t0xa7,\n\t0xa8,    \n\t0xa9,\n\t0xaa,\n\t0xab,\n\t0xac,    \n\t0xad,\n\t0xae,\n\t0xaf,\n};\n\n#define WM5100_MIXER_CONTROLS(name, base) \\\n\tSOC_SINGLE_TLV(name \" Input 1 Volume\", base + 1 , \\\n\t\t       WM5100_MIXER_VOL_SHIFT, 80, 0, mixer_tlv), \\\n\tSOC_SINGLE_TLV(name \" Input 2 Volume\", base + 3 , \\\n\t\t       WM5100_MIXER_VOL_SHIFT, 80, 0, mixer_tlv), \\\n\tSOC_SINGLE_TLV(name \" Input 3 Volume\", base + 5 , \\\n\t\t       WM5100_MIXER_VOL_SHIFT, 80, 0, mixer_tlv), \\\n\tSOC_SINGLE_TLV(name \" Input 4 Volume\", base + 7 , \\\n\t\t       WM5100_MIXER_VOL_SHIFT, 80, 0, mixer_tlv)\n\n#define WM5100_MUX_ENUM_DECL(name, reg) \\\n\tSOC_VALUE_ENUM_SINGLE_DECL(name, reg, 0, 0xff, \t\t\t\\\n\t\t\t\t   wm5100_mixer_texts, wm5100_mixer_values)\n\n#define WM5100_MUX_CTL_DECL(name) \\\n\tconst struct snd_kcontrol_new name##_mux =\t\\\n\t\tSOC_DAPM_ENUM(\"Route\", name##_enum)\n\n#define WM5100_MIXER_ENUMS(name, base_reg) \\\n\tstatic WM5100_MUX_ENUM_DECL(name##_in1_enum, base_reg);\t     \\\n\tstatic WM5100_MUX_ENUM_DECL(name##_in2_enum, base_reg + 2);  \\\n\tstatic WM5100_MUX_ENUM_DECL(name##_in3_enum, base_reg + 4);  \\\n\tstatic WM5100_MUX_ENUM_DECL(name##_in4_enum, base_reg + 6);  \\\n\tstatic WM5100_MUX_CTL_DECL(name##_in1); \\\n\tstatic WM5100_MUX_CTL_DECL(name##_in2); \\\n\tstatic WM5100_MUX_CTL_DECL(name##_in3); \\\n\tstatic WM5100_MUX_CTL_DECL(name##_in4) \n\nWM5100_MIXER_ENUMS(HPOUT1L, WM5100_OUT1LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(HPOUT1R, WM5100_OUT1RMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(HPOUT2L, WM5100_OUT2LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(HPOUT2R, WM5100_OUT2RMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(HPOUT3L, WM5100_OUT3LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(HPOUT3R, WM5100_OUT3RMIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(SPKOUTL, WM5100_OUT4LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(SPKOUTR, WM5100_OUT4RMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(SPKDAT1L, WM5100_OUT5LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(SPKDAT1R, WM5100_OUT5RMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(SPKDAT2L, WM5100_OUT6LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(SPKDAT2R, WM5100_OUT6RMIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(PWM1, WM5100_PWM1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(PWM2, WM5100_PWM1MIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(AIF1TX1, WM5100_AIF1TX1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX2, WM5100_AIF1TX2MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX3, WM5100_AIF1TX3MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX4, WM5100_AIF1TX4MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX5, WM5100_AIF1TX5MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX6, WM5100_AIF1TX6MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX7, WM5100_AIF1TX7MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF1TX8, WM5100_AIF1TX8MIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(AIF2TX1, WM5100_AIF2TX1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF2TX2, WM5100_AIF2TX2MIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(AIF3TX1, WM5100_AIF1TX1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(AIF3TX2, WM5100_AIF1TX2MIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(EQ1, WM5100_EQ1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(EQ2, WM5100_EQ2MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(EQ3, WM5100_EQ3MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(EQ4, WM5100_EQ4MIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(DRC1L, WM5100_DRC1LMIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(DRC1R, WM5100_DRC1RMIX_INPUT_1_SOURCE);\n\nWM5100_MIXER_ENUMS(LHPF1, WM5100_HPLP1MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(LHPF2, WM5100_HPLP2MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(LHPF3, WM5100_HPLP3MIX_INPUT_1_SOURCE);\nWM5100_MIXER_ENUMS(LHPF4, WM5100_HPLP4MIX_INPUT_1_SOURCE);\n\n#define WM5100_MUX(name, ctrl) \\\n\tSND_SOC_DAPM_MUX(name, SND_SOC_NOPM, 0, 0, ctrl)\n\n#define WM5100_MIXER_WIDGETS(name, name_str)\t\\\n\tWM5100_MUX(name_str \" Input 1\", &name##_in1_mux), \\\n\tWM5100_MUX(name_str \" Input 2\", &name##_in2_mux), \\\n\tWM5100_MUX(name_str \" Input 3\", &name##_in3_mux), \\\n\tWM5100_MUX(name_str \" Input 4\", &name##_in4_mux), \\\n\tSND_SOC_DAPM_MIXER(name_str \" Mixer\", SND_SOC_NOPM, 0, 0, NULL, 0)\n\n#define WM5100_MIXER_INPUT_ROUTES(name)\t\\\n\t{ name, \"Tone Generator 1\", \"Tone Generator 1\" }, \\\n        { name, \"Tone Generator 2\", \"Tone Generator 2\" }, \\\n        { name, \"IN1L\", \"IN1L PGA\" }, \\\n        { name, \"IN1R\", \"IN1R PGA\" }, \\\n        { name, \"IN2L\", \"IN2L PGA\" }, \\\n        { name, \"IN2R\", \"IN2R PGA\" }, \\\n        { name, \"IN3L\", \"IN3L PGA\" }, \\\n        { name, \"IN3R\", \"IN3R PGA\" }, \\\n        { name, \"IN4L\", \"IN4L PGA\" }, \\\n        { name, \"IN4R\", \"IN4R PGA\" }, \\\n        { name, \"AIF1RX1\", \"AIF1RX1\" }, \\\n        { name, \"AIF1RX2\", \"AIF1RX2\" }, \\\n        { name, \"AIF1RX3\", \"AIF1RX3\" }, \\\n        { name, \"AIF1RX4\", \"AIF1RX4\" }, \\\n        { name, \"AIF1RX5\", \"AIF1RX5\" }, \\\n        { name, \"AIF1RX6\", \"AIF1RX6\" }, \\\n        { name, \"AIF1RX7\", \"AIF1RX7\" }, \\\n        { name, \"AIF1RX8\", \"AIF1RX8\" }, \\\n        { name, \"AIF2RX1\", \"AIF2RX1\" }, \\\n        { name, \"AIF2RX2\", \"AIF2RX2\" }, \\\n        { name, \"AIF3RX1\", \"AIF3RX1\" }, \\\n        { name, \"AIF3RX2\", \"AIF3RX2\" }, \\\n        { name, \"EQ1\", \"EQ1\" }, \\\n        { name, \"EQ2\", \"EQ2\" }, \\\n        { name, \"EQ3\", \"EQ3\" }, \\\n        { name, \"EQ4\", \"EQ4\" }, \\\n        { name, \"DRC1L\", \"DRC1L\" }, \\\n        { name, \"DRC1R\", \"DRC1R\" }, \\\n        { name, \"LHPF1\", \"LHPF1\" }, \\\n        { name, \"LHPF2\", \"LHPF2\" }, \\\n        { name, \"LHPF3\", \"LHPF3\" }, \\\n        { name, \"LHPF4\", \"LHPF4\" }\n\n#define WM5100_MIXER_ROUTES(widget, name) \\\n\t{ widget, NULL, name \" Mixer\" },         \\\n\t{ name \" Mixer\", NULL, name \" Input 1\" }, \\\n\t{ name \" Mixer\", NULL, name \" Input 2\" }, \\\n\t{ name \" Mixer\", NULL, name \" Input 3\" }, \\\n\t{ name \" Mixer\", NULL, name \" Input 4\" }, \\\n\tWM5100_MIXER_INPUT_ROUTES(name \" Input 1\"), \\\n\tWM5100_MIXER_INPUT_ROUTES(name \" Input 2\"), \\\n\tWM5100_MIXER_INPUT_ROUTES(name \" Input 3\"), \\\n\tWM5100_MIXER_INPUT_ROUTES(name \" Input 4\")\n\nstatic const char *wm5100_lhpf_mode_text[] = {\n\t\"Low-pass\", \"High-pass\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(wm5100_lhpf1_mode,\n\t\t\t    WM5100_HPLPF1_1, WM5100_LHPF1_MODE_SHIFT,\n\t\t\t    wm5100_lhpf_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(wm5100_lhpf2_mode,\n\t\t\t    WM5100_HPLPF2_1, WM5100_LHPF2_MODE_SHIFT,\n\t\t\t    wm5100_lhpf_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(wm5100_lhpf3_mode,\n\t\t\t    WM5100_HPLPF3_1, WM5100_LHPF3_MODE_SHIFT,\n\t\t\t    wm5100_lhpf_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(wm5100_lhpf4_mode,\n\t\t\t    WM5100_HPLPF4_1, WM5100_LHPF4_MODE_SHIFT,\n\t\t\t    wm5100_lhpf_mode_text);\n\nstatic const struct snd_kcontrol_new wm5100_snd_controls[] = {\nSOC_SINGLE(\"IN1 High Performance Switch\", WM5100_IN1L_CONTROL,\n\t   WM5100_IN1_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"IN2 High Performance Switch\", WM5100_IN2L_CONTROL,\n\t   WM5100_IN2_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"IN3 High Performance Switch\", WM5100_IN3L_CONTROL,\n\t   WM5100_IN3_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"IN4 High Performance Switch\", WM5100_IN4L_CONTROL,\n\t   WM5100_IN4_OSR_SHIFT, 1, 0),\n\n \nSOC_DOUBLE_R_TLV(\"IN1 Volume\", WM5100_IN1L_CONTROL, WM5100_IN1R_CONTROL,\n\t\t WM5100_IN1L_PGA_VOL_SHIFT, 94, 0, in_tlv),\nSOC_DOUBLE_R_TLV(\"IN2 Volume\", WM5100_IN2L_CONTROL, WM5100_IN2R_CONTROL,\n\t\t WM5100_IN2L_PGA_VOL_SHIFT, 94, 0, in_tlv),\nSOC_DOUBLE_R_TLV(\"IN3 Volume\", WM5100_IN3L_CONTROL, WM5100_IN3R_CONTROL,\n\t\t WM5100_IN3L_PGA_VOL_SHIFT, 94, 0, in_tlv),\nSOC_DOUBLE_R_TLV(\"IN4 Volume\", WM5100_IN4L_CONTROL, WM5100_IN4R_CONTROL,\n\t\t WM5100_IN4L_PGA_VOL_SHIFT, 94, 0, in_tlv),\n\nSOC_DOUBLE_R_TLV(\"IN1 Digital Volume\", WM5100_ADC_DIGITAL_VOLUME_1L,\n\t\t WM5100_ADC_DIGITAL_VOLUME_1R, WM5100_IN1L_VOL_SHIFT, 191,\n\t\t 0, digital_tlv),\nSOC_DOUBLE_R_TLV(\"IN2 Digital Volume\", WM5100_ADC_DIGITAL_VOLUME_2L,\n\t\t WM5100_ADC_DIGITAL_VOLUME_2R, WM5100_IN2L_VOL_SHIFT, 191,\n\t\t 0, digital_tlv),\nSOC_DOUBLE_R_TLV(\"IN3 Digital Volume\", WM5100_ADC_DIGITAL_VOLUME_3L,\n\t\t WM5100_ADC_DIGITAL_VOLUME_3R, WM5100_IN3L_VOL_SHIFT, 191,\n\t\t 0, digital_tlv),\nSOC_DOUBLE_R_TLV(\"IN4 Digital Volume\", WM5100_ADC_DIGITAL_VOLUME_4L,\n\t\t WM5100_ADC_DIGITAL_VOLUME_4R, WM5100_IN4L_VOL_SHIFT, 191,\n\t\t 0, digital_tlv),\n\nSOC_DOUBLE_R(\"IN1 Switch\", WM5100_ADC_DIGITAL_VOLUME_1L,\n\t     WM5100_ADC_DIGITAL_VOLUME_1R, WM5100_IN1L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"IN2 Switch\", WM5100_ADC_DIGITAL_VOLUME_2L,\n\t     WM5100_ADC_DIGITAL_VOLUME_2R, WM5100_IN2L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"IN3 Switch\", WM5100_ADC_DIGITAL_VOLUME_3L,\n\t     WM5100_ADC_DIGITAL_VOLUME_3R, WM5100_IN3L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"IN4 Switch\", WM5100_ADC_DIGITAL_VOLUME_4L,\n\t     WM5100_ADC_DIGITAL_VOLUME_4R, WM5100_IN4L_MUTE_SHIFT, 1, 1),\n\nSND_SOC_BYTES_MASK(\"EQ1 Coefficients\", WM5100_EQ1_1, 20, WM5100_EQ1_ENA),\nSND_SOC_BYTES_MASK(\"EQ2 Coefficients\", WM5100_EQ2_1, 20, WM5100_EQ2_ENA),\nSND_SOC_BYTES_MASK(\"EQ3 Coefficients\", WM5100_EQ3_1, 20, WM5100_EQ3_ENA),\nSND_SOC_BYTES_MASK(\"EQ4 Coefficients\", WM5100_EQ4_1, 20, WM5100_EQ4_ENA),\n\nSND_SOC_BYTES_MASK(\"DRC Coefficients\", WM5100_DRC1_CTRL1, 5,\n\t\t   WM5100_DRCL_ENA | WM5100_DRCR_ENA),\n\nSND_SOC_BYTES(\"LHPF1 Coefficients\", WM5100_HPLPF1_2, 1),\nSND_SOC_BYTES(\"LHPF2 Coefficients\", WM5100_HPLPF2_2, 1),\nSND_SOC_BYTES(\"LHPF3 Coefficients\", WM5100_HPLPF3_2, 1),\nSND_SOC_BYTES(\"LHPF4 Coefficients\", WM5100_HPLPF4_2, 1),\n\nSOC_SINGLE(\"HPOUT1 High Performance Switch\", WM5100_OUT_VOLUME_1L,\n\t   WM5100_OUT1_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"HPOUT2 High Performance Switch\", WM5100_OUT_VOLUME_2L,\n\t   WM5100_OUT2_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"HPOUT3 High Performance Switch\", WM5100_OUT_VOLUME_3L,\n\t   WM5100_OUT3_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"SPKOUT High Performance Switch\", WM5100_OUT_VOLUME_4L,\n\t   WM5100_OUT4_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"SPKDAT1 High Performance Switch\", WM5100_DAC_VOLUME_LIMIT_5L,\n\t   WM5100_OUT5_OSR_SHIFT, 1, 0),\nSOC_SINGLE(\"SPKDAT2 High Performance Switch\", WM5100_DAC_VOLUME_LIMIT_6L,\n\t   WM5100_OUT6_OSR_SHIFT, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"HPOUT1 Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_1L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_1R, WM5100_OUT1L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\nSOC_DOUBLE_R_TLV(\"HPOUT2 Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_2L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_2R, WM5100_OUT2L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\nSOC_DOUBLE_R_TLV(\"HPOUT3 Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_3L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_3R, WM5100_OUT3L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\nSOC_DOUBLE_R_TLV(\"SPKOUT Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_4L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_4R, WM5100_OUT4L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\nSOC_DOUBLE_R_TLV(\"SPKDAT1 Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_5L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_5R, WM5100_OUT5L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\nSOC_DOUBLE_R_TLV(\"SPKDAT2 Digital Volume\", WM5100_DAC_DIGITAL_VOLUME_6L,\n\t\t WM5100_DAC_DIGITAL_VOLUME_6R, WM5100_OUT6L_VOL_SHIFT, 159, 0,\n\t\t digital_tlv),\n\nSOC_DOUBLE_R(\"HPOUT1 Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_1L,\n\t     WM5100_DAC_DIGITAL_VOLUME_1R, WM5100_OUT1L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"HPOUT2 Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_2L,\n\t     WM5100_DAC_DIGITAL_VOLUME_2R, WM5100_OUT2L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"HPOUT3 Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_3L,\n\t     WM5100_DAC_DIGITAL_VOLUME_3R, WM5100_OUT3L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"SPKOUT Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_4L,\n\t     WM5100_DAC_DIGITAL_VOLUME_4R, WM5100_OUT4L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"SPKDAT1 Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_5L,\n\t     WM5100_DAC_DIGITAL_VOLUME_5R, WM5100_OUT5L_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE_R(\"SPKDAT2 Digital Switch\", WM5100_DAC_DIGITAL_VOLUME_6L,\n\t     WM5100_DAC_DIGITAL_VOLUME_6R, WM5100_OUT6L_MUTE_SHIFT, 1, 1),\n\n \nSOC_DOUBLE_R_TLV(\"HPOUT1 Volume\", WM5100_OUT_VOLUME_1L, WM5100_OUT_VOLUME_1R,\n\t\t WM5100_OUT1L_PGA_VOL_SHIFT, 64, 0, out_tlv),\nSOC_DOUBLE_R_TLV(\"HPOUT2 Volume\", WM5100_OUT_VOLUME_2L, WM5100_OUT_VOLUME_2R,\n\t\t WM5100_OUT2L_PGA_VOL_SHIFT, 64, 0, out_tlv),\nSOC_DOUBLE_R_TLV(\"HPOUT3 Volume\", WM5100_OUT_VOLUME_3L, WM5100_OUT_VOLUME_3R,\n\t\t WM5100_OUT2L_PGA_VOL_SHIFT, 64, 0, out_tlv),\n\nSOC_DOUBLE(\"SPKDAT1 Switch\", WM5100_PDM_SPK1_CTRL_1, WM5100_SPK1L_MUTE_SHIFT,\n\t   WM5100_SPK1R_MUTE_SHIFT, 1, 1),\nSOC_DOUBLE(\"SPKDAT2 Switch\", WM5100_PDM_SPK2_CTRL_1, WM5100_SPK2L_MUTE_SHIFT,\n\t   WM5100_SPK2R_MUTE_SHIFT, 1, 1),\n\nSOC_SINGLE_TLV(\"EQ1 Band 1 Volume\", WM5100_EQ1_1, WM5100_EQ1_B1_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ1 Band 2 Volume\", WM5100_EQ1_1, WM5100_EQ1_B2_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ1 Band 3 Volume\", WM5100_EQ1_1, WM5100_EQ1_B3_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ1 Band 4 Volume\", WM5100_EQ1_2, WM5100_EQ1_B4_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ1 Band 5 Volume\", WM5100_EQ1_2, WM5100_EQ1_B5_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\n\nSOC_SINGLE_TLV(\"EQ2 Band 1 Volume\", WM5100_EQ2_1, WM5100_EQ2_B1_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Band 2 Volume\", WM5100_EQ2_1, WM5100_EQ2_B2_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Band 3 Volume\", WM5100_EQ2_1, WM5100_EQ2_B3_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Band 4 Volume\", WM5100_EQ2_2, WM5100_EQ2_B4_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Band 5 Volume\", WM5100_EQ2_2, WM5100_EQ2_B5_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\n\nSOC_SINGLE_TLV(\"EQ3 Band 1 Volume\", WM5100_EQ1_1, WM5100_EQ3_B1_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Band 2 Volume\", WM5100_EQ3_1, WM5100_EQ3_B2_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Band 3 Volume\", WM5100_EQ3_1, WM5100_EQ3_B3_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Band 4 Volume\", WM5100_EQ3_2, WM5100_EQ3_B4_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Band 5 Volume\", WM5100_EQ3_2, WM5100_EQ3_B5_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\n\nSOC_SINGLE_TLV(\"EQ4 Band 1 Volume\", WM5100_EQ4_1, WM5100_EQ4_B1_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Band 2 Volume\", WM5100_EQ4_1, WM5100_EQ4_B2_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Band 3 Volume\", WM5100_EQ4_1, WM5100_EQ4_B3_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Band 4 Volume\", WM5100_EQ4_2, WM5100_EQ4_B4_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Band 5 Volume\", WM5100_EQ4_2, WM5100_EQ4_B5_GAIN_SHIFT,\n\t       24, 0, eq_tlv),\n\nSOC_ENUM(\"LHPF1 Mode\", wm5100_lhpf1_mode),\nSOC_ENUM(\"LHPF2 Mode\", wm5100_lhpf2_mode),\nSOC_ENUM(\"LHPF3 Mode\", wm5100_lhpf3_mode),\nSOC_ENUM(\"LHPF4 Mode\", wm5100_lhpf4_mode),\n\nWM5100_MIXER_CONTROLS(\"HPOUT1L\", WM5100_OUT1LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"HPOUT1R\", WM5100_OUT1RMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"HPOUT2L\", WM5100_OUT2LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"HPOUT2R\", WM5100_OUT2RMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"HPOUT3L\", WM5100_OUT3LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"HPOUT3R\", WM5100_OUT3RMIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"SPKOUTL\", WM5100_OUT4LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"SPKOUTR\", WM5100_OUT4RMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"SPKDAT1L\", WM5100_OUT5LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"SPKDAT1R\", WM5100_OUT5RMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"SPKDAT2L\", WM5100_OUT6LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"SPKDAT2R\", WM5100_OUT6RMIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"PWM1\", WM5100_PWM1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"PWM2\", WM5100_PWM2MIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"AIF1TX1\", WM5100_AIF1TX1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX2\", WM5100_AIF1TX2MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX3\", WM5100_AIF1TX3MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX4\", WM5100_AIF1TX4MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX5\", WM5100_AIF1TX5MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX6\", WM5100_AIF1TX6MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX7\", WM5100_AIF1TX7MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF1TX8\", WM5100_AIF1TX8MIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"AIF2TX1\", WM5100_AIF2TX1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF2TX2\", WM5100_AIF2TX2MIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"AIF3TX1\", WM5100_AIF3TX1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"AIF3TX2\", WM5100_AIF3TX2MIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"EQ1\", WM5100_EQ1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"EQ2\", WM5100_EQ2MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"EQ3\", WM5100_EQ3MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"EQ4\", WM5100_EQ4MIX_INPUT_1_SOURCE),\n\nWM5100_MIXER_CONTROLS(\"DRC1L\", WM5100_DRC1LMIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"DRC1R\", WM5100_DRC1RMIX_INPUT_1_SOURCE),\nSND_SOC_BYTES_MASK(\"DRC\", WM5100_DRC1_CTRL1, 5,\n\t\t   WM5100_DRCL_ENA | WM5100_DRCR_ENA),\n\nWM5100_MIXER_CONTROLS(\"LHPF1\", WM5100_HPLP1MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"LHPF2\", WM5100_HPLP2MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"LHPF3\", WM5100_HPLP3MIX_INPUT_1_SOURCE),\nWM5100_MIXER_CONTROLS(\"LHPF4\", WM5100_HPLP4MIX_INPUT_1_SOURCE),\n};\n\nstatic void wm5100_seq_notifier(struct snd_soc_component *component,\n\t\t\t\tenum snd_soc_dapm_type event, int subseq)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tu16 val, expect, i;\n\n\t \n\tif (wm5100->out_ena[0]) {\n\t\texpect = snd_soc_component_read(component, WM5100_CHANNEL_ENABLES_1);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tval = snd_soc_component_read(component, WM5100_OUTPUT_STATUS_1);\n\t\t\tif (val == expect) {\n\t\t\t\twm5100->out_ena[0] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 200) {\n\t\t\tdev_err(component->dev, \"Timeout waiting for OUTPUT1 %x\\n\",\n\t\t\t\texpect);\n\t\t}\n\t}\n\n\tif (wm5100->out_ena[1]) {\n\t\texpect = snd_soc_component_read(component, WM5100_OUTPUT_ENABLES_2);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tval = snd_soc_component_read(component, WM5100_OUTPUT_STATUS_2);\n\t\t\tif (val == expect) {\n\t\t\t\twm5100->out_ena[1] = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 200) {\n\t\t\tdev_err(component->dev, \"Timeout waiting for OUTPUT2 %x\\n\",\n\t\t\t\texpect);\n\t\t}\n\t}\n}\n\nstatic int wm5100_out_ev(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol,\n\t\t\t int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\n\tswitch (w->reg) {\n\tcase WM5100_CHANNEL_ENABLES_1:\n\t\twm5100->out_ena[0] = true;\n\t\tbreak;\n\tcase WM5100_OUTPUT_ENABLES_2:\n\t\twm5100->out_ena[0] = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void wm5100_log_status3(struct wm5100_priv *wm5100, int val)\n{\n\tif (val & WM5100_SPK_SHUTDOWN_WARN_EINT)\n\t\tdev_crit(wm5100->dev, \"Speaker shutdown warning\\n\");\n\tif (val & WM5100_SPK_SHUTDOWN_EINT)\n\t\tdev_crit(wm5100->dev, \"Speaker shutdown\\n\");\n\tif (val & WM5100_CLKGEN_ERR_EINT)\n\t\tdev_crit(wm5100->dev, \"SYSCLK underclocked\\n\");\n\tif (val & WM5100_CLKGEN_ERR_ASYNC_EINT)\n\t\tdev_crit(wm5100->dev, \"ASYNCCLK underclocked\\n\");\n}\n\nstatic void wm5100_log_status4(struct wm5100_priv *wm5100, int val)\n{\n\tif (val & WM5100_AIF3_ERR_EINT)\n\t\tdev_err(wm5100->dev, \"AIF3 configuration error\\n\");\n\tif (val & WM5100_AIF2_ERR_EINT)\n\t\tdev_err(wm5100->dev, \"AIF2 configuration error\\n\");\n\tif (val & WM5100_AIF1_ERR_EINT)\n\t\tdev_err(wm5100->dev, \"AIF1 configuration error\\n\");\n\tif (val & WM5100_CTRLIF_ERR_EINT)\n\t\tdev_err(wm5100->dev, \"Control interface error\\n\");\n\tif (val & WM5100_ISRC2_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"ISRC2 underclocked\\n\");\n\tif (val & WM5100_ISRC1_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"ISRC1 underclocked\\n\");\n\tif (val & WM5100_FX_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"FX underclocked\\n\");\n\tif (val & WM5100_AIF3_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"AIF3 underclocked\\n\");\n\tif (val & WM5100_AIF2_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"AIF2 underclocked\\n\");\n\tif (val & WM5100_AIF1_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"AIF1 underclocked\\n\");\n\tif (val & WM5100_ASRC_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"ASRC underclocked\\n\");\n\tif (val & WM5100_DAC_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"DAC underclocked\\n\");\n\tif (val & WM5100_ADC_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"ADC underclocked\\n\");\n\tif (val & WM5100_MIXER_UNDERCLOCKED_EINT)\n\t\tdev_err(wm5100->dev, \"Mixer underclocked\\n\");\n}\n\nstatic int wm5100_post_ev(struct snd_soc_dapm_widget *w,\n\t\t\t  struct snd_kcontrol *kcontrol,\n\t\t\t  int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_component_read(component, WM5100_INTERRUPT_RAW_STATUS_3);\n\tret &= WM5100_SPK_SHUTDOWN_WARN_STS |\n\t\tWM5100_SPK_SHUTDOWN_STS | WM5100_CLKGEN_ERR_STS |\n\t\tWM5100_CLKGEN_ERR_ASYNC_STS;\n\twm5100_log_status3(wm5100, ret);\n\n\tret = snd_soc_component_read(component, WM5100_INTERRUPT_RAW_STATUS_4);\n\twm5100_log_status4(wm5100, ret);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget wm5100_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"SYSCLK\", WM5100_CLOCKING_3, WM5100_SYSCLK_ENA_SHIFT, 0,\n\t\t    NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"ASYNCCLK\", WM5100_CLOCKING_6, WM5100_ASYNC_CLK_ENA_SHIFT,\n\t\t    0, NULL, 0),\n\nSND_SOC_DAPM_REGULATOR_SUPPLY(\"CPVDD\", 20, 0),\nSND_SOC_DAPM_REGULATOR_SUPPLY(\"DBVDD2\", 0, 0),\nSND_SOC_DAPM_REGULATOR_SUPPLY(\"DBVDD3\", 0, 0),\n\nSND_SOC_DAPM_SUPPLY(\"CP1\", WM5100_HP_CHARGE_PUMP_1, WM5100_CP1_ENA_SHIFT, 0,\n\t\t    NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"CP2\", WM5100_MIC_CHARGE_PUMP_1, WM5100_CP2_ENA_SHIFT, 0,\n\t\t    NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"CP2 Active\", WM5100_MIC_CHARGE_PUMP_1,\n\t\t    WM5100_CP2_BYPASS_SHIFT, 1, NULL, 0),\n\nSND_SOC_DAPM_SUPPLY(\"MICBIAS1\", WM5100_MIC_BIAS_CTRL_1, WM5100_MICB1_ENA_SHIFT,\n\t\t    0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"MICBIAS2\", WM5100_MIC_BIAS_CTRL_2, WM5100_MICB2_ENA_SHIFT,\n\t\t    0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"MICBIAS3\", WM5100_MIC_BIAS_CTRL_3, WM5100_MICB3_ENA_SHIFT,\n\t\t    0, NULL, 0),\n\nSND_SOC_DAPM_INPUT(\"IN1L\"),\nSND_SOC_DAPM_INPUT(\"IN1R\"),\nSND_SOC_DAPM_INPUT(\"IN2L\"),\nSND_SOC_DAPM_INPUT(\"IN2R\"),\nSND_SOC_DAPM_INPUT(\"IN3L\"),\nSND_SOC_DAPM_INPUT(\"IN3R\"),\nSND_SOC_DAPM_INPUT(\"IN4L\"),\nSND_SOC_DAPM_INPUT(\"IN4R\"),\nSND_SOC_DAPM_SIGGEN(\"TONE\"),\n\nSND_SOC_DAPM_PGA_E(\"IN1L PGA\", WM5100_INPUT_ENABLES, WM5100_IN1L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN1R PGA\", WM5100_INPUT_ENABLES, WM5100_IN1R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN2L PGA\", WM5100_INPUT_ENABLES, WM5100_IN2L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN2R PGA\", WM5100_INPUT_ENABLES, WM5100_IN2R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN3L PGA\", WM5100_INPUT_ENABLES, WM5100_IN3L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN3R PGA\", WM5100_INPUT_ENABLES, WM5100_IN3R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN4L PGA\", WM5100_INPUT_ENABLES, WM5100_IN4L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"IN4R PGA\", WM5100_INPUT_ENABLES, WM5100_IN4R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\n\nSND_SOC_DAPM_PGA(\"Tone Generator 1\", WM5100_TONE_GENERATOR_1,\n\t\t WM5100_TONE1_ENA_SHIFT, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Tone Generator 2\", WM5100_TONE_GENERATOR_1,\n\t\t WM5100_TONE2_ENA_SHIFT, 0, NULL, 0),\n\nSND_SOC_DAPM_AIF_IN(\"AIF1RX1\", \"AIF1 Playback\", 0,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX2\", \"AIF1 Playback\", 1,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX2_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX3\", \"AIF1 Playback\", 2,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX3_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX4\", \"AIF1 Playback\", 3,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX4_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX5\", \"AIF1 Playback\", 4,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX5_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX6\", \"AIF1 Playback\", 5,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX6_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX7\", \"AIF1 Playback\", 6,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX7_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF1RX8\", \"AIF1 Playback\", 7,\n\t\t    WM5100_AUDIO_IF_1_27, WM5100_AIF1RX8_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_IN(\"AIF2RX1\", \"AIF2 Playback\", 0,\n\t\t    WM5100_AUDIO_IF_2_27, WM5100_AIF2RX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF2RX2\", \"AIF2 Playback\", 1,\n\t\t    WM5100_AUDIO_IF_2_27, WM5100_AIF2RX2_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_IN(\"AIF3RX1\", \"AIF3 Playback\", 0,\n\t\t    WM5100_AUDIO_IF_3_27, WM5100_AIF3RX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_IN(\"AIF3RX2\", \"AIF3 Playback\", 1,\n\t\t    WM5100_AUDIO_IF_3_27, WM5100_AIF3RX2_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX1\", \"AIF1 Capture\", 0,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX2\", \"AIF1 Capture\", 1,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX2_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX3\", \"AIF1 Capture\", 2,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX3_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX4\", \"AIF1 Capture\", 3,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX4_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX5\", \"AIF1 Capture\", 4,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX5_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX6\", \"AIF1 Capture\", 5,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX6_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX7\", \"AIF1 Capture\", 6,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX7_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF1TX8\", \"AIF1 Capture\", 7,\n\t\t    WM5100_AUDIO_IF_1_26, WM5100_AIF1TX8_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_OUT(\"AIF2TX1\", \"AIF2 Capture\", 0,\n\t\t    WM5100_AUDIO_IF_2_26, WM5100_AIF2TX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF2TX2\", \"AIF2 Capture\", 1,\n\t\t    WM5100_AUDIO_IF_2_26, WM5100_AIF2TX2_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_OUT(\"AIF3TX1\", \"AIF3 Capture\", 0,\n\t\t    WM5100_AUDIO_IF_3_26, WM5100_AIF3TX1_ENA_SHIFT, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIF3TX2\", \"AIF3 Capture\", 1,\n\t\t    WM5100_AUDIO_IF_3_26, WM5100_AIF3TX2_ENA_SHIFT, 0),\n\nSND_SOC_DAPM_PGA_E(\"OUT6L\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT6L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT6R\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT6R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT5L\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT5L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT5R\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT5R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT4L\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT4L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT4R\", WM5100_OUTPUT_ENABLES_2, WM5100_OUT4R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT3L\", WM5100_CHANNEL_ENABLES_1, WM5100_HP3L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT3R\", WM5100_CHANNEL_ENABLES_1, WM5100_HP3R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT2L\", WM5100_CHANNEL_ENABLES_1, WM5100_HP2L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT2R\", WM5100_CHANNEL_ENABLES_1, WM5100_HP2R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT1L\", WM5100_CHANNEL_ENABLES_1, WM5100_HP1L_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"OUT1R\", WM5100_CHANNEL_ENABLES_1, WM5100_HP1R_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"PWM1 Driver\", WM5100_PWM_DRIVE_1, WM5100_PWM1_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\nSND_SOC_DAPM_PGA_E(\"PWM2 Driver\", WM5100_PWM_DRIVE_1, WM5100_PWM2_ENA_SHIFT, 0,\n\t\t   NULL, 0, wm5100_out_ev, SND_SOC_DAPM_POST_PMU),\n\nSND_SOC_DAPM_PGA(\"EQ1\", WM5100_EQ1_1, WM5100_EQ1_ENA_SHIFT, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"EQ2\", WM5100_EQ2_1, WM5100_EQ2_ENA_SHIFT, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"EQ3\", WM5100_EQ3_1, WM5100_EQ3_ENA_SHIFT, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"EQ4\", WM5100_EQ4_1, WM5100_EQ4_ENA_SHIFT, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"DRC1L\", WM5100_DRC1_CTRL1, WM5100_DRCL_ENA_SHIFT, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"DRC1R\", WM5100_DRC1_CTRL1, WM5100_DRCR_ENA_SHIFT, 0,\n\t\t NULL, 0),\n\nSND_SOC_DAPM_PGA(\"LHPF1\", WM5100_HPLPF1_1, WM5100_LHPF1_ENA_SHIFT, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"LHPF2\", WM5100_HPLPF2_1, WM5100_LHPF2_ENA_SHIFT, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"LHPF3\", WM5100_HPLPF3_1, WM5100_LHPF3_ENA_SHIFT, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"LHPF4\", WM5100_HPLPF4_1, WM5100_LHPF4_ENA_SHIFT, 0,\n\t\t NULL, 0),\n\nWM5100_MIXER_WIDGETS(EQ1, \"EQ1\"),\nWM5100_MIXER_WIDGETS(EQ2, \"EQ2\"),\nWM5100_MIXER_WIDGETS(EQ3, \"EQ3\"),\nWM5100_MIXER_WIDGETS(EQ4, \"EQ4\"),\n\nWM5100_MIXER_WIDGETS(DRC1L, \"DRC1L\"),\nWM5100_MIXER_WIDGETS(DRC1R, \"DRC1R\"),\n\nWM5100_MIXER_WIDGETS(LHPF1, \"LHPF1\"),\nWM5100_MIXER_WIDGETS(LHPF2, \"LHPF2\"),\nWM5100_MIXER_WIDGETS(LHPF3, \"LHPF3\"),\nWM5100_MIXER_WIDGETS(LHPF4, \"LHPF4\"),\n\nWM5100_MIXER_WIDGETS(AIF1TX1, \"AIF1TX1\"),\nWM5100_MIXER_WIDGETS(AIF1TX2, \"AIF1TX2\"),\nWM5100_MIXER_WIDGETS(AIF1TX3, \"AIF1TX3\"),\nWM5100_MIXER_WIDGETS(AIF1TX4, \"AIF1TX4\"),\nWM5100_MIXER_WIDGETS(AIF1TX5, \"AIF1TX5\"),\nWM5100_MIXER_WIDGETS(AIF1TX6, \"AIF1TX6\"),\nWM5100_MIXER_WIDGETS(AIF1TX7, \"AIF1TX7\"),\nWM5100_MIXER_WIDGETS(AIF1TX8, \"AIF1TX8\"),\n\nWM5100_MIXER_WIDGETS(AIF2TX1, \"AIF2TX1\"),\nWM5100_MIXER_WIDGETS(AIF2TX2, \"AIF2TX2\"),\n\nWM5100_MIXER_WIDGETS(AIF3TX1, \"AIF3TX1\"),\nWM5100_MIXER_WIDGETS(AIF3TX2, \"AIF3TX2\"),\n\nWM5100_MIXER_WIDGETS(HPOUT1L, \"HPOUT1L\"),\nWM5100_MIXER_WIDGETS(HPOUT1R, \"HPOUT1R\"),\nWM5100_MIXER_WIDGETS(HPOUT2L, \"HPOUT2L\"),\nWM5100_MIXER_WIDGETS(HPOUT2R, \"HPOUT2R\"),\nWM5100_MIXER_WIDGETS(HPOUT3L, \"HPOUT3L\"),\nWM5100_MIXER_WIDGETS(HPOUT3R, \"HPOUT3R\"),\n\nWM5100_MIXER_WIDGETS(SPKOUTL, \"SPKOUTL\"),\nWM5100_MIXER_WIDGETS(SPKOUTR, \"SPKOUTR\"),\nWM5100_MIXER_WIDGETS(SPKDAT1L, \"SPKDAT1L\"),\nWM5100_MIXER_WIDGETS(SPKDAT1R, \"SPKDAT1R\"),\nWM5100_MIXER_WIDGETS(SPKDAT2L, \"SPKDAT2L\"),\nWM5100_MIXER_WIDGETS(SPKDAT2R, \"SPKDAT2R\"),\n\nWM5100_MIXER_WIDGETS(PWM1, \"PWM1\"),\nWM5100_MIXER_WIDGETS(PWM2, \"PWM2\"),\n\nSND_SOC_DAPM_OUTPUT(\"HPOUT1L\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUT1R\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUT2L\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUT2R\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUT3L\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUT3R\"),\nSND_SOC_DAPM_OUTPUT(\"SPKOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"SPKOUTR\"),\nSND_SOC_DAPM_OUTPUT(\"SPKDAT1\"),\nSND_SOC_DAPM_OUTPUT(\"SPKDAT2\"),\nSND_SOC_DAPM_OUTPUT(\"PWM1\"),\nSND_SOC_DAPM_OUTPUT(\"PWM2\"),\n};\n\n \nstatic const struct snd_soc_dapm_widget wm5100_dapm_widgets_noirq[] = {\nSND_SOC_DAPM_POST(\"Post\", wm5100_post_ev),\n};\n\nstatic const struct snd_soc_dapm_route wm5100_dapm_routes[] = {\n\t{ \"CP1\", NULL, \"CPVDD\" },\n\t{ \"CP2 Active\", NULL, \"CPVDD\" },\n\n\t{ \"IN1L\", NULL, \"SYSCLK\" },\n\t{ \"IN1R\", NULL, \"SYSCLK\" },\n\t{ \"IN2L\", NULL, \"SYSCLK\" },\n\t{ \"IN2R\", NULL, \"SYSCLK\" },\n\t{ \"IN3L\", NULL, \"SYSCLK\" },\n\t{ \"IN3R\", NULL, \"SYSCLK\" },\n\t{ \"IN4L\", NULL, \"SYSCLK\" },\n\t{ \"IN4R\", NULL, \"SYSCLK\" },\n\n\t{ \"OUT1L\", NULL, \"SYSCLK\" },\n\t{ \"OUT1R\", NULL, \"SYSCLK\" },\n\t{ \"OUT2L\", NULL, \"SYSCLK\" },\n\t{ \"OUT2R\", NULL, \"SYSCLK\" },\n\t{ \"OUT3L\", NULL, \"SYSCLK\" },\n\t{ \"OUT3R\", NULL, \"SYSCLK\" },\n\t{ \"OUT4L\", NULL, \"SYSCLK\" },\n\t{ \"OUT4R\", NULL, \"SYSCLK\" },\n\t{ \"OUT5L\", NULL, \"SYSCLK\" },\n\t{ \"OUT5R\", NULL, \"SYSCLK\" },\n\t{ \"OUT6L\", NULL, \"SYSCLK\" },\n\t{ \"OUT6R\", NULL, \"SYSCLK\" },\n\n\t{ \"AIF1RX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX3\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX4\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX5\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX6\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX7\", NULL, \"SYSCLK\" },\n\t{ \"AIF1RX8\", NULL, \"SYSCLK\" },\n\n\t{ \"AIF2RX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF2RX1\", NULL, \"DBVDD2\" },\n\t{ \"AIF2RX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF2RX2\", NULL, \"DBVDD2\" },\n\n\t{ \"AIF3RX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF3RX1\", NULL, \"DBVDD3\" },\n\t{ \"AIF3RX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF3RX2\", NULL, \"DBVDD3\" },\n\n\t{ \"AIF1TX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX3\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX4\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX5\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX6\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX7\", NULL, \"SYSCLK\" },\n\t{ \"AIF1TX8\", NULL, \"SYSCLK\" },\n\n\t{ \"AIF2TX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF2TX1\", NULL, \"DBVDD2\" },\n\t{ \"AIF2TX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF2TX2\", NULL, \"DBVDD2\" },\n\n\t{ \"AIF3TX1\", NULL, \"SYSCLK\" },\n\t{ \"AIF3TX1\", NULL, \"DBVDD3\" },\n\t{ \"AIF3TX2\", NULL, \"SYSCLK\" },\n\t{ \"AIF3TX2\", NULL, \"DBVDD3\" },\n\n\t{ \"MICBIAS1\", NULL, \"CP2\" },\n\t{ \"MICBIAS2\", NULL, \"CP2\" },\n\t{ \"MICBIAS3\", NULL, \"CP2\" },\n\n\t{ \"IN1L PGA\", NULL, \"CP2\" },\n\t{ \"IN1R PGA\", NULL, \"CP2\" },\n\t{ \"IN2L PGA\", NULL, \"CP2\" },\n\t{ \"IN2R PGA\", NULL, \"CP2\" },\n\t{ \"IN3L PGA\", NULL, \"CP2\" },\n\t{ \"IN3R PGA\", NULL, \"CP2\" },\n\t{ \"IN4L PGA\", NULL, \"CP2\" },\n\t{ \"IN4R PGA\", NULL, \"CP2\" },\n\n\t{ \"IN1L PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN1R PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN2L PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN2R PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN3L PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN3R PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN4L PGA\", NULL, \"CP2 Active\" },\n\t{ \"IN4R PGA\", NULL, \"CP2 Active\" },\n\n\t{ \"OUT1L\", NULL, \"CP1\" },\n\t{ \"OUT1R\", NULL, \"CP1\" },\n\t{ \"OUT2L\", NULL, \"CP1\" },\n\t{ \"OUT2R\", NULL, \"CP1\" },\n\t{ \"OUT3L\", NULL, \"CP1\" },\n\t{ \"OUT3R\", NULL, \"CP1\" },\n\n\t{ \"Tone Generator 1\", NULL, \"TONE\" },\n\t{ \"Tone Generator 2\", NULL, \"TONE\" },\n\n\t{ \"IN1L PGA\", NULL, \"IN1L\" },\n\t{ \"IN1R PGA\", NULL, \"IN1R\" },\n\t{ \"IN2L PGA\", NULL, \"IN2L\" },\n\t{ \"IN2R PGA\", NULL, \"IN2R\" },\n\t{ \"IN3L PGA\", NULL, \"IN3L\" },\n\t{ \"IN3R PGA\", NULL, \"IN3R\" },\n\t{ \"IN4L PGA\", NULL, \"IN4L\" },\n\t{ \"IN4R PGA\", NULL, \"IN4R\" },\n\n\tWM5100_MIXER_ROUTES(\"OUT1L\", \"HPOUT1L\"),\n\tWM5100_MIXER_ROUTES(\"OUT1R\", \"HPOUT1R\"),\n\tWM5100_MIXER_ROUTES(\"OUT2L\", \"HPOUT2L\"),\n\tWM5100_MIXER_ROUTES(\"OUT2R\", \"HPOUT2R\"),\n\tWM5100_MIXER_ROUTES(\"OUT3L\", \"HPOUT3L\"),\n\tWM5100_MIXER_ROUTES(\"OUT3R\", \"HPOUT3R\"),\n\n\tWM5100_MIXER_ROUTES(\"OUT4L\", \"SPKOUTL\"),\n\tWM5100_MIXER_ROUTES(\"OUT4R\", \"SPKOUTR\"),\n\tWM5100_MIXER_ROUTES(\"OUT5L\", \"SPKDAT1L\"),\n\tWM5100_MIXER_ROUTES(\"OUT5R\", \"SPKDAT1R\"),\n\tWM5100_MIXER_ROUTES(\"OUT6L\", \"SPKDAT2L\"),\n\tWM5100_MIXER_ROUTES(\"OUT6R\", \"SPKDAT2R\"),\n\n\tWM5100_MIXER_ROUTES(\"PWM1 Driver\", \"PWM1\"),\n\tWM5100_MIXER_ROUTES(\"PWM2 Driver\", \"PWM2\"),\n\n\tWM5100_MIXER_ROUTES(\"AIF1TX1\", \"AIF1TX1\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX2\", \"AIF1TX2\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX3\", \"AIF1TX3\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX4\", \"AIF1TX4\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX5\", \"AIF1TX5\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX6\", \"AIF1TX6\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX7\", \"AIF1TX7\"),\n\tWM5100_MIXER_ROUTES(\"AIF1TX8\", \"AIF1TX8\"),\n\n\tWM5100_MIXER_ROUTES(\"AIF2TX1\", \"AIF2TX1\"),\n\tWM5100_MIXER_ROUTES(\"AIF2TX2\", \"AIF2TX2\"),\n\n\tWM5100_MIXER_ROUTES(\"AIF3TX1\", \"AIF3TX1\"),\n\tWM5100_MIXER_ROUTES(\"AIF3TX2\", \"AIF3TX2\"),\n\n\tWM5100_MIXER_ROUTES(\"EQ1\", \"EQ1\"),\n\tWM5100_MIXER_ROUTES(\"EQ2\", \"EQ2\"),\n\tWM5100_MIXER_ROUTES(\"EQ3\", \"EQ3\"),\n\tWM5100_MIXER_ROUTES(\"EQ4\", \"EQ4\"),\n\n\tWM5100_MIXER_ROUTES(\"DRC1L\", \"DRC1L\"),\n\tWM5100_MIXER_ROUTES(\"DRC1R\", \"DRC1R\"),\n\n\tWM5100_MIXER_ROUTES(\"LHPF1\", \"LHPF1\"),\n\tWM5100_MIXER_ROUTES(\"LHPF2\", \"LHPF2\"),\n\tWM5100_MIXER_ROUTES(\"LHPF3\", \"LHPF3\"),\n\tWM5100_MIXER_ROUTES(\"LHPF4\", \"LHPF4\"),\n\n\t{ \"HPOUT1L\", NULL, \"OUT1L\" },\n\t{ \"HPOUT1R\", NULL, \"OUT1R\" },\n\t{ \"HPOUT2L\", NULL, \"OUT2L\" },\n\t{ \"HPOUT2R\", NULL, \"OUT2R\" },\n\t{ \"HPOUT3L\", NULL, \"OUT3L\" },\n\t{ \"HPOUT3R\", NULL, \"OUT3R\" },\n\t{ \"SPKOUTL\", NULL, \"OUT4L\" },\n\t{ \"SPKOUTR\", NULL, \"OUT4R\" },\n\t{ \"SPKDAT1\", NULL, \"OUT5L\" },\n\t{ \"SPKDAT1\", NULL, \"OUT5R\" },\n\t{ \"SPKDAT2\", NULL, \"OUT6L\" },\n\t{ \"SPKDAT2\", NULL, \"OUT6R\" },\n\t{ \"PWM1\", NULL, \"PWM1 Driver\" },\n\t{ \"PWM2\", NULL, \"PWM2 Driver\" },\n};\n\nstatic const struct reg_sequence wm5100_reva_patches[] = {\n\t{ WM5100_AUDIO_IF_1_10, 0 },\n\t{ WM5100_AUDIO_IF_1_11, 1 },\n\t{ WM5100_AUDIO_IF_1_12, 2 },\n\t{ WM5100_AUDIO_IF_1_13, 3 },\n\t{ WM5100_AUDIO_IF_1_14, 4 },\n\t{ WM5100_AUDIO_IF_1_15, 5 },\n\t{ WM5100_AUDIO_IF_1_16, 6 },\n\t{ WM5100_AUDIO_IF_1_17, 7 },\n\n\t{ WM5100_AUDIO_IF_1_18, 0 },\n\t{ WM5100_AUDIO_IF_1_19, 1 },\n\t{ WM5100_AUDIO_IF_1_20, 2 },\n\t{ WM5100_AUDIO_IF_1_21, 3 },\n\t{ WM5100_AUDIO_IF_1_22, 4 },\n\t{ WM5100_AUDIO_IF_1_23, 5 },\n\t{ WM5100_AUDIO_IF_1_24, 6 },\n\t{ WM5100_AUDIO_IF_1_25, 7 },\n\n\t{ WM5100_AUDIO_IF_2_10, 0 },\n\t{ WM5100_AUDIO_IF_2_11, 1 },\n\n\t{ WM5100_AUDIO_IF_2_18, 0 },\n\t{ WM5100_AUDIO_IF_2_19, 1 },\n\n\t{ WM5100_AUDIO_IF_3_10, 0 },\n\t{ WM5100_AUDIO_IF_3_11, 1 },\n\n\t{ WM5100_AUDIO_IF_3_18, 0 },\n\t{ WM5100_AUDIO_IF_3_19, 1 },\n};\n\nstatic int wm5100_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint lrclk, bclk, mask, base;\n\n\tbase = dai->driver->base;\n\n\tlrclk = 0;\n\tbclk = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tmask = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmask = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported DAI format %d\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\tlrclk |= WM5100_AIF1TX_LRCLK_MSTR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\tbclk |= WM5100_AIF1_BCLK_MSTR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tlrclk |= WM5100_AIF1TX_LRCLK_MSTR;\n\t\tbclk |= WM5100_AIF1_BCLK_MSTR;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported master mode %d\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_MASTER_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbclk |= WM5100_AIF1_BCLK_INV;\n\t\tlrclk |= WM5100_AIF1TX_LRCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbclk |= WM5100_AIF1_BCLK_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrclk |= WM5100_AIF1TX_LRCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, base + 1, WM5100_AIF1_BCLK_MSTR |\n\t\t\t    WM5100_AIF1_BCLK_INV, bclk);\n\tsnd_soc_component_update_bits(component, base + 2, WM5100_AIF1TX_LRCLK_MSTR |\n\t\t\t    WM5100_AIF1TX_LRCLK_INV, lrclk);\n\tsnd_soc_component_update_bits(component, base + 3, WM5100_AIF1TX_LRCLK_MSTR |\n\t\t\t    WM5100_AIF1TX_LRCLK_INV, lrclk);\n\tsnd_soc_component_update_bits(component, base + 5, WM5100_AIF1_FMT_MASK, mask);\n\n\treturn 0;\n}\n\n#define WM5100_NUM_BCLK_RATES 19\n\nstatic int wm5100_bclk_rates_dat[WM5100_NUM_BCLK_RATES] = {\n\t32000,\n\t48000,\n\t64000,\n\t96000,\n\t128000,\n\t192000,\n\t256000,\n\t384000,\n\t512000,\n\t768000,\n\t1024000,\n\t1536000,\n\t2048000,\n\t3072000,\n\t4096000,\n\t6144000,\n\t8192000,\n\t12288000,\n\t24576000,\n};\n\nstatic int wm5100_bclk_rates_cd[WM5100_NUM_BCLK_RATES] = {\n\t29400,\n\t44100,\n\t58800,\n\t88200,\n\t117600,\n\t176400,\n\t235200,\n\t352800,\n\t470400,\n\t705600,\n\t940800,\n\t1411200,\n\t1881600,\n\t2882400,\n\t3763200,\n\t5644800,\n\t7526400,\n\t11289600,\n\t22579600,\n};\n\nstatic int wm5100_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tbool async = wm5100->aif_async[dai->id];\n\tint i, base, bclk, aif_rate, lrclk, wl, fl, sr;\n\tint *bclk_rates;\n\n\tbase = dai->driver->base;\n\n\t \n\twl = params_width(params);\n\tif (wl < 0)\n\t\treturn wl;\n\tfl = snd_soc_params_to_frame_size(params);\n\tif (fl < 0)\n\t\treturn fl;\n\n\tdev_dbg(component->dev, \"Word length %d bits, frame length %d bits\\n\",\n\t\twl, fl);\n\n\t \n\tbclk = snd_soc_params_to_bclk(params);\n\tif (bclk < 0)\n\t\treturn bclk;\n\n\t \n\tif (!async) {\n\t\taif_rate = wm5100->sysclk;\n\t\tsr = wm5100_alloc_sr(component, params_rate(params));\n\t\tif (sr < 0)\n\t\t\treturn sr;\n\t} else {\n\t\t \n\t\taif_rate = wm5100->asyncclk;\n\t\tsr = 3;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(wm5100_sr_code); i++)\n\t\t\tif (params_rate(params) == wm5100_sr_code[i])\n\t\t\t\tbreak;\n\t\tif (i == ARRAY_SIZE(wm5100_sr_code)) {\n\t\t\tdev_err(component->dev, \"Invalid rate %dHzn\",\n\t\t\t\tparams_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM5100_CLOCKING_8,\n\t\t\t\t    WM5100_ASYNC_SAMPLE_RATE_MASK, i);\n\t}\n\n\tif (!aif_rate) {\n\t\tdev_err(component->dev, \"%s has no rate set\\n\",\n\t\t\tasync ? \"ASYNCCLK\" : \"SYSCLK\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"Target BCLK is %dHz, using %dHz %s\\n\",\n\t\tbclk, aif_rate, async ? \"ASYNCCLK\" : \"SYSCLK\");\n\n\tif (aif_rate % 4000)\n\t\tbclk_rates = wm5100_bclk_rates_cd;\n\telse\n\t\tbclk_rates = wm5100_bclk_rates_dat;\n\n\tfor (i = 0; i < WM5100_NUM_BCLK_RATES; i++)\n\t\tif (bclk_rates[i] >= bclk && (bclk_rates[i] % bclk == 0))\n\t\t\tbreak;\n\tif (i == WM5100_NUM_BCLK_RATES) {\n\t\tdev_err(component->dev,\n\t\t\t\"No valid BCLK for %dHz found from %dHz %s\\n\",\n\t\t\tbclk, aif_rate, async ? \"ASYNCCLK\" : \"SYSCLK\");\n\t\treturn -EINVAL;\n\t}\n\n\tbclk = i;\n\tdev_dbg(component->dev, \"Setting %dHz BCLK\\n\", bclk_rates[bclk]);\n\tsnd_soc_component_update_bits(component, base + 1, WM5100_AIF1_BCLK_FREQ_MASK, bclk);\n\n\tlrclk = bclk_rates[bclk] / params_rate(params);\n\tdev_dbg(component->dev, \"Setting %dHz LRCLK\\n\", bclk_rates[bclk] / lrclk);\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\n\t    wm5100->aif_symmetric[dai->id])\n\t\tsnd_soc_component_update_bits(component, base + 7,\n\t\t\t\t    WM5100_AIF1RX_BCPF_MASK, lrclk);\n\telse\n\t\tsnd_soc_component_update_bits(component, base + 6,\n\t\t\t\t    WM5100_AIF1TX_BCPF_MASK, lrclk);\n\n\ti = (wl << WM5100_AIF1TX_WL_SHIFT) | fl;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_soc_component_update_bits(component, base + 9,\n\t\t\t\t    WM5100_AIF1RX_WL_MASK |\n\t\t\t\t    WM5100_AIF1RX_SLOT_LEN_MASK, i);\n\telse\n\t\tsnd_soc_component_update_bits(component, base + 8,\n\t\t\t\t    WM5100_AIF1TX_WL_MASK |\n\t\t\t\t    WM5100_AIF1TX_SLOT_LEN_MASK, i);\n\n\tsnd_soc_component_update_bits(component, base + 4, WM5100_AIF1_RATE_MASK, sr);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wm5100_dai_ops = {\n\t.set_fmt = wm5100_set_fmt,\n\t.hw_params = wm5100_hw_params,\n};\n\nstatic int wm5100_set_sysclk(struct snd_soc_component *component, int clk_id,\n\t\t\t     int source, unsigned int freq, int dir)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tint *rate_store;\n\tint fval, audio_rate, ret, reg;\n\n\tswitch (clk_id) {\n\tcase WM5100_CLK_SYSCLK:\n\t\treg = WM5100_CLOCKING_3;\n\t\trate_store = &wm5100->sysclk;\n\t\tbreak;\n\tcase WM5100_CLK_ASYNCCLK:\n\t\treg = WM5100_CLOCKING_7;\n\t\trate_store = &wm5100->asyncclk;\n\t\tbreak;\n\tcase WM5100_CLK_32KHZ:\n\t\t \n\t\tswitch (source) {\n\t\tcase WM5100_CLKSRC_MCLK1:\n\t\tcase WM5100_CLKSRC_MCLK2:\n\t\tcase WM5100_CLKSRC_SYSCLK:\n\t\t\tsnd_soc_component_update_bits(component, WM5100_CLOCKING_1,\n\t\t\t\t\t    WM5100_CLK_32K_SRC_MASK,\n\t\t\t\t\t    source);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tcase WM5100_CLK_AIF1:\n\tcase WM5100_CLK_AIF2:\n\tcase WM5100_CLK_AIF3:\n\t\t \n\t\tswitch (source) {\n\t\tcase WM5100_CLKSRC_SYSCLK:\n\t\t\twm5100->aif_async[clk_id - 1] = false;\n\t\t\tbreak;\n\t\tcase WM5100_CLKSRC_ASYNCCLK:\n\t\t\twm5100->aif_async[clk_id - 1] = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Invalid source %d\\n\", source);\n\t\t\treturn -EINVAL;\n\t\t}\t\n\t\treturn 0;\n\n\tcase WM5100_CLK_OPCLK:\n\t\tswitch (freq) {\n\t\tcase 5644800:\n\t\tcase 6144000:\n\t\t\tsnd_soc_component_update_bits(component, WM5100_MISC_GPIO_1,\n\t\t\t\t\t    WM5100_OPCLK_SEL_MASK, 0);\n\t\t\tbreak;\n\t\tcase 11289600:\n\t\tcase 12288000:\n\t\t\tsnd_soc_component_update_bits(component, WM5100_MISC_GPIO_1,\n\t\t\t\t\t    WM5100_OPCLK_SEL_MASK, 0);\n\t\t\tbreak;\n\t\tcase 22579200:\n\t\tcase 24576000:\n\t\t\tsnd_soc_component_update_bits(component, WM5100_MISC_GPIO_1,\n\t\t\t\t\t    WM5100_OPCLK_SEL_MASK, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Unsupported OPCLK %dHz\\n\",\n\t\t\t\tfreq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown clock %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (source) {\n\tcase WM5100_CLKSRC_SYSCLK:\n\tcase WM5100_CLKSRC_ASYNCCLK:\n\t\tdev_err(component->dev, \"Invalid source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 5644800:\n\tcase 6144000:\n\t\tfval = 0;\n\t\tbreak;\n\tcase 11289600:\n\tcase 12288000:\n\t\tfval = 1;\n\t\tbreak;\n\tcase 22579200:\n\tcase 24576000:\n\t\tfval = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock rate: %d\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 5644800:\n\tcase 11289600:\n\tcase 22579200:\n\t\taudio_rate = 44100;\n\t\tbreak;\n\n\tcase 6144000:\n\tcase 12288000:\n\tcase 24576000:\n\t\taudio_rate = 48000;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\taudio_rate = 0;\n\t\tbreak;\n\t}\n\n\t \n\n\tsnd_soc_component_update_bits(component, reg, WM5100_SYSCLK_FREQ_MASK |\n\t\t\t    WM5100_SYSCLK_SRC_MASK,\n\t\t\t    fval << WM5100_SYSCLK_FREQ_SHIFT | source);\n\n\t \n\tif (clk_id == WM5100_CLK_SYSCLK) {\n\t\tdev_dbg(component->dev, \"Setting primary audio rate to %dHz\",\n\t\t\taudio_rate);\n\t\tif (0 && *rate_store)\n\t\t\twm5100_free_sr(component, audio_rate);\n\t\tret = wm5100_alloc_sr(component, audio_rate);\n\t\tif (ret != 0)\n\t\t\tdev_warn(component->dev, \"Primary audio slot is %d\\n\",\n\t\t\t\t ret);\n\t}\n\n\t*rate_store = freq;\n\n\treturn 0;\n}\n\nstruct _fll_div {\n\tu16 fll_fratio;\n\tu16 fll_outdiv;\n\tu16 fll_refclk_div;\n\tu16 n;\n\tu16 theta;\n\tu16 lambda;\n};\n\nstatic struct {\n\tunsigned int min;\n\tunsigned int max;\n\tu16 fll_fratio;\n\tint ratio;\n} fll_fratios[] = {\n\t{       0,    64000, 4, 16 },\n\t{   64000,   128000, 3,  8 },\n\t{  128000,   256000, 2,  4 },\n\t{  256000,  1000000, 1,  2 },\n\t{ 1000000, 13500000, 0,  1 },\n};\n\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\n\t\t       unsigned int Fout)\n{\n\tunsigned int target;\n\tunsigned int div;\n\tunsigned int fratio, gcd_fll;\n\tint i;\n\n\t \n\tdiv = 1;\n\tfll_div->fll_refclk_div = 0;\n\twhile ((Fref / div) > 13500000) {\n\t\tdiv *= 2;\n\t\tfll_div->fll_refclk_div++;\n\n\t\tif (div > 8) {\n\t\t\tpr_err(\"Can't scale %dMHz input down to <=13.5MHz\\n\",\n\t\t\t       Fref);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpr_debug(\"FLL Fref=%u Fout=%u\\n\", Fref, Fout);\n\n\t \n\tFref /= div;\n\n\t \n\tdiv = 2;\n\twhile (Fout * div < 90000000) {\n\t\tdiv++;\n\t\tif (div > 64) {\n\t\t\tpr_err(\"Unable to find FLL_OUTDIV for Fout=%uHz\\n\",\n\t\t\t       Fout);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\ttarget = Fout * div;\n\tfll_div->fll_outdiv = div - 1;\n\n\tpr_debug(\"FLL Fvco=%dHz\\n\", target);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\n\t\tif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\n\t\t\tfll_div->fll_fratio = fll_fratios[i].fll_fratio;\n\t\t\tfratio = fll_fratios[i].ratio;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(fll_fratios)) {\n\t\tpr_err(\"Unable to find FLL_FRATIO for Fref=%uHz\\n\", Fref);\n\t\treturn -EINVAL;\n\t}\n\n\tfll_div->n = target / (fratio * Fref);\n\n\tif (target % Fref == 0) {\n\t\tfll_div->theta = 0;\n\t\tfll_div->lambda = 0;\n\t} else {\n\t\tgcd_fll = gcd(target, fratio * Fref);\n\n\t\tfll_div->theta = (target - (fll_div->n * fratio * Fref))\n\t\t\t/ gcd_fll;\n\t\tfll_div->lambda = (fratio * Fref) / gcd_fll;\n\t}\n\n\tpr_debug(\"FLL N=%x THETA=%x LAMBDA=%x\\n\",\n\t\t fll_div->n, fll_div->theta, fll_div->lambda);\n\tpr_debug(\"FLL_FRATIO=%x(%d) FLL_OUTDIV=%x FLL_REFCLK_DIV=%x\\n\",\n\t\t fll_div->fll_fratio, fratio, fll_div->fll_outdiv,\n\t\t fll_div->fll_refclk_div);\n\n\treturn 0;\n}\n\nstatic int wm5100_set_fll(struct snd_soc_component *component, int fll_id, int source,\n\t\t\t  unsigned int Fref, unsigned int Fout)\n{\n\tstruct i2c_client *i2c = to_i2c_client(component->dev);\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tstruct _fll_div factors;\n\tstruct wm5100_fll *fll;\n\tint ret, base, lock, i, timeout;\n\tunsigned long time_left;\n\n\tswitch (fll_id) {\n\tcase WM5100_FLL1:\n\t\tfll = &wm5100->fll[0];\n\t\tbase = WM5100_FLL1_CONTROL_1 - 1;\n\t\tlock = WM5100_FLL1_LOCK_STS;\n\t\tbreak;\n\tcase WM5100_FLL2:\n\t\tfll = &wm5100->fll[1];\n\t\tbase = WM5100_FLL2_CONTROL_2 - 1;\n\t\tlock = WM5100_FLL2_LOCK_STS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown FLL %d\\n\",fll_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!Fout) {\n\t\tdev_dbg(component->dev, \"FLL%d disabled\", fll_id);\n\t\tif (fll->fout)\n\t\t\tpm_runtime_put(component->dev);\n\t\tfll->fout = 0;\n\t\tsnd_soc_component_update_bits(component, base + 1, WM5100_FLL1_ENA, 0);\n\t\treturn 0;\n\t}\n\n\tswitch (source) {\n\tcase WM5100_FLL_SRC_MCLK1:\n\tcase WM5100_FLL_SRC_MCLK2:\n\tcase WM5100_FLL_SRC_FLL1:\n\tcase WM5100_FLL_SRC_FLL2:\n\tcase WM5100_FLL_SRC_AIF1BCLK:\n\tcase WM5100_FLL_SRC_AIF2BCLK:\n\tcase WM5100_FLL_SRC_AIF3BCLK:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid FLL source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = fll_factors(&factors, Fref, Fout);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsnd_soc_component_update_bits(component, base + 1, WM5100_FLL1_ENA, 0);\n\n\tsnd_soc_component_update_bits(component, base + 2,\n\t\t\t    WM5100_FLL1_OUTDIV_MASK | WM5100_FLL1_FRATIO_MASK,\n\t\t\t    (factors.fll_outdiv << WM5100_FLL1_OUTDIV_SHIFT) |\n\t\t\t    factors.fll_fratio);\n\tsnd_soc_component_update_bits(component, base + 3, WM5100_FLL1_THETA_MASK,\n\t\t\t    factors.theta);\n\tsnd_soc_component_update_bits(component, base + 5, WM5100_FLL1_N_MASK, factors.n);\n\tsnd_soc_component_update_bits(component, base + 6,\n\t\t\t    WM5100_FLL1_REFCLK_DIV_MASK |\n\t\t\t    WM5100_FLL1_REFCLK_SRC_MASK,\n\t\t\t    (factors.fll_refclk_div\n\t\t\t     << WM5100_FLL1_REFCLK_DIV_SHIFT) | source);\n\tsnd_soc_component_update_bits(component, base + 7, WM5100_FLL1_LAMBDA_MASK,\n\t\t\t    factors.lambda);\n\n\t \n\ttry_wait_for_completion(&fll->lock);\n\n\tpm_runtime_get_sync(component->dev);\n\n\tsnd_soc_component_update_bits(component, base + 1, WM5100_FLL1_ENA, WM5100_FLL1_ENA);\n\n\tif (i2c->irq)\n\t\ttimeout = 2;\n\telse\n\t\ttimeout = 50;\n\n\tsnd_soc_component_update_bits(component, WM5100_CLOCKING_3, WM5100_SYSCLK_ENA,\n\t\t\t    WM5100_SYSCLK_ENA);\n\n\t \n\tfor (i = 0; i < timeout; i++) {\n\t\tif (i2c->irq) {\n\t\t\ttime_left = wait_for_completion_timeout(&fll->lock,\n\t\t\t\t\t\t\tmsecs_to_jiffies(25));\n\t\t\tif (time_left > 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tmsleep(1);\n\t\t}\n\n\t\tret = snd_soc_component_read(component,\n\t\t\t\t   WM5100_INTERRUPT_RAW_STATUS_3);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to read FLL status: %d\\n\",\n\t\t\t\tret);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret & lock)\n\t\t\tbreak;\n\t}\n\tif (i == timeout) {\n\t\tdev_err(component->dev, \"FLL%d lock timed out\\n\", fll_id);\n\t\tpm_runtime_put(component->dev);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tfll->src = source;\n\tfll->fref = Fref;\n\tfll->fout = Fout;\n\n\tdev_dbg(component->dev, \"FLL%d running %dHz->%dHz\\n\", fll_id,\n\t\tFref, Fout);\n\n\treturn 0;\n}\n\n \n#define WM5100_RATES SNDRV_PCM_RATE_8000_192000\n\n#define WM5100_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver wm5100_dai[] = {\n\t{\n\t\t.name = \"wm5100-aif1\",\n\t\t.base = WM5100_AUDIO_IF_1_1 - 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = WM5100_RATES,\n\t\t\t.formats = WM5100_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .stream_name = \"AIF1 Capture\",\n\t\t\t .channels_min = 2,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = WM5100_RATES,\n\t\t\t .formats = WM5100_FORMATS,\n\t\t },\n\t\t.ops = &wm5100_dai_ops,\n\t},\n\t{\n\t\t.name = \"wm5100-aif2\",\n\t\t.id = 1,\n\t\t.base = WM5100_AUDIO_IF_2_1 - 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF2 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = WM5100_RATES,\n\t\t\t.formats = WM5100_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .stream_name = \"AIF2 Capture\",\n\t\t\t .channels_min = 2,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = WM5100_RATES,\n\t\t\t .formats = WM5100_FORMATS,\n\t\t },\n\t\t.ops = &wm5100_dai_ops,\n\t},\n\t{\n\t\t.name = \"wm5100-aif3\",\n\t\t.id = 2,\n\t\t.base = WM5100_AUDIO_IF_3_1 - 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF3 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = WM5100_RATES,\n\t\t\t.formats = WM5100_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .stream_name = \"AIF3 Capture\",\n\t\t\t .channels_min = 2,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = WM5100_RATES,\n\t\t\t .formats = WM5100_FORMATS,\n\t\t },\n\t\t.ops = &wm5100_dai_ops,\n\t},\n};\n\nstatic int wm5100_dig_vu[] = {\n\tWM5100_ADC_DIGITAL_VOLUME_1L,\n\tWM5100_ADC_DIGITAL_VOLUME_1R,\n\tWM5100_ADC_DIGITAL_VOLUME_2L,\n\tWM5100_ADC_DIGITAL_VOLUME_2R,\n\tWM5100_ADC_DIGITAL_VOLUME_3L,\n\tWM5100_ADC_DIGITAL_VOLUME_3R,\n\tWM5100_ADC_DIGITAL_VOLUME_4L,\n\tWM5100_ADC_DIGITAL_VOLUME_4R,\n\n\tWM5100_DAC_DIGITAL_VOLUME_1L,\n\tWM5100_DAC_DIGITAL_VOLUME_1R,\n\tWM5100_DAC_DIGITAL_VOLUME_2L,\n\tWM5100_DAC_DIGITAL_VOLUME_2R,\n\tWM5100_DAC_DIGITAL_VOLUME_3L,\n\tWM5100_DAC_DIGITAL_VOLUME_3R,\n\tWM5100_DAC_DIGITAL_VOLUME_4L,\n\tWM5100_DAC_DIGITAL_VOLUME_4R,\n\tWM5100_DAC_DIGITAL_VOLUME_5L,\n\tWM5100_DAC_DIGITAL_VOLUME_5R,\n\tWM5100_DAC_DIGITAL_VOLUME_6L,\n\tWM5100_DAC_DIGITAL_VOLUME_6R,\n};\n\nstatic void wm5100_set_detect_mode(struct wm5100_priv *wm5100, int the_mode)\n{\n\tstruct wm5100_jack_mode *mode = &wm5100->pdata.jack_modes[the_mode];\n\n\tif (WARN_ON(the_mode >= ARRAY_SIZE(wm5100->pdata.jack_modes)))\n\t\treturn;\n\n\tgpio_set_value_cansleep(wm5100->pdata.hp_pol, mode->hp_pol);\n\tregmap_update_bits(wm5100->regmap, WM5100_ACCESSORY_DETECT_MODE_1,\n\t\t\t   WM5100_ACCDET_BIAS_SRC_MASK |\n\t\t\t   WM5100_ACCDET_SRC,\n\t\t\t   (mode->bias << WM5100_ACCDET_BIAS_SRC_SHIFT) |\n\t\t\t   mode->micd_src << WM5100_ACCDET_SRC_SHIFT);\n\tregmap_update_bits(wm5100->regmap, WM5100_MISC_CONTROL,\n\t\t\t   WM5100_HPCOM_SRC,\n\t\t\t   mode->micd_src << WM5100_HPCOM_SRC_SHIFT);\n\n\twm5100->jack_mode = the_mode;\n\n\tdev_dbg(wm5100->dev, \"Set microphone polarity to %d\\n\",\n\t\twm5100->jack_mode);\n}\n\nstatic void wm5100_report_headphone(struct wm5100_priv *wm5100)\n{\n\tdev_dbg(wm5100->dev, \"Headphone detected\\n\");\n\twm5100->jack_detecting = false;\n\tsnd_soc_jack_report(wm5100->jack, SND_JACK_HEADPHONE,\n\t\t\t    SND_JACK_HEADPHONE);\n\n\t \n\tregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\n\t\t\t   WM5100_ACCDET_RATE_MASK,\n\t\t\t   7 << WM5100_ACCDET_RATE_SHIFT);\n}\n\nstatic void wm5100_micd_irq(struct wm5100_priv *wm5100)\n{\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_read(wm5100->regmap, WM5100_MIC_DETECT_3, &val);\n\tif (ret != 0) {\n\t\tdev_err(wm5100->dev, \"Failed to read microphone status: %d\\n\",\n\t\t\tret);\n\t\treturn;\n\t}\n\n\tdev_dbg(wm5100->dev, \"Microphone event: %x\\n\", val);\n\n\tif (!(val & WM5100_ACCDET_VALID)) {\n\t\tdev_warn(wm5100->dev, \"Microphone detection state invalid\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!(val & WM5100_ACCDET_STS)) {\n\t\tdev_dbg(wm5100->dev, \"Jack removal detected\\n\");\n\t\twm5100->jack_mic = false;\n\t\twm5100->jack_detecting = true;\n\t\twm5100->jack_flips = 0;\n\t\tsnd_soc_jack_report(wm5100->jack, 0,\n\t\t\t\t    SND_JACK_LINEOUT | SND_JACK_HEADSET |\n\t\t\t\t    SND_JACK_BTN_0);\n\n\t\tregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\n\t\t\t\t   WM5100_ACCDET_RATE_MASK,\n\t\t\t\t   WM5100_ACCDET_RATE_MASK);\n\t\treturn;\n\t}\n\n\t \n\tif (val & 0x400) {\n\t\tif (wm5100->jack_detecting) {\n\t\t\tdev_dbg(wm5100->dev, \"Microphone detected\\n\");\n\t\t\twm5100->jack_mic = true;\n\t\t\twm5100->jack_detecting = false;\n\t\t\tsnd_soc_jack_report(wm5100->jack,\n\t\t\t\t\t    SND_JACK_HEADSET,\n\t\t\t\t\t    SND_JACK_HEADSET | SND_JACK_BTN_0);\n\n\t\t\t \n\t\t\tregmap_update_bits(wm5100->regmap, WM5100_MIC_DETECT_1,\n\t\t\t\t\t   WM5100_ACCDET_RATE_MASK,\n\t\t\t\t\t   5 << WM5100_ACCDET_RATE_SHIFT);\n\t\t} else {\n\t\t\tdev_dbg(wm5100->dev, \"Mic button up\\n\");\n\t\t\tsnd_soc_jack_report(wm5100->jack, 0, SND_JACK_BTN_0);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tif (wm5100->jack_detecting && (val & 0x3f8)) {\n\t\twm5100->jack_flips++;\n\n\t\tif (wm5100->jack_flips > 1)\n\t\t\twm5100_report_headphone(wm5100);\n\t\telse\n\t\t\twm5100_set_detect_mode(wm5100, !wm5100->jack_mode);\n\n\t\treturn;\n\t}\n\n\t \n\tif (val & 0x3fc) {\n\t\tif (wm5100->jack_mic) {\n\t\t\tdev_dbg(wm5100->dev, \"Mic button detected\\n\");\n\t\t\tsnd_soc_jack_report(wm5100->jack, SND_JACK_BTN_0,\n\t\t\t\t\t    SND_JACK_BTN_0);\n\t\t} else if (wm5100->jack_detecting) {\n\t\t\twm5100_report_headphone(wm5100);\n\t\t}\n\t}\n}\n\nint wm5100_detect(struct snd_soc_component *component, struct snd_soc_jack *jack)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tif (jack) {\n\t\twm5100->jack = jack;\n\t\twm5100->jack_detecting = true;\n\t\twm5100->jack_flips = 0;\n\n\t\twm5100_set_detect_mode(wm5100, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM5100_MIC_DETECT_1,\n\t\t\t\t    WM5100_ACCDET_BIAS_STARTTIME_MASK |\n\t\t\t\t    WM5100_ACCDET_RATE_MASK,\n\t\t\t\t    (7 << WM5100_ACCDET_BIAS_STARTTIME_SHIFT) |\n\t\t\t\t    WM5100_ACCDET_RATE_MASK);\n\n\t\t \n\t\tsnd_soc_dapm_mutex_lock(dapm);\n\n\t\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"CP2\");\n\t\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"SYSCLK\");\n\n\t\tsnd_soc_dapm_sync_unlocked(dapm);\n\n\t\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM5100_MIC_DETECT_1,\n\t\t\t\t    WM5100_ACCDET_ENA, WM5100_ACCDET_ENA);\n\n\t\tsnd_soc_component_update_bits(component, WM5100_INTERRUPT_STATUS_3_MASK,\n\t\t\t\t    WM5100_IM_ACCDET_EINT, 0);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, WM5100_INTERRUPT_STATUS_3_MASK,\n\t\t\t\t    WM5100_IM_HPDET_EINT |\n\t\t\t\t    WM5100_IM_ACCDET_EINT,\n\t\t\t\t    WM5100_IM_HPDET_EINT |\n\t\t\t\t    WM5100_IM_ACCDET_EINT);\n\t\tsnd_soc_component_update_bits(component, WM5100_MIC_DETECT_1,\n\t\t\t\t    WM5100_ACCDET_ENA, 0);\n\t\twm5100->jack = NULL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm5100_detect);\n\nstatic irqreturn_t wm5100_irq(int irq, void *data)\n{\n\tstruct wm5100_priv *wm5100 = data;\n\tirqreturn_t status = IRQ_NONE;\n\tunsigned int irq_val, mask_val;\n\tint ret;\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, &irq_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, \"Failed to read IRQ status 3: %d\\n\",\n\t\t\tret);\n\t\tirq_val = 0;\n\t}\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_3_MASK,\n\t\t\t  &mask_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, \"Failed to read IRQ mask 3: %d\\n\",\n\t\t\tret);\n\t\tmask_val = 0xffff;\n\t}\n\n\tirq_val &= ~mask_val;\n\n\tregmap_write(wm5100->regmap, WM5100_INTERRUPT_STATUS_3, irq_val);\n\n\tif (irq_val)\n\t\tstatus = IRQ_HANDLED;\n\n\twm5100_log_status3(wm5100, irq_val);\n\n\tif (irq_val & WM5100_FLL1_LOCK_EINT) {\n\t\tdev_dbg(wm5100->dev, \"FLL1 locked\\n\");\n\t\tcomplete(&wm5100->fll[0].lock);\n\t}\n\tif (irq_val & WM5100_FLL2_LOCK_EINT) {\n\t\tdev_dbg(wm5100->dev, \"FLL2 locked\\n\");\n\t\tcomplete(&wm5100->fll[1].lock);\n\t}\n\n\tif (irq_val & WM5100_ACCDET_EINT)\n\t\twm5100_micd_irq(wm5100);\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_4, &irq_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, \"Failed to read IRQ status 4: %d\\n\",\n\t\t\tret);\n\t\tirq_val = 0;\n\t}\n\n\tret = regmap_read(wm5100->regmap, WM5100_INTERRUPT_STATUS_4_MASK,\n\t\t\t  &mask_val);\n\tif (ret < 0) {\n\t\tdev_err(wm5100->dev, \"Failed to read IRQ mask 4: %d\\n\",\n\t\t\tret);\n\t\tmask_val = 0xffff;\n\t}\n\n\tirq_val &= ~mask_val;\n\n\tif (irq_val)\n\t\tstatus = IRQ_HANDLED;\n\n\tregmap_write(wm5100->regmap, WM5100_INTERRUPT_STATUS_4, irq_val);\n\n\twm5100_log_status4(wm5100, irq_val);\n\n\treturn status;\n}\n\nstatic irqreturn_t wm5100_edge_irq(int irq, void *data)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tirqreturn_t val;\n\n\tdo {\n\t\tval = wm5100_irq(irq, data);\n\t\tif (val != IRQ_NONE)\n\t\t\tret = val;\n\t} while (val != IRQ_NONE);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic void wm5100_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct wm5100_priv *wm5100 = gpiochip_get_data(chip);\n\n\tregmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\n\t\t\t   WM5100_GP1_LVL, !!value << WM5100_GP1_LVL_SHIFT);\n}\n\nstatic int wm5100_gpio_direction_out(struct gpio_chip *chip,\n\t\t\t\t     unsigned offset, int value)\n{\n\tstruct wm5100_priv *wm5100 = gpiochip_get_data(chip);\n\tint val, ret;\n\n\tval = (1 << WM5100_GP1_FN_SHIFT) | (!!value << WM5100_GP1_LVL_SHIFT);\n\n\tret = regmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\n\t\t\t\t WM5100_GP1_FN_MASK | WM5100_GP1_DIR |\n\t\t\t\t WM5100_GP1_LVL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\telse\n\t\treturn 0;\n}\n\nstatic int wm5100_gpio_get(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm5100_priv *wm5100 = gpiochip_get_data(chip);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (reg & WM5100_GP1_LVL) != 0;\n}\n\nstatic int wm5100_gpio_direction_in(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct wm5100_priv *wm5100 = gpiochip_get_data(chip);\n\n\treturn regmap_update_bits(wm5100->regmap, WM5100_GPIO_CTRL_1 + offset,\n\t\t\t\t  WM5100_GP1_FN_MASK | WM5100_GP1_DIR,\n\t\t\t\t  (1 << WM5100_GP1_FN_SHIFT) |\n\t\t\t\t  (1 << WM5100_GP1_DIR_SHIFT));\n}\n\nstatic const struct gpio_chip wm5100_template_chip = {\n\t.label\t\t\t= \"wm5100\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.direction_output\t= wm5100_gpio_direction_out,\n\t.set\t\t\t= wm5100_gpio_set,\n\t.direction_input\t= wm5100_gpio_direction_in,\n\t.get\t\t\t= wm5100_gpio_get,\n\t.can_sleep\t\t= 1,\n};\n\nstatic void wm5100_init_gpio(struct i2c_client *i2c)\n{\n\tstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\n\tint ret;\n\n\twm5100->gpio_chip = wm5100_template_chip;\n\twm5100->gpio_chip.ngpio = 6;\n\twm5100->gpio_chip.parent = &i2c->dev;\n\n\tif (wm5100->pdata.gpio_base)\n\t\twm5100->gpio_chip.base = wm5100->pdata.gpio_base;\n\telse\n\t\twm5100->gpio_chip.base = -1;\n\n\tret = gpiochip_add_data(&wm5100->gpio_chip, wm5100);\n\tif (ret != 0)\n\t\tdev_err(&i2c->dev, \"Failed to add GPIOs: %d\\n\", ret);\n}\n\nstatic void wm5100_free_gpio(struct i2c_client *i2c)\n{\n\tstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\n\n\tgpiochip_remove(&wm5100->gpio_chip);\n}\n#else\nstatic void wm5100_init_gpio(struct i2c_client *i2c)\n{\n}\n\nstatic void wm5100_free_gpio(struct i2c_client *i2c)\n{\n}\n#endif\n\nstatic int wm5100_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct i2c_client *i2c = to_i2c_client(component->dev);\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\tint ret, i;\n\n\twm5100->component = component;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100_dig_vu); i++)\n\t\tsnd_soc_component_update_bits(component, wm5100_dig_vu[i], WM5100_OUT_VU,\n\t\t\t\t    WM5100_OUT_VU);\n\n\t \n\tsnd_soc_component_write(component, WM5100_IRQ_DEBOUNCE_1, 0);\n\tsnd_soc_component_write(component, WM5100_IRQ_DEBOUNCE_2, 0);\n\n\t \n\n\tif (i2c->irq)\n\t\tsnd_soc_dapm_new_controls(dapm, wm5100_dapm_widgets_noirq,\n\t\t\t\t\t  ARRAY_SIZE(wm5100_dapm_widgets_noirq));\n\n\tif (wm5100->pdata.hp_pol) {\n\t\tret = gpio_request_one(wm5100->pdata.hp_pol,\n\t\t\t\t       GPIOF_OUT_INIT_HIGH, \"WM5100 HP_POL\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to request HP_POL %d: %d\\n\",\n\t\t\t\twm5100->pdata.hp_pol, ret);\n\t\t\tgoto err_gpio;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_gpio:\n\n\treturn ret;\n}\n\nstatic void wm5100_remove(struct snd_soc_component *component)\n{\n\tstruct wm5100_priv *wm5100 = snd_soc_component_get_drvdata(component);\n\n\tif (wm5100->pdata.hp_pol) {\n\t\tgpio_free(wm5100->pdata.hp_pol);\n\t}\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm5100 = {\n\t.probe\t\t\t= wm5100_probe,\n\t.remove\t\t\t= wm5100_remove,\n\t.set_sysclk\t\t= wm5100_set_sysclk,\n\t.set_pll\t\t= wm5100_set_fll,\n\t.seq_notifier\t\t= wm5100_seq_notifier,\n\t.controls\t\t= wm5100_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm5100_snd_controls),\n\t.dapm_widgets\t\t= wm5100_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm5100_dapm_widgets),\n\t.dapm_routes\t\t= wm5100_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm5100_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm5100_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\n\t.max_register = WM5100_MAX_REGISTER,\n\t.reg_defaults = wm5100_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm5100_reg_defaults),\n\t.volatile_reg = wm5100_volatile_register,\n\t.readable_reg = wm5100_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic const unsigned int wm5100_mic_ctrl_reg[] = {\n\tWM5100_IN1L_CONTROL,\n\tWM5100_IN2L_CONTROL,\n\tWM5100_IN3L_CONTROL,\n\tWM5100_IN4L_CONTROL,\n};\n\nstatic int wm5100_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm5100_pdata *pdata = dev_get_platdata(&i2c->dev);\n\tstruct wm5100_priv *wm5100;\n\tunsigned int reg;\n\tint ret, i, irq_flags;\n\n\twm5100 = devm_kzalloc(&i2c->dev, sizeof(struct wm5100_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm5100 == NULL)\n\t\treturn -ENOMEM;\n\n\twm5100->dev = &i2c->dev;\n\n\twm5100->regmap = devm_regmap_init_i2c(i2c, &wm5100_regmap);\n\tif (IS_ERR(wm5100->regmap)) {\n\t\tret = PTR_ERR(wm5100->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100->fll); i++)\n\t\tinit_completion(&wm5100->fll[i].lock);\n\n\tif (pdata)\n\t\twm5100->pdata = *pdata;\n\n\ti2c_set_clientdata(i2c, wm5100);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100->core_supplies); i++)\n\t\twm5100->core_supplies[i].supply = wm5100_core_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev,\n\t\t\t\t      ARRAY_SIZE(wm5100->core_supplies),\n\t\t\t\t      wm5100->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request core supplies: %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm5100->core_supplies),\n\t\t\t\t    wm5100->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable core supplies: %d\\n\",\n\t\t\tret);\n\t\tgoto err;\n\t}\n\n\tif (wm5100->pdata.ldo_ena) {\n\t\tret = gpio_request_one(wm5100->pdata.ldo_ena,\n\t\t\t\t       GPIOF_OUT_INIT_HIGH, \"WM5100 LDOENA\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to request LDOENA %d: %d\\n\",\n\t\t\t\twm5100->pdata.ldo_ena, ret);\n\t\t\tgoto err_enable;\n\t\t}\n\t\tmsleep(2);\n\t}\n\n\tif (wm5100->pdata.reset) {\n\t\tret = gpio_request_one(wm5100->pdata.reset,\n\t\t\t\t       GPIOF_OUT_INIT_HIGH, \"WM5100 /RESET\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to request /RESET %d: %d\\n\",\n\t\t\t\twm5100->pdata.reset, ret);\n\t\t\tgoto err_ldo;\n\t\t}\n\t}\n\n\tret = regmap_read(wm5100->regmap, WM5100_SOFTWARE_RESET, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read ID register: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\tswitch (reg) {\n\tcase 0x8997:\n\tcase 0x5100:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&i2c->dev, \"Device is not a WM5100, ID is %x\\n\", reg);\n\t\tret = -EINVAL;\n\t\tgoto err_reset;\n\t}\n\n\tret = regmap_read(wm5100->regmap, WM5100_DEVICE_REVISION, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read revision register\\n\");\n\t\tgoto err_reset;\n\t}\n\twm5100->rev = reg & WM5100_DEVICE_REVISION_MASK;\n\n\tdev_info(&i2c->dev, \"revision %c\\n\", wm5100->rev + 'A');\n\n\tret = wm5100_reset(wm5100);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset\\n\");\n\t\tgoto err_reset;\n\t}\n\n\tswitch (wm5100->rev) {\n\tcase 0:\n\t\tret = regmap_register_patch(wm5100->regmap,\n\t\t\t\t\t    wm5100_reva_patches,\n\t\t\t\t\t    ARRAY_SIZE(wm5100_reva_patches));\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to register patches: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_reset;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\n\twm5100_init_gpio(i2c);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100->pdata.gpio_defaults); i++) {\n\t\tif (!wm5100->pdata.gpio_defaults[i])\n\t\t\tcontinue;\n\n\t\tregmap_write(wm5100->regmap, WM5100_GPIO_CTRL_1 + i,\n\t\t\t     wm5100->pdata.gpio_defaults[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm5100->pdata.in_mode); i++) {\n\t\tregmap_update_bits(wm5100->regmap, wm5100_mic_ctrl_reg[i],\n\t\t\t\t   WM5100_IN1_MODE_MASK |\n\t\t\t\t   WM5100_IN1_DMIC_SUP_MASK,\n\t\t\t\t   (wm5100->pdata.in_mode[i] <<\n\t\t\t\t    WM5100_IN1_MODE_SHIFT) |\n\t\t\t\t   (wm5100->pdata.dmic_sup[i] <<\n\t\t\t\t    WM5100_IN1_DMIC_SUP_SHIFT));\n\t}\n\n\tif (i2c->irq) {\n\t\tif (wm5100->pdata.irq_flags)\n\t\t\tirq_flags = wm5100->pdata.irq_flags;\n\t\telse\n\t\t\tirq_flags = IRQF_TRIGGER_LOW;\n\n\t\tirq_flags |= IRQF_ONESHOT;\n\n\t\tif (irq_flags & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING))\n\t\t\tret = request_threaded_irq(i2c->irq, NULL,\n\t\t\t\t\t\t   wm5100_edge_irq, irq_flags,\n\t\t\t\t\t\t   \"wm5100\", wm5100);\n\t\telse\n\t\t\tret = request_threaded_irq(i2c->irq, NULL, wm5100_irq,\n\t\t\t\t\t\t   irq_flags, \"wm5100\",\n\t\t\t\t\t\t   wm5100);\n\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\t\ti2c->irq, ret);\n\t\t} else {\n\t\t\t \n\t\t\tregmap_update_bits(wm5100->regmap,\n\t\t\t\t\t   WM5100_INTERRUPT_STATUS_3_MASK,\n\t\t\t\t\t   WM5100_IM_SPK_SHUTDOWN_WARN_EINT |\n\t\t\t\t\t   WM5100_IM_SPK_SHUTDOWN_EINT |\n\t\t\t\t\t   WM5100_IM_ASRC2_LOCK_EINT |\n\t\t\t\t\t   WM5100_IM_ASRC1_LOCK_EINT |\n\t\t\t\t\t   WM5100_IM_FLL2_LOCK_EINT |\n\t\t\t\t\t   WM5100_IM_FLL1_LOCK_EINT |\n\t\t\t\t\t   WM5100_CLKGEN_ERR_EINT |\n\t\t\t\t\t   WM5100_CLKGEN_ERR_ASYNC_EINT, 0);\n\n\t\t\tregmap_update_bits(wm5100->regmap,\n\t\t\t\t\t   WM5100_INTERRUPT_STATUS_4_MASK,\n\t\t\t\t\t   WM5100_AIF3_ERR_EINT |\n\t\t\t\t\t   WM5100_AIF2_ERR_EINT |\n\t\t\t\t\t   WM5100_AIF1_ERR_EINT |\n\t\t\t\t\t   WM5100_CTRLIF_ERR_EINT |\n\t\t\t\t\t   WM5100_ISRC2_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_ISRC1_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_FX_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_AIF3_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_AIF2_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_AIF1_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_ASRC_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_DAC_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_ADC_UNDERCLOCKED_EINT |\n\t\t\t\t\t   WM5100_MIXER_UNDERCLOCKED_EINT, 0);\n\t\t}\n\t}\n\n\tpm_runtime_set_active(&i2c->dev);\n\tpm_runtime_enable(&i2c->dev);\n\tpm_request_idle(&i2c->dev);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_wm5100, wm5100_dai,\n\t\t\t\t     ARRAY_SIZE(wm5100_dai));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register WM5100: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\treturn ret;\n\nerr_reset:\n\tpm_runtime_disable(&i2c->dev);\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, wm5100);\n\twm5100_free_gpio(i2c);\n\tif (wm5100->pdata.reset) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.reset, 0);\n\t\tgpio_free(wm5100->pdata.reset);\n\t}\nerr_ldo:\n\tif (wm5100->pdata.ldo_ena) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\n\t\tgpio_free(wm5100->pdata.ldo_ena);\n\t}\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm5100->core_supplies),\n\t\t\t       wm5100->core_supplies);\nerr:\n\treturn ret;\n}\n\nstatic void wm5100_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct wm5100_priv *wm5100 = i2c_get_clientdata(i2c);\n\n\tpm_runtime_disable(&i2c->dev);\n\tif (i2c->irq)\n\t\tfree_irq(i2c->irq, wm5100);\n\twm5100_free_gpio(i2c);\n\tif (wm5100->pdata.reset) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.reset, 0);\n\t\tgpio_free(wm5100->pdata.reset);\n\t}\n\tif (wm5100->pdata.ldo_ena) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\n\t\tgpio_free(wm5100->pdata.ldo_ena);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int wm5100_runtime_suspend(struct device *dev)\n{\n\tstruct wm5100_priv *wm5100 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(wm5100->regmap, true);\n\tregcache_mark_dirty(wm5100->regmap);\n\tif (wm5100->pdata.ldo_ena)\n\t\tgpio_set_value_cansleep(wm5100->pdata.ldo_ena, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(wm5100->core_supplies),\n\t\t\t       wm5100->core_supplies);\n\n\treturn 0;\n}\n\nstatic int wm5100_runtime_resume(struct device *dev)\n{\n\tstruct wm5100_priv *wm5100 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm5100->core_supplies),\n\t\t\t\t    wm5100->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (wm5100->pdata.ldo_ena) {\n\t\tgpio_set_value_cansleep(wm5100->pdata.ldo_ena, 1);\n\t\tmsleep(2);\n\t}\n\n\tregcache_cache_only(wm5100->regmap, false);\n\tregcache_sync(wm5100->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops wm5100_pm = {\n\tSET_RUNTIME_PM_OPS(wm5100_runtime_suspend, wm5100_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct i2c_device_id wm5100_i2c_id[] = {\n\t{ \"wm5100\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm5100_i2c_id);\n\nstatic struct i2c_driver wm5100_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm5100\",\n\t\t.pm = &wm5100_pm,\n\t},\n\t.probe =    wm5100_i2c_probe,\n\t.remove =   wm5100_i2c_remove,\n\t.id_table = wm5100_i2c_id,\n};\n\nmodule_i2c_driver(wm5100_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM5100 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}