{
  "module_name": "wm8711.c",
  "hash_id": "08bed3b795eb51017f04c507170016363ed137208a0554a67cece8b1ff23737a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8711.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n\n#include \"wm8711.h\"\n\n \nstruct wm8711_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n};\n\n \nstatic const struct reg_default wm8711_reg_defaults[] = {\n\t{ 0, 0x0079 }, { 1, 0x0079 }, { 2, 0x000a }, { 3, 0x0008 },\n\t{ 4, 0x009f }, { 5, 0x000a }, { 6, 0x0000 }, { 7, 0x0000 },\n};\n\nstatic bool wm8711_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8711_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define wm8711_reset(c)\tsnd_soc_component_write(c, WM8711_RESET, 0)\n\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\n\nstatic const struct snd_kcontrol_new wm8711_snd_controls[] = {\n\nSOC_DOUBLE_R_TLV(\"Master Playback Volume\", WM8711_LOUT1V, WM8711_ROUT1V,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Master Playback ZC Switch\", WM8711_LOUT1V, WM8711_ROUT1V,\n\t7, 1, 0),\n\n};\n\n \nstatic const struct snd_kcontrol_new wm8711_output_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Bypass Switch\", WM8711_APANA, 3, 1, 0),\nSOC_DAPM_SINGLE(\"HiFi Playback Switch\", WM8711_APANA, 4, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8711_dapm_widgets[] = {\nSND_SOC_DAPM_MIXER(\"Output Mixer\", WM8711_PWR, 4, 1,\n\t&wm8711_output_mixer_controls[0],\n\tARRAY_SIZE(wm8711_output_mixer_controls)),\nSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", WM8711_PWR, 3, 1),\nSND_SOC_DAPM_OUTPUT(\"LOUT\"),\nSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT\"),\nSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8711_intercon[] = {\n\t \n\t{\"Output Mixer\", \"Line Bypass Switch\", \"Line Input\"},\n\t{\"Output Mixer\", \"HiFi Playback Switch\", \"DAC\"},\n\n\t \n\t{\"RHPOUT\", NULL, \"Output Mixer\"},\n\t{\"ROUT\", NULL, \"Output Mixer\"},\n\t{\"LHPOUT\", NULL, \"Output Mixer\"},\n\t{\"LOUT\", NULL, \"Output Mixer\"},\n};\n\nstruct _coeff_div {\n\tu32 mclk;\n\tu32 rate;\n\tu16 fs;\n\tu8 sr:4;\n\tu8 bosr:1;\n\tu8 usb:1;\n};\n\n \nstatic const struct _coeff_div coeff_div[] = {\n\t \n\t{12288000, 48000, 256, 0x0, 0x0, 0x0},\n\t{18432000, 48000, 384, 0x0, 0x1, 0x0},\n\t{12000000, 48000, 250, 0x0, 0x0, 0x1},\n\n\t \n\t{12288000, 32000, 384, 0x6, 0x0, 0x0},\n\t{18432000, 32000, 576, 0x6, 0x1, 0x0},\n\t{12000000, 32000, 375, 0x6, 0x0, 0x1},\n\n\t \n\t{12288000, 8000, 1536, 0x3, 0x0, 0x0},\n\t{18432000, 8000, 2304, 0x3, 0x1, 0x0},\n\t{11289600, 8000, 1408, 0xb, 0x0, 0x0},\n\t{16934400, 8000, 2112, 0xb, 0x1, 0x0},\n\t{12000000, 8000, 1500, 0x3, 0x0, 0x1},\n\n\t \n\t{12288000, 96000, 128, 0x7, 0x0, 0x0},\n\t{18432000, 96000, 192, 0x7, 0x1, 0x0},\n\t{12000000, 96000, 125, 0x7, 0x0, 0x1},\n\n\t \n\t{11289600, 44100, 256, 0x8, 0x0, 0x0},\n\t{16934400, 44100, 384, 0x8, 0x1, 0x0},\n\t{12000000, 44100, 272, 0x8, 0x1, 0x1},\n\n\t \n\t{11289600, 88200, 128, 0xf, 0x0, 0x0},\n\t{16934400, 88200, 192, 0xf, 0x1, 0x0},\n\t{12000000, 88200, 136, 0xf, 0x1, 0x1},\n};\n\nstatic inline int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int wm8711_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8711_priv *wm8711 =  snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8711_IFACE) & 0xfff3;\n\tint i = get_coeff(wm8711->sysclk, params_rate(params));\n\tu16 srate = (coeff_div[i].sr << 2) |\n\t\t(coeff_div[i].bosr << 1) | coeff_div[i].usb;\n\n\tsnd_soc_component_write(component, WM8711_SRATE, srate);\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x0008;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8711_IFACE, iface);\n\treturn 0;\n}\n\nstatic int wm8711_pcm_prepare(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\t \n\tsnd_soc_component_write(component, WM8711_ACTIVE, 0x0001);\n\n\treturn 0;\n}\n\nstatic void wm8711_shutdown(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\t \n\tif (!snd_soc_component_active(component)) {\n\t\tudelay(50);\n\t\tsnd_soc_component_write(component, WM8711_ACTIVE, 0x0);\n\t}\n}\n\nstatic int wm8711_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8711_APDIGI) & 0xfff7;\n\n\tif (mute)\n\t\tsnd_soc_component_write(component, WM8711_APDIGI, mute_reg | 0x8);\n\telse\n\t\tsnd_soc_component_write(component, WM8711_APDIGI, mute_reg);\n\n\treturn 0;\n}\n\nstatic int wm8711_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8711_priv *wm8711 =  snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase 11289600:\n\tcase 12000000:\n\tcase 12288000:\n\tcase 16934400:\n\tcase 18432000:\n\t\twm8711->sysclk = freq;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wm8711_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = snd_soc_component_read(component, WM8711_IFACE) & 0x000c;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tiface |= 0x0040;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0090;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8711_IFACE, iface);\n\treturn 0;\n}\n\nstatic int wm8711_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct wm8711_priv *wm8711 = snd_soc_component_get_drvdata(component);\n\tu16 reg = snd_soc_component_read(component, WM8711_PWR) & 0xff7f;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tsnd_soc_component_write(component, WM8711_PWR, reg);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tregcache_sync(wm8711->regmap);\n\n\t\tsnd_soc_component_write(component, WM8711_PWR, reg | 0x0040);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component, WM8711_ACTIVE, 0x0);\n\t\tsnd_soc_component_write(component, WM8711_PWR, 0xffff);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8711_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8711_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8711_ops = {\n\t.prepare = wm8711_pcm_prepare,\n\t.hw_params = wm8711_hw_params,\n\t.shutdown = wm8711_shutdown,\n\t.mute_stream = wm8711_mute,\n\t.set_sysclk = wm8711_set_dai_sysclk,\n\t.set_fmt = wm8711_set_dai_fmt,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8711_dai = {\n\t.name = \"wm8711-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8711_RATES,\n\t\t.formats = WM8711_FORMATS,\n\t},\n\t.ops = &wm8711_ops,\n};\n\nstatic int wm8711_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = wm8711_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8711_LOUT1V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8711_ROUT1V, 0x0100, 0x0100);\n\n\treturn ret;\n\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8711 = {\n\t.probe\t\t\t= wm8711_probe,\n\t.set_bias_level\t\t= wm8711_set_bias_level,\n\t.controls\t\t= wm8711_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8711_snd_controls),\n\t.dapm_widgets\t\t= wm8711_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8711_dapm_widgets),\n\t.dapm_routes\t\t= wm8711_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8711_intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8711_of_match[] = {\n\t{ .compatible = \"wlf,wm8711\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8711_of_match);\n\nstatic const struct regmap_config wm8711_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8711_RESET,\n\n\t.reg_defaults = wm8711_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8711_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8711_volatile,\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8711_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8711_priv *wm8711;\n\tint ret;\n\n\twm8711 = devm_kzalloc(&spi->dev, sizeof(struct wm8711_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8711 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8711->regmap = devm_regmap_init_spi(spi, &wm8711_regmap);\n\tif (IS_ERR(wm8711->regmap))\n\t\treturn PTR_ERR(wm8711->regmap);\n\n\tspi_set_drvdata(spi, wm8711);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_dev_wm8711, &wm8711_dai, 1);\n\n\treturn ret;\n}\n\nstatic struct spi_driver wm8711_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8711\",\n\t\t.of_match_table = wm8711_of_match,\n\t},\n\t.probe\t\t= wm8711_spi_probe,\n};\n#endif  \n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8711_i2c_probe(struct i2c_client *client)\n{\n\tstruct wm8711_priv *wm8711;\n\tint ret;\n\n\twm8711 = devm_kzalloc(&client->dev, sizeof(struct wm8711_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8711 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8711->regmap = devm_regmap_init_i2c(client, &wm8711_regmap);\n\tif (IS_ERR(wm8711->regmap))\n\t\treturn PTR_ERR(wm8711->regmap);\n\n\ti2c_set_clientdata(client, wm8711);\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t&soc_component_dev_wm8711, &wm8711_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8711_i2c_id[] = {\n\t{ \"wm8711\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8711_i2c_id);\n\nstatic struct i2c_driver wm8711_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8711\",\n\t\t.of_match_table = wm8711_of_match,\n\t},\n\t.probe = wm8711_i2c_probe,\n\t.id_table = wm8711_i2c_id,\n};\n#endif\n\nstatic int __init wm8711_modinit(void)\n{\n\tint ret;\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8711_i2c_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8711 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8711_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8711 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn 0;\n}\nmodule_init(wm8711_modinit);\n\nstatic void __exit wm8711_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8711_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8711_spi_driver);\n#endif\n}\nmodule_exit(wm8711_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8711 driver\");\nMODULE_AUTHOR(\"Mike Arthur\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}