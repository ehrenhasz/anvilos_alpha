{
  "module_name": "max98088.c",
  "hash_id": "559c1c50de0ff12e9c1ff10c3b1a2d60ec7ee65a61ce210be33c3a5cf832b8c3",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98088.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n#include <sound/max98088.h>\n#include \"max98088.h\"\n\nenum max98088_type {\n       MAX98088,\n       MAX98089,\n};\n\nstruct max98088_cdata {\n       unsigned int rate;\n       unsigned int fmt;\n       int eq_sel;\n};\n\nstruct max98088_priv {\n\tstruct regmap *regmap;\n\tenum max98088_type devtype;\n\tstruct max98088_pdata *pdata;\n\tstruct clk *mclk;\n\tunsigned char mclk_prescaler;\n\tunsigned int sysclk;\n\tstruct max98088_cdata dai[2];\n\tint eq_textcnt;\n\tconst char **eq_texts;\n\tstruct soc_enum eq_enum;\n\tu8 ina_state;\n\tu8 inb_state;\n\tunsigned int ex_mode;\n\tunsigned int digmic;\n\tunsigned int mic1pre;\n\tunsigned int mic2pre;\n\tunsigned int extmic_mode;\n};\n\nstatic const struct reg_default max98088_reg[] = {\n\t{  0xf, 0x00 },  \n\n\t{ 0x10, 0x00 },  \n\t{ 0x11, 0x00 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0x00 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0x00 },  \n\t{ 0x17, 0x00 },  \n\t{ 0x18, 0x00 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1a, 0x00 },  \n\t{ 0x1b, 0x00 },  \n\t{ 0x1c, 0x00 },  \n\t{ 0x1d, 0x00 },  \n\t{ 0x1e, 0x00 },  \n\t{ 0x1f, 0x00 },  \n\n\t{ 0x20, 0x00 },  \n\t{ 0x21, 0x00 },  \n\t{ 0x22, 0x00 },  \n\t{ 0x23, 0x00 },  \n\t{ 0x24, 0x00 },  \n\t{ 0x25, 0x00 },  \n\t{ 0x26, 0x00 },  \n\t{ 0x27, 0x00 },  \n\t{ 0x28, 0x00 },  \n\t{ 0x29, 0x00 },  \n\t{ 0x2a, 0x00 },  \n\t{ 0x2b, 0x00 },  \n\t{ 0x2c, 0x00 },  \n\t{ 0x2d, 0x00 },  \n\t{ 0x2e, 0x00 },  \n\t{ 0x2f, 0x00 },  \n\n\t{ 0x30, 0x00 },  \n\t{ 0x31, 0x00 },  \n\t{ 0x32, 0x00 },  \n\t{ 0x33, 0x00 },  \n\t{ 0x34, 0x00 },  \n\t{ 0x35, 0x00 },  \n\t{ 0x36, 0x00 },  \n\t{ 0x37, 0x00 },  \n\t{ 0x38, 0x00 },  \n\t{ 0x39, 0x00 },  \n\t{ 0x3a, 0x00 },  \n\t{ 0x3b, 0x00 },  \n\t{ 0x3c, 0x00 },  \n\t{ 0x3d, 0x00 },  \n\t{ 0x3e, 0x00 },  \n\t{ 0x3f, 0x00 },  \n\n\t{ 0x40, 0x00 },  \n\t{ 0x41, 0x00 },  \n\t{ 0x42, 0x00 },  \n\t{ 0x43, 0x00 },  \n\t{ 0x44, 0x00 },  \n\t{ 0x45, 0x00 },  \n\t{ 0x46, 0x00 },  \n\t{ 0x47, 0x00 },  \n        { 0x48, 0x00 },  \n\t{ 0x49, 0x00 },  \n\t{ 0x4a, 0x00 },  \n\t{ 0x4b, 0x00 },  \n\t{ 0x4c, 0x00 },  \n\t{ 0x4d, 0x00 },  \n\t{ 0x4e, 0xF0 },  \n\t{ 0x4f, 0x00 },  \n\n\t{ 0x50, 0x0F },  \n\t{ 0x51, 0x00 },  \n\t{ 0x52, 0x00 },  \n\t{ 0x53, 0x00 },  \n\t{ 0x54, 0x00 },  \n\t{ 0x55, 0x00 },  \n\t{ 0x56, 0x00 },  \n\t{ 0x57, 0x00 },  \n\t{ 0x58, 0x00 },  \n\t{ 0x59, 0x00 },  \n\t{ 0x5a, 0x00 },  \n\t{ 0x5b, 0x00 },  \n\t{ 0x5c, 0x00 },  \n\t{ 0x5d, 0x00 },  \n\t{ 0x5e, 0x00 },  \n\t{ 0x5f, 0x00 },  \n\n\t{ 0x60, 0x00 },  \n\t{ 0x61, 0x00 },  \n\t{ 0x62, 0x00 },  \n\t{ 0x63, 0x00 },  \n\t{ 0x64, 0x00 },  \n\t{ 0x65, 0x00 },  \n\t{ 0x66, 0x00 },  \n\t{ 0x67, 0x00 },  \n\t{ 0x68, 0x00 },  \n\t{ 0x69, 0x00 },  \n\t{ 0x6a, 0x00 },  \n\t{ 0x6b, 0x00 },  \n\t{ 0x6c, 0x00 },  \n\t{ 0x6d, 0x00 },  \n\t{ 0x6e, 0x00 },  \n\t{ 0x6f, 0x00 },  \n\n\t{ 0x70, 0x00 },  \n\t{ 0x71, 0x00 },  \n\t{ 0x72, 0x00 },  \n\t{ 0x73, 0x00 },  \n\t{ 0x74, 0x00 },  \n\t{ 0x75, 0x00 },  \n\t{ 0x76, 0x00 },  \n\t{ 0x77, 0x00 },  \n\t{ 0x78, 0x00 },  \n\t{ 0x79, 0x00 },  \n\t{ 0x7a, 0x00 },  \n\t{ 0x7b, 0x00 },  \n\t{ 0x7c, 0x00 },  \n\t{ 0x7d, 0x00 },  \n\t{ 0x7e, 0x00 },  \n\t{ 0x7f, 0x00 },  \n\n\t{ 0x80, 0x00 },  \n\t{ 0x81, 0x00 },  \n\t{ 0x82, 0x00 },  \n\t{ 0x83, 0x00 },  \n\t{ 0x84, 0x00 },  \n\t{ 0x85, 0x00 },  \n\t{ 0x86, 0x00 },  \n\t{ 0x87, 0x00 },  \n\t{ 0x88, 0x00 },  \n\t{ 0x89, 0x00 },  \n\t{ 0x8a, 0x00 },  \n\t{ 0x8b, 0x00 },  \n\t{ 0x8c, 0x00 },  \n\t{ 0x8d, 0x00 },  \n\t{ 0x8e, 0x00 },  \n\t{ 0x8f, 0x00 },  \n\n\t{ 0x90, 0x00 },  \n\t{ 0x91, 0x00 },  \n\t{ 0x92, 0x00 },  \n\t{ 0x93, 0x00 },  \n\t{ 0x94, 0x00 },  \n\t{ 0x95, 0x00 },  \n\t{ 0x96, 0x00 },  \n\t{ 0x97, 0x00 },  \n\t{ 0x98, 0x00 },  \n\t{ 0x99, 0x00 },  \n\t{ 0x9a, 0x00 },  \n        { 0x9b, 0x00 },  \n\t{ 0x9c, 0x00 },  \n\t{ 0x9d, 0x00 },  \n\t{ 0x9e, 0x00 },  \n\t{ 0x9f, 0x00 },  \n\n\t{ 0xa0, 0x00 },  \n\t{ 0xa1, 0x00 },  \n\t{ 0xa2, 0x00 },  \n\t{ 0xa3, 0x00 },  \n\t{ 0xa4, 0x00 },  \n\t{ 0xa5, 0x00 },  \n\t{ 0xa6, 0x00 },  \n\t{ 0xa7, 0x00 },  \n\t{ 0xa8, 0x00 },  \n\t{ 0xa9, 0x00 },  \n\t{ 0xaa, 0x00 },  \n\t{ 0xab, 0x00 },  \n\t{ 0xac, 0x00 },  \n\t{ 0xad, 0x00 },  \n\t{ 0xae, 0x00 },  \n\t{ 0xaf, 0x00 },  \n\n\t{ 0xb0, 0x00 },  \n\t{ 0xb1, 0x00 },  \n\t{ 0xb2, 0x00 },  \n\t{ 0xb3, 0x00 },  \n\t{ 0xb4, 0x00 },  \n\t{ 0xb5, 0x00 },  \n\t{ 0xb6, 0x00 },  \n\t{ 0xb7, 0x00 },  \n\t{ 0xb8 ,0x00 },  \n\t{ 0xb9, 0x00 },  \n\t{ 0xba, 0x00 },  \n\t{ 0xbb, 0x00 },  \n\t{ 0xbc, 0x00 },  \n\t{ 0xbd, 0x00 },  \n\t{ 0xbe, 0x00 },  \n        { 0xbf, 0x00 },  \n\n\t{ 0xc0, 0x00 },  \n\t{ 0xc1, 0x00 },  \n\t{ 0xc2, 0x00 },  \n\t{ 0xc3, 0x00 },  \n\t{ 0xc4, 0x00 },  \n\t{ 0xc5, 0x00 },  \n\t{ 0xc6, 0x00 },  \n\t{ 0xc7, 0x00 },  \n\t{ 0xc8, 0x00 },  \n\t{ 0xc9, 0x00 },  \n};\n\nstatic bool max98088_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98088_REG_00_IRQ_STATUS ... 0xC9:\n\tcase M98088_REG_FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98088_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98088_REG_03_BATTERY_VOLTAGE ... 0xC9:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98088_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98088_REG_00_IRQ_STATUS ... M98088_REG_03_BATTERY_VOLTAGE:\n\tcase M98088_REG_FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max98088_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.readable_reg = max98088_readable_register,\n\t.writeable_reg = max98088_writeable_register,\n\t.volatile_reg = max98088_volatile_register,\n\t.max_register = 0xff,\n\n\t.reg_defaults = max98088_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98088_reg),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\n \nstatic void m98088_eq_band(struct snd_soc_component *component, unsigned int dai,\n                   unsigned int band, u16 *coefs)\n{\n\tunsigned int eq_reg;\n\tunsigned int i;\n\n\tif (WARN_ON(band > 4) ||\n\t    WARN_ON(dai > 1))\n\t\treturn;\n\n\t \n\teq_reg = dai ? M98088_REG_84_DAI2_EQ_BASE : M98088_REG_52_DAI1_EQ_BASE;\n\n\t \n\teq_reg += band * (M98088_COEFS_PER_BAND << 1);\n\n\t \n\tfor (i = 0; i < M98088_COEFS_PER_BAND; i++) {\n\t\tsnd_soc_component_write(component, eq_reg++, M98088_BYTE1(coefs[i]));\n\t\tsnd_soc_component_write(component, eq_reg++, M98088_BYTE0(coefs[i]));\n\t}\n}\n\n \nstatic const char *max98088_exmode_texts[] = {\n       \"Off\", \"100Hz\", \"400Hz\", \"600Hz\", \"800Hz\", \"1000Hz\", \"200-400Hz\",\n       \"400-600Hz\", \"400-800Hz\",\n};\n\nstatic const unsigned int max98088_exmode_values[] = {\n       0x00, 0x43, 0x10, 0x20, 0x30, 0x40, 0x11, 0x22, 0x32\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(max98088_exmode_enum,\n\t\t\t\t  M98088_REG_41_SPKDHP, 0, 127,\n\t\t\t\t  max98088_exmode_texts,\n\t\t\t\t  max98088_exmode_values);\n\nstatic const char *max98088_ex_thresh[] = {  \n       \"0.6\", \"1.2\", \"1.8\", \"2.4\", \"3.0\", \"3.6\", \"4.2\", \"4.8\"};\nstatic SOC_ENUM_SINGLE_DECL(max98088_ex_thresh_enum,\n\t\t\t    M98088_REG_42_SPKDHP_THRESH, 0,\n\t\t\t    max98088_ex_thresh);\n\nstatic const char *max98088_fltr_mode[] = {\"Voice\", \"Music\" };\nstatic SOC_ENUM_SINGLE_DECL(max98088_filter_mode_enum,\n\t\t\t    M98088_REG_18_DAI1_FILTERS, 7,\n\t\t\t    max98088_fltr_mode);\n\nstatic const char *max98088_extmic_text[] = { \"None\", \"MIC1\", \"MIC2\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98088_extmic_enum,\n\t\t\t    M98088_REG_48_CFG_MIC, 0,\n\t\t\t    max98088_extmic_text);\n\nstatic const struct snd_kcontrol_new max98088_extmic_mux =\n       SOC_DAPM_ENUM(\"External MIC Mux\", max98088_extmic_enum);\n\nstatic const char *max98088_dai1_fltr[] = {\n       \"Off\", \"fc=258/fs=16k\", \"fc=500/fs=16k\",\n       \"fc=258/fs=8k\", \"fc=500/fs=8k\", \"fc=200\"};\nstatic SOC_ENUM_SINGLE_DECL(max98088_dai1_dac_filter_enum,\n\t\t\t    M98088_REG_18_DAI1_FILTERS, 0,\n\t\t\t    max98088_dai1_fltr);\nstatic SOC_ENUM_SINGLE_DECL(max98088_dai1_adc_filter_enum,\n\t\t\t    M98088_REG_18_DAI1_FILTERS, 4,\n\t\t\t    max98088_dai1_fltr);\n\nstatic int max98088_mic1pre_set(struct snd_kcontrol *kcontrol,\n                               struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       unsigned int sel = ucontrol->value.integer.value[0];\n\n       max98088->mic1pre = sel;\n       snd_soc_component_update_bits(component, M98088_REG_35_LVL_MIC1, M98088_MICPRE_MASK,\n               (1+sel)<<M98088_MICPRE_SHIFT);\n\n       return 0;\n}\n\nstatic int max98088_mic1pre_get(struct snd_kcontrol *kcontrol,\n                               struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n       ucontrol->value.integer.value[0] = max98088->mic1pre;\n       return 0;\n}\n\nstatic int max98088_mic2pre_set(struct snd_kcontrol *kcontrol,\n                               struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       unsigned int sel = ucontrol->value.integer.value[0];\n\n       max98088->mic2pre = sel;\n       snd_soc_component_update_bits(component, M98088_REG_36_LVL_MIC2, M98088_MICPRE_MASK,\n               (1+sel)<<M98088_MICPRE_SHIFT);\n\n       return 0;\n}\n\nstatic int max98088_mic2pre_get(struct snd_kcontrol *kcontrol,\n                               struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n       ucontrol->value.integer.value[0] = max98088->mic2pre;\n       return 0;\n}\n\nstatic const DECLARE_TLV_DB_RANGE(max98088_micboost_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98088_hp_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6700, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-4000, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1700, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(-400, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(150, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98088_spk_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6200, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-3500, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(100, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(650, 50, 0)\n);\n\nstatic const struct snd_kcontrol_new max98088_snd_controls[] = {\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", M98088_REG_39_LVL_HP_L,\n\t\t\t M98088_REG_3A_LVL_HP_R, 0, 31, 0, max98088_hp_tlv),\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\", M98088_REG_3D_LVL_SPK_L,\n\t\t\t M98088_REG_3E_LVL_SPK_R, 0, 31, 0, max98088_spk_tlv),\n\tSOC_DOUBLE_R_TLV(\"Receiver Volume\", M98088_REG_3B_LVL_REC_L,\n\t\t\t M98088_REG_3C_LVL_REC_R, 0, 31, 0, max98088_spk_tlv),\n\n       SOC_DOUBLE_R(\"Headphone Switch\", M98088_REG_39_LVL_HP_L,\n               M98088_REG_3A_LVL_HP_R, 7, 1, 1),\n       SOC_DOUBLE_R(\"Speaker Switch\", M98088_REG_3D_LVL_SPK_L,\n               M98088_REG_3E_LVL_SPK_R, 7, 1, 1),\n       SOC_DOUBLE_R(\"Receiver Switch\", M98088_REG_3B_LVL_REC_L,\n               M98088_REG_3C_LVL_REC_R, 7, 1, 1),\n\n       SOC_SINGLE(\"MIC1 Volume\", M98088_REG_35_LVL_MIC1, 0, 31, 1),\n       SOC_SINGLE(\"MIC2 Volume\", M98088_REG_36_LVL_MIC2, 0, 31, 1),\n\n       SOC_SINGLE_EXT_TLV(\"MIC1 Boost Volume\",\n                       M98088_REG_35_LVL_MIC1, 5, 2, 0,\n                       max98088_mic1pre_get, max98088_mic1pre_set,\n                       max98088_micboost_tlv),\n       SOC_SINGLE_EXT_TLV(\"MIC2 Boost Volume\",\n                       M98088_REG_36_LVL_MIC2, 5, 2, 0,\n                       max98088_mic2pre_get, max98088_mic2pre_set,\n                       max98088_micboost_tlv),\n\n        SOC_SINGLE(\"Noise Gate Threshold\", M98088_REG_40_MICAGC_THRESH,\n               4, 15, 0),\n\n       SOC_SINGLE(\"INA Volume\", M98088_REG_37_LVL_INA, 0, 7, 1),\n       SOC_SINGLE(\"INB Volume\", M98088_REG_38_LVL_INB, 0, 7, 1),\n\n       SOC_SINGLE(\"ADCL Volume\", M98088_REG_33_LVL_ADC_L, 0, 15, 0),\n       SOC_SINGLE(\"ADCR Volume\", M98088_REG_34_LVL_ADC_R, 0, 15, 0),\n\n       SOC_SINGLE(\"ADCL Boost Volume\", M98088_REG_33_LVL_ADC_L, 4, 3, 0),\n       SOC_SINGLE(\"ADCR Boost Volume\", M98088_REG_34_LVL_ADC_R, 4, 3, 0),\n\n       SOC_SINGLE(\"EQ1 Switch\", M98088_REG_49_CFG_LEVEL, 0, 1, 0),\n       SOC_SINGLE(\"EQ2 Switch\", M98088_REG_49_CFG_LEVEL, 1, 1, 0),\n\n       SOC_ENUM(\"EX Limiter Mode\", max98088_exmode_enum),\n       SOC_ENUM(\"EX Limiter Threshold\", max98088_ex_thresh_enum),\n\n       SOC_ENUM(\"DAI1 Filter Mode\", max98088_filter_mode_enum),\n       SOC_ENUM(\"DAI1 DAC Filter\", max98088_dai1_dac_filter_enum),\n       SOC_ENUM(\"DAI1 ADC Filter\", max98088_dai1_adc_filter_enum),\n       SOC_SINGLE(\"DAI2 DC Block Switch\", M98088_REG_20_DAI2_FILTERS,\n               0, 1, 0),\n\n       SOC_SINGLE(\"ALC Switch\", M98088_REG_43_SPKALC_COMP, 7, 1, 0),\n       SOC_SINGLE(\"ALC Threshold\", M98088_REG_43_SPKALC_COMP, 0, 7, 0),\n       SOC_SINGLE(\"ALC Multiband\", M98088_REG_43_SPKALC_COMP, 3, 1, 0),\n       SOC_SINGLE(\"ALC Release Time\", M98088_REG_43_SPKALC_COMP, 4, 7, 0),\n\n       SOC_SINGLE(\"PWR Limiter Threshold\", M98088_REG_44_PWRLMT_CFG,\n               4, 15, 0),\n       SOC_SINGLE(\"PWR Limiter Weight\", M98088_REG_44_PWRLMT_CFG, 0, 7, 0),\n       SOC_SINGLE(\"PWR Limiter Time1\", M98088_REG_45_PWRLMT_TIME, 0, 15, 0),\n       SOC_SINGLE(\"PWR Limiter Time2\", M98088_REG_45_PWRLMT_TIME, 4, 15, 0),\n\n       SOC_SINGLE(\"THD Limiter Threshold\", M98088_REG_46_THDLMT_CFG, 4, 15, 0),\n       SOC_SINGLE(\"THD Limiter Time\", M98088_REG_46_THDLMT_CFG, 0, 7, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_left_speaker_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_2B_MIX_SPK_LEFT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_right_speaker_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_2C_MIX_SPK_RIGHT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_left_hp_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_25_MIX_HP_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_25_MIX_HP_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_25_MIX_HP_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_25_MIX_HP_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_25_MIX_HP_LEFT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_25_MIX_HP_LEFT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_25_MIX_HP_LEFT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_25_MIX_HP_LEFT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_25_MIX_HP_LEFT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_25_MIX_HP_LEFT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_right_hp_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_26_MIX_HP_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_26_MIX_HP_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_26_MIX_HP_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_26_MIX_HP_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_26_MIX_HP_RIGHT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_26_MIX_HP_RIGHT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_26_MIX_HP_RIGHT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_26_MIX_HP_RIGHT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_26_MIX_HP_RIGHT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_26_MIX_HP_RIGHT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_left_rec_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_28_MIX_REC_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_28_MIX_REC_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_28_MIX_REC_LEFT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_28_MIX_REC_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_28_MIX_REC_LEFT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_28_MIX_REC_LEFT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_28_MIX_REC_LEFT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_28_MIX_REC_LEFT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_28_MIX_REC_LEFT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_28_MIX_REC_LEFT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_right_rec_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98088_REG_29_MIX_REC_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98088_REG_29_MIX_REC_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"Left DAC2 Switch\", M98088_REG_29_MIX_REC_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"Right DAC2 Switch\", M98088_REG_29_MIX_REC_RIGHT, 0, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_29_MIX_REC_RIGHT, 5, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_29_MIX_REC_RIGHT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_29_MIX_REC_RIGHT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_29_MIX_REC_RIGHT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_29_MIX_REC_RIGHT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_29_MIX_REC_RIGHT, 4, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_left_ADC_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_23_MIX_ADC_LEFT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_23_MIX_ADC_LEFT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_23_MIX_ADC_LEFT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_23_MIX_ADC_LEFT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_23_MIX_ADC_LEFT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_23_MIX_ADC_LEFT, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98088_right_ADC_mixer_controls[] = {\n       SOC_DAPM_SINGLE(\"MIC1 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 7, 1, 0),\n       SOC_DAPM_SINGLE(\"MIC2 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 6, 1, 0),\n       SOC_DAPM_SINGLE(\"INA1 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 3, 1, 0),\n       SOC_DAPM_SINGLE(\"INA2 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 2, 1, 0),\n       SOC_DAPM_SINGLE(\"INB1 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 1, 1, 0),\n       SOC_DAPM_SINGLE(\"INB2 Switch\", M98088_REG_24_MIX_ADC_RIGHT, 0, 1, 0),\n};\n\nstatic int max98088_mic_event(struct snd_soc_dapm_widget *w,\n                            struct snd_kcontrol *kcontrol, int event)\n{\n       struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n       switch (event) {\n       case SND_SOC_DAPM_POST_PMU:\n               if (w->reg == M98088_REG_35_LVL_MIC1) {\n                       snd_soc_component_update_bits(component, w->reg, M98088_MICPRE_MASK,\n                               (1+max98088->mic1pre)<<M98088_MICPRE_SHIFT);\n               } else {\n                       snd_soc_component_update_bits(component, w->reg, M98088_MICPRE_MASK,\n                               (1+max98088->mic2pre)<<M98088_MICPRE_SHIFT);\n               }\n               break;\n       case SND_SOC_DAPM_POST_PMD:\n               snd_soc_component_update_bits(component, w->reg, M98088_MICPRE_MASK, 0);\n               break;\n       default:\n               return -EINVAL;\n       }\n\n       return 0;\n}\n\n \nstatic int max98088_line_pga(struct snd_soc_dapm_widget *w,\n                            int event, int line, u8 channel)\n{\n       struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       u8 *state;\n\n\tif (WARN_ON(!(channel == 1 || channel == 2)))\n\t\treturn -EINVAL;\n\n       switch (line) {\n       case LINE_INA:\n               state = &max98088->ina_state;\n               break;\n       case LINE_INB:\n               state = &max98088->inb_state;\n               break;\n       default:\n               return -EINVAL;\n       }\n\n       switch (event) {\n       case SND_SOC_DAPM_POST_PMU:\n               *state |= channel;\n               snd_soc_component_update_bits(component, w->reg,\n                       (1 << w->shift), (1 << w->shift));\n               break;\n       case SND_SOC_DAPM_POST_PMD:\n               *state &= ~channel;\n               if (*state == 0) {\n                       snd_soc_component_update_bits(component, w->reg,\n                               (1 << w->shift), 0);\n               }\n               break;\n       default:\n               return -EINVAL;\n       }\n\n       return 0;\n}\n\nstatic int max98088_pga_ina1_event(struct snd_soc_dapm_widget *w,\n                                  struct snd_kcontrol *k, int event)\n{\n       return max98088_line_pga(w, event, LINE_INA, 1);\n}\n\nstatic int max98088_pga_ina2_event(struct snd_soc_dapm_widget *w,\n                                  struct snd_kcontrol *k, int event)\n{\n       return max98088_line_pga(w, event, LINE_INA, 2);\n}\n\nstatic int max98088_pga_inb1_event(struct snd_soc_dapm_widget *w,\n                                  struct snd_kcontrol *k, int event)\n{\n       return max98088_line_pga(w, event, LINE_INB, 1);\n}\n\nstatic int max98088_pga_inb2_event(struct snd_soc_dapm_widget *w,\n                                  struct snd_kcontrol *k, int event)\n{\n       return max98088_line_pga(w, event, LINE_INB, 2);\n}\n\nstatic const struct snd_soc_dapm_widget max98088_dapm_widgets[] = {\n\n       SND_SOC_DAPM_ADC(\"ADCL\", \"HiFi Capture\", M98088_REG_4C_PWR_EN_IN, 1, 0),\n       SND_SOC_DAPM_ADC(\"ADCR\", \"HiFi Capture\", M98088_REG_4C_PWR_EN_IN, 0, 0),\n\n       SND_SOC_DAPM_DAC(\"DACL1\", \"HiFi Playback\",\n               M98088_REG_4D_PWR_EN_OUT, 1, 0),\n       SND_SOC_DAPM_DAC(\"DACR1\", \"HiFi Playback\",\n               M98088_REG_4D_PWR_EN_OUT, 0, 0),\n       SND_SOC_DAPM_DAC(\"DACL2\", \"Aux Playback\",\n               M98088_REG_4D_PWR_EN_OUT, 1, 0),\n       SND_SOC_DAPM_DAC(\"DACR2\", \"Aux Playback\",\n               M98088_REG_4D_PWR_EN_OUT, 0, 0),\n\n       SND_SOC_DAPM_PGA(\"HP Left Out\", M98088_REG_4D_PWR_EN_OUT,\n               7, 0, NULL, 0),\n       SND_SOC_DAPM_PGA(\"HP Right Out\", M98088_REG_4D_PWR_EN_OUT,\n               6, 0, NULL, 0),\n\n       SND_SOC_DAPM_PGA(\"SPK Left Out\", M98088_REG_4D_PWR_EN_OUT,\n               5, 0, NULL, 0),\n       SND_SOC_DAPM_PGA(\"SPK Right Out\", M98088_REG_4D_PWR_EN_OUT,\n               4, 0, NULL, 0),\n\n       SND_SOC_DAPM_PGA(\"REC Left Out\", M98088_REG_4D_PWR_EN_OUT,\n               3, 0, NULL, 0),\n       SND_SOC_DAPM_PGA(\"REC Right Out\", M98088_REG_4D_PWR_EN_OUT,\n               2, 0, NULL, 0),\n\n       SND_SOC_DAPM_MUX(\"External MIC\", SND_SOC_NOPM, 0, 0,\n               &max98088_extmic_mux),\n\n       SND_SOC_DAPM_MIXER(\"Left HP Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_left_hp_mixer_controls[0],\n               ARRAY_SIZE(max98088_left_hp_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Right HP Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_right_hp_mixer_controls[0],\n               ARRAY_SIZE(max98088_right_hp_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Left SPK Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_left_speaker_mixer_controls[0],\n               ARRAY_SIZE(max98088_left_speaker_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Right SPK Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_right_speaker_mixer_controls[0],\n               ARRAY_SIZE(max98088_right_speaker_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Left REC Mixer\", SND_SOC_NOPM, 0, 0,\n         &max98088_left_rec_mixer_controls[0],\n               ARRAY_SIZE(max98088_left_rec_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Right REC Mixer\", SND_SOC_NOPM, 0, 0,\n         &max98088_right_rec_mixer_controls[0],\n               ARRAY_SIZE(max98088_right_rec_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Left ADC Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_left_ADC_mixer_controls[0],\n               ARRAY_SIZE(max98088_left_ADC_mixer_controls)),\n\n       SND_SOC_DAPM_MIXER(\"Right ADC Mixer\", SND_SOC_NOPM, 0, 0,\n               &max98088_right_ADC_mixer_controls[0],\n               ARRAY_SIZE(max98088_right_ADC_mixer_controls)),\n\n       SND_SOC_DAPM_PGA_E(\"MIC1 Input\", M98088_REG_35_LVL_MIC1,\n               5, 0, NULL, 0, max98088_mic_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_PGA_E(\"MIC2 Input\", M98088_REG_36_LVL_MIC2,\n               5, 0, NULL, 0, max98088_mic_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_PGA_E(\"INA1 Input\", M98088_REG_4C_PWR_EN_IN,\n               7, 0, NULL, 0, max98088_pga_ina1_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_PGA_E(\"INA2 Input\", M98088_REG_4C_PWR_EN_IN,\n               7, 0, NULL, 0, max98088_pga_ina2_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_PGA_E(\"INB1 Input\", M98088_REG_4C_PWR_EN_IN,\n               6, 0, NULL, 0, max98088_pga_inb1_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_PGA_E(\"INB2 Input\", M98088_REG_4C_PWR_EN_IN,\n               6, 0, NULL, 0, max98088_pga_inb2_event,\n               SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n       SND_SOC_DAPM_MICBIAS(\"MICBIAS\", M98088_REG_4C_PWR_EN_IN, 3, 0),\n\n       SND_SOC_DAPM_OUTPUT(\"HPL\"),\n       SND_SOC_DAPM_OUTPUT(\"HPR\"),\n       SND_SOC_DAPM_OUTPUT(\"SPKL\"),\n       SND_SOC_DAPM_OUTPUT(\"SPKR\"),\n       SND_SOC_DAPM_OUTPUT(\"RECL\"),\n       SND_SOC_DAPM_OUTPUT(\"RECR\"),\n\n       SND_SOC_DAPM_INPUT(\"MIC1\"),\n       SND_SOC_DAPM_INPUT(\"MIC2\"),\n       SND_SOC_DAPM_INPUT(\"INA1\"),\n       SND_SOC_DAPM_INPUT(\"INA2\"),\n       SND_SOC_DAPM_INPUT(\"INB1\"),\n       SND_SOC_DAPM_INPUT(\"INB2\"),\n};\n\nstatic const struct snd_soc_dapm_route max98088_audio_map[] = {\n        \n       {\"Left HP Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Left HP Mixer\", \"Left DAC2 Switch\", \"DACL2\"},\n       {\"Left HP Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Left HP Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Left HP Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Left HP Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Left HP Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Left HP Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Left HP Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Left HP Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Right HP Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Right HP Mixer\", \"Left DAC2 Switch\", \"DACL2\"  },\n       {\"Right HP Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Right HP Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Right HP Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Right HP Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Right HP Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Right HP Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Right HP Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Right HP Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Left SPK Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Left SPK Mixer\", \"Left DAC2 Switch\", \"DACL2\"},\n       {\"Left SPK Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Left SPK Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Left SPK Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Left SPK Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Left SPK Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Left SPK Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Left SPK Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Left SPK Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Right SPK Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Right SPK Mixer\", \"Left DAC2 Switch\", \"DACL2\"},\n       {\"Right SPK Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Right SPK Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Right SPK Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Right SPK Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Right SPK Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Right SPK Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Right SPK Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Right SPK Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Left REC Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Left REC Mixer\", \"Left DAC2 Switch\", \"DACL2\"},\n       {\"Left REC Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Left REC Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Left REC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Left REC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Left REC Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Left REC Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Left REC Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Left REC Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Right REC Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n       {\"Right REC Mixer\", \"Left DAC2 Switch\", \"DACL2\"},\n       {\"Right REC Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n       {\"Right REC Mixer\", \"Right DAC2 Switch\", \"DACR2\"},\n       {\"Right REC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Right REC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Right REC Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Right REC Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Right REC Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Right REC Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n       {\"HP Left Out\", NULL, \"Left HP Mixer\"},\n       {\"HP Right Out\", NULL, \"Right HP Mixer\"},\n       {\"SPK Left Out\", NULL, \"Left SPK Mixer\"},\n       {\"SPK Right Out\", NULL, \"Right SPK Mixer\"},\n       {\"REC Left Out\", NULL, \"Left REC Mixer\"},\n       {\"REC Right Out\", NULL, \"Right REC Mixer\"},\n\n       {\"HPL\", NULL, \"HP Left Out\"},\n       {\"HPR\", NULL, \"HP Right Out\"},\n       {\"SPKL\", NULL, \"SPK Left Out\"},\n       {\"SPKR\", NULL, \"SPK Right Out\"},\n       {\"RECL\", NULL, \"REC Left Out\"},\n       {\"RECR\", NULL, \"REC Right Out\"},\n\n        \n       {\"Left ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Left ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Left ADC Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Left ADC Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Left ADC Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Left ADC Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"Right ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n       {\"Right ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n       {\"Right ADC Mixer\", \"INA1 Switch\", \"INA1 Input\"},\n       {\"Right ADC Mixer\", \"INA2 Switch\", \"INA2 Input\"},\n       {\"Right ADC Mixer\", \"INB1 Switch\", \"INB1 Input\"},\n       {\"Right ADC Mixer\", \"INB2 Switch\", \"INB2 Input\"},\n\n        \n       {\"ADCL\", NULL, \"Left ADC Mixer\"},\n       {\"ADCR\", NULL, \"Right ADC Mixer\"},\n       {\"INA1 Input\", NULL, \"INA1\"},\n       {\"INA2 Input\", NULL, \"INA2\"},\n       {\"INB1 Input\", NULL, \"INB1\"},\n       {\"INB2 Input\", NULL, \"INB2\"},\n       {\"MIC1 Input\", NULL, \"MIC1\"},\n       {\"MIC2 Input\", NULL, \"MIC2\"},\n};\n\n \nstatic const struct {\n       u32 rate;\n       u8  sr;\n} rate_table[] = {\n       {8000,  0x10},\n       {11025, 0x20},\n       {16000, 0x30},\n       {22050, 0x40},\n       {24000, 0x50},\n       {32000, 0x60},\n       {44100, 0x70},\n       {48000, 0x80},\n       {88200, 0x90},\n       {96000, 0xA0},\n};\n\nstatic inline int rate_value(int rate, u8 *value)\n{\n       int i;\n\n       for (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n               if (rate_table[i].rate >= rate) {\n                       *value = rate_table[i].sr;\n                       return 0;\n               }\n       }\n       *value = rate_table[0].sr;\n       return -EINVAL;\n}\n\nstatic int max98088_dai1_hw_params(struct snd_pcm_substream *substream,\n                                  struct snd_pcm_hw_params *params,\n                                  struct snd_soc_dai *dai)\n{\n       struct snd_soc_component *component = dai->component;\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_cdata *cdata;\n       unsigned long long ni;\n       unsigned int rate;\n       u8 regval;\n\n       cdata = &max98088->dai[0];\n\n       rate = params_rate(params);\n\n       switch (params_width(params)) {\n       case 16:\n               snd_soc_component_update_bits(component, M98088_REG_14_DAI1_FORMAT,\n                       M98088_DAI_WS, 0);\n               break;\n       case 24:\n               snd_soc_component_update_bits(component, M98088_REG_14_DAI1_FORMAT,\n                       M98088_DAI_WS, M98088_DAI_WS);\n               break;\n       default:\n               return -EINVAL;\n       }\n\n       snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS, M98088_SHDNRUN, 0);\n\n       if (rate_value(rate, &regval))\n               return -EINVAL;\n\n       snd_soc_component_update_bits(component, M98088_REG_11_DAI1_CLKMODE,\n               M98088_CLKMODE_MASK, regval);\n       cdata->rate = rate;\n\n        \n       if (snd_soc_component_read(component, M98088_REG_14_DAI1_FORMAT)\n               & M98088_DAI_MAS) {\n               unsigned long pclk;\n\n               if (max98088->sysclk == 0) {\n                       dev_err(component->dev, \"Invalid system clock frequency\\n\");\n                       return -EINVAL;\n               }\n               ni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\n                               * (unsigned long long int)rate;\n               pclk = DIV_ROUND_CLOSEST(max98088->sysclk, max98088->mclk_prescaler);\n               ni = DIV_ROUND_CLOSEST_ULL(ni, pclk);\n               snd_soc_component_write(component, M98088_REG_12_DAI1_CLKCFG_HI,\n                       (ni >> 8) & 0x7F);\n               snd_soc_component_write(component, M98088_REG_13_DAI1_CLKCFG_LO,\n                       ni & 0xFF);\n       }\n\n        \n       if (rate < 50000)\n               snd_soc_component_update_bits(component, M98088_REG_18_DAI1_FILTERS,\n                       M98088_DAI_DHF, 0);\n       else\n               snd_soc_component_update_bits(component, M98088_REG_18_DAI1_FILTERS,\n                       M98088_DAI_DHF, M98088_DAI_DHF);\n\n       snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS, M98088_SHDNRUN,\n               M98088_SHDNRUN);\n\n       return 0;\n}\n\nstatic int max98088_dai2_hw_params(struct snd_pcm_substream *substream,\n                                  struct snd_pcm_hw_params *params,\n                                  struct snd_soc_dai *dai)\n{\n       struct snd_soc_component *component = dai->component;\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_cdata *cdata;\n       unsigned long long ni;\n       unsigned int rate;\n       u8 regval;\n\n       cdata = &max98088->dai[1];\n\n       rate = params_rate(params);\n\n       switch (params_width(params)) {\n       case 16:\n               snd_soc_component_update_bits(component, M98088_REG_1C_DAI2_FORMAT,\n                       M98088_DAI_WS, 0);\n               break;\n       case 24:\n               snd_soc_component_update_bits(component, M98088_REG_1C_DAI2_FORMAT,\n                       M98088_DAI_WS, M98088_DAI_WS);\n               break;\n       default:\n               return -EINVAL;\n       }\n\n       snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS, M98088_SHDNRUN, 0);\n\n       if (rate_value(rate, &regval))\n               return -EINVAL;\n\n       snd_soc_component_update_bits(component, M98088_REG_19_DAI2_CLKMODE,\n               M98088_CLKMODE_MASK, regval);\n       cdata->rate = rate;\n\n        \n       if (snd_soc_component_read(component, M98088_REG_1C_DAI2_FORMAT)\n               & M98088_DAI_MAS) {\n               unsigned long pclk;\n\n               if (max98088->sysclk == 0) {\n                       dev_err(component->dev, \"Invalid system clock frequency\\n\");\n                       return -EINVAL;\n               }\n               ni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\n                               * (unsigned long long int)rate;\n               pclk = DIV_ROUND_CLOSEST(max98088->sysclk, max98088->mclk_prescaler);\n               ni = DIV_ROUND_CLOSEST_ULL(ni, pclk);\n               snd_soc_component_write(component, M98088_REG_1A_DAI2_CLKCFG_HI,\n                       (ni >> 8) & 0x7F);\n               snd_soc_component_write(component, M98088_REG_1B_DAI2_CLKCFG_LO,\n                       ni & 0xFF);\n       }\n\n        \n       if (rate < 50000)\n               snd_soc_component_update_bits(component, M98088_REG_20_DAI2_FILTERS,\n                       M98088_DAI_DHF, 0);\n       else\n               snd_soc_component_update_bits(component, M98088_REG_20_DAI2_FILTERS,\n                       M98088_DAI_DHF, M98088_DAI_DHF);\n\n       snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS, M98088_SHDNRUN,\n               M98088_SHDNRUN);\n\n       return 0;\n}\n\nstatic int max98088_dai_set_sysclk(struct snd_soc_dai *dai,\n                                  int clk_id, unsigned int freq, int dir)\n{\n       struct snd_soc_component *component = dai->component;\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n        \n       if (freq == max98088->sysclk)\n               return 0;\n\n\tif (!IS_ERR(max98088->mclk)) {\n\t\tfreq = clk_round_rate(max98088->mclk, freq);\n\t\tclk_set_rate(max98088->mclk, freq);\n\t}\n\n        \n       if ((freq >= 10000000) && (freq < 20000000)) {\n               snd_soc_component_write(component, M98088_REG_10_SYS_CLK, 0x10);\n               max98088->mclk_prescaler = 1;\n       } else if ((freq >= 20000000) && (freq < 30000000)) {\n               snd_soc_component_write(component, M98088_REG_10_SYS_CLK, 0x20);\n               max98088->mclk_prescaler = 2;\n       } else {\n               dev_err(component->dev, \"Invalid master clock frequency\\n\");\n               return -EINVAL;\n       }\n\n       if (snd_soc_component_read(component, M98088_REG_51_PWR_SYS)  & M98088_SHDNRUN) {\n               snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS,\n                       M98088_SHDNRUN, 0);\n               snd_soc_component_update_bits(component, M98088_REG_51_PWR_SYS,\n                       M98088_SHDNRUN, M98088_SHDNRUN);\n       }\n\n       dev_dbg(dai->dev, \"Clock source is %d at %uHz\\n\", clk_id, freq);\n\n       max98088->sysclk = freq;\n       return 0;\n}\n\nstatic int max98088_dai1_set_fmt(struct snd_soc_dai *codec_dai,\n                                unsigned int fmt)\n{\n       struct snd_soc_component *component = codec_dai->component;\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_cdata *cdata;\n       u8 reg15val;\n       u8 reg14val = 0;\n\n       cdata = &max98088->dai[0];\n\n       if (fmt != cdata->fmt) {\n               cdata->fmt = fmt;\n\n               switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n               case SND_SOC_DAIFMT_CBC_CFC:\n                        \n                       snd_soc_component_write(component, M98088_REG_12_DAI1_CLKCFG_HI,\n                               0x80);\n                       snd_soc_component_write(component, M98088_REG_13_DAI1_CLKCFG_LO,\n                               0x00);\n                       break;\n               case SND_SOC_DAIFMT_CBP_CFP:\n                        \n                       reg14val |= M98088_DAI_MAS;\n                       break;\n               default:\n                       dev_err(component->dev, \"Clock mode unsupported\");\n                       return -EINVAL;\n               }\n\n               switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n               case SND_SOC_DAIFMT_I2S:\n                       reg14val |= M98088_DAI_DLY;\n                       break;\n               case SND_SOC_DAIFMT_LEFT_J:\n                       break;\n               default:\n                       return -EINVAL;\n               }\n\n               switch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n               case SND_SOC_DAIFMT_NB_NF:\n                       break;\n               case SND_SOC_DAIFMT_NB_IF:\n                       reg14val |= M98088_DAI_WCI;\n                       break;\n               case SND_SOC_DAIFMT_IB_NF:\n                       reg14val |= M98088_DAI_BCI;\n                       break;\n               case SND_SOC_DAIFMT_IB_IF:\n                       reg14val |= M98088_DAI_BCI|M98088_DAI_WCI;\n                       break;\n               default:\n                       return -EINVAL;\n               }\n\n               snd_soc_component_update_bits(component, M98088_REG_14_DAI1_FORMAT,\n                       M98088_DAI_MAS | M98088_DAI_DLY | M98088_DAI_BCI |\n                       M98088_DAI_WCI, reg14val);\n\n               reg15val = M98088_DAI_BSEL64;\n               if (max98088->digmic)\n                       reg15val |= M98088_DAI_OSR64;\n               snd_soc_component_write(component, M98088_REG_15_DAI1_CLOCK, reg15val);\n       }\n\n       return 0;\n}\n\nstatic int max98088_dai2_set_fmt(struct snd_soc_dai *codec_dai,\n                                unsigned int fmt)\n{\n       struct snd_soc_component *component = codec_dai->component;\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_cdata *cdata;\n       u8 reg1Cval = 0;\n\n       cdata = &max98088->dai[1];\n\n       if (fmt != cdata->fmt) {\n               cdata->fmt = fmt;\n\n               switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n               case SND_SOC_DAIFMT_CBC_CFC:\n                        \n                       snd_soc_component_write(component, M98088_REG_1A_DAI2_CLKCFG_HI,\n                               0x80);\n                       snd_soc_component_write(component, M98088_REG_1B_DAI2_CLKCFG_LO,\n                               0x00);\n                       break;\n               case SND_SOC_DAIFMT_CBP_CFP:\n                        \n                       reg1Cval |= M98088_DAI_MAS;\n                       break;\n               default:\n                       dev_err(component->dev, \"Clock mode unsupported\");\n                       return -EINVAL;\n               }\n\n               switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n               case SND_SOC_DAIFMT_I2S:\n                       reg1Cval |= M98088_DAI_DLY;\n                       break;\n               case SND_SOC_DAIFMT_LEFT_J:\n                       break;\n               default:\n                       return -EINVAL;\n               }\n\n               switch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n               case SND_SOC_DAIFMT_NB_NF:\n                       break;\n               case SND_SOC_DAIFMT_NB_IF:\n                       reg1Cval |= M98088_DAI_WCI;\n                       break;\n               case SND_SOC_DAIFMT_IB_NF:\n                       reg1Cval |= M98088_DAI_BCI;\n                       break;\n               case SND_SOC_DAIFMT_IB_IF:\n                       reg1Cval |= M98088_DAI_BCI|M98088_DAI_WCI;\n                       break;\n               default:\n                       return -EINVAL;\n               }\n\n               snd_soc_component_update_bits(component, M98088_REG_1C_DAI2_FORMAT,\n                       M98088_DAI_MAS | M98088_DAI_DLY | M98088_DAI_BCI |\n                       M98088_DAI_WCI, reg1Cval);\n\n               snd_soc_component_write(component, M98088_REG_1D_DAI2_CLOCK,\n                       M98088_DAI_BSEL64);\n       }\n\n       return 0;\n}\n\nstatic int max98088_dai1_mute(struct snd_soc_dai *codec_dai, int mute,\n\t\t\t      int direction)\n{\n       struct snd_soc_component *component = codec_dai->component;\n       int reg;\n\n       if (mute)\n               reg = M98088_DAI_MUTE;\n       else\n               reg = 0;\n\n       snd_soc_component_update_bits(component, M98088_REG_2F_LVL_DAI1_PLAY,\n                           M98088_DAI_MUTE_MASK, reg);\n       return 0;\n}\n\nstatic int max98088_dai2_mute(struct snd_soc_dai *codec_dai, int mute,\n\t\t\t      int direction)\n{\n       struct snd_soc_component *component = codec_dai->component;\n       int reg;\n\n       if (mute)\n               reg = M98088_DAI_MUTE;\n       else\n               reg = 0;\n\n       snd_soc_component_update_bits(component, M98088_REG_31_LVL_DAI2_PLAY,\n                           M98088_DAI_MUTE_MASK, reg);\n       return 0;\n}\n\nstatic int max98088_set_bias_level(struct snd_soc_component *component,\n                                  enum snd_soc_bias_level level)\n{\n\tstruct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (!IS_ERR(max98088->mclk)) {\n\t\t\tif (snd_soc_component_get_bias_level(component) ==\n\t\t\t    SND_SOC_BIAS_ON)\n\t\t\t\tclk_disable_unprepare(max98088->mclk);\n\t\t\telse\n\t\t\t\tclk_prepare_enable(max98088->mclk);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tregcache_sync(max98088->regmap);\n\n\t\tsnd_soc_component_update_bits(component, M98088_REG_4C_PWR_EN_IN,\n\t\t\t\t   M98088_MBEN, M98088_MBEN);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, M98088_REG_4C_PWR_EN_IN,\n\t\t\t\t    M98088_MBEN, 0);\n\t\tregcache_mark_dirty(max98088->regmap);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define MAX98088_RATES SNDRV_PCM_RATE_8000_96000\n#define MAX98088_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops max98088_dai1_ops = {\n       .set_sysclk = max98088_dai_set_sysclk,\n       .set_fmt = max98088_dai1_set_fmt,\n       .hw_params = max98088_dai1_hw_params,\n       .mute_stream = max98088_dai1_mute,\n       .no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops max98088_dai2_ops = {\n       .set_sysclk = max98088_dai_set_sysclk,\n       .set_fmt = max98088_dai2_set_fmt,\n       .hw_params = max98088_dai2_hw_params,\n       .mute_stream = max98088_dai2_mute,\n       .no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver max98088_dai[] = {\n{\n       .name = \"HiFi\",\n       .playback = {\n               .stream_name = \"HiFi Playback\",\n               .channels_min = 1,\n               .channels_max = 2,\n               .rates = MAX98088_RATES,\n               .formats = MAX98088_FORMATS,\n       },\n       .capture = {\n               .stream_name = \"HiFi Capture\",\n               .channels_min = 1,\n               .channels_max = 2,\n               .rates = MAX98088_RATES,\n               .formats = MAX98088_FORMATS,\n       },\n        .ops = &max98088_dai1_ops,\n},\n{\n       .name = \"Aux\",\n       .playback = {\n               .stream_name = \"Aux Playback\",\n               .channels_min = 1,\n               .channels_max = 2,\n               .rates = MAX98088_RATES,\n               .formats = MAX98088_FORMATS,\n       },\n       .ops = &max98088_dai2_ops,\n}\n};\n\nstatic const char *eq_mode_name[] = {\"EQ1 Mode\", \"EQ2 Mode\"};\n\nstatic int max98088_get_channel(struct snd_soc_component *component, const char *name)\n{\n\tint ret;\n\n\tret = match_string(eq_mode_name, ARRAY_SIZE(eq_mode_name), name);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"Bad EQ channel name '%s'\\n\", name);\n\treturn ret;\n}\n\nstatic void max98088_setup_eq1(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_pdata *pdata = max98088->pdata;\n       struct max98088_eq_cfg *coef_set;\n       int best, best_val, save, i, sel, fs;\n       struct max98088_cdata *cdata;\n\n       cdata = &max98088->dai[0];\n\n       if (!pdata || !max98088->eq_textcnt)\n               return;\n\n        \n       fs = cdata->rate;\n       sel = cdata->eq_sel;\n\n       best = 0;\n       best_val = INT_MAX;\n       for (i = 0; i < pdata->eq_cfgcnt; i++) {\n               if (strcmp(pdata->eq_cfg[i].name, max98088->eq_texts[sel]) == 0 &&\n                   abs(pdata->eq_cfg[i].rate - fs) < best_val) {\n                       best = i;\n                       best_val = abs(pdata->eq_cfg[i].rate - fs);\n               }\n       }\n\n       dev_dbg(component->dev, \"Selected %s/%dHz for %dHz sample rate\\n\",\n               pdata->eq_cfg[best].name,\n               pdata->eq_cfg[best].rate, fs);\n\n        \n       save = snd_soc_component_read(component, M98088_REG_49_CFG_LEVEL);\n       snd_soc_component_update_bits(component, M98088_REG_49_CFG_LEVEL, M98088_EQ1EN, 0);\n\n       coef_set = &pdata->eq_cfg[sel];\n\n       m98088_eq_band(component, 0, 0, coef_set->band1);\n       m98088_eq_band(component, 0, 1, coef_set->band2);\n       m98088_eq_band(component, 0, 2, coef_set->band3);\n       m98088_eq_band(component, 0, 3, coef_set->band4);\n       m98088_eq_band(component, 0, 4, coef_set->band5);\n\n        \n       snd_soc_component_update_bits(component, M98088_REG_49_CFG_LEVEL, M98088_EQ1EN, save);\n}\n\nstatic void max98088_setup_eq2(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_pdata *pdata = max98088->pdata;\n       struct max98088_eq_cfg *coef_set;\n       int best, best_val, save, i, sel, fs;\n       struct max98088_cdata *cdata;\n\n       cdata = &max98088->dai[1];\n\n       if (!pdata || !max98088->eq_textcnt)\n               return;\n\n        \n       fs = cdata->rate;\n\n       sel = cdata->eq_sel;\n       best = 0;\n       best_val = INT_MAX;\n       for (i = 0; i < pdata->eq_cfgcnt; i++) {\n               if (strcmp(pdata->eq_cfg[i].name, max98088->eq_texts[sel]) == 0 &&\n                   abs(pdata->eq_cfg[i].rate - fs) < best_val) {\n                       best = i;\n                       best_val = abs(pdata->eq_cfg[i].rate - fs);\n               }\n       }\n\n       dev_dbg(component->dev, \"Selected %s/%dHz for %dHz sample rate\\n\",\n               pdata->eq_cfg[best].name,\n               pdata->eq_cfg[best].rate, fs);\n\n        \n       save = snd_soc_component_read(component, M98088_REG_49_CFG_LEVEL);\n       snd_soc_component_update_bits(component, M98088_REG_49_CFG_LEVEL, M98088_EQ2EN, 0);\n\n       coef_set = &pdata->eq_cfg[sel];\n\n       m98088_eq_band(component, 1, 0, coef_set->band1);\n       m98088_eq_band(component, 1, 1, coef_set->band2);\n       m98088_eq_band(component, 1, 2, coef_set->band3);\n       m98088_eq_band(component, 1, 3, coef_set->band4);\n       m98088_eq_band(component, 1, 4, coef_set->band5);\n\n        \n       snd_soc_component_update_bits(component, M98088_REG_49_CFG_LEVEL, M98088_EQ2EN,\n               save);\n}\n\nstatic int max98088_put_eq_enum(struct snd_kcontrol *kcontrol,\n                                struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_pdata *pdata = max98088->pdata;\n       int channel = max98088_get_channel(component, kcontrol->id.name);\n       struct max98088_cdata *cdata;\n\tint sel = ucontrol->value.enumerated.item[0];\n\n       if (channel < 0)\n\t       return channel;\n\n       cdata = &max98088->dai[channel];\n\n       if (sel >= pdata->eq_cfgcnt)\n               return -EINVAL;\n\n       cdata->eq_sel = sel;\n\n       switch (channel) {\n       case 0:\n               max98088_setup_eq1(component);\n               break;\n       case 1:\n               max98088_setup_eq2(component);\n               break;\n       }\n\n       return 0;\n}\n\nstatic int max98088_get_eq_enum(struct snd_kcontrol *kcontrol,\n                                struct snd_ctl_elem_value *ucontrol)\n{\n       struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       int channel = max98088_get_channel(component, kcontrol->id.name);\n       struct max98088_cdata *cdata;\n\n       if (channel < 0)\n\t       return channel;\n\n       cdata = &max98088->dai[channel];\n       ucontrol->value.enumerated.item[0] = cdata->eq_sel;\n       return 0;\n}\n\nstatic void max98088_handle_eq_pdata(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_pdata *pdata = max98088->pdata;\n       struct max98088_eq_cfg *cfg;\n       unsigned int cfgcnt;\n       int i, j;\n       const char **t;\n       int ret;\n       struct snd_kcontrol_new controls[] = {\n               SOC_ENUM_EXT((char *)eq_mode_name[0],\n                       max98088->eq_enum,\n                       max98088_get_eq_enum,\n                       max98088_put_eq_enum),\n               SOC_ENUM_EXT((char *)eq_mode_name[1],\n                       max98088->eq_enum,\n                       max98088_get_eq_enum,\n                       max98088_put_eq_enum),\n       };\n       BUILD_BUG_ON(ARRAY_SIZE(controls) != ARRAY_SIZE(eq_mode_name));\n\n       cfg = pdata->eq_cfg;\n       cfgcnt = pdata->eq_cfgcnt;\n\n        \n       max98088->eq_textcnt = 0;\n       max98088->eq_texts = NULL;\n       for (i = 0; i < cfgcnt; i++) {\n               for (j = 0; j < max98088->eq_textcnt; j++) {\n                       if (strcmp(cfg[i].name, max98088->eq_texts[j]) == 0)\n                               break;\n               }\n\n               if (j != max98088->eq_textcnt)\n                       continue;\n\n                \n               t = krealloc(max98088->eq_texts,\n                            sizeof(char *) * (max98088->eq_textcnt + 1),\n                            GFP_KERNEL);\n               if (t == NULL)\n                       continue;\n\n                \n               t[max98088->eq_textcnt] = cfg[i].name;\n               max98088->eq_textcnt++;\n               max98088->eq_texts = t;\n       }\n\n        \n       max98088->eq_enum.texts = max98088->eq_texts;\n       max98088->eq_enum.items = max98088->eq_textcnt;\n\n       ret = snd_soc_add_component_controls(component, controls, ARRAY_SIZE(controls));\n       if (ret != 0)\n               dev_err(component->dev, \"Failed to add EQ control: %d\\n\", ret);\n}\n\nstatic void max98088_handle_pdata(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_pdata *pdata = max98088->pdata;\n       u8 regval = 0;\n\n       if (!pdata) {\n               dev_dbg(component->dev, \"No platform data\\n\");\n               return;\n       }\n\n        \n       if (pdata->digmic_left_mode)\n               regval |= M98088_DIGMIC_L;\n\n       if (pdata->digmic_right_mode)\n               regval |= M98088_DIGMIC_R;\n\n       max98088->digmic = (regval ? 1 : 0);\n\n       snd_soc_component_write(component, M98088_REG_48_CFG_MIC, regval);\n\n        \n       regval = ((pdata->receiver_mode) ? M98088_REC_LINEMODE : 0);\n       snd_soc_component_update_bits(component, M98088_REG_2A_MIC_REC_CNTL,\n               M98088_REC_LINEMODE_MASK, regval);\n\n        \n       if (pdata->eq_cfgcnt)\n               max98088_handle_eq_pdata(component);\n}\n\nstatic int max98088_probe(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n       struct max98088_cdata *cdata;\n       int ret = 0;\n\n       regcache_mark_dirty(max98088->regmap);\n\n        \n\n       max98088->sysclk = (unsigned)-1;\n       max98088->eq_textcnt = 0;\n\n       cdata = &max98088->dai[0];\n       cdata->rate = (unsigned)-1;\n       cdata->fmt  = (unsigned)-1;\n       cdata->eq_sel = 0;\n\n       cdata = &max98088->dai[1];\n       cdata->rate = (unsigned)-1;\n       cdata->fmt  = (unsigned)-1;\n       cdata->eq_sel = 0;\n\n       max98088->ina_state = 0;\n       max98088->inb_state = 0;\n       max98088->ex_mode = 0;\n       max98088->digmic = 0;\n       max98088->mic1pre = 0;\n       max98088->mic2pre = 0;\n\n       ret = snd_soc_component_read(component, M98088_REG_FF_REV_ID);\n       if (ret < 0) {\n               dev_err(component->dev, \"Failed to read device revision: %d\\n\",\n                       ret);\n               goto err_access;\n       }\n       dev_info(component->dev, \"revision %c\\n\", ret - 0x40 + 'A');\n\n       snd_soc_component_write(component, M98088_REG_51_PWR_SYS, M98088_PWRSV);\n\n       snd_soc_component_write(component, M98088_REG_0F_IRQ_ENABLE, 0x00);\n\n       snd_soc_component_write(component, M98088_REG_22_MIX_DAC,\n               M98088_DAI1L_TO_DACL|M98088_DAI2L_TO_DACL|\n               M98088_DAI1R_TO_DACR|M98088_DAI2R_TO_DACR);\n\n       snd_soc_component_write(component, M98088_REG_4E_BIAS_CNTL, 0xF0);\n       snd_soc_component_write(component, M98088_REG_50_DAC_BIAS2, 0x0F);\n\n       snd_soc_component_write(component, M98088_REG_16_DAI1_IOCFG,\n               M98088_S1NORMAL|M98088_SDATA);\n\n       snd_soc_component_write(component, M98088_REG_1E_DAI2_IOCFG,\n               M98088_S2NORMAL|M98088_SDATA);\n\n       max98088_handle_pdata(component);\n\nerr_access:\n       return ret;\n}\n\nstatic void max98088_remove(struct snd_soc_component *component)\n{\n       struct max98088_priv *max98088 = snd_soc_component_get_drvdata(component);\n\n       kfree(max98088->eq_texts);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98088 = {\n\t.probe\t\t\t= max98088_probe,\n\t.remove\t\t\t= max98088_remove,\n\t.set_bias_level\t\t= max98088_set_bias_level,\n\t.controls\t\t= max98088_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98088_snd_controls),\n\t.dapm_widgets\t\t= max98088_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98088_dapm_widgets),\n\t.dapm_routes\t\t= max98088_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98088_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct i2c_device_id max98088_i2c_id[] = {\n       { \"max98088\", MAX98088 },\n       { \"max98089\", MAX98089 },\n       { }\n};\nMODULE_DEVICE_TABLE(i2c, max98088_i2c_id);\n\nstatic int max98088_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max98088_priv *max98088;\n\tconst struct i2c_device_id *id;\n\n\tmax98088 = devm_kzalloc(&i2c->dev, sizeof(struct max98088_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (max98088 == NULL)\n\t\treturn -ENOMEM;\n\n\tmax98088->regmap = devm_regmap_init_i2c(i2c, &max98088_regmap);\n\tif (IS_ERR(max98088->regmap))\n\t\treturn PTR_ERR(max98088->regmap);\n\n\tmax98088->mclk = devm_clk_get(&i2c->dev, \"mclk\");\n\tif (IS_ERR(max98088->mclk))\n\t\tif (PTR_ERR(max98088->mclk) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(max98088->mclk);\n\n\tid = i2c_match_id(max98088_i2c_id, i2c);\n\tmax98088->devtype = id->driver_data;\n\n\ti2c_set_clientdata(i2c, max98088);\n\tmax98088->pdata = i2c->dev.platform_data;\n\n\treturn devm_snd_soc_register_component(&i2c->dev, &soc_component_dev_max98088,\n\t\t\t\t\t      &max98088_dai[0], 2);\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98088_of_match[] = {\n\t{ .compatible = \"maxim,max98088\" },\n\t{ .compatible = \"maxim,max98089\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98088_of_match);\n#endif\n\nstatic struct i2c_driver max98088_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98088\",\n\t\t.of_match_table = of_match_ptr(max98088_of_match),\n\t},\n\t.probe = max98088_i2c_probe,\n\t.id_table = max98088_i2c_id,\n};\n\nmodule_i2c_driver(max98088_i2c_driver);\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98088 driver\");\nMODULE_AUTHOR(\"Peter Hsiang, Jesse Marroquin\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}