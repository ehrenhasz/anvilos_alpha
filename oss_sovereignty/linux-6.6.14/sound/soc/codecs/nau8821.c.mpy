{
  "module_name": "nau8821.c",
  "hash_id": "460dfc1a4f3d451e33035d05a50c4f33bfcea2aac21c780043e1a16d50385bdc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8821.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/math64.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"nau8821.h\"\n\n#define NAU8821_JD_ACTIVE_HIGH\t\t\tBIT(0)\n\nstatic int nau8821_quirk;\nstatic int quirk_override = -1;\nmodule_param_named(quirk, quirk_override, uint, 0444);\nMODULE_PARM_DESC(quirk, \"Board-specific quirk override\");\n\n#define NAU_FREF_MAX 13500000\n#define NAU_FVCO_MAX 100000000\n#define NAU_FVCO_MIN 90000000\n\n#define NAU8821_BUTTON SND_JACK_BTN_0\n\n \n#define CLK_DA_AD_MAX 6144000\n\nstatic int nau8821_configure_sysclk(struct nau8821 *nau8821,\n\tint clk_id, unsigned int freq);\nstatic bool nau8821_is_jack_inserted(struct regmap *regmap);\n\nstruct nau8821_fll {\n\tint mclk_src;\n\tint ratio;\n\tint fll_frac;\n\tint fll_int;\n\tint clk_ref_div;\n};\n\nstruct nau8821_fll_attr {\n\tunsigned int param;\n\tunsigned int val;\n};\n\n \nstatic const struct nau8821_fll_attr mclk_src_scaling[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x2 },\n\t{ 4, 0x3 },\n\t{ 8, 0x4 },\n\t{ 16, 0x5 },\n\t{ 32, 0x6 },\n\t{ 3, 0x7 },\n\t{ 6, 0xa },\n\t{ 12, 0xb },\n\t{ 24, 0xc },\n\t{ 48, 0xd },\n\t{ 96, 0xe },\n\t{ 5, 0xf },\n};\n\n \nstatic const struct nau8821_fll_attr fll_ratio[] = {\n\t{ 512000, 0x01 },\n\t{ 256000, 0x02 },\n\t{ 128000, 0x04 },\n\t{ 64000, 0x08 },\n\t{ 32000, 0x10 },\n\t{ 8000, 0x20 },\n\t{ 4000, 0x40 },\n};\n\nstatic const struct nau8821_fll_attr fll_pre_scalar[] = {\n\t{ 0, 0x0 },\n\t{ 1, 0x1 },\n\t{ 2, 0x2 },\n\t{ 3, 0x3 },\n};\n\n \nstruct nau8821_osr_attr {\n\tunsigned int osr;\n\tunsigned int clk_src;\n};\n\nstatic const struct nau8821_osr_attr osr_dac_sel[] = {\n\t{ 64, 2 },\t \n\t{ 256, 0 },\t \n\t{ 128, 1 },\t \n\t{ 0, 0 },\n\t{ 32, 3 },\t \n};\n\nstatic const struct nau8821_osr_attr osr_adc_sel[] = {\n\t{ 32, 3 },\t \n\t{ 64, 2 },\t \n\t{ 128, 1 },\t \n\t{ 256, 0 },\t \n};\n\nstruct nau8821_dmic_speed {\n\tunsigned int param;\n\tunsigned int val;\n};\n\nstatic const struct nau8821_dmic_speed dmic_speed_sel[] = {\n\t{ 0, 0x0 },\t \n\t{ 1, 0x1 },\t \n\t{ 2, 0x2 },\t \n\t{ 3, 0x3 },\t \n};\n\nstatic const struct reg_default nau8821_reg_defaults[] = {\n\t{ NAU8821_R01_ENA_CTRL, 0x00ff },\n\t{ NAU8821_R03_CLK_DIVIDER, 0x0050 },\n\t{ NAU8821_R04_FLL1, 0x0 },\n\t{ NAU8821_R05_FLL2, 0x00bc },\n\t{ NAU8821_R06_FLL3, 0x0008 },\n\t{ NAU8821_R07_FLL4, 0x0010 },\n\t{ NAU8821_R08_FLL5, 0x4000 },\n\t{ NAU8821_R09_FLL6, 0x6900 },\n\t{ NAU8821_R0A_FLL7, 0x0031 },\n\t{ NAU8821_R0B_FLL8, 0x26e9 },\n\t{ NAU8821_R0D_JACK_DET_CTRL, 0x0 },\n\t{ NAU8821_R0F_INTERRUPT_MASK, 0x0 },\n\t{ NAU8821_R12_INTERRUPT_DIS_CTRL, 0xffff },\n\t{ NAU8821_R13_DMIC_CTRL, 0x0 },\n\t{ NAU8821_R1A_GPIO12_CTRL, 0x0 },\n\t{ NAU8821_R1B_TDM_CTRL, 0x0 },\n\t{ NAU8821_R1C_I2S_PCM_CTRL1, 0x000a },\n\t{ NAU8821_R1D_I2S_PCM_CTRL2, 0x8010 },\n\t{ NAU8821_R1E_LEFT_TIME_SLOT, 0x0 },\n\t{ NAU8821_R1F_RIGHT_TIME_SLOT, 0x0 },\n\t{ NAU8821_R21_BIQ0_COF1, 0x0 },\n\t{ NAU8821_R22_BIQ0_COF2, 0x0 },\n\t{ NAU8821_R23_BIQ0_COF3, 0x0 },\n\t{ NAU8821_R24_BIQ0_COF4, 0x0 },\n\t{ NAU8821_R25_BIQ0_COF5, 0x0 },\n\t{ NAU8821_R26_BIQ0_COF6, 0x0 },\n\t{ NAU8821_R27_BIQ0_COF7, 0x0 },\n\t{ NAU8821_R28_BIQ0_COF8, 0x0 },\n\t{ NAU8821_R29_BIQ0_COF9, 0x0 },\n\t{ NAU8821_R2A_BIQ0_COF10, 0x0 },\n\t{ NAU8821_R2B_ADC_RATE, 0x0002 },\n\t{ NAU8821_R2C_DAC_CTRL1, 0x0082 },\n\t{ NAU8821_R2D_DAC_CTRL2, 0x0 },\n\t{ NAU8821_R2F_DAC_DGAIN_CTRL, 0x0 },\n\t{ NAU8821_R30_ADC_DGAIN_CTRL, 0x0 },\n\t{ NAU8821_R31_MUTE_CTRL, 0x0 },\n\t{ NAU8821_R32_HSVOL_CTRL, 0x0 },\n\t{ NAU8821_R34_DACR_CTRL, 0xcfcf },\n\t{ NAU8821_R35_ADC_DGAIN_CTRL1, 0xcfcf },\n\t{ NAU8821_R36_ADC_DRC_KNEE_IP12, 0x1486 },\n\t{ NAU8821_R37_ADC_DRC_KNEE_IP34, 0x0f12 },\n\t{ NAU8821_R38_ADC_DRC_SLOPES, 0x25ff },\n\t{ NAU8821_R39_ADC_DRC_ATKDCY, 0x3457 },\n\t{ NAU8821_R3A_DAC_DRC_KNEE_IP12, 0x1486 },\n\t{ NAU8821_R3B_DAC_DRC_KNEE_IP34, 0x0f12 },\n\t{ NAU8821_R3C_DAC_DRC_SLOPES, 0x25f9 },\n\t{ NAU8821_R3D_DAC_DRC_ATKDCY, 0x3457 },\n\t{ NAU8821_R41_BIQ1_COF1, 0x0 },\n\t{ NAU8821_R42_BIQ1_COF2, 0x0 },\n\t{ NAU8821_R43_BIQ1_COF3, 0x0 },\n\t{ NAU8821_R44_BIQ1_COF4, 0x0 },\n\t{ NAU8821_R45_BIQ1_COF5, 0x0 },\n\t{ NAU8821_R46_BIQ1_COF6, 0x0 },\n\t{ NAU8821_R47_BIQ1_COF7, 0x0 },\n\t{ NAU8821_R48_BIQ1_COF8, 0x0 },\n\t{ NAU8821_R49_BIQ1_COF9, 0x0 },\n\t{ NAU8821_R4A_BIQ1_COF10, 0x0 },\n\t{ NAU8821_R4B_CLASSG_CTRL, 0x0 },\n\t{ NAU8821_R4C_IMM_MODE_CTRL, 0x0 },\n\t{ NAU8821_R4D_IMM_RMS_L, 0x0 },\n\t{ NAU8821_R53_OTPDOUT_1, 0xaad8 },\n\t{ NAU8821_R54_OTPDOUT_2, 0x0002 },\n\t{ NAU8821_R55_MISC_CTRL, 0x0 },\n\t{ NAU8821_R66_BIAS_ADJ, 0x0 },\n\t{ NAU8821_R68_TRIM_SETTINGS, 0x0 },\n\t{ NAU8821_R69_ANALOG_CONTROL_1, 0x0 },\n\t{ NAU8821_R6A_ANALOG_CONTROL_2, 0x0 },\n\t{ NAU8821_R6B_PGA_MUTE, 0x0 },\n\t{ NAU8821_R71_ANALOG_ADC_1, 0x0011 },\n\t{ NAU8821_R72_ANALOG_ADC_2, 0x0020 },\n\t{ NAU8821_R73_RDAC, 0x0008 },\n\t{ NAU8821_R74_MIC_BIAS, 0x0006 },\n\t{ NAU8821_R76_BOOST, 0x0 },\n\t{ NAU8821_R77_FEPGA, 0x0 },\n\t{ NAU8821_R7E_PGA_GAIN, 0x0 },\n\t{ NAU8821_R7F_POWER_UP_CONTROL, 0x0 },\n\t{ NAU8821_R80_CHARGE_PUMP, 0x0 },\n};\n\nstatic bool nau8821_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8821_R00_RESET ... NAU8821_R01_ENA_CTRL:\n\tcase NAU8821_R03_CLK_DIVIDER ... NAU8821_R0B_FLL8:\n\tcase NAU8821_R0D_JACK_DET_CTRL:\n\tcase NAU8821_R0F_INTERRUPT_MASK ... NAU8821_R13_DMIC_CTRL:\n\tcase NAU8821_R1A_GPIO12_CTRL ... NAU8821_R1F_RIGHT_TIME_SLOT:\n\tcase NAU8821_R21_BIQ0_COF1 ... NAU8821_R2D_DAC_CTRL2:\n\tcase NAU8821_R2F_DAC_DGAIN_CTRL ... NAU8821_R32_HSVOL_CTRL:\n\tcase NAU8821_R34_DACR_CTRL ... NAU8821_R3D_DAC_DRC_ATKDCY:\n\tcase NAU8821_R41_BIQ1_COF1 ... NAU8821_R4F_FUSE_CTRL3:\n\tcase NAU8821_R51_FUSE_CTRL1:\n\tcase NAU8821_R53_OTPDOUT_1 ... NAU8821_R55_MISC_CTRL:\n\tcase NAU8821_R58_I2C_DEVICE_ID ... NAU8821_R5A_SOFTWARE_RST:\n\tcase NAU8821_R66_BIAS_ADJ:\n\tcase NAU8821_R68_TRIM_SETTINGS ... NAU8821_R6B_PGA_MUTE:\n\tcase NAU8821_R71_ANALOG_ADC_1 ... NAU8821_R74_MIC_BIAS:\n\tcase NAU8821_R76_BOOST ... NAU8821_R77_FEPGA:\n\tcase NAU8821_R7E_PGA_GAIN ... NAU8821_R82_GENERAL_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8821_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8821_R00_RESET ... NAU8821_R01_ENA_CTRL:\n\tcase NAU8821_R03_CLK_DIVIDER ... NAU8821_R0B_FLL8:\n\tcase NAU8821_R0D_JACK_DET_CTRL:\n\tcase NAU8821_R0F_INTERRUPT_MASK:\n\tcase NAU8821_R11_INT_CLR_KEY_STATUS ... NAU8821_R13_DMIC_CTRL:\n\tcase NAU8821_R1A_GPIO12_CTRL ... NAU8821_R1F_RIGHT_TIME_SLOT:\n\tcase NAU8821_R21_BIQ0_COF1 ... NAU8821_R2D_DAC_CTRL2:\n\tcase NAU8821_R2F_DAC_DGAIN_CTRL ... NAU8821_R32_HSVOL_CTRL:\n\tcase NAU8821_R34_DACR_CTRL ... NAU8821_R3D_DAC_DRC_ATKDCY:\n\tcase NAU8821_R41_BIQ1_COF1 ... NAU8821_R4C_IMM_MODE_CTRL:\n\tcase NAU8821_R4E_FUSE_CTRL2 ... NAU8821_R4F_FUSE_CTRL3:\n\tcase NAU8821_R51_FUSE_CTRL1:\n\tcase NAU8821_R55_MISC_CTRL:\n\tcase NAU8821_R5A_SOFTWARE_RST:\n\tcase NAU8821_R66_BIAS_ADJ:\n\tcase NAU8821_R68_TRIM_SETTINGS ... NAU8821_R6B_PGA_MUTE:\n\tcase NAU8821_R71_ANALOG_ADC_1 ... NAU8821_R74_MIC_BIAS:\n\tcase NAU8821_R76_BOOST ... NAU8821_R77_FEPGA:\n\tcase NAU8821_R7E_PGA_GAIN ... NAU8821_R80_CHARGE_PUMP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8821_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8821_R00_RESET:\n\tcase NAU8821_R10_IRQ_STATUS ... NAU8821_R11_INT_CLR_KEY_STATUS:\n\tcase NAU8821_R21_BIQ0_COF1 ... NAU8821_R2A_BIQ0_COF10:\n\tcase NAU8821_R41_BIQ1_COF1 ... NAU8821_R4A_BIQ1_COF10:\n\tcase NAU8821_R4D_IMM_RMS_L:\n\tcase NAU8821_R53_OTPDOUT_1 ... NAU8821_R54_OTPDOUT_2:\n\tcase NAU8821_R58_I2C_DEVICE_ID ... NAU8821_R5A_SOFTWARE_RST:\n\tcase NAU8821_R81_CHARGE_PUMP_INPUT_READ ... NAU8821_R82_GENERAL_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nau8821_biq_coeff_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\n\tif (!component->regmap)\n\t\treturn -EINVAL;\n\n\tregmap_raw_read(component->regmap, NAU8821_R21_BIQ0_COF1,\n\t\tucontrol->value.bytes.data, params->max);\n\n\treturn 0;\n}\n\nstatic int nau8821_biq_coeff_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tvoid *data;\n\n\tif (!component->regmap)\n\t\treturn -EINVAL;\n\n\tdata = kmemdup(ucontrol->value.bytes.data,\n\t\tparams->max, GFP_KERNEL | GFP_DMA);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tregmap_raw_write(component->regmap, NAU8821_R21_BIQ0_COF1,\n\t\tdata, params->max);\n\n\tkfree(data);\n\n\treturn 0;\n}\n\nstatic const char * const nau8821_adc_decimation[] = {\n\t\"32\", \"64\", \"128\", \"256\" };\n\nstatic const struct soc_enum nau8821_adc_decimation_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R2B_ADC_RATE, NAU8821_ADC_SYNC_DOWN_SFT,\n\t\tARRAY_SIZE(nau8821_adc_decimation), nau8821_adc_decimation);\n\nstatic const char * const nau8821_dac_oversampl[] = {\n\t\"64\", \"256\", \"128\", \"\", \"32\" };\n\nstatic const struct soc_enum nau8821_dac_oversampl_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R2C_DAC_CTRL1, NAU8821_DAC_OVERSAMPLE_SFT,\n\t\tARRAY_SIZE(nau8821_dac_oversampl), nau8821_dac_oversampl);\n\nstatic const char * const nau8821_adc_drc_noise_gate[] = {\n\t\"1:1\", \"2:1\", \"4:1\", \"8:1\" };\n\nstatic const struct soc_enum nau8821_adc_drc_noise_gate_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R38_ADC_DRC_SLOPES, NAU8821_DRC_NG_SLP_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_adc_drc_noise_gate),\n\t\tnau8821_adc_drc_noise_gate);\n\nstatic const char * const nau8821_adc_drc_expansion_slope[] = {\n\t\"1:1\", \"2:1\", \"4:1\" };\n\nstatic const struct soc_enum nau8821_adc_drc_expansion_slope_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R38_ADC_DRC_SLOPES, NAU8821_DRC_EXP_SLP_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_adc_drc_expansion_slope),\n\t\tnau8821_adc_drc_expansion_slope);\n\nstatic const char * const nau8821_adc_drc_lower_region[] = {\n\t\"0\", \"1:2\", \"1:4\", \"1:8\", \"1:16\", \"\", \"\", \"1:1\" };\n\nstatic const struct soc_enum nau8821_adc_drc_lower_region_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R38_ADC_DRC_SLOPES,\n\t\tNAU8821_DRC_CMP2_SLP_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_adc_drc_lower_region),\n\t\tnau8821_adc_drc_lower_region);\n\nstatic const char * const nau8821_higher_region[] = {\n\t\"0\", \"1:2\", \"1:4\", \"1:8\", \"1:16\", \"\", \"\", \"1:1\" };\n\nstatic const struct soc_enum nau8821_higher_region_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R38_ADC_DRC_SLOPES,\n\t\tNAU8821_DRC_CMP1_SLP_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_higher_region),\n\t\tnau8821_higher_region);\n\nstatic const char * const nau8821_limiter_slope[] = {\n\t\"0\", \"1:2\", \"1:4\", \"1:8\", \"1:16\", \"1:32\", \"1:64\", \"1:1\" };\n\nstatic const struct soc_enum nau8821_limiter_slope_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R38_ADC_DRC_SLOPES,\n\t\tNAU8821_DRC_LMT_SLP_ADC_SFT, ARRAY_SIZE(nau8821_limiter_slope),\n\t\tnau8821_limiter_slope);\n\nstatic const char * const nau8821_detection_attack_time[] = {\n\t\"Ts\", \"3Ts\", \"7Ts\", \"15Ts\", \"31Ts\", \"63Ts\", \"127Ts\", \"255Ts\",\n\t\"\", \"511Ts\" };\n\nstatic const struct soc_enum nau8821_detection_attack_time_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R39_ADC_DRC_ATKDCY,\n\t\tNAU8821_DRC_PK_COEF1_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_detection_attack_time),\n\t\tnau8821_detection_attack_time);\n\nstatic const char * const nau8821_detection_release_time[] = {\n\t\"63Ts\", \"127Ts\", \"255Ts\", \"511Ts\", \"1023Ts\", \"2047Ts\", \"4095Ts\",\n\t\"8191Ts\", \"\", \"16383Ts\" };\n\nstatic const struct soc_enum nau8821_detection_release_time_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R39_ADC_DRC_ATKDCY,\n\t\tNAU8821_DRC_PK_COEF2_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_detection_release_time),\n\t\tnau8821_detection_release_time);\n\nstatic const char * const nau8821_attack_time[] = {\n\t\"Ts\", \"3Ts\", \"7Ts\", \"15Ts\", \"31Ts\", \"63Ts\", \"127Ts\", \"255Ts\",\n\t\"511Ts\", \"1023Ts\", \"2047Ts\", \"4095Ts\", \"8191Ts\" };\n\nstatic const struct soc_enum nau8821_attack_time_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R39_ADC_DRC_ATKDCY, NAU8821_DRC_ATK_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_attack_time), nau8821_attack_time);\n\nstatic const char * const nau8821_decay_time[] = {\n\t\"63Ts\", \"127Ts\", \"255Ts\", \"511Ts\", \"1023Ts\", \"2047Ts\", \"4095Ts\",\n\t\"8191Ts\", \"16383Ts\", \"32757Ts\", \"65535Ts\" };\n\nstatic const struct soc_enum nau8821_decay_time_enum =\n\tSOC_ENUM_SINGLE(NAU8821_R39_ADC_DRC_ATKDCY, NAU8821_DRC_DCY_ADC_SFT,\n\t\tARRAY_SIZE(nau8821_decay_time), nau8821_decay_time);\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(adc_vol_tlv, -6600, 2400);\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(sidetone_vol_tlv, -4200, 0);\nstatic const DECLARE_TLV_DB_MINMAX(hp_vol_tlv, -900, 0);\nstatic const DECLARE_TLV_DB_SCALE(playback_vol_tlv, -6600, 50, 1);\nstatic const DECLARE_TLV_DB_MINMAX(fepga_gain_tlv, -100, 3600);\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(crosstalk_vol_tlv, -7000, 2400);\nstatic const DECLARE_TLV_DB_MINMAX(drc_knee4_tlv, -9800, -3500);\nstatic const DECLARE_TLV_DB_MINMAX(drc_knee3_tlv, -8100, -1800);\n\nstatic const struct snd_kcontrol_new nau8821_controls[] = {\n\tSOC_DOUBLE_TLV(\"Mic Volume\", NAU8821_R35_ADC_DGAIN_CTRL1,\n\t\tNAU8821_ADCL_CH_VOL_SFT, NAU8821_ADCR_CH_VOL_SFT,\n\t\t0xff, 0, adc_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Bypass Volume\", NAU8821_R30_ADC_DGAIN_CTRL,\n\t\t12, 8, 0x0f, 0, sidetone_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Volume\", NAU8821_R32_HSVOL_CTRL,\n\t\tNAU8821_HPL_VOL_SFT, NAU8821_HPR_VOL_SFT, 0x3, 1, hp_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Digital Playback Volume\", NAU8821_R34_DACR_CTRL,\n\t\tNAU8821_DACL_CH_VOL_SFT, NAU8821_DACR_CH_VOL_SFT,\n\t\t0xcf, 0, playback_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Frontend PGA Volume\", NAU8821_R7E_PGA_GAIN,\n\t\tNAU8821_PGA_GAIN_L_SFT, NAU8821_PGA_GAIN_R_SFT,\n\t\t37, 0, fepga_gain_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Crosstalk Volume\",\n\t\tNAU8821_R2F_DAC_DGAIN_CTRL,\n\t\t0, 8, 0xff, 0, crosstalk_vol_tlv),\n\tSOC_SINGLE_TLV(\"ADC DRC KNEE4\", NAU8821_R37_ADC_DRC_KNEE_IP34,\n\t\tNAU8821_DRC_KNEE4_IP_ADC_SFT, 0x3f, 1, drc_knee4_tlv),\n\tSOC_SINGLE_TLV(\"ADC DRC KNEE3\", NAU8821_R37_ADC_DRC_KNEE_IP34,\n\t\tNAU8821_DRC_KNEE3_IP_ADC_SFT, 0x3f, 1, drc_knee3_tlv),\n\n\tSOC_ENUM(\"ADC DRC Noise Gate\", nau8821_adc_drc_noise_gate_enum),\n\tSOC_ENUM(\"ADC DRC Expansion Slope\", nau8821_adc_drc_expansion_slope_enum),\n\tSOC_ENUM(\"ADC DRC Lower Region\", nau8821_adc_drc_lower_region_enum),\n\tSOC_ENUM(\"ADC DRC Higher Region\", nau8821_higher_region_enum),\n\tSOC_ENUM(\"ADC DRC Limiter Slope\", nau8821_limiter_slope_enum),\n\tSOC_ENUM(\"ADC DRC Peak Detection Attack Time\", nau8821_detection_attack_time_enum),\n\tSOC_ENUM(\"ADC DRC Peak Detection Release Time\", nau8821_detection_release_time_enum),\n\tSOC_ENUM(\"ADC DRC Attack Time\", nau8821_attack_time_enum),\n\tSOC_ENUM(\"ADC DRC Decay Time\", nau8821_decay_time_enum),\n\tSOC_SINGLE(\"DRC Enable Switch\", NAU8821_R36_ADC_DRC_KNEE_IP12,\n\t\tNAU8821_DRC_ENA_ADC_SFT, 1, 0),\n\n\tSOC_ENUM(\"ADC Decimation Rate\", nau8821_adc_decimation_enum),\n\tSOC_ENUM(\"DAC Oversampling Rate\", nau8821_dac_oversampl_enum),\n\tSND_SOC_BYTES_EXT(\"BIQ Coefficients\", 20,\n\t\tnau8821_biq_coeff_get, nau8821_biq_coeff_put),\n\tSOC_SINGLE(\"ADC Phase Switch\", NAU8821_R1B_TDM_CTRL,\n\t\tNAU8821_ADCPHS_SFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8821_dmic_mode_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8821_R13_DMIC_CTRL,\n\t\tNAU8821_DMIC_EN_SFT, 1, 0);\n\nstatic int dmic_clock_control(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tint i, speed_selection = -1, clk_adc_src, clk_adc;\n\tunsigned int clk_divider_r03;\n\n\t \n\tregmap_read(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t&clk_divider_r03);\n\tclk_adc_src = (clk_divider_r03 & NAU8821_CLK_ADC_SRC_MASK)\n\t\t>> NAU8821_CLK_ADC_SRC_SFT;\n\tclk_adc = (nau8821->fs * 256) >> clk_adc_src;\n\n\tfor (i = 0 ; i < 4 ; i++)\n\t\tif ((clk_adc >> dmic_speed_sel[i].param) <=\n\t\t\tnau8821->dmic_clk_threshold) {\n\t\t\tspeed_selection = dmic_speed_sel[i].val;\n\t\t\tbreak;\n\t\t}\n\tif (i == 4)\n\t\treturn -EINVAL;\n\n\tdev_dbg(nau8821->dev,\n\t\t\"clk_adc=%d, dmic_clk_threshold = %d, param=%d, val = %d\\n\",\n\t\tclk_adc, nau8821->dmic_clk_threshold,\n\t\tdmic_speed_sel[i].param, dmic_speed_sel[i].val);\n\tregmap_update_bits(nau8821->regmap, NAU8821_R13_DMIC_CTRL,\n\t\tNAU8821_DMIC_SRC_MASK,\n\t\t(speed_selection << NAU8821_DMIC_SRC_SFT));\n\n\treturn 0;\n}\n\nstatic int nau8821_left_adc_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(125);\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R01_ENA_CTRL,\n\t\t\tNAU8821_EN_ADCL, NAU8821_EN_ADCL);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8821->regmap,\n\t\t\tNAU8821_R01_ENA_CTRL, NAU8821_EN_ADCL, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8821_right_adc_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(125);\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R01_ENA_CTRL,\n\t\t\tNAU8821_EN_ADCR, NAU8821_EN_ADCR);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8821->regmap,\n\t\t\tNAU8821_R01_ENA_CTRL, NAU8821_EN_ADCR, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8821_pump_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tmsleep(20);\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R80_CHARGE_PUMP,\n\t\t\tNAU8821_JAMNODCLOW, NAU8821_JAMNODCLOW);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R80_CHARGE_PUMP,\n\t\t\tNAU8821_JAMNODCLOW, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8821_output_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R66_BIAS_ADJ,\n\t\t\tNAU8821_BIAS_TESTDAC_EN, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R66_BIAS_ADJ,\n\t\t\tNAU8821_BIAS_TESTDAC_EN, NAU8821_BIAS_TESTDAC_EN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int system_clock_control(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tdev_dbg(nau8821->dev, \"system clock control : POWER OFF\\n\");\n\t\t \n\t\tif (nau8821_is_jack_inserted(nau8821->regmap)) {\n\t\t\tnau8821_configure_sysclk(nau8821,\n\t\t\t\tNAU8821_CLK_INTERNAL, 0);\n\t\t} else {\n\t\t\tnau8821_configure_sysclk(nau8821, NAU8821_CLK_DIS, 0);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int nau8821_left_fepga_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tif (!nau8821->left_input_single_end)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R77_FEPGA,\n\t\t\tNAU8821_ACDC_CTRL_MASK | NAU8821_FEPGA_MODEL_MASK,\n\t\t\tNAU8821_ACDC_VREF_MICN | NAU8821_FEPGA_MODEL_AAF);\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R76_BOOST,\n\t\t\tNAU8821_HP_BOOST_DISCHRG_EN, NAU8821_HP_BOOST_DISCHRG_EN);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R77_FEPGA,\n\t\t\tNAU8821_ACDC_CTRL_MASK | NAU8821_FEPGA_MODEL_MASK, 0);\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R76_BOOST,\n\t\t\tNAU8821_HP_BOOST_DISCHRG_EN, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget nau8821_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"System Clock\", SND_SOC_NOPM, 0, 0,\n\t\tsystem_clock_control, SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", NAU8821_R74_MIC_BIAS,\n\t\tNAU8821_MICBIAS_POWERUP_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC Clock\", SND_SOC_NOPM, 0, 0,\n\t\tdmic_clock_control, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_ADC(\"ADCL Power\", NULL, NAU8821_R72_ANALOG_ADC_2,\n\t\tNAU8821_POWERUP_ADCL_SFT, 0),\n\tSND_SOC_DAPM_ADC(\"ADCR Power\", NULL, NAU8821_R72_ANALOG_ADC_2,\n\t\tNAU8821_POWERUP_ADCR_SFT, 0),\n\t \n\tSND_SOC_DAPM_PGA_S(\"Frontend PGA L\", 1, NAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_PGA_L_SFT, 0, nau8821_left_fepga_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_S(\"Frontend PGA R\", 1, NAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_PGA_R_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADCL Digital path\", 0, NAU8821_R01_ENA_CTRL,\n\t\tNAU8821_EN_ADCL_SFT, 0, nau8821_left_adc_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_S(\"ADCR Digital path\", 0, NAU8821_R01_ENA_CTRL,\n\t\tNAU8821_EN_ADCR_SFT, 0, nau8821_right_adc_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SWITCH(\"DMIC Enable\", SND_SOC_NOPM,\n\t\t0, 0, &nau8821_dmic_mode_switch),\n\tSND_SOC_DAPM_AIF_OUT(\"AIFTX\", \"Capture\", 0, NAU8821_R1D_I2S_PCM_CTRL2,\n\t\tNAU8821_I2S_TRISTATE_SFT, 1),\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_PGA_S(\"ADACL\", 2, NAU8821_R73_RDAC,\n\t\tNAU8821_DACL_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACR\", 2, NAU8821_R73_RDAC,\n\t\tNAU8821_DACR_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACL Clock\", 3, NAU8821_R73_RDAC,\n\t\tNAU8821_DACL_CLK_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACR Clock\", 3, NAU8821_R73_RDAC,\n\t\tNAU8821_DACR_CLK_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"DDACR\", NULL, NAU8821_R01_ENA_CTRL,\n\t\tNAU8821_EN_DACR_SFT, 0),\n\tSND_SOC_DAPM_DAC(\"DDACL\", NULL, NAU8821_R01_ENA_CTRL,\n\t\tNAU8821_EN_DACL_SFT, 0),\n\tSND_SOC_DAPM_PGA_S(\"HP amp L\", 0, NAU8821_R4B_CLASSG_CTRL,\n\t\tNAU8821_CLASSG_LDAC_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"HP amp R\", 0, NAU8821_R4B_CLASSG_CTRL,\n\t\tNAU8821_CLASSG_RDAC_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Charge Pump\", 1, NAU8821_R80_CHARGE_PUMP,\n\t\tNAU8821_CHANRGE_PUMP_EN_SFT, 0, nau8821_pump_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 1\", 4,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_INTEG_R_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 1\", 4,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_INTEG_L_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 2\", 5,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_DRV_INSTG_R_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 2\", 5,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_DRV_INSTG_L_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 3\", 6,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_MAIN_DRV_R_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 3\", 6,\n\t\tNAU8821_R7F_POWER_UP_CONTROL,\n\t\tNAU8821_PUP_MAIN_DRV_L_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output DACL\", 7,\n\t\tNAU8821_R80_CHARGE_PUMP, NAU8821_POWER_DOWN_DACL_SFT,\n\t\t0, nau8821_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_S(\"Output DACR\", 7,\n\t\tNAU8821_R80_CHARGE_PUMP, NAU8821_POWER_DOWN_DACR_SFT,\n\t\t0, nau8821_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_PGA_S(\"HPOL Pulldown\", 8,\n\t\tNAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_SPKR_DWN1L_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"HPOR Pulldown\", 8,\n\t\tNAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_SPKR_DWN1R_SFT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA_S(\"HP Boost Driver\", 9,\n\t\tNAU8821_R76_BOOST, NAU8821_HP_BOOST_DIS_SFT, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Class G\", NAU8821_R4B_CLASSG_CTRL,\n\t\tNAU8821_CLASSG_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MICL\"),\n\tSND_SOC_DAPM_INPUT(\"MICR\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route nau8821_dapm_routes[] = {\n\t{\"DMIC Enable\", \"Switch\", \"DMIC\"},\n\t{\"DMIC Enable\", NULL, \"DMIC Clock\"},\n\n\t{\"Frontend PGA L\", NULL, \"MICL\"},\n\t{\"Frontend PGA R\", NULL, \"MICR\"},\n\t{\"Frontend PGA L\", NULL, \"MICBIAS\"},\n\t{\"Frontend PGA R\", NULL, \"MICBIAS\"},\n\n\t{\"ADCL Power\", NULL, \"Frontend PGA L\"},\n\t{\"ADCR Power\", NULL, \"Frontend PGA R\"},\n\n\t{\"ADCL Digital path\", NULL, \"ADCL Power\"},\n\t{\"ADCR Digital path\", NULL, \"ADCR Power\"},\n\t{\"ADCL Digital path\", NULL, \"DMIC Enable\"},\n\t{\"ADCR Digital path\", NULL, \"DMIC Enable\"},\n\n\t{\"AIFTX\", NULL, \"ADCL Digital path\"},\n\t{\"AIFTX\", NULL, \"ADCR Digital path\"},\n\n\t{\"AIFTX\", NULL, \"System Clock\"},\n\t{\"AIFRX\", NULL, \"System Clock\"},\n\n\t{\"DDACL\", NULL, \"AIFRX\"},\n\t{\"DDACR\", NULL, \"AIFRX\"},\n\n\t{\"HP amp L\", NULL, \"DDACL\"},\n\t{\"HP amp R\", NULL, \"DDACR\"},\n\n\t{\"Charge Pump\", NULL, \"HP amp L\"},\n\t{\"Charge Pump\", NULL, \"HP amp R\"},\n\n\t{\"ADACL\", NULL, \"Charge Pump\"},\n\t{\"ADACR\", NULL, \"Charge Pump\"},\n\t{\"ADACL Clock\", NULL, \"ADACL\"},\n\t{\"ADACR Clock\", NULL, \"ADACR\"},\n\n\t{\"Output Driver L Stage 1\", NULL, \"ADACL Clock\"},\n\t{\"Output Driver R Stage 1\", NULL, \"ADACR Clock\"},\n\t{\"Output Driver L Stage 2\", NULL, \"Output Driver L Stage 1\"},\n\t{\"Output Driver R Stage 2\", NULL, \"Output Driver R Stage 1\"},\n\t{\"Output Driver L Stage 3\", NULL, \"Output Driver L Stage 2\"},\n\t{\"Output Driver R Stage 3\", NULL, \"Output Driver R Stage 2\"},\n\t{\"Output DACL\", NULL, \"Output Driver L Stage 3\"},\n\t{\"Output DACR\", NULL, \"Output Driver R Stage 3\"},\n\n\t{\"HPOL Pulldown\", NULL, \"Output DACL\"},\n\t{\"HPOR Pulldown\", NULL, \"Output DACR\"},\n\t{\"HP Boost Driver\", NULL, \"HPOL Pulldown\"},\n\t{\"HP Boost Driver\", NULL, \"HPOR Pulldown\"},\n\n\t{\"Class G\", NULL, \"HP Boost Driver\"},\n\t{\"HPOL\", NULL, \"Class G\"},\n\t{\"HPOR\", NULL, \"Class G\"},\n};\n\nstatic const struct nau8821_osr_attr *\nnau8821_get_osr(struct nau8821 *nau8821, int stream)\n{\n\tunsigned int osr;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_read(nau8821->regmap, NAU8821_R2C_DAC_CTRL1, &osr);\n\t\tosr &= NAU8821_DAC_OVERSAMPLE_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_dac_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_dac_sel[osr];\n\t} else {\n\t\tregmap_read(nau8821->regmap, NAU8821_R2B_ADC_RATE, &osr);\n\t\tosr &= NAU8821_ADC_SYNC_DOWN_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_adc_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_adc_sel[osr];\n\t}\n}\n\nstatic int nau8821_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tconst struct nau8821_osr_attr *osr;\n\n\tosr = nau8821_get_osr(nau8821, substream->stream);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    0, CLK_DA_AD_MAX / osr->osr);\n}\n\nstatic int nau8821_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0, ctrl_val, bclk_fs, clk_div;\n\tconst struct nau8821_osr_attr *osr;\n\n\tnau8821->fs = params_rate(params);\n\t \n\tosr = nau8821_get_osr(nau8821, substream->stream);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\tif (nau8821->fs * osr->osr > CLK_DA_AD_MAX)\n\t\treturn -EINVAL;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t\tNAU8821_CLK_DAC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8821_CLK_DAC_SRC_SFT);\n\telse\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t\tNAU8821_CLK_ADC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8821_CLK_ADC_SRC_SFT);\n\n\t \n\tregmap_read(nau8821->regmap, NAU8821_R1D_I2S_PCM_CTRL2, &ctrl_val);\n\tif (ctrl_val & NAU8821_I2S_MS_MASTER) {\n\t\t \n\t\tbclk_fs = snd_soc_params_to_bclk(params) / nau8821->fs;\n\t\tif (bclk_fs <= 32)\n\t\t\tclk_div = 3;\n\t\telse if (bclk_fs <= 64)\n\t\t\tclk_div = 2;\n\t\telse if (bclk_fs <= 128)\n\t\t\tclk_div = 1;\n\t\telse {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregmap_update_bits(nau8821->regmap, NAU8821_R1D_I2S_PCM_CTRL2,\n\t\t\tNAU8821_I2S_LRC_DIV_MASK | NAU8821_I2S_BLK_DIV_MASK,\n\t\t\t(clk_div << NAU8821_I2S_LRC_DIV_SFT) | clk_div);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= NAU8821_I2S_DL_16;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= NAU8821_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= NAU8821_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len |= NAU8821_I2S_DL_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(nau8821->regmap, NAU8821_R1C_I2S_PCM_CTRL1,\n\t\tNAU8821_I2S_DL_MASK, val_len);\n\n\treturn 0;\n}\n\nstatic int nau8821_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl1_val = 0, ctrl2_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tctrl2_val |= NAU8821_I2S_MS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= NAU8821_I2S_BP_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= NAU8821_I2S_DF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= NAU8821_I2S_DF_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl1_val |= NAU8821_I2S_DF_RIGTH;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= NAU8821_I2S_DF_PCM_AB;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl1_val |= NAU8821_I2S_DF_PCM_AB;\n\t\tctrl1_val |= NAU8821_I2S_PCMB_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(nau8821->regmap, NAU8821_R1C_I2S_PCM_CTRL1,\n\t\tNAU8821_I2S_DL_MASK | NAU8821_I2S_DF_MASK |\n\t\tNAU8821_I2S_BP_MASK | NAU8821_I2S_PCMB_MASK, ctrl1_val);\n\tregmap_update_bits(nau8821->regmap, NAU8821_R1D_I2S_PCM_CTRL2,\n\t\tNAU8821_I2S_MS_MASK, ctrl2_val);\n\n\treturn 0;\n}\n\nstatic int nau8821_digital_mute(struct snd_soc_dai *dai, int mute,\n\t\tint direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\n\tif (mute)\n\t\tval = NAU8821_DAC_SOFT_MUTE;\n\n\treturn regmap_update_bits(nau8821->regmap,\n\t\tNAU8821_R31_MUTE_CTRL, NAU8821_DAC_SOFT_MUTE, val);\n}\n\nstatic const struct snd_soc_dai_ops nau8821_dai_ops = {\n\t.startup = nau8821_dai_startup,\n\t.hw_params = nau8821_hw_params,\n\t.set_fmt = nau8821_set_dai_fmt,\n\t.mute_stream = nau8821_digital_mute,\n\t.no_capture_mute = 1,\n};\n\n#define NAU8821_RATES SNDRV_PCM_RATE_8000_192000\n#define NAU8821_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t| SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver nau8821_dai = {\n\t.name = NUVOTON_CODEC_DAI,\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = NAU8821_RATES,\n\t\t.formats = NAU8821_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = NAU8821_RATES,\n\t\t.formats = NAU8821_FORMATS,\n\t},\n\t.ops = &nau8821_dai_ops,\n};\n\n\nstatic bool nau8821_is_jack_inserted(struct regmap *regmap)\n{\n\tbool active_high, is_high;\n\tint status, jkdet;\n\n\tregmap_read(regmap, NAU8821_R0D_JACK_DET_CTRL, &jkdet);\n\tactive_high = jkdet & NAU8821_JACK_POLARITY;\n\tregmap_read(regmap, NAU8821_R82_GENERAL_STATUS, &status);\n\tis_high = status & NAU8821_GPIO2_IN;\n\t \n\treturn active_high == is_high;\n}\n\nstatic void nau8821_int_status_clear_all(struct regmap *regmap)\n{\n\tint active_irq, clear_irq, i;\n\n\t \n\tregmap_read(regmap, NAU8821_R10_IRQ_STATUS, &active_irq);\n\tfor (i = 0; i < NAU8821_REG_DATA_LEN; i++) {\n\t\tclear_irq = (0x1 << i);\n\t\tif (active_irq & clear_irq)\n\t\t\tregmap_write(regmap,\n\t\t\t\tNAU8821_R11_INT_CLR_KEY_STATUS, clear_irq);\n\t}\n}\n\nstatic void nau8821_eject_jack(struct nau8821 *nau8821)\n{\n\tstruct snd_soc_dapm_context *dapm = nau8821->dapm;\n\tstruct regmap *regmap = nau8821->regmap;\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(dapm);\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R74_MIC_BIAS,\n\t\tNAU8821_MICBIAS_JKR2, 0);\n\t \n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_SPKR_DWN1R | NAU8821_SPKR_DWN1L, 0);\n\tsnd_soc_component_disable_pin(component, \"MICBIAS\");\n\tsnd_soc_dapm_sync(dapm);\n\n\t \n\tnau8821_int_status_clear_all(regmap);\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\tNAU8821_IRQ_EJECT_DIS | NAU8821_IRQ_INSERT_DIS,\n\t\tNAU8821_IRQ_EJECT_DIS);\n\t \n\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\tNAU8821_IRQ_EJECT_EN | NAU8821_IRQ_INSERT_EN,\n\t\tNAU8821_IRQ_EJECT_EN);\n\n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_JACK_DET_DB_BYPASS, NAU8821_JACK_DET_DB_BYPASS);\n\n\t \n\tif (dapm->bias_level < SND_SOC_BIAS_PREPARE)\n\t\tnau8821_configure_sysclk(nau8821, NAU8821_CLK_DIS, 0);\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,\n\t\t\tNAU8821_ADC_R_SRC_EN, 0);\n\tif (nau8821->key_enable) {\n\t\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\t\tNAU8821_IRQ_KEY_RELEASE_EN |\n\t\t\tNAU8821_IRQ_KEY_PRESS_EN,\n\t\t\tNAU8821_IRQ_KEY_RELEASE_EN |\n\t\t\tNAU8821_IRQ_KEY_PRESS_EN);\n\t\tregmap_update_bits(regmap,\n\t\t\tNAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\t\tNAU8821_IRQ_KEY_RELEASE_DIS |\n\t\t\tNAU8821_IRQ_KEY_PRESS_DIS,\n\t\t\tNAU8821_IRQ_KEY_RELEASE_DIS |\n\t\t\tNAU8821_IRQ_KEY_PRESS_DIS);\n\t}\n\n}\n\nstatic void nau8821_jdet_work(struct work_struct *work)\n{\n\tstruct nau8821 *nau8821 =\n\t\tcontainer_of(work, struct nau8821, jdet_work);\n\tstruct snd_soc_dapm_context *dapm = nau8821->dapm;\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(dapm);\n\tstruct regmap *regmap = nau8821->regmap;\n\tint jack_status_reg, mic_detected, event = 0, event_mask = 0;\n\n\tsnd_soc_component_force_enable_pin(component, \"MICBIAS\");\n\tsnd_soc_dapm_sync(dapm);\n\tmsleep(20);\n\n\tregmap_read(regmap, NAU8821_R58_I2C_DEVICE_ID, &jack_status_reg);\n\tmic_detected = !(jack_status_reg & NAU8821_KEYDET);\n\tif (mic_detected) {\n\t\tdev_dbg(nau8821->dev, \"Headset connected\\n\");\n\t\tevent |= SND_JACK_HEADSET;\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R74_MIC_BIAS,\n\t\t\tNAU8821_MICBIAS_JKR2, NAU8821_MICBIAS_JKR2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,\n\t\t\tNAU8821_ADC_R_SRC_EN, NAU8821_ADC_R_SRC_EN);\n\t\tif (nau8821->key_enable) {\n\t\t\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\t\t\tNAU8821_IRQ_KEY_RELEASE_EN |\n\t\t\t\tNAU8821_IRQ_KEY_PRESS_EN, 0);\n\t\t\tregmap_update_bits(regmap,\n\t\t\t\tNAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\t\t\tNAU8821_IRQ_KEY_RELEASE_DIS |\n\t\t\t\tNAU8821_IRQ_KEY_PRESS_DIS, 0);\n\t\t}\n\t} else {\n\t\tdev_dbg(nau8821->dev, \"Headphone connected\\n\");\n\t\tevent |= SND_JACK_HEADPHONE;\n\t\tsnd_soc_component_disable_pin(component, \"MICBIAS\");\n\t\tsnd_soc_dapm_sync(dapm);\n\t}\n\tevent_mask |= SND_JACK_HEADSET;\n\tsnd_soc_jack_report(nau8821->jack, event, event_mask);\n}\n\n \nstatic void nau8821_setup_inserted_irq(struct nau8821 *nau8821)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\t \n\tif (nau8821->dapm->bias_level < SND_SOC_BIAS_PREPARE)\n\t\tnau8821_configure_sysclk(nau8821, NAU8821_CLK_INTERNAL, 0);\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R1D_I2S_PCM_CTRL2,\n\t\tNAU8821_I2S_MS_MASK, NAU8821_I2S_MS_MASTER);\n\tregmap_update_bits(regmap, NAU8821_R1D_I2S_PCM_CTRL2,\n\t\tNAU8821_I2S_MS_MASK, NAU8821_I2S_MS_SLAVE);\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_JACK_DET_DB_BYPASS, 0);\n\n\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\tNAU8821_IRQ_EJECT_EN, 0);\n\tregmap_update_bits(regmap, NAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\tNAU8821_IRQ_EJECT_DIS, 0);\n}\n\nstatic irqreturn_t nau8821_interrupt(int irq, void *data)\n{\n\tstruct nau8821 *nau8821 = (struct nau8821 *)data;\n\tstruct regmap *regmap = nau8821->regmap;\n\tint active_irq, clear_irq = 0, event = 0, event_mask = 0;\n\n\tif (regmap_read(regmap, NAU8821_R10_IRQ_STATUS, &active_irq)) {\n\t\tdev_err(nau8821->dev, \"failed to read irq status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tdev_dbg(nau8821->dev, \"IRQ %d\\n\", active_irq);\n\n\tif ((active_irq & NAU8821_JACK_EJECT_IRQ_MASK) ==\n\t\tNAU8821_JACK_EJECT_DETECTED) {\n\t\tregmap_update_bits(regmap, NAU8821_R71_ANALOG_ADC_1,\n\t\t\tNAU8821_MICDET_MASK, NAU8821_MICDET_DIS);\n\t\tnau8821_eject_jack(nau8821);\n\t\tevent_mask |= SND_JACK_HEADSET;\n\t\tclear_irq = NAU8821_JACK_EJECT_IRQ_MASK;\n\t} else if (active_irq & NAU8821_KEY_SHORT_PRESS_IRQ) {\n\t\tevent |= NAU8821_BUTTON;\n\t\tevent_mask |= NAU8821_BUTTON;\n\t\tclear_irq = NAU8821_KEY_SHORT_PRESS_IRQ;\n\t} else if (active_irq & NAU8821_KEY_RELEASE_IRQ) {\n\t\tevent_mask = NAU8821_BUTTON;\n\t\tclear_irq = NAU8821_KEY_RELEASE_IRQ;\n\t} else if ((active_irq & NAU8821_JACK_INSERT_IRQ_MASK) ==\n\t\tNAU8821_JACK_INSERT_DETECTED) {\n\t\tregmap_update_bits(regmap, NAU8821_R71_ANALOG_ADC_1,\n\t\t\tNAU8821_MICDET_MASK, NAU8821_MICDET_EN);\n\t\tif (nau8821_is_jack_inserted(regmap)) {\n\t\t\t \n\t\t\tcancel_work_sync(&nau8821->jdet_work);\n\t\t\tschedule_work(&nau8821->jdet_work);\n\t\t\t \n\t\t\tregmap_update_bits(regmap,\n\t\t\t\tNAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\t\t\tNAU8821_IRQ_INSERT_DIS,\n\t\t\t\tNAU8821_IRQ_INSERT_DIS);\n\t\t\tregmap_update_bits(regmap,\n\t\t\t\tNAU8821_R0F_INTERRUPT_MASK,\n\t\t\t\tNAU8821_IRQ_INSERT_EN,\n\t\t\t\tNAU8821_IRQ_INSERT_EN);\n\t\t\tnau8821_setup_inserted_irq(nau8821);\n\t\t} else {\n\t\t\tdev_warn(nau8821->dev,\n\t\t\t\t\"Inserted IRQ fired but not connected\\n\");\n\t\t\tnau8821_eject_jack(nau8821);\n\t\t}\n\t}\n\n\tif (!clear_irq)\n\t\tclear_irq = active_irq;\n\t \n\tregmap_write(regmap, NAU8821_R11_INT_CLR_KEY_STATUS, clear_irq);\n\n\tif (event_mask)\n\t\tsnd_soc_jack_report(nau8821->jack, event, event_mask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct regmap_config nau8821_regmap_config = {\n\t.val_bits = NAU8821_REG_DATA_LEN,\n\t.reg_bits = NAU8821_REG_ADDR_LEN,\n\n\t.max_register = NAU8821_REG_MAX,\n\t.readable_reg = nau8821_readable_reg,\n\t.writeable_reg = nau8821_writeable_reg,\n\t.volatile_reg = nau8821_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8821_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8821_reg_defaults),\n};\n\nstatic int nau8821_component_probe(struct snd_soc_component *component)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\n\tnau8821->dapm = dapm;\n\n\treturn 0;\n}\n\n \nstatic int nau8821_calc_fll_param(unsigned int fll_in,\n\tunsigned int fs, struct nau8821_fll *fll_param)\n{\n\tu64 fvco, fvco_max;\n\tunsigned int fref, i, fvco_sel;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_pre_scalar); i++) {\n\t\tfref = fll_in >> fll_pre_scalar[i].param;\n\t\tif (fref <= NAU_FREF_MAX)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_pre_scalar))\n\t\treturn -EINVAL;\n\tfll_param->clk_ref_div = fll_pre_scalar[i].val;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_ratio); i++) {\n\t\tif (fref >= fll_ratio[i].param)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_ratio))\n\t\treturn -EINVAL;\n\tfll_param->ratio = fll_ratio[i].val;\n\n\t \n\tfvco_max = 0;\n\tfvco_sel = ARRAY_SIZE(mclk_src_scaling);\n\tfor (i = 0; i < ARRAY_SIZE(mclk_src_scaling); i++) {\n\t\tfvco = 256ULL * fs * 2 * mclk_src_scaling[i].param;\n\t\tif (fvco > NAU_FVCO_MIN && fvco < NAU_FVCO_MAX &&\n\t\t\tfvco_max < fvco) {\n\t\t\tfvco_max = fvco;\n\t\t\tfvco_sel = i;\n\t\t}\n\t}\n\tif (ARRAY_SIZE(mclk_src_scaling) == fvco_sel)\n\t\treturn -EINVAL;\n\tfll_param->mclk_src = mclk_src_scaling[fvco_sel].val;\n\n\t \n\tfvco = div_u64(fvco_max << 24, fref * fll_param->ratio);\n\tfll_param->fll_int = (fvco >> 24) & 0x3ff;\n\tfll_param->fll_frac = fvco & 0xffffff;\n\n\treturn 0;\n}\n\nstatic void nau8821_fll_apply(struct nau8821 *nau8821,\n\t\tstruct nau8821_fll *fll_param)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\tregmap_update_bits(regmap, NAU8821_R03_CLK_DIVIDER,\n\t\tNAU8821_CLK_SRC_MASK | NAU8821_CLK_MCLK_SRC_MASK,\n\t\tNAU8821_CLK_SRC_MCLK | fll_param->mclk_src);\n\t \n\tregmap_update_bits(regmap, NAU8821_R04_FLL1,\n\t\tNAU8821_FLL_RATIO_MASK | NAU8821_ICTRL_LATCH_MASK,\n\t\tfll_param->ratio | (0x6 << NAU8821_ICTRL_LATCH_SFT));\n\t \n\tregmap_write(regmap, NAU8821_R0A_FLL7,\n\t\t(fll_param->fll_frac >> 16) & 0xff);\n\tregmap_write(regmap, NAU8821_R0B_FLL8, fll_param->fll_frac & 0xffff);\n\t \n\tregmap_update_bits(regmap, NAU8821_R06_FLL3,\n\t\tNAU8821_FLL_INTEGER_MASK, fll_param->fll_int);\n\t \n\tregmap_update_bits(regmap, NAU8821_R07_FLL4,\n\t\tNAU8821_HIGHBW_EN | NAU8821_FLL_REF_DIV_MASK,\n\t\tNAU8821_HIGHBW_EN |\n\t\t(fll_param->clk_ref_div << NAU8821_FLL_REF_DIV_SFT));\n\t \n\tregmap_update_bits(regmap, NAU8821_R08_FLL5,\n\t\tNAU8821_FLL_CLK_SW_MASK, NAU8821_FLL_CLK_SW_REF);\n\t \n\tregmap_update_bits(regmap,\n\t\tNAU8821_R09_FLL6, NAU8821_DCO_EN, 0);\n\tif (fll_param->fll_frac) {\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R08_FLL5,\n\t\t\tNAU8821_FLL_PDB_DAC_EN | NAU8821_FLL_LOOP_FTR_EN |\n\t\t\tNAU8821_FLL_FTR_SW_MASK,\n\t\t\tNAU8821_FLL_PDB_DAC_EN | NAU8821_FLL_LOOP_FTR_EN |\n\t\t\tNAU8821_FLL_FTR_SW_FILTER);\n\t\tregmap_update_bits(regmap, NAU8821_R09_FLL6,\n\t\t\tNAU8821_SDM_EN | NAU8821_CUTOFF500,\n\t\t\tNAU8821_SDM_EN | NAU8821_CUTOFF500);\n\t} else {\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R08_FLL5,\n\t\t\tNAU8821_FLL_PDB_DAC_EN | NAU8821_FLL_LOOP_FTR_EN |\n\t\t\tNAU8821_FLL_FTR_SW_MASK, NAU8821_FLL_FTR_SW_ACCU);\n\t\tregmap_update_bits(regmap, NAU8821_R09_FLL6,\n\t\t\tNAU8821_SDM_EN | NAU8821_CUTOFF500, 0);\n\t}\n}\n\n \nstatic int nau8821_set_fll(struct snd_soc_component *component,\n\tint pll_id, int source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tstruct nau8821_fll fll_set_param, *fll_param = &fll_set_param;\n\tint ret, fs;\n\n\tfs = freq_out >> 8;\n\tret = nau8821_calc_fll_param(freq_in, fs, fll_param);\n\tif (ret) {\n\t\tdev_err(nau8821->dev,\n\t\t\t\"Unsupported input clock %d to output clock %d\\n\",\n\t\t\tfreq_in, freq_out);\n\t\treturn ret;\n\t}\n\tdev_dbg(nau8821->dev,\n\t\t\"mclk_src=%x ratio=%x fll_frac=%x fll_int=%x clk_ref_div=%x\\n\",\n\t\tfll_param->mclk_src, fll_param->ratio, fll_param->fll_frac,\n\t\tfll_param->fll_int, fll_param->clk_ref_div);\n\n\tnau8821_fll_apply(nau8821, fll_param);\n\tmdelay(2);\n\tregmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,\n\t\tNAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);\n\n\treturn 0;\n}\n\nstatic void nau8821_configure_mclk_as_sysclk(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, NAU8821_R03_CLK_DIVIDER,\n\t\tNAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_MCLK);\n\tregmap_update_bits(regmap, NAU8821_R09_FLL6,\n\t\tNAU8821_DCO_EN, 0);\n\t \n\tregmap_update_bits(regmap, NAU8821_R04_FLL1,\n\t\tNAU8821_ICTRL_LATCH_MASK, 0);\n}\n\nstatic int nau8821_configure_sysclk(struct nau8821 *nau8821,\n\tint clk_id, unsigned int freq)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\tswitch (clk_id) {\n\tcase NAU8821_CLK_DIS:\n\t\t \n\t\tnau8821_configure_mclk_as_sysclk(regmap);\n\t\tbreak;\n\tcase NAU8821_CLK_MCLK:\n\t\tnau8821_configure_mclk_as_sysclk(regmap);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t\tNAU8821_CLK_MCLK_SRC_MASK, 0);\n\t\tbreak;\n\tcase NAU8821_CLK_INTERNAL:\n\t\tif (nau8821_is_jack_inserted(regmap)) {\n\t\t\tregmap_update_bits(regmap, NAU8821_R09_FLL6,\n\t\t\t\tNAU8821_DCO_EN, NAU8821_DCO_EN);\n\t\t\tregmap_update_bits(regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t\t\tNAU8821_CLK_SRC_MASK, NAU8821_CLK_SRC_VCO);\n\t\t\t \n\t\t\tregmap_update_bits(regmap, NAU8821_R03_CLK_DIVIDER,\n\t\t\t\tNAU8821_CLK_MCLK_SRC_MASK, 0xf);\n\t\t\tregmap_update_bits(regmap, NAU8821_R04_FLL1,\n\t\t\t\tNAU8821_ICTRL_LATCH_MASK |\n\t\t\t\tNAU8821_FLL_RATIO_MASK, 0x10);\n\t\t\tregmap_update_bits(regmap, NAU8821_R09_FLL6,\n\t\t\t\tNAU8821_SDM_EN, NAU8821_SDM_EN);\n\t\t}\n\t\tbreak;\n\tcase NAU8821_CLK_FLL_MCLK:\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R06_FLL3,\n\t\t\tNAU8821_FLL_CLK_SRC_MASK | NAU8821_GAIN_ERR_MASK,\n\t\t\tNAU8821_FLL_CLK_SRC_MCLK | 0);\n\t\tbreak;\n\tcase NAU8821_CLK_FLL_BLK:\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R06_FLL3,\n\t\t\tNAU8821_FLL_CLK_SRC_MASK | NAU8821_GAIN_ERR_MASK,\n\t\t\tNAU8821_FLL_CLK_SRC_BLK |\n\t\t\t(0xf << NAU8821_GAIN_ERR_SFT));\n\t\tbreak;\n\tcase NAU8821_CLK_FLL_FS:\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R06_FLL3,\n\t\t\tNAU8821_FLL_CLK_SRC_MASK | NAU8821_GAIN_ERR_MASK,\n\t\t\tNAU8821_FLL_CLK_SRC_FS |\n\t\t\t(0xf << NAU8821_GAIN_ERR_SFT));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nau8821->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\tnau8821->clk_id = clk_id;\n\tdev_dbg(nau8821->dev, \"Sysclk is %dHz and clock id is %d\\n\", freq,\n\t\tnau8821->clk_id);\n\n\treturn 0;\n}\n\nstatic int nau8821_set_sysclk(struct snd_soc_component *component, int clk_id,\n\tint source, unsigned int freq, int dir)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\treturn nau8821_configure_sysclk(nau8821, clk_id, freq);\n}\n\nstatic int nau8821_resume_setup(struct nau8821 *nau8821)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\t \n\tnau8821_configure_sysclk(nau8821, NAU8821_CLK_DIS, 0);\n\tif (nau8821->irq) {\n\t\t \n\t\tnau8821_int_status_clear_all(regmap);\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\t\tNAU8821_IRQ_EJECT_EN | NAU8821_IRQ_INSERT_EN, 0);\n\t\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\t\tNAU8821_JACK_DET_DB_BYPASS,\n\t\t\tNAU8821_JACK_DET_DB_BYPASS);\n\t\tregmap_update_bits(regmap, NAU8821_R12_INTERRUPT_DIS_CTRL,\n\t\t\tNAU8821_IRQ_INSERT_DIS | NAU8821_IRQ_EJECT_DIS, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8821_set_bias_level(struct snd_soc_component *component,\n\t\tenum snd_soc_bias_level level)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *regmap = nau8821->regmap;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) ==\n\t\t\tSND_SOC_BIAS_OFF)\n\t\t\tnau8821_resume_setup(nau8821);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\t\tNAU8821_SPKR_DWN1R | NAU8821_SPKR_DWN1L, 0);\n\t\tif (nau8821->irq) {\n\t\t\t \n\t\t\tregmap_update_bits(regmap, NAU8821_R74_MIC_BIAS,\n\t\t\t\tNAU8821_MICBIAS_JKR2, 0);\n\t\t\t \n\t\t\tregmap_write(regmap,\n\t\t\t\tNAU8821_R12_INTERRUPT_DIS_CTRL, 0xffff);\n\t\t\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\t\t\tNAU8821_IRQ_EJECT_EN | NAU8821_IRQ_INSERT_EN,\n\t\t\t\tNAU8821_IRQ_EJECT_EN | NAU8821_IRQ_INSERT_EN);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8821_suspend(struct snd_soc_component *component)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tif (nau8821->irq)\n\t\tdisable_irq(nau8821->irq);\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\t \n\tsnd_soc_component_disable_pin(component, \"MICBIAS\");\n\tsnd_soc_dapm_sync(nau8821->dapm);\n\tregcache_cache_only(nau8821->regmap, true);\n\tregcache_mark_dirty(nau8821->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8821_resume(struct snd_soc_component *component)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(nau8821->regmap, false);\n\tregcache_sync(nau8821->regmap);\n\tif (nau8821->irq)\n\t\tenable_irq(nau8821->irq);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver nau8821_component_driver = {\n\t.probe\t\t\t= nau8821_component_probe,\n\t.set_sysclk\t\t= nau8821_set_sysclk,\n\t.set_pll\t\t= nau8821_set_fll,\n\t.set_bias_level\t\t= nau8821_set_bias_level,\n\t.suspend\t\t= nau8821_suspend,\n\t.resume\t\t\t= nau8821_resume,\n\t.controls\t\t= nau8821_controls,\n\t.num_controls\t\t= ARRAY_SIZE(nau8821_controls),\n\t.dapm_widgets\t\t= nau8821_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(nau8821_dapm_widgets),\n\t.dapm_routes\t\t= nau8821_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(nau8821_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n \nint nau8821_enable_jack_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *jack)\n{\n\tstruct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tnau8821->jack = jack;\n\t \n\tINIT_WORK(&nau8821->jdet_work, nau8821_jdet_work);\n\tret = devm_request_threaded_irq(nau8821->dev, nau8821->irq, NULL,\n\t\tnau8821_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\"nau8821\", nau8821);\n\tif (ret) {\n\t\tdev_err(nau8821->dev, \"Cannot request irq %d (%d)\\n\",\n\t\t\tnau8821->irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nau8821_enable_jack_detect);\n\nstatic void nau8821_reset_chip(struct regmap *regmap)\n{\n\tregmap_write(regmap, NAU8821_R00_RESET, 0xffff);\n\tregmap_write(regmap, NAU8821_R00_RESET, 0xffff);\n}\n\nstatic void nau8821_print_device_properties(struct nau8821 *nau8821)\n{\n\tstruct device *dev = nau8821->dev;\n\n\tdev_dbg(dev, \"jkdet-enable:         %d\\n\", nau8821->jkdet_enable);\n\tdev_dbg(dev, \"jkdet-pull-enable:    %d\\n\", nau8821->jkdet_pull_enable);\n\tdev_dbg(dev, \"jkdet-pull-up:        %d\\n\", nau8821->jkdet_pull_up);\n\tdev_dbg(dev, \"jkdet-polarity:       %d\\n\", nau8821->jkdet_polarity);\n\tdev_dbg(dev, \"micbias-voltage:      %d\\n\", nau8821->micbias_voltage);\n\tdev_dbg(dev, \"vref-impedance:       %d\\n\", nau8821->vref_impedance);\n\tdev_dbg(dev, \"jack-insert-debounce: %d\\n\",\n\t\tnau8821->jack_insert_debounce);\n\tdev_dbg(dev, \"jack-eject-debounce:  %d\\n\",\n\t\tnau8821->jack_eject_debounce);\n\tdev_dbg(dev, \"dmic-clk-threshold:       %d\\n\",\n\t\tnau8821->dmic_clk_threshold);\n\tdev_dbg(dev, \"key_enable:       %d\\n\", nau8821->key_enable);\n}\n\nstatic int nau8821_read_device_properties(struct device *dev,\n\tstruct nau8821 *nau8821)\n{\n\tint ret;\n\n\tnau8821->jkdet_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-enable\");\n\tnau8821->jkdet_pull_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-pull-enable\");\n\tnau8821->jkdet_pull_up = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-pull-up\");\n\tnau8821->key_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,key-enable\");\n\tnau8821->left_input_single_end = device_property_read_bool(dev,\n\t\t\"nuvoton,left-input-single-end\");\n\tret = device_property_read_u32(dev, \"nuvoton,jkdet-polarity\",\n\t\t&nau8821->jkdet_polarity);\n\tif (ret)\n\t\tnau8821->jkdet_polarity = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,micbias-voltage\",\n\t\t&nau8821->micbias_voltage);\n\tif (ret)\n\t\tnau8821->micbias_voltage = 6;\n\tret = device_property_read_u32(dev, \"nuvoton,vref-impedance\",\n\t\t&nau8821->vref_impedance);\n\tif (ret)\n\t\tnau8821->vref_impedance = 2;\n\tret = device_property_read_u32(dev, \"nuvoton,jack-insert-debounce\",\n\t\t&nau8821->jack_insert_debounce);\n\tif (ret)\n\t\tnau8821->jack_insert_debounce = 7;\n\tret = device_property_read_u32(dev, \"nuvoton,jack-eject-debounce\",\n\t\t&nau8821->jack_eject_debounce);\n\tif (ret)\n\t\tnau8821->jack_eject_debounce = 0;\n\tret = device_property_read_u32(dev, \"nuvoton,dmic-clk-threshold\",\n\t\t&nau8821->dmic_clk_threshold);\n\tif (ret)\n\t\tnau8821->dmic_clk_threshold = 3072000;\n\n\treturn 0;\n}\n\nstatic void nau8821_init_regs(struct nau8821 *nau8821)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R66_BIAS_ADJ,\n\t\tNAU8821_BIAS_VMID, NAU8821_BIAS_VMID);\n\tregmap_update_bits(regmap, NAU8821_R76_BOOST,\n\t\tNAU8821_GLOBAL_BIAS_EN, NAU8821_GLOBAL_BIAS_EN);\n\t \n\tregmap_update_bits(regmap, NAU8821_R66_BIAS_ADJ,\n\t\tNAU8821_BIAS_VMID_SEL_MASK | NAU8821_BIAS_TESTDAC_EN,\n\t\t(nau8821->vref_impedance << NAU8821_BIAS_VMID_SEL_SFT) |\n\t\tNAU8821_BIAS_TESTDAC_EN);\n\t \n\tregmap_update_bits(regmap, NAU8821_R1E_LEFT_TIME_SLOT,\n\t\tNAU8821_DIS_FS_SHORT_DET, NAU8821_DIS_FS_SHORT_DET);\n\t \n\tregmap_update_bits(regmap, NAU8821_R76_BOOST,\n\t\tNAU8821_PRECHARGE_DIS | NAU8821_HP_BOOST_DIS |\n\t\tNAU8821_HP_BOOST_G_DIS | NAU8821_SHORT_SHUTDOWN_EN,\n\t\tNAU8821_PRECHARGE_DIS | NAU8821_HP_BOOST_DIS |\n\t\tNAU8821_HP_BOOST_G_DIS | NAU8821_SHORT_SHUTDOWN_EN);\n\t \n\tregmap_update_bits(regmap, NAU8821_R4B_CLASSG_CTRL,\n\t\tNAU8821_CLASSG_TIMER_MASK,\n\t\t0x20 << NAU8821_CLASSG_TIMER_SFT);\n\t \n\tregmap_update_bits(regmap, NAU8821_R6A_ANALOG_CONTROL_2,\n\t\tNAU8821_HP_NON_CLASSG_CURRENT_2xADJ |\n\t\tNAU8821_DAC_CAPACITOR_MSB | NAU8821_DAC_CAPACITOR_LSB,\n\t\tNAU8821_HP_NON_CLASSG_CURRENT_2xADJ |\n\t\tNAU8821_DAC_CAPACITOR_MSB | NAU8821_DAC_CAPACITOR_LSB);\n\t \n\tregmap_update_bits(regmap, NAU8821_R80_CHARGE_PUMP,\n\t\tNAU8821_POWER_DOWN_DACR | NAU8821_POWER_DOWN_DACL, 0);\n\t \n\tregmap_update_bits(regmap, NAU8821_R73_RDAC,\n\t\tNAU8821_DAC_CLK_DELAY_MASK | NAU8821_DAC_VREF_MASK,\n\t\t(0x2 << NAU8821_DAC_CLK_DELAY_SFT) |\n\t\t(0x3 << NAU8821_DAC_VREF_SFT));\n\n\tregmap_update_bits(regmap, NAU8821_R74_MIC_BIAS,\n\t\tNAU8821_MICBIAS_VOLTAGE_MASK, nau8821->micbias_voltage);\n\t \n\tregmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,\n\t\tNAU8821_ADC_SYNC_DOWN_MASK, NAU8821_ADC_SYNC_DOWN_64);\n\tregmap_update_bits(regmap, NAU8821_R2C_DAC_CTRL1,\n\t\tNAU8821_DAC_OVERSAMPLE_MASK, NAU8821_DAC_OVERSAMPLE_64);\n\tif (nau8821->left_input_single_end) {\n\t\tregmap_update_bits(regmap, NAU8821_R6B_PGA_MUTE,\n\t\t\tNAU8821_MUTE_MICNL_EN, NAU8821_MUTE_MICNL_EN);\n\t\tregmap_update_bits(regmap, NAU8821_R74_MIC_BIAS,\n\t\t\tNAU8821_MICBIAS_LOWNOISE_EN, NAU8821_MICBIAS_LOWNOISE_EN);\n\t}\n}\n\nstatic int nau8821_setup_irq(struct nau8821 *nau8821)\n{\n\tstruct regmap *regmap = nau8821->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8821_R1A_GPIO12_CTRL,\n\t\tNAU8821_JKDET_OUTPUT_EN,\n\t\tnau8821->jkdet_enable ? 0 : NAU8821_JKDET_OUTPUT_EN);\n\tregmap_update_bits(regmap, NAU8821_R1A_GPIO12_CTRL,\n\t\tNAU8821_JKDET_PULL_EN,\n\t\tnau8821->jkdet_pull_enable ? 0 : NAU8821_JKDET_PULL_EN);\n\tregmap_update_bits(regmap, NAU8821_R1A_GPIO12_CTRL,\n\t\tNAU8821_JKDET_PULL_UP,\n\t\tnau8821->jkdet_pull_up ? NAU8821_JKDET_PULL_UP : 0);\n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_JACK_POLARITY,\n\t\t \n\t\tnau8821->jkdet_polarity ? 0 : NAU8821_JACK_POLARITY);\n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_JACK_INSERT_DEBOUNCE_MASK,\n\t\tnau8821->jack_insert_debounce <<\n\t\tNAU8821_JACK_INSERT_DEBOUNCE_SFT);\n\tregmap_update_bits(regmap, NAU8821_R0D_JACK_DET_CTRL,\n\t\tNAU8821_JACK_EJECT_DEBOUNCE_MASK,\n\t\tnau8821->jack_eject_debounce <<\n\t\tNAU8821_JACK_EJECT_DEBOUNCE_SFT);\n\t \n\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,\n\t\tNAU8821_IRQ_PIN_PULL_UP | NAU8821_IRQ_PIN_PULL_EN |\n\t\tNAU8821_IRQ_OUTPUT_EN, NAU8821_IRQ_PIN_PULL_UP |\n\t\tNAU8821_IRQ_PIN_PULL_EN | NAU8821_IRQ_OUTPUT_EN);\n\t \n\t \n\tregmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK, 0x3f5, 0x3f5);\n\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id nau8821_quirk_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Positivo Tecnologia SA\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"CW14Q01P-V2\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8821_JD_ACTIVE_HIGH),\n\t},\n\t{}\n};\n\nstatic void nau8821_check_quirks(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\n\tif (quirk_override != -1) {\n\t\tnau8821_quirk = quirk_override;\n\t\treturn;\n\t}\n\n\tdmi_id = dmi_first_match(nau8821_quirk_table);\n\tif (dmi_id)\n\t\tnau8821_quirk = (unsigned long)dmi_id->driver_data;\n}\n\nstatic int nau8821_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8821 *nau8821 = dev_get_platdata(&i2c->dev);\n\tint ret, value;\n\n\tif (!nau8821) {\n\t\tnau8821 = devm_kzalloc(dev, sizeof(*nau8821), GFP_KERNEL);\n\t\tif (!nau8821)\n\t\t\treturn -ENOMEM;\n\t\tnau8821_read_device_properties(dev, nau8821);\n\t}\n\ti2c_set_clientdata(i2c, nau8821);\n\n\tnau8821->regmap = devm_regmap_init_i2c(i2c, &nau8821_regmap_config);\n\tif (IS_ERR(nau8821->regmap))\n\t\treturn PTR_ERR(nau8821->regmap);\n\n\tnau8821->dev = dev;\n\tnau8821->irq = i2c->irq;\n\n\tnau8821_check_quirks();\n\n\tif (nau8821_quirk & NAU8821_JD_ACTIVE_HIGH)\n\t\tnau8821->jkdet_polarity = 0;\n\n\tnau8821_print_device_properties(nau8821);\n\n\tnau8821_reset_chip(nau8821->regmap);\n\tret = regmap_read(nau8821->regmap, NAU8821_R58_I2C_DEVICE_ID, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read device id (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tnau8821_init_regs(nau8821);\n\n\tif (i2c->irq)\n\t\tnau8821_setup_irq(nau8821);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t&nau8821_component_driver, &nau8821_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id nau8821_i2c_ids[] = {\n\t{ \"nau8821\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8821_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8821_of_ids[] = {\n\t{ .compatible = \"nuvoton,nau8821\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nau8821_of_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id nau8821_acpi_match[] = {\n\t{ \"NVTN2020\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, nau8821_acpi_match);\n#endif\n\nstatic struct i2c_driver nau8821_driver = {\n\t.driver = {\n\t\t.name = \"nau8821\",\n\t\t.of_match_table = of_match_ptr(nau8821_of_ids),\n\t\t.acpi_match_table = ACPI_PTR(nau8821_acpi_match),\n\t},\n\t.probe = nau8821_i2c_probe,\n\t.id_table = nau8821_i2c_ids,\n};\nmodule_i2c_driver(nau8821_driver);\n\nMODULE_DESCRIPTION(\"ASoC nau8821 driver\");\nMODULE_AUTHOR(\"John Hsu <kchsu0@nuvoton.com>\");\nMODULE_AUTHOR(\"Seven Lee <wtli@nuvoton.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}