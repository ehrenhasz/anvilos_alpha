{
  "module_name": "rt5682-i2c.c",
  "hash_id": "b2c0634b7bd08b2f9db5271cfa12fc1c5bf20ef628582afb321c4e488a31393b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt5682-i2c.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/spi/spi.h>\n#include <linux/acpi.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/jack.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/rt5682.h>\n\n#include \"rl6231.h\"\n#include \"rt5682.h\"\n\nstatic const struct rt5682_platform_data i2s_default_platform_data = {\n\t.dmic1_data_pin = RT5682_DMIC1_DATA_GPIO2,\n\t.dmic1_clk_pin = RT5682_DMIC1_CLK_GPIO3,\n\t.jd_src = RT5682_JD1,\n\t.btndet_delay = 16,\n\t.dai_clk_names[RT5682_DAI_WCLK_IDX] = \"rt5682-dai-wclk\",\n\t.dai_clk_names[RT5682_DAI_BCLK_IDX] = \"rt5682-dai-bclk\",\n};\n\nstatic const struct regmap_config rt5682_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.max_register = RT5682_I2C_MODE,\n\t.volatile_reg = rt5682_volatile_register,\n\t.readable_reg = rt5682_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = rt5682_reg,\n\t.num_reg_defaults = RT5682_REG_NUM,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic void rt5682_jd_check_handler(struct work_struct *work)\n{\n\tstruct rt5682_priv *rt5682 = container_of(work, struct rt5682_priv,\n\t\tjd_check_work.work);\n\n\tif (snd_soc_component_read(rt5682->component, RT5682_AJD1_CTRL) & RT5682_JDH_RS_MASK)\n\t\t \n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t\t &rt5682->jack_detect_work, 0);\n\telse\n\t\tschedule_delayed_work(&rt5682->jd_check_work, 500);\n}\n\nstatic irqreturn_t rt5682_irq(int irq, void *data)\n{\n\tstruct rt5682_priv *rt5682 = data;\n\n\tmod_delayed_work(system_power_efficient_wq,\n\t\t&rt5682->jack_detect_work, msecs_to_jiffies(rt5682->irq_work_delay_time));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct snd_soc_dai_driver rt5682_dai[] = {\n\t{\n\t\t.name = \"rt5682-aif1\",\n\t\t.id = RT5682_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.ops = &rt5682_aif1_dai_ops,\n\t},\n\t{\n\t\t.name = \"rt5682-aif2\",\n\t\t.id = RT5682_AIF2,\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT5682_STEREO_RATES,\n\t\t\t.formats = RT5682_FORMATS,\n\t\t},\n\t\t.ops = &rt5682_aif2_dai_ops,\n\t},\n};\n\nstatic void rt5682_i2c_disable_regulators(void *data)\n{\n\tstruct rt5682_priv *rt5682 = data;\n\n\tregulator_bulk_disable(ARRAY_SIZE(rt5682->supplies), rt5682->supplies);\n}\n\nstatic int rt5682_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt5682_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct rt5682_priv *rt5682;\n\tint i, ret;\n\tunsigned int val;\n\n\trt5682 = devm_kzalloc(&i2c->dev, sizeof(struct rt5682_priv),\n\t\tGFP_KERNEL);\n\tif (!rt5682)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt5682);\n\n\trt5682->i2c_dev = &i2c->dev;\n\n\trt5682->pdata = i2s_default_platform_data;\n\n\tif (pdata)\n\t\trt5682->pdata = *pdata;\n\telse\n\t\trt5682_parse_dt(rt5682, &i2c->dev);\n\n\trt5682->regmap = devm_regmap_init_i2c(i2c, &rt5682_regmap);\n\tif (IS_ERR(rt5682->regmap)) {\n\t\tret = PTR_ERR(rt5682->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rt5682->supplies); i++)\n\t\trt5682->supplies[i].supply = rt5682_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(rt5682->supplies),\n\t\t\t\t      rt5682->supplies);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(rt5682->supplies),\n\t\t\t\t    rt5682->supplies);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(&i2c->dev, rt5682_i2c_disable_regulators,\n\t\t\t\t       rt5682);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt5682_get_ldo1(rt5682, &i2c->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(300000, 350000);\n\n\tregmap_write(rt5682->regmap, RT5682_I2C_MODE, 0x1);\n\tusleep_range(10000, 15000);\n\n\tregmap_read(rt5682->regmap, RT5682_DEVICE_ID, &val);\n\tif (val != DEVICE_ID) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %x is not rt5682\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tmutex_init(&rt5682->calibrate_mutex);\n\trt5682_calibrate(rt5682);\n\n\trt5682_apply_patch_list(rt5682, &i2c->dev);\n\n\tregmap_write(rt5682->regmap, RT5682_DEPOP_1, 0x0000);\n\n\t \n\tif (rt5682->pdata.dmic1_data_pin != RT5682_DMIC1_NULL) {\n\t\tswitch (rt5682->pdata.dmic1_data_pin) {\n\t\tcase RT5682_DMIC1_DATA_GPIO2:  \n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_DMIC_CTRL_1,\n\t\t\t\tRT5682_DMIC_1_DP_MASK, RT5682_DMIC_1_DP_GPIO2);\n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_GPIO_CTRL_1,\n\t\t\t\tRT5682_GP2_PIN_MASK, RT5682_GP2_PIN_DMIC_SDA);\n\t\t\tbreak;\n\n\t\tcase RT5682_DMIC1_DATA_GPIO5:  \n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_DMIC_CTRL_1,\n\t\t\t\tRT5682_DMIC_1_DP_MASK, RT5682_DMIC_1_DP_GPIO5);\n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_GPIO_CTRL_1,\n\t\t\t\tRT5682_GP5_PIN_MASK, RT5682_GP5_PIN_DMIC_SDA);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(&i2c->dev, \"invalid DMIC_DAT pin\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (rt5682->pdata.dmic1_clk_pin) {\n\t\tcase RT5682_DMIC1_CLK_GPIO1:  \n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_GPIO_CTRL_1,\n\t\t\t\tRT5682_GP1_PIN_MASK, RT5682_GP1_PIN_DMIC_CLK);\n\t\t\tbreak;\n\n\t\tcase RT5682_DMIC1_CLK_GPIO3:  \n\t\t\tregmap_update_bits(rt5682->regmap, RT5682_GPIO_CTRL_1,\n\t\t\t\tRT5682_GP3_PIN_MASK, RT5682_GP3_PIN_DMIC_CLK);\n\t\t\tif (rt5682->pdata.dmic_clk_driving_high)\n\t\t\t\tregmap_update_bits(rt5682->regmap,\n\t\t\t\t\tRT5682_PAD_DRIVING_CTRL,\n\t\t\t\t\tRT5682_PAD_DRV_GP3_MASK,\n\t\t\t\t\t2 << RT5682_PAD_DRV_GP3_SFT);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_warn(&i2c->dev, \"invalid DMIC_CLK pin\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tregmap_update_bits(rt5682->regmap, RT5682_PWR_ANLG_1,\n\t\tRT5682_LDO1_DVO_MASK | RT5682_HP_DRIVER_MASK,\n\t\tRT5682_LDO1_DVO_12 | RT5682_HP_DRIVER_5X);\n\tregmap_write(rt5682->regmap, RT5682_MICBIAS_2, 0x0080);\n\tregmap_update_bits(rt5682->regmap, RT5682_GPIO_CTRL_1,\n\t\tRT5682_GP4_PIN_MASK | RT5682_GP5_PIN_MASK,\n\t\tRT5682_GP4_PIN_ADCDAT1 | RT5682_GP5_PIN_DACDAT1);\n\tregmap_write(rt5682->regmap, RT5682_TEST_MODE_CTRL_1, 0x0000);\n\tregmap_update_bits(rt5682->regmap, RT5682_BIAS_CUR_CTRL_8,\n\t\tRT5682_HPA_CP_BIAS_CTRL_MASK, RT5682_HPA_CP_BIAS_3UA);\n\tregmap_update_bits(rt5682->regmap, RT5682_CHARGE_PUMP_1,\n\t\tRT5682_CP_CLK_HP_MASK, RT5682_CP_CLK_HP_300KHZ);\n\tregmap_update_bits(rt5682->regmap, RT5682_HP_CHARGE_PUMP_1,\n\t\tRT5682_PM_HP_MASK, RT5682_PM_HP_HV);\n\tregmap_update_bits(rt5682->regmap, RT5682_DMIC_CTRL_1,\n\t\tRT5682_FIFO_CLK_DIV_MASK, RT5682_FIFO_CLK_DIV_2);\n\n\tINIT_DELAYED_WORK(&rt5682->jack_detect_work,\n\t\trt5682_jack_detect_handler);\n\tINIT_DELAYED_WORK(&rt5682->jd_check_work,\n\t\trt5682_jd_check_handler);\n\n\tif (i2c->irq) {\n\t\tret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\n\t\t\trt5682_irq, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING\n\t\t\t| IRQF_ONESHOT, \"rt5682\", rt5682);\n\t\tif (!ret)\n\t\t\trt5682->irq = i2c->irq;\n\t\telse\n\t\t\tdev_err(&i2c->dev, \"Failed to reguest IRQ: %d\\n\", ret);\n\t}\n\n#ifdef CONFIG_COMMON_CLK\n\t \n\trt5682->mclk = devm_clk_get_optional(&i2c->dev, \"mclk\");\n\tif (IS_ERR(rt5682->mclk))\n\t\treturn PTR_ERR(rt5682->mclk);\n\n\t \n\tret = rt5682_register_dai_clks(rt5682);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trt5682->lrck[RT5682_AIF1] = 48000;\n#endif\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t       &rt5682_soc_component_dev,\n\t\t\t\t\t       rt5682_dai, ARRAY_SIZE(rt5682_dai));\n}\n\nstatic void rt5682_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct rt5682_priv *rt5682 = i2c_get_clientdata(client);\n\n\tdisable_irq(client->irq);\n\tcancel_delayed_work_sync(&rt5682->jack_detect_work);\n\tcancel_delayed_work_sync(&rt5682->jd_check_work);\n\n\trt5682_reset(rt5682);\n}\n\nstatic void rt5682_i2c_remove(struct i2c_client *client)\n{\n\trt5682_i2c_shutdown(client);\n}\n\nstatic const struct of_device_id rt5682_of_match[] = {\n\t{.compatible = \"realtek,rt5682i\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt5682_of_match);\n\nstatic const struct acpi_device_id rt5682_acpi_match[] = {\n\t{\"10EC5682\", 0,},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt5682_acpi_match);\n\nstatic const struct i2c_device_id rt5682_i2c_id[] = {\n\t{\"rt5682\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, rt5682_i2c_id);\n\nstatic struct i2c_driver rt5682_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt5682\",\n\t\t.of_match_table = rt5682_of_match,\n\t\t.acpi_match_table = rt5682_acpi_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = rt5682_i2c_probe,\n\t.remove = rt5682_i2c_remove,\n\t.shutdown = rt5682_i2c_shutdown,\n\t.id_table = rt5682_i2c_id,\n};\nmodule_i2c_driver(rt5682_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT5682 driver\");\nMODULE_AUTHOR(\"Bard Liao <bardliao@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}