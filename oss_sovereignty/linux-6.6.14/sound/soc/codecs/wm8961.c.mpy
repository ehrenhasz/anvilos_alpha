{
  "module_name": "wm8961.c",
  "hash_id": "90fe3b0b15c3fd9f1b53b57c44ce1799f068e1919411133ef3545bc75eaa1cd1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8961.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8961.h\"\n\n#define WM8961_MAX_REGISTER                     0xFC\n\nstatic const struct reg_default wm8961_reg_defaults[] = {\n\t{  0, 0x009F },      \n\t{  1, 0x009F },      \n\t{  2, 0x0000 },      \n\t{  3, 0x0000 },      \n\t{  4, 0x0020 },      \n\t{  5, 0x0008 },      \n\t{  6, 0x0000 },      \n\t{  7, 0x000A },      \n\t{  8, 0x01F4 },      \n\t{  9, 0x0000 },      \n\t{ 10, 0x00FF },      \n\t{ 11, 0x00FF },      \n\n\t{ 14, 0x0040 },      \n\n\t{ 17, 0x007B },      \n\t{ 18, 0x0000 },      \n\t{ 19, 0x0032 },      \n\t{ 20, 0x0000 },      \n\t{ 21, 0x00C0 },      \n\t{ 22, 0x00C0 },      \n\t{ 23, 0x0120 },      \n\t{ 24, 0x0000 },      \n\t{ 25, 0x0000 },      \n\t{ 26, 0x0000 },      \n\t{ 27, 0x0000 },      \n\t{ 28, 0x0000 },      \n\n\t{ 30, 0x005F },      \n\n\t{ 32, 0x0000 },      \n\t{ 33, 0x0000 },      \n\n\t{ 40, 0x0000 },      \n\t{ 41, 0x0000 },      \n\n\t{ 47, 0x0000 },      \n\t{ 48, 0x0023 },      \n\t{ 49, 0x0000 },      \n\n\t{ 51, 0x0003 },      \n\n\t{ 56, 0x0106 },      \n\t{ 57, 0x0000 },      \n\t{ 58, 0x0000 },      \n\n\t{ 60, 0x0000 },      \n\t{ 61, 0x0000 },      \n\n\t{ 63, 0x015E },      \n\n\t{ 65, 0x0010 },      \n\n\t{ 68, 0x0003 },      \n\t{ 69, 0x0000 },      \n\n\t{ 71, 0x01FB },      \n\t{ 72, 0x0000 },      \n\n\t{ 82, 0x0000 },      \n\n\t{ 87, 0x0000 },      \n\t{ 88, 0x0000 },      \n\t{ 89, 0x0000 },      \n\t{ 90, 0x0000 },      \n\t{ 91, 0x0000 },      \n\t{ 92, 0x0000 },      \n\t{ 93, 0x0000 },      \n\n\t{ 252, 0x0001 },      \n};\n\nstruct wm8961_priv {\n\tstruct regmap *regmap;\n\tint sysclk;\n};\n\nstatic bool wm8961_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8961_SOFTWARE_RESET:\n\tcase WM8961_WRITE_SEQUENCER_7:\n\tcase WM8961_DC_SERVO_1:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8961_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8961_LEFT_INPUT_VOLUME:\n\tcase WM8961_RIGHT_INPUT_VOLUME:\n\tcase WM8961_LOUT1_VOLUME:\n\tcase WM8961_ROUT1_VOLUME:\n\tcase WM8961_CLOCKING1:\n\tcase WM8961_ADC_DAC_CONTROL_1:\n\tcase WM8961_ADC_DAC_CONTROL_2:\n\tcase WM8961_AUDIO_INTERFACE_0:\n\tcase WM8961_CLOCKING2:\n\tcase WM8961_AUDIO_INTERFACE_1:\n\tcase WM8961_LEFT_DAC_VOLUME:\n\tcase WM8961_RIGHT_DAC_VOLUME:\n\tcase WM8961_AUDIO_INTERFACE_2:\n\tcase WM8961_SOFTWARE_RESET:\n\tcase WM8961_ALC1:\n\tcase WM8961_ALC2:\n\tcase WM8961_ALC3:\n\tcase WM8961_NOISE_GATE:\n\tcase WM8961_LEFT_ADC_VOLUME:\n\tcase WM8961_RIGHT_ADC_VOLUME:\n\tcase WM8961_ADDITIONAL_CONTROL_1:\n\tcase WM8961_ADDITIONAL_CONTROL_2:\n\tcase WM8961_PWR_MGMT_1:\n\tcase WM8961_PWR_MGMT_2:\n\tcase WM8961_ADDITIONAL_CONTROL_3:\n\tcase WM8961_ANTI_POP:\n\tcase WM8961_CLOCKING_3:\n\tcase WM8961_ADCL_SIGNAL_PATH:\n\tcase WM8961_ADCR_SIGNAL_PATH:\n\tcase WM8961_LOUT2_VOLUME:\n\tcase WM8961_ROUT2_VOLUME:\n\tcase WM8961_PWR_MGMT_3:\n\tcase WM8961_ADDITIONAL_CONTROL_4:\n\tcase WM8961_CLASS_D_CONTROL_1:\n\tcase WM8961_CLASS_D_CONTROL_2:\n\tcase WM8961_CLOCKING_4:\n\tcase WM8961_DSP_SIDETONE_0:\n\tcase WM8961_DSP_SIDETONE_1:\n\tcase WM8961_DC_SERVO_0:\n\tcase WM8961_DC_SERVO_1:\n\tcase WM8961_DC_SERVO_3:\n\tcase WM8961_DC_SERVO_5:\n\tcase WM8961_ANALOGUE_PGA_BIAS:\n\tcase WM8961_ANALOGUE_HP_0:\n\tcase WM8961_ANALOGUE_HP_2:\n\tcase WM8961_CHARGE_PUMP_1:\n\tcase WM8961_CHARGE_PUMP_B:\n\tcase WM8961_WRITE_SEQUENCER_1:\n\tcase WM8961_WRITE_SEQUENCER_2:\n\tcase WM8961_WRITE_SEQUENCER_3:\n\tcase WM8961_WRITE_SEQUENCER_4:\n\tcase WM8961_WRITE_SEQUENCER_5:\n\tcase WM8961_WRITE_SEQUENCER_6:\n\tcase WM8961_WRITE_SEQUENCER_7:\n\tcase WM8961_GENERAL_TEST_1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic int wm8961_hp_event(struct snd_soc_dapm_widget *w,\n\t\t\t   struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu16 hp_reg = snd_soc_component_read(component, WM8961_ANALOGUE_HP_0);\n\tu16 cp_reg = snd_soc_component_read(component, WM8961_CHARGE_PUMP_1);\n\tu16 pwr_reg = snd_soc_component_read(component, WM8961_PWR_MGMT_2);\n\tu16 dcs_reg = snd_soc_component_read(component, WM8961_DC_SERVO_1);\n\tint timeout = 500;\n\n\tif (event & SND_SOC_DAPM_POST_PMU) {\n\t\t \n\t\thp_reg &= ~(WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT);\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\tcp_reg |= WM8961_CP_ENA;\n\t\tsnd_soc_component_write(component, WM8961_CHARGE_PUMP_1, cp_reg);\n\t\tmdelay(5);\n\n\t\t \n\t\tpwr_reg |= WM8961_LOUT1_PGA | WM8961_ROUT1_PGA;\n\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_2, pwr_reg);\n\n\t\t \n\t\thp_reg |= WM8961_HPR_ENA | WM8961_HPL_ENA;\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\thp_reg |= WM8961_HPR_ENA_DLY | WM8961_HPL_ENA_DLY;\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\tdcs_reg |=\n\t\t\tWM8961_DCS_ENA_CHAN_HPR | WM8961_DCS_TRIG_STARTUP_HPR |\n\t\t\tWM8961_DCS_ENA_CHAN_HPL | WM8961_DCS_TRIG_STARTUP_HPL;\n\t\tdev_dbg(component->dev, \"Enabling DC servo\\n\");\n\n\t\tsnd_soc_component_write(component, WM8961_DC_SERVO_1, dcs_reg);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\tdcs_reg = snd_soc_component_read(component, WM8961_DC_SERVO_1);\n\t\t} while (--timeout &&\n\t\t\t dcs_reg & (WM8961_DCS_TRIG_STARTUP_HPR |\n\t\t\t\tWM8961_DCS_TRIG_STARTUP_HPL));\n\t\tif (dcs_reg & (WM8961_DCS_TRIG_STARTUP_HPR |\n\t\t\t       WM8961_DCS_TRIG_STARTUP_HPL))\n\t\t\tdev_err(component->dev, \"DC servo timed out\\n\");\n\t\telse\n\t\t\tdev_dbg(component->dev, \"DC servo startup complete\\n\");\n\n\t\t \n\t\thp_reg |= WM8961_HPR_ENA_OUTP | WM8961_HPL_ENA_OUTP;\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\thp_reg |= WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT;\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\t}\n\n\tif (event & SND_SOC_DAPM_PRE_PMD) {\n\t\t \n\t\thp_reg &= ~(WM8961_HPR_RMV_SHORT | WM8961_HPL_RMV_SHORT);\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\thp_reg &= ~(WM8961_HPR_ENA_OUTP | WM8961_HPL_ENA_OUTP);\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\tdcs_reg &= ~(WM8961_DCS_ENA_CHAN_HPR |\n\t\t\t     WM8961_DCS_ENA_CHAN_HPL);\n\t\tsnd_soc_component_write(component, WM8961_DC_SERVO_1, dcs_reg);\n\n\t\t \n\t\thp_reg &= ~(WM8961_HPR_ENA_DLY | WM8961_HPR_ENA |\n\t\t\t    WM8961_HPL_ENA_DLY | WM8961_HPL_ENA);\n\t\tsnd_soc_component_write(component, WM8961_ANALOGUE_HP_0, hp_reg);\n\n\t\t \n\t\tpwr_reg &= ~(WM8961_LOUT1_PGA | WM8961_ROUT1_PGA);\n\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_2, pwr_reg);\n\n\t\t \n\t\tdev_dbg(component->dev, \"Disabling charge pump\\n\");\n\t\tsnd_soc_component_write(component, WM8961_CHARGE_PUMP_1,\n\t\t\t     cp_reg & ~WM8961_CP_ENA);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8961_spk_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu16 pwr_reg = snd_soc_component_read(component, WM8961_PWR_MGMT_2);\n\tu16 spk_reg = snd_soc_component_read(component, WM8961_CLASS_D_CONTROL_1);\n\n\tif (event & SND_SOC_DAPM_POST_PMU) {\n\t\t \n\t\tpwr_reg |= WM8961_SPKL_PGA | WM8961_SPKR_PGA;\n\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_2, pwr_reg);\n\n\t\t \n\t\tspk_reg |= WM8961_SPKL_ENA | WM8961_SPKR_ENA;\n\t\tsnd_soc_component_write(component, WM8961_CLASS_D_CONTROL_1, spk_reg);\n\t}\n\n\tif (event & SND_SOC_DAPM_PRE_PMD) {\n\t\t \n\t\tspk_reg &= ~(WM8961_SPKL_ENA | WM8961_SPKR_ENA);\n\t\tsnd_soc_component_write(component, WM8961_CLASS_D_CONTROL_1, spk_reg);\n\n\t\t \n\t\tpwr_reg &= ~(WM8961_SPKL_PGA | WM8961_SPKR_PGA);\n\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_2, pwr_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic const char *adc_hpf_text[] = {\n\t\"Hi-fi\", \"Voice 1\", \"Voice 2\", \"Voice 3\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(adc_hpf,\n\t\t\t    WM8961_ADC_DAC_CONTROL_2, 7, adc_hpf_text);\n\nstatic const char *dac_deemph_text[] = {\n\t\"None\", \"32kHz\", \"44.1kHz\", \"48kHz\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dac_deemph,\n\t\t\t    WM8961_ADC_DAC_CONTROL_1, 1, dac_deemph_text);\n\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(hp_sec_tlv, -700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -7200, 75, 1);\nstatic const DECLARE_TLV_DB_SCALE(sidetone_tlv, -3600, 300, 0);\nstatic const DECLARE_TLV_DB_RANGE(boost_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(0,  0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(13, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(20, 0, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(29, 0, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, -2325, 75, 0);\n\nstatic const struct snd_kcontrol_new wm8961_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Headphone Volume\", WM8961_LOUT1_VOLUME, WM8961_ROUT1_VOLUME,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_TLV(\"Headphone Secondary Volume\", WM8961_ANALOGUE_HP_2,\n\t       6, 3, 7, 0, hp_sec_tlv),\nSOC_DOUBLE_R(\"Headphone ZC Switch\", WM8961_LOUT1_VOLUME, WM8961_ROUT1_VOLUME,\n\t     7, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Speaker Volume\", WM8961_LOUT2_VOLUME, WM8961_ROUT2_VOLUME,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Speaker ZC Switch\", WM8961_LOUT2_VOLUME, WM8961_ROUT2_VOLUME,\n\t   7, 1, 0),\nSOC_SINGLE(\"Speaker AC Gain\", WM8961_CLASS_D_CONTROL_2, 0, 7, 0),\n\nSOC_SINGLE(\"DAC x128 OSR Switch\", WM8961_ADC_DAC_CONTROL_2, 0, 1, 0),\nSOC_ENUM(\"DAC Deemphasis\", dac_deemph),\nSOC_SINGLE(\"DAC Soft Mute Switch\", WM8961_ADC_DAC_CONTROL_2, 3, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Sidetone Volume\", WM8961_DSP_SIDETONE_0,\n\t\t WM8961_DSP_SIDETONE_1, 4, 12, 0, sidetone_tlv),\n\nSOC_SINGLE(\"ADC High Pass Filter Switch\", WM8961_ADC_DAC_CONTROL_1, 0, 1, 0),\nSOC_ENUM(\"ADC High Pass Filter Mode\", adc_hpf),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\",\n\t\t WM8961_LEFT_ADC_VOLUME, WM8961_RIGHT_ADC_VOLUME,\n\t\t 1, 119, 0, adc_tlv),\nSOC_DOUBLE_R_TLV(\"Capture Boost Volume\",\n\t\t WM8961_ADCL_SIGNAL_PATH, WM8961_ADCR_SIGNAL_PATH,\n\t\t 4, 3, 0, boost_tlv),\nSOC_DOUBLE_R_TLV(\"Capture PGA Volume\",\n\t\t WM8961_LEFT_INPUT_VOLUME, WM8961_RIGHT_INPUT_VOLUME,\n\t\t 0, 62, 0, pga_tlv),\nSOC_DOUBLE_R(\"Capture PGA ZC Switch\",\n\t     WM8961_LEFT_INPUT_VOLUME, WM8961_RIGHT_INPUT_VOLUME,\n\t     6, 1, 1),\nSOC_DOUBLE_R(\"Capture PGA Switch\",\n\t     WM8961_LEFT_INPUT_VOLUME, WM8961_RIGHT_INPUT_VOLUME,\n\t     7, 1, 1),\n};\n\nstatic const char *sidetone_text[] = {\n\t\"None\", \"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dacl_sidetone,\n\t\t\t    WM8961_DSP_SIDETONE_0, 2, sidetone_text);\n\nstatic SOC_ENUM_SINGLE_DECL(dacr_sidetone,\n\t\t\t    WM8961_DSP_SIDETONE_1, 2, sidetone_text);\n\nstatic const struct snd_kcontrol_new dacl_mux =\n\tSOC_DAPM_ENUM(\"DACL Sidetone\", dacl_sidetone);\n\nstatic const struct snd_kcontrol_new dacr_mux =\n\tSOC_DAPM_ENUM(\"DACR Sidetone\", dacr_sidetone);\n\nstatic const struct snd_soc_dapm_widget wm8961_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"LINPUT\"),\nSND_SOC_DAPM_INPUT(\"RINPUT\"),\n\nSND_SOC_DAPM_SUPPLY(\"CLK_DSP\", WM8961_CLOCKING2, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"Left Input\", WM8961_PWR_MGMT_1, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Input\", WM8961_PWR_MGMT_1, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_ADC(\"ADCL\", \"HiFi Capture\", WM8961_PWR_MGMT_1, 3, 0),\nSND_SOC_DAPM_ADC(\"ADCR\", \"HiFi Capture\", WM8961_PWR_MGMT_1, 2, 0),\n\nSND_SOC_DAPM_SUPPLY(\"MICBIAS\", WM8961_PWR_MGMT_1, 1, 0, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"DACL Sidetone\", SND_SOC_NOPM, 0, 0, &dacl_mux),\nSND_SOC_DAPM_MUX(\"DACR Sidetone\", SND_SOC_NOPM, 0, 0, &dacr_mux),\n\nSND_SOC_DAPM_DAC(\"DACL\", \"HiFi Playback\", WM8961_PWR_MGMT_2, 8, 0),\nSND_SOC_DAPM_DAC(\"DACR\", \"HiFi Playback\", WM8961_PWR_MGMT_2, 7, 0),\n\n \nSND_SOC_DAPM_PGA_E(\"Headphone Output\", SND_SOC_NOPM,\n\t\t   4, 0, NULL, 0, wm8961_hp_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\nSND_SOC_DAPM_PGA_E(\"Speaker Output\", SND_SOC_NOPM,\n\t\t   4, 0, NULL, 0, wm8961_spk_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\nSND_SOC_DAPM_OUTPUT(\"HP_L\"),\nSND_SOC_DAPM_OUTPUT(\"HP_R\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_LN\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_LP\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_RN\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_RP\"),\n};\n\n\nstatic const struct snd_soc_dapm_route audio_paths[] = {\n\t{ \"DACL\", NULL, \"CLK_DSP\" },\n\t{ \"DACL\", NULL, \"DACL Sidetone\" },\n\t{ \"DACR\", NULL, \"CLK_DSP\" },\n\t{ \"DACR\", NULL, \"DACR Sidetone\" },\n\n\t{ \"DACL Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACL Sidetone\", \"Right\", \"ADCR\" },\n\n\t{ \"DACR Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"DACR Sidetone\", \"Right\", \"ADCR\" },\n\n\t{ \"HP_L\", NULL, \"Headphone Output\" },\n\t{ \"HP_R\", NULL, \"Headphone Output\" },\n\t{ \"Headphone Output\", NULL, \"DACL\" },\n\t{ \"Headphone Output\", NULL, \"DACR\" },\n\n\t{ \"SPK_LN\", NULL, \"Speaker Output\" },\n\t{ \"SPK_LP\", NULL, \"Speaker Output\" },\n\t{ \"SPK_RN\", NULL, \"Speaker Output\" },\n\t{ \"SPK_RP\", NULL, \"Speaker Output\" },\n\n\t{ \"Speaker Output\", NULL, \"DACL\" },\n\t{ \"Speaker Output\", NULL, \"DACR\" },\n\n\t{ \"ADCL\", NULL, \"Left Input\" },\n\t{ \"ADCL\", NULL, \"CLK_DSP\" },\n\t{ \"ADCR\", NULL, \"Right Input\" },\n\t{ \"ADCR\", NULL, \"CLK_DSP\" },\n\n\t{ \"Left Input\", NULL, \"LINPUT\" },\n\t{ \"Right Input\", NULL, \"RINPUT\" },\n\n};\n\n \nstatic struct {\n\tint ratio;\n\tu16 val;\n} wm8961_clk_sys_ratio[] = {\n\t{  64,  0 },\n\t{  128, 1 },\n\t{  192, 2 },\n\t{  256, 3 },\n\t{  384, 4 },\n\t{  512, 5 },\n\t{  768, 6 },\n\t{ 1024, 7 },\n\t{ 1408, 8 },\n\t{ 1536, 9 },\n};\n\n \nstatic struct {\n\tint rate;\n\tu16 val;\n} wm8961_srate[] = {\n\t{ 48000, 0 },\n\t{ 44100, 0 },\n\t{ 32000, 1 },\n\t{ 22050, 2 },\n\t{ 24000, 2 },\n\t{ 16000, 3 },\n\t{ 11250, 4 },\n\t{ 12000, 4 },\n\t{  8000, 5 },\n};\n\nstatic int wm8961_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8961_priv *wm8961 = snd_soc_component_get_drvdata(component);\n\tint i, best, target, fs;\n\tu16 reg;\n\n\tfs = params_rate(params);\n\n\tif (!wm8961->sysclk) {\n\t\tdev_err(component->dev, \"MCLK has not been specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tbest = 0;\n\tfor (i = 0; i < ARRAY_SIZE(wm8961_srate); i++) {\n\t\tif (abs(wm8961_srate[i].rate - fs) <\n\t\t    abs(wm8961_srate[best].rate - fs))\n\t\t\tbest = i;\n\t}\n\treg = snd_soc_component_read(component, WM8961_ADDITIONAL_CONTROL_3);\n\treg &= ~WM8961_SAMPLE_RATE_MASK;\n\treg |= wm8961_srate[best].val;\n\tsnd_soc_component_write(component, WM8961_ADDITIONAL_CONTROL_3, reg);\n\tdev_dbg(component->dev, \"Selected SRATE %dHz for %dHz\\n\",\n\t\twm8961_srate[best].rate, fs);\n\n\t \n\ttarget = wm8961->sysclk / fs;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && target < 64) {\n\t\tdev_err(component->dev,\n\t\t\t\"SYSCLK must be at least 64*fs for DAC\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE && target < 256) {\n\t\tdev_err(component->dev,\n\t\t\t\"SYSCLK must be at least 256*fs for ADC\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8961_clk_sys_ratio); i++) {\n\t\tif (wm8961_clk_sys_ratio[i].ratio >= target)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(wm8961_clk_sys_ratio)) {\n\t\tdev_err(component->dev, \"Unable to generate CLK_SYS_RATE\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(component->dev, \"Selected CLK_SYS_RATE of %d for %d/%d=%d\\n\",\n\t\twm8961_clk_sys_ratio[i].ratio, wm8961->sysclk, fs,\n\t\twm8961->sysclk / fs);\n\n\treg = snd_soc_component_read(component, WM8961_CLOCKING_4);\n\treg &= ~WM8961_CLK_SYS_RATE_MASK;\n\treg |= wm8961_clk_sys_ratio[i].val << WM8961_CLK_SYS_RATE_SHIFT;\n\tsnd_soc_component_write(component, WM8961_CLOCKING_4, reg);\n\n\treg = snd_soc_component_read(component, WM8961_AUDIO_INTERFACE_0);\n\treg &= ~WM8961_WL_MASK;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\treg |= 1 << WM8961_WL_SHIFT;\n\t\tbreak;\n\tcase 24:\n\t\treg |= 2 << WM8961_WL_SHIFT;\n\t\tbreak;\n\tcase 32:\n\t\treg |= 3 << WM8961_WL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_write(component, WM8961_AUDIO_INTERFACE_0, reg);\n\n\t \n\treg = snd_soc_component_read(component, WM8961_ADC_DAC_CONTROL_2);\n\tif (fs <= 24000)\n\t\treg |= WM8961_DACSLOPE;\n\telse\n\t\treg &= ~WM8961_DACSLOPE;\n\tsnd_soc_component_write(component, WM8961_ADC_DAC_CONTROL_2, reg);\n\n\treturn 0;\n}\n\nstatic int wm8961_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq,\n\t\t\t     int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8961_priv *wm8961 = snd_soc_component_get_drvdata(component);\n\tu16 reg = snd_soc_component_read(component, WM8961_CLOCKING1);\n\n\tif (freq > 33000000) {\n\t\tdev_err(component->dev, \"MCLK must be <33MHz\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (freq > 16500000) {\n\t\tdev_dbg(component->dev, \"Using MCLK/2 for %dHz MCLK\\n\", freq);\n\t\treg |= WM8961_MCLKDIV;\n\t\tfreq /= 2;\n\t} else {\n\t\tdev_dbg(component->dev, \"Using MCLK/1 for %dHz MCLK\\n\", freq);\n\t\treg &= ~WM8961_MCLKDIV;\n\t}\n\n\tsnd_soc_component_write(component, WM8961_CLOCKING1, reg);\n\n\twm8961->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int wm8961_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 aif = snd_soc_component_read(component, WM8961_AUDIO_INTERFACE_0);\n\n\taif &= ~(WM8961_BCLKINV | WM8961_LRP |\n\t\t WM8961_MS | WM8961_FORMAT_MASK);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif |= WM8961_MS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif |= 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif |= 2;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif |= WM8961_LRP;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif |= 3;\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\taif |= WM8961_LRP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\taif |= WM8961_BCLKINV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\taif |= WM8961_BCLKINV | WM8961_LRP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_component_write(component, WM8961_AUDIO_INTERFACE_0, aif);\n}\n\nstatic int wm8961_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 reg = snd_soc_component_read(component, WM8961_ADDITIONAL_CONTROL_2);\n\n\tif (tristate)\n\t\treg |= WM8961_TRIS;\n\telse\n\t\treg &= ~WM8961_TRIS;\n\n\treturn snd_soc_component_write(component, WM8961_ADDITIONAL_CONTROL_2, reg);\n}\n\nstatic int wm8961_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 reg = snd_soc_component_read(component, WM8961_ADC_DAC_CONTROL_1);\n\n\tif (mute)\n\t\treg |= WM8961_DACMU;\n\telse\n\t\treg &= ~WM8961_DACMU;\n\n\tmsleep(17);\n\n\treturn snd_soc_component_write(component, WM8961_ADC_DAC_CONTROL_1, reg);\n}\n\nstatic int wm8961_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 reg;\n\n\tswitch (div_id) {\n\tcase WM8961_BCLK:\n\t\treg = snd_soc_component_read(component, WM8961_CLOCKING2);\n\t\treg &= ~WM8961_BCLKDIV_MASK;\n\t\treg |= div;\n\t\tsnd_soc_component_write(component, WM8961_CLOCKING2, reg);\n\t\tbreak;\n\n\tcase WM8961_LRCLK:\n\t\treg = snd_soc_component_read(component, WM8961_AUDIO_INTERFACE_2);\n\t\treg &= ~WM8961_LRCLK_RATE_MASK;\n\t\treg |= div;\n\t\tsnd_soc_component_write(component, WM8961_AUDIO_INTERFACE_2, reg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8961_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tu16 reg;\n\n\t \n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY) {\n\t\t\t \n\t\t\treg = snd_soc_component_read(component, WM8961_ANTI_POP);\n\t\t\treg |= WM8961_BUFIOEN | WM8961_BUFDCOPEN;\n\t\t\tsnd_soc_component_write(component, WM8961_ANTI_POP, reg);\n\n\t\t\t \n\t\t\treg = snd_soc_component_read(component, WM8961_PWR_MGMT_1);\n\t\t\treg &= ~WM8961_VMIDSEL_MASK;\n\t\t\treg |= (1 << WM8961_VMIDSEL_SHIFT) | WM8961_VREF;\n\t\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_1, reg);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE) {\n\t\t\t \n\t\t\treg = snd_soc_component_read(component, WM8961_PWR_MGMT_1);\n\t\t\treg &= ~WM8961_VREF;\n\t\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_1, reg);\n\n\t\t\t \n\t\t\treg = snd_soc_component_read(component, WM8961_ANTI_POP);\n\t\t\treg &= ~(WM8961_BUFIOEN | WM8961_BUFDCOPEN);\n\t\t\tsnd_soc_component_write(component, WM8961_ANTI_POP, reg);\n\n\t\t\t \n\t\t\treg = snd_soc_component_read(component, WM8961_PWR_MGMT_1);\n\t\t\treg &= ~WM8961_VMIDSEL_MASK;\n\t\t\tsnd_soc_component_write(component, WM8961_PWR_MGMT_1, reg);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\n#define WM8961_RATES SNDRV_PCM_RATE_8000_48000\n\n#define WM8961_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8961_dai_ops = {\n\t.hw_params = wm8961_hw_params,\n\t.set_sysclk = wm8961_set_sysclk,\n\t.set_fmt = wm8961_set_fmt,\n\t.mute_stream = wm8961_mute,\n\t.set_tristate = wm8961_set_tristate,\n\t.set_clkdiv = wm8961_set_clkdiv,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8961_dai = {\n\t.name = \"wm8961-hifi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8961_RATES,\n\t\t.formats = WM8961_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8961_RATES,\n\t\t.formats = WM8961_FORMATS,},\n\t.ops = &wm8961_dai_ops,\n};\n\nstatic int wm8961_probe(struct snd_soc_component *component)\n{\n\tu16 reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8961_CHARGE_PUMP_B);\n\treg |= WM8961_CP_DYN_PWR_MASK;\n\tsnd_soc_component_write(component, WM8961_CHARGE_PUMP_B, reg);\n\n\t \n\treg = snd_soc_component_read(component, WM8961_ROUT1_VOLUME);\n\tsnd_soc_component_write(component, WM8961_ROUT1_VOLUME,\n\t\t     reg | WM8961_LO1ZC | WM8961_OUT1VU);\n\tsnd_soc_component_write(component, WM8961_LOUT1_VOLUME, reg | WM8961_LO1ZC);\n\treg = snd_soc_component_read(component, WM8961_ROUT2_VOLUME);\n\tsnd_soc_component_write(component, WM8961_ROUT2_VOLUME,\n\t\t     reg | WM8961_SPKRZC | WM8961_SPKVU);\n\tsnd_soc_component_write(component, WM8961_LOUT2_VOLUME, reg | WM8961_SPKLZC);\n\n\treg = snd_soc_component_read(component, WM8961_RIGHT_ADC_VOLUME);\n\tsnd_soc_component_write(component, WM8961_RIGHT_ADC_VOLUME, reg | WM8961_ADCVU);\n\treg = snd_soc_component_read(component, WM8961_RIGHT_INPUT_VOLUME);\n\tsnd_soc_component_write(component, WM8961_RIGHT_INPUT_VOLUME, reg | WM8961_IPVU);\n\n\t \n\treg = snd_soc_component_read(component, WM8961_ADC_DAC_CONTROL_2);\n\treg |= WM8961_DACSMM;\n\tsnd_soc_component_write(component, WM8961_ADC_DAC_CONTROL_2, reg);\n\n\t \n\treg = snd_soc_component_read(component, WM8961_CLOCKING_3);\n\treg &= ~WM8961_MANUAL_MODE;\n\tsnd_soc_component_write(component, WM8961_CLOCKING_3, reg);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic int wm8961_resume(struct snd_soc_component *component)\n{\n\tsnd_soc_component_cache_sync(component);\n\n\treturn 0;\n}\n#else\n#define wm8961_resume NULL\n#endif\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8961 = {\n\t.probe\t\t\t= wm8961_probe,\n\t.resume\t\t\t= wm8961_resume,\n\t.set_bias_level\t\t= wm8961_set_bias_level,\n\t.controls\t\t= wm8961_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8961_snd_controls),\n\t.dapm_widgets\t\t= wm8961_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8961_dapm_widgets),\n\t.dapm_routes\t\t= audio_paths,\n\t.num_dapm_routes\t= ARRAY_SIZE(audio_paths),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8961_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = WM8961_MAX_REGISTER,\n\n\t.reg_defaults = wm8961_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8961_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8961_volatile,\n\t.readable_reg = wm8961_readable,\n};\n\nstatic int wm8961_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8961_priv *wm8961;\n\tunsigned int val;\n\tint ret;\n\n\twm8961 = devm_kzalloc(&i2c->dev, sizeof(struct wm8961_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8961 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8961->regmap = devm_regmap_init_i2c(i2c, &wm8961_regmap);\n\tif (IS_ERR(wm8961->regmap))\n\t\treturn PTR_ERR(wm8961->regmap);\n\n\tret = regmap_read(wm8961->regmap, WM8961_SOFTWARE_RESET, &val);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val != 0x1801) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM8961: ID=0x%x\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregcache_cache_bypass(wm8961->regmap, true);\n\tret = regmap_read(wm8961->regmap, WM8961_RIGHT_INPUT_VOLUME, &val);\n\tregcache_cache_bypass(wm8961->regmap, false);\n\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip revision: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_info(&i2c->dev, \"WM8961 family %d revision %c\\n\",\n\t\t (val & WM8961_DEVICE_ID_MASK) >> WM8961_DEVICE_ID_SHIFT,\n\t\t ((val & WM8961_CHIP_REV_MASK) >> WM8961_CHIP_REV_SHIFT)\n\t\t + 'A');\n\n\tret = regmap_write(wm8961->regmap, WM8961_SOFTWARE_RESET, 0x1801);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8961);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8961, &wm8961_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8961_i2c_id[] = {\n\t{ \"wm8961\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8961_i2c_id);\n\nstatic const struct of_device_id wm8961_of_match[] __maybe_unused = {\n\t{ .compatible = \"wlf,wm8961\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8961_of_match);\n\nstatic struct i2c_driver wm8961_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8961\",\n\t\t.of_match_table = of_match_ptr(wm8961_of_match),\n\t},\n\t.probe = wm8961_i2c_probe,\n\t.id_table = wm8961_i2c_id,\n};\n\nmodule_i2c_driver(wm8961_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8961 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}