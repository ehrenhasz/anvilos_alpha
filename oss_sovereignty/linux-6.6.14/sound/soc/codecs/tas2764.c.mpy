{
  "module_name": "tas2764.c",
  "hash_id": "bd990505dfb319085cef1a03d5ab2832accf0cfe7c01b9b3e72cd503fc6b50ed",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas2764.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regmap.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"tas2764.h\"\n\nstruct tas2764_priv {\n\tstruct snd_soc_component *component;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *sdz_gpio;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tint irq;\n\t\n\tint v_sense_slot;\n\tint i_sense_slot;\n\n\tbool dac_powered;\n\tbool unmuted;\n};\n\nstatic const char *tas2764_int_ltch0_msgs[8] = {\n\t\"fault: over temperature\",  \n\t\"fault: over current\",\n\t\"fault: bad TDM clock\",\n\t\"limiter active\",\n\t\"fault: PVDD below limiter inflection point\",\n\t\"fault: limiter max attenuation\",\n\t\"fault: BOP infinite hold\",\n\t\"fault: BOP mute\",  \n};\n\nstatic const unsigned int tas2764_int_readout_regs[6] = {\n\tTAS2764_INT_LTCH0,\n\tTAS2764_INT_LTCH1,\n\tTAS2764_INT_LTCH1_0,\n\tTAS2764_INT_LTCH2,\n\tTAS2764_INT_LTCH3,\n\tTAS2764_INT_LTCH4,\n};\n\nstatic irqreturn_t tas2764_irq(int irq, void *data)\n{\n\tstruct tas2764_priv *tas2764 = data;\n\tu8 latched[6] = {0, 0, 0, 0, 0, 0};\n\tint ret = IRQ_NONE;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(latched); i++)\n\t\tlatched[i] = snd_soc_component_read(tas2764->component,\n\t\t\t\t\t\t    tas2764_int_readout_regs[i]);\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (latched[0] & BIT(i)) {\n\t\t\tdev_crit_ratelimited(tas2764->dev, \"%s\\n\",\n\t\t\t\t\t     tas2764_int_ltch0_msgs[i]);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t}\n\n\tif (latched[0]) {\n\t\tdev_err_ratelimited(tas2764->dev, \"other context to the fault: %02x,%02x,%02x,%02x,%02x\",\n\t\t\t\t    latched[1], latched[2], latched[3], latched[4], latched[5]);\n\t\tsnd_soc_component_update_bits(tas2764->component,\n\t\t\t\t\t      TAS2764_INT_CLK_CFG,\n\t\t\t\t\t      TAS2764_INT_CLK_CFG_IRQZ_CLR,\n\t\t\t\t\t      TAS2764_INT_CLK_CFG_IRQZ_CLR);\n\t}\n\n\treturn ret;\n}\n\nstatic void tas2764_reset(struct tas2764_priv *tas2764)\n{\n\tif (tas2764->reset_gpio) {\n\t\tgpiod_set_value_cansleep(tas2764->reset_gpio, 0);\n\t\tmsleep(20);\n\t\tgpiod_set_value_cansleep(tas2764->reset_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tsnd_soc_component_write(tas2764->component, TAS2764_SW_RST,\n\t\t\t\tTAS2764_RST);\n\tusleep_range(1000, 2000);\n}\n\nstatic int tas2764_update_pwr_ctrl(struct tas2764_priv *tas2764)\n{\n\tstruct snd_soc_component *component = tas2764->component;\n\tunsigned int val;\n\tint ret;\n\n\tif (tas2764->dac_powered)\n\t\tval = tas2764->unmuted ?\n\t\t\tTAS2764_PWR_CTRL_ACTIVE : TAS2764_PWR_CTRL_MUTE;\n\telse\n\t\tval = TAS2764_PWR_CTRL_SHUTDOWN;\n\n\tret = snd_soc_component_update_bits(component, TAS2764_PWR_CTRL,\n\t\t\t\t\t    TAS2764_PWR_CTRL_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int tas2764_codec_suspend(struct snd_soc_component *component)\n{\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2764_PWR_CTRL,\n\t\t\t\t\t    TAS2764_PWR_CTRL_MASK,\n\t\t\t\t\t    TAS2764_PWR_CTRL_SHUTDOWN);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tas2764->sdz_gpio)\n\t\tgpiod_set_value_cansleep(tas2764->sdz_gpio, 0);\n\n\tregcache_cache_only(tas2764->regmap, true);\n\tregcache_mark_dirty(tas2764->regmap);\n\n\treturn 0;\n}\n\nstatic int tas2764_codec_resume(struct snd_soc_component *component)\n{\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (tas2764->sdz_gpio) {\n\t\tgpiod_set_value_cansleep(tas2764->sdz_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tret = tas2764_update_pwr_ctrl(tas2764);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_cache_only(tas2764->regmap, false);\n\n\treturn regcache_sync(tas2764->regmap);\n}\n#else\n#define tas2764_codec_suspend NULL\n#define tas2764_codec_resume NULL\n#endif\n\nstatic const char * const tas2764_ASI1_src[] = {\n\t\"I2C offset\", \"Left\", \"Right\", \"LeftRightDiv2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\ttas2764_ASI1_src_enum, TAS2764_TDM_CFG2, TAS2764_TDM_CFG2_SCFG_SHIFT,\n\ttas2764_ASI1_src);\n\nstatic const struct snd_kcontrol_new tas2764_asi1_mux =\n\tSOC_DAPM_ENUM(\"ASI1 Source\", tas2764_ASI1_src_enum);\n\nstatic int tas2764_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\ttas2764->dac_powered = true;\n\t\tret = tas2764_update_pwr_ctrl(tas2764);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\ttas2764->dac_powered = false;\n\t\tret = tas2764_update_pwr_ctrl(tas2764);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2764->dev, \"Unsupported event\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new isense_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", TAS2764_PWR_CTRL, TAS2764_ISENSE_POWER_EN, 1, 1);\nstatic const struct snd_kcontrol_new vsense_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", TAS2764_PWR_CTRL, TAS2764_VSENSE_POWER_EN, 1, 1);\n\nstatic const struct snd_soc_dapm_widget tas2764_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"ASI1\", \"ASI1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"ASI1 Sel\", SND_SOC_NOPM, 0, 0, &tas2764_asi1_mux),\n\tSND_SOC_DAPM_SWITCH(\"ISENSE\", TAS2764_PWR_CTRL, TAS2764_ISENSE_POWER_EN,\n\t\t\t    1, &isense_switch),\n\tSND_SOC_DAPM_SWITCH(\"VSENSE\", TAS2764_PWR_CTRL, TAS2764_VSENSE_POWER_EN,\n\t\t\t    1, &vsense_switch),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0, tas2764_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n\tSND_SOC_DAPM_SIGGEN(\"VMON\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON\")\n};\n\nstatic const struct snd_soc_dapm_route tas2764_audio_map[] = {\n\t{\"ASI1 Sel\", \"I2C offset\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Left\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"Right\", \"ASI1\"},\n\t{\"ASI1 Sel\", \"LeftRightDiv2\", \"ASI1\"},\n\t{\"DAC\", NULL, \"ASI1 Sel\"},\n\t{\"OUT\", NULL, \"DAC\"},\n\t{\"ISENSE\", \"Switch\", \"IMON\"},\n\t{\"VSENSE\", \"Switch\", \"VMON\"},\n};\n\nstatic int tas2764_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct tas2764_priv *tas2764 =\n\t\t\tsnd_soc_component_get_drvdata(dai->component);\n\n\ttas2764->unmuted = !mute;\n\treturn tas2764_update_pwr_ctrl(tas2764);\n}\n\nstatic int tas2764_set_bitwidth(struct tas2764_priv *tas2764, int bitwidth)\n{\n\tstruct snd_soc_component *component = tas2764->component;\n\tint sense_en;\n\tint val;\n\tint ret;\n\n\tswitch (bitwidth) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_MASK,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_16BITS);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_MASK,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_24BITS);\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_MASK,\n\t\t\t\t\t\t    TAS2764_TDM_CFG2_RXW_32BITS);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = snd_soc_component_read(tas2764->component, TAS2764_PWR_CTRL);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & (1 << TAS2764_VSENSE_POWER_EN))\n\t\tsense_en = 0;\n\telse\n\t\tsense_en = TAS2764_TDM_CFG5_VSNS_ENABLE;\n\n\tret = snd_soc_component_update_bits(tas2764->component, TAS2764_TDM_CFG5,\n\t\t\t\t\t    TAS2764_TDM_CFG5_VSNS_ENABLE,\n\t\t\t\t\t    sense_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val & (1 << TAS2764_ISENSE_POWER_EN))\n\t\tsense_en = 0;\n\telse\n\t\tsense_en = TAS2764_TDM_CFG6_ISNS_ENABLE;\n\n\tret = snd_soc_component_update_bits(tas2764->component, TAS2764_TDM_CFG6,\n\t\t\t\t\t    TAS2764_TDM_CFG6_ISNS_ENABLE,\n\t\t\t\t\t    sense_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2764_set_samplerate(struct tas2764_priv *tas2764, int samplerate)\n{\n\tstruct snd_soc_component *component = tas2764->component;\n\tint ramp_rate_val;\n\tint ret;\n\n\tswitch (samplerate) {\n\tcase 48000:\n\t\tramp_rate_val = TAS2764_TDM_CFG0_SMP_48KHZ |\n\t\t\t\tTAS2764_TDM_CFG0_44_1_48KHZ;\n\t\tbreak;\n\tcase 44100:\n\t\tramp_rate_val = TAS2764_TDM_CFG0_SMP_44_1KHZ |\n\t\t\t\tTAS2764_TDM_CFG0_44_1_48KHZ;\n\t\tbreak;\n\tcase 96000:\n\t\tramp_rate_val = TAS2764_TDM_CFG0_SMP_48KHZ |\n\t\t\t\tTAS2764_TDM_CFG0_88_2_96KHZ;\n\t\tbreak;\n\tcase 88200:\n\t\tramp_rate_val = TAS2764_TDM_CFG0_SMP_44_1KHZ |\n\t\t\t\tTAS2764_TDM_CFG0_88_2_96KHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG0,\n\t\t\t\t\t    TAS2764_TDM_CFG0_SMP_MASK |\n\t\t\t\t\t    TAS2764_TDM_CFG0_MASK,\n\t\t\t\t\t    ramp_rate_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2764_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = tas2764_set_bitwidth(tas2764, params_format(params));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn tas2764_set_samplerate(tas2764, params_rate(params));\n}\n\nstatic int tas2764_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tu8 tdm_rx_start_slot = 0, asi_cfg_0 = 0, asi_cfg_1 = 0;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tasi_cfg_0 ^= TAS2764_TDM_CFG0_FRAME_START;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tasi_cfg_1 = TAS2764_TDM_CFG1_RX_RISING;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tasi_cfg_0 ^= TAS2764_TDM_CFG0_FRAME_START;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tasi_cfg_1 = TAS2764_TDM_CFG1_RX_FALLING;\n\t\tbreak;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG1,\n\t\t\t\t\t    TAS2764_TDM_CFG1_RX_MASK,\n\t\t\t\t\t    asi_cfg_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tasi_cfg_0 ^= TAS2764_TDM_CFG0_FRAME_START;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\ttdm_rx_start_slot = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\ttdm_rx_start_slot = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(tas2764->dev,\n\t\t\t\"DAI Format is not found, fmt=0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG0,\n\t\t\t\t\t    TAS2764_TDM_CFG0_FRAME_START,\n\t\t\t\t\t    asi_cfg_0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG1,\n\t\t\t\t\t    TAS2764_TDM_CFG1_MASK,\n\t\t\t\t\t    (tdm_rx_start_slot << TAS2764_TDM_CFG1_51_SHIFT));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tas2764_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask,\n\t\t\t\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint left_slot, right_slot;\n\tint slots_cfg;\n\tint slot_size;\n\tint ret;\n\n\tif (tx_mask == 0 || rx_mask != 0)\n\t\treturn -EINVAL;\n\n\tleft_slot = __ffs(tx_mask);\n\ttx_mask &= ~(1 << left_slot);\n\tif (tx_mask == 0) {\n\t\tright_slot = left_slot;\n\t} else {\n\t\tright_slot = __ffs(tx_mask);\n\t\ttx_mask &= ~(1 << right_slot);\n\t}\n\n\tif (tx_mask != 0 || left_slot >= slots || right_slot >= slots)\n\t\treturn -EINVAL;\n\n\tslots_cfg = (right_slot << TAS2764_TDM_CFG3_RXS_SHIFT) | left_slot;\n\n\tret = snd_soc_component_write(component, TAS2764_TDM_CFG3, slots_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tslot_size = TAS2764_TDM_CFG2_RXS_16BITS;\n\t\tbreak;\n\tcase 24:\n\t\tslot_size = TAS2764_TDM_CFG2_RXS_24BITS;\n\t\tbreak;\n\tcase 32:\n\t\tslot_size = TAS2764_TDM_CFG2_RXS_32BITS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG2,\n\t\t\t\t\t    TAS2764_TDM_CFG2_RXS_MASK,\n\t\t\t\t\t    slot_size);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG5,\n\t\t\t\t\t    TAS2764_TDM_CFG5_50_MASK,\n\t\t\t\t\t    tas2764->v_sense_slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, TAS2764_TDM_CFG6,\n\t\t\t\t\t    TAS2764_TDM_CFG6_50_MASK,\n\t\t\t\t\t    tas2764->i_sense_slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops tas2764_dai_ops = {\n\t.mute_stream = tas2764_mute,\n\t.hw_params  = tas2764_hw_params,\n\t.set_fmt    = tas2764_set_fmt,\n\t.set_tdm_slot = tas2764_set_dai_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\n#define TAS2764_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\n#define TAS2764_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\\\n\t\t       SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_88200)\n\nstatic struct snd_soc_dai_driver tas2764_dai_driver[] = {\n\t{\n\t\t.name = \"tas2764 ASI1\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name    = \"ASI1 Playback\",\n\t\t\t.channels_min   = 1,\n\t\t\t.channels_max   = 2,\n\t\t\t.rates      = TAS2764_RATES,\n\t\t\t.formats    = TAS2764_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name    = \"ASI1 Capture\",\n\t\t\t.channels_min   = 0,\n\t\t\t.channels_max   = 2,\n\t\t\t.rates = TAS2764_RATES,\n\t\t\t.formats = TAS2764_FORMATS,\n\t\t},\n\t\t.ops = &tas2764_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic int tas2764_codec_probe(struct snd_soc_component *component)\n{\n\tstruct tas2764_priv *tas2764 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\ttas2764->component = component;\n\n\tif (tas2764->sdz_gpio) {\n\t\tgpiod_set_value_cansleep(tas2764->sdz_gpio, 1);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\ttas2764_reset(tas2764);\n\n\tif (tas2764->irq) {\n\t\tret = snd_soc_component_write(tas2764->component, TAS2764_INT_MASK0, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_component_write(tas2764->component, TAS2764_INT_MASK1, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_component_write(tas2764->component, TAS2764_INT_MASK2, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_component_write(tas2764->component, TAS2764_INT_MASK3, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_component_write(tas2764->component, TAS2764_INT_MASK4, 0xff);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_request_threaded_irq(tas2764->dev, tas2764->irq, NULL, tas2764_irq,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | IRQF_TRIGGER_LOW,\n\t\t\t\t\t\t\"tas2764\", tas2764);\n\t\tif (ret)\n\t\t\tdev_warn(tas2764->dev, \"failed to request IRQ: %d\\n\", ret);\n\t}\n\n\tret = snd_soc_component_update_bits(tas2764->component, TAS2764_TDM_CFG5,\n\t\t\t\t\t    TAS2764_TDM_CFG5_VSNS_ENABLE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(tas2764->component, TAS2764_TDM_CFG6,\n\t\t\t\t\t    TAS2764_TDM_CFG6_ISNS_ENABLE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic DECLARE_TLV_DB_SCALE(tas2764_digital_tlv, 1100, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(tas2764_playback_volume, -10050, 50, 1);\n\nstatic const char * const tas2764_hpf_texts[] = {\n\t\"Disabled\", \"2 Hz\", \"50 Hz\", \"100 Hz\", \"200 Hz\",\n\t\"400 Hz\", \"800 Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\ttas2764_hpf_enum, TAS2764_DC_BLK0,\n\tTAS2764_DC_BLK0_HPF_FREQ_PB_SHIFT, tas2764_hpf_texts);\n\nstatic const struct snd_kcontrol_new tas2764_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", TAS2764_DVC, 0,\n\t\t       TAS2764_DVC_MAX, 1, tas2764_playback_volume),\n\tSOC_SINGLE_TLV(\"Amp Gain Volume\", TAS2764_CHNL_0, 1, 0x14, 0,\n\t\t       tas2764_digital_tlv),\n\tSOC_ENUM(\"HPF Corner Frequency\", tas2764_hpf_enum),\n};\n\nstatic const struct snd_soc_component_driver soc_component_driver_tas2764 = {\n\t.probe\t\t\t= tas2764_codec_probe,\n\t.suspend\t\t= tas2764_codec_suspend,\n\t.resume\t\t\t= tas2764_codec_resume,\n\t.controls\t\t= tas2764_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas2764_snd_controls),\n\t.dapm_widgets\t\t= tas2764_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas2764_dapm_widgets),\n\t.dapm_routes\t\t= tas2764_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas2764_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct reg_default tas2764_reg_defaults[] = {\n\t{ TAS2764_PAGE, 0x00 },\n\t{ TAS2764_SW_RST, 0x00 },\n\t{ TAS2764_PWR_CTRL, 0x1a },\n\t{ TAS2764_DVC, 0x00 },\n\t{ TAS2764_CHNL_0, 0x28 },\n\t{ TAS2764_TDM_CFG0, 0x09 },\n\t{ TAS2764_TDM_CFG1, 0x02 },\n\t{ TAS2764_TDM_CFG2, 0x0a },\n\t{ TAS2764_TDM_CFG3, 0x10 },\n\t{ TAS2764_TDM_CFG5, 0x42 },\n};\n\nstatic const struct regmap_range_cfg tas2764_regmap_ranges[] = {\n\t{\n\t\t.range_min = 0,\n\t\t.range_max = 1 * 128,\n\t\t.selector_reg = TAS2764_PAGE,\n\t\t.selector_mask = 0xff,\n\t\t.selector_shift = 0,\n\t\t.window_start = 0,\n\t\t.window_len = 128,\n\t},\n};\n\nstatic bool tas2764_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS2764_INT_LTCH0 ... TAS2764_INT_LTCH4:\n\tcase TAS2764_INT_CLK_CFG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tas2764_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = tas2764_volatile_register,\n\t.reg_defaults = tas2764_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(tas2764_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n\t.ranges = tas2764_regmap_ranges,\n\t.num_ranges = ARRAY_SIZE(tas2764_regmap_ranges),\n\t.max_register = 1 * 128,\n};\n\nstatic int tas2764_parse_dt(struct device *dev, struct tas2764_priv *tas2764)\n{\n\tint ret = 0;\n\n\ttas2764->reset_gpio = devm_gpiod_get_optional(tas2764->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_HIGH);\n\tif (IS_ERR(tas2764->reset_gpio)) {\n\t\tif (PTR_ERR(tas2764->reset_gpio) == -EPROBE_DEFER) {\n\t\t\ttas2764->reset_gpio = NULL;\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t}\n\n\ttas2764->sdz_gpio = devm_gpiod_get_optional(dev, \"shutdown\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(tas2764->sdz_gpio)) {\n\t\tif (PTR_ERR(tas2764->sdz_gpio) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\n\t\ttas2764->sdz_gpio = NULL;\n\t}\n\n\tret = fwnode_property_read_u32(dev->fwnode, \"ti,imon-slot-no\",\n\t\t\t\t       &tas2764->i_sense_slot);\n\tif (ret)\n\t\ttas2764->i_sense_slot = 0;\n\n\tret = fwnode_property_read_u32(dev->fwnode, \"ti,vmon-slot-no\",\n\t\t\t\t       &tas2764->v_sense_slot);\n\tif (ret)\n\t\ttas2764->v_sense_slot = 2;\n\n\treturn 0;\n}\n\nstatic int tas2764_i2c_probe(struct i2c_client *client)\n{\n\tstruct tas2764_priv *tas2764;\n\tint result;\n\n\ttas2764 = devm_kzalloc(&client->dev, sizeof(struct tas2764_priv),\n\t\t\t       GFP_KERNEL);\n\tif (!tas2764)\n\t\treturn -ENOMEM;\n\n\ttas2764->dev = &client->dev;\n\ttas2764->irq = client->irq;\n\ti2c_set_clientdata(client, tas2764);\n\tdev_set_drvdata(&client->dev, tas2764);\n\n\ttas2764->regmap = devm_regmap_init_i2c(client, &tas2764_i2c_regmap);\n\tif (IS_ERR(tas2764->regmap)) {\n\t\tresult = PTR_ERR(tas2764->regmap);\n\t\tdev_err(&client->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\t\t\tresult);\n\t\treturn result;\n\t}\n\n\tif (client->dev.of_node) {\n\t\tresult = tas2764_parse_dt(&client->dev, tas2764);\n\t\tif (result) {\n\t\t\tdev_err(tas2764->dev, \"%s: Failed to parse devicetree\\n\",\n\t\t\t\t__func__);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn devm_snd_soc_register_component(tas2764->dev,\n\t\t\t\t\t       &soc_component_driver_tas2764,\n\t\t\t\t\t       tas2764_dai_driver,\n\t\t\t\t\t       ARRAY_SIZE(tas2764_dai_driver));\n}\n\nstatic const struct i2c_device_id tas2764_i2c_id[] = {\n\t{ \"tas2764\", 0},\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas2764_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id tas2764_of_match[] = {\n\t{ .compatible = \"ti,tas2764\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tas2764_of_match);\n#endif\n\nstatic struct i2c_driver tas2764_i2c_driver = {\n\t.driver = {\n\t\t.name   = \"tas2764\",\n\t\t.of_match_table = of_match_ptr(tas2764_of_match),\n\t},\n\t.probe      = tas2764_i2c_probe,\n\t.id_table   = tas2764_i2c_id,\n};\nmodule_i2c_driver(tas2764_i2c_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"TAS2764 I2C Smart Amplifier driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}