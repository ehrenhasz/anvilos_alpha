{
  "module_name": "wm8782.c",
  "hash_id": "8759d2da33c51c10341442b1d581b315257f36a4aa06ae9bfda9eb9eba30cbc6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8782.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/regulator/consumer.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/ac97_codec.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\nstatic const struct snd_soc_dapm_widget wm8782_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"AINL\"),\nSND_SOC_DAPM_INPUT(\"AINR\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8782_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"AINL\" },\n\t{ \"Capture\", NULL, \"AINR\" },\n};\n\nstatic struct snd_soc_dai_driver wm8782_dai = {\n\t.name = \"wm8782\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t \n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S20_3LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n};\n\n \nstatic const char *supply_names[] = {\n\t\"Vdda\",  \n\t\"Vdd\",   \n};\n\nstruct wm8782_priv {\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n};\n\nstatic int wm8782_soc_probe(struct snd_soc_component *component)\n{\n\tstruct wm8782_priv *priv = snd_soc_component_get_drvdata(component);\n\treturn regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n\nstatic void wm8782_soc_remove(struct snd_soc_component *component)\n{\n\tstruct wm8782_priv *priv = snd_soc_component_get_drvdata(component);\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n\n#ifdef CONFIG_PM\nstatic int wm8782_soc_suspend(struct snd_soc_component *component)\n{\n\tstruct wm8782_priv *priv = snd_soc_component_get_drvdata(component);\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\treturn 0;\n}\n\nstatic int wm8782_soc_resume(struct snd_soc_component *component)\n{\n\tstruct wm8782_priv *priv = snd_soc_component_get_drvdata(component);\n\treturn regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n}\n#else\n#define wm8782_soc_suspend      NULL\n#define wm8782_soc_resume       NULL\n#endif  \n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8782 = {\n\t.probe\t\t\t= wm8782_soc_probe,\n\t.remove\t\t\t= wm8782_soc_remove,\n\t.suspend\t\t= wm8782_soc_suspend,\n\t.resume\t\t\t= wm8782_soc_resume,\n\t.dapm_widgets\t\t= wm8782_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8782_dapm_widgets),\n\t.dapm_routes\t\t= wm8782_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8782_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm8782_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct wm8782_priv *priv;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_component_dev_wm8782, &wm8782_dai, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id wm8782_of_match[] = {\n\t{ .compatible = \"wlf,wm8782\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8782_of_match);\n#endif\n\nstatic struct platform_driver wm8782_codec_driver = {\n\t.driver = {\n\t\t.name = \"wm8782\",\n\t\t.of_match_table = of_match_ptr(wm8782_of_match),\n\t},\n\t.probe = wm8782_probe,\n};\n\nmodule_platform_driver(wm8782_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8782 driver\");\nMODULE_AUTHOR(\"Johannes Stezenbach <js@sig21.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}