{
  "module_name": "cs35l41.c",
  "hash_id": "1d665b046122c73ebd89a145ee6f4e593c355f7539691fb1a34c03a9dfae2994",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l41.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"cs35l41.h\"\n\nstatic const char * const cs35l41_supplies[CS35L41_NUM_SUPPLIES] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstruct cs35l41_pll_sysclk_config {\n\tint freq;\n\tint clk_cfg;\n};\n\nstatic const struct cs35l41_pll_sysclk_config cs35l41_pll_sysclk[] = {\n\t{ 32768,\t0x00 },\n\t{ 8000,\t\t0x01 },\n\t{ 11025,\t0x02 },\n\t{ 12000,\t0x03 },\n\t{ 16000,\t0x04 },\n\t{ 22050,\t0x05 },\n\t{ 24000,\t0x06 },\n\t{ 32000,\t0x07 },\n\t{ 44100,\t0x08 },\n\t{ 48000,\t0x09 },\n\t{ 88200,\t0x0A },\n\t{ 96000,\t0x0B },\n\t{ 128000,\t0x0C },\n\t{ 176400,\t0x0D },\n\t{ 192000,\t0x0E },\n\t{ 256000,\t0x0F },\n\t{ 352800,\t0x10 },\n\t{ 384000,\t0x11 },\n\t{ 512000,\t0x12 },\n\t{ 705600,\t0x13 },\n\t{ 750000,\t0x14 },\n\t{ 768000,\t0x15 },\n\t{ 1000000,\t0x16 },\n\t{ 1024000,\t0x17 },\n\t{ 1200000,\t0x18 },\n\t{ 1411200,\t0x19 },\n\t{ 1500000,\t0x1A },\n\t{ 1536000,\t0x1B },\n\t{ 2000000,\t0x1C },\n\t{ 2048000,\t0x1D },\n\t{ 2400000,\t0x1E },\n\t{ 2822400,\t0x1F },\n\t{ 3000000,\t0x20 },\n\t{ 3072000,\t0x21 },\n\t{ 3200000,\t0x22 },\n\t{ 4000000,\t0x23 },\n\t{ 4096000,\t0x24 },\n\t{ 4800000,\t0x25 },\n\t{ 5644800,\t0x26 },\n\t{ 6000000,\t0x27 },\n\t{ 6144000,\t0x28 },\n\t{ 6250000,\t0x29 },\n\t{ 6400000,\t0x2A },\n\t{ 6500000,\t0x2B },\n\t{ 6750000,\t0x2C },\n\t{ 7526400,\t0x2D },\n\t{ 8000000,\t0x2E },\n\t{ 8192000,\t0x2F },\n\t{ 9600000,\t0x30 },\n\t{ 11289600,\t0x31 },\n\t{ 12000000,\t0x32 },\n\t{ 12288000,\t0x33 },\n\t{ 12500000,\t0x34 },\n\t{ 12800000,\t0x35 },\n\t{ 13000000,\t0x36 },\n\t{ 13500000,\t0x37 },\n\t{ 19200000,\t0x38 },\n\t{ 22579200,\t0x39 },\n\t{ 24000000,\t0x3A },\n\t{ 24576000,\t0x3B },\n\t{ 25000000,\t0x3C },\n\t{ 25600000,\t0x3D },\n\t{ 26000000,\t0x3E },\n\t{ 27000000,\t0x3F },\n};\n\nstruct cs35l41_fs_mon_config {\n\tint freq;\n\tunsigned int fs1;\n\tunsigned int fs2;\n};\n\nstatic const struct cs35l41_fs_mon_config cs35l41_fs_mon[] = {\n\t{ 32768,\t2254,\t3754 },\n\t{ 8000,\t\t9220,\t15364 },\n\t{ 11025,\t6148,\t10244 },\n\t{ 12000,\t6148,\t10244 },\n\t{ 16000,\t4612,\t7684 },\n\t{ 22050,\t3076,\t5124 },\n\t{ 24000,\t3076,\t5124 },\n\t{ 32000,\t2308,\t3844 },\n\t{ 44100,\t1540,\t2564 },\n\t{ 48000,\t1540,\t2564 },\n\t{ 88200,\t772,\t1284 },\n\t{ 96000,\t772,\t1284 },\n\t{ 128000,\t580,\t964 },\n\t{ 176400,\t388,\t644 },\n\t{ 192000,\t388,\t644 },\n\t{ 256000,\t292,\t484 },\n\t{ 352800,\t196,\t324 },\n\t{ 384000,\t196,\t324 },\n\t{ 512000,\t148,\t244 },\n\t{ 705600,\t100,\t164 },\n\t{ 750000,\t100,\t164 },\n\t{ 768000,\t100,\t164 },\n\t{ 1000000,\t76,\t124 },\n\t{ 1024000,\t76,\t124 },\n\t{ 1200000,\t64,\t104 },\n\t{ 1411200,\t52,\t84 },\n\t{ 1500000,\t52,\t84 },\n\t{ 1536000,\t52,\t84 },\n\t{ 2000000,\t40,\t64 },\n\t{ 2048000,\t40,\t64 },\n\t{ 2400000,\t34,\t54 },\n\t{ 2822400,\t28,\t44 },\n\t{ 3000000,\t28,\t44 },\n\t{ 3072000,\t28,\t44 },\n\t{ 3200000,\t27,\t42 },\n\t{ 4000000,\t22,\t34 },\n\t{ 4096000,\t22,\t34 },\n\t{ 4800000,\t19,\t29 },\n\t{ 5644800,\t16,\t24 },\n\t{ 6000000,\t16,\t24 },\n\t{ 6144000,\t16,\t24 },\n\t{ 12288000,\t0,\t0 },\n};\n\nstatic int cs35l41_get_fs_mon_config_index(int freq)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l41_fs_mon); i++) {\n\t\tif (cs35l41_fs_mon[i].freq == freq)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const DECLARE_TLV_DB_RANGE(dig_vol_tlv,\n\t\t0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),\n\t\t1, 913, TLV_DB_MINMAX_ITEM(-10200, 1200));\nstatic DECLARE_TLV_DB_SCALE(amp_gain_tlv, 50, 100, 0);\n\nstatic const struct snd_kcontrol_new dre_ctrl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS35L41_PWR_CTRL3, 20, 1, 0);\n\nstatic const char * const cs35l41_pcm_sftramp_text[] =  {\n\t\"Off\", \".5ms\", \"1ms\", \"2ms\", \"4ms\", \"8ms\", \"15ms\", \"30ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(pcm_sft_ramp,\n\t\t\t    CS35L41_AMP_DIG_VOL_CTRL, 0,\n\t\t\t    cs35l41_pcm_sftramp_text);\n\nstatic int cs35l41_dsp_preload_ev(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (cs35l41->dsp.cs_dsp.booted)\n\t\t\treturn 0;\n\n\t\treturn wm_adsp_early_event(w, kcontrol, event);\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tif (cs35l41->dsp.preloaded)\n\t\t\treturn 0;\n\n\t\tif (cs35l41->dsp.cs_dsp.running) {\n\t\t\tret = wm_adsp_event(w, kcontrol, event);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\treturn wm_adsp_early_event(w, kcontrol, event);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int cs35l41_dsp_audio_ev(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\tunsigned int fw_status;\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (!cs35l41->dsp.cs_dsp.running)\n\t\t\treturn wm_adsp_event(w, kcontrol, event);\n\n\t\tret = regmap_read(cs35l41->regmap, CS35L41_DSP_MBOX_2, &fw_status);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cs35l41->dev,\n\t\t\t\t\"Failed to read firmware status: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (fw_status) {\n\t\tcase CSPL_MBOX_STS_RUNNING:\n\t\tcase CSPL_MBOX_STS_PAUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(cs35l41->dev, \"Firmware status is invalid: %u\\n\",\n\t\t\t\tfw_status);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,\n\t\t\t\t\t\t CSPL_MBOX_CMD_RESUME);\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\treturn cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,\n\t\t\t\t\t\t CSPL_MBOX_CMD_PAUSE);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const char * const cs35l41_pcm_source_texts[] = {\"ASP\", \"DSP\"};\nstatic const unsigned int cs35l41_pcm_source_values[] = {0x08, 0x32};\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_pcm_source_enum,\n\t\t\t\t  CS35L41_DAC_PCM1_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_pcm_source_texts,\n\t\t\t\t  cs35l41_pcm_source_values);\n\nstatic const struct snd_kcontrol_new pcm_source_mux =\n\tSOC_DAPM_ENUM(\"PCM Source\", cs35l41_pcm_source_enum);\n\nstatic const char * const cs35l41_tx_input_texts[] = {\n\t\"Zero\", \"ASPRX1\", \"ASPRX2\", \"VMON\", \"IMON\",\n\t\"VPMON\", \"VBSTMON\", \"DSPTX1\", \"DSPTX2\"\n};\n\nstatic const unsigned int cs35l41_tx_input_values[] = {\n\t0x00, CS35L41_INPUT_SRC_ASPRX1, CS35L41_INPUT_SRC_ASPRX2,\n\tCS35L41_INPUT_SRC_VMON, CS35L41_INPUT_SRC_IMON, CS35L41_INPUT_SRC_VPMON,\n\tCS35L41_INPUT_SRC_VBSTMON, CS35L41_INPUT_DSP_TX1, CS35L41_INPUT_DSP_TX2\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx1_enum,\n\t\t\t\t  CS35L41_ASP_TX1_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp_tx1_mux =\n\tSOC_DAPM_ENUM(\"ASPTX1 SRC\", cs35l41_asptx1_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx2_enum,\n\t\t\t\t  CS35L41_ASP_TX2_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp_tx2_mux =\n\tSOC_DAPM_ENUM(\"ASPTX2 SRC\", cs35l41_asptx2_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx3_enum,\n\t\t\t\t  CS35L41_ASP_TX3_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp_tx3_mux =\n\tSOC_DAPM_ENUM(\"ASPTX3 SRC\", cs35l41_asptx3_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx4_enum,\n\t\t\t\t  CS35L41_ASP_TX4_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp_tx4_mux =\n\tSOC_DAPM_ENUM(\"ASPTX4 SRC\", cs35l41_asptx4_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_dsprx1_enum,\n\t\t\t\t  CS35L41_DSP1_RX1_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new dsp_rx1_mux =\n\tSOC_DAPM_ENUM(\"DSPRX1 SRC\", cs35l41_dsprx1_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_dsprx2_enum,\n\t\t\t\t  CS35L41_DSP1_RX2_SRC,\n\t\t\t\t  0, CS35L41_ASP_SOURCE_MASK,\n\t\t\t\t  cs35l41_tx_input_texts,\n\t\t\t\t  cs35l41_tx_input_values);\n\nstatic const struct snd_kcontrol_new dsp_rx2_mux =\n\tSOC_DAPM_ENUM(\"DSPRX2 SRC\", cs35l41_dsprx2_enum);\n\nstatic const struct snd_kcontrol_new cs35l41_aud_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"Digital PCM Volume\", CS35L41_AMP_DIG_VOL_CTRL,\n\t\t\t  3, 0x4CF, 0x391, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Analog PCM Volume\", CS35L41_AMP_GAIN_CTRL, 5, 0x14, 0,\n\t\t       amp_gain_tlv),\n\tSOC_ENUM(\"PCM Soft Ramp\", pcm_sft_ramp),\n\tSOC_SINGLE(\"HW Noise Gate Enable\", CS35L41_NG_CFG, 8, 63, 0),\n\tSOC_SINGLE(\"HW Noise Gate Delay\", CS35L41_NG_CFG, 4, 7, 0),\n\tSOC_SINGLE(\"HW Noise Gate Threshold\", CS35L41_NG_CFG, 0, 7, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH1 Switch\",\n\t\t   CS35L41_MIXER_NGATE_CH1_CFG, 16, 1, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH1 Entry Delay\",\n\t\t   CS35L41_MIXER_NGATE_CH1_CFG, 8, 15, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH1 Threshold\",\n\t\t   CS35L41_MIXER_NGATE_CH1_CFG, 0, 7, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH2 Entry Delay\",\n\t\t   CS35L41_MIXER_NGATE_CH2_CFG, 8, 15, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH2 Switch\",\n\t\t   CS35L41_MIXER_NGATE_CH2_CFG, 16, 1, 0),\n\tSOC_SINGLE(\"Aux Noise Gate CH2 Threshold\",\n\t\t   CS35L41_MIXER_NGATE_CH2_CFG, 0, 7, 0),\n\tSOC_SINGLE(\"SCLK Force Switch\", CS35L41_SP_FORMAT, CS35L41_SCLK_FRC_SHIFT, 1, 0),\n\tSOC_SINGLE(\"LRCLK Force Switch\", CS35L41_SP_FORMAT, CS35L41_LRCLK_FRC_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Invert Class D Switch\", CS35L41_AMP_DIG_VOL_CTRL,\n\t\t   CS35L41_AMP_INV_PCM_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Amp Gain ZC Switch\", CS35L41_AMP_GAIN_CTRL,\n\t\t   CS35L41_AMP_GAIN_ZC_SHIFT, 1, 0),\n\tWM_ADSP2_PRELOAD_SWITCH(\"DSP1\", 1),\n\tWM_ADSP_FW_CONTROL(\"DSP1\", 0),\n};\n\nstatic void cs35l41_boost_enable(struct cs35l41_private *cs35l41, unsigned int enable)\n{\n\tswitch (cs35l41->hw_cfg.bst_type) {\n\tcase CS35L41_INT_BOOST:\n\tcase CS35L41_SHD_BOOST_ACTV:\n\t\tenable = enable ? CS35L41_BST_EN_DEFAULT : CS35L41_BST_DIS_FET_OFF;\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2, CS35L41_BST_EN_MASK,\n\t\t\t\tenable << CS35L41_BST_EN_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\nstatic void cs35l41_error_release(struct cs35l41_private *cs35l41, unsigned int irq_err_bit,\n\t\t\t\t  unsigned int rel_err_bit)\n{\n\tregmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1, irq_err_bit);\n\tregmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, rel_err_bit, rel_err_bit);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, rel_err_bit, 0);\n}\n\nstatic irqreturn_t cs35l41_irq(int irq, void *data)\n{\n\tstruct cs35l41_private *cs35l41 = data;\n\tunsigned int status[4] = { 0, 0, 0, 0 };\n\tunsigned int masks[4] = { 0, 0, 0, 0 };\n\tunsigned int i;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(cs35l41->dev);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev,\n\t\t\t\"pm_runtime_resume_and_get failed in %s: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn IRQ_NONE;\n\t}\n\n\tret = IRQ_NONE;\n\n\tfor (i = 0; i < ARRAY_SIZE(status); i++) {\n\t\tregmap_read(cs35l41->regmap,\n\t\t\t    CS35L41_IRQ1_STATUS1 + (i * CS35L41_REGSTRIDE),\n\t\t\t    &status[i]);\n\t\tregmap_read(cs35l41->regmap,\n\t\t\t    CS35L41_IRQ1_MASK1 + (i * CS35L41_REGSTRIDE),\n\t\t\t    &masks[i]);\n\t}\n\n\t \n\tif (!(status[0] & ~masks[0]) && !(status[1] & ~masks[1]) &&\n\t    !(status[2] & ~masks[2]) && !(status[3] & ~masks[3]))\n\t\tgoto done;\n\n\tif (status[3] & CS35L41_OTP_BOOT_DONE) {\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_IRQ1_MASK4,\n\t\t\t\t   CS35L41_OTP_BOOT_DONE, CS35L41_OTP_BOOT_DONE);\n\t}\n\n\t \n\tif (status[0] & CS35L41_AMP_SHORT_ERR) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"Amp short error\\n\");\n\t\tcs35l41_error_release(cs35l41, CS35L41_AMP_SHORT_ERR, CS35L41_AMP_SHORT_ERR_RLS);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L41_TEMP_WARN) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"Over temperature warning\\n\");\n\t\tcs35l41_error_release(cs35l41, CS35L41_TEMP_WARN, CS35L41_TEMP_WARN_ERR_RLS);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L41_TEMP_ERR) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"Over temperature error\\n\");\n\t\tcs35l41_error_release(cs35l41, CS35L41_TEMP_ERR, CS35L41_TEMP_ERR_RLS);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L41_BST_OVP_ERR) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"VBST Over Voltage error\\n\");\n\t\tcs35l41_boost_enable(cs35l41, 0);\n\t\tcs35l41_error_release(cs35l41, CS35L41_BST_OVP_ERR, CS35L41_BST_OVP_ERR_RLS);\n\t\tcs35l41_boost_enable(cs35l41, 1);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L41_BST_DCM_UVP_ERR) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"DCM VBST Under Voltage Error\\n\");\n\t\tcs35l41_boost_enable(cs35l41, 0);\n\t\tcs35l41_error_release(cs35l41, CS35L41_BST_DCM_UVP_ERR, CS35L41_BST_UVP_ERR_RLS);\n\t\tcs35l41_boost_enable(cs35l41, 1);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[0] & CS35L41_BST_SHORT_ERR) {\n\t\tdev_crit_ratelimited(cs35l41->dev, \"LBST error: powering off!\\n\");\n\t\tcs35l41_boost_enable(cs35l41, 0);\n\t\tcs35l41_error_release(cs35l41, CS35L41_BST_SHORT_ERR, CS35L41_BST_SHORT_ERR_RLS);\n\t\tcs35l41_boost_enable(cs35l41, 1);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (status[2] & CS35L41_PLL_LOCK) {\n\t\tregmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS3, CS35L41_PLL_LOCK);\n\n\t\tif (cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_ACTV ||\n\t\t    cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_PASS) {\n\t\t\tret = cs35l41_mdsync_up(cs35l41->regmap);\n\t\t\tif (ret)\n\t\t\t\tdev_err(cs35l41->dev, \"MDSYNC-up failed: %d\\n\", ret);\n\t\t\telse\n\t\t\t\tdev_dbg(cs35l41->dev, \"MDSYNC-up done\\n\");\n\n\t\t\tdev_dbg(cs35l41->dev, \"PUP-done status: %d\\n\",\n\t\t\t\t!!(status[0] & CS35L41_PUP_DONE_MASK));\n\t\t}\n\n\t\tret = IRQ_HANDLED;\n\t}\n\ndone:\n\tpm_runtime_mark_last_busy(cs35l41->dev);\n\tpm_runtime_put_autosuspend(cs35l41->dev);\n\n\treturn ret;\n}\n\nstatic const struct reg_sequence cs35l41_pup_patch[] = {\n\t{ CS35L41_TEST_KEY_CTL, 0x00000055 },\n\t{ CS35L41_TEST_KEY_CTL, 0x000000AA },\n\t{ 0x00002084, 0x002F1AA0 },\n\t{ CS35L41_TEST_KEY_CTL, 0x000000CC },\n\t{ CS35L41_TEST_KEY_CTL, 0x00000033 },\n};\n\nstatic const struct reg_sequence cs35l41_pdn_patch[] = {\n\t{ CS35L41_TEST_KEY_CTL, 0x00000055 },\n\t{ CS35L41_TEST_KEY_CTL, 0x000000AA },\n\t{ 0x00002084, 0x002F1AA3 },\n\t{ CS35L41_TEST_KEY_CTL, 0x000000CC },\n\t{ CS35L41_TEST_KEY_CTL, 0x00000033 },\n};\n\nstatic int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_multi_reg_write_bypassed(cs35l41->regmap,\n\t\t\t\t\t\tcs35l41_pup_patch,\n\t\t\t\t\t\tARRAY_SIZE(cs35l41_pup_patch));\n\n\t\tret = cs35l41_global_enable(cs35l41->dev, cs35l41->regmap, cs35l41->hw_cfg.bst_type,\n\t\t\t\t\t    1, cs35l41->dsp.cs_dsp.running);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tret = cs35l41_global_enable(cs35l41->dev, cs35l41->regmap, cs35l41->hw_cfg.bst_type,\n\t\t\t\t\t    0, cs35l41->dsp.cs_dsp.running);\n\n\t\tregmap_multi_reg_write_bypassed(cs35l41->regmap,\n\t\t\t\t\t\tcs35l41_pdn_patch,\n\t\t\t\t\t\tARRAY_SIZE(cs35l41_pdn_patch));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l41->dev, \"Invalid event = 0x%x\\n\", event);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget cs35l41_dapm_widgets[] = {\n\tSND_SOC_DAPM_SPK(\"DSP1 Preload\", NULL),\n\tSND_SOC_DAPM_SUPPLY_S(\"DSP1 Preloader\", 100, SND_SOC_NOPM, 0, 0,\n\t\t\t      cs35l41_dsp_preload_ev,\n\t\t\t      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUT_DRV_E(\"DSP1\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t       cs35l41_dsp_audio_ev,\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\n\tSND_SOC_DAPM_AIF_IN(\"ASPRX1\", NULL, 0, CS35L41_SP_ENABLES, 16, 0),\n\tSND_SOC_DAPM_AIF_IN(\"ASPRX2\", NULL, 0, CS35L41_SP_ENABLES, 17, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX1\", NULL, 0, CS35L41_SP_ENABLES, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX2\", NULL, 0, CS35L41_SP_ENABLES, 1, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX3\", NULL, 0, CS35L41_SP_ENABLES, 2, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASPTX4\", NULL, 0, CS35L41_SP_ENABLES, 3, 0),\n\n\tSND_SOC_DAPM_SIGGEN(\"VSENSE\"),\n\tSND_SOC_DAPM_SIGGEN(\"ISENSE\"),\n\tSND_SOC_DAPM_SIGGEN(\"VP\"),\n\tSND_SOC_DAPM_SIGGEN(\"VBST\"),\n\tSND_SOC_DAPM_SIGGEN(\"TEMP\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"VMON\", CS35L41_PWR_CTRL2, 12, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"IMON\", CS35L41_PWR_CTRL2, 13, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VPMON\", CS35L41_PWR_CTRL2, 8, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VBSTMON\", CS35L41_PWR_CTRL2, 9, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"TEMPMON\", CS35L41_PWR_CTRL2, 10, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"VMON ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"IMON ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"VPMON ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"VBSTMON ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_ADC(\"TEMPMON ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_ADC(\"CLASS H\", NULL, CS35L41_PWR_CTRL3, 4, 0),\n\n\tSND_SOC_DAPM_OUT_DRV_E(\"Main AMP\", CS35L41_PWR_CTRL2, 0, 0, NULL, 0,\n\t\t\t       cs35l41_main_amp_event,\n\t\t\t       SND_SOC_DAPM_POST_PMD |\tSND_SOC_DAPM_PRE_PMU),\n\n\tSND_SOC_DAPM_MUX(\"ASP TX1 Source\", SND_SOC_NOPM, 0, 0, &asp_tx1_mux),\n\tSND_SOC_DAPM_MUX(\"ASP TX2 Source\", SND_SOC_NOPM, 0, 0, &asp_tx2_mux),\n\tSND_SOC_DAPM_MUX(\"ASP TX3 Source\", SND_SOC_NOPM, 0, 0, &asp_tx3_mux),\n\tSND_SOC_DAPM_MUX(\"ASP TX4 Source\", SND_SOC_NOPM, 0, 0, &asp_tx4_mux),\n\tSND_SOC_DAPM_MUX(\"DSP RX1 Source\", SND_SOC_NOPM, 0, 0, &dsp_rx1_mux),\n\tSND_SOC_DAPM_MUX(\"DSP RX2 Source\", SND_SOC_NOPM, 0, 0, &dsp_rx2_mux),\n\tSND_SOC_DAPM_MUX(\"PCM Source\", SND_SOC_NOPM, 0, 0, &pcm_source_mux),\n\tSND_SOC_DAPM_SWITCH(\"DRE\", SND_SOC_NOPM, 0, 0, &dre_ctrl),\n};\n\nstatic const struct snd_soc_dapm_route cs35l41_audio_map[] = {\n\t{\"DSP RX1 Source\", \"ASPRX1\", \"ASPRX1\"},\n\t{\"DSP RX1 Source\", \"ASPRX2\", \"ASPRX2\"},\n\t{\"DSP RX2 Source\", \"ASPRX1\", \"ASPRX1\"},\n\t{\"DSP RX2 Source\", \"ASPRX2\", \"ASPRX2\"},\n\n\t{\"DSP1\", NULL, \"DSP RX1 Source\"},\n\t{\"DSP1\", NULL, \"DSP RX2 Source\"},\n\n\t{\"ASP TX1 Source\", \"VMON\", \"VMON ADC\"},\n\t{\"ASP TX1 Source\", \"IMON\", \"IMON ADC\"},\n\t{\"ASP TX1 Source\", \"VPMON\", \"VPMON ADC\"},\n\t{\"ASP TX1 Source\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASP TX1 Source\", \"DSPTX1\", \"DSP1\"},\n\t{\"ASP TX1 Source\", \"DSPTX2\", \"DSP1\"},\n\t{\"ASP TX1 Source\", \"ASPRX1\", \"ASPRX1\" },\n\t{\"ASP TX1 Source\", \"ASPRX2\", \"ASPRX2\" },\n\t{\"ASP TX2 Source\", \"VMON\", \"VMON ADC\"},\n\t{\"ASP TX2 Source\", \"IMON\", \"IMON ADC\"},\n\t{\"ASP TX2 Source\", \"VPMON\", \"VPMON ADC\"},\n\t{\"ASP TX2 Source\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASP TX2 Source\", \"DSPTX1\", \"DSP1\"},\n\t{\"ASP TX2 Source\", \"DSPTX2\", \"DSP1\"},\n\t{\"ASP TX2 Source\", \"ASPRX1\", \"ASPRX1\" },\n\t{\"ASP TX2 Source\", \"ASPRX2\", \"ASPRX2\" },\n\t{\"ASP TX3 Source\", \"VMON\", \"VMON ADC\"},\n\t{\"ASP TX3 Source\", \"IMON\", \"IMON ADC\"},\n\t{\"ASP TX3 Source\", \"VPMON\", \"VPMON ADC\"},\n\t{\"ASP TX3 Source\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASP TX3 Source\", \"DSPTX1\", \"DSP1\"},\n\t{\"ASP TX3 Source\", \"DSPTX2\", \"DSP1\"},\n\t{\"ASP TX3 Source\", \"ASPRX1\", \"ASPRX1\" },\n\t{\"ASP TX3 Source\", \"ASPRX2\", \"ASPRX2\" },\n\t{\"ASP TX4 Source\", \"VMON\", \"VMON ADC\"},\n\t{\"ASP TX4 Source\", \"IMON\", \"IMON ADC\"},\n\t{\"ASP TX4 Source\", \"VPMON\", \"VPMON ADC\"},\n\t{\"ASP TX4 Source\", \"VBSTMON\", \"VBSTMON ADC\"},\n\t{\"ASP TX4 Source\", \"DSPTX1\", \"DSP1\"},\n\t{\"ASP TX4 Source\", \"DSPTX2\", \"DSP1\"},\n\t{\"ASP TX4 Source\", \"ASPRX1\", \"ASPRX1\" },\n\t{\"ASP TX4 Source\", \"ASPRX2\", \"ASPRX2\" },\n\t{\"ASPTX1\", NULL, \"ASP TX1 Source\"},\n\t{\"ASPTX2\", NULL, \"ASP TX2 Source\"},\n\t{\"ASPTX3\", NULL, \"ASP TX3 Source\"},\n\t{\"ASPTX4\", NULL, \"ASP TX4 Source\"},\n\t{\"AMP Capture\", NULL, \"ASPTX1\"},\n\t{\"AMP Capture\", NULL, \"ASPTX2\"},\n\t{\"AMP Capture\", NULL, \"ASPTX3\"},\n\t{\"AMP Capture\", NULL, \"ASPTX4\"},\n\n\t{\"DSP1\", NULL, \"VMON\"},\n\t{\"DSP1\", NULL, \"IMON\"},\n\t{\"DSP1\", NULL, \"VPMON\"},\n\t{\"DSP1\", NULL, \"VBSTMON\"},\n\t{\"DSP1\", NULL, \"TEMPMON\"},\n\n\t{\"VMON ADC\", NULL, \"VMON\"},\n\t{\"IMON ADC\", NULL, \"IMON\"},\n\t{\"VPMON ADC\", NULL, \"VPMON\"},\n\t{\"VBSTMON ADC\", NULL, \"VBSTMON\"},\n\t{\"TEMPMON ADC\", NULL, \"TEMPMON\"},\n\n\t{\"VMON ADC\", NULL, \"VSENSE\"},\n\t{\"IMON ADC\", NULL, \"ISENSE\"},\n\t{\"VPMON ADC\", NULL, \"VP\"},\n\t{\"VBSTMON ADC\", NULL, \"VBST\"},\n\t{\"TEMPMON ADC\", NULL, \"TEMP\"},\n\n\t{\"DSP1 Preload\", NULL, \"DSP1 Preloader\"},\n\t{\"DSP1\", NULL, \"DSP1 Preloader\"},\n\n\t{\"ASPRX1\", NULL, \"AMP Playback\"},\n\t{\"ASPRX2\", NULL, \"AMP Playback\"},\n\t{\"DRE\", \"Switch\", \"CLASS H\"},\n\t{\"Main AMP\", NULL, \"CLASS H\"},\n\t{\"Main AMP\", NULL, \"DRE\"},\n\t{\"SPK\", NULL, \"Main AMP\"},\n\n\t{\"PCM Source\", \"ASP\", \"ASPRX1\"},\n\t{\"PCM Source\", \"DSP\", \"DSP1\"},\n\t{\"CLASS H\", NULL, \"PCM Source\"},\n};\n\nstatic int cs35l41_set_channel_map(struct snd_soc_dai *dai, unsigned int tx_n,\n\t\t\t\t   unsigned int *tx_slot, unsigned int rx_n, unsigned int *rx_slot)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);\n\n\treturn cs35l41_set_channels(cs35l41->dev, cs35l41->regmap, tx_n, tx_slot, rx_n, rx_slot);\n}\n\nstatic int cs35l41_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int daifmt = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tdaifmt |= CS35L41_SCLK_MSTR_MASK | CS35L41_LRCLK_MSTR_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(cs35l41->dev, \"Mixed provider/consumer mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdaifmt |= 2 << CS35L41_ASP_FMT_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(cs35l41->dev, \"Invalid or unsupported DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tdaifmt |= CS35L41_LRCLK_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tdaifmt |= CS35L41_SCLK_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tdaifmt |= CS35L41_LRCLK_INV_MASK | CS35L41_SCLK_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(cs35l41->dev, \"Invalid DAI clock INV\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,\n\t\t\t\t  CS35L41_SCLK_MSTR_MASK | CS35L41_LRCLK_MSTR_MASK |\n\t\t\t\t  CS35L41_ASP_FMT_MASK | CS35L41_LRCLK_INV_MASK |\n\t\t\t\t  CS35L41_SCLK_INV_MASK, daifmt);\n}\n\nstruct cs35l41_global_fs_config {\n\tint rate;\n\tint fs_cfg;\n};\n\nstatic const struct cs35l41_global_fs_config cs35l41_fs_rates[] = {\n\t{ 12000,\t0x01 },\n\t{ 24000,\t0x02 },\n\t{ 48000,\t0x03 },\n\t{ 96000,\t0x04 },\n\t{ 192000,\t0x05 },\n\t{ 11025,\t0x09 },\n\t{ 22050,\t0x0A },\n\t{ 44100,\t0x0B },\n\t{ 88200,\t0x0C },\n\t{ 176400,\t0x0D },\n\t{ 8000,\t\t0x11 },\n\t{ 16000,\t0x12 },\n\t{ 32000,\t0x13 },\n};\n\nstatic int cs35l41_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int rate = params_rate(params);\n\tu8 asp_wl;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l41_fs_rates); i++) {\n\t\tif (rate == cs35l41_fs_rates[i].rate)\n\t\t\tbreak;\n\t}\n\n\tif (i >= ARRAY_SIZE(cs35l41_fs_rates)) {\n\t\tdev_err(cs35l41->dev, \"Unsupported rate: %u\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tasp_wl = params_width(params);\n\n\tif (i < ARRAY_SIZE(cs35l41_fs_rates))\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_GLOBAL_CLK_CTRL,\n\t\t\t\t   CS35L41_GLOBAL_FS_MASK,\n\t\t\t\t   cs35l41_fs_rates[i].fs_cfg << CS35L41_GLOBAL_FS_SHIFT);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,\n\t\t\t\t   CS35L41_ASP_WIDTH_RX_MASK,\n\t\t\t\t   asp_wl << CS35L41_ASP_WIDTH_RX_SHIFT);\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_SP_RX_WL,\n\t\t\t\t   CS35L41_ASP_RX_WL_MASK,\n\t\t\t\t   asp_wl << CS35L41_ASP_RX_WL_SHIFT);\n\t} else {\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,\n\t\t\t\t   CS35L41_ASP_WIDTH_TX_MASK,\n\t\t\t\t   asp_wl << CS35L41_ASP_WIDTH_TX_SHIFT);\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_SP_TX_WL,\n\t\t\t\t   CS35L41_ASP_TX_WL_MASK,\n\t\t\t\t   asp_wl << CS35L41_ASP_TX_WL_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l41_get_clk_config(int freq)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l41_pll_sysclk); i++) {\n\t\tif (cs35l41_pll_sysclk[i].freq == freq)\n\t\t\treturn cs35l41_pll_sysclk[i].clk_cfg;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const unsigned int cs35l41_src_rates[] = {\n\t8000, 12000, 11025, 16000, 22050, 24000, 32000,\n\t44100, 48000, 88200, 96000, 176400, 192000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs35l41_constraints = {\n\t.count = ARRAY_SIZE(cs35l41_src_rates),\n\t.list = cs35l41_src_rates,\n};\n\nstatic int cs35l41_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tif (substream->runtime)\n\t\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t\t  &cs35l41_constraints);\n\treturn 0;\n}\n\nstatic int cs35l41_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\t\tint clk_id, int source,\n\t\t\t\t\tunsigned int freq, int dir)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\tint extclk_cfg, clksrc;\n\n\tswitch (clk_id) {\n\tcase CS35L41_CLKID_SCLK:\n\t\tclksrc = CS35L41_PLLSRC_SCLK;\n\t\tbreak;\n\tcase CS35L41_CLKID_LRCLK:\n\t\tclksrc = CS35L41_PLLSRC_LRCLK;\n\t\tbreak;\n\tcase CS35L41_CLKID_MCLK:\n\t\tclksrc = CS35L41_PLLSRC_MCLK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l41->dev, \"Invalid CLK Config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\textclk_cfg = cs35l41_get_clk_config(freq);\n\n\tif (extclk_cfg < 0) {\n\t\tdev_err(cs35l41->dev, \"Invalid CLK Config: %d, freq: %u\\n\",\n\t\t\textclk_cfg, freq);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_PLL_OPENLOOP_MASK,\n\t\t\t   1 << CS35L41_PLL_OPENLOOP_SHIFT);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_REFCLK_FREQ_MASK,\n\t\t\t   extclk_cfg << CS35L41_REFCLK_FREQ_SHIFT);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_PLL_CLK_EN_MASK,\n\t\t\t   0 << CS35L41_PLL_CLK_EN_SHIFT);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_PLL_CLK_SEL_MASK, clksrc);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_PLL_OPENLOOP_MASK,\n\t\t\t   0 << CS35L41_PLL_OPENLOOP_SHIFT);\n\tregmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,\n\t\t\t   CS35L41_PLL_CLK_EN_MASK,\n\t\t\t   1 << CS35L41_PLL_CLK_EN_SHIFT);\n\n\treturn 0;\n}\n\nstatic int cs35l41_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int fs1_val;\n\tunsigned int fs2_val;\n\tunsigned int val;\n\tint fsindex;\n\n\tfsindex = cs35l41_get_fs_mon_config_index(freq);\n\tif (fsindex < 0) {\n\t\tdev_err(cs35l41->dev, \"Invalid CLK Config freq: %u\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(cs35l41->dev, \"Set DAI sysclk %d\\n\", freq);\n\n\tif (freq <= 6144000) {\n\t\t \n\t\tfs1_val = cs35l41_fs_mon[fsindex].fs1;\n\t\tfs2_val = cs35l41_fs_mon[fsindex].fs2;\n\t} else {\n\t\t \n\t\tfs1_val = 0x10;\n\t\tfs2_val = 0x24;\n\t}\n\n\tval = fs1_val;\n\tval |= (fs2_val << CS35L41_FS2_WINDOW_SHIFT) & CS35L41_FS2_WINDOW_MASK;\n\tregmap_write(cs35l41->regmap, CS35L41_TST_FS_MON0, val);\n\n\treturn 0;\n}\n\nstatic int cs35l41_set_pdata(struct cs35l41_private *cs35l41)\n{\n\tstruct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;\n\tint ret;\n\n\tif (!hw_cfg->valid)\n\t\treturn -EINVAL;\n\n\tif (hw_cfg->bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH)\n\t\treturn -EINVAL;\n\n\t \n\tret = cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, hw_cfg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hw_cfg->dout_hiz <= CS35L41_ASP_DOUT_HIZ_MASK && hw_cfg->dout_hiz >= 0)\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_SP_HIZ_CTRL, CS35L41_ASP_DOUT_HIZ_MASK,\n\t\t\t\t   hw_cfg->dout_hiz);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_route cs35l41_ext_bst_routes[] = {\n\t{\"Main AMP\", NULL, \"VSPK\"},\n};\n\nstatic const struct snd_soc_dapm_widget cs35l41_ext_bst_widget[] = {\n\tSND_SOC_DAPM_SUPPLY(\"VSPK\", CS35L41_GPIO1_CTRL1, CS35L41_GPIO_LVL_SHIFT, 0, NULL, 0),\n};\n\nstatic int cs35l41_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint ret;\n\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST) {\n\t\tret = snd_soc_dapm_new_controls(dapm, cs35l41_ext_bst_widget,\n\t\t\t\t\t\tARRAY_SIZE(cs35l41_ext_bst_widget));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, cs35l41_ext_bst_routes,\n\t\t\t\t\t      ARRAY_SIZE(cs35l41_ext_bst_routes));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn wm_adsp2_component_probe(&cs35l41->dsp, component);\n}\n\nstatic void cs35l41_component_remove(struct snd_soc_component *component)\n{\n\tstruct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);\n\n\twm_adsp2_component_remove(&cs35l41->dsp, component);\n}\n\nstatic const struct snd_soc_dai_ops cs35l41_ops = {\n\t.startup = cs35l41_pcm_startup,\n\t.set_fmt = cs35l41_set_dai_fmt,\n\t.hw_params = cs35l41_pcm_hw_params,\n\t.set_sysclk = cs35l41_dai_set_sysclk,\n\t.set_channel_map = cs35l41_set_channel_map,\n};\n\nstatic struct snd_soc_dai_driver cs35l41_dai[] = {\n\t{\n\t\t.name = \"cs35l41-pcm\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AMP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L41_RX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AMP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L41_TX_FORMATS,\n\t\t},\n\t\t.ops = &cs35l41_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l41 = {\n\t.name = \"cs35l41-codec\",\n\t.probe = cs35l41_component_probe,\n\t.remove = cs35l41_component_remove,\n\n\t.dapm_widgets = cs35l41_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(cs35l41_dapm_widgets),\n\t.dapm_routes = cs35l41_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(cs35l41_audio_map),\n\n\t.controls = cs35l41_aud_controls,\n\t.num_controls = ARRAY_SIZE(cs35l41_aud_controls),\n\t.set_sysclk = cs35l41_component_set_sysclk,\n\n\t.endianness = 1,\n};\n\nstatic int cs35l41_handle_pdata(struct device *dev, struct cs35l41_hw_cfg *hw_cfg)\n{\n\tstruct cs35l41_gpio_cfg *gpio1 = &hw_cfg->gpio1;\n\tstruct cs35l41_gpio_cfg *gpio2 = &hw_cfg->gpio2;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tif (device_property_read_bool(dev, \"cirrus,shared-boost-active\")) {\n\t\thw_cfg->bst_type = CS35L41_SHD_BOOST_ACTV;\n\t} else if (device_property_read_bool(dev, \"cirrus,shared-boost-passive\")) {\n\t\thw_cfg->bst_type = CS35L41_SHD_BOOST_PASS;\n\t} else {\n\t\tret = device_property_read_u32(dev, \"cirrus,boost-type\", &val);\n\t\tif (ret >= 0)\n\t\t\thw_cfg->bst_type = val;\n\t}\n\n\tret = device_property_read_u32(dev, \"cirrus,boost-peak-milliamp\", &val);\n\tif (ret >= 0)\n\t\thw_cfg->bst_ipk = val;\n\telse\n\t\thw_cfg->bst_ipk = -1;\n\n\tret = device_property_read_u32(dev, \"cirrus,boost-ind-nanohenry\", &val);\n\tif (ret >= 0)\n\t\thw_cfg->bst_ind = val;\n\telse\n\t\thw_cfg->bst_ind = -1;\n\n\tret = device_property_read_u32(dev, \"cirrus,boost-cap-microfarad\", &val);\n\tif (ret >= 0)\n\t\thw_cfg->bst_cap = val;\n\telse\n\t\thw_cfg->bst_cap = -1;\n\n\tret = device_property_read_u32(dev, \"cirrus,asp-sdout-hiz\", &val);\n\tif (ret >= 0)\n\t\thw_cfg->dout_hiz = val;\n\telse\n\t\thw_cfg->dout_hiz = -1;\n\n\t \n\tgpio1->pol_inv = device_property_read_bool(dev, \"cirrus,gpio1-polarity-invert\");\n\tgpio1->out_en = device_property_read_bool(dev, \"cirrus,gpio1-output-enable\");\n\tret = device_property_read_u32(dev, \"cirrus,gpio1-src-select\", &val);\n\tif (ret >= 0) {\n\t\tgpio1->func = val;\n\t\tgpio1->valid = true;\n\t}\n\n\t \n\tgpio2->pol_inv = device_property_read_bool(dev, \"cirrus,gpio2-polarity-invert\");\n\tgpio2->out_en = device_property_read_bool(dev, \"cirrus,gpio2-output-enable\");\n\tret = device_property_read_u32(dev, \"cirrus,gpio2-src-select\", &val);\n\tif (ret >= 0) {\n\t\tgpio2->func = val;\n\t\tgpio2->valid = true;\n\t}\n\n\thw_cfg->valid = true;\n\n\treturn 0;\n}\n\nstatic int cs35l41_dsp_init(struct cs35l41_private *cs35l41)\n{\n\tstruct wm_adsp *dsp;\n\tint ret;\n\n\tdsp = &cs35l41->dsp;\n\tdsp->part = \"cs35l41\";\n\tdsp->fw = 9;  \n\tdsp->toggle_preload = true;\n\n\tcs35l41_configure_cs_dsp(cs35l41->dev, cs35l41->regmap, &dsp->cs_dsp);\n\n\tret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wm_halo_init(dsp);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"wm_halo_init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX5_SRC,\n\t\t\t   CS35L41_INPUT_SRC_VPMON);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Write INPUT_SRC_VPMON failed: %d\\n\", ret);\n\t\tgoto err_dsp;\n\t}\n\tret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX6_SRC,\n\t\t\t   CS35L41_INPUT_SRC_CLASSH);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Write INPUT_SRC_CLASSH failed: %d\\n\", ret);\n\t\tgoto err_dsp;\n\t}\n\tret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX7_SRC,\n\t\t\t   CS35L41_INPUT_SRC_TEMPMON);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Write INPUT_SRC_TEMPMON failed: %d\\n\", ret);\n\t\tgoto err_dsp;\n\t}\n\tret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX8_SRC,\n\t\t\t   CS35L41_INPUT_SRC_RSVD);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Write INPUT_SRC_RSVD failed: %d\\n\", ret);\n\t\tgoto err_dsp;\n\t}\n\n\treturn 0;\n\nerr_dsp:\n\twm_adsp2_remove(dsp);\n\n\treturn ret;\n}\n\nstatic int cs35l41_acpi_get_name(struct cs35l41_private *cs35l41)\n{\n\tacpi_handle handle = ACPI_HANDLE(cs35l41->dev);\n\tconst char *sub;\n\n\t \n\tif (!handle)\n\t\treturn 0;\n\n\tsub = acpi_get_subsystem_id(handle);\n\tif (IS_ERR(sub)) {\n\t\t \n\t\tif (PTR_ERR(sub) == -ENODATA)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn PTR_ERR(sub);\n\t}\n\n\tcs35l41->dsp.system_name = sub;\n\tdev_dbg(cs35l41->dev, \"Subsystem ID: %s\\n\", cs35l41->dsp.system_name);\n\n\treturn 0;\n}\n\nint cs35l41_probe(struct cs35l41_private *cs35l41, const struct cs35l41_hw_cfg *hw_cfg)\n{\n\tu32 regid, reg_revid, i, mtl_revid, int_status, chipid_match;\n\tint irq_pol = 0;\n\tint ret;\n\n\tif (hw_cfg) {\n\t\tcs35l41->hw_cfg = *hw_cfg;\n\t} else {\n\t\tret = cs35l41_handle_pdata(cs35l41->dev, &cs35l41->hw_cfg);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < CS35L41_NUM_SUPPLIES; i++)\n\t\tcs35l41->supplies[i].supply = cs35l41_supplies[i];\n\n\tret = devm_regulator_bulk_get(cs35l41->dev, CS35L41_NUM_SUPPLIES,\n\t\t\t\t      cs35l41->supplies);\n\tif (ret != 0) {\n\t\tdev_err(cs35l41->dev, \"Failed to request core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);\n\tif (ret != 0) {\n\t\tdev_err(cs35l41->dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs35l41->reset_gpio = devm_gpiod_get_optional(cs35l41->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l41->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l41->reset_gpio);\n\t\tcs35l41->reset_gpio = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_info(cs35l41->dev,\n\t\t\t\t \"Reset line busy, assuming shared reset\\n\");\n\t\t} else {\n\t\t\tdev_err(cs35l41->dev,\n\t\t\t\t\"Failed to get reset GPIO: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (cs35l41->reset_gpio) {\n\t\t \n\t\tusleep_range(2000, 2100);\n\t\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 1);\n\t}\n\n\tusleep_range(2000, 2100);\n\n\tret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS4,\n\t\t\t\t       int_status, int_status & CS35L41_OTP_BOOT_DONE,\n\t\t\t\t       1000, 100000);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev,\n\t\t\t\"Failed waiting for OTP_BOOT_DONE: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tregmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS3, &int_status);\n\tif (int_status & CS35L41_OTP_BOOT_ERR) {\n\t\tdev_err(cs35l41->dev, \"OTP Boot error\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l41->regmap, CS35L41_DEVID, &regid);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Get Device ID failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l41->regmap, CS35L41_REVID, &reg_revid);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Get Revision ID failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tmtl_revid = reg_revid & CS35L41_MTLREVID_MASK;\n\n\t \n\tchipid_match = (mtl_revid % 2) ? CS35L41R_CHIP_ID : CS35L41_CHIP_ID;\n\tif (regid != chipid_match) {\n\t\tdev_err(cs35l41->dev, \"CS35L41 Device ID (%X). Expected ID %X\\n\",\n\t\t\tregid, chipid_match);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tcs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);\n\n\tret = cs35l41_register_errata_patch(cs35l41->dev, cs35l41->regmap, reg_revid);\n\tif (ret)\n\t\tgoto err;\n\n\tret = cs35l41_otp_unpack(cs35l41->dev, cs35l41->regmap);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"OTP Unpack failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tcs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);\n\n\tirq_pol = cs35l41_gpio_config(cs35l41->regmap, &cs35l41->hw_cfg);\n\n\t \n\tregmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,\n\t\t     CS35L41_INT1_MASK_DEFAULT);\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_PASS ||\n\t    cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_ACTV)\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_IRQ1_MASK3, CS35L41_INT3_PLL_LOCK_MASK,\n\t\t\t\t   0 << CS35L41_INT3_PLL_LOCK_SHIFT);\n\n\tret = devm_request_threaded_irq(cs35l41->dev, cs35l41->irq, NULL, cs35l41_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_SHARED | irq_pol,\n\t\t\t\t\t\"cs35l41\", cs35l41);\n\tif (ret != 0) {\n\t\tdev_err(cs35l41->dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = cs35l41_set_pdata(cs35l41);\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Set pdata failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = cs35l41_acpi_get_name(cs35l41);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = cs35l41_dsp_init(cs35l41);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tpm_runtime_set_autosuspend_delay(cs35l41->dev, 3000);\n\tpm_runtime_use_autosuspend(cs35l41->dev);\n\tpm_runtime_mark_last_busy(cs35l41->dev);\n\tpm_runtime_set_active(cs35l41->dev);\n\tpm_runtime_get_noresume(cs35l41->dev);\n\tpm_runtime_enable(cs35l41->dev);\n\n\tret = devm_snd_soc_register_component(cs35l41->dev,\n\t\t\t\t\t      &soc_component_dev_cs35l41,\n\t\t\t\t\t      cs35l41_dai, ARRAY_SIZE(cs35l41_dai));\n\tif (ret < 0) {\n\t\tdev_err(cs35l41->dev, \"Register codec failed: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\tpm_runtime_put_autosuspend(cs35l41->dev);\n\n\tdev_info(cs35l41->dev, \"Cirrus Logic CS35L41 (%x), Revision: %02X\\n\",\n\t\t regid, reg_revid);\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_dont_use_autosuspend(cs35l41->dev);\n\tpm_runtime_disable(cs35l41->dev);\n\tpm_runtime_put_noidle(cs35l41->dev);\n\n\twm_adsp2_remove(&cs35l41->dsp);\nerr:\n\tcs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);\n\tregulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);\n\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs35l41_probe);\n\nvoid cs35l41_remove(struct cs35l41_private *cs35l41)\n{\n\tpm_runtime_get_sync(cs35l41->dev);\n\tpm_runtime_dont_use_autosuspend(cs35l41->dev);\n\tpm_runtime_disable(cs35l41->dev);\n\n\tregmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1, 0xFFFFFFFF);\n\tif (cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_PASS ||\n\t    cs35l41->hw_cfg.bst_type == CS35L41_SHD_BOOST_ACTV)\n\t\tregmap_update_bits(cs35l41->regmap, CS35L41_IRQ1_MASK3, CS35L41_INT3_PLL_LOCK_MASK,\n\t\t\t\t   1 << CS35L41_INT3_PLL_LOCK_SHIFT);\n\tkfree(cs35l41->dsp.system_name);\n\twm_adsp2_remove(&cs35l41->dsp);\n\tcs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);\n\n\tpm_runtime_put_noidle(cs35l41->dev);\n\n\tregulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);\n\tgpiod_set_value_cansleep(cs35l41->reset_gpio, 0);\n}\nEXPORT_SYMBOL_GPL(cs35l41_remove);\n\nstatic int __maybe_unused cs35l41_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"Runtime suspend\\n\");\n\n\tif (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)\n\t\treturn 0;\n\n\tcs35l41_enter_hibernate(dev, cs35l41->regmap, cs35l41->hw_cfg.bst_type);\n\n\tregcache_cache_only(cs35l41->regmap, true);\n\tregcache_mark_dirty(cs35l41->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l41_runtime_resume(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(cs35l41->dev, \"Runtime resume\\n\");\n\n\tif (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)\n\t\treturn 0;\n\n\tregcache_cache_only(cs35l41->regmap, false);\n\n\tret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tcs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);\n\tret = regcache_sync(cs35l41->regmap);\n\tcs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);\n\tif (ret) {\n\t\tdev_err(cs35l41->dev, \"Failed to restore register cache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l41_sys_suspend(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"System suspend, disabling IRQ\\n\");\n\tdisable_irq(cs35l41->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l41_sys_suspend_noirq(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"Late system suspend, reenabling IRQ\\n\");\n\tenable_irq(cs35l41->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l41_sys_resume_noirq(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"Early system resume, disabling IRQ\\n\");\n\tdisable_irq(cs35l41->irq);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l41_sys_resume(struct device *dev)\n{\n\tstruct cs35l41_private *cs35l41 = dev_get_drvdata(dev);\n\n\tdev_dbg(cs35l41->dev, \"System resume, reenabling IRQ\\n\");\n\tenable_irq(cs35l41->irq);\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops cs35l41_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)\n\n\tSET_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend, cs35l41_sys_resume)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend_noirq, cs35l41_sys_resume_noirq)\n};\nEXPORT_SYMBOL_GPL(cs35l41_pm_ops);\n\nMODULE_DESCRIPTION(\"ASoC CS35L41 driver\");\nMODULE_AUTHOR(\"David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}