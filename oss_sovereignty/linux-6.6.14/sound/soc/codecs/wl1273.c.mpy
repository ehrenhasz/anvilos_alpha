{
  "module_name": "wl1273.c",
  "hash_id": "1e4a6cee9c0b9599e11f708b99b55cfc1b95d70eb3e8c78c4584469304abe9fe",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wl1273.c",
  "human_readable_source": "\n \n\n#include <linux/mfd/wl1273-core.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include \"wl1273.h\"\n\nenum wl1273_mode { WL1273_MODE_BT, WL1273_MODE_FM_RX, WL1273_MODE_FM_TX };\n\n \nstruct wl1273_priv {\n\tenum wl1273_mode mode;\n\tstruct wl1273_core *core;\n\tunsigned int channels;\n};\n\nstatic int snd_wl1273_fm_set_i2s_mode(struct wl1273_core *core,\n\t\t\t\t      int rate, int width)\n{\n\tstruct device *dev = &core->client->dev;\n\tint r = 0;\n\tu16 mode;\n\n\tdev_dbg(dev, \"rate: %d\\n\", rate);\n\tdev_dbg(dev, \"width: %d\\n\", width);\n\n\tmutex_lock(&core->lock);\n\n\tmode = core->i2s_mode & ~WL1273_IS2_WIDTH & ~WL1273_IS2_RATE;\n\n\tswitch (rate) {\n\tcase 48000:\n\t\tmode |= WL1273_IS2_RATE_48K;\n\t\tbreak;\n\tcase 44100:\n\t\tmode |= WL1273_IS2_RATE_44_1K;\n\t\tbreak;\n\tcase 32000:\n\t\tmode |= WL1273_IS2_RATE_32K;\n\t\tbreak;\n\tcase 22050:\n\t\tmode |= WL1273_IS2_RATE_22_05K;\n\t\tbreak;\n\tcase 16000:\n\t\tmode |= WL1273_IS2_RATE_16K;\n\t\tbreak;\n\tcase 12000:\n\t\tmode |= WL1273_IS2_RATE_12K;\n\t\tbreak;\n\tcase 11025:\n\t\tmode |= WL1273_IS2_RATE_11_025;\n\t\tbreak;\n\tcase 8000:\n\t\tmode |= WL1273_IS2_RATE_8K;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Sampling rate: %d not supported\\n\", rate);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (width) {\n\tcase 16:\n\t\tmode |= WL1273_IS2_WIDTH_32;\n\t\tbreak;\n\tcase 20:\n\t\tmode |= WL1273_IS2_WIDTH_40;\n\t\tbreak;\n\tcase 24:\n\t\tmode |= WL1273_IS2_WIDTH_48;\n\t\tbreak;\n\tcase 25:\n\t\tmode |= WL1273_IS2_WIDTH_50;\n\t\tbreak;\n\tcase 30:\n\t\tmode |= WL1273_IS2_WIDTH_60;\n\t\tbreak;\n\tcase 32:\n\t\tmode |= WL1273_IS2_WIDTH_64;\n\t\tbreak;\n\tcase 40:\n\t\tmode |= WL1273_IS2_WIDTH_80;\n\t\tbreak;\n\tcase 48:\n\t\tmode |= WL1273_IS2_WIDTH_96;\n\t\tbreak;\n\tcase 64:\n\t\tmode |= WL1273_IS2_WIDTH_128;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Data width: %d not supported\\n\", width);\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(dev, \"WL1273_I2S_DEF_MODE: 0x%04x\\n\",  WL1273_I2S_DEF_MODE);\n\tdev_dbg(dev, \"core->i2s_mode: 0x%04x\\n\", core->i2s_mode);\n\tdev_dbg(dev, \"mode: 0x%04x\\n\", mode);\n\n\tif (core->i2s_mode != mode) {\n\t\tr = core->write(core, WL1273_I2S_MODE_CONFIG_SET, mode);\n\t\tif (r)\n\t\t\tgoto out;\n\n\t\tcore->i2s_mode = mode;\n\t\tr = core->write(core, WL1273_AUDIO_ENABLE,\n\t\t\t\tWL1273_AUDIO_ENABLE_I2S);\n\t\tif (r)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&core->lock);\n\n\treturn r;\n}\n\nstatic int snd_wl1273_fm_set_channel_number(struct wl1273_core *core,\n\t\t\t\t\t    int channel_number)\n{\n\tstruct device *dev = &core->client->dev;\n\tint r = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tmutex_lock(&core->lock);\n\n\tif (core->channel_number == channel_number)\n\t\tgoto out;\n\n\tif (channel_number == 1 && core->mode == WL1273_MODE_RX)\n\t\tr = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_MONO);\n\telse if (channel_number == 1 && core->mode == WL1273_MODE_TX)\n\t\tr = core->write(core, WL1273_MONO_SET, WL1273_TX_MONO);\n\telse if (channel_number == 2 && core->mode == WL1273_MODE_RX)\n\t\tr = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_STEREO);\n\telse if (channel_number == 2 && core->mode == WL1273_MODE_TX)\n\t\tr = core->write(core, WL1273_MONO_SET, WL1273_TX_STEREO);\n\telse\n\t\tr = -EINVAL;\nout:\n\tmutex_unlock(&core->lock);\n\n\treturn r;\n}\n\nstatic int snd_wl1273_get_audio_route(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wl1273->mode;\n\n\treturn 0;\n}\n\n \nstatic const char * const wl1273_audio_route[] = { \"Bt\", \"FmRx\", \"FmTx\" };\n\nstatic int snd_wl1273_set_audio_route(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tif (wl1273->mode == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\t \n\tif (snd_soc_component_active(component))\n\t\treturn -EPERM;\n\n\tif (ucontrol->value.enumerated.item[0] >=  ARRAY_SIZE(wl1273_audio_route))\n\t\treturn -EINVAL;\n\n\twl1273->mode = ucontrol->value.enumerated.item[0];\n\n\treturn 1;\n}\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(wl1273_enum, wl1273_audio_route);\n\nstatic int snd_wl1273_fm_audio_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s: enter.\\n\", __func__);\n\n\tucontrol->value.enumerated.item[0] = wl1273->core->audio_mode;\n\n\treturn 0;\n}\n\nstatic int snd_wl1273_fm_audio_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\tint val, r = 0;\n\n\tdev_dbg(component->dev, \"%s: enter.\\n\", __func__);\n\n\tval = ucontrol->value.enumerated.item[0];\n\tif (wl1273->core->audio_mode == val)\n\t\treturn 0;\n\n\tr = wl1273->core->set_audio(wl1273->core, val);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 1;\n}\n\nstatic const char * const wl1273_audio_strings[] = { \"Digital\", \"Analog\" };\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(wl1273_audio_enum, wl1273_audio_strings);\n\nstatic int snd_wl1273_fm_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s: enter.\\n\", __func__);\n\n\tucontrol->value.integer.value[0] = wl1273->core->volume;\n\n\treturn 0;\n}\n\nstatic int snd_wl1273_fm_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\tint r;\n\n\tdev_dbg(component->dev, \"%s: enter.\\n\", __func__);\n\n\tr = wl1273->core->set_volume(wl1273->core,\n\t\t\t\t     ucontrol->value.integer.value[0]);\n\tif (r)\n\t\treturn r;\n\n\treturn 1;\n}\n\nstatic const struct snd_kcontrol_new wl1273_controls[] = {\n\tSOC_ENUM_EXT(\"Codec Mode\", wl1273_enum,\n\t\t     snd_wl1273_get_audio_route, snd_wl1273_set_audio_route),\n\tSOC_ENUM_EXT(\"Audio Switch\", wl1273_audio_enum,\n\t\t     snd_wl1273_fm_audio_get,  snd_wl1273_fm_audio_put),\n\tSOC_SINGLE_EXT(\"Volume\", 0, 0, WL1273_MAX_VOLUME, 0,\n\t\t       snd_wl1273_fm_volume_get, snd_wl1273_fm_volume_put),\n};\n\nstatic const struct snd_soc_dapm_widget wl1273_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"RX\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"TX\"),\n};\n\nstatic const struct snd_soc_dapm_route wl1273_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"RX\" },\n\n\t{ \"TX\", NULL, \"Playback\" },\n};\n\nstatic int wl1273_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tswitch (wl1273->mode) {\n\tcase WL1273_MODE_BT:\n\t\tsnd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_RATE, 8000);\n\t\tsnd_pcm_hw_constraint_single(substream->runtime,\n\t\t\t\t\t     SNDRV_PCM_HW_PARAM_CHANNELS, 1);\n\t\tbreak;\n\tcase WL1273_MODE_FM_RX:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tpr_err(\"Cannot play in RX mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase WL1273_MODE_FM_TX:\n\t\tif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\t\tpr_err(\"Cannot capture in TX mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wl1273_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(dai->component);\n\tstruct wl1273_core *core = wl1273->core;\n\tunsigned int rate, width, r;\n\n\tif (params_width(params) != 16) {\n\t\tdev_err(dai->dev, \"%d bits/sample not supported\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\trate = params_rate(params);\n\twidth =  hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\n\n\tif (wl1273->mode == WL1273_MODE_BT) {\n\t\tif (rate != 8000) {\n\t\t\tpr_err(\"Rate %d not supported.\\n\", params_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (params_channels(params) != 1) {\n\t\t\tpr_err(\"Only mono supported.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (wl1273->mode == WL1273_MODE_FM_TX &&\n\t    substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tpr_err(\"Only playback supported with TX.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wl1273->mode == WL1273_MODE_FM_RX  &&\n\t    substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tpr_err(\"Only capture supported with RX.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wl1273->mode != WL1273_MODE_FM_RX  &&\n\t    wl1273->mode != WL1273_MODE_FM_TX) {\n\t\tpr_err(\"Unexpected mode: %d.\\n\", wl1273->mode);\n\t\treturn -EINVAL;\n\t}\n\n\tr = snd_wl1273_fm_set_i2s_mode(core, rate, width);\n\tif (r)\n\t\treturn r;\n\n\twl1273->channels = params_channels(params);\n\tr = snd_wl1273_fm_set_channel_number(core, wl1273->channels);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wl1273_dai_ops = {\n\t.startup\t= wl1273_startup,\n\t.hw_params\t= wl1273_hw_params,\n};\n\nstatic struct snd_soc_dai_driver wl1273_dai = {\n\t.name = \"wl1273-fm\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE},\n\t.ops = &wl1273_dai_ops,\n};\n\n \nint wl1273_get_format(struct snd_soc_component *component, unsigned int *fmt)\n{\n\tstruct wl1273_priv *wl1273;\n\n\tif (component == NULL || fmt == NULL)\n\t\treturn -EINVAL;\n\n\twl1273 = snd_soc_component_get_drvdata(component);\n\n\tswitch (wl1273->mode) {\n\tcase WL1273_MODE_FM_RX:\n\tcase WL1273_MODE_FM_TX:\n\t\t*fmt =\tSND_SOC_DAIFMT_I2S |\n\t\t\tSND_SOC_DAIFMT_NB_NF |\n\t\t\tSND_SOC_DAIFMT_CBP_CFP;\n\n\t\tbreak;\n\tcase WL1273_MODE_BT:\n\t\t*fmt =\tSND_SOC_DAIFMT_DSP_A |\n\t\t\tSND_SOC_DAIFMT_IB_NF |\n\t\t\tSND_SOC_DAIFMT_CBP_CFP;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wl1273_get_format);\n\nstatic int wl1273_probe(struct snd_soc_component *component)\n{\n\tstruct wl1273_core **core = component->dev->platform_data;\n\tstruct wl1273_priv *wl1273;\n\n\tdev_dbg(component->dev, \"%s.\\n\", __func__);\n\n\tif (!core) {\n\t\tdev_err(component->dev, \"Platform data is missing.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twl1273 = kzalloc(sizeof(struct wl1273_priv), GFP_KERNEL);\n\tif (!wl1273)\n\t\treturn -ENOMEM;\n\n\twl1273->mode = WL1273_MODE_BT;\n\twl1273->core = *core;\n\n\tsnd_soc_component_set_drvdata(component, wl1273);\n\n\treturn 0;\n}\n\nstatic void wl1273_remove(struct snd_soc_component *component)\n{\n\tstruct wl1273_priv *wl1273 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"%s\\n\", __func__);\n\tkfree(wl1273);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wl1273 = {\n\t.probe\t\t\t= wl1273_probe,\n\t.remove\t\t\t= wl1273_remove,\n\t.controls\t\t= wl1273_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wl1273_controls),\n\t.dapm_widgets\t\t= wl1273_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wl1273_dapm_widgets),\n\t.dapm_routes\t\t= wl1273_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wl1273_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wl1273_platform_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t      &soc_component_dev_wl1273,\n\t\t\t\t      &wl1273_dai, 1);\n}\n\nMODULE_ALIAS(\"platform:wl1273-codec\");\n\nstatic struct platform_driver wl1273_platform_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"wl1273-codec\",\n\t},\n\t.probe\t\t= wl1273_platform_probe,\n};\n\nmodule_platform_driver(wl1273_platform_driver);\n\nMODULE_AUTHOR(\"Matti Aaltonen <matti.j.aaltonen@nokia.com>\");\nMODULE_DESCRIPTION(\"ASoC WL1273 codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}