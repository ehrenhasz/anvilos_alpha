{
  "module_name": "wm1250-ev1.c",
  "hash_id": "eebf41cff09b2b799e32735c27f4e5b991fe8808896286de8ede53414508e7b9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm1250-ev1.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/wm1250-ev1.h>\n\nstatic const char *wm1250_gpio_names[WM1250_EV1_NUM_GPIOS] = {\n\t\"WM1250 CLK_ENA\",\n\t\"WM1250 CLK_SEL0\",\n\t\"WM1250 CLK_SEL1\",\n\t\"WM1250 OSR\",\n\t\"WM1250 MASTER\",\n};\n\nstruct wm1250_priv {\n\tstruct gpio gpios[WM1250_EV1_NUM_GPIOS];\n};\n\nstatic int wm1250_ev1_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t     enum snd_soc_bias_level level)\n{\n\tstruct wm1250_priv *wm1250 = dev_get_drvdata(component->dev);\n\tint ena;\n\n\tif (wm1250)\n\t\tena = wm1250->gpios[WM1250_EV1_GPIO_CLK_ENA].gpio;\n\telse\n\t\tena = -1;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (ena >= 0)\n\t\t\tgpio_set_value_cansleep(ena, 1);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (ena >= 0)\n\t\t\tgpio_set_value_cansleep(ena, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget wm1250_ev1_dapm_widgets[] = {\nSND_SOC_DAPM_ADC(\"ADC\", \"wm1250-ev1 Capture\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_DAC(\"DAC\", \"wm1250-ev1 Playback\", SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_INPUT(\"WM1250 Input\"),\nSND_SOC_DAPM_OUTPUT(\"WM1250 Output\"),\n};\n\nstatic const struct snd_soc_dapm_route wm1250_ev1_dapm_routes[] = {\n\t{ \"ADC\", NULL, \"WM1250 Input\" },\n\t{ \"WM1250 Output\", NULL, \"DAC\" },\n};\n\nstatic int wm1250_ev1_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct wm1250_priv *wm1250 = snd_soc_component_get_drvdata(dai->component);\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].gpio,\n\t\t\t       1);\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].gpio,\n\t\t\t       1);\n\t\tbreak;\n\tcase 16000:\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].gpio,\n\t\t\t       0);\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].gpio,\n\t\t\t       1);\n\t\tbreak;\n\tcase 32000:\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].gpio,\n\t\t\t       1);\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].gpio,\n\t\t\t       0);\n\t\tbreak;\n\tcase 64000:\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].gpio,\n\t\t\t       0);\n\t\tgpio_set_value(wm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].gpio,\n\t\t\t       0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wm1250_ev1_ops = {\n\t.hw_params = wm1250_ev1_hw_params,\n};\n\n#define WM1250_EV1_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\\\n\t\t\t  SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_64000)\n\nstatic struct snd_soc_dai_driver wm1250_ev1_dai = {\n\t.name = \"wm1250-ev1\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM1250_EV1_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM1250_EV1_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &wm1250_ev1_ops,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm1250_ev1 = {\n\t.dapm_widgets\t\t= wm1250_ev1_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm1250_ev1_dapm_widgets),\n\t.dapm_routes\t\t= wm1250_ev1_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm1250_ev1_dapm_routes),\n\t.set_bias_level\t\t= wm1250_ev1_set_bias_level,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int wm1250_ev1_pdata(struct i2c_client *i2c)\n{\n\tstruct wm1250_ev1_pdata *pdata = dev_get_platdata(&i2c->dev);\n\tstruct wm1250_priv *wm1250;\n\tint i, ret;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\twm1250 = devm_kzalloc(&i2c->dev, sizeof(*wm1250), GFP_KERNEL);\n\tif (!wm1250) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm1250->gpios); i++) {\n\t\twm1250->gpios[i].gpio = pdata->gpios[i];\n\t\twm1250->gpios[i].label = wm1250_gpio_names[i];\n\t\twm1250->gpios[i].flags = GPIOF_OUT_INIT_LOW;\n\t}\n\twm1250->gpios[WM1250_EV1_GPIO_CLK_SEL0].flags = GPIOF_OUT_INIT_HIGH;\n\twm1250->gpios[WM1250_EV1_GPIO_CLK_SEL1].flags = GPIOF_OUT_INIT_HIGH;\n\n\tret = gpio_request_array(wm1250->gpios, ARRAY_SIZE(wm1250->gpios));\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to get GPIOs: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdev_set_drvdata(&i2c->dev, wm1250);\n\n\treturn ret;\n\nerr:\n\treturn ret;\n}\n\nstatic void wm1250_ev1_free(struct i2c_client *i2c)\n{\n\tstruct wm1250_priv *wm1250 = dev_get_drvdata(&i2c->dev);\n\n\tif (wm1250)\n\t\tgpio_free_array(wm1250->gpios, ARRAY_SIZE(wm1250->gpios));\n}\n\nstatic int wm1250_ev1_probe(struct i2c_client *i2c)\n{\n\tint id, board, rev, ret;\n\n\tdev_set_drvdata(&i2c->dev, NULL);\n\n\tboard = i2c_smbus_read_byte_data(i2c, 0);\n\tif (board < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read ID: %d\\n\", board);\n\t\treturn board;\n\t}\n\n\tid = (board & 0xfe) >> 2;\n\trev = board & 0x3;\n\n\tif (id != 1) {\n\t\tdev_err(&i2c->dev, \"Unknown board ID %d\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&i2c->dev, \"revision %d\\n\", rev + 1);\n\n\tret = wm1250_ev1_pdata(i2c);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tret = devm_snd_soc_register_component(&i2c->dev, &soc_component_dev_wm1250_ev1,\n\t\t\t\t     &wm1250_ev1_dai, 1);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\twm1250_ev1_free(i2c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void wm1250_ev1_remove(struct i2c_client *i2c)\n{\n\twm1250_ev1_free(i2c);\n}\n\nstatic const struct i2c_device_id wm1250_ev1_i2c_id[] = {\n\t{ \"wm1250-ev1\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm1250_ev1_i2c_id);\n\nstatic struct i2c_driver wm1250_ev1_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm1250-ev1\",\n\t},\n\t.probe =    wm1250_ev1_probe,\n\t.remove =   wm1250_ev1_remove,\n\t.id_table = wm1250_ev1_i2c_id,\n};\n\nmodule_i2c_driver(wm1250_ev1_i2c_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM1250-EV1 audio I/O module driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}