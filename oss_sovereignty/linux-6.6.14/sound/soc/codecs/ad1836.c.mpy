{
  "module_name": "ad1836.c",
  "hash_id": "7809b45b433b54846434e4c424db334d96db497b9abad059f6d8aabc2c258888",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ad1836.c",
  "human_readable_source": "\n  \n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n\n#include \"ad1836.h\"\n\nenum ad1836_type {\n\tAD1835,\n\tAD1836,\n\tAD1838,\n};\n\n \nstruct ad1836_priv {\n\tenum ad1836_type type;\n\tstruct regmap *regmap;\n};\n\n \nstatic const char *ad1836_deemp[] = {\"None\", \"44.1kHz\", \"32kHz\", \"48kHz\"};\n\nstatic SOC_ENUM_SINGLE_DECL(ad1836_deemp_enum,\n\t\t\t    AD1836_DAC_CTRL1, 8, ad1836_deemp);\n\n#define AD1836_DAC_VOLUME(x) \\\n\tSOC_DOUBLE_R(\"DAC\" #x \" Playback Volume\", AD1836_DAC_L_VOL(x), \\\n\t\t\tAD1836_DAC_R_VOL(x), 0, 0x3FF, 0)\n\n#define AD1836_DAC_SWITCH(x) \\\n\tSOC_DOUBLE(\"DAC\" #x \" Playback Switch\", AD1836_DAC_CTRL2, \\\n\t\t\tAD1836_MUTE_LEFT(x), AD1836_MUTE_RIGHT(x), 1, 1)\n\n#define AD1836_ADC_SWITCH(x) \\\n\tSOC_DOUBLE(\"ADC\" #x \" Capture Switch\", AD1836_ADC_CTRL2, \\\n\t\tAD1836_MUTE_LEFT(x), AD1836_MUTE_RIGHT(x), 1, 1)\n\nstatic const struct snd_kcontrol_new ad183x_dac_controls[] = {\n\tAD1836_DAC_VOLUME(1),\n\tAD1836_DAC_SWITCH(1),\n\tAD1836_DAC_VOLUME(2),\n\tAD1836_DAC_SWITCH(2),\n\tAD1836_DAC_VOLUME(3),\n\tAD1836_DAC_SWITCH(3),\n\tAD1836_DAC_VOLUME(4),\n\tAD1836_DAC_SWITCH(4),\n};\n\nstatic const struct snd_soc_dapm_widget ad183x_dac_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"DAC1OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"DAC2OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"DAC3OUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"DAC4OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route ad183x_dac_routes[] = {\n\t{ \"DAC1OUT\", NULL, \"DAC\" },\n\t{ \"DAC2OUT\", NULL, \"DAC\" },\n\t{ \"DAC3OUT\", NULL, \"DAC\" },\n\t{ \"DAC4OUT\", NULL, \"DAC\" },\n};\n\nstatic const struct snd_kcontrol_new ad183x_adc_controls[] = {\n\tAD1836_ADC_SWITCH(1),\n\tAD1836_ADC_SWITCH(2),\n\tAD1836_ADC_SWITCH(3),\n};\n\nstatic const struct snd_soc_dapm_widget ad183x_adc_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"ADC1IN\"),\n\tSND_SOC_DAPM_INPUT(\"ADC2IN\"),\n};\n\nstatic const struct snd_soc_dapm_route ad183x_adc_routes[] = {\n\t{ \"ADC\", NULL, \"ADC1IN\" },\n\t{ \"ADC\", NULL, \"ADC2IN\" },\n};\n\nstatic const struct snd_kcontrol_new ad183x_controls[] = {\n\t \n\tSOC_SINGLE(\"ADC High Pass Filter Switch\", AD1836_ADC_CTRL1,\n\t\t\tAD1836_ADC_HIGHPASS_FILTER, 1, 0),\n\n\t \n\tSOC_ENUM(\"Playback Deemphasis\", ad1836_deemp_enum),\n};\n\nstatic const struct snd_soc_dapm_widget ad183x_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", AD1836_DAC_CTRL1,\n\t\t\t\tAD1836_DAC_POWERDOWN, 1),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC_PWR\", AD1836_ADC_CTRL1,\n\t\t\t\tAD1836_ADC_POWERDOWN, 1, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route ad183x_dapm_routes[] = {\n\t{ \"DAC\", NULL, \"ADC_PWR\" },\n\t{ \"ADC\", NULL, \"ADC_PWR\" },\n};\n\nstatic const DECLARE_TLV_DB_SCALE(ad1836_in_tlv, 0, 300, 0);\n\nstatic const struct snd_kcontrol_new ad1836_controls[] = {\n\tSOC_DOUBLE_TLV(\"ADC2 Capture Volume\", AD1836_ADC_CTRL1, 3, 0, 4, 0,\n\t    ad1836_in_tlv),\n};\n\n \n\nstatic int ad1836_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t \n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t \n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ad1836_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct ad1836_priv *ad1836 = snd_soc_component_get_drvdata(dai->component);\n\tint word_len = 0;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tword_len = AD1836_WORD_LEN_16;\n\t\tbreak;\n\tcase 20:\n\t\tword_len = AD1836_WORD_LEN_20;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\tword_len = AD1836_WORD_LEN_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(ad1836->regmap, AD1836_DAC_CTRL1,\n\t\tAD1836_DAC_WORD_LEN_MASK,\n\t\tword_len << AD1836_DAC_WORD_LEN_OFFSET);\n\n\tregmap_update_bits(ad1836->regmap, AD1836_ADC_CTRL2,\n\t\tAD1836_ADC_WORD_LEN_MASK,\n\t\tword_len << AD1836_ADC_WORD_OFFSET);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ad1836_dai_ops = {\n\t.hw_params = ad1836_hw_params,\n\t.set_fmt = ad1836_set_dai_fmt,\n};\n\n#define AD183X_DAI(_name, num_dacs, num_adcs) \\\n{ \\\n\t.name = _name \"-hifi\", \\\n\t.playback = { \\\n\t\t.stream_name = \"Playback\", \\\n\t\t.channels_min = 2, \\\n\t\t.channels_max = (num_dacs) * 2, \\\n\t\t.rates = SNDRV_PCM_RATE_48000,  \\\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE, \\\n\t}, \\\n\t.capture = { \\\n\t\t.stream_name = \"Capture\", \\\n\t\t.channels_min = 2, \\\n\t\t.channels_max = (num_adcs) * 2, \\\n\t\t.rates = SNDRV_PCM_RATE_48000, \\\n\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE, \\\n\t}, \\\n\t.ops = &ad1836_dai_ops, \\\n}\n\nstatic struct snd_soc_dai_driver ad183x_dais[] = {\n\t[AD1835] = AD183X_DAI(\"ad1835\", 4, 1),\n\t[AD1836] = AD183X_DAI(\"ad1836\", 3, 2),\n\t[AD1838] = AD183X_DAI(\"ad1838\", 3, 1),\n};\n\n#ifdef CONFIG_PM\nstatic int ad1836_suspend(struct snd_soc_component *component)\n{\n\tstruct ad1836_priv *ad1836 = snd_soc_component_get_drvdata(component);\n\t \n\treturn regmap_update_bits(ad1836->regmap, AD1836_ADC_CTRL2,\n\t\tAD1836_ADC_SERFMT_MASK, 0);\n}\n\nstatic int ad1836_resume(struct snd_soc_component *component)\n{\n\tstruct ad1836_priv *ad1836 = snd_soc_component_get_drvdata(component);\n\t \n\treturn regmap_update_bits(ad1836->regmap, AD1836_ADC_CTRL2,\n\t\tAD1836_ADC_SERFMT_MASK, AD1836_ADC_AUX);\n}\n#else\n#define ad1836_suspend NULL\n#define ad1836_resume  NULL\n#endif\n\nstatic int ad1836_probe(struct snd_soc_component *component)\n{\n\tstruct ad1836_priv *ad1836 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint num_dacs, num_adcs;\n\tint ret = 0;\n\tint i;\n\n\tnum_dacs = ad183x_dais[ad1836->type].playback.channels_max / 2;\n\tnum_adcs = ad183x_dais[ad1836->type].capture.channels_max / 2;\n\n\t \n\t \n\tregmap_write(ad1836->regmap, AD1836_DAC_CTRL1, 0x300);\n\t \n\tregmap_write(ad1836->regmap, AD1836_DAC_CTRL2, 0x0);\n\t \n\tregmap_write(ad1836->regmap, AD1836_ADC_CTRL1, 0x100);\n\t \n\tregmap_write(ad1836->regmap, AD1836_ADC_CTRL2, 0x180);\n\t \n\tfor (i = 1; i <= num_dacs; ++i) {\n\t\tregmap_write(ad1836->regmap, AD1836_DAC_L_VOL(i), 0x3FF);\n\t\tregmap_write(ad1836->regmap, AD1836_DAC_R_VOL(i), 0x3FF);\n\t}\n\n\tif (ad1836->type == AD1836) {\n\t\t \n\t\tregmap_write(ad1836->regmap, AD1836_ADC_CTRL3, 0x3A);\n\t\tret = snd_soc_add_component_controls(component, ad1836_controls,\n\t\t\t\tARRAY_SIZE(ad1836_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tregmap_write(ad1836->regmap, AD1836_ADC_CTRL3, 0x00);\n\t}\n\n\tret = snd_soc_add_component_controls(component, ad183x_dac_controls, num_dacs * 2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_add_component_controls(component, ad183x_adc_controls, num_adcs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_new_controls(dapm, ad183x_dac_dapm_widgets, num_dacs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_new_controls(dapm, ad183x_adc_dapm_widgets, num_adcs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_add_routes(dapm, ad183x_dac_routes, num_dacs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_add_routes(dapm, ad183x_adc_routes, num_adcs);\n\n\treturn ret;\n}\n\n \nstatic void ad1836_remove(struct snd_soc_component *component)\n{\n\tstruct ad1836_priv *ad1836 = snd_soc_component_get_drvdata(component);\n\t \n\tregmap_update_bits(ad1836->regmap, AD1836_ADC_CTRL2,\n\t\tAD1836_ADC_SERFMT_MASK, 0);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ad1836 = {\n\t.probe\t\t\t= ad1836_probe,\n\t.remove\t\t\t= ad1836_remove,\n\t.suspend\t\t= ad1836_suspend,\n\t.resume\t\t\t= ad1836_resume,\n\t.controls\t\t= ad183x_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ad183x_controls),\n\t.dapm_widgets\t\t= ad183x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ad183x_dapm_widgets),\n\t.dapm_routes\t\t= ad183x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ad183x_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct reg_default ad1836_reg_defaults[] = {\n\t{ AD1836_DAC_CTRL1, 0x0000 },\n\t{ AD1836_DAC_CTRL2, 0x0000 },\n\t{ AD1836_DAC_L_VOL(0), 0x0000 },\n\t{ AD1836_DAC_R_VOL(0), 0x0000 },\n\t{ AD1836_DAC_L_VOL(1), 0x0000 },\n\t{ AD1836_DAC_R_VOL(1), 0x0000 },\n\t{ AD1836_DAC_L_VOL(2), 0x0000 },\n\t{ AD1836_DAC_R_VOL(2), 0x0000 },\n\t{ AD1836_DAC_L_VOL(3), 0x0000 },\n\t{ AD1836_DAC_R_VOL(3), 0x0000 },\n\t{ AD1836_ADC_CTRL1, 0x0000 },\n\t{ AD1836_ADC_CTRL2, 0x0000 },\n\t{ AD1836_ADC_CTRL3, 0x0000 },\n};\n\nstatic const struct regmap_config ad1836_regmap_config = {\n\t.val_bits = 12,\n\t.reg_bits = 4,\n\t.read_flag_mask = 0x08,\n\n\t.max_register = AD1836_ADC_CTRL3,\n\t.reg_defaults = ad1836_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ad1836_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int ad1836_spi_probe(struct spi_device *spi)\n{\n\tstruct ad1836_priv *ad1836;\n\tint ret;\n\n\tad1836 = devm_kzalloc(&spi->dev, sizeof(struct ad1836_priv),\n\t\t\t      GFP_KERNEL);\n\tif (ad1836 == NULL)\n\t\treturn -ENOMEM;\n\n\tad1836->regmap = devm_regmap_init_spi(spi, &ad1836_regmap_config);\n\tif (IS_ERR(ad1836->regmap))\n\t\treturn PTR_ERR(ad1836->regmap);\n\n\tad1836->type = spi_get_device_id(spi)->driver_data;\n\n\tspi_set_drvdata(spi, ad1836);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_dev_ad1836, &ad183x_dais[ad1836->type], 1);\n\treturn ret;\n}\n\nstatic const struct spi_device_id ad1836_ids[] = {\n\t{ \"ad1835\", AD1835 },\n\t{ \"ad1836\", AD1836 },\n\t{ \"ad1837\", AD1835 },\n\t{ \"ad1838\", AD1838 },\n\t{ \"ad1839\", AD1838 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, ad1836_ids);\n\nstatic struct spi_driver ad1836_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"ad1836\",\n\t},\n\t.probe\t\t= ad1836_spi_probe,\n\t.id_table\t= ad1836_ids,\n};\n\nmodule_spi_driver(ad1836_spi_driver);\n\nMODULE_DESCRIPTION(\"ASoC ad1836 driver\");\nMODULE_AUTHOR(\"Barry Song <21cnbao@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}