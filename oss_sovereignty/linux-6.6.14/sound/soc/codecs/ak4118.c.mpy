{
  "module_name": "ak4118.c",
  "hash_id": "ee476ca0b7ae6d74b2c40461086c9604ea8e12bb50bc5198e6b137a223e636d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4118.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <sound/asoundef.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n\n#define AK4118_REG_CLK_PWR_CTL\t\t0x00\n#define AK4118_REG_FORMAT_CTL\t\t0x01\n#define AK4118_REG_IO_CTL0\t\t0x02\n#define AK4118_REG_IO_CTL1\t\t0x03\n#define AK4118_REG_INT0_MASK\t\t0x04\n#define AK4118_REG_INT1_MASK\t\t0x05\n#define AK4118_REG_RCV_STATUS0\t\t0x06\n#define AK4118_REG_RCV_STATUS1\t\t0x07\n#define AK4118_REG_RXCHAN_STATUS0\t0x08\n#define AK4118_REG_RXCHAN_STATUS1\t0x09\n#define AK4118_REG_RXCHAN_STATUS2\t0x0a\n#define AK4118_REG_RXCHAN_STATUS3\t0x0b\n#define AK4118_REG_RXCHAN_STATUS4\t0x0c\n#define AK4118_REG_TXCHAN_STATUS0\t0x0d\n#define AK4118_REG_TXCHAN_STATUS1\t0x0e\n#define AK4118_REG_TXCHAN_STATUS2\t0x0f\n#define AK4118_REG_TXCHAN_STATUS3\t0x10\n#define AK4118_REG_TXCHAN_STATUS4\t0x11\n#define AK4118_REG_BURST_PREAMB_PC0\t0x12\n#define AK4118_REG_BURST_PREAMB_PC1\t0x13\n#define AK4118_REG_BURST_PREAMB_PD0\t0x14\n#define AK4118_REG_BURST_PREAMB_PD1\t0x15\n#define AK4118_REG_QSUB_CTL\t\t0x16\n#define AK4118_REG_QSUB_TRACK\t\t0x17\n#define AK4118_REG_QSUB_INDEX\t\t0x18\n#define AK4118_REG_QSUB_MIN\t\t0x19\n#define AK4118_REG_QSUB_SEC\t\t0x1a\n#define AK4118_REG_QSUB_FRAME\t\t0x1b\n#define AK4118_REG_QSUB_ZERO\t\t0x1c\n#define AK4118_REG_QSUB_ABS_MIN\t\t0x1d\n#define AK4118_REG_QSUB_ABS_SEC\t\t0x1e\n#define AK4118_REG_QSUB_ABS_FRAME\t0x1f\n#define AK4118_REG_GPE\t\t\t0x20\n#define AK4118_REG_GPDR\t\t\t0x21\n#define AK4118_REG_GPSCR\t\t0x22\n#define AK4118_REG_GPLR\t\t\t0x23\n#define AK4118_REG_DAT_MASK_DTS\t\t0x24\n#define AK4118_REG_RX_DETECT\t\t0x25\n#define AK4118_REG_STC_DAT_DETECT\t0x26\n#define AK4118_REG_RXCHAN_STATUS5\t0x27\n#define AK4118_REG_TXCHAN_STATUS5\t0x28\n#define AK4118_REG_MAX\t\t\t0x29\n\n#define AK4118_REG_FORMAT_CTL_DIF0\t(1 << 4)\n#define AK4118_REG_FORMAT_CTL_DIF1\t(1 << 5)\n#define AK4118_REG_FORMAT_CTL_DIF2\t(1 << 6)\n\nstruct ak4118_priv {\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *irq;\n\tstruct snd_soc_component *component;\n};\n\nstatic const struct reg_default ak4118_reg_defaults[] = {\n\t{AK4118_REG_CLK_PWR_CTL,\t0x43},\n\t{AK4118_REG_FORMAT_CTL,\t\t0x6a},\n\t{AK4118_REG_IO_CTL0,\t\t0x88},\n\t{AK4118_REG_IO_CTL1,\t\t0x48},\n\t{AK4118_REG_INT0_MASK,\t\t0xee},\n\t{AK4118_REG_INT1_MASK,\t\t0xb5},\n\t{AK4118_REG_RCV_STATUS0,\t0x00},\n\t{AK4118_REG_RCV_STATUS1,\t0x10},\n\t{AK4118_REG_TXCHAN_STATUS0,\t0x00},\n\t{AK4118_REG_TXCHAN_STATUS1,\t0x00},\n\t{AK4118_REG_TXCHAN_STATUS2,\t0x00},\n\t{AK4118_REG_TXCHAN_STATUS3,\t0x00},\n\t{AK4118_REG_TXCHAN_STATUS4,\t0x00},\n\t{AK4118_REG_GPE,\t\t0x77},\n\t{AK4118_REG_GPDR,\t\t0x00},\n\t{AK4118_REG_GPSCR,\t\t0x00},\n\t{AK4118_REG_GPLR,\t\t0x00},\n\t{AK4118_REG_DAT_MASK_DTS,\t0x3f},\n\t{AK4118_REG_RX_DETECT,\t\t0x00},\n\t{AK4118_REG_STC_DAT_DETECT,\t0x00},\n\t{AK4118_REG_TXCHAN_STATUS5,\t0x00},\n};\n\nstatic const char * const ak4118_input_select_txt[] = {\n\t\"RX0\", \"RX1\", \"RX2\", \"RX3\", \"RX4\", \"RX5\", \"RX6\", \"RX7\",\n};\nstatic SOC_ENUM_SINGLE_DECL(ak4118_insel_enum, AK4118_REG_IO_CTL1, 0x0,\n\t\t\t    ak4118_input_select_txt);\n\nstatic const struct snd_kcontrol_new ak4118_input_mux_controls =\n\tSOC_DAPM_ENUM(\"Input Select\", ak4118_insel_enum);\n\nstatic const char * const ak4118_iec958_fs_txt[] = {\n\t\"44100\", \"48000\", \"32000\", \"22050\", \"11025\", \"24000\", \"16000\", \"88200\",\n\t\"8000\", \"96000\", \"64000\", \"176400\", \"192000\",\n};\n\nstatic const int ak4118_iec958_fs_val[] = {\n\t0x0, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xE,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(ak4118_iec958_fs_enum, AK4118_REG_RCV_STATUS1,\n\t\t\t\t  0x4, 0x4, ak4118_iec958_fs_txt,\n\t\t\t\t  ak4118_iec958_fs_val);\n\nstatic struct snd_kcontrol_new ak4118_iec958_controls[] = {\n\tSOC_SINGLE(\"IEC958 Parity Errors\", AK4118_REG_RCV_STATUS0, 0, 1, 0),\n\tSOC_SINGLE(\"IEC958 No Audio\", AK4118_REG_RCV_STATUS0, 1, 1, 0),\n\tSOC_SINGLE(\"IEC958 PLL Lock\", AK4118_REG_RCV_STATUS0, 4, 1, 1),\n\tSOC_SINGLE(\"IEC958 Non PCM\", AK4118_REG_RCV_STATUS0, 6, 1, 0),\n\tSOC_ENUM(\"IEC958 Sampling Freq\", ak4118_iec958_fs_enum),\n};\n\nstatic const struct snd_soc_dapm_widget ak4118_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"INRX0\"),\n\tSND_SOC_DAPM_INPUT(\"INRX1\"),\n\tSND_SOC_DAPM_INPUT(\"INRX2\"),\n\tSND_SOC_DAPM_INPUT(\"INRX3\"),\n\tSND_SOC_DAPM_INPUT(\"INRX4\"),\n\tSND_SOC_DAPM_INPUT(\"INRX5\"),\n\tSND_SOC_DAPM_INPUT(\"INRX6\"),\n\tSND_SOC_DAPM_INPUT(\"INRX7\"),\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &ak4118_input_mux_controls),\n};\n\nstatic const struct snd_soc_dapm_route ak4118_dapm_routes[] = {\n\t{\"Input Mux\", \"RX0\", \"INRX0\"},\n\t{\"Input Mux\", \"RX1\", \"INRX1\"},\n\t{\"Input Mux\", \"RX2\", \"INRX2\"},\n\t{\"Input Mux\", \"RX3\", \"INRX3\"},\n\t{\"Input Mux\", \"RX4\", \"INRX4\"},\n\t{\"Input Mux\", \"RX5\", \"INRX5\"},\n\t{\"Input Mux\", \"RX6\", \"INRX6\"},\n\t{\"Input Mux\", \"RX7\", \"INRX7\"},\n};\n\n\nstatic int ak4118_set_dai_fmt_provider(struct ak4118_priv *ak4118,\n\t\t\t\t       unsigned int format)\n{\n\tint dif;\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdif = AK4118_REG_FORMAT_CTL_DIF0 | AK4118_REG_FORMAT_CTL_DIF2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdif = AK4118_REG_FORMAT_CTL_DIF0 | AK4118_REG_FORMAT_CTL_DIF1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdif = AK4118_REG_FORMAT_CTL_DIF2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn dif;\n}\n\nstatic int ak4118_set_dai_fmt_consumer(struct ak4118_priv *ak4118,\n\t\t\t\t       unsigned int format)\n{\n\tint dif;\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdif = AK4118_REG_FORMAT_CTL_DIF0 | AK4118_REG_FORMAT_CTL_DIF1 |\n\t\t      AK4118_REG_FORMAT_CTL_DIF2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdif = AK4118_REG_FORMAT_CTL_DIF1 | AK4118_REG_FORMAT_CTL_DIF2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn dif;\n}\n\nstatic int ak4118_set_dai_fmt(struct snd_soc_dai *dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4118_priv *ak4118 = snd_soc_component_get_drvdata(component);\n\tint dif;\n\tint ret = 0;\n\n\tswitch (format & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tdif = ak4118_set_dai_fmt_provider(ak4118, format);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tdif = ak4118_set_dai_fmt_consumer(ak4118, format);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dif < 0) {\n\t\tret = dif;\n\t\tgoto exit;\n\t}\n\n\tret = regmap_update_bits(ak4118->regmap, AK4118_REG_FORMAT_CTL,\n\t\t\t\t AK4118_REG_FORMAT_CTL_DIF0 |\n\t\t\t\t AK4118_REG_FORMAT_CTL_DIF1 |\n\t\t\t\t AK4118_REG_FORMAT_CTL_DIF2, dif);\n\tif (ret < 0)\n\t\tgoto exit;\n\nexit:\n\treturn ret;\n}\n\nstatic int ak4118_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ak4118_dai_ops = {\n\t.hw_params = ak4118_hw_params,\n\t.set_fmt   = ak4118_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver ak4118_dai = {\n\t.name = \"ak4118-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 |\n\t\t\t SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\n\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\n\t\t\t SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE  |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_3LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE\n\t},\n\t.ops = &ak4118_dai_ops,\n};\n\nstatic irqreturn_t ak4118_irq_handler(int irq, void *data)\n{\n\tstruct ak4118_priv *ak4118 = data;\n\tstruct snd_soc_component *component = ak4118->component;\n\tstruct snd_kcontrol_new *kctl_new;\n\tunsigned int i;\n\n\tif (!component)\n\t\treturn IRQ_NONE;\n\n\tfor (i = 0; i < ARRAY_SIZE(ak4118_iec958_controls); i++) {\n\t\tkctl_new = &ak4118_iec958_controls[i];\n\n\t\tsnd_soc_component_notify_control(component, kctl_new->name);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ak4118_probe(struct snd_soc_component *component)\n{\n\tstruct ak4118_priv *ak4118 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tak4118->component = component;\n\n\t \n\tgpiod_set_value(ak4118->reset, 0);\n\n\t \n\tret = regmap_write(ak4118->regmap, AK4118_REG_INT1_MASK, 0x00);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"failed to write regmap 0x%x 0x%x: %d\\n\",\n\t\t\tAK4118_REG_INT1_MASK, 0x00, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(ak4118->regmap, AK4118_REG_RX_DETECT, 0xff);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"failed to write regmap 0x%x 0x%x: %d\\n\",\n\t\t\tAK4118_REG_RX_DETECT, 0xff, ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_add_component_controls(component, ak4118_iec958_controls,\n\t\t\t\t\t ARRAY_SIZE(ak4118_iec958_controls));\n\tif (ret) {\n\t\tdev_err(component->dev,\n\t\t\t\"failed to add component kcontrols: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ak4118_remove(struct snd_soc_component *component)\n{\n\tstruct ak4118_priv *ak4118 = snd_soc_component_get_drvdata(component);\n\n\t \n\tgpiod_set_value(ak4118->reset, 1);\n}\n\nstatic const struct snd_soc_component_driver soc_component_drv_ak4118 = {\n\t.probe\t\t\t= ak4118_probe,\n\t.remove\t\t\t= ak4118_remove,\n\t.dapm_widgets\t\t= ak4118_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4118_dapm_widgets),\n\t.dapm_routes\t\t= ak4118_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4118_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4118_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = ak4118_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ak4118_reg_defaults),\n\n\t.cache_type = REGCACHE_NONE,\n\t.max_register = AK4118_REG_MAX - 1,\n};\n\nstatic int ak4118_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak4118_priv *ak4118;\n\tint ret;\n\n\tak4118 = devm_kzalloc(&i2c->dev, sizeof(struct ak4118_priv),\n\t\t\t      GFP_KERNEL);\n\tif (ak4118 == NULL)\n\t\treturn -ENOMEM;\n\n\tak4118->regmap = devm_regmap_init_i2c(i2c, &ak4118_regmap);\n\tif (IS_ERR(ak4118->regmap))\n\t\treturn PTR_ERR(ak4118->regmap);\n\n\ti2c_set_clientdata(i2c, ak4118);\n\n\tak4118->reset = devm_gpiod_get(&i2c->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ak4118->reset))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(ak4118->reset),\n\t\t\t\t     \"Failed to get reset\\n\");\n\n\tak4118->irq = devm_gpiod_get(&i2c->dev, \"irq\", GPIOD_IN);\n\tif (IS_ERR(ak4118->irq))\n\t\treturn dev_err_probe(&i2c->dev, PTR_ERR(ak4118->irq),\n\t\t\t\t     \"Failed to get IRQ\\n\");\n\n\tret = devm_request_threaded_irq(&i2c->dev, gpiod_to_irq(ak4118->irq),\n\t\t\t\t\tNULL, ak4118_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"ak4118-irq\", ak4118);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Fail to request_irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_component_drv_ak4118, &ak4118_dai, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ak4118_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4118\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ak4118_of_match);\n#endif\n\nstatic const struct i2c_device_id ak4118_id_table[] = {\n\t{ \"ak4118\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ak4118_id_table);\n\nstatic struct i2c_driver ak4118_i2c_driver = {\n\t.driver  = {\n\t\t.name = \"ak4118\",\n\t\t.of_match_table = of_match_ptr(ak4118_of_match),\n\t},\n\t.id_table = ak4118_id_table,\n\t.probe = ak4118_i2c_probe,\n};\n\nmodule_i2c_driver(ak4118_i2c_driver);\n\nMODULE_DESCRIPTION(\"Asahi Kasei AK4118 ALSA SoC driver\");\nMODULE_AUTHOR(\"Adrien Charruel <adrien.charruel@devialet.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}