{
  "module_name": "wm8988.c",
  "hash_id": "76f31eb1919e07f155a8fc0d40c3c1dc6ff5cd82094405a0c811a98fef4bc9f2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8988.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include \"wm8988.h\"\n\n \nstatic const struct reg_default wm8988_reg_defaults[] = {\n\t{ 0, 0x0097 },\n\t{ 1, 0x0097 },\n\t{ 2, 0x0079 },\n\t{ 3, 0x0079 },\n\t{ 5, 0x0008 },\n\t{ 7, 0x000a },\n\t{ 8, 0x0000 },\n\t{ 10, 0x00ff },\n\t{ 11, 0x00ff },\n\t{ 12, 0x000f },\n\t{ 13, 0x000f },\n\t{ 16, 0x0000 },\n\t{ 17, 0x007b },\n\t{ 18, 0x0000 },\n\t{ 19, 0x0032 },\n\t{ 20, 0x0000 },\n\t{ 21, 0x00c3 },\n\t{ 22, 0x00c3 },\n\t{ 23, 0x00c0 },\n\t{ 24, 0x0000 },\n\t{ 25, 0x0000 },\n\t{ 26, 0x0000 },\n\t{ 27, 0x0000 },\n\t{ 31, 0x0000 },\n\t{ 32, 0x0000 },\n\t{ 33, 0x0000 },\n\t{ 34, 0x0050 },\n\t{ 35, 0x0050 },\n\t{ 36, 0x0050 },\n\t{ 37, 0x0050 },\n\t{ 40, 0x0079 },\n\t{ 41, 0x0079 },\n\t{ 42, 0x0079 },\n};\n\nstatic bool wm8988_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8988_LINVOL:\n\tcase WM8988_RINVOL:\n\tcase WM8988_LOUT1V:\n\tcase WM8988_ROUT1V:\n\tcase WM8988_ADCDAC:\n\tcase WM8988_IFACE:\n\tcase WM8988_SRATE:\n\tcase WM8988_LDAC:\n\tcase WM8988_RDAC:\n\tcase WM8988_BASS:\n\tcase WM8988_TREBLE:\n\tcase WM8988_RESET:\n\tcase WM8988_3D:\n\tcase WM8988_ALC1:\n\tcase WM8988_ALC2:\n\tcase WM8988_ALC3:\n\tcase WM8988_NGATE:\n\tcase WM8988_LADC:\n\tcase WM8988_RADC:\n\tcase WM8988_ADCTL1:\n\tcase WM8988_ADCTL2:\n\tcase WM8988_PWR1:\n\tcase WM8988_PWR2:\n\tcase WM8988_ADCTL3:\n\tcase WM8988_ADCIN:\n\tcase WM8988_LADCIN:\n\tcase WM8988_RADCIN:\n\tcase WM8988_LOUTM1:\n\tcase WM8988_LOUTM2:\n\tcase WM8988_ROUTM1:\n\tcase WM8988_ROUTM2:\n\tcase WM8988_LOUT2V:\n\tcase WM8988_ROUT2V:\n\tcase WM8988_LPPB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstruct wm8988_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n\tconst struct snd_pcm_hw_constraint_list *sysclk_constraints;\n};\n\n#define wm8988_reset(c)\tsnd_soc_component_write(c, WM8988_RESET, 0)\n\n \n\nstatic const char *bass_boost_txt[] = {\"Linear Control\", \"Adaptive Boost\"};\nstatic SOC_ENUM_SINGLE_DECL(bass_boost,\n\t\t\t    WM8988_BASS, 7, bass_boost_txt);\n\nstatic const char *bass_filter_txt[] = { \"130Hz @ 48kHz\", \"200Hz @ 48kHz\" };\nstatic SOC_ENUM_SINGLE_DECL(bass_filter,\n\t\t\t    WM8988_BASS, 6, bass_filter_txt);\n\nstatic const char *treble_txt[] = {\"8kHz\", \"4kHz\"};\nstatic SOC_ENUM_SINGLE_DECL(treble,\n\t\t\t    WM8988_TREBLE, 6, treble_txt);\n\nstatic const char *stereo_3d_lc_txt[] = {\"200Hz\", \"500Hz\"};\nstatic SOC_ENUM_SINGLE_DECL(stereo_3d_lc,\n\t\t\t    WM8988_3D, 5, stereo_3d_lc_txt);\n\nstatic const char *stereo_3d_uc_txt[] = {\"2.2kHz\", \"1.5kHz\"};\nstatic SOC_ENUM_SINGLE_DECL(stereo_3d_uc,\n\t\t\t    WM8988_3D, 6, stereo_3d_uc_txt);\n\nstatic const char *stereo_3d_func_txt[] = {\"Capture\", \"Playback\"};\nstatic SOC_ENUM_SINGLE_DECL(stereo_3d_func,\n\t\t\t    WM8988_3D, 7, stereo_3d_func_txt);\n\nstatic const char *alc_func_txt[] = {\"Off\", \"Right\", \"Left\", \"Stereo\"};\nstatic SOC_ENUM_SINGLE_DECL(alc_func,\n\t\t\t    WM8988_ALC1, 7, alc_func_txt);\n\nstatic const char *ng_type_txt[] = {\"Constant PGA Gain\",\n\t\t\t\t    \"Mute ADC Output\"};\nstatic SOC_ENUM_SINGLE_DECL(ng_type,\n\t\t\t    WM8988_NGATE, 1, ng_type_txt);\n\nstatic const char *deemph_txt[] = {\"None\", \"32Khz\", \"44.1Khz\", \"48Khz\"};\nstatic SOC_ENUM_SINGLE_DECL(deemph,\n\t\t\t    WM8988_ADCDAC, 1, deemph_txt);\n\nstatic const char *adcpol_txt[] = {\"Normal\", \"L Invert\", \"R Invert\",\n\t\t\t\t   \"L + R Invert\"};\nstatic SOC_ENUM_SINGLE_DECL(adcpol,\n\t\t\t    WM8988_ADCDAC, 5, adcpol_txt);\n\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -9750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);\n\nstatic const struct snd_kcontrol_new wm8988_snd_controls[] = {\n\nSOC_ENUM(\"Bass Boost\", bass_boost),\nSOC_ENUM(\"Bass Filter\", bass_filter),\nSOC_SINGLE(\"Bass Volume\", WM8988_BASS, 0, 15, 1),\n\nSOC_SINGLE(\"Treble Volume\", WM8988_TREBLE, 0, 15, 0),\nSOC_ENUM(\"Treble Cut-off\", treble),\n\nSOC_SINGLE(\"3D Switch\", WM8988_3D, 0, 1, 0),\nSOC_SINGLE(\"3D Volume\", WM8988_3D, 1, 15, 0),\nSOC_ENUM(\"3D Lower Cut-off\", stereo_3d_lc),\nSOC_ENUM(\"3D Upper Cut-off\", stereo_3d_uc),\nSOC_ENUM(\"3D Mode\", stereo_3d_func),\n\nSOC_SINGLE(\"ALC Capture Target Volume\", WM8988_ALC1, 0, 7, 0),\nSOC_SINGLE(\"ALC Capture Max Volume\", WM8988_ALC1, 4, 7, 0),\nSOC_ENUM(\"ALC Capture Function\", alc_func),\nSOC_SINGLE(\"ALC Capture ZC Switch\", WM8988_ALC2, 7, 1, 0),\nSOC_SINGLE(\"ALC Capture Hold Time\", WM8988_ALC2, 0, 15, 0),\nSOC_SINGLE(\"ALC Capture Decay Time\", WM8988_ALC3, 4, 15, 0),\nSOC_SINGLE(\"ALC Capture Attack Time\", WM8988_ALC3, 0, 15, 0),\nSOC_SINGLE(\"ALC Capture NG Threshold\", WM8988_NGATE, 3, 31, 0),\nSOC_ENUM(\"ALC Capture NG Type\", ng_type),\nSOC_SINGLE(\"ALC Capture NG Switch\", WM8988_NGATE, 0, 1, 0),\n\nSOC_SINGLE(\"ZC Timeout Switch\", WM8988_ADCTL1, 0, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Capture Digital Volume\", WM8988_LADC, WM8988_RADC,\n\t\t 0, 255, 0, adc_tlv),\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8988_LINVOL, WM8988_RINVOL,\n\t\t 0, 63, 0, pga_tlv),\nSOC_DOUBLE_R(\"Capture ZC Switch\", WM8988_LINVOL, WM8988_RINVOL, 6, 1, 0),\nSOC_DOUBLE_R(\"Capture Switch\", WM8988_LINVOL, WM8988_RINVOL, 7, 1, 1),\n\nSOC_ENUM(\"Playback De-emphasis\", deemph),\n\nSOC_ENUM(\"Capture Polarity\", adcpol),\nSOC_SINGLE(\"Playback 6dB Attenuate\", WM8988_ADCDAC, 7, 1, 0),\nSOC_SINGLE(\"Capture 6dB Attenuate\", WM8988_ADCDAC, 8, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"PCM Volume\", WM8988_LDAC, WM8988_RDAC, 0, 255, 0, dac_tlv),\n\nSOC_SINGLE_TLV(\"Left Mixer Left Bypass Volume\", WM8988_LOUTM1, 4, 7, 1,\n\t       bypass_tlv),\nSOC_SINGLE_TLV(\"Left Mixer Right Bypass Volume\", WM8988_LOUTM2, 4, 7, 1,\n\t       bypass_tlv),\nSOC_SINGLE_TLV(\"Right Mixer Left Bypass Volume\", WM8988_ROUTM1, 4, 7, 1,\n\t       bypass_tlv),\nSOC_SINGLE_TLV(\"Right Mixer Right Bypass Volume\", WM8988_ROUTM2, 4, 7, 1,\n\t       bypass_tlv),\n\nSOC_DOUBLE_R(\"Output 1 Playback ZC Switch\", WM8988_LOUT1V,\n\t     WM8988_ROUT1V, 7, 1, 0),\nSOC_DOUBLE_R_TLV(\"Output 1 Playback Volume\", WM8988_LOUT1V, WM8988_ROUT1V,\n\t\t 0, 127, 0, out_tlv),\n\nSOC_DOUBLE_R(\"Output 2 Playback ZC Switch\", WM8988_LOUT2V,\n\t     WM8988_ROUT2V, 7, 1, 0),\nSOC_DOUBLE_R_TLV(\"Output 2 Playback Volume\", WM8988_LOUT2V, WM8988_ROUT2V,\n\t\t 0, 127, 0, out_tlv),\n\n};\n\n \n\nstatic int wm8988_lrc_control(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu16 adctl2 = snd_soc_component_read(component, WM8988_ADCTL2);\n\n\t \n\tif (snd_soc_component_read(component, WM8988_PWR2) & 0x180)\n\t\tadctl2 &= ~0x4;\n\telse\n\t\tadctl2 |= 0x4;\n\n\treturn snd_soc_component_write(component, WM8988_ADCTL2, adctl2);\n}\n\nstatic const char *wm8988_line_texts[] = {\n\t\"Line 1\", \"Line 2\", \"PGA\", \"Differential\"};\n\nstatic const unsigned int wm8988_line_values[] = {\n\t0, 1, 3, 4};\n\nstatic const struct soc_enum wm8988_lline_enum =\n\tSOC_VALUE_ENUM_SINGLE(WM8988_LOUTM1, 0, 7,\n\t\t\t      ARRAY_SIZE(wm8988_line_texts),\n\t\t\t      wm8988_line_texts,\n\t\t\t      wm8988_line_values);\nstatic const struct snd_kcontrol_new wm8988_left_line_controls =\n\tSOC_DAPM_ENUM(\"Route\", wm8988_lline_enum);\n\nstatic const struct soc_enum wm8988_rline_enum =\n\tSOC_VALUE_ENUM_SINGLE(WM8988_ROUTM1, 0, 7,\n\t\t\t      ARRAY_SIZE(wm8988_line_texts),\n\t\t\t      wm8988_line_texts,\n\t\t\t      wm8988_line_values);\nstatic const struct snd_kcontrol_new wm8988_right_line_controls =\n\tSOC_DAPM_ENUM(\"Route\", wm8988_rline_enum);\n\n \nstatic const struct snd_kcontrol_new wm8988_left_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Playback Switch\", WM8988_LOUTM1, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Bypass Switch\", WM8988_LOUTM1, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Playback Switch\", WM8988_LOUTM2, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Bypass Switch\", WM8988_LOUTM2, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8988_right_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left Playback Switch\", WM8988_ROUTM1, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Bypass Switch\", WM8988_ROUTM1, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Playback Switch\", WM8988_ROUTM2, 8, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right Bypass Switch\", WM8988_ROUTM2, 7, 1, 0),\n};\n\nstatic const char *wm8988_pga_sel[] = {\"Line 1\", \"Line 2\", \"Differential\"};\nstatic const unsigned int wm8988_pga_val[] = { 0, 1, 3 };\n\n \nstatic const struct soc_enum wm8988_lpga_enum =\n\tSOC_VALUE_ENUM_SINGLE(WM8988_LADCIN, 6, 3,\n\t\t\t      ARRAY_SIZE(wm8988_pga_sel),\n\t\t\t      wm8988_pga_sel,\n\t\t\t      wm8988_pga_val);\nstatic const struct snd_kcontrol_new wm8988_left_pga_controls =\n\tSOC_DAPM_ENUM(\"Route\", wm8988_lpga_enum);\n\n \nstatic const struct soc_enum wm8988_rpga_enum =\n\tSOC_VALUE_ENUM_SINGLE(WM8988_RADCIN, 6, 3,\n\t\t\t      ARRAY_SIZE(wm8988_pga_sel),\n\t\t\t      wm8988_pga_sel,\n\t\t\t      wm8988_pga_val);\nstatic const struct snd_kcontrol_new wm8988_right_pga_controls =\n\tSOC_DAPM_ENUM(\"Route\", wm8988_rpga_enum);\n\n \nstatic const char *wm8988_diff_sel[] = {\"Line 1\", \"Line 2\"};\nstatic SOC_ENUM_SINGLE_DECL(diffmux,\n\t\t\t    WM8988_ADCIN, 8, wm8988_diff_sel);\nstatic const struct snd_kcontrol_new wm8988_diffmux_controls =\n\tSOC_DAPM_ENUM(\"Route\", diffmux);\n\n \nstatic const char *wm8988_mono_mux[] = {\"Stereo\", \"Mono (Left)\",\n\t\"Mono (Right)\", \"Digital Mono\"};\nstatic SOC_ENUM_SINGLE_DECL(monomux,\n\t\t\t    WM8988_ADCIN, 6, wm8988_mono_mux);\nstatic const struct snd_kcontrol_new wm8988_monomux_controls =\n\tSOC_DAPM_ENUM(\"Route\", monomux);\n\nstatic const struct snd_soc_dapm_widget wm8988_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", WM8988_PWR1, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Differential Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_diffmux_controls),\n\tSND_SOC_DAPM_MUX(\"Left ADC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_monomux_controls),\n\tSND_SOC_DAPM_MUX(\"Right ADC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_monomux_controls),\n\n\tSND_SOC_DAPM_MUX(\"Left PGA Mux\", WM8988_PWR1, 5, 0,\n\t\t&wm8988_left_pga_controls),\n\tSND_SOC_DAPM_MUX(\"Right PGA Mux\", WM8988_PWR1, 4, 0,\n\t\t&wm8988_right_pga_controls),\n\n\tSND_SOC_DAPM_MUX(\"Left Line Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_left_line_controls),\n\tSND_SOC_DAPM_MUX(\"Right Line Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_right_line_controls),\n\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", WM8988_PWR1, 2, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", WM8988_PWR1, 3, 0),\n\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", WM8988_PWR2, 7, 0),\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", WM8988_PWR2, 8, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_left_mixer_controls[0],\n\t\tARRAY_SIZE(wm8988_left_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&wm8988_right_mixer_controls[0],\n\t\tARRAY_SIZE(wm8988_right_mixer_controls)),\n\n\tSND_SOC_DAPM_PGA(\"Right Out 2\", WM8988_PWR2, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left Out 2\", WM8988_PWR2, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Out 1\", WM8988_PWR2, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left Out 1\", WM8988_PWR2, 6, 0, NULL, 0),\n\n\tSND_SOC_DAPM_POST(\"LRC control\", wm8988_lrc_control),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"VREF\"),\n\n\tSND_SOC_DAPM_INPUT(\"LINPUT1\"),\n\tSND_SOC_DAPM_INPUT(\"LINPUT2\"),\n\tSND_SOC_DAPM_INPUT(\"RINPUT1\"),\n\tSND_SOC_DAPM_INPUT(\"RINPUT2\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8988_dapm_routes[] = {\n\n\t{ \"Left Line Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left Line Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left Line Mux\", \"PGA\", \"Left PGA Mux\" },\n\t{ \"Left Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right Line Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right Line Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right Line Mux\", \"PGA\", \"Right PGA Mux\" },\n\t{ \"Right Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Left PGA Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left PGA Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left PGA Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right PGA Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right PGA Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right PGA Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Differential Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Differential Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Differential Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Differential Mux\", \"Line 2\", \"RINPUT2\" },\n\n\t{ \"Left ADC Mux\", \"Stereo\", \"Left PGA Mux\" },\n\t{ \"Left ADC Mux\", \"Mono (Left)\", \"Left PGA Mux\" },\n\t{ \"Left ADC Mux\", \"Digital Mono\", \"Left PGA Mux\" },\n\n\t{ \"Right ADC Mux\", \"Stereo\", \"Right PGA Mux\" },\n\t{ \"Right ADC Mux\", \"Mono (Right)\", \"Right PGA Mux\" },\n\t{ \"Right ADC Mux\", \"Digital Mono\", \"Right PGA Mux\" },\n\n\t{ \"Left ADC\", NULL, \"Left ADC Mux\" },\n\t{ \"Right ADC\", NULL, \"Right ADC Mux\" },\n\n\t{ \"Left Line Mux\", \"Line 1\", \"LINPUT1\" },\n\t{ \"Left Line Mux\", \"Line 2\", \"LINPUT2\" },\n\t{ \"Left Line Mux\", \"PGA\", \"Left PGA Mux\" },\n\t{ \"Left Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Right Line Mux\", \"Line 1\", \"RINPUT1\" },\n\t{ \"Right Line Mux\", \"Line 2\", \"RINPUT2\" },\n\t{ \"Right Line Mux\", \"PGA\", \"Right PGA Mux\" },\n\t{ \"Right Line Mux\", \"Differential\", \"Differential Mux\" },\n\n\t{ \"Left Mixer\", \"Playback Switch\", \"Left DAC\" },\n\t{ \"Left Mixer\", \"Left Bypass Switch\", \"Left Line Mux\" },\n\t{ \"Left Mixer\", \"Right Playback Switch\", \"Right DAC\" },\n\t{ \"Left Mixer\", \"Right Bypass Switch\", \"Right Line Mux\" },\n\n\t{ \"Right Mixer\", \"Left Playback Switch\", \"Left DAC\" },\n\t{ \"Right Mixer\", \"Left Bypass Switch\", \"Left Line Mux\" },\n\t{ \"Right Mixer\", \"Playback Switch\", \"Right DAC\" },\n\t{ \"Right Mixer\", \"Right Bypass Switch\", \"Right Line Mux\" },\n\n\t{ \"Left Out 1\", NULL, \"Left Mixer\" },\n\t{ \"LOUT1\", NULL, \"Left Out 1\" },\n\t{ \"Right Out 1\", NULL, \"Right Mixer\" },\n\t{ \"ROUT1\", NULL, \"Right Out 1\" },\n\n\t{ \"Left Out 2\", NULL, \"Left Mixer\" },\n\t{ \"LOUT2\", NULL, \"Left Out 2\" },\n\t{ \"Right Out 2\", NULL, \"Right Mixer\" },\n\t{ \"ROUT2\", NULL, \"Right Out 2\" },\n};\n\nstruct _coeff_div {\n\tu32 mclk;\n\tu32 rate;\n\tu16 fs;\n\tu8 sr:5;\n\tu8 usb:1;\n};\n\n \nstatic const struct _coeff_div coeff_div[] = {\n\t \n\t{12288000, 8000, 1536, 0x6, 0x0},\n\t{11289600, 8000, 1408, 0x16, 0x0},\n\t{18432000, 8000, 2304, 0x7, 0x0},\n\t{16934400, 8000, 2112, 0x17, 0x0},\n\t{12000000, 8000, 1500, 0x6, 0x1},\n\n\t \n\t{11289600, 11025, 1024, 0x18, 0x0},\n\t{16934400, 11025, 1536, 0x19, 0x0},\n\t{12000000, 11025, 1088, 0x19, 0x1},\n\n\t \n\t{12288000, 16000, 768, 0xa, 0x0},\n\t{18432000, 16000, 1152, 0xb, 0x0},\n\t{12000000, 16000, 750, 0xa, 0x1},\n\n\t \n\t{11289600, 22050, 512, 0x1a, 0x0},\n\t{16934400, 22050, 768, 0x1b, 0x0},\n\t{12000000, 22050, 544, 0x1b, 0x1},\n\n\t \n\t{12288000, 32000, 384, 0xc, 0x0},\n\t{18432000, 32000, 576, 0xd, 0x0},\n\t{12000000, 32000, 375, 0xa, 0x1},\n\n\t \n\t{11289600, 44100, 256, 0x10, 0x0},\n\t{16934400, 44100, 384, 0x11, 0x0},\n\t{12000000, 44100, 272, 0x11, 0x1},\n\n\t \n\t{12288000, 48000, 256, 0x0, 0x0},\n\t{18432000, 48000, 384, 0x1, 0x0},\n\t{12000000, 48000, 250, 0x0, 0x1},\n\n\t \n\t{11289600, 88200, 128, 0x1e, 0x0},\n\t{16934400, 88200, 192, 0x1f, 0x0},\n\t{12000000, 88200, 136, 0x1f, 0x1},\n\n\t \n\t{12288000, 96000, 128, 0xe, 0x0},\n\t{18432000, 96000, 192, 0xf, 0x0},\n\t{12000000, 96000, 125, 0xe, 0x1},\n};\n\nstatic inline int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\n \n\nstatic const unsigned int rates_12288[] = {\n\t8000, 12000, 16000, 24000, 32000, 48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_12288 = {\n\t.count\t= ARRAY_SIZE(rates_12288),\n\t.list\t= rates_12288,\n};\n\nstatic const unsigned int rates_112896[] = {\n\t8000, 11025, 22050, 44100,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_112896 = {\n\t.count\t= ARRAY_SIZE(rates_112896),\n\t.list\t= rates_112896,\n};\n\nstatic const unsigned int rates_12[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 41100, 48000,\n\t48000, 88235, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_12 = {\n\t.count\t= ARRAY_SIZE(rates_12),\n\t.list\t= rates_12,\n};\n\n \nstatic int wm8988_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8988_priv *wm8988 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase 11289600:\n\tcase 18432000:\n\tcase 22579200:\n\tcase 36864000:\n\t\twm8988->sysclk_constraints = &constraints_112896;\n\t\twm8988->sysclk = freq;\n\t\treturn 0;\n\n\tcase 12288000:\n\tcase 16934400:\n\tcase 24576000:\n\tcase 33868800:\n\t\twm8988->sysclk_constraints = &constraints_12288;\n\t\twm8988->sysclk = freq;\n\t\treturn 0;\n\n\tcase 12000000:\n\tcase 24000000:\n\t\twm8988->sysclk_constraints = &constraints_12;\n\t\twm8988->sysclk = freq;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int wm8988_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tiface = 0x0040;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0090;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8988_IFACE, iface);\n\treturn 0;\n}\n\nstatic int wm8988_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8988_priv *wm8988 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!wm8988->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"No MCLK configured, call set_sysclk() on init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   wm8988->sysclk_constraints);\n\n\treturn 0;\n}\n\nstatic int wm8988_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8988_priv *wm8988 = snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8988_IFACE) & 0x1f3;\n\tu16 srate = snd_soc_component_read(component, WM8988_SRATE) & 0x180;\n\tint coeff;\n\n\tcoeff = get_coeff(wm8988->sysclk, params_rate(params));\n\tif (coeff < 0) {\n\t\tcoeff = get_coeff(wm8988->sysclk / 2, params_rate(params));\n\t\tsrate |= 0x40;\n\t}\n\tif (coeff < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unable to configure sample rate %dHz with %dHz MCLK\\n\",\n\t\t\tparams_rate(params), wm8988->sysclk);\n\t\treturn coeff;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x0008;\n\t\tbreak;\n\tcase 32:\n\t\tiface |= 0x000c;\n\t\tbreak;\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8988_IFACE, iface);\n\tif (coeff >= 0)\n\t\tsnd_soc_component_write(component, WM8988_SRATE, srate |\n\t\t\t(coeff_div[coeff].sr << 1) | coeff_div[coeff].usb);\n\n\treturn 0;\n}\n\nstatic int wm8988_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8988_ADCDAC) & 0xfff7;\n\n\tif (mute)\n\t\tsnd_soc_component_write(component, WM8988_ADCDAC, mute_reg | 0x8);\n\telse\n\t\tsnd_soc_component_write(component, WM8988_ADCDAC, mute_reg);\n\treturn 0;\n}\n\nstatic int wm8988_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8988_priv *wm8988 = snd_soc_component_get_drvdata(component);\n\tu16 pwr_reg = snd_soc_component_read(component, WM8988_PWR1) & ~0x1c1;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_write(component, WM8988_PWR1, pwr_reg | 0x00c0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_sync(wm8988->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8988_PWR1, pwr_reg | 0x1c1);\n\n\t\t\t \n\t\t\tmsleep(100);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_write(component, WM8988_PWR1, pwr_reg | 0x0141);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component, WM8988_PWR1, 0x0000);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8988_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8988_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops wm8988_ops = {\n\t.startup = wm8988_pcm_startup,\n\t.hw_params = wm8988_pcm_hw_params,\n\t.set_fmt = wm8988_set_dai_fmt,\n\t.set_sysclk = wm8988_set_dai_sysclk,\n\t.mute_stream = wm8988_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8988_dai = {\n\t.name = \"wm8988-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8988_RATES,\n\t\t.formats = WM8988_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8988_RATES,\n\t\t.formats = WM8988_FORMATS,\n\t },\n\t.ops = &wm8988_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8988_probe(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\tret = wm8988_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8988_RADC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8988_RDAC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8988_ROUT1V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8988_ROUT2V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8988_RINVOL, 0x0100, 0x0100);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8988 = {\n\t.probe\t\t\t= wm8988_probe,\n\t.set_bias_level\t\t= wm8988_set_bias_level,\n\t.controls\t\t= wm8988_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8988_snd_controls),\n\t.dapm_widgets\t\t= wm8988_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8988_dapm_widgets),\n\t.dapm_routes\t\t= wm8988_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8988_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8988_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8988_LPPB,\n\t.writeable_reg = wm8988_writeable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8988_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8988_reg_defaults),\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8988_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8988_priv *wm8988;\n\tint ret;\n\n\twm8988 = devm_kzalloc(&spi->dev, sizeof(struct wm8988_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8988 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8988->regmap = devm_regmap_init_spi(spi, &wm8988_regmap);\n\tif (IS_ERR(wm8988->regmap)) {\n\t\tret = PTR_ERR(wm8988->regmap);\n\t\tdev_err(&spi->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, wm8988);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_dev_wm8988, &wm8988_dai, 1);\n\treturn ret;\n}\n\nstatic struct spi_driver wm8988_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8988\",\n\t},\n\t.probe\t\t= wm8988_spi_probe,\n};\n#endif  \n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8988_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8988_priv *wm8988;\n\tint ret;\n\n\twm8988 = devm_kzalloc(&i2c->dev, sizeof(struct wm8988_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8988 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm8988);\n\n\twm8988->regmap = devm_regmap_init_i2c(i2c, &wm8988_regmap);\n\tif (IS_ERR(wm8988->regmap)) {\n\t\tret = PTR_ERR(wm8988->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8988, &wm8988_dai, 1);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8988_i2c_id[] = {\n\t{ \"wm8988\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8988_i2c_id);\n\nstatic struct i2c_driver wm8988_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8988\",\n\t},\n\t.probe = wm8988_i2c_probe,\n\t.id_table = wm8988_i2c_id,\n};\n#endif\n\nstatic int __init wm8988_modinit(void)\n{\n\tint ret = 0;\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8988_i2c_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8988 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8988_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8988 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\nmodule_init(wm8988_modinit);\n\nstatic void __exit wm8988_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8988_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8988_spi_driver);\n#endif\n}\nmodule_exit(wm8988_exit);\n\n\nMODULE_DESCRIPTION(\"ASoC WM8988 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}