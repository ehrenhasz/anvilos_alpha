{
  "module_name": "ssm3515.c",
  "hash_id": "41d51d9fef0f8f71483e9ad21f3192574cb834ce9289cf8e2cb145425da69d2c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ssm3515.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n\n#define SSM3515_PWR\t\t0x00\n#define SSM3515_PWR_APWDN_EN\tBIT(7)\n#define SSM3515_PWR_BSNS_PWDN\tBIT(6)\n#define SSM3515_PWR_S_RST\tBIT(1)\n#define SSM3515_PWR_SPWDN\tBIT(0)\n\n#define SSM3515_GEC\t\t0x01\n#define SSM3515_GEC_EDGE\tBIT(4)\n#define SSM3515_GEC_EDGE_SHIFT\t4\n#define SSM3515_GEC_ANA_GAIN\tGENMASK(1, 0)\n\n#define SSM3515_DAC\t\t0x02\n#define SSM3515_DAC_HV\t\tBIT(7)\n#define SSM3515_DAC_MUTE\tBIT(6)\n#define SSM3515_DAC_HPF\t\tBIT(5)\n#define SSM3515_DAC_LPM\t\tBIT(4)\n#define SSM3515_DAC_FS\t\tGENMASK(2, 0)\n\n#define SSM3515_DAC_VOL\t\t0x03\n\n#define SSM3515_SAI1\t\t0x04\n#define SSM3515_SAI1_DAC_POL\tBIT(7)\n#define SSM3515_SAI1_BCLK_POL\tBIT(6)\n#define SSM3515_SAI1_TDM_BCLKS\tGENMASK(5, 3)\n#define SSM3515_SAI1_FSYNC_MODE\tBIT(2)\n#define SSM3515_SAI1_SDATA_FMT\tBIT(1)\n#define SSM3515_SAI1_SAI_MODE\tBIT(0)\n\n#define SSM3515_SAI2\t\t0x05\n#define SSM3515_SAI2_DATA_WIDTH\tBIT(7)\n#define SSM3515_SAI2_AUTO_SLOT\tBIT(4)\n#define SSM3515_SAI2_TDM_SLOT\tGENMASK(3, 0)\n\n#define SSM3515_VBAT_OUT\t0x06\n\n#define SSM3515_STATUS\t\t0x0a\n#define SSM3515_STATUS_UVLO_REG\tBIT(6)\n#define SSM3515_STATUS_LIM_EG\tBIT(5)\n#define SSM3515_STATUS_CLIP\tBIT(4)\n#define SSM3515_STATUS_AMP_OC\tBIT(3)\n#define SSM3515_STATUS_OTF\tBIT(2)\n#define SSM3515_STATUS_OTW\tBIT(1)\n#define SSM3515_STATUS_BAT_WARN\tBIT(0)\n\nstatic bool ssm3515_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase SSM3515_STATUS:\n\tcase SSM3515_VBAT_OUT:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_default ssm3515_reg_defaults[] = {\n\t{ SSM3515_PWR, 0x81 },\n\t{ SSM3515_GEC, 0x01 },\n\t{ SSM3515_DAC, 0x32 },\n\t{ SSM3515_DAC_VOL, 0x40 },\n\t{ SSM3515_SAI1, 0x11 },\n\t{ SSM3515_SAI2, 0x00 },\n};\n\nstatic const struct regmap_config ssm3515_i2c_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.volatile_reg = ssm3515_volatile_reg,\n\t.max_register = 0xb,\n\t.reg_defaults = ssm3515_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ssm3515_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstruct ssm3515_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n};\n\n\n\n\nstatic DECLARE_TLV_DB_MINMAX_MUTE(ssm3515_dac_volume, -7162, 2400);\n\nstatic const char * const ssm3515_ana_gain_text[] = {\n\t\"8.4 V Span\", \"12.6 V Span\", \"14 V Span\", \"15 V Span\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ssm3515_ana_gain_enum, SSM3515_GEC,\n\t\t\t    __bf_shf(SSM3515_GEC_ANA_GAIN),\n\t\t\t    ssm3515_ana_gain_text);\n\nstatic const struct snd_kcontrol_new ssm3515_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"DAC Playback Volume\", SSM3515_DAC_VOL,\n\t\t       0, 255, 1, ssm3515_dac_volume),\n\tSOC_SINGLE(\"Low EMI Mode Switch\", SSM3515_GEC,\n\t\t   __bf_shf(SSM3515_GEC_EDGE), 1, 0),\n\tSOC_SINGLE(\"Soft Volume Ramping Switch\", SSM3515_DAC,\n\t\t   __bf_shf(SSM3515_DAC_HV), 1, 1),\n\tSOC_SINGLE(\"HPF Switch\", SSM3515_DAC,\n\t\t   __bf_shf(SSM3515_DAC_HPF), 1, 0),\n\tSOC_SINGLE(\"DAC Invert Switch\", SSM3515_SAI1,\n\t\t   __bf_shf(SSM3515_SAI1_DAC_POL), 1, 0),\n\tSOC_ENUM(\"DAC Analog Gain Select\", ssm3515_ana_gain_enum),\n};\n\nstatic void ssm3515_read_faults(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = snd_soc_component_read(component, SSM3515_STATUS);\n\tif (ret <= 0) {\n\t\t \n\t\treturn;\n\t}\n\n\tdev_err(component->dev, \"device reports:%s%s%s%s%s%s%s\\n\",\n\t\tFIELD_GET(SSM3515_STATUS_UVLO_REG, ret) ? \" voltage regulator fault\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_LIM_EG, ret)   ? \" limiter engaged\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_CLIP, ret)     ? \" clipping detected\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_AMP_OC, ret)   ? \" amp over-current fault\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_OTF, ret)      ? \" overtemperature fault\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_OTW, ret)      ? \" overtemperature warning\" : \"\",\n\t\tFIELD_GET(SSM3515_STATUS_BAT_WARN, ret) ? \" bat voltage low warning\" : \"\");\n}\n\nstatic int ssm3515_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\n\t \n\tret = snd_soc_component_update_bits(component, SSM3515_DAC,\n\t\t\tSSM3515_DAC_MUTE, SSM3515_DAC_MUTE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_component_update_bits(component, SSM3515_PWR,\n\t\t\tSSM3515_PWR_SPWDN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ssm3515_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tint ret;\n\n\tret = snd_soc_component_update_bits(dai->component,\n\t\t\t\t\t    SSM3515_DAC,\n\t\t\t\t\t    SSM3515_DAC_MUTE,\n\t\t\t\t\t    FIELD_PREP(SSM3515_DAC_MUTE, mute));\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int ssm3515_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint ret, rateval;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16:\n\tcase SNDRV_PCM_FORMAT_S24:\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\tSSM3515_SAI2, SSM3515_SAI2_DATA_WIDTH,\n\t\t\t\tFIELD_PREP(SSM3515_SAI2_DATA_WIDTH,\n\t\t\t\t\t   params_width(params) == 16));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 8000 ... 12000:\n\t\trateval = 0;\n\t\tbreak;\n\tcase 16000 ... 24000:\n\t\trateval = 1;\n\t\tbreak;\n\tcase 32000 ... 48000:\n\t\trateval = 2;\n\t\tbreak;\n\tcase 64000 ... 96000:\n\t\trateval = 3;\n\t\tbreak;\n\tcase 128000 ... 192000:\n\t\trateval = 4;\n\t\tbreak;\n\tcase 48001 ... 63999:  \n\t\trateval = 5;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tSSM3515_DAC, SSM3515_DAC_FS,\n\t\t\tFIELD_PREP(SSM3515_DAC_FS, rateval));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ssm3515_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tbool fpol_inv = false;  \n\tint ret;\n\tu8 sai1 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tsai1 |= SSM3515_SAI1_BCLK_POL;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tfpol_inv = 1;\n\t\tsai1 &= ~SSM3515_SAI1_SDATA_FMT;  \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tfpol_inv = 0;\n\t\tsai1 |= SSM3515_SAI1_SDATA_FMT;  \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tfpol_inv ^= 1;\n\t\tbreak;\n\t}\n\n\t \n\tsai1 |= SSM3515_SAI1_SAI_MODE;\n\n\tif (fpol_inv) {\n\t\t \n\t\tsai1 |= SSM3515_SAI1_FSYNC_MODE;\n\t}\n\n\tret = snd_soc_component_update_bits(component, SSM3515_SAI1,\n\t\t\tSSM3515_SAI1_BCLK_POL | SSM3515_SAI1_SDATA_FMT |\n\t\t\tSSM3515_SAI1_SAI_MODE | SSM3515_SAI1_FSYNC_MODE, sai1);\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int ssm3515_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\tunsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask,\n\t\t\t\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint slot, tdm_bclks_val, ret;\n\n\tif (tx_mask == 0 || rx_mask != 0)\n\t\treturn -EINVAL;\n\n\tslot = __ffs(tx_mask);\n\n\tif (tx_mask & ~BIT(slot))\n\t\treturn -EINVAL;\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\ttdm_bclks_val = 0;\n\t\tbreak;\n\tcase 24:\n\t\ttdm_bclks_val = 1;\n\t\tbreak;\n\tcase 32:\n\t\ttdm_bclks_val = 2;\n\t\tbreak;\n\tcase 48:\n\t\ttdm_bclks_val = 3;\n\t\tbreak;\n\tcase 64:\n\t\ttdm_bclks_val = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, SSM3515_SAI1,\n\t\t\tSSM3515_SAI1_TDM_BCLKS,\n\t\t\tFIELD_PREP(SSM3515_SAI1_TDM_BCLKS, tdm_bclks_val));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_update_bits(component, SSM3515_SAI2,\n\t\t\tSSM3515_SAI2_TDM_SLOT,\n\t\t\tFIELD_PREP(SSM3515_SAI2_TDM_SLOT, slot));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ssm3515_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\t \n\tssm3515_read_faults(dai->component);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ssm3515_dai_ops = {\n\t.mute_stream\t= ssm3515_mute,\n\t.hw_params\t= ssm3515_hw_params,\n\t.set_fmt\t= ssm3515_set_fmt,\n\t.set_tdm_slot\t= ssm3515_set_tdm_slot,\n\t.hw_free\t= ssm3515_hw_free,\n};\n\nstatic struct snd_soc_dai_driver ssm3515_dai_driver = {\n\t.name = \"SSM3515 SAI\",\n\t.id = 0,\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.ops = &ssm3515_dai_ops,\n};\n\nstatic const struct snd_soc_dapm_widget ssm3515_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route ssm3515_dapm_routes[] = {\n\t{\"OUT\", NULL, \"DAC\"},\n\t{\"DAC\", NULL, \"Playback\"},\n};\n\nstatic const struct snd_soc_component_driver ssm3515_asoc_component = {\n\t.probe = ssm3515_probe,\n\t.controls = ssm3515_snd_controls,\n\t.num_controls = ARRAY_SIZE(ssm3515_snd_controls),\n\t.dapm_widgets = ssm3515_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(ssm3515_dapm_widgets),\n\t.dapm_routes = ssm3515_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(ssm3515_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic int ssm3515_i2c_probe(struct i2c_client *client)\n{\n\tstruct ssm3515_data *data;\n\tint ret;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &client->dev;\n\ti2c_set_clientdata(client, data);\n\n\tdata->regmap = devm_regmap_init_i2c(client, &ssm3515_i2c_regmap);\n\tif (IS_ERR(data->regmap))\n\t\treturn dev_err_probe(data->dev, PTR_ERR(data->regmap),\n\t\t\t\t     \"initializing register map\\n\");\n\n\t \n\tret = regmap_update_bits(data->regmap, SSM3515_PWR,\n\t\t\tSSM3515_PWR_S_RST, SSM3515_PWR_S_RST);\n\tif (ret < 0)\n\t\treturn dev_err_probe(data->dev, ret,\n\t\t\t\t     \"performing software reset\\n\");\n\tregmap_reinit_cache(data->regmap, &ssm3515_i2c_regmap);\n\n\treturn devm_snd_soc_register_component(data->dev,\n\t\t\t&ssm3515_asoc_component,\n\t\t\t&ssm3515_dai_driver, 1);\n}\n\nstatic const struct of_device_id ssm3515_of_match[] = {\n\t{ .compatible = \"adi,ssm3515\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ssm3515_of_match);\n\nstatic struct i2c_driver ssm3515_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ssm3515\",\n\t\t.of_match_table = ssm3515_of_match,\n\t},\n\t.probe = ssm3515_i2c_probe,\n};\nmodule_i2c_driver(ssm3515_i2c_driver);\n\nMODULE_AUTHOR(\"Martin Povi\u0161er <povik+lin@cutebit.org>\");\nMODULE_DESCRIPTION(\"ASoC SSM3515 audio amp driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}