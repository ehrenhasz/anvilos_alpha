{
  "module_name": "zl38060.c",
  "hash_id": "25df93fe76a5f765beb751f24ebcb5e04f05104f543b30e3c1c075936ed2cb5c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/zl38060.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/module.h>\n#include <linux/ihex.h>\n\n#include <sound/pcm_params.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#define DRV_NAME\t\t\"zl38060\"\n\n#define ZL38_RATES\t\t(SNDRV_PCM_RATE_8000  |\\\n\t\t\t\tSNDRV_PCM_RATE_16000 |\\\n\t\t\t\tSNDRV_PCM_RATE_48000)\n#define ZL38_FORMATS\t\tSNDRV_PCM_FMTBIT_S16_LE\n\n#define HBI_FIRMWARE_PAGE\t0xFF\n#define ZL38_MAX_RAW_XFER\t0x100\n\n#define REG_TDMA_CFG_CLK\t0x0262\n#define CFG_CLK_PCLK_SHIFT\t4\n#define CFG_CLK_PCLK_MASK\t(0x7ff << CFG_CLK_PCLK_SHIFT)\n#define CFG_CLK_PCLK(bits)\t((bits - 1) << CFG_CLK_PCLK_SHIFT)\n#define CFG_CLK_MASTER\t\tBIT(15)\n#define CFG_CLK_FSRATE_MASK\t0x7\n#define CFG_CLK_FSRATE_8KHZ\t0x1\n#define CFG_CLK_FSRATE_16KHZ\t0x2\n#define CFG_CLK_FSRATE_48KHZ\t0x6\n\n#define REG_CLK_CFG\t\t0x0016\n#define CLK_CFG_SOURCE_XTAL\tBIT(15)\n\n#define REG_CLK_STATUS\t\t0x0014\n#define CLK_STATUS_HWRST\tBIT(0)\n\n#define REG_PARAM_RESULT\t0x0034\n#define PARAM_RESULT_READY\t0xD3D3\n\n#define REG_PG255_BASE_HI\t0x000C\n#define REG_PG255_OFFS(addr)\t((HBI_FIRMWARE_PAGE << 8) | (addr & 0xFF))\n#define REG_FWR_EXEC\t\t0x012C\n\n#define REG_CMD\t\t\t0x0032\n#define REG_HW_REV\t\t0x0020\n#define REG_FW_PROD\t\t0x0022\n#define REG_FW_REV\t\t0x0024\n\n#define REG_SEMA_FLAGS\t\t0x0006\n#define SEMA_FLAGS_BOOT_CMD\tBIT(0)\n#define SEMA_FLAGS_APP_REBOOT\tBIT(1)\n\n#define REG_HW_REV\t\t0x0020\n#define REG_FW_PROD\t\t0x0022\n#define REG_FW_REV\t\t0x0024\n#define REG_GPIO_DIR\t\t0x02DC\n#define REG_GPIO_DAT\t\t0x02DA\n\n#define BOOTCMD_LOAD_COMPLETE\t0x000D\n#define BOOTCMD_FW_GO\t\t0x0008\n\n#define FIRMWARE_MAJOR\t\t2\n#define FIRMWARE_MINOR\t\t2\n\nstruct zl38_codec_priv {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tbool is_stream_in_use[2];\n\tstruct gpio_chip *gpio_chip;\n};\n\nstatic int zl38_fw_issue_command(struct regmap *regmap, u16 cmd)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read_poll_timeout(regmap, REG_SEMA_FLAGS, val,\n\t\t\t\t       !(val & SEMA_FLAGS_BOOT_CMD), 10000,\n\t\t\t\t       10000 * 100);\n\tif (err)\n\t\treturn err;\n\terr = regmap_write(regmap, REG_CMD, cmd);\n\tif (err)\n\t\treturn err;\n\terr = regmap_update_bits(regmap, REG_SEMA_FLAGS, SEMA_FLAGS_BOOT_CMD,\n\t\t\t\t SEMA_FLAGS_BOOT_CMD);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_read_poll_timeout(regmap, REG_CMD, val, !val, 10000,\n\t\t\t\t\t10000 * 100);\n}\n\nstatic int zl38_fw_go(struct regmap *regmap)\n{\n\tint err;\n\n\terr = zl38_fw_issue_command(regmap, BOOTCMD_LOAD_COMPLETE);\n\tif (err)\n\t\treturn err;\n\n\treturn zl38_fw_issue_command(regmap, BOOTCMD_FW_GO);\n}\n\nstatic int zl38_fw_enter_boot_mode(struct regmap *regmap)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_update_bits(regmap, REG_CLK_STATUS, CLK_STATUS_HWRST,\n\t\t\t\t CLK_STATUS_HWRST);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_read_poll_timeout(regmap, REG_PARAM_RESULT, val,\n\t\t\t\t\tval == PARAM_RESULT_READY, 1000, 50000);\n}\n\nstatic int\nzl38_fw_send_data(struct regmap *regmap, u32 addr, const void *data, u16 len)\n{\n\t__be32 addr_base = cpu_to_be32(addr & ~0xFF);\n\tint err;\n\n\terr = regmap_raw_write(regmap, REG_PG255_BASE_HI, &addr_base,\n\t\t\t       sizeof(addr_base));\n\tif (err)\n\t\treturn err;\n\treturn regmap_raw_write(regmap, REG_PG255_OFFS(addr), data, len);\n}\n\nstatic int zl38_fw_send_xaddr(struct regmap *regmap, const void *data)\n{\n\t \n\tu32 addr = le32_to_cpup(data);\n\t__be32 baddr = cpu_to_be32(addr);\n\n\treturn regmap_raw_write(regmap, REG_FWR_EXEC, &baddr, sizeof(baddr));\n}\n\nstatic int zl38_load_firmware(struct device *dev, struct regmap *regmap)\n{\n\tconst struct ihex_binrec *rec;\n\tconst struct firmware *fw;\n\tu32 addr;\n\tu16 len;\n\tint err;\n\n\t \n\terr = request_ihex_firmware(&fw, \"zl38060.fw\", dev);\n\tif (err)\n\t\treturn err;\n\terr = zl38_fw_enter_boot_mode(regmap);\n\tif (err)\n\t\tgoto out;\n\trec = (const struct ihex_binrec *)fw->data;\n\twhile (rec) {\n\t\taddr = be32_to_cpu(rec->addr);\n\t\tlen = be16_to_cpu(rec->len);\n\t\tif (addr) {\n\t\t\t \n\t\t\terr = zl38_fw_send_data(regmap, addr, rec->data, len);\n\t\t} else if (len == 4) {\n\t\t\t \n\t\t\terr = zl38_fw_send_xaddr(regmap, rec->data);\n\t\t} else {\n\t\t\terr = -EINVAL;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t\t \n\t\trec = ihex_next_binrec(rec);\n\t}\n\terr = zl38_fw_go(regmap);\n\nout:\n\trelease_firmware(fw);\n\treturn err;\n}\n\n\nstatic int zl38_software_reset(struct regmap *regmap)\n{\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_update_bits(regmap, REG_SEMA_FLAGS, SEMA_FLAGS_APP_REBOOT,\n\t\t\t\t SEMA_FLAGS_APP_REBOOT);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmsleep(50);\n\n\treturn regmap_read_poll_timeout(regmap, REG_SEMA_FLAGS, val,\n\t\t\t\t\t!(val & SEMA_FLAGS_APP_REBOOT), 10000,\n\t\t\t\t\t10000 * 100);\n}\n\nstatic int zl38_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct zl38_codec_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tint err;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t \n\t\terr = regmap_update_bits(priv->regmap, REG_TDMA_CFG_CLK,\n\t\t\t\t\t CFG_CLK_MASTER | CFG_CLK_PCLK_MASK,\n\t\t\t\t\t CFG_CLK_MASTER | CFG_CLK_PCLK(32));\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int zl38_hw_params(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct zl38_codec_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tunsigned int fsrate;\n\tint err;\n\n\t \n\tif (priv->is_stream_in_use[!tx])\n\t\tgoto skip_setup;\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tfsrate = CFG_CLK_FSRATE_8KHZ;\n\t\tbreak;\n\tcase 16000:\n\t\tfsrate = CFG_CLK_FSRATE_16KHZ;\n\t\tbreak;\n\tcase 48000:\n\t\tfsrate = CFG_CLK_FSRATE_48KHZ;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = regmap_update_bits(priv->regmap, REG_TDMA_CFG_CLK,\n\t\t\t\t CFG_CLK_FSRATE_MASK, fsrate);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = zl38_software_reset(priv->regmap);\n\tif (err)\n\t\treturn err;\n\nskip_setup:\n\tpriv->is_stream_in_use[tx] = true;\n\n\treturn 0;\n}\n\nstatic int zl38_hw_free(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct zl38_codec_priv *priv = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\n\tpriv->is_stream_in_use[tx] = false;\n\n\treturn 0;\n}\n\n \nstatic const struct reg_sequence cp_config_stereo_bypass[] = {\n\t \n\t{ 0x0210, 0x0005 },\t \n\t{ 0x0212, 0x0006 },\t \n\t{ 0x0214, 0x0001 },\t \n\t{ 0x0216, 0x0001 },\t \n\t{ 0x0224, 0x0000 },\t \n\t{ 0x0226, 0x0000 },\t \n\t \n\t{ 0x0202, 0x000F },\t \n};\n\nstatic const struct snd_soc_dai_ops zl38_dai_ops = {\n\t.set_fmt = zl38_set_fmt,\n\t.hw_params = zl38_hw_params,\n\t.hw_free = zl38_hw_free,\n};\n\nstatic struct snd_soc_dai_driver zl38_dai = {\n\t.name = \"zl38060-tdma\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = ZL38_RATES,\n\t\t.formats = ZL38_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = ZL38_RATES,\n\t\t.formats = ZL38_FORMATS,\n\t},\n\t.ops = &zl38_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n\t.symmetric_channels = 1,\n};\n\nstatic const struct snd_soc_dapm_widget zl38_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"DAC1\"),\n\tSND_SOC_DAPM_OUTPUT(\"DAC2\"),\n\n\tSND_SOC_DAPM_INPUT(\"DMICL\"),\n};\n\nstatic const struct snd_soc_dapm_route zl38_dapm_routes[] = {\n\t{ \"DAC1\",  NULL, \"Playback\" },\n\t{ \"DAC2\",  NULL, \"Playback\" },\n\n\t{ \"Capture\",  NULL, \"DMICL\" },\n};\n\nstatic const struct snd_soc_component_driver zl38_component_dev = {\n\t.dapm_widgets\t\t= zl38_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(zl38_dapm_widgets),\n\t.dapm_routes\t\t= zl38_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(zl38_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic void chip_gpio_set(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tstruct regmap *regmap = gpiochip_get_data(c);\n\tunsigned int mask = BIT(offset);\n\n\tregmap_update_bits(regmap, REG_GPIO_DAT, mask, val ? mask : 0);\n}\n\nstatic int chip_gpio_get(struct gpio_chip *c, unsigned int offset)\n{\n\tstruct regmap *regmap = gpiochip_get_data(c);\n\tunsigned int mask = BIT(offset);\n\tunsigned int val;\n\tint err;\n\n\terr = regmap_read(regmap, REG_GPIO_DAT, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn !!(val & mask);\n}\n\nstatic int chip_direction_input(struct gpio_chip *c, unsigned int offset)\n{\n\tstruct regmap *regmap = gpiochip_get_data(c);\n\tunsigned int mask = BIT(offset);\n\n\treturn regmap_update_bits(regmap, REG_GPIO_DIR, mask, 0);\n}\n\nstatic int\nchip_direction_output(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tstruct regmap *regmap = gpiochip_get_data(c);\n\tunsigned int mask = BIT(offset);\n\n\tchip_gpio_set(c, offset, val);\n\treturn regmap_update_bits(regmap, REG_GPIO_DIR, mask, mask);\n}\n\nstatic const struct gpio_chip template_chip = {\n\t.owner = THIS_MODULE,\n\t.label = DRV_NAME,\n\n\t.base = -1,\n\t.ngpio = 14,\n\t.direction_input = chip_direction_input,\n\t.direction_output = chip_direction_output,\n\t.get = chip_gpio_get,\n\t.set = chip_gpio_set,\n\n\t.can_sleep = true,\n};\n\nstatic int zl38_check_revision(struct device *dev, struct regmap *regmap)\n{\n\tunsigned int hwrev, fwprod, fwrev;\n\tint fw_major, fw_minor, fw_micro;\n\tint err;\n\n\terr = regmap_read(regmap, REG_HW_REV, &hwrev);\n\tif (err)\n\t\treturn err;\n\terr = regmap_read(regmap, REG_FW_PROD, &fwprod);\n\tif (err)\n\t\treturn err;\n\terr = regmap_read(regmap, REG_FW_REV, &fwrev);\n\tif (err)\n\t\treturn err;\n\n\tfw_major = (fwrev >> 12) & 0xF;\n\tfw_minor = (fwrev >>  8) & 0xF;\n\tfw_micro = fwrev & 0xFF;\n\tdev_info(dev, \"hw rev 0x%x, fw product code %d, firmware rev %d.%d.%d\",\n\t\t hwrev & 0x1F, fwprod, fw_major, fw_minor, fw_micro);\n\n\tif (fw_major != FIRMWARE_MAJOR || fw_minor < FIRMWARE_MINOR) {\n\t\tdev_err(dev, \"unsupported firmware. driver supports %d.%d\",\n\t\t\tFIRMWARE_MAJOR, FIRMWARE_MINOR);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int zl38_bus_read(void *context,\n\t\t\t const void *reg_buf, size_t reg_size,\n\t\t\t void *val_buf, size_t val_size)\n{\n\tstruct spi_device *spi = context;\n\tconst u8 *reg_buf8 = reg_buf;\n\tsize_t len = 0;\n\tu8 offs, page;\n\tu8 txbuf[4];\n\n\tif (reg_size != 2 || val_size > ZL38_MAX_RAW_XFER)\n\t\treturn -EINVAL;\n\n\toffs = reg_buf8[1] >> 1;\n\tpage = reg_buf8[0];\n\n\tif (page) {\n\t\ttxbuf[len++] = 0xFE;\n\t\ttxbuf[len++] = page == HBI_FIRMWARE_PAGE ? 0xFF : page - 1;\n\t\ttxbuf[len++] = offs;\n\t\ttxbuf[len++] = val_size / 2 - 1;\n\t} else {\n\t\ttxbuf[len++] = offs | 0x80;\n\t\ttxbuf[len++] = val_size / 2 - 1;\n\t}\n\n\treturn spi_write_then_read(spi, txbuf, len, val_buf, val_size);\n}\n\nstatic int zl38_bus_write(void *context, const void *data, size_t count)\n{\n\tstruct spi_device *spi = context;\n\tu8 buf[4 + ZL38_MAX_RAW_XFER];\n\tsize_t val_len, len = 0;\n\tconst u8 *data8 = data;\n\tu8 offs, page;\n\n\tif (count > (2 + ZL38_MAX_RAW_XFER) || count < 4)\n\t\treturn -EINVAL;\n\tval_len = count - 2;\n\toffs = data8[1] >> 1;\n\tpage = data8[0];\n\n\tif (page) {\n\t\tbuf[len++] = 0xFE;\n\t\tbuf[len++] = page == HBI_FIRMWARE_PAGE ? 0xFF : page - 1;\n\t\tbuf[len++] = offs;\n\t\tbuf[len++] = (val_len / 2 - 1) | 0x80;\n\t} else {\n\t\tbuf[len++] = offs | 0x80;\n\t\tbuf[len++] = (val_len / 2 - 1) | 0x80;\n\t}\n\tmemcpy(buf + len, data8 + 2, val_len);\n\tlen += val_len;\n\n\treturn spi_write(spi, buf, len);\n}\n\nstatic const struct regmap_bus zl38_regmap_bus = {\n\t.read = zl38_bus_read,\n\t.write = zl38_bus_write,\n\t.max_raw_write = ZL38_MAX_RAW_XFER,\n\t.max_raw_read = ZL38_MAX_RAW_XFER,\n};\n\nstatic const struct regmap_config zl38_regmap_conf = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.reg_stride = 2,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int zl38_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct zl38_codec_priv *priv;\n\tstruct gpio_desc *reset_gpio;\n\tint err;\n\n\t \n\treset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(reset_gpio))\n\t\treturn PTR_ERR(reset_gpio);\n\tif (reset_gpio) {\n\t\t \n\t\tusleep_range(15, 50);\n\t\t \n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\t \n\t\tusleep_range(3000, 10000);\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tdev_set_drvdata(dev, priv);\n\tpriv->regmap = devm_regmap_init(dev, &zl38_regmap_bus, spi,\n\t\t\t\t\t&zl38_regmap_conf);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\terr = zl38_load_firmware(dev, priv->regmap);\n\tif (err)\n\t\treturn err;\n\n\terr = zl38_check_revision(dev, priv->regmap);\n\tif (err)\n\t\treturn err;\n\n\tpriv->gpio_chip = devm_kmemdup(dev, &template_chip,\n\t\t\t\t       sizeof(template_chip), GFP_KERNEL);\n\tif (!priv->gpio_chip)\n\t\treturn -ENOMEM;\n\tpriv->gpio_chip->parent = dev;\n\terr = devm_gpiochip_add_data(dev, priv->gpio_chip, priv->regmap);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_multi_reg_write(priv->regmap, cp_config_stereo_bypass,\n\t\t\t\t     ARRAY_SIZE(cp_config_stereo_bypass));\n\tif (err)\n\t\treturn err;\n\t \n\terr = regmap_update_bits(priv->regmap, REG_CLK_CFG, CLK_CFG_SOURCE_XTAL,\n\t\t\t\t CLK_CFG_SOURCE_XTAL);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_snd_soc_register_component(dev, &zl38_component_dev,\n\t\t\t\t\t       &zl38_dai, 1);\n}\n\nstatic const struct of_device_id zl38_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"mscc,zl38060\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, zl38_dt_ids);\n\nstatic const struct spi_device_id zl38_spi_ids[] = {\n\t{ \"zl38060\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, zl38_spi_ids);\n\nstatic struct spi_driver zl38060_spi_driver = {\n\t.driver\t= {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = of_match_ptr(zl38_dt_ids),\n\t},\n\t.probe = zl38_spi_probe,\n\t.id_table = zl38_spi_ids,\n};\nmodule_spi_driver(zl38060_spi_driver);\n\nMODULE_DESCRIPTION(\"ASoC ZL38060 driver\");\nMODULE_AUTHOR(\"Sven Van Asbroeck <TheSven73@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}