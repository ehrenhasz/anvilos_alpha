{
  "module_name": "inno_rk3036.c",
  "hash_id": "81f341aad735238af1b89e5d17d7eb47941410eb7aa9907a671e62dfa5273ff7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/inno_rk3036.c",
  "human_readable_source": "\n \n\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/soc-dapm.h>\n#include <sound/soc-dai.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n#include \"inno_rk3036.h\"\n\nstruct rk3036_codec_priv {\n\tvoid __iomem *base;\n\tstruct clk *pclk;\n\tstruct regmap *regmap;\n\tstruct device *dev;\n};\n\nstatic const DECLARE_TLV_DB_MINMAX(rk3036_codec_hp_tlv, -39, 0);\n\nstatic int rk3036_codec_antipop_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 2;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\n\treturn 0;\n}\n\nstatic int rk3036_codec_antipop_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tint val, regval;\n\n\tregval = snd_soc_component_read(component, INNO_R09);\n\tval = ((regval >> INNO_R09_HPL_ANITPOP_SHIFT) &\n\t       INNO_R09_HP_ANTIPOP_MSK) == INNO_R09_HP_ANTIPOP_ON;\n\tucontrol->value.integer.value[0] = val;\n\n\tval = ((regval >> INNO_R09_HPR_ANITPOP_SHIFT) &\n\t       INNO_R09_HP_ANTIPOP_MSK) == INNO_R09_HP_ANTIPOP_ON;\n\tucontrol->value.integer.value[1] = val;\n\n\treturn 0;\n}\n\nstatic int rk3036_codec_antipop_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tint val, ret, regmsk;\n\n\tval = (ucontrol->value.integer.value[0] ?\n\t       INNO_R09_HP_ANTIPOP_ON : INNO_R09_HP_ANTIPOP_OFF) <<\n\t      INNO_R09_HPL_ANITPOP_SHIFT;\n\tval |= (ucontrol->value.integer.value[1] ?\n\t\tINNO_R09_HP_ANTIPOP_ON : INNO_R09_HP_ANTIPOP_OFF) <<\n\t       INNO_R09_HPR_ANITPOP_SHIFT;\n\n\tregmsk = INNO_R09_HP_ANTIPOP_MSK << INNO_R09_HPL_ANITPOP_SHIFT |\n\t\t INNO_R09_HP_ANTIPOP_MSK << INNO_R09_HPR_ANITPOP_SHIFT;\n\n\tret = snd_soc_component_update_bits(component, INNO_R09,\n\t\t\t\t\t    regmsk, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define SOC_RK3036_CODEC_ANTIPOP_DECL(xname) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = rk3036_codec_antipop_info, .get = rk3036_codec_antipop_get, \\\n\t.put = rk3036_codec_antipop_put, }\n\nstatic const struct snd_kcontrol_new rk3036_codec_dapm_controls[] = {\n\tSOC_DOUBLE_R_RANGE_TLV(\"Headphone Volume\", INNO_R07, INNO_R08,\n\t\tINNO_HP_GAIN_SHIFT, INNO_HP_GAIN_N39DB,\n\t\tINNO_HP_GAIN_0DB, 0, rk3036_codec_hp_tlv),\n\tSOC_DOUBLE(\"Zero Cross Switch\", INNO_R06, INNO_R06_VOUTL_CZ_SHIFT,\n\t\tINNO_R06_VOUTR_CZ_SHIFT, 1, 0),\n\tSOC_DOUBLE(\"Headphone Switch\", INNO_R09, INNO_R09_HPL_MUTE_SHIFT,\n\t\tINNO_R09_HPR_MUTE_SHIFT, 1, 0),\n\tSOC_RK3036_CODEC_ANTIPOP_DECL(\"Anti-pop Switch\"),\n};\n\nstatic const struct snd_kcontrol_new rk3036_codec_hpl_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC Left Out Switch\", INNO_R09,\n\t\t\tINNO_R09_DACL_SWITCH_SHIFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new rk3036_codec_hpr_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC Right Out Switch\", INNO_R09,\n\t\t\tINNO_R09_DACR_SWITCH_SHIFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new rk3036_codec_hpl_switch_controls[] = {\n\tSOC_DAPM_SINGLE(\"HP Left Out Switch\", INNO_R05,\n\t\t\tINNO_R05_HPL_WORK_SHIFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new rk3036_codec_hpr_switch_controls[] = {\n\tSOC_DAPM_SINGLE(\"HP Right Out Switch\", INNO_R05,\n\t\t\tINNO_R05_HPR_WORK_SHIFT, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget rk3036_codec_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY_S(\"DAC PWR\", 1, INNO_R06,\n\t\t\t      INNO_R06_DAC_EN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACL VREF\", 2, INNO_R04,\n\t\t\t      INNO_R04_DACL_VREF_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACR VREF\", 2, INNO_R04,\n\t\t\t      INNO_R04_DACR_VREF_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACL HiLo VREF\", 3, INNO_R06,\n\t\t\t      INNO_R06_DACL_HILO_VREF_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACR HiLo VREF\", 3, INNO_R06,\n\t\t\t      INNO_R06_DACR_HILO_VREF_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACR CLK\", 3, INNO_R04,\n\t\t\t      INNO_R04_DACR_CLK_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACL CLK\", 3, INNO_R04,\n\t\t\t      INNO_R04_DACL_CLK_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"DACL\", \"Left Playback\", INNO_R04,\n\t\t\t INNO_R04_DACL_SW_SHIFT, 0),\n\tSND_SOC_DAPM_DAC(\"DACR\", \"Right Playback\", INNO_R04,\n\t\t\t INNO_R04_DACR_SW_SHIFT, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\trk3036_codec_hpl_mixer_controls,\n\t\tARRAY_SIZE(rk3036_codec_hpl_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Right Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\trk3036_codec_hpr_mixer_controls,\n\t\tARRAY_SIZE(rk3036_codec_hpr_mixer_controls)),\n\n\tSND_SOC_DAPM_PGA(\"HP Left Out\", INNO_R05,\n\t\t\t INNO_R05_HPL_EN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP Right Out\", INNO_R05,\n\t\t\t INNO_R05_HPR_EN_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"HP Left Switch\",  SND_SOC_NOPM, 0, 0,\n\t\t\t   rk3036_codec_hpl_switch_controls,\n\t\t\t   ARRAY_SIZE(rk3036_codec_hpl_switch_controls)),\n\tSND_SOC_DAPM_MIXER(\"HP Right Switch\",  SND_SOC_NOPM, 0, 0,\n\t\t\t   rk3036_codec_hpr_switch_controls,\n\t\t\t   ARRAY_SIZE(rk3036_codec_hpr_switch_controls)),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n};\n\nstatic const struct snd_soc_dapm_route rk3036_codec_dapm_routes[] = {\n\t{\"DACL VREF\", NULL, \"DAC PWR\"},\n\t{\"DACR VREF\", NULL, \"DAC PWR\"},\n\t{\"DACL HiLo VREF\", NULL, \"DAC PWR\"},\n\t{\"DACR HiLo VREF\", NULL, \"DAC PWR\"},\n\t{\"DACL CLK\", NULL, \"DAC PWR\"},\n\t{\"DACR CLK\", NULL, \"DAC PWR\"},\n\n\t{\"DACL\", NULL, \"DACL VREF\"},\n\t{\"DACL\", NULL, \"DACL HiLo VREF\"},\n\t{\"DACL\", NULL, \"DACL CLK\"},\n\t{\"DACR\", NULL, \"DACR VREF\"},\n\t{\"DACR\", NULL, \"DACR HiLo VREF\"},\n\t{\"DACR\", NULL, \"DACR CLK\"},\n\n\t{\"Left Headphone Mixer\", \"DAC Left Out Switch\", \"DACL\"},\n\t{\"Right Headphone Mixer\", \"DAC Right Out Switch\", \"DACR\"},\n\t{\"HP Left Out\", NULL, \"Left Headphone Mixer\"},\n\t{\"HP Right Out\", NULL, \"Right Headphone Mixer\"},\n\n\t{\"HP Left Switch\", \"HP Left Out Switch\", \"HP Left Out\"},\n\t{\"HP Right Switch\", \"HP Right Out Switch\", \"HP Right Out\"},\n\n\t{\"HPL\", NULL, \"HP Left Switch\"},\n\t{\"HPR\", NULL, \"HP Right Switch\"},\n};\n\nstatic int rk3036_codec_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int reg01_val = 0,  reg02_val = 0, reg03_val = 0;\n\n\tdev_dbg(component->dev, \"rk3036_codec dai set fmt : %08x\\n\", fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\treg01_val |= INNO_R01_PINDIR_IN_SLAVE |\n\t\t\t     INNO_R01_I2SMODE_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\treg01_val |= INNO_R01_PINDIR_OUT_MASTER |\n\t\t\t     INNO_R01_I2SMODE_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"invalid fmt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg02_val |= INNO_R02_DACM_PCM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\treg02_val |= INNO_R02_DACM_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\treg02_val |= INNO_R02_DACM_RJM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg02_val |= INNO_R02_DACM_LJM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"set dai format failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\treg02_val |= INNO_R02_LRCP_NORMAL;\n\t\treg03_val |= INNO_R03_BCP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\treg02_val |= INNO_R02_LRCP_REVERSAL;\n\t\treg03_val |= INNO_R03_BCP_REVERSAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg02_val |= INNO_R02_LRCP_REVERSAL;\n\t\treg03_val |= INNO_R03_BCP_NORMAL;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\treg02_val |= INNO_R02_LRCP_NORMAL;\n\t\treg03_val |= INNO_R03_BCP_REVERSAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"set dai format failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, INNO_R01, INNO_R01_I2SMODE_MSK |\n\t\t\t    INNO_R01_PINDIR_MSK, reg01_val);\n\tsnd_soc_component_update_bits(component, INNO_R02, INNO_R02_LRCP_MSK |\n\t\t\t    INNO_R02_DACM_MSK, reg02_val);\n\tsnd_soc_component_update_bits(component, INNO_R03, INNO_R03_BCP_MSK, reg03_val);\n\n\treturn 0;\n}\n\nstatic int rk3036_codec_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *hw_params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int reg02_val = 0, reg03_val = 0;\n\n\tswitch (params_format(hw_params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\treg02_val |= INNO_R02_VWL_16BIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\treg02_val |= INNO_R02_VWL_20BIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_LE:\n\t\treg02_val |= INNO_R02_VWL_24BIT;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S32_LE:\n\t\treg02_val |= INNO_R02_VWL_32BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg02_val |= INNO_R02_LRCP_NORMAL;\n\treg03_val |= INNO_R03_FWL_32BIT | INNO_R03_DACR_WORK;\n\n\tsnd_soc_component_update_bits(component, INNO_R02, INNO_R02_LRCP_MSK |\n\t\t\t    INNO_R02_VWL_MSK, reg02_val);\n\tsnd_soc_component_update_bits(component, INNO_R03, INNO_R03_DACR_MSK |\n\t\t\t    INNO_R03_FWL_MSK, reg03_val);\n\treturn 0;\n}\n\n#define RK3036_CODEC_RATES (SNDRV_PCM_RATE_8000  | \\\n\t\t\t    SNDRV_PCM_RATE_16000 | \\\n\t\t\t    SNDRV_PCM_RATE_32000 | \\\n\t\t\t    SNDRV_PCM_RATE_44100 | \\\n\t\t\t    SNDRV_PCM_RATE_48000 | \\\n\t\t\t    SNDRV_PCM_RATE_96000)\n\n#define RK3036_CODEC_FMTS (SNDRV_PCM_FMTBIT_S16_LE  | \\\n\t\t\t   SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE  | \\\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops rk3036_codec_dai_ops = {\n\t.set_fmt\t= rk3036_codec_dai_set_fmt,\n\t.hw_params\t= rk3036_codec_dai_hw_params,\n};\n\nstatic struct snd_soc_dai_driver rk3036_codec_dai_driver[] = {\n\t{\n\t\t.name = \"rk3036-codec-dai\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RK3036_CODEC_RATES,\n\t\t\t.formats = RK3036_CODEC_FMTS,\n\t\t},\n\t\t.ops = &rk3036_codec_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n};\n\nstatic void rk3036_codec_reset(struct snd_soc_component *component)\n{\n\tsnd_soc_component_write(component, INNO_R00,\n\t\t      INNO_R00_CSR_RESET | INNO_R00_CDCR_RESET);\n\tsnd_soc_component_write(component, INNO_R00,\n\t\t      INNO_R00_CSR_WORK | INNO_R00_CDCR_WORK);\n}\n\nstatic int rk3036_codec_probe(struct snd_soc_component *component)\n{\n\trk3036_codec_reset(component);\n\treturn 0;\n}\n\nstatic void rk3036_codec_remove(struct snd_soc_component *component)\n{\n\trk3036_codec_reset(component);\n}\n\nstatic int rk3036_codec_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tsnd_soc_component_write(component, INNO_R10, INNO_R10_MAX_CUR);\n\t\t \n\t\tsnd_soc_component_write(component, INNO_R06, INNO_R06_DAC_PRECHARGE);\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_write(component, INNO_R10, INNO_R10_MAX_CUR);\n\t\t \n\t\tsnd_soc_component_write(component, INNO_R06, INNO_R06_DAC_DISCHARGE);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver rk3036_codec_driver = {\n\t.probe\t\t\t= rk3036_codec_probe,\n\t.remove\t\t\t= rk3036_codec_remove,\n\t.set_bias_level\t\t= rk3036_codec_set_bias_level,\n\t.controls\t\t= rk3036_codec_dapm_controls,\n\t.num_controls\t\t= ARRAY_SIZE(rk3036_codec_dapm_controls),\n\t.dapm_routes\t\t= rk3036_codec_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(rk3036_codec_dapm_routes),\n\t.dapm_widgets\t\t= rk3036_codec_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(rk3036_codec_dapm_widgets),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rk3036_codec_regmap_config = {\n\t.reg_bits = 32,\n\t.reg_stride = 4,\n\t.val_bits = 32,\n};\n\n#define GRF_SOC_CON0\t\t0x00140\n#define GRF_ACODEC_SEL\t\t(BIT(10) | BIT(16 + 10))\n\nstatic int rk3036_codec_platform_probe(struct platform_device *pdev)\n{\n\tstruct rk3036_codec_priv *priv;\n\tstruct device_node *of_node = pdev->dev.of_node;\n\tvoid __iomem *base;\n\tstruct regmap *grf;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->base = base;\n\tpriv->regmap = devm_regmap_init_mmio(&pdev->dev, priv->base,\n\t\t\t\t\t     &rk3036_codec_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(&pdev->dev, \"init regmap failed\\n\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tgrf = syscon_regmap_lookup_by_phandle(of_node, \"rockchip,grf\");\n\tif (IS_ERR(grf)) {\n\t\tdev_err(&pdev->dev, \"needs 'rockchip,grf' property\\n\");\n\t\treturn PTR_ERR(grf);\n\t}\n\tret = regmap_write(grf, GRF_SOC_CON0, GRF_ACODEC_SEL);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Could not write to GRF: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->pclk = devm_clk_get(&pdev->dev, \"acodec_pclk\");\n\tif (IS_ERR(priv->pclk))\n\t\treturn PTR_ERR(priv->pclk);\n\n\tret = clk_prepare_enable(priv->pclk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable clk\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tret = devm_snd_soc_register_component(&pdev->dev, &rk3036_codec_driver,\n\t\t\t\t     rk3036_codec_dai_driver,\n\t\t\t\t     ARRAY_SIZE(rk3036_codec_dai_driver));\n\tif (ret) {\n\t\tclk_disable_unprepare(priv->pclk);\n\t\tdev_set_drvdata(&pdev->dev, NULL);\n\t}\n\n\treturn ret;\n}\n\nstatic void rk3036_codec_platform_remove(struct platform_device *pdev)\n{\n\tstruct rk3036_codec_priv *priv = dev_get_drvdata(&pdev->dev);\n\n\tclk_disable_unprepare(priv->pclk);\n}\n\nstatic const struct of_device_id rk3036_codec_of_match[] __maybe_unused = {\n\t{ .compatible = \"rockchip,rk3036-codec\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, rk3036_codec_of_match);\n\nstatic struct platform_driver rk3036_codec_platform_driver = {\n\t.driver = {\n\t\t.name = \"rk3036-codec-platform\",\n\t\t.of_match_table = of_match_ptr(rk3036_codec_of_match),\n\t},\n\t.probe = rk3036_codec_platform_probe,\n\t.remove_new = rk3036_codec_platform_remove,\n};\n\nmodule_platform_driver(rk3036_codec_platform_driver);\n\nMODULE_AUTHOR(\"Rockchip Inc.\");\nMODULE_DESCRIPTION(\"Rockchip rk3036 codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}