{
  "module_name": "cs42l56.c",
  "hash_id": "a8eb780d91b58a94d0b00be8069456e02435513ef4376f2fcfe5f62271d20526",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l56.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/input.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs42l56.h>\n#include \"cs42l56.h\"\n\n#define CS42L56_NUM_SUPPLIES 3\nstatic const char *const cs42l56_supply_names[CS42L56_NUM_SUPPLIES] = {\n\t\"VA\",\n\t\"VCP\",\n\t\"VLDO\",\n};\n\nstruct  cs42l56_private {\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct device *dev;\n\tstruct cs42l56_platform_data pdata;\n\tstruct regulator_bulk_data supplies[CS42L56_NUM_SUPPLIES];\n\tu32 mclk;\n\tu8 mclk_prediv;\n\tu8 mclk_div2;\n\tu8 mclk_ratio;\n\tu8 iface;\n\tu8 iface_fmt;\n\tu8 iface_inv;\n#if IS_ENABLED(CONFIG_INPUT)\n\tstruct input_dev *beep;\n\tstruct work_struct beep_work;\n\tint beep_rate;\n#endif\n};\n\nstatic const struct reg_default cs42l56_reg_defaults[] = {\n\t{ 3, 0x7f },\t \n\t{ 4, 0xff },\t \n\t{ 5, 0x00 },\t \n\t{ 6, 0x0b },\t \n\t{ 7, 0x00 },\t \n\t{ 8, 0x05 },\t \n\t{ 9, 0x0c },\t \n\t{ 10, 0x80 },\t \n\t{ 11, 0x00 },\t \n\t{ 12, 0x0c },\t \n\t{ 13, 0x00 },\t \n\t{ 14, 0x00 },\t \n\t{ 15, 0x00 },\t \n\t{ 16, 0x00 },\t \n\t{ 17, 0x00 },\t \n\t{ 18, 0x00 },\t \n\t{ 19, 0x00 },\t \n\t{ 20, 0x00 },\t \n\t{ 21, 0x00 },\t \n\t{ 22, 0x00 },\t \n\t{ 23, 0x00 },\t \n\t{ 24, 0x88 },\t \n\t{ 25, 0x00 },\t \n\t{ 26, 0x00 },\t \n\t{ 27, 0xa0 },\t \n\t{ 28, 0x00 },\t \n\t{ 29, 0x00 },\t \n\t{ 30, 0x00 },\t \n\t{ 31, 0x00 },\t \n\t{ 32, 0x00 },\t \n\t{ 33, 0x00 },\t \n\t{ 34, 0x00 },\t \n\t{ 35, 0xbf },\t \n\t{ 36, 0x00 },\t \n\t{ 37, 0x00 },\t \n\t{ 38, 0x00 },\t \n\t{ 39, 0x00 },\t \n\t{ 40, 0x00 },\t \n\t{ 41, 0x00 },\t \n\t{ 42, 0x00 },\t \n\t{ 43, 0x00 },\t \n\t{ 44, 0x00 },\t \n\t{ 45, 0x7f },\t \n\t{ 46, 0x00 },\t \n};\n\nstatic bool cs42l56_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L56_CHIP_ID_1 ... CS42L56_LIM_ATTACK_RATE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42l56_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L56_INT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(beep_tlv, -5000, 200, 0);\nstatic DECLARE_TLV_DB_SCALE(hl_tlv, -6000, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(adv_tlv, -10200, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(adc_tlv, -9600, 100, 0);\nstatic DECLARE_TLV_DB_SCALE(tone_tlv, -1050, 150, 0);\nstatic DECLARE_TLV_DB_SCALE(preamp_tlv, 0, 1000, 0);\nstatic DECLARE_TLV_DB_SCALE(pga_tlv, -600, 50, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(ngnb_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-8200, 600, 0),\n\t2, 5, TLV_DB_SCALE_ITEM(-7600, 300, 0)\n);\nstatic const DECLARE_TLV_DB_RANGE(ngb_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-6400, 600, 0),\n\t3, 7, TLV_DB_SCALE_ITEM(-4600, 300, 0)\n);\nstatic const DECLARE_TLV_DB_RANGE(alc_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-3000, 600, 0),\n\t3, 7, TLV_DB_SCALE_ITEM(-1200, 300, 0)\n);\n\nstatic const char * const beep_config_text[] = {\n\t\"Off\", \"Single\", \"Multiple\", \"Continuous\"\n};\n\nstatic const struct soc_enum beep_config_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 6,\n\t\t\tARRAY_SIZE(beep_config_text), beep_config_text);\n\nstatic const char * const beep_pitch_text[] = {\n\t\"C4\", \"C5\", \"D5\", \"E5\", \"F5\", \"G5\", \"A5\", \"B5\",\n\t\"C6\", \"D6\", \"E6\", \"F6\", \"G6\", \"A6\", \"B6\", \"C7\"\n};\n\nstatic const struct soc_enum beep_pitch_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_ONTIME, 4,\n\t\t\tARRAY_SIZE(beep_pitch_text), beep_pitch_text);\n\nstatic const char * const beep_ontime_text[] = {\n\t\"86 ms\", \"430 ms\", \"780 ms\", \"1.20 s\", \"1.50 s\",\n\t\"1.80 s\", \"2.20 s\", \"2.50 s\", \"2.80 s\", \"3.20 s\",\n\t\"3.50 s\", \"3.80 s\", \"4.20 s\", \"4.50 s\", \"4.80 s\", \"5.20 s\"\n};\n\nstatic const struct soc_enum beep_ontime_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_ONTIME, 0,\n\t\t\tARRAY_SIZE(beep_ontime_text), beep_ontime_text);\n\nstatic const char * const beep_offtime_text[] = {\n\t\"1.23 s\", \"2.58 s\", \"3.90 s\", \"5.20 s\",\n\t\"6.60 s\", \"8.05 s\", \"9.35 s\", \"10.80 s\"\n};\n\nstatic const struct soc_enum beep_offtime_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_FREQ_OFFTIME, 5,\n\t\t\tARRAY_SIZE(beep_offtime_text), beep_offtime_text);\n\nstatic const char * const beep_treble_text[] = {\n\t\"5kHz\", \"7kHz\", \"10kHz\", \"15kHz\"\n};\n\nstatic const struct soc_enum beep_treble_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 3,\n\t\t\tARRAY_SIZE(beep_treble_text), beep_treble_text);\n\nstatic const char * const beep_bass_text[] = {\n\t\"50Hz\", \"100Hz\", \"200Hz\", \"250Hz\"\n};\n\nstatic const struct soc_enum beep_bass_enum =\n\tSOC_ENUM_SINGLE(CS42L56_BEEP_TONE_CFG, 1,\n\t\t\tARRAY_SIZE(beep_bass_text), beep_bass_text);\n\nstatic const char * const pgaa_mux_text[] = {\n\t\"AIN1A\", \"AIN2A\", \"AIN3A\"};\n\nstatic const struct soc_enum pgaa_mux_enum =\n\tSOC_ENUM_SINGLE(CS42L56_PGAA_MUX_VOLUME, 0,\n\t\t\t      ARRAY_SIZE(pgaa_mux_text),\n\t\t\t      pgaa_mux_text);\n\nstatic const struct snd_kcontrol_new pgaa_mux =\n\tSOC_DAPM_ENUM(\"Route\", pgaa_mux_enum);\n\nstatic const char * const pgab_mux_text[] = {\n\t\"AIN1B\", \"AIN2B\", \"AIN3B\"};\n\nstatic const struct soc_enum pgab_mux_enum =\n\tSOC_ENUM_SINGLE(CS42L56_PGAB_MUX_VOLUME, 0,\n\t\t\t      ARRAY_SIZE(pgab_mux_text),\n\t\t\t      pgab_mux_text);\n\nstatic const struct snd_kcontrol_new pgab_mux =\n\tSOC_DAPM_ENUM(\"Route\", pgab_mux_enum);\n\nstatic const char * const adca_mux_text[] = {\n\t\"PGAA\", \"AIN1A\", \"AIN2A\", \"AIN3A\"};\n\nstatic const struct soc_enum adca_mux_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AIN_REFCFG_ADC_MUX, 0,\n\t\t\t      ARRAY_SIZE(adca_mux_text),\n\t\t\t      adca_mux_text);\n\nstatic const struct snd_kcontrol_new adca_mux =\n\tSOC_DAPM_ENUM(\"Route\", adca_mux_enum);\n\nstatic const char * const adcb_mux_text[] = {\n\t\"PGAB\", \"AIN1B\", \"AIN2B\", \"AIN3B\"};\n\nstatic const struct soc_enum adcb_mux_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AIN_REFCFG_ADC_MUX, 2,\n\t\t\t      ARRAY_SIZE(adcb_mux_text),\n\t\t\t      adcb_mux_text);\n\nstatic const struct snd_kcontrol_new adcb_mux =\n\tSOC_DAPM_ENUM(\"Route\", adcb_mux_enum);\n\nstatic const char * const left_swap_text[] = {\n\t\"Left\", \"LR 2\", \"Right\"};\n\nstatic const char * const right_swap_text[] = {\n\t\"Right\", \"LR 2\", \"Left\"};\n\nstatic const unsigned int swap_values[] = { 0, 1, 3 };\n\nstatic const struct soc_enum adca_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 0, 3,\n\t\t\t      ARRAY_SIZE(left_swap_text),\n\t\t\t      left_swap_text,\n\t\t\t      swap_values);\nstatic const struct snd_kcontrol_new adca_swap_mux =\n\tSOC_DAPM_ENUM(\"Route\", adca_swap_enum);\n\nstatic const struct soc_enum pcma_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 4, 3,\n\t\t\t      ARRAY_SIZE(left_swap_text),\n\t\t\t      left_swap_text,\n\t\t\t      swap_values);\nstatic const struct snd_kcontrol_new pcma_swap_mux =\n\tSOC_DAPM_ENUM(\"Route\", pcma_swap_enum);\n\nstatic const struct soc_enum adcb_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 2, 3,\n\t\t\t      ARRAY_SIZE(right_swap_text),\n\t\t\t      right_swap_text,\n\t\t\t      swap_values);\nstatic const struct snd_kcontrol_new adcb_swap_mux =\n\tSOC_DAPM_ENUM(\"Route\", adcb_swap_enum);\n\nstatic const struct soc_enum pcmb_swap_enum =\n\tSOC_VALUE_ENUM_SINGLE(CS42L56_CHAN_MIX_SWAP, 6, 3,\n\t\t\t      ARRAY_SIZE(right_swap_text),\n\t\t\t      right_swap_text,\n\t\t\t      swap_values);\nstatic const struct snd_kcontrol_new pcmb_swap_mux =\n\tSOC_DAPM_ENUM(\"Route\", pcmb_swap_enum);\n\nstatic const struct snd_kcontrol_new hpa_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L56_PWRCTL_2, 6, 1, 1);\n\nstatic const struct snd_kcontrol_new hpb_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L56_PWRCTL_2, 4, 1, 1);\n\nstatic const struct snd_kcontrol_new loa_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L56_PWRCTL_2, 2, 1, 1);\n\nstatic const struct snd_kcontrol_new lob_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", CS42L56_PWRCTL_2, 0, 1, 1);\n\nstatic const char * const hploa_input_text[] = {\n\t\"DACA\", \"PGAA\"};\n\nstatic const struct soc_enum lineouta_input_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 2,\n\t\t\t      ARRAY_SIZE(hploa_input_text),\n\t\t\t      hploa_input_text);\n\nstatic const struct snd_kcontrol_new lineouta_input =\n\tSOC_DAPM_ENUM(\"Route\", lineouta_input_enum);\n\nstatic const struct soc_enum hpa_input_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 0,\n\t\t\t      ARRAY_SIZE(hploa_input_text),\n\t\t\t      hploa_input_text);\n\nstatic const struct snd_kcontrol_new hpa_input =\n\tSOC_DAPM_ENUM(\"Route\", hpa_input_enum);\n\nstatic const char * const hplob_input_text[] = {\n\t\"DACB\", \"PGAB\"};\n\nstatic const struct soc_enum lineoutb_input_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 3,\n\t\t\t      ARRAY_SIZE(hplob_input_text),\n\t\t\t      hplob_input_text);\n\nstatic const struct snd_kcontrol_new lineoutb_input =\n\tSOC_DAPM_ENUM(\"Route\", lineoutb_input_enum);\n\nstatic const struct soc_enum hpb_input_enum =\n\tSOC_ENUM_SINGLE(CS42L56_AMUTE_HPLO_MUX, 1,\n\t\t\t      ARRAY_SIZE(hplob_input_text),\n\t\t\t      hplob_input_text);\n\nstatic const struct snd_kcontrol_new hpb_input =\n\tSOC_DAPM_ENUM(\"Route\", hpb_input_enum);\n\nstatic const char * const dig_mux_text[] = {\n\t\"ADC\", \"DSP\"};\n\nstatic const struct soc_enum dig_mux_enum =\n\tSOC_ENUM_SINGLE(CS42L56_MISC_CTL, 7,\n\t\t\t      ARRAY_SIZE(dig_mux_text),\n\t\t\t      dig_mux_text);\n\nstatic const struct snd_kcontrol_new dig_mux =\n\tSOC_DAPM_ENUM(\"Route\", dig_mux_enum);\n\nstatic const char * const hpf_freq_text[] = {\n\t\"1.8Hz\", \"119Hz\", \"236Hz\", \"464Hz\"\n};\n\nstatic const struct soc_enum hpfa_freq_enum =\n\tSOC_ENUM_SINGLE(CS42L56_HPF_CTL, 0,\n\t\t\tARRAY_SIZE(hpf_freq_text), hpf_freq_text);\n\nstatic const struct soc_enum hpfb_freq_enum =\n\tSOC_ENUM_SINGLE(CS42L56_HPF_CTL, 2,\n\t\t\tARRAY_SIZE(hpf_freq_text), hpf_freq_text);\n\nstatic const char * const ng_delay_text[] = {\n\t\"50ms\", \"100ms\", \"150ms\", \"200ms\"\n};\n\nstatic const struct soc_enum ng_delay_enum =\n\tSOC_ENUM_SINGLE(CS42L56_NOISE_GATE_CTL, 0,\n\t\t\tARRAY_SIZE(ng_delay_text), ng_delay_text);\n\nstatic const struct snd_kcontrol_new cs42l56_snd_controls[] = {\n\n\tSOC_DOUBLE_R_SX_TLV(\"Master Volume\", CS42L56_MASTER_A_VOLUME,\n\t\t\t      CS42L56_MASTER_B_VOLUME, 0, 0x34, 0xE4, adv_tlv),\n\tSOC_DOUBLE(\"Master Mute Switch\", CS42L56_DSP_MUTE_CTL, 0, 1, 1, 1),\n\n\tSOC_DOUBLE_R_SX_TLV(\"ADC Mixer Volume\", CS42L56_ADCA_MIX_VOLUME,\n\t\t\t      CS42L56_ADCB_MIX_VOLUME, 0, 0x88, 0x90, hl_tlv),\n\tSOC_DOUBLE(\"ADC Mixer Mute Switch\", CS42L56_DSP_MUTE_CTL, 6, 7, 1, 1),\n\n\tSOC_DOUBLE_R_SX_TLV(\"PCM Mixer Volume\", CS42L56_PCMA_MIX_VOLUME,\n\t\t\t      CS42L56_PCMB_MIX_VOLUME, 0, 0x88, 0x90, hl_tlv),\n\tSOC_DOUBLE(\"PCM Mixer Mute Switch\", CS42L56_DSP_MUTE_CTL, 4, 5, 1, 1),\n\n\tSOC_SINGLE_TLV(\"Analog Advisory Volume\",\n\t\t\t  CS42L56_ANAINPUT_ADV_VOLUME, 0, 0x00, 1, adv_tlv),\n\tSOC_SINGLE_TLV(\"Digital Advisory Volume\",\n\t\t\t  CS42L56_DIGINPUT_ADV_VOLUME, 0, 0x00, 1, adv_tlv),\n\n\tSOC_DOUBLE_R_SX_TLV(\"PGA Volume\", CS42L56_PGAA_MUX_VOLUME,\n\t\t\t      CS42L56_PGAB_MUX_VOLUME, 0, 0x34, 0x24, pga_tlv),\n\tSOC_DOUBLE_R_TLV(\"ADC Volume\", CS42L56_ADCA_ATTENUATOR,\n\t\t\t      CS42L56_ADCB_ATTENUATOR, 0, 0x00, 1, adc_tlv),\n\tSOC_DOUBLE(\"ADC Mute Switch\", CS42L56_MISC_ADC_CTL, 2, 3, 1, 1),\n\tSOC_DOUBLE(\"ADC Boost Switch\", CS42L56_GAIN_BIAS_CTL, 3, 2, 1, 1),\n\n\tSOC_DOUBLE_R_SX_TLV(\"Headphone Volume\", CS42L56_HPA_VOLUME,\n\t\t\t      CS42L56_HPB_VOLUME, 0, 0x44, 0x48, hl_tlv),\n\tSOC_DOUBLE_R_SX_TLV(\"LineOut Volume\", CS42L56_LOA_VOLUME,\n\t\t\t      CS42L56_LOB_VOLUME, 0, 0x44, 0x48, hl_tlv),\n\n\tSOC_SINGLE_TLV(\"Bass Shelving Volume\", CS42L56_TONE_CTL,\n\t\t\t0, 0x00, 1, tone_tlv),\n\tSOC_SINGLE_TLV(\"Treble Shelving Volume\", CS42L56_TONE_CTL,\n\t\t\t4, 0x00, 1, tone_tlv),\n\n\tSOC_DOUBLE_TLV(\"PGA Preamp Volume\", CS42L56_GAIN_BIAS_CTL,\n\t\t\t4, 6, 0x02, 1, preamp_tlv),\n\n\tSOC_SINGLE(\"DSP Switch\", CS42L56_PLAYBACK_CTL, 7, 1, 1),\n\tSOC_SINGLE(\"Gang Playback Switch\", CS42L56_PLAYBACK_CTL, 4, 1, 1),\n\tSOC_SINGLE(\"Gang ADC Switch\", CS42L56_MISC_ADC_CTL, 7, 1, 1),\n\tSOC_SINGLE(\"Gang PGA Switch\", CS42L56_MISC_ADC_CTL, 6, 1, 1),\n\n\tSOC_SINGLE(\"PCMA Invert\", CS42L56_PLAYBACK_CTL, 2, 1, 1),\n\tSOC_SINGLE(\"PCMB Invert\", CS42L56_PLAYBACK_CTL, 3, 1, 1),\n\tSOC_SINGLE(\"ADCA Invert\", CS42L56_MISC_ADC_CTL, 2, 1, 1),\n\tSOC_SINGLE(\"ADCB Invert\", CS42L56_MISC_ADC_CTL, 3, 1, 1),\n\n\tSOC_DOUBLE(\"HPF Switch\", CS42L56_HPF_CTL, 5, 7, 1, 1),\n\tSOC_DOUBLE(\"HPF Freeze Switch\", CS42L56_HPF_CTL, 4, 6, 1, 1),\n\tSOC_ENUM(\"HPFA Corner Freq\", hpfa_freq_enum),\n\tSOC_ENUM(\"HPFB Corner Freq\", hpfb_freq_enum),\n\n\tSOC_SINGLE(\"Analog Soft Ramp\", CS42L56_MISC_CTL, 4, 1, 1),\n\tSOC_DOUBLE(\"Analog Soft Ramp Disable\", CS42L56_ALC_LIM_SFT_ZC,\n\t\t7, 5, 1, 1),\n\tSOC_SINGLE(\"Analog Zero Cross\", CS42L56_MISC_CTL, 3, 1, 1),\n\tSOC_DOUBLE(\"Analog Zero Cross Disable\", CS42L56_ALC_LIM_SFT_ZC,\n\t\t6, 4, 1, 1),\n\tSOC_SINGLE(\"Digital Soft Ramp\", CS42L56_MISC_CTL, 2, 1, 1),\n\tSOC_SINGLE(\"Digital Soft Ramp Disable\", CS42L56_ALC_LIM_SFT_ZC,\n\t\t3, 1, 1),\n\n\tSOC_SINGLE(\"HL Deemphasis\", CS42L56_PLAYBACK_CTL, 6, 1, 1),\n\n\tSOC_SINGLE(\"ALC Switch\", CS42L56_ALC_EN_ATTACK_RATE, 6, 1, 1),\n\tSOC_SINGLE(\"ALC Limit All Switch\", CS42L56_ALC_RELEASE_RATE, 7, 1, 1),\n\tSOC_SINGLE_RANGE(\"ALC Attack\", CS42L56_ALC_EN_ATTACK_RATE,\n\t\t\t0, 0, 0x3f, 0),\n\tSOC_SINGLE_RANGE(\"ALC Release\", CS42L56_ALC_RELEASE_RATE,\n\t\t\t0, 0x3f, 0, 0),\n\tSOC_SINGLE_TLV(\"ALC MAX\", CS42L56_ALC_THRESHOLD,\n\t\t\t5, 0x07, 1, alc_tlv),\n\tSOC_SINGLE_TLV(\"ALC MIN\", CS42L56_ALC_THRESHOLD,\n\t\t\t2, 0x07, 1, alc_tlv),\n\n\tSOC_SINGLE(\"Limiter Switch\", CS42L56_LIM_CTL_RELEASE_RATE, 7, 1, 1),\n\tSOC_SINGLE(\"Limit All Switch\", CS42L56_LIM_CTL_RELEASE_RATE, 6, 1, 1),\n\tSOC_SINGLE_RANGE(\"Limiter Attack\", CS42L56_LIM_ATTACK_RATE,\n\t\t\t0, 0, 0x3f, 0),\n\tSOC_SINGLE_RANGE(\"Limiter Release\", CS42L56_LIM_CTL_RELEASE_RATE,\n\t\t\t0, 0x3f, 0, 0),\n\tSOC_SINGLE_TLV(\"Limiter MAX\", CS42L56_LIM_THRESHOLD_CTL,\n\t\t\t5, 0x07, 1, alc_tlv),\n\tSOC_SINGLE_TLV(\"Limiter Cushion\", CS42L56_ALC_THRESHOLD,\n\t\t\t2, 0x07, 1, alc_tlv),\n\n\tSOC_SINGLE(\"NG Switch\", CS42L56_NOISE_GATE_CTL, 6, 1, 1),\n\tSOC_SINGLE(\"NG All Switch\", CS42L56_NOISE_GATE_CTL, 7, 1, 1),\n\tSOC_SINGLE(\"NG Boost Switch\", CS42L56_NOISE_GATE_CTL, 5, 1, 1),\n\tSOC_SINGLE_TLV(\"NG Unboost Threshold\", CS42L56_NOISE_GATE_CTL,\n\t\t\t2, 0x07, 1, ngnb_tlv),\n\tSOC_SINGLE_TLV(\"NG Boost Threshold\", CS42L56_NOISE_GATE_CTL,\n\t\t\t2, 0x07, 1, ngb_tlv),\n\tSOC_ENUM(\"NG Delay\", ng_delay_enum),\n\n\tSOC_ENUM(\"Beep Config\", beep_config_enum),\n\tSOC_ENUM(\"Beep Pitch\", beep_pitch_enum),\n\tSOC_ENUM(\"Beep on Time\", beep_ontime_enum),\n\tSOC_ENUM(\"Beep off Time\", beep_offtime_enum),\n\tSOC_SINGLE_SX_TLV(\"Beep Volume\", CS42L56_BEEP_FREQ_OFFTIME,\n\t\t\t0, 0x07, 0x23, beep_tlv),\n\tSOC_SINGLE(\"Beep Tone Ctl Switch\", CS42L56_BEEP_TONE_CFG, 0, 1, 1),\n\tSOC_ENUM(\"Beep Treble Corner Freq\", beep_treble_enum),\n\tSOC_ENUM(\"Beep Bass Corner Freq\", beep_bass_enum),\n\n};\n\nstatic const struct snd_soc_dapm_widget cs42l56_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_SIGGEN(\"Beep\"),\n\tSND_SOC_DAPM_SUPPLY(\"VBUF\", CS42L56_PWRCTL_1, 5, 1, NULL, 0),\n\tSND_SOC_DAPM_MICBIAS(\"MIC1 Bias\", CS42L56_PWRCTL_1, 4, 1),\n\tSND_SOC_DAPM_SUPPLY(\"Charge Pump\", CS42L56_PWRCTL_1, 3, 1, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1A\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2A\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1B\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2B\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3A\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3B\"),\n\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"SDIN\", NULL,  0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_MUX(\"Digital Output Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &dig_mux),\n\n\tSND_SOC_DAPM_PGA(\"PGAA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGAB\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MUX(\"PGAA Input Mux\",\n\t\t\tSND_SOC_NOPM, 0, 0, &pgaa_mux),\n\tSND_SOC_DAPM_MUX(\"PGAB Input Mux\",\n\t\t\tSND_SOC_NOPM, 0, 0, &pgab_mux),\n\n\tSND_SOC_DAPM_MUX(\"ADCA Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &adca_mux),\n\tSND_SOC_DAPM_MUX(\"ADCB Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &adcb_mux),\n\n\tSND_SOC_DAPM_ADC(\"ADCA\", NULL, CS42L56_PWRCTL_1, 1, 1),\n\tSND_SOC_DAPM_ADC(\"ADCB\", NULL, CS42L56_PWRCTL_1, 2, 1),\n\n\tSND_SOC_DAPM_MUX(\"ADCA Swap Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adca_swap_mux),\n\tSND_SOC_DAPM_MUX(\"ADCB Swap Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&adcb_swap_mux),\n\n\tSND_SOC_DAPM_MUX(\"PCMA Swap Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&pcma_swap_mux),\n\tSND_SOC_DAPM_MUX(\"PCMB Swap Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&pcmb_swap_mux),\n\n\tSND_SOC_DAPM_DAC(\"DACA\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DACB\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPA\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOA\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPB\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOB\"),\n\n\tSND_SOC_DAPM_SWITCH(\"Headphone Right\",\n\t\t\t    CS42L56_PWRCTL_2, 4, 1, &hpb_switch),\n\tSND_SOC_DAPM_SWITCH(\"Headphone Left\",\n\t\t\t    CS42L56_PWRCTL_2, 6, 1, &hpa_switch),\n\n\tSND_SOC_DAPM_SWITCH(\"Lineout Right\",\n\t\t\t    CS42L56_PWRCTL_2, 0, 1, &lob_switch),\n\tSND_SOC_DAPM_SWITCH(\"Lineout Left\",\n\t\t\t    CS42L56_PWRCTL_2, 2, 1, &loa_switch),\n\n\tSND_SOC_DAPM_MUX(\"LINEOUTA Input Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &lineouta_input),\n\tSND_SOC_DAPM_MUX(\"LINEOUTB Input Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &lineoutb_input),\n\tSND_SOC_DAPM_MUX(\"HPA Input Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &hpa_input),\n\tSND_SOC_DAPM_MUX(\"HPB Input Mux\", SND_SOC_NOPM,\n\t\t\t 0, 0, &hpb_input),\n\n};\n\nstatic const struct snd_soc_dapm_route cs42l56_audio_map[] = {\n\n\t{\"HiFi Capture\", \"DSP\", \"Digital Output Mux\"},\n\t{\"HiFi Capture\", \"ADC\", \"Digital Output Mux\"},\n\n\t{\"Digital Output Mux\", NULL, \"ADCA\"},\n\t{\"Digital Output Mux\", NULL, \"ADCB\"},\n\n\t{\"ADCB\", NULL, \"ADCB Swap Mux\"},\n\t{\"ADCA\", NULL, \"ADCA Swap Mux\"},\n\n\t{\"ADCA Swap Mux\", NULL, \"ADCA\"},\n\t{\"ADCB Swap Mux\", NULL, \"ADCB\"},\n\n\t{\"DACA\", \"Left\", \"ADCA Swap Mux\"},\n\t{\"DACA\", \"LR 2\", \"ADCA Swap Mux\"},\n\t{\"DACA\", \"Right\", \"ADCA Swap Mux\"},\n\n\t{\"DACB\", \"Left\", \"ADCB Swap Mux\"},\n\t{\"DACB\", \"LR 2\", \"ADCB Swap Mux\"},\n\t{\"DACB\", \"Right\", \"ADCB Swap Mux\"},\n\n\t{\"ADCA Mux\", NULL, \"AIN3A\"},\n\t{\"ADCA Mux\", NULL, \"AIN2A\"},\n\t{\"ADCA Mux\", NULL, \"AIN1A\"},\n\t{\"ADCA Mux\", NULL, \"PGAA\"},\n\t{\"ADCB Mux\", NULL, \"AIN3B\"},\n\t{\"ADCB Mux\", NULL, \"AIN2B\"},\n\t{\"ADCB Mux\", NULL, \"AIN1B\"},\n\t{\"ADCB Mux\", NULL, \"PGAB\"},\n\n\t{\"PGAA\", \"AIN1A\", \"PGAA Input Mux\"},\n\t{\"PGAA\", \"AIN2A\", \"PGAA Input Mux\"},\n\t{\"PGAA\", \"AIN3A\", \"PGAA Input Mux\"},\n\t{\"PGAB\", \"AIN1B\", \"PGAB Input Mux\"},\n\t{\"PGAB\", \"AIN2B\", \"PGAB Input Mux\"},\n\t{\"PGAB\", \"AIN3B\", \"PGAB Input Mux\"},\n\n\t{\"PGAA Input Mux\", NULL, \"AIN1A\"},\n\t{\"PGAA Input Mux\", NULL, \"AIN2A\"},\n\t{\"PGAA Input Mux\", NULL, \"AIN3A\"},\n\t{\"PGAB Input Mux\", NULL, \"AIN1B\"},\n\t{\"PGAB Input Mux\", NULL, \"AIN2B\"},\n\t{\"PGAB Input Mux\", NULL, \"AIN3B\"},\n\n\t{\"LOB\", \"Switch\", \"LINEOUTB Input Mux\"},\n\t{\"LOA\", \"Switch\", \"LINEOUTA Input Mux\"},\n\n\t{\"LINEOUTA Input Mux\", \"PGAA\", \"PGAA\"},\n\t{\"LINEOUTB Input Mux\", \"PGAB\", \"PGAB\"},\n\t{\"LINEOUTA Input Mux\", \"DACA\", \"DACA\"},\n\t{\"LINEOUTB Input Mux\", \"DACB\", \"DACB\"},\n\n\t{\"HPA\", \"Switch\", \"HPB Input Mux\"},\n\t{\"HPB\", \"Switch\", \"HPA Input Mux\"},\n\n\t{\"HPA Input Mux\", \"PGAA\", \"PGAA\"},\n\t{\"HPB Input Mux\", \"PGAB\", \"PGAB\"},\n\t{\"HPA Input Mux\", \"DACA\", \"DACA\"},\n\t{\"HPB Input Mux\", \"DACB\", \"DACB\"},\n\n\t{\"DACA\", NULL, \"PCMA Swap Mux\"},\n\t{\"DACB\", NULL, \"PCMB Swap Mux\"},\n\n\t{\"PCMB Swap Mux\", \"Left\", \"HiFi Playback\"},\n\t{\"PCMB Swap Mux\", \"LR 2\", \"HiFi Playback\"},\n\t{\"PCMB Swap Mux\", \"Right\", \"HiFi Playback\"},\n\n\t{\"PCMA Swap Mux\", \"Left\", \"HiFi Playback\"},\n\t{\"PCMA Swap Mux\", \"LR 2\", \"HiFi Playback\"},\n\t{\"PCMA Swap Mux\", \"Right\", \"HiFi Playback\"},\n\n};\n\nstruct cs42l56_clk_para {\n\tu32 mclk;\n\tu32 srate;\n\tu8 ratio;\n};\n\nstatic const struct cs42l56_clk_para clk_ratio_table[] = {\n\t \n\t{ 6000000, 8000, CS42L56_MCLK_LRCLK_768 },\n\t{ 6144000, 8000, CS42L56_MCLK_LRCLK_750 },\n\t{ 12000000, 8000, CS42L56_MCLK_LRCLK_768 },\n\t{ 12288000, 8000, CS42L56_MCLK_LRCLK_750 },\n\t{ 24000000, 8000, CS42L56_MCLK_LRCLK_768 },\n\t{ 24576000, 8000, CS42L56_MCLK_LRCLK_750 },\n\t \n\t{ 5644800, 11025, CS42L56_MCLK_LRCLK_512},\n\t{ 11289600, 11025, CS42L56_MCLK_LRCLK_512},\n\t{ 22579200, 11025, CS42L56_MCLK_LRCLK_512 },\n\t \n\t{ 6000000, 110294, CS42L56_MCLK_LRCLK_544 },\n\t{ 12000000, 110294, CS42L56_MCLK_LRCLK_544 },\n\t{ 24000000, 110294, CS42L56_MCLK_LRCLK_544 },\n\t \n\t{ 6000000, 12000, CS42L56_MCLK_LRCLK_500 },\n\t{ 6144000, 12000, CS42L56_MCLK_LRCLK_512 },\n\t{ 12000000, 12000, CS42L56_MCLK_LRCLK_500 },\n\t{ 12288000, 12000, CS42L56_MCLK_LRCLK_512 },\n\t{ 24000000, 12000, CS42L56_MCLK_LRCLK_500 },\n\t{ 24576000, 12000, CS42L56_MCLK_LRCLK_512 },\n\t \n\t{ 6000000, 16000, CS42L56_MCLK_LRCLK_375 },\n\t{ 6144000, 16000, CS42L56_MCLK_LRCLK_384 },\n\t{ 12000000, 16000, CS42L56_MCLK_LRCLK_375 },\n\t{ 12288000, 16000, CS42L56_MCLK_LRCLK_384 },\n\t{ 24000000, 16000, CS42L56_MCLK_LRCLK_375 },\n\t{ 24576000, 16000, CS42L56_MCLK_LRCLK_384 },\n\t \n\t{ 5644800, 22050, CS42L56_MCLK_LRCLK_256 },\n\t{ 11289600, 22050, CS42L56_MCLK_LRCLK_256 },\n\t{ 22579200, 22050, CS42L56_MCLK_LRCLK_256 },\n\t \n\t{ 6000000, 220588, CS42L56_MCLK_LRCLK_272 },\n\t{ 12000000, 220588, CS42L56_MCLK_LRCLK_272 },\n\t{ 24000000, 220588, CS42L56_MCLK_LRCLK_272 },\n\t \n\t{ 6000000, 24000, CS42L56_MCLK_LRCLK_250 },\n\t{ 6144000, 24000, CS42L56_MCLK_LRCLK_256 },\n\t{ 12000000, 24000, CS42L56_MCLK_LRCLK_250 },\n\t{ 12288000, 24000, CS42L56_MCLK_LRCLK_256 },\n\t{ 24000000, 24000, CS42L56_MCLK_LRCLK_250 },\n\t{ 24576000, 24000, CS42L56_MCLK_LRCLK_256 },\n\t \n\t{ 6000000, 32000, CS42L56_MCLK_LRCLK_187P5 },\n\t{ 6144000, 32000, CS42L56_MCLK_LRCLK_192 },\n\t{ 12000000, 32000, CS42L56_MCLK_LRCLK_187P5 },\n\t{ 12288000, 32000, CS42L56_MCLK_LRCLK_192 },\n\t{ 24000000, 32000, CS42L56_MCLK_LRCLK_187P5 },\n\t{ 24576000, 32000, CS42L56_MCLK_LRCLK_192 },\n\t \n\t{ 6000000, 44118, CS42L56_MCLK_LRCLK_136 },\n\t{ 12000000, 44118, CS42L56_MCLK_LRCLK_136 },\n\t{ 24000000, 44118, CS42L56_MCLK_LRCLK_136 },\n\t \n\t{ 5644800, 44100, CS42L56_MCLK_LRCLK_128 },\n\t{ 11289600, 44100, CS42L56_MCLK_LRCLK_128 },\n\t{ 22579200, 44100, CS42L56_MCLK_LRCLK_128 },\n\t \n\t{ 6000000, 48000, CS42L56_MCLK_LRCLK_125 },\n\t{ 6144000, 48000, CS42L56_MCLK_LRCLK_128 },\n\t{ 12000000, 48000, CS42L56_MCLK_LRCLK_125 },\n\t{ 12288000, 48000, CS42L56_MCLK_LRCLK_128 },\n\t{ 24000000, 48000, CS42L56_MCLK_LRCLK_125 },\n\t{ 24576000, 48000, CS42L56_MCLK_LRCLK_128 },\n};\n\nstatic int cs42l56_get_mclk_ratio(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(clk_ratio_table); i++) {\n\t\tif (clk_ratio_table[i].mclk == mclk &&\n\t\t    clk_ratio_table[i].srate == rate)\n\t\t\treturn clk_ratio_table[i].ratio;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs42l56_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase CS42L56_MCLK_5P6448MHZ:\n\tcase CS42L56_MCLK_6MHZ:\n\tcase CS42L56_MCLK_6P144MHZ:\n\t\tcs42l56->mclk_div2 = 0;\n\t\tcs42l56->mclk_prediv = 0;\n\t\tbreak;\n\tcase CS42L56_MCLK_11P2896MHZ:\n\tcase CS42L56_MCLK_12MHZ:\n\tcase CS42L56_MCLK_12P288MHZ:\n\t\tcs42l56->mclk_div2 = CS42L56_MCLK_DIV2;\n\t\tcs42l56->mclk_prediv = 0;\n\t\tbreak;\n\tcase CS42L56_MCLK_22P5792MHZ:\n\tcase CS42L56_MCLK_24MHZ:\n\tcase CS42L56_MCLK_24P576MHZ:\n\t\tcs42l56->mclk_div2 = CS42L56_MCLK_DIV2;\n\t\tcs42l56->mclk_prediv = CS42L56_MCLK_PREDIV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tcs42l56->mclk = freq;\n\n\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t    CS42L56_MCLK_PREDIV_MASK,\n\t\t\t\tcs42l56->mclk_prediv);\n\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t    CS42L56_MCLK_DIV2_MASK,\n\t\t\t\tcs42l56->mclk_div2);\n\n\treturn 0;\n}\n\nstatic int cs42l56_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs42l56->iface = CS42L56_MASTER_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs42l56->iface = CS42L56_SLAVE_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t  \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcs42l56->iface_fmt = CS42L56_DIG_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcs42l56->iface_fmt = CS42L56_DIG_FMT_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tcs42l56->iface_inv = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tcs42l56->iface_inv = CS42L56_SCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t    CS42L56_MS_MODE_MASK, cs42l56->iface);\n\tsnd_soc_component_update_bits(component, CS42L56_SERIAL_FMT,\n\t\t\t    CS42L56_DIG_FMT_MASK, cs42l56->iface_fmt);\n\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t    CS42L56_SCLK_INV_MASK, cs42l56->iface_inv);\n\treturn 0;\n}\n\nstatic int cs42l56_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L56_DSP_MUTE_CTL,\n\t\t\t\t    CS42L56_ADCAMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_ADCBMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_PCMAMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_PCMBMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_MSTB_MUTE_MASK |\n\t\t\t\t    CS42L56_MSTA_MUTE_MASK,\n\t\t\t\t    CS42L56_MUTE_ALL);\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L56_MISC_ADC_CTL,\n\t\t\t\t    CS42L56_ADCA_MUTE_MASK |\n\t\t\t\t    CS42L56_ADCB_MUTE_MASK,\n\t\t\t\t    CS42L56_MUTE_ALL);\n\t\t \n\t\tsnd_soc_component_update_bits(component, CS42L56_HPA_VOLUME,\n\t\t\t\t    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);\n\t\tsnd_soc_component_update_bits(component, CS42L56_HPB_VOLUME,\n\t\t\t\t    CS42L56_HP_MUTE_MASK, CS42L56_MUTE_ALL);\n\t\tsnd_soc_component_update_bits(component, CS42L56_LOA_VOLUME,\n\t\t\t\t    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);\n\t\tsnd_soc_component_update_bits(component, CS42L56_LOB_VOLUME,\n\t\t\t\t    CS42L56_LO_MUTE_MASK, CS42L56_MUTE_ALL);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, CS42L56_DSP_MUTE_CTL,\n\t\t\t\t    CS42L56_ADCAMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_ADCBMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_PCMAMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_PCMBMIX_MUTE_MASK |\n\t\t\t\t    CS42L56_MSTB_MUTE_MASK |\n\t\t\t\t    CS42L56_MSTA_MUTE_MASK,\n\t\t\t\t    CS42L56_UNMUTE);\n\n\t\tsnd_soc_component_update_bits(component, CS42L56_MISC_ADC_CTL,\n\t\t\t\t    CS42L56_ADCA_MUTE_MASK |\n\t\t\t\t    CS42L56_ADCB_MUTE_MASK,\n\t\t\t\t    CS42L56_UNMUTE);\n\n\t\tsnd_soc_component_update_bits(component, CS42L56_HPA_VOLUME,\n\t\t\t\t    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);\n\t\tsnd_soc_component_update_bits(component, CS42L56_HPB_VOLUME,\n\t\t\t\t    CS42L56_HP_MUTE_MASK, CS42L56_UNMUTE);\n\t\tsnd_soc_component_update_bits(component, CS42L56_LOA_VOLUME,\n\t\t\t\t    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);\n\t\tsnd_soc_component_update_bits(component, CS42L56_LOB_VOLUME,\n\t\t\t\t    CS42L56_LO_MUTE_MASK, CS42L56_UNMUTE);\n\t}\n\treturn 0;\n}\n\nstatic int cs42l56_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\tint ratio;\n\n\tratio = cs42l56_get_mclk_ratio(cs42l56->mclk, params_rate(params));\n\tif (ratio >= 0) {\n\t\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_2,\n\t\t\t\t    CS42L56_CLK_RATIO_MASK, ratio);\n\t} else {\n\t\tdev_err(component->dev, \"unsupported mclk/sclk/lrclk ratio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l56_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t\tenum snd_soc_bias_level level)\n{\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t\t    CS42L56_MCLK_DIS_MASK, 0);\n\t\tsnd_soc_component_update_bits(component, CS42L56_PWRCTL_1,\n\t\t\t\t    CS42L56_PDN_ALL_MASK, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_cache_only(cs42l56->regmap, false);\n\t\t\tregcache_sync(cs42l56->regmap);\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),\n\t\t\t\t\t\t    cs42l56->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(cs42l56->dev,\n\t\t\t\t\t\"Failed to enable regulators: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tsnd_soc_component_update_bits(component, CS42L56_PWRCTL_1,\n\t\t\t\t    CS42L56_PDN_ALL_MASK, 1);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, CS42L56_PWRCTL_1,\n\t\t\t\t    CS42L56_PDN_ALL_MASK, 1);\n\t\tsnd_soc_component_update_bits(component, CS42L56_CLKCTL_1,\n\t\t\t\t    CS42L56_MCLK_DIS_MASK, 1);\n\t\tregcache_cache_only(cs42l56->regmap, true);\n\t\tregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\n\t\t\t\t\t\t    cs42l56->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define CS42L56_RATES (SNDRV_PCM_RATE_8000_48000)\n\n#define CS42L56_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\n\nstatic const struct snd_soc_dai_ops cs42l56_ops = {\n\t.hw_params\t= cs42l56_pcm_hw_params,\n\t.mute_stream\t= cs42l56_mute,\n\t.set_fmt\t= cs42l56_set_dai_fmt,\n\t.set_sysclk\t= cs42l56_set_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs42l56_dai = {\n\t\t.name = \"cs42l56\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS42L56_RATES,\n\t\t\t.formats = CS42L56_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS42L56_RATES,\n\t\t\t.formats = CS42L56_FORMATS,\n\t\t},\n\t\t.ops = &cs42l56_ops,\n};\n\nstatic int beep_freq[] = {\n\t261, 522, 585, 667, 706, 774, 889, 1000,\n\t1043, 1200, 1333, 1412, 1600, 1714, 2000, 2182\n};\n\nstatic void cs42l56_beep_work(struct work_struct *work)\n{\n\tstruct cs42l56_private *cs42l56 =\n\t\tcontainer_of(work, struct cs42l56_private, beep_work);\n\tstruct snd_soc_component *component = cs42l56->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint i;\n\tint val = 0;\n\tint best = 0;\n\n\tif (cs42l56->beep_rate) {\n\t\tfor (i = 0; i < ARRAY_SIZE(beep_freq); i++) {\n\t\t\tif (abs(cs42l56->beep_rate - beep_freq[i]) <\n\t\t\t    abs(cs42l56->beep_rate - beep_freq[best]))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"Set beep rate %dHz for requested %dHz\\n\",\n\t\t\tbeep_freq[best], cs42l56->beep_rate);\n\n\t\tval = (best << CS42L56_BEEP_RATE_SHIFT);\n\n\t\tsnd_soc_dapm_enable_pin(dapm, \"Beep\");\n\t} else {\n\t\tdev_dbg(component->dev, \"Disabling beep\\n\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"Beep\");\n\t}\n\n\tsnd_soc_component_update_bits(component, CS42L56_BEEP_FREQ_ONTIME,\n\t\t\t    CS42L56_BEEP_FREQ_MASK, val);\n\n\tsnd_soc_dapm_sync(dapm);\n}\n\n \nstatic int cs42l56_beep_event(struct input_dev *dev, unsigned int type,\n\t\t\t     unsigned int code, int hz)\n{\n\tstruct snd_soc_component *component = input_get_drvdata(dev);\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"Beep event %x %x\\n\", code, hz);\n\n\tswitch (code) {\n\tcase SND_BELL:\n\t\tif (hz)\n\t\t\thz = 261;\n\t\tbreak;\n\tcase SND_TONE:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tcs42l56->beep_rate = hz;\n\tschedule_work(&cs42l56->beep_work);\n\treturn 0;\n}\n\nstatic ssize_t beep_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct cs42l56_private *cs42l56 = dev_get_drvdata(dev);\n\tlong int time;\n\tint ret;\n\n\tret = kstrtol(buf, 10, &time);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tinput_event(cs42l56->beep, EV_SND, SND_TONE, time);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(beep);\n\nstatic void cs42l56_init_beep(struct snd_soc_component *component)\n{\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tcs42l56->beep = devm_input_allocate_device(component->dev);\n\tif (!cs42l56->beep) {\n\t\tdev_err(component->dev, \"Failed to allocate beep device\\n\");\n\t\treturn;\n\t}\n\n\tINIT_WORK(&cs42l56->beep_work, cs42l56_beep_work);\n\tcs42l56->beep_rate = 0;\n\n\tcs42l56->beep->name = \"CS42L56 Beep Generator\";\n\tcs42l56->beep->phys = dev_name(component->dev);\n\tcs42l56->beep->id.bustype = BUS_I2C;\n\n\tcs42l56->beep->evbit[0] = BIT_MASK(EV_SND);\n\tcs42l56->beep->sndbit[0] = BIT_MASK(SND_BELL) | BIT_MASK(SND_TONE);\n\tcs42l56->beep->event = cs42l56_beep_event;\n\tcs42l56->beep->dev.parent = component->dev;\n\tinput_set_drvdata(cs42l56->beep, component);\n\n\tret = input_register_device(cs42l56->beep);\n\tif (ret != 0) {\n\t\tcs42l56->beep = NULL;\n\t\tdev_err(component->dev, \"Failed to register beep device\\n\");\n\t}\n\n\tret = device_create_file(component->dev, &dev_attr_beep);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to create keyclick file: %d\\n\",\n\t\t\tret);\n\t}\n}\n\nstatic void cs42l56_free_beep(struct snd_soc_component *component)\n{\n\tstruct cs42l56_private *cs42l56 = snd_soc_component_get_drvdata(component);\n\n\tdevice_remove_file(component->dev, &dev_attr_beep);\n\tcancel_work_sync(&cs42l56->beep_work);\n\tcs42l56->beep = NULL;\n\n\tsnd_soc_component_update_bits(component, CS42L56_BEEP_TONE_CFG,\n\t\t\t    CS42L56_BEEP_EN_MASK, 0);\n}\n\nstatic int cs42l56_probe(struct snd_soc_component *component)\n{\n\tcs42l56_init_beep(component);\n\n\treturn 0;\n}\n\nstatic void cs42l56_remove(struct snd_soc_component *component)\n{\n\tcs42l56_free_beep(component);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs42l56 = {\n\t.probe\t\t\t= cs42l56_probe,\n\t.remove\t\t\t= cs42l56_remove,\n\t.set_bias_level\t\t= cs42l56_set_bias_level,\n\t.controls\t\t= cs42l56_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42l56_snd_controls),\n\t.dapm_widgets\t\t= cs42l56_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42l56_dapm_widgets),\n\t.dapm_routes\t\t= cs42l56_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42l56_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs42l56_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS42L56_MAX_REGISTER,\n\t.reg_defaults = cs42l56_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs42l56_reg_defaults),\n\t.readable_reg = cs42l56_readable_register,\n\t.volatile_reg = cs42l56_volatile_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int cs42l56_handle_of_data(struct i2c_client *i2c_client,\n\t\t\t\t    struct cs42l56_platform_data *pdata)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tu32 val32;\n\n\tif (of_property_read_bool(np, \"cirrus,ain1a-reference-cfg\"))\n\t\tpdata->ain1a_ref_cfg = true;\n\n\tif (of_property_read_bool(np, \"cirrus,ain2a-reference-cfg\"))\n\t\tpdata->ain2a_ref_cfg = true;\n\n\tif (of_property_read_bool(np, \"cirrus,ain1b-reference-cfg\"))\n\t\tpdata->ain1b_ref_cfg = true;\n\n\tif (of_property_read_bool(np, \"cirrus,ain2b-reference-cfg\"))\n\t\tpdata->ain2b_ref_cfg = true;\n\n\tif (of_property_read_u32(np, \"cirrus,micbias-lvl\", &val32) >= 0)\n\t\tpdata->micbias_lvl = val32;\n\n\tif (of_property_read_u32(np, \"cirrus,chgfreq-divisor\", &val32) >= 0)\n\t\tpdata->chgfreq = val32;\n\n\tif (of_property_read_u32(np, \"cirrus,adaptive-pwr-cfg\", &val32) >= 0)\n\t\tpdata->adaptive_pwr = val32;\n\n\tif (of_property_read_u32(np, \"cirrus,hpf-left-freq\", &val32) >= 0)\n\t\tpdata->hpfa_freq = val32;\n\n\tif (of_property_read_u32(np, \"cirrus,hpf-left-freq\", &val32) >= 0)\n\t\tpdata->hpfb_freq = val32;\n\n\tpdata->gpio_nreset = of_get_named_gpio(np, \"cirrus,gpio-nreset\", 0);\n\n\treturn 0;\n}\n\nstatic int cs42l56_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs42l56_private *cs42l56;\n\tstruct cs42l56_platform_data *pdata =\n\t\tdev_get_platdata(&i2c_client->dev);\n\tint ret, i;\n\tunsigned int devid;\n\tunsigned int alpha_rev, metal_rev;\n\tunsigned int reg;\n\n\tcs42l56 = devm_kzalloc(&i2c_client->dev, sizeof(*cs42l56), GFP_KERNEL);\n\tif (cs42l56 == NULL)\n\t\treturn -ENOMEM;\n\tcs42l56->dev = &i2c_client->dev;\n\n\tcs42l56->regmap = devm_regmap_init_i2c(i2c_client, &cs42l56_regmap);\n\tif (IS_ERR(cs42l56->regmap)) {\n\t\tret = PTR_ERR(cs42l56->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs42l56->pdata = *pdata;\n\t} else {\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tret = cs42l56_handle_of_data(i2c_client,\n\t\t\t\t\t\t     &cs42l56->pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cs42l56->pdata.gpio_nreset) {\n\t\tret = gpio_request_one(cs42l56->pdata.gpio_nreset,\n\t\t\t\t       GPIOF_OUT_INIT_HIGH, \"CS42L56 /RST\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Failed to request /RST %d: %d\\n\",\n\t\t\t\tcs42l56->pdata.gpio_nreset, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tgpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 0);\n\t\tgpio_set_value_cansleep(cs42l56->pdata.gpio_nreset, 1);\n\t}\n\n\n\ti2c_set_clientdata(i2c_client, cs42l56);\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l56->supplies); i++)\n\t\tcs42l56->supplies[i].supply = cs42l56_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\t\t\t      ARRAY_SIZE(cs42l56->supplies),\n\t\t\t\t      cs42l56->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l56->supplies),\n\t\t\t\t    cs42l56->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(cs42l56->regmap, CS42L56_CHIP_ID_1, &reg);\n\tif (ret) {\n\t\tdev_err(&i2c_client->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tdevid = reg & CS42L56_CHIP_ID_MASK;\n\tif (devid != CS42L56_DEVID) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS42L56 Device ID (%X). Expected %X\\n\",\n\t\t\tdevid, CS42L56_DEVID);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\talpha_rev = reg & CS42L56_AREV_MASK;\n\tmetal_rev = reg & CS42L56_MTLREV_MASK;\n\n\tdev_info(&i2c_client->dev, \"Cirrus Logic CS42L56 \");\n\tdev_info(&i2c_client->dev, \"Alpha Rev %X Metal Rev %X\\n\",\n\t\t alpha_rev, metal_rev);\n\n\tif (cs42l56->pdata.ain1a_ref_cfg)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\n\t\t\t\t   CS42L56_AIN1A_REF_MASK,\n\t\t\t\t   CS42L56_AIN1A_REF_MASK);\n\n\tif (cs42l56->pdata.ain1b_ref_cfg)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\n\t\t\t\t   CS42L56_AIN1B_REF_MASK,\n\t\t\t\t   CS42L56_AIN1B_REF_MASK);\n\n\tif (cs42l56->pdata.ain2a_ref_cfg)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\n\t\t\t\t   CS42L56_AIN2A_REF_MASK,\n\t\t\t\t   CS42L56_AIN2A_REF_MASK);\n\n\tif (cs42l56->pdata.ain2b_ref_cfg)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_AIN_REFCFG_ADC_MUX,\n\t\t\t\t   CS42L56_AIN2B_REF_MASK,\n\t\t\t\t   CS42L56_AIN2B_REF_MASK);\n\n\tif (cs42l56->pdata.micbias_lvl)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_GAIN_BIAS_CTL,\n\t\t\t\t   CS42L56_MIC_BIAS_MASK,\n\t\t\t\tcs42l56->pdata.micbias_lvl);\n\n\tif (cs42l56->pdata.chgfreq)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,\n\t\t\t\t   CS42L56_CHRG_FREQ_MASK,\n\t\t\t\tcs42l56->pdata.chgfreq);\n\n\tif (cs42l56->pdata.hpfb_freq)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,\n\t\t\t\t   CS42L56_HPFB_FREQ_MASK,\n\t\t\t\tcs42l56->pdata.hpfb_freq);\n\n\tif (cs42l56->pdata.hpfa_freq)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_HPF_CTL,\n\t\t\t\t   CS42L56_HPFA_FREQ_MASK,\n\t\t\t\tcs42l56->pdata.hpfa_freq);\n\n\tif (cs42l56->pdata.adaptive_pwr)\n\t\tregmap_update_bits(cs42l56->regmap, CS42L56_CLASSH_CTL,\n\t\t\t\t   CS42L56_ADAPT_PWR_MASK,\n\t\t\t\tcs42l56->pdata.adaptive_pwr);\n\n\tret =  devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs42l56, &cs42l56_dai, 1);\n\tif (ret < 0)\n\t\tgoto err_enable;\n\n\treturn 0;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\n\t\t\t       cs42l56->supplies);\n\treturn ret;\n}\n\nstatic void cs42l56_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs42l56_private *cs42l56 = i2c_get_clientdata(client);\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l56->supplies),\n\t\t\t       cs42l56->supplies);\n}\n\nstatic const struct of_device_id cs42l56_of_match[] = {\n\t{ .compatible = \"cirrus,cs42l56\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs42l56_of_match);\n\n\nstatic const struct i2c_device_id cs42l56_id[] = {\n\t{ \"cs42l56\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, cs42l56_id);\n\nstatic struct i2c_driver cs42l56_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs42l56\",\n\t\t.of_match_table = cs42l56_of_match,\n\t},\n\t.id_table = cs42l56_id,\n\t.probe =    cs42l56_i2c_probe,\n\t.remove =   cs42l56_i2c_remove,\n};\n\nmodule_i2c_driver(cs42l56_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS42L56 driver\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}