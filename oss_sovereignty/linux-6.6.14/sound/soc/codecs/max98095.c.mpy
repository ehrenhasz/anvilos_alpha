{
  "module_name": "max98095.c",
  "hash_id": "b7fb55ac6fe60c2f402afd42d200120405d72aae7ab0a6278bb1fb7a9c2c15d7",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98095.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/clk.h>\n#include <linux/mutex.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/slab.h>\n#include <asm/div64.h>\n#include <sound/max98095.h>\n#include <sound/jack.h>\n#include \"max98095.h\"\n\nenum max98095_type {\n\tMAX98095,\n};\n\nstruct max98095_cdata {\n\tunsigned int rate;\n\tunsigned int fmt;\n\tint eq_sel;\n\tint bq_sel;\n};\n\nstruct max98095_priv {\n\tstruct regmap *regmap;\n\tenum max98095_type devtype;\n\tstruct max98095_pdata *pdata;\n\tstruct clk *mclk;\n\tunsigned int sysclk;\n\tstruct max98095_cdata dai[3];\n\tconst char **eq_texts;\n\tconst char **bq_texts;\n\tstruct soc_enum eq_enum;\n\tstruct soc_enum bq_enum;\n\tint eq_textcnt;\n\tint bq_textcnt;\n\tu8 lin_state;\n\tunsigned int mic1pre;\n\tunsigned int mic2pre;\n\tstruct snd_soc_jack *headphone_jack;\n\tstruct snd_soc_jack *mic_jack;\n\tstruct mutex lock;\n};\n\nstatic const struct reg_default max98095_reg_def[] = {\n\t{  0xf, 0x00 },  \n\t{ 0x10, 0x00 },  \n\t{ 0x11, 0x00 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0x00 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0x00 },  \n\t{ 0x17, 0x00 },  \n\t{ 0x18, 0x00 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1a, 0x00 },  \n\t{ 0x1b, 0x00 },  \n\t{ 0x1c, 0x00 },  \n\t{ 0x1d, 0x00 },  \n\t{ 0x1e, 0x00 },  \n\t{ 0x1f, 0x00 },  \n\t{ 0x20, 0x00 },  \n\t{ 0x21, 0x00 },  \n\t{ 0x22, 0x00 },  \n\t{ 0x23, 0x00 },  \n\t{ 0x24, 0x00 },  \n\t{ 0x25, 0x00 },  \n\t{ 0x26, 0x00 },  \n\t{ 0x27, 0x00 },  \n\t{ 0x28, 0x00 },  \n\t{ 0x29, 0x00 },  \n\t{ 0x2a, 0x00 },  \n\t{ 0x2b, 0x00 },  \n\t{ 0x2c, 0x00 },  \n\t{ 0x2d, 0x00 },  \n\t{ 0x2e, 0x00 },  \n\t{ 0x2f, 0x00 },  \n\t{ 0x30, 0x00 },  \n\t{ 0x31, 0x00 },  \n\t{ 0x32, 0x00 },  \n\t{ 0x33, 0x00 },  \n\t{ 0x34, 0x00 },  \n\t{ 0x35, 0x00 },  \n\t{ 0x36, 0x00 },  \n\t{ 0x37, 0x00 },  \n\t{ 0x38, 0x00 },  \n\t{ 0x39, 0x00 },  \n\t{ 0x3a, 0x00 },  \n\t{ 0x3b, 0x00 },  \n\t{ 0x3c, 0x00 },  \n\t{ 0x3d, 0x00 },  \n\t{ 0x3e, 0x00 },  \n\t{ 0x3f, 0x00 },  \n\t{ 0x40, 0x00 },  \n\t{ 0x41, 0x00 },  \n\t{ 0x42, 0x00 },  \n\t{ 0x43, 0x00 },  \n\t{ 0x44, 0x00 },  \n\t{ 0x45, 0x00 },  \n\t{ 0x46, 0x00 },  \n\t{ 0x47, 0x00 },  \n\t{ 0x48, 0x00 },  \n\t{ 0x49, 0x00 },  \n\t{ 0x4a, 0x00 },  \n\t{ 0x4b, 0x00 },  \n\t{ 0x4c, 0x00 },  \n\t{ 0x4d, 0x00 },  \n\t{ 0x4e, 0x00 },  \n\t{ 0x4f, 0x00 },  \n\t{ 0x50, 0x00 },  \n\t{ 0x51, 0x00 },  \n\t{ 0x52, 0x00 },  \n\t{ 0x53, 0x00 },  \n\t{ 0x54, 0x00 },  \n\t{ 0x55, 0x00 },  \n\t{ 0x56, 0x00 },  \n\t{ 0x57, 0x00 },  \n\t{ 0x58, 0x00 },  \n\t{ 0x59, 0x00 },  \n\t{ 0x5a, 0x00 },  \n\t{ 0x5b, 0x00 },  \n\t{ 0x5c, 0x00 },  \n\t{ 0x5d, 0x00 },  \n\t{ 0x5e, 0x00 },  \n\t{ 0x5f, 0x00 },  \n\t{ 0x60, 0x00 },  \n\t{ 0x61, 0x00 },  \n\t{ 0x62, 0x00 },  \n\t{ 0x63, 0x00 },  \n\t{ 0x64, 0x00 },  \n\t{ 0x65, 0x00 },  \n\t{ 0x66, 0x00 },  \n\t{ 0x67, 0x00 },  \n\t{ 0x68, 0x00 },  \n\t{ 0x69, 0x00 },  \n\t{ 0x6a, 0x00 },  \n\t{ 0x6b, 0x00 },  \n\t{ 0x6c, 0x00 },  \n\t{ 0x6d, 0x00 },  \n\t{ 0x6e, 0x00 },  \n\t{ 0x6f, 0x00 },  \n\t{ 0x70, 0x00 },  \n\t{ 0x71, 0x00 },  \n\t{ 0x72, 0x00 },  \n\t{ 0x73, 0x00 },  \n\t{ 0x74, 0x00 },  \n\t{ 0x75, 0x00 },  \n\t{ 0x76, 0x00 },  \n\t{ 0x77, 0x00 },  \n\t{ 0x78, 0x00 },  \n\t{ 0x79, 0x00 },  \n\t{ 0x7a, 0x00 },  \n\t{ 0x7b, 0x00 },  \n\t{ 0x7c, 0x00 },  \n\t{ 0x7d, 0x00 },  \n\t{ 0x7e, 0x00 },  \n\t{ 0x7f, 0x00 },  \n\t{ 0x80, 0x00 },  \n\t{ 0x81, 0x00 },  \n\t{ 0x82, 0x00 },  \n\t{ 0x83, 0x00 },  \n\t{ 0x84, 0x00 },  \n\t{ 0x85, 0x00 },  \n\t{ 0x86, 0x00 },  \n\t{ 0x87, 0x00 },  \n\t{ 0x88, 0x00 },  \n\t{ 0x89, 0x00 },  \n\t{ 0x8a, 0x00 },  \n\t{ 0x8b, 0x00 },  \n\t{ 0x8c, 0x00 },  \n\t{ 0x8d, 0x00 },  \n\t{ 0x8e, 0x00 },  \n\t{ 0x8f, 0x00 },  \n\t{ 0x90, 0x00 },  \n\t{ 0x91, 0x00 },  \n\t{ 0x92, 0x30 },  \n\t{ 0x93, 0xF0 },  \n\t{ 0x94, 0x00 },  \n\t{ 0x95, 0x00 },  \n\t{ 0x96, 0x3F },  \n\t{ 0x97, 0x00 },  \n\t{ 0xff, 0x00 },  \n};\n\nstatic bool max98095_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98095_001_HOST_INT_STS ... M98095_097_PWR_SYS:\n\tcase M98095_0FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98095_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98095_00F_HOST_CFG ... M98095_097_PWR_SYS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98095_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase M98095_000_HOST_DATA ... M98095_00E_TEMP_SENSOR_STS:\n\tcase M98095_REG_MAX_CACHED + 1 ... M98095_0FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max98095_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = max98095_reg_def,\n\t.num_reg_defaults = ARRAY_SIZE(max98095_reg_def),\n\t.max_register = M98095_0FF_REV_ID,\n\t.cache_type = REGCACHE_RBTREE,\n\n\t.readable_reg = max98095_readable,\n\t.writeable_reg = max98095_writeable,\n\t.volatile_reg = max98095_volatile,\n};\n\n \nstatic void m98095_eq_band(struct snd_soc_component *component, unsigned int dai,\n\t\t    unsigned int band, u16 *coefs)\n{\n\tunsigned int eq_reg;\n\tunsigned int i;\n\n\tif (WARN_ON(band > 4) ||\n\t    WARN_ON(dai > 1))\n\t\treturn;\n\n\t \n\teq_reg = dai ? M98095_142_DAI2_EQ_BASE : M98095_110_DAI1_EQ_BASE;\n\n\t \n\teq_reg += band * (M98095_COEFS_PER_BAND << 1);\n\n\t \n\tfor (i = 0; i < M98095_COEFS_PER_BAND; i++) {\n\t\tsnd_soc_component_write(component, eq_reg++, M98095_BYTE1(coefs[i]));\n\t\tsnd_soc_component_write(component, eq_reg++, M98095_BYTE0(coefs[i]));\n\t}\n}\n\n \nstatic void m98095_biquad_band(struct snd_soc_component *component, unsigned int dai,\n\t\t    unsigned int band, u16 *coefs)\n{\n\tunsigned int bq_reg;\n\tunsigned int i;\n\n\tif (WARN_ON(band > 1) ||\n\t    WARN_ON(dai > 1))\n\t\treturn;\n\n\t \n\tbq_reg = dai ? M98095_17E_DAI2_BQ_BASE : M98095_174_DAI1_BQ_BASE;\n\n\t \n\tbq_reg += band * (M98095_COEFS_PER_BAND << 1);\n\n\t \n\tfor (i = 0; i < M98095_COEFS_PER_BAND; i++) {\n\t\tsnd_soc_component_write(component, bq_reg++, M98095_BYTE1(coefs[i]));\n\t\tsnd_soc_component_write(component, bq_reg++, M98095_BYTE0(coefs[i]));\n\t}\n}\n\nstatic const char * const max98095_fltr_mode[] = { \"Voice\", \"Music\" };\nstatic SOC_ENUM_SINGLE_DECL(max98095_dai1_filter_mode_enum,\n\t\t\t    M98095_02E_DAI1_FILTERS, 7,\n\t\t\t    max98095_fltr_mode);\nstatic SOC_ENUM_SINGLE_DECL(max98095_dai2_filter_mode_enum,\n\t\t\t    M98095_038_DAI2_FILTERS, 7,\n\t\t\t    max98095_fltr_mode);\n\nstatic const char * const max98095_extmic_text[] = { \"None\", \"MIC1\", \"MIC2\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98095_extmic_enum,\n\t\t\t    M98095_087_CFG_MIC, 0,\n\t\t\t    max98095_extmic_text);\n\nstatic const struct snd_kcontrol_new max98095_extmic_mux =\n\tSOC_DAPM_ENUM(\"External MIC Mux\", max98095_extmic_enum);\n\nstatic const char * const max98095_linein_text[] = { \"INA\", \"INB\" };\n\nstatic SOC_ENUM_SINGLE_DECL(max98095_linein_enum,\n\t\t\t    M98095_086_CFG_LINE, 6,\n\t\t\t    max98095_linein_text);\n\nstatic const struct snd_kcontrol_new max98095_linein_mux =\n\tSOC_DAPM_ENUM(\"Linein Input Mux\", max98095_linein_enum);\n\nstatic const char * const max98095_line_mode_text[] = {\n\t\"Stereo\", \"Differential\"};\n\nstatic SOC_ENUM_SINGLE_DECL(max98095_linein_mode_enum,\n\t\t\t    M98095_086_CFG_LINE, 7,\n\t\t\t    max98095_line_mode_text);\n\nstatic SOC_ENUM_SINGLE_DECL(max98095_lineout_mode_enum,\n\t\t\t    M98095_086_CFG_LINE, 4,\n\t\t\t    max98095_line_mode_text);\n\nstatic const char * const max98095_dai_fltr[] = {\n\t\"Off\", \"Elliptical-HPF-16k\", \"Butterworth-HPF-16k\",\n\t\"Elliptical-HPF-8k\", \"Butterworth-HPF-8k\", \"Butterworth-HPF-Fs/240\"};\nstatic SOC_ENUM_SINGLE_DECL(max98095_dai1_dac_filter_enum,\n\t\t\t    M98095_02E_DAI1_FILTERS, 0,\n\t\t\t    max98095_dai_fltr);\nstatic SOC_ENUM_SINGLE_DECL(max98095_dai2_dac_filter_enum,\n\t\t\t    M98095_038_DAI2_FILTERS, 0,\n\t\t\t    max98095_dai_fltr);\nstatic SOC_ENUM_SINGLE_DECL(max98095_dai3_dac_filter_enum,\n\t\t\t    M98095_042_DAI3_FILTERS, 0,\n\t\t\t    max98095_dai_fltr);\n\nstatic int max98095_mic1pre_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tunsigned int sel = ucontrol->value.integer.value[0];\n\n\tmax98095->mic1pre = sel;\n\tsnd_soc_component_update_bits(component, M98095_05F_LVL_MIC1, M98095_MICPRE_MASK,\n\t\t(1+sel)<<M98095_MICPRE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int max98095_mic1pre_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = max98095->mic1pre;\n\treturn 0;\n}\n\nstatic int max98095_mic2pre_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tunsigned int sel = ucontrol->value.integer.value[0];\n\n\tmax98095->mic2pre = sel;\n\tsnd_soc_component_update_bits(component, M98095_060_LVL_MIC2, M98095_MICPRE_MASK,\n\t\t(1+sel)<<M98095_MICPRE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int max98095_mic2pre_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = max98095->mic2pre;\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_RANGE(max98095_micboost_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(0, 2000, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(3000, 0, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(max98095_mic_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98095_adc_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(max98095_adcboost_tlv, 0, 600, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(max98095_hp_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6700, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-4000, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1700, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(-400, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(150, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98095_spk_tlv,\n\t0, 10, TLV_DB_SCALE_ITEM(-5900, 400, 0),\n\t11, 18, TLV_DB_SCALE_ITEM(-1700, 200, 0),\n\t19, 27, TLV_DB_SCALE_ITEM(-200, 100, 0),\n\t28, 39, TLV_DB_SCALE_ITEM(650, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98095_rcv_lout_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(-6200, 400, 0),\n\t7, 14, TLV_DB_SCALE_ITEM(-3500, 300, 0),\n\t15, 21, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t22, 27, TLV_DB_SCALE_ITEM(100, 100, 0),\n\t28, 31, TLV_DB_SCALE_ITEM(650, 50, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98095_lin_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-600, 300, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(300, 1100, 0),\n\t4, 5, TLV_DB_SCALE_ITEM(1400, 600, 0)\n);\n\nstatic const struct snd_kcontrol_new max98095_snd_controls[] = {\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", M98095_064_LVL_HP_L,\n\t\tM98095_065_LVL_HP_R, 0, 31, 0, max98095_hp_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\", M98095_067_LVL_SPK_L,\n\t\tM98095_068_LVL_SPK_R, 0, 39, 0, max98095_spk_tlv),\n\n\tSOC_SINGLE_TLV(\"Receiver Volume\", M98095_066_LVL_RCV,\n\t\t0, 31, 0, max98095_rcv_lout_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Lineout Volume\", M98095_062_LVL_LINEOUT1,\n\t\tM98095_063_LVL_LINEOUT2, 0, 31, 0, max98095_rcv_lout_tlv),\n\n\tSOC_DOUBLE_R(\"Headphone Switch\", M98095_064_LVL_HP_L,\n\t\tM98095_065_LVL_HP_R, 7, 1, 1),\n\n\tSOC_DOUBLE_R(\"Speaker Switch\", M98095_067_LVL_SPK_L,\n\t\tM98095_068_LVL_SPK_R, 7, 1, 1),\n\n\tSOC_SINGLE(\"Receiver Switch\", M98095_066_LVL_RCV, 7, 1, 1),\n\n\tSOC_DOUBLE_R(\"Lineout Switch\", M98095_062_LVL_LINEOUT1,\n\t\tM98095_063_LVL_LINEOUT2, 7, 1, 1),\n\n\tSOC_SINGLE_TLV(\"MIC1 Volume\", M98095_05F_LVL_MIC1, 0, 20, 1,\n\t\tmax98095_mic_tlv),\n\n\tSOC_SINGLE_TLV(\"MIC2 Volume\", M98095_060_LVL_MIC2, 0, 20, 1,\n\t\tmax98095_mic_tlv),\n\n\tSOC_SINGLE_EXT_TLV(\"MIC1 Boost Volume\",\n\t\t\tM98095_05F_LVL_MIC1, 5, 2, 0,\n\t\t\tmax98095_mic1pre_get, max98095_mic1pre_set,\n\t\t\tmax98095_micboost_tlv),\n\tSOC_SINGLE_EXT_TLV(\"MIC2 Boost Volume\",\n\t\t\tM98095_060_LVL_MIC2, 5, 2, 0,\n\t\t\tmax98095_mic2pre_get, max98095_mic2pre_set,\n\t\t\tmax98095_micboost_tlv),\n\n\tSOC_SINGLE_TLV(\"Linein Volume\", M98095_061_LVL_LINEIN, 0, 5, 1,\n\t\tmax98095_lin_tlv),\n\n\tSOC_SINGLE_TLV(\"ADCL Volume\", M98095_05D_LVL_ADC_L, 0, 15, 1,\n\t\tmax98095_adc_tlv),\n\tSOC_SINGLE_TLV(\"ADCR Volume\", M98095_05E_LVL_ADC_R, 0, 15, 1,\n\t\tmax98095_adc_tlv),\n\n\tSOC_SINGLE_TLV(\"ADCL Boost Volume\", M98095_05D_LVL_ADC_L, 4, 3, 0,\n\t\tmax98095_adcboost_tlv),\n\tSOC_SINGLE_TLV(\"ADCR Boost Volume\", M98095_05E_LVL_ADC_R, 4, 3, 0,\n\t\tmax98095_adcboost_tlv),\n\n\tSOC_SINGLE(\"EQ1 Switch\", M98095_088_CFG_LEVEL, 0, 1, 0),\n\tSOC_SINGLE(\"EQ2 Switch\", M98095_088_CFG_LEVEL, 1, 1, 0),\n\n\tSOC_SINGLE(\"Biquad1 Switch\", M98095_088_CFG_LEVEL, 2, 1, 0),\n\tSOC_SINGLE(\"Biquad2 Switch\", M98095_088_CFG_LEVEL, 3, 1, 0),\n\n\tSOC_ENUM(\"DAI1 Filter Mode\", max98095_dai1_filter_mode_enum),\n\tSOC_ENUM(\"DAI2 Filter Mode\", max98095_dai2_filter_mode_enum),\n\tSOC_ENUM(\"DAI1 DAC Filter\", max98095_dai1_dac_filter_enum),\n\tSOC_ENUM(\"DAI2 DAC Filter\", max98095_dai2_dac_filter_enum),\n\tSOC_ENUM(\"DAI3 DAC Filter\", max98095_dai3_dac_filter_enum),\n\n\tSOC_ENUM(\"Linein Mode\", max98095_linein_mode_enum),\n\tSOC_ENUM(\"Lineout Mode\", max98095_lineout_mode_enum),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_left_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_050_MIX_SPK_LEFT, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_050_MIX_SPK_LEFT, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono DAC2 Switch\", M98095_050_MIX_SPK_LEFT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono DAC3 Switch\", M98095_050_MIX_SPK_LEFT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_050_MIX_SPK_LEFT, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_050_MIX_SPK_LEFT, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_050_MIX_SPK_LEFT, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_050_MIX_SPK_LEFT, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_right_speaker_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_051_MIX_SPK_RIGHT, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_051_MIX_SPK_RIGHT, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono DAC2 Switch\", M98095_051_MIX_SPK_RIGHT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono DAC3 Switch\", M98095_051_MIX_SPK_RIGHT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_051_MIX_SPK_RIGHT, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_051_MIX_SPK_RIGHT, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_051_MIX_SPK_RIGHT, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_051_MIX_SPK_RIGHT, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_left_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_04C_MIX_HP_LEFT, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_04C_MIX_HP_LEFT, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_04C_MIX_HP_LEFT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_04C_MIX_HP_LEFT, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_04C_MIX_HP_LEFT, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_04C_MIX_HP_LEFT, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_right_hp_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_04D_MIX_HP_RIGHT, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_04D_MIX_HP_RIGHT, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_04D_MIX_HP_RIGHT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_04D_MIX_HP_RIGHT, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_04D_MIX_HP_RIGHT, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_04D_MIX_HP_RIGHT, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_mono_rcv_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_04F_MIX_RCV, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_04F_MIX_RCV, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_04F_MIX_RCV, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_04F_MIX_RCV, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_04F_MIX_RCV, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_04F_MIX_RCV, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_left_lineout_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_053_MIX_LINEOUT1, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_053_MIX_LINEOUT1, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_053_MIX_LINEOUT1, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_053_MIX_LINEOUT1, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_053_MIX_LINEOUT1, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_053_MIX_LINEOUT1, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_right_lineout_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Left DAC1 Switch\", M98095_054_MIX_LINEOUT2, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"Right DAC1 Switch\", M98095_054_MIX_LINEOUT2, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_054_MIX_LINEOUT2, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_054_MIX_LINEOUT2, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_054_MIX_LINEOUT2, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_054_MIX_LINEOUT2, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_left_ADC_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_04A_MIX_ADC_LEFT, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_04A_MIX_ADC_LEFT, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_04A_MIX_ADC_LEFT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_04A_MIX_ADC_LEFT, 2, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new max98095_right_ADC_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"MIC1 Switch\", M98095_04B_MIX_ADC_RIGHT, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"MIC2 Switch\", M98095_04B_MIX_ADC_RIGHT, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN1 Switch\", M98095_04B_MIX_ADC_RIGHT, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"IN2 Switch\", M98095_04B_MIX_ADC_RIGHT, 2, 1, 0),\n};\n\nstatic int max98095_mic_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (w->reg == M98095_05F_LVL_MIC1) {\n\t\t\tsnd_soc_component_update_bits(component, w->reg, M98095_MICPRE_MASK,\n\t\t\t\t(1+max98095->mic1pre)<<M98095_MICPRE_SHIFT);\n\t\t} else {\n\t\t\tsnd_soc_component_update_bits(component, w->reg, M98095_MICPRE_MASK,\n\t\t\t\t(1+max98095->mic2pre)<<M98095_MICPRE_SHIFT);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, w->reg, M98095_MICPRE_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int max98095_line_pga(struct snd_soc_dapm_widget *w,\n\t\t\t     int event, u8 channel)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tu8 *state;\n\n\tif (WARN_ON(!(channel == 1 || channel == 2)))\n\t\treturn -EINVAL;\n\n\tstate = &max98095->lin_state;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t*state |= channel;\n\t\tsnd_soc_component_update_bits(component, w->reg,\n\t\t\t(1 << w->shift), (1 << w->shift));\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t*state &= ~channel;\n\t\tif (*state == 0) {\n\t\t\tsnd_soc_component_update_bits(component, w->reg,\n\t\t\t\t(1 << w->shift), 0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int max98095_pga_in1_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t   struct snd_kcontrol *k, int event)\n{\n\treturn max98095_line_pga(w, event, 1);\n}\n\nstatic int max98095_pga_in2_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t   struct snd_kcontrol *k, int event)\n{\n\treturn max98095_line_pga(w, event, 2);\n}\n\n \nstatic int max98095_lineout_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, w->reg,\n\t\t\t(1 << (w->shift+2)), (1 << (w->shift+2)));\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, w->reg,\n\t\t\t(1 << (w->shift+2)), 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget max98095_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_ADC(\"ADCL\", \"HiFi Capture\", M98095_090_PWR_EN_IN, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADCR\", \"HiFi Capture\", M98095_090_PWR_EN_IN, 1, 0),\n\n\tSND_SOC_DAPM_DAC(\"DACL1\", \"HiFi Playback\",\n\t\tM98095_091_PWR_EN_OUT, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DACR1\", \"HiFi Playback\",\n\t\tM98095_091_PWR_EN_OUT, 1, 0),\n\tSND_SOC_DAPM_DAC(\"DACM2\", \"Aux Playback\",\n\t\tM98095_091_PWR_EN_OUT, 2, 0),\n\tSND_SOC_DAPM_DAC(\"DACM3\", \"Voice Playback\",\n\t\tM98095_091_PWR_EN_OUT, 2, 0),\n\n\tSND_SOC_DAPM_PGA(\"HP Left Out\", M98095_091_PWR_EN_OUT,\n\t\t6, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP Right Out\", M98095_091_PWR_EN_OUT,\n\t\t7, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"SPK Left Out\", M98095_091_PWR_EN_OUT,\n\t\t4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"SPK Right Out\", M98095_091_PWR_EN_OUT,\n\t\t5, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"RCV Mono Out\", M98095_091_PWR_EN_OUT,\n\t\t3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_E(\"LINE Left Out\", M98095_092_PWR_EN_OUT,\n\t\t0, 0, NULL, 0, max98095_lineout_event, SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"LINE Right Out\", M98095_092_PWR_EN_OUT,\n\t\t1, 0, NULL, 0, max98095_lineout_event, SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_MUX(\"External MIC\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_extmic_mux),\n\n\tSND_SOC_DAPM_MUX(\"Linein Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_linein_mux),\n\n\tSND_SOC_DAPM_MIXER(\"Left Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_left_hp_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_left_hp_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Headphone Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_right_hp_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_right_hp_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Speaker Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_left_speaker_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_left_speaker_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Speaker Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_right_speaker_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_right_speaker_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Receiver Mixer\", SND_SOC_NOPM, 0, 0,\n\t  &max98095_mono_rcv_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_mono_rcv_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Lineout Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_left_lineout_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_left_lineout_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right Lineout Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_right_lineout_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_right_lineout_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Left ADC Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_left_ADC_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_left_ADC_mixer_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Right ADC Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&max98095_right_ADC_mixer_controls[0],\n\t\tARRAY_SIZE(max98095_right_ADC_mixer_controls)),\n\n\tSND_SOC_DAPM_PGA_E(\"MIC1 Input\", M98095_05F_LVL_MIC1,\n\t\t5, 0, NULL, 0, max98095_mic_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA_E(\"MIC2 Input\", M98095_060_LVL_MIC2,\n\t\t5, 0, NULL, 0, max98095_mic_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA_E(\"IN1 Input\", M98095_090_PWR_EN_IN,\n\t\t7, 0, NULL, 0, max98095_pga_in1_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA_E(\"IN2 Input\", M98095_090_PWR_EN_IN,\n\t\t7, 0, NULL, 0, max98095_pga_in2_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MICBIAS(\"MICBIAS1\", M98095_090_PWR_EN_IN, 2, 0),\n\tSND_SOC_DAPM_MICBIAS(\"MICBIAS2\", M98095_090_PWR_EN_IN, 3, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n\tSND_SOC_DAPM_OUTPUT(\"RCV\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT4\"),\n\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"INA1\"),\n\tSND_SOC_DAPM_INPUT(\"INA2\"),\n\tSND_SOC_DAPM_INPUT(\"INB1\"),\n\tSND_SOC_DAPM_INPUT(\"INB2\"),\n};\n\nstatic const struct snd_soc_dapm_route max98095_audio_map[] = {\n\t \n\t{\"Left Headphone Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Left Headphone Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Left Headphone Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Headphone Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Headphone Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Left Headphone Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Right Headphone Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Right Headphone Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Right Headphone Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Headphone Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Headphone Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Right Headphone Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Left Speaker Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Left Speaker Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Left Speaker Mixer\", \"Mono DAC2 Switch\", \"DACM2\"},\n\t{\"Left Speaker Mixer\", \"Mono DAC3 Switch\", \"DACM3\"},\n\t{\"Left Speaker Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Speaker Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Speaker Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Left Speaker Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Right Speaker Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Right Speaker Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Right Speaker Mixer\", \"Mono DAC2 Switch\", \"DACM2\"},\n\t{\"Right Speaker Mixer\", \"Mono DAC3 Switch\", \"DACM3\"},\n\t{\"Right Speaker Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Speaker Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Speaker Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Right Speaker Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Receiver Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Receiver Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Receiver Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Receiver Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Receiver Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Receiver Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Left Lineout Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Left Lineout Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Left Lineout Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left Lineout Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left Lineout Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Left Lineout Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Right Lineout Mixer\", \"Left DAC1 Switch\", \"DACL1\"},\n\t{\"Right Lineout Mixer\", \"Right DAC1 Switch\", \"DACR1\"},\n\t{\"Right Lineout Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right Lineout Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right Lineout Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Right Lineout Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t{\"HP Left Out\", NULL, \"Left Headphone Mixer\"},\n\t{\"HP Right Out\", NULL, \"Right Headphone Mixer\"},\n\t{\"SPK Left Out\", NULL, \"Left Speaker Mixer\"},\n\t{\"SPK Right Out\", NULL, \"Right Speaker Mixer\"},\n\t{\"RCV Mono Out\", NULL, \"Receiver Mixer\"},\n\t{\"LINE Left Out\", NULL, \"Left Lineout Mixer\"},\n\t{\"LINE Right Out\", NULL, \"Right Lineout Mixer\"},\n\n\t{\"HPL\", NULL, \"HP Left Out\"},\n\t{\"HPR\", NULL, \"HP Right Out\"},\n\t{\"SPKL\", NULL, \"SPK Left Out\"},\n\t{\"SPKR\", NULL, \"SPK Right Out\"},\n\t{\"RCV\", NULL, \"RCV Mono Out\"},\n\t{\"OUT1\", NULL, \"LINE Left Out\"},\n\t{\"OUT2\", NULL, \"LINE Right Out\"},\n\t{\"OUT3\", NULL, \"LINE Left Out\"},\n\t{\"OUT4\", NULL, \"LINE Right Out\"},\n\n\t \n\t{\"Left ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Left ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Left ADC Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Left ADC Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"Right ADC Mixer\", \"MIC1 Switch\", \"MIC1 Input\"},\n\t{\"Right ADC Mixer\", \"MIC2 Switch\", \"MIC2 Input\"},\n\t{\"Right ADC Mixer\", \"IN1 Switch\", \"IN1 Input\"},\n\t{\"Right ADC Mixer\", \"IN2 Switch\", \"IN2 Input\"},\n\n\t \n\t{\"ADCL\", NULL, \"Left ADC Mixer\"},\n\t{\"ADCR\", NULL, \"Right ADC Mixer\"},\n\n\t{\"IN1 Input\", NULL, \"INA1\"},\n\t{\"IN2 Input\", NULL, \"INA2\"},\n\n\t{\"MIC1 Input\", NULL, \"MIC1\"},\n\t{\"MIC2 Input\", NULL, \"MIC2\"},\n};\n\n \nstatic const struct {\n\tu32 rate;\n\tu8  sr;\n} rate_table[] = {\n\t{8000,  0x01},\n\t{11025, 0x02},\n\t{16000, 0x03},\n\t{22050, 0x04},\n\t{24000, 0x05},\n\t{32000, 0x06},\n\t{44100, 0x07},\n\t{48000, 0x08},\n\t{88200, 0x09},\n\t{96000, 0x0A},\n};\n\nstatic int rate_value(int rate, u8 *value)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n\t\tif (rate_table[i].rate >= rate) {\n\t\t\t*value = rate_table[i].sr;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*value = rate_table[0].sr;\n\treturn -EINVAL;\n}\n\nstatic int max98095_dai1_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tunsigned long long ni;\n\tunsigned int rate;\n\tu8 regval;\n\n\tcdata = &max98095->dai[0];\n\n\trate = params_rate(params);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tsnd_soc_component_update_bits(component, M98095_02A_DAI1_FORMAT,\n\t\t\tM98095_DAI_WS, 0);\n\t\tbreak;\n\tcase 24:\n\t\tsnd_soc_component_update_bits(component, M98095_02A_DAI1_FORMAT,\n\t\t\tM98095_DAI_WS, M98095_DAI_WS);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate_value(rate, &regval))\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, M98095_027_DAI1_CLKMODE,\n\t\tM98095_CLKMODE_MASK, regval);\n\tcdata->rate = rate;\n\n\t \n\tif (snd_soc_component_read(component, M98095_02A_DAI1_FORMAT) & M98095_DAI_MAS) {\n\t\tif (max98095->sysclk == 0) {\n\t\t\tdev_err(component->dev, \"Invalid system clock frequency\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\n\t\t\t\t* (unsigned long long int)rate;\n\t\tdo_div(ni, (unsigned long long int)max98095->sysclk);\n\t\tsnd_soc_component_write(component, M98095_028_DAI1_CLKCFG_HI,\n\t\t\t(ni >> 8) & 0x7F);\n\t\tsnd_soc_component_write(component, M98095_029_DAI1_CLKCFG_LO,\n\t\t\tni & 0xFF);\n\t}\n\n\t \n\tif (rate < 50000)\n\t\tsnd_soc_component_update_bits(component, M98095_02E_DAI1_FILTERS,\n\t\t\tM98095_DAI_DHF, 0);\n\telse\n\t\tsnd_soc_component_update_bits(component, M98095_02E_DAI1_FILTERS,\n\t\t\tM98095_DAI_DHF, M98095_DAI_DHF);\n\n\treturn 0;\n}\n\nstatic int max98095_dai2_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tunsigned long long ni;\n\tunsigned int rate;\n\tu8 regval;\n\n\tcdata = &max98095->dai[1];\n\n\trate = params_rate(params);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tsnd_soc_component_update_bits(component, M98095_034_DAI2_FORMAT,\n\t\t\tM98095_DAI_WS, 0);\n\t\tbreak;\n\tcase 24:\n\t\tsnd_soc_component_update_bits(component, M98095_034_DAI2_FORMAT,\n\t\t\tM98095_DAI_WS, M98095_DAI_WS);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate_value(rate, &regval))\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, M98095_031_DAI2_CLKMODE,\n\t\tM98095_CLKMODE_MASK, regval);\n\tcdata->rate = rate;\n\n\t \n\tif (snd_soc_component_read(component, M98095_034_DAI2_FORMAT) & M98095_DAI_MAS) {\n\t\tif (max98095->sysclk == 0) {\n\t\t\tdev_err(component->dev, \"Invalid system clock frequency\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\n\t\t\t\t* (unsigned long long int)rate;\n\t\tdo_div(ni, (unsigned long long int)max98095->sysclk);\n\t\tsnd_soc_component_write(component, M98095_032_DAI2_CLKCFG_HI,\n\t\t\t(ni >> 8) & 0x7F);\n\t\tsnd_soc_component_write(component, M98095_033_DAI2_CLKCFG_LO,\n\t\t\tni & 0xFF);\n\t}\n\n\t \n\tif (rate < 50000)\n\t\tsnd_soc_component_update_bits(component, M98095_038_DAI2_FILTERS,\n\t\t\tM98095_DAI_DHF, 0);\n\telse\n\t\tsnd_soc_component_update_bits(component, M98095_038_DAI2_FILTERS,\n\t\t\tM98095_DAI_DHF, M98095_DAI_DHF);\n\n\treturn 0;\n}\n\nstatic int max98095_dai3_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tunsigned long long ni;\n\tunsigned int rate;\n\tu8 regval;\n\n\tcdata = &max98095->dai[2];\n\n\trate = params_rate(params);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tsnd_soc_component_update_bits(component, M98095_03E_DAI3_FORMAT,\n\t\t\tM98095_DAI_WS, 0);\n\t\tbreak;\n\tcase 24:\n\t\tsnd_soc_component_update_bits(component, M98095_03E_DAI3_FORMAT,\n\t\t\tM98095_DAI_WS, M98095_DAI_WS);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate_value(rate, &regval))\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, M98095_03B_DAI3_CLKMODE,\n\t\tM98095_CLKMODE_MASK, regval);\n\tcdata->rate = rate;\n\n\t \n\tif (snd_soc_component_read(component, M98095_03E_DAI3_FORMAT) & M98095_DAI_MAS) {\n\t\tif (max98095->sysclk == 0) {\n\t\t\tdev_err(component->dev, \"Invalid system clock frequency\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\n\t\t\t\t* (unsigned long long int)rate;\n\t\tdo_div(ni, (unsigned long long int)max98095->sysclk);\n\t\tsnd_soc_component_write(component, M98095_03C_DAI3_CLKCFG_HI,\n\t\t\t(ni >> 8) & 0x7F);\n\t\tsnd_soc_component_write(component, M98095_03D_DAI3_CLKCFG_LO,\n\t\t\tni & 0xFF);\n\t}\n\n\t \n\tif (rate < 50000)\n\t\tsnd_soc_component_update_bits(component, M98095_042_DAI3_FILTERS,\n\t\t\tM98095_DAI_DHF, 0);\n\telse\n\t\tsnd_soc_component_update_bits(component, M98095_042_DAI3_FILTERS,\n\t\t\tM98095_DAI_DHF, M98095_DAI_DHF);\n\n\treturn 0;\n}\n\nstatic int max98095_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t   int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (freq == max98095->sysclk)\n\t\treturn 0;\n\n\tif (!IS_ERR(max98095->mclk)) {\n\t\tfreq = clk_round_rate(max98095->mclk, freq);\n\t\tclk_set_rate(max98095->mclk, freq);\n\t}\n\n\t \n\tif ((freq >= 10000000) && (freq < 20000000)) {\n\t\tsnd_soc_component_write(component, M98095_026_SYS_CLK, 0x10);\n\t} else if ((freq >= 20000000) && (freq < 40000000)) {\n\t\tsnd_soc_component_write(component, M98095_026_SYS_CLK, 0x20);\n\t} else if ((freq >= 40000000) && (freq < 60000000)) {\n\t\tsnd_soc_component_write(component, M98095_026_SYS_CLK, 0x30);\n\t} else {\n\t\tdev_err(component->dev, \"Invalid master clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"Clock source is %d at %uHz\\n\", clk_id, freq);\n\n\tmax98095->sysclk = freq;\n\treturn 0;\n}\n\nstatic int max98095_dai1_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tu8 regval = 0;\n\n\tcdata = &max98095->dai[0];\n\n\tif (fmt != cdata->fmt) {\n\t\tcdata->fmt = fmt;\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\t\t \n\t\t\tsnd_soc_component_write(component, M98095_028_DAI1_CLKCFG_HI,\n\t\t\t\t0x80);\n\t\t\tsnd_soc_component_write(component, M98095_029_DAI1_CLKCFG_LO,\n\t\t\t\t0x00);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t\t \n\t\t\tregval |= M98095_DAI_MAS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Clock mode unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tregval |= M98095_DAI_DLY;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tregval |= M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tregval |= M98095_DAI_BCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tregval |= M98095_DAI_BCI|M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, M98095_02A_DAI1_FORMAT,\n\t\t\tM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\n\t\t\tM98095_DAI_WCI, regval);\n\n\t\tsnd_soc_component_write(component, M98095_02B_DAI1_CLOCK, M98095_DAI_BSEL64);\n\t}\n\n\treturn 0;\n}\n\nstatic int max98095_dai2_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tu8 regval = 0;\n\n\tcdata = &max98095->dai[1];\n\n\tif (fmt != cdata->fmt) {\n\t\tcdata->fmt = fmt;\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\t\t \n\t\t\tsnd_soc_component_write(component, M98095_032_DAI2_CLKCFG_HI,\n\t\t\t\t0x80);\n\t\t\tsnd_soc_component_write(component, M98095_033_DAI2_CLKCFG_LO,\n\t\t\t\t0x00);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t\t \n\t\t\tregval |= M98095_DAI_MAS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Clock mode unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tregval |= M98095_DAI_DLY;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tregval |= M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tregval |= M98095_DAI_BCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tregval |= M98095_DAI_BCI|M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, M98095_034_DAI2_FORMAT,\n\t\t\tM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\n\t\t\tM98095_DAI_WCI, regval);\n\n\t\tsnd_soc_component_write(component, M98095_035_DAI2_CLOCK,\n\t\t\tM98095_DAI_BSEL64);\n\t}\n\n\treturn 0;\n}\n\nstatic int max98095_dai3_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tu8 regval = 0;\n\n\tcdata = &max98095->dai[2];\n\n\tif (fmt != cdata->fmt) {\n\t\tcdata->fmt = fmt;\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\t\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\t\t \n\t\t\tsnd_soc_component_write(component, M98095_03C_DAI3_CLKCFG_HI,\n\t\t\t\t0x80);\n\t\t\tsnd_soc_component_write(component, M98095_03D_DAI3_CLKCFG_LO,\n\t\t\t\t0x00);\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t\t \n\t\t\tregval |= M98095_DAI_MAS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Clock mode unsupported\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tregval |= M98095_DAI_DLY;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tregval |= M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tregval |= M98095_DAI_BCI;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tregval |= M98095_DAI_BCI|M98095_DAI_WCI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, M98095_03E_DAI3_FORMAT,\n\t\t\tM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\n\t\t\tM98095_DAI_WCI, regval);\n\n\t\tsnd_soc_component_write(component, M98095_03F_DAI3_CLOCK,\n\t\t\tM98095_DAI_BSEL64);\n\t}\n\n\treturn 0;\n}\n\nstatic int max98095_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (IS_ERR(max98095->mclk))\n\t\t\tbreak;\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_ON) {\n\t\t\tclk_disable_unprepare(max98095->mclk);\n\t\t} else {\n\t\t\tret = clk_prepare_enable(max98095->mclk);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regcache_sync(max98095->regmap);\n\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev, \"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, M98095_090_PWR_EN_IN,\n\t\t\t\tM98095_MBEN, M98095_MBEN);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, M98095_090_PWR_EN_IN,\n\t\t\t\tM98095_MBEN, 0);\n\t\tregcache_mark_dirty(max98095->regmap);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define MAX98095_RATES SNDRV_PCM_RATE_8000_96000\n#define MAX98095_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops max98095_dai1_ops = {\n\t.set_sysclk = max98095_dai_set_sysclk,\n\t.set_fmt = max98095_dai1_set_fmt,\n\t.hw_params = max98095_dai1_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops max98095_dai2_ops = {\n\t.set_sysclk = max98095_dai_set_sysclk,\n\t.set_fmt = max98095_dai2_set_fmt,\n\t.hw_params = max98095_dai2_hw_params,\n};\n\nstatic const struct snd_soc_dai_ops max98095_dai3_ops = {\n\t.set_sysclk = max98095_dai_set_sysclk,\n\t.set_fmt = max98095_dai3_set_fmt,\n\t.hw_params = max98095_dai3_hw_params,\n};\n\nstatic struct snd_soc_dai_driver max98095_dai[] = {\n{\n\t.name = \"HiFi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MAX98095_RATES,\n\t\t.formats = MAX98095_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = MAX98095_RATES,\n\t\t.formats = MAX98095_FORMATS,\n\t},\n\t .ops = &max98095_dai1_ops,\n},\n{\n\t.name = \"Aux\",\n\t.playback = {\n\t\t.stream_name = \"Aux Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = MAX98095_RATES,\n\t\t.formats = MAX98095_FORMATS,\n\t},\n\t.ops = &max98095_dai2_ops,\n},\n{\n\t.name = \"Voice\",\n\t.playback = {\n\t\t.stream_name = \"Voice Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = MAX98095_RATES,\n\t\t.formats = MAX98095_FORMATS,\n\t},\n\t.ops = &max98095_dai3_ops,\n}\n\n};\n\nstatic int max98095_get_eq_channel(const char *name)\n{\n\tif (strcmp(name, \"EQ1 Mode\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"EQ2 Mode\") == 0)\n\t\treturn 1;\n\treturn -EINVAL;\n}\n\nstatic int max98095_put_eq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_pdata *pdata = max98095->pdata;\n\tint channel = max98095_get_eq_channel(kcontrol->id.name);\n\tstruct max98095_cdata *cdata;\n\tunsigned int sel = ucontrol->value.enumerated.item[0];\n\tstruct max98095_eq_cfg *coef_set;\n\tint fs, best, best_val, i;\n\tint regmask, regsave;\n\n\tif (WARN_ON(channel > 1))\n\t\treturn -EINVAL;\n\n\tif (!pdata || !max98095->eq_textcnt)\n\t\treturn 0;\n\n\tif (sel >= pdata->eq_cfgcnt)\n\t\treturn -EINVAL;\n\n\tcdata = &max98095->dai[channel];\n\tcdata->eq_sel = sel;\n\tfs = cdata->rate;\n\n\t \n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < pdata->eq_cfgcnt; i++) {\n\t\tif (strcmp(pdata->eq_cfg[i].name, max98095->eq_texts[sel]) == 0 &&\n\t\t\tabs(pdata->eq_cfg[i].rate - fs) < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = abs(pdata->eq_cfg[i].rate - fs);\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"Selected %s/%dHz for %dHz sample rate\\n\",\n\t\tpdata->eq_cfg[best].name,\n\t\tpdata->eq_cfg[best].rate, fs);\n\n\tcoef_set = &pdata->eq_cfg[best];\n\n\tregmask = (channel == 0) ? M98095_EQ1EN : M98095_EQ2EN;\n\n\t \n\tregsave = snd_soc_component_read(component, M98095_088_CFG_LEVEL);\n\tsnd_soc_component_update_bits(component, M98095_088_CFG_LEVEL, regmask, 0);\n\n\tmutex_lock(&max98095->lock);\n\tsnd_soc_component_update_bits(component, M98095_00F_HOST_CFG, M98095_SEG, M98095_SEG);\n\tm98095_eq_band(component, channel, 0, coef_set->band1);\n\tm98095_eq_band(component, channel, 1, coef_set->band2);\n\tm98095_eq_band(component, channel, 2, coef_set->band3);\n\tm98095_eq_band(component, channel, 3, coef_set->band4);\n\tm98095_eq_band(component, channel, 4, coef_set->band5);\n\tsnd_soc_component_update_bits(component, M98095_00F_HOST_CFG, M98095_SEG, 0);\n\tmutex_unlock(&max98095->lock);\n\n\t \n\tsnd_soc_component_update_bits(component, M98095_088_CFG_LEVEL, regmask, regsave);\n\treturn 0;\n}\n\nstatic int max98095_get_eq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tint channel = max98095_get_eq_channel(kcontrol->id.name);\n\tstruct max98095_cdata *cdata;\n\n\tcdata = &max98095->dai[channel];\n\tucontrol->value.enumerated.item[0] = cdata->eq_sel;\n\n\treturn 0;\n}\n\nstatic void max98095_handle_eq_pdata(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_pdata *pdata = max98095->pdata;\n\tstruct max98095_eq_cfg *cfg;\n\tunsigned int cfgcnt;\n\tint i, j;\n\tconst char **t;\n\tint ret;\n\n\tstruct snd_kcontrol_new controls[] = {\n\t\tSOC_ENUM_EXT(\"EQ1 Mode\",\n\t\t\tmax98095->eq_enum,\n\t\t\tmax98095_get_eq_enum,\n\t\t\tmax98095_put_eq_enum),\n\t\tSOC_ENUM_EXT(\"EQ2 Mode\",\n\t\t\tmax98095->eq_enum,\n\t\t\tmax98095_get_eq_enum,\n\t\t\tmax98095_put_eq_enum),\n\t};\n\n\tcfg = pdata->eq_cfg;\n\tcfgcnt = pdata->eq_cfgcnt;\n\n\t \n\tmax98095->eq_textcnt = 0;\n\tmax98095->eq_texts = NULL;\n\tfor (i = 0; i < cfgcnt; i++) {\n\t\tfor (j = 0; j < max98095->eq_textcnt; j++) {\n\t\t\tif (strcmp(cfg[i].name, max98095->eq_texts[j]) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j != max98095->eq_textcnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tt = krealloc(max98095->eq_texts,\n\t\t\t     sizeof(char *) * (max98095->eq_textcnt + 1),\n\t\t\t     GFP_KERNEL);\n\t\tif (t == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tt[max98095->eq_textcnt] = cfg[i].name;\n\t\tmax98095->eq_textcnt++;\n\t\tmax98095->eq_texts = t;\n\t}\n\n\t \n\tmax98095->eq_enum.texts = max98095->eq_texts;\n\tmax98095->eq_enum.items = max98095->eq_textcnt;\n\n\tret = snd_soc_add_component_controls(component, controls, ARRAY_SIZE(controls));\n\tif (ret != 0)\n\t\tdev_err(component->dev, \"Failed to add EQ control: %d\\n\", ret);\n}\n\nstatic const char *bq_mode_name[] = {\"Biquad1 Mode\", \"Biquad2 Mode\"};\n\nstatic int max98095_get_bq_channel(struct snd_soc_component *component,\n\t\t\t\t   const char *name)\n{\n\tint ret;\n\n\tret = match_string(bq_mode_name, ARRAY_SIZE(bq_mode_name), name);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"Bad biquad channel name '%s'\\n\", name);\n\treturn ret;\n}\n\nstatic int max98095_put_bq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_pdata *pdata = max98095->pdata;\n\tint channel = max98095_get_bq_channel(component, kcontrol->id.name);\n\tstruct max98095_cdata *cdata;\n\tunsigned int sel = ucontrol->value.enumerated.item[0];\n\tstruct max98095_biquad_cfg *coef_set;\n\tint fs, best, best_val, i;\n\tint regmask, regsave;\n\n\tif (channel < 0)\n\t\treturn channel;\n\n\tif (!pdata || !max98095->bq_textcnt)\n\t\treturn 0;\n\n\tif (sel >= pdata->bq_cfgcnt)\n\t\treturn -EINVAL;\n\n\tcdata = &max98095->dai[channel];\n\tcdata->bq_sel = sel;\n\tfs = cdata->rate;\n\n\t \n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < pdata->bq_cfgcnt; i++) {\n\t\tif (strcmp(pdata->bq_cfg[i].name, max98095->bq_texts[sel]) == 0 &&\n\t\t\tabs(pdata->bq_cfg[i].rate - fs) < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = abs(pdata->bq_cfg[i].rate - fs);\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"Selected %s/%dHz for %dHz sample rate\\n\",\n\t\tpdata->bq_cfg[best].name,\n\t\tpdata->bq_cfg[best].rate, fs);\n\n\tcoef_set = &pdata->bq_cfg[best];\n\n\tregmask = (channel == 0) ? M98095_BQ1EN : M98095_BQ2EN;\n\n\t \n\tregsave = snd_soc_component_read(component, M98095_088_CFG_LEVEL);\n\tsnd_soc_component_update_bits(component, M98095_088_CFG_LEVEL, regmask, 0);\n\n\tmutex_lock(&max98095->lock);\n\tsnd_soc_component_update_bits(component, M98095_00F_HOST_CFG, M98095_SEG, M98095_SEG);\n\tm98095_biquad_band(component, channel, 0, coef_set->band1);\n\tm98095_biquad_band(component, channel, 1, coef_set->band2);\n\tsnd_soc_component_update_bits(component, M98095_00F_HOST_CFG, M98095_SEG, 0);\n\tmutex_unlock(&max98095->lock);\n\n\t \n\tsnd_soc_component_update_bits(component, M98095_088_CFG_LEVEL, regmask, regsave);\n\treturn 0;\n}\n\nstatic int max98095_get_bq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tint channel = max98095_get_bq_channel(component, kcontrol->id.name);\n\tstruct max98095_cdata *cdata;\n\n\tif (channel < 0)\n\t\treturn channel;\n\n\tcdata = &max98095->dai[channel];\n\tucontrol->value.enumerated.item[0] = cdata->bq_sel;\n\n\treturn 0;\n}\n\nstatic void max98095_handle_bq_pdata(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_pdata *pdata = max98095->pdata;\n\tstruct max98095_biquad_cfg *cfg;\n\tunsigned int cfgcnt;\n\tint i, j;\n\tconst char **t;\n\tint ret;\n\n\tstruct snd_kcontrol_new controls[] = {\n\t\tSOC_ENUM_EXT((char *)bq_mode_name[0],\n\t\t\tmax98095->bq_enum,\n\t\t\tmax98095_get_bq_enum,\n\t\t\tmax98095_put_bq_enum),\n\t\tSOC_ENUM_EXT((char *)bq_mode_name[1],\n\t\t\tmax98095->bq_enum,\n\t\t\tmax98095_get_bq_enum,\n\t\t\tmax98095_put_bq_enum),\n\t};\n\tBUILD_BUG_ON(ARRAY_SIZE(controls) != ARRAY_SIZE(bq_mode_name));\n\n\tcfg = pdata->bq_cfg;\n\tcfgcnt = pdata->bq_cfgcnt;\n\n\t \n\tmax98095->bq_textcnt = 0;\n\tmax98095->bq_texts = NULL;\n\tfor (i = 0; i < cfgcnt; i++) {\n\t\tfor (j = 0; j < max98095->bq_textcnt; j++) {\n\t\t\tif (strcmp(cfg[i].name, max98095->bq_texts[j]) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j != max98095->bq_textcnt)\n\t\t\tcontinue;\n\n\t\t \n\t\tt = krealloc(max98095->bq_texts,\n\t\t\t     sizeof(char *) * (max98095->bq_textcnt + 1),\n\t\t\t     GFP_KERNEL);\n\t\tif (t == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tt[max98095->bq_textcnt] = cfg[i].name;\n\t\tmax98095->bq_textcnt++;\n\t\tmax98095->bq_texts = t;\n\t}\n\n\t \n\tmax98095->bq_enum.texts = max98095->bq_texts;\n\tmax98095->bq_enum.items = max98095->bq_textcnt;\n\n\tret = snd_soc_add_component_controls(component, controls, ARRAY_SIZE(controls));\n\tif (ret != 0)\n\t\tdev_err(component->dev, \"Failed to add Biquad control: %d\\n\", ret);\n}\n\nstatic void max98095_handle_pdata(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_pdata *pdata = max98095->pdata;\n\tu8 regval = 0;\n\n\tif (!pdata) {\n\t\tdev_dbg(component->dev, \"No platform data\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (pdata->digmic_left_mode)\n\t\tregval |= M98095_DIGMIC_L;\n\n\tif (pdata->digmic_right_mode)\n\t\tregval |= M98095_DIGMIC_R;\n\n\tsnd_soc_component_write(component, M98095_087_CFG_MIC, regval);\n\n\t \n\tif (pdata->eq_cfgcnt)\n\t\tmax98095_handle_eq_pdata(component);\n\n\t \n\tif (pdata->bq_cfgcnt)\n\t\tmax98095_handle_bq_pdata(component);\n}\n\nstatic irqreturn_t max98095_report_jack(int irq, void *data)\n{\n\tstruct snd_soc_component *component = data;\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tunsigned int value;\n\tint hp_report = 0;\n\tint mic_report = 0;\n\n\t \n\tvalue = snd_soc_component_read(component, M98095_007_JACK_AUTO_STS);\n\n\t \n\tif ((value & M98095_DDONE) == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tif ((value & M98095_HP_IN || value & M98095_LO_IN) &&\n\t\tmax98095->headphone_jack)\n\t\thp_report |= SND_JACK_HEADPHONE;\n\n\t \n\tif ((value & M98095_MIC_IN) && max98095->mic_jack)\n\t\tmic_report |= SND_JACK_MICROPHONE;\n\n\tif (max98095->headphone_jack == max98095->mic_jack) {\n\t\tsnd_soc_jack_report(max98095->headphone_jack,\n\t\t\t\t\thp_report | mic_report,\n\t\t\t\t\tSND_JACK_HEADSET);\n\t} else {\n\t\tif (max98095->headphone_jack)\n\t\t\tsnd_soc_jack_report(max98095->headphone_jack,\n\t\t\t\t\thp_report, SND_JACK_HEADPHONE);\n\t\tif (max98095->mic_jack)\n\t\t\tsnd_soc_jack_report(max98095->mic_jack,\n\t\t\t\t\tmic_report, SND_JACK_MICROPHONE);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int max98095_jack_detect_enable(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\tint detect_enable = M98095_JDEN;\n\tunsigned int slew = M98095_DEFAULT_SLEW_DELAY;\n\n\tif (max98095->pdata->jack_detect_pin5en)\n\t\tdetect_enable |= M98095_PIN5EN;\n\n\tif (max98095->pdata->jack_detect_delay)\n\t\tslew = max98095->pdata->jack_detect_delay;\n\n\tret = snd_soc_component_write(component, M98095_08E_JACK_DC_SLEW, slew);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to cfg auto detect %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = snd_soc_component_write(component, M98095_089_JACK_DET_AUTO, detect_enable);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to cfg auto detect %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int max98095_jack_detect_disable(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\n\t \n\tret = snd_soc_component_write(component, M98095_089_JACK_DET_AUTO, 0x0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to cfg auto detect %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint max98095_jack_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *hp_jack, struct snd_soc_jack *mic_jack)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct i2c_client *client = to_i2c_client(component->dev);\n\tint ret = 0;\n\n\tmax98095->headphone_jack = hp_jack;\n\tmax98095->mic_jack = mic_jack;\n\n\t \n\tif (!hp_jack && !mic_jack)\n\t\treturn -EINVAL;\n\n\tmax98095_jack_detect_enable(component);\n\n\t \n\tret = snd_soc_component_update_bits(component, M98095_013_JACK_INT_EN,\n\t\tM98095_IDDONE, M98095_IDDONE);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to cfg jack irqs %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax98095_report_jack(client->irq, component);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(max98095_jack_detect);\n\n#ifdef CONFIG_PM\nstatic int max98095_suspend(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\n\tif (max98095->headphone_jack || max98095->mic_jack)\n\t\tmax98095_jack_detect_disable(component);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\n\treturn 0;\n}\n\nstatic int max98095_resume(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct i2c_client *client = to_i2c_client(component->dev);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\tif (max98095->headphone_jack || max98095->mic_jack) {\n\t\tmax98095_jack_detect_enable(component);\n\t\tmax98095_report_jack(client->irq, component);\n\t}\n\n\treturn 0;\n}\n#else\n#define max98095_suspend NULL\n#define max98095_resume NULL\n#endif\n\nstatic int max98095_reset(struct snd_soc_component *component)\n{\n\tint i, ret;\n\n\t \n\tret = snd_soc_component_write(component, M98095_00F_HOST_CFG, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to reset DSP: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_write(component, M98095_097_PWR_SYS, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to reset component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = M98095_010_HOST_INT_CFG; i < M98095_REG_MAX_CACHED; i++) {\n\t\tret = snd_soc_component_write(component, i, snd_soc_component_read(component, i));\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to reset: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int max98095_probe(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct max98095_cdata *cdata;\n\tstruct i2c_client *client;\n\tint ret = 0;\n\n\tmax98095->mclk = devm_clk_get(component->dev, \"mclk\");\n\tif (PTR_ERR(max98095->mclk) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\t \n\tmax98095_reset(component);\n\n\tclient = to_i2c_client(component->dev);\n\n\t \n\n\tmax98095->sysclk = (unsigned)-1;\n\tmax98095->eq_textcnt = 0;\n\tmax98095->bq_textcnt = 0;\n\n\tcdata = &max98095->dai[0];\n\tcdata->rate = (unsigned)-1;\n\tcdata->fmt  = (unsigned)-1;\n\tcdata->eq_sel = 0;\n\tcdata->bq_sel = 0;\n\n\tcdata = &max98095->dai[1];\n\tcdata->rate = (unsigned)-1;\n\tcdata->fmt  = (unsigned)-1;\n\tcdata->eq_sel = 0;\n\tcdata->bq_sel = 0;\n\n\tcdata = &max98095->dai[2];\n\tcdata->rate = (unsigned)-1;\n\tcdata->fmt  = (unsigned)-1;\n\tcdata->eq_sel = 0;\n\tcdata->bq_sel = 0;\n\n\tmax98095->lin_state = 0;\n\tmax98095->mic1pre = 0;\n\tmax98095->mic2pre = 0;\n\n\tif (client->irq) {\n\t\t \n\t\tret = request_threaded_irq(client->irq, NULL,\n\t\t\tmax98095_report_jack,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING |\n\t\t\tIRQF_ONESHOT, \"max98095\", component);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\t\tgoto err_access;\n\t\t}\n\t}\n\n\tret = snd_soc_component_read(component, M98095_0FF_REV_ID);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failure reading hardware revision: %d\\n\",\n\t\t\tret);\n\t\tgoto err_irq;\n\t}\n\tdev_info(component->dev, \"Hardware revision: %c\\n\", ret - 0x40 + 'A');\n\n\tsnd_soc_component_write(component, M98095_097_PWR_SYS, M98095_PWRSV);\n\n\tsnd_soc_component_write(component, M98095_048_MIX_DAC_LR,\n\t\tM98095_DAI1L_TO_DACL|M98095_DAI1R_TO_DACR);\n\n\tsnd_soc_component_write(component, M98095_049_MIX_DAC_M,\n\t\tM98095_DAI2M_TO_DACM|M98095_DAI3M_TO_DACM);\n\n\tsnd_soc_component_write(component, M98095_092_PWR_EN_OUT, M98095_SPK_SPREADSPECTRUM);\n\tsnd_soc_component_write(component, M98095_045_CFG_DSP, M98095_DSPNORMAL);\n\tsnd_soc_component_write(component, M98095_04E_CFG_HP, M98095_HPNORMAL);\n\n\tsnd_soc_component_write(component, M98095_02C_DAI1_IOCFG,\n\t\tM98095_S1NORMAL|M98095_SDATA);\n\n\tsnd_soc_component_write(component, M98095_036_DAI2_IOCFG,\n\t\tM98095_S2NORMAL|M98095_SDATA);\n\n\tsnd_soc_component_write(component, M98095_040_DAI3_IOCFG,\n\t\tM98095_S3NORMAL|M98095_SDATA);\n\n\tmax98095_handle_pdata(component);\n\n\t \n\tsnd_soc_component_update_bits(component, M98095_097_PWR_SYS, M98095_SHDNRUN,\n\t\tM98095_SHDNRUN);\n\n\treturn 0;\n\nerr_irq:\n\tif (client->irq)\n\t\tfree_irq(client->irq, component);\nerr_access:\n\treturn ret;\n}\n\nstatic void max98095_remove(struct snd_soc_component *component)\n{\n\tstruct max98095_priv *max98095 = snd_soc_component_get_drvdata(component);\n\tstruct i2c_client *client = to_i2c_client(component->dev);\n\n\tif (max98095->headphone_jack || max98095->mic_jack)\n\t\tmax98095_jack_detect_disable(component);\n\n\tif (client->irq)\n\t\tfree_irq(client->irq, component);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98095 = {\n\t.probe\t\t\t= max98095_probe,\n\t.remove\t\t\t= max98095_remove,\n\t.suspend\t\t= max98095_suspend,\n\t.resume\t\t\t= max98095_resume,\n\t.set_bias_level\t\t= max98095_set_bias_level,\n\t.controls\t\t= max98095_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98095_snd_controls),\n\t.dapm_widgets\t\t= max98095_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98095_dapm_widgets),\n\t.dapm_routes\t\t= max98095_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98095_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct i2c_device_id max98095_i2c_id[] = {\n\t{ \"max98095\", MAX98095 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max98095_i2c_id);\n\nstatic int max98095_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct max98095_priv *max98095;\n\tint ret;\n\tconst struct i2c_device_id *id;\n\n\tmax98095 = devm_kzalloc(&i2c->dev, sizeof(struct max98095_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (max98095 == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&max98095->lock);\n\n\tmax98095->regmap = devm_regmap_init_i2c(i2c, &max98095_regmap);\n\tif (IS_ERR(max98095->regmap)) {\n\t\tret = PTR_ERR(max98095->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tid = i2c_match_id(max98095_i2c_id, i2c);\n\tmax98095->devtype = id->driver_data;\n\ti2c_set_clientdata(i2c, max98095);\n\tmax98095->pdata = i2c->dev.platform_data;\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_max98095,\n\t\t\t\t     max98095_dai, ARRAY_SIZE(max98095_dai));\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98095_of_match[] = {\n\t{ .compatible = \"maxim,max98095\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98095_of_match);\n#endif\n\nstatic struct i2c_driver max98095_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98095\",\n\t\t.of_match_table = of_match_ptr(max98095_of_match),\n\t},\n\t.probe = max98095_i2c_probe,\n\t.id_table = max98095_i2c_id,\n};\n\nmodule_i2c_driver(max98095_i2c_driver);\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98095 driver\");\nMODULE_AUTHOR(\"Peter Hsiang\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}