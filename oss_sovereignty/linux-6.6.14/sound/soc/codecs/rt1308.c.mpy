{
  "module_name": "rt1308.c",
  "hash_id": "123bb77df75c71b73914a0a01ba9ed4f86134dbd8caac6da4ca25c1b139515e8",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1308.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rl6231.h\"\n#include \"rt1308.h\"\n\nstatic const struct reg_sequence init_list[] = {\n\n\t{ RT1308_I2C_I2S_SDW_SET,\t0x01014005 },\n\t{ RT1308_CLASS_D_SET_2,\t\t0x227f5501 },\n\t{ RT1308_PADS_1,\t\t0x50150505 },\n\t{ RT1308_VREF,\t\t\t0x18100000 },\n\t{ RT1308_IV_SENSE,\t\t0x87010000 },\n\t{ RT1308_DUMMY_REG,\t\t0x00000200 },\n\t{ RT1308_SIL_DET,\t\t0xe1c30000 },\n\t{ RT1308_DC_CAL_2,\t\t0x00ffff00 },\n\t{ RT1308_CLK_DET,\t\t0x01000000 },\n\t{ RT1308_POWER_STATUS,\t\t0x08800000 },\n\t{ RT1308_DAC_SET,\t\t0xafaf0700 },\n\n};\n#define RT1308_INIT_REG_LEN ARRAY_SIZE(init_list)\n\nstruct rt1308_priv {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\n\tint sysclk;\n\tint sysclk_src;\n\tint lrck;\n\tint bclk;\n\tint master;\n\n\tint pll_src;\n\tint pll_in;\n\tint pll_out;\n};\n\nstatic const struct reg_default rt1308_reg[] = {\n\n\t{ 0x01, 0x1f3f5f00 },\n\t{ 0x02, 0x07000000 },\n\t{ 0x03, 0x80003e00 },\n\t{ 0x04, 0x80800600 },\n\t{ 0x05, 0x0aaa1a0a },\n\t{ 0x06, 0x52000000 },\n\t{ 0x07, 0x00000000 },\n\t{ 0x08, 0x00600000 },\n\t{ 0x09, 0xe1030000 },\n\t{ 0x0a, 0x00000000 },\n\t{ 0x0b, 0x30000000 },\n\t{ 0x0c, 0x7fff7000 },\n\t{ 0x10, 0xffff0700 },\n\t{ 0x11, 0x0a000000 },\n\t{ 0x12, 0x60040000 },\n\t{ 0x13, 0x00000000 },\n\t{ 0x14, 0x0f300000 },\n\t{ 0x15, 0x00000022 },\n\t{ 0x16, 0x02000000 },\n\t{ 0x17, 0x01004045 },\n\t{ 0x18, 0x00000000 },\n\t{ 0x19, 0x00000000 },\n\t{ 0x1a, 0x80000000 },\n\t{ 0x1b, 0x10325476 },\n\t{ 0x1c, 0x1d1d0000 },\n\t{ 0x20, 0xd2101300 },\n\t{ 0x21, 0xf3ffff00 },\n\t{ 0x22, 0x00000000 },\n\t{ 0x23, 0x00000000 },\n\t{ 0x24, 0x00000000 },\n\t{ 0x25, 0x00000000 },\n\t{ 0x26, 0x00000000 },\n\t{ 0x27, 0x00000000 },\n\t{ 0x28, 0x00000000 },\n\t{ 0x29, 0x00000000 },\n\t{ 0x2a, 0x00000000 },\n\t{ 0x2b, 0x00000000 },\n\t{ 0x2c, 0x00000000 },\n\t{ 0x2d, 0x00000000 },\n\t{ 0x2e, 0x00000000 },\n\t{ 0x2f, 0x00000000 },\n\t{ 0x30, 0x01000000 },\n\t{ 0x31, 0x20025501 },\n\t{ 0x32, 0x00000000 },\n\t{ 0x33, 0x105a0000 },\n\t{ 0x34, 0x10100000 },\n\t{ 0x35, 0x2aaa52aa },\n\t{ 0x36, 0x00c00000 },\n\t{ 0x37, 0x20046100 },\n\t{ 0x50, 0x10022f00 },\n\t{ 0x51, 0x003c0000 },\n\t{ 0x54, 0x04000000 },\n\t{ 0x55, 0x01000000 },\n\t{ 0x56, 0x02000000 },\n\t{ 0x57, 0x02000000 },\n\t{ 0x58, 0x02000000 },\n\t{ 0x59, 0x02000000 },\n\t{ 0x5b, 0x02000000 },\n\t{ 0x5c, 0x00000000 },\n\t{ 0x5d, 0x00000000 },\n\t{ 0x5e, 0x00000000 },\n\t{ 0x5f, 0x00000000 },\n\t{ 0x60, 0x02000000 },\n\t{ 0x61, 0x00000000 },\n\t{ 0x62, 0x00000000 },\n\t{ 0x63, 0x00000000 },\n\t{ 0x64, 0x00000000 },\n\t{ 0x65, 0x02000000 },\n\t{ 0x66, 0x00000000 },\n\t{ 0x67, 0x00000000 },\n\t{ 0x68, 0x00000000 },\n\t{ 0x69, 0x00000000 },\n\t{ 0x6a, 0x02000000 },\n\t{ 0x6c, 0x00000000 },\n\t{ 0x6d, 0x00000000 },\n\t{ 0x6e, 0x00000000 },\n\t{ 0x70, 0x10EC1308 },\n\t{ 0x71, 0x00000000 },\n\t{ 0x72, 0x00000000 },\n\t{ 0x73, 0x00000000 },\n\t{ 0x74, 0x00000000 },\n\t{ 0x75, 0x00000000 },\n\t{ 0x76, 0x00000000 },\n\t{ 0x77, 0x00000000 },\n\t{ 0x78, 0x00000000 },\n\t{ 0x79, 0x00000000 },\n\t{ 0x7a, 0x00000000 },\n\t{ 0x7b, 0x00000000 },\n\t{ 0x7c, 0x00000000 },\n\t{ 0x7d, 0x00000000 },\n\t{ 0x7e, 0x00000000 },\n\t{ 0x7f, 0x00020f00 },\n\t{ 0x80, 0x00000000 },\n\t{ 0x81, 0x00000000 },\n\t{ 0x82, 0x00000000 },\n\t{ 0x83, 0x00000000 },\n\t{ 0x84, 0x00000000 },\n\t{ 0x85, 0x00000000 },\n\t{ 0x86, 0x00000000 },\n\t{ 0x87, 0x00000000 },\n\t{ 0x88, 0x00000000 },\n\t{ 0x89, 0x00000000 },\n\t{ 0x8a, 0x00000000 },\n\t{ 0x8b, 0x00000000 },\n\t{ 0x8c, 0x00000000 },\n\t{ 0x8d, 0x00000000 },\n\t{ 0x8e, 0x00000000 },\n\t{ 0x90, 0x50250905 },\n\t{ 0x91, 0x15050000 },\n\t{ 0xa0, 0x00000000 },\n\t{ 0xa1, 0x00000000 },\n\t{ 0xa2, 0x00000000 },\n\t{ 0xa3, 0x00000000 },\n\t{ 0xa4, 0x00000000 },\n\t{ 0xb0, 0x00000000 },\n\t{ 0xb1, 0x00000000 },\n\t{ 0xb2, 0x00000000 },\n\t{ 0xb3, 0x00000000 },\n\t{ 0xb4, 0x00000000 },\n\t{ 0xb5, 0x00000000 },\n\t{ 0xb6, 0x00000000 },\n\t{ 0xb7, 0x00000000 },\n\t{ 0xb8, 0x00000000 },\n\t{ 0xb9, 0x00000000 },\n\t{ 0xba, 0x00000000 },\n\t{ 0xbb, 0x00000000 },\n\t{ 0xc0, 0x01000000 },\n\t{ 0xc1, 0x00000000 },\n\t{ 0xf0, 0x00000000 },\n};\n\nstatic int rt1308_reg_init(struct snd_soc_component *component)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\n\treturn regmap_multi_reg_write(rt1308->regmap, init_list,\n\t\t\t\tRT1308_INIT_REG_LEN);\n}\n\nstatic bool rt1308_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1308_RESET:\n\tcase RT1308_RESET_N:\n\tcase RT1308_CLK_2:\n\tcase RT1308_SIL_DET:\n\tcase RT1308_CLK_DET:\n\tcase RT1308_DC_DET:\n\tcase RT1308_DAC_SET:\n\tcase RT1308_DAC_BUF:\n\tcase RT1308_SDW_REG_RDATA:\n\tcase RT1308_DC_CAL_1:\n\tcase RT1308_PVDD_OFFSET_CTL:\n\tcase RT1308_CAL_OFFSET_DAC_PBTL:\n\tcase RT1308_CAL_OFFSET_DAC_L:\n\tcase RT1308_CAL_OFFSET_DAC_R:\n\tcase RT1308_CAL_OFFSET_PWM_L:\n\tcase RT1308_CAL_OFFSET_PWM_R:\n\tcase RT1308_CAL_PWM_VOS_ADC_L:\n\tcase RT1308_CAL_PWM_VOS_ADC_R:\n\tcase RT1308_MBIAS:\n\tcase RT1308_POWER_STATUS:\n\tcase RT1308_POWER_INT:\n\tcase RT1308_SINE_TONE_GEN_2:\n\tcase RT1308_BQ_SET:\n\tcase RT1308_BQ_PARA_UPDATE:\n\tcase RT1308_VEN_DEV_ID:\n\tcase RT1308_VERSION_ID:\n\tcase RT1308_EFUSE_1:\n\tcase RT1308_EFUSE_READ_PVDD_L:\n\tcase RT1308_EFUSE_READ_PVDD_R:\n\tcase RT1308_EFUSE_READ_PVDD_PTBL:\n\tcase RT1308_EFUSE_READ_DEV:\n\tcase RT1308_EFUSE_READ_R0:\n\tcase RT1308_EFUSE_READ_ADC_L:\n\tcase RT1308_EFUSE_READ_ADC_R:\n\tcase RT1308_EFUSE_READ_ADC_PBTL:\n\tcase RT1308_EFUSE_RESERVE:\n\tcase RT1308_EFUSE_DATA_0_MSB:\n\tcase RT1308_EFUSE_DATA_0_LSB:\n\tcase RT1308_EFUSE_DATA_1_MSB:\n\tcase RT1308_EFUSE_DATA_1_LSB:\n\tcase RT1308_EFUSE_DATA_2_MSB:\n\tcase RT1308_EFUSE_DATA_2_LSB:\n\tcase RT1308_EFUSE_DATA_3_MSB:\n\tcase RT1308_EFUSE_DATA_3_LSB:\n\tcase RT1308_EFUSE_STATUS_1:\n\tcase RT1308_EFUSE_STATUS_2:\n\tcase RT1308_DUMMY_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1308_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1308_RESET:\n\tcase RT1308_RESET_N:\n\tcase RT1308_CLK_GATING ... RT1308_DC_DET_THRES:\n\tcase RT1308_DAC_SET ... RT1308_AD_FILTER_SET:\n\tcase RT1308_DC_CAL_1 ... RT1308_POWER_INT:\n\tcase RT1308_SINE_TONE_GEN_1:\n\tcase RT1308_SINE_TONE_GEN_2:\n\tcase RT1308_BQ_SET:\n\tcase RT1308_BQ_PARA_UPDATE:\n\tcase RT1308_BQ_PRE_VOL_L ... RT1308_BQ_POST_VOL_R:\n\tcase RT1308_BQ1_L_H0 ... RT1308_BQ2_R_A2:\n\tcase RT1308_VEN_DEV_ID:\n\tcase RT1308_VERSION_ID:\n\tcase RT1308_SPK_BOUND:\n\tcase RT1308_BQ1_EQ_L_1 ... RT1308_BQ2_EQ_R_3:\n\tcase RT1308_EFUSE_1 ... RT1308_EFUSE_RESERVE:\n\tcase RT1308_PADS_1:\n\tcase RT1308_PADS_2:\n\tcase RT1308_TEST_MODE:\n\tcase RT1308_TEST_1:\n\tcase RT1308_TEST_2:\n\tcase RT1308_TEST_3:\n\tcase RT1308_TEST_4:\n\tcase RT1308_EFUSE_DATA_0_MSB ... RT1308_EFUSE_STATUS_2:\n\tcase RT1308_TCON_1:\n\tcase RT1308_TCON_2:\n\tcase RT1308_DUMMY_REG:\n\tcase RT1308_MAX_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int rt1308_classd_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(30);\n\t\tsnd_soc_component_update_bits(component, RT1308_POWER_STATUS,\n\t\t\tRT1308_POW_PDB_REG_BIT | RT1308_POW_PDB_MN_BIT,\n\t\t\tRT1308_POW_PDB_REG_BIT | RT1308_POW_PDB_MN_BIT);\n\t\tmsleep(40);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, RT1308_POWER_STATUS,\n\t\t\tRT1308_POW_PDB_REG_BIT | RT1308_POW_PDB_MN_BIT, 0);\n\t\tusleep_range(150000, 200000);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const rt1308_rx_data_ch_select[] = {\n\t\"LR\",\n\t\"LL\",\n\t\"RL\",\n\t\"RR\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1308_rx_data_ch_enum, RT1308_DATA_PATH, 24,\n\trt1308_rx_data_ch_select);\n\nstatic const struct snd_kcontrol_new rt1308_snd_controls[] = {\n\n\t \n\tSOC_ENUM(\"RX Channel Select\", rt1308_rx_data_ch_enum),\n};\n\nstatic const struct snd_kcontrol_new rt1308_sto_dac_l =\n\tSOC_DAPM_SINGLE(\"Switch\", RT1308_DAC_SET,\n\t\tRT1308_DVOL_MUTE_L_EN_SFT, 1, 1);\n\nstatic const struct snd_kcontrol_new rt1308_sto_dac_r =\n\tSOC_DAPM_SINGLE(\"Switch\", RT1308_DAC_SET,\n\t\tRT1308_DVOL_MUTE_R_EN_SFT, 1, 1);\n\nstatic const struct snd_soc_dapm_widget rt1308_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RX\", \"AIF1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"MBIAS20U\", RT1308_POWER,\n\t\tRT1308_POW_MBIAS20U_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ALDO\", RT1308_POWER,\n\t\tRT1308_POW_ALDO_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DBG\", RT1308_POWER,\n\t\tRT1308_POW_DBG_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DACL\", RT1308_POWER,\n\t\tRT1308_POW_DACL_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CLK25M\", RT1308_POWER,\n\t\tRT1308_POW_CLK25M_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC_R\", RT1308_POWER,\n\t\tRT1308_POW_ADC_R_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC_L\", RT1308_POWER,\n\t\tRT1308_POW_ADC_L_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DLDO\", RT1308_POWER,\n\t\tRT1308_POW_DLDO_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VREF\", RT1308_POWER,\n\t\tRT1308_POW_VREF_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIXER_R\", RT1308_POWER,\n\t\tRT1308_POW_MIXER_R_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIXER_L\", RT1308_POWER,\n\t\tRT1308_POW_MIXER_L_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MBIAS4U\", RT1308_POWER,\n\t\tRT1308_POW_MBIAS4U_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2_LDO\", RT1308_POWER,\n\t\tRT1308_POW_PLL2_LDO_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2B\", RT1308_POWER,\n\t\tRT1308_POW_PLL2B_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2F\", RT1308_POWER,\n\t\tRT1308_POW_PLL2F_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2F2\", RT1308_POWER,\n\t\tRT1308_POW_PLL2F2_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2B2\", RT1308_POWER,\n\t\tRT1308_POW_PLL2B2_EN_BIT, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"DAC Power\", RT1308_POWER,\n\t\tRT1308_POW_DAC1_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SWITCH(\"DAC L\", SND_SOC_NOPM, 0, 0, &rt1308_sto_dac_l),\n\tSND_SOC_DAPM_SWITCH(\"DAC R\", SND_SOC_NOPM, 0, 0, &rt1308_sto_dac_r),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"CLASS D\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt1308_classd_event,\n\t\tSND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1308_dapm_routes[] = {\n\n\t{ \"DAC\", NULL, \"AIF1RX\" },\n\n\t{ \"DAC\", NULL, \"MBIAS20U\" },\n\t{ \"DAC\", NULL, \"ALDO\" },\n\t{ \"DAC\", NULL, \"DBG\" },\n\t{ \"DAC\", NULL, \"DACL\" },\n\t{ \"DAC\", NULL, \"CLK25M\" },\n\t{ \"DAC\", NULL, \"ADC_R\" },\n\t{ \"DAC\", NULL, \"ADC_L\" },\n\t{ \"DAC\", NULL, \"DLDO\" },\n\t{ \"DAC\", NULL, \"VREF\" },\n\t{ \"DAC\", NULL, \"MIXER_R\" },\n\t{ \"DAC\", NULL, \"MIXER_L\" },\n\t{ \"DAC\", NULL, \"MBIAS4U\" },\n\t{ \"DAC\", NULL, \"PLL2_LDO\" },\n\t{ \"DAC\", NULL, \"PLL2B\" },\n\t{ \"DAC\", NULL, \"PLL2F\" },\n\t{ \"DAC\", NULL, \"PLL2F2\" },\n\t{ \"DAC\", NULL, \"PLL2B2\" },\n\n\t{ \"DAC L\", \"Switch\", \"DAC\" },\n\t{ \"DAC R\", \"Switch\", \"DAC\" },\n\t{ \"DAC L\", NULL, \"DAC Power\" },\n\t{ \"DAC R\", NULL, \"DAC Power\" },\n\n\t{ \"CLASS D\", NULL, \"DAC L\" },\n\t{ \"CLASS D\", NULL, \"DAC R\" },\n\t{ \"SPOL\", NULL, \"CLASS D\" },\n\t{ \"SPOR\", NULL, \"CLASS D\" },\n};\n\nstatic int rt1308_get_clk_info(int sclk, int rate)\n{\n\tint i;\n\tstatic const int pd[] = {1, 2, 3, 4, 6, 8, 12, 16};\n\n\tif (sclk <= 0 || rate <= 0)\n\t\treturn -EINVAL;\n\n\trate = rate << 8;\n\tfor (i = 0; i < ARRAY_SIZE(pd); i++)\n\t\tif (sclk == rate * pd[i])\n\t\t\treturn i;\n\n\treturn -EINVAL;\n}\n\nstatic int rt1308_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0, val_clk, mask_clk;\n\tint pre_div, bclk_ms, frame_size;\n\n\trt1308->lrck = params_rate(params);\n\tpre_div = rt1308_get_clk_info(rt1308->sysclk, rt1308->lrck);\n\tif (pre_div < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unsupported clock setting %d\\n\", rt1308->lrck);\n\t\treturn -EINVAL;\n\t}\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0) {\n\t\tdev_err(component->dev, \"Unsupported frame size: %d\\n\",\n\t\t\tframe_size);\n\t\treturn -EINVAL;\n\t}\n\n\tbclk_ms = frame_size > 32;\n\trt1308->bclk = rt1308->lrck * (32 << bclk_ms);\n\n\tdev_dbg(component->dev, \"bclk_ms is %d and pre_div is %d for iis %d\\n\",\n\t\t\t\tbclk_ms, pre_div, dai->id);\n\n\tdev_dbg(component->dev, \"lrck is %dHz and pre_div is %d for iis %d\\n\",\n\t\t\t\trt1308->lrck, pre_div, dai->id);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= RT1308_I2S_DL_SEL_16B;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= RT1308_I2S_DL_SEL_20B;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= RT1308_I2S_DL_SEL_24B;\n\t\tbreak;\n\tcase 8:\n\t\tval_len |= RT1308_I2S_DL_SEL_8B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dai->id) {\n\tcase RT1308_AIF1:\n\t\tmask_clk = RT1308_DIV_FS_SYS_MASK;\n\t\tval_clk = pre_div << RT1308_DIV_FS_SYS_SFT;\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_I2S_SET_2, RT1308_I2S_DL_SEL_MASK,\n\t\t\tval_len);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid dai->id: %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1308_CLK_1,\n\t\tmask_clk, val_clk);\n\n\treturn 0;\n}\n\nstatic int rt1308_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0, reg1_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\trt1308->master = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg_val |= RT1308_I2S_DF_SEL_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg_val |= RT1308_I2S_DF_SEL_PCM_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\treg_val |= RT1308_I2S_DF_SEL_PCM_B;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg1_val |= RT1308_I2S_BCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dai->id) {\n\tcase RT1308_AIF1:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_I2S_SET_1, RT1308_I2S_DF_SEL_MASK,\n\t\t\treg_val);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_I2S_SET_2, RT1308_I2S_BCLK_MASK,\n\t\t\treg1_val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid dai->id: %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int rt1308_set_component_sysclk(struct snd_soc_component *component,\n\t\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tif (freq == rt1308->sysclk && clk_id == rt1308->sysclk_src)\n\t\treturn 0;\n\n\tswitch (clk_id) {\n\tcase RT1308_FS_SYS_S_MCLK:\n\t\treg_val |= RT1308_SEL_FS_SYS_SRC_MCLK;\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_DET, RT1308_MCLK_DET_EN_MASK,\n\t\t\tRT1308_MCLK_DET_EN);\n\t\tbreak;\n\tcase RT1308_FS_SYS_S_BCLK:\n\t\treg_val |= RT1308_SEL_FS_SYS_SRC_BCLK;\n\t\tbreak;\n\tcase RT1308_FS_SYS_S_PLL:\n\t\treg_val |= RT1308_SEL_FS_SYS_SRC_PLL;\n\t\tbreak;\n\tcase RT1308_FS_SYS_S_RCCLK:\n\t\treg_val |= RT1308_SEL_FS_SYS_SRC_RCCLK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, RT1308_CLK_1,\n\t\tRT1308_SEL_FS_SYS_MASK, reg_val);\n\trt1308->sysclk = freq;\n\trt1308->sysclk_src = clk_id;\n\n\tdev_dbg(component->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq, clk_id);\n\n\treturn 0;\n}\n\nstatic int rt1308_set_component_pll(struct snd_soc_component *component,\n\t\tint pll_id, int source, unsigned int freq_in,\n\t\tunsigned int freq_out)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\tstruct rl6231_pll_code pll_code;\n\tint ret;\n\n\tif (source == rt1308->pll_src && freq_in == rt1308->pll_in &&\n\t    freq_out == rt1308->pll_out)\n\t\treturn 0;\n\n\tif (!freq_in || !freq_out) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\n\t\trt1308->pll_in = 0;\n\t\trt1308->pll_out = 0;\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_1, RT1308_SEL_FS_SYS_MASK,\n\t\t\tRT1308_SEL_FS_SYS_SRC_MCLK);\n\t\treturn 0;\n\t}\n\n\tswitch (source) {\n\tcase RT1308_PLL_S_MCLK:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_2, RT1308_SEL_PLL_SRC_MASK,\n\t\t\tRT1308_SEL_PLL_SRC_MCLK);\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_DET, RT1308_MCLK_DET_EN_MASK,\n\t\t\tRT1308_MCLK_DET_EN);\n\t\tbreak;\n\tcase RT1308_PLL_S_BCLK:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_2, RT1308_SEL_PLL_SRC_MASK,\n\t\t\tRT1308_SEL_PLL_SRC_BCLK);\n\t\tbreak;\n\tcase RT1308_PLL_S_RCCLK:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1308_CLK_2, RT1308_SEL_PLL_SRC_MASK,\n\t\t\tRT1308_SEL_PLL_SRC_RCCLK);\n\t\tfreq_in = 25000000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown PLL Source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"bypass=%d m=%d n=%d k=%d\\n\",\n\t\tpll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\n\t\tpll_code.n_code, pll_code.k_code);\n\n\tsnd_soc_component_write(component, RT1308_PLL_1,\n\t\t(pll_code.k_code << RT1308_PLL1_K_SFT) |\n\t\t(pll_code.m_bp << RT1308_PLL1_M_BYPASS_SFT) |\n\t\t((pll_code.m_bp ? 0 : pll_code.m_code) << RT1308_PLL1_M_SFT) |\n\t\t(pll_code.n_code << RT1308_PLL1_N_SFT));\n\n\trt1308->pll_in = freq_in;\n\trt1308->pll_out = freq_out;\n\trt1308->pll_src = source;\n\n\treturn 0;\n}\n\nstatic int rt1308_probe(struct snd_soc_component *component)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\n\trt1308->component = component;\n\n\treturn rt1308_reg_init(component);\n}\n\nstatic void rt1308_remove(struct snd_soc_component *component)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\n\tregmap_write(rt1308->regmap, RT1308_RESET, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int rt1308_suspend(struct snd_soc_component *component)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1308->regmap, true);\n\tregcache_mark_dirty(rt1308->regmap);\n\n\treturn 0;\n}\n\nstatic int rt1308_resume(struct snd_soc_component *component)\n{\n\tstruct rt1308_priv *rt1308 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1308->regmap, false);\n\tregcache_sync(rt1308->regmap);\n\n\treturn 0;\n}\n#else\n#define rt1308_suspend NULL\n#define rt1308_resume NULL\n#endif\n\n#define RT1308_STEREO_RATES SNDRV_PCM_RATE_48000\n#define RT1308_FORMATS (SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops rt1308_aif_dai_ops = {\n\t.hw_params = rt1308_hw_params,\n\t.set_fmt = rt1308_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver rt1308_dai[] = {\n\t{\n\t\t.name = \"rt1308-aif\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1308_STEREO_RATES,\n\t\t\t.formats = RT1308_FORMATS,\n\t\t},\n\t\t.ops = &rt1308_aif_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt1308 = {\n\t.probe = rt1308_probe,\n\t.remove = rt1308_remove,\n\t.suspend = rt1308_suspend,\n\t.resume = rt1308_resume,\n\t.controls = rt1308_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1308_snd_controls),\n\t.dapm_widgets = rt1308_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1308_dapm_widgets),\n\t.dapm_routes = rt1308_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1308_dapm_routes),\n\t.set_sysclk = rt1308_set_component_sysclk,\n\t.set_pll = rt1308_set_component_pll,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt1308_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.max_register = RT1308_MAX_REG,\n\t.volatile_reg = rt1308_volatile_register,\n\t.readable_reg = rt1308_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = rt1308_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt1308_reg),\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rt1308_of_match[] = {\n\t{ .compatible = \"realtek,rt1308\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rt1308_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt1308_acpi_match[] = {\n\t{ \"10EC1308\", 0, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, rt1308_acpi_match);\n#endif\n\nstatic const struct i2c_device_id rt1308_i2c_id[] = {\n\t{ \"rt1308\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1308_i2c_id);\n\nstatic void rt1308_efuse(struct rt1308_priv *rt1308)\n{\n\tregmap_write(rt1308->regmap, RT1308_RESET, 0);\n\n\tregmap_write(rt1308->regmap, RT1308_POWER_STATUS, 0x01800000);\n\tmsleep(100);\n\tregmap_write(rt1308->regmap, RT1308_EFUSE_1, 0x44fe0f00);\n\tmsleep(20);\n\tregmap_write(rt1308->regmap, RT1308_PVDD_OFFSET_CTL, 0x10000000);\n}\n\nstatic int rt1308_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt1308_priv *rt1308;\n\tint ret;\n\tunsigned int val;\n\n\trt1308 = devm_kzalloc(&i2c->dev, sizeof(struct rt1308_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (rt1308 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt1308);\n\n\trt1308->regmap = devm_regmap_init_i2c(i2c, &rt1308_regmap);\n\tif (IS_ERR(rt1308->regmap)) {\n\t\tret = PTR_ERR(rt1308->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt1308->regmap, RT1308_VEN_DEV_ID, &val);\n\t \n\tif ((val & 0xFFFFFF00) != RT1308_DEVICE_ID_NUM) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %x is not rt1308\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\trt1308_efuse(rt1308);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_rt1308,\n\t\t\trt1308_dai, ARRAY_SIZE(rt1308_dai));\n}\n\nstatic void rt1308_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct rt1308_priv *rt1308 = i2c_get_clientdata(client);\n\n\tregmap_write(rt1308->regmap, RT1308_RESET, 0);\n}\n\nstatic struct i2c_driver rt1308_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1308\",\n\t\t.of_match_table = of_match_ptr(rt1308_of_match),\n\t\t.acpi_match_table = ACPI_PTR(rt1308_acpi_match),\n\t},\n\t.probe = rt1308_i2c_probe,\n\t.shutdown = rt1308_i2c_shutdown,\n\t.id_table = rt1308_i2c_id,\n};\nmodule_i2c_driver(rt1308_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1308 amplifier driver\");\nMODULE_AUTHOR(\"Derek Fang <derek.fang@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}