{
  "module_name": "pcm3060.c",
  "hash_id": "f9901a08f3a035f4d7cc7554e7daacf8dcb7ed39d813efbec62b3a0d80c7670f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm3060.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"pcm3060.h\"\n\n \n\nstatic int pcm3060_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t      unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct pcm3060_priv *priv = snd_soc_component_get_drvdata(comp);\n\tunsigned int reg;\n\tunsigned int val;\n\n\tif (dir != SND_SOC_CLOCK_IN) {\n\t\tdev_err(comp->dev, \"unsupported sysclock dir: %d\\n\", dir);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (clk_id) {\n\tcase PCM3060_CLK_DEF:\n\t\tval = 0;\n\t\tbreak;\n\n\tcase PCM3060_CLK1:\n\t\tval = (dai->id == PCM3060_DAI_ID_DAC ? PCM3060_REG_CSEL : 0);\n\t\tbreak;\n\n\tcase PCM3060_CLK2:\n\t\tval = (dai->id == PCM3060_DAI_ID_DAC ? 0 : PCM3060_REG_CSEL);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(comp->dev, \"unsupported sysclock id: %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dai->id == PCM3060_DAI_ID_DAC)\n\t\treg = PCM3060_REG67;\n\telse\n\t\treg = PCM3060_REG72;\n\n\tregmap_update_bits(priv->regmap, reg, PCM3060_REG_CSEL, val);\n\n\tpriv->dai[dai->id].sclk_freq = freq;\n\n\treturn 0;\n}\n\nstatic int pcm3060_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct pcm3060_priv *priv = snd_soc_component_get_drvdata(comp);\n\tunsigned int reg;\n\tunsigned int val;\n\n\tif ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF) {\n\t\tdev_err(comp->dev, \"unsupported DAI polarity: 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tpriv->dai[dai->id].is_provider = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tpriv->dai[dai->id].is_provider = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"unsupported DAI mode: 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = PCM3060_REG_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = PCM3060_REG_FMT_RJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = PCM3060_REG_FMT_LJ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"unsupported DAI format: 0x%x\\n\", fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (dai->id == PCM3060_DAI_ID_DAC)\n\t\treg = PCM3060_REG67;\n\telse\n\t\treg = PCM3060_REG72;\n\n\tregmap_update_bits(priv->regmap, reg, PCM3060_REG_MASK_FMT, val);\n\n\treturn 0;\n}\n\nstatic int pcm3060_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct pcm3060_priv *priv = snd_soc_component_get_drvdata(comp);\n\tunsigned int rate;\n\tunsigned int ratio;\n\tunsigned int reg;\n\tunsigned int val;\n\n\tif (!priv->dai[dai->id].is_provider) {\n\t\tval = PCM3060_REG_MS_S;\n\t\tgoto val_ready;\n\t}\n\n\trate = params_rate(params);\n\tif (!rate) {\n\t\tdev_err(comp->dev, \"rate is not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tratio = priv->dai[dai->id].sclk_freq / rate;\n\n\tswitch (ratio) {\n\tcase 768:\n\t\tval = PCM3060_REG_MS_M768;\n\t\tbreak;\n\tcase 512:\n\t\tval = PCM3060_REG_MS_M512;\n\t\tbreak;\n\tcase 384:\n\t\tval = PCM3060_REG_MS_M384;\n\t\tbreak;\n\tcase 256:\n\t\tval = PCM3060_REG_MS_M256;\n\t\tbreak;\n\tcase 192:\n\t\tval = PCM3060_REG_MS_M192;\n\t\tbreak;\n\tcase 128:\n\t\tval = PCM3060_REG_MS_M128;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(comp->dev, \"unsupported ratio: %d\\n\", ratio);\n\t\treturn -EINVAL;\n\t}\n\nval_ready:\n\tif (dai->id == PCM3060_DAI_ID_DAC)\n\t\treg = PCM3060_REG67;\n\telse\n\t\treg = PCM3060_REG72;\n\n\tregmap_update_bits(priv->regmap, reg, PCM3060_REG_MASK_MS, val);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops pcm3060_dai_ops = {\n\t.set_sysclk = pcm3060_set_sysclk,\n\t.set_fmt = pcm3060_set_fmt,\n\t.hw_params = pcm3060_hw_params,\n};\n\n#define PCM3060_DAI_RATES_ADC\t(SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | \\\n\t\t\t\t SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \\\n\t\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)\n\n#define PCM3060_DAI_RATES_DAC\t(PCM3060_DAI_RATES_ADC | \\\n\t\t\t\t SNDRV_PCM_RATE_176400 | SNDRV_PCM_RATE_192000)\n\nstatic struct snd_soc_dai_driver pcm3060_dai[] = {\n\t{\n\t\t.name = \"pcm3060-dac\",\n\t\t.id = PCM3060_DAI_ID_DAC,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = PCM3060_DAI_RATES_DAC,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S24_LE,\n\t\t},\n\t\t.ops = &pcm3060_dai_ops,\n\t},\n\t{\n\t\t.name = \"pcm3060-adc\",\n\t\t.id = PCM3060_DAI_ID_ADC,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = PCM3060_DAI_RATES_ADC,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S24_LE,\n\t\t},\n\t\t.ops = &pcm3060_dai_ops,\n\t},\n};\n\n \n\nstatic DECLARE_TLV_DB_SCALE(pcm3060_dapm_tlv, -10050, 50, 1);\n\nstatic const struct snd_kcontrol_new pcm3060_dapm_controls[] = {\n\tSOC_DOUBLE_R_RANGE_TLV(\"Master Playback Volume\",\n\t\t\t       PCM3060_REG65, PCM3060_REG66, 0,\n\t\t\t       PCM3060_REG_AT2_MIN, PCM3060_REG_AT2_MAX,\n\t\t\t       0, pcm3060_dapm_tlv),\n\tSOC_DOUBLE(\"Master Playback Switch\", PCM3060_REG68,\n\t\t   PCM3060_REG_SHIFT_MUT21, PCM3060_REG_SHIFT_MUT22, 1, 1),\n\n\tSOC_DOUBLE_R_RANGE_TLV(\"Master Capture Volume\",\n\t\t\t       PCM3060_REG70, PCM3060_REG71, 0,\n\t\t\t       PCM3060_REG_AT1_MIN, PCM3060_REG_AT1_MAX,\n\t\t\t       0, pcm3060_dapm_tlv),\n\tSOC_DOUBLE(\"Master Capture Switch\", PCM3060_REG73,\n\t\t   PCM3060_REG_SHIFT_MUT11, PCM3060_REG_SHIFT_MUT12, 1, 1),\n};\n\nstatic const struct snd_soc_dapm_widget pcm3060_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", PCM3060_REG64,\n\t\t\t PCM3060_REG_SHIFT_DAPSV, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUTR\"),\n\n\tSND_SOC_DAPM_INPUT(\"INL\"),\n\tSND_SOC_DAPM_INPUT(\"INR\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", PCM3060_REG64,\n\t\t\t PCM3060_REG_SHIFT_ADPSV, 1),\n};\n\nstatic const struct snd_soc_dapm_route pcm3060_dapm_map[] = {\n\t{ \"OUTL\", NULL, \"DAC\" },\n\t{ \"OUTR\", NULL, \"DAC\" },\n\n\t{ \"ADC\", NULL, \"INL\" },\n\t{ \"ADC\", NULL, \"INR\" },\n};\n\n \n\nstatic const struct snd_soc_component_driver pcm3060_soc_comp_driver = {\n\t.controls = pcm3060_dapm_controls,\n\t.num_controls = ARRAY_SIZE(pcm3060_dapm_controls),\n\t.dapm_widgets = pcm3060_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(pcm3060_dapm_widgets),\n\t.dapm_routes = pcm3060_dapm_map,\n\t.num_dapm_routes = ARRAY_SIZE(pcm3060_dapm_map),\n\t.endianness = 1,\n};\n\n \n\nstatic bool pcm3060_reg_writeable(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= PCM3060_REG64);\n}\n\nstatic bool pcm3060_reg_readable(struct device *dev, unsigned int reg)\n{\n\treturn (reg >= PCM3060_REG64);\n}\n\nstatic bool pcm3060_reg_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\treturn (reg == PCM3060_REG64);\n}\n\nstatic const struct reg_default pcm3060_reg_defaults[] = {\n\t{ PCM3060_REG64,  0xF0 },\n\t{ PCM3060_REG65,  0xFF },\n\t{ PCM3060_REG66,  0xFF },\n\t{ PCM3060_REG67,  0x00 },\n\t{ PCM3060_REG68,  0x00 },\n\t{ PCM3060_REG69,  0x00 },\n\t{ PCM3060_REG70,  0xD7 },\n\t{ PCM3060_REG71,  0xD7 },\n\t{ PCM3060_REG72,  0x00 },\n\t{ PCM3060_REG73,  0x00 },\n};\n\nconst struct regmap_config pcm3060_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = pcm3060_reg_writeable,\n\t.readable_reg = pcm3060_reg_readable,\n\t.volatile_reg = pcm3060_reg_volatile,\n\t.max_register = PCM3060_REG73,\n\t.reg_defaults = pcm3060_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(pcm3060_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\nEXPORT_SYMBOL(pcm3060_regmap);\n\n \n\nstatic void pcm3060_parse_dt(const struct device_node *np,\n\t\t\t     struct pcm3060_priv *priv)\n{\n\tpriv->out_se = of_property_read_bool(np, \"ti,out-single-ended\");\n}\n\nint pcm3060_probe(struct device *dev)\n{\n\tint rc;\n\tstruct pcm3060_priv *priv = dev_get_drvdata(dev);\n\n\t \n\trc = regmap_update_bits(priv->regmap, PCM3060_REG64,\n\t\t\t\tPCM3060_REG_MRST, 0);\n\tif (rc) {\n\t\tdev_err(dev, \"failed to reset component, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (dev->of_node)\n\t\tpcm3060_parse_dt(dev->of_node, priv);\n\n\tif (priv->out_se)\n\t\tregmap_update_bits(priv->regmap, PCM3060_REG64,\n\t\t\t\t   PCM3060_REG_SE, PCM3060_REG_SE);\n\n\trc = devm_snd_soc_register_component(dev, &pcm3060_soc_comp_driver,\n\t\t\t\t\t     pcm3060_dai,\n\t\t\t\t\t     ARRAY_SIZE(pcm3060_dai));\n\tif (rc) {\n\t\tdev_err(dev, \"failed to register component, rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(pcm3060_probe);\n\nMODULE_DESCRIPTION(\"PCM3060 codec driver\");\nMODULE_AUTHOR(\"Kirill Marinushkin <kmarinushkin@birdec.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}