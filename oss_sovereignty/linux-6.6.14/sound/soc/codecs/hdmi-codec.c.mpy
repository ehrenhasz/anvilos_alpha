{
  "module_name": "hdmi-codec.c",
  "hash_id": "edd454604467ed6b6b47d4fa9cdacce992dda84630e43a0cb691075b6aa06a6f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/hdmi-codec.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/string.h>\n#include <sound/core.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/pcm_drm_eld.h>\n#include <sound/hdmi-codec.h>\n#include <sound/pcm_iec958.h>\n\n#include <drm/drm_crtc.h>  \n\n#define HDMI_CODEC_CHMAP_IDX_UNKNOWN  -1\n\n \nenum hdmi_codec_cea_spk_placement {\n\tFL  = BIT(0),\t \n\tFC  = BIT(1),\t \n\tFR  = BIT(2),\t \n\tFLC = BIT(3),\t \n\tFRC = BIT(4),\t \n\tRL  = BIT(5),\t \n\tRC  = BIT(6),\t \n\tRR  = BIT(7),\t \n\tRLC = BIT(8),\t \n\tRRC = BIT(9),\t \n\tLFE = BIT(10),\t \n};\n\n \nstruct hdmi_codec_cea_spk_alloc {\n\tconst int ca_id;\n\tunsigned int n_ch;\n\tunsigned long mask;\n};\n\n \nstatic const struct snd_pcm_chmap_elem hdmi_codec_stereo_chmaps[] = {\n\t{ .channels = 2,\n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ }\n};\n\n \nstatic const struct snd_pcm_chmap_elem hdmi_codec_8ch_chmaps[] = {\n\t{ .channels = 2,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR } },\n\t{ .channels = 4,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA } },\n\t{ .channels = 4,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC } },\n\t{ .channels = 4,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 6,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RC, SNDRV_CHMAP_NA } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RLC, SNDRV_CHMAP_RRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RLC, SNDRV_CHMAP_RRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RLC, SNDRV_CHMAP_RRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_RL, SNDRV_CHMAP_RR,\n\t\t   SNDRV_CHMAP_RLC, SNDRV_CHMAP_RRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_NA, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ .channels = 8,  \n\t  .map = { SNDRV_CHMAP_FL, SNDRV_CHMAP_FR, SNDRV_CHMAP_LFE,\n\t\t   SNDRV_CHMAP_FC, SNDRV_CHMAP_NA, SNDRV_CHMAP_NA,\n\t\t   SNDRV_CHMAP_FLC, SNDRV_CHMAP_FRC } },\n\t{ }\n};\n\n \nstatic const struct hdmi_codec_cea_spk_alloc hdmi_codec_channel_alloc[] = {\n\t{ .ca_id = 0x00, .n_ch = 2,\n\t  .mask = FL | FR},\n\t \n\t{ .ca_id = 0x01, .n_ch = 4,\n\t  .mask = FL | FR | LFE},\n\t \n\t{ .ca_id = 0x02, .n_ch = 4,\n\t  .mask = FL | FR | FC },\n\t \n\t{ .ca_id = 0x0b, .n_ch = 6,\n\t  .mask = FL | FR | LFE | FC | RL | RR},\n\t \n\t{ .ca_id = 0x08, .n_ch = 6,\n\t  .mask = FL | FR | RL | RR },\n\t \n\t{ .ca_id = 0x09, .n_ch = 6,\n\t  .mask = FL | FR | LFE | RL | RR },\n\t \n\t{ .ca_id = 0x0a, .n_ch = 6,\n\t  .mask = FL | FR | FC | RL | RR },\n\t \n\t{ .ca_id = 0x0f, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC | RL | RR | RC },\n\t \n\t{ .ca_id = 0x13, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC | RL | RR | RLC | RRC },\n\t \n\t{ .ca_id = 0x03, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC },\n\t{ .ca_id = 0x04, .n_ch = 8,\n\t  .mask = FL | FR | RC},\n\t{ .ca_id = 0x05, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RC },\n\t{ .ca_id = 0x06, .n_ch = 8,\n\t  .mask = FL | FR | FC | RC },\n\t{ .ca_id = 0x07, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC | RC },\n\t{ .ca_id = 0x0c, .n_ch = 8,\n\t  .mask = FL | FR | RC | RL | RR },\n\t{ .ca_id = 0x0d, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RL | RR | RC },\n\t{ .ca_id = 0x0e, .n_ch = 8,\n\t  .mask = FL | FR | FC | RL | RR | RC },\n\t{ .ca_id = 0x10, .n_ch = 8,\n\t  .mask = FL | FR | RL | RR | RLC | RRC },\n\t{ .ca_id = 0x11, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RL | RR | RLC | RRC },\n\t{ .ca_id = 0x12, .n_ch = 8,\n\t  .mask = FL | FR | FC | RL | RR | RLC | RRC },\n\t{ .ca_id = 0x14, .n_ch = 8,\n\t  .mask = FL | FR | FLC | FRC },\n\t{ .ca_id = 0x15, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FLC | FRC },\n\t{ .ca_id = 0x16, .n_ch = 8,\n\t  .mask = FL | FR | FC | FLC | FRC },\n\t{ .ca_id = 0x17, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC | FLC | FRC },\n\t{ .ca_id = 0x18, .n_ch = 8,\n\t  .mask = FL | FR | RC | FLC | FRC },\n\t{ .ca_id = 0x19, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RC | FLC | FRC },\n\t{ .ca_id = 0x1a, .n_ch = 8,\n\t  .mask = FL | FR | RC | FC | FLC | FRC },\n\t{ .ca_id = 0x1b, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RC | FC | FLC | FRC },\n\t{ .ca_id = 0x1c, .n_ch = 8,\n\t  .mask = FL | FR | RL | RR | FLC | FRC },\n\t{ .ca_id = 0x1d, .n_ch = 8,\n\t  .mask = FL | FR | LFE | RL | RR | FLC | FRC },\n\t{ .ca_id = 0x1e, .n_ch = 8,\n\t  .mask = FL | FR | FC | RL | RR | FLC | FRC },\n\t{ .ca_id = 0x1f, .n_ch = 8,\n\t  .mask = FL | FR | LFE | FC | RL | RR | FLC | FRC },\n};\n\nstruct hdmi_codec_priv {\n\tstruct hdmi_codec_pdata hcd;\n\tuint8_t eld[MAX_ELD_BYTES];\n\tstruct snd_pcm_chmap *chmap_info;\n\tunsigned int chmap_idx;\n\tstruct mutex lock;\n\tbool busy;\n\tstruct snd_soc_jack *jack;\n\tunsigned int jack_status;\n\tu8 iec_status[AES_IEC958_STATUS_SIZE];\n};\n\nstatic const struct snd_soc_dapm_widget hdmi_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"TX\"),\n\tSND_SOC_DAPM_OUTPUT(\"RX\"),\n};\n\nenum {\n\tDAI_ID_I2S = 0,\n\tDAI_ID_SPDIF,\n};\n\nstatic int hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = sizeof_field(struct hdmi_codec_priv, eld);\n\n\treturn 0;\n}\n\nstatic int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\n\tmemcpy(ucontrol->value.bytes.data, hcp->eld, sizeof(hcp->eld));\n\n\treturn 0;\n}\n\nstatic unsigned long hdmi_codec_spk_mask_from_alloc(int spk_alloc)\n{\n\tint i;\n\tstatic const unsigned long hdmi_codec_eld_spk_alloc_bits[] = {\n\t\t[0] = FL | FR, [1] = LFE, [2] = FC, [3] = RL | RR,\n\t\t[4] = RC, [5] = FLC | FRC, [6] = RLC | RRC,\n\t};\n\tunsigned long spk_mask = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_codec_eld_spk_alloc_bits); i++) {\n\t\tif (spk_alloc & (1 << i))\n\t\t\tspk_mask |= hdmi_codec_eld_spk_alloc_bits[i];\n\t}\n\n\treturn spk_mask;\n}\n\nstatic void hdmi_codec_eld_chmap(struct hdmi_codec_priv *hcp)\n{\n\tu8 spk_alloc;\n\tunsigned long spk_mask;\n\n\tspk_alloc = drm_eld_get_spk_alloc(hcp->eld);\n\tspk_mask = hdmi_codec_spk_mask_from_alloc(spk_alloc);\n\n\t \n\tif ((spk_mask & ~(FL | FR)) && hcp->chmap_info->max_channels > 2)\n\t\thcp->chmap_info->chmap = hdmi_codec_8ch_chmaps;\n\telse\n\t\thcp->chmap_info->chmap = hdmi_codec_stereo_chmaps;\n}\n\nstatic int hdmi_codec_get_ch_alloc_table_idx(struct hdmi_codec_priv *hcp,\n\t\t\t\t\t     unsigned char channels)\n{\n\tint i;\n\tu8 spk_alloc;\n\tunsigned long spk_mask;\n\tconst struct hdmi_codec_cea_spk_alloc *cap = hdmi_codec_channel_alloc;\n\n\tspk_alloc = drm_eld_get_spk_alloc(hcp->eld);\n\tspk_mask = hdmi_codec_spk_mask_from_alloc(spk_alloc);\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_codec_channel_alloc); i++, cap++) {\n\t\t \n\t\tif (!spk_alloc && cap->ca_id == 0)\n\t\t\treturn i;\n\t\tif (cap->n_ch != channels)\n\t\t\tcontinue;\n\t\tif (!(cap->mask == (spk_mask & cap->mask)))\n\t\t\tcontinue;\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\nstatic int hdmi_codec_chmap_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tunsigned const char *map;\n\tunsigned int i;\n\tstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_codec_priv *hcp = info->private_data;\n\n\tmap = info->chmap[hcp->chmap_idx].map;\n\n\tfor (i = 0; i < info->max_channels; i++) {\n\t\tif (hcp->chmap_idx == HDMI_CODEC_CHMAP_IDX_UNKNOWN)\n\t\t\tucontrol->value.integer.value[i] = 0;\n\t\telse\n\t\t\tucontrol->value.integer.value[i] = map[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_iec958_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\n\tuinfo->count = 1;\n\treturn 0;\n}\n\nstatic int hdmi_codec_iec958_default_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\n\tmemcpy(ucontrol->value.iec958.status, hcp->iec_status,\n\t       sizeof(hcp->iec_status));\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_iec958_default_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\n\tmemcpy(hcp->iec_status, ucontrol->value.iec958.status,\n\t       sizeof(hcp->iec_status));\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_iec958_mask_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tmemset(ucontrol->value.iec958.status, 0xff,\n\t       sizeof_field(struct hdmi_codec_priv, iec_status));\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tbool has_capture = !hcp->hcd.no_i2s_capture;\n\tbool has_playback = !hcp->hcd.no_i2s_playback;\n\tint ret = 0;\n\n\tif (!((has_playback && tx) || (has_capture && !tx)))\n\t\treturn 0;\n\n\tmutex_lock(&hcp->lock);\n\tif (hcp->busy) {\n\t\tdev_err(dai->dev, \"Only one simultaneous stream supported!\\n\");\n\t\tmutex_unlock(&hcp->lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hcp->hcd.ops->audio_startup) {\n\t\tret = hcp->hcd.ops->audio_startup(dai->dev->parent, hcp->hcd.data);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (tx && hcp->hcd.ops->get_eld) {\n\t\tret = hcp->hcd.ops->get_eld(dai->dev->parent, hcp->hcd.data,\n\t\t\t\t\t    hcp->eld, sizeof(hcp->eld));\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = snd_pcm_hw_constraint_eld(substream->runtime, hcp->eld);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\thdmi_codec_eld_chmap(hcp);\n\t}\n\n\thcp->busy = true;\n\nerr:\n\tmutex_unlock(&hcp->lock);\n\treturn ret;\n}\n\nstatic void hdmi_codec_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tbool has_capture = !hcp->hcd.no_i2s_capture;\n\tbool has_playback = !hcp->hcd.no_i2s_playback;\n\n\tif (!((has_playback && tx) || (has_capture && !tx)))\n\t\treturn;\n\n\thcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\n\thcp->hcd.ops->audio_shutdown(dai->dev->parent, hcp->hcd.data);\n\n\tmutex_lock(&hcp->lock);\n\thcp->busy = false;\n\tmutex_unlock(&hcp->lock);\n}\n\nstatic int hdmi_codec_fill_codec_params(struct snd_soc_dai *dai,\n\t\t\t\t\tunsigned int sample_width,\n\t\t\t\t\tunsigned int sample_rate,\n\t\t\t\t\tunsigned int channels,\n\t\t\t\t\tstruct hdmi_codec_params *hp)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tint idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\n\tu8 ca_id = 0;\n\tbool pcm_audio = !(hcp->iec_status[0] & IEC958_AES0_NONAUDIO);\n\n\tif (pcm_audio) {\n\t\t \n\t\tidx = hdmi_codec_get_ch_alloc_table_idx(hcp, channels);\n\n\t\tif (idx < 0) {\n\t\t\tdev_err(dai->dev, \"Not able to map channels to speakers (%d)\\n\",\n\t\t\t\tidx);\n\t\t\thcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\n\t\t\treturn idx;\n\t\t}\n\n\t\tca_id = hdmi_codec_channel_alloc[idx].ca_id;\n\t}\n\n\tmemset(hp, 0, sizeof(*hp));\n\n\thdmi_audio_infoframe_init(&hp->cea);\n\n\tif (pcm_audio)\n\t\thp->cea.channels = channels;\n\telse\n\t\thp->cea.channels = 0;\n\n\thp->cea.coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;\n\thp->cea.sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;\n\thp->cea.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;\n\thp->cea.channel_allocation = ca_id;\n\n\thp->sample_width = sample_width;\n\thp->sample_rate = sample_rate;\n\thp->channels = channels;\n\n\tif (pcm_audio)\n\t\thcp->chmap_idx = ca_id;\n\telse\n\t\thcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tstruct hdmi_codec_daifmt *cf = snd_soc_dai_dma_data_get_playback(dai);\n\tstruct hdmi_codec_params hp = {\n\t\t.iec = {\n\t\t\t.status = { 0 },\n\t\t\t.subcode = { 0 },\n\t\t\t.pad = 0,\n\t\t\t.dig_subframe = { 0 },\n\t\t}\n\t};\n\tint ret;\n\n\tif (!hcp->hcd.ops->hw_params)\n\t\treturn 0;\n\n\tdev_dbg(dai->dev, \"%s() width %d rate %d channels %d\\n\", __func__,\n\t\tparams_width(params), params_rate(params),\n\t\tparams_channels(params));\n\n\tret = hdmi_codec_fill_codec_params(dai,\n\t\t\t\t\t   params_width(params),\n\t\t\t\t\t   params_rate(params),\n\t\t\t\t\t   params_channels(params),\n\t\t\t\t\t   &hp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(hp.iec.status, hcp->iec_status, sizeof(hp.iec.status));\n\tret = snd_pcm_fill_iec958_consumer_hw_params(params, hp.iec.status,\n\t\t\t\t\t\t     sizeof(hp.iec.status));\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Creating IEC958 channel status failed %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tcf->bit_fmt = params_format(params);\n\treturn hcp->hcd.ops->hw_params(dai->dev->parent, hcp->hcd.data,\n\t\t\t\t       cf, &hp);\n}\n\nstatic int hdmi_codec_prepare(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tstruct hdmi_codec_daifmt *cf = snd_soc_dai_dma_data_get_playback(dai);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tunsigned int channels = runtime->channels;\n\tunsigned int width = snd_pcm_format_width(runtime->format);\n\tunsigned int rate = runtime->rate;\n\tstruct hdmi_codec_params hp;\n\tint ret;\n\n\tif (!hcp->hcd.ops->prepare)\n\t\treturn 0;\n\n\tdev_dbg(dai->dev, \"%s() width %d rate %d channels %d\\n\", __func__,\n\t\twidth, rate, channels);\n\n\tret = hdmi_codec_fill_codec_params(dai, width, rate, channels, &hp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemcpy(hp.iec.status, hcp->iec_status, sizeof(hp.iec.status));\n\tret = snd_pcm_fill_iec958_consumer(runtime, hp.iec.status,\n\t\t\t\t\t   sizeof(hp.iec.status));\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Creating IEC958 channel status failed %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tcf->bit_fmt = runtime->format;\n\treturn hcp->hcd.ops->prepare(dai->dev->parent, hcp->hcd.data,\n\t\t\t\t     cf, &hp);\n}\n\nstatic int hdmi_codec_i2s_set_fmt(struct snd_soc_dai *dai,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct hdmi_codec_daifmt *cf = snd_soc_dai_dma_data_get_playback(dai);\n\n\t \n\tmemset(cf, 0, sizeof(*cf));\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tcf->bit_clk_provider = 1;\n\t\tcf->frame_clk_provider = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\t\tcf->frame_clk_provider = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\t\tcf->bit_clk_provider = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tcf->frame_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tcf->bit_clk_inv = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tcf->frame_clk_inv = 1;\n\t\tcf->bit_clk_inv = 1;\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcf->fmt = HDMI_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcf->fmt = HDMI_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tcf->fmt = HDMI_DSP_B;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcf->fmt = HDMI_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcf->fmt = HDMI_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_AC97:\n\t\tcf->fmt = HDMI_AC97;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Invalid DAI interface format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_codec_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\n\t \n\tif (hcp->hcd.ops->mute_stream &&\n\t    (direction == SNDRV_PCM_STREAM_PLAYBACK ||\n\t     !hcp->hcd.ops->no_capture_mute))\n\t\treturn hcp->hcd.ops->mute_stream(dai->dev->parent,\n\t\t\t\t\t\t hcp->hcd.data,\n\t\t\t\t\t\t mute, direction);\n\n\treturn -ENOTSUPP;\n}\n\n \nstatic u64 hdmi_codec_formats =\n\tSND_SOC_POSSIBLE_DAIFMT_NB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_NB_IF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_NF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_IB_IF\t|\n\tSND_SOC_POSSIBLE_DAIFMT_I2S\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B\t|\n\tSND_SOC_POSSIBLE_DAIFMT_RIGHT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_LEFT_J\t|\n\tSND_SOC_POSSIBLE_DAIFMT_AC97;\n\n#define HDMI_RATES\t(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\\\n\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\\\n\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\\\n\t\t\t SNDRV_PCM_RATE_192000)\n\n#define SPDIF_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\n \n#define I2S_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)\n\nstatic struct snd_kcontrol_new hdmi_codec_controls[] = {\n\t{\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_READ,\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, MASK),\n\t\t.info = hdmi_codec_iec958_info,\n\t\t.get = hdmi_codec_iec958_mask_get,\n\t},\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name = SNDRV_CTL_NAME_IEC958(\"\", PLAYBACK, DEFAULT),\n\t\t.info = hdmi_codec_iec958_info,\n\t\t.get = hdmi_codec_iec958_default_get,\n\t\t.put = hdmi_codec_iec958_default_put,\n\t},\n\t{\n\t\t.access\t= (SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t   SNDRV_CTL_ELEM_ACCESS_VOLATILE),\n\t\t.iface\t= SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name\t= \"ELD\",\n\t\t.info\t= hdmi_eld_ctl_info,\n\t\t.get\t= hdmi_eld_ctl_get,\n\t},\n};\n\nstatic int hdmi_codec_pcm_new(struct snd_soc_pcm_runtime *rtd,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dai_driver *drv = dai->driver;\n\tstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\n\tunsigned int i;\n\tint ret;\n\n\tret =  snd_pcm_add_chmap_ctls(rtd->pcm, SNDRV_PCM_STREAM_PLAYBACK,\n\t\t\t\t      NULL, drv->playback.channels_max, 0,\n\t\t\t\t      &hcp->chmap_info);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\thcp->chmap_info->private_data = hcp;\n\thcp->chmap_info->kctl->get = hdmi_codec_chmap_ctl_get;\n\n\t \n\thcp->chmap_info->chmap = hdmi_codec_stereo_chmaps;\n\thcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\n\n\tfor (i = 0; i < ARRAY_SIZE(hdmi_codec_controls); i++) {\n\t\tstruct snd_kcontrol *kctl;\n\n\t\t \n\t\tkctl = snd_ctl_new1(&hdmi_codec_controls[i], dai->component);\n\t\tif (!kctl)\n\t\t\treturn -ENOMEM;\n\n\t\tkctl->id.device = rtd->pcm->device;\n\t\tret = snd_ctl_add(rtd->card->snd_card, kctl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int hdmi_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct hdmi_codec_daifmt *daifmt;\n\tstruct snd_soc_dapm_route route[] = {\n\t\t{\n\t\t\t.sink = \"TX\",\n\t\t\t.source = dai->driver->playback.stream_name,\n\t\t},\n\t\t{\n\t\t\t.sink = dai->driver->capture.stream_name,\n\t\t\t.source = \"RX\",\n\t\t},\n\t};\n\tint ret, i;\n\n\tdapm = snd_soc_component_get_dapm(dai->component);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(route); i++) {\n\t\tif (!route[i].source || !route[i].sink)\n\t\t\tcontinue;\n\n\t\tret = snd_soc_dapm_add_routes(dapm, &route[i], 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdaifmt = devm_kzalloc(dai->dev, sizeof(*daifmt), GFP_KERNEL);\n\tif (!daifmt)\n\t\treturn -ENOMEM;\n\n\tsnd_soc_dai_dma_data_set_playback(dai, daifmt);\n\n\treturn 0;\n}\n\nstatic void hdmi_codec_jack_report(struct hdmi_codec_priv *hcp,\n\t\t\t\t   unsigned int jack_status)\n{\n\tif (jack_status != hcp->jack_status) {\n\t\tif (hcp->jack)\n\t\t\tsnd_soc_jack_report(hcp->jack, jack_status, SND_JACK_LINEOUT);\n\t\thcp->jack_status = jack_status;\n\t}\n}\n\nstatic void plugged_cb(struct device *dev, bool plugged)\n{\n\tstruct hdmi_codec_priv *hcp = dev_get_drvdata(dev);\n\n\tif (plugged) {\n\t\tif (hcp->hcd.ops->get_eld) {\n\t\t\thcp->hcd.ops->get_eld(dev->parent, hcp->hcd.data,\n\t\t\t\t\t    hcp->eld, sizeof(hcp->eld));\n\t\t}\n\t\thdmi_codec_jack_report(hcp, SND_JACK_LINEOUT);\n\t} else {\n\t\thdmi_codec_jack_report(hcp, 0);\n\t\tmemset(hcp->eld, 0, sizeof(hcp->eld));\n\t}\n}\n\nstatic int hdmi_codec_set_jack(struct snd_soc_component *component,\n\t\t\t       struct snd_soc_jack *jack,\n\t\t\t       void *data)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\n\tif (hcp->hcd.ops->hook_plugged_cb) {\n\t\thcp->jack = jack;\n\n\t\t \n\t\tsnd_soc_jack_report(jack, hcp->jack_status, SND_JACK_LINEOUT);\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOTSUPP;\n}\n\nstatic int hdmi_dai_spdif_probe(struct snd_soc_dai *dai)\n{\n\tstruct hdmi_codec_daifmt *cf;\n\tint ret;\n\n\tret = hdmi_dai_probe(dai);\n\tif (ret)\n\t\treturn ret;\n\n\tcf = snd_soc_dai_dma_data_get_playback(dai);\n\tcf->fmt = HDMI_SPDIF;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops hdmi_codec_i2s_dai_ops = {\n\t.probe\t\t\t\t= hdmi_dai_probe,\n\t.startup\t\t\t= hdmi_codec_startup,\n\t.shutdown\t\t\t= hdmi_codec_shutdown,\n\t.hw_params\t\t\t= hdmi_codec_hw_params,\n\t.prepare\t\t\t= hdmi_codec_prepare,\n\t.set_fmt\t\t\t= hdmi_codec_i2s_set_fmt,\n\t.mute_stream\t\t\t= hdmi_codec_mute,\n\t.pcm_new\t\t\t= hdmi_codec_pcm_new,\n\t.auto_selectable_formats\t= &hdmi_codec_formats,\n\t.num_auto_selectable_formats\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops hdmi_codec_spdif_dai_ops = {\n\t.probe\t\t= hdmi_dai_spdif_probe,\n\t.startup\t= hdmi_codec_startup,\n\t.shutdown\t= hdmi_codec_shutdown,\n\t.hw_params\t= hdmi_codec_hw_params,\n\t.mute_stream\t= hdmi_codec_mute,\n\t.pcm_new\t= hdmi_codec_pcm_new,\n};\n\nstatic const struct snd_soc_dai_driver hdmi_i2s_dai = {\n\t.name = \"i2s-hifi\",\n\t.id = DAI_ID_I2S,\n\t.playback = {\n\t\t.stream_name = \"I2S Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = HDMI_RATES,\n\t\t.formats = I2S_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 8,\n\t\t.rates = HDMI_RATES,\n\t\t.formats = I2S_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.ops = &hdmi_codec_i2s_dai_ops,\n};\n\nstatic const struct snd_soc_dai_driver hdmi_spdif_dai = {\n\t.name = \"spdif-hifi\",\n\t.id = DAI_ID_SPDIF,\n\t.playback = {\n\t\t.stream_name = \"SPDIF Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = HDMI_RATES,\n\t\t.formats = SPDIF_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = HDMI_RATES,\n\t\t.formats = SPDIF_FORMATS,\n\t},\n\t.ops = &hdmi_codec_spdif_dai_ops,\n};\n\nstatic int hdmi_of_xlate_dai_id(struct snd_soc_component *component,\n\t\t\t\t struct device_node *endpoint)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\tint ret = -ENOTSUPP;  \n\n\tif (hcp->hcd.ops->get_dai_id)\n\t\tret = hcp->hcd.ops->get_dai_id(component, endpoint);\n\n\treturn ret;\n}\n\nstatic int hdmi_probe(struct snd_soc_component *component)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (hcp->hcd.ops->hook_plugged_cb) {\n\t\tret = hcp->hcd.ops->hook_plugged_cb(component->dev->parent,\n\t\t\t\t\t\t    hcp->hcd.data,\n\t\t\t\t\t\t    plugged_cb,\n\t\t\t\t\t\t    component->dev);\n\t}\n\n\treturn ret;\n}\n\nstatic void hdmi_remove(struct snd_soc_component *component)\n{\n\tstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\n\n\tif (hcp->hcd.ops->hook_plugged_cb)\n\t\thcp->hcd.ops->hook_plugged_cb(component->dev->parent,\n\t\t\t\t\t      hcp->hcd.data, NULL, NULL);\n}\n\nstatic const struct snd_soc_component_driver hdmi_driver = {\n\t.probe\t\t\t= hdmi_probe,\n\t.remove\t\t\t= hdmi_remove,\n\t.dapm_widgets\t\t= hdmi_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(hdmi_widgets),\n\t.of_xlate_dai_id\t= hdmi_of_xlate_dai_id,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n\t.set_jack\t\t= hdmi_codec_set_jack,\n};\n\nstatic int hdmi_codec_probe(struct platform_device *pdev)\n{\n\tstruct hdmi_codec_pdata *hcd = pdev->dev.platform_data;\n\tstruct snd_soc_dai_driver *daidrv;\n\tstruct device *dev = &pdev->dev;\n\tstruct hdmi_codec_priv *hcp;\n\tint dai_count, i = 0;\n\tint ret;\n\n\tif (!hcd) {\n\t\tdev_err(dev, \"%s: No platform data\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdai_count = hcd->i2s + hcd->spdif;\n\tif (dai_count < 1 || !hcd->ops ||\n\t    (!hcd->ops->hw_params && !hcd->ops->prepare) ||\n\t    !hcd->ops->audio_shutdown) {\n\t\tdev_err(dev, \"%s: Invalid parameters\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\thcp = devm_kzalloc(dev, sizeof(*hcp), GFP_KERNEL);\n\tif (!hcp)\n\t\treturn -ENOMEM;\n\n\thcp->hcd = *hcd;\n\tmutex_init(&hcp->lock);\n\n\tret = snd_pcm_create_iec958_consumer_default(hcp->iec_status,\n\t\t\t\t\t\t     sizeof(hcp->iec_status));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdaidrv = devm_kcalloc(dev, dai_count, sizeof(*daidrv), GFP_KERNEL);\n\tif (!daidrv)\n\t\treturn -ENOMEM;\n\n\tif (hcd->i2s) {\n\t\tdaidrv[i] = hdmi_i2s_dai;\n\t\tdaidrv[i].playback.channels_max = hcd->max_i2s_channels;\n\t\tif (hcd->no_i2s_playback)\n\t\t\tmemset(&daidrv[i].playback, 0,\n\t\t\t       sizeof(daidrv[i].playback));\n\t\tif (hcd->no_i2s_capture)\n\t\t\tmemset(&daidrv[i].capture, 0,\n\t\t\t       sizeof(daidrv[i].capture));\n\t\ti++;\n\t}\n\n\tif (hcd->spdif) {\n\t\tdaidrv[i] = hdmi_spdif_dai;\n\t\tif (hcd->no_spdif_playback)\n\t\t\tmemset(&daidrv[i].playback, 0,\n\t\t\t       sizeof(daidrv[i].playback));\n\t\tif (hcd->no_spdif_capture)\n\t\t\tmemset(&daidrv[i].capture, 0,\n\t\t\t       sizeof(daidrv[i].capture));\n\t}\n\n\tdev_set_drvdata(dev, hcp);\n\n\tret = devm_snd_soc_register_component(dev, &hdmi_driver, daidrv,\n\t\t\t\t\t      dai_count);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: snd_soc_register_component() failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic struct platform_driver hdmi_codec_driver = {\n\t.driver = {\n\t\t.name = HDMI_CODEC_DRV_NAME,\n\t},\n\t.probe = hdmi_codec_probe,\n};\n\nmodule_platform_driver(hdmi_codec_driver);\n\nMODULE_AUTHOR(\"Jyri Sarha <jsarha@ti.com>\");\nMODULE_DESCRIPTION(\"HDMI Audio Codec Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" HDMI_CODEC_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}