{
  "module_name": "rt715-sdw.c",
  "hash_id": "a2858b2c00b03832a24b28adcd45dd29433501497d363d6c3e76ad75ff434a6a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt715-sdw.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"rt715.h\"\n#include \"rt715-sdw.h\"\n\nstatic bool rt715_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00e0 ... 0x00e5:\n\tcase 0x00ee ... 0x00ef:\n\tcase 0x00f0 ... 0x00f5:\n\tcase 0x00fe ... 0x00ff:\n\tcase 0x02e0:\n\tcase 0x02f0:\n\tcase 0x04e0:\n\tcase 0x04f0:\n\tcase 0x06e0:\n\tcase 0x06f0:\n\tcase 0x2000 ... 0x2016:\n\tcase 0x201a ... 0x2027:\n\tcase 0x2029 ... 0x202a:\n\tcase 0x202d ... 0x2034:\n\tcase 0x2200 ... 0x2204:\n\tcase 0x2206 ... 0x2212:\n\tcase 0x2220 ... 0x2223:\n\tcase 0x2230 ... 0x2239:\n\tcase 0x22f0 ... 0x22f3:\n\tcase 0x3122:\n\tcase 0x3123:\n\tcase 0x3124:\n\tcase 0x3125:\n\tcase 0x3607:\n\tcase 0x3608:\n\tcase 0x3609:\n\tcase 0x3610:\n\tcase 0x3611:\n\tcase 0x3627:\n\tcase 0x3712:\n\tcase 0x3713:\n\tcase 0x3718:\n\tcase 0x3719:\n\tcase 0x371a:\n\tcase 0x371b:\n\tcase 0x371d:\n\tcase 0x3729:\n\tcase 0x385e:\n\tcase 0x3859:\n\tcase 0x4c12:\n\tcase 0x4c13:\n\tcase 0x4c1d:\n\tcase 0x4c29:\n\tcase 0x4d12:\n\tcase 0x4d13:\n\tcase 0x4d1d:\n\tcase 0x4d29:\n\tcase 0x4e12:\n\tcase 0x4e13:\n\tcase 0x4e1d:\n\tcase 0x4e29:\n\tcase 0x4f12:\n\tcase 0x4f13:\n\tcase 0x4f1d:\n\tcase 0x4f29:\n\tcase 0x7207:\n\tcase 0x7208:\n\tcase 0x7209:\n\tcase 0x7227:\n\tcase 0x7307:\n\tcase 0x7308:\n\tcase 0x7309:\n\tcase 0x7312:\n\tcase 0x7313:\n\tcase 0x7318:\n\tcase 0x7319:\n\tcase 0x731a:\n\tcase 0x731b:\n\tcase 0x731d:\n\tcase 0x7327:\n\tcase 0x7329:\n\tcase 0x8287:\n\tcase 0x8288:\n\tcase 0x8289:\n\tcase 0x82a7:\n\tcase 0x8387:\n\tcase 0x8388:\n\tcase 0x8389:\n\tcase 0x8392:\n\tcase 0x8393:\n\tcase 0x8398:\n\tcase 0x8399:\n\tcase 0x839a:\n\tcase 0x839b:\n\tcase 0x839d:\n\tcase 0x83a7:\n\tcase 0x83a9:\n\tcase 0x752039:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt715_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x00e5:\n\tcase 0x00f0:\n\tcase 0x00f3:\n\tcase 0x00f5:\n\tcase 0x2009:\n\tcase 0x2016:\n\tcase 0x201b:\n\tcase 0x201c:\n\tcase 0x201d:\n\tcase 0x201f:\n\tcase 0x2023:\n\tcase 0x2230:\n\tcase 0x200b ... 0x200e:  \n\tcase 0x2012 ... 0x2015:  \n\tcase 0x202d ... 0x202f:  \n\tcase 0x2201 ... 0x2212:  \n\tcase 0x2220 ... 0x2223:  \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int rt715_sdw_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned int sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0;\n\tunsigned int reg2 = 0, reg3 = 0, reg4 = 0, mask, nid, val2;\n\tunsigned int is_hda_reg = 1, is_index_reg = 0;\n\tint ret;\n\n\tif (reg > 0xffff)\n\t\tis_index_reg = 1;\n\n\tmask = reg & 0xf000;\n\n\tif (is_index_reg) {  \n\t\tval2 = reg & 0xff;\n\t\treg = reg >> 8;\n\t\tnid = reg & 0xff;\n\t\tret = regmap_write(rt715->sdw_regmap, reg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg2 = reg + 0x1000;\n\t\treg2 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2, val2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg3 = RT715_PRIV_DATA_R_H | nid;\n\t\tret = regmap_write(rt715->sdw_regmap, reg3,\n\t\t\t((*val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg4 = reg3 + 0x1000;\n\t\treg4 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg4, (*val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (mask   == 0x3000) {\n\t\treg += 0x8000;\n\t\tret = regmap_write(rt715->sdw_regmap, reg, *val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (mask == 0x7000) {\n\t\treg += 0x2000;\n\t\treg |= 0x800;\n\t\tret = regmap_write(rt715->sdw_regmap, reg,\n\t\t\t((*val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg2 = reg + 0x1000;\n\t\treg2 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2, (*val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if ((reg & 0xff00) == 0x8300) {  \n\t\treg2 = reg - 0x1000;\n\t\treg2 &= ~0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2,\n\t\t\t((*val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_write(rt715->sdw_regmap, reg, (*val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (mask == 0x9000) {\n\t\tret = regmap_write(rt715->sdw_regmap, reg,\n\t\t\t((*val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg2 = reg + 0x1000;\n\t\treg2 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2, (*val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (mask == 0xb000) {\n\t\tret = regmap_write(rt715->sdw_regmap, reg, *val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regmap_read(rt715->sdw_regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tis_hda_reg = 0;\n\t}\n\n\tif (is_hda_reg || is_index_reg) {\n\t\tsdw_data_3 = 0;\n\t\tsdw_data_2 = 0;\n\t\tsdw_data_1 = 0;\n\t\tsdw_data_0 = 0;\n\t\tret = regmap_read(rt715->sdw_regmap, RT715_READ_HDA_3,\n\t\t\t&sdw_data_3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(rt715->sdw_regmap, RT715_READ_HDA_2,\n\t\t\t&sdw_data_2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(rt715->sdw_regmap, RT715_READ_HDA_1,\n\t\t\t&sdw_data_1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_read(rt715->sdw_regmap, RT715_READ_HDA_0,\n\t\t\t&sdw_data_0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = ((sdw_data_3 & 0xff) << 24) |\n\t\t\t((sdw_data_2 & 0xff) << 16) |\n\t\t\t((sdw_data_1 & 0xff) << 8) | (sdw_data_0 & 0xff);\n\t}\n\n\tif (is_hda_reg == 0)\n\t\tdev_dbg(dev, \"[%s] %04x => %08x\\n\", __func__, reg, *val);\n\telse if (is_index_reg)\n\t\tdev_dbg(dev, \"[%s] %04x %04x %04x %04x => %08x\\n\", __func__,\n\t\t\treg, reg2, reg3, reg4, *val);\n\telse\n\t\tdev_dbg(dev, \"[%s] %04x %04x => %08x\\n\",\n\t\t__func__, reg, reg2, *val);\n\n\treturn 0;\n}\n\nstatic int rt715_sdw_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned int reg2 = 0, reg3, reg4, nid, mask, val2;\n\tunsigned int is_index_reg = 0;\n\tint ret;\n\n\tif (reg > 0xffff)\n\t\tis_index_reg = 1;\n\n\tmask = reg & 0xf000;\n\n\tif (is_index_reg) {  \n\t\tval2 = reg & 0xff;\n\t\treg = reg >> 8;\n\t\tnid = reg & 0xff;\n\t\tret = regmap_write(rt715->sdw_regmap, reg, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg2 = reg + 0x1000;\n\t\treg2 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2, val2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg3 = RT715_PRIV_DATA_W_H | nid;\n\t\tret = regmap_write(rt715->sdw_regmap, reg3,\n\t\t\t((val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg4 = reg3 + 0x1000;\n\t\treg4 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg4, (val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tis_index_reg = 1;\n\t} else if (reg < 0x4fff) {\n\t\tret = regmap_write(rt715->sdw_regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (reg == RT715_FUNC_RESET) {\n\t\tret = regmap_write(rt715->sdw_regmap, reg, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (mask == 0x7000) {\n\t\tret = regmap_write(rt715->sdw_regmap, reg,\n\t\t\t((val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treg2 = reg + 0x1000;\n\t\treg2 |= 0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2, (val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if ((reg & 0xff00) == 0x8300) {   \n\t\treg2 = reg - 0x1000;\n\t\treg2 &= ~0x80;\n\t\tret = regmap_write(rt715->sdw_regmap, reg2,\n\t\t\t((val >> 8) & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = regmap_write(rt715->sdw_regmap, reg, (val & 0xff));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (reg2 == 0)\n\t\tdev_dbg(dev, \"[%s] %04x <= %04x\\n\", __func__, reg, val);\n\telse if (is_index_reg)\n\t\tdev_dbg(dev, \"[%s] %04x %04x %04x %04x <= %04x %04x\\n\",\n\t\t\t__func__, reg, reg2, reg3, reg4, val2, val);\n\telse\n\t\tdev_dbg(dev, \"[%s] %04x %04x <= %04x\\n\",\n\t\t__func__, reg, reg2, val);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config rt715_regmap = {\n\t.reg_bits = 24,\n\t.val_bits = 32,\n\t.readable_reg = rt715_readable_register,  \n\t.volatile_reg = rt715_volatile_register,  \n\t.max_register = 0x752039,  \n\t.reg_defaults = rt715_reg_defaults,  \n\t.num_reg_defaults = ARRAY_SIZE(rt715_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\t.reg_read = rt715_sdw_read,\n\t.reg_write = rt715_sdw_write,\n};\n\nstatic const struct regmap_config rt715_sdw_regmap = {\n\t.name = \"sdw\",\n\t.reg_bits = 32,  \n\t.val_bits = 8,  \n\t.max_register = 0xff01,  \n\t.cache_type = REGCACHE_NONE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nint hda_to_sdw(unsigned int nid, unsigned int verb, unsigned int payload,\n\t       unsigned int *sdw_addr_h, unsigned int *sdw_data_h,\n\t       unsigned int *sdw_addr_l, unsigned int *sdw_data_l)\n{\n\tunsigned int offset_h, offset_l, e_verb;\n\n\tif (((verb & 0xff) != 0) || verb == 0xf00) {  \n\t\tif (verb == 0x7ff)  \n\t\t\toffset_h = 0;\n\t\telse\n\t\t\toffset_h = 0x3000;\n\n\t\tif (verb & 0x800)  \n\t\t\te_verb = (verb - 0xf00) | 0x80;\n\t\telse  \n\t\t\te_verb = (verb - 0x700);\n\n\t\t*sdw_data_h = payload;  \n\t\t*sdw_addr_l = *sdw_data_l = 0;\n\t} else {  \n\t\tif ((verb & 0x800) == 0x800) {  \n\t\t\toffset_h = 0x9000;\n\t\t\toffset_l = 0xa000;\n\t\t} else {  \n\t\t\toffset_h = 0x7000;\n\t\t\toffset_l = 0x8000;\n\t\t}\n\t\te_verb = verb >> 8;\n\t\t*sdw_data_h = (payload >> 8);  \n\t\t*sdw_addr_l = (e_verb << 8) | nid | 0x80;  \n\t\t*sdw_addr_l += offset_l;\n\t\t*sdw_data_l = payload & 0xff;\n\t}\n\n\t*sdw_addr_h = (e_verb << 8) | nid;\n\t*sdw_addr_h += offset_h;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(hda_to_sdw);\n\nstatic int rt715_update_status(struct sdw_slave *slave,\n\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct rt715_priv *rt715 = dev_get_drvdata(&slave->dev);\n\n\t \n\tif (rt715->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt715_io_init(&slave->dev, slave);\n}\n\nstatic int rt715_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_IMPL_DEF | SDW_SCP_INT1_BUS_CLASH |\n\t\tSDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = false;\n\n\t \n\tprop->source_ports = 0x50; \n\tprop->sink_ports = 0x0;\t \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\tsizeof(*prop->src_dpn_prop),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tdpn = prop->src_dpn_prop;\n\ti = 0;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 20;\n\n\t \n\tprop->wake_capable = 1;\n\n\treturn 0;\n}\n\nstatic int rt715_bus_config(struct sdw_slave *slave,\n\t\t\t\tstruct sdw_bus_params *params)\n{\n\tstruct rt715_priv *rt715 = dev_get_drvdata(&slave->dev);\n\tint ret;\n\n\tmemcpy(&rt715->params, params, sizeof(*params));\n\n\tret = rt715_clock_config(&slave->dev);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev, \"Invalid clk config\");\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops rt715_slave_ops = {\n\t.read_prop = rt715_read_prop,\n\t.update_status = rt715_update_status,\n\t.bus_config = rt715_bus_config,\n};\n\nstatic int rt715_sdw_probe(struct sdw_slave *slave,\n\t\t\t   const struct sdw_device_id *id)\n{\n\tstruct regmap *sdw_regmap, *regmap;\n\n\t \n\tsdw_regmap = devm_regmap_init_sdw(slave, &rt715_sdw_regmap);\n\tif (IS_ERR(sdw_regmap))\n\t\treturn PTR_ERR(sdw_regmap);\n\n\tregmap = devm_regmap_init(&slave->dev, NULL, &slave->dev,\n\t\t&rt715_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt715_init(&slave->dev, sdw_regmap, regmap, slave);\n}\n\nstatic int rt715_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt715_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x714, 0x2, 0, 0),\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x715, 0x2, 0, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt715_id);\n\nstatic int __maybe_unused rt715_dev_suspend(struct device *dev)\n{\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\n\tif (!rt715->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt715->regmap, true);\n\n\treturn 0;\n}\n\n#define RT715_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt715_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt715_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt715->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\t\t   msecs_to_jiffies(RT715_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt715->regmap, false);\n\tregcache_sync_region(rt715->regmap, 0x3000, 0x8fff);\n\tregcache_sync_region(rt715->regmap, 0x752039, 0x752039);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt715_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt715_dev_suspend, rt715_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt715_dev_suspend, rt715_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt715_sdw_driver = {\n\t.driver = {\n\t\t   .name = \"rt715\",\n\t\t   .owner = THIS_MODULE,\n\t\t   .pm = &rt715_pm,\n\t\t   },\n\t.probe = rt715_sdw_probe,\n\t.remove = rt715_sdw_remove,\n\t.ops = &rt715_slave_ops,\n\t.id_table = rt715_id,\n};\nmodule_sdw_driver(rt715_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT715 driver SDW\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}