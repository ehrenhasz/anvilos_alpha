{
  "module_name": "cs42l42-sdw.c",
  "hash_id": "c318a34302fb4f22a6e734fb1c47ac10373090290ef13ad4c4908f3708e3e17c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l42-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_irq.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw_type.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n\n#include \"cs42l42.h\"\n\n#define CS42L42_SDW_CAPTURE_PORT\t1\n#define CS42L42_SDW_PLAYBACK_PORT\t2\n\n \n#define CS42L42_SDW_ADDR_OFFSET\t\t0x8000\n\n#define CS42L42_SDW_MEM_ACCESS_STATUS\t0xd0\n#define CS42L42_SDW_MEM_READ_DATA\t0xd8\n\n#define CS42L42_SDW_LAST_LATE\t\tBIT(3)\n#define CS42L42_SDW_CMD_IN_PROGRESS\tBIT(2)\n#define CS42L42_SDW_RDATA_RDY\t\tBIT(0)\n\n#define CS42L42_DELAYED_READ_POLL_US\t1\n#define CS42L42_DELAYED_READ_TIMEOUT_US\t100\n\nstatic const struct snd_soc_dapm_route cs42l42_sdw_audio_map[] = {\n\t \n\t{ \"HP\", NULL, \"MIXER\" },\n\t{ \"MIXER\", NULL, \"DACSRC\" },\n\t{ \"DACSRC\", NULL, \"Playback\" },\n\n\t \n\t{ \"ADCSRC\", NULL, \"HS\" },\n\t{ \"Capture\", NULL, \"ADCSRC\" },\n};\n\nstatic int cs42l42_sdw_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (!cs42l42->init_done)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(dai->component);\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tint ret;\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\t \n\tcs42l42->sample_rate = params_rate(params);\n\n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_config.num = CS42L42_SDW_PLAYBACK_PORT;\n\telse\n\t\tport_config.num = CS42L42_SDW_CAPTURE_PORT;\n\n\tret = sdw_stream_add_slave(cs42l42->sdw_peripheral, &stream_config, &port_config, 1,\n\t\t\t\t   sdw_stream);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Failed to add sdw stream: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs42l42_src_config(dai->component, params_rate(params));\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(dai->component);\n\n\tdev_dbg(dai->dev, \"dai_prepare: sclk=%u rate=%u\\n\", cs42l42->sclk, cs42l42->sample_rate);\n\n\tif (!cs42l42->sclk || !cs42l42->sample_rate)\n\t\treturn -EINVAL;\n\n\t \n\n\treturn cs42l42_pll_config(dai->component, cs42l42->sclk, cs42l42->sample_rate);\n}\n\nstatic int cs42l42_sdw_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct cs42l42_private *cs42l42 = snd_soc_component_get_drvdata(dai->component);\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tsdw_stream_remove_slave(cs42l42->sdw_peripheral, sdw_stream);\n\tcs42l42->sample_rate = 0;\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_port_prep(struct sdw_slave *slave,\n\t\t\t\t struct sdw_prepare_ch *prepare_ch,\n\t\t\t\t enum sdw_port_prep_ops state)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&slave->dev);\n\tunsigned int pdn_mask;\n\n\tif (prepare_ch->num == CS42L42_SDW_PLAYBACK_PORT)\n\t\tpdn_mask = CS42L42_HP_PDN_MASK;\n\telse\n\t\tpdn_mask = CS42L42_ADC_PDN_MASK;\n\n\tif (state == SDW_OPS_PORT_PRE_PREP) {\n\t\tdev_dbg(cs42l42->dev, \"Prep Port pdn_mask:%x\\n\", pdn_mask);\n\t\tregmap_clear_bits(cs42l42->regmap, CS42L42_PWR_CTL1, pdn_mask);\n\t\tusleep_range(CS42L42_HP_ADC_EN_TIME_US, CS42L42_HP_ADC_EN_TIME_US + 1000);\n\t} else if (state == SDW_OPS_PORT_POST_DEPREP) {\n\t\tdev_dbg(cs42l42->dev, \"Deprep Port pdn_mask:%x\\n\", pdn_mask);\n\t\tregmap_set_bits(cs42l42->regmap, CS42L42_PWR_CTL1, pdn_mask);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_dai_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\t\t  int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void cs42l42_sdw_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic const struct snd_soc_dai_ops cs42l42_sdw_dai_ops = {\n\t.startup\t= cs42l42_sdw_dai_startup,\n\t.shutdown\t= cs42l42_sdw_dai_shutdown,\n\t.hw_params\t= cs42l42_sdw_dai_hw_params,\n\t.prepare\t= cs42l42_sdw_dai_prepare,\n\t.hw_free\t= cs42l42_sdw_dai_hw_free,\n\t.mute_stream\t= cs42l42_mute_stream,\n\t.set_stream\t= cs42l42_sdw_dai_set_sdw_stream,\n};\n\nstatic struct snd_soc_dai_driver cs42l42_sdw_dai = {\n\t.name = \"cs42l42-sdw\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t \n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t \n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.symmetric_rate = 1,\n\t.ops = &cs42l42_sdw_dai_ops,\n};\n\nstatic int cs42l42_sdw_poll_status(struct sdw_slave *peripheral, u8 mask, u8 match)\n{\n\tint ret, sdwret;\n\n\tret = read_poll_timeout(sdw_read_no_pm, sdwret,\n\t\t\t\t(sdwret < 0) || ((sdwret & mask) == match),\n\t\t\t\tCS42L42_DELAYED_READ_POLL_US, CS42L42_DELAYED_READ_TIMEOUT_US,\n\t\t\t\tfalse, peripheral, CS42L42_SDW_MEM_ACCESS_STATUS);\n\tif (ret == 0)\n\t\tret = sdwret;\n\n\tif (ret < 0)\n\t\tdev_err(&peripheral->dev, \"MEM_ACCESS_STATUS & %#x for %#x fail: %d\\n\",\n\t\t\tmask, match, ret);\n\n\treturn ret;\n}\n\nstatic int cs42l42_sdw_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct sdw_slave *peripheral = context;\n\tu8 data;\n\tint ret;\n\n\treg += CS42L42_SDW_ADDR_OFFSET;\n\n\tret = cs42l42_sdw_poll_status(peripheral, CS42L42_SDW_CMD_IN_PROGRESS, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = sdw_read_no_pm(peripheral, reg);\n\tif (ret < 0) {\n\t\tdev_err(&peripheral->dev, \"Failed to issue read @0x%x: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\tdata = (u8)ret;\t \n\tret = sdw_read_no_pm(peripheral, CS42L42_SDW_MEM_ACCESS_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(&peripheral->dev, \"Failed to read MEM_ACCESS_STATUS: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((ret & CS42L42_SDW_LAST_LATE) == 0) {\n\t\t*val = data;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((ret & CS42L42_SDW_RDATA_RDY) == 0) {\n\t\tret = cs42l42_sdw_poll_status(peripheral,\n\t\t\t\t\t      CS42L42_SDW_RDATA_RDY, CS42L42_SDW_RDATA_RDY);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = sdw_read_no_pm(peripheral, CS42L42_SDW_MEM_READ_DATA);\n\tif (ret < 0) {\n\t\tdev_err(&peripheral->dev, \"Failed to read READ_DATA: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = (u8)ret;\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct sdw_slave *peripheral = context;\n\tint ret;\n\n\tret = cs42l42_sdw_poll_status(peripheral, CS42L42_SDW_CMD_IN_PROGRESS, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn sdw_write_no_pm(peripheral, reg + CS42L42_SDW_ADDR_OFFSET, (u8)val);\n}\n\n \nstatic void cs42l42_sdw_init(struct sdw_slave *peripheral)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&peripheral->dev);\n\tint ret;\n\n\tregcache_cache_only(cs42l42->regmap, false);\n\n\tret = cs42l42_init(cs42l42);\n\tif (ret < 0) {\n\t\tregcache_cache_only(cs42l42->regmap, true);\n\t\tgoto err;\n\t}\n\n\t \n\tret = regcache_sync(cs42l42->regmap);\n\tif (ret < 0)\n\t\tdev_warn(cs42l42->dev, \"Failed to sync cache: %d\\n\", ret);\n\n\t \n\tregmap_clear_bits(cs42l42->regmap, CS42L42_PWR_CTL3, CS42L42_SW_CLK_STP_STAT_SEL_MASK);\n\nerr:\n\t \n\tpm_runtime_put_autosuspend(cs42l42->dev);\n}\n\nstatic int cs42l42_sdw_read_prop(struct sdw_slave *peripheral)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&peripheral->dev);\n\tstruct sdw_slave_prop *prop = &peripheral->prop;\n\tstruct sdw_dpn_prop *ports;\n\n\tports = devm_kcalloc(cs42l42->dev, 2, sizeof(*ports), GFP_KERNEL);\n\tif (!ports)\n\t\treturn -ENOMEM;\n\n\tprop->source_ports = BIT(CS42L42_SDW_CAPTURE_PORT);\n\tprop->sink_ports = BIT(CS42L42_SDW_PLAYBACK_PORT);\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\n\t \n\tports[0].num = CS42L42_SDW_CAPTURE_PORT,\n\tports[0].type = SDW_DPN_FULL,\n\tports[0].ch_prep_timeout = 10,\n\tprop->src_dpn_prop = &ports[0];\n\n\t \n\tports[1].num = CS42L42_SDW_PLAYBACK_PORT,\n\tports[1].type = SDW_DPN_FULL,\n\tports[1].ch_prep_timeout = 10,\n\tprop->sink_dpn_prop = &ports[1];\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_update_status(struct sdw_slave *peripheral,\n\t\t\t\t     enum sdw_slave_status status)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&peripheral->dev);\n\n\tswitch (status) {\n\tcase SDW_SLAVE_ATTACHED:\n\t\tdev_dbg(cs42l42->dev, \"ATTACHED\\n\");\n\n\t\t \n\t\tif (cs42l42->sdw_waiting_first_unattach)\n\t\t\tbreak;\n\n\t\t \n\t\tif (!cs42l42->init_done)\n\t\t\tcs42l42_sdw_init(peripheral);\n\t\tbreak;\n\tcase SDW_SLAVE_UNATTACHED:\n\t\tdev_dbg(cs42l42->dev, \"UNATTACHED\\n\");\n\n\t\tif (cs42l42->sdw_waiting_first_unattach) {\n\t\t\t \n\t\t\tcs42l42->sdw_waiting_first_unattach = false;\n\t\t\tgpiod_set_value_cansleep(cs42l42->reset_gpio, 1);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_bus_config(struct sdw_slave *peripheral,\n\t\t\t\t  struct sdw_bus_params *params)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&peripheral->dev);\n\tunsigned int new_sclk = params->curr_dr_freq / 2;\n\n\t \n\tif ((new_sclk != cs42l42->sclk) && cs42l42->stream_use) {\n\t\tdev_warn(cs42l42->dev, \"Rejected SCLK change while audio active\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcs42l42->sclk = new_sclk;\n\n\tdev_dbg(cs42l42->dev, \"bus_config: sclk=%u c=%u r=%u\\n\",\n\t\tcs42l42->sclk, params->col, params->row);\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops cs42l42_sdw_ops = {\n \n\t.read_prop = cs42l42_sdw_read_prop,\n\t.update_status = cs42l42_sdw_update_status,\n\t.bus_config = cs42l42_sdw_bus_config,\n\t.port_prep = cs42l42_sdw_port_prep,\n};\n\nstatic int __maybe_unused cs42l42_sdw_runtime_suspend(struct device *dev)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"Runtime suspend\\n\");\n\n\tif (!cs42l42->init_done)\n\t\treturn 0;\n\n\t \n\tregcache_cache_only(cs42l42->regmap, true);\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence __maybe_unused cs42l42_soft_reboot_seq[] = {\n\tREG_SEQ0(CS42L42_SOFT_RESET_REBOOT, 0x1e),\n};\n\nstatic int __maybe_unused cs42l42_sdw_handle_unattach(struct cs42l42_private *cs42l42)\n{\n\tstruct sdw_slave *peripheral = cs42l42->sdw_peripheral;\n\n\tif (!peripheral->unattach_request)\n\t\treturn 0;\n\n\t \n\tdev_dbg(&peripheral->dev, \"Wait for initialization_complete\\n\");\n\tif (!wait_for_completion_timeout(&peripheral->initialization_complete,\n\t\t\t\t\t msecs_to_jiffies(5000))) {\n\t\tdev_err(&peripheral->dev, \"initialization_complete timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tperipheral->unattach_request = 0;\n\n\t \n\tregmap_multi_reg_write_bypassed(cs42l42->regmap,\n\t\t\t\t\tcs42l42_soft_reboot_seq,\n\t\t\t\t\tARRAY_SIZE(cs42l42_soft_reboot_seq));\n\tusleep_range(CS42L42_BOOT_TIME_US, CS42L42_BOOT_TIME_US * 2);\n\tregcache_mark_dirty(cs42l42->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs42l42_sdw_runtime_resume(struct device *dev)\n{\n\tstatic const unsigned int ts_dbnce_ms[] = { 0, 125, 250, 500, 750, 1000, 1250, 1500};\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\tunsigned int dbnce;\n\tint ret;\n\n\tdev_dbg(dev, \"Runtime resume\\n\");\n\n\tif (!cs42l42->init_done)\n\t\treturn 0;\n\n\tret = cs42l42_sdw_handle_unattach(cs42l42);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if (ret > 0) {\n\t\tdbnce = max(cs42l42->ts_dbnc_rise, cs42l42->ts_dbnc_fall);\n\n\t\tif (dbnce > 0)\n\t\t\tmsleep(ts_dbnce_ms[dbnce]);\n\t}\n\n\tregcache_cache_only(cs42l42->regmap, false);\n\n\t \n\tregcache_sync_region(cs42l42->regmap, CS42L42_MIC_DET_CTL1, CS42L42_MIC_DET_CTL1);\n\tregcache_sync(cs42l42->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs42l42_sdw_resume(struct device *dev)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"System resume\\n\");\n\n\t \n\tret = cs42l42_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cs42l42_sdw_handle_unattach(cs42l42);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcs42l42_resume_restore(dev);\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_probe(struct sdw_slave *peripheral, const struct sdw_device_id *id)\n{\n\tstruct snd_soc_component_driver *component_drv;\n\tstruct device *dev = &peripheral->dev;\n\tstruct cs42l42_private *cs42l42;\n\tstruct regmap_config *regmap_conf;\n\tstruct regmap *regmap;\n\tint irq, ret;\n\n\tcs42l42 = devm_kzalloc(dev, sizeof(*cs42l42), GFP_KERNEL);\n\tif (!cs42l42)\n\t\treturn -ENOMEM;\n\n\tif (has_acpi_companion(dev))\n\t\tirq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), 0);\n\telse\n\t\tirq = of_irq_get(dev->of_node, 0);\n\n\tif (irq == -ENOENT)\n\t\tirq = 0;\n\telse if (irq < 0)\n\t\treturn dev_err_probe(dev, irq, \"Failed to get IRQ\\n\");\n\n\tregmap_conf = devm_kmemdup(dev, &cs42l42_regmap, sizeof(cs42l42_regmap), GFP_KERNEL);\n\tif (!regmap_conf)\n\t\treturn -ENOMEM;\n\tregmap_conf->reg_bits = 16;\n\tregmap_conf->num_ranges = 0;\n\tregmap_conf->reg_read = cs42l42_sdw_read;\n\tregmap_conf->reg_write = cs42l42_sdw_write;\n\n\tregmap = devm_regmap_init(dev, NULL, peripheral, regmap_conf);\n\tif (IS_ERR(regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(regmap), \"Failed to allocate register map\\n\");\n\n\t \n\tregcache_cache_only(regmap, true);\n\n\tcomponent_drv = devm_kmemdup(dev,\n\t\t\t\t     &cs42l42_soc_component,\n\t\t\t\t     sizeof(cs42l42_soc_component),\n\t\t\t\t     GFP_KERNEL);\n\tif (!component_drv)\n\t\treturn -ENOMEM;\n\n\tcomponent_drv->dapm_routes = cs42l42_sdw_audio_map;\n\tcomponent_drv->num_dapm_routes = ARRAY_SIZE(cs42l42_sdw_audio_map);\n\n\tcs42l42->dev = dev;\n\tcs42l42->regmap = regmap;\n\tcs42l42->sdw_peripheral = peripheral;\n\tcs42l42->irq = irq;\n\tcs42l42->devid = CS42L42_CHIP_ID;\n\n\t \n\tpm_runtime_set_autosuspend_delay(cs42l42->dev, 3000);\n\tpm_runtime_use_autosuspend(cs42l42->dev);\n\tpm_runtime_mark_last_busy(cs42l42->dev);\n\tpm_runtime_set_active(cs42l42->dev);\n\tpm_runtime_get_noresume(cs42l42->dev);\n\tpm_runtime_enable(cs42l42->dev);\n\n\tret = cs42l42_common_probe(cs42l42, component_drv, &cs42l42_sdw_dai);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cs42l42_sdw_remove(struct sdw_slave *peripheral)\n{\n\tstruct cs42l42_private *cs42l42 = dev_get_drvdata(&peripheral->dev);\n\n\tcs42l42_common_remove(cs42l42);\n\tpm_runtime_disable(cs42l42->dev);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cs42l42_sdw_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cs42l42_suspend, cs42l42_sdw_resume)\n\tSET_RUNTIME_PM_OPS(cs42l42_sdw_runtime_suspend, cs42l42_sdw_runtime_resume, NULL)\n};\n\nstatic const struct sdw_device_id cs42l42_sdw_id[] = {\n\tSDW_SLAVE_ENTRY(0x01FA, 0x4242, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, cs42l42_sdw_id);\n\nstatic struct sdw_driver cs42l42_sdw_driver = {\n\t.driver = {\n\t\t.name = \"cs42l42-sdw\",\n\t\t.pm = &cs42l42_sdw_pm,\n\t},\n\t.probe = cs42l42_sdw_probe,\n\t.remove = cs42l42_sdw_remove,\n\t.ops = &cs42l42_sdw_ops,\n\t.id_table = cs42l42_sdw_id,\n};\n\nmodule_sdw_driver(cs42l42_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS42L42 SoundWire driver\");\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(SND_SOC_CS42L42_CORE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}