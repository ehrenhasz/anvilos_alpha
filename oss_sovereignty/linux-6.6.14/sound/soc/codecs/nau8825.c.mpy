{
  "module_name": "nau8825.c",
  "hash_id": "56e795a224d939bf55a81d20d18036ac32e106c1d1fe6cf711216aa47ee2aff9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8825.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/int_log.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/acpi.h>\n#include <linux/math64.h>\n#include <linux/semaphore.h>\n\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n\n\n#include \"nau8825.h\"\n\n\n#define NUVOTON_CODEC_DAI \"nau8825-hifi\"\n\n#define NAU_FREF_MAX 13500000\n#define NAU_FVCO_MAX 124000000\n#define NAU_FVCO_MIN 90000000\n\n \n#define GAIN_AUGMENT 22500\n#define SIDETONE_BASE 207000\n\n \n#define CLK_DA_AD_MAX 6144000\n\nstatic int nau8825_configure_sysclk(struct nau8825 *nau8825,\n\t\tint clk_id, unsigned int freq);\nstatic bool nau8825_is_jack_inserted(struct regmap *regmap);\n\nstruct nau8825_fll {\n\tint mclk_src;\n\tint ratio;\n\tint fll_frac;\n\tint fll_frac_num;\n\tint fll_int;\n\tint clk_ref_div;\n};\n\nstruct nau8825_fll_attr {\n\tunsigned int param;\n\tunsigned int val;\n};\n\n \nstatic const struct nau8825_fll_attr mclk_src_scaling[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x2 },\n\t{ 4, 0x3 },\n\t{ 8, 0x4 },\n\t{ 16, 0x5 },\n\t{ 32, 0x6 },\n\t{ 3, 0x7 },\n\t{ 6, 0xa },\n\t{ 12, 0xb },\n\t{ 24, 0xc },\n\t{ 48, 0xd },\n\t{ 96, 0xe },\n\t{ 5, 0xf },\n};\n\n \nstatic const struct nau8825_fll_attr fll_ratio[] = {\n\t{ 512000, 0x01 },\n\t{ 256000, 0x02 },\n\t{ 128000, 0x04 },\n\t{ 64000, 0x08 },\n\t{ 32000, 0x10 },\n\t{ 8000, 0x20 },\n\t{ 4000, 0x40 },\n};\n\nstatic const struct nau8825_fll_attr fll_pre_scalar[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x1 },\n\t{ 4, 0x2 },\n\t{ 8, 0x3 },\n};\n\n \nstruct nau8825_osr_attr {\n\tunsigned int osr;\n\tunsigned int clk_src;\n};\n\nstatic const struct nau8825_osr_attr osr_dac_sel[] = {\n\t{ 64, 2 },\t \n\t{ 256, 0 },\t \n\t{ 128, 1 },\t \n\t{ 0, 0 },\n\t{ 32, 3 },\t \n};\n\nstatic const struct nau8825_osr_attr osr_adc_sel[] = {\n\t{ 32, 3 },\t \n\t{ 64, 2 },\t \n\t{ 128, 1 },\t \n\t{ 256, 0 },\t \n};\n\nstatic const struct reg_default nau8825_reg_defaults[] = {\n\t{ NAU8825_REG_ENA_CTRL, 0x00ff },\n\t{ NAU8825_REG_IIC_ADDR_SET, 0x0 },\n\t{ NAU8825_REG_CLK_DIVIDER, 0x0050 },\n\t{ NAU8825_REG_FLL1, 0x0 },\n\t{ NAU8825_REG_FLL2, 0x3126 },\n\t{ NAU8825_REG_FLL3, 0x0008 },\n\t{ NAU8825_REG_FLL4, 0x0010 },\n\t{ NAU8825_REG_FLL5, 0x0 },\n\t{ NAU8825_REG_FLL6, 0x6000 },\n\t{ NAU8825_REG_FLL_VCO_RSV, 0xf13c },\n\t{ NAU8825_REG_HSD_CTRL, 0x000c },\n\t{ NAU8825_REG_JACK_DET_CTRL, 0x0 },\n\t{ NAU8825_REG_INTERRUPT_MASK, 0x0 },\n\t{ NAU8825_REG_INTERRUPT_DIS_CTRL, 0xffff },\n\t{ NAU8825_REG_SAR_CTRL, 0x0015 },\n\t{ NAU8825_REG_KEYDET_CTRL, 0x0110 },\n\t{ NAU8825_REG_VDET_THRESHOLD_1, 0x0 },\n\t{ NAU8825_REG_VDET_THRESHOLD_2, 0x0 },\n\t{ NAU8825_REG_VDET_THRESHOLD_3, 0x0 },\n\t{ NAU8825_REG_VDET_THRESHOLD_4, 0x0 },\n\t{ NAU8825_REG_GPIO34_CTRL, 0x0 },\n\t{ NAU8825_REG_GPIO12_CTRL, 0x0 },\n\t{ NAU8825_REG_TDM_CTRL, 0x0 },\n\t{ NAU8825_REG_I2S_PCM_CTRL1, 0x000b },\n\t{ NAU8825_REG_I2S_PCM_CTRL2, 0x8010 },\n\t{ NAU8825_REG_LEFT_TIME_SLOT, 0x0 },\n\t{ NAU8825_REG_RIGHT_TIME_SLOT, 0x0 },\n\t{ NAU8825_REG_BIQ_CTRL, 0x0 },\n\t{ NAU8825_REG_BIQ_COF1, 0x0 },\n\t{ NAU8825_REG_BIQ_COF2, 0x0 },\n\t{ NAU8825_REG_BIQ_COF3, 0x0 },\n\t{ NAU8825_REG_BIQ_COF4, 0x0 },\n\t{ NAU8825_REG_BIQ_COF5, 0x0 },\n\t{ NAU8825_REG_BIQ_COF6, 0x0 },\n\t{ NAU8825_REG_BIQ_COF7, 0x0 },\n\t{ NAU8825_REG_BIQ_COF8, 0x0 },\n\t{ NAU8825_REG_BIQ_COF9, 0x0 },\n\t{ NAU8825_REG_BIQ_COF10, 0x0 },\n\t{ NAU8825_REG_ADC_RATE, 0x0010 },\n\t{ NAU8825_REG_DAC_CTRL1, 0x0001 },\n\t{ NAU8825_REG_DAC_CTRL2, 0x0 },\n\t{ NAU8825_REG_DAC_DGAIN_CTRL, 0x0 },\n\t{ NAU8825_REG_ADC_DGAIN_CTRL, 0x00cf },\n\t{ NAU8825_REG_MUTE_CTRL, 0x0 },\n\t{ NAU8825_REG_HSVOL_CTRL, 0x0 },\n\t{ NAU8825_REG_DACL_CTRL, 0x02cf },\n\t{ NAU8825_REG_DACR_CTRL, 0x00cf },\n\t{ NAU8825_REG_ADC_DRC_KNEE_IP12, 0x1486 },\n\t{ NAU8825_REG_ADC_DRC_KNEE_IP34, 0x0f12 },\n\t{ NAU8825_REG_ADC_DRC_SLOPES, 0x25ff },\n\t{ NAU8825_REG_ADC_DRC_ATKDCY, 0x3457 },\n\t{ NAU8825_REG_DAC_DRC_KNEE_IP12, 0x1486 },\n\t{ NAU8825_REG_DAC_DRC_KNEE_IP34, 0x0f12 },\n\t{ NAU8825_REG_DAC_DRC_SLOPES, 0x25f9 },\n\t{ NAU8825_REG_DAC_DRC_ATKDCY, 0x3457 },\n\t{ NAU8825_REG_IMM_MODE_CTRL, 0x0 },\n\t{ NAU8825_REG_CLASSG_CTRL, 0x0 },\n\t{ NAU8825_REG_OPT_EFUSE_CTRL, 0x0 },\n\t{ NAU8825_REG_MISC_CTRL, 0x0 },\n\t{ NAU8825_REG_FLL2_LOWER, 0x0 },\n\t{ NAU8825_REG_FLL2_UPPER, 0x0 },\n\t{ NAU8825_REG_BIAS_ADJ, 0x0 },\n\t{ NAU8825_REG_TRIM_SETTINGS, 0x0 },\n\t{ NAU8825_REG_ANALOG_CONTROL_1, 0x0 },\n\t{ NAU8825_REG_ANALOG_CONTROL_2, 0x0 },\n\t{ NAU8825_REG_ANALOG_ADC_1, 0x0011 },\n\t{ NAU8825_REG_ANALOG_ADC_2, 0x0020 },\n\t{ NAU8825_REG_RDAC, 0x0008 },\n\t{ NAU8825_REG_MIC_BIAS, 0x0006 },\n\t{ NAU8825_REG_BOOST, 0x0 },\n\t{ NAU8825_REG_FEPGA, 0x0 },\n\t{ NAU8825_REG_POWER_UP_CONTROL, 0x0 },\n\t{ NAU8825_REG_CHARGE_PUMP, 0x0 },\n};\n\n \nstatic struct reg_default nau8825_xtalk_baktab[] = {\n\t{ NAU8825_REG_ADC_DGAIN_CTRL, 0x00cf },\n\t{ NAU8825_REG_HSVOL_CTRL, 0 },\n\t{ NAU8825_REG_DACL_CTRL, 0x00cf },\n\t{ NAU8825_REG_DACR_CTRL, 0x02cf },\n};\n\n \nstatic const struct reg_sequence nau8825_regmap_patch[] = {\n\t{ NAU8825_REG_FLL2, 0x0000 },\n\t{ NAU8825_REG_FLL4, 0x8010 },\n\t{ NAU8825_REG_FLL_VCO_RSV, 0x0bc0 },\n\t{ NAU8825_REG_INTERRUPT_MASK, 0x0800 },\n\t{ NAU8825_REG_DACL_CTRL, 0x00cf },\n\t{ NAU8825_REG_DACR_CTRL, 0x02cf },\n\t{ NAU8825_REG_OPT_EFUSE_CTRL, 0x0400 },\n\t{ NAU8825_REG_FLL2_LOWER, 0x26e9 },\n\t{ NAU8825_REG_FLL2_UPPER, 0x0031 },\n\t{ NAU8825_REG_ANALOG_CONTROL_2, 0x0020 },\n\t{ NAU8825_REG_ANALOG_ADC_2, 0x0220 },\n\t{ NAU8825_REG_MIC_BIAS, 0x0046 },\n};\n\n \nstatic int nau8825_sema_acquire(struct nau8825 *nau8825, long timeout)\n{\n\tint ret;\n\n\tif (timeout) {\n\t\tret = down_timeout(&nau8825->xtalk_sem, timeout);\n\t\tif (ret < 0)\n\t\t\tdev_warn(nau8825->dev, \"Acquire semaphore timeout\\n\");\n\t} else {\n\t\tret = down_trylock(&nau8825->xtalk_sem);\n\t\tif (ret)\n\t\t\tdev_warn(nau8825->dev, \"Acquire semaphore fail\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic inline void nau8825_sema_release(struct nau8825 *nau8825)\n{\n\tup(&nau8825->xtalk_sem);\n}\n\n \nstatic inline void nau8825_sema_reset(struct nau8825 *nau8825)\n{\n\tnau8825->xtalk_sem.count = 1;\n}\n\n \nstatic void nau8825_hpvol_ramp(struct nau8825 *nau8825,\n\tunsigned int vol_from, unsigned int vol_to, unsigned int step)\n{\n\tunsigned int value, volume, ramp_up, from, to;\n\n\tif (vol_from == vol_to || step == 0) {\n\t\treturn;\n\t} else if (vol_from < vol_to) {\n\t\tramp_up = true;\n\t\tfrom = vol_from;\n\t\tto = vol_to;\n\t} else {\n\t\tramp_up = false;\n\t\tfrom = vol_to;\n\t\tto = vol_from;\n\t}\n\t \n\tif (to > NAU8825_HP_VOL_MIN)\n\t\tto = NAU8825_HP_VOL_MIN;\n\n\tfor (volume = from; volume < to; volume += step) {\n\t\tif (ramp_up)\n\t\t\tvalue = volume;\n\t\telse\n\t\t\tvalue = to - volume + from;\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_HSVOL_CTRL,\n\t\t\tNAU8825_HPL_VOL_MASK | NAU8825_HPR_VOL_MASK,\n\t\t\t(value << NAU8825_HPL_VOL_SFT) | value);\n\t\tusleep_range(10000, 10500);\n\t}\n\tif (ramp_up)\n\t\tvalue = to;\n\telse\n\t\tvalue = from;\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_HSVOL_CTRL,\n\t\tNAU8825_HPL_VOL_MASK | NAU8825_HPR_VOL_MASK,\n\t\t(value << NAU8825_HPL_VOL_SFT) | value);\n}\n\n \nstatic u32 nau8825_intlog10_dec3(u32 value)\n{\n\treturn intlog10(value) / ((1 << 24) / 1000);\n}\n\n \nstatic u32 nau8825_xtalk_sidetone(u32 sig_org, u32 sig_cros)\n{\n\tu32 gain, sidetone;\n\n\tif (WARN_ON(sig_org == 0 || sig_cros == 0))\n\t\treturn 0;\n\n\tsig_org = nau8825_intlog10_dec3(sig_org);\n\tsig_cros = nau8825_intlog10_dec3(sig_cros);\n\tif (sig_org >= sig_cros)\n\t\tgain = (sig_org - sig_cros) * 20 + GAIN_AUGMENT;\n\telse\n\t\tgain = (sig_cros - sig_org) * 20 + GAIN_AUGMENT;\n\tsidetone = SIDETONE_BASE - gain * 2;\n\tsidetone /= 1000;\n\n\treturn sidetone;\n}\n\nstatic int nau8825_xtalk_baktab_index_by_reg(unsigned int reg)\n{\n\tint index;\n\n\tfor (index = 0; index < ARRAY_SIZE(nau8825_xtalk_baktab); index++)\n\t\tif (nau8825_xtalk_baktab[index].reg == reg)\n\t\t\treturn index;\n\treturn -EINVAL;\n}\n\nstatic void nau8825_xtalk_backup(struct nau8825 *nau8825)\n{\n\tint i;\n\n\tif (nau8825->xtalk_baktab_initialized)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(nau8825_xtalk_baktab); i++)\n\t\tregmap_read(nau8825->regmap, nau8825_xtalk_baktab[i].reg,\n\t\t\t\t&nau8825_xtalk_baktab[i].def);\n\n\tnau8825->xtalk_baktab_initialized = true;\n}\n\nstatic void nau8825_xtalk_restore(struct nau8825 *nau8825, bool cause_cancel)\n{\n\tint i, volume;\n\n\tif (!nau8825->xtalk_baktab_initialized)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(nau8825_xtalk_baktab); i++) {\n\t\tif (!cause_cancel && nau8825_xtalk_baktab[i].reg ==\n\t\t\tNAU8825_REG_HSVOL_CTRL) {\n\t\t\t \n\t\t\tvolume = nau8825_xtalk_baktab[i].def &\n\t\t\t\tNAU8825_HPR_VOL_MASK;\n\t\t\tnau8825_hpvol_ramp(nau8825, 0, volume, 3);\n\t\t\tcontinue;\n\t\t}\n\t\tregmap_write(nau8825->regmap, nau8825_xtalk_baktab[i].reg,\n\t\t\t\tnau8825_xtalk_baktab[i].def);\n\t}\n\n\tnau8825->xtalk_baktab_initialized = false;\n}\n\nstatic void nau8825_xtalk_prepare_dac(struct nau8825 *nau8825)\n{\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_DACR | NAU8825_ENABLE_DACL |\n\t\tNAU8825_ENABLE_ADC | NAU8825_ENABLE_ADC_CLK |\n\t\tNAU8825_ENABLE_DAC_CLK, NAU8825_ENABLE_DACR |\n\t\tNAU8825_ENABLE_DACL | NAU8825_ENABLE_ADC |\n\t\tNAU8825_ENABLE_ADC_CLK | NAU8825_ENABLE_DAC_CLK);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\tNAU8825_JAMNODCLOW | NAU8825_CHANRGE_PUMP_EN,\n\t\tNAU8825_JAMNODCLOW | NAU8825_CHANRGE_PUMP_EN);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_RDAC,\n\t\tNAU8825_RDAC_EN | NAU8825_RDAC_CLK_EN |\n\t\tNAU8825_RDAC_FS_BCLK_ENB,\n\t\tNAU8825_RDAC_EN | NAU8825_RDAC_CLK_EN);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_POWER_UP_CONTROL,\n\t\tNAU8825_POWERUP_INTEGR_R | NAU8825_POWERUP_INTEGR_L |\n\t\tNAU8825_POWERUP_DRV_IN_R | NAU8825_POWERUP_DRV_IN_L,\n\t\tNAU8825_POWERUP_INTEGR_R | NAU8825_POWERUP_INTEGR_L |\n\t\tNAU8825_POWERUP_DRV_IN_R | NAU8825_POWERUP_DRV_IN_L);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_POWER_UP_CONTROL,\n\t\tNAU8825_POWERUP_HP_DRV_R | NAU8825_POWERUP_HP_DRV_L,\n\t\tNAU8825_POWERUP_HP_DRV_R | NAU8825_POWERUP_HP_DRV_L);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_HSD_CTRL,\n\t\tNAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\n\t\tNAU8825_HP_BOOST_DIS, NAU8825_HP_BOOST_DIS);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLASSG_CTRL,\n\t\tNAU8825_CLASSG_LDAC_EN | NAU8825_CLASSG_RDAC_EN,\n\t\tNAU8825_CLASSG_LDAC_EN | NAU8825_CLASSG_RDAC_EN);\n}\n\nstatic void nau8825_xtalk_prepare_adc(struct nau8825 *nau8825)\n{\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ANALOG_ADC_2,\n\t\tNAU8825_POWERUP_ADCL | NAU8825_ADC_VREFSEL_MASK,\n\t\tNAU8825_POWERUP_ADCL | NAU8825_ADC_VREFSEL_VMID_PLUS_0_5DB);\n}\n\nstatic void nau8825_xtalk_clock(struct nau8825 *nau8825)\n{\n\t \n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL1, 0x0);\n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL2, 0x3126);\n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL3, 0x0008);\n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL4, 0x0010);\n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL5, 0x0);\n\tregmap_write(nau8825->regmap, NAU8825_REG_FLL6, 0x6000);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\tNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_VCO);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL6, NAU8825_DCO_EN,\n\t\tNAU8825_DCO_EN);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\tNAU8825_CLK_MCLK_SRC_MASK, 0xf);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL1,\n\t\tNAU8825_FLL_RATIO_MASK, 0x10);\n}\n\nstatic void nau8825_xtalk_prepare(struct nau8825 *nau8825)\n{\n\tint volume, index;\n\n\t \n\tnau8825_xtalk_backup(nau8825);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\tNAU8825_I2S_MS_MASK | NAU8825_I2S_LRC_DIV_MASK |\n\t\tNAU8825_I2S_BLK_DIV_MASK, NAU8825_I2S_MS_MASTER |\n\t\t(0x2 << NAU8825_I2S_LRC_DIV_SFT) | 0x1);\n\t \n\tindex = nau8825_xtalk_baktab_index_by_reg(NAU8825_REG_HSVOL_CTRL);\n\tif (index != -EINVAL) {\n\t\tvolume = nau8825_xtalk_baktab[index].def &\n\t\t\t\tNAU8825_HPR_VOL_MASK;\n\t\tnau8825_hpvol_ramp(nau8825, volume, 0, 3);\n\t}\n\tnau8825_xtalk_clock(nau8825);\n\tnau8825_xtalk_prepare_dac(nau8825);\n\tnau8825_xtalk_prepare_adc(nau8825);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_DACL_CTRL,\n\t\tNAU8825_DACL_CH_SEL_MASK | NAU8825_DACL_CH_VOL_MASK,\n\t\tNAU8825_DACL_CH_SEL_L | 0xab);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_DACR_CTRL,\n\t\tNAU8825_DACR_CH_SEL_MASK | NAU8825_DACR_CH_VOL_MASK,\n\t\tNAU8825_DACR_CH_SEL_R | 0xab);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_IMM_MODE_CTRL,\n\t\tNAU8825_IMM_THD_MASK | NAU8825_IMM_GEN_VOL_MASK |\n\t\tNAU8825_IMM_CYC_MASK | NAU8825_IMM_DAC_SRC_MASK,\n\t\t(0x9 << NAU8825_IMM_THD_SFT) | NAU8825_IMM_GEN_VOL_1_16th |\n\t\tNAU8825_IMM_CYC_8192 | NAU8825_IMM_DAC_SRC_SIN);\n\t \n\tregmap_update_bits(nau8825->regmap,\n\t\tNAU8825_REG_INTERRUPT_MASK, NAU8825_IRQ_RMS_EN, 0);\n\t \n\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL, 0);\n\telse\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\n}\n\nstatic void nau8825_xtalk_clean_dac(struct nau8825 *nau8825)\n{\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\n\t\tNAU8825_HP_BOOST_DIS, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_HSD_CTRL,\n\t\tNAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L,\n\t\tNAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L);\n\t \n\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\n\telse\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL, 0);\n\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\tNAU8825_BIAS_HPR_IMP | NAU8825_BIAS_HPL_IMP |\n\t\tNAU8825_BIAS_TESTDAC_EN, NAU8825_BIAS_TESTDAC_EN);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_POWER_UP_CONTROL,\n\t\tNAU8825_POWERUP_HP_DRV_R | NAU8825_POWERUP_HP_DRV_L, 0);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_POWER_UP_CONTROL,\n\t\tNAU8825_POWERUP_INTEGR_R | NAU8825_POWERUP_INTEGR_L |\n\t\tNAU8825_POWERUP_DRV_IN_R | NAU8825_POWERUP_DRV_IN_L, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_RDAC,\n\t\tNAU8825_RDAC_EN | NAU8825_RDAC_CLK_EN, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\tNAU8825_JAMNODCLOW | NAU8825_CHANRGE_PUMP_EN, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_DACR | NAU8825_ENABLE_DACL |\n\t\tNAU8825_ENABLE_ADC_CLK | NAU8825_ENABLE_DAC_CLK, 0);\n\tif (!nau8825->irq)\n\t\tregmap_update_bits(nau8825->regmap,\n\t\t\tNAU8825_REG_ENA_CTRL, NAU8825_ENABLE_ADC, 0);\n}\n\nstatic void nau8825_xtalk_clean_adc(struct nau8825 *nau8825)\n{\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ANALOG_ADC_2,\n\t\tNAU8825_POWERUP_ADCL | NAU8825_ADC_VREFSEL_MASK, 0);\n}\n\nstatic void nau8825_xtalk_clean(struct nau8825 *nau8825, bool cause_cancel)\n{\n\t \n\tnau8825_configure_sysclk(nau8825, NAU8825_CLK_INTERNAL, 0);\n\tnau8825_xtalk_clean_dac(nau8825);\n\tnau8825_xtalk_clean_adc(nau8825);\n\t \n\tregmap_write(nau8825->regmap, NAU8825_REG_IMM_MODE_CTRL, 0);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_RMS_EN, NAU8825_IRQ_RMS_EN);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\tNAU8825_I2S_MS_MASK | NAU8825_I2S_LRC_DIV_MASK |\n\t\tNAU8825_I2S_BLK_DIV_MASK, NAU8825_I2S_MS_SLAVE);\n\t \n\tnau8825_xtalk_restore(nau8825, cause_cancel);\n}\n\nstatic void nau8825_xtalk_imm_start(struct nau8825 *nau8825, int vol)\n{\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ADC_DGAIN_CTRL,\n\t\t\t\tNAU8825_ADC_DIG_VOL_MASK, vol);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\tNAU8825_BIAS_TESTDACR_EN | NAU8825_BIAS_TESTDACL_EN,\n\t\tNAU8825_BIAS_TESTDACL_EN);\n\tswitch (nau8825->xtalk_state) {\n\tcase NAU8825_XTALK_HPR_R2L:\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\t\tNAU8825_BIAS_HPR_IMP | NAU8825_BIAS_HPL_IMP,\n\t\t\tNAU8825_BIAS_HPR_IMP);\n\t\tbreak;\n\tcase NAU8825_XTALK_HPL_R2L:\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\t\tNAU8825_BIAS_HPR_IMP | NAU8825_BIAS_HPL_IMP,\n\t\t\tNAU8825_BIAS_HPL_IMP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmsleep(100);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_IMM_MODE_CTRL,\n\t\t\t\tNAU8825_IMM_EN, NAU8825_IMM_EN);\n}\n\nstatic void nau8825_xtalk_imm_stop(struct nau8825 *nau8825)\n{\n\t \n\tregmap_update_bits(nau8825->regmap,\n\t\tNAU8825_REG_IMM_MODE_CTRL, NAU8825_IMM_EN, 0);\n}\n\n \nstatic void nau8825_xtalk_measure(struct nau8825 *nau8825)\n{\n\tu32 sidetone;\n\n\tswitch (nau8825->xtalk_state) {\n\tcase NAU8825_XTALK_PREPARE:\n\t\t \n\t\tnau8825_xtalk_prepare(nau8825);\n\t\tmsleep(280);\n\t\t \n\t\tnau8825->xtalk_state = NAU8825_XTALK_HPR_R2L;\n\t\tnau8825_xtalk_imm_start(nau8825, 0x00d2);\n\t\tbreak;\n\tcase NAU8825_XTALK_HPR_R2L:\n\t\t \n\t\tregmap_read(nau8825->regmap, NAU8825_REG_IMM_RMS_L,\n\t\t\t&nau8825->imp_rms[NAU8825_XTALK_HPR_R2L]);\n\t\tdev_dbg(nau8825->dev, \"HPR_R2L imm: %x\\n\",\n\t\t\tnau8825->imp_rms[NAU8825_XTALK_HPR_R2L]);\n\t\t \n\t\tnau8825_xtalk_imm_stop(nau8825);\n\t\t \n\t\tnau8825->xtalk_state = NAU8825_XTALK_HPL_R2L;\n\t\tnau8825_xtalk_imm_start(nau8825, 0x00ff);\n\t\tbreak;\n\tcase NAU8825_XTALK_HPL_R2L:\n\t\t \n\t\tregmap_read(nau8825->regmap, NAU8825_REG_IMM_RMS_L,\n\t\t\t&nau8825->imp_rms[NAU8825_XTALK_HPL_R2L]);\n\t\tdev_dbg(nau8825->dev, \"HPL_R2L imm: %x\\n\",\n\t\t\tnau8825->imp_rms[NAU8825_XTALK_HPL_R2L]);\n\t\tnau8825_xtalk_imm_stop(nau8825);\n\t\tmsleep(150);\n\t\tnau8825->xtalk_state = NAU8825_XTALK_IMM;\n\t\tbreak;\n\tcase NAU8825_XTALK_IMM:\n\t\t \n\t\tsidetone = nau8825_xtalk_sidetone(\n\t\t\tnau8825->imp_rms[NAU8825_XTALK_HPR_R2L],\n\t\t\tnau8825->imp_rms[NAU8825_XTALK_HPL_R2L]);\n\t\tdev_dbg(nau8825->dev, \"cross talk sidetone: %x\\n\", sidetone);\n\t\tregmap_write(nau8825->regmap, NAU8825_REG_DAC_DGAIN_CTRL,\n\t\t\t\t\t(sidetone << 8) | sidetone);\n\t\tnau8825_xtalk_clean(nau8825, false);\n\t\tnau8825->xtalk_state = NAU8825_XTALK_DONE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void nau8825_xtalk_work(struct work_struct *work)\n{\n\tstruct nau8825 *nau8825 = container_of(\n\t\twork, struct nau8825, xtalk_work);\n\n\tnau8825_xtalk_measure(nau8825);\n\t \n\tif (nau8825->xtalk_state == NAU8825_XTALK_IMM)\n\t\tnau8825_xtalk_measure(nau8825);\n\n\t \n\tif (nau8825->xtalk_state == NAU8825_XTALK_DONE) {\n\t\tsnd_soc_jack_report(nau8825->jack, nau8825->xtalk_event,\n\t\t\t\tnau8825->xtalk_event_mask);\n\t\tnau8825_sema_release(nau8825);\n\t\tnau8825->xtalk_protect = false;\n\t}\n}\n\nstatic void nau8825_xtalk_cancel(struct nau8825 *nau8825)\n{\n\t \n\tif (nau8825->xtalk_enable && nau8825->xtalk_state !=\n\t\tNAU8825_XTALK_DONE) {\n\t\tcancel_work_sync(&nau8825->xtalk_work);\n\t\tnau8825_xtalk_clean(nau8825, true);\n\t}\n\t \n\tnau8825_sema_reset(nau8825);\n\tnau8825->xtalk_state = NAU8825_XTALK_DONE;\n\tnau8825->xtalk_protect = false;\n}\n\nstatic bool nau8825_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8825_REG_ENA_CTRL ... NAU8825_REG_FLL_VCO_RSV:\n\tcase NAU8825_REG_HSD_CTRL ... NAU8825_REG_JACK_DET_CTRL:\n\tcase NAU8825_REG_INTERRUPT_MASK ... NAU8825_REG_KEYDET_CTRL:\n\tcase NAU8825_REG_VDET_THRESHOLD_1 ... NAU8825_REG_DACR_CTRL:\n\tcase NAU8825_REG_ADC_DRC_KNEE_IP12 ... NAU8825_REG_ADC_DRC_ATKDCY:\n\tcase NAU8825_REG_DAC_DRC_KNEE_IP12 ... NAU8825_REG_DAC_DRC_ATKDCY:\n\tcase NAU8825_REG_IMM_MODE_CTRL ... NAU8825_REG_IMM_RMS_R:\n\tcase NAU8825_REG_CLASSG_CTRL ... NAU8825_REG_OPT_EFUSE_CTRL:\n\tcase NAU8825_REG_MISC_CTRL:\n\tcase NAU8825_REG_I2C_DEVICE_ID ... NAU8825_REG_FLL2_UPPER:\n\tcase NAU8825_REG_BIAS_ADJ:\n\tcase NAU8825_REG_TRIM_SETTINGS ... NAU8825_REG_ANALOG_CONTROL_2:\n\tcase NAU8825_REG_ANALOG_ADC_1 ... NAU8825_REG_MIC_BIAS:\n\tcase NAU8825_REG_BOOST ... NAU8825_REG_FEPGA:\n\tcase NAU8825_REG_POWER_UP_CONTROL ... NAU8825_REG_GENERAL_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\nstatic bool nau8825_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8825_REG_RESET ... NAU8825_REG_FLL_VCO_RSV:\n\tcase NAU8825_REG_HSD_CTRL ... NAU8825_REG_JACK_DET_CTRL:\n\tcase NAU8825_REG_INTERRUPT_MASK:\n\tcase NAU8825_REG_INT_CLR_KEY_STATUS ... NAU8825_REG_KEYDET_CTRL:\n\tcase NAU8825_REG_VDET_THRESHOLD_1 ... NAU8825_REG_DACR_CTRL:\n\tcase NAU8825_REG_ADC_DRC_KNEE_IP12 ... NAU8825_REG_ADC_DRC_ATKDCY:\n\tcase NAU8825_REG_DAC_DRC_KNEE_IP12 ... NAU8825_REG_DAC_DRC_ATKDCY:\n\tcase NAU8825_REG_IMM_MODE_CTRL:\n\tcase NAU8825_REG_CLASSG_CTRL ... NAU8825_REG_OPT_EFUSE_CTRL:\n\tcase NAU8825_REG_MISC_CTRL:\n\tcase NAU8825_REG_FLL2_LOWER ... NAU8825_REG_FLL2_UPPER:\n\tcase NAU8825_REG_BIAS_ADJ:\n\tcase NAU8825_REG_TRIM_SETTINGS ... NAU8825_REG_ANALOG_CONTROL_2:\n\tcase NAU8825_REG_ANALOG_ADC_1 ... NAU8825_REG_MIC_BIAS:\n\tcase NAU8825_REG_BOOST ... NAU8825_REG_FEPGA:\n\tcase NAU8825_REG_POWER_UP_CONTROL ... NAU8825_REG_CHARGE_PUMP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8825_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8825_REG_RESET:\n\tcase NAU8825_REG_IRQ_STATUS:\n\tcase NAU8825_REG_INT_CLR_KEY_STATUS:\n\tcase NAU8825_REG_IMM_RMS_L:\n\tcase NAU8825_REG_IMM_RMS_R:\n\tcase NAU8825_REG_I2C_DEVICE_ID:\n\tcase NAU8825_REG_SARDOUT_RAM_STATUS:\n\tcase NAU8825_REG_CHARGE_PUMP_INPUT_READ:\n\tcase NAU8825_REG_GENERAL_STATUS:\n\tcase NAU8825_REG_BIQ_CTRL ... NAU8825_REG_BIQ_COF10:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int nau8825_fepga_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FEPGA,\n\t\t\t\t   NAU8825_ACDC_CTRL_MASK,\n\t\t\t\t   NAU8825_ACDC_VREF_MICP | NAU8825_ACDC_VREF_MICN);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\n\t\t\t\t   NAU8825_DISCHRG_EN, NAU8825_DISCHRG_EN);\n\t\tmsleep(40);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\n\t\t\t\t   NAU8825_DISCHRG_EN, 0);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FEPGA,\n\t\t\t\t   NAU8825_ACDC_CTRL_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_adc_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(nau8825->adc_delay);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ENA_CTRL,\n\t\t\tNAU8825_ENABLE_ADC, NAU8825_ENABLE_ADC);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (!nau8825->irq)\n\t\t\tregmap_update_bits(nau8825->regmap,\n\t\t\t\tNAU8825_REG_ENA_CTRL, NAU8825_ENABLE_ADC, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_pump_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tmsleep(10);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\tNAU8825_JAMNODCLOW, NAU8825_JAMNODCLOW);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\tNAU8825_JAMNODCLOW, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_output_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\t\tNAU8825_BIAS_TESTDAC_EN, 0);\n\t\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL, 0);\n\t\telse\n\t\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\t\tNAU8825_BIAS_TESTDAC_EN, NAU8825_BIAS_TESTDAC_EN);\n\t\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\n\t\telse\n\t\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL, 0);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int system_clock_control(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *regmap = nau8825->regmap;\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tdev_dbg(nau8825->dev, \"system clock control : POWER OFF\\n\");\n\t\t \n\t\tif (nau8825_is_jack_inserted(regmap)) {\n\t\t\tnau8825_configure_sysclk(nau8825,\n\t\t\t\t\t\t NAU8825_CLK_INTERNAL, 0);\n\t\t} else {\n\t\t\tnau8825_configure_sysclk(nau8825, NAU8825_CLK_DIS, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_biq_coeff_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\n\tif (!component->regmap)\n\t\treturn -EINVAL;\n\n\tregmap_raw_read(component->regmap, NAU8825_REG_BIQ_COF1,\n\t\tucontrol->value.bytes.data, params->max);\n\treturn 0;\n}\n\nstatic int nau8825_biq_coeff_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\n\tvoid *data;\n\n\tif (!component->regmap)\n\t\treturn -EINVAL;\n\n\tdata = kmemdup(ucontrol->value.bytes.data,\n\t\tparams->max, GFP_KERNEL | GFP_DMA);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tregmap_update_bits(component->regmap, NAU8825_REG_BIQ_CTRL,\n\t\tNAU8825_BIQ_WRT_EN, 0);\n\tregmap_raw_write(component->regmap, NAU8825_REG_BIQ_COF1,\n\t\tdata, params->max);\n\tregmap_update_bits(component->regmap, NAU8825_REG_BIQ_CTRL,\n\t\tNAU8825_BIQ_WRT_EN, NAU8825_BIQ_WRT_EN);\n\n\tkfree(data);\n\treturn 0;\n}\n\nstatic const char * const nau8825_biq_path[] = {\n\t\"ADC\", \"DAC\"\n};\n\nstatic const struct soc_enum nau8825_biq_path_enum =\n\tSOC_ENUM_SINGLE(NAU8825_REG_BIQ_CTRL, NAU8825_BIQ_PATH_SFT,\n\t\tARRAY_SIZE(nau8825_biq_path), nau8825_biq_path);\n\nstatic const char * const nau8825_adc_decimation[] = {\n\t\"32\", \"64\", \"128\", \"256\"\n};\n\nstatic const struct soc_enum nau8825_adc_decimation_enum =\n\tSOC_ENUM_SINGLE(NAU8825_REG_ADC_RATE, NAU8825_ADC_SYNC_DOWN_SFT,\n\t\tARRAY_SIZE(nau8825_adc_decimation), nau8825_adc_decimation);\n\nstatic const char * const nau8825_dac_oversampl[] = {\n\t\"64\", \"256\", \"128\", \"\", \"32\"\n};\n\nstatic const struct soc_enum nau8825_dac_oversampl_enum =\n\tSOC_ENUM_SINGLE(NAU8825_REG_DAC_CTRL1, NAU8825_DAC_OVERSAMPLE_SFT,\n\t\tARRAY_SIZE(nau8825_dac_oversampl), nau8825_dac_oversampl);\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(adc_vol_tlv, -10300, 2400);\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(sidetone_vol_tlv, -4200, 0);\nstatic const DECLARE_TLV_DB_MINMAX(dac_vol_tlv, -5400, 0);\nstatic const DECLARE_TLV_DB_MINMAX(fepga_gain_tlv, -100, 3600);\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(crosstalk_vol_tlv, -9600, 2400);\n\nstatic const struct snd_kcontrol_new nau8825_controls[] = {\n\tSOC_SINGLE_TLV(\"Mic Volume\", NAU8825_REG_ADC_DGAIN_CTRL,\n\t\t0, 0xff, 0, adc_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Bypass Volume\", NAU8825_REG_ADC_DGAIN_CTRL,\n\t\t12, 8, 0x0f, 0, sidetone_vol_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Volume\", NAU8825_REG_HSVOL_CTRL,\n\t\t6, 0, 0x3f, 1, dac_vol_tlv),\n\tSOC_SINGLE_TLV(\"Frontend PGA Volume\", NAU8825_REG_POWER_UP_CONTROL,\n\t\t8, 37, 0, fepga_gain_tlv),\n\tSOC_DOUBLE_TLV(\"Headphone Crosstalk Volume\", NAU8825_REG_DAC_DGAIN_CTRL,\n\t\t0, 8, 0xff, 0, crosstalk_vol_tlv),\n\n\tSOC_ENUM(\"ADC Decimation Rate\", nau8825_adc_decimation_enum),\n\tSOC_ENUM(\"DAC Oversampling Rate\", nau8825_dac_oversampl_enum),\n\t \n\tSOC_ENUM(\"BIQ Path Select\", nau8825_biq_path_enum),\n\tSND_SOC_BYTES_EXT(\"BIQ Coefficients\", 20,\n\t\t  nau8825_biq_coeff_get, nau8825_biq_coeff_put),\n};\n\n \nstatic const char * const nau8825_dac_src[] = {\n\t\"DACL\", \"DACR\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tnau8825_dacl_enum, NAU8825_REG_DACL_CTRL,\n\tNAU8825_DACL_CH_SEL_SFT, nau8825_dac_src);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tnau8825_dacr_enum, NAU8825_REG_DACR_CTRL,\n\tNAU8825_DACR_CH_SEL_SFT, nau8825_dac_src);\n\nstatic const struct snd_kcontrol_new nau8825_dacl_mux =\n\tSOC_DAPM_ENUM(\"DACL Source\", nau8825_dacl_enum);\n\nstatic const struct snd_kcontrol_new nau8825_dacr_mux =\n\tSOC_DAPM_ENUM(\"DACR Source\", nau8825_dacr_enum);\n\n\nstatic const struct snd_soc_dapm_widget nau8825_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_OUT(\"AIFTX\", \"Capture\", 0, NAU8825_REG_I2S_PCM_CTRL2,\n\t\t15, 1),\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"System Clock\", SND_SOC_NOPM, 0, 0,\n\t\t\t    system_clock_control, SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_INPUT(\"MIC\"),\n\tSND_SOC_DAPM_MICBIAS(\"MICBIAS\", NAU8825_REG_MIC_BIAS, 8, 0),\n\n\tSND_SOC_DAPM_PGA_E(\"Frontend PGA\", NAU8825_REG_POWER_UP_CONTROL, 14, 0,\n\t\t\t   NULL, 0, nau8825_fepga_event, SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_ADC_E(\"ADC\", NULL, SND_SOC_NOPM, 0, 0,\n\t\tnau8825_adc_event, SND_SOC_DAPM_POST_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"ADC Clock\", NAU8825_REG_ENA_CTRL, 7, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC Power\", NAU8825_REG_ANALOG_ADC_2, 6, 0, NULL,\n\t\t0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"SAR\", NAU8825_REG_SAR_CTRL,\n\t\tNAU8825_SAR_ADC_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_S(\"ADACL\", 2, NAU8825_REG_RDAC, 12, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACR\", 2, NAU8825_REG_RDAC, 13, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACL Clock\", 3, NAU8825_REG_RDAC, 8, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"ADACR Clock\", 3, NAU8825_REG_RDAC, 9, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"DDACR\", NULL, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_DACR_SFT, 0),\n\tSND_SOC_DAPM_DAC(\"DDACL\", NULL, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_DACL_SFT, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DDAC Clock\", NAU8825_REG_ENA_CTRL, 6, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"DACL Mux\", SND_SOC_NOPM, 0, 0, &nau8825_dacl_mux),\n\tSND_SOC_DAPM_MUX(\"DACR Mux\", SND_SOC_NOPM, 0, 0, &nau8825_dacr_mux),\n\n\tSND_SOC_DAPM_PGA_S(\"HP amp L\", 0,\n\t\tNAU8825_REG_CLASSG_CTRL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"HP amp R\", 0,\n\t\tNAU8825_REG_CLASSG_CTRL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_S(\"Charge Pump\", 1, NAU8825_REG_CHARGE_PUMP, 5, 0,\n\t\tnau8825_pump_event, SND_SOC_DAPM_POST_PMU |\n\t\tSND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 1\", 4,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 1\", 4,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 2\", 5,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 2\", 5,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver R Stage 3\", 6,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"Output Driver L Stage 3\", 6,\n\t\tNAU8825_REG_POWER_UP_CONTROL, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_S(\"Output DACL\", 7,\n\t\tSND_SOC_NOPM, 0, 0, nau8825_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_S(\"Output DACR\", 7,\n\t\tSND_SOC_NOPM, 0, 0, nau8825_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\n\t \n\tSND_SOC_DAPM_PGA_S(\"HPOL Pulldown\", 8,\n\t\tNAU8825_REG_HSD_CTRL, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA_S(\"HPOR Pulldown\", 8,\n\t\tNAU8825_REG_HSD_CTRL, 1, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA_S(\"HP Boost Driver\", 9,\n\t\tNAU8825_REG_BOOST, 9, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_PGA_S(\"Class G\", 10,\n\t\tNAU8825_REG_CLASSG_CTRL, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route nau8825_dapm_routes[] = {\n\t{\"Frontend PGA\", NULL, \"MIC\"},\n\t{\"ADC\", NULL, \"Frontend PGA\"},\n\t{\"ADC\", NULL, \"ADC Clock\"},\n\t{\"ADC\", NULL, \"ADC Power\"},\n\t{\"AIFTX\", NULL, \"ADC\"},\n\t{\"AIFTX\", NULL, \"System Clock\"},\n\n\t{\"AIFRX\", NULL, \"System Clock\"},\n\t{\"DDACL\", NULL, \"AIFRX\"},\n\t{\"DDACR\", NULL, \"AIFRX\"},\n\t{\"DDACL\", NULL, \"DDAC Clock\"},\n\t{\"DDACR\", NULL, \"DDAC Clock\"},\n\t{\"DACL Mux\", \"DACL\", \"DDACL\"},\n\t{\"DACL Mux\", \"DACR\", \"DDACR\"},\n\t{\"DACR Mux\", \"DACL\", \"DDACL\"},\n\t{\"DACR Mux\", \"DACR\", \"DDACR\"},\n\t{\"HP amp L\", NULL, \"DACL Mux\"},\n\t{\"HP amp R\", NULL, \"DACR Mux\"},\n\t{\"Charge Pump\", NULL, \"HP amp L\"},\n\t{\"Charge Pump\", NULL, \"HP amp R\"},\n\t{\"ADACL\", NULL, \"Charge Pump\"},\n\t{\"ADACR\", NULL, \"Charge Pump\"},\n\t{\"ADACL Clock\", NULL, \"ADACL\"},\n\t{\"ADACR Clock\", NULL, \"ADACR\"},\n\t{\"Output Driver L Stage 1\", NULL, \"ADACL Clock\"},\n\t{\"Output Driver R Stage 1\", NULL, \"ADACR Clock\"},\n\t{\"Output Driver L Stage 2\", NULL, \"Output Driver L Stage 1\"},\n\t{\"Output Driver R Stage 2\", NULL, \"Output Driver R Stage 1\"},\n\t{\"Output Driver L Stage 3\", NULL, \"Output Driver L Stage 2\"},\n\t{\"Output Driver R Stage 3\", NULL, \"Output Driver R Stage 2\"},\n\t{\"Output DACL\", NULL, \"Output Driver L Stage 3\"},\n\t{\"Output DACR\", NULL, \"Output Driver R Stage 3\"},\n\t{\"HPOL Pulldown\", NULL, \"Output DACL\"},\n\t{\"HPOR Pulldown\", NULL, \"Output DACR\"},\n\t{\"HP Boost Driver\", NULL, \"HPOL Pulldown\"},\n\t{\"HP Boost Driver\", NULL, \"HPOR Pulldown\"},\n\t{\"Class G\", NULL, \"HP Boost Driver\"},\n\t{\"HPOL\", NULL, \"Class G\"},\n\t{\"HPOR\", NULL, \"Class G\"},\n};\n\nstatic const struct nau8825_osr_attr *\nnau8825_get_osr(struct nau8825 *nau8825, int stream)\n{\n\tunsigned int osr;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_read(nau8825->regmap,\n\t\t\t    NAU8825_REG_DAC_CTRL1, &osr);\n\t\tosr &= NAU8825_DAC_OVERSAMPLE_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_dac_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_dac_sel[osr];\n\t} else {\n\t\tregmap_read(nau8825->regmap,\n\t\t\t    NAU8825_REG_ADC_RATE, &osr);\n\t\tosr &= NAU8825_ADC_SYNC_DOWN_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_adc_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_adc_sel[osr];\n\t}\n}\n\nstatic int nau8825_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tconst struct nau8825_osr_attr *osr;\n\n\tosr = nau8825_get_osr(nau8825, substream->stream);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    0, CLK_DA_AD_MAX / osr->osr);\n}\n\nstatic int nau8825_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0, ctrl_val, bclk_fs, bclk_div;\n\tconst struct nau8825_osr_attr *osr;\n\tint err = -EINVAL;\n\n\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\n\t \n\tosr = nau8825_get_osr(nau8825, substream->stream);\n\tif (!osr || !osr->osr)\n\t\tgoto error;\n\tif (params_rate(params) * osr->osr > CLK_DA_AD_MAX)\n\t\tgoto error;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\tNAU8825_CLK_DAC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8825_CLK_DAC_SRC_SFT);\n\telse\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\tNAU8825_CLK_ADC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8825_CLK_ADC_SRC_SFT);\n\n\t \n\tregmap_read(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2, &ctrl_val);\n\tif (ctrl_val & NAU8825_I2S_MS_MASTER) {\n\t\t \n\t\tbclk_fs = snd_soc_params_to_bclk(params) / params_rate(params);\n\t\tif (bclk_fs <= 32)\n\t\t\tbclk_div = 2;\n\t\telse if (bclk_fs <= 64)\n\t\t\tbclk_div = 1;\n\t\telse if (bclk_fs <= 128)\n\t\t\tbclk_div = 0;\n\t\telse\n\t\t\tgoto error;\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\t\tNAU8825_I2S_LRC_DIV_MASK | NAU8825_I2S_BLK_DIV_MASK,\n\t\t\t((bclk_div + 1) << NAU8825_I2S_LRC_DIV_SFT) | bclk_div);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= NAU8825_I2S_DL_16;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= NAU8825_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= NAU8825_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len |= NAU8825_I2S_DL_32;\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL1,\n\t\tNAU8825_I2S_DL_MASK, val_len);\n\terr = 0;\n\n error:\n\t \n\tnau8825_sema_release(nau8825);\n\n\treturn err;\n}\n\nstatic int nau8825_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl1_val = 0, ctrl2_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl2_val |= NAU8825_I2S_MS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= NAU8825_I2S_BP_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= NAU8825_I2S_DF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= NAU8825_I2S_DF_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl1_val |= NAU8825_I2S_DF_RIGTH;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= NAU8825_I2S_DF_PCM_AB;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl1_val |= NAU8825_I2S_DF_PCM_AB;\n\t\tctrl1_val |= NAU8825_I2S_PCMB_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL1,\n\t\tNAU8825_I2S_DL_MASK | NAU8825_I2S_DF_MASK |\n\t\tNAU8825_I2S_BP_MASK | NAU8825_I2S_PCMB_MASK,\n\t\tctrl1_val);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\tNAU8825_I2S_MS_MASK, ctrl2_val);\n\n\t \n\tnau8825_sema_release(nau8825);\n\n\treturn 0;\n}\n\n \nstatic int nau8825_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl_val = 0, ctrl_offset = 0, value = 0, dac_s, adc_s;\n\n\tif (slots != 4 && slots != 8) {\n\t\tdev_err(nau8825->dev, \"Only support 4 or 8 slots!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (hweight_long((unsigned long) tx_mask) != 1 ||\n\t    hweight_long((unsigned long) rx_mask) != 2) {\n\t\tdev_err(nau8825->dev,\n\t\t\t\"The limitation is 1-channel for ADC, and 2-channel for DAC on TDM mode.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (((tx_mask & 0xf) && (tx_mask & 0xf0)) ||\n\t    ((rx_mask & 0xf) && (rx_mask & 0xf0)) ||\n\t    ((tx_mask & 0xf) && (rx_mask & 0xf0)) ||\n\t    ((rx_mask & 0xf) && (tx_mask & 0xf0))) {\n\t\tdev_err(nau8825->dev,\n\t\t\t\"Slot assignment of DAC and ADC need to set same interval.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rx_mask & 0xf0) {\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\t\t\t   NAU8825_I2S_PCM_TS_EN_MASK, NAU8825_I2S_PCM_TS_EN);\n\t\tregmap_read(nau8825->regmap, NAU8825_REG_I2S_PCM_CTRL1, &value);\n\t\tctrl_val |= NAU8825_TDM_OFFSET_EN;\n\t\tctrl_offset = 4 * slot_width;\n\t\tif (!(value & NAU8825_I2S_PCMB_MASK))\n\t\t\tctrl_offset += 1;\n\t\tdac_s = (rx_mask & 0xf0) >> 4;\n\t\tadc_s = fls((tx_mask & 0xf0) >> 4);\n\t} else {\n\t\tdac_s = rx_mask & 0xf;\n\t\tadc_s = fls(tx_mask & 0xf);\n\t}\n\n\tctrl_val |= NAU8825_TDM_MODE;\n\n\tswitch (dac_s) {\n\tcase 0x3:\n\t\tctrl_val |= 1 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tcase 0x5:\n\t\tctrl_val |= 2 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tcase 0x6:\n\t\tctrl_val |= 1 << NAU8825_TDM_DACL_RX_SFT;\n\t\tctrl_val |= 2 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tcase 0x9:\n\t\tctrl_val |= 3 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tcase 0xa:\n\t\tctrl_val |= 1 << NAU8825_TDM_DACL_RX_SFT;\n\t\tctrl_val |= 3 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tcase 0xc:\n\t\tctrl_val |= 2 << NAU8825_TDM_DACL_RX_SFT;\n\t\tctrl_val |= 3 << NAU8825_TDM_DACR_RX_SFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tctrl_val |= adc_s - 1;\n\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_TDM_CTRL,\n\t\t\t   NAU8825_TDM_MODE | NAU8825_TDM_OFFSET_EN |\n\t\t\t   NAU8825_TDM_DACL_RX_MASK | NAU8825_TDM_DACR_RX_MASK |\n\t\t\t   NAU8825_TDM_TX_MASK, ctrl_val);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_LEFT_TIME_SLOT,\n\t\t\t   NAU8825_TSLOT_L0_MASK, ctrl_offset);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops nau8825_dai_ops = {\n\t.startup\t= nau8825_dai_startup,\n\t.hw_params\t= nau8825_hw_params,\n\t.set_fmt\t= nau8825_set_dai_fmt,\n\t.set_tdm_slot\t= nau8825_set_tdm_slot,\n};\n\n#define NAU8825_RATES\tSNDRV_PCM_RATE_8000_192000\n#define NAU8825_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t\t\t | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver nau8825_dai = {\n\t.name = \"nau8825-hifi\",\n\t.playback = {\n\t\t.stream_name\t = \"Playback\",\n\t\t.channels_min\t = 1,\n\t\t.channels_max\t = 2,\n\t\t.rates\t\t = NAU8825_RATES,\n\t\t.formats\t = NAU8825_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name\t = \"Capture\",\n\t\t.channels_min\t = 1,\n\t\t.channels_max\t = 2,    \n\t\t.rates\t\t = NAU8825_RATES,\n\t\t.formats\t = NAU8825_FORMATS,\n\t},\n\t.ops = &nau8825_dai_ops,\n};\n\n \nint nau8825_enable_jack_detect(struct snd_soc_component *component,\n\t\t\t\tstruct snd_soc_jack *jack)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *regmap = nau8825->regmap;\n\n\tnau8825->jack = jack;\n\n\tif (!nau8825->jack) {\n\t\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t\t   NAU8825_HSD_AUTO_MODE | NAU8825_SPKR_DWN1R |\n\t\t\t\t   NAU8825_SPKR_DWN1L, 0);\n\t\treturn 0;\n\t}\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\tNAU8825_HSD_AUTO_MODE | NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L,\n\t\tNAU8825_HSD_AUTO_MODE | NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nau8825_enable_jack_detect);\n\n\nstatic bool nau8825_is_jack_inserted(struct regmap *regmap)\n{\n\tbool active_high, is_high;\n\tint status, jkdet;\n\n\tregmap_read(regmap, NAU8825_REG_JACK_DET_CTRL, &jkdet);\n\tactive_high = jkdet & NAU8825_JACK_POLARITY;\n\tregmap_read(regmap, NAU8825_REG_I2C_DEVICE_ID, &status);\n\tis_high = status & NAU8825_GPIO2JD1;\n\t \n\treturn active_high == is_high;\n}\n\nstatic void nau8825_restart_jack_detection(struct regmap *regmap)\n{\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_DET_RESTART, NAU8825_JACK_DET_RESTART);\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_DET_RESTART, 0);\n}\n\nstatic void nau8825_int_status_clear_all(struct regmap *regmap)\n{\n\tint active_irq, clear_irq, i;\n\n\t \n\tregmap_read(regmap, NAU8825_REG_IRQ_STATUS, &active_irq);\n\tfor (i = 0; i < NAU8825_REG_DATA_LEN; i++) {\n\t\tclear_irq = (0x1 << i);\n\t\tif (active_irq & clear_irq)\n\t\t\tregmap_write(regmap,\n\t\t\t\tNAU8825_REG_INT_CLR_KEY_STATUS, clear_irq);\n\t}\n}\n\nstatic void nau8825_eject_jack(struct nau8825 *nau8825)\n{\n\tstruct snd_soc_dapm_context *dapm = nau8825->dapm;\n\tstruct regmap *regmap = nau8825->regmap;\n\n\t \n\tnau8825_xtalk_cancel(nau8825);\n\n\tsnd_soc_dapm_disable_pin(dapm, \"SAR\");\n\tsnd_soc_dapm_disable_pin(dapm, \"MICBIAS\");\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\tNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2, 0);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 0xf, 0xf);\n\n\tsnd_soc_dapm_sync(dapm);\n\n\t \n\tnau8825_int_status_clear_all(regmap);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_DIS_CTRL,\n\t\tNAU8825_IRQ_EJECT_DIS | NAU8825_IRQ_INSERT_DIS,\n\t\tNAU8825_IRQ_EJECT_DIS);\n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_OUTPUT_EN | NAU8825_IRQ_EJECT_EN |\n\t\tNAU8825_IRQ_HEADSET_COMPLETE_EN | NAU8825_IRQ_INSERT_EN,\n\t\tNAU8825_IRQ_OUTPUT_EN | NAU8825_IRQ_EJECT_EN |\n\t\tNAU8825_IRQ_HEADSET_COMPLETE_EN);\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_DET_DB_BYPASS, NAU8825_JACK_DET_DB_BYPASS);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_ADC, 0);\n\n\t \n\tnau8825_configure_sysclk(nau8825, NAU8825_CLK_DIS, 0);\n}\n\n \nstatic void nau8825_setup_auto_irq(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_HSD_AUTO_MODE, NAU8825_HSD_AUTO_MODE);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_HEADSET_COMPLETE_EN | NAU8825_IRQ_EJECT_EN, 0);\n\n\t \n\tnau8825_configure_sysclk(nau8825, NAU8825_CLK_INTERNAL, 0);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\t   NAU8825_CLK_MCLK_SRC_MASK, 0);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_ENA_CTRL,\n\t\tNAU8825_ENABLE_ADC, NAU8825_ENABLE_ADC);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\tNAU8825_I2S_MS_MASK, NAU8825_I2S_MS_MASTER);\n\tregmap_update_bits(regmap, NAU8825_REG_I2S_PCM_CTRL2,\n\t\tNAU8825_I2S_MS_MASK, NAU8825_I2S_MS_SLAVE);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_DET_DB_BYPASS, 0);\n\n\t \n\tregmap_write(regmap, NAU8825_REG_INTERRUPT_DIS_CTRL, 0);\n\n\t \n\tnau8825_restart_jack_detection(regmap);\n}\n\nstatic int nau8825_button_decode(int value)\n{\n\tint buttons = 0;\n\n\t \n\tif (value & BIT(0))\n\t\tbuttons |= SND_JACK_BTN_0;\n\tif (value & BIT(1))\n\t\tbuttons |= SND_JACK_BTN_1;\n\tif (value & BIT(2))\n\t\tbuttons |= SND_JACK_BTN_2;\n\tif (value & BIT(3))\n\t\tbuttons |= SND_JACK_BTN_3;\n\tif (value & BIT(4))\n\t\tbuttons |= SND_JACK_BTN_4;\n\tif (value & BIT(5))\n\t\tbuttons |= SND_JACK_BTN_5;\n\n\treturn buttons;\n}\n\nstatic int nau8825_high_imped_detection(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\tstruct snd_soc_dapm_context *dapm = nau8825->dapm;\n\tunsigned int adc_mg1, adc_mg2;\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 | NAU8825_SPKR_DWN1R |\n\t\t\t   NAU8825_SPKR_DWN1L, NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2);\n\tregmap_update_bits(regmap, NAU8825_REG_ANALOG_CONTROL_1,\n\t\t\t   NAU8825_TESTDACIN_MASK, NAU8825_TESTDACIN_GND);\n\tregmap_write(regmap, NAU8825_REG_TRIM_SETTINGS, 0x6);\n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t   NAU8825_MICBIAS_LOWNOISE_MASK | NAU8825_MICBIAS_VOLTAGE_MASK,\n\t\t\t   NAU8825_MICBIAS_LOWNOISE_EN);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t   NAU8825_SAR_INPUT_MASK | NAU8825_SAR_TRACKING_GAIN_MASK |\n\t\t\t   NAU8825_SAR_HV_SEL_MASK | NAU8825_SAR_RES_SEL_MASK |\n\t\t\t   NAU8825_SAR_COMPARE_TIME_MASK | NAU8825_SAR_SAMPLING_TIME_MASK,\n\t\t\t   NAU8825_SAR_HV_SEL_VDDMIC | NAU8825_SAR_RES_SEL_70K);\n\n\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\tsnd_soc_dapm_force_enable_pin(dapm, \"SAR\");\n\tsnd_soc_dapm_sync(dapm);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 | NAU8825_SPKR_DWN1R |\n\t\t\t   NAU8825_SPKR_DWN1L, NAU8825_SPKR_ENGND2);\n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\t   NAU8825_MICBIAS_JKR2);\n\tregmap_read(regmap, NAU8825_REG_SARDOUT_RAM_STATUS, &adc_mg1);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2, 0);\n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 | NAU8825_SPKR_DWN1R |\n\t\t\t   NAU8825_SPKR_DWN1L, NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 |\n\t\t\t   NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L);\n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 | NAU8825_SPKR_DWN1R |\n\t\t\t   NAU8825_SPKR_DWN1L, NAU8825_SPKR_ENGND1);\n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\t   NAU8825_MICBIAS_JKSLV);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t   NAU8825_SAR_INPUT_MASK, NAU8825_SAR_INPUT_JKSLV);\n\tregmap_read(regmap, NAU8825_REG_SARDOUT_RAM_STATUS, &adc_mg2);\n\n\t \n\tsnd_soc_dapm_disable_pin(dapm, \"SAR\");\n\tsnd_soc_dapm_disable_pin(dapm, \"MICBIAS\");\n\tsnd_soc_dapm_sync(dapm);\n\n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_LOWNOISE_MASK |\n\t\t\t   NAU8825_MICBIAS_VOLTAGE_MASK, nau8825->micbias_voltage);\n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 | NAU8825_SPKR_DWN1R |\n\t\t\t   NAU8825_SPKR_DWN1L, NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2 |\n\t\t\t   NAU8825_SPKR_DWN1R | NAU8825_SPKR_DWN1L);\n\tregmap_update_bits(regmap, NAU8825_REG_ANALOG_CONTROL_1,\n\t\t\t   NAU8825_TESTDACIN_MASK, NAU8825_TESTDACIN_GND);\n\tregmap_write(regmap, NAU8825_REG_TRIM_SETTINGS, 0);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t   NAU8825_SAR_TRACKING_GAIN_MASK | NAU8825_SAR_HV_SEL_MASK,\n\t\t\t   nau8825->sar_voltage << NAU8825_SAR_TRACKING_GAIN_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t   NAU8825_SAR_COMPARE_TIME_MASK | NAU8825_SAR_SAMPLING_TIME_MASK,\n\t\t\t   (nau8825->sar_compare_time << NAU8825_SAR_COMPARE_TIME_SFT) |\n\t\t\t   (nau8825->sar_sampling_time << NAU8825_SAR_SAMPLING_TIME_SFT));\n\tdev_dbg(nau8825->dev, \"adc_mg1:%x, adc_mg2:%x\\n\", adc_mg1, adc_mg2);\n\n\t \n\tif (adc_mg1 > adc_mg2) {\n\t\tdev_dbg(nau8825->dev, \"OMTP (micgnd1) mic connected\\n\");\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2,\n\t\t\t\t   NAU8825_SPKR_ENGND2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\t\t   NAU8825_MICBIAS_JKR2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t\t   NAU8825_SAR_INPUT_MASK,\n\t\t\t\t   NAU8825_SAR_INPUT_JKR2);\n\t} else if (adc_mg1 < adc_mg2) {\n\t\tdev_dbg(nau8825->dev, \"CTIA (micgnd2) mic connected\\n\");\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL,\n\t\t\t\t   NAU8825_SPKR_ENGND1 | NAU8825_SPKR_ENGND2,\n\t\t\t\t   NAU8825_SPKR_ENGND1);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\t\t   NAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\t\t   NAU8825_MICBIAS_JKSLV);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\t\t   NAU8825_SAR_INPUT_MASK,\n\t\t\t\t   NAU8825_SAR_INPUT_JKSLV);\n\t} else {\n\t\tdev_err(nau8825->dev, \"Jack broken.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_jack_insert(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\tstruct snd_soc_dapm_context *dapm = nau8825->dapm;\n\tint jack_status_reg, mic_detected;\n\tint type = 0;\n\n\tregmap_read(regmap, NAU8825_REG_GENERAL_STATUS, &jack_status_reg);\n\tmic_detected = (jack_status_reg >> 10) & 3;\n\t \n\tif (mic_detected == 0x3)\n\t\tnau8825->high_imped = true;\n\telse\n\t\tnau8825->high_imped = false;\n\n\tswitch (mic_detected) {\n\tcase 0:\n\t\t \n\t\ttype = SND_JACK_HEADPHONE;\n\t\tbreak;\n\tcase 1:\n\t\tdev_dbg(nau8825->dev, \"OMTP (micgnd1) mic connected\\n\");\n\t\ttype = SND_JACK_HEADSET;\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 3 << 2,\n\t\t\t1 << 2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\tNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\tNAU8825_MICBIAS_JKR2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\tNAU8825_SAR_INPUT_MASK,\n\t\t\tNAU8825_SAR_INPUT_JKR2);\n\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"SAR\");\n\t\tsnd_soc_dapm_sync(dapm);\n\t\tbreak;\n\tcase 2:\n\t\tdev_dbg(nau8825->dev, \"CTIA (micgnd2) mic connected\\n\");\n\t\ttype = SND_JACK_HEADSET;\n\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, 3 << 2,\n\t\t\t2 << 2);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\t\tNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2,\n\t\t\tNAU8825_MICBIAS_JKSLV);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\t\tNAU8825_SAR_INPUT_MASK,\n\t\t\tNAU8825_SAR_INPUT_JKSLV);\n\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"SAR\");\n\t\tsnd_soc_dapm_sync(dapm);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tdev_warn(nau8825->dev,\n\t\t\t \"Detection failure. Try the manually mechanism for jack type checking.\\n\");\n\t\tif (!nau8825_high_imped_detection(nau8825)) {\n\t\t\ttype = SND_JACK_HEADSET;\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\t\t\tsnd_soc_dapm_force_enable_pin(dapm, \"SAR\");\n\t\t\tsnd_soc_dapm_sync(dapm);\n\t\t} else\n\t\t\ttype = SND_JACK_HEADPHONE;\n\t\tbreak;\n\t}\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\t   NAU8825_CLK_MCLK_SRC_MASK, 0xf);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_HSD_CTRL, NAU8825_HSD_AUTO_MODE, 0);\n\n\t \n\treturn type;\n}\n\n#define NAU8825_BUTTONS (SND_JACK_BTN_0 | SND_JACK_BTN_1 | \\\n\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3)\n\nstatic irqreturn_t nau8825_interrupt(int irq, void *data)\n{\n\tstruct nau8825 *nau8825 = (struct nau8825 *)data;\n\tstruct regmap *regmap = nau8825->regmap;\n\tint active_irq, clear_irq = 0, event = 0, event_mask = 0;\n\n\tif (regmap_read(regmap, NAU8825_REG_IRQ_STATUS, &active_irq)) {\n\t\tdev_err(nau8825->dev, \"failed to read irq status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif ((active_irq & NAU8825_JACK_EJECTION_IRQ_MASK) ==\n\t\tNAU8825_JACK_EJECTION_DETECTED) {\n\n\t\tnau8825_eject_jack(nau8825);\n\t\tevent_mask |= SND_JACK_HEADSET;\n\t\tclear_irq = NAU8825_JACK_EJECTION_IRQ_MASK;\n\t} else if (active_irq & NAU8825_KEY_SHORT_PRESS_IRQ) {\n\t\tint key_status;\n\n\t\tregmap_read(regmap, NAU8825_REG_INT_CLR_KEY_STATUS,\n\t\t\t&key_status);\n\n\t\t \n\t\tnau8825->button_pressed = nau8825_button_decode(\n\t\t\tkey_status >> 8);\n\n\t\tevent |= nau8825->button_pressed;\n\t\tevent_mask |= NAU8825_BUTTONS;\n\t\tclear_irq = NAU8825_KEY_SHORT_PRESS_IRQ;\n\t} else if (active_irq & NAU8825_KEY_RELEASE_IRQ) {\n\t\tevent_mask = NAU8825_BUTTONS;\n\t\tclear_irq = NAU8825_KEY_RELEASE_IRQ;\n\t} else if (active_irq & NAU8825_HEADSET_COMPLETION_IRQ) {\n\t\tif (nau8825_is_jack_inserted(regmap)) {\n\t\t\tevent |= nau8825_jack_insert(nau8825);\n\t\t\tif (nau8825->xtalk_enable && !nau8825->high_imped) {\n\t\t\t\t \n\t\t\t\tif (!nau8825->xtalk_protect) {\n\t\t\t\t\t \n\t\t\t\t\tint ret;\n\t\t\t\t\tnau8825->xtalk_protect = true;\n\t\t\t\t\tret = nau8825_sema_acquire(nau8825, 0);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tnau8825->xtalk_protect = false;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (nau8825->xtalk_protect) {\n\t\t\t\t\tnau8825->xtalk_state =\n\t\t\t\t\t\tNAU8825_XTALK_PREPARE;\n\t\t\t\t\tschedule_work(&nau8825->xtalk_work);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (nau8825->xtalk_protect) {\n\t\t\t\t\tnau8825_sema_release(nau8825);\n\t\t\t\t\tnau8825->xtalk_protect = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(nau8825->dev, \"Headset completion IRQ fired but no headset connected\\n\");\n\t\t\tnau8825_eject_jack(nau8825);\n\t\t}\n\n\t\tevent_mask |= SND_JACK_HEADSET;\n\t\tclear_irq = NAU8825_HEADSET_COMPLETION_IRQ;\n\t\t \n\t\tif (nau8825->xtalk_state == NAU8825_XTALK_PREPARE) {\n\t\t\tnau8825->xtalk_event = event;\n\t\t\tnau8825->xtalk_event_mask = event_mask;\n\t\t}\n\t} else if (active_irq & NAU8825_IMPEDANCE_MEAS_IRQ) {\n\t\t \n\t\tif (nau8825->xtalk_enable && nau8825->xtalk_protect)\n\t\t\tschedule_work(&nau8825->xtalk_work);\n\t\tclear_irq = NAU8825_IMPEDANCE_MEAS_IRQ;\n\t} else if ((active_irq & NAU8825_JACK_INSERTION_IRQ_MASK) ==\n\t\tNAU8825_JACK_INSERTION_DETECTED) {\n\t\t \n\t\tif (nau8825_is_jack_inserted(regmap)) {\n\t\t\t \n\t\t\tregmap_update_bits(regmap,\n\t\t\t\tNAU8825_REG_INTERRUPT_DIS_CTRL,\n\t\t\t\tNAU8825_IRQ_INSERT_DIS,\n\t\t\t\tNAU8825_IRQ_INSERT_DIS);\n\t\t\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\t\t\tNAU8825_IRQ_INSERT_EN, NAU8825_IRQ_INSERT_EN);\n\t\t\t \n\t\t\tnau8825_setup_auto_irq(nau8825);\n\t\t}\n\t}\n\n\tif (!clear_irq)\n\t\tclear_irq = active_irq;\n\t \n\tregmap_write(regmap, NAU8825_REG_INT_CLR_KEY_STATUS, clear_irq);\n\n\t \n\tif (event_mask && nau8825->xtalk_state == NAU8825_XTALK_DONE)\n\t\tsnd_soc_jack_report(nau8825->jack, event, event_mask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void nau8825_setup_buttons(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\tNAU8825_SAR_TRACKING_GAIN_MASK,\n\t\tnau8825->sar_voltage << NAU8825_SAR_TRACKING_GAIN_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\tNAU8825_SAR_COMPARE_TIME_MASK,\n\t\tnau8825->sar_compare_time << NAU8825_SAR_COMPARE_TIME_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_SAR_CTRL,\n\t\tNAU8825_SAR_SAMPLING_TIME_MASK,\n\t\tnau8825->sar_sampling_time << NAU8825_SAR_SAMPLING_TIME_SFT);\n\n\tregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\n\t\tNAU8825_KEYDET_LEVELS_NR_MASK,\n\t\t(nau8825->sar_threshold_num - 1) << NAU8825_KEYDET_LEVELS_NR_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\n\t\tNAU8825_KEYDET_HYSTERESIS_MASK,\n\t\tnau8825->sar_hysteresis << NAU8825_KEYDET_HYSTERESIS_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_KEYDET_CTRL,\n\t\tNAU8825_KEYDET_SHORTKEY_DEBOUNCE_MASK,\n\t\tnau8825->key_debounce << NAU8825_KEYDET_SHORTKEY_DEBOUNCE_SFT);\n\n\tregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_1,\n\t\t(nau8825->sar_threshold[0] << 8) | nau8825->sar_threshold[1]);\n\tregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_2,\n\t\t(nau8825->sar_threshold[2] << 8) | nau8825->sar_threshold[3]);\n\tregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_3,\n\t\t(nau8825->sar_threshold[4] << 8) | nau8825->sar_threshold[5]);\n\tregmap_write(regmap, NAU8825_REG_VDET_THRESHOLD_4,\n\t\t(nau8825->sar_threshold[6] << 8) | nau8825->sar_threshold[7]);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_KEY_SHORT_PRESS_EN | NAU8825_IRQ_KEY_RELEASE_EN,\n\t\t0);\n}\n\nstatic void nau8825_init_regs(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\n\t \n\tregmap_write(regmap, NAU8825_REG_IIC_ADDR_SET, 0x0001);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\tNAU8825_BIAS_VMID, NAU8825_BIAS_VMID);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BOOST,\n\t\tNAU8825_GLOBAL_BIAS_EN, NAU8825_GLOBAL_BIAS_EN);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_BIAS_ADJ,\n\t\tNAU8825_BIAS_VMID_SEL_MASK,\n\t\tnau8825->vref_impedance << NAU8825_BIAS_VMID_SEL_SFT);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_BOOST,\n\t\tNAU8825_PRECHARGE_DIS | NAU8825_HP_BOOST_DIS |\n\t\tNAU8825_HP_BOOST_G_DIS | NAU8825_SHORT_SHUTDOWN_EN,\n\t\tNAU8825_PRECHARGE_DIS | NAU8825_HP_BOOST_DIS |\n\t\tNAU8825_HP_BOOST_G_DIS | NAU8825_SHORT_SHUTDOWN_EN);\n\n\tregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\n\t\tNAU8825_JKDET_OUTPUT_EN,\n\t\tnau8825->jkdet_enable ? 0 : NAU8825_JKDET_OUTPUT_EN);\n\tregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\n\t\tNAU8825_JKDET_PULL_EN,\n\t\tnau8825->jkdet_pull_enable ? 0 : NAU8825_JKDET_PULL_EN);\n\tregmap_update_bits(regmap, NAU8825_REG_GPIO12_CTRL,\n\t\tNAU8825_JKDET_PULL_UP,\n\t\tnau8825->jkdet_pull_up ? NAU8825_JKDET_PULL_UP : 0);\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_POLARITY,\n\t\t \n\t\tnau8825->jkdet_polarity ? 0 : NAU8825_JACK_POLARITY);\n\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_INSERT_DEBOUNCE_MASK,\n\t\tnau8825->jack_insert_debounce << NAU8825_JACK_INSERT_DEBOUNCE_SFT);\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_EJECT_DEBOUNCE_MASK,\n\t\tnau8825->jack_eject_debounce << NAU8825_JACK_EJECT_DEBOUNCE_SFT);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_PIN_PULLUP | NAU8825_IRQ_PIN_PULL_EN,\n\t\tNAU8825_IRQ_PIN_PULLUP | NAU8825_IRQ_PIN_PULL_EN);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK, 0x7ff, 0x7ff);\n\n\tregmap_update_bits(regmap, NAU8825_REG_MIC_BIAS,\n\t\tNAU8825_MICBIAS_VOLTAGE_MASK, nau8825->micbias_voltage);\n\n\tif (nau8825->sar_threshold_num)\n\t\tnau8825_setup_buttons(nau8825);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_ADC_RATE,\n\t\tNAU8825_ADC_SYNC_DOWN_MASK | NAU8825_ADC_SINC4_EN,\n\t\tNAU8825_ADC_SYNC_DOWN_64);\n\tregmap_update_bits(regmap, NAU8825_REG_DAC_CTRL1,\n\t\tNAU8825_DAC_OVERSAMPLE_MASK, NAU8825_DAC_OVERSAMPLE_64);\n\t \n\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\tregmap_update_bits(regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL,\n\t\t\t\t   NAU8825_POWER_DOWN_DACR | NAU8825_POWER_DOWN_DACL);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_BIAS_ADJ,\n\t\tNAU8825_BIAS_TESTDAC_EN, NAU8825_BIAS_TESTDAC_EN);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_DAC_CTRL1,\n\t\tNAU8825_DAC_CLIP_OFF, NAU8825_DAC_CLIP_OFF);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_ANALOG_CONTROL_2,\n\t\tNAU8825_HP_NON_CLASSG_CURRENT_2xADJ |\n\t\tNAU8825_DAC_CAPACITOR_MSB | NAU8825_DAC_CAPACITOR_LSB,\n\t\tNAU8825_HP_NON_CLASSG_CURRENT_2xADJ |\n\t\tNAU8825_DAC_CAPACITOR_MSB | NAU8825_DAC_CAPACITOR_LSB);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_CLASSG_CTRL,\n\t\tNAU8825_CLASSG_TIMER_MASK,\n\t\t0x20 << NAU8825_CLASSG_TIMER_SFT);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_RDAC,\n\t\tNAU8825_RDAC_CLK_DELAY_MASK | NAU8825_RDAC_VREF_MASK,\n\t\t(0x2 << NAU8825_RDAC_CLK_DELAY_SFT) |\n\t\t(0x3 << NAU8825_RDAC_VREF_SFT));\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_DACL_CTRL,\n\t\tNAU8825_DACL_CH_SEL_MASK, NAU8825_DACL_CH_SEL_L);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_DACR_CTRL,\n\t\tNAU8825_DACL_CH_SEL_MASK, NAU8825_DACL_CH_SEL_R);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_LEFT_TIME_SLOT,\n\t\tNAU8825_DIS_FS_SHORT_DET, NAU8825_DIS_FS_SHORT_DET);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_CHARGE_PUMP,\n\t\t\t   NAU8825_ADCOUT_DS_MASK,\n\t\t\t   nau8825->adcout_ds << NAU8825_ADCOUT_DS_SFT);\n}\n\nstatic const struct regmap_config nau8825_regmap_config = {\n\t.val_bits = NAU8825_REG_DATA_LEN,\n\t.reg_bits = NAU8825_REG_ADDR_LEN,\n\n\t.max_register = NAU8825_REG_MAX,\n\t.readable_reg = nau8825_readable_reg,\n\t.writeable_reg = nau8825_writeable_reg,\n\t.volatile_reg = nau8825_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8825_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8825_reg_defaults),\n};\n\nstatic int nau8825_component_probe(struct snd_soc_component *component)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tnau8825->dapm = dapm;\n\n\treturn 0;\n}\n\nstatic void nau8825_component_remove(struct snd_soc_component *component)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\t \n\tnau8825_xtalk_cancel(nau8825);\n}\n\n \nstatic int nau8825_calc_fll_param(unsigned int fll_in, unsigned int fs,\n\t\tstruct nau8825_fll *fll_param)\n{\n\tu64 fvco, fvco_max;\n\tunsigned int fref, i, fvco_sel;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_pre_scalar); i++) {\n\t\tfref = fll_in / fll_pre_scalar[i].param;\n\t\tif (fref <= NAU_FREF_MAX)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_pre_scalar))\n\t\treturn -EINVAL;\n\tfll_param->clk_ref_div = fll_pre_scalar[i].val;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_ratio); i++) {\n\t\tif (fref >= fll_ratio[i].param)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_ratio))\n\t\treturn -EINVAL;\n\tfll_param->ratio = fll_ratio[i].val;\n\n\t \n\tfvco_max = 0;\n\tfvco_sel = ARRAY_SIZE(mclk_src_scaling);\n\tfor (i = 0; i < ARRAY_SIZE(mclk_src_scaling); i++) {\n\t\tfvco = 256ULL * fs * 2 * mclk_src_scaling[i].param;\n\t\tif (fvco > NAU_FVCO_MIN && fvco < NAU_FVCO_MAX &&\n\t\t\tfvco_max < fvco) {\n\t\t\tfvco_max = fvco;\n\t\t\tfvco_sel = i;\n\t\t}\n\t}\n\tif (ARRAY_SIZE(mclk_src_scaling) == fvco_sel)\n\t\treturn -EINVAL;\n\tfll_param->mclk_src = mclk_src_scaling[fvco_sel].val;\n\n\t \n\tfvco = div_u64(fvco_max << fll_param->fll_frac_num, fref * fll_param->ratio);\n\tfll_param->fll_int = (fvco >> fll_param->fll_frac_num) & 0x3FF;\n\tif (fll_param->fll_frac_num == 16)\n\t\tfll_param->fll_frac = fvco & 0xFFFF;\n\telse\n\t\tfll_param->fll_frac = fvco & 0xFFFFFF;\n\treturn 0;\n}\n\nstatic void nau8825_fll_apply(struct nau8825 *nau8825,\n\t\tstruct nau8825_fll *fll_param)\n{\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\tNAU8825_CLK_SRC_MASK | NAU8825_CLK_MCLK_SRC_MASK,\n\t\tNAU8825_CLK_SRC_MCLK | fll_param->mclk_src);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL1,\n\t\tNAU8825_FLL_RATIO_MASK | NAU8825_ICTRL_LATCH_MASK,\n\t\tfll_param->ratio | (0x6 << NAU8825_ICTRL_LATCH_SFT));\n\t \n\tif (fll_param->fll_frac_num == 16)\n\t\tregmap_write(nau8825->regmap, NAU8825_REG_FLL2,\n\t\t\t     fll_param->fll_frac);\n\telse {\n\t\tregmap_write(nau8825->regmap, NAU8825_REG_FLL2_LOWER,\n\t\t\t     fll_param->fll_frac & 0xffff);\n\t\tregmap_write(nau8825->regmap, NAU8825_REG_FLL2_UPPER,\n\t\t\t     (fll_param->fll_frac >> 16) & 0xff);\n\t}\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL3,\n\t\t\tNAU8825_FLL_INTEGER_MASK, fll_param->fll_int);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL4,\n\t\t\tNAU8825_FLL_REF_DIV_MASK,\n\t\t\tfll_param->clk_ref_div << NAU8825_FLL_REF_DIV_SFT);\n\t \n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL5,\n\t\tNAU8825_FLL_CLK_SW_MASK, NAU8825_FLL_CLK_SW_REF);\n\t \n\tregmap_update_bits(nau8825->regmap,\n\t\tNAU8825_REG_FLL6, NAU8825_DCO_EN, 0);\n\tif (fll_param->fll_frac) {\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL5,\n\t\t\tNAU8825_FLL_PDB_DAC_EN | NAU8825_FLL_LOOP_FTR_EN |\n\t\t\tNAU8825_FLL_FTR_SW_MASK,\n\t\t\tNAU8825_FLL_PDB_DAC_EN | NAU8825_FLL_LOOP_FTR_EN |\n\t\t\tNAU8825_FLL_FTR_SW_FILTER);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL6,\n\t\t\tNAU8825_SDM_EN | NAU8825_CUTOFF500,\n\t\t\tNAU8825_SDM_EN | NAU8825_CUTOFF500);\n\t} else {\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL5,\n\t\t\tNAU8825_FLL_PDB_DAC_EN | NAU8825_FLL_LOOP_FTR_EN |\n\t\t\tNAU8825_FLL_FTR_SW_MASK, NAU8825_FLL_FTR_SW_ACCU);\n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_FLL6,\n\t\t\tNAU8825_SDM_EN | NAU8825_CUTOFF500, 0);\n\t}\n}\n\n \nstatic int nau8825_set_pll(struct snd_soc_component *component, int pll_id, int source,\n\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tstruct nau8825_fll fll_param;\n\tint ret, fs;\n\n\tif (nau8825->sw_id == NAU8825_SOFTWARE_ID_NAU8825)\n\t\tfll_param.fll_frac_num = 16;\n\telse\n\t\tfll_param.fll_frac_num = 24;\n\n\tfs = freq_out / 256;\n\tret = nau8825_calc_fll_param(freq_in, fs, &fll_param);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\tdev_dbg(component->dev, \"mclk_src=%x ratio=%x fll_frac=%x fll_int=%x clk_ref_div=%x\\n\",\n\t\tfll_param.mclk_src, fll_param.ratio, fll_param.fll_frac,\n\t\tfll_param.fll_int, fll_param.clk_ref_div);\n\n\tnau8825_fll_apply(nau8825, &fll_param);\n\tmdelay(2);\n\tregmap_update_bits(nau8825->regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\tNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_VCO);\n\treturn 0;\n}\n\nstatic int nau8825_mclk_prepare(struct nau8825 *nau8825, unsigned int freq)\n{\n\tint ret;\n\n\tnau8825->mclk = devm_clk_get(nau8825->dev, \"mclk\");\n\tif (IS_ERR(nau8825->mclk)) {\n\t\tdev_info(nau8825->dev, \"No 'mclk' clock found, assume MCLK is managed externally\");\n\t\treturn 0;\n\t}\n\n\tif (!nau8825->mclk_freq) {\n\t\tret = clk_prepare_enable(nau8825->mclk);\n\t\tif (ret) {\n\t\t\tdev_err(nau8825->dev, \"Unable to prepare codec mclk\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (nau8825->mclk_freq != freq) {\n\t\tfreq = clk_round_rate(nau8825->mclk, freq);\n\t\tret = clk_set_rate(nau8825->mclk, freq);\n\t\tif (ret) {\n\t\t\tdev_err(nau8825->dev, \"Unable to set mclk rate\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tnau8825->mclk_freq = freq;\n\t}\n\n\treturn 0;\n}\n\nstatic void nau8825_configure_mclk_as_sysclk(struct regmap *regmap)\n{\n\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\tNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_MCLK);\n\tregmap_update_bits(regmap, NAU8825_REG_FLL6,\n\t\tNAU8825_DCO_EN, 0);\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_FLL1,\n\t\tNAU8825_ICTRL_LATCH_MASK, 0);\n}\n\nstatic int nau8825_configure_sysclk(struct nau8825 *nau8825, int clk_id,\n\tunsigned int freq)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\tint ret;\n\n\tswitch (clk_id) {\n\tcase NAU8825_CLK_DIS:\n\t\t \n\t\tnau8825_configure_mclk_as_sysclk(regmap);\n\t\tif (nau8825->mclk_freq) {\n\t\t\tclk_disable_unprepare(nau8825->mclk);\n\t\t\tnau8825->mclk_freq = 0;\n\t\t}\n\n\t\tbreak;\n\tcase NAU8825_CLK_MCLK:\n\t\t \n\t\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\t\tnau8825_configure_mclk_as_sysclk(regmap);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\tNAU8825_CLK_MCLK_SRC_MASK, 0);\n\t\t \n\t\tnau8825_sema_release(nau8825);\n\n\t\tret = nau8825_mclk_prepare(nau8825, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase NAU8825_CLK_INTERNAL:\n\t\tif (nau8825_is_jack_inserted(nau8825->regmap)) {\n\t\t\tregmap_update_bits(regmap, NAU8825_REG_FLL6,\n\t\t\t\tNAU8825_DCO_EN, NAU8825_DCO_EN);\n\t\t\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\t\tNAU8825_CLK_SRC_MASK, NAU8825_CLK_SRC_VCO);\n\t\t\t \n\t\t\tregmap_update_bits(regmap, NAU8825_REG_CLK_DIVIDER,\n\t\t\t\tNAU8825_CLK_MCLK_SRC_MASK, 0xf);\n\t\t\tregmap_update_bits(regmap, NAU8825_REG_FLL1,\n\t\t\t\tNAU8825_ICTRL_LATCH_MASK |\n\t\t\t\tNAU8825_FLL_RATIO_MASK, 0x10);\n\t\t\tregmap_update_bits(regmap, NAU8825_REG_FLL6,\n\t\t\t\tNAU8825_SDM_EN, NAU8825_SDM_EN);\n\t\t} else {\n\t\t\t \n\t\t\tnau8825_configure_mclk_as_sysclk(regmap);\n\t\t\tdev_warn(nau8825->dev, \"Disable clock for power saving when no headset connected\\n\");\n\t\t}\n\t\tif (nau8825->mclk_freq) {\n\t\t\tclk_disable_unprepare(nau8825->mclk);\n\t\t\tnau8825->mclk_freq = 0;\n\t\t}\n\n\t\tbreak;\n\tcase NAU8825_CLK_FLL_MCLK:\n\t\t \n\t\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_FLL3,\n\t\t\tNAU8825_FLL_CLK_SRC_MASK | NAU8825_GAIN_ERR_MASK,\n\t\t\tNAU8825_FLL_CLK_SRC_MCLK | 0);\n\t\t \n\t\tnau8825_sema_release(nau8825);\n\n\t\tret = nau8825_mclk_prepare(nau8825, freq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase NAU8825_CLK_FLL_BLK:\n\t\t \n\t\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_FLL3,\n\t\t\tNAU8825_FLL_CLK_SRC_MASK | NAU8825_GAIN_ERR_MASK,\n\t\t\tNAU8825_FLL_CLK_SRC_BLK |\n\t\t\t(0xf << NAU8825_GAIN_ERR_SFT));\n\t\t \n\t\tnau8825_sema_release(nau8825);\n\n\t\tif (nau8825->mclk_freq) {\n\t\t\tclk_disable_unprepare(nau8825->mclk);\n\t\t\tnau8825->mclk_freq = 0;\n\t\t}\n\n\t\tbreak;\n\tcase NAU8825_CLK_FLL_FS:\n\t\t \n\t\tnau8825_sema_acquire(nau8825, 3 * HZ);\n\t\t \n\t\tregmap_update_bits(regmap, NAU8825_REG_FLL3,\n\t\t\tNAU8825_FLL_CLK_SRC_MASK | NAU8825_GAIN_ERR_MASK,\n\t\t\tNAU8825_FLL_CLK_SRC_FS |\n\t\t\t(0xf << NAU8825_GAIN_ERR_SFT));\n\t\t \n\t\tnau8825_sema_release(nau8825);\n\n\t\tif (nau8825->mclk_freq) {\n\t\t\tclk_disable_unprepare(nau8825->mclk);\n\t\t\tnau8825->mclk_freq = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(nau8825->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(nau8825->dev, \"Sysclk is %dHz and clock id is %d\\n\", freq,\n\t\tclk_id);\n\treturn 0;\n}\n\nstatic int nau8825_set_sysclk(struct snd_soc_component *component, int clk_id,\n\tint source, unsigned int freq, int dir)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\treturn nau8825_configure_sysclk(nau8825, clk_id, freq);\n}\n\nstatic int nau8825_resume_setup(struct nau8825 *nau8825)\n{\n\tstruct regmap *regmap = nau8825->regmap;\n\n\t \n\tnau8825_configure_sysclk(nau8825, NAU8825_CLK_DIS, 0);\n\n\t \n\tnau8825_int_status_clear_all(regmap);\n\n\t \n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_MASK,\n\t\tNAU8825_IRQ_OUTPUT_EN | NAU8825_IRQ_HEADSET_COMPLETE_EN |\n\t\tNAU8825_IRQ_EJECT_EN | NAU8825_IRQ_INSERT_EN,\n\t\tNAU8825_IRQ_OUTPUT_EN | NAU8825_IRQ_HEADSET_COMPLETE_EN);\n\tregmap_update_bits(regmap, NAU8825_REG_JACK_DET_CTRL,\n\t\tNAU8825_JACK_DET_DB_BYPASS, NAU8825_JACK_DET_DB_BYPASS);\n\tregmap_update_bits(regmap, NAU8825_REG_INTERRUPT_DIS_CTRL,\n\t\tNAU8825_IRQ_INSERT_DIS | NAU8825_IRQ_EJECT_DIS, 0);\n\n\treturn 0;\n}\n\nstatic int nau8825_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t   enum snd_soc_bias_level level)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tif (nau8825->mclk_freq) {\n\t\t\t\tret = clk_prepare_enable(nau8825->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(nau8825->dev, \"Unable to prepare component mclk\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tnau8825_resume_setup(nau8825);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_MIC_BIAS,\n\t\t\tNAU8825_MICBIAS_JKSLV | NAU8825_MICBIAS_JKR2, 0);\n\t\t \n\t\tregmap_update_bits(nau8825->regmap,\n\t\t\tNAU8825_REG_HSD_CTRL, 0xf, 0xf);\n\t\t \n\t\tnau8825_xtalk_cancel(nau8825);\n\t\t \n\t\tregmap_write(nau8825->regmap,\n\t\t\tNAU8825_REG_INTERRUPT_DIS_CTRL, 0xffff);\n\t\t \n\t\tregmap_update_bits(nau8825->regmap, NAU8825_REG_ENA_CTRL,\n\t\t\tNAU8825_ENABLE_ADC, 0);\n\t\tif (nau8825->mclk_freq)\n\t\t\tclk_disable_unprepare(nau8825->mclk);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8825_suspend(struct snd_soc_component *component)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\n\tdisable_irq(nau8825->irq);\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\t \n\tsnd_soc_dapm_disable_pin(nau8825->dapm, \"SAR\");\n\tsnd_soc_dapm_disable_pin(nau8825->dapm, \"MICBIAS\");\n\tsnd_soc_dapm_sync(nau8825->dapm);\n\tregcache_cache_only(nau8825->regmap, true);\n\tregcache_mark_dirty(nau8825->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8825_resume(struct snd_soc_component *component)\n{\n\tstruct nau8825 *nau8825 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tregcache_cache_only(nau8825->regmap, false);\n\tregcache_sync(nau8825->regmap);\n\tnau8825->xtalk_protect = true;\n\tret = nau8825_sema_acquire(nau8825, 0);\n\tif (ret)\n\t\tnau8825->xtalk_protect = false;\n\tenable_irq(nau8825->irq);\n\n\treturn 0;\n}\n\nstatic int nau8825_set_jack(struct snd_soc_component *component,\n\t\t\t    struct snd_soc_jack *jack, void *data)\n{\n\treturn nau8825_enable_jack_detect(component, jack);\n}\n\nstatic const struct snd_soc_component_driver nau8825_component_driver = {\n\t.probe\t\t\t= nau8825_component_probe,\n\t.remove\t\t\t= nau8825_component_remove,\n\t.set_sysclk\t\t= nau8825_set_sysclk,\n\t.set_pll\t\t= nau8825_set_pll,\n\t.set_bias_level\t\t= nau8825_set_bias_level,\n\t.suspend\t\t= nau8825_suspend,\n\t.resume\t\t\t= nau8825_resume,\n\t.controls\t\t= nau8825_controls,\n\t.num_controls\t\t= ARRAY_SIZE(nau8825_controls),\n\t.dapm_widgets\t\t= nau8825_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(nau8825_dapm_widgets),\n\t.dapm_routes\t\t= nau8825_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(nau8825_dapm_routes),\n\t.set_jack\t\t= nau8825_set_jack,\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void nau8825_reset_chip(struct regmap *regmap)\n{\n\tregmap_write(regmap, NAU8825_REG_RESET, 0x00);\n\tregmap_write(regmap, NAU8825_REG_RESET, 0x00);\n}\n\nstatic void nau8825_print_device_properties(struct nau8825 *nau8825)\n{\n\tint i;\n\tstruct device *dev = nau8825->dev;\n\n\tdev_dbg(dev, \"jkdet-enable:         %d\\n\", nau8825->jkdet_enable);\n\tdev_dbg(dev, \"jkdet-pull-enable:    %d\\n\", nau8825->jkdet_pull_enable);\n\tdev_dbg(dev, \"jkdet-pull-up:        %d\\n\", nau8825->jkdet_pull_up);\n\tdev_dbg(dev, \"jkdet-polarity:       %d\\n\", nau8825->jkdet_polarity);\n\tdev_dbg(dev, \"micbias-voltage:      %d\\n\", nau8825->micbias_voltage);\n\tdev_dbg(dev, \"vref-impedance:       %d\\n\", nau8825->vref_impedance);\n\n\tdev_dbg(dev, \"sar-threshold-num:    %d\\n\", nau8825->sar_threshold_num);\n\tfor (i = 0; i < nau8825->sar_threshold_num; i++)\n\t\tdev_dbg(dev, \"sar-threshold[%d]=%d\\n\", i,\n\t\t\t\tnau8825->sar_threshold[i]);\n\n\tdev_dbg(dev, \"sar-hysteresis:       %d\\n\", nau8825->sar_hysteresis);\n\tdev_dbg(dev, \"sar-voltage:          %d\\n\", nau8825->sar_voltage);\n\tdev_dbg(dev, \"sar-compare-time:     %d\\n\", nau8825->sar_compare_time);\n\tdev_dbg(dev, \"sar-sampling-time:    %d\\n\", nau8825->sar_sampling_time);\n\tdev_dbg(dev, \"short-key-debounce:   %d\\n\", nau8825->key_debounce);\n\tdev_dbg(dev, \"jack-insert-debounce: %d\\n\",\n\t\t\tnau8825->jack_insert_debounce);\n\tdev_dbg(dev, \"jack-eject-debounce:  %d\\n\",\n\t\t\tnau8825->jack_eject_debounce);\n\tdev_dbg(dev, \"crosstalk-enable:     %d\\n\",\n\t\t\tnau8825->xtalk_enable);\n\tdev_dbg(dev, \"adcout-drive-strong:  %d\\n\", nau8825->adcout_ds);\n\tdev_dbg(dev, \"adc-delay-ms:         %d\\n\", nau8825->adc_delay);\n}\n\nstatic int nau8825_read_device_properties(struct device *dev,\n\tstruct nau8825 *nau8825) {\n\tint ret;\n\n\tnau8825->jkdet_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-enable\");\n\tnau8825->jkdet_pull_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-pull-enable\");\n\tnau8825->jkdet_pull_up = device_property_read_bool(dev,\n\t\t\"nuvoton,jkdet-pull-up\");\n\tret = device_property_read_u32(dev, \"nuvoton,jkdet-polarity\",\n\t\t&nau8825->jkdet_polarity);\n\tif (ret)\n\t\tnau8825->jkdet_polarity = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,micbias-voltage\",\n\t\t&nau8825->micbias_voltage);\n\tif (ret)\n\t\tnau8825->micbias_voltage = 6;\n\tret = device_property_read_u32(dev, \"nuvoton,vref-impedance\",\n\t\t&nau8825->vref_impedance);\n\tif (ret)\n\t\tnau8825->vref_impedance = 2;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-threshold-num\",\n\t\t&nau8825->sar_threshold_num);\n\tif (ret)\n\t\tnau8825->sar_threshold_num = 4;\n\tret = device_property_read_u32_array(dev, \"nuvoton,sar-threshold\",\n\t\tnau8825->sar_threshold, nau8825->sar_threshold_num);\n\tif (ret) {\n\t\tnau8825->sar_threshold[0] = 0x08;\n\t\tnau8825->sar_threshold[1] = 0x12;\n\t\tnau8825->sar_threshold[2] = 0x26;\n\t\tnau8825->sar_threshold[3] = 0x73;\n\t}\n\tret = device_property_read_u32(dev, \"nuvoton,sar-hysteresis\",\n\t\t&nau8825->sar_hysteresis);\n\tif (ret)\n\t\tnau8825->sar_hysteresis = 0;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-voltage\",\n\t\t&nau8825->sar_voltage);\n\tif (ret)\n\t\tnau8825->sar_voltage = 6;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-compare-time\",\n\t\t&nau8825->sar_compare_time);\n\tif (ret)\n\t\tnau8825->sar_compare_time = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-sampling-time\",\n\t\t&nau8825->sar_sampling_time);\n\tif (ret)\n\t\tnau8825->sar_sampling_time = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,short-key-debounce\",\n\t\t&nau8825->key_debounce);\n\tif (ret)\n\t\tnau8825->key_debounce = 3;\n\tret = device_property_read_u32(dev, \"nuvoton,jack-insert-debounce\",\n\t\t&nau8825->jack_insert_debounce);\n\tif (ret)\n\t\tnau8825->jack_insert_debounce = 7;\n\tret = device_property_read_u32(dev, \"nuvoton,jack-eject-debounce\",\n\t\t&nau8825->jack_eject_debounce);\n\tif (ret)\n\t\tnau8825->jack_eject_debounce = 0;\n\tnau8825->xtalk_enable = device_property_read_bool(dev,\n\t\t\"nuvoton,crosstalk-enable\");\n\tnau8825->adcout_ds = device_property_read_bool(dev, \"nuvoton,adcout-drive-strong\");\n\tret = device_property_read_u32(dev, \"nuvoton,adc-delay-ms\", &nau8825->adc_delay);\n\tif (ret)\n\t\tnau8825->adc_delay = 125;\n\tif (nau8825->adc_delay < 125 || nau8825->adc_delay > 500)\n\t\tdev_warn(dev, \"Please set the suitable delay time!\\n\");\n\n\tnau8825->mclk = devm_clk_get(dev, \"mclk\");\n\tif (PTR_ERR(nau8825->mclk) == -EPROBE_DEFER) {\n\t\treturn -EPROBE_DEFER;\n\t} else if (PTR_ERR(nau8825->mclk) == -ENOENT) {\n\t\t \n\t\tnau8825->mclk = NULL;\n\t\tdev_info(dev, \"No 'mclk' clock found, assume MCLK is managed externally\");\n\t} else if (IS_ERR(nau8825->mclk)) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_setup_irq(struct nau8825 *nau8825)\n{\n\tint ret;\n\n\tret = devm_request_threaded_irq(nau8825->dev, nau8825->irq, NULL,\n\t\tnau8825_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\"nau8825\", nau8825);\n\n\tif (ret) {\n\t\tdev_err(nau8825->dev, \"Cannot request irq %d (%d)\\n\",\n\t\t\tnau8825->irq, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8825_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8825 *nau8825 = dev_get_platdata(&i2c->dev);\n\tint ret, value;\n\n\tif (!nau8825) {\n\t\tnau8825 = devm_kzalloc(dev, sizeof(*nau8825), GFP_KERNEL);\n\t\tif (!nau8825)\n\t\t\treturn -ENOMEM;\n\t\tret = nau8825_read_device_properties(dev, nau8825);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, nau8825);\n\n\tnau8825->regmap = devm_regmap_init_i2c(i2c, &nau8825_regmap_config);\n\tif (IS_ERR(nau8825->regmap))\n\t\treturn PTR_ERR(nau8825->regmap);\n\tnau8825->dev = dev;\n\tnau8825->irq = i2c->irq;\n\t \n\tnau8825->xtalk_state = NAU8825_XTALK_DONE;\n\tnau8825->xtalk_protect = false;\n\tnau8825->xtalk_baktab_initialized = false;\n\tsema_init(&nau8825->xtalk_sem, 1);\n\tINIT_WORK(&nau8825->xtalk_work, nau8825_xtalk_work);\n\n\tnau8825_print_device_properties(nau8825);\n\n\tnau8825_reset_chip(nau8825->regmap);\n\tret = regmap_read(nau8825->regmap, NAU8825_REG_I2C_DEVICE_ID, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device id from the NAU8825: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tnau8825->sw_id = value & NAU8825_SOFTWARE_ID_MASK;\n\tswitch (nau8825->sw_id) {\n\tcase NAU8825_SOFTWARE_ID_NAU8825:\n\t\tbreak;\n\tcase NAU8825_SOFTWARE_ID_NAU8825C:\n\t\tret = regmap_register_patch(nau8825->regmap, nau8825_regmap_patch,\n\t\t\t\t\t    ARRAY_SIZE(nau8825_regmap_patch));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register Rev C patch: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Not a NAU8825 chip\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnau8825_init_regs(nau8825);\n\n\tif (i2c->irq)\n\t\tnau8825_setup_irq(nau8825);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t&nau8825_component_driver,\n\t\t&nau8825_dai, 1);\n}\n\nstatic void nau8825_i2c_remove(struct i2c_client *client)\n{}\n\nstatic const struct i2c_device_id nau8825_i2c_ids[] = {\n\t{ \"nau8825\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8825_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8825_of_ids[] = {\n\t{ .compatible = \"nuvoton,nau8825\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nau8825_of_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id nau8825_acpi_match[] = {\n\t{ \"10508825\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, nau8825_acpi_match);\n#endif\n\nstatic struct i2c_driver nau8825_driver = {\n\t.driver = {\n\t\t.name = \"nau8825\",\n\t\t.of_match_table = of_match_ptr(nau8825_of_ids),\n\t\t.acpi_match_table = ACPI_PTR(nau8825_acpi_match),\n\t},\n\t.probe = nau8825_i2c_probe,\n\t.remove = nau8825_i2c_remove,\n\t.id_table = nau8825_i2c_ids,\n};\nmodule_i2c_driver(nau8825_driver);\n\nMODULE_DESCRIPTION(\"ASoC nau8825 driver\");\nMODULE_AUTHOR(\"Anatol Pomozov <anatol@chromium.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}