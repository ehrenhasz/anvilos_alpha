{
  "module_name": "ak4642.c",
  "hash_id": "33444d67bc8b067470b2ebac0578c8bbb9c1dd4af02a89a79b374f432867e0b9",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4642.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n \n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#define PW_MGMT1\t0x00\n#define PW_MGMT2\t0x01\n#define SG_SL1\t\t0x02\n#define SG_SL2\t\t0x03\n#define MD_CTL1\t\t0x04\n#define MD_CTL2\t\t0x05\n#define TIMER\t\t0x06\n#define ALC_CTL1\t0x07\n#define ALC_CTL2\t0x08\n#define L_IVC\t\t0x09\n#define L_DVC\t\t0x0a\n#define ALC_CTL3\t0x0b\n#define R_IVC\t\t0x0c\n#define R_DVC\t\t0x0d\n#define MD_CTL3\t\t0x0e\n#define MD_CTL4\t\t0x0f\n#define PW_MGMT3\t0x10\n#define DF_S\t\t0x11\n#define FIL3_0\t\t0x12\n#define FIL3_1\t\t0x13\n#define FIL3_2\t\t0x14\n#define FIL3_3\t\t0x15\n#define EQ_0\t\t0x16\n#define EQ_1\t\t0x17\n#define EQ_2\t\t0x18\n#define EQ_3\t\t0x19\n#define EQ_4\t\t0x1a\n#define EQ_5\t\t0x1b\n#define FIL1_0\t\t0x1c\n#define FIL1_1\t\t0x1d\n#define FIL1_2\t\t0x1e\n#define FIL1_3\t\t0x1f\t \n#define PW_MGMT4\t0x20\n#define MD_CTL5\t\t0x21\n#define LO_MS\t\t0x22\n#define HP_MS\t\t0x23\n#define SPK_MS\t\t0x24\t \n#define EQ_FBEQAB\t0x25\n#define EQ_FBEQCD\t0x26\n#define EQ_FBEQE\t0x27\t \n\n \n#define PMVCM\t\t(1 << 6)  \n#define PMMIN\t\t(1 << 5)  \n#define PMDAC\t\t(1 << 2)  \n#define PMADL\t\t(1 << 0)  \n\n \n#define HPMTN\t\t(1 << 6)\n#define PMHPL\t\t(1 << 5)\n#define PMHPR\t\t(1 << 4)\n#define MS\t\t(1 << 3)  \n#define MCKO\t\t(1 << 1)\n#define PMPLL\t\t(1 << 0)\n\n#define PMHP_MASK\t(PMHPL | PMHPR)\n#define PMHP\t\tPMHP_MASK\n\n \n#define PMADR\t\t(1 << 0)  \n\n \n#define MINS\t\t(1 << 6)  \n#define DACL\t\t(1 << 4)  \n#define PMMP\t\t(1 << 2)  \n#define MGAIN0\t\t(1 << 0)  \n\n \n#define LOPS\t\t(1 << 6)  \n\n \n#define ZTM(param)\t((param & 0x3) << 4)  \n#define WTM(param)\t(((param & 0x4) << 4) | ((param & 0x3) << 2))\n\n \n#define ALC\t\t(1 << 5)  \n#define LMTH0\t\t(1 << 0)  \n\n \n#define PLL3\t\t(1 << 7)\n#define PLL2\t\t(1 << 6)\n#define PLL1\t\t(1 << 5)\n#define PLL0\t\t(1 << 4)\n#define PLL_MASK\t(PLL3 | PLL2 | PLL1 | PLL0)\n\n#define BCKO_MASK\t(1 << 3)\n#define BCKO_64\t\tBCKO_MASK\n\n#define DIF_MASK\t(3 << 0)\n#define DSP\t\t(0 << 0)\n#define RIGHT_J\t\t(1 << 0)\n#define LEFT_J\t\t(2 << 0)\n#define I2S\t\t(3 << 0)\n\n \n#define FSs(val)\t(((val & 0x7) << 0) | ((val & 0x8) << 2))\n#define PSs(val)\t((val & 0x3) << 6)\n\n \n#define BST1\t\t(1 << 3)\n\n \n#define DACH\t\t(1 << 0)\n\nstruct ak4642_drvdata {\n\tconst struct regmap_config *regmap_config;\n\tint extended_frequencies;\n};\n\nstruct ak4642_priv {\n\tconst struct ak4642_drvdata *drvdata;\n\tstruct clk *mcko;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -11550, 50, 1);\n\nstatic const struct snd_kcontrol_new ak4642_snd_controls[] = {\n\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", L_DVC, R_DVC,\n\t\t\t 0, 0xFF, 1, out_tlv),\n\tSOC_SINGLE(\"ALC Capture Switch\", ALC_CTL1, 5, 1, 0),\n\tSOC_SINGLE(\"ALC Capture ZC Switch\", ALC_CTL1, 4, 1, 1),\n};\n\nstatic const struct snd_kcontrol_new ak4642_headphone_control =\n\tSOC_DAPM_SINGLE(\"Switch\", PW_MGMT2, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new ak4642_lout_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"DACL\", SG_SL1, 4, 1, 0),\n};\n\n \nstatic int ak4642_lout_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMD:\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, SG_SL2, LOPS, LOPS);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tmsleep(300);\n\t\tsnd_soc_component_update_bits(component, SG_SL2, LOPS, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget ak4642_dapm_widgets[] = {\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINEOUT\"),\n\n\tSND_SOC_DAPM_PGA(\"HPL Out\", PW_MGMT2, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HPR Out\", PW_MGMT2, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SWITCH(\"Headphone Enable\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &ak4642_headphone_control),\n\n\tSND_SOC_DAPM_PGA(\"DACH\", MD_CTL4, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER_E(\"LINEOUT Mixer\", PW_MGMT1, 3, 0,\n\t\t\t   &ak4642_lout_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(ak4642_lout_mixer_controls),\n\t\t\t   ak4642_lout_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, PW_MGMT1, 2, 0),\n};\n\nstatic const struct snd_soc_dapm_route ak4642_intercon[] = {\n\n\t \n\t{\"HPOUTL\", NULL, \"HPL Out\"},\n\t{\"HPOUTR\", NULL, \"HPR Out\"},\n\t{\"LINEOUT\", NULL, \"LINEOUT Mixer\"},\n\n\t{\"HPL Out\", NULL, \"Headphone Enable\"},\n\t{\"HPR Out\", NULL, \"Headphone Enable\"},\n\n\t{\"Headphone Enable\", \"Switch\", \"DACH\"},\n\n\t{\"DACH\", NULL, \"DAC\"},\n\n\t{\"LINEOUT Mixer\", \"DACL\", \"DAC\"},\n\n\t{ \"DAC\", NULL, \"Playback\" },\n};\n\n \nstatic const struct reg_default ak4643_reg[] = {\n\t{  0, 0x00 }, {  1, 0x00 }, {  2, 0x01 }, {  3, 0x00 },\n\t{  4, 0x02 }, {  5, 0x00 }, {  6, 0x00 }, {  7, 0x00 },\n\t{  8, 0xe1 }, {  9, 0xe1 }, { 10, 0x18 }, { 11, 0x00 },\n\t{ 12, 0xe1 }, { 13, 0x18 }, { 14, 0x11 }, { 15, 0x08 },\n\t{ 16, 0x00 }, { 17, 0x00 }, { 18, 0x00 }, { 19, 0x00 },\n\t{ 20, 0x00 }, { 21, 0x00 }, { 22, 0x00 }, { 23, 0x00 },\n\t{ 24, 0x00 }, { 25, 0x00 }, { 26, 0x00 }, { 27, 0x00 },\n\t{ 28, 0x00 }, { 29, 0x00 }, { 30, 0x00 }, { 31, 0x00 },\n\t{ 32, 0x00 }, { 33, 0x00 }, { 34, 0x00 }, { 35, 0x00 },\n\t{ 36, 0x00 },\n};\n\n \n#define ak4642_reg ak4643_reg\n#define NUM_AK4642_REG_DEFAULTS\t(FIL1_3 + 1)\n\nstatic const struct reg_default ak4648_reg[] = {\n\t{  0, 0x00 }, {  1, 0x00 }, {  2, 0x01 }, {  3, 0x00 },\n\t{  4, 0x02 }, {  5, 0x00 }, {  6, 0x00 }, {  7, 0x00 },\n\t{  8, 0xe1 }, {  9, 0xe1 }, { 10, 0x18 }, { 11, 0x00 },\n\t{ 12, 0xe1 }, { 13, 0x18 }, { 14, 0x11 }, { 15, 0xb8 },\n\t{ 16, 0x00 }, { 17, 0x00 }, { 18, 0x00 }, { 19, 0x00 },\n\t{ 20, 0x00 }, { 21, 0x00 }, { 22, 0x00 }, { 23, 0x00 },\n\t{ 24, 0x00 }, { 25, 0x00 }, { 26, 0x00 }, { 27, 0x00 },\n\t{ 28, 0x00 }, { 29, 0x00 }, { 30, 0x00 }, { 31, 0x00 },\n\t{ 32, 0x00 }, { 33, 0x00 }, { 34, 0x00 }, { 35, 0x00 },\n\t{ 36, 0x00 }, { 37, 0x88 }, { 38, 0x88 }, { 39, 0x08 },\n};\n\nstatic int ak4642_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (is_play) {\n\t\t \n\t\tsnd_soc_component_write(component, L_IVC, 0x91);  \n\t\tsnd_soc_component_write(component, R_IVC, 0x91);  \n\t} else {\n\t\t \n\t\tsnd_soc_component_update_bits(component, SG_SL1, PMMP | MGAIN0, PMMP | MGAIN0);\n\t\tsnd_soc_component_write(component, TIMER, ZTM(0x3) | WTM(0x3));\n\t\tsnd_soc_component_write(component, ALC_CTL1, ALC | LMTH0);\n\t\tsnd_soc_component_update_bits(component, PW_MGMT1, PMADL, PMADL);\n\t\tsnd_soc_component_update_bits(component, PW_MGMT3, PMADR, PMADR);\n\t}\n\n\treturn 0;\n}\n\nstatic void ak4642_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (is_play) {\n\t} else {\n\t\t \n\t\tsnd_soc_component_update_bits(component, PW_MGMT1, PMADL, 0);\n\t\tsnd_soc_component_update_bits(component, PW_MGMT3, PMADR, 0);\n\t\tsnd_soc_component_update_bits(component, ALC_CTL1, ALC, 0);\n\t}\n}\n\nstatic int ak4642_dai_set_sysclk(struct snd_soc_dai *codec_dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ak4642_priv *priv = snd_soc_component_get_drvdata(component);\n\tu8 pll;\n\tint extended_freq = 0;\n\n\tswitch (freq) {\n\tcase 11289600:\n\t\tpll = PLL2;\n\t\tbreak;\n\tcase 12288000:\n\t\tpll = PLL2 | PLL0;\n\t\tbreak;\n\tcase 12000000:\n\t\tpll = PLL2 | PLL1;\n\t\tbreak;\n\tcase 24000000:\n\t\tpll = PLL2 | PLL1 | PLL0;\n\t\tbreak;\n\tcase 13500000:\n\t\tpll = PLL3 | PLL2;\n\t\tbreak;\n\tcase 27000000:\n\t\tpll = PLL3 | PLL2 | PLL0;\n\t\tbreak;\n\tcase 19200000:\n\t\tpll = PLL3;\n\t\textended_freq = 1;\n\t\tbreak;\n\tcase 13000000:\n\t\tpll = PLL3 | PLL2 | PLL1;\n\t\textended_freq = 1;\n\t\tbreak;\n\tcase 26000000:\n\t\tpll = PLL3 | PLL2 | PLL1 | PLL0;\n\t\textended_freq = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (extended_freq && !priv->drvdata->extended_frequencies)\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, MD_CTL1, PLL_MASK, pll);\n\n\treturn 0;\n}\n\nstatic int ak4642_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 data;\n\tu8 bcko;\n\n\tdata = MCKO | PMPLL;  \n\tbcko = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tdata |= MS;\n\t\tbcko = BCKO_64;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, PW_MGMT2, MS | MCKO | PMPLL, data);\n\tsnd_soc_component_update_bits(component, MD_CTL1, BCKO_MASK, bcko);\n\n\t \n\tdata = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdata = LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdata = I2S;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, MD_CTL1, DIF_MASK, data);\n\n\treturn 0;\n}\n\nstatic int ak4642_set_mcko(struct snd_soc_component *component,\n\t\t\t   u32 frequency)\n{\n\tstatic const u32 fs_list[] = {\n\t\t[0] = 8000,\n\t\t[1] = 12000,\n\t\t[2] = 16000,\n\t\t[3] = 24000,\n\t\t[4] = 7350,\n\t\t[5] = 11025,\n\t\t[6] = 14700,\n\t\t[7] = 22050,\n\t\t[10] = 32000,\n\t\t[11] = 48000,\n\t\t[14] = 29400,\n\t\t[15] = 44100,\n\t};\n\tstatic const u32 ps_list[] = {\n\t\t[0] = 256,\n\t\t[1] = 128,\n\t\t[2] = 64,\n\t\t[3] = 32\n\t};\n\tint ps, fs;\n\n\tfor (ps = 0; ps < ARRAY_SIZE(ps_list); ps++) {\n\t\tfor (fs = 0; fs < ARRAY_SIZE(fs_list); fs++) {\n\t\t\tif (frequency == ps_list[ps] * fs_list[fs]) {\n\t\t\t\tsnd_soc_component_write(component, MD_CTL2,\n\t\t\t\t\t      PSs(ps) | FSs(fs));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ak4642_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4642_priv *priv = snd_soc_component_get_drvdata(component);\n\tu32 rate = clk_get_rate(priv->mcko);\n\n\tif (!rate)\n\t\trate = params_rate(params) * 256;\n\n\treturn ak4642_set_mcko(component, rate);\n}\n\nstatic int ak4642_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_write(component, PW_MGMT1, 0x00);\n\t\tbreak;\n\tdefault:\n\t\tsnd_soc_component_update_bits(component, PW_MGMT1, PMVCM, PMVCM);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ak4642_dai_ops = {\n\t.startup\t= ak4642_dai_startup,\n\t.shutdown\t= ak4642_dai_shutdown,\n\t.set_sysclk\t= ak4642_dai_set_sysclk,\n\t.set_fmt\t= ak4642_dai_set_fmt,\n\t.hw_params\t= ak4642_dai_hw_params,\n};\n\nstatic struct snd_soc_dai_driver ak4642_dai = {\n\t.name = \"ak4642-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE },\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE },\n\t.ops = &ak4642_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int ak4642_suspend(struct snd_soc_component *component)\n{\n\tstruct regmap *regmap = dev_get_regmap(component->dev, NULL);\n\n\tregcache_cache_only(regmap, true);\n\tregcache_mark_dirty(regmap);\n\treturn 0;\n}\n\nstatic int ak4642_resume(struct snd_soc_component *component)\n{\n\tstruct regmap *regmap = dev_get_regmap(component->dev, NULL);\n\n\tregcache_cache_only(regmap, false);\n\tregcache_sync(regmap);\n\treturn 0;\n}\nstatic int ak4642_probe(struct snd_soc_component *component)\n{\n\tstruct ak4642_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tif (priv->mcko)\n\t\tak4642_set_mcko(component, clk_get_rate(priv->mcko));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ak4642 = {\n\t.probe\t\t\t= ak4642_probe,\n\t.suspend\t\t= ak4642_suspend,\n\t.resume\t\t\t= ak4642_resume,\n\t.set_bias_level\t\t= ak4642_set_bias_level,\n\t.controls\t\t= ak4642_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4642_snd_controls),\n\t.dapm_widgets\t\t= ak4642_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4642_dapm_widgets),\n\t.dapm_routes\t\t= ak4642_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4642_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4642_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= FIL1_3,\n\t.reg_defaults\t\t= ak4642_reg,\n\t.num_reg_defaults\t= NUM_AK4642_REG_DEFAULTS,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_config ak4643_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= SPK_MS,\n\t.reg_defaults\t\t= ak4643_reg,\n\t.num_reg_defaults\t= ARRAY_SIZE(ak4643_reg),\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct regmap_config ak4648_regmap = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= EQ_FBEQE,\n\t.reg_defaults\t\t= ak4648_reg,\n\t.num_reg_defaults\t= ARRAY_SIZE(ak4648_reg),\n\t.cache_type\t\t= REGCACHE_RBTREE,\n};\n\nstatic const struct ak4642_drvdata ak4642_drvdata = {\n\t.regmap_config = &ak4642_regmap,\n};\n\nstatic const struct ak4642_drvdata ak4643_drvdata = {\n\t.regmap_config = &ak4643_regmap,\n};\n\nstatic const struct ak4642_drvdata ak4648_drvdata = {\n\t.regmap_config = &ak4648_regmap,\n\t.extended_frequencies = 1,\n};\n\n#ifdef CONFIG_COMMON_CLK\nstatic struct clk *ak4642_of_parse_mcko(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct clk *clk;\n\tconst char *clk_name = np->name;\n\tconst char *parent_clk_name = NULL;\n\tu32 rate;\n\n\tif (of_property_read_u32(np, \"clock-frequency\", &rate))\n\t\treturn NULL;\n\n\tif (of_property_read_bool(np, \"clocks\"))\n\t\tparent_clk_name = of_clk_get_parent_name(np, 0);\n\n\tof_property_read_string(np, \"clock-output-names\", &clk_name);\n\n\tclk = clk_register_fixed_rate(dev, clk_name, parent_clk_name, 0, rate);\n\tif (!IS_ERR(clk))\n\t\tof_clk_add_provider(np, of_clk_src_simple_get, clk);\n\n\treturn clk;\n}\n#else\n#define ak4642_of_parse_mcko(d) 0\n#endif\n\nstatic const struct of_device_id ak4642_of_match[];\nstatic const struct i2c_device_id ak4642_i2c_id[];\nstatic int ak4642_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct ak4642_drvdata *drvdata = NULL;\n\tstruct regmap *regmap;\n\tstruct ak4642_priv *priv;\n\tstruct clk *mcko = NULL;\n\n\tif (np) {\n\t\tconst struct of_device_id *of_id;\n\n\t\tmcko = ak4642_of_parse_mcko(dev);\n\t\tif (IS_ERR(mcko))\n\t\t\tmcko = NULL;\n\n\t\tof_id = of_match_device(ak4642_of_match, dev);\n\t\tif (of_id)\n\t\t\tdrvdata = of_id->data;\n\t} else {\n\t\tconst struct i2c_device_id *id =\n\t\t\ti2c_match_id(ak4642_i2c_id, i2c);\n\t\tdrvdata = (const struct ak4642_drvdata *)id->driver_data;\n\t}\n\n\tif (!drvdata) {\n\t\tdev_err(dev, \"Unknown device type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->drvdata = drvdata;\n\tpriv->mcko = mcko;\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tregmap = devm_regmap_init_i2c(i2c, drvdata->regmap_config);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t&soc_component_dev_ak4642, &ak4642_dai, 1);\n}\n\nstatic const struct of_device_id ak4642_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4642\",\t.data = &ak4642_drvdata},\n\t{ .compatible = \"asahi-kasei,ak4643\",\t.data = &ak4643_drvdata},\n\t{ .compatible = \"asahi-kasei,ak4648\",\t.data = &ak4648_drvdata},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ak4642_of_match);\n\nstatic const struct i2c_device_id ak4642_i2c_id[] = {\n\t{ \"ak4642\", (kernel_ulong_t)&ak4642_drvdata },\n\t{ \"ak4643\", (kernel_ulong_t)&ak4643_drvdata },\n\t{ \"ak4648\", (kernel_ulong_t)&ak4648_drvdata },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ak4642_i2c_id);\n\nstatic struct i2c_driver ak4642_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4642-codec\",\n\t\t.of_match_table = ak4642_of_match,\n\t},\n\t.probe\t\t= ak4642_i2c_probe,\n\t.id_table\t= ak4642_i2c_id,\n};\n\nmodule_i2c_driver(ak4642_i2c_driver);\n\nMODULE_DESCRIPTION(\"Soc AK4642 driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <morimoto.kuninori@renesas.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}