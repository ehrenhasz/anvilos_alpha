{
  "module_name": "da7213.c",
  "hash_id": "eb04b1efca0f9dd0906935ae247c0a046bf68b831846628503ba7f01a3250acb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/da7213.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/of_device.h>\n#include <linux/property.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/da7213.h>\n#include \"da7213.h\"\n\n\n \nstatic const DECLARE_TLV_DB_RANGE(aux_vol_tlv,\n\t \n\t0x0, 0x11, TLV_DB_SCALE_ITEM(-5400, 0, 0),\n\t \n\t0x12, 0x3f, TLV_DB_SCALE_ITEM(-5250, 150, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(digital_gain_tlv,\n\t0x0, 0x07, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),\n\t \n\t0x08, 0x7f, TLV_DB_SCALE_ITEM(-7800, 75, 0)\n);\n\nstatic const DECLARE_TLV_DB_RANGE(alc_analog_gain_tlv,\n\t0x0, 0x0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),\n\t \n\t0x01, 0x07, TLV_DB_SCALE_ITEM(0, 600, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(mixin_gain_tlv, -450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(eq_gain_tlv, -1050, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(hp_vol_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(lineout_vol_tlv, -4800, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_threshold_tlv, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_gain_tlv, 0, 600, 0);\n\n \nstatic const char * const da7213_voice_hpf_corner_txt[] = {\n\t\"2.5Hz\", \"25Hz\", \"50Hz\", \"100Hz\", \"150Hz\", \"200Hz\", \"300Hz\", \"400Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_voice_hpf_corner,\n\t\t\t    DA7213_DAC_FILTERS1,\n\t\t\t    DA7213_VOICE_HPF_CORNER_SHIFT,\n\t\t\t    da7213_voice_hpf_corner_txt);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_adc_voice_hpf_corner,\n\t\t\t    DA7213_ADC_FILTERS1,\n\t\t\t    DA7213_VOICE_HPF_CORNER_SHIFT,\n\t\t\t    da7213_voice_hpf_corner_txt);\n\n \nstatic const char * const da7213_audio_hpf_corner_txt[] = {\n\t\"Fs/24000\", \"Fs/12000\", \"Fs/6000\", \"Fs/3000\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_audio_hpf_corner,\n\t\t\t    DA7213_DAC_FILTERS1\n\t\t\t    , DA7213_AUDIO_HPF_CORNER_SHIFT,\n\t\t\t    da7213_audio_hpf_corner_txt);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_adc_audio_hpf_corner,\n\t\t\t    DA7213_ADC_FILTERS1,\n\t\t\t    DA7213_AUDIO_HPF_CORNER_SHIFT,\n\t\t\t    da7213_audio_hpf_corner_txt);\n\n \nstatic const char * const da7213_gain_ramp_rate_txt[] = {\n\t\"nominal rate * 8\", \"nominal rate * 16\", \"nominal rate / 16\",\n\t\"nominal rate / 32\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_gain_ramp_rate,\n\t\t\t    DA7213_GAIN_RAMP_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_RATE_SHIFT,\n\t\t\t    da7213_gain_ramp_rate_txt);\n\n \nstatic const char * const da7213_dac_ng_setup_time_txt[] = {\n\t\"256 samples\", \"512 samples\", \"1024 samples\", \"2048 samples\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_ng_setup_time,\n\t\t\t    DA7213_DAC_NG_SETUP_TIME,\n\t\t\t    DA7213_DAC_NG_SETUP_TIME_SHIFT,\n\t\t\t    da7213_dac_ng_setup_time_txt);\n\n \nstatic const char * const da7213_dac_ng_rampup_txt[] = {\n\t\"0.02 ms/dB\", \"0.16 ms/dB\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_ng_rampup_rate,\n\t\t\t    DA7213_DAC_NG_SETUP_TIME,\n\t\t\t    DA7213_DAC_NG_RAMPUP_RATE_SHIFT,\n\t\t\t    da7213_dac_ng_rampup_txt);\n\n \nstatic const char * const da7213_dac_ng_rampdown_txt[] = {\n\t\"0.64 ms/dB\", \"20.48 ms/dB\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_ng_rampdown_rate,\n\t\t\t    DA7213_DAC_NG_SETUP_TIME,\n\t\t\t    DA7213_DAC_NG_RAMPDN_RATE_SHIFT,\n\t\t\t    da7213_dac_ng_rampdown_txt);\n\n \nstatic const char * const da7213_dac_soft_mute_rate_txt[] = {\n\t\"1\", \"2\", \"4\", \"8\", \"16\", \"32\", \"64\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_soft_mute_rate,\n\t\t\t    DA7213_DAC_FILTERS5,\n\t\t\t    DA7213_DAC_SOFTMUTE_RATE_SHIFT,\n\t\t\t    da7213_dac_soft_mute_rate_txt);\n\n \nstatic const char * const da7213_alc_attack_rate_txt[] = {\n\t\"44/fs\", \"88/fs\", \"176/fs\", \"352/fs\", \"704/fs\", \"1408/fs\", \"2816/fs\",\n\t\"5632/fs\", \"11264/fs\", \"22528/fs\", \"45056/fs\", \"90112/fs\", \"180224/fs\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_alc_attack_rate,\n\t\t\t    DA7213_ALC_CTRL2,\n\t\t\t    DA7213_ALC_ATTACK_SHIFT,\n\t\t\t    da7213_alc_attack_rate_txt);\n\n \nstatic const char * const da7213_alc_release_rate_txt[] = {\n\t\"176/fs\", \"352/fs\", \"704/fs\", \"1408/fs\", \"2816/fs\", \"5632/fs\",\n\t\"11264/fs\", \"22528/fs\", \"45056/fs\", \"90112/fs\", \"180224/fs\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_alc_release_rate,\n\t\t\t    DA7213_ALC_CTRL2,\n\t\t\t    DA7213_ALC_RELEASE_SHIFT,\n\t\t\t    da7213_alc_release_rate_txt);\n\n \nstatic const char * const da7213_alc_hold_time_txt[] = {\n\t\"62/fs\", \"124/fs\", \"248/fs\", \"496/fs\", \"992/fs\", \"1984/fs\", \"3968/fs\",\n\t\"7936/fs\", \"15872/fs\", \"31744/fs\", \"63488/fs\", \"126976/fs\",\n\t\"253952/fs\", \"507904/fs\", \"1015808/fs\", \"2031616/fs\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_alc_hold_time,\n\t\t\t    DA7213_ALC_CTRL3,\n\t\t\t    DA7213_ALC_HOLD_SHIFT,\n\t\t\t    da7213_alc_hold_time_txt);\n\n \nstatic const char * const da7213_alc_integ_rate_txt[] = {\n\t\"1/4\", \"1/16\", \"1/256\", \"1/65536\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_alc_integ_attack_rate,\n\t\t\t    DA7213_ALC_CTRL3,\n\t\t\t    DA7213_ALC_INTEG_ATTACK_SHIFT,\n\t\t\t    da7213_alc_integ_rate_txt);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_alc_integ_release_rate,\n\t\t\t    DA7213_ALC_CTRL3,\n\t\t\t    DA7213_ALC_INTEG_RELEASE_SHIFT,\n\t\t\t    da7213_alc_integ_rate_txt);\n\n\n \n\nstatic int da7213_get_alc_data(struct snd_soc_component *component, u8 reg_val)\n{\n\tint mid_data, top_data;\n\tint sum = 0;\n\tu8 iteration;\n\n\tfor (iteration = 0; iteration < DA7213_ALC_AVG_ITERATIONS;\n\t     iteration++) {\n\t\t \n\t\tsnd_soc_component_write(component, DA7213_ALC_CIC_OP_LVL_CTRL, reg_val);\n\n\t\t \n\t\tsnd_soc_component_write(component, DA7213_ALC_CIC_OP_LVL_CTRL,\n\t\t\t      reg_val | DA7213_ALC_DATA_MIDDLE);\n\t\tmid_data = snd_soc_component_read(component, DA7213_ALC_CIC_OP_LVL_DATA);\n\n\t\t \n\t\tsnd_soc_component_write(component, DA7213_ALC_CIC_OP_LVL_CTRL,\n\t\t\t      reg_val | DA7213_ALC_DATA_TOP);\n\t\ttop_data = snd_soc_component_read(component, DA7213_ALC_CIC_OP_LVL_DATA);\n\n\t\tsum += ((mid_data << 8) | (top_data << 16));\n\t}\n\n\treturn sum / DA7213_ALC_AVG_ITERATIONS;\n}\n\nstatic void da7213_alc_calib_man(struct snd_soc_component *component)\n{\n\tu8 reg_val;\n\tint avg_left_data, avg_right_data, offset_l, offset_r;\n\n\t \n\t \n\tavg_left_data = da7213_get_alc_data(component,\n\t\t\tDA7213_ALC_CIC_OP_CHANNEL_LEFT);\n\t \n\tavg_right_data = da7213_get_alc_data(component,\n\t\t\t DA7213_ALC_CIC_OP_CHANNEL_RIGHT);\n\n\t \n\toffset_l = -avg_left_data;\n\toffset_r = -avg_right_data;\n\n\treg_val = (offset_l & DA7213_ALC_OFFSET_15_8) >> 8;\n\tsnd_soc_component_write(component, DA7213_ALC_OFFSET_MAN_M_L, reg_val);\n\treg_val = (offset_l & DA7213_ALC_OFFSET_19_16) >> 16;\n\tsnd_soc_component_write(component, DA7213_ALC_OFFSET_MAN_U_L, reg_val);\n\n\treg_val = (offset_r & DA7213_ALC_OFFSET_15_8) >> 8;\n\tsnd_soc_component_write(component, DA7213_ALC_OFFSET_MAN_M_R, reg_val);\n\treg_val = (offset_r & DA7213_ALC_OFFSET_19_16) >> 16;\n\tsnd_soc_component_write(component, DA7213_ALC_OFFSET_MAN_U_R, reg_val);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_ALC_CTRL1,\n\t\t\t    DA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\n\t\t\t    DA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE);\n}\n\nstatic void da7213_alc_calib_auto(struct snd_soc_component *component)\n{\n\tu8 alc_ctrl1;\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_ALC_CTRL1, DA7213_ALC_AUTO_CALIB_EN,\n\t\t\t    DA7213_ALC_AUTO_CALIB_EN);\n\tdo {\n\t\talc_ctrl1 = snd_soc_component_read(component, DA7213_ALC_CTRL1);\n\t} while (alc_ctrl1 & DA7213_ALC_AUTO_CALIB_EN);\n\n\t \n\tif (alc_ctrl1 & DA7213_ALC_CALIB_OVERFLOW) {\n\t\tdev_warn(component->dev,\n\t\t\t \"ALC auto calibration failed with overflow\\n\");\n\t\tsnd_soc_component_update_bits(component, DA7213_ALC_CTRL1,\n\t\t\t\t    DA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\n\t\t\t\t    0);\n\t} else {\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7213_ALC_CTRL1,\n\t\t\t\t    DA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\n\t\t\t\t    DA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE);\n\t}\n\n}\n\nstatic void da7213_alc_calib(struct snd_soc_component *component)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tu8 adc_l_ctrl, adc_r_ctrl;\n\tu8 mixin_l_sel, mixin_r_sel;\n\tu8 mic_1_ctrl, mic_2_ctrl;\n\n\t \n\tadc_l_ctrl = snd_soc_component_read(component, DA7213_ADC_L_CTRL);\n\tadc_r_ctrl = snd_soc_component_read(component, DA7213_ADC_R_CTRL);\n\n\t \n\tmixin_l_sel = snd_soc_component_read(component, DA7213_MIXIN_L_SELECT);\n\tmixin_r_sel = snd_soc_component_read(component, DA7213_MIXIN_R_SELECT);\n\n\t \n\tmic_1_ctrl = snd_soc_component_read(component, DA7213_MIC_1_CTRL);\n\tmic_2_ctrl = snd_soc_component_read(component, DA7213_MIC_2_CTRL);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_ADC_L_CTRL, DA7213_ADC_EN,\n\t\t\t    DA7213_ADC_EN);\n\tsnd_soc_component_update_bits(component, DA7213_ADC_R_CTRL, DA7213_ADC_EN,\n\t\t\t    DA7213_ADC_EN);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_L_SELECT,\n\t\t\t    DA7213_MIXIN_L_MIX_SELECT_MIC_1 |\n\t\t\t    DA7213_MIXIN_L_MIX_SELECT_MIC_2,\n\t\t\t    DA7213_MIXIN_L_MIX_SELECT_MIC_1 |\n\t\t\t    DA7213_MIXIN_L_MIX_SELECT_MIC_2);\n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_R_SELECT,\n\t\t\t    DA7213_MIXIN_R_MIX_SELECT_MIC_2 |\n\t\t\t    DA7213_MIXIN_R_MIX_SELECT_MIC_1,\n\t\t\t    DA7213_MIXIN_R_MIX_SELECT_MIC_2 |\n\t\t\t    DA7213_MIXIN_R_MIX_SELECT_MIC_1);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_MIC_1_CTRL, DA7213_MUTE_EN,\n\t\t\t    DA7213_MUTE_EN);\n\tsnd_soc_component_update_bits(component, DA7213_MIC_2_CTRL, DA7213_MUTE_EN,\n\t\t\t    DA7213_MUTE_EN);\n\n\t \n\tif (da7213->alc_calib_auto)\n\t\tda7213_alc_calib_auto(component);\n\telse\n\t\tda7213_alc_calib_man(component);\n\n\t \n\tsnd_soc_component_write(component, DA7213_MIXIN_L_SELECT, mixin_l_sel);\n\tsnd_soc_component_write(component, DA7213_MIXIN_R_SELECT, mixin_r_sel);\n\n\t \n\tsnd_soc_component_write(component, DA7213_ADC_L_CTRL, adc_l_ctrl);\n\tsnd_soc_component_write(component, DA7213_ADC_R_CTRL, adc_r_ctrl);\n\n\t \n\tsnd_soc_component_write(component, DA7213_MIC_1_CTRL, mic_1_ctrl);\n\tsnd_soc_component_write(component, DA7213_MIC_2_CTRL, mic_2_ctrl);\n}\n\nstatic int da7213_put_mixin_gain(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_put_volsw_2r(kcontrol, ucontrol);\n\n\t \n\tif ((!ret) && (da7213->alc_en))\n\t\tda7213_alc_calib(component);\n\n\treturn ret;\n}\n\nstatic int da7213_put_alc_sw(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (ucontrol->value.integer.value[0] ||\n\t    ucontrol->value.integer.value[1]) {\n\t\tif (!da7213->alc_en) {\n\t\t\tda7213_alc_calib(component);\n\t\t\tda7213->alc_en = true;\n\t\t}\n\t} else {\n\t\tda7213->alc_en = false;\n\t}\n\n\treturn snd_soc_put_volsw(kcontrol, ucontrol);\n}\n\n\n \n\nstatic const struct snd_kcontrol_new da7213_snd_controls[] = {\n\n\t \n\tSOC_SINGLE_TLV(\"Mic 1 Volume\", DA7213_MIC_1_GAIN,\n\t\t       DA7213_MIC_AMP_GAIN_SHIFT, DA7213_MIC_AMP_GAIN_MAX,\n\t\t       DA7213_NO_INVERT, mic_vol_tlv),\n\tSOC_SINGLE_TLV(\"Mic 2 Volume\", DA7213_MIC_2_GAIN,\n\t\t       DA7213_MIC_AMP_GAIN_SHIFT, DA7213_MIC_AMP_GAIN_MAX,\n\t\t       DA7213_NO_INVERT, mic_vol_tlv),\n\tSOC_DOUBLE_R_TLV(\"Aux Volume\", DA7213_AUX_L_GAIN, DA7213_AUX_R_GAIN,\n\t\t\t DA7213_AUX_AMP_GAIN_SHIFT, DA7213_AUX_AMP_GAIN_MAX,\n\t\t\t DA7213_NO_INVERT, aux_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"Mixin PGA Volume\", DA7213_MIXIN_L_GAIN,\n\t\t\t     DA7213_MIXIN_R_GAIN, DA7213_MIXIN_AMP_GAIN_SHIFT,\n\t\t\t     DA7213_MIXIN_AMP_GAIN_MAX, DA7213_NO_INVERT,\n\t\t\t     snd_soc_get_volsw_2r, da7213_put_mixin_gain,\n\t\t\t     mixin_gain_tlv),\n\tSOC_DOUBLE_R_TLV(\"ADC Volume\", DA7213_ADC_L_GAIN, DA7213_ADC_R_GAIN,\n\t\t\t DA7213_ADC_AMP_GAIN_SHIFT, DA7213_ADC_AMP_GAIN_MAX,\n\t\t\t DA7213_NO_INVERT, digital_gain_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC Volume\", DA7213_DAC_L_GAIN, DA7213_DAC_R_GAIN,\n\t\t\t DA7213_DAC_AMP_GAIN_SHIFT, DA7213_DAC_AMP_GAIN_MAX,\n\t\t\t DA7213_NO_INVERT, digital_gain_tlv),\n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", DA7213_HP_L_GAIN, DA7213_HP_R_GAIN,\n\t\t\t DA7213_HP_AMP_GAIN_SHIFT, DA7213_HP_AMP_GAIN_MAX,\n\t\t\t DA7213_NO_INVERT, hp_vol_tlv),\n\tSOC_SINGLE_TLV(\"Lineout Volume\", DA7213_LINE_GAIN,\n\t\t       DA7213_LINE_AMP_GAIN_SHIFT, DA7213_LINE_AMP_GAIN_MAX,\n\t\t       DA7213_NO_INVERT, lineout_vol_tlv),\n\n\t \n\tSOC_SINGLE(\"DAC EQ Switch\", DA7213_DAC_FILTERS4, DA7213_DAC_EQ_EN_SHIFT,\n\t\t   DA7213_DAC_EQ_EN_MAX, DA7213_NO_INVERT),\n\tSOC_SINGLE_TLV(\"DAC EQ1 Volume\", DA7213_DAC_FILTERS2,\n\t\t       DA7213_DAC_EQ_BAND1_SHIFT, DA7213_DAC_EQ_BAND_MAX,\n\t\t       DA7213_NO_INVERT, eq_gain_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ2 Volume\", DA7213_DAC_FILTERS2,\n\t\t       DA7213_DAC_EQ_BAND2_SHIFT, DA7213_DAC_EQ_BAND_MAX,\n\t\t       DA7213_NO_INVERT, eq_gain_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ3 Volume\", DA7213_DAC_FILTERS3,\n\t\t       DA7213_DAC_EQ_BAND3_SHIFT, DA7213_DAC_EQ_BAND_MAX,\n\t\t       DA7213_NO_INVERT, eq_gain_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ4 Volume\", DA7213_DAC_FILTERS3,\n\t\t       DA7213_DAC_EQ_BAND4_SHIFT, DA7213_DAC_EQ_BAND_MAX,\n\t\t       DA7213_NO_INVERT, eq_gain_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ5 Volume\", DA7213_DAC_FILTERS4,\n\t\t       DA7213_DAC_EQ_BAND5_SHIFT, DA7213_DAC_EQ_BAND_MAX,\n\t\t       DA7213_NO_INVERT, eq_gain_tlv),\n\n\t \n\tSOC_SINGLE(\"ADC HPF Switch\", DA7213_ADC_FILTERS1, DA7213_HPF_EN_SHIFT,\n\t\t   DA7213_HPF_EN_MAX, DA7213_NO_INVERT),\n\tSOC_ENUM(\"ADC HPF Cutoff\", da7213_adc_audio_hpf_corner),\n\tSOC_SINGLE(\"ADC Voice Mode Switch\", DA7213_ADC_FILTERS1,\n\t\t   DA7213_VOICE_EN_SHIFT, DA7213_VOICE_EN_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_ENUM(\"ADC Voice Cutoff\", da7213_adc_voice_hpf_corner),\n\n\tSOC_SINGLE(\"DAC HPF Switch\", DA7213_DAC_FILTERS1, DA7213_HPF_EN_SHIFT,\n\t\t   DA7213_HPF_EN_MAX, DA7213_NO_INVERT),\n\tSOC_ENUM(\"DAC HPF Cutoff\", da7213_dac_audio_hpf_corner),\n\tSOC_SINGLE(\"DAC Voice Mode Switch\", DA7213_DAC_FILTERS1,\n\t\t   DA7213_VOICE_EN_SHIFT, DA7213_VOICE_EN_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_ENUM(\"DAC Voice Cutoff\", da7213_dac_voice_hpf_corner),\n\n\t \n\tSOC_SINGLE(\"Mic 1 Switch\", DA7213_MIC_1_CTRL, DA7213_MUTE_EN_SHIFT,\n\t\t   DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_SINGLE(\"Mic 2 Switch\", DA7213_MIC_2_CTRL, DA7213_MUTE_EN_SHIFT,\n\t\t   DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_DOUBLE_R(\"Aux Switch\", DA7213_AUX_L_CTRL, DA7213_AUX_R_CTRL,\n\t\t     DA7213_MUTE_EN_SHIFT, DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_DOUBLE_R(\"Mixin PGA Switch\", DA7213_MIXIN_L_CTRL,\n\t\t     DA7213_MIXIN_R_CTRL, DA7213_MUTE_EN_SHIFT,\n\t\t     DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_DOUBLE_R(\"ADC Switch\", DA7213_ADC_L_CTRL, DA7213_ADC_R_CTRL,\n\t\t     DA7213_MUTE_EN_SHIFT, DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_DOUBLE_R(\"Headphone Switch\", DA7213_HP_L_CTRL, DA7213_HP_R_CTRL,\n\t\t     DA7213_MUTE_EN_SHIFT, DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_SINGLE(\"Lineout Switch\", DA7213_LINE_CTRL, DA7213_MUTE_EN_SHIFT,\n\t\t   DA7213_MUTE_EN_MAX, DA7213_INVERT),\n\tSOC_SINGLE(\"DAC Soft Mute Switch\", DA7213_DAC_FILTERS5,\n\t\t   DA7213_DAC_SOFTMUTE_EN_SHIFT, DA7213_DAC_SOFTMUTE_EN_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_ENUM(\"DAC Soft Mute Rate\", da7213_dac_soft_mute_rate),\n\n\t \n\tSOC_DOUBLE_R(\"Aux ZC Switch\", DA7213_AUX_L_CTRL, DA7213_AUX_R_CTRL,\n\t\t     DA7213_ZC_EN_SHIFT, DA7213_ZC_EN_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"Mixin PGA ZC Switch\", DA7213_MIXIN_L_CTRL,\n\t\t     DA7213_MIXIN_R_CTRL, DA7213_ZC_EN_SHIFT, DA7213_ZC_EN_MAX,\n\t\t     DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"Headphone ZC Switch\", DA7213_HP_L_CTRL, DA7213_HP_R_CTRL,\n\t\t     DA7213_ZC_EN_SHIFT, DA7213_ZC_EN_MAX, DA7213_NO_INVERT),\n\n\t \n\tSOC_DOUBLE_R(\"Aux Gain Ramping Switch\", DA7213_AUX_L_CTRL,\n\t\t     DA7213_AUX_R_CTRL, DA7213_GAIN_RAMP_EN_SHIFT,\n\t\t     DA7213_GAIN_RAMP_EN_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"Mixin Gain Ramping Switch\", DA7213_MIXIN_L_CTRL,\n\t\t     DA7213_MIXIN_R_CTRL, DA7213_GAIN_RAMP_EN_SHIFT,\n\t\t     DA7213_GAIN_RAMP_EN_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"ADC Gain Ramping Switch\", DA7213_ADC_L_CTRL,\n\t\t     DA7213_ADC_R_CTRL, DA7213_GAIN_RAMP_EN_SHIFT,\n\t\t     DA7213_GAIN_RAMP_EN_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"DAC Gain Ramping Switch\", DA7213_DAC_L_CTRL,\n\t\t     DA7213_DAC_R_CTRL, DA7213_GAIN_RAMP_EN_SHIFT,\n\t\t     DA7213_GAIN_RAMP_EN_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE_R(\"Headphone Gain Ramping Switch\", DA7213_HP_L_CTRL,\n\t\t     DA7213_HP_R_CTRL, DA7213_GAIN_RAMP_EN_SHIFT,\n\t\t     DA7213_GAIN_RAMP_EN_MAX, DA7213_NO_INVERT),\n\tSOC_SINGLE(\"Lineout Gain Ramping Switch\", DA7213_LINE_CTRL,\n\t\t   DA7213_GAIN_RAMP_EN_SHIFT, DA7213_GAIN_RAMP_EN_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_ENUM(\"Gain Ramping Rate\", da7213_gain_ramp_rate),\n\n\t \n\tSOC_SINGLE(\"DAC NG Switch\", DA7213_DAC_NG_CTRL, DA7213_DAC_NG_EN_SHIFT,\n\t\t   DA7213_DAC_NG_EN_MAX, DA7213_NO_INVERT),\n\tSOC_ENUM(\"DAC NG Setup Time\", da7213_dac_ng_setup_time),\n\tSOC_ENUM(\"DAC NG Rampup Rate\", da7213_dac_ng_rampup_rate),\n\tSOC_ENUM(\"DAC NG Rampdown Rate\", da7213_dac_ng_rampdown_rate),\n\tSOC_SINGLE(\"DAC NG OFF Threshold\", DA7213_DAC_NG_OFF_THRESHOLD,\n\t\t   DA7213_DAC_NG_THRESHOLD_SHIFT, DA7213_DAC_NG_THRESHOLD_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_SINGLE(\"DAC NG ON Threshold\", DA7213_DAC_NG_ON_THRESHOLD,\n\t\t   DA7213_DAC_NG_THRESHOLD_SHIFT, DA7213_DAC_NG_THRESHOLD_MAX,\n\t\t   DA7213_NO_INVERT),\n\n\t \n\tSOC_DOUBLE(\"DAC Mono Switch\", DA7213_DIG_ROUTING_DAC,\n\t\t   DA7213_DAC_L_MONO_SHIFT, DA7213_DAC_R_MONO_SHIFT,\n\t\t   DA7213_DAC_MONO_MAX, DA7213_NO_INVERT),\n\tSOC_DOUBLE(\"DAC Invert Switch\", DA7213_DIG_CTRL, DA7213_DAC_L_INV_SHIFT,\n\t\t   DA7213_DAC_R_INV_SHIFT, DA7213_DAC_INV_MAX,\n\t\t   DA7213_NO_INVERT),\n\n\t \n\tSOC_DOUBLE_R(\"DMIC Switch\", DA7213_MIXIN_L_SELECT,\n\t\t     DA7213_MIXIN_R_SELECT, DA7213_DMIC_EN_SHIFT,\n\t\t     DA7213_DMIC_EN_MAX, DA7213_NO_INVERT),\n\n\t \n\tSOC_DOUBLE_EXT(\"ALC Switch\", DA7213_ALC_CTRL1, DA7213_ALC_L_EN_SHIFT,\n\t\t       DA7213_ALC_R_EN_SHIFT, DA7213_ALC_EN_MAX,\n\t\t       DA7213_NO_INVERT, snd_soc_get_volsw, da7213_put_alc_sw),\n\tSOC_ENUM(\"ALC Attack Rate\", da7213_alc_attack_rate),\n\tSOC_ENUM(\"ALC Release Rate\", da7213_alc_release_rate),\n\tSOC_ENUM(\"ALC Hold Time\", da7213_alc_hold_time),\n\t \n\tSOC_ENUM(\"ALC Integ Attack Rate\", da7213_alc_integ_attack_rate),\n\t \n\tSOC_ENUM(\"ALC Integ Release Rate\", da7213_alc_integ_release_rate),\n\tSOC_SINGLE_TLV(\"ALC Noise Threshold Volume\", DA7213_ALC_NOISE,\n\t\t       DA7213_ALC_THRESHOLD_SHIFT, DA7213_ALC_THRESHOLD_MAX,\n\t\t       DA7213_INVERT, alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Min Threshold Volume\", DA7213_ALC_TARGET_MIN,\n\t\t       DA7213_ALC_THRESHOLD_SHIFT, DA7213_ALC_THRESHOLD_MAX,\n\t\t       DA7213_INVERT, alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Threshold Volume\", DA7213_ALC_TARGET_MAX,\n\t\t       DA7213_ALC_THRESHOLD_SHIFT, DA7213_ALC_THRESHOLD_MAX,\n\t\t       DA7213_INVERT, alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Attenuation Volume\", DA7213_ALC_GAIN_LIMITS,\n\t\t       DA7213_ALC_ATTEN_MAX_SHIFT,\n\t\t       DA7213_ALC_ATTEN_GAIN_MAX_MAX, DA7213_NO_INVERT,\n\t\t       alc_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Gain Volume\", DA7213_ALC_GAIN_LIMITS,\n\t\t       DA7213_ALC_GAIN_MAX_SHIFT, DA7213_ALC_ATTEN_GAIN_MAX_MAX,\n\t\t       DA7213_NO_INVERT, alc_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Min Analog Gain Volume\", DA7213_ALC_ANA_GAIN_LIMITS,\n\t\t       DA7213_ALC_ANA_GAIN_MIN_SHIFT, DA7213_ALC_ANA_GAIN_MAX,\n\t\t       DA7213_NO_INVERT, alc_analog_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Analog Gain Volume\", DA7213_ALC_ANA_GAIN_LIMITS,\n\t\t       DA7213_ALC_ANA_GAIN_MAX_SHIFT, DA7213_ALC_ANA_GAIN_MAX,\n\t\t       DA7213_NO_INVERT, alc_analog_gain_tlv),\n\tSOC_SINGLE(\"ALC Anticlip Mode Switch\", DA7213_ALC_ANTICLIP_CTRL,\n\t\t   DA7213_ALC_ANTICLIP_EN_SHIFT, DA7213_ALC_ANTICLIP_EN_MAX,\n\t\t   DA7213_NO_INVERT),\n\tSOC_SINGLE(\"ALC Anticlip Level\", DA7213_ALC_ANTICLIP_LEVEL,\n\t\t   DA7213_ALC_ANTICLIP_LEVEL_SHIFT,\n\t\t   DA7213_ALC_ANTICLIP_LEVEL_MAX, DA7213_NO_INVERT),\n};\n\n\n \n\n \n\n \nstatic const char * const da7213_mic_amp_in_sel_txt[] = {\n\t\"Differential\", \"MIC_P\", \"MIC_N\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_mic_1_amp_in_sel,\n\t\t\t    DA7213_MIC_1_CTRL,\n\t\t\t    DA7213_MIC_AMP_IN_SEL_SHIFT,\n\t\t\t    da7213_mic_amp_in_sel_txt);\nstatic const struct snd_kcontrol_new da7213_mic_1_amp_in_sel_mux =\n\tSOC_DAPM_ENUM(\"Mic 1 Amp Source MUX\", da7213_mic_1_amp_in_sel);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_mic_2_amp_in_sel,\n\t\t\t    DA7213_MIC_2_CTRL,\n\t\t\t    DA7213_MIC_AMP_IN_SEL_SHIFT,\n\t\t\t    da7213_mic_amp_in_sel_txt);\nstatic const struct snd_kcontrol_new da7213_mic_2_amp_in_sel_mux =\n\tSOC_DAPM_ENUM(\"Mic 2 Amp Source MUX\", da7213_mic_2_amp_in_sel);\n\n \nstatic const char * const da7213_dai_src_txt[] = {\n\t\"ADC Left\", \"ADC Right\", \"DAI Input Left\", \"DAI Input Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dai_l_src,\n\t\t\t    DA7213_DIG_ROUTING_DAI,\n\t\t\t    DA7213_DAI_L_SRC_SHIFT,\n\t\t\t    da7213_dai_src_txt);\nstatic const struct snd_kcontrol_new da7213_dai_l_src_mux =\n\tSOC_DAPM_ENUM(\"DAI Left Source MUX\", da7213_dai_l_src);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dai_r_src,\n\t\t\t    DA7213_DIG_ROUTING_DAI,\n\t\t\t    DA7213_DAI_R_SRC_SHIFT,\n\t\t\t    da7213_dai_src_txt);\nstatic const struct snd_kcontrol_new da7213_dai_r_src_mux =\n\tSOC_DAPM_ENUM(\"DAI Right Source MUX\", da7213_dai_r_src);\n\n \nstatic const char * const da7213_dac_src_txt[] = {\n\t\"ADC Output Left\", \"ADC Output Right\", \"DAI Input Left\",\n\t\"DAI Input Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_l_src,\n\t\t\t    DA7213_DIG_ROUTING_DAC,\n\t\t\t    DA7213_DAC_L_SRC_SHIFT,\n\t\t\t    da7213_dac_src_txt);\nstatic const struct snd_kcontrol_new da7213_dac_l_src_mux =\n\tSOC_DAPM_ENUM(\"DAC Left Source MUX\", da7213_dac_l_src);\n\nstatic SOC_ENUM_SINGLE_DECL(da7213_dac_r_src,\n\t\t\t    DA7213_DIG_ROUTING_DAC,\n\t\t\t    DA7213_DAC_R_SRC_SHIFT,\n\t\t\t    da7213_dac_src_txt);\nstatic const struct snd_kcontrol_new da7213_dac_r_src_mux =\n\tSOC_DAPM_ENUM(\"DAC Right Source MUX\", da7213_dac_r_src);\n\n \n\n \nstatic const struct snd_kcontrol_new da7213_dapm_mixinl_controls[] = {\n\tSOC_DAPM_SINGLE(\"Aux Left Switch\", DA7213_MIXIN_L_SELECT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_AUX_L_SHIFT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mic 1 Switch\", DA7213_MIXIN_L_SELECT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MIC_1_SHIFT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mic 2 Switch\", DA7213_MIXIN_L_SELECT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MIC_2_SHIFT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Right Switch\", DA7213_MIXIN_L_SELECT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MIXIN_R_SHIFT,\n\t\t\tDA7213_MIXIN_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n};\n\n \nstatic const struct snd_kcontrol_new da7213_dapm_mixinr_controls[] = {\n\tSOC_DAPM_SINGLE(\"Aux Right Switch\", DA7213_MIXIN_R_SELECT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_AUX_R_SHIFT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mic 2 Switch\", DA7213_MIXIN_R_SELECT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MIC_2_SHIFT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mic 1 Switch\", DA7213_MIXIN_R_SELECT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MIC_1_SHIFT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Left Switch\", DA7213_MIXIN_R_SELECT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MIXIN_L_SHIFT,\n\t\t\tDA7213_MIXIN_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n};\n\n \nstatic const struct snd_kcontrol_new da7213_dapm_mixoutl_controls[] = {\n\tSOC_DAPM_SINGLE(\"Aux Left Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_AUX_L_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Left Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MIXIN_L_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Right Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MIXIN_R_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"DAC Left Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_DAC_L_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Aux Left Invert Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_AUX_L_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Left Invert Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MIXIN_L_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Right Invert Switch\", DA7213_MIXOUT_L_SELECT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MIXIN_R_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_L_MIX_SELECT_MAX, DA7213_NO_INVERT),\n};\n\n \nstatic const struct snd_kcontrol_new da7213_dapm_mixoutr_controls[] = {\n\tSOC_DAPM_SINGLE(\"Aux Right Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_AUX_R_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Right Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MIXIN_R_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Left Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MIXIN_L_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"DAC Right Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_DAC_R_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Aux Right Invert Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_AUX_R_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Right Invert Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MIXIN_R_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n\tSOC_DAPM_SINGLE(\"Mixin Left Invert Switch\", DA7213_MIXOUT_R_SELECT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MIXIN_L_INVERTED_SHIFT,\n\t\t\tDA7213_MIXOUT_R_MIX_SELECT_MAX, DA7213_NO_INVERT),\n};\n\n\n \n\nstatic int da7213_dai_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tu8 pll_ctrl, pll_status;\n\tint i = 0;\n\tbool srm_lock = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tif (da7213->master)\n\t\t\tsnd_soc_component_update_bits(component, DA7213_DAI_CLK_MODE,\n\t\t\t\t\t    DA7213_DAI_CLK_EN_MASK,\n\t\t\t\t\t    DA7213_DAI_CLK_EN_MASK);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7213_PC_COUNT,\n\t\t\t\t    DA7213_PC_FREERUN_MASK, 0);\n\n\t\t \n\t\tpll_ctrl = snd_soc_component_read(component, DA7213_PLL_CTRL);\n\t\tif (!(pll_ctrl & DA7213_PLL_SRM_EN))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (pll_ctrl & DA7213_PLL_32K_MODE) {\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x8B);\n\t\t\tsnd_soc_component_write(component, 0xF2, 0x03);\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x00);\n\t\t}\n\n\t\t \n\t\tdo {\n\t\t\tpll_status = snd_soc_component_read(component, DA7213_PLL_STATUS);\n\t\t\tif (pll_status & DA7219_PLL_SRM_LOCK) {\n\t\t\t\tsrm_lock = true;\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t\tmsleep(50);\n\t\t\t}\n\t\t} while ((i < DA7213_SRM_CHECK_RETRIES) && (!srm_lock));\n\n\t\tif (!srm_lock)\n\t\t\tdev_warn(component->dev, \"SRM failed to lock\\n\");\n\n\t\treturn 0;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tpll_ctrl = snd_soc_component_read(component, DA7213_PLL_CTRL);\n\t\tif (pll_ctrl & DA7213_PLL_32K_MODE) {\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x8B);\n\t\t\tsnd_soc_component_write(component, 0xF2, 0x01);\n\t\t\tsnd_soc_component_write(component, 0xF0, 0x00);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7213_PC_COUNT,\n\t\t\t\t    DA7213_PC_FREERUN_MASK,\n\t\t\t\t    DA7213_PC_FREERUN_MASK);\n\n\t\t \n\t\tif (da7213->master)\n\t\t\tsnd_soc_component_update_bits(component, DA7213_DAI_CLK_MODE,\n\t\t\t\t\t    DA7213_DAI_CLK_EN_MASK, 0);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n\n \n\nstatic const struct snd_soc_dapm_widget da7213_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDDMIC\", 0, 0),\n\n\t \n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"DAI\", DA7213_DAI_CTRL, DA7213_DAI_EN_SHIFT,\n\t\t\t    DA7213_NO_INVERT, da7213_dai_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\n\t \n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"AUXL\"),\n\tSND_SOC_DAPM_INPUT(\"AUXR\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Mic 1 Amp Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_mic_1_amp_in_sel_mux),\n\tSND_SOC_DAPM_MUX(\"Mic 2 Amp Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_mic_2_amp_in_sel_mux),\n\n\t \n\tSND_SOC_DAPM_PGA(\"Mic 1 PGA\", DA7213_MIC_1_CTRL, DA7213_AMP_EN_SHIFT,\n\t\t\t DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mic 2 PGA\", DA7213_MIC_2_CTRL, DA7213_AMP_EN_SHIFT,\n\t\t\t DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Aux Left PGA\", DA7213_AUX_L_CTRL, DA7213_AMP_EN_SHIFT,\n\t\t\t DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Aux Right PGA\", DA7213_AUX_R_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mixin Left PGA\", DA7213_MIXIN_L_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mixin Right PGA\", DA7213_MIXIN_R_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 1\", DA7213_MICBIAS_CTRL,\n\t\t\t    DA7213_MICBIAS1_EN_SHIFT, DA7213_NO_INVERT,\n\t\t\t    NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 2\", DA7213_MICBIAS_CTRL,\n\t\t\t    DA7213_MICBIAS2_EN_SHIFT, DA7213_NO_INVERT,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Mixin Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &da7213_dapm_mixinl_controls[0],\n\t\t\t   ARRAY_SIZE(da7213_dapm_mixinl_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mixin Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &da7213_dapm_mixinr_controls[0],\n\t\t\t   ARRAY_SIZE(da7213_dapm_mixinr_controls)),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC Left\", NULL, DA7213_ADC_L_CTRL,\n\t\t\t DA7213_ADC_EN_SHIFT, DA7213_NO_INVERT),\n\tSND_SOC_DAPM_ADC(\"ADC Right\", NULL, DA7213_ADC_R_CTRL,\n\t\t\t DA7213_ADC_EN_SHIFT, DA7213_NO_INVERT),\n\n\t \n\tSND_SOC_DAPM_MUX(\"DAI Left Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_dai_l_src_mux),\n\tSND_SOC_DAPM_MUX(\"DAI Right Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_dai_r_src_mux),\n\tSND_SOC_DAPM_AIF_OUT(\"DAIOUTL\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DAIOUTR\", \"Capture\", 1, SND_SOC_NOPM, 0, 0),\n\n\t \n\n\t \n\tSND_SOC_DAPM_AIF_IN(\"DAIINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DAIINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"DAC Left Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_dac_l_src_mux),\n\tSND_SOC_DAPM_MUX(\"DAC Right Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7213_dac_r_src_mux),\n\n\t \n\tSND_SOC_DAPM_DAC(\"DAC Left\", NULL, DA7213_DAC_L_CTRL,\n\t\t\t DA7213_DAC_EN_SHIFT, DA7213_NO_INVERT),\n\tSND_SOC_DAPM_DAC(\"DAC Right\", NULL, DA7213_DAC_R_CTRL,\n\t\t\t DA7213_DAC_EN_SHIFT, DA7213_NO_INVERT),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Mixout Left\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &da7213_dapm_mixoutl_controls[0],\n\t\t\t   ARRAY_SIZE(da7213_dapm_mixoutl_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mixout Right\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &da7213_dapm_mixoutr_controls[0],\n\t\t\t   ARRAY_SIZE(da7213_dapm_mixoutr_controls)),\n\n\t \n\tSND_SOC_DAPM_PGA(\"Mixout Left PGA\", DA7213_MIXOUT_L_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mixout Right PGA\", DA7213_MIXOUT_R_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Lineout PGA\", DA7213_LINE_CTRL, DA7213_AMP_EN_SHIFT,\n\t\t\t DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Headphone Left PGA\", DA7213_HP_L_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Headphone Right PGA\", DA7213_HP_R_CTRL,\n\t\t\t DA7213_AMP_EN_SHIFT, DA7213_NO_INVERT, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Charge Pump\", DA7213_CP_CTRL, DA7213_CP_EN_SHIFT,\n\t\t\t    DA7213_NO_INVERT, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINE\"),\n};\n\n\n \n\nstatic const struct snd_soc_dapm_route da7213_audio_map[] = {\n\t \n\n\t \n\t{\"Mic Bias 1\", NULL, \"VDDMIC\"},\n\t{\"Mic Bias 2\", NULL, \"VDDMIC\"},\n\n\t{\"MIC1\", NULL, \"Mic Bias 1\"},\n\t{\"MIC2\", NULL, \"Mic Bias 2\"},\n\n\t{\"Mic 1 Amp Source MUX\", \"Differential\", \"MIC1\"},\n\t{\"Mic 1 Amp Source MUX\", \"MIC_P\", \"MIC1\"},\n\t{\"Mic 1 Amp Source MUX\", \"MIC_N\", \"MIC1\"},\n\n\t{\"Mic 2 Amp Source MUX\", \"Differential\", \"MIC2\"},\n\t{\"Mic 2 Amp Source MUX\", \"MIC_P\", \"MIC2\"},\n\t{\"Mic 2 Amp Source MUX\", \"MIC_N\", \"MIC2\"},\n\n\t{\"Mic 1 PGA\", NULL, \"Mic 1 Amp Source MUX\"},\n\t{\"Mic 2 PGA\", NULL, \"Mic 2 Amp Source MUX\"},\n\n\t{\"Aux Left PGA\", NULL, \"AUXL\"},\n\t{\"Aux Right PGA\", NULL, \"AUXR\"},\n\n\t{\"Mixin Left\", \"Aux Left Switch\", \"Aux Left PGA\"},\n\t{\"Mixin Left\", \"Mic 1 Switch\", \"Mic 1 PGA\"},\n\t{\"Mixin Left\", \"Mic 2 Switch\", \"Mic 2 PGA\"},\n\t{\"Mixin Left\", \"Mixin Right Switch\", \"Mixin Right PGA\"},\n\n\t{\"Mixin Right\", \"Aux Right Switch\", \"Aux Right PGA\"},\n\t{\"Mixin Right\", \"Mic 2 Switch\", \"Mic 2 PGA\"},\n\t{\"Mixin Right\", \"Mic 1 Switch\", \"Mic 1 PGA\"},\n\t{\"Mixin Right\", \"Mixin Left Switch\", \"Mixin Left PGA\"},\n\n\t{\"Mixin Left PGA\", NULL, \"Mixin Left\"},\n\t{\"ADC Left\", NULL, \"Mixin Left PGA\"},\n\n\t{\"Mixin Right PGA\", NULL, \"Mixin Right\"},\n\t{\"ADC Right\", NULL, \"Mixin Right PGA\"},\n\n\t{\"DAI Left Source MUX\", \"ADC Left\", \"ADC Left\"},\n\t{\"DAI Left Source MUX\", \"ADC Right\", \"ADC Right\"},\n\t{\"DAI Left Source MUX\", \"DAI Input Left\", \"DAIINL\"},\n\t{\"DAI Left Source MUX\", \"DAI Input Right\", \"DAIINR\"},\n\n\t{\"DAI Right Source MUX\", \"ADC Left\", \"ADC Left\"},\n\t{\"DAI Right Source MUX\", \"ADC Right\", \"ADC Right\"},\n\t{\"DAI Right Source MUX\", \"DAI Input Left\", \"DAIINL\"},\n\t{\"DAI Right Source MUX\", \"DAI Input Right\", \"DAIINR\"},\n\n\t{\"DAIOUTL\", NULL, \"DAI Left Source MUX\"},\n\t{\"DAIOUTR\", NULL, \"DAI Right Source MUX\"},\n\n\t{\"DAIOUTL\", NULL, \"DAI\"},\n\t{\"DAIOUTR\", NULL, \"DAI\"},\n\n\t \n\t{\"DAIINL\", NULL, \"DAI\"},\n\t{\"DAIINR\", NULL, \"DAI\"},\n\n\t{\"DAC Left Source MUX\", \"ADC Output Left\", \"ADC Left\"},\n\t{\"DAC Left Source MUX\", \"ADC Output Right\", \"ADC Right\"},\n\t{\"DAC Left Source MUX\", \"DAI Input Left\", \"DAIINL\"},\n\t{\"DAC Left Source MUX\", \"DAI Input Right\", \"DAIINR\"},\n\n\t{\"DAC Right Source MUX\", \"ADC Output Left\", \"ADC Left\"},\n\t{\"DAC Right Source MUX\", \"ADC Output Right\", \"ADC Right\"},\n\t{\"DAC Right Source MUX\", \"DAI Input Left\", \"DAIINL\"},\n\t{\"DAC Right Source MUX\", \"DAI Input Right\", \"DAIINR\"},\n\n\t{\"DAC Left\", NULL, \"DAC Left Source MUX\"},\n\t{\"DAC Right\", NULL, \"DAC Right Source MUX\"},\n\n\t{\"Mixout Left\", \"Aux Left Switch\", \"Aux Left PGA\"},\n\t{\"Mixout Left\", \"Mixin Left Switch\", \"Mixin Left PGA\"},\n\t{\"Mixout Left\", \"Mixin Right Switch\", \"Mixin Right PGA\"},\n\t{\"Mixout Left\", \"DAC Left Switch\", \"DAC Left\"},\n\t{\"Mixout Left\", \"Aux Left Invert Switch\", \"Aux Left PGA\"},\n\t{\"Mixout Left\", \"Mixin Left Invert Switch\", \"Mixin Left PGA\"},\n\t{\"Mixout Left\", \"Mixin Right Invert Switch\", \"Mixin Right PGA\"},\n\n\t{\"Mixout Right\", \"Aux Right Switch\", \"Aux Right PGA\"},\n\t{\"Mixout Right\", \"Mixin Right Switch\", \"Mixin Right PGA\"},\n\t{\"Mixout Right\", \"Mixin Left Switch\", \"Mixin Left PGA\"},\n\t{\"Mixout Right\", \"DAC Right Switch\", \"DAC Right\"},\n\t{\"Mixout Right\", \"Aux Right Invert Switch\", \"Aux Right PGA\"},\n\t{\"Mixout Right\", \"Mixin Right Invert Switch\", \"Mixin Right PGA\"},\n\t{\"Mixout Right\", \"Mixin Left Invert Switch\", \"Mixin Left PGA\"},\n\n\t{\"Mixout Left PGA\", NULL, \"Mixout Left\"},\n\t{\"Mixout Right PGA\", NULL, \"Mixout Right\"},\n\n\t{\"Headphone Left PGA\", NULL, \"Mixout Left PGA\"},\n\t{\"Headphone Left PGA\", NULL, \"Charge Pump\"},\n\t{\"HPL\", NULL, \"Headphone Left PGA\"},\n\n\t{\"Headphone Right PGA\", NULL, \"Mixout Right PGA\"},\n\t{\"Headphone Right PGA\", NULL, \"Charge Pump\"},\n\t{\"HPR\", NULL, \"Headphone Right PGA\"},\n\n\t{\"Lineout PGA\", NULL, \"Mixout Right PGA\"},\n\t{\"LINE\", NULL, \"Lineout PGA\"},\n};\n\nstatic const struct reg_default da7213_reg_defaults[] = {\n\t{ DA7213_DIG_ROUTING_DAI, 0x10 },\n\t{ DA7213_SR, 0x0A },\n\t{ DA7213_REFERENCES, 0x80 },\n\t{ DA7213_PLL_FRAC_TOP, 0x00 },\n\t{ DA7213_PLL_FRAC_BOT, 0x00 },\n\t{ DA7213_PLL_INTEGER, 0x20 },\n\t{ DA7213_PLL_CTRL, 0x0C },\n\t{ DA7213_DAI_CLK_MODE, 0x01 },\n\t{ DA7213_DAI_CTRL, 0x08 },\n\t{ DA7213_DIG_ROUTING_DAC, 0x32 },\n\t{ DA7213_AUX_L_GAIN, 0x35 },\n\t{ DA7213_AUX_R_GAIN, 0x35 },\n\t{ DA7213_MIXIN_L_SELECT, 0x00 },\n\t{ DA7213_MIXIN_R_SELECT, 0x00 },\n\t{ DA7213_MIXIN_L_GAIN, 0x03 },\n\t{ DA7213_MIXIN_R_GAIN, 0x03 },\n\t{ DA7213_ADC_L_GAIN, 0x6F },\n\t{ DA7213_ADC_R_GAIN, 0x6F },\n\t{ DA7213_ADC_FILTERS1, 0x80 },\n\t{ DA7213_MIC_1_GAIN, 0x01 },\n\t{ DA7213_MIC_2_GAIN, 0x01 },\n\t{ DA7213_DAC_FILTERS5, 0x00 },\n\t{ DA7213_DAC_FILTERS2, 0x88 },\n\t{ DA7213_DAC_FILTERS3, 0x88 },\n\t{ DA7213_DAC_FILTERS4, 0x08 },\n\t{ DA7213_DAC_FILTERS1, 0x80 },\n\t{ DA7213_DAC_L_GAIN, 0x6F },\n\t{ DA7213_DAC_R_GAIN, 0x6F },\n\t{ DA7213_CP_CTRL, 0x61 },\n\t{ DA7213_HP_L_GAIN, 0x39 },\n\t{ DA7213_HP_R_GAIN, 0x39 },\n\t{ DA7213_LINE_GAIN, 0x30 },\n\t{ DA7213_MIXOUT_L_SELECT, 0x00 },\n\t{ DA7213_MIXOUT_R_SELECT, 0x00 },\n\t{ DA7213_SYSTEM_MODES_INPUT, 0x00 },\n\t{ DA7213_SYSTEM_MODES_OUTPUT, 0x00 },\n\t{ DA7213_AUX_L_CTRL, 0x44 },\n\t{ DA7213_AUX_R_CTRL, 0x44 },\n\t{ DA7213_MICBIAS_CTRL, 0x11 },\n\t{ DA7213_MIC_1_CTRL, 0x40 },\n\t{ DA7213_MIC_2_CTRL, 0x40 },\n\t{ DA7213_MIXIN_L_CTRL, 0x40 },\n\t{ DA7213_MIXIN_R_CTRL, 0x40 },\n\t{ DA7213_ADC_L_CTRL, 0x40 },\n\t{ DA7213_ADC_R_CTRL, 0x40 },\n\t{ DA7213_DAC_L_CTRL, 0x48 },\n\t{ DA7213_DAC_R_CTRL, 0x40 },\n\t{ DA7213_HP_L_CTRL, 0x41 },\n\t{ DA7213_HP_R_CTRL, 0x40 },\n\t{ DA7213_LINE_CTRL, 0x40 },\n\t{ DA7213_MIXOUT_L_CTRL, 0x10 },\n\t{ DA7213_MIXOUT_R_CTRL, 0x10 },\n\t{ DA7213_LDO_CTRL, 0x00 },\n\t{ DA7213_IO_CTRL, 0x00 },\n\t{ DA7213_GAIN_RAMP_CTRL, 0x00},\n\t{ DA7213_MIC_CONFIG, 0x00 },\n\t{ DA7213_PC_COUNT, 0x00 },\n\t{ DA7213_CP_VOL_THRESHOLD1, 0x32 },\n\t{ DA7213_CP_DELAY, 0x95 },\n\t{ DA7213_CP_DETECTOR, 0x00 },\n\t{ DA7213_DAI_OFFSET, 0x00 },\n\t{ DA7213_DIG_CTRL, 0x00 },\n\t{ DA7213_ALC_CTRL2, 0x00 },\n\t{ DA7213_ALC_CTRL3, 0x00 },\n\t{ DA7213_ALC_NOISE, 0x3F },\n\t{ DA7213_ALC_TARGET_MIN, 0x3F },\n\t{ DA7213_ALC_TARGET_MAX, 0x00 },\n\t{ DA7213_ALC_GAIN_LIMITS, 0xFF },\n\t{ DA7213_ALC_ANA_GAIN_LIMITS, 0x71 },\n\t{ DA7213_ALC_ANTICLIP_CTRL, 0x00 },\n\t{ DA7213_ALC_ANTICLIP_LEVEL, 0x00 },\n\t{ DA7213_ALC_OFFSET_MAN_M_L, 0x00 },\n\t{ DA7213_ALC_OFFSET_MAN_U_L, 0x00 },\n\t{ DA7213_ALC_OFFSET_MAN_M_R, 0x00 },\n\t{ DA7213_ALC_OFFSET_MAN_U_R, 0x00 },\n\t{ DA7213_ALC_CIC_OP_LVL_CTRL, 0x00 },\n\t{ DA7213_DAC_NG_SETUP_TIME, 0x00 },\n\t{ DA7213_DAC_NG_OFF_THRESHOLD, 0x00 },\n\t{ DA7213_DAC_NG_ON_THRESHOLD, 0x00 },\n\t{ DA7213_DAC_NG_CTRL, 0x00 },\n};\n\nstatic bool da7213_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DA7213_STATUS1:\n\tcase DA7213_PLL_STATUS:\n\tcase DA7213_AUX_L_GAIN_STATUS:\n\tcase DA7213_AUX_R_GAIN_STATUS:\n\tcase DA7213_MIC_1_GAIN_STATUS:\n\tcase DA7213_MIC_2_GAIN_STATUS:\n\tcase DA7213_MIXIN_L_GAIN_STATUS:\n\tcase DA7213_MIXIN_R_GAIN_STATUS:\n\tcase DA7213_ADC_L_GAIN_STATUS:\n\tcase DA7213_ADC_R_GAIN_STATUS:\n\tcase DA7213_DAC_L_GAIN_STATUS:\n\tcase DA7213_DAC_R_GAIN_STATUS:\n\tcase DA7213_HP_L_GAIN_STATUS:\n\tcase DA7213_HP_R_GAIN_STATUS:\n\tcase DA7213_LINE_GAIN_STATUS:\n\tcase DA7213_ALC_CTRL1:\n\tcase DA7213_ALC_OFFSET_AUTO_M_L:\n\tcase DA7213_ALC_OFFSET_AUTO_U_L:\n\tcase DA7213_ALC_OFFSET_AUTO_M_R:\n\tcase DA7213_ALC_OFFSET_AUTO_U_R:\n\tcase DA7213_ALC_CIC_OP_LVL_DATA:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int da7213_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tu8 dai_clk_mode = DA7213_DAI_BCLKS_PER_WCLK_64;\n\tu8 dai_ctrl = 0;\n\tu8 fs;\n\n\t \n\tswitch (params_channels(params)) {\n\tcase 1:\n\t\tif (da7213->fmt != DA7213_DAI_FORMAT_DSP) {\n\t\t\tdev_err(component->dev, \"Mono supported only in DSP mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdai_ctrl |= DA7213_DAI_MONO_MODE_EN;\n\t\tbreak;\n\tcase 2:\n\t\tdai_ctrl &= ~(DA7213_DAI_MONO_MODE_EN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tdai_ctrl |= DA7213_DAI_WORD_LENGTH_S16_LE;\n\t\tdai_clk_mode = DA7213_DAI_BCLKS_PER_WCLK_32;  \n\t\tbreak;\n\tcase 20:\n\t\tdai_ctrl |= DA7213_DAI_WORD_LENGTH_S20_LE;\n\t\tbreak;\n\tcase 24:\n\t\tdai_ctrl |= DA7213_DAI_WORD_LENGTH_S24_LE;\n\t\tbreak;\n\tcase 32:\n\t\tdai_ctrl |= DA7213_DAI_WORD_LENGTH_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tfs = DA7213_SR_8000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tcase 11025:\n\t\tfs = DA7213_SR_11025;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_90316800;\n\t\tbreak;\n\tcase 12000:\n\t\tfs = DA7213_SR_12000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tcase 16000:\n\t\tfs = DA7213_SR_16000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tcase 22050:\n\t\tfs = DA7213_SR_22050;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_90316800;\n\t\tbreak;\n\tcase 32000:\n\t\tfs = DA7213_SR_32000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tcase 44100:\n\t\tfs = DA7213_SR_44100;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_90316800;\n\t\tbreak;\n\tcase 48000:\n\t\tfs = DA7213_SR_48000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tcase 88200:\n\t\tfs = DA7213_SR_88200;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_90316800;\n\t\tbreak;\n\tcase 96000:\n\t\tfs = DA7213_SR_96000;\n\t\tda7213->out_rate = DA7213_PLL_FREQ_OUT_98304000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, DA7213_DAI_CLK_MODE,\n\t\tDA7213_DAI_BCLKS_PER_WCLK_MASK, dai_clk_mode);\n\n\tsnd_soc_component_update_bits(component, DA7213_DAI_CTRL,\n\t\tDA7213_DAI_WORD_LENGTH_MASK | DA7213_DAI_MONO_MODE_MASK, dai_ctrl);\n\tsnd_soc_component_write(component, DA7213_SR, fs);\n\n\treturn 0;\n}\n\nstatic int da7213_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tu8 dai_clk_mode = 0, dai_ctrl = 0;\n\tu8 dai_offset = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tda7213->master = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tda7213->master = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tdai_clk_mode |= DA7213_DAI_WCLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tdai_clk_mode |= DA7213_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tdai_clk_mode |= DA7213_DAI_WCLK_POL_INV |\n\t\t\t\t\tDA7213_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAI_FORMAT_DSP_A:\n\tcase SND_SOC_DAI_FORMAT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tdai_clk_mode |= DA7213_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tdai_clk_mode |= DA7213_DAI_WCLK_POL_INV |\n\t\t\t\t\tDA7213_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tdai_clk_mode |= DA7213_DAI_WCLK_POL_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdai_ctrl |= DA7213_DAI_FORMAT_I2S_MODE;\n\t\tda7213->fmt = DA7213_DAI_FORMAT_I2S_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdai_ctrl |= DA7213_DAI_FORMAT_LEFT_J;\n\t\tda7213->fmt = DA7213_DAI_FORMAT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdai_ctrl |= DA7213_DAI_FORMAT_RIGHT_J;\n\t\tda7213->fmt = DA7213_DAI_FORMAT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAI_FORMAT_DSP_A:  \n\t\tdai_ctrl |= DA7213_DAI_FORMAT_DSP;\n\t\tdai_offset = 1;\n\t\tda7213->fmt = DA7213_DAI_FORMAT_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAI_FORMAT_DSP_B:  \n\t\tdai_ctrl |= DA7213_DAI_FORMAT_DSP;\n\t\tda7213->fmt = DA7213_DAI_FORMAT_DSP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdai_clk_mode |= DA7213_DAI_BCLKS_PER_WCLK_64;\n\n\tsnd_soc_component_update_bits(component, DA7213_DAI_CLK_MODE,\n\t\t\t    DA7213_DAI_BCLKS_PER_WCLK_MASK |\n\t\t\t    DA7213_DAI_CLK_POL_MASK | DA7213_DAI_WCLK_POL_MASK,\n\t\t\t    dai_clk_mode);\n\tsnd_soc_component_update_bits(component, DA7213_DAI_CTRL, DA7213_DAI_FORMAT_MASK,\n\t\t\t    dai_ctrl);\n\tsnd_soc_component_write(component, DA7213_DAI_OFFSET, dai_offset);\n\n\treturn 0;\n}\n\nstatic int da7213_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute) {\n\t\tsnd_soc_component_update_bits(component, DA7213_DAC_L_CTRL,\n\t\t\t\t    DA7213_MUTE_EN, DA7213_MUTE_EN);\n\t\tsnd_soc_component_update_bits(component, DA7213_DAC_R_CTRL,\n\t\t\t\t    DA7213_MUTE_EN, DA7213_MUTE_EN);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, DA7213_DAC_L_CTRL,\n\t\t\t\t    DA7213_MUTE_EN, 0);\n\t\tsnd_soc_component_update_bits(component, DA7213_DAC_R_CTRL,\n\t\t\t\t    DA7213_MUTE_EN, 0);\n\t}\n\n\treturn 0;\n}\n\n#define DA7213_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int da7213_set_component_sysclk(struct snd_soc_component *component,\n\t\t\t\t       int clk_id, int source,\n\t\t\t\t       unsigned int freq, int dir)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif ((da7213->clk_src == clk_id) && (da7213->mclk_rate == freq))\n\t\treturn 0;\n\n\tif (((freq < 5000000) && (freq != 32768)) || (freq > 54000000)) {\n\t\tdev_err(component->dev, \"Unsupported MCLK value %d\\n\",\n\t\t\tfreq);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (clk_id) {\n\tcase DA7213_CLKSRC_MCLK:\n\t\tsnd_soc_component_update_bits(component, DA7213_PLL_CTRL,\n\t\t\t\t    DA7213_PLL_MCLK_SQR_EN, 0);\n\t\tbreak;\n\tcase DA7213_CLKSRC_MCLK_SQR:\n\t\tsnd_soc_component_update_bits(component, DA7213_PLL_CTRL,\n\t\t\t\t    DA7213_PLL_MCLK_SQR_EN,\n\t\t\t\t    DA7213_PLL_MCLK_SQR_EN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown clock source %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tda7213->clk_src = clk_id;\n\n\tif (da7213->mclk) {\n\t\tfreq = clk_round_rate(da7213->mclk, freq);\n\t\tret = clk_set_rate(da7213->mclk, freq);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to set clock rate %d\\n\",\n\t\t\t\tfreq);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tda7213->mclk_rate = freq;\n\n\treturn 0;\n}\n\n \nstatic int _da7213_set_component_pll(struct snd_soc_component *component,\n\t\t\t\t     int pll_id, int source,\n\t\t\t\t     unsigned int fref, unsigned int fout)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\n\tu8 pll_ctrl, indiv_bits, indiv;\n\tu8 pll_frac_top, pll_frac_bot, pll_integer;\n\tu32 freq_ref;\n\tu64 frac_div;\n\n\t \n\tif (da7213->mclk_rate == 32768) {\n\t\tif (!da7213->master) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"32KHz only valid if codec is clock master\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tindiv_bits = DA7213_PLL_INDIV_9_TO_18_MHZ;\n\t\tindiv = DA7213_PLL_INDIV_9_TO_18_MHZ_VAL;\n\t\tsource = DA7213_SYSCLK_PLL_32KHZ;\n\t\tfreq_ref = 3750000;\n\n\t} else {\n\t\tif (da7213->mclk_rate < 5000000) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"PLL input clock %d below valid range\\n\",\n\t\t\t\tda7213->mclk_rate);\n\t\t\treturn -EINVAL;\n\t\t} else if (da7213->mclk_rate <= 9000000) {\n\t\t\tindiv_bits = DA7213_PLL_INDIV_5_TO_9_MHZ;\n\t\t\tindiv = DA7213_PLL_INDIV_5_TO_9_MHZ_VAL;\n\t\t} else if (da7213->mclk_rate <= 18000000) {\n\t\t\tindiv_bits = DA7213_PLL_INDIV_9_TO_18_MHZ;\n\t\t\tindiv = DA7213_PLL_INDIV_9_TO_18_MHZ_VAL;\n\t\t} else if (da7213->mclk_rate <= 36000000) {\n\t\t\tindiv_bits = DA7213_PLL_INDIV_18_TO_36_MHZ;\n\t\t\tindiv = DA7213_PLL_INDIV_18_TO_36_MHZ_VAL;\n\t\t} else if (da7213->mclk_rate <= 54000000) {\n\t\t\tindiv_bits = DA7213_PLL_INDIV_36_TO_54_MHZ;\n\t\t\tindiv = DA7213_PLL_INDIV_36_TO_54_MHZ_VAL;\n\t\t} else {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"PLL input clock %d above valid range\\n\",\n\t\t\t\tda7213->mclk_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfreq_ref = (da7213->mclk_rate / indiv);\n\t}\n\n\tpll_ctrl = indiv_bits;\n\n\t \n\tswitch (source) {\n\tcase DA7213_SYSCLK_MCLK:\n\t\tsnd_soc_component_update_bits(component, DA7213_PLL_CTRL,\n\t\t\t\t    DA7213_PLL_INDIV_MASK |\n\t\t\t\t    DA7213_PLL_MODE_MASK, pll_ctrl);\n\t\treturn 0;\n\tcase DA7213_SYSCLK_PLL:\n\t\tbreak;\n\tcase DA7213_SYSCLK_PLL_SRM:\n\t\tpll_ctrl |= DA7213_PLL_SRM_EN;\n\t\tfout = DA7213_PLL_FREQ_OUT_94310400;\n\t\tbreak;\n\tcase DA7213_SYSCLK_PLL_32KHZ:\n\t\tif (da7213->mclk_rate != 32768) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"32KHz mode only valid with 32KHz MCLK\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpll_ctrl |= DA7213_PLL_32K_MODE | DA7213_PLL_SRM_EN;\n\t\tfout = DA7213_PLL_FREQ_OUT_94310400;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid PLL config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpll_integer = fout / freq_ref;\n\tfrac_div = (u64)(fout % freq_ref) * 8192ULL;\n\tdo_div(frac_div, freq_ref);\n\tpll_frac_top = (frac_div >> DA7213_BYTE_SHIFT) & DA7213_BYTE_MASK;\n\tpll_frac_bot = (frac_div) & DA7213_BYTE_MASK;\n\n\t \n\tsnd_soc_component_write(component, DA7213_PLL_FRAC_TOP, pll_frac_top);\n\tsnd_soc_component_write(component, DA7213_PLL_FRAC_BOT, pll_frac_bot);\n\tsnd_soc_component_write(component, DA7213_PLL_INTEGER, pll_integer);\n\n\t \n\tpll_ctrl |= DA7213_PLL_EN;\n\tsnd_soc_component_update_bits(component, DA7213_PLL_CTRL,\n\t\t\t    DA7213_PLL_INDIV_MASK | DA7213_PLL_MODE_MASK,\n\t\t\t    pll_ctrl);\n\n\t \n\tif (source == DA7213_SYSCLK_PLL_32KHZ) {\n\t\tsnd_soc_component_write(component, 0xF0, 0x8B);\n\t\tsnd_soc_component_write(component, 0xF1, 0x03);\n\t\tsnd_soc_component_write(component, 0xF1, 0x01);\n\t\tsnd_soc_component_write(component, 0xF0, 0x00);\n\t}\n\n\treturn 0;\n}\n\nstatic int da7213_set_component_pll(struct snd_soc_component *component,\n\t\t\t\t    int pll_id, int source,\n\t\t\t\t    unsigned int fref, unsigned int fout)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tda7213->fixed_clk_auto_pll = false;\n\n\treturn _da7213_set_component_pll(component, pll_id, source, fref, fout);\n}\n\n \nstatic const struct snd_soc_dai_ops da7213_dai_ops = {\n\t.hw_params\t= da7213_hw_params,\n\t.set_fmt\t= da7213_set_dai_fmt,\n\t.mute_stream\t= da7213_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver da7213_dai = {\n\t.name = \"da7213-hifi\",\n\t \n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = DA7213_FORMATS,\n\t},\n\t \n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = DA7213_FORMATS,\n\t},\n\t.ops = &da7213_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int da7213_set_auto_pll(struct snd_soc_component *component, bool enable)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tint mode;\n\n\tif (!da7213->fixed_clk_auto_pll)\n\t\treturn 0;\n\n\tda7213->mclk_rate = clk_get_rate(da7213->mclk);\n\n\tif (enable) {\n\t\t \n\t\tif (da7213->master)\n\t\t\tmode = DA7213_SYSCLK_PLL;\n\t\telse\n\t\t\tmode = DA7213_SYSCLK_PLL_SRM;\n\n\t\t \n\t\tswitch (da7213->out_rate) {\n\t\tcase DA7213_PLL_FREQ_OUT_90316800:\n\t\t\tif (da7213->mclk_rate == 11289600 ||\n\t\t\t    da7213->mclk_rate == 22579200 ||\n\t\t\t    da7213->mclk_rate == 45158400)\n\t\t\t\tmode = DA7213_SYSCLK_MCLK;\n\t\t\tbreak;\n\t\tcase DA7213_PLL_FREQ_OUT_98304000:\n\t\t\tif (da7213->mclk_rate == 12288000 ||\n\t\t\t    da7213->mclk_rate == 24576000 ||\n\t\t\t    da7213->mclk_rate == 49152000)\n\t\t\t\tmode = DA7213_SYSCLK_MCLK;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t \n\t\tmode = DA7213_SYSCLK_MCLK;\n\t}\n\n\treturn _da7213_set_component_pll(component, 0, mode,\n\t\t\t\t\t da7213->mclk_rate, da7213->out_rate);\n}\n\nstatic int da7213_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY) {\n\t\t\tif (da7213->mclk) {\n\t\t\t\tret = clk_prepare_enable(da7213->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable mclk\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tda7213_set_auto_pll(component, true);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, DA7213_REFERENCES,\n\t\t\t\t\t    DA7213_VMID_EN | DA7213_BIAS_EN,\n\t\t\t\t\t    DA7213_VMID_EN | DA7213_BIAS_EN);\n\t\t} else {\n\t\t\t \n\t\t\tif (da7213->mclk) {\n\t\t\t\tda7213_set_auto_pll(component, false);\n\t\t\t\tclk_disable_unprepare(da7213->mclk);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7213_REFERENCES,\n\t\t\t\t    DA7213_VMID_EN | DA7213_BIAS_EN, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\n \nstatic const struct of_device_id da7213_of_match[] = {\n\t{ .compatible = \"dlg,da7212\", },\n\t{ .compatible = \"dlg,da7213\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da7213_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id da7213_acpi_match[] = {\n\t{ \"DLGS7212\", 0},\n\t{ \"DLGS7213\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, da7213_acpi_match);\n#endif\n\nstatic enum da7213_micbias_voltage\n\tda7213_of_micbias_lvl(struct snd_soc_component *component, u32 val)\n{\n\tswitch (val) {\n\tcase 1600:\n\t\treturn DA7213_MICBIAS_1_6V;\n\tcase 2200:\n\t\treturn DA7213_MICBIAS_2_2V;\n\tcase 2500:\n\t\treturn DA7213_MICBIAS_2_5V;\n\tcase 3000:\n\t\treturn DA7213_MICBIAS_3_0V;\n\tdefault:\n\t\tdev_warn(component->dev, \"Invalid micbias level\\n\");\n\t\treturn DA7213_MICBIAS_2_2V;\n\t}\n}\n\nstatic enum da7213_dmic_data_sel\n\tda7213_of_dmic_data_sel(struct snd_soc_component *component, const char *str)\n{\n\tif (!strcmp(str, \"lrise_rfall\")) {\n\t\treturn DA7213_DMIC_DATA_LRISE_RFALL;\n\t} else if (!strcmp(str, \"lfall_rrise\")) {\n\t\treturn DA7213_DMIC_DATA_LFALL_RRISE;\n\t} else {\n\t\tdev_warn(component->dev, \"Invalid DMIC data select type\\n\");\n\t\treturn DA7213_DMIC_DATA_LRISE_RFALL;\n\t}\n}\n\nstatic enum da7213_dmic_samplephase\n\tda7213_of_dmic_samplephase(struct snd_soc_component *component, const char *str)\n{\n\tif (!strcmp(str, \"on_clkedge\")) {\n\t\treturn DA7213_DMIC_SAMPLE_ON_CLKEDGE;\n\t} else if (!strcmp(str, \"between_clkedge\")) {\n\t\treturn DA7213_DMIC_SAMPLE_BETWEEN_CLKEDGE;\n\t} else {\n\t\tdev_warn(component->dev, \"Invalid DMIC sample phase\\n\");\n\t\treturn DA7213_DMIC_SAMPLE_ON_CLKEDGE;\n\t}\n}\n\nstatic enum da7213_dmic_clk_rate\n\tda7213_of_dmic_clkrate(struct snd_soc_component *component, u32 val)\n{\n\tswitch (val) {\n\tcase 1500000:\n\t\treturn DA7213_DMIC_CLK_1_5MHZ;\n\tcase 3000000:\n\t\treturn DA7213_DMIC_CLK_3_0MHZ;\n\tdefault:\n\t\tdev_warn(component->dev, \"Invalid DMIC clock rate\\n\");\n\t\treturn DA7213_DMIC_CLK_1_5MHZ;\n\t}\n}\n\nstatic struct da7213_platform_data\n\t*da7213_fw_to_pdata(struct snd_soc_component *component)\n{\n\tstruct device *dev = component->dev;\n\tstruct da7213_platform_data *pdata;\n\tconst char *fw_str;\n\tu32 fw_val32;\n\n\tpdata = devm_kzalloc(component->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tif (device_property_read_u32(dev, \"dlg,micbias1-lvl\", &fw_val32) >= 0)\n\t\tpdata->micbias1_lvl = da7213_of_micbias_lvl(component, fw_val32);\n\telse\n\t\tpdata->micbias1_lvl = DA7213_MICBIAS_2_2V;\n\n\tif (device_property_read_u32(dev, \"dlg,micbias2-lvl\", &fw_val32) >= 0)\n\t\tpdata->micbias2_lvl = da7213_of_micbias_lvl(component, fw_val32);\n\telse\n\t\tpdata->micbias2_lvl = DA7213_MICBIAS_2_2V;\n\n\tif (!device_property_read_string(dev, \"dlg,dmic-data-sel\", &fw_str))\n\t\tpdata->dmic_data_sel = da7213_of_dmic_data_sel(component, fw_str);\n\telse\n\t\tpdata->dmic_data_sel = DA7213_DMIC_DATA_LRISE_RFALL;\n\n\tif (!device_property_read_string(dev, \"dlg,dmic-samplephase\", &fw_str))\n\t\tpdata->dmic_samplephase =\n\t\t\tda7213_of_dmic_samplephase(component, fw_str);\n\telse\n\t\tpdata->dmic_samplephase = DA7213_DMIC_SAMPLE_ON_CLKEDGE;\n\n\tif (device_property_read_u32(dev, \"dlg,dmic-clkrate\", &fw_val32) >= 0)\n\t\tpdata->dmic_clk_rate = da7213_of_dmic_clkrate(component, fw_val32);\n\telse\n\t\tpdata->dmic_clk_rate = DA7213_DMIC_CLK_3_0MHZ;\n\n\treturn pdata;\n}\n\nstatic int da7213_probe(struct snd_soc_component *component)\n{\n\tstruct da7213_priv *da7213 = snd_soc_component_get_drvdata(component);\n\n\tpm_runtime_get_sync(component->dev);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_ALC_CTRL1,\n\t\t\t    DA7213_ALC_CALIB_MODE_MAN, 0);\n\tda7213->alc_calib_auto = true;\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_PC_COUNT, DA7213_PC_FREERUN_MASK,\n\t\t\t    DA7213_PC_FREERUN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_AUX_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_AUX_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_ADC_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_ADC_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_DAC_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_DAC_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_HP_L_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_HP_R_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\tsnd_soc_component_update_bits(component, DA7213_LINE_CTRL,\n\t\t\t    DA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_L_CTRL,\n\t\t\t    DA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\n\tsnd_soc_component_update_bits(component, DA7213_MIXIN_R_CTRL,\n\t\t\t    DA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\n\n\tsnd_soc_component_update_bits(component, DA7213_MIXOUT_L_CTRL,\n\t\t\t    DA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\n\tsnd_soc_component_update_bits(component, DA7213_MIXOUT_R_CTRL,\n\t\t\t    DA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\n\n\tsnd_soc_component_update_bits(component, DA7213_HP_L_CTRL,\n\t\t\t    DA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\n\tsnd_soc_component_update_bits(component, DA7213_HP_R_CTRL,\n\t\t\t    DA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\n\n\tsnd_soc_component_update_bits(component, DA7213_LINE_CTRL,\n\t\t\t    DA7213_LINE_AMP_OE, DA7213_LINE_AMP_OE);\n\n\t \n\tda7213->pdata = dev_get_platdata(component->dev);\n\tif (!da7213->pdata)\n\t\tda7213->pdata = da7213_fw_to_pdata(component);\n\n\t \n\tif (da7213->pdata) {\n\t\tstruct da7213_platform_data *pdata = da7213->pdata;\n\t\tu8 micbias_lvl = 0, dmic_cfg = 0;\n\n\t\t \n\t\tswitch (pdata->micbias1_lvl) {\n\t\tcase DA7213_MICBIAS_1_6V:\n\t\tcase DA7213_MICBIAS_2_2V:\n\t\tcase DA7213_MICBIAS_2_5V:\n\t\tcase DA7213_MICBIAS_3_0V:\n\t\t\tmicbias_lvl |= (pdata->micbias1_lvl <<\n\t\t\t\t\tDA7213_MICBIAS1_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (pdata->micbias2_lvl) {\n\t\tcase DA7213_MICBIAS_1_6V:\n\t\tcase DA7213_MICBIAS_2_2V:\n\t\tcase DA7213_MICBIAS_2_5V:\n\t\tcase DA7213_MICBIAS_3_0V:\n\t\t\tmicbias_lvl |= (pdata->micbias2_lvl <<\n\t\t\t\t\t DA7213_MICBIAS2_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tsnd_soc_component_update_bits(component, DA7213_MICBIAS_CTRL,\n\t\t\t\t    DA7213_MICBIAS1_LEVEL_MASK |\n\t\t\t\t    DA7213_MICBIAS2_LEVEL_MASK, micbias_lvl);\n\n\t\t \n\t\tswitch (pdata->dmic_data_sel) {\n\t\tcase DA7213_DMIC_DATA_LFALL_RRISE:\n\t\tcase DA7213_DMIC_DATA_LRISE_RFALL:\n\t\t\tdmic_cfg |= (pdata->dmic_data_sel <<\n\t\t\t\t     DA7213_DMIC_DATA_SEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (pdata->dmic_samplephase) {\n\t\tcase DA7213_DMIC_SAMPLE_ON_CLKEDGE:\n\t\tcase DA7213_DMIC_SAMPLE_BETWEEN_CLKEDGE:\n\t\t\tdmic_cfg |= (pdata->dmic_samplephase <<\n\t\t\t\t     DA7213_DMIC_SAMPLEPHASE_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tswitch (pdata->dmic_clk_rate) {\n\t\tcase DA7213_DMIC_CLK_3_0MHZ:\n\t\tcase DA7213_DMIC_CLK_1_5MHZ:\n\t\t\tdmic_cfg |= (pdata->dmic_clk_rate <<\n\t\t\t\t     DA7213_DMIC_CLK_RATE_SHIFT);\n\t\t\tbreak;\n\t\t}\n\t\tsnd_soc_component_update_bits(component, DA7213_MIC_CONFIG,\n\t\t\t\t    DA7213_DMIC_DATA_SEL_MASK |\n\t\t\t\t    DA7213_DMIC_SAMPLEPHASE_MASK |\n\t\t\t\t    DA7213_DMIC_CLK_RATE_MASK, dmic_cfg);\n\t}\n\n\tpm_runtime_put_sync(component->dev);\n\n\t \n\tda7213->mclk = devm_clk_get(component->dev, \"mclk\");\n\tif (IS_ERR(da7213->mclk)) {\n\t\tif (PTR_ERR(da7213->mclk) != -ENOENT)\n\t\t\treturn PTR_ERR(da7213->mclk);\n\t\telse\n\t\t\tda7213->mclk = NULL;\n\t} else {\n\t\t \n\t\tda7213->fixed_clk_auto_pll = true;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_da7213 = {\n\t.probe\t\t\t= da7213_probe,\n\t.set_bias_level\t\t= da7213_set_bias_level,\n\t.controls\t\t= da7213_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(da7213_snd_controls),\n\t.dapm_widgets\t\t= da7213_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(da7213_dapm_widgets),\n\t.dapm_routes\t\t= da7213_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(da7213_audio_map),\n\t.set_sysclk\t\t= da7213_set_component_sysclk,\n\t.set_pll\t\t= da7213_set_component_pll,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config da7213_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.reg_defaults = da7213_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(da7213_reg_defaults),\n\t.volatile_reg = da7213_volatile_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic void da7213_power_off(void *data)\n{\n\tstruct da7213_priv *da7213 = data;\n\tregulator_bulk_disable(DA7213_NUM_SUPPLIES, da7213->supplies);\n}\n\nstatic const char *da7213_supply_names[DA7213_NUM_SUPPLIES] = {\n\t[DA7213_SUPPLY_VDDA] = \"VDDA\",\n\t[DA7213_SUPPLY_VDDIO] = \"VDDIO\",\n};\n\nstatic int da7213_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct da7213_priv *da7213;\n\tint i, ret;\n\n\tda7213 = devm_kzalloc(&i2c->dev, sizeof(*da7213), GFP_KERNEL);\n\tif (!da7213)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, da7213);\n\n\t \n\tfor (i = 0; i < DA7213_NUM_SUPPLIES; ++i)\n\t\tda7213->supplies[i].supply = da7213_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, DA7213_NUM_SUPPLIES,\n\t\t\t\t      da7213->supplies);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(DA7213_NUM_SUPPLIES, da7213->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = devm_add_action_or_reset(&i2c->dev, da7213_power_off, da7213);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tda7213->regmap = devm_regmap_init_i2c(i2c, &da7213_regmap_config);\n\tif (IS_ERR(da7213->regmap)) {\n\t\tret = PTR_ERR(da7213->regmap);\n\t\tdev_err(&i2c->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_autosuspend_delay(&i2c->dev, 100);\n\tpm_runtime_use_autosuspend(&i2c->dev);\n\tpm_runtime_set_active(&i2c->dev);\n\tpm_runtime_enable(&i2c->dev);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_da7213, &da7213_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register da7213 component: %d\\n\",\n\t\t\tret);\n\t}\n\treturn ret;\n}\n\nstatic void da7213_i2c_remove(struct i2c_client *i2c)\n{\n\tpm_runtime_disable(&i2c->dev);\n}\n\nstatic int __maybe_unused da7213_runtime_suspend(struct device *dev)\n{\n\tstruct da7213_priv *da7213 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(da7213->regmap, true);\n\tregcache_mark_dirty(da7213->regmap);\n\tregulator_bulk_disable(DA7213_NUM_SUPPLIES, da7213->supplies);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused da7213_runtime_resume(struct device *dev)\n{\n\tstruct da7213_priv *da7213 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(DA7213_NUM_SUPPLIES, da7213->supplies);\n\tif (ret < 0)\n\t\treturn ret;\n\tregcache_cache_only(da7213->regmap, false);\n\tregcache_sync(da7213->regmap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops da7213_pm = {\n\tSET_RUNTIME_PM_OPS(da7213_runtime_suspend, da7213_runtime_resume, NULL)\n};\n\nstatic const struct i2c_device_id da7213_i2c_id[] = {\n\t{ \"da7213\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, da7213_i2c_id);\n\n \nstatic struct i2c_driver da7213_i2c_driver = {\n\t.driver = {\n\t\t.name = \"da7213\",\n\t\t.of_match_table = of_match_ptr(da7213_of_match),\n\t\t.acpi_match_table = ACPI_PTR(da7213_acpi_match),\n\t\t.pm = &da7213_pm,\n\t},\n\t.probe\t\t= da7213_i2c_probe,\n\t.remove\t\t= da7213_i2c_remove,\n\t.id_table\t= da7213_i2c_id,\n};\n\nmodule_i2c_driver(da7213_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC DA7213 Codec driver\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}