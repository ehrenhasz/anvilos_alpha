{
  "module_name": "wm8960.c",
  "hash_id": "c0f5a3bc450c2b1a198168de757678155d0e4fca6575bdcc13825e502ecdd0a5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8960.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/wm8960.h>\n\n#include \"wm8960.h\"\n\n \n#define WM8960_VMID_MASK 0x180\n#define WM8960_VREF      0x40\n\n \n#define WM8960_PWR2_LOUT1\t0x40\n#define WM8960_PWR2_ROUT1\t0x20\n#define WM8960_PWR2_OUT3\t0x02\n\n \n#define WM8960_POBCTRL   0x80\n#define WM8960_BUFDCOPEN 0x10\n#define WM8960_BUFIOEN   0x08\n#define WM8960_SOFT_ST   0x04\n#define WM8960_HPSTBY    0x01\n\n \n#define WM8960_DISOP     0x40\n#define WM8960_DRES_MASK 0x30\n\n#define WM8960_DSCH_TOUT\t600  \n\nstatic bool is_pll_freq_available(unsigned int source, unsigned int target);\nstatic int wm8960_set_pll(struct snd_soc_component *component,\n\t\tunsigned int freq_in, unsigned int freq_out);\n \nstatic const struct reg_default wm8960_reg_defaults[] = {\n\t{  0x0, 0x00a7 },\n\t{  0x1, 0x00a7 },\n\t{  0x2, 0x0000 },\n\t{  0x3, 0x0000 },\n\t{  0x4, 0x0000 },\n\t{  0x5, 0x0008 },\n\t{  0x6, 0x0000 },\n\t{  0x7, 0x000a },\n\t{  0x8, 0x01c0 },\n\t{  0x9, 0x0000 },\n\t{  0xa, 0x00ff },\n\t{  0xb, 0x00ff },\n\n\t{ 0x10, 0x0000 },\n\t{ 0x11, 0x007b },\n\t{ 0x12, 0x0100 },\n\t{ 0x13, 0x0032 },\n\t{ 0x14, 0x0000 },\n\t{ 0x15, 0x00c3 },\n\t{ 0x16, 0x00c3 },\n\t{ 0x17, 0x01c0 },\n\t{ 0x18, 0x0000 },\n\t{ 0x19, 0x0000 },\n\t{ 0x1a, 0x0000 },\n\t{ 0x1b, 0x0000 },\n\t{ 0x1c, 0x0000 },\n\t{ 0x1d, 0x0000 },\n\n\t{ 0x20, 0x0100 },\n\t{ 0x21, 0x0100 },\n\t{ 0x22, 0x0050 },\n\n\t{ 0x25, 0x0050 },\n\t{ 0x26, 0x0000 },\n\t{ 0x27, 0x0000 },\n\t{ 0x28, 0x0000 },\n\t{ 0x29, 0x0000 },\n\t{ 0x2a, 0x0040 },\n\t{ 0x2b, 0x0000 },\n\t{ 0x2c, 0x0000 },\n\t{ 0x2d, 0x0050 },\n\t{ 0x2e, 0x0050 },\n\t{ 0x2f, 0x0000 },\n\t{ 0x30, 0x0002 },\n\t{ 0x31, 0x0037 },\n\n\t{ 0x33, 0x0080 },\n\t{ 0x34, 0x0008 },\n\t{ 0x35, 0x0031 },\n\t{ 0x36, 0x0026 },\n\t{ 0x37, 0x00e9 },\n};\n\nstatic bool wm8960_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8960_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define WM8960_NUM_SUPPLIES 5\nstatic const char *wm8960_supply_names[WM8960_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"AVDD\",\n\t\"SPKVDD1\",\n\t\"SPKVDD2\",\n};\n\nstruct wm8960_priv {\n\tstruct clk *mclk;\n\tstruct regmap *regmap;\n\tint (*set_bias_level)(struct snd_soc_component *,\n\t\t\t      enum snd_soc_bias_level level);\n\tstruct snd_soc_dapm_widget *lout1;\n\tstruct snd_soc_dapm_widget *rout1;\n\tstruct snd_soc_dapm_widget *out3;\n\tbool deemph;\n\tint lrclk;\n\tint bclk;\n\tint sysclk;\n\tint clk_id;\n\tint freq_in;\n\tbool is_stream_in_use[2];\n\tstruct wm8960_data pdata;\n\tktime_t dsch_start;\n\tstruct regulator_bulk_data supplies[WM8960_NUM_SUPPLIES];\n};\n\n#define wm8960_reset(c)\tregmap_write(c, WM8960_RESET, 0)\n\n \nstatic const char *wm8960_polarity[] = {\"No Inversion\", \"Left Inverted\",\n\t\"Right Inverted\", \"Stereo Inversion\"};\nstatic const char *wm8960_3d_upper_cutoff[] = {\"High\", \"Low\"};\nstatic const char *wm8960_3d_lower_cutoff[] = {\"Low\", \"High\"};\nstatic const char *wm8960_alcfunc[] = {\"Off\", \"Right\", \"Left\", \"Stereo\"};\nstatic const char *wm8960_alcmode[] = {\"ALC\", \"Limiter\"};\nstatic const char *wm8960_adc_data_output_sel[] = {\n\t\"Left Data = Left ADC;  Right Data = Right ADC\",\n\t\"Left Data = Left ADC;  Right Data = Left ADC\",\n\t\"Left Data = Right ADC; Right Data = Right ADC\",\n\t\"Left Data = Right ADC; Right Data = Left ADC\",\n};\nstatic const char *wm8960_dmonomix[] = {\"Stereo\", \"Mono\"};\nstatic const char *wm8960_dacslope[] = {\"Normal\", \"Sloping\"};\n\nstatic const struct soc_enum wm8960_enum[] = {\n\tSOC_ENUM_SINGLE(WM8960_DACCTL1, 5, 4, wm8960_polarity),\n\tSOC_ENUM_SINGLE(WM8960_DACCTL2, 5, 4, wm8960_polarity),\n\tSOC_ENUM_SINGLE(WM8960_3D, 6, 2, wm8960_3d_upper_cutoff),\n\tSOC_ENUM_SINGLE(WM8960_3D, 5, 2, wm8960_3d_lower_cutoff),\n\tSOC_ENUM_SINGLE(WM8960_ALC1, 7, 4, wm8960_alcfunc),\n\tSOC_ENUM_SINGLE(WM8960_ALC3, 8, 2, wm8960_alcmode),\n\tSOC_ENUM_SINGLE(WM8960_ADDCTL1, 2, 4, wm8960_adc_data_output_sel),\n\tSOC_ENUM_SINGLE(WM8960_ADDCTL1, 4, 2, wm8960_dmonomix),\n\tSOC_ENUM_SINGLE(WM8960_DACCTL2, 1, 2, wm8960_dacslope),\n};\n\nstatic const int deemph_settings[] = { 0, 32000, 44100, 48000 };\n\nstatic int wm8960_set_deemph(struct snd_soc_component *component)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (wm8960->deemph) {\n\t\tbest = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\n\t\t\tif (abs(deemph_settings[i] - wm8960->lrclk) <\n\t\t\t    abs(deemph_settings[best] - wm8960->lrclk))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = best << 1;\n\t} else {\n\t\tval = 0;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d\\n\", val);\n\n\treturn snd_soc_component_update_bits(component, WM8960_DACCTL1,\n\t\t\t\t   0x6, val);\n}\n\nstatic int wm8960_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8960->deemph;\n\treturn 0;\n}\n\nstatic int wm8960_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\twm8960->deemph = deemph;\n\n\treturn wm8960_set_deemph(component);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -9750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(inpga_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -2100, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -12100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(lineinboost_tlv, -1500, 300, 1);\nstatic const SNDRV_CTL_TLVD_DECLARE_DB_RANGE(micboost_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(0, 1300, 0),\n\t2, 3, TLV_DB_SCALE_ITEM(2000, 900, 0),\n);\n\nstatic const struct snd_kcontrol_new wm8960_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8960_LINVOL, WM8960_RINVOL,\n\t\t 0, 63, 0, inpga_tlv),\nSOC_DOUBLE_R(\"Capture Volume ZC Switch\", WM8960_LINVOL, WM8960_RINVOL,\n\t6, 1, 0),\nSOC_DOUBLE_R(\"Capture Switch\", WM8960_LINVOL, WM8960_RINVOL,\n\t7, 1, 1),\n\nSOC_SINGLE_TLV(\"Left Input Boost Mixer LINPUT3 Volume\",\n\t       WM8960_INBMIX1, 4, 7, 0, lineinboost_tlv),\nSOC_SINGLE_TLV(\"Left Input Boost Mixer LINPUT2 Volume\",\n\t       WM8960_INBMIX1, 1, 7, 0, lineinboost_tlv),\nSOC_SINGLE_TLV(\"Right Input Boost Mixer RINPUT3 Volume\",\n\t       WM8960_INBMIX2, 4, 7, 0, lineinboost_tlv),\nSOC_SINGLE_TLV(\"Right Input Boost Mixer RINPUT2 Volume\",\n\t       WM8960_INBMIX2, 1, 7, 0, lineinboost_tlv),\nSOC_SINGLE_TLV(\"Right Input Boost Mixer RINPUT1 Volume\",\n\t\tWM8960_RINPATH, 4, 3, 0, micboost_tlv),\nSOC_SINGLE_TLV(\"Left Input Boost Mixer LINPUT1 Volume\",\n\t\tWM8960_LINPATH, 4, 3, 0, micboost_tlv),\n\nSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8960_LDAC, WM8960_RDAC,\n\t\t 0, 255, 0, dac_tlv),\n\nSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", WM8960_LOUT1, WM8960_ROUT1,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Headphone Playback ZC Switch\", WM8960_LOUT1, WM8960_ROUT1,\n\t7, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Speaker Playback Volume\", WM8960_LOUT2, WM8960_ROUT2,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R(\"Speaker Playback ZC Switch\", WM8960_LOUT2, WM8960_ROUT2,\n\t7, 1, 0),\nSOC_SINGLE(\"Speaker DC Volume\", WM8960_CLASSD3, 3, 5, 0),\nSOC_SINGLE(\"Speaker AC Volume\", WM8960_CLASSD3, 0, 5, 0),\n\nSOC_SINGLE(\"PCM Playback -6dB Switch\", WM8960_DACCTL1, 7, 1, 0),\nSOC_ENUM(\"ADC Polarity\", wm8960_enum[0]),\nSOC_SINGLE(\"ADC High Pass Filter Switch\", WM8960_DACCTL1, 0, 1, 0),\n\nSOC_ENUM(\"DAC Polarity\", wm8960_enum[1]),\nSOC_SINGLE_BOOL_EXT(\"DAC Deemphasis Switch\", 0,\n\t\t    wm8960_get_deemph, wm8960_put_deemph),\n\nSOC_ENUM(\"3D Filter Upper Cut-Off\", wm8960_enum[2]),\nSOC_ENUM(\"3D Filter Lower Cut-Off\", wm8960_enum[3]),\nSOC_SINGLE(\"3D Volume\", WM8960_3D, 1, 15, 0),\nSOC_SINGLE(\"3D Switch\", WM8960_3D, 0, 1, 0),\n\nSOC_ENUM(\"ALC Function\", wm8960_enum[4]),\nSOC_SINGLE(\"ALC Max Gain\", WM8960_ALC1, 4, 7, 0),\nSOC_SINGLE(\"ALC Target\", WM8960_ALC1, 0, 15, 1),\nSOC_SINGLE(\"ALC Min Gain\", WM8960_ALC2, 4, 7, 0),\nSOC_SINGLE(\"ALC Hold Time\", WM8960_ALC2, 0, 15, 0),\nSOC_ENUM(\"ALC Mode\", wm8960_enum[5]),\nSOC_SINGLE(\"ALC Decay\", WM8960_ALC3, 4, 15, 0),\nSOC_SINGLE(\"ALC Attack\", WM8960_ALC3, 0, 15, 0),\n\nSOC_SINGLE(\"Noise Gate Threshold\", WM8960_NOISEG, 3, 31, 0),\nSOC_SINGLE(\"Noise Gate Switch\", WM8960_NOISEG, 0, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"ADC PCM Capture Volume\", WM8960_LADC, WM8960_RADC,\n\t0, 255, 0, adc_tlv),\n\nSOC_SINGLE_TLV(\"Left Output Mixer Boost Bypass Volume\",\n\t       WM8960_BYPASS1, 4, 7, 1, bypass_tlv),\nSOC_SINGLE_TLV(\"Left Output Mixer LINPUT3 Volume\",\n\t       WM8960_LOUTMIX, 4, 7, 1, bypass_tlv),\nSOC_SINGLE_TLV(\"Right Output Mixer Boost Bypass Volume\",\n\t       WM8960_BYPASS2, 4, 7, 1, bypass_tlv),\nSOC_SINGLE_TLV(\"Right Output Mixer RINPUT3 Volume\",\n\t       WM8960_ROUTMIX, 4, 7, 1, bypass_tlv),\n\nSOC_ENUM(\"ADC Data Output Select\", wm8960_enum[6]),\nSOC_ENUM(\"DAC Mono Mix\", wm8960_enum[7]),\nSOC_ENUM(\"DAC Filter Characteristics\", wm8960_enum[8]),\n};\n\nstatic const struct snd_kcontrol_new wm8960_lin_boost[] = {\nSOC_DAPM_SINGLE(\"LINPUT2 Switch\", WM8960_LINPATH, 6, 1, 0),\nSOC_DAPM_SINGLE(\"LINPUT3 Switch\", WM8960_LINPATH, 7, 1, 0),\nSOC_DAPM_SINGLE(\"LINPUT1 Switch\", WM8960_LINPATH, 8, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_lin[] = {\nSOC_DAPM_SINGLE(\"Boost Switch\", WM8960_LINPATH, 3, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_rin_boost[] = {\nSOC_DAPM_SINGLE(\"RINPUT2 Switch\", WM8960_RINPATH, 6, 1, 0),\nSOC_DAPM_SINGLE(\"RINPUT3 Switch\", WM8960_RINPATH, 7, 1, 0),\nSOC_DAPM_SINGLE(\"RINPUT1 Switch\", WM8960_RINPATH, 8, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_rin[] = {\nSOC_DAPM_SINGLE(\"Boost Switch\", WM8960_RINPATH, 3, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_loutput_mixer[] = {\nSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8960_LOUTMIX, 8, 1, 0),\nSOC_DAPM_SINGLE(\"LINPUT3 Switch\", WM8960_LOUTMIX, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Boost Bypass Switch\", WM8960_BYPASS1, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_routput_mixer[] = {\nSOC_DAPM_SINGLE(\"PCM Playback Switch\", WM8960_ROUTMIX, 8, 1, 0),\nSOC_DAPM_SINGLE(\"RINPUT3 Switch\", WM8960_ROUTMIX, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Boost Bypass Switch\", WM8960_BYPASS2, 7, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8960_mono_out[] = {\nSOC_DAPM_SINGLE(\"Left Switch\", WM8960_MONOMIX1, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Right Switch\", WM8960_MONOMIX2, 7, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8960_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"LINPUT1\"),\nSND_SOC_DAPM_INPUT(\"RINPUT1\"),\nSND_SOC_DAPM_INPUT(\"LINPUT2\"),\nSND_SOC_DAPM_INPUT(\"RINPUT2\"),\nSND_SOC_DAPM_INPUT(\"LINPUT3\"),\nSND_SOC_DAPM_INPUT(\"RINPUT3\"),\n\nSND_SOC_DAPM_SUPPLY(\"MICB\", WM8960_POWER1, 1, 0, NULL, 0),\n\nSND_SOC_DAPM_MIXER(\"Left Boost Mixer\", WM8960_POWER1, 5, 0,\n\t\t   wm8960_lin_boost, ARRAY_SIZE(wm8960_lin_boost)),\nSND_SOC_DAPM_MIXER(\"Right Boost Mixer\", WM8960_POWER1, 4, 0,\n\t\t   wm8960_rin_boost, ARRAY_SIZE(wm8960_rin_boost)),\n\nSND_SOC_DAPM_MIXER(\"Left Input Mixer\", WM8960_POWER3, 5, 0,\n\t\t   wm8960_lin, ARRAY_SIZE(wm8960_lin)),\nSND_SOC_DAPM_MIXER(\"Right Input Mixer\", WM8960_POWER3, 4, 0,\n\t\t   wm8960_rin, ARRAY_SIZE(wm8960_rin)),\n\nSND_SOC_DAPM_ADC(\"Left ADC\", \"Capture\", WM8960_POWER1, 3, 0),\nSND_SOC_DAPM_ADC(\"Right ADC\", \"Capture\", WM8960_POWER1, 2, 0),\n\nSND_SOC_DAPM_DAC(\"Left DAC\", \"Playback\", WM8960_POWER2, 8, 0),\nSND_SOC_DAPM_DAC(\"Right DAC\", \"Playback\", WM8960_POWER2, 7, 0),\n\nSND_SOC_DAPM_MIXER(\"Left Output Mixer\", WM8960_POWER3, 3, 0,\n\t&wm8960_loutput_mixer[0],\n\tARRAY_SIZE(wm8960_loutput_mixer)),\nSND_SOC_DAPM_MIXER(\"Right Output Mixer\", WM8960_POWER3, 2, 0,\n\t&wm8960_routput_mixer[0],\n\tARRAY_SIZE(wm8960_routput_mixer)),\n\nSND_SOC_DAPM_PGA(\"LOUT1 PGA\", WM8960_POWER2, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"ROUT1 PGA\", WM8960_POWER2, 5, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"Left Speaker PGA\", WM8960_POWER2, 4, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Speaker PGA\", WM8960_POWER2, 3, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"Right Speaker Output\", WM8960_CLASSD1, 7, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Left Speaker Output\", WM8960_CLASSD1, 6, 0, NULL, 0),\n\nSND_SOC_DAPM_OUTPUT(\"SPK_LP\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_LN\"),\nSND_SOC_DAPM_OUTPUT(\"HP_L\"),\nSND_SOC_DAPM_OUTPUT(\"HP_R\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_RP\"),\nSND_SOC_DAPM_OUTPUT(\"SPK_RN\"),\nSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n};\n\nstatic const struct snd_soc_dapm_widget wm8960_dapm_widgets_out3[] = {\nSND_SOC_DAPM_MIXER(\"Mono Output Mixer\", WM8960_POWER2, 1, 0,\n\t&wm8960_mono_out[0],\n\tARRAY_SIZE(wm8960_mono_out)),\n};\n\n \nstatic const struct snd_soc_dapm_widget wm8960_dapm_widgets_capless[] = {\nSND_SOC_DAPM_PGA(\"OUT3 VMID\", WM8960_POWER2, 1, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route audio_paths[] = {\n\t{ \"Left Boost Mixer\", \"LINPUT1 Switch\", \"LINPUT1\" },\n\t{ \"Left Boost Mixer\", \"LINPUT2 Switch\", \"LINPUT2\" },\n\t{ \"Left Boost Mixer\", \"LINPUT3 Switch\", \"LINPUT3\" },\n\n\t{ \"Left Input Mixer\", \"Boost Switch\", \"Left Boost Mixer\" },\n\t{ \"Left Input Mixer\", \"Boost Switch\", \"LINPUT1\" },   \n\t{ \"Left Input Mixer\", NULL, \"LINPUT2\" },\n\t{ \"Left Input Mixer\", NULL, \"LINPUT3\" },\n\n\t{ \"Right Boost Mixer\", \"RINPUT1 Switch\", \"RINPUT1\" },\n\t{ \"Right Boost Mixer\", \"RINPUT2 Switch\", \"RINPUT2\" },\n\t{ \"Right Boost Mixer\", \"RINPUT3 Switch\", \"RINPUT3\" },\n\n\t{ \"Right Input Mixer\", \"Boost Switch\", \"Right Boost Mixer\" },\n\t{ \"Right Input Mixer\", \"Boost Switch\", \"RINPUT1\" },   \n\t{ \"Right Input Mixer\", NULL, \"RINPUT2\" },\n\t{ \"Right Input Mixer\", NULL, \"RINPUT3\" },\n\n\t{ \"Left ADC\", NULL, \"Left Input Mixer\" },\n\t{ \"Right ADC\", NULL, \"Right Input Mixer\" },\n\n\t{ \"Left Output Mixer\", \"LINPUT3 Switch\", \"LINPUT3\" },\n\t{ \"Left Output Mixer\", \"Boost Bypass Switch\", \"Left Boost Mixer\" },\n\t{ \"Left Output Mixer\", \"PCM Playback Switch\", \"Left DAC\" },\n\n\t{ \"Right Output Mixer\", \"RINPUT3 Switch\", \"RINPUT3\" },\n\t{ \"Right Output Mixer\", \"Boost Bypass Switch\", \"Right Boost Mixer\" },\n\t{ \"Right Output Mixer\", \"PCM Playback Switch\", \"Right DAC\" },\n\n\t{ \"LOUT1 PGA\", NULL, \"Left Output Mixer\" },\n\t{ \"ROUT1 PGA\", NULL, \"Right Output Mixer\" },\n\n\t{ \"HP_L\", NULL, \"LOUT1 PGA\" },\n\t{ \"HP_R\", NULL, \"ROUT1 PGA\" },\n\n\t{ \"Left Speaker PGA\", NULL, \"Left Output Mixer\" },\n\t{ \"Right Speaker PGA\", NULL, \"Right Output Mixer\" },\n\n\t{ \"Left Speaker Output\", NULL, \"Left Speaker PGA\" },\n\t{ \"Right Speaker Output\", NULL, \"Right Speaker PGA\" },\n\n\t{ \"SPK_LN\", NULL, \"Left Speaker Output\" },\n\t{ \"SPK_LP\", NULL, \"Left Speaker Output\" },\n\t{ \"SPK_RN\", NULL, \"Right Speaker Output\" },\n\t{ \"SPK_RP\", NULL, \"Right Speaker Output\" },\n};\n\nstatic const struct snd_soc_dapm_route audio_paths_out3[] = {\n\t{ \"Mono Output Mixer\", \"Left Switch\", \"Left Output Mixer\" },\n\t{ \"Mono Output Mixer\", \"Right Switch\", \"Right Output Mixer\" },\n\n\t{ \"OUT3\", NULL, \"Mono Output Mixer\", }\n};\n\nstatic const struct snd_soc_dapm_route audio_paths_capless[] = {\n\t{ \"HP_L\", NULL, \"OUT3 VMID\" },\n\t{ \"HP_R\", NULL, \"OUT3 VMID\" },\n\n\t{ \"OUT3 VMID\", NULL, \"Left Output Mixer\" },\n\t{ \"OUT3 VMID\", NULL, \"Right Output Mixer\" },\n};\n\nstatic int wm8960_add_widgets(struct snd_soc_component *component)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tstruct wm8960_data *pdata = &wm8960->pdata;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct snd_soc_dapm_widget *w;\n\n\tsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(wm8960_dapm_widgets));\n\n\tsnd_soc_dapm_add_routes(dapm, audio_paths, ARRAY_SIZE(audio_paths));\n\n\t \n\tif (pdata && pdata->capless) {\n\t\tsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_capless,\n\t\t\t\t\t  ARRAY_SIZE(wm8960_dapm_widgets_capless));\n\n\t\tsnd_soc_dapm_add_routes(dapm, audio_paths_capless,\n\t\t\t\t\tARRAY_SIZE(audio_paths_capless));\n\t} else {\n\t\tsnd_soc_dapm_new_controls(dapm, wm8960_dapm_widgets_out3,\n\t\t\t\t\t  ARRAY_SIZE(wm8960_dapm_widgets_out3));\n\n\t\tsnd_soc_dapm_add_routes(dapm, audio_paths_out3,\n\t\t\t\t\tARRAY_SIZE(audio_paths_out3));\n\t}\n\n\t \n\tlist_for_each_entry(w, &component->card->widgets, list) {\n\t\tif (w->dapm != dapm)\n\t\t\tcontinue;\n\t\tif (strcmp(w->name, \"LOUT1 PGA\") == 0)\n\t\t\twm8960->lout1 = w;\n\t\tif (strcmp(w->name, \"ROUT1 PGA\") == 0)\n\t\t\twm8960->rout1 = w;\n\t\tif (strcmp(w->name, \"OUT3 VMID\") == 0)\n\t\t\twm8960->out3 = w;\n\t}\n\t\n\treturn 0;\n}\n\nstatic int wm8960_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 iface = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tiface |= 0x0040;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0090;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8960_IFACE1, iface);\n\treturn 0;\n}\n\nstatic struct {\n\tint rate;\n\tunsigned int val;\n} alc_rates[] = {\n\t{ 48000, 0 },\n\t{ 44100, 0 },\n\t{ 32000, 1 },\n\t{ 22050, 2 },\n\t{ 24000, 2 },\n\t{ 16000, 3 },\n\t{ 11025, 4 },\n\t{ 12000, 4 },\n\t{  8000, 5 },\n};\n\n \nstatic const int sysclk_divs[] = { 1, -1, 2, -1 };\n\n \nstatic const int dac_divs[] = { 256, 384, 512, 768, 1024, 1408, 1536 };\n\n \nstatic const int bclk_divs[] = {\n\t10, 15, 20, 30, 40, 55, 60, 80, 110,\n\t120, 160, 220, 240, 320, 320, 320\n};\n\n \nstatic\nint wm8960_configure_sysclk(struct wm8960_priv *wm8960, int mclk,\n\t\t\t    int *sysclk_idx, int *dac_idx, int *bclk_idx)\n{\n\tint sysclk, bclk, lrclk;\n\tint i, j, k;\n\tint diff;\n\n\t \n\t*bclk_idx = -1;\n\n\tbclk = wm8960->bclk;\n\tlrclk = wm8960->lrclk;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sysclk_divs); ++i) {\n\t\tif (sysclk_divs[i] == -1)\n\t\t\tcontinue;\n\t\tsysclk = mclk / sysclk_divs[i];\n\t\tfor (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {\n\t\t\tif (sysclk != dac_divs[j] * lrclk)\n\t\t\t\tcontinue;\n\t\t\tfor (k = 0; k < ARRAY_SIZE(bclk_divs); ++k) {\n\t\t\t\tdiff = sysclk - bclk * bclk_divs[k] / 10;\n\t\t\t\tif (diff == 0) {\n\t\t\t\t\t*sysclk_idx = i;\n\t\t\t\t\t*dac_idx = j;\n\t\t\t\t\t*bclk_idx = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (k != ARRAY_SIZE(bclk_divs))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j != ARRAY_SIZE(dac_divs))\n\t\t\tbreak;\n\t}\n\treturn *bclk_idx;\n}\n\n \nstatic\nint wm8960_configure_pll(struct snd_soc_component *component, int freq_in,\n\t\t\t int *sysclk_idx, int *dac_idx, int *bclk_idx)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tint sysclk, bclk, lrclk, freq_out;\n\tint diff, closest, best_freq_out;\n\tint i, j, k;\n\n\tbclk = wm8960->bclk;\n\tlrclk = wm8960->lrclk;\n\tclosest = freq_in;\n\n\tbest_freq_out = -EINVAL;\n\t*sysclk_idx = *dac_idx = *bclk_idx = -1;\n\n\t \n\tfor (i = ARRAY_SIZE(sysclk_divs) - 1; i >= 0; --i) {\n\t\tif (sysclk_divs[i] == -1)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {\n\t\t\tsysclk = lrclk * dac_divs[j];\n\t\t\tfreq_out = sysclk * sysclk_divs[i];\n\n\t\t\tfor (k = 0; k < ARRAY_SIZE(bclk_divs); ++k) {\n\t\t\t\tif (!is_pll_freq_available(freq_in, freq_out))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdiff = sysclk - bclk * bclk_divs[k] / 10;\n\t\t\t\tif (diff == 0) {\n\t\t\t\t\t*sysclk_idx = i;\n\t\t\t\t\t*dac_idx = j;\n\t\t\t\t\t*bclk_idx = k;\n\t\t\t\t\treturn freq_out;\n\t\t\t\t}\n\t\t\t\tif (diff > 0 && closest > diff) {\n\t\t\t\t\t*sysclk_idx = i;\n\t\t\t\t\t*dac_idx = j;\n\t\t\t\t\t*bclk_idx = k;\n\t\t\t\t\tclosest = diff;\n\t\t\t\t\tbest_freq_out = freq_out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn best_freq_out;\n}\nstatic int wm8960_configure_clocking(struct snd_soc_component *component)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tint freq_out, freq_in;\n\tu16 iface1 = snd_soc_component_read(component, WM8960_IFACE1);\n\tint i, j, k;\n\tint ret;\n\n\t \n\tif (!(iface1 & (1 << 6)) && !wm8960->sysclk) {\n\t\tdev_warn(component->dev,\n\t\t\t \"slave mode, but proceeding with no clock configuration\\n\");\n\t\treturn 0;\n\t}\n\n\tif (wm8960->clk_id != WM8960_SYSCLK_MCLK && !wm8960->freq_in) {\n\t\tdev_err(component->dev, \"No MCLK configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfreq_in = wm8960->freq_in;\n\t \n\tif (wm8960->clk_id == WM8960_SYSCLK_AUTO) {\n\t\t \n\t\twm8960_set_pll(component, 0, 0);\n\t\tfreq_out = freq_in;\n\t} else if (wm8960->sysclk) {\n\t\tfreq_out = wm8960->sysclk;\n\t} else {\n\t\tdev_err(component->dev, \"No SYSCLK configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wm8960->clk_id != WM8960_SYSCLK_PLL) {\n\t\tret = wm8960_configure_sysclk(wm8960, freq_out, &i, &j, &k);\n\t\tif (ret >= 0) {\n\t\t\tgoto configure_clock;\n\t\t} else if (wm8960->clk_id != WM8960_SYSCLK_AUTO) {\n\t\t\tdev_err(component->dev, \"failed to configure clock\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tfreq_out = wm8960_configure_pll(component, freq_in, &i, &j, &k);\n\tif (freq_out < 0) {\n\t\tdev_err(component->dev, \"failed to configure clock via PLL\\n\");\n\t\treturn freq_out;\n\t}\n\twm8960_set_pll(component, freq_in, freq_out);\n\nconfigure_clock:\n\t \n\tsnd_soc_component_update_bits(component, WM8960_CLOCK1, 3 << 1, i << 1);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8960_CLOCK1, 0x7 << 3, j << 3);\n\tsnd_soc_component_update_bits(component, WM8960_CLOCK1, 0x7 << 6, j << 6);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8960_CLOCK2, 0xf, k);\n\n\treturn 0;\n}\n\nstatic int wm8960_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tu16 iface = snd_soc_component_read(component, WM8960_IFACE1) & 0xfff3;\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tint i;\n\n\twm8960->bclk = snd_soc_params_to_bclk(params);\n\tif (params_channels(params) == 1)\n\t\twm8960->bclk *= 2;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x0008;\n\t\tbreak;\n\tcase 32:\n\t\t \n\t\tif ((iface & 0x3) != 0) {\n\t\t\tiface |= 0x000c;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported width %d\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\twm8960->lrclk = params_rate(params);\n\t \n\tif (tx) {\n\t\twm8960_set_deemph(component);\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(alc_rates); i++)\n\t\t\tif (alc_rates[i].rate == params_rate(params))\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t    WM8960_ADDCTL3, 0x7,\n\t\t\t\t\t\t    alc_rates[i].val);\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8960_IFACE1, iface);\n\n\twm8960->is_stream_in_use[tx] = true;\n\n\tif (!wm8960->is_stream_in_use[!tx])\n\t\treturn wm8960_configure_clocking(component);\n\n\treturn 0;\n}\n\nstatic int wm8960_hw_free(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\n\twm8960->is_stream_in_use[tx] = false;\n\n\treturn 0;\n}\n\nstatic int wm8960_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute)\n\t\tsnd_soc_component_update_bits(component, WM8960_DACCTL1, 0x8, 0x8);\n\telse\n\t\tsnd_soc_component_update_bits(component, WM8960_DACCTL1, 0x8, 0);\n\treturn 0;\n}\n\nstatic int wm8960_set_bias_level_out3(struct snd_soc_component *component,\n\t\t\t\t      enum snd_soc_bias_level level)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tu16 pm2 = snd_soc_component_read(component, WM8960_POWER2);\n\tint ret;\n\tktime_t tout;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tswitch (snd_soc_component_get_bias_level(component)) {\n\t\tcase SND_SOC_BIAS_STANDBY:\n\t\t\tif (!IS_ERR(wm8960->mclk)) {\n\t\t\t\tret = clk_prepare_enable(wm8960->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable MCLK: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = wm8960_configure_clocking(component);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1, 0x180, 0x80);\n\t\t\tbreak;\n\n\t\tcase SND_SOC_BIAS_ON:\n\t\t\t \n\t\t\tif (wm8960->clk_id == WM8960_SYSCLK_AUTO && (pm2 & 0x1))\n\t\t\t\twm8960_set_pll(component, 0, 0);\n\n\t\t\tif (!IS_ERR(wm8960->mclk))\n\t\t\t\tclk_disable_unprepare(wm8960->mclk);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\ttout = WM8960_DSCH_TOUT - ktime_ms_delta(ktime_get(), wm8960->dsch_start);\n\t\t\tif (tout > 0)\n\t\t\t\tmsleep(tout);\n\n\t\t\tregcache_sync(wm8960->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8960_APOP1,\n\t\t\t\t      WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t      WM8960_BUFDCOPEN | WM8960_BUFIOEN);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1, 0x80, 0x80);\n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1, WM8960_VREF,\n\t\t\t\t\t    WM8960_VREF);\n\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8960_APOP1, WM8960_BUFIOEN);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8960_POWER1, 0x180, 0x100);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_write(component, WM8960_APOP1,\n\t\t\t     WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t     WM8960_BUFDCOPEN | WM8960_BUFIOEN);\n\n\t\t \n\t\tsnd_soc_component_write(component, WM8960_POWER1, 0);\n\t\twm8960->dsch_start = ktime_get();\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8960_set_bias_level_capless(struct snd_soc_component *component,\n\t\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tu16 pm2 = snd_soc_component_read(component, WM8960_POWER2);\n\tint reg, ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tswitch (snd_soc_component_get_bias_level(component)) {\n\t\tcase SND_SOC_BIAS_STANDBY:\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_APOP1,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN);\n\n\t\t\t \n\t\t\treg = 0;\n\t\t\tif (wm8960->lout1 && wm8960->lout1->power)\n\t\t\t\treg |= WM8960_PWR2_LOUT1;\n\t\t\tif (wm8960->rout1 && wm8960->rout1->power)\n\t\t\t\treg |= WM8960_PWR2_ROUT1;\n\t\t\tif (wm8960->out3 && wm8960->out3->power)\n\t\t\t\treg |= WM8960_PWR2_OUT3;\n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER2,\n\t\t\t\t\t    WM8960_PWR2_LOUT1 |\n\t\t\t\t\t    WM8960_PWR2_ROUT1 |\n\t\t\t\t\t    WM8960_PWR2_OUT3, reg);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1,\n\t\t\t\t\t    WM8960_VMID_MASK, 0x80);\n\n\t\t\t \n\t\t\tmsleep(100);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1,\n\t\t\t\t\t    WM8960_VREF, WM8960_VREF);\n\n\t\t\tmsleep(100);\n\n\t\t\tif (!IS_ERR(wm8960->mclk)) {\n\t\t\t\tret = clk_prepare_enable(wm8960->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable MCLK: %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = wm8960_configure_clocking(component);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tbreak;\n\n\t\tcase SND_SOC_BIAS_ON:\n\t\t\t \n\t\t\tif (wm8960->clk_id == WM8960_SYSCLK_AUTO && (pm2 & 0x1))\n\t\t\t\twm8960_set_pll(component, 0, 0);\n\n\t\t\tif (!IS_ERR(wm8960->mclk))\n\t\t\t\tclk_disable_unprepare(wm8960->mclk);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_APOP1,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_POWER1,\n\t\t\t\t\t    WM8960_VREF | WM8960_VMID_MASK, 0);\n\t\t\tbreak;\n\n\t\tcase SND_SOC_BIAS_OFF:\n\t\t\tregcache_sync(wm8960->regmap);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tswitch (snd_soc_component_get_bias_level(component)) {\n\t\tcase SND_SOC_BIAS_PREPARE:\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_APOP2,\n\t\t\t\t\t    WM8960_DISOP | WM8960_DRES_MASK,\n\t\t\t\t\t    0);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8960_APOP1,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN,\n\t\t\t\t\t    WM8960_POBCTRL | WM8960_SOFT_ST |\n\t\t\t\t\t    WM8960_BUFDCOPEN);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstruct _pll_div {\n\tu32 pre_div:1;\n\tu32 n:4;\n\tu32 k:24;\n};\n\nstatic bool is_pll_freq_available(unsigned int source, unsigned int target)\n{\n\tunsigned int Ndiv;\n\n\tif (source == 0 || target == 0)\n\t\treturn false;\n\n\t \n\ttarget *= 4;\n\tNdiv = target / source;\n\n\tif (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\tNdiv = target / source;\n\t}\n\n\tif ((Ndiv < 6) || (Ndiv > 12))\n\t\treturn false;\n\n\treturn true;\n}\n\n \n#define FIXED_PLL_SIZE ((1 << 24) * 10)\n\nstatic int pll_factors(unsigned int source, unsigned int target,\n\t\t       struct _pll_div *pll_div)\n{\n\tunsigned long long Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\n\tpr_debug(\"WM8960 PLL: setting %dHz->%dHz\\n\", source, target);\n\n\t \n\ttarget *= 4;\n\n\tNdiv = target / source;\n\tif (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\tpll_div->pre_div = 1;\n\t\tNdiv = target / source;\n\t} else\n\t\tpll_div->pre_div = 0;\n\n\tif ((Ndiv < 6) || (Ndiv > 12)) {\n\t\tpr_err(\"WM8960 PLL: Unsupported N=%d\\n\", Ndiv);\n\t\treturn -EINVAL;\n\t}\n\n\tpll_div->n = Ndiv;\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\t \n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tK /= 10;\n\n\tpll_div->k = K;\n\n\tpr_debug(\"WM8960 PLL: N=%x K=%x pre_div=%d\\n\",\n\t\t pll_div->n, pll_div->k, pll_div->pre_div);\n\n\treturn 0;\n}\n\nstatic int wm8960_set_pll(struct snd_soc_component *component,\n\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tu16 reg;\n\tstatic struct _pll_div pll_div;\n\tint ret;\n\n\tif (freq_in && freq_out) {\n\t\tret = pll_factors(freq_in, freq_out, &pll_div);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8960_CLOCK1, 0x1, 0);\n\tsnd_soc_component_update_bits(component, WM8960_POWER2, 0x1, 0);\n\n\tif (!freq_in || !freq_out)\n\t\treturn 0;\n\n\treg = snd_soc_component_read(component, WM8960_PLL1) & ~0x3f;\n\treg |= pll_div.pre_div << 4;\n\treg |= pll_div.n;\n\n\tif (pll_div.k) {\n\t\treg |= 0x20;\n\n\t\tsnd_soc_component_write(component, WM8960_PLL2, (pll_div.k >> 16) & 0xff);\n\t\tsnd_soc_component_write(component, WM8960_PLL3, (pll_div.k >> 8) & 0xff);\n\t\tsnd_soc_component_write(component, WM8960_PLL4, pll_div.k & 0xff);\n\t}\n\tsnd_soc_component_write(component, WM8960_PLL1, reg);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8960_POWER2, 0x1, 0x1);\n\tmsleep(250);\n\tsnd_soc_component_update_bits(component, WM8960_CLOCK1, 0x1, 0x1);\n\n\treturn 0;\n}\n\nstatic int wm8960_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\n\twm8960->freq_in = freq_in;\n\n\tif (pll_id == WM8960_SYSCLK_AUTO)\n\t\treturn 0;\n\n\treturn wm8960_set_pll(component, freq_in, freq_out);\n}\n\nstatic int wm8960_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\tint div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\n\tswitch (div_id) {\n\tcase WM8960_SYSCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8960_CLOCK1) & 0x1f9;\n\t\tsnd_soc_component_write(component, WM8960_CLOCK1, reg | div);\n\t\tbreak;\n\tcase WM8960_DACDIV:\n\t\treg = snd_soc_component_read(component, WM8960_CLOCK1) & 0x1c7;\n\t\tsnd_soc_component_write(component, WM8960_CLOCK1, reg | div);\n\t\tbreak;\n\tcase WM8960_OPCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8960_PLL1) & 0x03f;\n\t\tsnd_soc_component_write(component, WM8960_PLL1, reg | div);\n\t\tbreak;\n\tcase WM8960_DCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8960_CLOCK2) & 0x03f;\n\t\tsnd_soc_component_write(component, WM8960_CLOCK2, reg | div);\n\t\tbreak;\n\tcase WM8960_TOCLKSEL:\n\t\treg = snd_soc_component_read(component, WM8960_ADDCTL1) & 0x1fd;\n\t\tsnd_soc_component_write(component, WM8960_ADDCTL1, reg | div);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8960_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\n\treturn wm8960->set_bias_level(component, level);\n}\n\nstatic int wm8960_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t\tunsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM8960_SYSCLK_MCLK:\n\t\tsnd_soc_component_update_bits(component, WM8960_CLOCK1,\n\t\t\t\t\t0x1, WM8960_SYSCLK_MCLK);\n\t\tbreak;\n\tcase WM8960_SYSCLK_PLL:\n\t\tsnd_soc_component_update_bits(component, WM8960_CLOCK1,\n\t\t\t\t\t0x1, WM8960_SYSCLK_PLL);\n\t\tbreak;\n\tcase WM8960_SYSCLK_AUTO:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twm8960->sysclk = freq;\n\twm8960->clk_id = clk_id;\n\n\treturn 0;\n}\n\n#define WM8960_RATES SNDRV_PCM_RATE_8000_48000\n\n#define WM8960_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8960_dai_ops = {\n\t.hw_params = wm8960_hw_params,\n\t.hw_free = wm8960_hw_free,\n\t.mute_stream = wm8960_mute,\n\t.set_fmt = wm8960_set_dai_fmt,\n\t.set_clkdiv = wm8960_set_dai_clkdiv,\n\t.set_pll = wm8960_set_dai_pll,\n\t.set_sysclk = wm8960_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8960_dai = {\n\t.name = \"wm8960-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8960_RATES,\n\t\t.formats = WM8960_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8960_RATES,\n\t\t.formats = WM8960_FORMATS,},\n\t.ops = &wm8960_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int wm8960_probe(struct snd_soc_component *component)\n{\n\tstruct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);\n\tstruct wm8960_data *pdata = &wm8960->pdata;\n\n\tif (pdata->capless)\n\t\twm8960->set_bias_level = wm8960_set_bias_level_capless;\n\telse\n\t\twm8960->set_bias_level = wm8960_set_bias_level_out3;\n\n\tsnd_soc_add_component_controls(component, wm8960_snd_controls,\n\t\t\t\t     ARRAY_SIZE(wm8960_snd_controls));\n\twm8960_add_widgets(component);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8960 = {\n\t.probe\t\t\t= wm8960_probe,\n\t.set_bias_level\t\t= wm8960_set_bias_level,\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8960_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8960_PLL4,\n\n\t.reg_defaults = wm8960_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8960_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8960_volatile,\n};\n\nstatic void wm8960_set_pdata_from_of(struct i2c_client *i2c,\n\t\t\t\tstruct wm8960_data *pdata)\n{\n\tconst struct device_node *np = i2c->dev.of_node;\n\n\tif (of_property_read_bool(np, \"wlf,capless\"))\n\t\tpdata->capless = true;\n\n\tif (of_property_read_bool(np, \"wlf,shared-lrclk\"))\n\t\tpdata->shared_lrclk = true;\n\n\tof_property_read_u32_array(np, \"wlf,gpio-cfg\", pdata->gpio_cfg,\n\t\t\t\t   ARRAY_SIZE(pdata->gpio_cfg));\n\n\tof_property_read_u32_array(np, \"wlf,hp-cfg\", pdata->hp_cfg,\n\t\t\t\t   ARRAY_SIZE(pdata->hp_cfg));\n}\n\nstatic int wm8960_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8960_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct wm8960_priv *wm8960;\n\tunsigned int i;\n\tint ret;\n\tu8 val;\n\n\twm8960 = devm_kzalloc(&i2c->dev, sizeof(struct wm8960_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8960 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8960->mclk = devm_clk_get(&i2c->dev, \"mclk\");\n\tif (IS_ERR(wm8960->mclk)) {\n\t\tif (PTR_ERR(wm8960->mclk) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t} else {\n\t\tret = clk_get_rate(wm8960->mclk);\n\t\tif (ret >= 0) {\n\t\t\twm8960->freq_in = ret;\n\t\t} else {\n\t\t\tdev_err(&i2c->dev, \"Failed to read MCLK rate: %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8960->supplies); i++)\n\t\twm8960->supplies[i].supply = wm8960_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8960->supplies),\n\t\t\t\t wm8960->supplies);\n\tif (ret <  0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8960->supplies),\n\t\t\t\t    wm8960->supplies);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8960->regmap = devm_regmap_init_i2c(i2c, &wm8960_regmap);\n\tif (IS_ERR(wm8960->regmap)) {\n\t\tret = PTR_ERR(wm8960->regmap);\n\t\tgoto bulk_disable;\n\t}\n\n\tif (pdata)\n\t\tmemcpy(&wm8960->pdata, pdata, sizeof(struct wm8960_data));\n\telse if (i2c->dev.of_node)\n\t\twm8960_set_pdata_from_of(i2c, &wm8960->pdata);\n\n\tret = i2c_master_recv(i2c, &val, sizeof(val));\n\tif (ret >= 0) {\n\t\tdev_err(&i2c->dev, \"Not wm8960, wm8960 reg can not read by i2c\\n\");\n\t\tret = -EINVAL;\n\t\tgoto bulk_disable;\n\t}\n\n\tret = wm8960_reset(wm8960->regmap);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset\\n\");\n\t\tgoto bulk_disable;\n\t}\n\n\tif (wm8960->pdata.shared_lrclk) {\n\t\tret = regmap_update_bits(wm8960->regmap, WM8960_ADDCTL2,\n\t\t\t\t\t 0x4, 0x4);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to enable LRCM: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto bulk_disable;\n\t\t}\n\t}\n\n\t \n\tregmap_update_bits(wm8960->regmap, WM8960_LINVOL, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_RINVOL, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_LADC, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_RADC, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_LDAC, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_RDAC, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_LOUT1, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_ROUT1, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_LOUT2, 0x100, 0x100);\n\tregmap_update_bits(wm8960->regmap, WM8960_ROUT2, 0x100, 0x100);\n\n\t \n\tregmap_update_bits(wm8960->regmap, WM8960_IFACE2, 1 << 6,\n\t\t\t   wm8960->pdata.gpio_cfg[0] << 6);\n\tregmap_update_bits(wm8960->regmap, WM8960_ADDCTL4, 0xF << 4,\n\t\t\t   wm8960->pdata.gpio_cfg[1] << 4);\n\n\t \n\tregmap_update_bits(wm8960->regmap, WM8960_ADDCTL4, 3 << 2,\n\t\t\t   wm8960->pdata.hp_cfg[0] << 2);\n\tregmap_update_bits(wm8960->regmap, WM8960_ADDCTL2, 3 << 5,\n\t\t\t   wm8960->pdata.hp_cfg[1] << 5);\n\tregmap_update_bits(wm8960->regmap, WM8960_ADDCTL1, 3,\n\t\t\t   wm8960->pdata.hp_cfg[2]);\n\n\ti2c_set_clientdata(i2c, wm8960);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8960, &wm8960_dai, 1);\n\tif (ret)\n\t\tgoto bulk_disable;\n\n\treturn 0;\n\nbulk_disable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8960->supplies), wm8960->supplies);\n\treturn ret;\n}\n\nstatic void wm8960_i2c_remove(struct i2c_client *client)\n{\n\tstruct wm8960_priv *wm8960 = i2c_get_clientdata(client);\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8960->supplies), wm8960->supplies);\n}\n\nstatic const struct i2c_device_id wm8960_i2c_id[] = {\n\t{ \"wm8960\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8960_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id wm8960_of_match[] = {\n       { .compatible = \"wlf,wm8960\", },\n       { }\n};\nMODULE_DEVICE_TABLE(of, wm8960_of_match);\n#endif\n\n#if defined(CONFIG_ACPI)\nstatic const struct acpi_device_id wm8960_acpi_match[] = {\n\t{ \"1AEC8960\", 0 },  \n\t{ \"10138960\", 0 },  \n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, wm8960_acpi_match);\n#endif\n\nstatic struct i2c_driver wm8960_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8960\",\n\t\t.of_match_table = of_match_ptr(wm8960_of_match),\n\t\t.acpi_match_table = ACPI_PTR(wm8960_acpi_match),\n\t},\n\t.probe =    wm8960_i2c_probe,\n\t.remove =   wm8960_i2c_remove,\n\t.id_table = wm8960_i2c_id,\n};\n\nmodule_i2c_driver(wm8960_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8960 driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}