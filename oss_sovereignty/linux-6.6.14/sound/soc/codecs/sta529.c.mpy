{
  "module_name": "sta529.c",
  "hash_id": "ff977dde6bcb3f7f80603c744a7ab64b1d89710ead206ffee98893714a3bfb1b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sta529.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n \n#define\t STA529_FFXCFG0\t\t0x00\n#define\t STA529_FFXCFG1\t\t0x01\n#define\t STA529_MVOL\t\t0x02\n#define\t STA529_LVOL\t\t0x03\n#define\t STA529_RVOL\t\t0x04\n#define\t STA529_TTF0\t\t0x05\n#define\t STA529_TTF1\t\t0x06\n#define\t STA529_TTP0\t\t0x07\n#define\t STA529_TTP1\t\t0x08\n#define\t STA529_S2PCFG0\t\t0x0A\n#define\t STA529_S2PCFG1\t\t0x0B\n#define\t STA529_P2SCFG0\t\t0x0C\n#define\t STA529_P2SCFG1\t\t0x0D\n#define\t STA529_PLLCFG0\t\t0x14\n#define\t STA529_PLLCFG1\t\t0x15\n#define\t STA529_PLLCFG2\t\t0x16\n#define\t STA529_PLLCFG3\t\t0x17\n#define\t STA529_PLLPFE\t\t0x18\n#define\t STA529_PLLST\t\t0x19\n#define\t STA529_ADCCFG\t\t0x1E  \n#define\t STA529_CKOCFG\t\t0x1F\n#define\t STA529_MISC\t\t0x20\n#define\t STA529_PADST0\t\t0x21\n#define\t STA529_PADST1\t\t0x22\n#define\t STA529_FFXST\t\t0x23\n#define\t STA529_PWMIN1\t\t0x2D\n#define\t STA529_PWMIN2\t\t0x2E\n#define\t STA529_POWST\t\t0x32\n\n#define STA529_MAX_REGISTER\t0x32\n\n#define STA529_RATES\t\t(SNDRV_PCM_RATE_8000 | \\\n\t\t\t\tSNDRV_PCM_RATE_11025 | \\\n\t\t\t\tSNDRV_PCM_RATE_16000 | \\\n\t\t\t\tSNDRV_PCM_RATE_22050 | \\\n\t\t\t\tSNDRV_PCM_RATE_32000 | \\\n\t\t\t\tSNDRV_PCM_RATE_44100 | \\\n\t\t\t\tSNDRV_PCM_RATE_48000)\n\n#define STA529_FORMAT\t\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n#define\tS2PC_VALUE\t\t0x98\n#define CLOCK_OUT\t\t0x60\n#define DATA_FORMAT_MSK\t\t0x0E\n#define LEFT_J_DATA_FORMAT\t0x00\n#define I2S_DATA_FORMAT\t\t0x02\n#define RIGHT_J_DATA_FORMAT\t0x04\n#define CODEC_MUTE_VAL\t\t0x80\n\n#define POWER_CNTLMSAK\t\t0x40\n#define POWER_STDBY\t\t0x40\n#define FFX_MASK\t\t0x80\n#define FFX_OFF\t\t\t0x80\n#define POWER_UP\t\t0x00\n#define FFX_CLK_ENB\t\t0x01\n#define FFX_CLK_DIS\t\t0x00\n#define FFX_CLK_MSK\t\t0x01\n#define PLAY_FREQ_RANGE_MSK\t0x70\n#define CAP_FREQ_RANGE_MSK\t0x0C\n#define PDATA_LEN_MSK\t\t0xC0\n#define BCLK_TO_FS_MSK\t\t0x30\n#define AUDIO_MUTE_MSK\t\t0x80\n\nstatic const struct reg_default sta529_reg_defaults[] = {\n\t{ 0,  0x35 },      \n\t{ 1,  0xc8 },      \n\t{ 2,  0x50 },      \n\t{ 3,  0x00 },      \n\t{ 4,  0x00 },      \n\t{ 10, 0xb2 },      \n\t{ 11, 0x41 },      \n\t{ 12, 0x92 },      \n\t{ 13, 0x41 },      \n\t{ 30, 0xd2 },      \n\t{ 31, 0x40 },      \n\t{ 32, 0x21 },      \n};\n\nstruct sta529 {\n\tstruct regmap *regmap;\n};\n\nstatic bool sta529_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\n\tcase STA529_FFXCFG0:\n\tcase STA529_FFXCFG1:\n\tcase STA529_MVOL:\n\tcase STA529_LVOL:\n\tcase STA529_RVOL:\n\tcase STA529_S2PCFG0:\n\tcase STA529_S2PCFG1:\n\tcase STA529_P2SCFG0:\n\tcase STA529_P2SCFG1:\n\tcase STA529_ADCCFG:\n\tcase STA529_CKOCFG:\n\tcase STA529_MISC:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n\nstatic const char *pwm_mode_text[] = { \"Binary\", \"Headphone\", \"Ternary\",\n\t\"Phase-shift\"};\n\nstatic const DECLARE_TLV_DB_SCALE(out_gain_tlv, -9150, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(master_vol_tlv, -12750, 50, 0);\nstatic SOC_ENUM_SINGLE_DECL(pwm_src, STA529_FFXCFG1, 4, pwm_mode_text);\n\nstatic const struct snd_kcontrol_new sta529_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", STA529_LVOL, STA529_RVOL, 0,\n\t\t\t127, 0, out_gain_tlv),\n\tSOC_SINGLE_TLV(\"Master Playback Volume\", STA529_MVOL, 0, 127, 1,\n\t\t\tmaster_vol_tlv),\n\tSOC_ENUM(\"PWM Select\", pwm_src),\n};\n\nstatic int sta529_set_bias_level(struct snd_soc_component *component, enum\n\t\tsnd_soc_bias_level level)\n{\n\tstruct sta529 *sta529 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, STA529_FFXCFG0, POWER_CNTLMSAK,\n\t\t\t\tPOWER_UP);\n\t\tsnd_soc_component_update_bits(component, STA529_MISC,\tFFX_CLK_MSK,\n\t\t\t\tFFX_CLK_ENB);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tregcache_sync(sta529->regmap);\n\t\tsnd_soc_component_update_bits(component, STA529_FFXCFG0,\n\t\t\t\t\tPOWER_CNTLMSAK, POWER_STDBY);\n\t\t \n\t\tsnd_soc_component_update_bits(component, STA529_FFXCFG0, FFX_MASK,\n\t\t\t\tFFX_OFF);\n\t\tsnd_soc_component_update_bits(component, STA529_MISC, FFX_CLK_MSK,\n\t\t\t\tFFX_CLK_DIS);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic int sta529_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint pdata, play_freq_val, record_freq_val;\n\tint bclk_to_fs_ratio;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tpdata = 1;\n\t\tbclk_to_fs_ratio = 0;\n\t\tbreak;\n\tcase 24:\n\t\tpdata = 2;\n\t\tbclk_to_fs_ratio = 1;\n\t\tbreak;\n\tcase 32:\n\t\tpdata = 3;\n\t\tbclk_to_fs_ratio = 2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\tcase 11025:\n\t\tplay_freq_val = 0;\n\t\trecord_freq_val = 2;\n\t\tbreak;\n\tcase 16000:\n\tcase 22050:\n\t\tplay_freq_val = 1;\n\t\trecord_freq_val = 0;\n\t\tbreak;\n\n\tcase 32000:\n\tcase 44100:\n\tcase 48000:\n\t\tplay_freq_val = 2;\n\t\trecord_freq_val = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsnd_soc_component_update_bits(component, STA529_S2PCFG1, PDATA_LEN_MSK,\n\t\t\t\tpdata << 6);\n\t\tsnd_soc_component_update_bits(component, STA529_S2PCFG1, BCLK_TO_FS_MSK,\n\t\t\t\tbclk_to_fs_ratio << 4);\n\t\tsnd_soc_component_update_bits(component, STA529_MISC, PLAY_FREQ_RANGE_MSK,\n\t\t\t\tplay_freq_val << 4);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, STA529_P2SCFG1, PDATA_LEN_MSK,\n\t\t\t\tpdata << 6);\n\t\tsnd_soc_component_update_bits(component, STA529_P2SCFG1, BCLK_TO_FS_MSK,\n\t\t\t\tbclk_to_fs_ratio << 4);\n\t\tsnd_soc_component_update_bits(component, STA529_MISC, CAP_FREQ_RANGE_MSK,\n\t\t\t\trecord_freq_val << 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int sta529_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tu8 val = 0;\n\n\tif (mute)\n\t\tval |= CODEC_MUTE_VAL;\n\n\tsnd_soc_component_update_bits(dai->component, STA529_FFXCFG0, AUDIO_MUTE_MSK, val);\n\n\treturn 0;\n}\n\nstatic int sta529_set_dai_fmt(struct snd_soc_dai *codec_dai, u32 fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 mode = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tmode = LEFT_J_DATA_FORMAT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmode = I2S_DATA_FORMAT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tmode = RIGHT_J_DATA_FORMAT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, STA529_S2PCFG0, DATA_FORMAT_MSK, mode);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sta529_dai_ops = {\n\t.hw_params\t=\tsta529_hw_params,\n\t.set_fmt\t=\tsta529_set_dai_fmt,\n\t.mute_stream\t=\tsta529_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver sta529_dai = {\n\t.name = \"sta529-audio\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = STA529_RATES,\n\t\t.formats = STA529_FORMAT,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = STA529_RATES,\n\t\t.formats = STA529_FORMAT,\n\t},\n\t.ops\t= &sta529_dai_ops,\n};\n\nstatic const struct snd_soc_component_driver sta529_component_driver = {\n\t.set_bias_level\t\t= sta529_set_bias_level,\n\t.controls\t\t= sta529_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sta529_snd_controls),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config sta529_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = STA529_MAX_REGISTER,\n\t.readable_reg = sta529_readable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = sta529_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(sta529_reg_defaults),\n};\n\nstatic int sta529_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct sta529 *sta529;\n\tint ret;\n\n\tsta529 = devm_kzalloc(&i2c->dev, sizeof(struct sta529), GFP_KERNEL);\n\tif (!sta529)\n\t\treturn -ENOMEM;\n\n\tsta529->regmap = devm_regmap_init_i2c(i2c, &sta529_regmap);\n\tif (IS_ERR(sta529->regmap)) {\n\t\tret = PTR_ERR(sta529->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, sta529);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&sta529_component_driver, &sta529_dai, 1);\n\tif (ret != 0)\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id sta529_i2c_id[] = {\n\t{ \"sta529\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sta529_i2c_id);\n\nstatic const struct of_device_id sta529_of_match[] = {\n\t{ .compatible = \"st,sta529\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sta529_of_match);\n\nstatic struct i2c_driver sta529_i2c_driver = {\n\t.driver = {\n\t\t.name = \"sta529\",\n\t\t.of_match_table = sta529_of_match,\n\t},\n\t.probe\t\t= sta529_i2c_probe,\n\t.id_table\t= sta529_i2c_id,\n};\n\nmodule_i2c_driver(sta529_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC STA529 codec driver\");\nMODULE_AUTHOR(\"Rajeev Kumar <rajeevkumar.linux@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}