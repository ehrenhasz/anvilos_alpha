{
  "module_name": "sigmadsp.c",
  "hash_id": "69b9839f32ad3ad59c55947c8a75890d7d74e2df628d63c9beca1021f6ef021f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sigmadsp.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <sound/control.h>\n#include <sound/soc.h>\n\n#include \"sigmadsp.h\"\n\n#define SIGMA_MAGIC \"ADISIGM\"\n\n#define SIGMA_FW_CHUNK_TYPE_DATA 0\n#define SIGMA_FW_CHUNK_TYPE_CONTROL 1\n#define SIGMA_FW_CHUNK_TYPE_SAMPLERATES 2\n\n#define READBACK_CTRL_NAME \"ReadBack\"\n\nstruct sigmadsp_control {\n\tstruct list_head head;\n\tuint32_t samplerates;\n\tunsigned int addr;\n\tunsigned int num_bytes;\n\tconst char *name;\n\tstruct snd_kcontrol *kcontrol;\n\tbool is_readback;\n\tbool cached;\n\tuint8_t cache[];\n};\n\nstruct sigmadsp_data {\n\tstruct list_head head;\n\tuint32_t samplerates;\n\tunsigned int addr;\n\tunsigned int length;\n\tuint8_t data[];\n};\n\nstruct sigma_fw_chunk {\n\t__le32 length;\n\t__le32 tag;\n\t__le32 samplerates;\n} __packed;\n\nstruct sigma_fw_chunk_data {\n\tstruct sigma_fw_chunk chunk;\n\t__le16 addr;\n\tuint8_t data[];\n} __packed;\n\nstruct sigma_fw_chunk_control {\n\tstruct sigma_fw_chunk chunk;\n\t__le16 type;\n\t__le16 addr;\n\t__le16 num_bytes;\n\tconst char name[];\n} __packed;\n\nstruct sigma_fw_chunk_samplerate {\n\tstruct sigma_fw_chunk chunk;\n\t__le32 samplerates[];\n} __packed;\n\nstruct sigma_firmware_header {\n\tunsigned char magic[7];\n\tu8 version;\n\t__le32 crc;\n} __packed;\n\nenum {\n\tSIGMA_ACTION_WRITEXBYTES = 0,\n\tSIGMA_ACTION_WRITESINGLE,\n\tSIGMA_ACTION_WRITESAFELOAD,\n\tSIGMA_ACTION_END,\n};\n\nstruct sigma_action {\n\tu8 instr;\n\tu8 len_hi;\n\t__le16 len;\n\t__be16 addr;\n\tunsigned char payload[];\n} __packed;\n\nstatic int sigmadsp_write(struct sigmadsp *sigmadsp, unsigned int addr,\n\tconst uint8_t data[], size_t len)\n{\n\treturn sigmadsp->write(sigmadsp->control_data, addr, data, len);\n}\n\nstatic int sigmadsp_read(struct sigmadsp *sigmadsp, unsigned int addr,\n\tuint8_t data[], size_t len)\n{\n\treturn sigmadsp->read(sigmadsp->control_data, addr, data, len);\n}\n\nstatic int sigmadsp_ctrl_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *info)\n{\n\tstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\n\n\tinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tinfo->count = ctrl->num_bytes;\n\n\treturn 0;\n}\n\nstatic int sigmadsp_ctrl_write(struct sigmadsp *sigmadsp,\n\tstruct sigmadsp_control *ctrl, void *data)\n{\n\t \n\tif (ctrl->num_bytes <= 20 && sigmadsp->ops && sigmadsp->ops->safeload)\n\t\treturn sigmadsp->ops->safeload(sigmadsp, ctrl->addr, data,\n\t\t\tctrl->num_bytes);\n\telse\n\t\treturn sigmadsp_write(sigmadsp, ctrl->addr, data,\n\t\t\tctrl->num_bytes);\n}\n\nstatic int sigmadsp_ctrl_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\n\tstruct sigmadsp *sigmadsp = snd_kcontrol_chip(kcontrol);\n\tuint8_t *data;\n\tint ret = 0;\n\n\tmutex_lock(&sigmadsp->lock);\n\n\tdata = ucontrol->value.bytes.data;\n\n\tif (!(kcontrol->vd[0].access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\n\t\tret = sigmadsp_ctrl_write(sigmadsp, ctrl, data);\n\n\tif (ret == 0) {\n\t\tmemcpy(ctrl->cache, data, ctrl->num_bytes);\n\t\tif (!ctrl->is_readback)\n\t\t\tctrl->cached = true;\n\t}\n\n\tmutex_unlock(&sigmadsp->lock);\n\n\treturn ret;\n}\n\nstatic int sigmadsp_ctrl_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\n\tstruct sigmadsp *sigmadsp = snd_kcontrol_chip(kcontrol);\n\tint ret = 0;\n\n\tmutex_lock(&sigmadsp->lock);\n\n\tif (!ctrl->cached) {\n\t\tret = sigmadsp_read(sigmadsp, ctrl->addr, ctrl->cache,\n\t\t\tctrl->num_bytes);\n\t}\n\n\tif (ret == 0) {\n\t\tif (!ctrl->is_readback)\n\t\t\tctrl->cached = true;\n\t\tmemcpy(ucontrol->value.bytes.data, ctrl->cache,\n\t\t\tctrl->num_bytes);\n\t}\n\n\tmutex_unlock(&sigmadsp->lock);\n\n\treturn ret;\n}\n\nstatic void sigmadsp_control_free(struct snd_kcontrol *kcontrol)\n{\n\tstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\n\n\tctrl->kcontrol = NULL;\n}\n\nstatic bool sigma_fw_validate_control_name(const char *name, unsigned int len)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++) {\n\t\t \n\t\tif (name[i] < ' ' || name[i] > '~')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int sigma_fw_load_control(struct sigmadsp *sigmadsp,\n\tconst struct sigma_fw_chunk *chunk, unsigned int length)\n{\n\tconst struct sigma_fw_chunk_control *ctrl_chunk;\n\tstruct sigmadsp_control *ctrl;\n\tunsigned int num_bytes;\n\tsize_t name_len;\n\tchar *name;\n\tint ret;\n\n\tif (length <= sizeof(*ctrl_chunk))\n\t\treturn -EINVAL;\n\n\tctrl_chunk = (const struct sigma_fw_chunk_control *)chunk;\n\n\tname_len = length - sizeof(*ctrl_chunk);\n\tif (name_len >= SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\n\t\tname_len = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - 1;\n\n\t \n\tif (!sigma_fw_validate_control_name(ctrl_chunk->name, name_len))\n\t\treturn -EINVAL;\n\n\tnum_bytes = le16_to_cpu(ctrl_chunk->num_bytes);\n\tctrl = kzalloc(sizeof(*ctrl) + num_bytes, GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tname = kmemdup_nul(ctrl_chunk->name, name_len, GFP_KERNEL);\n\tif (!name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ctrl;\n\t}\n\tctrl->name = name;\n\n\t \n\tif (ctrl->name && strncmp(ctrl->name, READBACK_CTRL_NAME,\n\t\t\t\t  (sizeof(READBACK_CTRL_NAME) - 1)) == 0)\n\t\tctrl->is_readback = true;\n\n\tctrl->addr = le16_to_cpu(ctrl_chunk->addr);\n\tctrl->num_bytes = num_bytes;\n\tctrl->samplerates = le32_to_cpu(chunk->samplerates);\n\n\tlist_add_tail(&ctrl->head, &sigmadsp->ctrl_list);\n\n\treturn 0;\n\nerr_free_ctrl:\n\tkfree(ctrl);\n\n\treturn ret;\n}\n\nstatic int sigma_fw_load_data(struct sigmadsp *sigmadsp,\n\tconst struct sigma_fw_chunk *chunk, unsigned int length)\n{\n\tconst struct sigma_fw_chunk_data *data_chunk;\n\tstruct sigmadsp_data *data;\n\n\tif (length <= sizeof(*data_chunk))\n\t\treturn -EINVAL;\n\n\tdata_chunk = (struct sigma_fw_chunk_data *)chunk;\n\n\tlength -= sizeof(*data_chunk);\n\n\tdata = kzalloc(sizeof(*data) + length, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->addr = le16_to_cpu(data_chunk->addr);\n\tdata->length = length;\n\tdata->samplerates = le32_to_cpu(chunk->samplerates);\n\tmemcpy(data->data, data_chunk->data, length);\n\tlist_add_tail(&data->head, &sigmadsp->data_list);\n\n\treturn 0;\n}\n\nstatic int sigma_fw_load_samplerates(struct sigmadsp *sigmadsp,\n\tconst struct sigma_fw_chunk *chunk, unsigned int length)\n{\n\tconst struct sigma_fw_chunk_samplerate *rate_chunk;\n\tunsigned int num_rates;\n\tunsigned int *rates;\n\tunsigned int i;\n\n\trate_chunk = (const struct sigma_fw_chunk_samplerate *)chunk;\n\n\tnum_rates = (length - sizeof(*rate_chunk)) / sizeof(__le32);\n\n\tif (num_rates > 32 || num_rates == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif (sigmadsp->rate_constraints.count)\n\t\treturn -EINVAL;\n\n\trates = kcalloc(num_rates, sizeof(*rates), GFP_KERNEL);\n\tif (!rates)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_rates; i++)\n\t\trates[i] = le32_to_cpu(rate_chunk->samplerates[i]);\n\n\tsigmadsp->rate_constraints.count = num_rates;\n\tsigmadsp->rate_constraints.list = rates;\n\n\treturn 0;\n}\n\nstatic int sigmadsp_fw_load_v2(struct sigmadsp *sigmadsp,\n\tconst struct firmware *fw)\n{\n\tstruct sigma_fw_chunk *chunk;\n\tunsigned int length, pos;\n\tint ret;\n\n\t \n\tif (fw->size < sizeof(*chunk) + sizeof(struct sigma_firmware_header))\n\t\treturn 0;\n\n\tpos = sizeof(struct sigma_firmware_header);\n\n\twhile (pos < fw->size - sizeof(*chunk)) {\n\t\tchunk = (struct sigma_fw_chunk *)(fw->data + pos);\n\n\t\tlength = le32_to_cpu(chunk->length);\n\n\t\tif (length > fw->size - pos || length < sizeof(*chunk))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (le32_to_cpu(chunk->tag)) {\n\t\tcase SIGMA_FW_CHUNK_TYPE_DATA:\n\t\t\tret = sigma_fw_load_data(sigmadsp, chunk, length);\n\t\t\tbreak;\n\t\tcase SIGMA_FW_CHUNK_TYPE_CONTROL:\n\t\t\tret = sigma_fw_load_control(sigmadsp, chunk, length);\n\t\t\tbreak;\n\t\tcase SIGMA_FW_CHUNK_TYPE_SAMPLERATES:\n\t\t\tret = sigma_fw_load_samplerates(sigmadsp, chunk, length);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(sigmadsp->dev, \"Unknown chunk type: %d\\n\",\n\t\t\t\tchunk->tag);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tpos += ALIGN(length, sizeof(__le32));\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 sigma_action_len(struct sigma_action *sa)\n{\n\treturn (sa->len_hi << 16) | le16_to_cpu(sa->len);\n}\n\nstatic size_t sigma_action_size(struct sigma_action *sa)\n{\n\tsize_t payload = 0;\n\n\tswitch (sa->instr) {\n\tcase SIGMA_ACTION_WRITEXBYTES:\n\tcase SIGMA_ACTION_WRITESINGLE:\n\tcase SIGMA_ACTION_WRITESAFELOAD:\n\t\tpayload = sigma_action_len(sa);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpayload = ALIGN(payload, 2);\n\n\treturn payload + sizeof(struct sigma_action);\n}\n\n \nstatic int process_sigma_action(struct sigmadsp *sigmadsp,\n\tstruct sigma_action *sa)\n{\n\tsize_t len = sigma_action_len(sa);\n\tstruct sigmadsp_data *data;\n\n\tpr_debug(\"%s: instr:%i addr:%#x len:%zu\\n\", __func__,\n\t\tsa->instr, sa->addr, len);\n\n\tswitch (sa->instr) {\n\tcase SIGMA_ACTION_WRITEXBYTES:\n\tcase SIGMA_ACTION_WRITESINGLE:\n\tcase SIGMA_ACTION_WRITESAFELOAD:\n\t\tif (len < 3)\n\t\t\treturn -EINVAL;\n\n\t\tdata = kzalloc(sizeof(*data) + len - 2, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tdata->addr = be16_to_cpu(sa->addr);\n\t\tdata->length = len - 2;\n\t\tmemcpy(data->data, sa->payload, data->length);\n\t\tlist_add_tail(&data->head, &sigmadsp->data_list);\n\t\tbreak;\n\tcase SIGMA_ACTION_END:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 1;\n}\n\nstatic int sigmadsp_fw_load_v1(struct sigmadsp *sigmadsp,\n\tconst struct firmware *fw)\n{\n\tstruct sigma_action *sa;\n\tsize_t size, pos;\n\tint ret;\n\n\tpos = sizeof(struct sigma_firmware_header);\n\n\twhile (pos + sizeof(*sa) <= fw->size) {\n\t\tsa = (struct sigma_action *)(fw->data + pos);\n\n\t\tsize = sigma_action_size(sa);\n\t\tpos += size;\n\t\tif (pos > fw->size || size == 0)\n\t\t\tbreak;\n\n\t\tret = process_sigma_action(sigmadsp, sa);\n\n\t\tpr_debug(\"%s: action returned %i\\n\", __func__, ret);\n\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\t}\n\n\tif (pos != fw->size)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void sigmadsp_firmware_release(struct sigmadsp *sigmadsp)\n{\n\tstruct sigmadsp_control *ctrl, *_ctrl;\n\tstruct sigmadsp_data *data, *_data;\n\n\tlist_for_each_entry_safe(ctrl, _ctrl, &sigmadsp->ctrl_list, head) {\n\t\tkfree(ctrl->name);\n\t\tkfree(ctrl);\n\t}\n\n\tlist_for_each_entry_safe(data, _data, &sigmadsp->data_list, head)\n\t\tkfree(data);\n\n\tINIT_LIST_HEAD(&sigmadsp->ctrl_list);\n\tINIT_LIST_HEAD(&sigmadsp->data_list);\n}\n\nstatic void devm_sigmadsp_release(struct device *dev, void *res)\n{\n\tsigmadsp_firmware_release((struct sigmadsp *)res);\n}\n\nstatic int sigmadsp_firmware_load(struct sigmadsp *sigmadsp, const char *name)\n{\n\tconst struct sigma_firmware_header *ssfw_head;\n\tconst struct firmware *fw;\n\tint ret;\n\tu32 crc;\n\n\t \n\tret = request_firmware(&fw, name, sigmadsp->dev);\n\tif (ret) {\n\t\tpr_debug(\"%s: request_firmware() failed with %i\\n\", __func__, ret);\n\t\tgoto done;\n\t}\n\n\t \n\tret = -EINVAL;\n\n\t \n\tif (fw->size < sizeof(*ssfw_head) || fw->size >= 0x4000000) {\n\t\tdev_err(sigmadsp->dev, \"Failed to load firmware: Invalid size\\n\");\n\t\tgoto done;\n\t}\n\n\tssfw_head = (void *)fw->data;\n\tif (memcmp(ssfw_head->magic, SIGMA_MAGIC, ARRAY_SIZE(ssfw_head->magic))) {\n\t\tdev_err(sigmadsp->dev, \"Failed to load firmware: Invalid magic\\n\");\n\t\tgoto done;\n\t}\n\n\tcrc = crc32(0, fw->data + sizeof(*ssfw_head),\n\t\t\tfw->size - sizeof(*ssfw_head));\n\tpr_debug(\"%s: crc=%x\\n\", __func__, crc);\n\tif (crc != le32_to_cpu(ssfw_head->crc)) {\n\t\tdev_err(sigmadsp->dev, \"Failed to load firmware: Wrong crc checksum: expected %x got %x\\n\",\n\t\t\tle32_to_cpu(ssfw_head->crc), crc);\n\t\tgoto done;\n\t}\n\n\tswitch (ssfw_head->version) {\n\tcase 1:\n\t\tret = sigmadsp_fw_load_v1(sigmadsp, fw);\n\t\tbreak;\n\tcase 2:\n\t\tret = sigmadsp_fw_load_v2(sigmadsp, fw);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(sigmadsp->dev,\n\t\t\t\"Failed to load firmware: Invalid version %d. Supported firmware versions: 1, 2\\n\",\n\t\t\tssfw_head->version);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tsigmadsp_firmware_release(sigmadsp);\n\ndone:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int sigmadsp_init(struct sigmadsp *sigmadsp, struct device *dev,\n\tconst struct sigmadsp_ops *ops, const char *firmware_name)\n{\n\tsigmadsp->ops = ops;\n\tsigmadsp->dev = dev;\n\n\tINIT_LIST_HEAD(&sigmadsp->ctrl_list);\n\tINIT_LIST_HEAD(&sigmadsp->data_list);\n\tmutex_init(&sigmadsp->lock);\n\n\treturn sigmadsp_firmware_load(sigmadsp, firmware_name);\n}\n\n \nstruct sigmadsp *devm_sigmadsp_init(struct device *dev,\n\tconst struct sigmadsp_ops *ops, const char *firmware_name)\n{\n\tstruct sigmadsp *sigmadsp;\n\tint ret;\n\n\tsigmadsp = devres_alloc(devm_sigmadsp_release, sizeof(*sigmadsp),\n\t\tGFP_KERNEL);\n\tif (!sigmadsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = sigmadsp_init(sigmadsp, dev, ops, firmware_name);\n\tif (ret) {\n\t\tdevres_free(sigmadsp);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdevres_add(dev, sigmadsp);\n\n\treturn sigmadsp;\n}\nEXPORT_SYMBOL_GPL(devm_sigmadsp_init);\n\nstatic int sigmadsp_rate_to_index(struct sigmadsp *sigmadsp, unsigned int rate)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < sigmadsp->rate_constraints.count; i++) {\n\t\tif (sigmadsp->rate_constraints.list[i] == rate)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic unsigned int sigmadsp_get_samplerate_mask(struct sigmadsp *sigmadsp,\n\tunsigned int samplerate)\n{\n\tint samplerate_index;\n\n\tif (samplerate == 0)\n\t\treturn 0;\n\n\tif (sigmadsp->rate_constraints.count) {\n\t\tsamplerate_index = sigmadsp_rate_to_index(sigmadsp, samplerate);\n\t\tif (samplerate_index < 0)\n\t\t\treturn 0;\n\n\t\treturn BIT(samplerate_index);\n\t} else {\n\t\treturn ~0;\n\t}\n}\n\nstatic bool sigmadsp_samplerate_valid(unsigned int supported,\n\tunsigned int requested)\n{\n\t \n\tif (!supported)\n\t\treturn true;\n\n\treturn supported & requested;\n}\n\nstatic int sigmadsp_alloc_control(struct sigmadsp *sigmadsp,\n\tstruct sigmadsp_control *ctrl, unsigned int samplerate_mask)\n{\n\tstruct snd_kcontrol_new template;\n\tstruct snd_kcontrol *kcontrol;\n\n\tmemset(&template, 0, sizeof(template));\n\ttemplate.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\ttemplate.name = ctrl->name;\n\ttemplate.info = sigmadsp_ctrl_info;\n\ttemplate.get = sigmadsp_ctrl_get;\n\ttemplate.put = sigmadsp_ctrl_put;\n\ttemplate.private_value = (unsigned long)ctrl;\n\ttemplate.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tif (!sigmadsp_samplerate_valid(ctrl->samplerates, samplerate_mask))\n\t\ttemplate.access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\n\n\tkcontrol = snd_ctl_new1(&template, sigmadsp);\n\tif (!kcontrol)\n\t\treturn -ENOMEM;\n\n\tkcontrol->private_free = sigmadsp_control_free;\n\tctrl->kcontrol = kcontrol;\n\n\treturn snd_ctl_add(sigmadsp->component->card->snd_card, kcontrol);\n}\n\nstatic void sigmadsp_activate_ctrl(struct sigmadsp *sigmadsp,\n\tstruct sigmadsp_control *ctrl, unsigned int samplerate_mask)\n{\n\tstruct snd_card *card = sigmadsp->component->card->snd_card;\n\tbool active;\n\tint changed;\n\n\tactive = sigmadsp_samplerate_valid(ctrl->samplerates, samplerate_mask);\n\tif (!ctrl->kcontrol)\n\t\treturn;\n\tchanged = snd_ctl_activate_id(card, &ctrl->kcontrol->id, active);\n\tif (active && changed > 0) {\n\t\tmutex_lock(&sigmadsp->lock);\n\t\tif (ctrl->cached)\n\t\t\tsigmadsp_ctrl_write(sigmadsp, ctrl, ctrl->cache);\n\t\tmutex_unlock(&sigmadsp->lock);\n\t}\n}\n\n \nint sigmadsp_attach(struct sigmadsp *sigmadsp,\n\tstruct snd_soc_component *component)\n{\n\tstruct sigmadsp_control *ctrl;\n\tunsigned int samplerate_mask;\n\tint ret;\n\n\tsigmadsp->component = component;\n\n\tsamplerate_mask = sigmadsp_get_samplerate_mask(sigmadsp,\n\t\tsigmadsp->current_samplerate);\n\n\tlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head) {\n\t\tret = sigmadsp_alloc_control(sigmadsp, ctrl, samplerate_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sigmadsp_attach);\n\n \nint sigmadsp_setup(struct sigmadsp *sigmadsp, unsigned int samplerate)\n{\n\tstruct sigmadsp_control *ctrl;\n\tunsigned int samplerate_mask;\n\tstruct sigmadsp_data *data;\n\tint ret;\n\n\tif (sigmadsp->current_samplerate == samplerate)\n\t\treturn 0;\n\n\tsamplerate_mask = sigmadsp_get_samplerate_mask(sigmadsp, samplerate);\n\tif (samplerate_mask == 0)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(data, &sigmadsp->data_list, head) {\n\t\tif (!sigmadsp_samplerate_valid(data->samplerates,\n\t\t    samplerate_mask))\n\t\t\tcontinue;\n\t\tret = sigmadsp_write(sigmadsp, data->addr, data->data,\n\t\t\tdata->length);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head)\n\t\tsigmadsp_activate_ctrl(sigmadsp, ctrl, samplerate_mask);\n\n\tsigmadsp->current_samplerate = samplerate;\n\n\treturn 0;\nerr:\n\tsigmadsp_reset(sigmadsp);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sigmadsp_setup);\n\n \nvoid sigmadsp_reset(struct sigmadsp *sigmadsp)\n{\n\tstruct sigmadsp_control *ctrl;\n\n\tlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head)\n\t\tsigmadsp_activate_ctrl(sigmadsp, ctrl, false);\n\n\tsigmadsp->current_samplerate = 0;\n}\nEXPORT_SYMBOL_GPL(sigmadsp_reset);\n\n \nint sigmadsp_restrict_params(struct sigmadsp *sigmadsp,\n\tstruct snd_pcm_substream *substream)\n{\n\tif (sigmadsp->rate_constraints.count == 0)\n\t\treturn 0;\n\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\tSNDRV_PCM_HW_PARAM_RATE, &sigmadsp->rate_constraints);\n}\nEXPORT_SYMBOL_GPL(sigmadsp_restrict_params);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}