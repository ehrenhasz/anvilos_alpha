{
  "module_name": "tpa6130a2.c",
  "hash_id": "89ed2c954e86dd92722e4a63cb6e193c84bc004dea3815626a3025d783cbf6ef",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tpa6130a2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/tpa6130a2-plat.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n\n#include \"tpa6130a2.h\"\n\nenum tpa_model {\n\tTPA6130A2,\n\tTPA6140A2,\n};\n\n \nstruct tpa6130a2_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct regulator *supply;\n\tint power_gpio;\n\tenum tpa_model id;\n};\n\nstatic int tpa6130a2_power(struct tpa6130a2_data *data, bool enable)\n{\n\tint ret = 0, ret2;\n\n\tif (enable) {\n\t\tret = regulator_enable(data->supply);\n\t\tif (ret != 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Failed to enable supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tif (data->power_gpio >= 0)\n\t\t\tgpio_set_value(data->power_gpio, 1);\n\n\t\t \n\t\tregcache_cache_only(data->regmap, false);\n\t\tret = regcache_sync(data->regmap);\n\t\tif (ret != 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Failed to sync registers: %d\\n\", ret);\n\t\t\tregcache_cache_only(data->regmap, true);\n\t\t\tif (data->power_gpio >= 0)\n\t\t\t\tgpio_set_value(data->power_gpio, 0);\n\t\t\tret2 = regulator_disable(data->supply);\n\t\t\tif (ret2 != 0)\n\t\t\t\tdev_err(data->dev,\n\t\t\t\t\t\"Failed to disable supply: %d\\n\", ret2);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tregcache_mark_dirty(data->regmap);\n\t\tregcache_cache_only(data->regmap, true);\n\n\t\t \n\t\tif (data->power_gpio >= 0)\n\t\t\tgpio_set_value(data->power_gpio, 0);\n\n\t\tret = regulator_disable(data->supply);\n\t\tif (ret != 0) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\"Failed to disable supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int tpa6130a2_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kctrl, int event)\n{\n\tstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\n\tstruct tpa6130a2_data *data = snd_soc_component_get_drvdata(c);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event)) {\n\t\t \n\t\treturn tpa6130a2_power(data, true);\n\t} else {\n\t\t \n\t\treturn tpa6130a2_power(data, false);\n\t}\n}\n\n \nstatic const DECLARE_TLV_DB_RANGE(tpa6130_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-5950, 600, 0),\n\t2, 3, TLV_DB_SCALE_ITEM(-5000, 250, 0),\n\t4, 5, TLV_DB_SCALE_ITEM(-4550, 160, 0),\n\t6, 7, TLV_DB_SCALE_ITEM(-4140, 190, 0),\n\t8, 9, TLV_DB_SCALE_ITEM(-3650, 120, 0),\n\t10, 11, TLV_DB_SCALE_ITEM(-3330, 160, 0),\n\t12, 13, TLV_DB_SCALE_ITEM(-3040, 180, 0),\n\t14, 20, TLV_DB_SCALE_ITEM(-2710, 110, 0),\n\t21, 37, TLV_DB_SCALE_ITEM(-1960, 74, 0),\n\t38, 63, TLV_DB_SCALE_ITEM(-720, 45, 0)\n);\n\nstatic const struct snd_kcontrol_new tpa6130a2_controls[] = {\n\tSOC_SINGLE_TLV(\"Headphone Playback Volume\",\n\t\t       TPA6130A2_REG_VOL_MUTE, 0, 0x3f, 0,\n\t\t       tpa6130_tlv),\n};\n\nstatic const DECLARE_TLV_DB_RANGE(tpa6140_tlv,\n\t0, 8, TLV_DB_SCALE_ITEM(-5900, 400, 0),\n\t9, 16, TLV_DB_SCALE_ITEM(-2500, 200, 0),\n\t17, 31, TLV_DB_SCALE_ITEM(-1000, 100, 0)\n);\n\nstatic const struct snd_kcontrol_new tpa6140a2_controls[] = {\n\tSOC_SINGLE_TLV(\"Headphone Playback Volume\",\n\t\t       TPA6130A2_REG_VOL_MUTE, 1, 0x1f, 0,\n\t\t       tpa6140_tlv),\n};\n\nstatic int tpa6130a2_component_probe(struct snd_soc_component *component)\n{\n\tstruct tpa6130a2_data *data = snd_soc_component_get_drvdata(component);\n\n\tif (data->id == TPA6140A2)\n\t\treturn snd_soc_add_component_controls(component,\n\t\t\ttpa6140a2_controls, ARRAY_SIZE(tpa6140a2_controls));\n\telse\n\t\treturn snd_soc_add_component_controls(component,\n\t\t\ttpa6130a2_controls, ARRAY_SIZE(tpa6130a2_controls));\n}\n\nstatic const struct snd_soc_dapm_widget tpa6130a2_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"LEFTIN\"),\n\tSND_SOC_DAPM_INPUT(\"RIGHTIN\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPLEFT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPRIGHT\"),\n\n\tSND_SOC_DAPM_PGA(\"Left Mute\", TPA6130A2_REG_VOL_MUTE,\n\t\t\t TPA6130A2_HP_EN_L_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Mute\", TPA6130A2_REG_VOL_MUTE,\n\t\t\t TPA6130A2_HP_EN_R_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left PGA\", TPA6130A2_REG_CONTROL,\n\t\t\t TPA6130A2_HP_EN_L_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right PGA\", TPA6130A2_REG_CONTROL,\n\t\t\t TPA6130A2_HP_EN_R_SHIFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Power\", TPA6130A2_REG_CONTROL,\n\t\t\t    TPA6130A2_SWS_SHIFT, 1, tpa6130a2_power_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route tpa6130a2_dapm_routes[] = {\n\t{ \"Left PGA\", NULL, \"LEFTIN\" },\n\t{ \"Right PGA\", NULL, \"RIGHTIN\" },\n\n\t{ \"Left Mute\", NULL, \"Left PGA\" },\n\t{ \"Right Mute\", NULL, \"Right PGA\" },\n\n\t{ \"HPLEFT\", NULL, \"Left Mute\" },\n\t{ \"HPRIGHT\", NULL, \"Right Mute\" },\n\n\t{ \"Left PGA\", NULL, \"Power\" },\n\t{ \"Right PGA\", NULL, \"Power\" },\n};\n\nstatic const struct snd_soc_component_driver tpa6130a2_component_driver = {\n\t.name = \"tpa6130a2\",\n\t.probe = tpa6130a2_component_probe,\n\t.dapm_widgets = tpa6130a2_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(tpa6130a2_dapm_widgets),\n\t.dapm_routes = tpa6130a2_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(tpa6130a2_dapm_routes),\n};\n\nstatic const struct reg_default tpa6130a2_reg_defaults[] = {\n\t{ TPA6130A2_REG_CONTROL, TPA6130A2_SWS },\n\t{ TPA6130A2_REG_VOL_MUTE, TPA6130A2_MUTE_R | TPA6130A2_MUTE_L },\n};\n\nstatic const struct regmap_config tpa6130a2_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = TPA6130A2_REG_VERSION,\n\t.reg_defaults = tpa6130a2_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(tpa6130a2_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct i2c_device_id tpa6130a2_id[] = {\n\t{ \"tpa6130a2\", TPA6130A2 },\n\t{ \"tpa6140a2\", TPA6140A2 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tpa6130a2_id);\n\nstatic int tpa6130a2_probe(struct i2c_client *client)\n{\n\tstruct device *dev;\n\tstruct tpa6130a2_data *data;\n\tstruct tpa6130a2_platform_data *pdata = client->dev.platform_data;\n\tstruct device_node *np = client->dev.of_node;\n\tconst struct i2c_device_id *id;\n\tconst char *regulator;\n\tunsigned int version;\n\tint ret;\n\n\tdev = &client->dev;\n\n\tdata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = dev;\n\n\tdata->regmap = devm_regmap_init_i2c(client, &tpa6130a2_regmap_config);\n\tif (IS_ERR(data->regmap))\n\t\treturn PTR_ERR(data->regmap);\n\n\tif (pdata) {\n\t\tdata->power_gpio = pdata->power_gpio;\n\t} else if (np) {\n\t\tdata->power_gpio = of_get_named_gpio(np, \"power-gpio\", 0);\n\t} else {\n\t\tdev_err(dev, \"Platform data not set\\n\");\n\t\tdump_stack();\n\t\treturn -ENODEV;\n\t}\n\n\ti2c_set_clientdata(client, data);\n\n\tid = i2c_match_id(tpa6130a2_id, client);\n\tdata->id = id->driver_data;\n\n\tif (data->power_gpio >= 0) {\n\t\tret = devm_gpio_request(dev, data->power_gpio,\n\t\t\t\t\t\"tpa6130a2 enable\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to request power GPIO (%d)\\n\",\n\t\t\t\tdata->power_gpio);\n\t\t\treturn ret;\n\t\t}\n\t\tgpio_direction_output(data->power_gpio, 0);\n\t}\n\n\tswitch (data->id) {\n\tdefault:\n\t\tdev_warn(dev, \"Unknown TPA model (%d). Assuming 6130A2\\n\",\n\t\t\t data->id);\n\t\tfallthrough;\n\tcase TPA6130A2:\n\t\tregulator = \"Vdd\";\n\t\tbreak;\n\tcase TPA6140A2:\n\t\tregulator = \"AVdd\";\n\t\tbreak;\n\t}\n\n\tdata->supply = devm_regulator_get(dev, regulator);\n\tif (IS_ERR(data->supply)) {\n\t\tret = PTR_ERR(data->supply);\n\t\tdev_err(dev, \"Failed to request supply: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = tpa6130a2_power(data, true);\n\tif (ret != 0)\n\t\treturn ret;\n\n\n\t \n\tregmap_read(data->regmap, TPA6130A2_REG_VERSION, &version);\n\tversion &= TPA6130A2_VERSION_MASK;\n\tif ((version != 1) && (version != 2))\n\t\tdev_warn(dev, \"UNTESTED version detected (%d)\\n\", version);\n\n\t \n\tret = tpa6130a2_power(data, false);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(&client->dev,\n\t\t\t&tpa6130a2_component_driver, NULL, 0);\n}\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tpa6130a2_of_match[] = {\n\t{ .compatible = \"ti,tpa6130a2\", },\n\t{ .compatible = \"ti,tpa6140a2\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tpa6130a2_of_match);\n#endif\n\nstatic struct i2c_driver tpa6130a2_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tpa6130a2\",\n\t\t.of_match_table = of_match_ptr(tpa6130a2_of_match),\n\t},\n\t.probe = tpa6130a2_probe,\n\t.id_table = tpa6130a2_id,\n};\n\nmodule_i2c_driver(tpa6130a2_i2c_driver);\n\nMODULE_AUTHOR(\"Peter Ujfalusi <peter.ujfalusi@ti.com>\");\nMODULE_DESCRIPTION(\"TPA6130A2 Headphone amplifier driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}