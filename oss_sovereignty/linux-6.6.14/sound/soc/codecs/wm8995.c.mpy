{
  "module_name": "wm8995.c",
  "hash_id": "8fb0ef96da0a3cb9f55f9f2e31f4d949568605b78713e44277982d3ac57e27fc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8995.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8995.h\"\n\n#define WM8995_NUM_SUPPLIES 8\nstatic const char *wm8995_supply_names[WM8995_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD1\",\n\t\"DBVDD2\",\n\t\"DBVDD3\",\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"CPVDD\",\n\t\"MICVDD\"\n};\n\nstatic const struct reg_default wm8995_reg_defaults[] = {\n\t{ 0, 0x8995 },\n\t{ 5, 0x0100 },\n\t{ 16, 0x000b },\n\t{ 17, 0x000b },\n\t{ 24, 0x02c0 },\n\t{ 25, 0x02c0 },\n\t{ 26, 0x02c0 },\n\t{ 27, 0x02c0 },\n\t{ 28, 0x000f },\n\t{ 32, 0x0005 },\n\t{ 33, 0x0005 },\n\t{ 40, 0x0003 },\n\t{ 41, 0x0013 },\n\t{ 48, 0x0004 },\n\t{ 56, 0x09f8 },\n\t{ 64, 0x1f25 },\n\t{ 69, 0x0004 },\n\t{ 82, 0xaaaa },\n\t{ 84, 0x2a2a },\n\t{ 146, 0x0060 },\n\t{ 256, 0x0002 },\n\t{ 257, 0x8004 },\n\t{ 520, 0x0010 },\n\t{ 528, 0x0083 },\n\t{ 529, 0x0083 },\n\t{ 548, 0x0c80 },\n\t{ 580, 0x0c80 },\n\t{ 768, 0x4050 },\n\t{ 769, 0x4000 },\n\t{ 771, 0x0040 },\n\t{ 772, 0x0040 },\n\t{ 773, 0x0040 },\n\t{ 774, 0x0004 },\n\t{ 775, 0x0100 },\n\t{ 784, 0x4050 },\n\t{ 785, 0x4000 },\n\t{ 787, 0x0040 },\n\t{ 788, 0x0040 },\n\t{ 789, 0x0040 },\n\t{ 1024, 0x00c0 },\n\t{ 1025, 0x00c0 },\n\t{ 1026, 0x00c0 },\n\t{ 1027, 0x00c0 },\n\t{ 1028, 0x00c0 },\n\t{ 1029, 0x00c0 },\n\t{ 1030, 0x00c0 },\n\t{ 1031, 0x00c0 },\n\t{ 1056, 0x0200 },\n\t{ 1057, 0x0010 },\n\t{ 1058, 0x0200 },\n\t{ 1059, 0x0010 },\n\t{ 1088, 0x0098 },\n\t{ 1089, 0x0845 },\n\t{ 1104, 0x0098 },\n\t{ 1105, 0x0845 },\n\t{ 1152, 0x6318 },\n\t{ 1153, 0x6300 },\n\t{ 1154, 0x0fca },\n\t{ 1155, 0x0400 },\n\t{ 1156, 0x00d8 },\n\t{ 1157, 0x1eb5 },\n\t{ 1158, 0xf145 },\n\t{ 1159, 0x0b75 },\n\t{ 1160, 0x01c5 },\n\t{ 1161, 0x1c58 },\n\t{ 1162, 0xf373 },\n\t{ 1163, 0x0a54 },\n\t{ 1164, 0x0558 },\n\t{ 1165, 0x168e },\n\t{ 1166, 0xf829 },\n\t{ 1167, 0x07ad },\n\t{ 1168, 0x1103 },\n\t{ 1169, 0x0564 },\n\t{ 1170, 0x0559 },\n\t{ 1171, 0x4000 },\n\t{ 1184, 0x6318 },\n\t{ 1185, 0x6300 },\n\t{ 1186, 0x0fca },\n\t{ 1187, 0x0400 },\n\t{ 1188, 0x00d8 },\n\t{ 1189, 0x1eb5 },\n\t{ 1190, 0xf145 },\n\t{ 1191, 0x0b75 },\n\t{ 1192, 0x01c5 },\n\t{ 1193, 0x1c58 },\n\t{ 1194, 0xf373 },\n\t{ 1195, 0x0a54 },\n\t{ 1196, 0x0558 },\n\t{ 1197, 0x168e },\n\t{ 1198, 0xf829 },\n\t{ 1199, 0x07ad },\n\t{ 1200, 0x1103 },\n\t{ 1201, 0x0564 },\n\t{ 1202, 0x0559 },\n\t{ 1203, 0x4000 },\n\t{ 1280, 0x00c0 },\n\t{ 1281, 0x00c0 },\n\t{ 1282, 0x00c0 },\n\t{ 1283, 0x00c0 },\n\t{ 1312, 0x0200 },\n\t{ 1313, 0x0010 },\n\t{ 1344, 0x0098 },\n\t{ 1345, 0x0845 },\n\t{ 1408, 0x6318 },\n\t{ 1409, 0x6300 },\n\t{ 1410, 0x0fca },\n\t{ 1411, 0x0400 },\n\t{ 1412, 0x00d8 },\n\t{ 1413, 0x1eb5 },\n\t{ 1414, 0xf145 },\n\t{ 1415, 0x0b75 },\n\t{ 1416, 0x01c5 },\n\t{ 1417, 0x1c58 },\n\t{ 1418, 0xf373 },\n\t{ 1419, 0x0a54 },\n\t{ 1420, 0x0558 },\n\t{ 1421, 0x168e },\n\t{ 1422, 0xf829 },\n\t{ 1423, 0x07ad },\n\t{ 1424, 0x1103 },\n\t{ 1425, 0x0564 },\n\t{ 1426, 0x0559 },\n\t{ 1427, 0x4000 },\n\t{ 1568, 0x0002 },\n\t{ 1792, 0xa100 },\n\t{ 1793, 0xa101 },\n\t{ 1794, 0xa101 },\n\t{ 1795, 0xa101 },\n\t{ 1796, 0xa101 },\n\t{ 1797, 0xa101 },\n\t{ 1798, 0xa101 },\n\t{ 1799, 0xa101 },\n\t{ 1800, 0xa101 },\n\t{ 1801, 0xa101 },\n\t{ 1802, 0xa101 },\n\t{ 1803, 0xa101 },\n\t{ 1804, 0xa101 },\n\t{ 1805, 0xa101 },\n\t{ 1825, 0x0055 },\n\t{ 1848, 0x3fff },\n\t{ 1849, 0x1fff },\n\t{ 2049, 0x0001 },\n\t{ 2050, 0x0069 },\n\t{ 2056, 0x0002 },\n\t{ 2057, 0x0003 },\n\t{ 2058, 0x0069 },\n\t{ 12288, 0x0001 },\n\t{ 12289, 0x0001 },\n\t{ 12291, 0x0006 },\n\t{ 12292, 0x0040 },\n\t{ 12293, 0x0001 },\n\t{ 12294, 0x000f },\n\t{ 12295, 0x0006 },\n\t{ 12296, 0x0001 },\n\t{ 12297, 0x0003 },\n\t{ 12298, 0x0104 },\n\t{ 12300, 0x0060 },\n\t{ 12301, 0x0011 },\n\t{ 12302, 0x0401 },\n\t{ 12304, 0x0050 },\n\t{ 12305, 0x0003 },\n\t{ 12306, 0x0100 },\n\t{ 12308, 0x0051 },\n\t{ 12309, 0x0003 },\n\t{ 12310, 0x0104 },\n\t{ 12311, 0x000a },\n\t{ 12312, 0x0060 },\n\t{ 12313, 0x003b },\n\t{ 12314, 0x0502 },\n\t{ 12315, 0x0100 },\n\t{ 12316, 0x2fff },\n\t{ 12320, 0x2fff },\n\t{ 12324, 0x2fff },\n\t{ 12328, 0x2fff },\n\t{ 12332, 0x2fff },\n\t{ 12336, 0x2fff },\n\t{ 12340, 0x2fff },\n\t{ 12344, 0x2fff },\n\t{ 12348, 0x2fff },\n\t{ 12352, 0x0001 },\n\t{ 12353, 0x0001 },\n\t{ 12355, 0x0006 },\n\t{ 12356, 0x0040 },\n\t{ 12357, 0x0001 },\n\t{ 12358, 0x000f },\n\t{ 12359, 0x0006 },\n\t{ 12360, 0x0001 },\n\t{ 12361, 0x0003 },\n\t{ 12362, 0x0104 },\n\t{ 12364, 0x0060 },\n\t{ 12365, 0x0011 },\n\t{ 12366, 0x0401 },\n\t{ 12368, 0x0050 },\n\t{ 12369, 0x0003 },\n\t{ 12370, 0x0100 },\n\t{ 12372, 0x0060 },\n\t{ 12373, 0x003b },\n\t{ 12374, 0x0502 },\n\t{ 12375, 0x0100 },\n\t{ 12376, 0x2fff },\n\t{ 12380, 0x2fff },\n\t{ 12384, 0x2fff },\n\t{ 12388, 0x2fff },\n\t{ 12392, 0x2fff },\n\t{ 12396, 0x2fff },\n\t{ 12400, 0x2fff },\n\t{ 12404, 0x2fff },\n\t{ 12408, 0x2fff },\n\t{ 12412, 0x2fff },\n\t{ 12416, 0x0001 },\n\t{ 12417, 0x0001 },\n\t{ 12419, 0x0006 },\n\t{ 12420, 0x0040 },\n\t{ 12421, 0x0001 },\n\t{ 12422, 0x000f },\n\t{ 12423, 0x0006 },\n\t{ 12424, 0x0001 },\n\t{ 12425, 0x0003 },\n\t{ 12426, 0x0106 },\n\t{ 12428, 0x0061 },\n\t{ 12429, 0x0011 },\n\t{ 12430, 0x0401 },\n\t{ 12432, 0x0050 },\n\t{ 12433, 0x0003 },\n\t{ 12434, 0x0102 },\n\t{ 12436, 0x0051 },\n\t{ 12437, 0x0003 },\n\t{ 12438, 0x0106 },\n\t{ 12439, 0x000a },\n\t{ 12440, 0x0061 },\n\t{ 12441, 0x003b },\n\t{ 12442, 0x0502 },\n\t{ 12443, 0x0100 },\n\t{ 12444, 0x2fff },\n\t{ 12448, 0x2fff },\n\t{ 12452, 0x2fff },\n\t{ 12456, 0x2fff },\n\t{ 12460, 0x2fff },\n\t{ 12464, 0x2fff },\n\t{ 12468, 0x2fff },\n\t{ 12472, 0x2fff },\n\t{ 12476, 0x2fff },\n\t{ 12480, 0x0001 },\n\t{ 12481, 0x0001 },\n\t{ 12483, 0x0006 },\n\t{ 12484, 0x0040 },\n\t{ 12485, 0x0001 },\n\t{ 12486, 0x000f },\n\t{ 12487, 0x0006 },\n\t{ 12488, 0x0001 },\n\t{ 12489, 0x0003 },\n\t{ 12490, 0x0106 },\n\t{ 12492, 0x0061 },\n\t{ 12493, 0x0011 },\n\t{ 12494, 0x0401 },\n\t{ 12496, 0x0050 },\n\t{ 12497, 0x0003 },\n\t{ 12498, 0x0102 },\n\t{ 12500, 0x0061 },\n\t{ 12501, 0x003b },\n\t{ 12502, 0x0502 },\n\t{ 12503, 0x0100 },\n\t{ 12504, 0x2fff },\n\t{ 12508, 0x2fff },\n\t{ 12512, 0x2fff },\n\t{ 12516, 0x2fff },\n\t{ 12520, 0x2fff },\n\t{ 12524, 0x2fff },\n\t{ 12528, 0x2fff },\n\t{ 12532, 0x2fff },\n\t{ 12536, 0x2fff },\n\t{ 12540, 0x2fff },\n\t{ 12544, 0x0060 },\n\t{ 12546, 0x0601 },\n\t{ 12548, 0x0050 },\n\t{ 12550, 0x0100 },\n\t{ 12552, 0x0001 },\n\t{ 12554, 0x0104 },\n\t{ 12555, 0x0100 },\n\t{ 12556, 0x2fff },\n\t{ 12560, 0x2fff },\n\t{ 12564, 0x2fff },\n\t{ 12568, 0x2fff },\n\t{ 12572, 0x2fff },\n\t{ 12576, 0x2fff },\n\t{ 12580, 0x2fff },\n\t{ 12584, 0x2fff },\n\t{ 12588, 0x2fff },\n\t{ 12592, 0x2fff },\n\t{ 12596, 0x2fff },\n\t{ 12600, 0x2fff },\n\t{ 12604, 0x2fff },\n\t{ 12608, 0x0061 },\n\t{ 12610, 0x0601 },\n\t{ 12612, 0x0050 },\n\t{ 12614, 0x0102 },\n\t{ 12616, 0x0001 },\n\t{ 12618, 0x0106 },\n\t{ 12619, 0x0100 },\n\t{ 12620, 0x2fff },\n\t{ 12624, 0x2fff },\n\t{ 12628, 0x2fff },\n\t{ 12632, 0x2fff },\n\t{ 12636, 0x2fff },\n\t{ 12640, 0x2fff },\n\t{ 12644, 0x2fff },\n\t{ 12648, 0x2fff },\n\t{ 12652, 0x2fff },\n\t{ 12656, 0x2fff },\n\t{ 12660, 0x2fff },\n\t{ 12664, 0x2fff },\n\t{ 12668, 0x2fff },\n\t{ 12672, 0x0060 },\n\t{ 12674, 0x0601 },\n\t{ 12676, 0x0061 },\n\t{ 12678, 0x0601 },\n\t{ 12680, 0x0050 },\n\t{ 12682, 0x0300 },\n\t{ 12684, 0x0001 },\n\t{ 12686, 0x0304 },\n\t{ 12688, 0x0040 },\n\t{ 12690, 0x000f },\n\t{ 12692, 0x0001 },\n\t{ 12695, 0x0100 },\n};\n\nstruct fll_config {\n\tint src;\n\tint in;\n\tint out;\n};\n\nstruct wm8995_priv {\n\tstruct regmap *regmap;\n\tint sysclk[2];\n\tint mclk[2];\n\tint aifclk[2];\n\tstruct fll_config fll[2], fll_suspend[2];\n\tstruct regulator_bulk_data supplies[WM8995_NUM_SUPPLIES];\n\tstruct notifier_block disable_nb[WM8995_NUM_SUPPLIES];\n\tstruct snd_soc_component *component;\n};\n\n \n#define WM8995_REGULATOR_EVENT(n) \\\nstatic int wm8995_regulator_event_##n(struct notifier_block *nb, \\\n\t\t\t\t      unsigned long event, void *data)    \\\n{ \\\n\tstruct wm8995_priv *wm8995 = container_of(nb, struct wm8995_priv, \\\n\t\t\t\t     disable_nb[n]); \\\n\tif (event & REGULATOR_EVENT_DISABLE) { \\\n\t\tregcache_mark_dirty(wm8995->regmap);\t\\\n\t} \\\n\treturn 0; \\\n}\n\nWM8995_REGULATOR_EVENT(0)\nWM8995_REGULATOR_EVENT(1)\nWM8995_REGULATOR_EVENT(2)\nWM8995_REGULATOR_EVENT(3)\nWM8995_REGULATOR_EVENT(4)\nWM8995_REGULATOR_EVENT(5)\nWM8995_REGULATOR_EVENT(6)\nWM8995_REGULATOR_EVENT(7)\n\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -7200, 75, 1);\nstatic const DECLARE_TLV_DB_SCALE(in1lr_pga_tlv, -1650, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(in1l_boost_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(sidetone_tlv, -3600, 150, 0);\n\nstatic const char *in1l_text[] = {\n\t\"Differential\", \"Single-ended IN1LN\", \"Single-ended IN1LP\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(in1l_enum, WM8995_LEFT_LINE_INPUT_CONTROL,\n\t\t\t    2, in1l_text);\n\nstatic const char *in1r_text[] = {\n\t\"Differential\", \"Single-ended IN1RN\", \"Single-ended IN1RP\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(in1r_enum, WM8995_LEFT_LINE_INPUT_CONTROL,\n\t\t\t    0, in1r_text);\n\nstatic const char *dmic_src_text[] = {\n\t\"DMICDAT1\", \"DMICDAT2\", \"DMICDAT3\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dmic_src1_enum, WM8995_POWER_MANAGEMENT_5,\n\t\t\t    8, dmic_src_text);\nstatic SOC_ENUM_SINGLE_DECL(dmic_src2_enum, WM8995_POWER_MANAGEMENT_5,\n\t\t\t    6, dmic_src_text);\n\nstatic const struct snd_kcontrol_new wm8995_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC1 Volume\", WM8995_DAC1_LEFT_VOLUME,\n\t\tWM8995_DAC1_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R(\"DAC1 Switch\", WM8995_DAC1_LEFT_VOLUME,\n\t\tWM8995_DAC1_RIGHT_VOLUME, 9, 1, 1),\n\n\tSOC_DOUBLE_R_TLV(\"DAC2 Volume\", WM8995_DAC2_LEFT_VOLUME,\n\t\tWM8995_DAC2_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R(\"DAC2 Switch\", WM8995_DAC2_LEFT_VOLUME,\n\t\tWM8995_DAC2_RIGHT_VOLUME, 9, 1, 1),\n\n\tSOC_DOUBLE_R_TLV(\"AIF1DAC1 Volume\", WM8995_AIF1_DAC1_LEFT_VOLUME,\n\t\tWM8995_AIF1_DAC1_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"AIF1DAC2 Volume\", WM8995_AIF1_DAC2_LEFT_VOLUME,\n\t\tWM8995_AIF1_DAC2_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"AIF2DAC Volume\", WM8995_AIF2_DAC_LEFT_VOLUME,\n\t\tWM8995_AIF2_DAC_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"IN1LR Volume\", WM8995_LEFT_LINE_INPUT_1_VOLUME,\n\t\tWM8995_RIGHT_LINE_INPUT_1_VOLUME, 0, 31, 0, in1lr_pga_tlv),\n\n\tSOC_SINGLE_TLV(\"IN1L Boost\", WM8995_LEFT_LINE_INPUT_CONTROL,\n\t\t4, 3, 0, in1l_boost_tlv),\n\n\tSOC_ENUM(\"IN1L Mode\", in1l_enum),\n\tSOC_ENUM(\"IN1R Mode\", in1r_enum),\n\n\tSOC_ENUM(\"DMIC1 SRC\", dmic_src1_enum),\n\tSOC_ENUM(\"DMIC2 SRC\", dmic_src2_enum),\n\n\tSOC_DOUBLE_TLV(\"DAC1 Sidetone Volume\", WM8995_DAC1_MIXER_VOLUMES, 0, 5,\n\t\t24, 0, sidetone_tlv),\n\tSOC_DOUBLE_TLV(\"DAC2 Sidetone Volume\", WM8995_DAC2_MIXER_VOLUMES, 0, 5,\n\t\t24, 0, sidetone_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"AIF1ADC1 Volume\", WM8995_AIF1_ADC1_LEFT_VOLUME,\n\t\tWM8995_AIF1_ADC1_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"AIF1ADC2 Volume\", WM8995_AIF1_ADC2_LEFT_VOLUME,\n\t\tWM8995_AIF1_ADC2_RIGHT_VOLUME, 0, 96, 0, digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"AIF2ADC Volume\", WM8995_AIF2_ADC_LEFT_VOLUME,\n\t\tWM8995_AIF2_ADC_RIGHT_VOLUME, 0, 96, 0, digital_tlv)\n};\n\nstatic void wm8995_update_class_w(struct snd_soc_component *component)\n{\n\tint enable = 1;\n\tint source = 0;   \n\tint reg, reg_r;\n\n\t \n\treg = snd_soc_component_read(component, WM8995_DAC1_LEFT_MIXER_ROUTING);\n\tswitch (reg) {\n\tcase WM8995_AIF2DACL_TO_DAC1L:\n\t\tdev_dbg(component->dev, \"Class W source AIF2DAC\\n\");\n\t\tsource = 2 << WM8995_CP_DYN_SRC_SEL_SHIFT;\n\t\tbreak;\n\tcase WM8995_AIF1DAC2L_TO_DAC1L:\n\t\tdev_dbg(component->dev, \"Class W source AIF1DAC2\\n\");\n\t\tsource = 1 << WM8995_CP_DYN_SRC_SEL_SHIFT;\n\t\tbreak;\n\tcase WM8995_AIF1DAC1L_TO_DAC1L:\n\t\tdev_dbg(component->dev, \"Class W source AIF1DAC1\\n\");\n\t\tsource = 0 << WM8995_CP_DYN_SRC_SEL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(component->dev, \"DAC mixer setting: %x\\n\", reg);\n\t\tenable = 0;\n\t\tbreak;\n\t}\n\n\treg_r = snd_soc_component_read(component, WM8995_DAC1_RIGHT_MIXER_ROUTING);\n\tif (reg_r != reg) {\n\t\tdev_dbg(component->dev, \"Left and right DAC mixers different\\n\");\n\t\tenable = 0;\n\t}\n\n\tif (enable) {\n\t\tdev_dbg(component->dev, \"Class W enabled\\n\");\n\t\tsnd_soc_component_update_bits(component, WM8995_CLASS_W_1,\n\t\t\t\t    WM8995_CP_DYN_PWR_MASK |\n\t\t\t\t    WM8995_CP_DYN_SRC_SEL_MASK,\n\t\t\t\t    source | WM8995_CP_DYN_PWR);\n\t} else {\n\t\tdev_dbg(component->dev, \"Class W disabled\\n\");\n\t\tsnd_soc_component_update_bits(component, WM8995_CLASS_W_1,\n\t\t\t\t    WM8995_CP_DYN_PWR_MASK, 0);\n\t}\n}\n\nstatic int check_clk_sys(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tunsigned int reg;\n\tconst char *clk;\n\n\treg = snd_soc_component_read(component, WM8995_CLOCKING_1);\n\t \n\tif (reg & WM8995_SYSCLK_SRC)\n\t\tclk = \"AIF2CLK\";\n\telse\n\t\tclk = \"AIF1CLK\";\n\treturn !strcmp(source->name, clk);\n}\n\nstatic int wm8995_put_class_w(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tint ret;\n\n\tret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\n\twm8995_update_class_w(component);\n\treturn ret;\n}\n\nstatic int hp_supply_event(struct snd_soc_dapm_widget *w,\n\t\t\t   struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8995_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8995_HPOUT1L_ENA_MASK |\n\t\t\t\t    WM8995_HPOUT1R_ENA_MASK,\n\t\t\t\t    WM8995_HPOUT1L_ENA |\n\t\t\t\t    WM8995_HPOUT1R_ENA);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8995_ANALOGUE_HP_1,\n\t\t\t\t    WM8995_HPOUT1L_DLY_MASK |\n\t\t\t\t    WM8995_HPOUT1R_DLY_MASK,\n\t\t\t\t    WM8995_HPOUT1L_DLY |\n\t\t\t\t    WM8995_HPOUT1R_DLY);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8995_CHARGE_PUMP_1,\n\t\t\t\t    WM8995_CP_ENA_MASK, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void dc_servo_cmd(struct snd_soc_component *component,\n\t\t\t unsigned int reg, unsigned int val, unsigned int mask)\n{\n\tint timeout = 10;\n\n\tdev_dbg(component->dev, \"%s: reg = %#x, val = %#x, mask = %#x\\n\",\n\t\t__func__, reg, val, mask);\n\n\tsnd_soc_component_write(component, reg, val);\n\twhile (timeout--) {\n\t\tmsleep(10);\n\t\tval = snd_soc_component_read(component, WM8995_DC_SERVO_READBACK_0);\n\t\tif ((val & mask) == mask)\n\t\t\treturn;\n\t}\n\n\tdev_err(component->dev, \"Timed out waiting for DC Servo\\n\");\n}\n\nstatic int hp_event(struct snd_soc_dapm_widget *w,\n\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM8995_ANALOGUE_HP_1);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, WM8995_CHARGE_PUMP_1,\n\t\t\t\t    WM8995_CP_ENA_MASK, WM8995_CP_ENA);\n\n\t\tmsleep(5);\n\n\t\tsnd_soc_component_update_bits(component, WM8995_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8995_HPOUT1L_ENA_MASK |\n\t\t\t\t    WM8995_HPOUT1R_ENA_MASK,\n\t\t\t\t    WM8995_HPOUT1L_ENA | WM8995_HPOUT1R_ENA);\n\n\t\tudelay(20);\n\n\t\treg |= WM8995_HPOUT1L_DLY | WM8995_HPOUT1R_DLY;\n\t\tsnd_soc_component_write(component, WM8995_ANALOGUE_HP_1, reg);\n\n\t\tsnd_soc_component_write(component, WM8995_DC_SERVO_1, WM8995_DCS_ENA_CHAN_0 |\n\t\t\t      WM8995_DCS_ENA_CHAN_1);\n\n\t\tdc_servo_cmd(component, WM8995_DC_SERVO_2,\n\t\t\t     WM8995_DCS_TRIG_STARTUP_0 |\n\t\t\t     WM8995_DCS_TRIG_STARTUP_1,\n\t\t\t     WM8995_DCS_TRIG_DAC_WR_0 |\n\t\t\t     WM8995_DCS_TRIG_DAC_WR_1);\n\n\t\treg |= WM8995_HPOUT1R_OUTP | WM8995_HPOUT1R_RMV_SHORT |\n\t\t       WM8995_HPOUT1L_OUTP | WM8995_HPOUT1L_RMV_SHORT;\n\t\tsnd_soc_component_write(component, WM8995_ANALOGUE_HP_1, reg);\n\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8995_ANALOGUE_HP_1,\n\t\t\t\t    WM8995_HPOUT1L_OUTP_MASK |\n\t\t\t\t    WM8995_HPOUT1R_OUTP_MASK |\n\t\t\t\t    WM8995_HPOUT1L_RMV_SHORT_MASK |\n\t\t\t\t    WM8995_HPOUT1R_RMV_SHORT_MASK, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8995_ANALOGUE_HP_1,\n\t\t\t\t    WM8995_HPOUT1L_DLY_MASK |\n\t\t\t\t    WM8995_HPOUT1R_DLY_MASK, 0);\n\n\t\tsnd_soc_component_write(component, WM8995_DC_SERVO_1, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8995_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8995_HPOUT1L_ENA_MASK |\n\t\t\t\t    WM8995_HPOUT1R_ENA_MASK,\n\t\t\t\t    0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int configure_aif_clock(struct snd_soc_component *component, int aif)\n{\n\tstruct wm8995_priv *wm8995;\n\tint rate;\n\tint reg1 = 0;\n\tint offset;\n\n\twm8995 = snd_soc_component_get_drvdata(component);\n\n\tif (aif)\n\t\toffset = 4;\n\telse\n\t\toffset = 0;\n\n\tswitch (wm8995->sysclk[aif]) {\n\tcase WM8995_SYSCLK_MCLK1:\n\t\trate = wm8995->mclk[0];\n\t\tbreak;\n\tcase WM8995_SYSCLK_MCLK2:\n\t\treg1 |= 0x8;\n\t\trate = wm8995->mclk[1];\n\t\tbreak;\n\tcase WM8995_SYSCLK_FLL1:\n\t\treg1 |= 0x10;\n\t\trate = wm8995->fll[0].out;\n\t\tbreak;\n\tcase WM8995_SYSCLK_FLL2:\n\t\treg1 |= 0x18;\n\t\trate = wm8995->fll[1].out;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rate >= 13500000) {\n\t\trate /= 2;\n\t\treg1 |= WM8995_AIF1CLK_DIV;\n\n\t\tdev_dbg(component->dev, \"Dividing AIF%d clock to %dHz\\n\",\n\t\t\taif + 1, rate);\n\t}\n\n\twm8995->aifclk[aif] = rate;\n\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_CLOCKING_1 + offset,\n\t\t\t    WM8995_AIF1CLK_SRC_MASK | WM8995_AIF1CLK_DIV_MASK,\n\t\t\t    reg1);\n\treturn 0;\n}\n\nstatic int configure_clock(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct wm8995_priv *wm8995;\n\tint change, new;\n\n\twm8995 = snd_soc_component_get_drvdata(component);\n\n\t \n\tconfigure_aif_clock(component, 0);\n\tconfigure_aif_clock(component, 1);\n\n\t \n\n\t \n\tif (wm8995->aifclk[0] == wm8995->aifclk[1])\n\t\treturn 0;\n\n\tif (wm8995->aifclk[0] < wm8995->aifclk[1])\n\t\tnew = WM8995_SYSCLK_SRC;\n\telse\n\t\tnew = 0;\n\n\tchange = snd_soc_component_update_bits(component, WM8995_CLOCKING_1,\n\t\t\t\t     WM8995_SYSCLK_SRC_MASK, new);\n\tif (!change)\n\t\treturn 0;\n\n\tsnd_soc_dapm_sync(dapm);\n\n\treturn 0;\n}\n\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn configure_clock(component);\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tconfigure_clock(component);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *sidetone_text[] = {\n\t\"ADC/DMIC1\", \"DMIC2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(sidetone1_enum, WM8995_SIDETONE, 0, sidetone_text);\n\nstatic const struct snd_kcontrol_new sidetone1_mux =\n\tSOC_DAPM_ENUM(\"Left Sidetone Mux\", sidetone1_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(sidetone2_enum, WM8995_SIDETONE, 1, sidetone_text);\n\nstatic const struct snd_kcontrol_new sidetone2_mux =\n\tSOC_DAPM_ENUM(\"Right Sidetone Mux\", sidetone2_enum);\n\nstatic const struct snd_kcontrol_new aif1adc1l_mix[] = {\n\tSOC_DAPM_SINGLE(\"ADC/DMIC Switch\", WM8995_AIF1_ADC1_LEFT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_AIF1_ADC1_LEFT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aif1adc1r_mix[] = {\n\tSOC_DAPM_SINGLE(\"ADC/DMIC Switch\", WM8995_AIF1_ADC1_RIGHT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_AIF1_ADC1_RIGHT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aif1adc2l_mix[] = {\n\tSOC_DAPM_SINGLE(\"DMIC Switch\", WM8995_AIF1_ADC2_LEFT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_AIF1_ADC2_LEFT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aif1adc2r_mix[] = {\n\tSOC_DAPM_SINGLE(\"DMIC Switch\", WM8995_AIF1_ADC2_RIGHT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_AIF1_ADC2_RIGHT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new dac1l_mix[] = {\n\tWM8995_CLASS_W_SWITCH(\"Right Sidetone Switch\", WM8995_DAC1_LEFT_MIXER_ROUTING,\n\t\t5, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"Left Sidetone Switch\", WM8995_DAC1_LEFT_MIXER_ROUTING,\n\t\t4, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF2 Switch\", WM8995_DAC1_LEFT_MIXER_ROUTING,\n\t\t2, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF1.2 Switch\", WM8995_DAC1_LEFT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF1.1 Switch\", WM8995_DAC1_LEFT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new dac1r_mix[] = {\n\tWM8995_CLASS_W_SWITCH(\"Right Sidetone Switch\", WM8995_DAC1_RIGHT_MIXER_ROUTING,\n\t\t5, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"Left Sidetone Switch\", WM8995_DAC1_RIGHT_MIXER_ROUTING,\n\t\t4, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF2 Switch\", WM8995_DAC1_RIGHT_MIXER_ROUTING,\n\t\t2, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF1.2 Switch\", WM8995_DAC1_RIGHT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tWM8995_CLASS_W_SWITCH(\"AIF1.1 Switch\", WM8995_DAC1_RIGHT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aif2dac2l_mix[] = {\n\tSOC_DAPM_SINGLE(\"Right Sidetone Switch\", WM8995_DAC2_LEFT_MIXER_ROUTING,\n\t\t5, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Sidetone Switch\", WM8995_DAC2_LEFT_MIXER_ROUTING,\n\t\t4, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_DAC2_LEFT_MIXER_ROUTING,\n\t\t2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF1.2 Switch\", WM8995_DAC2_LEFT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF1.1 Switch\", WM8995_DAC2_LEFT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new aif2dac2r_mix[] = {\n\tSOC_DAPM_SINGLE(\"Right Sidetone Switch\", WM8995_DAC2_RIGHT_MIXER_ROUTING,\n\t\t5, 1, 0),\n\tSOC_DAPM_SINGLE(\"Left Sidetone Switch\", WM8995_DAC2_RIGHT_MIXER_ROUTING,\n\t\t4, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF2 Switch\", WM8995_DAC2_RIGHT_MIXER_ROUTING,\n\t\t2, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF1.2 Switch\", WM8995_DAC2_RIGHT_MIXER_ROUTING,\n\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"AIF1.1 Switch\", WM8995_DAC2_RIGHT_MIXER_ROUTING,\n\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new in1l_pga =\n\tSOC_DAPM_SINGLE(\"IN1L Switch\", WM8995_POWER_MANAGEMENT_2, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new in1r_pga =\n\tSOC_DAPM_SINGLE(\"IN1R Switch\", WM8995_POWER_MANAGEMENT_2, 4, 1, 0);\n\nstatic const char *adc_mux_text[] = {\n\t\"ADC\",\n\t\"DMIC\",\n};\n\nstatic SOC_ENUM_SINGLE_VIRT_DECL(adc_enum, adc_mux_text);\n\nstatic const struct snd_kcontrol_new adcl_mux =\n\tSOC_DAPM_ENUM(\"ADCL Mux\", adc_enum);\n\nstatic const struct snd_kcontrol_new adcr_mux =\n\tSOC_DAPM_ENUM(\"ADCR Mux\", adc_enum);\n\nstatic const char *spk_src_text[] = {\n\t\"DAC1L\", \"DAC1R\", \"DAC2L\", \"DAC2R\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(spk1l_src_enum, WM8995_LEFT_PDM_SPEAKER_1,\n\t\t\t    0, spk_src_text);\nstatic SOC_ENUM_SINGLE_DECL(spk1r_src_enum, WM8995_RIGHT_PDM_SPEAKER_1,\n\t\t\t    0, spk_src_text);\nstatic SOC_ENUM_SINGLE_DECL(spk2l_src_enum, WM8995_LEFT_PDM_SPEAKER_2,\n\t\t\t    0, spk_src_text);\nstatic SOC_ENUM_SINGLE_DECL(spk2r_src_enum, WM8995_RIGHT_PDM_SPEAKER_2,\n\t\t\t    0, spk_src_text);\n\nstatic const struct snd_kcontrol_new spk1l_mux =\n\tSOC_DAPM_ENUM(\"SPK1L SRC\", spk1l_src_enum);\nstatic const struct snd_kcontrol_new spk1r_mux =\n\tSOC_DAPM_ENUM(\"SPK1R SRC\", spk1r_src_enum);\nstatic const struct snd_kcontrol_new spk2l_mux =\n\tSOC_DAPM_ENUM(\"SPK2L SRC\", spk2l_src_enum);\nstatic const struct snd_kcontrol_new spk2r_mux =\n\tSOC_DAPM_ENUM(\"SPK2R SRC\", spk2r_src_enum);\n\nstatic const struct snd_soc_dapm_widget wm8995_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC1DAT\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2DAT\"),\n\n\tSND_SOC_DAPM_INPUT(\"IN1L\"),\n\tSND_SOC_DAPM_INPUT(\"IN1R\"),\n\n\tSND_SOC_DAPM_MIXER(\"IN1L PGA\", SND_SOC_NOPM, 0, 0,\n\t\t&in1l_pga, 1),\n\tSND_SOC_DAPM_MIXER(\"IN1R PGA\", SND_SOC_NOPM, 0, 0,\n\t\t&in1r_pga, 1),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS1\", WM8995_POWER_MANAGEMENT_1, 8, 0,\n\t\t\t    NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS2\", WM8995_POWER_MANAGEMENT_1, 9, 0,\n\t\t\t    NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"AIF1CLK\", WM8995_AIF1_CLOCKING_1, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"AIF2CLK\", WM8995_AIF2_CLOCKING_1, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DSP1CLK\", WM8995_CLOCKING_1, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DSP2CLK\", WM8995_CLOCKING_1, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"SYSDSPCLK\", WM8995_CLOCKING_1, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CLK_SYS\", SND_SOC_NOPM, 0, 0, clk_sys_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1ADC1L\", \"AIF1 Capture\", 0,\n\t\tWM8995_POWER_MANAGEMENT_3, 9, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1ADC1R\", \"AIF1 Capture\", 0,\n\t\tWM8995_POWER_MANAGEMENT_3, 8, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1ADCDAT\", \"AIF1 Capture\", 0,\n\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1ADC2L\", \"AIF1 Capture\",\n\t\t0, WM8995_POWER_MANAGEMENT_3, 11, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1ADC2R\", \"AIF1 Capture\",\n\t\t0, WM8995_POWER_MANAGEMENT_3, 10, 0),\n\n\tSND_SOC_DAPM_MUX(\"ADCL Mux\", SND_SOC_NOPM, 1, 0, &adcl_mux),\n\tSND_SOC_DAPM_MUX(\"ADCR Mux\", SND_SOC_NOPM, 0, 0, &adcr_mux),\n\n\tSND_SOC_DAPM_ADC(\"DMIC2L\", NULL, WM8995_POWER_MANAGEMENT_3, 5, 0),\n\tSND_SOC_DAPM_ADC(\"DMIC2R\", NULL, WM8995_POWER_MANAGEMENT_3, 4, 0),\n\tSND_SOC_DAPM_ADC(\"DMIC1L\", NULL, WM8995_POWER_MANAGEMENT_3, 3, 0),\n\tSND_SOC_DAPM_ADC(\"DMIC1R\", NULL, WM8995_POWER_MANAGEMENT_3, 2, 0),\n\n\tSND_SOC_DAPM_ADC(\"ADCL\", NULL, WM8995_POWER_MANAGEMENT_3, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADCR\", NULL, WM8995_POWER_MANAGEMENT_3, 0, 0),\n\n\tSND_SOC_DAPM_MIXER(\"AIF1ADC1L Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif1adc1l_mix, ARRAY_SIZE(aif1adc1l_mix)),\n\tSND_SOC_DAPM_MIXER(\"AIF1ADC1R Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif1adc1r_mix, ARRAY_SIZE(aif1adc1r_mix)),\n\tSND_SOC_DAPM_MIXER(\"AIF1ADC2L Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif1adc2l_mix, ARRAY_SIZE(aif1adc2l_mix)),\n\tSND_SOC_DAPM_MIXER(\"AIF1ADC2R Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif1adc2r_mix, ARRAY_SIZE(aif1adc2r_mix)),\n\n\tSND_SOC_DAPM_AIF_IN(\"AIF1DAC1L\", NULL, 0, WM8995_POWER_MANAGEMENT_4,\n\t\t9, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF1DAC1R\", NULL, 0, WM8995_POWER_MANAGEMENT_4,\n\t\t8, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF1DACDAT\", \"AIF1 Playback\", 0, SND_SOC_NOPM,\n\t\t0, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"AIF1DAC2L\", NULL, 0, WM8995_POWER_MANAGEMENT_4,\n\t\t11, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF1DAC2R\", NULL, 0, WM8995_POWER_MANAGEMENT_4,\n\t\t10, 0),\n\n\tSND_SOC_DAPM_MIXER(\"AIF2DAC2L Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif2dac2l_mix, ARRAY_SIZE(aif2dac2l_mix)),\n\tSND_SOC_DAPM_MIXER(\"AIF2DAC2R Mixer\", SND_SOC_NOPM, 0, 0,\n\t\taif2dac2r_mix, ARRAY_SIZE(aif2dac2r_mix)),\n\n\tSND_SOC_DAPM_DAC(\"DAC2L\", NULL, WM8995_POWER_MANAGEMENT_4, 3, 0),\n\tSND_SOC_DAPM_DAC(\"DAC2R\", NULL, WM8995_POWER_MANAGEMENT_4, 2, 0),\n\tSND_SOC_DAPM_DAC(\"DAC1L\", NULL, WM8995_POWER_MANAGEMENT_4, 1, 0),\n\tSND_SOC_DAPM_DAC(\"DAC1R\", NULL, WM8995_POWER_MANAGEMENT_4, 0, 0),\n\n\tSND_SOC_DAPM_MIXER(\"DAC1L Mixer\", SND_SOC_NOPM, 0, 0, dac1l_mix,\n\t\tARRAY_SIZE(dac1l_mix)),\n\tSND_SOC_DAPM_MIXER(\"DAC1R Mixer\", SND_SOC_NOPM, 0, 0, dac1r_mix,\n\t\tARRAY_SIZE(dac1r_mix)),\n\n\tSND_SOC_DAPM_MUX(\"Left Sidetone\", SND_SOC_NOPM, 0, 0, &sidetone1_mux),\n\tSND_SOC_DAPM_MUX(\"Right Sidetone\", SND_SOC_NOPM, 0, 0, &sidetone2_mux),\n\n\tSND_SOC_DAPM_PGA_E(\"Headphone PGA\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\thp_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Supply\", SND_SOC_NOPM, 0, 0,\n\t\thp_supply_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_MUX(\"SPK1L Driver\", WM8995_LEFT_PDM_SPEAKER_1,\n\t\t4, 0, &spk1l_mux),\n\tSND_SOC_DAPM_MUX(\"SPK1R Driver\", WM8995_RIGHT_PDM_SPEAKER_1,\n\t\t4, 0, &spk1r_mux),\n\tSND_SOC_DAPM_MUX(\"SPK2L Driver\", WM8995_LEFT_PDM_SPEAKER_2,\n\t\t4, 0, &spk2l_mux),\n\tSND_SOC_DAPM_MUX(\"SPK2R Driver\", WM8995_RIGHT_PDM_SPEAKER_2,\n\t\t4, 0, &spk2r_mux),\n\n\tSND_SOC_DAPM_SUPPLY(\"LDO2\", WM8995_POWER_MANAGEMENT_2, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"HP1L\"),\n\tSND_SOC_DAPM_OUTPUT(\"HP1R\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK1L\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK1R\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK2L\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK2R\")\n};\n\nstatic const struct snd_soc_dapm_route wm8995_intercon[] = {\n\t{ \"CLK_SYS\", NULL, \"AIF1CLK\", check_clk_sys },\n\t{ \"CLK_SYS\", NULL, \"AIF2CLK\", check_clk_sys },\n\n\t{ \"DSP1CLK\", NULL, \"CLK_SYS\" },\n\t{ \"DSP2CLK\", NULL, \"CLK_SYS\" },\n\t{ \"SYSDSPCLK\", NULL, \"CLK_SYS\" },\n\n\t{ \"AIF1ADC1L\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1ADC1L\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1ADC1R\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1ADC1R\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1ADC1R\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"AIF1ADC2L\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1ADC2L\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1ADC2R\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1ADC2R\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1ADC2R\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"DMIC1L\", NULL, \"DMIC1DAT\" },\n\t{ \"DMIC1L\", NULL, \"CLK_SYS\" },\n\t{ \"DMIC1R\", NULL, \"DMIC1DAT\" },\n\t{ \"DMIC1R\", NULL, \"CLK_SYS\" },\n\t{ \"DMIC2L\", NULL, \"DMIC2DAT\" },\n\t{ \"DMIC2L\", NULL, \"CLK_SYS\" },\n\t{ \"DMIC2R\", NULL, \"DMIC2DAT\" },\n\t{ \"DMIC2R\", NULL, \"CLK_SYS\" },\n\n\t{ \"ADCL\", NULL, \"AIF1CLK\" },\n\t{ \"ADCL\", NULL, \"DSP1CLK\" },\n\t{ \"ADCL\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"ADCR\", NULL, \"AIF1CLK\" },\n\t{ \"ADCR\", NULL, \"DSP1CLK\" },\n\t{ \"ADCR\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"IN1L PGA\", \"IN1L Switch\", \"IN1L\" },\n\t{ \"IN1R PGA\", \"IN1R Switch\", \"IN1R\" },\n\t{ \"IN1L PGA\", NULL, \"LDO2\" },\n\t{ \"IN1R PGA\", NULL, \"LDO2\" },\n\n\t{ \"ADCL\", NULL, \"IN1L PGA\" },\n\t{ \"ADCR\", NULL, \"IN1R PGA\" },\n\n\t{ \"ADCL Mux\", \"ADC\", \"ADCL\" },\n\t{ \"ADCL Mux\", \"DMIC\", \"DMIC1L\" },\n\t{ \"ADCR Mux\", \"ADC\", \"ADCR\" },\n\t{ \"ADCR Mux\", \"DMIC\", \"DMIC1R\" },\n\n\t \n\t{ \"AIF1ADC1L\", NULL, \"AIF1ADC1L Mixer\" },\n\t{ \"AIF1ADC1L Mixer\", \"ADC/DMIC Switch\", \"ADCL Mux\" },\n\n\t{ \"AIF1ADC1R\", NULL, \"AIF1ADC1R Mixer\" },\n\t{ \"AIF1ADC1R Mixer\", \"ADC/DMIC Switch\", \"ADCR Mux\" },\n\n\t{ \"AIF1ADC2L\", NULL, \"AIF1ADC2L Mixer\" },\n\t{ \"AIF1ADC2L Mixer\", \"DMIC Switch\", \"DMIC2L\" },\n\n\t{ \"AIF1ADC2R\", NULL, \"AIF1ADC2R Mixer\" },\n\t{ \"AIF1ADC2R Mixer\", \"DMIC Switch\", \"DMIC2R\" },\n\n\t \n\t{ \"Left Sidetone\", \"ADC/DMIC1\", \"AIF1ADC1L\" },\n\t{ \"Left Sidetone\", \"DMIC2\", \"AIF1ADC2L\" },\n\t{ \"Right Sidetone\", \"ADC/DMIC1\", \"AIF1ADC1R\" },\n\t{ \"Right Sidetone\", \"DMIC2\", \"AIF1ADC2R\" },\n\n\t{ \"AIF1DAC1L\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1DAC1L\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1DAC1R\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1DAC1R\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1DAC1R\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"AIF1DAC2L\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1DAC2L\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1DAC2R\", NULL, \"AIF1CLK\" },\n\t{ \"AIF1DAC2R\", NULL, \"DSP1CLK\" },\n\t{ \"AIF1DAC2R\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"DAC1L\", NULL, \"AIF1CLK\" },\n\t{ \"DAC1L\", NULL, \"DSP1CLK\" },\n\t{ \"DAC1L\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"DAC1R\", NULL, \"AIF1CLK\" },\n\t{ \"DAC1R\", NULL, \"DSP1CLK\" },\n\t{ \"DAC1R\", NULL, \"SYSDSPCLK\" },\n\n\t{ \"AIF1DAC1L\", NULL, \"AIF1DACDAT\" },\n\t{ \"AIF1DAC1R\", NULL, \"AIF1DACDAT\" },\n\t{ \"AIF1DAC2L\", NULL, \"AIF1DACDAT\" },\n\t{ \"AIF1DAC2R\", NULL, \"AIF1DACDAT\" },\n\n\t \n\t{ \"DAC1L\", NULL, \"DAC1L Mixer\" },\n\t{ \"DAC1L Mixer\", \"AIF1.1 Switch\", \"AIF1DAC1L\" },\n\t{ \"DAC1L Mixer\", \"AIF1.2 Switch\", \"AIF1DAC2L\" },\n\t{ \"DAC1L Mixer\", \"Left Sidetone Switch\", \"Left Sidetone\" },\n\t{ \"DAC1L Mixer\", \"Right Sidetone Switch\", \"Right Sidetone\" },\n\n\t{ \"DAC1R\", NULL, \"DAC1R Mixer\" },\n\t{ \"DAC1R Mixer\", \"AIF1.1 Switch\", \"AIF1DAC1R\" },\n\t{ \"DAC1R Mixer\", \"AIF1.2 Switch\", \"AIF1DAC2R\" },\n\t{ \"DAC1R Mixer\", \"Left Sidetone Switch\", \"Left Sidetone\" },\n\t{ \"DAC1R Mixer\", \"Right Sidetone Switch\", \"Right Sidetone\" },\n\n\t \n\t{ \"DAC2L\", NULL, \"AIF2DAC2L Mixer\" },\n\t{ \"AIF2DAC2L Mixer\", \"AIF1.2 Switch\", \"AIF1DAC2L\" },\n\t{ \"AIF2DAC2L Mixer\", \"AIF1.1 Switch\", \"AIF1DAC1L\" },\n\n\t{ \"DAC2R\", NULL, \"AIF2DAC2R Mixer\" },\n\t{ \"AIF2DAC2R Mixer\", \"AIF1.2 Switch\", \"AIF1DAC2R\" },\n\t{ \"AIF2DAC2R Mixer\", \"AIF1.1 Switch\", \"AIF1DAC1R\" },\n\n\t \n\t{ \"Headphone PGA\", NULL, \"DAC1L\" },\n\t{ \"Headphone PGA\", NULL, \"DAC1R\" },\n\n\t{ \"Headphone PGA\", NULL, \"DAC2L\" },\n\t{ \"Headphone PGA\", NULL, \"DAC2R\" },\n\n\t{ \"Headphone PGA\", NULL, \"Headphone Supply\" },\n\t{ \"Headphone PGA\", NULL, \"CLK_SYS\" },\n\t{ \"Headphone PGA\", NULL, \"LDO2\" },\n\n\t{ \"HP1L\", NULL, \"Headphone PGA\" },\n\t{ \"HP1R\", NULL, \"Headphone PGA\" },\n\n\t{ \"SPK1L Driver\", \"DAC1L\", \"DAC1L\" },\n\t{ \"SPK1L Driver\", \"DAC1R\", \"DAC1R\" },\n\t{ \"SPK1L Driver\", \"DAC2L\", \"DAC2L\" },\n\t{ \"SPK1L Driver\", \"DAC2R\", \"DAC2R\" },\n\t{ \"SPK1L Driver\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPK1R Driver\", \"DAC1L\", \"DAC1L\" },\n\t{ \"SPK1R Driver\", \"DAC1R\", \"DAC1R\" },\n\t{ \"SPK1R Driver\", \"DAC2L\", \"DAC2L\" },\n\t{ \"SPK1R Driver\", \"DAC2R\", \"DAC2R\" },\n\t{ \"SPK1R Driver\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPK2L Driver\", \"DAC1L\", \"DAC1L\" },\n\t{ \"SPK2L Driver\", \"DAC1R\", \"DAC1R\" },\n\t{ \"SPK2L Driver\", \"DAC2L\", \"DAC2L\" },\n\t{ \"SPK2L Driver\", \"DAC2R\", \"DAC2R\" },\n\t{ \"SPK2L Driver\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPK2R Driver\", \"DAC1L\", \"DAC1L\" },\n\t{ \"SPK2R Driver\", \"DAC1R\", \"DAC1R\" },\n\t{ \"SPK2R Driver\", \"DAC2L\", \"DAC2L\" },\n\t{ \"SPK2R Driver\", \"DAC2R\", \"DAC2R\" },\n\t{ \"SPK2R Driver\", NULL, \"CLK_SYS\" },\n\n\t{ \"SPK1L\", NULL, \"SPK1L Driver\" },\n\t{ \"SPK1R\", NULL, \"SPK1R Driver\" },\n\t{ \"SPK2L\", NULL, \"SPK2L Driver\" },\n\t{ \"SPK2R\", NULL, \"SPK2R Driver\" }\n};\n\nstatic bool wm8995_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8995_SOFTWARE_RESET:\n\tcase WM8995_POWER_MANAGEMENT_1:\n\tcase WM8995_POWER_MANAGEMENT_2:\n\tcase WM8995_POWER_MANAGEMENT_3:\n\tcase WM8995_POWER_MANAGEMENT_4:\n\tcase WM8995_POWER_MANAGEMENT_5:\n\tcase WM8995_LEFT_LINE_INPUT_1_VOLUME:\n\tcase WM8995_RIGHT_LINE_INPUT_1_VOLUME:\n\tcase WM8995_LEFT_LINE_INPUT_CONTROL:\n\tcase WM8995_DAC1_LEFT_VOLUME:\n\tcase WM8995_DAC1_RIGHT_VOLUME:\n\tcase WM8995_DAC2_LEFT_VOLUME:\n\tcase WM8995_DAC2_RIGHT_VOLUME:\n\tcase WM8995_OUTPUT_VOLUME_ZC_1:\n\tcase WM8995_MICBIAS_1:\n\tcase WM8995_MICBIAS_2:\n\tcase WM8995_LDO_1:\n\tcase WM8995_LDO_2:\n\tcase WM8995_ACCESSORY_DETECT_MODE1:\n\tcase WM8995_ACCESSORY_DETECT_MODE2:\n\tcase WM8995_HEADPHONE_DETECT1:\n\tcase WM8995_HEADPHONE_DETECT2:\n\tcase WM8995_MIC_DETECT_1:\n\tcase WM8995_MIC_DETECT_2:\n\tcase WM8995_CHARGE_PUMP_1:\n\tcase WM8995_CLASS_W_1:\n\tcase WM8995_DC_SERVO_1:\n\tcase WM8995_DC_SERVO_2:\n\tcase WM8995_DC_SERVO_3:\n\tcase WM8995_DC_SERVO_5:\n\tcase WM8995_DC_SERVO_6:\n\tcase WM8995_DC_SERVO_7:\n\tcase WM8995_DC_SERVO_READBACK_0:\n\tcase WM8995_ANALOGUE_HP_1:\n\tcase WM8995_ANALOGUE_HP_2:\n\tcase WM8995_CHIP_REVISION:\n\tcase WM8995_CONTROL_INTERFACE_1:\n\tcase WM8995_CONTROL_INTERFACE_2:\n\tcase WM8995_WRITE_SEQUENCER_CTRL_1:\n\tcase WM8995_WRITE_SEQUENCER_CTRL_2:\n\tcase WM8995_AIF1_CLOCKING_1:\n\tcase WM8995_AIF1_CLOCKING_2:\n\tcase WM8995_AIF2_CLOCKING_1:\n\tcase WM8995_AIF2_CLOCKING_2:\n\tcase WM8995_CLOCKING_1:\n\tcase WM8995_CLOCKING_2:\n\tcase WM8995_AIF1_RATE:\n\tcase WM8995_AIF2_RATE:\n\tcase WM8995_RATE_STATUS:\n\tcase WM8995_FLL1_CONTROL_1:\n\tcase WM8995_FLL1_CONTROL_2:\n\tcase WM8995_FLL1_CONTROL_3:\n\tcase WM8995_FLL1_CONTROL_4:\n\tcase WM8995_FLL1_CONTROL_5:\n\tcase WM8995_FLL2_CONTROL_1:\n\tcase WM8995_FLL2_CONTROL_2:\n\tcase WM8995_FLL2_CONTROL_3:\n\tcase WM8995_FLL2_CONTROL_4:\n\tcase WM8995_FLL2_CONTROL_5:\n\tcase WM8995_AIF1_CONTROL_1:\n\tcase WM8995_AIF1_CONTROL_2:\n\tcase WM8995_AIF1_MASTER_SLAVE:\n\tcase WM8995_AIF1_BCLK:\n\tcase WM8995_AIF1ADC_LRCLK:\n\tcase WM8995_AIF1DAC_LRCLK:\n\tcase WM8995_AIF1DAC_DATA:\n\tcase WM8995_AIF1ADC_DATA:\n\tcase WM8995_AIF2_CONTROL_1:\n\tcase WM8995_AIF2_CONTROL_2:\n\tcase WM8995_AIF2_MASTER_SLAVE:\n\tcase WM8995_AIF2_BCLK:\n\tcase WM8995_AIF2ADC_LRCLK:\n\tcase WM8995_AIF2DAC_LRCLK:\n\tcase WM8995_AIF2DAC_DATA:\n\tcase WM8995_AIF2ADC_DATA:\n\tcase WM8995_AIF1_ADC1_LEFT_VOLUME:\n\tcase WM8995_AIF1_ADC1_RIGHT_VOLUME:\n\tcase WM8995_AIF1_DAC1_LEFT_VOLUME:\n\tcase WM8995_AIF1_DAC1_RIGHT_VOLUME:\n\tcase WM8995_AIF1_ADC2_LEFT_VOLUME:\n\tcase WM8995_AIF1_ADC2_RIGHT_VOLUME:\n\tcase WM8995_AIF1_DAC2_LEFT_VOLUME:\n\tcase WM8995_AIF1_DAC2_RIGHT_VOLUME:\n\tcase WM8995_AIF1_ADC1_FILTERS:\n\tcase WM8995_AIF1_ADC2_FILTERS:\n\tcase WM8995_AIF1_DAC1_FILTERS_1:\n\tcase WM8995_AIF1_DAC1_FILTERS_2:\n\tcase WM8995_AIF1_DAC2_FILTERS_1:\n\tcase WM8995_AIF1_DAC2_FILTERS_2:\n\tcase WM8995_AIF1_DRC1_1:\n\tcase WM8995_AIF1_DRC1_2:\n\tcase WM8995_AIF1_DRC1_3:\n\tcase WM8995_AIF1_DRC1_4:\n\tcase WM8995_AIF1_DRC1_5:\n\tcase WM8995_AIF1_DRC2_1:\n\tcase WM8995_AIF1_DRC2_2:\n\tcase WM8995_AIF1_DRC2_3:\n\tcase WM8995_AIF1_DRC2_4:\n\tcase WM8995_AIF1_DRC2_5:\n\tcase WM8995_AIF1_DAC1_EQ_GAINS_1:\n\tcase WM8995_AIF1_DAC1_EQ_GAINS_2:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_1_A:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_1_B:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_1_PG:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_2_A:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_2_B:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_2_C:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_2_PG:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_3_A:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_3_B:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_3_C:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_3_PG:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_4_A:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_4_B:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_4_C:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_4_PG:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_5_A:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_5_B:\n\tcase WM8995_AIF1_DAC1_EQ_BAND_5_PG:\n\tcase WM8995_AIF1_DAC2_EQ_GAINS_1:\n\tcase WM8995_AIF1_DAC2_EQ_GAINS_2:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_1_A:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_1_B:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_1_PG:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_2_A:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_2_B:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_2_C:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_2_PG:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_3_A:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_3_B:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_3_C:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_3_PG:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_4_A:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_4_B:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_4_C:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_4_PG:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_5_A:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_5_B:\n\tcase WM8995_AIF1_DAC2_EQ_BAND_5_PG:\n\tcase WM8995_AIF2_ADC_LEFT_VOLUME:\n\tcase WM8995_AIF2_ADC_RIGHT_VOLUME:\n\tcase WM8995_AIF2_DAC_LEFT_VOLUME:\n\tcase WM8995_AIF2_DAC_RIGHT_VOLUME:\n\tcase WM8995_AIF2_ADC_FILTERS:\n\tcase WM8995_AIF2_DAC_FILTERS_1:\n\tcase WM8995_AIF2_DAC_FILTERS_2:\n\tcase WM8995_AIF2_DRC_1:\n\tcase WM8995_AIF2_DRC_2:\n\tcase WM8995_AIF2_DRC_3:\n\tcase WM8995_AIF2_DRC_4:\n\tcase WM8995_AIF2_DRC_5:\n\tcase WM8995_AIF2_EQ_GAINS_1:\n\tcase WM8995_AIF2_EQ_GAINS_2:\n\tcase WM8995_AIF2_EQ_BAND_1_A:\n\tcase WM8995_AIF2_EQ_BAND_1_B:\n\tcase WM8995_AIF2_EQ_BAND_1_PG:\n\tcase WM8995_AIF2_EQ_BAND_2_A:\n\tcase WM8995_AIF2_EQ_BAND_2_B:\n\tcase WM8995_AIF2_EQ_BAND_2_C:\n\tcase WM8995_AIF2_EQ_BAND_2_PG:\n\tcase WM8995_AIF2_EQ_BAND_3_A:\n\tcase WM8995_AIF2_EQ_BAND_3_B:\n\tcase WM8995_AIF2_EQ_BAND_3_C:\n\tcase WM8995_AIF2_EQ_BAND_3_PG:\n\tcase WM8995_AIF2_EQ_BAND_4_A:\n\tcase WM8995_AIF2_EQ_BAND_4_B:\n\tcase WM8995_AIF2_EQ_BAND_4_C:\n\tcase WM8995_AIF2_EQ_BAND_4_PG:\n\tcase WM8995_AIF2_EQ_BAND_5_A:\n\tcase WM8995_AIF2_EQ_BAND_5_B:\n\tcase WM8995_AIF2_EQ_BAND_5_PG:\n\tcase WM8995_DAC1_MIXER_VOLUMES:\n\tcase WM8995_DAC1_LEFT_MIXER_ROUTING:\n\tcase WM8995_DAC1_RIGHT_MIXER_ROUTING:\n\tcase WM8995_DAC2_MIXER_VOLUMES:\n\tcase WM8995_DAC2_LEFT_MIXER_ROUTING:\n\tcase WM8995_DAC2_RIGHT_MIXER_ROUTING:\n\tcase WM8995_AIF1_ADC1_LEFT_MIXER_ROUTING:\n\tcase WM8995_AIF1_ADC1_RIGHT_MIXER_ROUTING:\n\tcase WM8995_AIF1_ADC2_LEFT_MIXER_ROUTING:\n\tcase WM8995_AIF1_ADC2_RIGHT_MIXER_ROUTING:\n\tcase WM8995_DAC_SOFTMUTE:\n\tcase WM8995_OVERSAMPLING:\n\tcase WM8995_SIDETONE:\n\tcase WM8995_GPIO_1:\n\tcase WM8995_GPIO_2:\n\tcase WM8995_GPIO_3:\n\tcase WM8995_GPIO_4:\n\tcase WM8995_GPIO_5:\n\tcase WM8995_GPIO_6:\n\tcase WM8995_GPIO_7:\n\tcase WM8995_GPIO_8:\n\tcase WM8995_GPIO_9:\n\tcase WM8995_GPIO_10:\n\tcase WM8995_GPIO_11:\n\tcase WM8995_GPIO_12:\n\tcase WM8995_GPIO_13:\n\tcase WM8995_GPIO_14:\n\tcase WM8995_PULL_CONTROL_1:\n\tcase WM8995_PULL_CONTROL_2:\n\tcase WM8995_INTERRUPT_STATUS_1:\n\tcase WM8995_INTERRUPT_STATUS_2:\n\tcase WM8995_INTERRUPT_RAW_STATUS_2:\n\tcase WM8995_INTERRUPT_STATUS_1_MASK:\n\tcase WM8995_INTERRUPT_STATUS_2_MASK:\n\tcase WM8995_INTERRUPT_CONTROL:\n\tcase WM8995_LEFT_PDM_SPEAKER_1:\n\tcase WM8995_RIGHT_PDM_SPEAKER_1:\n\tcase WM8995_PDM_SPEAKER_1_MUTE_SEQUENCE:\n\tcase WM8995_LEFT_PDM_SPEAKER_2:\n\tcase WM8995_RIGHT_PDM_SPEAKER_2:\n\tcase WM8995_PDM_SPEAKER_2_MUTE_SEQUENCE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8995_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8995_SOFTWARE_RESET:\n\tcase WM8995_DC_SERVO_READBACK_0:\n\tcase WM8995_INTERRUPT_STATUS_1:\n\tcase WM8995_INTERRUPT_STATUS_2:\n\tcase WM8995_INTERRUPT_CONTROL:\n\tcase WM8995_ACCESSORY_DETECT_MODE1:\n\tcase WM8995_ACCESSORY_DETECT_MODE2:\n\tcase WM8995_HEADPHONE_DETECT1:\n\tcase WM8995_HEADPHONE_DETECT2:\n\tcase WM8995_RATE_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8995_aif_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint mute_reg;\n\n\tswitch (dai->id) {\n\tcase 0:\n\t\tmute_reg = WM8995_AIF1_DAC1_FILTERS_1;\n\t\tbreak;\n\tcase 1:\n\t\tmute_reg = WM8995_AIF2_DAC_FILTERS_1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, mute_reg, WM8995_AIF1DAC1_MUTE_MASK,\n\t\t\t    !!mute << WM8995_AIF1DAC1_MUTE_SHIFT);\n\treturn 0;\n}\n\nstatic int wm8995_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component;\n\tint master;\n\tint aif;\n\n\tcomponent = dai->component;\n\n\tmaster = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster = WM8995_AIF1_MSTR;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\taif = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif |= WM8995_AIF1_LRCLK_INV;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif |= (0x3 << WM8995_AIF1_FMT_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif |= (0x2 << WM8995_AIF1_FMT_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif |= (0x1 << WM8995_AIF1_FMT_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif |= WM8995_AIF1_BCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif |= WM8995_AIF1_BCLK_INV | WM8995_AIF1_LRCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif |= WM8995_AIF1_BCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif |= WM8995_AIF1_LRCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_CONTROL_1,\n\t\t\t    WM8995_AIF1_BCLK_INV_MASK |\n\t\t\t    WM8995_AIF1_LRCLK_INV_MASK |\n\t\t\t    WM8995_AIF1_FMT_MASK, aif);\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_MASTER_SLAVE,\n\t\t\t    WM8995_AIF1_MSTR_MASK, master);\n\treturn 0;\n}\n\nstatic const int srs[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100,\n\t48000, 88200, 96000\n};\n\nstatic const int fs_ratios[] = {\n\t-1  ,\n\t128, 192, 256, 384, 512, 768, 1024, 1408, 1536\n};\n\nstatic const int bclk_divs[] = {\n\t10, 15, 20, 30, 40, 55, 60, 80, 110, 120, 160, 220, 240, 320, 440, 480\n};\n\nstatic int wm8995_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8995_priv *wm8995;\n\tint aif1_reg;\n\tint bclk_reg;\n\tint lrclk_reg;\n\tint rate_reg;\n\tint bclk_rate;\n\tint aif1;\n\tint lrclk, bclk;\n\tint i, rate_val, best, best_val, cur_val;\n\n\tcomponent = dai->component;\n\twm8995 = snd_soc_component_get_drvdata(component);\n\n\tswitch (dai->id) {\n\tcase 0:\n\t\taif1_reg = WM8995_AIF1_CONTROL_1;\n\t\tbclk_reg = WM8995_AIF1_BCLK;\n\t\trate_reg = WM8995_AIF1_RATE;\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK  ) {\n\t\t\tlrclk_reg = WM8995_AIF1DAC_LRCLK;\n\t\t} else {\n\t\t\tlrclk_reg = WM8995_AIF1ADC_LRCLK;\n\t\t\tdev_dbg(component->dev, \"AIF1 using split LRCLK\\n\");\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\taif1_reg = WM8995_AIF2_CONTROL_1;\n\t\tbclk_reg = WM8995_AIF2_BCLK;\n\t\trate_reg = WM8995_AIF2_RATE;\n\t\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK  ) {\n\t\t\tlrclk_reg = WM8995_AIF2DAC_LRCLK;\n\t\t} else {\n\t\t\tlrclk_reg = WM8995_AIF2ADC_LRCLK;\n\t\t\tdev_dbg(component->dev, \"AIF2 using split LRCLK\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbclk_rate = snd_soc_params_to_bclk(params);\n\tif (bclk_rate < 0)\n\t\treturn bclk_rate;\n\n\taif1 = 0;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\taif1 |= (0x1 << WM8995_AIF1_WL_SHIFT);\n\t\tbreak;\n\tcase 24:\n\t\taif1 |= (0x2 << WM8995_AIF1_WL_SHIFT);\n\t\tbreak;\n\tcase 32:\n\t\taif1 |= (0x3 << WM8995_AIF1_WL_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported word length %u\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(srs); ++i)\n\t\tif (srs[i] == params_rate(params))\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(srs)) {\n\t\tdev_err(dai->dev, \"Sample rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\trate_val = i << WM8995_AIF1_SR_SHIFT;\n\n\tdev_dbg(dai->dev, \"Sample rate is %dHz\\n\", srs[i]);\n\tdev_dbg(dai->dev, \"AIF%dCLK is %dHz, target BCLK %dHz\\n\",\n\t\tdai->id + 1, wm8995->aifclk[dai->id], bclk_rate);\n\n\t \n\tbest = 1;\n\tbest_val = abs((fs_ratios[1] * params_rate(params))\n\t\t       - wm8995->aifclk[dai->id]);\n\tfor (i = 2; i < ARRAY_SIZE(fs_ratios); i++) {\n\t\tcur_val = abs((fs_ratios[i] * params_rate(params))\n\t\t\t      - wm8995->aifclk[dai->id]);\n\t\tif (cur_val >= best_val)\n\t\t\tcontinue;\n\t\tbest = i;\n\t\tbest_val = cur_val;\n\t}\n\trate_val |= best;\n\n\tdev_dbg(dai->dev, \"Selected AIF%dCLK/fs = %d\\n\",\n\t\tdai->id + 1, fs_ratios[best]);\n\n\t \n\tbest = 0;\n\tbclk = 0;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\n\t\tcur_val = (wm8995->aifclk[dai->id] * 10 / bclk_divs[i]) - bclk_rate;\n\t\tif (cur_val < 0)  \n\t\t\tbreak;\n\t\tbest = i;\n\t}\n\tbclk |= best << WM8995_AIF1_BCLK_DIV_SHIFT;\n\n\tbclk_rate = wm8995->aifclk[dai->id] * 10 / bclk_divs[best];\n\tdev_dbg(dai->dev, \"Using BCLK_DIV %d for actual BCLK %dHz\\n\",\n\t\tbclk_divs[best], bclk_rate);\n\n\tlrclk = bclk_rate / params_rate(params);\n\tdev_dbg(dai->dev, \"Using LRCLK rate %d for actual LRCLK %dHz\\n\",\n\t\tlrclk, bclk_rate / lrclk);\n\n\tsnd_soc_component_update_bits(component, aif1_reg,\n\t\t\t    WM8995_AIF1_WL_MASK, aif1);\n\tsnd_soc_component_update_bits(component, bclk_reg,\n\t\t\t    WM8995_AIF1_BCLK_DIV_MASK, bclk);\n\tsnd_soc_component_update_bits(component, lrclk_reg,\n\t\t\t    WM8995_AIF1DAC_RATE_MASK, lrclk);\n\tsnd_soc_component_update_bits(component, rate_reg,\n\t\t\t    WM8995_AIF1_SR_MASK |\n\t\t\t    WM8995_AIF1CLK_RATE_MASK, rate_val);\n\treturn 0;\n}\n\nstatic int wm8995_set_tristate(struct snd_soc_dai *codec_dai, int tristate)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint reg, val, mask;\n\n\tswitch (codec_dai->id) {\n\tcase 0:\n\t\treg = WM8995_AIF1_MASTER_SLAVE;\n\t\tmask = WM8995_AIF1_TRI;\n\t\tbreak;\n\tcase 1:\n\t\treg = WM8995_AIF2_MASTER_SLAVE;\n\t\tmask = WM8995_AIF2_TRI;\n\t\tbreak;\n\tcase 2:\n\t\treg = WM8995_POWER_MANAGEMENT_5;\n\t\tmask = WM8995_AIF3_TRI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (tristate)\n\t\tval = mask;\n\telse\n\t\tval = 0;\n\n\treturn snd_soc_component_update_bits(component, reg, mask, val);\n}\n\n \n#define FIXED_FLL_SIZE ((1 << 16) * 10)\n\nstruct fll_div {\n\tu16 outdiv;\n\tu16 n;\n\tu16 k;\n\tu16 clk_ref_div;\n\tu16 fll_fratio;\n};\n\nstatic int wm8995_get_fll_config(struct fll_div *fll,\n\t\t\t\t int freq_in, int freq_out)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\n\tpr_debug(\"FLL input=%dHz, output=%dHz\\n\", freq_in, freq_out);\n\n\t \n\tfll->clk_ref_div = 0;\n\twhile (freq_in > 13500000) {\n\t\tfll->clk_ref_div++;\n\t\tfreq_in /= 2;\n\n\t\tif (fll->clk_ref_div > 3)\n\t\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"CLK_REF_DIV=%d, Fref=%dHz\\n\", fll->clk_ref_div, freq_in);\n\n\t \n\tfll->outdiv = 3;\n\twhile (freq_out * (fll->outdiv + 1) < 90000000) {\n\t\tfll->outdiv++;\n\t\tif (fll->outdiv > 63)\n\t\t\treturn -EINVAL;\n\t}\n\tfreq_out *= fll->outdiv + 1;\n\tpr_debug(\"OUTDIV=%d, Fvco=%dHz\\n\", fll->outdiv, freq_out);\n\n\tif (freq_in > 1000000) {\n\t\tfll->fll_fratio = 0;\n\t} else if (freq_in > 256000) {\n\t\tfll->fll_fratio = 1;\n\t\tfreq_in *= 2;\n\t} else if (freq_in > 128000) {\n\t\tfll->fll_fratio = 2;\n\t\tfreq_in *= 4;\n\t} else if (freq_in > 64000) {\n\t\tfll->fll_fratio = 3;\n\t\tfreq_in *= 8;\n\t} else {\n\t\tfll->fll_fratio = 4;\n\t\tfreq_in *= 16;\n\t}\n\tpr_debug(\"FLL_FRATIO=%d, Fref=%dHz\\n\", fll->fll_fratio, freq_in);\n\n\t \n\tNdiv = freq_out / freq_in;\n\n\tfll->n = Ndiv;\n\tNmod = freq_out % freq_in;\n\tpr_debug(\"Nmod=%d\\n\", Nmod);\n\n\t \n\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, freq_in);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tfll->k = K / 10;\n\n\tpr_debug(\"N=%x K=%x\\n\", fll->n, fll->k);\n\n\treturn 0;\n}\n\nstatic int wm8995_set_fll(struct snd_soc_dai *dai, int id,\n\t\t\t  int src, unsigned int freq_in,\n\t\t\t  unsigned int freq_out)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8995_priv *wm8995;\n\tint reg_offset, ret;\n\tstruct fll_div fll;\n\tu16 reg, aif1, aif2;\n\n\tcomponent = dai->component;\n\twm8995 = snd_soc_component_get_drvdata(component);\n\n\taif1 = snd_soc_component_read(component, WM8995_AIF1_CLOCKING_1)\n\t       & WM8995_AIF1CLK_ENA;\n\n\taif2 = snd_soc_component_read(component, WM8995_AIF2_CLOCKING_1)\n\t       & WM8995_AIF2CLK_ENA;\n\n\tswitch (id) {\n\tcase WM8995_FLL1:\n\t\treg_offset = 0;\n\t\tid = 0;\n\t\tbreak;\n\tcase WM8995_FLL2:\n\t\treg_offset = 0x20;\n\t\tid = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (src) {\n\tcase 0:\n\t\t \n\t\tif (freq_out)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase WM8995_FLL_SRC_MCLK1:\n\tcase WM8995_FLL_SRC_MCLK2:\n\tcase WM8995_FLL_SRC_LRCLK:\n\tcase WM8995_FLL_SRC_BCLK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wm8995->fll[id].src == src &&\n\t    wm8995->fll[id].in == freq_in && wm8995->fll[id].out == freq_out)\n\t\treturn 0;\n\n\t \n\tif (freq_out)\n\t\tret = wm8995_get_fll_config(&fll, freq_in, freq_out);\n\telse\n\t\tret = wm8995_get_fll_config(&fll, wm8995->fll[id].in,\n\t\t\t\t\t    wm8995->fll[id].out);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8995_AIF1_CLOCKING_1,\n\t\t\t    WM8995_AIF1CLK_ENA_MASK, 0);\n\tsnd_soc_component_update_bits(component, WM8995_AIF2_CLOCKING_1,\n\t\t\t    WM8995_AIF2CLK_ENA_MASK, 0);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8995_FLL1_CONTROL_1 + reg_offset,\n\t\t\t    WM8995_FLL1_ENA_MASK, 0);\n\n\treg = (fll.outdiv << WM8995_FLL1_OUTDIV_SHIFT) |\n\t      (fll.fll_fratio << WM8995_FLL1_FRATIO_SHIFT);\n\tsnd_soc_component_update_bits(component, WM8995_FLL1_CONTROL_2 + reg_offset,\n\t\t\t    WM8995_FLL1_OUTDIV_MASK |\n\t\t\t    WM8995_FLL1_FRATIO_MASK, reg);\n\n\tsnd_soc_component_write(component, WM8995_FLL1_CONTROL_3 + reg_offset, fll.k);\n\n\tsnd_soc_component_update_bits(component, WM8995_FLL1_CONTROL_4 + reg_offset,\n\t\t\t    WM8995_FLL1_N_MASK,\n\t\t\t    fll.n << WM8995_FLL1_N_SHIFT);\n\n\tsnd_soc_component_update_bits(component, WM8995_FLL1_CONTROL_5 + reg_offset,\n\t\t\t    WM8995_FLL1_REFCLK_DIV_MASK |\n\t\t\t    WM8995_FLL1_REFCLK_SRC_MASK,\n\t\t\t    (fll.clk_ref_div << WM8995_FLL1_REFCLK_DIV_SHIFT) |\n\t\t\t    (src - 1));\n\n\tif (freq_out)\n\t\tsnd_soc_component_update_bits(component, WM8995_FLL1_CONTROL_1 + reg_offset,\n\t\t\t\t    WM8995_FLL1_ENA_MASK, WM8995_FLL1_ENA);\n\n\twm8995->fll[id].in = freq_in;\n\twm8995->fll[id].out = freq_out;\n\twm8995->fll[id].src = src;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8995_AIF1_CLOCKING_1,\n\t\t\t    WM8995_AIF1CLK_ENA_MASK, aif1);\n\tsnd_soc_component_update_bits(component, WM8995_AIF2_CLOCKING_1,\n\t\t\t    WM8995_AIF2CLK_ENA_MASK, aif2);\n\n\tconfigure_clock(component);\n\n\treturn 0;\n}\n\nstatic int wm8995_set_dai_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8995_priv *wm8995;\n\n\tcomponent = dai->component;\n\twm8995 = snd_soc_component_get_drvdata(component);\n\n\tswitch (dai->id) {\n\tcase 0:\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tswitch (clk_id) {\n\tcase WM8995_SYSCLK_MCLK1:\n\t\twm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK1;\n\t\twm8995->mclk[0] = freq;\n\t\tdev_dbg(dai->dev, \"AIF%d using MCLK1 at %uHz\\n\",\n\t\t\tdai->id + 1, freq);\n\t\tbreak;\n\tcase WM8995_SYSCLK_MCLK2:\n\t\twm8995->sysclk[dai->id] = WM8995_SYSCLK_MCLK2;\n\t\twm8995->mclk[1] = freq;\n\t\tdev_dbg(dai->dev, \"AIF%d using MCLK2 at %uHz\\n\",\n\t\t\tdai->id + 1, freq);\n\t\tbreak;\n\tcase WM8995_SYSCLK_FLL1:\n\t\twm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL1;\n\t\tdev_dbg(dai->dev, \"AIF%d using FLL1\\n\", dai->id + 1);\n\t\tbreak;\n\tcase WM8995_SYSCLK_FLL2:\n\t\twm8995->sysclk[dai->id] = WM8995_SYSCLK_FLL2;\n\t\tdev_dbg(dai->dev, \"AIF%d using FLL2\\n\", dai->id + 1);\n\t\tbreak;\n\tcase WM8995_SYSCLK_OPCLK:\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown clock source %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tconfigure_clock(component);\n\n\treturn 0;\n}\n\nstatic int wm8995_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8995_priv *wm8995;\n\tint ret;\n\n\twm8995 = snd_soc_component_get_drvdata(component);\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8995->supplies),\n\t\t\t\t\t\t    wm8995->supplies);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = regcache_sync(wm8995->regmap);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tsnd_soc_component_update_bits(component, WM8995_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8995_BG_ENA_MASK, WM8995_BG_ENA);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8995_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8995_BG_ENA_MASK, 0);\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8995->supplies),\n\t\t\t\t       wm8995->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8995_probe(struct snd_soc_component *component)\n{\n\tstruct wm8995_priv *wm8995;\n\tint i;\n\tint ret;\n\n\twm8995 = snd_soc_component_get_drvdata(component);\n\twm8995->component = component;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8995->supplies); i++)\n\t\twm8995->supplies[i].supply = wm8995_supply_names[i];\n\n\tret = devm_regulator_bulk_get(component->dev,\n\t\t\t\t      ARRAY_SIZE(wm8995->supplies),\n\t\t\t\t      wm8995->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8995->disable_nb[0].notifier_call = wm8995_regulator_event_0;\n\twm8995->disable_nb[1].notifier_call = wm8995_regulator_event_1;\n\twm8995->disable_nb[2].notifier_call = wm8995_regulator_event_2;\n\twm8995->disable_nb[3].notifier_call = wm8995_regulator_event_3;\n\twm8995->disable_nb[4].notifier_call = wm8995_regulator_event_4;\n\twm8995->disable_nb[5].notifier_call = wm8995_regulator_event_5;\n\twm8995->disable_nb[6].notifier_call = wm8995_regulator_event_6;\n\twm8995->disable_nb[7].notifier_call = wm8995_regulator_event_7;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wm8995->supplies); i++) {\n\t\tret = devm_regulator_register_notifier(\n\t\t\t\t\t\twm8995->supplies[i].consumer,\n\t\t\t\t\t\t&wm8995->disable_nb[i]);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to register regulator notifier: %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8995->supplies),\n\t\t\t\t    wm8995->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_read(component, WM8995_SOFTWARE_RESET);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\tif (ret != 0x8995) {\n\t\tdev_err(component->dev, \"Invalid device ID: %#x\\n\", ret);\n\t\tret = -EINVAL;\n\t\tgoto err_reg_enable;\n\t}\n\n\tret = snd_soc_component_write(component, WM8995_SOFTWARE_RESET, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8995_AIF1_DAC1_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF1DAC1_VU_MASK, WM8995_AIF1DAC1_VU);\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_DAC2_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF1DAC2_VU_MASK, WM8995_AIF1DAC2_VU);\n\tsnd_soc_component_update_bits(component, WM8995_AIF2_DAC_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF2DAC_VU_MASK, WM8995_AIF2DAC_VU);\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_ADC1_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF1ADC1_VU_MASK, WM8995_AIF1ADC1_VU);\n\tsnd_soc_component_update_bits(component, WM8995_AIF1_ADC2_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF1ADC2_VU_MASK, WM8995_AIF1ADC2_VU);\n\tsnd_soc_component_update_bits(component, WM8995_AIF2_ADC_RIGHT_VOLUME,\n\t\t\t    WM8995_AIF2ADC_VU_MASK, WM8995_AIF1ADC2_VU);\n\tsnd_soc_component_update_bits(component, WM8995_DAC1_RIGHT_VOLUME,\n\t\t\t    WM8995_DAC1_VU_MASK, WM8995_DAC1_VU);\n\tsnd_soc_component_update_bits(component, WM8995_DAC2_RIGHT_VOLUME,\n\t\t\t    WM8995_DAC2_VU_MASK, WM8995_DAC2_VU);\n\tsnd_soc_component_update_bits(component, WM8995_RIGHT_LINE_INPUT_1_VOLUME,\n\t\t\t    WM8995_IN1_VU_MASK, WM8995_IN1_VU);\n\n\twm8995_update_class_w(component);\n\n\treturn 0;\n\nerr_reg_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8995->supplies), wm8995->supplies);\n\treturn ret;\n}\n\n#define WM8995_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8995_aif1_dai_ops = {\n\t.set_sysclk = wm8995_set_dai_sysclk,\n\t.set_fmt = wm8995_set_dai_fmt,\n\t.hw_params = wm8995_hw_params,\n\t.mute_stream = wm8995_aif_mute,\n\t.set_pll = wm8995_set_fll,\n\t.set_tristate = wm8995_set_tristate,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops wm8995_aif2_dai_ops = {\n\t.set_sysclk = wm8995_set_dai_sysclk,\n\t.set_fmt = wm8995_set_dai_fmt,\n\t.hw_params = wm8995_hw_params,\n\t.mute_stream = wm8995_aif_mute,\n\t.set_pll = wm8995_set_fll,\n\t.set_tristate = wm8995_set_tristate,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops wm8995_aif3_dai_ops = {\n\t.set_tristate = wm8995_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver wm8995_dai[] = {\n\t{\n\t\t.name = \"wm8995-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.ops = &wm8995_aif1_dai_ops\n\t},\n\t{\n\t\t.name = \"wm8995-aif2\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF2 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF2 Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.ops = &wm8995_aif2_dai_ops\n\t},\n\t{\n\t\t.name = \"wm8995-aif3\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF3 Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF3 Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = WM8995_FORMATS\n\t\t},\n\t\t.ops = &wm8995_aif3_dai_ops\n\t}\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8995 = {\n\t.probe\t\t\t= wm8995_probe,\n\t.set_bias_level\t\t= wm8995_set_bias_level,\n\t.controls\t\t= wm8995_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8995_snd_controls),\n\t.dapm_widgets\t\t= wm8995_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8995_dapm_widgets),\n\t.dapm_routes\t\t= wm8995_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8995_intercon),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8995_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\n\t.max_register = WM8995_MAX_REGISTER,\n\t.reg_defaults = wm8995_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8995_reg_defaults),\n\t.volatile_reg = wm8995_volatile,\n\t.readable_reg = wm8995_readable,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8995_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8995_priv *wm8995;\n\tint ret;\n\n\twm8995 = devm_kzalloc(&spi->dev, sizeof(*wm8995), GFP_KERNEL);\n\tif (!wm8995)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, wm8995);\n\n\twm8995->regmap = devm_regmap_init_spi(spi, &wm8995_regmap);\n\tif (IS_ERR(wm8995->regmap)) {\n\t\tret = PTR_ERR(wm8995->regmap);\n\t\tdev_err(&spi->dev, \"Failed to register regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t     &soc_component_dev_wm8995, wm8995_dai,\n\t\t\t\t     ARRAY_SIZE(wm8995_dai));\n\treturn ret;\n}\n\nstatic struct spi_driver wm8995_spi_driver = {\n\t.driver = {\n\t\t.name = \"wm8995\",\n\t},\n\t.probe = wm8995_spi_probe,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8995_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8995_priv *wm8995;\n\tint ret;\n\n\twm8995 = devm_kzalloc(&i2c->dev, sizeof(*wm8995), GFP_KERNEL);\n\tif (!wm8995)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm8995);\n\n\twm8995->regmap = devm_regmap_init_i2c(i2c, &wm8995_regmap);\n\tif (IS_ERR(wm8995->regmap)) {\n\t\tret = PTR_ERR(wm8995->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to register regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_wm8995, wm8995_dai,\n\t\t\t\t     ARRAY_SIZE(wm8995_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8995_i2c_id[] = {\n\t{\"wm8995\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, wm8995_i2c_id);\n\nstatic struct i2c_driver wm8995_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8995\",\n\t},\n\t.probe = wm8995_i2c_probe,\n\t.id_table = wm8995_i2c_id\n};\n#endif\n\nstatic int __init wm8995_modinit(void)\n{\n\tint ret = 0;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8995_i2c_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Failed to register wm8995 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8995_spi_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Failed to register wm8995 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\n\nmodule_init(wm8995_modinit);\n\nstatic void __exit wm8995_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8995_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8995_spi_driver);\n#endif\n}\n\nmodule_exit(wm8995_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8995 driver\");\nMODULE_AUTHOR(\"Dimitris Papastamos <dp@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}