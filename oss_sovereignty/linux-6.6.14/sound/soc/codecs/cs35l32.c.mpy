{
  "module_name": "cs35l32.c",
  "hash_id": "501520953bf5963c016a164a8a05f49fc10dec9440d7ee44692e201d02a89fba",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l32.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/gpio.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <dt-bindings/sound/cs35l32.h>\n\n#include \"cs35l32.h\"\n#include \"cirrus_legacy.h\"\n\n#define CS35L32_NUM_SUPPLIES 2\nstatic const char *const cs35l32_supply_names[CS35L32_NUM_SUPPLIES] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstruct  cs35l32_private {\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tstruct regulator_bulk_data supplies[CS35L32_NUM_SUPPLIES];\n\tstruct cs35l32_platform_data pdata;\n\tstruct gpio_desc *reset_gpio;\n};\n\nstatic const struct reg_default cs35l32_reg_defaults[] = {\n\n\t{ 0x06, 0x04 },  \n\t{ 0x07, 0xE8 },  \n\t{ 0x08, 0x40 },  \n\t{ 0x09, 0x20 },  \n\t{ 0x0A, 0x00 },  \n\t{ 0x0B, 0x40 },  \n\t{ 0x0C, 0x07 },  \n\t{ 0x0D, 0x03 },  \n\t{ 0x0F, 0x20 },  \n\t{ 0x10, 0x14 },  \n\t{ 0x11, 0x00 },  \n\t{ 0x12, 0xFF },  \n\t{ 0x13, 0xFF },  \n\t{ 0x14, 0xFF },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1A, 0x00 },  \n\t{ 0x1B, 0x20 },  \n\t{ 0x1C, 0x00 },  \n};\n\nstatic bool cs35l32_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L32_DEVID_AB ... CS35L32_AUDIO_LED_MNGR:\n\tcase CS35L32_ADSP_CTL ... CS35L32_FLASH_INHIBIT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l32_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L32_DEVID_AB ... CS35L32_REV_ID:\n\tcase CS35L32_INT_STATUS_1 ... CS35L32_LED_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l32_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L32_INT_STATUS_1 ... CS35L32_LED_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(classd_ctl_tlv, 900, 300, 0);\n\nstatic const struct snd_kcontrol_new imon_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS35L32_PWRCTL2, 6, 1, 1);\n\nstatic const struct snd_kcontrol_new vmon_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS35L32_PWRCTL2, 7, 1, 1);\n\nstatic const struct snd_kcontrol_new vpmon_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CS35L32_PWRCTL2, 5, 1, 1);\n\nstatic const struct snd_kcontrol_new cs35l32_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", CS35L32_CLASSD_CTL,\n\t\t       3, 0x04, 1, classd_ctl_tlv),\n\tSOC_SINGLE(\"Zero Cross Switch\", CS35L32_CLASSD_CTL, 2, 1, 0),\n\tSOC_SINGLE(\"Gain Manager Switch\", CS35L32_AUDIO_LED_MNGR, 3, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget cs35l32_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_SUPPLY(\"BOOST\", CS35L32_PWRCTL1, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV(\"Speaker\", CS35L32_PWRCTL1, 7, 1, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT\", NULL, 0, CS35L32_PWRCTL2, 3, 1),\n\n\tSND_SOC_DAPM_INPUT(\"VP\"),\n\tSND_SOC_DAPM_INPUT(\"ISENSE\"),\n\tSND_SOC_DAPM_INPUT(\"VSENSE\"),\n\n\tSND_SOC_DAPM_SWITCH(\"VMON ADC\", CS35L32_PWRCTL2, 7, 1, &vmon_ctl),\n\tSND_SOC_DAPM_SWITCH(\"IMON ADC\", CS35L32_PWRCTL2, 6, 1, &imon_ctl),\n\tSND_SOC_DAPM_SWITCH(\"VPMON ADC\", CS35L32_PWRCTL2, 5, 1, &vpmon_ctl),\n};\n\nstatic const struct snd_soc_dapm_route cs35l32_audio_map[] = {\n\n\t{\"Speaker\", NULL, \"BOOST\"},\n\n\t{\"VMON ADC\", NULL, \"VSENSE\"},\n\t{\"IMON ADC\", NULL, \"ISENSE\"},\n\t{\"VPMON ADC\", NULL, \"VP\"},\n\n\t{\"SDOUT\", \"Switch\", \"VMON ADC\"},\n\t{\"SDOUT\",  \"Switch\", \"IMON ADC\"},\n\t{\"SDOUT\", \"Switch\", \"VPMON ADC\"},\n\n\t{\"Capture\", NULL, \"SDOUT\"},\n};\n\nstatic int cs35l32_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tsnd_soc_component_update_bits(component, CS35L32_ADSP_CTL,\n\t\t\t\t    CS35L32_ADSP_MASTER_MASK,\n\t\t\t\tCS35L32_ADSP_MASTER_MASK);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tsnd_soc_component_update_bits(component, CS35L32_ADSP_CTL,\n\t\t\t\t    CS35L32_ADSP_MASTER_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l32_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\treturn snd_soc_component_update_bits(component, CS35L32_PWRCTL2,\n\t\t\t\t\tCS35L32_SDOUT_3ST, tristate << 3);\n}\n\nstatic const struct snd_soc_dai_ops cs35l32_ops = {\n\t.set_fmt = cs35l32_set_dai_fmt,\n\t.set_tristate = cs35l32_set_tristate,\n};\n\nstatic struct snd_soc_dai_driver cs35l32_dai[] = {\n\t{\n\t\t.name = \"cs35l32-monitor\",\n\t\t.id = 0,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS35L32_RATES,\n\t\t\t.formats = CS35L32_FORMATS,\n\t\t},\n\t\t.ops = &cs35l32_ops,\n\t\t.symmetric_rate = 1,\n\t}\n};\n\nstatic int cs35l32_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t      int clk_id, int source, unsigned int freq, int dir)\n{\n\tunsigned int val;\n\n\tswitch (freq) {\n\tcase 6000000:\n\t\tval = CS35L32_MCLK_RATIO;\n\t\tbreak;\n\tcase 12000000:\n\t\tval = CS35L32_MCLK_DIV2_MASK | CS35L32_MCLK_RATIO;\n\t\tbreak;\n\tcase 6144000:\n\t\tval = 0;\n\t\tbreak;\n\tcase 12288000:\n\t\tval = CS35L32_MCLK_DIV2_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_component_update_bits(component, CS35L32_CLK_CTL,\n\t\t\tCS35L32_MCLK_DIV2_MASK | CS35L32_MCLK_RATIO_MASK, val);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l32 = {\n\t.set_sysclk\t\t= cs35l32_component_set_sysclk,\n\t.controls\t\t= cs35l32_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs35l32_snd_controls),\n\t.dapm_widgets\t\t= cs35l32_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs35l32_dapm_widgets),\n\t.dapm_routes\t\t= cs35l32_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs35l32_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n \nstatic const struct reg_sequence cs35l32_monitor_patch[] = {\n\n\t{ 0x00, 0x99 },\n\t{ 0x48, 0x17 },\n\t{ 0x49, 0x56 },\n\t{ 0x43, 0x01 },\n\t{ 0x3B, 0x62 },\n\t{ 0x3C, 0x80 },\n\t{ 0x00, 0x00 },\n};\n\nstatic const struct regmap_config cs35l32_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS35L32_MAX_REGISTER,\n\t.reg_defaults = cs35l32_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l32_reg_defaults),\n\t.volatile_reg = cs35l32_volatile_register,\n\t.readable_reg = cs35l32_readable_register,\n\t.precious_reg = cs35l32_precious_register,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int cs35l32_handle_of_data(struct i2c_client *i2c_client,\n\t\t\t\t    struct cs35l32_platform_data *pdata)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tunsigned int val;\n\n\tif (of_property_read_u32(np, \"cirrus,sdout-share\", &val) >= 0)\n\t\tpdata->sdout_share = val;\n\n\tif (of_property_read_u32(np, \"cirrus,boost-manager\", &val))\n\t\tval = -1u;\n\n\tswitch (val) {\n\tcase CS35L32_BOOST_MGR_AUTO:\n\tcase CS35L32_BOOST_MGR_AUTO_AUDIO:\n\tcase CS35L32_BOOST_MGR_BYPASS:\n\tcase CS35L32_BOOST_MGR_FIXED:\n\t\tpdata->boost_mng = val;\n\t\tbreak;\n\tcase -1u:\n\tdefault:\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Wrong cirrus,boost-manager DT value %d\\n\", val);\n\t\tpdata->boost_mng = CS35L32_BOOST_MGR_BYPASS;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,sdout-datacfg\", &val))\n\t\tval = -1u;\n\tswitch (val) {\n\tcase CS35L32_DATA_CFG_LR_VP:\n\tcase CS35L32_DATA_CFG_LR_STAT:\n\tcase CS35L32_DATA_CFG_LR:\n\tcase CS35L32_DATA_CFG_LR_VPSTAT:\n\t\tpdata->sdout_datacfg = val;\n\t\tbreak;\n\tcase -1u:\n\tdefault:\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Wrong cirrus,sdout-datacfg DT value %d\\n\", val);\n\t\tpdata->sdout_datacfg = CS35L32_DATA_CFG_LR;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,battery-threshold\", &val))\n\t\tval = -1u;\n\tswitch (val) {\n\tcase CS35L32_BATT_THRESH_3_1V:\n\tcase CS35L32_BATT_THRESH_3_2V:\n\tcase CS35L32_BATT_THRESH_3_3V:\n\tcase CS35L32_BATT_THRESH_3_4V:\n\t\tpdata->batt_thresh = val;\n\t\tbreak;\n\tcase -1u:\n\tdefault:\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Wrong cirrus,battery-threshold DT value %d\\n\", val);\n\t\tpdata->batt_thresh = CS35L32_BATT_THRESH_3_3V;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,battery-recovery\", &val))\n\t\tval = -1u;\n\tswitch (val) {\n\tcase CS35L32_BATT_RECOV_3_1V:\n\tcase CS35L32_BATT_RECOV_3_2V:\n\tcase CS35L32_BATT_RECOV_3_3V:\n\tcase CS35L32_BATT_RECOV_3_4V:\n\tcase CS35L32_BATT_RECOV_3_5V:\n\tcase CS35L32_BATT_RECOV_3_6V:\n\t\tpdata->batt_recov = val;\n\t\tbreak;\n\tcase -1u:\n\tdefault:\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Wrong cirrus,battery-recovery DT value %d\\n\", val);\n\t\tpdata->batt_recov = CS35L32_BATT_RECOV_3_4V;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l32_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs35l32_private *cs35l32;\n\tstruct cs35l32_platform_data *pdata =\n\t\tdev_get_platdata(&i2c_client->dev);\n\tint ret, i, devid;\n\tunsigned int reg;\n\n\tcs35l32 = devm_kzalloc(&i2c_client->dev, sizeof(*cs35l32), GFP_KERNEL);\n\tif (!cs35l32)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c_client, cs35l32);\n\n\tcs35l32->regmap = devm_regmap_init_i2c(i2c_client, &cs35l32_regmap);\n\tif (IS_ERR(cs35l32->regmap)) {\n\t\tret = PTR_ERR(cs35l32->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs35l32->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(&i2c_client->dev, sizeof(*pdata),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tret = cs35l32_handle_of_data(i2c_client,\n\t\t\t\t\t\t     &cs35l32->pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l32->supplies); i++)\n\t\tcs35l32->supplies[i].supply = cs35l32_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\t\t\t      ARRAY_SIZE(cs35l32->supplies),\n\t\t\t\t      cs35l32->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs35l32->supplies),\n\t\t\t\t    cs35l32->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs35l32->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\n\t\t\"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l32->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l32->reset_gpio);\n\t\tgoto err_supplies;\n\t}\n\n\tgpiod_set_value_cansleep(cs35l32->reset_gpio, 1);\n\n\t \n\tdevid = cirrus_read_device_id(cs35l32->regmap, CS35L32_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(&i2c_client->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_disable;\n\t}\n\n\tif (devid != CS35L32_CHIP_ID) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS35L32 Device ID (%X). Expected %X\\n\",\n\t\t\tdevid, CS35L32_CHIP_ID);\n\t\tgoto err_disable;\n\t}\n\n\tret = regmap_read(cs35l32->regmap, CS35L32_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err_disable;\n\t}\n\n\tret = regmap_register_patch(cs35l32->regmap, cs35l32_monitor_patch,\n\t\t\t\t    ARRAY_SIZE(cs35l32_monitor_patch));\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Failed to apply errata patch\\n\");\n\t\tgoto err_disable;\n\t}\n\n\tdev_info(&i2c_client->dev,\n\t\t \"Cirrus Logic CS35L32, Revision: %02X\\n\", reg & 0xFF);\n\n\t \n\tif (cs35l32->pdata.boost_mng)\n\t\tregmap_update_bits(cs35l32->regmap, CS35L32_AUDIO_LED_MNGR,\n\t\t\t\t   CS35L32_BOOST_MASK,\n\t\t\t\tcs35l32->pdata.boost_mng);\n\n\t \n\tif (cs35l32->pdata.sdout_share)\n\t\tregmap_update_bits(cs35l32->regmap, CS35L32_ADSP_CTL,\n\t\t\t\t    CS35L32_ADSP_SHARE_MASK,\n\t\t\t\tcs35l32->pdata.sdout_share << 3);\n\n\t \n\tif (cs35l32->pdata.sdout_datacfg)\n\t\tregmap_update_bits(cs35l32->regmap, CS35L32_ADSP_CTL,\n\t\t\t\t   CS35L32_ADSP_DATACFG_MASK,\n\t\t\t\tcs35l32->pdata.sdout_datacfg << 4);\n\n\t \n\tif (cs35l32->pdata.batt_recov)\n\t\tregmap_update_bits(cs35l32->regmap, CS35L32_BATT_THRESHOLD,\n\t\t\t\t   CS35L32_BATT_REC_MASK,\n\t\t\t\tcs35l32->pdata.batt_recov << 1);\n\n\t \n\tif (cs35l32->pdata.batt_thresh)\n\t\tregmap_update_bits(cs35l32->regmap, CS35L32_BATT_THRESHOLD,\n\t\t\t\t   CS35L32_BATT_THRESH_MASK,\n\t\t\t\tcs35l32->pdata.batt_thresh << 4);\n\n\t \n\tregmap_update_bits(cs35l32->regmap, CS35L32_PWRCTL1, CS35L32_PDN_AMP,\n\t\t\t    CS35L32_PDN_AMP);\n\n\t \n\tregmap_read(cs35l32->regmap, CS35L32_INT_STATUS_1, &reg);\n\n\tret = devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs35l32, cs35l32_dai,\n\t\t\tARRAY_SIZE(cs35l32_dai));\n\tif (ret < 0)\n\t\tgoto err_disable;\n\n\treturn 0;\n\nerr_disable:\n\tgpiod_set_value_cansleep(cs35l32->reset_gpio, 0);\nerr_supplies:\n\tregulator_bulk_disable(ARRAY_SIZE(cs35l32->supplies),\n\t\t\t       cs35l32->supplies);\n\treturn ret;\n}\n\nstatic void cs35l32_i2c_remove(struct i2c_client *i2c_client)\n{\n\tstruct cs35l32_private *cs35l32 = i2c_get_clientdata(i2c_client);\n\n\t \n\tgpiod_set_value_cansleep(cs35l32->reset_gpio, 0);\n}\n\n#ifdef CONFIG_PM\nstatic int cs35l32_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l32_private *cs35l32 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs35l32->regmap, true);\n\tregcache_mark_dirty(cs35l32->regmap);\n\n\t \n\tgpiod_set_value_cansleep(cs35l32->reset_gpio, 0);\n\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(cs35l32->supplies),\n\t\t\t       cs35l32->supplies);\n\n\treturn 0;\n}\n\nstatic int cs35l32_runtime_resume(struct device *dev)\n{\n\tstruct cs35l32_private *cs35l32 = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(cs35l32->supplies),\n\t\t\t\t    cs35l32->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(cs35l32->reset_gpio, 1);\n\n\tregcache_cache_only(cs35l32->regmap, false);\n\tregcache_sync(cs35l32->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops cs35l32_runtime_pm = {\n\tSET_RUNTIME_PM_OPS(cs35l32_runtime_suspend, cs35l32_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id cs35l32_of_match[] = {\n\t{ .compatible = \"cirrus,cs35l32\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs35l32_of_match);\n\n\nstatic const struct i2c_device_id cs35l32_id[] = {\n\t{\"cs35l32\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs35l32_id);\n\nstatic struct i2c_driver cs35l32_i2c_driver = {\n\t.driver = {\n\t\t   .name = \"cs35l32\",\n\t\t   .pm = &cs35l32_runtime_pm,\n\t\t   .of_match_table = cs35l32_of_match,\n\t\t   },\n\t.id_table = cs35l32_id,\n\t.probe = cs35l32_i2c_probe,\n\t.remove = cs35l32_i2c_remove,\n};\n\nmodule_i2c_driver(cs35l32_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS35L32 driver\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}