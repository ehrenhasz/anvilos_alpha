{
  "module_name": "mc13783.c",
  "hash_id": "1c3caa3dfcca035653760a7aff4a134a3fe21f0e1db9a2dd78fa85b23c0111f6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/mc13783.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/mfd/mc13xxx.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/soc-dapm.h>\n#include <linux/regmap.h>\n\n#include \"mc13783.h\"\n\n#define AUDIO_RX0_ALSPEN\t\t(1 << 5)\n#define AUDIO_RX0_ALSPSEL\t\t(1 << 7)\n#define AUDIO_RX0_ADDCDC\t\t(1 << 21)\n#define AUDIO_RX0_ADDSTDC\t\t(1 << 22)\n#define AUDIO_RX0_ADDRXIN\t\t(1 << 23)\n\n#define AUDIO_RX1_PGARXEN\t\t(1 << 0);\n#define AUDIO_RX1_PGASTEN\t\t(1 << 5)\n#define AUDIO_RX1_ARXINEN\t\t(1 << 10)\n\n#define AUDIO_TX_AMC1REN\t\t(1 << 5)\n#define AUDIO_TX_AMC1LEN\t\t(1 << 7)\n#define AUDIO_TX_AMC2EN\t\t\t(1 << 9)\n#define AUDIO_TX_ATXINEN\t\t(1 << 11)\n#define AUDIO_TX_RXINREC\t\t(1 << 13)\n\n#define SSI_NETWORK_CDCTXRXSLOT(x)\t(((x) & 0x3) << 2)\n#define SSI_NETWORK_CDCTXSECSLOT(x)\t(((x) & 0x3) << 4)\n#define SSI_NETWORK_CDCRXSECSLOT(x)\t(((x) & 0x3) << 6)\n#define SSI_NETWORK_CDCRXSECGAIN(x)\t(((x) & 0x3) << 8)\n#define SSI_NETWORK_CDCSUMGAIN(x)\t(1 << 10)\n#define SSI_NETWORK_CDCFSDLY(x)\t\t(1 << 11)\n#define SSI_NETWORK_DAC_SLOTS_8\t\t(1 << 12)\n#define SSI_NETWORK_DAC_SLOTS_4\t\t(2 << 12)\n#define SSI_NETWORK_DAC_SLOTS_2\t\t(3 << 12)\n#define SSI_NETWORK_DAC_SLOT_MASK\t(3 << 12)\n#define SSI_NETWORK_DAC_RXSLOT_0_1\t(0 << 14)\n#define SSI_NETWORK_DAC_RXSLOT_2_3\t(1 << 14)\n#define SSI_NETWORK_DAC_RXSLOT_4_5\t(2 << 14)\n#define SSI_NETWORK_DAC_RXSLOT_6_7\t(3 << 14)\n#define SSI_NETWORK_DAC_RXSLOT_MASK\t(3 << 14)\n#define SSI_NETWORK_STDCRXSECSLOT(x)\t(((x) & 0x3) << 16)\n#define SSI_NETWORK_STDCRXSECGAIN(x)\t(((x) & 0x3) << 18)\n#define SSI_NETWORK_STDCSUMGAIN\t\t(1 << 20)\n\n \n#define AUDIO_SSI_SEL\t\t\t(1 << 0)\n#define AUDIO_CLK_SEL\t\t\t(1 << 1)\n#define AUDIO_CSM\t\t\t(1 << 2)\n#define AUDIO_BCL_INV\t\t\t(1 << 3)\n#define AUDIO_CFS_INV\t\t\t(1 << 4)\n#define AUDIO_CFS(x)\t\t\t(((x) & 0x3) << 5)\n#define AUDIO_CLK(x)\t\t\t(((x) & 0x7) << 7)\n#define AUDIO_C_EN\t\t\t(1 << 11)\n#define AUDIO_C_CLK_EN\t\t\t(1 << 12)\n#define AUDIO_C_RESET\t\t\t(1 << 15)\n\n#define AUDIO_CODEC_CDCFS8K16K\t\t(1 << 10)\n#define AUDIO_DAC_CFS_DLY_B\t\t(1 << 10)\n\nstruct mc13783_priv {\n\tstruct mc13xxx *mc13xxx;\n\tstruct regmap *regmap;\n\n\tenum mc13783_ssi_port adc_ssi_port;\n\tenum mc13783_ssi_port dac_ssi_port;\n};\n\n \nstatic unsigned int mc13783_rates[] = {\n\t8000, 11025, 12000, 16000,\n\t22050, 24000, 32000, 44100,\n\t48000, 64000, 96000\n};\n\nstatic int mc13783_pcm_hw_params_dac(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int rate = params_rate(params);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mc13783_rates); i++) {\n\t\tif (rate == mc13783_rates[i]) {\n\t\t\tsnd_soc_component_update_bits(component, MC13783_AUDIO_DAC,\n\t\t\t\t\t0xf << 17, i << 17);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int mc13783_pcm_hw_params_codec(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int rate = params_rate(params);\n\tunsigned int val;\n\n\tswitch (rate) {\n\tcase 8000:\n\t\tval = 0;\n\t\tbreak;\n\tcase 16000:\n\t\tval = AUDIO_CODEC_CDCFS8K16K;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, MC13783_AUDIO_CODEC, AUDIO_CODEC_CDCFS8K16K,\n\t\t\tval);\n\n\treturn 0;\n}\n\nstatic int mc13783_pcm_hw_params_sync(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn mc13783_pcm_hw_params_dac(substream, params, dai);\n\telse\n\t\treturn mc13783_pcm_hw_params_codec(substream, params, dai);\n}\n\nstatic int mc13783_set_fmt(struct snd_soc_dai *dai, unsigned int fmt,\n\t\t\tunsigned int reg)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val = 0;\n\tunsigned int mask = AUDIO_CFS(3) | AUDIO_BCL_INV | AUDIO_CFS_INV |\n\t\t\t\tAUDIO_CSM | AUDIO_C_CLK_EN | AUDIO_C_RESET;\n\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= AUDIO_CFS(2);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tval |= AUDIO_CFS(1);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval |= AUDIO_BCL_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval |= AUDIO_BCL_INV | AUDIO_CFS_INV;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval |= AUDIO_CFS_INV;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tval |= AUDIO_C_CLK_EN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tval |= AUDIO_CSM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval |= AUDIO_C_RESET;\n\n\tsnd_soc_component_update_bits(component, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int mc13783_set_fmt_async(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tif (dai->id == MC13783_ID_STEREO_DAC)\n\t\treturn mc13783_set_fmt(dai, fmt, MC13783_AUDIO_DAC);\n\telse\n\t\treturn mc13783_set_fmt(dai, fmt, MC13783_AUDIO_CODEC);\n}\n\nstatic int mc13783_set_fmt_sync(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tint ret;\n\n\tret = mc13783_set_fmt(dai, fmt, MC13783_AUDIO_DAC);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfmt &= ~SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK;\n\tfmt |= SND_SOC_DAIFMT_CBC_CFC;\n\tret = mc13783_set_fmt(dai, fmt, MC13783_AUDIO_CODEC);\n\n\treturn ret;\n}\n\nstatic int mc13783_sysclk[] = {\n\t13000000,\n\t15360000,\n\t16800000,\n\t-1,\n\t26000000,\n\t-1,  \n\t-1,  \n\t33600000,\n};\n\nstatic int mc13783_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir,\n\t\t\t\t  unsigned int reg)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint clk;\n\tunsigned int val = 0;\n\tunsigned int mask = AUDIO_CLK(0x7) | AUDIO_CLK_SEL;\n\n\tfor (clk = 0; clk < ARRAY_SIZE(mc13783_sysclk); clk++) {\n\t\tif (mc13783_sysclk[clk] < 0)\n\t\t\tcontinue;\n\t\tif (mc13783_sysclk[clk] == freq)\n\t\t\tbreak;\n\t}\n\n\tif (clk == ARRAY_SIZE(mc13783_sysclk))\n\t\treturn -EINVAL;\n\n\tif (clk_id == MC13783_CLK_CLIB)\n\t\tval |= AUDIO_CLK_SEL;\n\n\tval |= AUDIO_CLK(clk);\n\n\tsnd_soc_component_update_bits(component, reg, mask, val);\n\n\treturn 0;\n}\n\nstatic int mc13783_set_sysclk_dac(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\treturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_DAC);\n}\n\nstatic int mc13783_set_sysclk_codec(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\treturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_CODEC);\n}\n\nstatic int mc13783_set_sysclk_sync(struct snd_soc_dai *dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tint ret;\n\n\tret = mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_DAC);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_CODEC);\n}\n\nstatic int mc13783_set_tdm_slot_dac(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots,\n\tint slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val = 0;\n\tunsigned int mask = SSI_NETWORK_DAC_SLOT_MASK |\n\t\t\t\tSSI_NETWORK_DAC_RXSLOT_MASK;\n\n\tswitch (slots) {\n\tcase 2:\n\t\tval |= SSI_NETWORK_DAC_SLOTS_2;\n\t\tbreak;\n\tcase 4:\n\t\tval |= SSI_NETWORK_DAC_SLOTS_4;\n\t\tbreak;\n\tcase 8:\n\t\tval |= SSI_NETWORK_DAC_SLOTS_8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (rx_mask) {\n\tcase 0x03:\n\t\tval |= SSI_NETWORK_DAC_RXSLOT_0_1;\n\t\tbreak;\n\tcase 0x0c:\n\t\tval |= SSI_NETWORK_DAC_RXSLOT_2_3;\n\t\tbreak;\n\tcase 0x30:\n\t\tval |= SSI_NETWORK_DAC_RXSLOT_4_5;\n\t\tbreak;\n\tcase 0xc0:\n\t\tval |= SSI_NETWORK_DAC_RXSLOT_6_7;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, MC13783_SSI_NETWORK, mask, val);\n\n\treturn 0;\n}\n\nstatic int mc13783_set_tdm_slot_codec(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots,\n\tint slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val = 0;\n\tunsigned int mask = 0x3f;\n\n\tif (slots != 4)\n\t\treturn -EINVAL;\n\n\tif (tx_mask != 0x3)\n\t\treturn -EINVAL;\n\n\tval |= (0x00 << 2);\t \n\tval |= (0x01 << 4);\t \n\n\tsnd_soc_component_update_bits(component, MC13783_SSI_NETWORK, mask, val);\n\n\treturn 0;\n}\n\nstatic int mc13783_set_tdm_slot_sync(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots,\n\tint slot_width)\n{\n\tint ret;\n\n\tret = mc13783_set_tdm_slot_dac(dai, tx_mask, rx_mask, slots,\n\t\t\tslot_width);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mc13783_set_tdm_slot_codec(dai, tx_mask, rx_mask, slots,\n\t\t\tslot_width);\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new mc1l_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_TX, 7, 1, 0);\n\nstatic const struct snd_kcontrol_new mc1r_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_TX, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new mc2_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_TX, 9, 1, 0);\n\nstatic const struct snd_kcontrol_new atx_amp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_TX, 11, 1, 0);\n\n\n \nstatic const char * const adcl_enum_text[] = {\n\t\"MC1L\", \"RXINL\",\n};\n\nstatic SOC_ENUM_SINGLE_VIRT_DECL(adcl_enum, adcl_enum_text);\n\nstatic const struct snd_kcontrol_new left_input_mux =\n\tSOC_DAPM_ENUM(\"Route\", adcl_enum);\n\nstatic const char * const adcr_enum_text[] = {\n\t\"MC1R\", \"MC2\", \"RXINR\", \"TXIN\",\n};\n\nstatic SOC_ENUM_SINGLE_VIRT_DECL(adcr_enum, adcr_enum_text);\n\nstatic const struct snd_kcontrol_new right_input_mux =\n\tSOC_DAPM_ENUM(\"Route\", adcr_enum);\n\nstatic const struct snd_kcontrol_new samp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 3, 1, 0);\n\nstatic const char * const speaker_amp_source_text[] = {\n\t\"CODEC\", \"Right\"\n};\nstatic SOC_ENUM_SINGLE_DECL(speaker_amp_source, MC13783_AUDIO_RX0, 4,\n\t\t\t    speaker_amp_source_text);\nstatic const struct snd_kcontrol_new speaker_amp_source_mux =\n\tSOC_DAPM_ENUM(\"Speaker Amp Source MUX\", speaker_amp_source);\n\nstatic const char * const headset_amp_source_text[] = {\n\t\"CODEC\", \"Mixer\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(headset_amp_source, MC13783_AUDIO_RX0, 11,\n\t\t\t    headset_amp_source_text);\nstatic const struct snd_kcontrol_new headset_amp_source_mux =\n\tSOC_DAPM_ENUM(\"Headset Amp Source MUX\", headset_amp_source);\n\nstatic const struct snd_kcontrol_new cdcout_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 18, 1, 0);\n\nstatic const struct snd_kcontrol_new adc_bypass_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_CODEC, 16, 1, 0);\n\nstatic const struct snd_kcontrol_new lamp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new hlamp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 10, 1, 0);\n\nstatic const struct snd_kcontrol_new hramp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 9, 1, 0);\n\nstatic const struct snd_kcontrol_new llamp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 16, 1, 0);\n\nstatic const struct snd_kcontrol_new lramp_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", MC13783_AUDIO_RX0, 15, 1, 0);\n\nstatic const struct snd_soc_dapm_widget mc13783_dapm_widgets[] = {\n \n\tSND_SOC_DAPM_INPUT(\"MC1LIN\"),\n\tSND_SOC_DAPM_INPUT(\"MC1RIN\"),\n\tSND_SOC_DAPM_INPUT(\"MC2IN\"),\n\tSND_SOC_DAPM_INPUT(\"RXINR\"),\n\tSND_SOC_DAPM_INPUT(\"RXINL\"),\n\tSND_SOC_DAPM_INPUT(\"TXIN\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"MC1 Bias\", MC13783_AUDIO_TX, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MC2 Bias\", MC13783_AUDIO_TX, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"MC1L Amp\", MC13783_AUDIO_TX, 7, 0, &mc1l_amp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"MC1R Amp\", MC13783_AUDIO_TX, 5, 0, &mc1r_amp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"MC2 Amp\", MC13783_AUDIO_TX, 9, 0, &mc2_amp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"TXIN Amp\", MC13783_AUDIO_TX, 11, 0, &atx_amp_ctl),\n\n\tSND_SOC_DAPM_MUX(\"PGA Left Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t      &left_input_mux),\n\tSND_SOC_DAPM_MUX(\"PGA Right Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t      &right_input_mux),\n\n\tSND_SOC_DAPM_MUX(\"Speaker Amp Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &speaker_amp_source_mux),\n\n\tSND_SOC_DAPM_MUX(\"Headset Amp Source MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t &headset_amp_source_mux),\n\n\tSND_SOC_DAPM_PGA(\"PGA Left Input\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"PGA Right Input\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", MC13783_AUDIO_CODEC, 11, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ADC_Reset\", MC13783_AUDIO_CODEC, 15, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Voice CODEC PGA\", MC13783_AUDIO_RX1, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SWITCH(\"Voice CODEC Bypass\", MC13783_AUDIO_CODEC, 16, 0,\n\t\t\t&adc_bypass_ctl),\n\n \n\tSND_SOC_DAPM_SUPPLY(\"DAC_E\", MC13783_AUDIO_DAC, 11, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAC_Reset\", MC13783_AUDIO_DAC, 15, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"RXOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"RXOUTR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSR\"),\n\tSND_SOC_DAPM_OUTPUT(\"LSPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"LSP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SP\"),\n\tSND_SOC_DAPM_OUTPUT(\"CDCOUT\"),\n\n\tSND_SOC_DAPM_SWITCH(\"CDCOUT Switch\", MC13783_AUDIO_RX0, 18, 0,\n\t\t\t&cdcout_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Speaker Amp Switch\", MC13783_AUDIO_RX0, 3, 0,\n\t\t\t&samp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Loudspeaker Amp\", SND_SOC_NOPM, 0, 0, &lamp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Headset Amp Left\", MC13783_AUDIO_RX0, 10, 0,\n\t\t\t&hlamp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Headset Amp Right\", MC13783_AUDIO_RX0, 9, 0,\n\t\t\t&hramp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Line out Amp Left\", MC13783_AUDIO_RX0, 16, 0,\n\t\t\t&llamp_ctl),\n\tSND_SOC_DAPM_SWITCH(\"Line out Amp Right\", MC13783_AUDIO_RX0, 15, 0,\n\t\t\t&lramp_ctl),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", MC13783_AUDIO_RX0, 22, 0),\n\tSND_SOC_DAPM_PGA(\"DAC PGA\", MC13783_AUDIO_RX1, 5, 0, NULL, 0),\n};\n\nstatic struct snd_soc_dapm_route mc13783_routes[] = {\n \n\t{ \"MC1L Amp\", NULL, \"MC1LIN\"},\n\t{ \"MC1R Amp\", NULL, \"MC1RIN\" },\n\t{ \"MC2 Amp\", NULL, \"MC2IN\" },\n\t{ \"TXIN Amp\", NULL, \"TXIN\"},\n\n\t{ \"PGA Left Input Mux\", \"MC1L\", \"MC1L Amp\" },\n\t{ \"PGA Left Input Mux\", \"RXINL\", \"RXINL\"},\n\t{ \"PGA Right Input Mux\", \"MC1R\", \"MC1R Amp\" },\n\t{ \"PGA Right Input Mux\", \"MC2\",  \"MC2 Amp\"},\n\t{ \"PGA Right Input Mux\", \"TXIN\", \"TXIN Amp\"},\n\t{ \"PGA Right Input Mux\", \"RXINR\", \"RXINR\"},\n\n\t{ \"PGA Left Input\", NULL, \"PGA Left Input Mux\"},\n\t{ \"PGA Right Input\", NULL, \"PGA Right Input Mux\"},\n\n\t{ \"ADC\", NULL, \"PGA Left Input\"},\n\t{ \"ADC\", NULL, \"PGA Right Input\"},\n\t{ \"ADC\", NULL, \"ADC_Reset\"},\n\n\t{ \"Voice CODEC PGA\", \"Voice CODEC Bypass\", \"ADC\" },\n\n\t{ \"Speaker Amp Source MUX\", \"CODEC\", \"Voice CODEC PGA\"},\n\t{ \"Speaker Amp Source MUX\", \"Right\", \"DAC PGA\"},\n\n\t{ \"Headset Amp Source MUX\", \"CODEC\", \"Voice CODEC PGA\"},\n\t{ \"Headset Amp Source MUX\", \"Mixer\", \"DAC PGA\"},\n\n \n\t{ \"HSL\", NULL, \"Headset Amp Left\" },\n\t{ \"HSR\", NULL, \"Headset Amp Right\"},\n\t{ \"RXOUTL\", NULL, \"Line out Amp Left\"},\n\t{ \"RXOUTR\", NULL, \"Line out Amp Right\"},\n\t{ \"SP\", \"Speaker Amp Switch\", \"Speaker Amp Source MUX\"},\n\t{ \"LSP\", \"Loudspeaker Amp\", \"Speaker Amp Source MUX\"},\n\t{ \"HSL\", \"Headset Amp Left\", \"Headset Amp Source MUX\"},\n\t{ \"HSR\", \"Headset Amp Right\", \"Headset Amp Source MUX\"},\n\t{ \"Line out Amp Left\", NULL, \"DAC PGA\"},\n\t{ \"Line out Amp Right\", NULL, \"DAC PGA\"},\n\t{ \"DAC PGA\", NULL, \"DAC\"},\n\t{ \"DAC\", NULL, \"DAC_E\"},\n\t{ \"CDCOUT\", \"CDCOUT Switch\", \"Voice CODEC PGA\"},\n};\n\nstatic const char * const mc13783_3d_mixer[] = {\"Stereo\", \"Phase Mix\",\n\t\t\t\t\t\t\"Mono\", \"Mono Mix\"};\n\nstatic SOC_ENUM_SINGLE_DECL(mc13783_enum_3d_mixer,\n\t\t\t    MC13783_AUDIO_RX1, 16,\n\t\t\t    mc13783_3d_mixer);\n\nstatic struct snd_kcontrol_new mc13783_control_list[] = {\n\tSOC_SINGLE(\"Loudspeaker enable\", MC13783_AUDIO_RX0, 5, 1, 0),\n\tSOC_SINGLE(\"PCM Playback Volume\", MC13783_AUDIO_RX1, 6, 15, 0),\n\tSOC_SINGLE(\"PCM Playback Switch\", MC13783_AUDIO_RX1, 5, 1, 0),\n\tSOC_DOUBLE(\"PCM Capture Volume\", MC13783_AUDIO_TX, 19, 14, 31, 0),\n\tSOC_ENUM(\"3D Control\", mc13783_enum_3d_mixer),\n\n\tSOC_SINGLE(\"CDCOUT Switch\", MC13783_AUDIO_RX0, 18, 1, 0),\n\tSOC_SINGLE(\"Earpiece Amp Switch\", MC13783_AUDIO_RX0, 3, 1, 0),\n\tSOC_DOUBLE(\"Headset Amp Switch\", MC13783_AUDIO_RX0, 10, 9, 1, 0),\n\tSOC_DOUBLE(\"Line out Amp Switch\", MC13783_AUDIO_RX0, 16, 15, 1, 0),\n\n\tSOC_SINGLE(\"PCM Capture Mixin Switch\", MC13783_AUDIO_RX0, 22, 1, 0),\n\tSOC_SINGLE(\"Line in Capture Mixin Switch\", MC13783_AUDIO_RX0, 23, 1, 0),\n\n\tSOC_SINGLE(\"CODEC Capture Volume\", MC13783_AUDIO_RX1, 1, 15, 0),\n\tSOC_SINGLE(\"CODEC Capture Mixin Switch\", MC13783_AUDIO_RX0, 21, 1, 0),\n\n\tSOC_SINGLE(\"Line in Capture Volume\", MC13783_AUDIO_RX1, 12, 15, 0),\n\tSOC_SINGLE(\"Line in Capture Switch\", MC13783_AUDIO_RX1, 10, 1, 0),\n\n\tSOC_SINGLE(\"MC1 Capture Bias Switch\", MC13783_AUDIO_TX, 0, 1, 0),\n\tSOC_SINGLE(\"MC2 Capture Bias Switch\", MC13783_AUDIO_TX, 1, 1, 0),\n};\n\nstatic int mc13783_probe(struct snd_soc_component *component)\n{\n\tstruct mc13783_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_init_regmap(component,\n\t\t\t\t  dev_get_regmap(component->dev->parent, NULL));\n\n\t \n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_RX0, 0x25893);\n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_RX1, 0x00d35A);\n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_TX, 0x420000);\n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_SSI_NETWORK, 0x013060);\n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_CODEC, 0x180027);\n\tmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_DAC, 0x0e0004);\n\n\tif (priv->adc_ssi_port == MC13783_SSI1_PORT)\n\t\tmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,\n\t\t\t\tAUDIO_SSI_SEL, 0);\n\telse\n\t\tmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,\n\t\t\t\tAUDIO_SSI_SEL, AUDIO_SSI_SEL);\n\n\tif (priv->dac_ssi_port == MC13783_SSI1_PORT)\n\t\tmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,\n\t\t\t\tAUDIO_SSI_SEL, 0);\n\telse\n\t\tmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,\n\t\t\t\tAUDIO_SSI_SEL, AUDIO_SSI_SEL);\n\n\treturn 0;\n}\n\nstatic void mc13783_remove(struct snd_soc_component *component)\n{\n\tstruct mc13783_priv *priv = snd_soc_component_get_drvdata(component);\n\n\t \n\tmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_RX0, 0x3, 0);\n}\n\n#define MC13783_RATES_RECORD (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000)\n\n#define MC13783_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops mc13783_ops_dac = {\n\t.hw_params\t= mc13783_pcm_hw_params_dac,\n\t.set_fmt\t= mc13783_set_fmt_async,\n\t.set_sysclk\t= mc13783_set_sysclk_dac,\n\t.set_tdm_slot\t= mc13783_set_tdm_slot_dac,\n};\n\nstatic const struct snd_soc_dai_ops mc13783_ops_codec = {\n\t.hw_params\t= mc13783_pcm_hw_params_codec,\n\t.set_fmt\t= mc13783_set_fmt_async,\n\t.set_sysclk\t= mc13783_set_sysclk_codec,\n\t.set_tdm_slot\t= mc13783_set_tdm_slot_codec,\n};\n\n \nstatic struct snd_soc_dai_driver mc13783_dai_async[] = {\n\t{\n\t\t.name = \"mc13783-hifi-playback\",\n\t\t.id = MC13783_ID_STEREO_DAC,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = MC13783_FORMATS,\n\t\t},\n\t\t.ops = &mc13783_ops_dac,\n\t}, {\n\t\t.name = \"mc13783-hifi-capture\",\n\t\t.id = MC13783_ID_STEREO_CODEC,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MC13783_RATES_RECORD,\n\t\t\t.formats = MC13783_FORMATS,\n\t\t},\n\t\t.ops = &mc13783_ops_codec,\n\t},\n};\n\nstatic const struct snd_soc_dai_ops mc13783_ops_sync = {\n\t.hw_params\t= mc13783_pcm_hw_params_sync,\n\t.set_fmt\t= mc13783_set_fmt_sync,\n\t.set_sysclk\t= mc13783_set_sysclk_sync,\n\t.set_tdm_slot\t= mc13783_set_tdm_slot_sync,\n};\n\nstatic struct snd_soc_dai_driver mc13783_dai_sync[] = {\n\t{\n\t\t.name = \"mc13783-hifi\",\n\t\t.id = MC13783_ID_SYNC,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t\t.formats = MC13783_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MC13783_RATES_RECORD,\n\t\t\t.formats = MC13783_FORMATS,\n\t\t},\n\t\t.ops = &mc13783_ops_sync,\n\t\t.symmetric_rate = 1,\n\t}\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_mc13783 = {\n\t.probe\t\t\t= mc13783_probe,\n\t.remove\t\t\t= mc13783_remove,\n\t.controls\t\t= mc13783_control_list,\n\t.num_controls\t\t= ARRAY_SIZE(mc13783_control_list),\n\t.dapm_widgets\t\t= mc13783_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(mc13783_dapm_widgets),\n\t.dapm_routes\t\t= mc13783_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(mc13783_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int __init mc13783_codec_probe(struct platform_device *pdev)\n{\n\tstruct mc13783_priv *priv;\n\tstruct mc13xxx_codec_platform_data *pdata = pdev->dev.platform_data;\n\tstruct device_node *np;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (pdata) {\n\t\tpriv->adc_ssi_port = pdata->adc_ssi_port;\n\t\tpriv->dac_ssi_port = pdata->dac_ssi_port;\n\t} else {\n\t\tnp = of_get_child_by_name(pdev->dev.parent->of_node, \"codec\");\n\t\tif (!np)\n\t\t\treturn -ENOSYS;\n\n\t\tret = of_property_read_u32(np, \"adc-port\", &priv->adc_ssi_port);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = of_property_read_u32(np, \"dac-port\", &priv->dac_ssi_port);\n\t\tif (ret) {\n\t\t\tof_node_put(np);\n\t\t\treturn ret;\n\t\t}\n\n\t\tof_node_put(np);\n\t}\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\tpriv->mc13xxx = dev_get_drvdata(pdev->dev.parent);\n\n\tif (priv->adc_ssi_port == priv->dac_ssi_port)\n\t\tret = devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_mc13783,\n\t\t\tmc13783_dai_sync, ARRAY_SIZE(mc13783_dai_sync));\n\telse\n\t\tret = devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_mc13783,\n\t\t\tmc13783_dai_async, ARRAY_SIZE(mc13783_dai_async));\n\n\treturn ret;\n}\n\nstatic struct platform_driver mc13783_codec_driver = {\n\t.driver = {\n\t\t.name\t= \"mc13783-codec\",\n\t},\n};\nmodule_platform_driver_probe(mc13783_codec_driver, mc13783_codec_probe);\n\nMODULE_DESCRIPTION(\"ASoC MC13783 driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix <s.hauer@pengutronix.de>\");\nMODULE_AUTHOR(\"Philippe Retornaz <philippe.retornaz@epfl.ch>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}