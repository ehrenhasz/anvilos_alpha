{
  "module_name": "rt1316-sdw.c",
  "hash_id": "8946b8d5d8ebbc40c2c94effd923907bcfb5189cea310360a994679814f9959a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1316-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include \"rt1316-sdw.h\"\n\nstatic const struct reg_default rt1316_reg_defaults[] = {\n\t{ 0x3004, 0x00 },\n\t{ 0x3005, 0x00 },\n\t{ 0x3206, 0x00 },\n\t{ 0xc001, 0x00 },\n\t{ 0xc002, 0x00 },\n\t{ 0xc003, 0x00 },\n\t{ 0xc004, 0x00 },\n\t{ 0xc005, 0x00 },\n\t{ 0xc006, 0x00 },\n\t{ 0xc007, 0x00 },\n\t{ 0xc008, 0x00 },\n\t{ 0xc009, 0x00 },\n\t{ 0xc00a, 0x00 },\n\t{ 0xc00b, 0x00 },\n\t{ 0xc00c, 0x00 },\n\t{ 0xc00d, 0x00 },\n\t{ 0xc00e, 0x00 },\n\t{ 0xc00f, 0x00 },\n\t{ 0xc010, 0xa5 },\n\t{ 0xc011, 0x00 },\n\t{ 0xc012, 0xff },\n\t{ 0xc013, 0xff },\n\t{ 0xc014, 0x40 },\n\t{ 0xc015, 0x00 },\n\t{ 0xc016, 0x00 },\n\t{ 0xc017, 0x00 },\n\t{ 0xc605, 0x30 },\n\t{ 0xc700, 0x0a },\n\t{ 0xc701, 0xaa },\n\t{ 0xc702, 0x1a },\n\t{ 0xc703, 0x0a },\n\t{ 0xc710, 0x80 },\n\t{ 0xc711, 0x00 },\n\t{ 0xc712, 0x3e },\n\t{ 0xc713, 0x80 },\n\t{ 0xc714, 0x80 },\n\t{ 0xc715, 0x06 },\n\t{ 0xd101, 0x00 },\n\t{ 0xd102, 0x30 },\n\t{ 0xd103, 0x00 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_UDMPU21, RT1316_SDCA_CTL_UDMPU_CLUSTER, 0), 0x00 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_L), 0x01 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_R), 0x01 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_XU24, RT1316_SDCA_CTL_BYPASS, 0), 0x01 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE23, RT1316_SDCA_CTL_REQ_POWER_STATE, 0), 0x03 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE22, RT1316_SDCA_CTL_REQ_POWER_STATE, 0), 0x03 },\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE24, RT1316_SDCA_CTL_REQ_POWER_STATE, 0), 0x03 },\n};\n\nstatic const struct reg_sequence rt1316_blind_write[] = {\n\t{ 0xc710, 0x17 },\n\t{ 0xc711, 0x80 },\n\t{ 0xc712, 0x26 },\n\t{ 0xc713, 0x06 },\n\t{ 0xc714, 0x80 },\n\t{ 0xc715, 0x06 },\n\t{ 0xc702, 0x0a },\n\t{ 0xc703, 0x0a },\n\t{ 0xc001, 0x45 },\n\t{ 0xc003, 0x00 },\n\t{ 0xc004, 0x11 },\n\t{ 0xc005, 0x00 },\n\t{ 0xc006, 0x00 },\n\t{ 0xc106, 0x00 },\n\t{ 0xc007, 0x11 },\n\t{ 0xc008, 0x11 },\n\t{ 0xc009, 0x00 },\n\n\t{ 0x2f0a, 0x00 },\n\t{ 0xd101, 0xf0 },\n\t{ 0xd103, 0x9b },\n\t{ 0x2f36, 0x8e },\n\t{ 0x3206, 0x80 },\n\t{ 0x3211, 0x0b },\n\t{ 0x3216, 0x06 },\n\t{ 0xc614, 0x20 },\n\t{ 0xc615, 0x0a },\n\t{ 0xc616, 0x02 },\n\t{ 0xc617, 0x00 },\n\t{ 0xc60b, 0x10 },\n\t{ 0xc60e, 0x05 },\n\t{ 0xc102, 0x00 },\n\t{ 0xc090, 0xb0 },\n\t{ 0xc00f, 0x01 },\n\t{ 0xc09c, 0x7b },\n\n\t{ 0xc602, 0x07 },\n\t{ 0xc603, 0x07 },\n\t{ 0xc0a3, 0x71 },\n\t{ 0xc00b, 0x30 },\n\t{ 0xc093, 0x80 },\n\t{ 0xc09d, 0x80 },\n\t{ 0xc0b0, 0x77 },\n\t{ 0xc010, 0xa5 },\n\t{ 0xc050, 0x83 },\n\t{ 0x2f55, 0x03 },\n\t{ 0x3217, 0xb5 },\n\t{ 0x3202, 0x02 },\n\n\t{ SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_XU24, RT1316_SDCA_CTL_BYPASS, 0), 0x00 },\n\n\t \n\t{ 0x2232, 0x80 },\n\t{ 0xc0b0, 0x77 },\n\t{ 0xc011, 0x00 },\n\t{ 0xc020, 0x00 },\n\t{ 0xc023, 0x00 },\n\t{ 0x3101, 0x00 },\n\t{ 0x3004, 0xa0 },\n\t{ 0x3005, 0xb1 },\n\t{ 0xc007, 0x11 },\n\t{ 0xc008, 0x11 },\n\t{ 0xc009, 0x00 },\n\t{ 0xc022, 0xd6 },\n\t{ 0xc025, 0xd6 },\n\n\t{ 0xd001, 0x03 },\n\t{ 0xd002, 0xbf },\n\t{ 0xd003, 0x03 },\n\t{ 0xd004, 0xbf },\n};\n\nstatic bool rt1316_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f0a:\n\tcase 0x2f36:\n\tcase 0x3203 ... 0x320e:\n\tcase 0xc000 ... 0xc7b4:\n\tcase 0xcf00 ... 0xcf03:\n\tcase 0xd101 ... 0xd103:\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_UDMPU21, RT1316_SDCA_CTL_UDMPU_CLUSTER, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_R):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE23, RT1316_SDCA_CTL_REQ_POWER_STATE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE27, RT1316_SDCA_CTL_REQ_POWER_STATE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE22, RT1316_SDCA_CTL_REQ_POWER_STATE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE24, RT1316_SDCA_CTL_REQ_POWER_STATE, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1316_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0xc000:\n\tcase 0xc093:\n\tcase 0xc09d:\n\tcase 0xc0a3:\n\tcase 0xc201:\n\tcase 0xc427 ... 0xc428:\n\tcase 0xd102:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt1316_sdw_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt1316_readable_register,\n\t.volatile_reg = rt1316_volatile_register,\n\t.max_register = 0x4108ffff,\n\t.reg_defaults = rt1316_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt1316_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt1316_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval;\n\tint i, j;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = 0x04;  \n\tprop->sink_ports = 0x2;  \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->src_dpn_prop), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->sink_dpn_prop), GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[j].num = bit;\n\t\tdpn[j].type = SDW_DPN_FULL;\n\t\tdpn[j].simple_ch_prep_sm = true;\n\t\tdpn[j].ch_prep_timeout = 10;\n\t\tj++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 20;\n\n\tdev_dbg(&slave->dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic void rt1316_apply_bq_params(struct rt1316_sdw_priv *rt1316)\n{\n\tunsigned int i, reg, data;\n\n\tfor (i = 0; i < rt1316->bq_params_cnt; i += 3) {\n\t\treg = rt1316->bq_params[i] | (rt1316->bq_params[i + 1] << 8);\n\t\tdata = rt1316->bq_params[i + 2];\n\t\tregmap_write(rt1316->regmap, reg, data);\n\t}\n}\n\nstatic int rt1316_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt1316_sdw_priv *rt1316 = dev_get_drvdata(dev);\n\n\tif (rt1316->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt1316->regmap, false);\n\tif (rt1316->first_hw_init) {\n\t\tregcache_cache_bypass(rt1316->regmap, true);\n\t} else {\n\t\t \n\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\t \n\tregmap_write(rt1316->regmap, 0xc000, 0x02);\n\n\t \n\tregmap_multi_reg_write(rt1316->regmap, rt1316_blind_write,\n\t\tARRAY_SIZE(rt1316_blind_write));\n\n\tif (rt1316->first_hw_init) {\n\t\tregcache_cache_bypass(rt1316->regmap, false);\n\t\tregcache_mark_dirty(rt1316->regmap);\n\t} else\n\t\trt1316->first_hw_init = true;\n\n\t \n\trt1316->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete\\n\", __func__);\n\treturn 0;\n}\n\nstatic int rt1316_update_status(struct sdw_slave *slave,\n\t\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct  rt1316_sdw_priv *rt1316 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt1316->hw_init = false;\n\n\t \n\tif (rt1316->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt1316_io_init(&slave->dev, slave);\n}\n\nstatic int rt1316_classd_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt1316_sdw_priv *rt1316 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE23,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE27,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE22,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE23,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE27,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE22,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt1316_pde24_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt1316_sdw_priv *rt1316 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE24,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt1316->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_PDE24,\n\t\t\t\tRT1316_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const char * const rt1316_rx_data_ch_select[] = {\n\t\"L,R\",\n\t\"L,L\",\n\t\"L,R\",\n\t\"L,L+R\",\n\t\"R,L\",\n\t\"R,R\",\n\t\"R,L+R\",\n\t\"L+R,L\",\n\t\"L+R,R\",\n\t\"L+R,L+R\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1316_rx_data_ch_enum,\n\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_UDMPU21, RT1316_SDCA_CTL_UDMPU_CLUSTER, 0), 0,\n\trt1316_rx_data_ch_select);\n\nstatic const char * const rt1316_dac_output_vol_select[] = {\n\t\"immediately\",\n\t\"zero crossing\",\n\t\"zero crossing with soft ramp\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1316_dac_vol_ctl_enum,\n\t0xc010, 6, rt1316_dac_output_vol_select);\n\nstatic const struct snd_kcontrol_new rt1316_snd_controls[] = {\n\n\t \n\tSOC_ENUM(\"RX Channel Select\", rt1316_rx_data_ch_enum),\n\n\t \n\tSOC_SINGLE(\"XU24 Bypass Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_XU24, RT1316_SDCA_CTL_BYPASS, 0), 0, 1, 0),\n\n\t \n\tSOC_SINGLE(\"Left V Tag Select\", 0x3004, 0, 7, 0),\n\tSOC_SINGLE(\"Left I Tag Select\", 0x3004, 4, 7, 0),\n\tSOC_SINGLE(\"Right V Tag Select\", 0x3005, 0, 7, 0),\n\tSOC_SINGLE(\"Right I Tag Select\", 0x3005, 4, 7, 0),\n\n\t \n\tSOC_DOUBLE(\"Isense Mixer Switch\", 0xc605, 2, 0, 1, 1),\n\tSOC_DOUBLE(\"Vsense Mixer Switch\", 0xc605, 3, 1, 1, 1),\n\n\t \n\tSOC_ENUM(\"DAC Output Vol Control\", rt1316_dac_vol_ctl_enum),\n};\n\nstatic const struct snd_kcontrol_new rt1316_sto_dac =\n\tSOC_DAPM_DOUBLE_R(\"Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1316_SDCA_ENT_FU21, RT1316_SDCA_CTL_FU_MUTE, CH_R),\n\t\t0, 1, 1);\n\nstatic const struct snd_soc_dapm_widget rt1316_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"DP1RX\", \"DP1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP2TX\", \"DP2 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"DAC\", SND_SOC_NOPM, 0, 0, &rt1316_sto_dac),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"CLASS D\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt1316_classd_event,\n\t\tSND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOR\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PDE 24\", SND_SOC_NOPM, 0, 0,\n\t\trt1316_pde24_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA(\"I Sense\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"V Sense\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SIGGEN(\"I Gen\"),\n\tSND_SOC_DAPM_SIGGEN(\"V Gen\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1316_dapm_routes[] = {\n\t{ \"DAC\", \"Switch\", \"DP1RX\" },\n\t{ \"CLASS D\", NULL, \"DAC\" },\n\t{ \"SPOL\", NULL, \"CLASS D\" },\n\t{ \"SPOR\", NULL, \"CLASS D\" },\n\n\t{ \"I Sense\", NULL, \"I Gen\" },\n\t{ \"V Sense\", NULL, \"V Gen\" },\n\t{ \"I Sense\", NULL, \"PDE 24\" },\n\t{ \"V Sense\", NULL, \"PDE 24\" },\n\t{ \"DP2TX\", NULL, \"I Sense\" },\n\t{ \"DP2TX\", NULL, \"V Sense\" },\n};\n\nstatic int rt1316_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt1316_sdw_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt1316_sdw_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1316_sdw_priv *rt1316 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt1316->sdw_slave)\n\t\treturn -EINVAL;\n\n\t \n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tport_config.num = 1;\n\telse\n\t\tport_config.num = 2;\n\n\tretval = sdw_stream_add_slave(rt1316->sdw_slave, &stream_config,\n\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt1316_sdw_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1316_sdw_priv *rt1316 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt1316->sdw_slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt1316->sdw_slave, sdw_stream);\n\treturn 0;\n}\n\n \nstatic const struct sdw_slave_ops rt1316_slave_ops = {\n\t.read_prop = rt1316_read_prop,\n\t.update_status = rt1316_update_status,\n};\n\nstatic int rt1316_sdw_parse_dt(struct rt1316_sdw_priv *rt1316, struct device *dev)\n{\n\tint ret = 0;\n\n\tdevice_property_read_u32(dev, \"realtek,bq-params-cnt\", &rt1316->bq_params_cnt);\n\tif (rt1316->bq_params_cnt) {\n\t\trt1316->bq_params = devm_kzalloc(dev, rt1316->bq_params_cnt, GFP_KERNEL);\n\t\tif (!rt1316->bq_params) {\n\t\t\tdev_err(dev, \"Could not allocate bq_params memory\\n\");\n\t\t\tret = -ENOMEM;\n\t\t} else {\n\t\t\tret = device_property_read_u8_array(dev, \"realtek,bq-params\", rt1316->bq_params, rt1316->bq_params_cnt);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(dev, \"Could not read list of realtek,bq-params\\n\");\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"bq_params_cnt=%d\\n\", rt1316->bq_params_cnt);\n\treturn ret;\n}\n\nstatic int rt1316_sdw_component_probe(struct snd_soc_component *component)\n{\n\tstruct rt1316_sdw_priv *rt1316 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt1316->component = component;\n\trt1316_sdw_parse_dt(rt1316, &rt1316->sdw_slave->dev);\n\n\tif (!rt1316->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\t \n\trt1316_apply_bq_params(rt1316);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_sdw_rt1316 = {\n\t.probe = rt1316_sdw_component_probe,\n\t.controls = rt1316_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1316_snd_controls),\n\t.dapm_widgets = rt1316_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1316_dapm_widgets),\n\t.dapm_routes = rt1316_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1316_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic const struct snd_soc_dai_ops rt1316_aif_dai_ops = {\n\t.hw_params = rt1316_sdw_hw_params,\n\t.hw_free\t= rt1316_sdw_pcm_hw_free,\n\t.set_stream\t= rt1316_set_sdw_stream,\n\t.shutdown\t= rt1316_sdw_shutdown,\n};\n\n#define RT1316_STEREO_RATES SNDRV_PCM_RATE_48000\n#define RT1316_FORMATS (SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver rt1316_sdw_dai[] = {\n\t{\n\t\t.name = \"rt1316-aif\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1316_STEREO_RATES,\n\t\t\t.formats = RT1316_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1316_STEREO_RATES,\n\t\t\t.formats = RT1316_FORMATS,\n\t\t},\n\t\t.ops = &rt1316_aif_dai_ops,\n\t},\n};\n\nstatic int rt1316_sdw_init(struct device *dev, struct regmap *regmap,\n\t\t\t\tstruct sdw_slave *slave)\n{\n\tstruct rt1316_sdw_priv *rt1316;\n\tint ret;\n\n\trt1316 = devm_kzalloc(dev, sizeof(*rt1316), GFP_KERNEL);\n\tif (!rt1316)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt1316);\n\trt1316->sdw_slave = slave;\n\trt1316->regmap = regmap;\n\n\tregcache_cache_only(rt1316->regmap, true);\n\n\t \n\trt1316->hw_init = false;\n\trt1316->first_hw_init = false;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t\t&soc_component_sdw_rt1316,\n\t\t\t\trt1316_sdw_dai,\n\t\t\t\tARRAY_SIZE(rt1316_sdw_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int rt1316_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &rt1316_sdw_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt1316_sdw_init(&slave->dev, regmap, slave);\n}\n\nstatic int rt1316_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt1316_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1316, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt1316_id);\n\nstatic int __maybe_unused rt1316_dev_suspend(struct device *dev)\n{\n\tstruct rt1316_sdw_priv *rt1316 = dev_get_drvdata(dev);\n\n\tif (!rt1316->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt1316->regmap, true);\n\n\treturn 0;\n}\n\n#define RT1316_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt1316_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt1316_sdw_priv *rt1316 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt1316->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT1316_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt1316->regmap, false);\n\tregcache_sync(rt1316->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt1316_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt1316_dev_suspend, rt1316_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt1316_dev_suspend, rt1316_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt1316_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt1316-sdca\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt1316_pm,\n\t},\n\t.probe = rt1316_sdw_probe,\n\t.remove = rt1316_sdw_remove,\n\t.ops = &rt1316_slave_ops,\n\t.id_table = rt1316_id,\n};\nmodule_sdw_driver(rt1316_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1316 driver SDCA SDW\");\nMODULE_AUTHOR(\"Shuming Fan <shumingf@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}