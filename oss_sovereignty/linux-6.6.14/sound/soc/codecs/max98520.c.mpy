{
  "module_name": "max98520.c",
  "hash_id": "92dd0fe8cd27e3326f8fe06f46eb6930a89f92a0efb97deb46fab62a94c233fb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98520.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <sound/tlv.h>\n#include \"max98520.h\"\n\nstatic struct reg_default max98520_reg[] = {\n\t{MAX98520_R2000_SW_RESET, 0x00},\n\t{MAX98520_R2001_STATUS_1, 0x00},\n\t{MAX98520_R2002_STATUS_2, 0x00},\n\t{MAX98520_R2020_THERM_WARN_THRESH, 0x46},\n\t{MAX98520_R2021_THERM_SHDN_THRESH, 0x64},\n\t{MAX98520_R2022_THERM_HYSTERESIS, 0x02},\n\t{MAX98520_R2023_THERM_FOLDBACK_SET, 0x31},\n\t{MAX98520_R2027_THERM_FOLDBACK_EN, 0x01},\n\t{MAX98520_R2030_CLK_MON_CTRL, 0x00},\n\t{MAX98520_R2037_ERR_MON_CTRL, 0x01},\n\t{MAX98520_R2040_PCM_MODE_CFG, 0xC0},\n\t{MAX98520_R2041_PCM_CLK_SETUP, 0x04},\n\t{MAX98520_R2042_PCM_SR_SETUP, 0x08},\n\t{MAX98520_R2043_PCM_RX_SRC1, 0x00},\n\t{MAX98520_R2044_PCM_RX_SRC2, 0x00},\n\t{MAX98520_R204F_PCM_RX_EN, 0x00},\n\t{MAX98520_R2090_AMP_VOL_CTRL, 0x00},\n\t{MAX98520_R2091_AMP_PATH_GAIN, 0x03},\n\t{MAX98520_R2092_AMP_DSP_CFG, 0x02},\n\t{MAX98520_R2094_SSM_CFG, 0x01},\n\t{MAX98520_R2095_AMP_CFG, 0xF0},\n\t{MAX98520_R209F_AMP_EN, 0x00},\n\t{MAX98520_R20B0_ADC_SR, 0x00},\n\t{MAX98520_R20B1_ADC_RESOLUTION, 0x00},\n\t{MAX98520_R20B2_ADC_PVDD0_CFG, 0x02},\n\t{MAX98520_R20B3_ADC_THERMAL_CFG, 0x02},\n\t{MAX98520_R20B4_ADC_READBACK_CTRL, 0x00},\n\t{MAX98520_R20B5_ADC_READBACK_UPDATE, 0x00},\n\t{MAX98520_R20B6_ADC_PVDD_READBACK_MSB, 0x00},\n\t{MAX98520_R20B7_ADC_PVDD_READBACK_LSB, 0x00},\n\t{MAX98520_R20B8_ADC_TEMP_READBACK_MSB, 0x00},\n\t{MAX98520_R20B9_ADC_TEMP_READBACK_LSB, 0x00},\n\t{MAX98520_R20BA_ADC_LOW_PVDD_READBACK_MSB, 0xFF},\n\t{MAX98520_R20BB_ADC_LOW_READBACK_LSB, 0x01},\n\t{MAX98520_R20BC_ADC_HIGH_TEMP_READBACK_MSB, 0x00},\n\t{MAX98520_R20BD_ADC_HIGH_TEMP_READBACK_LSB, 0x00},\n\t{MAX98520_R20CF_MEAS_ADC_CFG, 0x00},\n\t{MAX98520_R20D0_DHT_CFG1, 0x00},\n\t{MAX98520_R20D1_LIMITER_CFG1, 0x08},\n\t{MAX98520_R20D2_LIMITER_CFG2, 0x00},\n\t{MAX98520_R20D3_DHT_CFG2, 0x14},\n\t{MAX98520_R20D4_DHT_CFG3, 0x02},\n\t{MAX98520_R20D5_DHT_CFG4, 0x04},\n\t{MAX98520_R20D6_DHT_HYSTERESIS_CFG, 0x07},\n\t{MAX98520_R20D8_DHT_EN, 0x00},\n\t{MAX98520_R210E_AUTO_RESTART_BEHAVIOR, 0x00},\n\t{MAX98520_R210F_GLOBAL_EN, 0x00},\n\t{MAX98520_R21FF_REVISION_ID, 0x00},\n};\n\nstatic int max98520_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tunsigned int format = 0;\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98520_PCM_MODE_CFG_PCM_BCLKEDGE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2041_PCM_CLK_SETUP,\n\t\t\t   MAX98520_PCM_MODE_CFG_PCM_BCLKEDGE,\n\t\t\t   invert);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = MAX98520_PCM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = MAX98520_PCM_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = MAX98520_PCM_FORMAT_TDM_MODE1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = MAX98520_PCM_FORMAT_TDM_MODE0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2040_PCM_MODE_CFG,\n\t\t\t   MAX98520_PCM_MODE_CFG_FORMAT_MASK,\n\t\t\t   format << MAX98520_PCM_MODE_CFG_FORMAT_SHIFT);\n\n\treturn 0;\n}\n\n \nstatic const int bclk_sel_table[] = {\n\t32, 48, 64, 96, 128, 192, 256, 384, 512, 320,\n};\n\nstatic int max98520_get_bclk_sel(int bclk)\n{\n\tint i;\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bclk_sel_table); i++) {\n\t\tif (bclk_sel_table[i] == bclk)\n\t\t\treturn i + 2;\n\t}\n\treturn 0;\n}\n\nstatic int max98520_set_clock(struct snd_soc_component *component,\n\t\t\t      struct snd_pcm_hw_params *params)\n{\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\t \n\tint blr_clk_ratio = params_channels(params) * max98520->ch_size;\n\tint value;\n\n\tif (!max98520->tdm_mode) {\n\t\t \n\t\tvalue = max98520_get_bclk_sel(blr_clk_ratio);\n\t\tif (!value) {\n\t\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98520->regmap,\n\t\t\t\t   MAX98520_R2041_PCM_CLK_SETUP,\n\t\t\t\t   MAX98520_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t\t   value);\n\t}\n\tdev_dbg(component->dev, \"%s tdm_mode:%d out\\n\", __func__, max98520->tdm_mode);\n\treturn 0;\n}\n\nstatic int max98520_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tunsigned int sampling_rate = 0;\n\tunsigned int chan_sz = 0;\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\tgoto err;\n\t}\n\n\tmax98520->ch_size = snd_pcm_format_width(params_format(params));\n\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2040_PCM_MODE_CFG,\n\t\t\t   MAX98520_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\tdev_dbg(component->dev, \"format supported %d\",\n\t\tparams_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98520_PCM_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98520_PCM_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98520_PCM_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98520_PCM_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98520_PCM_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98520_PCM_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98520_PCM_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98520_PCM_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98520_PCM_SR_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tsampling_rate = MAX98520_PCM_SR_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = MAX98520_PCM_SR_96000;\n\t\tbreak;\n\tcase 176400:\n\t\tsampling_rate = MAX98520_PCM_SR_176400;\n\t\tbreak;\n\tcase 192000:\n\t\tsampling_rate = MAX98520_PCM_SR_192000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"rate %d not supported\\n\",\n\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\n\tdev_dbg(component->dev, \" %s ch_size: %d, sampling rate : %d out\\n\", __func__,\n\t\tsnd_pcm_format_width(params_format(params)), params_rate(params));\n\t \n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2042_PCM_SR_SETUP,\n\t\t\t   MAX98520_PCM_SR_MASK,\n\t\t\t   sampling_rate);\n\n\treturn max98520_set_clock(component, params);\nerr:\n\tdev_dbg(component->dev, \"%s out error\", __func__);\n\treturn -EINVAL;\n}\n\nstatic int max98520_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tint bsel;\n\tunsigned int chan_sz = 0;\n\n\tif (!tx_mask && !rx_mask && !slots && !slot_width)\n\t\tmax98520->tdm_mode = false;\n\telse\n\t\tmax98520->tdm_mode = true;\n\n\t \n\tbsel = max98520_get_bclk_sel(slots * slot_width);\n\tif (bsel == 0) {\n\t\tdev_err(component->dev, \"BCLK %d not supported\\n\",\n\t\t\tslots * slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2041_PCM_CLK_SETUP,\n\t\t\t   MAX98520_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\t   bsel);\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98520_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2040_PCM_MODE_CFG,\n\t\t\t   MAX98520_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\t \n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2044_PCM_RX_SRC2,\n\t\t\t   MAX98520_PCM_DMIX_CH0_SRC_MASK,\n\t\t\t   rx_mask);\n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R2044_PCM_RX_SRC2,\n\t\t\t   MAX98520_PCM_DMIX_CH1_SRC_MASK,\n\t\t\t   rx_mask << MAX98520_PCM_DMIX_CH1_SHIFT);\n\n\treturn 0;\n}\n\n#define MAX98520_RATES SNDRV_PCM_RATE_8000_192000\n\n#define MAX98520_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops max98520_dai_ops = {\n\t.set_fmt = max98520_dai_set_fmt,\n\t.hw_params = max98520_dai_hw_params,\n\t.set_tdm_slot = max98520_dai_tdm_slot,\n};\n\nstatic int max98520_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tdev_dbg(component->dev, \" AMP ON\\n\");\n\n\t\tregmap_write(max98520->regmap, MAX98520_R209F_AMP_EN, 1);\n\t\tregmap_write(max98520->regmap, MAX98520_R210F_GLOBAL_EN, 1);\n\t\tusleep_range(30000, 31000);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdev_dbg(component->dev, \" AMP OFF\\n\");\n\n\t\tregmap_write(max98520->regmap, MAX98520_R210F_GLOBAL_EN, 0);\n\t\tregmap_write(max98520->regmap, MAX98520_R209F_AMP_EN, 0);\n\t\tusleep_range(30000, 31000);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic const char * const max98520_switch_text[] = {\n\t\"Left\", \"Right\", \"LeftRight\"};\n\nstatic const struct soc_enum dai_sel_enum =\n\tSOC_ENUM_SINGLE(MAX98520_R2043_PCM_RX_SRC1,\n\t\t\t0, 3, max98520_switch_text);\n\nstatic const struct snd_kcontrol_new max98520_dai_controls =\n\tSOC_DAPM_ENUM(\"DAI Sel\", dai_sel_enum);\n\nstatic const struct snd_kcontrol_new max98520_left_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH0\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x0, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH1\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x1, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH2\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x2, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH3\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x3, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH4\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x4, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH5\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x5, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH6\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x6, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH7\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x7, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH8\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x8, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH9\", MAX98520_R2044_PCM_RX_SRC2, 0, 0x9, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH10\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xa, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH11\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xb, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH12\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xc, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH13\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xd, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH14\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xe, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH15\", MAX98520_R2044_PCM_RX_SRC2, 0, 0xf, 0),\n};\n\nstatic const struct snd_kcontrol_new max98520_right_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH0\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x0, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH1\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x1, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH2\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x2, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH3\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x3, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH4\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x4, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH5\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x5, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH6\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x6, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH7\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x7, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH8\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x8, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH9\", MAX98520_R2044_PCM_RX_SRC2, 4, 0x9, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH10\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xa, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH11\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xb, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH12\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xc, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH13\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xd, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH14\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xe, 0),\n\tSOC_DAPM_SINGLE(\"PCM_INPUT_CH15\", MAX98520_R2044_PCM_RX_SRC2, 4, 0xf, 0),\n};\n\nstatic const struct snd_soc_dapm_widget max98520_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"Amp Enable\", \"HiFi Playback\",\n\t\t\t   SND_SOC_NOPM, 0, 0, max98520_dac_event,\n\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MUX(\"DAI Sel Mux\", SND_SOC_NOPM, 0, 0,\t&max98520_dai_controls),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n\t \n\tSND_SOC_DAPM_MIXER(\"Left Input Selection\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &max98520_left_input_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(max98520_left_input_mixer_controls)),\n\t \n\tSND_SOC_DAPM_MIXER(\"Right Input Selection\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &max98520_right_input_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(max98520_right_input_mixer_controls)),\n};\n\nstatic const DECLARE_TLV_DB_SCALE(max98520_digital_tlv, -6300, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(max98520_spk_tlv, -600, 300, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(max98520_dht_lim_thresh_tlv,\n\t0, 15, TLV_DB_SCALE_ITEM(-1500, 100, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98520_dht_hysteresis_tlv,\n\t0, 3, TLV_DB_SCALE_ITEM(100, 100, 0),\n\t4, 7, TLV_DB_SCALE_ITEM(600, 200, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98520_dht_rotation_point_tlv,\n\t0, 1, TLV_DB_SCALE_ITEM(-1500, 300, 0),\n\t2, 4, TLV_DB_SCALE_ITEM(-1000, 200, 0),\n\t5, 10, TLV_DB_SCALE_ITEM(-500, 100, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98520_dht_supply_hr_tlv,\n\t0, 16, TLV_DB_SCALE_ITEM(-2000, 250, 0),\n);\n\nstatic const DECLARE_TLV_DB_RANGE(max98520_dht_max_atten_tlv,\n\t1, 20, TLV_DB_SCALE_ITEM(-2000, 100, 0),\n);\n\nstatic const char * const max98520_dht_attack_rate_text[] = {\n\t\"20us\", \"40us\", \"80us\", \"160us\", \"320us\", \"640us\",\n\t\"1.28ms\", \"2.56ms\",\t\"5.12ms\", \"10.24ms\", \"20.48ms\", \"40.96ms\",\n\t\"81.92ms\", \"163.84ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98520_dht_attack_rate_enum,\n\t\t\t    MAX98520_R20D4_DHT_CFG3, 0,\n\t\t\t    max98520_dht_attack_rate_text);\n\nstatic const char * const max98520_dht_release_rate_text[] = {\n\t\"2ms\", \"4ms\", \"8ms\", \"16ms\", \"32ms\", \"64ms\", \"128ms\", \"256ms\", \"512ms\",\n\t\"1.024s\", \"2.048s\", \"4.096s\", \"8.192s\", \"16.384s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98520_dht_release_rate_enum,\n\t\t\t    MAX98520_R20D5_DHT_CFG4, 0,\n\t\t\t    max98520_dht_release_rate_text);\n\nstatic bool max98520_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98520_R2000_SW_RESET:\n\tcase MAX98520_R2027_THERM_FOLDBACK_EN:\n\tcase MAX98520_R2030_CLK_MON_CTRL:\n\tcase MAX98520_R2037_ERR_MON_CTRL:\n\tcase MAX98520_R204F_PCM_RX_EN:\n\tcase MAX98520_R209F_AMP_EN:\n\tcase MAX98520_R20CF_MEAS_ADC_CFG:\n\tcase MAX98520_R20D8_DHT_EN:\n\tcase MAX98520_R21FF_REVISION_ID:\n\tcase MAX98520_R2001_STATUS_1... MAX98520_R2002_STATUS_2:\n\tcase MAX98520_R2020_THERM_WARN_THRESH... MAX98520_R2023_THERM_FOLDBACK_SET:\n\tcase MAX98520_R2040_PCM_MODE_CFG... MAX98520_R2044_PCM_RX_SRC2:\n\tcase MAX98520_R2090_AMP_VOL_CTRL... MAX98520_R2092_AMP_DSP_CFG:\n\tcase MAX98520_R2094_SSM_CFG... MAX98520_R2095_AMP_CFG:\n\tcase MAX98520_R20B0_ADC_SR... MAX98520_R20BD_ADC_HIGH_TEMP_READBACK_LSB:\n\tcase MAX98520_R20D0_DHT_CFG1... MAX98520_R20D6_DHT_HYSTERESIS_CFG:\n\tcase MAX98520_R210E_AUTO_RESTART_BEHAVIOR... MAX98520_R210F_GLOBAL_EN:\n\tcase MAX98520_R2161_BOOST_TM1... MAX98520_R2163_BOOST_TM3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98520_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98520_R210F_GLOBAL_EN:\n\tcase MAX98520_R21FF_REVISION_ID:\n\tcase MAX98520_R2000_SW_RESET:\n\tcase MAX98520_R2001_STATUS_1 ... MAX98520_R2002_STATUS_2:\n\tcase MAX98520_R20B4_ADC_READBACK_CTRL\n\t\t... MAX98520_R20BD_ADC_HIGH_TEMP_READBACK_LSB:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct snd_kcontrol_new max98520_snd_controls[] = {\n \nSOC_SINGLE_TLV(\"Digital Volume\", MAX98520_R2090_AMP_VOL_CTRL,\n\t       0, 0x7F, 1, max98520_digital_tlv),\nSOC_SINGLE_TLV(\"Speaker Volume\", MAX98520_R2091_AMP_PATH_GAIN,\n\t       0, 0x5, 0, max98520_spk_tlv),\n \nSOC_SINGLE(\"Ramp Up Switch\", MAX98520_R2092_AMP_DSP_CFG,\n\t   MAX98520_DSP_SPK_VOL_RMPUP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ramp Down Switch\", MAX98520_R2092_AMP_DSP_CFG,\n\t   MAX98520_DSP_SPK_VOL_RMPDN_SHIFT, 1, 0),\n \nSOC_SINGLE(\"CLK Monitor Switch\", MAX98520_R2037_ERR_MON_CTRL,\n\t   MAX98520_CTRL_CMON_EN_SHIFT, 1, 0),\n \nSOC_SINGLE(\"CLKMON Autorestart Switch\", MAX98520_R2030_CLK_MON_CTRL,\n\t   MAX98520_CMON_AUTORESTART_SHIFT, 1, 0),\n \nSOC_SINGLE(\"Dither Switch\", MAX98520_R2092_AMP_DSP_CFG,\n\t   MAX98520_DSP_SPK_DITH_EN_SHIFT, 1, 0),\n \nSOC_SINGLE(\"DC Blocker Switch\", MAX98520_R2092_AMP_DSP_CFG,\n\t   MAX98520_DSP_SPK_DCBLK_EN_SHIFT, 1, 0),\n \nSOC_SINGLE(\"Speaker Safemode Switch\", MAX98520_R2092_AMP_DSP_CFG,\n\t   MAX98520_DSP_SPK_SAFE_EN_SHIFT, 1, 0),\n \nSOC_SINGLE(\"CP Bypass Switch\", MAX98520_R2094_SSM_CFG,\n\t   MAX98520_SSM_RCVR_MODE_SHIFT, 1, 0),\n \nSOC_SINGLE(\"DHT Switch\", MAX98520_R20D8_DHT_EN, 0, 1, 0),\nSOC_SINGLE(\"DHT Limiter Mode\", MAX98520_R20D2_LIMITER_CFG2,\n\t   MAX98520_DHT_LIMITER_MODE_SHIFT, 1, 0),\nSOC_SINGLE(\"DHT Hysteresis Switch\", MAX98520_R20D6_DHT_HYSTERESIS_CFG,\n\t   MAX98520_DHT_HYSTERESIS_SWITCH_SHIFT, 1, 0),\nSOC_SINGLE_TLV(\"DHT Rot Pnt\", MAX98520_R20D0_DHT_CFG1,\n\t       MAX98520_DHT_VROT_PNT_SHIFT, 10, 1, max98520_dht_rotation_point_tlv),\nSOC_SINGLE_TLV(\"DHT Supply Headroom\", MAX98520_R20D1_LIMITER_CFG1,\n\t       MAX98520_DHT_SUPPLY_HR_SHIFT, 16, 0, max98520_dht_supply_hr_tlv),\nSOC_SINGLE_TLV(\"DHT Limiter Threshold\", MAX98520_R20D2_LIMITER_CFG2,\n\t       MAX98520_DHT_LIMITER_THRESHOLD_SHIFT, 0xF, 1, max98520_dht_lim_thresh_tlv),\nSOC_SINGLE_TLV(\"DHT Max Attenuation\", MAX98520_R20D3_DHT_CFG2,\n\t       MAX98520_DHT_MAX_ATTEN_SHIFT, 20, 1, max98520_dht_max_atten_tlv),\nSOC_SINGLE_TLV(\"DHT Hysteresis\", MAX98520_R20D6_DHT_HYSTERESIS_CFG,\n\t       MAX98520_DHT_HYSTERESIS_SHIFT, 0x7, 0, max98520_dht_hysteresis_tlv),\nSOC_ENUM(\"DHT Attack Rate\", max98520_dht_attack_rate_enum),\nSOC_ENUM(\"DHT Release Rate\", max98520_dht_release_rate_enum),\n \nSOC_SINGLE(\"ADC PVDD CH Switch\", MAX98520_R20CF_MEAS_ADC_CFG, 0, 1, 0),\nSOC_SINGLE(\"ADC PVDD FLT Switch\", MAX98520_R20B2_ADC_PVDD0_CFG,\tMAX98520_FLT_EN_SHIFT, 1, 0),\nSOC_SINGLE(\"ADC TEMP FLT Switch\", MAX98520_R20B3_ADC_THERMAL_CFG, MAX98520_FLT_EN_SHIFT, 1, 0),\nSOC_SINGLE(\"ADC PVDD MSB\", MAX98520_R20B6_ADC_PVDD_READBACK_MSB, 0, 0xFF, 0),\nSOC_SINGLE(\"ADC PVDD LSB\", MAX98520_R20B7_ADC_PVDD_READBACK_LSB, 0, 0x01, 0),\nSOC_SINGLE(\"ADC TEMP MSB\", MAX98520_R20B8_ADC_TEMP_READBACK_MSB, 0, 0xFF, 0),\nSOC_SINGLE(\"ADC TEMP LSB\", MAX98520_R20B9_ADC_TEMP_READBACK_LSB, 0, 0x01, 0),\n};\n\nstatic const struct snd_soc_dapm_route max98520_audio_map[] = {\n\t \n\t{\"DAI Sel Mux\", \"Left\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"Right\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"LeftRight\", \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"DAI Sel Mux\"},\n};\n\nstatic struct snd_soc_dai_driver max98520_dai[] = {\n\t{\n\t\t.name = \"max98520-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98520_RATES,\n\t\t\t.formats = MAX98520_FORMATS,\n\t\t},\n\t\t.ops = &max98520_dai_ops,\n\t}\n\n};\n\nstatic int max98520_probe(struct snd_soc_component *component)\n{\n\tstruct max98520_priv *max98520 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\t \n\tregmap_write(max98520->regmap, MAX98520_R2000_SW_RESET, 1);\n\n\t \n\tregmap_write(max98520->regmap, MAX98520_R2043_PCM_RX_SRC1, 0x2);\n\n\t \n\t \n\tregmap_write(max98520->regmap, MAX98520_R2044_PCM_RX_SRC2, 0x10);\n\n\t \n\tregmap_update_bits(max98520->regmap, MAX98520_R2092_AMP_DSP_CFG, 1, 1);\n\t \n\tregmap_write(max98520->regmap, MAX98520_R2030_CLK_MON_CTRL, 0x1);\n\n\t \n\tregmap_update_bits(max98520->regmap,\n\t\t\t   MAX98520_R204F_PCM_RX_EN,\n\t\t\t   MAX98520_PCM_RX_EN_MASK,\n\t\t\t   1);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused max98520_suspend(struct device *dev)\n{\n\tstruct max98520_priv *max98520 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98520->regmap, true);\n\tregcache_mark_dirty(max98520->regmap);\n\treturn 0;\n}\n\nstatic int __maybe_unused max98520_resume(struct device *dev)\n{\n\tstruct max98520_priv *max98520 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98520->regmap, false);\n\tregmap_write(max98520->regmap, MAX98520_R2000_SW_RESET, 1);\n\tregcache_sync(max98520->regmap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops max98520_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max98520_suspend, max98520_resume)\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_max98520 = {\n\t.probe\t\t\t= max98520_probe,\n\t.controls\t\t= max98520_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98520_snd_controls),\n\t.dapm_widgets\t\t= max98520_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98520_dapm_widgets),\n\t.dapm_routes\t\t= max98520_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98520_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98520_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\t.max_register = MAX98520_R21FF_REVISION_ID,\n\t.reg_defaults  = max98520_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98520_reg),\n\t.readable_reg = max98520_readable_register,\n\t.volatile_reg = max98520_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic void max98520_power_on(struct max98520_priv *max98520, bool poweron)\n{\n\tif (max98520->reset_gpio)\n\t\tgpiod_set_value_cansleep(max98520->reset_gpio, !poweron);\n}\n\nstatic int max98520_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret;\n\tint reg = 0;\n\tstruct max98520_priv *max98520;\n\tstruct i2c_adapter *adapter = to_i2c_adapter(i2c->dev.parent);\n\n\tret = i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE | I2C_FUNC_SMBUS_BYTE_DATA);\n\tif (!ret) {\n\t\tdev_err(&i2c->dev, \"I2C check functionality failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmax98520 = devm_kzalloc(&i2c->dev, sizeof(*max98520), GFP_KERNEL);\n\n\tif (!max98520)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max98520);\n\n\t \n\tmax98520->regmap = devm_regmap_init_i2c(i2c, &max98520_regmap);\n\tif (IS_ERR(max98520->regmap)) {\n\t\tret = PTR_ERR(max98520->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmax98520->reset_gpio = devm_gpiod_get_optional(&i2c->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (max98520->reset_gpio) {\n\t\tif (IS_ERR(max98520->reset_gpio)) {\n\t\t\tret = PTR_ERR(max98520->reset_gpio);\n\t\t\tdev_err(&i2c->dev, \"Unable to request GPIO pin: %d.\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmax98520_power_on(max98520, 1);\n\t}\n\n\t \n\tret = regmap_read(max98520->regmap, MAX98520_R21FF_REVISION_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to read: 0x%02X\\n\", MAX98520_R21FF_REVISION_ID);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"MAX98520 revisionID: 0x%02X\\n\", reg);\n\n\t \n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t      &soc_codec_dev_max98520,\n\t\t\t\t\t\t  max98520_dai, ARRAY_SIZE(max98520_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev, \"Failed to register codec: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98520_i2c_id[] = {\n\t{ \"max98520\", 0},\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(i2c, max98520_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98520_of_match[] = {\n\t{ .compatible = \"maxim,max98520\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98520_of_match);\n#endif\n\nstatic struct i2c_driver max98520_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98520\",\n\t\t.of_match_table = of_match_ptr(max98520_of_match),\n\t\t.pm = &max98520_pm,\n\t},\n\t.probe = max98520_i2c_probe,\n\t.id_table = max98520_i2c_id,\n};\n\nmodule_i2c_driver(max98520_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98520 driver\");\nMODULE_AUTHOR(\"George Song <george.song@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}