{
  "module_name": "hda.c",
  "hash_id": "ac604d6881d60e907df0b619ebd06b75d34b5b1b485824a63822df20ee858722",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/hda.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/soc.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_i915.h>\n#include <sound/hda_codec.h>\n#include \"hda.h\"\n\nstatic int hda_codec_create_dais(struct hda_codec *codec, int pcm_count,\n\t\t\t\t struct snd_soc_dai_driver **drivers)\n{\n\tstruct device *dev = &codec->core.dev;\n\tstruct snd_soc_dai_driver *drvs;\n\tstruct hda_pcm *pcm;\n\tint i;\n\n\tdrvs = devm_kcalloc(dev, pcm_count, sizeof(*drvs), GFP_KERNEL);\n\tif (!drvs)\n\t\treturn -ENOMEM;\n\n\tpcm = list_first_entry(&codec->pcm_list_head, struct hda_pcm, list);\n\n\tfor (i = 0; i < pcm_count; i++, pcm = list_next_entry(pcm, list)) {\n\t\tstruct snd_soc_pcm_stream *stream;\n\t\tint dir;\n\n\t\tdev_info(dev, \"creating for %s %d\\n\", pcm->name, i);\n\t\tdrvs[i].id = i;\n\t\tdrvs[i].name = pcm->name;\n\t\tdrvs[i].ops = &snd_soc_hda_codec_dai_ops;\n\n\t\tdir = SNDRV_PCM_STREAM_PLAYBACK;\n\t\tstream = &drvs[i].playback;\n\t\tif (!pcm->stream[dir].substreams) {\n\t\t\tdev_info(dev, \"skipping playback dai for %s\\n\", pcm->name);\n\t\t\tgoto capture_dais;\n\t\t}\n\n\t\tstream->stream_name =\n\t\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%s %s\", pcm->name,\n\t\t\t\t       snd_pcm_direction_name(dir));\n\t\tif (!stream->stream_name)\n\t\t\treturn -ENOMEM;\n\t\tstream->channels_min = pcm->stream[dir].channels_min;\n\t\tstream->channels_max = pcm->stream[dir].channels_max;\n\t\tstream->rates = pcm->stream[dir].rates;\n\t\tstream->formats = pcm->stream[dir].formats;\n\t\tstream->sig_bits = pcm->stream[dir].maxbps;\n\ncapture_dais:\n\t\tdir = SNDRV_PCM_STREAM_CAPTURE;\n\t\tstream = &drvs[i].capture;\n\t\tif (!pcm->stream[dir].substreams) {\n\t\t\tdev_info(dev, \"skipping capture dai for %s\\n\", pcm->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstream->stream_name =\n\t\t\tdevm_kasprintf(dev, GFP_KERNEL, \"%s %s\", pcm->name,\n\t\t\t\t       snd_pcm_direction_name(dir));\n\t\tif (!stream->stream_name)\n\t\t\treturn -ENOMEM;\n\t\tstream->channels_min = pcm->stream[dir].channels_min;\n\t\tstream->channels_max = pcm->stream[dir].channels_max;\n\t\tstream->rates = pcm->stream[dir].rates;\n\t\tstream->formats = pcm->stream[dir].formats;\n\t\tstream->sig_bits = pcm->stream[dir].maxbps;\n\t}\n\n\t*drivers = drvs;\n\treturn 0;\n}\n\nstatic int hda_codec_register_dais(struct hda_codec *codec, struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai_driver *drvs = NULL;\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct hda_pcm *pcm;\n\tint ret, pcm_count = 0;\n\n\tif (list_empty(&codec->pcm_list_head))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list)\n\t\tpcm_count++;\n\n\tret = hda_codec_create_dais(codec, pcm_count, &drvs);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdapm = snd_soc_component_get_dapm(component);\n\n\tlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\n\t\tstruct snd_soc_dai *dai;\n\n\t\tdai = snd_soc_register_dai(component, drvs, false);\n\t\tif (!dai) {\n\t\t\tdev_err(component->dev, \"register dai for %s failed\\n\", pcm->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = snd_soc_dapm_new_dai_widgets(dapm, dai);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"create widgets failed: %d\\n\", ret);\n\t\t\tsnd_soc_unregister_dai(dai);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsnd_soc_dai_init_dma_data(dai, &pcm->stream[0], &pcm->stream[1]);\n\t\tdrvs++;\n\t}\n\n\treturn 0;\n}\n\nstatic void hda_codec_unregister_dais(struct hda_codec *codec,\n\t\t\t\t      struct snd_soc_component *component)\n{\n\tstruct snd_soc_dai *dai, *save;\n\tstruct hda_pcm *pcm;\n\n\tfor_each_component_dais_safe(component, dai, save) {\n\t\tint stream;\n\n\t\tlist_for_each_entry(pcm, &codec->pcm_list_head, list) {\n\t\t\tif (strcmp(dai->driver->name, pcm->name))\n\t\t\t\tcontinue;\n\n\t\t\tfor_each_pcm_streams(stream)\n\t\t\t\tsnd_soc_dapm_free_widget(snd_soc_dai_get_widget(dai, stream));\n\n\t\t\tsnd_soc_unregister_dai(dai);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint hda_codec_probe_complete(struct hda_codec *codec)\n{\n\tstruct hdac_device *hdev = &codec->core;\n\tstruct hdac_bus *bus = hdev->bus;\n\tint ret;\n\n\tret = snd_hda_codec_build_controls(codec);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to create controls %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tpm_runtime_set_active(&hdev->dev);\n\t \n\tsnd_hda_codec_set_power_save(codec, 2000);\n\tsnd_hda_codec_register(codec);\nout:\n\t \n\tpm_runtime_mark_last_busy(bus->dev);\n\tpm_runtime_put_autosuspend(bus->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(hda_codec_probe_complete);\n\n \nstatic int hda_codec_probe(struct snd_soc_component *component)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(component->dev);\n\tstruct hdac_device *hdev = &codec->core;\n\tstruct hdac_bus *bus = hdev->bus;\n\tstruct hdac_ext_link *hlink;\n\thda_codec_patch_t patch;\n\tint ret;\n\n#ifdef CONFIG_PM\n\tWARN_ON(atomic_read(&hdev->dev.power.usage_count) != 1 ||\n\t\t!pm_runtime_status_suspended(&hdev->dev));\n#endif\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_addr(bus, hdev->addr);\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpm_runtime_get_sync(bus->dev);\n\tif (hda_codec_is_display(codec))\n\t\tsnd_hdac_display_power(bus, hdev->addr, true);\n\tsnd_hdac_ext_bus_link_get(bus, hlink);\n\n\tret = snd_hda_codec_device_new(codec->bus, component->card->snd_card, hdev->addr, codec,\n\t\t\t\t       false);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"create hda codec failed: %d\\n\", ret);\n\t\tgoto device_new_err;\n\t}\n\n\tret = snd_hda_codec_set_name(codec, codec->preset->name);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"name failed %s\\n\", codec->preset->name);\n\t\tgoto err;\n\t}\n\n\tret = snd_hdac_regmap_init(&codec->core);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"regmap init failed\\n\");\n\t\tgoto err;\n\t}\n\n\tpatch = (hda_codec_patch_t)codec->preset->driver_data;\n\tif (!patch) {\n\t\tdev_err(&hdev->dev, \"no patch specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = patch(codec);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"patch failed %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = snd_hda_codec_parse_pcms(codec);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to map pcms to dai %d\\n\", ret);\n\t\tgoto parse_pcms_err;\n\t}\n\n\tret = hda_codec_register_dais(codec, component);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"update dais failed: %d\\n\", ret);\n\t\tgoto parse_pcms_err;\n\t}\n\n\tif (!hda_codec_is_display(codec)) {\n\t\tret = hda_codec_probe_complete(codec);\n\t\tif (ret < 0)\n\t\t\tgoto complete_err;\n\t}\n\n\tcodec->core.lazy_cache = true;\n\n\treturn 0;\n\ncomplete_err:\n\thda_codec_unregister_dais(codec, component);\nparse_pcms_err:\n\tif (codec->patch_ops.free)\n\t\tcodec->patch_ops.free(codec);\nerr:\n\tsnd_hda_codec_cleanup_for_unbind(codec);\ndevice_new_err:\n\tif (hda_codec_is_display(codec))\n\t\tsnd_hdac_display_power(bus, hdev->addr, false);\n\n\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\n\tpm_runtime_mark_last_busy(bus->dev);\n\tpm_runtime_put_autosuspend(bus->dev);\n\treturn ret;\n}\n\n \nstatic void hda_codec_remove(struct snd_soc_component *component)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(component->dev);\n\tstruct hdac_device *hdev = &codec->core;\n\tstruct hdac_bus *bus = hdev->bus;\n\tstruct hdac_ext_link *hlink;\n\tbool was_registered = codec->core.registered;\n\n\t \n\tpm_runtime_forbid(&hdev->dev);\n\n\thda_codec_unregister_dais(codec, component);\n\n\tif (codec->patch_ops.free)\n\t\tcodec->patch_ops.free(codec);\n\n\tsnd_hda_codec_cleanup_for_unbind(codec);\n\tpm_runtime_put_noidle(&hdev->dev);\n\t \n\tpm_runtime_set_suspended(&hdev->dev);\n\n\tif (hda_codec_is_display(codec))\n\t\tsnd_hdac_display_power(bus, hdev->addr, false);\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_addr(bus, hdev->addr);\n\tif (hlink)\n\t\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\t \n\tif (!was_registered) {\n\t\tpm_runtime_mark_last_busy(bus->dev);\n\t\tpm_runtime_put_autosuspend(bus->dev);\n\t}\n\n#ifdef CONFIG_PM\n\tWARN_ON(atomic_read(&hdev->dev.power.usage_count) != 1 ||\n\t\t!pm_runtime_status_suspended(&hdev->dev));\n#endif\n}\n\nstatic const struct snd_soc_dapm_route hda_dapm_routes[] = {\n\t{\"AIF1TX\", NULL, \"Codec Input Pin1\"},\n\t{\"AIF2TX\", NULL, \"Codec Input Pin2\"},\n\t{\"AIF3TX\", NULL, \"Codec Input Pin3\"},\n\n\t{\"Codec Output Pin1\", NULL, \"AIF1RX\"},\n\t{\"Codec Output Pin2\", NULL, \"AIF2RX\"},\n\t{\"Codec Output Pin3\", NULL, \"AIF3RX\"},\n};\n\nstatic const struct snd_soc_dapm_widget hda_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RX\", \"Analog Codec Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF2RX\", \"Digital Codec Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF3RX\", \"Alt Analog Codec Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX\", \"Analog Codec Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2TX\", \"Digital Codec Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF3TX\", \"Alt Analog Codec Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin1\"),\n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin2\"),\n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin3\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin1\"),\n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin2\"),\n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin3\"),\n};\n\nstatic struct snd_soc_dai_driver card_binder_dai = {\n\t.id = -1,\n\t.name = \"codec-probing-DAI\",\n};\n\nstatic int hda_hdev_attach(struct hdac_device *hdev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(&hdev->dev);\n\tstruct snd_soc_component_driver *comp_drv;\n\n\tcomp_drv = devm_kzalloc(&hdev->dev, sizeof(*comp_drv), GFP_KERNEL);\n\tif (!comp_drv)\n\t\treturn -ENOMEM;\n\n\t \n\tcomp_drv->name = dev_name(&hdev->dev);\n\tcomp_drv->probe = hda_codec_probe;\n\tcomp_drv->remove = hda_codec_remove;\n\tcomp_drv->idle_bias_on = false;\n\tif (!hda_codec_is_display(codec)) {\n\t\tcomp_drv->dapm_widgets = hda_dapm_widgets;\n\t\tcomp_drv->num_dapm_widgets = ARRAY_SIZE(hda_dapm_widgets);\n\t\tcomp_drv->dapm_routes = hda_dapm_routes;\n\t\tcomp_drv->num_dapm_routes = ARRAY_SIZE(hda_dapm_routes);\n\t}\n\n\treturn snd_soc_register_component(&hdev->dev, comp_drv, &card_binder_dai, 1);\n}\n\nstatic int hda_hdev_detach(struct hdac_device *hdev)\n{\n\tstruct hda_codec *codec = dev_to_hda_codec(&hdev->dev);\n\n\tif (codec->core.registered)\n\t\tcancel_delayed_work_sync(&codec->jackpoll_work);\n\n\tsnd_soc_unregister_component(&hdev->dev);\n\n\treturn 0;\n}\n\nconst struct hdac_ext_bus_ops soc_hda_ext_bus_ops = {\n\t.hdev_attach = hda_hdev_attach,\n\t.hdev_detach = hda_hdev_detach,\n};\nEXPORT_SYMBOL_GPL(soc_hda_ext_bus_ops);\n\nMODULE_DESCRIPTION(\"HD-Audio codec driver\");\nMODULE_AUTHOR(\"Cezary Rojewski <cezary.rojewski@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}