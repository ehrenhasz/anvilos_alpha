{
  "module_name": "da7219.c",
  "hash_id": "7fa2ea9d4f2e54a0831a775b6dfe8a2784d766ba72dfecda5e7d2835e582a51b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/da7219.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/clkdev.h>\n#include <linux/clk-provider.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/pm.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <asm/div64.h>\n\n#include <sound/da7219.h>\n#include \"da7219.h\"\n#include \"da7219-aad.h\"\n\n\n \n\n \nstatic const DECLARE_TLV_DB_SCALE(da7219_mic_gain_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_mixin_gain_tlv, -450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_adc_dig_gain_tlv, -8325, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_alc_threshold_tlv, -9450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_alc_gain_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_alc_ana_gain_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_sidetone_gain_tlv, -4200, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_tonegen_gain_tlv, -4500, 300, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(da7219_dac_eq_band_tlv, -1050, 150, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(da7219_dac_dig_gain_tlv,\n\t0x0, 0x07, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),\n\t \n\t0x08, 0x7f, TLV_DB_SCALE_ITEM(-7725, 75, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(da7219_dac_ng_threshold_tlv, -10200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(da7219_hp_gain_tlv, -5700, 100, 0);\n\n \nstatic const char * const da7219_alc_attack_rate_txt[] = {\n\t\"7.33/fs\", \"14.66/fs\", \"29.32/fs\", \"58.64/fs\", \"117.3/fs\", \"234.6/fs\",\n\t\"469.1/fs\", \"938.2/fs\", \"1876/fs\", \"3753/fs\", \"7506/fs\", \"15012/fs\",\n\t\"30024/fs\"\n};\n\nstatic const struct soc_enum da7219_alc_attack_rate =\n\tSOC_ENUM_SINGLE(DA7219_ALC_CTRL2, DA7219_ALC_ATTACK_SHIFT,\n\t\t\tDA7219_ALC_ATTACK_MAX, da7219_alc_attack_rate_txt);\n\nstatic const char * const da7219_alc_release_rate_txt[] = {\n\t\"28.66/fs\", \"57.33/fs\", \"114.6/fs\", \"229.3/fs\", \"458.6/fs\", \"917.1/fs\",\n\t\"1834/fs\", \"3668/fs\", \"7337/fs\", \"14674/fs\", \"29348/fs\"\n};\n\nstatic const struct soc_enum da7219_alc_release_rate =\n\tSOC_ENUM_SINGLE(DA7219_ALC_CTRL2, DA7219_ALC_RELEASE_SHIFT,\n\t\t\tDA7219_ALC_RELEASE_MAX, da7219_alc_release_rate_txt);\n\nstatic const char * const da7219_alc_hold_time_txt[] = {\n\t\"62/fs\", \"124/fs\", \"248/fs\", \"496/fs\", \"992/fs\", \"1984/fs\", \"3968/fs\",\n\t\"7936/fs\", \"15872/fs\", \"31744/fs\", \"63488/fs\", \"126976/fs\",\n\t\"253952/fs\", \"507904/fs\", \"1015808/fs\", \"2031616/fs\"\n};\n\nstatic const struct soc_enum da7219_alc_hold_time =\n\tSOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_HOLD_SHIFT,\n\t\t\tDA7219_ALC_HOLD_MAX, da7219_alc_hold_time_txt);\n\nstatic const char * const da7219_alc_env_rate_txt[] = {\n\t\"1/4\", \"1/16\", \"1/256\", \"1/65536\"\n};\n\nstatic const struct soc_enum da7219_alc_env_attack_rate =\n\tSOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_INTEG_ATTACK_SHIFT,\n\t\t\tDA7219_ALC_INTEG_MAX, da7219_alc_env_rate_txt);\n\nstatic const struct soc_enum da7219_alc_env_release_rate =\n\tSOC_ENUM_SINGLE(DA7219_ALC_CTRL3, DA7219_ALC_INTEG_RELEASE_SHIFT,\n\t\t\tDA7219_ALC_INTEG_MAX, da7219_alc_env_rate_txt);\n\nstatic const char * const da7219_alc_anticlip_step_txt[] = {\n\t\"0.034dB/fs\", \"0.068dB/fs\", \"0.136dB/fs\", \"0.272dB/fs\"\n};\n\nstatic const struct soc_enum da7219_alc_anticlip_step =\n\tSOC_ENUM_SINGLE(DA7219_ALC_ANTICLIP_CTRL,\n\t\t\tDA7219_ALC_ANTICLIP_STEP_SHIFT,\n\t\t\tDA7219_ALC_ANTICLIP_STEP_MAX,\n\t\t\tda7219_alc_anticlip_step_txt);\n\n \nstatic const char * const da7219_gain_ramp_rate_txt[] = {\n\t\"Nominal Rate * 8\", \"Nominal Rate\", \"Nominal Rate / 8\",\n\t\"Nominal Rate / 16\"\n};\n\nstatic const struct soc_enum da7219_gain_ramp_rate =\n\tSOC_ENUM_SINGLE(DA7219_GAIN_RAMP_CTRL, DA7219_GAIN_RAMP_RATE_SHIFT,\n\t\t\tDA7219_GAIN_RAMP_RATE_MAX, da7219_gain_ramp_rate_txt);\n\nstatic const char * const da7219_hpf_mode_txt[] = {\n\t\"Disabled\", \"Audio\", \"Voice\"\n};\n\nstatic const unsigned int da7219_hpf_mode_val[] = {\n\tDA7219_HPF_DISABLED, DA7219_HPF_AUDIO_EN, DA7219_HPF_VOICE_EN,\n};\n\nstatic const struct soc_enum da7219_adc_hpf_mode =\n\tSOC_VALUE_ENUM_SINGLE(DA7219_ADC_FILTERS1, DA7219_HPF_MODE_SHIFT,\n\t\t\t      DA7219_HPF_MODE_MASK, DA7219_HPF_MODE_MAX,\n\t\t\t      da7219_hpf_mode_txt, da7219_hpf_mode_val);\n\nstatic const struct soc_enum da7219_dac_hpf_mode =\n\tSOC_VALUE_ENUM_SINGLE(DA7219_DAC_FILTERS1, DA7219_HPF_MODE_SHIFT,\n\t\t\t      DA7219_HPF_MODE_MASK, DA7219_HPF_MODE_MAX,\n\t\t\t      da7219_hpf_mode_txt, da7219_hpf_mode_val);\n\nstatic const char * const da7219_audio_hpf_corner_txt[] = {\n\t\"2Hz\", \"4Hz\", \"8Hz\", \"16Hz\"\n};\n\nstatic const struct soc_enum da7219_adc_audio_hpf_corner =\n\tSOC_ENUM_SINGLE(DA7219_ADC_FILTERS1,\n\t\t\tDA7219_ADC_AUDIO_HPF_CORNER_SHIFT,\n\t\t\tDA7219_AUDIO_HPF_CORNER_MAX,\n\t\t\tda7219_audio_hpf_corner_txt);\n\nstatic const struct soc_enum da7219_dac_audio_hpf_corner =\n\tSOC_ENUM_SINGLE(DA7219_DAC_FILTERS1,\n\t\t\tDA7219_DAC_AUDIO_HPF_CORNER_SHIFT,\n\t\t\tDA7219_AUDIO_HPF_CORNER_MAX,\n\t\t\tda7219_audio_hpf_corner_txt);\n\nstatic const char * const da7219_voice_hpf_corner_txt[] = {\n\t\"2.5Hz\", \"25Hz\", \"50Hz\", \"100Hz\", \"150Hz\", \"200Hz\", \"300Hz\", \"400Hz\"\n};\n\nstatic const struct soc_enum da7219_adc_voice_hpf_corner =\n\tSOC_ENUM_SINGLE(DA7219_ADC_FILTERS1,\n\t\t\tDA7219_ADC_VOICE_HPF_CORNER_SHIFT,\n\t\t\tDA7219_VOICE_HPF_CORNER_MAX,\n\t\t\tda7219_voice_hpf_corner_txt);\n\nstatic const struct soc_enum da7219_dac_voice_hpf_corner =\n\tSOC_ENUM_SINGLE(DA7219_DAC_FILTERS1,\n\t\t\tDA7219_DAC_VOICE_HPF_CORNER_SHIFT,\n\t\t\tDA7219_VOICE_HPF_CORNER_MAX,\n\t\t\tda7219_voice_hpf_corner_txt);\n\nstatic const char * const da7219_tonegen_dtmf_key_txt[] = {\n\t\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\",\n\t\"*\", \"#\"\n};\n\nstatic const struct soc_enum da7219_tonegen_dtmf_key =\n\tSOC_ENUM_SINGLE(DA7219_TONE_GEN_CFG1, DA7219_DTMF_REG_SHIFT,\n\t\t\tDA7219_DTMF_REG_MAX, da7219_tonegen_dtmf_key_txt);\n\nstatic const char * const da7219_tonegen_swg_sel_txt[] = {\n\t\"Sum\", \"SWG1\", \"SWG2\", \"SWG1_1-Cos\"\n};\n\nstatic const struct soc_enum da7219_tonegen_swg_sel =\n\tSOC_ENUM_SINGLE(DA7219_TONE_GEN_CFG2, DA7219_SWG_SEL_SHIFT,\n\t\t\tDA7219_SWG_SEL_MAX, da7219_tonegen_swg_sel_txt);\n\n \nstatic const char * const da7219_dac_softmute_rate_txt[] = {\n\t\"1 Sample\", \"2 Samples\", \"4 Samples\", \"8 Samples\", \"16 Samples\",\n\t\"32 Samples\", \"64 Samples\"\n};\n\nstatic const struct soc_enum da7219_dac_softmute_rate =\n\tSOC_ENUM_SINGLE(DA7219_DAC_FILTERS5, DA7219_DAC_SOFTMUTE_RATE_SHIFT,\n\t\t\tDA7219_DAC_SOFTMUTE_RATE_MAX,\n\t\t\tda7219_dac_softmute_rate_txt);\n\nstatic const char * const da7219_dac_ng_setup_time_txt[] = {\n\t\"256 Samples\", \"512 Samples\", \"1024 Samples\", \"2048 Samples\"\n};\n\nstatic const struct soc_enum da7219_dac_ng_setup_time =\n\tSOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,\n\t\t\tDA7219_DAC_NG_SETUP_TIME_SHIFT,\n\t\t\tDA7219_DAC_NG_SETUP_TIME_MAX,\n\t\t\tda7219_dac_ng_setup_time_txt);\n\nstatic const char * const da7219_dac_ng_rampup_txt[] = {\n\t\"0.22ms/dB\", \"0.0138ms/dB\"\n};\n\nstatic const struct soc_enum da7219_dac_ng_rampup_rate =\n\tSOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,\n\t\t\tDA7219_DAC_NG_RAMPUP_RATE_SHIFT,\n\t\t\tDA7219_DAC_NG_RAMP_RATE_MAX,\n\t\t\tda7219_dac_ng_rampup_txt);\n\nstatic const char * const da7219_dac_ng_rampdown_txt[] = {\n\t\"0.88ms/dB\", \"14.08ms/dB\"\n};\n\nstatic const struct soc_enum da7219_dac_ng_rampdown_rate =\n\tSOC_ENUM_SINGLE(DA7219_DAC_NG_SETUP_TIME,\n\t\t\tDA7219_DAC_NG_RAMPDN_RATE_SHIFT,\n\t\t\tDA7219_DAC_NG_RAMP_RATE_MAX,\n\t\t\tda7219_dac_ng_rampdown_txt);\n\n\nstatic const char * const da7219_cp_track_mode_txt[] = {\n\t\"Largest Volume\", \"DAC Volume\", \"Signal Magnitude\"\n};\n\nstatic const unsigned int da7219_cp_track_mode_val[] = {\n\tDA7219_CP_MCHANGE_LARGEST_VOL, DA7219_CP_MCHANGE_DAC_VOL,\n\tDA7219_CP_MCHANGE_SIG_MAG\n};\n\nstatic const struct soc_enum da7219_cp_track_mode =\n\tSOC_VALUE_ENUM_SINGLE(DA7219_CP_CTRL, DA7219_CP_MCHANGE_SHIFT,\n\t\t\t      DA7219_CP_MCHANGE_REL_MASK, DA7219_CP_MCHANGE_MAX,\n\t\t\t      da7219_cp_track_mode_txt,\n\t\t\t      da7219_cp_track_mode_val);\n\n\n \n\n \nstatic int da7219_volsw_locked_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = snd_soc_get_volsw(kcontrol, ucontrol);\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\treturn ret;\n}\n\nstatic int da7219_volsw_locked_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = snd_soc_put_volsw(kcontrol, ucontrol);\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\treturn ret;\n}\n\nstatic int da7219_enum_locked_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = snd_soc_get_enum_double(kcontrol, ucontrol);\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\treturn ret;\n}\n\nstatic int da7219_enum_locked_put(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = snd_soc_put_enum_double(kcontrol, ucontrol);\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\treturn ret;\n}\n\n \nstatic void da7219_alc_calib(struct snd_soc_component *component)\n{\n\tu8 mic_ctrl, mixin_ctrl, adc_ctrl, calib_ctrl;\n\n\t \n\tmic_ctrl = snd_soc_component_read(component, DA7219_MIC_1_CTRL);\n\n\t \n\tmixin_ctrl = snd_soc_component_read(component, DA7219_MIXIN_L_CTRL);\n\n\t \n\tadc_ctrl = snd_soc_component_read(component, DA7219_ADC_L_CTRL);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_MIC_1_CTRL, DA7219_MIC_1_AMP_EN_MASK,\n\t\t\t    DA7219_MIC_1_AMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_MIC_1_CTRL,\n\t\t\t    DA7219_MIC_1_AMP_MUTE_EN_MASK,\n\t\t\t    DA7219_MIC_1_AMP_MUTE_EN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_MIXIN_L_CTRL,\n\t\t\t    DA7219_MIXIN_L_AMP_EN_MASK |\n\t\t\t    DA7219_MIXIN_L_AMP_MUTE_EN_MASK,\n\t\t\t    DA7219_MIXIN_L_AMP_EN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ADC_L_CTRL,\n\t\t\t    DA7219_ADC_L_MUTE_EN_MASK | DA7219_ADC_L_EN_MASK,\n\t\t\t    DA7219_ADC_L_EN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_ALC_CTRL1,\n\t\t\t    DA7219_ALC_AUTO_CALIB_EN_MASK,\n\t\t\t    DA7219_ALC_AUTO_CALIB_EN_MASK);\n\tdo {\n\t\tcalib_ctrl = snd_soc_component_read(component, DA7219_ALC_CTRL1);\n\t} while (calib_ctrl & DA7219_ALC_AUTO_CALIB_EN_MASK);\n\n\t \n\tif (calib_ctrl & DA7219_ALC_CALIB_OVERFLOW_MASK) {\n\t\tdev_warn(component->dev,\n\t\t\t \"ALC auto calibration failed with overflow\\n\");\n\t\tsnd_soc_component_update_bits(component, DA7219_ALC_CTRL1,\n\t\t\t\t    DA7219_ALC_OFFSET_EN_MASK |\n\t\t\t\t    DA7219_ALC_SYNC_MODE_MASK, 0);\n\t} else {\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7219_ALC_CTRL1,\n\t\t\t\t    DA7219_ALC_OFFSET_EN_MASK |\n\t\t\t\t    DA7219_ALC_SYNC_MODE_MASK,\n\t\t\t\t    DA7219_ALC_OFFSET_EN_MASK |\n\t\t\t\t    DA7219_ALC_SYNC_MODE_MASK);\n\t}\n\n\t \n\tsnd_soc_component_write(component, DA7219_ADC_L_CTRL, adc_ctrl);\n\n\t \n\tsnd_soc_component_write(component, DA7219_MIXIN_L_CTRL, mixin_ctrl);\n\n\t \n\tsnd_soc_component_write(component, DA7219_MIC_1_CTRL, mic_ctrl);\n}\n\nstatic int da7219_mixin_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = snd_soc_put_volsw(kcontrol, ucontrol);\n\n\t \n\tif ((ret == 1) && (da7219->alc_en))\n\t\tda7219_alc_calib(component);\n\n\treturn ret;\n}\n\nstatic int da7219_alc_sw_put(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\n\t \n\tif ((ucontrol->value.integer.value[0]) && (!da7219->alc_en)) {\n\t\tda7219_alc_calib(component);\n\t\tda7219->alc_en = true;\n\t} else {\n\t\tda7219->alc_en = false;\n\t}\n\n\treturn snd_soc_put_volsw(kcontrol, ucontrol);\n}\n\n \nstatic int da7219_tonegen_freq_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mixer_ctrl =\n\t\t(struct soc_mixer_control *) kcontrol->private_value;\n\tunsigned int reg = mixer_ctrl->reg;\n\t__le16 val;\n\tint ret;\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = regmap_raw_read(da7219->regmap, reg, &val, sizeof(val));\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tucontrol->value.integer.value[0] = le16_to_cpu(val);\n\n\treturn 0;\n}\n\nstatic int da7219_tonegen_freq_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mixer_ctrl =\n\t\t(struct soc_mixer_control *) kcontrol->private_value;\n\tunsigned int reg = mixer_ctrl->reg;\n\t__le16 val_new, val_old;\n\tint ret;\n\n\t \n\tval_new = cpu_to_le16(ucontrol->value.integer.value[0]);\n\n\tmutex_lock(&da7219->ctrl_lock);\n\tret = regmap_raw_read(da7219->regmap, reg, &val_old, sizeof(val_old));\n\tif (ret == 0 && (val_old != val_new))\n\t\tret = regmap_raw_write(da7219->regmap, reg,\n\t\t\t\t&val_new, sizeof(val_new));\n\tmutex_unlock(&da7219->ctrl_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val_old != val_new;\n}\n\n\n \n\nstatic const struct snd_kcontrol_new da7219_snd_controls[] = {\n\t \n\tSOC_SINGLE_TLV(\"Mic Volume\", DA7219_MIC_1_GAIN,\n\t\t       DA7219_MIC_1_AMP_GAIN_SHIFT, DA7219_MIC_1_AMP_GAIN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_mic_gain_tlv),\n\tSOC_SINGLE(\"Mic Switch\", DA7219_MIC_1_CTRL,\n\t\t   DA7219_MIC_1_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_INVERT),\n\n\t \n\tSOC_SINGLE_EXT_TLV(\"Mixin Volume\", DA7219_MIXIN_L_GAIN,\n\t\t\t   DA7219_MIXIN_L_AMP_GAIN_SHIFT,\n\t\t\t   DA7219_MIXIN_L_AMP_GAIN_MAX, DA7219_NO_INVERT,\n\t\t\t   snd_soc_get_volsw, da7219_mixin_gain_put,\n\t\t\t   da7219_mixin_gain_tlv),\n\tSOC_SINGLE(\"Mixin Switch\", DA7219_MIXIN_L_CTRL,\n\t\t   DA7219_MIXIN_L_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_INVERT),\n\tSOC_SINGLE(\"Mixin Gain Ramp Switch\", DA7219_MIXIN_L_CTRL,\n\t\t   DA7219_MIXIN_L_AMP_RAMP_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_NO_INVERT),\n\tSOC_SINGLE(\"Mixin ZC Gain Switch\", DA7219_MIXIN_L_CTRL,\n\t\t   DA7219_MIXIN_L_AMP_ZC_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_NO_INVERT),\n\n\t \n\tSOC_SINGLE_TLV(\"Capture Digital Volume\", DA7219_ADC_L_GAIN,\n\t\t       DA7219_ADC_L_DIGITAL_GAIN_SHIFT,\n\t\t       DA7219_ADC_L_DIGITAL_GAIN_MAX, DA7219_NO_INVERT,\n\t\t       da7219_adc_dig_gain_tlv),\n\tSOC_SINGLE(\"Capture Digital Switch\", DA7219_ADC_L_CTRL,\n\t\t   DA7219_ADC_L_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_INVERT),\n\tSOC_SINGLE(\"Capture Digital Gain Ramp Switch\", DA7219_ADC_L_CTRL,\n\t\t   DA7219_ADC_L_RAMP_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_NO_INVERT),\n\n\t \n\tSOC_ENUM(\"ALC Attack Rate\", da7219_alc_attack_rate),\n\tSOC_ENUM(\"ALC Release Rate\", da7219_alc_release_rate),\n\tSOC_ENUM(\"ALC Hold Time\", da7219_alc_hold_time),\n\tSOC_ENUM(\"ALC Envelope Attack Rate\", da7219_alc_env_attack_rate),\n\tSOC_ENUM(\"ALC Envelope Release Rate\", da7219_alc_env_release_rate),\n\tSOC_SINGLE_TLV(\"ALC Noise Threshold\", DA7219_ALC_NOISE,\n\t\t       DA7219_ALC_NOISE_SHIFT, DA7219_ALC_THRESHOLD_MAX,\n\t\t       DA7219_INVERT, da7219_alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Min Threshold\", DA7219_ALC_TARGET_MIN,\n\t\t       DA7219_ALC_THRESHOLD_MIN_SHIFT, DA7219_ALC_THRESHOLD_MAX,\n\t\t       DA7219_INVERT, da7219_alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Threshold\", DA7219_ALC_TARGET_MAX,\n\t\t       DA7219_ALC_THRESHOLD_MAX_SHIFT, DA7219_ALC_THRESHOLD_MAX,\n\t\t       DA7219_INVERT, da7219_alc_threshold_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Attenuation\", DA7219_ALC_GAIN_LIMITS,\n\t\t       DA7219_ALC_ATTEN_MAX_SHIFT, DA7219_ALC_ATTEN_GAIN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_alc_gain_tlv),\n\tSOC_SINGLE_TLV(\"ALC Max Volume\", DA7219_ALC_GAIN_LIMITS,\n\t\t       DA7219_ALC_GAIN_MAX_SHIFT, DA7219_ALC_ATTEN_GAIN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_alc_gain_tlv),\n\tSOC_SINGLE_RANGE_TLV(\"ALC Min Analog Volume\", DA7219_ALC_ANA_GAIN_LIMITS,\n\t\t\t     DA7219_ALC_ANA_GAIN_MIN_SHIFT,\n\t\t\t     DA7219_ALC_ANA_GAIN_MIN, DA7219_ALC_ANA_GAIN_MAX,\n\t\t\t     DA7219_NO_INVERT, da7219_alc_ana_gain_tlv),\n\tSOC_SINGLE_RANGE_TLV(\"ALC Max Analog Volume\", DA7219_ALC_ANA_GAIN_LIMITS,\n\t\t\t     DA7219_ALC_ANA_GAIN_MAX_SHIFT,\n\t\t\t     DA7219_ALC_ANA_GAIN_MIN, DA7219_ALC_ANA_GAIN_MAX,\n\t\t\t     DA7219_NO_INVERT, da7219_alc_ana_gain_tlv),\n\tSOC_ENUM(\"ALC Anticlip Step\", da7219_alc_anticlip_step),\n\tSOC_SINGLE(\"ALC Anticlip Switch\", DA7219_ALC_ANTICLIP_CTRL,\n\t\t   DA7219_ALC_ANTIPCLIP_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_NO_INVERT),\n\tSOC_SINGLE_EXT(\"ALC Switch\", DA7219_ALC_CTRL1, DA7219_ALC_EN_SHIFT,\n\t\t       DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT,\n\t\t       snd_soc_get_volsw, da7219_alc_sw_put),\n\n\t \n\tSOC_ENUM(\"ADC HPF Mode\", da7219_adc_hpf_mode),\n\tSOC_ENUM(\"ADC HPF Corner Audio\", da7219_adc_audio_hpf_corner),\n\tSOC_ENUM(\"ADC HPF Corner Voice\", da7219_adc_voice_hpf_corner),\n\n\t \n\tSOC_SINGLE_TLV(\"Sidetone Volume\", DA7219_SIDETONE_GAIN,\n\t\t       DA7219_SIDETONE_GAIN_SHIFT, DA7219_SIDETONE_GAIN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_sidetone_gain_tlv),\n\tSOC_SINGLE(\"Sidetone Switch\", DA7219_SIDETONE_CTRL,\n\t\t   DA7219_SIDETONE_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t   DA7219_INVERT),\n\n\t \n\tSOC_SINGLE_EXT_TLV(\"ToneGen Volume\", DA7219_TONE_GEN_CFG2,\n\t\t\t   DA7219_TONE_GEN_GAIN_SHIFT, DA7219_TONE_GEN_GAIN_MAX,\n\t\t\t   DA7219_NO_INVERT, da7219_volsw_locked_get,\n\t\t\t   da7219_volsw_locked_put, da7219_tonegen_gain_tlv),\n\tSOC_ENUM_EXT(\"ToneGen DTMF Key\", da7219_tonegen_dtmf_key,\n\t\t     da7219_enum_locked_get, da7219_enum_locked_put),\n\tSOC_SINGLE_EXT(\"ToneGen DTMF Switch\", DA7219_TONE_GEN_CFG1,\n\t\t       DA7219_DTMF_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_volsw_locked_get,\n\t\t       da7219_volsw_locked_put),\n\tSOC_ENUM_EXT(\"ToneGen Sinewave Gen Type\", da7219_tonegen_swg_sel,\n\t\t     da7219_enum_locked_get, da7219_enum_locked_put),\n\tSOC_SINGLE_EXT(\"ToneGen Sinewave1 Freq\", DA7219_TONE_GEN_FREQ1_L,\n\t\t       DA7219_FREQ1_L_SHIFT, DA7219_FREQ_MAX, DA7219_NO_INVERT,\n\t\t       da7219_tonegen_freq_get, da7219_tonegen_freq_put),\n\tSOC_SINGLE_EXT(\"ToneGen Sinewave2 Freq\", DA7219_TONE_GEN_FREQ2_L,\n\t\t       DA7219_FREQ2_L_SHIFT, DA7219_FREQ_MAX, DA7219_NO_INVERT,\n\t\t       da7219_tonegen_freq_get, da7219_tonegen_freq_put),\n\tSOC_SINGLE_EXT(\"ToneGen On Time\", DA7219_TONE_GEN_ON_PER,\n\t\t       DA7219_BEEP_ON_PER_SHIFT, DA7219_BEEP_ON_OFF_MAX,\n\t\t       DA7219_NO_INVERT, da7219_volsw_locked_get,\n\t\t       da7219_volsw_locked_put),\n\tSOC_SINGLE(\"ToneGen Off Time\", DA7219_TONE_GEN_OFF_PER,\n\t\t   DA7219_BEEP_OFF_PER_SHIFT, DA7219_BEEP_ON_OFF_MAX,\n\t\t   DA7219_NO_INVERT),\n\n\t \n\tSOC_ENUM(\"Gain Ramp Rate\", da7219_gain_ramp_rate),\n\n\t \n\tSOC_ENUM_EXT(\"DAC HPF Mode\", da7219_dac_hpf_mode,\n\t\t     da7219_enum_locked_get, da7219_enum_locked_put),\n\tSOC_ENUM(\"DAC HPF Corner Audio\", da7219_dac_audio_hpf_corner),\n\tSOC_ENUM(\"DAC HPF Corner Voice\", da7219_dac_voice_hpf_corner),\n\n\t \n\tSOC_SINGLE_TLV(\"DAC EQ Band1 Volume\", DA7219_DAC_FILTERS2,\n\t\t       DA7219_DAC_EQ_BAND1_SHIFT, DA7219_DAC_EQ_BAND_MAX,\n\t\t       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ Band2 Volume\", DA7219_DAC_FILTERS2,\n\t\t       DA7219_DAC_EQ_BAND2_SHIFT, DA7219_DAC_EQ_BAND_MAX,\n\t\t       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ Band3 Volume\", DA7219_DAC_FILTERS3,\n\t\t       DA7219_DAC_EQ_BAND3_SHIFT, DA7219_DAC_EQ_BAND_MAX,\n\t\t       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ Band4 Volume\", DA7219_DAC_FILTERS3,\n\t\t       DA7219_DAC_EQ_BAND4_SHIFT, DA7219_DAC_EQ_BAND_MAX,\n\t\t       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),\n\tSOC_SINGLE_TLV(\"DAC EQ Band5 Volume\", DA7219_DAC_FILTERS4,\n\t\t       DA7219_DAC_EQ_BAND5_SHIFT, DA7219_DAC_EQ_BAND_MAX,\n\t\t       DA7219_NO_INVERT, da7219_dac_eq_band_tlv),\n\tSOC_SINGLE_EXT(\"DAC EQ Switch\", DA7219_DAC_FILTERS4,\n\t\t       DA7219_DAC_EQ_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_volsw_locked_get,\n\t\t       da7219_volsw_locked_put),\n\n\t \n\tSOC_ENUM(\"DAC Soft Mute Rate\", da7219_dac_softmute_rate),\n\tSOC_SINGLE_EXT(\"DAC Soft Mute Switch\", DA7219_DAC_FILTERS5,\n\t\t       DA7219_DAC_SOFTMUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t       DA7219_NO_INVERT, da7219_volsw_locked_get,\n\t\t       da7219_volsw_locked_put),\n\n\t \n\tSOC_ENUM(\"DAC NG Setup Time\", da7219_dac_ng_setup_time),\n\tSOC_ENUM(\"DAC NG Rampup Rate\", da7219_dac_ng_rampup_rate),\n\tSOC_ENUM(\"DAC NG Rampdown Rate\", da7219_dac_ng_rampdown_rate),\n\tSOC_SINGLE_TLV(\"DAC NG Off Threshold\", DA7219_DAC_NG_OFF_THRESH,\n\t\t       DA7219_DAC_NG_OFF_THRESHOLD_SHIFT,\n\t\t       DA7219_DAC_NG_THRESHOLD_MAX, DA7219_NO_INVERT,\n\t\t       da7219_dac_ng_threshold_tlv),\n\tSOC_SINGLE_TLV(\"DAC NG On Threshold\", DA7219_DAC_NG_ON_THRESH,\n\t\t       DA7219_DAC_NG_ON_THRESHOLD_SHIFT,\n\t\t       DA7219_DAC_NG_THRESHOLD_MAX, DA7219_NO_INVERT,\n\t\t       da7219_dac_ng_threshold_tlv),\n\tSOC_SINGLE(\"DAC NG Switch\", DA7219_DAC_NG_CTRL, DA7219_DAC_NG_EN_SHIFT,\n\t\t   DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"Playback Digital Volume\", DA7219_DAC_L_GAIN,\n\t\t\t     DA7219_DAC_R_GAIN, DA7219_DAC_L_DIGITAL_GAIN_SHIFT,\n\t\t\t     DA7219_DAC_DIGITAL_GAIN_MAX, DA7219_NO_INVERT,\n\t\t\t     da7219_volsw_locked_get, da7219_volsw_locked_put,\n\t\t\t     da7219_dac_dig_gain_tlv),\n\tSOC_DOUBLE_R_EXT(\"Playback Digital Switch\", DA7219_DAC_L_CTRL,\n\t\t\t DA7219_DAC_R_CTRL, DA7219_DAC_L_MUTE_EN_SHIFT,\n\t\t\t DA7219_SWITCH_EN_MAX, DA7219_INVERT,\n\t\t\t da7219_volsw_locked_get, da7219_volsw_locked_put),\n\tSOC_DOUBLE_R(\"Playback Digital Gain Ramp Switch\", DA7219_DAC_L_CTRL,\n\t\t     DA7219_DAC_R_CTRL, DA7219_DAC_L_RAMP_EN_SHIFT,\n\t\t     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n\n\t \n\tSOC_ENUM(\"Charge Pump Track Mode\", da7219_cp_track_mode),\n\tSOC_SINGLE(\"Charge Pump Threshold\", DA7219_CP_VOL_THRESHOLD1,\n\t\t   DA7219_CP_THRESH_VDD2_SHIFT, DA7219_CP_THRESH_VDD2_MAX,\n\t\t   DA7219_NO_INVERT),\n\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"Headphone Volume\", DA7219_HP_L_GAIN,\n\t\t\t     DA7219_HP_R_GAIN, DA7219_HP_L_AMP_GAIN_SHIFT,\n\t\t\t     DA7219_HP_AMP_GAIN_MAX, DA7219_NO_INVERT,\n\t\t\t     da7219_volsw_locked_get, da7219_volsw_locked_put,\n\t\t\t     da7219_hp_gain_tlv),\n\tSOC_DOUBLE_R_EXT(\"Headphone Switch\", DA7219_HP_L_CTRL, DA7219_HP_R_CTRL,\n\t\t\t DA7219_HP_L_AMP_MUTE_EN_SHIFT, DA7219_SWITCH_EN_MAX,\n\t\t\t DA7219_INVERT, da7219_volsw_locked_get,\n\t\t\t da7219_volsw_locked_put),\n\tSOC_DOUBLE_R(\"Headphone Gain Ramp Switch\", DA7219_HP_L_CTRL,\n\t\t     DA7219_HP_R_CTRL, DA7219_HP_L_AMP_RAMP_EN_SHIFT,\n\t\t     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n\tSOC_DOUBLE_R(\"Headphone ZC Gain Switch\", DA7219_HP_L_CTRL,\n\t\t     DA7219_HP_R_CTRL, DA7219_HP_L_AMP_ZC_EN_SHIFT,\n\t\t     DA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n};\n\n\n \n\nstatic const char * const da7219_out_sel_txt[] = {\n\t\"ADC\", \"Tone Generator\", \"DAIL\", \"DAIR\"\n};\n\nstatic const struct soc_enum da7219_out_dail_sel =\n\tSOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAI,\n\t\t\tDA7219_DAI_L_SRC_SHIFT,\n\t\t\tDA7219_OUT_SRC_MAX,\n\t\t\tda7219_out_sel_txt);\n\nstatic const struct snd_kcontrol_new da7219_out_dail_sel_mux =\n\tSOC_DAPM_ENUM(\"Out DAIL Mux\", da7219_out_dail_sel);\n\nstatic const struct soc_enum da7219_out_dair_sel =\n\tSOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAI,\n\t\t\tDA7219_DAI_R_SRC_SHIFT,\n\t\t\tDA7219_OUT_SRC_MAX,\n\t\t\tda7219_out_sel_txt);\n\nstatic const struct snd_kcontrol_new da7219_out_dair_sel_mux =\n\tSOC_DAPM_ENUM(\"Out DAIR Mux\", da7219_out_dair_sel);\n\nstatic const struct soc_enum da7219_out_dacl_sel =\n\tSOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAC,\n\t\t\tDA7219_DAC_L_SRC_SHIFT,\n\t\t\tDA7219_OUT_SRC_MAX,\n\t\t\tda7219_out_sel_txt);\n\nstatic const struct snd_kcontrol_new da7219_out_dacl_sel_mux =\n\tSOC_DAPM_ENUM(\"Out DACL Mux\", da7219_out_dacl_sel);\n\nstatic const struct soc_enum da7219_out_dacr_sel =\n\tSOC_ENUM_SINGLE(DA7219_DIG_ROUTING_DAC,\n\t\t\tDA7219_DAC_R_SRC_SHIFT,\n\t\t\tDA7219_OUT_SRC_MAX,\n\t\t\tda7219_out_sel_txt);\n\nstatic const struct snd_kcontrol_new da7219_out_dacr_sel_mux =\n\tSOC_DAPM_ENUM(\"Out DACR Mux\", da7219_out_dacr_sel);\n\n\n \n\nstatic const struct snd_kcontrol_new da7219_mixin_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic Switch\", DA7219_MIXIN_L_SELECT,\n\t\t\tDA7219_MIXIN_L_MIX_SELECT_SHIFT,\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n};\n\nstatic const struct snd_kcontrol_new da7219_mixout_l_controls[] = {\n\tSOC_DAPM_SINGLE(\"DACL Switch\", DA7219_MIXOUT_L_SELECT,\n\t\t\tDA7219_MIXOUT_L_MIX_SELECT_SHIFT,\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n};\n\nstatic const struct snd_kcontrol_new da7219_mixout_r_controls[] = {\n\tSOC_DAPM_SINGLE(\"DACR Switch\", DA7219_MIXOUT_R_SELECT,\n\t\t\tDA7219_MIXOUT_R_MIX_SELECT_SHIFT,\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\n};\n\n#define DA7219_DMIX_ST_CTRLS(reg)\t\t\t\t\t\\\n\tSOC_DAPM_SINGLE(\"Out FilterL Switch\", reg,\t\t\t\\\n\t\t\tDA7219_DMIX_ST_SRC_OUTFILT1L_SHIFT,\t\t\\\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\t\\\n\tSOC_DAPM_SINGLE(\"Out FilterR Switch\", reg,\t\t\t\\\n\t\t\tDA7219_DMIX_ST_SRC_OUTFILT1R_SHIFT,\t\t\\\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT),\t\\\n\tSOC_DAPM_SINGLE(\"Sidetone Switch\", reg,\t\t\t\t\\\n\t\t\tDA7219_DMIX_ST_SRC_SIDETONE_SHIFT,\t\t\\\n\t\t\tDA7219_SWITCH_EN_MAX, DA7219_NO_INVERT)\t\t\\\n\nstatic const struct snd_kcontrol_new da7219_st_out_filtl_mix_controls[] = {\n\tDA7219_DMIX_ST_CTRLS(DA7219_DROUTING_ST_OUTFILT_1L),\n};\n\nstatic const struct snd_kcontrol_new da7219_st_out_filtr_mix_controls[] = {\n\tDA7219_DMIX_ST_CTRLS(DA7219_DROUTING_ST_OUTFILT_1R),\n};\n\n\n \n\nstatic int da7219_mic_pga_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (da7219->micbias_on_event) {\n\t\t\t \n\t\t\tda7219->micbias_on_event = false;\n\t\t\tmsleep(da7219->mic_pga_delay);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int da7219_dai_event(struct snd_soc_dapm_widget *w,\n\t\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct clk *bclk = da7219->dai_clks[DA7219_DAI_BCLK_IDX];\n\tu8 pll_ctrl, pll_status;\n\tint i = 0, ret;\n\tbool srm_lock = false;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (da7219->master) {\n\t\t\t \n\t\t\tif (bclk) {\n\t\t\t\tret = clk_prepare_enable(bclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable DAI clks\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t\t      DA7219_DAI_CLK_MODE,\n\t\t\t\t\t\t\t      DA7219_DAI_CLK_EN_MASK,\n\t\t\t\t\t\t\t      DA7219_DAI_CLK_EN_MASK);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7219_PC_COUNT,\n\t\t\t\t    DA7219_PC_FREERUN_MASK, 0);\n\n\t\t \n\t\tpll_ctrl = snd_soc_component_read(component, DA7219_PLL_CTRL);\n\t\tif ((pll_ctrl & DA7219_PLL_MODE_MASK) != DA7219_PLL_MODE_SRM)\n\t\t\treturn 0;\n\n\t\t \n\t\tdo {\n\t\t\tpll_status = snd_soc_component_read(component, DA7219_PLL_SRM_STS);\n\t\t\tif (pll_status & DA7219_PLL_SRM_STS_SRM_LOCK) {\n\t\t\t\tsrm_lock = true;\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t\tmsleep(50);\n\t\t\t}\n\t\t} while ((i < DA7219_SRM_CHECK_RETRIES) && (!srm_lock));\n\n\t\tif (!srm_lock)\n\t\t\tdev_warn(component->dev, \"SRM failed to lock\\n\");\n\n\t\treturn 0;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tsnd_soc_component_update_bits(component, DA7219_PC_COUNT,\n\t\t\t\t    DA7219_PC_FREERUN_MASK,\n\t\t\t\t    DA7219_PC_FREERUN_MASK);\n\n\t\t \n\t\tif (da7219->master) {\n\t\t\tif (bclk)\n\t\t\t\tclk_disable_unprepare(bclk);\n\t\t\telse\n\t\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\t\t\t\t      DA7219_DAI_CLK_MODE,\n\t\t\t\t\t\t\t      DA7219_DAI_CLK_EN_MASK,\n\t\t\t\t\t\t\t      0);\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int da7219_settling_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tmsleep(DA7219_SETTLING_DELAY);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int da7219_mixout_event(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu8 hp_ctrl, min_gain_mask;\n\n\tswitch (w->reg) {\n\tcase DA7219_MIXOUT_L_CTRL:\n\t\thp_ctrl = DA7219_HP_L_CTRL;\n\t\tmin_gain_mask = DA7219_HP_L_AMP_MIN_GAIN_EN_MASK;\n\t\tbreak;\n\tcase DA7219_MIXOUT_R_CTRL:\n\t\thp_ctrl = DA7219_HP_R_CTRL;\n\t\tmin_gain_mask = DA7219_HP_R_AMP_MIN_GAIN_EN_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\t \n\t\tsnd_soc_component_update_bits(component, hp_ctrl, min_gain_mask,\n\t\t\t\t    min_gain_mask);\n\n\t\tmsleep(DA7219_MIN_GAIN_DELAY);\n\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, hp_ctrl, min_gain_mask, 0);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int da7219_gain_ramp_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\t \n\t\tda7219->gain_ramp_ctrl =\n\t\t\tsnd_soc_component_read(component, DA7219_GAIN_RAMP_CTRL);\n\t\tsnd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL,\n\t\t\t      DA7219_GAIN_RAMP_RATE_NOMINAL);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tsnd_soc_component_write(component, DA7219_GAIN_RAMP_CTRL,\n\t\t\t      da7219->gain_ramp_ctrl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic const struct snd_soc_dapm_widget da7219_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", DA7219_MICBIAS_CTRL,\n\t\t\t    DA7219_MICBIAS1_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"MIC\"),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"Mic PGA\", DA7219_MIC_1_CTRL,\n\t\t\t   DA7219_MIC_1_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   NULL, 0, da7219_mic_pga_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_PGA_E(\"Mixin PGA\", DA7219_MIXIN_L_CTRL,\n\t\t\t   DA7219_MIXIN_L_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   NULL, 0, da7219_settling_event, SND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC\", NULL, DA7219_ADC_L_CTRL, DA7219_ADC_L_EN_SHIFT,\n\t\t\t DA7219_NO_INVERT),\n\n\t \n\tSND_SOC_DAPM_SIGGEN(\"TONE\"),\n\tSND_SOC_DAPM_PGA(\"Tone Generator\", DA7219_TONE_GEN_CFG1,\n\t\t\t DA7219_START_STOPN_SHIFT, DA7219_NO_INVERT, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"Sidetone Filter\", NULL, DA7219_SIDETONE_CTRL,\n\t\t\t DA7219_SIDETONE_EN_SHIFT, DA7219_NO_INVERT),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Mixer In Supply\", DA7219_MIXIN_L_CTRL,\n\t\t\t    DA7219_MIXIN_L_MIX_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t    NULL, 0),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Mixer In\", SND_SOC_NOPM, 0, 0,\n\t\t\t   da7219_mixin_controls,\n\t\t\t   ARRAY_SIZE(da7219_mixin_controls)),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Out DAIL Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7219_out_dail_sel_mux),\n\tSND_SOC_DAPM_MUX(\"Out DAIR Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7219_out_dair_sel_mux),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"DAI\", DA7219_DAI_CTRL, DA7219_DAI_EN_SHIFT,\n\t\t\t    DA7219_NO_INVERT, da7219_dai_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"DAIOUT\", \"Capture\", 0, DA7219_DAI_TDM_CTRL,\n\t\t\t     DA7219_DAI_OE_SHIFT, DA7219_NO_INVERT),\n\tSND_SOC_DAPM_AIF_IN(\"DAIIN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Out DACL Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7219_out_dacl_sel_mux),\n\tSND_SOC_DAPM_MUX(\"Out DACR Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t &da7219_out_dacr_sel_mux),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"Mixer Out FilterL\", SND_SOC_NOPM, 0, 0,\n\t\t\t   da7219_mixout_l_controls,\n\t\t\t   ARRAY_SIZE(da7219_mixout_l_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mixer Out FilterR\", SND_SOC_NOPM, 0, 0,\n\t\t\t   da7219_mixout_r_controls,\n\t\t\t   ARRAY_SIZE(da7219_mixout_r_controls)),\n\n\t \n\tSND_SOC_DAPM_MIXER(\"ST Mixer Out FilterL\", SND_SOC_NOPM, 0, 0,\n\t\t\t   da7219_st_out_filtl_mix_controls,\n\t\t\t   ARRAY_SIZE(da7219_st_out_filtl_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"ST Mixer Out FilterR\", SND_SOC_NOPM, 0,\n\t\t\t   0, da7219_st_out_filtr_mix_controls,\n\t\t\t   ARRAY_SIZE(da7219_st_out_filtr_mix_controls)),\n\n\t \n\tSND_SOC_DAPM_DAC_E(\"DACL\", NULL, DA7219_DAC_L_CTRL,\n\t\t\t   DA7219_DAC_L_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   da7219_settling_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DACR\", NULL, DA7219_DAC_R_CTRL,\n\t\t\t   DA7219_DAC_R_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   da7219_settling_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"Mixout Left PGA\", DA7219_MIXOUT_L_CTRL,\n\t\t\t   DA7219_MIXOUT_L_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   NULL, 0, da7219_mixout_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Mixout Right PGA\", DA7219_MIXOUT_R_CTRL,\n\t\t\t   DA7219_MIXOUT_R_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t   NULL, 0, da7219_mixout_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY_S(\"Headphone Left PGA\", 1, DA7219_HP_L_CTRL,\n\t\t\t      DA7219_HP_L_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t      da7219_settling_event,\n\t\t\t      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY_S(\"Headphone Right PGA\", 1, DA7219_HP_R_CTRL,\n\t\t\t      DA7219_HP_R_AMP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t      da7219_settling_event,\n\t\t\t      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_SUPPLY_S(\"Charge Pump\", 0, DA7219_CP_CTRL,\n\t\t\t      DA7219_CP_EN_SHIFT, DA7219_NO_INVERT,\n\t\t\t      da7219_settling_event,\n\t\t\t      SND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\n\t \n\tSND_SOC_DAPM_PRE(\"Pre Power Gain Ramp\", da7219_gain_ramp_event),\n\tSND_SOC_DAPM_POST(\"Post Power Gain Ramp\", da7219_gain_ramp_event),\n};\n\n\n \n\n#define DA7219_OUT_DAI_MUX_ROUTES(name)\t\t\t\\\n\t{name, \"ADC\", \"Mixer In\"},\t\t\t\\\n\t{name, \"Tone Generator\", \"Tone Generator\"},\t\\\n\t{name, \"DAIL\", \"DAIOUT\"},\t\t\t\\\n\t{name, \"DAIR\", \"DAIOUT\"}\n\n#define DA7219_OUT_DAC_MUX_ROUTES(name)\t\t\t\\\n\t{name, \"ADC\", \"Mixer In\"},\t\t\t\\\n\t{name, \"Tone Generator\", \"Tone Generator\"},\t\t\\\n\t{name, \"DAIL\", \"DAIIN\"},\t\t\t\\\n\t{name, \"DAIR\", \"DAIIN\"}\n\n \n\n#define DA7219_DMIX_ST_ROUTES(name)\t\t\t\t\\\n\t{name, \"Out FilterL Switch\", \"Mixer Out FilterL\"},\t\\\n\t{name, \"Out FilterR Switch\", \"Mixer Out FilterR\"},\t\\\n\t{name, \"Sidetone Switch\", \"Sidetone Filter\"}\n\n\n \n\nstatic const struct snd_soc_dapm_route da7219_audio_map[] = {\n\t \n\t{\"MIC\", NULL, \"Mic Bias\"},\n\t{\"Mic PGA\", NULL, \"MIC\"},\n\t{\"Mixin PGA\", NULL, \"Mic PGA\"},\n\t{\"ADC\", NULL, \"Mixin PGA\"},\n\n\t{\"Mixer In\", NULL, \"Mixer In Supply\"},\n\t{\"Mixer In\", \"Mic Switch\", \"ADC\"},\n\n\t{\"Sidetone Filter\", NULL, \"Mixer In\"},\n\n\t{\"Tone Generator\", NULL, \"TONE\"},\n\n\tDA7219_OUT_DAI_MUX_ROUTES(\"Out DAIL Mux\"),\n\tDA7219_OUT_DAI_MUX_ROUTES(\"Out DAIR Mux\"),\n\n\t{\"DAIOUT\", NULL, \"Out DAIL Mux\"},\n\t{\"DAIOUT\", NULL, \"Out DAIR Mux\"},\n\t{\"DAIOUT\", NULL, \"DAI\"},\n\n\t \n\t{\"DAIIN\", NULL, \"DAI\"},\n\n\tDA7219_OUT_DAC_MUX_ROUTES(\"Out DACL Mux\"),\n\tDA7219_OUT_DAC_MUX_ROUTES(\"Out DACR Mux\"),\n\n\t{\"Mixer Out FilterL\", \"DACL Switch\", \"Out DACL Mux\"},\n\t{\"Mixer Out FilterR\", \"DACR Switch\", \"Out DACR Mux\"},\n\n\tDA7219_DMIX_ST_ROUTES(\"ST Mixer Out FilterL\"),\n\tDA7219_DMIX_ST_ROUTES(\"ST Mixer Out FilterR\"),\n\n\t{\"DACL\", NULL, \"ST Mixer Out FilterL\"},\n\t{\"DACR\", NULL, \"ST Mixer Out FilterR\"},\n\n\t{\"Mixout Left PGA\", NULL, \"DACL\"},\n\t{\"Mixout Right PGA\", NULL, \"DACR\"},\n\n\t{\"HPL\", NULL, \"Mixout Left PGA\"},\n\t{\"HPR\", NULL, \"Mixout Right PGA\"},\n\n\t{\"HPL\", NULL, \"Headphone Left PGA\"},\n\t{\"HPR\", NULL, \"Headphone Right PGA\"},\n\n\t{\"HPL\", NULL, \"Charge Pump\"},\n\t{\"HPR\", NULL, \"Charge Pump\"},\n};\n\n\n \n\nstatic int da7219_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif ((da7219->clk_src == clk_id) && (da7219->mclk_rate == freq))\n\t\treturn 0;\n\n\tif ((freq < 2000000) || (freq > 54000000)) {\n\t\tdev_err(codec_dai->dev, \"Unsupported MCLK value %d\\n\",\n\t\t\tfreq);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&da7219->pll_lock);\n\n\tswitch (clk_id) {\n\tcase DA7219_CLKSRC_MCLK_SQR:\n\t\tsnd_soc_component_update_bits(component, DA7219_PLL_CTRL,\n\t\t\t\t    DA7219_PLL_MCLK_SQR_EN_MASK,\n\t\t\t\t    DA7219_PLL_MCLK_SQR_EN_MASK);\n\t\tbreak;\n\tcase DA7219_CLKSRC_MCLK:\n\t\tsnd_soc_component_update_bits(component, DA7219_PLL_CTRL,\n\t\t\t\t    DA7219_PLL_MCLK_SQR_EN_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(codec_dai->dev, \"Unknown clock source %d\\n\", clk_id);\n\t\tmutex_unlock(&da7219->pll_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tda7219->clk_src = clk_id;\n\n\tif (da7219->mclk) {\n\t\tfreq = clk_round_rate(da7219->mclk, freq);\n\t\tret = clk_set_rate(da7219->mclk, freq);\n\t\tif (ret) {\n\t\t\tdev_err(codec_dai->dev, \"Failed to set clock rate %d\\n\",\n\t\t\t\tfreq);\n\t\t\tmutex_unlock(&da7219->pll_lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tda7219->mclk_rate = freq;\n\n\tmutex_unlock(&da7219->pll_lock);\n\n\treturn 0;\n}\n\nint da7219_set_pll(struct snd_soc_component *component, int source, unsigned int fout)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tu8 pll_ctrl, indiv_bits, indiv;\n\tu8 pll_frac_top, pll_frac_bot, pll_integer;\n\tu32 freq_ref;\n\tu64 frac_div;\n\n\t \n\tif (da7219->mclk_rate < 2000000) {\n\t\tdev_err(component->dev, \"PLL input clock %d below valid range\\n\",\n\t\t\tda7219->mclk_rate);\n\t\treturn -EINVAL;\n\t} else if (da7219->mclk_rate <= 4500000) {\n\t\tindiv_bits = DA7219_PLL_INDIV_2_TO_4_5_MHZ;\n\t\tindiv = DA7219_PLL_INDIV_2_TO_4_5_MHZ_VAL;\n\t} else if (da7219->mclk_rate <= 9000000) {\n\t\tindiv_bits = DA7219_PLL_INDIV_4_5_TO_9_MHZ;\n\t\tindiv = DA7219_PLL_INDIV_4_5_TO_9_MHZ_VAL;\n\t} else if (da7219->mclk_rate <= 18000000) {\n\t\tindiv_bits = DA7219_PLL_INDIV_9_TO_18_MHZ;\n\t\tindiv = DA7219_PLL_INDIV_9_TO_18_MHZ_VAL;\n\t} else if (da7219->mclk_rate <= 36000000) {\n\t\tindiv_bits = DA7219_PLL_INDIV_18_TO_36_MHZ;\n\t\tindiv = DA7219_PLL_INDIV_18_TO_36_MHZ_VAL;\n\t} else if (da7219->mclk_rate <= 54000000) {\n\t\tindiv_bits = DA7219_PLL_INDIV_36_TO_54_MHZ;\n\t\tindiv = DA7219_PLL_INDIV_36_TO_54_MHZ_VAL;\n\t} else {\n\t\tdev_err(component->dev, \"PLL input clock %d above valid range\\n\",\n\t\t\tda7219->mclk_rate);\n\t\treturn -EINVAL;\n\t}\n\tfreq_ref = (da7219->mclk_rate / indiv);\n\tpll_ctrl = indiv_bits;\n\n\t \n\tswitch (source) {\n\tcase DA7219_SYSCLK_MCLK:\n\t\tpll_ctrl |= DA7219_PLL_MODE_BYPASS;\n\t\tsnd_soc_component_update_bits(component, DA7219_PLL_CTRL,\n\t\t\t\t    DA7219_PLL_INDIV_MASK |\n\t\t\t\t    DA7219_PLL_MODE_MASK, pll_ctrl);\n\t\treturn 0;\n\tcase DA7219_SYSCLK_PLL:\n\t\tpll_ctrl |= DA7219_PLL_MODE_NORMAL;\n\t\tbreak;\n\tcase DA7219_SYSCLK_PLL_SRM:\n\t\tpll_ctrl |= DA7219_PLL_MODE_SRM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid PLL config\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpll_integer = fout / freq_ref;\n\tfrac_div = (u64)(fout % freq_ref) * 8192ULL;\n\tdo_div(frac_div, freq_ref);\n\tpll_frac_top = (frac_div >> DA7219_BYTE_SHIFT) & DA7219_BYTE_MASK;\n\tpll_frac_bot = (frac_div) & DA7219_BYTE_MASK;\n\n\t \n\tsnd_soc_component_write(component, DA7219_PLL_FRAC_TOP, pll_frac_top);\n\tsnd_soc_component_write(component, DA7219_PLL_FRAC_BOT, pll_frac_bot);\n\tsnd_soc_component_write(component, DA7219_PLL_INTEGER, pll_integer);\n\tsnd_soc_component_update_bits(component, DA7219_PLL_CTRL,\n\t\t\t    DA7219_PLL_INDIV_MASK | DA7219_PLL_MODE_MASK,\n\t\t\t    pll_ctrl);\n\n\treturn 0;\n}\n\nstatic int da7219_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\t\t      int source, unsigned int fref, unsigned int fout)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_lock(&da7219->pll_lock);\n\tret = da7219_set_pll(component, source, fout);\n\tmutex_unlock(&da7219->pll_lock);\n\n\treturn ret;\n}\n\nstatic int da7219_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tu8 dai_clk_mode = 0, dai_ctrl = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tda7219->master = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tda7219->master = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tdai_clk_mode |= DA7219_DAI_WCLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tdai_clk_mode |= DA7219_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tdai_clk_mode |= DA7219_DAI_WCLK_POL_INV |\n\t\t\t\t\tDA7219_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tdai_clk_mode |= DA7219_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tdai_clk_mode |= DA7219_DAI_WCLK_POL_INV |\n\t\t\t\t\tDA7219_DAI_CLK_POL_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tdai_clk_mode |= DA7219_DAI_WCLK_POL_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdai_ctrl |= DA7219_DAI_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdai_ctrl |= DA7219_DAI_FORMAT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdai_ctrl |= DA7219_DAI_FORMAT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tdai_ctrl |= DA7219_DAI_FORMAT_DSP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,\n\t\t\t    DA7219_DAI_CLK_POL_MASK | DA7219_DAI_WCLK_POL_MASK,\n\t\t\t    dai_clk_mode);\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CTRL, DA7219_DAI_FORMAT_MASK,\n\t\t\t    dai_ctrl);\n\n\treturn 0;\n}\n\nstatic int da7219_set_bclks_per_wclk(struct snd_soc_component *component,\n\t\t\t\t     unsigned long factor)\n{\n\tu8 bclks_per_wclk;\n\n\tswitch (factor) {\n\tcase 32:\n\t\tbclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_32;\n\t\tbreak;\n\tcase 64:\n\t\tbclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_64;\n\t\tbreak;\n\tcase 128:\n\t\tbclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_128;\n\t\tbreak;\n\tcase 256:\n\t\tbclks_per_wclk = DA7219_DAI_BCLKS_PER_WCLK_256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,\n\t\t\t\t      DA7219_DAI_BCLKS_PER_WCLK_MASK,\n\t\t\t\t      bclks_per_wclk);\n\n\treturn 0;\n}\n\nstatic int da7219_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t   unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t   int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct clk *wclk = da7219->dai_clks[DA7219_DAI_WCLK_IDX];\n\tstruct clk *bclk = da7219->dai_clks[DA7219_DAI_BCLK_IDX];\n\tunsigned int ch_mask;\n\tunsigned long sr, bclk_rate;\n\tu8 slot_offset;\n\tu16 offset;\n\t__le16 dai_offset;\n\tu32 frame_size;\n\tint ret;\n\n\t \n\tif (!tx_mask) {\n\t\tsnd_soc_component_update_bits(component, DA7219_DAI_TDM_CTRL,\n\t\t\t\t    DA7219_DAI_TDM_CH_EN_MASK |\n\t\t\t\t    DA7219_DAI_TDM_MODE_EN_MASK, 0);\n\t\tda7219->tdm_en = false;\n\t\treturn 0;\n\t}\n\n\t \n\tslot_offset = ffs(tx_mask) - 1;\n\tch_mask = (tx_mask >> slot_offset);\n\tif (fls(ch_mask) > DA7219_DAI_TDM_MAX_SLOTS) {\n\t\tdev_err(component->dev,\n\t\t\t\"Invalid number of slots, max = %d\\n\",\n\t\t\tDA7219_DAI_TDM_MAX_SLOTS);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\toffset = slot_offset * slot_width;\n\tif (offset > DA7219_DAI_OFFSET_MAX) {\n\t\tdev_err(component->dev, \"Invalid frame offset %d\\n\", offset);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (da7219->master) {\n\t\tframe_size = slots * slot_width;\n\n\t\tif (bclk) {\n\t\t\tsr = clk_get_rate(wclk);\n\t\t\tbclk_rate = sr * frame_size;\n\t\t\tret = clk_set_rate(bclk, bclk_rate);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to set TDM BCLK rate %lu: %d\\n\",\n\t\t\t\t\tbclk_rate, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = da7219_set_bclks_per_wclk(component, frame_size);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to set TDM BCLKs per WCLK %d: %d\\n\",\n\t\t\t\t\tframe_size, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tdai_offset = cpu_to_le16(offset);\n\tregmap_bulk_write(da7219->regmap, DA7219_DAI_OFFSET_LOWER,\n\t\t\t  &dai_offset, sizeof(dai_offset));\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_TDM_CTRL,\n\t\t\t    DA7219_DAI_TDM_CH_EN_MASK |\n\t\t\t    DA7219_DAI_TDM_MODE_EN_MASK,\n\t\t\t    (ch_mask << DA7219_DAI_TDM_CH_EN_SHIFT) |\n\t\t\t    DA7219_DAI_TDM_MODE_EN_MASK);\n\n\tda7219->tdm_en = true;\n\n\treturn 0;\n}\n\nstatic int da7219_set_sr(struct snd_soc_component *component,\n\t\t\t unsigned long rate)\n{\n\tu8 fs;\n\n\tswitch (rate) {\n\tcase 8000:\n\t\tfs = DA7219_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tfs = DA7219_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tfs = DA7219_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tfs = DA7219_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tfs = DA7219_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tfs = DA7219_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tfs = DA7219_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tfs = DA7219_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tfs = DA7219_SR_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tfs = DA7219_SR_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tfs = DA7219_SR_96000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, DA7219_SR, fs);\n\n\treturn 0;\n}\n\nstatic int da7219_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct clk *wclk = da7219->dai_clks[DA7219_DAI_WCLK_IDX];\n\tstruct clk *bclk = da7219->dai_clks[DA7219_DAI_BCLK_IDX];\n\tu8 dai_ctrl = 0;\n\tunsigned int channels;\n\tunsigned long sr, bclk_rate;\n\tint word_len = params_width(params);\n\tint frame_size, ret;\n\n\tswitch (word_len) {\n\tcase 16:\n\t\tdai_ctrl |= DA7219_DAI_WORD_LENGTH_S16_LE;\n\t\tbreak;\n\tcase 20:\n\t\tdai_ctrl |= DA7219_DAI_WORD_LENGTH_S20_LE;\n\t\tbreak;\n\tcase 24:\n\t\tdai_ctrl |= DA7219_DAI_WORD_LENGTH_S24_LE;\n\t\tbreak;\n\tcase 32:\n\t\tdai_ctrl |= DA7219_DAI_WORD_LENGTH_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchannels = params_channels(params);\n\tif ((channels < 1) || (channels > DA7219_DAI_CH_NUM_MAX)) {\n\t\tdev_err(component->dev,\n\t\t\t\"Invalid number of channels, only 1 to %d supported\\n\",\n\t\t\tDA7219_DAI_CH_NUM_MAX);\n\t\treturn -EINVAL;\n\t}\n\tdai_ctrl |= channels << DA7219_DAI_CH_NUM_SHIFT;\n\n\tsr = params_rate(params);\n\tif (da7219->master && wclk) {\n\t\tret = clk_set_rate(wclk, sr);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set WCLK SR %lu: %d\\n\", sr, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = da7219_set_sr(component, sr);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set SR %lu: %d\\n\", sr, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (da7219->master && !da7219->tdm_en) {\n\t\tif ((word_len * DA7219_DAI_CH_NUM_MAX) <= 32)\n\t\t\tframe_size = 32;\n\t\telse\n\t\t\tframe_size = 64;\n\n\t\tif (bclk) {\n\t\t\tbclk_rate = frame_size * sr;\n\t\t\t \n\t\t\tbclk_rate = clk_round_rate(bclk, bclk_rate);\n\t\t\tif ((bclk_rate / sr) < frame_size) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"BCLK rate mismatch against frame size\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tret = clk_set_rate(bclk, bclk_rate);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to set BCLK rate %lu: %d\\n\",\n\t\t\t\t\tbclk_rate, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = da7219_set_bclks_per_wclk(component, frame_size);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to set BCLKs per WCLK %d: %d\\n\",\n\t\t\t\t\tframe_size, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CTRL,\n\t\t\t    DA7219_DAI_WORD_LENGTH_MASK |\n\t\t\t    DA7219_DAI_CH_NUM_MASK,\n\t\t\t    dai_ctrl);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops da7219_dai_ops = {\n\t.hw_params\t= da7219_hw_params,\n\t.set_sysclk\t= da7219_set_dai_sysclk,\n\t.set_pll\t= da7219_set_dai_pll,\n\t.set_fmt\t= da7219_set_dai_fmt,\n\t.set_tdm_slot\t= da7219_set_dai_tdm_slot,\n};\n\n#define DA7219_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\n#define DA7219_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\t      SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\t      SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\\\n\t\t      SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\\\n\t\t      SNDRV_PCM_RATE_96000)\n\nstatic struct snd_soc_dai_driver da7219_dai = {\n\t.name = \"da7219-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = DA7219_DAI_CH_NUM_MAX,\n\t\t.rates = DA7219_RATES,\n\t\t.formats = DA7219_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = DA7219_DAI_CH_NUM_MAX,\n\t\t.rates = DA7219_RATES,\n\t\t.formats = DA7219_FORMATS,\n\t},\n\t.ops = &da7219_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_channels = 1,\n\t.symmetric_sample_bits = 1,\n};\n\n\n \n\n#ifdef CONFIG_OF\nstatic const struct of_device_id da7219_of_match[] = {\n\t{ .compatible = \"dlg,da7219\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da7219_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id da7219_acpi_match[] = {\n\t{ .id = \"DLGS7219\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, da7219_acpi_match);\n#endif\n\nstatic enum da7219_micbias_voltage\n\tda7219_fw_micbias_lvl(struct device *dev, u32 val)\n{\n\tswitch (val) {\n\tcase 1600:\n\t\treturn DA7219_MICBIAS_1_6V;\n\tcase 1800:\n\t\treturn DA7219_MICBIAS_1_8V;\n\tcase 2000:\n\t\treturn DA7219_MICBIAS_2_0V;\n\tcase 2200:\n\t\treturn DA7219_MICBIAS_2_2V;\n\tcase 2400:\n\t\treturn DA7219_MICBIAS_2_4V;\n\tcase 2600:\n\t\treturn DA7219_MICBIAS_2_6V;\n\tdefault:\n\t\tdev_warn(dev, \"Invalid micbias level\");\n\t\treturn DA7219_MICBIAS_2_2V;\n\t}\n}\n\nstatic enum da7219_mic_amp_in_sel\n\tda7219_fw_mic_amp_in_sel(struct device *dev, const char *str)\n{\n\tif (!strcmp(str, \"diff\")) {\n\t\treturn DA7219_MIC_AMP_IN_SEL_DIFF;\n\t} else if (!strcmp(str, \"se_p\")) {\n\t\treturn DA7219_MIC_AMP_IN_SEL_SE_P;\n\t} else if (!strcmp(str, \"se_n\")) {\n\t\treturn DA7219_MIC_AMP_IN_SEL_SE_N;\n\t} else {\n\t\tdev_warn(dev, \"Invalid mic input type selection\");\n\t\treturn DA7219_MIC_AMP_IN_SEL_DIFF;\n\t}\n}\n\nstatic struct da7219_pdata *da7219_fw_to_pdata(struct device *dev)\n{\n\tstruct da7219_pdata *pdata;\n\tconst char *of_str;\n\tu32 of_val32;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tpdata->wakeup_source = device_property_read_bool(dev, \"wakeup-source\");\n\n\tpdata->dai_clk_names[DA7219_DAI_WCLK_IDX] = \"da7219-dai-wclk\";\n\tpdata->dai_clk_names[DA7219_DAI_BCLK_IDX] = \"da7219-dai-bclk\";\n\tif (device_property_read_string_array(dev, \"clock-output-names\",\n\t\t\t\t\t      pdata->dai_clk_names,\n\t\t\t\t\t      DA7219_DAI_NUM_CLKS) < 0)\n\t\tdev_warn(dev, \"Using default DAI clk names: %s, %s\\n\",\n\t\t\t pdata->dai_clk_names[DA7219_DAI_WCLK_IDX],\n\t\t\t pdata->dai_clk_names[DA7219_DAI_BCLK_IDX]);\n\n\tif (device_property_read_u32(dev, \"dlg,micbias-lvl\", &of_val32) >= 0)\n\t\tpdata->micbias_lvl = da7219_fw_micbias_lvl(dev, of_val32);\n\telse\n\t\tpdata->micbias_lvl = DA7219_MICBIAS_2_2V;\n\n\tif (!device_property_read_string(dev, \"dlg,mic-amp-in-sel\", &of_str))\n\t\tpdata->mic_amp_in_sel = da7219_fw_mic_amp_in_sel(dev, of_str);\n\telse\n\t\tpdata->mic_amp_in_sel = DA7219_MIC_AMP_IN_SEL_DIFF;\n\n\treturn pdata;\n}\n\n\n \n\nstatic int da7219_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_STANDBY) {\n\t\t\tif (da7219->mclk) {\n\t\t\t\tret = clk_prepare_enable(da7219->mclk);\n\t\t\t\tif (ret) {\n\t\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\t\"Failed to enable mclk\\n\");\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, DA7219_REFERENCES,\n\t\t\t\t\t    DA7219_BIAS_EN_MASK,\n\t\t\t\t\t    DA7219_BIAS_EN_MASK);\n\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE) {\n\t\t\t \n\t\t\tif (da7219->mclk)\n\t\t\t\tclk_disable_unprepare(da7219->mclk);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tif (!da7219->wakeup_source)\n\t\t\tsnd_soc_component_update_bits(component, DA7219_REFERENCES,\n\t\t\t\t\t    DA7219_BIAS_EN_MASK, 0);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *da7219_supply_names[DA7219_NUM_SUPPLIES] = {\n\t[DA7219_SUPPLY_VDD] = \"VDD\",\n\t[DA7219_SUPPLY_VDDMIC] = \"VDDMIC\",\n\t[DA7219_SUPPLY_VDDIO] = \"VDDIO\",\n};\n\nstatic int da7219_handle_supplies(struct snd_soc_component *component,\n\t\t\t\t  u8 *io_voltage_lvl)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct regulator *vddio;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < DA7219_NUM_SUPPLIES; ++i)\n\t\tda7219->supplies[i].supply = da7219_supply_names[i];\n\n\tret = regulator_bulk_get(component->dev, DA7219_NUM_SUPPLIES,\n\t\t\t\t da7219->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to get supplies\");\n\t\treturn ret;\n\t}\n\n\t \n\t*io_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_2_5V_3_6V;\n\n\t \n\tvddio = da7219->supplies[DA7219_SUPPLY_VDDIO].consumer;\n\tret = regulator_get_voltage(vddio);\n\tif (ret < 1200000)\n\t\tdev_warn(component->dev, \"Invalid VDDIO voltage\\n\");\n\telse if (ret < 2800000)\n\t\t*io_voltage_lvl = DA7219_IO_VOLTAGE_LEVEL_1_2V_2_8V;\n\n\t \n\tret = regulator_bulk_enable(DA7219_NUM_SUPPLIES, da7219->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to enable supplies\");\n\t\tregulator_bulk_free(DA7219_NUM_SUPPLIES, da7219->supplies);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_COMMON_CLK\nstatic int da7219_wclk_prepare(struct clk_hw *hw)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\n\tif (!da7219->master)\n\t\treturn -EINVAL;\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,\n\t\t\t\t      DA7219_DAI_CLK_EN_MASK,\n\t\t\t\t      DA7219_DAI_CLK_EN_MASK);\n\n\treturn 0;\n}\n\nstatic void da7219_wclk_unprepare(struct clk_hw *hw)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\n\tif (!da7219->master)\n\t\treturn;\n\n\tsnd_soc_component_update_bits(component, DA7219_DAI_CLK_MODE,\n\t\t\t\t      DA7219_DAI_CLK_EN_MASK, 0);\n}\n\nstatic int da7219_wclk_is_prepared(struct clk_hw *hw)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\tu8 clk_reg;\n\n\tif (!da7219->master)\n\t\treturn -EINVAL;\n\n\tclk_reg = snd_soc_component_read(component, DA7219_DAI_CLK_MODE);\n\n\treturn !!(clk_reg & DA7219_DAI_CLK_EN_MASK);\n}\n\nstatic unsigned long da7219_wclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\tu8 fs = snd_soc_component_read(component, DA7219_SR);\n\n\tswitch (fs & DA7219_SR_MASK) {\n\tcase DA7219_SR_8000:\n\t\treturn 8000;\n\tcase DA7219_SR_11025:\n\t\treturn 11025;\n\tcase DA7219_SR_12000:\n\t\treturn 12000;\n\tcase DA7219_SR_16000:\n\t\treturn 16000;\n\tcase DA7219_SR_22050:\n\t\treturn 22050;\n\tcase DA7219_SR_24000:\n\t\treturn 24000;\n\tcase DA7219_SR_32000:\n\t\treturn 32000;\n\tcase DA7219_SR_44100:\n\t\treturn 44100;\n\tcase DA7219_SR_48000:\n\t\treturn 48000;\n\tcase DA7219_SR_88200:\n\t\treturn 88200;\n\tcase DA7219_SR_96000:\n\t\treturn 96000;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic long da7219_wclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\n\tif (!da7219->master)\n\t\treturn -EINVAL;\n\n\tif (rate < 11025)\n\t\treturn 8000;\n\telse if (rate < 12000)\n\t\treturn 11025;\n\telse if (rate < 16000)\n\t\treturn 12000;\n\telse if (rate < 22050)\n\t\treturn 16000;\n\telse if (rate < 24000)\n\t\treturn 22050;\n\telse if (rate < 32000)\n\t\treturn 24000;\n\telse if (rate < 44100)\n\t\treturn 32000;\n\telse if (rate < 48000)\n\t\treturn 44100;\n\telse if (rate < 88200)\n\t\treturn 48000;\n\telse if (rate < 96000)\n\t\treturn 88200;\n\telse\n\t\treturn 96000;\n}\n\nstatic int da7219_wclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_WCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\n\tif (!da7219->master)\n\t\treturn -EINVAL;\n\n\treturn da7219_set_sr(component, rate);\n}\n\nstatic unsigned long da7219_bclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t     unsigned long parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_BCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\tu8 bclks_per_wclk = snd_soc_component_read(component,\n\t\t\t\t\t\t     DA7219_DAI_CLK_MODE);\n\n\tswitch (bclks_per_wclk & DA7219_DAI_BCLKS_PER_WCLK_MASK) {\n\tcase DA7219_DAI_BCLKS_PER_WCLK_32:\n\t\treturn parent_rate * 32;\n\tcase DA7219_DAI_BCLKS_PER_WCLK_64:\n\t\treturn parent_rate * 64;\n\tcase DA7219_DAI_BCLKS_PER_WCLK_128:\n\t\treturn parent_rate * 128;\n\tcase DA7219_DAI_BCLKS_PER_WCLK_256:\n\t\treturn parent_rate * 256;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic unsigned long da7219_bclk_get_factor(unsigned long rate,\n\t\t\t\t\t    unsigned long parent_rate)\n{\n\tunsigned long factor;\n\n\tfactor = rate / parent_rate;\n\tif (factor < 64)\n\t\treturn 32;\n\telse if (factor < 128)\n\t\treturn 64;\n\telse if (factor < 256)\n\t\treturn 128;\n\telse\n\t\treturn 256;\n}\n\nstatic long da7219_bclk_round_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\t   unsigned long *parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_BCLK_IDX]);\n\tunsigned long factor;\n\n\tif (!*parent_rate || !da7219->master)\n\t\treturn -EINVAL;\n\n\t \n\tfactor = da7219_bclk_get_factor(rate, *parent_rate);\n\n\treturn *parent_rate * factor;\n}\n\nstatic int da7219_bclk_set_rate(struct clk_hw *hw, unsigned long rate,\n\t\t\t\tunsigned long parent_rate)\n{\n\tstruct da7219_priv *da7219 =\n\t\tcontainer_of(hw, struct da7219_priv,\n\t\t\t     dai_clks_hw[DA7219_DAI_BCLK_IDX]);\n\tstruct snd_soc_component *component = da7219->component;\n\tunsigned long factor;\n\n\tif (!da7219->master)\n\t\treturn -EINVAL;\n\n\tfactor = da7219_bclk_get_factor(rate, parent_rate);\n\n\treturn da7219_set_bclks_per_wclk(component, factor);\n}\n\nstatic const struct clk_ops da7219_dai_clk_ops[DA7219_DAI_NUM_CLKS] = {\n\t[DA7219_DAI_WCLK_IDX] = {\n\t\t.prepare = da7219_wclk_prepare,\n\t\t.unprepare = da7219_wclk_unprepare,\n\t\t.is_prepared = da7219_wclk_is_prepared,\n\t\t.recalc_rate = da7219_wclk_recalc_rate,\n\t\t.round_rate = da7219_wclk_round_rate,\n\t\t.set_rate = da7219_wclk_set_rate,\n\t},\n\t[DA7219_DAI_BCLK_IDX] = {\n\t\t.recalc_rate = da7219_bclk_recalc_rate,\n\t\t.round_rate = da7219_bclk_round_rate,\n\t\t.set_rate = da7219_bclk_set_rate,\n\t},\n};\n\nstatic int da7219_register_dai_clks(struct snd_soc_component *component)\n{\n\tstruct device *dev = component->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_pdata *pdata = da7219->pdata;\n\tconst char *parent_name;\n\tstruct clk_hw_onecell_data *clk_data;\n\tint i, ret;\n\n\t \n\tif (np) {\n\t\tclk_data = kzalloc(struct_size(clk_data, hws, DA7219_DAI_NUM_CLKS),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!clk_data)\n\t\t\treturn -ENOMEM;\n\n\t\tclk_data->num = DA7219_DAI_NUM_CLKS;\n\t\tda7219->clk_hw_data = clk_data;\n\t}\n\n\tfor (i = 0; i < DA7219_DAI_NUM_CLKS; ++i) {\n\t\tstruct clk_init_data init = {};\n\t\tstruct clk_lookup *dai_clk_lookup;\n\t\tstruct clk_hw *dai_clk_hw = &da7219->dai_clks_hw[i];\n\n\t\tswitch (i) {\n\t\tcase DA7219_DAI_WCLK_IDX:\n\t\t\t \n\t\t\tif (da7219->mclk) {\n\t\t\t\tparent_name = __clk_get_name(da7219->mclk);\n\t\t\t\tinit.parent_names = &parent_name;\n\t\t\t\tinit.num_parents = 1;\n\t\t\t} else {\n\t\t\t\tinit.parent_names = NULL;\n\t\t\t\tinit.num_parents = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DA7219_DAI_BCLK_IDX:\n\t\t\t \n\t\t\tparent_name = __clk_get_name(da7219->dai_clks[DA7219_DAI_WCLK_IDX]);\n\t\t\tinit.parent_names = &parent_name;\n\t\t\tinit.num_parents = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid clock index\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tinit.name = pdata->dai_clk_names[i];\n\t\tinit.ops = &da7219_dai_clk_ops[i];\n\t\tinit.flags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_GATE;\n\t\tdai_clk_hw->init = &init;\n\n\t\tret = clk_hw_register(dev, dai_clk_hw);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"Failed to register %s: %d\\n\", init.name,\n\t\t\t\t ret);\n\t\t\tgoto err;\n\t\t}\n\t\tda7219->dai_clks[i] = dai_clk_hw->clk;\n\n\t\t \n\t\tif (np) {\n\t\t\tda7219->clk_hw_data->hws[i] = dai_clk_hw;\n\t\t} else {\n\t\t\tdai_clk_lookup = clkdev_hw_create(dai_clk_hw, init.name,\n\t\t\t\t\t\t\t  \"%s\", dev_name(dev));\n\t\t\tif (!dai_clk_lookup) {\n\t\t\t\tclk_hw_unregister(dai_clk_hw);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tda7219->dai_clks_lookup[i] = dai_clk_lookup;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (np) {\n\t\tret = of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,\n\t\t\t\t\t     da7219->clk_hw_data);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to register clock provider\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\twhile (--i >= 0) {\n\t\tif (da7219->dai_clks_lookup[i])\n\t\t\tclkdev_drop(da7219->dai_clks_lookup[i]);\n\n\t\tclk_hw_unregister(&da7219->dai_clks_hw[i]);\n\t}\n\n\tif (np)\n\t\tkfree(da7219->clk_hw_data);\n\n\treturn ret;\n}\n\nstatic void da7219_free_dai_clks(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct device_node *np = component->dev->of_node;\n\tint i;\n\n\tif (np)\n\t\tof_clk_del_provider(np);\n\n\tfor (i = DA7219_DAI_NUM_CLKS - 1; i >= 0; --i) {\n\t\tif (da7219->dai_clks_lookup[i])\n\t\t\tclkdev_drop(da7219->dai_clks_lookup[i]);\n\n\t\tclk_hw_unregister(&da7219->dai_clks_hw[i]);\n\t}\n\n\tif (np)\n\t\tkfree(da7219->clk_hw_data);\n}\n#else\nstatic inline int da7219_register_dai_clks(struct snd_soc_component *component)\n{\n\treturn 0;\n}\n\nstatic void da7219_free_dai_clks(struct snd_soc_component *component) {}\n#endif  \n\nstatic void da7219_handle_pdata(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tstruct da7219_pdata *pdata = da7219->pdata;\n\n\tif (pdata) {\n\t\tu8 micbias_lvl = 0;\n\n\t\tda7219->wakeup_source = pdata->wakeup_source;\n\n\t\t \n\t\tswitch (pdata->micbias_lvl) {\n\t\tcase DA7219_MICBIAS_1_6V:\n\t\tcase DA7219_MICBIAS_1_8V:\n\t\tcase DA7219_MICBIAS_2_0V:\n\t\tcase DA7219_MICBIAS_2_2V:\n\t\tcase DA7219_MICBIAS_2_4V:\n\t\tcase DA7219_MICBIAS_2_6V:\n\t\t\tmicbias_lvl |= (pdata->micbias_lvl <<\n\t\t\t\t\tDA7219_MICBIAS1_LEVEL_SHIFT);\n\t\t\tbreak;\n\t\t}\n\n\t\tsnd_soc_component_write(component, DA7219_MICBIAS_CTRL, micbias_lvl);\n\n\t\t \n\t\tda7219->mic_pga_delay =  DA7219_MIC_PGA_BASE_DELAY +\n\t\t\t\t\t(pdata->micbias_lvl *\n\t\t\t\t\t DA7219_MIC_PGA_OFFSET_DELAY);\n\n\t\t \n\t\tswitch (pdata->mic_amp_in_sel) {\n\t\tcase DA7219_MIC_AMP_IN_SEL_DIFF:\n\t\tcase DA7219_MIC_AMP_IN_SEL_SE_P:\n\t\tcase DA7219_MIC_AMP_IN_SEL_SE_N:\n\t\t\tsnd_soc_component_write(component, DA7219_MIC_1_SELECT,\n\t\t\t\t      pdata->mic_amp_in_sel);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n \n\nstatic struct reg_default da7219_reg_defaults[] = {\n\t{ DA7219_MIC_1_SELECT, 0x00 },\n\t{ DA7219_CIF_TIMEOUT_CTRL, 0x01 },\n\t{ DA7219_SR_24_48, 0x00 },\n\t{ DA7219_SR, 0x0A },\n\t{ DA7219_CIF_I2C_ADDR_CFG, 0x02 },\n\t{ DA7219_PLL_CTRL, 0x10 },\n\t{ DA7219_PLL_FRAC_TOP, 0x00 },\n\t{ DA7219_PLL_FRAC_BOT, 0x00 },\n\t{ DA7219_PLL_INTEGER, 0x20 },\n\t{ DA7219_DIG_ROUTING_DAI, 0x10 },\n\t{ DA7219_DAI_CLK_MODE, 0x01 },\n\t{ DA7219_DAI_CTRL, 0x28 },\n\t{ DA7219_DAI_TDM_CTRL, 0x40 },\n\t{ DA7219_DIG_ROUTING_DAC, 0x32 },\n\t{ DA7219_DAI_OFFSET_LOWER, 0x00 },\n\t{ DA7219_DAI_OFFSET_UPPER, 0x00 },\n\t{ DA7219_REFERENCES, 0x08 },\n\t{ DA7219_MIXIN_L_SELECT, 0x00 },\n\t{ DA7219_MIXIN_L_GAIN, 0x03 },\n\t{ DA7219_ADC_L_GAIN, 0x6F },\n\t{ DA7219_ADC_FILTERS1, 0x80 },\n\t{ DA7219_MIC_1_GAIN, 0x01 },\n\t{ DA7219_SIDETONE_CTRL, 0x40 },\n\t{ DA7219_SIDETONE_GAIN, 0x0E },\n\t{ DA7219_DROUTING_ST_OUTFILT_1L, 0x01 },\n\t{ DA7219_DROUTING_ST_OUTFILT_1R, 0x02 },\n\t{ DA7219_DAC_FILTERS5, 0x00 },\n\t{ DA7219_DAC_FILTERS2, 0x88 },\n\t{ DA7219_DAC_FILTERS3, 0x88 },\n\t{ DA7219_DAC_FILTERS4, 0x08 },\n\t{ DA7219_DAC_FILTERS1, 0x80 },\n\t{ DA7219_DAC_L_GAIN, 0x6F },\n\t{ DA7219_DAC_R_GAIN, 0x6F },\n\t{ DA7219_CP_CTRL, 0x20 },\n\t{ DA7219_HP_L_GAIN, 0x39 },\n\t{ DA7219_HP_R_GAIN, 0x39 },\n\t{ DA7219_MIXOUT_L_SELECT, 0x00 },\n\t{ DA7219_MIXOUT_R_SELECT, 0x00 },\n\t{ DA7219_MICBIAS_CTRL, 0x03 },\n\t{ DA7219_MIC_1_CTRL, 0x40 },\n\t{ DA7219_MIXIN_L_CTRL, 0x40 },\n\t{ DA7219_ADC_L_CTRL, 0x40 },\n\t{ DA7219_DAC_L_CTRL, 0x40 },\n\t{ DA7219_DAC_R_CTRL, 0x40 },\n\t{ DA7219_HP_L_CTRL, 0x40 },\n\t{ DA7219_HP_R_CTRL, 0x40 },\n\t{ DA7219_MIXOUT_L_CTRL, 0x10 },\n\t{ DA7219_MIXOUT_R_CTRL, 0x10 },\n\t{ DA7219_CHIP_ID1, 0x23 },\n\t{ DA7219_CHIP_ID2, 0x93 },\n\t{ DA7219_IO_CTRL, 0x00 },\n\t{ DA7219_GAIN_RAMP_CTRL, 0x00 },\n\t{ DA7219_PC_COUNT, 0x02 },\n\t{ DA7219_CP_VOL_THRESHOLD1, 0x0E },\n\t{ DA7219_DIG_CTRL, 0x00 },\n\t{ DA7219_ALC_CTRL2, 0x00 },\n\t{ DA7219_ALC_CTRL3, 0x00 },\n\t{ DA7219_ALC_NOISE, 0x3F },\n\t{ DA7219_ALC_TARGET_MIN, 0x3F },\n\t{ DA7219_ALC_TARGET_MAX, 0x00 },\n\t{ DA7219_ALC_GAIN_LIMITS, 0xFF },\n\t{ DA7219_ALC_ANA_GAIN_LIMITS, 0x71 },\n\t{ DA7219_ALC_ANTICLIP_CTRL, 0x00 },\n\t{ DA7219_ALC_ANTICLIP_LEVEL, 0x00 },\n\t{ DA7219_DAC_NG_SETUP_TIME, 0x00 },\n\t{ DA7219_DAC_NG_OFF_THRESH, 0x00 },\n\t{ DA7219_DAC_NG_ON_THRESH, 0x00 },\n\t{ DA7219_DAC_NG_CTRL, 0x00 },\n\t{ DA7219_TONE_GEN_CFG1, 0x00 },\n\t{ DA7219_TONE_GEN_CFG2, 0x00 },\n\t{ DA7219_TONE_GEN_CYCLES, 0x00 },\n\t{ DA7219_TONE_GEN_FREQ1_L, 0x55 },\n\t{ DA7219_TONE_GEN_FREQ1_U, 0x15 },\n\t{ DA7219_TONE_GEN_FREQ2_L, 0x00 },\n\t{ DA7219_TONE_GEN_FREQ2_U, 0x40 },\n\t{ DA7219_TONE_GEN_ON_PER, 0x02 },\n\t{ DA7219_TONE_GEN_OFF_PER, 0x01 },\n\t{ DA7219_ACCDET_IRQ_MASK_A, 0x00 },\n\t{ DA7219_ACCDET_IRQ_MASK_B, 0x00 },\n\t{ DA7219_ACCDET_CONFIG_1, 0xD6 },\n\t{ DA7219_ACCDET_CONFIG_2, 0x34 },\n\t{ DA7219_ACCDET_CONFIG_3, 0x0A },\n\t{ DA7219_ACCDET_CONFIG_4, 0x16 },\n\t{ DA7219_ACCDET_CONFIG_5, 0x21 },\n\t{ DA7219_ACCDET_CONFIG_6, 0x3E },\n\t{ DA7219_ACCDET_CONFIG_7, 0x01 },\n\t{ DA7219_SYSTEM_ACTIVE, 0x00 },\n};\n\nstatic bool da7219_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DA7219_MIC_1_GAIN_STATUS:\n\tcase DA7219_MIXIN_L_GAIN_STATUS:\n\tcase DA7219_ADC_L_GAIN_STATUS:\n\tcase DA7219_DAC_L_GAIN_STATUS:\n\tcase DA7219_DAC_R_GAIN_STATUS:\n\tcase DA7219_HP_L_GAIN_STATUS:\n\tcase DA7219_HP_R_GAIN_STATUS:\n\tcase DA7219_CIF_CTRL:\n\tcase DA7219_PLL_SRM_STS:\n\tcase DA7219_ALC_CTRL1:\n\tcase DA7219_SYSTEM_MODES_INPUT:\n\tcase DA7219_SYSTEM_MODES_OUTPUT:\n\tcase DA7219_ALC_OFFSET_AUTO_M_L:\n\tcase DA7219_ALC_OFFSET_AUTO_U_L:\n\tcase DA7219_TONE_GEN_CFG1:\n\tcase DA7219_ACCDET_STATUS_A:\n\tcase DA7219_ACCDET_STATUS_B:\n\tcase DA7219_ACCDET_IRQ_EVENT_A:\n\tcase DA7219_ACCDET_IRQ_EVENT_B:\n\tcase DA7219_ACCDET_CONFIG_8:\n\tcase DA7219_SYSTEM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config da7219_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = DA7219_SYSTEM_ACTIVE,\n\t.reg_defaults = da7219_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(da7219_reg_defaults),\n\t.volatile_reg = da7219_volatile_register,\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic struct reg_sequence da7219_rev_aa_patch[] = {\n\t{ DA7219_REFERENCES, 0x08 },\n};\n\nstatic int da7219_probe(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\tunsigned int system_active, system_status, rev;\n\tu8 io_voltage_lvl;\n\tint i, ret;\n\n\tda7219->component = component;\n\tmutex_init(&da7219->ctrl_lock);\n\tmutex_init(&da7219->pll_lock);\n\n\t \n\tret = da7219_handle_supplies(component, &io_voltage_lvl);\n\tif (ret)\n\t\treturn ret;\n\n\tregcache_cache_bypass(da7219->regmap, true);\n\n\t \n\tregmap_read(da7219->regmap, DA7219_SYSTEM_ACTIVE, &system_active);\n\tif (system_active) {\n\t\tregmap_write(da7219->regmap, DA7219_GAIN_RAMP_CTRL,\n\t\t\t     DA7219_GAIN_RAMP_RATE_NOMINAL);\n\t\tregmap_write(da7219->regmap, DA7219_SYSTEM_MODES_INPUT, 0x00);\n\t\tregmap_write(da7219->regmap, DA7219_SYSTEM_MODES_OUTPUT, 0x01);\n\n\t\tfor (i = 0; i < DA7219_SYS_STAT_CHECK_RETRIES; ++i) {\n\t\t\tregmap_read(da7219->regmap, DA7219_SYSTEM_STATUS,\n\t\t\t\t    &system_status);\n\t\t\tif (!system_status)\n\t\t\t\tbreak;\n\n\t\t\tmsleep(DA7219_SYS_STAT_CHECK_DELAY);\n\t\t}\n\t}\n\n\t \n\tregmap_write_bits(da7219->regmap, DA7219_ACCDET_CONFIG_1,\n\t\t\t  DA7219_ACCDET_EN_MASK, 0);\n\tregmap_write_bits(da7219->regmap, DA7219_CIF_CTRL,\n\t\t\t  DA7219_CIF_REG_SOFT_RESET_MASK,\n\t\t\t  DA7219_CIF_REG_SOFT_RESET_MASK);\n\tregmap_write_bits(da7219->regmap, DA7219_SYSTEM_ACTIVE,\n\t\t\t  DA7219_SYSTEM_ACTIVE_MASK, 0);\n\tregmap_write_bits(da7219->regmap, DA7219_SYSTEM_ACTIVE,\n\t\t\t  DA7219_SYSTEM_ACTIVE_MASK, 1);\n\n\tregcache_cache_bypass(da7219->regmap, false);\n\tregmap_reinit_cache(da7219->regmap, &da7219_regmap_config);\n\n\t \n\tsnd_soc_component_write(component, DA7219_IO_CTRL, io_voltage_lvl);\n\n\tret = regmap_read(da7219->regmap, DA7219_CHIP_REVISION, &rev);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to read chip revision: %d\\n\", ret);\n\t\tgoto err_disable_reg;\n\t}\n\n\tswitch (rev & DA7219_CHIP_MINOR_MASK) {\n\tcase 0:\n\t\tret = regmap_register_patch(da7219->regmap, da7219_rev_aa_patch,\n\t\t\t\t\t    ARRAY_SIZE(da7219_rev_aa_patch));\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to register AA patch: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err_disable_reg;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tda7219_handle_pdata(component);\n\n\t \n\tda7219->mclk = clk_get(component->dev, \"mclk\");\n\tif (IS_ERR(da7219->mclk)) {\n\t\tif (PTR_ERR(da7219->mclk) != -ENOENT) {\n\t\t\tret = PTR_ERR(da7219->mclk);\n\t\t\tgoto err_disable_reg;\n\t\t} else {\n\t\t\tda7219->mclk = NULL;\n\t\t}\n\t}\n\n\t \n\tret = da7219_register_dai_clks(component);\n\tif (ret)\n\t\tgoto err_put_clk;\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_PC_COUNT, DA7219_PC_FREERUN_MASK,\n\t\t\t    DA7219_PC_FREERUN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_MIXIN_L_CTRL,\n\t\t\t    DA7219_MIXIN_L_AMP_RAMP_EN_MASK,\n\t\t\t    DA7219_MIXIN_L_AMP_RAMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_ADC_L_CTRL, DA7219_ADC_L_RAMP_EN_MASK,\n\t\t\t    DA7219_ADC_L_RAMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_L_CTRL, DA7219_DAC_L_RAMP_EN_MASK,\n\t\t\t    DA7219_DAC_L_RAMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_DAC_R_CTRL, DA7219_DAC_R_RAMP_EN_MASK,\n\t\t\t    DA7219_DAC_R_RAMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t    DA7219_HP_L_AMP_RAMP_EN_MASK,\n\t\t\t    DA7219_HP_L_AMP_RAMP_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t    DA7219_HP_R_AMP_RAMP_EN_MASK,\n\t\t\t    DA7219_HP_R_AMP_RAMP_EN_MASK);\n\n\t \n\tsnd_soc_component_update_bits(component, DA7219_HP_L_CTRL,\n\t\t\t    DA7219_HP_L_AMP_MIN_GAIN_EN_MASK,\n\t\t\t    DA7219_HP_L_AMP_MIN_GAIN_EN_MASK);\n\tsnd_soc_component_update_bits(component, DA7219_HP_R_CTRL,\n\t\t\t    DA7219_HP_R_AMP_MIN_GAIN_EN_MASK,\n\t\t\t    DA7219_HP_R_AMP_MIN_GAIN_EN_MASK);\n\n\t \n\tsnd_soc_component_write(component, DA7219_TONE_GEN_CYCLES, DA7219_BEEP_CYCLES_MASK);\n\n\t \n\tret = da7219_aad_init(component);\n\tif (ret)\n\t\tgoto err_free_dai_clks;\n\n\treturn 0;\n\nerr_free_dai_clks:\n\tda7219_free_dai_clks(component);\n\nerr_put_clk:\n\tclk_put(da7219->mclk);\n\nerr_disable_reg:\n\tregulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);\n\tregulator_bulk_free(DA7219_NUM_SUPPLIES, da7219->supplies);\n\n\treturn ret;\n}\n\nstatic void da7219_remove(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tda7219_aad_exit(component);\n\n\tda7219_free_dai_clks(component);\n\tclk_put(da7219->mclk);\n\n\t \n\tregulator_bulk_disable(DA7219_NUM_SUPPLIES, da7219->supplies);\n\tregulator_bulk_free(DA7219_NUM_SUPPLIES, da7219->supplies);\n}\n\n#ifdef CONFIG_PM\nstatic int da7219_suspend(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!da7219->wakeup_source)\n\t\tda7219_aad_suspend(component);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\n\treturn 0;\n}\n\nstatic int da7219_resume(struct snd_soc_component *component)\n{\n\tstruct da7219_priv *da7219 = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\t \n\tif (!da7219->wakeup_source)\n\t\tda7219_aad_resume(component);\n\n\treturn 0;\n}\n#else\n#define da7219_suspend NULL\n#define da7219_resume NULL\n#endif\n\nstatic int da7219_set_jack(struct snd_soc_component *component, struct snd_soc_jack *jack,\n\t\t\t   void *data)\n{\n\tda7219_aad_jack_det(component, jack);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_da7219 = {\n\t.probe\t\t\t= da7219_probe,\n\t.remove\t\t\t= da7219_remove,\n\t.suspend\t\t= da7219_suspend,\n\t.resume\t\t\t= da7219_resume,\n\t.set_jack\t\t= da7219_set_jack,\n\t.set_bias_level\t\t= da7219_set_bias_level,\n\t.controls\t\t= da7219_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(da7219_snd_controls),\n\t.dapm_widgets\t\t= da7219_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(da7219_dapm_widgets),\n\t.dapm_routes\t\t= da7219_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(da7219_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n\n \n\nstatic int da7219_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct da7219_priv *da7219;\n\tint ret;\n\n\tda7219 = devm_kzalloc(dev, sizeof(struct da7219_priv),\n\t\t\t      GFP_KERNEL);\n\tif (!da7219)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, da7219);\n\n\tda7219->regmap = devm_regmap_init_i2c(i2c, &da7219_regmap_config);\n\tif (IS_ERR(da7219->regmap)) {\n\t\tret = PTR_ERR(da7219->regmap);\n\t\tdev_err(dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tda7219->pdata = dev_get_platdata(dev);\n\tif (!da7219->pdata)\n\t\tda7219->pdata = da7219_fw_to_pdata(dev);\n\n\t \n\tret = da7219_aad_probe(i2c);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_snd_soc_register_component(dev, &soc_component_dev_da7219,\n\t\t\t\t\t      &da7219_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register da7219 component: %d\\n\", ret);\n\t}\n\treturn ret;\n}\n\nstatic const struct i2c_device_id da7219_i2c_id[] = {\n\t{ \"da7219\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, da7219_i2c_id);\n\nstatic struct i2c_driver da7219_i2c_driver = {\n\t.driver = {\n\t\t.name = \"da7219\",\n\t\t.of_match_table = of_match_ptr(da7219_of_match),\n\t\t.acpi_match_table = ACPI_PTR(da7219_acpi_match),\n\t},\n\t.probe\t\t= da7219_i2c_probe,\n\t.id_table\t= da7219_i2c_id,\n};\n\nmodule_i2c_driver(da7219_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC DA7219 Codec Driver\");\nMODULE_AUTHOR(\"Adam Thomson <Adam.Thomson.Opensource@diasemi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}