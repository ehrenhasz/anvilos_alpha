{
  "module_name": "ak5558.c",
  "hash_id": "577bc82310236bb1e1398e2a00cfedfc03a5f0de569affd0b380731b12391561",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak5558.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"ak5558.h\"\n\nenum ak555x_type {\n\tAK5558,\n\tAK5552,\n};\n\n#define AK5558_NUM_SUPPLIES 2\nstatic const char *ak5558_supply_names[AK5558_NUM_SUPPLIES] = {\n\t\"DVDD\",\n\t\"AVDD\",\n};\n\n \nstruct ak5558_priv {\n\tstruct regulator_bulk_data supplies[AK5558_NUM_SUPPLIES];\n\tstruct snd_soc_component component;\n\tstruct regmap *regmap;\n\tstruct i2c_client *i2c;\n\tstruct gpio_desc *reset_gpiod;  \n\tint slots;\n\tint slot_width;\n};\n\n \nstatic const struct reg_default ak5558_reg[] = {\n\t{ 0x0, 0xFF },\t \n\t{ 0x1, 0x01 },\t \n\t{ 0x2, 0x01 },\t \n\t{ 0x3, 0x00 },\t \n\t{ 0x4, 0x00 },\t \n\t{ 0x5, 0x00 }\t \n};\n\nstatic const char * const mono_texts[] = {\n\t\"8 Slot\", \"2 Slot\", \"4 Slot\", \"1 Slot\",\n};\n\nstatic const struct soc_enum ak5558_mono_enum[] = {\n\tSOC_ENUM_SINGLE(AK5558_01_POWER_MANAGEMENT2, 1,\n\t\t\tARRAY_SIZE(mono_texts), mono_texts),\n};\n\nstatic const char * const mono_5552_texts[] = {\n\t\"2 Slot\", \"1 Slot (Fixed)\", \"2 Slot\", \"1 Slot (Optimal)\",\n};\n\nstatic const struct soc_enum ak5552_mono_enum[] = {\n\tSOC_ENUM_SINGLE(AK5558_01_POWER_MANAGEMENT2, 1,\n\t\t\tARRAY_SIZE(mono_5552_texts), mono_5552_texts),\n};\n\nstatic const char * const digfil_texts[] = {\n\t\"Sharp Roll-Off\", \"Slow Roll-Off\",\n\t\"Short Delay Sharp Roll-Off\", \"Short Delay Slow Roll-Off\",\n};\n\nstatic const struct soc_enum ak5558_adcset_enum[] = {\n\tSOC_ENUM_SINGLE(AK5558_04_CONTROL3, 0,\n\t\t\tARRAY_SIZE(digfil_texts), digfil_texts),\n};\n\nstatic const struct snd_kcontrol_new ak5558_snd_controls[] = {\n\tSOC_ENUM(\"Monaural Mode\", ak5558_mono_enum[0]),\n\tSOC_ENUM(\"Digital Filter\", ak5558_adcset_enum[0]),\n};\n\nstatic const struct snd_kcontrol_new ak5552_snd_controls[] = {\n\tSOC_ENUM(\"Monaural Mode\", ak5552_mono_enum[0]),\n\tSOC_ENUM(\"Digital Filter\", ak5558_adcset_enum[0]),\n};\n\nstatic const struct snd_soc_dapm_widget ak5558_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4\"),\n\tSND_SOC_DAPM_INPUT(\"AIN5\"),\n\tSND_SOC_DAPM_INPUT(\"AIN6\"),\n\tSND_SOC_DAPM_INPUT(\"AIN7\"),\n\tSND_SOC_DAPM_INPUT(\"AIN8\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC Ch1\", NULL, AK5558_00_POWER_MANAGEMENT1, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch2\", NULL, AK5558_00_POWER_MANAGEMENT1, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch3\", NULL, AK5558_00_POWER_MANAGEMENT1, 2, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch4\", NULL, AK5558_00_POWER_MANAGEMENT1, 3, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch5\", NULL, AK5558_00_POWER_MANAGEMENT1, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch6\", NULL, AK5558_00_POWER_MANAGEMENT1, 5, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch7\", NULL, AK5558_00_POWER_MANAGEMENT1, 6, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch8\", NULL, AK5558_00_POWER_MANAGEMENT1, 7, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"SDTO\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_widget ak5552_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC Ch1\", NULL, AK5558_00_POWER_MANAGEMENT1, 0, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Ch2\", NULL, AK5558_00_POWER_MANAGEMENT1, 1, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"SDTO\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route ak5558_intercon[] = {\n\t{\"ADC Ch1\", NULL, \"AIN1\"},\n\t{\"SDTO\", NULL, \"ADC Ch1\"},\n\n\t{\"ADC Ch2\", NULL, \"AIN2\"},\n\t{\"SDTO\", NULL, \"ADC Ch2\"},\n\n\t{\"ADC Ch3\", NULL, \"AIN3\"},\n\t{\"SDTO\", NULL, \"ADC Ch3\"},\n\n\t{\"ADC Ch4\", NULL, \"AIN4\"},\n\t{\"SDTO\", NULL, \"ADC Ch4\"},\n\n\t{\"ADC Ch5\", NULL, \"AIN5\"},\n\t{\"SDTO\", NULL, \"ADC Ch5\"},\n\n\t{\"ADC Ch6\", NULL, \"AIN6\"},\n\t{\"SDTO\", NULL, \"ADC Ch6\"},\n\n\t{\"ADC Ch7\", NULL, \"AIN7\"},\n\t{\"SDTO\", NULL, \"ADC Ch7\"},\n\n\t{\"ADC Ch8\", NULL, \"AIN8\"},\n\t{\"SDTO\", NULL, \"ADC Ch8\"},\n};\n\nstatic const struct snd_soc_dapm_route ak5552_intercon[] = {\n\t{\"ADC Ch1\", NULL, \"AIN1\"},\n\t{\"SDTO\", NULL, \"ADC Ch1\"},\n\n\t{\"ADC Ch2\", NULL, \"AIN2\"},\n\t{\"SDTO\", NULL, \"ADC Ch2\"},\n};\n\nstatic int ak5558_set_mcki(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_update_bits(component, AK5558_02_CONTROL1, AK5558_CKS,\n\t\t\t\t   AK5558_CKS_AUTO);\n}\n\nstatic int ak5558_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak5558_priv *ak5558 = snd_soc_component_get_drvdata(component);\n\tu8 bits;\n\tint pcm_width = max(params_physical_width(params), ak5558->slot_width);\n\n\tswitch (pcm_width) {\n\tcase 16:\n\t\tbits = AK5558_DIF_24BIT_MODE;\n\t\tbreak;\n\tcase 32:\n\t\tbits = AK5558_DIF_32BIT_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AK5558_02_CONTROL1, AK5558_BITS, bits);\n\n\treturn 0;\n}\n\nstatic int ak5558_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 format;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\tdefault:\n\t\tdev_err(dai->dev, \"Clock mode unsupported\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = AK5558_DIF_I2S_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = AK5558_DIF_MSB_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = AK5558_DIF_MSB_MODE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AK5558_02_CONTROL1, AK5558_DIF, format);\n\n\treturn 0;\n}\n\nstatic int ak5558_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots,\n\t\t\t       int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak5558_priv *ak5558 = snd_soc_component_get_drvdata(component);\n\tint tdm_mode;\n\n\tak5558->slots = slots;\n\tak5558->slot_width = slot_width;\n\n\tswitch (slots * slot_width) {\n\tcase 128:\n\t\ttdm_mode = AK5558_MODE_TDM128;\n\t\tbreak;\n\tcase 256:\n\t\ttdm_mode = AK5558_MODE_TDM256;\n\t\tbreak;\n\tcase 512:\n\t\ttdm_mode = AK5558_MODE_TDM512;\n\t\tbreak;\n\tdefault:\n\t\ttdm_mode = AK5558_MODE_NORMAL;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_update_bits(component, AK5558_03_CONTROL2, AK5558_MODE_BITS,\n\t\t\t    tdm_mode);\n\treturn 0;\n}\n\n#define AK5558_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const unsigned int ak5558_rates[] = {\n\t8000, 11025,  16000, 22050,\n\t32000, 44100, 48000, 88200,\n\t96000, 176400, 192000, 352800,\n\t384000, 705600, 768000, 1411200,\n\t2822400,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ak5558_rate_constraints = {\n\t.count = ARRAY_SIZE(ak5558_rates),\n\t.list = ak5558_rates,\n};\n\nstatic int ak5558_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &ak5558_rate_constraints);\n}\n\nstatic const struct snd_soc_dai_ops ak5558_dai_ops = {\n\t.startup        = ak5558_startup,\n\t.hw_params\t= ak5558_hw_params,\n\n\t.set_fmt\t= ak5558_set_dai_fmt,\n\t.set_tdm_slot   = ak5558_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver ak5558_dai = {\n\t.name = \"ak5558-aif\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = AK5558_FORMATS,\n\t},\n\t.ops = &ak5558_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver ak5552_dai = {\n\t.name = \"ak5552-aif\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = AK5558_FORMATS,\n\t},\n\t.ops = &ak5558_dai_ops,\n};\n\nstatic void ak5558_reset(struct ak5558_priv *ak5558, bool active)\n{\n\tif (!ak5558->reset_gpiod)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(ak5558->reset_gpiod, active);\n\tusleep_range(1000, 2000);\n}\n\nstatic int ak5558_probe(struct snd_soc_component *component)\n{\n\tstruct ak5558_priv *ak5558 = snd_soc_component_get_drvdata(component);\n\n\tak5558_reset(ak5558, false);\n\treturn ak5558_set_mcki(component);\n}\n\nstatic void ak5558_remove(struct snd_soc_component *component)\n{\n\tstruct ak5558_priv *ak5558 = snd_soc_component_get_drvdata(component);\n\n\tak5558_reset(ak5558, true);\n}\n\nstatic int __maybe_unused ak5558_runtime_suspend(struct device *dev)\n{\n\tstruct ak5558_priv *ak5558 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(ak5558->regmap, true);\n\tak5558_reset(ak5558, true);\n\n\tregulator_bulk_disable(ARRAY_SIZE(ak5558->supplies),\n\t\t\t       ak5558->supplies);\n\treturn 0;\n}\n\nstatic int __maybe_unused ak5558_runtime_resume(struct device *dev)\n{\n\tstruct ak5558_priv *ak5558 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ak5558->supplies),\n\t\t\t\t    ak5558->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tak5558_reset(ak5558, true);\n\tak5558_reset(ak5558, false);\n\n\tregcache_cache_only(ak5558->regmap, false);\n\tregcache_mark_dirty(ak5558->regmap);\n\n\treturn regcache_sync(ak5558->regmap);\n}\n\nstatic const struct dev_pm_ops ak5558_pm = {\n\tSET_RUNTIME_PM_OPS(ak5558_runtime_suspend, ak5558_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_ak5558 = {\n\t.probe\t\t\t= ak5558_probe,\n\t.remove\t\t\t= ak5558_remove,\n\t.controls\t\t= ak5558_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak5558_snd_controls),\n\t.dapm_widgets\t\t= ak5558_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak5558_dapm_widgets),\n\t.dapm_routes\t\t= ak5558_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak5558_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_ak5552 = {\n\t.probe\t\t\t= ak5558_probe,\n\t.remove\t\t\t= ak5558_remove,\n\t.controls\t\t= ak5552_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak5552_snd_controls),\n\t.dapm_widgets\t\t= ak5552_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak5552_dapm_widgets),\n\t.dapm_routes\t\t= ak5552_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak5552_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak5558_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = AK5558_05_DSD,\n\t.reg_defaults = ak5558_reg,\n\t.num_reg_defaults = ARRAY_SIZE(ak5558_reg),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int ak5558_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak5558_priv *ak5558;\n\tint ret = 0;\n\tint dev_id;\n\tint i;\n\n\tak5558 = devm_kzalloc(&i2c->dev, sizeof(*ak5558), GFP_KERNEL);\n\tif (!ak5558)\n\t\treturn -ENOMEM;\n\n\tak5558->regmap = devm_regmap_init_i2c(i2c, &ak5558_regmap);\n\tif (IS_ERR(ak5558->regmap))\n\t\treturn PTR_ERR(ak5558->regmap);\n\n\ti2c_set_clientdata(i2c, ak5558);\n\tak5558->i2c = i2c;\n\n\tak5558->reset_gpiod = devm_gpiod_get_optional(&i2c->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(ak5558->reset_gpiod))\n\t\treturn PTR_ERR(ak5558->reset_gpiod);\n\n\tfor (i = 0; i < ARRAY_SIZE(ak5558->supplies); i++)\n\t\tak5558->supplies[i].supply = ak5558_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(ak5558->supplies),\n\t\t\t\t      ak5558->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_id = (uintptr_t)of_device_get_match_data(&i2c->dev);\n\tswitch (dev_id) {\n\tcase AK5552:\n\t\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t\t      &soc_codec_dev_ak5552,\n\t\t\t\t\t\t      &ak5552_dai, 1);\n\t\tbreak;\n\tcase AK5558:\n\t\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t\t      &soc_codec_dev_ak5558,\n\t\t\t\t\t\t      &ak5558_dai, 1);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c->dev, \"unexpected device type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"failed to register component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&i2c->dev);\n\tregcache_cache_only(ak5558->regmap, true);\n\n\treturn 0;\n}\n\nstatic void ak5558_i2c_remove(struct i2c_client *i2c)\n{\n\tpm_runtime_disable(&i2c->dev);\n}\n\nstatic const struct of_device_id ak5558_i2c_dt_ids[] __maybe_unused = {\n\t{ .compatible = \"asahi-kasei,ak5558\", .data = (void *) AK5558 },\n\t{ .compatible = \"asahi-kasei,ak5552\", .data = (void *) AK5552 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ak5558_i2c_dt_ids);\n\nstatic struct i2c_driver ak5558_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak5558\",\n\t\t.of_match_table = of_match_ptr(ak5558_i2c_dt_ids),\n\t\t.pm = &ak5558_pm,\n\t},\n\t.probe = ak5558_i2c_probe,\n\t.remove = ak5558_i2c_remove,\n};\n\nmodule_i2c_driver(ak5558_i2c_driver);\n\nMODULE_AUTHOR(\"Junichi Wakasugi <wakasugi.jb@om.asahi-kasei.co.jp>\");\nMODULE_AUTHOR(\"Mihai Serban <mihai.serban@nxp.com>\");\nMODULE_DESCRIPTION(\"ASoC AK5558 ADC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}