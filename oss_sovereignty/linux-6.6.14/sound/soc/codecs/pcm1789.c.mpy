{
  "module_name": "pcm1789.c",
  "hash_id": "723487bc2ba0becaff3c07c5340fcd2afb9999954dfcfd55ff58a18e762da00c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/pcm1789.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/workqueue.h>\n\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"pcm1789.h\"\n\n#define PCM1789_MUTE_CONTROL\t0x10\n#define PCM1789_FMT_CONTROL\t0x11\n#define PCM1789_SOFT_MUTE\t0x14\n#define PCM1789_DAC_VOL_LEFT\t0x18\n#define PCM1789_DAC_VOL_RIGHT\t0x19\n\n#define PCM1789_FMT_MASK\t0x07\n#define PCM1789_MUTE_MASK\t0x03\n#define PCM1789_MUTE_SRET\t0x06\n\nstruct pcm1789_private {\n\tstruct regmap *regmap;\n\tunsigned int format;\n\tunsigned int rate;\n\tstruct gpio_desc *reset;\n\tstruct work_struct work;\n\tstruct device *dev;\n};\n\nstatic const struct reg_default pcm1789_reg_defaults[] = {\n\t{ PCM1789_FMT_CONTROL, 0x00 },\n\t{ PCM1789_SOFT_MUTE, 0x00 },\n\t{ PCM1789_DAC_VOL_LEFT, 0xff },\n\t{ PCM1789_DAC_VOL_RIGHT, 0xff },\n};\n\nstatic bool pcm1789_accessible_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg >= PCM1789_MUTE_CONTROL && reg <= PCM1789_DAC_VOL_RIGHT;\n}\n\nstatic bool pcm1789_writeable_reg(struct device *dev, unsigned int reg)\n{\n\treturn pcm1789_accessible_reg(dev, reg);\n}\n\nstatic int pcm1789_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t       unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct pcm1789_private *priv = snd_soc_component_get_drvdata(component);\n\n\tpriv->format = format;\n\n\treturn 0;\n}\n\nstatic int pcm1789_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct pcm1789_private *priv = snd_soc_component_get_drvdata(component);\n\n\treturn regmap_update_bits(priv->regmap, PCM1789_SOFT_MUTE,\n\t\t\t\t  PCM1789_MUTE_MASK,\n\t\t\t\t  mute ? 0 : PCM1789_MUTE_MASK);\n}\n\nstatic int pcm1789_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *codec_dai)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct pcm1789_private *priv = snd_soc_component_get_drvdata(component);\n\tint val = 0, ret;\n\n\tpriv->rate = params_rate(params);\n\n\tswitch (priv->format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 24:\n\t\t\tval = 2;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\tcase 24:\n\t\tcase 32:\n\t\t\tval = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, PCM1789_FMT_CONTROL,\n\t\t\t\t PCM1789_FMT_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void pcm1789_work_queue(struct work_struct *work)\n{\n\tstruct pcm1789_private *priv = container_of(work,\n\t\t\t\t\t\t    struct pcm1789_private,\n\t\t\t\t\t\t    work);\n\n\t \n\tif (regmap_update_bits(priv->regmap, PCM1789_MUTE_CONTROL,\n\t\t\t       0x3 << PCM1789_MUTE_SRET, 0) < 0)\n\t\tdev_err(priv->dev, \"Error while setting SRET\");\n}\n\nstatic int pcm1789_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct pcm1789_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tschedule_work(&priv->work);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops pcm1789_dai_ops = {\n\t.set_fmt\t= pcm1789_set_dai_fmt,\n\t.hw_params\t= pcm1789_hw_params,\n\t.mute_stream\t= pcm1789_mute,\n\t.trigger\t= pcm1789_trigger,\n\t.no_capture_mute = 1,\n};\n\nstatic const DECLARE_TLV_DB_SCALE(pcm1789_dac_tlv, -12000, 50, 1);\n\nstatic const struct snd_kcontrol_new pcm1789_controls[] = {\n\tSOC_DOUBLE_R_RANGE_TLV(\"DAC Playback Volume\", PCM1789_DAC_VOL_LEFT,\n\t\t\t       PCM1789_DAC_VOL_RIGHT, 0, 0xf, 0xff, 0,\n\t\t\t       pcm1789_dac_tlv),\n};\n\nstatic const struct snd_soc_dapm_widget pcm1789_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"IOUTL+\"),\n\tSND_SOC_DAPM_OUTPUT(\"IOUTL-\"),\n\tSND_SOC_DAPM_OUTPUT(\"IOUTR+\"),\n\tSND_SOC_DAPM_OUTPUT(\"IOUTR-\"),\n};\n\nstatic const struct snd_soc_dapm_route pcm1789_dapm_routes[] = {\n\t{ \"IOUTL+\", NULL, \"Playback\" },\n\t{ \"IOUTL-\", NULL, \"Playback\" },\n\t{ \"IOUTR+\", NULL, \"Playback\" },\n\t{ \"IOUTR-\", NULL, \"Playback\" },\n};\n\nstatic struct snd_soc_dai_driver pcm1789_dai = {\n\t.name = \"pcm1789-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 10000,\n\t\t.rate_max = 200000,\n\t\t.formats = PCM1789_FORMATS,\n\t},\n\t.ops = &pcm1789_dai_ops,\n};\n\nconst struct regmap_config pcm1789_regmap_config = {\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.max_register\t\t= PCM1789_DAC_VOL_RIGHT,\n\t.reg_defaults\t\t= pcm1789_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(pcm1789_reg_defaults),\n\t.writeable_reg\t\t= pcm1789_writeable_reg,\n\t.readable_reg\t\t= pcm1789_accessible_reg,\n};\nEXPORT_SYMBOL_GPL(pcm1789_regmap_config);\n\nstatic const struct snd_soc_component_driver soc_component_dev_pcm1789 = {\n\t.controls\t\t= pcm1789_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pcm1789_controls),\n\t.dapm_widgets\t\t= pcm1789_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pcm1789_dapm_widgets),\n\t.dapm_routes\t\t= pcm1789_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(pcm1789_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint pcm1789_common_init(struct device *dev, struct regmap *regmap)\n{\n\tstruct pcm1789_private *pcm1789;\n\n\tpcm1789 = devm_kzalloc(dev, sizeof(struct pcm1789_private),\n\t\t\t       GFP_KERNEL);\n\tif (!pcm1789)\n\t\treturn -ENOMEM;\n\n\tpcm1789->regmap = regmap;\n\tpcm1789->dev = dev;\n\tdev_set_drvdata(dev, pcm1789);\n\n\tpcm1789->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(pcm1789->reset))\n\t\treturn PTR_ERR(pcm1789->reset);\n\n\tgpiod_set_value_cansleep(pcm1789->reset, 0);\n\tmsleep(300);\n\n\tINIT_WORK(&pcm1789->work, pcm1789_work_queue);\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_dev_pcm1789,\n\t\t\t\t\t       &pcm1789_dai, 1);\n}\nEXPORT_SYMBOL_GPL(pcm1789_common_init);\n\nvoid pcm1789_common_exit(struct device *dev)\n{\n\tstruct pcm1789_private *priv = dev_get_drvdata(dev);\n\n\tflush_work(&priv->work);\n}\nEXPORT_SYMBOL_GPL(pcm1789_common_exit);\n\nMODULE_DESCRIPTION(\"ASoC PCM1789 driver\");\nMODULE_AUTHOR(\"Myl\u00e8ne Josserand <mylene.josserand@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}