{
  "module_name": "hdac_hdmi.c",
  "hash_id": "0605352cde08844174c91e96b7d82ceba6ae33d4ef91b4f21c2aa431e2c8b4a1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/hdac_hdmi.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/hdmi.h>\n#include <drm/drm_edid.h>\n#include <sound/pcm_params.h>\n#include <sound/jack.h>\n#include <sound/soc.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_i915.h>\n#include <sound/pcm_drm_eld.h>\n#include <sound/hda_chmap.h>\n#include \"../../hda/local.h\"\n#include \"hdac_hdmi.h\"\n\n#define NAME_SIZE\t32\n\n#define AMP_OUT_MUTE\t\t0xb080\n#define AMP_OUT_UNMUTE\t\t0xb000\n#define PIN_OUT\t\t\t(AC_PINCTL_OUT_EN)\n\n#define HDA_MAX_CONNECTIONS     32\n\n#define HDA_MAX_CVTS\t\t3\n#define HDA_MAX_PORTS\t\t3\n\n#define ELD_MAX_SIZE    256\n#define ELD_FIXED_BYTES\t20\n\n#define ELD_VER_CEA_861D 2\n#define ELD_VER_PARTIAL 31\n#define ELD_MAX_MNL     16\n\nstruct hdac_hdmi_cvt_params {\n\tunsigned int channels_min;\n\tunsigned int channels_max;\n\tu32 rates;\n\tu64 formats;\n\tunsigned int maxbps;\n};\n\nstruct hdac_hdmi_cvt {\n\tstruct list_head head;\n\thda_nid_t nid;\n\tconst char *name;\n\tstruct hdac_hdmi_cvt_params params;\n};\n\n \nstruct hdac_hdmi_parsed_eld {\n\tu8 spk_alloc;\n};\n\nstruct hdac_hdmi_eld {\n\tbool\tmonitor_present;\n\tbool\teld_valid;\n\tint\teld_size;\n\tchar    eld_buffer[ELD_MAX_SIZE];\n\tstruct\thdac_hdmi_parsed_eld info;\n};\n\nstruct hdac_hdmi_pin {\n\tstruct list_head head;\n\thda_nid_t nid;\n\tbool mst_capable;\n\tstruct hdac_hdmi_port *ports;\n\tint num_ports;\n\tstruct hdac_device *hdev;\n};\n\nstruct hdac_hdmi_port {\n\tstruct list_head head;\n\tint id;\n\tstruct hdac_hdmi_pin *pin;\n\tint num_mux_nids;\n\thda_nid_t mux_nids[HDA_MAX_CONNECTIONS];\n\tstruct hdac_hdmi_eld eld;\n\tconst char *jack_pin;\n\tbool is_connect;\n\tstruct snd_soc_dapm_context *dapm;\n\tconst char *output_pin;\n\tstruct work_struct dapm_work;\n};\n\nstruct hdac_hdmi_pcm {\n\tstruct list_head head;\n\tint pcm_id;\n\tstruct list_head port_list;\n\tstruct hdac_hdmi_cvt *cvt;\n\tstruct snd_soc_jack *jack;\n\tint stream_tag;\n\tint channels;\n\tint format;\n\tbool chmap_set;\n\tunsigned char chmap[8];  \n\tstruct mutex lock;\n\tint jack_event;\n\tstruct snd_kcontrol *eld_ctl;\n};\n\nstruct hdac_hdmi_dai_port_map {\n\tint dai_id;\n\tstruct hdac_hdmi_port *port;\n\tstruct hdac_hdmi_cvt *cvt;\n};\n\nstruct hdac_hdmi_drv_data {\n\tunsigned int vendor_nid;\n};\n\nstruct hdac_hdmi_priv {\n\tstruct hdac_device *hdev;\n\tstruct snd_soc_component *component;\n\tstruct snd_card *card;\n\tstruct hdac_hdmi_dai_port_map dai_map[HDA_MAX_CVTS];\n\tstruct list_head pin_list;\n\tstruct list_head cvt_list;\n\tstruct list_head pcm_list;\n\tint num_pin;\n\tint num_cvt;\n\tint num_ports;\n\tstruct mutex pin_mutex;\n\tstruct hdac_chmap chmap;\n\tstruct hdac_hdmi_drv_data *drv_data;\n\tstruct snd_soc_dai_driver *dai_drv;\n};\n\n#define hdev_to_hdmi_priv(_hdev) dev_get_drvdata(&(_hdev)->dev)\n\nstatic struct hdac_hdmi_pcm *\nhdac_hdmi_get_pcm_from_cvt(struct hdac_hdmi_priv *hdmi,\n\t\t\t   struct hdac_hdmi_cvt *cvt)\n{\n\tstruct hdac_hdmi_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (pcm->cvt == cvt)\n\t\t\treturn pcm;\n\t}\n\n\treturn NULL;\n}\n\nstatic void hdac_hdmi_jack_report(struct hdac_hdmi_pcm *pcm,\n\t\tstruct hdac_hdmi_port *port, bool is_connect)\n{\n\tstruct hdac_device *hdev = port->pin->hdev;\n\n\tport->is_connect = is_connect;\n\tif (is_connect) {\n\t\t \n\t\tif (pcm->jack_event == 0) {\n\t\t\tdev_dbg(&hdev->dev,\n\t\t\t\t\t\"jack report for pcm=%d\\n\",\n\t\t\t\t\tpcm->pcm_id);\n\t\t\tsnd_soc_jack_report(pcm->jack, SND_JACK_AVOUT,\n\t\t\t\t\t\tSND_JACK_AVOUT);\n\t\t}\n\t\tpcm->jack_event++;\n\t} else {\n\t\t \n\t\tif (pcm->jack_event == 1)\n\t\t\tsnd_soc_jack_report(pcm->jack, 0, SND_JACK_AVOUT);\n\t\tif (pcm->jack_event > 0)\n\t\t\tpcm->jack_event--;\n\t}\n}\n\nstatic void hdac_hdmi_port_dapm_update(struct hdac_hdmi_port *port)\n{\n\tif (port->is_connect)\n\t\tsnd_soc_dapm_enable_pin(port->dapm, port->jack_pin);\n\telse\n\t\tsnd_soc_dapm_disable_pin(port->dapm, port->jack_pin);\n\tsnd_soc_dapm_sync(port->dapm);\n}\n\nstatic void hdac_hdmi_jack_dapm_work(struct work_struct *work)\n{\n\tstruct hdac_hdmi_port *port;\n\n\tport = container_of(work, struct hdac_hdmi_port, dapm_work);\n\thdac_hdmi_port_dapm_update(port);\n}\n\nstatic void hdac_hdmi_jack_report_sync(struct hdac_hdmi_pcm *pcm,\n\t\tstruct hdac_hdmi_port *port, bool is_connect)\n{\n\thdac_hdmi_jack_report(pcm, port, is_connect);\n\thdac_hdmi_port_dapm_update(port);\n}\n\n \n \nstatic int hdac_hdmi_get_port_len(struct hdac_device *hdev, hda_nid_t nid)\n{\n\tunsigned int caps;\n\tunsigned int type, param;\n\n\tcaps = get_wcaps(hdev, nid);\n\ttype = get_wcaps_type(caps);\n\n\tif (!(caps & AC_WCAP_DIGITAL) || (type != AC_WID_PIN))\n\t\treturn 0;\n\n\tparam = snd_hdac_read_parm_uncached(hdev, nid, AC_PAR_DEVLIST_LEN);\n\tif (param == -1)\n\t\treturn param;\n\n\treturn param & AC_DEV_LIST_LEN_MASK;\n}\n\n \nstatic int hdac_hdmi_port_select_get(struct hdac_device *hdev,\n\t\t\t\t\tstruct hdac_hdmi_port *port)\n{\n\treturn snd_hdac_codec_read(hdev, port->pin->nid,\n\t\t\t\t0, AC_VERB_GET_DEVICE_SEL, 0);\n}\n\n \nstatic int hdac_hdmi_port_select_set(struct hdac_device *hdev,\n\t\t\t\t\tstruct hdac_hdmi_port *port)\n{\n\tint num_ports;\n\n\tif (!port->pin->mst_capable)\n\t\treturn 0;\n\n\t \n\tnum_ports = hdac_hdmi_get_port_len(hdev, port->pin->nid);\n\tif (num_ports < 0)\n\t\treturn -EIO;\n\t \n\tif (num_ports + 1  < port->id)\n\t\treturn 0;\n\n\tsnd_hdac_codec_write(hdev, port->pin->nid, 0,\n\t\t\tAC_VERB_SET_DEVICE_SEL, port->id);\n\n\tif (port->id != hdac_hdmi_port_select_get(hdev, port))\n\t\treturn -EIO;\n\n\tdev_dbg(&hdev->dev, \"Selected the port=%d\\n\", port->id);\n\n\treturn 0;\n}\n\nstatic struct hdac_hdmi_pcm *get_hdmi_pcm_from_id(struct hdac_hdmi_priv *hdmi,\n\t\t\t\t\t\tint pcm_idx)\n{\n\tstruct hdac_hdmi_pcm *pcm;\n\n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (pcm->pcm_id == pcm_idx)\n\t\t\treturn pcm;\n\t}\n\n\treturn NULL;\n}\n\nstatic unsigned int sad_format(const u8 *sad)\n{\n\treturn ((sad[0] >> 0x3) & 0x1f);\n}\n\nstatic unsigned int sad_sample_bits_lpcm(const u8 *sad)\n{\n\treturn (sad[2] & 7);\n}\n\nstatic int hdac_hdmi_eld_limit_formats(struct snd_pcm_runtime *runtime,\n\t\t\t\t\t\tvoid *eld)\n{\n\tu64 formats = SNDRV_PCM_FMTBIT_S16;\n\tint i;\n\tconst u8 *sad, *eld_buf = eld;\n\n\tsad = drm_eld_sad(eld_buf);\n\tif (!sad)\n\t\tgoto format_constraint;\n\n\tfor (i = drm_eld_sad_count(eld_buf); i > 0; i--, sad += 3) {\n\t\tif (sad_format(sad) == 1) {  \n\n\t\t\t \n\t\t\tif (sad_sample_bits_lpcm(sad) & 0x6)\n\t\t\t\tformats |= SNDRV_PCM_FMTBIT_S32;\n\t\t}\n\t}\n\nformat_constraint:\n\treturn snd_pcm_hw_constraint_mask64(runtime, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\t\tformats);\n\n}\n\nstatic void\nhdac_hdmi_set_dip_index(struct hdac_device *hdev, hda_nid_t pin_nid,\n\t\t\t\tint packet_index, int byte_index)\n{\n\tint val;\n\n\tval = (packet_index << 5) | (byte_index & 0x1f);\n\tsnd_hdac_codec_write(hdev, pin_nid, 0, AC_VERB_SET_HDMI_DIP_INDEX, val);\n}\n\nstruct dp_audio_infoframe {\n\tu8 type;  \n\tu8 len;   \n\tu8 ver;   \n\n\tu8 CC02_CT47;\t \n\tu8 SS01_SF24;\n\tu8 CXT04;\n\tu8 CA;\n\tu8 LFEPBL01_LSV36_DM_INH7;\n};\n\nstatic int hdac_hdmi_setup_audio_infoframe(struct hdac_device *hdev,\n\t\t   struct hdac_hdmi_pcm *pcm, struct hdac_hdmi_port *port)\n{\n\tuint8_t buffer[HDMI_INFOFRAME_HEADER_SIZE + HDMI_AUDIO_INFOFRAME_SIZE];\n\tstruct hdmi_audio_infoframe frame;\n\tstruct hdac_hdmi_pin *pin = port->pin;\n\tstruct dp_audio_infoframe dp_ai;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_cvt *cvt = pcm->cvt;\n\tu8 *dip;\n\tint ret;\n\tint i;\n\tconst u8 *eld_buf;\n\tu8 conn_type;\n\tint channels, ca;\n\n\tca = snd_hdac_channel_allocation(hdev, port->eld.info.spk_alloc,\n\t\t\tpcm->channels, pcm->chmap_set, true, pcm->chmap);\n\n\tchannels = snd_hdac_get_active_channels(ca);\n\thdmi->chmap.ops.set_channel_count(hdev, cvt->nid, channels);\n\n\tsnd_hdac_setup_channel_mapping(&hdmi->chmap, pin->nid, false, ca,\n\t\t\t\tpcm->channels, pcm->chmap, pcm->chmap_set);\n\n\teld_buf = port->eld.eld_buffer;\n\tconn_type = drm_eld_get_conn_type(eld_buf);\n\n\tswitch (conn_type) {\n\tcase DRM_ELD_CONN_TYPE_HDMI:\n\t\thdmi_audio_infoframe_init(&frame);\n\n\t\tframe.channels = channels;\n\t\tframe.channel_allocation = ca;\n\n\t\tret = hdmi_audio_infoframe_pack(&frame, buffer, sizeof(buffer));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tbreak;\n\n\tcase DRM_ELD_CONN_TYPE_DP:\n\t\tmemset(&dp_ai, 0, sizeof(dp_ai));\n\t\tdp_ai.type\t= 0x84;\n\t\tdp_ai.len\t= 0x1b;\n\t\tdp_ai.ver\t= 0x11 << 2;\n\t\tdp_ai.CC02_CT47\t= channels - 1;\n\t\tdp_ai.CA\t= ca;\n\n\t\tdip = (u8 *)&dp_ai;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&hdev->dev, \"Invalid connection type: %d\\n\", conn_type);\n\t\treturn -EIO;\n\t}\n\n\t \n\thdac_hdmi_set_dip_index(hdev, pin->nid, 0x0, 0x0);\n\tsnd_hdac_codec_write(hdev, pin->nid, 0,\n\t\t\tAC_VERB_SET_HDMI_DIP_XMIT, AC_DIPXMIT_DISABLE);\n\n\n\t \n\thdac_hdmi_set_dip_index(hdev, pin->nid, 0x0, 0x0);\n\tif (conn_type == DRM_ELD_CONN_TYPE_HDMI) {\n\t\tfor (i = 0; i < sizeof(buffer); i++)\n\t\t\tsnd_hdac_codec_write(hdev, pin->nid, 0,\n\t\t\t\tAC_VERB_SET_HDMI_DIP_DATA, buffer[i]);\n\t} else {\n\t\tfor (i = 0; i < sizeof(dp_ai); i++)\n\t\t\tsnd_hdac_codec_write(hdev, pin->nid, 0,\n\t\t\t\tAC_VERB_SET_HDMI_DIP_DATA, dip[i]);\n\t}\n\n\t \n\thdac_hdmi_set_dip_index(hdev, pin->nid, 0x0, 0x0);\n\tsnd_hdac_codec_write(hdev, pin->nid, 0,\n\t\t\tAC_VERB_SET_HDMI_DIP_XMIT, AC_DIPXMIT_BEST);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_set_stream(struct snd_soc_dai *dai,\n\t\t\t\tvoid *stream, int direction)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_dai_get_drvdata(dai);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tstruct hdac_hdmi_dai_port_map *dai_map;\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct hdac_stream *hstream;\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\thstream = (struct hdac_stream *)stream;\n\n\tdev_dbg(&hdev->dev, \"%s: strm_tag: %d\\n\", __func__, hstream->stream_tag);\n\n\tdai_map = &hdmi->dai_map[dai->id];\n\n\tpcm = hdac_hdmi_get_pcm_from_cvt(hdmi, dai_map->cvt);\n\n\tif (pcm)\n\t\tpcm->stream_tag = (hstream->stream_tag << 4);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_set_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *hparams, struct snd_soc_dai *dai)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_dai_get_drvdata(dai);\n\tstruct hdac_hdmi_dai_port_map *dai_map;\n\tstruct hdac_hdmi_pcm *pcm;\n\tint format;\n\n\tdai_map = &hdmi->dai_map[dai->id];\n\n\tformat = snd_hdac_calc_stream_format(params_rate(hparams),\n\t\t\tparams_channels(hparams), params_format(hparams),\n\t\t\tdai->driver->playback.sig_bits, 0);\n\n\tpcm = hdac_hdmi_get_pcm_from_cvt(hdmi, dai_map->cvt);\n\tif (!pcm)\n\t\treturn -EIO;\n\n\tpcm->format = format;\n\tpcm->channels = params_channels(hparams);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_query_port_connlist(struct hdac_device *hdev,\n\t\t\t\t\tstruct hdac_hdmi_pin *pin,\n\t\t\t\t\tstruct hdac_hdmi_port *port)\n{\n\tif (!(get_wcaps(hdev, pin->nid) & AC_WCAP_CONN_LIST)) {\n\t\tdev_warn(&hdev->dev,\n\t\t\t\"HDMI: pin %d wcaps %#x does not support connection list\\n\",\n\t\t\tpin->nid, get_wcaps(hdev, pin->nid));\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdac_hdmi_port_select_set(hdev, port) < 0)\n\t\treturn -EIO;\n\n\tport->num_mux_nids = snd_hdac_get_connections(hdev, pin->nid,\n\t\t\tport->mux_nids, HDA_MAX_CONNECTIONS);\n\tif (port->num_mux_nids == 0)\n\t\tdev_warn(&hdev->dev,\n\t\t\t\"No connections found for pin:port %d:%d\\n\",\n\t\t\t\t\t\tpin->nid, port->id);\n\n\tdev_dbg(&hdev->dev, \"num_mux_nids %d for pin:port %d:%d\\n\",\n\t\t\tport->num_mux_nids, pin->nid, port->id);\n\n\treturn port->num_mux_nids;\n}\n\n \nstatic struct hdac_hdmi_port *hdac_hdmi_get_port_from_cvt(\n\t\t\tstruct hdac_device *hdev,\n\t\t\tstruct hdac_hdmi_priv *hdmi,\n\t\t\tstruct hdac_hdmi_cvt *cvt)\n{\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct hdac_hdmi_port *port;\n\tint ret, i;\n\n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (pcm->cvt == cvt) {\n\t\t\tif (list_empty(&pcm->port_list))\n\t\t\t\tcontinue;\n\n\t\t\tlist_for_each_entry(port, &pcm->port_list, head) {\n\t\t\t\tmutex_lock(&pcm->lock);\n\t\t\t\tret = hdac_hdmi_query_port_connlist(hdev,\n\t\t\t\t\t\t\tport->pin, port);\n\t\t\t\tmutex_unlock(&pcm->lock);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (i = 0; i < port->num_mux_nids; i++) {\n\t\t\t\t\tif (port->mux_nids[i] == cvt->nid &&\n\t\t\t\t\t\tport->eld.monitor_present &&\n\t\t\t\t\t\tport->eld.eld_valid)\n\t\t\t\t\t\treturn port;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void hdac_hdmi_verify_connect_sel_all_pins(struct hdac_device *hdev)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_port *port;\n\tstruct hdac_hdmi_cvt *cvt;\n\tint cvt_idx = 0;\n\n\tlist_for_each_entry(cvt, &hdmi->cvt_list, head) {\n\t\tport = hdac_hdmi_get_port_from_cvt(hdev, hdmi, cvt);\n\t\tif (port && port->pin) {\n\t\t\tsnd_hdac_codec_write(hdev, port->pin->nid, 0,\n\t\t\t\t\t     AC_VERB_SET_CONNECT_SEL, cvt_idx);\n\t\t\tdev_dbg(&hdev->dev, \"%s: %s set connect %d -> %d\\n\",\n\t\t\t\t__func__, cvt->name, port->pin->nid, cvt_idx);\n\t\t}\n\t\t++cvt_idx;\n\t}\n}\n\n \nstatic int hdac_hdmi_pcm_open(struct snd_pcm_substream *substream,\n\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_dai_get_drvdata(dai);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tstruct hdac_hdmi_dai_port_map *dai_map;\n\tstruct hdac_hdmi_cvt *cvt;\n\tstruct hdac_hdmi_port *port;\n\tint ret;\n\n\tdai_map = &hdmi->dai_map[dai->id];\n\n\tcvt = dai_map->cvt;\n\tport = hdac_hdmi_get_port_from_cvt(hdev, hdmi, cvt);\n\n\t \n\tif (!port)\n\t\treturn 0;\n\tif ((!port->eld.monitor_present) ||\n\t\t\t(!port->eld.eld_valid)) {\n\n\t\tdev_warn(&hdev->dev,\n\t\t\t\"Failed: present?:%d ELD valid?:%d pin:port: %d:%d\\n\",\n\t\t\tport->eld.monitor_present, port->eld.eld_valid,\n\t\t\tport->pin->nid, port->id);\n\n\t\treturn 0;\n\t}\n\n\tdai_map->port = port;\n\n\tret = hdac_hdmi_eld_limit_formats(substream->runtime,\n\t\t\t\tport->eld.eld_buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_constraint_eld(substream->runtime,\n\t\t\t\tport->eld.eld_buffer);\n}\n\nstatic void hdac_hdmi_pcm_close(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_dai_get_drvdata(dai);\n\tstruct hdac_hdmi_dai_port_map *dai_map;\n\tstruct hdac_hdmi_pcm *pcm;\n\n\tdai_map = &hdmi->dai_map[dai->id];\n\n\tpcm = hdac_hdmi_get_pcm_from_cvt(hdmi, dai_map->cvt);\n\n\tif (pcm) {\n\t\tmutex_lock(&pcm->lock);\n\t\tpcm->chmap_set = false;\n\t\tmemset(pcm->chmap, 0, sizeof(pcm->chmap));\n\t\tpcm->channels = 0;\n\t\tmutex_unlock(&pcm->lock);\n\t}\n\n\tif (dai_map->port)\n\t\tdai_map->port = NULL;\n}\n\nstatic int\nhdac_hdmi_query_cvt_params(struct hdac_device *hdev, struct hdac_hdmi_cvt *cvt)\n{\n\tunsigned int chans;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tint err;\n\n\tchans = get_wcaps(hdev, cvt->nid);\n\tchans = get_wcaps_channels(chans);\n\n\tcvt->params.channels_min = 2;\n\n\tcvt->params.channels_max = chans;\n\tif (chans > hdmi->chmap.channels_max)\n\t\thdmi->chmap.channels_max = chans;\n\n\terr = snd_hdac_query_supported_pcm(hdev, cvt->nid,\n\t\t\t&cvt->params.rates,\n\t\t\t&cvt->params.formats,\n\t\t\t&cvt->params.maxbps);\n\tif (err < 0)\n\t\tdev_err(&hdev->dev,\n\t\t\t\"Failed to query pcm params for nid %d: %d\\n\",\n\t\t\tcvt->nid, err);\n\n\treturn err;\n}\n\nstatic int hdac_hdmi_fill_widget_info(struct device *dev,\n\t\tstruct snd_soc_dapm_widget *w, enum snd_soc_dapm_type id,\n\t\tvoid *priv, const char *wname, const char *stream,\n\t\tstruct snd_kcontrol_new *wc, int numkc,\n\t\tint (*event)(struct snd_soc_dapm_widget *,\n\t\tstruct snd_kcontrol *, int), unsigned short event_flags)\n{\n\tw->id = id;\n\tw->name = devm_kstrdup(dev, wname, GFP_KERNEL);\n\tif (!w->name)\n\t\treturn -ENOMEM;\n\n\tw->sname = stream;\n\tw->reg = SND_SOC_NOPM;\n\tw->shift = 0;\n\tw->kcontrol_news = wc;\n\tw->num_kcontrols = numkc;\n\tw->priv = priv;\n\tw->event = event;\n\tw->event_flags = event_flags;\n\n\treturn 0;\n}\n\nstatic void hdac_hdmi_fill_route(struct snd_soc_dapm_route *route,\n\t\tconst char *sink, const char *control, const char *src,\n\t\tint (*handler)(struct snd_soc_dapm_widget *src,\n\t\t\tstruct snd_soc_dapm_widget *sink))\n{\n\troute->sink = sink;\n\troute->source = src;\n\troute->control = control;\n\troute->connected = handler;\n}\n\nstatic struct hdac_hdmi_pcm *hdac_hdmi_get_pcm(struct hdac_device *hdev,\n\t\t\t\t\tstruct hdac_hdmi_port *port)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct hdac_hdmi_port *p;\n\n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (list_empty(&pcm->port_list))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(p, &pcm->port_list, head) {\n\t\t\tif (p->id == port->id && port->pin == p->pin)\n\t\t\t\treturn pcm;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void hdac_hdmi_set_power_state(struct hdac_device *hdev,\n\t\t\t     hda_nid_t nid, unsigned int pwr_state)\n{\n\tint count;\n\tunsigned int state;\n\n\tif (get_wcaps(hdev, nid) & AC_WCAP_POWER) {\n\t\tif (!snd_hdac_check_power_state(hdev, nid, pwr_state)) {\n\t\t\tfor (count = 0; count < 10; count++) {\n\t\t\t\tsnd_hdac_codec_read(hdev, nid, 0,\n\t\t\t\t\t\tAC_VERB_SET_POWER_STATE,\n\t\t\t\t\t\tpwr_state);\n\t\t\t\tstate = snd_hdac_sync_power_state(hdev,\n\t\t\t\t\t\tnid, pwr_state);\n\t\t\t\tif (!(state & AC_PWRST_ERROR))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void hdac_hdmi_set_amp(struct hdac_device *hdev,\n\t\t\t\t   hda_nid_t nid, int val)\n{\n\tif (get_wcaps(hdev, nid) & AC_WCAP_OUT_AMP)\n\t\tsnd_hdac_codec_write(hdev, nid, 0,\n\t\t\t\t\tAC_VERB_SET_AMP_GAIN_MUTE, val);\n}\n\n\nstatic int hdac_hdmi_pin_output_widget_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\tstruct snd_kcontrol *kc, int event)\n{\n\tstruct hdac_hdmi_port *port = w->priv;\n\tstruct hdac_device *hdev = dev_to_hdac_dev(w->dapm->dev);\n\tstruct hdac_hdmi_pcm *pcm;\n\n\tdev_dbg(&hdev->dev, \"%s: widget: %s event: %x\\n\",\n\t\t\t__func__, w->name, event);\n\n\tpcm = hdac_hdmi_get_pcm(hdev, port);\n\tif (!pcm)\n\t\treturn -EIO;\n\n\t \n\tif (hdac_hdmi_port_select_set(hdev, port) < 0)\n\t\treturn -EIO;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\thdac_hdmi_set_power_state(hdev, port->pin->nid, AC_PWRST_D0);\n\n\t\t \n\t\tsnd_hdac_codec_write(hdev, port->pin->nid, 0,\n\t\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, PIN_OUT);\n\n\t\thdac_hdmi_set_amp(hdev, port->pin->nid, AMP_OUT_UNMUTE);\n\n\t\treturn hdac_hdmi_setup_audio_infoframe(hdev, pcm, port);\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\thdac_hdmi_set_amp(hdev, port->pin->nid, AMP_OUT_MUTE);\n\n\t\t \n\t\tsnd_hdac_codec_write(hdev, port->pin->nid, 0,\n\t\t\t\tAC_VERB_SET_PIN_WIDGET_CONTROL, 0);\n\n\t\thdac_hdmi_set_power_state(hdev, port->pin->nid, AC_PWRST_D3);\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_cvt_output_widget_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\tstruct snd_kcontrol *kc, int event)\n{\n\tstruct hdac_hdmi_cvt *cvt = w->priv;\n\tstruct hdac_device *hdev = dev_to_hdac_dev(w->dapm->dev);\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm;\n\n\tdev_dbg(&hdev->dev, \"%s: widget: %s event: %x\\n\",\n\t\t\t__func__, w->name, event);\n\n\tpcm = hdac_hdmi_get_pcm_from_cvt(hdmi, cvt);\n\tif (!pcm)\n\t\treturn -EIO;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\thdac_hdmi_set_power_state(hdev, cvt->nid, AC_PWRST_D0);\n\n\t\t \n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\tAC_VERB_SET_DIGI_CONVERT_1, 1);\n\n\t\t \n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\tAC_VERB_SET_DIGI_CONVERT_2, 0);\n\n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\t\tAC_VERB_SET_CHANNEL_STREAMID, pcm->stream_tag);\n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\t\tAC_VERB_SET_STREAM_FORMAT, pcm->format);\n\n\t\t \n\t\thdac_hdmi_verify_connect_sel_all_pins(hdev);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\t\tAC_VERB_SET_CHANNEL_STREAMID, 0);\n\t\tsnd_hdac_codec_write(hdev, cvt->nid, 0,\n\t\t\t\tAC_VERB_SET_STREAM_FORMAT, 0);\n\n\t\thdac_hdmi_set_power_state(hdev, cvt->nid, AC_PWRST_D3);\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_pin_mux_widget_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t\tstruct snd_kcontrol *kc, int event)\n{\n\tstruct hdac_hdmi_port *port = w->priv;\n\tstruct hdac_device *hdev = dev_to_hdac_dev(w->dapm->dev);\n\tint mux_idx;\n\n\tdev_dbg(&hdev->dev, \"%s: widget: %s event: %x\\n\",\n\t\t\t__func__, w->name, event);\n\n\tif (!kc)\n\t\tkc  = w->kcontrols[0];\n\n\tmux_idx = dapm_kcontrol_get_value(kc);\n\n\t \n\tif (hdac_hdmi_port_select_set(hdev, port) < 0)\n\t\treturn -EIO;\n\n\tif (mux_idx > 0) {\n\t\tsnd_hdac_codec_write(hdev, port->pin->nid, 0,\n\t\t\tAC_VERB_SET_CONNECT_SEL, (mux_idx - 1));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hdac_hdmi_set_pin_port_mux(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint ret;\n\tstruct hdac_hdmi_port *p, *p_next;\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct snd_soc_dapm_widget *w = snd_soc_dapm_kcontrol_widget(kcontrol);\n\tstruct snd_soc_dapm_context *dapm = w->dapm;\n\tstruct hdac_hdmi_port *port = w->priv;\n\tstruct hdac_device *hdev = dev_to_hdac_dev(dapm->dev);\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm;\n\tconst char *cvt_name =  e->texts[ucontrol->value.enumerated.item[0]];\n\n\tret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (port == NULL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hdmi->pin_mutex);\n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (list_empty(&pcm->port_list))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(p, p_next, &pcm->port_list, head) {\n\t\t\tif (p == port && p->id == port->id &&\n\t\t\t\t\tp->pin == port->pin) {\n\t\t\t\thdac_hdmi_jack_report_sync(pcm, port, false);\n\t\t\t\tlist_del(&p->head);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(pcm, &hdmi->pcm_list, head) {\n\t\tif (!strcmp(cvt_name, pcm->cvt->name)) {\n\t\t\tlist_add_tail(&port->head, &pcm->port_list);\n\t\t\tif (port->eld.monitor_present && port->eld.eld_valid) {\n\t\t\t\thdac_hdmi_jack_report_sync(pcm, port, true);\n\t\t\t\tmutex_unlock(&hdmi->pin_mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&hdmi->pin_mutex);\n\n\treturn ret;\n}\n\n \nstatic int hdac_hdmi_create_pin_port_muxs(struct hdac_device *hdev,\n\t\t\t\tstruct hdac_hdmi_port *port,\n\t\t\t\tstruct snd_soc_dapm_widget *widget,\n\t\t\t\tconst char *widget_name)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pin *pin = port->pin;\n\tstruct snd_kcontrol_new *kc;\n\tstruct hdac_hdmi_cvt *cvt;\n\tstruct soc_enum *se;\n\tchar kc_name[NAME_SIZE];\n\tchar mux_items[NAME_SIZE];\n\t \n\tchar *items[HDA_MAX_CONNECTIONS];\n\tint i = 0;\n\tint num_items = hdmi->num_cvt + 1;\n\n\tkc = devm_kzalloc(&hdev->dev, sizeof(*kc), GFP_KERNEL);\n\tif (!kc)\n\t\treturn -ENOMEM;\n\n\tse = devm_kzalloc(&hdev->dev, sizeof(*se), GFP_KERNEL);\n\tif (!se)\n\t\treturn -ENOMEM;\n\n\tsnprintf(kc_name, NAME_SIZE, \"Pin %d port %d Input\",\n\t\t\t\t\t\tpin->nid, port->id);\n\tkc->name = devm_kstrdup(&hdev->dev, kc_name, GFP_KERNEL);\n\tif (!kc->name)\n\t\treturn -ENOMEM;\n\n\tkc->private_value = (long)se;\n\tkc->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkc->access = 0;\n\tkc->info = snd_soc_info_enum_double;\n\tkc->put = hdac_hdmi_set_pin_port_mux;\n\tkc->get = snd_soc_dapm_get_enum_double;\n\n\tse->reg = SND_SOC_NOPM;\n\n\t \n\tse->items = num_items;\n\tse->mask = roundup_pow_of_two(se->items) - 1;\n\n\tsprintf(mux_items, \"NONE\");\n\titems[i] = devm_kstrdup(&hdev->dev, mux_items, GFP_KERNEL);\n\tif (!items[i])\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(cvt, &hdmi->cvt_list, head) {\n\t\ti++;\n\t\tsprintf(mux_items, \"cvt %d\", cvt->nid);\n\t\titems[i] = devm_kstrdup(&hdev->dev, mux_items, GFP_KERNEL);\n\t\tif (!items[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tse->texts = devm_kmemdup(&hdev->dev, items,\n\t\t\t(num_items  * sizeof(char *)), GFP_KERNEL);\n\tif (!se->texts)\n\t\treturn -ENOMEM;\n\n\treturn hdac_hdmi_fill_widget_info(&hdev->dev, widget,\n\t\t\tsnd_soc_dapm_mux, port, widget_name, NULL, kc, 1,\n\t\t\thdac_hdmi_pin_mux_widget_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_REG);\n}\n\n \nstatic void hdac_hdmi_add_pinmux_cvt_route(struct hdac_device *hdev,\n\t\t\tstruct snd_soc_dapm_widget *widgets,\n\t\t\tstruct snd_soc_dapm_route *route, int rindex)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tconst struct snd_kcontrol_new *kc;\n\tstruct soc_enum *se;\n\tint mux_index = hdmi->num_cvt + hdmi->num_ports;\n\tint i, j;\n\n\tfor (i = 0; i < hdmi->num_ports; i++) {\n\t\tkc = widgets[mux_index].kcontrol_news;\n\t\tse = (struct soc_enum *)kc->private_value;\n\t\tfor (j = 0; j < hdmi->num_cvt; j++) {\n\t\t\thdac_hdmi_fill_route(&route[rindex],\n\t\t\t\t\twidgets[mux_index].name,\n\t\t\t\t\tse->texts[j + 1],\n\t\t\t\t\twidgets[j].name, NULL);\n\n\t\t\trindex++;\n\t\t}\n\n\t\tmux_index++;\n\t}\n}\n\n \nstatic int create_fill_widget_route_map(struct snd_soc_dapm_context *dapm)\n{\n\tstruct snd_soc_dapm_widget *widgets;\n\tstruct snd_soc_dapm_route *route;\n\tstruct hdac_device *hdev = dev_to_hdac_dev(dapm->dev);\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct snd_soc_dai_driver *dai_drv = hdmi->dai_drv;\n\tchar widget_name[NAME_SIZE];\n\tstruct hdac_hdmi_cvt *cvt;\n\tstruct hdac_hdmi_pin *pin;\n\tint ret, i = 0, num_routes = 0, j;\n\n\tif (list_empty(&hdmi->cvt_list) || list_empty(&hdmi->pin_list))\n\t\treturn -EINVAL;\n\n\twidgets = devm_kzalloc(dapm->dev, (sizeof(*widgets) *\n\t\t\t\t((2 * hdmi->num_ports) + hdmi->num_cvt)),\n\t\t\t\tGFP_KERNEL);\n\n\tif (!widgets)\n\t\treturn -ENOMEM;\n\n\t \n\tlist_for_each_entry(cvt, &hdmi->cvt_list, head) {\n\t\tsprintf(widget_name, \"Converter %d\", cvt->nid);\n\t\tret = hdac_hdmi_fill_widget_info(dapm->dev, &widgets[i],\n\t\t\tsnd_soc_dapm_aif_in, cvt,\n\t\t\twidget_name, dai_drv[i].playback.stream_name, NULL, 0,\n\t\t\thdac_hdmi_cvt_output_widget_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++) {\n\t\t\tsprintf(widget_name, \"hif%d-%d Output\",\n\t\t\t\tpin->nid, pin->ports[j].id);\n\t\t\tret = hdac_hdmi_fill_widget_info(dapm->dev, &widgets[i],\n\t\t\t\t\tsnd_soc_dapm_output, &pin->ports[j],\n\t\t\t\t\twidget_name, NULL, NULL, 0,\n\t\t\t\t\thdac_hdmi_pin_output_widget_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tpin->ports[j].output_pin = widgets[i].name;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++) {\n\t\t\tsprintf(widget_name, \"Pin%d-Port%d Mux\",\n\t\t\t\tpin->nid, pin->ports[j].id);\n\t\t\tret = hdac_hdmi_create_pin_port_muxs(hdev,\n\t\t\t\t\t\t&pin->ports[j], &widgets[i],\n\t\t\t\t\t\twidget_name);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\ti++;\n\n\t\t\t \n\t\t\tnum_routes += hdmi->num_cvt;\n\n\t\t\t \n\t\t\tnum_routes++;\n\t\t}\n\t}\n\n\troute = devm_kzalloc(dapm->dev, (sizeof(*route) * num_routes),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!route)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\t \n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++) {\n\t\t\tint sink_index = i + hdmi->num_cvt;\n\t\t\tint src_index = sink_index + pin->num_ports *\n\t\t\t\t\t\thdmi->num_pin;\n\n\t\t\thdac_hdmi_fill_route(&route[i],\n\t\t\t\twidgets[sink_index].name, NULL,\n\t\t\t\twidgets[src_index].name, NULL);\n\t\t\ti++;\n\t\t}\n\t}\n\n\thdac_hdmi_add_pinmux_cvt_route(hdev, widgets, route, i);\n\n\tsnd_soc_dapm_new_controls(dapm, widgets,\n\t\t((2 * hdmi->num_ports) + hdmi->num_cvt));\n\n\tsnd_soc_dapm_add_routes(dapm, route, num_routes);\n\tsnd_soc_dapm_new_widgets(dapm->card);\n\n\treturn 0;\n\n}\n\nstatic int hdac_hdmi_init_dai_map(struct hdac_device *hdev)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_dai_port_map *dai_map;\n\tstruct hdac_hdmi_cvt *cvt;\n\tint dai_id = 0;\n\n\tif (list_empty(&hdmi->cvt_list))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(cvt, &hdmi->cvt_list, head) {\n\t\tdai_map = &hdmi->dai_map[dai_id];\n\t\tdai_map->dai_id = dai_id;\n\t\tdai_map->cvt = cvt;\n\n\t\tdai_id++;\n\n\t\tif (dai_id == HDA_MAX_CVTS) {\n\t\t\tdev_warn(&hdev->dev,\n\t\t\t\t\"Max dais supported: %d\\n\", dai_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_add_cvt(struct hdac_device *hdev, hda_nid_t nid)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_cvt *cvt;\n\tchar name[NAME_SIZE];\n\n\tcvt = devm_kzalloc(&hdev->dev, sizeof(*cvt), GFP_KERNEL);\n\tif (!cvt)\n\t\treturn -ENOMEM;\n\n\tcvt->nid = nid;\n\tsprintf(name, \"cvt %d\", cvt->nid);\n\tcvt->name = devm_kstrdup(&hdev->dev, name, GFP_KERNEL);\n\tif (!cvt->name)\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&cvt->head, &hdmi->cvt_list);\n\thdmi->num_cvt++;\n\n\treturn hdac_hdmi_query_cvt_params(hdev, cvt);\n}\n\nstatic int hdac_hdmi_parse_eld(struct hdac_device *hdev,\n\t\t\tstruct hdac_hdmi_port *port)\n{\n\tunsigned int ver, mnl;\n\n\tver = (port->eld.eld_buffer[DRM_ELD_VER] & DRM_ELD_VER_MASK)\n\t\t\t\t\t\t>> DRM_ELD_VER_SHIFT;\n\n\tif (ver != ELD_VER_CEA_861D && ver != ELD_VER_PARTIAL) {\n\t\tdev_err(&hdev->dev, \"HDMI: Unknown ELD version %d\\n\", ver);\n\t\treturn -EINVAL;\n\t}\n\n\tmnl = (port->eld.eld_buffer[DRM_ELD_CEA_EDID_VER_MNL] &\n\t\tDRM_ELD_MNL_MASK) >> DRM_ELD_MNL_SHIFT;\n\n\tif (mnl > ELD_MAX_MNL) {\n\t\tdev_err(&hdev->dev, \"HDMI: MNL Invalid %d\\n\", mnl);\n\t\treturn -EINVAL;\n\t}\n\n\tport->eld.info.spk_alloc = port->eld.eld_buffer[DRM_ELD_SPEAKER];\n\n\treturn 0;\n}\n\nstatic void hdac_hdmi_present_sense(struct hdac_hdmi_pin *pin,\n\t\t\t\t    struct hdac_hdmi_port *port)\n{\n\tstruct hdac_device *hdev = pin->hdev;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm;\n\tint size = 0;\n\tint port_id = -1;\n\tbool eld_valid, eld_changed;\n\n\tif (!hdmi)\n\t\treturn;\n\n\t \n\tmutex_lock(&hdmi->pin_mutex);\n\tport->eld.monitor_present = false;\n\n\tif (pin->mst_capable)\n\t\tport_id = port->id;\n\n\tsize = snd_hdac_acomp_get_eld(hdev, pin->nid, port_id,\n\t\t\t\t&port->eld.monitor_present,\n\t\t\t\tport->eld.eld_buffer,\n\t\t\t\tELD_MAX_SIZE);\n\n\tif (size > 0) {\n\t\tsize = min(size, ELD_MAX_SIZE);\n\t\tif (hdac_hdmi_parse_eld(hdev, port) < 0)\n\t\t\tsize = -EINVAL;\n\t}\n\n\teld_valid = port->eld.eld_valid;\n\n\tif (size > 0) {\n\t\tport->eld.eld_valid = true;\n\t\tport->eld.eld_size = size;\n\t} else {\n\t\tport->eld.eld_valid = false;\n\t\tport->eld.eld_size = 0;\n\t}\n\n\teld_changed = (eld_valid != port->eld.eld_valid);\n\n\tpcm = hdac_hdmi_get_pcm(hdev, port);\n\n\tif (!port->eld.monitor_present || !port->eld.eld_valid) {\n\n\t\tdev_err(&hdev->dev, \"%s: disconnect for pin:port %d:%d\\n\",\n\t\t\t\t\t\t__func__, pin->nid, port->id);\n\n\t\t \n\t\tif (pcm) {\n\t\t\thdac_hdmi_jack_report(pcm, port, false);\n\t\t\tschedule_work(&port->dapm_work);\n\t\t}\n\n\t\tmutex_unlock(&hdmi->pin_mutex);\n\t\treturn;\n\t}\n\n\tif (port->eld.monitor_present && port->eld.eld_valid) {\n\t\tif (pcm) {\n\t\t\thdac_hdmi_jack_report(pcm, port, true);\n\t\t\tschedule_work(&port->dapm_work);\n\t\t}\n\n\t\tprint_hex_dump_debug(\"ELD: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  port->eld.eld_buffer, port->eld.eld_size, false);\n\n\t}\n\tmutex_unlock(&hdmi->pin_mutex);\n\n\tif (eld_changed && pcm)\n\t\tsnd_ctl_notify(hdmi->card,\n\t\t\t       SNDRV_CTL_EVENT_MASK_VALUE |\n\t\t\t       SNDRV_CTL_EVENT_MASK_INFO,\n\t\t\t       &pcm->eld_ctl->id);\n}\n\nstatic int hdac_hdmi_add_ports(struct hdac_device *hdev,\n\t\t\t       struct hdac_hdmi_pin *pin)\n{\n\tstruct hdac_hdmi_port *ports;\n\tint max_ports = HDA_MAX_PORTS;\n\tint i;\n\n\t \n\n\tports = devm_kcalloc(&hdev->dev, max_ports, sizeof(*ports), GFP_KERNEL);\n\tif (!ports)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_ports; i++) {\n\t\tports[i].id = i;\n\t\tports[i].pin = pin;\n\t\tINIT_WORK(&ports[i].dapm_work, hdac_hdmi_jack_dapm_work);\n\t}\n\tpin->ports = ports;\n\tpin->num_ports = max_ports;\n\treturn 0;\n}\n\nstatic int hdac_hdmi_add_pin(struct hdac_device *hdev, hda_nid_t nid)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pin *pin;\n\tint ret;\n\n\tpin = devm_kzalloc(&hdev->dev, sizeof(*pin), GFP_KERNEL);\n\tif (!pin)\n\t\treturn -ENOMEM;\n\n\tpin->nid = nid;\n\tpin->mst_capable = false;\n\tpin->hdev = hdev;\n\tret = hdac_hdmi_add_ports(hdev, pin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add_tail(&pin->head, &hdmi->pin_list);\n\thdmi->num_pin++;\n\thdmi->num_ports += pin->num_ports;\n\n\treturn 0;\n}\n\n#define INTEL_VENDOR_NID 0x08\n#define INTEL_GLK_VENDOR_NID 0x0b\n#define INTEL_GET_VENDOR_VERB 0xf81\n#define INTEL_SET_VENDOR_VERB 0x781\n#define INTEL_EN_DP12\t\t\t0x02  \n#define INTEL_EN_ALL_PIN_CVTS\t0x01  \n\nstatic void hdac_hdmi_skl_enable_all_pins(struct hdac_device *hdev)\n{\n\tunsigned int vendor_param;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tunsigned int vendor_nid = hdmi->drv_data->vendor_nid;\n\n\tvendor_param = snd_hdac_codec_read(hdev, vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_ALL_PIN_CVTS)\n\t\treturn;\n\n\tvendor_param |= INTEL_EN_ALL_PIN_CVTS;\n\tvendor_param = snd_hdac_codec_read(hdev, vendor_nid, 0,\n\t\t\t\tINTEL_SET_VENDOR_VERB, vendor_param);\n\tif (vendor_param == -1)\n\t\treturn;\n}\n\nstatic void hdac_hdmi_skl_enable_dp12(struct hdac_device *hdev)\n{\n\tunsigned int vendor_param;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tunsigned int vendor_nid = hdmi->drv_data->vendor_nid;\n\n\tvendor_param = snd_hdac_codec_read(hdev, vendor_nid, 0,\n\t\t\t\tINTEL_GET_VENDOR_VERB, 0);\n\tif (vendor_param == -1 || vendor_param & INTEL_EN_DP12)\n\t\treturn;\n\n\t \n\tvendor_param |= INTEL_EN_DP12;\n\tvendor_param = snd_hdac_codec_read(hdev, vendor_nid, 0,\n\t\t\t\tINTEL_SET_VENDOR_VERB, vendor_param);\n\tif (vendor_param == -1)\n\t\treturn;\n\n}\n\nstatic int hdac_hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct hdac_hdmi_port *port;\n\tstruct hdac_hdmi_eld *eld;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = 0;\n\n\tpcm = get_hdmi_pcm_from_id(hdmi, kcontrol->id.device);\n\tif (!pcm) {\n\t\tdev_dbg(component->dev, \"%s: no pcm, device %d\\n\", __func__,\n\t\t\tkcontrol->id.device);\n\t\treturn 0;\n\t}\n\n\tif (list_empty(&pcm->port_list)) {\n\t\tdev_dbg(component->dev, \"%s: empty port list, device %d\\n\",\n\t\t\t__func__, kcontrol->id.device);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&hdmi->pin_mutex);\n\n\tlist_for_each_entry(port, &pcm->port_list, head) {\n\t\teld = &port->eld;\n\n\t\tif (eld->eld_valid) {\n\t\t\tuinfo->count = eld->eld_size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&hdmi->pin_mutex);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct hdac_hdmi_port *port;\n\tstruct hdac_hdmi_eld *eld;\n\n\tmemset(ucontrol->value.bytes.data, 0, sizeof(ucontrol->value.bytes.data));\n\n\tpcm = get_hdmi_pcm_from_id(hdmi, kcontrol->id.device);\n\tif (!pcm) {\n\t\tdev_dbg(component->dev, \"%s: no pcm, device %d\\n\", __func__,\n\t\t\tkcontrol->id.device);\n\t\treturn 0;\n\t}\n\n\tif (list_empty(&pcm->port_list)) {\n\t\tdev_dbg(component->dev, \"%s: empty port list, device %d\\n\",\n\t\t\t__func__, kcontrol->id.device);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&hdmi->pin_mutex);\n\n\tlist_for_each_entry(port, &pcm->port_list, head) {\n\t\teld = &port->eld;\n\n\t\tif (!eld->eld_valid)\n\t\t\tcontinue;\n\n\t\tif (eld->eld_size > ARRAY_SIZE(ucontrol->value.bytes.data) ||\n\t\t    eld->eld_size > ELD_MAX_SIZE) {\n\t\t\tmutex_unlock(&hdmi->pin_mutex);\n\n\t\t\tdev_err(component->dev, \"%s: buffer too small, device %d eld_size %d\\n\",\n\t\t\t\t__func__, kcontrol->id.device, eld->eld_size);\n\t\t\tsnd_BUG();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(ucontrol->value.bytes.data, eld->eld_buffer,\n\t\t       eld->eld_size);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&hdmi->pin_mutex);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_create_eld_ctl(struct snd_soc_component *component, struct hdac_hdmi_pcm *pcm)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_new hdmi_eld_ctl = {\n\t\t.access\t= SNDRV_CTL_ELEM_ACCESS_READ |\n\t\t\t  SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.iface\t= SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name\t= \"ELD\",\n\t\t.info\t= hdac_hdmi_eld_ctl_info,\n\t\t.get\t= hdac_hdmi_eld_ctl_get,\n\t\t.device\t= pcm->pcm_id,\n\t};\n\n\t \n\tkctl = snd_ctl_new1(&hdmi_eld_ctl, component);\n\tif (!kctl)\n\t\treturn -ENOMEM;\n\n\tpcm->eld_ctl = kctl;\n\n\treturn snd_ctl_add(component->card->snd_card, kctl);\n}\n\nstatic const struct snd_soc_dai_ops hdmi_dai_ops = {\n\t.startup = hdac_hdmi_pcm_open,\n\t.shutdown = hdac_hdmi_pcm_close,\n\t.hw_params = hdac_hdmi_set_hw_params,\n\t.set_stream = hdac_hdmi_set_stream,\n};\n\n \nstatic int hdac_hdmi_create_dais(struct hdac_device *hdev,\n\t\tstruct snd_soc_dai_driver **dais,\n\t\tstruct hdac_hdmi_priv *hdmi, int num_dais)\n{\n\tstruct snd_soc_dai_driver *hdmi_dais;\n\tstruct hdac_hdmi_cvt *cvt;\n\tchar name[NAME_SIZE], dai_name[NAME_SIZE];\n\tint i = 0;\n\tu32 rates, bps;\n\tunsigned int rate_max = 384000, rate_min = 8000;\n\tu64 formats;\n\tint ret;\n\n\thdmi_dais = devm_kzalloc(&hdev->dev,\n\t\t\t(sizeof(*hdmi_dais) * num_dais),\n\t\t\tGFP_KERNEL);\n\tif (!hdmi_dais)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(cvt, &hdmi->cvt_list, head) {\n\t\tret = snd_hdac_query_supported_pcm(hdev, cvt->nid,\n\t\t\t\t\t&rates,\t&formats, &bps);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\trates &= ~(SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_88200 |\n\t\t\t   SNDRV_PCM_RATE_176400);\n\t\tif (!rates)\n\t\t\treturn -EINVAL;\n\n\t\tsprintf(dai_name, \"intel-hdmi-hifi%d\", i+1);\n\t\thdmi_dais[i].name = devm_kstrdup(&hdev->dev,\n\t\t\t\t\tdai_name, GFP_KERNEL);\n\n\t\tif (!hdmi_dais[i].name)\n\t\t\treturn -ENOMEM;\n\n\t\tsnprintf(name, sizeof(name), \"hifi%d\", i+1);\n\t\thdmi_dais[i].playback.stream_name =\n\t\t\t\tdevm_kstrdup(&hdev->dev, name, GFP_KERNEL);\n\t\tif (!hdmi_dais[i].playback.stream_name)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\thdmi_dais[i].playback.formats = formats;\n\t\thdmi_dais[i].playback.rates = rates;\n\t\thdmi_dais[i].playback.rate_max = rate_max;\n\t\thdmi_dais[i].playback.rate_min = rate_min;\n\t\thdmi_dais[i].playback.channels_min = 2;\n\t\thdmi_dais[i].playback.channels_max = 2;\n\t\thdmi_dais[i].playback.sig_bits = bps;\n\t\thdmi_dais[i].ops = &hdmi_dai_ops;\n\t\ti++;\n\t}\n\n\t*dais = hdmi_dais;\n\thdmi->dai_drv = hdmi_dais;\n\n\treturn 0;\n}\n\n \nstatic int hdac_hdmi_parse_and_map_nid(struct hdac_device *hdev,\n\t\tstruct snd_soc_dai_driver **dais, int *num_dais)\n{\n\thda_nid_t nid;\n\tint i, num_nodes;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tint ret;\n\n\thdac_hdmi_skl_enable_all_pins(hdev);\n\thdac_hdmi_skl_enable_dp12(hdev);\n\n\tnum_nodes = snd_hdac_get_sub_nodes(hdev, hdev->afg, &nid);\n\tif (!nid || num_nodes <= 0) {\n\t\tdev_warn(&hdev->dev, \"HDMI: failed to get afg sub nodes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_nodes; i++, nid++) {\n\t\tunsigned int caps;\n\t\tunsigned int type;\n\n\t\tcaps = get_wcaps(hdev, nid);\n\t\ttype = get_wcaps_type(caps);\n\n\t\tif (!(caps & AC_WCAP_DIGITAL))\n\t\t\tcontinue;\n\n\t\tswitch (type) {\n\n\t\tcase AC_WID_AUD_OUT:\n\t\t\tret = hdac_hdmi_add_cvt(hdev, nid);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\n\t\tcase AC_WID_PIN:\n\t\t\tret = hdac_hdmi_add_pin(hdev, nid);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!hdmi->num_pin || !hdmi->num_cvt) {\n\t\tret = -EIO;\n\t\tdev_err(&hdev->dev, \"Bad pin/cvt setup in %s\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = hdac_hdmi_create_dais(hdev, dais, hdmi, hdmi->num_cvt);\n\tif (ret) {\n\t\tdev_err(&hdev->dev, \"Failed to create dais with err: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*num_dais = hdmi->num_cvt;\n\tret = hdac_hdmi_init_dai_map(hdev);\n\tif (ret < 0)\n\t\tdev_err(&hdev->dev, \"Failed to init DAI map with err: %d\\n\",\n\t\t\tret);\n\treturn ret;\n}\n\nstatic int hdac_hdmi_pin2port(void *aptr, int pin)\n{\n\treturn pin - 4;  \n}\n\nstatic void hdac_hdmi_eld_notify_cb(void *aptr, int port, int pipe)\n{\n\tstruct hdac_device *hdev = aptr;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pin *pin;\n\tstruct hdac_hdmi_port *hport = NULL;\n\tstruct snd_soc_component *component = hdmi->component;\n\tint i;\n\n\t \n\thda_nid_t pin_nid = port + 0x04;\n\n\tdev_dbg(&hdev->dev, \"%s: for pin:%d port=%d\\n\", __func__,\n\t\t\t\t\t\t\tpin_nid, pipe);\n\n\t \n\tif (snd_power_get_state(component->card->snd_card) !=\n\t\t\tSNDRV_CTL_POWER_D0)\n\t\treturn;\n\n\tif (atomic_read(&hdev->in_pm))\n\t\treturn;\n\n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tif (pin->nid != pin_nid)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pipe == -1) {\n\t\t\tpin->mst_capable = false;\n\t\t\t \n\t\t\thport = &pin->ports[0];\n\t\t} else {\n\t\t\tfor (i = 0; i < pin->num_ports; i++) {\n\t\t\t\tpin->mst_capable = true;\n\t\t\t\tif (pin->ports[i].id == pipe) {\n\t\t\t\t\thport = &pin->ports[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hport)\n\t\t\thdac_hdmi_present_sense(pin, hport);\n\t}\n\n}\n\nstatic struct drm_audio_component_audio_ops aops = {\n\t.pin2port\t= hdac_hdmi_pin2port,\n\t.pin_eld_notify\t= hdac_hdmi_eld_notify_cb,\n};\n\nstatic struct snd_pcm *hdac_hdmi_get_pcm_from_id(struct snd_soc_card *card,\n\t\t\t\t\t\tint device)\n{\n\tstruct snd_soc_pcm_runtime *rtd;\n\n\tfor_each_card_rtds(card, rtd) {\n\t\tif (rtd->pcm && (rtd->pcm->device == device))\n\t\t\treturn rtd->pcm;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int create_fill_jack_kcontrols(struct snd_soc_card *card,\n\t\t\t\t    struct hdac_device *hdev)\n{\n\tstruct hdac_hdmi_pin *pin;\n\tstruct snd_kcontrol_new *kc;\n\tchar kc_name[NAME_SIZE], xname[NAME_SIZE];\n\tchar *name;\n\tint i = 0, j;\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct snd_soc_component *component = hdmi->component;\n\n\tkc = devm_kcalloc(component->dev, hdmi->num_ports,\n\t\t\t\tsizeof(*kc), GFP_KERNEL);\n\n\tif (!kc)\n\t\treturn -ENOMEM;\n\n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++) {\n\t\t\tsnprintf(xname, sizeof(xname), \"hif%d-%d Jack\",\n\t\t\t\t\t\tpin->nid, pin->ports[j].id);\n\t\t\tname = devm_kstrdup(component->dev, xname, GFP_KERNEL);\n\t\t\tif (!name)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsnprintf(kc_name, sizeof(kc_name), \"%s Switch\", xname);\n\t\t\tkc[i].name = devm_kstrdup(component->dev, kc_name,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!kc[i].name)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tkc[i].private_value = (unsigned long)name;\n\t\t\tkc[i].iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\t\t\tkc[i].access = 0;\n\t\t\tkc[i].info = snd_soc_dapm_info_pin_switch;\n\t\t\tkc[i].put = snd_soc_dapm_put_pin_switch;\n\t\t\tkc[i].get = snd_soc_dapm_get_pin_switch;\n\t\t\ti++;\n\t\t}\n\t}\n\n\treturn snd_soc_add_card_controls(card, kc, i);\n}\n\nint hdac_hdmi_jack_port_init(struct snd_soc_component *component,\n\t\t\tstruct snd_soc_dapm_context *dapm)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tstruct hdac_hdmi_pin *pin;\n\tstruct snd_soc_dapm_widget *widgets;\n\tstruct snd_soc_dapm_route *route;\n\tchar w_name[NAME_SIZE];\n\tint i = 0, j, ret;\n\n\twidgets = devm_kcalloc(dapm->dev, hdmi->num_ports,\n\t\t\t\tsizeof(*widgets), GFP_KERNEL);\n\n\tif (!widgets)\n\t\treturn -ENOMEM;\n\n\troute = devm_kcalloc(dapm->dev, hdmi->num_ports,\n\t\t\t\tsizeof(*route), GFP_KERNEL);\n\tif (!route)\n\t\treturn -ENOMEM;\n\n\t \n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++) {\n\t\t\tsnprintf(w_name, sizeof(w_name), \"hif%d-%d Jack\",\n\t\t\t\t\t\tpin->nid, pin->ports[j].id);\n\n\t\t\tret = hdac_hdmi_fill_widget_info(dapm->dev, &widgets[i],\n\t\t\t\t\tsnd_soc_dapm_spk, NULL,\n\t\t\t\t\tw_name, NULL, NULL, 0, NULL, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tpin->ports[j].jack_pin = widgets[i].name;\n\t\t\tpin->ports[j].dapm = dapm;\n\n\t\t\t \n\t\t\thdac_hdmi_fill_route(&route[i], pin->ports[j].jack_pin,\n\t\t\t\t\tNULL, pin->ports[j].output_pin, NULL);\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\t \n\tret = snd_soc_dapm_new_controls(dapm, widgets, hdmi->num_ports);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_add_routes(dapm, route, hdmi->num_ports);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_new_widgets(dapm->card);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = create_fill_jack_kcontrols(dapm->card, hdev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tfor (j = 0; j < pin->num_ports; j++)\n\t\t\tsnd_soc_dapm_disable_pin(pin->ports[j].dapm,\n\t\t\t\t\t\tpin->ports[j].jack_pin);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hdac_hdmi_jack_port_init);\n\nint hdac_hdmi_jack_init(struct snd_soc_dai *dai, int device,\n\t\t\t\tstruct snd_soc_jack *jack)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tstruct hdac_hdmi_pcm *pcm;\n\tstruct snd_pcm *snd_pcm;\n\tint err;\n\n\t \n\tpcm = devm_kzalloc(&hdev->dev, sizeof(*pcm), GFP_KERNEL);\n\tif (!pcm)\n\t\treturn -ENOMEM;\n\tpcm->pcm_id = device;\n\tpcm->cvt = hdmi->dai_map[dai->id].cvt;\n\tpcm->jack_event = 0;\n\tpcm->jack = jack;\n\tmutex_init(&pcm->lock);\n\tINIT_LIST_HEAD(&pcm->port_list);\n\tsnd_pcm = hdac_hdmi_get_pcm_from_id(dai->component->card, device);\n\tif (snd_pcm) {\n\t\terr = snd_hdac_add_chmap_ctls(snd_pcm, device, &hdmi->chmap);\n\t\tif (err < 0) {\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"chmap control add failed with err: %d for pcm: %d\\n\",\n\t\t\t\terr, device);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = hdac_hdmi_create_eld_ctl(component, pcm);\n\tif (err < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"eld control add failed with err: %d for pcm: %d\\n\",\n\t\t\terr, device);\n\t\treturn err;\n\t}\n\n\tlist_add_tail(&pcm->head, &hdmi->pcm_list);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hdac_hdmi_jack_init);\n\nstatic void hdac_hdmi_present_sense_all_pins(struct hdac_device *hdev,\n\t\t\tstruct hdac_hdmi_priv *hdmi, bool detect_pin_caps)\n{\n\tint i;\n\tstruct hdac_hdmi_pin *pin;\n\n\tlist_for_each_entry(pin, &hdmi->pin_list, head) {\n\t\tif (detect_pin_caps) {\n\n\t\t\tif (hdac_hdmi_get_port_len(hdev, pin->nid)  == 0)\n\t\t\t\tpin->mst_capable = false;\n\t\t\telse\n\t\t\t\tpin->mst_capable = true;\n\t\t}\n\n\t\tfor (i = 0; i < pin->num_ports; i++) {\n\t\t\tif (!pin->mst_capable && i > 0)\n\t\t\t\tcontinue;\n\n\t\t\thdac_hdmi_present_sense(pin, &pin->ports[i]);\n\t\t}\n\t}\n}\n\nstatic int hdmi_codec_probe(struct snd_soc_component *component)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_component_get_dapm(component);\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\thdmi->component = component;\n\n\t \n\thlink = snd_hdac_ext_bus_get_hlink_by_name(hdev->bus, dev_name(&hdev->dev));\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnd_hdac_ext_bus_link_get(hdev->bus, hlink);\n\n\tret = create_fill_widget_route_map(dapm);\n\tif (ret < 0)\n\t\treturn ret;\n\n\taops.audio_ptr = hdev;\n\tret = snd_hdac_acomp_register_notifier(hdev->bus, &aops);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"notifier register failed: err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thdac_hdmi_present_sense_all_pins(hdev, hdmi, true);\n\t \n\thdmi->card = dapm->card->snd_card;\n\n\t \n\tdevice_link_add(component->card->dev, &hdev->dev, DL_FLAG_RPM_ACTIVE |\n\t\t\tDL_FLAG_AUTOREMOVE_CONSUMER);\n\t \n\tpm_runtime_enable(&hdev->dev);\n\tpm_runtime_put(&hdev->dev);\n\tpm_runtime_suspend(&hdev->dev);\n\n\treturn 0;\n}\n\nstatic void hdmi_codec_remove(struct snd_soc_component *component)\n{\n\tstruct hdac_hdmi_priv *hdmi = snd_soc_component_get_drvdata(component);\n\tstruct hdac_device *hdev = hdmi->hdev;\n\tint ret;\n\n\tret = snd_hdac_acomp_register_notifier(hdev->bus, NULL);\n\tif (ret < 0)\n\t\tdev_err(&hdev->dev, \"notifier unregister failed: err: %d\\n\",\n\t\t\t\tret);\n\n\tpm_runtime_disable(&hdev->dev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int hdmi_codec_resume(struct device *dev)\n{\n\tstruct hdac_device *hdev = dev_to_hdac_dev(dev);\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\thdac_hdmi_present_sense_all_pins(hdev, hdmi, false);\n\treturn 0;\n}\n#else\n#define hdmi_codec_resume NULL\n#endif\n\nstatic const struct snd_soc_component_driver hdmi_hda_codec = {\n\t.probe\t\t\t= hdmi_codec_probe,\n\t.remove\t\t\t= hdmi_codec_remove,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic void hdac_hdmi_get_chmap(struct hdac_device *hdev, int pcm_idx,\n\t\t\t\t\tunsigned char *chmap)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm = get_hdmi_pcm_from_id(hdmi, pcm_idx);\n\n\tmemcpy(chmap, pcm->chmap, ARRAY_SIZE(pcm->chmap));\n}\n\nstatic void hdac_hdmi_set_chmap(struct hdac_device *hdev, int pcm_idx,\n\t\t\t\tunsigned char *chmap, int prepared)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm = get_hdmi_pcm_from_id(hdmi, pcm_idx);\n\tstruct hdac_hdmi_port *port;\n\n\tif (!pcm)\n\t\treturn;\n\n\tif (list_empty(&pcm->port_list))\n\t\treturn;\n\n\tmutex_lock(&pcm->lock);\n\tpcm->chmap_set = true;\n\tmemcpy(pcm->chmap, chmap, ARRAY_SIZE(pcm->chmap));\n\tlist_for_each_entry(port, &pcm->port_list, head)\n\t\tif (prepared)\n\t\t\thdac_hdmi_setup_audio_infoframe(hdev, pcm, port);\n\tmutex_unlock(&pcm->lock);\n}\n\nstatic bool is_hdac_hdmi_pcm_attached(struct hdac_device *hdev, int pcm_idx)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm = get_hdmi_pcm_from_id(hdmi, pcm_idx);\n\n\tif (!pcm)\n\t\treturn false;\n\n\tif (list_empty(&pcm->port_list))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int hdac_hdmi_get_spk_alloc(struct hdac_device *hdev, int pcm_idx)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pcm *pcm = get_hdmi_pcm_from_id(hdmi, pcm_idx);\n\tstruct hdac_hdmi_port *port;\n\n\tif (!pcm)\n\t\treturn 0;\n\n\tif (list_empty(&pcm->port_list))\n\t\treturn 0;\n\n\tport = list_first_entry(&pcm->port_list, struct hdac_hdmi_port, head);\n\n\tif (!port || !port->eld.eld_valid)\n\t\treturn 0;\n\n\treturn port->eld.info.spk_alloc;\n}\n\nstatic struct hdac_hdmi_drv_data intel_glk_drv_data  = {\n\t.vendor_nid = INTEL_GLK_VENDOR_NID,\n};\n\nstatic struct hdac_hdmi_drv_data intel_drv_data  = {\n\t.vendor_nid = INTEL_VENDOR_NID,\n};\n\nstatic int hdac_hdmi_dev_probe(struct hdac_device *hdev)\n{\n\tstruct hdac_hdmi_priv *hdmi_priv;\n\tstruct snd_soc_dai_driver *hdmi_dais = NULL;\n\tstruct hdac_ext_link *hlink;\n\tint num_dais = 0;\n\tint ret;\n\tstruct hdac_driver *hdrv = drv_to_hdac_driver(hdev->dev.driver);\n\tconst struct hda_device_id *hdac_id = hdac_get_device_id(hdev, hdrv);\n\n\t \n\thlink = snd_hdac_ext_bus_get_hlink_by_name(hdev->bus, dev_name(&hdev->dev));\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnd_hdac_ext_bus_link_get(hdev->bus, hlink);\n\n\thdmi_priv = devm_kzalloc(&hdev->dev, sizeof(*hdmi_priv), GFP_KERNEL);\n\tif (hdmi_priv == NULL)\n\t\treturn -ENOMEM;\n\n\tsnd_hdac_register_chmap_ops(hdev, &hdmi_priv->chmap);\n\thdmi_priv->chmap.ops.get_chmap = hdac_hdmi_get_chmap;\n\thdmi_priv->chmap.ops.set_chmap = hdac_hdmi_set_chmap;\n\thdmi_priv->chmap.ops.is_pcm_attached = is_hdac_hdmi_pcm_attached;\n\thdmi_priv->chmap.ops.get_spk_alloc = hdac_hdmi_get_spk_alloc;\n\thdmi_priv->hdev = hdev;\n\n\tif (!hdac_id)\n\t\treturn -ENODEV;\n\n\tif (hdac_id->driver_data)\n\t\thdmi_priv->drv_data =\n\t\t\t(struct hdac_hdmi_drv_data *)hdac_id->driver_data;\n\telse\n\t\thdmi_priv->drv_data = &intel_drv_data;\n\n\tdev_set_drvdata(&hdev->dev, hdmi_priv);\n\n\tINIT_LIST_HEAD(&hdmi_priv->pin_list);\n\tINIT_LIST_HEAD(&hdmi_priv->cvt_list);\n\tINIT_LIST_HEAD(&hdmi_priv->pcm_list);\n\tmutex_init(&hdmi_priv->pin_mutex);\n\n\t \n\tsnd_hdac_display_power(hdev->bus, hdev->addr, true);\n\n\tret = hdac_hdmi_parse_and_map_nid(hdev, &hdmi_dais, &num_dais);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"Failed in parse and map nid with err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tsnd_hdac_refresh_widgets(hdev);\n\n\t \n\tret = devm_snd_soc_register_component(&hdev->dev, &hdmi_hda_codec,\n\t\t\t\t\thdmi_dais, num_dais);\n\n\tsnd_hdac_ext_bus_link_put(hdev->bus, hlink);\n\n\treturn ret;\n}\n\nstatic void clear_dapm_works(struct hdac_device *hdev)\n{\n\tstruct hdac_hdmi_priv *hdmi = hdev_to_hdmi_priv(hdev);\n\tstruct hdac_hdmi_pin *pin;\n\tint i;\n\n\tlist_for_each_entry(pin, &hdmi->pin_list, head)\n\t\tfor (i = 0; i < pin->num_ports; i++)\n\t\t\tcancel_work_sync(&pin->ports[i].dapm_work);\n}\n\nstatic int hdac_hdmi_dev_remove(struct hdac_device *hdev)\n{\n\tclear_dapm_works(hdev);\n\tsnd_hdac_display_power(hdev->bus, hdev->addr, false);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int hdac_hdmi_runtime_suspend(struct device *dev)\n{\n\tstruct hdac_device *hdev = dev_to_hdac_dev(dev);\n\tstruct hdac_bus *bus = hdev->bus;\n\tstruct hdac_ext_link *hlink;\n\n\tdev_dbg(dev, \"Enter: %s\\n\", __func__);\n\n\t \n\tif (!bus)\n\t\treturn 0;\n\n\t \n\tsnd_hdac_codec_read(hdev, hdev->afg, 0,\tAC_VERB_SET_POWER_STATE,\n\t\t\t\t\t\t\tAC_PWRST_D3);\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_name(bus, dev_name(dev));\n\tif (!hlink) {\n\t\tdev_err(dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnd_hdac_codec_link_down(hdev);\n\tsnd_hdac_ext_bus_link_put(bus, hlink);\n\n\tsnd_hdac_display_power(bus, hdev->addr, false);\n\n\treturn 0;\n}\n\nstatic int hdac_hdmi_runtime_resume(struct device *dev)\n{\n\tstruct hdac_device *hdev = dev_to_hdac_dev(dev);\n\tstruct hdac_bus *bus = hdev->bus;\n\tstruct hdac_ext_link *hlink;\n\n\tdev_dbg(dev, \"Enter: %s\\n\", __func__);\n\n\t \n\tif (!bus)\n\t\treturn 0;\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_name(bus, dev_name(dev));\n\tif (!hlink) {\n\t\tdev_err(dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnd_hdac_ext_bus_link_get(bus, hlink);\n\tsnd_hdac_codec_link_up(hdev);\n\n\tsnd_hdac_display_power(bus, hdev->addr, true);\n\n\thdac_hdmi_skl_enable_all_pins(hdev);\n\thdac_hdmi_skl_enable_dp12(hdev);\n\n\t \n\tsnd_hdac_codec_read(hdev, hdev->afg, 0,\tAC_VERB_SET_POWER_STATE,\n\t\t\t\t\t\t\tAC_PWRST_D0);\n\n\treturn 0;\n}\n#else\n#define hdac_hdmi_runtime_suspend NULL\n#define hdac_hdmi_runtime_resume NULL\n#endif\n\nstatic const struct dev_pm_ops hdac_hdmi_pm = {\n\tSET_RUNTIME_PM_OPS(hdac_hdmi_runtime_suspend, hdac_hdmi_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, hdmi_codec_resume)\n};\n\nstatic const struct hda_device_id hdmi_list[] = {\n\tHDA_CODEC_EXT_ENTRY(0x80862809, 0x100000, \"Skylake HDMI\", 0),\n\tHDA_CODEC_EXT_ENTRY(0x8086280a, 0x100000, \"Broxton HDMI\", 0),\n\tHDA_CODEC_EXT_ENTRY(0x8086280b, 0x100000, \"Kabylake HDMI\", 0),\n\tHDA_CODEC_EXT_ENTRY(0x8086280c, 0x100000, \"Cannonlake HDMI\",\n\t\t\t\t\t\t   &intel_glk_drv_data),\n\tHDA_CODEC_EXT_ENTRY(0x8086280d, 0x100000, \"Geminilake HDMI\",\n\t\t\t\t\t\t   &intel_glk_drv_data),\n\t{}\n};\n\nMODULE_DEVICE_TABLE(hdaudio, hdmi_list);\n\nstatic struct hdac_driver hdmi_driver = {\n\t.driver = {\n\t\t.name   = \"HDMI HDA Codec\",\n\t\t.pm = &hdac_hdmi_pm,\n\t},\n\t.id_table       = hdmi_list,\n\t.probe          = hdac_hdmi_dev_probe,\n\t.remove         = hdac_hdmi_dev_remove,\n};\n\nstatic int __init hdmi_init(void)\n{\n\treturn snd_hda_ext_driver_register(&hdmi_driver);\n}\n\nstatic void __exit hdmi_exit(void)\n{\n\tsnd_hda_ext_driver_unregister(&hdmi_driver);\n}\n\nmodule_init(hdmi_init);\nmodule_exit(hdmi_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"HDMI HD codec\");\nMODULE_AUTHOR(\"Samreen Nilofer<samreen.nilofer@intel.com>\");\nMODULE_AUTHOR(\"Subhransu S. Prusty<subhransu.s.prusty@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}