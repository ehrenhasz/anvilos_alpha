{
  "module_name": "mt6660.c",
  "hash_id": "3bca3c28f44f5107c295a2d44c4f21a3525e5610c96f3d83b5e34cf995fb3f7d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/mt6660.c",
  "human_readable_source": "\n\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/i2c.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/pcm_params.h>\n\n#include \"mt6660.h\"\n\nstruct reg_size_table {\n\tu32 addr;\n\tu8 size;\n};\n\nstatic const struct reg_size_table mt6660_reg_size_table[] = {\n\t{ MT6660_REG_HPF1_COEF, 4 },\n\t{ MT6660_REG_HPF2_COEF, 4 },\n\t{ MT6660_REG_TDM_CFG3, 2 },\n\t{ MT6660_REG_RESV17, 2 },\n\t{ MT6660_REG_RESV23, 2 },\n\t{ MT6660_REG_SIGMAX, 2 },\n\t{ MT6660_REG_DEVID, 2 },\n\t{ MT6660_REG_HCLIP_CTRL, 2 },\n\t{ MT6660_REG_DA_GAIN, 2 },\n};\n\nstatic int mt6660_get_reg_size(uint32_t addr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt6660_reg_size_table); i++) {\n\t\tif (mt6660_reg_size_table[i].addr == addr)\n\t\t\treturn mt6660_reg_size_table[i].size;\n\t}\n\treturn 1;\n}\n\nstatic int mt6660_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct mt6660_chip *chip = context;\n\tint size = mt6660_get_reg_size(reg);\n\tu8 reg_data[4];\n\tint i;\n\n\tfor (i = 0; i < size; i++)\n\t\treg_data[size - i - 1] = (val >> (8 * i)) & 0xff;\n\n\treturn i2c_smbus_write_i2c_block_data(chip->i2c, reg, size, reg_data);\n}\n\nstatic int mt6660_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct mt6660_chip *chip = context;\n\tint size = mt6660_get_reg_size(reg);\n\tint i, ret;\n\tu8 data[4];\n\tu32 reg_data = 0;\n\n\tret = i2c_smbus_read_i2c_block_data(chip->i2c, reg, size, data);\n\tif (ret < 0)\n\t\treturn ret;\n\tfor (i = 0; i < size; i++) {\n\t\treg_data <<= 8;\n\t\treg_data |= data[i];\n\t}\n\t*val = reg_data;\n\treturn 0;\n}\n\nstatic const struct regmap_config mt6660_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_write = mt6660_reg_write,\n\t.reg_read = mt6660_reg_read,\n};\n\nstatic int mt6660_codec_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tif (event == SND_SOC_DAPM_POST_PMU)\n\t\tusleep_range(1000, 1100);\n\treturn 0;\n}\n\nstatic int mt6660_codec_classd_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tdev_dbg(component->dev,\n\t\t\t\"%s: before classd turn on\\n\", __func__);\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_BST_CTRL, 0x03, 0x03);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"config mode adaptive fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_RESV7, 0x04, 0x04);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"enable voltage sensing fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(component->dev, \"Amp on\\n\");\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tdev_dbg(component->dev, \"Amp off\\n\");\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_RESV7, 0x04, 0x00);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"disable voltage sensing fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_RESV10, 0x10, 0x10);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"pop-noise improvement 1 fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tdev_dbg(component->dev,\n\t\t\t\"%s: after classd turn off\\n\", __func__);\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_RESV10, 0x10, 0x00);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"pop-noise improvement 2 fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = snd_soc_component_update_bits(component,\n\t\t\tMT6660_REG_BST_CTRL, 0x03, 0x00);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"config mode off fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget mt6660_component_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, MT6660_REG_PLL_CFG1,\n\t\t0, 1, mt6660_codec_dac_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_ADC(\"VI ADC\", NULL, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_PGA(\"PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUT_DRV_E(\"ClassD\", MT6660_REG_SYSTEM_CTRL, 2, 0,\n\t\t\t       NULL, 0, mt6660_codec_classd_event,\n\t\t\t       SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUTP\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUTN\"),\n};\n\nstatic const struct snd_soc_dapm_route mt6660_component_dapm_routes[] = {\n\t{ \"DAC\", NULL, \"aif_playback\" },\n\t{ \"PGA\", NULL, \"DAC\" },\n\t{ \"ClassD\", NULL, \"PGA\" },\n\t{ \"OUTP\", NULL, \"ClassD\" },\n\t{ \"OUTN\", NULL, \"ClassD\" },\n\t{ \"VI ADC\", NULL, \"ClassD\" },\n\t{ \"aif_capture\", NULL, \"VI ADC\" },\n};\n\nstatic int mt6660_component_get_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct mt6660_chip *chip = (struct mt6660_chip *)\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = chip->chip_rev & 0x0f;\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(vol_ctl_tlv, -1155, 5, 0);\n\nstatic const struct snd_kcontrol_new mt6660_component_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Digital Volume\", MT6660_REG_VOL_CTRL, 0, 255,\n\t\t\t   1, vol_ctl_tlv),\n\tSOC_SINGLE(\"Hard Clip Switch\", MT6660_REG_HCLIP_CTRL, 8, 1, 0),\n\tSOC_SINGLE(\"Clip Switch\", MT6660_REG_SPS_CTRL, 0, 1, 0),\n\tSOC_SINGLE(\"Boost Mode\", MT6660_REG_BST_CTRL, 0, 3, 0),\n\tSOC_SINGLE(\"DRE Switch\", MT6660_REG_DRE_CTRL, 0, 1, 0),\n\tSOC_SINGLE(\"DC Protect Switch\",\tMT6660_REG_DC_PROTECT_CTRL, 3, 1, 0),\n\tSOC_SINGLE(\"Data Output Left Channel Selection\",\n\t\t   MT6660_REG_DATAO_SEL, 3, 7, 0),\n\tSOC_SINGLE(\"Data Output Right Channel Selection\",\n\t\t   MT6660_REG_DATAO_SEL, 0, 7, 0),\n\tSOC_SINGLE_EXT(\"T0 SEL\", MT6660_REG_CALI_T0, 0, 7, 0,\n\t\t       snd_soc_get_volsw, NULL),\n\tSOC_SINGLE_EXT(\"Chip Rev\", MT6660_REG_DEVID, 8, 15, 0,\n\t\t       mt6660_component_get_volsw, NULL),\n};\n\nstatic int _mt6660_chip_power_on(struct mt6660_chip *chip, int on_off)\n{\n\treturn regmap_write_bits(chip->regmap, MT6660_REG_SYSTEM_CTRL,\n\t\t\t\t 0x01, on_off ? 0x00 : 0x01);\n}\n\nstruct reg_table {\n\tuint32_t addr;\n\tuint32_t mask;\n\tuint32_t val;\n};\n\nstatic const struct reg_table mt6660_setting_table[] = {\n\t{ 0x20, 0x80, 0x00 },\n\t{ 0x30, 0x01, 0x00 },\n\t{ 0x50, 0x1c, 0x04 },\n\t{ 0xB1, 0x0c, 0x00 },\n\t{ 0xD3, 0x03, 0x03 },\n\t{ 0xE0, 0x01, 0x00 },\n\t{ 0x98, 0x44, 0x04 },\n\t{ 0xB9, 0xff, 0x82 },\n\t{ 0xB7, 0x7777, 0x7273 },\n\t{ 0xB6, 0x07, 0x03 },\n\t{ 0x6B, 0xe0, 0x20 },\n\t{ 0x07, 0xff, 0x70 },\n\t{ 0xBB, 0xff, 0x20 },\n\t{ 0x69, 0xff, 0x40 },\n\t{ 0xBD, 0xffff, 0x17f8 },\n\t{ 0x70, 0xff, 0x15 },\n\t{ 0x7C, 0xff, 0x00 },\n\t{ 0x46, 0xff, 0x1d },\n\t{ 0x1A, 0xffffffff, 0x7fdb7ffe },\n\t{ 0x1B, 0xffffffff, 0x7fdb7ffe },\n\t{ 0x51, 0xff, 0x58 },\n\t{ 0xA2, 0xff, 0xce },\n\t{ 0x33, 0xffff, 0x7fff },\n\t{ 0x4C, 0xffff, 0x0116 },\n\t{ 0x16, 0x1800, 0x0800 },\n\t{ 0x68, 0x1f, 0x07 },\n};\n\nstatic int mt6660_component_setting(struct snd_soc_component *component)\n{\n\tstruct mt6660_chip *chip = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\tsize_t i = 0;\n\n\tret = _mt6660_chip_power_on(chip, 1);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"%s chip power on failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mt6660_setting_table); i++) {\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\tmt6660_setting_table[i].addr,\n\t\t\t\tmt6660_setting_table[i].mask,\n\t\t\t\tmt6660_setting_table[i].val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"%s update 0x%02x failed\\n\",\n\t\t\t\t__func__, mt6660_setting_table[i].addr);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = _mt6660_chip_power_on(chip, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"%s chip power off failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mt6660_component_probe(struct snd_soc_component *component)\n{\n\tstruct mt6660_chip *chip = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tdev_dbg(component->dev, \"%s\\n\", __func__);\n\tsnd_soc_component_init_regmap(component, chip->regmap);\n\n\tret = mt6660_component_setting(component);\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"mt6660 component setting failed\\n\");\n\n\treturn ret;\n}\n\nstatic void mt6660_component_remove(struct snd_soc_component *component)\n{\n\tdev_dbg(component->dev, \"%s\\n\", __func__);\n\tsnd_soc_component_exit_regmap(component);\n}\n\nstatic const struct snd_soc_component_driver mt6660_component_driver = {\n\t.probe = mt6660_component_probe,\n\t.remove = mt6660_component_remove,\n\n\t.controls = mt6660_component_snd_controls,\n\t.num_controls = ARRAY_SIZE(mt6660_component_snd_controls),\n\t.dapm_widgets = mt6660_component_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(mt6660_component_dapm_widgets),\n\t.dapm_routes = mt6660_component_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(mt6660_component_dapm_routes),\n\n\t.idle_bias_on = false,  \n\t.endianness = 1,\n};\n\nstatic int mt6660_component_aif_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *hw_params, struct snd_soc_dai *dai)\n{\n\tint word_len = params_physical_width(hw_params);\n\tint aud_bit = params_width(hw_params);\n\tu16 reg_data = 0;\n\tint ret;\n\n\tdev_dbg(dai->dev, \"%s: ++\\n\", __func__);\n\tdev_dbg(dai->dev, \"format: 0x%08x\\n\", params_format(hw_params));\n\tdev_dbg(dai->dev, \"rate: 0x%08x\\n\", params_rate(hw_params));\n\tdev_dbg(dai->dev, \"word_len: %d, aud_bit: %d\\n\", word_len, aud_bit);\n\tif (word_len > 32 || word_len < 16) {\n\t\tdev_err(dai->dev, \"not supported word length\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\tswitch (aud_bit) {\n\tcase 16:\n\t\treg_data = 3;\n\t\tbreak;\n\tcase 18:\n\t\treg_data = 2;\n\t\tbreak;\n\tcase 20:\n\t\treg_data = 1;\n\t\tbreak;\n\tcase 24:\n\tcase 32:\n\t\treg_data = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\tret = snd_soc_component_update_bits(dai->component,\n\t\tMT6660_REG_SERIAL_CFG1, 0xc0, (reg_data << 6));\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"config aud bit fail\\n\");\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(dai->component,\n\t\tMT6660_REG_TDM_CFG3, 0x3f0, word_len << 4);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"config word len fail\\n\");\n\t\treturn ret;\n\t}\n\tdev_dbg(dai->dev, \"%s: --\\n\", __func__);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops mt6660_component_aif_ops = {\n\t.hw_params = mt6660_component_aif_hw_params,\n};\n\n#define STUB_RATES\tSNDRV_PCM_RATE_8000_192000\n#define STUB_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U32_LE)\n\nstatic struct snd_soc_dai_driver mt6660_codec_dai = {\n\t.name = \"mt6660-aif\",\n\t.playback = {\n\t\t.stream_name\t= \"aif_playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= STUB_RATES,\n\t\t.formats\t= STUB_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name\t= \"aif_capture\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 2,\n\t\t.rates = STUB_RATES,\n\t\t.formats = STUB_FORMATS,\n\t},\n\t \n\t.symmetric_rate = 1,\n\t.symmetric_channels = 1,\n\t.symmetric_sample_bits = 1,\n\t \n\t.ops = &mt6660_component_aif_ops,\n};\n\nstatic int _mt6660_chip_id_check(struct mt6660_chip *chip)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(chip->regmap, MT6660_REG_DEVID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tval &= 0x0ff0;\n\tif (val != 0x00e0 && val != 0x01e0) {\n\t\tdev_err(chip->dev, \"%s id(%x) not match\\n\", __func__, val);\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int _mt6660_chip_sw_reset(struct mt6660_chip *chip)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(chip->regmap, MT6660_REG_SYSTEM_CTRL, 0x00);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_write(chip->regmap, MT6660_REG_SYSTEM_CTRL, 0x80);\n\tif (ret < 0)\n\t\treturn ret;\n\tmsleep(30);\n\treturn 0;\n}\n\nstatic int _mt6660_read_chip_revision(struct mt6660_chip *chip)\n{\n\tint ret;\n\tunsigned int val;\n\n\tret = regmap_read(chip->regmap, MT6660_REG_DEVID, &val);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"get chip revision fail\\n\");\n\t\treturn ret;\n\t}\n\tchip->chip_rev = val&0xff;\n\tdev_info(chip->dev, \"%s chip_rev = %x\\n\", __func__, chip->chip_rev);\n\treturn 0;\n}\n\nstatic int mt6660_i2c_probe(struct i2c_client *client)\n{\n\tstruct mt6660_chip *chip = NULL;\n\tint ret;\n\n\tdev_dbg(&client->dev, \"%s\\n\", __func__);\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\tchip->i2c = client;\n\tchip->dev = &client->dev;\n\tmutex_init(&chip->io_lock);\n\ti2c_set_clientdata(client, chip);\n\n\tchip->regmap = devm_regmap_init(&client->dev,\n\t\tNULL, chip, &mt6660_regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev, \"failed to initialise regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = _mt6660_chip_sw_reset(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"chip reset fail\\n\");\n\t\tgoto probe_fail;\n\t}\n\t \n\tret = _mt6660_chip_power_on(chip, 1);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"chip power on 2 fail\\n\");\n\t\tgoto probe_fail;\n\t}\n\t \n\tret = _mt6660_chip_id_check(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"chip id check fail\\n\");\n\t\tgoto probe_fail;\n\t}\n\t \n\tret = _mt6660_read_chip_revision(chip);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"read chip revision fail\\n\");\n\t\tgoto probe_fail;\n\t}\n\tpm_runtime_set_active(chip->dev);\n\tpm_runtime_enable(chip->dev);\n\n\tret = devm_snd_soc_register_component(chip->dev,\n\t\t\t\t\t       &mt6660_component_driver,\n\t\t\t\t\t       &mt6660_codec_dai, 1);\n\tif (ret)\n\t\tpm_runtime_disable(chip->dev);\n\n\treturn ret;\n\nprobe_fail:\n\t_mt6660_chip_power_on(chip, 0);\n\tmutex_destroy(&chip->io_lock);\n\treturn ret;\n}\n\nstatic void mt6660_i2c_remove(struct i2c_client *client)\n{\n\tstruct mt6660_chip *chip = i2c_get_clientdata(client);\n\n\tpm_runtime_disable(chip->dev);\n\tpm_runtime_set_suspended(chip->dev);\n\tmutex_destroy(&chip->io_lock);\n}\n\nstatic int __maybe_unused mt6660_i2c_runtime_suspend(struct device *dev)\n{\n\tstruct mt6660_chip *chip = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"enter low power mode\\n\");\n\treturn regmap_update_bits(chip->regmap,\n\t\tMT6660_REG_SYSTEM_CTRL, 0x01, 0x01);\n}\n\nstatic int __maybe_unused mt6660_i2c_runtime_resume(struct device *dev)\n{\n\tstruct mt6660_chip *chip = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"exit low power mode\\n\");\n\treturn regmap_update_bits(chip->regmap,\n\t\tMT6660_REG_SYSTEM_CTRL, 0x01, 0x00);\n}\n\nstatic const struct dev_pm_ops mt6660_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mt6660_i2c_runtime_suspend,\n\t\t\t   mt6660_i2c_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id __maybe_unused mt6660_of_id[] = {\n\t{ .compatible = \"mediatek,mt6660\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mt6660_of_id);\n\nstatic const struct i2c_device_id mt6660_i2c_id[] = {\n\t{\"mt6660\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, mt6660_i2c_id);\n\nstatic struct i2c_driver mt6660_i2c_driver = {\n\t.driver = {\n\t\t.name = \"mt6660\",\n\t\t.of_match_table = of_match_ptr(mt6660_of_id),\n\t\t.pm = &mt6660_dev_pm_ops,\n\t},\n\t.probe = mt6660_i2c_probe,\n\t.remove = mt6660_i2c_remove,\n\t.id_table = mt6660_i2c_id,\n};\nmodule_i2c_driver(mt6660_i2c_driver);\n\nMODULE_AUTHOR(\"Jeff Chang <jeff_chang@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6660 SPKAMP Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"1.0.8_G\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}