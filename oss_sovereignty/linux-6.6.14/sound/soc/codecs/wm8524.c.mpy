{
  "module_name": "wm8524.c",
  "hash_id": "52672b268f7f750169173caa36d093f956c0fa46e6737849806149336d4bf306",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8524.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#define WM8524_NUM_RATES 7\n\n \nstruct wm8524_priv {\n\tstruct gpio_desc *mute;\n\tunsigned int sysclk;\n\tunsigned int rate_constraint_list[WM8524_NUM_RATES];\n\tstruct snd_pcm_hw_constraint_list rate_constraint;\n};\n\n\nstatic const struct snd_soc_dapm_widget wm8524_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8524_dapm_routes[] = {\n\t{ \"LINEVOUTL\", NULL, \"DAC\" },\n\t{ \"LINEVOUTR\", NULL, \"DAC\" },\n};\n\nstatic const struct {\n\tint value;\n\tint ratio;\n} lrclk_ratios[WM8524_NUM_RATES] = {\n\t{ 1, 128 },\n\t{ 2, 192 },\n\t{ 3, 256 },\n\t{ 4, 384 },\n\t{ 5, 512 },\n\t{ 6, 768 },\n\t{ 7, 1152 },\n};\n\nstatic int wm8524_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8524_priv *wm8524 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!wm8524->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"No MCLK configured, call set_sysclk() on init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &wm8524->rate_constraint);\n\n\tgpiod_set_value_cansleep(wm8524->mute, 1);\n\n\treturn 0;\n}\n\nstatic void wm8524_shutdown(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8524_priv *wm8524 = snd_soc_component_get_drvdata(component);\n\n\tgpiod_set_value_cansleep(wm8524->mute, 0);\n}\n\nstatic int wm8524_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8524_priv *wm8524 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint i, j = 0;\n\n\twm8524->sysclk = freq;\n\n\twm8524->rate_constraint.count = 0;\n\tfor (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {\n\t\tval = freq / lrclk_ratios[i].ratio;\n\t\t \n\t\tswitch (val) {\n\t\tcase 8000:\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\tcase 88200:\n\t\tcase 96000:\n\t\tcase 176400:\n\t\tcase 192000:\n\t\t\tdev_dbg(component->dev, \"Supported sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t\twm8524->rate_constraint_list[j++] = val;\n\t\t\twm8524->rate_constraint.count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(component->dev, \"Skipping sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t}\n\t}\n\n\t \n\tif (wm8524->rate_constraint.count == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int wm8524_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tfmt &= (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK |\n\t\tSND_SOC_DAIFMT_MASTER_MASK);\n\n\tif (fmt != (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t    SND_SOC_DAIFMT_CBS_CFS)) {\n\t\tdev_err(codec_dai->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8524_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct wm8524_priv *wm8524 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (wm8524->mute)\n\t\tgpiod_set_value_cansleep(wm8524->mute, mute);\n\n\treturn 0;\n}\n\n#define WM8524_RATES SNDRV_PCM_RATE_8000_192000\n\n#define WM8524_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8524_dai_ops = {\n\t.startup\t= wm8524_startup,\n\t.shutdown\t= wm8524_shutdown,\n\t.set_sysclk\t= wm8524_set_dai_sysclk,\n\t.set_fmt\t= wm8524_set_fmt,\n\t.mute_stream\t= wm8524_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver wm8524_dai = {\n\t.name = \"wm8524-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8524_RATES,\n\t\t.formats = WM8524_FORMATS,\n\t},\n\t.ops = &wm8524_dai_ops,\n};\n\nstatic int wm8524_probe(struct snd_soc_component *component)\n{\n\tstruct wm8524_priv *wm8524 = snd_soc_component_get_drvdata(component);\n\n\twm8524->rate_constraint.list = &wm8524->rate_constraint_list[0];\n\twm8524->rate_constraint.count =\n\t\tARRAY_SIZE(wm8524->rate_constraint_list);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8524 = {\n\t.probe\t\t\t= wm8524_probe,\n\t.dapm_widgets\t\t= wm8524_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8524_dapm_widgets),\n\t.dapm_routes\t\t= wm8524_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8524_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8524_of_match[] = {\n\t{ .compatible = \"wlf,wm8524\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, wm8524_of_match);\n\nstatic int wm8524_codec_probe(struct platform_device *pdev)\n{\n\tstruct wm8524_priv *wm8524;\n\tint ret;\n\n\twm8524 = devm_kzalloc(&pdev->dev, sizeof(struct wm8524_priv),\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (wm8524 == NULL)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, wm8524);\n\n\twm8524->mute = devm_gpiod_get(&pdev->dev, \"wlf,mute\", GPIOD_OUT_LOW);\n\tif (IS_ERR(wm8524->mute)) {\n\t\tret = PTR_ERR(wm8524->mute);\n\t\tdev_err_probe(&pdev->dev, ret, \"Failed to get mute line\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&soc_component_dev_wm8524, &wm8524_dai, 1);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to register component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver wm8524_codec_driver = {\n\t.probe\t\t= wm8524_codec_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"wm8524-codec\",\n\t\t.of_match_table = wm8524_of_match,\n\t},\n};\nmodule_platform_driver(wm8524_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8524 driver\");\nMODULE_AUTHOR(\"Mihai Serban <mihai.serban@nxp.com>\");\nMODULE_ALIAS(\"platform:wm8524-codec\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}