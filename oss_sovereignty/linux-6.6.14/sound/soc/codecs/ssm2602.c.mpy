{
  "module_name": "ssm2602.c",
  "hash_id": "1473c1a41f947ebd6c34d30643c96cbc768f8705a969097880bd547522555214",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ssm2602.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"ssm2602.h\"\n\n \nstruct ssm2602_priv {\n\tunsigned int sysclk;\n\tconst struct snd_pcm_hw_constraint_list *sysclk_constraints;\n\n\tstruct regmap *regmap;\n\n\tenum ssm2602_type type;\n\tunsigned int clk_out_pwr;\n};\n\n \nstatic const struct reg_default ssm2602_reg[SSM2602_CACHEREGNUM] = {\n\t{ .reg = 0x00, .def = 0x0097 },\n\t{ .reg = 0x01, .def = 0x0097 },\n\t{ .reg = 0x02, .def = 0x0079 },\n\t{ .reg = 0x03, .def = 0x0079 },\n\t{ .reg = 0x04, .def = 0x000a },\n\t{ .reg = 0x05, .def = 0x0008 },\n\t{ .reg = 0x06, .def = 0x009f },\n\t{ .reg = 0x07, .def = 0x000a },\n\t{ .reg = 0x08, .def = 0x0000 },\n\t{ .reg = 0x09, .def = 0x0000 }\n};\n\n \n\nstatic const struct reg_sequence ssm2602_patch[] = {\n\t{ SSM2602_ACTIVE, 0x01 },\n\t{ SSM2602_PWR,    0x07 },\n\t{ SSM2602_RESET,  0x00 },\n};\n\n\n \nstatic const char *ssm2602_input_select[] = {\n\t\"Line\", \"Mic\",\n};\n\nstatic const char *ssm2602_deemph[] = {\"None\", \"32Khz\", \"44.1Khz\", \"48Khz\"};\n\nstatic const struct soc_enum ssm2602_enum[] = {\n\tSOC_ENUM_SINGLE(SSM2602_APANA, 2, ARRAY_SIZE(ssm2602_input_select),\n\t\t\tssm2602_input_select),\n\tSOC_ENUM_SINGLE(SSM2602_APDIGI, 1, ARRAY_SIZE(ssm2602_deemph),\n\t\t\tssm2602_deemph),\n};\n\nstatic const DECLARE_TLV_DB_RANGE(ssm260x_outmix_tlv,\n\t0, 47, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),\n\t48, 127, TLV_DB_SCALE_ITEM(-7400, 100, 0)\n);\n\nstatic const DECLARE_TLV_DB_SCALE(ssm260x_inpga_tlv, -3450, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(ssm260x_sidetone_tlv, -1500, 300, 0);\n\nstatic const struct snd_kcontrol_new ssm260x_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Capture Volume\", SSM2602_LINVOL, SSM2602_RINVOL, 0, 45, 0,\n\tssm260x_inpga_tlv),\nSOC_DOUBLE_R(\"Capture Switch\", SSM2602_LINVOL, SSM2602_RINVOL, 7, 1, 1),\n\nSOC_SINGLE(\"ADC High Pass Filter Switch\", SSM2602_APDIGI, 0, 1, 1),\nSOC_SINGLE(\"Store DC Offset Switch\", SSM2602_APDIGI, 4, 1, 0),\n\nSOC_ENUM(\"Playback De-emphasis\", ssm2602_enum[1]),\n};\n\nstatic const struct snd_kcontrol_new ssm2602_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Master Playback Volume\", SSM2602_LOUT1V, SSM2602_ROUT1V,\n\t0, 127, 0, ssm260x_outmix_tlv),\nSOC_DOUBLE_R(\"Master Playback ZC Switch\", SSM2602_LOUT1V, SSM2602_ROUT1V,\n\t7, 1, 0),\nSOC_SINGLE_TLV(\"Sidetone Playback Volume\", SSM2602_APANA, 6, 3, 1,\n\tssm260x_sidetone_tlv),\n\nSOC_SINGLE(\"Mic Boost (+20dB)\", SSM2602_APANA, 0, 1, 0),\nSOC_SINGLE(\"Mic Boost2 (+20dB)\", SSM2602_APANA, 8, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ssm260x_output_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Bypass Switch\", SSM2602_APANA, 3, 1, 0),\nSOC_DAPM_SINGLE(\"HiFi Playback Switch\", SSM2602_APANA, 4, 1, 0),\nSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", SSM2602_APANA, 5, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mic_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", SSM2602_APANA, 1, 1, 1);\n\n \nstatic const struct snd_kcontrol_new ssm2602_input_mux_controls =\nSOC_DAPM_ENUM(\"Input Select\", ssm2602_enum[0]);\n\nstatic int ssm2602_mic_switch_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\t \n\tmsleep(500);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget ssm260x_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", SSM2602_PWR, 3, 1),\nSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", SSM2602_PWR, 2, 1),\nSND_SOC_DAPM_PGA(\"Line Input\", SSM2602_PWR, 0, 1, NULL, 0),\n\nSND_SOC_DAPM_SUPPLY(\"Digital Core Power\", SSM2602_ACTIVE, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_OUTPUT(\"LOUT\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT\"),\nSND_SOC_DAPM_INPUT(\"RLINEIN\"),\nSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n};\n\nstatic const struct snd_soc_dapm_widget ssm2602_dapm_widgets[] = {\nSND_SOC_DAPM_MIXER(\"Output Mixer\", SSM2602_PWR, 4, 1,\n\tssm260x_output_mixer_controls,\n\tARRAY_SIZE(ssm260x_output_mixer_controls)),\n\nSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0, &ssm2602_input_mux_controls),\nSND_SOC_DAPM_MICBIAS(\"Mic Bias\", SSM2602_PWR, 1, 1),\n\nSND_SOC_DAPM_SWITCH_E(\"Mic Switch\", SSM2602_APANA, 1, 1, &mic_ctl,\n\t\tssm2602_mic_switch_event, SND_SOC_DAPM_PRE_PMU),\n\nSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\nSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\nSND_SOC_DAPM_INPUT(\"MICIN\"),\n};\n\nstatic const struct snd_soc_dapm_widget ssm2604_dapm_widgets[] = {\nSND_SOC_DAPM_MIXER(\"Output Mixer\", SND_SOC_NOPM, 0, 0,\n\tssm260x_output_mixer_controls,\n\tARRAY_SIZE(ssm260x_output_mixer_controls) - 1),  \n};\n\nstatic const struct snd_soc_dapm_route ssm260x_routes[] = {\n\t{\"DAC\", NULL, \"Digital Core Power\"},\n\t{\"ADC\", NULL, \"Digital Core Power\"},\n\n\t{\"Output Mixer\", \"Line Bypass Switch\", \"Line Input\"},\n\t{\"Output Mixer\", \"HiFi Playback Switch\", \"DAC\"},\n\n\t{\"ROUT\", NULL, \"Output Mixer\"},\n\t{\"LOUT\", NULL, \"Output Mixer\"},\n\n\t{\"Line Input\", NULL, \"LLINEIN\"},\n\t{\"Line Input\", NULL, \"RLINEIN\"},\n};\n\nstatic const struct snd_soc_dapm_route ssm2602_routes[] = {\n\t{\"Output Mixer\", \"Mic Sidetone Switch\", \"Mic Bias\"},\n\n\t{\"RHPOUT\", NULL, \"Output Mixer\"},\n\t{\"LHPOUT\", NULL, \"Output Mixer\"},\n\n\t{\"Input Mux\", \"Line\", \"Line Input\"},\n\t{\"Input Mux\", \"Mic\", \"Mic Switch\"},\n\t{\"ADC\", NULL, \"Input Mux\"},\n\n\t{\"Mic Switch\", NULL, \"Mic Bias\"},\n\n\t{\"Mic Bias\", NULL, \"MICIN\"},\n};\n\nstatic const struct snd_soc_dapm_route ssm2604_routes[] = {\n\t{\"ADC\", NULL, \"Line Input\"},\n};\n\nstatic const unsigned int ssm2602_rates_12288000[] = {\n\t8000, 16000, 32000, 48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2602_constraints_12288000 = {\n\t.list = ssm2602_rates_12288000,\n\t.count = ARRAY_SIZE(ssm2602_rates_12288000),\n};\n\nstatic const unsigned int ssm2602_rates_11289600[] = {\n\t8000, 11025, 22050, 44100, 88200,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2602_constraints_11289600 = {\n\t.list = ssm2602_rates_11289600,\n\t.count = ARRAY_SIZE(ssm2602_rates_11289600),\n};\n\nstruct ssm2602_coeff {\n\tu32 mclk;\n\tu32 rate;\n\tu8 srate;\n};\n\n#define SSM2602_COEFF_SRATE(sr, bosr, usb) (((sr) << 2) | ((bosr) << 1) | (usb))\n\n \nstatic const struct ssm2602_coeff ssm2602_coeff_table[] = {\n\t \n\t{12288000, 48000, SSM2602_COEFF_SRATE(0x0, 0x0, 0x0)},\n\t{18432000, 48000, SSM2602_COEFF_SRATE(0x0, 0x1, 0x0)},\n\t{12000000, 48000, SSM2602_COEFF_SRATE(0x0, 0x0, 0x1)},\n\n\t \n\t{12288000, 32000, SSM2602_COEFF_SRATE(0x6, 0x0, 0x0)},\n\t{18432000, 32000, SSM2602_COEFF_SRATE(0x6, 0x1, 0x0)},\n\t{12000000, 32000, SSM2602_COEFF_SRATE(0x6, 0x0, 0x1)},\n\n\t \n\t{12288000, 16000, SSM2602_COEFF_SRATE(0x5, 0x0, 0x0)},\n\t{18432000, 16000, SSM2602_COEFF_SRATE(0x5, 0x1, 0x0)},\n\t{12000000, 16000, SSM2602_COEFF_SRATE(0xa, 0x0, 0x1)},\n\n\t \n\t{12288000, 8000, SSM2602_COEFF_SRATE(0x3, 0x0, 0x0)},\n\t{18432000, 8000, SSM2602_COEFF_SRATE(0x3, 0x1, 0x0)},\n\t{11289600, 8000, SSM2602_COEFF_SRATE(0xb, 0x0, 0x0)},\n\t{16934400, 8000, SSM2602_COEFF_SRATE(0xb, 0x1, 0x0)},\n\t{12000000, 8000, SSM2602_COEFF_SRATE(0x3, 0x0, 0x1)},\n\n\t \n\t{12288000, 96000, SSM2602_COEFF_SRATE(0x7, 0x0, 0x0)},\n\t{18432000, 96000, SSM2602_COEFF_SRATE(0x7, 0x1, 0x0)},\n\t{12000000, 96000, SSM2602_COEFF_SRATE(0x7, 0x0, 0x1)},\n\n\t \n\t{11289600, 11025, SSM2602_COEFF_SRATE(0xc, 0x0, 0x0)},\n\t{16934400, 11025, SSM2602_COEFF_SRATE(0xc, 0x1, 0x0)},\n\t{12000000, 11025, SSM2602_COEFF_SRATE(0xc, 0x1, 0x1)},\n\n\t \n\t{11289600, 22050, SSM2602_COEFF_SRATE(0xd, 0x0, 0x0)},\n\t{16934400, 22050, SSM2602_COEFF_SRATE(0xd, 0x1, 0x0)},\n\t{12000000, 22050, SSM2602_COEFF_SRATE(0xd, 0x1, 0x1)},\n\n\t \n\t{11289600, 44100, SSM2602_COEFF_SRATE(0x8, 0x0, 0x0)},\n\t{16934400, 44100, SSM2602_COEFF_SRATE(0x8, 0x1, 0x0)},\n\t{12000000, 44100, SSM2602_COEFF_SRATE(0x8, 0x1, 0x1)},\n\n\t \n\t{11289600, 88200, SSM2602_COEFF_SRATE(0xf, 0x0, 0x0)},\n\t{16934400, 88200, SSM2602_COEFF_SRATE(0xf, 0x1, 0x0)},\n\t{12000000, 88200, SSM2602_COEFF_SRATE(0xf, 0x1, 0x1)},\n};\n\nstatic inline int ssm2602_get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssm2602_coeff_table); i++) {\n\t\tif (ssm2602_coeff_table[i].rate == rate) {\n\t\t\tif (ssm2602_coeff_table[i].mclk == mclk)\n\t\t\t\treturn ssm2602_coeff_table[i].srate;\n\t\t\tif (ssm2602_coeff_table[i].mclk == mclk / 2)\n\t\t\t\treturn ssm2602_coeff_table[i].srate | SRATE_CORECLK_DIV2;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ssm2602_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\tint srate = ssm2602_get_coeff(ssm2602->sysclk, params_rate(params));\n\tunsigned int iface;\n\n\tif (srate < 0)\n\t\treturn srate;\n\n\tregmap_write(ssm2602->regmap, SSM2602_SRATE, srate);\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tiface = 0x0;\n\t\tbreak;\n\tcase 20:\n\t\tiface = 0x4;\n\t\tbreak;\n\tcase 24:\n\t\tiface = 0x8;\n\t\tbreak;\n\tcase 32:\n\t\tiface = 0xc;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tregmap_update_bits(ssm2602->regmap, SSM2602_IFACE,\n\t\tIFACE_AUDIO_DATA_LEN, iface);\n\treturn 0;\n}\n\nstatic int ssm2602_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\n\tif (ssm2602->sysclk_constraints) {\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   ssm2602->sysclk_constraints);\n\t}\n\n\treturn 0;\n}\n\nstatic int ssm2602_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (mute)\n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\n\t\t\t\t    APDIGI_ENABLE_DAC_MUTE,\n\t\t\t\t    APDIGI_ENABLE_DAC_MUTE);\n\telse\n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_APDIGI,\n\t\t\t\t    APDIGI_ENABLE_DAC_MUTE, 0);\n\treturn 0;\n}\n\nstatic int ssm2602_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\n\tif (dir == SND_SOC_CLOCK_IN) {\n\t\tif (clk_id != SSM2602_SYSCLK)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (freq) {\n\t\tcase 12288000:\n\t\tcase 18432000:\n\t\tcase 24576000:\n\t\tcase 36864000:\n\t\t\tssm2602->sysclk_constraints = &ssm2602_constraints_12288000;\n\t\t\tbreak;\n\t\tcase 11289600:\n\t\tcase 16934400:\n\t\tcase 22579200:\n\t\tcase 33868800:\n\t\t\tssm2602->sysclk_constraints = &ssm2602_constraints_11289600;\n\t\t\tbreak;\n\t\tcase 12000000:\n\t\tcase 24000000:\n\t\t\tssm2602->sysclk_constraints = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tssm2602->sysclk = freq;\n\t} else {\n\t\tunsigned int mask;\n\n\t\tswitch (clk_id) {\n\t\tcase SSM2602_CLK_CLKOUT:\n\t\t\tmask = PWR_CLK_OUT_PDN;\n\t\t\tbreak;\n\t\tcase SSM2602_CLK_XTO:\n\t\t\tmask = PWR_OSC_PDN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (freq == 0)\n\t\t\tssm2602->clk_out_pwr |= mask;\n\t\telse\n\t\t\tssm2602->clk_out_pwr &= ~mask;\n\n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\n\t\t\tPWR_CLK_OUT_PDN | PWR_OSC_PDN, ssm2602->clk_out_pwr);\n\t}\n\n\treturn 0;\n}\n\nstatic int ssm2602_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(codec_dai->component);\n\tunsigned int iface = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tiface |= 0x0040;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface |= 0x0013;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface |= 0x0003;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x0090;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x0080;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x0010;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(ssm2602->regmap, SSM2602_IFACE, iface);\n\treturn 0;\n}\n\nstatic int ssm2602_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\t \n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\n\t\t\tPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\n\t\t\tssm2602->clk_out_pwr);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\n\t\t\tPWR_POWER_OFF | PWR_CLK_OUT_PDN | PWR_OSC_PDN,\n\t\t\tPWR_CLK_OUT_PDN | PWR_OSC_PDN);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tregmap_update_bits(ssm2602->regmap, SSM2602_PWR,\n\t\t\tPWR_POWER_OFF, PWR_POWER_OFF);\n\t\tbreak;\n\n\t}\n\treturn 0;\n}\n\n#define SSM2602_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\tSNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\\\n\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\\\n\t\tSNDRV_PCM_RATE_96000)\n\n#define SSM2602_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops ssm2602_dai_ops = {\n\t.startup\t= ssm2602_startup,\n\t.hw_params\t= ssm2602_hw_params,\n\t.mute_stream\t= ssm2602_mute,\n\t.set_sysclk\t= ssm2602_set_dai_sysclk,\n\t.set_fmt\t= ssm2602_set_dai_fmt,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ssm2602_dai = {\n\t.name = \"ssm2602-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SSM2602_RATES,\n\t\t.formats = SSM2602_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SSM2602_RATES,\n\t\t.formats = SSM2602_FORMATS,},\n\t.ops = &ssm2602_dai_ops,\n\t.symmetric_rate = 1,\n\t.symmetric_sample_bits = 1,\n};\n\nstatic int ssm2602_resume(struct snd_soc_component *component)\n{\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\n\tregcache_sync(ssm2602->regmap);\n\n\treturn 0;\n}\n\nstatic int ssm2602_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tregmap_update_bits(ssm2602->regmap, SSM2602_LOUT1V,\n\t\t\t    LOUT1V_LRHP_BOTH, LOUT1V_LRHP_BOTH);\n\tregmap_update_bits(ssm2602->regmap, SSM2602_ROUT1V,\n\t\t\t    ROUT1V_RLHP_BOTH, ROUT1V_RLHP_BOTH);\n\n\tret = snd_soc_add_component_controls(component, ssm2602_snd_controls,\n\t\t\tARRAY_SIZE(ssm2602_snd_controls));\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_dapm_new_controls(dapm, ssm2602_dapm_widgets,\n\t\t\tARRAY_SIZE(ssm2602_dapm_widgets));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_soc_dapm_add_routes(dapm, ssm2602_routes,\n\t\t\tARRAY_SIZE(ssm2602_routes));\n}\n\nstatic int ssm2604_component_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint ret;\n\n\tret = snd_soc_dapm_new_controls(dapm, ssm2604_dapm_widgets,\n\t\t\tARRAY_SIZE(ssm2604_dapm_widgets));\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_soc_dapm_add_routes(dapm, ssm2604_routes,\n\t\t\tARRAY_SIZE(ssm2604_routes));\n}\n\nstatic int ssm260x_component_probe(struct snd_soc_component *component)\n{\n\tstruct ssm2602_priv *ssm2602 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regmap_write(ssm2602->regmap, SSM2602_RESET, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregmap_register_patch(ssm2602->regmap, ssm2602_patch,\n\t\t\t      ARRAY_SIZE(ssm2602_patch));\n\n\t \n\tregmap_update_bits(ssm2602->regmap, SSM2602_LINVOL,\n\t\t\t    LINVOL_LRIN_BOTH, LINVOL_LRIN_BOTH);\n\tregmap_update_bits(ssm2602->regmap, SSM2602_RINVOL,\n\t\t\t    RINVOL_RLIN_BOTH, RINVOL_RLIN_BOTH);\n\t \n\tregmap_write(ssm2602->regmap, SSM2602_APANA, APANA_SELECT_DAC |\n\t\t\tAPANA_ENABLE_MIC_BOOST);\n\n\tswitch (ssm2602->type) {\n\tcase SSM2602:\n\t\tret = ssm2602_component_probe(component);\n\t\tbreak;\n\tcase SSM2604:\n\t\tret = ssm2604_component_probe(component);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ssm2602 = {\n\t.probe\t\t\t= ssm260x_component_probe,\n\t.resume\t\t\t= ssm2602_resume,\n\t.set_bias_level\t\t= ssm2602_set_bias_level,\n\t.controls\t\t= ssm260x_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ssm260x_snd_controls),\n\t.dapm_widgets\t\t= ssm260x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ssm260x_dapm_widgets),\n\t.dapm_routes\t\t= ssm260x_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ssm260x_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic bool ssm2602_register_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == SSM2602_RESET;\n}\n\nconst struct regmap_config ssm2602_regmap_config = {\n\t.val_bits = 9,\n\t.reg_bits = 7,\n\n\t.max_register = SSM2602_RESET,\n\t.volatile_reg = ssm2602_register_volatile,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = ssm2602_reg,\n\t.num_reg_defaults = ARRAY_SIZE(ssm2602_reg),\n};\nEXPORT_SYMBOL_GPL(ssm2602_regmap_config);\n\nint ssm2602_probe(struct device *dev, enum ssm2602_type type,\n\tstruct regmap *regmap)\n{\n\tstruct ssm2602_priv *ssm2602;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tssm2602 = devm_kzalloc(dev, sizeof(*ssm2602), GFP_KERNEL);\n\tif (ssm2602 == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, ssm2602);\n\tssm2602->type = type;\n\tssm2602->regmap = regmap;\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_dev_ssm2602,\n\t\t&ssm2602_dai, 1);\n}\nEXPORT_SYMBOL_GPL(ssm2602_probe);\n\nMODULE_DESCRIPTION(\"ASoC SSM2602/SSM2603/SSM2604 driver\");\nMODULE_AUTHOR(\"Cliff Cai\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}