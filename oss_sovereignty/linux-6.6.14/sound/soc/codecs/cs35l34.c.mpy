{
  "module_name": "cs35l34.c",
  "hash_id": "d6ab95626c3699a1b7dbf6dff3537327d34f11b9c72f04a295b467daf999d00a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l34.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/regulator/machine.h>\n#include <linux/pm_runtime.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/of_irq.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs35l34.h>\n\n#include \"cs35l34.h\"\n#include \"cirrus_legacy.h\"\n\n#define PDN_DONE_ATTEMPTS 10\n#define CS35L34_START_DELAY 50\n\nstruct  cs35l34_private {\n\tstruct snd_soc_component *component;\n\tstruct cs35l34_platform_data pdata;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data core_supplies[2];\n\tint num_core_supplies;\n\tint mclk_int;\n\tbool tdm_mode;\n\tstruct gpio_desc *reset_gpio;\t \n};\n\nstatic const struct reg_default cs35l34_reg[] = {\n\t{CS35L34_PWRCTL1, 0x01},\n\t{CS35L34_PWRCTL2, 0x19},\n\t{CS35L34_PWRCTL3, 0x01},\n\t{CS35L34_ADSP_CLK_CTL, 0x08},\n\t{CS35L34_MCLK_CTL, 0x11},\n\t{CS35L34_AMP_INP_DRV_CTL, 0x01},\n\t{CS35L34_AMP_DIG_VOL_CTL, 0x12},\n\t{CS35L34_AMP_DIG_VOL, 0x00},\n\t{CS35L34_AMP_ANLG_GAIN_CTL, 0x0F},\n\t{CS35L34_PROTECT_CTL, 0x06},\n\t{CS35L34_AMP_KEEP_ALIVE_CTL, 0x04},\n\t{CS35L34_BST_CVTR_V_CTL, 0x00},\n\t{CS35L34_BST_PEAK_I, 0x10},\n\t{CS35L34_BST_RAMP_CTL, 0x87},\n\t{CS35L34_BST_CONV_COEF_1, 0x24},\n\t{CS35L34_BST_CONV_COEF_2, 0x24},\n\t{CS35L34_BST_CONV_SLOPE_COMP, 0x4E},\n\t{CS35L34_BST_CONV_SW_FREQ, 0x08},\n\t{CS35L34_CLASS_H_CTL, 0x0D},\n\t{CS35L34_CLASS_H_HEADRM_CTL, 0x0D},\n\t{CS35L34_CLASS_H_RELEASE_RATE, 0x08},\n\t{CS35L34_CLASS_H_FET_DRIVE_CTL, 0x41},\n\t{CS35L34_CLASS_H_STATUS, 0x05},\n\t{CS35L34_VPBR_CTL, 0x0A},\n\t{CS35L34_VPBR_VOL_CTL, 0x90},\n\t{CS35L34_VPBR_TIMING_CTL, 0x6A},\n\t{CS35L34_PRED_MAX_ATTEN_SPK_LOAD, 0x95},\n\t{CS35L34_PRED_BROWNOUT_THRESH, 0x1C},\n\t{CS35L34_PRED_BROWNOUT_VOL_CTL, 0x00},\n\t{CS35L34_PRED_BROWNOUT_RATE_CTL, 0x10},\n\t{CS35L34_PRED_WAIT_CTL, 0x10},\n\t{CS35L34_PRED_ZVP_INIT_IMP_CTL, 0x08},\n\t{CS35L34_PRED_MAN_SAFE_VPI_CTL, 0x80},\n\t{CS35L34_VPBR_ATTEN_STATUS, 0x00},\n\t{CS35L34_PRED_BRWNOUT_ATT_STATUS, 0x00},\n\t{CS35L34_SPKR_MON_CTL, 0xC6},\n\t{CS35L34_ADSP_I2S_CTL, 0x00},\n\t{CS35L34_ADSP_TDM_CTL, 0x00},\n\t{CS35L34_TDM_TX_CTL_1_VMON, 0x00},\n\t{CS35L34_TDM_TX_CTL_2_IMON, 0x04},\n\t{CS35L34_TDM_TX_CTL_3_VPMON, 0x03},\n\t{CS35L34_TDM_TX_CTL_4_VBSTMON, 0x07},\n\t{CS35L34_TDM_TX_CTL_5_FLAG1, 0x08},\n\t{CS35L34_TDM_TX_CTL_6_FLAG2, 0x09},\n\t{CS35L34_TDM_TX_SLOT_EN_1, 0x00},\n\t{CS35L34_TDM_TX_SLOT_EN_2, 0x00},\n\t{CS35L34_TDM_TX_SLOT_EN_3, 0x00},\n\t{CS35L34_TDM_TX_SLOT_EN_4, 0x00},\n\t{CS35L34_TDM_RX_CTL_1_AUDIN, 0x40},\n\t{CS35L34_TDM_RX_CTL_3_ALIVE, 0x04},\n\t{CS35L34_MULT_DEV_SYNCH1, 0x00},\n\t{CS35L34_MULT_DEV_SYNCH2, 0x80},\n\t{CS35L34_PROT_RELEASE_CTL, 0x00},\n\t{CS35L34_DIAG_MODE_REG_LOCK, 0x00},\n\t{CS35L34_DIAG_MODE_CTL_1, 0x00},\n\t{CS35L34_DIAG_MODE_CTL_2, 0x00},\n\t{CS35L34_INT_MASK_1, 0xFF},\n\t{CS35L34_INT_MASK_2, 0xFF},\n\t{CS35L34_INT_MASK_3, 0xFF},\n\t{CS35L34_INT_MASK_4, 0xFF},\n\t{CS35L34_INT_STATUS_1, 0x30},\n\t{CS35L34_INT_STATUS_2, 0x05},\n\t{CS35L34_INT_STATUS_3, 0x00},\n\t{CS35L34_INT_STATUS_4, 0x00},\n\t{CS35L34_OTP_TRIM_STATUS, 0x00},\n};\n\nstatic bool cs35l34_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L34_DEVID_AB:\n\tcase CS35L34_DEVID_CD:\n\tcase CS35L34_DEVID_E:\n\tcase CS35L34_FAB_ID:\n\tcase CS35L34_REV_ID:\n\tcase CS35L34_INT_STATUS_1:\n\tcase CS35L34_INT_STATUS_2:\n\tcase CS35L34_INT_STATUS_3:\n\tcase CS35L34_INT_STATUS_4:\n\tcase CS35L34_CLASS_H_STATUS:\n\tcase CS35L34_VPBR_ATTEN_STATUS:\n\tcase CS35L34_OTP_TRIM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l34_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase\tCS35L34_DEVID_AB:\n\tcase\tCS35L34_DEVID_CD:\n\tcase\tCS35L34_DEVID_E:\n\tcase\tCS35L34_FAB_ID:\n\tcase\tCS35L34_REV_ID:\n\tcase\tCS35L34_PWRCTL1:\n\tcase\tCS35L34_PWRCTL2:\n\tcase\tCS35L34_PWRCTL3:\n\tcase\tCS35L34_ADSP_CLK_CTL:\n\tcase\tCS35L34_MCLK_CTL:\n\tcase\tCS35L34_AMP_INP_DRV_CTL:\n\tcase\tCS35L34_AMP_DIG_VOL_CTL:\n\tcase\tCS35L34_AMP_DIG_VOL:\n\tcase\tCS35L34_AMP_ANLG_GAIN_CTL:\n\tcase\tCS35L34_PROTECT_CTL:\n\tcase\tCS35L34_AMP_KEEP_ALIVE_CTL:\n\tcase\tCS35L34_BST_CVTR_V_CTL:\n\tcase\tCS35L34_BST_PEAK_I:\n\tcase\tCS35L34_BST_RAMP_CTL:\n\tcase\tCS35L34_BST_CONV_COEF_1:\n\tcase\tCS35L34_BST_CONV_COEF_2:\n\tcase\tCS35L34_BST_CONV_SLOPE_COMP:\n\tcase\tCS35L34_BST_CONV_SW_FREQ:\n\tcase\tCS35L34_CLASS_H_CTL:\n\tcase\tCS35L34_CLASS_H_HEADRM_CTL:\n\tcase\tCS35L34_CLASS_H_RELEASE_RATE:\n\tcase\tCS35L34_CLASS_H_FET_DRIVE_CTL:\n\tcase\tCS35L34_CLASS_H_STATUS:\n\tcase\tCS35L34_VPBR_CTL:\n\tcase\tCS35L34_VPBR_VOL_CTL:\n\tcase\tCS35L34_VPBR_TIMING_CTL:\n\tcase\tCS35L34_PRED_MAX_ATTEN_SPK_LOAD:\n\tcase\tCS35L34_PRED_BROWNOUT_THRESH:\n\tcase\tCS35L34_PRED_BROWNOUT_VOL_CTL:\n\tcase\tCS35L34_PRED_BROWNOUT_RATE_CTL:\n\tcase\tCS35L34_PRED_WAIT_CTL:\n\tcase\tCS35L34_PRED_ZVP_INIT_IMP_CTL:\n\tcase\tCS35L34_PRED_MAN_SAFE_VPI_CTL:\n\tcase\tCS35L34_VPBR_ATTEN_STATUS:\n\tcase\tCS35L34_PRED_BRWNOUT_ATT_STATUS:\n\tcase\tCS35L34_SPKR_MON_CTL:\n\tcase\tCS35L34_ADSP_I2S_CTL:\n\tcase\tCS35L34_ADSP_TDM_CTL:\n\tcase\tCS35L34_TDM_TX_CTL_1_VMON:\n\tcase\tCS35L34_TDM_TX_CTL_2_IMON:\n\tcase\tCS35L34_TDM_TX_CTL_3_VPMON:\n\tcase\tCS35L34_TDM_TX_CTL_4_VBSTMON:\n\tcase\tCS35L34_TDM_TX_CTL_5_FLAG1:\n\tcase\tCS35L34_TDM_TX_CTL_6_FLAG2:\n\tcase\tCS35L34_TDM_TX_SLOT_EN_1:\n\tcase\tCS35L34_TDM_TX_SLOT_EN_2:\n\tcase\tCS35L34_TDM_TX_SLOT_EN_3:\n\tcase\tCS35L34_TDM_TX_SLOT_EN_4:\n\tcase\tCS35L34_TDM_RX_CTL_1_AUDIN:\n\tcase\tCS35L34_TDM_RX_CTL_3_ALIVE:\n\tcase\tCS35L34_MULT_DEV_SYNCH1:\n\tcase\tCS35L34_MULT_DEV_SYNCH2:\n\tcase\tCS35L34_PROT_RELEASE_CTL:\n\tcase\tCS35L34_DIAG_MODE_REG_LOCK:\n\tcase\tCS35L34_DIAG_MODE_CTL_1:\n\tcase\tCS35L34_DIAG_MODE_CTL_2:\n\tcase\tCS35L34_INT_MASK_1:\n\tcase\tCS35L34_INT_MASK_2:\n\tcase\tCS35L34_INT_MASK_3:\n\tcase\tCS35L34_INT_MASK_4:\n\tcase\tCS35L34_INT_STATUS_1:\n\tcase\tCS35L34_INT_STATUS_2:\n\tcase\tCS35L34_INT_STATUS_3:\n\tcase\tCS35L34_INT_STATUS_4:\n\tcase\tCS35L34_OTP_TRIM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l34_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L34_INT_STATUS_1:\n\tcase CS35L34_INT_STATUS_2:\n\tcase CS35L34_INT_STATUS_3:\n\tcase CS35L34_INT_STATUS_4:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int cs35l34_sdin_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (priv->tdm_mode)\n\t\t\tregmap_update_bits(priv->regmap, CS35L34_PWRCTL3,\n\t\t\t\t\t\tCS35L34_PDN_TDM, 0x00);\n\n\t\tret = regmap_update_bits(priv->regmap, CS35L34_PWRCTL1,\n\t\t\t\t\t\tCS35L34_PDN_ALL, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Cannot set Power bits %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tusleep_range(5000, 5100);\n\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (priv->tdm_mode) {\n\t\t\tregmap_update_bits(priv->regmap, CS35L34_PWRCTL3,\n\t\t\t\t\tCS35L34_PDN_TDM, CS35L34_PDN_TDM);\n\t\t}\n\t\tret = regmap_update_bits(priv->regmap, CS35L34_PWRCTL1,\n\t\t\t\t\tCS35L34_PDN_ALL, CS35L34_PDN_ALL);\n\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\nstatic int cs35l34_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int reg, bit_pos;\n\tint slot, slot_num;\n\n\tif (slot_width != 8)\n\t\treturn -EINVAL;\n\n\tpriv->tdm_mode = true;\n\t \n\tslot = ffs(rx_mask) - 1;\n\tif (slot >= 0)\n\t\tsnd_soc_component_update_bits(component, CS35L34_TDM_RX_CTL_1_AUDIN,\n\t\t\t\t\tCS35L34_X_LOC, slot);\n\n\t \n\tslot = ffs(tx_mask) - 1;\n\tslot_num = 0;\n\n\t \n\tsnd_soc_component_update_bits(component, CS35L34_TDM_TX_CTL_3_VPMON,\n\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC,\n\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC);\n\tsnd_soc_component_update_bits(component, CS35L34_TDM_TX_CTL_4_VBSTMON,\n\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC,\n\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC);\n\n\t \n\twhile (slot >= 0) {\n\t\t \n\t\tif (slot_num == 0)\n\t\t\tsnd_soc_component_update_bits(component, CS35L34_TDM_TX_CTL_1_VMON,\n\t\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC, slot);\n\n\t\t \n\t\tif (slot_num == 4) {\n\t\t\tsnd_soc_component_update_bits(component, CS35L34_TDM_TX_CTL_2_IMON,\n\t\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC, slot);\n\t\t}\n\t\t \n\t\tif (slot_num == 3) {\n\t\t\tsnd_soc_component_update_bits(component, CS35L34_TDM_TX_CTL_3_VPMON,\n\t\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC, slot);\n\t\t}\n\t\t \n\t\tif (slot_num == 7) {\n\t\t\tsnd_soc_component_update_bits(component,\n\t\t\t\tCS35L34_TDM_TX_CTL_4_VBSTMON,\n\t\t\t\tCS35L34_X_STATE | CS35L34_X_LOC, slot);\n\t\t}\n\n\t\t \n\t\treg = CS35L34_TDM_TX_SLOT_EN_4 - (slot/8);\n\t\tbit_pos = slot - ((slot / 8) * (8));\n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t1 << bit_pos, 1 << bit_pos);\n\n\t\ttx_mask &= ~(1 << slot);\n\t\tslot = ffs(tx_mask) - 1;\n\t\tslot_num++;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l34_main_amp_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(priv->regmap, CS35L34_BST_CVTR_V_CTL,\n\t\t\t\tCS35L34_BST_CVTL_MASK, priv->pdata.boost_vtge);\n\t\tusleep_range(5000, 5100);\n\t\tregmap_update_bits(priv->regmap, CS35L34_PROTECT_CTL,\n\t\t\t\t\t\tCS35L34_MUTE, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(priv->regmap, CS35L34_BST_CVTR_V_CTL,\n\t\t\tCS35L34_BST_CVTL_MASK, 0);\n\t\tregmap_update_bits(priv->regmap, CS35L34_PROTECT_CTL,\n\t\t\tCS35L34_MUTE, CS35L34_MUTE);\n\t\tusleep_range(5000, 5100);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\nstatic DECLARE_TLV_DB_SCALE(dig_vol_tlv, -10200, 50, 0);\n\nstatic DECLARE_TLV_DB_SCALE(amp_gain_tlv, 300, 100, 0);\n\n\nstatic const struct snd_kcontrol_new cs35l34_snd_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"Digital Volume\", CS35L34_AMP_DIG_VOL,\n\t\t      0, 0x34, 0xE4, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Amp Gain Volume\", CS35L34_AMP_ANLG_GAIN_CTL,\n\t\t      0, 0xF, 0, amp_gain_tlv),\n};\n\n\nstatic int cs35l34_mclk_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\tint ret, i;\n\tunsigned int reg;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tret = regmap_read(priv->regmap, CS35L34_AMP_DIG_VOL_CTL,\n\t\t\t&reg);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"%s regmap read failure %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (reg & CS35L34_AMP_DIGSFT)\n\t\t\tmsleep(40);\n\t\telse\n\t\t\tusleep_range(2000, 2100);\n\n\t\tfor (i = 0; i < PDN_DONE_ATTEMPTS; i++) {\n\t\t\tret = regmap_read(priv->regmap, CS35L34_INT_STATUS_2,\n\t\t\t\t&reg);\n\t\t\tif (ret != 0) {\n\t\t\t\tpr_err(\"%s regmap read failure %d\\n\",\n\t\t\t\t\t__func__, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (reg & CS35L34_PDN_DONE)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(5000, 5100);\n\t\t}\n\t\tif (i == PDN_DONE_ATTEMPTS)\n\t\t\tpr_err(\"%s Device did not power down properly\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid event = 0x%x\\n\", event);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs35l34_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN_E(\"SDIN\", NULL, 0, CS35L34_PWRCTL3,\n\t\t\t\t\t1, 1, cs35l34_sdin_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU |\n\t\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT\", NULL, 0, CS35L34_PWRCTL3, 2, 1),\n\n\tSND_SOC_DAPM_SUPPLY(\"EXTCLK\", CS35L34_PWRCTL3, 7, 1,\n\t\tcs35l34_mclk_event, SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\n\tSND_SOC_DAPM_INPUT(\"VP\"),\n\tSND_SOC_DAPM_INPUT(\"VPST\"),\n\tSND_SOC_DAPM_INPUT(\"ISENSE\"),\n\tSND_SOC_DAPM_INPUT(\"VSENSE\"),\n\n\tSND_SOC_DAPM_ADC(\"VMON ADC\", NULL, CS35L34_PWRCTL2, 7, 1),\n\tSND_SOC_DAPM_ADC(\"IMON ADC\", NULL, CS35L34_PWRCTL2, 6, 1),\n\tSND_SOC_DAPM_ADC(\"VPMON ADC\", NULL, CS35L34_PWRCTL3, 3, 1),\n\tSND_SOC_DAPM_ADC(\"VBSTMON ADC\", NULL, CS35L34_PWRCTL3, 4, 1),\n\tSND_SOC_DAPM_ADC(\"CLASS H\", NULL, CS35L34_PWRCTL2, 5, 1),\n\tSND_SOC_DAPM_ADC(\"BOOST\", NULL, CS35L34_PWRCTL2, 2, 1),\n\n\tSND_SOC_DAPM_OUT_DRV_E(\"Main AMP\", CS35L34_PWRCTL2, 0, 1, NULL, 0,\n\t\tcs35l34_main_amp_event, SND_SOC_DAPM_POST_PMU |\n\t\t\tSND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route cs35l34_audio_map[] = {\n\t{\"SDIN\", NULL, \"AMP Playback\"},\n\t{\"BOOST\", NULL, \"SDIN\"},\n\t{\"CLASS H\", NULL, \"BOOST\"},\n\t{\"Main AMP\", NULL, \"CLASS H\"},\n\t{\"SPK\", NULL, \"Main AMP\"},\n\n\t{\"VPMON ADC\", NULL, \"CLASS H\"},\n\t{\"VBSTMON ADC\", NULL, \"CLASS H\"},\n\t{\"SPK\", NULL, \"VPMON ADC\"},\n\t{\"SPK\", NULL, \"VBSTMON ADC\"},\n\n\t{\"IMON ADC\", NULL, \"ISENSE\"},\n\t{\"VMON ADC\", NULL, \"VSENSE\"},\n\t{\"SDOUT\", NULL, \"IMON ADC\"},\n\t{\"SDOUT\", NULL, \"VMON ADC\"},\n\t{\"AMP Capture\", NULL, \"SDOUT\"},\n\n\t{\"SDIN\", NULL, \"EXTCLK\"},\n\t{\"SDOUT\", NULL, \"EXTCLK\"},\n};\n\nstruct cs35l34_mclk_div {\n\tint mclk;\n\tint srate;\n\tu8 adsp_rate;\n};\n\nstatic struct cs35l34_mclk_div cs35l34_mclk_coeffs[] = {\n\n\t \n\n\t{5644800, 11025, 0x1},\n\t{5644800, 22050, 0x4},\n\t{5644800, 44100, 0x7},\n\n\t{6000000,  8000, 0x0},\n\t{6000000, 11025, 0x1},\n\t{6000000, 12000, 0x2},\n\t{6000000, 16000, 0x3},\n\t{6000000, 22050, 0x4},\n\t{6000000, 24000, 0x5},\n\t{6000000, 32000, 0x6},\n\t{6000000, 44100, 0x7},\n\t{6000000, 48000, 0x8},\n\n\t{6144000,  8000, 0x0},\n\t{6144000, 11025, 0x1},\n\t{6144000, 12000, 0x2},\n\t{6144000, 16000, 0x3},\n\t{6144000, 22050, 0x4},\n\t{6144000, 24000, 0x5},\n\t{6144000, 32000, 0x6},\n\t{6144000, 44100, 0x7},\n\t{6144000, 48000, 0x8},\n};\n\nstatic int cs35l34_get_mclk_coeff(int mclk, int srate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l34_mclk_coeffs); i++) {\n\t\tif (cs35l34_mclk_coeffs[i].mclk == mclk &&\n\t\t\tcs35l34_mclk_coeffs[i].srate == srate)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs35l34_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tregmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\n\t\t\t\t    0x80, 0x80);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tregmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\n\t\t\t\t    0x80, 0x00);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs35l34_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l34_private *priv = snd_soc_component_get_drvdata(component);\n\tint srate = params_rate(params);\n\tint ret;\n\n\tint coeff = cs35l34_get_mclk_coeff(priv->mclk_int, srate);\n\n\tif (coeff < 0) {\n\t\tdev_err(component->dev, \"ERROR: Invalid mclk %d and/or srate %d\\n\",\n\t\t\tpriv->mclk_int, srate);\n\t\treturn coeff;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, CS35L34_ADSP_CLK_CTL,\n\t\tCS35L34_ADSP_RATE, cs35l34_mclk_coeffs[coeff].adsp_rate);\n\tif (ret != 0)\n\t\tdev_err(component->dev, \"Failed to set clock state %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const unsigned int cs35l34_src_rates[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000\n};\n\n\nstatic const struct snd_pcm_hw_constraint_list cs35l34_constraints = {\n\t.count  = ARRAY_SIZE(cs35l34_src_rates),\n\t.list   = cs35l34_src_rates,\n};\n\nstatic int cs35l34_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE, &cs35l34_constraints);\n\treturn 0;\n}\n\n\nstatic int cs35l34_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (tristate)\n\t\tsnd_soc_component_update_bits(component, CS35L34_PWRCTL3,\n\t\t\t\t\tCS35L34_PDN_SDOUT, CS35L34_PDN_SDOUT);\n\telse\n\t\tsnd_soc_component_update_bits(component, CS35L34_PWRCTL3,\n\t\t\t\t\tCS35L34_PDN_SDOUT, 0);\n\treturn 0;\n}\n\nstatic int cs35l34_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l34_private *cs35l34 = snd_soc_component_get_drvdata(component);\n\tunsigned int value;\n\n\tswitch (freq) {\n\tcase CS35L34_MCLK_5644:\n\t\tvalue = CS35L34_MCLK_RATE_5P6448;\n\t\tcs35l34->mclk_int = freq;\n\tbreak;\n\tcase CS35L34_MCLK_6:\n\t\tvalue = CS35L34_MCLK_RATE_6P0000;\n\t\tcs35l34->mclk_int = freq;\n\tbreak;\n\tcase CS35L34_MCLK_6144:\n\t\tvalue = CS35L34_MCLK_RATE_6P1440;\n\t\tcs35l34->mclk_int = freq;\n\tbreak;\n\tcase CS35L34_MCLK_11289:\n\t\tvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_5P6448;\n\t\tcs35l34->mclk_int = freq / 2;\n\tbreak;\n\tcase CS35L34_MCLK_12:\n\t\tvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_6P0000;\n\t\tcs35l34->mclk_int = freq / 2;\n\tbreak;\n\tcase CS35L34_MCLK_12288:\n\t\tvalue = CS35L34_MCLK_DIV | CS35L34_MCLK_RATE_6P1440;\n\t\tcs35l34->mclk_int = freq / 2;\n\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"ERROR: Invalid Frequency %d\\n\", freq);\n\t\tcs35l34->mclk_int = 0;\n\t\treturn -EINVAL;\n\t}\n\tregmap_update_bits(cs35l34->regmap, CS35L34_MCLK_CTL,\n\t\t\tCS35L34_MCLK_DIV | CS35L34_MCLK_RATE_MASK, value);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l34_ops = {\n\t.startup = cs35l34_pcm_startup,\n\t.set_tristate = cs35l34_set_tristate,\n\t.set_fmt = cs35l34_set_dai_fmt,\n\t.hw_params = cs35l34_pcm_hw_params,\n\t.set_sysclk = cs35l34_dai_set_sysclk,\n\t.set_tdm_slot = cs35l34_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver cs35l34_dai = {\n\t\t.name = \"cs35l34\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AMP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = CS35L34_RATES,\n\t\t\t.formats = CS35L34_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AMP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = CS35L34_RATES,\n\t\t\t.formats = CS35L34_FORMATS,\n\t\t},\n\t\t.ops = &cs35l34_ops,\n\t\t.symmetric_rate = 1,\n};\n\nstatic int cs35l34_boost_inductor(struct cs35l34_private *cs35l34,\n\tunsigned int inductor)\n{\n\tstruct snd_soc_component *component = cs35l34->component;\n\n\tswitch (inductor) {\n\tcase 1000:  \n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x24);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x24);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\n\t\t\t0x4E);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 0);\n\t\tbreak;\n\tcase 1200:  \n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x20);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x20);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\n\t\t\t0x47);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 1);\n\t\tbreak;\n\tcase 1500:  \n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x20);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x20);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\n\t\t\t0x3C);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 2);\n\t\tbreak;\n\tcase 2200:  \n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_1, 0x19);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_COEF_2, 0x25);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SLOPE_COMP,\n\t\t\t0x23);\n\t\tregmap_write(cs35l34->regmap, CS35L34_BST_CONV_SW_FREQ, 3);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"%s Invalid Inductor Value %d uH\\n\",\n\t\t\t__func__, inductor);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs35l34_probe(struct snd_soc_component *component)\n{\n\tint ret = 0;\n\tstruct cs35l34_private *cs35l34 = snd_soc_component_get_drvdata(component);\n\n\tpm_runtime_get_sync(component->dev);\n\n\t \n\tregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\n\t\t CS35L34_OTW_ATTN_MASK, 0x8);\n\n\t \n\tregmap_write(cs35l34->regmap, CS35L34_PWRCTL2, 0xFD);\n\tregmap_write(cs35l34->regmap, CS35L34_PWRCTL3, 0x1F);\n\n\t \n\tregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\n\t\t\t\tCS35L34_MUTE, CS35L34_MUTE);\n\n\t \n\tif (cs35l34->pdata.boost_peak)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_BST_PEAK_I,\n\t\t\t\tCS35L34_BST_PEAK_MASK,\n\t\t\t\tcs35l34->pdata.boost_peak);\n\n\tif (cs35l34->pdata.gain_zc_disable)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\n\t\t\tCS35L34_GAIN_ZC_MASK, 0);\n\telse\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PROTECT_CTL,\n\t\t\tCS35L34_GAIN_ZC_MASK, CS35L34_GAIN_ZC_MASK);\n\n\tif (cs35l34->pdata.aif_half_drv)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_CLK_CTL,\n\t\t\tCS35L34_ADSP_DRIVE, 0);\n\n\tif (cs35l34->pdata.digsft_disable)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_AMP_DIG_VOL_CTL,\n\t\t\tCS35L34_AMP_DIGSFT, 0);\n\n\tif (cs35l34->pdata.amp_inv)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_AMP_DIG_VOL_CTL,\n\t\t\tCS35L34_INV, CS35L34_INV);\n\n\tif (cs35l34->pdata.boost_ind)\n\t\tret = cs35l34_boost_inductor(cs35l34, cs35l34->pdata.boost_ind);\n\n\tif (cs35l34->pdata.i2s_sdinloc)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_I2S_CTL,\n\t\t\tCS35L34_I2S_LOC_MASK,\n\t\t\tcs35l34->pdata.i2s_sdinloc << CS35L34_I2S_LOC_SHIFT);\n\n\tif (cs35l34->pdata.tdm_rising_edge)\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_ADSP_TDM_CTL,\n\t\t\t1, 1);\n\n\tpm_runtime_put_sync(component->dev);\n\n\treturn ret;\n}\n\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l34 = {\n\t.probe\t\t\t= cs35l34_probe,\n\t.dapm_widgets\t\t= cs35l34_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs35l34_dapm_widgets),\n\t.dapm_routes\t\t= cs35l34_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs35l34_audio_map),\n\t.controls\t\t= cs35l34_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs35l34_snd_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct regmap_config cs35l34_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS35L34_MAX_REGISTER,\n\t.reg_defaults = cs35l34_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l34_reg),\n\t.volatile_reg = cs35l34_volatile_register,\n\t.readable_reg = cs35l34_readable_register,\n\t.precious_reg = cs35l34_precious_register,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int cs35l34_handle_of_data(struct i2c_client *i2c_client,\n\t\t\t\tstruct cs35l34_platform_data *pdata)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tunsigned int val;\n\n\tif (of_property_read_u32(np, \"cirrus,boost-vtge-millivolt\",\n\t\t&val) >= 0) {\n\t\t \n\t\tif (val > 8000 || (val < 3300 && val > 0)) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Voltage %d mV\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val == 0)\n\t\t\tpdata->boost_vtge = 0;  \n\t\telse\n\t\t\tpdata->boost_vtge = ((val - 3300)/100) + 1;\n\t} else {\n\t\tdev_warn(&i2c_client->dev,\n\t\t\t\"Boost Voltage not specified. Using VP\\n\");\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,boost-ind-nanohenry\", &val) >= 0) {\n\t\tpdata->boost_ind = val;\n\t} else {\n\t\tdev_err(&i2c_client->dev, \"Inductor not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,boost-peak-milliamp\", &val) >= 0) {\n\t\tif (val > 3840 || val < 1200) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Peak Current %d mA\\n\", val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdata->boost_peak = ((val - 1200)/80) + 1;\n\t}\n\n\tpdata->aif_half_drv = of_property_read_bool(np,\n\t\t\"cirrus,aif-half-drv\");\n\tpdata->digsft_disable = of_property_read_bool(np,\n\t\t\"cirrus,digsft-disable\");\n\n\tpdata->gain_zc_disable = of_property_read_bool(np,\n\t\t\"cirrus,gain-zc-disable\");\n\tpdata->amp_inv = of_property_read_bool(np, \"cirrus,amp-inv\");\n\n\tif (of_property_read_u32(np, \"cirrus,i2s-sdinloc\", &val) >= 0)\n\t\tpdata->i2s_sdinloc = val;\n\tif (of_property_read_u32(np, \"cirrus,tdm-rising-edge\", &val) >= 0)\n\t\tpdata->tdm_rising_edge = val;\n\n\treturn 0;\n}\n\nstatic irqreturn_t cs35l34_irq_thread(int irq, void *data)\n{\n\tstruct cs35l34_private *cs35l34 = data;\n\tstruct snd_soc_component *component = cs35l34->component;\n\tunsigned int sticky1, sticky2, sticky3, sticky4;\n\tunsigned int mask1, mask2, mask3, mask4, current1;\n\n\n\t \n\tregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_4, &sticky4);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_3, &sticky3);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_2, &sticky2);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_1, &sticky1);\n\n\tregmap_read(cs35l34->regmap, CS35L34_INT_MASK_4, &mask4);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_MASK_3, &mask3);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_MASK_2, &mask2);\n\tregmap_read(cs35l34->regmap, CS35L34_INT_MASK_1, &mask1);\n\n\tif (!(sticky1 & ~mask1) && !(sticky2 & ~mask2) && !(sticky3 & ~mask3)\n\t\t&& !(sticky4 & ~mask4))\n\t\treturn IRQ_NONE;\n\n\tregmap_read(cs35l34->regmap, CS35L34_INT_STATUS_1, &current1);\n\n\tif (sticky1 & CS35L34_CAL_ERR) {\n\t\tdev_err(component->dev, \"Cal error\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L34_CAL_ERR)) {\n\t\t\tdev_dbg(component->dev, \"Cal error release\\n\");\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_CAL_ERR_RLS, 0);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_CAL_ERR_RLS,\n\t\t\t\t\tCS35L34_CAL_ERR_RLS);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_CAL_ERR_RLS, 0);\n\t\t\t \n\t\t}\n\t}\n\n\tif (sticky1 & CS35L34_ALIVE_ERR)\n\t\tdev_err(component->dev, \"Alive error\\n\");\n\n\tif (sticky1 & CS35L34_AMP_SHORT) {\n\t\tdev_crit(component->dev, \"Amp short error\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L34_AMP_SHORT)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Amp short error release\\n\");\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_SHORT_RLS, 0);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_SHORT_RLS,\n\t\t\t\t\tCS35L34_SHORT_RLS);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_SHORT_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky1 & CS35L34_OTW) {\n\t\tdev_crit(component->dev, \"Over temperature warning\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L34_OTW)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Over temperature warning release\\n\");\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTW_RLS, 0);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTW_RLS,\n\t\t\t\t\tCS35L34_OTW_RLS);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTW_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky1 & CS35L34_OTE) {\n\t\tdev_crit(component->dev, \"Over temperature error\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L34_OTE)) {\n\t\t\tdev_dbg(component->dev,\n\t\t\t\t\"Over temperature error release\\n\");\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTE_RLS, 0);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTE_RLS,\n\t\t\t\t\tCS35L34_OTE_RLS);\n\t\t\tregmap_update_bits(cs35l34->regmap,\n\t\t\t\t\tCS35L34_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L34_OTE_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky3 & CS35L34_BST_HIGH) {\n\t\tdev_crit(component->dev, \"VBST too high error; powering off!\\n\");\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL2,\n\t\t\t\tCS35L34_PDN_AMP, CS35L34_PDN_AMP);\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL1,\n\t\t\t\tCS35L34_PDN_ALL, CS35L34_PDN_ALL);\n\t}\n\n\tif (sticky3 & CS35L34_LBST_SHORT) {\n\t\tdev_crit(component->dev, \"LBST short error; powering off!\\n\");\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL2,\n\t\t\t\tCS35L34_PDN_AMP, CS35L34_PDN_AMP);\n\t\tregmap_update_bits(cs35l34->regmap, CS35L34_PWRCTL1,\n\t\t\t\tCS35L34_PDN_ALL, CS35L34_PDN_ALL);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const char * const cs35l34_core_supplies[] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstatic int cs35l34_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs35l34_private *cs35l34;\n\tstruct cs35l34_platform_data *pdata =\n\t\tdev_get_platdata(&i2c_client->dev);\n\tint i, devid;\n\tint ret;\n\tunsigned int reg;\n\n\tcs35l34 = devm_kzalloc(&i2c_client->dev, sizeof(*cs35l34), GFP_KERNEL);\n\tif (!cs35l34)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c_client, cs35l34);\n\tcs35l34->regmap = devm_regmap_init_i2c(i2c_client, &cs35l34_regmap);\n\tif (IS_ERR(cs35l34->regmap)) {\n\t\tret = PTR_ERR(cs35l34->regmap);\n\t\tdev_err(&i2c_client->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs35l34->num_core_supplies = ARRAY_SIZE(cs35l34_core_supplies);\n\tfor (i = 0; i < ARRAY_SIZE(cs35l34_core_supplies); i++)\n\t\tcs35l34->core_supplies[i].supply = cs35l34_core_supplies[i];\n\n\tret = devm_regulator_bulk_get(&i2c_client->dev,\n\t\tcs35l34->num_core_supplies,\n\t\tcs35l34->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to request core supplies %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(cs35l34->num_core_supplies,\n\t\t\t\t\tcs35l34->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Failed to enable core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs35l34->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(&i2c_client->dev, sizeof(*pdata),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_regulator;\n\t\t}\n\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tret = cs35l34_handle_of_data(i2c_client, pdata);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto err_regulator;\n\n\t\t}\n\t\tcs35l34->pdata = *pdata;\n\t}\n\n\tret = devm_request_threaded_irq(&i2c_client->dev, i2c_client->irq, NULL,\n\t\t\tcs35l34_irq_thread, IRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\"cs35l34\", cs35l34);\n\tif (ret != 0)\n\t\tdev_err(&i2c_client->dev, \"Failed to request IRQ: %d\\n\", ret);\n\n\tcs35l34->reset_gpio = devm_gpiod_get_optional(&i2c_client->dev,\n\t\t\t\t\"reset-gpios\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l34->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l34->reset_gpio);\n\t\tgoto err_regulator;\n\t}\n\n\tgpiod_set_value_cansleep(cs35l34->reset_gpio, 1);\n\n\tmsleep(CS35L34_START_DELAY);\n\n\tdevid = cirrus_read_device_id(cs35l34->regmap, CS35L34_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(&i2c_client->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err_reset;\n\t}\n\n\tif (devid != CS35L34_CHIP_ID) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"CS35l34 Device ID (%X). Expected ID %X\\n\",\n\t\t\tdevid, CS35L34_CHIP_ID);\n\t\tret = -ENODEV;\n\t\tgoto err_reset;\n\t}\n\n\tret = regmap_read(cs35l34->regmap, CS35L34_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err_reset;\n\t}\n\n\tdev_info(&i2c_client->dev,\n\t\t \"Cirrus Logic CS35l34 (%x), Revision: %02X\\n\", devid,\n\t\treg & 0xFF);\n\n\t \n\tregmap_update_bits(cs35l34->regmap, CS35L34_INT_MASK_1,\n\t\t\t\tCS35L34_M_CAL_ERR | CS35L34_M_ALIVE_ERR |\n\t\t\t\tCS35L34_M_AMP_SHORT | CS35L34_M_OTW |\n\t\t\t\tCS35L34_M_OTE, 0);\n\tregmap_update_bits(cs35l34->regmap, CS35L34_INT_MASK_3,\n\t\t\t\tCS35L34_M_BST_HIGH | CS35L34_M_LBST_SHORT, 0);\n\n\tpm_runtime_set_autosuspend_delay(&i2c_client->dev, 100);\n\tpm_runtime_use_autosuspend(&i2c_client->dev);\n\tpm_runtime_set_active(&i2c_client->dev);\n\tpm_runtime_enable(&i2c_client->dev);\n\n\tret = devm_snd_soc_register_component(&i2c_client->dev,\n\t\t\t&soc_component_dev_cs35l34, &cs35l34_dai, 1);\n\tif (ret < 0) {\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"%s: Register component failed\\n\", __func__);\n\t\tgoto err_reset;\n\t}\n\n\treturn 0;\n\nerr_reset:\n\tgpiod_set_value_cansleep(cs35l34->reset_gpio, 0);\nerr_regulator:\n\tregulator_bulk_disable(cs35l34->num_core_supplies,\n\t\tcs35l34->core_supplies);\n\n\treturn ret;\n}\n\nstatic void cs35l34_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs35l34_private *cs35l34 = i2c_get_clientdata(client);\n\n\tgpiod_set_value_cansleep(cs35l34->reset_gpio, 0);\n\n\tpm_runtime_disable(&client->dev);\n\tregulator_bulk_disable(cs35l34->num_core_supplies,\n\t\tcs35l34->core_supplies);\n}\n\nstatic int __maybe_unused cs35l34_runtime_resume(struct device *dev)\n{\n\tstruct cs35l34_private *cs35l34 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(cs35l34->num_core_supplies,\n\t\tcs35l34->core_supplies);\n\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable core supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(cs35l34->regmap, false);\n\n\tgpiod_set_value_cansleep(cs35l34->reset_gpio, 1);\n\tmsleep(CS35L34_START_DELAY);\n\n\tret = regcache_sync(cs35l34->regmap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to restore register cache\\n\");\n\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tregcache_cache_only(cs35l34->regmap, true);\n\tregulator_bulk_disable(cs35l34->num_core_supplies,\n\t\tcs35l34->core_supplies);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused cs35l34_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l34_private *cs35l34 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs35l34->regmap, true);\n\tregcache_mark_dirty(cs35l34->regmap);\n\n\tgpiod_set_value_cansleep(cs35l34->reset_gpio, 0);\n\n\tregulator_bulk_disable(cs35l34->num_core_supplies,\n\t\t\tcs35l34->core_supplies);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cs35l34_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cs35l34_runtime_suspend,\n\t\t\t   cs35l34_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id cs35l34_of_match[] = {\n\t{.compatible = \"cirrus,cs35l34\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs35l34_of_match);\n\nstatic const struct i2c_device_id cs35l34_id[] = {\n\t{\"cs35l34\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cs35l34_id);\n\nstatic struct i2c_driver cs35l34_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs35l34\",\n\t\t.pm = &cs35l34_pm_ops,\n\t\t.of_match_table = cs35l34_of_match,\n\n\t\t},\n\t.id_table = cs35l34_id,\n\t.probe = cs35l34_i2c_probe,\n\t.remove = cs35l34_i2c_remove,\n\n};\n\nstatic int __init cs35l34_modinit(void)\n{\n\tint ret;\n\n\tret = i2c_add_driver(&cs35l34_i2c_driver);\n\tif (ret != 0) {\n\t\tpr_err(\"Failed to register CS35l34 I2C driver: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\nmodule_init(cs35l34_modinit);\n\nstatic void __exit cs35l34_exit(void)\n{\n\ti2c_del_driver(&cs35l34_i2c_driver);\n}\nmodule_exit(cs35l34_exit);\n\nMODULE_DESCRIPTION(\"ASoC CS35l34 driver\");\nMODULE_AUTHOR(\"Paul Handrigan, Cirrus Logic Inc, <Paul.Handrigan@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}