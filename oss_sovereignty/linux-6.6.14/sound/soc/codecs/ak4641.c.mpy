{
  "module_name": "ak4641.c",
  "hash_id": "9e5424d425a9d5227d9422da9bf17bfe2843eecf435242e8f5cbefc76e4b4a11",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4641.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/ak4641.h>\n\n \n#define AK4641_PM1\t\t0x00\n#define AK4641_PM2\t\t0x01\n#define AK4641_SIG1\t\t0x02\n#define AK4641_SIG2\t\t0x03\n#define AK4641_MODE1\t\t0x04\n#define AK4641_MODE2\t\t0x05\n#define AK4641_DAC\t\t0x06\n#define AK4641_MIC\t\t0x07\n#define AK4641_TIMER\t\t0x08\n#define AK4641_ALC1\t\t0x09\n#define AK4641_ALC2\t\t0x0a\n#define AK4641_PGA\t\t0x0b\n#define AK4641_LATT\t\t0x0c\n#define AK4641_RATT\t\t0x0d\n#define AK4641_VOL\t\t0x0e\n#define AK4641_STATUS\t\t0x0f\n#define AK4641_EQLO\t\t0x10\n#define AK4641_EQMID\t\t0x11\n#define AK4641_EQHI\t\t0x12\n#define AK4641_BTIF\t\t0x13\n\n \nstruct ak4641_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n\tint deemph;\n\tint playback_fs;\n};\n\n \nstatic const struct reg_default ak4641_reg_defaults[] = {\n\t{  0, 0x00 }, {  1, 0x80 }, {  2, 0x00 }, {  3, 0x80 },\n\t{  4, 0x02 }, {  5, 0x00 }, {  6, 0x11 }, {  7, 0x05 },\n\t{  8, 0x00 }, {  9, 0x00 }, { 10, 0x36 }, { 11, 0x10 },\n\t{ 12, 0x00 }, { 13, 0x00 }, { 14, 0x57 }, { 15, 0x00 },\n\t{ 16, 0x88 }, { 17, 0x88 }, { 18, 0x08 }, { 19, 0x08 }\n};\n\nstatic const int deemph_settings[] = {44100, 0, 48000, 32000};\n\nstatic int ak4641_set_deemph(struct snd_soc_component *component)\n{\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\tint i, best = 0;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(deemph_settings); i++) {\n\t\t \n\t\tif (ak4641->deemph && deemph_settings[i] != 0 &&\n\t\t    abs(deemph_settings[i] - ak4641->playback_fs) <\n\t\t    abs(deemph_settings[best] - ak4641->playback_fs))\n\t\t\tbest = i;\n\n\t\tif (!ak4641->deemph && deemph_settings[i] == 0)\n\t\t\tbest = i;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d\\n\", best);\n\n\treturn snd_soc_component_update_bits(component, AK4641_DAC, 0x3, best);\n}\n\nstatic int ak4641_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\tint deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tak4641->deemph = deemph;\n\n\treturn ak4641_set_deemph(component);\n}\n\nstatic int ak4641_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = ak4641->deemph;\n\treturn 0;\n};\n\nstatic const char *ak4641_mono_out[] = {\"(L + R)/2\", \"Hi-Z\"};\nstatic const char *ak4641_hp_out[] = {\"Stereo\", \"Mono\"};\nstatic const char *ak4641_mic_select[] = {\"Internal\", \"External\"};\nstatic const char *ak4641_mic_or_dac[] = {\"Microphone\", \"Voice DAC\"};\n\n\nstatic const DECLARE_TLV_DB_SCALE(mono_gain_tlv, -1700, 2300, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_boost_tlv, 0, 2000, 0);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1050, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(master_tlv, -12750, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_stereo_sidetone_tlv, -2700, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_mono_sidetone_tlv, -400, 400, 0);\nstatic const DECLARE_TLV_DB_SCALE(capture_tlv, -800, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_tlv, -800, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(aux_in_tlv, -2100, 300, 0);\n\n\nstatic SOC_ENUM_SINGLE_DECL(ak4641_mono_out_enum,\n\t\t\t    AK4641_SIG1, 6, ak4641_mono_out);\nstatic SOC_ENUM_SINGLE_DECL(ak4641_hp_out_enum,\n\t\t\t    AK4641_MODE2, 2, ak4641_hp_out);\nstatic SOC_ENUM_SINGLE_DECL(ak4641_mic_select_enum,\n\t\t\t    AK4641_MIC, 1, ak4641_mic_select);\nstatic SOC_ENUM_SINGLE_DECL(ak4641_mic_or_dac_enum,\n\t\t\t    AK4641_BTIF, 4, ak4641_mic_or_dac);\n\nstatic const struct snd_kcontrol_new ak4641_snd_controls[] = {\n\tSOC_ENUM(\"Mono 1 Output\", ak4641_mono_out_enum),\n\tSOC_SINGLE_TLV(\"Mono 1 Gain Volume\", AK4641_SIG1, 7, 1, 1,\n\t\t\t\t\t\t\tmono_gain_tlv),\n\tSOC_ENUM(\"Headphone Output\", ak4641_hp_out_enum),\n\tSOC_SINGLE_BOOL_EXT(\"Playback Deemphasis Switch\", 0,\n\t\t\t\t\tak4641_get_deemph, ak4641_put_deemph),\n\n\tSOC_SINGLE_TLV(\"Mic Boost Volume\", AK4641_MIC, 0, 1, 0, mic_boost_tlv),\n\n\tSOC_SINGLE(\"ALC Operation Time\", AK4641_TIMER, 0, 3, 0),\n\tSOC_SINGLE(\"ALC Recovery Time\", AK4641_TIMER, 2, 3, 0),\n\tSOC_SINGLE(\"ALC ZC Time\", AK4641_TIMER, 4, 3, 0),\n\n\tSOC_SINGLE(\"ALC 1 Switch\", AK4641_ALC1, 5, 1, 0),\n\n\tSOC_SINGLE_TLV(\"ALC Volume\", AK4641_ALC2, 0, 71, 0, alc_tlv),\n\tSOC_SINGLE(\"Left Out Enable Switch\", AK4641_SIG2, 1, 1, 0),\n\tSOC_SINGLE(\"Right Out Enable Switch\", AK4641_SIG2, 0, 1, 0),\n\n\tSOC_SINGLE_TLV(\"Capture Volume\", AK4641_PGA, 0, 71, 0, capture_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\", AK4641_LATT,\n\t\t\t\tAK4641_RATT, 0, 255, 1, master_tlv),\n\n\tSOC_SINGLE_TLV(\"AUX In Volume\", AK4641_VOL, 0, 15, 0, aux_in_tlv),\n\n\tSOC_SINGLE(\"Equalizer Switch\", AK4641_DAC, 2, 1, 0),\n\tSOC_SINGLE_TLV(\"EQ1 100 Hz Volume\", AK4641_EQLO, 0, 15, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ2 250 Hz Volume\", AK4641_EQLO, 4, 15, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ3 1 kHz Volume\", AK4641_EQMID, 0, 15, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ4 3.5 kHz Volume\", AK4641_EQMID, 4, 15, 1, eq_tlv),\n\tSOC_SINGLE_TLV(\"EQ5 10 kHz Volume\", AK4641_EQHI, 0, 15, 1, eq_tlv),\n};\n\n \nstatic const struct snd_kcontrol_new ak4641_mono1_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"Mic Mono Sidetone Volume\", AK4641_VOL, 7, 1, 0,\n\t\t\t\t\t\tmic_mono_sidetone_tlv),\n\tSOC_DAPM_SINGLE(\"Mic Mono Sidetone Switch\", AK4641_SIG1, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono Playback Switch\", AK4641_SIG1, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4641_stereo_mixer_controls[] = {\n\tSOC_DAPM_SINGLE_TLV(\"Mic Sidetone Volume\", AK4641_VOL, 4, 7, 0,\n\t\t\t\t\t\tmic_stereo_sidetone_tlv),\n\tSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", AK4641_SIG2, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"Playback Switch\", AK4641_SIG2, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Bypass Switch\", AK4641_SIG2, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4641_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic Capture Switch\", AK4641_MIC, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Capture Switch\", AK4641_MIC, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4641_mic_mux_control =\n\tSOC_DAPM_ENUM(\"Mic Select\", ak4641_mic_select_enum);\n\n \nstatic const struct snd_kcontrol_new ak4641_input_mux_control =\n\tSOC_DAPM_ENUM(\"Input Select\", ak4641_mic_or_dac_enum);\n\n \nstatic const struct snd_kcontrol_new ak4641_mono2_control =\n\tSOC_DAPM_SINGLE(\"Switch\", AK4641_SIG1, 0, 1, 0);\n\n \nstatic const struct snd_soc_dapm_widget ak4641_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Stereo Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_stereo_mixer_controls[0],\n\t\tARRAY_SIZE(ak4641_stereo_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mono1 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_mono1_mixer_controls[0],\n\t\tARRAY_SIZE(ak4641_mono1_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Input Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_input_mixer_controls[0],\n\t\tARRAY_SIZE(ak4641_input_mixer_controls)),\n\tSND_SOC_DAPM_MUX(\"Mic Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_mic_mux_control),\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_input_mux_control),\n\tSND_SOC_DAPM_SWITCH(\"Mono 2 Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4641_mono2_control),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"MOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"MOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"MICOUT\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", \"HiFi Capture\", AK4641_PM1, 0, 0),\n\tSND_SOC_DAPM_PGA(\"Mic\", AK4641_PM1, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"AUX In\", AK4641_PM1, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mono Out\", AK4641_PM1, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Line Out\", AK4641_PM1, 4, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", AK4641_PM2, 0, 0),\n\tSND_SOC_DAPM_PGA(\"Mono Out 2\", AK4641_PM2, 3, 0, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"Voice ADC\", \"Voice Capture\", AK4641_BTIF, 0, 0),\n\tSND_SOC_DAPM_DAC(\"Voice DAC\", \"Voice Playback\", AK4641_BTIF, 1, 0),\n\n\tSND_SOC_DAPM_MICBIAS(\"Mic Int Bias\", AK4641_MIC, 3, 0),\n\tSND_SOC_DAPM_MICBIAS(\"Mic Ext Bias\", AK4641_MIC, 4, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MICIN\"),\n\tSND_SOC_DAPM_INPUT(\"MICEXT\"),\n\tSND_SOC_DAPM_INPUT(\"AUX\"),\n\tSND_SOC_DAPM_INPUT(\"AIN\"),\n};\n\nstatic const struct snd_soc_dapm_route ak4641_audio_map[] = {\n\t \n\t{\"Stereo Mixer\", \"Playback Switch\", \"DAC\"},\n\t{\"Stereo Mixer\", \"Mic Sidetone Switch\", \"Input Mux\"},\n\t{\"Stereo Mixer\", \"Aux Bypass Switch\", \"AUX In\"},\n\n\t \n\t{\"Mono1 Mixer\", \"Mic Mono Sidetone Switch\", \"Input Mux\"},\n\t{\"Mono1 Mixer\", \"Mono Playback Switch\", \"DAC\"},\n\n\t \n\t{\"Mic\", NULL, \"AIN\"},\n\t{\"Mic Mux\", \"Internal\", \"Mic Int Bias\"},\n\t{\"Mic Mux\", \"External\", \"Mic Ext Bias\"},\n\t{\"Mic Int Bias\", NULL, \"MICIN\"},\n\t{\"Mic Ext Bias\", NULL, \"MICEXT\"},\n\t{\"MICOUT\", NULL, \"Mic Mux\"},\n\n\t \n\t{\"Input Mux\", \"Microphone\", \"Mic\"},\n\t{\"Input Mux\", \"Voice DAC\", \"Voice DAC\"},\n\n\t \n\t{\"LOUT\", NULL, \"Line Out\"},\n\t{\"ROUT\", NULL, \"Line Out\"},\n\t{\"Line Out\", NULL, \"Stereo Mixer\"},\n\n\t \n\t{\"MOUT1\", NULL, \"Mono Out\"},\n\t{\"Mono Out\", NULL, \"Mono1 Mixer\"},\n\n\t \n\t{\"MOUT2\", NULL, \"Mono 2 Enable\"},\n\t{\"Mono 2 Enable\", \"Switch\", \"Mono Out 2\"},\n\t{\"Mono Out 2\", NULL, \"Stereo Mixer\"},\n\n\t{\"Voice ADC\", NULL, \"Mono 2 Enable\"},\n\n\t \n\t{\"AUX In\", NULL, \"AUX\"},\n\n\t \n\t{\"ADC\", NULL, \"Input Mixer\"},\n\t{\"Input Mixer\", \"Mic Capture Switch\", \"Mic\"},\n\t{\"Input Mixer\", \"Aux Capture Switch\", \"AUX In\"},\n};\n\nstatic int ak4641_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\n\tak4641->sysclk = freq;\n\treturn 0;\n}\n\nstatic int ak4641_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\tint rate = params_rate(params), fs = 256;\n\tu8 mode2;\n\n\tif (rate)\n\t\tfs = ak4641->sysclk / rate;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tswitch (fs) {\n\tcase 1024:\n\t\tmode2 = (0x2 << 5);\n\t\tbreak;\n\tcase 512:\n\t\tmode2 = (0x1 << 5);\n\t\tbreak;\n\tcase 256:\n\t\tmode2 = (0x0 << 5);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Error: unsupported fs=%d\\n\", fs);\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AK4641_MODE2, (0x3 << 5), mode2);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tak4641->playback_fs = rate;\n\t\tak4641_set_deemph(component);\n\t}\n\n\treturn 0;\n}\n\nstatic int ak4641_pcm_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 btif;\n\tint ret;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbtif = (0x3 << 5);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tbtif = (0x2 << 5);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\t \n\t\tbtif = (0x0 << 5);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\t \n\t\tbtif = (0x1 << 5);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, AK4641_BTIF, (0x3 << 5), btif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ak4641_i2s_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 mode1 = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmode1 = 0x02;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tmode1 = 0x01;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn snd_soc_component_write(component, AK4641_MODE1, mode1);\n}\n\nstatic int ak4641_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\treturn snd_soc_component_update_bits(component, AK4641_DAC, 0x20, mute ? 0x20 : 0);\n}\n\nstatic int ak4641_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct ak4641_priv *ak4641 = snd_soc_component_get_drvdata(component);\n\tstruct ak4641_platform_data *pdata = component->dev->platform_data;\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\t \n\t\tsnd_soc_component_update_bits(component, AK4641_DAC, 0x20, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, AK4641_DAC, 0x20, 0x20);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tif (pdata && gpio_is_valid(pdata->gpio_power))\n\t\t\t\tgpio_set_value(pdata->gpio_power, 1);\n\t\t\tmdelay(1);\n\t\t\tif (pdata && gpio_is_valid(pdata->gpio_npdn))\n\t\t\t\tgpio_set_value(pdata->gpio_npdn, 1);\n\t\t\tmdelay(1);\n\n\t\t\tret = regcache_sync(ak4641->regmap);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tsnd_soc_component_update_bits(component, AK4641_PM1, 0x80, 0x80);\n\t\tsnd_soc_component_update_bits(component, AK4641_PM2, 0x80, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, AK4641_PM1, 0x80, 0);\n\t\tif (pdata && gpio_is_valid(pdata->gpio_npdn))\n\t\t\tgpio_set_value(pdata->gpio_npdn, 0);\n\t\tif (pdata && gpio_is_valid(pdata->gpio_power))\n\t\t\tgpio_set_value(pdata->gpio_power, 0);\n\t\tregcache_mark_dirty(ak4641->regmap);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define AK4641_RATES\t(SNDRV_PCM_RATE_8000_48000)\n#define AK4641_RATES_BT (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\t\t SNDRV_PCM_RATE_16000)\n#define AK4641_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE)\n\nstatic const struct snd_soc_dai_ops ak4641_i2s_dai_ops = {\n\t.hw_params    = ak4641_i2s_hw_params,\n\t.set_fmt      = ak4641_i2s_set_dai_fmt,\n\t.mute_stream  = ak4641_mute,\n\t.set_sysclk   = ak4641_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops ak4641_pcm_dai_ops = {\n\t.hw_params    = NULL,  \n\t.set_fmt      = ak4641_pcm_set_dai_fmt,\n\t.mute_stream  = ak4641_mute,\n\t.set_sysclk   = ak4641_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ak4641_dai[] = {\n{\n\t.name = \"ak4641-hifi\",\n\t.id = 1,\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = AK4641_RATES,\n\t\t.formats = AK4641_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"HiFi Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = AK4641_RATES,\n\t\t.formats = AK4641_FORMATS,\n\t},\n\t.ops = &ak4641_i2s_dai_ops,\n\t.symmetric_rate = 1,\n},\n{\n\t.name = \"ak4641-voice\",\n\t.id = 1,\n\t.playback = {\n\t\t.stream_name = \"Voice Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = AK4641_RATES_BT,\n\t\t.formats = AK4641_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Voice Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = AK4641_RATES_BT,\n\t\t.formats = AK4641_FORMATS,\n\t},\n\t.ops = &ak4641_pcm_dai_ops,\n\t.symmetric_rate = 1,\n},\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_ak4641 = {\n\t.controls\t\t= ak4641_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4641_snd_controls),\n\t.dapm_widgets\t\t= ak4641_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4641_dapm_widgets),\n\t.dapm_routes\t\t= ak4641_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4641_audio_map),\n\t.set_bias_level\t\t= ak4641_set_bias_level,\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4641_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = AK4641_BTIF,\n\t.reg_defaults = ak4641_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ak4641_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic int ak4641_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak4641_platform_data *pdata = i2c->dev.platform_data;\n\tstruct ak4641_priv *ak4641;\n\tint ret;\n\n\tak4641 = devm_kzalloc(&i2c->dev, sizeof(struct ak4641_priv),\n\t\t\t      GFP_KERNEL);\n\tif (!ak4641)\n\t\treturn -ENOMEM;\n\n\tak4641->regmap = devm_regmap_init_i2c(i2c, &ak4641_regmap);\n\tif (IS_ERR(ak4641->regmap))\n\t\treturn PTR_ERR(ak4641->regmap);\n\n\tif (pdata) {\n\t\tif (gpio_is_valid(pdata->gpio_power)) {\n\t\t\tret = gpio_request_one(pdata->gpio_power,\n\t\t\t\t\tGPIOF_OUT_INIT_LOW, \"ak4641 power\");\n\t\t\tif (ret)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tif (gpio_is_valid(pdata->gpio_npdn)) {\n\t\t\tret = gpio_request_one(pdata->gpio_npdn,\n\t\t\t\t\tGPIOF_OUT_INIT_LOW, \"ak4641 npdn\");\n\t\t\tif (ret)\n\t\t\t\tgoto err_gpio;\n\n\t\t\tudelay(1);  \n\t\t\tgpio_set_value(pdata->gpio_npdn, 1);\n\t\t}\n\t}\n\n\ti2c_set_clientdata(i2c, ak4641);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_component_dev_ak4641,\n\t\t\t\tak4641_dai, ARRAY_SIZE(ak4641_dai));\n\tif (ret != 0)\n\t\tgoto err_gpio2;\n\n\treturn 0;\n\nerr_gpio2:\n\tif (pdata) {\n\t\tif (gpio_is_valid(pdata->gpio_power))\n\t\t\tgpio_set_value(pdata->gpio_power, 0);\n\t\tif (gpio_is_valid(pdata->gpio_npdn))\n\t\t\tgpio_free(pdata->gpio_npdn);\n\t}\nerr_gpio:\n\tif (pdata && gpio_is_valid(pdata->gpio_power))\n\t\tgpio_free(pdata->gpio_power);\nerr_out:\n\treturn ret;\n}\n\nstatic void ak4641_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct ak4641_platform_data *pdata = i2c->dev.platform_data;\n\n\tif (pdata) {\n\t\tif (gpio_is_valid(pdata->gpio_power)) {\n\t\t\tgpio_set_value(pdata->gpio_power, 0);\n\t\t\tgpio_free(pdata->gpio_power);\n\t\t}\n\t\tif (gpio_is_valid(pdata->gpio_npdn))\n\t\t\tgpio_free(pdata->gpio_npdn);\n\t}\n}\n\nstatic const struct i2c_device_id ak4641_i2c_id[] = {\n\t{ \"ak4641\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ak4641_i2c_id);\n\nstatic struct i2c_driver ak4641_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4641\",\n\t},\n\t.probe =    ak4641_i2c_probe,\n\t.remove =   ak4641_i2c_remove,\n\t.id_table = ak4641_i2c_id,\n};\n\nmodule_i2c_driver(ak4641_i2c_driver);\n\nMODULE_DESCRIPTION(\"SoC AK4641 driver\");\nMODULE_AUTHOR(\"Harald Welte <laforge@gnufiish.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}