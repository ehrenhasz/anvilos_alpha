{
  "module_name": "wsa881x.c",
  "hash_id": "d1d689bff8bec50c3c9b3181cba8d2b302d143b9ac9c86f3f05e67503bec5d8f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wsa881x.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw_type.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define WSA881X_DIGITAL_BASE\t\t0x3000\n#define WSA881X_ANALOG_BASE\t\t0x3100\n\n \n#define WSA881X_CHIP_ID0\t\t\t(WSA881X_DIGITAL_BASE + 0x0000)\n#define WSA881X_CHIP_ID1\t\t\t(WSA881X_DIGITAL_BASE + 0x0001)\n#define WSA881X_CHIP_ID2\t\t\t(WSA881X_DIGITAL_BASE + 0x0002)\n#define WSA881X_CHIP_ID3\t\t\t(WSA881X_DIGITAL_BASE + 0x0003)\n#define WSA881X_BUS_ID\t\t\t\t(WSA881X_DIGITAL_BASE + 0x0004)\n#define WSA881X_CDC_RST_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0005)\n#define WSA881X_CDC_TOP_CLK_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0006)\n#define WSA881X_CDC_ANA_CLK_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0007)\n#define WSA881X_CDC_DIG_CLK_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0008)\n#define WSA881X_CLOCK_CONFIG\t\t\t(WSA881X_DIGITAL_BASE + 0x0009)\n#define WSA881X_ANA_CTL\t\t\t\t(WSA881X_DIGITAL_BASE + 0x000A)\n#define WSA881X_SWR_RESET_EN\t\t\t(WSA881X_DIGITAL_BASE + 0x000B)\n#define WSA881X_RESET_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x000C)\n#define WSA881X_TADC_VALUE_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x000F)\n#define WSA881X_TEMP_DETECT_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0010)\n#define WSA881X_TEMP_MSB\t\t\t(WSA881X_DIGITAL_BASE + 0x0011)\n#define WSA881X_TEMP_LSB\t\t\t(WSA881X_DIGITAL_BASE + 0x0012)\n#define WSA881X_TEMP_CONFIG0\t\t\t(WSA881X_DIGITAL_BASE + 0x0013)\n#define WSA881X_TEMP_CONFIG1\t\t\t(WSA881X_DIGITAL_BASE + 0x0014)\n#define WSA881X_CDC_CLIP_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0015)\n#define WSA881X_SDM_PDM9_LSB\t\t\t(WSA881X_DIGITAL_BASE + 0x0016)\n#define WSA881X_SDM_PDM9_MSB\t\t\t(WSA881X_DIGITAL_BASE + 0x0017)\n#define WSA881X_CDC_RX_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0018)\n#define WSA881X_DEM_BYPASS_DATA0\t\t(WSA881X_DIGITAL_BASE + 0x0019)\n#define WSA881X_DEM_BYPASS_DATA1\t\t(WSA881X_DIGITAL_BASE + 0x001A)\n#define WSA881X_DEM_BYPASS_DATA2\t\t(WSA881X_DIGITAL_BASE + 0x001B)\n#define WSA881X_DEM_BYPASS_DATA3\t\t(WSA881X_DIGITAL_BASE + 0x001C)\n#define WSA881X_OTP_CTRL0\t\t\t(WSA881X_DIGITAL_BASE + 0x001D)\n#define WSA881X_OTP_CTRL1\t\t\t(WSA881X_DIGITAL_BASE + 0x001E)\n#define WSA881X_HDRIVE_CTL_GROUP1\t\t(WSA881X_DIGITAL_BASE + 0x001F)\n#define WSA881X_INTR_MODE\t\t\t(WSA881X_DIGITAL_BASE + 0x0020)\n#define WSA881X_INTR_MASK\t\t\t(WSA881X_DIGITAL_BASE + 0x0021)\n#define WSA881X_INTR_STATUS\t\t\t(WSA881X_DIGITAL_BASE + 0x0022)\n#define WSA881X_INTR_CLEAR\t\t\t(WSA881X_DIGITAL_BASE + 0x0023)\n#define WSA881X_INTR_LEVEL\t\t\t(WSA881X_DIGITAL_BASE + 0x0024)\n#define WSA881X_INTR_SET\t\t\t(WSA881X_DIGITAL_BASE + 0x0025)\n#define WSA881X_INTR_TEST\t\t\t(WSA881X_DIGITAL_BASE + 0x0026)\n#define WSA881X_PDM_TEST_MODE\t\t\t(WSA881X_DIGITAL_BASE + 0x0030)\n#define WSA881X_ATE_TEST_MODE\t\t\t(WSA881X_DIGITAL_BASE + 0x0031)\n#define WSA881X_PIN_CTL_MODE\t\t\t(WSA881X_DIGITAL_BASE + 0x0032)\n#define WSA881X_PIN_CTL_OE\t\t\t(WSA881X_DIGITAL_BASE + 0x0033)\n#define WSA881X_PIN_WDATA_IOPAD\t\t\t(WSA881X_DIGITAL_BASE + 0x0034)\n#define WSA881X_PIN_STATUS\t\t\t(WSA881X_DIGITAL_BASE + 0x0035)\n#define WSA881X_DIG_DEBUG_MODE\t\t\t(WSA881X_DIGITAL_BASE + 0x0037)\n#define WSA881X_DIG_DEBUG_SEL\t\t\t(WSA881X_DIGITAL_BASE + 0x0038)\n#define WSA881X_DIG_DEBUG_EN\t\t\t(WSA881X_DIGITAL_BASE + 0x0039)\n#define WSA881X_SWR_HM_TEST1\t\t\t(WSA881X_DIGITAL_BASE + 0x003B)\n#define WSA881X_SWR_HM_TEST2\t\t\t(WSA881X_DIGITAL_BASE + 0x003C)\n#define WSA881X_TEMP_DETECT_DBG_CTL\t\t(WSA881X_DIGITAL_BASE + 0x003D)\n#define WSA881X_TEMP_DEBUG_MSB\t\t\t(WSA881X_DIGITAL_BASE + 0x003E)\n#define WSA881X_TEMP_DEBUG_LSB\t\t\t(WSA881X_DIGITAL_BASE + 0x003F)\n#define WSA881X_SAMPLE_EDGE_SEL\t\t\t(WSA881X_DIGITAL_BASE + 0x0044)\n#define WSA881X_IOPAD_CTL\t\t\t(WSA881X_DIGITAL_BASE + 0x0045)\n#define WSA881X_SPARE_0\t\t\t\t(WSA881X_DIGITAL_BASE + 0x0050)\n#define WSA881X_SPARE_1\t\t\t\t(WSA881X_DIGITAL_BASE + 0x0051)\n#define WSA881X_SPARE_2\t\t\t\t(WSA881X_DIGITAL_BASE + 0x0052)\n#define WSA881X_OTP_REG_0\t\t\t(WSA881X_DIGITAL_BASE + 0x0080)\n#define WSA881X_OTP_REG_1\t\t\t(WSA881X_DIGITAL_BASE + 0x0081)\n#define WSA881X_OTP_REG_2\t\t\t(WSA881X_DIGITAL_BASE + 0x0082)\n#define WSA881X_OTP_REG_3\t\t\t(WSA881X_DIGITAL_BASE + 0x0083)\n#define WSA881X_OTP_REG_4\t\t\t(WSA881X_DIGITAL_BASE + 0x0084)\n#define WSA881X_OTP_REG_5\t\t\t(WSA881X_DIGITAL_BASE + 0x0085)\n#define WSA881X_OTP_REG_6\t\t\t(WSA881X_DIGITAL_BASE + 0x0086)\n#define WSA881X_OTP_REG_7\t\t\t(WSA881X_DIGITAL_BASE + 0x0087)\n#define WSA881X_OTP_REG_8\t\t\t(WSA881X_DIGITAL_BASE + 0x0088)\n#define WSA881X_OTP_REG_9\t\t\t(WSA881X_DIGITAL_BASE + 0x0089)\n#define WSA881X_OTP_REG_10\t\t\t(WSA881X_DIGITAL_BASE + 0x008A)\n#define WSA881X_OTP_REG_11\t\t\t(WSA881X_DIGITAL_BASE + 0x008B)\n#define WSA881X_OTP_REG_12\t\t\t(WSA881X_DIGITAL_BASE + 0x008C)\n#define WSA881X_OTP_REG_13\t\t\t(WSA881X_DIGITAL_BASE + 0x008D)\n#define WSA881X_OTP_REG_14\t\t\t(WSA881X_DIGITAL_BASE + 0x008E)\n#define WSA881X_OTP_REG_15\t\t\t(WSA881X_DIGITAL_BASE + 0x008F)\n#define WSA881X_OTP_REG_16\t\t\t(WSA881X_DIGITAL_BASE + 0x0090)\n#define WSA881X_OTP_REG_17\t\t\t(WSA881X_DIGITAL_BASE + 0x0091)\n#define WSA881X_OTP_REG_18\t\t\t(WSA881X_DIGITAL_BASE + 0x0092)\n#define WSA881X_OTP_REG_19\t\t\t(WSA881X_DIGITAL_BASE + 0x0093)\n#define WSA881X_OTP_REG_20\t\t\t(WSA881X_DIGITAL_BASE + 0x0094)\n#define WSA881X_OTP_REG_21\t\t\t(WSA881X_DIGITAL_BASE + 0x0095)\n#define WSA881X_OTP_REG_22\t\t\t(WSA881X_DIGITAL_BASE + 0x0096)\n#define WSA881X_OTP_REG_23\t\t\t(WSA881X_DIGITAL_BASE + 0x0097)\n#define WSA881X_OTP_REG_24\t\t\t(WSA881X_DIGITAL_BASE + 0x0098)\n#define WSA881X_OTP_REG_25\t\t\t(WSA881X_DIGITAL_BASE + 0x0099)\n#define WSA881X_OTP_REG_26\t\t\t(WSA881X_DIGITAL_BASE + 0x009A)\n#define WSA881X_OTP_REG_27\t\t\t(WSA881X_DIGITAL_BASE + 0x009B)\n#define WSA881X_OTP_REG_28\t\t\t(WSA881X_DIGITAL_BASE + 0x009C)\n#define WSA881X_OTP_REG_29\t\t\t(WSA881X_DIGITAL_BASE + 0x009D)\n#define WSA881X_OTP_REG_30\t\t\t(WSA881X_DIGITAL_BASE + 0x009E)\n#define WSA881X_OTP_REG_31\t\t\t(WSA881X_DIGITAL_BASE + 0x009F)\n#define WSA881X_OTP_REG_63\t\t\t(WSA881X_DIGITAL_BASE + 0x00BF)\n\n \n#define WSA881X_BIAS_REF_CTRL\t\t\t(WSA881X_ANALOG_BASE + 0x0000)\n#define WSA881X_BIAS_TEST\t\t\t(WSA881X_ANALOG_BASE + 0x0001)\n#define WSA881X_BIAS_BIAS\t\t\t(WSA881X_ANALOG_BASE + 0x0002)\n#define WSA881X_TEMP_OP\t\t\t\t(WSA881X_ANALOG_BASE + 0x0003)\n#define WSA881X_TEMP_IREF_CTRL\t\t\t(WSA881X_ANALOG_BASE + 0x0004)\n#define WSA881X_TEMP_ISENS_CTRL\t\t\t(WSA881X_ANALOG_BASE + 0x0005)\n#define WSA881X_TEMP_CLK_CTRL\t\t\t(WSA881X_ANALOG_BASE + 0x0006)\n#define WSA881X_TEMP_TEST\t\t\t(WSA881X_ANALOG_BASE + 0x0007)\n#define WSA881X_TEMP_BIAS\t\t\t(WSA881X_ANALOG_BASE + 0x0008)\n#define WSA881X_TEMP_ADC_CTRL\t\t\t(WSA881X_ANALOG_BASE + 0x0009)\n#define WSA881X_TEMP_DOUT_MSB\t\t\t(WSA881X_ANALOG_BASE + 0x000A)\n#define WSA881X_TEMP_DOUT_LSB\t\t\t(WSA881X_ANALOG_BASE + 0x000B)\n#define WSA881X_ADC_EN_MODU_V\t\t\t(WSA881X_ANALOG_BASE + 0x0010)\n#define WSA881X_ADC_EN_MODU_I\t\t\t(WSA881X_ANALOG_BASE + 0x0011)\n#define WSA881X_ADC_EN_DET_TEST_V\t\t(WSA881X_ANALOG_BASE + 0x0012)\n#define WSA881X_ADC_EN_DET_TEST_I\t\t(WSA881X_ANALOG_BASE + 0x0013)\n#define WSA881X_ADC_SEL_IBIAS\t\t\t(WSA881X_ANALOG_BASE + 0x0014)\n#define WSA881X_ADC_EN_SEL_IBAIS\t\t(WSA881X_ANALOG_BASE + 0x0015)\n#define WSA881X_SPKR_DRV_EN\t\t\t(WSA881X_ANALOG_BASE + 0x001A)\n#define WSA881X_SPKR_DRV_GAIN\t\t\t(WSA881X_ANALOG_BASE + 0x001B)\n#define WSA881X_PA_GAIN_SEL_MASK\t\tBIT(3)\n#define WSA881X_PA_GAIN_SEL_REG\t\t\tBIT(3)\n#define WSA881X_PA_GAIN_SEL_DRE\t\t\t0\n#define WSA881X_SPKR_PAG_GAIN_MASK\t\tGENMASK(7, 4)\n#define WSA881X_SPKR_DAC_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x001C)\n#define WSA881X_SPKR_DRV_DBG\t\t\t(WSA881X_ANALOG_BASE + 0x001D)\n#define WSA881X_SPKR_PWRSTG_DBG\t\t\t(WSA881X_ANALOG_BASE + 0x001E)\n#define WSA881X_SPKR_OCP_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x001F)\n#define WSA881X_SPKR_OCP_MASK\t\t\tGENMASK(7, 6)\n#define WSA881X_SPKR_OCP_EN\t\t\tBIT(7)\n#define WSA881X_SPKR_OCP_HOLD\t\t\tBIT(6)\n#define WSA881X_SPKR_CLIP_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0020)\n#define WSA881X_SPKR_BBM_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0021)\n#define WSA881X_SPKR_MISC_CTL1\t\t\t(WSA881X_ANALOG_BASE + 0x0022)\n#define WSA881X_SPKR_MISC_CTL2\t\t\t(WSA881X_ANALOG_BASE + 0x0023)\n#define WSA881X_SPKR_BIAS_INT\t\t\t(WSA881X_ANALOG_BASE + 0x0024)\n#define WSA881X_SPKR_PA_INT\t\t\t(WSA881X_ANALOG_BASE + 0x0025)\n#define WSA881X_SPKR_BIAS_CAL\t\t\t(WSA881X_ANALOG_BASE + 0x0026)\n#define WSA881X_SPKR_BIAS_PSRR\t\t\t(WSA881X_ANALOG_BASE + 0x0027)\n#define WSA881X_SPKR_STATUS1\t\t\t(WSA881X_ANALOG_BASE + 0x0028)\n#define WSA881X_SPKR_STATUS2\t\t\t(WSA881X_ANALOG_BASE + 0x0029)\n#define WSA881X_BOOST_EN_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x002A)\n#define WSA881X_BOOST_EN_MASK\t\t\tBIT(7)\n#define WSA881X_BOOST_EN\t\t\tBIT(7)\n#define WSA881X_BOOST_CURRENT_LIMIT\t\t(WSA881X_ANALOG_BASE + 0x002B)\n#define WSA881X_BOOST_PS_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x002C)\n#define WSA881X_BOOST_PRESET_OUT1\t\t(WSA881X_ANALOG_BASE + 0x002D)\n#define WSA881X_BOOST_PRESET_OUT2\t\t(WSA881X_ANALOG_BASE + 0x002E)\n#define WSA881X_BOOST_FORCE_OUT\t\t\t(WSA881X_ANALOG_BASE + 0x002F)\n#define WSA881X_BOOST_LDO_PROG\t\t\t(WSA881X_ANALOG_BASE + 0x0030)\n#define WSA881X_BOOST_SLOPE_COMP_ISENSE_FB\t(WSA881X_ANALOG_BASE + 0x0031)\n#define WSA881X_BOOST_RON_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0032)\n#define WSA881X_BOOST_LOOP_STABILITY\t\t(WSA881X_ANALOG_BASE + 0x0033)\n#define WSA881X_BOOST_ZX_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0034)\n#define WSA881X_BOOST_START_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0035)\n#define WSA881X_BOOST_MISC1_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0036)\n#define WSA881X_BOOST_MISC2_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0037)\n#define WSA881X_BOOST_MISC3_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0038)\n#define WSA881X_BOOST_ATEST_CTL\t\t\t(WSA881X_ANALOG_BASE + 0x0039)\n#define WSA881X_SPKR_PROT_FE_GAIN\t\t(WSA881X_ANALOG_BASE + 0x003A)\n#define WSA881X_SPKR_PROT_FE_CM_LDO_SET\t\t(WSA881X_ANALOG_BASE + 0x003B)\n#define WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET1\t(WSA881X_ANALOG_BASE + 0x003C)\n#define WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET2\t(WSA881X_ANALOG_BASE + 0x003D)\n#define WSA881X_SPKR_PROT_ATEST1\t\t(WSA881X_ANALOG_BASE + 0x003E)\n#define WSA881X_SPKR_PROT_ATEST2\t\t(WSA881X_ANALOG_BASE + 0x003F)\n#define WSA881X_SPKR_PROT_FE_VSENSE_VCM\t\t(WSA881X_ANALOG_BASE + 0x0040)\n#define WSA881X_SPKR_PROT_FE_VSENSE_BIAS_SET1\t(WSA881X_ANALOG_BASE + 0x0041)\n#define WSA881X_BONGO_RESRV_REG1\t\t(WSA881X_ANALOG_BASE + 0x0042)\n#define WSA881X_BONGO_RESRV_REG2\t\t(WSA881X_ANALOG_BASE + 0x0043)\n#define WSA881X_SPKR_PROT_SAR\t\t\t(WSA881X_ANALOG_BASE + 0x0044)\n#define WSA881X_SPKR_STATUS3\t\t\t(WSA881X_ANALOG_BASE + 0x0045)\n\n#define SWRS_SCP_FRAME_CTRL_BANK(m)\t\t(0x60 + 0x10 * (m))\n#define SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(m)\t(0xE0 + 0x10 * (m))\n#define SWR_SLV_MAX_REG_ADDR\t0x390\n#define SWR_SLV_START_REG_ADDR\t0x40\n#define SWR_SLV_MAX_BUF_LEN\t20\n#define BYTES_PER_LINE\t\t12\n#define SWR_SLV_RD_BUF_LEN\t8\n#define SWR_SLV_WR_BUF_LEN\t32\n#define SWR_SLV_MAX_DEVICES\t2\n#define WSA881X_MAX_SWR_PORTS   4\n#define WSA881X_VERSION_ENTRY_SIZE 27\n#define WSA881X_OCP_CTL_TIMER_SEC 2\n#define WSA881X_OCP_CTL_TEMP_CELSIUS 25\n#define WSA881X_OCP_CTL_POLL_TIMER_SEC 60\n#define WSA881X_PROBE_TIMEOUT 1000\n\n#define WSA881X_PA_GAIN_TLV(xname, reg, shift, max, invert, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.tlv.p = (tlv_array), \\\n\t.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\\n\t.put = wsa881x_put_pa_gain, \\\n\t.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }\n\nstatic struct reg_default wsa881x_defaults[] = {\n\t{ WSA881X_CHIP_ID0, 0x00 },\n\t{ WSA881X_CHIP_ID1, 0x00 },\n\t{ WSA881X_CHIP_ID2, 0x00 },\n\t{ WSA881X_CHIP_ID3, 0x02 },\n\t{ WSA881X_BUS_ID, 0x00 },\n\t{ WSA881X_CDC_RST_CTL, 0x00 },\n\t{ WSA881X_CDC_TOP_CLK_CTL, 0x03 },\n\t{ WSA881X_CDC_ANA_CLK_CTL, 0x00 },\n\t{ WSA881X_CDC_DIG_CLK_CTL, 0x00 },\n\t{ WSA881X_CLOCK_CONFIG, 0x00 },\n\t{ WSA881X_ANA_CTL, 0x08 },\n\t{ WSA881X_SWR_RESET_EN, 0x00 },\n\t{ WSA881X_TEMP_DETECT_CTL, 0x01 },\n\t{ WSA881X_TEMP_MSB, 0x00 },\n\t{ WSA881X_TEMP_LSB, 0x00 },\n\t{ WSA881X_TEMP_CONFIG0, 0x00 },\n\t{ WSA881X_TEMP_CONFIG1, 0x00 },\n\t{ WSA881X_CDC_CLIP_CTL, 0x03 },\n\t{ WSA881X_SDM_PDM9_LSB, 0x00 },\n\t{ WSA881X_SDM_PDM9_MSB, 0x00 },\n\t{ WSA881X_CDC_RX_CTL, 0x7E },\n\t{ WSA881X_DEM_BYPASS_DATA0, 0x00 },\n\t{ WSA881X_DEM_BYPASS_DATA1, 0x00 },\n\t{ WSA881X_DEM_BYPASS_DATA2, 0x00 },\n\t{ WSA881X_DEM_BYPASS_DATA3, 0x00 },\n\t{ WSA881X_OTP_CTRL0, 0x00 },\n\t{ WSA881X_OTP_CTRL1, 0x00 },\n\t{ WSA881X_HDRIVE_CTL_GROUP1, 0x00 },\n\t{ WSA881X_INTR_MODE, 0x00 },\n\t{ WSA881X_INTR_STATUS, 0x00 },\n\t{ WSA881X_INTR_CLEAR, 0x00 },\n\t{ WSA881X_INTR_LEVEL, 0x00 },\n\t{ WSA881X_INTR_SET, 0x00 },\n\t{ WSA881X_INTR_TEST, 0x00 },\n\t{ WSA881X_PDM_TEST_MODE, 0x00 },\n\t{ WSA881X_ATE_TEST_MODE, 0x00 },\n\t{ WSA881X_PIN_CTL_MODE, 0x00 },\n\t{ WSA881X_PIN_CTL_OE, 0x00 },\n\t{ WSA881X_PIN_WDATA_IOPAD, 0x00 },\n\t{ WSA881X_PIN_STATUS, 0x00 },\n\t{ WSA881X_DIG_DEBUG_MODE, 0x00 },\n\t{ WSA881X_DIG_DEBUG_SEL, 0x00 },\n\t{ WSA881X_DIG_DEBUG_EN, 0x00 },\n\t{ WSA881X_SWR_HM_TEST1, 0x08 },\n\t{ WSA881X_SWR_HM_TEST2, 0x00 },\n\t{ WSA881X_TEMP_DETECT_DBG_CTL, 0x00 },\n\t{ WSA881X_TEMP_DEBUG_MSB, 0x00 },\n\t{ WSA881X_TEMP_DEBUG_LSB, 0x00 },\n\t{ WSA881X_SAMPLE_EDGE_SEL, 0x0C },\n\t{ WSA881X_SPARE_0, 0x00 },\n\t{ WSA881X_SPARE_1, 0x00 },\n\t{ WSA881X_SPARE_2, 0x00 },\n\t{ WSA881X_OTP_REG_0, 0x01 },\n\t{ WSA881X_OTP_REG_1, 0xFF },\n\t{ WSA881X_OTP_REG_2, 0xC0 },\n\t{ WSA881X_OTP_REG_3, 0xFF },\n\t{ WSA881X_OTP_REG_4, 0xC0 },\n\t{ WSA881X_OTP_REG_5, 0xFF },\n\t{ WSA881X_OTP_REG_6, 0xFF },\n\t{ WSA881X_OTP_REG_7, 0xFF },\n\t{ WSA881X_OTP_REG_8, 0xFF },\n\t{ WSA881X_OTP_REG_9, 0xFF },\n\t{ WSA881X_OTP_REG_10, 0xFF },\n\t{ WSA881X_OTP_REG_11, 0xFF },\n\t{ WSA881X_OTP_REG_12, 0xFF },\n\t{ WSA881X_OTP_REG_13, 0xFF },\n\t{ WSA881X_OTP_REG_14, 0xFF },\n\t{ WSA881X_OTP_REG_15, 0xFF },\n\t{ WSA881X_OTP_REG_16, 0xFF },\n\t{ WSA881X_OTP_REG_17, 0xFF },\n\t{ WSA881X_OTP_REG_18, 0xFF },\n\t{ WSA881X_OTP_REG_19, 0xFF },\n\t{ WSA881X_OTP_REG_20, 0xFF },\n\t{ WSA881X_OTP_REG_21, 0xFF },\n\t{ WSA881X_OTP_REG_22, 0xFF },\n\t{ WSA881X_OTP_REG_23, 0xFF },\n\t{ WSA881X_OTP_REG_24, 0x03 },\n\t{ WSA881X_OTP_REG_25, 0x01 },\n\t{ WSA881X_OTP_REG_26, 0x03 },\n\t{ WSA881X_OTP_REG_27, 0x11 },\n\t{ WSA881X_OTP_REG_63, 0x40 },\n\t \n\t{ WSA881X_BIAS_REF_CTRL, 0x6C },\n\t{ WSA881X_BIAS_TEST, 0x16 },\n\t{ WSA881X_BIAS_BIAS, 0xF0 },\n\t{ WSA881X_TEMP_OP, 0x00 },\n\t{ WSA881X_TEMP_IREF_CTRL, 0x56 },\n\t{ WSA881X_TEMP_ISENS_CTRL, 0x47 },\n\t{ WSA881X_TEMP_CLK_CTRL, 0x87 },\n\t{ WSA881X_TEMP_TEST, 0x00 },\n\t{ WSA881X_TEMP_BIAS, 0x51 },\n\t{ WSA881X_TEMP_DOUT_MSB, 0x00 },\n\t{ WSA881X_TEMP_DOUT_LSB, 0x00 },\n\t{ WSA881X_ADC_EN_MODU_V, 0x00 },\n\t{ WSA881X_ADC_EN_MODU_I, 0x00 },\n\t{ WSA881X_ADC_EN_DET_TEST_V, 0x00 },\n\t{ WSA881X_ADC_EN_DET_TEST_I, 0x00 },\n\t{ WSA881X_ADC_EN_SEL_IBAIS, 0x10 },\n\t{ WSA881X_SPKR_DRV_EN, 0x74 },\n\t{ WSA881X_SPKR_DRV_DBG, 0x15 },\n\t{ WSA881X_SPKR_PWRSTG_DBG, 0x00 },\n\t{ WSA881X_SPKR_OCP_CTL, 0xD4 },\n\t{ WSA881X_SPKR_CLIP_CTL, 0x90 },\n\t{ WSA881X_SPKR_PA_INT, 0x54 },\n\t{ WSA881X_SPKR_BIAS_CAL, 0xAC },\n\t{ WSA881X_SPKR_STATUS1, 0x00 },\n\t{ WSA881X_SPKR_STATUS2, 0x00 },\n\t{ WSA881X_BOOST_EN_CTL, 0x18 },\n\t{ WSA881X_BOOST_CURRENT_LIMIT, 0x7A },\n\t{ WSA881X_BOOST_PRESET_OUT2, 0x70 },\n\t{ WSA881X_BOOST_FORCE_OUT, 0x0E },\n\t{ WSA881X_BOOST_LDO_PROG, 0x16 },\n\t{ WSA881X_BOOST_SLOPE_COMP_ISENSE_FB, 0x71 },\n\t{ WSA881X_BOOST_RON_CTL, 0x0F },\n\t{ WSA881X_BOOST_ZX_CTL, 0x34 },\n\t{ WSA881X_BOOST_START_CTL, 0x23 },\n\t{ WSA881X_BOOST_MISC1_CTL, 0x80 },\n\t{ WSA881X_BOOST_MISC2_CTL, 0x00 },\n\t{ WSA881X_BOOST_MISC3_CTL, 0x00 },\n\t{ WSA881X_BOOST_ATEST_CTL, 0x00 },\n\t{ WSA881X_SPKR_PROT_FE_GAIN, 0x46 },\n\t{ WSA881X_SPKR_PROT_FE_CM_LDO_SET, 0x3B },\n\t{ WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET1, 0x8D },\n\t{ WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET2, 0x8D },\n\t{ WSA881X_SPKR_PROT_ATEST1, 0x01 },\n\t{ WSA881X_SPKR_PROT_FE_VSENSE_VCM, 0x8D },\n\t{ WSA881X_SPKR_PROT_FE_VSENSE_BIAS_SET1, 0x4D },\n\t{ WSA881X_SPKR_PROT_SAR, 0x00 },\n\t{ WSA881X_SPKR_STATUS3, 0x00 },\n};\n\nstatic const struct reg_sequence wsa881x_pre_pmu_pa_2_0[] = {\n\t{ WSA881X_SPKR_DRV_GAIN, 0x41, 0 },\n\t{ WSA881X_SPKR_MISC_CTL1, 0x87, 0 },\n};\n\nstatic const struct reg_sequence wsa881x_vi_txfe_en_2_0[] = {\n\t{ WSA881X_SPKR_PROT_FE_VSENSE_VCM, 0x85, 0 },\n\t{ WSA881X_SPKR_PROT_ATEST2, 0x0A, 0 },\n\t{ WSA881X_SPKR_PROT_FE_GAIN, 0x47, 0 },\n};\n\n \nstatic struct reg_sequence wsa881x_rev_2_0[] = {\n\t{ WSA881X_RESET_CTL, 0x00, 0x00 },\n\t{ WSA881X_TADC_VALUE_CTL, 0x01, 0x00 },\n\t{ WSA881X_INTR_MASK, 0x1B, 0x00 },\n\t{ WSA881X_IOPAD_CTL, 0x00, 0x00 },\n\t{ WSA881X_OTP_REG_28, 0x3F, 0x00 },\n\t{ WSA881X_OTP_REG_29, 0x3F, 0x00 },\n\t{ WSA881X_OTP_REG_30, 0x01, 0x00 },\n\t{ WSA881X_OTP_REG_31, 0x01, 0x00 },\n\t{ WSA881X_TEMP_ADC_CTRL, 0x03, 0x00 },\n\t{ WSA881X_ADC_SEL_IBIAS, 0x45, 0x00 },\n\t{ WSA881X_SPKR_DRV_GAIN, 0xC1, 0x00 },\n\t{ WSA881X_SPKR_DAC_CTL, 0x42, 0x00 },\n\t{ WSA881X_SPKR_BBM_CTL, 0x02, 0x00 },\n\t{ WSA881X_SPKR_MISC_CTL1, 0x40, 0x00 },\n\t{ WSA881X_SPKR_MISC_CTL2, 0x07, 0x00 },\n\t{ WSA881X_SPKR_BIAS_INT, 0x5F, 0x00 },\n\t{ WSA881X_SPKR_BIAS_PSRR, 0x44, 0x00 },\n\t{ WSA881X_BOOST_PS_CTL, 0xA0, 0x00 },\n\t{ WSA881X_BOOST_PRESET_OUT1, 0xB7, 0x00 },\n\t{ WSA881X_BOOST_LOOP_STABILITY, 0x8D, 0x00 },\n\t{ WSA881X_SPKR_PROT_ATEST2, 0x02, 0x00 },\n\t{ WSA881X_BONGO_RESRV_REG1, 0x5E, 0x00 },\n\t{ WSA881X_BONGO_RESRV_REG2, 0x07, 0x00 },\n};\n\nenum wsa_port_ids {\n\tWSA881X_PORT_DAC,\n\tWSA881X_PORT_COMP,\n\tWSA881X_PORT_BOOST,\n\tWSA881X_PORT_VISENSE,\n};\n\n \nstatic struct sdw_dpn_prop wsa_sink_dpn_prop[WSA881X_MAX_SWR_PORTS] = {\n\t{\n\t\t \n\t\t.num = 1,\n\t\t.type = SDW_DPN_SIMPLE,\n\t\t.min_ch = 1,\n\t\t.max_ch = 1,\n\t\t.simple_ch_prep_sm = true,\n\t\t.read_only_wordlength = true,\n\t}, {\n\t\t \n\t\t.num = 2,\n\t\t.type = SDW_DPN_SIMPLE,\n\t\t.min_ch = 1,\n\t\t.max_ch = 1,\n\t\t.simple_ch_prep_sm = true,\n\t\t.read_only_wordlength = true,\n\t}, {\n\t\t \n\t\t.num = 3,\n\t\t.type = SDW_DPN_SIMPLE,\n\t\t.min_ch = 1,\n\t\t.max_ch = 1,\n\t\t.simple_ch_prep_sm = true,\n\t\t.read_only_wordlength = true,\n\t}, {\n\t\t \n\t\t.num = 4,\n\t\t.type = SDW_DPN_SIMPLE,\n\t\t.min_ch = 1,\n\t\t.max_ch = 1,\n\t\t.simple_ch_prep_sm = true,\n\t\t.read_only_wordlength = true,\n\t}\n};\n\nstatic const struct sdw_port_config wsa881x_pconfig[WSA881X_MAX_SWR_PORTS] = {\n\t{\n\t\t.num = 1,\n\t\t.ch_mask = 0x1,\n\t}, {\n\t\t.num = 2,\n\t\t.ch_mask = 0xf,\n\t}, {\n\t\t.num = 3,\n\t\t.ch_mask = 0x3,\n\t}, {\t \n\t\t.num = 4,\n\t\t.ch_mask = 0x3,\n\t},\n};\n\nstatic bool wsa881x_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WSA881X_CHIP_ID0:\n\tcase WSA881X_CHIP_ID1:\n\tcase WSA881X_CHIP_ID2:\n\tcase WSA881X_CHIP_ID3:\n\tcase WSA881X_BUS_ID:\n\tcase WSA881X_CDC_RST_CTL:\n\tcase WSA881X_CDC_TOP_CLK_CTL:\n\tcase WSA881X_CDC_ANA_CLK_CTL:\n\tcase WSA881X_CDC_DIG_CLK_CTL:\n\tcase WSA881X_CLOCK_CONFIG:\n\tcase WSA881X_ANA_CTL:\n\tcase WSA881X_SWR_RESET_EN:\n\tcase WSA881X_RESET_CTL:\n\tcase WSA881X_TADC_VALUE_CTL:\n\tcase WSA881X_TEMP_DETECT_CTL:\n\tcase WSA881X_TEMP_MSB:\n\tcase WSA881X_TEMP_LSB:\n\tcase WSA881X_TEMP_CONFIG0:\n\tcase WSA881X_TEMP_CONFIG1:\n\tcase WSA881X_CDC_CLIP_CTL:\n\tcase WSA881X_SDM_PDM9_LSB:\n\tcase WSA881X_SDM_PDM9_MSB:\n\tcase WSA881X_CDC_RX_CTL:\n\tcase WSA881X_DEM_BYPASS_DATA0:\n\tcase WSA881X_DEM_BYPASS_DATA1:\n\tcase WSA881X_DEM_BYPASS_DATA2:\n\tcase WSA881X_DEM_BYPASS_DATA3:\n\tcase WSA881X_OTP_CTRL0:\n\tcase WSA881X_OTP_CTRL1:\n\tcase WSA881X_HDRIVE_CTL_GROUP1:\n\tcase WSA881X_INTR_MODE:\n\tcase WSA881X_INTR_MASK:\n\tcase WSA881X_INTR_STATUS:\n\tcase WSA881X_INTR_CLEAR:\n\tcase WSA881X_INTR_LEVEL:\n\tcase WSA881X_INTR_SET:\n\tcase WSA881X_INTR_TEST:\n\tcase WSA881X_PDM_TEST_MODE:\n\tcase WSA881X_ATE_TEST_MODE:\n\tcase WSA881X_PIN_CTL_MODE:\n\tcase WSA881X_PIN_CTL_OE:\n\tcase WSA881X_PIN_WDATA_IOPAD:\n\tcase WSA881X_PIN_STATUS:\n\tcase WSA881X_DIG_DEBUG_MODE:\n\tcase WSA881X_DIG_DEBUG_SEL:\n\tcase WSA881X_DIG_DEBUG_EN:\n\tcase WSA881X_SWR_HM_TEST1:\n\tcase WSA881X_SWR_HM_TEST2:\n\tcase WSA881X_TEMP_DETECT_DBG_CTL:\n\tcase WSA881X_TEMP_DEBUG_MSB:\n\tcase WSA881X_TEMP_DEBUG_LSB:\n\tcase WSA881X_SAMPLE_EDGE_SEL:\n\tcase WSA881X_IOPAD_CTL:\n\tcase WSA881X_SPARE_0:\n\tcase WSA881X_SPARE_1:\n\tcase WSA881X_SPARE_2:\n\tcase WSA881X_OTP_REG_0:\n\tcase WSA881X_OTP_REG_1:\n\tcase WSA881X_OTP_REG_2:\n\tcase WSA881X_OTP_REG_3:\n\tcase WSA881X_OTP_REG_4:\n\tcase WSA881X_OTP_REG_5:\n\tcase WSA881X_OTP_REG_6:\n\tcase WSA881X_OTP_REG_7:\n\tcase WSA881X_OTP_REG_8:\n\tcase WSA881X_OTP_REG_9:\n\tcase WSA881X_OTP_REG_10:\n\tcase WSA881X_OTP_REG_11:\n\tcase WSA881X_OTP_REG_12:\n\tcase WSA881X_OTP_REG_13:\n\tcase WSA881X_OTP_REG_14:\n\tcase WSA881X_OTP_REG_15:\n\tcase WSA881X_OTP_REG_16:\n\tcase WSA881X_OTP_REG_17:\n\tcase WSA881X_OTP_REG_18:\n\tcase WSA881X_OTP_REG_19:\n\tcase WSA881X_OTP_REG_20:\n\tcase WSA881X_OTP_REG_21:\n\tcase WSA881X_OTP_REG_22:\n\tcase WSA881X_OTP_REG_23:\n\tcase WSA881X_OTP_REG_24:\n\tcase WSA881X_OTP_REG_25:\n\tcase WSA881X_OTP_REG_26:\n\tcase WSA881X_OTP_REG_27:\n\tcase WSA881X_OTP_REG_28:\n\tcase WSA881X_OTP_REG_29:\n\tcase WSA881X_OTP_REG_30:\n\tcase WSA881X_OTP_REG_31:\n\tcase WSA881X_OTP_REG_63:\n\tcase WSA881X_BIAS_REF_CTRL:\n\tcase WSA881X_BIAS_TEST:\n\tcase WSA881X_BIAS_BIAS:\n\tcase WSA881X_TEMP_OP:\n\tcase WSA881X_TEMP_IREF_CTRL:\n\tcase WSA881X_TEMP_ISENS_CTRL:\n\tcase WSA881X_TEMP_CLK_CTRL:\n\tcase WSA881X_TEMP_TEST:\n\tcase WSA881X_TEMP_BIAS:\n\tcase WSA881X_TEMP_ADC_CTRL:\n\tcase WSA881X_TEMP_DOUT_MSB:\n\tcase WSA881X_TEMP_DOUT_LSB:\n\tcase WSA881X_ADC_EN_MODU_V:\n\tcase WSA881X_ADC_EN_MODU_I:\n\tcase WSA881X_ADC_EN_DET_TEST_V:\n\tcase WSA881X_ADC_EN_DET_TEST_I:\n\tcase WSA881X_ADC_SEL_IBIAS:\n\tcase WSA881X_ADC_EN_SEL_IBAIS:\n\tcase WSA881X_SPKR_DRV_EN:\n\tcase WSA881X_SPKR_DRV_GAIN:\n\tcase WSA881X_SPKR_DAC_CTL:\n\tcase WSA881X_SPKR_DRV_DBG:\n\tcase WSA881X_SPKR_PWRSTG_DBG:\n\tcase WSA881X_SPKR_OCP_CTL:\n\tcase WSA881X_SPKR_CLIP_CTL:\n\tcase WSA881X_SPKR_BBM_CTL:\n\tcase WSA881X_SPKR_MISC_CTL1:\n\tcase WSA881X_SPKR_MISC_CTL2:\n\tcase WSA881X_SPKR_BIAS_INT:\n\tcase WSA881X_SPKR_PA_INT:\n\tcase WSA881X_SPKR_BIAS_CAL:\n\tcase WSA881X_SPKR_BIAS_PSRR:\n\tcase WSA881X_SPKR_STATUS1:\n\tcase WSA881X_SPKR_STATUS2:\n\tcase WSA881X_BOOST_EN_CTL:\n\tcase WSA881X_BOOST_CURRENT_LIMIT:\n\tcase WSA881X_BOOST_PS_CTL:\n\tcase WSA881X_BOOST_PRESET_OUT1:\n\tcase WSA881X_BOOST_PRESET_OUT2:\n\tcase WSA881X_BOOST_FORCE_OUT:\n\tcase WSA881X_BOOST_LDO_PROG:\n\tcase WSA881X_BOOST_SLOPE_COMP_ISENSE_FB:\n\tcase WSA881X_BOOST_RON_CTL:\n\tcase WSA881X_BOOST_LOOP_STABILITY:\n\tcase WSA881X_BOOST_ZX_CTL:\n\tcase WSA881X_BOOST_START_CTL:\n\tcase WSA881X_BOOST_MISC1_CTL:\n\tcase WSA881X_BOOST_MISC2_CTL:\n\tcase WSA881X_BOOST_MISC3_CTL:\n\tcase WSA881X_BOOST_ATEST_CTL:\n\tcase WSA881X_SPKR_PROT_FE_GAIN:\n\tcase WSA881X_SPKR_PROT_FE_CM_LDO_SET:\n\tcase WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET1:\n\tcase WSA881X_SPKR_PROT_FE_ISENSE_BIAS_SET2:\n\tcase WSA881X_SPKR_PROT_ATEST1:\n\tcase WSA881X_SPKR_PROT_ATEST2:\n\tcase WSA881X_SPKR_PROT_FE_VSENSE_VCM:\n\tcase WSA881X_SPKR_PROT_FE_VSENSE_BIAS_SET1:\n\tcase WSA881X_BONGO_RESRV_REG1:\n\tcase WSA881X_BONGO_RESRV_REG2:\n\tcase WSA881X_SPKR_PROT_SAR:\n\tcase WSA881X_SPKR_STATUS3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wsa881x_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WSA881X_CHIP_ID0:\n\tcase WSA881X_CHIP_ID1:\n\tcase WSA881X_CHIP_ID2:\n\tcase WSA881X_CHIP_ID3:\n\tcase WSA881X_BUS_ID:\n\tcase WSA881X_TEMP_MSB:\n\tcase WSA881X_TEMP_LSB:\n\tcase WSA881X_SDM_PDM9_LSB:\n\tcase WSA881X_SDM_PDM9_MSB:\n\tcase WSA881X_OTP_CTRL1:\n\tcase WSA881X_INTR_STATUS:\n\tcase WSA881X_ATE_TEST_MODE:\n\tcase WSA881X_PIN_STATUS:\n\tcase WSA881X_SWR_HM_TEST2:\n\tcase WSA881X_SPKR_STATUS1:\n\tcase WSA881X_SPKR_STATUS2:\n\tcase WSA881X_SPKR_STATUS3:\n\tcase WSA881X_OTP_REG_0:\n\tcase WSA881X_OTP_REG_1:\n\tcase WSA881X_OTP_REG_2:\n\tcase WSA881X_OTP_REG_3:\n\tcase WSA881X_OTP_REG_4:\n\tcase WSA881X_OTP_REG_5:\n\tcase WSA881X_OTP_REG_31:\n\tcase WSA881X_TEMP_DOUT_MSB:\n\tcase WSA881X_TEMP_DOUT_LSB:\n\tcase WSA881X_TEMP_OP:\n\tcase WSA881X_SPKR_PROT_SAR:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct regmap_config wsa881x_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wsa881x_defaults,\n\t.max_register = WSA881X_SPKR_STATUS3,\n\t.num_reg_defaults = ARRAY_SIZE(wsa881x_defaults),\n\t.volatile_reg = wsa881x_volatile_register,\n\t.readable_reg = wsa881x_readable_register,\n\t.reg_format_endian = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian = REGMAP_ENDIAN_NATIVE,\n};\n\nenum {\n\tG_18DB = 0,\n\tG_16P5DB,\n\tG_15DB,\n\tG_13P5DB,\n\tG_12DB,\n\tG_10P5DB,\n\tG_9DB,\n\tG_7P5DB,\n\tG_6DB,\n\tG_4P5DB,\n\tG_3DB,\n\tG_1P5DB,\n\tG_0DB,\n};\n\n \nstruct wsa881x_priv {\n\tstruct regmap *regmap;\n\tstruct device *dev;\n\tstruct sdw_slave *slave;\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_stream_runtime *sruntime;\n\tstruct sdw_port_config port_config[WSA881X_MAX_SWR_PORTS];\n\tstruct gpio_desc *sd_n;\n\t \n\tunsigned int sd_n_val;\n\tint version;\n\tint active_ports;\n\tbool port_prepared[WSA881X_MAX_SWR_PORTS];\n\tbool port_enable[WSA881X_MAX_SWR_PORTS];\n};\n\nstatic void wsa881x_init(struct wsa881x_priv *wsa881x)\n{\n\tstruct regmap *rm = wsa881x->regmap;\n\tunsigned int val = 0;\n\n\tregmap_read(rm, WSA881X_CHIP_ID1, &wsa881x->version);\n\tregmap_register_patch(wsa881x->regmap, wsa881x_rev_2_0,\n\t\t\t      ARRAY_SIZE(wsa881x_rev_2_0));\n\n\t \n\tregmap_update_bits(rm, WSA881X_SWR_RESET_EN, 0x07, 0x07);\n\n\t \n\tregmap_update_bits(rm, WSA881X_CDC_RST_CTL, 0x02, 0x02);\n\n\t \n\tregmap_update_bits(rm, WSA881X_CDC_RST_CTL, 0x01, 0x01);\n\tregmap_update_bits(rm, WSA881X_CLOCK_CONFIG, 0x10, 0x10);\n\tregmap_update_bits(rm, WSA881X_SPKR_OCP_CTL, 0x02, 0x02);\n\tregmap_update_bits(rm, WSA881X_SPKR_MISC_CTL1, 0xC0, 0x80);\n\tregmap_update_bits(rm, WSA881X_SPKR_MISC_CTL1, 0x06, 0x06);\n\tregmap_update_bits(rm, WSA881X_SPKR_BIAS_INT, 0xFF, 0x00);\n\tregmap_update_bits(rm, WSA881X_SPKR_PA_INT, 0xF0, 0x40);\n\tregmap_update_bits(rm, WSA881X_SPKR_PA_INT, 0x0E, 0x0E);\n\tregmap_update_bits(rm, WSA881X_BOOST_LOOP_STABILITY, 0x03, 0x03);\n\tregmap_update_bits(rm, WSA881X_BOOST_MISC2_CTL, 0xFF, 0x14);\n\tregmap_update_bits(rm, WSA881X_BOOST_START_CTL, 0x80, 0x80);\n\tregmap_update_bits(rm, WSA881X_BOOST_START_CTL, 0x03, 0x00);\n\tregmap_update_bits(rm, WSA881X_BOOST_SLOPE_COMP_ISENSE_FB, 0x0C, 0x04);\n\tregmap_update_bits(rm, WSA881X_BOOST_SLOPE_COMP_ISENSE_FB, 0x03, 0x00);\n\n\tregmap_read(rm, WSA881X_OTP_REG_0, &val);\n\tif (val)\n\t\tregmap_update_bits(rm, WSA881X_BOOST_PRESET_OUT1, 0xF0, 0x70);\n\n\tregmap_update_bits(rm, WSA881X_BOOST_PRESET_OUT2, 0xF0, 0x30);\n\tregmap_update_bits(rm, WSA881X_SPKR_DRV_EN, 0x08, 0x08);\n\tregmap_update_bits(rm, WSA881X_BOOST_CURRENT_LIMIT, 0x0F, 0x08);\n\tregmap_update_bits(rm, WSA881X_SPKR_OCP_CTL, 0x30, 0x30);\n\tregmap_update_bits(rm, WSA881X_SPKR_OCP_CTL, 0x0C, 0x00);\n\tregmap_update_bits(rm, WSA881X_OTP_REG_28, 0x3F, 0x3A);\n\tregmap_update_bits(rm, WSA881X_BONGO_RESRV_REG1, 0xFF, 0xB2);\n\tregmap_update_bits(rm, WSA881X_BONGO_RESRV_REG2, 0xFF, 0x05);\n}\n\nstatic int wsa881x_component_probe(struct snd_soc_component *comp)\n{\n\tstruct wsa881x_priv *wsa881x = snd_soc_component_get_drvdata(comp);\n\n\tsnd_soc_component_init_regmap(comp, wsa881x->regmap);\n\n\treturn 0;\n}\n\nstatic int wsa881x_put_pa_gain(struct snd_kcontrol *kc,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kc);\n\tstruct soc_mixer_control *mc =\n\t\t\t(struct soc_mixer_control *)kc->private_value;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tint val, ret, min_gain, max_gain;\n\n\tret = pm_runtime_resume_and_get(comp->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\tmax_gain = (max - ucontrol->value.integer.value[0]) & mask;\n\t \n\tif (max_gain > G_4P5DB)\n\t\tmin_gain = G_0DB;\n\telse\n\t\tmin_gain = max_gain + 3;\n\t \n\tusleep_range(1000, 1010);\n\n\tfor (val = min_gain; max_gain <= val; val--) {\n\t\tret = snd_soc_component_update_bits(comp,\n\t\t\t      WSA881X_SPKR_DRV_GAIN,\n\t\t\t      WSA881X_SPKR_PAG_GAIN_MASK,\n\t\t\t      val << 4);\n\t\tif (ret < 0)\n\t\t\tdev_err(comp->dev, \"Failed to change PA gain\");\n\n\t\tusleep_range(1000, 1010);\n\t}\n\n\tpm_runtime_mark_last_busy(comp->dev);\n\tpm_runtime_put_autosuspend(comp->dev);\n\n\treturn 1;\n}\n\nstatic int wsa881x_get_port(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct wsa881x_priv *data = snd_soc_component_get_drvdata(comp);\n\tstruct soc_mixer_control *mixer =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint portidx = mixer->reg;\n\n\tucontrol->value.integer.value[0] = data->port_enable[portidx];\n\n\n\treturn 0;\n}\n\nstatic int wsa881x_boost_ctrl(struct snd_soc_component *comp, bool enable)\n{\n\tif (enable)\n\t\tsnd_soc_component_update_bits(comp, WSA881X_BOOST_EN_CTL,\n\t\t\t\t\t      WSA881X_BOOST_EN_MASK,\n\t\t\t\t\t      WSA881X_BOOST_EN);\n\telse\n\t\tsnd_soc_component_update_bits(comp, WSA881X_BOOST_EN_CTL,\n\t\t\t\t\t      WSA881X_BOOST_EN_MASK, 0);\n\t \n\tusleep_range(1500, 1510);\n\treturn 0;\n}\n\nstatic int wsa881x_set_port(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *comp = snd_soc_kcontrol_component(kcontrol);\n\tstruct wsa881x_priv *data = snd_soc_component_get_drvdata(comp);\n\tstruct soc_mixer_control *mixer =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint portidx = mixer->reg;\n\n\tif (ucontrol->value.integer.value[0]) {\n\t\tif (data->port_enable[portidx])\n\t\t\treturn 0;\n\n\t\tdata->port_enable[portidx] = true;\n\t} else {\n\t\tif (!data->port_enable[portidx])\n\t\t\treturn 0;\n\n\t\tdata->port_enable[portidx] = false;\n\t}\n\n\tif (portidx == WSA881X_PORT_BOOST)  \n\t\twsa881x_boost_ctrl(comp, data->port_enable[portidx]);\n\n\treturn 1;\n}\n\nstatic const char * const smart_boost_lvl_text[] = {\n\t\"6.625 V\", \"6.750 V\", \"6.875 V\", \"7.000 V\",\n\t\"7.125 V\", \"7.250 V\", \"7.375 V\", \"7.500 V\",\n\t\"7.625 V\", \"7.750 V\", \"7.875 V\", \"8.000 V\",\n\t\"8.125 V\", \"8.250 V\", \"8.375 V\", \"8.500 V\"\n};\n\nstatic const struct soc_enum smart_boost_lvl_enum =\n\tSOC_ENUM_SINGLE(WSA881X_BOOST_PRESET_OUT1, 0,\n\t\t\tARRAY_SIZE(smart_boost_lvl_text),\n\t\t\tsmart_boost_lvl_text);\n\nstatic const DECLARE_TLV_DB_SCALE(pa_gain, 0, 150, 0);\n\nstatic const struct snd_kcontrol_new wsa881x_snd_controls[] = {\n\tSOC_ENUM(\"Smart Boost Level\", smart_boost_lvl_enum),\n\tWSA881X_PA_GAIN_TLV(\"PA Volume\", WSA881X_SPKR_DRV_GAIN,\n\t\t\t    4, 0xC, 1, pa_gain),\n\tSOC_SINGLE_EXT(\"DAC Switch\", WSA881X_PORT_DAC, 0, 1, 0,\n\t\t       wsa881x_get_port, wsa881x_set_port),\n\tSOC_SINGLE_EXT(\"COMP Switch\", WSA881X_PORT_COMP, 0, 1, 0,\n\t\t       wsa881x_get_port, wsa881x_set_port),\n\tSOC_SINGLE_EXT(\"BOOST Switch\", WSA881X_PORT_BOOST, 0, 1, 0,\n\t\t       wsa881x_get_port, wsa881x_set_port),\n\tSOC_SINGLE_EXT(\"VISENSE Switch\", WSA881X_PORT_VISENSE, 0, 1, 0,\n\t\t       wsa881x_get_port, wsa881x_set_port),\n};\n\nstatic const struct snd_soc_dapm_route wsa881x_audio_map[] = {\n\t{ \"RDAC\", NULL, \"IN\" },\n\t{ \"RDAC\", NULL, \"DCLK\" },\n\t{ \"RDAC\", NULL, \"ACLK\" },\n\t{ \"RDAC\", NULL, \"Bandgap\" },\n\t{ \"SPKR PGA\", NULL, \"RDAC\" },\n\t{ \"SPKR\", NULL, \"SPKR PGA\" },\n};\n\nstatic int wsa881x_visense_txfe_ctrl(struct snd_soc_component *comp,\n\t\t\t\t     bool enable)\n{\n\tstruct wsa881x_priv *wsa881x = snd_soc_component_get_drvdata(comp);\n\n\tif (enable) {\n\t\tregmap_multi_reg_write(wsa881x->regmap, wsa881x_vi_txfe_en_2_0,\n\t\t\t\t       ARRAY_SIZE(wsa881x_vi_txfe_en_2_0));\n\t} else {\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t      WSA881X_SPKR_PROT_FE_VSENSE_VCM,\n\t\t\t\t\t      0x08, 0x08);\n\t\t \n\t\tusleep_range(200, 210);\n\t\tsnd_soc_component_update_bits(comp, WSA881X_SPKR_PROT_FE_GAIN,\n\t\t\t\t\t      0x01, 0x00);\n\t}\n\treturn 0;\n}\n\nstatic int wsa881x_visense_adc_ctrl(struct snd_soc_component *comp,\n\t\t\t\t    bool enable)\n{\n\tsnd_soc_component_update_bits(comp, WSA881X_ADC_EN_MODU_V, BIT(7),\n\t\t\t\t      (enable << 7));\n\tsnd_soc_component_update_bits(comp, WSA881X_ADC_EN_MODU_I, BIT(7),\n\t\t\t\t      (enable << 7));\n\treturn 0;\n}\n\nstatic int wsa881x_spkr_pa_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tstruct wsa881x_priv *wsa881x = snd_soc_component_get_drvdata(comp);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(comp, WSA881X_SPKR_OCP_CTL,\n\t\t\t\t\t      WSA881X_SPKR_OCP_MASK,\n\t\t\t\t\t      WSA881X_SPKR_OCP_EN);\n\t\tregmap_multi_reg_write(wsa881x->regmap, wsa881x_pre_pmu_pa_2_0,\n\t\t\t\t       ARRAY_SIZE(wsa881x_pre_pmu_pa_2_0));\n\n\t\tsnd_soc_component_update_bits(comp, WSA881X_SPKR_DRV_GAIN,\n\t\t\t\t\t      WSA881X_PA_GAIN_SEL_MASK,\n\t\t\t\t\t      WSA881X_PA_GAIN_SEL_REG);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (wsa881x->port_prepared[WSA881X_PORT_VISENSE]) {\n\t\t\twsa881x_visense_txfe_ctrl(comp, true);\n\t\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\t\t\t      WSA881X_ADC_EN_SEL_IBAIS,\n\t\t\t\t\t\t      0x07, 0x01);\n\t\t\twsa881x_visense_adc_ctrl(comp, true);\n\t\t}\n\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (wsa881x->port_prepared[WSA881X_PORT_VISENSE]) {\n\t\t\twsa881x_visense_adc_ctrl(comp, false);\n\t\t\twsa881x_visense_txfe_ctrl(comp, false);\n\t\t}\n\n\t\tsnd_soc_component_update_bits(comp, WSA881X_SPKR_OCP_CTL,\n\t\t\t\t\t      WSA881X_SPKR_OCP_MASK,\n\t\t\t\t\t      WSA881X_SPKR_OCP_EN |\n\t\t\t\t\t      WSA881X_SPKR_OCP_HOLD);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget wsa881x_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"IN\"),\n\tSND_SOC_DAPM_DAC_E(\"RDAC\", NULL, WSA881X_SPKR_DAC_CTL, 7, 0,\n\t\t\t   NULL,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_E(\"SPKR PGA\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\t   wsa881x_spkr_pa_event, SND_SOC_DAPM_PRE_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"DCLK\", WSA881X_CDC_DIG_CLK_CTL, 0, 0, NULL,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"ACLK\", WSA881X_CDC_ANA_CLK_CTL, 0, 0, NULL,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"Bandgap\", WSA881X_TEMP_OP, 3, 0,\n\t\t\t    NULL,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n};\n\nstatic int wsa881x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dai->dev);\n\tint i;\n\n\twsa881x->active_ports = 0;\n\tfor (i = 0; i < WSA881X_MAX_SWR_PORTS; i++) {\n\t\tif (!wsa881x->port_enable[i])\n\t\t\tcontinue;\n\n\t\twsa881x->port_config[wsa881x->active_ports] =\n\t\t\t\t\t\t\twsa881x_pconfig[i];\n\t\twsa881x->active_ports++;\n\t}\n\n\treturn sdw_stream_add_slave(wsa881x->slave, &wsa881x->sconfig,\n\t\t\t\t    wsa881x->port_config, wsa881x->active_ports,\n\t\t\t\t    wsa881x->sruntime);\n}\n\nstatic int wsa881x_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dai->dev);\n\n\tsdw_stream_remove_slave(wsa881x->slave, wsa881x->sruntime);\n\n\treturn 0;\n}\n\nstatic int wsa881x_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t  void *stream, int direction)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dai->dev);\n\n\twsa881x->sruntime = stream;\n\n\treturn 0;\n}\n\nstatic int wsa881x_digital_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dai->dev);\n\n\tif (mute)\n\t\tregmap_update_bits(wsa881x->regmap, WSA881X_SPKR_DRV_EN, 0x80,\n\t\t\t\t   0x00);\n\telse\n\t\tregmap_update_bits(wsa881x->regmap, WSA881X_SPKR_DRV_EN, 0x80,\n\t\t\t\t   0x80);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wsa881x_dai_ops = {\n\t.hw_params = wsa881x_hw_params,\n\t.hw_free = wsa881x_hw_free,\n\t.mute_stream = wsa881x_digital_mute,\n\t.set_stream = wsa881x_set_sdw_stream,\n};\n\nstatic struct snd_soc_dai_driver wsa881x_dais[] = {\n\t{\n\t\t.name = \"SPKR\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"SPKR Playback\",\n\t\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t\t.rate_max = 48000,\n\t\t\t.rate_min = 48000,\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t},\n\t\t.ops = &wsa881x_dai_ops,\n\t},\n};\n\nstatic const struct snd_soc_component_driver wsa881x_component_drv = {\n\t.name = \"WSA881x\",\n\t.probe = wsa881x_component_probe,\n\t.controls = wsa881x_snd_controls,\n\t.num_controls = ARRAY_SIZE(wsa881x_snd_controls),\n\t.dapm_widgets = wsa881x_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(wsa881x_dapm_widgets),\n\t.dapm_routes = wsa881x_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(wsa881x_audio_map),\n\t.endianness = 1,\n};\n\nstatic int wsa881x_update_status(struct sdw_slave *slave,\n\t\t\t\t enum sdw_slave_status status)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_ATTACHED && slave->dev_num > 0)\n\t\twsa881x_init(wsa881x);\n\n\treturn 0;\n}\n\nstatic int wsa881x_port_prep(struct sdw_slave *slave,\n\t\t\t     struct sdw_prepare_ch *prepare_ch,\n\t\t\t     enum sdw_port_prep_ops state)\n{\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(&slave->dev);\n\n\tif (state == SDW_OPS_PORT_POST_PREP)\n\t\twsa881x->port_prepared[prepare_ch->num - 1] = true;\n\telse\n\t\twsa881x->port_prepared[prepare_ch->num - 1] = false;\n\n\treturn 0;\n}\n\nstatic int wsa881x_bus_config(struct sdw_slave *slave,\n\t\t\t      struct sdw_bus_params *params)\n{\n\tsdw_write(slave, SWRS_SCP_HOST_CLK_DIV2_CTL_BANK(params->next_bank),\n\t\t  0x01);\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops wsa881x_slave_ops = {\n\t.update_status = wsa881x_update_status,\n\t.bus_config = wsa881x_bus_config,\n\t.port_prep = wsa881x_port_prep,\n};\n\nstatic int wsa881x_probe(struct sdw_slave *pdev,\n\t\t\t const struct sdw_device_id *id)\n{\n\tstruct wsa881x_priv *wsa881x;\n\tstruct device *dev = &pdev->dev;\n\n\twsa881x = devm_kzalloc(dev, sizeof(*wsa881x), GFP_KERNEL);\n\tif (!wsa881x)\n\t\treturn -ENOMEM;\n\n\twsa881x->sd_n = devm_gpiod_get_optional(dev, \"powerdown\",\n\t\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(wsa881x->sd_n))\n\t\treturn dev_err_probe(dev, PTR_ERR(wsa881x->sd_n),\n\t\t\t\t     \"Shutdown Control GPIO not found\\n\");\n\n\t \n\twsa881x->sd_n_val = gpiod_is_active_low(wsa881x->sd_n);\n\tif (!wsa881x->sd_n_val)\n\t\tdev_warn(dev, \"Using ACTIVE_HIGH for shutdown GPIO. Your DTB might be outdated or you use unsupported configuration for the GPIO.\");\n\n\tdev_set_drvdata(dev, wsa881x);\n\twsa881x->slave = pdev;\n\twsa881x->dev = dev;\n\twsa881x->sconfig.ch_count = 1;\n\twsa881x->sconfig.bps = 1;\n\twsa881x->sconfig.frame_rate = 48000;\n\twsa881x->sconfig.direction = SDW_DATA_DIR_RX;\n\twsa881x->sconfig.type = SDW_STREAM_PDM;\n\tpdev->prop.sink_ports = GENMASK(WSA881X_MAX_SWR_PORTS, 0);\n\tpdev->prop.sink_dpn_prop = wsa_sink_dpn_prop;\n\tpdev->prop.scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tgpiod_direction_output(wsa881x->sd_n, !wsa881x->sd_n_val);\n\n\twsa881x->regmap = devm_regmap_init_sdw(pdev, &wsa881x_regmap_config);\n\tif (IS_ERR(wsa881x->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(wsa881x->regmap), \"regmap_init failed\\n\");\n\n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t\t\t       &wsa881x_component_drv,\n\t\t\t\t\t       wsa881x_dais,\n\t\t\t\t\t       ARRAY_SIZE(wsa881x_dais));\n}\n\nstatic int __maybe_unused wsa881x_runtime_suspend(struct device *dev)\n{\n\tstruct regmap *regmap = dev_get_regmap(dev, NULL);\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dev);\n\n\tgpiod_direction_output(wsa881x->sd_n, wsa881x->sd_n_val);\n\n\tregcache_cache_only(regmap, true);\n\tregcache_mark_dirty(regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused wsa881x_runtime_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct regmap *regmap = dev_get_regmap(dev, NULL);\n\tstruct wsa881x_priv *wsa881x = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tgpiod_direction_output(wsa881x->sd_n, !wsa881x->sd_n_val);\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\t\t   msecs_to_jiffies(WSA881X_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(dev, \"Initialization not complete, timed out\\n\");\n\t\tgpiod_direction_output(wsa881x->sd_n, wsa881x->sd_n_val);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tregcache_cache_only(regmap, false);\n\tregcache_sync(regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wsa881x_pm_ops = {\n\tSET_RUNTIME_PM_OPS(wsa881x_runtime_suspend, wsa881x_runtime_resume, NULL)\n};\n\nstatic const struct sdw_device_id wsa881x_slave_id[] = {\n\tSDW_SLAVE_ENTRY(0x0217, 0x2010, 0),\n\tSDW_SLAVE_ENTRY(0x0217, 0x2110, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, wsa881x_slave_id);\n\nstatic struct sdw_driver wsa881x_codec_driver = {\n\t.probe\t= wsa881x_probe,\n\t.ops = &wsa881x_slave_ops,\n\t.id_table = wsa881x_slave_id,\n\t.driver = {\n\t\t.name\t= \"wsa881x-codec\",\n\t\t.pm = &wsa881x_pm_ops,\n\t}\n};\nmodule_sdw_driver(wsa881x_codec_driver);\n\nMODULE_DESCRIPTION(\"WSA881x codec driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}