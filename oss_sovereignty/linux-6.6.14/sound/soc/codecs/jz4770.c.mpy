{
  "module_name": "jz4770.c",
  "hash_id": "d63d091398c69db4fe91bd9f7d6fb2e6baa9888e56f6f42487b71c30a7048afc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/jz4770.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/time64.h>\n\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#define ICDC_RGADW_OFFSET\t\t0x00\n#define ICDC_RGDATA_OFFSET\t\t0x04\n\n \n#define ICDC_RGADW_RGWR\t\t\tBIT(16)\n\n#define ICDC_RGADW_RGADDR_OFFSET\t8\n#define\tICDC_RGADW_RGADDR_MASK\t\tGENMASK(14, ICDC_RGADW_RGADDR_OFFSET)\n\n#define ICDC_RGADW_RGDIN_OFFSET\t\t0\n#define\tICDC_RGADW_RGDIN_MASK\t\tGENMASK(7, ICDC_RGADW_RGDIN_OFFSET)\n\n \n#define ICDC_RGDATA_IRQ\t\t\tBIT(8)\n\n#define ICDC_RGDATA_RGDOUT_OFFSET\t0\n#define ICDC_RGDATA_RGDOUT_MASK\t\tGENMASK(7, ICDC_RGDATA_RGDOUT_OFFSET)\n\n \nenum {\n\tJZ4770_CODEC_REG_SR,\n\tJZ4770_CODEC_REG_AICR_DAC,\n\tJZ4770_CODEC_REG_AICR_ADC,\n\tJZ4770_CODEC_REG_CR_LO,\n\tJZ4770_CODEC_REG_CR_HP,\n\n\tJZ4770_CODEC_REG_MISSING_REG1,\n\n\tJZ4770_CODEC_REG_CR_DAC,\n\tJZ4770_CODEC_REG_CR_MIC,\n\tJZ4770_CODEC_REG_CR_LI,\n\tJZ4770_CODEC_REG_CR_ADC,\n\tJZ4770_CODEC_REG_CR_MIX,\n\tJZ4770_CODEC_REG_CR_VIC,\n\tJZ4770_CODEC_REG_CCR,\n\tJZ4770_CODEC_REG_FCR_DAC,\n\tJZ4770_CODEC_REG_FCR_ADC,\n\tJZ4770_CODEC_REG_ICR,\n\tJZ4770_CODEC_REG_IMR,\n\tJZ4770_CODEC_REG_IFR,\n\tJZ4770_CODEC_REG_GCR_HPL,\n\tJZ4770_CODEC_REG_GCR_HPR,\n\tJZ4770_CODEC_REG_GCR_LIBYL,\n\tJZ4770_CODEC_REG_GCR_LIBYR,\n\tJZ4770_CODEC_REG_GCR_DACL,\n\tJZ4770_CODEC_REG_GCR_DACR,\n\tJZ4770_CODEC_REG_GCR_MIC1,\n\tJZ4770_CODEC_REG_GCR_MIC2,\n\tJZ4770_CODEC_REG_GCR_ADCL,\n\tJZ4770_CODEC_REG_GCR_ADCR,\n\n\tJZ4770_CODEC_REG_MISSING_REG2,\n\n\tJZ4770_CODEC_REG_GCR_MIXADC,\n\tJZ4770_CODEC_REG_GCR_MIXDAC,\n\tJZ4770_CODEC_REG_AGC1,\n\tJZ4770_CODEC_REG_AGC2,\n\tJZ4770_CODEC_REG_AGC3,\n\tJZ4770_CODEC_REG_AGC4,\n\tJZ4770_CODEC_REG_AGC5,\n};\n\n#define REG_AICR_DAC_ADWL_OFFSET\t6\n#define REG_AICR_DAC_ADWL_MASK\t\t(0x3 << REG_AICR_DAC_ADWL_OFFSET)\n#define REG_AICR_DAC_SERIAL\t\tBIT(1)\n#define REG_AICR_DAC_I2S\t\tBIT(0)\n\n#define REG_AICR_ADC_ADWL_OFFSET\t6\n#define REG_AICR_ADC_ADWL_MASK\t\t(0x3 << REG_AICR_ADC_ADWL_OFFSET)\n#define REG_AICR_ADC_SERIAL\t\tBIT(1)\n#define REG_AICR_ADC_I2S\t\tBIT(0)\n\n#define REG_CR_LO_MUTE_OFFSET\t\t7\n#define REG_CR_LO_SB_OFFSET\t\t4\n#define REG_CR_LO_SEL_OFFSET\t\t0\n#define REG_CR_LO_SEL_MASK\t\t(0x3 << REG_CR_LO_SEL_OFFSET)\n\n#define REG_CR_HP_MUTE\t\t\tBIT(7)\n#define REG_CR_HP_LOAD\t\t\tBIT(6)\n#define REG_CR_HP_SB_OFFSET\t\t4\n#define REG_CR_HP_SB_HPCM_OFFSET\t3\n#define REG_CR_HP_SEL_OFFSET\t\t0\n#define REG_CR_HP_SEL_MASK\t\t(0x3 << REG_CR_HP_SEL_OFFSET)\n\n#define REG_CR_DAC_MUTE\t\t\tBIT(7)\n#define REG_CR_DAC_MONO\t\t\tBIT(6)\n#define REG_CR_DAC_LEFT_ONLY\t\tBIT(5)\n#define REG_CR_DAC_SB_OFFSET\t\t4\n#define REG_CR_DAC_LRSWAP\t\tBIT(3)\n\n#define REG_CR_MIC_STEREO_OFFSET\t7\n#define REG_CR_MIC_IDIFF_OFFSET\t\t6\n#define REG_CR_MIC_SB_MIC2_OFFSET\t5\n#define REG_CR_MIC_SB_MIC1_OFFSET\t4\n#define REG_CR_MIC_BIAS_V0_OFFSET\t1\n#define REG_CR_MIC_BIAS_SB_OFFSET\t0\n\n#define REG_CR_LI_LIBY_OFFSET\t\t4\n#define REG_CR_LI_SB_OFFSET\t\t0\n\n#define REG_CR_ADC_DMIC_SEL\t\tBIT(7)\n#define REG_CR_ADC_MONO\t\t\tBIT(6)\n#define REG_CR_ADC_LEFT_ONLY\t\tBIT(5)\n#define REG_CR_ADC_SB_OFFSET\t\t4\n#define REG_CR_ADC_LRSWAP\t\tBIT(3)\n#define REG_CR_ADC_IN_SEL_OFFSET\t0\n#define REG_CR_ADC_IN_SEL_MASK\t\t(0x3 << REG_CR_ADC_IN_SEL_OFFSET)\n\n#define REG_CR_VIC_SB_SLEEP\t\tBIT(1)\n#define REG_CR_VIC_SB\t\t\tBIT(0)\n\n#define REG_CCR_CRYSTAL_OFFSET\t\t0\n#define REG_CCR_CRYSTAL_MASK\t\t(0xf << REG_CCR_CRYSTAL_OFFSET)\n\n#define REG_FCR_DAC_FREQ_OFFSET\t\t0\n#define REG_FCR_DAC_FREQ_MASK\t\t(0xf << REG_FCR_DAC_FREQ_OFFSET)\n\n#define REG_FCR_ADC_FREQ_OFFSET\t\t0\n#define REG_FCR_ADC_FREQ_MASK\t\t(0xf << REG_FCR_ADC_FREQ_OFFSET)\n\n#define REG_ICR_INT_FORM_OFFSET\t\t6\n#define REG_ICR_INT_FORM_MASK\t\t(0x3 << REG_ICR_INT_FORM_OFFSET)\n\n#define REG_IMR_ALL_MASK\t\t(0x7f)\n#define REG_IMR_SCLR_MASK\t\tBIT(6)\n#define REG_IMR_JACK_MASK\t\tBIT(5)\n#define REG_IMR_SCMC_MASK\t\tBIT(4)\n#define REG_IMR_RUP_MASK\t\tBIT(3)\n#define REG_IMR_RDO_MASK\t\tBIT(2)\n#define REG_IMR_GUP_MASK\t\tBIT(1)\n#define REG_IMR_GDO_MASK\t\tBIT(0)\n\n#define REG_IFR_ALL_MASK\t\t(0x7f)\n#define REG_IFR_SCLR\t\t\tBIT(6)\n#define REG_IFR_JACK\t\t\tBIT(5)\n#define REG_IFR_SCMC\t\t\tBIT(4)\n#define REG_IFR_RUP\t\t\tBIT(3)\n#define REG_IFR_RDO\t\t\tBIT(2)\n#define REG_IFR_GUP\t\t\tBIT(1)\n#define REG_IFR_GDO\t\t\tBIT(0)\n\n#define REG_GCR_HPL_LRGO\t\tBIT(7)\n\n#define REG_GCR_DACL_RLGOD\t\tBIT(7)\n\n#define REG_GCR_GAIN_OFFSET\t\t0\n#define REG_GCR_GAIN_MAX\t\t0x1f\n\n#define REG_GCR_MIC_GAIN_OFFSET\t\t0\n#define REG_GCR_MIC_GAIN_MAX\t\t5\n\n#define REG_GCR_ADC_GAIN_OFFSET\t\t0\n#define REG_GCR_ADC_GAIN_MAX\t\t23\n\n#define REG_AGC1_EN\t\t\tBIT(7)\n\n \nstruct jz_codec {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic int jz4770_codec_set_bias_level(struct snd_soc_component *codec,\n\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tstruct regmap *regmap = jz_codec->regmap;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tregmap_write(regmap, JZ4770_CODEC_REG_IFR, REG_IFR_ALL_MASK);\n\n\t\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_VIC,\n\t\t\t\t  REG_CR_VIC_SB);\n\t\tmsleep(250);\n\t\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_VIC,\n\t\t\t\t  REG_CR_VIC_SB_SLEEP);\n\t\tmsleep(400);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_VIC,\n\t\t\t\tREG_CR_VIC_SB_SLEEP);\n\t\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_VIC,\n\t\t\t\tREG_CR_VIC_SB);\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4770_codec_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(codec);\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_soc_dapm_force_enable_pin(dapm, \"SYSCLK\");\n\n\treturn 0;\n}\n\nstatic void jz4770_codec_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(codec);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_soc_dapm_disable_pin(dapm, \"SYSCLK\");\n}\n\n\nstatic int jz4770_codec_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsnd_soc_component_force_bias_level(codec,\n\t\t\t\t\t\t\t   SND_SOC_BIAS_ON);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int jz4770_codec_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tunsigned int gain_bit = mute ? REG_IFR_GDO : REG_IFR_GUP;\n\tunsigned int val;\n\tint change, err;\n\n\tchange = snd_soc_component_update_bits(codec, JZ4770_CODEC_REG_CR_DAC,\n\t\t\t\t\t       REG_CR_DAC_MUTE,\n\t\t\t\t\t       mute ? REG_CR_DAC_MUTE : 0);\n\tif (change == 1) {\n\t\tregmap_read(jz_codec->regmap, JZ4770_CODEC_REG_CR_DAC, &val);\n\n\t\tif (val & BIT(REG_CR_DAC_SB_OFFSET))\n\t\t\treturn 1;\n\n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4770_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & gain_bit,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev,\n\t\t\t\t\"Timeout while setting digital mute: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4770_CODEC_REG_IFR,\n\t\t\t\tgain_bit);\n\t}\n\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_MINMAX_MUTE(dac_tlv, -3100, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_MINMAX(out_tlv, -2500, 600);\nstatic const DECLARE_TLV_DB_SCALE(linein_tlv, -2500, 100, 0);\nstatic const DECLARE_TLV_DB_MINMAX(mixer_tlv, -3100, 0);\n\n \nstatic const struct snd_kcontrol_new jz4770_codec_snd_controls[] = {\n\t \n\tSOC_DOUBLE_R_TLV(\"PCM Capture Volume\",\n\t\t\t JZ4770_CODEC_REG_GCR_ADCL, JZ4770_CODEC_REG_GCR_ADCR,\n\t\t\t REG_GCR_ADC_GAIN_OFFSET, REG_GCR_ADC_GAIN_MAX,\n\t\t\t 0, adc_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Line In Bypass Playback Volume\",\n\t\t\t JZ4770_CODEC_REG_GCR_LIBYL, JZ4770_CODEC_REG_GCR_LIBYR,\n\t\t\t REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, linein_tlv),\n\n\tSOC_SINGLE_TLV(\"Mixer Capture Volume\",\n\t\t       JZ4770_CODEC_REG_GCR_MIXADC,\n\t\t       REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, mixer_tlv),\n\n\tSOC_SINGLE_TLV(\"Mixer Playback Volume\",\n\t\t       JZ4770_CODEC_REG_GCR_MIXDAC,\n\t\t       REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, mixer_tlv),\n};\n\nstatic const struct snd_kcontrol_new jz4770_codec_pcm_playback_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Volume\",\n\t\t.info = snd_soc_info_volsw,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ\n\t\t\t| SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.tlv.p = dac_tlv,\n\t\t.get = snd_soc_dapm_get_volsw,\n\t\t.put = snd_soc_dapm_put_volsw,\n\t\t \n\t\t.private_value = SOC_DOUBLE_R_VALUE(JZ4770_CODEC_REG_GCR_DACR,\n\t\t\t\t\t\t    JZ4770_CODEC_REG_GCR_DACL,\n\t\t\t\t\t\t    REG_GCR_GAIN_OFFSET,\n\t\t\t\t\t\t    REG_GCR_GAIN_MAX, 1),\n\t},\n};\n\nstatic const struct snd_kcontrol_new jz4770_codec_hp_playback_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Volume\",\n\t\t.info = snd_soc_info_volsw,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ\n\t\t\t| SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.tlv.p = out_tlv,\n\t\t.get = snd_soc_dapm_get_volsw,\n\t\t.put = snd_soc_dapm_put_volsw,\n\t\t \n\t\t.private_value = SOC_DOUBLE_R_VALUE(JZ4770_CODEC_REG_GCR_HPR,\n\t\t\t\t\t\t    JZ4770_CODEC_REG_GCR_HPL,\n\t\t\t\t\t\t    REG_GCR_GAIN_OFFSET,\n\t\t\t\t\t\t    REG_GCR_GAIN_MAX, 1),\n\t},\n};\n\nstatic int hpout_event(struct snd_soc_dapm_widget *w,\n\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tunsigned int val;\n\tint err;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tregmap_clear_bits(jz_codec->regmap, JZ4770_CODEC_REG_CR_HP,\n\t\t\t\t  REG_CR_HP_MUTE);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4770_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & REG_IFR_RUP,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev, \"RUP timeout: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4770_CODEC_REG_IFR,\n\t\t\t\tREG_IFR_RUP);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4770_CODEC_REG_CR_HP,\n\t\t\t\tREG_CR_HP_MUTE);\n\n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4770_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & REG_IFR_RDO,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev, \"RDO timeout: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4770_CODEC_REG_IFR,\n\t\t\t\tREG_IFR_RDO);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int adc_poweron_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tif (event == SND_SOC_DAPM_POST_PMU)\n\t\tmsleep(1000);\n\n\treturn 0;\n}\n\nstatic const char * const jz4770_codec_hp_texts[] = {\n\t\"PCM\", \"Line In\", \"Mic 1\", \"Mic 2\"\n};\nstatic const unsigned int jz4770_codec_hp_values[] = { 3, 2, 0, 1 };\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4770_codec_hp_enum,\n\t\t\t\t  JZ4770_CODEC_REG_CR_HP,\n\t\t\t\t  REG_CR_HP_SEL_OFFSET,\n\t\t\t\t  REG_CR_HP_SEL_MASK,\n\t\t\t\t  jz4770_codec_hp_texts,\n\t\t\t\t  jz4770_codec_hp_values);\nstatic const struct snd_kcontrol_new jz4770_codec_hp_source =\n\t\t\tSOC_DAPM_ENUM(\"Route\", jz4770_codec_hp_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4770_codec_lo_enum,\n\t\t\t\t  JZ4770_CODEC_REG_CR_LO,\n\t\t\t\t  REG_CR_LO_SEL_OFFSET,\n\t\t\t\t  REG_CR_LO_SEL_MASK,\n\t\t\t\t  jz4770_codec_hp_texts,\n\t\t\t\t  jz4770_codec_hp_values);\nstatic const struct snd_kcontrol_new jz4770_codec_lo_source =\n\t\t\tSOC_DAPM_ENUM(\"Route\", jz4770_codec_lo_enum);\n\nstatic const char * const jz4770_codec_cap_texts[] = {\n\t\"Line In\", \"Mic 1\", \"Mic 2\"\n};\nstatic const unsigned int jz4770_codec_cap_values[] = { 2, 0, 1 };\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4770_codec_cap_enum,\n\t\t\t\t  JZ4770_CODEC_REG_CR_ADC,\n\t\t\t\t  REG_CR_ADC_IN_SEL_OFFSET,\n\t\t\t\t  REG_CR_ADC_IN_SEL_MASK,\n\t\t\t\t  jz4770_codec_cap_texts,\n\t\t\t\t  jz4770_codec_cap_values);\nstatic const struct snd_kcontrol_new jz4770_codec_cap_source =\n\t\t\tSOC_DAPM_ENUM(\"Route\", jz4770_codec_cap_enum);\n\nstatic const struct snd_kcontrol_new jz4770_codec_mic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Stereo Capture Switch\", JZ4770_CODEC_REG_CR_MIC,\n\t\t\tREG_CR_MIC_STEREO_OFFSET, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget jz4770_codec_dapm_widgets[] = {\n\tSND_SOC_DAPM_PGA_E(\"HP Out\", JZ4770_CODEC_REG_CR_HP,\n\t\t\t   REG_CR_HP_SB_OFFSET, 1, NULL, 0, hpout_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA(\"Line Out\", JZ4770_CODEC_REG_CR_LO,\n\t\t\t REG_CR_LO_SB_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Line Out Switch 2\", JZ4770_CODEC_REG_CR_LO,\n\t\t\t REG_CR_LO_MUTE_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Line In\", JZ4770_CODEC_REG_CR_LI,\n\t\t\t REG_CR_LI_SB_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Headphones Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4770_codec_hp_source),\n\tSND_SOC_DAPM_MUX(\"Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4770_codec_cap_source),\n\tSND_SOC_DAPM_MUX(\"Line Out Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4770_codec_lo_source),\n\n\tSND_SOC_DAPM_PGA(\"Mic 1\", JZ4770_CODEC_REG_CR_MIC,\n\t\t\t REG_CR_MIC_SB_MIC1_OFFSET, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mic 2\", JZ4770_CODEC_REG_CR_MIC,\n\t\t\t REG_CR_MIC_SB_MIC2_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Mic Diff\", JZ4770_CODEC_REG_CR_MIC,\n\t\t\t REG_CR_MIC_IDIFF_OFFSET, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Mic\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4770_codec_mic_controls,\n\t\t\t   ARRAY_SIZE(jz4770_codec_mic_controls)),\n\n\tSND_SOC_DAPM_PGA(\"Line In Bypass\", JZ4770_CODEC_REG_CR_LI,\n\t\t\t REG_CR_LI_LIBY_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_ADC_E(\"ADC\", \"HiFi Capture\", JZ4770_CODEC_REG_CR_ADC,\n\t\t\t   REG_CR_ADC_SB_OFFSET, 1, adc_poweron_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"HiFi Playback\", JZ4770_CODEC_REG_CR_DAC,\n\t\t\t REG_CR_DAC_SB_OFFSET, 1),\n\n\tSND_SOC_DAPM_MIXER(\"PCM Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4770_codec_pcm_playback_controls,\n\t\t\t   ARRAY_SIZE(jz4770_codec_pcm_playback_controls)),\n\tSND_SOC_DAPM_MIXER(\"Headphones Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4770_codec_hp_playback_controls,\n\t\t\t   ARRAY_SIZE(jz4770_codec_hp_playback_controls)),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", JZ4770_CODEC_REG_CR_MIC,\n\t\t\t    REG_CR_MIC_BIAS_SB_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Cap-less\", JZ4770_CODEC_REG_CR_HP,\n\t\t\t    REG_CR_HP_SB_HPCM_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MIC1P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1N\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2N\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\n\n\tSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n\tSND_SOC_DAPM_INPUT(\"RLINEIN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"SYSCLK\"),\n};\n\n \nstatic const struct snd_soc_dapm_route jz4770_codec_dapm_routes[] = {\n\t{ \"Mic 1\", NULL, \"MIC1P\" },\n\t{ \"Mic Diff\", NULL, \"MIC1N\" },\n\t{ \"Mic 1\", NULL, \"Mic Diff\" },\n\t{ \"Mic 2\", NULL, \"MIC2P\" },\n\t{ \"Mic Diff\", NULL, \"MIC2N\" },\n\t{ \"Mic 2\", NULL, \"Mic Diff\" },\n\n\t{ \"Line In\", NULL, \"LLINEIN\" },\n\t{ \"Line In\", NULL, \"RLINEIN\" },\n\n\t{ \"Mic\", \"Stereo Capture Switch\", \"Mic 1\" },\n\t{ \"Mic\", \"Stereo Capture Switch\", \"Mic 2\" },\n\t{ \"Headphones Source\", \"Mic 1\", \"Mic\" },\n\t{ \"Headphones Source\", \"Mic 2\", \"Mic\" },\n\t{ \"Capture Source\", \"Mic 1\", \"Mic\" },\n\t{ \"Capture Source\", \"Mic 2\", \"Mic\" },\n\n\t{ \"Headphones Source\", \"Mic 1\", \"Mic 1\" },\n\t{ \"Headphones Source\", \"Mic 2\", \"Mic 2\" },\n\t{ \"Headphones Source\", \"Line In\", \"Line In Bypass\" },\n\t{ \"Headphones Source\", \"PCM\", \"Headphones Playback\" },\n\t{ \"HP Out\", NULL, \"Headphones Source\" },\n\n\t{ \"Capture Source\", \"Line In\", \"Line In\" },\n\t{ \"Capture Source\", \"Mic 1\", \"Mic 1\" },\n\t{ \"Capture Source\", \"Mic 2\", \"Mic 2\" },\n\t{ \"ADC\", NULL, \"Capture Source\" },\n\n\t{ \"Line In Bypass\", NULL, \"Line In\" },\n\t{ \"Line Out Source\", \"Line In\", \"Line In Bypass\" },\n\t{ \"Line Out Source\", \"PCM\", \"PCM Playback\" },\n\n\t{ \"LHPOUT\", NULL, \"HP Out\"},\n\t{ \"RHPOUT\", NULL, \"HP Out\"},\n\n\t{ \"Line Out\", NULL, \"Line Out Source\" },\n\t{ \"Line Out Switch 2\", NULL, \"Line Out\" },\n\n\t{ \"LOUT\", NULL, \"Line Out Switch 2\"},\n\t{ \"ROUT\", NULL, \"Line Out Switch 2\"},\n\n\t{ \"PCM Playback\", \"Volume\", \"DAC\" },\n\t{ \"Headphones Playback\", \"Volume\", \"PCM Playback\" },\n\n\t{ \"SYSCLK\", NULL, \"DAC\" },\n};\n\nstatic void jz4770_codec_codec_init_regs(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tstruct regmap *regmap = jz_codec->regmap;\n\n\t \n\tregcache_cache_only(regmap, true);\n\n\t \n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_HP, REG_CR_HP_SEL_MASK);\n\n\t \n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_LO, REG_CR_LO_SEL_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_MIC,\n\t\t\t  BIT(REG_CR_MIC_STEREO_OFFSET));\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_ADC,\n\t\t\t  REG_CR_ADC_IN_SEL_MASK);\n\n\t \n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_AICR_ADC,\n\t\t\tREG_AICR_ADC_SERIAL | REG_AICR_ADC_I2S);\n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_AICR_DAC,\n\t\t\tREG_AICR_DAC_SERIAL | REG_AICR_DAC_I2S);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_ICR, REG_ICR_INT_FORM_MASK);\n\tregmap_update_bits(regmap, JZ4770_CODEC_REG_IMR, REG_IMR_ALL_MASK,\n\t\t\t   REG_IMR_JACK_MASK | REG_IMR_RUP_MASK |\n\t\t\t   REG_IMR_RDO_MASK | REG_IMR_GUP_MASK |\n\t\t\t   REG_IMR_GDO_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CCR, REG_CCR_CRYSTAL_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_HP, REG_CR_HP_LOAD);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_AGC1, REG_AGC1_EN);\n\n\t \n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_DAC, REG_CR_DAC_LRSWAP);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_GCR_DACL,\n\t\t\t  REG_GCR_DACL_RLGOD);\n\n\t \n\tregmap_set_bits(regmap, JZ4770_CODEC_REG_CR_ADC, REG_CR_ADC_LRSWAP);\n\n\t \n\tregmap_clear_bits(regmap, JZ4770_CODEC_REG_CR_HP,\n\t\t\t  BIT(REG_CR_HP_SB_HPCM_OFFSET));\n\n\t \n\tregcache_cache_only(regmap, false);\n\tregcache_sync(regmap);\n}\n\nstatic int jz4770_codec_codec_probe(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\n\tclk_prepare_enable(jz_codec->clk);\n\n\tjz4770_codec_codec_init_regs(codec);\n\n\treturn 0;\n}\n\nstatic void jz4770_codec_codec_remove(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\n\tclk_disable_unprepare(jz_codec->clk);\n}\n\nstatic const struct snd_soc_component_driver jz4770_codec_soc_codec_dev = {\n\t.probe\t\t\t= jz4770_codec_codec_probe,\n\t.remove\t\t\t= jz4770_codec_codec_remove,\n\t.set_bias_level\t\t= jz4770_codec_set_bias_level,\n\t.controls\t\t= jz4770_codec_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(jz4770_codec_snd_controls),\n\t.dapm_widgets\t\t= jz4770_codec_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(jz4770_codec_dapm_widgets),\n\t.dapm_routes\t\t= jz4770_codec_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(jz4770_codec_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.use_pmdown_time\t= 1,\n};\n\nstatic const unsigned int jz4770_codec_sample_rates[] = {\n\t96000, 48000, 44100, 32000,\n\t24000, 22050, 16000, 12000,\n\t11025, 9600, 8000,\n};\n\nstatic int jz4770_codec_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct jz_codec *codec = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int rate, bit_width;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbit_width = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tbit_width = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tbit_width = 2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tbit_width = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (rate = 0; rate < ARRAY_SIZE(jz4770_codec_sample_rates); rate++) {\n\t\tif (jz4770_codec_sample_rates[rate] == params_rate(params))\n\t\t\tbreak;\n\t}\n\n\tif (rate == ARRAY_SIZE(jz4770_codec_sample_rates))\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(codec->regmap, JZ4770_CODEC_REG_AICR_DAC,\n\t\t\t\t   REG_AICR_DAC_ADWL_MASK,\n\t\t\t\t   bit_width << REG_AICR_DAC_ADWL_OFFSET);\n\t\tregmap_update_bits(codec->regmap, JZ4770_CODEC_REG_FCR_DAC,\n\t\t\t\t   REG_FCR_DAC_FREQ_MASK,\n\t\t\t\t   rate << REG_FCR_DAC_FREQ_OFFSET);\n\t} else {\n\t\tregmap_update_bits(codec->regmap, JZ4770_CODEC_REG_AICR_ADC,\n\t\t\t\t   REG_AICR_ADC_ADWL_MASK,\n\t\t\t\t   bit_width << REG_AICR_ADC_ADWL_OFFSET);\n\t\tregmap_update_bits(codec->regmap, JZ4770_CODEC_REG_FCR_ADC,\n\t\t\t\t   REG_FCR_ADC_FREQ_MASK,\n\t\t\t\t   rate << REG_FCR_ADC_FREQ_OFFSET);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops jz4770_codec_dai_ops = {\n\t.startup\t= jz4770_codec_startup,\n\t.shutdown\t= jz4770_codec_shutdown,\n\t.hw_params\t= jz4770_codec_hw_params,\n\t.trigger\t= jz4770_codec_pcm_trigger,\n\t.mute_stream\t= jz4770_codec_mute_stream,\n\t.no_capture_mute = 1,\n};\n\n#define JZ_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_3LE)\n\nstatic struct snd_soc_dai_driver jz4770_codec_dai = {\n\t.name = \"jz4770-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_CODEC_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_CODEC_FORMATS,\n\t},\n\t.ops = &jz4770_codec_dai_ops,\n};\n\nstatic bool jz4770_codec_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == JZ4770_CODEC_REG_SR || reg == JZ4770_CODEC_REG_IFR;\n}\n\nstatic bool jz4770_codec_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase JZ4770_CODEC_REG_MISSING_REG1:\n\tcase JZ4770_CODEC_REG_MISSING_REG2:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool jz4770_codec_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase JZ4770_CODEC_REG_SR:\n\tcase JZ4770_CODEC_REG_MISSING_REG1:\n\tcase JZ4770_CODEC_REG_MISSING_REG2:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int jz4770_codec_io_wait(struct jz_codec *codec)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(codec->base + ICDC_RGADW_OFFSET, reg,\n\t\t\t\t  !(reg & ICDC_RGADW_RGWR),\n\t\t\t\t  1000, 1 * USEC_PER_SEC);\n}\n\nstatic int jz4770_codec_reg_read(void *context, unsigned int reg,\n\t\t\t\t unsigned int *val)\n{\n\tstruct jz_codec *codec = context;\n\tunsigned int i;\n\tu32 tmp;\n\tint ret;\n\n\tret = jz4770_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = readl(codec->base + ICDC_RGADW_OFFSET);\n\ttmp = (tmp & ~ICDC_RGADW_RGADDR_MASK)\n\t    | (reg << ICDC_RGADW_RGADDR_OFFSET);\n\twritel(tmp, codec->base + ICDC_RGADW_OFFSET);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\t*val = readl(codec->base + ICDC_RGDATA_OFFSET) &\n\t\t\tICDC_RGDATA_RGDOUT_MASK;\n\n\treturn 0;\n}\n\nstatic int jz4770_codec_reg_write(void *context, unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\tstruct jz_codec *codec = context;\n\tint ret;\n\n\tret = jz4770_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(ICDC_RGADW_RGWR | (reg << ICDC_RGADW_RGADDR_OFFSET) | val,\n\t       codec->base + ICDC_RGADW_OFFSET);\n\n\tret = jz4770_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const u8 jz4770_codec_reg_defaults[] = {\n\t0x00, 0xC3, 0xC3, 0x90, 0x98, 0xFF, 0x90, 0xB1,\n\t0x11, 0x10, 0x00, 0x03, 0x00, 0x00, 0x40, 0x00,\n\t0xFF, 0x00, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x34,\n\t0x07, 0x44, 0x1F, 0x00\n};\n\nstatic struct regmap_config jz4770_codec_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 8,\n\n\t.max_register = JZ4770_CODEC_REG_AGC5,\n\t.volatile_reg = jz4770_codec_volatile,\n\t.readable_reg = jz4770_codec_readable,\n\t.writeable_reg = jz4770_codec_writeable,\n\n\t.reg_read = jz4770_codec_reg_read,\n\t.reg_write = jz4770_codec_reg_write,\n\n\t.reg_defaults_raw = jz4770_codec_reg_defaults,\n\t.num_reg_defaults_raw = ARRAY_SIZE(jz4770_codec_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int jz4770_codec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz_codec *codec;\n\tint ret;\n\n\tcodec = devm_kzalloc(dev, sizeof(*codec), GFP_KERNEL);\n\tif (!codec)\n\t\treturn -ENOMEM;\n\n\tcodec->dev = dev;\n\n\tcodec->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(codec->base))\n\t\treturn PTR_ERR(codec->base);\n\n\tcodec->regmap = devm_regmap_init(dev, NULL, codec,\n\t\t\t\t\t&jz4770_codec_regmap_config);\n\tif (IS_ERR(codec->regmap))\n\t\treturn PTR_ERR(codec->regmap);\n\n\tcodec->clk = devm_clk_get(dev, \"aic\");\n\tif (IS_ERR(codec->clk))\n\t\treturn PTR_ERR(codec->clk);\n\n\tplatform_set_drvdata(pdev, codec);\n\n\tret = devm_snd_soc_register_component(dev, &jz4770_codec_soc_codec_dev,\n\t\t\t\t\t      &jz4770_codec_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register codec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id jz4770_codec_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4770-codec\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, jz4770_codec_of_matches);\n\nstatic struct platform_driver jz4770_codec_driver = {\n\t.probe\t\t\t= jz4770_codec_probe,\n\t.driver\t\t\t= {\n\t\t.name\t\t= \"jz4770-codec\",\n\t\t.of_match_table = jz4770_codec_of_matches,\n\t},\n};\nmodule_platform_driver(jz4770_codec_driver);\n\nMODULE_DESCRIPTION(\"JZ4770 SoC internal codec driver\");\nMODULE_AUTHOR(\"Maarten ter Huurne <maarten@treewalker.org>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}