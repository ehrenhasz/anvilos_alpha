{
  "module_name": "wm8958-dsp2.c",
  "hash_id": "2261816d940fa117da6579e137838a2f43fe390a7e03e0b5d481da5cf45e3527",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8958-dsp2.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <trace/events/asoc.h>\n\n#include <linux/mfd/wm8994/core.h>\n#include <linux/mfd/wm8994/registers.h>\n#include <linux/mfd/wm8994/pdata.h>\n#include <linux/mfd/wm8994/gpio.h>\n\n#include <asm/unaligned.h>\n\n#include \"wm8994.h\"\n\n#define WM_FW_BLOCK_INFO 0xff\n#define WM_FW_BLOCK_PM   0x00\n#define WM_FW_BLOCK_X    0x01\n#define WM_FW_BLOCK_Y    0x02\n#define WM_FW_BLOCK_Z    0x03\n#define WM_FW_BLOCK_I    0x06\n#define WM_FW_BLOCK_A    0x08\n#define WM_FW_BLOCK_C    0x0c\n\nstatic int wm8958_dsp2_fw(struct snd_soc_component *component, const char *name,\n\t\t\t  const struct firmware *fw, bool check)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tu64 data64;\n\tu32 data32;\n\tconst u8 *data;\n\tchar *str;\n\tsize_t block_len, len;\n\tint ret = 0;\n\n\t \n\tif (wm8994->cur_fw == fw)\n\t\treturn 0;\n\n\tif (fw->size < 32) {\n\t\tdev_err(component->dev, \"%s: firmware too short (%zd bytes)\\n\",\n\t\t\tname, fw->size);\n\t\tgoto err;\n\t}\n\n\tif (memcmp(fw->data, \"WMFW\", 4) != 0) {\n\t\tdata32 = get_unaligned_be32(fw->data);\n\t\tdev_err(component->dev, \"%s: firmware has bad file magic %08x\\n\",\n\t\t\tname, data32);\n\t\tgoto err;\n\t}\n\n\tlen = get_unaligned_be32(fw->data + 4);\n\tdata32 = get_unaligned_be32(fw->data + 8);\n\n\tif ((data32 >> 24) & 0xff) {\n\t\tdev_err(component->dev, \"%s: unsupported firmware version %d\\n\",\n\t\t\tname, (data32 >> 24) & 0xff);\n\t\tgoto err;\n\t}\n\tif ((data32 & 0xffff) != 8958) {\n\t\tdev_err(component->dev, \"%s: unsupported target device %d\\n\",\n\t\t\tname, data32 & 0xffff);\n\t\tgoto err;\n\t}\n\tif (((data32 >> 16) & 0xff) != 0xc) {\n\t\tdev_err(component->dev, \"%s: unsupported target core %d\\n\",\n\t\t\tname, (data32 >> 16) & 0xff);\n\t\tgoto err;\n\t}\n\n\tif (check) {\n\t\tdata64 = get_unaligned_be64(fw->data + 24);\n\t\tdev_info(component->dev, \"%s timestamp %llx\\n\",  name, data64);\n\t} else {\n\t\tsnd_soc_component_write(component, 0x102, 0x2);\n\t\tsnd_soc_component_write(component, 0x900, 0x2);\n\t}\n\n\tdata = fw->data + len;\n\tlen = fw->size - len;\n\twhile (len) {\n\t\tif (len < 12) {\n\t\t\tdev_err(component->dev, \"%s short data block of %zd\\n\",\n\t\t\t\tname, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\tblock_len = get_unaligned_be32(data + 4);\n\t\tif (block_len + 8 > len) {\n\t\t\tdev_err(component->dev, \"%zd byte block longer than file\\n\",\n\t\t\t\tblock_len);\n\t\t\tgoto err;\n\t\t}\n\t\tif (block_len == 0) {\n\t\t\tdev_err(component->dev, \"Zero length block\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tdata32 = get_unaligned_be32(data);\n\n\t\tswitch ((data32 >> 24) & 0xff) {\n\t\tcase WM_FW_BLOCK_INFO:\n\t\t\t \n\t\t\tif (!check)\n\t\t\t\tbreak;\n\n\t\t\tstr = kzalloc(block_len + 1, GFP_KERNEL);\n\t\t\tif (str) {\n\t\t\t\tmemcpy(str, data + 8, block_len);\n\t\t\t\tdev_info(component->dev, \"%s: %s\\n\", name, str);\n\t\t\t\tkfree(str);\n\t\t\t} else {\n\t\t\t\tdev_err(component->dev, \"Out of memory\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_FW_BLOCK_PM:\n\t\tcase WM_FW_BLOCK_X:\n\t\tcase WM_FW_BLOCK_Y:\n\t\tcase WM_FW_BLOCK_Z:\n\t\tcase WM_FW_BLOCK_I:\n\t\tcase WM_FW_BLOCK_A:\n\t\tcase WM_FW_BLOCK_C:\n\t\t\tdev_dbg(component->dev, \"%s: %zd bytes of %x@%x\\n\", name,\n\t\t\t\tblock_len, (data32 >> 24) & 0xff,\n\t\t\t\tdata32 & 0xffffff);\n\n\t\t\tif (check)\n\t\t\t\tbreak;\n\n\t\t\tdata32 &= 0xffffff;\n\n\t\t\twm8994_bulk_write(wm8994->wm8994,\n\t\t\t\t\t  data32 & 0xffffff,\n\t\t\t\t\t  block_len / 2,\n\t\t\t\t\t  (void *)(data + 8));\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(component->dev, \"%s: unknown block type %d\\n\",\n\t\t\t\t name, (data32 >> 24) & 0xff);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tblock_len += block_len % 4;\n\n\t\tdata += block_len + 8;\n\t\tlen -= block_len + 8;\n\t}\n\n\tif (!check) {\n\t\tdev_dbg(component->dev, \"%s: download done\\n\", name);\n\t\twm8994->cur_fw = fw;\n\t} else {\n\t\tdev_info(component->dev, \"%s: got firmware\\n\", name);\n\t}\n\n\tgoto ok;\n\nerr:\n\tret = -EINVAL;\nok:\n\tif (!check) {\n\t\tsnd_soc_component_write(component, 0x900, 0x0);\n\t\tsnd_soc_component_write(component, 0x102, 0x0);\n\t}\n\n\treturn ret;\n}\n\nstatic void wm8958_dsp_start_mbc(struct snd_soc_component *component, int path)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint i;\n\n\t \n\tif (snd_soc_component_read(component, WM8958_DSP2_PROGRAM) & WM8958_DSP2_ENA)\n\t\treturn;\n\n\t \n\tif (wm8994->mbc)\n\t\twm8958_dsp2_fw(component, \"MBC\", wm8994->mbc, false);\n\n\tsnd_soc_component_update_bits(component, WM8958_DSP2_PROGRAM,\n\t\t\t    WM8958_DSP2_ENA, WM8958_DSP2_ENA);\n\n\t \n\tif (control->pdata.num_mbc_cfgs) {\n\t\tstruct wm8958_mbc_cfg *cfg\n\t\t\t= &control->pdata.mbc_cfgs[wm8994->mbc_cfg];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->coeff_regs); i++)\n\t\t\tsnd_soc_component_write(component, i + WM8958_MBC_BAND_1_K_1,\n\t\t\t\t      cfg->coeff_regs[i]);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->cutoff_regs); i++)\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\t      i + WM8958_MBC_BAND_2_LOWER_CUTOFF_C1_1,\n\t\t\t\t      cfg->cutoff_regs[i]);\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8958_DSP2_EXECCONTROL,\n\t\t      WM8958_DSP2_RUNR);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8958_DSP2_CONFIG,\n\t\t\t    WM8958_MBC_ENA |\n\t\t\t    WM8958_MBC_SEL_MASK,\n\t\t\t    path << WM8958_MBC_SEL_SHIFT |\n\t\t\t    WM8958_MBC_ENA);\n}\n\nstatic void wm8958_dsp_start_vss(struct snd_soc_component *component, int path)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint i, ena;\n\n\tif (wm8994->mbc_vss)\n\t\twm8958_dsp2_fw(component, \"MBC+VSS\", wm8994->mbc_vss, false);\n\n\tsnd_soc_component_update_bits(component, WM8958_DSP2_PROGRAM,\n\t\t\t    WM8958_DSP2_ENA, WM8958_DSP2_ENA);\n\n\t \n\tif (control->pdata.num_mbc_cfgs) {\n\t\tstruct wm8958_mbc_cfg *cfg\n\t\t\t= &control->pdata.mbc_cfgs[wm8994->mbc_cfg];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->combined_regs); i++)\n\t\t\tsnd_soc_component_write(component, i + 0x2800,\n\t\t\t\t      cfg->combined_regs[i]);\n\t}\n\n\tif (control->pdata.num_vss_cfgs) {\n\t\tstruct wm8958_vss_cfg *cfg\n\t\t\t= &control->pdata.vss_cfgs[wm8994->vss_cfg];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\n\t\t\tsnd_soc_component_write(component, i + 0x2600, cfg->regs[i]);\n\t}\n\n\tif (control->pdata.num_vss_hpf_cfgs) {\n\t\tstruct wm8958_vss_hpf_cfg *cfg\n\t\t\t= &control->pdata.vss_hpf_cfgs[wm8994->vss_hpf_cfg];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\n\t\t\tsnd_soc_component_write(component, i + 0x2400, cfg->regs[i]);\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8958_DSP2_EXECCONTROL,\n\t\t      WM8958_DSP2_RUNR);\n\n\t \n\tena = 0;\n\tif (wm8994->mbc_ena[path])\n\t\tena |= 0x8;\n\tif (wm8994->hpf2_ena[path])\n\t\tena |= 0x4;\n\tif (wm8994->hpf1_ena[path])\n\t\tena |= 0x2;\n\tif (wm8994->vss_ena[path])\n\t\tena |= 0x1;\n\n\tsnd_soc_component_write(component, 0x2201, ena);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8958_DSP2_CONFIG,\n\t\t\t    WM8958_MBC_SEL_MASK | WM8958_MBC_ENA,\n\t\t\t    path << WM8958_MBC_SEL_SHIFT | WM8958_MBC_ENA);\n}\n\nstatic void wm8958_dsp_start_enh_eq(struct snd_soc_component *component, int path)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint i;\n\n\twm8958_dsp2_fw(component, \"ENH_EQ\", wm8994->enh_eq, false);\n\n\tsnd_soc_component_update_bits(component, WM8958_DSP2_PROGRAM,\n\t\t\t    WM8958_DSP2_ENA, WM8958_DSP2_ENA);\n\n\t \n\tif (control->pdata.num_enh_eq_cfgs) {\n\t\tstruct wm8958_enh_eq_cfg *cfg\n\t\t\t= &control->pdata.enh_eq_cfgs[wm8994->enh_eq_cfg];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(cfg->regs); i++)\n\t\t\tsnd_soc_component_write(component, i + 0x2200,\n\t\t\t\t      cfg->regs[i]);\n\t}\n\n\t \n\tsnd_soc_component_write(component, WM8958_DSP2_EXECCONTROL,\n\t\t      WM8958_DSP2_RUNR);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8958_DSP2_CONFIG,\n\t\t\t    WM8958_MBC_SEL_MASK | WM8958_MBC_ENA,\n\t\t\t    path << WM8958_MBC_SEL_SHIFT | WM8958_MBC_ENA);\n}\n\nstatic void wm8958_dsp_apply(struct snd_soc_component *component, int path, int start)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tint pwr_reg = snd_soc_component_read(component, WM8994_POWER_MANAGEMENT_5);\n\tint ena, reg, aif;\n\n\tswitch (path) {\n\tcase 0:\n\t\tpwr_reg &= (WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA);\n\t\taif = 0;\n\t\tbreak;\n\tcase 1:\n\t\tpwr_reg &= (WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);\n\t\taif = 0;\n\t\tbreak;\n\tcase 2:\n\t\tpwr_reg &= (WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA);\n\t\taif = 1;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid path %d\\n\", path);\n\t\treturn;\n\t}\n\n\t \n\tena = wm8994->mbc_ena[path] || wm8994->vss_ena[path] ||\n\t\twm8994->hpf1_ena[path] || wm8994->hpf2_ena[path] ||\n\t\twm8994->enh_eq_ena[path];\n\tif (!pwr_reg)\n\t\tena = 0;\n\n\treg = snd_soc_component_read(component, WM8958_DSP2_PROGRAM);\n\n\tdev_dbg(component->dev, \"DSP path %d %d startup: %d, power: %x, DSP: %x\\n\",\n\t\tpath, wm8994->dsp_active, start, pwr_reg, reg);\n\n\tif (start && ena) {\n\t\t \n\t\tif (reg & WM8958_DSP2_ENA)\n\t\t\treturn;\n\n\t\t \n\t\tif (!(snd_soc_component_read(component, WM8994_AIF1_CLOCKING_1)\n\t\t      & WM8994_AIF1CLK_ENA_MASK) &&\n\t\t    !(snd_soc_component_read(component, WM8994_AIF2_CLOCKING_1)\n\t\t      & WM8994_AIF2CLK_ENA_MASK))\n\t\t\treturn;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8994_CLOCKING_1,\n\t\t\t\t    WM8958_DSP2CLK_SRC | WM8958_DSP2CLK_ENA,\n\t\t\t\t    aif << WM8958_DSP2CLK_SRC_SHIFT |\n\t\t\t\t    WM8958_DSP2CLK_ENA);\n\n\t\tif (wm8994->enh_eq_ena[path])\n\t\t\twm8958_dsp_start_enh_eq(component, path);\n\t\telse if (wm8994->vss_ena[path] || wm8994->hpf1_ena[path] ||\n\t\t    wm8994->hpf2_ena[path])\n\t\t\twm8958_dsp_start_vss(component, path);\n\t\telse if (wm8994->mbc_ena[path])\n\t\t\twm8958_dsp_start_mbc(component, path);\n\n\t\twm8994->dsp_active = path;\n\n\t\tdev_dbg(component->dev, \"DSP running in path %d\\n\", path);\n\t}\n\n\tif (!start && wm8994->dsp_active == path) {\n\t\t \n\t\tif (!(reg & WM8958_DSP2_ENA))\n\t\t\treturn;\n\n\t\tsnd_soc_component_update_bits(component, WM8958_DSP2_CONFIG,\n\t\t\t\t    WM8958_MBC_ENA, 0);\t\n\t\tsnd_soc_component_write(component, WM8958_DSP2_EXECCONTROL,\n\t\t\t      WM8958_DSP2_STOP);\n\t\tsnd_soc_component_update_bits(component, WM8958_DSP2_PROGRAM,\n\t\t\t\t    WM8958_DSP2_ENA, 0);\n\t\tsnd_soc_component_update_bits(component, WM8994_CLOCKING_1,\n\t\t\t\t    WM8958_DSP2CLK_ENA, 0);\n\n\t\twm8994->dsp_active = -1;\n\n\t\tdev_dbg(component->dev, \"DSP stopped\\n\");\n\t}\n}\n\nint wm8958_aif_ev(struct snd_soc_dapm_widget *w,\n\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8994 *control = dev_get_drvdata(component->dev->parent);\n\tint i;\n\n\tif (control->type != WM8958)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tfor (i = 0; i < 3; i++)\n\t\t\twm8958_dsp_apply(component, i, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tfor (i = 0; i < 3; i++)\n\t\t\twm8958_dsp_apply(component, i, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int wm8958_dsp2_busy(struct wm8994_priv *wm8994, int aif)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8994->mbc_ena); i++) {\n\t\tif (i == aif)\n\t\t\tcontinue;\n\t\tif (wm8994->mbc_ena[i] || wm8994->vss_ena[i] ||\n\t\t    wm8994->hpf1_ena[i] || wm8994->hpf2_ena[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8958_put_mbc_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint value = ucontrol->value.enumerated.item[0];\n\tint reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8994_CLOCKING_1);\n\tif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\n\t\treturn -EBUSY;\n\n\tif (value >= control->pdata.num_mbc_cfgs)\n\t\treturn -EINVAL;\n\n\twm8994->mbc_cfg = value;\n\n\treturn 0;\n}\n\nstatic int wm8958_get_mbc_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8994->mbc_cfg;\n\n\treturn 0;\n}\n\nstatic int wm8958_mbc_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm8958_mbc_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint mbc = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8994->mbc_ena[mbc];\n\n\treturn 0;\n}\n\nstatic int wm8958_mbc_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint mbc = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (wm8994->mbc_ena[mbc] == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0] > 1)\n\t\treturn -EINVAL;\n\n\tif (wm8958_dsp2_busy(wm8994, mbc)) {\n\t\tdev_dbg(component->dev, \"DSP2 active on %d already\\n\", mbc);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wm8994->enh_eq_ena[mbc])\n\t\treturn -EBUSY;\n\n\twm8994->mbc_ena[mbc] = ucontrol->value.integer.value[0];\n\n\twm8958_dsp_apply(component, mbc, wm8994->mbc_ena[mbc]);\n\n\treturn 1;\n}\n\n#define WM8958_MBC_SWITCH(xname, xval) {\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.info = wm8958_mbc_info, \\\n\t.get = wm8958_mbc_get, .put = wm8958_mbc_put, \\\n\t.private_value = xval }\n\nstatic int wm8958_put_vss_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint value = ucontrol->value.enumerated.item[0];\n\tint reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8994_CLOCKING_1);\n\tif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\n\t\treturn -EBUSY;\n\n\tif (value >= control->pdata.num_vss_cfgs)\n\t\treturn -EINVAL;\n\n\twm8994->vss_cfg = value;\n\n\treturn 0;\n}\n\nstatic int wm8958_get_vss_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8994->vss_cfg;\n\n\treturn 0;\n}\n\nstatic int wm8958_put_vss_hpf_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint value = ucontrol->value.enumerated.item[0];\n\tint reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8994_CLOCKING_1);\n\tif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\n\t\treturn -EBUSY;\n\n\tif (value >= control->pdata.num_vss_hpf_cfgs)\n\t\treturn -EINVAL;\n\n\twm8994->vss_hpf_cfg = value;\n\n\treturn 0;\n}\n\nstatic int wm8958_get_vss_hpf_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8994->vss_hpf_cfg;\n\n\treturn 0;\n}\n\nstatic int wm8958_vss_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm8958_vss_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint vss = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8994->vss_ena[vss];\n\n\treturn 0;\n}\n\nstatic int wm8958_vss_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint vss = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (wm8994->vss_ena[vss] == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0] > 1)\n\t\treturn -EINVAL;\n\n\tif (!wm8994->mbc_vss)\n\t\treturn -ENODEV;\n\n\tif (wm8958_dsp2_busy(wm8994, vss)) {\n\t\tdev_dbg(component->dev, \"DSP2 active on %d already\\n\", vss);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wm8994->enh_eq_ena[vss])\n\t\treturn -EBUSY;\n\n\twm8994->vss_ena[vss] = ucontrol->value.integer.value[0];\n\n\twm8958_dsp_apply(component, vss, wm8994->vss_ena[vss]);\n\n\treturn 1;\n}\n\n\n#define WM8958_VSS_SWITCH(xname, xval) {\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.info = wm8958_vss_info, \\\n\t.get = wm8958_vss_get, .put = wm8958_vss_put, \\\n\t.private_value = xval }\n\nstatic int wm8958_hpf_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm8958_hpf_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint hpf = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (hpf < 3)\n\t\tucontrol->value.integer.value[0] = wm8994->hpf1_ena[hpf % 3];\n\telse\n\t\tucontrol->value.integer.value[0] = wm8994->hpf2_ena[hpf % 3];\n\n\treturn 0;\n}\n\nstatic int wm8958_hpf_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint hpf = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (hpf < 3) {\n\t\tif (wm8994->hpf1_ena[hpf % 3] ==\n\t\t    ucontrol->value.integer.value[0])\n\t\t\treturn 0;\n\t} else {\n\t\tif (wm8994->hpf2_ena[hpf % 3] ==\n\t\t    ucontrol->value.integer.value[0])\n\t\t\treturn 0;\n\t}\n\n\tif (ucontrol->value.integer.value[0] > 1)\n\t\treturn -EINVAL;\n\n\tif (!wm8994->mbc_vss)\n\t\treturn -ENODEV;\n\n\tif (wm8958_dsp2_busy(wm8994, hpf % 3)) {\n\t\tdev_dbg(component->dev, \"DSP2 active on %d already\\n\", hpf);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wm8994->enh_eq_ena[hpf % 3])\n\t\treturn -EBUSY;\n\n\tif (hpf < 3)\n\t\twm8994->hpf1_ena[hpf % 3] = ucontrol->value.integer.value[0];\n\telse\n\t\twm8994->hpf2_ena[hpf % 3] = ucontrol->value.integer.value[0];\n\n\twm8958_dsp_apply(component, hpf % 3, ucontrol->value.integer.value[0]);\n\n\treturn 1;\n}\n\n#define WM8958_HPF_SWITCH(xname, xval) {\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.info = wm8958_hpf_info, \\\n\t.get = wm8958_hpf_get, .put = wm8958_hpf_put, \\\n\t.private_value = xval }\n\nstatic int wm8958_put_enh_eq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tint value = ucontrol->value.enumerated.item[0];\n\tint reg;\n\n\t \n\treg = snd_soc_component_read(component, WM8994_CLOCKING_1);\n\tif (reg < 0 || reg & WM8958_DSP2CLK_ENA)\n\t\treturn -EBUSY;\n\n\tif (value >= control->pdata.num_enh_eq_cfgs)\n\t\treturn -EINVAL;\n\n\twm8994->enh_eq_cfg = value;\n\n\treturn 0;\n}\n\nstatic int wm8958_get_enh_eq_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8994->enh_eq_cfg;\n\n\treturn 0;\n}\n\nstatic int wm8958_enh_eq_info(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\treturn 0;\n}\n\nstatic int wm8958_enh_eq_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint eq = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8994->enh_eq_ena[eq];\n\n\treturn 0;\n}\n\nstatic int wm8958_enh_eq_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tint eq = kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (wm8994->enh_eq_ena[eq] == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tif (ucontrol->value.integer.value[0] > 1)\n\t\treturn -EINVAL;\n\n\tif (!wm8994->enh_eq)\n\t\treturn -ENODEV;\n\n\tif (wm8958_dsp2_busy(wm8994, eq)) {\n\t\tdev_dbg(component->dev, \"DSP2 active on %d already\\n\", eq);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wm8994->mbc_ena[eq] || wm8994->vss_ena[eq] ||\n\t    wm8994->hpf1_ena[eq] || wm8994->hpf2_ena[eq])\n\t\treturn -EBUSY;\n\n\twm8994->enh_eq_ena[eq] = ucontrol->value.integer.value[0];\n\n\twm8958_dsp_apply(component, eq, ucontrol->value.integer.value[0]);\n\n\treturn 1;\n}\n\n#define WM8958_ENH_EQ_SWITCH(xname, xval) {\\\n\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\\\n\t.info = wm8958_enh_eq_info, \\\n\t.get = wm8958_enh_eq_get, .put = wm8958_enh_eq_put, \\\n\t.private_value = xval }\n\nstatic const struct snd_kcontrol_new wm8958_mbc_snd_controls[] = {\nWM8958_MBC_SWITCH(\"AIF1DAC1 MBC Switch\", 0),\nWM8958_MBC_SWITCH(\"AIF1DAC2 MBC Switch\", 1),\nWM8958_MBC_SWITCH(\"AIF2DAC MBC Switch\", 2),\n};\n\nstatic const struct snd_kcontrol_new wm8958_vss_snd_controls[] = {\nWM8958_VSS_SWITCH(\"AIF1DAC1 VSS Switch\", 0),\nWM8958_VSS_SWITCH(\"AIF1DAC2 VSS Switch\", 1),\nWM8958_VSS_SWITCH(\"AIF2DAC VSS Switch\", 2),\nWM8958_HPF_SWITCH(\"AIF1DAC1 HPF1 Switch\", 0),\nWM8958_HPF_SWITCH(\"AIF1DAC2 HPF1 Switch\", 1),\nWM8958_HPF_SWITCH(\"AIF2DAC HPF1 Switch\", 2),\nWM8958_HPF_SWITCH(\"AIF1DAC1 HPF2 Switch\", 3),\nWM8958_HPF_SWITCH(\"AIF1DAC2 HPF2 Switch\", 4),\nWM8958_HPF_SWITCH(\"AIF2DAC HPF2 Switch\", 5),\n};\n\nstatic const struct snd_kcontrol_new wm8958_enh_eq_snd_controls[] = {\nWM8958_ENH_EQ_SWITCH(\"AIF1DAC1 Enhanced EQ Switch\", 0),\nWM8958_ENH_EQ_SWITCH(\"AIF1DAC2 Enhanced EQ Switch\", 1),\nWM8958_ENH_EQ_SWITCH(\"AIF2DAC Enhanced EQ Switch\", 2),\n};\n\nstatic void wm8958_enh_eq_loaded(const struct firmware *fw, void *context)\n{\n\tstruct snd_soc_component *component = context;\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (fw && (wm8958_dsp2_fw(component, \"ENH_EQ\", fw, true) == 0)) {\n\t\tmutex_lock(&wm8994->fw_lock);\n\t\twm8994->enh_eq = fw;\n\t\tmutex_unlock(&wm8994->fw_lock);\n\t}\n}\n\nstatic void wm8958_mbc_vss_loaded(const struct firmware *fw, void *context)\n{\n\tstruct snd_soc_component *component = context;\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (fw && (wm8958_dsp2_fw(component, \"MBC+VSS\", fw, true) == 0)) {\n\t\tmutex_lock(&wm8994->fw_lock);\n\t\twm8994->mbc_vss = fw;\n\t\tmutex_unlock(&wm8994->fw_lock);\n\t}\n}\n\nstatic void wm8958_mbc_loaded(const struct firmware *fw, void *context)\n{\n\tstruct snd_soc_component *component = context;\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\n\tif (fw && (wm8958_dsp2_fw(component, \"MBC\", fw, true) == 0)) {\n\t\tmutex_lock(&wm8994->fw_lock);\n\t\twm8994->mbc = fw;\n\t\tmutex_unlock(&wm8994->fw_lock);\n\t}\n}\n\nvoid wm8958_dsp2_init(struct snd_soc_component *component)\n{\n\tstruct wm8994_priv *wm8994 = snd_soc_component_get_drvdata(component);\n\tstruct wm8994 *control = wm8994->wm8994;\n\tstruct wm8994_pdata *pdata = &control->pdata;\n\tint ret, i;\n\n\twm8994->dsp_active = -1;\n\n\tsnd_soc_add_component_controls(component, wm8958_mbc_snd_controls,\n\t\t\t     ARRAY_SIZE(wm8958_mbc_snd_controls));\n\tsnd_soc_add_component_controls(component, wm8958_vss_snd_controls,\n\t\t\t     ARRAY_SIZE(wm8958_vss_snd_controls));\n\tsnd_soc_add_component_controls(component, wm8958_enh_eq_snd_controls,\n\t\t\t     ARRAY_SIZE(wm8958_enh_eq_snd_controls));\n\n\n\t \n\trequest_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t\"wm8958_mbc.wfw\", component->dev, GFP_KERNEL,\n\t\t\t\tcomponent, wm8958_mbc_loaded);\n\trequest_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t\"wm8958_mbc_vss.wfw\", component->dev, GFP_KERNEL,\n\t\t\t\tcomponent, wm8958_mbc_vss_loaded);\n\trequest_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t\"wm8958_enh_eq.wfw\", component->dev, GFP_KERNEL,\n\t\t\t\tcomponent, wm8958_enh_eq_loaded);\n\n\tif (pdata->num_mbc_cfgs) {\n\t\tstruct snd_kcontrol_new mbc_control[] = {\n\t\t\tSOC_ENUM_EXT(\"MBC Mode\", wm8994->mbc_enum,\n\t\t\t\t     wm8958_get_mbc_enum, wm8958_put_mbc_enum),\n\t\t};\n\n\t\t \n\t\twm8994->mbc_texts = kmalloc_array(pdata->num_mbc_cfgs,\n\t\t\t\t\t\t  sizeof(char *),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!wm8994->mbc_texts)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < pdata->num_mbc_cfgs; i++)\n\t\t\twm8994->mbc_texts[i] = pdata->mbc_cfgs[i].name;\n\n\t\twm8994->mbc_enum.items = pdata->num_mbc_cfgs;\n\t\twm8994->mbc_enum.texts = wm8994->mbc_texts;\n\n\t\tret = snd_soc_add_component_controls(wm8994->hubs.component,\n\t\t\t\t\t\t mbc_control, 1);\n\t\tif (ret != 0)\n\t\t\tdev_err(wm8994->hubs.component->dev,\n\t\t\t\t\"Failed to add MBC mode controls: %d\\n\", ret);\n\t}\n\n\tif (pdata->num_vss_cfgs) {\n\t\tstruct snd_kcontrol_new vss_control[] = {\n\t\t\tSOC_ENUM_EXT(\"VSS Mode\", wm8994->vss_enum,\n\t\t\t\t     wm8958_get_vss_enum, wm8958_put_vss_enum),\n\t\t};\n\n\t\t \n\t\twm8994->vss_texts = kmalloc_array(pdata->num_vss_cfgs,\n\t\t\t\t\t\t  sizeof(char *),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!wm8994->vss_texts)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < pdata->num_vss_cfgs; i++)\n\t\t\twm8994->vss_texts[i] = pdata->vss_cfgs[i].name;\n\n\t\twm8994->vss_enum.items = pdata->num_vss_cfgs;\n\t\twm8994->vss_enum.texts = wm8994->vss_texts;\n\n\t\tret = snd_soc_add_component_controls(wm8994->hubs.component,\n\t\t\t\t\t\t vss_control, 1);\n\t\tif (ret != 0)\n\t\t\tdev_err(wm8994->hubs.component->dev,\n\t\t\t\t\"Failed to add VSS mode controls: %d\\n\", ret);\n\t}\n\n\tif (pdata->num_vss_hpf_cfgs) {\n\t\tstruct snd_kcontrol_new hpf_control[] = {\n\t\t\tSOC_ENUM_EXT(\"VSS HPF Mode\", wm8994->vss_hpf_enum,\n\t\t\t\t     wm8958_get_vss_hpf_enum,\n\t\t\t\t     wm8958_put_vss_hpf_enum),\n\t\t};\n\n\t\t \n\t\twm8994->vss_hpf_texts = kmalloc_array(pdata->num_vss_hpf_cfgs,\n\t\t\t\t\t\t      sizeof(char *),\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!wm8994->vss_hpf_texts)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < pdata->num_vss_hpf_cfgs; i++)\n\t\t\twm8994->vss_hpf_texts[i] = pdata->vss_hpf_cfgs[i].name;\n\n\t\twm8994->vss_hpf_enum.items = pdata->num_vss_hpf_cfgs;\n\t\twm8994->vss_hpf_enum.texts = wm8994->vss_hpf_texts;\n\n\t\tret = snd_soc_add_component_controls(wm8994->hubs.component,\n\t\t\t\t\t\t hpf_control, 1);\n\t\tif (ret != 0)\n\t\t\tdev_err(wm8994->hubs.component->dev,\n\t\t\t\t\"Failed to add VSS HPFmode controls: %d\\n\",\n\t\t\t\tret);\n\t}\n\n\tif (pdata->num_enh_eq_cfgs) {\n\t\tstruct snd_kcontrol_new eq_control[] = {\n\t\t\tSOC_ENUM_EXT(\"Enhanced EQ Mode\", wm8994->enh_eq_enum,\n\t\t\t\t     wm8958_get_enh_eq_enum,\n\t\t\t\t     wm8958_put_enh_eq_enum),\n\t\t};\n\n\t\t \n\t\twm8994->enh_eq_texts = kmalloc_array(pdata->num_enh_eq_cfgs,\n\t\t\t\t\t\t     sizeof(char *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!wm8994->enh_eq_texts)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < pdata->num_enh_eq_cfgs; i++)\n\t\t\twm8994->enh_eq_texts[i] = pdata->enh_eq_cfgs[i].name;\n\n\t\twm8994->enh_eq_enum.items = pdata->num_enh_eq_cfgs;\n\t\twm8994->enh_eq_enum.texts = wm8994->enh_eq_texts;\n\n\t\tret = snd_soc_add_component_controls(wm8994->hubs.component,\n\t\t\t\t\t\t eq_control, 1);\n\t\tif (ret != 0)\n\t\t\tdev_err(wm8994->hubs.component->dev,\n\t\t\t\t\"Failed to add enhanced EQ controls: %d\\n\",\n\t\t\t\tret);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}