{
  "module_name": "wm8985.c",
  "hash_id": "1a96d06c15c85326bb115081be7e7759b9f0a1b07461e4375defff850ee4c5b2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8985.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8985.h\"\n\n#define WM8985_NUM_SUPPLIES 4\nstatic const char *wm8985_supply_names[WM8985_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"AVDD1\",\n\t\"AVDD2\"\n};\n\nenum wm8985_type {\n\tWM8985,\n\tWM8758,\n};\n\nstatic const struct reg_default wm8985_reg_defaults[] = {\n\t{ 1,  0x0000 },      \n\t{ 2,  0x0000 },      \n\t{ 3,  0x0000 },      \n\t{ 4,  0x0050 },      \n\t{ 5,  0x0000 },      \n\t{ 6,  0x0140 },      \n\t{ 7,  0x0000 },      \n\t{ 8,  0x0000 },      \n\t{ 9,  0x0000 },      \n\t{ 10, 0x0000 },      \n\t{ 11, 0x00FF },      \n\t{ 12, 0x00FF },      \n\t{ 13, 0x0000 },      \n\t{ 14, 0x0100 },      \n\t{ 15, 0x00FF },      \n\t{ 16, 0x00FF },      \n\t{ 18, 0x012C },      \n\t{ 19, 0x002C },      \n\t{ 20, 0x002C },      \n\t{ 21, 0x002C },      \n\t{ 22, 0x002C },      \n\t{ 24, 0x0032 },      \n\t{ 25, 0x0000 },      \n\t{ 27, 0x0000 },      \n\t{ 28, 0x0000 },      \n\t{ 29, 0x0000 },      \n\t{ 30, 0x0000 },      \n\t{ 32, 0x0038 },      \n\t{ 33, 0x000B },      \n\t{ 34, 0x0032 },      \n\t{ 35, 0x0000 },      \n\t{ 36, 0x0008 },      \n\t{ 37, 0x000C },      \n\t{ 38, 0x0093 },      \n\t{ 39, 0x00E9 },      \n\t{ 41, 0x0000 },      \n\t{ 42, 0x0000 },      \n\t{ 43, 0x0000 },      \n\t{ 44, 0x0033 },      \n\t{ 45, 0x0010 },      \n\t{ 46, 0x0010 },      \n\t{ 47, 0x0100 },      \n\t{ 48, 0x0100 },      \n\t{ 49, 0x0002 },      \n\t{ 50, 0x0001 },      \n\t{ 51, 0x0001 },      \n\t{ 52, 0x0039 },      \n\t{ 53, 0x0039 },      \n\t{ 54, 0x0039 },      \n\t{ 55, 0x0039 },      \n\t{ 56, 0x0001 },      \n\t{ 57, 0x0001 },      \n\t{ 60, 0x0004 },      \n\t{ 61, 0x0000 },      \n};\n\nstatic bool wm8985_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8985_SOFTWARE_RESET:\n\tcase WM8985_POWER_MANAGEMENT_1:\n\tcase WM8985_POWER_MANAGEMENT_2:\n\tcase WM8985_POWER_MANAGEMENT_3:\n\tcase WM8985_AUDIO_INTERFACE:\n\tcase WM8985_COMPANDING_CONTROL:\n\tcase WM8985_CLOCK_GEN_CONTROL:\n\tcase WM8985_ADDITIONAL_CONTROL:\n\tcase WM8985_GPIO_CONTROL:\n\tcase WM8985_JACK_DETECT_CONTROL_1:\n\tcase WM8985_DAC_CONTROL:\n\tcase WM8985_LEFT_DAC_DIGITAL_VOL:\n\tcase WM8985_RIGHT_DAC_DIGITAL_VOL:\n\tcase WM8985_JACK_DETECT_CONTROL_2:\n\tcase WM8985_ADC_CONTROL:\n\tcase WM8985_LEFT_ADC_DIGITAL_VOL:\n\tcase WM8985_RIGHT_ADC_DIGITAL_VOL:\n\tcase WM8985_EQ1_LOW_SHELF:\n\tcase WM8985_EQ2_PEAK_1:\n\tcase WM8985_EQ3_PEAK_2:\n\tcase WM8985_EQ4_PEAK_3:\n\tcase WM8985_EQ5_HIGH_SHELF:\n\tcase WM8985_DAC_LIMITER_1:\n\tcase WM8985_DAC_LIMITER_2:\n\tcase WM8985_NOTCH_FILTER_1:\n\tcase WM8985_NOTCH_FILTER_2:\n\tcase WM8985_NOTCH_FILTER_3:\n\tcase WM8985_NOTCH_FILTER_4:\n\tcase WM8985_ALC_CONTROL_1:\n\tcase WM8985_ALC_CONTROL_2:\n\tcase WM8985_ALC_CONTROL_3:\n\tcase WM8985_NOISE_GATE:\n\tcase WM8985_PLL_N:\n\tcase WM8985_PLL_K_1:\n\tcase WM8985_PLL_K_2:\n\tcase WM8985_PLL_K_3:\n\tcase WM8985_3D_CONTROL:\n\tcase WM8985_OUT4_TO_ADC:\n\tcase WM8985_BEEP_CONTROL:\n\tcase WM8985_INPUT_CTRL:\n\tcase WM8985_LEFT_INP_PGA_GAIN_CTRL:\n\tcase WM8985_RIGHT_INP_PGA_GAIN_CTRL:\n\tcase WM8985_LEFT_ADC_BOOST_CTRL:\n\tcase WM8985_RIGHT_ADC_BOOST_CTRL:\n\tcase WM8985_OUTPUT_CTRL0:\n\tcase WM8985_LEFT_MIXER_CTRL:\n\tcase WM8985_RIGHT_MIXER_CTRL:\n\tcase WM8985_LOUT1_HP_VOLUME_CTRL:\n\tcase WM8985_ROUT1_HP_VOLUME_CTRL:\n\tcase WM8985_LOUT2_SPK_VOLUME_CTRL:\n\tcase WM8985_ROUT2_SPK_VOLUME_CTRL:\n\tcase WM8985_OUT3_MIXER_CTRL:\n\tcase WM8985_OUT4_MONO_MIX_CTRL:\n\tcase WM8985_OUTPUT_CTRL1:\n\tcase WM8985_BIAS_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n \nstatic const int volume_update_regs[] = {\n\tWM8985_LEFT_DAC_DIGITAL_VOL,\n\tWM8985_RIGHT_DAC_DIGITAL_VOL,\n\tWM8985_LEFT_ADC_DIGITAL_VOL,\n\tWM8985_RIGHT_ADC_DIGITAL_VOL,\n\tWM8985_LOUT2_SPK_VOLUME_CTRL,\n\tWM8985_ROUT2_SPK_VOLUME_CTRL,\n\tWM8985_LOUT1_HP_VOLUME_CTRL,\n\tWM8985_ROUT1_HP_VOLUME_CTRL,\n\tWM8985_LEFT_INP_PGA_GAIN_CTRL,\n\tWM8985_RIGHT_INP_PGA_GAIN_CTRL\n};\n\nstruct wm8985_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8985_NUM_SUPPLIES];\n\tenum wm8985_type dev_type;\n\tunsigned int sysclk;\n\tunsigned int bclk;\n};\n\nstatic const struct {\n\tint div;\n\tint ratio;\n} fs_ratios[] = {\n\t{ 10, 128 },\n\t{ 15, 192 },\n\t{ 20, 256 },\n\t{ 30, 384 },\n\t{ 40, 512 },\n\t{ 60, 768 },\n\t{ 80, 1024 },\n\t{ 120, 1536 }\n};\n\nstatic const int srates[] = { 48000, 32000, 24000, 16000, 12000, 8000 };\n\nstatic const int bclk_divs[] = {\n\t1, 2, 4, 8, 16, 32\n};\n\nstatic int eqmode_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\n\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -12700, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(lim_thresh_tlv, -600, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(lim_boost_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_min_tlv, -1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_max_tlv, -675, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_tar_tlv, -2250, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_vol_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, -1200, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(aux_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_boost_tlv, 0, 2000, 0);\n\nstatic const char *alc_sel_text[] = { \"Off\", \"Right\", \"Left\", \"Stereo\" };\nstatic SOC_ENUM_SINGLE_DECL(alc_sel, WM8985_ALC_CONTROL_1, 7, alc_sel_text);\n\nstatic const char *alc_mode_text[] = { \"ALC\", \"Limiter\" };\nstatic SOC_ENUM_SINGLE_DECL(alc_mode, WM8985_ALC_CONTROL_3, 8, alc_mode_text);\n\nstatic const char *filter_mode_text[] = { \"Audio\", \"Application\" };\nstatic SOC_ENUM_SINGLE_DECL(filter_mode, WM8985_ADC_CONTROL, 7,\n\t\t\t    filter_mode_text);\n\nstatic const char *eq_bw_text[] = { \"Narrow\", \"Wide\" };\nstatic const char *eqmode_text[] = { \"Capture\", \"Playback\" };\nstatic SOC_ENUM_SINGLE_EXT_DECL(eqmode, eqmode_text);\n\nstatic const char *eq1_cutoff_text[] = {\n\t\"80Hz\", \"105Hz\", \"135Hz\", \"175Hz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq1_cutoff, WM8985_EQ1_LOW_SHELF, 5,\n\t\t\t    eq1_cutoff_text);\nstatic const char *eq2_cutoff_text[] = {\n\t\"230Hz\", \"300Hz\", \"385Hz\", \"500Hz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq2_bw, WM8985_EQ2_PEAK_1, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq2_cutoff, WM8985_EQ2_PEAK_1, 5, eq2_cutoff_text);\nstatic const char *eq3_cutoff_text[] = {\n\t\"650Hz\", \"850Hz\", \"1.1kHz\", \"1.4kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq3_bw, WM8985_EQ3_PEAK_2, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq3_cutoff, WM8985_EQ3_PEAK_2, 5,\n\t\t\t    eq3_cutoff_text);\nstatic const char *eq4_cutoff_text[] = {\n\t\"1.8kHz\", \"2.4kHz\", \"3.2kHz\", \"4.1kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq4_bw, WM8985_EQ4_PEAK_3, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq4_cutoff, WM8985_EQ4_PEAK_3, 5, eq4_cutoff_text);\nstatic const char *eq5_cutoff_text[] = {\n\t\"5.3kHz\", \"6.9kHz\", \"9kHz\", \"11.7kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq5_cutoff, WM8985_EQ5_HIGH_SHELF, 5,\n\t\t\t\t  eq5_cutoff_text);\n\nstatic const char *speaker_mode_text[] = { \"Class A/B\", \"Class D\" };\nstatic SOC_ENUM_SINGLE_DECL(speaker_mode, 0x17, 8, speaker_mode_text);\n\nstatic const char *depth_3d_text[] = {\n\t\"Off\",\n\t\"6.67%\",\n\t\"13.3%\",\n\t\"20%\",\n\t\"26.7%\",\n\t\"33.3%\",\n\t\"40%\",\n\t\"46.6%\",\n\t\"53.3%\",\n\t\"60%\",\n\t\"66.7%\",\n\t\"73.3%\",\n\t\"80%\",\n\t\"86.7%\",\n\t\"93.3%\",\n\t\"100%\"\n};\nstatic SOC_ENUM_SINGLE_DECL(depth_3d, WM8985_3D_CONTROL, 0, depth_3d_text);\n\nstatic const struct snd_kcontrol_new wm8985_common_snd_controls[] = {\n\tSOC_SINGLE(\"Digital Loopback Switch\", WM8985_COMPANDING_CONTROL,\n\t\t0, 1, 0),\n\n\tSOC_ENUM(\"ALC Capture Function\", alc_sel),\n\tSOC_SINGLE_TLV(\"ALC Capture Max Volume\", WM8985_ALC_CONTROL_1,\n\t\t3, 7, 0, alc_max_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Min Volume\", WM8985_ALC_CONTROL_1,\n\t\t0, 7, 0, alc_min_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Target Volume\", WM8985_ALC_CONTROL_2,\n\t\t0, 15, 0, alc_tar_tlv),\n\tSOC_SINGLE(\"ALC Capture Attack\", WM8985_ALC_CONTROL_3, 0, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Hold\", WM8985_ALC_CONTROL_2, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Decay\", WM8985_ALC_CONTROL_3, 4, 10, 0),\n\tSOC_ENUM(\"ALC Mode\", alc_mode),\n\tSOC_SINGLE(\"ALC Capture NG Switch\", WM8985_NOISE_GATE,\n\t\t3, 1, 0),\n\tSOC_SINGLE(\"ALC Capture NG Threshold\", WM8985_NOISE_GATE,\n\t\t0, 7, 1),\n\n\tSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8985_LEFT_ADC_DIGITAL_VOL,\n\t\tWM8985_RIGHT_ADC_DIGITAL_VOL, 0, 255, 0, adc_tlv),\n\tSOC_DOUBLE_R(\"Capture PGA ZC Switch\", WM8985_LEFT_INP_PGA_GAIN_CTRL,\n\t\tWM8985_RIGHT_INP_PGA_GAIN_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Capture PGA Volume\", WM8985_LEFT_INP_PGA_GAIN_CTRL,\n\t\tWM8985_RIGHT_INP_PGA_GAIN_CTRL, 0, 63, 0, pga_vol_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Capture PGA Boost Volume\",\n\t\tWM8985_LEFT_ADC_BOOST_CTRL, WM8985_RIGHT_ADC_BOOST_CTRL,\n\t\t8, 1, 0, pga_boost_tlv),\n\n\tSOC_DOUBLE(\"ADC Inversion Switch\", WM8985_ADC_CONTROL, 0, 1, 1, 0),\n\tSOC_SINGLE(\"ADC 128x Oversampling Switch\", WM8985_ADC_CONTROL, 8, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8985_LEFT_DAC_DIGITAL_VOL,\n\t\tWM8985_RIGHT_DAC_DIGITAL_VOL, 0, 255, 0, dac_tlv),\n\n\tSOC_SINGLE(\"DAC Playback Limiter Switch\", WM8985_DAC_LIMITER_1, 8, 1, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Decay\", WM8985_DAC_LIMITER_1, 4, 10, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Attack\", WM8985_DAC_LIMITER_1, 0, 11, 0),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Threshold\", WM8985_DAC_LIMITER_2,\n\t\t4, 7, 1, lim_thresh_tlv),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Boost Volume\", WM8985_DAC_LIMITER_2,\n\t\t0, 12, 0, lim_boost_tlv),\n\tSOC_DOUBLE(\"DAC Inversion Switch\", WM8985_DAC_CONTROL, 0, 1, 1, 0),\n\tSOC_SINGLE(\"DAC Auto Mute Switch\", WM8985_DAC_CONTROL, 2, 1, 0),\n\tSOC_SINGLE(\"DAC 128x Oversampling Switch\", WM8985_DAC_CONTROL, 3, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", WM8985_LOUT1_HP_VOLUME_CTRL,\n\t\tWM8985_ROUT1_HP_VOLUME_CTRL, 0, 63, 0, out_tlv),\n\tSOC_DOUBLE_R(\"Headphone Playback ZC Switch\", WM8985_LOUT1_HP_VOLUME_CTRL,\n\t\tWM8985_ROUT1_HP_VOLUME_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Headphone Switch\", WM8985_LOUT1_HP_VOLUME_CTRL,\n\t\tWM8985_ROUT1_HP_VOLUME_CTRL, 6, 1, 1),\n\n\tSOC_DOUBLE_R_TLV(\"Speaker Playback Volume\", WM8985_LOUT2_SPK_VOLUME_CTRL,\n\t\tWM8985_ROUT2_SPK_VOLUME_CTRL, 0, 63, 0, out_tlv),\n\tSOC_DOUBLE_R(\"Speaker Playback ZC Switch\", WM8985_LOUT2_SPK_VOLUME_CTRL,\n\t\tWM8985_ROUT2_SPK_VOLUME_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Speaker Switch\", WM8985_LOUT2_SPK_VOLUME_CTRL,\n\t\tWM8985_ROUT2_SPK_VOLUME_CTRL, 6, 1, 1),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\", WM8985_ADC_CONTROL, 8, 1, 0),\n\tSOC_ENUM(\"High Pass Filter Mode\", filter_mode),\n\tSOC_SINGLE(\"High Pass Filter Cutoff\", WM8985_ADC_CONTROL, 4, 7, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Input PGA Bypass Volume\",\n\t\tWM8985_LEFT_MIXER_CTRL, WM8985_RIGHT_MIXER_CTRL, 2, 7, 0,\n\t\tbypass_tlv),\n\n\tSOC_ENUM_EXT(\"Equalizer Function\", eqmode, eqmode_get, eqmode_put),\n\tSOC_ENUM(\"EQ1 Cutoff\", eq1_cutoff),\n\tSOC_SINGLE_TLV(\"EQ1 Volume\", WM8985_EQ1_LOW_SHELF,  0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ2 Bandwidth\", eq2_bw),\n\tSOC_ENUM(\"EQ2 Cutoff\", eq2_cutoff),\n\tSOC_SINGLE_TLV(\"EQ2 Volume\", WM8985_EQ2_PEAK_1, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ3 Bandwidth\", eq3_bw),\n\tSOC_ENUM(\"EQ3 Cutoff\", eq3_cutoff),\n\tSOC_SINGLE_TLV(\"EQ3 Volume\", WM8985_EQ3_PEAK_2, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ4 Bandwidth\", eq4_bw),\n\tSOC_ENUM(\"EQ4 Cutoff\", eq4_cutoff),\n\tSOC_SINGLE_TLV(\"EQ4 Volume\", WM8985_EQ4_PEAK_3, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ5 Cutoff\", eq5_cutoff),\n\tSOC_SINGLE_TLV(\"EQ5 Volume\", WM8985_EQ5_HIGH_SHELF, 0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"3D Depth\", depth_3d),\n};\n\nstatic const struct snd_kcontrol_new wm8985_specific_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Aux Bypass Volume\",\n\t\tWM8985_LEFT_MIXER_CTRL, WM8985_RIGHT_MIXER_CTRL, 6, 7, 0,\n\t\taux_tlv),\n\n\tSOC_ENUM(\"Speaker Mode\", speaker_mode)\n};\n\nstatic const struct snd_kcontrol_new left_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Switch\", WM8985_LEFT_MIXER_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Switch\", WM8985_LEFT_MIXER_CTRL, 0, 1, 0),\n\n\t \n\tSOC_DAPM_SINGLE(\"Aux Switch\", WM8985_LEFT_MIXER_CTRL, 5, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Switch\", WM8985_RIGHT_MIXER_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Switch\", WM8985_RIGHT_MIXER_CTRL, 0, 1, 0),\n\n\t \n\tSOC_DAPM_SINGLE(\"Aux Switch\", WM8985_RIGHT_MIXER_CTRL, 5, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new left_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"L2 Switch\", WM8985_INPUT_CTRL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8985_INPUT_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8985_INPUT_CTRL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"R2 Switch\", WM8985_INPUT_CTRL, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8985_INPUT_CTRL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8985_INPUT_CTRL, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new left_boost_mixer[] = {\n\tSOC_DAPM_SINGLE_TLV(\"L2 Volume\", WM8985_LEFT_ADC_BOOST_CTRL,\n\t\t4, 7, 0, boost_tlv),\n\n\t \n\tSOC_DAPM_SINGLE_TLV(\"AUXL Volume\", WM8985_LEFT_ADC_BOOST_CTRL,\n\t\t0, 7, 0, boost_tlv)\n};\n\nstatic const struct snd_kcontrol_new right_boost_mixer[] = {\n\tSOC_DAPM_SINGLE_TLV(\"R2 Volume\", WM8985_RIGHT_ADC_BOOST_CTRL,\n\t\t4, 7, 0, boost_tlv),\n\n\t \n\tSOC_DAPM_SINGLE_TLV(\"AUXR Volume\", WM8985_RIGHT_ADC_BOOST_CTRL,\n\t\t0, 7, 0, boost_tlv)\n};\n\nstatic const struct snd_soc_dapm_widget wm8985_common_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", WM8985_POWER_MANAGEMENT_3,\n\t\t0, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", WM8985_POWER_MANAGEMENT_3,\n\t\t1, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", WM8985_POWER_MANAGEMENT_2,\n\t\t0, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", WM8985_POWER_MANAGEMENT_2,\n\t\t1, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left Input Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t2, 0, left_input_mixer, ARRAY_SIZE(left_input_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Input Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t3, 0, right_input_mixer, ARRAY_SIZE(right_input_mixer)),\n\n\tSND_SOC_DAPM_PGA(\"Left Capture PGA\", WM8985_LEFT_INP_PGA_GAIN_CTRL,\n\t\t6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Capture PGA\", WM8985_RIGHT_INP_PGA_GAIN_CTRL,\n\t\t6, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Headphone Out\", WM8985_POWER_MANAGEMENT_2,\n\t\t7, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Headphone Out\", WM8985_POWER_MANAGEMENT_2,\n\t\t8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Speaker Out\", WM8985_POWER_MANAGEMENT_3,\n\t\t5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Speaker Out\", WM8985_POWER_MANAGEMENT_3,\n\t\t6, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", WM8985_POWER_MANAGEMENT_1, 4, 0,\n\t\t\t    NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"LIN\"),\n\tSND_SOC_DAPM_INPUT(\"LIP\"),\n\tSND_SOC_DAPM_INPUT(\"RIN\"),\n\tSND_SOC_DAPM_INPUT(\"RIP\"),\n\tSND_SOC_DAPM_INPUT(\"L2\"),\n\tSND_SOC_DAPM_INPUT(\"R2\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\")\n};\n\nstatic const struct snd_soc_dapm_widget wm8985_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Left Output Mixer\", WM8985_POWER_MANAGEMENT_3,\n\t\t2, 0, left_out_mixer, ARRAY_SIZE(left_out_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Output Mixer\", WM8985_POWER_MANAGEMENT_3,\n\t\t3, 0, right_out_mixer, ARRAY_SIZE(right_out_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Boost Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t4, 0, left_boost_mixer, ARRAY_SIZE(left_boost_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Boost Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t5, 0, right_boost_mixer, ARRAY_SIZE(right_boost_mixer)),\n\n\tSND_SOC_DAPM_INPUT(\"AUXL\"),\n\tSND_SOC_DAPM_INPUT(\"AUXR\"),\n};\n\nstatic const struct snd_soc_dapm_widget wm8758_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Left Output Mixer\", WM8985_POWER_MANAGEMENT_3,\n\t\t2, 0, left_out_mixer,\n\t\tARRAY_SIZE(left_out_mixer) - 1),\n\tSND_SOC_DAPM_MIXER(\"Right Output Mixer\", WM8985_POWER_MANAGEMENT_3,\n\t\t3, 0, right_out_mixer,\n\t\tARRAY_SIZE(right_out_mixer) - 1),\n\n\tSND_SOC_DAPM_MIXER(\"Left Boost Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t4, 0, left_boost_mixer,\n\t\tARRAY_SIZE(left_boost_mixer) - 1),\n\tSND_SOC_DAPM_MIXER(\"Right Boost Mixer\", WM8985_POWER_MANAGEMENT_2,\n\t\t5, 0, right_boost_mixer,\n\t\tARRAY_SIZE(right_boost_mixer) - 1),\n};\n\nstatic const struct snd_soc_dapm_route wm8985_common_dapm_routes[] = {\n\t{ \"Right Output Mixer\", \"PCM Switch\", \"Right DAC\" },\n\t{ \"Right Output Mixer\", \"Line Switch\", \"Right Boost Mixer\" },\n\n\t{ \"Left Output Mixer\", \"PCM Switch\", \"Left DAC\" },\n\t{ \"Left Output Mixer\", \"Line Switch\", \"Left Boost Mixer\" },\n\n\t{ \"Right Headphone Out\", NULL, \"Right Output Mixer\" },\n\t{ \"HPR\", NULL, \"Right Headphone Out\" },\n\n\t{ \"Left Headphone Out\", NULL, \"Left Output Mixer\" },\n\t{ \"HPL\", NULL, \"Left Headphone Out\" },\n\n\t{ \"Right Speaker Out\", NULL, \"Right Output Mixer\" },\n\t{ \"SPKR\", NULL, \"Right Speaker Out\" },\n\n\t{ \"Left Speaker Out\", NULL, \"Left Output Mixer\" },\n\t{ \"SPKL\", NULL, \"Left Speaker Out\" },\n\n\t{ \"Right ADC\", NULL, \"Right Boost Mixer\" },\n\n\t{ \"Right Boost Mixer\", NULL, \"Right Capture PGA\" },\n\t{ \"Right Boost Mixer\", \"R2 Volume\", \"R2\" },\n\n\t{ \"Left ADC\", NULL, \"Left Boost Mixer\" },\n\n\t{ \"Left Boost Mixer\", NULL, \"Left Capture PGA\" },\n\t{ \"Left Boost Mixer\", \"L2 Volume\", \"L2\" },\n\n\t{ \"Right Capture PGA\", NULL, \"Right Input Mixer\" },\n\t{ \"Left Capture PGA\", NULL, \"Left Input Mixer\" },\n\n\t{ \"Right Input Mixer\", \"R2 Switch\", \"R2\" },\n\t{ \"Right Input Mixer\", \"MicN Switch\", \"RIN\" },\n\t{ \"Right Input Mixer\", \"MicP Switch\", \"RIP\" },\n\n\t{ \"Left Input Mixer\", \"L2 Switch\", \"L2\" },\n\t{ \"Left Input Mixer\", \"MicN Switch\", \"LIN\" },\n\t{ \"Left Input Mixer\", \"MicP Switch\", \"LIP\" },\n};\nstatic const struct snd_soc_dapm_route wm8985_aux_dapm_routes[] = {\n\t{ \"Right Output Mixer\", \"Aux Switch\", \"AUXR\" },\n\t{ \"Left Output Mixer\", \"Aux Switch\", \"AUXL\" },\n\n\t{ \"Right Boost Mixer\", \"AUXR Volume\", \"AUXR\" },\n\t{ \"Left Boost Mixer\", \"AUXL Volume\", \"AUXL\" },\n};\n\nstatic int wm8985_add_widgets(struct snd_soc_component *component)\n{\n\tstruct wm8985_priv *wm8985 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tswitch (wm8985->dev_type) {\n\tcase WM8758:\n\t\tsnd_soc_dapm_new_controls(dapm, wm8758_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(wm8758_dapm_widgets));\n\t\tbreak;\n\n\tcase WM8985:\n\t\tsnd_soc_add_component_controls(component, wm8985_specific_snd_controls,\n\t\t\tARRAY_SIZE(wm8985_specific_snd_controls));\n\n\t\tsnd_soc_dapm_new_controls(dapm, wm8985_dapm_widgets,\n\t\t\tARRAY_SIZE(wm8985_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, wm8985_aux_dapm_routes,\n\t\t\tARRAY_SIZE(wm8985_aux_dapm_routes));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int eqmode_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM8985_EQ1_LOW_SHELF);\n\tif (reg & WM8985_EQ3DMODE)\n\t\tucontrol->value.enumerated.item[0] = 1;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\n\treturn 0;\n}\n\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int regpwr2, regpwr3;\n\tunsigned int reg_eq;\n\n\tif (ucontrol->value.enumerated.item[0] != 0\n\t\t\t&& ucontrol->value.enumerated.item[0] != 1)\n\t\treturn -EINVAL;\n\n\treg_eq = snd_soc_component_read(component, WM8985_EQ1_LOW_SHELF);\n\tswitch ((reg_eq & WM8985_EQ3DMODE) >> WM8985_EQ3DMODE_SHIFT) {\n\tcase 0:\n\t\tif (!ucontrol->value.enumerated.item[0])\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (ucontrol->value.enumerated.item[0])\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tregpwr2 = snd_soc_component_read(component, WM8985_POWER_MANAGEMENT_2);\n\tregpwr3 = snd_soc_component_read(component, WM8985_POWER_MANAGEMENT_3);\n\t \n\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_2,\n\t\t\t    WM8985_ADCENR_MASK | WM8985_ADCENL_MASK, 0);\n\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_3,\n\t\t\t    WM8985_DACENR_MASK | WM8985_DACENL_MASK, 0);\n\tsnd_soc_component_update_bits(component, WM8985_ADDITIONAL_CONTROL,\n\t\t\t    WM8985_M128ENB_MASK, WM8985_M128ENB);\n\t \n\tsnd_soc_component_update_bits(component, WM8985_EQ1_LOW_SHELF,\n\t\t\t    WM8985_EQ3DMODE_MASK,\n\t\t\t    ucontrol->value.enumerated.item[0]\n\t\t\t    << WM8985_EQ3DMODE_SHIFT);\n\t \n\tsnd_soc_component_write(component, WM8985_POWER_MANAGEMENT_2, regpwr2);\n\tsnd_soc_component_write(component, WM8985_POWER_MANAGEMENT_3, regpwr3);\n\treturn 0;\n}\n\nstatic int wm8985_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8985_SOFTWARE_RESET, 0x0);\n}\n\nstatic int wm8985_dac_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\treturn snd_soc_component_update_bits(component, WM8985_DAC_CONTROL,\n\t\t\t\t   WM8985_SOFTMUTE_MASK,\n\t\t\t\t   !!mute << WM8985_SOFTMUTE_SHIFT);\n}\n\nstatic int wm8985_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component;\n\tu16 format, master, bcp, lrp;\n\n\tcomponent = dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tformat = 0x0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = 0x1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8985_AUDIO_INTERFACE,\n\t\t\t    WM8985_FMT_MASK, format << WM8985_FMT_SHIFT);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t    WM8985_MS_MASK, master << WM8985_MS_SHIFT);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbcp = lrp = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbcp = lrp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbcp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrp = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown polarity configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8985_AUDIO_INTERFACE,\n\t\t\t    WM8985_LRP_MASK, lrp << WM8985_LRP_SHIFT);\n\tsnd_soc_component_update_bits(component, WM8985_AUDIO_INTERFACE,\n\t\t\t    WM8985_BCP_MASK, bcp << WM8985_BCP_SHIFT);\n\treturn 0;\n}\n\nstatic int wm8985_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tint i;\n\tstruct snd_soc_component *component;\n\tstruct wm8985_priv *wm8985;\n\tu16 blen, srate_idx;\n\tunsigned int tmp;\n\tint srate_best;\n\n\tcomponent = dai->component;\n\twm8985 = snd_soc_component_get_drvdata(component);\n\n\twm8985->bclk = snd_soc_params_to_bclk(params);\n\tif ((int)wm8985->bclk < 0)\n\t\treturn wm8985->bclk;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tblen = 0x0;\n\t\tbreak;\n\tcase 20:\n\t\tblen = 0x1;\n\t\tbreak;\n\tcase 24:\n\t\tblen = 0x2;\n\t\tbreak;\n\tcase 32:\n\t\tblen = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported word length %u\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8985_AUDIO_INTERFACE,\n\t\t\t    WM8985_WL_MASK, blen << WM8985_WL_SHIFT);\n\n\t \n\tsrate_idx = 0;\n\tsrate_best = abs(srates[0] - params_rate(params));\n\tfor (i = 1; i < ARRAY_SIZE(srates); ++i) {\n\t\tif (abs(srates[i] - params_rate(params)) >= srate_best)\n\t\t\tcontinue;\n\t\tsrate_idx = i;\n\t\tsrate_best = abs(srates[i] - params_rate(params));\n\t}\n\n\tdev_dbg(dai->dev, \"Selected SRATE = %d\\n\", srates[srate_idx]);\n\tsnd_soc_component_update_bits(component, WM8985_ADDITIONAL_CONTROL,\n\t\t\t    WM8985_SR_MASK, srate_idx << WM8985_SR_SHIFT);\n\n\tdev_dbg(dai->dev, \"Target BCLK = %uHz\\n\", wm8985->bclk);\n\tdev_dbg(dai->dev, \"SYSCLK = %uHz\\n\", wm8985->sysclk);\n\n\tfor (i = 0; i < ARRAY_SIZE(fs_ratios); ++i) {\n\t\tif (wm8985->sysclk / params_rate(params)\n\t\t\t\t== fs_ratios[i].ratio)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(fs_ratios)) {\n\t\tdev_err(dai->dev, \"Unable to configure MCLK ratio %u/%u\\n\",\n\t\t\twm8985->sysclk, params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"MCLK ratio = %dfs\\n\", fs_ratios[i].ratio);\n\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t    WM8985_MCLKDIV_MASK, i << WM8985_MCLKDIV_SHIFT);\n\n\t \n\ttmp = (wm8985->sysclk / fs_ratios[i].div) * 10;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); ++i) {\n\t\tif (wm8985->bclk == tmp / bclk_divs[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(bclk_divs)) {\n\t\tdev_err(dai->dev, \"No matching BCLK divider found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"BCLK div = %d\\n\", i);\n\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t    WM8985_BCLKDIV_MASK, i << WM8985_BCLKDIV_SHIFT);\n\treturn 0;\n}\n\nstruct pll_div {\n\tu32 div2:1;\n\tu32 n:4;\n\tu32 k:24;\n};\n\n#define FIXED_PLL_SIZE ((1ULL << 24) * 10)\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\n\t\t       unsigned int source)\n{\n\tu64 Kpart;\n\tunsigned long int K, Ndiv, Nmod;\n\n\tpll_div->div2 = 0;\n\tNdiv = target / source;\n\tif (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\tpll_div->div2 = 1;\n\t\tNdiv = target / source;\n\t}\n\n\tif (Ndiv < 6 || Ndiv > 12) {\n\t\tprintk(KERN_ERR \"%s: WM8985 N value is not within\"\n\t\t       \" the recommended range: %lu\\n\", __func__, Ndiv);\n\t\treturn -EINVAL;\n\t}\n\tpll_div->n = Ndiv;\n\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (u64)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xffffffff;\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\tK /= 10;\n\tpll_div->k = K;\n\n\treturn 0;\n}\n\nstatic int wm8985_set_pll(struct snd_soc_dai *dai, int pll_id,\n\t\t\t  int source, unsigned int freq_in,\n\t\t\t  unsigned int freq_out)\n{\n\tint ret;\n\tstruct snd_soc_component *component;\n\tstruct pll_div pll_div;\n\n\tcomponent = dai->component;\n\tif (!freq_in || !freq_out) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_PLLEN_MASK, 0);\n\t} else {\n\t\tret = pll_factors(&pll_div, freq_out * 4 * 2, freq_in);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tsnd_soc_component_write(component, WM8985_PLL_N,\n\t\t\t      (pll_div.div2 << WM8985_PLL_PRESCALE_SHIFT)\n\t\t\t      | pll_div.n);\n\t\t \n\t\tsnd_soc_component_write(component, WM8985_PLL_K_3, pll_div.k & 0x1ff);\n\t\tsnd_soc_component_write(component, WM8985_PLL_K_2, (pll_div.k >> 9) & 0x1ff);\n\t\tsnd_soc_component_write(component, WM8985_PLL_K_1, (pll_div.k >> 18));\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t\t    WM8985_CLKSEL_MASK, WM8985_CLKSEL);\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_PLLEN_MASK, WM8985_PLLEN);\n\t}\n\treturn 0;\n}\n\nstatic int wm8985_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8985_priv *wm8985;\n\n\tcomponent = dai->component;\n\twm8985 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM8985_CLKSRC_MCLK:\n\t\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t\t    WM8985_CLKSEL_MASK, 0);\n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_PLLEN_MASK, 0);\n\t\tbreak;\n\tcase WM8985_CLKSRC_PLL:\n\t\tsnd_soc_component_update_bits(component, WM8985_CLOCK_GEN_CONTROL,\n\t\t\t\t    WM8985_CLKSEL_MASK, WM8985_CLKSEL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown clock source %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\twm8985->sysclk = freq;\n\treturn 0;\n}\n\nstatic int wm8985_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tint ret;\n\tstruct wm8985_priv *wm8985;\n\n\twm8985 = snd_soc_component_get_drvdata(component);\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_VMIDSEL_MASK,\n\t\t\t\t    1 << WM8985_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8985->supplies),\n\t\t\t\t\t\t    wm8985->supplies);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tregcache_sync(wm8985->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8985_OUT4_TO_ADC,\n\t\t\t\t\t    WM8985_POBCTRL_MASK,\n\t\t\t\t\t    WM8985_POBCTRL);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8985_OUTPUT_CTRL0,\n\t\t\t\t\t    WM8985_TSDEN_MASK, WM8985_TSDEN);\n\t\t\tsnd_soc_component_update_bits(component, WM8985_OUTPUT_CTRL0,\n\t\t\t\t\t    WM8985_TSOPCTRL_MASK,\n\t\t\t\t\t    WM8985_TSOPCTRL);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8985_BIASEN_MASK, WM8985_BIASEN);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8985_VMIDSEL_MASK,\n\t\t\t\t\t    1 << WM8985_VMIDSEL_SHIFT);\n\t\t\tmsleep(500);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8985_OUT4_TO_ADC,\n\t\t\t\t\t    WM8985_POBCTRL_MASK, 0);\n\t\t}\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_VMIDSEL_MASK,\n\t\t\t\t    2 << WM8985_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_OUTPUT_CTRL0,\n\t\t\t\t    WM8985_TSOPCTRL_MASK, 0);\n\t\tsnd_soc_component_update_bits(component, WM8985_OUTPUT_CTRL0,\n\t\t\t\t    WM8985_TSDEN_MASK, 0);\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8985_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8985_VMIDSEL_MASK | WM8985_BIASEN_MASK,\n\t\t\t\t    0);\n\t\tsnd_soc_component_write(component, WM8985_POWER_MANAGEMENT_1, 0);\n\t\tsnd_soc_component_write(component, WM8985_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_component_write(component, WM8985_POWER_MANAGEMENT_3, 0);\n\n\t\tregcache_mark_dirty(wm8985->regmap);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8985->supplies),\n\t\t\t\t       wm8985->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8985_probe(struct snd_soc_component *component)\n{\n\tsize_t i;\n\tstruct wm8985_priv *wm8985;\n\tint ret;\n\n\twm8985 = snd_soc_component_get_drvdata(component);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8985->supplies); i++)\n\t\twm8985->supplies[i].supply = wm8985_supply_names[i];\n\n\tret = devm_regulator_bulk_get(component->dev, ARRAY_SIZE(wm8985->supplies),\n\t\t\t\t wm8985->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8985->supplies),\n\t\t\t\t    wm8985->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8985_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(volume_update_regs); ++i)\n\t\tsnd_soc_component_update_bits(component, volume_update_regs[i],\n\t\t\t\t    0x100, 0x100);\n\t \n\tsnd_soc_component_update_bits(component, WM8985_BIAS_CTRL, WM8985_BIASCUT,\n\t\t\t    WM8985_BIASCUT);\n\n\twm8985_add_widgets(component);\n\n\treturn 0;\n\nerr_reg_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8985->supplies), wm8985->supplies);\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops wm8985_dai_ops = {\n\t.mute_stream = wm8985_dac_mute,\n\t.hw_params = wm8985_hw_params,\n\t.set_fmt = wm8985_set_fmt,\n\t.set_sysclk = wm8985_set_sysclk,\n\t.set_pll = wm8985_set_pll,\n\t.no_capture_mute = 1,\n};\n\n#define WM8985_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver wm8985_dai = {\n\t.name = \"wm8985-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8985_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8985_FORMATS,\n\t},\n\t.ops = &wm8985_dai_ops,\n\t.symmetric_rate = 1\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8985 = {\n\t.probe\t\t\t= wm8985_probe,\n\t.set_bias_level\t\t= wm8985_set_bias_level,\n\t.controls\t\t= wm8985_common_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8985_common_snd_controls),\n\t.dapm_widgets\t\t= wm8985_common_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8985_common_dapm_widgets),\n\t.dapm_routes\t\t= wm8985_common_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8985_common_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8985_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8985_MAX_REGISTER,\n\t.writeable_reg = wm8985_writeable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8985_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8985_reg_defaults),\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8985_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8985_priv *wm8985;\n\tint ret;\n\n\twm8985 = devm_kzalloc(&spi->dev, sizeof *wm8985, GFP_KERNEL);\n\tif (!wm8985)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, wm8985);\n\n\twm8985->dev_type = WM8985;\n\n\twm8985->regmap = devm_regmap_init_spi(spi, &wm8985_regmap);\n\tif (IS_ERR(wm8985->regmap)) {\n\t\tret = PTR_ERR(wm8985->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t     &soc_component_dev_wm8985, &wm8985_dai, 1);\n\treturn ret;\n}\n\nstatic struct spi_driver wm8985_spi_driver = {\n\t.driver = {\n\t\t.name = \"wm8985\",\n\t},\n\t.probe = wm8985_spi_probe,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic const struct i2c_device_id wm8985_i2c_id[];\n\nstatic int wm8985_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8985_priv *wm8985;\n\tconst struct i2c_device_id *id = i2c_match_id(wm8985_i2c_id, i2c);\n\tint ret;\n\n\twm8985 = devm_kzalloc(&i2c->dev, sizeof *wm8985, GFP_KERNEL);\n\tif (!wm8985)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm8985);\n\n\twm8985->dev_type = id->driver_data;\n\n\twm8985->regmap = devm_regmap_init_i2c(i2c, &wm8985_regmap);\n\tif (IS_ERR(wm8985->regmap)) {\n\t\tret = PTR_ERR(wm8985->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_wm8985, &wm8985_dai, 1);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8985_i2c_id[] = {\n\t{ \"wm8985\", WM8985 },\n\t{ \"wm8758\", WM8758 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8985_i2c_id);\n\nstatic struct i2c_driver wm8985_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8985\",\n\t},\n\t.probe = wm8985_i2c_probe,\n\t.id_table = wm8985_i2c_id\n};\n#endif\n\nstatic int __init wm8985_modinit(void)\n{\n\tint ret = 0;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8985_i2c_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Failed to register wm8985 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8985_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8985 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\nmodule_init(wm8985_modinit);\n\nstatic void __exit wm8985_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8985_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8985_spi_driver);\n#endif\n}\nmodule_exit(wm8985_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8985 / WM8758 driver\");\nMODULE_AUTHOR(\"Dimitris Papastamos <dp@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}