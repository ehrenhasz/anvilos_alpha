{
  "module_name": "audio-iio-aux.c",
  "hash_id": "33cf8dc88dbee8ffe3b4575709b05d7c1152933b5775a4bbed232c627cece423",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/audio-iio-aux.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/iio/consumer.h>\n#include <linux/minmax.h>\n#include <linux/mod_devicetable.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/string_helpers.h>\n\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\nstruct audio_iio_aux_chan {\n\tstruct iio_channel *iio_chan;\n\tconst char *name;\n\tint max;\n\tint min;\n\tbool is_invert_range;\n};\n\nstruct audio_iio_aux {\n\tstruct device *dev;\n\tstruct audio_iio_aux_chan *chans;\n\tunsigned int num_chans;\n};\n\nstatic int audio_iio_aux_info_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_info *uinfo)\n{\n\tstruct audio_iio_aux_chan *chan = (struct audio_iio_aux_chan *)kcontrol->private_value;\n\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = chan->max - chan->min;\n\tuinfo->type = (uinfo->value.integer.max == 1) ?\n\t\t\tSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\n\treturn 0;\n}\n\nstatic int audio_iio_aux_get_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct audio_iio_aux_chan *chan = (struct audio_iio_aux_chan *)kcontrol->private_value;\n\tint max = chan->max;\n\tint min = chan->min;\n\tbool invert_range = chan->is_invert_range;\n\tint ret;\n\tint val;\n\n\tret = iio_read_channel_raw(chan->iio_chan, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tucontrol->value.integer.value[0] = val - min;\n\tif (invert_range)\n\t\tucontrol->value.integer.value[0] = max - ucontrol->value.integer.value[0];\n\n\treturn 0;\n}\n\nstatic int audio_iio_aux_put_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct audio_iio_aux_chan *chan = (struct audio_iio_aux_chan *)kcontrol->private_value;\n\tint max = chan->max;\n\tint min = chan->min;\n\tbool invert_range = chan->is_invert_range;\n\tint val;\n\tint ret;\n\tint tmp;\n\n\tval = ucontrol->value.integer.value[0];\n\tif (val < 0)\n\t\treturn -EINVAL;\n\tif (val > max - min)\n\t\treturn -EINVAL;\n\n\tval = val + min;\n\tif (invert_range)\n\t\tval = max - val;\n\n\tret = iio_read_channel_raw(chan->iio_chan, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tmp == val)\n\t\treturn 0;\n\n\tret = iio_write_channel_raw(chan->iio_chan, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 1;  \n}\n\nstatic int audio_iio_aux_add_controls(struct snd_soc_component *component,\n\t\t\t\t      struct audio_iio_aux_chan *chan)\n{\n\tstruct snd_kcontrol_new control = {\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = chan->name,\n\t\t.info = audio_iio_aux_info_volsw,\n\t\t.get = audio_iio_aux_get_volsw,\n\t\t.put = audio_iio_aux_put_volsw,\n\t\t.private_value = (unsigned long)chan,\n\t};\n\n\treturn snd_soc_add_component_controls(component, &control, 1);\n}\n\n \nstatic struct snd_soc_dapm_widget widgets[3];\nstatic struct snd_soc_dapm_route routes[2];\n\n \nstatic_assert(ARRAY_SIZE(widgets) >= 3, \"3 widgets are needed\");\nstatic_assert(ARRAY_SIZE(routes) >= 2, \"2 routes are needed\");\n\nstatic int audio_iio_aux_add_dapms(struct snd_soc_component *component,\n\t\t\t\t   struct audio_iio_aux_chan *chan)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tchar *output_name;\n\tchar *input_name;\n\tchar *pga_name;\n\tint ret;\n\n\tinput_name = kasprintf(GFP_KERNEL, \"%s IN\", chan->name);\n\tif (!input_name)\n\t\treturn -ENOMEM;\n\n\toutput_name = kasprintf(GFP_KERNEL, \"%s OUT\", chan->name);\n\tif (!output_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_input_name;\n\t}\n\n\tpga_name = kasprintf(GFP_KERNEL, \"%s PGA\", chan->name);\n\tif (!pga_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_output_name;\n\t}\n\n\twidgets[0] = SND_SOC_DAPM_INPUT(input_name);\n\twidgets[1] = SND_SOC_DAPM_OUTPUT(output_name);\n\twidgets[2] = SND_SOC_DAPM_PGA(pga_name, SND_SOC_NOPM, 0, 0, NULL, 0);\n\tret = snd_soc_dapm_new_controls(dapm, widgets, 3);\n\tif (ret)\n\t\tgoto out_free_pga_name;\n\n\troutes[0].sink = pga_name;\n\troutes[0].control = NULL;\n\troutes[0].source = input_name;\n\troutes[1].sink = output_name;\n\troutes[1].control = NULL;\n\troutes[1].source = pga_name;\n\tret = snd_soc_dapm_add_routes(dapm, routes, 2);\n\n\t \n\nout_free_pga_name:\n\tkfree(pga_name);\nout_free_output_name:\n\tkfree(output_name);\nout_free_input_name:\n\tkfree(input_name);\n\treturn ret;\n}\n\nstatic int audio_iio_aux_component_probe(struct snd_soc_component *component)\n{\n\tstruct audio_iio_aux *iio_aux = snd_soc_component_get_drvdata(component);\n\tstruct audio_iio_aux_chan *chan;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < iio_aux->num_chans; i++) {\n\t\tchan = iio_aux->chans + i;\n\n\t\tret = iio_read_max_channel_raw(chan->iio_chan, &chan->max);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(component->dev, ret,\n\t\t\t\t\t     \"chan[%d] %s: Cannot get max raw value\\n\",\n\t\t\t\t\t     i, chan->name);\n\n\t\tret = iio_read_min_channel_raw(chan->iio_chan, &chan->min);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(component->dev, ret,\n\t\t\t\t\t     \"chan[%d] %s: Cannot get min raw value\\n\",\n\t\t\t\t\t     i, chan->name);\n\n\t\tif (chan->min > chan->max) {\n\t\t\t \n\t\t\tdev_dbg(component->dev, \"chan[%d] %s: Swap min and max\\n\",\n\t\t\t\ti, chan->name);\n\t\t\tswap(chan->min, chan->max);\n\t\t}\n\n\t\t \n\t\tret = iio_write_channel_raw(chan->iio_chan,\n\t\t\t\t\t    chan->is_invert_range ? chan->max : chan->min);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(component->dev, ret,\n\t\t\t\t\t     \"chan[%d] %s: Cannot set initial value\\n\",\n\t\t\t\t\t     i, chan->name);\n\n\t\tret = audio_iio_aux_add_controls(component, chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = audio_iio_aux_add_dapms(component, chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(component->dev, \"chan[%d]: Added %s (min=%d, max=%d, invert=%s)\\n\",\n\t\t\ti, chan->name, chan->min, chan->max,\n\t\t\tstr_on_off(chan->is_invert_range));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver audio_iio_aux_component_driver = {\n\t.probe = audio_iio_aux_component_probe,\n};\n\nstatic int audio_iio_aux_probe(struct platform_device *pdev)\n{\n\tstruct audio_iio_aux_chan *iio_aux_chan;\n\tstruct device *dev = &pdev->dev;\n\tstruct audio_iio_aux *iio_aux;\n\tconst char **names;\n\tu32 *invert_ranges;\n\tint count;\n\tint ret;\n\tint i;\n\n\tiio_aux = devm_kzalloc(dev, sizeof(*iio_aux), GFP_KERNEL);\n\tif (!iio_aux)\n\t\treturn -ENOMEM;\n\n\tiio_aux->dev = dev;\n\n\tcount = device_property_string_array_count(dev, \"io-channel-names\");\n\tif (count < 0)\n\t\treturn dev_err_probe(dev, count, \"failed to count io-channel-names\\n\");\n\n\tiio_aux->num_chans = count;\n\n\tiio_aux->chans = devm_kmalloc_array(dev, iio_aux->num_chans,\n\t\t\t\t\t    sizeof(*iio_aux->chans), GFP_KERNEL);\n\tif (!iio_aux->chans)\n\t\treturn -ENOMEM;\n\n\tnames = kcalloc(iio_aux->num_chans, sizeof(*names), GFP_KERNEL);\n\tif (!names)\n\t\treturn -ENOMEM;\n\n\tinvert_ranges = kcalloc(iio_aux->num_chans, sizeof(*invert_ranges), GFP_KERNEL);\n\tif (!invert_ranges) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_names;\n\t}\n\n\tret = device_property_read_string_array(dev, \"io-channel-names\",\n\t\t\t\t\t\tnames, iio_aux->num_chans);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"failed to read io-channel-names\\n\");\n\t\tgoto out_free_invert_ranges;\n\t}\n\n\t \n\tcount = device_property_count_u32(dev, \"snd-control-invert-range\");\n\tif (count > 0) {\n\t\tcount = min_t(unsigned int, count, iio_aux->num_chans);\n\t\tret = device_property_read_u32_array(dev, \"snd-control-invert-range\",\n\t\t\t\t\t\t     invert_ranges, count);\n\t\tif (ret < 0) {\n\t\t\tdev_err_probe(dev, ret, \"failed to read snd-control-invert-range\\n\");\n\t\t\tgoto out_free_invert_ranges;\n\t\t}\n\t}\n\n\tfor (i = 0; i < iio_aux->num_chans; i++) {\n\t\tiio_aux_chan = iio_aux->chans + i;\n\t\tiio_aux_chan->name = names[i];\n\t\tiio_aux_chan->is_invert_range = invert_ranges[i];\n\n\t\tiio_aux_chan->iio_chan = devm_iio_channel_get(dev, iio_aux_chan->name);\n\t\tif (IS_ERR(iio_aux_chan->iio_chan)) {\n\t\t\tret = PTR_ERR(iio_aux_chan->iio_chan);\n\t\t\tdev_err_probe(dev, ret, \"get IIO channel '%s' failed\\n\",\n\t\t\t\t      iio_aux_chan->name);\n\t\t\tgoto out_free_invert_ranges;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, iio_aux);\n\n\tret = devm_snd_soc_register_component(dev, &audio_iio_aux_component_driver,\n\t\t\t\t\t      NULL, 0);\nout_free_invert_ranges:\n\tkfree(invert_ranges);\nout_free_names:\n\tkfree(names);\n\treturn ret;\n}\n\nstatic const struct of_device_id audio_iio_aux_ids[] = {\n\t{ .compatible = \"audio-iio-aux\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, audio_iio_aux_ids);\n\nstatic struct platform_driver audio_iio_aux_driver = {\n\t.driver = {\n\t\t.name = \"audio-iio-aux\",\n\t\t.of_match_table = audio_iio_aux_ids,\n\t},\n\t.probe = audio_iio_aux_probe,\n};\nmodule_platform_driver(audio_iio_aux_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"IIO ALSA SoC aux driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}