{
  "module_name": "cs35l35.c",
  "hash_id": "f16116e587c128c13950219e637d92347378c17dd561f44fbfe1f76380efdd80",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l35.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <linux/gpio.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/cs35l35.h>\n#include <linux/of_irq.h>\n#include <linux/completion.h>\n\n#include \"cs35l35.h\"\n#include \"cirrus_legacy.h\"\n\n \n#define CS35L35_VALID_PDATA 0x80000000\n\nstatic const struct reg_default cs35l35_reg[] = {\n\t{CS35L35_PWRCTL1,\t\t0x01},\n\t{CS35L35_PWRCTL2,\t\t0x11},\n\t{CS35L35_PWRCTL3,\t\t0x00},\n\t{CS35L35_CLK_CTL1,\t\t0x04},\n\t{CS35L35_CLK_CTL2,\t\t0x12},\n\t{CS35L35_CLK_CTL3,\t\t0xCF},\n\t{CS35L35_SP_FMT_CTL1,\t\t0x20},\n\t{CS35L35_SP_FMT_CTL2,\t\t0x00},\n\t{CS35L35_SP_FMT_CTL3,\t\t0x02},\n\t{CS35L35_MAG_COMP_CTL,\t\t0x00},\n\t{CS35L35_AMP_INP_DRV_CTL,\t0x01},\n\t{CS35L35_AMP_DIG_VOL_CTL,\t0x12},\n\t{CS35L35_AMP_DIG_VOL,\t\t0x00},\n\t{CS35L35_ADV_DIG_VOL,\t\t0x00},\n\t{CS35L35_PROTECT_CTL,\t\t0x06},\n\t{CS35L35_AMP_GAIN_AUD_CTL,\t0x13},\n\t{CS35L35_AMP_GAIN_PDM_CTL,\t0x00},\n\t{CS35L35_AMP_GAIN_ADV_CTL,\t0x00},\n\t{CS35L35_GPI_CTL,\t\t0x00},\n\t{CS35L35_BST_CVTR_V_CTL,\t0x00},\n\t{CS35L35_BST_PEAK_I,\t\t0x07},\n\t{CS35L35_BST_RAMP_CTL,\t\t0x85},\n\t{CS35L35_BST_CONV_COEF_1,\t0x24},\n\t{CS35L35_BST_CONV_COEF_2,\t0x24},\n\t{CS35L35_BST_CONV_SLOPE_COMP,\t0x4E},\n\t{CS35L35_BST_CONV_SW_FREQ,\t0x04},\n\t{CS35L35_CLASS_H_CTL,\t\t0x0B},\n\t{CS35L35_CLASS_H_HEADRM_CTL,\t0x0B},\n\t{CS35L35_CLASS_H_RELEASE_RATE,\t0x08},\n\t{CS35L35_CLASS_H_FET_DRIVE_CTL, 0x41},\n\t{CS35L35_CLASS_H_VP_CTL,\t0xC5},\n\t{CS35L35_VPBR_CTL,\t\t0x0A},\n\t{CS35L35_VPBR_VOL_CTL,\t\t0x90},\n\t{CS35L35_VPBR_TIMING_CTL,\t0x6A},\n\t{CS35L35_VPBR_MODE_VOL_CTL,\t0x00},\n\t{CS35L35_SPKR_MON_CTL,\t\t0xC0},\n\t{CS35L35_IMON_SCALE_CTL,\t0x30},\n\t{CS35L35_AUDIN_RXLOC_CTL,\t0x00},\n\t{CS35L35_ADVIN_RXLOC_CTL,\t0x80},\n\t{CS35L35_VMON_TXLOC_CTL,\t0x00},\n\t{CS35L35_IMON_TXLOC_CTL,\t0x80},\n\t{CS35L35_VPMON_TXLOC_CTL,\t0x04},\n\t{CS35L35_VBSTMON_TXLOC_CTL,\t0x84},\n\t{CS35L35_VPBR_STATUS_TXLOC_CTL,\t0x04},\n\t{CS35L35_ZERO_FILL_LOC_CTL,\t0x00},\n\t{CS35L35_AUDIN_DEPTH_CTL,\t0x0F},\n\t{CS35L35_SPKMON_DEPTH_CTL,\t0x0F},\n\t{CS35L35_SUPMON_DEPTH_CTL,\t0x0F},\n\t{CS35L35_ZEROFILL_DEPTH_CTL,\t0x00},\n\t{CS35L35_MULT_DEV_SYNCH1,\t0x02},\n\t{CS35L35_MULT_DEV_SYNCH2,\t0x80},\n\t{CS35L35_PROT_RELEASE_CTL,\t0x00},\n\t{CS35L35_DIAG_MODE_REG_LOCK,\t0x00},\n\t{CS35L35_DIAG_MODE_CTL_1,\t0x40},\n\t{CS35L35_DIAG_MODE_CTL_2,\t0x00},\n\t{CS35L35_INT_MASK_1,\t\t0xFF},\n\t{CS35L35_INT_MASK_2,\t\t0xFF},\n\t{CS35L35_INT_MASK_3,\t\t0xFF},\n\t{CS35L35_INT_MASK_4,\t\t0xFF},\n\n};\n\nstatic bool cs35l35_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L35_INT_STATUS_1:\n\tcase CS35L35_INT_STATUS_2:\n\tcase CS35L35_INT_STATUS_3:\n\tcase CS35L35_INT_STATUS_4:\n\tcase CS35L35_PLL_STATUS:\n\tcase CS35L35_OTP_TRIM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l35_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L35_DEVID_AB ... CS35L35_PWRCTL3:\n\tcase CS35L35_CLK_CTL1 ... CS35L35_SP_FMT_CTL3:\n\tcase CS35L35_MAG_COMP_CTL ... CS35L35_AMP_GAIN_AUD_CTL:\n\tcase CS35L35_AMP_GAIN_PDM_CTL ... CS35L35_BST_PEAK_I:\n\tcase CS35L35_BST_RAMP_CTL ... CS35L35_BST_CONV_SW_FREQ:\n\tcase CS35L35_CLASS_H_CTL ... CS35L35_CLASS_H_VP_CTL:\n\tcase CS35L35_CLASS_H_STATUS:\n\tcase CS35L35_VPBR_CTL ... CS35L35_VPBR_MODE_VOL_CTL:\n\tcase CS35L35_VPBR_ATTEN_STATUS:\n\tcase CS35L35_SPKR_MON_CTL:\n\tcase CS35L35_IMON_SCALE_CTL ... CS35L35_ZEROFILL_DEPTH_CTL:\n\tcase CS35L35_MULT_DEV_SYNCH1 ... CS35L35_PROT_RELEASE_CTL:\n\tcase CS35L35_DIAG_MODE_REG_LOCK ... CS35L35_DIAG_MODE_CTL_2:\n\tcase CS35L35_INT_MASK_1 ... CS35L35_PLL_STATUS:\n\tcase CS35L35_OTP_TRIM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs35l35_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS35L35_INT_STATUS_1:\n\tcase CS35L35_INT_STATUS_2:\n\tcase CS35L35_INT_STATUS_3:\n\tcase CS35L35_INT_STATUS_4:\n\tcase CS35L35_PLL_STATUS:\n\tcase CS35L35_OTP_TRIM_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void cs35l35_reset(struct cs35l35_private *cs35l35)\n{\n\tgpiod_set_value_cansleep(cs35l35->reset_gpio, 0);\n\tusleep_range(2000, 2100);\n\tgpiod_set_value_cansleep(cs35l35->reset_gpio, 1);\n\tusleep_range(1000, 1100);\n}\n\nstatic int cs35l35_wait_for_pdn(struct cs35l35_private *cs35l35)\n{\n\tint ret;\n\n\tif (cs35l35->pdata.ext_bst) {\n\t\tusleep_range(5000, 5500);\n\t\treturn 0;\n\t}\n\n\treinit_completion(&cs35l35->pdn_done);\n\n\tret = wait_for_completion_timeout(&cs35l35->pdn_done,\n\t\t\t\t\t  msecs_to_jiffies(100));\n\tif (ret == 0) {\n\t\tdev_err(cs35l35->dev, \"PDN_DONE did not complete\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l35_sdin_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\t\tCS35L35_MCLK_DIS_MASK,\n\t\t\t\t\t0 << CS35L35_MCLK_DIS_SHIFT);\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\t\t\tCS35L35_DISCHG_FILT_MASK,\n\t\t\t\t\t0 << CS35L35_DISCHG_FILT_SHIFT);\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\t\t\tCS35L35_PDN_ALL_MASK, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\t\t\tCS35L35_DISCHG_FILT_MASK,\n\t\t\t\t\t1 << CS35L35_DISCHG_FILT_SHIFT);\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\t\t\t  CS35L35_PDN_ALL_MASK, 1);\n\n\t\t \n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_AMP_DIG_VOL_CTL,\n\t\t\t\t   CS35L35_AMP_DIGSFT_MASK, 0);\n\n\t\tret = cs35l35_wait_for_pdn(cs35l35);\n\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\t\tCS35L35_MCLK_DIS_MASK,\n\t\t\t\t\t1 << CS35L35_MCLK_DIS_SHIFT);\n\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_AMP_DIG_VOL_CTL,\n\t\t\t\t   CS35L35_AMP_DIGSFT_MASK,\n\t\t\t\t   1 << CS35L35_AMP_DIGSFT_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int cs35l35_main_amp_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg[4];\n\tint i;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (cs35l35->pdata.bst_pdn_fet_on)\n\t\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t0 << CS35L35_PDN_BST_FETON_SHIFT);\n\t\telse\n\t\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t0 << CS35L35_PDN_BST_FETOFF_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tusleep_range(5000, 5100);\n\t\t \n\t\tif (cs35l35->pdm_mode)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_BST_CVTR_V_CTL,\n\t\t\t\t\tCS35L35_BST_CTL_MASK,\n\t\t\t\t\t0 << CS35L35_BST_CTL_SHIFT);\n\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PROTECT_CTL,\n\t\t\tCS35L35_AMP_MUTE_MASK, 0);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tregmap_bulk_read(cs35l35->regmap, CS35L35_INT_STATUS_1,\n\t\t\t\t\t&reg, ARRAY_SIZE(reg));\n\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PROTECT_CTL,\n\t\t\t\tCS35L35_AMP_MUTE_MASK,\n\t\t\t\t1 << CS35L35_AMP_MUTE_SHIFT);\n\t\tif (cs35l35->pdata.bst_pdn_fet_on)\n\t\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t1 << CS35L35_PDN_BST_FETON_SHIFT);\n\t\telse\n\t\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t1 << CS35L35_PDN_BST_FETOFF_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tusleep_range(5000, 5100);\n\t\t \n\t\tif (cs35l35->pdm_mode)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_BST_CVTR_V_CTL,\n\t\t\t\t\tCS35L35_BST_CTL_MASK,\n\t\t\t\t\tcs35l35->pdata.bst_vctl\n\t\t\t\t\t<< CS35L35_BST_CTL_SHIFT);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t}\n\treturn 0;\n}\n\nstatic DECLARE_TLV_DB_SCALE(amp_gain_tlv, 0, 1, 1);\nstatic DECLARE_TLV_DB_SCALE(dig_vol_tlv, -10200, 50, 0);\n\nstatic const struct snd_kcontrol_new cs35l35_aud_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"Digital Audio Volume\", CS35L35_AMP_DIG_VOL,\n\t\t      0, 0x34, 0xE4, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Analog Audio Volume\", CS35L35_AMP_GAIN_AUD_CTL, 0, 19, 0,\n\t\t\tamp_gain_tlv),\n\tSOC_SINGLE_TLV(\"PDM Volume\", CS35L35_AMP_GAIN_PDM_CTL, 0, 19, 0,\n\t\t\tamp_gain_tlv),\n};\n\nstatic const struct snd_kcontrol_new cs35l35_adv_controls[] = {\n\tSOC_SINGLE_SX_TLV(\"Digital Advisory Volume\", CS35L35_ADV_DIG_VOL,\n\t\t      0, 0x34, 0xE4, dig_vol_tlv),\n\tSOC_SINGLE_TLV(\"Analog Advisory Volume\", CS35L35_AMP_GAIN_ADV_CTL, 0, 19, 0,\n\t\t\tamp_gain_tlv),\n};\n\nstatic const struct snd_soc_dapm_widget cs35l35_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN_E(\"SDIN\", NULL, 0, CS35L35_PWRCTL3, 1, 1,\n\t\t\t\tcs35l35_sdin_event, SND_SOC_DAPM_PRE_PMU |\n\t\t\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_AIF_OUT(\"SDOUT\", NULL, 0, CS35L35_PWRCTL3, 2, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\n\tSND_SOC_DAPM_INPUT(\"VP\"),\n\tSND_SOC_DAPM_INPUT(\"VBST\"),\n\tSND_SOC_DAPM_INPUT(\"ISENSE\"),\n\tSND_SOC_DAPM_INPUT(\"VSENSE\"),\n\n\tSND_SOC_DAPM_ADC(\"VMON ADC\", NULL, CS35L35_PWRCTL2, 7, 1),\n\tSND_SOC_DAPM_ADC(\"IMON ADC\", NULL, CS35L35_PWRCTL2, 6, 1),\n\tSND_SOC_DAPM_ADC(\"VPMON ADC\", NULL, CS35L35_PWRCTL3, 3, 1),\n\tSND_SOC_DAPM_ADC(\"VBSTMON ADC\", NULL, CS35L35_PWRCTL3, 4, 1),\n\tSND_SOC_DAPM_ADC(\"CLASS H\", NULL, CS35L35_PWRCTL2, 5, 1),\n\n\tSND_SOC_DAPM_OUT_DRV_E(\"Main AMP\", CS35L35_PWRCTL2, 0, 1, NULL, 0,\n\t\tcs35l35_main_amp_event, SND_SOC_DAPM_PRE_PMU |\n\t\t\t\tSND_SOC_DAPM_POST_PMD | SND_SOC_DAPM_POST_PMU |\n\t\t\t\tSND_SOC_DAPM_PRE_PMD),\n};\n\nstatic const struct snd_soc_dapm_route cs35l35_audio_map[] = {\n\t{\"VPMON ADC\", NULL, \"VP\"},\n\t{\"VBSTMON ADC\", NULL, \"VBST\"},\n\t{\"IMON ADC\", NULL, \"ISENSE\"},\n\t{\"VMON ADC\", NULL, \"VSENSE\"},\n\t{\"SDOUT\", NULL, \"IMON ADC\"},\n\t{\"SDOUT\", NULL, \"VMON ADC\"},\n\t{\"SDOUT\", NULL, \"VBSTMON ADC\"},\n\t{\"SDOUT\", NULL, \"VPMON ADC\"},\n\t{\"AMP Capture\", NULL, \"SDOUT\"},\n\n\t{\"SDIN\", NULL, \"AMP Playback\"},\n\t{\"CLASS H\", NULL, \"SDIN\"},\n\t{\"Main AMP\", NULL, \"CLASS H\"},\n\t{\"SPK\", NULL, \"Main AMP\"},\n};\n\nstatic int cs35l35_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\t    CS35L35_MS_MASK, 1 << CS35L35_MS_SHIFT);\n\t\tcs35l35->clock_consumer = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\t    CS35L35_MS_MASK, 0 << CS35L35_MS_SHIFT);\n\t\tcs35l35->clock_consumer = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcs35l35->i2s_mode = true;\n\t\tcs35l35->pdm_mode = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_PDM:\n\t\tcs35l35->pdm_mode = true;\n\t\tcs35l35->i2s_mode = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct cs35l35_sysclk_config {\n\tint sysclk;\n\tint srate;\n\tu8 clk_cfg;\n};\n\nstatic struct cs35l35_sysclk_config cs35l35_clk_ctl[] = {\n\n\t \n\t{5644800, 44100, 0x00},\n\t{5644800, 88200, 0x40},\n\t{6144000, 48000, 0x10},\n\t{6144000, 96000, 0x50},\n\t{11289600, 44100, 0x01},\n\t{11289600, 88200, 0x41},\n\t{11289600, 176400, 0x81},\n\t{12000000, 44100, 0x03},\n\t{12000000, 48000, 0x13},\n\t{12000000, 88200, 0x43},\n\t{12000000, 96000, 0x53},\n\t{12000000, 176400, 0x83},\n\t{12000000, 192000, 0x93},\n\t{12288000, 48000, 0x11},\n\t{12288000, 96000, 0x51},\n\t{12288000, 192000, 0x91},\n\t{13000000, 44100, 0x07},\n\t{13000000, 48000, 0x17},\n\t{13000000, 88200, 0x47},\n\t{13000000, 96000, 0x57},\n\t{13000000, 176400, 0x87},\n\t{13000000, 192000, 0x97},\n\t{22579200, 44100, 0x02},\n\t{22579200, 88200, 0x42},\n\t{22579200, 176400, 0x82},\n\t{24000000, 44100, 0x0B},\n\t{24000000, 48000, 0x1B},\n\t{24000000, 88200, 0x4B},\n\t{24000000, 96000, 0x5B},\n\t{24000000, 176400, 0x8B},\n\t{24000000, 192000, 0x9B},\n\t{24576000, 48000, 0x12},\n\t{24576000, 96000, 0x52},\n\t{24576000, 192000, 0x92},\n\t{26000000, 44100, 0x0F},\n\t{26000000, 48000, 0x1F},\n\t{26000000, 88200, 0x4F},\n\t{26000000, 96000, 0x5F},\n\t{26000000, 176400, 0x8F},\n\t{26000000, 192000, 0x9F},\n};\n\nstatic int cs35l35_get_clk_config(int sysclk, int srate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l35_clk_ctl); i++) {\n\t\tif (cs35l35_clk_ctl[i].sysclk == sysclk &&\n\t\t\tcs35l35_clk_ctl[i].srate == srate)\n\t\t\treturn cs35l35_clk_ctl[i].clk_cfg;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int cs35l35_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\tstruct classh_cfg *classh = &cs35l35->pdata.classh_algo;\n\tint srate = params_rate(params);\n\tint ret = 0;\n\tu8 sp_sclks;\n\tint audin_format;\n\tint errata_chk;\n\n\tint clk_ctl = cs35l35_get_clk_config(cs35l35->sysclk, srate);\n\n\tif (clk_ctl < 0) {\n\t\tdev_err(component->dev, \"Invalid CLK:Rate %d:%d\\n\",\n\t\t\tcs35l35->sysclk, srate);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL2,\n\t\t\t  CS35L35_CLK_CTL2_MASK, clk_ctl);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set port config %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\terrata_chk = (clk_ctl & CS35L35_SP_RATE_MASK) >> CS35L35_SP_RATE_SHIFT;\n\n\tif (classh->classh_wk_fet_disable == 0x00 &&\n\t\t(errata_chk == 0x01 || errata_chk == 0x02)) {\n\t\tret = regmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_FET_DRIVE_CTL,\n\t\t\t\t\tCS35L35_CH_WKFET_DEL_MASK,\n\t\t\t\t\t0 << CS35L35_CH_WKFET_DEL_SHIFT);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to set fet config %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (params_width(params)) {\n\t\tcase 8:\n\t\t\taudin_format = CS35L35_SDIN_DEPTH_8;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\taudin_format = CS35L35_SDIN_DEPTH_16;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\taudin_format = CS35L35_SDIN_DEPTH_24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Unsupported Width %d\\n\",\n\t\t\t\tparams_width(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\tCS35L35_AUDIN_DEPTH_CTL,\n\t\t\t\tCS35L35_AUDIN_DEPTH_MASK,\n\t\t\t\taudin_format <<\n\t\t\t\tCS35L35_AUDIN_DEPTH_SHIFT);\n\t\tif (cs35l35->pdata.stereo) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_AUDIN_DEPTH_CTL,\n\t\t\t\t\tCS35L35_ADVIN_DEPTH_MASK,\n\t\t\t\t\taudin_format <<\n\t\t\t\t\tCS35L35_ADVIN_DEPTH_SHIFT);\n\t\t}\n\t}\n\n\tif (cs35l35->i2s_mode) {\n\t\t \n\t\tif ((cs35l35->sclk / srate) % 4) {\n\t\t\tdev_err(component->dev, \"Unsupported sclk/fs ratio %d:%d\\n\",\n\t\t\t\t\tcs35l35->sclk, srate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsp_sclks = ((cs35l35->sclk / srate) / 4) - 1;\n\n\t\t \n\t\tif (cs35l35->clock_consumer) {\n\t\t\tswitch (sp_sclks) {\n\t\t\tcase CS35L35_SP_SCLKS_32FS:\n\t\t\tcase CS35L35_SP_SCLKS_48FS:\n\t\t\tcase CS35L35_SP_SCLKS_64FS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(component->dev, \"ratio not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tswitch (sp_sclks) {\n\t\t\tcase CS35L35_SP_SCLKS_32FS:\n\t\t\tcase CS35L35_SP_SCLKS_64FS:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(component->dev, \"ratio not supported\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tret = regmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLK_CTL3,\n\t\t\t\t\tCS35L35_SP_SCLKS_MASK, sp_sclks <<\n\t\t\t\t\tCS35L35_SP_SCLKS_SHIFT);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to set fsclk %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic const unsigned int cs35l35_src_rates[] = {\n\t44100, 48000, 88200, 96000, 176400, 192000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs35l35_constraints = {\n\t.count  = ARRAY_SIZE(cs35l35_src_rates),\n\t.list   = cs35l35_src_rates,\n};\n\nstatic int cs35l35_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\n\tif (!substream->runtime)\n\t\treturn 0;\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE, &cs35l35_constraints);\n\n\tregmap_update_bits(cs35l35->regmap, CS35L35_AMP_INP_DRV_CTL,\n\t\t\t\t\tCS35L35_PDM_MODE_MASK,\n\t\t\t\t\t0 << CS35L35_PDM_MODE_SHIFT);\n\n\treturn 0;\n}\n\nstatic const unsigned int cs35l35_pdm_rates[] = {\n\t44100, 48000, 88200, 96000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs35l35_pdm_constraints = {\n\t.count  = ARRAY_SIZE(cs35l35_pdm_rates),\n\t.list   = cs35l35_pdm_rates,\n};\n\nstatic int cs35l35_pdm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\n\tif (!substream->runtime)\n\t\treturn 0;\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t&cs35l35_pdm_constraints);\n\n\tregmap_update_bits(cs35l35->regmap, CS35L35_AMP_INP_DRV_CTL,\n\t\t\t\t\tCS35L35_PDM_MODE_MASK,\n\t\t\t\t\t1 << CS35L35_PDM_MODE_SHIFT);\n\n\treturn 0;\n}\n\nstatic int cs35l35_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\n\t \n\tcs35l35->sclk = freq;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l35_ops = {\n\t.startup = cs35l35_pcm_startup,\n\t.set_fmt = cs35l35_set_dai_fmt,\n\t.hw_params = cs35l35_hw_params,\n\t.set_sysclk = cs35l35_dai_set_sysclk,\n};\n\nstatic const struct snd_soc_dai_ops cs35l35_pdm_ops = {\n\t.startup = cs35l35_pdm_startup,\n\t.set_fmt = cs35l35_set_dai_fmt,\n\t.hw_params = cs35l35_hw_params,\n};\n\nstatic struct snd_soc_dai_driver cs35l35_dai[] = {\n\t{\n\t\t.name = \"cs35l35-pcm\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AMP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L35_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AMP Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L35_FORMATS,\n\t\t},\n\t\t.ops = &cs35l35_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{\n\t\t.name = \"cs35l35-pdm\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"PDM Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS35L35_FORMATS,\n\t\t},\n\t\t.ops = &cs35l35_pdm_ops,\n\t},\n};\n\nstatic int cs35l35_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\tint clk_id, int source, unsigned int freq,\n\t\t\t\tint dir)\n{\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\tint clksrc;\n\tint ret = 0;\n\n\tswitch (clk_id) {\n\tcase 0:\n\t\tclksrc = CS35L35_CLK_SOURCE_MCLK;\n\t\tbreak;\n\tcase 1:\n\t\tclksrc = CS35L35_CLK_SOURCE_SCLK;\n\t\tbreak;\n\tcase 2:\n\t\tclksrc = CS35L35_CLK_SOURCE_PDM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid CLK Source\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 5644800:\n\tcase 6144000:\n\tcase 11289600:\n\tcase 12000000:\n\tcase 12288000:\n\tcase 13000000:\n\tcase 22579200:\n\tcase 24000000:\n\tcase 24576000:\n\tcase 26000000:\n\t\tcs35l35->sysclk = freq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid CLK Frequency Input : %d\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\tCS35L35_CLK_SOURCE_MASK,\n\t\t\t\tclksrc << CS35L35_CLK_SOURCE_SHIFT);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to set sysclk %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int cs35l35_boost_inductor(struct cs35l35_private *cs35l35,\n\t\t\t\t  int inductor)\n{\n\tstruct regmap *regmap = cs35l35->regmap;\n\tunsigned int bst_ipk = 0;\n\n\t \n\n\tregmap_update_bits(regmap, CS35L35_BST_CONV_SW_FREQ,\n\t\t\t   CS35L35_BST_CONV_SWFREQ_MASK, 0x00);\n\n\tregmap_read(regmap, CS35L35_BST_PEAK_I, &bst_ipk);\n\tbst_ipk &= CS35L35_BST_IPK_MASK;\n\n\tswitch (inductor) {\n\tcase 1000:  \n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_1, 0x24);\n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_2, 0x24);\n\t\tregmap_update_bits(regmap, CS35L35_BST_CONV_SW_FREQ,\n\t\t\t\t   CS35L35_BST_CONV_LBST_MASK, 0x00);\n\n\t\tif (bst_ipk < 0x04)\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x1B);\n\t\telse\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x4E);\n\t\tbreak;\n\tcase 1200:  \n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_1, 0x20);\n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_2, 0x20);\n\t\tregmap_update_bits(regmap, CS35L35_BST_CONV_SW_FREQ,\n\t\t\t\t   CS35L35_BST_CONV_LBST_MASK, 0x01);\n\n\t\tif (bst_ipk < 0x04)\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x1B);\n\t\telse\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x47);\n\t\tbreak;\n\tcase 1500:  \n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_1, 0x20);\n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_2, 0x20);\n\t\tregmap_update_bits(regmap, CS35L35_BST_CONV_SW_FREQ,\n\t\t\t\t   CS35L35_BST_CONV_LBST_MASK, 0x02);\n\n\t\tif (bst_ipk < 0x04)\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x1B);\n\t\telse\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x3C);\n\t\tbreak;\n\tcase 2200:  \n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_1, 0x19);\n\t\tregmap_write(regmap, CS35L35_BST_CONV_COEF_2, 0x25);\n\t\tregmap_update_bits(regmap, CS35L35_BST_CONV_SW_FREQ,\n\t\t\t\t   CS35L35_BST_CONV_LBST_MASK, 0x03);\n\n\t\tif (bst_ipk < 0x04)\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x1B);\n\t\telse\n\t\t\tregmap_write(regmap, CS35L35_BST_CONV_SLOPE_COMP, 0x23);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l35->dev, \"Invalid Inductor Value %d uH\\n\",\n\t\t\tinductor);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs35l35_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l35_private *cs35l35 = snd_soc_component_get_drvdata(component);\n\tstruct classh_cfg *classh = &cs35l35->pdata.classh_algo;\n\tstruct monitor_cfg *monitor_config = &cs35l35->pdata.mon_cfg;\n\tint ret;\n\n\t \n\tif (cs35l35->pdata.bst_vctl)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_BST_CVTR_V_CTL,\n\t\t\t\tCS35L35_BST_CTL_MASK,\n\t\t\t\tcs35l35->pdata.bst_vctl);\n\n\tif (cs35l35->pdata.bst_ipk)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_BST_PEAK_I,\n\t\t\t\tCS35L35_BST_IPK_MASK,\n\t\t\t\tcs35l35->pdata.bst_ipk <<\n\t\t\t\tCS35L35_BST_IPK_SHIFT);\n\n\tret = cs35l35_boost_inductor(cs35l35, cs35l35->pdata.boost_ind);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cs35l35->pdata.gain_zc)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PROTECT_CTL,\n\t\t\t\tCS35L35_AMP_GAIN_ZC_MASK,\n\t\t\t\tcs35l35->pdata.gain_zc <<\n\t\t\t\tCS35L35_AMP_GAIN_ZC_SHIFT);\n\n\tif (cs35l35->pdata.aud_channel)\n\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\tCS35L35_AUDIN_RXLOC_CTL,\n\t\t\t\tCS35L35_AUD_IN_LR_MASK,\n\t\t\t\tcs35l35->pdata.aud_channel <<\n\t\t\t\tCS35L35_AUD_IN_LR_SHIFT);\n\n\tif (cs35l35->pdata.stereo) {\n\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\tCS35L35_ADVIN_RXLOC_CTL,\n\t\t\t\tCS35L35_ADV_IN_LR_MASK,\n\t\t\t\tcs35l35->pdata.adv_channel <<\n\t\t\t\tCS35L35_ADV_IN_LR_SHIFT);\n\t\tif (cs35l35->pdata.shared_bst)\n\t\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLASS_H_CTL,\n\t\t\t\t\tCS35L35_CH_STEREO_MASK,\n\t\t\t\t\t1 << CS35L35_CH_STEREO_SHIFT);\n\t\tret = snd_soc_add_component_controls(component, cs35l35_adv_controls,\n\t\t\t\t\tARRAY_SIZE(cs35l35_adv_controls));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cs35l35->pdata.sp_drv_str)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_CLK_CTL1,\n\t\t\t\tCS35L35_SP_DRV_MASK,\n\t\t\t\tcs35l35->pdata.sp_drv_str <<\n\t\t\t\tCS35L35_SP_DRV_SHIFT);\n\tif (cs35l35->pdata.sp_drv_unused)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_SP_FMT_CTL3,\n\t\t\t\t   CS35L35_SP_I2S_DRV_MASK,\n\t\t\t\t   cs35l35->pdata.sp_drv_unused <<\n\t\t\t\t   CS35L35_SP_I2S_DRV_SHIFT);\n\n\tif (classh->classh_algo_enable) {\n\t\tif (classh->classh_bst_override)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_CTL,\n\t\t\t\t\tCS35L35_CH_BST_OVR_MASK,\n\t\t\t\t\tclassh->classh_bst_override <<\n\t\t\t\t\tCS35L35_CH_BST_OVR_SHIFT);\n\t\tif (classh->classh_bst_max_limit)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_CTL,\n\t\t\t\t\tCS35L35_CH_BST_LIM_MASK,\n\t\t\t\t\tclassh->classh_bst_max_limit <<\n\t\t\t\t\tCS35L35_CH_BST_LIM_SHIFT);\n\t\tif (classh->classh_mem_depth)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_CTL,\n\t\t\t\t\tCS35L35_CH_MEM_DEPTH_MASK,\n\t\t\t\t\tclassh->classh_mem_depth <<\n\t\t\t\t\tCS35L35_CH_MEM_DEPTH_SHIFT);\n\t\tif (classh->classh_headroom)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_HEADRM_CTL,\n\t\t\t\t\tCS35L35_CH_HDRM_CTL_MASK,\n\t\t\t\t\tclassh->classh_headroom <<\n\t\t\t\t\tCS35L35_CH_HDRM_CTL_SHIFT);\n\t\tif (classh->classh_release_rate)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_RELEASE_RATE,\n\t\t\t\t\tCS35L35_CH_REL_RATE_MASK,\n\t\t\t\t\tclassh->classh_release_rate <<\n\t\t\t\t\tCS35L35_CH_REL_RATE_SHIFT);\n\t\tif (classh->classh_wk_fet_disable)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_FET_DRIVE_CTL,\n\t\t\t\t\tCS35L35_CH_WKFET_DIS_MASK,\n\t\t\t\t\tclassh->classh_wk_fet_disable <<\n\t\t\t\t\tCS35L35_CH_WKFET_DIS_SHIFT);\n\t\tif (classh->classh_wk_fet_delay)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_FET_DRIVE_CTL,\n\t\t\t\t\tCS35L35_CH_WKFET_DEL_MASK,\n\t\t\t\t\tclassh->classh_wk_fet_delay <<\n\t\t\t\t\tCS35L35_CH_WKFET_DEL_SHIFT);\n\t\tif (classh->classh_wk_fet_thld)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_FET_DRIVE_CTL,\n\t\t\t\t\tCS35L35_CH_WKFET_THLD_MASK,\n\t\t\t\t\tclassh->classh_wk_fet_thld <<\n\t\t\t\t\tCS35L35_CH_WKFET_THLD_SHIFT);\n\t\tif (classh->classh_vpch_auto)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_VP_CTL,\n\t\t\t\t\tCS35L35_CH_VP_AUTO_MASK,\n\t\t\t\t\tclassh->classh_vpch_auto <<\n\t\t\t\t\tCS35L35_CH_VP_AUTO_SHIFT);\n\t\tif (classh->classh_vpch_rate)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_VP_CTL,\n\t\t\t\t\tCS35L35_CH_VP_RATE_MASK,\n\t\t\t\t\tclassh->classh_vpch_rate <<\n\t\t\t\t\tCS35L35_CH_VP_RATE_SHIFT);\n\t\tif (classh->classh_vpch_man)\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_CLASS_H_VP_CTL,\n\t\t\t\t\tCS35L35_CH_VP_MAN_MASK,\n\t\t\t\t\tclassh->classh_vpch_man <<\n\t\t\t\t\tCS35L35_CH_VP_MAN_SHIFT);\n\t}\n\n\tif (monitor_config->is_present) {\n\t\tif (monitor_config->vmon_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SPKMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_VMON_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->vmon_dpth <<\n\t\t\t\t\tCS35L35_VMON_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->vmon_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->vmon_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t}\n\t\tif (monitor_config->imon_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SPKMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_IMON_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->imon_dpth <<\n\t\t\t\t\tCS35L35_IMON_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_IMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->imon_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_IMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->imon_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_IMON_SCALE_CTL,\n\t\t\t\t\tCS35L35_IMON_SCALE_MASK,\n\t\t\t\t\tmonitor_config->imon_scale <<\n\t\t\t\t\tCS35L35_IMON_SCALE_SHIFT);\n\t\t}\n\t\tif (monitor_config->vpmon_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SUPMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_VPMON_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->vpmon_dpth <<\n\t\t\t\t\tCS35L35_VPMON_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VPMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->vpmon_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VPMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->vpmon_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t}\n\t\tif (monitor_config->vbstmon_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SUPMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_VBSTMON_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->vpmon_dpth <<\n\t\t\t\t\tCS35L35_VBSTMON_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VBSTMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->vbstmon_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VBSTMON_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->vbstmon_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t}\n\t\tif (monitor_config->vpbrstat_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SUPMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_VPBRSTAT_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->vpbrstat_dpth <<\n\t\t\t\t\tCS35L35_VPBRSTAT_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VPBR_STATUS_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->vpbrstat_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_VPBR_STATUS_TXLOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->vpbrstat_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t}\n\t\tif (monitor_config->zerofill_specs) {\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_SUPMON_DEPTH_CTL,\n\t\t\t\t\tCS35L35_ZEROFILL_DEPTH_MASK,\n\t\t\t\t\tmonitor_config->zerofill_dpth <<\n\t\t\t\t\tCS35L35_ZEROFILL_DEPTH_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_ZERO_FILL_LOC_CTL,\n\t\t\t\t\tCS35L35_MON_TXLOC_MASK,\n\t\t\t\t\tmonitor_config->zerofill_loc <<\n\t\t\t\t\tCS35L35_MON_TXLOC_SHIFT);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_ZERO_FILL_LOC_CTL,\n\t\t\t\t\tCS35L35_MON_FRM_MASK,\n\t\t\t\t\tmonitor_config->zerofill_frm <<\n\t\t\t\t\tCS35L35_MON_FRM_SHIFT);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l35 = {\n\t.probe\t\t\t= cs35l35_component_probe,\n\t.set_sysclk\t\t= cs35l35_component_set_sysclk,\n\t.dapm_widgets\t\t= cs35l35_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs35l35_dapm_widgets),\n\t.dapm_routes\t\t= cs35l35_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs35l35_audio_map),\n\t.controls\t\t= cs35l35_aud_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs35l35_aud_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct regmap_config cs35l35_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS35L35_MAX_REGISTER,\n\t.reg_defaults = cs35l35_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs35l35_reg),\n\t.volatile_reg = cs35l35_volatile_register,\n\t.readable_reg = cs35l35_readable_register,\n\t.precious_reg = cs35l35_precious_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic irqreturn_t cs35l35_irq(int irq, void *data)\n{\n\tstruct cs35l35_private *cs35l35 = data;\n\tunsigned int sticky1, sticky2, sticky3, sticky4;\n\tunsigned int mask1, mask2, mask3, mask4, current1;\n\n\t \n\tregmap_read(cs35l35->regmap, CS35L35_INT_STATUS_4, &sticky4);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_STATUS_3, &sticky3);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_STATUS_2, &sticky2);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_STATUS_1, &sticky1);\n\n\tregmap_read(cs35l35->regmap, CS35L35_INT_MASK_4, &mask4);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_MASK_3, &mask3);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_MASK_2, &mask2);\n\tregmap_read(cs35l35->regmap, CS35L35_INT_MASK_1, &mask1);\n\n\t \n\tif (!(sticky1 & ~mask1) && !(sticky2 & ~mask2) && !(sticky3 & ~mask3)\n\t\t\t&& !(sticky4 & ~mask4))\n\t\treturn IRQ_NONE;\n\n\tif (sticky2 & CS35L35_PDN_DONE)\n\t\tcomplete(&cs35l35->pdn_done);\n\n\t \n\tregmap_read(cs35l35->regmap, CS35L35_INT_STATUS_1, &current1);\n\n\t \n\tif (sticky1 & CS35L35_CAL_ERR) {\n\t\tdev_crit(cs35l35->dev, \"Calibration Error\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L35_CAL_ERR)) {\n\t\t\tpr_debug(\"%s : Cal error release\\n\", __func__);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_CAL_ERR_RLS, 0);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_CAL_ERR_RLS,\n\t\t\t\t\tCS35L35_CAL_ERR_RLS);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_CAL_ERR_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky1 & CS35L35_AMP_SHORT) {\n\t\tdev_crit(cs35l35->dev, \"AMP Short Error\\n\");\n\t\t \n\t\tif (!(current1 & CS35L35_AMP_SHORT)) {\n\t\t\tdev_dbg(cs35l35->dev, \"Amp short error release\\n\");\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_SHORT_RLS, 0);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_SHORT_RLS,\n\t\t\t\t\tCS35L35_SHORT_RLS);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_SHORT_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky1 & CS35L35_OTW) {\n\t\tdev_warn(cs35l35->dev, \"Over temperature warning\\n\");\n\n\t\t \n\t\tif (!(current1 & CS35L35_OTW)) {\n\t\t\tdev_dbg(cs35l35->dev, \"Over temperature warn release\\n\");\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTW_RLS, 0);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTW_RLS,\n\t\t\t\t\tCS35L35_OTW_RLS);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTW_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky1 & CS35L35_OTE) {\n\t\tdev_crit(cs35l35->dev, \"Over temperature error\\n\");\n\t\t \n\t\tif (!(current1 & CS35L35_OTE)) {\n\t\t\tdev_dbg(cs35l35->dev, \"Over temperature error release\\n\");\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTE_RLS, 0);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTE_RLS,\n\t\t\t\t\tCS35L35_OTE_RLS);\n\t\t\tregmap_update_bits(cs35l35->regmap,\n\t\t\t\t\tCS35L35_PROT_RELEASE_CTL,\n\t\t\t\t\tCS35L35_OTE_RLS, 0);\n\t\t}\n\t}\n\n\tif (sticky3 & CS35L35_BST_HIGH) {\n\t\tdev_crit(cs35l35->dev, \"VBST error: powering off!\\n\");\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\tCS35L35_PDN_AMP, CS35L35_PDN_AMP);\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\tCS35L35_PDN_ALL, CS35L35_PDN_ALL);\n\t}\n\n\tif (sticky3 & CS35L35_LBST_SHORT) {\n\t\tdev_crit(cs35l35->dev, \"LBST error: powering off!\\n\");\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\tCS35L35_PDN_AMP, CS35L35_PDN_AMP);\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL1,\n\t\t\tCS35L35_PDN_ALL, CS35L35_PDN_ALL);\n\t}\n\n\tif (sticky2 & CS35L35_VPBR_ERR)\n\t\tdev_dbg(cs35l35->dev, \"Error: Reactive Brownout\\n\");\n\n\tif (sticky4 & CS35L35_VMON_OVFL)\n\t\tdev_dbg(cs35l35->dev, \"Error: VMON overflow\\n\");\n\n\tif (sticky4 & CS35L35_IMON_OVFL)\n\t\tdev_dbg(cs35l35->dev, \"Error: IMON overflow\\n\");\n\n\treturn IRQ_HANDLED;\n}\n\n\nstatic int cs35l35_handle_of_data(struct i2c_client *i2c_client,\n\t\t\t\tstruct cs35l35_platform_data *pdata)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tstruct device_node *classh, *signal_format;\n\tstruct classh_cfg *classh_config = &pdata->classh_algo;\n\tstruct monitor_cfg *monitor_config = &pdata->mon_cfg;\n\tunsigned int val32 = 0;\n\tu8 monitor_array[4];\n\tconst int imon_array_size = ARRAY_SIZE(monitor_array);\n\tconst int mon_array_size = imon_array_size - 1;\n\tint ret = 0;\n\n\tif (!np)\n\t\treturn 0;\n\n\tpdata->bst_pdn_fet_on = of_property_read_bool(np,\n\t\t\t\t\t\"cirrus,boost-pdn-fet-on\");\n\n\tret = of_property_read_u32(np, \"cirrus,boost-ctl-millivolt\", &val32);\n\tif (ret >= 0) {\n\t\tif (val32 < 2600 || val32 > 9000) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Voltage %d mV\\n\", val32);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdata->bst_vctl = ((val32 - 2600) / 100) + 1;\n\t}\n\n\tret = of_property_read_u32(np, \"cirrus,boost-peak-milliamp\", &val32);\n\tif (ret >= 0) {\n\t\tif (val32 < 1680 || val32 > 4480) {\n\t\t\tdev_err(&i2c_client->dev,\n\t\t\t\t\"Invalid Boost Peak Current %u mA\\n\", val32);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpdata->bst_ipk = ((val32 - 1680) / 110) | CS35L35_VALID_PDATA;\n\t}\n\n\tret = of_property_read_u32(np, \"cirrus,boost-ind-nanohenry\", &val32);\n\tif (ret >= 0) {\n\t\tpdata->boost_ind = val32;\n\t} else {\n\t\tdev_err(&i2c_client->dev, \"Inductor not specified.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(np, \"cirrus,sp-drv-strength\", &val32) >= 0)\n\t\tpdata->sp_drv_str = val32;\n\tif (of_property_read_u32(np, \"cirrus,sp-drv-unused\", &val32) >= 0)\n\t\tpdata->sp_drv_unused = val32 | CS35L35_VALID_PDATA;\n\n\tpdata->stereo = of_property_read_bool(np, \"cirrus,stereo-config\");\n\n\tif (pdata->stereo) {\n\t\tret = of_property_read_u32(np, \"cirrus,audio-channel\", &val32);\n\t\tif (ret >= 0)\n\t\t\tpdata->aud_channel = val32;\n\n\t\tret = of_property_read_u32(np, \"cirrus,advisory-channel\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0)\n\t\t\tpdata->adv_channel = val32;\n\n\t\tpdata->shared_bst = of_property_read_bool(np,\n\t\t\t\t\t\t\"cirrus,shared-boost\");\n\t}\n\n\tpdata->ext_bst = of_property_read_bool(np, \"cirrus,external-boost\");\n\n\tpdata->gain_zc = of_property_read_bool(np, \"cirrus,amp-gain-zc\");\n\n\tclassh = of_get_child_by_name(np, \"cirrus,classh-internal-algo\");\n\tclassh_config->classh_algo_enable = (classh != NULL);\n\n\tif (classh_config->classh_algo_enable) {\n\t\tclassh_config->classh_bst_override =\n\t\t\tof_property_read_bool(np, \"cirrus,classh-bst-overide\");\n\n\t\tret = of_property_read_u32(classh,\n\t\t\t\t\t   \"cirrus,classh-bst-max-limit\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_bst_max_limit = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh,\n\t\t\t\t\t   \"cirrus,classh-bst-max-limit\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_bst_max_limit = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-mem-depth\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_mem_depth = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-release-rate\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0)\n\t\t\tclassh_config->classh_release_rate = val32;\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-headroom\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_headroom = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh,\n\t\t\t\t\t   \"cirrus,classh-wk-fet-disable\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0)\n\t\t\tclassh_config->classh_wk_fet_disable = val32;\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-wk-fet-delay\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_wk_fet_delay = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-wk-fet-thld\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0)\n\t\t\tclassh_config->classh_wk_fet_thld = val32;\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-vpch-auto\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_vpch_auto = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-vpch-rate\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0) {\n\t\t\tval32 |= CS35L35_VALID_PDATA;\n\t\t\tclassh_config->classh_vpch_rate = val32;\n\t\t}\n\n\t\tret = of_property_read_u32(classh, \"cirrus,classh-vpch-man\",\n\t\t\t\t\t   &val32);\n\t\tif (ret >= 0)\n\t\t\tclassh_config->classh_vpch_man = val32;\n\t}\n\tof_node_put(classh);\n\n\t \n\tsignal_format = of_get_child_by_name(np, \"cirrus,monitor-signal-format\");\n\tmonitor_config->is_present = signal_format ? true : false;\n\tif (monitor_config->is_present) {\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,imon\",\n\t\t\t\t\t\tmonitor_array, imon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->imon_specs = true;\n\t\t\tmonitor_config->imon_dpth = monitor_array[0];\n\t\t\tmonitor_config->imon_loc = monitor_array[1];\n\t\t\tmonitor_config->imon_frm = monitor_array[2];\n\t\t\tmonitor_config->imon_scale = monitor_array[3];\n\t\t}\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,vmon\",\n\t\t\t\t\t\tmonitor_array, mon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->vmon_specs = true;\n\t\t\tmonitor_config->vmon_dpth = monitor_array[0];\n\t\t\tmonitor_config->vmon_loc = monitor_array[1];\n\t\t\tmonitor_config->vmon_frm = monitor_array[2];\n\t\t}\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,vpmon\",\n\t\t\t\t\t\tmonitor_array, mon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->vpmon_specs = true;\n\t\t\tmonitor_config->vpmon_dpth = monitor_array[0];\n\t\t\tmonitor_config->vpmon_loc = monitor_array[1];\n\t\t\tmonitor_config->vpmon_frm = monitor_array[2];\n\t\t}\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,vbstmon\",\n\t\t\t\t\t\tmonitor_array, mon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->vbstmon_specs = true;\n\t\t\tmonitor_config->vbstmon_dpth = monitor_array[0];\n\t\t\tmonitor_config->vbstmon_loc = monitor_array[1];\n\t\t\tmonitor_config->vbstmon_frm = monitor_array[2];\n\t\t}\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,vpbrstat\",\n\t\t\t\t\t\tmonitor_array, mon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->vpbrstat_specs = true;\n\t\t\tmonitor_config->vpbrstat_dpth = monitor_array[0];\n\t\t\tmonitor_config->vpbrstat_loc = monitor_array[1];\n\t\t\tmonitor_config->vpbrstat_frm = monitor_array[2];\n\t\t}\n\t\tret = of_property_read_u8_array(signal_format, \"cirrus,zerofill\",\n\t\t\t\t\t\tmonitor_array, mon_array_size);\n\t\tif (!ret) {\n\t\t\tmonitor_config->zerofill_specs = true;\n\t\t\tmonitor_config->zerofill_dpth = monitor_array[0];\n\t\t\tmonitor_config->zerofill_loc = monitor_array[1];\n\t\t\tmonitor_config->zerofill_frm = monitor_array[2];\n\t\t}\n\t}\n\tof_node_put(signal_format);\n\n\treturn 0;\n}\n\n \nstatic const struct reg_sequence cs35l35_errata_patch[] = {\n\n\t{ 0x7F, 0x99 },\n\t{ 0x00, 0x99 },\n\t{ 0x52, 0x22 },\n\t{ 0x04, 0x14 },\n\t{ 0x6D, 0x44 },\n\t{ 0x24, 0x10 },\n\t{ 0x58, 0xC4 },\n\t{ 0x00, 0x98 },\n\t{ 0x18, 0x08 },\n\t{ 0x00, 0x00 },\n\t{ 0x7F, 0x00 },\n};\n\nstatic int cs35l35_i2c_probe(struct i2c_client *i2c_client)\n{\n\tstruct cs35l35_private *cs35l35;\n\tstruct device *dev = &i2c_client->dev;\n\tstruct cs35l35_platform_data *pdata = dev_get_platdata(dev);\n\tint i, devid;\n\tint ret;\n\tunsigned int reg;\n\n\tcs35l35 = devm_kzalloc(dev, sizeof(struct cs35l35_private), GFP_KERNEL);\n\tif (!cs35l35)\n\t\treturn -ENOMEM;\n\n\tcs35l35->dev = dev;\n\n\ti2c_set_clientdata(i2c_client, cs35l35);\n\tcs35l35->regmap = devm_regmap_init_i2c(i2c_client, &cs35l35_regmap);\n\tif (IS_ERR(cs35l35->regmap)) {\n\t\tret = PTR_ERR(cs35l35->regmap);\n\t\tdev_err(dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cs35l35_supplies); i++)\n\t\tcs35l35->supplies[i].supply = cs35l35_supplies[i];\n\n\tcs35l35->num_supplies = ARRAY_SIZE(cs35l35_supplies);\n\n\tret = devm_regulator_bulk_get(dev, cs35l35->num_supplies,\n\t\t\t\t      cs35l35->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (pdata) {\n\t\tcs35l35->pdata = *pdata;\n\t} else {\n\t\tpdata = devm_kzalloc(dev, sizeof(struct cs35l35_platform_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\t\tif (i2c_client->dev.of_node) {\n\t\t\tret = cs35l35_handle_of_data(i2c_client, pdata);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\n\t\t}\n\t\tcs35l35->pdata = *pdata;\n\t}\n\n\tret = regulator_bulk_enable(cs35l35->num_supplies,\n\t\t\t\t\tcs35l35->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable core supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs35l35->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l35->reset_gpio)) {\n\t\tret = PTR_ERR(cs35l35->reset_gpio);\n\t\tcs35l35->reset_gpio = NULL;\n\t\tif (ret == -EBUSY) {\n\t\t\tdev_info(dev,\n\t\t\t\t \"Reset line busy, assuming shared reset\\n\");\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to get reset GPIO: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tcs35l35_reset(cs35l35);\n\n\tinit_completion(&cs35l35->pdn_done);\n\n\tret = devm_request_threaded_irq(dev, i2c_client->irq, NULL, cs35l35_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_LOW |\n\t\t\t\t\tIRQF_SHARED, \"cs35l35\", cs35l35);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\t \n\tdevid = cirrus_read_device_id(cs35l35->regmap, CS35L35_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (devid != CS35L35_CHIP_ID) {\n\t\tdev_err(dev, \"CS35L35 Device ID (%X). Expected ID %X\\n\",\n\t\t\tdevid, CS35L35_CHIP_ID);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tret = regmap_read(cs35l35->regmap, CS35L35_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Get Revision ID failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = regmap_register_patch(cs35l35->regmap, cs35l35_errata_patch,\n\t\t\t\t    ARRAY_SIZE(cs35l35_errata_patch));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to apply errata patch: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdev_info(dev, \"Cirrus Logic CS35L35 (%x), Revision: %02X\\n\",\n\t\t devid, reg & 0xFF);\n\n\t \n\tregmap_write(cs35l35->regmap, CS35L35_INT_MASK_1,\n\t\t\t\tCS35L35_INT1_CRIT_MASK);\n\tregmap_write(cs35l35->regmap, CS35L35_INT_MASK_2,\n\t\t\t\tCS35L35_INT2_CRIT_MASK);\n\tregmap_write(cs35l35->regmap, CS35L35_INT_MASK_3,\n\t\t\t\tCS35L35_INT3_CRIT_MASK);\n\tregmap_write(cs35l35->regmap, CS35L35_INT_MASK_4,\n\t\t\t\tCS35L35_INT4_CRIT_MASK);\n\n\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\tCS35L35_PWR2_PDN_MASK,\n\t\t\tCS35L35_PWR2_PDN_MASK);\n\n\tif (cs35l35->pdata.bst_pdn_fet_on)\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t\t1 << CS35L35_PDN_BST_FETON_SHIFT);\n\telse\n\t\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL2,\n\t\t\t\t\tCS35L35_PDN_BST_MASK,\n\t\t\t\t\t1 << CS35L35_PDN_BST_FETOFF_SHIFT);\n\n\tregmap_update_bits(cs35l35->regmap, CS35L35_PWRCTL3,\n\t\t\tCS35L35_PWR3_PDN_MASK,\n\t\t\tCS35L35_PWR3_PDN_MASK);\n\n\tregmap_update_bits(cs35l35->regmap, CS35L35_PROTECT_CTL,\n\t\tCS35L35_AMP_MUTE_MASK, 1 << CS35L35_AMP_MUTE_SHIFT);\n\n\tret = devm_snd_soc_register_component(dev, &soc_component_dev_cs35l35,\n\t\t\t\t\tcs35l35_dai, ARRAY_SIZE(cs35l35_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register component: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tregulator_bulk_disable(cs35l35->num_supplies,\n\t\t\t       cs35l35->supplies);\n\tgpiod_set_value_cansleep(cs35l35->reset_gpio, 0);\n\n\treturn ret;\n}\n\nstatic void cs35l35_i2c_remove(struct i2c_client *i2c_client)\n{\n\tstruct cs35l35_private *cs35l35 = i2c_get_clientdata(i2c_client);\n\n\tregulator_bulk_disable(cs35l35->num_supplies, cs35l35->supplies);\n\tgpiod_set_value_cansleep(cs35l35->reset_gpio, 0);\n}\n\nstatic const struct of_device_id cs35l35_of_match[] = {\n\t{.compatible = \"cirrus,cs35l35\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cs35l35_of_match);\n\nstatic const struct i2c_device_id cs35l35_id[] = {\n\t{\"cs35l35\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs35l35_id);\n\nstatic struct i2c_driver cs35l35_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs35l35\",\n\t\t.of_match_table = cs35l35_of_match,\n\t},\n\t.id_table = cs35l35_id,\n\t.probe = cs35l35_i2c_probe,\n\t.remove = cs35l35_i2c_remove,\n};\n\nmodule_i2c_driver(cs35l35_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS35L35 driver\");\nMODULE_AUTHOR(\"Brian Austin, Cirrus Logic Inc, <brian.austin@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}