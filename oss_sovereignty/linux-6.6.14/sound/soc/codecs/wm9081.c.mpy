{
  "module_name": "wm9081.c",
  "hash_id": "ab3c3770c812d2f9866b62e2f709ce62e10fe62c6853980246d0264ded2ecaaf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm9081.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/wm9081.h>\n#include \"wm9081.h\"\n\nstatic const struct reg_default wm9081_reg[] = {\n\t{  2, 0x00B9 },      \n\t{  3, 0x00B9 },      \n\t{  4, 0x0001 },      \n\t{  5, 0x0068 },      \n\t{  7, 0x0000 },      \n\t{  8, 0x0000 },      \n\t{  9, 0x01DB },      \n\t{ 10, 0x0018 },      \n\t{ 11, 0x0180 },      \n\t{ 12, 0x0000 },      \n\t{ 13, 0x0038 },      \n\t{ 14, 0x4000 },      \n\t{ 16, 0x0000 },      \n\t{ 17, 0x0200 },      \n\t{ 18, 0x0000 },      \n\t{ 19, 0x0204 },      \n\t{ 20, 0x0000 },      \n\t{ 22, 0x0000 },      \n\t{ 23, 0x0002 },      \n\t{ 24, 0x0008 },      \n\t{ 25, 0x0022 },      \n\t{ 27, 0x0006 },      \n\t{ 28, 0x0000 },      \n\t{ 29, 0x0000 },      \n\t{ 30, 0x00C0 },      \n\t{ 31, 0x0008 },      \n\t{ 32, 0x09AF },      \n\t{ 33, 0x4201 },      \n\t{ 34, 0x0000 },      \n\t{ 35, 0x0000 },      \n\t{ 38, 0x0000 },      \n\t{ 39, 0x0000 },      \n\t{ 40, 0x0002 },      \n\t{ 42, 0x0000 },      \n\t{ 43, 0x0000 },      \n\t{ 44, 0x0FCA },      \n\t{ 45, 0x0400 },      \n\t{ 46, 0x00B8 },      \n\t{ 47, 0x1EB5 },      \n\t{ 48, 0xF145 },      \n\t{ 49, 0x0B75 },      \n\t{ 50, 0x01C5 },      \n\t{ 51, 0x169E },      \n\t{ 52, 0xF829 },      \n\t{ 53, 0x07AD },      \n\t{ 54, 0x1103 },      \n\t{ 55, 0x1C58 },      \n\t{ 56, 0xF373 },      \n\t{ 57, 0x0A54 },      \n\t{ 58, 0x0558 },      \n\t{ 59, 0x0564 },      \n\t{ 60, 0x0559 },      \n\t{ 61, 0x4000 },      \n};\n\nstatic struct {\n\tint ratio;\n\tint clk_sys_rate;\n} clk_sys_rates[] = {\n\t{ 64,   0 },\n\t{ 128,  1 },\n\t{ 192,  2 },\n\t{ 256,  3 },\n\t{ 384,  4 },\n\t{ 512,  5 },\n\t{ 768,  6 },\n\t{ 1024, 7 },\n\t{ 1408, 8 },\n\t{ 1536, 9 },\n};\n\nstatic struct {\n\tint rate;\n\tint sample_rate;\n} sample_rates[] = {\n\t{ 8000,  0  },\n\t{ 11025, 1  },\n\t{ 12000, 2  },\n\t{ 16000, 3  },\n\t{ 22050, 4  },\n\t{ 24000, 5  },\n\t{ 32000, 6  },\n\t{ 44100, 7  },\n\t{ 48000, 8  },\n\t{ 88200, 9  },\n\t{ 96000, 10 },\n};\n\nstatic struct {\n\tint div;  \n\tint bclk_div;\n} bclk_divs[] = {\n\t{ 10,  0  },\n\t{ 15,  1  },\n\t{ 20,  2  },\n\t{ 30,  3  },\n\t{ 40,  4  },\n\t{ 50,  5  },\n\t{ 55,  6  },\n\t{ 60,  7  },\n\t{ 80,  8  },\n\t{ 100, 9  },\n\t{ 110, 10 },\n\t{ 120, 11 },\n\t{ 160, 12 },\n\t{ 200, 13 },\n\t{ 220, 14 },\n\t{ 240, 15 },\n\t{ 250, 16 },\n\t{ 300, 17 },\n\t{ 320, 18 },\n\t{ 440, 19 },\n\t{ 480, 20 },\n};\n\nstruct wm9081_priv {\n\tstruct regmap *regmap;\n\tint sysclk_source;\n\tint mclk_rate;\n\tint sysclk_rate;\n\tint fs;\n\tint bclk;\n\tint master;\n\tint fll_fref;\n\tint fll_fout;\n\tint tdm_width;\n\tstruct wm9081_pdata pdata;\n};\n\nstatic bool wm9081_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM9081_SOFTWARE_RESET:\n\tcase WM9081_INTERRUPT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm9081_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM9081_SOFTWARE_RESET:\n\tcase WM9081_ANALOGUE_LINEOUT:\n\tcase WM9081_ANALOGUE_SPEAKER_PGA:\n\tcase WM9081_VMID_CONTROL:\n\tcase WM9081_BIAS_CONTROL_1:\n\tcase WM9081_ANALOGUE_MIXER:\n\tcase WM9081_ANTI_POP_CONTROL:\n\tcase WM9081_ANALOGUE_SPEAKER_1:\n\tcase WM9081_ANALOGUE_SPEAKER_2:\n\tcase WM9081_POWER_MANAGEMENT:\n\tcase WM9081_CLOCK_CONTROL_1:\n\tcase WM9081_CLOCK_CONTROL_2:\n\tcase WM9081_CLOCK_CONTROL_3:\n\tcase WM9081_FLL_CONTROL_1:\n\tcase WM9081_FLL_CONTROL_2:\n\tcase WM9081_FLL_CONTROL_3:\n\tcase WM9081_FLL_CONTROL_4:\n\tcase WM9081_FLL_CONTROL_5:\n\tcase WM9081_AUDIO_INTERFACE_1:\n\tcase WM9081_AUDIO_INTERFACE_2:\n\tcase WM9081_AUDIO_INTERFACE_3:\n\tcase WM9081_AUDIO_INTERFACE_4:\n\tcase WM9081_INTERRUPT_STATUS:\n\tcase WM9081_INTERRUPT_STATUS_MASK:\n\tcase WM9081_INTERRUPT_POLARITY:\n\tcase WM9081_INTERRUPT_CONTROL:\n\tcase WM9081_DAC_DIGITAL_1:\n\tcase WM9081_DAC_DIGITAL_2:\n\tcase WM9081_DRC_1:\n\tcase WM9081_DRC_2:\n\tcase WM9081_DRC_3:\n\tcase WM9081_DRC_4:\n\tcase WM9081_WRITE_SEQUENCER_1:\n\tcase WM9081_WRITE_SEQUENCER_2:\n\tcase WM9081_MW_SLAVE_1:\n\tcase WM9081_EQ_1:\n\tcase WM9081_EQ_2:\n\tcase WM9081_EQ_3:\n\tcase WM9081_EQ_4:\n\tcase WM9081_EQ_5:\n\tcase WM9081_EQ_6:\n\tcase WM9081_EQ_7:\n\tcase WM9081_EQ_8:\n\tcase WM9081_EQ_9:\n\tcase WM9081_EQ_10:\n\tcase WM9081_EQ_11:\n\tcase WM9081_EQ_12:\n\tcase WM9081_EQ_13:\n\tcase WM9081_EQ_14:\n\tcase WM9081_EQ_15:\n\tcase WM9081_EQ_16:\n\tcase WM9081_EQ_17:\n\tcase WM9081_EQ_18:\n\tcase WM9081_EQ_19:\n\tcase WM9081_EQ_20:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm9081_reset(struct regmap *map)\n{\n\treturn regmap_write(map, WM9081_SOFTWARE_RESET, 0x9081);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(drc_in_tlv, -4500, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_out_tlv, -2250, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_min_tlv, -1800, 600, 0);\nstatic const DECLARE_TLV_DB_RANGE(drc_max_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(1200, 0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(1800, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(2400, 0, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(3600, 0, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(drc_qr_tlv, 1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(drc_startup_tlv, -300, 50, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(in_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -7200, 75, 1);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\n\nstatic const char *drc_high_text[] = {\n\t\"1\",\n\t\"1/2\",\n\t\"1/4\",\n\t\"1/8\",\n\t\"1/16\",\n\t\"0\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_high, WM9081_DRC_3, 3, drc_high_text);\n\nstatic const char *drc_low_text[] = {\n\t\"1\",\n\t\"1/2\",\n\t\"1/4\",\n\t\"1/8\",\n\t\"0\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_low, WM9081_DRC_3, 0, drc_low_text);\n\nstatic const char *drc_atk_text[] = {\n\t\"181us\",\n\t\"181us\",\n\t\"363us\",\n\t\"726us\",\n\t\"1.45ms\",\n\t\"2.9ms\",\n\t\"5.8ms\",\n\t\"11.6ms\",\n\t\"23.2ms\",\n\t\"46.4ms\",\n\t\"92.8ms\",\n\t\"185.6ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_atk, WM9081_DRC_2, 12, drc_atk_text);\n\nstatic const char *drc_dcy_text[] = {\n\t\"186ms\",\n\t\"372ms\",\n\t\"743ms\",\n\t\"1.49s\",\n\t\"2.97s\",\n\t\"5.94s\",\n\t\"11.89s\",\n\t\"23.78s\",\n\t\"47.56s\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_dcy, WM9081_DRC_2, 8, drc_dcy_text);\n\nstatic const char *drc_qr_dcy_text[] = {\n\t\"0.725ms\",\n\t\"1.45ms\",\n\t\"5.8ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_qr_dcy, WM9081_DRC_2, 4, drc_qr_dcy_text);\n\nstatic const char *dac_deemph_text[] = {\n\t\"None\",\n\t\"32kHz\",\n\t\"44.1kHz\",\n\t\"48kHz\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dac_deemph, WM9081_DAC_DIGITAL_2, 1,\n\t\t\t    dac_deemph_text);\n\nstatic const char *speaker_mode_text[] = {\n\t\"Class D\",\n\t\"Class AB\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(speaker_mode, WM9081_ANALOGUE_SPEAKER_2, 6,\n\t\t\t    speaker_mode_text);\n\nstatic int speaker_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM9081_ANALOGUE_SPEAKER_2);\n\tif (reg & WM9081_SPK_MODE)\n\t\tucontrol->value.enumerated.item[0] = 1;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\n\treturn 0;\n}\n\n \nstatic int speaker_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg_pwr = snd_soc_component_read(component, WM9081_POWER_MANAGEMENT);\n\tunsigned int reg2 = snd_soc_component_read(component, WM9081_ANALOGUE_SPEAKER_2);\n\n\t \n\tif (ucontrol->value.enumerated.item[0] ==\n\t    ((reg2 & WM9081_SPK_MODE) != 0))\n\t\treturn 0;\n\n\t \n\tif (reg_pwr & WM9081_SPK_ENA)\n\t\treturn -EINVAL;\n\n\tif (ucontrol->value.enumerated.item[0]) {\n\t\t \n\t\treg2 &= ~(WM9081_SPK_INV_MUTE | WM9081_OUT_SPK_CTRL);\n\t\treg2 |= WM9081_SPK_MODE;\n\t} else {\n\t\t \n\t\treg2 |= WM9081_SPK_INV_MUTE | WM9081_OUT_SPK_CTRL;\n\t\treg2 &= ~WM9081_SPK_MODE;\n\t}\n\n\tsnd_soc_component_write(component, WM9081_ANALOGUE_SPEAKER_2, reg2);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new wm9081_snd_controls[] = {\nSOC_SINGLE_TLV(\"IN1 Volume\", WM9081_ANALOGUE_MIXER, 1, 1, 1, in_tlv),\nSOC_SINGLE_TLV(\"IN2 Volume\", WM9081_ANALOGUE_MIXER, 3, 1, 1, in_tlv),\n\nSOC_SINGLE_TLV(\"Playback Volume\", WM9081_DAC_DIGITAL_1, 1, 96, 0, dac_tlv),\n\nSOC_SINGLE(\"LINEOUT Switch\", WM9081_ANALOGUE_LINEOUT, 7, 1, 1),\nSOC_SINGLE(\"LINEOUT ZC Switch\", WM9081_ANALOGUE_LINEOUT, 6, 1, 0),\nSOC_SINGLE_TLV(\"LINEOUT Volume\", WM9081_ANALOGUE_LINEOUT, 0, 63, 0, out_tlv),\n\nSOC_SINGLE(\"DRC Switch\", WM9081_DRC_1, 15, 1, 0),\nSOC_ENUM(\"DRC High Slope\", drc_high),\nSOC_ENUM(\"DRC Low Slope\", drc_low),\nSOC_SINGLE_TLV(\"DRC Input Volume\", WM9081_DRC_4, 5, 60, 1, drc_in_tlv),\nSOC_SINGLE_TLV(\"DRC Output Volume\", WM9081_DRC_4, 0, 30, 1, drc_out_tlv),\nSOC_SINGLE_TLV(\"DRC Minimum Volume\", WM9081_DRC_2, 2, 3, 1, drc_min_tlv),\nSOC_SINGLE_TLV(\"DRC Maximum Volume\", WM9081_DRC_2, 0, 3, 0, drc_max_tlv),\nSOC_ENUM(\"DRC Attack\", drc_atk),\nSOC_ENUM(\"DRC Decay\", drc_dcy),\nSOC_SINGLE(\"DRC Quick Release Switch\", WM9081_DRC_1, 2, 1, 0),\nSOC_SINGLE_TLV(\"DRC Quick Release Volume\", WM9081_DRC_2, 6, 3, 0, drc_qr_tlv),\nSOC_ENUM(\"DRC Quick Release Decay\", drc_qr_dcy),\nSOC_SINGLE_TLV(\"DRC Startup Volume\", WM9081_DRC_1, 6, 18, 0, drc_startup_tlv),\n\nSOC_SINGLE(\"EQ Switch\", WM9081_EQ_1, 0, 1, 0),\n\nSOC_SINGLE(\"Speaker DC Volume\", WM9081_ANALOGUE_SPEAKER_1, 3, 5, 0),\nSOC_SINGLE(\"Speaker AC Volume\", WM9081_ANALOGUE_SPEAKER_1, 0, 5, 0),\nSOC_SINGLE(\"Speaker Switch\", WM9081_ANALOGUE_SPEAKER_PGA, 7, 1, 1),\nSOC_SINGLE(\"Speaker ZC Switch\", WM9081_ANALOGUE_SPEAKER_PGA, 6, 1, 0),\nSOC_SINGLE_TLV(\"Speaker Volume\", WM9081_ANALOGUE_SPEAKER_PGA, 0, 63, 0,\n\t       out_tlv),\nSOC_ENUM(\"DAC Deemphasis\", dac_deemph),\nSOC_ENUM_EXT(\"Speaker Mode\", speaker_mode, speaker_mode_get, speaker_mode_put),\n};\n\nstatic const struct snd_kcontrol_new wm9081_eq_controls[] = {\nSOC_SINGLE_TLV(\"EQ1 Volume\", WM9081_EQ_1, 11, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Volume\", WM9081_EQ_1, 6, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Volume\", WM9081_EQ_1, 1, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Volume\", WM9081_EQ_2, 11, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ5 Volume\", WM9081_EQ_2, 6, 24, 0, eq_tlv),\n};\n\nstatic const struct snd_kcontrol_new mixer[] = {\nSOC_DAPM_SINGLE(\"IN1 Switch\", WM9081_ANALOGUE_MIXER, 0, 1, 0),\nSOC_DAPM_SINGLE(\"IN2 Switch\", WM9081_ANALOGUE_MIXER, 2, 1, 0),\nSOC_DAPM_SINGLE(\"Playback Switch\", WM9081_ANALOGUE_MIXER, 4, 1, 0),\n};\n\nstruct _fll_div {\n\tu16 fll_fratio;\n\tu16 fll_outdiv;\n\tu16 fll_clk_ref_div;\n\tu16 n;\n\tu16 k;\n};\n\n \n#define FIXED_FLL_SIZE ((1 << 16) * 10)\n\nstatic struct {\n\tunsigned int min;\n\tunsigned int max;\n\tu16 fll_fratio;\n\tint ratio;\n} fll_fratios[] = {\n\t{       0,    64000, 4, 16 },\n\t{   64000,   128000, 3,  8 },\n\t{  128000,   256000, 2,  4 },\n\t{  256000,  1000000, 1,  2 },\n\t{ 1000000, 13500000, 0,  1 },\n};\n\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\n\t\t       unsigned int Fout)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod, target;\n\tunsigned int div;\n\tint i;\n\n\t \n\tdiv = 1;\n\twhile ((Fref / div) > 13500000) {\n\t\tdiv *= 2;\n\n\t\tif (div > 8) {\n\t\t\tpr_err(\"Can't scale %dMHz input down to <=13.5MHz\\n\",\n\t\t\t       Fref);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfll_div->fll_clk_ref_div = div / 2;\n\n\tpr_debug(\"Fref=%u Fout=%u\\n\", Fref, Fout);\n\n\t \n\tFref /= div;\n\n\t \n\tdiv = 0;\n\ttarget = Fout * 2;\n\twhile (target < 90000000) {\n\t\tdiv++;\n\t\ttarget *= 2;\n\t\tif (div > 7) {\n\t\t\tpr_err(\"Unable to find FLL_OUTDIV for Fout=%uHz\\n\",\n\t\t\t       Fout);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tfll_div->fll_outdiv = div;\n\n\tpr_debug(\"Fvco=%dHz\\n\", target);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\n\t\tif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\n\t\t\tfll_div->fll_fratio = fll_fratios[i].fll_fratio;\n\t\t\ttarget /= fll_fratios[i].ratio;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(fll_fratios)) {\n\t\tpr_err(\"Unable to find FLL_FRATIO for Fref=%uHz\\n\", Fref);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tNdiv = target / Fref;\n\n\tfll_div->n = Ndiv;\n\tNmod = target % Fref;\n\tpr_debug(\"Nmod=%d\\n\", Nmod);\n\n\t \n\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, Fref);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tfll_div->k = K / 10;\n\n\tpr_debug(\"N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\\n\",\n\t\t fll_div->n, fll_div->k,\n\t\t fll_div->fll_fratio, fll_div->fll_outdiv,\n\t\t fll_div->fll_clk_ref_div);\n\n\treturn 0;\n}\n\nstatic int wm9081_set_fll(struct snd_soc_component *component, int fll_id,\n\t\t\t  unsigned int Fref, unsigned int Fout)\n{\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\tu16 reg1, reg4, reg5;\n\tstruct _fll_div fll_div;\n\tint ret;\n\tint clk_sys_reg;\n\n\t \n\tif (Fref == wm9081->fll_fref && Fout == wm9081->fll_fout)\n\t\treturn 0;\n\n\t \n\tif (Fout == 0) {\n\t\tdev_dbg(component->dev, \"FLL disabled\\n\");\n\t\twm9081->fll_fref = 0;\n\t\twm9081->fll_fout = 0;\n\n\t\treturn 0;\n\t}\n\n\tret = fll_factors(&fll_div, Fref, Fout);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treg5 = snd_soc_component_read(component, WM9081_FLL_CONTROL_5);\n\treg5 &= ~WM9081_FLL_CLK_SRC_MASK;\n\n\tswitch (fll_id) {\n\tcase WM9081_SYSCLK_FLL_MCLK:\n\t\treg5 |= 0x1;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown FLL ID %d\\n\", fll_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tclk_sys_reg = snd_soc_component_read(component, WM9081_CLOCK_CONTROL_3);\n\tif (clk_sys_reg & WM9081_CLK_SYS_ENA)\n\t\tsnd_soc_component_write(component, WM9081_CLOCK_CONTROL_3,\n\t\t\t     clk_sys_reg & ~WM9081_CLK_SYS_ENA);\n\n\t \n\treg1 = snd_soc_component_read(component, WM9081_FLL_CONTROL_1);\n\treg1 &= ~WM9081_FLL_ENA;\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_1, reg1);\n\n\t \n\tif (fll_div.k)\n\t\treg1 |= WM9081_FLL_FRAC_MASK;\n\telse\n\t\treg1 &= ~WM9081_FLL_FRAC_MASK;\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_1, reg1);\n\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_2,\n\t\t     (fll_div.fll_outdiv << WM9081_FLL_OUTDIV_SHIFT) |\n\t\t     (fll_div.fll_fratio << WM9081_FLL_FRATIO_SHIFT));\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_3, fll_div.k);\n\n\treg4 = snd_soc_component_read(component, WM9081_FLL_CONTROL_4);\n\treg4 &= ~WM9081_FLL_N_MASK;\n\treg4 |= fll_div.n << WM9081_FLL_N_SHIFT;\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_4, reg4);\n\n\treg5 &= ~WM9081_FLL_CLK_REF_DIV_MASK;\n\treg5 |= fll_div.fll_clk_ref_div << WM9081_FLL_CLK_REF_DIV_SHIFT;\n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_5, reg5);\n\n\t \n\tsnd_soc_component_update_bits(component, WM9081_FLL_CONTROL_4,\n\t\t\t    WM9081_FLL_GAIN_MASK, 0);\n\n\t \n\tsnd_soc_component_write(component, WM9081_FLL_CONTROL_1, reg1 | WM9081_FLL_ENA);\n\n\t \n\tif (clk_sys_reg & WM9081_CLK_SYS_ENA)\n\t\tsnd_soc_component_write(component, WM9081_CLOCK_CONTROL_3, clk_sys_reg);\n\n\tdev_dbg(component->dev, \"FLL enabled at %dHz->%dHz\\n\", Fref, Fout);\n\n\twm9081->fll_fref = Fref;\n\twm9081->fll_fout = Fout;\n\n\treturn 0;\n}\n\nstatic int configure_clock(struct snd_soc_component *component)\n{\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\tint new_sysclk, i, target;\n\tunsigned int reg;\n\tint ret = 0;\n\tint mclkdiv = 0;\n\tint fll = 0;\n\n\tswitch (wm9081->sysclk_source) {\n\tcase WM9081_SYSCLK_MCLK:\n\t\tif (wm9081->mclk_rate > 12225000) {\n\t\t\tmclkdiv = 1;\n\t\t\twm9081->sysclk_rate = wm9081->mclk_rate / 2;\n\t\t} else {\n\t\t\twm9081->sysclk_rate = wm9081->mclk_rate;\n\t\t}\n\t\twm9081_set_fll(component, WM9081_SYSCLK_FLL_MCLK, 0, 0);\n\t\tbreak;\n\n\tcase WM9081_SYSCLK_FLL_MCLK:\n\t\t \n\t\tif (wm9081->master && wm9081->bclk) {\n\t\t\t \n\t\t\tfor (i = 0; i < ARRAY_SIZE(clk_sys_rates); i++) {\n\t\t\t\ttarget = wm9081->fs * clk_sys_rates[i].ratio;\n\t\t\t\tnew_sysclk = target;\n\t\t\t\tif (target >= wm9081->bclk &&\n\t\t\t\t    target > 3000000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == ARRAY_SIZE(clk_sys_rates))\n\t\t\t\treturn -EINVAL;\n\n\t\t} else if (wm9081->fs) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(clk_sys_rates); i++) {\n\t\t\t\tnew_sysclk = clk_sys_rates[i].ratio\n\t\t\t\t\t* wm9081->fs;\n\t\t\t\tif (new_sysclk > 3000000)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == ARRAY_SIZE(clk_sys_rates))\n\t\t\t\treturn -EINVAL;\n\n\t\t} else {\n\t\t\tnew_sysclk = 12288000;\n\t\t}\n\n\t\tret = wm9081_set_fll(component, WM9081_SYSCLK_FLL_MCLK,\n\t\t\t\t     wm9081->mclk_rate, new_sysclk);\n\t\tif (ret == 0) {\n\t\t\twm9081->sysclk_rate = new_sysclk;\n\n\t\t\t \n\t\t\tfll = 1;\n\t\t} else {\n\t\t\twm9081->sysclk_rate = wm9081->mclk_rate;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg = snd_soc_component_read(component, WM9081_CLOCK_CONTROL_1);\n\tif (mclkdiv)\n\t\treg |= WM9081_MCLKDIV2;\n\telse\n\t\treg &= ~WM9081_MCLKDIV2;\n\tsnd_soc_component_write(component, WM9081_CLOCK_CONTROL_1, reg);\n\n\treg = snd_soc_component_read(component, WM9081_CLOCK_CONTROL_3);\n\tif (fll)\n\t\treg |= WM9081_CLK_SRC_SEL;\n\telse\n\t\treg &= ~WM9081_CLK_SRC_SEL;\n\tsnd_soc_component_write(component, WM9081_CLOCK_CONTROL_3, reg);\n\n\tdev_dbg(component->dev, \"CLK_SYS is %dHz\\n\", wm9081->sysclk_rate);\n\n\treturn ret;\n}\n\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\n\t \n\tswitch (wm9081->sysclk_source) {\n\tcase WM9081_SYSCLK_MCLK:\n\t\tdev_dbg(component->dev, \"Using %dHz MCLK\\n\", wm9081->mclk_rate);\n\t\tbreak;\n\tcase WM9081_SYSCLK_FLL_MCLK:\n\t\tdev_dbg(component->dev, \"Using %dHz MCLK with FLL\\n\",\n\t\t\twm9081->mclk_rate);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"System clock not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tconfigure_clock(component);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\twm9081_set_fll(component, 0, 0, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget wm9081_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"IN1\"),\nSND_SOC_DAPM_INPUT(\"IN2\"),\n\nSND_SOC_DAPM_DAC(\"DAC\", NULL, WM9081_POWER_MANAGEMENT, 0, 0),\n\nSND_SOC_DAPM_MIXER_NAMED_CTL(\"Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t     mixer, ARRAY_SIZE(mixer)),\n\nSND_SOC_DAPM_PGA(\"LINEOUT PGA\", WM9081_POWER_MANAGEMENT, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"Speaker PGA\", WM9081_POWER_MANAGEMENT, 2, 0, NULL, 0),\nSND_SOC_DAPM_OUT_DRV(\"Speaker\", WM9081_POWER_MANAGEMENT, 1, 0, NULL, 0),\n\nSND_SOC_DAPM_OUTPUT(\"LINEOUT\"),\nSND_SOC_DAPM_OUTPUT(\"SPKN\"),\nSND_SOC_DAPM_OUTPUT(\"SPKP\"),\n\nSND_SOC_DAPM_SUPPLY(\"CLK_SYS\", WM9081_CLOCK_CONTROL_3, 0, 0, clk_sys_event,\n\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_SUPPLY(\"CLK_DSP\", WM9081_CLOCK_CONTROL_3, 1, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"TOCLK\", WM9081_CLOCK_CONTROL_3, 2, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"TSENSE\", WM9081_POWER_MANAGEMENT, 7, 0, NULL, 0),\n};\n\n\nstatic const struct snd_soc_dapm_route wm9081_audio_paths[] = {\n\t{ \"DAC\", NULL, \"CLK_SYS\" },\n\t{ \"DAC\", NULL, \"CLK_DSP\" },\n\t{ \"DAC\", NULL, \"AIF\" },\n\n\t{ \"Mixer\", \"IN1 Switch\", \"IN1\" },\n\t{ \"Mixer\", \"IN2 Switch\", \"IN2\" },\n\t{ \"Mixer\", \"Playback Switch\", \"DAC\" },\n\n\t{ \"LINEOUT PGA\", NULL, \"Mixer\" },\n\t{ \"LINEOUT PGA\", NULL, \"TOCLK\" },\n\t{ \"LINEOUT PGA\", NULL, \"CLK_SYS\" },\n\n\t{ \"LINEOUT\", NULL, \"LINEOUT PGA\" },\n\n\t{ \"Speaker PGA\", NULL, \"Mixer\" },\n\t{ \"Speaker PGA\", NULL, \"TOCLK\" },\n\t{ \"Speaker PGA\", NULL, \"CLK_SYS\" },\n\n\t{ \"Speaker\", NULL, \"Speaker PGA\" },\n\t{ \"Speaker\", NULL, \"TSENSE\" },\n\n\t{ \"SPKN\", NULL, \"Speaker\" },\n\t{ \"SPKP\", NULL, \"Speaker\" },\n};\n\nstatic int wm9081_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_VMID_CONTROL,\n\t\t\t\t    WM9081_VMID_SEL_MASK, 0x2);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_BIAS_CONTROL_1,\n\t\t\t\t    WM9081_STBY_BIAS_ENA, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tregcache_cache_only(wm9081->regmap, false);\n\t\t\tregcache_sync(wm9081->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM9081_ANTI_POP_CONTROL,\n\t\t\t\t\t    WM9081_LINEOUT_DISCH, 0);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM9081_BIAS_CONTROL_1,\n\t\t\t\t\t    WM9081_BIAS_SRC | WM9081_BIAS_ENA,\n\t\t\t\t\t    WM9081_BIAS_SRC | WM9081_BIAS_ENA);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM9081_VMID_CONTROL,\n\t\t\t\t\t    WM9081_VMID_RAMP |\n\t\t\t\t\t    WM9081_VMID_SEL_MASK,\n\t\t\t\t\t    WM9081_VMID_RAMP | 0x6);\n\n\t\t\tmdelay(100);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM9081_VMID_CONTROL,\n\t\t\t\t\t    WM9081_VMID_RAMP, 0);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM9081_BIAS_CONTROL_1,\n\t\t\t\t\t    WM9081_BIAS_SRC, 0);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_VMID_CONTROL,\n\t\t\t\t    WM9081_VMID_SEL_MASK, 0x04);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_BIAS_CONTROL_1,\n\t\t\t\t    WM9081_STBY_BIAS_ENA,\n\t\t\t\t    WM9081_STBY_BIAS_ENA);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_BIAS_CONTROL_1,\n\t\t\t\t    WM9081_BIAS_SRC | WM9081_BIAS_ENA,\n\t\t\t\t    WM9081_BIAS_SRC);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_VMID_CONTROL,\n\t\t\t\t    WM9081_VMID_RAMP | WM9081_VMID_SEL_MASK,\n\t\t\t\t    WM9081_VMID_RAMP);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9081_ANTI_POP_CONTROL,\n\t\t\t\t    WM9081_LINEOUT_DISCH,\n\t\t\t\t    WM9081_LINEOUT_DISCH);\n\n\t\tregcache_cache_only(wm9081->regmap, true);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm9081_set_dai_fmt(struct snd_soc_dai *dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\tunsigned int aif2 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_2);\n\n\taif2 &= ~(WM9081_AIF_BCLK_INV | WM9081_AIF_LRCLK_INV |\n\t\t  WM9081_BCLK_DIR | WM9081_LRCLK_DIR | WM9081_AIF_FMT_MASK);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\twm9081->master = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\taif2 |= WM9081_LRCLK_DIR;\n\t\twm9081->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\taif2 |= WM9081_BCLK_DIR;\n\t\twm9081->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif2 |= WM9081_LRCLK_DIR | WM9081_BCLK_DIR;\n\t\twm9081->master = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif2 |= WM9081_AIF_LRCLK_INV;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif2 |= 0x3;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif2 |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif2 |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif2 |= WM9081_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif2 |= WM9081_AIF_BCLK_INV | WM9081_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif2 |= WM9081_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif2 |= WM9081_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM9081_AUDIO_INTERFACE_2, aif2);\n\n\treturn 0;\n}\n\nstatic int wm9081_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\tint ret, i, best, best_val, cur_val;\n\tunsigned int clk_ctrl2, aif1, aif2, aif3, aif4;\n\n\tclk_ctrl2 = snd_soc_component_read(component, WM9081_CLOCK_CONTROL_2);\n\tclk_ctrl2 &= ~(WM9081_CLK_SYS_RATE_MASK | WM9081_SAMPLE_RATE_MASK);\n\n\taif1 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_1);\n\n\taif2 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_2);\n\taif2 &= ~WM9081_AIF_WL_MASK;\n\n\taif3 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_3);\n\taif3 &= ~WM9081_BCLK_DIV_MASK;\n\n\taif4 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_4);\n\taif4 &= ~WM9081_LRCLK_RATE_MASK;\n\n\twm9081->fs = params_rate(params);\n\n\tif (wm9081->tdm_width) {\n\t\t \n\t\tint slots = ((aif1 & WM9081_AIFDAC_TDM_MODE_MASK) >>\n\t\t\t     WM9081_AIFDAC_TDM_MODE_SHIFT) + 1;\n\n\t\twm9081->bclk = wm9081->fs * wm9081->tdm_width * slots;\n\t} else {\n\t\t \n\t\twm9081->bclk = 2 * wm9081->fs;\n\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\twm9081->bclk *= 16;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\twm9081->bclk *= 20;\n\t\t\taif2 |= 0x4;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\twm9081->bclk *= 24;\n\t\t\taif2 |= 0x8;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\twm9081->bclk *= 32;\n\t\t\taif2 |= 0xc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"Target BCLK is %dHz\\n\", wm9081->bclk);\n\n\tret = configure_clock(component);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tbest = 0;\n\tbest_val = abs((wm9081->sysclk_rate / clk_sys_rates[0].ratio)\n\t\t       - wm9081->fs);\n\tfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\n\t\tcur_val = abs((wm9081->sysclk_rate /\n\t\t\t       clk_sys_rates[i].ratio) - wm9081->fs);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected CLK_SYS_RATIO of %d\\n\",\n\t\tclk_sys_rates[best].ratio);\n\tclk_ctrl2 |= (clk_sys_rates[best].clk_sys_rate\n\t\t      << WM9081_CLK_SYS_RATE_SHIFT);\n\n\t \n\tbest = 0;\n\tbest_val = abs(wm9081->fs - sample_rates[0].rate);\n\tfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\n\t\t \n\t\tcur_val = abs(wm9081->fs - sample_rates[i].rate);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected SAMPLE_RATE of %dHz\\n\",\n\t\tsample_rates[best].rate);\n\tclk_ctrl2 |= (sample_rates[best].sample_rate\n\t\t\t<< WM9081_SAMPLE_RATE_SHIFT);\n\n\t \n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\n\t\tcur_val = ((wm9081->sysclk_rate * 10) / bclk_divs[i].div)\n\t\t\t- wm9081->bclk;\n\t\tif (cur_val < 0)  \n\t\t\tbreak;\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\twm9081->bclk = (wm9081->sysclk_rate * 10) / bclk_divs[best].div;\n\tdev_dbg(component->dev, \"Selected BCLK_DIV of %d for %dHz BCLK\\n\",\n\t\tbclk_divs[best].div, wm9081->bclk);\n\taif3 |= bclk_divs[best].bclk_div;\n\n\t \n\tdev_dbg(component->dev, \"LRCLK_RATE is %d\\n\", wm9081->bclk / wm9081->fs);\n\taif4 |= wm9081->bclk / wm9081->fs;\n\n\t \n\tif (wm9081->pdata.num_retune_configs) {\n\t\tstruct wm9081_pdata *pdata = &wm9081->pdata;\n\t\tstruct wm9081_retune_mobile_setting *s;\n\t\tint eq1;\n\n\t\tbest = 0;\n\t\tbest_val = abs(pdata->retune_configs[0].rate - wm9081->fs);\n\t\tfor (i = 0; i < pdata->num_retune_configs; i++) {\n\t\t\tcur_val = abs(pdata->retune_configs[i].rate -\n\t\t\t\t      wm9081->fs);\n\t\t\tif (cur_val < best_val) {\n\t\t\t\tbest_val = cur_val;\n\t\t\t\tbest = i;\n\t\t\t}\n\t\t}\n\t\ts = &pdata->retune_configs[best];\n\n\t\tdev_dbg(component->dev, \"ReTune Mobile %s tuned for %dHz\\n\",\n\t\t\ts->name, s->rate);\n\n\t\t \n\t\teq1 = snd_soc_component_read(component, WM9081_EQ_1) & WM9081_EQ_ENA;\n\t\tif (eq1 & WM9081_EQ_ENA)\n\t\t\tsnd_soc_component_write(component, WM9081_EQ_1, 0);\n\n\t\t \n\t\tfor (i = 1; i < ARRAY_SIZE(s->config); i++)\n\t\t\tsnd_soc_component_write(component, WM9081_EQ_1 + i, s->config[i]);\n\n\t\teq1 |= (s->config[0] & ~WM9081_EQ_ENA);\n\t\tsnd_soc_component_write(component, WM9081_EQ_1, eq1);\n\t}\n\n\tsnd_soc_component_write(component, WM9081_CLOCK_CONTROL_2, clk_ctrl2);\n\tsnd_soc_component_write(component, WM9081_AUDIO_INTERFACE_2, aif2);\n\tsnd_soc_component_write(component, WM9081_AUDIO_INTERFACE_3, aif3);\n\tsnd_soc_component_write(component, WM9081_AUDIO_INTERFACE_4, aif4);\n\n\treturn 0;\n}\n\nstatic int wm9081_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM9081_DAC_DIGITAL_2);\n\n\tif (mute)\n\t\treg |= WM9081_DAC_MUTE;\n\telse\n\t\treg &= ~WM9081_DAC_MUTE;\n\n\tsnd_soc_component_write(component, WM9081_DAC_DIGITAL_2, reg);\n\n\treturn 0;\n}\n\nstatic int wm9081_set_sysclk(struct snd_soc_component *component, int clk_id,\n\t\t\t     int source, unsigned int freq, int dir)\n{\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM9081_SYSCLK_MCLK:\n\tcase WM9081_SYSCLK_FLL_MCLK:\n\t\twm9081->sysclk_source = clk_id;\n\t\twm9081->mclk_rate = freq;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm9081_set_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\tunsigned int aif1 = snd_soc_component_read(component, WM9081_AUDIO_INTERFACE_1);\n\n\taif1 &= ~(WM9081_AIFDAC_TDM_SLOT_MASK | WM9081_AIFDAC_TDM_MODE_MASK);\n\n\tif (slots < 0 || slots > 4)\n\t\treturn -EINVAL;\n\n\twm9081->tdm_width = slot_width;\n\n\tif (slots == 0)\n\t\tslots = 1;\n\n\taif1 |= (slots - 1) << WM9081_AIFDAC_TDM_MODE_SHIFT;\n\n\tswitch (rx_mask) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\taif1 |= 0x10;\n\t\tbreak;\n\tcase 4:\n\t\taif1 |= 0x20;\n\t\tbreak;\n\tcase 8:\n\t\taif1 |= 0x30;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM9081_AUDIO_INTERFACE_1, aif1);\n\n\treturn 0;\n}\n\n#define WM9081_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM9081_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm9081_dai_ops = {\n\t.hw_params = wm9081_hw_params,\n\t.set_fmt = wm9081_set_dai_fmt,\n\t.mute_stream = wm9081_mute,\n\t.set_tdm_slot = wm9081_set_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\n \nstatic struct snd_soc_dai_driver wm9081_dai = {\n\t.name = \"wm9081-hifi\",\n\t.playback = {\n\t\t.stream_name = \"AIF\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM9081_RATES,\n\t\t.formats = WM9081_FORMATS,\n\t},\n\t.ops = &wm9081_dai_ops,\n};\n\nstatic int wm9081_probe(struct snd_soc_component *component)\n{\n\tstruct wm9081_priv *wm9081 = snd_soc_component_get_drvdata(component);\n\n\t \n\tsnd_soc_component_update_bits(component, WM9081_ANALOGUE_LINEOUT,\n\t\t\t    WM9081_LINEOUTZC, WM9081_LINEOUTZC);\n\tsnd_soc_component_update_bits(component, WM9081_ANALOGUE_SPEAKER_PGA,\n\t\t\t    WM9081_SPKPGAZC, WM9081_SPKPGAZC);\n\n\tif (!wm9081->pdata.num_retune_configs) {\n\t\tdev_dbg(component->dev,\n\t\t\t\"No ReTune Mobile data, using normal EQ\\n\");\n\t\tsnd_soc_add_component_controls(component, wm9081_eq_controls,\n\t\t\t\t     ARRAY_SIZE(wm9081_eq_controls));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm9081 = {\n\t.probe\t\t\t= wm9081_probe,\n\t.set_sysclk\t\t= wm9081_set_sysclk,\n\t.set_bias_level\t\t= wm9081_set_bias_level,\n\t.controls\t\t= wm9081_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm9081_snd_controls),\n\t.dapm_widgets\t\t= wm9081_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm9081_dapm_widgets),\n\t.dapm_routes\t\t= wm9081_audio_paths,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm9081_audio_paths),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm9081_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM9081_MAX_REGISTER,\n\t.reg_defaults = wm9081_reg,\n\t.num_reg_defaults = ARRAY_SIZE(wm9081_reg),\n\t.volatile_reg = wm9081_volatile_register,\n\t.readable_reg = wm9081_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int wm9081_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm9081_priv *wm9081;\n\tunsigned int reg;\n\tint ret;\n\n\twm9081 = devm_kzalloc(&i2c->dev, sizeof(struct wm9081_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm9081 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm9081);\n\n\twm9081->regmap = devm_regmap_init_i2c(i2c, &wm9081_regmap);\n\tif (IS_ERR(wm9081->regmap)) {\n\t\tret = PTR_ERR(wm9081->regmap);\n\t\tdev_err(&i2c->dev, \"regmap_init() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm9081->regmap, WM9081_SOFTWARE_RESET, &reg);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read chip ID: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (reg != 0x9081) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM9081: ID=0x%x\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\n\tret = wm9081_reset(wm9081->regmap);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset\\n\");\n\t\treturn ret;\n\t}\n\n\tif (dev_get_platdata(&i2c->dev))\n\t\tmemcpy(&wm9081->pdata, dev_get_platdata(&i2c->dev),\n\t\t       sizeof(wm9081->pdata));\n\n\treg = 0;\n\tif (wm9081->pdata.irq_high)\n\t\treg |= WM9081_IRQ_POL;\n\tif (!wm9081->pdata.irq_cmos)\n\t\treg |= WM9081_IRQ_OP_CTRL;\n\tregmap_update_bits(wm9081->regmap, WM9081_INTERRUPT_CONTROL,\n\t\t\t   WM9081_IRQ_POL | WM9081_IRQ_OP_CTRL, reg);\n\n\tregcache_cache_only(wm9081->regmap, true);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm9081, &wm9081_dai, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void wm9081_i2c_remove(struct i2c_client *client)\n{}\n\nstatic const struct i2c_device_id wm9081_i2c_id[] = {\n\t{ \"wm9081\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm9081_i2c_id);\n\nstatic struct i2c_driver wm9081_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm9081\",\n\t},\n\t.probe =    wm9081_i2c_probe,\n\t.remove =   wm9081_i2c_remove,\n\t.id_table = wm9081_i2c_id,\n};\n\nmodule_i2c_driver(wm9081_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM9081 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}