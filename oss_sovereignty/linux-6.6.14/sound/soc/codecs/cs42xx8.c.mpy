{
  "module_name": "cs42xx8.c",
  "hash_id": "a89b443f41945244717a252fc6e5684a02dc319ff68881a82b49a2b069fea608",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42xx8.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"cs42xx8.h\"\n\n#define CS42XX8_NUM_SUPPLIES 4\nstatic const char *const cs42xx8_supply_names[CS42XX8_NUM_SUPPLIES] = {\n\t\"VA\",\n\t\"VD\",\n\t\"VLS\",\n\t\"VLC\",\n};\n\n#define CS42XX8_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n\n \nstruct cs42xx8_priv {\n\tstruct regulator_bulk_data supplies[CS42XX8_NUM_SUPPLIES];\n\tconst struct cs42xx8_driver_data *drvdata;\n\tstruct regmap *regmap;\n\tstruct clk *clk;\n\n\tbool slave_mode;\n\tunsigned long sysclk;\n\tu32 tx_channels;\n\tstruct gpio_desc *gpiod_reset;\n\tu32 rate[2];\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\n \nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -6400, 50, 0);\n\nstatic const char *const cs42xx8_adc_single[] = { \"Differential\", \"Single-Ended\" };\nstatic const char *const cs42xx8_szc[] = { \"Immediate Change\", \"Zero Cross\",\n\t\t\t\t\t\"Soft Ramp\", \"Soft Ramp on Zero Cross\" };\n\nstatic const struct soc_enum adc1_single_enum =\n\tSOC_ENUM_SINGLE(CS42XX8_ADCCTL, 4, 2, cs42xx8_adc_single);\nstatic const struct soc_enum adc2_single_enum =\n\tSOC_ENUM_SINGLE(CS42XX8_ADCCTL, 3, 2, cs42xx8_adc_single);\nstatic const struct soc_enum adc3_single_enum =\n\tSOC_ENUM_SINGLE(CS42XX8_ADCCTL, 2, 2, cs42xx8_adc_single);\nstatic const struct soc_enum dac_szc_enum =\n\tSOC_ENUM_SINGLE(CS42XX8_TXCTL, 5, 4, cs42xx8_szc);\nstatic const struct soc_enum adc_szc_enum =\n\tSOC_ENUM_SINGLE(CS42XX8_TXCTL, 0, 4, cs42xx8_szc);\n\nstatic const struct snd_kcontrol_new cs42xx8_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC1 Playback Volume\", CS42XX8_VOLAOUT1,\n\t\t\t CS42XX8_VOLAOUT2, 0, 0xff, 1, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Playback Volume\", CS42XX8_VOLAOUT3,\n\t\t\t CS42XX8_VOLAOUT4, 0, 0xff, 1, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC3 Playback Volume\", CS42XX8_VOLAOUT5,\n\t\t\t CS42XX8_VOLAOUT6, 0, 0xff, 1, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC4 Playback Volume\", CS42XX8_VOLAOUT7,\n\t\t\t CS42XX8_VOLAOUT8, 0, 0xff, 1, dac_tlv),\n\tSOC_DOUBLE_R_S_TLV(\"ADC1 Capture Volume\", CS42XX8_VOLAIN1,\n\t\t\t   CS42XX8_VOLAIN2, 0, -0x80, 0x30, 7, 0, adc_tlv),\n\tSOC_DOUBLE_R_S_TLV(\"ADC2 Capture Volume\", CS42XX8_VOLAIN3,\n\t\t\t   CS42XX8_VOLAIN4, 0, -0x80, 0x30, 7, 0, adc_tlv),\n\tSOC_DOUBLE(\"DAC1 Invert Switch\", CS42XX8_DACINV, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"DAC2 Invert Switch\", CS42XX8_DACINV, 2, 3, 1, 0),\n\tSOC_DOUBLE(\"DAC3 Invert Switch\", CS42XX8_DACINV, 4, 5, 1, 0),\n\tSOC_DOUBLE(\"DAC4 Invert Switch\", CS42XX8_DACINV, 6, 7, 1, 0),\n\tSOC_DOUBLE(\"ADC1 Invert Switch\", CS42XX8_ADCINV, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"ADC2 Invert Switch\", CS42XX8_ADCINV, 2, 3, 1, 0),\n\tSOC_SINGLE(\"ADC High-Pass Filter Switch\", CS42XX8_ADCCTL, 7, 1, 1),\n\tSOC_SINGLE(\"DAC De-emphasis Switch\", CS42XX8_ADCCTL, 5, 1, 0),\n\tSOC_ENUM(\"ADC1 Single Ended Mode Switch\", adc1_single_enum),\n\tSOC_ENUM(\"ADC2 Single Ended Mode Switch\", adc2_single_enum),\n\tSOC_SINGLE(\"DAC Single Volume Control Switch\", CS42XX8_TXCTL, 7, 1, 0),\n\tSOC_ENUM(\"DAC Soft Ramp & Zero Cross Control Switch\", dac_szc_enum),\n\tSOC_SINGLE(\"DAC Auto Mute Switch\", CS42XX8_TXCTL, 4, 1, 0),\n\tSOC_SINGLE(\"Mute ADC Serial Port Switch\", CS42XX8_TXCTL, 3, 1, 0),\n\tSOC_SINGLE(\"ADC Single Volume Control Switch\", CS42XX8_TXCTL, 2, 1, 0),\n\tSOC_ENUM(\"ADC Soft Ramp & Zero Cross Control Switch\", adc_szc_enum),\n};\n\nstatic const struct snd_kcontrol_new cs42xx8_adc3_snd_controls[] = {\n\tSOC_DOUBLE_R_S_TLV(\"ADC3 Capture Volume\", CS42XX8_VOLAIN5,\n\t\t\t   CS42XX8_VOLAIN6, 0, -0x80, 0x30, 7, 0, adc_tlv),\n\tSOC_DOUBLE(\"ADC3 Invert Switch\", CS42XX8_ADCINV, 4, 5, 1, 0),\n\tSOC_ENUM(\"ADC3 Single Ended Mode Switch\", adc3_single_enum),\n};\n\nstatic const struct snd_soc_dapm_widget cs42xx8_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC1\", \"Playback\", CS42XX8_PWRCTL, 1, 1),\n\tSND_SOC_DAPM_DAC(\"DAC2\", \"Playback\", CS42XX8_PWRCTL, 2, 1),\n\tSND_SOC_DAPM_DAC(\"DAC3\", \"Playback\", CS42XX8_PWRCTL, 3, 1),\n\tSND_SOC_DAPM_DAC(\"DAC4\", \"Playback\", CS42XX8_PWRCTL, 4, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"AOUT1L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT1R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT2L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT2R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT3L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT3R\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT4L\"),\n\tSND_SOC_DAPM_OUTPUT(\"AOUT4R\"),\n\n\tSND_SOC_DAPM_ADC(\"ADC1\", \"Capture\", CS42XX8_PWRCTL, 5, 1),\n\tSND_SOC_DAPM_ADC(\"ADC2\", \"Capture\", CS42XX8_PWRCTL, 6, 1),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2R\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PWR\", CS42XX8_PWRCTL, 0, 1, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_widget cs42xx8_adc3_dapm_widgets[] = {\n\tSND_SOC_DAPM_ADC(\"ADC3\", \"Capture\", CS42XX8_PWRCTL, 7, 1),\n\n\tSND_SOC_DAPM_INPUT(\"AIN3L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3R\"),\n};\n\nstatic const struct snd_soc_dapm_route cs42xx8_dapm_routes[] = {\n\t \n\t{ \"AOUT1L\", NULL, \"DAC1\" },\n\t{ \"AOUT1R\", NULL, \"DAC1\" },\n\t{ \"DAC1\", NULL, \"PWR\" },\n\n\t{ \"AOUT2L\", NULL, \"DAC2\" },\n\t{ \"AOUT2R\", NULL, \"DAC2\" },\n\t{ \"DAC2\", NULL, \"PWR\" },\n\n\t{ \"AOUT3L\", NULL, \"DAC3\" },\n\t{ \"AOUT3R\", NULL, \"DAC3\" },\n\t{ \"DAC3\", NULL, \"PWR\" },\n\n\t{ \"AOUT4L\", NULL, \"DAC4\" },\n\t{ \"AOUT4R\", NULL, \"DAC4\" },\n\t{ \"DAC4\", NULL, \"PWR\" },\n\n\t \n\t{ \"ADC1\", NULL, \"AIN1L\" },\n\t{ \"ADC1\", NULL, \"AIN1R\" },\n\t{ \"ADC1\", NULL, \"PWR\" },\n\n\t{ \"ADC2\", NULL, \"AIN2L\" },\n\t{ \"ADC2\", NULL, \"AIN2R\" },\n\t{ \"ADC2\", NULL, \"PWR\" },\n};\n\nstatic const struct snd_soc_dapm_route cs42xx8_adc3_dapm_routes[] = {\n\t \n\t{ \"ADC3\", NULL, \"AIN3L\" },\n\t{ \"ADC3\", NULL, \"AIN3R\" },\n\t{ \"ADC3\", NULL, \"PWR\" },\n};\n\nstruct cs42xx8_ratios {\n\tunsigned int mfreq;\n\tunsigned int min_mclk;\n\tunsigned int max_mclk;\n\tunsigned int ratio[3];\n};\n\n \nstatic const struct cs42xx8_ratios cs42xx8_ratios[] = {\n\t{ 0, 1029000, 12800000, {256, 128, 64} },\n\t{ 2, 1536000, 19200000, {384, 192, 96} },\n\t{ 4, 2048000, 25600000, {512, 256, 128} },\n\t{ 6, 3072000, 38400000, {768, 384, 192} },\n\t{ 8, 4096000, 51200000, {1024, 512, 256} },\n};\n\nstatic int cs42xx8_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\n\tcs42xx8->sysclk = freq;\n\n\treturn 0;\n}\n\nstatic int cs42xx8_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t       unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\tu32 val;\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = CS42XX8_INTF_DAC_DIF_LEFTJ | CS42XX8_INTF_ADC_DIF_LEFTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = CS42XX8_INTF_DAC_DIF_I2S | CS42XX8_INTF_ADC_DIF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = CS42XX8_INTF_DAC_DIF_RIGHTJ | CS42XX8_INTF_ADC_DIF_RIGHTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tval = CS42XX8_INTF_DAC_DIF_TDM | CS42XX8_INTF_ADC_DIF_TDM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs42xx8->regmap, CS42XX8_INTF,\n\t\t\t   CS42XX8_INTF_DAC_DIF_MASK |\n\t\t\t   CS42XX8_INTF_ADC_DIF_MASK, val);\n\n\t \n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs42xx8->slave_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs42xx8->slave_mode = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported master/slave mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs42xx8_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\tu32 ratio[2];\n\tu32 rate[2];\n\tu32 fm[2];\n\tu32 i, val, mask;\n\tbool condition1, condition2;\n\n\tif (tx)\n\t\tcs42xx8->tx_channels = params_channels(params);\n\n\trate[tx]  = params_rate(params);\n\trate[!tx] = cs42xx8->rate[!tx];\n\n\tratio[tx] = rate[tx] > 0 ? cs42xx8->sysclk / rate[tx] : 0;\n\tratio[!tx] = rate[!tx] > 0 ? cs42xx8->sysclk / rate[!tx] : 0;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (cs42xx8->slave_mode) {\n\t\t\tfm[i] = CS42XX8_FM_AUTO;\n\t\t} else {\n\t\t\tif (rate[i] < 50000) {\n\t\t\t\tfm[i] = CS42XX8_FM_SINGLE;\n\t\t\t} else if (rate[i] > 50000 && rate[i] < 100000) {\n\t\t\t\tfm[i] = CS42XX8_FM_DOUBLE;\n\t\t\t} else if (rate[i] > 100000 && rate[i] < 200000) {\n\t\t\t\tfm[i] = CS42XX8_FM_QUAD;\n\t\t\t} else {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"unsupported sample rate\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42xx8_ratios); i++) {\n\t\t \n\t\tcondition1 = ((fm[tx] == CS42XX8_FM_AUTO) ?\n\t\t\t(cs42xx8_ratios[i].ratio[0] == ratio[tx] ||\n\t\t\tcs42xx8_ratios[i].ratio[1] == ratio[tx] ||\n\t\t\tcs42xx8_ratios[i].ratio[2] == ratio[tx]) :\n\t\t\t(cs42xx8_ratios[i].ratio[fm[tx]] == ratio[tx])) &&\n\t\t\tcs42xx8->sysclk >= cs42xx8_ratios[i].min_mclk &&\n\t\t\tcs42xx8->sysclk <= cs42xx8_ratios[i].max_mclk;\n\n\t\tif (!ratio[tx])\n\t\t\tcondition1 = true;\n\n\t\t \n\t\tcondition2 = ((fm[!tx] == CS42XX8_FM_AUTO) ?\n\t\t\t(cs42xx8_ratios[i].ratio[0] == ratio[!tx] ||\n\t\t\tcs42xx8_ratios[i].ratio[1] == ratio[!tx] ||\n\t\t\tcs42xx8_ratios[i].ratio[2] == ratio[!tx]) :\n\t\t\t(cs42xx8_ratios[i].ratio[fm[!tx]] == ratio[!tx]));\n\n\t\tif (!ratio[!tx])\n\t\t\tcondition2 = true;\n\n\t\t \n\t\tif (condition1 && condition2)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(cs42xx8_ratios)) {\n\t\tdev_err(component->dev, \"unsupported sysclk ratio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcs42xx8->rate[tx] = params_rate(params);\n\n\tmask = CS42XX8_FUNCMOD_MFREQ_MASK;\n\tval = cs42xx8_ratios[i].mfreq;\n\n\tregmap_update_bits(cs42xx8->regmap, CS42XX8_FUNCMOD,\n\t\t\t   CS42XX8_FUNCMOD_xC_FM_MASK(tx) | mask,\n\t\t\t   CS42XX8_FUNCMOD_xC_FM(tx, fm[tx]) | val);\n\n\treturn 0;\n}\n\nstatic int cs42xx8_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\tbool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\n\n\t \n\tcs42xx8->rate[tx] = 0;\n\n\tregmap_update_bits(cs42xx8->regmap, CS42XX8_FUNCMOD,\n\t\t\t   CS42XX8_FUNCMOD_xC_FM_MASK(tx),\n\t\t\t   CS42XX8_FUNCMOD_xC_FM(tx, CS42XX8_FM_AUTO));\n\treturn 0;\n}\n\nstatic int cs42xx8_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\tu8 dac_unmute = cs42xx8->tx_channels ?\n\t\t        ~((0x1 << cs42xx8->tx_channels) - 1) : 0;\n\n\tregmap_write(cs42xx8->regmap, CS42XX8_DACMUTE,\n\t\t     mute ? CS42XX8_DACMUTE_ALL : dac_unmute);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs42xx8_dai_ops = {\n\t.set_fmt\t= cs42xx8_set_dai_fmt,\n\t.set_sysclk\t= cs42xx8_set_dai_sysclk,\n\t.hw_params\t= cs42xx8_hw_params,\n\t.hw_free\t= cs42xx8_hw_free,\n\t.mute_stream\t= cs42xx8_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs42xx8_dai = {\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = CS42XX8_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = CS42XX8_FORMATS,\n\t},\n\t.ops = &cs42xx8_dai_ops,\n};\n\nstatic const struct reg_default cs42xx8_reg[] = {\n\t{ 0x02, 0x00 },    \n\t{ 0x03, 0xF0 },    \n\t{ 0x04, 0x46 },    \n\t{ 0x05, 0x00 },    \n\t{ 0x06, 0x10 },    \n\t{ 0x07, 0x00 },    \n\t{ 0x08, 0x00 },    \n\t{ 0x09, 0x00 },    \n\t{ 0x0a, 0x00 },    \n\t{ 0x0b, 0x00 },    \n\t{ 0x0c, 0x00 },    \n\t{ 0x0d, 0x00 },    \n\t{ 0x0e, 0x00 },    \n\t{ 0x0f, 0x00 },    \n\t{ 0x10, 0x00 },    \n\t{ 0x11, 0x00 },    \n\t{ 0x12, 0x00 },    \n\t{ 0x13, 0x00 },    \n\t{ 0x14, 0x00 },    \n\t{ 0x15, 0x00 },    \n\t{ 0x16, 0x00 },    \n\t{ 0x17, 0x00 },    \n\t{ 0x18, 0x00 },    \n\t{ 0x1a, 0x00 },    \n\t{ 0x1b, 0x00 },    \n};\n\nstatic bool cs42xx8_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42XX8_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42xx8_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42XX8_CHIPID:\n\tcase CS42XX8_STATUS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nconst struct regmap_config cs42xx8_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS42XX8_LASTREG,\n\t.reg_defaults = cs42xx8_reg,\n\t.num_reg_defaults = ARRAY_SIZE(cs42xx8_reg),\n\t.volatile_reg = cs42xx8_volatile_register,\n\t.writeable_reg = cs42xx8_writeable_register,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(cs42xx8_regmap_config);\n\nstatic int cs42xx8_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs42xx8_priv *cs42xx8 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tswitch (cs42xx8->drvdata->num_adcs) {\n\tcase 3:\n\t\tsnd_soc_add_component_controls(component, cs42xx8_adc3_snd_controls,\n\t\t\t\t\tARRAY_SIZE(cs42xx8_adc3_snd_controls));\n\t\tsnd_soc_dapm_new_controls(dapm, cs42xx8_adc3_dapm_widgets,\n\t\t\t\t\tARRAY_SIZE(cs42xx8_adc3_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, cs42xx8_adc3_dapm_routes,\n\t\t\t\t\tARRAY_SIZE(cs42xx8_adc3_dapm_routes));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tregmap_write(cs42xx8->regmap, CS42XX8_DACMUTE, CS42XX8_DACMUTE_ALL);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver cs42xx8_driver = {\n\t.probe\t\t\t= cs42xx8_component_probe,\n\t.controls\t\t= cs42xx8_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42xx8_snd_controls),\n\t.dapm_widgets\t\t= cs42xx8_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42xx8_dapm_widgets),\n\t.dapm_routes\t\t= cs42xx8_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42xx8_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nconst struct cs42xx8_driver_data cs42448_data = {\n\t.name = \"cs42448\",\n\t.num_adcs = 3,\n};\nEXPORT_SYMBOL_GPL(cs42448_data);\n\nconst struct cs42xx8_driver_data cs42888_data = {\n\t.name = \"cs42888\",\n\t.num_adcs = 2,\n};\nEXPORT_SYMBOL_GPL(cs42888_data);\n\nint cs42xx8_probe(struct device *dev, struct regmap *regmap, struct cs42xx8_driver_data *drvdata)\n{\n\tstruct cs42xx8_priv *cs42xx8;\n\tint ret, val, i;\n\n\tif (IS_ERR(regmap)) {\n\t\tret = PTR_ERR(regmap);\n\t\tdev_err(dev, \"failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs42xx8 = devm_kzalloc(dev, sizeof(*cs42xx8), GFP_KERNEL);\n\tif (cs42xx8 == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, cs42xx8);\n\n\tcs42xx8->regmap = regmap;\n\n\tcs42xx8->drvdata = drvdata;\n\n\tcs42xx8->gpiod_reset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(cs42xx8->gpiod_reset))\n\t\treturn PTR_ERR(cs42xx8->gpiod_reset);\n\n\tgpiod_set_value_cansleep(cs42xx8->gpiod_reset, 0);\n\n\tcs42xx8->clk = devm_clk_get(dev, \"mclk\");\n\tif (IS_ERR(cs42xx8->clk)) {\n\t\tdev_err(dev, \"failed to get the clock: %ld\\n\",\n\t\t\t\tPTR_ERR(cs42xx8->clk));\n\t\treturn -EINVAL;\n\t}\n\n\tcs42xx8->sysclk = clk_get_rate(cs42xx8->clk);\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42xx8->supplies); i++)\n\t\tcs42xx8->supplies[i].supply = cs42xx8_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev,\n\t\t\tARRAY_SIZE(cs42xx8->supplies), cs42xx8->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42xx8->supplies),\n\t\t\t\t    cs42xx8->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmsleep(5);\n\n\t \n\tret = regmap_read(cs42xx8->regmap, CS42XX8_CHIPID, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get device ID, ret = %d\", ret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\tif (((val & CS42XX8_CHIPID_CHIP_ID_MASK) >> 4) != 0x00) {\n\t\tdev_err(dev, \"unmatched chip ID: %d\\n\",\n\t\t\t(val & CS42XX8_CHIPID_CHIP_ID_MASK) >> 4);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tdev_info(dev, \"found device, revision %X\\n\",\n\t\t\tval & CS42XX8_CHIPID_REV_ID_MASK);\n\n\tcs42xx8_dai.name = cs42xx8->drvdata->name;\n\n\t \n\tcs42xx8_dai.capture.channels_max = cs42xx8->drvdata->num_adcs * 2;\n\n\tret = devm_snd_soc_register_component(dev, &cs42xx8_driver, &cs42xx8_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register component:%d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\tregcache_cache_only(cs42xx8->regmap, true);\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\n\t\t\t       cs42xx8->supplies);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs42xx8_probe);\n\n#ifdef CONFIG_PM\nstatic int cs42xx8_runtime_resume(struct device *dev)\n{\n\tstruct cs42xx8_priv *cs42xx8 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(cs42xx8->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable mclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(cs42xx8->gpiod_reset, 0);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42xx8->supplies),\n\t\t\t\t    cs42xx8->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\t \n\tmsleep(5);\n\n\tregcache_cache_only(cs42xx8->regmap, false);\n\tregcache_mark_dirty(cs42xx8->regmap);\n\n\tret = regcache_sync(cs42xx8->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to sync regmap: %d\\n\", ret);\n\t\tgoto err_bulk;\n\t}\n\n\treturn 0;\n\nerr_bulk:\n\tregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\n\t\t\t       cs42xx8->supplies);\nerr_clk:\n\tclk_disable_unprepare(cs42xx8->clk);\n\n\treturn ret;\n}\n\nstatic int cs42xx8_runtime_suspend(struct device *dev)\n{\n\tstruct cs42xx8_priv *cs42xx8 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs42xx8->regmap, true);\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs42xx8->supplies),\n\t\t\t       cs42xx8->supplies);\n\n\tgpiod_set_value_cansleep(cs42xx8->gpiod_reset, 1);\n\n\tclk_disable_unprepare(cs42xx8->clk);\n\n\treturn 0;\n}\n#endif\n\nconst struct dev_pm_ops cs42xx8_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(cs42xx8_runtime_suspend, cs42xx8_runtime_resume, NULL)\n};\nEXPORT_SYMBOL_GPL(cs42xx8_pm);\n\nMODULE_DESCRIPTION(\"Cirrus Logic CS42448/CS42888 ALSA SoC Codec Driver\");\nMODULE_AUTHOR(\"Freescale Semiconductor, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}