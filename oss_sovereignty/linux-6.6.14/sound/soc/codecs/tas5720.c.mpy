{
  "module_name": "tas5720.c",
  "hash_id": "f747ab9a43b69a6f027a0829673bb6474d95a8e1538f244ce1f1f49506341d5c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tas5720.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/regulator/consumer.h>\n#include <linux/delay.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"tas5720.h\"\n\n \n#define TAS5720_FAULT_CHECK_INTERVAL\t\t200\n\nenum tas572x_type {\n\tTAS5720,\n\tTAS5720A_Q1,\n\tTAS5722,\n};\n\nstatic const char * const tas5720_supply_names[] = {\n\t\"dvdd\",\t\t \n\t\"pvdd\",\t\t \n};\n\n#define TAS5720_NUM_SUPPLIES\tARRAY_SIZE(tas5720_supply_names)\n\nstruct tas5720_data {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\tstruct i2c_client *tas5720_client;\n\tenum tas572x_type devtype;\n\tstruct regulator_bulk_data supplies[TAS5720_NUM_SUPPLIES];\n\tstruct delayed_work fault_check_work;\n\tunsigned int last_fault;\n};\n\nstatic int tas5720_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int rate = params_rate(params);\n\tbool ssz_ds;\n\tint ret;\n\n\tswitch (rate) {\n\tcase 44100:\n\tcase 48000:\n\t\tssz_ds = false;\n\t\tbreak;\n\tcase 88200:\n\tcase 96000:\n\t\tssz_ds = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported sample rate: %u\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS5720_DIGITAL_CTRL1_REG,\n\t\t\t\t  TAS5720_SSZ_DS, ssz_ds);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"error setting sample rate: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tas5720_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu8 serial_format;\n\tint ret;\n\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC) {\n\t\tdev_vdbg(component->dev, \"DAI clocking invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\n\t\t       SND_SOC_DAIFMT_INV_MASK)) {\n\tcase (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF):\n\t\t \n\t\tserial_format = TAS5720_SAIF_I2S;\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_NB_NF):\n\t\t \n\t\tserial_format = TAS5720_SAIF_I2S;\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_NB_NF):\n\t\t \n\t\tserial_format = TAS5720_SAIF_LEFTJ;\n\t\tbreak;\n\tcase (SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF):\n\t\t \n\t\tserial_format = TAS5720_SAIF_LEFTJ;\n\t\tbreak;\n\tdefault:\n\t\tdev_vdbg(component->dev, \"DAI Format is not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = snd_soc_component_update_bits(component, TAS5720_DIGITAL_CTRL1_REG,\n\t\t\t\t  TAS5720_SAIF_FORMAT_MASK,\n\t\t\t\t  serial_format);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"error setting SAIF format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tas5720_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tunsigned int first_slot;\n\tint ret;\n\n\tif (!tx_mask) {\n\t\tdev_err(component->dev, \"tx masks must not be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfirst_slot = __ffs(tx_mask);\n\n\tif (first_slot > 7) {\n\t\tdev_err(component->dev, \"slot selection out of bounds (%u)\\n\",\n\t\t\tfirst_slot);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (tas5720->devtype) {\n\tcase TAS5720A_Q1:\n\t\tbreak;\n\tdefault:\n\t\tret = snd_soc_component_update_bits(component, TAS5720_DIGITAL_CTRL1_REG,\n\t\t\t\t\t  TAS5720_TDM_CFG_SRC, TAS5720_TDM_CFG_SRC);\n\t\tif (ret < 0)\n\t\t\tgoto error_snd_soc_component_update_bits;\n\n\t\t \n\t\tret = snd_soc_component_update_bits(component, TAS5720_DIGITAL_CTRL2_REG,\n\t\t\t\t\t  TAS5720_TDM_SLOT_SEL_MASK, first_slot);\n\t\tif (ret < 0)\n\t\t\tgoto error_snd_soc_component_update_bits;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (tas5720->devtype) {\n\tcase TAS5722:\n\t\tret = snd_soc_component_update_bits(component, TAS5722_DIGITAL_CTRL2_REG,\n\t\t\t\t\t\t    TAS5722_TDM_SLOT_16B,\n\t\t\t\t\t\t    slot_width == 16 ?\n\t\t\t\t\t\t    TAS5722_TDM_SLOT_16B : 0);\n\t\tif (ret < 0)\n\t\t\tgoto error_snd_soc_component_update_bits;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerror_snd_soc_component_update_bits:\n\tdev_err(component->dev, \"error configuring TDM mode: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int tas5720_mute_soc_component(struct snd_soc_component *component, int mute)\n{\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg, mask;\n\tint ret;\n\n\tswitch (tas5720->devtype) {\n\tcase TAS5720A_Q1:\n\t\treg = TAS5720_Q1_VOLUME_CTRL_CFG_REG;\n\t\tmask = TAS5720_Q1_MUTE;\n\t\tbreak;\n\tdefault:\n\t\treg = TAS5720_DIGITAL_CTRL2_REG;\n\t\tmask = TAS5720_MUTE;\n\t\tbreak;\n\t}\n\n\tret = snd_soc_component_update_bits(component, reg, mask, mute ? mask : 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"error (un-)muting device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tas5720_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\treturn tas5720_mute_soc_component(dai->component, mute);\n}\n\nstatic void tas5720_fault_check_work(struct work_struct *work)\n{\n\tstruct tas5720_data *tas5720 = container_of(work, struct tas5720_data,\n\t\t\tfault_check_work.work);\n\tstruct device *dev = tas5720->component->dev;\n\tunsigned int curr_fault;\n\tint ret;\n\n\tret = regmap_read(tas5720->regmap, TAS5720_FAULT_REG, &curr_fault);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read FAULT register: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tcurr_fault &= TAS5720_OCE | TAS5720_DCE | TAS5720_OTE;\n\n\t \n\tif ((curr_fault & TAS5720_OCE) && !(tas5720->last_fault & TAS5720_OCE))\n\t\tdev_crit(dev, \"experienced an over current hardware fault\\n\");\n\n\tif ((curr_fault & TAS5720_DCE) && !(tas5720->last_fault & TAS5720_DCE))\n\t\tdev_crit(dev, \"experienced a DC detection fault\\n\");\n\n\tif ((curr_fault & TAS5720_OTE) && !(tas5720->last_fault & TAS5720_OTE))\n\t\tdev_crit(dev, \"experienced an over temperature fault\\n\");\n\n\t \n\ttas5720->last_fault = curr_fault;\n\n\tif (!curr_fault)\n\t\tgoto out;\n\n\t \n\tret = regmap_write_bits(tas5720->regmap, TAS5720_POWER_CTRL_REG,\n\t\t\t\tTAS5720_SDZ, 0);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write POWER_CTRL register: %d\\n\", ret);\n\n\tret = regmap_write_bits(tas5720->regmap, TAS5720_POWER_CTRL_REG,\n\t\t\t\tTAS5720_SDZ, TAS5720_SDZ);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to write POWER_CTRL register: %d\\n\", ret);\n\nout:\n\t \n\tschedule_delayed_work(&tas5720->fault_check_work,\n\t\t\t      msecs_to_jiffies(TAS5720_FAULT_CHECK_INTERVAL));\n}\n\nstatic int tas5720_codec_probe(struct snd_soc_component *component)\n{\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tunsigned int device_id, expected_device_id;\n\tint ret;\n\n\ttas5720->component = component;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas5720->supplies),\n\t\t\t\t    tas5720->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(tas5720->regmap, TAS5720_DEVICE_ID_REG, &device_id);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to read device ID register: %d\\n\",\n\t\t\tret);\n\t\tgoto probe_fail;\n\t}\n\n\tswitch (tas5720->devtype) {\n\tcase TAS5720:\n\t\texpected_device_id = TAS5720_DEVICE_ID;\n\t\tbreak;\n\tcase TAS5720A_Q1:\n\t\texpected_device_id = TAS5720A_Q1_DEVICE_ID;\n\t\tbreak;\n\tcase TAS5722:\n\t\texpected_device_id = TAS5722_DEVICE_ID;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unexpected private driver data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto probe_fail;\n\t}\n\n\tif (device_id != expected_device_id)\n\t\tdev_warn(component->dev, \"wrong device ID. expected: %u read: %u\\n\",\n\t\t\t expected_device_id, device_id);\n\n\t \n\tret = tas5720_mute_soc_component(component, 1);\n\tif (ret < 0)\n\t\tgoto error_snd_soc_component_update_bits;\n\n\t \n\tswitch (tas5720->devtype) {\n\tcase TAS5720A_Q1:\n\t\tret = snd_soc_component_update_bits(component, TAS5720_ANALOG_CTRL_REG,\n\t\t\t\t\t\t    TAS5720_Q1_RESERVED7_BIT,\n\t\t\t\t\t\t    TAS5720_Q1_RESERVED7_BIT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret < 0)\n\t\tgoto error_snd_soc_component_update_bits;\n\n\t \n\tret = snd_soc_component_update_bits(component, TAS5720_POWER_CTRL_REG,\n\t\t\t\t  TAS5720_SDZ, 0);\n\tif (ret < 0)\n\t\tgoto error_snd_soc_component_update_bits;\n\n\tINIT_DELAYED_WORK(&tas5720->fault_check_work, tas5720_fault_check_work);\n\n\treturn 0;\n\nerror_snd_soc_component_update_bits:\n\tdev_err(component->dev, \"error configuring device registers: %d\\n\", ret);\n\nprobe_fail:\n\tregulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\n\t\t\t       tas5720->supplies);\n\treturn ret;\n}\n\nstatic void tas5720_codec_remove(struct snd_soc_component *component)\n{\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tcancel_delayed_work_sync(&tas5720->fault_check_work);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\n\t\t\t\t     tas5720->supplies);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"failed to disable supplies: %d\\n\", ret);\n};\n\nstatic int tas5720_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (event & SND_SOC_DAPM_POST_PMU) {\n\t\t \n\t\tret = snd_soc_component_update_bits(component, TAS5720_POWER_CTRL_REG,\n\t\t\t\t\t  TAS5720_SDZ, TAS5720_SDZ);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"error waking component: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tmsleep(25);\n\n\t\t \n\t\ttas5720->last_fault = 0;\n\t\tschedule_delayed_work(&tas5720->fault_check_work,\n\t\t\t\tmsecs_to_jiffies(TAS5720_FAULT_CHECK_INTERVAL));\n\t} else if (event & SND_SOC_DAPM_PRE_PMD) {\n\t\t \n\t\tcancel_delayed_work_sync(&tas5720->fault_check_work);\n\n\t\t \n\t\tret = snd_soc_component_update_bits(component, TAS5720_POWER_CTRL_REG,\n\t\t\t\t\t  TAS5720_SDZ, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"error shutting down component: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int tas5720_suspend(struct snd_soc_component *component)\n{\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tregcache_cache_only(tas5720->regmap, true);\n\tregcache_mark_dirty(tas5720->regmap);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(tas5720->supplies),\n\t\t\t\t     tas5720->supplies);\n\tif (ret < 0)\n\t\tdev_err(component->dev, \"failed to disable supplies: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int tas5720_resume(struct snd_soc_component *component)\n{\n\tstruct tas5720_data *tas5720 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(tas5720->supplies),\n\t\t\t\t    tas5720->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(tas5720->regmap, false);\n\n\tret = regcache_sync(tas5720->regmap);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"failed to sync regcache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#else\n#define tas5720_suspend NULL\n#define tas5720_resume NULL\n#endif\n\nstatic bool tas5720_is_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase TAS5720_DEVICE_ID_REG:\n\tcase TAS5720_FAULT_REG:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config tas5720_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = TAS5720_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = tas5720_is_volatile_reg,\n};\n\nstatic const struct regmap_config tas5720a_q1_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = TAS5720_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = tas5720_is_volatile_reg,\n};\n\nstatic const struct regmap_config tas5722_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = TAS5722_MAX_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.volatile_reg = tas5720_is_volatile_reg,\n};\n\n \nstatic const DECLARE_TLV_DB_RANGE(dac_analog_tlv,\n\t0x0, 0x0, TLV_DB_SCALE_ITEM(1920, 0, 0),\n\t0x1, 0x1, TLV_DB_SCALE_ITEM(2070, 0, 0),\n\t0x2, 0x2, TLV_DB_SCALE_ITEM(2350, 0, 0),\n\t0x3, 0x3, TLV_DB_SCALE_ITEM(2630, 0, 0),\n);\n\n \nstatic const DECLARE_TLV_DB_RANGE(dac_analog_tlv_a_q1,\n\t0x0, 0x0, TLV_DB_SCALE_ITEM(1920, 0, 0),\n\t0x1, 0x1, TLV_DB_SCALE_ITEM(2260, 0, 0),\n\t0x2, 0x2, TLV_DB_SCALE_ITEM(2500, 0, 0),\n);\n\n \nstatic DECLARE_TLV_DB_SCALE(tas5720_dac_tlv, -10350, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(tas5722_dac_tlv, -10350, 25, 0);\n\nstatic int tas5722_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int val;\n\n\tval = snd_soc_component_read(component, TAS5720_VOLUME_CTRL_REG);\n\tucontrol->value.integer.value[0] = val << 1;\n\n\tval = snd_soc_component_read(component, TAS5722_DIGITAL_CTRL2_REG);\n\tucontrol->value.integer.value[0] |= val & TAS5722_VOL_CONTROL_LSB;\n\n\treturn 0;\n}\n\nstatic int tas5722_volume_set(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int sel = ucontrol->value.integer.value[0];\n\n\tsnd_soc_component_write(component, TAS5720_VOLUME_CTRL_REG, sel >> 1);\n\tsnd_soc_component_update_bits(component, TAS5722_DIGITAL_CTRL2_REG,\n\t\t\t\t      TAS5722_VOL_CONTROL_LSB, sel);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new tas5720_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Driver Playback Volume\",\n\t\t       TAS5720_VOLUME_CTRL_REG, 0, 0xff, 0, tas5720_dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver Analog Gain\", TAS5720_ANALOG_CTRL_REG,\n\t\t       TAS5720_ANALOG_GAIN_SHIFT, 3, 0, dac_analog_tlv),\n};\n\nstatic const struct snd_kcontrol_new tas5720a_q1_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Speaker Driver Playback Volume\",\n\t\t\t\tTAS5720_Q1_VOLUME_CTRL_LEFT_REG,\n\t\t\t\tTAS5720_Q1_VOLUME_CTRL_RIGHT_REG,\n\t\t\t\t0, 0xff, 0, tas5720_dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver Analog Gain\", TAS5720_ANALOG_CTRL_REG,\n\t\t\t\tTAS5720_ANALOG_GAIN_SHIFT, 3, 0, dac_analog_tlv_a_q1),\n};\n\nstatic const struct snd_kcontrol_new tas5722_snd_controls[] = {\n\tSOC_SINGLE_EXT_TLV(\"Speaker Driver Playback Volume\",\n\t\t\t   0, 0, 511, 0,\n\t\t\t   tas5722_volume_get, tas5722_volume_set,\n\t\t\t   tas5722_dac_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Driver Analog Gain\", TAS5720_ANALOG_CTRL_REG,\n\t\t       TAS5720_ANALOG_GAIN_SHIFT, 3, 0, dac_analog_tlv),\n};\n\nstatic const struct snd_soc_dapm_widget tas5720_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"DAC IN\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0, tas5720_dac_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"OUT\")\n};\n\nstatic const struct snd_soc_dapm_route tas5720_audio_map[] = {\n\t{ \"DAC\", NULL, \"DAC IN\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas5720 = {\n\t.probe\t\t\t= tas5720_codec_probe,\n\t.remove\t\t\t= tas5720_codec_remove,\n\t.suspend\t\t= tas5720_suspend,\n\t.resume\t\t\t= tas5720_resume,\n\t.controls\t\t= tas5720_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas5720_snd_controls),\n\t.dapm_widgets\t\t= tas5720_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas5720_dapm_widgets),\n\t.dapm_routes\t\t= tas5720_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas5720_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas5720_a_q1 = {\n\t.probe\t\t\t= tas5720_codec_probe,\n\t.remove\t\t\t= tas5720_codec_remove,\n\t.suspend\t\t= tas5720_suspend,\n\t.resume\t\t\t= tas5720_resume,\n\t.controls\t\t= tas5720a_q1_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(tas5720a_q1_snd_controls),\n\t.dapm_widgets\t\t= tas5720_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tas5720_dapm_widgets),\n\t.dapm_routes\t\t= tas5720_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(tas5720_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_tas5722 = {\n\t.probe = tas5720_codec_probe,\n\t.remove = tas5720_codec_remove,\n\t.suspend = tas5720_suspend,\n\t.resume = tas5720_resume,\n\t.controls = tas5722_snd_controls,\n\t.num_controls = ARRAY_SIZE(tas5722_snd_controls),\n\t.dapm_widgets = tas5720_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(tas5720_dapm_widgets),\n\t.dapm_routes = tas5720_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(tas5720_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n \n#define TAS5720_RATES\t(SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\\\n\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)\n\n \n#define TAS5720_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops tas5720_speaker_dai_ops = {\n\t.hw_params\t= tas5720_hw_params,\n\t.set_fmt\t= tas5720_set_dai_fmt,\n\t.set_tdm_slot\t= tas5720_set_dai_tdm_slot,\n\t.mute_stream\t= tas5720_mute,\n\t.no_capture_mute = 1,\n};\n\n \nstatic struct snd_soc_dai_driver tas5720_dai[] = {\n\t{\n\t\t.name = \"tas5720-amplifier\",\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = TAS5720_RATES,\n\t\t\t.formats = TAS5720_FORMATS,\n\t\t},\n\t\t.ops = &tas5720_speaker_dai_ops,\n\t},\n};\n\nstatic const struct i2c_device_id tas5720_id[] = {\n\t{ \"tas5720\", TAS5720 },\n\t{ \"tas5720a-q1\", TAS5720A_Q1 },\n\t{ \"tas5722\", TAS5722 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tas5720_id);\n\nstatic int tas5720_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct tas5720_data *data;\n\tconst struct regmap_config *regmap_config;\n\tconst struct i2c_device_id *id;\n\tint ret;\n\tint i;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tid = i2c_match_id(tas5720_id, client);\n\tdata->tas5720_client = client;\n\tdata->devtype = id->driver_data;\n\n\tswitch (id->driver_data) {\n\tcase TAS5720:\n\t\tregmap_config = &tas5720_regmap_config;\n\t\tbreak;\n\tcase TAS5720A_Q1:\n\t\tregmap_config = &tas5720a_q1_regmap_config;\n\t\tbreak;\n\tcase TAS5722:\n\t\tregmap_config = &tas5722_regmap_config;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unexpected private driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdata->regmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tdev_err(dev, \"failed to allocate register map: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(data->supplies); i++)\n\t\tdata->supplies[i].supply = tas5720_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),\n\t\t\t\t      data->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, data);\n\n\tswitch (id->driver_data) {\n\tcase TAS5720:\n\t\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t\t&soc_component_dev_tas5720,\n\t\t\t\t\ttas5720_dai,\n\t\t\t\t\tARRAY_SIZE(tas5720_dai));\n\t\tbreak;\n\tcase TAS5720A_Q1:\n\t\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t\t&soc_component_dev_tas5720_a_q1,\n\t\t\t\t\ttas5720_dai,\n\t\t\t\t\tARRAY_SIZE(tas5720_dai));\n\t\tbreak;\n\tcase TAS5722:\n\t\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t\t&soc_component_dev_tas5722,\n\t\t\t\t\ttas5720_dai,\n\t\t\t\t\tARRAY_SIZE(tas5720_dai));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unexpected private driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to register component: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_OF)\nstatic const struct of_device_id tas5720_of_match[] = {\n\t{ .compatible = \"ti,tas5720\", },\n\t{ .compatible = \"ti,tas5720a-q1\", },\n\t{ .compatible = \"ti,tas5722\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tas5720_of_match);\n#endif\n\nstatic struct i2c_driver tas5720_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tas5720\",\n\t\t.of_match_table = of_match_ptr(tas5720_of_match),\n\t},\n\t.probe = tas5720_probe,\n\t.id_table = tas5720_id,\n};\n\nmodule_i2c_driver(tas5720_i2c_driver);\n\nMODULE_AUTHOR(\"Andreas Dannenberg <dannenberg@ti.com>\");\nMODULE_DESCRIPTION(\"TAS5720 Audio amplifier driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}