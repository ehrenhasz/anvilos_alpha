{
  "module_name": "wm0010.c",
  "hash_id": "afcd5f6886b8330888064abf08db600fb345560393bc1a89d3f8e09a8edb977f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm0010.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/irqreturn.h>\n#include <linux/init.h>\n#include <linux/spi/spi.h>\n#include <linux/firmware.h>\n#include <linux/delay.h>\n#include <linux/fs.h>\n#include <linux/gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n\n#include <sound/soc.h>\n#include <sound/wm0010.h>\n\n#define DEVICE_ID_WM0010\t10\n\n \n#define INFO_VERSION\t\t1\n\nenum dfw_cmd {\n\tDFW_CMD_FUSE = 0x01,\n\tDFW_CMD_CODE_HDR,\n\tDFW_CMD_CODE_DATA,\n\tDFW_CMD_PLL,\n\tDFW_CMD_INFO = 0xff\n};\n\nstruct dfw_binrec {\n\tu8 command;\n\tu32 length:24;\n\tu32 address;\n\tuint8_t data[];\n} __packed;\n\nstruct dfw_inforec {\n\tu8 info_version;\n\tu8 tool_major_version;\n\tu8 tool_minor_version;\n\tu8 dsp_target;\n};\n\nstruct dfw_pllrec {\n\tu8 command;\n\tu32 length:24;\n\tu32 address;\n\tu32 clkctrl1;\n\tu32 clkctrl2;\n\tu32 clkctrl3;\n\tu32 ldetctrl;\n\tu32 uart_div;\n\tu32 spi_div;\n} __packed;\n\nstatic struct pll_clock_map {\n\tint max_sysclk;\n\tint max_pll_spi_speed;\n\tu32 pll_clkctrl1;\n} pll_clock_map[] = {\t\t\t    \n\t{ 22000000, 26000000, 0x00201f11 },  \n\t{ 18000000, 26000000, 0x00203f21 },  \n\t{ 14000000, 26000000, 0x00202620 },  \n\t{ 10000000, 22000000, 0x00203120 },  \n\t{  6500000, 22000000, 0x00204520 },  \n\t{  5500000, 22000000, 0x00103f10 },  \n};\n\nenum wm0010_state {\n\tWM0010_POWER_OFF,\n\tWM0010_OUT_OF_RESET,\n\tWM0010_BOOTROM,\n\tWM0010_STAGE2,\n\tWM0010_FIRMWARE,\n};\n\nstruct wm0010_priv {\n\tstruct snd_soc_component *component;\n\n\tstruct mutex lock;\n\tstruct device *dev;\n\n\tstruct wm0010_pdata pdata;\n\n\tint gpio_reset;\n\tint gpio_reset_value;\n\n\tstruct regulator_bulk_data core_supplies[2];\n\tstruct regulator *dbvdd;\n\n\tint sysclk;\n\n\tenum wm0010_state state;\n\tbool boot_failed;\n\tbool ready;\n\tbool pll_running;\n\tint max_spi_freq;\n\tint board_max_spi_speed;\n\tu32 pll_clkctrl1;\n\n\tspinlock_t irq_lock;\n\tint irq;\n\n\tstruct completion boot_completion;\n};\n\nstruct wm0010_spi_msg {\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tu8 *tx_buf;\n\tu8 *rx_buf;\n\tsize_t len;\n};\n\nstatic const struct snd_soc_dapm_widget wm0010_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"CLKIN\",  SND_SOC_NOPM, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route wm0010_dapm_routes[] = {\n\t{ \"SDI2 Capture\", NULL, \"SDI1 Playback\" },\n\t{ \"SDI1 Capture\", NULL, \"SDI2 Playback\" },\n\n\t{ \"SDI1 Capture\", NULL, \"CLKIN\" },\n\t{ \"SDI2 Capture\", NULL, \"CLKIN\" },\n\t{ \"SDI1 Playback\", NULL, \"CLKIN\" },\n\t{ \"SDI2 Playback\", NULL, \"CLKIN\" },\n};\n\nstatic const char *wm0010_state_to_str(enum wm0010_state state)\n{\n\tstatic const char * const state_to_str[] = {\n\t\t\"Power off\",\n\t\t\"Out of reset\",\n\t\t\"Boot ROM\",\n\t\t\"Stage2\",\n\t\t\"Firmware\"\n\t};\n\n\tif (state < 0 || state >= ARRAY_SIZE(state_to_str))\n\t\treturn \"null\";\n\treturn state_to_str[state];\n}\n\n \nstatic void wm0010_halt(struct snd_soc_component *component)\n{\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tunsigned long flags;\n\tenum wm0010_state state;\n\n\t \n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\tstate = wm0010->state;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tswitch (state) {\n\tcase WM0010_POWER_OFF:\n\t\t \n\t\treturn;\n\tcase WM0010_OUT_OF_RESET:\n\tcase WM0010_BOOTROM:\n\tcase WM0010_STAGE2:\n\tcase WM0010_FIRMWARE:\n\t\t \n\t\tgpio_set_value_cansleep(wm0010->gpio_reset,\n\t\t\t\t\twm0010->gpio_reset_value);\n\t\t \n\t\tregulator_disable(wm0010->dbvdd);\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),\n\t\t\t\t       wm0010->core_supplies);\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\twm0010->state = WM0010_POWER_OFF;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n}\n\nstruct wm0010_boot_xfer {\n\tstruct list_head list;\n\tstruct snd_soc_component *component;\n\tstruct completion *done;\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n};\n\n \nstatic void wm0010_mark_boot_failure(struct wm0010_priv *wm0010)\n{\n\tenum wm0010_state state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\tstate = wm0010->state;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tdev_err(wm0010->dev, \"Failed to transition from `%s' state to `%s' state\\n\",\n\t\twm0010_state_to_str(state), wm0010_state_to_str(state + 1));\n\n\twm0010->boot_failed = true;\n}\n\nstatic void wm0010_boot_xfer_complete(void *data)\n{\n\tstruct wm0010_boot_xfer *xfer = data;\n\tstruct snd_soc_component *component = xfer->component;\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tu32 *out32 = xfer->t.rx_buf;\n\tint i;\n\n\tif (xfer->m.status != 0) {\n\t\tdev_err(component->dev, \"SPI transfer failed: %d\\n\",\n\t\t\txfer->m.status);\n\t\twm0010_mark_boot_failure(wm0010);\n\t\tif (xfer->done)\n\t\t\tcomplete(xfer->done);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < xfer->t.len / 4; i++) {\n\t\tdev_dbg(component->dev, \"%d: %04x\\n\", i, out32[i]);\n\n\t\tswitch (be32_to_cpu(out32[i])) {\n\t\tcase 0xe0e0e0e0:\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"%d: ROM error reported in stage 2\\n\", i);\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x55555555:\n\t\t\tif (wm0010->state < WM0010_STAGE2)\n\t\t\t\tbreak;\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"%d: ROM bootloader running in stage 2\\n\", i);\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0000:\n\t\t\tdev_dbg(component->dev, \"Stage2 loader running\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed0007:\n\t\t\tdev_dbg(component->dev, \"CODE_HDR packet received\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed0008:\n\t\t\tdev_dbg(component->dev, \"CODE_DATA packet received\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed0009:\n\t\t\tdev_dbg(component->dev, \"Download complete\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed000c:\n\t\t\tdev_dbg(component->dev, \"Application start\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed000e:\n\t\t\tdev_dbg(component->dev, \"PLL packet received\\n\");\n\t\t\twm0010->pll_running = true;\n\t\t\tbreak;\n\n\t\tcase 0x0fed0025:\n\t\t\tdev_err(component->dev, \"Device reports image too long\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed002c:\n\t\t\tdev_err(component->dev, \"Device reports bad SPI packet\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0031:\n\t\t\tdev_err(component->dev, \"Device reports SPI read overflow\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0032:\n\t\t\tdev_err(component->dev, \"Device reports SPI underclock\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0033:\n\t\t\tdev_err(component->dev, \"Device reports bad header packet\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0034:\n\t\t\tdev_err(component->dev, \"Device reports invalid packet type\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0035:\n\t\t\tdev_err(component->dev, \"Device reports data before header error\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tcase 0x0fed0038:\n\t\t\tdev_err(component->dev, \"Device reports invalid PLL packet\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x0fed003a:\n\t\t\tdev_err(component->dev, \"Device reports packet alignment error\\n\");\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Unrecognised return 0x%x\\n\",\n\t\t\t    be32_to_cpu(out32[i]));\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wm0010->boot_failed)\n\t\t\tbreak;\n\t}\n\n\tif (xfer->done)\n\t\tcomplete(xfer->done);\n}\n\nstatic void byte_swap_64(u64 *data_in, u64 *data_out, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < len / 8; i++)\n\t\tdata_out[i] = cpu_to_be64(le64_to_cpu(data_in[i]));\n}\n\nstatic int wm0010_firmware_load(const char *name, struct snd_soc_component *component)\n{\n\tstruct spi_device *spi = to_spi_device(component->dev);\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tstruct list_head xfer_list;\n\tstruct wm0010_boot_xfer *xfer;\n\tint ret;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tconst struct firmware *fw;\n\tconst struct dfw_binrec *rec;\n\tconst struct dfw_inforec *inforec;\n\tu64 *img;\n\tu8 *out, dsp;\n\tu32 len, offset;\n\n\tINIT_LIST_HEAD(&xfer_list);\n\n\tret = request_firmware(&fw, name, component->dev);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to request application(%s): %d\\n\",\n\t\t\tname, ret);\n\t\treturn ret;\n\t}\n\n\trec = (const struct dfw_binrec *)fw->data;\n\tinforec = (const struct dfw_inforec *)rec->data;\n\toffset = 0;\n\tdsp = inforec->dsp_target;\n\twm0010->boot_failed = false;\n\tif (WARN_ON(!list_empty(&xfer_list)))\n\t\treturn -EINVAL;\n\n\t \n\tif (rec->command != DFW_CMD_INFO) {\n\t\tdev_err(component->dev, \"First record not INFO\\r\\n\");\n\t\tret = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\tif (inforec->info_version != INFO_VERSION) {\n\t\tdev_err(component->dev,\n\t\t\t\"Unsupported version (%02d) of INFO record\\r\\n\",\n\t\t\tinforec->info_version);\n\t\tret = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\tdev_dbg(component->dev, \"Version v%02d INFO record found\\r\\n\",\n\t\tinforec->info_version);\n\n\t \n\tif (dsp != DEVICE_ID_WM0010) {\n\t\tdev_err(component->dev, \"Not a WM0010 firmware file.\\r\\n\");\n\t\tret = -EINVAL;\n\t\tgoto abort;\n\t}\n\n\t \n\toffset += ((rec->length) + 8);\n\trec = (void *)&rec->data[rec->length];\n\n\twhile (offset < fw->size) {\n\t\tdev_dbg(component->dev,\n\t\t\t\"Packet: command %d, data length = 0x%x\\r\\n\",\n\t\t\trec->command, rec->length);\n\t\tlen = rec->length + 8;\n\n\t\txfer = kzalloc(sizeof(*xfer), GFP_KERNEL);\n\t\tif (!xfer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto abort;\n\t\t}\n\n\t\txfer->component = component;\n\t\tlist_add_tail(&xfer->list, &xfer_list);\n\n\t\tout = kzalloc(len, GFP_KERNEL | GFP_DMA);\n\t\tif (!out) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto abort1;\n\t\t}\n\t\txfer->t.rx_buf = out;\n\n\t\timg = kzalloc(len, GFP_KERNEL | GFP_DMA);\n\t\tif (!img) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto abort1;\n\t\t}\n\t\txfer->t.tx_buf = img;\n\n\t\tbyte_swap_64((u64 *)&rec->command, img, len);\n\n\t\tspi_message_init(&xfer->m);\n\t\txfer->m.complete = wm0010_boot_xfer_complete;\n\t\txfer->m.context = xfer;\n\t\txfer->t.len = len;\n\t\txfer->t.bits_per_word = 8;\n\n\t\tif (!wm0010->pll_running) {\n\t\t\txfer->t.speed_hz = wm0010->sysclk / 6;\n\t\t} else {\n\t\t\txfer->t.speed_hz = wm0010->max_spi_freq;\n\n\t\t\tif (wm0010->board_max_spi_speed &&\n\t\t\t   (wm0010->board_max_spi_speed < wm0010->max_spi_freq))\n\t\t\t\t\txfer->t.speed_hz = wm0010->board_max_spi_speed;\n\t\t}\n\n\t\t \n\t\twm0010->max_spi_freq = xfer->t.speed_hz;\n\n\t\tspi_message_add_tail(&xfer->t, &xfer->m);\n\n\t\toffset += ((rec->length) + 8);\n\t\trec = (void *)&rec->data[rec->length];\n\n\t\tif (offset >= fw->size) {\n\t\t\tdev_dbg(component->dev, \"All transfers scheduled\\n\");\n\t\t\txfer->done = &done;\n\t\t}\n\n\t\tret = spi_async(spi, &xfer->m);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Write failed: %d\\n\", ret);\n\t\t\tgoto abort1;\n\t\t}\n\n\t\tif (wm0010->boot_failed) {\n\t\t\tdev_dbg(component->dev, \"Boot fail!\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto abort1;\n\t\t}\n\t}\n\n\twait_for_completion(&done);\n\n\tret = 0;\n\nabort1:\n\twhile (!list_empty(&xfer_list)) {\n\t\txfer = list_first_entry(&xfer_list, struct wm0010_boot_xfer,\n\t\t\t\t\tlist);\n\t\tkfree(xfer->t.rx_buf);\n\t\tkfree(xfer->t.tx_buf);\n\t\tlist_del(&xfer->list);\n\t\tkfree(xfer);\n\t}\n\nabort:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int wm0010_stage2_load(struct snd_soc_component *component)\n{\n\tstruct spi_device *spi = to_spi_device(component->dev);\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tconst struct firmware *fw;\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tu32 *img;\n\tu8 *out;\n\tint i;\n\tint ret = 0;\n\n\tret = request_firmware(&fw, \"wm0010_stage2.bin\", component->dev);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to request stage2 loader: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"Downloading %zu byte stage 2 loader\\n\", fw->size);\n\n\t \n\timg = kmemdup(&fw->data[0], fw->size, GFP_KERNEL | GFP_DMA);\n\tif (!img) {\n\t\tret = -ENOMEM;\n\t\tgoto abort2;\n\t}\n\n\tout = kzalloc(fw->size, GFP_KERNEL | GFP_DMA);\n\tif (!out) {\n\t\tret = -ENOMEM;\n\t\tgoto abort1;\n\t}\n\n\tspi_message_init(&m);\n\tmemset(&t, 0, sizeof(t));\n\tt.rx_buf = out;\n\tt.tx_buf = img;\n\tt.len = fw->size;\n\tt.bits_per_word = 8;\n\tt.speed_hz = wm0010->sysclk / 10;\n\tspi_message_add_tail(&t, &m);\n\n\tdev_dbg(component->dev, \"Starting initial download at %dHz\\n\",\n\t\tt.speed_hz);\n\n\tret = spi_sync(spi, &m);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Initial download failed: %d\\n\", ret);\n\t\tgoto abort;\n\t}\n\n\t \n\tfor (i = 0; i < fw->size; i++) {\n\t\tif (out[i] != 0x55) {\n\t\t\tdev_err(component->dev, \"Boot ROM error: %x in %d\\n\",\n\t\t\t\tout[i], i);\n\t\t\twm0010_mark_boot_failure(wm0010);\n\t\t\tret = -EBUSY;\n\t\t\tgoto abort;\n\t\t}\n\t}\nabort:\n\tkfree(out);\nabort1:\n\tkfree(img);\nabort2:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int wm0010_boot(struct snd_soc_component *component)\n{\n\tstruct spi_device *spi = to_spi_device(component->dev);\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tunsigned long flags;\n\tint ret;\n\tstruct spi_message m;\n\tstruct spi_transfer t;\n\tstruct dfw_pllrec pll_rec;\n\tu32 *p, len;\n\tu64 *img_swap;\n\tu8 *out;\n\tint i;\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\tif (wm0010->state != WM0010_POWER_OFF)\n\t\tdev_warn(wm0010->dev, \"DSP already powered up!\\n\");\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tif (wm0010->sysclk > 26000000) {\n\t\tdev_err(component->dev, \"Max DSP clock frequency is 26MHz\\n\");\n\t\tret = -ECANCELED;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&wm0010->lock);\n\twm0010->pll_running = false;\n\n\tdev_dbg(component->dev, \"max_spi_freq: %d\\n\", wm0010->max_spi_freq);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm0010->core_supplies),\n\t\t\t\t    wm0010->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(&spi->dev, \"Failed to enable core supplies: %d\\n\",\n\t\t\tret);\n\t\tmutex_unlock(&wm0010->lock);\n\t\tgoto err;\n\t}\n\n\tret = regulator_enable(wm0010->dbvdd);\n\tif (ret != 0) {\n\t\tdev_err(&spi->dev, \"Failed to enable DBVDD: %d\\n\", ret);\n\t\tgoto err_core;\n\t}\n\n\t \n\tgpio_set_value_cansleep(wm0010->gpio_reset, !wm0010->gpio_reset_value);\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\twm0010->state = WM0010_OUT_OF_RESET;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tif (!wait_for_completion_timeout(&wm0010->boot_completion,\n\t\t\t\t\t msecs_to_jiffies(20)))\n\t\tdev_err(component->dev, \"Failed to get interrupt from DSP\\n\");\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\twm0010->state = WM0010_BOOTROM;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tret = wm0010_stage2_load(component);\n\tif (ret)\n\t\tgoto abort;\n\n\tif (!wait_for_completion_timeout(&wm0010->boot_completion,\n\t\t\t\t\t msecs_to_jiffies(20)))\n\t\tdev_err(component->dev, \"Failed to get interrupt from DSP loader.\\n\");\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\twm0010->state = WM0010_STAGE2;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\t \n\tif (wm0010->max_spi_freq) {\n\n\t\t \n\t\tmemset(&pll_rec, 0, sizeof(pll_rec));\n\t\tpll_rec.command = DFW_CMD_PLL;\n\t\tpll_rec.length = (sizeof(pll_rec) - 8);\n\n\t\t \n\t\tpll_rec.clkctrl1 = wm0010->pll_clkctrl1;\n\n\t\tret = -ENOMEM;\n\t\tlen = pll_rec.length + 8;\n\t\tout = kzalloc(len, GFP_KERNEL | GFP_DMA);\n\t\tif (!out)\n\t\t\tgoto abort;\n\n\t\timg_swap = kzalloc(len, GFP_KERNEL | GFP_DMA);\n\t\tif (!img_swap)\n\t\t\tgoto abort_out;\n\n\t\t \n\t\tbyte_swap_64((u64 *)&pll_rec, img_swap, len);\n\n\t\tspi_message_init(&m);\n\t\tmemset(&t, 0, sizeof(t));\n\t\tt.rx_buf = out;\n\t\tt.tx_buf = img_swap;\n\t\tt.len = len;\n\t\tt.bits_per_word = 8;\n\t\tt.speed_hz = wm0010->sysclk / 6;\n\t\tspi_message_add_tail(&t, &m);\n\n\t\tret = spi_sync(spi, &m);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"First PLL write failed: %d\\n\", ret);\n\t\t\tgoto abort_swap;\n\t\t}\n\n\t\t \n\t\tret = spi_sync(spi, &m);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Second PLL write failed: %d\\n\", ret);\n\t\t\tgoto abort_swap;\n\t\t}\n\n\t\tp = (u32 *)out;\n\n\t\t \n\t\tfor (i = 0; i < len / 4; i++) {\n\t\t\tif (*p == 0x0e00ed0f) {\n\t\t\t\tdev_dbg(component->dev, \"PLL packet received\\n\");\n\t\t\t\twm0010->pll_running = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\n\t\tkfree(img_swap);\n\t\tkfree(out);\n\t} else\n\t\tdev_dbg(component->dev, \"Not enabling DSP PLL.\");\n\n\tret = wm0010_firmware_load(\"wm0010.dfw\", component);\n\n\tif (ret != 0)\n\t\tgoto abort;\n\n\tspin_lock_irqsave(&wm0010->irq_lock, flags);\n\twm0010->state = WM0010_FIRMWARE;\n\tspin_unlock_irqrestore(&wm0010->irq_lock, flags);\n\n\tmutex_unlock(&wm0010->lock);\n\n\treturn 0;\n\nabort_swap:\n\tkfree(img_swap);\nabort_out:\n\tkfree(out);\nabort:\n\t \n\twm0010_halt(component);\n\tmutex_unlock(&wm0010->lock);\n\treturn ret;\n\nerr_core:\n\tmutex_unlock(&wm0010->lock);\n\tregulator_bulk_disable(ARRAY_SIZE(wm0010->core_supplies),\n\t\t\t       wm0010->core_supplies);\nerr:\n\treturn ret;\n}\n\nstatic int wm0010_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE)\n\t\t\twm0010_boot(component);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_PREPARE) {\n\t\t\tmutex_lock(&wm0010->lock);\n\t\t\twm0010_halt(component);\n\t\t\tmutex_unlock(&wm0010->lock);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm0010_set_sysclk(struct snd_soc_component *component, int source,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\tunsigned int i;\n\n\twm0010->sysclk = freq;\n\n\tif (freq < pll_clock_map[ARRAY_SIZE(pll_clock_map)-1].max_sysclk) {\n\t\twm0010->max_spi_freq = 0;\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(pll_clock_map); i++)\n\t\t\tif (freq >= pll_clock_map[i].max_sysclk) {\n\t\t\t\twm0010->max_spi_freq = pll_clock_map[i].max_pll_spi_speed;\n\t\t\t\twm0010->pll_clkctrl1 = pll_clock_map[i].pll_clkctrl1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wm0010_probe(struct snd_soc_component *component);\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm0010 = {\n\t.probe\t\t\t= wm0010_probe,\n\t.set_bias_level\t\t= wm0010_set_bias_level,\n\t.set_sysclk\t\t= wm0010_set_sysclk,\n\t.dapm_widgets\t\t= wm0010_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm0010_dapm_widgets),\n\t.dapm_routes\t\t= wm0010_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm0010_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n#define WM0010_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define WM0010_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver wm0010_dai[] = {\n\t{\n\t\t.name = \"wm0010-sdi1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"SDI1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = WM0010_RATES,\n\t\t\t.formats = WM0010_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .stream_name = \"SDI1 Capture\",\n\t\t\t .channels_min = 1,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = WM0010_RATES,\n\t\t\t .formats = WM0010_FORMATS,\n\t\t },\n\t},\n\t{\n\t\t.name = \"wm0010-sdi2\",\n\t\t.playback = {\n\t\t\t.stream_name = \"SDI2 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = WM0010_RATES,\n\t\t\t.formats = WM0010_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t .stream_name = \"SDI2 Capture\",\n\t\t\t .channels_min = 1,\n\t\t\t .channels_max = 2,\n\t\t\t .rates = WM0010_RATES,\n\t\t\t .formats = WM0010_FORMATS,\n\t\t },\n\t},\n};\n\nstatic irqreturn_t wm0010_irq(int irq, void *data)\n{\n\tstruct wm0010_priv *wm0010 = data;\n\n\tswitch (wm0010->state) {\n\tcase WM0010_OUT_OF_RESET:\n\tcase WM0010_BOOTROM:\n\tcase WM0010_STAGE2:\n\t\tspin_lock(&wm0010->irq_lock);\n\t\tcomplete(&wm0010->boot_completion);\n\t\tspin_unlock(&wm0010->irq_lock);\n\t\treturn IRQ_HANDLED;\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int wm0010_probe(struct snd_soc_component *component)\n{\n\tstruct wm0010_priv *wm0010 = snd_soc_component_get_drvdata(component);\n\n\twm0010->component = component;\n\n\treturn 0;\n}\n\nstatic int wm0010_spi_probe(struct spi_device *spi)\n{\n\tunsigned long gpio_flags;\n\tint ret;\n\tint trigger;\n\tint irq;\n\tstruct wm0010_priv *wm0010;\n\n\twm0010 = devm_kzalloc(&spi->dev, sizeof(*wm0010),\n\t\t\t      GFP_KERNEL);\n\tif (!wm0010)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wm0010->lock);\n\tspin_lock_init(&wm0010->irq_lock);\n\n\tspi_set_drvdata(spi, wm0010);\n\twm0010->dev = &spi->dev;\n\n\tif (dev_get_platdata(&spi->dev))\n\t\tmemcpy(&wm0010->pdata, dev_get_platdata(&spi->dev),\n\t\t       sizeof(wm0010->pdata));\n\n\tinit_completion(&wm0010->boot_completion);\n\n\twm0010->core_supplies[0].supply = \"AVDD\";\n\twm0010->core_supplies[1].supply = \"DCVDD\";\n\tret = devm_regulator_bulk_get(wm0010->dev, ARRAY_SIZE(wm0010->core_supplies),\n\t\t\t\t      wm0010->core_supplies);\n\tif (ret != 0) {\n\t\tdev_err(wm0010->dev, \"Failed to obtain core supplies: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\twm0010->dbvdd = devm_regulator_get(wm0010->dev, \"DBVDD\");\n\tif (IS_ERR(wm0010->dbvdd)) {\n\t\tret = PTR_ERR(wm0010->dbvdd);\n\t\tdev_err(wm0010->dev, \"Failed to obtain DBVDD: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (wm0010->pdata.gpio_reset) {\n\t\twm0010->gpio_reset = wm0010->pdata.gpio_reset;\n\n\t\tif (wm0010->pdata.reset_active_high)\n\t\t\twm0010->gpio_reset_value = 1;\n\t\telse\n\t\t\twm0010->gpio_reset_value = 0;\n\n\t\tif (wm0010->gpio_reset_value)\n\t\t\tgpio_flags = GPIOF_OUT_INIT_HIGH;\n\t\telse\n\t\t\tgpio_flags = GPIOF_OUT_INIT_LOW;\n\n\t\tret = devm_gpio_request_one(wm0010->dev, wm0010->gpio_reset,\n\t\t\t\t\t    gpio_flags, \"wm0010 reset\");\n\t\tif (ret < 0) {\n\t\t\tdev_err(wm0010->dev,\n\t\t\t\t\"Failed to request GPIO for DSP reset: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tdev_err(wm0010->dev, \"No reset GPIO configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twm0010->state = WM0010_POWER_OFF;\n\n\tirq = spi->irq;\n\tif (wm0010->pdata.irq_flags)\n\t\ttrigger = wm0010->pdata.irq_flags;\n\telse\n\t\ttrigger = IRQF_TRIGGER_FALLING;\n\ttrigger |= IRQF_ONESHOT;\n\n\tret = request_threaded_irq(irq, NULL, wm0010_irq, trigger,\n\t\t\t\t   \"wm0010\", wm0010);\n\tif (ret) {\n\t\tdev_err(wm0010->dev, \"Failed to request IRQ %d: %d\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\twm0010->irq = irq;\n\n\tret = irq_set_irq_wake(irq, 1);\n\tif (ret) {\n\t\tdev_err(wm0010->dev, \"Failed to set IRQ %d as wake source: %d\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tif (spi->max_speed_hz)\n\t\twm0010->board_max_spi_speed = spi->max_speed_hz;\n\telse\n\t\twm0010->board_max_spi_speed = 0;\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t     &soc_component_dev_wm0010, wm0010_dai,\n\t\t\t\t     ARRAY_SIZE(wm0010_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void wm0010_spi_remove(struct spi_device *spi)\n{\n\tstruct wm0010_priv *wm0010 = spi_get_drvdata(spi);\n\n\tgpio_set_value_cansleep(wm0010->gpio_reset,\n\t\t\t\twm0010->gpio_reset_value);\n\n\tirq_set_irq_wake(wm0010->irq, 0);\n\n\tif (wm0010->irq)\n\t\tfree_irq(wm0010->irq, wm0010);\n}\n\nstatic struct spi_driver wm0010_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm0010\",\n\t},\n\t.probe\t\t= wm0010_spi_probe,\n\t.remove\t\t= wm0010_spi_remove,\n};\n\nmodule_spi_driver(wm0010_spi_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM0010 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"wm0010.dfw\");\nMODULE_FIRMWARE(\"wm0010_stage2.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}