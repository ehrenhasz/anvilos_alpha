{
  "module_name": "uda1334.c",
  "hash_id": "34f1e749587043279ae84775ee7bb3cb47db6407fe5f8de4722871b085998ce2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/uda1334.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#define UDA1334_NUM_RATES 6\n\n \nstruct uda1334_priv {\n\tstruct gpio_desc *mute;\n\tstruct gpio_desc *deemph;\n\tunsigned int sysclk;\n\tunsigned int rate_constraint_list[UDA1334_NUM_RATES];\n\tstruct snd_pcm_hw_constraint_list rate_constraint;\n};\n\nstatic const struct snd_soc_dapm_widget uda1334_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"LINEVOUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route uda1334_dapm_routes[] = {\n\t{ \"LINEVOUTL\", NULL, \"DAC\" },\n\t{ \"LINEVOUTR\", NULL, \"DAC\" },\n};\n\nstatic int uda1334_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\tint deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tgpiod_set_value_cansleep(uda1334->deemph, deemph);\n\n\treturn 0;\n};\n\nstatic int uda1334_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = gpiod_get_value_cansleep(uda1334->deemph);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tucontrol->value.integer.value[0] = ret;\n\n\treturn 0;\n};\n\nstatic const struct snd_kcontrol_new uda1334_snd_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"Playback Deemphasis Switch\", 0,\n\t\t\t    uda1334_get_deemph, uda1334_put_deemph),\n};\n\nstatic const struct {\n\tint value;\n\tint ratio;\n} lrclk_ratios[UDA1334_NUM_RATES] = {\n\t{ 1, 128 },\n\t{ 2, 192 },\n\t{ 3, 256 },\n\t{ 4, 384 },\n\t{ 5, 512 },\n\t{ 6, 768 },\n};\n\nstatic int uda1334_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (!uda1334->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"No MCLK configured, call set_sysclk() on init\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   &uda1334->rate_constraint);\n\n\tgpiod_set_value_cansleep(uda1334->mute, 1);\n\n\treturn 0;\n}\n\nstatic void uda1334_shutdown(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\n\tgpiod_set_value_cansleep(uda1334->mute, 0);\n}\n\nstatic int uda1334_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint i, j = 0;\n\n\tuda1334->sysclk = freq;\n\n\tuda1334->rate_constraint.count = 0;\n\tfor (i = 0; i < ARRAY_SIZE(lrclk_ratios); i++) {\n\t\tval = freq / lrclk_ratios[i].ratio;\n\t\t \n\n\t\tswitch (val) {\n\t\tcase 8000:\n\t\tcase 32000:\n\t\tcase 44100:\n\t\tcase 48000:\n\t\tcase 64000:\n\t\tcase 88200:\n\t\tcase 96000:\n\t\t\tdev_dbg(component->dev, \"Supported sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t\tuda1334->rate_constraint_list[j++] = val;\n\t\t\tuda1334->rate_constraint.count++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(component->dev, \"Skipping sample rate: %dHz\\n\",\n\t\t\t\tval);\n\t\t}\n\t}\n\n\t \n\tif (uda1334->rate_constraint.count == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int uda1334_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tfmt &= (SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_INV_MASK |\n\t\tSND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\n\tif (fmt != (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\n\t\t    SND_SOC_DAIFMT_CBC_CFC)) {\n\t\tdev_err(codec_dai->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int uda1334_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (uda1334->mute)\n\t\tgpiod_set_value_cansleep(uda1334->mute, mute);\n\n\treturn 0;\n}\n\n#define UDA1334_RATES SNDRV_PCM_RATE_8000_96000\n\n#define UDA1334_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops uda1334_dai_ops = {\n\t.startup\t= uda1334_startup,\n\t.shutdown\t= uda1334_shutdown,\n\t.set_sysclk\t= uda1334_set_dai_sysclk,\n\t.set_fmt\t= uda1334_set_fmt,\n\t.mute_stream\t= uda1334_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver uda1334_dai = {\n\t.name = \"uda1334-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = UDA1334_RATES,\n\t\t.formats = UDA1334_FORMATS,\n\t},\n\t.ops = &uda1334_dai_ops,\n};\n\nstatic int uda1334_probe(struct snd_soc_component *component)\n{\n\tstruct uda1334_priv *uda1334 = snd_soc_component_get_drvdata(component);\n\n\tuda1334->rate_constraint.list = &uda1334->rate_constraint_list[0];\n\tuda1334->rate_constraint.count =\n\t\tARRAY_SIZE(uda1334->rate_constraint_list);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_uda1334 = {\n\t.probe\t\t\t= uda1334_probe,\n\t.controls\t\t= uda1334_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(uda1334_snd_controls),\n\t.dapm_widgets\t\t= uda1334_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(uda1334_dapm_widgets),\n\t.dapm_routes\t\t= uda1334_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(uda1334_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id uda1334_of_match[] = {\n\t{ .compatible = \"nxp,uda1334\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uda1334_of_match);\n\nstatic int uda1334_codec_probe(struct platform_device *pdev)\n{\n\tstruct uda1334_priv *uda1334;\n\tint ret;\n\n\tuda1334 = devm_kzalloc(&pdev->dev, sizeof(struct uda1334_priv),\n\t\t\t       GFP_KERNEL);\n\tif (!uda1334)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, uda1334);\n\n\tuda1334->mute = devm_gpiod_get(&pdev->dev, \"nxp,mute\", GPIOD_OUT_LOW);\n\tif (IS_ERR(uda1334->mute)) {\n\t\tret = PTR_ERR(uda1334->mute);\n\t\tdev_err(&pdev->dev, \"Failed to get mute line: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tuda1334->deemph = devm_gpiod_get(&pdev->dev, \"nxp,deemph\", GPIOD_OUT_LOW);\n\tif (IS_ERR(uda1334->deemph)) {\n\t\tret = PTR_ERR(uda1334->deemph);\n\t\tdev_err(&pdev->dev, \"Failed to get deemph line: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t      &soc_component_dev_uda1334,\n\t\t\t\t\t      &uda1334_dai, 1);\n\tif (ret < 0)\n\t\tdev_err(&pdev->dev, \"Failed to register component: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct platform_driver uda1334_codec_driver = {\n\t.probe\t\t= uda1334_codec_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"uda1334-codec\",\n\t\t.of_match_table = uda1334_of_match,\n\t},\n};\nmodule_platform_driver(uda1334_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC UDA1334 driver\");\nMODULE_AUTHOR(\"Andra Danciu <andradanciu1997@gmail.com>\");\nMODULE_ALIAS(\"platform:uda1334-codec\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}