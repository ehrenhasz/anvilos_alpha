{
  "module_name": "idt821034.c",
  "hash_id": "e186c876868c083e7e321b5112c37112f54f02662966bd6f06dc61833ce9ac5b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/idt821034.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bitrev.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define IDT821034_NB_CHANNEL\t4\n\nstruct idt821034_amp {\n\tu16 gain;\n\tbool is_muted;\n};\n\nstruct idt821034 {\n\tstruct spi_device *spi;\n\tstruct mutex mutex;\n\tu8 spi_tx_buf;  \n\tu8 spi_rx_buf;  \n\tstruct {\n\t\tu8 codec_conf;\n\t\tstruct {\n\t\t\tu8 power;\n\t\t\tu8 tx_slot;\n\t\t\tu8 rx_slot;\n\t\t\tu8 slic_conf;\n\t\t\tu8 slic_control;\n\t\t} ch[IDT821034_NB_CHANNEL];\n\t} cache;\n\tstruct {\n\t\tstruct {\n\t\t\tstruct idt821034_amp amp_out;\n\t\t\tstruct idt821034_amp amp_in;\n\t\t} ch[IDT821034_NB_CHANNEL];\n\t} amps;\n\tint max_ch_playback;\n\tint max_ch_capture;\n\tstruct gpio_chip gpio_chip;\n};\n\nstatic int idt821034_8bit_write(struct idt821034 *idt821034, u8 val)\n{\n\tstruct spi_transfer xfer[] = {\n\t\t{\n\t\t\t.tx_buf = &idt821034->spi_tx_buf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.cs_off = 1,\n\t\t\t.tx_buf = &idt821034->spi_tx_buf,\n\t\t\t.len = 1,\n\t\t}\n\t};\n\n\tidt821034->spi_tx_buf = val;\n\n\tdev_vdbg(&idt821034->spi->dev, \"spi xfer wr 0x%x\\n\", val);\n\n\treturn spi_sync_transfer(idt821034->spi, xfer, 2);\n}\n\nstatic int idt821034_2x8bit_write(struct idt821034 *idt821034, u8 val1, u8 val2)\n{\n\tint ret;\n\n\tret = idt821034_8bit_write(idt821034, val1);\n\tif (ret)\n\t\treturn ret;\n\treturn idt821034_8bit_write(idt821034, val2);\n}\n\nstatic int idt821034_8bit_read(struct idt821034 *idt821034, u8 valw, u8 *valr)\n{\n\tstruct spi_transfer xfer[] = {\n\t\t{\n\t\t\t.tx_buf = &idt821034->spi_tx_buf,\n\t\t\t.rx_buf = &idt821034->spi_rx_buf,\n\t\t\t.len = 1,\n\t\t}, {\n\t\t\t.cs_off = 1,\n\t\t\t.tx_buf = &idt821034->spi_tx_buf,\n\t\t\t.len = 1,\n\t\t}\n\t};\n\tint ret;\n\n\tidt821034->spi_tx_buf = valw;\n\n\tret = spi_sync_transfer(idt821034->spi, xfer, 2);\n\tif (ret)\n\t\treturn ret;\n\n\t*valr = idt821034->spi_rx_buf;\n\n\tdev_vdbg(&idt821034->spi->dev, \"spi xfer wr 0x%x, rd 0x%x\\n\",\n\t\t valw, *valr);\n\n\treturn 0;\n}\n\n \n#define IDT821034_MODE_CODEC(_ch) (0x80 | ((_ch) << 2))\n#define IDT821034_MODE_SLIC(_ch)  (0xD0 | ((_ch) << 2))\n#define IDT821034_MODE_GAIN(_ch)  (0xC0 | ((_ch) << 2))\n\n \n#define IDT821034_CONF_PWRUP_TX\t\tBIT(1)  \n#define IDT821034_CONF_PWRUP_RX\t\tBIT(0)  \n\nstatic int idt821034_set_channel_power(struct idt821034 *idt821034, u8 ch, u8 power)\n{\n\tu8 conf;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"set_channel_power(%u, 0x%x)\\n\", ch, power);\n\n\tconf = IDT821034_MODE_CODEC(ch) | idt821034->cache.codec_conf;\n\n\tif (power & IDT821034_CONF_PWRUP_RX) {\n\t\tret = idt821034_2x8bit_write(idt821034,\n\t\t\t\t\t     conf | IDT821034_CONF_PWRUP_RX,\n\t\t\t\t\t     idt821034->cache.ch[ch].rx_slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (power & IDT821034_CONF_PWRUP_TX) {\n\t\tret = idt821034_2x8bit_write(idt821034,\n\t\t\t\t\t     conf | IDT821034_CONF_PWRUP_TX,\n\t\t\t\t\t     idt821034->cache.ch[ch].tx_slot);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!(power & (IDT821034_CONF_PWRUP_TX | IDT821034_CONF_PWRUP_RX))) {\n\t\tret = idt821034_2x8bit_write(idt821034, conf, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tidt821034->cache.ch[ch].power = power;\n\n\treturn 0;\n}\n\nstatic u8 idt821034_get_channel_power(struct idt821034 *idt821034, u8 ch)\n{\n\treturn idt821034->cache.ch[ch].power;\n}\n\n \n#define IDT821034_CONF_ALAW_MODE\tBIT(5)\n#define IDT821034_CONF_DELAY_MODE\tBIT(4)\n\nstatic int idt821034_set_codec_conf(struct idt821034 *idt821034, u8 codec_conf)\n{\n\tu8 conf;\n\tu8 ts;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"set_codec_conf(0x%x)\\n\", codec_conf);\n\n\t \n\n\t \n\tconf = IDT821034_MODE_CODEC(0) | codec_conf;\n\n\t \n\tif (idt821034->cache.ch[0].power & IDT821034_CONF_PWRUP_RX) {\n\t\tconf |= IDT821034_CONF_PWRUP_RX;\n\t\tts = idt821034->cache.ch[0].rx_slot;\n\t} else if (idt821034->cache.ch[0].power & IDT821034_CONF_PWRUP_TX) {\n\t\tconf |= IDT821034_CONF_PWRUP_TX;\n\t\tts = idt821034->cache.ch[0].tx_slot;\n\t} else {\n\t\tts = 0x00;\n\t}\n\n\t \n\tret = idt821034_2x8bit_write(idt821034, conf, ts);\n\tif (ret)\n\t\treturn ret;\n\n\tidt821034->cache.codec_conf = codec_conf;\n\treturn 0;\n}\n\nstatic u8 idt821034_get_codec_conf(struct idt821034 *idt821034)\n{\n\treturn idt821034->cache.codec_conf;\n}\n\n \n#define IDT821034_CH_RX\t\tBIT(0)  \n#define IDT821034_CH_TX\t\tBIT(1)  \n\nstatic int idt821034_set_channel_ts(struct idt821034 *idt821034, u8 ch, u8 ch_dir, u8 ts_num)\n{\n\tu8 conf;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"set_channel_ts(%u, 0x%x, %d)\\n\", ch, ch_dir, ts_num);\n\n\tconf = IDT821034_MODE_CODEC(ch) | idt821034->cache.codec_conf;\n\n\tif (ch_dir & IDT821034_CH_RX) {\n\t\tif (idt821034->cache.ch[ch].power & IDT821034_CONF_PWRUP_RX) {\n\t\t\tret = idt821034_2x8bit_write(idt821034,\n\t\t\t\t\t\t     conf | IDT821034_CONF_PWRUP_RX,\n\t\t\t\t\t\t     ts_num);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tidt821034->cache.ch[ch].rx_slot = ts_num;\n\t}\n\tif (ch_dir & IDT821034_CH_TX) {\n\t\tif (idt821034->cache.ch[ch].power & IDT821034_CONF_PWRUP_TX) {\n\t\t\tret = idt821034_2x8bit_write(idt821034,\n\t\t\t\t\t\t     conf | IDT821034_CONF_PWRUP_TX,\n\t\t\t\t\t\t     ts_num);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tidt821034->cache.ch[ch].tx_slot = ts_num;\n\t}\n\n\treturn 0;\n}\n\n \n#define IDT821034_SLIC_IO1_IN       BIT(1)\n#define IDT821034_SLIC_IO0_IN       BIT(0)\n\nstatic int idt821034_set_slic_conf(struct idt821034 *idt821034, u8 ch, u8 slic_dir)\n{\n\tu8 conf;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"set_slic_conf(%u, 0x%x)\\n\", ch, slic_dir);\n\n\tconf = IDT821034_MODE_SLIC(ch) | slic_dir;\n\tret = idt821034_2x8bit_write(idt821034, conf, idt821034->cache.ch[ch].slic_control);\n\tif (ret)\n\t\treturn ret;\n\n\tidt821034->cache.ch[ch].slic_conf = slic_dir;\n\n\treturn 0;\n}\n\nstatic u8 idt821034_get_slic_conf(struct idt821034 *idt821034, u8 ch)\n{\n\treturn idt821034->cache.ch[ch].slic_conf;\n}\n\nstatic int idt821034_write_slic_raw(struct idt821034 *idt821034, u8 ch, u8 slic_raw)\n{\n\tu8 conf;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"write_slic_raw(%u, 0x%x)\\n\", ch, slic_raw);\n\n\t \n\n\tconf = IDT821034_MODE_SLIC(ch) | idt821034->cache.ch[ch].slic_conf;\n\tret = idt821034_2x8bit_write(idt821034, conf, slic_raw);\n\tif (ret)\n\t\treturn ret;\n\n\tidt821034->cache.ch[ch].slic_control = slic_raw;\n\treturn 0;\n}\n\nstatic u8 idt821034_get_written_slic_raw(struct idt821034 *idt821034, u8 ch)\n{\n\treturn idt821034->cache.ch[ch].slic_control;\n}\n\nstatic int idt821034_read_slic_raw(struct idt821034 *idt821034, u8 ch, u8 *slic_raw)\n{\n\tu8 val;\n\tint ret;\n\n\t \n\n\tval = IDT821034_MODE_SLIC(ch) | idt821034->cache.ch[ch].slic_conf;\n\tret = idt821034_8bit_write(idt821034, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = idt821034_8bit_read(idt821034, idt821034->cache.ch[ch].slic_control, slic_raw);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"read_slic_raw(%i) 0x%x\\n\", ch, *slic_raw);\n\n\treturn 0;\n}\n\n \n#define IDT821034_GAIN_RX\t\t(0 << 1)  \n#define IDT821034_GAIN_TX\t\t(1 << 1)  \n\nstatic int idt821034_set_gain_channel(struct idt821034 *idt821034, u8 ch,\n\t\t\t\t      u8 gain_type, u16 gain_val)\n{\n\tu8 conf;\n\tint ret;\n\n\tdev_dbg(&idt821034->spi->dev, \"set_gain_channel(%u, 0x%x, 0x%x-%d)\\n\",\n\t\tch, gain_type, gain_val, gain_val);\n\n\t \n\n\tconf = IDT821034_MODE_GAIN(ch) | gain_type;\n\n\tret = idt821034_2x8bit_write(idt821034, conf | 0x00, gain_val & 0x007F);\n\tif (ret)\n\t\treturn ret;\n\n\tret = idt821034_2x8bit_write(idt821034, conf | 0x01, (gain_val >> 7) & 0x7F);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n#define IDT821034_DIR_OUT (1 << 3)\n#define IDT821034_DIR_IN  (0 << 3)\n#define IDT821034_ID(_ch, _dir) (((_ch) & 0x03) | (_dir))\n#define IDT821034_ID_OUT(_ch) IDT821034_ID(_ch, IDT821034_DIR_OUT)\n#define IDT821034_ID_IN(_ch)  IDT821034_ID(_ch, IDT821034_DIR_IN)\n\n#define IDT821034_ID_GET_CHAN(_id) ((_id) & 0x03)\n#define IDT821034_ID_GET_DIR(_id) ((_id) & (1 << 3))\n#define IDT821034_ID_IS_OUT(_id) (IDT821034_ID_GET_DIR(_id) == IDT821034_DIR_OUT)\n\nstatic int idt821034_kctrl_gain_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tint min = mc->min;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tint val;\n\tu8 ch;\n\n\tch = IDT821034_ID_GET_CHAN(mc->reg);\n\n\tmutex_lock(&idt821034->mutex);\n\tif (IDT821034_ID_IS_OUT(mc->reg))\n\t\tval = idt821034->amps.ch[ch].amp_out.gain;\n\telse\n\t\tval = idt821034->amps.ch[ch].amp_in.gain;\n\tmutex_unlock(&idt821034->mutex);\n\n\tucontrol->value.integer.value[0] = val & mask;\n\tif (invert)\n\t\tucontrol->value.integer.value[0] = max - ucontrol->value.integer.value[0];\n\telse\n\t\tucontrol->value.integer.value[0] = ucontrol->value.integer.value[0] - min;\n\n\treturn 0;\n}\n\nstatic int idt821034_kctrl_gain_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc = (struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tstruct idt821034_amp *amp;\n\tint min = mc->min;\n\tint max = mc->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = mc->invert;\n\tunsigned int val;\n\tint ret;\n\tu8 gain_type;\n\tu8 ch;\n\n\tval = ucontrol->value.integer.value[0];\n\tif (val > max - min)\n\t\treturn -EINVAL;\n\n\tif (invert)\n\t\tval = (max - val) & mask;\n\telse\n\t\tval = (val + min) & mask;\n\n\tch = IDT821034_ID_GET_CHAN(mc->reg);\n\n\tmutex_lock(&idt821034->mutex);\n\n\tif (IDT821034_ID_IS_OUT(mc->reg)) {\n\t\tamp = &idt821034->amps.ch[ch].amp_out;\n\t\tgain_type = IDT821034_GAIN_RX;\n\t} else {\n\t\tamp = &idt821034->amps.ch[ch].amp_in;\n\t\tgain_type = IDT821034_GAIN_TX;\n\t}\n\n\tif (amp->gain == val) {\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tif (!amp->is_muted) {\n\t\tret = idt821034_set_gain_channel(idt821034, ch, gain_type, val);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tamp->gain = val;\n\tret = 1;  \nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_kctrl_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tint id = kcontrol->private_value;\n\tbool is_muted;\n\tu8 ch;\n\n\tch = IDT821034_ID_GET_CHAN(id);\n\n\tmutex_lock(&idt821034->mutex);\n\tis_muted = IDT821034_ID_IS_OUT(id) ?\n\t\t\tidt821034->amps.ch[ch].amp_out.is_muted :\n\t\t\tidt821034->amps.ch[ch].amp_in.is_muted;\n\tmutex_unlock(&idt821034->mutex);\n\n\tucontrol->value.integer.value[0] = !is_muted;\n\n\treturn 0;\n}\n\nstatic int idt821034_kctrl_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t    struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tint id = kcontrol->private_value;\n\tstruct idt821034_amp *amp;\n\tbool is_mute;\n\tu8 gain_type;\n\tint ret;\n\tu8 ch;\n\n\tch = IDT821034_ID_GET_CHAN(id);\n\tis_mute = !ucontrol->value.integer.value[0];\n\n\tmutex_lock(&idt821034->mutex);\n\n\tif (IDT821034_ID_IS_OUT(id)) {\n\t\tamp = &idt821034->amps.ch[ch].amp_out;\n\t\tgain_type = IDT821034_GAIN_RX;\n\t} else {\n\t\tamp = &idt821034->amps.ch[ch].amp_in;\n\t\tgain_type = IDT821034_GAIN_TX;\n\t}\n\n\tif (amp->is_muted == is_mute) {\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tret = idt821034_set_gain_channel(idt821034, ch, gain_type,\n\t\t\t\t\t is_mute ? 0 : amp->gain);\n\tif (ret)\n\t\tgoto end;\n\n\tamp->is_muted = is_mute;\n\tret = 1;  \nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic const DECLARE_TLV_DB_LINEAR(idt821034_gain_in, -6520, 1306);\n#define IDT821034_GAIN_IN_MIN_RAW\t1  \n#define IDT821034_GAIN_IN_MAX_RAW\t8191  \n#define IDT821034_GAIN_IN_INIT_RAW\t1820  \n\nstatic const DECLARE_TLV_DB_LINEAR(idt821034_gain_out, -6798, 1029);\n#define IDT821034_GAIN_OUT_MIN_RAW\t1  \n#define IDT821034_GAIN_OUT_MAX_RAW\t8191  \n#define IDT821034_GAIN_OUT_INIT_RAW\t2506  \n\nstatic const struct snd_kcontrol_new idt821034_controls[] = {\n\t \n\tSOC_SINGLE_RANGE_EXT_TLV(\"DAC0 Playback Volume\", IDT821034_ID_OUT(0), 0,\n\t\t\t\t IDT821034_GAIN_OUT_MIN_RAW, IDT821034_GAIN_OUT_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_out),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"DAC1 Playback Volume\", IDT821034_ID_OUT(1), 0,\n\t\t\t\t IDT821034_GAIN_OUT_MIN_RAW, IDT821034_GAIN_OUT_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_out),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"DAC2 Playback Volume\", IDT821034_ID_OUT(2), 0,\n\t\t\t\t IDT821034_GAIN_OUT_MIN_RAW, IDT821034_GAIN_OUT_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_out),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"DAC3 Playback Volume\", IDT821034_ID_OUT(3), 0,\n\t\t\t\t IDT821034_GAIN_OUT_MIN_RAW, IDT821034_GAIN_OUT_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_out),\n\n\t \n\tSOC_SINGLE_BOOL_EXT(\"DAC0 Playback Switch\", IDT821034_ID_OUT(0),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"DAC1 Playback Switch\", IDT821034_ID_OUT(1),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"DAC2 Playback Switch\", IDT821034_ID_OUT(2),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"DAC3 Playback Switch\", IDT821034_ID_OUT(3),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\n\t \n\tSOC_SINGLE_RANGE_EXT_TLV(\"ADC0 Capture Volume\", IDT821034_ID_IN(0), 0,\n\t\t\t\t IDT821034_GAIN_IN_MIN_RAW, IDT821034_GAIN_IN_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_in),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"ADC1 Capture Volume\", IDT821034_ID_IN(1), 0,\n\t\t\t\t IDT821034_GAIN_IN_MIN_RAW, IDT821034_GAIN_IN_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_in),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"ADC2 Capture Volume\", IDT821034_ID_IN(2), 0,\n\t\t\t\t IDT821034_GAIN_IN_MIN_RAW, IDT821034_GAIN_IN_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_in),\n\tSOC_SINGLE_RANGE_EXT_TLV(\"ADC3 Capture Volume\", IDT821034_ID_IN(3), 0,\n\t\t\t\t IDT821034_GAIN_IN_MIN_RAW, IDT821034_GAIN_IN_MAX_RAW,\n\t\t\t\t 0, idt821034_kctrl_gain_get, idt821034_kctrl_gain_put,\n\t\t\t\t idt821034_gain_in),\n\n\t \n\tSOC_SINGLE_BOOL_EXT(\"ADC0 Capture Switch\", IDT821034_ID_IN(0),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"ADC1 Capture Switch\", IDT821034_ID_IN(1),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"ADC2 Capture Switch\", IDT821034_ID_IN(2),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n\tSOC_SINGLE_BOOL_EXT(\"ADC3 Capture Switch\", IDT821034_ID_IN(3),\n\t\t\t    idt821034_kctrl_mute_get, idt821034_kctrl_mute_put),\n};\n\nstatic int idt821034_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tunsigned int id = w->shift;\n\tu8 power, mask;\n\tint ret;\n\tu8 ch;\n\n\tch = IDT821034_ID_GET_CHAN(id);\n\tmask = IDT821034_ID_IS_OUT(id) ? IDT821034_CONF_PWRUP_RX : IDT821034_CONF_PWRUP_TX;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tpower = idt821034_get_channel_power(idt821034, ch);\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\tpower |= mask;\n\telse\n\t\tpower &= ~mask;\n\tret = idt821034_set_channel_power(idt821034, ch, power);\n\n\tmutex_unlock(&idt821034->mutex);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget idt821034_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"DAC0\", \"Playback\", SND_SOC_NOPM, IDT821034_ID_OUT(0), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DAC1\", \"Playback\", SND_SOC_NOPM, IDT821034_ID_OUT(1), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DAC2\", \"Playback\", SND_SOC_NOPM, IDT821034_ID_OUT(2), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"DAC3\", \"Playback\", SND_SOC_NOPM, IDT821034_ID_OUT(3), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT0\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\n\tSND_SOC_DAPM_DAC_E(\"ADC0\", \"Capture\", SND_SOC_NOPM, IDT821034_ID_IN(0), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"ADC1\", \"Capture\", SND_SOC_NOPM, IDT821034_ID_IN(1), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"ADC2\", \"Capture\", SND_SOC_NOPM, IDT821034_ID_IN(2), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"ADC3\", \"Capture\", SND_SOC_NOPM, IDT821034_ID_IN(3), 0,\n\t\t\t   idt821034_power_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_INPUT(\"IN0\"),\n\tSND_SOC_DAPM_INPUT(\"IN1\"),\n\tSND_SOC_DAPM_INPUT(\"IN2\"),\n\tSND_SOC_DAPM_INPUT(\"IN3\"),\n};\n\nstatic const struct snd_soc_dapm_route idt821034_dapm_routes[] = {\n\t{ \"OUT0\", NULL, \"DAC0\" },\n\t{ \"OUT1\", NULL, \"DAC1\" },\n\t{ \"OUT2\", NULL, \"DAC2\" },\n\t{ \"OUT3\", NULL, \"DAC3\" },\n\n\t{ \"ADC0\", NULL, \"IN0\" },\n\t{ \"ADC1\", NULL, \"IN1\" },\n\t{ \"ADC2\", NULL, \"IN2\" },\n\t{ \"ADC3\", NULL, \"IN3\" },\n};\n\nstatic int idt821034_dai_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t      int slots, int width)\n{\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int mask;\n\tu8 slot;\n\tint ret;\n\tu8 ch;\n\n\tswitch (width) {\n\tcase 0:  \n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"tdm slot width %d not supported\\n\", width);\n\t\treturn -EINVAL;\n\t}\n\n\tmask = tx_mask;\n\tslot = 0;\n\tch = 0;\n\twhile (mask && ch < IDT821034_NB_CHANNEL) {\n\t\tif (mask & 0x1) {\n\t\t\tmutex_lock(&idt821034->mutex);\n\t\t\tret = idt821034_set_channel_ts(idt821034, ch, IDT821034_CH_RX, slot);\n\t\t\tmutex_unlock(&idt821034->mutex);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dai->dev, \"ch%u set tx tdm slot failed (%d)\\n\",\n\t\t\t\t\tch, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tch++;\n\t\t}\n\t\tmask >>= 1;\n\t\tslot++;\n\t}\n\tif (mask) {\n\t\tdev_err(dai->dev, \"too much tx slots defined (mask = 0x%x) support max %d\\n\",\n\t\t\ttx_mask, IDT821034_NB_CHANNEL);\n\t\treturn -EINVAL;\n\t}\n\tidt821034->max_ch_playback = ch;\n\n\tmask = rx_mask;\n\tslot = 0;\n\tch = 0;\n\twhile (mask && ch < IDT821034_NB_CHANNEL) {\n\t\tif (mask & 0x1) {\n\t\t\tmutex_lock(&idt821034->mutex);\n\t\t\tret = idt821034_set_channel_ts(idt821034, ch, IDT821034_CH_TX, slot);\n\t\t\tmutex_unlock(&idt821034->mutex);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dai->dev, \"ch%u set rx tdm slot failed (%d)\\n\",\n\t\t\t\t\tch, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tch++;\n\t\t}\n\t\tmask >>= 1;\n\t\tslot++;\n\t}\n\tif (mask) {\n\t\tdev_err(dai->dev, \"too much rx slots defined (mask = 0x%x) support max %d\\n\",\n\t\t\trx_mask, IDT821034_NB_CHANNEL);\n\t\treturn -EINVAL;\n\t}\n\tidt821034->max_ch_capture = ch;\n\n\treturn 0;\n}\n\nstatic int idt821034_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(dai->component);\n\tu8 conf;\n\tint ret;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tconf = idt821034_get_codec_conf(idt821034);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tconf |= IDT821034_CONF_DELAY_MODE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tconf &= ~IDT821034_CONF_DELAY_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported DAI format 0x%x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\tret = idt821034_set_codec_conf(idt821034, conf);\nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(dai->component);\n\tu8 conf;\n\tint ret;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tconf = idt821034_get_codec_conf(idt821034);\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tconf |= IDT821034_CONF_ALAW_MODE;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tconf &= ~IDT821034_CONF_ALAW_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported PCM format 0x%x\\n\",\n\t\t\tparams_format(params));\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\tret = idt821034_set_codec_conf(idt821034, conf);\nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic const unsigned int idt821034_sample_bits[] = {8};\n\nstatic struct snd_pcm_hw_constraint_list idt821034_sample_bits_constr = {\n\t.list = idt821034_sample_bits,\n\t.count = ARRAY_SIZE(idt821034_sample_bits),\n};\n\nstatic int idt821034_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int max_ch = 0;\n\tint ret;\n\n\tmax_ch = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\tidt821034->max_ch_playback : idt821034->max_ch_capture;\n\n\t \n\tret = snd_pcm_hw_constraint_minmax(substream->runtime, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   max_ch ? 1 : 0, max_ch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_pcm_hw_constraint_list(substream->runtime, 0, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\n\t\t\t\t\t &idt821034_sample_bits_constr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic u64 idt821034_dai_formats[] = {\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B,\n};\n\nstatic const struct snd_soc_dai_ops idt821034_dai_ops = {\n\t.startup      = idt821034_dai_startup,\n\t.hw_params    = idt821034_dai_hw_params,\n\t.set_tdm_slot = idt821034_dai_set_tdm_slot,\n\t.set_fmt      = idt821034_dai_set_fmt,\n\t.auto_selectable_formats     = idt821034_dai_formats,\n\t.num_auto_selectable_formats = ARRAY_SIZE(idt821034_dai_formats),\n};\n\nstatic struct snd_soc_dai_driver idt821034_dai_driver = {\n\t.name = \"idt821034\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = IDT821034_NB_CHANNEL,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = IDT821034_NB_CHANNEL,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t},\n\t.ops = &idt821034_dai_ops,\n};\n\nstatic int idt821034_reset_audio(struct idt821034 *idt821034)\n{\n\tint ret;\n\tu8 i;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tret = idt821034_set_codec_conf(idt821034, 0);\n\tif (ret)\n\t\tgoto end;\n\n\tfor (i = 0; i < IDT821034_NB_CHANNEL; i++) {\n\t\tidt821034->amps.ch[i].amp_out.gain = IDT821034_GAIN_OUT_INIT_RAW;\n\t\tidt821034->amps.ch[i].amp_out.is_muted = false;\n\t\tret = idt821034_set_gain_channel(idt821034, i, IDT821034_GAIN_RX,\n\t\t\t\t\t\t idt821034->amps.ch[i].amp_out.gain);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\tidt821034->amps.ch[i].amp_in.gain = IDT821034_GAIN_IN_INIT_RAW;\n\t\tidt821034->amps.ch[i].amp_in.is_muted = false;\n\t\tret = idt821034_set_gain_channel(idt821034, i, IDT821034_GAIN_TX,\n\t\t\t\t\t\t idt821034->amps.ch[i].amp_in.gain);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\tret = idt821034_set_channel_power(idt821034, i, 0);\n\t\tif (ret)\n\t\t\tgoto end;\n\t}\n\n\tret = 0;\nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_component_probe(struct snd_soc_component *component)\n{\n\tstruct idt821034 *idt821034 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\t \n\tret = idt821034_reset_audio(idt821034);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver idt821034_component_driver = {\n\t.probe\t\t\t= idt821034_component_probe,\n\t.controls\t\t= idt821034_controls,\n\t.num_controls\t\t= ARRAY_SIZE(idt821034_controls),\n\t.dapm_widgets\t\t= idt821034_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(idt821034_dapm_widgets),\n\t.dapm_routes\t\t= idt821034_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(idt821034_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\n#define IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(_offset) (((_offset) / 5) % 4)\n#define IDT821034_GPIO_OFFSET_TO_SLIC_MASK(_offset)    BIT((_offset) % 5)\n\nstatic void idt821034_chip_gpio_set(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tu8 ch = IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(offset);\n\tu8 mask = IDT821034_GPIO_OFFSET_TO_SLIC_MASK(offset);\n\tstruct idt821034 *idt821034 = gpiochip_get_data(c);\n\tu8 slic_raw;\n\tint ret;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tslic_raw = idt821034_get_written_slic_raw(idt821034, ch);\n\tif (val)\n\t\tslic_raw |= mask;\n\telse\n\t\tslic_raw &= ~mask;\n\tret = idt821034_write_slic_raw(idt821034, ch, slic_raw);\n\tif (ret) {\n\t\tdev_err(&idt821034->spi->dev, \"set gpio %d (%u, 0x%x) failed (%d)\\n\",\n\t\t\toffset, ch, mask, ret);\n\t}\n\n\tmutex_unlock(&idt821034->mutex);\n}\n\nstatic int idt821034_chip_gpio_get(struct gpio_chip *c, unsigned int offset)\n{\n\tu8 ch = IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(offset);\n\tu8 mask = IDT821034_GPIO_OFFSET_TO_SLIC_MASK(offset);\n\tstruct idt821034 *idt821034 = gpiochip_get_data(c);\n\tu8 slic_raw;\n\tint ret;\n\n\tmutex_lock(&idt821034->mutex);\n\tret = idt821034_read_slic_raw(idt821034, ch, &slic_raw);\n\tmutex_unlock(&idt821034->mutex);\n\tif (ret) {\n\t\tdev_err(&idt821034->spi->dev, \"get gpio %d (%u, 0x%x) failed (%d)\\n\",\n\t\t\toffset, ch, mask, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treturn !!(bitrev8(slic_raw) & mask);\n}\n\nstatic int idt821034_chip_get_direction(struct gpio_chip *c, unsigned int offset)\n{\n\tu8 ch = IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(offset);\n\tu8 mask = IDT821034_GPIO_OFFSET_TO_SLIC_MASK(offset);\n\tstruct idt821034 *idt821034 = gpiochip_get_data(c);\n\tu8 slic_dir;\n\n\tmutex_lock(&idt821034->mutex);\n\tslic_dir = idt821034_get_slic_conf(idt821034, ch);\n\tmutex_unlock(&idt821034->mutex);\n\n\treturn slic_dir & mask ? GPIO_LINE_DIRECTION_IN : GPIO_LINE_DIRECTION_OUT;\n}\n\nstatic int idt821034_chip_direction_input(struct gpio_chip *c, unsigned int offset)\n{\n\tu8 ch = IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(offset);\n\tu8 mask = IDT821034_GPIO_OFFSET_TO_SLIC_MASK(offset);\n\tstruct idt821034 *idt821034 = gpiochip_get_data(c);\n\tu8 slic_conf;\n\tint ret;\n\n\t \n\tif (mask & ~(IDT821034_SLIC_IO1_IN | IDT821034_SLIC_IO0_IN))\n\t\treturn -EPERM;\n\n\tmutex_lock(&idt821034->mutex);\n\n\tslic_conf = idt821034_get_slic_conf(idt821034, ch) | mask;\n\n\tret = idt821034_set_slic_conf(idt821034, ch, slic_conf);\n\tif (ret) {\n\t\tdev_err(&idt821034->spi->dev, \"dir in gpio %d (%u, 0x%x) failed (%d)\\n\",\n\t\t\toffset, ch, mask, ret);\n\t}\n\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_chip_direction_output(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tu8 ch = IDT821034_GPIO_OFFSET_TO_SLIC_CHANNEL(offset);\n\tu8 mask = IDT821034_GPIO_OFFSET_TO_SLIC_MASK(offset);\n\tstruct idt821034 *idt821034 = gpiochip_get_data(c);\n\tu8 slic_conf;\n\tint ret;\n\n\tidt821034_chip_gpio_set(c, offset, val);\n\n\tmutex_lock(&idt821034->mutex);\n\n\tslic_conf = idt821034_get_slic_conf(idt821034, ch) & ~mask;\n\n\tret = idt821034_set_slic_conf(idt821034, ch, slic_conf);\n\tif (ret) {\n\t\tdev_err(&idt821034->spi->dev, \"dir in gpio %d (%u, 0x%x) failed (%d)\\n\",\n\t\t\toffset, ch, mask, ret);\n\t}\n\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_reset_gpio(struct idt821034 *idt821034)\n{\n\tint ret;\n\tu8 i;\n\n\tmutex_lock(&idt821034->mutex);\n\n\t \n\tfor (i = 0; i < IDT821034_NB_CHANNEL; i++) {\n\t\tret = idt821034_set_slic_conf(idt821034, i,\n\t\t\t\t\t      IDT821034_SLIC_IO1_IN | IDT821034_SLIC_IO0_IN);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\tret = idt821034_write_slic_raw(idt821034, i, 0);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t}\n\tret = 0;\nend:\n\tmutex_unlock(&idt821034->mutex);\n\treturn ret;\n}\n\nstatic int idt821034_gpio_init(struct idt821034 *idt821034)\n{\n\tint ret;\n\n\tret = idt821034_reset_gpio(idt821034);\n\tif (ret)\n\t\treturn ret;\n\n\tidt821034->gpio_chip.owner = THIS_MODULE;\n\tidt821034->gpio_chip.label = dev_name(&idt821034->spi->dev);\n\tidt821034->gpio_chip.parent = &idt821034->spi->dev;\n\tidt821034->gpio_chip.base = -1;\n\tidt821034->gpio_chip.ngpio = 5 * 4;  \n\tidt821034->gpio_chip.get_direction = idt821034_chip_get_direction;\n\tidt821034->gpio_chip.direction_input = idt821034_chip_direction_input;\n\tidt821034->gpio_chip.direction_output = idt821034_chip_direction_output;\n\tidt821034->gpio_chip.get = idt821034_chip_gpio_get;\n\tidt821034->gpio_chip.set = idt821034_chip_gpio_set;\n\tidt821034->gpio_chip.can_sleep = true;\n\n\treturn devm_gpiochip_add_data(&idt821034->spi->dev, &idt821034->gpio_chip,\n\t\t\t\t      idt821034);\n}\n\nstatic int idt821034_spi_probe(struct spi_device *spi)\n{\n\tstruct idt821034 *idt821034;\n\tint ret;\n\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tidt821034 = devm_kzalloc(&spi->dev, sizeof(*idt821034), GFP_KERNEL);\n\tif (!idt821034)\n\t\treturn -ENOMEM;\n\n\tidt821034->spi = spi;\n\n\tmutex_init(&idt821034->mutex);\n\n\tspi_set_drvdata(spi, idt821034);\n\n\tret = devm_snd_soc_register_component(&spi->dev, &idt821034_component_driver,\n\t\t\t\t\t      &idt821034_dai_driver, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (IS_ENABLED(CONFIG_GPIOLIB))\n\t\treturn idt821034_gpio_init(idt821034);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id idt821034_of_match[] = {\n\t{ .compatible = \"renesas,idt821034\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, idt821034_of_match);\n\nstatic const struct spi_device_id idt821034_id_table[] = {\n\t{ \"idt821034\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, idt821034_id_table);\n\nstatic struct spi_driver idt821034_spi_driver = {\n\t.driver  = {\n\t\t.name   = \"idt821034\",\n\t\t.of_match_table = idt821034_of_match,\n\t},\n\t.id_table = idt821034_id_table,\n\t.probe  = idt821034_spi_probe,\n};\n\nmodule_spi_driver(idt821034_spi_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"IDT821034 ALSA SoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}