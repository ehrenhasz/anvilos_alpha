{
  "module_name": "max9860.c",
  "hash_id": "756988bfa7b4ff020cc8dfb5432ba0c4463da232fe50c9bdc14fb9d61864ab5a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max9860.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/regulator/consumer.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n\n#include \"max9860.h\"\n\nstruct max9860_priv {\n\tstruct regmap *regmap;\n\tstruct regulator *dvddio;\n\tstruct notifier_block dvddio_nb;\n\tu8 psclk;\n\tunsigned long pclk_rate;\n\tint fmt;\n};\n\nstatic int max9860_dvddio_event(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *data)\n{\n\tstruct max9860_priv *max9860 = container_of(nb, struct max9860_priv,\n\t\t\t\t\t\t    dvddio_nb);\n\tif (event & REGULATOR_EVENT_DISABLE) {\n\t\tregcache_mark_dirty(max9860->regmap);\n\t\tregcache_cache_only(max9860->regmap, true);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reg_default max9860_reg_defaults[] = {\n\t{ MAX9860_PWRMAN,       0x00 },\n\t{ MAX9860_INTEN,        0x00 },\n\t{ MAX9860_SYSCLK,       0x00 },\n\t{ MAX9860_AUDIOCLKHIGH, 0x00 },\n\t{ MAX9860_AUDIOCLKLOW,  0x00 },\n\t{ MAX9860_IFC1A,        0x00 },\n\t{ MAX9860_IFC1B,        0x00 },\n\t{ MAX9860_VOICEFLTR,    0x00 },\n\t{ MAX9860_DACATTN,      0x00 },\n\t{ MAX9860_ADCLEVEL,     0x00 },\n\t{ MAX9860_DACGAIN,      0x00 },\n\t{ MAX9860_MICGAIN,      0x00 },\n\t{ MAX9860_MICADC,       0x00 },\n\t{ MAX9860_NOISEGATE,    0x00 },\n};\n\nstatic bool max9860_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX9860_INTRSTATUS ... MAX9860_MICGAIN:\n\tcase MAX9860_MICADC ... MAX9860_PWRMAN:\n\tcase MAX9860_REVISION:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool max9860_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX9860_INTEN ... MAX9860_MICGAIN:\n\tcase MAX9860_MICADC ... MAX9860_PWRMAN:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool max9860_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX9860_INTRSTATUS:\n\tcase MAX9860_MICREADBACK:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool max9860_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX9860_INTRSTATUS:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct regmap_config max9860_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.readable_reg = max9860_readable,\n\t.writeable_reg = max9860_writeable,\n\t.volatile_reg = max9860_volatile,\n\t.precious_reg = max9860_precious,\n\n\t.max_register = MAX9860_MAX_REGISTER,\n\t.reg_defaults = max9860_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(max9860_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const DECLARE_TLV_DB_SCALE(dva_tlv, -9100, 100, 1);\nstatic const DECLARE_TLV_DB_SCALE(dvg_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_RANGE(pam_tlv,\n\t0, MAX9860_PAM_MAX - 1,             TLV_DB_SCALE_ITEM(-2000, 2000, 1),\n\tMAX9860_PAM_MAX, MAX9860_PAM_MAX,   TLV_DB_SCALE_ITEM(3000, 0, 0));\nstatic const DECLARE_TLV_DB_SCALE(pgam_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(anth_tlv, -7600, 400, 1);\nstatic const DECLARE_TLV_DB_SCALE(agcth_tlv, -1800, 100, 0);\n\nstatic const char * const agchld_text[] = {\n\t\"AGC Disabled\", \"50ms\", \"100ms\", \"400ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(agchld_enum, MAX9860_MICADC,\n\t\t\t    MAX9860_AGCHLD_SHIFT, agchld_text);\n\nstatic const char * const agcsrc_text[] = {\n\t\"Left ADC\", \"Left/Right ADC\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(agcsrc_enum, MAX9860_MICADC,\n\t\t\t    MAX9860_AGCSRC_SHIFT, agcsrc_text);\n\nstatic const char * const agcatk_text[] = {\n\t\"3ms\", \"12ms\", \"50ms\", \"200ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(agcatk_enum, MAX9860_MICADC,\n\t\t\t    MAX9860_AGCATK_SHIFT, agcatk_text);\n\nstatic const char * const agcrls_text[] = {\n\t\"78ms\", \"156ms\", \"312ms\", \"625ms\",\n\t\"1.25s\", \"2.5s\", \"5s\", \"10s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(agcrls_enum, MAX9860_MICADC,\n\t\t\t    MAX9860_AGCRLS_SHIFT, agcrls_text);\n\nstatic const char * const filter_text[] = {\n\t\"Disabled\",\n\t\"Elliptical HP 217Hz notch (16kHz)\",\n\t\"Butterworth HP 500Hz (16kHz)\",\n\t\"Elliptical HP 217Hz notch (8kHz)\",\n\t\"Butterworth HP 500Hz (8kHz)\",\n\t\"Butterworth HP 200Hz (48kHz)\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(avflt_enum, MAX9860_VOICEFLTR,\n\t\t\t    MAX9860_AVFLT_SHIFT, filter_text);\n\nstatic SOC_ENUM_SINGLE_DECL(dvflt_enum, MAX9860_VOICEFLTR,\n\t\t\t    MAX9860_DVFLT_SHIFT, filter_text);\n\nstatic const struct snd_kcontrol_new max9860_controls[] = {\nSOC_SINGLE_TLV(\"Master Playback Volume\", MAX9860_DACATTN,\n\t       MAX9860_DVA_SHIFT, MAX9860_DVA_MUTE, 1, dva_tlv),\nSOC_SINGLE_TLV(\"DAC Gain Volume\", MAX9860_DACGAIN,\n\t       MAX9860_DVG_SHIFT, MAX9860_DVG_MAX, 0, dvg_tlv),\nSOC_DOUBLE_TLV(\"Line Capture Volume\", MAX9860_ADCLEVEL,\n\t       MAX9860_ADCLL_SHIFT, MAX9860_ADCRL_SHIFT, MAX9860_ADCxL_MIN, 1,\n\t       adc_tlv),\n\nSOC_ENUM(\"AGC Hold Time\", agchld_enum),\nSOC_ENUM(\"AGC/Noise Gate Source\", agcsrc_enum),\nSOC_ENUM(\"AGC Attack Time\", agcatk_enum),\nSOC_ENUM(\"AGC Release Time\", agcrls_enum),\n\nSOC_SINGLE_TLV(\"Noise Gate Threshold Volume\", MAX9860_NOISEGATE,\n\t       MAX9860_ANTH_SHIFT, MAX9860_ANTH_MAX, 0, anth_tlv),\nSOC_SINGLE_TLV(\"AGC Signal Threshold Volume\", MAX9860_NOISEGATE,\n\t       MAX9860_AGCTH_SHIFT, MAX9860_AGCTH_MIN, 1, agcth_tlv),\n\nSOC_SINGLE_TLV(\"Mic PGA Volume\", MAX9860_MICGAIN,\n\t       MAX9860_PGAM_SHIFT, MAX9860_PGAM_MIN, 1, pgam_tlv),\nSOC_SINGLE_TLV(\"Mic Preamp Volume\", MAX9860_MICGAIN,\n\t       MAX9860_PAM_SHIFT, MAX9860_PAM_MAX, 0, pam_tlv),\n\nSOC_ENUM(\"ADC Filter\", avflt_enum),\nSOC_ENUM(\"DAC Filter\", dvflt_enum),\n};\n\nstatic const struct snd_soc_dapm_widget max9860_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"MICL\"),\nSND_SOC_DAPM_INPUT(\"MICR\"),\n\nSND_SOC_DAPM_ADC(\"ADCL\", NULL, MAX9860_PWRMAN, MAX9860_ADCLEN_SHIFT, 0),\nSND_SOC_DAPM_ADC(\"ADCR\", NULL, MAX9860_PWRMAN, MAX9860_ADCREN_SHIFT, 0),\n\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTL\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTR\", \"Capture\", 1, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_DAC(\"DAC\", NULL, MAX9860_PWRMAN, MAX9860_DACEN_SHIFT, 0),\n\nSND_SOC_DAPM_OUTPUT(\"OUT\"),\n\nSND_SOC_DAPM_SUPPLY(\"Supply\", SND_SOC_NOPM, 0, 0,\n\t\t    NULL, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_REGULATOR_SUPPLY(\"AVDD\", 0, 0),\nSND_SOC_DAPM_REGULATOR_SUPPLY(\"DVDD\", 0, 0),\nSND_SOC_DAPM_CLOCK_SUPPLY(\"mclk\"),\n};\n\nstatic const struct snd_soc_dapm_route max9860_dapm_routes[] = {\n\t{ \"ADCL\", NULL, \"MICL\" },\n\t{ \"ADCR\", NULL, \"MICR\" },\n\t{ \"AIFOUTL\", NULL, \"ADCL\" },\n\t{ \"AIFOUTR\", NULL, \"ADCR\" },\n\n\t{ \"DAC\", NULL, \"AIFINL\" },\n\t{ \"DAC\", NULL, \"AIFINR\" },\n\t{ \"OUT\", NULL, \"DAC\" },\n\n\t{ \"Supply\", NULL, \"AVDD\" },\n\t{ \"Supply\", NULL, \"DVDD\" },\n\t{ \"Supply\", NULL, \"mclk\" },\n\n\t{ \"DAC\", NULL, \"Supply\" },\n\t{ \"ADCL\", NULL, \"Supply\" },\n\t{ \"ADCR\", NULL, \"Supply\" },\n};\n\nstatic int max9860_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max9860_priv *max9860 = snd_soc_component_get_drvdata(component);\n\tu8 master;\n\tu8 ifc1a = 0;\n\tu8 ifc1b = 0;\n\tu8 sysclk = 0;\n\tunsigned long n;\n\tint ret;\n\n\tdev_dbg(component->dev, \"hw_params %u Hz, %u channels\\n\",\n\t\tparams_rate(params),\n\t\tparams_channels(params));\n\n\tif (params_channels(params) == 2)\n\t\tifc1b |= MAX9860_ST;\n\n\tswitch (max9860->fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmaster = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tmaster = MAX9860_MASTER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tifc1a |= master;\n\n\tif (master) {\n\t\tif (params_width(params) * params_channels(params) > 48)\n\t\t\tifc1b |= MAX9860_BSEL_64X;\n\t\telse\n\t\t\tifc1b |= MAX9860_BSEL_48X;\n\t}\n\n\tswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tifc1a |= MAX9860_DDLY;\n\t\tifc1b |= MAX9860_ADLY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tifc1a |= MAX9860_WCI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tif (params_width(params) != 16) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"DSP_A works for 16 bits per sample only.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tifc1a |= MAX9860_DDLY | MAX9860_WCI | MAX9860_HIZ | MAX9860_TDM;\n\t\tifc1b |= MAX9860_ADLY;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tif (params_width(params) != 16) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"DSP_B works for 16 bits per sample only.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tifc1a |= MAX9860_WCI | MAX9860_HIZ | MAX9860_TDM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (max9860->fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tifc1a ^= MAX9860_WCI;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\t\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tifc1a ^= MAX9860_WCI;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tifc1a ^= MAX9860_DBCI;\n\t\tifc1b ^= MAX9860_ABCI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"IFC1A  %02x\\n\", ifc1a);\n\tret = regmap_write(max9860->regmap, MAX9860_IFC1A, ifc1a);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to set IFC1A: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(component->dev, \"IFC1B  %02x\\n\", ifc1b);\n\tret = regmap_write(max9860->regmap, MAX9860_IFC1B, ifc1b);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to set IFC1B: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (params_rate(params) == 8000 || params_rate(params) == 16000) {\n\t\tif (master) {\n\t\t\tswitch (max9860->pclk_rate) {\n\t\t\tcase 12000000:\n\t\t\t\tsysclk = MAX9860_FREQ_12MHZ;\n\t\t\t\tbreak;\n\t\t\tcase 13000000:\n\t\t\t\tsysclk = MAX9860_FREQ_13MHZ;\n\t\t\t\tbreak;\n\t\t\tcase 19200000:\n\t\t\t\tsysclk = MAX9860_FREQ_19_2MHZ;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sysclk && params_rate(params) == 16000)\n\t\t\t\tsysclk |= MAX9860_16KHZ;\n\t\t}\n\t}\n\n\t \n\tn = DIV_ROUND_CLOSEST_ULL(65536ULL * 96 * params_rate(params),\n\t\t\t\t  max9860->pclk_rate);\n\n\tif (!sysclk) {\n\t\t \n\t\tif (params_rate(params) > 24000)\n\t\t\tsysclk |= MAX9860_16KHZ;\n\n\t\tif (!master)\n\t\t\tn |= 1;  \n\t}\n\n\tsysclk |= max9860->psclk;\n\tdev_dbg(component->dev, \"SYSCLK %02x\\n\", sysclk);\n\tret = regmap_write(max9860->regmap,\n\t\t\t   MAX9860_SYSCLK, sysclk);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to set SYSCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(component->dev, \"N %lu\\n\", n);\n\tret = regmap_write(max9860->regmap,\n\t\t\t   MAX9860_AUDIOCLKHIGH, n >> 8);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to set NHI: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regmap_write(max9860->regmap,\n\t\t\t   MAX9860_AUDIOCLKLOW, n & 0xff);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to set NLO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!master) {\n\t\tdev_dbg(component->dev, \"Enable PLL\\n\");\n\t\tret = regmap_update_bits(max9860->regmap, MAX9860_AUDIOCLKHIGH,\n\t\t\t\t\t MAX9860_PLL, MAX9860_PLL);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to enable PLL: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int max9860_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max9860_priv *max9860 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmax9860->fmt = fmt;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct snd_soc_dai_ops max9860_dai_ops = {\n\t.hw_params = max9860_hw_params,\n\t.set_fmt = max9860_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver max9860_dai = {\n\t.name = \"max9860-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t\t.rate_min = 8000,\n\t\t.rate_max = 48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t},\n\t.ops = &max9860_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int max9860_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct max9860_priv *max9860 = dev_get_drvdata(component->dev);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tret = regmap_update_bits(max9860->regmap, MAX9860_PWRMAN,\n\t\t\t\t\t MAX9860_SHDN, MAX9860_SHDN);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to remove SHDN: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tret = regmap_update_bits(max9860->regmap, MAX9860_PWRMAN,\n\t\t\t\t\t MAX9860_SHDN, 0);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"Failed to request SHDN: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver max9860_component_driver = {\n\t.set_bias_level\t\t= max9860_set_bias_level,\n\t.controls\t\t= max9860_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max9860_controls),\n\t.dapm_widgets\t\t= max9860_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max9860_dapm_widgets),\n\t.dapm_routes\t\t= max9860_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(max9860_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\n#ifdef CONFIG_PM\nstatic int max9860_suspend(struct device *dev)\n{\n\tstruct max9860_priv *max9860 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regmap_update_bits(max9860->regmap, MAX9860_SYSCLK,\n\t\t\t\t MAX9860_PSCLK, MAX9860_PSCLK_OFF);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to disable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregulator_disable(max9860->dvddio);\n\n\treturn 0;\n}\n\nstatic int max9860_resume(struct device *dev)\n{\n\tstruct max9860_priv *max9860 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_enable(max9860->dvddio);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable DVDDIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(max9860->regmap, false);\n\tret = regcache_sync(max9860->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to sync cache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_update_bits(max9860->regmap, MAX9860_SYSCLK,\n\t\t\t\t MAX9860_PSCLK, max9860->psclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops max9860_pm_ops = {\n\tSET_RUNTIME_PM_OPS(max9860_suspend, max9860_resume, NULL)\n};\n\nstatic int max9860_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct max9860_priv *max9860;\n\tint ret;\n\tstruct clk *mclk;\n\tunsigned long mclk_rate;\n\tint i;\n\tint intr;\n\n\tmax9860 = devm_kzalloc(dev, sizeof(struct max9860_priv), GFP_KERNEL);\n\tif (!max9860)\n\t\treturn -ENOMEM;\n\n\tmax9860->dvddio = devm_regulator_get(dev, \"DVDDIO\");\n\tif (IS_ERR(max9860->dvddio))\n\t\treturn dev_err_probe(dev, PTR_ERR(max9860->dvddio),\n\t\t\t\t     \"Failed to get DVDDIO supply\\n\");\n\n\tmax9860->dvddio_nb.notifier_call = max9860_dvddio_event;\n\n\tret = devm_regulator_register_notifier(max9860->dvddio,\n\t\t\t\t\t       &max9860->dvddio_nb);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register DVDDIO notifier: %d\\n\", ret);\n\n\tret = regulator_enable(max9860->dvddio);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable DVDDIO: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmax9860->regmap = devm_regmap_init_i2c(i2c, &max9860_regmap);\n\tif (IS_ERR(max9860->regmap)) {\n\t\tret = PTR_ERR(max9860->regmap);\n\t\tgoto err_regulator;\n\t}\n\n\tdev_set_drvdata(dev, max9860);\n\n\t \n\tmclk = clk_get(dev, \"mclk\");\n\n\tif (IS_ERR(mclk)) {\n\t\tret = PTR_ERR(mclk);\n\t\tdev_err_probe(dev, ret, \"Failed to get MCLK\\n\");\n\t\tgoto err_regulator;\n\t}\n\n\tmclk_rate = clk_get_rate(mclk);\n\tclk_put(mclk);\n\n\tif (mclk_rate > 60000000 || mclk_rate < 10000000) {\n\t\tdev_err(dev, \"Bad mclk %luHz (needs 10MHz - 60MHz)\\n\",\n\t\t\tmclk_rate);\n\t\tret = -EINVAL;\n\t\tgoto err_regulator;\n\t}\n\tif (mclk_rate >= 40000000)\n\t\tmax9860->psclk = 3;\n\telse if (mclk_rate >= 20000000)\n\t\tmax9860->psclk = 2;\n\telse\n\t\tmax9860->psclk = 1;\n\tmax9860->pclk_rate = mclk_rate >> (max9860->psclk - 1);\n\tmax9860->psclk <<= MAX9860_PSCLK_SHIFT;\n\tdev_dbg(dev, \"mclk %lu pclk %lu\\n\", mclk_rate, max9860->pclk_rate);\n\n\tregcache_cache_bypass(max9860->regmap, true);\n\tfor (i = 0; i < max9860_regmap.num_reg_defaults; ++i) {\n\t\tret = regmap_write(max9860->regmap,\n\t\t\t\t   max9860_regmap.reg_defaults[i].reg,\n\t\t\t\t   max9860_regmap.reg_defaults[i].def);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to initialize register %u: %d\\n\",\n\t\t\t\tmax9860_regmap.reg_defaults[i].reg, ret);\n\t\t\tgoto err_regulator;\n\t\t}\n\t}\n\tregcache_cache_bypass(max9860->regmap, false);\n\n\tret = regmap_read(max9860->regmap, MAX9860_INTRSTATUS, &intr);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to clear INTRSTATUS: %d\\n\", ret);\n\t\tgoto err_regulator;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_idle(dev);\n\n\tret = devm_snd_soc_register_component(dev, &max9860_component_driver,\n\t\t\t\t\t      &max9860_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\tgoto err_pm;\n\t}\n\n\treturn 0;\n\nerr_pm:\n\tpm_runtime_disable(dev);\nerr_regulator:\n\tregulator_disable(max9860->dvddio);\n\treturn ret;\n}\n\nstatic void max9860_remove(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct max9860_priv *max9860 = dev_get_drvdata(dev);\n\n\tpm_runtime_disable(dev);\n\tregulator_disable(max9860->dvddio);\n}\n\nstatic const struct i2c_device_id max9860_i2c_id[] = {\n\t{ \"max9860\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max9860_i2c_id);\n\nstatic const struct of_device_id max9860_of_match[] = {\n\t{ .compatible = \"maxim,max9860\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max9860_of_match);\n\nstatic struct i2c_driver max9860_i2c_driver = {\n\t.probe          = max9860_probe,\n\t.remove         = max9860_remove,\n\t.id_table       = max9860_i2c_id,\n\t.driver         = {\n\t\t.name           = \"max9860\",\n\t\t.of_match_table = max9860_of_match,\n\t\t.pm             = &max9860_pm_ops,\n\t},\n};\n\nmodule_i2c_driver(max9860_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC MAX9860 Mono Audio Voice Codec driver\");\nMODULE_AUTHOR(\"Peter Rosin <peda@axentia.se>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}