{
  "module_name": "wm9090.c",
  "hash_id": "c61620ea959108a968c51fad1ecb85d4044a5795cd7288a901d89c175fba0b53",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm9090.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/device.h>\n#include <linux/i2c.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/wm9090.h>\n\n#include \"wm9090.h\"\n\nstatic const struct reg_default wm9090_reg_defaults[] = {\n\t{ 1,  0x0006 },      \n\t{ 2,  0x6000 },      \n\t{ 3,  0x0000 },      \n\t{ 6,  0x01C0 },      \n\t{ 22, 0x0003 },      \n\t{ 23, 0x0003 },      \n\t{ 24, 0x0083 },      \n\t{ 25, 0x0083 },      \n\t{ 26, 0x0083 },      \n\t{ 27, 0x0083 },      \n\t{ 28, 0x002D },      \n\t{ 29, 0x002D },      \n\t{ 34, 0x0100 },      \n\t{ 35, 0x0010 },      \n\t{ 37, 0x0140 },      \n\t{ 38, 0x0039 },      \n\t{ 45, 0x0000 },      \n\t{ 46, 0x0000 },      \n\t{ 47, 0x0100 },      \n\t{ 48, 0x0100 },      \n\t{ 54, 0x0000 },      \n\t{ 57, 0x000D },      \n\t{ 70, 0x0000 },      \n\t{ 71, 0x0000 },      \n\t{ 72, 0x0000 },      \n\t{ 73, 0x0000 },      \n\t{ 74, 0x0000 },      \n\t{ 75, 0x0000 },      \n\t{ 76, 0x1F25 },      \n\t{ 85, 0x054A },      \n\t{ 87, 0x0000 },      \n\t{ 96, 0x0100 },      \n\t{ 98, 0x8640 },      \n\t{ 99, 0xC000 },      \n\t{ 100, 0x0200 },      \n};\n\n \nstruct wm9090_priv {\n\tstruct wm9090_platform_data pdata;\n\tstruct regmap *regmap;\n};\n\nstatic bool wm9090_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM9090_SOFTWARE_RESET:\n\tcase WM9090_DC_SERVO_0:\n\tcase WM9090_DC_SERVO_READBACK_0:\n\tcase WM9090_DC_SERVO_READBACK_1:\n\tcase WM9090_DC_SERVO_READBACK_2:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm9090_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM9090_SOFTWARE_RESET:\n\tcase WM9090_POWER_MANAGEMENT_1:\n\tcase WM9090_POWER_MANAGEMENT_2:\n\tcase WM9090_POWER_MANAGEMENT_3:\n\tcase WM9090_CLOCKING_1:\n\tcase WM9090_IN1_LINE_CONTROL:\n\tcase WM9090_IN2_LINE_CONTROL:\n\tcase WM9090_IN1_LINE_INPUT_A_VOLUME:\n\tcase WM9090_IN1_LINE_INPUT_B_VOLUME:\n\tcase WM9090_IN2_LINE_INPUT_A_VOLUME:\n\tcase WM9090_IN2_LINE_INPUT_B_VOLUME:\n\tcase WM9090_LEFT_OUTPUT_VOLUME:\n\tcase WM9090_RIGHT_OUTPUT_VOLUME:\n\tcase WM9090_SPKMIXL_ATTENUATION:\n\tcase WM9090_SPKOUT_MIXERS:\n\tcase WM9090_CLASSD3:\n\tcase WM9090_SPEAKER_VOLUME_LEFT:\n\tcase WM9090_OUTPUT_MIXER1:\n\tcase WM9090_OUTPUT_MIXER2:\n\tcase WM9090_OUTPUT_MIXER3:\n\tcase WM9090_OUTPUT_MIXER4:\n\tcase WM9090_SPEAKER_MIXER:\n\tcase WM9090_ANTIPOP2:\n\tcase WM9090_WRITE_SEQUENCER_0:\n\tcase WM9090_WRITE_SEQUENCER_1:\n\tcase WM9090_WRITE_SEQUENCER_2:\n\tcase WM9090_WRITE_SEQUENCER_3:\n\tcase WM9090_WRITE_SEQUENCER_4:\n\tcase WM9090_WRITE_SEQUENCER_5:\n\tcase WM9090_CHARGE_PUMP_1:\n\tcase WM9090_DC_SERVO_0:\n\tcase WM9090_DC_SERVO_1:\n\tcase WM9090_DC_SERVO_3:\n\tcase WM9090_DC_SERVO_READBACK_0:\n\tcase WM9090_DC_SERVO_READBACK_1:\n\tcase WM9090_DC_SERVO_READBACK_2:\n\tcase WM9090_ANALOGUE_HP_0:\n\tcase WM9090_AGC_CONTROL_0:\n\tcase WM9090_AGC_CONTROL_1:\n\tcase WM9090_AGC_CONTROL_2:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void wait_for_dc_servo(struct snd_soc_component *component)\n{\n\tunsigned int reg;\n\tint count = 0;\n\n\tdev_dbg(component->dev, \"Waiting for DC servo...\\n\");\n\tdo {\n\t\tcount++;\n\t\tmsleep(1);\n\t\treg = snd_soc_component_read(component, WM9090_DC_SERVO_READBACK_0);\n\t\tdev_dbg(component->dev, \"DC servo status: %x\\n\", reg);\n\t} while ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\n\t\t != WM9090_DCS_CAL_COMPLETE_MASK && count < 1000);\n\n\tif ((reg & WM9090_DCS_CAL_COMPLETE_MASK)\n\t    != WM9090_DCS_CAL_COMPLETE_MASK)\n\t\tdev_err(component->dev, \"Timed out waiting for DC Servo\\n\");\n}\n\nstatic const DECLARE_TLV_DB_RANGE(in_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(-600, 0, 0),\n\t1, 3, TLV_DB_SCALE_ITEM(-350, 350, 0),\n\t4, 6, TLV_DB_SCALE_ITEM(600, 600, 0)\n);\nstatic const DECLARE_TLV_DB_RANGE(mix_tlv,\n\t0, 2, TLV_DB_SCALE_ITEM(-1200, 300, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(0, 0, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_RANGE(spkboost_tlv,\n\t0, 6, TLV_DB_SCALE_ITEM(0, 150, 0),\n\t7, 7, TLV_DB_SCALE_ITEM(1200, 0, 0)\n);\n\nstatic const struct snd_kcontrol_new wm9090_controls[] = {\nSOC_SINGLE_TLV(\"IN1A Volume\", WM9090_IN1_LINE_INPUT_A_VOLUME, 0, 6, 0,\n\t       in_tlv),\nSOC_SINGLE(\"IN1A Switch\", WM9090_IN1_LINE_INPUT_A_VOLUME, 7, 1, 1),\nSOC_SINGLE(\"IN1A ZC Switch\", WM9090_IN1_LINE_INPUT_A_VOLUME, 6, 1, 0),\n\nSOC_SINGLE_TLV(\"IN2A Volume\", WM9090_IN2_LINE_INPUT_A_VOLUME, 0, 6, 0,\n\t       in_tlv),\nSOC_SINGLE(\"IN2A Switch\", WM9090_IN2_LINE_INPUT_A_VOLUME, 7, 1, 1),\nSOC_SINGLE(\"IN2A ZC Switch\", WM9090_IN2_LINE_INPUT_A_VOLUME, 6, 1, 0),\n\nSOC_SINGLE(\"MIXOUTL Switch\", WM9090_OUTPUT_MIXER3, 8, 1, 1),\nSOC_SINGLE_TLV(\"MIXOUTL IN1A Volume\", WM9090_OUTPUT_MIXER3, 6, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTL IN2A Volume\", WM9090_OUTPUT_MIXER3, 2, 3, 1,\n\t       mix_tlv),\n\nSOC_SINGLE(\"MIXOUTR Switch\", WM9090_OUTPUT_MIXER4, 8, 1, 1),\nSOC_SINGLE_TLV(\"MIXOUTR IN1A Volume\", WM9090_OUTPUT_MIXER4, 6, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTR IN2A Volume\", WM9090_OUTPUT_MIXER4, 2, 3, 1,\n\t       mix_tlv),\n\nSOC_SINGLE(\"SPKMIX Switch\", WM9090_SPKMIXL_ATTENUATION, 8, 1, 1),\nSOC_SINGLE_TLV(\"SPKMIX IN1A Volume\", WM9090_SPKMIXL_ATTENUATION, 6, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"SPKMIX IN2A Volume\", WM9090_SPKMIXL_ATTENUATION, 2, 3, 1,\n\t       mix_tlv),\n\nSOC_DOUBLE_R_TLV(\"Headphone Volume\", WM9090_LEFT_OUTPUT_VOLUME,\n\t\t WM9090_RIGHT_OUTPUT_VOLUME, 0, 63, 0, out_tlv),\nSOC_DOUBLE_R(\"Headphone Switch\", WM9090_LEFT_OUTPUT_VOLUME,\n\t     WM9090_RIGHT_OUTPUT_VOLUME, 6, 1, 1),\nSOC_DOUBLE_R(\"Headphone ZC Switch\", WM9090_LEFT_OUTPUT_VOLUME,\n\t     WM9090_RIGHT_OUTPUT_VOLUME, 7, 1, 0),\n\nSOC_SINGLE_TLV(\"Speaker Volume\", WM9090_SPEAKER_VOLUME_LEFT, 0, 63, 0,\n\t       out_tlv),\nSOC_SINGLE(\"Speaker Switch\", WM9090_SPEAKER_VOLUME_LEFT, 6, 1, 1),\nSOC_SINGLE(\"Speaker ZC Switch\", WM9090_SPEAKER_VOLUME_LEFT, 7, 1, 0),\nSOC_SINGLE_TLV(\"Speaker Boost Volume\", WM9090_CLASSD3, 3, 7, 0, spkboost_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm9090_in1_se_controls[] = {\nSOC_SINGLE_TLV(\"IN1B Volume\", WM9090_IN1_LINE_INPUT_B_VOLUME, 0, 6, 0,\n\t       in_tlv),\nSOC_SINGLE(\"IN1B Switch\", WM9090_IN1_LINE_INPUT_B_VOLUME, 7, 1, 1),\nSOC_SINGLE(\"IN1B ZC Switch\", WM9090_IN1_LINE_INPUT_B_VOLUME, 6, 1, 0),\n\nSOC_SINGLE_TLV(\"SPKMIX IN1B Volume\", WM9090_SPKMIXL_ATTENUATION, 4, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTL IN1B Volume\", WM9090_OUTPUT_MIXER3, 4, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTR IN1B Volume\", WM9090_OUTPUT_MIXER4, 4, 3, 1,\n\t       mix_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm9090_in2_se_controls[] = {\nSOC_SINGLE_TLV(\"IN2B Volume\", WM9090_IN2_LINE_INPUT_B_VOLUME, 0, 6, 0,\n\t       in_tlv),\nSOC_SINGLE(\"IN2B Switch\", WM9090_IN2_LINE_INPUT_B_VOLUME, 7, 1, 1),\nSOC_SINGLE(\"IN2B ZC Switch\", WM9090_IN2_LINE_INPUT_B_VOLUME, 6, 1, 0),\n\nSOC_SINGLE_TLV(\"SPKMIX IN2B Volume\", WM9090_SPKMIXL_ATTENUATION, 0, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTL IN2B Volume\", WM9090_OUTPUT_MIXER3, 0, 3, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"MIXOUTR IN2B Volume\", WM9090_OUTPUT_MIXER4, 0, 3, 1,\n\t       mix_tlv),\n};\n\nstatic int hp_ev(struct snd_soc_dapm_widget *w,\n\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tunsigned int reg = snd_soc_component_read(component, WM9090_ANALOGUE_HP_0);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, WM9090_CHARGE_PUMP_1,\n\t\t\t\t    WM9090_CP_ENA, WM9090_CP_ENA);\n\n\t\tmsleep(5);\n\n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_1,\n\t\t\t\t    WM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\n\t\t\t\t    WM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA);\n\n\t\treg |= WM9090_HPOUT1L_DLY | WM9090_HPOUT1R_DLY;\n\t\tsnd_soc_component_write(component, WM9090_ANALOGUE_HP_0, reg);\n\n\t\t \n\t\tsnd_soc_component_write(component, WM9090_DC_SERVO_0,\n\t\t\t      WM9090_DCS_ENA_CHAN_0 |\n\t\t\t      WM9090_DCS_ENA_CHAN_1 |\n\t\t\t      WM9090_DCS_TRIG_STARTUP_1 |\n\t\t\t      WM9090_DCS_TRIG_STARTUP_0);\n\t\twait_for_dc_servo(component);\n\n\t\treg |= WM9090_HPOUT1R_OUTP | WM9090_HPOUT1R_RMV_SHORT |\n\t\t\tWM9090_HPOUT1L_OUTP | WM9090_HPOUT1L_RMV_SHORT;\n\t\tsnd_soc_component_write(component, WM9090_ANALOGUE_HP_0, reg);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\treg &= ~(WM9090_HPOUT1L_RMV_SHORT |\n\t\t\t WM9090_HPOUT1L_DLY |\n\t\t\t WM9090_HPOUT1L_OUTP |\n\t\t\t WM9090_HPOUT1R_RMV_SHORT |\n\t\t\t WM9090_HPOUT1R_DLY |\n\t\t\t WM9090_HPOUT1R_OUTP);\n\n\t\tsnd_soc_component_write(component, WM9090_ANALOGUE_HP_0, reg);\n\n\t\tsnd_soc_component_write(component, WM9090_DC_SERVO_0, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_1,\n\t\t\t\t    WM9090_HPOUT1L_ENA | WM9090_HPOUT1R_ENA,\n\t\t\t\t    0);\n\n\t\tsnd_soc_component_update_bits(component, WM9090_CHARGE_PUMP_1,\n\t\t\t\t    WM9090_CP_ENA, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new spkmix[] = {\nSOC_DAPM_SINGLE(\"IN1A Switch\", WM9090_SPEAKER_MIXER, 6, 1, 0),\nSOC_DAPM_SINGLE(\"IN1B Switch\", WM9090_SPEAKER_MIXER, 4, 1, 0),\nSOC_DAPM_SINGLE(\"IN2A Switch\", WM9090_SPEAKER_MIXER, 2, 1, 0),\nSOC_DAPM_SINGLE(\"IN2B Switch\", WM9090_SPEAKER_MIXER, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new spkout[] = {\nSOC_DAPM_SINGLE(\"Mixer Switch\", WM9090_SPKOUT_MIXERS, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mixoutl[] = {\nSOC_DAPM_SINGLE(\"IN1A Switch\", WM9090_OUTPUT_MIXER1, 6, 1, 0),\nSOC_DAPM_SINGLE(\"IN1B Switch\", WM9090_OUTPUT_MIXER1, 4, 1, 0),\nSOC_DAPM_SINGLE(\"IN2A Switch\", WM9090_OUTPUT_MIXER1, 2, 1, 0),\nSOC_DAPM_SINGLE(\"IN2B Switch\", WM9090_OUTPUT_MIXER1, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new mixoutr[] = {\nSOC_DAPM_SINGLE(\"IN1A Switch\", WM9090_OUTPUT_MIXER2, 6, 1, 0),\nSOC_DAPM_SINGLE(\"IN1B Switch\", WM9090_OUTPUT_MIXER2, 4, 1, 0),\nSOC_DAPM_SINGLE(\"IN2A Switch\", WM9090_OUTPUT_MIXER2, 2, 1, 0),\nSOC_DAPM_SINGLE(\"IN2B Switch\", WM9090_OUTPUT_MIXER2, 0, 1, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm9090_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"IN1+\"),\nSND_SOC_DAPM_INPUT(\"IN1-\"),\nSND_SOC_DAPM_INPUT(\"IN2+\"),\nSND_SOC_DAPM_INPUT(\"IN2-\"),\n\nSND_SOC_DAPM_SUPPLY(\"OSC\", WM9090_POWER_MANAGEMENT_1, 3, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"IN1A PGA\", WM9090_POWER_MANAGEMENT_2, 7, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"IN1B PGA\", WM9090_POWER_MANAGEMENT_2, 6, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"IN2A PGA\", WM9090_POWER_MANAGEMENT_2, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"IN2B PGA\", WM9090_POWER_MANAGEMENT_2, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_MIXER(\"SPKMIX\", WM9090_POWER_MANAGEMENT_3, 3, 0,\n\t\t   spkmix, ARRAY_SIZE(spkmix)),\nSND_SOC_DAPM_MIXER(\"MIXOUTL\", WM9090_POWER_MANAGEMENT_3, 5, 0,\n\t\t   mixoutl, ARRAY_SIZE(mixoutl)),\nSND_SOC_DAPM_MIXER(\"MIXOUTR\", WM9090_POWER_MANAGEMENT_3, 4, 0,\n\t\t   mixoutr, ARRAY_SIZE(mixoutr)),\n\nSND_SOC_DAPM_PGA_E(\"HP PGA\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t   hp_ev, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\nSND_SOC_DAPM_PGA(\"SPKPGA\", WM9090_POWER_MANAGEMENT_3, 8, 0, NULL, 0),\nSND_SOC_DAPM_MIXER(\"SPKOUT\", WM9090_POWER_MANAGEMENT_1, 12, 0,\n\t\t   spkout, ARRAY_SIZE(spkout)),\n\nSND_SOC_DAPM_OUTPUT(\"HPR\"),\nSND_SOC_DAPM_OUTPUT(\"HPL\"),\nSND_SOC_DAPM_OUTPUT(\"Speaker\"),\n};\n\nstatic const struct snd_soc_dapm_route audio_map[] = {\n\t{ \"IN1A PGA\", NULL, \"IN1+\" },\n\t{ \"IN2A PGA\", NULL, \"IN2+\" },\n\n\t{ \"SPKMIX\", \"IN1A Switch\", \"IN1A PGA\" },\n\t{ \"SPKMIX\", \"IN2A Switch\", \"IN2A PGA\" },\n\n\t{ \"MIXOUTL\", \"IN1A Switch\", \"IN1A PGA\" },\n\t{ \"MIXOUTL\", \"IN2A Switch\", \"IN2A PGA\" },\n\n\t{ \"MIXOUTR\", \"IN1A Switch\", \"IN1A PGA\" },\n\t{ \"MIXOUTR\", \"IN2A Switch\", \"IN2A PGA\" },\n\n\t{ \"HP PGA\", NULL, \"OSC\" },\n\t{ \"HP PGA\", NULL, \"MIXOUTL\" },\n\t{ \"HP PGA\", NULL, \"MIXOUTR\" },\n\n\t{ \"HPL\", NULL, \"HP PGA\" },\n\t{ \"HPR\", NULL, \"HP PGA\" },\n\n\t{ \"SPKPGA\", NULL, \"OSC\" },\n\t{ \"SPKPGA\", NULL, \"SPKMIX\" },\n\n\t{ \"SPKOUT\", \"Mixer Switch\", \"SPKPGA\" },\n\n\t{ \"Speaker\", NULL, \"SPKOUT\" },\n};\n\nstatic const struct snd_soc_dapm_route audio_map_in1_se[] = {\n\t{ \"IN1B PGA\", NULL, \"IN1-\" },\t\n\n\t{ \"SPKMIX\", \"IN1B Switch\", \"IN1B PGA\" },\n\t{ \"MIXOUTL\", \"IN1B Switch\", \"IN1B PGA\" },\n\t{ \"MIXOUTR\", \"IN1B Switch\", \"IN1B PGA\" },\n};\n\nstatic const struct snd_soc_dapm_route audio_map_in1_diff[] = {\n\t{ \"IN1A PGA\", NULL, \"IN1-\" },\t\n};\n\nstatic const struct snd_soc_dapm_route audio_map_in2_se[] = {\n\t{ \"IN2B PGA\", NULL, \"IN2-\" },\t\n\n\t{ \"SPKMIX\", \"IN2B Switch\", \"IN2B PGA\" },\n\t{ \"MIXOUTL\", \"IN2B Switch\", \"IN2B PGA\" },\n\t{ \"MIXOUTR\", \"IN2B Switch\", \"IN2B PGA\" },\n};\n\nstatic const struct snd_soc_dapm_route audio_map_in2_diff[] = {\n\t{ \"IN2A PGA\", NULL, \"IN2-\" },\t\n};\n\nstatic int wm9090_add_controls(struct snd_soc_component *component)\n{\n\tstruct wm9090_priv *wm9090 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint i;\n\n\tsnd_soc_dapm_new_controls(dapm, wm9090_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(wm9090_dapm_widgets));\n\n\tsnd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));\n\n\tsnd_soc_add_component_controls(component, wm9090_controls,\n\t\t\t     ARRAY_SIZE(wm9090_controls));\n\n\tif (wm9090->pdata.lin1_diff) {\n\t\tsnd_soc_dapm_add_routes(dapm, audio_map_in1_diff,\n\t\t\t\t\tARRAY_SIZE(audio_map_in1_diff));\n\t} else {\n\t\tsnd_soc_dapm_add_routes(dapm, audio_map_in1_se,\n\t\t\t\t\tARRAY_SIZE(audio_map_in1_se));\n\t\tsnd_soc_add_component_controls(component, wm9090_in1_se_controls,\n\t\t\t\t     ARRAY_SIZE(wm9090_in1_se_controls));\n\t}\n\n\tif (wm9090->pdata.lin2_diff) {\n\t\tsnd_soc_dapm_add_routes(dapm, audio_map_in2_diff,\n\t\t\t\t\tARRAY_SIZE(audio_map_in2_diff));\n\t} else {\n\t\tsnd_soc_dapm_add_routes(dapm, audio_map_in2_se,\n\t\t\t\t\tARRAY_SIZE(audio_map_in2_se));\n\t\tsnd_soc_add_component_controls(component, wm9090_in2_se_controls,\n\t\t\t\t     ARRAY_SIZE(wm9090_in2_se_controls));\n\t}\n\n\tif (wm9090->pdata.agc_ena) {\n\t\tfor (i = 0; i < ARRAY_SIZE(wm9090->pdata.agc); i++)\n\t\t\tsnd_soc_component_write(component, WM9090_AGC_CONTROL_0 + i,\n\t\t\t\t      wm9090->pdata.agc[i]);\n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_3,\n\t\t\t\t    WM9090_AGC_ENA, WM9090_AGC_ENA);\n\t} else {\n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_3,\n\t\t\t\t    WM9090_AGC_ENA, 0);\n\t}\n\n\treturn 0;\n\n}\n\n \nstatic int wm9090_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm9090_priv *wm9090 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, WM9090_ANTIPOP2, WM9090_VMID_ENA,\n\t\t\t\t    WM9090_VMID_ENA);\n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_1,\n\t\t\t\t    WM9090_BIAS_ENA |\n\t\t\t\t    WM9090_VMID_RES_MASK,\n\t\t\t\t    WM9090_BIAS_ENA |\n\t\t\t\t    1 << WM9090_VMID_RES_SHIFT);\n\t\tmsleep(1);   \n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tregcache_sync(wm9090->regmap);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM9090_POWER_MANAGEMENT_1,\n\t\t\t\t    WM9090_BIAS_ENA | WM9090_VMID_RES_MASK, 0);\n\t\tsnd_soc_component_update_bits(component, WM9090_ANTIPOP2,\n\t\t\t\t    WM9090_VMID_ENA, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm9090_probe(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_update_bits(component, WM9090_IN1_LINE_INPUT_A_VOLUME,\n\t\t\t    WM9090_IN1_VU | WM9090_IN1A_ZC,\n\t\t\t    WM9090_IN1_VU | WM9090_IN1A_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_IN1_LINE_INPUT_B_VOLUME,\n\t\t\t    WM9090_IN1_VU | WM9090_IN1B_ZC,\n\t\t\t    WM9090_IN1_VU | WM9090_IN1B_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_IN2_LINE_INPUT_A_VOLUME,\n\t\t\t    WM9090_IN2_VU | WM9090_IN2A_ZC,\n\t\t\t    WM9090_IN2_VU | WM9090_IN2A_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_IN2_LINE_INPUT_B_VOLUME,\n\t\t\t    WM9090_IN2_VU | WM9090_IN2B_ZC,\n\t\t\t    WM9090_IN2_VU | WM9090_IN2B_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_SPEAKER_VOLUME_LEFT,\n\t\t\t    WM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC,\n\t\t\t    WM9090_SPKOUT_VU | WM9090_SPKOUTL_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_LEFT_OUTPUT_VOLUME,\n\t\t\t    WM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC,\n\t\t\t    WM9090_HPOUT1_VU | WM9090_HPOUT1L_ZC);\n\tsnd_soc_component_update_bits(component, WM9090_RIGHT_OUTPUT_VOLUME,\n\t\t\t    WM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC,\n\t\t\t    WM9090_HPOUT1_VU | WM9090_HPOUT1R_ZC);\n\n\tsnd_soc_component_update_bits(component, WM9090_CLOCKING_1,\n\t\t\t    WM9090_TOCLK_ENA, WM9090_TOCLK_ENA);\n\n\twm9090_add_controls(component);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm9090 = {\n\t.probe\t\t\t= wm9090_probe,\n\t.set_bias_level\t\t= wm9090_set_bias_level,\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n};\n\nstatic const struct regmap_config wm9090_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM9090_MAX_REGISTER,\n\t.volatile_reg = wm9090_volatile,\n\t.readable_reg = wm9090_readable,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm9090_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm9090_reg_defaults),\n};\n\n\nstatic int wm9090_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm9090_priv *wm9090;\n\tunsigned int reg;\n\tint ret;\n\n\twm9090 = devm_kzalloc(&i2c->dev, sizeof(*wm9090), GFP_KERNEL);\n\tif (!wm9090)\n\t\treturn -ENOMEM;\n\n\twm9090->regmap = devm_regmap_init_i2c(i2c, &wm9090_regmap);\n\tif (IS_ERR(wm9090->regmap)) {\n\t\tret = PTR_ERR(wm9090->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm9090->regmap, WM9090_SOFTWARE_RESET, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (reg != 0x9093) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM9090, ID=%x\\n\", reg);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_write(wm9090->regmap, WM9090_SOFTWARE_RESET, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (i2c->dev.platform_data)\n\t\tmemcpy(&wm9090->pdata, i2c->dev.platform_data,\n\t\t       sizeof(wm9090->pdata));\n\n\ti2c_set_clientdata(i2c, wm9090);\n\n\tret =  devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm9090,  NULL, 0);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id wm9090_id[] = {\n\t{ \"wm9090\", 0 },\n\t{ \"wm9093\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm9090_id);\n\nstatic struct i2c_driver wm9090_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm9090\",\n\t},\n\t.probe = wm9090_i2c_probe,\n\t.id_table = wm9090_id,\n};\n\nmodule_i2c_driver(wm9090_i2c_driver);\n\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_DESCRIPTION(\"WM9090 ASoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}