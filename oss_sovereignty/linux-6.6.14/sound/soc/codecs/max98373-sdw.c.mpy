{
  "module_name": "max98373-sdw.c",
  "hash_id": "98a25a53ec40a5dca6e64c07cec4ed9d51df75c5c8317b10c2b70f91f5703455",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98373-sdw.c",
  "human_readable_source": "\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <linux/of.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/soundwire/sdw_registers.h>\n#include \"max98373.h\"\n#include \"max98373-sdw.h\"\n\nstatic const u32 max98373_sdw_cache_reg[] = {\n\tMAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK,\n\tMAX98373_R2055_MEAS_ADC_THERM_CH_READBACK,\n\tMAX98373_R20B6_BDE_CUR_STATE_READBACK,\n};\n\nstatic struct reg_default max98373_reg[] = {\n\t{MAX98373_R0040_SCP_INIT_STAT_1, 0x00},\n\t{MAX98373_R0041_SCP_INIT_MASK_1, 0x00},\n\t{MAX98373_R0042_SCP_INIT_STAT_2, 0x00},\n\t{MAX98373_R0044_SCP_CTRL, 0x00},\n\t{MAX98373_R0045_SCP_SYSTEM_CTRL, 0x00},\n\t{MAX98373_R0046_SCP_DEV_NUMBER, 0x00},\n\t{MAX98373_R0050_SCP_DEV_ID_0, 0x21},\n\t{MAX98373_R0051_SCP_DEV_ID_1, 0x01},\n\t{MAX98373_R0052_SCP_DEV_ID_2, 0x9F},\n\t{MAX98373_R0053_SCP_DEV_ID_3, 0x87},\n\t{MAX98373_R0054_SCP_DEV_ID_4, 0x08},\n\t{MAX98373_R0055_SCP_DEV_ID_5, 0x00},\n\t{MAX98373_R0060_SCP_FRAME_CTLR, 0x00},\n\t{MAX98373_R0070_SCP_FRAME_CTLR, 0x00},\n\t{MAX98373_R0100_DP1_INIT_STAT, 0x00},\n\t{MAX98373_R0101_DP1_INIT_MASK, 0x00},\n\t{MAX98373_R0102_DP1_PORT_CTRL, 0x00},\n\t{MAX98373_R0103_DP1_BLOCK_CTRL_1, 0x00},\n\t{MAX98373_R0104_DP1_PREPARE_STATUS, 0x00},\n\t{MAX98373_R0105_DP1_PREPARE_CTRL, 0x00},\n\t{MAX98373_R0120_DP1_CHANNEL_EN, 0x00},\n\t{MAX98373_R0122_DP1_SAMPLE_CTRL1, 0x00},\n\t{MAX98373_R0123_DP1_SAMPLE_CTRL2, 0x00},\n\t{MAX98373_R0124_DP1_OFFSET_CTRL1, 0x00},\n\t{MAX98373_R0125_DP1_OFFSET_CTRL2, 0x00},\n\t{MAX98373_R0126_DP1_HCTRL, 0x00},\n\t{MAX98373_R0127_DP1_BLOCK_CTRL3, 0x00},\n\t{MAX98373_R0130_DP1_CHANNEL_EN, 0x00},\n\t{MAX98373_R0132_DP1_SAMPLE_CTRL1, 0x00},\n\t{MAX98373_R0133_DP1_SAMPLE_CTRL2, 0x00},\n\t{MAX98373_R0134_DP1_OFFSET_CTRL1, 0x00},\n\t{MAX98373_R0135_DP1_OFFSET_CTRL2, 0x00},\n\t{MAX98373_R0136_DP1_HCTRL, 0x0136},\n\t{MAX98373_R0137_DP1_BLOCK_CTRL3, 0x00},\n\t{MAX98373_R0300_DP3_INIT_STAT, 0x00},\n\t{MAX98373_R0301_DP3_INIT_MASK, 0x00},\n\t{MAX98373_R0302_DP3_PORT_CTRL, 0x00},\n\t{MAX98373_R0303_DP3_BLOCK_CTRL_1, 0x00},\n\t{MAX98373_R0304_DP3_PREPARE_STATUS, 0x00},\n\t{MAX98373_R0305_DP3_PREPARE_CTRL, 0x00},\n\t{MAX98373_R0320_DP3_CHANNEL_EN, 0x00},\n\t{MAX98373_R0322_DP3_SAMPLE_CTRL1, 0x00},\n\t{MAX98373_R0323_DP3_SAMPLE_CTRL2, 0x00},\n\t{MAX98373_R0324_DP3_OFFSET_CTRL1, 0x00},\n\t{MAX98373_R0325_DP3_OFFSET_CTRL2, 0x00},\n\t{MAX98373_R0326_DP3_HCTRL, 0x00},\n\t{MAX98373_R0327_DP3_BLOCK_CTRL3, 0x00},\n\t{MAX98373_R0330_DP3_CHANNEL_EN, 0x00},\n\t{MAX98373_R0332_DP3_SAMPLE_CTRL1, 0x00},\n\t{MAX98373_R0333_DP3_SAMPLE_CTRL2, 0x00},\n\t{MAX98373_R0334_DP3_OFFSET_CTRL1, 0x00},\n\t{MAX98373_R0335_DP3_OFFSET_CTRL2, 0x00},\n\t{MAX98373_R0336_DP3_HCTRL, 0x00},\n\t{MAX98373_R0337_DP3_BLOCK_CTRL3, 0x00},\n\t{MAX98373_R2000_SW_RESET, 0x00},\n\t{MAX98373_R2001_INT_RAW1, 0x00},\n\t{MAX98373_R2002_INT_RAW2, 0x00},\n\t{MAX98373_R2003_INT_RAW3, 0x00},\n\t{MAX98373_R2004_INT_STATE1, 0x00},\n\t{MAX98373_R2005_INT_STATE2, 0x00},\n\t{MAX98373_R2006_INT_STATE3, 0x00},\n\t{MAX98373_R2007_INT_FLAG1, 0x00},\n\t{MAX98373_R2008_INT_FLAG2, 0x00},\n\t{MAX98373_R2009_INT_FLAG3, 0x00},\n\t{MAX98373_R200A_INT_EN1, 0x00},\n\t{MAX98373_R200B_INT_EN2, 0x00},\n\t{MAX98373_R200C_INT_EN3, 0x00},\n\t{MAX98373_R200D_INT_FLAG_CLR1, 0x00},\n\t{MAX98373_R200E_INT_FLAG_CLR2, 0x00},\n\t{MAX98373_R200F_INT_FLAG_CLR3, 0x00},\n\t{MAX98373_R2010_IRQ_CTRL, 0x00},\n\t{MAX98373_R2014_THERM_WARN_THRESH, 0x10},\n\t{MAX98373_R2015_THERM_SHDN_THRESH, 0x27},\n\t{MAX98373_R2016_THERM_HYSTERESIS, 0x01},\n\t{MAX98373_R2017_THERM_FOLDBACK_SET, 0xC0},\n\t{MAX98373_R2018_THERM_FOLDBACK_EN, 0x00},\n\t{MAX98373_R201E_PIN_DRIVE_STRENGTH, 0x55},\n\t{MAX98373_R2020_PCM_TX_HIZ_EN_1, 0xFE},\n\t{MAX98373_R2021_PCM_TX_HIZ_EN_2, 0xFF},\n\t{MAX98373_R2022_PCM_TX_SRC_1, 0x00},\n\t{MAX98373_R2023_PCM_TX_SRC_2, 0x00},\n\t{MAX98373_R2024_PCM_DATA_FMT_CFG, 0xC0},\n\t{MAX98373_R2025_AUDIO_IF_MODE, 0x00},\n\t{MAX98373_R2026_PCM_CLOCK_RATIO, 0x04},\n\t{MAX98373_R2027_PCM_SR_SETUP_1, 0x08},\n\t{MAX98373_R2028_PCM_SR_SETUP_2, 0x88},\n\t{MAX98373_R2029_PCM_TO_SPK_MONO_MIX_1, 0x00},\n\t{MAX98373_R202A_PCM_TO_SPK_MONO_MIX_2, 0x00},\n\t{MAX98373_R202B_PCM_RX_EN, 0x00},\n\t{MAX98373_R202C_PCM_TX_EN, 0x00},\n\t{MAX98373_R202E_ICC_RX_CH_EN_1, 0x00},\n\t{MAX98373_R202F_ICC_RX_CH_EN_2, 0x00},\n\t{MAX98373_R2030_ICC_TX_HIZ_EN_1, 0xFF},\n\t{MAX98373_R2031_ICC_TX_HIZ_EN_2, 0xFF},\n\t{MAX98373_R2032_ICC_LINK_EN_CFG, 0x30},\n\t{MAX98373_R2034_ICC_TX_CNTL, 0x00},\n\t{MAX98373_R2035_ICC_TX_EN, 0x00},\n\t{MAX98373_R2036_SOUNDWIRE_CTRL, 0x05},\n\t{MAX98373_R203D_AMP_DIG_VOL_CTRL, 0x00},\n\t{MAX98373_R203E_AMP_PATH_GAIN, 0x08},\n\t{MAX98373_R203F_AMP_DSP_CFG, 0x02},\n\t{MAX98373_R2040_TONE_GEN_CFG, 0x00},\n\t{MAX98373_R2041_AMP_CFG, 0x03},\n\t{MAX98373_R2042_AMP_EDGE_RATE_CFG, 0x00},\n\t{MAX98373_R2043_AMP_EN, 0x00},\n\t{MAX98373_R2046_IV_SENSE_ADC_DSP_CFG, 0x04},\n\t{MAX98373_R2047_IV_SENSE_ADC_EN, 0x00},\n\t{MAX98373_R2051_MEAS_ADC_SAMPLING_RATE, 0x00},\n\t{MAX98373_R2052_MEAS_ADC_PVDD_FLT_CFG, 0x00},\n\t{MAX98373_R2053_MEAS_ADC_THERM_FLT_CFG, 0x00},\n\t{MAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK, 0x00},\n\t{MAX98373_R2055_MEAS_ADC_THERM_CH_READBACK, 0x00},\n\t{MAX98373_R2056_MEAS_ADC_PVDD_CH_EN, 0x00},\n\t{MAX98373_R2090_BDE_LVL_HOLD, 0x00},\n\t{MAX98373_R2091_BDE_GAIN_ATK_REL_RATE, 0x00},\n\t{MAX98373_R2092_BDE_CLIPPER_MODE, 0x00},\n\t{MAX98373_R2097_BDE_L1_THRESH, 0x00},\n\t{MAX98373_R2098_BDE_L2_THRESH, 0x00},\n\t{MAX98373_R2099_BDE_L3_THRESH, 0x00},\n\t{MAX98373_R209A_BDE_L4_THRESH, 0x00},\n\t{MAX98373_R209B_BDE_THRESH_HYST, 0x00},\n\t{MAX98373_R20A8_BDE_L1_CFG_1, 0x00},\n\t{MAX98373_R20A9_BDE_L1_CFG_2, 0x00},\n\t{MAX98373_R20AA_BDE_L1_CFG_3, 0x00},\n\t{MAX98373_R20AB_BDE_L2_CFG_1, 0x00},\n\t{MAX98373_R20AC_BDE_L2_CFG_2, 0x00},\n\t{MAX98373_R20AD_BDE_L2_CFG_3, 0x00},\n\t{MAX98373_R20AE_BDE_L3_CFG_1, 0x00},\n\t{MAX98373_R20AF_BDE_L3_CFG_2, 0x00},\n\t{MAX98373_R20B0_BDE_L3_CFG_3, 0x00},\n\t{MAX98373_R20B1_BDE_L4_CFG_1, 0x00},\n\t{MAX98373_R20B2_BDE_L4_CFG_2, 0x00},\n\t{MAX98373_R20B3_BDE_L4_CFG_3, 0x00},\n\t{MAX98373_R20B4_BDE_INFINITE_HOLD_RELEASE, 0x00},\n\t{MAX98373_R20B5_BDE_EN, 0x00},\n\t{MAX98373_R20B6_BDE_CUR_STATE_READBACK, 0x00},\n\t{MAX98373_R20D1_DHT_CFG, 0x01},\n\t{MAX98373_R20D2_DHT_ATTACK_CFG, 0x02},\n\t{MAX98373_R20D3_DHT_RELEASE_CFG, 0x03},\n\t{MAX98373_R20D4_DHT_EN, 0x00},\n\t{MAX98373_R20E0_LIMITER_THRESH_CFG, 0x00},\n\t{MAX98373_R20E1_LIMITER_ATK_REL_RATES, 0x00},\n\t{MAX98373_R20E2_LIMITER_EN, 0x00},\n\t{MAX98373_R20FE_DEVICE_AUTO_RESTART_CFG, 0x00},\n\t{MAX98373_R20FF_GLOBAL_SHDN, 0x00},\n\t{MAX98373_R21FF_REV_ID, 0x42},\n};\n\nstatic bool max98373_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98373_R21FF_REV_ID:\n\tcase MAX98373_R2010_IRQ_CTRL:\n\t \n\tcase MAX98373_R0040_SCP_INIT_STAT_1 ... MAX98373_R0070_SCP_FRAME_CTLR:\n\t \n\tcase MAX98373_R0100_DP1_INIT_STAT ... MAX98373_R0137_DP1_BLOCK_CTRL3:\n\t \n\tcase MAX98373_R0300_DP3_INIT_STAT ... MAX98373_R0337_DP3_BLOCK_CTRL3:\n\tcase MAX98373_R2000_SW_RESET ... MAX98373_R200C_INT_EN3:\n\tcase MAX98373_R2014_THERM_WARN_THRESH\n\t\t... MAX98373_R2018_THERM_FOLDBACK_EN:\n\tcase MAX98373_R201E_PIN_DRIVE_STRENGTH\n\t\t... MAX98373_R2036_SOUNDWIRE_CTRL:\n\tcase MAX98373_R203D_AMP_DIG_VOL_CTRL ... MAX98373_R2043_AMP_EN:\n\tcase MAX98373_R2046_IV_SENSE_ADC_DSP_CFG\n\t\t... MAX98373_R2047_IV_SENSE_ADC_EN:\n\tcase MAX98373_R2051_MEAS_ADC_SAMPLING_RATE\n\t\t... MAX98373_R2056_MEAS_ADC_PVDD_CH_EN:\n\tcase MAX98373_R2090_BDE_LVL_HOLD ... MAX98373_R2092_BDE_CLIPPER_MODE:\n\tcase MAX98373_R2097_BDE_L1_THRESH\n\t\t... MAX98373_R209B_BDE_THRESH_HYST:\n\tcase MAX98373_R20A8_BDE_L1_CFG_1 ... MAX98373_R20B3_BDE_L4_CFG_3:\n\tcase MAX98373_R20B5_BDE_EN ... MAX98373_R20B6_BDE_CUR_STATE_READBACK:\n\tcase MAX98373_R20D1_DHT_CFG ... MAX98373_R20D4_DHT_EN:\n\tcase MAX98373_R20E0_LIMITER_THRESH_CFG ... MAX98373_R20E2_LIMITER_EN:\n\tcase MAX98373_R20FE_DEVICE_AUTO_RESTART_CFG\n\t\t... MAX98373_R20FF_GLOBAL_SHDN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98373_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98373_R2054_MEAS_ADC_PVDD_CH_READBACK:\n\tcase MAX98373_R2055_MEAS_ADC_THERM_CH_READBACK:\n\tcase MAX98373_R20B6_BDE_CUR_STATE_READBACK:\n\tcase MAX98373_R20FF_GLOBAL_SHDN:\n\tcase MAX98373_R21FF_REV_ID:\n\t \n\tcase MAX98373_R0040_SCP_INIT_STAT_1 ... MAX98373_R0070_SCP_FRAME_CTLR:\n\t \n\tcase MAX98373_R0100_DP1_INIT_STAT ... MAX98373_R0137_DP1_BLOCK_CTRL3:\n\t \n\tcase MAX98373_R0300_DP3_INIT_STAT ... MAX98373_R0337_DP3_BLOCK_CTRL3:\n\tcase MAX98373_R2000_SW_RESET ... MAX98373_R2009_INT_FLAG3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max98373_sdw_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.max_register = MAX98373_R21FF_REV_ID,\n\t.reg_defaults  = max98373_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98373_reg),\n\t.readable_reg = max98373_readable_register,\n\t.volatile_reg = max98373_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\n \nstatic __maybe_unused int max98373_suspend(struct device *dev)\n{\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < max98373->cache_num; i++)\n\t\tregmap_read(max98373->regmap, max98373->cache[i].reg, &max98373->cache[i].val);\n\n\tregcache_cache_only(max98373->regmap, true);\n\n\treturn 0;\n}\n\n#define MAX98373_PROBE_TIMEOUT 5000\n\nstatic __maybe_unused int max98373_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!max98373->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\t\t   msecs_to_jiffies(MAX98373_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(max98373->regmap, false);\n\tregcache_sync(max98373->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops max98373_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max98373_suspend, max98373_resume)\n\tSET_RUNTIME_PM_OPS(max98373_suspend, max98373_resume, NULL)\n};\n\nstatic int max98373_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\n\t \n\tprop->source_ports = BIT(3);\n\t \n\tprop->sink_ports = BIT(1);\n\tprop->paging_support = true;\n\tprop->clk_stop_timeout = 20;\n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t  sizeof(*prop->src_dpn_prop),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t   sizeof(*prop->sink_dpn_prop),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 20;\n\n\treturn 0;\n}\n\nstatic int max98373_io_init(struct sdw_slave *slave)\n{\n\tstruct device *dev = &slave->dev;\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98373->regmap, false);\n\tif (max98373->first_hw_init)\n\t\tregcache_cache_bypass(max98373->regmap, true);\n\n\t \n\tif (!max98373->first_hw_init)\n\t\t \n\t\tpm_runtime_set_active(dev);\n\n\tpm_runtime_get_noresume(dev);\n\n\t \n\tmax98373_reset(max98373, dev);\n\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2025_AUDIO_IF_MODE, 3);\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2047_IV_SENSE_ADC_EN, 3);\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2036_SOUNDWIRE_CTRL, 5);\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2028_PCM_SR_SETUP_2, 0x88);\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2020_PCM_TX_HIZ_EN_1,\n\t\t     0xFF);\n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2021_PCM_TX_HIZ_EN_2,\n\t\t     0xFF);\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2029_PCM_TO_SPK_MONO_MIX_1,\n\t\t     0x80);\n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R202A_PCM_TO_SPK_MONO_MIX_2,\n\t\t     0x1);\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R203F_AMP_DSP_CFG,\n\t\t     0x3);\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2046_IV_SENSE_ADC_DSP_CFG,\n\t\t     0x7);\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2022_PCM_TX_SRC_1,\n\t\t     (max98373->i_slot << MAX98373_PCM_TX_CH_SRC_A_I_SHIFT |\n\t\t     max98373->v_slot) & 0xFF);\n\tif (max98373->v_slot < 8)\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2020_PCM_TX_HIZ_EN_1,\n\t\t\t\t   1 << max98373->v_slot, 0);\n\telse\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2021_PCM_TX_HIZ_EN_2,\n\t\t\t\t   1 << (max98373->v_slot - 8), 0);\n\n\tif (max98373->i_slot < 8)\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2020_PCM_TX_HIZ_EN_1,\n\t\t\t\t   1 << max98373->i_slot, 0);\n\telse\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2021_PCM_TX_HIZ_EN_2,\n\t\t\t\t   1 << (max98373->i_slot - 8), 0);\n\n\t \n\tregmap_write(max98373->regmap,\n\t\t     MAX98373_R2023_PCM_TX_SRC_2,\n\t\t     max98373->spkfb_slot & 0xFF);\n\n\t \n\tif (max98373->interleave_mode)\n\t\tregmap_update_bits(max98373->regmap,\n\t\t\t\t   MAX98373_R2024_PCM_DATA_FMT_CFG,\n\t\t\t\t   MAX98373_PCM_TX_CH_INTERLEAVE_MASK,\n\t\t\t\t   MAX98373_PCM_TX_CH_INTERLEAVE_MASK);\n\n\t \n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2043_AMP_EN,\n\t\t\t   MAX98373_SPK_EN_MASK, 1);\n\n\tregmap_write(max98373->regmap, MAX98373_R20B5_BDE_EN, 1);\n\tregmap_write(max98373->regmap, MAX98373_R20E2_LIMITER_EN, 1);\n\n\tif (max98373->first_hw_init) {\n\t\tregcache_cache_bypass(max98373->regmap, false);\n\t\tregcache_mark_dirty(max98373->regmap);\n\t}\n\n\tmax98373->first_hw_init = true;\n\tmax98373->hw_init = true;\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int max98373_clock_calculate(struct sdw_slave *slave,\n\t\t\t\t    unsigned int clk_freq)\n{\n\tint x, y;\n\tstatic const int max98373_clk_family[] = {\n\t\t7680000, 8400000, 9600000, 11289600,\n\t\t12000000, 12288000, 13000000\n\t};\n\n\tfor (x = 0; x < 4; x++)\n\t\tfor (y = 0; y < ARRAY_SIZE(max98373_clk_family); y++)\n\t\t\tif (clk_freq == (max98373_clk_family[y] >> x))\n\t\t\t\treturn (x << 3) + y;\n\n\t \n\tdev_err(&slave->dev, \"Requested clock not found. (clk_freq = %d)\\n\",\n\t\tclk_freq);\n\treturn 0x5;\n}\n\nstatic int max98373_clock_config(struct sdw_slave *slave,\n\t\t\t\t struct sdw_bus_params *params)\n{\n\tstruct device *dev = &slave->dev;\n\tstruct max98373_priv *max98373 = dev_get_drvdata(dev);\n\tunsigned int clk_freq, value;\n\n\tclk_freq = (params->curr_dr_freq >> 1);\n\n\t \n\tvalue = max98373_clock_calculate(slave, clk_freq);\n\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2036_SOUNDWIRE_CTRL, value);\n\n\t \n\tregmap_write(max98373->regmap, MAX98373_R2028_PCM_SR_SETUP_2, 0x88);\n\n\treturn 0;\n}\n\n#define MAX98373_RATES SNDRV_PCM_RATE_8000_96000\n#define MAX98373_FORMATS (SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int max98373_sdw_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98373_priv *max98373 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint ret, chan_sz, sampling_rate;\n\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!max98373->slave)\n\t\treturn -EINVAL;\n\n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tport_config.num = 1;\n\n\t\tif (max98373->slot) {\n\t\t\tstream_config.ch_count = max98373->slot;\n\t\t\tport_config.ch_mask = max98373->rx_mask;\n\t\t}\n\t} else {\n\t\tport_config.num = 3;\n\n\t\t \n\t\tstream_config.ch_count = 2;\n\t\tport_config.ch_mask = GENMASK((int)stream_config.ch_count - 1, 0);\n\t}\n\n\tret = sdw_stream_add_slave(max98373->slave, &stream_config,\n\t\t\t\t   &port_config, 1, sdw_stream);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn ret;\n\t}\n\n\tif (params_channels(params) > 16) {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98373_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Channel size unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tmax98373->ch_size = snd_pcm_format_width(params_format(params));\n\n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2024_PCM_DATA_FMT_CFG,\n\t\t\t   MAX98373_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\tdev_dbg(component->dev, \"Format supported %d\", params_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_48000;\n\t\tbreak;\n\tcase 88200:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_88200;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = MAX98373_PCM_SR_SET1_SR_96000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2028_PCM_SR_SETUP_2,\n\t\t\t   MAX98373_PCM_SR_SET2_SR_MASK,\n\t\t\t   sampling_rate << MAX98373_PCM_SR_SET2_SR_SHIFT);\n\n\t \n\tregmap_update_bits(max98373->regmap,\n\t\t\t   MAX98373_R2028_PCM_SR_SETUP_2,\n\t\t\t   MAX98373_PCM_SR_SET2_IVADC_SR_MASK,\n\t\t\t   sampling_rate);\n\n\treturn 0;\n}\n\nstatic int max98373_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98373_priv *max98373 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!max98373->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(max98373->slave, sdw_stream);\n\treturn 0;\n}\n\nstatic int max98373_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t   void *sdw_stream, int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void max98373_shutdown(struct snd_pcm_substream *substream,\n\t\t\t      struct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int max98373_sdw_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t     unsigned int tx_mask,\n\t\t\t\t     unsigned int rx_mask,\n\t\t\t\t     int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98373_priv *max98373 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\t \n\tif (tx_mask)\n\t\treturn -EINVAL;\n\n\tif (!rx_mask && !slots && !slot_width)\n\t\tmax98373->tdm_mode = false;\n\telse\n\t\tmax98373->tdm_mode = true;\n\n\tmax98373->rx_mask = rx_mask;\n\tmax98373->slot = slots;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops max98373_dai_sdw_ops = {\n\t.hw_params = max98373_sdw_dai_hw_params,\n\t.hw_free = max98373_pcm_hw_free,\n\t.set_stream = max98373_set_sdw_stream,\n\t.shutdown = max98373_shutdown,\n\t.set_tdm_slot = max98373_sdw_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver max98373_sdw_dai[] = {\n\t{\n\t\t.name = \"max98373-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98373_RATES,\n\t\t\t.formats = MAX98373_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98373_RATES,\n\t\t\t.formats = MAX98373_FORMATS,\n\t\t},\n\t\t.ops = &max98373_dai_sdw_ops,\n\t}\n};\n\nstatic int max98373_init(struct sdw_slave *slave, struct regmap *regmap)\n{\n\tstruct max98373_priv *max98373;\n\tint ret;\n\tint i;\n\tstruct device *dev = &slave->dev;\n\n\t \n\tmax98373 = devm_kzalloc(dev, sizeof(*max98373), GFP_KERNEL);\n\tif (!max98373)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, max98373);\n\tmax98373->regmap = regmap;\n\tmax98373->slave = slave;\n\n\tregcache_cache_only(max98373->regmap, true);\n\n\tmax98373->cache_num = ARRAY_SIZE(max98373_sdw_cache_reg);\n\tmax98373->cache = devm_kcalloc(dev, max98373->cache_num,\n\t\t\t\t       sizeof(*max98373->cache),\n\t\t\t\t       GFP_KERNEL);\n\tif (!max98373->cache)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max98373->cache_num; i++)\n\t\tmax98373->cache[i].reg = max98373_sdw_cache_reg[i];\n\n\t \n\tmax98373_slot_config(dev, max98373);\n\n\tmax98373->hw_init = false;\n\tmax98373->first_hw_init = false;\n\n\t \n\tret = devm_snd_soc_register_component(dev, &soc_codec_dev_max98373_sdw,\n\t\t\t\t\t      max98373_sdw_dai,\n\t\t\t\t\t      ARRAY_SIZE(max98373_sdw_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register codec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\treturn 0;\n}\n\nstatic int max98373_update_status(struct sdw_slave *slave,\n\t\t\t\t  enum sdw_slave_status status)\n{\n\tstruct max98373_priv *max98373 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\tmax98373->hw_init = false;\n\n\t \n\tif (max98373->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn max98373_io_init(slave);\n}\n\nstatic int max98373_bus_config(struct sdw_slave *slave,\n\t\t\t       struct sdw_bus_params *params)\n{\n\tint ret;\n\n\tret = max98373_clock_config(slave, params);\n\tif (ret < 0)\n\t\tdev_err(&slave->dev, \"Invalid clk config\");\n\n\treturn ret;\n}\n\n \nstatic struct sdw_slave_ops max98373_slave_ops = {\n\t.read_prop = max98373_read_prop,\n\t.update_status = max98373_update_status,\n\t.bus_config = max98373_bus_config,\n};\n\nstatic int max98373_sdw_probe(struct sdw_slave *slave,\n\t\t\t      const struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &max98373_sdw_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn max98373_init(slave, regmap);\n}\n\nstatic int max98373_sdw_remove(struct sdw_slave *slave)\n{\n\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98373_of_match[] = {\n\t{ .compatible = \"maxim,max98373\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max98373_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max98373_acpi_match[] = {\n\t{ \"MX98373\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, max98373_acpi_match);\n#endif\n\nstatic const struct sdw_device_id max98373_id[] = {\n\tSDW_SLAVE_ENTRY(0x019F, 0x8373, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, max98373_id);\n\nstatic struct sdw_driver max98373_sdw_driver = {\n\t.driver = {\n\t\t.name = \"max98373\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = of_match_ptr(max98373_of_match),\n\t\t.acpi_match_table = ACPI_PTR(max98373_acpi_match),\n\t\t.pm = &max98373_pm,\n\t},\n\t.probe = max98373_sdw_probe,\n\t.remove = max98373_sdw_remove,\n\t.ops = &max98373_slave_ops,\n\t.id_table = max98373_id,\n};\n\nmodule_sdw_driver(max98373_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC MAX98373 driver SDW\");\nMODULE_AUTHOR(\"Oleg Sherbakov <oleg.sherbakov@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}