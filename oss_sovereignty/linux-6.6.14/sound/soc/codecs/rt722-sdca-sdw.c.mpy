{
  "module_name": "rt722-sdca-sdw.c",
  "hash_id": "33992e39f33e159d266998e087f590cf6899b22a44909406f909ce8ec091d688",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt722-sdca-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/pm_runtime.h>\n#include <linux/soundwire/sdw_registers.h>\n\n#include \"rt722-sdca.h\"\n#include \"rt722-sdca-sdw.h\"\n\nstatic bool rt722_sdca_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f01 ... 0x2f0a:\n\tcase 0x2f35 ... 0x2f36:\n\tcase 0x2f50:\n\tcase 0x2f54:\n\tcase 0x2f58 ... 0x2f5d:\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49, RT722_SDCA_CTL_SELECTED_MODE,\n\t\t\t0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49, RT722_SDCA_CTL_DETECTED_MODE,\n\t\t\t0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01, RT722_SDCA_CTL_HIDTX_CURRENT_OWNER,\n\t\t\t0) ... SDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\tRT722_SDCA_CTL_HIDTX_MESSAGE_LENGTH, 0):\n\tcase RT722_BUF_ADDR_HID1 ... RT722_BUF_ADDR_HID2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt722_sdca_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f01:\n\tcase 0x2f54:\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49, RT722_SDCA_CTL_DETECTED_MODE,\n\t\t\t0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01, RT722_SDCA_CTL_HIDTX_CURRENT_OWNER,\n\t\t\t0) ... SDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\tRT722_SDCA_CTL_HIDTX_MESSAGE_LENGTH, 0):\n\tcase RT722_BUF_ADDR_HID1 ... RT722_BUF_ADDR_HID2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt722_sdca_mbq_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000 ... 0x2000024:\n\tcase 0x2000029 ... 0x200004a:\n\tcase 0x2000051 ... 0x2000052:\n\tcase 0x200005a ... 0x200005b:\n\tcase 0x2000061 ... 0x2000069:\n\tcase 0x200006b:\n\tcase 0x2000070:\n\tcase 0x200007f:\n\tcase 0x2000082 ... 0x200008e:\n\tcase 0x2000090 ... 0x2000094:\n\tcase 0x5300000 ... 0x5300002:\n\tcase 0x5400002:\n\tcase 0x5600000 ... 0x5600007:\n\tcase 0x5700000 ... 0x5700004:\n\tcase 0x5800000 ... 0x5800004:\n\tcase 0x5b00003:\n\tcase 0x5c00011:\n\tcase 0x5d00006:\n\tcase 0x5f00000 ... 0x5f0000d:\n\tcase 0x5f00030:\n\tcase 0x6100000 ... 0x6100051:\n\tcase 0x6100055 ... 0x6100057:\n\tcase 0x6100062:\n\tcase 0x6100064 ... 0x6100065:\n\tcase 0x6100067:\n\tcase 0x6100070 ... 0x610007c:\n\tcase 0x6100080:\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_01):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_02):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_03):\n\tcase SDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_04):\n\tcase SDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06, RT722_SDCA_CTL_FU_VOLUME, CH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06, RT722_SDCA_CTL_FU_VOLUME, CH_R):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_R):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F, RT722_SDCA_CTL_FU_VOLUME,\n\t\t\tCH_R):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PLATFORM_FU44,\n\t\t\tRT722_SDCA_CTL_FU_CH_GAIN, CH_L):\n\tcase SDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PLATFORM_FU44,\n\t\t\tRT722_SDCA_CTL_FU_CH_GAIN, CH_R):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt722_sdca_mbq_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2000000:\n\tcase 0x200000d:\n\tcase 0x2000019:\n\tcase 0x2000020:\n\tcase 0x2000030:\n\tcase 0x2000046:\n\tcase 0x2000067:\n\tcase 0x2000084:\n\tcase 0x2000086:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config rt722_sdca_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt722_sdca_readable_register,\n\t.volatile_reg = rt722_sdca_volatile_register,\n\t.max_register = 0x44ffffff,\n\t.reg_defaults = rt722_sdca_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt722_sdca_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic const struct regmap_config rt722_sdca_mbq_regmap = {\n\t.name = \"sdw-mbq\",\n\t.reg_bits = 32,\n\t.val_bits = 16,\n\t.readable_reg = rt722_sdca_mbq_readable_register,\n\t.volatile_reg = rt722_sdca_mbq_volatile_register,\n\t.max_register = 0x41000312,\n\t.reg_defaults = rt722_sdca_mbq_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt722_sdca_mbq_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt722_sdca_update_status(struct sdw_slave *slave,\n\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt722->hw_init = false;\n\n\tif (status == SDW_SLAVE_ATTACHED) {\n\t\tif (rt722->hs_jack) {\n\t\t \n\t\t\tsdw_write_no_pm(rt722->slave, SDW_SCP_SDCA_INTMASK1,\n\t\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_6);\n\t\t\tsdw_write_no_pm(rt722->slave, SDW_SCP_SDCA_INTMASK2,\n\t\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_8);\n\t\t}\n\t}\n\n\t \n\tif (rt722->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt722_sdca_io_init(&slave->dev, slave);\n}\n\nstatic int rt722_sdca_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval;\n\tint i, j;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = BIT(6) | BIT(2);  \n\tprop->sink_ports = BIT(3) | BIT(1);  \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->src_dpn_prop), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->sink_dpn_prop), GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[j].num = bit;\n\t\tdpn[j].type = SDW_DPN_FULL;\n\t\tdpn[j].simple_ch_prep_sm = true;\n\t\tdpn[j].ch_prep_timeout = 10;\n\t\tj++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 200;\n\n\t \n\tprop->wake_capable = 1;\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_interrupt_callback(struct sdw_slave *slave,\n\t\t\t\t\tstruct sdw_slave_intr_status *status)\n{\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(&slave->dev);\n\tint ret, stat;\n\tint count = 0, retry = 3;\n\tunsigned int sdca_cascade, scp_sdca_stat1, scp_sdca_stat2 = 0;\n\n\tif (cancel_delayed_work_sync(&rt722->jack_detect_work)) {\n\t\tdev_warn(&slave->dev, \"%s the pending delayed_work was cancelled\", __func__);\n\t\t \n\t\tif (rt722->scp_sdca_stat2)\n\t\t\tscp_sdca_stat2 = rt722->scp_sdca_stat2;\n\t}\n\n\t \n\tmutex_lock(&rt722->disable_irq_lock);\n\n\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT1);\n\tif (ret < 0)\n\t\tgoto io_error;\n\trt722->scp_sdca_stat1 = ret;\n\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT2);\n\tif (ret < 0)\n\t\tgoto io_error;\n\trt722->scp_sdca_stat2 = ret;\n\tif (scp_sdca_stat2)\n\t\trt722->scp_sdca_stat2 |= scp_sdca_stat2;\n\tdo {\n\t\t \n\t\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT1);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t\tif (ret & SDW_SCP_SDCA_INTMASK_SDCA_0) {\n\t\t\tret = sdw_update_no_pm(rt722->slave, SDW_SCP_SDCA_INT1,\n\t\t\t\tSDW_SCP_SDCA_INT_SDCA_0, SDW_SCP_SDCA_INT_SDCA_0);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto io_error;\n\t\t} else if (ret & SDW_SCP_SDCA_INTMASK_SDCA_6) {\n\t\t\tret = sdw_update_no_pm(rt722->slave, SDW_SCP_SDCA_INT1,\n\t\t\t\tSDW_SCP_SDCA_INT_SDCA_6, SDW_SCP_SDCA_INT_SDCA_6);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto io_error;\n\t\t}\n\t\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT2);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t\tif (ret & SDW_SCP_SDCA_INTMASK_SDCA_8) {\n\t\t\tret = sdw_write_no_pm(rt722->slave, SDW_SCP_SDCA_INT2,\n\t\t\t\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_8);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto io_error;\n\t\t}\n\n\t\t \n\t\tret = sdw_read_no_pm(rt722->slave, SDW_DP0_INT);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t\tsdca_cascade = ret & SDW_DP0_SDCA_CASCADE;\n\n\t\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT1);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t\tscp_sdca_stat1 = ret & SDW_SCP_SDCA_INTMASK_SDCA_0;\n\n\t\tret = sdw_read_no_pm(rt722->slave, SDW_SCP_SDCA_INT2);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t\tscp_sdca_stat2 = ret & SDW_SCP_SDCA_INTMASK_SDCA_8;\n\n\t\tstat = scp_sdca_stat1 || scp_sdca_stat2 || sdca_cascade;\n\n\t\tcount++;\n\t} while (stat != 0 && count < retry);\n\n\tif (stat)\n\t\tdev_warn(&slave->dev,\n\t\t\t\"%s scp_sdca_stat1=0x%x, scp_sdca_stat2=0x%x\\n\", __func__,\n\t\t\trt722->scp_sdca_stat1, rt722->scp_sdca_stat2);\n\n\tif (status->sdca_cascade && !rt722->disable_irq)\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt722->jack_detect_work, msecs_to_jiffies(30));\n\n\tmutex_unlock(&rt722->disable_irq_lock);\n\n\treturn 0;\n\nio_error:\n\tmutex_unlock(&rt722->disable_irq_lock);\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic struct sdw_slave_ops rt722_sdca_slave_ops = {\n\t.read_prop = rt722_sdca_read_prop,\n\t.interrupt_callback = rt722_sdca_interrupt_callback,\n\t.update_status = rt722_sdca_update_status,\n};\n\nstatic int rt722_sdca_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct regmap *regmap, *mbq_regmap;\n\n\t \n\tmbq_regmap = devm_regmap_init_sdw_mbq(slave, &rt722_sdca_mbq_regmap);\n\tif (IS_ERR(mbq_regmap))\n\t\treturn PTR_ERR(mbq_regmap);\n\n\tregmap = devm_regmap_init_sdw(slave, &rt722_sdca_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt722_sdca_init(&slave->dev, regmap, mbq_regmap, slave);\n}\n\nstatic int rt722_sdca_sdw_remove(struct sdw_slave *slave)\n{\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(&slave->dev);\n\n\tif (rt722->hw_init) {\n\t\tcancel_delayed_work_sync(&rt722->jack_detect_work);\n\t\tcancel_delayed_work_sync(&rt722->jack_btn_check_work);\n\t}\n\n\tif (rt722->first_hw_init)\n\t\tpm_runtime_disable(&slave->dev);\n\n\tmutex_destroy(&rt722->calibrate_mutex);\n\tmutex_destroy(&rt722->disable_irq_lock);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt722_sdca_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x722, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt722_sdca_id);\n\nstatic int __maybe_unused rt722_sdca_dev_suspend(struct device *dev)\n{\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(dev);\n\n\tif (!rt722->hw_init)\n\t\treturn 0;\n\n\tcancel_delayed_work_sync(&rt722->jack_detect_work);\n\tcancel_delayed_work_sync(&rt722->jack_btn_check_work);\n\n\tregcache_cache_only(rt722->regmap, true);\n\tregcache_cache_only(rt722->mbq_regmap, true);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused rt722_sdca_dev_system_suspend(struct device *dev)\n{\n\tstruct rt722_sdca_priv *rt722_sdca = dev_get_drvdata(dev);\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tint ret1, ret2;\n\n\tif (!rt722_sdca->hw_init)\n\t\treturn 0;\n\n\t \n\tmutex_lock(&rt722_sdca->disable_irq_lock);\n\trt722_sdca->disable_irq = true;\n\tret1 = sdw_update_no_pm(slave, SDW_SCP_SDCA_INTMASK1,\n\t\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_0 | SDW_SCP_SDCA_INTMASK_SDCA_6, 0);\n\tret2 = sdw_update_no_pm(slave, SDW_SCP_SDCA_INTMASK2,\n\t\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_8, 0);\n\tmutex_unlock(&rt722_sdca->disable_irq_lock);\n\n\tif (ret1 < 0 || ret2 < 0) {\n\t\t \n\t\tdev_dbg(&slave->dev, \"%s: could not disable SDCA interrupts\\n:\", __func__);\n\t}\n\n\treturn rt722_sdca_dev_suspend(dev);\n}\n\n#define RT722_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt722_sdca_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt722->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request) {\n\t\tif (rt722->disable_irq == true) {\n\t\t\tmutex_lock(&rt722->disable_irq_lock);\n\t\t\tsdw_write_no_pm(slave, SDW_SCP_SDCA_INTMASK1, SDW_SCP_SDCA_INTMASK_SDCA_6);\n\t\t\tsdw_write_no_pm(slave, SDW_SCP_SDCA_INTMASK2, SDW_SCP_SDCA_INTMASK_SDCA_8);\n\t\t\trt722->disable_irq = false;\n\t\t\tmutex_unlock(&rt722->disable_irq_lock);\n\t\t}\n\t\tgoto regmap_sync;\n\t}\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT722_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt722->regmap, false);\n\tregcache_sync(rt722->regmap);\n\tregcache_cache_only(rt722->mbq_regmap, false);\n\tregcache_sync(rt722->mbq_regmap);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt722_sdca_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt722_sdca_dev_system_suspend, rt722_sdca_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt722_sdca_dev_suspend, rt722_sdca_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt722_sdca_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt722-sdca\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt722_sdca_pm,\n\t},\n\t.probe = rt722_sdca_sdw_probe,\n\t.remove = rt722_sdca_sdw_remove,\n\t.ops = &rt722_sdca_slave_ops,\n\t.id_table = rt722_sdca_id,\n};\nmodule_sdw_driver(rt722_sdca_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT722 SDCA SDW driver\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}