{
  "module_name": "wm8753.c",
  "hash_id": "346f28c59b00419d208db7ffd71922b66ef973fdec26301610f147d74b67b16c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8753.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <asm/div64.h>\n\n#include \"wm8753.h\"\n\nstatic int caps_charge = 2000;\nmodule_param(caps_charge, int, 0);\nMODULE_PARM_DESC(caps_charge, \"WM8753 cap charge time (msecs)\");\n\nstatic int wm8753_hifi_write_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt);\nstatic int wm8753_voice_write_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt);\n\n \nstatic const struct reg_default wm8753_reg_defaults[] = {\n\t{ 0x00, 0x0000 },\n\t{ 0x01, 0x0008 },\n\t{ 0x02, 0x0000 },\n\t{ 0x03, 0x000a },\n\t{ 0x04, 0x000a },\n\t{ 0x05, 0x0033 },\n\t{ 0x06, 0x0000 },\n\t{ 0x07, 0x0007 },\n\t{ 0x08, 0x00ff },\n\t{ 0x09, 0x00ff },\n\t{ 0x0a, 0x000f },\n\t{ 0x0b, 0x000f },\n\t{ 0x0c, 0x007b },\n\t{ 0x0d, 0x0000 },\n\t{ 0x0e, 0x0032 },\n\t{ 0x0f, 0x0000 },\n\t{ 0x10, 0x00c3 },\n\t{ 0x11, 0x00c3 },\n\t{ 0x12, 0x00c0 },\n\t{ 0x13, 0x0000 },\n\t{ 0x14, 0x0000 },\n\t{ 0x15, 0x0000 },\n\t{ 0x16, 0x0000 },\n\t{ 0x17, 0x0000 },\n\t{ 0x18, 0x0000 },\n\t{ 0x19, 0x0000 },\n\t{ 0x1a, 0x0000 },\n\t{ 0x1b, 0x0000 },\n\t{ 0x1c, 0x0000 },\n\t{ 0x1d, 0x0000 },\n\t{ 0x1e, 0x0000 },\n\t{ 0x1f, 0x0000 },\n\t{ 0x20, 0x0055 },\n\t{ 0x21, 0x0005 },\n\t{ 0x22, 0x0050 },\n\t{ 0x23, 0x0055 },\n\t{ 0x24, 0x0050 },\n\t{ 0x25, 0x0055 },\n\t{ 0x26, 0x0050 },\n\t{ 0x27, 0x0055 },\n\t{ 0x28, 0x0079 },\n\t{ 0x29, 0x0079 },\n\t{ 0x2a, 0x0079 },\n\t{ 0x2b, 0x0079 },\n\t{ 0x2c, 0x0079 },\n\t{ 0x2d, 0x0000 },\n\t{ 0x2e, 0x0000 },\n\t{ 0x2f, 0x0000 },\n\t{ 0x30, 0x0000 },\n\t{ 0x31, 0x0097 },\n\t{ 0x32, 0x0097 },\n\t{ 0x33, 0x0000 },\n\t{ 0x34, 0x0004 },\n\t{ 0x35, 0x0000 },\n\t{ 0x36, 0x0083 },\n\t{ 0x37, 0x0024 },\n\t{ 0x38, 0x01ba },\n\t{ 0x39, 0x0000 },\n\t{ 0x3a, 0x0083 },\n\t{ 0x3b, 0x0024 },\n\t{ 0x3c, 0x01ba },\n\t{ 0x3d, 0x0000 },\n\t{ 0x3e, 0x0000 },\n\t{ 0x3f, 0x0000 },\n};\n\nstatic bool wm8753_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == WM8753_RESET;\n}\n\n \nstruct wm8753_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n\tunsigned int pcmclk;\n\n\tunsigned int voice_fmt;\n\tunsigned int hifi_fmt;\n\n\tint dai_func;\n\tstruct delayed_work charge_work;\n};\n\n#define wm8753_reset(c) snd_soc_component_write(c, WM8753_RESET, 0)\n\n \nstatic const char *wm8753_base[] = {\"Linear Control\", \"Adaptive Boost\"};\nstatic const char *wm8753_base_filter[] =\n\t{\"130Hz @ 48kHz\", \"200Hz @ 48kHz\", \"100Hz @ 16kHz\", \"400Hz @ 48kHz\",\n\t\"100Hz @ 8kHz\", \"200Hz @ 8kHz\"};\nstatic const char *wm8753_treble[] = {\"8kHz\", \"4kHz\"};\nstatic const char *wm8753_alc_func[] = {\"Off\", \"Right\", \"Left\", \"Stereo\"};\nstatic const char *wm8753_ng_type[] = {\"Constant PGA Gain\", \"Mute ADC Output\"};\nstatic const char *wm8753_3d_func[] = {\"Capture\", \"Playback\"};\nstatic const char *wm8753_3d_uc[] = {\"2.2kHz\", \"1.5kHz\"};\nstatic const char *wm8753_3d_lc[] = {\"200Hz\", \"500Hz\"};\nstatic const char *wm8753_deemp[] = {\"None\", \"32kHz\", \"44.1kHz\", \"48kHz\"};\nstatic const char *wm8753_mono_mix[] = {\"Stereo\", \"Left\", \"Right\", \"Mono\"};\nstatic const char *wm8753_dac_phase[] = {\"Non Inverted\", \"Inverted\"};\nstatic const char *wm8753_line_mix[] = {\"Line 1 + 2\", \"Line 1 - 2\",\n\t\"Line 1\", \"Line 2\"};\nstatic const char *wm8753_mono_mux[] = {\"Line Mix\", \"Rx Mix\"};\nstatic const char *wm8753_right_mux[] = {\"Line 2\", \"Rx Mix\"};\nstatic const char *wm8753_left_mux[] = {\"Line 1\", \"Rx Mix\"};\nstatic const char *wm8753_rxmsel[] = {\"RXP - RXN\", \"RXP + RXN\", \"RXP\", \"RXN\"};\nstatic const char *wm8753_sidetone_mux[] = {\"Left PGA\", \"Mic 1\", \"Mic 2\",\n\t\"Right PGA\"};\nstatic const char *wm8753_mono2_src[] = {\"Inverted Mono 1\", \"Left\", \"Right\",\n\t\"Left + Right\"};\nstatic const char *wm8753_out3[] = {\"VREF\", \"ROUT2\", \"Left + Right\"};\nstatic const char *wm8753_out4[] = {\"VREF\", \"Capture ST\", \"LOUT2\"};\nstatic const char *wm8753_radcsel[] = {\"PGA\", \"Line or RXP-RXN\", \"Sidetone\"};\nstatic const char *wm8753_ladcsel[] = {\"PGA\", \"Line or RXP-RXN\", \"Line\"};\nstatic const char *wm8753_mono_adc[] = {\"Stereo\", \"Analogue Mix Left\",\n\t\"Analogue Mix Right\", \"Digital Mono Mix\"};\nstatic const char *wm8753_adc_hp[] = {\"3.4Hz @ 48kHz\", \"82Hz @ 16k\",\n\t\"82Hz @ 8kHz\", \"170Hz @ 8kHz\"};\nstatic const char *wm8753_adc_filter[] = {\"HiFi\", \"Voice\"};\nstatic const char *wm8753_mic_sel[] = {\"Mic 1\", \"Mic 2\", \"Mic 3\"};\nstatic const char *wm8753_dai_mode[] = {\"DAI 0\", \"DAI 1\", \"DAI 2\", \"DAI 3\"};\nstatic const char *wm8753_dat_sel[] = {\"Stereo\", \"Left ADC\", \"Right ADC\",\n\t\"Channel Swap\"};\nstatic const char *wm8753_rout2_phase[] = {\"Non Inverted\", \"Inverted\"};\n\nstatic const struct soc_enum wm8753_enum[] = {\nSOC_ENUM_SINGLE(WM8753_BASS, 7, 2, wm8753_base),\nSOC_ENUM_SINGLE(WM8753_BASS, 4, 6, wm8753_base_filter),\nSOC_ENUM_SINGLE(WM8753_TREBLE, 6, 2, wm8753_treble),\nSOC_ENUM_SINGLE(WM8753_ALC1, 7, 4, wm8753_alc_func),\nSOC_ENUM_SINGLE(WM8753_NGATE, 1, 2, wm8753_ng_type),\nSOC_ENUM_SINGLE(WM8753_3D, 7, 2, wm8753_3d_func),\nSOC_ENUM_SINGLE(WM8753_3D, 6, 2, wm8753_3d_uc),\nSOC_ENUM_SINGLE(WM8753_3D, 5, 2, wm8753_3d_lc),\nSOC_ENUM_SINGLE(WM8753_DAC, 1, 4, wm8753_deemp),\nSOC_ENUM_SINGLE(WM8753_DAC, 4, 4, wm8753_mono_mix),\nSOC_ENUM_SINGLE(WM8753_DAC, 6, 2, wm8753_dac_phase),\nSOC_ENUM_SINGLE(WM8753_INCTL1, 3, 4, wm8753_line_mix),\nSOC_ENUM_SINGLE(WM8753_INCTL1, 2, 2, wm8753_mono_mux),\nSOC_ENUM_SINGLE(WM8753_INCTL1, 1, 2, wm8753_right_mux),\nSOC_ENUM_SINGLE(WM8753_INCTL1, 0, 2, wm8753_left_mux),\nSOC_ENUM_SINGLE(WM8753_INCTL2, 6, 4, wm8753_rxmsel),\nSOC_ENUM_SINGLE(WM8753_INCTL2, 4, 4, wm8753_sidetone_mux),\nSOC_ENUM_SINGLE(WM8753_OUTCTL, 7, 4, wm8753_mono2_src),\nSOC_ENUM_SINGLE(WM8753_OUTCTL, 0, 3, wm8753_out3),\nSOC_ENUM_SINGLE(WM8753_ADCTL2, 7, 3, wm8753_out4),\nSOC_ENUM_SINGLE(WM8753_ADCIN, 2, 3, wm8753_radcsel),\nSOC_ENUM_SINGLE(WM8753_ADCIN, 0, 3, wm8753_ladcsel),\nSOC_ENUM_SINGLE(WM8753_ADCIN, 4, 4, wm8753_mono_adc),\nSOC_ENUM_SINGLE(WM8753_ADC, 2, 4, wm8753_adc_hp),\nSOC_ENUM_SINGLE(WM8753_ADC, 4, 2, wm8753_adc_filter),\nSOC_ENUM_SINGLE(WM8753_MICBIAS, 6, 3, wm8753_mic_sel),\nSOC_ENUM_SINGLE(WM8753_IOCTL, 2, 4, wm8753_dai_mode),\nSOC_ENUM_SINGLE(WM8753_ADC, 7, 4, wm8753_dat_sel),\nSOC_ENUM_SINGLE(WM8753_OUTCTL, 2, 2, wm8753_rout2_phase),\n};\n\n\nstatic int wm8753_get_dai(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8753->dai_func;\n\treturn 0;\n}\n\nstatic int wm8753_set_dai(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tu16 ioctl;\n\n\tif (wm8753->dai_func == ucontrol->value.enumerated.item[0])\n\t\treturn 0;\n\n\tif (snd_soc_component_active(component))\n\t\treturn -EBUSY;\n\n\tioctl = snd_soc_component_read(component, WM8753_IOCTL);\n\n\twm8753->dai_func = ucontrol->value.enumerated.item[0];\n\n\tif (((ioctl >> 2) & 0x3) == wm8753->dai_func)\n\t\treturn 1;\n\n\tioctl = (ioctl & 0x1f3) | (wm8753->dai_func << 2);\n\tsnd_soc_component_write(component, WM8753_IOCTL, ioctl);\n\n\n\twm8753_hifi_write_dai_fmt(component, wm8753->hifi_fmt);\n\twm8753_voice_write_dai_fmt(component, wm8753->voice_fmt);\n\n\treturn 1;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(rec_mix_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_preamp_tlv, 1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -9750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_RANGE(out_tlv,\n\t \n\t0, 48, TLV_DB_SCALE_ITEM(-25500, 0, 0),\n\t48, 127, TLV_DB_SCALE_ITEM(-7300, 100, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(mix_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(voice_mix_tlv, -1200, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, -1725, 75, 0);\n\nstatic const struct snd_kcontrol_new wm8753_snd_controls[] = {\nSOC_SINGLE(\"Hi-Fi DAC Left/Right channel Swap\", WM8753_HIFI, 5, 1, 0),\nSOC_DOUBLE_R_TLV(\"PCM Volume\", WM8753_LDAC, WM8753_RDAC, 0, 255, 0, dac_tlv),\n\nSOC_DOUBLE_R_TLV(\"ADC Capture Volume\", WM8753_LADC, WM8753_RADC, 0, 255, 0,\n\t\t adc_tlv),\n\nSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", WM8753_LOUT1V, WM8753_ROUT1V,\n\t\t 0, 127, 0, out_tlv),\nSOC_DOUBLE_R_TLV(\"Speaker Playback Volume\", WM8753_LOUT2V, WM8753_ROUT2V, 0,\n\t\t 127, 0, out_tlv),\n\nSOC_SINGLE_TLV(\"Mono Playback Volume\", WM8753_MOUTV, 0, 127, 0, out_tlv),\n\nSOC_DOUBLE_R_TLV(\"Bypass Playback Volume\", WM8753_LOUTM1, WM8753_ROUTM1, 4, 7,\n\t\t 1, mix_tlv),\nSOC_DOUBLE_R_TLV(\"Sidetone Playback Volume\", WM8753_LOUTM2, WM8753_ROUTM2, 4,\n\t\t 7, 1, mix_tlv),\nSOC_DOUBLE_R_TLV(\"Voice Playback Volume\", WM8753_LOUTM2, WM8753_ROUTM2, 0, 7,\n\t\t 1, voice_mix_tlv),\n\nSOC_DOUBLE_R(\"Headphone Playback ZC Switch\", WM8753_LOUT1V, WM8753_ROUT1V, 7,\n\t     1, 0),\nSOC_DOUBLE_R(\"Speaker Playback ZC Switch\", WM8753_LOUT2V, WM8753_ROUT2V, 7,\n\t     1, 0),\n\nSOC_SINGLE_TLV(\"Mono Bypass Playback Volume\", WM8753_MOUTM1, 4, 7, 1, mix_tlv),\nSOC_SINGLE_TLV(\"Mono Sidetone Playback Volume\", WM8753_MOUTM2, 4, 7, 1,\n\t       mix_tlv),\nSOC_SINGLE_TLV(\"Mono Voice Playback Volume\", WM8753_MOUTM2, 0, 7, 1,\n\t       voice_mix_tlv),\nSOC_SINGLE(\"Mono Playback ZC Switch\", WM8753_MOUTV, 7, 1, 0),\n\nSOC_ENUM(\"Bass Boost\", wm8753_enum[0]),\nSOC_ENUM(\"Bass Filter\", wm8753_enum[1]),\nSOC_SINGLE(\"Bass Volume\", WM8753_BASS, 0, 15, 1),\n\nSOC_SINGLE(\"Treble Volume\", WM8753_TREBLE, 0, 15, 1),\nSOC_ENUM(\"Treble Cut-off\", wm8753_enum[2]),\n\nSOC_DOUBLE_TLV(\"Sidetone Capture Volume\", WM8753_RECMIX1, 0, 4, 7, 1,\n\t       rec_mix_tlv),\nSOC_SINGLE_TLV(\"Voice Sidetone Capture Volume\", WM8753_RECMIX2, 0, 7, 1,\n\t       rec_mix_tlv),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8753_LINVOL, WM8753_RINVOL, 0, 63, 0,\n\t\t pga_tlv),\nSOC_DOUBLE_R(\"Capture ZC Switch\", WM8753_LINVOL, WM8753_RINVOL, 6, 1, 0),\nSOC_DOUBLE_R(\"Capture Switch\", WM8753_LINVOL, WM8753_RINVOL, 7, 1, 1),\n\nSOC_ENUM(\"Capture Filter Select\", wm8753_enum[23]),\nSOC_ENUM(\"Capture Filter Cut-off\", wm8753_enum[24]),\nSOC_SINGLE(\"Capture Filter Switch\", WM8753_ADC, 0, 1, 1),\n\nSOC_SINGLE(\"ALC Capture Target Volume\", WM8753_ALC1, 0, 7, 0),\nSOC_SINGLE(\"ALC Capture Max Volume\", WM8753_ALC1, 4, 7, 0),\nSOC_ENUM(\"ALC Capture Function\", wm8753_enum[3]),\nSOC_SINGLE(\"ALC Capture ZC Switch\", WM8753_ALC2, 8, 1, 0),\nSOC_SINGLE(\"ALC Capture Hold Time\", WM8753_ALC2, 0, 15, 1),\nSOC_SINGLE(\"ALC Capture Decay Time\", WM8753_ALC3, 4, 15, 1),\nSOC_SINGLE(\"ALC Capture Attack Time\", WM8753_ALC3, 0, 15, 0),\nSOC_SINGLE(\"ALC Capture NG Threshold\", WM8753_NGATE, 3, 31, 0),\nSOC_ENUM(\"ALC Capture NG Type\", wm8753_enum[4]),\nSOC_SINGLE(\"ALC Capture NG Switch\", WM8753_NGATE, 0, 1, 0),\n\nSOC_ENUM(\"3D Function\", wm8753_enum[5]),\nSOC_ENUM(\"3D Upper Cut-off\", wm8753_enum[6]),\nSOC_ENUM(\"3D Lower Cut-off\", wm8753_enum[7]),\nSOC_SINGLE(\"3D Volume\", WM8753_3D, 1, 15, 0),\nSOC_SINGLE(\"3D Switch\", WM8753_3D, 0, 1, 0),\n\nSOC_SINGLE(\"Capture 6dB Attenuate\", WM8753_ADCTL1, 2, 1, 0),\nSOC_SINGLE(\"Playback 6dB Attenuate\", WM8753_ADCTL1, 1, 1, 0),\n\nSOC_ENUM(\"De-emphasis\", wm8753_enum[8]),\nSOC_ENUM(\"Playback Mono Mix\", wm8753_enum[9]),\nSOC_ENUM(\"Playback Phase\", wm8753_enum[10]),\n\nSOC_SINGLE_TLV(\"Mic2 Capture Volume\", WM8753_INCTL1, 7, 3, 0, mic_preamp_tlv),\nSOC_SINGLE_TLV(\"Mic1 Capture Volume\", WM8753_INCTL1, 5, 3, 0, mic_preamp_tlv),\n\nSOC_ENUM_EXT(\"DAI Mode\", wm8753_enum[26], wm8753_get_dai, wm8753_set_dai),\n\nSOC_ENUM(\"ADC Data Select\", wm8753_enum[27]),\nSOC_ENUM(\"ROUT2 Phase\", wm8753_enum[28]),\n};\n\n \n\n \nstatic const struct snd_kcontrol_new wm8753_left_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Voice Playback Switch\", WM8753_LOUTM2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Sidetone Playback Switch\", WM8753_LOUTM2, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Left Playback Switch\", WM8753_LOUTM1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Playback Switch\", WM8753_LOUTM1, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8753_right_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Voice Playback Switch\", WM8753_ROUTM2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Sidetone Playback Switch\", WM8753_ROUTM2, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Right Playback Switch\", WM8753_ROUTM1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Playback Switch\", WM8753_ROUTM1, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8753_mono_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Left Playback Switch\", WM8753_MOUTM1, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Right Playback Switch\", WM8753_MOUTM2, 8, 1, 0),\nSOC_DAPM_SINGLE(\"Voice Playback Switch\", WM8753_MOUTM2, 3, 1, 0),\nSOC_DAPM_SINGLE(\"Sidetone Playback Switch\", WM8753_MOUTM2, 7, 1, 0),\nSOC_DAPM_SINGLE(\"Bypass Playback Switch\", WM8753_MOUTM1, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8753_mono2_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[17]);\n\n \nstatic const struct snd_kcontrol_new wm8753_out3_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[18]);\n\n \nstatic const struct snd_kcontrol_new wm8753_out4_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[19]);\n\n \nstatic const struct snd_kcontrol_new wm8753_adc_mono_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[22]);\n\n \nstatic const struct snd_kcontrol_new wm8753_record_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Voice Capture Switch\", WM8753_RECMIX2, 3, 1, 0),\nSOC_DAPM_SINGLE(\"Left Capture Switch\", WM8753_RECMIX1, 3, 1, 0),\nSOC_DAPM_SINGLE(\"Right Capture Switch\", WM8753_RECMIX1, 7, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8753_adc_left_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[21]);\n\n \nstatic const struct snd_kcontrol_new wm8753_adc_right_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[20]);\n\n \nstatic const struct snd_kcontrol_new wm8753_mic_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[16]);\n\n \nstatic const struct snd_kcontrol_new wm8753_alc_mixer_controls[] = {\nSOC_DAPM_SINGLE(\"Line Capture Switch\", WM8753_INCTL2, 3, 1, 0),\nSOC_DAPM_SINGLE(\"Mic2 Capture Switch\", WM8753_INCTL2, 2, 1, 0),\nSOC_DAPM_SINGLE(\"Mic1 Capture Switch\", WM8753_INCTL2, 1, 1, 0),\nSOC_DAPM_SINGLE(\"Rx Capture Switch\", WM8753_INCTL2, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new wm8753_line_left_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[14]);\n\n \nstatic const struct snd_kcontrol_new wm8753_line_right_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[13]);\n\n \nstatic const struct snd_kcontrol_new wm8753_line_mono_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[12]);\n\n \nstatic const struct snd_kcontrol_new wm8753_line_mux_mix_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[11]);\n\n \nstatic const struct snd_kcontrol_new wm8753_rx_mux_mix_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[15]);\n\n \nstatic const struct snd_kcontrol_new wm8753_mic_sel_mux_controls =\nSOC_DAPM_ENUM(\"Route\", wm8753_enum[25]);\n\nstatic const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {\nSND_SOC_DAPM_MICBIAS(\"Mic Bias\", WM8753_PWR1, 5, 0),\nSND_SOC_DAPM_MIXER(\"Left Mixer\", WM8753_PWR4, 0, 0,\n\t&wm8753_left_mixer_controls[0], ARRAY_SIZE(wm8753_left_mixer_controls)),\nSND_SOC_DAPM_PGA(\"Left Out 1\", WM8753_PWR3, 8, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Left Out 2\", WM8753_PWR3, 6, 0, NULL, 0),\nSND_SOC_DAPM_DAC(\"Left DAC\", \"Left HiFi Playback\", WM8753_PWR1, 3, 0),\nSND_SOC_DAPM_OUTPUT(\"LOUT1\"),\nSND_SOC_DAPM_OUTPUT(\"LOUT2\"),\nSND_SOC_DAPM_MIXER(\"Right Mixer\", WM8753_PWR4, 1, 0,\n\t&wm8753_right_mixer_controls[0], ARRAY_SIZE(wm8753_right_mixer_controls)),\nSND_SOC_DAPM_PGA(\"Right Out 1\", WM8753_PWR3, 7, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Out 2\", WM8753_PWR3, 5, 0, NULL, 0),\nSND_SOC_DAPM_DAC(\"Right DAC\", \"Right HiFi Playback\", WM8753_PWR1, 2, 0),\nSND_SOC_DAPM_OUTPUT(\"ROUT1\"),\nSND_SOC_DAPM_OUTPUT(\"ROUT2\"),\nSND_SOC_DAPM_MIXER(\"Mono Mixer\", WM8753_PWR4, 2, 0,\n\t&wm8753_mono_mixer_controls[0], ARRAY_SIZE(wm8753_mono_mixer_controls)),\nSND_SOC_DAPM_PGA(\"Mono Out 1\", WM8753_PWR3, 2, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Mono Out 2\", WM8753_PWR3, 1, 0, NULL, 0),\nSND_SOC_DAPM_DAC(\"Voice DAC\", \"Voice Playback\", WM8753_PWR1, 4, 0),\nSND_SOC_DAPM_OUTPUT(\"MONO1\"),\nSND_SOC_DAPM_MUX(\"Mono 2 Mux\", SND_SOC_NOPM, 0, 0, &wm8753_mono2_controls),\nSND_SOC_DAPM_OUTPUT(\"MONO2\"),\nSND_SOC_DAPM_MIXER(\"Out3 Left + Right\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_MUX(\"Out3 Mux\", SND_SOC_NOPM, 0, 0, &wm8753_out3_controls),\nSND_SOC_DAPM_PGA(\"Out 3\", WM8753_PWR3, 4, 0, NULL, 0),\nSND_SOC_DAPM_OUTPUT(\"OUT3\"),\nSND_SOC_DAPM_MUX(\"Out4 Mux\", SND_SOC_NOPM, 0, 0, &wm8753_out4_controls),\nSND_SOC_DAPM_PGA(\"Out 4\", WM8753_PWR3, 3, 0, NULL, 0),\nSND_SOC_DAPM_OUTPUT(\"OUT4\"),\nSND_SOC_DAPM_MIXER(\"Playback Mixer\", WM8753_PWR4, 3, 0,\n\t&wm8753_record_mixer_controls[0],\n\tARRAY_SIZE(wm8753_record_mixer_controls)),\nSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", WM8753_PWR2, 3, 0),\nSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", WM8753_PWR2, 2, 0),\nSND_SOC_DAPM_MUX(\"Capture Left Mixer\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_adc_mono_controls),\nSND_SOC_DAPM_MUX(\"Capture Right Mixer\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_adc_mono_controls),\nSND_SOC_DAPM_MUX(\"Capture Left Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_adc_left_controls),\nSND_SOC_DAPM_MUX(\"Capture Right Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_adc_right_controls),\nSND_SOC_DAPM_MUX(\"Mic Sidetone Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_mic_mux_controls),\nSND_SOC_DAPM_PGA(\"Left Capture Volume\", WM8753_PWR2, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Capture Volume\", WM8753_PWR2, 4, 0, NULL, 0),\nSND_SOC_DAPM_MIXER(\"ALC Mixer\", WM8753_PWR2, 6, 0,\n\t&wm8753_alc_mixer_controls[0], ARRAY_SIZE(wm8753_alc_mixer_controls)),\nSND_SOC_DAPM_MUX(\"Line Left Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_line_left_controls),\nSND_SOC_DAPM_MUX(\"Line Right Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_line_right_controls),\nSND_SOC_DAPM_MUX(\"Line Mono Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_line_mono_controls),\nSND_SOC_DAPM_MUX(\"Line Mixer\", WM8753_PWR2, 0, 0,\n\t&wm8753_line_mux_mix_controls),\nSND_SOC_DAPM_MUX(\"Rx Mixer\", WM8753_PWR2, 1, 0,\n\t&wm8753_rx_mux_mix_controls),\nSND_SOC_DAPM_PGA(\"Mic 1 Volume\", WM8753_PWR2, 8, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Mic 2 Volume\", WM8753_PWR2, 7, 0, NULL, 0),\nSND_SOC_DAPM_MUX(\"Mic Selection Mux\", SND_SOC_NOPM, 0, 0,\n\t&wm8753_mic_sel_mux_controls),\nSND_SOC_DAPM_INPUT(\"LINE1\"),\nSND_SOC_DAPM_INPUT(\"LINE2\"),\nSND_SOC_DAPM_INPUT(\"RXP\"),\nSND_SOC_DAPM_INPUT(\"RXN\"),\nSND_SOC_DAPM_INPUT(\"ACIN\"),\nSND_SOC_DAPM_OUTPUT(\"ACOP\"),\nSND_SOC_DAPM_INPUT(\"MIC1N\"),\nSND_SOC_DAPM_INPUT(\"MIC1\"),\nSND_SOC_DAPM_INPUT(\"MIC2N\"),\nSND_SOC_DAPM_INPUT(\"MIC2\"),\nSND_SOC_DAPM_VMID(\"VREF\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8753_dapm_routes[] = {\n\t \n\t{\"Left Mixer\", \"Left Playback Switch\", \"Left DAC\"},\n\t{\"Left Mixer\", \"Voice Playback Switch\", \"Voice DAC\"},\n\t{\"Left Mixer\", \"Sidetone Playback Switch\", \"Mic Sidetone Mux\"},\n\t{\"Left Mixer\", \"Bypass Playback Switch\", \"Line Left Mux\"},\n\n\t \n\t{\"Right Mixer\", \"Right Playback Switch\", \"Right DAC\"},\n\t{\"Right Mixer\", \"Voice Playback Switch\", \"Voice DAC\"},\n\t{\"Right Mixer\", \"Sidetone Playback Switch\", \"Mic Sidetone Mux\"},\n\t{\"Right Mixer\", \"Bypass Playback Switch\", \"Line Right Mux\"},\n\n\t \n\t{\"Mono Mixer\", \"Voice Playback Switch\", \"Voice DAC\"},\n\t{\"Mono Mixer\", \"Left Playback Switch\", \"Left DAC\"},\n\t{\"Mono Mixer\", \"Right Playback Switch\", \"Right DAC\"},\n\t{\"Mono Mixer\", \"Sidetone Playback Switch\", \"Mic Sidetone Mux\"},\n\t{\"Mono Mixer\", \"Bypass Playback Switch\", \"Line Mono Mux\"},\n\n\t \n\t{\"Left Out 1\", NULL, \"Left Mixer\"},\n\t{\"Left Out 2\", NULL, \"Left Mixer\"},\n\t{\"LOUT1\", NULL, \"Left Out 1\"},\n\t{\"LOUT2\", NULL, \"Left Out 2\"},\n\n\t \n\t{\"Right Out 1\", NULL, \"Right Mixer\"},\n\t{\"Right Out 2\", NULL, \"Right Mixer\"},\n\t{\"ROUT1\", NULL, \"Right Out 1\"},\n\t{\"ROUT2\", NULL, \"Right Out 2\"},\n\n\t \n\t{\"Mono Out 1\", NULL, \"Mono Mixer\"},\n\t{\"MONO1\", NULL, \"Mono Out 1\"},\n\n\t \n\t{\"Mono 2 Mux\", \"Left + Right\", \"Out3 Left + Right\"},\n\t{\"Mono 2 Mux\", \"Inverted Mono 1\", \"MONO1\"},\n\t{\"Mono 2 Mux\", \"Left\", \"Left Mixer\"},\n\t{\"Mono 2 Mux\", \"Right\", \"Right Mixer\"},\n\t{\"Mono Out 2\", NULL, \"Mono 2 Mux\"},\n\t{\"MONO2\", NULL, \"Mono Out 2\"},\n\n\t \n\t{\"Out3 Left + Right\", NULL, \"Left Mixer\"},\n\t{\"Out3 Left + Right\", NULL, \"Right Mixer\"},\n\t{\"Out3 Mux\", \"VREF\", \"VREF\"},\n\t{\"Out3 Mux\", \"Left + Right\", \"Out3 Left + Right\"},\n\t{\"Out3 Mux\", \"ROUT2\", \"ROUT2\"},\n\t{\"Out 3\", NULL, \"Out3 Mux\"},\n\t{\"OUT3\", NULL, \"Out 3\"},\n\n\t \n\t{\"Out4 Mux\", \"VREF\", \"VREF\"},\n\t{\"Out4 Mux\", \"Capture ST\", \"Playback Mixer\"},\n\t{\"Out4 Mux\", \"LOUT2\", \"LOUT2\"},\n\t{\"Out 4\", NULL, \"Out4 Mux\"},\n\t{\"OUT4\", NULL, \"Out 4\"},\n\n\t \n\t{\"Playback Mixer\", \"Left Capture Switch\", \"Left Mixer\"},\n\t{\"Playback Mixer\", \"Voice Capture Switch\", \"Mono Mixer\"},\n\t{\"Playback Mixer\", \"Right Capture Switch\", \"Right Mixer\"},\n\n\t \n\t{\"Mic Sidetone Mux\", \"Left PGA\", \"Left Capture Volume\"},\n\t{\"Mic Sidetone Mux\", \"Right PGA\", \"Right Capture Volume\"},\n\t{\"Mic Sidetone Mux\", \"Mic 1\", \"Mic 1 Volume\"},\n\t{\"Mic Sidetone Mux\", \"Mic 2\", \"Mic 2 Volume\"},\n\n\t \n\t{\"Capture Left Mux\", \"PGA\", \"Left Capture Volume\"},\n\t{\"Capture Left Mux\", \"Line or RXP-RXN\", \"Line Left Mux\"},\n\t{\"Capture Left Mux\", \"Line\", \"LINE1\"},\n\n\t \n\t{\"Capture Right Mux\", \"PGA\", \"Right Capture Volume\"},\n\t{\"Capture Right Mux\", \"Line or RXP-RXN\", \"Line Right Mux\"},\n\t{\"Capture Right Mux\", \"Sidetone\", \"Playback Mixer\"},\n\n\t \n\t{\"Capture Right Mixer\", \"Stereo\", \"Capture Right Mux\"},\n\t{\"Capture Left Mixer\", \"Stereo\", \"Capture Left Mux\"},\n\t{\"Capture Left Mixer\", \"Analogue Mix Left\", \"Capture Left Mux\"},\n\t{\"Capture Left Mixer\", \"Analogue Mix Left\", \"Capture Right Mux\"},\n\t{\"Capture Right Mixer\", \"Analogue Mix Right\", \"Capture Left Mux\"},\n\t{\"Capture Right Mixer\", \"Analogue Mix Right\", \"Capture Right Mux\"},\n\t{\"Capture Left Mixer\", \"Digital Mono Mix\", \"Capture Left Mux\"},\n\t{\"Capture Left Mixer\", \"Digital Mono Mix\", \"Capture Right Mux\"},\n\t{\"Capture Right Mixer\", \"Digital Mono Mix\", \"Capture Left Mux\"},\n\t{\"Capture Right Mixer\", \"Digital Mono Mix\", \"Capture Right Mux\"},\n\n\t \n\t{\"Left ADC\", NULL, \"Capture Left Mixer\"},\n\t{\"Right ADC\", NULL, \"Capture Right Mixer\"},\n\n\t \n\t{\"Left Capture Volume\", NULL, \"ACIN\"},\n\n\t \n\t{\"Right Capture Volume\", NULL, \"Mic 2 Volume\"},\n\n\t \n\t{\"ALC Mixer\", \"Line Capture Switch\", \"Line Mixer\"},\n\t{\"ALC Mixer\", \"Mic2 Capture Switch\", \"Mic 2 Volume\"},\n\t{\"ALC Mixer\", \"Mic1 Capture Switch\", \"Mic 1 Volume\"},\n\t{\"ALC Mixer\", \"Rx Capture Switch\", \"Rx Mixer\"},\n\n\t \n\t{\"Line Left Mux\", \"Line 1\", \"LINE1\"},\n\t{\"Line Left Mux\", \"Rx Mix\", \"Rx Mixer\"},\n\n\t \n\t{\"Line Right Mux\", \"Line 2\", \"LINE2\"},\n\t{\"Line Right Mux\", \"Rx Mix\", \"Rx Mixer\"},\n\n\t \n\t{\"Line Mono Mux\", \"Line Mix\", \"Line Mixer\"},\n\t{\"Line Mono Mux\", \"Rx Mix\", \"Rx Mixer\"},\n\n\t \n\t{\"Line Mixer\", \"Line 1 + 2\", \"LINE1\"},\n\t{\"Line Mixer\", \"Line 1 - 2\", \"LINE1\"},\n\t{\"Line Mixer\", \"Line 1 + 2\", \"LINE2\"},\n\t{\"Line Mixer\", \"Line 1 - 2\", \"LINE2\"},\n\t{\"Line Mixer\", \"Line 1\", \"LINE1\"},\n\t{\"Line Mixer\", \"Line 2\", \"LINE2\"},\n\n\t \n\t{\"Rx Mixer\", \"RXP - RXN\", \"RXP\"},\n\t{\"Rx Mixer\", \"RXP + RXN\", \"RXP\"},\n\t{\"Rx Mixer\", \"RXP - RXN\", \"RXN\"},\n\t{\"Rx Mixer\", \"RXP + RXN\", \"RXN\"},\n\t{\"Rx Mixer\", \"RXP\", \"RXP\"},\n\t{\"Rx Mixer\", \"RXN\", \"RXN\"},\n\n\t \n\t{\"Mic 1 Volume\", NULL, \"MIC1N\"},\n\t{\"Mic 1 Volume\", NULL, \"Mic Selection Mux\"},\n\n\t \n\t{\"Mic 2 Volume\", NULL, \"MIC2N\"},\n\t{\"Mic 2 Volume\", NULL, \"MIC2\"},\n\n\t \n\t{\"Mic Selection Mux\", \"Mic 1\", \"MIC1\"},\n\t{\"Mic Selection Mux\", \"Mic 2\", \"MIC2N\"},\n\t{\"Mic Selection Mux\", \"Mic 3\", \"MIC2\"},\n\n\t \n\t{\"ACOP\", NULL, \"ALC Mixer\"},\n};\n\n \nstruct _pll_div {\n\tu32 div2:1;\n\tu32 n:4;\n\tu32 k:24;\n};\n\n \n#define FIXED_PLL_SIZE ((1 << 22) * 10)\n\nstatic void pll_factors(struct _pll_div *pll_div, unsigned int target,\n\tunsigned int source)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\n\tNdiv = target / source;\n\tif (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\tpll_div->div2 = 1;\n\t\tNdiv = target / source;\n\t} else\n\t\tpll_div->div2 = 0;\n\n\tif ((Ndiv < 6) || (Ndiv > 12))\n\t\tprintk(KERN_WARNING\n\t\t\t\"wm8753: unsupported N = %u\\n\", Ndiv);\n\n\tpll_div->n = Ndiv;\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\t \n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tK /= 10;\n\n\tpll_div->k = K;\n}\n\nstatic int wm8753_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tu16 reg, enable;\n\tint offset;\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tif (pll_id < WM8753_PLL1 || pll_id > WM8753_PLL2)\n\t\treturn -ENODEV;\n\n\tif (pll_id == WM8753_PLL1) {\n\t\toffset = 0;\n\t\tenable = 0x10;\n\t\treg = snd_soc_component_read(component, WM8753_CLOCK) & 0xffef;\n\t} else {\n\t\toffset = 4;\n\t\tenable = 0x8;\n\t\treg = snd_soc_component_read(component, WM8753_CLOCK) & 0xfff7;\n\t}\n\n\tif (!freq_in || !freq_out) {\n\t\t \n\t\tsnd_soc_component_write(component, WM8753_PLL1CTL1 + offset, 0x0026);\n\t\tsnd_soc_component_write(component, WM8753_CLOCK, reg);\n\t\treturn 0;\n\t} else {\n\t\tu16 value = 0;\n\t\tstruct _pll_div pll_div;\n\n\t\tpll_factors(&pll_div, freq_out * 8, freq_in);\n\n\t\t \n\t\t \n\t\tvalue = (pll_div.n << 5) + ((pll_div.k & 0x3c0000) >> 18);\n\t\tsnd_soc_component_write(component, WM8753_PLL1CTL2 + offset, value);\n\n\t\t \n\t\tvalue = (pll_div.k & 0x03fe00) >> 9;\n\t\tsnd_soc_component_write(component, WM8753_PLL1CTL3 + offset, value);\n\n\t\t \n\t\tvalue = pll_div.k & 0x0001ff;\n\t\tsnd_soc_component_write(component, WM8753_PLL1CTL4 + offset, value);\n\n\t\t \n\t\tsnd_soc_component_write(component, WM8753_PLL1CTL1 + offset, 0x0027 |\n\t\t\t(pll_div.div2 << 3));\n\t\tsnd_soc_component_write(component, WM8753_CLOCK, reg | enable);\n\t}\n\treturn 0;\n}\n\nstruct _coeff_div {\n\tu32 mclk;\n\tu32 rate;\n\tu8 sr:5;\n\tu8 usb:1;\n};\n\n \nstatic const struct _coeff_div coeff_div[] = {\n\t \n\t{12288000, 8000, 0x6, 0x0},\n\t{11289600, 8000, 0x16, 0x0},\n\t{18432000, 8000, 0x7, 0x0},\n\t{16934400, 8000, 0x17, 0x0},\n\t{12000000, 8000, 0x6, 0x1},\n\n\t \n\t{11289600, 11025, 0x18, 0x0},\n\t{16934400, 11025, 0x19, 0x0},\n\t{12000000, 11025, 0x19, 0x1},\n\n\t \n\t{12288000, 16000, 0xa, 0x0},\n\t{18432000, 16000, 0xb, 0x0},\n\t{12000000, 16000, 0xa, 0x1},\n\n\t \n\t{11289600, 22050, 0x1a, 0x0},\n\t{16934400, 22050, 0x1b, 0x0},\n\t{12000000, 22050, 0x1b, 0x1},\n\n\t \n\t{12288000, 32000, 0xc, 0x0},\n\t{18432000, 32000, 0xd, 0x0},\n\t{12000000, 32000, 0xa, 0x1},\n\n\t \n\t{11289600, 44100, 0x10, 0x0},\n\t{16934400, 44100, 0x11, 0x0},\n\t{12000000, 44100, 0x11, 0x1},\n\n\t \n\t{12288000, 48000, 0x0, 0x0},\n\t{18432000, 48000, 0x1, 0x0},\n\t{12000000, 48000, 0x0, 0x1},\n\n\t \n\t{11289600, 88200, 0x1e, 0x0},\n\t{16934400, 88200, 0x1f, 0x0},\n\t{12000000, 88200, 0x1f, 0x1},\n\n\t \n\t{12288000, 96000, 0xe, 0x0},\n\t{18432000, 96000, 0xf, 0x0},\n\t{12000000, 96000, 0xe, 0x1},\n};\n\nstatic int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int wm8753_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq) {\n\tcase 11289600:\n\tcase 12000000:\n\tcase 12288000:\n\tcase 16934400:\n\tcase 18432000:\n\t\tif (clk_id == WM8753_MCLK) {\n\t\t\twm8753->sysclk = freq;\n\t\t\treturn 0;\n\t\t} else if (clk_id == WM8753_PCMCLK) {\n\t\t\twm8753->pcmclk = freq;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int wm8753_vdac_adc_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 voice = snd_soc_component_read(component, WM8753_PCM) & 0x01ec;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tvoice |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tvoice |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tvoice |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tvoice |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_PCM, voice);\n\treturn 0;\n}\n\n \nstatic int wm8753_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tu16 voice = snd_soc_component_read(component, WM8753_PCM) & 0x01f3;\n\tu16 srate = snd_soc_component_read(component, WM8753_SRATE1) & 0x017f;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tvoice |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\tvoice |= 0x0008;\n\t\tbreak;\n\tcase 32:\n\t\tvoice |= 0x000c;\n\t\tbreak;\n\t}\n\n\t \n\tif (params_rate(params) * 384 == wm8753->pcmclk)\n\t\tsrate |= 0x80;\n\tsnd_soc_component_write(component, WM8753_SRATE1, srate);\n\n\tsnd_soc_component_write(component, WM8753_PCM, voice);\n\treturn 0;\n}\n\n \nstatic int wm8753_pcm_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 voice, ioctl;\n\n\tvoice = snd_soc_component_read(component, WM8753_PCM) & 0x011f;\n\tioctl = snd_soc_component_read(component, WM8753_IOCTL) & 0x015d;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tioctl |= 0x2;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\tvoice |= 0x0040;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tvoice |= 0x0080;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tvoice &= ~0x0010;\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\tvoice |= 0x0090;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\tvoice |= 0x0080;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\tvoice |= 0x0010;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_PCM, voice);\n\tsnd_soc_component_write(component, WM8753_IOCTL, ioctl);\n\treturn 0;\n}\n\nstatic int wm8753_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\tint div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 reg;\n\n\tswitch (div_id) {\n\tcase WM8753_PCMDIV:\n\t\treg = snd_soc_component_read(component, WM8753_CLOCK) & 0x003f;\n\t\tsnd_soc_component_write(component, WM8753_CLOCK, reg | div);\n\t\tbreak;\n\tcase WM8753_BCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8753_SRATE2) & 0x01c7;\n\t\tsnd_soc_component_write(component, WM8753_SRATE2, reg | div);\n\t\tbreak;\n\tcase WM8753_VXCLKDIV:\n\t\treg = snd_soc_component_read(component, WM8753_SRATE2) & 0x003f;\n\t\tsnd_soc_component_write(component, WM8753_SRATE2, reg | div);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int wm8753_hdac_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 hifi = snd_soc_component_read(component, WM8753_HIFI) & 0x01e0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\thifi |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\thifi |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\thifi |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\thifi |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_HIFI, hifi);\n\treturn 0;\n}\n\n \nstatic int wm8753_i2s_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 ioctl, hifi;\n\n\thifi = snd_soc_component_read(component, WM8753_HIFI) & 0x013f;\n\tioctl = snd_soc_component_read(component, WM8753_IOCTL) & 0x00ae;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tioctl |= 0x1;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\thifi |= 0x0040;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\thifi |= 0x0080;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\thifi &= ~0x0010;\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\thifi |= 0x0090;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\thifi |= 0x0080;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\thifi |= 0x0010;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_HIFI, hifi);\n\tsnd_soc_component_write(component, WM8753_IOCTL, ioctl);\n\treturn 0;\n}\n\n \nstatic int wm8753_i2s_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tu16 srate = snd_soc_component_read(component, WM8753_SRATE1) & 0x01c0;\n\tu16 hifi = snd_soc_component_read(component, WM8753_HIFI) & 0x01f3;\n\tint coeff;\n\n\t \n\tcoeff = get_coeff(wm8753->sysclk, params_rate(params));\n\tif (coeff < 0) {\n\t\tprintk(KERN_ERR \"wm8753 invalid MCLK or rate\\n\");\n\t\treturn coeff;\n\t}\n\tsnd_soc_component_write(component, WM8753_SRATE1, srate | (coeff_div[coeff].sr << 1) |\n\t\tcoeff_div[coeff].usb);\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\thifi |= 0x0004;\n\t\tbreak;\n\tcase 24:\n\t\thifi |= 0x0008;\n\t\tbreak;\n\tcase 32:\n\t\thifi |= 0x000c;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_HIFI, hifi);\n\treturn 0;\n}\n\nstatic int wm8753_mode1v_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 clock;\n\n\t \n\tclock = snd_soc_component_read(component, WM8753_CLOCK) & 0xfffb;\n\tsnd_soc_component_write(component, WM8753_CLOCK, clock);\n\n\treturn wm8753_vdac_adc_set_dai_fmt(component, fmt);\n}\n\nstatic int wm8753_mode1h_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\treturn wm8753_hdac_set_dai_fmt(component, fmt);\n}\n\nstatic int wm8753_mode2_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 clock;\n\n\t \n\tclock = snd_soc_component_read(component, WM8753_CLOCK) & 0xfffb;\n\tsnd_soc_component_write(component, WM8753_CLOCK, clock);\n\n\treturn wm8753_vdac_adc_set_dai_fmt(component, fmt);\n}\n\nstatic int wm8753_mode3_4_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 clock;\n\n\t \n\tclock = snd_soc_component_read(component, WM8753_CLOCK) & 0xfffb;\n\tsnd_soc_component_write(component, WM8753_CLOCK, clock | 0x4);\n\n\tif (wm8753_hdac_set_dai_fmt(component, fmt) < 0)\n\t\treturn -EINVAL;\n\treturn wm8753_vdac_adc_set_dai_fmt(component, fmt);\n}\n\nstatic int wm8753_hifi_write_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (wm8753->dai_func) {\n\tcase 0:\n\t\tret = wm8753_mode1h_set_dai_fmt(component, fmt);\n\t\tbreak;\n\tcase 1:\n\t\tret = wm8753_mode2_set_dai_fmt(component, fmt);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tret = wm8753_mode3_4_set_dai_fmt(component, fmt);\n\t\tbreak;\n\tdefault:\n\t\t break;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\treturn wm8753_i2s_set_dai_fmt(component, fmt);\n}\n\nstatic int wm8753_hifi_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\twm8753->hifi_fmt = fmt;\n\n\treturn wm8753_hifi_write_dai_fmt(component, fmt);\n};\n\nstatic int wm8753_voice_write_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tif (wm8753->dai_func != 0)\n\t\treturn 0;\n\n\tret = wm8753_mode1v_set_dai_fmt(component, fmt);\n\tif (ret)\n\t\treturn ret;\n\tret = wm8753_pcm_set_dai_fmt(component, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n};\n\nstatic int wm8753_voice_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\twm8753->voice_fmt = fmt;\n\n\treturn wm8753_voice_write_dai_fmt(component, fmt);\n};\n\nstatic int wm8753_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, WM8753_DAC) & 0xfff7;\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\t \n\tif (mute && wm8753->dai_func == 1) {\n\t\tif (!snd_soc_component_active(component))\n\t\t\tsnd_soc_component_write(component, WM8753_DAC, mute_reg | 0x8);\n\t} else {\n\t\tif (mute)\n\t\t\tsnd_soc_component_write(component, WM8753_DAC, mute_reg | 0x8);\n\t\telse\n\t\t\tsnd_soc_component_write(component, WM8753_DAC, mute_reg);\n\t}\n\n\treturn 0;\n}\n\nstatic void wm8753_charge_work(struct work_struct *work)\n{\n\tstruct wm8753_priv *wm8753 =\n\t\tcontainer_of(work, struct wm8753_priv, charge_work.work);\n\n\t \n\tregmap_update_bits(wm8753->regmap, WM8753_PWR1, 0x0180, 0x0100);\n}\n\nstatic int wm8753_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tu16 pwr_reg = snd_soc_component_read(component, WM8753_PWR1) & 0xfe3e;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\t \n\t\tsnd_soc_component_write(component, WM8753_PWR1, pwr_reg | 0x00c0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tflush_delayed_work(&wm8753->charge_work);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8753_PWR1, pwr_reg | 0x01c1);\n\t\t\tschedule_delayed_work(&wm8753->charge_work,\n\t\t\t\tmsecs_to_jiffies(caps_charge));\n\t\t} else {\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8753_PWR1, pwr_reg | 0x0141);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tcancel_delayed_work_sync(&wm8753->charge_work);\n\t\tsnd_soc_component_write(component, WM8753_PWR1, 0x0001);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8753_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 |\\\n\t\tSNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)\n\n#define WM8753_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\tSNDRV_PCM_FMTBIT_S24_LE)\n\n \nstatic const struct snd_soc_dai_ops wm8753_dai_ops_hifi_mode = {\n\t.hw_params\t= wm8753_i2s_hw_params,\n\t.mute_stream\t= wm8753_mute,\n\t.set_fmt\t= wm8753_hifi_set_dai_fmt,\n\t.set_clkdiv\t= wm8753_set_dai_clkdiv,\n\t.set_pll\t= wm8753_set_dai_pll,\n\t.set_sysclk\t= wm8753_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops wm8753_dai_ops_voice_mode = {\n\t.hw_params\t= wm8753_pcm_hw_params,\n\t.mute_stream\t= wm8753_mute,\n\t.set_fmt\t= wm8753_voice_set_dai_fmt,\n\t.set_clkdiv\t= wm8753_set_dai_clkdiv,\n\t.set_pll\t= wm8753_set_dai_pll,\n\t.set_sysclk\t= wm8753_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8753_dai[] = {\n \n{\t.name = \"wm8753-hifi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8753_RATES,\n\t\t.formats = WM8753_FORMATS\n\t},\n\t.capture = {  \n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8753_RATES,\n\t\t.formats = WM8753_FORMATS\n\t},\n\t.ops = &wm8753_dai_ops_hifi_mode,\n},\n \n{\t.name = \"wm8753-voice\",\n\t.playback = {\n\t\t.stream_name = \"Voice Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = WM8753_RATES,\n\t\t.formats = WM8753_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = WM8753_RATES,\n\t\t.formats = WM8753_FORMATS,\n\t},\n\t.ops = &wm8753_dai_ops_voice_mode,\n},\n};\n\nstatic int wm8753_resume(struct snd_soc_component *component)\n{\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\n\tregcache_sync(wm8753->regmap);\n\n\treturn 0;\n}\n\nstatic int wm8753_probe(struct snd_soc_component *component)\n{\n\tstruct wm8753_priv *wm8753 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tINIT_DELAYED_WORK(&wm8753->charge_work, wm8753_charge_work);\n\n\tret = wm8753_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8753->dai_func = 0;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8753_LDAC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_RDAC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_LADC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_RADC, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_LOUT1V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_ROUT1V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_LOUT2V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_ROUT2V, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_LINVOL, 0x0100, 0x0100);\n\tsnd_soc_component_update_bits(component, WM8753_RINVOL, 0x0100, 0x0100);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8753 = {\n\t.probe\t\t\t= wm8753_probe,\n\t.resume\t\t\t= wm8753_resume,\n\t.set_bias_level\t\t= wm8753_set_bias_level,\n\t.controls\t\t= wm8753_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8753_snd_controls),\n\t.dapm_widgets\t\t= wm8753_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8753_dapm_widgets),\n\t.dapm_routes\t\t= wm8753_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8753_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8753_of_match[] = {\n\t{ .compatible = \"wlf,wm8753\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8753_of_match);\n\nstatic const struct regmap_config wm8753_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.max_register = WM8753_ADCTL2,\n\t.volatile_reg = wm8753_volatile,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8753_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8753_reg_defaults),\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8753_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8753_priv *wm8753;\n\tint ret;\n\n\twm8753 = devm_kzalloc(&spi->dev, sizeof(struct wm8753_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8753 == NULL)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, wm8753);\n\n\twm8753->regmap = devm_regmap_init_spi(spi, &wm8753_regmap);\n\tif (IS_ERR(wm8753->regmap)) {\n\t\tret = PTR_ERR(wm8753->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&spi->dev, &soc_component_dev_wm8753,\n\t\t\t\t     wm8753_dai, ARRAY_SIZE(wm8753_dai));\n\tif (ret != 0)\n\t\tdev_err(&spi->dev, \"Failed to register CODEC: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic struct spi_driver wm8753_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8753\",\n\t\t.of_match_table = wm8753_of_match,\n\t},\n\t.probe\t\t= wm8753_spi_probe,\n};\n#endif  \n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8753_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8753_priv *wm8753;\n\tint ret;\n\n\twm8753 = devm_kzalloc(&i2c->dev, sizeof(struct wm8753_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8753 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, wm8753);\n\n\twm8753->regmap = devm_regmap_init_i2c(i2c, &wm8753_regmap);\n\tif (IS_ERR(wm8753->regmap)) {\n\t\tret = PTR_ERR(wm8753->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev, &soc_component_dev_wm8753,\n\t\t\t\t     wm8753_dai, ARRAY_SIZE(wm8753_dai));\n\tif (ret != 0)\n\t\tdev_err(&i2c->dev, \"Failed to register CODEC: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8753_i2c_id[] = {\n\t{ \"wm8753\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8753_i2c_id);\n\nstatic struct i2c_driver wm8753_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8753\",\n\t\t.of_match_table = wm8753_of_match,\n\t},\n\t.probe = wm8753_i2c_probe,\n\t.id_table = wm8753_i2c_id,\n};\n#endif\n\nstatic int __init wm8753_modinit(void)\n{\n\tint ret = 0;\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8753_i2c_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8753 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8753_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8753 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\nmodule_init(wm8753_modinit);\n\nstatic void __exit wm8753_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8753_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8753_spi_driver);\n#endif\n}\nmodule_exit(wm8753_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8753 driver\");\nMODULE_AUTHOR(\"Liam Girdwood\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}