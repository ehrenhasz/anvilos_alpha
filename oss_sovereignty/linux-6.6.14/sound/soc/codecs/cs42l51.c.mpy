{
  "module_name": "cs42l51.c",
  "hash_id": "a92e1aa923e0751e2b964b6eef29b17d7bd299fdf0a3adee7a67561935cd7115",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l51.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"cs42l51.h\"\n\nenum master_slave_mode {\n\tMODE_SLAVE,\n\tMODE_SLAVE_AUTO,\n\tMODE_MASTER,\n};\n\nstatic const char * const cs42l51_supply_names[] = {\n\t\"VL\",\n\t\"VD\",\n\t\"VA\",\n\t\"VAHP\",\n};\n\nstruct cs42l51_private {\n\tunsigned int mclk;\n\tstruct clk *mclk_handle;\n\tunsigned int audio_mode;\t \n\tenum master_slave_mode func;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(cs42l51_supply_names)];\n\tstruct gpio_desc *reset_gpio;\n\tstruct regmap *regmap;\n};\n\n#define CS42L51_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\t\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic int cs42l51_get_chan_mix(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned long value = snd_soc_component_read(component, CS42L51_PCM_MIXER)&3;\n\n\tswitch (value) {\n\tdefault:\n\tcase 0:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\t \n\tcase 1:\n\tcase 2:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tcase 3:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define CHAN_MIX_NORMAL\t0x00\n#define CHAN_MIX_BOTH\t0x55\n#define CHAN_MIX_SWAP\t0xFF\n\nstatic int cs42l51_set_chan_mix(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned char val;\n\n\tswitch (ucontrol->value.enumerated.item[0]) {\n\tdefault:\n\tcase 0:\n\t\tval = CHAN_MIX_NORMAL;\n\t\tbreak;\n\tcase 1:\n\t\tval = CHAN_MIX_BOTH;\n\t\tbreak;\n\tcase 2:\n\t\tval = CHAN_MIX_SWAP;\n\t\tbreak;\n\t}\n\n\tsnd_soc_component_write(component, CS42L51_PCM_MIXER, val);\n\n\treturn 1;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(adc_pcm_tlv, -5150, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(tone_tlv, -1050, 150, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(aout_tlv, -10200, 50, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, 1600, 1600, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_boost_tlv, 2000, 2000, 0);\nstatic const char *chan_mix[] = {\n\t\"L R\",\n\t\"L+R\",\n\t\"R L\",\n};\n\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, -300, 50, 0);\nstatic const DECLARE_TLV_DB_SCALE(adc_att_tlv, -9600, 100, 0);\n\nstatic SOC_ENUM_SINGLE_EXT_DECL(cs42l51_chan_mix, chan_mix);\n\nstatic const struct snd_kcontrol_new cs42l51_snd_controls[] = {\n\tSOC_DOUBLE_R_SX_TLV(\"PCM Playback Volume\",\n\t\t\tCS42L51_PCMA_VOL, CS42L51_PCMB_VOL,\n\t\t\t0, 0x19, 0x7F, adc_pcm_tlv),\n\tSOC_DOUBLE_R(\"PCM Playback Switch\",\n\t\t\tCS42L51_PCMA_VOL, CS42L51_PCMB_VOL, 7, 1, 1),\n\tSOC_DOUBLE_R_SX_TLV(\"Analog Playback Volume\",\n\t\t\tCS42L51_AOUTA_VOL, CS42L51_AOUTB_VOL,\n\t\t\t0, 0x34, 0xE4, aout_tlv),\n\tSOC_DOUBLE_R_SX_TLV(\"ADC Mixer Volume\",\n\t\t\tCS42L51_ADCA_VOL, CS42L51_ADCB_VOL,\n\t\t\t0, 0x19, 0x7F, adc_pcm_tlv),\n\tSOC_DOUBLE_R(\"ADC Mixer Switch\",\n\t\t\tCS42L51_ADCA_VOL, CS42L51_ADCB_VOL, 7, 1, 1),\n\tSOC_DOUBLE_R_SX_TLV(\"ADC Attenuator Volume\",\n\t\t\tCS42L51_ADCA_ATT, CS42L51_ADCB_ATT,\n\t\t\t0, 0xA0, 96, adc_att_tlv),\n\tSOC_DOUBLE_R_SX_TLV(\"PGA Volume\",\n\t\t\tCS42L51_ALC_PGA_CTL, CS42L51_ALC_PGB_CTL,\n\t\t\t0, 0x1A, 30, pga_tlv),\n\tSOC_SINGLE(\"Playback Deemphasis Switch\", CS42L51_DAC_CTL, 3, 1, 0),\n\tSOC_SINGLE(\"Auto-Mute Switch\", CS42L51_DAC_CTL, 2, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp Switch\", CS42L51_DAC_CTL, 1, 1, 0),\n\tSOC_SINGLE(\"Zero Cross Switch\", CS42L51_DAC_CTL, 0, 0, 0),\n\tSOC_DOUBLE_TLV(\"Mic Boost Volume\",\n\t\t\tCS42L51_MIC_CTL, 0, 1, 1, 0, boost_tlv),\n\tSOC_DOUBLE_TLV(\"ADC Boost Volume\",\n\t\t       CS42L51_MIC_CTL, 5, 6, 1, 0, adc_boost_tlv),\n\tSOC_SINGLE_TLV(\"Bass Volume\", CS42L51_TONE_CTL, 0, 0xf, 1, tone_tlv),\n\tSOC_SINGLE_TLV(\"Treble Volume\", CS42L51_TONE_CTL, 4, 0xf, 1, tone_tlv),\n\tSOC_ENUM_EXT(\"PCM channel mixer\",\n\t\t\tcs42l51_chan_mix,\n\t\t\tcs42l51_get_chan_mix, cs42l51_set_chan_mix),\n};\n\n \nstatic int cs42l51_pdn_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tsnd_soc_component_update_bits(component, CS42L51_POWER_CTL1,\n\t\t\t\t    CS42L51_POWER_CTL1_PDN,\n\t\t\t\t    CS42L51_POWER_CTL1_PDN);\n\t\tbreak;\n\tdefault:\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, CS42L51_POWER_CTL1,\n\t\t\t\t    CS42L51_POWER_CTL1_PDN, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *cs42l51_dac_names[] = {\"Direct PCM\",\n\t\"DSP PCM\", \"ADC\"};\nstatic SOC_ENUM_SINGLE_DECL(cs42l51_dac_mux_enum,\n\t\t\t    CS42L51_DAC_CTL, 6, cs42l51_dac_names);\nstatic const struct snd_kcontrol_new cs42l51_dac_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", cs42l51_dac_mux_enum);\n\nstatic const char *cs42l51_adcl_names[] = {\"AIN1 Left\", \"AIN2 Left\",\n\t\"MIC Left\", \"MIC+preamp Left\"};\nstatic SOC_ENUM_SINGLE_DECL(cs42l51_adcl_mux_enum,\n\t\t\t    CS42L51_ADC_INPUT, 4, cs42l51_adcl_names);\nstatic const struct snd_kcontrol_new cs42l51_adcl_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", cs42l51_adcl_mux_enum);\n\nstatic const char *cs42l51_adcr_names[] = {\"AIN1 Right\", \"AIN2 Right\",\n\t\"MIC Right\", \"MIC+preamp Right\"};\nstatic SOC_ENUM_SINGLE_DECL(cs42l51_adcr_mux_enum,\n\t\t\t    CS42L51_ADC_INPUT, 6, cs42l51_adcr_names);\nstatic const struct snd_kcontrol_new cs42l51_adcr_mux_controls =\n\tSOC_DAPM_ENUM(\"Route\", cs42l51_adcr_mux_enum);\n\nstatic const struct snd_soc_dapm_widget cs42l51_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", CS42L51_MIC_POWER_CTL, 1, 1, NULL,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Left PGA\", CS42L51_POWER_CTL1, 3, 1, NULL, 0,\n\t\tcs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_PGA_E(\"Right PGA\", CS42L51_POWER_CTL1, 4, 1, NULL, 0,\n\t\tcs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_ADC_E(\"Left ADC\", \"Left HiFi Capture\",\n\t\tCS42L51_POWER_CTL1, 1, 1,\n\t\tcs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_ADC_E(\"Right ADC\", \"Right HiFi Capture\",\n\t\tCS42L51_POWER_CTL1, 2, 1,\n\t\tcs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"Left DAC\", NULL, CS42L51_POWER_CTL1, 5, 1,\n\t\t\t   cs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\tSND_SOC_DAPM_DAC_E(\"Right DAC\", NULL, CS42L51_POWER_CTL1, 6, 1,\n\t\t\t   cs42l51_pdn_event, SND_SOC_DAPM_PRE_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"AIN1L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN1R\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2L\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2R\"),\n\tSND_SOC_DAPM_INPUT(\"MICL\"),\n\tSND_SOC_DAPM_INPUT(\"MICR\"),\n\n\tSND_SOC_DAPM_MIXER(\"Mic Preamp Left\",\n\t\tCS42L51_MIC_POWER_CTL, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Mic Preamp Right\",\n\t\tCS42L51_MIC_POWER_CTL, 3, 1, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"DAC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&cs42l51_dac_mux_controls),\n\tSND_SOC_DAPM_MUX(\"PGA-ADC Mux Left\", SND_SOC_NOPM, 0, 0,\n\t\t&cs42l51_adcl_mux_controls),\n\tSND_SOC_DAPM_MUX(\"PGA-ADC Mux Right\", SND_SOC_NOPM, 0, 0,\n\t\t&cs42l51_adcr_mux_controls),\n};\n\nstatic int mclk_event(struct snd_soc_dapm_widget *w,\n\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *comp = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs42l51_private *cs42l51 = snd_soc_component_get_drvdata(comp);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\treturn clk_prepare_enable(cs42l51->mclk_handle);\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tmsleep(20);\n\t\tclk_disable_unprepare(cs42l51->mclk_handle);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget cs42l51_dapm_mclk_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"MCLK\", SND_SOC_NOPM, 0, 0, mclk_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n};\n\nstatic const struct snd_soc_dapm_route cs42l51_routes[] = {\n\t{\"HPL\", NULL, \"Left DAC\"},\n\t{\"HPR\", NULL, \"Right DAC\"},\n\n\t{\"Right DAC\", NULL, \"DAC Mux\"},\n\t{\"Left DAC\", NULL, \"DAC Mux\"},\n\n\t{\"DAC Mux\", \"Direct PCM\", \"Playback\"},\n\t{\"DAC Mux\", \"DSP PCM\", \"Playback\"},\n\n\t{\"Left ADC\", NULL, \"Left PGA\"},\n\t{\"Right ADC\", NULL, \"Right PGA\"},\n\n\t{\"Mic Preamp Left\",  NULL,  \"MICL\"},\n\t{\"Mic Preamp Right\", NULL,  \"MICR\"},\n\n\t{\"PGA-ADC Mux Left\",  \"AIN1 Left\",        \"AIN1L\" },\n\t{\"PGA-ADC Mux Left\",  \"AIN2 Left\",        \"AIN2L\" },\n\t{\"PGA-ADC Mux Left\",  \"MIC Left\",         \"MICL\"  },\n\t{\"PGA-ADC Mux Left\",  \"MIC+preamp Left\",  \"Mic Preamp Left\" },\n\t{\"PGA-ADC Mux Right\", \"AIN1 Right\",       \"AIN1R\" },\n\t{\"PGA-ADC Mux Right\", \"AIN2 Right\",       \"AIN2R\" },\n\t{\"PGA-ADC Mux Right\", \"MIC Right\",        \"MICR\" },\n\t{\"PGA-ADC Mux Right\", \"MIC+preamp Right\", \"Mic Preamp Right\" },\n\n\t{\"Left PGA\", NULL, \"PGA-ADC Mux Left\"},\n\t{\"Right PGA\", NULL, \"PGA-ADC Mux Right\"},\n};\n\nstatic int cs42l51_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l51_private *cs42l51 = snd_soc_component_get_drvdata(component);\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcs42l51->audio_mode = format & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs42l51->func = MODE_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs42l51->func = MODE_SLAVE_AUTO;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct cs42l51_ratios {\n\tunsigned int ratio;\n\tunsigned char speed_mode;\n\tunsigned char mclk;\n};\n\nstatic struct cs42l51_ratios slave_ratios[] = {\n\t{  512, CS42L51_QSM_MODE, 0 }, {  768, CS42L51_QSM_MODE, 0 },\n\t{ 1024, CS42L51_QSM_MODE, 0 }, { 1536, CS42L51_QSM_MODE, 0 },\n\t{ 2048, CS42L51_QSM_MODE, 0 }, { 3072, CS42L51_QSM_MODE, 0 },\n\t{  256, CS42L51_HSM_MODE, 0 }, {  384, CS42L51_HSM_MODE, 0 },\n\t{  512, CS42L51_HSM_MODE, 0 }, {  768, CS42L51_HSM_MODE, 0 },\n\t{ 1024, CS42L51_HSM_MODE, 0 }, { 1536, CS42L51_HSM_MODE, 0 },\n\t{  128, CS42L51_SSM_MODE, 0 }, {  192, CS42L51_SSM_MODE, 0 },\n\t{  256, CS42L51_SSM_MODE, 0 }, {  384, CS42L51_SSM_MODE, 0 },\n\t{  512, CS42L51_SSM_MODE, 0 }, {  768, CS42L51_SSM_MODE, 0 },\n\t{  128, CS42L51_DSM_MODE, 0 }, {  192, CS42L51_DSM_MODE, 0 },\n\t{  256, CS42L51_DSM_MODE, 0 }, {  384, CS42L51_DSM_MODE, 0 },\n};\n\nstatic struct cs42l51_ratios slave_auto_ratios[] = {\n\t{ 1024, CS42L51_QSM_MODE, 0 }, { 1536, CS42L51_QSM_MODE, 0 },\n\t{ 2048, CS42L51_QSM_MODE, 1 }, { 3072, CS42L51_QSM_MODE, 1 },\n\t{  512, CS42L51_HSM_MODE, 0 }, {  768, CS42L51_HSM_MODE, 0 },\n\t{ 1024, CS42L51_HSM_MODE, 1 }, { 1536, CS42L51_HSM_MODE, 1 },\n\t{  256, CS42L51_SSM_MODE, 0 }, {  384, CS42L51_SSM_MODE, 0 },\n\t{  512, CS42L51_SSM_MODE, 1 }, {  768, CS42L51_SSM_MODE, 1 },\n\t{  128, CS42L51_DSM_MODE, 0 }, {  192, CS42L51_DSM_MODE, 0 },\n\t{  256, CS42L51_DSM_MODE, 1 }, {  384, CS42L51_DSM_MODE, 1 },\n};\n\n \nstatic struct cs42l51_ratios master_ratios[] = {\n\t{ 128, CS42L51_SSM_MODE, 0 }, { 256, CS42L51_SSM_MODE, 1 },\n};\n\nstatic int cs42l51_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs42l51_private *cs42l51 = snd_soc_component_get_drvdata(component);\n\n\tcs42l51->mclk = freq;\n\treturn 0;\n}\n\nstatic int cs42l51_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs42l51_private *cs42l51 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tunsigned int i;\n\tunsigned int rate;\n\tunsigned int ratio;\n\tstruct cs42l51_ratios *ratios = NULL;\n\tint nr_ratios = 0;\n\tint intf_ctl, power_ctl, fmt, mode;\n\n\tswitch (cs42l51->func) {\n\tcase MODE_MASTER:\n\t\tratios = master_ratios;\n\t\tnr_ratios = ARRAY_SIZE(master_ratios);\n\t\tbreak;\n\tcase MODE_SLAVE:\n\t\tratios = slave_ratios;\n\t\tnr_ratios = ARRAY_SIZE(slave_ratios);\n\t\tbreak;\n\tcase MODE_SLAVE_AUTO:\n\t\tratios = slave_auto_ratios;\n\t\tnr_ratios = ARRAY_SIZE(slave_auto_ratios);\n\t\tbreak;\n\t}\n\n\t \n\trate = params_rate(params);      \n\tratio = cs42l51->mclk / rate;     \n\tfor (i = 0; i < nr_ratios; i++) {\n\t\tif (ratios[i].ratio == ratio)\n\t\t\tbreak;\n\t}\n\n\tif (i == nr_ratios) {\n\t\t \n\t\tdev_err(component->dev, \"could not find matching ratio\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tintf_ctl = snd_soc_component_read(component, CS42L51_INTF_CTL);\n\tpower_ctl = snd_soc_component_read(component, CS42L51_MIC_POWER_CTL);\n\n\tintf_ctl &= ~(CS42L51_INTF_CTL_MASTER | CS42L51_INTF_CTL_ADC_I2S\n\t\t\t| CS42L51_INTF_CTL_DAC_FORMAT(7));\n\tpower_ctl &= ~(CS42L51_MIC_POWER_CTL_SPEED(3)\n\t\t\t| CS42L51_MIC_POWER_CTL_MCLK_DIV2);\n\n\tswitch (cs42l51->func) {\n\tcase MODE_MASTER:\n\t\tintf_ctl |= CS42L51_INTF_CTL_MASTER;\n\t\tmode = ratios[i].speed_mode;\n\t\t \n\t\tif (rate > 50000)\n\t\t\tmode = CS42L51_DSM_MODE;\n\t\tpower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(mode);\n\t\t \n\t\tpower_ctl &= ~CS42L51_MIC_POWER_CTL_AUTO;\n\t\tbreak;\n\tcase MODE_SLAVE:\n\t\tpower_ctl |= CS42L51_MIC_POWER_CTL_SPEED(ratios[i].speed_mode);\n\t\tbreak;\n\tcase MODE_SLAVE_AUTO:\n\t\tpower_ctl |= CS42L51_MIC_POWER_CTL_AUTO;\n\t\tbreak;\n\t}\n\n\tswitch (cs42l51->audio_mode) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tintf_ctl |= CS42L51_INTF_CTL_ADC_I2S;\n\t\tintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_I2S);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(CS42L51_DAC_DIF_LJ24);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tfmt = CS42L51_DAC_DIF_RJ16;\n\t\t\tbreak;\n\t\tcase 18:\n\t\t\tfmt = CS42L51_DAC_DIF_RJ18;\n\t\t\tbreak;\n\t\tcase 20:\n\t\t\tfmt = CS42L51_DAC_DIF_RJ20;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tfmt = CS42L51_DAC_DIF_RJ24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"unknown format\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tintf_ctl |= CS42L51_INTF_CTL_DAC_FORMAT(fmt);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unknown format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ratios[i].mclk)\n\t\tpower_ctl |= CS42L51_MIC_POWER_CTL_MCLK_DIV2;\n\n\tret = snd_soc_component_write(component, CS42L51_INTF_CTL, intf_ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = snd_soc_component_write(component, CS42L51_MIC_POWER_CTL, power_ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cs42l51_dai_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tint reg;\n\tint mask = CS42L51_DAC_OUT_CTL_DACA_MUTE|CS42L51_DAC_OUT_CTL_DACB_MUTE;\n\n\treg = snd_soc_component_read(component, CS42L51_DAC_OUT_CTL);\n\n\tif (mute)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\n\treturn snd_soc_component_write(component, CS42L51_DAC_OUT_CTL, reg);\n}\n\nstatic int cs42l51_of_xlate_dai_id(struct snd_soc_component *component,\n\t\t\t\t   struct device_node *endpoint)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs42l51_dai_ops = {\n\t.hw_params      = cs42l51_hw_params,\n\t.set_sysclk     = cs42l51_set_dai_sysclk,\n\t.set_fmt        = cs42l51_set_dai_fmt,\n\t.mute_stream    = cs42l51_dai_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cs42l51_dai = {\n\t.name = \"cs42l51-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = CS42L51_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = CS42L51_FORMATS,\n\t},\n\t.ops = &cs42l51_dai_ops,\n};\n\nstatic int cs42l51_component_probe(struct snd_soc_component *component)\n{\n\tint ret, reg;\n\tstruct snd_soc_dapm_context *dapm;\n\tstruct cs42l51_private *cs42l51;\n\n\tcs42l51 = snd_soc_component_get_drvdata(component);\n\tdapm = snd_soc_component_get_dapm(component);\n\n\tif (cs42l51->mclk_handle)\n\t\tsnd_soc_dapm_new_controls(dapm, cs42l51_dapm_mclk_widgets, 1);\n\n\t \n\treg = CS42L51_DAC_CTL_DATA_SEL(1)\n\t\t| CS42L51_DAC_CTL_AMUTE | CS42L51_DAC_CTL_DACSZ(0);\n\tret = snd_soc_component_write(component, CS42L51_DAC_CTL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_device_cs42l51 = {\n\t.probe\t\t\t= cs42l51_component_probe,\n\t.controls\t\t= cs42l51_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs42l51_snd_controls),\n\t.dapm_widgets\t\t= cs42l51_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs42l51_dapm_widgets),\n\t.dapm_routes\t\t= cs42l51_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs42l51_routes),\n\t.of_xlate_dai_id\t= cs42l51_of_xlate_dai_id,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic bool cs42l51_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L51_POWER_CTL1:\n\tcase CS42L51_MIC_POWER_CTL:\n\tcase CS42L51_INTF_CTL:\n\tcase CS42L51_MIC_CTL:\n\tcase CS42L51_ADC_CTL:\n\tcase CS42L51_ADC_INPUT:\n\tcase CS42L51_DAC_OUT_CTL:\n\tcase CS42L51_DAC_CTL:\n\tcase CS42L51_ALC_PGA_CTL:\n\tcase CS42L51_ALC_PGB_CTL:\n\tcase CS42L51_ADCA_ATT:\n\tcase CS42L51_ADCB_ATT:\n\tcase CS42L51_ADCA_VOL:\n\tcase CS42L51_ADCB_VOL:\n\tcase CS42L51_PCMA_VOL:\n\tcase CS42L51_PCMB_VOL:\n\tcase CS42L51_BEEP_FREQ:\n\tcase CS42L51_BEEP_VOL:\n\tcase CS42L51_BEEP_CONF:\n\tcase CS42L51_TONE_CTL:\n\tcase CS42L51_AOUTA_VOL:\n\tcase CS42L51_AOUTB_VOL:\n\tcase CS42L51_PCM_MIXER:\n\tcase CS42L51_LIMIT_THRES_DIS:\n\tcase CS42L51_LIMIT_REL:\n\tcase CS42L51_LIMIT_ATT:\n\tcase CS42L51_ALC_EN:\n\tcase CS42L51_ALC_REL:\n\tcase CS42L51_ALC_THRES:\n\tcase CS42L51_NOISE_CONF:\n\tcase CS42L51_CHARGE_FREQ:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42l51_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L51_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs42l51_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS42L51_CHIP_REV_ID:\n\tcase CS42L51_POWER_CTL1:\n\tcase CS42L51_MIC_POWER_CTL:\n\tcase CS42L51_INTF_CTL:\n\tcase CS42L51_MIC_CTL:\n\tcase CS42L51_ADC_CTL:\n\tcase CS42L51_ADC_INPUT:\n\tcase CS42L51_DAC_OUT_CTL:\n\tcase CS42L51_DAC_CTL:\n\tcase CS42L51_ALC_PGA_CTL:\n\tcase CS42L51_ALC_PGB_CTL:\n\tcase CS42L51_ADCA_ATT:\n\tcase CS42L51_ADCB_ATT:\n\tcase CS42L51_ADCA_VOL:\n\tcase CS42L51_ADCB_VOL:\n\tcase CS42L51_PCMA_VOL:\n\tcase CS42L51_PCMB_VOL:\n\tcase CS42L51_BEEP_FREQ:\n\tcase CS42L51_BEEP_VOL:\n\tcase CS42L51_BEEP_CONF:\n\tcase CS42L51_TONE_CTL:\n\tcase CS42L51_AOUTA_VOL:\n\tcase CS42L51_AOUTB_VOL:\n\tcase CS42L51_PCM_MIXER:\n\tcase CS42L51_LIMIT_THRES_DIS:\n\tcase CS42L51_LIMIT_REL:\n\tcase CS42L51_LIMIT_ATT:\n\tcase CS42L51_ALC_EN:\n\tcase CS42L51_ALC_REL:\n\tcase CS42L51_ALC_THRES:\n\tcase CS42L51_NOISE_CONF:\n\tcase CS42L51_STATUS:\n\tcase CS42L51_CHARGE_FREQ:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nconst struct regmap_config cs42l51_regmap = {\n\t.reg_bits = 8,\n\t.reg_stride = 1,\n\t.val_bits = 8,\n\t.use_single_write = true,\n\t.readable_reg = cs42l51_readable_reg,\n\t.volatile_reg = cs42l51_volatile_reg,\n\t.writeable_reg = cs42l51_writeable_reg,\n\t.max_register = CS42L51_CHARGE_FREQ,\n\t.cache_type = REGCACHE_MAPLE,\n};\nEXPORT_SYMBOL_GPL(cs42l51_regmap);\n\nint cs42l51_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct cs42l51_private *cs42l51;\n\tunsigned int val;\n\tint ret, i;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tcs42l51 = devm_kzalloc(dev, sizeof(struct cs42l51_private),\n\t\t\t       GFP_KERNEL);\n\tif (!cs42l51)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, cs42l51);\n\tcs42l51->regmap = regmap;\n\n\tcs42l51->mclk_handle = devm_clk_get_optional(dev, \"MCLK\");\n\tif (IS_ERR(cs42l51->mclk_handle))\n\t\treturn PTR_ERR(cs42l51->mclk_handle);\n\n\tfor (i = 0; i < ARRAY_SIZE(cs42l51->supplies); i++)\n\t\tcs42l51->supplies[i].supply = cs42l51_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(cs42l51->supplies),\n\t\t\t\t      cs42l51->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs42l51->supplies),\n\t\t\t\t    cs42l51->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs42l51->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(cs42l51->reset_gpio))\n\t\treturn PTR_ERR(cs42l51->reset_gpio);\n\n\tif (cs42l51->reset_gpio) {\n\t\tdev_dbg(dev, \"Release reset gpio\\n\");\n\t\tgpiod_set_value_cansleep(cs42l51->reset_gpio, 0);\n\t\tmdelay(2);\n\t}\n\n\t \n\tret = regmap_read(regmap, CS42L51_CHIP_REV_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to read I2C\\n\");\n\t\tgoto error;\n\t}\n\n\tif ((val != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_A)) &&\n\t    (val != CS42L51_MK_CHIP_REV(CS42L51_CHIP_ID, CS42L51_CHIP_REV_B))) {\n\t\tdev_err(dev, \"Invalid chip id: %x\\n\", val);\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tdev_info(dev, \"Cirrus Logic CS42L51, Revision: %02X\\n\",\n\t\t val & CS42L51_CHIP_REV_MASK);\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t&soc_component_device_cs42l51, &cs42l51_dai, 1);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tregulator_bulk_disable(ARRAY_SIZE(cs42l51->supplies),\n\t\t\t       cs42l51->supplies);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cs42l51_probe);\n\nvoid cs42l51_remove(struct device *dev)\n{\n\tstruct cs42l51_private *cs42l51 = dev_get_drvdata(dev);\n\tint ret;\n\n\tgpiod_set_value_cansleep(cs42l51->reset_gpio, 1);\n\n\tret = regulator_bulk_disable(ARRAY_SIZE(cs42l51->supplies),\n\t\t\t\t     cs42l51->supplies);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to disable all regulators (%pe)\\n\",\n\t\t\t ERR_PTR(ret));\n\n}\nEXPORT_SYMBOL_GPL(cs42l51_remove);\n\nint __maybe_unused cs42l51_suspend(struct device *dev)\n{\n\tstruct cs42l51_private *cs42l51 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs42l51->regmap, true);\n\tregcache_mark_dirty(cs42l51->regmap);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs42l51_suspend);\n\nint __maybe_unused cs42l51_resume(struct device *dev)\n{\n\tstruct cs42l51_private *cs42l51 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs42l51->regmap, false);\n\n\treturn regcache_sync(cs42l51->regmap);\n}\nEXPORT_SYMBOL_GPL(cs42l51_resume);\n\nMODULE_AUTHOR(\"Arnaud Patard <arnaud.patard@rtp-net.org>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS42L51 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}