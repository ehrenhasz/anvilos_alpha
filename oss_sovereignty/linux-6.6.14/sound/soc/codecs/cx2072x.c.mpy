{
  "module_name": "cx2072x.c",
  "hash_id": "19640a4d1c9505360f222210fe8d35493de8b8f0b101d4923de6fe8eb8fcb1bb",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cx2072x.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include \"cx2072x.h\"\n\n#define PLL_OUT_HZ_48\t(1024 * 3 * 48000)\n#define BITS_PER_SLOT\t8\n\n \nstruct cx2072x_priv {\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\tunsigned int mclk_rate;\n\tstruct device *dev;\n\tstruct snd_soc_component *codec;\n\tstruct snd_soc_jack_gpio jack_gpio;\n\tstruct mutex lock;\n\tunsigned int bclk_ratio;\n\tbool pll_changed;\n\tbool i2spcm_changed;\n\tint sample_size;\n\tint frame_size;\n\tint sample_rate;\n\tunsigned int dai_fmt;\n\tbool en_aec_ref;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -7400, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -7400, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, 0, 1200, 0);\n\nstruct cx2072x_eq_ctrl {\n\tu8 ch;\n\tu8 band;\n};\n\nstatic const DECLARE_TLV_DB_RANGE(hpf_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(120, 0, 0),\n\t1, 63, TLV_DB_SCALE_ITEM(30, 30, 0)\n);\n\n \nstatic const struct {\n\tunsigned int mclk;\n\tunsigned int div;\n} mclk_pre_div[] = {\n\t{ 6144000, 1 },\n\t{ 12288000, 2 },\n\t{ 19200000, 3 },\n\t{ 26000000, 4 },\n\t{ 28224000, 5 },\n\t{ 36864000, 6 },\n\t{ 36864000, 7 },\n\t{ 48000000, 8 },\n\t{ 49152000, 8 },\n};\n\n \nstatic const struct reg_default cx2072x_reg_defaults[] = {\n\t{ CX2072X_AFG_POWER_STATE, 0x00000003 },\n\t{ CX2072X_UM_RESPONSE, 0x00000000 },\n\t{ CX2072X_GPIO_DATA, 0x00000000 },\n\t{ CX2072X_GPIO_ENABLE, 0x00000000 },\n\t{ CX2072X_GPIO_DIRECTION, 0x00000000 },\n\t{ CX2072X_GPIO_WAKE, 0x00000000 },\n\t{ CX2072X_GPIO_UM_ENABLE, 0x00000000 },\n\t{ CX2072X_GPIO_STICKY_MASK, 0x00000000 },\n\t{ CX2072X_DAC1_CONVERTER_FORMAT, 0x00000031 },\n\t{ CX2072X_DAC1_AMP_GAIN_RIGHT, 0x0000004a },\n\t{ CX2072X_DAC1_AMP_GAIN_LEFT, 0x0000004a },\n\t{ CX2072X_DAC1_POWER_STATE, 0x00000433 },\n\t{ CX2072X_DAC1_CONVERTER_STREAM_CHANNEL, 0x00000000 },\n\t{ CX2072X_DAC1_EAPD_ENABLE, 0x00000000 },\n\t{ CX2072X_DAC2_CONVERTER_FORMAT, 0x00000031 },\n\t{ CX2072X_DAC2_AMP_GAIN_RIGHT, 0x0000004a },\n\t{ CX2072X_DAC2_AMP_GAIN_LEFT, 0x0000004a },\n\t{ CX2072X_DAC2_POWER_STATE, 0x00000433 },\n\t{ CX2072X_DAC2_CONVERTER_STREAM_CHANNEL, 0x00000000 },\n\t{ CX2072X_ADC1_CONVERTER_FORMAT, 0x00000031 },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_0, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_0, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_1, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_1, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_2, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_2, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_3, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_3, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_4, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_4, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_5, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_5, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_RIGHT_6, 0x0000004a },\n\t{ CX2072X_ADC1_AMP_GAIN_LEFT_6, 0x0000004a },\n\t{ CX2072X_ADC1_CONNECTION_SELECT_CONTROL, 0x00000000 },\n\t{ CX2072X_ADC1_POWER_STATE, 0x00000433 },\n\t{ CX2072X_ADC1_CONVERTER_STREAM_CHANNEL, 0x00000000 },\n\t{ CX2072X_ADC2_CONVERTER_FORMAT, 0x00000031 },\n\t{ CX2072X_ADC2_AMP_GAIN_RIGHT_0, 0x0000004a },\n\t{ CX2072X_ADC2_AMP_GAIN_LEFT_0, 0x0000004a },\n\t{ CX2072X_ADC2_AMP_GAIN_RIGHT_1, 0x0000004a },\n\t{ CX2072X_ADC2_AMP_GAIN_LEFT_1, 0x0000004a },\n\t{ CX2072X_ADC2_AMP_GAIN_RIGHT_2, 0x0000004a },\n\t{ CX2072X_ADC2_AMP_GAIN_LEFT_2, 0x0000004a },\n\t{ CX2072X_ADC2_CONNECTION_SELECT_CONTROL, 0x00000000 },\n\t{ CX2072X_ADC2_POWER_STATE, 0x00000433 },\n\t{ CX2072X_ADC2_CONVERTER_STREAM_CHANNEL, 0x00000000 },\n\t{ CX2072X_PORTA_CONNECTION_SELECT_CTRL, 0x00000000 },\n\t{ CX2072X_PORTA_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTA_PIN_CTRL, 0x000000c0 },\n\t{ CX2072X_PORTA_UNSOLICITED_RESPONSE, 0x00000000 },\n\t{ CX2072X_PORTA_PIN_SENSE, 0x00000000 },\n\t{ CX2072X_PORTA_EAPD_BTL, 0x00000002 },\n\t{ CX2072X_PORTB_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTB_PIN_CTRL, 0x00000000 },\n\t{ CX2072X_PORTB_UNSOLICITED_RESPONSE, 0x00000000 },\n\t{ CX2072X_PORTB_PIN_SENSE, 0x00000000 },\n\t{ CX2072X_PORTB_EAPD_BTL, 0x00000002 },\n\t{ CX2072X_PORTB_GAIN_RIGHT, 0x00000000 },\n\t{ CX2072X_PORTB_GAIN_LEFT, 0x00000000 },\n\t{ CX2072X_PORTC_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTC_PIN_CTRL, 0x00000000 },\n\t{ CX2072X_PORTC_GAIN_RIGHT, 0x00000000 },\n\t{ CX2072X_PORTC_GAIN_LEFT, 0x00000000 },\n\t{ CX2072X_PORTD_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTD_PIN_CTRL, 0x00000020 },\n\t{ CX2072X_PORTD_UNSOLICITED_RESPONSE, 0x00000000 },\n\t{ CX2072X_PORTD_PIN_SENSE, 0x00000000 },\n\t{ CX2072X_PORTD_GAIN_RIGHT, 0x00000000 },\n\t{ CX2072X_PORTD_GAIN_LEFT, 0x00000000 },\n\t{ CX2072X_PORTE_CONNECTION_SELECT_CTRL, 0x00000000 },\n\t{ CX2072X_PORTE_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTE_PIN_CTRL, 0x00000040 },\n\t{ CX2072X_PORTE_UNSOLICITED_RESPONSE, 0x00000000 },\n\t{ CX2072X_PORTE_PIN_SENSE, 0x00000000 },\n\t{ CX2072X_PORTE_EAPD_BTL, 0x00000002 },\n\t{ CX2072X_PORTE_GAIN_RIGHT, 0x00000000 },\n\t{ CX2072X_PORTE_GAIN_LEFT, 0x00000000 },\n\t{ CX2072X_PORTF_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTF_PIN_CTRL, 0x00000000 },\n\t{ CX2072X_PORTF_UNSOLICITED_RESPONSE, 0x00000000 },\n\t{ CX2072X_PORTF_PIN_SENSE, 0x00000000 },\n\t{ CX2072X_PORTF_GAIN_RIGHT, 0x00000000 },\n\t{ CX2072X_PORTF_GAIN_LEFT, 0x00000000 },\n\t{ CX2072X_PORTG_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTG_PIN_CTRL, 0x00000040 },\n\t{ CX2072X_PORTG_CONNECTION_SELECT_CTRL, 0x00000000 },\n\t{ CX2072X_PORTG_EAPD_BTL, 0x00000002 },\n\t{ CX2072X_PORTM_POWER_STATE, 0x00000433 },\n\t{ CX2072X_PORTM_PIN_CTRL, 0x00000000 },\n\t{ CX2072X_PORTM_CONNECTION_SELECT_CTRL, 0x00000000 },\n\t{ CX2072X_PORTM_EAPD_BTL, 0x00000002 },\n\t{ CX2072X_MIXER_POWER_STATE, 0x00000433 },\n\t{ CX2072X_MIXER_GAIN_RIGHT_0, 0x0000004a },\n\t{ CX2072X_MIXER_GAIN_LEFT_0, 0x0000004a },\n\t{ CX2072X_MIXER_GAIN_RIGHT_1, 0x0000004a },\n\t{ CX2072X_MIXER_GAIN_LEFT_1, 0x0000004a },\n\t{ CX2072X_SPKR_DRC_ENABLE_STEP, 0x040065a4 },\n\t{ CX2072X_SPKR_DRC_CONTROL, 0x007b0024 },\n\t{ CX2072X_SPKR_DRC_TEST, 0x00000000 },\n\t{ CX2072X_DIGITAL_BIOS_TEST0, 0x001f008a },\n\t{ CX2072X_DIGITAL_BIOS_TEST2, 0x00990026 },\n\t{ CX2072X_I2SPCM_CONTROL1, 0x00010001 },\n\t{ CX2072X_I2SPCM_CONTROL2, 0x00000000 },\n\t{ CX2072X_I2SPCM_CONTROL3, 0x00000000 },\n\t{ CX2072X_I2SPCM_CONTROL4, 0x00000000 },\n\t{ CX2072X_I2SPCM_CONTROL5, 0x00000000 },\n\t{ CX2072X_I2SPCM_CONTROL6, 0x00000000 },\n\t{ CX2072X_UM_INTERRUPT_CRTL_E, 0x00000000 },\n\t{ CX2072X_CODEC_TEST2, 0x00000000 },\n\t{ CX2072X_CODEC_TEST9, 0x00000004 },\n\t{ CX2072X_CODEC_TEST20, 0x00000600 },\n\t{ CX2072X_CODEC_TEST26, 0x00000208 },\n\t{ CX2072X_ANALOG_TEST4, 0x00000000 },\n\t{ CX2072X_ANALOG_TEST5, 0x00000000 },\n\t{ CX2072X_ANALOG_TEST6, 0x0000059a },\n\t{ CX2072X_ANALOG_TEST7, 0x000000a7 },\n\t{ CX2072X_ANALOG_TEST8, 0x00000017 },\n\t{ CX2072X_ANALOG_TEST9, 0x00000000 },\n\t{ CX2072X_ANALOG_TEST10, 0x00000285 },\n\t{ CX2072X_ANALOG_TEST11, 0x00000000 },\n\t{ CX2072X_ANALOG_TEST12, 0x00000000 },\n\t{ CX2072X_ANALOG_TEST13, 0x00000000 },\n\t{ CX2072X_DIGITAL_TEST1, 0x00000242 },\n\t{ CX2072X_DIGITAL_TEST11, 0x00000000 },\n\t{ CX2072X_DIGITAL_TEST12, 0x00000084 },\n\t{ CX2072X_DIGITAL_TEST15, 0x00000077 },\n\t{ CX2072X_DIGITAL_TEST16, 0x00000021 },\n\t{ CX2072X_DIGITAL_TEST17, 0x00000018 },\n\t{ CX2072X_DIGITAL_TEST18, 0x00000024 },\n\t{ CX2072X_DIGITAL_TEST19, 0x00000001 },\n\t{ CX2072X_DIGITAL_TEST20, 0x00000002 },\n};\n\n \nstatic const struct reg_sequence cx2072x_reg_init[] = {\n\t{ CX2072X_ANALOG_TEST9,\t0x080 },     \n\t{ CX2072X_CODEC_TEST26,\t0x65f },     \n\t{ CX2072X_ANALOG_TEST10, 0x289 },    \n\t{ CX2072X_CODEC_TEST20,\t0xf05 },\n\t{ CX2072X_CODEC_TESTXX,\t0x380 },\n\t{ CX2072X_CODEC_TEST26,\t0xb90 },\n\t{ CX2072X_CODEC_TEST9,\t0x001 },     \n\t{ CX2072X_ANALOG_TEST3,\t0x300 },     \n\t{ CX2072X_CODEC_TEST24,\t0x100 },     \n\t{ CX2072X_PORTD_PIN_CTRL, 0x020 },   \n\t{ CX2072X_GPIO_ENABLE,\t0x040 },     \n\t{ CX2072X_GPIO_UM_ENABLE, 0x040 },   \n\t{ CX2072X_UM_RESPONSE,\t0x080 },     \n\t{ CX2072X_DIGITAL_TEST12, 0x0c4 },   \n\t{ CX2072X_DIGITAL_TEST0, 0x415 },    \n\t{ CX2072X_I2SPCM_CONTROL2, 0x00f },  \n\t{ CX2072X_I2SPCM_CONTROL3, 0x00f },  \n};\n\nstatic unsigned int cx2072x_register_size(unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CX2072X_VENDOR_ID:\n\tcase CX2072X_REVISION_ID:\n\tcase CX2072X_PORTA_PIN_SENSE:\n\tcase CX2072X_PORTB_PIN_SENSE:\n\tcase CX2072X_PORTD_PIN_SENSE:\n\tcase CX2072X_PORTE_PIN_SENSE:\n\tcase CX2072X_PORTF_PIN_SENSE:\n\tcase CX2072X_I2SPCM_CONTROL1:\n\tcase CX2072X_I2SPCM_CONTROL2:\n\tcase CX2072X_I2SPCM_CONTROL3:\n\tcase CX2072X_I2SPCM_CONTROL4:\n\tcase CX2072X_I2SPCM_CONTROL5:\n\tcase CX2072X_I2SPCM_CONTROL6:\n\tcase CX2072X_UM_INTERRUPT_CRTL_E:\n\tcase CX2072X_EQ_G_COEFF:\n\tcase CX2072X_SPKR_DRC_CONTROL:\n\tcase CX2072X_SPKR_DRC_TEST:\n\tcase CX2072X_DIGITAL_BIOS_TEST0:\n\tcase CX2072X_DIGITAL_BIOS_TEST2:\n\t\treturn 4;\n\tcase CX2072X_EQ_ENABLE_BYPASS:\n\tcase CX2072X_EQ_B0_COEFF:\n\tcase CX2072X_EQ_B1_COEFF:\n\tcase CX2072X_EQ_B2_COEFF:\n\tcase CX2072X_EQ_A1_COEFF:\n\tcase CX2072X_EQ_A2_COEFF:\n\tcase CX2072X_DAC1_CONVERTER_FORMAT:\n\tcase CX2072X_DAC2_CONVERTER_FORMAT:\n\tcase CX2072X_ADC1_CONVERTER_FORMAT:\n\tcase CX2072X_ADC2_CONVERTER_FORMAT:\n\tcase CX2072X_CODEC_TEST2:\n\tcase CX2072X_CODEC_TEST9:\n\tcase CX2072X_CODEC_TEST20:\n\tcase CX2072X_CODEC_TEST26:\n\tcase CX2072X_ANALOG_TEST3:\n\tcase CX2072X_ANALOG_TEST4:\n\tcase CX2072X_ANALOG_TEST5:\n\tcase CX2072X_ANALOG_TEST6:\n\tcase CX2072X_ANALOG_TEST7:\n\tcase CX2072X_ANALOG_TEST8:\n\tcase CX2072X_ANALOG_TEST9:\n\tcase CX2072X_ANALOG_TEST10:\n\tcase CX2072X_ANALOG_TEST11:\n\tcase CX2072X_ANALOG_TEST12:\n\tcase CX2072X_ANALOG_TEST13:\n\tcase CX2072X_DIGITAL_TEST0:\n\tcase CX2072X_DIGITAL_TEST1:\n\tcase CX2072X_DIGITAL_TEST11:\n\tcase CX2072X_DIGITAL_TEST12:\n\tcase CX2072X_DIGITAL_TEST15:\n\tcase CX2072X_DIGITAL_TEST16:\n\tcase CX2072X_DIGITAL_TEST17:\n\tcase CX2072X_DIGITAL_TEST18:\n\tcase CX2072X_DIGITAL_TEST19:\n\tcase CX2072X_DIGITAL_TEST20:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic bool cx2072x_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CX2072X_VENDOR_ID:\n\tcase CX2072X_REVISION_ID:\n\tcase CX2072X_CURRENT_BCLK_FREQUENCY:\n\tcase CX2072X_AFG_POWER_STATE:\n\tcase CX2072X_UM_RESPONSE:\n\tcase CX2072X_GPIO_DATA:\n\tcase CX2072X_GPIO_ENABLE:\n\tcase CX2072X_GPIO_DIRECTION:\n\tcase CX2072X_GPIO_WAKE:\n\tcase CX2072X_GPIO_UM_ENABLE:\n\tcase CX2072X_GPIO_STICKY_MASK:\n\tcase CX2072X_DAC1_CONVERTER_FORMAT:\n\tcase CX2072X_DAC1_AMP_GAIN_RIGHT:\n\tcase CX2072X_DAC1_AMP_GAIN_LEFT:\n\tcase CX2072X_DAC1_POWER_STATE:\n\tcase CX2072X_DAC1_CONVERTER_STREAM_CHANNEL:\n\tcase CX2072X_DAC1_EAPD_ENABLE:\n\tcase CX2072X_DAC2_CONVERTER_FORMAT:\n\tcase CX2072X_DAC2_AMP_GAIN_RIGHT:\n\tcase CX2072X_DAC2_AMP_GAIN_LEFT:\n\tcase CX2072X_DAC2_POWER_STATE:\n\tcase CX2072X_DAC2_CONVERTER_STREAM_CHANNEL:\n\tcase CX2072X_ADC1_CONVERTER_FORMAT:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_0:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_0:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_1:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_1:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_2:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_2:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_3:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_3:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_4:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_4:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_5:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_5:\n\tcase CX2072X_ADC1_AMP_GAIN_RIGHT_6:\n\tcase CX2072X_ADC1_AMP_GAIN_LEFT_6:\n\tcase CX2072X_ADC1_CONNECTION_SELECT_CONTROL:\n\tcase CX2072X_ADC1_POWER_STATE:\n\tcase CX2072X_ADC1_CONVERTER_STREAM_CHANNEL:\n\tcase CX2072X_ADC2_CONVERTER_FORMAT:\n\tcase CX2072X_ADC2_AMP_GAIN_RIGHT_0:\n\tcase CX2072X_ADC2_AMP_GAIN_LEFT_0:\n\tcase CX2072X_ADC2_AMP_GAIN_RIGHT_1:\n\tcase CX2072X_ADC2_AMP_GAIN_LEFT_1:\n\tcase CX2072X_ADC2_AMP_GAIN_RIGHT_2:\n\tcase CX2072X_ADC2_AMP_GAIN_LEFT_2:\n\tcase CX2072X_ADC2_CONNECTION_SELECT_CONTROL:\n\tcase CX2072X_ADC2_POWER_STATE:\n\tcase CX2072X_ADC2_CONVERTER_STREAM_CHANNEL:\n\tcase CX2072X_PORTA_CONNECTION_SELECT_CTRL:\n\tcase CX2072X_PORTA_POWER_STATE:\n\tcase CX2072X_PORTA_PIN_CTRL:\n\tcase CX2072X_PORTA_UNSOLICITED_RESPONSE:\n\tcase CX2072X_PORTA_PIN_SENSE:\n\tcase CX2072X_PORTA_EAPD_BTL:\n\tcase CX2072X_PORTB_POWER_STATE:\n\tcase CX2072X_PORTB_PIN_CTRL:\n\tcase CX2072X_PORTB_UNSOLICITED_RESPONSE:\n\tcase CX2072X_PORTB_PIN_SENSE:\n\tcase CX2072X_PORTB_EAPD_BTL:\n\tcase CX2072X_PORTB_GAIN_RIGHT:\n\tcase CX2072X_PORTB_GAIN_LEFT:\n\tcase CX2072X_PORTC_POWER_STATE:\n\tcase CX2072X_PORTC_PIN_CTRL:\n\tcase CX2072X_PORTC_GAIN_RIGHT:\n\tcase CX2072X_PORTC_GAIN_LEFT:\n\tcase CX2072X_PORTD_POWER_STATE:\n\tcase CX2072X_PORTD_PIN_CTRL:\n\tcase CX2072X_PORTD_UNSOLICITED_RESPONSE:\n\tcase CX2072X_PORTD_PIN_SENSE:\n\tcase CX2072X_PORTD_GAIN_RIGHT:\n\tcase CX2072X_PORTD_GAIN_LEFT:\n\tcase CX2072X_PORTE_CONNECTION_SELECT_CTRL:\n\tcase CX2072X_PORTE_POWER_STATE:\n\tcase CX2072X_PORTE_PIN_CTRL:\n\tcase CX2072X_PORTE_UNSOLICITED_RESPONSE:\n\tcase CX2072X_PORTE_PIN_SENSE:\n\tcase CX2072X_PORTE_EAPD_BTL:\n\tcase CX2072X_PORTE_GAIN_RIGHT:\n\tcase CX2072X_PORTE_GAIN_LEFT:\n\tcase CX2072X_PORTF_POWER_STATE:\n\tcase CX2072X_PORTF_PIN_CTRL:\n\tcase CX2072X_PORTF_UNSOLICITED_RESPONSE:\n\tcase CX2072X_PORTF_PIN_SENSE:\n\tcase CX2072X_PORTF_GAIN_RIGHT:\n\tcase CX2072X_PORTF_GAIN_LEFT:\n\tcase CX2072X_PORTG_POWER_STATE:\n\tcase CX2072X_PORTG_PIN_CTRL:\n\tcase CX2072X_PORTG_CONNECTION_SELECT_CTRL:\n\tcase CX2072X_PORTG_EAPD_BTL:\n\tcase CX2072X_PORTM_POWER_STATE:\n\tcase CX2072X_PORTM_PIN_CTRL:\n\tcase CX2072X_PORTM_CONNECTION_SELECT_CTRL:\n\tcase CX2072X_PORTM_EAPD_BTL:\n\tcase CX2072X_MIXER_POWER_STATE:\n\tcase CX2072X_MIXER_GAIN_RIGHT_0:\n\tcase CX2072X_MIXER_GAIN_LEFT_0:\n\tcase CX2072X_MIXER_GAIN_RIGHT_1:\n\tcase CX2072X_MIXER_GAIN_LEFT_1:\n\tcase CX2072X_EQ_ENABLE_BYPASS:\n\tcase CX2072X_EQ_B0_COEFF:\n\tcase CX2072X_EQ_B1_COEFF:\n\tcase CX2072X_EQ_B2_COEFF:\n\tcase CX2072X_EQ_A1_COEFF:\n\tcase CX2072X_EQ_A2_COEFF:\n\tcase CX2072X_EQ_G_COEFF:\n\tcase CX2072X_SPKR_DRC_ENABLE_STEP:\n\tcase CX2072X_SPKR_DRC_CONTROL:\n\tcase CX2072X_SPKR_DRC_TEST:\n\tcase CX2072X_DIGITAL_BIOS_TEST0:\n\tcase CX2072X_DIGITAL_BIOS_TEST2:\n\tcase CX2072X_I2SPCM_CONTROL1:\n\tcase CX2072X_I2SPCM_CONTROL2:\n\tcase CX2072X_I2SPCM_CONTROL3:\n\tcase CX2072X_I2SPCM_CONTROL4:\n\tcase CX2072X_I2SPCM_CONTROL5:\n\tcase CX2072X_I2SPCM_CONTROL6:\n\tcase CX2072X_UM_INTERRUPT_CRTL_E:\n\tcase CX2072X_CODEC_TEST2:\n\tcase CX2072X_CODEC_TEST9:\n\tcase CX2072X_CODEC_TEST20:\n\tcase CX2072X_CODEC_TEST26:\n\tcase CX2072X_ANALOG_TEST4:\n\tcase CX2072X_ANALOG_TEST5:\n\tcase CX2072X_ANALOG_TEST6:\n\tcase CX2072X_ANALOG_TEST7:\n\tcase CX2072X_ANALOG_TEST8:\n\tcase CX2072X_ANALOG_TEST9:\n\tcase CX2072X_ANALOG_TEST10:\n\tcase CX2072X_ANALOG_TEST11:\n\tcase CX2072X_ANALOG_TEST12:\n\tcase CX2072X_ANALOG_TEST13:\n\tcase CX2072X_DIGITAL_TEST0:\n\tcase CX2072X_DIGITAL_TEST1:\n\tcase CX2072X_DIGITAL_TEST11:\n\tcase CX2072X_DIGITAL_TEST12:\n\tcase CX2072X_DIGITAL_TEST15:\n\tcase CX2072X_DIGITAL_TEST16:\n\tcase CX2072X_DIGITAL_TEST17:\n\tcase CX2072X_DIGITAL_TEST18:\n\tcase CX2072X_DIGITAL_TEST19:\n\tcase CX2072X_DIGITAL_TEST20:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cx2072x_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CX2072X_VENDOR_ID:\n\tcase CX2072X_REVISION_ID:\n\tcase CX2072X_UM_INTERRUPT_CRTL_E:\n\tcase CX2072X_DIGITAL_TEST11:\n\tcase CX2072X_PORTA_PIN_SENSE:\n\tcase CX2072X_PORTB_PIN_SENSE:\n\tcase CX2072X_PORTD_PIN_SENSE:\n\tcase CX2072X_PORTE_PIN_SENSE:\n\tcase CX2072X_PORTF_PIN_SENSE:\n\tcase CX2072X_EQ_G_COEFF:\n\tcase CX2072X_EQ_BAND:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int cx2072x_reg_raw_write(struct i2c_client *client,\n\t\t\t\t unsigned int reg,\n\t\t\t\t const void *val, size_t val_count)\n{\n\tstruct device *dev = &client->dev;\n\tu8 buf[2 + CX2072X_MAX_EQ_COEFF];\n\tint ret;\n\n\tif (WARN_ON(val_count + 2 > sizeof(buf)))\n\t\treturn -EINVAL;\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = reg & 0xff;\n\n\tmemcpy(buf + 2, val, val_count);\n\n\tret = i2c_master_send(client, buf, val_count + 2);\n\tif (ret != val_count + 2) {\n\t\tdev_err(dev, \"I2C write failed, ret = %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int cx2072x_reg_write(void *context, unsigned int reg,\n\t\t\t     unsigned int value)\n{\n\t__le32 raw_value;\n\tunsigned int size;\n\n\tsize = cx2072x_register_size(reg);\n\n\tif (reg == CX2072X_UM_INTERRUPT_CRTL_E) {\n\t\t \n\t\treg += 3;\n\t\tsize = 1;\n\t\tvalue >>= 24;\n\t}\n\n\traw_value = cpu_to_le32(value);\n\treturn cx2072x_reg_raw_write(context, reg, &raw_value, size);\n}\n\nstatic int cx2072x_reg_read(void *context, unsigned int reg,\n\t\t\t    unsigned int *value)\n{\n\tstruct i2c_client *client = context;\n\tstruct device *dev = &client->dev;\n\t__le32 recv_buf = 0;\n\tstruct i2c_msg msgs[2];\n\tunsigned int size;\n\tu8 send_buf[2];\n\tint ret;\n\n\tsize = cx2072x_register_size(reg);\n\n\tsend_buf[0] = reg >> 8;\n\tsend_buf[1] = reg & 0xff;\n\n\tmsgs[0].addr = client->addr;\n\tmsgs[0].len = sizeof(send_buf);\n\tmsgs[0].buf = send_buf;\n\tmsgs[0].flags = 0;\n\n\tmsgs[1].addr = client->addr;\n\tmsgs[1].len = size;\n\tmsgs[1].buf = (u8 *)&recv_buf;\n\tmsgs[1].flags = I2C_M_RD;\n\n\tret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (ret != ARRAY_SIZE(msgs)) {\n\t\tdev_err(dev, \"Failed to read register, ret = %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\t*value = le32_to_cpu(recv_buf);\n\treturn 0;\n}\n\n \nstatic unsigned int get_div_from_mclk(unsigned int mclk)\n{\n\tunsigned int div = 8;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mclk_pre_div); i++) {\n\t\tif (mclk <= mclk_pre_div[i].mclk) {\n\t\t\tdiv = mclk_pre_div[i].div;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn div;\n}\n\nstatic int cx2072x_config_pll(struct cx2072x_priv *cx2072x)\n{\n\tstruct device *dev = cx2072x->dev;\n\tunsigned int pre_div;\n\tunsigned int pre_div_val;\n\tunsigned int pll_input;\n\tunsigned int pll_output;\n\tunsigned int int_div;\n\tunsigned int frac_div;\n\tu64 frac_num;\n\tunsigned int frac;\n\tunsigned int sample_rate = cx2072x->sample_rate;\n\tint pt_sample_per_sync = 2;\n\tint pt_clock_per_sample = 96;\n\n\tswitch (sample_rate) {\n\tcase 48000:\n\tcase 32000:\n\tcase 24000:\n\tcase 16000:\n\t\tbreak;\n\n\tcase 96000:\n\t\tpt_sample_per_sync = 1;\n\t\tpt_clock_per_sample = 48;\n\t\tbreak;\n\n\tcase 192000:\n\t\tpt_sample_per_sync = 0;\n\t\tpt_clock_per_sample = 24;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported sample rate %d\\n\", sample_rate);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpre_div = get_div_from_mclk(cx2072x->mclk_rate);\n\tpll_input = cx2072x->mclk_rate / pre_div;\n\tpll_output = sample_rate * 3072;\n\tint_div = pll_output / pll_input;\n\tfrac_div = pll_output - (int_div * pll_input);\n\n\tif (frac_div) {\n\t\tfrac_div *= 1000;\n\t\tfrac_div /= pll_input;\n\t\tfrac_num = (u64)(4000 + frac_div) * ((1 << 20) - 4);\n\t\tdo_div(frac_num, 7);\n\t\tfrac = ((u32)frac_num + 499) / 1000;\n\t}\n\tpre_div_val = (pre_div - 1) * 2;\n\n\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST4,\n\t\t     0x40 | (pre_div_val << 8));\n\tif (frac_div == 0) {\n\t\t \n\t\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST7, 0x100);\n\t} else {\n\t\t \n\t\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST6,\n\t\t\t     frac & 0xfff);\n\t\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST7,\n\t\t\t     (u8)(frac >> 12));\n\t}\n\n\tint_div--;\n\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST8, int_div);\n\n\t \n\tif (frac_div == 0) {\n\t\t \n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST16, 0x00);\n\t} else {\n\t\t \n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST16,\n\t\t\t     (pt_sample_per_sync << 4) & 0xf0);\n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST17,\n\t\t\t     pt_clock_per_sample);\n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST18,\n\t\t\t     pt_clock_per_sample * 3 / 2);\n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST19, 0x01);\n\t\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST20, 0x02);\n\t\tregmap_update_bits(cx2072x->regmap, CX2072X_DIGITAL_TEST16,\n\t\t\t\t   0x01, 0x01);\n\t}\n\n\treturn 0;\n}\n\nstatic int cx2072x_config_i2spcm(struct cx2072x_priv *cx2072x)\n{\n\tstruct device *dev = cx2072x->dev;\n\tunsigned int bclk_rate = 0;\n\tint is_i2s = 0;\n\tint has_one_bit_delay = 0;\n\tint is_frame_inv = 0;\n\tint is_bclk_inv = 0;\n\tint pulse_len;\n\tint frame_len = cx2072x->frame_size;\n\tint sample_size = cx2072x->sample_size;\n\tint i2s_right_slot;\n\tint i2s_right_pause_interval = 0;\n\tint i2s_right_pause_pos;\n\tint is_big_endian = 1;\n\tu64 div;\n\tunsigned int mod;\n\tunion cx2072x_reg_i2spcm_ctrl_reg1 reg1;\n\tunion cx2072x_reg_i2spcm_ctrl_reg2 reg2;\n\tunion cx2072x_reg_i2spcm_ctrl_reg3 reg3;\n\tunion cx2072x_reg_i2spcm_ctrl_reg4 reg4;\n\tunion cx2072x_reg_i2spcm_ctrl_reg5 reg5;\n\tunion cx2072x_reg_i2spcm_ctrl_reg6 reg6;\n\tunion cx2072x_reg_digital_bios_test2 regdbt2;\n\tconst unsigned int fmt = cx2072x->dai_fmt;\n\n\tif (frame_len <= 0) {\n\t\tdev_err(dev, \"Incorrect frame len %d\\n\", frame_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sample_size <= 0) {\n\t\tdev_err(dev, \"Incorrect sample size %d\\n\", sample_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"config_i2spcm set_dai_fmt- %08x\\n\", fmt);\n\n\tregdbt2.ulval = 0xac;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\treg2.r.tx_master = 1;\n\t\treg3.r.rx_master = 1;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\treg2.r.tx_master = 0;\n\t\treg3.r.rx_master = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI clocking mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tis_i2s = 1;\n\t\thas_one_bit_delay = 1;\n\t\tpulse_len = frame_len / 2;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tis_i2s = 1;\n\t\tpulse_len = frame_len / 2;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tis_i2s = 1;\n\t\tpulse_len = frame_len / 2;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tis_frame_inv = is_i2s;\n\t\tis_bclk_inv = is_i2s;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tis_frame_inv = !is_i2s;\n\t\tis_bclk_inv = !is_i2s;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tis_frame_inv = is_i2s;\n\t\tis_bclk_inv = !is_i2s;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tis_frame_inv = !is_i2s;\n\t\tis_bclk_inv = is_i2s;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI clock inversion\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg1.r.rx_data_one_line = 1;\n\treg1.r.tx_data_one_line = 1;\n\n\tif (is_i2s) {\n\t\ti2s_right_slot = (frame_len / 2) / BITS_PER_SLOT;\n\t\ti2s_right_pause_interval = (frame_len / 2) % BITS_PER_SLOT;\n\t\ti2s_right_pause_pos = i2s_right_slot * BITS_PER_SLOT;\n\t}\n\n\treg1.r.rx_ws_pol = is_frame_inv;\n\treg1.r.rx_ws_wid = pulse_len - 1;\n\n\treg1.r.rx_frm_len = frame_len / BITS_PER_SLOT - 1;\n\treg1.r.rx_sa_size = (sample_size / BITS_PER_SLOT) - 1;\n\n\treg1.r.tx_ws_pol = reg1.r.rx_ws_pol;\n\treg1.r.tx_ws_wid = pulse_len - 1;\n\treg1.r.tx_frm_len = reg1.r.rx_frm_len;\n\treg1.r.tx_sa_size = reg1.r.rx_sa_size;\n\n\treg2.r.tx_endian_sel = !is_big_endian;\n\treg2.r.tx_dstart_dly = has_one_bit_delay;\n\tif (cx2072x->en_aec_ref)\n\t\treg2.r.tx_dstart_dly = 0;\n\n\treg3.r.rx_endian_sel = !is_big_endian;\n\treg3.r.rx_dstart_dly = has_one_bit_delay;\n\n\treg4.ulval = 0;\n\n\tif (is_i2s) {\n\t\treg2.r.tx_slot_1 = 0;\n\t\treg2.r.tx_slot_2 = i2s_right_slot;\n\t\treg3.r.rx_slot_1 = 0;\n\t\tif (cx2072x->en_aec_ref)\n\t\t\treg3.r.rx_slot_2 = 0;\n\t\telse\n\t\t\treg3.r.rx_slot_2 = i2s_right_slot;\n\t\treg6.r.rx_pause_start_pos = i2s_right_pause_pos;\n\t\treg6.r.rx_pause_cycles = i2s_right_pause_interval;\n\t\treg6.r.tx_pause_start_pos = i2s_right_pause_pos;\n\t\treg6.r.tx_pause_cycles = i2s_right_pause_interval;\n\t} else {\n\t\tdev_err(dev, \"TDM mode is not implemented yet\\n\");\n\t\treturn -EINVAL;\n\t}\n\tregdbt2.r.i2s_bclk_invert = is_bclk_inv;\n\n\t \n\tbclk_rate = cx2072x->sample_rate * frame_len;\n\treg5.r.i2s_pcm_clk_div_chan_en = 0;\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_I2SPCM_CONTROL5, 0);\n\n\tif (reg2.r.tx_master) {\n\t\t \n\t\tdiv = PLL_OUT_HZ_48;\n\t\tmod = do_div(div, bclk_rate);\n\t\tif (mod) {\n\t\t\tdev_err(dev, \"Unsupported BCLK %dHz\\n\", bclk_rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdev_dbg(dev, \"enables BCLK %dHz output\\n\", bclk_rate);\n\t\treg5.r.i2s_pcm_clk_div = (u32)div - 1;\n\t\treg5.r.i2s_pcm_clk_div_chan_en = 1;\n\t}\n\n\tregmap_write(cx2072x->regmap, CX2072X_I2SPCM_CONTROL1, reg1.ulval);\n\tregmap_update_bits(cx2072x->regmap, CX2072X_I2SPCM_CONTROL2, 0xffffffc0,\n\t\t\t   reg2.ulval);\n\tregmap_update_bits(cx2072x->regmap, CX2072X_I2SPCM_CONTROL3, 0xffffffc0,\n\t\t\t   reg3.ulval);\n\tregmap_write(cx2072x->regmap, CX2072X_I2SPCM_CONTROL4, reg4.ulval);\n\tregmap_write(cx2072x->regmap, CX2072X_I2SPCM_CONTROL6, reg6.ulval);\n\tregmap_write(cx2072x->regmap, CX2072X_I2SPCM_CONTROL5, reg5.ulval);\n\n\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_BIOS_TEST2,\n\t\t     regdbt2.ulval);\n\n\treturn 0;\n}\n\nstatic int afg_power_ev(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(cx2072x->regmap, CX2072X_DIGITAL_BIOS_TEST0,\n\t\t\t\t   0x00, 0x10);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(cx2072x->regmap, CX2072X_DIGITAL_BIOS_TEST0,\n\t\t\t\t   0x10, 0x10);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new cx2072x_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"PortD Boost Volume\", CX2072X_PORTD_GAIN_LEFT,\n\t\t\t CX2072X_PORTD_GAIN_RIGHT, 0, 3, 0, boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"PortC Boost Volume\", CX2072X_PORTC_GAIN_LEFT,\n\t\t\t CX2072X_PORTC_GAIN_RIGHT, 0, 3, 0, boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"PortB Boost Volume\", CX2072X_PORTB_GAIN_LEFT,\n\t\t\t CX2072X_PORTB_GAIN_RIGHT, 0, 3, 0, boost_tlv),\n\tSOC_DOUBLE_R_TLV(\"PortD ADC1 Volume\", CX2072X_ADC1_AMP_GAIN_LEFT_1,\n\t\t\t CX2072X_ADC1_AMP_GAIN_RIGHT_1, 0, 0x4a, 0, adc_tlv),\n\tSOC_DOUBLE_R_TLV(\"PortC ADC1 Volume\", CX2072X_ADC1_AMP_GAIN_LEFT_2,\n\t\t\t CX2072X_ADC1_AMP_GAIN_RIGHT_2, 0, 0x4a, 0, adc_tlv),\n\tSOC_DOUBLE_R_TLV(\"PortB ADC1 Volume\", CX2072X_ADC1_AMP_GAIN_LEFT_0,\n\t\t\t CX2072X_ADC1_AMP_GAIN_RIGHT_0, 0, 0x4a, 0, adc_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC1 Volume\", CX2072X_DAC1_AMP_GAIN_LEFT,\n\t\t\t CX2072X_DAC1_AMP_GAIN_RIGHT, 0, 0x4a, 0, dac_tlv),\n\tSOC_DOUBLE_R(\"DAC1 Switch\", CX2072X_DAC1_AMP_GAIN_LEFT,\n\t\t     CX2072X_DAC1_AMP_GAIN_RIGHT, 7,  1, 0),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Volume\", CX2072X_DAC2_AMP_GAIN_LEFT,\n\t\t\t CX2072X_DAC2_AMP_GAIN_RIGHT, 0, 0x4a, 0, dac_tlv),\n\tSOC_SINGLE_TLV(\"HPF Freq\", CX2072X_CODEC_TEST9, 0, 0x3f, 0, hpf_tlv),\n\tSOC_DOUBLE(\"HPF Switch\", CX2072X_CODEC_TEST9, 8, 9, 1, 1),\n\tSOC_SINGLE(\"PortA HP Amp Switch\", CX2072X_PORTA_PIN_CTRL, 7, 1, 0),\n};\n\nstatic int cx2072x_hw_params(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tstruct device *dev = codec->dev;\n\tconst unsigned int sample_rate = params_rate(params);\n\tint sample_size, frame_size;\n\n\t \n\tsample_size = params_width(params);\n\n\tif (sample_size < 0)\n\t\treturn sample_size;\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0)\n\t\treturn frame_size;\n\n\tif (cx2072x->mclk_rate == 0) {\n\t\tdev_err(dev, \"Master clock rate is not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cx2072x->bclk_ratio)\n\t\tframe_size = cx2072x->bclk_ratio;\n\n\tswitch (sample_rate) {\n\tcase 48000:\n\tcase 32000:\n\tcase 24000:\n\tcase 16000:\n\tcase 96000:\n\tcase 192000:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported sample rate %d\\n\", sample_rate);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"Sample size %d bits, frame = %d bits, rate = %d Hz\\n\",\n\t\tsample_size, frame_size, sample_rate);\n\n\tcx2072x->frame_size = frame_size;\n\tcx2072x->sample_size = sample_size;\n\tcx2072x->sample_rate = sample_rate;\n\n\tif (dai->id == CX2072X_DAI_DSP) {\n\t\tcx2072x->en_aec_ref = true;\n\t\tdev_dbg(cx2072x->dev, \"enables aec reference\\n\");\n\t\tregmap_write(cx2072x->regmap,\n\t\t\t     CX2072X_ADC1_CONNECTION_SELECT_CONTROL, 3);\n\t}\n\n\tif (cx2072x->pll_changed) {\n\t\tcx2072x_config_pll(cx2072x);\n\t\tcx2072x->pll_changed = false;\n\t}\n\n\tif (cx2072x->i2spcm_changed) {\n\t\tcx2072x_config_i2spcm(cx2072x);\n\t\tcx2072x->i2spcm_changed = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int cx2072x_set_dai_bclk_ratio(struct snd_soc_dai *dai,\n\t\t\t\t      unsigned int ratio)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\n\tcx2072x->bclk_ratio = ratio;\n\treturn 0;\n}\n\nstatic int cx2072x_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t\t  unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\n\tif (clk_set_rate(cx2072x->mclk, freq)) {\n\t\tdev_err(codec->dev, \"set clk rate failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcx2072x->mclk_rate = freq;\n\treturn 0;\n}\n\nstatic int cx2072x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tstruct device *dev = codec->dev;\n\n\tdev_dbg(dev, \"set_dai_fmt- %08x\\n\", fmt);\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI master mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\tcase SND_SOC_DAIFMT_IB_NF:\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Unsupported DAI clock inversion\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcx2072x->dai_fmt = fmt;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new portaouten_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTA_PIN_CTRL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new porteouten_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTE_PIN_CTRL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new portgouten_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTG_PIN_CTRL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new portmouten_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTM_PIN_CTRL, 6, 1, 0);\n\nstatic const struct snd_kcontrol_new portbinen_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTB_PIN_CTRL, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new portcinen_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTC_PIN_CTRL, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new portdinen_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTD_PIN_CTRL, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new porteinen_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_PORTE_PIN_CTRL, 5, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sadc1l_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL2, 0, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sadc1r_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL2, 1, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sadc2l_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL2, 2, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sadc2r_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL2, 3, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sdac1l_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL3, 0, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sdac1r_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL3, 1, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sdac2l_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL3, 2, 1, 0);\n\nstatic const struct snd_kcontrol_new i2sdac2r_ctl =\n\tSOC_DAPM_SINGLE(\"Switch\", CX2072X_I2SPCM_CONTROL3, 3, 1, 0);\n\nstatic const char * const dac_enum_text[] = {\n\t\"DAC1 Switch\", \"DAC2 Switch\",\n};\n\nstatic const struct soc_enum porta_dac_enum =\nSOC_ENUM_SINGLE(CX2072X_PORTA_CONNECTION_SELECT_CTRL, 0, 2, dac_enum_text);\n\nstatic const struct snd_kcontrol_new porta_mux =\nSOC_DAPM_ENUM(\"PortA Mux\", porta_dac_enum);\n\nstatic const struct soc_enum portg_dac_enum =\nSOC_ENUM_SINGLE(CX2072X_PORTG_CONNECTION_SELECT_CTRL, 0, 2, dac_enum_text);\n\nstatic const struct snd_kcontrol_new portg_mux =\nSOC_DAPM_ENUM(\"PortG Mux\", portg_dac_enum);\n\nstatic const struct soc_enum porte_dac_enum =\nSOC_ENUM_SINGLE(CX2072X_PORTE_CONNECTION_SELECT_CTRL, 0, 2, dac_enum_text);\n\nstatic const struct snd_kcontrol_new porte_mux =\nSOC_DAPM_ENUM(\"PortE Mux\", porte_dac_enum);\n\nstatic const struct soc_enum portm_dac_enum =\nSOC_ENUM_SINGLE(CX2072X_PORTM_CONNECTION_SELECT_CTRL, 0, 2, dac_enum_text);\n\nstatic const struct snd_kcontrol_new portm_mux =\nSOC_DAPM_ENUM(\"PortM Mux\", portm_dac_enum);\n\nstatic const char * const adc1in_sel_text[] = {\n\t\"PortB Switch\", \"PortD Switch\", \"PortC Switch\", \"Widget15 Switch\",\n\t\"PortE Switch\", \"PortF Switch\", \"PortH Switch\"\n};\n\nstatic const struct soc_enum adc1in_sel_enum =\nSOC_ENUM_SINGLE(CX2072X_ADC1_CONNECTION_SELECT_CONTROL, 0, 7, adc1in_sel_text);\n\nstatic const struct snd_kcontrol_new adc1_mux =\nSOC_DAPM_ENUM(\"ADC1 Mux\", adc1in_sel_enum);\n\nstatic const char * const adc2in_sel_text[] = {\n\t\"PortC Switch\", \"Widget15 Switch\", \"PortH Switch\"\n};\n\nstatic const struct soc_enum adc2in_sel_enum =\nSOC_ENUM_SINGLE(CX2072X_ADC2_CONNECTION_SELECT_CONTROL, 0, 3, adc2in_sel_text);\n\nstatic const struct snd_kcontrol_new adc2_mux =\nSOC_DAPM_ENUM(\"ADC2 Mux\", adc2in_sel_enum);\n\nstatic const struct snd_kcontrol_new wid15_mix[] = {\n\tSOC_DAPM_SINGLE(\"DAC1L Switch\", CX2072X_MIXER_GAIN_LEFT_0, 7, 1, 1),\n\tSOC_DAPM_SINGLE(\"DAC1R Switch\", CX2072X_MIXER_GAIN_RIGHT_0, 7, 1, 1),\n\tSOC_DAPM_SINGLE(\"DAC2L Switch\", CX2072X_MIXER_GAIN_LEFT_1, 7, 1, 1),\n\tSOC_DAPM_SINGLE(\"DAC2R Switch\", CX2072X_MIXER_GAIN_RIGHT_1, 7, 1, 1),\n};\n\n#define CX2072X_DAPM_SUPPLY_S(wname, wsubseq, wreg, wshift, wmask,  won_val, \\\n\twoff_val, wevent, wflags) \\\n\t{.id = snd_soc_dapm_supply, .name = wname, .kcontrol_news = NULL, \\\n\t.num_kcontrols = 0, .reg = wreg, .shift = wshift, .mask = wmask, \\\n\t.on_val = won_val, .off_val = woff_val, \\\n\t.subseq = wsubseq, .event = wevent, .event_flags = wflags}\n\n#define CX2072X_DAPM_SWITCH(wname,  wreg, wshift, wmask,  won_val, woff_val, \\\n\twevent, wflags) \\\n\t{.id = snd_soc_dapm_switch, .name = wname, .kcontrol_news = NULL, \\\n\t.num_kcontrols = 0, .reg = wreg, .shift = wshift, .mask = wmask, \\\n\t.on_val = won_val, .off_val = woff_val, \\\n\t.event = wevent, .event_flags = wflags}\n\n#define CX2072X_DAPM_SWITCH(wname,  wreg, wshift, wmask,  won_val, woff_val, \\\n\twevent, wflags) \\\n\t{.id = snd_soc_dapm_switch, .name = wname, .kcontrol_news = NULL, \\\n\t.num_kcontrols = 0, .reg = wreg, .shift = wshift, .mask = wmask, \\\n\t.on_val = won_val, .off_val = woff_val, \\\n\t.event = wevent, .event_flags = wflags}\n\n#define CX2072X_DAPM_REG_E(wid, wname, wreg, wshift, wmask, won_val, woff_val, \\\n\t\t\t\twevent, wflags) \\\n\t{.id = wid, .name = wname, .kcontrol_news = NULL, .num_kcontrols = 0, \\\n\t.reg = wreg, .shift = wshift, .mask = wmask, \\\n\t.on_val = won_val, .off_val = woff_val, \\\n\t.event = wevent, .event_flags = wflags}\n\nstatic const struct snd_soc_dapm_widget cx2072x_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"In AIF\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"I2S DAC1L\", SND_SOC_NOPM, 0, 0, &i2sdac1l_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S DAC1R\", SND_SOC_NOPM, 0, 0, &i2sdac1r_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S DAC2L\", SND_SOC_NOPM, 0, 0, &i2sdac2l_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S DAC2R\", SND_SOC_NOPM, 0, 0, &i2sdac2r_ctl),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_dac, \"DAC1\", CX2072X_DAC1_POWER_STATE,\n\t\t\t 0, 0xfff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_dac, \"DAC2\", CX2072X_DAC2_POWER_STATE,\n\t\t\t 0, 0xfff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_MUX(\"PortA Mux\", SND_SOC_NOPM, 0, 0, &porta_mux),\n\tSND_SOC_DAPM_MUX(\"PortG Mux\", SND_SOC_NOPM, 0, 0, &portg_mux),\n\tSND_SOC_DAPM_MUX(\"PortE Mux\", SND_SOC_NOPM, 0, 0, &porte_mux),\n\tSND_SOC_DAPM_MUX(\"PortM Mux\", SND_SOC_NOPM, 0, 0, &portm_mux),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortA Power\",\n\t\t\t CX2072X_PORTA_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortM Power\",\n\t\t\t CX2072X_PORTM_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortG Power\",\n\t\t\t CX2072X_PORTG_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\n\tCX2072X_DAPM_SUPPLY_S(\"AFG Power\", 0, CX2072X_AFG_POWER_STATE,\n\t\t\t      0, 0xfff, 0x00, 0x03, afg_power_ev,\n\t\t\t      SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_SWITCH(\"PortA Out En\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &portaouten_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortE Out En\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &porteouten_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortG Out En\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &portgouten_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortM Out En\", SND_SOC_NOPM, 0, 0,\n\t\t\t    &portmouten_ctl),\n\n\tSND_SOC_DAPM_OUTPUT(\"PORTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"PORTG\"),\n\tSND_SOC_DAPM_OUTPUT(\"PORTE\"),\n\tSND_SOC_DAPM_OUTPUT(\"PORTM\"),\n\tSND_SOC_DAPM_OUTPUT(\"AEC REF\"),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"Out AIF\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_SWITCH(\"I2S ADC1L\", SND_SOC_NOPM, 0, 0, &i2sadc1l_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S ADC1R\", SND_SOC_NOPM, 0, 0, &i2sadc1r_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S ADC2L\", SND_SOC_NOPM, 0, 0, &i2sadc2l_ctl),\n\tSND_SOC_DAPM_SWITCH(\"I2S ADC2R\", SND_SOC_NOPM, 0, 0, &i2sadc2r_ctl),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_adc, \"ADC1\", CX2072X_ADC1_POWER_STATE,\n\t\t\t 0, 0xff, 0x00, 0x03),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_adc, \"ADC2\", CX2072X_ADC2_POWER_STATE,\n\t\t\t 0, 0xff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_MUX(\"ADC1 Mux\", SND_SOC_NOPM, 0, 0, &adc1_mux),\n\tSND_SOC_DAPM_MUX(\"ADC2 Mux\", SND_SOC_NOPM, 0, 0, &adc2_mux),\n\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortB Power\",\n\t\t\t CX2072X_PORTB_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortC Power\",\n\t\t\t CX2072X_PORTC_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortD Power\",\n\t\t\t CX2072X_PORTD_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"PortE Power\",\n\t\t\t CX2072X_PORTE_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_supply, \"Widget15 Power\",\n\t\t\t CX2072X_MIXER_POWER_STATE, 0, 0xfff, 0x00, 0x03),\n\n\tSND_SOC_DAPM_MIXER(\"Widget15 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   wid15_mix, ARRAY_SIZE(wid15_mix)),\n\tSND_SOC_DAPM_SWITCH(\"PortB In En\", SND_SOC_NOPM, 0, 0, &portbinen_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortC In En\", SND_SOC_NOPM, 0, 0, &portcinen_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortD In En\", SND_SOC_NOPM, 0, 0, &portdinen_ctl),\n\tSND_SOC_DAPM_SWITCH(\"PortE In En\", SND_SOC_NOPM, 0, 0, &porteinen_ctl),\n\n\tSND_SOC_DAPM_MICBIAS(\"Headset Bias\", CX2072X_ANALOG_TEST11, 1, 0),\n\tSND_SOC_DAPM_MICBIAS(\"PortB Mic Bias\", CX2072X_PORTB_PIN_CTRL, 2, 0),\n\tSND_SOC_DAPM_MICBIAS(\"PortD Mic Bias\", CX2072X_PORTD_PIN_CTRL, 2, 0),\n\tSND_SOC_DAPM_MICBIAS(\"PortE Mic Bias\", CX2072X_PORTE_PIN_CTRL, 2, 0),\n\tSND_SOC_DAPM_INPUT(\"PORTB\"),\n\tSND_SOC_DAPM_INPUT(\"PORTC\"),\n\tSND_SOC_DAPM_INPUT(\"PORTD\"),\n\tSND_SOC_DAPM_INPUT(\"PORTEIN\"),\n\n};\n\nstatic const struct snd_soc_dapm_route cx2072x_intercon[] = {\n\t \n\t{\"In AIF\", NULL, \"AFG Power\"},\n\t{\"I2S DAC1L\", \"Switch\", \"In AIF\"},\n\t{\"I2S DAC1R\", \"Switch\", \"In AIF\"},\n\t{\"I2S DAC2L\", \"Switch\", \"In AIF\"},\n\t{\"I2S DAC2R\", \"Switch\", \"In AIF\"},\n\t{\"DAC1\", NULL, \"I2S DAC1L\"},\n\t{\"DAC1\", NULL, \"I2S DAC1R\"},\n\t{\"DAC2\", NULL, \"I2S DAC2L\"},\n\t{\"DAC2\", NULL, \"I2S DAC2R\"},\n\t{\"PortA Mux\", \"DAC1 Switch\", \"DAC1\"},\n\t{\"PortA Mux\", \"DAC2 Switch\", \"DAC2\"},\n\t{\"PortG Mux\", \"DAC1 Switch\", \"DAC1\"},\n\t{\"PortG Mux\", \"DAC2 Switch\", \"DAC2\"},\n\t{\"PortE Mux\", \"DAC1 Switch\", \"DAC1\"},\n\t{\"PortE Mux\", \"DAC2 Switch\", \"DAC2\"},\n\t{\"PortM Mux\", \"DAC1 Switch\", \"DAC1\"},\n\t{\"PortM Mux\", \"DAC2 Switch\", \"DAC2\"},\n\t{\"Widget15 Mixer\", \"DAC1L Switch\", \"DAC1\"},\n\t{\"Widget15 Mixer\", \"DAC1R Switch\", \"DAC2\"},\n\t{\"Widget15 Mixer\", \"DAC2L Switch\", \"DAC1\"},\n\t{\"Widget15 Mixer\", \"DAC2R Switch\", \"DAC2\"},\n\t{\"Widget15 Mixer\", NULL, \"Widget15 Power\"},\n\t{\"PortA Out En\", \"Switch\", \"PortA Mux\"},\n\t{\"PortG Out En\", \"Switch\", \"PortG Mux\"},\n\t{\"PortE Out En\", \"Switch\", \"PortE Mux\"},\n\t{\"PortM Out En\", \"Switch\", \"PortM Mux\"},\n\t{\"PortA Mux\", NULL, \"PortA Power\"},\n\t{\"PortG Mux\", NULL, \"PortG Power\"},\n\t{\"PortE Mux\", NULL, \"PortE Power\"},\n\t{\"PortM Mux\", NULL, \"PortM Power\"},\n\t{\"PortA Out En\", NULL, \"PortA Power\"},\n\t{\"PortG Out En\", NULL, \"PortG Power\"},\n\t{\"PortE Out En\", NULL, \"PortE Power\"},\n\t{\"PortM Out En\", NULL, \"PortM Power\"},\n\t{\"PORTA\", NULL, \"PortA Out En\"},\n\t{\"PORTG\", NULL, \"PortG Out En\"},\n\t{\"PORTE\", NULL, \"PortE Out En\"},\n\t{\"PORTM\", NULL, \"PortM Out En\"},\n\n\t \n\t{\"PORTD\", NULL, \"Headset Bias\"},\n\t{\"PortB In En\", \"Switch\", \"PORTB\"},\n\t{\"PortC In En\", \"Switch\", \"PORTC\"},\n\t{\"PortD In En\", \"Switch\", \"PORTD\"},\n\t{\"PortE In En\", \"Switch\", \"PORTEIN\"},\n\t{\"ADC1 Mux\", \"PortB Switch\", \"PortB In En\"},\n\t{\"ADC1 Mux\", \"PortC Switch\", \"PortC In En\"},\n\t{\"ADC1 Mux\", \"PortD Switch\", \"PortD In En\"},\n\t{\"ADC1 Mux\", \"PortE Switch\", \"PortE In En\"},\n\t{\"ADC1 Mux\", \"Widget15 Switch\", \"Widget15 Mixer\"},\n\t{\"ADC2 Mux\", \"PortC Switch\", \"PortC In En\"},\n\t{\"ADC2 Mux\", \"Widget15 Switch\", \"Widget15 Mixer\"},\n\t{\"ADC1\", NULL, \"ADC1 Mux\"},\n\t{\"ADC2\", NULL, \"ADC2 Mux\"},\n\t{\"I2S ADC1L\", \"Switch\", \"ADC1\"},\n\t{\"I2S ADC1R\", \"Switch\", \"ADC1\"},\n\t{\"I2S ADC2L\", \"Switch\", \"ADC2\"},\n\t{\"I2S ADC2R\", \"Switch\", \"ADC2\"},\n\t{\"Out AIF\", NULL, \"I2S ADC1L\"},\n\t{\"Out AIF\", NULL, \"I2S ADC1R\"},\n\t{\"Out AIF\", NULL, \"I2S ADC2L\"},\n\t{\"Out AIF\", NULL, \"I2S ADC2R\"},\n\t{\"Out AIF\", NULL, \"AFG Power\"},\n\t{\"AEC REF\", NULL, \"Out AIF\"},\n\t{\"PortB In En\", NULL, \"PortB Power\"},\n\t{\"PortC In En\", NULL, \"PortC Power\"},\n\t{\"PortD In En\", NULL, \"PortD Power\"},\n\t{\"PortE In En\", NULL, \"PortE Power\"},\n};\n\nstatic int cx2072x_set_bias_level(struct snd_soc_component *codec,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tconst enum snd_soc_bias_level old_level =\n\t\tsnd_soc_component_get_bias_level(codec);\n\n\tif (level == SND_SOC_BIAS_STANDBY && old_level == SND_SOC_BIAS_OFF)\n\t\tregmap_write(cx2072x->regmap, CX2072X_AFG_POWER_STATE, 0);\n\telse if (level == SND_SOC_BIAS_OFF && old_level != SND_SOC_BIAS_OFF)\n\t\tregmap_write(cx2072x->regmap, CX2072X_AFG_POWER_STATE, 3);\n\n\treturn 0;\n}\n\n \nstatic void cx2072x_enable_jack_detect(struct snd_soc_component *codec)\n{\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(codec);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_GPIO_STICKY_MASK, 0x1f);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_UM_INTERRUPT_CRTL_E, 0x12 << 24);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_PORTA_UNSOLICITED_RESPONSE, 0x80);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST15, 0x73);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_ANALOG_TEST12, 0x300);\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_DIGITAL_TEST1, 0);\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"PORTD\");\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"Headset Bias\");\n\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"PortD Mic Bias\");\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n}\n\nstatic void cx2072x_disable_jack_detect(struct snd_soc_component *codec)\n{\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\n\tregmap_write(cx2072x->regmap, CX2072X_UM_INTERRUPT_CRTL_E, 0);\n\tregmap_write(cx2072x->regmap, CX2072X_PORTA_UNSOLICITED_RESPONSE, 0);\n}\n\nstatic int cx2072x_jack_status_check(void *data)\n{\n\tstruct snd_soc_component *codec = data;\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tunsigned int jack;\n\tunsigned int type = 0;\n\tint state = 0;\n\n\tmutex_lock(&cx2072x->lock);\n\n\tregmap_read(cx2072x->regmap, CX2072X_PORTA_PIN_SENSE, &jack);\n\tjack = jack >> 24;\n\tregmap_read(cx2072x->regmap, CX2072X_DIGITAL_TEST11, &type);\n\n\tif (jack == 0x80) {\n\t\ttype = type >> 8;\n\n\t\tif (type & 0x8) {\n\t\t\t \n\t\t\tstate |= SND_JACK_HEADSET;\n\t\t\tif (type & 0x2)\n\t\t\t\tstate |= SND_JACK_BTN_0;\n\t\t} else {\n\t\t\t \n\t\t\tstate |= SND_JACK_HEADPHONE;\n\t\t}\n\t}\n\n\t \n\tregmap_write(cx2072x->regmap, CX2072X_UM_INTERRUPT_CRTL_E, 0x12 << 24);\n\n\tmutex_unlock(&cx2072x->lock);\n\n\tdev_dbg(codec->dev, \"CX2072X_HSDETECT type=0x%X,Jack state = %x\\n\",\n\t\ttype, state);\n\treturn state;\n}\n\nstatic const struct snd_soc_jack_gpio cx2072x_jack_gpio = {\n\t.name = \"headset\",\n\t.report = SND_JACK_HEADSET | SND_JACK_BTN_0,\n\t.debounce_time = 150,\n\t.wake = true,\n\t.jack_status_check = cx2072x_jack_status_check,\n};\n\nstatic int cx2072x_set_jack(struct snd_soc_component *codec,\n\t\t\t    struct snd_soc_jack *jack, void *data)\n{\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\tint err;\n\n\tif (!jack) {\n\t\tcx2072x_disable_jack_detect(codec);\n\t\treturn 0;\n\t}\n\n\tif (!cx2072x->jack_gpio.gpiod_dev) {\n\t\tcx2072x->jack_gpio = cx2072x_jack_gpio;\n\t\tcx2072x->jack_gpio.gpiod_dev = codec->dev;\n\t\tcx2072x->jack_gpio.data = codec;\n\t\terr = snd_soc_jack_add_gpios(jack, 1, &cx2072x->jack_gpio);\n\t\tif (err) {\n\t\t\tcx2072x->jack_gpio.gpiod_dev = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcx2072x_enable_jack_detect(codec);\n\treturn 0;\n}\n\nstatic int cx2072x_probe(struct snd_soc_component *codec)\n{\n\tstruct cx2072x_priv *cx2072x = snd_soc_component_get_drvdata(codec);\n\n\tcx2072x->codec = codec;\n\n\t \n\tpm_runtime_get_sync(codec->dev);\n\tregmap_write(cx2072x->regmap, CX2072X_AFG_POWER_STATE, 0);\n\n\tregmap_multi_reg_write(cx2072x->regmap, cx2072x_reg_init,\n\t\t\t       ARRAY_SIZE(cx2072x_reg_init));\n\n\t \n\tregmap_update_bits(cx2072x->regmap, CX2072X_PORTC_PIN_CTRL,\n\t\t\t   0x20, 0x20);\n\n\tregmap_update_bits(cx2072x->regmap, CX2072X_DIGITAL_BIOS_TEST2,\n\t\t\t   0x84, 0xff);\n\n\tregmap_write(cx2072x->regmap, CX2072X_AFG_POWER_STATE, 3);\n\tpm_runtime_put(codec->dev);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_driver_cx2072x = {\n\t.probe = cx2072x_probe,\n\t.set_bias_level = cx2072x_set_bias_level,\n\t.set_jack = cx2072x_set_jack,\n\t.controls = cx2072x_snd_controls,\n\t.num_controls = ARRAY_SIZE(cx2072x_snd_controls),\n\t.dapm_widgets = cx2072x_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(cx2072x_dapm_widgets),\n\t.dapm_routes = cx2072x_intercon,\n\t.num_dapm_routes = ARRAY_SIZE(cx2072x_intercon),\n\t.endianness = 1,\n};\n\n \nstatic const struct snd_soc_dai_ops cx2072x_dai_ops = {\n\t.set_sysclk = cx2072x_set_dai_sysclk,\n\t.set_fmt = cx2072x_set_dai_fmt,\n\t.hw_params = cx2072x_hw_params,\n\t.set_bclk_ratio = cx2072x_set_dai_bclk_ratio,\n};\n\nstatic int cx2072x_dsp_dai_probe(struct snd_soc_dai *dai)\n{\n\tstruct cx2072x_priv *cx2072x =\n\t\tsnd_soc_component_get_drvdata(dai->component);\n\n\tcx2072x->en_aec_ref = true;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cx2072x_dai_ops2 = {\n\t.probe\t\t= cx2072x_dsp_dai_probe,\n\t.set_sysclk\t= cx2072x_set_dai_sysclk,\n\t.set_fmt\t= cx2072x_set_dai_fmt,\n\t.hw_params\t= cx2072x_hw_params,\n\t.set_bclk_ratio\t= cx2072x_set_dai_bclk_ratio,\n};\n\n#define CX2072X_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver soc_codec_cx2072x_dai[] = {\n\t{  \n\t\t.name = \"cx2072x-hifi\",\n\t\t.id\t= CX2072X_DAI_HIFI,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CX2072X_RATES_DSP,\n\t\t\t.formats = CX2072X_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CX2072X_RATES_DSP,\n\t\t\t.formats = CX2072X_FORMATS,\n\t\t},\n\t\t.ops = &cx2072x_dai_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{  \n\t\t.name = \"cx2072x-dsp\",\n\t\t.id\t= CX2072X_DAI_DSP,\n\t\t.playback = {\n\t\t\t.stream_name = \"DSP Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CX2072X_RATES_DSP,\n\t\t\t.formats = CX2072X_FORMATS,\n\t\t},\n\t\t.ops = &cx2072x_dai_ops2,\n\t},\n\t{  \n\t\t.name = \"cx2072x-aec\",\n\t\t.id\t= 3,\n\t\t.capture = {\n\t\t\t.stream_name = \"AEC Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CX2072X_RATES_DSP,\n\t\t\t.formats = CX2072X_FORMATS,\n\t\t},\n\t},\n};\n\nstatic const struct regmap_config cx2072x_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 32,\n\t.max_register = CX2072X_REG_MAX,\n\t.reg_defaults = cx2072x_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cx2072x_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n\t.readable_reg = cx2072x_readable_register,\n\t.volatile_reg = cx2072x_volatile_register,\n\t \n\t.reg_read = cx2072x_reg_read,\n\t.reg_write = cx2072x_reg_write,\n};\n\nstatic int __maybe_unused cx2072x_runtime_suspend(struct device *dev)\n{\n\tstruct cx2072x_priv *cx2072x = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(cx2072x->mclk);\n\treturn 0;\n}\n\nstatic int __maybe_unused cx2072x_runtime_resume(struct device *dev)\n{\n\tstruct cx2072x_priv *cx2072x = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(cx2072x->mclk);\n}\n\nstatic int cx2072x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct cx2072x_priv *cx2072x;\n\tunsigned int ven_id, rev_id;\n\tint ret;\n\n\tcx2072x = devm_kzalloc(&i2c->dev, sizeof(struct cx2072x_priv),\n\t\t\t       GFP_KERNEL);\n\tif (!cx2072x)\n\t\treturn -ENOMEM;\n\n\tcx2072x->regmap = devm_regmap_init(&i2c->dev, NULL, i2c,\n\t\t\t\t\t   &cx2072x_regmap);\n\tif (IS_ERR(cx2072x->regmap))\n\t\treturn PTR_ERR(cx2072x->regmap);\n\n\tmutex_init(&cx2072x->lock);\n\n\ti2c_set_clientdata(i2c, cx2072x);\n\n\tcx2072x->dev = &i2c->dev;\n\tcx2072x->pll_changed = true;\n\tcx2072x->i2spcm_changed = true;\n\tcx2072x->bclk_ratio = 0;\n\n\tcx2072x->mclk = devm_clk_get(cx2072x->dev, \"mclk\");\n\tif (IS_ERR(cx2072x->mclk)) {\n\t\tdev_err(cx2072x->dev, \"Failed to get MCLK\\n\");\n\t\treturn PTR_ERR(cx2072x->mclk);\n\t}\n\n\tregmap_read(cx2072x->regmap, CX2072X_VENDOR_ID, &ven_id);\n\tregmap_read(cx2072x->regmap, CX2072X_REVISION_ID, &rev_id);\n\n\tdev_info(cx2072x->dev, \"codec version: %08x,%08x\\n\", ven_id, rev_id);\n\n\tret = devm_snd_soc_register_component(cx2072x->dev,\n\t\t\t\t\t      &soc_codec_driver_cx2072x,\n\t\t\t\t\t      soc_codec_cx2072x_dai,\n\t\t\t\t\t      ARRAY_SIZE(soc_codec_cx2072x_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_use_autosuspend(cx2072x->dev);\n\tpm_runtime_enable(cx2072x->dev);\n\n\treturn 0;\n}\n\nstatic void cx2072x_i2c_remove(struct i2c_client *i2c)\n{\n\tpm_runtime_disable(&i2c->dev);\n}\n\nstatic const struct i2c_device_id cx2072x_i2c_id[] = {\n\t{ \"cx20721\", 0 },\n\t{ \"cx20723\", 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, cx2072x_i2c_id);\n\n#ifdef CONFIG_ACPI\nstatic struct acpi_device_id cx2072x_acpi_match[] = {\n\t{ \"14F10720\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, cx2072x_acpi_match);\n#endif\n\nstatic const struct dev_pm_ops cx2072x_runtime_pm = {\n\tSET_RUNTIME_PM_OPS(cx2072x_runtime_suspend, cx2072x_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct i2c_driver cx2072x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cx2072x\",\n\t\t.acpi_match_table = ACPI_PTR(cx2072x_acpi_match),\n\t\t.pm = &cx2072x_runtime_pm,\n\t},\n\t.probe = cx2072x_i2c_probe,\n\t.remove = cx2072x_i2c_remove,\n\t.id_table = cx2072x_i2c_id,\n};\n\nmodule_i2c_driver(cx2072x_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC cx2072x Codec Driver\");\nMODULE_AUTHOR(\"Simon Ho <simon.ho@conexant.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}