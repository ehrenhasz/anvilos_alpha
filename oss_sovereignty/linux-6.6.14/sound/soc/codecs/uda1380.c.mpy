{
  "module_name": "uda1380.c",
  "hash_id": "da0840d7c76d450fc1bbf2035a21b4f1a33af5c249cd84172f2428b2263048d6",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/uda1380.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/workqueue.h>\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/initval.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/uda1380.h>\n\n#include \"uda1380.h\"\n\n \nstruct uda1380_priv {\n\tstruct snd_soc_component *component;\n\tunsigned int dac_clk;\n\tstruct work_struct work;\n\tstruct i2c_client *i2c;\n\tu16 *reg_cache;\n};\n\n \nstatic const u16 uda1380_reg[UDA1380_CACHEREGNUM] = {\n\t0x0502, 0x0000, 0x0000, 0x3f3f,\n\t0x0202, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0xff00, 0x0000, 0x4800,\n\t0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x0000, 0x0000, 0x0000,\n\t0x0000, 0x8000, 0x0002, 0x0000,\n};\n\nstatic unsigned long uda1380_cache_dirty;\n\n \nstatic inline unsigned int uda1380_read_reg_cache(struct snd_soc_component *component,\n\tunsigned int reg)\n{\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tu16 *cache = uda1380->reg_cache;\n\n\tif (reg == UDA1380_RESET)\n\t\treturn 0;\n\tif (reg >= UDA1380_CACHEREGNUM)\n\t\treturn -1;\n\treturn cache[reg];\n}\n\n \nstatic inline void uda1380_write_reg_cache(struct snd_soc_component *component,\n\tu16 reg, unsigned int value)\n{\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tu16 *cache = uda1380->reg_cache;\n\n\tif (reg >= UDA1380_CACHEREGNUM)\n\t\treturn;\n\tif ((reg >= 0x10) && (cache[reg] != value))\n\t\tset_bit(reg - 0x10, &uda1380_cache_dirty);\n\tcache[reg] = value;\n}\n\n \nstatic int uda1380_write(struct snd_soc_component *component, unsigned int reg,\n\tunsigned int value)\n{\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tu8 data[3];\n\n\t \n\tdata[0] = reg;\n\tdata[1] = (value & 0xff00) >> 8;\n\tdata[2] = value & 0x00ff;\n\n\tuda1380_write_reg_cache(component, reg, value);\n\n\t \n\tif (!snd_soc_component_active(component) && (reg >= UDA1380_MVOL))\n\t\treturn 0;\n\tpr_debug(\"uda1380: hw write %x val %x\\n\", reg, value);\n\tif (i2c_master_send(uda1380->i2c, data, 3) == 3) {\n\t\tunsigned int val;\n\t\ti2c_master_send(uda1380->i2c, data, 1);\n\t\ti2c_master_recv(uda1380->i2c, data, 2);\n\t\tval = (data[0]<<8) | data[1];\n\t\tif (val != value) {\n\t\t\tpr_debug(\"uda1380: READ BACK VAL %x\\n\",\n\t\t\t\t\t(data[0]<<8) | data[1]);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (reg >= 0x10)\n\t\t\tclear_bit(reg - 0x10, &uda1380_cache_dirty);\n\t\treturn 0;\n\t} else\n\t\treturn -EIO;\n}\n\nstatic void uda1380_sync_cache(struct snd_soc_component *component)\n{\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tint reg;\n\tu8 data[3];\n\tu16 *cache = uda1380->reg_cache;\n\n\t \n\tfor (reg = 0; reg < UDA1380_MVOL; reg++) {\n\t\tdata[0] = reg;\n\t\tdata[1] = (cache[reg] & 0xff00) >> 8;\n\t\tdata[2] = cache[reg] & 0x00ff;\n\t\tif (i2c_master_send(uda1380->i2c, data, 3) != 3)\n\t\t\tdev_err(component->dev, \"%s: write to reg 0x%x failed\\n\",\n\t\t\t\t__func__, reg);\n\t}\n}\n\nstatic int uda1380_reset(struct snd_soc_component *component)\n{\n\tstruct uda1380_platform_data *pdata = component->dev->platform_data;\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\n\tif (gpio_is_valid(pdata->gpio_reset)) {\n\t\tgpio_set_value(pdata->gpio_reset, 1);\n\t\tmdelay(1);\n\t\tgpio_set_value(pdata->gpio_reset, 0);\n\t} else {\n\t\tu8 data[3];\n\n\t\tdata[0] = UDA1380_RESET;\n\t\tdata[1] = 0;\n\t\tdata[2] = 0;\n\n\t\tif (i2c_master_send(uda1380->i2c, data, 3) != 3) {\n\t\t\tdev_err(component->dev, \"%s: failed\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void uda1380_flush_work(struct work_struct *work)\n{\n\tstruct uda1380_priv *uda1380 = container_of(work, struct uda1380_priv, work);\n\tstruct snd_soc_component *uda1380_component = uda1380->component;\n\tint bit, reg;\n\n\tfor_each_set_bit(bit, &uda1380_cache_dirty, UDA1380_CACHEREGNUM - 0x10) {\n\t\treg = 0x10 + bit;\n\t\tpr_debug(\"uda1380: flush reg %x val %x:\\n\", reg,\n\t\t\t\tuda1380_read_reg_cache(uda1380_component, reg));\n\t\tuda1380_write(uda1380_component, reg,\n\t\t\t\tuda1380_read_reg_cache(uda1380_component, reg));\n\t\tclear_bit(bit, &uda1380_cache_dirty);\n\t}\n\n}\n\n \nstatic const char *uda1380_deemp[] = {\n\t\"None\",\n\t\"32kHz\",\n\t\"44.1kHz\",\n\t\"48kHz\",\n\t\"96kHz\",\n};\nstatic const char *uda1380_input_sel[] = {\n\t\"Line\",\n\t\"Mic + Line R\",\n\t\"Line L\",\n\t\"Mic\",\n};\nstatic const char *uda1380_output_sel[] = {\n\t\"DAC\",\n\t\"Analog Mixer\",\n};\nstatic const char *uda1380_spf_mode[] = {\n\t\"Flat\",\n\t\"Minimum1\",\n\t\"Minimum2\",\n\t\"Maximum\"\n};\nstatic const char *uda1380_capture_sel[] = {\n\t\"ADC\",\n\t\"Digital Mixer\"\n};\nstatic const char *uda1380_sel_ns[] = {\n\t\"3rd-order\",\n\t\"5th-order\"\n};\nstatic const char *uda1380_mix_control[] = {\n\t\"off\",\n\t\"PCM only\",\n\t\"before sound processing\",\n\t\"after sound processing\"\n};\nstatic const char *uda1380_sdet_setting[] = {\n\t\"3200\",\n\t\"4800\",\n\t\"9600\",\n\t\"19200\"\n};\nstatic const char *uda1380_os_setting[] = {\n\t\"single-speed\",\n\t\"double-speed (no mixing)\",\n\t\"quad-speed (no mixing)\"\n};\n\nstatic const struct soc_enum uda1380_deemp_enum[] = {\n\tSOC_ENUM_SINGLE(UDA1380_DEEMP, 8, ARRAY_SIZE(uda1380_deemp),\n\t\t\tuda1380_deemp),\n\tSOC_ENUM_SINGLE(UDA1380_DEEMP, 0, ARRAY_SIZE(uda1380_deemp),\n\t\t\tuda1380_deemp),\n};\nstatic SOC_ENUM_SINGLE_DECL(uda1380_input_sel_enum,\n\t\t\t    UDA1380_ADC, 2, uda1380_input_sel);\t\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_output_sel_enum,\n\t\t\t    UDA1380_PM, 7, uda1380_output_sel);\t\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_spf_enum,\n\t\t\t    UDA1380_MODE, 14, uda1380_spf_mode);\t\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_capture_sel_enum,\n\t\t\t    UDA1380_IFACE, 6, uda1380_capture_sel);\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_sel_ns_enum,\n\t\t\t    UDA1380_MIXER, 14, uda1380_sel_ns);\t\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_mix_enum,\n\t\t\t    UDA1380_MIXER, 12, uda1380_mix_control);\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_sdet_enum,\n\t\t\t    UDA1380_MIXER, 4, uda1380_sdet_setting);\t \nstatic SOC_ENUM_SINGLE_DECL(uda1380_os_enum,\n\t\t\t    UDA1380_MIXER, 0, uda1380_os_setting);\t \n\n \nstatic DECLARE_TLV_DB_SCALE(amix_tlv, -4950, 150, 1);\n\n \nstatic const DECLARE_TLV_DB_RANGE(mvol_tlv,\n\t0, 15, TLV_DB_SCALE_ITEM(-8200, 100, 1),\n\t16, 43, TLV_DB_SCALE_ITEM(-6600, 50, 0),\n\t44, 252, TLV_DB_SCALE_ITEM(-5200, 25, 0)\n);\n\n \nstatic const DECLARE_TLV_DB_RANGE(vc_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-7800, 150, 1),\n\t8, 15, TLV_DB_SCALE_ITEM(-6600, 75, 0),\n\t16, 43, TLV_DB_SCALE_ITEM(-6000, 50, 0),\n\t44, 228, TLV_DB_SCALE_ITEM(-4600, 25, 0)\n);\n\n \nstatic DECLARE_TLV_DB_SCALE(tr_tlv, 0, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(bb_tlv, 0, 200, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(dec_tlv, -6400, 50, 1);\n\n \nstatic DECLARE_TLV_DB_SCALE(pga_tlv, 0, 300, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(vga_tlv, 0, 200, 0);\n\nstatic const struct snd_kcontrol_new uda1380_snd_controls[] = {\n\tSOC_DOUBLE_TLV(\"Analog Mixer Volume\", UDA1380_AMIX, 0, 8, 44, 1, amix_tlv),\t \n\tSOC_DOUBLE_TLV(\"Master Playback Volume\", UDA1380_MVOL, 0, 8, 252, 1, mvol_tlv),\t \n\tSOC_SINGLE_TLV(\"ADC Playback Volume\", UDA1380_MIXVOL, 8, 228, 1, vc_tlv),\t \n\tSOC_SINGLE_TLV(\"PCM Playback Volume\", UDA1380_MIXVOL, 0, 228, 1, vc_tlv),\t \n\tSOC_ENUM(\"Sound Processing Filter\", uda1380_spf_enum),\t\t\t\t \n\tSOC_DOUBLE_TLV(\"Tone Control - Treble\", UDA1380_MODE, 4, 12, 3, 0, tr_tlv), \t \n\tSOC_DOUBLE_TLV(\"Tone Control - Bass\", UDA1380_MODE, 0, 8, 15, 0, bb_tlv),\t \n \tSOC_SINGLE(\"Master Playback Switch\", UDA1380_DEEMP, 14, 1, 1),\t\t \n\tSOC_SINGLE(\"ADC Playback Switch\", UDA1380_DEEMP, 11, 1, 1),\t\t \n\tSOC_ENUM(\"ADC Playback De-emphasis\", uda1380_deemp_enum[0]),\t\t \n\tSOC_SINGLE(\"PCM Playback Switch\", UDA1380_DEEMP, 3, 1, 1),\t\t \n\tSOC_ENUM(\"PCM Playback De-emphasis\", uda1380_deemp_enum[1]),\t\t \n\tSOC_SINGLE(\"DAC Polarity inverting Switch\", UDA1380_MIXER, 15, 1, 0),\t \n\tSOC_ENUM(\"Noise Shaper\", uda1380_sel_ns_enum),\t\t\t\t \n\tSOC_ENUM(\"Digital Mixer Signal Control\", uda1380_mix_enum),\t\t \n\tSOC_SINGLE(\"Silence Detector Switch\", UDA1380_MIXER, 6, 1, 0),\t\t \n\tSOC_ENUM(\"Silence Detector Setting\", uda1380_sdet_enum),\t\t \n\tSOC_ENUM(\"Oversampling Input\", uda1380_os_enum),\t\t\t \n\tSOC_DOUBLE_S8_TLV(\"ADC Capture Volume\", UDA1380_DEC, -128, 48, dec_tlv),\t \n \tSOC_SINGLE(\"ADC Capture Switch\", UDA1380_PGA, 15, 1, 1),\t\t \n\tSOC_DOUBLE_TLV(\"Line Capture Volume\", UDA1380_PGA, 0, 8, 8, 0, pga_tlv),  \n\tSOC_SINGLE(\"ADC Polarity inverting Switch\", UDA1380_ADC, 12, 1, 0),\t \n\tSOC_SINGLE_TLV(\"Mic Capture Volume\", UDA1380_ADC, 8, 15, 0, vga_tlv),\t \n\tSOC_SINGLE(\"DC Filter Bypass Switch\", UDA1380_ADC, 1, 1, 0),\t\t \n\tSOC_SINGLE(\"DC Filter Enable Switch\", UDA1380_ADC, 0, 1, 0),\t\t \n\tSOC_SINGLE(\"AGC Timing\", UDA1380_AGC, 8, 7, 0),\t\t\t \n\tSOC_SINGLE(\"AGC Target level\", UDA1380_AGC, 2, 3, 1),\t\t\t \n\t \n\tSOC_SINGLE(\"AGC Switch\", UDA1380_AGC, 0, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new uda1380_input_mux_control =\n\tSOC_DAPM_ENUM(\"Route\", uda1380_input_sel_enum);\n\n \nstatic const struct snd_kcontrol_new uda1380_output_mux_control =\n\tSOC_DAPM_ENUM(\"Route\", uda1380_output_sel_enum);\n\n \nstatic const struct snd_kcontrol_new uda1380_capture_mux_control =\n\tSOC_DAPM_ENUM(\"Route\", uda1380_capture_sel_enum);\n\n\nstatic const struct snd_soc_dapm_widget uda1380_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&uda1380_input_mux_control),\n\tSND_SOC_DAPM_MUX(\"Output Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&uda1380_output_mux_control),\n\tSND_SOC_DAPM_MUX(\"Capture Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&uda1380_capture_mux_control),\n\tSND_SOC_DAPM_PGA(\"Left PGA\", UDA1380_PM, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right PGA\", UDA1380_PM, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mic LNA\", UDA1380_PM, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", UDA1380_PM, 2, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", UDA1380_PM, 0, 0),\n\tSND_SOC_DAPM_INPUT(\"VINM\"),\n\tSND_SOC_DAPM_INPUT(\"VINL\"),\n\tSND_SOC_DAPM_INPUT(\"VINR\"),\n\tSND_SOC_DAPM_MIXER(\"Analog Mixer\", UDA1380_PM, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTLHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTRHP\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTR\"),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", UDA1380_PM, 10, 0),\n\tSND_SOC_DAPM_PGA(\"HeadPhone Driver\", UDA1380_PM, 13, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_route uda1380_dapm_routes[] = {\n\n\t \n\t{\"HeadPhone Driver\", NULL, \"Output Mux\"},\n\t{\"VOUTR\", NULL, \"Output Mux\"},\n\t{\"VOUTL\", NULL, \"Output Mux\"},\n\n\t{\"Analog Mixer\", NULL, \"VINR\"},\n\t{\"Analog Mixer\", NULL, \"VINL\"},\n\t{\"Analog Mixer\", NULL, \"DAC\"},\n\n\t{\"Output Mux\", \"DAC\", \"DAC\"},\n\t{\"Output Mux\", \"Analog Mixer\", \"Analog Mixer\"},\n\n\t \n\n\t \n\t{\"VOUTLHP\", NULL, \"HeadPhone Driver\"},\n\t{\"VOUTRHP\", NULL, \"HeadPhone Driver\"},\n\n\t \n\t{\"Left ADC\", NULL, \"Input Mux\"},\n\t{\"Input Mux\", \"Mic\", \"Mic LNA\"},\n\t{\"Input Mux\", \"Mic + Line R\", \"Mic LNA\"},\n\t{\"Input Mux\", \"Line L\", \"Left PGA\"},\n\t{\"Input Mux\", \"Line\", \"Left PGA\"},\n\n\t \n\t{\"Right ADC\", \"Mic + Line R\", \"Right PGA\"},\n\t{\"Right ADC\", \"Line\", \"Right PGA\"},\n\n\t \n\t{\"Mic LNA\", NULL, \"VINM\"},\n\t{\"Left PGA\", NULL, \"VINL\"},\n\t{\"Right PGA\", NULL, \"VINR\"},\n};\n\nstatic int uda1380_set_dai_fmt_both(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint iface;\n\n\t \n\tiface = uda1380_read_reg_cache(component, UDA1380_IFACE);\n\tiface &= ~(R01_SFORI_MASK | R01_SIM | R01_SFORO_MASK);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= R01_SFORI_I2S | R01_SFORO_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tiface |= R01_SFORI_LSB16 | R01_SFORO_LSB16;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tiface |= R01_SFORI_MSB | R01_SFORO_MSB;\n\t}\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC)\n\t\treturn -EINVAL;\n\n\tuda1380_write_reg_cache(component, UDA1380_IFACE, iface);\n\n\treturn 0;\n}\n\nstatic int uda1380_set_dai_fmt_playback(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint iface;\n\n\t \n\tiface = uda1380_read_reg_cache(component, UDA1380_IFACE);\n\tiface &= ~R01_SFORI_MASK;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= R01_SFORI_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tiface |= R01_SFORI_LSB16;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tiface |= R01_SFORI_MSB;\n\t}\n\n\t \n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC)\n\t\treturn -EINVAL;\n\n\tuda1380_write(component, UDA1380_IFACE, iface);\n\n\treturn 0;\n}\n\nstatic int uda1380_set_dai_fmt_capture(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint iface;\n\n\t \n\tiface = uda1380_read_reg_cache(component, UDA1380_IFACE);\n\tiface &= ~(R01_SIM | R01_SFORO_MASK);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= R01_SFORO_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LSB:\n\t\tiface |= R01_SFORO_LSB16;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_MSB:\n\t\tiface |= R01_SFORO_MSB;\n\t}\n\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) == SND_SOC_DAIFMT_CBP_CFP)\n\t\tiface |= R01_SIM;\n\n\tuda1380_write(component, UDA1380_IFACE, iface);\n\n\treturn 0;\n}\n\nstatic int uda1380_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tint mixer = uda1380_read_reg_cache(component, UDA1380_MIXER);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tuda1380_write_reg_cache(component, UDA1380_MIXER,\n\t\t\t\t\tmixer & ~R14_SILENCE);\n\t\tschedule_work(&uda1380->work);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\tuda1380_write_reg_cache(component, UDA1380_MIXER,\n\t\t\t\t\tmixer | R14_SILENCE);\n\t\tschedule_work(&uda1380->work);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int uda1380_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 clk = uda1380_read_reg_cache(component, UDA1380_CLK);\n\n\t \n\tif (clk & R00_DAC_CLK) {\n\t\tint rate = params_rate(params);\n\t\tu16 pm = uda1380_read_reg_cache(component, UDA1380_PM);\n\t\tclk &= ~0x3;  \n\t\tswitch (rate) {\n\t\tcase 6250 ... 12500:\n\t\t\tclk |= 0x0;\n\t\t\tbreak;\n\t\tcase 12501 ... 25000:\n\t\t\tclk |= 0x1;\n\t\t\tbreak;\n\t\tcase 25001 ... 50000:\n\t\t\tclk |= 0x2;\n\t\t\tbreak;\n\t\tcase 50001 ... 100000:\n\t\t\tclk |= 0x3;\n\t\t\tbreak;\n\t\t}\n\t\tuda1380_write(component, UDA1380_PM, R02_PON_PLL | pm);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tclk |= R00_EN_DAC | R00_EN_INT;\n\telse\n\t\tclk |= R00_EN_ADC | R00_EN_DEC;\n\n\tuda1380_write(component, UDA1380_CLK, clk);\n\treturn 0;\n}\n\nstatic void uda1380_pcm_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 clk = uda1380_read_reg_cache(component, UDA1380_CLK);\n\n\t \n\tif (clk & R00_DAC_CLK) {\n\t\tu16 pm = uda1380_read_reg_cache(component, UDA1380_PM);\n\t\tuda1380_write(component, UDA1380_PM, ~R02_PON_PLL & pm);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tclk &= ~(R00_EN_DAC | R00_EN_INT);\n\telse\n\t\tclk &= ~(R00_EN_ADC | R00_EN_DEC);\n\n\tuda1380_write(component, UDA1380_CLK, clk);\n}\n\nstatic int uda1380_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tint pm = uda1380_read_reg_cache(component, UDA1380_PM);\n\tint reg;\n\tstruct uda1380_platform_data *pdata = component->dev->platform_data;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tuda1380_write(component, UDA1380_PM, R02_PON_BIAS | pm);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tif (gpio_is_valid(pdata->gpio_power)) {\n\t\t\t\tgpio_set_value(pdata->gpio_power, 1);\n\t\t\t\tmdelay(1);\n\t\t\t\tuda1380_reset(component);\n\t\t\t}\n\n\t\t\tuda1380_sync_cache(component);\n\t\t}\n\t\tuda1380_write(component, UDA1380_PM, 0x0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tif (!gpio_is_valid(pdata->gpio_power))\n\t\t\tbreak;\n\n\t\tgpio_set_value(pdata->gpio_power, 0);\n\n\t\t \n\t\tfor (reg = UDA1380_MVOL; reg < UDA1380_CACHEREGNUM; reg++)\n\t\t\tset_bit(reg - 0x10, &uda1380_cache_dirty);\n\t}\n\treturn 0;\n}\n\n#define UDA1380_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\t       SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\t       SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n\nstatic const struct snd_soc_dai_ops uda1380_dai_ops = {\n\t.hw_params\t= uda1380_pcm_hw_params,\n\t.shutdown\t= uda1380_pcm_shutdown,\n\t.trigger\t= uda1380_trigger,\n\t.set_fmt\t= uda1380_set_dai_fmt_both,\n};\n\nstatic const struct snd_soc_dai_ops uda1380_dai_ops_playback = {\n\t.hw_params\t= uda1380_pcm_hw_params,\n\t.shutdown\t= uda1380_pcm_shutdown,\n\t.trigger\t= uda1380_trigger,\n\t.set_fmt\t= uda1380_set_dai_fmt_playback,\n};\n\nstatic const struct snd_soc_dai_ops uda1380_dai_ops_capture = {\n\t.hw_params\t= uda1380_pcm_hw_params,\n\t.shutdown\t= uda1380_pcm_shutdown,\n\t.trigger\t= uda1380_trigger,\n\t.set_fmt\t= uda1380_set_dai_fmt_capture,\n};\n\nstatic struct snd_soc_dai_driver uda1380_dai[] = {\n{\n\t.name = \"uda1380-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = UDA1380_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = UDA1380_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &uda1380_dai_ops,\n},\n{  \n\t.name = \"uda1380-hifi-playback\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = UDA1380_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &uda1380_dai_ops_playback,\n},\n{  \n\t.name = \"uda1380-hifi-capture\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = UDA1380_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &uda1380_dai_ops_capture,\n},\n};\n\nstatic int uda1380_probe(struct snd_soc_component *component)\n{\n\tstruct uda1380_platform_data *pdata =component->dev->platform_data;\n\tstruct uda1380_priv *uda1380 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tuda1380->component = component;\n\n\tif (!gpio_is_valid(pdata->gpio_power)) {\n\t\tret = uda1380_reset(component);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tINIT_WORK(&uda1380->work, uda1380_flush_work);\n\n\t \n\tswitch (pdata->dac_clk) {\n\tcase UDA1380_DAC_CLK_SYSCLK:\n\t\tuda1380_write_reg_cache(component, UDA1380_CLK, 0);\n\t\tbreak;\n\tcase UDA1380_DAC_CLK_WSPLL:\n\t\tuda1380_write_reg_cache(component, UDA1380_CLK,\n\t\t\tR00_DAC_CLK);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_uda1380 = {\n\t.probe\t\t\t= uda1380_probe,\n\t.read\t\t\t= uda1380_read_reg_cache,\n\t.write\t\t\t= uda1380_write,\n\t.set_bias_level\t\t= uda1380_set_bias_level,\n\t.controls\t\t= uda1380_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(uda1380_snd_controls),\n\t.dapm_widgets\t\t= uda1380_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(uda1380_dapm_widgets),\n\t.dapm_routes\t\t= uda1380_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(uda1380_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int uda1380_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct uda1380_platform_data *pdata = i2c->dev.platform_data;\n\tstruct uda1380_priv *uda1380;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tuda1380 = devm_kzalloc(&i2c->dev, sizeof(struct uda1380_priv),\n\t\t\t       GFP_KERNEL);\n\tif (uda1380 == NULL)\n\t\treturn -ENOMEM;\n\n\tif (gpio_is_valid(pdata->gpio_reset)) {\n\t\tret = devm_gpio_request_one(&i2c->dev, pdata->gpio_reset,\n\t\t\tGPIOF_OUT_INIT_LOW, \"uda1380 reset\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (gpio_is_valid(pdata->gpio_power)) {\n\t\tret = devm_gpio_request_one(&i2c->dev, pdata->gpio_power,\n\t\t\tGPIOF_OUT_INIT_LOW, \"uda1380 power\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tuda1380->reg_cache = devm_kmemdup(&i2c->dev,\n\t\t\t\t\tuda1380_reg,\n\t\t\t\t\tARRAY_SIZE(uda1380_reg) * sizeof(u16),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!uda1380->reg_cache)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, uda1380);\n\tuda1380->i2c = i2c;\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_uda1380, uda1380_dai, ARRAY_SIZE(uda1380_dai));\n\treturn ret;\n}\n\nstatic const struct i2c_device_id uda1380_i2c_id[] = {\n\t{ \"uda1380\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, uda1380_i2c_id);\n\nstatic const struct of_device_id uda1380_of_match[] = {\n\t{ .compatible = \"nxp,uda1380\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, uda1380_of_match);\n\nstatic struct i2c_driver uda1380_i2c_driver = {\n\t.driver = {\n\t\t.name =  \"uda1380-codec\",\n\t\t.of_match_table = uda1380_of_match,\n\t},\n\t.probe = uda1380_i2c_probe,\n\t.id_table = uda1380_i2c_id,\n};\n\nmodule_i2c_driver(uda1380_i2c_driver);\n\nMODULE_AUTHOR(\"Giorgio Padrin\");\nMODULE_DESCRIPTION(\"Audio support for codec Philips UDA1380\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}