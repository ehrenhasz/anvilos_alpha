{
  "module_name": "ssm2518.c",
  "hash_id": "b5cb3235b662ae5d92ca84c1d4407470b58f510b9ce1118c0e4badfa700d8cb5",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ssm2518.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"ssm2518.h\"\n\n#define SSM2518_REG_POWER1\t\t0x00\n#define SSM2518_REG_CLOCK\t\t0x01\n#define SSM2518_REG_SAI_CTRL1\t\t0x02\n#define SSM2518_REG_SAI_CTRL2\t\t0x03\n#define SSM2518_REG_CHAN_MAP\t\t0x04\n#define SSM2518_REG_LEFT_VOL\t\t0x05\n#define SSM2518_REG_RIGHT_VOL\t\t0x06\n#define SSM2518_REG_MUTE_CTRL\t\t0x07\n#define SSM2518_REG_FAULT_CTRL\t\t0x08\n#define SSM2518_REG_POWER2\t\t0x09\n#define SSM2518_REG_DRC_1\t\t0x0a\n#define SSM2518_REG_DRC_2\t\t0x0b\n#define SSM2518_REG_DRC_3\t\t0x0c\n#define SSM2518_REG_DRC_4\t\t0x0d\n#define SSM2518_REG_DRC_5\t\t0x0e\n#define SSM2518_REG_DRC_6\t\t0x0f\n#define SSM2518_REG_DRC_7\t\t0x10\n#define SSM2518_REG_DRC_8\t\t0x11\n#define SSM2518_REG_DRC_9\t\t0x12\n\n#define SSM2518_POWER1_RESET\t\t\tBIT(7)\n#define SSM2518_POWER1_NO_BCLK\t\t\tBIT(5)\n#define SSM2518_POWER1_MCS_MASK\t\t\t(0xf << 1)\n#define SSM2518_POWER1_MCS_64FS\t\t\t(0x0 << 1)\n#define SSM2518_POWER1_MCS_128FS\t\t(0x1 << 1)\n#define SSM2518_POWER1_MCS_256FS\t\t(0x2 << 1)\n#define SSM2518_POWER1_MCS_384FS\t\t(0x3 << 1)\n#define SSM2518_POWER1_MCS_512FS\t\t(0x4 << 1)\n#define SSM2518_POWER1_MCS_768FS\t\t(0x5 << 1)\n#define SSM2518_POWER1_MCS_100FS\t\t(0x6 << 1)\n#define SSM2518_POWER1_MCS_200FS\t\t(0x7 << 1)\n#define SSM2518_POWER1_MCS_400FS\t\t(0x8 << 1)\n#define SSM2518_POWER1_SPWDN\t\t\tBIT(0)\n\n#define SSM2518_CLOCK_ASR\t\t\tBIT(0)\n\n#define SSM2518_SAI_CTRL1_FMT_MASK\t\t(0x3 << 5)\n#define SSM2518_SAI_CTRL1_FMT_I2S\t\t(0x0 << 5)\n#define SSM2518_SAI_CTRL1_FMT_LJ\t\t(0x1 << 5)\n#define SSM2518_SAI_CTRL1_FMT_RJ_24BIT\t\t(0x2 << 5)\n#define SSM2518_SAI_CTRL1_FMT_RJ_16BIT\t\t(0x3 << 5)\n\n#define SSM2518_SAI_CTRL1_SAI_MASK\t\t(0x7 << 2)\n#define SSM2518_SAI_CTRL1_SAI_I2S\t\t(0x0 << 2)\n#define SSM2518_SAI_CTRL1_SAI_TDM_2\t\t(0x1 << 2)\n#define SSM2518_SAI_CTRL1_SAI_TDM_4\t\t(0x2 << 2)\n#define SSM2518_SAI_CTRL1_SAI_TDM_8\t\t(0x3 << 2)\n#define SSM2518_SAI_CTRL1_SAI_TDM_16\t\t(0x4 << 2)\n#define SSM2518_SAI_CTRL1_SAI_MONO\t\t(0x5 << 2)\n\n#define SSM2518_SAI_CTRL1_FS_MASK\t\t(0x3)\n#define SSM2518_SAI_CTRL1_FS_8000_12000\t\t(0x0)\n#define SSM2518_SAI_CTRL1_FS_16000_24000\t(0x1)\n#define SSM2518_SAI_CTRL1_FS_32000_48000\t(0x2)\n#define SSM2518_SAI_CTRL1_FS_64000_96000\t(0x3)\n\n#define SSM2518_SAI_CTRL2_BCLK_INTERAL\t\tBIT(7)\n#define SSM2518_SAI_CTRL2_LRCLK_PULSE\t\tBIT(6)\n#define SSM2518_SAI_CTRL2_LRCLK_INVERT\t\tBIT(5)\n#define SSM2518_SAI_CTRL2_MSB\t\t\tBIT(4)\n#define SSM2518_SAI_CTRL2_SLOT_WIDTH_MASK\t(0x3 << 2)\n#define SSM2518_SAI_CTRL2_SLOT_WIDTH_32\t\t(0x0 << 2)\n#define SSM2518_SAI_CTRL2_SLOT_WIDTH_24\t\t(0x1 << 2)\n#define SSM2518_SAI_CTRL2_SLOT_WIDTH_16\t\t(0x2 << 2)\n#define SSM2518_SAI_CTRL2_BCLK_INVERT\t\tBIT(1)\n\n#define SSM2518_CHAN_MAP_RIGHT_SLOT_OFFSET\t4\n#define SSM2518_CHAN_MAP_RIGHT_SLOT_MASK\t0xf0\n#define SSM2518_CHAN_MAP_LEFT_SLOT_OFFSET\t0\n#define SSM2518_CHAN_MAP_LEFT_SLOT_MASK\t\t0x0f\n\n#define SSM2518_MUTE_CTRL_ANA_GAIN\t\tBIT(5)\n#define SSM2518_MUTE_CTRL_MUTE_MASTER\t\tBIT(0)\n\n#define SSM2518_POWER2_APWDN\t\t\tBIT(0)\n\n#define SSM2518_DAC_MUTE\t\t\tBIT(6)\n#define SSM2518_DAC_FS_MASK\t\t\t0x07\n#define SSM2518_DAC_FS_8000\t\t\t0x00\n#define SSM2518_DAC_FS_16000\t\t\t0x01\n#define SSM2518_DAC_FS_32000\t\t\t0x02\n#define SSM2518_DAC_FS_64000\t\t\t0x03\n#define SSM2518_DAC_FS_128000\t\t\t0x04\n\nstruct ssm2518 {\n\tstruct regmap *regmap;\n\tbool right_j;\n\n\tunsigned int sysclk;\n\tconst struct snd_pcm_hw_constraint_list *constraints;\n\n\tstruct gpio_desc *enable_gpio;\n};\n\nstatic const struct reg_default ssm2518_reg_defaults[] = {\n\t{ 0x00, 0x05 },\n\t{ 0x01, 0x00 },\n\t{ 0x02, 0x02 },\n\t{ 0x03, 0x00 },\n\t{ 0x04, 0x10 },\n\t{ 0x05, 0x40 },\n\t{ 0x06, 0x40 },\n\t{ 0x07, 0x81 },\n\t{ 0x08, 0x0c },\n\t{ 0x09, 0x99 },\n\t{ 0x0a, 0x7c },\n\t{ 0x0b, 0x5b },\n\t{ 0x0c, 0x57 },\n\t{ 0x0d, 0x89 },\n\t{ 0x0e, 0x8c },\n\t{ 0x0f, 0x77 },\n\t{ 0x10, 0x26 },\n\t{ 0x11, 0x1c },\n\t{ 0x12, 0x97 },\n};\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(ssm2518_vol_tlv, -7125, 2400);\nstatic const DECLARE_TLV_DB_SCALE(ssm2518_compressor_tlv, -3400, 200, 0);\nstatic const DECLARE_TLV_DB_SCALE(ssm2518_expander_tlv, -8100, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(ssm2518_noise_gate_tlv, -9600, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(ssm2518_post_drc_tlv, -2400, 300, 0);\n\nstatic const DECLARE_TLV_DB_RANGE(ssm2518_limiter_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-2200, 200, 0),\n\t7, 15, TLV_DB_SCALE_ITEM(-800, 100, 0),\n);\n\nstatic const char * const ssm2518_drc_peak_detector_attack_time_text[] = {\n\t\"0 ms\", \"0.1 ms\", \"0.19 ms\", \"0.37 ms\", \"0.75 ms\", \"1.5 ms\", \"3 ms\",\n\t\"6 ms\", \"12 ms\", \"24 ms\", \"48 ms\", \"96 ms\", \"192 ms\", \"384 ms\",\n\t\"768 ms\", \"1536 ms\",\n};\n\nstatic const char * const ssm2518_drc_peak_detector_release_time_text[] = {\n\t\"0 ms\", \"1.5 ms\", \"3 ms\", \"6 ms\", \"12 ms\", \"24 ms\", \"48 ms\", \"96 ms\",\n\t\"192 ms\", \"384 ms\", \"768 ms\", \"1536 ms\", \"3072 ms\", \"6144 ms\",\n\t\"12288 ms\", \"24576 ms\"\n};\n\nstatic const char * const ssm2518_drc_hold_time_text[] = {\n\t\"0 ms\", \"0.67 ms\", \"1.33 ms\", \"2.67 ms\", \"5.33 ms\", \"10.66 ms\",\n\t\"21.32 ms\", \"42.64 ms\", \"85.28 ms\", \"170.56 ms\", \"341.12 ms\",\n\t\"682.24 ms\", \"1364 ms\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_peak_detector_attack_time_enum,\n\tSSM2518_REG_DRC_2, 4, ssm2518_drc_peak_detector_attack_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_peak_detector_release_time_enum,\n\tSSM2518_REG_DRC_2, 0, ssm2518_drc_peak_detector_release_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_attack_time_enum,\n\tSSM2518_REG_DRC_6, 4, ssm2518_drc_peak_detector_attack_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_decay_time_enum,\n\tSSM2518_REG_DRC_6, 0, ssm2518_drc_peak_detector_release_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_hold_time_enum,\n\tSSM2518_REG_DRC_7, 4, ssm2518_drc_hold_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_noise_gate_hold_time_enum,\n\tSSM2518_REG_DRC_7, 0, ssm2518_drc_hold_time_text);\nstatic SOC_ENUM_SINGLE_DECL(ssm2518_drc_rms_averaging_time_enum,\n\tSSM2518_REG_DRC_9, 0, ssm2518_drc_peak_detector_release_time_text);\n\nstatic const struct snd_kcontrol_new ssm2518_snd_controls[] = {\n\tSOC_SINGLE(\"Playback De-emphasis Switch\", SSM2518_REG_MUTE_CTRL,\n\t\t\t4, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\", SSM2518_REG_LEFT_VOL,\n\t\t\tSSM2518_REG_RIGHT_VOL, 0, 0xff, 1, ssm2518_vol_tlv),\n\tSOC_DOUBLE(\"Master Playback Switch\", SSM2518_REG_MUTE_CTRL, 2, 1, 1, 1),\n\n\tSOC_SINGLE(\"Amp Low Power Mode Switch\", SSM2518_REG_POWER2, 4, 1, 0),\n\tSOC_SINGLE(\"DAC Low Power Mode Switch\", SSM2518_REG_POWER2, 3, 1, 0),\n\n\tSOC_SINGLE(\"DRC Limiter Switch\", SSM2518_REG_DRC_1, 5, 1, 0),\n\tSOC_SINGLE(\"DRC Compressor Switch\", SSM2518_REG_DRC_1, 4, 1, 0),\n\tSOC_SINGLE(\"DRC Expander Switch\", SSM2518_REG_DRC_1, 3, 1, 0),\n\tSOC_SINGLE(\"DRC Noise Gate Switch\", SSM2518_REG_DRC_1, 2, 1, 0),\n\tSOC_DOUBLE(\"DRC Switch\", SSM2518_REG_DRC_1, 0, 1, 1, 0),\n\n\tSOC_SINGLE_TLV(\"DRC Limiter Threshold Volume\",\n\t\t\tSSM2518_REG_DRC_3, 4, 15, 1, ssm2518_limiter_tlv),\n\tSOC_SINGLE_TLV(\"DRC Compressor Lower Threshold Volume\",\n\t\t\tSSM2518_REG_DRC_3, 0, 15, 1, ssm2518_compressor_tlv),\n\tSOC_SINGLE_TLV(\"DRC Expander Upper Threshold Volume\", SSM2518_REG_DRC_4,\n\t\t\t4, 15, 1, ssm2518_expander_tlv),\n\tSOC_SINGLE_TLV(\"DRC Noise Gate Threshold Volume\",\n\t\t\tSSM2518_REG_DRC_4, 0, 15, 1, ssm2518_noise_gate_tlv),\n\tSOC_SINGLE_TLV(\"DRC Upper Output Threshold Volume\",\n\t\t\tSSM2518_REG_DRC_5, 4, 15, 1, ssm2518_limiter_tlv),\n\tSOC_SINGLE_TLV(\"DRC Lower Output Threshold Volume\",\n\t\t\tSSM2518_REG_DRC_5, 0, 15, 1, ssm2518_noise_gate_tlv),\n\tSOC_SINGLE_TLV(\"DRC Post Volume\", SSM2518_REG_DRC_8,\n\t\t\t2, 15, 1, ssm2518_post_drc_tlv),\n\n\tSOC_ENUM(\"DRC Peak Detector Attack Time\",\n\t\tssm2518_drc_peak_detector_attack_time_enum),\n\tSOC_ENUM(\"DRC Peak Detector Release Time\",\n\t\tssm2518_drc_peak_detector_release_time_enum),\n\tSOC_ENUM(\"DRC Attack Time\", ssm2518_drc_attack_time_enum),\n\tSOC_ENUM(\"DRC Decay Time\", ssm2518_drc_decay_time_enum),\n\tSOC_ENUM(\"DRC Hold Time\", ssm2518_drc_hold_time_enum),\n\tSOC_ENUM(\"DRC Noise Gate Hold Time\",\n\t\tssm2518_drc_noise_gate_hold_time_enum),\n\tSOC_ENUM(\"DRC RMS Averaging Time\", ssm2518_drc_rms_averaging_time_enum),\n};\n\nstatic const struct snd_soc_dapm_widget ssm2518_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DACL\", \"HiFi Playback\", SSM2518_REG_POWER2, 1, 1),\n\tSND_SOC_DAPM_DAC(\"DACR\", \"HiFi Playback\", SSM2518_REG_POWER2, 2, 1),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUTR\"),\n};\n\nstatic const struct snd_soc_dapm_route ssm2518_routes[] = {\n\t{ \"OUTL\", NULL, \"DACL\" },\n\t{ \"OUTR\", NULL, \"DACR\" },\n};\n\nstruct ssm2518_mcs_lut {\n\tunsigned int rate;\n\tconst unsigned int *sysclks;\n};\n\nstatic const unsigned int ssm2518_sysclks_2048000[] = {\n\t2048000, 4096000, 8192000, 12288000, 16384000, 24576000,\n\t3200000, 6400000, 12800000, 0\n};\n\nstatic const unsigned int ssm2518_sysclks_2822000[] = {\n\t2822000, 5644800, 11289600, 16934400, 22579200, 33868800,\n\t4410000, 8820000, 17640000, 0\n};\n\nstatic const unsigned int ssm2518_sysclks_3072000[] = {\n\t3072000, 6144000, 12288000, 16384000, 24576000, 38864000,\n\t4800000, 9600000, 19200000, 0\n};\n\nstatic const struct ssm2518_mcs_lut ssm2518_mcs_lut[] = {\n\t{ 8000,  ssm2518_sysclks_2048000, },\n\t{ 11025, ssm2518_sysclks_2822000, },\n\t{ 12000, ssm2518_sysclks_3072000, },\n\t{ 16000, ssm2518_sysclks_2048000, },\n\t{ 24000, ssm2518_sysclks_3072000, },\n\t{ 22050, ssm2518_sysclks_2822000, },\n\t{ 32000, ssm2518_sysclks_2048000, },\n\t{ 44100, ssm2518_sysclks_2822000, },\n\t{ 48000, ssm2518_sysclks_3072000, },\n\t{ 96000, ssm2518_sysclks_3072000, },\n};\n\nstatic const unsigned int ssm2518_rates_2048000[] = {\n\t8000, 16000, 32000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2518_constraints_2048000 = {\n\t.list = ssm2518_rates_2048000,\n\t.count = ARRAY_SIZE(ssm2518_rates_2048000),\n};\n\nstatic const unsigned int ssm2518_rates_2822000[] = {\n\t11025, 22050, 44100,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2518_constraints_2822000 = {\n\t.list = ssm2518_rates_2822000,\n\t.count = ARRAY_SIZE(ssm2518_rates_2822000),\n};\n\nstatic const unsigned int ssm2518_rates_3072000[] = {\n\t12000, 24000, 48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2518_constraints_3072000 = {\n\t.list = ssm2518_rates_3072000,\n\t.count = ARRAY_SIZE(ssm2518_rates_3072000),\n};\n\nstatic const unsigned int ssm2518_rates_12288000[] = {\n\t8000, 12000, 16000, 24000, 32000, 48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ssm2518_constraints_12288000 = {\n\t.list = ssm2518_rates_12288000,\n\t.count = ARRAY_SIZE(ssm2518_rates_12288000),\n};\n\nstatic int ssm2518_lookup_mcs(struct ssm2518 *ssm2518,\n\tunsigned int rate)\n{\n\tconst unsigned int *sysclks = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssm2518_mcs_lut); i++) {\n\t\tif (ssm2518_mcs_lut[i].rate == rate) {\n\t\t\tsysclks = ssm2518_mcs_lut[i].sysclks;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!sysclks)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; sysclks[i]; i++) {\n\t\tif (sysclks[i] == ssm2518->sysclk)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ssm2518_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(component);\n\tunsigned int rate = params_rate(params);\n\tunsigned int ctrl1, ctrl1_mask;\n\tint mcs;\n\tint ret;\n\n\tmcs = ssm2518_lookup_mcs(ssm2518, rate);\n\tif (mcs < 0)\n\t\treturn mcs;\n\n\tctrl1_mask = SSM2518_SAI_CTRL1_FS_MASK;\n\n\tif (rate >= 8000 && rate <= 12000)\n\t\tctrl1 = SSM2518_SAI_CTRL1_FS_8000_12000;\n\telse if (rate >= 16000 && rate <= 24000)\n\t\tctrl1 = SSM2518_SAI_CTRL1_FS_16000_24000;\n\telse if (rate >= 32000 && rate <= 48000)\n\t\tctrl1 = SSM2518_SAI_CTRL1_FS_32000_48000;\n\telse if (rate >= 64000 && rate <= 96000)\n\t\tctrl1 = SSM2518_SAI_CTRL1_FS_64000_96000;\n\telse\n\t\treturn -EINVAL;\n\n\tif (ssm2518->right_j) {\n\t\tswitch (params_width(params)) {\n\t\tcase 16:\n\t\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_16BIT;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_24BIT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctrl1_mask |= SSM2518_SAI_CTRL1_FMT_MASK;\n\t}\n\n\t \n\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_CLOCK,\n\t\t\t\tSSM2518_CLOCK_ASR, SSM2518_CLOCK_ASR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL1,\n\t\t\t\tctrl1_mask, ctrl1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\n\t\t\t\tSSM2518_POWER1_MCS_MASK, mcs << 1);\n}\n\nstatic int ssm2518_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int val;\n\n\tif (mute)\n\t\tval = SSM2518_MUTE_CTRL_MUTE_MASTER;\n\telse\n\t\tval = 0;\n\n\treturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_MUTE_CTRL,\n\t\t\tSSM2518_MUTE_CTRL_MUTE_MASTER, val);\n}\n\nstatic int ssm2518_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ctrl1 = 0, ctrl2 = 0;\n\tbool invert_fclk;\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tinvert_fclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl2 |= SSM2518_SAI_CTRL2_BCLK_INVERT;\n\t\tinvert_fclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert_fclk = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tctrl2 |= SSM2518_SAI_CTRL2_BCLK_INVERT;\n\t\tinvert_fclk = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tssm2518->right_j = false;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_LJ;\n\t\tinvert_fclk = !invert_fclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_RJ_24BIT;\n\t\tssm2518->right_j = true;\n\t\tinvert_fclk = !invert_fclk;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl2 |= SSM2518_SAI_CTRL2_LRCLK_PULSE;\n\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_I2S;\n\t\tinvert_fclk = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl2 |= SSM2518_SAI_CTRL2_LRCLK_PULSE;\n\t\tctrl1 |= SSM2518_SAI_CTRL1_FMT_LJ;\n\t\tinvert_fclk = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (invert_fclk)\n\t\tctrl2 |= SSM2518_SAI_CTRL2_LRCLK_INVERT;\n\n\tret = regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL1, ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(ssm2518->regmap, SSM2518_REG_SAI_CTRL2, ctrl2);\n}\n\nstatic int ssm2518_set_power(struct ssm2518 *ssm2518, bool enable)\n{\n\tint ret = 0;\n\n\tif (!enable) {\n\t\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\n\t\t\tSSM2518_POWER1_SPWDN, SSM2518_POWER1_SPWDN);\n\t\tregcache_mark_dirty(ssm2518->regmap);\n\t}\n\n\tif (ssm2518->enable_gpio)\n\t\tgpiod_set_value_cansleep(ssm2518->enable_gpio, enable);\n\n\tregcache_cache_only(ssm2518->regmap, !enable);\n\n\tif (enable) {\n\t\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\n\t\t\tSSM2518_POWER1_SPWDN | SSM2518_POWER1_RESET, 0x00);\n\t\tregcache_sync(ssm2518->regmap);\n\t}\n\n\treturn ret;\n}\n\nstatic int ssm2518_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tret = ssm2518_set_power(ssm2518, true);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tret = ssm2518_set_power(ssm2518, false);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ssm2518_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\tunsigned int rx_mask, int slots, int width)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ctrl1, ctrl2;\n\tint left_slot, right_slot;\n\tint ret;\n\n\tif (slots == 0)\n\t\treturn regmap_update_bits(ssm2518->regmap,\n\t\t\tSSM2518_REG_SAI_CTRL1, SSM2518_SAI_CTRL1_SAI_MASK,\n\t\t\tSSM2518_SAI_CTRL1_SAI_I2S);\n\n\tif (tx_mask == 0 || rx_mask != 0)\n\t\treturn -EINVAL;\n\n\tif (slots == 1) {\n\t\tif (tx_mask != 1)\n\t\t\treturn -EINVAL;\n\t\tleft_slot = 0;\n\t\tright_slot = 0;\n\t} else {\n\t\t \n\t\tleft_slot = __ffs(tx_mask);\n\t\ttx_mask &= ~(1 << left_slot);\n\t\tif (tx_mask == 0) {\n\t\t\tright_slot = left_slot;\n\t\t} else {\n\t\t\tright_slot = __ffs(tx_mask);\n\t\t\ttx_mask &= ~(1 << right_slot);\n\t\t}\n\t}\n\n\tif (tx_mask != 0 || left_slot >= slots || right_slot >= slots)\n\t\treturn -EINVAL;\n\n\tswitch (width) {\n\tcase 16:\n\t\tctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_16;\n\t\tbreak;\n\tcase 24:\n\t\tctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_24;\n\t\tbreak;\n\tcase 32:\n\t\tctrl2 = SSM2518_SAI_CTRL2_SLOT_WIDTH_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (slots) {\n\tcase 1:\n\t\tctrl1 = SSM2518_SAI_CTRL1_SAI_MONO;\n\t\tbreak;\n\tcase 2:\n\t\tctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_2;\n\t\tbreak;\n\tcase 4:\n\t\tctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_4;\n\t\tbreak;\n\tcase 8:\n\t\tctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_8;\n\t\tbreak;\n\tcase 16:\n\t\tctrl1 = SSM2518_SAI_CTRL1_SAI_TDM_16;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(ssm2518->regmap, SSM2518_REG_CHAN_MAP,\n\t\t(left_slot << SSM2518_CHAN_MAP_LEFT_SLOT_OFFSET) |\n\t\t(right_slot << SSM2518_CHAN_MAP_RIGHT_SLOT_OFFSET));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL1,\n\t\tSSM2518_SAI_CTRL1_SAI_MASK, ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_SAI_CTRL2,\n\t\tSSM2518_SAI_CTRL2_SLOT_WIDTH_MASK, ctrl2);\n}\n\nstatic int ssm2518_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(dai->component);\n\n\tif (ssm2518->constraints)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE, ssm2518->constraints);\n\n\treturn 0;\n}\n\n#define SSM2518_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32)\n\nstatic const struct snd_soc_dai_ops ssm2518_dai_ops = {\n\t.startup = ssm2518_startup,\n\t.hw_params\t= ssm2518_hw_params,\n\t.mute_stream\t= ssm2518_mute,\n\t.set_fmt\t= ssm2518_set_dai_fmt,\n\t.set_tdm_slot\t= ssm2518_set_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ssm2518_dai = {\n\t.name = \"ssm2518-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SSM2518_FORMATS,\n\t},\n\t.ops = &ssm2518_dai_ops,\n};\n\nstatic int ssm2518_set_sysclk(struct snd_soc_component *component, int clk_id,\n\tint source, unsigned int freq, int dir)\n{\n\tstruct ssm2518 *ssm2518 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (clk_id != SSM2518_SYSCLK)\n\t\treturn -EINVAL;\n\n\tswitch (source) {\n\tcase SSM2518_SYSCLK_SRC_MCLK:\n\t\tval = 0;\n\t\tbreak;\n\tcase SSM2518_SYSCLK_SRC_BCLK:\n\t\t \n\t\tval = SSM2518_POWER1_NO_BCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq) {\n\tcase 0:\n\t\tssm2518->constraints = NULL;\n\t\tbreak;\n\tcase 2048000:\n\tcase 4096000:\n\tcase 8192000:\n\tcase 3200000:\n\tcase 6400000:\n\tcase 12800000:\n\t\tssm2518->constraints = &ssm2518_constraints_2048000;\n\t\tbreak;\n\tcase 2822000:\n\tcase 5644800:\n\tcase 11289600:\n\tcase 16934400:\n\tcase 22579200:\n\tcase 33868800:\n\tcase 4410000:\n\tcase 8820000:\n\tcase 17640000:\n\t\tssm2518->constraints = &ssm2518_constraints_2822000;\n\t\tbreak;\n\tcase 3072000:\n\tcase 6144000:\n\tcase 38864000:\n\tcase 4800000:\n\tcase 9600000:\n\tcase 19200000:\n\t\tssm2518->constraints = &ssm2518_constraints_3072000;\n\t\tbreak;\n\tcase 12288000:\n\tcase 16384000:\n\tcase 24576000:\n\t\tssm2518->constraints = &ssm2518_constraints_12288000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tssm2518->sysclk = freq;\n\n\treturn regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER1,\n\t\t\tSSM2518_POWER1_NO_BCLK, val);\n}\n\nstatic const struct snd_soc_component_driver ssm2518_component_driver = {\n\t.set_bias_level\t\t= ssm2518_set_bias_level,\n\t.set_sysclk\t\t= ssm2518_set_sysclk,\n\t.controls\t\t= ssm2518_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ssm2518_snd_controls),\n\t.dapm_widgets\t\t= ssm2518_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ssm2518_dapm_widgets),\n\t.dapm_routes\t\t= ssm2518_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(ssm2518_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ssm2518_regmap_config = {\n\t.val_bits = 8,\n\t.reg_bits = 8,\n\n\t.max_register = SSM2518_REG_DRC_9,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = ssm2518_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ssm2518_reg_defaults),\n};\n\nstatic int ssm2518_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ssm2518 *ssm2518;\n\tint ret;\n\n\tssm2518 = devm_kzalloc(&i2c->dev, sizeof(*ssm2518), GFP_KERNEL);\n\tif (ssm2518 == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tssm2518->enable_gpio = devm_gpiod_get_optional(&i2c->dev, NULL,\n\t\t\t\t\t\t       GPIOD_OUT_HIGH);\n\tret = PTR_ERR_OR_ZERO(ssm2518->enable_gpio);\n\tif (ret)\n\t\treturn ret;\n\n\tgpiod_set_consumer_name(ssm2518->enable_gpio, \"SSM2518 nSD\");\n\n\ti2c_set_clientdata(i2c, ssm2518);\n\n\tssm2518->regmap = devm_regmap_init_i2c(i2c, &ssm2518_regmap_config);\n\tif (IS_ERR(ssm2518->regmap))\n\t\treturn PTR_ERR(ssm2518->regmap);\n\n\t \n\tregcache_cache_bypass(ssm2518->regmap, true);\n\tret = regmap_write(ssm2518->regmap, SSM2518_REG_POWER1,\n\t\t\tSSM2518_POWER1_RESET);\n\tregcache_cache_bypass(ssm2518->regmap, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(ssm2518->regmap, SSM2518_REG_POWER2,\n\t\t\t\tSSM2518_POWER2_APWDN, 0x00);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ssm2518_set_power(ssm2518, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&ssm2518_component_driver,\n\t\t\t&ssm2518_dai, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ssm2518_dt_ids[] = {\n\t{ .compatible = \"adi,ssm2518\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ssm2518_dt_ids);\n#endif\n\nstatic const struct i2c_device_id ssm2518_i2c_ids[] = {\n\t{ \"ssm2518\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ssm2518_i2c_ids);\n\nstatic struct i2c_driver ssm2518_driver = {\n\t.driver = {\n\t\t.name = \"ssm2518\",\n\t\t.of_match_table = of_match_ptr(ssm2518_dt_ids),\n\t},\n\t.probe = ssm2518_i2c_probe,\n\t.id_table = ssm2518_i2c_ids,\n};\nmodule_i2c_driver(ssm2518_driver);\n\nMODULE_DESCRIPTION(\"ASoC SSM2518 driver\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}