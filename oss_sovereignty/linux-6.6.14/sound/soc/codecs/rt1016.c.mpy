{
  "module_name": "rt1016.c",
  "hash_id": "dc5c80ddd162e4f3e1e9b2a56559466a838f70f64378d3e886c1a087af8acf9d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1016.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/platform_device.h>\n#include <linux/firmware.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rl6231.h\"\n#include \"rt1016.h\"\n\nstatic const struct reg_sequence rt1016_patch[] = {\n\t{RT1016_VOL_CTRL_3,\t0x8900},\n\t{RT1016_ANA_CTRL_1,\t0xa002},\n\t{RT1016_ANA_CTRL_2,\t0x0002},\n\t{RT1016_CLOCK_4,\t0x6700},\n\t{RT1016_CLASSD_3,\t0xdc55},\n\t{RT1016_CLASSD_4,\t0x376a},\n\t{RT1016_CLASSD_5,\t0x009f},\n};\n\nstatic const struct reg_default rt1016_reg[] = {\n\t{0x00, 0x0000},\n\t{0x01, 0x5400},\n\t{0x02, 0x5506},\n\t{0x03, 0xf800},\n\t{0x04, 0x0000},\n\t{0x05, 0xbfbf},\n\t{0x06, 0x8900},\n\t{0x07, 0xa002},\n\t{0x08, 0x0000},\n\t{0x09, 0x0000},\n\t{0x0a, 0x0000},\n\t{0x0c, 0x0000},\n\t{0x0d, 0x0000},\n\t{0x0e, 0x10ec},\n\t{0x0f, 0x6595},\n\t{0x11, 0x0002},\n\t{0x1c, 0x0000},\n\t{0x1d, 0x0000},\n\t{0x1e, 0x0000},\n\t{0x1f, 0xf000},\n\t{0x20, 0x0000},\n\t{0x21, 0x6000},\n\t{0x22, 0x0000},\n\t{0x23, 0x6700},\n\t{0x24, 0x0000},\n\t{0x25, 0x0000},\n\t{0x26, 0x0000},\n\t{0x40, 0x0018},\n\t{0x60, 0x00a5},\n\t{0x80, 0x0010},\n\t{0x81, 0x0009},\n\t{0x82, 0x0000},\n\t{0x83, 0x0000},\n\t{0xa0, 0x0700},\n\t{0xc0, 0x0080},\n\t{0xc1, 0x02a0},\n\t{0xc2, 0x1400},\n\t{0xc3, 0x0a4a},\n\t{0xc4, 0x552a},\n\t{0xc5, 0x087e},\n\t{0xc6, 0x0020},\n\t{0xc7, 0xa833},\n\t{0xc8, 0x0433},\n\t{0xc9, 0x8040},\n\t{0xca, 0xdc55},\n\t{0xcb, 0x376a},\n\t{0xcc, 0x009f},\n\t{0xcf, 0x0020},\n};\n\nstatic bool rt1016_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1016_ANA_FLAG:\n\tcase RT1016_VERSION2_ID:\n\tcase RT1016_VERSION1_ID:\n\tcase RT1016_VENDER_ID:\n\tcase RT1016_DEVICE_ID:\n\tcase RT1016_TEST_SIGNAL:\n\tcase RT1016_SC_CTRL_1:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1016_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1016_RESET:\n\tcase RT1016_PADS_CTRL_1:\n\tcase RT1016_PADS_CTRL_2:\n\tcase RT1016_I2C_CTRL:\n\tcase RT1016_VOL_CTRL_1:\n\tcase RT1016_VOL_CTRL_2:\n\tcase RT1016_VOL_CTRL_3:\n\tcase RT1016_ANA_CTRL_1:\n\tcase RT1016_MUX_SEL:\n\tcase RT1016_RX_I2S_CTRL:\n\tcase RT1016_ANA_FLAG:\n\tcase RT1016_VERSION2_ID:\n\tcase RT1016_VERSION1_ID:\n\tcase RT1016_VENDER_ID:\n\tcase RT1016_DEVICE_ID:\n\tcase RT1016_ANA_CTRL_2:\n\tcase RT1016_TEST_SIGNAL:\n\tcase RT1016_TEST_CTRL_1:\n\tcase RT1016_TEST_CTRL_2:\n\tcase RT1016_TEST_CTRL_3:\n\tcase RT1016_CLOCK_1:\n\tcase RT1016_CLOCK_2:\n\tcase RT1016_CLOCK_3:\n\tcase RT1016_CLOCK_4:\n\tcase RT1016_CLOCK_5:\n\tcase RT1016_CLOCK_6:\n\tcase RT1016_CLOCK_7:\n\tcase RT1016_I2S_CTRL:\n\tcase RT1016_DAC_CTRL_1:\n\tcase RT1016_SC_CTRL_1:\n\tcase RT1016_SC_CTRL_2:\n\tcase RT1016_SC_CTRL_3:\n\tcase RT1016_SC_CTRL_4:\n\tcase RT1016_SIL_DET:\n\tcase RT1016_SYS_CLK:\n\tcase RT1016_BIAS_CUR:\n\tcase RT1016_DAC_CTRL_2:\n\tcase RT1016_LDO_CTRL:\n\tcase RT1016_CLASSD_1:\n\tcase RT1016_PLL1:\n\tcase RT1016_PLL2:\n\tcase RT1016_PLL3:\n\tcase RT1016_CLASSD_2:\n\tcase RT1016_CLASSD_OUT:\n\tcase RT1016_CLASSD_3:\n\tcase RT1016_CLASSD_4:\n\tcase RT1016_CLASSD_5:\n\tcase RT1016_PWR_CTRL:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9550, 50, 0);\n\nstatic const struct snd_kcontrol_new rt1016_snd_controls[] = {\n\tSOC_DOUBLE_TLV(\"DAC Playback Volume\", RT1016_VOL_CTRL_2,\n\t\tRT1016_L_VOL_SFT, RT1016_R_VOL_SFT, 191, 0, dac_vol_tlv),\n\tSOC_DOUBLE(\"DAC Playback Switch\", RT1016_VOL_CTRL_1,\n\t\tRT1016_DA_MUTE_L_SFT, RT1016_DA_MUTE_R_SFT, 1, 1),\n};\n\nstatic int rt1016_is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\n\tif (rt1016->sysclk_src == RT1016_SCLK_S_PLL)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic const char * const rt1016_data_select[] = {\n\t\"L/R\", \"R/L\", \"L/L\", \"R/R\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1016_if_data_swap_enum,\n\tRT1016_I2S_CTRL, RT1016_I2S_DATA_SWAP_SFT, rt1016_data_select);\n\nstatic const struct snd_kcontrol_new rt1016_if_data_swap_mux =\n\tSOC_DAPM_ENUM(\"Data Swap Mux\", rt1016_if_data_swap_enum);\n\nstatic const struct snd_soc_dapm_widget rt1016_dapm_widgets[] = {\n\tSND_SOC_DAPM_MUX(\"Data Swap Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&rt1016_if_data_swap_mux),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC Filter\", RT1016_CLOCK_3,\n\t\tRT1016_PWR_DAC_FILTER_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAMOD\", RT1016_CLOCK_3, RT1016_PWR_DACMOD_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"FIFO\", RT1016_CLOCK_3, RT1016_PWR_CLK_FIFO_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Pure DC\", RT1016_CLOCK_3,\n\t\tRT1016_PWR_CLK_PUREDC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CLK Silence Det\", RT1016_CLOCK_3,\n\t\tRT1016_PWR_SIL_DET_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"RC 25M\", RT1016_CLOCK_3, RT1016_PWR_RC_25M_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL1\", RT1016_CLOCK_3, RT1016_PWR_PLL1_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"ANA CTRL\", RT1016_CLOCK_3, RT1016_PWR_ANA_CTRL_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CLK SYS\", RT1016_CLOCK_3, RT1016_PWR_CLK_SYS_BIT,\n\t\t0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"LRCK Det\", RT1016_CLOCK_4, RT1016_PWR_LRCK_DET_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"BCLK Det\", RT1016_CLOCK_4, RT1016_PWR_BCLK_DET_BIT,\n\t\t0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"CKGEN DAC\", RT1016_DAC_CTRL_2,\n\t\tRT1016_CKGEN_DAC_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"VCM SLOW\", RT1016_CLASSD_1, RT1016_VCM_SLOW_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Silence Det\", RT1016_SIL_DET,\n\t\tRT1016_SIL_DET_EN_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2\", RT1016_PLL2, RT1016_PLL2_EN_BIT, 0, NULL,\n\t\t0),\n\n\tSND_SOC_DAPM_SUPPLY_S(\"BG1 BG2\", 1, RT1016_PWR_CTRL,\n\t\tRT1016_PWR_BG_1_2_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"MBIAS BG\", 1, RT1016_PWR_CTRL,\n\t\tRT1016_PWR_MBIAS_BG_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"PLL\", 1, RT1016_PWR_CTRL, RT1016_PWR_PLL_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"BASIC\", 1, RT1016_PWR_CTRL, RT1016_PWR_BASIC_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"CLASS D\", 1, RT1016_PWR_CTRL,\n\t\tRT1016_PWR_CLSD_BIT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"25M\", 1, RT1016_PWR_CTRL, RT1016_PWR_25M_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACL\", 1, RT1016_PWR_CTRL, RT1016_PWR_DACL_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"DACR\", 1, RT1016_PWR_CTRL, RT1016_PWR_DACR_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"LDO2\", 1, RT1016_PWR_CTRL, RT1016_PWR_LDO2_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"VREF\", 1, RT1016_PWR_CTRL, RT1016_PWR_VREF_BIT,\n\t\t0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY_S(\"MBIAS\", 1, RT1016_PWR_CTRL, RT1016_PWR_MBIAS_BIT,\n\t\t0, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"AIF Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPO\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1016_dapm_routes[] = {\n\t{ \"Data Swap Mux\", \"L/R\", \"AIFRX\" },\n\t{ \"Data Swap Mux\", \"R/L\", \"AIFRX\" },\n\t{ \"Data Swap Mux\", \"L/L\", \"AIFRX\" },\n\t{ \"Data Swap Mux\", \"R/R\", \"AIFRX\" },\n\n\t{ \"DAC\", NULL, \"DAC Filter\" },\n\t{ \"DAC\", NULL, \"DAMOD\" },\n\t{ \"DAC\", NULL, \"FIFO\" },\n\t{ \"DAC\", NULL, \"Pure DC\" },\n\t{ \"DAC\", NULL, \"Silence Det\" },\n\t{ \"DAC\", NULL, \"ANA CTRL\" },\n\t{ \"DAC\", NULL, \"CLK SYS\" },\n\t{ \"DAC\", NULL, \"LRCK Det\" },\n\t{ \"DAC\", NULL, \"BCLK Det\" },\n\t{ \"DAC\", NULL, \"CKGEN DAC\" },\n\t{ \"DAC\", NULL, \"VCM SLOW\" },\n\n\t{ \"PLL\", NULL, \"PLL1\" },\n\t{ \"PLL\", NULL, \"PLL2\" },\n\t{ \"25M\", NULL, \"RC 25M\" },\n\t{ \"Silence Det\", NULL, \"CLK Silence Det\" },\n\n\t{ \"DAC\", NULL, \"Data Swap Mux\" },\n\t{ \"DAC\", NULL, \"BG1 BG2\" },\n\t{ \"DAC\", NULL, \"MBIAS BG\" },\n\t{ \"DAC\", NULL, \"PLL\", rt1016_is_sys_clk_from_pll},\n\t{ \"DAC\", NULL, \"BASIC\" },\n\t{ \"DAC\", NULL, \"CLASS D\" },\n\t{ \"DAC\", NULL, \"25M\" },\n\t{ \"DAC\", NULL, \"DACL\" },\n\t{ \"DAC\", NULL, \"DACR\" },\n\t{ \"DAC\", NULL, \"LDO2\" },\n\t{ \"DAC\", NULL, \"VREF\" },\n\t{ \"DAC\", NULL, \"MBIAS\" },\n\n\t{ \"SPO\", NULL, \"DAC\" },\n};\n\nstatic int rt1016_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\tint pre_div, bclk_ms, frame_size;\n\tunsigned int val_len = 0;\n\n\trt1016->lrck = params_rate(params);\n\tpre_div = rl6231_get_clk_info(rt1016->sysclk, rt1016->lrck);\n\tif (pre_div < 0) {\n\t\tdev_err(component->dev, \"Unsupported clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0) {\n\t\tdev_err(component->dev, \"Unsupported frame size: %d\\n\",\n\t\t\tframe_size);\n\t\treturn -EINVAL;\n\t}\n\n\tbclk_ms = frame_size > 32;\n\trt1016->bclk = rt1016->lrck * (32 << bclk_ms);\n\n\tif (bclk_ms && rt1016->master)\n\t\tsnd_soc_component_update_bits(component, RT1016_I2S_CTRL,\n\t\t\tRT1016_I2S_BCLK_MS_MASK, RT1016_I2S_BCLK_MS_64);\n\n\tdev_dbg(component->dev, \"lrck is %dHz and pre_div is %d for iis %d\\n\",\n\t\t\t\trt1016->lrck, pre_div, dai->id);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len = RT1016_I2S_DL_16;\n\t\tbreak;\n\tcase 20:\n\t\tval_len = RT1016_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len = RT1016_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len = RT1016_I2S_DL_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1016_I2S_CTRL,\n\t\tRT1016_I2S_DL_MASK, val_len);\n\tsnd_soc_component_update_bits(component, RT1016_CLOCK_2,\n\t\tRT1016_FS_PD_MASK | RT1016_OSR_PD_MASK,\n\t\t((pre_div + 3) << RT1016_FS_PD_SFT) |\n\t\t(pre_div << RT1016_OSR_PD_SFT));\n\n\treturn 0;\n}\n\nstatic int rt1016_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\treg_val |= RT1016_I2S_MS_M;\n\t\trt1016->master = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\treg_val |= RT1016_I2S_MS_S;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg_val |= RT1016_I2S_BCLK_POL_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg_val |= RT1016_I2S_DF_LEFT;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg_val |= RT1016_I2S_DF_PCM_A;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\treg_val |= RT1016_I2S_DF_PCM_B;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1016_I2S_CTRL,\n\t\t\tRT1016_I2S_MS_MASK | RT1016_I2S_BCLK_POL_MASK |\n\t\t\tRT1016_I2S_DF_MASK, reg_val);\n\n\treturn 0;\n}\n\nstatic int rt1016_set_component_sysclk(struct snd_soc_component *component,\n\t\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tif (freq == rt1016->sysclk && clk_id == rt1016->sysclk_src)\n\t\treturn 0;\n\n\tswitch (clk_id) {\n\tcase RT1016_SCLK_S_MCLK:\n\t\treg_val |= RT1016_CLK_SYS_SEL_MCLK;\n\t\tbreak;\n\n\tcase RT1016_SCLK_S_PLL:\n\t\treg_val |= RT1016_CLK_SYS_SEL_PLL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\trt1016->sysclk = freq;\n\trt1016->sysclk_src = clk_id;\n\n\tdev_dbg(component->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq, clk_id);\n\n\tsnd_soc_component_update_bits(component, RT1016_CLOCK_1,\n\t\t\tRT1016_CLK_SYS_SEL_MASK, reg_val);\n\n\treturn 0;\n}\n\nstatic int rt1016_set_component_pll(struct snd_soc_component *component,\n\t\tint pll_id, int source, unsigned int freq_in,\n\t\tunsigned int freq_out)\n{\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\tstruct rl6231_pll_code pll_code;\n\tint ret;\n\n\tif (!freq_in || !freq_out) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\n\t\trt1016->pll_in = 0;\n\t\trt1016->pll_out = 0;\n\n\t\treturn 0;\n\t}\n\n\tif (source == rt1016->pll_src && freq_in == rt1016->pll_in &&\n\t\tfreq_out == rt1016->pll_out)\n\t\treturn 0;\n\n\tswitch (source) {\n\tcase RT1016_PLL_S_MCLK:\n\t\tsnd_soc_component_update_bits(component, RT1016_CLOCK_1,\n\t\t\tRT1016_PLL_SEL_MASK, RT1016_PLL_SEL_MCLK);\n\t\tbreak;\n\n\tcase RT1016_PLL_S_BCLK:\n\t\tsnd_soc_component_update_bits(component, RT1016_CLOCK_1,\n\t\t\tRT1016_PLL_SEL_MASK, RT1016_PLL_SEL_BCLK);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown PLL Source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rl6231_pll_calc(freq_in, freq_out * 4, &pll_code);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"mbypass=%d m=%d n=%d kbypass=%d k=%d\\n\",\n\t\tpll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\n\t\tpll_code.n_code, pll_code.k_bp,\n\t\t(pll_code.k_bp ? 0 : pll_code.k_code));\n\n\tsnd_soc_component_write(component, RT1016_PLL1,\n\t\t((pll_code.m_bp ? 0 : pll_code.m_code) << RT1016_PLL_M_SFT) |\n\t\t(pll_code.m_bp << RT1016_PLL_M_BP_SFT) |\n\t\tpll_code.n_code);\n\tsnd_soc_component_write(component, RT1016_PLL2,\n\t\t(pll_code.k_bp << RT1016_PLL_K_BP_SFT) |\n\t\t(pll_code.k_bp ? 0 : pll_code.k_code));\n\n\trt1016->pll_in = freq_in;\n\trt1016->pll_out = freq_out;\n\trt1016->pll_src = source;\n\n\treturn 0;\n}\n\nstatic int rt1016_probe(struct snd_soc_component *component)\n{\n\tstruct rt1016_priv *rt1016 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\trt1016->component = component;\n\n\treturn 0;\n}\n\nstatic void rt1016_remove(struct snd_soc_component *component)\n{\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\n\tregmap_write(rt1016->regmap, RT1016_RESET, 0);\n}\n\n#define RT1016_STEREO_RATES SNDRV_PCM_RATE_8000_48000\n#define RT1016_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt1016_aif_dai_ops = {\n\t.hw_params = rt1016_hw_params,\n\t.set_fmt = rt1016_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver rt1016_dai[] = {\n\t{\n\t\t.name = \"rt1016-aif\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT1016_STEREO_RATES,\n\t\t\t.formats = RT1016_FORMATS,\n\t\t},\n\t\t.ops = &rt1016_aif_dai_ops,\n\t}\n};\n\n#ifdef CONFIG_PM\nstatic int rt1016_suspend(struct snd_soc_component *component)\n{\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1016->regmap, true);\n\tregcache_mark_dirty(rt1016->regmap);\n\n\treturn 0;\n}\n\nstatic int rt1016_resume(struct snd_soc_component *component)\n{\n\tstruct rt1016_priv *rt1016 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1016->regmap, false);\n\tregcache_sync(rt1016->regmap);\n\n\treturn 0;\n}\n#else\n#define rt1016_suspend NULL\n#define rt1016_resume NULL\n#endif\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt1016 = {\n\t.probe = rt1016_probe,\n\t.remove = rt1016_remove,\n\t.suspend = rt1016_suspend,\n\t.resume = rt1016_resume,\n\t.controls = rt1016_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1016_snd_controls),\n\t.dapm_widgets = rt1016_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1016_dapm_widgets),\n\t.dapm_routes = rt1016_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1016_dapm_routes),\n\t.set_sysclk = rt1016_set_component_sysclk,\n\t.set_pll = rt1016_set_component_pll,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt1016_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\t.max_register = RT1016_PWR_CTRL,\n\t.volatile_reg = rt1016_volatile_register,\n\t.readable_reg = rt1016_readable_register,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = rt1016_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt1016_reg),\n};\n\nstatic const struct i2c_device_id rt1016_i2c_id[] = {\n\t{ \"rt1016\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1016_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id rt1016_of_match[] = {\n\t{ .compatible = \"realtek,rt1016\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt1016_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt1016_acpi_match[] = {\n\t{\"10EC1016\", 0,},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt1016_acpi_match);\n#endif\n\nstatic int rt1016_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt1016_priv *rt1016;\n\tint ret;\n\tunsigned int val;\n\n\trt1016 = devm_kzalloc(&i2c->dev, sizeof(struct rt1016_priv),\n\t\t\t\tGFP_KERNEL);\n\tif (rt1016 == NULL)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt1016);\n\n\trt1016->regmap = devm_regmap_init_i2c(i2c, &rt1016_regmap);\n\tif (IS_ERR(rt1016->regmap)) {\n\t\tret = PTR_ERR(rt1016->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tregmap_read(rt1016->regmap, RT1016_DEVICE_ID, &val);\n\tif (val != RT1016_DEVICE_ID_VAL) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %x is not rt1016\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\tregmap_write(rt1016->regmap, RT1016_RESET, 0);\n\n\tret = regmap_register_patch(rt1016->regmap, rt1016_patch,\n\t\t\t\t    ARRAY_SIZE(rt1016_patch));\n\tif (ret != 0)\n\t\tdev_warn(&i2c->dev, \"Failed to apply regmap patch: %d\\n\", ret);\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t&soc_component_dev_rt1016,\n\t\trt1016_dai, ARRAY_SIZE(rt1016_dai));\n}\n\nstatic void rt1016_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct rt1016_priv *rt1016 = i2c_get_clientdata(client);\n\n\tregmap_write(rt1016->regmap, RT1016_RESET, 0);\n}\n\nstatic struct i2c_driver rt1016_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1016\",\n\t\t.of_match_table = of_match_ptr(rt1016_of_match),\n\t\t.acpi_match_table = ACPI_PTR(rt1016_acpi_match),\n\t},\n\t.probe = rt1016_i2c_probe,\n\t.shutdown = rt1016_i2c_shutdown,\n\t.id_table = rt1016_i2c_id,\n};\nmodule_i2c_driver(rt1016_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1016 driver\");\nMODULE_AUTHOR(\"Oder Chiou <oder_chiou@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}