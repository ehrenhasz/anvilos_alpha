{
  "module_name": "aw88261.c",
  "hash_id": "fbf54a495f4fc8ff0c7c668c2d505edda04a304d498910de46fdc0abf52696ee",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/aw88261.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/i2c.h>\n#include <linux/firmware.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include \"aw88261.h\"\n#include \"aw88395/aw88395_data_type.h\"\n#include \"aw88395/aw88395_device.h\"\n\nstatic const struct regmap_config aw88261_remap_config = {\n\t.val_bits = 16,\n\t.reg_bits = 8,\n\t.max_register = AW88261_REG_MAX - 1,\n\t.reg_format_endian = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian = REGMAP_ENDIAN_BIG,\n};\n\nstatic void aw88261_dev_set_volume(struct aw_device *aw_dev, unsigned int value)\n{\n\tstruct aw_volume_desc *vol_desc = &aw_dev->volume_desc;\n\tunsigned int real_value, volume;\n\tunsigned int reg_value;\n\n\tvolume = min((value + vol_desc->init_volume), (unsigned int)AW88261_MUTE_VOL);\n\treal_value = DB_TO_REG_VAL(volume);\n\n\tregmap_read(aw_dev->regmap, AW88261_SYSCTRL2_REG, &reg_value);\n\n\treal_value = (real_value | (reg_value & AW88261_VOL_START_MASK));\n\n\tdev_dbg(aw_dev->dev, \"value 0x%x , real_value:0x%x\", value, real_value);\n\n\tregmap_write(aw_dev->regmap, AW88261_SYSCTRL2_REG, real_value);\n}\n\nstatic void aw88261_dev_fade_in(struct aw_device *aw_dev)\n{\n\tstruct aw_volume_desc *desc = &aw_dev->volume_desc;\n\tint fade_in_vol = desc->ctl_volume;\n\tint fade_step = aw_dev->fade_step;\n\tint i;\n\n\tif (fade_step == 0 || aw_dev->fade_in_time == 0) {\n\t\taw88261_dev_set_volume(aw_dev, fade_in_vol);\n\t\treturn;\n\t}\n\n\tfor (i = AW88261_MUTE_VOL; i >= fade_in_vol; i -= fade_step) {\n\t\taw88261_dev_set_volume(aw_dev, i);\n\t\tusleep_range(aw_dev->fade_in_time,\n\t\t\t\t\taw_dev->fade_in_time + 10);\n\t}\n\n\tif (i != fade_in_vol)\n\t\taw88261_dev_set_volume(aw_dev, fade_in_vol);\n}\n\nstatic void aw88261_dev_fade_out(struct aw_device *aw_dev)\n{\n\tstruct aw_volume_desc *desc = &aw_dev->volume_desc;\n\tint fade_step = aw_dev->fade_step;\n\tint i;\n\n\tif (fade_step == 0 || aw_dev->fade_out_time == 0) {\n\t\taw88261_dev_set_volume(aw_dev, AW88261_MUTE_VOL);\n\t\treturn;\n\t}\n\n\tfor (i = desc->ctl_volume; i <= AW88261_MUTE_VOL; i += fade_step) {\n\t\taw88261_dev_set_volume(aw_dev, i);\n\t\tusleep_range(aw_dev->fade_out_time, aw_dev->fade_out_time + 10);\n\t}\n\n\tif (i != AW88261_MUTE_VOL) {\n\t\taw88261_dev_set_volume(aw_dev, AW88261_MUTE_VOL);\n\t\tusleep_range(aw_dev->fade_out_time, aw_dev->fade_out_time + 10);\n\t}\n}\n\nstatic void aw88261_dev_i2s_tx_enable(struct aw_device *aw_dev, bool flag)\n{\n\tif (flag)\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_I2SCFG1_REG,\n\t\t\t~AW88261_I2STXEN_MASK, AW88261_I2STXEN_ENABLE_VALUE);\n\telse\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_I2SCFG1_REG,\n\t\t\t~AW88261_I2STXEN_MASK, AW88261_I2STXEN_DISABLE_VALUE);\n}\n\nstatic void aw88261_dev_pwd(struct aw_device *aw_dev, bool pwd)\n{\n\tif (pwd)\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_PWDN_MASK, AW88261_PWDN_POWER_DOWN_VALUE);\n\telse\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_PWDN_MASK, AW88261_PWDN_WORKING_VALUE);\n}\n\nstatic void aw88261_dev_amppd(struct aw_device *aw_dev, bool amppd)\n{\n\tif (amppd)\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_AMPPD_MASK, AW88261_AMPPD_POWER_DOWN_VALUE);\n\telse\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_AMPPD_MASK, AW88261_AMPPD_WORKING_VALUE);\n}\n\nstatic void aw88261_dev_mute(struct aw_device *aw_dev, bool is_mute)\n{\n\tif (is_mute) {\n\t\taw88261_dev_fade_out(aw_dev);\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_HMUTE_MASK, AW88261_HMUTE_ENABLE_VALUE);\n\t} else {\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_HMUTE_MASK, AW88261_HMUTE_DISABLE_VALUE);\n\t\taw88261_dev_fade_in(aw_dev);\n\t}\n}\n\nstatic void aw88261_dev_clear_int_status(struct aw_device *aw_dev)\n{\n\tunsigned int int_status;\n\n\t \n\tregmap_read(aw_dev->regmap, AW88261_SYSINT_REG, &int_status);\n\t \n\tregmap_read(aw_dev->regmap, AW88261_SYSINT_REG, &int_status);\n\n\tdev_dbg(aw_dev->dev, \"read interrupt reg = 0x%04x\", int_status);\n}\n\nstatic int aw88261_dev_get_iis_status(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88261_SYSST_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\tif ((reg_val & AW88261_BIT_PLL_CHECK) != AW88261_BIT_PLL_CHECK) {\n\t\tdev_err(aw_dev->dev, \"check pll lock fail,reg_val:0x%04x\", reg_val);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_check_mode1_pll(struct aw_device *aw_dev)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < AW88261_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = aw88261_dev_get_iis_status(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"mode1 iis signal check error\");\n\t\t\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\t\t} else {\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EPERM;\n}\n\nstatic int aw88261_dev_check_mode2_pll(struct aw_device *aw_dev)\n{\n\tunsigned int reg_val;\n\tint ret, i;\n\n\tret = regmap_read(aw_dev->regmap, AW88261_PLLCTRL1_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_val &= (~AW88261_CCO_MUX_MASK);\n\tif (reg_val == AW88261_CCO_MUX_DIVIDED_VALUE) {\n\t\tdev_dbg(aw_dev->dev, \"CCO_MUX is already divider\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tret = regmap_update_bits(aw_dev->regmap, AW88261_PLLCTRL1_REG,\n\t\t\t~AW88261_CCO_MUX_MASK, AW88261_CCO_MUX_DIVIDED_VALUE);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < AW88261_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = aw88261_dev_get_iis_status(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"mode2 iis signal check error\");\n\t\t\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tret = regmap_update_bits(aw_dev->regmap, AW88261_PLLCTRL1_REG,\n\t\t\t~AW88261_CCO_MUX_MASK, AW88261_CCO_MUX_BYPASS_VALUE);\n\tif (ret == 0) {\n\t\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\t\tfor (i = 0; i < AW88261_DEV_SYSST_CHECK_MAX; i++) {\n\t\t\tret = aw88261_dev_check_mode1_pll(aw_dev);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(aw_dev->dev, \"mode2 switch to mode1, iis signal check error\");\n\t\t\t\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_check_syspll(struct aw_device *aw_dev)\n{\n\tint ret;\n\n\tret = aw88261_dev_check_mode1_pll(aw_dev);\n\tif (ret) {\n\t\tdev_dbg(aw_dev->dev, \"mode1 check iis failed try switch to mode2 check\");\n\t\tret = aw88261_dev_check_mode2_pll(aw_dev);\n\t\tif (ret) {\n\t\t\tdev_err(aw_dev->dev, \"mode2 check iis failed\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_check_sysst(struct aw_device *aw_dev)\n{\n\tunsigned int check_val;\n\tunsigned int reg_val;\n\tint ret, i;\n\n\tfor (i = 0; i < AW88261_DEV_SYSST_CHECK_MAX; i++) {\n\t\tret = regmap_read(aw_dev->regmap, AW88261_SYSST_REG, &reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcheck_val = reg_val & (~AW88261_BIT_SYSST_CHECK_MASK)\n\t\t\t\t\t\t\t& AW88261_BIT_SYSST_CHECK;\n\t\tif (check_val != AW88261_BIT_SYSST_CHECK) {\n\t\t\tdev_err(aw_dev->dev, \"check sysst fail, reg_val=0x%04x, check:0x%x\",\n\t\t\t\treg_val, AW88261_BIT_SYSST_CHECK);\n\t\t\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EPERM;\n}\n\nstatic void aw88261_dev_uls_hmute(struct aw_device *aw_dev, bool uls_hmute)\n{\n\tif (uls_hmute)\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_ULS_HMUTE_MASK,\n\t\t\t\tAW88261_ULS_HMUTE_ENABLE_VALUE);\n\telse\n\t\tregmap_update_bits(aw_dev->regmap, AW88261_SYSCTRL_REG,\n\t\t\t\t~AW88261_ULS_HMUTE_MASK,\n\t\t\t\tAW88261_ULS_HMUTE_DISABLE_VALUE);\n}\n\nstatic void aw88261_reg_force_set(struct aw88261 *aw88261)\n{\n\tif (aw88261->frcset_en == AW88261_FRCSET_ENABLE) {\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL3_REG,\n\t\t\t\tAW88261_FORCE_PWM_MASK, AW88261_FORCE_PWM_FORCEMINUS_PWM_VALUE);\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL5_REG,\n\t\t\t\tAW88261_BST_OS_WIDTH_MASK, AW88261_BST_OS_WIDTH_50NS_VALUE);\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL6_REG,\n\t\t\t\tAW88261_BST_LOOPR_MASK, AW88261_BST_LOOPR_340K_VALUE);\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL7_REG,\n\t\t\t\tAW88261_RSQN_DLY_MASK, AW88261_RSQN_DLY_35NS_VALUE);\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL8_REG,\n\t\t\t\tAW88261_BURST_SSMODE_MASK, AW88261_BURST_SSMODE_FAST_VALUE);\n\t\t \n\t\tregmap_update_bits(aw88261->regmap, AW88261_BSTCTRL9_REG,\n\t\t\t\tAW88261_BST_BURST_MASK, AW88261_BST_BURST_30MA_VALUE);\n\t} else {\n\t\tdev_dbg(aw88261->aw_pa->dev, \"needn't set reg value\");\n\t}\n}\n\nstatic int aw88261_dev_get_icalk(struct aw_device *aw_dev, int16_t *icalk)\n{\n\tu16 reg_icalk, reg_icalkl;\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88261_EFRH4_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_icalk = reg_val & (~AW88261_EF_ISN_GESLP_H_MASK);\n\n\tret = regmap_read(aw_dev->regmap, AW88261_EFRL4_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_icalkl = reg_val & (~AW88261_EF_ISN_GESLP_L_MASK);\n\n\treg_icalk = (reg_icalk >> AW88261_ICALK_SHIFT) & (reg_icalkl >> AW88261_ICALKL_SHIFT);\n\n\tif (reg_icalk & (~AW88261_EF_ISN_GESLP_SIGN_MASK))\n\t\treg_icalk = reg_icalk | ~AW88261_EF_ISN_GESLP_NEG;\n\n\t*icalk = (int16_t)reg_icalk;\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_get_vcalk(struct aw_device *aw_dev, int16_t *vcalk)\n{\n\tu16 reg_vcalk, reg_vcalkl;\n\tunsigned int reg_val;\n\tint ret;\n\n\tret = regmap_read(aw_dev->regmap, AW88261_EFRH3_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_vcalk = (u16)reg_val & (~AW88261_EF_VSN_GESLP_H_MASK);\n\n\tret = regmap_read(aw_dev->regmap, AW88261_EFRL3_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\n\treg_vcalkl = (u16)reg_val & (~AW88261_EF_VSN_GESLP_L_MASK);\n\n\treg_vcalk = (reg_vcalk >> AW88261_VCALK_SHIFT) & (reg_vcalkl >> AW88261_VCALKL_SHIFT);\n\n\tif (reg_vcalk & AW88261_EF_VSN_GESLP_SIGN_MASK)\n\t\treg_vcalk = reg_vcalk | (~AW88261_EF_VSN_GESLP_NEG);\n\t*vcalk = (int16_t)reg_vcalk;\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_set_vcalb(struct aw_device *aw_dev)\n{\n\tint16_t icalk_val, vcalk_val;\n\tint icalk, vcalk, vcalb;\n\tu32 reg_val;\n\tint ret;\n\n\tret = aw88261_dev_get_icalk(aw_dev, &icalk_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = aw88261_dev_get_vcalk(aw_dev, &vcalk_val);\n\tif (ret)\n\t\treturn ret;\n\n\ticalk = AW88261_CABL_BASE_VALUE + AW88261_ICABLK_FACTOR * icalk_val;\n\tvcalk = AW88261_CABL_BASE_VALUE + AW88261_VCABLK_FACTOR * vcalk_val;\n\tif (!vcalk)\n\t\treturn -EINVAL;\n\n\tvcalb = AW88261_VCAL_FACTOR * icalk / vcalk;\n\treg_val = (unsigned int)vcalb;\n\n\tdev_dbg(aw_dev->dev, \"icalk=%d, vcalk=%d, vcalb=%d, reg_val=0x%04x\",\n\t\t\ticalk, vcalk, vcalb, reg_val);\n\tret = regmap_write(aw_dev->regmap, AW88261_VSNTM1_REG, reg_val);\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_reg_update(struct aw88261 *aw88261,\n\t\t\t\t\tunsigned char *data, unsigned int len)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tstruct aw_volume_desc *vol_desc = &aw_dev->volume_desc;\n\tunsigned int read_val, efcheck_val, read_vol;\n\tint data_len, i, ret;\n\tint16_t *reg_data;\n\tu16 reg_val;\n\tu8 reg_addr;\n\n\tif (!len || !data) {\n\t\tdev_err(aw_dev->dev, \"reg data is null or len is 0\");\n\t\treturn -EINVAL;\n\t}\n\n\treg_data = (int16_t *)data;\n\tdata_len = len >> 1;\n\n\tif (data_len & 0x1) {\n\t\tdev_err(aw_dev->dev, \"data len:%d unsupported\",\tdata_len);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < data_len; i += 2) {\n\t\treg_addr = reg_data[i];\n\t\treg_val = reg_data[i + 1];\n\n\t\tif (reg_addr == AW88261_SYSCTRL_REG) {\n\t\t\taw88261->amppd_st = reg_val & (~AW88261_AMPPD_MASK);\n\t\t\tret = regmap_read(aw_dev->regmap, reg_addr, &read_val);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tread_val &= (~AW88261_AMPPD_MASK) | (~AW88261_PWDN_MASK) |\n\t\t\t\t\t\t\t\t(~AW88261_HMUTE_MASK);\n\t\t\treg_val &= (AW88261_AMPPD_MASK | AW88261_PWDN_MASK | AW88261_HMUTE_MASK);\n\t\t\treg_val |= read_val;\n\n\t\t\t \n\t\t\treg_val &= AW88261_ULS_HMUTE_MASK;\n\t\t\treg_val |= AW88261_ULS_HMUTE_ENABLE_VALUE;\n\t\t}\n\n\t\tif (reg_addr == AW88261_DBGCTRL_REG) {\n\t\t\tefcheck_val = reg_val & (~AW88261_EF_DBMD_MASK);\n\t\t\tif (efcheck_val == AW88261_OR_VALUE)\n\t\t\t\taw88261->efuse_check = AW88261_EF_OR_CHECK;\n\t\t\telse\n\t\t\t\taw88261->efuse_check = AW88261_EF_AND_CHECK;\n\t\t}\n\n\t\t \n\t\tif (reg_addr == AW88261_I2SCTRL3_REG) {\n\t\t\t \n\t\t\treg_val &= AW88261_I2STXEN_MASK;\n\t\t\treg_val |= AW88261_I2STXEN_DISABLE_VALUE;\n\t\t}\n\n\t\tif (reg_addr == AW88261_SYSCTRL2_REG) {\n\t\t\tread_vol = (reg_val & (~AW88261_VOL_MASK)) >>\n\t\t\t\tAW88261_VOL_START_BIT;\n\t\t\taw_dev->volume_desc.init_volume =\n\t\t\t\tREG_VAL_TO_DB(read_vol);\n\t\t}\n\n\t\tif (reg_addr == AW88261_VSNTM1_REG)\n\t\t\tcontinue;\n\n\t\tret = regmap_write(aw_dev->regmap, reg_addr, reg_val);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tret = aw88261_dev_set_vcalb(aw_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (aw_dev->prof_cur != aw_dev->prof_index)\n\t\tvol_desc->ctl_volume = 0;\n\n\t \n\taw88261_dev_set_volume(aw_dev, vol_desc->mute_volume);\n\n\treturn ret;\n}\n\nstatic char *aw88261_dev_get_prof_name(struct aw_device *aw_dev, int index)\n{\n\tstruct aw_prof_info *prof_info = &aw_dev->prof_info;\n\tstruct aw_prof_desc *prof_desc;\n\n\tif ((index >= aw_dev->prof_info.count) || (index < 0)) {\n\t\tdev_err(aw_dev->dev, \"index[%d] overflow count[%d]\",\n\t\t\tindex, aw_dev->prof_info.count);\n\t\treturn NULL;\n\t}\n\n\tprof_desc = &aw_dev->prof_info.prof_desc[index];\n\n\treturn prof_info->prof_name_list[prof_desc->id];\n}\n\nstatic int aw88261_dev_get_prof_data(struct aw_device *aw_dev, int index,\n\t\t\tstruct aw_prof_desc **prof_desc)\n{\n\tif ((index >= aw_dev->prof_info.count) || (index < 0)) {\n\t\tdev_err(aw_dev->dev, \"%s: index[%d] overflow count[%d]\\n\",\n\t\t\t\t__func__, index, aw_dev->prof_info.count);\n\t\treturn -EINVAL;\n\t}\n\n\t*prof_desc = &aw_dev->prof_info.prof_desc[index];\n\n\treturn 0;\n}\n\nstatic int aw88261_dev_fw_update(struct aw88261 *aw88261)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tstruct aw_prof_desc *prof_index_desc;\n\tstruct aw_sec_data_desc *sec_desc;\n\tchar *prof_name;\n\tint ret;\n\n\tprof_name = aw88261_dev_get_prof_name(aw_dev, aw_dev->prof_index);\n\tif (!prof_name) {\n\t\tdev_err(aw_dev->dev, \"get prof name failed\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(aw_dev->dev, \"start update %s\", prof_name);\n\n\tret = aw88261_dev_get_prof_data(aw_dev, aw_dev->prof_index, &prof_index_desc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsec_desc = prof_index_desc->sec_desc;\n\tret = aw88261_dev_reg_update(aw88261, sec_desc[AW88395_DATA_TYPE_REG].data,\n\t\t\t\t\tsec_desc[AW88395_DATA_TYPE_REG].len);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"update reg failed\");\n\t\treturn ret;\n\t}\n\n\taw_dev->prof_cur = aw_dev->prof_index;\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_start(struct aw88261 *aw88261)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tint ret;\n\n\tif (aw_dev->status == AW88261_DEV_PW_ON) {\n\t\tdev_info(aw_dev->dev, \"already power on\");\n\t\treturn 0;\n\t}\n\n\t \n\taw88261_dev_pwd(aw_dev, false);\n\tusleep_range(AW88261_2000_US, AW88261_2000_US + 10);\n\n\tret = aw88261_dev_check_syspll(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"pll check failed cannot start\");\n\t\tgoto pll_check_fail;\n\t}\n\n\t \n\taw88261_dev_amppd(aw_dev, false);\n\tusleep_range(AW88261_1000_US, AW88261_1000_US + 50);\n\n\t \n\tret = aw88261_dev_check_sysst(aw_dev);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"sysst check failed\");\n\t\tgoto sysst_check_fail;\n\t}\n\n\t \n\taw88261_dev_i2s_tx_enable(aw_dev, true);\n\n\tif (aw88261->amppd_st)\n\t\taw88261_dev_amppd(aw_dev, true);\n\n\taw88261_reg_force_set(aw88261);\n\n\t \n\taw88261_dev_uls_hmute(aw_dev, false);\n\n\t \n\tif (!aw88261->mute_st)\n\t\taw88261_dev_mute(aw_dev, false);\n\n\t \n\taw88261_dev_clear_int_status(aw_dev);\n\taw_dev->status = AW88261_DEV_PW_ON;\n\n\treturn 0;\n\nsysst_check_fail:\n\taw88261_dev_i2s_tx_enable(aw_dev, false);\n\taw88261_dev_clear_int_status(aw_dev);\n\taw88261_dev_amppd(aw_dev, true);\npll_check_fail:\n\taw88261_dev_pwd(aw_dev, true);\n\taw_dev->status = AW88261_DEV_PW_OFF;\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_stop(struct aw_device *aw_dev)\n{\n\tif (aw_dev->status == AW88261_DEV_PW_OFF) {\n\t\tdev_info(aw_dev->dev, \"already power off\");\n\t\treturn 0;\n\t}\n\n\taw_dev->status = AW88261_DEV_PW_OFF;\n\n\t \n\taw88261_dev_clear_int_status(aw_dev);\n\n\taw88261_dev_uls_hmute(aw_dev, true);\n\t \n\taw88261_dev_mute(aw_dev, true);\n\n\t \n\taw88261_dev_i2s_tx_enable(aw_dev, false);\n\tusleep_range(AW88261_1000_US, AW88261_1000_US + 100);\n\n\t \n\taw88261_dev_amppd(aw_dev, true);\n\n\t \n\taw88261_dev_pwd(aw_dev, true);\n\n\treturn 0;\n}\n\nstatic int aw88261_reg_update(struct aw88261 *aw88261, bool force)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tint ret;\n\n\tif (force) {\n\t\tret = regmap_write(aw_dev->regmap,\n\t\t\t\t\tAW88261_ID_REG, AW88261_SOFT_RESET_VALUE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = aw88261_dev_fw_update(aw88261);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tif (aw_dev->prof_cur != aw_dev->prof_index) {\n\t\t\tret = aw88261_dev_fw_update(aw88261);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\taw_dev->prof_cur = aw_dev->prof_index;\n\n\treturn ret;\n}\n\nstatic void aw88261_start_pa(struct aw88261 *aw88261)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < AW88261_START_RETRIES; i++) {\n\t\tret = aw88261_reg_update(aw88261, aw88261->phase_sync);\n\t\tif (ret) {\n\t\t\tdev_err(aw88261->aw_pa->dev, \"fw update failed, cnt:%d\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tret = aw88261_dev_start(aw88261);\n\t\tif (ret) {\n\t\t\tdev_err(aw88261->aw_pa->dev, \"aw88261 device start failed. retry = %d\", i);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tdev_info(aw88261->aw_pa->dev, \"start success\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void aw88261_startup_work(struct work_struct *work)\n{\n\tstruct aw88261 *aw88261 =\n\t\tcontainer_of(work, struct aw88261, start_work.work);\n\n\tmutex_lock(&aw88261->lock);\n\taw88261_start_pa(aw88261);\n\tmutex_unlock(&aw88261->lock);\n}\n\nstatic void aw88261_start(struct aw88261 *aw88261, bool sync_start)\n{\n\tif (aw88261->aw_pa->fw_status != AW88261_DEV_FW_OK)\n\t\treturn;\n\n\tif (aw88261->aw_pa->status == AW88261_DEV_PW_ON)\n\t\treturn;\n\n\tif (sync_start == AW88261_SYNC_START)\n\t\taw88261_start_pa(aw88261);\n\telse\n\t\tqueue_delayed_work(system_wq,\n\t\t\t&aw88261->start_work,\n\t\t\tAW88261_START_WORK_DELAY_MS);\n}\n\nstatic struct snd_soc_dai_driver aw88261_dai[] = {\n\t{\n\t\t.name = \"aw88261-aif\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"Speaker_Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = AW88261_RATES,\n\t\t\t.formats = AW88261_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Speaker_Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = AW88261_RATES,\n\t\t\t.formats = AW88261_FORMATS,\n\t\t},\n\t},\n};\n\nstatic int aw88261_get_fade_in_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\n\tucontrol->value.integer.value[0] = aw_dev->fade_in_time;\n\n\treturn 0;\n}\n\nstatic int aw88261_set_fade_in_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tint time;\n\n\ttime = ucontrol->value.integer.value[0];\n\n\tif (time < mc->min || time > mc->max)\n\t\treturn -EINVAL;\n\n\tif (time != aw_dev->fade_in_time) {\n\t\taw_dev->fade_in_time = time;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88261_get_fade_out_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\n\tucontrol->value.integer.value[0] = aw_dev->fade_out_time;\n\n\treturn 0;\n}\n\nstatic int aw88261_set_fade_out_time(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tint time;\n\n\ttime = ucontrol->value.integer.value[0];\n\tif (time < mc->min || time > mc->max)\n\t\treturn -EINVAL;\n\n\tif (time != aw_dev->fade_out_time) {\n\t\taw_dev->fade_out_time = time;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88261_dev_set_profile_index(struct aw_device *aw_dev, int index)\n{\n\t \n\tif ((index >= aw_dev->prof_info.count) || (index < 0))\n\t\treturn -EINVAL;\n\t \n\tif (aw_dev->prof_index == index)\n\t\treturn -EPERM;\n\n\taw_dev->prof_index = index;\n\n\treturn 0;\n}\n\nstatic int aw88261_profile_info(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\tconst char *prof_name;\n\tchar *name;\n\tint count;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\n\tuinfo->count = 1;\n\n\tcount = aw88261->aw_pa->prof_info.count;\n\tif (count <= 0) {\n\t\tuinfo->value.enumerated.items = 0;\n\t\treturn 0;\n\t}\n\n\tuinfo->value.enumerated.items = count;\n\n\tif (uinfo->value.enumerated.item >= count)\n\t\tuinfo->value.enumerated.item = count - 1;\n\n\tname = uinfo->value.enumerated.name;\n\tcount = uinfo->value.enumerated.item;\n\n\tprof_name = aw88261_dev_get_prof_name(aw88261->aw_pa, count);\n\tif (!prof_name) {\n\t\tstrscpy(uinfo->value.enumerated.name, \"null\",\n\t\t\t\t\t\tstrlen(\"null\") + 1);\n\t\treturn 0;\n\t}\n\n\tstrscpy(name, prof_name, sizeof(uinfo->value.enumerated.name));\n\n\treturn 0;\n}\n\nstatic int aw88261_profile_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = aw88261->aw_pa->prof_index;\n\n\treturn 0;\n}\n\nstatic int aw88261_profile_set(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\tint ret;\n\n\t \n\tmutex_lock(&aw88261->lock);\n\tret = aw88261_dev_set_profile_index(aw88261->aw_pa, ucontrol->value.integer.value[0]);\n\tif (ret) {\n\t\tdev_dbg(codec->dev, \"profile index does not change\");\n\t\tmutex_unlock(&aw88261->lock);\n\t\treturn 0;\n\t}\n\n\tif (aw88261->aw_pa->status) {\n\t\taw88261_dev_stop(aw88261->aw_pa);\n\t\taw88261_start(aw88261, AW88261_SYNC_START);\n\t}\n\n\tmutex_unlock(&aw88261->lock);\n\n\treturn 1;\n}\n\nstatic int aw88261_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\tstruct aw_volume_desc *vol_desc = &aw88261->aw_pa->volume_desc;\n\n\tucontrol->value.integer.value[0] = vol_desc->ctl_volume;\n\n\treturn 0;\n}\n\nstatic int aw88261_volume_set(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\tstruct aw_volume_desc *vol_desc = &aw88261->aw_pa->volume_desc;\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint value;\n\n\tvalue = ucontrol->value.integer.value[0];\n\n\tif (value < mc->min || value > mc->max)\n\t\treturn -EINVAL;\n\n\tif (vol_desc->ctl_volume != value) {\n\t\tvol_desc->ctl_volume = value;\n\t\taw88261_dev_set_volume(aw88261->aw_pa, vol_desc->ctl_volume);\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aw88261_get_fade_step(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\n\tucontrol->value.integer.value[0] = aw88261->aw_pa->fade_step;\n\n\treturn 0;\n}\n\nstatic int aw88261_set_fade_step(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *codec = snd_soc_kcontrol_component(kcontrol);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(codec);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint value;\n\n\tvalue = ucontrol->value.integer.value[0];\n\tif (value < mc->min || value > mc->max)\n\t\treturn -EINVAL;\n\n\tif (aw88261->aw_pa->fade_step != value) {\n\t\taw88261->aw_pa->fade_step = value;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new aw88261_controls[] = {\n\tSOC_SINGLE_EXT(\"PCM Playback Volume\", AW88261_SYSCTRL2_REG,\n\t\t6, AW88261_MUTE_VOL, 0, aw88261_volume_get,\n\t\taw88261_volume_set),\n\tSOC_SINGLE_EXT(\"Fade Step\", 0, 0, AW88261_MUTE_VOL, 0,\n\t\taw88261_get_fade_step, aw88261_set_fade_step),\n\tSOC_SINGLE_EXT(\"Volume Ramp Up Step\", 0, 0, FADE_TIME_MAX, FADE_TIME_MIN,\n\t\taw88261_get_fade_in_time, aw88261_set_fade_in_time),\n\tSOC_SINGLE_EXT(\"Volume Ramp Down Step\", 0, 0, FADE_TIME_MAX, FADE_TIME_MIN,\n\t\taw88261_get_fade_out_time, aw88261_set_fade_out_time),\n\tAW88261_PROFILE_EXT(\"Profile Set\", aw88261_profile_info,\n\t\taw88261_profile_get, aw88261_profile_set),\n};\n\nstatic int aw88261_playback_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *k, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&aw88261->lock);\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\taw88261_start(aw88261, AW88261_ASYNC_START);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\taw88261_dev_stop(aw88261->aw_pa);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&aw88261->lock);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget aw88261_dapm_widgets[] = {\n\t  \n\tSND_SOC_DAPM_AIF_IN_E(\"AIF_RX\", \"Speaker_Playback\", 0, 0, 0, 0,\n\t\t\t\t\taw88261_playback_event,\n\t\t\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUTPUT(\"DAC Output\"),\n\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"AIF_TX\", \"Speaker_Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_INPUT(\"ADC Input\"),\n};\n\nstatic const struct snd_soc_dapm_route aw88261_audio_map[] = {\n\t{\"DAC Output\", NULL, \"AIF_RX\"},\n\t{\"AIF_TX\", NULL, \"ADC Input\"},\n};\n\nstatic int aw88261_frcset_check(struct aw88261 *aw88261)\n{\n\tunsigned int reg_val;\n\tu16 temh, teml, tem;\n\tint ret;\n\n\tret = regmap_read(aw88261->regmap, AW88261_EFRH3_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\ttemh = ((u16)reg_val & (~AW88261_TEMH_MASK));\n\n\tret = regmap_read(aw88261->regmap, AW88261_EFRL3_REG, &reg_val);\n\tif (ret)\n\t\treturn ret;\n\tteml = ((u16)reg_val & (~AW88261_TEML_MASK));\n\n\tif (aw88261->efuse_check == AW88261_EF_OR_CHECK)\n\t\ttem = (temh | teml);\n\telse\n\t\ttem = (temh & teml);\n\n\tif (tem == AW88261_DEFAULT_CFG)\n\t\taw88261->frcset_en = AW88261_FRCSET_ENABLE;\n\telse\n\t\taw88261->frcset_en = AW88261_FRCSET_DISABLE;\n\n\tdev_dbg(aw88261->aw_pa->dev, \"tem is 0x%04x, frcset_en is %d\",\n\t\t\t\t\t\ttem, aw88261->frcset_en);\n\n\treturn ret;\n}\n\nstatic int aw88261_dev_init(struct aw88261 *aw88261, struct aw_container *aw_cfg)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tint ret;\n\n\tret = aw88395_dev_cfg_load(aw_dev, aw_cfg);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"aw_dev acf parse failed\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(aw_dev->regmap, AW88261_ID_REG, AW88261_SOFT_RESET_VALUE);\n\tif (ret)\n\t\treturn ret;\n\n\taw_dev->fade_in_time = AW88261_500_US;\n\taw_dev->fade_out_time = AW88261_500_US;\n\taw_dev->prof_cur = AW88261_INIT_PROFILE;\n\taw_dev->prof_index = AW88261_INIT_PROFILE;\n\n\tret = aw88261_dev_fw_update(aw88261);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"fw update failed ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = aw88261_frcset_check(aw88261);\n\tif (ret) {\n\t\tdev_err(aw_dev->dev, \"aw88261_frcset_check ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\taw88261_dev_clear_int_status(aw_dev);\n\n\taw88261_dev_uls_hmute(aw_dev, true);\n\n\taw88261_dev_mute(aw_dev, true);\n\n\taw88261_dev_i2s_tx_enable(aw_dev, false);\n\n\tusleep_range(AW88261_1000_US, AW88261_1000_US + 100);\n\n\taw88261_dev_amppd(aw_dev, true);\n\n\taw88261_dev_pwd(aw_dev, true);\n\n\treturn 0;\n}\n\nstatic int aw88261_request_firmware_file(struct aw88261 *aw88261)\n{\n\tconst struct firmware *cont = NULL;\n\tint ret;\n\n\taw88261->aw_pa->fw_status = AW88261_DEV_FW_FAILED;\n\n\tret = request_firmware(&cont, AW88261_ACF_FILE, aw88261->aw_pa->dev);\n\tif (ret)\n\t\treturn dev_err_probe(aw88261->aw_pa->dev, ret,\n\t\t\t\t\t\"load [%s] failed!\", AW88261_ACF_FILE);\n\n\tdev_info(aw88261->aw_pa->dev, \"loaded %s - size: %zu\\n\",\n\t\t\tAW88261_ACF_FILE, cont ? cont->size : 0);\n\n\taw88261->aw_cfg = devm_kzalloc(aw88261->aw_pa->dev, cont->size + sizeof(int), GFP_KERNEL);\n\tif (!aw88261->aw_cfg) {\n\t\trelease_firmware(cont);\n\t\treturn -ENOMEM;\n\t}\n\taw88261->aw_cfg->len = (int)cont->size;\n\tmemcpy(aw88261->aw_cfg->data, cont->data, cont->size);\n\trelease_firmware(cont);\n\n\tret = aw88395_dev_load_acf_check(aw88261->aw_pa, aw88261->aw_cfg);\n\tif (ret) {\n\t\tdev_err(aw88261->aw_pa->dev, \"load [%s] failed !\", AW88261_ACF_FILE);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&aw88261->lock);\n\t \n\tret = aw88261_dev_init(aw88261, aw88261->aw_cfg);\n\tif (ret)\n\t\tdev_err(aw88261->aw_pa->dev, \"dev init failed\");\n\tmutex_unlock(&aw88261->lock);\n\n\treturn ret;\n}\n\nstatic int aw88261_codec_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tINIT_DELAYED_WORK(&aw88261->start_work, aw88261_startup_work);\n\n\tret = aw88261_request_firmware_file(aw88261);\n\tif (ret)\n\t\treturn dev_err_probe(aw88261->aw_pa->dev, ret,\n\t\t\t\t\"aw88261_request_firmware_file failed\\n\");\n\n\t \n\tret = snd_soc_dapm_new_controls(dapm, aw88261_dapm_widgets,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88261_dapm_widgets));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = snd_soc_dapm_add_routes(dapm, aw88261_audio_map,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88261_audio_map));\n\tif (ret)\n\t\treturn ret;\n\n\tret = snd_soc_add_component_controls(component, aw88261_controls,\n\t\t\t\t\t\t\tARRAY_SIZE(aw88261_controls));\n\n\treturn ret;\n}\n\nstatic void aw88261_codec_remove(struct snd_soc_component *aw_codec)\n{\n\tstruct aw88261 *aw88261 = snd_soc_component_get_drvdata(aw_codec);\n\n\tcancel_delayed_work_sync(&aw88261->start_work);\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_aw88261 = {\n\t.probe = aw88261_codec_probe,\n\t.remove = aw88261_codec_remove,\n};\n\nstatic void aw88261_hw_reset(struct aw88261 *aw88261)\n{\n\tgpiod_set_value_cansleep(aw88261->reset_gpio, 0);\n\tusleep_range(AW88261_1000_US, AW88261_1000_US + 10);\n\tgpiod_set_value_cansleep(aw88261->reset_gpio, 1);\n\tusleep_range(AW88261_1000_US, AW88261_1000_US + 10);\n}\n\nstatic void aw88261_parse_channel_dt(struct aw88261 *aw88261)\n{\n\tstruct aw_device *aw_dev = aw88261->aw_pa;\n\tstruct device_node *np = aw_dev->dev->of_node;\n\tu32 channel_value = AW88261_DEV_DEFAULT_CH;\n\tu32 sync_enable = false;\n\n\tof_property_read_u32(np, \"sound-channel\", &channel_value);\n\tof_property_read_u32(np, \"sync-flag\", &sync_enable);\n\n\taw_dev->channel = channel_value;\n\taw88261->phase_sync = sync_enable;\n}\n\nstatic int aw88261_init(struct aw88261 **aw88261, struct i2c_client *i2c, struct regmap *regmap)\n{\n\tstruct aw_device *aw_dev;\n\tunsigned int chip_id;\n\tint ret;\n\n\t \n\tret = regmap_read(regmap, AW88261_ID_REG, &chip_id);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"%s read chipid error. ret = %d\", __func__, ret);\n\t\treturn ret;\n\t}\n\tif (chip_id != AW88261_CHIP_ID) {\n\t\tdev_err(&i2c->dev, \"unsupported device\");\n\t\treturn -ENXIO;\n\t}\n\n\tdev_info(&i2c->dev, \"chip id = %x\\n\", chip_id);\n\n\taw_dev = devm_kzalloc(&i2c->dev, sizeof(*aw_dev), GFP_KERNEL);\n\tif (!aw_dev)\n\t\treturn -ENOMEM;\n\n\t(*aw88261)->aw_pa = aw_dev;\n\taw_dev->i2c = i2c;\n\taw_dev->regmap = regmap;\n\taw_dev->dev = &i2c->dev;\n\taw_dev->chip_id = AW88261_CHIP_ID;\n\taw_dev->acf = NULL;\n\taw_dev->prof_info.prof_desc = NULL;\n\taw_dev->prof_info.count = 0;\n\taw_dev->prof_info.prof_type = AW88395_DEV_NONE_TYPE_ID;\n\taw_dev->channel = 0;\n\taw_dev->fw_status = AW88261_DEV_FW_FAILED;\n\taw_dev->fade_step = AW88261_VOLUME_STEP_DB;\n\taw_dev->volume_desc.ctl_volume = AW88261_VOL_DEFAULT_VALUE;\n\taw_dev->volume_desc.mute_volume = AW88261_MUTE_VOL;\n\taw88261_parse_channel_dt(*aw88261);\n\n\treturn ret;\n}\n\nstatic int aw88261_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct aw88261 *aw88261;\n\tint ret;\n\n\tret = i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C);\n\tif (!ret)\n\t\treturn dev_err_probe(&i2c->dev, -ENXIO, \"check_functionality failed\");\n\n\taw88261 = devm_kzalloc(&i2c->dev, sizeof(*aw88261), GFP_KERNEL);\n\tif (!aw88261)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&aw88261->lock);\n\n\ti2c_set_clientdata(i2c, aw88261);\n\n\taw88261->reset_gpio = devm_gpiod_get_optional(&i2c->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(aw88261->reset_gpio))\n\t\tdev_info(&i2c->dev, \"reset gpio not defined\\n\");\n\telse\n\t\taw88261_hw_reset(aw88261);\n\n\taw88261->regmap = devm_regmap_init_i2c(i2c, &aw88261_remap_config);\n\tif (IS_ERR(aw88261->regmap)) {\n\t\tret = PTR_ERR(aw88261->regmap);\n\t\treturn dev_err_probe(&i2c->dev, ret, \"failed to init regmap: %d\\n\", ret);\n\t}\n\n\t \n\tret = aw88261_init(&aw88261, i2c, aw88261->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_codec_dev_aw88261,\n\t\t\taw88261_dai, ARRAY_SIZE(aw88261_dai));\n\tif (ret)\n\t\tdev_err(&i2c->dev, \"failed to register aw88261: %d\", ret);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id aw88261_i2c_id[] = {\n\t{ AW88261_I2C_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, aw88261_i2c_id);\n\nstatic struct i2c_driver aw88261_i2c_driver = {\n\t.driver = {\n\t\t.name = AW88261_I2C_NAME,\n\t},\n\t.probe = aw88261_i2c_probe,\n\t.id_table = aw88261_i2c_id,\n};\nmodule_i2c_driver(aw88261_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC AW88261 Smart PA Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}