{
  "module_name": "tscs454.c",
  "hash_id": "4865d7daadd40c39d4b271285fce6caa3900087be8338db6c8c41be5f304938f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tscs454.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/regmap.h>\n#include <linux/i2c.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n\n#include <sound/tlv.h>\n#include <sound/pcm_params.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n#include \"tscs454.h\"\n\nstatic const unsigned int PLL_44_1K_RATE = (44100 * 256);\n\n#define COEFF_SIZE 3\n#define BIQUAD_COEFF_COUNT 5\n#define BIQUAD_SIZE (COEFF_SIZE * BIQUAD_COEFF_COUNT)\n\n#define COEFF_RAM_MAX_ADDR 0xcd\n#define COEFF_RAM_COEFF_COUNT (COEFF_RAM_MAX_ADDR + 1)\n#define COEFF_RAM_SIZE (COEFF_SIZE * COEFF_RAM_COEFF_COUNT)\n\nenum {\n\tTSCS454_DAI1_ID,\n\tTSCS454_DAI2_ID,\n\tTSCS454_DAI3_ID,\n\tTSCS454_DAI_COUNT,\n};\n\nstruct pll {\n\tint id;\n\tunsigned int users;\n\tstruct mutex lock;\n};\n\nstatic inline void pll_init(struct pll *pll, int id)\n{\n\tpll->id = id;\n\tmutex_init(&pll->lock);\n}\n\nstruct internal_rate {\n\tstruct pll *pll;\n};\n\nstruct aif {\n\tunsigned int id;\n\tbool provider;\n\tstruct pll *pll;\n};\n\nstatic inline void aif_init(struct aif *aif, unsigned int id)\n{\n\taif->id = id;\n}\n\nstruct coeff_ram {\n\tu8 cache[COEFF_RAM_SIZE];\n\tbool synced;\n\tstruct mutex lock;\n};\n\nstatic inline void init_coeff_ram_cache(u8 *cache)\n{\n\tstatic const u8 norm_addrs[] = { 0x00, 0x05, 0x0a, 0x0f, 0x14, 0x19,\n\t\t0x1f, 0x20, 0x25, 0x2a, 0x2f, 0x34, 0x39, 0x3f, 0x40, 0x45,\n\t\t0x4a, 0x4f, 0x54, 0x59, 0x5f, 0x60, 0x65, 0x6a, 0x6f, 0x74,\n\t\t0x79, 0x7f, 0x80, 0x85, 0x8c, 0x91, 0x96, 0x97, 0x9c, 0xa3,\n\t\t0xa8, 0xad, 0xaf, 0xb0, 0xb5, 0xba, 0xbf, 0xc4, 0xc9};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(norm_addrs); i++)\n\t\tcache[((norm_addrs[i] + 1) * COEFF_SIZE) - 1] = 0x40;\n}\n\nstatic inline void coeff_ram_init(struct coeff_ram *ram)\n{\n\tinit_coeff_ram_cache(ram->cache);\n\tmutex_init(&ram->lock);\n}\n\nstruct aifs_status {\n\tu8 streams;\n};\n\nstatic inline void set_aif_status_active(struct aifs_status *status,\n\t\tint aif_id, bool playback)\n{\n\tu8 mask = 0x01 << (aif_id * 2 + !playback);\n\n\tstatus->streams |= mask;\n}\n\nstatic inline void set_aif_status_inactive(struct aifs_status *status,\n\t\tint aif_id, bool playback)\n{\n\tu8 mask = ~(0x01 << (aif_id * 2 + !playback));\n\n\tstatus->streams &= mask;\n}\n\nstatic bool aifs_active(struct aifs_status *status)\n{\n\treturn status->streams;\n}\n\nstatic bool aif_active(struct aifs_status *status, int aif_id)\n{\n\treturn (0x03 << aif_id * 2) & status->streams;\n}\n\nstruct tscs454 {\n\tstruct regmap *regmap;\n\tstruct aif aifs[TSCS454_DAI_COUNT];\n\n\tstruct aifs_status aifs_status;\n\tstruct mutex aifs_status_lock;\n\n\tstruct pll pll1;\n\tstruct pll pll2;\n\tstruct internal_rate internal_rate;\n\n\tstruct coeff_ram dac_ram;\n\tstruct coeff_ram spk_ram;\n\tstruct coeff_ram sub_ram;\n\n\tstruct clk *sysclk;\n\tint sysclk_src_id;\n\tunsigned int bclk_freq;\n};\n\nstruct coeff_ram_ctl {\n\tunsigned int addr;\n\tstruct soc_bytes_ext bytes_ext;\n};\n\nstatic const struct reg_sequence tscs454_patch[] = {\n\t \n\t{ R_AUDIOMUX1, FV_ASRCIMUX_I2S1 | FV_I2S2MUX_I2S2 },\n\t{ R_AUDIOMUX2, FV_ASRCOMUX_I2S1 | FV_DACMUX_I2S1 | FV_I2S3MUX_I2S3 },\n\t{ R_AUDIOMUX3, FV_CLSSDMUX_I2S1 | FV_SUBMUX_I2S1_LR },\n\t{ R_TDMCTL0, FV_TDMMD_256 },\n\t{ VIRT_ADDR(0x0A, 0x13), 1 << 3 },\n};\n\nstatic bool tscs454_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_PLLSTAT:\n\n\tcase R_SPKCRRDL:\n\tcase R_SPKCRRDM:\n\tcase R_SPKCRRDH:\n\tcase R_SPKCRS:\n\n\tcase R_DACCRRDL:\n\tcase R_DACCRRDM:\n\tcase R_DACCRRDH:\n\tcase R_DACCRS:\n\n\tcase R_SUBCRRDL:\n\tcase R_SUBCRRDM:\n\tcase R_SUBCRRDH:\n\tcase R_SUBCRS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool tscs454_writable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_SPKCRRDL:\n\tcase R_SPKCRRDM:\n\tcase R_SPKCRRDH:\n\n\tcase R_DACCRRDL:\n\tcase R_DACCRRDM:\n\tcase R_DACCRRDH:\n\n\tcase R_SUBCRRDL:\n\tcase R_SUBCRRDM:\n\tcase R_SUBCRRDH:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool tscs454_readable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_SPKCRWDL:\n\tcase R_SPKCRWDM:\n\tcase R_SPKCRWDH:\n\n\tcase R_DACCRWDL:\n\tcase R_DACCRWDM:\n\tcase R_DACCRWDH:\n\n\tcase R_SUBCRWDL:\n\tcase R_SUBCRWDM:\n\tcase R_SUBCRWDH:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool tscs454_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase R_SPKCRWDL:\n\tcase R_SPKCRWDM:\n\tcase R_SPKCRWDH:\n\tcase R_SPKCRRDL:\n\tcase R_SPKCRRDM:\n\tcase R_SPKCRRDH:\n\n\tcase R_DACCRWDL:\n\tcase R_DACCRWDM:\n\tcase R_DACCRWDH:\n\tcase R_DACCRRDL:\n\tcase R_DACCRRDM:\n\tcase R_DACCRRDH:\n\n\tcase R_SUBCRWDL:\n\tcase R_SUBCRWDM:\n\tcase R_SUBCRWDH:\n\tcase R_SUBCRRDL:\n\tcase R_SUBCRRDM:\n\tcase R_SUBCRRDH:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_range_cfg tscs454_regmap_range_cfg = {\n\t.name = \"Pages\",\n\t.range_min = VIRT_BASE,\n\t.range_max = VIRT_ADDR(0xFE, 0x02),\n\t.selector_reg = R_PAGESEL,\n\t.selector_mask = 0xff,\n\t.selector_shift = 0,\n\t.window_start = 0,\n\t.window_len = 0x100,\n};\n\nstatic struct regmap_config const tscs454_regmap_cfg = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.writeable_reg = tscs454_writable,\n\t.readable_reg = tscs454_readable,\n\t.volatile_reg = tscs454_volatile,\n\t.precious_reg = tscs454_precious,\n\t.ranges = &tscs454_regmap_range_cfg,\n\t.num_ranges = 1,\n\t.max_register = VIRT_ADDR(0xFE, 0x02),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic inline int tscs454_data_init(struct tscs454 *tscs454,\n\t\tstruct i2c_client *i2c)\n{\n\tint i;\n\tint ret;\n\n\ttscs454->regmap = devm_regmap_init_i2c(i2c, &tscs454_regmap_cfg);\n\tif (IS_ERR(tscs454->regmap)) {\n\t\tret = PTR_ERR(tscs454->regmap);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < TSCS454_DAI_COUNT; i++)\n\t\taif_init(&tscs454->aifs[i], i);\n\n\tmutex_init(&tscs454->aifs_status_lock);\n\tpll_init(&tscs454->pll1, 1);\n\tpll_init(&tscs454->pll2, 2);\n\n\tcoeff_ram_init(&tscs454->dac_ram);\n\tcoeff_ram_init(&tscs454->spk_ram);\n\tcoeff_ram_init(&tscs454->sub_ram);\n\n\treturn 0;\n}\n\nstruct reg_setting {\n\tunsigned int addr;\n\tunsigned int val;\n};\n\nstatic int coeff_ram_get(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\tu8 *coeff_ram;\n\tstruct mutex *coeff_ram_lock;\n\n\tif (strstr(kcontrol->id.name, \"DAC\")) {\n\t\tcoeff_ram = tscs454->dac_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->dac_ram.lock;\n\t} else if (strstr(kcontrol->id.name, \"Speaker\")) {\n\t\tcoeff_ram = tscs454->spk_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->spk_ram.lock;\n\t} else if (strstr(kcontrol->id.name, \"Sub\")) {\n\t\tcoeff_ram = tscs454->sub_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->sub_ram.lock;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(coeff_ram_lock);\n\n\tmemcpy(ucontrol->value.bytes.data,\n\t\t&coeff_ram[ctl->addr * COEFF_SIZE], params->max);\n\n\tmutex_unlock(coeff_ram_lock);\n\n\treturn 0;\n}\n\n#define DACCRSTAT_MAX_TRYS 10\nstatic int write_coeff_ram(struct snd_soc_component *component, u8 *coeff_ram,\n\t\tunsigned int r_stat, unsigned int r_addr, unsigned int r_wr,\n\t\tunsigned int coeff_addr, unsigned int coeff_cnt)\n{\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint cnt;\n\tint trys;\n\tint ret;\n\n\tfor (cnt = 0; cnt < coeff_cnt; cnt++, coeff_addr++) {\n\n\t\tfor (trys = 0; trys < DACCRSTAT_MAX_TRYS; trys++) {\n\t\t\tval = snd_soc_component_read(component, r_stat);\n\t\t\tif (!val)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (trys == DACCRSTAT_MAX_TRYS) {\n\t\t\tret = -EIO;\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Coefficient write error (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_write(tscs454->regmap, r_addr, coeff_addr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to write dac ram address (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = regmap_bulk_write(tscs454->regmap, r_wr,\n\t\t\t&coeff_ram[coeff_addr * COEFF_SIZE],\n\t\t\tCOEFF_SIZE);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to write dac ram (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int coeff_ram_put(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\tunsigned int coeff_cnt = params->max / COEFF_SIZE;\n\tu8 *coeff_ram;\n\tstruct mutex *coeff_ram_lock;\n\tbool *coeff_ram_synced;\n\tunsigned int r_stat;\n\tunsigned int r_addr;\n\tunsigned int r_wr;\n\tunsigned int val;\n\tint ret;\n\n\tif (strstr(kcontrol->id.name, \"DAC\")) {\n\t\tcoeff_ram = tscs454->dac_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->dac_ram.lock;\n\t\tcoeff_ram_synced = &tscs454->dac_ram.synced;\n\t\tr_stat = R_DACCRS;\n\t\tr_addr = R_DACCRADD;\n\t\tr_wr = R_DACCRWDL;\n\t} else if (strstr(kcontrol->id.name, \"Speaker\")) {\n\t\tcoeff_ram = tscs454->spk_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->spk_ram.lock;\n\t\tcoeff_ram_synced = &tscs454->spk_ram.synced;\n\t\tr_stat = R_SPKCRS;\n\t\tr_addr = R_SPKCRADD;\n\t\tr_wr = R_SPKCRWDL;\n\t} else if (strstr(kcontrol->id.name, \"Sub\")) {\n\t\tcoeff_ram = tscs454->sub_ram.cache;\n\t\tcoeff_ram_lock = &tscs454->sub_ram.lock;\n\t\tcoeff_ram_synced = &tscs454->sub_ram.synced;\n\t\tr_stat = R_SUBCRS;\n\t\tr_addr = R_SUBCRADD;\n\t\tr_wr = R_SUBCRWDL;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(coeff_ram_lock);\n\n\t*coeff_ram_synced = false;\n\n\tmemcpy(&coeff_ram[ctl->addr * COEFF_SIZE],\n\t\tucontrol->value.bytes.data, params->max);\n\n\tmutex_lock(&tscs454->pll1.lock);\n\tmutex_lock(&tscs454->pll2.lock);\n\n\tval = snd_soc_component_read(component, R_PLLSTAT);\n\tif (val) {  \n\t\tret = write_coeff_ram(component, coeff_ram,\n\t\t\tr_stat, r_addr, r_wr,\n\t\t\tctl->addr, coeff_cnt);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to flush coeff ram cache (%d)\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t\t*coeff_ram_synced = true;\n\t}\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs454->pll2.lock);\n\tmutex_unlock(&tscs454->pll1.lock);\n\tmutex_unlock(coeff_ram_lock);\n\n\treturn ret;\n}\n\nstatic inline int coeff_ram_sync(struct snd_soc_component *component,\n\t\tstruct tscs454 *tscs454)\n{\n\tint ret;\n\n\tmutex_lock(&tscs454->dac_ram.lock);\n\tif (!tscs454->dac_ram.synced) {\n\t\tret = write_coeff_ram(component, tscs454->dac_ram.cache,\n\t\t\t\tR_DACCRS, R_DACCRADD, R_DACCRWDL,\n\t\t\t\t0x00, COEFF_RAM_COEFF_COUNT);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tscs454->dac_ram.lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&tscs454->dac_ram.lock);\n\n\tmutex_lock(&tscs454->spk_ram.lock);\n\tif (!tscs454->spk_ram.synced) {\n\t\tret = write_coeff_ram(component, tscs454->spk_ram.cache,\n\t\t\t\tR_SPKCRS, R_SPKCRADD, R_SPKCRWDL,\n\t\t\t\t0x00, COEFF_RAM_COEFF_COUNT);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tscs454->spk_ram.lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&tscs454->spk_ram.lock);\n\n\tmutex_lock(&tscs454->sub_ram.lock);\n\tif (!tscs454->sub_ram.synced) {\n\t\tret = write_coeff_ram(component, tscs454->sub_ram.cache,\n\t\t\t\tR_SUBCRS, R_SUBCRADD, R_SUBCRWDL,\n\t\t\t\t0x00, COEFF_RAM_COEFF_COUNT);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&tscs454->sub_ram.lock);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmutex_unlock(&tscs454->sub_ram.lock);\n\n\treturn 0;\n}\n\n#define PLL_REG_SETTINGS_COUNT 11\nstruct pll_ctl {\n\tint freq_in;\n\tstruct reg_setting settings[PLL_REG_SETTINGS_COUNT];\n};\n\n#define PLL_CTL(f, t, c1, r1, o1, f1l, f1h, c2, r2, o2, f2l, f2h)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.freq_in = f,\t\t\t\t\t\t\\\n\t\t.settings = {\t\t\t\t\t\t\\\n\t\t\t{R_PLL1CTL,\tc1},\t\t\t\t\\\n\t\t\t{R_PLL1RDIV,\tr1},\t\t\t\t\\\n\t\t\t{R_PLL1ODIV,\to1},\t\t\t\t\\\n\t\t\t{R_PLL1FDIVL,\tf1l},\t\t\t\t\\\n\t\t\t{R_PLL1FDIVH,\tf1h},\t\t\t\t\\\n\t\t\t{R_PLL2CTL,\tc2},\t\t\t\t\\\n\t\t\t{R_PLL2RDIV,\tr2},\t\t\t\t\\\n\t\t\t{R_PLL2ODIV,\to2},\t\t\t\t\\\n\t\t\t{R_PLL2FDIVL,\tf2l},\t\t\t\t\\\n\t\t\t{R_PLL2FDIVH,\tf2h},\t\t\t\t\\\n\t\t\t{R_TIMEBASE,\tt},\t\t\t\t\\\n\t\t},\t\t\t\t\t\t\t\\\n\t}\n\nstatic const struct pll_ctl pll_ctls[] = {\n\tPLL_CTL(1411200, 0x05,\n\t\t0xB9, 0x07, 0x02, 0xC3, 0x04,\n\t\t0x5A, 0x02, 0x03, 0xE0, 0x01),\n\tPLL_CTL(1536000, 0x05,\n\t\t0x5A, 0x02, 0x03, 0xE0, 0x01,\n\t\t0x5A, 0x02, 0x03, 0xB9, 0x01),\n\tPLL_CTL(2822400, 0x0A,\n\t\t0x63, 0x07, 0x04, 0xC3, 0x04,\n\t\t0x62, 0x07, 0x03, 0x48, 0x03),\n\tPLL_CTL(3072000, 0x0B,\n\t\t0x62, 0x07, 0x03, 0x48, 0x03,\n\t\t0x5A, 0x04, 0x03, 0xB9, 0x01),\n\tPLL_CTL(5644800, 0x15,\n\t\t0x63, 0x0E, 0x04, 0xC3, 0x04,\n\t\t0x5A, 0x08, 0x03, 0xE0, 0x01),\n\tPLL_CTL(6144000, 0x17,\n\t\t0x5A, 0x08, 0x03, 0xE0, 0x01,\n\t\t0x5A, 0x08, 0x03, 0xB9, 0x01),\n\tPLL_CTL(12000000, 0x2E,\n\t\t0x5B, 0x19, 0x03, 0x00, 0x03,\n\t\t0x6A, 0x19, 0x05, 0x98, 0x04),\n\tPLL_CTL(19200000, 0x4A,\n\t\t0x53, 0x14, 0x03, 0x80, 0x01,\n\t\t0x5A, 0x19, 0x03, 0xB9, 0x01),\n\tPLL_CTL(22000000, 0x55,\n\t\t0x6A, 0x37, 0x05, 0x00, 0x06,\n\t\t0x62, 0x26, 0x03, 0x49, 0x02),\n\tPLL_CTL(22579200, 0x57,\n\t\t0x62, 0x31, 0x03, 0x20, 0x03,\n\t\t0x53, 0x1D, 0x03, 0xB3, 0x01),\n\tPLL_CTL(24000000, 0x5D,\n\t\t0x53, 0x19, 0x03, 0x80, 0x01,\n\t\t0x5B, 0x19, 0x05, 0x4C, 0x02),\n\tPLL_CTL(24576000, 0x5F,\n\t\t0x53, 0x1D, 0x03, 0xB3, 0x01,\n\t\t0x62, 0x40, 0x03, 0x72, 0x03),\n\tPLL_CTL(27000000, 0x68,\n\t\t0x62, 0x4B, 0x03, 0x00, 0x04,\n\t\t0x6A, 0x7D, 0x03, 0x20, 0x06),\n\tPLL_CTL(36000000, 0x8C,\n\t\t0x5B, 0x4B, 0x03, 0x00, 0x03,\n\t\t0x6A, 0x7D, 0x03, 0x98, 0x04),\n\tPLL_CTL(11289600, 0x2B,\n\t\t0x6A, 0x31, 0x03, 0x40, 0x06,\n\t\t0x5A, 0x12, 0x03, 0x1C, 0x02),\n\tPLL_CTL(26000000, 0x65,\n\t\t0x63, 0x41, 0x05, 0x00, 0x06,\n\t\t0x5A, 0x26, 0x03, 0xEF, 0x01),\n\tPLL_CTL(12288000, 0x2F,\n\t\t0x5A, 0x12, 0x03, 0x1C, 0x02,\n\t\t0x62, 0x20, 0x03, 0x72, 0x03),\n\tPLL_CTL(40000000, 0x9B,\n\t\t0xA2, 0x7D, 0x03, 0x80, 0x04,\n\t\t0x63, 0x7D, 0x05, 0xE4, 0x06),\n\tPLL_CTL(512000, 0x01,\n\t\t0x62, 0x01, 0x03, 0xD0, 0x02,\n\t\t0x5B, 0x01, 0x04, 0x72, 0x03),\n\tPLL_CTL(705600, 0x02,\n\t\t0x62, 0x02, 0x03, 0x15, 0x04,\n\t\t0x62, 0x01, 0x04, 0x80, 0x02),\n\tPLL_CTL(1024000, 0x03,\n\t\t0x62, 0x02, 0x03, 0xD0, 0x02,\n\t\t0x5B, 0x02, 0x04, 0x72, 0x03),\n\tPLL_CTL(2048000, 0x07,\n\t\t0x62, 0x04, 0x03, 0xD0, 0x02,\n\t\t0x5B, 0x04, 0x04, 0x72, 0x03),\n\tPLL_CTL(2400000, 0x08,\n\t\t0x62, 0x05, 0x03, 0x00, 0x03,\n\t\t0x63, 0x05, 0x05, 0x98, 0x04),\n};\n\nstatic inline const struct pll_ctl *get_pll_ctl(unsigned long freq_in)\n{\n\tint i;\n\tstruct pll_ctl const *pll_ctl = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_ctls); ++i)\n\t\tif (pll_ctls[i].freq_in == freq_in) {\n\t\t\tpll_ctl = &pll_ctls[i];\n\t\t\tbreak;\n\t\t}\n\n\treturn pll_ctl;\n}\n\nenum {\n\tPLL_INPUT_XTAL = 0,\n\tPLL_INPUT_MCLK1,\n\tPLL_INPUT_MCLK2,\n\tPLL_INPUT_BCLK,\n};\n\nstatic int set_sysclk(struct snd_soc_component *component)\n{\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct pll_ctl const *pll_ctl;\n\tunsigned long freq;\n\tint i;\n\tint ret;\n\n\tif (tscs454->sysclk_src_id < PLL_INPUT_BCLK)\n\t\tfreq = clk_get_rate(tscs454->sysclk);\n\telse\n\t\tfreq = tscs454->bclk_freq;\n\tpll_ctl = get_pll_ctl(freq);\n\tif (!pll_ctl) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev,\n\t\t\t\t\"Invalid PLL input %lu (%d)\\n\", freq, ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < PLL_REG_SETTINGS_COUNT; ++i) {\n\t\tret = snd_soc_component_write(component,\n\t\t\t\tpll_ctl->settings[i].addr,\n\t\t\t\tpll_ctl->settings[i].val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to set pll setting (%d)\\n\",\n\t\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void reserve_pll(struct pll *pll)\n{\n\tmutex_lock(&pll->lock);\n\tpll->users++;\n\tmutex_unlock(&pll->lock);\n}\n\nstatic inline void free_pll(struct pll *pll)\n{\n\tmutex_lock(&pll->lock);\n\tpll->users--;\n\tmutex_unlock(&pll->lock);\n}\n\nstatic int pll_connected(struct snd_soc_dapm_widget *source,\n\t\tstruct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tint users;\n\n\tif (strstr(source->name, \"PLL 1\")) {\n\t\tmutex_lock(&tscs454->pll1.lock);\n\t\tusers = tscs454->pll1.users;\n\t\tmutex_unlock(&tscs454->pll1.lock);\n\t\tdev_dbg(component->dev, \"%s(): PLL 1 users = %d\\n\", __func__,\n\t\t\t\tusers);\n\t} else {\n\t\tmutex_lock(&tscs454->pll2.lock);\n\t\tusers = tscs454->pll2.users;\n\t\tmutex_unlock(&tscs454->pll2.lock);\n\t\tdev_dbg(component->dev, \"%s(): PLL 2 users = %d\\n\", __func__,\n\t\t\t\tusers);\n\t}\n\n\treturn users;\n}\n\n \nstatic int pll_power_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tbool enable;\n\tbool pll1;\n\tunsigned int msk;\n\tunsigned int val;\n\tint ret;\n\n\tif (strstr(w->name, \"PLL 1\"))\n\t\tpll1 = true;\n\telse\n\t\tpll1 = false;\n\n\tmsk = pll1 ? FM_PLLCTL_PLL1CLKEN : FM_PLLCTL_PLL2CLKEN;\n\n\tif (event == SND_SOC_DAPM_POST_PMU)\n\t\tenable = true;\n\telse\n\t\tenable = false;\n\n\tif (enable)\n\t\tval = pll1 ? FV_PLL1CLKEN_ENABLE : FV_PLL2CLKEN_ENABLE;\n\telse\n\t\t \n\t\tval = FV_PLL1CLKEN_DISABLE;\n\n\tret = snd_soc_component_update_bits(component, R_PLLCTL, msk, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to %s PLL %d  (%d)\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\",\n\t\t\t\tpll1 ? 1 : 2,\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (enable) {\n\t\tmsleep(20); \n\t\tret = coeff_ram_sync(component, tscs454);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to sync coeff ram (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int aif_set_provider(struct snd_soc_component *component,\n\t\tunsigned int aif_id, bool provider)\n{\n\tunsigned int reg;\n\tunsigned int mask;\n\tunsigned int val;\n\tint ret;\n\n\tswitch (aif_id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_I2SP1CTL;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_I2SP2CTL;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_I2SP3CTL;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tdev_err(component->dev, \"Unknown DAI %d (%d)\\n\", aif_id, ret);\n\t\treturn ret;\n\t}\n\tmask = FM_I2SPCTL_PORTMS;\n\tval = provider ? FV_PORTMS_MASTER : FV_PORTMS_SLAVE;\n\n\tret = snd_soc_component_update_bits(component, reg, mask, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set DAI %d to %s (%d)\\n\",\n\t\t\taif_id, provider ? \"provider\" : \"consumer\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline\nint aif_prepare(struct snd_soc_component *component, struct aif *aif)\n{\n\tint ret;\n\n\tret = aif_set_provider(component, aif->id, aif->provider);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic inline int aif_free(struct snd_soc_component *component,\n\t\tstruct aif *aif, bool playback)\n{\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&tscs454->aifs_status_lock);\n\n\tdev_dbg(component->dev, \"%s(): aif %d\\n\", __func__, aif->id);\n\n\tset_aif_status_inactive(&tscs454->aifs_status, aif->id, playback);\n\n\tdev_dbg(component->dev, \"Set aif %d inactive. Streams status is 0x%x\\n\",\n\t\taif->id, tscs454->aifs_status.streams);\n\n\tif (!aif_active(&tscs454->aifs_status, aif->id)) {\n\t\t \n\t\taif_set_provider(component, aif->id, false);\n\t\tdev_dbg(component->dev, \"Freeing pll %d from aif %d\\n\",\n\t\t\t\taif->pll->id, aif->id);\n\t\tfree_pll(aif->pll);\n\t}\n\n\tif (!aifs_active(&tscs454->aifs_status)) {\n\t\tdev_dbg(component->dev, \"Freeing pll %d from ir\\n\",\n\t\t\t\ttscs454->internal_rate.pll->id);\n\t\tfree_pll(tscs454->internal_rate.pll);\n\t}\n\n\tmutex_unlock(&tscs454->aifs_status_lock);\n\n\treturn 0;\n}\n\n \nstatic char const * const bclk_sel_txt[] = {\n\t\t\"BCLK 1\", \"BCLK 2\", \"BCLK 3\"};\n\nstatic struct soc_enum const bclk_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_PLLCTL, FB_PLLCTL_BCLKSEL,\n\t\t\t\tARRAY_SIZE(bclk_sel_txt), bclk_sel_txt);\n\n \nstatic char const * const isrc_br_txt[] = {\n\t\t\"44.1kHz\", \"48kHz\"};\n\nstatic struct soc_enum const isrc_br_enum =\n\t\tSOC_ENUM_SINGLE(R_ISRC, FB_ISRC_IBR,\n\t\t\t\tARRAY_SIZE(isrc_br_txt), isrc_br_txt);\n\nstatic char const * const isrc_bm_txt[] = {\n\t\t\"0.25x\", \"0.5x\", \"1.0x\", \"2.0x\"};\n\nstatic struct soc_enum const isrc_bm_enum =\n\t\tSOC_ENUM_SINGLE(R_ISRC, FB_ISRC_IBM,\n\t\t\t\tARRAY_SIZE(isrc_bm_txt), isrc_bm_txt);\n\n \nstatic char const * const modular_rate_txt[] = {\n\t\"Reserved\", \"Half\", \"Full\", \"Auto\",};\n\nstatic struct soc_enum const adc_modular_rate_enum =\n\tSOC_ENUM_SINGLE(R_SCLKCTL, FB_SCLKCTL_ASDM,\n\t\t\tARRAY_SIZE(modular_rate_txt), modular_rate_txt);\n\nstatic struct soc_enum const dac_modular_rate_enum =\n\tSOC_ENUM_SINGLE(R_SCLKCTL, FB_SCLKCTL_DSDM,\n\t\t\tARRAY_SIZE(modular_rate_txt), modular_rate_txt);\n\n \nstatic char const * const data_ctrl_txt[] = {\n\t\"L/R\", \"L/L\", \"R/R\", \"R/L\"};\n\nstatic struct soc_enum const data_in_ctrl_enums[] = {\n\tSOC_ENUM_SINGLE(R_I2SIDCTL, FB_I2SIDCTL_I2SI1DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n\tSOC_ENUM_SINGLE(R_I2SIDCTL, FB_I2SIDCTL_I2SI2DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n\tSOC_ENUM_SINGLE(R_I2SIDCTL, FB_I2SIDCTL_I2SI3DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n};\n\n \nstatic struct soc_enum const data_out_ctrl_enums[] = {\n\tSOC_ENUM_SINGLE(R_I2SODCTL, FB_I2SODCTL_I2SO1DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n\tSOC_ENUM_SINGLE(R_I2SODCTL, FB_I2SODCTL_I2SO2DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n\tSOC_ENUM_SINGLE(R_I2SODCTL, FB_I2SODCTL_I2SO3DCTL,\n\t\t\tARRAY_SIZE(data_ctrl_txt), data_ctrl_txt),\n};\n\n \nstatic char const * const asrc_mux_txt[] = {\n\t\t\"None\", \"DAI 1\", \"DAI 2\", \"DAI 3\"};\n\nstatic struct soc_enum const asrc_in_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX1, FB_AUDIOMUX1_ASRCIMUX,\n\t\t\t\tARRAY_SIZE(asrc_mux_txt), asrc_mux_txt);\n\nstatic char const * const dai_mux_txt[] = {\n\t\t\"CH 0_1\", \"CH 2_3\", \"CH 4_5\", \"ADC/DMic 1\",\n\t\t\"DMic 2\", \"ClassD\", \"DAC\", \"Sub\"};\n\nstatic struct soc_enum const dai2_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX1, FB_AUDIOMUX1_I2S2MUX,\n\t\t\t\tARRAY_SIZE(dai_mux_txt), dai_mux_txt);\n\nstatic struct snd_kcontrol_new const dai2_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"DAI 2 Mux\",  dai2_mux_enum);\n\nstatic struct soc_enum const dai1_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX1, FB_AUDIOMUX1_I2S1MUX,\n\t\t\t\tARRAY_SIZE(dai_mux_txt), dai_mux_txt);\n\nstatic struct snd_kcontrol_new const dai1_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"DAI 1 Mux\", dai1_mux_enum);\n\n \nstatic struct soc_enum const asrc_out_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX2, FB_AUDIOMUX2_ASRCOMUX,\n\t\t\t\tARRAY_SIZE(asrc_mux_txt), asrc_mux_txt);\n\nstatic struct soc_enum const dac_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX2, FB_AUDIOMUX2_DACMUX,\n\t\t\t\tARRAY_SIZE(dai_mux_txt), dai_mux_txt);\n\nstatic struct snd_kcontrol_new const dac_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"DAC Mux\", dac_mux_enum);\n\nstatic struct soc_enum const dai3_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX2, FB_AUDIOMUX2_I2S3MUX,\n\t\t\t\tARRAY_SIZE(dai_mux_txt), dai_mux_txt);\n\nstatic struct snd_kcontrol_new const dai3_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"DAI 3 Mux\", dai3_mux_enum);\n\n \nstatic char const * const sub_mux_txt[] = {\n\t\t\"CH 0\", \"CH 1\", \"CH 0 + 1\",\n\t\t\"CH 2\", \"CH 3\", \"CH 2 + 3\",\n\t\t\"CH 4\", \"CH 5\", \"CH 4 + 5\",\n\t\t\"ADC/DMic 1 Left\", \"ADC/DMic 1 Right\",\n\t\t\"ADC/DMic 1 Left Plus Right\",\n\t\t\"DMic 2 Left\", \"DMic 2 Right\", \"DMic 2 Left Plus Right\",\n\t\t\"ClassD Left\", \"ClassD Right\", \"ClassD Left Plus Right\"};\n\nstatic struct soc_enum const sub_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX3, FB_AUDIOMUX3_SUBMUX,\n\t\t\t\tARRAY_SIZE(sub_mux_txt), sub_mux_txt);\n\nstatic struct snd_kcontrol_new const sub_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"Sub Mux\", sub_mux_enum);\n\nstatic struct soc_enum const classd_mux_enum =\n\t\tSOC_ENUM_SINGLE(R_AUDIOMUX3, FB_AUDIOMUX3_CLSSDMUX,\n\t\t\t\tARRAY_SIZE(dai_mux_txt), dai_mux_txt);\n\nstatic struct snd_kcontrol_new const classd_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"ClassD Mux\", classd_mux_enum);\n\n \nstatic char const * const jack_type_txt[] = {\n\t\t\"3 Terminal\", \"4 Terminal\"};\n\nstatic struct soc_enum const hp_jack_type_enum =\n\t\tSOC_ENUM_SINGLE(R_HSDCTL1, FB_HSDCTL1_HPJKTYPE,\n\t\t\t\tARRAY_SIZE(jack_type_txt), jack_type_txt);\n\nstatic char const * const hs_det_pol_txt[] = {\n\t\t\"Rising\", \"Falling\"};\n\nstatic struct soc_enum const hs_det_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_HSDCTL1, FB_HSDCTL1_HSDETPOL,\n\t\t\t\tARRAY_SIZE(hs_det_pol_txt), hs_det_pol_txt);\n\n \nstatic char const * const hs_mic_bias_force_txt[] = {\n\t\t\"Off\", \"Ring\", \"Sleeve\"};\n\nstatic struct soc_enum const hs_mic_bias_force_enum =\n\t\tSOC_ENUM_SINGLE(R_HSDCTL2, FB_HSDCTL2_FMICBIAS1,\n\t\t\t\tARRAY_SIZE(hs_mic_bias_force_txt),\n\t\t\t\ths_mic_bias_force_txt);\n\nstatic char const * const plug_type_txt[] = {\n\t\t\"OMTP\", \"CTIA\", \"Reserved\", \"Headphone\"};\n\nstatic struct soc_enum const plug_type_force_enum =\n\t\tSOC_ENUM_SINGLE(R_HSDCTL2, FB_HSDCTL2_FPLUGTYPE,\n\t\tARRAY_SIZE(plug_type_txt), plug_type_txt);\n\n\n \nstatic char const * const in_bst_mux_txt[] = {\n\t\t\"Input 1\", \"Input 2\", \"Input 3\", \"D2S\"};\n\nstatic struct soc_enum const in_bst_mux_ch0_enum =\n\t\tSOC_ENUM_SINGLE(R_CH0AIC, FB_CH0AIC_INSELL,\n\t\t\t\tARRAY_SIZE(in_bst_mux_txt),\n\t\t\t\tin_bst_mux_txt);\nstatic struct snd_kcontrol_new const in_bst_mux_ch0_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"Input Boost Channel 0 Enum\",\n\t\t\t\tin_bst_mux_ch0_enum);\n\nstatic DECLARE_TLV_DB_SCALE(in_bst_vol_tlv_arr, 0, 1000, 0);\n\nstatic char const * const adc_mux_txt[] = {\n\t\t\"Input 1 Boost Bypass\", \"Input 2 Boost Bypass\",\n\t\t\"Input 3 Boost Bypass\", \"Input Boost\"};\n\nstatic struct soc_enum const adc_mux_ch0_enum =\n\t\tSOC_ENUM_SINGLE(R_CH0AIC, FB_CH0AIC_LADCIN,\n\t\t\t\tARRAY_SIZE(adc_mux_txt), adc_mux_txt);\nstatic struct snd_kcontrol_new const adc_mux_ch0_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"ADC Channel 0 Enum\", adc_mux_ch0_enum);\n\nstatic char const * const in_proc_mux_txt[] = {\n\t\t\"ADC\", \"DMic\"};\n\nstatic struct soc_enum const in_proc_ch0_enum =\n\t\tSOC_ENUM_SINGLE(R_CH0AIC, FB_CH0AIC_IPCH0S,\n\t\t\t\tARRAY_SIZE(in_proc_mux_txt), in_proc_mux_txt);\nstatic struct snd_kcontrol_new const in_proc_mux_ch0_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"Input Processor Channel 0 Enum\",\n\t\t\t\tin_proc_ch0_enum);\n\n \nstatic struct soc_enum const in_bst_mux_ch1_enum =\n\t\tSOC_ENUM_SINGLE(R_CH1AIC, FB_CH1AIC_INSELR,\n\t\t\t\tARRAY_SIZE(in_bst_mux_txt),\n\t\t\t\tin_bst_mux_txt);\nstatic struct snd_kcontrol_new const in_bst_mux_ch1_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"Input Boost Channel 1 Enum\",\n\t\t\t\tin_bst_mux_ch1_enum);\n\nstatic struct soc_enum const adc_mux_ch1_enum =\n\t\tSOC_ENUM_SINGLE(R_CH1AIC, FB_CH1AIC_RADCIN,\n\t\t\t\tARRAY_SIZE(adc_mux_txt), adc_mux_txt);\nstatic struct snd_kcontrol_new const adc_mux_ch1_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"ADC Channel 1 Enum\", adc_mux_ch1_enum);\n\nstatic struct soc_enum const in_proc_ch1_enum =\n\t\tSOC_ENUM_SINGLE(R_CH1AIC, FB_CH1AIC_IPCH1S,\n\t\t\t\tARRAY_SIZE(in_proc_mux_txt), in_proc_mux_txt);\nstatic struct snd_kcontrol_new const in_proc_mux_ch1_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"Input Processor Channel 1 Enum\",\n\t\t\t\tin_proc_ch1_enum);\n\n \nstatic char const * const pol_txt[] = {\n\t\t\"Normal\", \"Invert\"};\n\nstatic struct soc_enum const in_pol_ch1_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL0, FB_ICTL0_IN0POL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic struct soc_enum const in_pol_ch0_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL0, FB_ICTL0_IN1POL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic char const * const in_proc_ch_sel_txt[] = {\n\t\t\"Normal\", \"Mono Mix to Channel 0\",\n\t\t\"Mono Mix to Channel 1\", \"Add\"};\n\nstatic struct soc_enum const in_proc_ch01_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL0, FB_ICTL0_INPCH10SEL,\n\t\t\t\tARRAY_SIZE(in_proc_ch_sel_txt),\n\t\t\t\tin_proc_ch_sel_txt);\n\n \nstatic struct soc_enum const in_pol_ch3_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL1, FB_ICTL1_IN2POL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic struct soc_enum const in_pol_ch2_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL1, FB_ICTL1_IN3POL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic struct soc_enum const in_proc_ch23_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_ICTL1, FB_ICTL1_INPCH32SEL,\n\t\t\t\tARRAY_SIZE(in_proc_ch_sel_txt),\n\t\t\t\tin_proc_ch_sel_txt);\n\n \nstatic char const * const mic_bias_txt[] = {\n\t\t\"2.5V\", \"2.1V\", \"1.8V\", \"Vdd\"};\n\nstatic struct soc_enum const mic_bias_2_enum =\n\t\tSOC_ENUM_SINGLE(R_MICBIAS, FB_MICBIAS_MICBOV2,\n\t\t\t\tARRAY_SIZE(mic_bias_txt), mic_bias_txt);\n\nstatic struct soc_enum const mic_bias_1_enum =\n\t\tSOC_ENUM_SINGLE(R_MICBIAS, FB_MICBIAS_MICBOV1,\n\t\t\t\tARRAY_SIZE(mic_bias_txt), mic_bias_txt);\n\n \n \n \n \nstatic DECLARE_TLV_DB_SCALE(in_pga_vol_tlv_arr, -1725, 75, 0);\n\n \n \n \n \nstatic DECLARE_TLV_DB_MINMAX(in_vol_tlv_arr, -7125, 2400);\n\n \n \n \n \nstatic DECLARE_TLV_DB_MINMAX(asrc_vol_tlv_arr, -9562, 600);\n\n \nstatic char const * const alc_mode_txt[] = {\n\t\t\"ALC\", \"Limiter\"};\n\nstatic struct soc_enum const alc_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_ALCCTL0, FB_ALCCTL0_ALCMODE,\n\t\t\t\tARRAY_SIZE(alc_mode_txt), alc_mode_txt);\n\nstatic char const * const alc_ref_text[] = {\n\t\t\"Channel 0\", \"Channel 1\", \"Channel 2\", \"Channel 3\", \"Peak\"};\n\nstatic struct soc_enum const alc_ref_enum =\n\t\tSOC_ENUM_SINGLE(R_ALCCTL0, FB_ALCCTL0_ALCREF,\n\t\t\t\tARRAY_SIZE(alc_ref_text), alc_ref_text);\n\n \nstatic DECLARE_TLV_DB_SCALE(alc_max_gain_tlv_arr, -1200, 600, 0);\nstatic DECLARE_TLV_DB_SCALE(alc_target_tlv_arr, -2850, 150, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(alc_min_gain_tlv_arr, -1725, 600, 0);\n\n \nstatic DECLARE_TLV_DB_SCALE(ngth_tlv_arr, -7650, 150, 0);\n\nstatic char const * const ngate_type_txt[] = {\n\t\t\"PGA Constant\", \"ADC Mute\"};\n\nstatic struct soc_enum const ngate_type_enum =\n\t\tSOC_ENUM_SINGLE(R_NGATE, FB_NGATE_NGG,\n\t\t\t\tARRAY_SIZE(ngate_type_txt), ngate_type_txt);\n\n \nstatic char const * const dmic_mono_sel_txt[] = {\n\t\t\"Stereo\", \"Mono\"};\n\nstatic struct soc_enum const dmic_mono_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_DMICCTL, FB_DMICCTL_DMONO,\n\t\t\tARRAY_SIZE(dmic_mono_sel_txt), dmic_mono_sel_txt);\n\n \nstatic struct soc_enum const dac_pol_r_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCTL, FB_DACCTL_DACPOLR,\n\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic struct soc_enum const dac_pol_l_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCTL, FB_DACCTL_DACPOLL,\n\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic char const * const dac_dith_txt[] = {\n\t\t\"Half\", \"Full\", \"Disabled\", \"Static\"};\n\nstatic struct soc_enum const dac_dith_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCTL, FB_DACCTL_DACDITH,\n\t\t\tARRAY_SIZE(dac_dith_txt), dac_dith_txt);\n\n \nstatic struct soc_enum const spk_pol_r_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKCTL, FB_SPKCTL_SPKPOLR,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic struct soc_enum const spk_pol_l_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKCTL, FB_SPKCTL_SPKPOLL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const sub_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBCTL, FB_SUBCTL_SUBPOL,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \n \nstatic DECLARE_TLV_DB_MINMAX(mvol_tlv_arr, -9562, 0);\n\n \n \nstatic DECLARE_TLV_DB_SCALE(hp_vol_tlv_arr, -8850, 75, 0);\n\n \n \nstatic DECLARE_TLV_DB_SCALE(spk_vol_tlv_arr, -7725, 75, 0);\n\n \nstatic char const * const eq_txt[] = {\n\t\"Pre Scale\",\n\t\"Pre Scale + EQ Band 0\",\n\t\"Pre Scale + EQ Band 0 - 1\",\n\t\"Pre Scale + EQ Band 0 - 2\",\n\t\"Pre Scale + EQ Band 0 - 3\",\n\t\"Pre Scale + EQ Band 0 - 4\",\n\t\"Pre Scale + EQ Band 0 - 5\",\n};\n\nstatic struct soc_enum const spk_eq_enums[] = {\n\tSOC_ENUM_SINGLE(R_SPKEQFILT, FB_SPKEQFILT_EQ2BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n\tSOC_ENUM_SINGLE(R_SPKEQFILT, FB_SPKEQFILT_EQ1BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n};\n\n \nstatic char const * const lvl_mode_txt[] = {\n\t\t\"Average\", \"Peak\"};\n\nstatic struct soc_enum const spk_mbc3_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_LVLMODE3,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic char const * const win_sel_txt[] = {\n\t\t\"512\", \"64\"};\n\nstatic struct soc_enum const spk_mbc3_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_WINSEL3,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const spk_mbc2_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_LVLMODE2,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const spk_mbc2_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_WINSEL2,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const spk_mbc1_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_LVLMODE1,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const spk_mbc1_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCCTL, FB_SPKMBCCTL_WINSEL1,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic struct soc_enum const spk_mbc1_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCMUG1, FB_SPKMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\nstatic DECLARE_TLV_DB_MINMAX(mbc_mug_tlv_arr, -4650, 0);\n\n \nstatic DECLARE_TLV_DB_MINMAX(thr_tlv_arr, -9562, 0);\n\n \nstatic char const * const comp_rat_txt[] = {\n\t\t\"Reserved\", \"1.5:1\", \"2:1\", \"3:1\", \"4:1\", \"5:1\", \"6:1\",\n\t\t\"7:1\", \"8:1\", \"9:1\", \"10:1\", \"11:1\", \"12:1\", \"13:1\", \"14:1\",\n\t\t\"15:1\", \"16:1\", \"17:1\", \"18:1\", \"19:1\", \"20:1\"};\n\nstatic struct soc_enum const spk_mbc1_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCRAT1, FB_SPKMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const spk_mbc2_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCMUG2, FB_SPKMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const spk_mbc2_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCRAT2, FB_SPKMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const spk_mbc3_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCMUG3, FB_SPKMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const spk_mbc3_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKMBCRAT3, FB_SPKMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const spk_cle_lvl_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKCLECTL, FB_SPKCLECTL_LVLMODE,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const spk_cle_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKCLECTL, FB_SPKCLECTL_WINSEL,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic DECLARE_TLV_DB_MINMAX(cle_mug_tlv_arr, 0, 4650);\n\n \nstatic struct soc_enum const spk_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKCOMPRAT, FB_SPKCOMPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic char const * const exp_rat_txt[] = {\n\t\t\"Reserved\", \"Reserved\", \"1:2\", \"1:3\",\n\t\t\"1:4\", \"1:5\", \"1:6\", \"1:7\"};\n\nstatic struct soc_enum const spk_exp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SPKEXPRAT, FB_SPKEXPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(exp_rat_txt), exp_rat_txt);\n\n \nstatic struct soc_enum const dac_eq_enums[] = {\n\tSOC_ENUM_SINGLE(R_DACEQFILT, FB_DACEQFILT_EQ2BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n\tSOC_ENUM_SINGLE(R_DACEQFILT, FB_DACEQFILT_EQ1BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n};\n\n \nstatic struct soc_enum const dac_mbc3_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE3,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const dac_mbc3_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL3,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const dac_mbc2_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE2,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const dac_mbc2_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL2,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const dac_mbc1_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_LVLMODE1,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const dac_mbc1_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCCTL, FB_DACMBCCTL_WINSEL1,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic struct soc_enum const dac_mbc1_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCMUG1, FB_DACMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const dac_mbc1_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCRAT1, FB_DACMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const dac_mbc2_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCMUG2, FB_DACMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const dac_mbc2_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCRAT2, FB_DACMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const dac_mbc3_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCMUG3, FB_DACMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const dac_mbc3_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_DACMBCRAT3, FB_DACMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const dac_cle_lvl_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCLECTL, FB_DACCLECTL_LVLMODE,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const dac_cle_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCLECTL, FB_DACCLECTL_WINSEL,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic struct soc_enum const dac_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_DACCOMPRAT, FB_DACCOMPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const dac_exp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_DACEXPRAT, FB_DACEXPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(exp_rat_txt), exp_rat_txt);\n\n \nstatic struct soc_enum const sub_eq_enums[] = {\n\tSOC_ENUM_SINGLE(R_SUBEQFILT, FB_SUBEQFILT_EQ2BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n\tSOC_ENUM_SINGLE(R_SUBEQFILT, FB_SUBEQFILT_EQ1BE,\n\t\tARRAY_SIZE(eq_txt), eq_txt),\n};\n\n \nstatic struct soc_enum const sub_mbc3_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_LVLMODE3,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const sub_mbc3_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_WINSEL3,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const sub_mbc2_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_LVLMODE2,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const sub_mbc2_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_WINSEL2,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\nstatic struct soc_enum const sub_mbc1_lvl_det_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_LVLMODE1,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\n\nstatic struct soc_enum const sub_mbc1_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCCTL, FB_SUBMBCCTL_WINSEL1,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic struct soc_enum const sub_mbc1_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCMUG1, FB_SUBMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const sub_mbc1_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCRAT1, FB_SUBMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const sub_mbc2_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCMUG2, FB_SUBMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const sub_mbc2_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCRAT2, FB_SUBMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const sub_mbc3_phase_pol_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCMUG3, FB_SUBMBCMUG_PHASE,\n\t\t\t\tARRAY_SIZE(pol_txt), pol_txt);\n\n \nstatic struct soc_enum const sub_mbc3_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBMBCRAT3, FB_SUBMBCRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const sub_cle_lvl_mode_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBCLECTL, FB_SUBCLECTL_LVLMODE,\n\t\t\t\tARRAY_SIZE(lvl_mode_txt), lvl_mode_txt);\nstatic struct soc_enum const sub_cle_win_sel_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBCLECTL, FB_SUBCLECTL_WINSEL,\n\t\t\t\tARRAY_SIZE(win_sel_txt), win_sel_txt);\n\n \nstatic struct soc_enum const sub_comp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBCOMPRAT, FB_SUBCOMPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(comp_rat_txt), comp_rat_txt);\n\n \nstatic struct soc_enum const sub_exp_rat_enum =\n\t\tSOC_ENUM_SINGLE(R_SUBEXPRAT, FB_SUBEXPRAT_RATIO,\n\t\t\t\tARRAY_SIZE(exp_rat_txt), exp_rat_txt);\n\nstatic int bytes_info_ext(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *ucontrol)\n{\n\tstruct coeff_ram_ctl *ctl =\n\t\t(struct coeff_ram_ctl *)kcontrol->private_value;\n\tstruct soc_bytes_ext *params = &ctl->bytes_ext;\n\n\tucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tucontrol->count = params->max;\n\n\treturn 0;\n}\n\n \nstatic char const * const ch_0_1_mux_txt[] = {\"DAI 1\", \"TDM 0_1\"};\n\nstatic struct soc_enum const ch_0_1_mux_enum =\n\t\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0,\n\t\t\t\tARRAY_SIZE(ch_0_1_mux_txt), ch_0_1_mux_txt);\n\nstatic struct snd_kcontrol_new const ch_0_1_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"CH 0_1 Input Mux\", ch_0_1_mux_enum);\n\n \nstatic char const * const ch_2_3_mux_txt[] = {\"DAI 2\", \"TDM 2_3\"};\n\nstatic struct soc_enum const ch_2_3_mux_enum =\n\t\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0,\n\t\t\t\tARRAY_SIZE(ch_2_3_mux_txt), ch_2_3_mux_txt);\n\nstatic struct snd_kcontrol_new const ch_2_3_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"CH 2_3 Input Mux\", ch_2_3_mux_enum);\n\n \nstatic char const * const ch_4_5_mux_txt[] = {\"DAI 3\", \"TDM 4_5\"};\n\nstatic struct soc_enum const ch_4_5_mux_enum =\n\t\tSOC_ENUM_SINGLE(SND_SOC_NOPM, 0,\n\t\t\t\tARRAY_SIZE(ch_4_5_mux_txt), ch_4_5_mux_txt);\n\nstatic struct snd_kcontrol_new const ch_4_5_mux_dapm_enum =\n\t\tSOC_DAPM_ENUM(\"CH 4_5 Input Mux\", ch_4_5_mux_enum);\n\n#define COEFF_RAM_CTL(xname, xcount, xaddr) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = bytes_info_ext, \\\n\t.get = coeff_ram_get, .put = coeff_ram_put, \\\n\t.private_value = (unsigned long)&(struct coeff_ram_ctl) { \\\n\t\t.addr = xaddr, \\\n\t\t.bytes_ext = {.max = xcount, }, \\\n\t} \\\n}\n\nstatic struct snd_kcontrol_new const tscs454_snd_controls[] = {\n\t \n\tSOC_ENUM(\"PLL BCLK Input\", bclk_sel_enum),\n\t \n\tSOC_ENUM(\"Internal Rate\", isrc_br_enum),\n\tSOC_ENUM(\"Internal Rate Multiple\", isrc_bm_enum),\n\t \n\tSOC_ENUM(\"ADC Modular Rate\", adc_modular_rate_enum),\n\tSOC_ENUM(\"DAC Modular Rate\", dac_modular_rate_enum),\n\t \n\tSOC_SINGLE(\"ASRC Out High Bandwidth Switch\",\n\t\t\tR_ASRC, FB_ASRC_ASRCOBW, 1, 0),\n\tSOC_SINGLE(\"ASRC In High Bandwidth Switch\",\n\t\t\tR_ASRC, FB_ASRC_ASRCIBW, 1, 0),\n\t \n\tSOC_ENUM(\"I2S 1 Data In Control\", data_in_ctrl_enums[0]),\n\tSOC_ENUM(\"I2S 2 Data In Control\", data_in_ctrl_enums[1]),\n\tSOC_ENUM(\"I2S 3 Data In Control\", data_in_ctrl_enums[2]),\n\t \n\tSOC_ENUM(\"I2S 1 Data Out Control\", data_out_ctrl_enums[0]),\n\tSOC_ENUM(\"I2S 2 Data Out Control\", data_out_ctrl_enums[1]),\n\tSOC_ENUM(\"I2S 3 Data Out Control\", data_out_ctrl_enums[2]),\n\t \n\tSOC_ENUM(\"ASRC In\", asrc_in_mux_enum),\n\t \n\tSOC_ENUM(\"ASRC Out\", asrc_out_mux_enum),\n\t \n\tSOC_ENUM(\"Headphone Jack Type\", hp_jack_type_enum),\n\tSOC_ENUM(\"Headset Detection Polarity\", hs_det_pol_enum),\n\tSOC_SINGLE(\"Headphone Detection Switch\",\n\t\t\tR_HSDCTL1, FB_HSDCTL1_HPID_EN, 1, 0),\n\tSOC_SINGLE(\"Headset OMTP/CTIA Switch\",\n\t\t\tR_HSDCTL1, FB_HSDCTL1_GBLHS_EN, 1, 0),\n\t \n\tSOC_ENUM(\"Headset Mic Bias Force\", hs_mic_bias_force_enum),\n\tSOC_SINGLE(\"Manual Mic Bias Switch\",\n\t\t\tR_HSDCTL2, FB_HSDCTL2_MB1MODE, 1, 0),\n\tSOC_SINGLE(\"Ring/Sleeve Auto Switch\",\n\t\t\tR_HSDCTL2, FB_HSDCTL2_SWMODE, 1, 0),\n\tSOC_ENUM(\"Manual Mode Plug Type\", plug_type_force_enum),\n\t \n\tSOC_SINGLE_TLV(\"Input Boost Channel 0 Volume\", R_CH0AIC,\n\t\t\tFB_CHAIC_MICBST, 0x3, 0, in_bst_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Boost Channel 1 Volume\", R_CH1AIC,\n\t\t\tFB_CHAIC_MICBST, 0x3, 0, in_bst_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Boost Channel 2 Volume\", R_CH2AIC,\n\t\t\tFB_CHAIC_MICBST, 0x3, 0, in_bst_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Boost Channel 3 Volume\", R_CH3AIC,\n\t\t\tFB_CHAIC_MICBST, 0x3, 0, in_bst_vol_tlv_arr),\n\t \n\tSOC_ENUM(\"Input Channel 1 Polarity\", in_pol_ch1_enum),\n\tSOC_ENUM(\"Input Channel 0 Polarity\", in_pol_ch0_enum),\n\tSOC_ENUM(\"Input Processor Channel 0/1 Operation\",\n\t\t\tin_proc_ch01_sel_enum),\n\tSOC_SINGLE(\"Input Channel 1 Mute Switch\",\n\t\t\tR_ICTL0, FB_ICTL0_IN1MUTE, 1, 0),\n\tSOC_SINGLE(\"Input Channel 0 Mute Switch\",\n\t\t\tR_ICTL0, FB_ICTL0_IN0MUTE, 1, 0),\n\tSOC_SINGLE(\"Input Channel 1 HPF Disable Switch\",\n\t\t\tR_ICTL0, FB_ICTL0_IN1HP, 1, 0),\n\tSOC_SINGLE(\"Input Channel 0 HPF Disable Switch\",\n\t\t\tR_ICTL0, FB_ICTL0_IN0HP, 1, 0),\n\t \n\tSOC_ENUM(\"Input Channel 3 Polarity\", in_pol_ch3_enum),\n\tSOC_ENUM(\"Input Channel 2 Polarity\", in_pol_ch2_enum),\n\tSOC_ENUM(\"Input Processor Channel 2/3 Operation\",\n\t\t\tin_proc_ch23_sel_enum),\n\tSOC_SINGLE(\"Input Channel 3 Mute Switch\",\n\t\t\tR_ICTL1, FB_ICTL1_IN3MUTE, 1, 0),\n\tSOC_SINGLE(\"Input Channel 2 Mute Switch\",\n\t\t\tR_ICTL1, FB_ICTL1_IN2MUTE, 1, 0),\n\tSOC_SINGLE(\"Input Channel 3 HPF Disable Switch\",\n\t\t\tR_ICTL1, FB_ICTL1_IN3HP, 1, 0),\n\tSOC_SINGLE(\"Input Channel 2 HPF Disable Switch\",\n\t\t\tR_ICTL1, FB_ICTL1_IN2HP, 1, 0),\n\t \n\tSOC_ENUM(\"Mic Bias 2 Voltage\", mic_bias_2_enum),\n\tSOC_ENUM(\"Mic Bias 1 Voltage\", mic_bias_1_enum),\n\t \n\tSOC_SINGLE(\"Input Channel 0 PGA Mute Switch\",\n\t\t\tR_PGACTL0, FB_PGACTL_PGAMUTE, 1, 0),\n\tSOC_SINGLE_TLV(\"Input Channel 0 PGA Volume\", R_PGACTL0,\n\t\t\tFB_PGACTL_PGAVOL,\n\t\t\tFM_PGACTL_PGAVOL, 0, in_pga_vol_tlv_arr),\n\t \n\tSOC_SINGLE(\"Input Channel 1 PGA Mute Switch\",\n\t\t\tR_PGACTL1, FB_PGACTL_PGAMUTE, 1, 0),\n\tSOC_SINGLE_TLV(\"Input Channel 1 PGA Volume\", R_PGACTL1,\n\t\t\tFB_PGACTL_PGAVOL,\n\t\t\tFM_PGACTL_PGAVOL, 0, in_pga_vol_tlv_arr),\n\t \n\tSOC_SINGLE(\"Input Channel 2 PGA Mute Switch\",\n\t\t\tR_PGACTL2, FB_PGACTL_PGAMUTE, 1, 0),\n\tSOC_SINGLE_TLV(\"Input Channel 2 PGA Volume\", R_PGACTL2,\n\t\t\tFB_PGACTL_PGAVOL,\n\t\t\tFM_PGACTL_PGAVOL, 0, in_pga_vol_tlv_arr),\n\t \n\tSOC_SINGLE(\"Input Channel 3 PGA Mute Switch\",\n\t\t\tR_PGACTL3, FB_PGACTL_PGAMUTE, 1, 0),\n\tSOC_SINGLE_TLV(\"Input Channel 3 PGA Volume\", R_PGACTL3,\n\t\t\tFB_PGACTL_PGAVOL,\n\t\t\tFM_PGACTL_PGAVOL, 0, in_pga_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Channel 0 Volume\", R_ICH0VOL,\n\t\t\tFB_ICHVOL_ICHVOL, FM_ICHVOL_ICHVOL, 0, in_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Channel 1 Volume\", R_ICH1VOL,\n\t\t\tFB_ICHVOL_ICHVOL, FM_ICHVOL_ICHVOL, 0, in_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Channel 2 Volume\", R_ICH2VOL,\n\t\t\tFB_ICHVOL_ICHVOL, FM_ICHVOL_ICHVOL, 0, in_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Input Channel 3 Volume\", R_ICH3VOL,\n\t\t\tFB_ICHVOL_ICHVOL, FM_ICHVOL_ICHVOL, 0, in_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"ASRC Input Left Volume\", R_ASRCILVOL,\n\t\t\tFB_ASRCILVOL_ASRCILVOL, FM_ASRCILVOL_ASRCILVOL,\n\t\t\t0, asrc_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"ASRC Input Right Volume\", R_ASRCIRVOL,\n\t\t\tFB_ASRCIRVOL_ASRCIRVOL, FM_ASRCIRVOL_ASRCIRVOL,\n\t\t\t0, asrc_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"ASRC Output Left Volume\", R_ASRCOLVOL,\n\t\t\tFB_ASRCOLVOL_ASRCOLVOL, FM_ASRCOLVOL_ASRCOLVOL,\n\t\t\t0, asrc_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"ASRC Output Right Volume\", R_ASRCORVOL,\n\t\t\tFB_ASRCORVOL_ASRCOLVOL, FM_ASRCORVOL_ASRCOLVOL,\n\t\t\t0, asrc_vol_tlv_arr),\n\t \n\t \n\tSOC_ENUM(\"ALC Mode\", alc_mode_enum),\n\tSOC_ENUM(\"ALC Reference\", alc_ref_enum),\n\tSOC_SINGLE(\"Input Channel 3 ALC Switch\",\n\t\t\tR_ALCCTL0, FB_ALCCTL0_ALCEN3, 1, 0),\n\tSOC_SINGLE(\"Input Channel 2 ALC Switch\",\n\t\t\tR_ALCCTL0, FB_ALCCTL0_ALCEN2, 1, 0),\n\tSOC_SINGLE(\"Input Channel 1 ALC Switch\",\n\t\t\tR_ALCCTL0, FB_ALCCTL0_ALCEN1, 1, 0),\n\tSOC_SINGLE(\"Input Channel 0 ALC Switch\",\n\t\t\tR_ALCCTL0, FB_ALCCTL0_ALCEN0, 1, 0),\n\t \n\tSOC_SINGLE_TLV(\"ALC Max Gain Volume\", R_ALCCTL1,\n\t\t\tFB_ALCCTL1_MAXGAIN, FM_ALCCTL1_MAXGAIN,\n\t\t\t0, alc_max_gain_tlv_arr),\n\tSOC_SINGLE_TLV(\"ALC Target Volume\", R_ALCCTL1,\n\t\t\tFB_ALCCTL1_ALCL, FM_ALCCTL1_ALCL,\n\t\t\t0, alc_target_tlv_arr),\n\t \n\tSOC_SINGLE(\"ALC Zero Cross Switch\",\n\t\t\tR_ALCCTL2, FB_ALCCTL2_ALCZC, 1, 0),\n\tSOC_SINGLE_TLV(\"ALC Min Gain Volume\", R_ALCCTL2,\n\t\t\tFB_ALCCTL2_MINGAIN, FM_ALCCTL2_MINGAIN,\n\t\t\t0, alc_min_gain_tlv_arr),\n\tSOC_SINGLE_RANGE(\"ALC Hold\", R_ALCCTL2,\n\t\t\tFB_ALCCTL2_HLD, 0, FM_ALCCTL2_HLD, 0),\n\t \n\tSOC_SINGLE_RANGE(\"ALC Decay\", R_ALCCTL3,\n\t\t\tFB_ALCCTL3_DCY, 0, FM_ALCCTL3_DCY, 0),\n\tSOC_SINGLE_RANGE(\"ALC Attack\", R_ALCCTL3,\n\t\t\tFB_ALCCTL3_ATK, 0, FM_ALCCTL3_ATK, 0),\n\t \n\tSOC_SINGLE_TLV(\"Noise Gate Threshold Volume\", R_NGATE,\n\t\t\tFB_NGATE_NGTH, FM_NGATE_NGTH, 0, ngth_tlv_arr),\n\tSOC_ENUM(\"Noise Gate Type\", ngate_type_enum),\n\tSOC_SINGLE(\"Noise Gate Switch\", R_NGATE, FB_NGATE_NGAT, 1, 0),\n\t \n\tSOC_SINGLE(\"Digital Mic 2 Switch\", R_DMICCTL, FB_DMICCTL_DMIC2EN, 1, 0),\n\tSOC_SINGLE(\"Digital Mic 1 Switch\", R_DMICCTL, FB_DMICCTL_DMIC1EN, 1, 0),\n\tSOC_ENUM(\"Digital Mic Mono Select\", dmic_mono_sel_enum),\n\t \n\tSOC_ENUM(\"DAC Polarity Left\", dac_pol_r_enum),\n\tSOC_ENUM(\"DAC Polarity Right\", dac_pol_l_enum),\n\tSOC_ENUM(\"DAC Dither\", dac_dith_enum),\n\tSOC_SINGLE(\"DAC Mute Switch\", R_DACCTL, FB_DACCTL_DACMUTE, 1, 0),\n\tSOC_SINGLE(\"DAC De-Emphasis Switch\", R_DACCTL, FB_DACCTL_DACDEM, 1, 0),\n\t \n\tSOC_ENUM(\"Speaker Polarity Right\", spk_pol_r_enum),\n\tSOC_ENUM(\"Speaker Polarity Left\", spk_pol_l_enum),\n\tSOC_SINGLE(\"Speaker Mute Switch\", R_SPKCTL, FB_SPKCTL_SPKMUTE, 1, 0),\n\tSOC_SINGLE(\"Speaker De-Emphasis Switch\",\n\t\t\tR_SPKCTL, FB_SPKCTL_SPKDEM, 1, 0),\n\t \n\tSOC_ENUM(\"Sub Polarity\", sub_pol_enum),\n\tSOC_SINGLE(\"SUB Mute Switch\", R_SUBCTL, FB_SUBCTL_SUBMUTE, 1, 0),\n\tSOC_SINGLE(\"Sub De-Emphasis Switch\", R_SUBCTL, FB_SUBCTL_SUBDEM, 1, 0),\n\t \n\tSOC_SINGLE(\"Sub DC Removal Switch\", R_DCCTL, FB_DCCTL_SUBDCBYP, 1, 1),\n\tSOC_SINGLE(\"DAC DC Removal Switch\", R_DCCTL, FB_DCCTL_DACDCBYP, 1, 1),\n\tSOC_SINGLE(\"Speaker DC Removal Switch\",\n\t\t\tR_DCCTL, FB_DCCTL_SPKDCBYP, 1, 1),\n\tSOC_SINGLE(\"DC Removal Coefficient Switch\", R_DCCTL, FB_DCCTL_DCCOEFSEL,\n\t\t\tFM_DCCTL_DCCOEFSEL, 0),\n\t \n\tSOC_SINGLE(\"Output Fade Switch\", R_OVOLCTLU, FB_OVOLCTLU_OFADE, 1, 0),\n\t \n\t \n\tSOC_DOUBLE_R_TLV(\"Master Volume\", R_MVOLL, R_MVOLR,\n\t\t\tFB_MVOLL_MVOL_L, FM_MVOLL_MVOL_L, 0, mvol_tlv_arr),\n\t \n\t \n\tSOC_DOUBLE_R_TLV(\"Headphone Volume\", R_HPVOLL, R_HPVOLR,\n\t\t\tFB_HPVOLL_HPVOL_L, FM_HPVOLL_HPVOL_L, 0,\n\t\t\thp_vol_tlv_arr),\n\t \n\t \n\tSOC_DOUBLE_R_TLV(\"Speaker Volume\", R_SPKVOLL, R_SPKVOLR,\n\t\t\tFB_SPKVOLL_SPKVOL_L, FM_SPKVOLL_SPKVOL_L, 0,\n\t\t\tspk_vol_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub Volume\", R_SUBVOL,\n\t\t\tFB_SUBVOL_SUBVOL, FM_SUBVOL_SUBVOL, 0, spk_vol_tlv_arr),\n\t \n\tSOC_SINGLE(\"Speaker EQ 2 Switch\",\n\t\t\tR_SPKEQFILT, FB_SPKEQFILT_EQ2EN, 1, 0),\n\tSOC_ENUM(\"Speaker EQ 2 Band\", spk_eq_enums[0]),\n\tSOC_SINGLE(\"Speaker EQ 1 Switch\",\n\t\t\tR_SPKEQFILT, FB_SPKEQFILT_EQ1EN, 1, 0),\n\tSOC_ENUM(\"Speaker EQ 1 Band\", spk_eq_enums[1]),\n\t \n\tSOC_SINGLE(\"Speaker MBC 3 Switch\",\n\t\t\tR_SPKMBCEN, FB_SPKMBCEN_MBCEN3, 1, 0),\n\tSOC_SINGLE(\"Speaker MBC 2 Switch\",\n\t\t\tR_SPKMBCEN, FB_SPKMBCEN_MBCEN2, 1, 0),\n\tSOC_SINGLE(\"Speaker MBC 1 Switch\",\n\t\t\tR_SPKMBCEN, FB_SPKMBCEN_MBCEN1, 1, 0),\n\t \n\tSOC_ENUM(\"Speaker MBC 3 Mode\", spk_mbc3_lvl_det_mode_enum),\n\tSOC_ENUM(\"Speaker MBC 3 Window\", spk_mbc3_win_sel_enum),\n\tSOC_ENUM(\"Speaker MBC 2 Mode\", spk_mbc2_lvl_det_mode_enum),\n\tSOC_ENUM(\"Speaker MBC 2 Window\", spk_mbc2_win_sel_enum),\n\tSOC_ENUM(\"Speaker MBC 1 Mode\", spk_mbc1_lvl_det_mode_enum),\n\tSOC_ENUM(\"Speaker MBC 1 Window\", spk_mbc1_win_sel_enum),\n\t \n\tSOC_ENUM(\"Speaker MBC 1 Phase Polarity\", spk_mbc1_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Speaker MBC1 Make-Up Gain Volume\", R_SPKMBCMUG1,\n\t\t\tFB_SPKMBCMUG_MUGAIN, FM_SPKMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Speaker MBC 1 Compressor Threshold Volume\",\n\t\t\tR_SPKMBCTHR1, FB_SPKMBCTHR_THRESH, FM_SPKMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Speaker MBC 1 Compressor Ratio\", spk_mbc1_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 1 Attack\", R_SPKMBCATK1L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 1 Release\", R_SPKMBCREL1L, 2),\n\t \n\tSOC_ENUM(\"Speaker MBC 2 Phase Polarity\", spk_mbc2_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Speaker MBC2 Make-Up Gain Volume\", R_SPKMBCMUG2,\n\t\t\tFB_SPKMBCMUG_MUGAIN, FM_SPKMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Speaker MBC 2 Compressor Threshold Volume\",\n\t\t\tR_SPKMBCTHR2, FB_SPKMBCTHR_THRESH, FM_SPKMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Speaker MBC 2 Compressor Ratio\", spk_mbc2_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 2 Attack\", R_SPKMBCATK2L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 2 Release\", R_SPKMBCREL2L, 2),\n\t \n\tSOC_ENUM(\"Speaker MBC 3 Phase Polarity\", spk_mbc3_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Speaker MBC 3 Make-Up Gain Volume\", R_SPKMBCMUG3,\n\t\t\tFB_SPKMBCMUG_MUGAIN, FM_SPKMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Speaker MBC 3 Threshold Volume\", R_SPKMBCTHR3,\n\t\t\tFB_SPKMBCTHR_THRESH, FM_SPKMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Speaker MBC 3 Compressor Ratio\", spk_mbc3_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 3 Attack\", R_SPKMBCATK3L, 3),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker MBC 3 Release\", R_SPKMBCREL3L, 3),\n\t \n\tSOC_ENUM(\"Speaker CLE Level Mode\", spk_cle_lvl_mode_enum),\n\tSOC_ENUM(\"Speaker CLE Window\", spk_cle_win_sel_enum),\n\tSOC_SINGLE(\"Speaker CLE Expander Switch\",\n\t\t\tR_SPKCLECTL, FB_SPKCLECTL_EXPEN, 1, 0),\n\tSOC_SINGLE(\"Speaker CLE Limiter Switch\",\n\t\t\tR_SPKCLECTL, FB_SPKCLECTL_LIMEN, 1, 0),\n\tSOC_SINGLE(\"Speaker CLE Compressor Switch\",\n\t\t\tR_SPKCLECTL, FB_SPKCLECTL_COMPEN, 1, 0),\n\t \n\tSOC_SINGLE_TLV(\"Speaker CLE Make-Up Gain Volume\", R_SPKCLEMUG,\n\t\t\tFB_SPKCLEMUG_MUGAIN, FM_SPKCLEMUG_MUGAIN,\n\t\t\t0, cle_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Speaker Compressor Threshold Volume\", R_SPKCOMPTHR,\n\t\t\tFB_SPKCOMPTHR_THRESH, FM_SPKCOMPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Speaker Compressor Ratio\", spk_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Compressor Attack\", R_SPKCOMPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Compressor Release\", R_SPKCOMPRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"Speaker Limiter Threshold Volume\", R_SPKLIMTHR,\n\t\t\tFB_SPKLIMTHR_THRESH, FM_SPKLIMTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Speaker Limiter Target Volume\", R_SPKLIMTGT,\n\t\t\tFB_SPKLIMTGT_TARGET, FM_SPKLIMTGT_TARGET,\n\t\t\t0, thr_tlv_arr),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Limiter Attack\", R_SPKLIMATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Limiter Release\", R_SPKLIMRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"Speaker Expander Threshold Volume\", R_SPKEXPTHR,\n\t\t\tFB_SPKEXPTHR_THRESH, FM_SPKEXPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Speaker Expander Ratio\", spk_exp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Expander Attack\", R_SPKEXPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Speaker Expander Release\", R_SPKEXPRELL, 2),\n\t \n\tSOC_SINGLE(\"Speaker 3D Switch\", R_SPKFXCTL, FB_SPKFXCTL_3DEN, 1, 0),\n\tSOC_SINGLE(\"Speaker Treble Enhancement Switch\",\n\t\t\tR_SPKFXCTL, FB_SPKFXCTL_TEEN, 1, 0),\n\tSOC_SINGLE(\"Speaker Treble NLF Switch\",\n\t\t\tR_SPKFXCTL, FB_SPKFXCTL_TNLFBYP, 1, 1),\n\tSOC_SINGLE(\"Speaker Bass Enhancement Switch\",\n\t\t\tR_SPKFXCTL, FB_SPKFXCTL_BEEN, 1, 0),\n\tSOC_SINGLE(\"Speaker Bass NLF Switch\",\n\t\t\tR_SPKFXCTL, FB_SPKFXCTL_BNLFBYP, 1, 1),\n\t \n\tSOC_SINGLE(\"DAC EQ 2 Switch\",\n\t\t\tR_DACEQFILT, FB_DACEQFILT_EQ2EN, 1, 0),\n\tSOC_ENUM(\"DAC EQ 2 Band\", dac_eq_enums[0]),\n\tSOC_SINGLE(\"DAC EQ 1 Switch\", R_DACEQFILT, FB_DACEQFILT_EQ1EN, 1, 0),\n\tSOC_ENUM(\"DAC EQ 1 Band\", dac_eq_enums[1]),\n\t \n\tSOC_SINGLE(\"DAC MBC 3 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN3, 1, 0),\n\tSOC_SINGLE(\"DAC MBC 2 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN2, 1, 0),\n\tSOC_SINGLE(\"DAC MBC 1 Switch\", R_DACMBCEN, FB_DACMBCEN_MBCEN1, 1, 0),\n\t \n\tSOC_ENUM(\"DAC MBC 3 Mode\", dac_mbc3_lvl_det_mode_enum),\n\tSOC_ENUM(\"DAC MBC 3 Window\", dac_mbc3_win_sel_enum),\n\tSOC_ENUM(\"DAC MBC 2 Mode\", dac_mbc2_lvl_det_mode_enum),\n\tSOC_ENUM(\"DAC MBC 2 Window\", dac_mbc2_win_sel_enum),\n\tSOC_ENUM(\"DAC MBC 1 Mode\", dac_mbc1_lvl_det_mode_enum),\n\tSOC_ENUM(\"DAC MBC 1 Window\", dac_mbc1_win_sel_enum),\n\t \n\tSOC_ENUM(\"DAC MBC 1 Phase Polarity\", dac_mbc1_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"DAC MBC 1 Make-Up Gain Volume\", R_DACMBCMUG1,\n\t\t\tFB_DACMBCMUG_MUGAIN, FM_DACMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"DAC MBC 1 Compressor Threshold Volume\", R_DACMBCTHR1,\n\t\t\tFB_DACMBCTHR_THRESH, FM_DACMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"DAC MBC 1 Compressor Ratio\", dac_mbc1_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 1 Attack\", R_DACMBCATK1L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 1 Release\", R_DACMBCREL1L, 2),\n\t \n\tSOC_ENUM(\"DAC MBC 2 Phase Polarity\", dac_mbc2_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"DAC MBC 2 Make-Up Gain Volume\", R_DACMBCMUG2,\n\t\t\tFB_DACMBCMUG_MUGAIN, FM_DACMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"DAC MBC 2 Compressor Threshold Volume\", R_DACMBCTHR2,\n\t\t\tFB_DACMBCTHR_THRESH, FM_DACMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"DAC MBC 2 Compressor Ratio\", dac_mbc2_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 2 Attack\", R_DACMBCATK2L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 2 Release\", R_DACMBCREL2L, 2),\n\t \n\tSOC_ENUM(\"DAC MBC 3 Phase Polarity\", dac_mbc3_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"DAC MBC 3 Make-Up Gain Volume\", R_DACMBCMUG3,\n\t\t\tFB_DACMBCMUG_MUGAIN, FM_DACMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"DAC MBC 3 Threshold Volume\", R_DACMBCTHR3,\n\t\t\tFB_DACMBCTHR_THRESH, FM_DACMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"DAC MBC 3 Compressor Ratio\", dac_mbc3_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 3 Attack\", R_DACMBCATK3L, 3),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC MBC 3 Release\", R_DACMBCREL3L, 3),\n\t \n\tSOC_ENUM(\"DAC CLE Level Mode\", dac_cle_lvl_mode_enum),\n\tSOC_ENUM(\"DAC CLE Window\", dac_cle_win_sel_enum),\n\tSOC_SINGLE(\"DAC CLE Expander Switch\",\n\t\t\tR_DACCLECTL, FB_DACCLECTL_EXPEN, 1, 0),\n\tSOC_SINGLE(\"DAC CLE Limiter Switch\",\n\t\t\tR_DACCLECTL, FB_DACCLECTL_LIMEN, 1, 0),\n\tSOC_SINGLE(\"DAC CLE Compressor Switch\",\n\t\t\tR_DACCLECTL, FB_DACCLECTL_COMPEN, 1, 0),\n\t \n\tSOC_SINGLE_TLV(\"DAC CLE Make-Up Gain Volume\", R_DACCLEMUG,\n\t\t\tFB_DACCLEMUG_MUGAIN, FM_DACCLEMUG_MUGAIN,\n\t\t\t0, cle_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"DAC Compressor Threshold Volume\", R_DACCOMPTHR,\n\t\t\tFB_DACCOMPTHR_THRESH, FM_DACCOMPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"DAC Compressor Ratio\", dac_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Compressor Attack\", R_DACCOMPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Compressor Release\", R_DACCOMPRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"DAC Limiter Threshold Volume\", R_DACLIMTHR,\n\t\t\tFB_DACLIMTHR_THRESH, FM_DACLIMTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"DAC Limiter Target Volume\", R_DACLIMTGT,\n\t\t\tFB_DACLIMTGT_TARGET, FM_DACLIMTGT_TARGET,\n\t\t\t0, thr_tlv_arr),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Limiter Attack\", R_DACLIMATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Limiter Release\", R_DACLIMRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"DAC Expander Threshold Volume\", R_DACEXPTHR,\n\t\t\tFB_DACEXPTHR_THRESH, FM_DACEXPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"DAC Expander Ratio\", dac_exp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Expander Attack\", R_DACEXPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"DAC Expander Release\", R_DACEXPRELL, 2),\n\t \n\tSOC_SINGLE(\"DAC 3D Switch\", R_DACFXCTL, FB_DACFXCTL_3DEN, 1, 0),\n\tSOC_SINGLE(\"DAC Treble Enhancement Switch\",\n\t\t\tR_DACFXCTL, FB_DACFXCTL_TEEN, 1, 0),\n\tSOC_SINGLE(\"DAC Treble NLF Switch\",\n\t\t\tR_DACFXCTL, FB_DACFXCTL_TNLFBYP, 1, 1),\n\tSOC_SINGLE(\"DAC Bass Enhancement Switch\",\n\t\t\tR_DACFXCTL, FB_DACFXCTL_BEEN, 1, 0),\n\tSOC_SINGLE(\"DAC Bass NLF Switch\",\n\t\t\tR_DACFXCTL, FB_DACFXCTL_BNLFBYP, 1, 1),\n\t \n\tSOC_SINGLE(\"Sub EQ 2 Switch\",\n\t\t\tR_SUBEQFILT, FB_SUBEQFILT_EQ2EN, 1, 0),\n\tSOC_ENUM(\"Sub EQ 2 Band\", sub_eq_enums[0]),\n\tSOC_SINGLE(\"Sub EQ 1 Switch\", R_SUBEQFILT, FB_SUBEQFILT_EQ1EN, 1, 0),\n\tSOC_ENUM(\"Sub EQ 1 Band\", sub_eq_enums[1]),\n\t \n\tSOC_SINGLE(\"Sub MBC 3 Switch\", R_SUBMBCEN, FB_SUBMBCEN_MBCEN3, 1, 0),\n\tSOC_SINGLE(\"Sub MBC 2 Switch\", R_SUBMBCEN, FB_SUBMBCEN_MBCEN2, 1, 0),\n\tSOC_SINGLE(\"Sub MBC 1 Switch\", R_SUBMBCEN, FB_SUBMBCEN_MBCEN1, 1, 0),\n\t \n\tSOC_ENUM(\"Sub MBC 3 Mode\", sub_mbc3_lvl_det_mode_enum),\n\tSOC_ENUM(\"Sub MBC 3 Window\", sub_mbc3_win_sel_enum),\n\tSOC_ENUM(\"Sub MBC 2 Mode\", sub_mbc2_lvl_det_mode_enum),\n\tSOC_ENUM(\"Sub MBC 2 Window\", sub_mbc2_win_sel_enum),\n\tSOC_ENUM(\"Sub MBC 1 Mode\", sub_mbc1_lvl_det_mode_enum),\n\tSOC_ENUM(\"Sub MBC 1 Window\", sub_mbc1_win_sel_enum),\n\t \n\tSOC_ENUM(\"Sub MBC 1 Phase Polarity\", sub_mbc1_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Sub MBC 1 Make-Up Gain Volume\", R_SUBMBCMUG1,\n\t\t\tFB_SUBMBCMUG_MUGAIN, FM_SUBMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub MBC 1 Compressor Threshold Volume\", R_SUBMBCTHR1,\n\t\t\tFB_SUBMBCTHR_THRESH, FM_SUBMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Sub MBC 1 Compressor Ratio\", sub_mbc1_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 1 Attack\", R_SUBMBCATK1L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 1 Release\", R_SUBMBCREL1L, 2),\n\t \n\tSOC_ENUM(\"Sub MBC 2 Phase Polarity\", sub_mbc2_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Sub MBC 2 Make-Up Gain Volume\", R_SUBMBCMUG2,\n\t\t\tFB_SUBMBCMUG_MUGAIN, FM_SUBMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub MBC 2 Compressor Threshold Volume\", R_SUBMBCTHR2,\n\t\t\tFB_SUBMBCTHR_THRESH, FM_SUBMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Sub MBC 2 Compressor Ratio\", sub_mbc2_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 2 Attack\", R_SUBMBCATK2L, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 2 Release\", R_SUBMBCREL2L, 2),\n\t \n\tSOC_ENUM(\"Sub MBC 3 Phase Polarity\", sub_mbc3_phase_pol_enum),\n\tSOC_SINGLE_TLV(\"Sub MBC 3 Make-Up Gain Volume\", R_SUBMBCMUG3,\n\t\t\tFB_SUBMBCMUG_MUGAIN, FM_SUBMBCMUG_MUGAIN,\n\t\t\t0, mbc_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub MBC 3 Threshold Volume\", R_SUBMBCTHR3,\n\t\t\tFB_SUBMBCTHR_THRESH, FM_SUBMBCTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Sub MBC 3 Compressor Ratio\", sub_mbc3_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 3 Attack\", R_SUBMBCATK3L, 3),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub MBC 3 Release\", R_SUBMBCREL3L, 3),\n\t \n\tSOC_ENUM(\"Sub CLE Level Mode\", sub_cle_lvl_mode_enum),\n\tSOC_ENUM(\"Sub CLE Window\", sub_cle_win_sel_enum),\n\tSOC_SINGLE(\"Sub CLE Expander Switch\",\n\t\t\tR_SUBCLECTL, FB_SUBCLECTL_EXPEN, 1, 0),\n\tSOC_SINGLE(\"Sub CLE Limiter Switch\",\n\t\t\tR_SUBCLECTL, FB_SUBCLECTL_LIMEN, 1, 0),\n\tSOC_SINGLE(\"Sub CLE Compressor Switch\",\n\t\t\tR_SUBCLECTL, FB_SUBCLECTL_COMPEN, 1, 0),\n\t \n\tSOC_SINGLE_TLV(\"Sub CLE Make-Up Gain Volume\", R_SUBCLEMUG,\n\t\t\tFB_SUBCLEMUG_MUGAIN, FM_SUBCLEMUG_MUGAIN,\n\t\t\t0, cle_mug_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub Compressor Threshold Volume\", R_SUBCOMPTHR,\n\t\t\tFB_SUBCOMPTHR_THRESH, FM_SUBCOMPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Sub Compressor Ratio\", sub_comp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Compressor Attack\", R_SUBCOMPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Compressor Release\", R_SUBCOMPRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"Sub Limiter Threshold Volume\", R_SUBLIMTHR,\n\t\t\tFB_SUBLIMTHR_THRESH, FM_SUBLIMTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_SINGLE_TLV(\"Sub Limiter Target Volume\", R_SUBLIMTGT,\n\t\t\tFB_SUBLIMTGT_TARGET, FM_SUBLIMTGT_TARGET,\n\t\t\t0, thr_tlv_arr),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Limiter Attack\", R_SUBLIMATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Limiter Release\", R_SUBLIMRELL, 2),\n\t \n\tSOC_SINGLE_TLV(\"Sub Expander Threshold Volume\", R_SUBEXPTHR,\n\t\t\tFB_SUBEXPTHR_THRESH, FM_SUBEXPTHR_THRESH,\n\t\t\t0, thr_tlv_arr),\n\t \n\tSOC_ENUM(\"Sub Expander Ratio\", sub_exp_rat_enum),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Expander Attack\", R_SUBEXPATKL, 2),\n\t \n\t \n\tSND_SOC_BYTES(\"Sub Expander Release\", R_SUBEXPRELL, 2),\n\t \n\tSOC_SINGLE(\"Sub Treble Enhancement Switch\",\n\t\t\tR_SUBFXCTL, FB_SUBFXCTL_TEEN, 1, 0),\n\tSOC_SINGLE(\"Sub Treble NLF Switch\",\n\t\t\tR_SUBFXCTL, FB_SUBFXCTL_TNLFBYP, 1, 1),\n\tSOC_SINGLE(\"Sub Bass Enhancement Switch\",\n\t\t\tR_SUBFXCTL, FB_SUBFXCTL_BEEN, 1, 0),\n\tSOC_SINGLE(\"Sub Bass NLF Switch\",\n\t\t\tR_SUBFXCTL, FB_SUBFXCTL_BNLFBYP, 1, 1),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 1\", BIQUAD_SIZE, 0x00),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 2\", BIQUAD_SIZE, 0x05),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 3\", BIQUAD_SIZE, 0x0a),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 4\", BIQUAD_SIZE, 0x0f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 5\", BIQUAD_SIZE, 0x14),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left BiQuad 6\", BIQUAD_SIZE, 0x19),\n\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 1\", BIQUAD_SIZE, 0x20),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 2\", BIQUAD_SIZE, 0x25),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 3\", BIQUAD_SIZE, 0x2a),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 4\", BIQUAD_SIZE, 0x2f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 5\", BIQUAD_SIZE, 0x34),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right BiQuad 6\", BIQUAD_SIZE, 0x39),\n\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Left Prescale\", COEFF_SIZE, 0x1f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 1 Right Prescale\", COEFF_SIZE, 0x3f),\n\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 1\", BIQUAD_SIZE, 0x40),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 2\", BIQUAD_SIZE, 0x45),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 3\", BIQUAD_SIZE, 0x4a),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 4\", BIQUAD_SIZE, 0x4f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 5\", BIQUAD_SIZE, 0x54),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left BiQuad 6\", BIQUAD_SIZE, 0x59),\n\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 1\", BIQUAD_SIZE, 0x60),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 2\", BIQUAD_SIZE, 0x65),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 3\", BIQUAD_SIZE, 0x6a),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 4\", BIQUAD_SIZE, 0x6f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 5\", BIQUAD_SIZE, 0x74),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right BiQuad 6\", BIQUAD_SIZE, 0x79),\n\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Left Prescale\", COEFF_SIZE, 0x5f),\n\tCOEFF_RAM_CTL(\"DAC Cascade 2 Right Prescale\", COEFF_SIZE, 0x7f),\n\n\tCOEFF_RAM_CTL(\"DAC Bass Extraction BiQuad 1\", BIQUAD_SIZE, 0x80),\n\tCOEFF_RAM_CTL(\"DAC Bass Extraction BiQuad 2\", BIQUAD_SIZE, 0x85),\n\n\tCOEFF_RAM_CTL(\"DAC Bass Non Linear Function 1\", COEFF_SIZE, 0x8a),\n\tCOEFF_RAM_CTL(\"DAC Bass Non Linear Function 2\", COEFF_SIZE, 0x8b),\n\n\tCOEFF_RAM_CTL(\"DAC Bass Limiter BiQuad\", BIQUAD_SIZE, 0x8c),\n\n\tCOEFF_RAM_CTL(\"DAC Bass Cut Off BiQuad\", BIQUAD_SIZE, 0x91),\n\n\tCOEFF_RAM_CTL(\"DAC Bass Mix\", COEFF_SIZE, 0x96),\n\n\tCOEFF_RAM_CTL(\"DAC Treb Extraction BiQuad 1\", BIQUAD_SIZE, 0x97),\n\tCOEFF_RAM_CTL(\"DAC Treb Extraction BiQuad 2\", BIQUAD_SIZE, 0x9c),\n\n\tCOEFF_RAM_CTL(\"DAC Treb Non Linear Function 1\", COEFF_SIZE, 0xa1),\n\tCOEFF_RAM_CTL(\"DAC Treb Non Linear Function 2\", COEFF_SIZE, 0xa2),\n\n\tCOEFF_RAM_CTL(\"DAC Treb Limiter BiQuad\", BIQUAD_SIZE, 0xa3),\n\n\tCOEFF_RAM_CTL(\"DAC Treb Cut Off BiQuad\", BIQUAD_SIZE, 0xa8),\n\n\tCOEFF_RAM_CTL(\"DAC Treb Mix\", COEFF_SIZE, 0xad),\n\n\tCOEFF_RAM_CTL(\"DAC 3D\", COEFF_SIZE, 0xae),\n\n\tCOEFF_RAM_CTL(\"DAC 3D Mix\", COEFF_SIZE, 0xaf),\n\n\tCOEFF_RAM_CTL(\"DAC MBC 1 BiQuad 1\", BIQUAD_SIZE, 0xb0),\n\tCOEFF_RAM_CTL(\"DAC MBC 1 BiQuad 2\", BIQUAD_SIZE, 0xb5),\n\n\tCOEFF_RAM_CTL(\"DAC MBC 2 BiQuad 1\", BIQUAD_SIZE, 0xba),\n\tCOEFF_RAM_CTL(\"DAC MBC 2 BiQuad 2\", BIQUAD_SIZE, 0xbf),\n\n\tCOEFF_RAM_CTL(\"DAC MBC 3 BiQuad 1\", BIQUAD_SIZE, 0xc4),\n\tCOEFF_RAM_CTL(\"DAC MBC 3 BiQuad 2\", BIQUAD_SIZE, 0xc9),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 1\", BIQUAD_SIZE, 0x00),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 2\", BIQUAD_SIZE, 0x05),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 3\", BIQUAD_SIZE, 0x0a),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 4\", BIQUAD_SIZE, 0x0f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 5\", BIQUAD_SIZE, 0x14),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left BiQuad 6\", BIQUAD_SIZE, 0x19),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 1\", BIQUAD_SIZE, 0x20),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 2\", BIQUAD_SIZE, 0x25),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 3\", BIQUAD_SIZE, 0x2a),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 4\", BIQUAD_SIZE, 0x2f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 5\", BIQUAD_SIZE, 0x34),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right BiQuad 6\", BIQUAD_SIZE, 0x39),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Left Prescale\", COEFF_SIZE, 0x1f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 1 Right Prescale\", COEFF_SIZE, 0x3f),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 1\", BIQUAD_SIZE, 0x40),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 2\", BIQUAD_SIZE, 0x45),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 3\", BIQUAD_SIZE, 0x4a),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 4\", BIQUAD_SIZE, 0x4f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 5\", BIQUAD_SIZE, 0x54),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left BiQuad 6\", BIQUAD_SIZE, 0x59),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 1\", BIQUAD_SIZE, 0x60),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 2\", BIQUAD_SIZE, 0x65),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 3\", BIQUAD_SIZE, 0x6a),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 4\", BIQUAD_SIZE, 0x6f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 5\", BIQUAD_SIZE, 0x74),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right BiQuad 6\", BIQUAD_SIZE, 0x79),\n\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Left Prescale\", COEFF_SIZE, 0x5f),\n\tCOEFF_RAM_CTL(\"Speaker Cascade 2 Right Prescale\", COEFF_SIZE, 0x7f),\n\n\tCOEFF_RAM_CTL(\"Speaker Bass Extraction BiQuad 1\", BIQUAD_SIZE, 0x80),\n\tCOEFF_RAM_CTL(\"Speaker Bass Extraction BiQuad 2\", BIQUAD_SIZE, 0x85),\n\n\tCOEFF_RAM_CTL(\"Speaker Bass Non Linear Function 1\", COEFF_SIZE, 0x8a),\n\tCOEFF_RAM_CTL(\"Speaker Bass Non Linear Function 2\", COEFF_SIZE, 0x8b),\n\n\tCOEFF_RAM_CTL(\"Speaker Bass Limiter BiQuad\", BIQUAD_SIZE, 0x8c),\n\n\tCOEFF_RAM_CTL(\"Speaker Bass Cut Off BiQuad\", BIQUAD_SIZE, 0x91),\n\n\tCOEFF_RAM_CTL(\"Speaker Bass Mix\", COEFF_SIZE, 0x96),\n\n\tCOEFF_RAM_CTL(\"Speaker Treb Extraction BiQuad 1\", BIQUAD_SIZE, 0x97),\n\tCOEFF_RAM_CTL(\"Speaker Treb Extraction BiQuad 2\", BIQUAD_SIZE, 0x9c),\n\n\tCOEFF_RAM_CTL(\"Speaker Treb Non Linear Function 1\", COEFF_SIZE, 0xa1),\n\tCOEFF_RAM_CTL(\"Speaker Treb Non Linear Function 2\", COEFF_SIZE, 0xa2),\n\n\tCOEFF_RAM_CTL(\"Speaker Treb Limiter BiQuad\", BIQUAD_SIZE, 0xa3),\n\n\tCOEFF_RAM_CTL(\"Speaker Treb Cut Off BiQuad\", BIQUAD_SIZE, 0xa8),\n\n\tCOEFF_RAM_CTL(\"Speaker Treb Mix\", COEFF_SIZE, 0xad),\n\n\tCOEFF_RAM_CTL(\"Speaker 3D\", COEFF_SIZE, 0xae),\n\n\tCOEFF_RAM_CTL(\"Speaker 3D Mix\", COEFF_SIZE, 0xaf),\n\n\tCOEFF_RAM_CTL(\"Speaker MBC 1 BiQuad 1\", BIQUAD_SIZE, 0xb0),\n\tCOEFF_RAM_CTL(\"Speaker MBC 1 BiQuad 2\", BIQUAD_SIZE, 0xb5),\n\n\tCOEFF_RAM_CTL(\"Speaker MBC 2 BiQuad 1\", BIQUAD_SIZE, 0xba),\n\tCOEFF_RAM_CTL(\"Speaker MBC 2 BiQuad 2\", BIQUAD_SIZE, 0xbf),\n\n\tCOEFF_RAM_CTL(\"Speaker MBC 3 BiQuad 1\", BIQUAD_SIZE, 0xc4),\n\tCOEFF_RAM_CTL(\"Speaker MBC 3 BiQuad 2\", BIQUAD_SIZE, 0xc9),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 1\", BIQUAD_SIZE, 0x00),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 2\", BIQUAD_SIZE, 0x05),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 3\", BIQUAD_SIZE, 0x0a),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 4\", BIQUAD_SIZE, 0x0f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 5\", BIQUAD_SIZE, 0x14),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left BiQuad 6\", BIQUAD_SIZE, 0x19),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 1\", BIQUAD_SIZE, 0x20),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 2\", BIQUAD_SIZE, 0x25),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 3\", BIQUAD_SIZE, 0x2a),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 4\", BIQUAD_SIZE, 0x2f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 5\", BIQUAD_SIZE, 0x34),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right BiQuad 6\", BIQUAD_SIZE, 0x39),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Left Prescale\", COEFF_SIZE, 0x1f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 1 Right Prescale\", COEFF_SIZE, 0x3f),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 1\", BIQUAD_SIZE, 0x40),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 2\", BIQUAD_SIZE, 0x45),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 3\", BIQUAD_SIZE, 0x4a),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 4\", BIQUAD_SIZE, 0x4f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 5\", BIQUAD_SIZE, 0x54),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left BiQuad 6\", BIQUAD_SIZE, 0x59),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 1\", BIQUAD_SIZE, 0x60),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 2\", BIQUAD_SIZE, 0x65),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 3\", BIQUAD_SIZE, 0x6a),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 4\", BIQUAD_SIZE, 0x6f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 5\", BIQUAD_SIZE, 0x74),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right BiQuad 6\", BIQUAD_SIZE, 0x79),\n\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Left Prescale\", COEFF_SIZE, 0x5f),\n\tCOEFF_RAM_CTL(\"Sub Cascade 2 Right Prescale\", COEFF_SIZE, 0x7f),\n\n\tCOEFF_RAM_CTL(\"Sub Bass Extraction BiQuad 1\", BIQUAD_SIZE, 0x80),\n\tCOEFF_RAM_CTL(\"Sub Bass Extraction BiQuad 2\", BIQUAD_SIZE, 0x85),\n\n\tCOEFF_RAM_CTL(\"Sub Bass Non Linear Function 1\", COEFF_SIZE, 0x8a),\n\tCOEFF_RAM_CTL(\"Sub Bass Non Linear Function 2\", COEFF_SIZE, 0x8b),\n\n\tCOEFF_RAM_CTL(\"Sub Bass Limiter BiQuad\", BIQUAD_SIZE, 0x8c),\n\n\tCOEFF_RAM_CTL(\"Sub Bass Cut Off BiQuad\", BIQUAD_SIZE, 0x91),\n\n\tCOEFF_RAM_CTL(\"Sub Bass Mix\", COEFF_SIZE, 0x96),\n\n\tCOEFF_RAM_CTL(\"Sub Treb Extraction BiQuad 1\", BIQUAD_SIZE, 0x97),\n\tCOEFF_RAM_CTL(\"Sub Treb Extraction BiQuad 2\", BIQUAD_SIZE, 0x9c),\n\n\tCOEFF_RAM_CTL(\"Sub Treb Non Linear Function 1\", COEFF_SIZE, 0xa1),\n\tCOEFF_RAM_CTL(\"Sub Treb Non Linear Function 2\", COEFF_SIZE, 0xa2),\n\n\tCOEFF_RAM_CTL(\"Sub Treb Limiter BiQuad\", BIQUAD_SIZE, 0xa3),\n\n\tCOEFF_RAM_CTL(\"Sub Treb Cut Off BiQuad\", BIQUAD_SIZE, 0xa8),\n\n\tCOEFF_RAM_CTL(\"Sub Treb Mix\", COEFF_SIZE, 0xad),\n\n\tCOEFF_RAM_CTL(\"Sub 3D\", COEFF_SIZE, 0xae),\n\n\tCOEFF_RAM_CTL(\"Sub 3D Mix\", COEFF_SIZE, 0xaf),\n\n\tCOEFF_RAM_CTL(\"Sub MBC 1 BiQuad 1\", BIQUAD_SIZE, 0xb0),\n\tCOEFF_RAM_CTL(\"Sub MBC 1 BiQuad 2\", BIQUAD_SIZE, 0xb5),\n\n\tCOEFF_RAM_CTL(\"Sub MBC 2 BiQuad 1\", BIQUAD_SIZE, 0xba),\n\tCOEFF_RAM_CTL(\"Sub MBC 2 BiQuad 2\", BIQUAD_SIZE, 0xbf),\n\n\tCOEFF_RAM_CTL(\"Sub MBC 3 BiQuad 1\", BIQUAD_SIZE, 0xc4),\n\tCOEFF_RAM_CTL(\"Sub MBC 3 BiQuad 2\", BIQUAD_SIZE, 0xc9),\n};\n\nstatic struct snd_soc_dapm_widget const tscs454_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_SUPPLY(\"PLL 1 Power\", R_PLLCTL, FB_PLLCTL_PU_PLL1, 0,\n\t\t\tpll_power_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"PLL 2 Power\", R_PLLCTL, FB_PLLCTL_PU_PLL2, 0,\n\t\t\tpll_power_event,\n\t\t\tSND_SOC_DAPM_POST_PMU|SND_SOC_DAPM_PRE_PMD),\n\t \n\tSND_SOC_DAPM_AIF_OUT(\"DAI 3 Out\", \"DAI 3 Capture\", 0,\n\t\t\tR_I2SPINC0, FB_I2SPINC0_SDO3TRI, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"DAI 2 Out\", \"DAI 2 Capture\", 0,\n\t\t\tR_I2SPINC0, FB_I2SPINC0_SDO2TRI, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"DAI 1 Out\", \"DAI 1 Capture\", 0,\n\t\t\tR_I2SPINC0, FB_I2SPINC0_SDO1TRI, 1),\n\t \n\tSND_SOC_DAPM_ADC(\"Input Processor Channel 3\", NULL,\n\t\t\tR_PWRM0, FB_PWRM0_INPROC3PU, 0),\n\tSND_SOC_DAPM_ADC(\"Input Processor Channel 2\", NULL,\n\t\t\tR_PWRM0, FB_PWRM0_INPROC2PU, 0),\n\tSND_SOC_DAPM_ADC(\"Input Processor Channel 1\", NULL,\n\t\t\tR_PWRM0, FB_PWRM0_INPROC1PU, 0),\n\tSND_SOC_DAPM_ADC(\"Input Processor Channel 0\", NULL,\n\t\t\tR_PWRM0, FB_PWRM0_INPROC0PU, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 2\",\n\t\t\tR_PWRM0, FB_PWRM0_MICB2PU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias 1\", R_PWRM0,\n\t\t\tFB_PWRM0_MICB1PU, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Sub Power\", R_PWRM1, FB_PWRM1_SUBPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Left Power\",\n\t\t\tR_PWRM1, FB_PWRM1_HPLPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Headphone Right Power\",\n\t\t\tR_PWRM1, FB_PWRM1_HPRPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Speaker Left Power\",\n\t\t\tR_PWRM1, FB_PWRM1_SPKLPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Speaker Right Power\",\n\t\t\tR_PWRM1, FB_PWRM1_SPKRPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Differential Input 2 Power\",\n\t\t\tR_PWRM1, FB_PWRM1_D2S2PU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Differential Input 1 Power\",\n\t\t\tR_PWRM1, FB_PWRM1_D2S1PU, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_SUPPLY(\"DAI 3 Out Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S3OPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAI 2 Out Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S2OPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAI 1 Out Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S1OPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAI 3 In Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S3IPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAI 2 In Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S2IPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DAI 1 In Power\",\n\t\t\tR_PWRM2, FB_PWRM2_I2S1IPU, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Line Out Left Power\",\n\t\t\tR_PWRM3, FB_PWRM3_LLINEPU, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Line Out Right Power\",\n\t\t\tR_PWRM3, FB_PWRM3_RLINEPU, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_DAC(\"Sub\", NULL, R_PWRM4, FB_PWRM4_OPSUBPU, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Left\", NULL, R_PWRM4, FB_PWRM4_OPDACLPU, 0),\n\tSND_SOC_DAPM_DAC(\"DAC Right\", NULL, R_PWRM4, FB_PWRM4_OPDACRPU, 0),\n\tSND_SOC_DAPM_DAC(\"ClassD Left\", NULL, R_PWRM4, FB_PWRM4_OPSPKLPU, 0),\n\tSND_SOC_DAPM_DAC(\"ClassD Right\", NULL, R_PWRM4, FB_PWRM4_OPSPKRPU, 0),\n\t \n\tSND_SOC_DAPM_MUX(\"DAI 2 Out Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&dai2_mux_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"DAI 1 Out Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&dai1_mux_dapm_enum),\n\t \n\tSND_SOC_DAPM_MUX(\"DAC Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&dac_mux_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"DAI 3 Out Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&dai3_mux_dapm_enum),\n\t \n\tSND_SOC_DAPM_MUX(\"Sub Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&sub_mux_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"Speaker Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&classd_mux_dapm_enum),\n\t \n\tSND_SOC_DAPM_SUPPLY(\"GHS Detect Power\", R_HSDCTL1,\n\t\t\tFB_HSDCTL1_CON_DET_PWD, 1, NULL, 0),\n\t \n\tSND_SOC_DAPM_MUX(\"Input Boost Channel 0 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&in_bst_mux_ch0_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"ADC Channel 0 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&adc_mux_ch0_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"Input Processor Channel 0 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&in_proc_mux_ch0_dapm_enum),\n\t \n\tSND_SOC_DAPM_MUX(\"Input Boost Channel 1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&in_bst_mux_ch1_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"ADC Channel 1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&adc_mux_ch1_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"Input Processor Channel 1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&in_proc_mux_ch1_dapm_enum),\n\t \n\tSND_SOC_DAPM_AIF_IN(\"DAI 3 In\", \"DAI 3 Playback\", 0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DAI 2 In\", \"DAI 2 Playback\", 0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DAI 1 In\", \"DAI 1 Playback\", 0,\n\t\t\tSND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLLs\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"Sub Out\"),\n\tSND_SOC_DAPM_OUTPUT(\"Headphone Left\"),\n\tSND_SOC_DAPM_OUTPUT(\"Headphone Right\"),\n\tSND_SOC_DAPM_OUTPUT(\"Speaker Left\"),\n\tSND_SOC_DAPM_OUTPUT(\"Speaker Right\"),\n\tSND_SOC_DAPM_OUTPUT(\"Line Out Left\"),\n\tSND_SOC_DAPM_OUTPUT(\"Line Out Right\"),\n\tSND_SOC_DAPM_INPUT(\"D2S 2\"),\n\tSND_SOC_DAPM_INPUT(\"D2S 1\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 1 Left\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 1 Right\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 2 Left\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 2 Right\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 3 Left\"),\n\tSND_SOC_DAPM_INPUT(\"Line In 3 Right\"),\n\tSND_SOC_DAPM_INPUT(\"DMic 1\"),\n\tSND_SOC_DAPM_INPUT(\"DMic 2\"),\n\n\tSND_SOC_DAPM_MUX(\"CH 0_1 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&ch_0_1_mux_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"CH 2_3 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&ch_2_3_mux_dapm_enum),\n\tSND_SOC_DAPM_MUX(\"CH 4_5 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t&ch_4_5_mux_dapm_enum),\n};\n\nstatic struct snd_soc_dapm_route const tscs454_intercon[] = {\n\t \n\t{\"PLLs\", NULL, \"PLL 1 Power\", pll_connected},\n\t{\"PLLs\", NULL, \"PLL 2 Power\", pll_connected},\n\t \n\t{\"DAI 3 In\", NULL, \"DAI 3 In Power\"},\n\t{\"DAI 2 In\", NULL, \"DAI 2 In Power\"},\n\t{\"DAI 1 In\", NULL, \"DAI 1 In Power\"},\n\t \n\t{\"DAI 3 Out\", NULL, \"DAI 3 Out Power\"},\n\t{\"DAI 2 Out\", NULL, \"DAI 2 Out Power\"},\n\t{\"DAI 1 Out\", NULL, \"DAI 1 Out Power\"},\n\t \n\t{\"CH 0_1 Mux\", \"DAI 1\", \"DAI 1 In\"},\n\t{\"CH 0_1 Mux\", \"TDM 0_1\", \"DAI 1 In\"},\n\t{\"CH 2_3 Mux\", \"DAI 2\", \"DAI 2 In\"},\n\t{\"CH 2_3 Mux\", \"TDM 2_3\", \"DAI 1 In\"},\n\t{\"CH 4_5 Mux\", \"DAI 3\", \"DAI 2 In\"},\n\t{\"CH 4_5 Mux\", \"TDM 4_5\", \"DAI 1 In\"},\n\t \n\t{\"DAI 1 Out Mux\", \"CH 0_1\", \"CH 0_1 Mux\"},\n\t{\"DAI 1 Out Mux\", \"CH 2_3\", \"CH 2_3 Mux\"},\n\t{\"DAI 1 Out Mux\", \"CH 4_5\", \"CH 4_5 Mux\"},\n\t{\"DAI 2 Out Mux\", \"CH 0_1\", \"CH 0_1 Mux\"},\n\t{\"DAI 2 Out Mux\", \"CH 2_3\", \"CH 2_3 Mux\"},\n\t{\"DAI 2 Out Mux\", \"CH 4_5\", \"CH 4_5 Mux\"},\n\t{\"DAI 3 Out Mux\", \"CH 0_1\", \"CH 0_1 Mux\"},\n\t{\"DAI 3 Out Mux\", \"CH 2_3\", \"CH 2_3 Mux\"},\n\t{\"DAI 3 Out Mux\", \"CH 4_5\", \"CH 4_5 Mux\"},\n\t \n\t \n\t{\"DAC Mux\", \"CH 4_5\", \"CH 4_5 Mux\"},\n\t{\"DAC Mux\", \"CH 2_3\", \"CH 2_3 Mux\"},\n\t{\"DAC Mux\", \"CH 0_1\", \"CH 0_1 Mux\"},\n\t{\"DAC Left\", NULL, \"DAC Mux\"},\n\t{\"DAC Right\", NULL, \"DAC Mux\"},\n\t{\"DAC Left\", NULL, \"PLLs\"},\n\t{\"DAC Right\", NULL, \"PLLs\"},\n\t{\"Headphone Left\", NULL, \"Headphone Left Power\"},\n\t{\"Headphone Right\", NULL, \"Headphone Right Power\"},\n\t{\"Headphone Left\", NULL, \"DAC Left\"},\n\t{\"Headphone Right\", NULL, \"DAC Right\"},\n\t \n\t{\"Line Out Left\", NULL, \"Line Out Left Power\"},\n\t{\"Line Out Right\", NULL, \"Line Out Right Power\"},\n\t{\"Line Out Left\", NULL, \"DAC Left\"},\n\t{\"Line Out Right\", NULL, \"DAC Right\"},\n\t \n\t{\"Speaker Mux\", \"CH 4_5\", \"CH 4_5 Mux\"},\n\t{\"Speaker Mux\", \"CH 2_3\", \"CH 2_3 Mux\"},\n\t{\"Speaker Mux\", \"CH 0_1\", \"CH 0_1 Mux\"},\n\t{\"ClassD Left\", NULL, \"Speaker Mux\"},\n\t{\"ClassD Right\", NULL, \"Speaker Mux\"},\n\t{\"ClassD Left\", NULL, \"PLLs\"},\n\t{\"ClassD Right\", NULL, \"PLLs\"},\n\t{\"Speaker Left\", NULL, \"Speaker Left Power\"},\n\t{\"Speaker Right\", NULL, \"Speaker Right Power\"},\n\t{\"Speaker Left\", NULL, \"ClassD Left\"},\n\t{\"Speaker Right\", NULL, \"ClassD Right\"},\n\t \n\t{\"Sub Mux\", \"CH 4\", \"CH 4_5 Mux\"},\n\t{\"Sub Mux\", \"CH 5\", \"CH 4_5 Mux\"},\n\t{\"Sub Mux\", \"CH 4 + 5\", \"CH 4_5 Mux\"},\n\t{\"Sub Mux\", \"CH 2\", \"CH 2_3 Mux\"},\n\t{\"Sub Mux\", \"CH 3\", \"CH 2_3 Mux\"},\n\t{\"Sub Mux\", \"CH 2 + 3\", \"CH 2_3 Mux\"},\n\t{\"Sub Mux\", \"CH 0\", \"CH 0_1 Mux\"},\n\t{\"Sub Mux\", \"CH 1\", \"CH 0_1 Mux\"},\n\t{\"Sub Mux\", \"CH 0 + 1\", \"CH 0_1 Mux\"},\n\t{\"Sub Mux\", \"ADC/DMic 1 Left\", \"Input Processor Channel 0\"},\n\t{\"Sub Mux\", \"ADC/DMic 1 Right\", \"Input Processor Channel 1\"},\n\t{\"Sub Mux\", \"ADC/DMic 1 Left Plus Right\", \"Input Processor Channel 0\"},\n\t{\"Sub Mux\", \"ADC/DMic 1 Left Plus Right\", \"Input Processor Channel 1\"},\n\t{\"Sub Mux\", \"DMic 2 Left\", \"DMic 2\"},\n\t{\"Sub Mux\", \"DMic 2 Right\", \"DMic 2\"},\n\t{\"Sub Mux\", \"DMic 2 Left Plus Right\", \"DMic 2\"},\n\t{\"Sub Mux\", \"ClassD Left\", \"ClassD Left\"},\n\t{\"Sub Mux\", \"ClassD Right\", \"ClassD Right\"},\n\t{\"Sub Mux\", \"ClassD Left Plus Right\", \"ClassD Left\"},\n\t{\"Sub Mux\", \"ClassD Left Plus Right\", \"ClassD Right\"},\n\t{\"Sub\", NULL, \"Sub Mux\"},\n\t{\"Sub\", NULL, \"PLLs\"},\n\t{\"Sub Out\", NULL, \"Sub Power\"},\n\t{\"Sub Out\", NULL, \"Sub\"},\n\t \n\t{\"Input Boost Channel 0 Mux\", \"Input 3\", \"Line In 3 Left\"},\n\t{\"Input Boost Channel 0 Mux\", \"Input 2\", \"Line In 2 Left\"},\n\t{\"Input Boost Channel 0 Mux\", \"Input 1\", \"Line In 1 Left\"},\n\t{\"Input Boost Channel 0 Mux\", \"D2S\", \"D2S 1\"},\n\n\t{\"Input Boost Channel 1 Mux\", \"Input 3\", \"Line In 3 Right\"},\n\t{\"Input Boost Channel 1 Mux\", \"Input 2\", \"Line In 2 Right\"},\n\t{\"Input Boost Channel 1 Mux\", \"Input 1\", \"Line In 1 Right\"},\n\t{\"Input Boost Channel 1 Mux\", \"D2S\", \"D2S 2\"},\n\n\t{\"ADC Channel 0 Mux\", \"Input 3 Boost Bypass\", \"Line In 3 Left\"},\n\t{\"ADC Channel 0 Mux\", \"Input 2 Boost Bypass\", \"Line In 2 Left\"},\n\t{\"ADC Channel 0 Mux\", \"Input 1 Boost Bypass\", \"Line In 1 Left\"},\n\t{\"ADC Channel 0 Mux\", \"Input Boost\", \"Input Boost Channel 0 Mux\"},\n\n\t{\"ADC Channel 1 Mux\", \"Input 3 Boost Bypass\", \"Line In 3 Right\"},\n\t{\"ADC Channel 1 Mux\", \"Input 2 Boost Bypass\", \"Line In 2 Right\"},\n\t{\"ADC Channel 1 Mux\", \"Input 1 Boost Bypass\", \"Line In 1 Right\"},\n\t{\"ADC Channel 1 Mux\", \"Input Boost\", \"Input Boost Channel 1 Mux\"},\n\n\t{\"Input Processor Channel 0 Mux\", \"ADC\", \"ADC Channel 0 Mux\"},\n\t{\"Input Processor Channel 0 Mux\", \"DMic\", \"DMic 1\"},\n\n\t{\"Input Processor Channel 0\", NULL, \"PLLs\"},\n\t{\"Input Processor Channel 0\", NULL, \"Input Processor Channel 0 Mux\"},\n\n\t{\"Input Processor Channel 1 Mux\", \"ADC\", \"ADC Channel 1 Mux\"},\n\t{\"Input Processor Channel 1 Mux\", \"DMic\", \"DMic 1\"},\n\n\t{\"Input Processor Channel 1\", NULL, \"PLLs\"},\n\t{\"Input Processor Channel 1\", NULL, \"Input Processor Channel 1 Mux\"},\n\n\t{\"Input Processor Channel 2\", NULL, \"PLLs\"},\n\t{\"Input Processor Channel 2\", NULL, \"DMic 2\"},\n\n\t{\"Input Processor Channel 3\", NULL, \"PLLs\"},\n\t{\"Input Processor Channel 3\", NULL, \"DMic 2\"},\n\n\t{\"DAI 1 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 0\"},\n\t{\"DAI 1 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 1\"},\n\t{\"DAI 1 Out Mux\", \"DMic 2\", \"Input Processor Channel 2\"},\n\t{\"DAI 1 Out Mux\", \"DMic 2\", \"Input Processor Channel 3\"},\n\n\t{\"DAI 2 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 0\"},\n\t{\"DAI 2 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 1\"},\n\t{\"DAI 2 Out Mux\", \"DMic 2\", \"Input Processor Channel 2\"},\n\t{\"DAI 2 Out Mux\", \"DMic 2\", \"Input Processor Channel 3\"},\n\n\t{\"DAI 3 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 0\"},\n\t{\"DAI 3 Out Mux\", \"ADC/DMic 1\", \"Input Processor Channel 1\"},\n\t{\"DAI 3 Out Mux\", \"DMic 2\", \"Input Processor Channel 2\"},\n\t{\"DAI 3 Out Mux\", \"DMic 2\", \"Input Processor Channel 3\"},\n\n\t{\"DAI 1 Out\", NULL, \"DAI 1 Out Mux\"},\n\t{\"DAI 2 Out\", NULL, \"DAI 2 Out Mux\"},\n\t{\"DAI 3 Out\", NULL, \"DAI 3 Out Mux\"},\n};\n\n \nstatic int tscs454_set_sysclk(struct snd_soc_dai *dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint bclk_dai;\n\n\tdev_dbg(component->dev, \"%s(): freq = %u\\n\", __func__, freq);\n\n\tval = snd_soc_component_read(component, R_PLLCTL);\n\n\tbclk_dai = (val & FM_PLLCTL_BCLKSEL) >> FB_PLLCTL_BCLKSEL;\n\tif (bclk_dai != dai->id)\n\t\treturn 0;\n\n\ttscs454->bclk_freq = freq;\n\treturn set_sysclk(component);\n}\n\nstatic int tscs454_set_bclk_ratio(struct snd_soc_dai *dai,\n\t\tunsigned int ratio)\n{\n\tunsigned int mask;\n\tint ret;\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val;\n\tint shift;\n\n\tdev_dbg(component->dev, \"set_bclk_ratio() id = %d ratio = %u\\n\",\n\t\t\tdai->id, ratio);\n\n\tswitch (dai->id) {\n\tcase TSCS454_DAI1_ID:\n\t\tmask = FM_I2SCMC_BCMP1;\n\t\tshift = FB_I2SCMC_BCMP1;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\tmask = FM_I2SCMC_BCMP2;\n\t\tshift = FB_I2SCMC_BCMP2;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\tmask = FM_I2SCMC_BCMP3;\n\t\tshift = FB_I2SCMC_BCMP3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unknown audio interface (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (ratio) {\n\tcase 32:\n\t\tval = I2SCMC_BCMP_32X;\n\t\tbreak;\n\tcase 40:\n\t\tval = I2SCMC_BCMP_40X;\n\t\tbreak;\n\tcase 64:\n\t\tval = I2SCMC_BCMP_64X;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported bclk ratio (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\tR_I2SCMC, mask, val << shift);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set DAI BCLK ratio (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int set_aif_provider_from_fmt(struct snd_soc_component *component,\n\t\tstruct aif *aif, unsigned int fmt)\n{\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\taif->provider = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\taif->provider = false;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported format (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int set_aif_tdm_delay(struct snd_soc_component *component,\n\t\tunsigned int dai_id, bool delay)\n{\n\tunsigned int reg;\n\tint ret;\n\n\tswitch (dai_id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_TDMCTL0;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_PCMP2CTL0;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_PCMP3CTL0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev,\n\t\t\t\t\"DAI %d unknown (%d)\\n\", dai_id + 1, ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_update_bits(component,\n\t\t\treg, FM_TDMCTL0_BDELAY, delay);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to setup tdm format (%d)\\n\",\n\t\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int set_aif_format_from_fmt(struct snd_soc_component *component,\n\t\tunsigned int dai_id, unsigned int fmt)\n{\n\tunsigned int reg;\n\tunsigned int val;\n\tint ret;\n\n\tswitch (dai_id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_I2SP1CTL;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_I2SP2CTL;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_I2SP3CTL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev,\n\t\t\t\t\"DAI %d unknown (%d)\\n\", dai_id + 1, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tval = FV_FORMAT_RIGHT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval = FV_FORMAT_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = FV_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tret = set_aif_tdm_delay(component, dai_id, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval = FV_FORMAT_TDM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tret = set_aif_tdm_delay(component, dai_id, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tval = FV_FORMAT_TDM;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Format unsupported (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\treg, FM_I2SPCTL_FORMAT, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set DAI %d format (%d)\\n\",\n\t\t\t\tdai_id + 1, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int\nset_aif_clock_format_from_fmt(struct snd_soc_component *component,\n\t\tunsigned int dai_id, unsigned int fmt)\n{\n\tunsigned int reg;\n\tunsigned int val;\n\tint ret;\n\n\tswitch (dai_id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_I2SP1CTL;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_I2SP2CTL;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_I2SP3CTL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev,\n\t\t\t\t\"DAI %d unknown (%d)\\n\", dai_id + 1, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval = FV_BCLKP_NOT_INVERTED | FV_LRCLKP_NOT_INVERTED;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval = FV_BCLKP_NOT_INVERTED | FV_LRCLKP_INVERTED;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval = FV_BCLKP_INVERTED | FV_LRCLKP_NOT_INVERTED;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval = FV_BCLKP_INVERTED | FV_LRCLKP_INVERTED;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Format unknown (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component, reg,\n\t\t\tFM_I2SPCTL_BCLKP | FM_I2SPCTL_LRCLKP, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set clock polarity for DAI%d (%d)\\n\",\n\t\t\t\tdai_id + 1, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs454_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct aif *aif = &tscs454->aifs[dai->id];\n\tint ret;\n\n\tret = set_aif_provider_from_fmt(component, aif, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = set_aif_format_from_fmt(component, dai->id, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = set_aif_clock_format_from_fmt(component, dai->id, fmt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tscs454_dai1_set_tdm_slot(struct snd_soc_dai *dai,\n\t\tunsigned int tx_mask, unsigned int rx_mask, int slots,\n\t\tint slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val;\n\tint ret;\n\n\tif (!slots)\n\t\treturn 0;\n\n\tif (tx_mask >= (1 << slots) || rx_mask >= (1 << slots)) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid TDM slot mask (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (slots) {\n\tcase 2:\n\t\tval = FV_TDMSO_2 | FV_TDMSI_2;\n\t\tbreak;\n\tcase 4:\n\t\tval = FV_TDMSO_4 | FV_TDMSI_4;\n\t\tbreak;\n\tcase 6:\n\t\tval = FV_TDMSO_6 | FV_TDMSI_6;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid number of slots (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tval = val | FV_TDMDSS_16;\n\t\tbreak;\n\tcase 24:\n\t\tval = val | FV_TDMDSS_24;\n\t\tbreak;\n\tcase 32:\n\t\tval = val | FV_TDMDSS_32;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid TDM slot width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_write(component, R_TDMCTL1, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set slots (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs454_dai23_set_tdm_slot(struct snd_soc_dai *dai,\n\t\tunsigned int tx_mask, unsigned int rx_mask, int slots,\n\t\tint slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int reg;\n\tunsigned int val;\n\tint ret;\n\n\tif (!slots)\n\t\treturn 0;\n\n\tif (tx_mask >= (1 << slots) || rx_mask >= (1 << slots)) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid TDM slot mask (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (dai->id) {\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_PCMP2CTL1;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_PCMP3CTL1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unrecognized interface %d (%d)\\n\",\n\t\t\t\tdai->id, ret);\n\t\treturn ret;\n\t}\n\n\tswitch (slots) {\n\tcase 1:\n\t\tval = FV_PCMSOP_1 | FV_PCMSIP_1;\n\t\tbreak;\n\tcase 2:\n\t\tval = FV_PCMSOP_2 | FV_PCMSIP_2;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid number of slots (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tval = val | FV_PCMDSSP_16;\n\t\tbreak;\n\tcase 24:\n\t\tval = val | FV_PCMDSSP_24;\n\t\tbreak;\n\tcase 32:\n\t\tval = val | FV_PCMDSSP_32;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid TDM slot width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = snd_soc_component_write(component, reg, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set slots (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_aif_fs(struct snd_soc_component *component,\n\t\tunsigned int id,\n\t\tunsigned int rate)\n{\n\tunsigned int reg;\n\tunsigned int br;\n\tunsigned int bm;\n\tint ret;\n\n\tswitch (rate) {\n\tcase 8000:\n\t\tbr = FV_I2SMBR_32;\n\t\tbm = FV_I2SMBM_0PT25;\n\t\tbreak;\n\tcase 16000:\n\t\tbr = FV_I2SMBR_32;\n\t\tbm = FV_I2SMBM_0PT5;\n\t\tbreak;\n\tcase 24000:\n\t\tbr = FV_I2SMBR_48;\n\t\tbm = FV_I2SMBM_0PT5;\n\t\tbreak;\n\tcase 32000:\n\t\tbr = FV_I2SMBR_32;\n\t\tbm = FV_I2SMBM_1;\n\t\tbreak;\n\tcase 48000:\n\t\tbr = FV_I2SMBR_48;\n\t\tbm = FV_I2SMBM_1;\n\t\tbreak;\n\tcase 96000:\n\t\tbr = FV_I2SMBR_48;\n\t\tbm = FV_I2SMBM_2;\n\t\tbreak;\n\tcase 11025:\n\t\tbr = FV_I2SMBR_44PT1;\n\t\tbm = FV_I2SMBM_0PT25;\n\t\tbreak;\n\tcase 22050:\n\t\tbr = FV_I2SMBR_44PT1;\n\t\tbm = FV_I2SMBM_0PT5;\n\t\tbreak;\n\tcase 44100:\n\t\tbr = FV_I2SMBR_44PT1;\n\t\tbm = FV_I2SMBM_1;\n\t\tbreak;\n\tcase 88200:\n\t\tbr = FV_I2SMBR_44PT1;\n\t\tbm = FV_I2SMBM_2;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported sample rate (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_I2S1MRATE;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_I2S2MRATE;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_I2S3MRATE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"DAI ID not recognized (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component, reg,\n\t\t\tFM_I2SMRATE_I2SMBR | FM_I2SMRATE_I2SMBM, br|bm);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to update register (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_aif_sample_format(struct snd_soc_component *component,\n\t\tsnd_pcm_format_t format,\n\t\tint aif_id)\n{\n\tunsigned int reg;\n\tunsigned int width;\n\tint ret;\n\n\tswitch (snd_pcm_format_width(format)) {\n\tcase 16:\n\t\twidth = FV_WL_16;\n\t\tbreak;\n\tcase 20:\n\t\twidth = FV_WL_20;\n\t\tbreak;\n\tcase 24:\n\t\twidth = FV_WL_24;\n\t\tbreak;\n\tcase 32:\n\t\twidth = FV_WL_32;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Unsupported format width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (aif_id) {\n\tcase TSCS454_DAI1_ID:\n\t\treg = R_I2SP1CTL;\n\t\tbreak;\n\tcase TSCS454_DAI2_ID:\n\t\treg = R_I2SP2CTL;\n\t\tbreak;\n\tcase TSCS454_DAI3_ID:\n\t\treg = R_I2SP3CTL;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"AIF ID not recognized (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component,\n\t\t\treg, FM_I2SPCTL_WL, width);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set sample width (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tscs454_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tunsigned int fs = params_rate(params);\n\tstruct aif *aif = &tscs454->aifs[dai->id];\n\tunsigned int val;\n\tint ret;\n\n\tmutex_lock(&tscs454->aifs_status_lock);\n\n\tdev_dbg(component->dev, \"%s(): aif %d fs = %u\\n\", __func__,\n\t\t\taif->id, fs);\n\n\tif (!aif_active(&tscs454->aifs_status, aif->id)) {\n\t\tif (PLL_44_1K_RATE % fs)\n\t\t\taif->pll = &tscs454->pll1;\n\t\telse\n\t\t\taif->pll = &tscs454->pll2;\n\n\t\tdev_dbg(component->dev, \"Reserving pll %d for aif %d\\n\",\n\t\t\t\taif->pll->id, aif->id);\n\n\t\treserve_pll(aif->pll);\n\t}\n\n\tif (!aifs_active(&tscs454->aifs_status)) {  \n\t\tval = snd_soc_component_read(component, R_ISRC);\n\t\tif ((val & FM_ISRC_IBR) == FV_IBR_48)\n\t\t\ttscs454->internal_rate.pll = &tscs454->pll1;\n\t\telse\n\t\t\ttscs454->internal_rate.pll = &tscs454->pll2;\n\n\t\tdev_dbg(component->dev, \"Reserving pll %d for ir\\n\",\n\t\t\t\ttscs454->internal_rate.pll->id);\n\n\t\treserve_pll(tscs454->internal_rate.pll);\n\t}\n\n\tret = set_aif_fs(component, aif->id, fs);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set aif fs (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = set_aif_sample_format(component, params_format(params), aif->id);\n\tif (ret < 0) {\n\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to set aif sample format (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tset_aif_status_active(&tscs454->aifs_status, aif->id,\n\t\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n\n\tdev_dbg(component->dev, \"Set aif %d active. Streams status is 0x%x\\n\",\n\t\taif->id, tscs454->aifs_status.streams);\n\n\tret = 0;\nexit:\n\tmutex_unlock(&tscs454->aifs_status_lock);\n\n\treturn ret;\n}\n\nstatic int tscs454_hw_free(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct aif *aif = &tscs454->aifs[dai->id];\n\n\treturn aif_free(component, aif,\n\t\t\tsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK);\n}\n\nstatic int tscs454_prepare(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tint ret;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tstruct aif *aif = &tscs454->aifs[dai->id];\n\n\tret = aif_prepare(component, aif);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct snd_soc_dai_ops const tscs454_dai1_ops = {\n\t.set_sysclk\t= tscs454_set_sysclk,\n\t.set_bclk_ratio = tscs454_set_bclk_ratio,\n\t.set_fmt\t= tscs454_set_dai_fmt,\n\t.set_tdm_slot\t= tscs454_dai1_set_tdm_slot,\n\t.hw_params\t= tscs454_hw_params,\n\t.hw_free\t= tscs454_hw_free,\n\t.prepare\t= tscs454_prepare,\n};\n\nstatic struct snd_soc_dai_ops const tscs454_dai23_ops = {\n\t.set_sysclk\t= tscs454_set_sysclk,\n\t.set_bclk_ratio = tscs454_set_bclk_ratio,\n\t.set_fmt\t= tscs454_set_dai_fmt,\n\t.set_tdm_slot\t= tscs454_dai23_set_tdm_slot,\n\t.hw_params\t= tscs454_hw_params,\n\t.hw_free\t= tscs454_hw_free,\n\t.prepare\t= tscs454_prepare,\n};\n\nstatic int tscs454_probe(struct snd_soc_component *component)\n{\n\tstruct tscs454 *tscs454 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint ret = 0;\n\n\tswitch (tscs454->sysclk_src_id) {\n\tcase PLL_INPUT_XTAL:\n\t\tval = FV_PLLISEL_XTAL;\n\t\tbreak;\n\tcase PLL_INPUT_MCLK1:\n\t\tval = FV_PLLISEL_MCLK1;\n\t\tbreak;\n\tcase PLL_INPUT_MCLK2:\n\t\tval = FV_PLLISEL_MCLK2;\n\t\tbreak;\n\tcase PLL_INPUT_BCLK:\n\t\tval = FV_PLLISEL_BCLK;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"Invalid sysclk src id (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = snd_soc_component_update_bits(component, R_PLLCTL,\n\t\t\tFM_PLLCTL_PLLISEL, val);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to set PLL input (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (tscs454->sysclk_src_id < PLL_INPUT_BCLK)\n\t\tret = set_sysclk(component);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_tscs454 = {\n\t.probe =\ttscs454_probe,\n\t.dapm_widgets = tscs454_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(tscs454_dapm_widgets),\n\t.dapm_routes = tscs454_intercon,\n\t.num_dapm_routes = ARRAY_SIZE(tscs454_intercon),\n\t.controls =\ttscs454_snd_controls,\n\t.num_controls = ARRAY_SIZE(tscs454_snd_controls),\n\t.endianness = 1,\n};\n\n#define TSCS454_RATES SNDRV_PCM_RATE_8000_96000\n\n#define TSCS454_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t| SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S24_LE \\\n\t| SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver tscs454_dais[] = {\n\t{\n\t\t.name = \"tscs454-dai1\",\n\t\t.id = TSCS454_DAI1_ID,\n\t\t.playback = {\n\t\t\t.stream_name = \"DAI 1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 6,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAI 1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 6,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.ops = &tscs454_dai1_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_channels = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n\t{\n\t\t.name = \"tscs454-dai2\",\n\t\t.id = TSCS454_DAI2_ID,\n\t\t.playback = {\n\t\t\t.stream_name = \"DAI 2 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAI 2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.ops = &tscs454_dai23_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_channels = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n\t{\n\t\t.name = \"tscs454-dai3\",\n\t\t.id = TSCS454_DAI3_ID,\n\t\t.playback = {\n\t\t\t.stream_name = \"DAI 3 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.capture = {\n\t\t\t.stream_name = \"DAI 3 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = TSCS454_RATES,\n\t\t\t.formats = TSCS454_FORMATS,},\n\t\t.ops = &tscs454_dai23_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_channels = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n};\n\nstatic char const * const src_names[] = {\n\t\"xtal\", \"mclk1\", \"mclk2\", \"bclk\"};\n\nstatic int tscs454_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct tscs454 *tscs454;\n\tint src;\n\tint ret;\n\n\ttscs454 = devm_kzalloc(&i2c->dev, sizeof(*tscs454), GFP_KERNEL);\n\tif (!tscs454)\n\t\treturn -ENOMEM;\n\n\tret = tscs454_data_init(tscs454, i2c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti2c_set_clientdata(i2c, tscs454);\n\n\tfor (src = PLL_INPUT_XTAL; src < PLL_INPUT_BCLK; src++) {\n\t\ttscs454->sysclk = devm_clk_get(&i2c->dev, src_names[src]);\n\t\tif (!IS_ERR(tscs454->sysclk)) {\n\t\t\tbreak;\n\t\t} else if (PTR_ERR(tscs454->sysclk) != -ENOENT) {\n\t\t\tret = PTR_ERR(tscs454->sysclk);\n\t\t\tdev_err(&i2c->dev, \"Failed to get sysclk (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tdev_dbg(&i2c->dev, \"PLL input is %s\\n\", src_names[src]);\n\ttscs454->sysclk_src_id = src;\n\n\tret = regmap_write(tscs454->regmap,\n\t\t\tR_RESET, FV_RESET_PWR_ON_DEFAULTS);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to reset the component (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tregcache_mark_dirty(tscs454->regmap);\n\n\tret = regmap_register_patch(tscs454->regmap, tscs454_patch,\n\t\t\tARRAY_SIZE(tscs454_patch));\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to apply patch (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tregmap_write(tscs454->regmap, R_PAGESEL, 0x00);\n\n\tret = devm_snd_soc_register_component(&i2c->dev, &soc_component_dev_tscs454,\n\t\t\ttscs454_dais, ARRAY_SIZE(tscs454_dais));\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to register component (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct i2c_device_id tscs454_i2c_id[] = {\n\t{ \"tscs454\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tscs454_i2c_id);\n\nstatic const struct of_device_id tscs454_of_match[] = {\n\t{ .compatible = \"tempo,tscs454\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tscs454_of_match);\n\nstatic struct i2c_driver tscs454_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tscs454\",\n\t\t.of_match_table = tscs454_of_match,\n\t},\n\t.probe = tscs454_i2c_probe,\n\t.id_table = tscs454_i2c_id,\n};\n\nmodule_i2c_driver(tscs454_i2c_driver);\n\nMODULE_AUTHOR(\"Tempo Semiconductor <steven.eckhoff.opensource@gmail.com\");\nMODULE_DESCRIPTION(\"ASoC TSCS454 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}