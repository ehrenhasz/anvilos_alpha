{
  "module_name": "ak4535.c",
  "hash_id": "fe7f548c0afa9fc9ff085993321ef03262da783704963e6e87bdabb8759c1d80",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4535.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include \"ak4535.h\"\n\n \nstruct ak4535_priv {\n\tstruct regmap *regmap;\n\tunsigned int sysclk;\n};\n\n \nstatic const struct reg_default ak4535_reg_defaults[] = {\n\t{ 0, 0x00 },\n\t{ 1, 0x80 },\n\t{ 2, 0x00 },\n\t{ 3, 0x03 },\n\t{ 4, 0x02 },\n\t{ 5, 0x00 },\n\t{ 6, 0x11 },\n\t{ 7, 0x01 },\n\t{ 8, 0x00 },\n\t{ 9, 0x40 },\n\t{ 10, 0x36 },\n\t{ 11, 0x10 },\n\t{ 12, 0x00 },\n\t{ 13, 0x00 },\n\t{ 14, 0x57 },\n};\n\nstatic bool ak4535_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase AK4535_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char *ak4535_mono_gain[] = {\"+6dB\", \"-17dB\"};\nstatic const char *ak4535_mono_out[] = {\"(L + R)/2\", \"Hi-Z\"};\nstatic const char *ak4535_hp_out[] = {\"Stereo\", \"Mono\"};\nstatic const char *ak4535_deemp[] = {\"44.1kHz\", \"Off\", \"48kHz\", \"32kHz\"};\nstatic const char *ak4535_mic_select[] = {\"Internal\", \"External\"};\n\nstatic const struct soc_enum ak4535_enum[] = {\n\tSOC_ENUM_SINGLE(AK4535_SIG1, 7, 2, ak4535_mono_gain),\n\tSOC_ENUM_SINGLE(AK4535_SIG1, 6, 2, ak4535_mono_out),\n\tSOC_ENUM_SINGLE(AK4535_MODE2, 2, 2, ak4535_hp_out),\n\tSOC_ENUM_SINGLE(AK4535_DAC, 0, 4, ak4535_deemp),\n\tSOC_ENUM_SINGLE(AK4535_MIC, 1, 2, ak4535_mic_select),\n};\n\nstatic const struct snd_kcontrol_new ak4535_snd_controls[] = {\n\tSOC_SINGLE(\"ALC2 Switch\", AK4535_SIG1, 1, 1, 0),\n\tSOC_ENUM(\"Mono 1 Output\", ak4535_enum[1]),\n\tSOC_ENUM(\"Mono 1 Gain\", ak4535_enum[0]),\n\tSOC_ENUM(\"Headphone Output\", ak4535_enum[2]),\n\tSOC_ENUM(\"Playback Deemphasis\", ak4535_enum[3]),\n\tSOC_SINGLE(\"Bass Volume\", AK4535_DAC, 2, 3, 0),\n\tSOC_SINGLE(\"Mic Boost (+20dB) Switch\", AK4535_MIC, 0, 1, 0),\n\tSOC_ENUM(\"Mic Select\", ak4535_enum[4]),\n\tSOC_SINGLE(\"ALC Operation Time\", AK4535_TIMER, 0, 3, 0),\n\tSOC_SINGLE(\"ALC Recovery Time\", AK4535_TIMER, 2, 3, 0),\n\tSOC_SINGLE(\"ALC ZC Time\", AK4535_TIMER, 4, 3, 0),\n\tSOC_SINGLE(\"ALC 1 Switch\", AK4535_ALC1, 5, 1, 0),\n\tSOC_SINGLE(\"ALC 2 Switch\", AK4535_ALC1, 6, 1, 0),\n\tSOC_SINGLE(\"ALC Volume\", AK4535_ALC2, 0, 127, 0),\n\tSOC_SINGLE(\"Capture Volume\", AK4535_PGA, 0, 127, 0),\n\tSOC_SINGLE(\"Left Playback Volume\", AK4535_LATT, 0, 127, 1),\n\tSOC_SINGLE(\"Right Playback Volume\", AK4535_RATT, 0, 127, 1),\n\tSOC_SINGLE(\"AUX Bypass Volume\", AK4535_VOL, 0, 15, 0),\n\tSOC_SINGLE(\"Mic Sidetone Volume\", AK4535_VOL, 4, 7, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4535_mono1_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", AK4535_SIG1, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"Mono Playback Switch\", AK4535_SIG1, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4535_stereo_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic Sidetone Switch\", AK4535_SIG2, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"Playback Switch\", AK4535_SIG2, 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Bypass Switch\", AK4535_SIG2, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4535_input_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Mic Capture Switch\", AK4535_MIC, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Capture Switch\", AK4535_MIC, 5, 1, 0),\n};\n\n \nstatic const struct snd_kcontrol_new ak4535_input_mux_control =\n\tSOC_DAPM_ENUM(\"Input Select\", ak4535_enum[4]);\n\n \nstatic const struct snd_kcontrol_new ak4535_hpl_control =\n\tSOC_DAPM_SINGLE(\"Switch\", AK4535_SIG2, 1, 1, 1);\n\n \nstatic const struct snd_kcontrol_new ak4535_hpr_control =\n\tSOC_DAPM_SINGLE(\"Switch\", AK4535_SIG2, 0, 1, 1);\n\n \nstatic const struct snd_kcontrol_new ak4535_mono2_control =\n\tSOC_DAPM_SINGLE(\"Switch\", AK4535_SIG1, 0, 1, 0);\n\n \nstatic const struct snd_kcontrol_new ak4535_line_control =\n\tSOC_DAPM_SINGLE(\"Switch\", AK4535_SIG2, 6, 1, 0);\n\n \nstatic const struct snd_soc_dapm_widget ak4535_dapm_widgets[] = {\n\tSND_SOC_DAPM_MIXER(\"Stereo Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_stereo_mixer_controls[0],\n\t\tARRAY_SIZE(ak4535_stereo_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Mono1 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_mono1_mixer_controls[0],\n\t\tARRAY_SIZE(ak4535_mono1_mixer_controls)),\n\tSND_SOC_DAPM_MIXER(\"Input Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_input_mixer_controls[0],\n\t\tARRAY_SIZE(ak4535_input_mixer_controls)),\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_input_mux_control),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", AK4535_PM2, 0, 0),\n\tSND_SOC_DAPM_SWITCH(\"Mono 2 Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_mono2_control),\n\t \n\tSND_SOC_DAPM_PGA(\"Speaker Enable\", AK4535_MODE2, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SWITCH(\"Line Out Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_line_control),\n\tSND_SOC_DAPM_SWITCH(\"Left HP Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_hpl_control),\n\tSND_SOC_DAPM_SWITCH(\"Right HP Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&ak4535_hpr_control),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPN\"),\n\tSND_SOC_DAPM_OUTPUT(\"MOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"MOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"MICOUT\"),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", AK4535_PM1, 0, 0),\n\tSND_SOC_DAPM_PGA(\"Spk Amp\", AK4535_PM2, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP R Amp\", AK4535_PM2, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP L Amp\", AK4535_PM2, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mic\", AK4535_PM1, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Line Out\", AK4535_PM1, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Mono Out\", AK4535_PM1, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"AUX In\", AK4535_PM1, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MICBIAS(\"Mic Int Bias\", AK4535_MIC, 3, 0),\n\tSND_SOC_DAPM_MICBIAS(\"Mic Ext Bias\", AK4535_MIC, 4, 0),\n\tSND_SOC_DAPM_INPUT(\"MICIN\"),\n\tSND_SOC_DAPM_INPUT(\"MICEXT\"),\n\tSND_SOC_DAPM_INPUT(\"AUX\"),\n\tSND_SOC_DAPM_INPUT(\"MIN\"),\n\tSND_SOC_DAPM_INPUT(\"AIN\"),\n};\n\nstatic const struct snd_soc_dapm_route ak4535_audio_map[] = {\n\t \n\t{\"Stereo Mixer\", \"Playback Switch\", \"DAC\"},\n\t{\"Stereo Mixer\", \"Mic Sidetone Switch\", \"Mic\"},\n\t{\"Stereo Mixer\", \"Aux Bypass Switch\", \"AUX In\"},\n\n\t \n\t{\"Mono1 Mixer\", \"Mic Sidetone Switch\", \"Mic\"},\n\t{\"Mono1 Mixer\", \"Mono Playback Switch\", \"DAC\"},\n\n\t \n\t{\"Mic\", NULL, \"AIN\"},\n\t{\"Input Mux\", \"Internal\", \"Mic Int Bias\"},\n\t{\"Input Mux\", \"External\", \"Mic Ext Bias\"},\n\t{\"Mic Int Bias\", NULL, \"MICIN\"},\n\t{\"Mic Ext Bias\", NULL, \"MICEXT\"},\n\t{\"MICOUT\", NULL, \"Input Mux\"},\n\n\t \n\t{\"LOUT\", NULL, \"Line Out Enable\"},\n\t{\"ROUT\", NULL, \"Line Out Enable\"},\n\t{\"Line Out Enable\", \"Switch\", \"Line Out\"},\n\t{\"Line Out\", NULL, \"Stereo Mixer\"},\n\n\t \n\t{\"MOUT1\", NULL, \"Mono Out\"},\n\t{\"Mono Out\", NULL, \"Mono1 Mixer\"},\n\n\t \n\t{\"HPL\", NULL, \"Left HP Enable\"},\n\t{\"Left HP Enable\", \"Switch\", \"HP L Amp\"},\n\t{\"HP L Amp\", NULL, \"Stereo Mixer\"},\n\n\t \n\t{\"HPR\", NULL, \"Right HP Enable\"},\n\t{\"Right HP Enable\", \"Switch\", \"HP R Amp\"},\n\t{\"HP R Amp\", NULL, \"Stereo Mixer\"},\n\n\t \n\t{\"SPP\", NULL, \"Speaker Enable\"},\n\t{\"SPN\", NULL, \"Speaker Enable\"},\n\t{\"Speaker Enable\", \"Switch\", \"Spk Amp\"},\n\t{\"Spk Amp\", NULL, \"MIN\"},\n\n\t \n\t{\"MOUT2\", NULL, \"Mono 2 Enable\"},\n\t{\"Mono 2 Enable\", \"Switch\", \"Stereo Mixer\"},\n\n\t \n\t{\"Aux In\", NULL, \"AUX\"},\n\n\t \n\t{\"ADC\", NULL, \"Input Mixer\"},\n\t{\"Input Mixer\", \"Mic Capture Switch\", \"Mic\"},\n\t{\"Input Mixer\", \"Aux Capture Switch\", \"Aux In\"},\n};\n\nstatic int ak4535_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ak4535_priv *ak4535 = snd_soc_component_get_drvdata(component);\n\n\tak4535->sysclk = freq;\n\treturn 0;\n}\n\nstatic int ak4535_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4535_priv *ak4535 = snd_soc_component_get_drvdata(component);\n\tu8 mode2 = snd_soc_component_read(component, AK4535_MODE2) & ~(0x3 << 5);\n\tint rate = params_rate(params), fs = 256;\n\n\tif (rate)\n\t\tfs = ak4535->sysclk / rate;\n\n\t \n\tswitch (fs) {\n\tcase 1024:\n\t\tmode2 |= (0x2 << 5);\n\t\tbreak;\n\tcase 512:\n\t\tmode2 |= (0x1 << 5);\n\t\tbreak;\n\tcase 256:\n\t\tbreak;\n\t}\n\n\t \n\tsnd_soc_component_write(component, AK4535_MODE2, mode2);\n\treturn 0;\n}\n\nstatic int ak4535_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu8 mode1 = 0;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tmode1 = 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tmode1 = 0x0001;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmode1 |= 0x4;\n\n\tsnd_soc_component_write(component, AK4535_MODE1, mode1);\n\treturn 0;\n}\n\nstatic int ak4535_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 mute_reg = snd_soc_component_read(component, AK4535_DAC);\n\n\tif (!mute)\n\t\tsnd_soc_component_write(component, AK4535_DAC, mute_reg & ~0x20);\n\telse\n\t\tsnd_soc_component_write(component, AK4535_DAC, mute_reg | 0x20);\n\treturn 0;\n}\n\nstatic int ak4535_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tsnd_soc_component_update_bits(component, AK4535_DAC, 0x20, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tsnd_soc_component_update_bits(component, AK4535_DAC, 0x20, 0x20);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tsnd_soc_component_update_bits(component, AK4535_PM1, 0x80, 0x80);\n\t\tsnd_soc_component_update_bits(component, AK4535_PM2, 0x80, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, AK4535_PM1, 0x80, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define AK4535_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\\\n\t\tSNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\tSNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n\nstatic const struct snd_soc_dai_ops ak4535_dai_ops = {\n\t.hw_params\t= ak4535_hw_params,\n\t.set_fmt\t= ak4535_set_dai_fmt,\n\t.mute_stream\t= ak4535_mute,\n\t.set_sysclk\t= ak4535_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ak4535_dai = {\n\t.name = \"ak4535-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = AK4535_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = AK4535_RATES,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,},\n\t.ops = &ak4535_dai_ops,\n};\n\nstatic int ak4535_resume(struct snd_soc_component *component)\n{\n\tsnd_soc_component_cache_sync(component);\n\treturn 0;\n}\n\nstatic const struct regmap_config ak4535_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = AK4535_STATUS,\n\t.volatile_reg = ak4535_volatile,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = ak4535_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ak4535_reg_defaults),\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_ak4535 = {\n\t.resume\t\t\t= ak4535_resume,\n\t.set_bias_level\t\t= ak4535_set_bias_level,\n\t.controls\t\t= ak4535_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4535_snd_controls),\n\t.dapm_widgets\t\t= ak4535_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4535_dapm_widgets),\n\t.dapm_routes\t\t= ak4535_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4535_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int ak4535_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak4535_priv *ak4535;\n\tint ret;\n\n\tak4535 = devm_kzalloc(&i2c->dev, sizeof(struct ak4535_priv),\n\t\t\t      GFP_KERNEL);\n\tif (ak4535 == NULL)\n\t\treturn -ENOMEM;\n\n\tak4535->regmap = devm_regmap_init_i2c(i2c, &ak4535_regmap);\n\tif (IS_ERR(ak4535->regmap)) {\n\t\tret = PTR_ERR(ak4535->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, ak4535);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_ak4535, &ak4535_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id ak4535_i2c_id[] = {\n\t{ \"ak4535\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ak4535_i2c_id);\n\nstatic struct i2c_driver ak4535_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4535\",\n\t},\n\t.probe = ak4535_i2c_probe,\n\t.id_table = ak4535_i2c_id,\n};\n\nmodule_i2c_driver(ak4535_i2c_driver);\n\nMODULE_DESCRIPTION(\"Soc AK4535 driver\");\nMODULE_AUTHOR(\"Richard Purdie\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}