{
  "module_name": "wm8983.c",
  "hash_id": "06d2c5b2adb2c95292faa7734e1d4db4c77c44b57cfdb02f586365595cad6483",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8983.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8983.h\"\n\nstatic const struct reg_default wm8983_defaults[] = {\n\t{ 0x01, 0x0000 },      \n\t{ 0x02, 0x0000 },      \n\t{ 0x03, 0x0000 },      \n\t{ 0x04, 0x0050 },      \n\t{ 0x05, 0x0000 },      \n\t{ 0x06, 0x0140 },      \n\t{ 0x07, 0x0000 },      \n\t{ 0x08, 0x0000 },      \n\t{ 0x09, 0x0000 },      \n\t{ 0x0A, 0x0000 },      \n\t{ 0x0B, 0x00FF },      \n\t{ 0x0C, 0x00FF },      \n\t{ 0x0D, 0x0000 },      \n\t{ 0x0E, 0x0100 },      \n\t{ 0x0F, 0x00FF },      \n\t{ 0x10, 0x00FF },      \n\t{ 0x12, 0x012C },      \n\t{ 0x13, 0x002C },      \n\t{ 0x14, 0x002C },      \n\t{ 0x15, 0x002C },      \n\t{ 0x16, 0x002C },      \n\t{ 0x18, 0x0032 },      \n\t{ 0x19, 0x0000 },      \n\t{ 0x1B, 0x0000 },      \n\t{ 0x1C, 0x0000 },      \n\t{ 0x1D, 0x0000 },      \n\t{ 0x1E, 0x0000 },      \n\t{ 0x20, 0x0038 },      \n\t{ 0x21, 0x000B },      \n\t{ 0x22, 0x0032 },      \n\t{ 0x23, 0x0000 },      \n\t{ 0x24, 0x0008 },      \n\t{ 0x25, 0x000C },      \n\t{ 0x26, 0x0093 },      \n\t{ 0x27, 0x00E9 },      \n\t{ 0x29, 0x0000 },      \n\t{ 0x2A, 0x0000 },      \n\t{ 0x2B, 0x0000 },      \n\t{ 0x2C, 0x0033 },      \n\t{ 0x2D, 0x0010 },      \n\t{ 0x2E, 0x0010 },      \n\t{ 0x2F, 0x0100 },      \n\t{ 0x30, 0x0100 },      \n\t{ 0x31, 0x0002 },      \n\t{ 0x32, 0x0001 },      \n\t{ 0x33, 0x0001 },      \n\t{ 0x34, 0x0039 },      \n\t{ 0x35, 0x0039 },      \n\t{ 0x36, 0x0039 },      \n\t{ 0x37, 0x0039 },      \n\t{ 0x38, 0x0001 },      \n\t{ 0x39, 0x0001 },      \n\t{ 0x3D, 0x0000 },       \n};\n\n \nstatic const int vol_update_regs[] = {\n\tWM8983_LEFT_DAC_DIGITAL_VOL,\n\tWM8983_RIGHT_DAC_DIGITAL_VOL,\n\tWM8983_LEFT_ADC_DIGITAL_VOL,\n\tWM8983_RIGHT_ADC_DIGITAL_VOL,\n\tWM8983_LOUT1_HP_VOLUME_CTRL,\n\tWM8983_ROUT1_HP_VOLUME_CTRL,\n\tWM8983_LOUT2_SPK_VOLUME_CTRL,\n\tWM8983_ROUT2_SPK_VOLUME_CTRL,\n\tWM8983_LEFT_INP_PGA_GAIN_CTRL,\n\tWM8983_RIGHT_INP_PGA_GAIN_CTRL\n};\n\nstruct wm8983_priv {\n\tstruct regmap *regmap;\n\tu32 sysclk;\n\tu32 bclk;\n};\n\nstatic const struct {\n\tint div;\n\tint ratio;\n} fs_ratios[] = {\n\t{ 10, 128 },\n\t{ 15, 192 },\n\t{ 20, 256 },\n\t{ 30, 384 },\n\t{ 40, 512 },\n\t{ 60, 768 },\n\t{ 80, 1024 },\n\t{ 120, 1536 }\n};\n\nstatic const int srates[] = { 48000, 32000, 24000, 16000, 12000, 8000 };\n\nstatic const int bclk_divs[] = {\n\t1, 2, 4, 8, 16, 32\n};\n\nstatic int eqmode_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol);\n\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -12700, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(lim_thresh_tlv, -600, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(lim_boost_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_min_tlv, -1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_max_tlv, -675, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_tar_tlv, -2250, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_vol_tlv, -1200, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_tlv, -1200, 300, 1);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(aux_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(pga_boost_tlv, 0, 2000, 0);\n\nstatic const char *alc_sel_text[] = { \"Off\", \"Right\", \"Left\", \"Stereo\" };\nstatic SOC_ENUM_SINGLE_DECL(alc_sel, WM8983_ALC_CONTROL_1, 7, alc_sel_text);\n\nstatic const char *alc_mode_text[] = { \"ALC\", \"Limiter\" };\nstatic SOC_ENUM_SINGLE_DECL(alc_mode, WM8983_ALC_CONTROL_3, 8, alc_mode_text);\n\nstatic const char *filter_mode_text[] = { \"Audio\", \"Application\" };\nstatic SOC_ENUM_SINGLE_DECL(filter_mode, WM8983_ADC_CONTROL, 7,\n\t\t\t    filter_mode_text);\n\nstatic const char *eq_bw_text[] = { \"Narrow\", \"Wide\" };\nstatic const char *eqmode_text[] = { \"Capture\", \"Playback\" };\nstatic SOC_ENUM_SINGLE_EXT_DECL(eqmode, eqmode_text);\n\nstatic const char *eq1_cutoff_text[] = {\n\t\"80Hz\", \"105Hz\", \"135Hz\", \"175Hz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq1_cutoff, WM8983_EQ1_LOW_SHELF, 5,\n\t\t\t    eq1_cutoff_text);\nstatic const char *eq2_cutoff_text[] = {\n\t\"230Hz\", \"300Hz\", \"385Hz\", \"500Hz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq2_bw, WM8983_EQ2_PEAK_1, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq2_cutoff, WM8983_EQ2_PEAK_1, 5, eq2_cutoff_text);\nstatic const char *eq3_cutoff_text[] = {\n\t\"650Hz\", \"850Hz\", \"1.1kHz\", \"1.4kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq3_bw, WM8983_EQ3_PEAK_2, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq3_cutoff, WM8983_EQ3_PEAK_2, 5, eq3_cutoff_text);\nstatic const char *eq4_cutoff_text[] = {\n\t\"1.8kHz\", \"2.4kHz\", \"3.2kHz\", \"4.1kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq4_bw, WM8983_EQ4_PEAK_3, 8, eq_bw_text);\nstatic SOC_ENUM_SINGLE_DECL(eq4_cutoff, WM8983_EQ4_PEAK_3, 5, eq4_cutoff_text);\nstatic const char *eq5_cutoff_text[] = {\n\t\"5.3kHz\", \"6.9kHz\", \"9kHz\", \"11.7kHz\"\n};\nstatic SOC_ENUM_SINGLE_DECL(eq5_cutoff, WM8983_EQ5_HIGH_SHELF, 5,\n\t\t\t    eq5_cutoff_text);\n\nstatic const char *depth_3d_text[] = {\n\t\"Off\",\n\t\"6.67%\",\n\t\"13.3%\",\n\t\"20%\",\n\t\"26.7%\",\n\t\"33.3%\",\n\t\"40%\",\n\t\"46.6%\",\n\t\"53.3%\",\n\t\"60%\",\n\t\"66.7%\",\n\t\"73.3%\",\n\t\"80%\",\n\t\"86.7%\",\n\t\"93.3%\",\n\t\"100%\"\n};\nstatic SOC_ENUM_SINGLE_DECL(depth_3d, WM8983_3D_CONTROL, 0,\n\t\t\t    depth_3d_text);\n\nstatic const struct snd_kcontrol_new wm8983_snd_controls[] = {\n\tSOC_SINGLE(\"Digital Loopback Switch\", WM8983_COMPANDING_CONTROL,\n\t\t   0, 1, 0),\n\n\tSOC_ENUM(\"ALC Capture Function\", alc_sel),\n\tSOC_SINGLE_TLV(\"ALC Capture Max Volume\", WM8983_ALC_CONTROL_1,\n\t\t       3, 7, 0, alc_max_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Min Volume\", WM8983_ALC_CONTROL_1,\n\t\t       0, 7, 0, alc_min_tlv),\n\tSOC_SINGLE_TLV(\"ALC Capture Target Volume\", WM8983_ALC_CONTROL_2,\n\t\t       0, 15, 0, alc_tar_tlv),\n\tSOC_SINGLE(\"ALC Capture Attack\", WM8983_ALC_CONTROL_3, 0, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Hold\", WM8983_ALC_CONTROL_2, 4, 10, 0),\n\tSOC_SINGLE(\"ALC Capture Decay\", WM8983_ALC_CONTROL_3, 4, 10, 0),\n\tSOC_ENUM(\"ALC Mode\", alc_mode),\n\tSOC_SINGLE(\"ALC Capture NG Switch\", WM8983_NOISE_GATE,\n\t\t   3, 1, 0),\n\tSOC_SINGLE(\"ALC Capture NG Threshold\", WM8983_NOISE_GATE,\n\t\t   0, 7, 1),\n\n\tSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8983_LEFT_ADC_DIGITAL_VOL,\n\t\t\t WM8983_RIGHT_ADC_DIGITAL_VOL, 0, 255, 0, adc_tlv),\n\tSOC_DOUBLE_R(\"Capture PGA ZC Switch\", WM8983_LEFT_INP_PGA_GAIN_CTRL,\n\t\t     WM8983_RIGHT_INP_PGA_GAIN_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"Capture PGA Volume\", WM8983_LEFT_INP_PGA_GAIN_CTRL,\n\t\t\t WM8983_RIGHT_INP_PGA_GAIN_CTRL, 0, 63, 0, pga_vol_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Capture PGA Boost Volume\",\n\t\t\t WM8983_LEFT_ADC_BOOST_CTRL, WM8983_RIGHT_ADC_BOOST_CTRL,\n\t\t\t 8, 1, 0, pga_boost_tlv),\n\n\tSOC_DOUBLE(\"ADC Inversion Switch\", WM8983_ADC_CONTROL, 0, 1, 1, 0),\n\tSOC_SINGLE(\"ADC 128x Oversampling Switch\", WM8983_ADC_CONTROL, 8, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8983_LEFT_DAC_DIGITAL_VOL,\n\t\t\t WM8983_RIGHT_DAC_DIGITAL_VOL, 0, 255, 0, dac_tlv),\n\n\tSOC_SINGLE(\"DAC Playback Limiter Switch\", WM8983_DAC_LIMITER_1, 8, 1, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Decay\", WM8983_DAC_LIMITER_1, 4, 10, 0),\n\tSOC_SINGLE(\"DAC Playback Limiter Attack\", WM8983_DAC_LIMITER_1, 0, 11, 0),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Threshold\", WM8983_DAC_LIMITER_2,\n\t\t       4, 7, 1, lim_thresh_tlv),\n\tSOC_SINGLE_TLV(\"DAC Playback Limiter Boost Volume\", WM8983_DAC_LIMITER_2,\n\t\t       0, 12, 0, lim_boost_tlv),\n\tSOC_DOUBLE(\"DAC Inversion Switch\", WM8983_DAC_CONTROL, 0, 1, 1, 0),\n\tSOC_SINGLE(\"DAC Auto Mute Switch\", WM8983_DAC_CONTROL, 2, 1, 0),\n\tSOC_SINGLE(\"DAC 128x Oversampling Switch\", WM8983_DAC_CONTROL, 3, 1, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Headphone Playback Volume\", WM8983_LOUT1_HP_VOLUME_CTRL,\n\t\t\t WM8983_ROUT1_HP_VOLUME_CTRL, 0, 63, 0, out_tlv),\n\tSOC_DOUBLE_R(\"Headphone Playback ZC Switch\", WM8983_LOUT1_HP_VOLUME_CTRL,\n\t\t     WM8983_ROUT1_HP_VOLUME_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Headphone Switch\", WM8983_LOUT1_HP_VOLUME_CTRL,\n\t\t     WM8983_ROUT1_HP_VOLUME_CTRL, 6, 1, 1),\n\n\tSOC_DOUBLE_R_TLV(\"Speaker Playback Volume\", WM8983_LOUT2_SPK_VOLUME_CTRL,\n\t\t\t WM8983_ROUT2_SPK_VOLUME_CTRL, 0, 63, 0, out_tlv),\n\tSOC_DOUBLE_R(\"Speaker Playback ZC Switch\", WM8983_LOUT2_SPK_VOLUME_CTRL,\n\t\t     WM8983_ROUT2_SPK_VOLUME_CTRL, 7, 1, 0),\n\tSOC_DOUBLE_R(\"Speaker Switch\", WM8983_LOUT2_SPK_VOLUME_CTRL,\n\t\t     WM8983_ROUT2_SPK_VOLUME_CTRL, 6, 1, 1),\n\n\tSOC_SINGLE(\"OUT3 Switch\", WM8983_OUT3_MIXER_CTRL,\n\t\t   6, 1, 1),\n\n\tSOC_SINGLE(\"OUT4 Switch\", WM8983_OUT4_MONO_MIX_CTRL,\n\t\t   6, 1, 1),\n\n\tSOC_SINGLE(\"High Pass Filter Switch\", WM8983_ADC_CONTROL, 8, 1, 0),\n\tSOC_ENUM(\"High Pass Filter Mode\", filter_mode),\n\tSOC_SINGLE(\"High Pass Filter Cutoff\", WM8983_ADC_CONTROL, 4, 7, 0),\n\n\tSOC_DOUBLE_R_TLV(\"Aux Bypass Volume\",\n\t\t\t WM8983_LEFT_MIXER_CTRL, WM8983_RIGHT_MIXER_CTRL, 6, 7, 0,\n\t\t\t aux_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Input PGA Bypass Volume\",\n\t\t\t WM8983_LEFT_MIXER_CTRL, WM8983_RIGHT_MIXER_CTRL, 2, 7, 0,\n\t\t\t bypass_tlv),\n\n\tSOC_ENUM_EXT(\"Equalizer Function\", eqmode, eqmode_get, eqmode_put),\n\tSOC_ENUM(\"EQ1 Cutoff\", eq1_cutoff),\n\tSOC_SINGLE_TLV(\"EQ1 Volume\", WM8983_EQ1_LOW_SHELF,  0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ2 Bandwidth\", eq2_bw),\n\tSOC_ENUM(\"EQ2 Cutoff\", eq2_cutoff),\n\tSOC_SINGLE_TLV(\"EQ2 Volume\", WM8983_EQ2_PEAK_1, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ3 Bandwidth\", eq3_bw),\n\tSOC_ENUM(\"EQ3 Cutoff\", eq3_cutoff),\n\tSOC_SINGLE_TLV(\"EQ3 Volume\", WM8983_EQ3_PEAK_2, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ4 Bandwidth\", eq4_bw),\n\tSOC_ENUM(\"EQ4 Cutoff\", eq4_cutoff),\n\tSOC_SINGLE_TLV(\"EQ4 Volume\", WM8983_EQ4_PEAK_3, 0, 24, 1, eq_tlv),\n\tSOC_ENUM(\"EQ5 Cutoff\", eq5_cutoff),\n\tSOC_SINGLE_TLV(\"EQ5 Volume\", WM8983_EQ5_HIGH_SHELF, 0, 24, 1, eq_tlv),\n\n\tSOC_ENUM(\"3D Depth\", depth_3d),\n};\n\nstatic const struct snd_kcontrol_new left_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Switch\", WM8983_LEFT_MIXER_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Switch\", WM8983_LEFT_MIXER_CTRL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Switch\", WM8983_LEFT_MIXER_CTRL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_out_mixer[] = {\n\tSOC_DAPM_SINGLE(\"Line Switch\", WM8983_RIGHT_MIXER_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Aux Switch\", WM8983_RIGHT_MIXER_CTRL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"PCM Switch\", WM8983_RIGHT_MIXER_CTRL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new left_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"L2 Switch\", WM8983_INPUT_CTRL, 2, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8983_INPUT_CTRL, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8983_INPUT_CTRL, 0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_input_mixer[] = {\n\tSOC_DAPM_SINGLE(\"R2 Switch\", WM8983_INPUT_CTRL, 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicN Switch\", WM8983_INPUT_CTRL, 5, 1, 0),\n\tSOC_DAPM_SINGLE(\"MicP Switch\", WM8983_INPUT_CTRL, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new left_boost_mixer[] = {\n\tSOC_DAPM_SINGLE_TLV(\"L2 Volume\", WM8983_LEFT_ADC_BOOST_CTRL,\n\t\t\t    4, 7, 0, boost_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"AUXL Volume\", WM8983_LEFT_ADC_BOOST_CTRL,\n\t\t\t    0, 7, 0, boost_tlv)\n};\n\nstatic const struct snd_kcontrol_new out3_mixer[] = {\n\tSOC_DAPM_SINGLE(\"LMIX2OUT3 Switch\", WM8983_OUT3_MIXER_CTRL,\n\t\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"LDAC2OUT3 Switch\", WM8983_OUT3_MIXER_CTRL,\n\t\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new out4_mixer[] = {\n\tSOC_DAPM_SINGLE(\"LMIX2OUT4 Switch\", WM8983_OUT4_MONO_MIX_CTRL,\n\t\t\t4, 1, 0),\n\tSOC_DAPM_SINGLE(\"RMIX2OUT4 Switch\", WM8983_OUT4_MONO_MIX_CTRL,\n\t\t\t1, 1, 0),\n\tSOC_DAPM_SINGLE(\"LDAC2OUT4 Switch\", WM8983_OUT4_MONO_MIX_CTRL,\n\t\t\t3, 1, 0),\n\tSOC_DAPM_SINGLE(\"RDAC2OUT4 Switch\", WM8983_OUT4_MONO_MIX_CTRL,\n\t\t\t0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new right_boost_mixer[] = {\n\tSOC_DAPM_SINGLE_TLV(\"R2 Volume\", WM8983_RIGHT_ADC_BOOST_CTRL,\n\t\t\t    4, 7, 0, boost_tlv),\n\tSOC_DAPM_SINGLE_TLV(\"AUXR Volume\", WM8983_RIGHT_ADC_BOOST_CTRL,\n\t\t\t    0, 7, 0, boost_tlv)\n};\n\nstatic const struct snd_soc_dapm_widget wm8983_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"Left DAC\", \"Left Playback\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 0, 0),\n\tSND_SOC_DAPM_DAC(\"Right DAC\", \"Right Playback\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 1, 0),\n\tSND_SOC_DAPM_ADC(\"Left ADC\", \"Left Capture\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t 0, 0),\n\tSND_SOC_DAPM_ADC(\"Right ADC\", \"Right Capture\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t 1, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Left Output Mixer\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t   2, 0, left_out_mixer, ARRAY_SIZE(left_out_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Output Mixer\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t   3, 0, right_out_mixer, ARRAY_SIZE(right_out_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Input Mixer\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t   2, 0, left_input_mixer, ARRAY_SIZE(left_input_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Input Mixer\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t   3, 0, right_input_mixer, ARRAY_SIZE(right_input_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"Left Boost Mixer\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t   4, 0, left_boost_mixer, ARRAY_SIZE(left_boost_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Boost Mixer\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t   5, 0, right_boost_mixer, ARRAY_SIZE(right_boost_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"OUT3 Mixer\", WM8983_POWER_MANAGEMENT_1,\n\t\t\t   6, 0, out3_mixer, ARRAY_SIZE(out3_mixer)),\n\n\tSND_SOC_DAPM_MIXER(\"OUT4 Mixer\", WM8983_POWER_MANAGEMENT_1,\n\t\t\t   7, 0, out4_mixer, ARRAY_SIZE(out4_mixer)),\n\n\tSND_SOC_DAPM_PGA(\"Left Capture PGA\", WM8983_LEFT_INP_PGA_GAIN_CTRL,\n\t\t\t 6, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Capture PGA\", WM8983_RIGHT_INP_PGA_GAIN_CTRL,\n\t\t\t 6, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Headphone Out\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t 7, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Headphone Out\", WM8983_POWER_MANAGEMENT_2,\n\t\t\t 8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Left Speaker Out\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 5, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Right Speaker Out\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 6, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"OUT3 Out\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 7, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"OUT4 Out\", WM8983_POWER_MANAGEMENT_3,\n\t\t\t 8, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"Mic Bias\", WM8983_POWER_MANAGEMENT_1, 4, 0,\n\t\t\t    NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"LIN\"),\n\tSND_SOC_DAPM_INPUT(\"LIP\"),\n\tSND_SOC_DAPM_INPUT(\"RIN\"),\n\tSND_SOC_DAPM_INPUT(\"RIP\"),\n\tSND_SOC_DAPM_INPUT(\"AUXL\"),\n\tSND_SOC_DAPM_INPUT(\"AUXR\"),\n\tSND_SOC_DAPM_INPUT(\"L2\"),\n\tSND_SOC_DAPM_INPUT(\"R2\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT4\")\n};\n\nstatic const struct snd_soc_dapm_route wm8983_audio_map[] = {\n\t{ \"OUT3 Mixer\", \"LMIX2OUT3 Switch\", \"Left Output Mixer\" },\n\t{ \"OUT3 Mixer\", \"LDAC2OUT3 Switch\", \"Left DAC\" },\n\n\t{ \"OUT3 Out\", NULL, \"OUT3 Mixer\" },\n\t{ \"OUT3\", NULL, \"OUT3 Out\" },\n\n\t{ \"OUT4 Mixer\", \"LMIX2OUT4 Switch\", \"Left Output Mixer\" },\n\t{ \"OUT4 Mixer\", \"RMIX2OUT4 Switch\", \"Right Output Mixer\" },\n\t{ \"OUT4 Mixer\", \"LDAC2OUT4 Switch\", \"Left DAC\" },\n\t{ \"OUT4 Mixer\", \"RDAC2OUT4 Switch\", \"Right DAC\" },\n\n\t{ \"OUT4 Out\", NULL, \"OUT4 Mixer\" },\n\t{ \"OUT4\", NULL, \"OUT4 Out\" },\n\n\t{ \"Right Output Mixer\", \"PCM Switch\", \"Right DAC\" },\n\t{ \"Right Output Mixer\", \"Aux Switch\", \"AUXR\" },\n\t{ \"Right Output Mixer\", \"Line Switch\", \"Right Boost Mixer\" },\n\n\t{ \"Left Output Mixer\", \"PCM Switch\", \"Left DAC\" },\n\t{ \"Left Output Mixer\", \"Aux Switch\", \"AUXL\" },\n\t{ \"Left Output Mixer\", \"Line Switch\", \"Left Boost Mixer\" },\n\n\t{ \"Right Headphone Out\", NULL, \"Right Output Mixer\" },\n\t{ \"HPR\", NULL, \"Right Headphone Out\" },\n\n\t{ \"Left Headphone Out\", NULL, \"Left Output Mixer\" },\n\t{ \"HPL\", NULL, \"Left Headphone Out\" },\n\n\t{ \"Right Speaker Out\", NULL, \"Right Output Mixer\" },\n\t{ \"SPKR\", NULL, \"Right Speaker Out\" },\n\n\t{ \"Left Speaker Out\", NULL, \"Left Output Mixer\" },\n\t{ \"SPKL\", NULL, \"Left Speaker Out\" },\n\n\t{ \"Right ADC\", NULL, \"Right Boost Mixer\" },\n\n\t{ \"Right Boost Mixer\", \"AUXR Volume\", \"AUXR\" },\n\t{ \"Right Boost Mixer\", NULL, \"Right Capture PGA\" },\n\t{ \"Right Boost Mixer\", \"R2 Volume\", \"R2\" },\n\n\t{ \"Left ADC\", NULL, \"Left Boost Mixer\" },\n\n\t{ \"Left Boost Mixer\", \"AUXL Volume\", \"AUXL\" },\n\t{ \"Left Boost Mixer\", NULL, \"Left Capture PGA\" },\n\t{ \"Left Boost Mixer\", \"L2 Volume\", \"L2\" },\n\n\t{ \"Right Capture PGA\", NULL, \"Right Input Mixer\" },\n\t{ \"Left Capture PGA\", NULL, \"Left Input Mixer\" },\n\n\t{ \"Right Input Mixer\", \"R2 Switch\", \"R2\" },\n\t{ \"Right Input Mixer\", \"MicN Switch\", \"RIN\" },\n\t{ \"Right Input Mixer\", \"MicP Switch\", \"RIP\" },\n\n\t{ \"Left Input Mixer\", \"L2 Switch\", \"L2\" },\n\t{ \"Left Input Mixer\", \"MicN Switch\", \"LIN\" },\n\t{ \"Left Input Mixer\", \"MicP Switch\", \"LIP\" },\n};\n\nstatic int eqmode_get(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM8983_EQ1_LOW_SHELF);\n\tif (reg & WM8983_EQ3DMODE)\n\t\tucontrol->value.enumerated.item[0] = 1;\n\telse\n\t\tucontrol->value.enumerated.item[0] = 0;\n\n\treturn 0;\n}\n\nstatic int eqmode_put(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int regpwr2, regpwr3;\n\tunsigned int reg_eq;\n\n\tif (ucontrol->value.enumerated.item[0] != 0\n\t    && ucontrol->value.enumerated.item[0] != 1)\n\t\treturn -EINVAL;\n\n\treg_eq = snd_soc_component_read(component, WM8983_EQ1_LOW_SHELF);\n\tswitch ((reg_eq & WM8983_EQ3DMODE) >> WM8983_EQ3DMODE_SHIFT) {\n\tcase 0:\n\t\tif (!ucontrol->value.enumerated.item[0])\n\t\t\treturn 0;\n\t\tbreak;\n\tcase 1:\n\t\tif (ucontrol->value.enumerated.item[0])\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\tregpwr2 = snd_soc_component_read(component, WM8983_POWER_MANAGEMENT_2);\n\tregpwr3 = snd_soc_component_read(component, WM8983_POWER_MANAGEMENT_3);\n\t \n\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_2,\n\t\t\t    WM8983_ADCENR_MASK | WM8983_ADCENL_MASK, 0);\n\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_3,\n\t\t\t    WM8983_DACENR_MASK | WM8983_DACENL_MASK, 0);\n\t \n\tsnd_soc_component_update_bits(component, WM8983_EQ1_LOW_SHELF,\n\t\t\t    WM8983_EQ3DMODE_MASK,\n\t\t\t    ucontrol->value.enumerated.item[0]\n\t\t\t    << WM8983_EQ3DMODE_SHIFT);\n\t \n\tsnd_soc_component_write(component, WM8983_POWER_MANAGEMENT_2, regpwr2);\n\tsnd_soc_component_write(component, WM8983_POWER_MANAGEMENT_3, regpwr3);\n\treturn 0;\n}\n\nstatic bool wm8983_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8983_SOFTWARE_RESET ... WM8983_RIGHT_ADC_DIGITAL_VOL:\n\tcase WM8983_EQ1_LOW_SHELF ... WM8983_DAC_LIMITER_2:\n\tcase WM8983_NOTCH_FILTER_1 ... WM8983_NOTCH_FILTER_4:\n\tcase WM8983_ALC_CONTROL_1 ... WM8983_PLL_K_3:\n\tcase WM8983_3D_CONTROL ... WM8983_OUT4_MONO_MIX_CTRL:\n\tcase WM8983_BIAS_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8983_dac_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\treturn snd_soc_component_update_bits(component, WM8983_DAC_CONTROL,\n\t\t\t\t   WM8983_SOFTMUTE_MASK,\n\t\t\t\t   !!mute << WM8983_SOFTMUTE_SHIFT);\n}\n\nstatic int wm8983_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tu16 format, master, bcp, lrp;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tformat = 0x0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = 0x1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown dai format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8983_AUDIO_INTERFACE,\n\t\t\t    WM8983_FMT_MASK, format << WM8983_FMT_SHIFT);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown master/slave configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8983_CLOCK_GEN_CONTROL,\n\t\t\t    WM8983_MS_MASK, master << WM8983_MS_SHIFT);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tdev_err(dai->dev, \"DSP A/B modes are not supported\\n\");\n\t\treturn -EINVAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbcp = lrp = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tbcp = lrp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tbcp = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tlrp = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown polarity configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8983_AUDIO_INTERFACE,\n\t\t\t    WM8983_LRCP_MASK, lrp << WM8983_LRCP_SHIFT);\n\tsnd_soc_component_update_bits(component, WM8983_AUDIO_INTERFACE,\n\t\t\t    WM8983_BCP_MASK, bcp << WM8983_BCP_SHIFT);\n\treturn 0;\n}\n\nstatic int wm8983_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tint i;\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8983_priv *wm8983 = snd_soc_component_get_drvdata(component);\n\tu16 blen, srate_idx;\n\tu32 tmp;\n\tint srate_best;\n\tint ret;\n\n\tret = snd_soc_params_to_bclk(params);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to convert params to bclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8983->bclk = ret;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tblen = 0x0;\n\t\tbreak;\n\tcase 20:\n\t\tblen = 0x1;\n\t\tbreak;\n\tcase 24:\n\t\tblen = 0x2;\n\t\tbreak;\n\tcase 32:\n\t\tblen = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported word length %u\\n\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8983_AUDIO_INTERFACE,\n\t\t\t    WM8983_WL_MASK, blen << WM8983_WL_SHIFT);\n\n\t \n\tsrate_idx = 0;\n\tsrate_best = abs(srates[0] - params_rate(params));\n\tfor (i = 1; i < ARRAY_SIZE(srates); ++i) {\n\t\tif (abs(srates[i] - params_rate(params)) >= srate_best)\n\t\t\tcontinue;\n\t\tsrate_idx = i;\n\t\tsrate_best = abs(srates[i] - params_rate(params));\n\t}\n\n\tdev_dbg(dai->dev, \"Selected SRATE = %d\\n\", srates[srate_idx]);\n\tsnd_soc_component_update_bits(component, WM8983_ADDITIONAL_CONTROL,\n\t\t\t    WM8983_SR_MASK, srate_idx << WM8983_SR_SHIFT);\n\n\tdev_dbg(dai->dev, \"Target BCLK = %uHz\\n\", wm8983->bclk);\n\tdev_dbg(dai->dev, \"SYSCLK = %uHz\\n\", wm8983->sysclk);\n\n\tfor (i = 0; i < ARRAY_SIZE(fs_ratios); ++i) {\n\t\tif (wm8983->sysclk / params_rate(params)\n\t\t    == fs_ratios[i].ratio)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(fs_ratios)) {\n\t\tdev_err(dai->dev, \"Unable to configure MCLK ratio %u/%u\\n\",\n\t\t\twm8983->sysclk, params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"MCLK ratio = %dfs\\n\", fs_ratios[i].ratio);\n\tsnd_soc_component_update_bits(component, WM8983_CLOCK_GEN_CONTROL,\n\t\t\t    WM8983_MCLKDIV_MASK, i << WM8983_MCLKDIV_SHIFT);\n\n\t \n\ttmp = (wm8983->sysclk / fs_ratios[i].div) * 10;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); ++i) {\n\t\tif (wm8983->bclk == tmp / bclk_divs[i])\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(bclk_divs)) {\n\t\tdev_err(dai->dev, \"No matching BCLK divider found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"BCLK div = %d\\n\", i);\n\tsnd_soc_component_update_bits(component, WM8983_CLOCK_GEN_CONTROL,\n\t\t\t    WM8983_BCLKDIV_MASK, i << WM8983_BCLKDIV_SHIFT);\n\n\treturn 0;\n}\n\nstruct pll_div {\n\tu32 div2:1;\n\tu32 n:4;\n\tu32 k:24;\n};\n\n#define FIXED_PLL_SIZE ((1ULL << 24) * 10)\nstatic int pll_factors(struct pll_div *pll_div, unsigned int target,\n\t\t       unsigned int source)\n{\n\tu64 Kpart;\n\tunsigned long int K, Ndiv, Nmod;\n\n\tpll_div->div2 = 0;\n\tNdiv = target / source;\n\tif (Ndiv < 6) {\n\t\tsource >>= 1;\n\t\tpll_div->div2 = 1;\n\t\tNdiv = target / source;\n\t}\n\n\tif (Ndiv < 6 || Ndiv > 12) {\n\t\tprintk(KERN_ERR \"%s: WM8983 N value is not within\"\n\t\t       \" the recommended range: %lu\\n\", __func__, Ndiv);\n\t\treturn -EINVAL;\n\t}\n\tpll_div->n = Ndiv;\n\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (u64)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xffffffff;\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\tK /= 10;\n\tpll_div->k = K;\n\treturn 0;\n}\n\nstatic int wm8983_set_pll(struct snd_soc_dai *dai, int pll_id,\n\t\t\t  int source, unsigned int freq_in,\n\t\t\t  unsigned int freq_out)\n{\n\tint ret;\n\tstruct snd_soc_component *component;\n\tstruct pll_div pll_div;\n\n\tcomponent = dai->component;\n\tif (!freq_in || !freq_out) {\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_PLLEN_MASK, 0);\n\t\treturn 0;\n\t} else {\n\t\tret = pll_factors(&pll_div, freq_out * 4 * 2, freq_in);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_PLLEN_MASK, 0);\n\n\t\t \n\t\tsnd_soc_component_write(component, WM8983_PLL_N,\n\t\t\t(pll_div.div2 << WM8983_PLL_PRESCALE_SHIFT)\n\t\t\t| pll_div.n);\n\t\t \n\t\tsnd_soc_component_write(component, WM8983_PLL_K_3, pll_div.k & 0x1ff);\n\t\tsnd_soc_component_write(component, WM8983_PLL_K_2, (pll_div.k >> 9) & 0x1ff);\n\t\tsnd_soc_component_write(component, WM8983_PLL_K_1, (pll_div.k >> 18));\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\tWM8983_PLLEN_MASK, WM8983_PLLEN);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8983_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8983_priv *wm8983 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase WM8983_CLKSRC_MCLK:\n\t\tsnd_soc_component_update_bits(component, WM8983_CLOCK_GEN_CONTROL,\n\t\t\t\t    WM8983_CLKSEL_MASK, 0);\n\t\tbreak;\n\tcase WM8983_CLKSRC_PLL:\n\t\tsnd_soc_component_update_bits(component, WM8983_CLOCK_GEN_CONTROL,\n\t\t\t\t    WM8983_CLKSEL_MASK, WM8983_CLKSEL);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unknown clock source: %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\twm8983->sysclk = freq;\n\treturn 0;\n}\n\nstatic int wm8983_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8983_priv *wm8983 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regcache_sync(wm8983->regmap);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev, \"Failed to sync cache: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK | WM8983_DELEN_MASK,\n\t\t\t\t\t    WM8983_POBCTRL | WM8983_DELEN);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8983_OUTPUT_CTRL,\n\t\t\t\t\t    WM8983_TSDEN_MASK, WM8983_TSDEN);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_BIASEN_MASK, WM8983_BIASEN);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t\t    1 << WM8983_VMIDSEL_SHIFT);\n\t\t\tmsleep(250);\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8983_OUT4_TO_ADC,\n\t\t\t\t\t    WM8983_POBCTRL_MASK |\n\t\t\t\t\t    WM8983_DELEN_MASK, 0);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK,\n\t\t\t\t    2 << WM8983_VMIDSEL_SHIFT);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_OUTPUT_CTRL,\n\t\t\t\t    WM8983_TSDEN_MASK, 0);\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8983_POWER_MANAGEMENT_1,\n\t\t\t\t    WM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,\n\t\t\t\t    0);\n\t\t \n\t\tmsleep(100);\n\t\tsnd_soc_component_write(component, WM8983_POWER_MANAGEMENT_1, 0);\n\t\tsnd_soc_component_write(component, WM8983_POWER_MANAGEMENT_2, 0);\n\t\tsnd_soc_component_write(component, WM8983_POWER_MANAGEMENT_3, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8983_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\tint i;\n\n\tret = snd_soc_component_write(component, WM8983_SOFTWARE_RESET, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(vol_update_regs); ++i)\n\t\tsnd_soc_component_update_bits(component, vol_update_regs[i],\n\t\t\t\t    0x100, 0x100);\n\n\t \n\tfor (i = WM8983_LOUT1_HP_VOLUME_CTRL;\n\t     i <= WM8983_OUT4_MONO_MIX_CTRL; ++i)\n\t\tsnd_soc_component_update_bits(component, i, 0x40, 0x40);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8983_DAC_CONTROL,\n\t\t\t    WM8983_SOFTMUTE_MASK,\n\t\t\t    WM8983_SOFTMUTE);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8983_BIAS_CTRL,\n\t\t\t    WM8983_BIASCUT, WM8983_BIASCUT);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops wm8983_dai_ops = {\n\t.mute_stream = wm8983_dac_mute,\n\t.hw_params = wm8983_hw_params,\n\t.set_fmt = wm8983_set_fmt,\n\t.set_sysclk = wm8983_set_sysclk,\n\t.set_pll = wm8983_set_pll,\n\t.no_capture_mute = 1,\n};\n\n#define WM8983_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver wm8983_dai = {\n\t.name = \"wm8983-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8983_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = WM8983_FORMATS,\n\t},\n\t.ops = &wm8983_dai_ops,\n\t.symmetric_rate = 1\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8983 = {\n\t.probe\t\t\t= wm8983_probe,\n\t.set_bias_level\t\t= wm8983_set_bias_level,\n\t.controls\t\t= wm8983_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8983_snd_controls),\n\t.dapm_widgets\t\t= wm8983_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8983_dapm_widgets),\n\t.dapm_routes\t\t= wm8983_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8983_audio_map),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8983_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\n\t.reg_defaults = wm8983_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8983_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.max_register = WM8983_MAX_REGISTER,\n\n\t.writeable_reg = wm8983_writeable,\n};\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8983_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8983_priv *wm8983;\n\tint ret;\n\n\twm8983 = devm_kzalloc(&spi->dev, sizeof *wm8983, GFP_KERNEL);\n\tif (!wm8983)\n\t\treturn -ENOMEM;\n\n\twm8983->regmap = devm_regmap_init_spi(spi, &wm8983_regmap);\n\tif (IS_ERR(wm8983->regmap)) {\n\t\tret = PTR_ERR(wm8983->regmap);\n\t\tdev_err(&spi->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, wm8983);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t&soc_component_dev_wm8983, &wm8983_dai, 1);\n\treturn ret;\n}\n\nstatic struct spi_driver wm8983_spi_driver = {\n\t.driver = {\n\t\t.name = \"wm8983\",\n\t},\n\t.probe = wm8983_spi_probe,\n};\n#endif\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8983_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8983_priv *wm8983;\n\tint ret;\n\n\twm8983 = devm_kzalloc(&i2c->dev, sizeof *wm8983, GFP_KERNEL);\n\tif (!wm8983)\n\t\treturn -ENOMEM;\n\n\twm8983->regmap = devm_regmap_init_i2c(i2c, &wm8983_regmap);\n\tif (IS_ERR(wm8983->regmap)) {\n\t\tret = PTR_ERR(wm8983->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8983);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_component_dev_wm8983, &wm8983_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8983_i2c_id[] = {\n\t{ \"wm8983\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8983_i2c_id);\n\nstatic struct i2c_driver wm8983_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8983\",\n\t},\n\t.probe = wm8983_i2c_probe,\n\t.id_table = wm8983_i2c_id\n};\n#endif\n\nstatic int __init wm8983_modinit(void)\n{\n\tint ret = 0;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8983_i2c_driver);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Failed to register wm8983 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8983_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8983 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn ret;\n}\nmodule_init(wm8983_modinit);\n\nstatic void __exit wm8983_exit(void)\n{\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8983_i2c_driver);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8983_spi_driver);\n#endif\n}\nmodule_exit(wm8983_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8983 driver\");\nMODULE_AUTHOR(\"Dimitris Papastamos <dp@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}