{
  "module_name": "jz4760.c",
  "hash_id": "e5bbdf3d083ee96e5f20671e04f3781c785e214b7f0a408d8ce0e6ac0d99335a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/jz4760.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/time64.h>\n\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dai.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#define ICDC_RGADW_OFFSET\t\t0x00\n#define ICDC_RGDATA_OFFSET\t\t0x04\n\n \n#define ICDC_RGADW_RGWR\t\t\tBIT(16)\n#define\tICDC_RGADW_RGADDR_MASK\t\tGENMASK(14, 8)\n#define\tICDC_RGADW_RGDIN_MASK\t\tGENMASK(7, 0)\n\n \n#define ICDC_RGDATA_IRQ\t\t\tBIT(8)\n#define ICDC_RGDATA_RGDOUT_MASK\t\tGENMASK(7, 0)\n\n \nenum {\n\tJZ4760_CODEC_REG_SR,\n\tJZ4760_CODEC_REG_AICR,\n\tJZ4760_CODEC_REG_CR1,\n\tJZ4760_CODEC_REG_CR2,\n\tJZ4760_CODEC_REG_CR3,\n\tJZ4760_CODEC_REG_CR4,\n\tJZ4760_CODEC_REG_CCR1,\n\tJZ4760_CODEC_REG_CCR2,\n\tJZ4760_CODEC_REG_PMR1,\n\tJZ4760_CODEC_REG_PMR2,\n\tJZ4760_CODEC_REG_ICR,\n\tJZ4760_CODEC_REG_IFR,\n\tJZ4760_CODEC_REG_GCR1,\n\tJZ4760_CODEC_REG_GCR2,\n\tJZ4760_CODEC_REG_GCR3,\n\tJZ4760_CODEC_REG_GCR4,\n\tJZ4760_CODEC_REG_GCR5,\n\tJZ4760_CODEC_REG_GCR6,\n\tJZ4760_CODEC_REG_GCR7,\n\tJZ4760_CODEC_REG_GCR8,\n\tJZ4760_CODEC_REG_GCR9,\n\tJZ4760_CODEC_REG_AGC1,\n\tJZ4760_CODEC_REG_AGC2,\n\tJZ4760_CODEC_REG_AGC3,\n\tJZ4760_CODEC_REG_AGC4,\n\tJZ4760_CODEC_REG_AGC5,\n\tJZ4760_CODEC_REG_MIX1,\n\tJZ4760_CODEC_REG_MIX2,\n};\n\n#define REG_AICR_DAC_ADWL_MASK\t\tGENMASK(7, 6)\n#define REG_AICR_DAC_SERIAL\t\tBIT(3)\n#define REG_AICR_DAC_I2S\t\tBIT(1)\n\n#define REG_AICR_ADC_ADWL_MASK\t\tGENMASK(5, 4)\n\n#define REG_AICR_ADC_SERIAL\t\tBIT(2)\n#define REG_AICR_ADC_I2S\t\tBIT(0)\n\n#define REG_CR1_HP_LOAD\t\t\tBIT(7)\n#define REG_CR1_HP_MUTE\t\t\tBIT(5)\n#define REG_CR1_LO_MUTE_OFFSET\t\t4\n#define REG_CR1_BTL_MUTE_OFFSET\t\t3\n#define REG_CR1_OUTSEL_OFFSET\t\t0\n#define REG_CR1_OUTSEL_MASK\t\tGENMASK(1, REG_CR1_OUTSEL_OFFSET)\n\n#define REG_CR2_DAC_MONO\t\tBIT(7)\n#define REG_CR2_DAC_MUTE\t\tBIT(5)\n#define REG_CR2_DAC_NOMAD\t\tBIT(1)\n#define REG_CR2_DAC_RIGHT_ONLY\t\tBIT(0)\n\n#define REG_CR3_ADC_INSEL_OFFSET\t2\n#define REG_CR3_ADC_INSEL_MASK\t\tGENMASK(3, REG_CR3_ADC_INSEL_OFFSET)\n#define REG_CR3_MICSTEREO_OFFSET\t1\n#define REG_CR3_MICDIFF_OFFSET\t\t0\n\n#define REG_CR4_ADC_HPF_OFFSET\t\t7\n#define REG_CR4_ADC_RIGHT_ONLY\t\tBIT(0)\n\n#define REG_CCR1_CRYSTAL_MASK\t\tGENMASK(3, 0)\n\n#define REG_CCR2_DAC_FREQ_MASK\t\tGENMASK(7, 4)\n#define REG_CCR2_ADC_FREQ_MASK\t\tGENMASK(3, 0)\n\n#define REG_PMR1_SB\t\t\tBIT(7)\n#define REG_PMR1_SB_SLEEP\t\tBIT(6)\n#define REG_PMR1_SB_AIP_OFFSET\t\t5\n#define REG_PMR1_SB_LINE_OFFSET\t\t4\n#define REG_PMR1_SB_MIC1_OFFSET\t\t3\n#define REG_PMR1_SB_MIC2_OFFSET\t\t2\n#define REG_PMR1_SB_BYPASS_OFFSET\t1\n#define REG_PMR1_SB_MICBIAS_OFFSET\t0\n\n#define REG_PMR2_SB_ADC_OFFSET\t\t4\n#define REG_PMR2_SB_HP_OFFSET\t\t3\n#define REG_PMR2_SB_BTL_OFFSET\t\t2\n#define REG_PMR2_SB_LOUT_OFFSET\t\t1\n#define REG_PMR2_SB_DAC_OFFSET\t\t0\n\n#define REG_ICR_INT_FORM_MASK\t\tGENMASK(7, 6)\n#define REG_ICR_ALL_MASK\t\tGENMASK(5, 0)\n#define REG_ICR_JACK_MASK\t\tBIT(5)\n#define REG_ICR_SCMC_MASK\t\tBIT(4)\n#define REG_ICR_RUP_MASK\t\tBIT(3)\n#define REG_ICR_RDO_MASK\t\tBIT(2)\n#define REG_ICR_GUP_MASK\t\tBIT(1)\n#define REG_ICR_GDO_MASK\t\tBIT(0)\n\n#define REG_IFR_ALL_MASK\t\tGENMASK(5, 0)\n#define REG_IFR_JACK\t\t\tBIT(6)\n#define REG_IFR_JACK_EVENT\t\tBIT(5)\n#define REG_IFR_SCMC\t\t\tBIT(4)\n#define REG_IFR_RUP\t\t\tBIT(3)\n#define REG_IFR_RDO\t\t\tBIT(2)\n#define REG_IFR_GUP\t\t\tBIT(1)\n#define REG_IFR_GDO\t\t\tBIT(0)\n\n#define REG_GCR_GAIN_OFFSET\t\t0\n#define REG_GCR_GAIN_MAX\t\t0x1f\n\n#define REG_GCR_RL\t\t\tBIT(7)\n\n#define REG_GCR_GIM1_MASK\t\tGENMASK(5, 3)\n#define REG_GCR_GIM2_MASK\t\tGENMASK(2, 0)\n#define REG_GCR_GIM_GAIN_MAX\t\t7\n\n#define REG_AGC1_EN\t\t\tBIT(7)\n#define REG_AGC1_TARGET_MASK\t\tGENMASK(5, 2)\n\n#define REG_AGC2_NG_THR_MASK\t\tGENMASK(6, 4)\n#define REG_AGC2_HOLD_MASK\t\tGENMASK(3, 0)\n\n#define REG_AGC3_ATK_MASK\t\tGENMASK(7, 4)\n#define REG_AGC3_DCY_MASK\t\tGENMASK(3, 0)\n\n#define REG_AGC4_AGC_MAX_MASK\t\tGENMASK(4, 0)\n\n#define REG_AGC5_AGC_MIN_MASK\t\tGENMASK(4, 0)\n\n#define REG_MIX1_MIX_REC_MASK\t\tGENMASK(7, 6)\n#define REG_MIX1_GIMIX_MASK\t\tGENMASK(4, 0)\n\n#define REG_MIX2_DAC_MIX_MASK\t\tGENMASK(7, 6)\n#define REG_MIX2_GOMIX_MASK\t\tGENMASK(4, 0)\n\n \nstruct jz_codec {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n};\n\nstatic int jz4760_codec_set_bias_level(struct snd_soc_component *codec,\n\t\t\t\t       enum snd_soc_bias_level level)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tstruct regmap *regmap = jz_codec->regmap;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tregmap_write(regmap, JZ4760_CODEC_REG_IFR, REG_IFR_ALL_MASK);\n\n\t\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_PMR1, REG_PMR1_SB);\n\t\tmsleep(250);\n\t\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_PMR1, REG_PMR1_SB_SLEEP);\n\t\tmsleep(400);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_set_bits(regmap, JZ4760_CODEC_REG_PMR1, REG_PMR1_SB_SLEEP);\n\t\tregmap_set_bits(regmap, JZ4760_CODEC_REG_PMR1, REG_PMR1_SB);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4760_codec_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(codec);\n\tint ret = 0;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tret = snd_soc_dapm_force_enable_pin(dapm, \"SYSCLK\");\n\treturn ret;\n}\n\nstatic void jz4760_codec_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(codec);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tsnd_soc_dapm_disable_pin(dapm, \"SYSCLK\");\n}\n\n\nstatic int jz4760_codec_pcm_trigger(struct snd_pcm_substream *substream,\n\t\t\t\t    int cmd, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tint ret = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\t\tsnd_soc_component_force_bias_level(codec, SND_SOC_BIAS_ON);\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int jz4760_codec_mute_stream(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *codec = dai->component;\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tunsigned int gain_bit = mute ? REG_IFR_GDO : REG_IFR_GUP;\n\tunsigned int val, reg;\n\tint change, err;\n\n\tchange = snd_soc_component_update_bits(codec, JZ4760_CODEC_REG_CR2,\n\t\t\t\t\t       REG_CR2_DAC_MUTE,\n\t\t\t\t\t       mute ? REG_CR2_DAC_MUTE : 0);\n\tif (change == 1) {\n\t\tregmap_read(jz_codec->regmap, JZ4760_CODEC_REG_PMR2, &val);\n\n\t\tif (val & BIT(REG_PMR2_SB_DAC_OFFSET))\n\t\t\treturn 1;\n\n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4760_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & gain_bit,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev,\n\t\t\t\t\"Timeout while setting digital mute: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_write(jz_codec->regmap, JZ4760_CODEC_REG_IFR, gain_bit);\n\t}\n\n\tregmap_read(jz_codec->regmap, JZ4760_CODEC_REG_CR2, &reg);\n\n\treturn 0;\n}\n\n \nstatic const DECLARE_TLV_DB_MINMAX_MUTE(dac_tlv, -3100, 100);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, 0, 100, 0);\nstatic const DECLARE_TLV_DB_MINMAX(out_tlv, -2500, 100);\nstatic const DECLARE_TLV_DB_SCALE(linein_tlv, -2500, 100, 0);\nstatic const DECLARE_TLV_DB_MINMAX(mixer_tlv, -3100, 0);\n\n \nstatic const struct snd_kcontrol_new jz4760_codec_snd_controls[] = {\n\t \n\tSOC_DOUBLE_R_TLV(\"PCM Capture Volume\",\n\t\t\t JZ4760_CODEC_REG_GCR9, JZ4760_CODEC_REG_GCR8,\n\t\t\t REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 0, adc_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"Line In Bypass Playback Volume\",\n\t\t\t JZ4760_CODEC_REG_GCR4, JZ4760_CODEC_REG_GCR3,\n\t\t\t REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, linein_tlv),\n\n\tSOC_SINGLE_TLV(\"Mixer Capture Volume\",\n\t\t       JZ4760_CODEC_REG_MIX1,\n\t\t       REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, mixer_tlv),\n\n\tSOC_SINGLE_TLV(\"Mixer Playback Volume\",\n\t\t       JZ4760_CODEC_REG_MIX2,\n\t\t       REG_GCR_GAIN_OFFSET, REG_GCR_GAIN_MAX, 1, mixer_tlv),\n\n\tSOC_SINGLE(\"High-Pass Filter Capture Switch\",\n\t\t   JZ4760_CODEC_REG_CR4,\n\t\t   REG_CR4_ADC_HPF_OFFSET, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new jz4760_codec_pcm_playback_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Volume\",\n\t\t.info = snd_soc_info_volsw,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ\n\t\t\t| SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.tlv.p = dac_tlv,\n\t\t.get = snd_soc_dapm_get_volsw,\n\t\t.put = snd_soc_dapm_put_volsw,\n\t\t.private_value = SOC_DOUBLE_R_VALUE(JZ4760_CODEC_REG_GCR6,\n\t\t\t\t\t\t    JZ4760_CODEC_REG_GCR5,\n\t\t\t\t\t\t    REG_GCR_GAIN_OFFSET,\n\t\t\t\t\t\t    REG_GCR_GAIN_MAX, 1),\n\t},\n};\n\nstatic const struct snd_kcontrol_new jz4760_codec_hp_playback_controls[] = {\n\t{\n\t\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name = \"Volume\",\n\t\t.info = snd_soc_info_volsw,\n\t\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ\n\t\t\t| SNDRV_CTL_ELEM_ACCESS_READWRITE,\n\t\t.tlv.p = out_tlv,\n\t\t.get = snd_soc_dapm_get_volsw,\n\t\t.put = snd_soc_dapm_put_volsw,\n\t\t.private_value = SOC_DOUBLE_R_VALUE(JZ4760_CODEC_REG_GCR2,\n\t\t\t\t\t\t    JZ4760_CODEC_REG_GCR1,\n\t\t\t\t\t\t    REG_GCR_GAIN_OFFSET,\n\t\t\t\t\t\t    REG_GCR_GAIN_MAX, 1),\n\t},\n};\n\nstatic int hpout_event(struct snd_soc_dapm_widget *w,\n\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *codec = snd_soc_dapm_to_component(w->dapm);\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tunsigned int val;\n\tint err;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tregmap_clear_bits(jz_codec->regmap, JZ4760_CODEC_REG_CR1,\n\t\t\t\t  REG_CR1_HP_MUTE);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4760_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & REG_IFR_RUP,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev, \"RUP timeout: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4760_CODEC_REG_IFR,\n\t\t\t\tREG_IFR_RUP);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4760_CODEC_REG_CR1,\n\t\t\t\tREG_CR1_HP_MUTE);\n\n\t\terr = regmap_read_poll_timeout(jz_codec->regmap,\n\t\t\t\t\t       JZ4760_CODEC_REG_IFR,\n\t\t\t\t\t       val, val & REG_IFR_RDO,\n\t\t\t\t\t       1000, 1 * USEC_PER_SEC);\n\t\tif (err) {\n\t\t\tdev_err(jz_codec->dev, \"RDO timeout: %d\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tregmap_set_bits(jz_codec->regmap, JZ4760_CODEC_REG_IFR,\n\t\t\t\tREG_IFR_RDO);\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char * const jz4760_codec_hp_texts[] = {\n\t\"PCM\", \"Line In\", \"Mic 1\", \"Mic 2\"\n};\n\nstatic const unsigned int jz4760_codec_hp_values[] = { 3, 2, 0, 1 };\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4760_codec_hp_enum,\n\t\t\t\t  JZ4760_CODEC_REG_CR1,\n\t\t\t\t  REG_CR1_OUTSEL_OFFSET,\n\t\t\t\t  REG_CR1_OUTSEL_MASK >> REG_CR1_OUTSEL_OFFSET,\n\t\t\t\t  jz4760_codec_hp_texts,\n\t\t\t\t  jz4760_codec_hp_values);\nstatic const struct snd_kcontrol_new jz4760_codec_hp_source =\n\t\t\tSOC_DAPM_ENUM(\"Route\", jz4760_codec_hp_enum);\n\nstatic const char * const jz4760_codec_cap_texts[] = {\n\t\"Line In\", \"Mic 1\", \"Mic 2\"\n};\n\nstatic const unsigned int jz4760_codec_cap_values[] = { 2, 0, 1 };\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(jz4760_codec_cap_enum,\n\t\t\t\t  JZ4760_CODEC_REG_CR3,\n\t\t\t\t  REG_CR3_ADC_INSEL_OFFSET,\n\t\t\t\t  REG_CR3_ADC_INSEL_MASK >> REG_CR3_ADC_INSEL_OFFSET,\n\t\t\t\t  jz4760_codec_cap_texts,\n\t\t\t\t  jz4760_codec_cap_values);\nstatic const struct snd_kcontrol_new jz4760_codec_cap_source =\n\t\t\tSOC_DAPM_ENUM(\"Route\", jz4760_codec_cap_enum);\n\nstatic const struct snd_kcontrol_new jz4760_codec_mic_controls[] = {\n\tSOC_DAPM_SINGLE(\"Stereo Capture Switch\", JZ4760_CODEC_REG_CR3,\n\t\t\tREG_CR3_MICSTEREO_OFFSET, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new jz4760_codec_line_out_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", JZ4760_CODEC_REG_CR1,\n\t\t\tREG_CR1_LO_MUTE_OFFSET, 0, 0);\nstatic const struct snd_kcontrol_new jz4760_codec_btl_out_switch =\n\tSOC_DAPM_SINGLE(\"Switch\", JZ4760_CODEC_REG_CR1,\n\t\t\tREG_CR1_BTL_MUTE_OFFSET, 0, 0);\n\nstatic const struct snd_soc_dapm_widget jz4760_codec_dapm_widgets[] = {\n\tSND_SOC_DAPM_PGA_E(\"HP Out\", JZ4760_CODEC_REG_PMR2,\n\t\t\t   REG_PMR2_SB_HP_OFFSET, 1, NULL, 0, hpout_event,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_SWITCH(\"Line Out\", JZ4760_CODEC_REG_PMR2,\n\t\t\t    REG_PMR2_SB_LOUT_OFFSET, 1,\n\t\t\t    &jz4760_codec_line_out_switch),\n\n\tSND_SOC_DAPM_SWITCH(\"BTL Out\", JZ4760_CODEC_REG_PMR2,\n\t\t\t    REG_PMR2_SB_BTL_OFFSET, 1,\n\t\t\t    &jz4760_codec_btl_out_switch),\n\n\tSND_SOC_DAPM_PGA(\"Line In\", JZ4760_CODEC_REG_PMR1,\n\t\t\t REG_PMR1_SB_LINE_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"Headphones Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4760_codec_hp_source),\n\n\tSND_SOC_DAPM_MUX(\"Capture Source\", SND_SOC_NOPM, 0, 0,\n\t\t\t &jz4760_codec_cap_source),\n\n\tSND_SOC_DAPM_PGA(\"Mic 1\", JZ4760_CODEC_REG_PMR1,\n\t\t\t REG_PMR1_SB_MIC1_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Mic 2\", JZ4760_CODEC_REG_PMR1,\n\t\t\t REG_PMR1_SB_MIC2_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"Mic Diff\", JZ4760_CODEC_REG_CR3,\n\t\t\t REG_CR3_MICDIFF_OFFSET, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MIXER(\"Mic\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4760_codec_mic_controls,\n\t\t\t   ARRAY_SIZE(jz4760_codec_mic_controls)),\n\n\tSND_SOC_DAPM_PGA(\"Line In Bypass\", JZ4760_CODEC_REG_PMR1,\n\t\t\t REG_PMR1_SB_BYPASS_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", JZ4760_CODEC_REG_PMR2,\n\t\t\t REG_PMR2_SB_ADC_OFFSET, 1),\n\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", JZ4760_CODEC_REG_PMR2,\n\t\t\t REG_PMR2_SB_DAC_OFFSET, 1),\n\n\tSND_SOC_DAPM_MIXER(\"PCM Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4760_codec_pcm_playback_controls,\n\t\t\t   ARRAY_SIZE(jz4760_codec_pcm_playback_controls)),\n\n\tSND_SOC_DAPM_MIXER(\"Headphones Playback\", SND_SOC_NOPM, 0, 0,\n\t\t\t   jz4760_codec_hp_playback_controls,\n\t\t\t   ARRAY_SIZE(jz4760_codec_hp_playback_controls)),\n\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", JZ4760_CODEC_REG_PMR1,\n\t\t\t    REG_PMR1_SB_MICBIAS_OFFSET, 1, NULL, 0),\n\n\tSND_SOC_DAPM_INPUT(\"MIC1P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1N\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2P\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2N\"),\n\n\tSND_SOC_DAPM_INPUT(\"LLINEIN\"),\n\tSND_SOC_DAPM_INPUT(\"RLINEIN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LHPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"RHPOUT\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"ROUT\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"BTLP\"),\n\tSND_SOC_DAPM_OUTPUT(\"BTLN\"),\n\n\tSND_SOC_DAPM_OUTPUT(\"SYSCLK\"),\n};\n\n \nstatic const struct snd_soc_dapm_route jz4760_codec_dapm_routes[] = {\n\t{ \"Mic 1\", NULL, \"MIC1P\" },\n\t{ \"Mic Diff\", NULL, \"MIC1N\" },\n\t{ \"Mic 1\", NULL, \"Mic Diff\" },\n\t{ \"Mic 2\", NULL, \"MIC2P\" },\n\t{ \"Mic Diff\", NULL, \"MIC2N\" },\n\t{ \"Mic 2\", NULL, \"Mic Diff\" },\n\n\t{ \"Line In\", NULL, \"LLINEIN\" },\n\t{ \"Line In\", NULL, \"RLINEIN\" },\n\n\t{ \"Mic\", \"Stereo Capture Switch\", \"Mic 1\" },\n\t{ \"Mic\", \"Stereo Capture Switch\", \"Mic 2\" },\n\t{ \"Headphones Source\", \"Mic 1\", \"Mic\" },\n\t{ \"Headphones Source\", \"Mic 2\", \"Mic\" },\n\t{ \"Capture Source\", \"Mic 1\", \"Mic\" },\n\t{ \"Capture Source\", \"Mic 2\", \"Mic\" },\n\n\t{ \"Capture Source\", \"Line In\", \"Line In\" },\n\t{ \"Capture Source\", \"Mic 1\", \"Mic 1\" },\n\t{ \"Capture Source\", \"Mic 2\", \"Mic 2\" },\n\t{ \"ADC\", NULL, \"Capture Source\" },\n\n\t{ \"Line In Bypass\", NULL, \"Line In\" },\n\n\t{ \"Headphones Source\", \"Mic 1\", \"Mic 1\" },\n\t{ \"Headphones Source\", \"Mic 2\", \"Mic 2\" },\n\t{ \"Headphones Source\", \"Line In\", \"Line In Bypass\" },\n\t{ \"Headphones Source\", \"PCM\", \"Headphones Playback\" },\n\t{ \"HP Out\", NULL, \"Headphones Source\" },\n\n\t{ \"LHPOUT\", NULL, \"HP Out\" },\n\t{ \"RHPOUT\", NULL, \"HP Out\" },\n\t{ \"Line Out\", \"Switch\", \"HP Out\" },\n\n\t{ \"LOUT\", NULL, \"Line Out\" },\n\t{ \"ROUT\", NULL, \"Line Out\" },\n\t{ \"BTL Out\", \"Switch\", \"Line Out\" },\n\n\t{ \"BTLP\", NULL, \"BTL Out\"},\n\t{ \"BTLN\", NULL, \"BTL Out\"},\n\n\t{ \"PCM Playback\", \"Volume\", \"DAC\" },\n\t{ \"Headphones Playback\", \"Volume\", \"PCM Playback\" },\n\n\t{ \"SYSCLK\", NULL, \"DAC\" },\n};\n\nstatic void jz4760_codec_codec_init_regs(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\tstruct regmap *regmap = jz_codec->regmap;\n\n\t \n\tregcache_cache_only(regmap, true);\n\n\t \n\tregmap_set_bits(regmap, JZ4760_CODEC_REG_CR1, REG_CR1_OUTSEL_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_CR3,\n\t\t\t  BIT(REG_CR3_MICSTEREO_OFFSET));\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_CR3,\n\t\t\t  REG_CR3_ADC_INSEL_MASK);\n\n\t \n\tregmap_set_bits(regmap, JZ4760_CODEC_REG_AICR,\n\t\t\tREG_AICR_ADC_SERIAL | REG_AICR_ADC_I2S |\n\t\t\tREG_AICR_DAC_SERIAL | REG_AICR_DAC_I2S);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_ICR, REG_ICR_INT_FORM_MASK);\n\tregmap_update_bits(regmap, JZ4760_CODEC_REG_ICR, REG_ICR_ALL_MASK,\n\t\t\t   REG_ICR_JACK_MASK | REG_ICR_RUP_MASK |\n\t\t\t   REG_ICR_RDO_MASK  | REG_ICR_GUP_MASK |\n\t\t\t   REG_ICR_GDO_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_CCR1, REG_CCR1_CRYSTAL_MASK);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_CR1, REG_CR1_HP_LOAD);\n\n\t \n\tregmap_set_bits(jz_codec->regmap, JZ4760_CODEC_REG_CR2,\n\t\t\tREG_CR2_DAC_NOMAD);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_AGC1, REG_AGC1_EN);\n\n\t \n\tregmap_clear_bits(regmap, JZ4760_CODEC_REG_GCR5,\n\t\t\t  REG_GCR_RL);\n\n\t \n\tregcache_cache_only(regmap, false);\n\tregcache_sync(regmap);\n}\n\nstatic int jz4760_codec_codec_probe(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\n\tclk_prepare_enable(jz_codec->clk);\n\n\tjz4760_codec_codec_init_regs(codec);\n\n\treturn 0;\n}\n\nstatic void jz4760_codec_codec_remove(struct snd_soc_component *codec)\n{\n\tstruct jz_codec *jz_codec = snd_soc_component_get_drvdata(codec);\n\n\tclk_disable_unprepare(jz_codec->clk);\n}\n\nstatic const struct snd_soc_component_driver jz4760_codec_soc_codec_dev = {\n\t.probe\t\t\t= jz4760_codec_codec_probe,\n\t.remove\t\t\t= jz4760_codec_codec_remove,\n\t.set_bias_level\t\t= jz4760_codec_set_bias_level,\n\t.controls\t\t= jz4760_codec_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(jz4760_codec_snd_controls),\n\t.dapm_widgets\t\t= jz4760_codec_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(jz4760_codec_dapm_widgets),\n\t.dapm_routes\t\t= jz4760_codec_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(jz4760_codec_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.use_pmdown_time\t= 1,\n};\n\nstatic const unsigned int jz4760_codec_sample_rates[] = {\n\t96000, 48000, 44100, 32000,\n\t24000, 22050, 16000, 12000,\n\t11025, 9600, 8000,\n};\n\nstatic int jz4760_codec_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct jz_codec *codec = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int rate, bit_width;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_S16_LE:\n\t\tbit_width = 0;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S18_3LE:\n\t\tbit_width = 1;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S20_3LE:\n\t\tbit_width = 2;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_S24_3LE:\n\t\tbit_width = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfor (rate = 0; rate < ARRAY_SIZE(jz4760_codec_sample_rates); rate++) {\n\t\tif (jz4760_codec_sample_rates[rate] == params_rate(params))\n\t\t\tbreak;\n\t}\n\n\tif (rate == ARRAY_SIZE(jz4760_codec_sample_rates))\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(codec->regmap, JZ4760_CODEC_REG_AICR,\n\t\t\t\t   REG_AICR_DAC_ADWL_MASK,\n\t\t\t\t   FIELD_PREP(REG_AICR_DAC_ADWL_MASK, bit_width));\n\t\tregmap_update_bits(codec->regmap, JZ4760_CODEC_REG_CCR2,\n\t\t\t\t   REG_CCR2_DAC_FREQ_MASK,\n\t\t\t\t   FIELD_PREP(REG_CCR2_DAC_FREQ_MASK, rate));\n\t} else {\n\t\tregmap_update_bits(codec->regmap, JZ4760_CODEC_REG_AICR,\n\t\t\t\t   REG_AICR_ADC_ADWL_MASK,\n\t\t\t\t   FIELD_PREP(REG_AICR_ADC_ADWL_MASK, bit_width));\n\t\tregmap_update_bits(codec->regmap, JZ4760_CODEC_REG_CCR2,\n\t\t\t\t   REG_CCR2_ADC_FREQ_MASK,\n\t\t\t\t   FIELD_PREP(REG_CCR2_ADC_FREQ_MASK, rate));\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops jz4760_codec_dai_ops = {\n\t.startup\t= jz4760_codec_startup,\n\t.shutdown\t= jz4760_codec_shutdown,\n\t.hw_params\t= jz4760_codec_hw_params,\n\t.trigger\t= jz4760_codec_pcm_trigger,\n\t.mute_stream\t= jz4760_codec_mute_stream,\n\t.no_capture_mute = 1,\n};\n\n#define JZ_CODEC_FORMATS (SNDRV_PCM_FMTBIT_S16_LE  | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\t  SNDRV_PCM_FMTBIT_S24_3LE)\n\nstatic struct snd_soc_dai_driver jz4760_codec_dai = {\n\t.name = \"jz4760-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_CODEC_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = JZ_CODEC_FORMATS,\n\t},\n\t.ops = &jz4760_codec_dai_ops,\n};\n\nstatic bool jz4760_codec_volatile(struct device *dev, unsigned int reg)\n{\n\treturn reg == JZ4760_CODEC_REG_SR || reg == JZ4760_CODEC_REG_IFR;\n}\n\nstatic bool jz4760_codec_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase JZ4760_CODEC_REG_SR:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int jz4760_codec_io_wait(struct jz_codec *codec)\n{\n\tu32 reg;\n\n\treturn readl_poll_timeout(codec->base + ICDC_RGADW_OFFSET, reg,\n\t\t\t\t  !(reg & ICDC_RGADW_RGWR),\n\t\t\t\t  1000, 1 * USEC_PER_SEC);\n}\n\nstatic int jz4760_codec_reg_read(void *context, unsigned int reg,\n\t\t\t\t unsigned int *val)\n{\n\tstruct jz_codec *codec = context;\n\tunsigned int i;\n\tu32 tmp;\n\tint ret;\n\n\tret = jz4760_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = readl(codec->base + ICDC_RGADW_OFFSET);\n\ttmp &= ~ICDC_RGADW_RGADDR_MASK;\n\ttmp |= FIELD_PREP(ICDC_RGADW_RGADDR_MASK, reg);\n\twritel(tmp, codec->base + ICDC_RGADW_OFFSET);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\t*val = readl(codec->base + ICDC_RGDATA_OFFSET) &\n\t\t\tICDC_RGDATA_RGDOUT_MASK;\n\n\treturn 0;\n}\n\nstatic int jz4760_codec_reg_write(void *context, unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\tstruct jz_codec *codec = context;\n\tint ret;\n\n\tret = jz4760_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(ICDC_RGADW_RGWR | FIELD_PREP(ICDC_RGADW_RGADDR_MASK, reg) | val,\n\t       codec->base + ICDC_RGADW_OFFSET);\n\n\tret = jz4760_codec_io_wait(codec);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const u8 jz4760_codec_reg_defaults[] = {\n\t0x00, 0xFC, 0x1B, 0x20, 0x00, 0x80, 0x00, 0x00,\n\t0xFF, 0x1F, 0x3F, 0x00, 0x06, 0x06, 0x06, 0x06,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x07, 0x44,\n\t0x1F, 0x00, 0x00, 0x00\n};\n\nstatic struct regmap_config jz4760_codec_regmap_config = {\n\t.reg_bits = 7,\n\t.val_bits = 8,\n\n\t.max_register = JZ4760_CODEC_REG_MIX2,\n\t.volatile_reg = jz4760_codec_volatile,\n\t.writeable_reg = jz4760_codec_writeable,\n\n\t.reg_read = jz4760_codec_reg_read,\n\t.reg_write = jz4760_codec_reg_write,\n\n\t.reg_defaults_raw = jz4760_codec_reg_defaults,\n\t.num_reg_defaults_raw = ARRAY_SIZE(jz4760_codec_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n};\n\nstatic int jz4760_codec_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct jz_codec *codec;\n\tint ret;\n\n\tcodec = devm_kzalloc(dev, sizeof(*codec), GFP_KERNEL);\n\tif (!codec)\n\t\treturn -ENOMEM;\n\n\tcodec->dev = dev;\n\n\tcodec->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(codec->base))\n\t\treturn PTR_ERR(codec->base);\n\n\tcodec->regmap = devm_regmap_init(dev, NULL, codec,\n\t\t\t\t\t&jz4760_codec_regmap_config);\n\tif (IS_ERR(codec->regmap))\n\t\treturn PTR_ERR(codec->regmap);\n\n\tcodec->clk = devm_clk_get(dev, \"aic\");\n\tif (IS_ERR(codec->clk))\n\t\treturn PTR_ERR(codec->clk);\n\n\tplatform_set_drvdata(pdev, codec);\n\n\tret = devm_snd_soc_register_component(dev, &jz4760_codec_soc_codec_dev,\n\t\t\t\t\t      &jz4760_codec_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register codec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id jz4760_codec_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4760-codec\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, jz4760_codec_of_matches);\n\nstatic struct platform_driver jz4760_codec_driver = {\n\t.probe\t\t\t= jz4760_codec_probe,\n\t.driver\t\t\t= {\n\t\t.name\t\t= \"jz4760-codec\",\n\t\t.of_match_table = jz4760_codec_of_matches,\n\t},\n};\nmodule_platform_driver(jz4760_codec_driver);\n\nMODULE_DESCRIPTION(\"JZ4760 SoC internal codec driver\");\nMODULE_AUTHOR(\"Christophe Branchereau <cbranchereau@gmail.com>\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}