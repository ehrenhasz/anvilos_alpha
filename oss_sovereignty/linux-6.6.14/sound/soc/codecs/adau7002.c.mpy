{
  "module_name": "adau7002.c",
  "hash_id": "0ebb3847e96aae1722d25b135133094bc2e6ad418c4009ccc18423b65bc07c66",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adau7002.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <sound/soc.h>\n\nstruct adau7002_priv {\n\tint wakeup_delay;\n};\n\nstatic int adau7002_aif_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct adau7002_priv *adau7002 =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tif (adau7002->wakeup_delay)\n\t\t\tmsleep(adau7002->wakeup_delay);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int adau7002_component_probe(struct snd_soc_component *component)\n{\n\tstruct adau7002_priv *adau7002;\n\n\tadau7002 = devm_kzalloc(component->dev, sizeof(*adau7002),\n\t\t\t\tGFP_KERNEL);\n\tif (!adau7002)\n\t\treturn -ENOMEM;\n\n\tdevice_property_read_u32(component->dev, \"wakeup-delay-ms\",\n\t\t\t\t &adau7002->wakeup_delay);\n\n\tsnd_soc_component_set_drvdata(component, adau7002);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget adau7002_widgets[] = {\n\tSND_SOC_DAPM_AIF_OUT_E(\"ADAU AIF\", \"Capture\", 0,\n\t\t\t       SND_SOC_NOPM, 0, 0, adau7002_aif_event,\n\t\t\t       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_INPUT(\"PDM_DAT\"),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"IOVDD\", 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route adau7002_routes[] = {\n\t{ \"ADAU AIF\", NULL, \"PDM_DAT\"},\n\t{ \"Capture\", NULL, \"PDM_DAT\" },\n\t{ \"Capture\", NULL, \"IOVDD\" },\n};\n\nstatic struct snd_soc_dai_driver adau7002_dai = {\n\t.name = \"adau7002-hifi\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE |\n\t\t\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE,\n\t\t.sig_bits = 20,\n\t},\n};\n\nstatic const struct snd_soc_component_driver adau7002_component_driver = {\n\t.probe\t\t\t= adau7002_component_probe,\n\t.dapm_widgets\t\t= adau7002_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adau7002_widgets),\n\t.dapm_routes\t\t= adau7002_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(adau7002_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int adau7002_probe(struct platform_device *pdev)\n{\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t&adau7002_component_driver,\n\t\t\t&adau7002_dai, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id adau7002_dt_ids[] = {\n\t{ .compatible = \"adi,adau7002\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adau7002_dt_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id adau7002_acpi_match[] = {\n\t{ \"ADAU7002\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, adau7002_acpi_match);\n#endif\n\nstatic struct platform_driver adau7002_driver = {\n\t.driver = {\n\t\t.name = \"adau7002\",\n\t\t.of_match_table\t= of_match_ptr(adau7002_dt_ids),\n\t\t.acpi_match_table = ACPI_PTR(adau7002_acpi_match),\n\t},\n\t.probe = adau7002_probe,\n};\nmodule_platform_driver(adau7002_driver);\n\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_DESCRIPTION(\"ADAU7002 Stereo PDM-to-I2S/TDM Converter driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}