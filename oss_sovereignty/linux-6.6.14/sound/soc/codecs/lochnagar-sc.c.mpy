{
  "module_name": "lochnagar-sc.c",
  "hash_id": "182138efd691ea9a6217ca72aa75fc11310d96c17a4e7457879ce18b0a23e5ab",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/lochnagar-sc.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <sound/soc.h>\n\n#include <linux/mfd/lochnagar.h>\n#include <linux/mfd/lochnagar1_regs.h>\n#include <linux/mfd/lochnagar2_regs.h>\n\nstruct lochnagar_sc_priv {\n\tstruct clk *mclk;\n};\n\nstatic const struct snd_soc_dapm_widget lochnagar_sc_widgets[] = {\n\tSND_SOC_DAPM_LINE(\"Line Jack\", NULL),\n\tSND_SOC_DAPM_LINE(\"USB Audio\", NULL),\n};\n\nstatic const struct snd_soc_dapm_route lochnagar_sc_routes[] = {\n\t{ \"Line Jack\", NULL, \"AIF1 Playback\" },\n\t{ \"AIF1 Capture\", NULL, \"Line Jack\" },\n\n\t{ \"USB Audio\", NULL, \"USB1 Playback\" },\n\t{ \"USB Audio\", NULL, \"USB2 Playback\" },\n\t{ \"USB1 Capture\", NULL, \"USB Audio\" },\n\t{ \"USB2 Capture\", NULL, \"USB Audio\" },\n};\n\nstatic const unsigned int lochnagar_sc_chan_vals[] = {\n\t4, 8,\n};\n\nstatic const struct snd_pcm_hw_constraint_list lochnagar_sc_chan_constraint = {\n\t.count = ARRAY_SIZE(lochnagar_sc_chan_vals),\n\t.list = lochnagar_sc_chan_vals,\n};\n\nstatic const unsigned int lochnagar_sc_rate_vals[] = {\n\t8000, 16000, 24000, 32000, 48000, 96000, 192000,\n\t22050, 44100, 88200, 176400,\n};\n\nstatic const struct snd_pcm_hw_constraint_list lochnagar_sc_rate_constraint = {\n\t.count = ARRAY_SIZE(lochnagar_sc_rate_vals),\n\t.list = lochnagar_sc_rate_vals,\n};\n\nstatic int lochnagar_sc_hw_rule_rate(struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_pcm_hw_rule *rule)\n{\n\tstruct snd_interval range = {\n\t\t.min = 8000,\n\t\t.max = 24576000 / hw_param_interval(params, rule->deps[0])->max,\n\t};\n\n\treturn snd_interval_refine(hw_param_interval(params, rule->var),\n\t\t\t\t   &range);\n}\n\nstatic int lochnagar_sc_startup(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct lochnagar_sc_priv *priv = snd_soc_component_get_drvdata(comp);\n\tint ret;\n\n\tret = snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t &lochnagar_sc_rate_constraint);\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_rule_add(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t   lochnagar_sc_hw_rule_rate, priv,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_FRAME_BITS, -1);\n}\n\nstatic int lochnagar_sc_line_startup(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct lochnagar_sc_priv *priv = snd_soc_component_get_drvdata(comp);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->mclk);\n\tif (ret < 0) {\n\t\tdev_err(dai->dev, \"Failed to enable MCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = lochnagar_sc_startup(substream, dai);\n\tif (ret)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t  &lochnagar_sc_chan_constraint);\n}\n\nstatic void lochnagar_sc_line_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *comp = dai->component;\n\tstruct lochnagar_sc_priv *priv = snd_soc_component_get_drvdata(comp);\n\n\tclk_disable_unprepare(priv->mclk);\n}\n\nstatic int lochnagar_sc_check_fmt(struct snd_soc_dai *dai, unsigned int fmt,\n\t\t\t\t  unsigned int tar)\n{\n\ttar |= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF;\n\n\tif ((fmt & ~SND_SOC_DAIFMT_CLOCK_MASK) != tar)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int lochnagar_sc_set_line_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\treturn lochnagar_sc_check_fmt(dai, fmt, SND_SOC_DAIFMT_CBS_CFS);\n}\n\nstatic int lochnagar_sc_set_usb_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\treturn lochnagar_sc_check_fmt(dai, fmt, SND_SOC_DAIFMT_CBM_CFM);\n}\n\nstatic const struct snd_soc_dai_ops lochnagar_sc_line_ops = {\n\t.startup = lochnagar_sc_line_startup,\n\t.shutdown = lochnagar_sc_line_shutdown,\n\t.set_fmt = lochnagar_sc_set_line_fmt,\n};\n\nstatic const struct snd_soc_dai_ops lochnagar_sc_usb_ops = {\n\t.startup = lochnagar_sc_startup,\n\t.set_fmt = lochnagar_sc_set_usb_fmt,\n};\n\nstatic struct snd_soc_dai_driver lochnagar_sc_dai[] = {\n\t{\n\t\t.name = \"lochnagar-line\",\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF1 Playback\",\n\t\t\t.channels_min = 4,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"AIF1 Capture\",\n\t\t\t.channels_min = 4,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &lochnagar_sc_line_ops,\n\t\t.symmetric_rate = true,\n\t\t.symmetric_sample_bits = true,\n\t},\n\t{\n\t\t.name = \"lochnagar-usb1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"USB1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"USB1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &lochnagar_sc_usb_ops,\n\t\t.symmetric_rate = true,\n\t\t.symmetric_sample_bits = true,\n\t},\n\t{\n\t\t.name = \"lochnagar-usb2\",\n\t\t.playback = {\n\t\t\t.stream_name = \"USB2 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"USB2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 8,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = &lochnagar_sc_usb_ops,\n\t\t.symmetric_rate = true,\n\t\t.symmetric_sample_bits = true,\n\t},\n};\n\nstatic const struct snd_soc_component_driver lochnagar_sc_driver = {\n\t.dapm_widgets = lochnagar_sc_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(lochnagar_sc_widgets),\n\t.dapm_routes = lochnagar_sc_routes,\n\t.num_dapm_routes = ARRAY_SIZE(lochnagar_sc_routes),\n\n\t.endianness = 1,\n};\n\nstatic int lochnagar_sc_probe(struct platform_device *pdev)\n{\n\tstruct lochnagar_sc_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->mclk = devm_clk_get(&pdev->dev, \"mclk\");\n\tif (IS_ERR(priv->mclk)) {\n\t\tret = PTR_ERR(priv->mclk);\n\t\tdev_err(&pdev->dev, \"Failed to get MCLK: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn devm_snd_soc_register_component(&pdev->dev,\n\t\t\t\t\t       &lochnagar_sc_driver,\n\t\t\t\t\t       lochnagar_sc_dai,\n\t\t\t\t\t       ARRAY_SIZE(lochnagar_sc_dai));\n}\n\nstatic const struct of_device_id lochnagar_of_match[] = {\n\t{ .compatible = \"cirrus,lochnagar2-soundcard\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, lochnagar_of_match);\n\nstatic struct platform_driver lochnagar_sc_codec_driver = {\n\t.driver = {\n\t\t.name = \"lochnagar-soundcard\",\n\t\t.of_match_table = lochnagar_of_match,\n\t},\n\n\t.probe = lochnagar_sc_probe,\n};\nmodule_platform_driver(lochnagar_sc_codec_driver);\n\nMODULE_DESCRIPTION(\"ASoC Lochnagar Sound Card Driver\");\nMODULE_AUTHOR(\"Piotr Stankiewicz <piotrs@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:lochnagar-soundcard\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}