{
  "module_name": "wm2000.c",
  "hash_id": "ef22a63839023d5f77866b6639e4dfc8d828e5b5d7d1bc9fdf4ec7f9b2499b1c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm2000.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/firmware.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/debugfs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/wm2000.h>\n\n#include \"wm2000.h\"\n\n#define WM2000_NUM_SUPPLIES 3\n\nstatic const char *wm2000_supplies[WM2000_NUM_SUPPLIES] = {\n\t\"SPKVDD\",\n\t\"DBVDD\",\n\t\"DCVDD\",\n};\n\nenum wm2000_anc_mode {\n\tANC_ACTIVE = 0,\n\tANC_BYPASS = 1,\n\tANC_STANDBY = 2,\n\tANC_OFF = 3,\n};\n\nstruct wm2000_priv {\n\tstruct i2c_client *i2c;\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\n\tstruct regulator_bulk_data supplies[WM2000_NUM_SUPPLIES];\n\n\tenum wm2000_anc_mode anc_mode;\n\n\tunsigned int anc_active:1;\n\tunsigned int anc_eng_ena:1;\n\tunsigned int spk_ena:1;\n\n\tunsigned int speech_clarity:1;\n\n\tint anc_download_size;\n\tchar *anc_download;\n\n\tstruct mutex lock;\n};\n\nstatic int wm2000_write(struct i2c_client *i2c, unsigned int reg,\n\t\t\tunsigned int value)\n{\n\tstruct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);\n\treturn regmap_write(wm2000->regmap, reg, value);\n}\n\nstatic void wm2000_reset(struct wm2000_priv *wm2000)\n{\n\tstruct i2c_client *i2c = wm2000->i2c;\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\n\twm2000_write(i2c, WM2000_REG_ID1, 0);\n\n\twm2000->anc_mode = ANC_OFF;\n}\n\nstatic int wm2000_poll_bit(struct i2c_client *i2c,\n\t\t\t   unsigned int reg, u8 mask)\n{\n\tstruct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);\n\tint timeout = 4000;\n\tunsigned int val;\n\n\tregmap_read(wm2000->regmap, reg, &val);\n\n\twhile (!(val & mask) && --timeout) {\n\t\tmsleep(1);\n\t\tregmap_read(wm2000->regmap, reg, &val);\n\t}\n\n\tif (timeout == 0)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic int wm2000_power_up(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\tunsigned long rate;\n\tunsigned int val;\n\tint ret;\n\n\tif (WARN_ON(wm2000->anc_mode != ANC_OFF))\n\t\treturn -EINVAL;\n\n\tdev_dbg(&i2c->dev, \"Beginning power up\\n\");\n\n\tret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trate = clk_get_rate(wm2000->mclk);\n\tif (rate <= 13500000) {\n\t\tdev_dbg(&i2c->dev, \"Disabling MCLK divider\\n\");\n\t\twm2000_write(i2c, WM2000_REG_SYS_CTL2,\n\t\t\t     WM2000_MCLK_DIV2_ENA_CLR);\n\t} else {\n\t\tdev_dbg(&i2c->dev, \"Enabling MCLK divider\\n\");\n\t\twm2000_write(i2c, WM2000_REG_SYS_CTL2,\n\t\t\t     WM2000_MCLK_DIV2_ENA_SET);\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_SET);\n\n\t \n\tif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\n\t\t\t     WM2000_ANC_ENG_IDLE)) {\n\t\tdev_err(&i2c->dev, \"ANC engine failed to reset\\n\");\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_BOOT_COMPLETE)) {\n\t\tdev_err(&i2c->dev, \"ANC engine failed to initialise\\n\");\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\n\n\t \n\tdev_dbg(&i2c->dev, \"Downloading %d bytes\\n\",\n\t\twm2000->anc_download_size - 2);\n\n\tret = i2c_master_send(i2c, wm2000->anc_download,\n\t\t\t      wm2000->anc_download_size);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"i2c_transfer() failed: %d\\n\", ret);\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn ret;\n\t}\n\tif (ret != wm2000->anc_download_size) {\n\t\tdev_err(&i2c->dev, \"i2c_transfer() failed, %d != %d\\n\",\n\t\t\tret, wm2000->anc_download_size);\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(&i2c->dev, \"Download complete\\n\");\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);\n\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_MOUSE_ENABLE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_MOUSE_ENABLE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE);\n\t}\n\n\tret = regmap_read(wm2000->regmap, WM2000_REG_SPEECH_CLARITY, &val);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Unable to read Speech Clarity: %d\\n\", ret);\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn ret;\n\t}\n\tif (wm2000->speech_clarity)\n\t\tval |= WM2000_SPEECH_CLARITY;\n\telse\n\t\tval &= ~WM2000_SPEECH_CLARITY;\n\twm2000_write(i2c, WM2000_REG_SPEECH_CLARITY, val);\n\n\twm2000_write(i2c, WM2000_REG_SYS_START0, 0x33);\n\twm2000_write(i2c, WM2000_REG_SYS_START1, 0x02);\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_MOUSE_ACTIVE)) {\n\t\tdev_err(&i2c->dev, \"Timed out waiting for device\\n\");\n\t\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(&i2c->dev, \"ANC active\\n\");\n\tif (analogue)\n\t\tdev_dbg(&i2c->dev, \"Analogue active\\n\");\n\twm2000->anc_mode = ANC_ACTIVE;\n\n\treturn 0;\n}\n\nstatic int wm2000_power_down(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_POWER_DOWN);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_POWER_DOWN);\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_POWER_DOWN_COMPLETE)) {\n\t\tdev_err(&i2c->dev, \"Timeout waiting for ANC power down\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\n\t\t\t     WM2000_ANC_ENG_IDLE)) {\n\t\tdev_err(&i2c->dev, \"Timeout waiting for ANC engine idle\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\n\tdev_dbg(&i2c->dev, \"powered off\\n\");\n\twm2000->anc_mode = ANC_OFF;\n\n\treturn 0;\n}\n\nstatic int wm2000_enter_bypass(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\n\tif (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))\n\t\treturn -EINVAL;\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_BYPASS_ENTRY);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_BYPASS_ENTRY);\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_ANC_DISABLED)) {\n\t\tdev_err(&i2c->dev, \"Timeout waiting for ANC disable\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\n\t\t\t     WM2000_ANC_ENG_IDLE)) {\n\t\tdev_err(&i2c->dev, \"Timeout waiting for ANC engine idle\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\n\n\twm2000->anc_mode = ANC_BYPASS;\n\tdev_dbg(&i2c->dev, \"bypass enabled\\n\");\n\n\treturn 0;\n}\n\nstatic int wm2000_exit_bypass(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\n\tif (WARN_ON(wm2000->anc_mode != ANC_BYPASS))\n\t\treturn -EINVAL;\n\t\n\twm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_MOUSE_ENABLE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_MOUSE_ENABLE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE);\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_MOUSE_ACTIVE)) {\n\t\tdev_err(&i2c->dev, \"Timed out waiting for MOUSE\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twm2000->anc_mode = ANC_ACTIVE;\n\tdev_dbg(&i2c->dev, \"MOUSE active\\n\");\n\n\treturn 0;\n}\n\nstatic int wm2000_enter_standby(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\n\tif (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))\n\t\treturn -EINVAL;\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);\n\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_STANDBY_ENTRY);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_STANDBY_ENTRY);\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_ANC_DISABLED)) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Timed out waiting for ANC disable after 1ms\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT, WM2000_ANC_ENG_IDLE)) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Timed out waiting for standby\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\n\n\twm2000->anc_mode = ANC_STANDBY;\n\tdev_dbg(&i2c->dev, \"standby\\n\");\n\tif (analogue)\n\t\tdev_dbg(&i2c->dev, \"Analogue disabled\\n\");\n\n\treturn 0;\n}\n\nstatic int wm2000_exit_standby(struct i2c_client *i2c, int analogue)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\n\n\tif (WARN_ON(wm2000->anc_mode != ANC_STANDBY))\n\t\treturn -EINVAL;\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\n\n\tif (analogue) {\n\t\twm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);\n\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_ANA_SEQ_INCLUDE |\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_MOUSE_ENABLE);\n\t} else {\n\t\twm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\n\t\t\t     WM2000_MODE_THERMAL_ENABLE |\n\t\t\t     WM2000_MODE_MOUSE_ENABLE);\n\t}\n\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\n\twm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\n\n\tif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\n\t\t\t     WM2000_STATUS_MOUSE_ACTIVE)) {\n\t\tdev_err(&i2c->dev, \"Timed out waiting for MOUSE\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\twm2000->anc_mode = ANC_ACTIVE;\n\tdev_dbg(&i2c->dev, \"MOUSE active\\n\");\n\tif (analogue)\n\t\tdev_dbg(&i2c->dev, \"Analogue enabled\\n\");\n\n\treturn 0;\n}\n\ntypedef int (*wm2000_mode_fn)(struct i2c_client *i2c, int analogue);\n\nstatic struct {\n\tenum wm2000_anc_mode source;\n\tenum wm2000_anc_mode dest;\n\tint analogue;\n\twm2000_mode_fn step[2];\n} anc_transitions[] = {\n\t{\n\t\t.source = ANC_OFF,\n\t\t.dest = ANC_ACTIVE,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_power_up,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_OFF,\n\t\t.dest = ANC_STANDBY,\n\t\t.step = {\n\t\t\twm2000_power_up,\n\t\t\twm2000_enter_standby,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_OFF,\n\t\t.dest = ANC_BYPASS,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_power_up,\n\t\t\twm2000_enter_bypass,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_ACTIVE,\n\t\t.dest = ANC_BYPASS,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_enter_bypass,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_ACTIVE,\n\t\t.dest = ANC_STANDBY,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_enter_standby,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_ACTIVE,\n\t\t.dest = ANC_OFF,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_power_down,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_BYPASS,\n\t\t.dest = ANC_ACTIVE,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_exit_bypass,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_BYPASS,\n\t\t.dest = ANC_STANDBY,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_exit_bypass,\n\t\t\twm2000_enter_standby,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_BYPASS,\n\t\t.dest = ANC_OFF,\n\t\t.step = {\n\t\t\twm2000_exit_bypass,\n\t\t\twm2000_power_down,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_STANDBY,\n\t\t.dest = ANC_ACTIVE,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_exit_standby,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_STANDBY,\n\t\t.dest = ANC_BYPASS,\n\t\t.analogue = 1,\n\t\t.step = {\n\t\t\twm2000_exit_standby,\n\t\t\twm2000_enter_bypass,\n\t\t},\n\t},\n\t{\n\t\t.source = ANC_STANDBY,\n\t\t.dest = ANC_OFF,\n\t\t.step = {\n\t\t\twm2000_exit_standby,\n\t\t\twm2000_power_down,\n\t\t},\n\t},\n};\n\nstatic int wm2000_anc_transition(struct wm2000_priv *wm2000,\n\t\t\t\t enum wm2000_anc_mode mode)\n{\n\tstruct i2c_client *i2c = wm2000->i2c;\n\tint i, j;\n\tint ret = 0;\n\n\tif (wm2000->anc_mode == mode)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(anc_transitions); i++)\n\t\tif (anc_transitions[i].source == wm2000->anc_mode &&\n\t\t    anc_transitions[i].dest == mode)\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(anc_transitions)) {\n\t\tdev_err(&i2c->dev, \"No transition for %d->%d\\n\",\n\t\t\twm2000->anc_mode, mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (anc_transitions[i].source == ANC_OFF) {\n\t\tret = clk_prepare_enable(wm2000->mclk);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&i2c->dev, \"Failed to enable MCLK: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (j = 0; j < ARRAY_SIZE(anc_transitions[j].step); j++) {\n\t\tif (!anc_transitions[i].step[j])\n\t\t\tbreak;\n\t\tret = anc_transitions[i].step[j](i2c,\n\t\t\t\t\t\t anc_transitions[i].analogue);\n\t\tif (ret != 0)\n\t\t\tbreak;\n\t}\n\n\tif (anc_transitions[i].dest == ANC_OFF)\n\t\tclk_disable_unprepare(wm2000->mclk);\n\n\treturn ret;\n}\n\nstatic int wm2000_anc_set_mode(struct wm2000_priv *wm2000)\n{\n\tstruct i2c_client *i2c = wm2000->i2c;\n\tenum wm2000_anc_mode mode;\n\n\tif (wm2000->anc_eng_ena && wm2000->spk_ena)\n\t\tif (wm2000->anc_active)\n\t\t\tmode = ANC_ACTIVE;\n\t\telse\n\t\t\tmode = ANC_BYPASS;\n\telse\n\t\tmode = ANC_STANDBY;\n\n\tdev_dbg(&i2c->dev, \"Set mode %d (enabled %d, mute %d, active %d)\\n\",\n\t\tmode, wm2000->anc_eng_ena, !wm2000->spk_ena,\n\t\twm2000->anc_active);\n\n\treturn wm2000_anc_transition(wm2000, mode);\n}\n\nstatic int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\tucontrol->value.integer.value[0] = wm2000->anc_active;\n\n\treturn 0;\n}\n\nstatic int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\tunsigned int anc_active = ucontrol->value.integer.value[0];\n\tint ret;\n\n\tif (anc_active > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wm2000->lock);\n\n\twm2000->anc_active = anc_active;\n\n\tret = wm2000_anc_set_mode(wm2000);\n\n\tmutex_unlock(&wm2000->lock);\n\n\treturn ret;\n}\n\nstatic int wm2000_speaker_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\tucontrol->value.integer.value[0] = wm2000->spk_ena;\n\n\treturn 0;\n}\n\nstatic int wm2000_speaker_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\tunsigned int val = ucontrol->value.integer.value[0];\n\tint ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wm2000->lock);\n\n\twm2000->spk_ena = val;\n\n\tret = wm2000_anc_set_mode(wm2000);\n\n\tmutex_unlock(&wm2000->lock);\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new wm2000_controls[] = {\n\tSOC_SINGLE(\"ANC Volume\", WM2000_REG_ANC_GAIN_CTRL, 0, 255, 0),\n\tSOC_SINGLE_BOOL_EXT(\"WM2000 ANC Switch\", 0,\n\t\t\t    wm2000_anc_mode_get,\n\t\t\t    wm2000_anc_mode_put),\n\tSOC_SINGLE_BOOL_EXT(\"WM2000 Switch\", 0,\n\t\t\t    wm2000_speaker_get,\n\t\t\t    wm2000_speaker_put),\n};\n\nstatic int wm2000_anc_power_event(struct snd_soc_dapm_widget *w,\n\t\t\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\tint ret;\n\n\tmutex_lock(&wm2000->lock);\n\n\tif (SND_SOC_DAPM_EVENT_ON(event))\n\t\twm2000->anc_eng_ena = 1;\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event))\n\t\twm2000->anc_eng_ena = 0;\n\n\tret = wm2000_anc_set_mode(wm2000);\n\n\tmutex_unlock(&wm2000->lock);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dapm_widget wm2000_dapm_widgets[] = {\n \nSND_SOC_DAPM_OUTPUT(\"SPKN\"),\nSND_SOC_DAPM_OUTPUT(\"SPKP\"),\n\nSND_SOC_DAPM_INPUT(\"LINN\"),\nSND_SOC_DAPM_INPUT(\"LINP\"),\n\nSND_SOC_DAPM_PGA_E(\"ANC Engine\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t   wm2000_anc_power_event,\n\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n};\n\n \nstatic const struct snd_soc_dapm_route wm2000_audio_map[] = {\n\t{ \"SPKN\", NULL, \"ANC Engine\" },\n\t{ \"SPKP\", NULL, \"ANC Engine\" },\n\t{ \"ANC Engine\", NULL, \"LINN\" },\n\t{ \"ANC Engine\", NULL, \"LINP\" },\n};\n\n#ifdef CONFIG_PM\nstatic int wm2000_suspend(struct snd_soc_component *component)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\treturn wm2000_anc_transition(wm2000, ANC_OFF);\n}\n\nstatic int wm2000_resume(struct snd_soc_component *component)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\treturn wm2000_anc_set_mode(wm2000);\n}\n#else\n#define wm2000_suspend NULL\n#define wm2000_resume NULL\n#endif\n\nstatic bool wm2000_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM2000_REG_SYS_START:\n\tcase WM2000_REG_ANC_GAIN_CTRL:\n\tcase WM2000_REG_MSE_TH1:\n\tcase WM2000_REG_MSE_TH2:\n\tcase WM2000_REG_SPEECH_CLARITY:\n\tcase WM2000_REG_SYS_WATCHDOG:\n\tcase WM2000_REG_ANA_VMID_PD_TIME:\n\tcase WM2000_REG_ANA_VMID_PU_TIME:\n\tcase WM2000_REG_CAT_FLTR_INDX:\n\tcase WM2000_REG_CAT_GAIN_0:\n\tcase WM2000_REG_SYS_STATUS:\n\tcase WM2000_REG_SYS_MODE_CNTRL:\n\tcase WM2000_REG_SYS_START0:\n\tcase WM2000_REG_SYS_START1:\n\tcase WM2000_REG_ID1:\n\tcase WM2000_REG_ID2:\n\tcase WM2000_REG_REVISON:\n\tcase WM2000_REG_SYS_CTL1:\n\tcase WM2000_REG_SYS_CTL2:\n\tcase WM2000_REG_ANC_STAT:\n\tcase WM2000_REG_IF_CTL:\n\tcase WM2000_REG_ANA_MIC_CTL:\n\tcase WM2000_REG_SPK_CTL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config wm2000_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 8,\n\n\t.max_register = WM2000_REG_SPK_CTL,\n\t.readable_reg = wm2000_readable_reg,\n};\n\nstatic int wm2000_probe(struct snd_soc_component *component)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\t \n\twm2000_anc_set_mode(wm2000);\n\n\treturn 0;\n}\n\nstatic void wm2000_remove(struct snd_soc_component *component)\n{\n\tstruct wm2000_priv *wm2000 = dev_get_drvdata(component->dev);\n\n\twm2000_anc_transition(wm2000, ANC_OFF);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm2000 = {\n\t.probe\t\t\t= wm2000_probe,\n\t.remove\t\t\t= wm2000_remove,\n\t.suspend\t\t= wm2000_suspend,\n\t.resume\t\t\t= wm2000_resume,\n\t.controls\t\t= wm2000_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm2000_controls),\n\t.dapm_widgets\t\t= wm2000_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm2000_dapm_widgets),\n\t.dapm_routes\t\t= wm2000_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm2000_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n};\n\nstatic int wm2000_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm2000_priv *wm2000;\n\tstruct wm2000_platform_data *pdata;\n\tconst char *filename;\n\tconst struct firmware *fw = NULL;\n\tint ret, i;\n\tunsigned int reg;\n\tu16 id;\n\n\twm2000 = devm_kzalloc(&i2c->dev, sizeof(*wm2000), GFP_KERNEL);\n\tif (!wm2000)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wm2000->lock);\n\n\tdev_set_drvdata(&i2c->dev, wm2000);\n\n\twm2000->regmap = devm_regmap_init_i2c(i2c, &wm2000_regmap);\n\tif (IS_ERR(wm2000->regmap)) {\n\t\tret = PTR_ERR(wm2000->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < WM2000_NUM_SUPPLIES; i++)\n\t\twm2000->supplies[i].supply = wm2000_supplies[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, WM2000_NUM_SUPPLIES,\n\t\t\t\t      wm2000->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_read(wm2000->regmap, WM2000_REG_ID1, &reg);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Unable to read ID1: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tid = reg << 8;\n\tret = regmap_read(wm2000->regmap, WM2000_REG_ID2, &reg);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Unable to read ID2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tid |= reg & 0xff;\n\n\tif (id != 0x2000) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM2000 - ID %x\\n\", id);\n\t\tret = -ENODEV;\n\t\tgoto err_supplies;\n\t}\n\n\tret = regmap_read(wm2000->regmap, WM2000_REG_REVISON, &reg);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Unable to read Revision: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"revision %c\\n\", reg + 'A');\n\n\twm2000->mclk = devm_clk_get(&i2c->dev, \"MCLK\");\n\tif (IS_ERR(wm2000->mclk)) {\n\t\tret = PTR_ERR(wm2000->mclk);\n\t\tdev_err(&i2c->dev, \"Failed to get MCLK: %d\\n\", ret);\n\t\tgoto err_supplies;\n\t}\n\n\tfilename = \"wm2000_anc.bin\";\n\tpdata = dev_get_platdata(&i2c->dev);\n\tif (pdata) {\n\t\twm2000->speech_clarity = !pdata->speech_enh_disable;\n\n\t\tif (pdata->download_file)\n\t\t\tfilename = pdata->download_file;\n\t}\n\n\tret = request_firmware(&fw, filename, &i2c->dev);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to acquire ANC data: %d\\n\", ret);\n\t\tgoto err_supplies;\n\t}\n\n\t \n\twm2000->anc_download_size = fw->size + 2;\n\twm2000->anc_download = devm_kzalloc(&i2c->dev,\n\t\t\t\t\t    wm2000->anc_download_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (wm2000->anc_download == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_supplies;\n\t}\n\n\twm2000->anc_download[0] = 0x80;\n\twm2000->anc_download[1] = 0x00;\n\tmemcpy(wm2000->anc_download + 2, fw->data, fw->size);\n\n\twm2000->anc_eng_ena = 1;\n\twm2000->anc_active = 1;\n\twm2000->spk_ena = 1;\n\twm2000->i2c = i2c;\n\n\twm2000_reset(wm2000);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t\t&soc_component_dev_wm2000, NULL, 0);\n\nerr_supplies:\n\tregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\n\nout:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm2000_i2c_id[] = {\n\t{ \"wm2000\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm2000_i2c_id);\n\nstatic struct i2c_driver wm2000_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm2000\",\n\t},\n\t.probe = wm2000_i2c_probe,\n\t.id_table = wm2000_i2c_id,\n};\n\nmodule_i2c_driver(wm2000_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM2000 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}