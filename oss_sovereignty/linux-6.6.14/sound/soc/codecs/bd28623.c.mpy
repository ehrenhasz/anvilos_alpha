{
  "module_name": "bd28623.c",
  "hash_id": "3fea921916b22442c8a45c581dbcdda629ba540a3862253f96f036c837ba0d53",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/bd28623.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n\n#define BD28623_NUM_SUPPLIES    3\n\nstatic const char *const bd28623_supply_names[BD28623_NUM_SUPPLIES] = {\n\t\"VCCA\",\n\t\"VCCP1\",\n\t\"VCCP2\",\n};\n\nstruct bd28623_priv {\n\tstruct device *dev;\n\tstruct regulator_bulk_data supplies[BD28623_NUM_SUPPLIES];\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *mute_gpio;\n\n\tint switch_spk;\n};\n\nstatic const struct snd_soc_dapm_widget bd28623_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1P\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1N\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2P\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2N\"),\n};\n\nstatic const struct snd_soc_dapm_route bd28623_routes[] = {\n\t{ \"OUT1P\", NULL, \"DAC\" },\n\t{ \"OUT1N\", NULL, \"DAC\" },\n\t{ \"OUT2P\", NULL, \"DAC\" },\n\t{ \"OUT2N\", NULL, \"DAC\" },\n};\n\nstatic int bd28623_power_on(struct bd28623_priv *bd)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(bd->supplies), bd->supplies);\n\tif (ret) {\n\t\tdev_err(bd->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(bd->reset_gpio, 0);\n\tusleep_range(300000, 400000);\n\n\treturn 0;\n}\n\nstatic void bd28623_power_off(struct bd28623_priv *bd)\n{\n\tgpiod_set_value_cansleep(bd->reset_gpio, 1);\n\n\tregulator_bulk_disable(ARRAY_SIZE(bd->supplies), bd->supplies);\n}\n\nstatic int bd28623_get_switch_spk(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = bd->switch_spk;\n\n\treturn 0;\n}\n\nstatic int bd28623_set_switch_spk(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\n\tif (bd->switch_spk == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tbd->switch_spk = ucontrol->value.integer.value[0];\n\n\tgpiod_set_value_cansleep(bd->mute_gpio, bd->switch_spk ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new bd28623_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"Speaker Switch\", 0,\n\t\t\t    bd28623_get_switch_spk, bd28623_set_switch_spk),\n};\n\nstatic int bd28623_codec_probe(struct snd_soc_component *component)\n{\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tbd->switch_spk = 1;\n\n\tret = bd28623_power_on(bd);\n\tif (ret)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(bd->mute_gpio, bd->switch_spk ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic void bd28623_codec_remove(struct snd_soc_component *component)\n{\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\n\tbd28623_power_off(bd);\n}\n\nstatic int bd28623_codec_suspend(struct snd_soc_component *component)\n{\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\n\tbd28623_power_off(bd);\n\n\treturn 0;\n}\n\nstatic int bd28623_codec_resume(struct snd_soc_component *component)\n{\n\tstruct bd28623_priv *bd = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = bd28623_power_on(bd);\n\tif (ret)\n\t\treturn ret;\n\n\tgpiod_set_value_cansleep(bd->mute_gpio, bd->switch_spk ? 0 : 1);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_bd = {\n\t.probe\t\t\t= bd28623_codec_probe,\n\t.remove\t\t\t= bd28623_codec_remove,\n\t.suspend\t\t= bd28623_codec_suspend,\n\t.resume\t\t\t= bd28623_codec_resume,\n\t.dapm_widgets\t\t= bd28623_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(bd28623_widgets),\n\t.dapm_routes\t\t= bd28623_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(bd28623_routes),\n\t.controls\t\t= bd28623_controls,\n\t.num_controls\t\t= ARRAY_SIZE(bd28623_controls),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct snd_soc_dai_driver soc_dai_bd = {\n\t.name     = \"bd28623-speaker\",\n\t.playback = {\n\t\t.stream_name  = \"Playback\",\n\t\t.formats      = SNDRV_PCM_FMTBIT_S32_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S24_LE |\n\t\t\t\tSNDRV_PCM_FMTBIT_S16_LE,\n\t\t.rates        = SNDRV_PCM_RATE_48000 |\n\t\t\t\tSNDRV_PCM_RATE_44100 |\n\t\t\t\tSNDRV_PCM_RATE_32000,\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t},\n};\n\nstatic int bd28623_probe(struct platform_device *pdev)\n{\n\tstruct bd28623_priv *bd;\n\tstruct device *dev = &pdev->dev;\n\tint i, ret;\n\n\tbd = devm_kzalloc(&pdev->dev, sizeof(struct bd28623_priv), GFP_KERNEL);\n\tif (!bd)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(bd->supplies); i++)\n\t\tbd->supplies[i].supply = bd28623_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(bd->supplies),\n\t\t\t\t      bd->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbd->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(bd->reset_gpio)) {\n\t\tdev_err(dev, \"Failed to request reset_gpio: %ld\\n\",\n\t\t\tPTR_ERR(bd->reset_gpio));\n\t\treturn PTR_ERR(bd->reset_gpio);\n\t}\n\n\tbd->mute_gpio = devm_gpiod_get_optional(dev, \"mute\",\n\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(bd->mute_gpio)) {\n\t\tdev_err(dev, \"Failed to request mute_gpio: %ld\\n\",\n\t\t\tPTR_ERR(bd->mute_gpio));\n\t\treturn PTR_ERR(bd->mute_gpio);\n\t}\n\n\tplatform_set_drvdata(pdev, bd);\n\tbd->dev = dev;\n\n\treturn devm_snd_soc_register_component(dev, &soc_codec_bd,\n\t\t\t\t\t       &soc_dai_bd, 1);\n}\n\nstatic const struct of_device_id bd28623_of_match[] __maybe_unused = {\n\t{ .compatible = \"rohm,bd28623\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, bd28623_of_match);\n\nstatic struct platform_driver bd28623_codec_driver = {\n\t.driver = {\n\t\t.name = \"bd28623\",\n\t\t.of_match_table = of_match_ptr(bd28623_of_match),\n\t},\n\t.probe  = bd28623_probe,\n};\nmodule_platform_driver(bd28623_codec_driver);\n\nMODULE_AUTHOR(\"Katsuhiro Suzuki <suzuki.katsuhiro@socionext.com>\");\nMODULE_DESCRIPTION(\"ROHM BD28623 speaker amplifier driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}