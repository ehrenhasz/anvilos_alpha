{
  "module_name": "cpcap.c",
  "hash_id": "16576100ccb9a7c1a257e2f946acfab35892ff33e2d003d0a2807d9ce2d64ce1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cpcap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/motorola-cpcap.h>\n#include <sound/core.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n \n#define CPCAP_BIT_AUDIO_LOW_PWR           6\n#define CPCAP_BIT_AUD_LOWPWR_SPEED        5\n#define CPCAP_BIT_VAUDIOPRISTBY           4\n#define CPCAP_BIT_VAUDIO_MODE1            2\n#define CPCAP_BIT_VAUDIO_MODE0            1\n#define CPCAP_BIT_V_AUDIO_EN              0\n\n \n#define CPCAP_BIT_CDC_CLK2                15\n#define CPCAP_BIT_CDC_CLK1                14\n#define CPCAP_BIT_CDC_CLK0                13\n#define CPCAP_BIT_CDC_SR3                 12\n#define CPCAP_BIT_CDC_SR2                 11\n#define CPCAP_BIT_CDC_SR1                 10\n#define CPCAP_BIT_CDC_SR0                 9\n#define CPCAP_BIT_CDC_CLOCK_TREE_RESET    8\n#define CPCAP_BIT_MIC2_CDC_EN             7\n#define CPCAP_BIT_CDC_EN_RX               6\n#define CPCAP_BIT_DF_RESET                5\n#define CPCAP_BIT_MIC1_CDC_EN             4\n#define CPCAP_BIT_AUDOHPF_1\t\t  3\n#define CPCAP_BIT_AUDOHPF_0\t\t  2\n#define CPCAP_BIT_AUDIHPF_1\t\t  1\n#define CPCAP_BIT_AUDIHPF_0\t\t  0\n\n \n#define CPCAP_BIT_CDC_PLL_SEL             15\n#define CPCAP_BIT_CLK_IN_SEL              13\n#define CPCAP_BIT_DIG_AUD_IN              12\n#define CPCAP_BIT_CDC_CLK_EN              11\n#define CPCAP_BIT_CDC_DIG_AUD_FS1         10\n#define CPCAP_BIT_CDC_DIG_AUD_FS0         9\n#define CPCAP_BIT_MIC2_TIMESLOT2          8\n#define CPCAP_BIT_MIC2_TIMESLOT1          7\n#define CPCAP_BIT_MIC2_TIMESLOT0          6\n#define CPCAP_BIT_MIC1_RX_TIMESLOT2       5\n#define CPCAP_BIT_MIC1_RX_TIMESLOT1       4\n#define CPCAP_BIT_MIC1_RX_TIMESLOT0       3\n#define CPCAP_BIT_FS_INV                  2\n#define CPCAP_BIT_CLK_INV                 1\n#define CPCAP_BIT_SMB_CDC                 0\n\n \n#define CPCAP_BIT_FSYNC_CLK_IN_COMMON     11\n#define CPCAP_BIT_SLAVE_PLL_CLK_INPUT     10\n#define CPCAP_BIT_ST_CLOCK_TREE_RESET     9\n#define CPCAP_BIT_DF_RESET_ST_DAC         8\n#define CPCAP_BIT_ST_SR3                  7\n#define CPCAP_BIT_ST_SR2                  6\n#define CPCAP_BIT_ST_SR1                  5\n#define CPCAP_BIT_ST_SR0                  4\n#define CPCAP_BIT_ST_DAC_CLK2             3\n#define CPCAP_BIT_ST_DAC_CLK1             2\n#define CPCAP_BIT_ST_DAC_CLK0             1\n#define CPCAP_BIT_ST_DAC_EN               0\n\n \n#define CPCAP_BIT_ST_L_TIMESLOT2          13\n#define CPCAP_BIT_ST_L_TIMESLOT1          12\n#define CPCAP_BIT_ST_L_TIMESLOT0          11\n#define CPCAP_BIT_ST_R_TIMESLOT2          10\n#define CPCAP_BIT_ST_R_TIMESLOT1          9\n#define CPCAP_BIT_ST_R_TIMESLOT0          8\n#define CPCAP_BIT_ST_DAC_CLK_IN_SEL       7\n#define CPCAP_BIT_ST_FS_INV               6\n#define CPCAP_BIT_ST_CLK_INV              5\n#define CPCAP_BIT_ST_DIG_AUD_FS1          4\n#define CPCAP_BIT_ST_DIG_AUD_FS0          3\n#define CPCAP_BIT_DIG_AUD_IN_ST_DAC       2\n#define CPCAP_BIT_ST_CLK_EN               1\n#define CPCAP_BIT_SMB_ST_DAC              0\n\n \n#define CPCAP_BIT_PTT_TH\t\t15\n#define CPCAP_BIT_PTT_CMP_EN\t\t14\n#define CPCAP_BIT_HS_ID_TX\t\t13\n#define CPCAP_BIT_MB_ON2\t\t12\n#define CPCAP_BIT_MB_ON1L\t\t11\n#define CPCAP_BIT_MB_ON1R\t\t10\n#define CPCAP_BIT_RX_L_ENCODE\t\t9\n#define CPCAP_BIT_RX_R_ENCODE\t\t8\n#define CPCAP_BIT_MIC2_MUX\t\t7\n#define CPCAP_BIT_MIC2_PGA_EN\t\t6\n#define CPCAP_BIT_CDET_DIS\t\t5\n#define CPCAP_BIT_EMU_MIC_MUX\t\t4\n#define CPCAP_BIT_HS_MIC_MUX\t\t3\n#define CPCAP_BIT_MIC1_MUX\t\t2\n#define CPCAP_BIT_MIC1_PGA_EN\t\t1\n#define CPCAP_BIT_DLM\t\t\t0\n\n \n#define CPCAP_BIT_MB_BIAS_R1              11\n#define CPCAP_BIT_MB_BIAS_R0              10\n#define CPCAP_BIT_MIC2_GAIN_4             9\n#define CPCAP_BIT_MIC2_GAIN_3             8\n#define CPCAP_BIT_MIC2_GAIN_2             7\n#define CPCAP_BIT_MIC2_GAIN_1             6\n#define CPCAP_BIT_MIC2_GAIN_0             5\n#define CPCAP_BIT_MIC1_GAIN_4             4\n#define CPCAP_BIT_MIC1_GAIN_3             3\n#define CPCAP_BIT_MIC1_GAIN_2             2\n#define CPCAP_BIT_MIC1_GAIN_1             1\n#define CPCAP_BIT_MIC1_GAIN_0             0\n\n \n#define CPCAP_BIT_UNUSED_519_15\t\t15\n#define CPCAP_BIT_UNUSED_519_14\t\t14\n#define CPCAP_BIT_UNUSED_519_13\t\t13\n#define CPCAP_BIT_STDAC_LOW_PWR_DISABLE\t12\n#define CPCAP_BIT_HS_LOW_PWR\t\t11\n#define CPCAP_BIT_HS_ID_RX\t\t10\n#define CPCAP_BIT_ST_HS_CP_EN\t\t9\n#define CPCAP_BIT_EMU_SPKR_R_EN\t\t8\n#define CPCAP_BIT_EMU_SPKR_L_EN\t\t7\n#define CPCAP_BIT_HS_L_EN\t\t6\n#define CPCAP_BIT_HS_R_EN\t\t5\n#define CPCAP_BIT_A4_LINEOUT_L_EN\t4\n#define CPCAP_BIT_A4_LINEOUT_R_EN\t3\n#define CPCAP_BIT_A2_LDSP_L_EN\t\t2\n#define CPCAP_BIT_A2_LDSP_R_EN\t\t1\n#define CPCAP_BIT_A1_EAR_EN\t\t0\n\n \n#define CPCAP_BIT_VOL_EXT3                15\n#define CPCAP_BIT_VOL_EXT2                14\n#define CPCAP_BIT_VOL_EXT1                13\n#define CPCAP_BIT_VOL_EXT0                12\n#define CPCAP_BIT_VOL_DAC3                11\n#define CPCAP_BIT_VOL_DAC2                10\n#define CPCAP_BIT_VOL_DAC1                9\n#define CPCAP_BIT_VOL_DAC0                8\n#define CPCAP_BIT_VOL_DAC_LSB_1dB1        7\n#define CPCAP_BIT_VOL_DAC_LSB_1dB0        6\n#define CPCAP_BIT_VOL_CDC3                5\n#define CPCAP_BIT_VOL_CDC2                4\n#define CPCAP_BIT_VOL_CDC1                3\n#define CPCAP_BIT_VOL_CDC0                2\n#define CPCAP_BIT_VOL_CDC_LSB_1dB1        1\n#define CPCAP_BIT_VOL_CDC_LSB_1dB0        0\n\n \n#define CPCAP_BIT_PGA_CDC_EN              10\n#define CPCAP_BIT_CDC_SW                  9\n#define CPCAP_BIT_PGA_OUTR_USBDP_CDC_SW   8\n#define CPCAP_BIT_PGA_OUTL_USBDN_CDC_SW   7\n#define CPCAP_BIT_ALEFT_HS_CDC_SW         6\n#define CPCAP_BIT_ARIGHT_HS_CDC_SW        5\n#define CPCAP_BIT_A4_LINEOUT_L_CDC_SW     4\n#define CPCAP_BIT_A4_LINEOUT_R_CDC_SW     3\n#define CPCAP_BIT_A2_LDSP_L_CDC_SW        2\n#define CPCAP_BIT_A2_LDSP_R_CDC_SW        1\n#define CPCAP_BIT_A1_EAR_CDC_SW           0\n\n \n#define CPCAP_BIT_PGA_DAC_EN              12\n#define CPCAP_BIT_ST_DAC_SW               11\n#define CPCAP_BIT_MONO_DAC1               10\n#define CPCAP_BIT_MONO_DAC0               9\n#define CPCAP_BIT_PGA_OUTR_USBDP_DAC_SW   8\n#define CPCAP_BIT_PGA_OUTL_USBDN_DAC_SW   7\n#define CPCAP_BIT_ALEFT_HS_DAC_SW         6\n#define CPCAP_BIT_ARIGHT_HS_DAC_SW        5\n#define CPCAP_BIT_A4_LINEOUT_L_DAC_SW     4\n#define CPCAP_BIT_A4_LINEOUT_R_DAC_SW     3\n#define CPCAP_BIT_A2_LDSP_L_DAC_SW        2\n#define CPCAP_BIT_A2_LDSP_R_DAC_SW        1\n#define CPCAP_BIT_A1_EAR_DAC_SW           0\n\n \n#define CPCAP_BIT_PGA_EXT_L_EN            14\n#define CPCAP_BIT_PGA_EXT_R_EN            13\n#define CPCAP_BIT_PGA_IN_L_SW             12\n#define CPCAP_BIT_PGA_IN_R_SW             11\n#define CPCAP_BIT_MONO_EXT1               10\n#define CPCAP_BIT_MONO_EXT0               9\n#define CPCAP_BIT_PGA_OUTR_USBDP_EXT_SW   8\n#define CPCAP_BIT_PGA_OUTL_USBDN_EXT_SW   7\n#define CPCAP_BIT_ALEFT_HS_EXT_SW         6\n#define CPCAP_BIT_ARIGHT_HS_EXT_SW        5\n#define CPCAP_BIT_A4_LINEOUT_L_EXT_SW     4\n#define CPCAP_BIT_A4_LINEOUT_R_EXT_SW     3\n#define CPCAP_BIT_A2_LDSP_L_EXT_SW        2\n#define CPCAP_BIT_A2_LDSP_R_EXT_SW        1\n#define CPCAP_BIT_A1_EAR_EXT_SW           0\n\n \n#define CPCAP_BIT_NCP_CLK_SYNC            7\n#define CPCAP_BIT_A2_CLK_SYNC             6\n#define CPCAP_BIT_A2_FREE_RUN             5\n#define CPCAP_BIT_A2_CLK2                 4\n#define CPCAP_BIT_A2_CLK1                 3\n#define CPCAP_BIT_A2_CLK0                 2\n#define CPCAP_BIT_A2_CLK_IN               1\n#define CPCAP_BIT_A2_CONFIG               0\n\n#define SLEEP_ACTIVATE_POWER 2\n#define CLOCK_TREE_RESET_TIME 1\n\n \n#define STM_STDAC_ACTIVATE_RAMP_TIME   1\n#define STM_STDAC_EN_TEST_PRE          0x090C\n#define STM_STDAC_EN_TEST_POST         0x0000\n#define STM_STDAC_EN_ST_TEST1_PRE      0x2400\n#define STM_STDAC_EN_ST_TEST1_POST     0x0400\n\nstruct cpcap_reg_info {\n\tu16 reg;\n\tu16 mask;\n\tu16 val;\n};\n\nstatic const struct cpcap_reg_info cpcap_default_regs[] = {\n\t{ CPCAP_REG_VAUDIOC, 0x003F, 0x0000 },\n\t{ CPCAP_REG_CC, 0xFFFF, 0x0000 },\n\t{ CPCAP_REG_CC, 0xFFFF, 0x0000 },\n\t{ CPCAP_REG_CDI, 0xBFFF, 0x0000 },\n\t{ CPCAP_REG_SDAC, 0x0FFF, 0x0000 },\n\t{ CPCAP_REG_SDACDI, 0x3FFF, 0x0000 },\n\t{ CPCAP_REG_TXI, 0x0FDF, 0x0000 },\n\t{ CPCAP_REG_TXMP, 0x0FFF, 0x0400 },\n\t{ CPCAP_REG_RXOA, 0x01FF, 0x0000 },\n\t{ CPCAP_REG_RXVC, 0xFF3C, 0x0000 },\n\t{ CPCAP_REG_RXCOA, 0x07FF, 0x0000 },\n\t{ CPCAP_REG_RXSDOA, 0x1FFF, 0x0000 },\n\t{ CPCAP_REG_RXEPOA, 0x7FFF, 0x0000 },\n\t{ CPCAP_REG_A2LA, BIT(CPCAP_BIT_A2_FREE_RUN),\n\t  BIT(CPCAP_BIT_A2_FREE_RUN) },\n};\n\nenum cpcap_dai {\n\tCPCAP_DAI_HIFI,\n\tCPCAP_DAI_VOICE,\n};\n\nstruct cpcap_audio {\n\tstruct snd_soc_component *component;\n\tstruct regmap *regmap;\n\n\tu16 vendor;\n\n\tint codec_clk_id;\n\tint codec_freq;\n\tint codec_format;\n};\n\nstatic int cpcap_st_workaround(struct snd_soc_dapm_widget *w,\n\t\t\t       struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint err = 0;\n\n\t \n\tif (cpcap->vendor != CPCAP_VENDOR_ST)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\terr = regmap_write(cpcap->regmap, CPCAP_REG_TEST,\n\t\t\t\t   STM_STDAC_EN_TEST_PRE);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = regmap_write(cpcap->regmap, CPCAP_REG_ST_TEST1,\n\t\t\t\t   STM_STDAC_EN_ST_TEST1_PRE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(STM_STDAC_ACTIVATE_RAMP_TIME);\n\n\t\terr = regmap_write(cpcap->regmap, CPCAP_REG_ST_TEST1,\n\t\t\t\t   STM_STDAC_EN_ST_TEST1_POST);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = regmap_write(cpcap->regmap, CPCAP_REG_TEST,\n\t\t\t\t   STM_STDAC_EN_TEST_POST);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic const DECLARE_TLV_DB_SCALE(mic_gain_tlv, 0, 100, 0);\n\n \nstatic const DECLARE_TLV_DB_SCALE(vol_tlv, -3300, 300, 0);\n\nstatic const struct snd_kcontrol_new cpcap_snd_controls[] = {\n\t \n\tSOC_SINGLE_TLV(\"HiFi Playback Volume\",\n\t\tCPCAP_REG_RXVC, CPCAP_BIT_VOL_DAC0, 0xF, 0, vol_tlv),\n\tSOC_SINGLE_TLV(\"Voice Playback Volume\",\n\t\tCPCAP_REG_RXVC, CPCAP_BIT_VOL_CDC0, 0xF, 0, vol_tlv),\n\tSOC_SINGLE_TLV(\"Ext Playback Volume\",\n\t\tCPCAP_REG_RXVC, CPCAP_BIT_VOL_EXT0, 0xF, 0, vol_tlv),\n\n\t \n\tSOC_SINGLE_TLV(\"Mic1 Capture Volume\",\n\t\tCPCAP_REG_TXMP, CPCAP_BIT_MIC1_GAIN_0, 0x1F, 0, mic_gain_tlv),\n\tSOC_SINGLE_TLV(\"Mic2 Capture Volume\",\n\t\tCPCAP_REG_TXMP, CPCAP_BIT_MIC2_GAIN_0, 0x1F, 0, mic_gain_tlv),\n\n\t \n\tSOC_SINGLE(\"Hifi Left Phase Invert Switch\",\n\t\tCPCAP_REG_RXSDOA, CPCAP_BIT_MONO_DAC0, 1, 0),\n\tSOC_SINGLE(\"Ext Left Phase Invert Switch\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_MONO_EXT0, 1, 0),\n};\n\nstatic const char * const cpcap_out_mux_texts[] = {\n\t\"Off\", \"Voice\", \"HiFi\", \"Ext\"\n};\n\nstatic const char * const cpcap_in_right_mux_texts[] = {\n\t\"Off\", \"Mic 1\", \"Headset Mic\", \"EMU Mic\", \"Ext Right\"\n};\n\nstatic const char * const cpcap_in_left_mux_texts[] = {\n\t\"Off\", \"Mic 2\", \"Ext Left\"\n};\n\n \nstatic SOC_ENUM_SINGLE_EXT_DECL(cpcap_input_left_mux_enum,\n\t\t\t\tcpcap_in_left_mux_texts);\nstatic SOC_ENUM_SINGLE_EXT_DECL(cpcap_input_right_mux_enum,\n\t\t\t\tcpcap_in_right_mux_texts);\n\n \nstatic SOC_ENUM_SINGLE_DECL(cpcap_earpiece_mux_enum, 0, 0, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_spkr_r_mux_enum, 0, 1, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_spkr_l_mux_enum, 0, 2, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_line_r_mux_enum, 0, 3, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_line_l_mux_enum, 0, 4, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_hs_r_mux_enum, 0, 5, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_hs_l_mux_enum, 0, 6, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_emu_l_mux_enum, 0, 7, cpcap_out_mux_texts);\nstatic SOC_ENUM_SINGLE_DECL(cpcap_emu_r_mux_enum, 0, 8, cpcap_out_mux_texts);\n\nstatic int cpcap_output_mux_get_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int shift = e->shift_l;\n\tint reg_voice, reg_hifi, reg_ext, status;\n\tint err;\n\n\terr = regmap_read(cpcap->regmap, CPCAP_REG_RXCOA, &reg_voice);\n\tif (err)\n\t\treturn err;\n\terr = regmap_read(cpcap->regmap, CPCAP_REG_RXSDOA, &reg_hifi);\n\tif (err)\n\t\treturn err;\n\terr = regmap_read(cpcap->regmap, CPCAP_REG_RXEPOA, &reg_ext);\n\tif (err)\n\t\treturn err;\n\n\treg_voice = (reg_voice >> shift) & 1;\n\treg_hifi = (reg_hifi >> shift) & 1;\n\treg_ext = (reg_ext >> shift) & 1;\n\tstatus = reg_ext << 2 | reg_hifi << 1 | reg_voice;\n\n\tswitch (status) {\n\tcase 0x04:\n\t\tucontrol->value.enumerated.item[0] = 3;\n\t\tbreak;\n\tcase 0x02:\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase 0x01:\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_output_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int muxval = ucontrol->value.enumerated.item[0];\n\tunsigned int mask = BIT(e->shift_l);\n\tu16 reg_voice = 0x00, reg_hifi = 0x00, reg_ext = 0x00;\n\tint err;\n\n\tswitch (muxval) {\n\tcase 1:\n\t\treg_voice = mask;\n\t\tbreak;\n\tcase 2:\n\t\treg_hifi = mask;\n\t\tbreak;\n\tcase 3:\n\t\treg_ext = mask;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_RXCOA,\n\t\t\t\t mask, reg_voice);\n\tif (err)\n\t\treturn err;\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_RXSDOA,\n\t\t\t\t mask, reg_hifi);\n\tif (err)\n\t\treturn err;\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_RXEPOA,\n\t\t\t\t mask, reg_ext);\n\tif (err)\n\t\treturn err;\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, muxval, e, NULL);\n\n\treturn 0;\n}\n\nstatic int cpcap_input_right_mux_get_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint regval, mask;\n\tint err;\n\n\terr = regmap_read(cpcap->regmap, CPCAP_REG_TXI, &regval);\n\tif (err)\n\t\treturn err;\n\n\tmask = 0;\n\tmask |= BIT(CPCAP_BIT_MIC1_MUX);\n\tmask |= BIT(CPCAP_BIT_HS_MIC_MUX);\n\tmask |= BIT(CPCAP_BIT_EMU_MIC_MUX);\n\tmask |= BIT(CPCAP_BIT_RX_R_ENCODE);\n\n\tswitch (regval & mask) {\n\tcase BIT(CPCAP_BIT_RX_R_ENCODE):\n\t\tucontrol->value.enumerated.item[0] = 4;\n\t\tbreak;\n\tcase BIT(CPCAP_BIT_EMU_MIC_MUX):\n\t\tucontrol->value.enumerated.item[0] = 3;\n\t\tbreak;\n\tcase BIT(CPCAP_BIT_HS_MIC_MUX):\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase BIT(CPCAP_BIT_MIC1_MUX):\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_input_right_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int muxval = ucontrol->value.enumerated.item[0];\n\tint regval = 0, mask;\n\tint err;\n\n\tmask = 0;\n\tmask |= BIT(CPCAP_BIT_MIC1_MUX);\n\tmask |= BIT(CPCAP_BIT_HS_MIC_MUX);\n\tmask |= BIT(CPCAP_BIT_EMU_MIC_MUX);\n\tmask |= BIT(CPCAP_BIT_RX_R_ENCODE);\n\n\tswitch (muxval) {\n\tcase 1:\n\t\tregval = BIT(CPCAP_BIT_MIC1_MUX);\n\t\tbreak;\n\tcase 2:\n\t\tregval = BIT(CPCAP_BIT_HS_MIC_MUX);\n\t\tbreak;\n\tcase 3:\n\t\tregval = BIT(CPCAP_BIT_EMU_MIC_MUX);\n\t\tbreak;\n\tcase 4:\n\t\tregval = BIT(CPCAP_BIT_RX_R_ENCODE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_TXI,\n\t\t\t\t mask, regval);\n\tif (err)\n\t\treturn err;\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, muxval, e, NULL);\n\n\treturn 0;\n}\n\nstatic int cpcap_input_left_mux_get_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint regval, mask;\n\tint err;\n\n\terr = regmap_read(cpcap->regmap, CPCAP_REG_TXI, &regval);\n\tif (err)\n\t\treturn err;\n\n\tmask = 0;\n\tmask |= BIT(CPCAP_BIT_MIC2_MUX);\n\tmask |= BIT(CPCAP_BIT_RX_L_ENCODE);\n\n\tswitch (regval & mask) {\n\tcase BIT(CPCAP_BIT_RX_L_ENCODE):\n\t\tucontrol->value.enumerated.item[0] = 2;\n\t\tbreak;\n\tcase BIT(CPCAP_BIT_MIC2_MUX):\n\t\tucontrol->value.enumerated.item[0] = 1;\n\t\tbreak;\n\tdefault:\n\t\tucontrol->value.enumerated.item[0] = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_input_left_mux_put_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int muxval = ucontrol->value.enumerated.item[0];\n\tint regval = 0, mask;\n\tint err;\n\n\tmask = 0;\n\tmask |= BIT(CPCAP_BIT_MIC2_MUX);\n\tmask |= BIT(CPCAP_BIT_RX_L_ENCODE);\n\n\tswitch (muxval) {\n\tcase 1:\n\t\tregval = BIT(CPCAP_BIT_MIC2_MUX);\n\t\tbreak;\n\tcase 2:\n\t\tregval = BIT(CPCAP_BIT_RX_L_ENCODE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_TXI,\n\t\t\t\t mask, regval);\n\tif (err)\n\t\treturn err;\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, muxval, e, NULL);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new cpcap_input_left_mux =\n\tSOC_DAPM_ENUM_EXT(\"Input Left\", cpcap_input_left_mux_enum,\n\t\t\t  cpcap_input_left_mux_get_enum,\n\t\t\t  cpcap_input_left_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_input_right_mux =\n\tSOC_DAPM_ENUM_EXT(\"Input Right\", cpcap_input_right_mux_enum,\n\t\t\t  cpcap_input_right_mux_get_enum,\n\t\t\t  cpcap_input_right_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_emu_left_mux =\n\tSOC_DAPM_ENUM_EXT(\"EMU Left\", cpcap_emu_l_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_emu_right_mux =\n\tSOC_DAPM_ENUM_EXT(\"EMU Right\", cpcap_emu_r_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_hs_left_mux =\n\tSOC_DAPM_ENUM_EXT(\"Headset Left\", cpcap_hs_l_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_hs_right_mux =\n\tSOC_DAPM_ENUM_EXT(\"Headset Right\", cpcap_hs_r_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_line_left_mux =\n\tSOC_DAPM_ENUM_EXT(\"Line Left\", cpcap_line_l_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_line_right_mux =\n\tSOC_DAPM_ENUM_EXT(\"Line Right\", cpcap_line_r_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_speaker_left_mux =\n\tSOC_DAPM_ENUM_EXT(\"Speaker Left\", cpcap_spkr_l_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_speaker_right_mux =\n\tSOC_DAPM_ENUM_EXT(\"Speaker Right\", cpcap_spkr_r_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\nstatic const struct snd_kcontrol_new cpcap_earpiece_mux =\n\tSOC_DAPM_ENUM_EXT(\"Earpiece\", cpcap_earpiece_mux_enum,\n\t\t\t  cpcap_output_mux_get_enum, cpcap_output_mux_put_enum);\n\nstatic const struct snd_kcontrol_new cpcap_hifi_mono_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"HiFi Mono Playback Switch\",\n\t\tCPCAP_REG_RXSDOA, CPCAP_BIT_MONO_DAC1, 1, 0),\n};\nstatic const struct snd_kcontrol_new cpcap_ext_mono_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"Ext Mono Playback Switch\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_MONO_EXT0, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new cpcap_extr_mute_control =\n\tSOC_DAPM_SINGLE(\"Switch\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_PGA_IN_R_SW, 1, 0);\nstatic const struct snd_kcontrol_new cpcap_extl_mute_control =\n\tSOC_DAPM_SINGLE(\"Switch\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_PGA_IN_L_SW, 1, 0);\n\nstatic const struct snd_kcontrol_new cpcap_voice_loopback =\n\tSOC_DAPM_SINGLE(\"Switch\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_DLM, 1, 0);\n\nstatic const struct snd_soc_dapm_widget cpcap_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"HiFi RX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"Voice RX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"Voice TX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VAUDIO\", SLEEP_ACTIVATE_POWER, 0),\n\n\t \n\tSND_SOC_DAPM_REG(snd_soc_dapm_pga, \"Highpass Filter RX\",\n\t\tCPCAP_REG_CC, CPCAP_BIT_AUDIHPF_0, 0x3, 0x3, 0x0),\n\tSND_SOC_DAPM_REG(snd_soc_dapm_pga, \"Highpass Filter TX\",\n\t\tCPCAP_REG_CC, CPCAP_BIT_AUDOHPF_0, 0x3, 0x3, 0x0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"HiFi DAI Clock\",\n\t\tCPCAP_REG_SDACDI, CPCAP_BIT_ST_CLK_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"Voice DAI Clock\",\n\t\tCPCAP_REG_CDI, CPCAP_BIT_CDC_CLK_EN, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"MIC1R Bias\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_MB_ON1R, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC1L Bias\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_MB_ON1L, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC2 Bias\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_MB_ON2, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"MICR\"),\n\tSND_SOC_DAPM_INPUT(\"HSMIC\"),\n\tSND_SOC_DAPM_INPUT(\"EMUMIC\"),\n\tSND_SOC_DAPM_INPUT(\"MICL\"),\n\tSND_SOC_DAPM_INPUT(\"EXTR\"),\n\tSND_SOC_DAPM_INPUT(\"EXTL\"),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Right Capture Route\",\n\t\tSND_SOC_NOPM, 0, 0, &cpcap_input_right_mux),\n\tSND_SOC_DAPM_MUX(\"Left Capture Route\",\n\t\tSND_SOC_NOPM, 0, 0, &cpcap_input_left_mux),\n\n\t \n\tSND_SOC_DAPM_PGA(\"Microphone 1 PGA\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_MIC1_PGA_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Microphone 2 PGA\",\n\t\tCPCAP_REG_TXI, CPCAP_BIT_MIC2_PGA_EN, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_ADC(\"ADC Right\", NULL,\n\t\tCPCAP_REG_CC, CPCAP_BIT_MIC1_CDC_EN, 0),\n\tSND_SOC_DAPM_ADC(\"ADC Left\", NULL,\n\t\tCPCAP_REG_CC, CPCAP_BIT_MIC2_CDC_EN, 0),\n\n\t \n\tSND_SOC_DAPM_DAC_E(\"DAC HiFi\", NULL,\n\t\tCPCAP_REG_SDAC, CPCAP_BIT_ST_DAC_EN, 0,\n\t\tcpcap_st_workaround,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_DAC_E(\"DAC Voice\", NULL,\n\t\tCPCAP_REG_CC, CPCAP_BIT_CDC_EN_RX, 0,\n\t\tcpcap_st_workaround,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_PGA(\"HiFi PGA\",\n\t\tCPCAP_REG_RXSDOA, CPCAP_BIT_PGA_DAC_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Voice PGA\",\n\t\tCPCAP_REG_RXCOA, CPCAP_BIT_PGA_CDC_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA_E(\"Ext Right PGA\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_PGA_EXT_R_EN, 0,\n\t\tNULL, 0,\n\t\tcpcap_st_workaround,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_PGA_E(\"Ext Left PGA\",\n\t\tCPCAP_REG_RXEPOA, CPCAP_BIT_PGA_EXT_L_EN, 0,\n\t\tNULL, 0,\n\t\tcpcap_st_workaround,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"Ext Right Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_extr_mute_control),\n\tSND_SOC_DAPM_SWITCH(\"Ext Left Enable\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_extl_mute_control),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"Voice Loopback\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_voice_loopback),\n\n\t \n\tSOC_MIXER_ARRAY(\"HiFi Mono Left Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tcpcap_hifi_mono_mixer_controls),\n\tSOC_MIXER_ARRAY(\"HiFi Mono Right Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tcpcap_hifi_mono_mixer_controls),\n\tSOC_MIXER_ARRAY(\"Ext Mono Left Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tcpcap_ext_mono_mixer_controls),\n\tSOC_MIXER_ARRAY(\"Ext Mono Right Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tcpcap_ext_mono_mixer_controls),\n\n\t \n\tSND_SOC_DAPM_MUX(\"Earpiece Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_earpiece_mux),\n\tSND_SOC_DAPM_MUX(\"Speaker Right Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_speaker_right_mux),\n\tSND_SOC_DAPM_MUX(\"Speaker Left Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_speaker_left_mux),\n\tSND_SOC_DAPM_MUX(\"Lineout Right Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_line_right_mux),\n\tSND_SOC_DAPM_MUX(\"Lineout Left Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_line_left_mux),\n\tSND_SOC_DAPM_MUX(\"Headset Right Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_hs_right_mux),\n\tSND_SOC_DAPM_MUX(\"Headset Left Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_hs_left_mux),\n\tSND_SOC_DAPM_MUX(\"EMU Right Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_emu_right_mux),\n\tSND_SOC_DAPM_MUX(\"EMU Left Playback Route\", SND_SOC_NOPM, 0, 0,\n\t\t&cpcap_emu_left_mux),\n\n\t \n\tSND_SOC_DAPM_PGA(\"Earpiece PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_A1_EAR_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Speaker Right PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_A2_LDSP_R_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Speaker Left PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_A2_LDSP_L_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Lineout Right PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_A4_LINEOUT_R_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Lineout Left PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_A4_LINEOUT_L_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Headset Right PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_HS_R_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Headset Left PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_HS_L_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"EMU Right PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_EMU_SPKR_R_EN, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"EMU Left PGA\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_EMU_SPKR_L_EN, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"Headset Charge Pump\",\n\t\tCPCAP_REG_RXOA, CPCAP_BIT_ST_HS_CP_EN, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"EP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKR\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKL\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINER\"),\n\tSND_SOC_DAPM_OUTPUT(\"LINEL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HSL\"),\n\tSND_SOC_DAPM_OUTPUT(\"EMUR\"),\n\tSND_SOC_DAPM_OUTPUT(\"EMUL\"),\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t \n\t{\"HiFi PGA\", NULL, \"VAUDIO\"},\n\t{\"Voice PGA\", NULL, \"VAUDIO\"},\n\t{\"Ext Right PGA\", NULL, \"VAUDIO\"},\n\t{\"Ext Left PGA\", NULL, \"VAUDIO\"},\n\t{\"Microphone 1 PGA\", NULL, \"VAUDIO\"},\n\t{\"Microphone 2 PGA\", NULL, \"VAUDIO\"},\n\n\t \n\t{\"HiFi RX\", NULL, \"HiFi Playback\"},\n\t{\"Voice RX\", NULL, \"Voice Playback\"},\n\t{\"Voice Capture\", NULL, \"Voice TX\"},\n\n\t \n\t{\"HiFi RX\", NULL, \"HiFi DAI Clock\"},\n\t{\"Voice RX\", NULL, \"Voice DAI Clock\"},\n\t{\"Voice TX\", NULL, \"Voice DAI Clock\"},\n\n\t \n\t{\"Voice Loopback\", \"Switch\", \"Voice TX\"},\n\t{\"Voice RX\", NULL, \"Voice Loopback\"},\n\n\t \n\t{\"Highpass Filter RX\", NULL, \"Voice RX\"},\n\t{\"Voice TX\", NULL, \"Highpass Filter TX\"},\n\n\t \n\t{\"DAC HiFi\", NULL, \"HiFi RX\"},\n\t{\"DAC Voice\", NULL, \"Highpass Filter RX\"},\n\n\t \n\t{\"HiFi PGA\", NULL, \"DAC HiFi\"},\n\t{\"Voice PGA\", NULL, \"DAC Voice\"},\n\n\t \n\t{\"Ext Right PGA\", NULL, \"EXTR\"},\n\t{\"Ext Left PGA\", NULL, \"EXTL\"},\n\n\t \n\t{\"Ext Right Enable\", \"Switch\", \"Ext Right PGA\"},\n\t{\"Ext Left Enable\", \"Switch\", \"Ext Left PGA\"},\n\n\t \n\t{\"HiFi Mono Left Mixer\", NULL, \"HiFi PGA\"},\n\t{\"HiFi Mono Left Mixer\", \"HiFi Mono Playback Switch\", \"HiFi PGA\"},\n\t{\"HiFi Mono Right Mixer\", NULL, \"HiFi PGA\"},\n\t{\"HiFi Mono Right Mixer\", \"HiFi Mono Playback Switch\", \"HiFi PGA\"},\n\n\t \n\t{\"Ext Mono Right Mixer\", NULL, \"Ext Right Enable\"},\n\t{\"Ext Mono Right Mixer\", \"Ext Mono Playback Switch\", \"Ext Left Enable\"},\n\t{\"Ext Mono Left Mixer\", NULL, \"Ext Left Enable\"},\n\t{\"Ext Mono Left Mixer\", \"Ext Mono Playback Switch\", \"Ext Right Enable\"},\n\n\t \n\t{\"Earpiece Playback Route\", \"HiFi\", \"HiFi Mono Right Mixer\"},\n\t{\"Speaker Right Playback Route\", \"HiFi\", \"HiFi Mono Right Mixer\"},\n\t{\"Speaker Left Playback Route\", \"HiFi\", \"HiFi Mono Left Mixer\"},\n\t{\"Lineout Right Playback Route\", \"HiFi\", \"HiFi Mono Right Mixer\"},\n\t{\"Lineout Left Playback Route\", \"HiFi\", \"HiFi Mono Left Mixer\"},\n\t{\"Headset Right Playback Route\", \"HiFi\", \"HiFi Mono Right Mixer\"},\n\t{\"Headset Left Playback Route\", \"HiFi\", \"HiFi Mono Left Mixer\"},\n\t{\"EMU Right Playback Route\", \"HiFi\", \"HiFi Mono Right Mixer\"},\n\t{\"EMU Left Playback Route\", \"HiFi\", \"HiFi Mono Left Mixer\"},\n\n\t \n\t{\"Earpiece Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Speaker Right Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Speaker Left Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Lineout Right Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Lineout Left Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Headset Right Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"Headset Left Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"EMU Right Playback Route\", \"Voice\", \"Voice PGA\"},\n\t{\"EMU Left Playback Route\", \"Voice\", \"Voice PGA\"},\n\n\t \n\t{\"Earpiece Playback Route\", \"Ext\", \"Ext Mono Right Mixer\"},\n\t{\"Speaker Right Playback Route\", \"Ext\", \"Ext Mono Right Mixer\"},\n\t{\"Speaker Left Playback Route\", \"Ext\", \"Ext Mono Left Mixer\"},\n\t{\"Lineout Right Playback Route\", \"Ext\", \"Ext Mono Right Mixer\"},\n\t{\"Lineout Left Playback Route\", \"Ext\", \"Ext Mono Left Mixer\"},\n\t{\"Headset Right Playback Route\", \"Ext\", \"Ext Mono Right Mixer\"},\n\t{\"Headset Left Playback Route\", \"Ext\", \"Ext Mono Left Mixer\"},\n\t{\"EMU Right Playback Route\", \"Ext\", \"Ext Mono Right Mixer\"},\n\t{\"EMU Left Playback Route\", \"Ext\", \"Ext Mono Left Mixer\"},\n\n\t \n\t{\"Earpiece PGA\", NULL, \"Earpiece Playback Route\"},\n\t{\"Speaker Right PGA\", NULL, \"Speaker Right Playback Route\"},\n\t{\"Speaker Left PGA\", NULL, \"Speaker Left Playback Route\"},\n\t{\"Lineout Right PGA\", NULL, \"Lineout Right Playback Route\"},\n\t{\"Lineout Left PGA\", NULL, \"Lineout Left Playback Route\"},\n\t{\"Headset Right PGA\", NULL, \"Headset Right Playback Route\"},\n\t{\"Headset Left PGA\", NULL, \"Headset Left Playback Route\"},\n\t{\"EMU Right PGA\", NULL, \"EMU Right Playback Route\"},\n\t{\"EMU Left PGA\", NULL, \"EMU Left Playback Route\"},\n\n\t \n\t{\"EP\", NULL, \"Earpiece PGA\"},\n\t{\"SPKR\", NULL, \"Speaker Right PGA\"},\n\t{\"SPKL\", NULL, \"Speaker Left PGA\"},\n\t{\"LINER\", NULL, \"Lineout Right PGA\"},\n\t{\"LINEL\", NULL, \"Lineout Left PGA\"},\n\t{\"HSR\", NULL, \"Headset Right PGA\"},\n\t{\"HSL\", NULL, \"Headset Left PGA\"},\n\t{\"EMUR\", NULL, \"EMU Right PGA\"},\n\t{\"EMUL\", NULL, \"EMU Left PGA\"},\n\n\t \n\t{\"HSR\", NULL, \"Headset Charge Pump\"},\n\t{\"HSL\", NULL, \"Headset Charge Pump\"},\n\n\t \n\t{\"Right Capture Route\", \"Mic 1\", \"MICR\"},\n\t{\"Right Capture Route\", \"Headset Mic\", \"HSMIC\"},\n\t{\"Right Capture Route\", \"EMU Mic\", \"EMUMIC\"},\n\t{\"Right Capture Route\", \"Ext Right\", \"EXTR\"},\n\t{\"Left Capture Route\", \"Mic 2\", \"MICL\"},\n\t{\"Left Capture Route\", \"Ext Left\", \"EXTL\"},\n\n\t \n\t{\"Microphone 1 PGA\", NULL, \"Right Capture Route\"},\n\t{\"Microphone 2 PGA\", NULL, \"Left Capture Route\"},\n\n\t \n\t{\"ADC Right\", NULL, \"Microphone 1 PGA\"},\n\t{\"ADC Left\", NULL, \"Microphone 2 PGA\"},\n\n\t \n\t{\"Highpass Filter TX\", NULL, \"ADC Right\"},\n\t{\"Highpass Filter TX\", NULL, \"ADC Left\"},\n\n\t \n\t{\"MICL\", NULL, \"MIC1L Bias\"},\n\t{\"MICR\", NULL, \"MIC1R Bias\"},\n};\n\nstatic int cpcap_set_sysclk(struct cpcap_audio *cpcap, enum cpcap_dai dai,\n\t\t\t    int clk_id, int freq)\n{\n\tu16 clkfreqreg, clkfreqshift;\n\tu16 clkfreqmask, clkfreqval;\n\tu16 clkidreg, clkidshift;\n\tu16 mask, val;\n\tint err;\n\n\tswitch (dai) {\n\tcase CPCAP_DAI_HIFI:\n\t\tclkfreqreg = CPCAP_REG_SDAC;\n\t\tclkfreqshift = CPCAP_BIT_ST_DAC_CLK0;\n\t\tclkidreg = CPCAP_REG_SDACDI;\n\t\tclkidshift = CPCAP_BIT_ST_DAC_CLK_IN_SEL;\n\t\tbreak;\n\tcase CPCAP_DAI_VOICE:\n\t\tclkfreqreg = CPCAP_REG_CC;\n\t\tclkfreqshift = CPCAP_BIT_CDC_CLK0;\n\t\tclkidreg = CPCAP_REG_CDI;\n\t\tclkidshift = CPCAP_BIT_CLK_IN_SEL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpcap->component->dev, \"invalid DAI: %d\", dai);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (clk_id < 0 || clk_id > 1) {\n\t\tdev_err(cpcap->component->dev, \"invalid clk id %d\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\terr = regmap_update_bits(cpcap->regmap, clkidreg, BIT(clkidshift),\n\t\t\t\t clk_id ? BIT(clkidshift) : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dai == CPCAP_DAI_VOICE) {\n\t\tmask = BIT(CPCAP_BIT_CDC_PLL_SEL);\n\t\tval = BIT(CPCAP_BIT_CDC_PLL_SEL);\n\t\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CDI,\n\t\t\t\t\t mask, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tclkfreqmask = 0x7 << clkfreqshift;\n\tswitch (freq) {\n\tcase 15360000:\n\t\tclkfreqval = 0x01 << clkfreqshift;\n\t\tbreak;\n\tcase 16800000:\n\t\tclkfreqval = 0x02 << clkfreqshift;\n\t\tbreak;\n\tcase 19200000:\n\t\tclkfreqval = 0x03 << clkfreqshift;\n\t\tbreak;\n\tcase 26000000:\n\t\tclkfreqval = 0x04 << clkfreqshift;\n\t\tbreak;\n\tcase 33600000:\n\t\tclkfreqval = 0x05 << clkfreqshift;\n\t\tbreak;\n\tcase 38400000:\n\t\tclkfreqval = 0x06 << clkfreqshift;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpcap->component->dev, \"unsupported freq %u\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\terr = regmap_update_bits(cpcap->regmap, clkfreqreg,\n\t\t\t\t clkfreqmask, clkfreqval);\n\tif (err)\n\t\treturn err;\n\n\tif (dai == CPCAP_DAI_VOICE) {\n\t\tcpcap->codec_clk_id = clk_id;\n\t\tcpcap->codec_freq = freq;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_set_samprate(struct cpcap_audio *cpcap, enum cpcap_dai dai,\n\t\t\t      int samplerate)\n{\n\tstruct snd_soc_component *component = cpcap->component;\n\tu16 sampreg, sampmask, sampshift, sampval, sampreset;\n\tint err, sampreadval;\n\n\tswitch (dai) {\n\tcase CPCAP_DAI_HIFI:\n\t\tsampreg = CPCAP_REG_SDAC;\n\t\tsampshift = CPCAP_BIT_ST_SR0;\n\t\tsampreset = BIT(CPCAP_BIT_DF_RESET_ST_DAC) |\n\t\t\t    BIT(CPCAP_BIT_ST_CLOCK_TREE_RESET);\n\t\tbreak;\n\tcase CPCAP_DAI_VOICE:\n\t\tsampreg = CPCAP_REG_CC;\n\t\tsampshift = CPCAP_BIT_CDC_SR0;\n\t\tsampreset = BIT(CPCAP_BIT_DF_RESET) |\n\t\t\t    BIT(CPCAP_BIT_CDC_CLOCK_TREE_RESET);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"invalid DAI: %d\", dai);\n\t\treturn -EINVAL;\n\t}\n\n\tsampmask = 0xF << sampshift | sampreset;\n\tswitch (samplerate) {\n\tcase 48000:\n\t\tsampval = 0x8 << sampshift;\n\t\tbreak;\n\tcase 44100:\n\t\tsampval = 0x7 << sampshift;\n\t\tbreak;\n\tcase 32000:\n\t\tsampval = 0x6 << sampshift;\n\t\tbreak;\n\tcase 24000:\n\t\tsampval = 0x5 << sampshift;\n\t\tbreak;\n\tcase 22050:\n\t\tsampval = 0x4 << sampshift;\n\t\tbreak;\n\tcase 16000:\n\t\tsampval = 0x3 << sampshift;\n\t\tbreak;\n\tcase 12000:\n\t\tsampval = 0x2 << sampshift;\n\t\tbreak;\n\tcase 11025:\n\t\tsampval = 0x1 << sampshift;\n\t\tbreak;\n\tcase 8000:\n\t\tsampval = 0x0 << sampshift;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported samplerate %d\", samplerate);\n\t\treturn -EINVAL;\n\t}\n\terr = regmap_update_bits(cpcap->regmap, sampreg,\n\t\t\t\t sampmask, sampval | sampreset);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmdelay(CLOCK_TREE_RESET_TIME);\n\n\terr = regmap_read(cpcap->regmap, sampreg, &sampreadval);\n\tif (err)\n\t\treturn err;\n\n\tif (sampreadval & sampreset) {\n\t\tdev_err(component->dev, \"reset self-clear failed: %04x\",\n\t\t\tsampreadval);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_hifi_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint rate = params_rate(params);\n\n\tdev_dbg(component->dev, \"HiFi setup HW params: rate=%d\", rate);\n\treturn cpcap_set_samprate(cpcap, CPCAP_DAI_HIFI, rate);\n}\n\nstatic int cpcap_hifi_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\n\t\t\t\t     unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = component->dev;\n\n\tdev_dbg(dev, \"HiFi setup sysclk: clk_id=%u, freq=%u\", clk_id, freq);\n\treturn cpcap_set_sysclk(cpcap, CPCAP_DAI_HIFI, clk_id, freq);\n}\n\nstatic int cpcap_hifi_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t  unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstruct device *dev = component->dev;\n\tstatic const u16 reg = CPCAP_REG_SDACDI;\n\tstatic const u16 mask =\n\t\tBIT(CPCAP_BIT_SMB_ST_DAC) |\n\t\tBIT(CPCAP_BIT_ST_CLK_INV) |\n\t\tBIT(CPCAP_BIT_ST_FS_INV) |\n\t\tBIT(CPCAP_BIT_ST_DIG_AUD_FS0) |\n\t\tBIT(CPCAP_BIT_ST_DIG_AUD_FS1) |\n\t\tBIT(CPCAP_BIT_ST_L_TIMESLOT0) |\n\t\tBIT(CPCAP_BIT_ST_L_TIMESLOT1) |\n\t\tBIT(CPCAP_BIT_ST_L_TIMESLOT2) |\n\t\tBIT(CPCAP_BIT_ST_R_TIMESLOT0) |\n\t\tBIT(CPCAP_BIT_ST_R_TIMESLOT1) |\n\t\tBIT(CPCAP_BIT_ST_R_TIMESLOT2);\n\tu16 val = 0x0000;\n\n\tdev_dbg(dev, \"HiFi setup dai format (%08x)\", fmt);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tval &= ~BIT(CPCAP_BIT_SMB_ST_DAC);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HiFi dai fmt failed: CPCAP should be provider\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval |= BIT(CPCAP_BIT_ST_FS_INV);\n\t\tval |= BIT(CPCAP_BIT_ST_CLK_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval &= ~BIT(CPCAP_BIT_ST_FS_INV);\n\t\tval |= BIT(CPCAP_BIT_ST_CLK_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval |= BIT(CPCAP_BIT_ST_FS_INV);\n\t\tval &= ~BIT(CPCAP_BIT_ST_CLK_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval &= ~BIT(CPCAP_BIT_ST_FS_INV);\n\t\tval &= ~BIT(CPCAP_BIT_ST_CLK_INV);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"HiFi dai fmt failed: unsupported clock invert mode\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (val & BIT(CPCAP_BIT_ST_CLK_INV))\n\t\tval &= ~BIT(CPCAP_BIT_ST_CLK_INV);\n\telse\n\t\tval |= BIT(CPCAP_BIT_ST_CLK_INV);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= BIT(CPCAP_BIT_ST_DIG_AUD_FS0);\n\t\tval |= BIT(CPCAP_BIT_ST_DIG_AUD_FS1);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tval |= BIT(CPCAP_BIT_ST_DIG_AUD_FS0);\n\t\tval &= ~BIT(CPCAP_BIT_ST_DIG_AUD_FS1);\n\t\t \n\t\tval |= BIT(CPCAP_BIT_ST_L_TIMESLOT0);\n\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"HiFi dai format: val=%04x\", val);\n\treturn regmap_update_bits(cpcap->regmap, reg, mask, val);\n}\n\nstatic int cpcap_hifi_set_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstatic const u16 reg = CPCAP_REG_RXSDOA;\n\tstatic const u16 mask = BIT(CPCAP_BIT_ST_DAC_SW);\n\tu16 val;\n\n\tif (mute)\n\t\tval = 0;\n\telse\n\t\tval = BIT(CPCAP_BIT_ST_DAC_SW);\n\n\tdev_dbg(component->dev, \"HiFi mute: %d\", mute);\n\treturn regmap_update_bits(cpcap->regmap, reg, mask, val);\n}\n\nstatic const struct snd_soc_dai_ops cpcap_dai_hifi_ops = {\n\t.hw_params\t= cpcap_hifi_hw_params,\n\t.set_sysclk\t= cpcap_hifi_set_dai_sysclk,\n\t.set_fmt\t= cpcap_hifi_set_dai_fmt,\n\t.mute_stream\t= cpcap_hifi_set_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic int cpcap_voice_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct device *dev = component->dev;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstatic const u16 reg_cdi = CPCAP_REG_CDI;\n\tint rate = params_rate(params);\n\tint channels = params_channels(params);\n\tint direction = substream->stream;\n\tu16 val, mask;\n\tint err;\n\n\tdev_dbg(dev, \"Voice setup HW params: rate=%d, direction=%d, chan=%d\",\n\t\trate, direction, channels);\n\n\terr = cpcap_set_samprate(cpcap, CPCAP_DAI_VOICE, rate);\n\tif (err)\n\t\treturn err;\n\n\tif (direction == SNDRV_PCM_STREAM_CAPTURE) {\n\t\tmask = 0x0000;\n\t\tmask |= BIT(CPCAP_BIT_MIC1_RX_TIMESLOT0);\n\t\tmask |= BIT(CPCAP_BIT_MIC1_RX_TIMESLOT1);\n\t\tmask |= BIT(CPCAP_BIT_MIC1_RX_TIMESLOT2);\n\t\tmask |= BIT(CPCAP_BIT_MIC2_TIMESLOT0);\n\t\tmask |= BIT(CPCAP_BIT_MIC2_TIMESLOT1);\n\t\tmask |= BIT(CPCAP_BIT_MIC2_TIMESLOT2);\n\t\tval = 0x0000;\n\t\tif (channels >= 2)\n\t\t\tval = BIT(CPCAP_BIT_MIC1_RX_TIMESLOT0);\n\t\terr = regmap_update_bits(cpcap->regmap, reg_cdi, mask, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpcap_voice_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,\n\t\t\t\t      unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"Voice setup sysclk: clk_id=%u, freq=%u\",\n\t\tclk_id, freq);\n\treturn cpcap_set_sysclk(cpcap, CPCAP_DAI_VOICE, clk_id, freq);\n}\n\nstatic int cpcap_voice_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t   unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstatic const u16 mask = BIT(CPCAP_BIT_SMB_CDC) |\n\t\t\t\tBIT(CPCAP_BIT_CLK_INV) |\n\t\t\t\tBIT(CPCAP_BIT_FS_INV) |\n\t\t\t\tBIT(CPCAP_BIT_CDC_DIG_AUD_FS0) |\n\t\t\t\tBIT(CPCAP_BIT_CDC_DIG_AUD_FS1);\n\tu16 val = 0x0000;\n\tint err;\n\n\tdev_dbg(component->dev, \"Voice setup dai format (%08x)\", fmt);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tval &= ~BIT(CPCAP_BIT_SMB_CDC);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Voice dai fmt failed: CPCAP should be the provider\");\n\t\tval &= ~BIT(CPCAP_BIT_SMB_CDC);\n\t\tbreak;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval |= BIT(CPCAP_BIT_CLK_INV);\n\t\tval |= BIT(CPCAP_BIT_FS_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval |= BIT(CPCAP_BIT_CLK_INV);\n\t\tval &= ~BIT(CPCAP_BIT_FS_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval &= ~BIT(CPCAP_BIT_CLK_INV);\n\t\tval |= BIT(CPCAP_BIT_FS_INV);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tval &= ~BIT(CPCAP_BIT_CLK_INV);\n\t\tval &= ~BIT(CPCAP_BIT_FS_INV);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Voice dai fmt failed: unsupported clock invert mode\");\n\t\tbreak;\n\t}\n\n\tif (val & BIT(CPCAP_BIT_CLK_INV))\n\t\tval &= ~BIT(CPCAP_BIT_CLK_INV);\n\telse\n\t\tval |= BIT(CPCAP_BIT_CLK_INV);\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\tval |= BIT(CPCAP_BIT_CDC_DIG_AUD_FS0);\n\t\tval |= BIT(CPCAP_BIT_CDC_DIG_AUD_FS1);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tval |= BIT(CPCAP_BIT_CDC_DIG_AUD_FS0);\n\t\tval &= ~BIT(CPCAP_BIT_CDC_DIG_AUD_FS1);\n\t\tbreak;\n\t}\n\n\tdev_dbg(component->dev, \"Voice dai format: val=%04x\", val);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CDI, mask, val);\n\tif (err)\n\t\treturn err;\n\n\tcpcap->codec_format = val;\n\treturn 0;\n}\n\n\n \nstatic int cpcap_voice_call(struct cpcap_audio *cpcap, struct snd_soc_dai *dai,\n\t\t\t    bool voice_call)\n{\n\tint mask, err;\n\n\t \n\tmask = BIT(CPCAP_BIT_VAUDIO_MODE1);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_VAUDIOC,\n\t\t\t\t mask, voice_call ? mask : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmask = BIT(CPCAP_BIT_MIC1_MUX);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_TXI,\n\t\t\t\t mask, voice_call ? 0 : mask);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmask = BIT(CPCAP_BIT_MB_ON1L) | BIT(CPCAP_BIT_MB_ON1R) |\n\t\tBIT(CPCAP_BIT_MIC2_MUX) | BIT(CPCAP_BIT_MIC2_PGA_EN);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_TXI,\n\t\t\t\t mask, voice_call ? mask : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmask = BIT(CPCAP_BIT_A2_LDSP_L_EN) | BIT(CPCAP_BIT_A2_LDSP_R_EN);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_RXOA,\n\t\t\t\t mask, voice_call ? mask : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmask = BIT(CPCAP_BIT_PGA_CDC_EN);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_RXCOA,\n\t\t\t\t mask, voice_call ? mask : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dai) {\n\t\terr = snd_soc_dai_digital_mute(dai, !voice_call,\n\t\t\t\t\t       SNDRV_PCM_STREAM_PLAYBACK);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tmask = BIT(CPCAP_BIT_MIC2_CDC_EN) | BIT(CPCAP_BIT_CDC_EN_RX) |\n\t       BIT(CPCAP_BIT_AUDOHPF_1) | BIT(CPCAP_BIT_AUDOHPF_0) |\n\t       BIT(CPCAP_BIT_AUDIHPF_1) | BIT(CPCAP_BIT_AUDIHPF_0);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CC,\n\t\t\t\t mask, voice_call ? mask : 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmask = BIT(CPCAP_BIT_CDC_CLK_EN);\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CDI,\n\t\t\t\t mask, voice_call ? mask : 0);\n\n\treturn err;\n}\n\nstatic int cpcap_voice_set_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint err, ts_mask, mask;\n\tbool voice_call;\n\n\t \n\tif (tx_mask == 0 && rx_mask == 1 && slot_width == 8)\n\t\tvoice_call = true;\n\telse\n\t\tvoice_call = false;\n\n\tts_mask = 0x7 << CPCAP_BIT_MIC2_TIMESLOT0;\n\tts_mask |= 0x7 << CPCAP_BIT_MIC1_RX_TIMESLOT0;\n\n\tmask = (tx_mask & 0x7) << CPCAP_BIT_MIC2_TIMESLOT0;\n\tmask |= (rx_mask & 0x7) << CPCAP_BIT_MIC1_RX_TIMESLOT0;\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CDI,\n\t\t\t\t ts_mask, mask);\n\tif (err)\n\t\treturn err;\n\n\terr = cpcap_set_samprate(cpcap, CPCAP_DAI_VOICE, slot_width * 1000);\n\tif (err)\n\t\treturn err;\n\n\terr = cpcap_voice_call(cpcap, dai, voice_call);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int cpcap_voice_set_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tstatic const u16 reg = CPCAP_REG_RXCOA;\n\tstatic const u16 mask = BIT(CPCAP_BIT_CDC_SW);\n\tu16 val;\n\n\tif (mute)\n\t\tval = 0;\n\telse\n\t\tval = BIT(CPCAP_BIT_CDC_SW);\n\n\tdev_dbg(component->dev, \"Voice mute: %d\", mute);\n\treturn regmap_update_bits(cpcap->regmap, reg, mask, val);\n};\n\nstatic const struct snd_soc_dai_ops cpcap_dai_voice_ops = {\n\t.hw_params\t= cpcap_voice_hw_params,\n\t.set_sysclk\t= cpcap_voice_set_dai_sysclk,\n\t.set_fmt\t= cpcap_voice_set_dai_fmt,\n\t.set_tdm_slot\t= cpcap_voice_set_tdm_slot,\n\t.mute_stream\t= cpcap_voice_set_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver cpcap_dai[] = {\n{\n\t.id = 0,\n\t.name = \"cpcap-hifi\",\n\t.playback = {\n\t\t.stream_name = \"HiFi Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FORMAT_S24_LE,\n\t},\n\t.ops = &cpcap_dai_hifi_ops,\n},\n{\n\t.id = 1,\n\t.name = \"cpcap-voice\",\n\t.playback = {\n\t\t.stream_name = \"Voice Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Voice Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n\t.ops = &cpcap_dai_voice_ops,\n},\n};\n\nstatic int cpcap_dai_mux(struct cpcap_audio *cpcap, bool swap_dai_configuration)\n{\n\tu16 hifi_val, voice_val;\n\tu16 hifi_mask = BIT(CPCAP_BIT_DIG_AUD_IN_ST_DAC);\n\tu16 voice_mask = BIT(CPCAP_BIT_DIG_AUD_IN);\n\tint err;\n\n\n\n\tif (!swap_dai_configuration) {\n\t\t \n\t\tvoice_val = 0;\n\t\thifi_val = hifi_mask;\n\t} else {\n\t\t \n\t\tvoice_val = voice_mask;\n\t\thifi_val = 0;\n\t}\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_CDI,\n\t\t\t\t voice_mask, voice_val);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_update_bits(cpcap->regmap, CPCAP_REG_SDACDI,\n\t\t\t\t hifi_mask, hifi_val);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int cpcap_audio_reset(struct snd_soc_component *component,\n\t\t\t     bool swap_dai_configuration)\n{\n\tstruct cpcap_audio *cpcap = snd_soc_component_get_drvdata(component);\n\tint i, err = 0;\n\n\tdev_dbg(component->dev, \"init audio codec\");\n\n\tfor (i = 0; i < ARRAY_SIZE(cpcap_default_regs); i++) {\n\t\terr = regmap_update_bits(cpcap->regmap,\n\t\t\t\t\t cpcap_default_regs[i].reg,\n\t\t\t\t\t cpcap_default_regs[i].mask,\n\t\t\t\t\t cpcap_default_regs[i].val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = cpcap_dai_mux(cpcap, swap_dai_configuration);\n\tif (err)\n\t\treturn err;\n\n\terr = cpcap_set_sysclk(cpcap, CPCAP_DAI_HIFI, 0, 26000000);\n\tif (err)\n\t\treturn err;\n\terr = cpcap_set_sysclk(cpcap, CPCAP_DAI_VOICE, 0, 26000000);\n\tif (err)\n\t\treturn err;\n\n\terr = cpcap_set_samprate(cpcap, CPCAP_DAI_HIFI, 48000);\n\tif (err)\n\t\treturn err;\n\n\terr = cpcap_set_samprate(cpcap, CPCAP_DAI_VOICE, 48000);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int cpcap_soc_probe(struct snd_soc_component *component)\n{\n\tstruct cpcap_audio *cpcap;\n\tint err;\n\n\tcpcap = devm_kzalloc(component->dev, sizeof(*cpcap), GFP_KERNEL);\n\tif (!cpcap)\n\t\treturn -ENOMEM;\n\tsnd_soc_component_set_drvdata(component, cpcap);\n\tcpcap->component = component;\n\n\tcpcap->regmap = dev_get_regmap(component->dev->parent, NULL);\n\tif (!cpcap->regmap)\n\t\treturn -ENODEV;\n\tsnd_soc_component_init_regmap(component, cpcap->regmap);\n\n\terr = cpcap_get_vendor(component->dev, cpcap->regmap, &cpcap->vendor);\n\tif (err)\n\t\treturn err;\n\n\treturn cpcap_audio_reset(component, false);\n}\n\nstatic struct snd_soc_component_driver soc_codec_dev_cpcap = {\n\t.probe\t\t\t= cpcap_soc_probe,\n\t.controls\t\t= cpcap_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cpcap_snd_controls),\n\t.dapm_widgets\t\t= cpcap_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cpcap_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int cpcap_codec_probe(struct platform_device *pdev)\n{\n\tstruct device_node *codec_node =\n\t\tof_get_child_by_name(pdev->dev.parent->of_node, \"audio-codec\");\n\tif (!codec_node)\n\t\treturn -ENODEV;\n\n\tpdev->dev.of_node = codec_node;\n\n\treturn devm_snd_soc_register_component(&pdev->dev, &soc_codec_dev_cpcap,\n\t\t\t\t      cpcap_dai, ARRAY_SIZE(cpcap_dai));\n}\n\nstatic struct platform_driver cpcap_codec_driver = {\n\t.probe\t\t= cpcap_codec_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"cpcap-codec\",\n\t},\n};\nmodule_platform_driver(cpcap_codec_driver);\n\nMODULE_ALIAS(\"platform:cpcap-codec\");\nMODULE_DESCRIPTION(\"ASoC CPCAP codec driver\");\nMODULE_AUTHOR(\"Sebastian Reichel\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}