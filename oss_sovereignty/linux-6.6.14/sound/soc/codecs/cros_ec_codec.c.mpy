{
  "module_name": "cros_ec_codec.c",
  "hash_id": "75ae6aa0b4188ace15b50539162a9f53bc0853f013788a8cf349b5100f26dcdf",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cros_ec_codec.c",
  "human_readable_source": "\n \n\n#include <crypto/sha2.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_data/cros_ec_commands.h>\n#include <linux/platform_data/cros_ec_proto.h>\n#include <linux/platform_device.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\nstruct cros_ec_codec_priv {\n\tstruct device *dev;\n\tstruct cros_ec_device *ec_device;\n\n\t \n\tuint32_t ec_capabilities;\n\n\tuint64_t ec_shm_addr;\n\tuint32_t ec_shm_len;\n\n\tuint64_t ap_shm_phys_addr;\n\tuint32_t ap_shm_len;\n\tuint64_t ap_shm_addr;\n\tuint64_t ap_shm_last_alloc;\n\n\t \n\tatomic_t dmic_probed;\n\n\t \n\tuint32_t i2s_rx_bclk_ratio;\n\n\t \n\tbool wov_enabled;\n\tuint8_t *wov_audio_shm_p;\n\tuint32_t wov_audio_shm_len;\n\tuint8_t wov_audio_shm_type;\n\tuint8_t *wov_lang_shm_p;\n\tuint32_t wov_lang_shm_len;\n\tuint8_t wov_lang_shm_type;\n\n\tstruct mutex wov_dma_lock;\n\tuint8_t wov_buf[64000];\n\tuint32_t wov_rp, wov_wp;\n\tsize_t wov_dma_offset;\n\tbool wov_burst_read;\n\tstruct snd_pcm_substream *wov_substream;\n\tstruct delayed_work wov_copy_work;\n\tstruct notifier_block wov_notifier;\n};\n\nstatic int ec_codec_capable(struct cros_ec_codec_priv *priv, uint8_t cap)\n{\n\treturn priv->ec_capabilities & BIT(cap);\n}\n\nstatic int send_ec_host_command(struct cros_ec_device *ec_dev, uint32_t cmd,\n\t\t\t\tuint8_t *out, size_t outsize,\n\t\t\t\tuint8_t *in, size_t insize)\n{\n\tint ret;\n\tstruct cros_ec_command *msg;\n\n\tmsg = kmalloc(sizeof(*msg) + max(outsize, insize), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = 0;\n\tmsg->command = cmd;\n\tmsg->outsize = outsize;\n\tmsg->insize = insize;\n\n\tif (outsize)\n\t\tmemcpy(msg->data, out, outsize);\n\n\tret = cros_ec_cmd_xfer_status(ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (in && insize)\n\t\tmemcpy(in, msg->data, insize);\n\n\tret = 0;\nerror:\n\tkfree(msg);\n\treturn ret;\n}\n\nstatic int dmic_get_gain(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct ec_param_ec_codec_dmic p;\n\tstruct ec_response_ec_codec_dmic_get_gain_idx r;\n\tint ret;\n\n\tp.cmd = EC_CODEC_DMIC_GET_GAIN_IDX;\n\tp.get_gain_idx_param.channel = EC_CODEC_DMIC_CHANNEL_0;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_DMIC,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret < 0)\n\t\treturn ret;\n\tucontrol->value.integer.value[0] = r.gain;\n\n\tp.cmd = EC_CODEC_DMIC_GET_GAIN_IDX;\n\tp.get_gain_idx_param.channel = EC_CODEC_DMIC_CHANNEL_1;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_DMIC,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret < 0)\n\t\treturn ret;\n\tucontrol->value.integer.value[1] = r.gain;\n\n\treturn 0;\n}\n\nstatic int dmic_put_gain(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *control =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tint max_dmic_gain = control->max;\n\tint left = ucontrol->value.integer.value[0];\n\tint right = ucontrol->value.integer.value[1];\n\tstruct ec_param_ec_codec_dmic p;\n\tint ret;\n\n\tif (left > max_dmic_gain || right > max_dmic_gain)\n\t\treturn -EINVAL;\n\n\tdev_dbg(component->dev, \"set mic gain to %u, %u\\n\", left, right);\n\n\tp.cmd = EC_CODEC_DMIC_SET_GAIN_IDX;\n\tp.set_gain_idx_param.channel = EC_CODEC_DMIC_CHANNEL_0;\n\tp.set_gain_idx_param.gain = left;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_DMIC,\n\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tp.cmd = EC_CODEC_DMIC_SET_GAIN_IDX;\n\tp.set_gain_idx_param.channel = EC_CODEC_DMIC_CHANNEL_1;\n\tp.set_gain_idx_param.gain = right;\n\treturn send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_DMIC,\n\t\t\t\t    (uint8_t *)&p, sizeof(p), NULL, 0);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dmic_gain_tlv, 0, 100, 0);\n\nenum {\n\tDMIC_CTL_GAIN = 0,\n};\n\nstatic struct snd_kcontrol_new dmic_controls[] = {\n\t[DMIC_CTL_GAIN] =\n\t\tSOC_DOUBLE_EXT_TLV(\"EC Mic Gain\", SND_SOC_NOPM, SND_SOC_NOPM,\n\t\t\t\t   0, 0, 0, dmic_get_gain, dmic_put_gain,\n\t\t\t\t   dmic_gain_tlv),\n};\n\nstatic int dmic_probe(struct snd_soc_component *component)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct device *dev = priv->dev;\n\tstruct soc_mixer_control *control;\n\tstruct ec_param_ec_codec_dmic p;\n\tstruct ec_response_ec_codec_dmic_get_max_gain r;\n\tint ret;\n\n\tif (!atomic_add_unless(&priv->dmic_probed, 1, 1))\n\t\treturn 0;\n\n\tp.cmd = EC_CODEC_DMIC_GET_MAX_GAIN;\n\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_DMIC,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"get_max_gain() unsupported\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"max gain = %d\\n\", r.max_gain);\n\n\tcontrol = (struct soc_mixer_control *)\n\t\tdmic_controls[DMIC_CTL_GAIN].private_value;\n\tcontrol->max = r.max_gain;\n\tcontrol->platform_max = r.max_gain;\n\n\treturn snd_soc_add_component_controls(component,\n\t\t\t&dmic_controls[DMIC_CTL_GAIN], 1);\n}\n\nstatic int i2s_rx_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct ec_param_ec_codec_i2s_rx p;\n\tenum ec_codec_i2s_rx_sample_depth depth;\n\tuint32_t bclk;\n\tint ret;\n\n\tif (params_rate(params) != 48000)\n\t\treturn -EINVAL;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tdepth = EC_CODEC_I2S_RX_SAMPLE_DEPTH_16;\n\t\tbreak;\n\tcase 24:\n\t\tdepth = EC_CODEC_I2S_RX_SAMPLE_DEPTH_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"set depth to %u\\n\", depth);\n\n\tp.cmd = EC_CODEC_I2S_RX_SET_SAMPLE_DEPTH;\n\tp.set_sample_depth_param.depth = depth;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_I2S_RX,\n\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (priv->i2s_rx_bclk_ratio)\n\t\tbclk = params_rate(params) * priv->i2s_rx_bclk_ratio;\n\telse\n\t\tbclk = snd_soc_params_to_bclk(params);\n\n\tdev_dbg(component->dev, \"set bclk to %u\\n\", bclk);\n\n\tp.cmd = EC_CODEC_I2S_RX_SET_BCLK;\n\tp.set_bclk_param.bclk = bclk;\n\treturn send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_I2S_RX,\n\t\t\t\t    (uint8_t *)&p, sizeof(p), NULL, 0);\n}\n\nstatic int i2s_rx_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tpriv->i2s_rx_bclk_ratio = ratio;\n\treturn 0;\n}\n\nstatic int i2s_rx_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct ec_param_ec_codec_i2s_rx p;\n\tenum ec_codec_i2s_rx_daifmt daifmt;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tdaifmt = EC_CODEC_I2S_RX_DAIFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tdaifmt = EC_CODEC_I2S_RX_DAIFMT_RIGHT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tdaifmt = EC_CODEC_I2S_RX_DAIFMT_LEFT_J;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"set format to %u\\n\", daifmt);\n\n\tp.cmd = EC_CODEC_I2S_RX_SET_DAIFMT;\n\tp.set_daifmt_param.daifmt = daifmt;\n\treturn send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_I2S_RX,\n\t\t\t\t    (uint8_t *)&p, sizeof(p), NULL, 0);\n}\n\nstatic const struct snd_soc_dai_ops i2s_rx_dai_ops = {\n\t.hw_params = i2s_rx_hw_params,\n\t.set_fmt = i2s_rx_set_fmt,\n\t.set_bclk_ratio = i2s_rx_set_bclk_ratio,\n};\n\nstatic int i2s_rx_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct ec_param_ec_codec_i2s_rx p = {};\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tdev_dbg(component->dev, \"enable I2S RX\\n\");\n\t\tp.cmd = EC_CODEC_I2S_RX_ENABLE;\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tdev_dbg(component->dev, \"disable I2S RX\\n\");\n\t\tp.cmd = EC_CODEC_I2S_RX_DISABLE;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_I2S_RX,\n\t\t\t\t    (uint8_t *)&p, sizeof(p), NULL, 0);\n}\n\nstatic struct snd_soc_dapm_widget i2s_rx_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC\"),\n\tSND_SOC_DAPM_SUPPLY(\"I2S RX Enable\", SND_SOC_NOPM, 0, 0, i2s_rx_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_AIF_OUT(\"I2S RX\", \"I2S Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic struct snd_soc_dapm_route i2s_rx_dapm_routes[] = {\n\t{\"I2S RX\", NULL, \"DMIC\"},\n\t{\"I2S RX\", NULL, \"I2S RX Enable\"},\n};\n\nstatic struct snd_soc_dai_driver i2s_rx_dai_driver = {\n\t.name = \"EC Codec I2S RX\",\n\t.capture = {\n\t\t.stream_name = \"I2S Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_48000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE,\n\t},\n\t.ops = &i2s_rx_dai_ops,\n};\n\nstatic int i2s_rx_probe(struct snd_soc_component *component)\n{\n\treturn dmic_probe(component);\n}\n\nstatic const struct snd_soc_component_driver i2s_rx_component_driver = {\n\t.probe\t\t\t= i2s_rx_probe,\n\t.dapm_widgets\t\t= i2s_rx_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(i2s_rx_dapm_widgets),\n\t.dapm_routes\t\t= i2s_rx_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(i2s_rx_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\nstatic void *wov_map_shm(struct cros_ec_codec_priv *priv,\n\t\t\t uint8_t shm_id, uint32_t *len, uint8_t *type)\n{\n\tstruct ec_param_ec_codec p;\n\tstruct ec_response_ec_codec_get_shm_addr r;\n\tuint32_t req, offset;\n\n\tp.cmd = EC_CODEC_GET_SHM_ADDR;\n\tp.get_shm_addr_param.shm_id = shm_id;\n\tif (send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC,\n\t\t\t\t (uint8_t *)&p, sizeof(p),\n\t\t\t\t (uint8_t *)&r, sizeof(r)) < 0) {\n\t\tdev_err(priv->dev, \"failed to EC_CODEC_GET_SHM_ADDR\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(priv->dev, \"phys_addr=%#llx, len=%#x\\n\", r.phys_addr, r.len);\n\n\t*len = r.len;\n\t*type = r.type;\n\n\tswitch (r.type) {\n\tcase EC_CODEC_SHM_TYPE_EC_RAM:\n\t\treturn (void __force *)devm_ioremap_wc(priv->dev,\n\t\t\t\tr.phys_addr + priv->ec_shm_addr, r.len);\n\tcase EC_CODEC_SHM_TYPE_SYSTEM_RAM:\n\t\tif (r.phys_addr) {\n\t\t\tdev_err(priv->dev, \"unknown status\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\treq = round_up(r.len, PAGE_SIZE);\n\t\tdev_dbg(priv->dev, \"round up from %u to %u\\n\", r.len, req);\n\n\t\tif (priv->ap_shm_last_alloc + req >\n\t\t    priv->ap_shm_phys_addr + priv->ap_shm_len) {\n\t\t\tdev_err(priv->dev, \"insufficient space for AP SHM\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tdev_dbg(priv->dev, \"alloc AP SHM addr=%#llx, len=%#x\\n\",\n\t\t\tpriv->ap_shm_last_alloc, req);\n\n\t\tp.cmd = EC_CODEC_SET_SHM_ADDR;\n\t\tp.set_shm_addr_param.phys_addr = priv->ap_shm_last_alloc;\n\t\tp.set_shm_addr_param.len = req;\n\t\tp.set_shm_addr_param.shm_id = shm_id;\n\t\tif (send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC,\n\t\t\t\t\t (uint8_t *)&p, sizeof(p),\n\t\t\t\t\t NULL, 0) < 0) {\n\t\t\tdev_err(priv->dev, \"failed to EC_CODEC_SET_SHM_ADDR\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\toffset = priv->ap_shm_last_alloc - priv->ap_shm_phys_addr;\n\t\tpriv->ap_shm_last_alloc += req;\n\n\t\treturn (void *)(uintptr_t)(priv->ap_shm_addr + offset);\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic bool wov_queue_full(struct cros_ec_codec_priv *priv)\n{\n\treturn ((priv->wov_wp + 1) % sizeof(priv->wov_buf)) == priv->wov_rp;\n}\n\nstatic size_t wov_queue_size(struct cros_ec_codec_priv *priv)\n{\n\tif (priv->wov_wp >= priv->wov_rp)\n\t\treturn priv->wov_wp - priv->wov_rp;\n\telse\n\t\treturn sizeof(priv->wov_buf) - priv->wov_rp + priv->wov_wp;\n}\n\nstatic void wov_queue_dequeue(struct cros_ec_codec_priv *priv, size_t len)\n{\n\tstruct snd_pcm_runtime *runtime = priv->wov_substream->runtime;\n\tsize_t req;\n\n\twhile (len) {\n\t\treq = min(len, runtime->dma_bytes - priv->wov_dma_offset);\n\t\tif (priv->wov_wp >= priv->wov_rp)\n\t\t\treq = min(req, (size_t)priv->wov_wp - priv->wov_rp);\n\t\telse\n\t\t\treq = min(req, sizeof(priv->wov_buf) - priv->wov_rp);\n\n\t\tmemcpy(runtime->dma_area + priv->wov_dma_offset,\n\t\t       priv->wov_buf + priv->wov_rp, req);\n\n\t\tpriv->wov_dma_offset += req;\n\t\tif (priv->wov_dma_offset == runtime->dma_bytes)\n\t\t\tpriv->wov_dma_offset = 0;\n\n\t\tpriv->wov_rp += req;\n\t\tif (priv->wov_rp == sizeof(priv->wov_buf))\n\t\t\tpriv->wov_rp = 0;\n\n\t\tlen -= req;\n\t}\n\n\tsnd_pcm_period_elapsed(priv->wov_substream);\n}\n\nstatic void wov_queue_try_dequeue(struct cros_ec_codec_priv *priv)\n{\n\tsize_t period_bytes = snd_pcm_lib_period_bytes(priv->wov_substream);\n\n\twhile (period_bytes && wov_queue_size(priv) >= period_bytes) {\n\t\twov_queue_dequeue(priv, period_bytes);\n\t\tperiod_bytes = snd_pcm_lib_period_bytes(priv->wov_substream);\n\t}\n}\n\nstatic void wov_queue_enqueue(struct cros_ec_codec_priv *priv,\n\t\t\t      uint8_t *addr, size_t len, bool iomem)\n{\n\tsize_t req;\n\n\twhile (len) {\n\t\tif (wov_queue_full(priv)) {\n\t\t\twov_queue_try_dequeue(priv);\n\n\t\t\tif (wov_queue_full(priv)) {\n\t\t\t\tdev_err(priv->dev, \"overrun detected\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (priv->wov_wp >= priv->wov_rp)\n\t\t\treq = sizeof(priv->wov_buf) - priv->wov_wp;\n\t\telse\n\t\t\t \n\t\t\treq = priv->wov_rp - priv->wov_wp - 1;\n\t\treq = min(req, len);\n\n\t\tif (iomem)\n\t\t\tmemcpy_fromio(priv->wov_buf + priv->wov_wp,\n\t\t\t\t      (void __force __iomem *)addr, req);\n\t\telse\n\t\t\tmemcpy(priv->wov_buf + priv->wov_wp, addr, req);\n\n\t\tpriv->wov_wp += req;\n\t\tif (priv->wov_wp == sizeof(priv->wov_buf))\n\t\t\tpriv->wov_wp = 0;\n\n\t\taddr += req;\n\t\tlen -= req;\n\t}\n\n\twov_queue_try_dequeue(priv);\n}\n\nstatic int wov_read_audio_shm(struct cros_ec_codec_priv *priv)\n{\n\tstruct ec_param_ec_codec_wov p;\n\tstruct ec_response_ec_codec_wov_read_audio_shm r;\n\tint ret;\n\n\tp.cmd = EC_CODEC_WOV_READ_AUDIO_SHM;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to EC_CODEC_WOV_READ_AUDIO_SHM\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!r.len)\n\t\tdev_dbg(priv->dev, \"no data, sleep\\n\");\n\telse\n\t\twov_queue_enqueue(priv, priv->wov_audio_shm_p + r.offset, r.len,\n\t\t\tpriv->wov_audio_shm_type == EC_CODEC_SHM_TYPE_EC_RAM);\n\treturn -EAGAIN;\n}\n\nstatic int wov_read_audio(struct cros_ec_codec_priv *priv)\n{\n\tstruct ec_param_ec_codec_wov p;\n\tstruct ec_response_ec_codec_wov_read_audio r;\n\tint remain = priv->wov_burst_read ? 16000 : 320;\n\tint ret;\n\n\twhile (remain >= 0) {\n\t\tp.cmd = EC_CODEC_WOV_READ_AUDIO;\n\t\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to EC_CODEC_WOV_READ_AUDIO\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!r.len) {\n\t\t\tdev_dbg(priv->dev, \"no data, sleep\\n\");\n\t\t\tpriv->wov_burst_read = false;\n\t\t\tbreak;\n\t\t}\n\n\t\twov_queue_enqueue(priv, r.buf, r.len, false);\n\t\tremain -= r.len;\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic void wov_copy_work(struct work_struct *w)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tcontainer_of(w, struct cros_ec_codec_priv, wov_copy_work.work);\n\tint ret;\n\n\tmutex_lock(&priv->wov_dma_lock);\n\tif (!priv->wov_substream) {\n\t\tdev_warn(priv->dev, \"no pcm substream\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (ec_codec_capable(priv, EC_CODEC_CAP_WOV_AUDIO_SHM))\n\t\tret = wov_read_audio_shm(priv);\n\telse\n\t\tret = wov_read_audio(priv);\n\n\tif (ret == -EAGAIN)\n\t\tschedule_delayed_work(&priv->wov_copy_work,\n\t\t\t\t      msecs_to_jiffies(10));\n\telse if (ret)\n\t\tdev_err(priv->dev, \"failed to read audio data\\n\");\nleave:\n\tmutex_unlock(&priv->wov_dma_lock);\n}\n\nstatic int wov_enable_get(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *c = snd_soc_kcontrol_component(kcontrol);\n\tstruct cros_ec_codec_priv *priv = snd_soc_component_get_drvdata(c);\n\n\tucontrol->value.integer.value[0] = priv->wov_enabled;\n\treturn 0;\n}\n\nstatic int wov_enable_put(struct snd_kcontrol *kcontrol,\n\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *c = snd_soc_kcontrol_component(kcontrol);\n\tstruct cros_ec_codec_priv *priv = snd_soc_component_get_drvdata(c);\n\tint enabled = ucontrol->value.integer.value[0];\n\tstruct ec_param_ec_codec_wov p;\n\tint ret;\n\n\tif (priv->wov_enabled != enabled) {\n\t\tif (enabled)\n\t\t\tp.cmd = EC_CODEC_WOV_ENABLE;\n\t\telse\n\t\t\tp.cmd = EC_CODEC_WOV_DISABLE;\n\n\t\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"failed to %s wov\\n\",\n\t\t\t\tenabled ? \"enable\" : \"disable\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tpriv->wov_enabled = enabled;\n\t}\n\n\treturn 0;\n}\n\nstatic int wov_set_lang_shm(struct cros_ec_codec_priv *priv,\n\t\t\t    uint8_t *buf, size_t size, uint8_t *digest)\n{\n\tstruct ec_param_ec_codec_wov p;\n\tstruct ec_param_ec_codec_wov_set_lang_shm *pp = &p.set_lang_shm_param;\n\tint ret;\n\n\tif (size > priv->wov_lang_shm_len) {\n\t\tdev_err(priv->dev, \"no enough SHM size: %d\\n\",\n\t\t\tpriv->wov_lang_shm_len);\n\t\treturn -EIO;\n\t}\n\n\tswitch (priv->wov_lang_shm_type) {\n\tcase EC_CODEC_SHM_TYPE_EC_RAM:\n\t\tmemcpy_toio((void __force __iomem *)priv->wov_lang_shm_p,\n\t\t\t    buf, size);\n\t\tmemset_io((void __force __iomem *)priv->wov_lang_shm_p + size,\n\t\t\t  0, priv->wov_lang_shm_len - size);\n\t\tbreak;\n\tcase EC_CODEC_SHM_TYPE_SYSTEM_RAM:\n\t\tmemcpy(priv->wov_lang_shm_p, buf, size);\n\t\tmemset(priv->wov_lang_shm_p + size, 0,\n\t\t       priv->wov_lang_shm_len - size);\n\n\t\t \n\t\twmb();\n\t\tbreak;\n\t}\n\n\tp.cmd = EC_CODEC_WOV_SET_LANG_SHM;\n\tmemcpy(pp->hash, digest, SHA256_DIGEST_SIZE);\n\tpp->total_len = size;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to EC_CODEC_WOV_SET_LANG_SHM\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wov_set_lang(struct cros_ec_codec_priv *priv,\n\t\t\tuint8_t *buf, size_t size, uint8_t *digest)\n{\n\tstruct ec_param_ec_codec_wov p;\n\tstruct ec_param_ec_codec_wov_set_lang *pp = &p.set_lang_param;\n\tsize_t i, req;\n\tint ret;\n\n\tfor (i = 0; i < size; i += req) {\n\t\treq = min(size - i, ARRAY_SIZE(pp->buf));\n\n\t\tp.cmd = EC_CODEC_WOV_SET_LANG;\n\t\tmemcpy(pp->hash, digest, SHA256_DIGEST_SIZE);\n\t\tpp->total_len = size;\n\t\tpp->offset = i;\n\t\tmemcpy(pp->buf, buf + i, req);\n\t\tpp->len = req;\n\t\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"failed to EC_CODEC_WOV_SET_LANG\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wov_hotword_model_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t const unsigned int __user *bytes,\n\t\t\t\t unsigned int size)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct ec_param_ec_codec_wov p;\n\tstruct ec_response_ec_codec_wov_get_lang r;\n\tuint8_t digest[SHA256_DIGEST_SIZE];\n\tuint8_t *buf;\n\tint ret;\n\n\t \n\tbytes += 2;\n\tsize -= 8;\n\n\tdev_dbg(priv->dev, \"%s: size=%d\\n\", __func__, size);\n\n\tbuf = memdup_user(bytes, size);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tsha256(buf, size, digest);\n\tdev_dbg(priv->dev, \"hash=%*phN\\n\", SHA256_DIGEST_SIZE, digest);\n\n\tp.cmd = EC_CODEC_WOV_GET_LANG;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_WOV,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret)\n\t\tgoto leave;\n\n\tif (memcmp(digest, r.hash, SHA256_DIGEST_SIZE) == 0) {\n\t\tdev_dbg(priv->dev, \"not updated\");\n\t\tgoto leave;\n\t}\n\n\tif (ec_codec_capable(priv, EC_CODEC_CAP_WOV_LANG_SHM))\n\t\tret = wov_set_lang_shm(priv, buf, size, digest);\n\telse\n\t\tret = wov_set_lang(priv, buf, size, digest);\n\nleave:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic struct snd_kcontrol_new wov_controls[] = {\n\tSOC_SINGLE_BOOL_EXT(\"Wake-on-Voice Switch\", 0,\n\t\t\t    wov_enable_get, wov_enable_put),\n\tSND_SOC_BYTES_TLV(\"Hotword Model\", 0x11000, NULL,\n\t\t\t  wov_hotword_model_put),\n};\n\nstatic struct snd_soc_dai_driver wov_dai_driver = {\n\t.name = \"Wake on Voice\",\n\t.capture = {\n\t\t.stream_name = \"WoV Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.rates = SNDRV_PCM_RATE_16000,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t},\n};\n\nstatic int wov_host_event(struct notifier_block *nb,\n\t\t\t  unsigned long queued_during_suspend, void *notify)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tcontainer_of(nb, struct cros_ec_codec_priv, wov_notifier);\n\tu32 host_event;\n\n\tdev_dbg(priv->dev, \"%s\\n\", __func__);\n\n\thost_event = cros_ec_get_host_event(priv->ec_device);\n\tif (host_event & EC_HOST_EVENT_MASK(EC_HOST_EVENT_WOV)) {\n\t\tschedule_delayed_work(&priv->wov_copy_work, 0);\n\t\treturn NOTIFY_OK;\n\t} else {\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic int wov_probe(struct snd_soc_component *component)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tmutex_init(&priv->wov_dma_lock);\n\tINIT_DELAYED_WORK(&priv->wov_copy_work, wov_copy_work);\n\n\tpriv->wov_notifier.notifier_call = wov_host_event;\n\tret = blocking_notifier_chain_register(\n\t\t\t&priv->ec_device->event_notifier, &priv->wov_notifier);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ec_codec_capable(priv, EC_CODEC_CAP_WOV_LANG_SHM)) {\n\t\tpriv->wov_lang_shm_p = wov_map_shm(priv,\n\t\t\t\tEC_CODEC_SHM_ID_WOV_LANG,\n\t\t\t\t&priv->wov_lang_shm_len,\n\t\t\t\t&priv->wov_lang_shm_type);\n\t\tif (!priv->wov_lang_shm_p)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (ec_codec_capable(priv, EC_CODEC_CAP_WOV_AUDIO_SHM)) {\n\t\tpriv->wov_audio_shm_p = wov_map_shm(priv,\n\t\t\t\tEC_CODEC_SHM_ID_WOV_AUDIO,\n\t\t\t\t&priv->wov_audio_shm_len,\n\t\t\t\t&priv->wov_audio_shm_type);\n\t\tif (!priv->wov_audio_shm_p)\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn dmic_probe(component);\n}\n\nstatic void wov_remove(struct snd_soc_component *component)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tblocking_notifier_chain_unregister(\n\t\t\t&priv->ec_device->event_notifier, &priv->wov_notifier);\n}\n\nstatic int wov_pcm_open(struct snd_soc_component *component,\n\t\t\tstruct snd_pcm_substream *substream)\n{\n\tstatic const struct snd_pcm_hardware hw_param = {\n\t\t.info = SNDRV_PCM_INFO_MMAP |\n\t\t\tSNDRV_PCM_INFO_INTERLEAVED |\n\t\t\tSNDRV_PCM_INFO_MMAP_VALID,\n\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t.rates = SNDRV_PCM_RATE_16000,\n\t\t.channels_min = 1,\n\t\t.channels_max = 1,\n\t\t.period_bytes_min = PAGE_SIZE,\n\t\t.period_bytes_max = 0x20000 / 8,\n\t\t.periods_min = 8,\n\t\t.periods_max = 8,\n\t\t.buffer_bytes_max = 0x20000,\n\t};\n\n\treturn snd_soc_set_runtime_hwparams(substream, &hw_param);\n}\n\nstatic int wov_pcm_hw_params(struct snd_soc_component *component,\n\t\t\t     struct snd_pcm_substream *substream,\n\t\t\t     struct snd_pcm_hw_params *hw_params)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&priv->wov_dma_lock);\n\tpriv->wov_substream = substream;\n\tpriv->wov_rp = priv->wov_wp = 0;\n\tpriv->wov_dma_offset = 0;\n\tpriv->wov_burst_read = true;\n\tmutex_unlock(&priv->wov_dma_lock);\n\n\treturn 0;\n}\n\nstatic int wov_pcm_hw_free(struct snd_soc_component *component,\n\t\t\t   struct snd_pcm_substream *substream)\n{\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&priv->wov_dma_lock);\n\twov_queue_dequeue(priv, wov_queue_size(priv));\n\tpriv->wov_substream = NULL;\n\tmutex_unlock(&priv->wov_dma_lock);\n\n\tcancel_delayed_work_sync(&priv->wov_copy_work);\n\n\treturn 0;\n}\n\nstatic snd_pcm_uframes_t wov_pcm_pointer(struct snd_soc_component *component,\n\t\t\t\t\t struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct cros_ec_codec_priv *priv =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\treturn bytes_to_frames(runtime, priv->wov_dma_offset);\n}\n\nstatic int wov_pcm_new(struct snd_soc_component *component,\n\t\t       struct snd_soc_pcm_runtime *rtd)\n{\n\tsnd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_VMALLOC,\n\t\t\t\t       NULL, 0, 0);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver wov_component_driver = {\n\t.probe\t\t= wov_probe,\n\t.remove\t\t= wov_remove,\n\t.controls\t= wov_controls,\n\t.num_controls\t= ARRAY_SIZE(wov_controls),\n\t.open\t\t= wov_pcm_open,\n\t.hw_params\t= wov_pcm_hw_params,\n\t.hw_free\t= wov_pcm_hw_free,\n\t.pointer\t= wov_pcm_pointer,\n\t.pcm_construct\t= wov_pcm_new,\n};\n\nstatic int cros_ec_codec_platform_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_device *ec_device = dev_get_drvdata(pdev->dev.parent);\n\tstruct cros_ec_codec_priv *priv;\n\tstruct ec_param_ec_codec p;\n\tstruct ec_response_ec_codec_get_capabilities r;\n\tint ret;\n#ifdef CONFIG_OF\n\tstruct device_node *node;\n\tstruct resource res;\n\tu64 ec_shm_size;\n\tconst __be32 *regaddr_p;\n#endif\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_OF\n\tregaddr_p = of_get_address(dev->of_node, 0, &ec_shm_size, NULL);\n\tif (regaddr_p) {\n\t\tpriv->ec_shm_addr = of_read_number(regaddr_p, 2);\n\t\tpriv->ec_shm_len = ec_shm_size;\n\n\t\tdev_dbg(dev, \"ec_shm_addr=%#llx len=%#x\\n\",\n\t\t\tpriv->ec_shm_addr, priv->ec_shm_len);\n\t}\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (node) {\n\t\tret = of_address_to_resource(node, 0, &res);\n\t\tif (!ret) {\n\t\t\tpriv->ap_shm_phys_addr = res.start;\n\t\t\tpriv->ap_shm_len = resource_size(&res);\n\t\t\tpriv->ap_shm_addr =\n\t\t\t\t(uint64_t)(uintptr_t)devm_ioremap_wc(\n\t\t\t\t\tdev, priv->ap_shm_phys_addr,\n\t\t\t\t\tpriv->ap_shm_len);\n\t\t\tpriv->ap_shm_last_alloc = priv->ap_shm_phys_addr;\n\n\t\t\tdev_dbg(dev, \"ap_shm_phys_addr=%#llx len=%#x\\n\",\n\t\t\t\tpriv->ap_shm_phys_addr, priv->ap_shm_len);\n\t\t}\n\t\tof_node_put(node);\n\t}\n#endif\n\n\tpriv->dev = dev;\n\tpriv->ec_device = ec_device;\n\tatomic_set(&priv->dmic_probed, 0);\n\n\tp.cmd = EC_CODEC_GET_CAPABILITIES;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC,\n\t\t\t\t   (uint8_t *)&p, sizeof(p),\n\t\t\t\t   (uint8_t *)&r, sizeof(r));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to EC_CODEC_GET_CAPABILITIES\\n\");\n\t\treturn ret;\n\t}\n\tpriv->ec_capabilities = r.capabilities;\n\n\t \n\tp.cmd = EC_CODEC_I2S_RX_RESET;\n\tret = send_ec_host_command(priv->ec_device, EC_CMD_EC_CODEC_I2S_RX,\n\t\t\t\t   (uint8_t *)&p, sizeof(p), NULL, 0);\n\tif (ret == -ENOPROTOOPT) {\n\t\tdev_info(dev,\n\t\t\t \"Missing reset command. Please update EC firmware.\\n\");\n\t} else if (ret) {\n\t\tdev_err(dev, \"failed to EC_CODEC_I2S_RESET: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tret = devm_snd_soc_register_component(dev, &i2s_rx_component_driver,\n\t\t\t\t\t      &i2s_rx_dai_driver, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_snd_soc_register_component(dev, &wov_component_driver,\n\t\t\t\t\t       &wov_dai_driver, 1);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id cros_ec_codec_of_match[] = {\n\t{ .compatible = \"google,cros-ec-codec\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cros_ec_codec_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id cros_ec_codec_acpi_id[] = {\n\t{ \"GOOG0013\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, cros_ec_codec_acpi_id);\n#endif\n\nstatic struct platform_driver cros_ec_codec_platform_driver = {\n\t.driver = {\n\t\t.name = \"cros-ec-codec\",\n\t\t.of_match_table = of_match_ptr(cros_ec_codec_of_match),\n\t\t.acpi_match_table = ACPI_PTR(cros_ec_codec_acpi_id),\n\t},\n\t.probe = cros_ec_codec_platform_probe,\n};\n\nmodule_platform_driver(cros_ec_codec_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ChromeOS EC codec driver\");\nMODULE_AUTHOR(\"Cheng-Yi Chiang <cychiang@chromium.org>\");\nMODULE_ALIAS(\"platform:cros-ec-codec\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}