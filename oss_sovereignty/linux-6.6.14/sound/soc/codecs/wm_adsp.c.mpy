{
  "module_name": "wm_adsp.c",
  "hash_id": "bf99f572ebed31d40074cb2879177a1c35da71d0b3f6d6a4e9c8697f0d3a8265",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm_adsp.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/list.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm_adsp.h\"\n\n#define adsp_crit(_dsp, fmt, ...) \\\n\tdev_crit(_dsp->cs_dsp.dev, \"%s: \" fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)\n#define adsp_err(_dsp, fmt, ...) \\\n\tdev_err(_dsp->cs_dsp.dev, \"%s: \" fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)\n#define adsp_warn(_dsp, fmt, ...) \\\n\tdev_warn(_dsp->cs_dsp.dev, \"%s: \" fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)\n#define adsp_info(_dsp, fmt, ...) \\\n\tdev_info(_dsp->cs_dsp.dev, \"%s: \" fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)\n#define adsp_dbg(_dsp, fmt, ...) \\\n\tdev_dbg(_dsp->cs_dsp.dev, \"%s: \" fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)\n\n#define compr_err(_obj, fmt, ...) \\\n\tadsp_err(_obj->dsp, \"%s: \" fmt, _obj->name ? _obj->name : \"legacy\", \\\n\t\t ##__VA_ARGS__)\n#define compr_dbg(_obj, fmt, ...) \\\n\tadsp_dbg(_obj->dsp, \"%s: \" fmt, _obj->name ? _obj->name : \"legacy\", \\\n\t\t ##__VA_ARGS__)\n\n#define ADSP_MAX_STD_CTRL_SIZE               512\n\nstatic const struct cs_dsp_client_ops wm_adsp1_client_ops;\nstatic const struct cs_dsp_client_ops wm_adsp2_client_ops;\n\n#define WM_ADSP_FW_MBC_VSS  0\n#define WM_ADSP_FW_HIFI     1\n#define WM_ADSP_FW_TX       2\n#define WM_ADSP_FW_TX_SPK   3\n#define WM_ADSP_FW_RX       4\n#define WM_ADSP_FW_RX_ANC   5\n#define WM_ADSP_FW_CTRL     6\n#define WM_ADSP_FW_ASR      7\n#define WM_ADSP_FW_TRACE    8\n#define WM_ADSP_FW_SPK_PROT 9\n#define WM_ADSP_FW_SPK_CALI 10\n#define WM_ADSP_FW_SPK_DIAG 11\n#define WM_ADSP_FW_MISC     12\n\n#define WM_ADSP_NUM_FW      13\n\nstatic const char *wm_adsp_fw_text[WM_ADSP_NUM_FW] = {\n\t[WM_ADSP_FW_MBC_VSS] =  \"MBC/VSS\",\n\t[WM_ADSP_FW_HIFI] =     \"MasterHiFi\",\n\t[WM_ADSP_FW_TX] =       \"Tx\",\n\t[WM_ADSP_FW_TX_SPK] =   \"Tx Speaker\",\n\t[WM_ADSP_FW_RX] =       \"Rx\",\n\t[WM_ADSP_FW_RX_ANC] =   \"Rx ANC\",\n\t[WM_ADSP_FW_CTRL] =     \"Voice Ctrl\",\n\t[WM_ADSP_FW_ASR] =      \"ASR Assist\",\n\t[WM_ADSP_FW_TRACE] =    \"Dbg Trace\",\n\t[WM_ADSP_FW_SPK_PROT] = \"Protection\",\n\t[WM_ADSP_FW_SPK_CALI] = \"Calibration\",\n\t[WM_ADSP_FW_SPK_DIAG] = \"Diagnostic\",\n\t[WM_ADSP_FW_MISC] =     \"Misc\",\n};\n\nstruct wm_adsp_system_config_xm_hdr {\n\t__be32 sys_enable;\n\t__be32 fw_id;\n\t__be32 fw_rev;\n\t__be32 boot_status;\n\t__be32 watchdog;\n\t__be32 dma_buffer_size;\n\t__be32 rdma[6];\n\t__be32 wdma[8];\n\t__be32 build_job_name[3];\n\t__be32 build_job_number;\n} __packed;\n\nstruct wm_halo_system_config_xm_hdr {\n\t__be32 halo_heartbeat;\n\t__be32 build_job_name[3];\n\t__be32 build_job_number;\n} __packed;\n\nstruct wm_adsp_alg_xm_struct {\n\t__be32 magic;\n\t__be32 smoothing;\n\t__be32 threshold;\n\t__be32 host_buf_ptr;\n\t__be32 start_seq;\n\t__be32 high_water_mark;\n\t__be32 low_water_mark;\n\t__be64 smoothed_power;\n} __packed;\n\nstruct wm_adsp_host_buf_coeff_v1 {\n\t__be32 host_buf_ptr;\t\t \n\t__be32 versions;\t\t \n\t__be32 name[4];\t\t\t \n} __packed;\n\nstruct wm_adsp_buffer {\n\t__be32 buf1_base;\t\t \n\t__be32 buf1_size;\t\t \n\t__be32 buf2_base;\t\t \n\t__be32 buf1_buf2_size;\t\t \n\t__be32 buf3_base;\t\t \n\t__be32 buf_total_size;\t\t \n\t__be32 high_water_mark;\t\t \n\t__be32 irq_count;\t\t \n\t__be32 irq_ack;\t\t\t \n\t__be32 next_write_index;\t \n\t__be32 next_read_index;\t\t \n\t__be32 error;\t\t\t \n\t__be32 oldest_block_index;\t \n\t__be32 requested_rewind;\t \n\t__be32 reserved_space;\t\t \n\t__be32 min_free;\t\t \n\t__be32 blocks_written[2];\t \n\t__be32 words_written[2];\t \n} __packed;\n\nstruct wm_adsp_compr;\n\nstruct wm_adsp_compr_buf {\n\tstruct list_head list;\n\tstruct wm_adsp *dsp;\n\tstruct wm_adsp_compr *compr;\n\n\tstruct wm_adsp_buffer_region *regions;\n\tu32 host_buf_ptr;\n\n\tu32 error;\n\tu32 irq_count;\n\tint read_index;\n\tint avail;\n\tint host_buf_mem_type;\n\n\tchar *name;\n};\n\nstruct wm_adsp_compr {\n\tstruct list_head list;\n\tstruct wm_adsp *dsp;\n\tstruct wm_adsp_compr_buf *buf;\n\n\tstruct snd_compr_stream *stream;\n\tstruct snd_compressed_buffer size;\n\n\tu32 *raw_buf;\n\tunsigned int copied_total;\n\n\tunsigned int sample_rate;\n\n\tconst char *name;\n};\n\n#define WM_ADSP_MIN_FRAGMENTS          1\n#define WM_ADSP_MAX_FRAGMENTS          256\n#define WM_ADSP_MIN_FRAGMENT_SIZE      (16 * CS_DSP_DATA_WORD_SIZE)\n#define WM_ADSP_MAX_FRAGMENT_SIZE      (4096 * CS_DSP_DATA_WORD_SIZE)\n\n#define WM_ADSP_ALG_XM_STRUCT_MAGIC    0x49aec7\n\n#define HOST_BUFFER_FIELD(field) \\\n\t(offsetof(struct wm_adsp_buffer, field) / sizeof(__be32))\n\n#define ALG_XM_FIELD(field) \\\n\t(offsetof(struct wm_adsp_alg_xm_struct, field) / sizeof(__be32))\n\n#define HOST_BUF_COEFF_SUPPORTED_COMPAT_VER\t1\n\n#define HOST_BUF_COEFF_COMPAT_VER_MASK\t\t0xFF00\n#define HOST_BUF_COEFF_COMPAT_VER_SHIFT\t\t8\n\nstatic int wm_adsp_buffer_init(struct wm_adsp *dsp);\nstatic int wm_adsp_buffer_free(struct wm_adsp *dsp);\n\nstruct wm_adsp_buffer_region {\n\tunsigned int offset;\n\tunsigned int cumulative_size;\n\tunsigned int mem_type;\n\tunsigned int base_addr;\n};\n\nstruct wm_adsp_buffer_region_def {\n\tunsigned int mem_type;\n\tunsigned int base_offset;\n\tunsigned int size_offset;\n};\n\nstatic const struct wm_adsp_buffer_region_def default_regions[] = {\n\t{\n\t\t.mem_type = WMFW_ADSP2_XM,\n\t\t.base_offset = HOST_BUFFER_FIELD(buf1_base),\n\t\t.size_offset = HOST_BUFFER_FIELD(buf1_size),\n\t},\n\t{\n\t\t.mem_type = WMFW_ADSP2_XM,\n\t\t.base_offset = HOST_BUFFER_FIELD(buf2_base),\n\t\t.size_offset = HOST_BUFFER_FIELD(buf1_buf2_size),\n\t},\n\t{\n\t\t.mem_type = WMFW_ADSP2_YM,\n\t\t.base_offset = HOST_BUFFER_FIELD(buf3_base),\n\t\t.size_offset = HOST_BUFFER_FIELD(buf_total_size),\n\t},\n};\n\nstruct wm_adsp_fw_caps {\n\tu32 id;\n\tstruct snd_codec_desc desc;\n\tint num_regions;\n\tconst struct wm_adsp_buffer_region_def *region_defs;\n};\n\nstatic const struct wm_adsp_fw_caps ctrl_caps[] = {\n\t{\n\t\t.id = SND_AUDIOCODEC_BESPOKE,\n\t\t.desc = {\n\t\t\t.max_ch = 8,\n\t\t\t.sample_rates = { 16000 },\n\t\t\t.num_sample_rates = 1,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.num_regions = ARRAY_SIZE(default_regions),\n\t\t.region_defs = default_regions,\n\t},\n};\n\nstatic const struct wm_adsp_fw_caps trace_caps[] = {\n\t{\n\t\t.id = SND_AUDIOCODEC_BESPOKE,\n\t\t.desc = {\n\t\t\t.max_ch = 8,\n\t\t\t.sample_rates = {\n\t\t\t\t4000, 8000, 11025, 12000, 16000, 22050,\n\t\t\t\t24000, 32000, 44100, 48000, 64000, 88200,\n\t\t\t\t96000, 176400, 192000\n\t\t\t},\n\t\t\t.num_sample_rates = 15,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE,\n\t\t},\n\t\t.num_regions = ARRAY_SIZE(default_regions),\n\t\t.region_defs = default_regions,\n\t},\n};\n\nstatic const struct {\n\tconst char *file;\n\tint compr_direction;\n\tint num_caps;\n\tconst struct wm_adsp_fw_caps *caps;\n\tbool voice_trigger;\n} wm_adsp_fw[WM_ADSP_NUM_FW] = {\n\t[WM_ADSP_FW_MBC_VSS] =  { .file = \"mbc-vss\" },\n\t[WM_ADSP_FW_HIFI] =     { .file = \"hifi\" },\n\t[WM_ADSP_FW_TX] =       { .file = \"tx\" },\n\t[WM_ADSP_FW_TX_SPK] =   { .file = \"tx-spk\" },\n\t[WM_ADSP_FW_RX] =       { .file = \"rx\" },\n\t[WM_ADSP_FW_RX_ANC] =   { .file = \"rx-anc\" },\n\t[WM_ADSP_FW_CTRL] =     {\n\t\t.file = \"ctrl\",\n\t\t.compr_direction = SND_COMPRESS_CAPTURE,\n\t\t.num_caps = ARRAY_SIZE(ctrl_caps),\n\t\t.caps = ctrl_caps,\n\t\t.voice_trigger = true,\n\t},\n\t[WM_ADSP_FW_ASR] =      { .file = \"asr\" },\n\t[WM_ADSP_FW_TRACE] =    {\n\t\t.file = \"trace\",\n\t\t.compr_direction = SND_COMPRESS_CAPTURE,\n\t\t.num_caps = ARRAY_SIZE(trace_caps),\n\t\t.caps = trace_caps,\n\t},\n\t[WM_ADSP_FW_SPK_PROT] = {\n\t\t.file = \"spk-prot\",\n\t\t.compr_direction = SND_COMPRESS_CAPTURE,\n\t\t.num_caps = ARRAY_SIZE(trace_caps),\n\t\t.caps = trace_caps,\n\t},\n\t[WM_ADSP_FW_SPK_CALI] = { .file = \"spk-cali\" },\n\t[WM_ADSP_FW_SPK_DIAG] = { .file = \"spk-diag\" },\n\t[WM_ADSP_FW_MISC] =     { .file = \"misc\" },\n};\n\nstruct wm_coeff_ctl {\n\tconst char *name;\n\tstruct cs_dsp_coeff_ctl *cs_ctl;\n\tstruct soc_bytes_ext bytes_ext;\n\tstruct work_struct work;\n};\n\nint wm_adsp_fw_get(struct snd_kcontrol *kcontrol,\n\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct wm_adsp *dsp = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = dsp[e->shift_l].fw;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_fw_get);\n\nint wm_adsp_fw_put(struct snd_kcontrol *kcontrol,\n\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tstruct wm_adsp *dsp = snd_soc_component_get_drvdata(component);\n\tint ret = 1;\n\n\tif (ucontrol->value.enumerated.item[0] == dsp[e->shift_l].fw)\n\t\treturn 0;\n\n\tif (ucontrol->value.enumerated.item[0] >= WM_ADSP_NUM_FW)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dsp[e->shift_l].cs_dsp.pwr_lock);\n\n\tif (dsp[e->shift_l].cs_dsp.booted || !list_empty(&dsp[e->shift_l].compr_list))\n\t\tret = -EBUSY;\n\telse\n\t\tdsp[e->shift_l].fw = ucontrol->value.enumerated.item[0];\n\n\tmutex_unlock(&dsp[e->shift_l].cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_fw_put);\n\nconst struct soc_enum wm_adsp_fw_enum[] = {\n\tSOC_ENUM_SINGLE(0, 0, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 1, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 2, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 3, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 4, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 5, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n\tSOC_ENUM_SINGLE(0, 6, ARRAY_SIZE(wm_adsp_fw_text), wm_adsp_fw_text),\n};\nEXPORT_SYMBOL_GPL(wm_adsp_fw_enum);\n\nstatic inline struct wm_coeff_ctl *bytes_ext_to_ctl(struct soc_bytes_ext *ext)\n{\n\treturn container_of(ext, struct wm_coeff_ctl, bytes_ext);\n}\n\nstatic int wm_coeff_info(struct snd_kcontrol *kctl,\n\t\t\t struct snd_ctl_elem_info *uinfo)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\n\tswitch (cs_ctl->type) {\n\tcase WMFW_CTL_TYPE_ACKED:\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\t\tuinfo->value.integer.min = CS_DSP_ACKED_CTL_MIN_VALUE;\n\t\tuinfo->value.integer.max = CS_DSP_ACKED_CTL_MAX_VALUE;\n\t\tuinfo->value.integer.step = 1;\n\t\tuinfo->count = 1;\n\t\tbreak;\n\tdefault:\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\t\tuinfo->count = cs_ctl->len;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm_coeff_put(struct snd_kcontrol *kctl,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tchar *p = ucontrol->value.bytes.data;\n\tint ret = 0;\n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\tret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, p, cs_ctl->len);\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\treturn ret;\n}\n\nstatic int wm_coeff_tlv_put(struct snd_kcontrol *kctl,\n\t\t\t    const unsigned int __user *bytes, unsigned int size)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tvoid *scratch;\n\tint ret = 0;\n\n\tscratch = vmalloc(size);\n\tif (!scratch)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(scratch, bytes, size)) {\n\t\tret = -EFAULT;\n\t} else {\n\t\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\t\tret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, scratch, size);\n\t\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\t}\n\tvfree(scratch);\n\n\treturn ret;\n}\n\nstatic int wm_coeff_put_acked(struct snd_kcontrol *kctl,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tunsigned int val = ucontrol->value.integer.value[0];\n\tint ret;\n\n\tif (val == 0)\n\t\treturn 0;\t \n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\n\tif (cs_ctl->enabled)\n\t\tret = cs_dsp_coeff_write_acked_control(cs_ctl, val);\n\telse\n\t\tret = -EPERM;\n\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 1;\n}\n\nstatic int wm_coeff_get(struct snd_kcontrol *kctl,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tchar *p = ucontrol->value.bytes.data;\n\tint ret;\n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\tret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, p, cs_ctl->len);\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\treturn ret;\n}\n\nstatic int wm_coeff_tlv_get(struct snd_kcontrol *kctl,\n\t\t\t    unsigned int __user *bytes, unsigned int size)\n{\n\tstruct soc_bytes_ext *bytes_ext =\n\t\t(struct soc_bytes_ext *)kctl->private_value;\n\tstruct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tint ret = 0;\n\n\tmutex_lock(&cs_ctl->dsp->pwr_lock);\n\n\tret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, cs_ctl->cache, size);\n\n\tif (!ret && copy_to_user(bytes, cs_ctl->cache, size))\n\t\tret = -EFAULT;\n\n\tmutex_unlock(&cs_ctl->dsp->pwr_lock);\n\n\treturn ret;\n}\n\nstatic int wm_coeff_get_acked(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\t \n\tucontrol->value.integer.value[0] = 0;\n\n\treturn 0;\n}\n\nstatic unsigned int wmfw_convert_flags(unsigned int in, unsigned int len)\n{\n\tunsigned int out, rd, wr, vol;\n\n\tif (len > ADSP_MAX_STD_CTRL_SIZE) {\n\t\trd = SNDRV_CTL_ELEM_ACCESS_TLV_READ;\n\t\twr = SNDRV_CTL_ELEM_ACCESS_TLV_WRITE;\n\t\tvol = SNDRV_CTL_ELEM_ACCESS_VOLATILE;\n\n\t\tout = SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\t} else {\n\t\trd = SNDRV_CTL_ELEM_ACCESS_READ;\n\t\twr = SNDRV_CTL_ELEM_ACCESS_WRITE;\n\t\tvol = SNDRV_CTL_ELEM_ACCESS_VOLATILE;\n\n\t\tout = 0;\n\t}\n\n\tif (in) {\n\t\tout |= rd;\n\t\tif (in & WMFW_CTL_FLAG_WRITEABLE)\n\t\t\tout |= wr;\n\t\tif (in & WMFW_CTL_FLAG_VOLATILE)\n\t\t\tout |= vol;\n\t} else {\n\t\tout |= rd | wr | vol;\n\t}\n\n\treturn out;\n}\n\nstatic void wm_adsp_ctl_work(struct work_struct *work)\n{\n\tstruct wm_coeff_ctl *ctl = container_of(work,\n\t\t\t\t\t\tstruct wm_coeff_ctl,\n\t\t\t\t\t\twork);\n\tstruct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;\n\tstruct wm_adsp *dsp = container_of(cs_ctl->dsp,\n\t\t\t\t\t   struct wm_adsp,\n\t\t\t\t\t   cs_dsp);\n\tstruct snd_kcontrol_new *kcontrol;\n\n\tkcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);\n\tif (!kcontrol)\n\t\treturn;\n\n\tkcontrol->name = ctl->name;\n\tkcontrol->info = wm_coeff_info;\n\tkcontrol->iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tkcontrol->tlv.c = snd_soc_bytes_tlv_callback;\n\tkcontrol->private_value = (unsigned long)&ctl->bytes_ext;\n\tkcontrol->access = wmfw_convert_flags(cs_ctl->flags, cs_ctl->len);\n\n\tswitch (cs_ctl->type) {\n\tcase WMFW_CTL_TYPE_ACKED:\n\t\tkcontrol->get = wm_coeff_get_acked;\n\t\tkcontrol->put = wm_coeff_put_acked;\n\t\tbreak;\n\tdefault:\n\t\tif (kcontrol->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\n\t\t\tctl->bytes_ext.max = cs_ctl->len;\n\t\t\tctl->bytes_ext.get = wm_coeff_tlv_get;\n\t\t\tctl->bytes_ext.put = wm_coeff_tlv_put;\n\t\t} else {\n\t\t\tkcontrol->get = wm_coeff_get;\n\t\t\tkcontrol->put = wm_coeff_put;\n\t\t}\n\t\tbreak;\n\t}\n\n\tsnd_soc_add_component_controls(dsp->component, kcontrol, 1);\n\n\tkfree(kcontrol);\n}\n\nstatic int wm_adsp_control_add(struct cs_dsp_coeff_ctl *cs_ctl)\n{\n\tstruct wm_adsp *dsp = container_of(cs_ctl->dsp, struct wm_adsp, cs_dsp);\n\tstruct cs_dsp *cs_dsp = &dsp->cs_dsp;\n\tstruct wm_coeff_ctl *ctl;\n\tchar name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\n\tconst char *region_name;\n\tint ret;\n\n\tif (cs_ctl->flags & WMFW_CTL_FLAG_SYS)\n\t\treturn 0;\n\n\tregion_name = cs_dsp_mem_region_name(cs_ctl->alg_region.type);\n\tif (!region_name) {\n\t\tadsp_err(dsp, \"Unknown region type: %d\\n\", cs_ctl->alg_region.type);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cs_dsp->fw_ver) {\n\tcase 0:\n\tcase 1:\n\t\tret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\t\t\t\"%s %s %x\", cs_dsp->name, region_name,\n\t\t\t\tcs_ctl->alg_region.alg);\n\t\tbreak;\n\tcase 2:\n\t\tret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\t\t\t\"%s%c %.12s %x\", cs_dsp->name, *region_name,\n\t\t\t\twm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);\n\t\tbreak;\n\tdefault:\n\t\tret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,\n\t\t\t\t\"%s %.12s %x\", cs_dsp->name,\n\t\t\t\twm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);\n\t\tbreak;\n\t}\n\n\tif (cs_ctl->subname) {\n\t\tint avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;\n\t\tint skip = 0;\n\n\t\tif (dsp->component->name_prefix)\n\t\t\tavail -= strlen(dsp->component->name_prefix) + 1;\n\n\t\t \n\t\tif (cs_ctl->subname_len > avail)\n\t\t\tskip = cs_ctl->subname_len - avail;\n\n\t\tsnprintf(name + ret, SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret,\n\t\t\t \" %.*s\", cs_ctl->subname_len - skip, cs_ctl->subname + skip);\n\t}\n\n\tctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\n\tif (!ctl)\n\t\treturn -ENOMEM;\n\tctl->cs_ctl = cs_ctl;\n\n\tctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);\n\tif (!ctl->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ctl;\n\t}\n\n\tcs_ctl->priv = ctl;\n\n\tINIT_WORK(&ctl->work, wm_adsp_ctl_work);\n\tschedule_work(&ctl->work);\n\n\treturn 0;\n\nerr_ctl:\n\tkfree(ctl);\n\n\treturn ret;\n}\n\nstatic void wm_adsp_control_remove(struct cs_dsp_coeff_ctl *cs_ctl)\n{\n\tstruct wm_coeff_ctl *ctl = cs_ctl->priv;\n\n\tcancel_work_sync(&ctl->work);\n\n\tkfree(ctl->name);\n\tkfree(ctl);\n}\n\nint wm_adsp_write_ctl(struct wm_adsp *dsp, const char *name, int type,\n\t\t      unsigned int alg, void *buf, size_t len)\n{\n\tstruct cs_dsp_coeff_ctl *cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);\n\tstruct wm_coeff_ctl *ctl;\n\tint ret;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\tret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, buf, len);\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0 || (cs_ctl->flags & WMFW_CTL_FLAG_SYS))\n\t\treturn 0;\n\n\tctl = cs_ctl->priv;\n\n\treturn snd_soc_component_notify_control(dsp->component, ctl->name);\n}\nEXPORT_SYMBOL_GPL(wm_adsp_write_ctl);\n\nint wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,\n\t\t     unsigned int alg, void *buf, size_t len)\n{\n\tint ret;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\tret = cs_dsp_coeff_read_ctrl(cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg),\n\t\t\t\t     0, buf, len);\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_read_ctl);\n\nstatic void wm_adsp_release_firmware_files(struct wm_adsp *dsp,\n\t\t\t\t\t   const struct firmware *wmfw_firmware,\n\t\t\t\t\t   char *wmfw_filename,\n\t\t\t\t\t   const struct firmware *coeff_firmware,\n\t\t\t\t\t   char *coeff_filename)\n{\n\tif (wmfw_firmware)\n\t\trelease_firmware(wmfw_firmware);\n\tkfree(wmfw_filename);\n\n\tif (coeff_firmware)\n\t\trelease_firmware(coeff_firmware);\n\tkfree(coeff_filename);\n}\n\nstatic int wm_adsp_request_firmware_file(struct wm_adsp *dsp,\n\t\t\t\t\t const struct firmware **firmware, char **filename,\n\t\t\t\t\t const char *dir, const char *system_name,\n\t\t\t\t\t const char *asoc_component_prefix,\n\t\t\t\t\t const char *filetype)\n{\n\tstruct cs_dsp *cs_dsp = &dsp->cs_dsp;\n\tchar *s, c;\n\tint ret = 0;\n\n\tif (system_name && asoc_component_prefix)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s-%s.%s\", dir, dsp->part,\n\t\t\t\t      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,\n\t\t\t\t      asoc_component_prefix, filetype);\n\telse if (system_name)\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s-%s.%s\", dir, dsp->part,\n\t\t\t\t      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,\n\t\t\t\t      filetype);\n\telse\n\t\t*filename = kasprintf(GFP_KERNEL, \"%s%s-%s-%s.%s\", dir, dsp->part, dsp->fwf_name,\n\t\t\t\t      wm_adsp_fw[dsp->fw].file, filetype);\n\n\tif (*filename == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\ts = *filename;\n\twhile (*s) {\n\t\tc = *s;\n\t\tif (isalnum(c))\n\t\t\t*s = tolower(c);\n\t\telse if ((c != '.') && (c != '/'))\n\t\t\t*s = '-';\n\t\ts++;\n\t}\n\n\tret = firmware_request_nowarn(firmware, *filename, cs_dsp->dev);\n\tif (ret != 0) {\n\t\tadsp_dbg(dsp, \"Failed to request '%s'\\n\", *filename);\n\t\tkfree(*filename);\n\t\t*filename = NULL;\n\t} else {\n\t\tadsp_dbg(dsp, \"Found '%s'\\n\", *filename);\n\t}\n\n\treturn ret;\n}\n\nstatic const char *cirrus_dir = \"cirrus/\";\nstatic int wm_adsp_request_firmware_files(struct wm_adsp *dsp,\n\t\t\t\t\t  const struct firmware **wmfw_firmware,\n\t\t\t\t\t  char **wmfw_filename,\n\t\t\t\t\t  const struct firmware **coeff_firmware,\n\t\t\t\t\t  char **coeff_filename)\n{\n\tconst char *system_name = dsp->system_name;\n\tconst char *asoc_component_prefix = dsp->component->name_prefix;\n\tint ret = 0;\n\n\tif (system_name && asoc_component_prefix) {\n\t\tif (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\t   cirrus_dir, system_name,\n\t\t\t\t\t\t   asoc_component_prefix, \"wmfw\")) {\n\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t      cirrus_dir, system_name,\n\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (system_name) {\n\t\tif (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t\t   cirrus_dir, system_name,\n\t\t\t\t\t\t   NULL, \"wmfw\")) {\n\t\t\tif (asoc_component_prefix)\n\t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t      cirrus_dir, system_name,\n\t\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n\n\t\t\tif (!*coeff_firmware)\n\t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t      cirrus_dir, system_name,\n\t\t\t\t\t\t\t      NULL, \"bin\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t   \"\", NULL, NULL, \"wmfw\")) {\n\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t      \"\", NULL, NULL, \"bin\");\n\t\treturn 0;\n\t}\n\n\tret = wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    cirrus_dir, NULL, NULL, \"wmfw\");\n\tif (!ret) {\n\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t      cirrus_dir, NULL, NULL, \"bin\");\n\t\treturn 0;\n\t}\n\n\tif (dsp->wmfw_optional) {\n\t\tif (system_name) {\n\t\t\tif (asoc_component_prefix)\n\t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t      cirrus_dir, system_name,\n\t\t\t\t\t\t\t      asoc_component_prefix, \"bin\");\n\n\t\t\tif (!*coeff_firmware)\n\t\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t\t      cirrus_dir, system_name,\n\t\t\t\t\t\t\t      NULL, \"bin\");\n\t\t}\n\n\t\tif (!*coeff_firmware)\n\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t      \"\", NULL, NULL, \"bin\");\n\n\t\tif (!*coeff_firmware)\n\t\t\twm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,\n\t\t\t\t\t\t      cirrus_dir, NULL, NULL, \"bin\");\n\n\t\treturn 0;\n\t}\n\n\tadsp_err(dsp, \"Failed to request firmware <%s>%s-%s-%s<-%s<%s>>.wmfw\\n\",\n\t\t cirrus_dir, dsp->part, dsp->fwf_name, wm_adsp_fw[dsp->fw].file,\n\t\t system_name, asoc_component_prefix);\n\n\treturn -ENOENT;\n}\n\nstatic int wm_adsp_common_init(struct wm_adsp *dsp)\n{\n\tchar *p;\n\n\tINIT_LIST_HEAD(&dsp->compr_list);\n\tINIT_LIST_HEAD(&dsp->buffer_list);\n\n\tif (!dsp->fwf_name) {\n\t\tp = devm_kstrdup(dsp->cs_dsp.dev, dsp->cs_dsp.name, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\n\t\tdsp->fwf_name = p;\n\t\tfor (; *p != 0; ++p)\n\t\t\t*p = tolower(*p);\n\t}\n\n\treturn 0;\n}\n\nint wm_adsp1_init(struct wm_adsp *dsp)\n{\n\tint ret;\n\n\tdsp->cs_dsp.client_ops = &wm_adsp1_client_ops;\n\n\tret = cs_dsp_adsp1_init(&dsp->cs_dsp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wm_adsp_common_init(dsp);\n}\nEXPORT_SYMBOL_GPL(wm_adsp1_init);\n\nint wm_adsp1_event(struct snd_soc_dapm_widget *w,\n\t\t   struct snd_kcontrol *kcontrol,\n\t\t   int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct wm_adsp *dsp = &dsps[w->shift];\n\tint ret = 0;\n\tchar *wmfw_filename = NULL;\n\tconst struct firmware *wmfw_firmware = NULL;\n\tchar *coeff_filename = NULL;\n\tconst struct firmware *coeff_firmware = NULL;\n\n\tdsp->component = component;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tret = wm_adsp_request_firmware_files(dsp,\n\t\t\t\t\t\t     &wmfw_firmware, &wmfw_filename,\n\t\t\t\t\t\t     &coeff_firmware, &coeff_filename);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tret = cs_dsp_adsp1_power_up(&dsp->cs_dsp,\n\t\t\t\t\t    wmfw_firmware, wmfw_filename,\n\t\t\t\t\t    coeff_firmware, coeff_filename,\n\t\t\t\t\t    wm_adsp_fw_text[dsp->fw]);\n\n\t\twm_adsp_release_firmware_files(dsp,\n\t\t\t\t\t       wmfw_firmware, wmfw_filename,\n\t\t\t\t\t       coeff_firmware, coeff_filename);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tcs_dsp_adsp1_power_down(&dsp->cs_dsp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp1_event);\n\nint wm_adsp2_set_dspclk(struct snd_soc_dapm_widget *w, unsigned int freq)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct wm_adsp *dsp = &dsps[w->shift];\n\n\treturn cs_dsp_set_dspclk(&dsp->cs_dsp, freq);\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_set_dspclk);\n\nint wm_adsp2_preloader_get(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct wm_adsp *dsp = &dsps[mc->shift - 1];\n\n\tucontrol->value.integer.value[0] = dsp->preloaded;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_preloader_get);\n\nint wm_adsp2_preloader_put(struct snd_kcontrol *kcontrol,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct wm_adsp *dsp = &dsps[mc->shift - 1];\n\tchar preload[32];\n\n\tif (dsp->preloaded == ucontrol->value.integer.value[0])\n\t\treturn 0;\n\n\tsnprintf(preload, ARRAY_SIZE(preload), \"%s Preload\", dsp->cs_dsp.name);\n\n\tif (ucontrol->value.integer.value[0] || dsp->toggle_preload)\n\t\tsnd_soc_component_force_enable_pin(component, preload);\n\telse\n\t\tsnd_soc_component_disable_pin(component, preload);\n\n\tsnd_soc_dapm_sync(dapm);\n\n\tflush_work(&dsp->boot_work);\n\n\tdsp->preloaded = ucontrol->value.integer.value[0];\n\n\tif (dsp->toggle_preload) {\n\t\tsnd_soc_component_disable_pin(component, preload);\n\t\tsnd_soc_dapm_sync(dapm);\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_preloader_put);\n\nint wm_adsp_power_up(struct wm_adsp *dsp, bool load_firmware)\n{\n\tint ret = 0;\n\tchar *wmfw_filename = NULL;\n\tconst struct firmware *wmfw_firmware = NULL;\n\tchar *coeff_filename = NULL;\n\tconst struct firmware *coeff_firmware = NULL;\n\n\tif (load_firmware) {\n\t\tret = wm_adsp_request_firmware_files(dsp,\n\t\t\t\t\t\t     &wmfw_firmware, &wmfw_filename,\n\t\t\t\t\t\t     &coeff_firmware, &coeff_filename);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = cs_dsp_power_up(&dsp->cs_dsp,\n\t\t\t      wmfw_firmware, wmfw_filename,\n\t\t\t      coeff_firmware, coeff_filename,\n\t\t\t      wm_adsp_fw_text[dsp->fw]);\n\n\twm_adsp_release_firmware_files(dsp,\n\t\t\t\t       wmfw_firmware, wmfw_filename,\n\t\t\t\t       coeff_firmware, coeff_filename);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_power_up);\n\nvoid wm_adsp_power_down(struct wm_adsp *dsp)\n{\n\tcs_dsp_power_down(&dsp->cs_dsp);\n}\nEXPORT_SYMBOL_GPL(wm_adsp_power_down);\n\nstatic void wm_adsp_boot_work(struct work_struct *work)\n{\n\tstruct wm_adsp *dsp = container_of(work,\n\t\t\t\t\t   struct wm_adsp,\n\t\t\t\t\t   boot_work);\n\n\twm_adsp_power_up(dsp, true);\n}\n\nint wm_adsp_early_event(struct snd_soc_dapm_widget *w,\n\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct wm_adsp *dsp = &dsps[w->shift];\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tqueue_work(system_unbound_wq, &dsp->boot_work);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\twm_adsp_power_down(dsp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_early_event);\n\nstatic int wm_adsp_pre_run(struct cs_dsp *cs_dsp)\n{\n\tstruct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);\n\n\tif (!dsp->pre_run)\n\t\treturn 0;\n\n\treturn (*dsp->pre_run)(dsp);\n}\n\nstatic int wm_adsp_event_post_run(struct cs_dsp *cs_dsp)\n{\n\tstruct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);\n\n\tif (wm_adsp_fw[dsp->fw].num_caps != 0)\n\t\treturn wm_adsp_buffer_init(dsp);\n\n\treturn 0;\n}\n\nstatic void wm_adsp_event_post_stop(struct cs_dsp *cs_dsp)\n{\n\tstruct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);\n\n\tif (wm_adsp_fw[dsp->fw].num_caps != 0)\n\t\twm_adsp_buffer_free(dsp);\n\n\tdsp->fatal_error = false;\n}\n\nint wm_adsp_event(struct snd_soc_dapm_widget *w,\n\t\t  struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm_adsp *dsps = snd_soc_component_get_drvdata(component);\n\tstruct wm_adsp *dsp = &dsps[w->shift];\n\tint ret = 0;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tflush_work(&dsp->boot_work);\n\t\tret = cs_dsp_run(&dsp->cs_dsp);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tcs_dsp_stop(&dsp->cs_dsp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_event);\n\nint wm_adsp2_component_probe(struct wm_adsp *dsp, struct snd_soc_component *component)\n{\n\tchar preload[32];\n\n\tif (!dsp->cs_dsp.no_core_startstop) {\n\t\tsnprintf(preload, ARRAY_SIZE(preload), \"%s Preload\", dsp->cs_dsp.name);\n\t\tsnd_soc_component_disable_pin(component, preload);\n\t}\n\n\tcs_dsp_init_debugfs(&dsp->cs_dsp, component->debugfs_root);\n\n\tdsp->component = component;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_component_probe);\n\nint wm_adsp2_component_remove(struct wm_adsp *dsp, struct snd_soc_component *component)\n{\n\tcs_dsp_cleanup_debugfs(&dsp->cs_dsp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_component_remove);\n\nint wm_adsp2_init(struct wm_adsp *dsp)\n{\n\tint ret;\n\n\tINIT_WORK(&dsp->boot_work, wm_adsp_boot_work);\n\n\tdsp->sys_config_size = sizeof(struct wm_adsp_system_config_xm_hdr);\n\tdsp->cs_dsp.client_ops = &wm_adsp2_client_ops;\n\n\tret = cs_dsp_adsp2_init(&dsp->cs_dsp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wm_adsp_common_init(dsp);\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_init);\n\nint wm_halo_init(struct wm_adsp *dsp)\n{\n\tint ret;\n\n\tINIT_WORK(&dsp->boot_work, wm_adsp_boot_work);\n\n\tdsp->sys_config_size = sizeof(struct wm_halo_system_config_xm_hdr);\n\tdsp->cs_dsp.client_ops = &wm_adsp2_client_ops;\n\n\tret = cs_dsp_halo_init(&dsp->cs_dsp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn wm_adsp_common_init(dsp);\n}\nEXPORT_SYMBOL_GPL(wm_halo_init);\n\nvoid wm_adsp2_remove(struct wm_adsp *dsp)\n{\n\tcs_dsp_remove(&dsp->cs_dsp);\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_remove);\n\nstatic inline int wm_adsp_compr_attached(struct wm_adsp_compr *compr)\n{\n\treturn compr->buf != NULL;\n}\n\nstatic int wm_adsp_compr_attach(struct wm_adsp_compr *compr)\n{\n\tstruct wm_adsp_compr_buf *buf = NULL, *tmp;\n\n\tif (compr->dsp->fatal_error)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(tmp, &compr->dsp->buffer_list, list) {\n\t\tif (!tmp->name || !strcmp(compr->name, tmp->name)) {\n\t\t\tbuf = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tcompr->buf = buf;\n\tbuf->compr = compr;\n\n\treturn 0;\n}\n\nstatic void wm_adsp_compr_detach(struct wm_adsp_compr *compr)\n{\n\tif (!compr)\n\t\treturn;\n\n\t \n\tif (compr->stream)\n\t\tsnd_compr_fragment_elapsed(compr->stream);\n\n\tif (wm_adsp_compr_attached(compr)) {\n\t\tcompr->buf->compr = NULL;\n\t\tcompr->buf = NULL;\n\t}\n}\n\nint wm_adsp_compr_open(struct wm_adsp *dsp, struct snd_compr_stream *stream)\n{\n\tstruct wm_adsp_compr *compr, *tmp;\n\tstruct snd_soc_pcm_runtime *rtd = stream->private_data;\n\tint ret = 0;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\tif (wm_adsp_fw[dsp->fw].num_caps == 0) {\n\t\tadsp_err(dsp, \"%s: Firmware does not support compressed API\\n\",\n\t\t\t asoc_rtd_to_codec(rtd, 0)->name);\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (wm_adsp_fw[dsp->fw].compr_direction != stream->direction) {\n\t\tadsp_err(dsp, \"%s: Firmware does not support stream direction\\n\",\n\t\t\t asoc_rtd_to_codec(rtd, 0)->name);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(tmp, &dsp->compr_list, list) {\n\t\tif (!strcmp(tmp->name, asoc_rtd_to_codec(rtd, 0)->name)) {\n\t\t\tadsp_err(dsp, \"%s: Only a single stream supported per dai\\n\",\n\t\t\t\t asoc_rtd_to_codec(rtd, 0)->name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcompr = kzalloc(sizeof(*compr), GFP_KERNEL);\n\tif (!compr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcompr->dsp = dsp;\n\tcompr->stream = stream;\n\tcompr->name = asoc_rtd_to_codec(rtd, 0)->name;\n\n\tlist_add_tail(&compr->list, &dsp->compr_list);\n\n\tstream->runtime->private_data = compr;\n\nout:\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_open);\n\nint wm_adsp_compr_free(struct snd_soc_component *component,\n\t\t       struct snd_compr_stream *stream)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tstruct wm_adsp *dsp = compr->dsp;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\twm_adsp_compr_detach(compr);\n\tlist_del(&compr->list);\n\n\tkfree(compr->raw_buf);\n\tkfree(compr);\n\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_free);\n\nstatic int wm_adsp_compr_check_params(struct snd_compr_stream *stream,\n\t\t\t\t      struct snd_compr_params *params)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tstruct wm_adsp *dsp = compr->dsp;\n\tconst struct wm_adsp_fw_caps *caps;\n\tconst struct snd_codec_desc *desc;\n\tint i, j;\n\n\tif (params->buffer.fragment_size < WM_ADSP_MIN_FRAGMENT_SIZE ||\n\t    params->buffer.fragment_size > WM_ADSP_MAX_FRAGMENT_SIZE ||\n\t    params->buffer.fragments < WM_ADSP_MIN_FRAGMENTS ||\n\t    params->buffer.fragments > WM_ADSP_MAX_FRAGMENTS ||\n\t    params->buffer.fragment_size % CS_DSP_DATA_WORD_SIZE) {\n\t\tcompr_err(compr, \"Invalid buffer fragsize=%d fragments=%d\\n\",\n\t\t\t  params->buffer.fragment_size,\n\t\t\t  params->buffer.fragments);\n\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < wm_adsp_fw[dsp->fw].num_caps; i++) {\n\t\tcaps = &wm_adsp_fw[dsp->fw].caps[i];\n\t\tdesc = &caps->desc;\n\n\t\tif (caps->id != params->codec.id)\n\t\t\tcontinue;\n\n\t\tif (stream->direction == SND_COMPRESS_PLAYBACK) {\n\t\t\tif (desc->max_ch < params->codec.ch_out)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (desc->max_ch < params->codec.ch_in)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(desc->formats & (1 << params->codec.format)))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < desc->num_sample_rates; ++j)\n\t\t\tif (desc->sample_rates[j] == params->codec.sample_rate)\n\t\t\t\treturn 0;\n\t}\n\n\tcompr_err(compr, \"Invalid params id=%u ch=%u,%u rate=%u fmt=%u\\n\",\n\t\t  params->codec.id, params->codec.ch_in, params->codec.ch_out,\n\t\t  params->codec.sample_rate, params->codec.format);\n\treturn -EINVAL;\n}\n\nstatic inline unsigned int wm_adsp_compr_frag_words(struct wm_adsp_compr *compr)\n{\n\treturn compr->size.fragment_size / CS_DSP_DATA_WORD_SIZE;\n}\n\nint wm_adsp_compr_set_params(struct snd_soc_component *component,\n\t\t\t     struct snd_compr_stream *stream,\n\t\t\t     struct snd_compr_params *params)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tunsigned int size;\n\tint ret;\n\n\tret = wm_adsp_compr_check_params(stream, params);\n\tif (ret)\n\t\treturn ret;\n\n\tcompr->size = params->buffer;\n\n\tcompr_dbg(compr, \"fragment_size=%d fragments=%d\\n\",\n\t\t  compr->size.fragment_size, compr->size.fragments);\n\n\tsize = wm_adsp_compr_frag_words(compr) * sizeof(*compr->raw_buf);\n\tcompr->raw_buf = kmalloc(size, GFP_DMA | GFP_KERNEL);\n\tif (!compr->raw_buf)\n\t\treturn -ENOMEM;\n\n\tcompr->sample_rate = params->codec.sample_rate;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_set_params);\n\nint wm_adsp_compr_get_caps(struct snd_soc_component *component,\n\t\t\t   struct snd_compr_stream *stream,\n\t\t\t   struct snd_compr_caps *caps)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tint fw = compr->dsp->fw;\n\tint i;\n\n\tif (wm_adsp_fw[fw].caps) {\n\t\tfor (i = 0; i < wm_adsp_fw[fw].num_caps; i++)\n\t\t\tcaps->codecs[i] = wm_adsp_fw[fw].caps[i].id;\n\n\t\tcaps->num_codecs = i;\n\t\tcaps->direction = wm_adsp_fw[fw].compr_direction;\n\n\t\tcaps->min_fragment_size = WM_ADSP_MIN_FRAGMENT_SIZE;\n\t\tcaps->max_fragment_size = WM_ADSP_MAX_FRAGMENT_SIZE;\n\t\tcaps->min_fragments = WM_ADSP_MIN_FRAGMENTS;\n\t\tcaps->max_fragments = WM_ADSP_MAX_FRAGMENTS;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_get_caps);\n\nstatic inline int wm_adsp_buffer_read(struct wm_adsp_compr_buf *buf,\n\t\t\t\t      unsigned int field_offset, u32 *data)\n{\n\treturn cs_dsp_read_data_word(&buf->dsp->cs_dsp, buf->host_buf_mem_type,\n\t\t\t\t     buf->host_buf_ptr + field_offset, data);\n}\n\nstatic inline int wm_adsp_buffer_write(struct wm_adsp_compr_buf *buf,\n\t\t\t\t       unsigned int field_offset, u32 data)\n{\n\treturn cs_dsp_write_data_word(&buf->dsp->cs_dsp, buf->host_buf_mem_type,\n\t\t\t\t      buf->host_buf_ptr + field_offset,\n\t\t\t\t      data);\n}\n\nstatic int wm_adsp_buffer_populate(struct wm_adsp_compr_buf *buf)\n{\n\tconst struct wm_adsp_fw_caps *caps = wm_adsp_fw[buf->dsp->fw].caps;\n\tstruct wm_adsp_buffer_region *region;\n\tu32 offset = 0;\n\tint i, ret;\n\n\tbuf->regions = kcalloc(caps->num_regions, sizeof(*buf->regions),\n\t\t\t       GFP_KERNEL);\n\tif (!buf->regions)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < caps->num_regions; ++i) {\n\t\tregion = &buf->regions[i];\n\n\t\tregion->offset = offset;\n\t\tregion->mem_type = caps->region_defs[i].mem_type;\n\n\t\tret = wm_adsp_buffer_read(buf, caps->region_defs[i].base_offset,\n\t\t\t\t\t  &region->base_addr);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tret = wm_adsp_buffer_read(buf, caps->region_defs[i].size_offset,\n\t\t\t\t\t  &offset);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tregion->cumulative_size = offset;\n\n\t\tcompr_dbg(buf,\n\t\t\t  \"region=%d type=%d base=%08x off=%08x size=%08x\\n\",\n\t\t\t  i, region->mem_type, region->base_addr,\n\t\t\t  region->offset, region->cumulative_size);\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree(buf->regions);\n\treturn ret;\n}\n\nstatic void wm_adsp_buffer_clear(struct wm_adsp_compr_buf *buf)\n{\n\tbuf->irq_count = 0xFFFFFFFF;\n\tbuf->read_index = -1;\n\tbuf->avail = 0;\n}\n\nstatic struct wm_adsp_compr_buf *wm_adsp_buffer_alloc(struct wm_adsp *dsp)\n{\n\tstruct wm_adsp_compr_buf *buf;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->dsp = dsp;\n\n\twm_adsp_buffer_clear(buf);\n\n\treturn buf;\n}\n\nstatic int wm_adsp_buffer_parse_legacy(struct wm_adsp *dsp)\n{\n\tstruct cs_dsp_alg_region *alg_region;\n\tstruct wm_adsp_compr_buf *buf;\n\tu32 xmalg, addr, magic;\n\tint i, ret;\n\n\talg_region = cs_dsp_find_alg_region(&dsp->cs_dsp, WMFW_ADSP2_XM, dsp->cs_dsp.fw_id);\n\tif (!alg_region) {\n\t\tadsp_err(dsp, \"No algorithm region found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txmalg = dsp->sys_config_size / sizeof(__be32);\n\n\taddr = alg_region->base + xmalg + ALG_XM_FIELD(magic);\n\tret = cs_dsp_read_data_word(&dsp->cs_dsp, WMFW_ADSP2_XM, addr, &magic);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (magic != WM_ADSP_ALG_XM_STRUCT_MAGIC)\n\t\treturn -ENODEV;\n\n\tbuf = wm_adsp_buffer_alloc(dsp);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\taddr = alg_region->base + xmalg + ALG_XM_FIELD(host_buf_ptr);\n\tfor (i = 0; i < 5; ++i) {\n\t\tret = cs_dsp_read_data_word(&dsp->cs_dsp, WMFW_ADSP2_XM, addr,\n\t\t\t\t\t    &buf->host_buf_ptr);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\n\t\tif (buf->host_buf_ptr)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!buf->host_buf_ptr) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tbuf->host_buf_mem_type = WMFW_ADSP2_XM;\n\n\tret = wm_adsp_buffer_populate(buf);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tlist_add_tail(&buf->list, &dsp->buffer_list);\n\n\tcompr_dbg(buf, \"legacy host_buf_ptr=%x\\n\", buf->host_buf_ptr);\n\n\treturn 0;\n\nerr:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int wm_adsp_buffer_parse_coeff(struct cs_dsp_coeff_ctl *cs_ctl)\n{\n\tstruct wm_adsp_host_buf_coeff_v1 coeff_v1;\n\tstruct wm_adsp_compr_buf *buf;\n\tstruct wm_adsp *dsp = container_of(cs_ctl->dsp, struct wm_adsp, cs_dsp);\n\tunsigned int version = 0;\n\tint ret, i;\n\n\tfor (i = 0; i < 5; ++i) {\n\t\tret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, &coeff_v1,\n\t\t\t\t\t     min(cs_ctl->len, sizeof(coeff_v1)));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (coeff_v1.host_buf_ptr)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\n\tif (!coeff_v1.host_buf_ptr) {\n\t\tadsp_err(dsp, \"Failed to acquire host buffer\\n\");\n\t\treturn -EIO;\n\t}\n\n\tbuf = wm_adsp_buffer_alloc(dsp);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->host_buf_mem_type = cs_ctl->alg_region.type;\n\tbuf->host_buf_ptr = be32_to_cpu(coeff_v1.host_buf_ptr);\n\n\tret = wm_adsp_buffer_populate(buf);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tif (cs_ctl->len == 4)\n\t\tgoto done;\n\n\tversion = be32_to_cpu(coeff_v1.versions) & HOST_BUF_COEFF_COMPAT_VER_MASK;\n\tversion >>= HOST_BUF_COEFF_COMPAT_VER_SHIFT;\n\n\tif (version > HOST_BUF_COEFF_SUPPORTED_COMPAT_VER) {\n\t\tadsp_err(dsp,\n\t\t\t \"Host buffer coeff ver %u > supported version %u\\n\",\n\t\t\t version, HOST_BUF_COEFF_SUPPORTED_COMPAT_VER);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcs_dsp_remove_padding((u32 *)&coeff_v1.name, ARRAY_SIZE(coeff_v1.name));\n\n\tbuf->name = kasprintf(GFP_KERNEL, \"%s-dsp-%s\", dsp->part,\n\t\t\t      (char *)&coeff_v1.name);\n\ndone:\n\tlist_add_tail(&buf->list, &dsp->buffer_list);\n\n\tcompr_dbg(buf, \"host_buf_ptr=%x coeff version %u\\n\",\n\t\t  buf->host_buf_ptr, version);\n\n\treturn version;\n\nerr:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int wm_adsp_buffer_init(struct wm_adsp *dsp)\n{\n\tstruct cs_dsp_coeff_ctl *cs_ctl;\n\tint ret;\n\n\tlist_for_each_entry(cs_ctl, &dsp->cs_dsp.ctl_list, list) {\n\t\tif (cs_ctl->type != WMFW_CTL_TYPE_HOST_BUFFER)\n\t\t\tcontinue;\n\n\t\tif (!cs_ctl->enabled)\n\t\t\tcontinue;\n\n\t\tret = wm_adsp_buffer_parse_coeff(cs_ctl);\n\t\tif (ret < 0) {\n\t\t\tadsp_err(dsp, \"Failed to parse coeff: %d\\n\", ret);\n\t\t\tgoto error;\n\t\t} else if (ret == 0) {\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (list_empty(&dsp->buffer_list)) {\n\t\t \n\t\tret = wm_adsp_buffer_parse_legacy(dsp);\n\t\tif (ret == -ENODEV)\n\t\t\tadsp_info(dsp, \"Legacy support not available\\n\");\n\t\telse if (ret)\n\t\t\tadsp_warn(dsp, \"Failed to parse legacy: %d\\n\", ret);\n\t}\n\n\treturn 0;\n\nerror:\n\twm_adsp_buffer_free(dsp);\n\treturn ret;\n}\n\nstatic int wm_adsp_buffer_free(struct wm_adsp *dsp)\n{\n\tstruct wm_adsp_compr_buf *buf, *tmp;\n\n\tlist_for_each_entry_safe(buf, tmp, &dsp->buffer_list, list) {\n\t\twm_adsp_compr_detach(buf->compr);\n\n\t\tkfree(buf->name);\n\t\tkfree(buf->regions);\n\t\tlist_del(&buf->list);\n\t\tkfree(buf);\n\t}\n\n\treturn 0;\n}\n\nstatic int wm_adsp_buffer_get_error(struct wm_adsp_compr_buf *buf)\n{\n\tint ret;\n\n\tret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(error), &buf->error);\n\tif (ret < 0) {\n\t\tcompr_err(buf, \"Failed to check buffer error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (buf->error != 0) {\n\t\tcompr_err(buf, \"Buffer error occurred: %d\\n\", buf->error);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nint wm_adsp_compr_trigger(struct snd_soc_component *component,\n\t\t\t  struct snd_compr_stream *stream, int cmd)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tstruct wm_adsp *dsp = compr->dsp;\n\tint ret = 0;\n\n\tcompr_dbg(compr, \"Trigger: %d\\n\", cmd);\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\t\tif (!wm_adsp_compr_attached(compr)) {\n\t\t\tret = wm_adsp_compr_attach(compr);\n\t\t\tif (ret < 0) {\n\t\t\t\tcompr_err(compr, \"Failed to link buffer and stream: %d\\n\",\n\t\t\t\t\t  ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret = wm_adsp_buffer_get_error(compr->buf);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tret = wm_adsp_buffer_write(compr->buf,\n\t\t\t\t\t   HOST_BUFFER_FIELD(high_water_mark),\n\t\t\t\t\t   wm_adsp_compr_frag_words(compr));\n\t\tif (ret < 0) {\n\t\t\tcompr_err(compr, \"Failed to set high water mark: %d\\n\",\n\t\t\t\t  ret);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\t\tif (wm_adsp_compr_attached(compr))\n\t\t\twm_adsp_buffer_clear(compr->buf);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_trigger);\n\nstatic inline int wm_adsp_buffer_size(struct wm_adsp_compr_buf *buf)\n{\n\tint last_region = wm_adsp_fw[buf->dsp->fw].caps->num_regions - 1;\n\n\treturn buf->regions[last_region].cumulative_size;\n}\n\nstatic int wm_adsp_buffer_update_avail(struct wm_adsp_compr_buf *buf)\n{\n\tu32 next_read_index, next_write_index;\n\tint write_index, read_index, avail;\n\tint ret;\n\n\t \n\tif (buf->read_index < 0) {\n\t\tret = wm_adsp_buffer_read(buf,\n\t\t\t\tHOST_BUFFER_FIELD(next_read_index),\n\t\t\t\t&next_read_index);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tread_index = sign_extend32(next_read_index, 23);\n\n\t\tif (read_index < 0) {\n\t\t\tcompr_dbg(buf, \"Avail check on unstarted stream\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuf->read_index = read_index;\n\t}\n\n\tret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(next_write_index),\n\t\t\t&next_write_index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twrite_index = sign_extend32(next_write_index, 23);\n\n\tavail = write_index - buf->read_index;\n\tif (avail < 0)\n\t\tavail += wm_adsp_buffer_size(buf);\n\n\tcompr_dbg(buf, \"readindex=0x%x, writeindex=0x%x, avail=%d\\n\",\n\t\t  buf->read_index, write_index, avail * CS_DSP_DATA_WORD_SIZE);\n\n\tbuf->avail = avail;\n\n\treturn 0;\n}\n\nint wm_adsp_compr_handle_irq(struct wm_adsp *dsp)\n{\n\tstruct wm_adsp_compr_buf *buf;\n\tstruct wm_adsp_compr *compr;\n\tint ret = 0;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\tif (list_empty(&dsp->buffer_list)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tadsp_dbg(dsp, \"Handling buffer IRQ\\n\");\n\n\tlist_for_each_entry(buf, &dsp->buffer_list, list) {\n\t\tcompr = buf->compr;\n\n\t\tret = wm_adsp_buffer_get_error(buf);\n\t\tif (ret < 0)\n\t\t\tgoto out_notify;  \n\n\t\tret = wm_adsp_buffer_read(buf, HOST_BUFFER_FIELD(irq_count),\n\t\t\t\t\t  &buf->irq_count);\n\t\tif (ret < 0) {\n\t\t\tcompr_err(buf, \"Failed to get irq_count: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = wm_adsp_buffer_update_avail(buf);\n\t\tif (ret < 0) {\n\t\t\tcompr_err(buf, \"Error reading avail: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (wm_adsp_fw[dsp->fw].voice_trigger && buf->irq_count == 2)\n\t\t\tret = WM_ADSP_COMPR_VOICE_TRIGGER;\n\nout_notify:\n\t\tif (compr && compr->stream)\n\t\t\tsnd_compr_fragment_elapsed(compr->stream);\n\t}\n\nout:\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_handle_irq);\n\nstatic int wm_adsp_buffer_reenable_irq(struct wm_adsp_compr_buf *buf)\n{\n\tif (buf->irq_count & 0x01)\n\t\treturn 0;\n\n\tcompr_dbg(buf, \"Enable IRQ(0x%x) for next fragment\\n\", buf->irq_count);\n\n\tbuf->irq_count |= 0x01;\n\n\treturn wm_adsp_buffer_write(buf, HOST_BUFFER_FIELD(irq_ack),\n\t\t\t\t    buf->irq_count);\n}\n\nint wm_adsp_compr_pointer(struct snd_soc_component *component,\n\t\t\t  struct snd_compr_stream *stream,\n\t\t\t  struct snd_compr_tstamp *tstamp)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tstruct wm_adsp *dsp = compr->dsp;\n\tstruct wm_adsp_compr_buf *buf;\n\tint ret = 0;\n\n\tcompr_dbg(compr, \"Pointer request\\n\");\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\tbuf = compr->buf;\n\n\tif (dsp->fatal_error || !buf || buf->error) {\n\t\tsnd_compr_stop_error(stream, SNDRV_PCM_STATE_XRUN);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (buf->avail < wm_adsp_compr_frag_words(compr)) {\n\t\tret = wm_adsp_buffer_update_avail(buf);\n\t\tif (ret < 0) {\n\t\t\tcompr_err(compr, \"Error reading avail: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tif (buf->avail < wm_adsp_compr_frag_words(compr)) {\n\t\t\tret = wm_adsp_buffer_get_error(buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (buf->error)\n\t\t\t\t\tsnd_compr_stop_error(stream,\n\t\t\t\t\t\t\tSNDRV_PCM_STATE_XRUN);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = wm_adsp_buffer_reenable_irq(buf);\n\t\t\tif (ret < 0) {\n\t\t\t\tcompr_err(compr, \"Failed to re-enable buffer IRQ: %d\\n\",\n\t\t\t\t\t  ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\ttstamp->copied_total = compr->copied_total;\n\ttstamp->copied_total += buf->avail * CS_DSP_DATA_WORD_SIZE;\n\ttstamp->sampling_rate = compr->sample_rate;\n\nout:\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_pointer);\n\nstatic int wm_adsp_buffer_capture_block(struct wm_adsp_compr *compr, int target)\n{\n\tstruct wm_adsp_compr_buf *buf = compr->buf;\n\tunsigned int adsp_addr;\n\tint mem_type, nwords, max_read;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < wm_adsp_fw[buf->dsp->fw].caps->num_regions; ++i)\n\t\tif (buf->read_index < buf->regions[i].cumulative_size)\n\t\t\tbreak;\n\n\tif (i == wm_adsp_fw[buf->dsp->fw].caps->num_regions)\n\t\treturn -EINVAL;\n\n\tmem_type = buf->regions[i].mem_type;\n\tadsp_addr = buf->regions[i].base_addr +\n\t\t    (buf->read_index - buf->regions[i].offset);\n\n\tmax_read = wm_adsp_compr_frag_words(compr);\n\tnwords = buf->regions[i].cumulative_size - buf->read_index;\n\n\tif (nwords > target)\n\t\tnwords = target;\n\tif (nwords > buf->avail)\n\t\tnwords = buf->avail;\n\tif (nwords > max_read)\n\t\tnwords = max_read;\n\tif (!nwords)\n\t\treturn 0;\n\n\t \n\tret = cs_dsp_read_raw_data_block(&buf->dsp->cs_dsp, mem_type, adsp_addr,\n\t\t\t\t\t nwords, (__be32 *)compr->raw_buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcs_dsp_remove_padding(compr->raw_buf, nwords);\n\n\t \n\tbuf->read_index += nwords;\n\tif (buf->read_index == wm_adsp_buffer_size(buf))\n\t\tbuf->read_index = 0;\n\n\tret = wm_adsp_buffer_write(buf, HOST_BUFFER_FIELD(next_read_index),\n\t\t\t\t   buf->read_index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tbuf->avail -= nwords;\n\n\treturn nwords;\n}\n\nstatic int wm_adsp_compr_read(struct wm_adsp_compr *compr,\n\t\t\t      char __user *buf, size_t count)\n{\n\tstruct wm_adsp *dsp = compr->dsp;\n\tint ntotal = 0;\n\tint nwords, nbytes;\n\n\tcompr_dbg(compr, \"Requested read of %zu bytes\\n\", count);\n\n\tif (dsp->fatal_error || !compr->buf || compr->buf->error) {\n\t\tsnd_compr_stop_error(compr->stream, SNDRV_PCM_STATE_XRUN);\n\t\treturn -EIO;\n\t}\n\n\tcount /= CS_DSP_DATA_WORD_SIZE;\n\n\tdo {\n\t\tnwords = wm_adsp_buffer_capture_block(compr, count);\n\t\tif (nwords < 0) {\n\t\t\tcompr_err(compr, \"Failed to capture block: %d\\n\",\n\t\t\t\t  nwords);\n\t\t\treturn nwords;\n\t\t}\n\n\t\tnbytes = nwords * CS_DSP_DATA_WORD_SIZE;\n\n\t\tcompr_dbg(compr, \"Read %d bytes\\n\", nbytes);\n\n\t\tif (copy_to_user(buf + ntotal, compr->raw_buf, nbytes)) {\n\t\t\tcompr_err(compr, \"Failed to copy data to user: %d, %d\\n\",\n\t\t\t\t  ntotal, nbytes);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcount -= nwords;\n\t\tntotal += nbytes;\n\t} while (nwords > 0 && count > 0);\n\n\tcompr->copied_total += ntotal;\n\n\treturn ntotal;\n}\n\nint wm_adsp_compr_copy(struct snd_soc_component *component,\n\t\t       struct snd_compr_stream *stream, char __user *buf,\n\t\t       size_t count)\n{\n\tstruct wm_adsp_compr *compr = stream->runtime->private_data;\n\tstruct wm_adsp *dsp = compr->dsp;\n\tint ret;\n\n\tmutex_lock(&dsp->cs_dsp.pwr_lock);\n\n\tif (stream->direction == SND_COMPRESS_CAPTURE)\n\t\tret = wm_adsp_compr_read(compr, buf, count);\n\telse\n\t\tret = -ENOTSUPP;\n\n\tmutex_unlock(&dsp->cs_dsp.pwr_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(wm_adsp_compr_copy);\n\nstatic void wm_adsp_fatal_error(struct cs_dsp *cs_dsp)\n{\n\tstruct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);\n\tstruct wm_adsp_compr *compr;\n\n\tdsp->fatal_error = true;\n\n\tlist_for_each_entry(compr, &dsp->compr_list, list) {\n\t\tif (compr->stream)\n\t\t\tsnd_compr_fragment_elapsed(compr->stream);\n\t}\n}\n\nirqreturn_t wm_adsp2_bus_error(int irq, void *data)\n{\n\tstruct wm_adsp *dsp = (struct wm_adsp *)data;\n\n\tcs_dsp_adsp2_bus_error(&dsp->cs_dsp);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(wm_adsp2_bus_error);\n\nirqreturn_t wm_halo_bus_error(int irq, void *data)\n{\n\tstruct wm_adsp *dsp = (struct wm_adsp *)data;\n\n\tcs_dsp_halo_bus_error(&dsp->cs_dsp);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(wm_halo_bus_error);\n\nirqreturn_t wm_halo_wdt_expire(int irq, void *data)\n{\n\tstruct wm_adsp *dsp = data;\n\n\tcs_dsp_halo_wdt_expire(&dsp->cs_dsp);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(wm_halo_wdt_expire);\n\nstatic const struct cs_dsp_client_ops wm_adsp1_client_ops = {\n\t.control_add = wm_adsp_control_add,\n\t.control_remove = wm_adsp_control_remove,\n};\n\nstatic const struct cs_dsp_client_ops wm_adsp2_client_ops = {\n\t.control_add = wm_adsp_control_add,\n\t.control_remove = wm_adsp_control_remove,\n\t.pre_run = wm_adsp_pre_run,\n\t.post_run = wm_adsp_event_post_run,\n\t.post_stop = wm_adsp_event_post_stop,\n\t.watchdog_expired = wm_adsp_fatal_error,\n};\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_IMPORT_NS(FW_CS_DSP);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}