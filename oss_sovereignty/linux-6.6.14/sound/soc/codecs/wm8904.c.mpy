{
  "module_name": "wm8904.c",
  "hash_id": "1942e76567df8168c3532daf61c91fdb6c4e54732dbfc6e46bd785909700159f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8904.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/wm8904.h>\n\n#include \"wm8904.h\"\n\nenum wm8904_type {\n\tWM8904,\n\tWM8912,\n};\n\n#define WM8904_NUM_DCS_CHANNELS 4\n\n#define WM8904_NUM_SUPPLIES 5\nstatic const char *wm8904_supply_names[WM8904_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"AVDD\",\n\t\"CPVDD\",\n\t\"MICVDD\",\n};\n\n \nstruct wm8904_priv {\n\tstruct regmap *regmap;\n\tstruct clk *mclk;\n\n\tenum wm8904_type devtype;\n\n\tstruct regulator_bulk_data supplies[WM8904_NUM_SUPPLIES];\n\n\tstruct wm8904_pdata *pdata;\n\n\tint deemph;\n\n\t \n\tconst char **drc_texts;\n\tint drc_cfg;\n\tstruct soc_enum drc_enum;\n\n\t \n\tint num_retune_mobile_texts;\n\tconst char **retune_mobile_texts;\n\tint retune_mobile_cfg;\n\tstruct soc_enum retune_mobile_enum;\n\n\t \n\tint fll_src;\n\tint fll_fref;\n\tint fll_fout;\n\n\t \n\tunsigned int mclk_rate;\n\tint sysclk_src;\n\tunsigned int sysclk_rate;\n\n\tint tdm_width;\n\tint tdm_slots;\n\tint bclk;\n\tint fs;\n\n\t \n\tint dcs_state[WM8904_NUM_DCS_CHANNELS];\n};\n\nstatic const struct reg_default wm8904_reg_defaults[] = {\n\t{ 4,   0x0018 },      \n\t{ 5,   0x0000 },      \n\t{ 6,   0x0000 },      \n\t{ 7,   0x0000 },      \n\t{ 8,   0x0001 },      \n\t{ 9,   0x9696 },      \n\t{ 10,  0x0001 },      \n\t{ 12,  0x0000 },      \n\t{ 14,  0x0000 },      \n\t{ 15,  0x0000 },      \n\t{ 18,  0x0000 },      \n\t{ 20,  0x945E },      \n\t{ 21,  0x0C05 },      \n\t{ 22,  0x0006 },      \n\t{ 24,  0x0050 },      \n\t{ 25,  0x000A },      \n\t{ 26,  0x00E4 },      \n\t{ 27,  0x0040 },      \n\t{ 30,  0x00C0 },      \n\t{ 31,  0x00C0 },      \n\t{ 32,  0x0000 },      \n\t{ 33,  0x0008 },      \n\t{ 36,  0x00C0 },      \n\t{ 37,  0x00C0 },      \n\t{ 38,  0x0010 },      \n\t{ 39,  0x0000 },      \n\t{ 40,  0x01AF },      \n\t{ 41,  0x3248 },      \n\t{ 42,  0x0000 },      \n\t{ 43,  0x0000 },      \n\t{ 44,  0x0085 },      \n\t{ 45,  0x0085 },      \n\t{ 46,  0x0044 },      \n\t{ 47,  0x0044 },      \n\t{ 57,  0x002D },      \n\t{ 58,  0x002D },      \n\t{ 59,  0x0039 },      \n\t{ 60,  0x0039 },      \n\t{ 61,  0x0000 },      \n\t{ 67,  0x0000 },      \n\t{ 69,  0xAAAA },      \n\t{ 71,  0xAAAA },      \n\t{ 72,  0xAAAA },      \n\t{ 90,  0x0000 },      \n\t{ 94,  0x0000 },      \n\t{ 98,  0x0000 },      \n\t{ 104, 0x0004 },      \n\t{ 108, 0x0000 },      \n\t{ 109, 0x0000 },      \n\t{ 110, 0x0000 },      \n\t{ 111, 0x0000 },      \n\t{ 112, 0x0000 },      \n\t{ 116, 0x0000 },      \n\t{ 117, 0x0007 },      \n\t{ 118, 0x0000 },      \n\t{ 119, 0x2EE0 },      \n\t{ 120, 0x0004 },      \n\t{ 121, 0x0014 },      \n\t{ 122, 0x0010 },      \n\t{ 123, 0x0010 },      \n\t{ 124, 0x0000 },      \n\t{ 126, 0x0000 },      \n\t{ 128, 0xFFFF },      \n\t{ 129, 0x0000 },      \n\t{ 130, 0x0000 },      \n\t{ 134, 0x0000 },      \n\t{ 135, 0x000C },      \n\t{ 136, 0x000C },      \n\t{ 137, 0x000C },      \n\t{ 138, 0x000C },      \n\t{ 139, 0x000C },      \n\t{ 140, 0x0FCA },      \n\t{ 141, 0x0400 },      \n\t{ 142, 0x00D8 },      \n\t{ 143, 0x1EB5 },      \n\t{ 144, 0xF145 },      \n\t{ 145, 0x0B75 },      \n\t{ 146, 0x01C5 },      \n\t{ 147, 0x1C58 },      \n\t{ 148, 0xF373 },      \n\t{ 149, 0x0A54 },      \n\t{ 150, 0x0558 },      \n\t{ 151, 0x168E },      \n\t{ 152, 0xF829 },      \n\t{ 153, 0x07AD },      \n\t{ 154, 0x1103 },      \n\t{ 155, 0x0564 },      \n\t{ 156, 0x0559 },      \n\t{ 157, 0x4000 },      \n\t{ 161, 0x0000 },      \n\t{ 204, 0x0000 },      \n\t{ 247, 0x0000 },      \n\t{ 248, 0x0019 },      \n};\n\nstatic bool wm8904_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8904_SW_RESET_AND_ID:\n\tcase WM8904_REVISION:\n\tcase WM8904_DC_SERVO_1:\n\tcase WM8904_DC_SERVO_6:\n\tcase WM8904_DC_SERVO_7:\n\tcase WM8904_DC_SERVO_8:\n\tcase WM8904_DC_SERVO_9:\n\tcase WM8904_DC_SERVO_READBACK_0:\n\tcase WM8904_INTERRUPT_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool wm8904_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8904_SW_RESET_AND_ID:\n\tcase WM8904_REVISION:\n\tcase WM8904_BIAS_CONTROL_0:\n\tcase WM8904_VMID_CONTROL_0:\n\tcase WM8904_MIC_BIAS_CONTROL_0:\n\tcase WM8904_MIC_BIAS_CONTROL_1:\n\tcase WM8904_ANALOGUE_DAC_0:\n\tcase WM8904_MIC_FILTER_CONTROL:\n\tcase WM8904_ANALOGUE_ADC_0:\n\tcase WM8904_POWER_MANAGEMENT_0:\n\tcase WM8904_POWER_MANAGEMENT_2:\n\tcase WM8904_POWER_MANAGEMENT_3:\n\tcase WM8904_POWER_MANAGEMENT_6:\n\tcase WM8904_CLOCK_RATES_0:\n\tcase WM8904_CLOCK_RATES_1:\n\tcase WM8904_CLOCK_RATES_2:\n\tcase WM8904_AUDIO_INTERFACE_0:\n\tcase WM8904_AUDIO_INTERFACE_1:\n\tcase WM8904_AUDIO_INTERFACE_2:\n\tcase WM8904_AUDIO_INTERFACE_3:\n\tcase WM8904_DAC_DIGITAL_VOLUME_LEFT:\n\tcase WM8904_DAC_DIGITAL_VOLUME_RIGHT:\n\tcase WM8904_DAC_DIGITAL_0:\n\tcase WM8904_DAC_DIGITAL_1:\n\tcase WM8904_ADC_DIGITAL_VOLUME_LEFT:\n\tcase WM8904_ADC_DIGITAL_VOLUME_RIGHT:\n\tcase WM8904_ADC_DIGITAL_0:\n\tcase WM8904_DIGITAL_MICROPHONE_0:\n\tcase WM8904_DRC_0:\n\tcase WM8904_DRC_1:\n\tcase WM8904_DRC_2:\n\tcase WM8904_DRC_3:\n\tcase WM8904_ANALOGUE_LEFT_INPUT_0:\n\tcase WM8904_ANALOGUE_RIGHT_INPUT_0:\n\tcase WM8904_ANALOGUE_LEFT_INPUT_1:\n\tcase WM8904_ANALOGUE_RIGHT_INPUT_1:\n\tcase WM8904_ANALOGUE_OUT1_LEFT:\n\tcase WM8904_ANALOGUE_OUT1_RIGHT:\n\tcase WM8904_ANALOGUE_OUT2_LEFT:\n\tcase WM8904_ANALOGUE_OUT2_RIGHT:\n\tcase WM8904_ANALOGUE_OUT12_ZC:\n\tcase WM8904_DC_SERVO_0:\n\tcase WM8904_DC_SERVO_1:\n\tcase WM8904_DC_SERVO_2:\n\tcase WM8904_DC_SERVO_4:\n\tcase WM8904_DC_SERVO_5:\n\tcase WM8904_DC_SERVO_6:\n\tcase WM8904_DC_SERVO_7:\n\tcase WM8904_DC_SERVO_8:\n\tcase WM8904_DC_SERVO_9:\n\tcase WM8904_DC_SERVO_READBACK_0:\n\tcase WM8904_ANALOGUE_HP_0:\n\tcase WM8904_ANALOGUE_LINEOUT_0:\n\tcase WM8904_CHARGE_PUMP_0:\n\tcase WM8904_CLASS_W_0:\n\tcase WM8904_WRITE_SEQUENCER_0:\n\tcase WM8904_WRITE_SEQUENCER_1:\n\tcase WM8904_WRITE_SEQUENCER_2:\n\tcase WM8904_WRITE_SEQUENCER_3:\n\tcase WM8904_WRITE_SEQUENCER_4:\n\tcase WM8904_FLL_CONTROL_1:\n\tcase WM8904_FLL_CONTROL_2:\n\tcase WM8904_FLL_CONTROL_3:\n\tcase WM8904_FLL_CONTROL_4:\n\tcase WM8904_FLL_CONTROL_5:\n\tcase WM8904_GPIO_CONTROL_1:\n\tcase WM8904_GPIO_CONTROL_2:\n\tcase WM8904_GPIO_CONTROL_3:\n\tcase WM8904_GPIO_CONTROL_4:\n\tcase WM8904_DIGITAL_PULLS:\n\tcase WM8904_INTERRUPT_STATUS:\n\tcase WM8904_INTERRUPT_STATUS_MASK:\n\tcase WM8904_INTERRUPT_POLARITY:\n\tcase WM8904_INTERRUPT_DEBOUNCE:\n\tcase WM8904_EQ1:\n\tcase WM8904_EQ2:\n\tcase WM8904_EQ3:\n\tcase WM8904_EQ4:\n\tcase WM8904_EQ5:\n\tcase WM8904_EQ6:\n\tcase WM8904_EQ7:\n\tcase WM8904_EQ8:\n\tcase WM8904_EQ9:\n\tcase WM8904_EQ10:\n\tcase WM8904_EQ11:\n\tcase WM8904_EQ12:\n\tcase WM8904_EQ13:\n\tcase WM8904_EQ14:\n\tcase WM8904_EQ15:\n\tcase WM8904_EQ16:\n\tcase WM8904_EQ17:\n\tcase WM8904_EQ18:\n\tcase WM8904_EQ19:\n\tcase WM8904_EQ20:\n\tcase WM8904_EQ21:\n\tcase WM8904_EQ22:\n\tcase WM8904_EQ23:\n\tcase WM8904_EQ24:\n\tcase WM8904_CONTROL_INTERFACE_TEST_1:\n\tcase WM8904_ADC_TEST_0:\n\tcase WM8904_ANALOGUE_OUTPUT_BIAS_0:\n\tcase WM8904_FLL_NCO_TEST_0:\n\tcase WM8904_FLL_NCO_TEST_1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8904_configure_clocking(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tunsigned int clock0, clock2, rate;\n\n\t \n\tclock2 = snd_soc_component_read(component, WM8904_CLOCK_RATES_2);\n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_2,\n\t\t\t    WM8904_SYSCLK_SRC, 0);\n\n\t \n\tswitch (wm8904->sysclk_src) {\n\tcase WM8904_CLK_MCLK:\n\t\tdev_dbg(component->dev, \"Using %dHz MCLK\\n\", wm8904->mclk_rate);\n\n\t\tclock2 &= ~WM8904_SYSCLK_SRC;\n\t\trate = wm8904->mclk_rate;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t\t    WM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\n\t\tbreak;\n\n\tcase WM8904_CLK_FLL:\n\t\tdev_dbg(component->dev, \"Using %dHz FLL clock\\n\",\n\t\t\twm8904->fll_fout);\n\n\t\tclock2 |= WM8904_SYSCLK_SRC;\n\t\trate = wm8904->fll_fout;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"System clock not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rate > 13500000) {\n\t\tclock0 = WM8904_MCLK_DIV;\n\t\twm8904->sysclk_rate = rate / 2;\n\t} else {\n\t\tclock0 = 0;\n\t\twm8904->sysclk_rate = rate;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_0, WM8904_MCLK_DIV,\n\t\t\t    clock0);\n\n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_2,\n\t\t\t    WM8904_CLK_SYS_ENA | WM8904_SYSCLK_SRC, clock2);\n\n\tdev_dbg(component->dev, \"CLK_SYS is %dHz\\n\", wm8904->sysclk_rate);\n\n\treturn 0;\n}\n\nstatic void wm8904_set_drc(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tint save, i;\n\n\t \n\tsave = snd_soc_component_read(component, WM8904_DRC_0);\n\n\tfor (i = 0; i < WM8904_DRC_REGS; i++)\n\t\tsnd_soc_component_update_bits(component, WM8904_DRC_0 + i, 0xffff,\n\t\t\t\t    pdata->drc_cfgs[wm8904->drc_cfg].regs[i]);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8904_DRC_0,\n\t\t\t    WM8904_DRC_ENA | WM8904_DRC_DAC_PATH, save);\n}\n\nstatic int wm8904_put_drc_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tint value = ucontrol->value.enumerated.item[0];\n\n\tif (value >= pdata->num_drc_cfgs)\n\t\treturn -EINVAL;\n\n\twm8904->drc_cfg = value;\n\n\twm8904_set_drc(component);\n\n\treturn 0;\n}\n\nstatic int wm8904_get_drc_enum(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8904->drc_cfg;\n\n\treturn 0;\n}\n\nstatic void wm8904_set_retune_mobile(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tint best, best_val, save, i, cfg;\n\n\tif (!pdata || !wm8904->num_retune_mobile_texts)\n\t\treturn;\n\n\t \n\tcfg = wm8904->retune_mobile_cfg;\n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\n\t\tif (strcmp(pdata->retune_mobile_cfgs[i].name,\n\t\t\t   wm8904->retune_mobile_texts[cfg]) == 0 &&\n\t\t    abs(pdata->retune_mobile_cfgs[i].rate\n\t\t\t- wm8904->fs) < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = abs(pdata->retune_mobile_cfgs[i].rate\n\t\t\t\t       - wm8904->fs);\n\t\t}\n\t}\n\n\tdev_dbg(component->dev, \"ReTune Mobile %s/%dHz for %dHz sample rate\\n\",\n\t\tpdata->retune_mobile_cfgs[best].name,\n\t\tpdata->retune_mobile_cfgs[best].rate,\n\t\twm8904->fs);\n\n\t \n\tsave = snd_soc_component_read(component, WM8904_EQ1);\n\n\tfor (i = 0; i < WM8904_EQ_REGS; i++)\n\t\tsnd_soc_component_update_bits(component, WM8904_EQ1 + i, 0xffff,\n\t\t\t\tpdata->retune_mobile_cfgs[best].regs[i]);\n\n\tsnd_soc_component_update_bits(component, WM8904_EQ1, WM8904_EQ_ENA, save);\n}\n\nstatic int wm8904_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tint value = ucontrol->value.enumerated.item[0];\n\n\tif (value >= pdata->num_retune_mobile_cfgs)\n\t\treturn -EINVAL;\n\n\twm8904->retune_mobile_cfg = value;\n\n\twm8904_set_retune_mobile(component);\n\n\treturn 0;\n}\n\nstatic int wm8904_get_retune_mobile_enum(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = wm8904->retune_mobile_cfg;\n\n\treturn 0;\n}\n\nstatic int deemph_settings[] = { 0, 32000, 44100, 48000 };\n\nstatic int wm8904_set_deemph(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tint val, i, best;\n\n\t \n\tif (wm8904->deemph) {\n\t\tbest = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(deemph_settings); i++) {\n\t\t\tif (abs(deemph_settings[i] - wm8904->fs) <\n\t\t\t    abs(deemph_settings[best] - wm8904->fs))\n\t\t\t\tbest = i;\n\t\t}\n\n\t\tval = best << WM8904_DEEMPH_SHIFT;\n\t} else {\n\t\tval = 0;\n\t}\n\n\tdev_dbg(component->dev, \"Set deemphasis %d\\n\", val);\n\n\treturn snd_soc_component_update_bits(component, WM8904_DAC_DIGITAL_1,\n\t\t\t\t   WM8904_DEEMPH_MASK, val);\n}\n\nstatic int wm8904_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = wm8904->deemph;\n\treturn 0;\n}\n\nstatic int wm8904_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\twm8904->deemph = deemph;\n\n\treturn wm8904_set_deemph(component);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_boost_tlv, 0, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -7200, 75, 1);\nstatic const DECLARE_TLV_DB_SCALE(out_tlv, -5700, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(sidetone_tlv, -3600, 300, 0);\nstatic const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);\n\nstatic const char *hpf_mode_text[] = {\n\t\"Hi-fi\", \"Voice 1\", \"Voice 2\", \"Voice 3\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(hpf_mode, WM8904_ADC_DIGITAL_0, 5,\n\t\t\t    hpf_mode_text);\n\nstatic int wm8904_adc_osr_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tunsigned int val;\n\tint ret;\n\n\tret = snd_soc_put_volsw(kcontrol, ucontrol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ucontrol->value.integer.value[0])\n\t\tval = 0;\n\telse\n\t\tval = WM8904_ADC_128_OSR_TST_MODE | WM8904_ADC_BIASX1P5;\n\n\tsnd_soc_component_update_bits(component, WM8904_ADC_TEST_0,\n\t\t\t    WM8904_ADC_128_OSR_TST_MODE | WM8904_ADC_BIASX1P5,\n\t\t\t    val);\n\n\treturn ret;\n}\n\nstatic const struct snd_kcontrol_new wm8904_adc_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Digital Capture Volume\", WM8904_ADC_DIGITAL_VOLUME_LEFT,\n\t\t WM8904_ADC_DIGITAL_VOLUME_RIGHT, 1, 119, 0, digital_tlv),\n\n \nSOC_DOUBLE_R(\"Capture Volume\", WM8904_ANALOGUE_LEFT_INPUT_0,\n\t     WM8904_ANALOGUE_RIGHT_INPUT_0, 0, 31, 0),\nSOC_DOUBLE_R(\"Capture Switch\", WM8904_ANALOGUE_LEFT_INPUT_0,\n\t     WM8904_ANALOGUE_RIGHT_INPUT_0, 7, 1, 1),\n\nSOC_SINGLE(\"High Pass Filter Switch\", WM8904_ADC_DIGITAL_0, 4, 1, 0),\nSOC_ENUM(\"High Pass Filter Mode\", hpf_mode),\nSOC_SINGLE_EXT(\"ADC 128x OSR Switch\", WM8904_ANALOGUE_ADC_0, 0, 1, 0,\n\tsnd_soc_get_volsw, wm8904_adc_osr_put),\n};\n\nstatic const char *drc_path_text[] = {\n\t\"ADC\", \"DAC\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(drc_path, WM8904_DRC_0, 14, drc_path_text);\n\nstatic const struct snd_kcontrol_new wm8904_dac_snd_controls[] = {\nSOC_SINGLE_TLV(\"Digital Playback Boost Volume\", \n\t       WM8904_AUDIO_INTERFACE_0, 9, 3, 0, dac_boost_tlv),\nSOC_DOUBLE_R_TLV(\"Digital Playback Volume\", WM8904_DAC_DIGITAL_VOLUME_LEFT,\n\t\t WM8904_DAC_DIGITAL_VOLUME_RIGHT, 1, 96, 0, digital_tlv),\n\nSOC_DOUBLE_R_TLV(\"Headphone Volume\", WM8904_ANALOGUE_OUT1_LEFT,\n\t\t WM8904_ANALOGUE_OUT1_RIGHT, 0, 63, 0, out_tlv),\nSOC_DOUBLE_R(\"Headphone Switch\", WM8904_ANALOGUE_OUT1_LEFT,\n\t     WM8904_ANALOGUE_OUT1_RIGHT, 8, 1, 1),\nSOC_DOUBLE_R(\"Headphone ZC Switch\", WM8904_ANALOGUE_OUT1_LEFT,\n\t     WM8904_ANALOGUE_OUT1_RIGHT, 6, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Line Output Volume\", WM8904_ANALOGUE_OUT2_LEFT,\n\t\t WM8904_ANALOGUE_OUT2_RIGHT, 0, 63, 0, out_tlv),\nSOC_DOUBLE_R(\"Line Output Switch\", WM8904_ANALOGUE_OUT2_LEFT,\n\t     WM8904_ANALOGUE_OUT2_RIGHT, 8, 1, 1),\nSOC_DOUBLE_R(\"Line Output ZC Switch\", WM8904_ANALOGUE_OUT2_LEFT,\n\t     WM8904_ANALOGUE_OUT2_RIGHT, 6, 1, 0),\n\nSOC_SINGLE(\"EQ Switch\", WM8904_EQ1, 0, 1, 0),\nSOC_SINGLE(\"DRC Switch\", WM8904_DRC_0, 15, 1, 0),\nSOC_ENUM(\"DRC Path\", drc_path),\nSOC_SINGLE(\"DAC OSRx2 Switch\", WM8904_DAC_DIGITAL_1, 6, 1, 0),\nSOC_SINGLE_BOOL_EXT(\"DAC Deemphasis Switch\", 0,\n\t\t    wm8904_get_deemph, wm8904_put_deemph),\n};\n\nstatic const struct snd_kcontrol_new wm8904_snd_controls[] = {\nSOC_DOUBLE_TLV(\"Digital Sidetone Volume\", WM8904_DAC_DIGITAL_0, 4, 8, 15, 0,\n\t       sidetone_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm8904_eq_controls[] = {\nSOC_SINGLE_TLV(\"EQ1 Volume\", WM8904_EQ2, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ2 Volume\", WM8904_EQ3, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ3 Volume\", WM8904_EQ4, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ4 Volume\", WM8904_EQ5, 0, 24, 0, eq_tlv),\nSOC_SINGLE_TLV(\"EQ5 Volume\", WM8904_EQ6, 0, 24, 0, eq_tlv),\n};\n\nstatic int cp_event(struct snd_soc_dapm_widget *w,\n\t\t    struct snd_kcontrol *kcontrol, int event)\n{\n\tif (WARN_ON(event != SND_SOC_DAPM_POST_PMU))\n\t\treturn -EINVAL;\n\n\t \n\tudelay(500);\n\n\treturn 0;\n}\n\nstatic int sysclk_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tswitch (wm8904->sysclk_src) {\n\t\tcase WM8904_CLK_FLL:\n\t\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t\t\t    WM8904_FLL_OSC_ENA,\n\t\t\t\t\t    WM8904_FLL_OSC_ENA);\n\n\t\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t\t\t    WM8904_FLL_ENA,\n\t\t\t\t\t    WM8904_FLL_ENA);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t\t    WM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int out_pga_event(struct snd_soc_dapm_widget *w,\n\t\t\t struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tint reg, val;\n\tint dcs_mask;\n\tint dcs_l, dcs_r;\n\tint dcs_l_reg, dcs_r_reg;\n\tint an_out_reg;\n\tint timeout;\n\tint pwr_reg;\n\n\t \n\treg = w->shift;\n\n\tswitch (reg) {\n\tcase WM8904_ANALOGUE_HP_0:\n\t\tpwr_reg = WM8904_POWER_MANAGEMENT_2;\n\t\tdcs_mask = WM8904_DCS_ENA_CHAN_0 | WM8904_DCS_ENA_CHAN_1;\n\t\tdcs_r_reg = WM8904_DC_SERVO_8;\n\t\tdcs_l_reg = WM8904_DC_SERVO_9;\n\t\tan_out_reg = WM8904_ANALOGUE_OUT1_LEFT;\n\t\tdcs_l = 0;\n\t\tdcs_r = 1;\n\t\tbreak;\n\tcase WM8904_ANALOGUE_LINEOUT_0:\n\t\tpwr_reg = WM8904_POWER_MANAGEMENT_3;\n\t\tdcs_mask = WM8904_DCS_ENA_CHAN_2 | WM8904_DCS_ENA_CHAN_3;\n\t\tdcs_r_reg = WM8904_DC_SERVO_6;\n\t\tdcs_l_reg = WM8904_DC_SERVO_7;\n\t\tan_out_reg = WM8904_ANALOGUE_OUT2_LEFT;\n\t\tdcs_l = 2;\n\t\tdcs_r = 3;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid reg %d\\n\", reg);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, pwr_reg,\n\t\t\t\t    WM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA,\n\t\t\t\t    WM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_ENA | WM8904_HPR_ENA,\n\t\t\t\t    WM8904_HPL_ENA | WM8904_HPR_ENA);\n\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY,\n\t\t\t\t    WM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_DC_SERVO_0,\n\t\t\t\t    dcs_mask, dcs_mask);\n\n\t\t \n\t\tif (wm8904->dcs_state[dcs_l] || wm8904->dcs_state[dcs_r]) {\n\t\t\tdev_dbg(component->dev, \"Restoring DC servo state\\n\");\n\n\t\t\tsnd_soc_component_write(component, dcs_l_reg,\n\t\t\t\t      wm8904->dcs_state[dcs_l]);\n\t\t\tsnd_soc_component_write(component, dcs_r_reg,\n\t\t\t\t      wm8904->dcs_state[dcs_r]);\n\n\t\t\tsnd_soc_component_write(component, WM8904_DC_SERVO_1, dcs_mask);\n\n\t\t\ttimeout = 20;\n\t\t} else {\n\t\t\tdev_dbg(component->dev, \"Calibrating DC servo\\n\");\n\n\t\t\tsnd_soc_component_write(component, WM8904_DC_SERVO_1,\n\t\t\t\tdcs_mask << WM8904_DCS_TRIG_STARTUP_0_SHIFT);\n\n\t\t\ttimeout = 500;\n\t\t}\n\n\t\t \n\t\tdcs_mask <<= WM8904_DCS_CAL_COMPLETE_SHIFT;\n\t\tdo {\n\t\t\tval = snd_soc_component_read(component, WM8904_DC_SERVO_READBACK_0);\n\t\t\tif ((val & dcs_mask) == dcs_mask)\n\t\t\t\tbreak;\n\n\t\t\tmsleep(1);\n\t\t} while (--timeout);\n\n\t\tif ((val & dcs_mask) != dcs_mask)\n\t\t\tdev_warn(component->dev, \"DC servo timed out\\n\");\n\t\telse\n\t\t\tdev_dbg(component->dev, \"DC servo ready\\n\");\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP,\n\t\t\t\t    WM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP);\n\n\t\t \n\t\tval = snd_soc_component_read(component, an_out_reg);\n\t\tsnd_soc_component_write(component, an_out_reg, val);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_RMV_SHORT |\n\t\t\t\t    WM8904_HPR_RMV_SHORT,\n\t\t\t\t    WM8904_HPL_RMV_SHORT |\n\t\t\t\t    WM8904_HPR_RMV_SHORT);\n\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_RMV_SHORT |\n\t\t\t\t    WM8904_HPR_RMV_SHORT, 0);\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\t \n\t\twm8904->dcs_state[dcs_l] = snd_soc_component_read(component, dcs_l_reg);\n\t\twm8904->dcs_state[dcs_r] = snd_soc_component_read(component, dcs_r_reg);\n\n\t\tsnd_soc_component_update_bits(component, WM8904_DC_SERVO_0,\n\t\t\t\t    dcs_mask, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, reg,\n\t\t\t\t    WM8904_HPL_ENA | WM8904_HPR_ENA |\n\t\t\t\t    WM8904_HPL_ENA_DLY | WM8904_HPR_ENA_DLY |\n\t\t\t\t    WM8904_HPL_ENA_OUTP | WM8904_HPR_ENA_OUTP,\n\t\t\t\t    0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, pwr_reg,\n\t\t\t\t    WM8904_HPL_PGA_ENA | WM8904_HPR_PGA_ENA,\n\t\t\t\t    0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *input_mode_text[] = {\n\t\"Single-Ended\", \"Differential Line\", \"Differential Mic\"\n};\n\nstatic const char *lin_text[] = {\n\t\"IN1L\", \"IN2L\", \"IN3L\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(lin_enum, WM8904_ANALOGUE_LEFT_INPUT_1, 2,\n\t\t\t    lin_text);\n\nstatic const struct snd_kcontrol_new lin_mux =\n\tSOC_DAPM_ENUM(\"Left Capture Mux\", lin_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(lin_inv_enum, WM8904_ANALOGUE_LEFT_INPUT_1, 4,\n\t\t\t    lin_text);\n\nstatic const struct snd_kcontrol_new lin_inv_mux =\n\tSOC_DAPM_ENUM(\"Left Capture Inverting Mux\", lin_inv_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(lin_mode_enum,\n\t\t\t    WM8904_ANALOGUE_LEFT_INPUT_1, 0,\n\t\t\t    input_mode_text);\n\nstatic const struct snd_kcontrol_new lin_mode =\n\tSOC_DAPM_ENUM(\"Left Capture Mode\", lin_mode_enum);\n\nstatic const char *rin_text[] = {\n\t\"IN1R\", \"IN2R\", \"IN3R\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rin_enum, WM8904_ANALOGUE_RIGHT_INPUT_1, 2,\n\t\t\t    rin_text);\n\nstatic const struct snd_kcontrol_new rin_mux =\n\tSOC_DAPM_ENUM(\"Right Capture Mux\", rin_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(rin_inv_enum, WM8904_ANALOGUE_RIGHT_INPUT_1, 4,\n\t\t\t    rin_text);\n\nstatic const struct snd_kcontrol_new rin_inv_mux =\n\tSOC_DAPM_ENUM(\"Right Capture Inverting Mux\", rin_inv_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(rin_mode_enum,\n\t\t\t    WM8904_ANALOGUE_RIGHT_INPUT_1, 0,\n\t\t\t    input_mode_text);\n\nstatic const struct snd_kcontrol_new rin_mode =\n\tSOC_DAPM_ENUM(\"Right Capture Mode\", rin_mode_enum);\n\nstatic const char *aif_text[] = {\n\t\"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(aifoutl_enum, WM8904_AUDIO_INTERFACE_0, 7,\n\t\t\t    aif_text);\n\nstatic const struct snd_kcontrol_new aifoutl_mux =\n\tSOC_DAPM_ENUM(\"AIFOUTL Mux\", aifoutl_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifoutr_enum, WM8904_AUDIO_INTERFACE_0, 6,\n\t\t\t    aif_text);\n\nstatic const struct snd_kcontrol_new aifoutr_mux =\n\tSOC_DAPM_ENUM(\"AIFOUTR Mux\", aifoutr_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifinl_enum, WM8904_AUDIO_INTERFACE_0, 5,\n\t\t\t    aif_text);\n\nstatic const struct snd_kcontrol_new aifinl_mux =\n\tSOC_DAPM_ENUM(\"AIFINL Mux\", aifinl_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(aifinr_enum, WM8904_AUDIO_INTERFACE_0, 4,\n\t\t\t    aif_text);\n\nstatic const struct snd_kcontrol_new aifinr_mux =\n\tSOC_DAPM_ENUM(\"AIFINR Mux\", aifinr_enum);\n\nstatic const struct snd_soc_dapm_widget wm8904_core_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"SYSCLK\", WM8904_CLOCK_RATES_2, 2, 0, sysclk_event,\n\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_SUPPLY(\"CLK_DSP\", WM8904_CLOCK_RATES_2, 1, 0, NULL, 0),\nSND_SOC_DAPM_SUPPLY(\"TOCLK\", WM8904_CLOCK_RATES_2, 0, 0, NULL, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8904_adc_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"IN1L\"),\nSND_SOC_DAPM_INPUT(\"IN1R\"),\nSND_SOC_DAPM_INPUT(\"IN2L\"),\nSND_SOC_DAPM_INPUT(\"IN2R\"),\nSND_SOC_DAPM_INPUT(\"IN3L\"),\nSND_SOC_DAPM_INPUT(\"IN3R\"),\n\nSND_SOC_DAPM_SUPPLY(\"MICBIAS\", WM8904_MIC_BIAS_CONTROL_0, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"Left Capture Mux\", SND_SOC_NOPM, 0, 0, &lin_mux),\nSND_SOC_DAPM_MUX(\"Left Capture Inverting Mux\", SND_SOC_NOPM, 0, 0,\n\t\t &lin_inv_mux),\nSND_SOC_DAPM_MUX(\"Left Capture Mode\", SND_SOC_NOPM, 0, 0, &lin_mode),\nSND_SOC_DAPM_MUX(\"Right Capture Mux\", SND_SOC_NOPM, 0, 0, &rin_mux),\nSND_SOC_DAPM_MUX(\"Right Capture Inverting Mux\", SND_SOC_NOPM, 0, 0,\n\t\t &rin_inv_mux),\nSND_SOC_DAPM_MUX(\"Right Capture Mode\", SND_SOC_NOPM, 0, 0, &rin_mode),\n\nSND_SOC_DAPM_PGA(\"Left Capture PGA\", WM8904_POWER_MANAGEMENT_0, 1, 0,\n\t\t NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Capture PGA\", WM8904_POWER_MANAGEMENT_0, 0, 0,\n\t\t NULL, 0),\n\nSND_SOC_DAPM_ADC(\"ADCL\", NULL, WM8904_POWER_MANAGEMENT_6, 1, 0),\nSND_SOC_DAPM_ADC(\"ADCR\", NULL, WM8904_POWER_MANAGEMENT_6, 0, 0),\n\nSND_SOC_DAPM_MUX(\"AIFOUTL Mux\", SND_SOC_NOPM, 0, 0, &aifoutl_mux),\nSND_SOC_DAPM_MUX(\"AIFOUTR Mux\", SND_SOC_NOPM, 0, 0, &aifoutr_mux),\n\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTL\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_OUT(\"AIFOUTR\", \"Capture\", 1, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_widget wm8904_dac_dapm_widgets[] = {\nSND_SOC_DAPM_AIF_IN(\"AIFINL\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_AIF_IN(\"AIFINR\", \"Playback\", 1, SND_SOC_NOPM, 0, 0),\n\nSND_SOC_DAPM_MUX(\"DACL Mux\", SND_SOC_NOPM, 0, 0, &aifinl_mux),\nSND_SOC_DAPM_MUX(\"DACR Mux\", SND_SOC_NOPM, 0, 0, &aifinr_mux),\n\nSND_SOC_DAPM_DAC(\"DACL\", NULL, WM8904_POWER_MANAGEMENT_6, 3, 0),\nSND_SOC_DAPM_DAC(\"DACR\", NULL, WM8904_POWER_MANAGEMENT_6, 2, 0),\n\nSND_SOC_DAPM_SUPPLY(\"Charge pump\", WM8904_CHARGE_PUMP_0, 0, 0, cp_event,\n\t\t    SND_SOC_DAPM_POST_PMU),\n\nSND_SOC_DAPM_PGA(\"HPL PGA\", SND_SOC_NOPM, 1, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"HPR PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA(\"LINEL PGA\", SND_SOC_NOPM, 1, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"LINER PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_PGA_E(\"Headphone Output\", SND_SOC_NOPM, WM8904_ANALOGUE_HP_0,\n\t\t   0, NULL, 0, out_pga_event,\n\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\nSND_SOC_DAPM_PGA_E(\"Line Output\", SND_SOC_NOPM, WM8904_ANALOGUE_LINEOUT_0,\n\t\t   0, NULL, 0, out_pga_event,\n\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\nSND_SOC_DAPM_OUTPUT(\"HPOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"HPOUTR\"),\nSND_SOC_DAPM_OUTPUT(\"LINEOUTL\"),\nSND_SOC_DAPM_OUTPUT(\"LINEOUTR\"),\n};\n\nstatic const char *out_mux_text[] = {\n\t\"DAC\", \"Bypass\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(hpl_enum, WM8904_ANALOGUE_OUT12_ZC, 3,\n\t\t\t    out_mux_text);\n\nstatic const struct snd_kcontrol_new hpl_mux =\n\tSOC_DAPM_ENUM(\"HPL Mux\", hpl_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(hpr_enum, WM8904_ANALOGUE_OUT12_ZC, 2,\n\t\t\t    out_mux_text);\n\nstatic const struct snd_kcontrol_new hpr_mux =\n\tSOC_DAPM_ENUM(\"HPR Mux\", hpr_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(linel_enum, WM8904_ANALOGUE_OUT12_ZC, 1,\n\t\t\t    out_mux_text);\n\nstatic const struct snd_kcontrol_new linel_mux =\n\tSOC_DAPM_ENUM(\"LINEL Mux\", linel_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(liner_enum, WM8904_ANALOGUE_OUT12_ZC, 0,\n\t\t\t    out_mux_text);\n\nstatic const struct snd_kcontrol_new liner_mux =\n\tSOC_DAPM_ENUM(\"LINER Mux\", liner_enum);\n\nstatic const char *sidetone_text[] = {\n\t\"None\", \"Left\", \"Right\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(dacl_sidetone_enum, WM8904_DAC_DIGITAL_0, 2,\n\t\t\t    sidetone_text);\n\nstatic const struct snd_kcontrol_new dacl_sidetone_mux =\n\tSOC_DAPM_ENUM(\"Left Sidetone Mux\", dacl_sidetone_enum);\n\nstatic SOC_ENUM_SINGLE_DECL(dacr_sidetone_enum, WM8904_DAC_DIGITAL_0, 0,\n\t\t\t    sidetone_text);\n\nstatic const struct snd_kcontrol_new dacr_sidetone_mux =\n\tSOC_DAPM_ENUM(\"Right Sidetone Mux\", dacr_sidetone_enum);\n\nstatic const struct snd_soc_dapm_widget wm8904_dapm_widgets[] = {\nSND_SOC_DAPM_SUPPLY(\"Class G\", WM8904_CLASS_W_0, 0, 1, NULL, 0),\nSND_SOC_DAPM_PGA(\"Left Bypass\", SND_SOC_NOPM, 0, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"Right Bypass\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\nSND_SOC_DAPM_MUX(\"Left Sidetone\", SND_SOC_NOPM, 0, 0, &dacl_sidetone_mux),\nSND_SOC_DAPM_MUX(\"Right Sidetone\", SND_SOC_NOPM, 0, 0, &dacr_sidetone_mux),\n\nSND_SOC_DAPM_MUX(\"HPL Mux\", SND_SOC_NOPM, 0, 0, &hpl_mux),\nSND_SOC_DAPM_MUX(\"HPR Mux\", SND_SOC_NOPM, 0, 0, &hpr_mux),\nSND_SOC_DAPM_MUX(\"LINEL Mux\", SND_SOC_NOPM, 0, 0, &linel_mux),\nSND_SOC_DAPM_MUX(\"LINER Mux\", SND_SOC_NOPM, 0, 0, &liner_mux),\n};\n\nstatic const struct snd_soc_dapm_route core_intercon[] = {\n\t{ \"CLK_DSP\", NULL, \"SYSCLK\" },\n\t{ \"TOCLK\", NULL, \"SYSCLK\" },\n};\n\nstatic const struct snd_soc_dapm_route adc_intercon[] = {\n\t{ \"Left Capture Mux\", \"IN1L\", \"IN1L\" },\n\t{ \"Left Capture Mux\", \"IN2L\", \"IN2L\" },\n\t{ \"Left Capture Mux\", \"IN3L\", \"IN3L\" },\n\n\t{ \"Left Capture Inverting Mux\", \"IN1L\", \"IN1L\" },\n\t{ \"Left Capture Inverting Mux\", \"IN2L\", \"IN2L\" },\n\t{ \"Left Capture Inverting Mux\", \"IN3L\", \"IN3L\" },\n\n\t{ \"Left Capture Mode\", \"Single-Ended\", \"Left Capture Inverting Mux\" },\n\t{ \"Left Capture Mode\", \"Differential Line\", \"Left Capture Mux\" },\n\t{ \"Left Capture Mode\", \"Differential Line\", \"Left Capture Inverting Mux\" },\n\t{ \"Left Capture Mode\", \"Differential Mic\", \"Left Capture Mux\" },\n\t{ \"Left Capture Mode\", \"Differential Mic\", \"Left Capture Inverting Mux\" },\n\n\t{ \"Right Capture Mux\", \"IN1R\", \"IN1R\" },\n\t{ \"Right Capture Mux\", \"IN2R\", \"IN2R\" },\n\t{ \"Right Capture Mux\", \"IN3R\", \"IN3R\" },\n\n\t{ \"Right Capture Inverting Mux\", \"IN1R\", \"IN1R\" },\n\t{ \"Right Capture Inverting Mux\", \"IN2R\", \"IN2R\" },\n\t{ \"Right Capture Inverting Mux\", \"IN3R\", \"IN3R\" },\n\n\t{ \"Right Capture Mode\", \"Single-Ended\", \"Right Capture Inverting Mux\" },\n\t{ \"Right Capture Mode\", \"Differential Line\", \"Right Capture Mux\" },\n\t{ \"Right Capture Mode\", \"Differential Line\", \"Right Capture Inverting Mux\" },\n\t{ \"Right Capture Mode\", \"Differential Mic\", \"Right Capture Mux\" },\n\t{ \"Right Capture Mode\", \"Differential Mic\", \"Right Capture Inverting Mux\" },\n\n\t{ \"Left Capture PGA\", NULL, \"Left Capture Mode\" },\n\t{ \"Right Capture PGA\", NULL, \"Right Capture Mode\" },\n\n\t{ \"AIFOUTL Mux\", \"Left\", \"ADCL\" },\n\t{ \"AIFOUTL Mux\", \"Right\", \"ADCR\" },\n\t{ \"AIFOUTR Mux\", \"Left\", \"ADCL\" },\n\t{ \"AIFOUTR Mux\", \"Right\", \"ADCR\" },\n\n\t{ \"AIFOUTL\", NULL, \"AIFOUTL Mux\" },\n\t{ \"AIFOUTR\", NULL, \"AIFOUTR Mux\" },\n\n\t{ \"ADCL\", NULL, \"CLK_DSP\" },\n\t{ \"ADCL\", NULL, \"Left Capture PGA\" },\n\n\t{ \"ADCR\", NULL, \"CLK_DSP\" },\n\t{ \"ADCR\", NULL, \"Right Capture PGA\" },\n};\n\nstatic const struct snd_soc_dapm_route dac_intercon[] = {\n\t{ \"DACL Mux\", \"Left\", \"AIFINL\" },\n\t{ \"DACL Mux\", \"Right\", \"AIFINR\" },\n\n\t{ \"DACR Mux\", \"Left\", \"AIFINL\" },\n\t{ \"DACR Mux\", \"Right\", \"AIFINR\" },\n\n\t{ \"DACL\", NULL, \"DACL Mux\" },\n\t{ \"DACL\", NULL, \"CLK_DSP\" },\n\n\t{ \"DACR\", NULL, \"DACR Mux\" },\n\t{ \"DACR\", NULL, \"CLK_DSP\" },\n\n\t{ \"Charge pump\", NULL, \"SYSCLK\" },\n\n\t{ \"Headphone Output\", NULL, \"HPL PGA\" },\n\t{ \"Headphone Output\", NULL, \"HPR PGA\" },\n\t{ \"Headphone Output\", NULL, \"Charge pump\" },\n\t{ \"Headphone Output\", NULL, \"TOCLK\" },\n\n\t{ \"Line Output\", NULL, \"LINEL PGA\" },\n\t{ \"Line Output\", NULL, \"LINER PGA\" },\n\t{ \"Line Output\", NULL, \"Charge pump\" },\n\t{ \"Line Output\", NULL, \"TOCLK\" },\n\n\t{ \"HPOUTL\", NULL, \"Headphone Output\" },\n\t{ \"HPOUTR\", NULL, \"Headphone Output\" },\n\n\t{ \"LINEOUTL\", NULL, \"Line Output\" },\n\t{ \"LINEOUTR\", NULL, \"Line Output\" },\n};\n\nstatic const struct snd_soc_dapm_route wm8904_intercon[] = {\n\t{ \"Left Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"Left Sidetone\", \"Right\", \"ADCR\" },\n\t{ \"DACL\", NULL, \"Left Sidetone\" },\n\t\n\t{ \"Right Sidetone\", \"Left\", \"ADCL\" },\n\t{ \"Right Sidetone\", \"Right\", \"ADCR\" },\n\t{ \"DACR\", NULL, \"Right Sidetone\" },\n\n\t{ \"Left Bypass\", NULL, \"Class G\" },\n\t{ \"Left Bypass\", NULL, \"Left Capture PGA\" },\n\n\t{ \"Right Bypass\", NULL, \"Class G\" },\n\t{ \"Right Bypass\", NULL, \"Right Capture PGA\" },\n\n\t{ \"HPL Mux\", \"DAC\", \"DACL\" },\n\t{ \"HPL Mux\", \"Bypass\", \"Left Bypass\" },\n\n\t{ \"HPR Mux\", \"DAC\", \"DACR\" },\n\t{ \"HPR Mux\", \"Bypass\", \"Right Bypass\" },\n\n\t{ \"LINEL Mux\", \"DAC\", \"DACL\" },\n\t{ \"LINEL Mux\", \"Bypass\", \"Left Bypass\" },\n\n\t{ \"LINER Mux\", \"DAC\", \"DACR\" },\n\t{ \"LINER Mux\", \"Bypass\", \"Right Bypass\" },\n\n\t{ \"HPL PGA\", NULL, \"HPL Mux\" },\n\t{ \"HPR PGA\", NULL, \"HPR Mux\" },\n\n\t{ \"LINEL PGA\", NULL, \"LINEL Mux\" },\n\t{ \"LINER PGA\", NULL, \"LINER Mux\" },\n};\n\nstatic const struct snd_soc_dapm_route wm8912_intercon[] = {\n\t{ \"HPL PGA\", NULL, \"DACL\" },\n\t{ \"HPR PGA\", NULL, \"DACR\" },\n\n\t{ \"LINEL PGA\", NULL, \"DACL\" },\n\t{ \"LINER PGA\", NULL, \"DACR\" },\n};\n\nstatic int wm8904_add_widgets(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tsnd_soc_dapm_new_controls(dapm, wm8904_core_dapm_widgets,\n\t\t\t\t  ARRAY_SIZE(wm8904_core_dapm_widgets));\n\tsnd_soc_dapm_add_routes(dapm, core_intercon,\n\t\t\t\tARRAY_SIZE(core_intercon));\n\n\tswitch (wm8904->devtype) {\n\tcase WM8904:\n\t\tsnd_soc_add_component_controls(component, wm8904_adc_snd_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_adc_snd_controls));\n\t\tsnd_soc_add_component_controls(component, wm8904_dac_snd_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_dac_snd_controls));\n\t\tsnd_soc_add_component_controls(component, wm8904_snd_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_snd_controls));\n\n\t\tsnd_soc_dapm_new_controls(dapm, wm8904_adc_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(wm8904_adc_dapm_widgets));\n\t\tsnd_soc_dapm_new_controls(dapm, wm8904_dac_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(wm8904_dac_dapm_widgets));\n\t\tsnd_soc_dapm_new_controls(dapm, wm8904_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(wm8904_dapm_widgets));\n\n\t\tsnd_soc_dapm_add_routes(dapm, adc_intercon,\n\t\t\t\t\tARRAY_SIZE(adc_intercon));\n\t\tsnd_soc_dapm_add_routes(dapm, dac_intercon,\n\t\t\t\t\tARRAY_SIZE(dac_intercon));\n\t\tsnd_soc_dapm_add_routes(dapm, wm8904_intercon,\n\t\t\t\t\tARRAY_SIZE(wm8904_intercon));\n\t\tbreak;\n\n\tcase WM8912:\n\t\tsnd_soc_add_component_controls(component, wm8904_dac_snd_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_dac_snd_controls));\n\n\t\tsnd_soc_dapm_new_controls(dapm, wm8904_dac_dapm_widgets,\n\t\t\t\t\t  ARRAY_SIZE(wm8904_dac_dapm_widgets));\n\n\t\tsnd_soc_dapm_add_routes(dapm, dac_intercon,\n\t\t\t\t\tARRAY_SIZE(dac_intercon));\n\t\tsnd_soc_dapm_add_routes(dapm, wm8912_intercon,\n\t\t\t\t\tARRAY_SIZE(wm8912_intercon));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct {\n\tint ratio;\n\tunsigned int clk_sys_rate;\n} clk_sys_rates[] = {\n\t{   64,  0 },\n\t{  128,  1 },\n\t{  192,  2 },\n\t{  256,  3 },\n\t{  384,  4 },\n\t{  512,  5 },\n\t{  786,  6 },\n\t{ 1024,  7 },\n\t{ 1408,  8 },\n\t{ 1536,  9 },\n};\n\nstatic struct {\n\tint rate;\n\tint sample_rate;\n} sample_rates[] = {\n\t{ 8000,  0  },\n\t{ 11025, 1  },\n\t{ 12000, 1  },\n\t{ 16000, 2  },\n\t{ 22050, 3  },\n\t{ 24000, 3  },\n\t{ 32000, 4  },\n\t{ 44100, 5  },\n\t{ 48000, 5  },\n};\n\nstatic struct {\n\tint div;  \n\tint bclk_div;\n} bclk_divs[] = {\n\t{ 10,  0  },\n\t{ 15,  1  },\n\t{ 20,  2  },\n\t{ 30,  3  },\n\t{ 40,  4  },\n\t{ 50,  5  },\n\t{ 55,  6  },\n\t{ 60,  7  },\n\t{ 80,  8  },\n\t{ 100, 9  },\n\t{ 110, 10 },\n\t{ 120, 11 },\n\t{ 160, 12 },\n\t{ 200, 13 },\n\t{ 220, 14 },\n\t{ 240, 16 },\n\t{ 200, 17 },\n\t{ 320, 18 },\n\t{ 440, 19 },\n\t{ 480, 20 },\n};\n\n\nstatic int wm8904_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tint ret, i, best, best_val, cur_val;\n\tunsigned int aif1 = 0;\n\tunsigned int aif2 = 0;\n\tunsigned int aif3 = 0;\n\tunsigned int clock1 = 0;\n\tunsigned int dac_digital1 = 0;\n\n\t \n\twm8904->fs = params_rate(params);\n\tif (wm8904->tdm_slots) {\n\t\tdev_dbg(component->dev, \"Configuring for %d %d bit TDM slots\\n\",\n\t\t\twm8904->tdm_slots, wm8904->tdm_width);\n\t\twm8904->bclk = snd_soc_calc_bclk(wm8904->fs,\n\t\t\t\t\t\t wm8904->tdm_width, 2,\n\t\t\t\t\t\t wm8904->tdm_slots);\n\t} else {\n\t\twm8904->bclk = snd_soc_params_to_bclk(params);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\taif1 |= 0x40;\n\t\tbreak;\n\tcase 24:\n\t\taif1 |= 0x80;\n\t\tbreak;\n\tcase 32:\n\t\taif1 |= 0xc0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tdev_dbg(component->dev, \"Target BCLK is %dHz\\n\", wm8904->bclk);\n\n\tret = wm8904_configure_clocking(component);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tbest = 0;\n\tbest_val = abs((wm8904->sysclk_rate / clk_sys_rates[0].ratio)\n\t\t       - wm8904->fs);\n\tfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\n\t\tcur_val = abs((wm8904->sysclk_rate /\n\t\t\t       clk_sys_rates[i].ratio) - wm8904->fs);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected CLK_SYS_RATIO of %d\\n\",\n\t\tclk_sys_rates[best].ratio);\n\tclock1 |= (clk_sys_rates[best].clk_sys_rate\n\t\t   << WM8904_CLK_SYS_RATE_SHIFT);\n\n\t \n\tbest = 0;\n\tbest_val = abs(wm8904->fs - sample_rates[0].rate);\n\tfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\n\t\t \n\t\tcur_val = abs(wm8904->fs - sample_rates[i].rate);\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\tdev_dbg(component->dev, \"Selected SAMPLE_RATE of %dHz\\n\",\n\t\tsample_rates[best].rate);\n\tclock1 |= (sample_rates[best].sample_rate\n\t\t   << WM8904_SAMPLE_RATE_SHIFT);\n\n\t \n\tif (wm8904->fs <= 24000)\n\t\tdac_digital1 |= WM8904_DAC_SB_FILT;\n\n\t \n\tbest = 0;\n\tbest_val = INT_MAX;\n\tfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\n\t\tcur_val = ((wm8904->sysclk_rate * 10) / bclk_divs[i].div)\n\t\t\t- wm8904->bclk;\n\t\tif (cur_val < 0)  \n\t\t\tbreak;\n\t\tif (cur_val < best_val) {\n\t\t\tbest = i;\n\t\t\tbest_val = cur_val;\n\t\t}\n\t}\n\twm8904->bclk = (wm8904->sysclk_rate * 10) / bclk_divs[best].div;\n\tdev_dbg(component->dev, \"Selected BCLK_DIV of %d for %dHz BCLK\\n\",\n\t\tbclk_divs[best].div, wm8904->bclk);\n\taif2 |= bclk_divs[best].bclk_div;\n\n\t \n\tdev_dbg(component->dev, \"LRCLK_RATE is %d\\n\", wm8904->bclk / wm8904->fs);\n\taif3 |= wm8904->bclk / wm8904->fs;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8904_DAC_DIGITAL_1,\n\t\t\t    WM8904_DAC_SB_FILT, dac_digital1);\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_1,\n\t\t\t    WM8904_AIF_WL_MASK, aif1);\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_2,\n\t\t\t    WM8904_BCLK_DIV_MASK, aif2);\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_3,\n\t\t\t    WM8904_LRCLK_RATE_MASK, aif3);\n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_1,\n\t\t\t    WM8904_SAMPLE_RATE_MASK |\n\t\t\t    WM8904_CLK_SYS_RATE_MASK, clock1);\n\n\t \n\twm8904_set_retune_mobile(component);\n\twm8904_set_deemph(component);\n\n\treturn 0;\n}\n\nstatic int wm8904_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int aif1 = 0;\n\tunsigned int aif3 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFM:\n\t\taif3 |= WM8904_LRCLK_DIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFS:\n\t\taif1 |= WM8904_BCLK_DIR;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taif1 |= WM8904_BCLK_DIR;\n\t\taif3 |= WM8904_LRCLK_DIR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taif1 |= 0x3 | WM8904_AIF_LRCLK_INV;\n\t\tfallthrough;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taif1 |= 0x3;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taif1 |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taif1 |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t \n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8904_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\t\tcase SND_SOC_DAIFMT_NB_NF:\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_IF:\n\t\t\taif1 |= WM8904_AIF_BCLK_INV | WM8904_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_IB_NF:\n\t\t\taif1 |= WM8904_AIF_BCLK_INV;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_NB_IF:\n\t\t\taif1 |= WM8904_AIF_LRCLK_INV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_1,\n\t\t\t    WM8904_AIF_BCLK_INV | WM8904_AIF_LRCLK_INV |\n\t\t\t    WM8904_AIF_FMT_MASK | WM8904_BCLK_DIR, aif1);\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_3,\n\t\t\t    WM8904_LRCLK_DIR, aif3);\n\n\treturn 0;\n}\n\n\nstatic int wm8904_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tint aif1 = 0;\n\n\t \n\tif (slots == 0)\n\t\tgoto out;\n\n\t \n\taif1 |= WM8904_AIFADC_TDM | WM8904_AIFDAC_TDM;\n\n\tswitch (rx_mask) {\n\tcase 3:\n\t\tbreak;\n\tcase 0xc:\n\t\taif1 |= WM8904_AIFADC_TDM_CHAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tswitch (tx_mask) {\n\tcase 3:\n\t\tbreak;\n\tcase 0xc:\n\t\taif1 |= WM8904_AIFDAC_TDM_CHAN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\nout:\n\twm8904->tdm_width = slot_width;\n\twm8904->tdm_slots = slots / 2;\n\n\tsnd_soc_component_update_bits(component, WM8904_AUDIO_INTERFACE_1,\n\t\t\t    WM8904_AIFADC_TDM | WM8904_AIFADC_TDM_CHAN |\n\t\t\t    WM8904_AIFDAC_TDM | WM8904_AIFDAC_TDM_CHAN, aif1);\n\n\treturn 0;\n}\n\nstruct _fll_div {\n\tu16 fll_fratio;\n\tu16 fll_outdiv;\n\tu16 fll_clk_ref_div;\n\tu16 n;\n\tu16 k;\n};\n\n \n#define FIXED_FLL_SIZE ((1 << 16) * 10)\n\nstatic struct {\n\tunsigned int min;\n\tunsigned int max;\n\tu16 fll_fratio;\n\tint ratio;\n} fll_fratios[] = {\n\t{       0,    64000, 4, 16 },\n\t{   64000,   128000, 3,  8 },\n\t{  128000,   256000, 2,  4 },\n\t{  256000,  1000000, 1,  2 },\n\t{ 1000000, 13500000, 0,  1 },\n};\n\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\n\t\t       unsigned int Fout)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod, target;\n\tunsigned int div;\n\tint i;\n\n\t \n\tdiv = 1;\n\tfll_div->fll_clk_ref_div = 0;\n\twhile ((Fref / div) > 13500000) {\n\t\tdiv *= 2;\n\t\tfll_div->fll_clk_ref_div++;\n\n\t\tif (div > 8) {\n\t\t\tpr_err(\"Can't scale %dMHz input down to <=13.5MHz\\n\",\n\t\t\t       Fref);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tpr_debug(\"Fref=%u Fout=%u\\n\", Fref, Fout);\n\n\t \n\tFref /= div;\n\n\t \n\tdiv = 4;\n\twhile (Fout * div < 90000000) {\n\t\tdiv++;\n\t\tif (div > 64) {\n\t\t\tpr_err(\"Unable to find FLL_OUTDIV for Fout=%uHz\\n\",\n\t\t\t       Fout);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\ttarget = Fout * div;\n\tfll_div->fll_outdiv = div - 1;\n\n\tpr_debug(\"Fvco=%dHz\\n\", target);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\n\t\tif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\n\t\t\tfll_div->fll_fratio = fll_fratios[i].fll_fratio;\n\t\t\ttarget /= fll_fratios[i].ratio;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == ARRAY_SIZE(fll_fratios)) {\n\t\tpr_err(\"Unable to find FLL_FRATIO for Fref=%uHz\\n\", Fref);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tNdiv = target / Fref;\n\n\tfll_div->n = Ndiv;\n\tNmod = target % Fref;\n\tpr_debug(\"Nmod=%d\\n\", Nmod);\n\n\t \n\tKpart = FIXED_FLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, Fref);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tif ((K % 10) >= 5)\n\t\tK += 5;\n\n\t \n\tfll_div->k = K / 10;\n\n\tpr_debug(\"N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\\n\",\n\t\t fll_div->n, fll_div->k,\n\t\t fll_div->fll_fratio, fll_div->fll_outdiv,\n\t\t fll_div->fll_clk_ref_div);\n\n\treturn 0;\n}\n\nstatic int wm8904_set_fll(struct snd_soc_dai *dai, int fll_id, int source,\n\t\t\t  unsigned int Fref, unsigned int Fout)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct _fll_div fll_div;\n\tint ret, val;\n\tint clock2, fll1;\n\n\t \n\tif (source == wm8904->fll_src && Fref == wm8904->fll_fref &&\n\t    Fout == wm8904->fll_fout)\n\t\treturn 0;\n\n\tclock2 = snd_soc_component_read(component, WM8904_CLOCK_RATES_2);\n\n\tif (Fout == 0) {\n\t\tdev_dbg(component->dev, \"FLL disabled\\n\");\n\n\t\twm8904->fll_fref = 0;\n\t\twm8904->fll_fout = 0;\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_2,\n\t\t\t\t    WM8904_CLK_SYS_ENA, 0);\n\n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t\t    WM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\n\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (source) {\n\tcase WM8904_FLL_MCLK:\n\tcase WM8904_FLL_LRCLK:\n\tcase WM8904_FLL_BCLK:\n\t\tret = fll_factors(&fll_div, Fref, Fout);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase WM8904_FLL_FREE_RUNNING:\n\t\tdev_dbg(component->dev, \"Using free running FLL\\n\");\n\t\t \n\t\tFout = 12000000;\n\t\tFref = 12000000;\n\n\t\tmemset(&fll_div, 0, sizeof(fll_div));\n\t\tfll_div.fll_outdiv = 3;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown FLL ID %d\\n\", fll_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfll1 = snd_soc_component_read(component, WM8904_FLL_CONTROL_1);\n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_2,\n\t\t\t    WM8904_CLK_SYS_ENA, 0);\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t    WM8904_FLL_OSC_ENA | WM8904_FLL_ENA, 0);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8904_CONTROL_INTERFACE_TEST_1,\n\t\t\t    WM8904_USER_KEY, WM8904_USER_KEY);\n\n\tif (fll_id == WM8904_FLL_FREE_RUNNING) {\n\t\tval = WM8904_FLL_FRC_NCO;\n\t} else {\n\t\tval = 0;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8904_FLL_NCO_TEST_1, WM8904_FLL_FRC_NCO,\n\t\t\t    val);\n\tsnd_soc_component_update_bits(component, WM8904_CONTROL_INTERFACE_TEST_1,\n\t\t\t    WM8904_USER_KEY, 0);\n\n\tswitch (fll_id) {\n\tcase WM8904_FLL_MCLK:\n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_5,\n\t\t\t\t    WM8904_FLL_CLK_REF_SRC_MASK, 0);\n\t\tbreak;\n\n\tcase WM8904_FLL_LRCLK:\n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_5,\n\t\t\t\t    WM8904_FLL_CLK_REF_SRC_MASK, 1);\n\t\tbreak;\n\n\tcase WM8904_FLL_BCLK:\n\t\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_5,\n\t\t\t\t    WM8904_FLL_CLK_REF_SRC_MASK, 2);\n\t\tbreak;\n\t}\n\n\tif (fll_div.k)\n\t\tval = WM8904_FLL_FRACN_ENA;\n\telse\n\t\tval = 0;\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t    WM8904_FLL_FRACN_ENA, val);\n\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_2,\n\t\t\t    WM8904_FLL_OUTDIV_MASK | WM8904_FLL_FRATIO_MASK,\n\t\t\t    (fll_div.fll_outdiv << WM8904_FLL_OUTDIV_SHIFT) |\n\t\t\t    (fll_div.fll_fratio << WM8904_FLL_FRATIO_SHIFT));\n\n\tsnd_soc_component_write(component, WM8904_FLL_CONTROL_3, fll_div.k);\n\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_4, WM8904_FLL_N_MASK,\n\t\t\t    fll_div.n << WM8904_FLL_N_SHIFT);\n\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_5,\n\t\t\t    WM8904_FLL_CLK_REF_DIV_MASK,\n\t\t\t    fll_div.fll_clk_ref_div \n\t\t\t    << WM8904_FLL_CLK_REF_DIV_SHIFT);\n\n\tdev_dbg(component->dev, \"FLL configured for %dHz->%dHz\\n\", Fref, Fout);\n\n\twm8904->fll_fref = Fref;\n\twm8904->fll_fout = Fout;\n\twm8904->fll_src = source;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t    WM8904_FLL_OSC_ENA, fll1);\n\tsnd_soc_component_update_bits(component, WM8904_FLL_CONTROL_1,\n\t\t\t    WM8904_FLL_ENA, fll1);\n\nout:\n\t \n\tsnd_soc_component_update_bits(component, WM8904_CLOCK_RATES_2,\n\t\t\t    WM8904_CLK_SYS_ENA, clock2);\n\n\treturn 0;\n}\n\nstatic int wm8904_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8904_priv *priv = snd_soc_component_get_drvdata(component);\n\tunsigned long mclk_freq;\n\tint ret;\n\n\tswitch (clk_id) {\n\tcase WM8904_CLK_AUTO:\n\t\t \n\t\tif (!freq)\n\t\t\treturn 0;\n\n\t\tmclk_freq = clk_get_rate(priv->mclk);\n\t\t \n\t\tif (mclk_freq != freq) {\n\t\t\tpriv->sysclk_src = WM8904_CLK_FLL;\n\t\t\tret = wm8904_set_fll(dai, WM8904_FLL_MCLK,\n\t\t\t\t\t     WM8904_FLL_MCLK,\n\t\t\t\t\t     mclk_freq, freq);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t\tclk_id = WM8904_CLK_MCLK;\n\t\tfallthrough;\n\n\tcase WM8904_CLK_MCLK:\n\t\tpriv->sysclk_src = clk_id;\n\t\tpriv->mclk_rate = freq;\n\t\tbreak;\n\n\tcase WM8904_CLK_FLL:\n\t\tpriv->sysclk_src = clk_id;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dai->dev, \"Clock source is %d at %uHz\\n\", clk_id, freq);\n\n\twm8904_configure_clocking(component);\n\n\treturn 0;\n}\n\nstatic int wm8904_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tint val;\n\n\tif (mute)\n\t\tval = WM8904_DAC_MUTE;\n\telse\n\t\tval = 0;\n\n\tsnd_soc_component_update_bits(component, WM8904_DAC_DIGITAL_1, WM8904_DAC_MUTE, val);\n\n\treturn 0;\n}\n\nstatic int wm8904_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_VMID_CONTROL_0,\n\t\t\t\t    WM8904_VMID_RES_MASK,\n\t\t\t\t    0x1 << WM8904_VMID_RES_SHIFT);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_BIAS_CONTROL_0,\n\t\t\t\t    WM8904_ISEL_MASK, 2 << WM8904_ISEL_SHIFT);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8904->supplies),\n\t\t\t\t\t\t    wm8904->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = clk_prepare_enable(wm8904->mclk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable MCLK: %d\\n\", ret);\n\t\t\t\tregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies),\n\t\t\t\t\t\t       wm8904->supplies);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tregcache_cache_only(wm8904->regmap, false);\n\t\t\tregcache_sync(wm8904->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8904_BIAS_CONTROL_0,\n\t\t\t\t\t    WM8904_BIAS_ENA, WM8904_BIAS_ENA);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8904_VMID_CONTROL_0,\n\t\t\t\t\t    WM8904_VMID_ENA |\n\t\t\t\t\t    WM8904_VMID_RES_MASK,\n\t\t\t\t\t    WM8904_VMID_ENA |\n\t\t\t\t\t    0x3 << WM8904_VMID_RES_SHIFT);\n\n\t\t\t \n\t\t\tmsleep(1);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_VMID_CONTROL_0,\n\t\t\t\t    WM8904_VMID_RES_MASK,\n\t\t\t\t    0x2 << WM8904_VMID_RES_SHIFT);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_BIAS_CONTROL_0,\n\t\t\t\t    WM8904_ISEL_MASK, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_VMID_CONTROL_0,\n\t\t\t\t    WM8904_VMID_RES_MASK | WM8904_VMID_ENA, 0);\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8904_BIAS_CONTROL_0,\n\t\t\t\t    WM8904_BIAS_ENA, 0);\n\n\t\tsnd_soc_component_write(component, WM8904_SW_RESET_AND_ID, 0);\n\t\tregcache_cache_only(wm8904->regmap, true);\n\t\tregcache_mark_dirty(wm8904->regmap);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies),\n\t\t\t\t       wm8904->supplies);\n\t\tclk_disable_unprepare(wm8904->mclk);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#define WM8904_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8904_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8904_dai_ops = {\n\t.set_sysclk = wm8904_set_sysclk,\n\t.set_fmt = wm8904_set_fmt,\n\t.set_tdm_slot = wm8904_set_tdm_slot,\n\t.set_pll = wm8904_set_fll,\n\t.hw_params = wm8904_hw_params,\n\t.mute_stream = wm8904_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8904_dai = {\n\t.name = \"wm8904-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8904_RATES,\n\t\t.formats = WM8904_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8904_RATES,\n\t\t.formats = WM8904_FORMATS,\n\t},\n\t.ops = &wm8904_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic void wm8904_handle_retune_mobile_pdata(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tstruct snd_kcontrol_new control =\n\t\tSOC_ENUM_EXT(\"EQ Mode\",\n\t\t\t     wm8904->retune_mobile_enum,\n\t\t\t     wm8904_get_retune_mobile_enum,\n\t\t\t     wm8904_put_retune_mobile_enum);\n\tint ret, i, j;\n\tconst char **t;\n\n\t \n\twm8904->num_retune_mobile_texts = 0;\n\twm8904->retune_mobile_texts = NULL;\n\tfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\n\t\tfor (j = 0; j < wm8904->num_retune_mobile_texts; j++) {\n\t\t\tif (strcmp(pdata->retune_mobile_cfgs[i].name,\n\t\t\t\t   wm8904->retune_mobile_texts[j]) == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j != wm8904->num_retune_mobile_texts)\n\t\t\tcontinue;\n\n\t\t \n\t\tt = krealloc(wm8904->retune_mobile_texts,\n\t\t\t     sizeof(char *) * \n\t\t\t     (wm8904->num_retune_mobile_texts + 1),\n\t\t\t     GFP_KERNEL);\n\t\tif (t == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tt[wm8904->num_retune_mobile_texts] = \n\t\t\tpdata->retune_mobile_cfgs[i].name;\n\n\t\t \n\t\twm8904->num_retune_mobile_texts++;\n\t\twm8904->retune_mobile_texts = t;\n\t}\n\n\tdev_dbg(component->dev, \"Allocated %d unique ReTune Mobile names\\n\",\n\t\twm8904->num_retune_mobile_texts);\n\n\twm8904->retune_mobile_enum.items = wm8904->num_retune_mobile_texts;\n\twm8904->retune_mobile_enum.texts = wm8904->retune_mobile_texts;\n\n\tret = snd_soc_add_component_controls(component, &control, 1);\n\tif (ret != 0)\n\t\tdev_err(component->dev,\n\t\t\t\"Failed to add ReTune Mobile control: %d\\n\", ret);\n}\n\nstatic void wm8904_handle_pdata(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\tstruct wm8904_pdata *pdata = wm8904->pdata;\n\tint ret, i;\n\n\tif (!pdata) {\n\t\tsnd_soc_add_component_controls(component, wm8904_eq_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_eq_controls));\n\t\treturn;\n\t}\n\n\tdev_dbg(component->dev, \"%d DRC configurations\\n\", pdata->num_drc_cfgs);\n\n\tif (pdata->num_drc_cfgs) {\n\t\tstruct snd_kcontrol_new control =\n\t\t\tSOC_ENUM_EXT(\"DRC Mode\", wm8904->drc_enum,\n\t\t\t\t     wm8904_get_drc_enum, wm8904_put_drc_enum);\n\n\t\t \n\t\twm8904->drc_texts = kmalloc_array(pdata->num_drc_cfgs,\n\t\t\t\t\t\t  sizeof(char *),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!wm8904->drc_texts)\n\t\t\treturn;\n\n\t\tfor (i = 0; i < pdata->num_drc_cfgs; i++)\n\t\t\twm8904->drc_texts[i] = pdata->drc_cfgs[i].name;\n\n\t\twm8904->drc_enum.items = pdata->num_drc_cfgs;\n\t\twm8904->drc_enum.texts = wm8904->drc_texts;\n\n\t\tret = snd_soc_add_component_controls(component, &control, 1);\n\t\tif (ret != 0)\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Failed to add DRC mode control: %d\\n\", ret);\n\n\t\twm8904_set_drc(component);\n\t}\n\n\tdev_dbg(component->dev, \"%d ReTune Mobile configurations\\n\",\n\t\tpdata->num_retune_mobile_cfgs);\n\n\tif (pdata->num_retune_mobile_cfgs)\n\t\twm8904_handle_retune_mobile_pdata(component);\n\telse\n\t\tsnd_soc_add_component_controls(component, wm8904_eq_controls,\n\t\t\t\t     ARRAY_SIZE(wm8904_eq_controls));\n}\n\n\nstatic int wm8904_probe(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tswitch (wm8904->devtype) {\n\tcase WM8904:\n\t\tbreak;\n\tcase WM8912:\n\t\tmemset(&wm8904_dai.capture, 0, sizeof(wm8904_dai.capture));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown device type %d\\n\",\n\t\t\twm8904->devtype);\n\t\treturn -EINVAL;\n\t}\n\n\twm8904_handle_pdata(component);\n\n\twm8904_add_widgets(component);\n\n\treturn 0;\n}\n\nstatic void wm8904_remove(struct snd_soc_component *component)\n{\n\tstruct wm8904_priv *wm8904 = snd_soc_component_get_drvdata(component);\n\n\tkfree(wm8904->retune_mobile_texts);\n\tkfree(wm8904->drc_texts);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8904 = {\n\t.probe\t\t\t= wm8904_probe,\n\t.remove\t\t\t= wm8904_remove,\n\t.set_bias_level\t\t= wm8904_set_bias_level,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8904_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 16,\n\n\t.max_register = WM8904_MAX_REGISTER,\n\t.volatile_reg = wm8904_volatile_register,\n\t.readable_reg = wm8904_readable_register,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = wm8904_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8904_reg_defaults),\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id wm8904_of_match[] = {\n\t{\n\t\t.compatible = \"wlf,wm8904\",\n\t\t.data = (void *)WM8904,\n\t}, {\n\t\t.compatible = \"wlf,wm8912\",\n\t\t.data = (void *)WM8912,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, wm8904_of_match);\n#endif\n\nstatic const struct i2c_device_id wm8904_i2c_id[];\n\nstatic int wm8904_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8904_priv *wm8904;\n\tunsigned int val;\n\tint ret, i;\n\n\twm8904 = devm_kzalloc(&i2c->dev, sizeof(struct wm8904_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8904 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8904->mclk = devm_clk_get(&i2c->dev, \"mclk\");\n\tif (IS_ERR(wm8904->mclk)) {\n\t\tret = PTR_ERR(wm8904->mclk);\n\t\tdev_err(&i2c->dev, \"Failed to get MCLK\\n\");\n\t\treturn ret;\n\t}\n\n\twm8904->regmap = devm_regmap_init_i2c(i2c, &wm8904_regmap);\n\tif (IS_ERR(wm8904->regmap)) {\n\t\tret = PTR_ERR(wm8904->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (i2c->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(wm8904_of_match, i2c->dev.of_node);\n\t\tif (match == NULL)\n\t\t\treturn -EINVAL;\n\t\twm8904->devtype = (uintptr_t)match->data;\n\t} else {\n\t\tconst struct i2c_device_id *id =\n\t\t\ti2c_match_id(wm8904_i2c_id, i2c);\n\t\twm8904->devtype = id->driver_data;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8904);\n\twm8904->pdata = i2c->dev.platform_data;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8904->supplies); i++)\n\t\twm8904->supplies[i].supply = wm8904_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8904->supplies),\n\t\t\t\t      wm8904->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8904->supplies),\n\t\t\t\t    wm8904->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(wm8904->regmap, WM8904_SW_RESET_AND_ID, &val);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read ID register: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\tif (val != 0x8904) {\n\t\tdev_err(&i2c->dev, \"Device is not a WM8904, ID is %x\\n\", val);\n\t\tret = -EINVAL;\n\t\tgoto err_enable;\n\t}\n\n\tret = regmap_read(wm8904->regmap, WM8904_REVISION, &val);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to read device revision: %d\\n\",\n\t\t\tret);\n\t\tgoto err_enable;\n\t}\n\tdev_info(&i2c->dev, \"revision %c\\n\", val + 'A');\n\n\tret = regmap_write(wm8904->regmap, WM8904_SW_RESET_AND_ID, 0);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_enable;\n\t}\n\n\t \n\tregmap_update_bits(wm8904->regmap, WM8904_ADC_DIGITAL_VOLUME_LEFT,\n\t\t\t   WM8904_ADC_VU, WM8904_ADC_VU);\n\tregmap_update_bits(wm8904->regmap, WM8904_ADC_DIGITAL_VOLUME_RIGHT,\n\t\t\t   WM8904_ADC_VU, WM8904_ADC_VU);\n\tregmap_update_bits(wm8904->regmap, WM8904_DAC_DIGITAL_VOLUME_LEFT,\n\t\t\t   WM8904_DAC_VU, WM8904_DAC_VU);\n\tregmap_update_bits(wm8904->regmap, WM8904_DAC_DIGITAL_VOLUME_RIGHT,\n\t\t\t   WM8904_DAC_VU, WM8904_DAC_VU);\n\tregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT1_LEFT,\n\t\t\t   WM8904_HPOUT_VU | WM8904_HPOUTLZC,\n\t\t\t   WM8904_HPOUT_VU | WM8904_HPOUTLZC);\n\tregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT1_RIGHT,\n\t\t\t   WM8904_HPOUT_VU | WM8904_HPOUTRZC,\n\t\t\t   WM8904_HPOUT_VU | WM8904_HPOUTRZC);\n\tregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT2_LEFT,\n\t\t\t   WM8904_LINEOUT_VU | WM8904_LINEOUTLZC,\n\t\t\t   WM8904_LINEOUT_VU | WM8904_LINEOUTLZC);\n\tregmap_update_bits(wm8904->regmap, WM8904_ANALOGUE_OUT2_RIGHT,\n\t\t\t   WM8904_LINEOUT_VU | WM8904_LINEOUTRZC,\n\t\t\t   WM8904_LINEOUT_VU | WM8904_LINEOUTRZC);\n\tregmap_update_bits(wm8904->regmap, WM8904_CLOCK_RATES_0,\n\t\t\t   WM8904_SR_MODE, 0);\n\n\t \n\tif (wm8904->pdata) {\n\t\tfor (i = 0; i < WM8904_GPIO_REGS; i++) {\n\t\t\tif (!wm8904->pdata->gpio_cfg[i])\n\t\t\t\tcontinue;\n\n\t\t\tregmap_update_bits(wm8904->regmap,\n\t\t\t\t\t   WM8904_GPIO_CONTROL_1 + i,\n\t\t\t\t\t   0xffff,\n\t\t\t\t\t   wm8904->pdata->gpio_cfg[i]);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < WM8904_MIC_REGS; i++)\n\t\t\tregmap_update_bits(wm8904->regmap,\n\t\t\t\t\t   WM8904_MIC_BIAS_CONTROL_0 + i,\n\t\t\t\t\t   0xffff,\n\t\t\t\t\t   wm8904->pdata->mic_cfg[i]);\n\t}\n\n\t \n\tregmap_update_bits(wm8904->regmap, WM8904_CLASS_W_0,\n\t\t\t    WM8904_CP_DYN_PWR, WM8904_CP_DYN_PWR);\n\n\t \n\tregmap_update_bits(wm8904->regmap, WM8904_BIAS_CONTROL_0,\n\t\t\t    WM8904_POBCTRL, 0);\n\n\t \n\tregmap_read(wm8904->regmap, WM8904_ADC_TEST_0, &val);\n\n\t \n\tregcache_cache_only(wm8904->regmap, true);\n\tregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies), wm8904->supplies);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8904, &wm8904_dai, 1);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8904->supplies), wm8904->supplies);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8904_i2c_id[] = {\n\t{ \"wm8904\", WM8904 },\n\t{ \"wm8912\", WM8912 },\n\t{ \"wm8918\", WM8904 },    \n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8904_i2c_id);\n\nstatic struct i2c_driver wm8904_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8904\",\n\t\t.of_match_table = of_match_ptr(wm8904_of_match),\n\t},\n\t.probe = wm8904_i2c_probe,\n\t.id_table = wm8904_i2c_id,\n};\n\nmodule_i2c_driver(wm8904_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8904 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}