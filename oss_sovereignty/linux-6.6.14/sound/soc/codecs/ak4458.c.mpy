{
  "module_name": "ak4458.c",
  "hash_id": "98269a8fa2a822472d7cc858dfa1d63b73a9c285d0e7ea13ac452b6fef2bdd35",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ak4458.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <sound/initval.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"ak4458.h\"\n\n#define AK4458_NUM_SUPPLIES 2\nstatic const char *ak4458_supply_names[AK4458_NUM_SUPPLIES] = {\n\t\"DVDD\",\n\t\"AVDD\",\n};\n\nenum ak4458_type {\n\tAK4458 = 0,\n\tAK4497 = 1,\n};\n\nstruct ak4458_drvdata {\n\tstruct snd_soc_dai_driver *dai_drv;\n\tconst struct snd_soc_component_driver *comp_drv;\n\tenum ak4458_type type;\n};\n\n \nstruct ak4458_priv {\n\tstruct regulator_bulk_data supplies[AK4458_NUM_SUPPLIES];\n\tconst struct ak4458_drvdata *drvdata;\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *reset_gpiod;\n\tstruct reset_control *reset;\n\tstruct gpio_desc *mute_gpiod;\n\tint digfil;\t \n\tint fs;\t\t \n\tint fmt;\n\tint slots;\n\tint slot_width;\n\tu32 dsd_path;     \n};\n\nstatic const struct reg_default ak4458_reg_defaults[] = {\n\t{ 0x00, 0x0C },\t \n\t{ 0x01, 0x22 },\t \n\t{ 0x02, 0x00 },\t \n\t{ 0x03, 0xFF },\t \n\t{ 0x04, 0xFF },\t \n\t{ 0x05, 0x00 },\t \n\t{ 0x06, 0x00 },\t \n\t{ 0x07, 0x03 },\t \n\t{ 0x08, 0x00 },\t \n\t{ 0x09, 0x00 },\t \n\t{ 0x0A, 0x0D },\t \n\t{ 0x0B, 0x0C },\t \n\t{ 0x0C, 0x00 },\t \n\t{ 0x0D, 0x00 },\t \n\t{ 0x0E, 0x50 },\t \n\t{ 0x0F, 0xFF },\t \n\t{ 0x10, 0xFF },\t \n\t{ 0x11, 0xFF },\t \n\t{ 0x12, 0xFF },\t \n\t{ 0x13, 0xFF },\t \n\t{ 0x14, 0xFF },\t \n};\n\n \nstatic DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\n\n \nstatic const char * const ak4458_dem_select_texts[] = {\n\t\"44.1kHz\", \"OFF\", \"48kHz\", \"32kHz\"\n};\n\n \nstatic const char * const ak4458_digfil_select_texts[] = {\n\t\"Sharp Roll-Off Filter\",\n\t\"Slow Roll-Off Filter\",\n\t\"Short delay Sharp Roll-Off Filter\",\n\t\"Short delay Slow Roll-Off Filter\",\n\t\"Super Slow Roll-Off Filter\"\n};\n\n \nstatic const char * const ak4458_dzfb_select_texts[] = {\"H\", \"L\"};\n\n \nstatic const char * const ak4458_sc_select_texts[] = {\n\t\"Sound Mode 0\", \"Sound Mode 1\", \"Sound Mode 2\"\n};\n\n \nstatic const char * const ak4458_fir_select_texts[] = {\n\t\"Mode 0\", \"Mode 1\", \"Mode 2\", \"Mode 3\",\n\t\"Mode 4\", \"Mode 5\", \"Mode 6\", \"Mode 7\",\n};\n\n \nstatic const char * const ak4458_ats_select_texts[] = {\n\t\"4080/fs\", \"2040/fs\", \"510/fs\", \"255/fs\",\n};\n\n \nstatic const char * const ak4458_dif_select_texts[] = {\"32fs,48fs\", \"64fs\",};\n\nstatic const struct soc_enum ak4458_dac1_dem_enum =\n\tSOC_ENUM_SINGLE(AK4458_01_CONTROL2, 1,\n\t\t\tARRAY_SIZE(ak4458_dem_select_texts),\n\t\t\tak4458_dem_select_texts);\nstatic const struct soc_enum ak4458_dac2_dem_enum =\n\tSOC_ENUM_SINGLE(AK4458_0A_CONTROL6, 0,\n\t\t\tARRAY_SIZE(ak4458_dem_select_texts),\n\t\t\tak4458_dem_select_texts);\nstatic const struct soc_enum ak4458_dac3_dem_enum =\n\tSOC_ENUM_SINGLE(AK4458_0E_CONTROL10, 4,\n\t\t\tARRAY_SIZE(ak4458_dem_select_texts),\n\t\t\tak4458_dem_select_texts);\nstatic const struct soc_enum ak4458_dac4_dem_enum =\n\tSOC_ENUM_SINGLE(AK4458_0E_CONTROL10, 6,\n\t\t\tARRAY_SIZE(ak4458_dem_select_texts),\n\t\t\tak4458_dem_select_texts);\nstatic const struct soc_enum ak4458_digfil_enum =\n\tSOC_ENUM_SINGLE_EXT(ARRAY_SIZE(ak4458_digfil_select_texts),\n\t\t\t    ak4458_digfil_select_texts);\nstatic const struct soc_enum ak4458_dzfb_enum =\n\tSOC_ENUM_SINGLE(AK4458_02_CONTROL3, 2,\n\t\t\tARRAY_SIZE(ak4458_dzfb_select_texts),\n\t\t\tak4458_dzfb_select_texts);\nstatic const struct soc_enum ak4458_sm_enum =\n\tSOC_ENUM_SINGLE(AK4458_08_SOUND_CONTROL, 0,\n\t\t\tARRAY_SIZE(ak4458_sc_select_texts),\n\t\t\tak4458_sc_select_texts);\nstatic const struct soc_enum ak4458_fir_enum =\n\tSOC_ENUM_SINGLE(AK4458_0C_CONTROL8, 0,\n\t\t\tARRAY_SIZE(ak4458_fir_select_texts),\n\t\t\tak4458_fir_select_texts);\nstatic const struct soc_enum ak4458_ats_enum =\n\tSOC_ENUM_SINGLE(AK4458_0B_CONTROL7, 6,\n\t\t\tARRAY_SIZE(ak4458_ats_select_texts),\n\t\t\tak4458_ats_select_texts);\nstatic const struct soc_enum ak4458_dif_enum =\n\tSOC_ENUM_SINGLE(AK4458_00_CONTROL1, 3,\n\t\t\tARRAY_SIZE(ak4458_dif_select_texts),\n\t\t\tak4458_dif_select_texts);\n\nstatic int get_digfil(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.enumerated.item[0] = ak4458->digfil;\n\n\treturn 0;\n}\n\nstatic int set_digfil(struct snd_kcontrol *kcontrol,\n\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\tint num;\n\n\tnum = ucontrol->value.enumerated.item[0];\n\tif (num > 4)\n\t\treturn -EINVAL;\n\n\tak4458->digfil = num;\n\n\t \n\tsnd_soc_component_update_bits(component, AK4458_01_CONTROL2,\n\t\t\t    AK4458_SD_MASK,\n\t\t\t    ((ak4458->digfil & 0x02) << 4));\n\n\t \n\tsnd_soc_component_update_bits(component, AK4458_02_CONTROL3,\n\t\t\t    AK4458_SLOW_MASK,\n\t\t\t    (ak4458->digfil & 0x01));\n\n\t \n\tsnd_soc_component_update_bits(component, AK4458_05_CONTROL4,\n\t\t\t    AK4458_SSLOW_MASK,\n\t\t\t    ((ak4458->digfil & 0x04) >> 2));\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new ak4458_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC1 Playback Volume\", AK4458_03_LCHATT,\n\t\t\t AK4458_04_RCHATT, 0, 0xFF, 0, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Playback Volume\", AK4458_0F_L2CHATT,\n\t\t\t AK4458_10_R2CHATT, 0, 0xFF, 0, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC3 Playback Volume\", AK4458_11_L3CHATT,\n\t\t\t AK4458_12_R3CHATT, 0, 0xFF, 0, dac_tlv),\n\tSOC_DOUBLE_R_TLV(\"DAC4 Playback Volume\", AK4458_13_L4CHATT,\n\t\t\t AK4458_14_R4CHATT, 0, 0xFF, 0, dac_tlv),\n\tSOC_ENUM(\"AK4458 De-emphasis Response DAC1\", ak4458_dac1_dem_enum),\n\tSOC_ENUM(\"AK4458 De-emphasis Response DAC2\", ak4458_dac2_dem_enum),\n\tSOC_ENUM(\"AK4458 De-emphasis Response DAC3\", ak4458_dac3_dem_enum),\n\tSOC_ENUM(\"AK4458 De-emphasis Response DAC4\", ak4458_dac4_dem_enum),\n\tSOC_ENUM_EXT(\"AK4458 Digital Filter Setting\", ak4458_digfil_enum,\n\t\t     get_digfil, set_digfil),\n\tSOC_ENUM(\"AK4458 Inverting Enable of DZFB\", ak4458_dzfb_enum),\n\tSOC_ENUM(\"AK4458 Sound Mode\", ak4458_sm_enum),\n\tSOC_ENUM(\"AK4458 FIR Filter Mode Setting\", ak4458_fir_enum),\n\tSOC_ENUM(\"AK4458 Attenuation transition Time Setting\",\n\t\t ak4458_ats_enum),\n\tSOC_ENUM(\"AK4458 BICK fs Setting\", ak4458_dif_enum),\n};\n\n \nstatic const struct snd_soc_dapm_widget ak4458_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"AK4458 DAC1\", NULL, AK4458_0A_CONTROL6, 2, 0), \n\tSND_SOC_DAPM_AIF_IN(\"AK4458 SDTI\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"AK4458 AOUTA\"),\n\n\tSND_SOC_DAPM_DAC(\"AK4458 DAC2\", NULL, AK4458_0A_CONTROL6, 3, 0), \n\tSND_SOC_DAPM_OUTPUT(\"AK4458 AOUTB\"),\n\n\tSND_SOC_DAPM_DAC(\"AK4458 DAC3\", NULL, AK4458_0B_CONTROL7, 2, 0), \n\tSND_SOC_DAPM_OUTPUT(\"AK4458 AOUTC\"),\n\n\tSND_SOC_DAPM_DAC(\"AK4458 DAC4\", NULL, AK4458_0B_CONTROL7, 3, 0), \n\tSND_SOC_DAPM_OUTPUT(\"AK4458 AOUTD\"),\n};\n\nstatic const struct snd_soc_dapm_route ak4458_intercon[] = {\n\t{\"AK4458 DAC1\",\t\tNULL,\t\"AK4458 SDTI\"},\n\t{\"AK4458 AOUTA\",\tNULL,\t\"AK4458 DAC1\"},\n\n\t{\"AK4458 DAC2\",\t\tNULL,\t\"AK4458 SDTI\"},\n\t{\"AK4458 AOUTB\",\tNULL,\t\"AK4458 DAC2\"},\n\n\t{\"AK4458 DAC3\",\t\tNULL,\t\"AK4458 SDTI\"},\n\t{\"AK4458 AOUTC\",\tNULL,\t\"AK4458 DAC3\"},\n\n\t{\"AK4458 DAC4\",\t\tNULL,\t\"AK4458 SDTI\"},\n\t{\"AK4458 AOUTD\",\tNULL,\t\"AK4458 DAC4\"},\n};\n\n \nstatic const struct snd_kcontrol_new ak4497_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"DAC Playback Volume\", AK4458_03_LCHATT,\n\t\t\t AK4458_04_RCHATT, 0, 0xFF, 0, dac_tlv),\n\tSOC_ENUM(\"AK4497 De-emphasis Response DAC\", ak4458_dac1_dem_enum),\n\tSOC_ENUM_EXT(\"AK4497 Digital Filter Setting\", ak4458_digfil_enum,\n\t\t     get_digfil, set_digfil),\n\tSOC_ENUM(\"AK4497 Inverting Enable of DZFB\", ak4458_dzfb_enum),\n\tSOC_ENUM(\"AK4497 Sound Mode\", ak4458_sm_enum),\n\tSOC_ENUM(\"AK4497 Attenuation transition Time Setting\",\n\t\t ak4458_ats_enum),\n};\n\n \nstatic const struct snd_soc_dapm_widget ak4497_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"AK4497 DAC\", NULL, AK4458_0A_CONTROL6, 2, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AK4497 SDTI\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"AK4497 AOUT\"),\n};\n\n \nstatic const struct snd_soc_dapm_route ak4497_intercon[] = {\n\t{\"AK4497 DAC\",\t\tNULL,\t\"AK4497 SDTI\"},\n\t{\"AK4497 AOUT\",\t\tNULL,\t\"AK4497 DAC\"},\n\n};\n\nstatic int ak4458_get_tdm_mode(struct ak4458_priv *ak4458)\n{\n\tswitch (ak4458->slots * ak4458->slot_width) {\n\tcase 128:\n\t\treturn 1;\n\tcase 256:\n\t\treturn 2;\n\tcase 512:\n\t\treturn 3;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ak4458_rstn_control(struct snd_soc_component *component, int bit)\n{\n\tint ret;\n\n\tif (bit)\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t  AK4458_00_CONTROL1,\n\t\t\t\t\t  AK4458_RSTN_MASK,\n\t\t\t\t\t  0x1);\n\telse\n\t\tret = snd_soc_component_update_bits(component,\n\t\t\t\t\t  AK4458_00_CONTROL1,\n\t\t\t\t\t  AK4458_RSTN_MASK,\n\t\t\t\t\t  0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ak4458_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\tint pcm_width = max(params_physical_width(params), ak4458->slot_width);\n\tu8 format, dsdsel0, dsdsel1, dchn;\n\tint nfs1, dsd_bclk, ret, channels, channels_max;\n\n\tnfs1 = params_rate(params);\n\tak4458->fs = nfs1;\n\n\t \n\tchannels = params_channels(params);\n\tchannels_max = dai->driver->playback.channels_max;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_DSD_U8:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U16_BE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_LE:\n\tcase SNDRV_PCM_FORMAT_DSD_U32_BE:\n\t\tdsd_bclk = nfs1 * params_physical_width(params);\n\t\tswitch (dsd_bclk) {\n\t\tcase 2822400:\n\t\t\tdsdsel0 = 0;\n\t\t\tdsdsel1 = 0;\n\t\t\tbreak;\n\t\tcase 5644800:\n\t\t\tdsdsel0 = 1;\n\t\t\tdsdsel1 = 0;\n\t\t\tbreak;\n\t\tcase 11289600:\n\t\t\tdsdsel0 = 0;\n\t\t\tdsdsel1 = 1;\n\t\t\tbreak;\n\t\tcase 22579200:\n\t\t\tif (ak4458->drvdata->type == AK4497) {\n\t\t\t\tdsdsel0 = 1;\n\t\t\t\tdsdsel1 = 1;\n\t\t\t} else {\n\t\t\t\tdev_err(dai->dev, \"DSD512 not supported.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dai->dev, \"Unsupported dsd bclk.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, AK4458_06_DSD1,\n\t\t\t\t\t      AK4458_DSDSEL_MASK, dsdsel0);\n\t\tsnd_soc_component_update_bits(component, AK4458_09_DSD2,\n\t\t\t\t\t      AK4458_DSDSEL_MASK, dsdsel1);\n\t\tbreak;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, AK4458_00_CONTROL1, 0x80, 0x80);\n\n\tswitch (pcm_width) {\n\tcase 16:\n\t\tif (ak4458->fmt == SND_SOC_DAIFMT_I2S)\n\t\t\tformat = AK4458_DIF_24BIT_I2S;\n\t\telse\n\t\t\tformat = AK4458_DIF_16BIT_LSB;\n\t\tbreak;\n\tcase 32:\n\t\tswitch (ak4458->fmt) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tformat = AK4458_DIF_32BIT_I2S;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tformat = AK4458_DIF_32BIT_MSB;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tformat = AK4458_DIF_32BIT_LSB;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_DSP_B:\n\t\t\tformat = AK4458_DIF_32BIT_MSB;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_PDM:\n\t\t\tformat = AK4458_DIF_32BIT_MSB;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, AK4458_00_CONTROL1,\n\t\t\t    AK4458_DIF_MASK, format);\n\n\t \n\tdchn = ak4458_get_tdm_mode(ak4458) &&\n\t\t(ak4458->fmt == SND_SOC_DAIFMT_DSP_B) &&\n\t\t(channels > channels_max) ? AK4458_DCHAIN_MASK : 0;\n\n\tsnd_soc_component_update_bits(component, AK4458_0B_CONTROL7,\n\t\t\t\t      AK4458_DCHAIN_MASK, dchn);\n\n\tif (ak4458->drvdata->type == AK4497) {\n\t\tret = snd_soc_component_update_bits(component, AK4458_09_DSD2,\n\t\t\t\t\t\t    0x4, (ak4458->dsd_path << 2));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = ak4458_rstn_control(component, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ak4458_rstn_control(component, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ak4458_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:  \n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:  \n\tcase SND_SOC_DAIFMT_CBC_CFP:\n\tcase SND_SOC_DAIFMT_CBP_CFC:\n\tdefault:\n\t\tdev_err(component->dev, \"Clock provider mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_DSP_B:\n\tcase SND_SOC_DAIFMT_PDM:\n\t\tak4458->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Audio format 0x%02X unsupported\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, AK4458_02_CONTROL3,\n\t\t\t\t      AK4458_DP_MASK,\n\t\t\t\t      ak4458->fmt == SND_SOC_DAIFMT_PDM ?\n\t\t\t\t      AK4458_DP_MASK : 0);\n\n\tret = ak4458_rstn_control(component, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ak4458_rstn_control(component, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const int att_speed[] = { 4080, 2040, 510, 255 };\n\nstatic int ak4458_set_dai_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\tint nfs, ndt, reg;\n\tint ats;\n\n\tnfs = ak4458->fs;\n\n\treg = snd_soc_component_read(component, AK4458_0B_CONTROL7);\n\tats = (reg & AK4458_ATS_MASK) >> AK4458_ATS_SHIFT;\n\n\tndt = att_speed[ats] / (nfs / 1000);\n\n\tif (mute) {\n\t\tsnd_soc_component_update_bits(component, AK4458_01_CONTROL2,  0x01, 1);\n\t\tmdelay(ndt);\n\t\tif (ak4458->mute_gpiod)\n\t\t\tgpiod_set_value_cansleep(ak4458->mute_gpiod, 1);\n\t} else {\n\t\tif (ak4458->mute_gpiod)\n\t\t\tgpiod_set_value_cansleep(ak4458->mute_gpiod, 0);\n\t\tsnd_soc_component_update_bits(component, AK4458_01_CONTROL2, 0x01, 0);\n\t\tmdelay(ndt);\n\t}\n\n\treturn 0;\n}\n\nstatic int ak4458_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t       unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ak4458_priv *ak4458 = snd_soc_component_get_drvdata(component);\n\tint mode;\n\n\tak4458->slots = slots;\n\tak4458->slot_width = slot_width;\n\n\tmode = ak4458_get_tdm_mode(ak4458) << AK4458_MODE_SHIFT;\n\n\tsnd_soc_component_update_bits(component, AK4458_0A_CONTROL6,\n\t\t\t    AK4458_MODE_MASK,\n\t\t\t    mode);\n\n\treturn 0;\n}\n\n#define AK4458_FORMATS\t(SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_DSD_U8 |\\\n\t\t\t SNDRV_PCM_FMTBIT_DSD_U16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_DSD_U32_LE)\n\nstatic const unsigned int ak4458_rates[] = {\n\t8000, 11025,  16000, 22050,\n\t32000, 44100, 48000, 88200,\n\t96000, 176400, 192000, 352800,\n\t384000, 705600, 768000, 1411200,\n\t2822400,\n};\n\nstatic const struct snd_pcm_hw_constraint_list ak4458_rate_constraints = {\n\t.count = ARRAY_SIZE(ak4458_rates),\n\t.list = ak4458_rates,\n};\n\nstatic int ak4458_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tint ret;\n\n\tret = snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t &ak4458_rate_constraints);\n\n\treturn ret;\n}\n\nstatic const struct snd_soc_dai_ops ak4458_dai_ops = {\n\t.startup        = ak4458_startup,\n\t.hw_params\t= ak4458_hw_params,\n\t.set_fmt\t= ak4458_set_dai_fmt,\n\t.mute_stream\t= ak4458_set_dai_mute,\n\t.set_tdm_slot\t= ak4458_set_tdm_slot,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ak4458_dai = {\n\t.name = \"ak4458-aif\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 8,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = AK4458_FORMATS,\n\t},\n\t.ops = &ak4458_dai_ops,\n};\n\nstatic struct snd_soc_dai_driver ak4497_dai = {\n\t.name = \"ak4497-aif\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t.formats = AK4458_FORMATS,\n\t},\n\t.ops = &ak4458_dai_ops,\n};\n\nstatic void ak4458_reset(struct ak4458_priv *ak4458, bool active)\n{\n\tif (ak4458->reset_gpiod) {\n\t\tgpiod_set_value_cansleep(ak4458->reset_gpiod, active);\n\t\tusleep_range(1000, 2000);\n\t} else if (!IS_ERR_OR_NULL(ak4458->reset)) {\n\t\tif (active)\n\t\t\treset_control_assert(ak4458->reset);\n\t\telse\n\t\t\treset_control_deassert(ak4458->reset);\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int __maybe_unused ak4458_runtime_suspend(struct device *dev)\n{\n\tstruct ak4458_priv *ak4458 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(ak4458->regmap, true);\n\n\tak4458_reset(ak4458, true);\n\n\tif (ak4458->mute_gpiod)\n\t\tgpiod_set_value_cansleep(ak4458->mute_gpiod, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(ak4458->supplies),\n\t\t\t       ak4458->supplies);\n\treturn 0;\n}\n\nstatic int __maybe_unused ak4458_runtime_resume(struct device *dev)\n{\n\tstruct ak4458_priv *ak4458 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(ak4458->supplies),\n\t\t\t\t    ak4458->supplies);\n\tif (ret != 0) {\n\t\tdev_err(ak4458->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ak4458->mute_gpiod)\n\t\tgpiod_set_value_cansleep(ak4458->mute_gpiod, 1);\n\n\tak4458_reset(ak4458, false);\n\n\tregcache_cache_only(ak4458->regmap, false);\n\tregcache_mark_dirty(ak4458->regmap);\n\n\treturn regcache_sync(ak4458->regmap);\n}\n#endif  \n\nstatic const struct snd_soc_component_driver soc_codec_dev_ak4458 = {\n\t.controls\t\t= ak4458_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4458_snd_controls),\n\t.dapm_widgets\t\t= ak4458_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4458_dapm_widgets),\n\t.dapm_routes\t\t= ak4458_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4458_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_ak4497 = {\n\t.controls\t\t= ak4497_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ak4497_snd_controls),\n\t.dapm_widgets\t\t= ak4497_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ak4497_dapm_widgets),\n\t.dapm_routes\t\t= ak4497_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ak4497_intercon),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ak4458_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = AK4458_14_R4CHATT,\n\t.reg_defaults = ak4458_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(ak4458_reg_defaults),\n\t.cache_type = REGCACHE_RBTREE,\n};\n\nstatic const struct ak4458_drvdata ak4458_drvdata = {\n\t.dai_drv = &ak4458_dai,\n\t.comp_drv = &soc_codec_dev_ak4458,\n\t.type = AK4458,\n};\n\nstatic const struct ak4458_drvdata ak4497_drvdata = {\n\t.dai_drv = &ak4497_dai,\n\t.comp_drv = &soc_codec_dev_ak4497,\n\t.type = AK4497,\n};\n\nstatic const struct dev_pm_ops ak4458_pm = {\n\tSET_RUNTIME_PM_OPS(ak4458_runtime_suspend, ak4458_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic int ak4458_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ak4458_priv *ak4458;\n\tint ret, i;\n\n\tak4458 = devm_kzalloc(&i2c->dev, sizeof(*ak4458), GFP_KERNEL);\n\tif (!ak4458)\n\t\treturn -ENOMEM;\n\n\tak4458->regmap = devm_regmap_init_i2c(i2c, &ak4458_regmap);\n\tif (IS_ERR(ak4458->regmap))\n\t\treturn PTR_ERR(ak4458->regmap);\n\n\ti2c_set_clientdata(i2c, ak4458);\n\tak4458->dev = &i2c->dev;\n\n\tak4458->drvdata = of_device_get_match_data(&i2c->dev);\n\n\tak4458->reset = devm_reset_control_get_optional_shared(ak4458->dev, NULL);\n\tif (IS_ERR(ak4458->reset))\n\t\treturn PTR_ERR(ak4458->reset);\n\n\tak4458->reset_gpiod = devm_gpiod_get_optional(ak4458->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(ak4458->reset_gpiod))\n\t\treturn PTR_ERR(ak4458->reset_gpiod);\n\n\tak4458->mute_gpiod = devm_gpiod_get_optional(ak4458->dev, \"mute\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(ak4458->mute_gpiod))\n\t\treturn PTR_ERR(ak4458->mute_gpiod);\n\n\t \n\tof_property_read_u32(i2c->dev.of_node, \"dsd-path\", &ak4458->dsd_path);\n\n\tfor (i = 0; i < ARRAY_SIZE(ak4458->supplies); i++)\n\t\tak4458->supplies[i].supply = ak4458_supply_names[i];\n\n\tret = devm_regulator_bulk_get(ak4458->dev, ARRAY_SIZE(ak4458->supplies),\n\t\t\t\t      ak4458->supplies);\n\tif (ret != 0) {\n\t\tdev_err(ak4458->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = devm_snd_soc_register_component(ak4458->dev,\n\t\t\t\t\t      ak4458->drvdata->comp_drv,\n\t\t\t\t\t      ak4458->drvdata->dai_drv, 1);\n\tif (ret < 0) {\n\t\tdev_err(ak4458->dev, \"Failed to register CODEC: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(&i2c->dev);\n\tregcache_cache_only(ak4458->regmap, true);\n\tak4458_reset(ak4458, false);\n\n\treturn 0;\n}\n\nstatic void ak4458_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct ak4458_priv *ak4458 = i2c_get_clientdata(i2c);\n\n\tak4458_reset(ak4458, true);\n\tpm_runtime_disable(&i2c->dev);\n}\n\nstatic const struct of_device_id ak4458_of_match[] = {\n\t{ .compatible = \"asahi-kasei,ak4458\", .data = &ak4458_drvdata},\n\t{ .compatible = \"asahi-kasei,ak4497\", .data = &ak4497_drvdata},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ak4458_of_match);\n\nstatic struct i2c_driver ak4458_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ak4458\",\n\t\t.pm = &ak4458_pm,\n\t\t.of_match_table = ak4458_of_match,\n\t\t},\n\t.probe = ak4458_i2c_probe,\n\t.remove = ak4458_i2c_remove,\n};\n\nmodule_i2c_driver(ak4458_i2c_driver);\n\nMODULE_AUTHOR(\"Junichi Wakasugi <wakasugi.jb@om.asahi-kasei.co.jp>\");\nMODULE_AUTHOR(\"Mihai Serban <mihai.serban@nxp.com>\");\nMODULE_DESCRIPTION(\"ASoC AK4458 DAC driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}