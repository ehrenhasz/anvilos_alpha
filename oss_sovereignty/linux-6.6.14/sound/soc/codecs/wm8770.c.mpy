{
  "module_name": "wm8770.c",
  "hash_id": "819b2820a14a89715be90d4dc00c0d7c7e06e2d14e3184af309e5b5caff5067c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8770.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/of_device.h>\n#include <linux/pm.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8770.h\"\n\n#define WM8770_NUM_SUPPLIES 3\nstatic const char *wm8770_supply_names[WM8770_NUM_SUPPLIES] = {\n\t\"AVDD1\",\n\t\"AVDD2\",\n\t\"DVDD\"\n};\n\nstatic const struct reg_default wm8770_reg_defaults[] = {\n\t{  0, 0x7f },\n\t{  1, 0x7f },\n\t{  2, 0x7f },\n\t{  3, 0x7f },\n\t{  4, 0x7f },\n\t{  5, 0x7f },\n\t{  6, 0x7f },\n\t{  7, 0x7f },\n\t{  8, 0x7f },\n\t{  9, 0xff },\n\t{ 10, 0xff },\n\t{ 11, 0xff },\n\t{ 12, 0xff },\n\t{ 13, 0xff },\n\t{ 14, 0xff },\n\t{ 15, 0xff },\n\t{ 16, 0xff },\n\t{ 17, 0xff },\n\t{ 18, 0    },\n\t{ 19, 0x90 },\n\t{ 20, 0    },\n\t{ 21, 0    },\n\t{ 22, 0x22 },\n\t{ 23, 0x22 },\n\t{ 24, 0x3e },\n\t{ 25, 0xc  },\n\t{ 26, 0xc  },\n\t{ 27, 0x100 },\n\t{ 28, 0x189 },\n\t{ 29, 0x189 },\n\t{ 30, 0x8770 },\n};\n\nstatic bool wm8770_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8770_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct wm8770_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8770_NUM_SUPPLIES];\n\tstruct notifier_block disable_nb[WM8770_NUM_SUPPLIES];\n\tstruct snd_soc_component *component;\n\tint sysclk;\n};\n\nstatic int vout12supply_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event);\nstatic int vout34supply_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event);\n\n \n#define WM8770_REGULATOR_EVENT(n) \\\nstatic int wm8770_regulator_event_##n(struct notifier_block *nb, \\\n\t\t\t\t      unsigned long event, void *data)    \\\n{ \\\n\tstruct wm8770_priv *wm8770 = container_of(nb, struct wm8770_priv, \\\n\t\t\t\t     disable_nb[n]); \\\n\tif (event & REGULATOR_EVENT_DISABLE) { \\\n\t\tregcache_mark_dirty(wm8770->regmap);\t\\\n\t} \\\n\treturn 0; \\\n}\n\nWM8770_REGULATOR_EVENT(0)\nWM8770_REGULATOR_EVENT(1)\nWM8770_REGULATOR_EVENT(2)\n\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -1200, 100, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_dig_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(dac_alg_tlv, -12700, 100, 1);\n\nstatic const char *dac_phase_text[][2] = {\n\t{ \"DAC1 Normal\", \"DAC1 Inverted\" },\n\t{ \"DAC2 Normal\", \"DAC2 Inverted\" },\n\t{ \"DAC3 Normal\", \"DAC3 Inverted\" },\n\t{ \"DAC4 Normal\", \"DAC4 Inverted\" },\n};\n\nstatic const struct soc_enum dac_phase[] = {\n\tSOC_ENUM_DOUBLE(WM8770_DACPHASE, 0, 1, 2, dac_phase_text[0]),\n\tSOC_ENUM_DOUBLE(WM8770_DACPHASE, 2, 3, 2, dac_phase_text[1]),\n\tSOC_ENUM_DOUBLE(WM8770_DACPHASE, 4, 5, 2, dac_phase_text[2]),\n\tSOC_ENUM_DOUBLE(WM8770_DACPHASE, 6, 7, 2, dac_phase_text[3]),\n};\n\nstatic const struct snd_kcontrol_new wm8770_snd_controls[] = {\n\t \n\tSOC_SINGLE_TLV(\"DAC Playback Volume\", WM8770_MSDIGVOL, 0, 255, 0,\n\t\tdac_dig_tlv),\n\tSOC_SINGLE(\"DAC Playback Switch\", WM8770_DACMUTE, 4, 1, 1),\n\tSOC_SINGLE(\"DAC Playback ZC Switch\", WM8770_DACCTRL1, 0, 1, 0),\n\n\t \n\tSOC_SINGLE_TLV(\"VOUT Playback Volume\", WM8770_MSALGVOL, 0, 127, 0,\n\t\tdac_alg_tlv),\n\tSOC_SINGLE(\"VOUT Playback ZC Switch\", WM8770_MSALGVOL, 7, 1, 0),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"VOUT1 Playback Volume\", WM8770_VOUT1LVOL,\n\t\tWM8770_VOUT1RVOL, 0, 127, 0, dac_alg_tlv),\n\tSOC_DOUBLE_R(\"VOUT1 Playback ZC Switch\", WM8770_VOUT1LVOL,\n\t\tWM8770_VOUT1RVOL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"VOUT2 Playback Volume\", WM8770_VOUT2LVOL,\n\t\tWM8770_VOUT2RVOL, 0, 127, 0, dac_alg_tlv),\n\tSOC_DOUBLE_R(\"VOUT2 Playback ZC Switch\", WM8770_VOUT2LVOL,\n\t\tWM8770_VOUT2RVOL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"VOUT3 Playback Volume\", WM8770_VOUT3LVOL,\n\t\tWM8770_VOUT3RVOL, 0, 127, 0, dac_alg_tlv),\n\tSOC_DOUBLE_R(\"VOUT3 Playback ZC Switch\", WM8770_VOUT3LVOL,\n\t\tWM8770_VOUT3RVOL, 7, 1, 0),\n\tSOC_DOUBLE_R_TLV(\"VOUT4 Playback Volume\", WM8770_VOUT4LVOL,\n\t\tWM8770_VOUT4RVOL, 0, 127, 0, dac_alg_tlv),\n\tSOC_DOUBLE_R(\"VOUT4 Playback ZC Switch\", WM8770_VOUT4LVOL,\n\t\tWM8770_VOUT4RVOL, 7, 1, 0),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"DAC1 Playback Volume\", WM8770_DAC1LVOL,\n\t\tWM8770_DAC1RVOL, 0, 255, 0, dac_dig_tlv),\n\tSOC_SINGLE(\"DAC1 Deemphasis Switch\", WM8770_DACCTRL2, 0, 1, 0),\n\tSOC_ENUM(\"DAC1 Phase\", dac_phase[0]),\n\tSOC_DOUBLE_R_TLV(\"DAC2 Playback Volume\", WM8770_DAC2LVOL,\n\t\tWM8770_DAC2RVOL, 0, 255, 0, dac_dig_tlv),\n\tSOC_SINGLE(\"DAC2 Deemphasis Switch\", WM8770_DACCTRL2, 1, 1, 0),\n\tSOC_ENUM(\"DAC2 Phase\", dac_phase[1]),\n\tSOC_DOUBLE_R_TLV(\"DAC3 Playback Volume\", WM8770_DAC3LVOL,\n\t\tWM8770_DAC3RVOL, 0, 255, 0, dac_dig_tlv),\n\tSOC_SINGLE(\"DAC3 Deemphasis Switch\", WM8770_DACCTRL2, 2, 1, 0),\n\tSOC_ENUM(\"DAC3 Phase\", dac_phase[2]),\n\tSOC_DOUBLE_R_TLV(\"DAC4 Playback Volume\", WM8770_DAC4LVOL,\n\t\tWM8770_DAC4RVOL, 0, 255, 0, dac_dig_tlv),\n\tSOC_SINGLE(\"DAC4 Deemphasis Switch\", WM8770_DACCTRL2, 3, 1, 0),\n\tSOC_ENUM(\"DAC4 Phase\", dac_phase[3]),\n\n\t \n\tSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8770_ADCLCTRL, WM8770_ADCRCTRL,\n\t\t0, 31, 0, adc_tlv),\n\tSOC_DOUBLE_R(\"Capture Switch\", WM8770_ADCLCTRL, WM8770_ADCRCTRL,\n\t\t5, 1, 1),\n\n\t \n\tSOC_SINGLE(\"ADC 128x Oversampling Switch\", WM8770_MSTRCTRL, 3, 1, 0),\n\tSOC_SINGLE(\"ADC Highpass Filter Switch\", WM8770_IFACECTRL, 8, 1, 1)\n};\n\nstatic const char *ain_text[] = {\n\t\"AIN1\", \"AIN2\", \"AIN3\", \"AIN4\",\n\t\"AIN5\", \"AIN6\", \"AIN7\", \"AIN8\"\n};\n\nstatic SOC_ENUM_DOUBLE_DECL(ain_enum,\n\t\t\t    WM8770_ADCMUX, 0, 4, ain_text);\n\nstatic const struct snd_kcontrol_new ain_mux =\n\tSOC_DAPM_ENUM(\"Capture Mux\", ain_enum);\n\nstatic const struct snd_kcontrol_new vout1_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC1 Switch\", WM8770_OUTMUX1, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUX1 Switch\", WM8770_OUTMUX1, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Bypass Switch\", WM8770_OUTMUX1, 2, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new vout2_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC2 Switch\", WM8770_OUTMUX1, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUX2 Switch\", WM8770_OUTMUX1, 4, 1, 0),\n\tSOC_DAPM_SINGLE(\"Bypass Switch\", WM8770_OUTMUX1, 5, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new vout3_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC3 Switch\", WM8770_OUTMUX2, 0, 1, 0),\n\tSOC_DAPM_SINGLE(\"AUX3 Switch\", WM8770_OUTMUX2, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Bypass Switch\", WM8770_OUTMUX2, 2, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new vout4_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC4 Switch\", WM8770_OUTMUX2, 3, 1, 0),\n\tSOC_DAPM_SINGLE(\"Bypass Switch\", WM8770_OUTMUX2, 4, 1, 0)\n};\n\nstatic const struct snd_soc_dapm_widget wm8770_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"AUX1\"),\n\tSND_SOC_DAPM_INPUT(\"AUX2\"),\n\tSND_SOC_DAPM_INPUT(\"AUX3\"),\n\n\tSND_SOC_DAPM_INPUT(\"AIN1\"),\n\tSND_SOC_DAPM_INPUT(\"AIN2\"),\n\tSND_SOC_DAPM_INPUT(\"AIN3\"),\n\tSND_SOC_DAPM_INPUT(\"AIN4\"),\n\tSND_SOC_DAPM_INPUT(\"AIN5\"),\n\tSND_SOC_DAPM_INPUT(\"AIN6\"),\n\tSND_SOC_DAPM_INPUT(\"AIN7\"),\n\tSND_SOC_DAPM_INPUT(\"AIN8\"),\n\n\tSND_SOC_DAPM_MUX(\"Capture Mux\", WM8770_ADCMUX, 8, 1, &ain_mux),\n\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", WM8770_PWDNCTRL, 1, 1),\n\n\tSND_SOC_DAPM_DAC(\"DAC1\", \"Playback\", WM8770_PWDNCTRL, 2, 1),\n\tSND_SOC_DAPM_DAC(\"DAC2\", \"Playback\", WM8770_PWDNCTRL, 3, 1),\n\tSND_SOC_DAPM_DAC(\"DAC3\", \"Playback\", WM8770_PWDNCTRL, 4, 1),\n\tSND_SOC_DAPM_DAC(\"DAC4\", \"Playback\", WM8770_PWDNCTRL, 5, 1),\n\n\tSND_SOC_DAPM_SUPPLY(\"VOUT12 Supply\", SND_SOC_NOPM, 0, 0,\n\t\tvout12supply_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"VOUT34 Supply\", SND_SOC_NOPM, 0, 0,\n\t\tvout34supply_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MIXER(\"VOUT1 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tvout1_mix_controls, ARRAY_SIZE(vout1_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"VOUT2 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tvout2_mix_controls, ARRAY_SIZE(vout2_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"VOUT3 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tvout3_mix_controls, ARRAY_SIZE(vout3_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"VOUT4 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\tvout4_mix_controls, ARRAY_SIZE(vout4_mix_controls)),\n\n\tSND_SOC_DAPM_OUTPUT(\"VOUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUT3\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUT4\")\n};\n\nstatic const struct snd_soc_dapm_route wm8770_intercon[] = {\n\t{ \"Capture Mux\", \"AIN1\", \"AIN1\" },\n\t{ \"Capture Mux\", \"AIN2\", \"AIN2\" },\n\t{ \"Capture Mux\", \"AIN3\", \"AIN3\" },\n\t{ \"Capture Mux\", \"AIN4\", \"AIN4\" },\n\t{ \"Capture Mux\", \"AIN5\", \"AIN5\" },\n\t{ \"Capture Mux\", \"AIN6\", \"AIN6\" },\n\t{ \"Capture Mux\", \"AIN7\", \"AIN7\" },\n\t{ \"Capture Mux\", \"AIN8\", \"AIN8\" },\n\n\t{ \"ADC\", NULL, \"Capture Mux\" },\n\n\t{ \"VOUT1 Mixer\", NULL, \"VOUT12 Supply\" },\n\t{ \"VOUT1 Mixer\", \"DAC1 Switch\", \"DAC1\" },\n\t{ \"VOUT1 Mixer\", \"AUX1 Switch\", \"AUX1\" },\n\t{ \"VOUT1 Mixer\", \"Bypass Switch\", \"Capture Mux\" },\n\n\t{ \"VOUT2 Mixer\", NULL, \"VOUT12 Supply\" },\n\t{ \"VOUT2 Mixer\", \"DAC2 Switch\", \"DAC2\" },\n\t{ \"VOUT2 Mixer\", \"AUX2 Switch\", \"AUX2\" },\n\t{ \"VOUT2 Mixer\", \"Bypass Switch\", \"Capture Mux\" },\n\n\t{ \"VOUT3 Mixer\", NULL, \"VOUT34 Supply\" },\n\t{ \"VOUT3 Mixer\", \"DAC3 Switch\", \"DAC3\" },\n\t{ \"VOUT3 Mixer\", \"AUX3 Switch\", \"AUX3\" },\n\t{ \"VOUT3 Mixer\", \"Bypass Switch\", \"Capture Mux\" },\n\n\t{ \"VOUT4 Mixer\", NULL, \"VOUT34 Supply\" },\n\t{ \"VOUT4 Mixer\", \"DAC4 Switch\", \"DAC4\" },\n\t{ \"VOUT4 Mixer\", \"Bypass Switch\", \"Capture Mux\" },\n\n\t{ \"VOUT1\", NULL, \"VOUT1 Mixer\" },\n\t{ \"VOUT2\", NULL, \"VOUT2 Mixer\" },\n\t{ \"VOUT3\", NULL, \"VOUT3 Mixer\" },\n\t{ \"VOUT4\", NULL, \"VOUT4 Mixer\" }\n};\n\nstatic int vout12supply_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, WM8770_OUTMUX1, 0x180, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8770_OUTMUX1, 0x180, 0x180);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int vout34supply_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, WM8770_OUTMUX2, 0x180, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, WM8770_OUTMUX2, 0x180, 0x180);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8770_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8770_RESET, 0);\n}\n\nstatic int wm8770_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component;\n\tint iface, master;\n\n\tcomponent = dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tmaster = 0x100;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tmaster = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tiface = 0;\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface |= 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0xc;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x8;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8770_IFACECTRL, 0xf, iface);\n\tsnd_soc_component_update_bits(component, WM8770_MSTRCTRL, 0x100, master);\n\n\treturn 0;\n}\n\nstatic const int mclk_ratios[] = {\n\t128,\n\t192,\n\t256,\n\t384,\n\t512,\n\t768\n};\n\nstatic int wm8770_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8770_priv *wm8770;\n\tint i;\n\tint iface;\n\tint shift;\n\tint ratio;\n\n\tcomponent = dai->component;\n\twm8770 = snd_soc_component_get_drvdata(component);\n\n\tiface = 0;\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tiface |= 0x10;\n\t\tbreak;\n\tcase 24:\n\t\tiface |= 0x20;\n\t\tbreak;\n\tcase 32:\n\t\tiface |= 0x30;\n\t\tbreak;\n\t}\n\n\tswitch (substream->stream) {\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\ti = 0;\n\t\tshift = 4;\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\ti = 2;\n\t\tshift = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (snd_soc_component_read(component, WM8770_MSTRCTRL) & 0x100) {\n\t\tfor (; i < ARRAY_SIZE(mclk_ratios); ++i) {\n\t\t\tratio = wm8770->sysclk / params_rate(params);\n\t\t\tif (ratio == mclk_ratios[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == ARRAY_SIZE(mclk_ratios)) {\n\t\t\tdev_err(component->dev,\n\t\t\t\t\"Unable to configure MCLK ratio %d/%d\\n\",\n\t\t\t\twm8770->sysclk, params_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(component->dev, \"MCLK is %dfs\\n\", mclk_ratios[i]);\n\n\t\tsnd_soc_component_update_bits(component, WM8770_MSTRCTRL, 0x7 << shift,\n\t\t\t\t    i << shift);\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8770_IFACECTRL, 0x30, iface);\n\n\treturn 0;\n}\n\nstatic int wm8770_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component;\n\n\tcomponent = dai->component;\n\treturn snd_soc_component_update_bits(component, WM8770_DACMUTE, 0x10,\n\t\t\t\t   !!mute << 4);\n}\n\nstatic int wm8770_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t     int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component;\n\tstruct wm8770_priv *wm8770;\n\n\tcomponent = dai->component;\n\twm8770 = snd_soc_component_get_drvdata(component);\n\twm8770->sysclk = freq;\n\treturn 0;\n}\n\nstatic int wm8770_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tint ret;\n\tstruct wm8770_priv *wm8770;\n\n\twm8770 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8770->supplies),\n\t\t\t\t\t\t    wm8770->supplies);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tregcache_sync(wm8770->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_write(component, WM8770_PWDNCTRL, 0);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_write(component, WM8770_PWDNCTRL, 1);\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8770->supplies),\n\t\t\t\t       wm8770->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define WM8770_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8770_dai_ops = {\n\t.mute_stream = wm8770_mute,\n\t.hw_params = wm8770_hw_params,\n\t.set_fmt = wm8770_set_fmt,\n\t.set_sysclk = wm8770_set_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8770_dai = {\n\t.name = \"wm8770-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = WM8770_FORMATS\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = SNDRV_PCM_RATE_8000_96000,\n\t\t.formats = WM8770_FORMATS\n\t},\n\t.ops = &wm8770_dai_ops,\n\t.symmetric_rate = 1\n};\n\nstatic int wm8770_probe(struct snd_soc_component *component)\n{\n\tstruct wm8770_priv *wm8770;\n\tint ret;\n\n\twm8770 = snd_soc_component_get_drvdata(component);\n\twm8770->component = component;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8770->supplies),\n\t\t\t\t    wm8770->supplies);\n\tif (ret) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8770_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset: %d\\n\", ret);\n\t\tgoto err_reg_enable;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8770_MSDIGVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_MSALGVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_VOUT1RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_VOUT2RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_VOUT3RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_VOUT4RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_DAC1RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_DAC2RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_DAC3RVOL, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, WM8770_DAC4RVOL, 0x100, 0x100);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8770_DACMUTE, 0x10, 0x10);\n\nerr_reg_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8770->supplies), wm8770->supplies);\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8770 = {\n\t.probe\t\t\t= wm8770_probe,\n\t.set_bias_level\t\t= wm8770_set_bias_level,\n\t.controls\t\t= wm8770_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8770_snd_controls),\n\t.dapm_widgets\t\t= wm8770_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8770_dapm_widgets),\n\t.dapm_routes\t\t= wm8770_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8770_intercon),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8770_of_match[] = {\n\t{ .compatible = \"wlf,wm8770\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8770_of_match);\n\nstatic const struct regmap_config wm8770_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8770_RESET,\n\n\t.reg_defaults = wm8770_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8770_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8770_volatile_reg,\n};\n\nstatic int wm8770_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8770_priv *wm8770;\n\tint ret, i;\n\n\twm8770 = devm_kzalloc(&spi->dev, sizeof(struct wm8770_priv),\n\t\t\t      GFP_KERNEL);\n\tif (!wm8770)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8770->supplies); i++)\n\t\twm8770->supplies[i].supply = wm8770_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8770->supplies),\n\t\t\t\t      wm8770->supplies);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8770->disable_nb[0].notifier_call = wm8770_regulator_event_0;\n\twm8770->disable_nb[1].notifier_call = wm8770_regulator_event_1;\n\twm8770->disable_nb[2].notifier_call = wm8770_regulator_event_2;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(wm8770->supplies); i++) {\n\t\tret = devm_regulator_register_notifier(\n\t\t\t\t\t\twm8770->supplies[i].consumer,\n\t\t\t\t\t\t&wm8770->disable_nb[i]);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"Failed to register regulator notifier: %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t}\n\n\twm8770->regmap = devm_regmap_init_spi(spi, &wm8770_regmap);\n\tif (IS_ERR(wm8770->regmap))\n\t\treturn PTR_ERR(wm8770->regmap);\n\n\tspi_set_drvdata(spi, wm8770);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t     &soc_component_dev_wm8770, &wm8770_dai, 1);\n\n\treturn ret;\n}\n\nstatic struct spi_driver wm8770_spi_driver = {\n\t.driver = {\n\t\t.name = \"wm8770\",\n\t\t.of_match_table = wm8770_of_match,\n\t},\n\t.probe = wm8770_spi_probe,\n};\n\nmodule_spi_driver(wm8770_spi_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8770 driver\");\nMODULE_AUTHOR(\"Dimitris Papastamos <dp@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}