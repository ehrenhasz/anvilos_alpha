{
  "module_name": "max98390.c",
  "hash_id": "3c423bbd5b4292a2f11bfcbcb500c9b5ce177131708918427ee14c4323bf3c25",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98390.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/cdev.h>\n#include <linux/dmi.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"max98390.h\"\n\nstatic struct reg_default max98390_reg_defaults[] = {\n\t{MAX98390_INT_EN1, 0xf0},\n\t{MAX98390_INT_EN2, 0x00},\n\t{MAX98390_INT_EN3, 0x00},\n\t{MAX98390_INT_FLAG_CLR1, 0x00},\n\t{MAX98390_INT_FLAG_CLR2, 0x00},\n\t{MAX98390_INT_FLAG_CLR3, 0x00},\n\t{MAX98390_IRQ_CTRL, 0x01},\n\t{MAX98390_CLK_MON, 0x6d},\n\t{MAX98390_DAT_MON, 0x03},\n\t{MAX98390_WDOG_CTRL, 0x00},\n\t{MAX98390_WDOG_RST, 0x00},\n\t{MAX98390_MEAS_ADC_THERM_WARN_THRESH, 0x75},\n\t{MAX98390_MEAS_ADC_THERM_SHDN_THRESH, 0x8c},\n\t{MAX98390_MEAS_ADC_THERM_HYSTERESIS, 0x08},\n\t{MAX98390_PIN_CFG, 0x55},\n\t{MAX98390_PCM_RX_EN_A, 0x00},\n\t{MAX98390_PCM_RX_EN_B, 0x00},\n\t{MAX98390_PCM_TX_EN_A, 0x00},\n\t{MAX98390_PCM_TX_EN_B, 0x00},\n\t{MAX98390_PCM_TX_HIZ_CTRL_A, 0xff},\n\t{MAX98390_PCM_TX_HIZ_CTRL_B, 0xff},\n\t{MAX98390_PCM_CH_SRC_1, 0x00},\n\t{MAX98390_PCM_CH_SRC_2, 0x00},\n\t{MAX98390_PCM_CH_SRC_3, 0x00},\n\t{MAX98390_PCM_MODE_CFG, 0xc0},\n\t{MAX98390_PCM_MASTER_MODE, 0x1c},\n\t{MAX98390_PCM_CLK_SETUP, 0x44},\n\t{MAX98390_PCM_SR_SETUP, 0x08},\n\t{MAX98390_ICC_RX_EN_A, 0x00},\n\t{MAX98390_ICC_RX_EN_B, 0x00},\n\t{MAX98390_ICC_TX_EN_A, 0x00},\n\t{MAX98390_ICC_TX_EN_B, 0x00},\n\t{MAX98390_ICC_HIZ_MANUAL_MODE, 0x00},\n\t{MAX98390_ICC_TX_HIZ_EN_A, 0x00},\n\t{MAX98390_ICC_TX_HIZ_EN_B, 0x00},\n\t{MAX98390_ICC_LNK_EN, 0x00},\n\t{MAX98390_R2039_AMP_DSP_CFG, 0x0f},\n\t{MAX98390_R203A_AMP_EN, 0x81},\n\t{MAX98390_TONE_GEN_DC_CFG, 0x00},\n\t{MAX98390_SPK_SRC_SEL, 0x00},\n\t{MAX98390_SSM_CFG, 0x85},\n\t{MAX98390_MEAS_EN, 0x03},\n\t{MAX98390_MEAS_DSP_CFG, 0x0f},\n\t{MAX98390_BOOST_CTRL0, 0x1c},\n\t{MAX98390_BOOST_CTRL3, 0x01},\n\t{MAX98390_BOOST_CTRL1, 0x40},\n\t{MAX98390_MEAS_ADC_CFG, 0x07},\n\t{MAX98390_MEAS_ADC_BASE_MSB, 0x00},\n\t{MAX98390_MEAS_ADC_BASE_LSB, 0x23},\n\t{MAX98390_ADC_CH0_DIVIDE, 0x00},\n\t{MAX98390_ADC_CH1_DIVIDE, 0x00},\n\t{MAX98390_ADC_CH2_DIVIDE, 0x00},\n\t{MAX98390_ADC_CH0_FILT_CFG, 0x00},\n\t{MAX98390_ADC_CH1_FILT_CFG, 0x00},\n\t{MAX98390_ADC_CH2_FILT_CFG, 0x00},\n\t{MAX98390_PWR_GATE_CTL, 0x2c},\n\t{MAX98390_BROWNOUT_EN, 0x00},\n\t{MAX98390_BROWNOUT_INFINITE_HOLD, 0x00},\n\t{MAX98390_BROWNOUT_INFINITE_HOLD_CLR, 0x00},\n\t{MAX98390_BROWNOUT_LVL_HOLD, 0x00},\n\t{MAX98390_BROWNOUT_LVL1_THRESH, 0x00},\n\t{MAX98390_BROWNOUT_LVL2_THRESH, 0x00},\n\t{MAX98390_BROWNOUT_LVL3_THRESH, 0x00},\n\t{MAX98390_BROWNOUT_LVL4_THRESH, 0x00},\n\t{MAX98390_BROWNOUT_THRESH_HYSTERYSIS, 0x00},\n\t{MAX98390_BROWNOUT_AMP_LIMITER_ATK_REL, 0x1f},\n\t{MAX98390_BROWNOUT_AMP_GAIN_ATK_REL, 0x00},\n\t{MAX98390_BROWNOUT_AMP1_CLIP_MODE, 0x00},\n\t{MAX98390_BROWNOUT_LVL1_CUR_LIMIT, 0x00},\n\t{MAX98390_BROWNOUT_LVL1_AMP1_CTRL1, 0x00},\n\t{MAX98390_BROWNOUT_LVL1_AMP1_CTRL2, 0x00},\n\t{MAX98390_BROWNOUT_LVL1_AMP1_CTRL3, 0x00},\n\t{MAX98390_BROWNOUT_LVL2_CUR_LIMIT, 0x00},\n\t{MAX98390_BROWNOUT_LVL2_AMP1_CTRL1, 0x00},\n\t{MAX98390_BROWNOUT_LVL2_AMP1_CTRL2, 0x00},\n\t{MAX98390_BROWNOUT_LVL2_AMP1_CTRL3, 0x00},\n\t{MAX98390_BROWNOUT_LVL3_CUR_LIMIT, 0x00},\n\t{MAX98390_BROWNOUT_LVL3_AMP1_CTRL1, 0x00},\n\t{MAX98390_BROWNOUT_LVL3_AMP1_CTRL2, 0x00},\n\t{MAX98390_BROWNOUT_LVL3_AMP1_CTRL3, 0x00},\n\t{MAX98390_BROWNOUT_LVL4_CUR_LIMIT, 0x00},\n\t{MAX98390_BROWNOUT_LVL4_AMP1_CTRL1, 0x00},\n\t{MAX98390_BROWNOUT_LVL4_AMP1_CTRL2, 0x00},\n\t{MAX98390_BROWNOUT_LVL4_AMP1_CTRL3, 0x00},\n\t{MAX98390_BROWNOUT_ILIM_HLD, 0x00},\n\t{MAX98390_BROWNOUT_LIM_HLD, 0x00},\n\t{MAX98390_BROWNOUT_CLIP_HLD, 0x00},\n\t{MAX98390_BROWNOUT_GAIN_HLD, 0x00},\n\t{MAX98390_ENV_TRACK_VOUT_HEADROOM, 0x0f},\n\t{MAX98390_ENV_TRACK_BOOST_VOUT_DELAY, 0x80},\n\t{MAX98390_ENV_TRACK_REL_RATE, 0x07},\n\t{MAX98390_ENV_TRACK_HOLD_RATE, 0x07},\n\t{MAX98390_ENV_TRACK_CTRL, 0x01},\n\t{MAX98390_BOOST_BYPASS1, 0x49},\n\t{MAX98390_BOOST_BYPASS2, 0x2b},\n\t{MAX98390_BOOST_BYPASS3, 0x08},\n\t{MAX98390_FET_SCALING1, 0x00},\n\t{MAX98390_FET_SCALING2, 0x03},\n\t{MAX98390_FET_SCALING3, 0x00},\n\t{MAX98390_FET_SCALING4, 0x07},\n\t{MAX98390_SPK_SPEEDUP, 0x00},\n\t{DSMIG_WB_DRC_RELEASE_TIME_1, 0x00},\n\t{DSMIG_WB_DRC_RELEASE_TIME_2, 0x00},\n\t{DSMIG_WB_DRC_ATTACK_TIME_1, 0x00},\n\t{DSMIG_WB_DRC_ATTACK_TIME_2, 0x00},\n\t{DSMIG_WB_DRC_COMPRESSION_RATIO, 0x00},\n\t{DSMIG_WB_DRC_COMPRESSION_THRESHOLD, 0x00},\n\t{DSMIG_WB_DRC_MAKEUPGAIN, 0x00},\n\t{DSMIG_WB_DRC_NOISE_GATE_THRESHOLD, 0x00},\n\t{DSMIG_WBDRC_HPF_ENABLE, 0x00},\n\t{DSMIG_WB_DRC_TEST_SMOOTHER_OUT_EN, 0x00},\n\t{DSMIG_PPR_THRESHOLD, 0x00},\n\t{DSM_STEREO_BASS_CHANNEL_SELECT, 0x00},\n\t{DSM_TPROT_THRESHOLD_BYTE0, 0x00},\n\t{DSM_TPROT_THRESHOLD_BYTE1, 0x00},\n\t{DSM_TPROT_ROOM_TEMPERATURE_BYTE0, 0x00},\n\t{DSM_TPROT_ROOM_TEMPERATURE_BYTE1, 0x00},\n\t{DSM_TPROT_RECIP_RDC_ROOM_BYTE0, 0x00},\n\t{DSM_TPROT_RECIP_RDC_ROOM_BYTE1, 0x00},\n\t{DSM_TPROT_RECIP_RDC_ROOM_BYTE2, 0x00},\n\t{DSM_TPROT_RECIP_TCONST_BYTE0, 0x00},\n\t{DSM_TPROT_RECIP_TCONST_BYTE1, 0x00},\n\t{DSM_TPROT_RECIP_TCONST_BYTE2, 0x00},\n\t{DSM_THERMAL_ATTENUATION_SETTINGS, 0x00},\n\t{DSM_THERMAL_PILOT_TONE_ATTENUATION, 0x00},\n\t{DSM_TPROT_PG_TEMP_THRESH_BYTE0, 0x00},\n\t{DSM_TPROT_PG_TEMP_THRESH_BYTE1, 0x00},\n\t{DSMIG_DEBUZZER_THRESHOLD, 0x00},\n\t{DSMIG_DEBUZZER_ALPHA_COEF_TEST_ONLY, 0x08},\n\t{DSM_VOL_ENA, 0x20},\n\t{DSM_VOL_CTRL, 0xa0},\n\t{DSMIG_EN, 0x00},\n\t{MAX98390_R23E1_DSP_GLOBAL_EN, 0x00},\n\t{MAX98390_R23FF_GLOBAL_EN, 0x00},\n};\n\nstatic int max98390_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tunsigned int mode;\n\tunsigned int format;\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmode = MAX98390_PCM_MASTER_MODE_SLAVE;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tmax98390->provider = true;\n\t\tmode = MAX98390_PCM_MASTER_MODE_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI clock mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_MASTER_MODE,\n\t\tMAX98390_PCM_MASTER_MODE_MASK,\n\t\tmode);\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = MAX98390_PCM_MODE_CFG_PCM_BCLKEDGE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_MODE_CFG,\n\t\tMAX98390_PCM_MODE_CFG_PCM_BCLKEDGE,\n\t\tinvert);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tformat = MAX98390_PCM_FORMAT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tformat = MAX98390_PCM_FORMAT_LJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tformat = MAX98390_PCM_FORMAT_TDM_MODE1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tformat = MAX98390_PCM_FORMAT_TDM_MODE0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_MODE_CFG,\n\t\tMAX98390_PCM_MODE_CFG_FORMAT_MASK,\n\t\tformat << MAX98390_PCM_MODE_CFG_FORMAT_SHIFT);\n\n\treturn 0;\n}\n\nstatic int max98390_get_bclk_sel(int bclk)\n{\n\tint i;\n\t \n\tstatic int bclk_sel_table[] = {\n\t\t32, 48, 64, 96, 128, 192, 256, 320, 384, 512,\n\t};\n\t \n\tfor (i = 0; i < ARRAY_SIZE(bclk_sel_table); i++) {\n\t\tif (bclk_sel_table[i] == bclk)\n\t\t\treturn i + 2;\n\t}\n\treturn 0;\n}\n\nstatic int max98390_set_clock(struct snd_soc_component *component,\n\t\tstruct snd_pcm_hw_params *params)\n{\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\t \n\tstatic int rate_table[] = {\n\t\t5644800, 6000000, 6144000, 6500000,\n\t\t9600000, 11289600, 12000000, 12288000,\n\t\t13000000, 19200000,\n\t};\n\t \n\tint blr_clk_ratio = params_channels(params)\n\t\t* snd_pcm_format_width(params_format(params));\n\tint value;\n\n\tif (max98390->provider) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n\t\t\tif (rate_table[i] >= max98390->sysclk)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(rate_table)) {\n\t\t\tdev_err(component->dev, \"failed to find proper clock rate.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_MASTER_MODE,\n\t\t\tMAX98390_PCM_MASTER_MODE_MCLK_MASK,\n\t\t\ti << MAX98390_PCM_MASTER_MODE_MCLK_RATE_SHIFT);\n\t}\n\n\tif (!max98390->tdm_mode) {\n\t\t \n\t\tvalue = max98390_get_bclk_sel(blr_clk_ratio);\n\t\tif (!value) {\n\t\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\t\tparams_format(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_CLK_SETUP,\n\t\t\tMAX98390_PCM_CLK_SETUP_BSEL_MASK,\n\t\t\tvalue);\n\t}\n\treturn 0;\n}\n\nstatic int max98390_dai_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component =\n\t\tdai->component;\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tunsigned int sampling_rate;\n\tunsigned int chan_sz;\n\n\t \n\tswitch (snd_pcm_format_width(params_format(params))) {\n\tcase 16:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tparams_format(params));\n\t\tgoto err;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_MODE_CFG,\n\t\tMAX98390_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\tdev_dbg(component->dev, \"format supported %d\",\n\t\tparams_format(params));\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_8000;\n\t\tbreak;\n\tcase 11025:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_11025;\n\t\tbreak;\n\tcase 12000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_12000;\n\t\tbreak;\n\tcase 16000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_16000;\n\t\tbreak;\n\tcase 22050:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_22050;\n\t\tbreak;\n\tcase 24000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_24000;\n\t\tbreak;\n\tcase 32000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_32000;\n\t\tbreak;\n\tcase 44100:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_44100;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = MAX98390_PCM_SR_SET1_SR_48000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"rate %d not supported\\n\",\n\t\t\tparams_rate(params));\n\t\tgoto err;\n\t}\n\n\t \n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_SR_SETUP,\n\t\tMAX98390_PCM_SR_SET1_SR_MASK,\n\t\tsampling_rate);\n\n\treturn max98390_set_clock(component, params);\nerr:\n\treturn -EINVAL;\n}\n\nstatic int max98390_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\tunsigned int tx_mask, unsigned int rx_mask,\n\t\tint slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tint bsel;\n\tunsigned int chan_sz;\n\n\tif (!tx_mask && !rx_mask && !slots && !slot_width)\n\t\tmax98390->tdm_mode = false;\n\telse\n\t\tmax98390->tdm_mode = true;\n\n\tdev_dbg(component->dev,\n\t\t\"Tdm mode : %d\\n\", max98390->tdm_mode);\n\n\t \n\tbsel = max98390_get_bclk_sel(slots * slot_width);\n\tif (!bsel) {\n\t\tdev_err(component->dev, \"BCLK %d not supported\\n\",\n\t\t\tslots * slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_CLK_SETUP,\n\t\tMAX98390_PCM_CLK_SETUP_BSEL_MASK,\n\t\tbsel);\n\n\t \n\tswitch (slot_width) {\n\tcase 16:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_16;\n\t\tbreak;\n\tcase 24:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_24;\n\t\tbreak;\n\tcase 32:\n\t\tchan_sz = MAX98390_PCM_MODE_CFG_CHANSZ_32;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"format unsupported %d\\n\",\n\t\t\tslot_width);\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98390->regmap,\n\t\tMAX98390_PCM_MODE_CFG,\n\t\tMAX98390_PCM_MODE_CFG_CHANSZ_MASK, chan_sz);\n\n\t \n\tregmap_write(max98390->regmap,\n\t\tMAX98390_PCM_RX_EN_A,\n\t\trx_mask & 0xFF);\n\tregmap_write(max98390->regmap,\n\t\tMAX98390_PCM_RX_EN_B,\n\t\t(rx_mask & 0xFF00) >> 8);\n\n\t \n\tregmap_write(max98390->regmap,\n\t\tMAX98390_PCM_TX_HIZ_CTRL_A,\n\t\t~tx_mask & 0xFF);\n\tregmap_write(max98390->regmap,\n\t\tMAX98390_PCM_TX_HIZ_CTRL_B,\n\t\t(~tx_mask & 0xFF00) >> 8);\n\n\treturn 0;\n}\n\nstatic int max98390_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmax98390->sysclk = freq;\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops max98390_dai_ops = {\n\t.set_sysclk = max98390_dai_set_sysclk,\n\t.set_fmt = max98390_dai_set_fmt,\n\t.hw_params = max98390_dai_hw_params,\n\t.set_tdm_slot = max98390_dai_tdm_slot,\n};\n\nstatic int max98390_dac_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_R203A_AMP_EN,\n\t\t\tMAX98390_AMP_EN_MASK, 1);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_R23FF_GLOBAL_EN,\n\t\t\tMAX98390_GLOBAL_EN_MASK, 1);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_R23FF_GLOBAL_EN,\n\t\t\tMAX98390_GLOBAL_EN_MASK, 0);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_R203A_AMP_EN,\n\t\t\tMAX98390_AMP_EN_MASK, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const char * const max98390_switch_text[] = {\n\t\"Left\", \"Right\", \"LeftRight\"};\n\nstatic const char * const max98390_boost_voltage_text[] = {\n\t\"6.5V\", \"6.625V\", \"6.75V\", \"6.875V\", \"7V\", \"7.125V\", \"7.25V\", \"7.375V\",\n\t\"7.5V\", \"7.625V\", \"7.75V\", \"7.875V\", \"8V\", \"8.125V\", \"8.25V\", \"8.375V\",\n\t\"8.5V\", \"8.625V\", \"8.75V\", \"8.875V\", \"9V\", \"9.125V\", \"9.25V\", \"9.375V\",\n\t\"9.5V\", \"9.625V\", \"9.75V\", \"9.875V\", \"10V\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98390_boost_voltage,\n\t\tMAX98390_BOOST_CTRL0, 0,\n\t\tmax98390_boost_voltage_text);\n\nstatic DECLARE_TLV_DB_SCALE(max98390_spk_tlv, 300, 300, 0);\nstatic DECLARE_TLV_DB_SCALE(max98390_digital_tlv, -8000, 50, 0);\n\nstatic const char * const max98390_current_limit_text[] = {\n\t\"0.00A\", \"0.50A\", \"1.00A\", \"1.05A\", \"1.10A\", \"1.15A\", \"1.20A\", \"1.25A\",\n\t\"1.30A\", \"1.35A\", \"1.40A\", \"1.45A\", \"1.50A\", \"1.55A\", \"1.60A\", \"1.65A\",\n\t\"1.70A\", \"1.75A\", \"1.80A\", \"1.85A\", \"1.90A\", \"1.95A\", \"2.00A\", \"2.05A\",\n\t\"2.10A\", \"2.15A\", \"2.20A\", \"2.25A\", \"2.30A\", \"2.35A\", \"2.40A\", \"2.45A\",\n\t\"2.50A\", \"2.55A\", \"2.60A\", \"2.65A\", \"2.70A\", \"2.75A\", \"2.80A\", \"2.85A\",\n\t\"2.90A\", \"2.95A\", \"3.00A\", \"3.05A\", \"3.10A\", \"3.15A\", \"3.20A\", \"3.25A\",\n\t\"3.30A\", \"3.35A\", \"3.40A\", \"3.45A\", \"3.50A\", \"3.55A\", \"3.60A\", \"3.65A\",\n\t\"3.70A\", \"3.75A\", \"3.80A\", \"3.85A\", \"3.90A\", \"3.95A\", \"4.00A\", \"4.05A\",\n\t\"4.10A\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98390_current_limit,\n\t\tMAX98390_BOOST_CTRL1, 0,\n\t\tmax98390_current_limit_text);\n\nstatic int max98390_ref_rdc_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmax98390->ref_rdc_value = ucontrol->value.integer.value[0];\n\n\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE0,\n\t\tmax98390->ref_rdc_value & 0x000000ff);\n\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE1,\n\t\t(max98390->ref_rdc_value >> 8) & 0x000000ff);\n\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE2,\n\t\t(max98390->ref_rdc_value >> 16) & 0x000000ff);\n\n\treturn 0;\n}\n\nstatic int max98390_ref_rdc_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = max98390->ref_rdc_value;\n\n\treturn 0;\n}\n\nstatic int max98390_ambient_temp_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tmax98390->ambient_temp_value = ucontrol->value.integer.value[0];\n\n\tregmap_write(max98390->regmap, DSM_TPROT_ROOM_TEMPERATURE_BYTE1,\n\t\t(max98390->ambient_temp_value >> 8) & 0x000000ff);\n\tregmap_write(max98390->regmap, DSM_TPROT_ROOM_TEMPERATURE_BYTE0,\n\t\t(max98390->ambient_temp_value) & 0x000000ff);\n\n\treturn 0;\n}\n\nstatic int max98390_ambient_temp_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = max98390->ambient_temp_value;\n\n\treturn 0;\n}\n\nstatic int max98390_adaptive_rdc_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\n\tdev_warn(component->dev, \"Put adaptive rdc not supported\\n\");\n\n\treturn 0;\n}\n\nstatic int max98390_adaptive_rdc_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tint rdc, rdc0;\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tregmap_read(max98390->regmap, THERMAL_RDC_RD_BACK_BYTE1, &rdc);\n\tregmap_read(max98390->regmap, THERMAL_RDC_RD_BACK_BYTE0, &rdc0);\n\tucontrol->value.integer.value[0] = rdc0 | rdc << 8;\n\n\treturn 0;\n}\n\nstatic int max98390_dsm_calib_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\t \n\treturn 0;\n}\n\nstatic int max98390_dsm_calib_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98390_priv *max98390 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tunsigned int rdc, rdc_cal_result, rdc_integer, rdc_factor, temp, val;\n\n\tsnd_soc_dapm_mutex_lock(dapm);\n\n\tregmap_read(max98390->regmap, MAX98390_R23FF_GLOBAL_EN, &val);\n\tif (!val) {\n\t\t \n\t\tregmap_update_bits(max98390->regmap, MAX98390_R203A_AMP_EN,\n\t\t\t\t   MAX98390_AMP_EN_MASK, 1);\n\t\tregmap_update_bits(max98390->regmap, MAX98390_R23FF_GLOBAL_EN,\n\t\t\t\t   MAX98390_GLOBAL_EN_MASK, 1);\n\t}\n\n\tregmap_read(max98390->regmap, THERMAL_RDC_RD_BACK_BYTE1, &rdc);\n\tregmap_read(max98390->regmap, THERMAL_RDC_RD_BACK_BYTE0, &rdc_cal_result);\n\tregmap_read(max98390->regmap, MAX98390_MEAS_ADC_CH2_READ, &temp);\n\n\tif (!val) {\n\t\t \n\t\tregmap_update_bits(max98390->regmap, MAX98390_R23FF_GLOBAL_EN,\n\t\t\t\t   MAX98390_GLOBAL_EN_MASK, 0);\n\t\tregmap_update_bits(max98390->regmap, MAX98390_R203A_AMP_EN,\n\t\t\t\t   MAX98390_AMP_EN_MASK, 0);\n\t}\n\n\tsnd_soc_dapm_mutex_unlock(dapm);\n\n\trdc_cal_result |= (rdc << 8) & 0x0000FFFF;\n\tif (rdc_cal_result)\n\t\tmax98390->ref_rdc_value = 268435456U / rdc_cal_result;\n\n\tmax98390->ambient_temp_value = temp * 52 - 1188;\n\n\trdc_integer =  rdc_cal_result * 937  / 65536;\n\trdc_factor = ((rdc_cal_result * 937 * 100) / 65536) - (rdc_integer * 100);\n\n\tdev_info(component->dev,\n\t\t \"rdc resistance about %d.%02d ohm, reg=0x%X temp reg=0x%X\\n\",\n\t\t rdc_integer, rdc_factor, rdc_cal_result, temp);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new max98390_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Digital Volume\", DSM_VOL_CTRL,\n\t\t0, 184, 0,\n\t\tmax98390_digital_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98390_R203D_SPK_GAIN,\n\t\t0, 6, 0,\n\t\tmax98390_spk_tlv),\n\tSOC_SINGLE(\"Ramp Up Bypass Switch\", MAX98390_R2039_AMP_DSP_CFG,\n\t\tMAX98390_AMP_DSP_CFG_RMP_UP_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Ramp Down Bypass Switch\", MAX98390_R2039_AMP_DSP_CFG,\n\t\tMAX98390_AMP_DSP_CFG_RMP_DN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"Boost Clock Phase\", MAX98390_BOOST_CTRL3,\n\t\tMAX98390_BOOST_CLK_PHASE_CFG_SHIFT, 3, 0),\n\tSOC_ENUM(\"Boost Output Voltage\", max98390_boost_voltage),\n\tSOC_ENUM(\"Current Limit\", max98390_current_limit),\n\tSOC_SINGLE_EXT(\"DSM Rdc\", SND_SOC_NOPM, 0, 0xffffff, 0,\n\t\tmax98390_ref_rdc_get, max98390_ref_rdc_put),\n\tSOC_SINGLE_EXT(\"DSM Ambient Temp\", SND_SOC_NOPM, 0, 0xffff, 0,\n\t\tmax98390_ambient_temp_get, max98390_ambient_temp_put),\n\tSOC_SINGLE_EXT(\"DSM Adaptive Rdc\", SND_SOC_NOPM, 0, 0xffff, 0,\n\t\tmax98390_adaptive_rdc_get, max98390_adaptive_rdc_put),\n\tSOC_SINGLE_EXT(\"DSM Calibration\", SND_SOC_NOPM, 0, 1, 0,\n\t\tmax98390_dsm_calib_get, max98390_dsm_calib_put),\n};\n\nstatic const struct soc_enum dai_sel_enum =\n\tSOC_ENUM_SINGLE(MAX98390_PCM_CH_SRC_1,\n\t\tMAX98390_PCM_RX_CH_SRC_SHIFT,\n\t\t3, max98390_switch_text);\n\nstatic const struct snd_kcontrol_new max98390_dai_controls =\n\tSOC_DAPM_ENUM(\"DAI Sel\", dai_sel_enum);\n\nstatic const struct snd_soc_dapm_widget max98390_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"Amp Enable\", \"HiFi Playback\",\n\t\tSND_SOC_NOPM, 0, 0, max98390_dac_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MUX(\"DAI Sel Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&max98390_dai_controls),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route max98390_audio_map[] = {\n\t \n\t{\"DAI Sel Mux\", \"Left\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"Right\", \"Amp Enable\"},\n\t{\"DAI Sel Mux\", \"LeftRight\", \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"DAI Sel Mux\"},\n};\n\nstatic bool max98390_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98390_SOFTWARE_RESET ... MAX98390_INT_EN3:\n\tcase MAX98390_IRQ_CTRL ... MAX98390_WDOG_CTRL:\n\tcase MAX98390_MEAS_ADC_THERM_WARN_THRESH\n\t\t... MAX98390_BROWNOUT_INFINITE_HOLD:\n\tcase MAX98390_BROWNOUT_LVL_HOLD ... DSMIG_DEBUZZER_THRESHOLD:\n\tcase DSM_VOL_ENA ... MAX98390_R24FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98390_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98390_SOFTWARE_RESET ... MAX98390_INT_EN3:\n\tcase MAX98390_MEAS_ADC_CH0_READ ... MAX98390_MEAS_ADC_CH2_READ:\n\tcase MAX98390_PWR_GATE_STATUS ... MAX98390_BROWNOUT_STATUS:\n\tcase MAX98390_BROWNOUT_LOWEST_STATUS:\n\tcase MAX98390_ENV_TRACK_BOOST_VOUT_READ:\n\tcase DSM_STBASS_HPF_B0_BYTE0 ... DSM_DEBUZZER_ATTACK_TIME_BYTE2:\n\tcase THERMAL_RDC_RD_BACK_BYTE1 ... DSMIG_DEBUZZER_THRESHOLD:\n\tcase DSM_THERMAL_GAIN ... DSM_WBDRC_GAIN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n#define MAX98390_RATES SNDRV_PCM_RATE_8000_48000\n\n#define MAX98390_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver max98390_dai[] = {\n\t{\n\t\t.name = \"max98390-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98390_RATES,\n\t\t\t.formats = MAX98390_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = MAX98390_RATES,\n\t\t\t.formats = MAX98390_FORMATS,\n\t\t},\n\t\t.ops = &max98390_dai_ops,\n\t}\n};\n\nstatic int max98390_dsm_init(struct snd_soc_component *component)\n{\n\tint ret;\n\tint param_size, param_start_addr;\n\tchar filename[128];\n\tconst char *vendor, *product;\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tconst struct firmware *fw;\n\tchar *dsm_param;\n\n\tvendor = dmi_get_system_info(DMI_SYS_VENDOR);\n\tproduct = dmi_get_system_info(DMI_PRODUCT_NAME);\n\n\tif (!strcmp(max98390->dsm_param_name, \"default\")) {\n\t\tif (vendor && product) {\n\t\t\tsnprintf(filename, sizeof(filename),\n\t\t\t\t\"dsm_param_%s_%s.bin\", vendor, product);\n\t\t} else {\n\t\t\tsprintf(filename, \"dsm_param.bin\");\n\t\t}\n\t} else {\n\t\tsnprintf(filename, sizeof(filename), \"%s\",\n\t\t\tmax98390->dsm_param_name);\n\t}\n\tret = request_firmware(&fw, filename, component->dev);\n\tif (ret) {\n\t\tret = request_firmware(&fw, \"dsm_param.bin\", component->dev);\n\t\tif (ret) {\n\t\t\tret = request_firmware(&fw, \"dsmparam.bin\",\n\t\t\t\tcomponent->dev);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev_dbg(component->dev,\n\t\t\"max98390: param fw size %zd\\n\",\n\t\tfw->size);\n\tif (fw->size < MAX98390_DSM_PARAM_MIN_SIZE) {\n\t\tdev_err(component->dev,\n\t\t\t\"param fw is invalid.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_alloc;\n\t}\n\tdsm_param = (char *)fw->data;\n\tparam_start_addr = (dsm_param[0] & 0xff) | (dsm_param[1] & 0xff) << 8;\n\tparam_size = (dsm_param[2] & 0xff) | (dsm_param[3] & 0xff) << 8;\n\tif (param_size > MAX98390_DSM_PARAM_MAX_SIZE ||\n\t\tparam_start_addr < MAX98390_IRQ_CTRL ||\n\t\tfw->size < param_size + MAX98390_DSM_PAYLOAD_OFFSET) {\n\t\tdev_err(component->dev,\n\t\t\t\"param fw is invalid.\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_alloc;\n\t}\n\tregmap_write(max98390->regmap, MAX98390_R203A_AMP_EN, 0x80);\n\tdsm_param += MAX98390_DSM_PAYLOAD_OFFSET;\n\tregmap_bulk_write(max98390->regmap, param_start_addr,\n\t\tdsm_param, param_size);\n\tregmap_write(max98390->regmap, MAX98390_R23E1_DSP_GLOBAL_EN, 0x01);\n\nerr_alloc:\n\trelease_firmware(fw);\nerr:\n\treturn ret;\n}\n\nstatic void max98390_init_regs(struct snd_soc_component *component)\n{\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tregmap_write(max98390->regmap, MAX98390_CLK_MON, 0x6f);\n\tregmap_write(max98390->regmap, MAX98390_DAT_MON, 0x00);\n\tregmap_write(max98390->regmap, MAX98390_PWR_GATE_CTL, 0x00);\n\tregmap_write(max98390->regmap, MAX98390_PCM_RX_EN_A, 0x03);\n\tregmap_write(max98390->regmap, MAX98390_ENV_TRACK_VOUT_HEADROOM, 0x0e);\n\tregmap_write(max98390->regmap, MAX98390_BOOST_BYPASS1, 0x46);\n\tregmap_write(max98390->regmap, MAX98390_FET_SCALING3, 0x03);\n\n\t \n\tregmap_write(max98390->regmap,\n\t\tMAX98390_PCM_CH_SRC_2,\n\t\t(max98390->i_l_slot << 4 |\n\t\tmax98390->v_l_slot)&0xFF);\n\n\tif (max98390->v_l_slot < 8) {\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_HIZ_CTRL_A,\n\t\t\t1 << max98390->v_l_slot, 0);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_EN_A,\n\t\t\t1 << max98390->v_l_slot,\n\t\t\t1 << max98390->v_l_slot);\n\t} else {\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_HIZ_CTRL_B,\n\t\t\t1 << (max98390->v_l_slot - 8), 0);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_EN_B,\n\t\t\t1 << (max98390->v_l_slot - 8),\n\t\t\t1 << (max98390->v_l_slot - 8));\n\t}\n\n\tif (max98390->i_l_slot < 8) {\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_HIZ_CTRL_A,\n\t\t\t1 << max98390->i_l_slot, 0);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_EN_A,\n\t\t\t1 << max98390->i_l_slot,\n\t\t\t1 << max98390->i_l_slot);\n\t} else {\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_HIZ_CTRL_B,\n\t\t\t1 << (max98390->i_l_slot - 8), 0);\n\t\tregmap_update_bits(max98390->regmap,\n\t\t\tMAX98390_PCM_TX_EN_B,\n\t\t\t1 << (max98390->i_l_slot - 8),\n\t\t\t1 << (max98390->i_l_slot - 8));\n\t}\n}\n\nstatic int max98390_probe(struct snd_soc_component *component)\n{\n\tstruct max98390_priv *max98390 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tregmap_write(max98390->regmap, MAX98390_SOFTWARE_RESET, 0x01);\n\t \n\tmsleep(20);\n\n\t \n\tmax98390_init_regs(component);\n\t \n\tmax98390_dsm_init(component);\n\n\t \n\tif (max98390->ref_rdc_value) {\n\t\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE0,\n\t\t\tmax98390->ref_rdc_value & 0x000000ff);\n\t\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE1,\n\t\t\t(max98390->ref_rdc_value >> 8) & 0x000000ff);\n\t\tregmap_write(max98390->regmap, DSM_TPROT_RECIP_RDC_ROOM_BYTE2,\n\t\t\t(max98390->ref_rdc_value >> 16) & 0x000000ff);\n\t}\n\tif (max98390->ambient_temp_value) {\n\t\tregmap_write(max98390->regmap, DSM_TPROT_ROOM_TEMPERATURE_BYTE1,\n\t\t\t(max98390->ambient_temp_value >> 8) & 0x000000ff);\n\t\tregmap_write(max98390->regmap, DSM_TPROT_ROOM_TEMPERATURE_BYTE0,\n\t\t\t(max98390->ambient_temp_value) & 0x000000ff);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int max98390_suspend(struct device *dev)\n{\n\tstruct max98390_priv *max98390 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s:Enter\\n\", __func__);\n\n\tregcache_cache_only(max98390->regmap, true);\n\tregcache_mark_dirty(max98390->regmap);\n\n\treturn 0;\n}\n\nstatic int max98390_resume(struct device *dev)\n{\n\tstruct max98390_priv *max98390 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"%s:Enter\\n\", __func__);\n\n\tregcache_cache_only(max98390->regmap, false);\n\tregcache_sync(max98390->regmap);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops max98390_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(max98390_suspend, max98390_resume)\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_max98390 = {\n\t.probe\t\t\t= max98390_probe,\n\t.controls\t\t= max98390_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98390_snd_controls),\n\t.dapm_widgets\t\t= max98390_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98390_dapm_widgets),\n\t.dapm_routes\t\t= max98390_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98390_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98390_regmap = {\n\t.reg_bits         = 16,\n\t.val_bits         = 8,\n\t.max_register     = MAX98390_R24FF_REV_ID,\n\t.reg_defaults     = max98390_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(max98390_reg_defaults),\n\t.readable_reg\t  = max98390_readable_register,\n\t.volatile_reg\t  = max98390_volatile_reg,\n\t.cache_type       = REGCACHE_RBTREE,\n};\n\nstatic void max98390_slot_config(struct i2c_client *i2c,\n\tstruct max98390_priv *max98390)\n{\n\tint value;\n\tstruct device *dev = &i2c->dev;\n\n\tif (!device_property_read_u32(dev, \"maxim,vmon-slot-no\", &value))\n\t\tmax98390->v_l_slot = value & 0xF;\n\telse\n\t\tmax98390->v_l_slot = 0;\n\n\tif (!device_property_read_u32(dev, \"maxim,imon-slot-no\", &value))\n\t\tmax98390->i_l_slot = value & 0xF;\n\telse\n\t\tmax98390->i_l_slot = 1;\n}\n\nstatic int max98390_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret = 0;\n\tint reg = 0;\n\n\tstruct max98390_priv *max98390 = NULL;\n\tstruct i2c_adapter *adapter = i2c->adapter;\n\tstruct gpio_desc *reset_gpio;\n\n\tret = i2c_check_functionality(adapter,\n\t\tI2C_FUNC_SMBUS_BYTE\n\t\t| I2C_FUNC_SMBUS_BYTE_DATA);\n\tif (!ret) {\n\t\tdev_err(&i2c->dev, \"I2C check functionality failed\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmax98390 = devm_kzalloc(&i2c->dev, sizeof(*max98390), GFP_KERNEL);\n\tif (!max98390) {\n\t\tret = -ENOMEM;\n\t\treturn ret;\n\t}\n\ti2c_set_clientdata(i2c, max98390);\n\n\tret = device_property_read_u32(&i2c->dev, \"maxim,temperature_calib\",\n\t\t\t\t       &max98390->ambient_temp_value);\n\tif (ret) {\n\t\tdev_info(&i2c->dev,\n\t\t\t \"no optional property 'temperature_calib' found, default:\\n\");\n\t}\n\tret = device_property_read_u32(&i2c->dev, \"maxim,r0_calib\",\n\t\t\t\t       &max98390->ref_rdc_value);\n\tif (ret) {\n\t\tdev_info(&i2c->dev,\n\t\t\t \"no optional property 'r0_calib' found, default:\\n\");\n\t}\n\n\tdev_info(&i2c->dev,\n\t\t\"%s: r0_calib: 0x%x,temperature_calib: 0x%x\",\n\t\t__func__, max98390->ref_rdc_value,\n\t\tmax98390->ambient_temp_value);\n\n\tret = device_property_read_string(&i2c->dev, \"maxim,dsm_param_name\",\n\t\t\t\t       &max98390->dsm_param_name);\n\tif (ret)\n\t\tmax98390->dsm_param_name = \"default\";\n\n\t \n\tmax98390_slot_config(i2c, max98390);\n\n\t \n\tmax98390->regmap = devm_regmap_init_i2c(i2c, &max98390_regmap);\n\tif (IS_ERR(max98390->regmap)) {\n\t\tret = PTR_ERR(max98390->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treset_gpio = devm_gpiod_get_optional(&i2c->dev,\n\t\t\t\t\t     \"reset\", GPIOD_OUT_HIGH);\n\n\t \n\tif (reset_gpio) {\n\t\tusleep_range(1000, 2000);\n\t\t \n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\tusleep_range(1000, 2000);\n\t}\n\n\t \n\tret = regmap_read(max98390->regmap,\n\t\tMAX98390_R24FF_REV_ID, &reg);\n\tif (ret) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"ret=%d, Failed to read: 0x%02X\\n\",\n\t\t\tret, MAX98390_R24FF_REV_ID);\n\t\treturn ret;\n\t}\n\tdev_info(&i2c->dev, \"MAX98390 revisionID: 0x%02X\\n\", reg);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_codec_dev_max98390,\n\t\t\tmax98390_dai, ARRAY_SIZE(max98390_dai));\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98390_i2c_id[] = {\n\t{ \"max98390\", 0},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, max98390_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id max98390_of_match[] = {\n\t{ .compatible = \"maxim,max98390\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, max98390_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id max98390_acpi_match[] = {\n\t{ \"MX98390\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, max98390_acpi_match);\n#endif\n\nstatic struct i2c_driver max98390_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98390\",\n\t\t.of_match_table = of_match_ptr(max98390_of_match),\n\t\t.acpi_match_table = ACPI_PTR(max98390_acpi_match),\n\t\t.pm = &max98390_pm,\n\t},\n\t.probe = max98390_i2c_probe,\n\t.id_table = max98390_i2c_id,\n};\n\nmodule_i2c_driver(max98390_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98390 driver\");\nMODULE_AUTHOR(\"Steve Lee <steves.lee@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}