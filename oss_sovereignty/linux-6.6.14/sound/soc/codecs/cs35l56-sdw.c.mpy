{
  "module_name": "cs35l56-sdw.c",
  "hash_id": "1832d75242bc9c4329dd2dea080271b9756b52e27d74fcf89ba478047ae73189",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l56-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw_type.h>\n#include <linux/swab.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n\n#include \"cs35l56.h\"\n\n \n#define CS35L56_SDW_ADDR_OFFSET\t\t0x8000\n\nstatic int cs35l56_sdw_read_one(struct sdw_slave *peripheral, unsigned int reg, void *buf)\n{\n\tint ret;\n\n\tret = sdw_nread_no_pm(peripheral, reg, 4, (u8 *)buf);\n\tif (ret != 0) {\n\t\tdev_err(&peripheral->dev, \"Read failed @%#x:%d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\tswab32s((u32 *)buf);\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_read(void *context, const void *reg_buf,\n\t\t\t    const size_t reg_size, void *val_buf,\n\t\t\t    size_t val_size)\n{\n\tstruct sdw_slave *peripheral = context;\n\tu8 *buf8 = val_buf;\n\tunsigned int reg, bytes;\n\tint ret;\n\n\treg = le32_to_cpu(*(const __le32 *)reg_buf);\n\treg += CS35L56_SDW_ADDR_OFFSET;\n\n\tif (val_size == 4)\n\t\treturn cs35l56_sdw_read_one(peripheral, reg, val_buf);\n\n\twhile (val_size) {\n\t\tbytes = SDW_REG_NO_PAGE - (reg & SDW_REGADDR);  \n\t\tif (bytes > val_size)\n\t\t\tbytes = val_size;\n\n\t\tret = sdw_nread_no_pm(peripheral, reg, bytes, buf8);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&peripheral->dev, \"Read failed @%#x..%#x:%d\\n\",\n\t\t\t\treg, reg + bytes - 1, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswab32_array((u32 *)buf8, bytes / 4);\n\t\tval_size -= bytes;\n\t\treg += bytes;\n\t\tbuf8 += bytes;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void cs35l56_swab_copy(void *dest, const void *src, size_t nbytes)\n{\n\tu32 *dest32 = dest;\n\tconst u32 *src32 = src;\n\n\tfor (; nbytes > 0; nbytes -= 4)\n\t\t*dest32++ = swab32(*src32++);\n}\n\nstatic int cs35l56_sdw_write_one(struct sdw_slave *peripheral, unsigned int reg, const void *buf)\n{\n\tu32 val_le = swab32(*(u32 *)buf);\n\tint ret;\n\n\tret = sdw_nwrite_no_pm(peripheral, reg, 4, (u8 *)&val_le);\n\tif (ret != 0) {\n\t\tdev_err(&peripheral->dev, \"Write failed @%#x:%d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_gather_write(void *context,\n\t\t\t\t    const void *reg_buf, size_t reg_size,\n\t\t\t\t    const void *val_buf, size_t val_size)\n{\n\tstruct sdw_slave *peripheral = context;\n\tconst u8 *src_be = val_buf;\n\tu32 val_le_buf[64];\t \n\tunsigned int reg, bytes;\n\tint ret;\n\n\treg = le32_to_cpu(*(const __le32 *)reg_buf);\n\treg += CS35L56_SDW_ADDR_OFFSET;\n\n\tif (val_size == 4)\n\t\treturn cs35l56_sdw_write_one(peripheral, reg, src_be);\n\n\twhile (val_size) {\n\t\tbytes = SDW_REG_NO_PAGE - (reg & SDW_REGADDR);  \n\t\tif (bytes > val_size)\n\t\t\tbytes = val_size;\n\t\tif (bytes > sizeof(val_le_buf))\n\t\t\tbytes = sizeof(val_le_buf);\n\n\t\tcs35l56_swab_copy(val_le_buf, src_be, bytes);\n\n\t\tret = sdw_nwrite_no_pm(peripheral, reg, bytes, (u8 *)val_le_buf);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&peripheral->dev, \"Write failed @%#x..%#x:%d\\n\",\n\t\t\t\treg, reg + bytes - 1, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tval_size -= bytes;\n\t\treg += bytes;\n\t\tsrc_be += bytes;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_write(void *context, const void *val_buf, size_t val_size)\n{\n\tconst u8 *src_buf = val_buf;\n\n\t \n\treturn cs35l56_sdw_gather_write(context, &src_buf[0], 4, &src_buf[4], val_size - 4);\n}\n\n \nstatic const struct regmap_bus cs35l56_regmap_bus_sdw = {\n\t.read = cs35l56_sdw_read,\n\t.write = cs35l56_sdw_write,\n\t.gather_write = cs35l56_sdw_gather_write,\n\t.reg_format_endian_default = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic void cs35l56_sdw_init(struct sdw_slave *peripheral)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\tint ret;\n\n\tpm_runtime_get_noresume(cs35l56->base.dev);\n\n\tregcache_cache_only(cs35l56->base.regmap, false);\n\n\tret = cs35l56_init(cs35l56);\n\tif (ret < 0) {\n\t\tregcache_cache_only(cs35l56->base.regmap, true);\n\t\tgoto out;\n\t}\n\n\t \n\tif (cs35l56->base.init_done) {\n\t\t \n\t\tsdw_write_no_pm(peripheral, CS35L56_SDW_GEN_INT_MASK_1,\n\t\t\t\tCS35L56_SDW_INT_MASK_CODEC_IRQ);\n\t}\n\nout:\n\tpm_runtime_mark_last_busy(cs35l56->base.dev);\n\tpm_runtime_put_autosuspend(cs35l56->base.dev);\n}\n\nstatic int cs35l56_sdw_interrupt(struct sdw_slave *peripheral,\n\t\t\t\t struct sdw_slave_intr_status *status)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\n\t \n\n\tdev_dbg(cs35l56->base.dev, \"int control_port=%#x\\n\", status->control_port);\n\n\tif ((status->control_port & SDW_SCP_INT1_IMPL_DEF) == 0)\n\t\treturn 0;\n\n\t \n\tpm_runtime_get_noresume(cs35l56->base.dev);\n\n\t \n\tsdw_write_no_pm(peripheral, CS35L56_SDW_GEN_INT_MASK_1, 0);\n\tsdw_read_no_pm(peripheral, CS35L56_SDW_GEN_INT_STAT_1);\n\tsdw_write_no_pm(peripheral, CS35L56_SDW_GEN_INT_STAT_1, 0xFF);\n\tqueue_work(system_power_efficient_wq, &cs35l56->sdw_irq_work);\n\n\treturn 0;\n}\n\nstatic void cs35l56_sdw_irq_work(struct work_struct *work)\n{\n\tstruct cs35l56_private *cs35l56 = container_of(work,\n\t\t\t\t\t\t       struct cs35l56_private,\n\t\t\t\t\t\t       sdw_irq_work);\n\n\tcs35l56_irq(-1, &cs35l56->base);\n\n\t \n\tif (!cs35l56->sdw_irq_no_unmask)\n\t\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_MASK_1,\n\t\t\t\tCS35L56_SDW_INT_MASK_CODEC_IRQ);\n\n\tpm_runtime_put_autosuspend(cs35l56->base.dev);\n}\n\nstatic int cs35l56_sdw_read_prop(struct sdw_slave *peripheral)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\tstruct sdw_slave_prop *prop = &peripheral->prop;\n\tstruct sdw_dpn_prop *ports;\n\n\tports = devm_kcalloc(cs35l56->base.dev, 2, sizeof(*ports), GFP_KERNEL);\n\tif (!ports)\n\t\treturn -ENOMEM;\n\n\tprop->source_ports = BIT(CS35L56_SDW1_CAPTURE_PORT);\n\tprop->sink_ports = BIT(CS35L56_SDW1_PLAYBACK_PORT);\n\tprop->paging_support = true;\n\tprop->clk_stop_mode1 = false;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY | SDW_SCP_INT1_IMPL_DEF;\n\n\t \n\tports[0].num = CS35L56_SDW1_PLAYBACK_PORT;\n\tports[0].type = SDW_DPN_FULL;\n\tports[0].ch_prep_timeout = 10;\n\tprop->sink_dpn_prop = &ports[0];\n\n\t \n\tports[1].num = CS35L56_SDW1_CAPTURE_PORT;\n\tports[1].type = SDW_DPN_FULL;\n\tports[1].ch_prep_timeout = 10;\n\tprop->src_dpn_prop = &ports[1];\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_update_status(struct sdw_slave *peripheral,\n\t\t\t\t     enum sdw_slave_status status)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\n\tswitch (status) {\n\tcase SDW_SLAVE_ATTACHED:\n\t\tdev_dbg(cs35l56->base.dev, \"%s: ATTACHED\\n\", __func__);\n\t\tif (cs35l56->sdw_attached)\n\t\t\tbreak;\n\n\t\tif (!cs35l56->base.init_done || cs35l56->soft_resetting)\n\t\t\tcs35l56_sdw_init(peripheral);\n\n\t\tcs35l56->sdw_attached = true;\n\t\tbreak;\n\tcase SDW_SLAVE_UNATTACHED:\n\t\tdev_dbg(cs35l56->base.dev, \"%s: UNATTACHED\\n\", __func__);\n\t\tcs35l56->sdw_attached = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_a1_kick_divider(struct cs35l56_private *cs35l56,\n\t\t\t\t   struct sdw_slave *peripheral)\n{\n\tunsigned int curr_scale_reg, next_scale_reg;\n\tint curr_scale, next_scale, ret;\n\n\tif (!cs35l56->base.init_done)\n\t\treturn 0;\n\n\tif (peripheral->bus->params.curr_bank) {\n\t\tcurr_scale_reg = SDW_SCP_BUSCLOCK_SCALE_B1;\n\t\tnext_scale_reg = SDW_SCP_BUSCLOCK_SCALE_B0;\n\t} else {\n\t\tcurr_scale_reg = SDW_SCP_BUSCLOCK_SCALE_B0;\n\t\tnext_scale_reg = SDW_SCP_BUSCLOCK_SCALE_B1;\n\t}\n\n\t \n\tcurr_scale = sdw_read_no_pm(peripheral, curr_scale_reg);\n\tif (curr_scale < 0) {\n\t\tdev_err(cs35l56->base.dev, \"Failed to read current clock scale: %d\\n\", curr_scale);\n\t\treturn curr_scale;\n\t}\n\n\tnext_scale = sdw_read_no_pm(peripheral, next_scale_reg);\n\tif (next_scale < 0) {\n\t\tdev_err(cs35l56->base.dev, \"Failed to read next clock scale: %d\\n\", next_scale);\n\t\treturn next_scale;\n\t}\n\n\tif (next_scale == CS35L56_SDW_INVALID_BUS_SCALE) {\n\t\tnext_scale = cs35l56->old_sdw_clock_scale;\n\t\tret = sdw_write_no_pm(peripheral, next_scale_reg, next_scale);\n\t\tif (ret < 0) {\n\t\t\tdev_err(cs35l56->base.dev, \"Failed to modify current clock scale: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcs35l56->old_sdw_clock_scale = curr_scale;\n\tret = sdw_write_no_pm(peripheral, curr_scale_reg, CS35L56_SDW_INVALID_BUS_SCALE);\n\tif (ret < 0) {\n\t\tdev_err(cs35l56->base.dev, \"Failed to modify current clock scale: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(cs35l56->base.dev, \"Next bus scale: %#x\\n\", next_scale);\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_bus_config(struct sdw_slave *peripheral,\n\t\t\t\t  struct sdw_bus_params *params)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\tint sclk;\n\n\tsclk = params->curr_dr_freq / 2;\n\tdev_dbg(cs35l56->base.dev, \"%s: sclk=%u c=%u r=%u\\n\",\n\t\t__func__, sclk, params->col, params->row);\n\n\tif (cs35l56->base.rev < 0xb0)\n\t\treturn cs35l56_a1_kick_divider(cs35l56, peripheral);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l56_sdw_clk_stop(struct sdw_slave *peripheral,\n\t\t\t\t\t       enum sdw_clk_stop_mode mode,\n\t\t\t\t\t       enum sdw_clk_stop_type type)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\n\tdev_dbg(cs35l56->base.dev, \"%s: mode:%d type:%d\\n\", __func__, mode, type);\n\n\treturn 0;\n}\n\nstatic const struct sdw_slave_ops cs35l56_sdw_ops = {\n\t.read_prop = cs35l56_sdw_read_prop,\n\t.interrupt_callback = cs35l56_sdw_interrupt,\n\t.update_status = cs35l56_sdw_update_status,\n\t.bus_config = cs35l56_sdw_bus_config,\n#ifdef DEBUG\n\t.clk_stop = cs35l56_sdw_clk_stop,\n#endif\n};\n\nstatic int __maybe_unused cs35l56_sdw_handle_unattach(struct cs35l56_private *cs35l56)\n{\n\tstruct sdw_slave *peripheral = cs35l56->sdw_peripheral;\n\n\tif (peripheral->unattach_request) {\n\t\t \n\t\tdev_dbg(cs35l56->base.dev, \"Wait for initialization_complete\\n\");\n\t\tif (!wait_for_completion_timeout(&peripheral->initialization_complete,\n\t\t\t\t\t\t msecs_to_jiffies(5000))) {\n\t\t\tdev_err(cs35l56->base.dev, \"initialization_complete timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tperipheral->unattach_request = 0;\n\n\t\t \n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l56_sdw_runtime_suspend(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tif (!cs35l56->base.init_done)\n\t\treturn 0;\n\n\treturn cs35l56_runtime_suspend_common(&cs35l56->base);\n}\n\nstatic int __maybe_unused cs35l56_sdw_runtime_resume(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"Runtime resume\\n\");\n\n\tif (!cs35l56->base.init_done)\n\t\treturn 0;\n\n\tret = cs35l56_sdw_handle_unattach(cs35l56);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = cs35l56_runtime_resume_common(&cs35l56->base, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_MASK_1,\n\t\t\tCS35L56_SDW_INT_MASK_CODEC_IRQ);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs35l56_sdw_system_suspend(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tif (!cs35l56->base.init_done)\n\t\treturn 0;\n\n\t \n\tcs35l56->sdw_irq_no_unmask = true;\n\tflush_work(&cs35l56->sdw_irq_work);\n\n\t \n\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_MASK_1, 0);\n\tsdw_read_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_STAT_1);\n\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_STAT_1, 0xFF);\n\tflush_work(&cs35l56->sdw_irq_work);\n\n\treturn cs35l56_system_suspend(dev);\n}\n\nstatic int __maybe_unused cs35l56_sdw_system_resume(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tcs35l56->sdw_irq_no_unmask = false;\n\t \n\n\treturn cs35l56_system_resume(dev);\n}\n\nstatic int cs35l56_sdw_probe(struct sdw_slave *peripheral, const struct sdw_device_id *id)\n{\n\tstruct device *dev = &peripheral->dev;\n\tstruct cs35l56_private *cs35l56;\n\tint ret;\n\n\tcs35l56 = devm_kzalloc(dev, sizeof(*cs35l56), GFP_KERNEL);\n\tif (!cs35l56)\n\t\treturn -ENOMEM;\n\n\tcs35l56->base.dev = dev;\n\tcs35l56->sdw_peripheral = peripheral;\n\tINIT_WORK(&cs35l56->sdw_irq_work, cs35l56_sdw_irq_work);\n\n\tdev_set_drvdata(dev, cs35l56);\n\n\tcs35l56->base.regmap = devm_regmap_init(dev, &cs35l56_regmap_bus_sdw,\n\t\t\t\t\t   peripheral, &cs35l56_regmap_sdw);\n\tif (IS_ERR(cs35l56->base.regmap)) {\n\t\tret = PTR_ERR(cs35l56->base.regmap);\n\t\treturn dev_err_probe(dev, ret, \"Failed to allocate register map\\n\");\n\t}\n\n\t \n\tregcache_cache_only(cs35l56->base.regmap, true);\n\n\tret = cs35l56_common_probe(cs35l56);\n\tif (ret != 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_remove(struct sdw_slave *peripheral)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(&peripheral->dev);\n\n\t \n\tcs35l56->sdw_irq_no_unmask = true;\n\tcancel_work_sync(&cs35l56->sdw_irq_work);\n\tsdw_write_no_pm(peripheral, CS35L56_SDW_GEN_INT_MASK_1, 0);\n\tsdw_read_no_pm(peripheral, CS35L56_SDW_GEN_INT_STAT_1);\n\tsdw_write_no_pm(peripheral, CS35L56_SDW_GEN_INT_STAT_1, 0xFF);\n\n\tcs35l56_remove(cs35l56);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cs35l56_sdw_pm = {\n\tSET_RUNTIME_PM_OPS(cs35l56_sdw_runtime_suspend, cs35l56_sdw_runtime_resume, NULL)\n\tSYSTEM_SLEEP_PM_OPS(cs35l56_sdw_system_suspend, cs35l56_sdw_system_resume)\n\tLATE_SYSTEM_SLEEP_PM_OPS(cs35l56_system_suspend_late, cs35l56_system_resume_early)\n\t \n};\n\nstatic const struct sdw_device_id cs35l56_sdw_id[] = {\n\tSDW_SLAVE_ENTRY(0x01FA, 0x3556, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, cs35l56_sdw_id);\n\nstatic struct sdw_driver cs35l56_sdw_driver = {\n\t.driver = {\n\t\t.name = \"cs35l56\",\n\t\t.pm = &cs35l56_sdw_pm,\n\t},\n\t.probe = cs35l56_sdw_probe,\n\t.remove = cs35l56_sdw_remove,\n\t.ops = &cs35l56_sdw_ops,\n\t.id_table = cs35l56_sdw_id,\n};\n\nmodule_sdw_driver(cs35l56_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS35L56 SoundWire driver\");\nMODULE_IMPORT_NS(SND_SOC_CS35L56_CORE);\nMODULE_IMPORT_NS(SND_SOC_CS35L56_SHARED);\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Simon Trimmer <simont@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}