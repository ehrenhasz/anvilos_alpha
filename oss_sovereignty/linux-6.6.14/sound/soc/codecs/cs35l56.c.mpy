{
  "module_name": "cs35l56.c",
  "hash_id": "c18c47c5d62bda5a255c040aa7b89de2dbaf7a27165bfebb8c39acc882f9922d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs35l56.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/math.h>\n#include <linux/module.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/types.h>\n#include <linux/workqueue.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"wm_adsp.h\"\n#include \"cs35l56.h\"\n\nstatic int cs35l56_dsp_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event);\n\nstatic void cs35l56_wait_dsp_ready(struct cs35l56_private *cs35l56)\n{\n\t \n\tflush_work(&cs35l56->dsp_work);\n}\n\nstatic int cs35l56_dspwait_get_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\n\tcs35l56_wait_dsp_ready(cs35l56);\n\treturn snd_soc_get_volsw(kcontrol, ucontrol);\n}\n\nstatic int cs35l56_dspwait_put_volsw(struct snd_kcontrol *kcontrol,\n\t\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\n\tcs35l56_wait_dsp_ready(cs35l56);\n\treturn snd_soc_put_volsw(kcontrol, ucontrol);\n}\n\nstatic DECLARE_TLV_DB_SCALE(vol_tlv, -10000, 25, 0);\n\nstatic const struct snd_kcontrol_new cs35l56_controls[] = {\n\tSOC_SINGLE_EXT(\"Speaker Switch\",\n\t\t       CS35L56_MAIN_RENDER_USER_MUTE, 0, 1, 1,\n\t\t       cs35l56_dspwait_get_volsw, cs35l56_dspwait_put_volsw),\n\tSOC_SINGLE_S_EXT_TLV(\"Speaker Volume\",\n\t\t\t     CS35L56_MAIN_RENDER_USER_VOLUME,\n\t\t\t     6, -400, 400, 9, 0,\n\t\t\t     cs35l56_dspwait_get_volsw,\n\t\t\t     cs35l56_dspwait_put_volsw,\n\t\t\t     vol_tlv),\n\tSOC_SINGLE_EXT(\"Posture Number\", CS35L56_MAIN_POSTURE_NUMBER,\n\t\t       0, 255, 0,\n\t\t       cs35l56_dspwait_get_volsw, cs35l56_dspwait_put_volsw),\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_asp1tx1_enum,\n\t\t\t\t  CS35L56_ASP1TX1_INPUT,\n\t\t\t\t  0, CS35L56_ASP_TXn_SRC_MASK,\n\t\t\t\t  cs35l56_tx_input_texts,\n\t\t\t\t  cs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp1_tx1_mux =\n\tSOC_DAPM_ENUM(\"ASP1TX1 SRC\", cs35l56_asp1tx1_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_asp1tx2_enum,\n\t\t\t\t  CS35L56_ASP1TX2_INPUT,\n\t\t\t\t  0, CS35L56_ASP_TXn_SRC_MASK,\n\t\t\t\t  cs35l56_tx_input_texts,\n\t\t\t\t  cs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp1_tx2_mux =\n\tSOC_DAPM_ENUM(\"ASP1TX2 SRC\", cs35l56_asp1tx2_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_asp1tx3_enum,\n\t\t\t\t  CS35L56_ASP1TX3_INPUT,\n\t\t\t\t  0, CS35L56_ASP_TXn_SRC_MASK,\n\t\t\t\t  cs35l56_tx_input_texts,\n\t\t\t\t  cs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp1_tx3_mux =\n\tSOC_DAPM_ENUM(\"ASP1TX3 SRC\", cs35l56_asp1tx3_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_asp1tx4_enum,\n\t\t\t\t  CS35L56_ASP1TX4_INPUT,\n\t\t\t\t  0, CS35L56_ASP_TXn_SRC_MASK,\n\t\t\t\t  cs35l56_tx_input_texts,\n\t\t\t\t  cs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new asp1_tx4_mux =\n\tSOC_DAPM_ENUM(\"ASP1TX4 SRC\", cs35l56_asp1tx4_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_sdw1tx1_enum,\n\t\t\t\tCS35L56_SWIRE_DP3_CH1_INPUT,\n\t\t\t\t0, CS35L56_SWIRETXn_SRC_MASK,\n\t\t\t\tcs35l56_tx_input_texts,\n\t\t\t\tcs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new sdw1_tx1_mux =\n\tSOC_DAPM_ENUM(\"SDW1TX1 SRC\", cs35l56_sdw1tx1_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_sdw1tx2_enum,\n\t\t\t\tCS35L56_SWIRE_DP3_CH2_INPUT,\n\t\t\t\t0, CS35L56_SWIRETXn_SRC_MASK,\n\t\t\t\tcs35l56_tx_input_texts,\n\t\t\t\tcs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new sdw1_tx2_mux =\n\tSOC_DAPM_ENUM(\"SDW1TX2 SRC\", cs35l56_sdw1tx2_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_sdw1tx3_enum,\n\t\t\t\tCS35L56_SWIRE_DP3_CH3_INPUT,\n\t\t\t\t0, CS35L56_SWIRETXn_SRC_MASK,\n\t\t\t\tcs35l56_tx_input_texts,\n\t\t\t\tcs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new sdw1_tx3_mux =\n\tSOC_DAPM_ENUM(\"SDW1TX3 SRC\", cs35l56_sdw1tx3_enum);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(cs35l56_sdw1tx4_enum,\n\t\t\t\tCS35L56_SWIRE_DP3_CH4_INPUT,\n\t\t\t\t0, CS35L56_SWIRETXn_SRC_MASK,\n\t\t\t\tcs35l56_tx_input_texts,\n\t\t\t\tcs35l56_tx_input_values);\n\nstatic const struct snd_kcontrol_new sdw1_tx4_mux =\n\tSOC_DAPM_ENUM(\"SDW1TX4 SRC\", cs35l56_sdw1tx4_enum);\n\nstatic int cs35l56_play_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\tint ret;\n\n\tdev_dbg(cs35l56->base.dev, \"play: %d\\n\", event);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\treturn regmap_write(cs35l56->base.regmap, CS35L56_DSP_VIRTUAL1_MBOX_1,\n\t\t\t\t    CS35L56_MBOX_CMD_AUDIO_PLAY);\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tret = regmap_read_poll_timeout(cs35l56->base.regmap,\n\t\t\t\t\t       CS35L56_TRANSDUCER_ACTUAL_PS,\n\t\t\t\t\t       val, (val == CS35L56_PS0),\n\t\t\t\t\t       CS35L56_PS0_POLL_US,\n\t\t\t\t\t       CS35L56_PS0_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tdev_err(cs35l56->base.dev, \"PS0 wait failed: %d\\n\", ret);\n\t\treturn ret;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\treturn cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_AUDIO_PAUSE);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct snd_soc_dapm_widget cs35l56_dapm_widgets[] = {\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDD_B\", 0, 0),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"VDD_AMP\", 0, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"PLAY\", SND_SOC_NOPM, 0, 0, cs35l56_play_event,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_OUT_DRV(\"AMP\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\n\tSND_SOC_DAPM_PGA_E(\"DSP1\", SND_SOC_NOPM, 0, 0, NULL, 0, cs35l56_dsp_event,\n\t\t\t   SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_AIF_IN(\"ASP1RX1\", NULL, 0, CS35L56_ASP1_ENABLES1,\n\t\t\t    CS35L56_ASP_RX1_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_IN(\"ASP1RX2\", NULL, 1, CS35L56_ASP1_ENABLES1,\n\t\t\t    CS35L56_ASP_RX2_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP1TX1\", NULL, 0, CS35L56_ASP1_ENABLES1,\n\t\t\t     CS35L56_ASP_TX1_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP1TX2\", NULL, 1, CS35L56_ASP1_ENABLES1,\n\t\t\t     CS35L56_ASP_TX2_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP1TX3\", NULL, 2, CS35L56_ASP1_ENABLES1,\n\t\t\t     CS35L56_ASP_TX3_EN_SHIFT, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP1TX4\", NULL, 3, CS35L56_ASP1_ENABLES1,\n\t\t\t     CS35L56_ASP_TX4_EN_SHIFT, 0),\n\n\tSND_SOC_DAPM_MUX(\"ASP1 TX1 Source\", SND_SOC_NOPM, 0, 0, &asp1_tx1_mux),\n\tSND_SOC_DAPM_MUX(\"ASP1 TX2 Source\", SND_SOC_NOPM, 0, 0, &asp1_tx2_mux),\n\tSND_SOC_DAPM_MUX(\"ASP1 TX3 Source\", SND_SOC_NOPM, 0, 0, &asp1_tx3_mux),\n\tSND_SOC_DAPM_MUX(\"ASP1 TX4 Source\", SND_SOC_NOPM, 0, 0, &asp1_tx4_mux),\n\n\tSND_SOC_DAPM_MUX(\"SDW1 TX1 Source\", SND_SOC_NOPM, 0, 0, &sdw1_tx1_mux),\n\tSND_SOC_DAPM_MUX(\"SDW1 TX2 Source\", SND_SOC_NOPM, 0, 0, &sdw1_tx2_mux),\n\tSND_SOC_DAPM_MUX(\"SDW1 TX3 Source\", SND_SOC_NOPM, 0, 0, &sdw1_tx3_mux),\n\tSND_SOC_DAPM_MUX(\"SDW1 TX4 Source\", SND_SOC_NOPM, 0, 0, &sdw1_tx4_mux),\n\n\tSND_SOC_DAPM_SIGGEN(\"VMON ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"IMON ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"ERRVOL ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"CLASSH ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"VDDBMON ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"VBSTMON ADC\"),\n\tSND_SOC_DAPM_SIGGEN(\"TEMPMON ADC\"),\n};\n\n#define CS35L56_SRC_ROUTE(name) \\\n\t{ name\" Source\", \"ASP1RX1\", \"ASP1RX1\" }, \\\n\t{ name\" Source\", \"ASP1RX2\", \"ASP1RX2\" }, \\\n\t{ name\" Source\", \"VMON\", \"VMON ADC\" }, \\\n\t{ name\" Source\", \"IMON\", \"IMON ADC\" }, \\\n\t{ name\" Source\", \"ERRVOL\", \"ERRVOL ADC\" },   \\\n\t{ name\" Source\", \"CLASSH\", \"CLASSH ADC\" },   \\\n\t{ name\" Source\", \"VDDBMON\", \"VDDBMON ADC\" }, \\\n\t{ name\" Source\", \"VBSTMON\", \"VBSTMON ADC\" }, \\\n\t{ name\" Source\", \"DSP1TX1\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX2\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX3\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX4\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX5\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX6\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX7\", \"DSP1\" }, \\\n\t{ name\" Source\", \"DSP1TX8\", \"DSP1\" }, \\\n\t{ name\" Source\", \"TEMPMON\", \"TEMPMON ADC\" }, \\\n\t{ name\" Source\", \"INTERPOLATOR\", \"AMP\" }, \\\n\t{ name\" Source\", \"SDW1RX1\", \"SDW1 Playback\" }, \\\n\t{ name\" Source\", \"SDW1RX2\", \"SDW1 Playback\" },\n\nstatic const struct snd_soc_dapm_route cs35l56_audio_map[] = {\n\t{ \"AMP\", NULL, \"VDD_B\" },\n\t{ \"AMP\", NULL, \"VDD_AMP\" },\n\n\t{ \"ASP1 Playback\", NULL, \"PLAY\" },\n\t{ \"SDW1 Playback\", NULL, \"PLAY\" },\n\n\t{ \"ASP1RX1\", NULL, \"ASP1 Playback\" },\n\t{ \"ASP1RX2\", NULL, \"ASP1 Playback\" },\n\t{ \"DSP1\", NULL, \"ASP1RX1\" },\n\t{ \"DSP1\", NULL, \"ASP1RX2\" },\n\t{ \"DSP1\", NULL, \"SDW1 Playback\" },\n\t{ \"AMP\", NULL, \"DSP1\" },\n\t{ \"SPK\", NULL, \"AMP\" },\n\n\tCS35L56_SRC_ROUTE(\"ASP1 TX1\")\n\tCS35L56_SRC_ROUTE(\"ASP1 TX2\")\n\tCS35L56_SRC_ROUTE(\"ASP1 TX3\")\n\tCS35L56_SRC_ROUTE(\"ASP1 TX4\")\n\n\t{ \"ASP1TX1\", NULL, \"ASP1 TX1 Source\" },\n\t{ \"ASP1TX2\", NULL, \"ASP1 TX2 Source\" },\n\t{ \"ASP1TX3\", NULL, \"ASP1 TX3 Source\" },\n\t{ \"ASP1TX4\", NULL, \"ASP1 TX4 Source\" },\n\t{ \"ASP1 Capture\", NULL, \"ASP1TX1\" },\n\t{ \"ASP1 Capture\", NULL, \"ASP1TX2\" },\n\t{ \"ASP1 Capture\", NULL, \"ASP1TX3\" },\n\t{ \"ASP1 Capture\", NULL, \"ASP1TX4\" },\n\n\tCS35L56_SRC_ROUTE(\"SDW1 TX1\")\n\tCS35L56_SRC_ROUTE(\"SDW1 TX2\")\n\tCS35L56_SRC_ROUTE(\"SDW1 TX3\")\n\tCS35L56_SRC_ROUTE(\"SDW1 TX4\")\n\t{ \"SDW1 Capture\", NULL, \"SDW1 TX1 Source\" },\n\t{ \"SDW1 Capture\", NULL, \"SDW1 TX2 Source\" },\n\t{ \"SDW1 Capture\", NULL, \"SDW1 TX3 Source\" },\n\t{ \"SDW1 Capture\", NULL, \"SDW1 TX4 Source\" },\n};\n\nstatic int cs35l56_dsp_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(cs35l56->base.dev, \"%s: %d\\n\", __func__, event);\n\n\treturn wm_adsp_event(w, kcontrol, event);\n}\n\nstatic int cs35l56_asp_dai_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(codec_dai->component);\n\tunsigned int val;\n\n\tdev_dbg(cs35l56->base.dev, \"%s: %#x\\n\", __func__, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l56->base.dev, \"Unsupported clock source mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tval = CS35L56_ASP_FMT_DSP_A << CS35L56_ASP_FMT_SHIFT;\n\t\tcs35l56->tdm_mode = true;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval = CS35L56_ASP_FMT_I2S << CS35L56_ASP_FMT_SHIFT;\n\t\tcs35l56->tdm_mode = false;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l56->base.dev, \"Unsupported DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tval |= CS35L56_ASP_FSYNC_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tval |= CS35L56_ASP_BCLK_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tval |= CS35L56_ASP_BCLK_INV_MASK | CS35L56_ASP_FSYNC_INV_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cs35l56->base.dev, \"Invalid clock invert\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(cs35l56->base.regmap,\n\t\t\t   CS35L56_ASP1_CONTROL2,\n\t\t\t   CS35L56_ASP_FMT_MASK |\n\t\t\t   CS35L56_ASP_BCLK_INV_MASK | CS35L56_ASP_FSYNC_INV_MASK,\n\t\t\t   val);\n\n\t \n\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL3,\n\t\t\t   CS35L56_ASP1_DOUT_HIZ_CTRL_MASK,\n\t\t\t   CS35L56_ASP_UNUSED_HIZ_OFF_HIZ);\n\n\treturn 0;\n}\n\nstatic unsigned int cs35l56_make_tdm_config_word(unsigned int reg_val, unsigned long mask)\n{\n\tunsigned int channel_shift;\n\tint bit_num;\n\n\t \n\tchannel_shift = 0;\n\tfor_each_set_bit(bit_num, &mask, 32) {\n\t\treg_val &= ~(0x3f << channel_shift);\n\t\treg_val |= bit_num << channel_shift;\n\t\tchannel_shift += 8;\n\t}\n\n\treturn reg_val;\n}\n\nstatic int cs35l56_asp_dai_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\n\tif ((slots == 0) || (slot_width == 0)) {\n\t\tdev_dbg(cs35l56->base.dev, \"tdm config cleared\\n\");\n\t\tcs35l56->asp_slot_width = 0;\n\t\tcs35l56->asp_slot_count = 0;\n\t\treturn 0;\n\t}\n\n\tif (slot_width > (CS35L56_ASP_RX_WIDTH_MASK >> CS35L56_ASP_RX_WIDTH_SHIFT)) {\n\t\tdev_err(cs35l56->base.dev, \"tdm invalid slot width %d\\n\", slot_width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (slots > 32) {\n\t\tdev_err(cs35l56->base.dev, \"tdm invalid slot count %d\\n\", slots);\n\t\treturn -EINVAL;\n\t}\n\n\tcs35l56->asp_slot_width = (u8)slot_width;\n\tcs35l56->asp_slot_count = (u8)slots;\n\n\t\n\tif (tx_mask == 0)\n\t\ttx_mask = 0x3;\t\n\n\tif (rx_mask == 0)\n\t\trx_mask = 0xf;\t\n\n\t \n\tregmap_write(cs35l56->base.regmap, CS35L56_ASP1_FRAME_CONTROL1,\n\t\t     cs35l56_make_tdm_config_word(0x3f3f3f3f, rx_mask));\n\tregmap_write(cs35l56->base.regmap, CS35L56_ASP1_FRAME_CONTROL5,\n\t\t     cs35l56_make_tdm_config_word(0x3f3f3f, tx_mask));\n\n\tdev_dbg(cs35l56->base.dev, \"tdm slot width: %u count: %u tx_mask: %#x rx_mask: %#x\\n\",\n\t\tcs35l56->asp_slot_width, cs35l56->asp_slot_count, tx_mask, rx_mask);\n\n\treturn 0;\n}\n\nstatic int cs35l56_asp_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int rate = params_rate(params);\n\tu8 asp_width, asp_wl;\n\n\tasp_wl = params_width(params);\n\tif (cs35l56->asp_slot_width)\n\t\tasp_width = cs35l56->asp_slot_width;\n\telse\n\t\tasp_width = asp_wl;\n\n\tdev_dbg(cs35l56->base.dev, \"%s: wl=%d, width=%d, rate=%d\",\n\t\t__func__, asp_wl, asp_width, rate);\n\n\tif (!cs35l56->sysclk_set) {\n\t\tunsigned int slots = cs35l56->asp_slot_count;\n\t\tunsigned int bclk_freq;\n\t\tint freq_id;\n\n\t\tif (slots == 0) {\n\t\t\tslots = params_channels(params);\n\n\t\t\t \n\t\t\tif (!cs35l56->tdm_mode)\n\t\t\t\tslots = round_up(slots, 2);\n\t\t}\n\n\t\tbclk_freq = asp_width * slots * rate;\n\t\tfreq_id = cs35l56_get_bclk_freq_id(bclk_freq);\n\t\tif (freq_id < 0) {\n\t\t\tdev_err(cs35l56->base.dev, \"%s: Invalid BCLK %u\\n\", __func__, bclk_freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL1,\n\t\t\t\t   CS35L56_ASP_BCLK_FREQ_MASK,\n\t\t\t\t   freq_id << CS35L56_ASP_BCLK_FREQ_SHIFT);\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL2,\n\t\t\t\t   CS35L56_ASP_RX_WIDTH_MASK, asp_width <<\n\t\t\t\t   CS35L56_ASP_RX_WIDTH_SHIFT);\n\t\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_DATA_CONTROL5,\n\t\t\t\t   CS35L56_ASP_RX_WL_MASK, asp_wl);\n\t} else {\n\t\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL2,\n\t\t\t\t   CS35L56_ASP_TX_WIDTH_MASK, asp_width <<\n\t\t\t\t   CS35L56_ASP_TX_WIDTH_SHIFT);\n\t\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_DATA_CONTROL1,\n\t\t\t\t   CS35L56_ASP_TX_WL_MASK, asp_wl);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_asp_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t      int clk_id, unsigned int freq, int dir)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\tint freq_id;\n\n\tif (freq == 0) {\n\t\tcs35l56->sysclk_set = false;\n\t\treturn 0;\n\t}\n\n\tfreq_id = cs35l56_get_bclk_freq_id(freq);\n\tif (freq_id < 0)\n\t\treturn freq_id;\n\n\tregmap_update_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL1,\n\t\t\t   CS35L56_ASP_BCLK_FREQ_MASK,\n\t\t\t   freq_id << CS35L56_ASP_BCLK_FREQ_SHIFT);\n\tcs35l56->sysclk_set = true;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l56_ops = {\n\t.set_fmt = cs35l56_asp_dai_set_fmt,\n\t.set_tdm_slot = cs35l56_asp_dai_set_tdm_slot,\n\t.hw_params = cs35l56_asp_dai_hw_params,\n\t.set_sysclk = cs35l56_asp_dai_set_sysclk,\n};\n\nstatic void cs35l56_sdw_dai_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int cs35l56_sdw_dai_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t\tunsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\n\t \n\tcs35l56->rx_mask = tx_mask;\n\tcs35l56->tx_mask = rx_mask;\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t     struct snd_pcm_hw_params *params,\n\t\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\tstruct sdw_stream_config sconfig;\n\tstruct sdw_port_config pconfig;\n\tint ret;\n\n\tdev_dbg(cs35l56->base.dev, \"%s: rate %d\\n\", __func__, params_rate(params));\n\n\tif (!cs35l56->base.init_done)\n\t\treturn -ENODEV;\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tmemset(&sconfig, 0, sizeof(sconfig));\n\tmemset(&pconfig, 0, sizeof(pconfig));\n\n\tsconfig.frame_rate = params_rate(params);\n\tsconfig.bps = snd_pcm_format_width(params_format(params));\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tsconfig.direction = SDW_DATA_DIR_RX;\n\t\tpconfig.num = CS35L56_SDW1_PLAYBACK_PORT;\n\t\tpconfig.ch_mask = cs35l56->rx_mask;\n\t} else {\n\t\tsconfig.direction = SDW_DATA_DIR_TX;\n\t\tpconfig.num = CS35L56_SDW1_CAPTURE_PORT;\n\t\tpconfig.ch_mask = cs35l56->tx_mask;\n\t}\n\n\tif (pconfig.ch_mask == 0) {\n\t\tsconfig.ch_count = params_channels(params);\n\t\tpconfig.ch_mask = GENMASK(sconfig.ch_count - 1, 0);\n\t} else {\n\t\tsconfig.ch_count = hweight32(pconfig.ch_mask);\n\t}\n\n\tret = sdw_stream_add_slave(cs35l56->sdw_peripheral, &sconfig, &pconfig,\n\t\t\t\t   1, sdw_stream);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Failed to add sdw stream: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(dai->component);\n\tstruct sdw_stream_runtime *sdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!cs35l56->sdw_peripheral)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(cs35l56->sdw_peripheral, sdw_stream);\n\n\treturn 0;\n}\n\nstatic int cs35l56_sdw_dai_set_stream(struct snd_soc_dai *dai,\n\t\t\t\t      void *sdw_stream, int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs35l56_sdw_dai_ops = {\n\t.set_tdm_slot = cs35l56_sdw_dai_set_tdm_slot,\n\t.shutdown = cs35l56_sdw_dai_shutdown,\n\t.hw_params = cs35l56_sdw_dai_hw_params,\n\t.hw_free = cs35l56_sdw_dai_hw_free,\n\t.set_stream = cs35l56_sdw_dai_set_stream,\n};\n\nstatic struct snd_soc_dai_driver cs35l56_dai[] = {\n\t{\n\t\t.name = \"cs35l56-asp1\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"ASP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS35L56_RATES,\n\t\t\t.formats = CS35L56_RX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"ASP1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = CS35L56_RATES,\n\t\t\t.formats = CS35L56_TX_FORMATS,\n\t\t},\n\t\t.ops = &cs35l56_ops,\n\t\t.symmetric_rate = 1,\n\t\t.symmetric_sample_bits = 1,\n\t},\n\t{\n\t\t.name = \"cs35l56-sdw1\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"SDW1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = CS35L56_RATES,\n\t\t\t.formats = CS35L56_RX_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"SDW1 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = CS35L56_RATES,\n\t\t\t.formats = CS35L56_TX_FORMATS,\n\t\t},\n\t\t.symmetric_rate = 1,\n\t\t.ops = &cs35l56_sdw_dai_ops,\n\t}\n};\n\nstatic void cs35l56_secure_patch(struct cs35l56_private *cs35l56)\n{\n\tint ret;\n\n\t \n\tret = wm_adsp_power_up(&cs35l56->dsp, true);\n\tif (ret)\n\t\tdev_dbg(cs35l56->base.dev, \"%s: wm_adsp_power_up ret %d\\n\", __func__, ret);\n\telse\n\t\tcs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_AUDIO_REINIT);\n}\n\nstatic void cs35l56_patch(struct cs35l56_private *cs35l56)\n{\n\tunsigned int firmware_missing;\n\tint ret;\n\n\tret = regmap_read(cs35l56->base.regmap, CS35L56_PROTECTION_STATUS, &firmware_missing);\n\tif (ret) {\n\t\tdev_err(cs35l56->base.dev, \"Failed to read PROTECTION_STATUS: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tfirmware_missing &= CS35L56_FIRMWARE_MISSING;\n\n\t \n\tif (cs35l56->sdw_peripheral) {\n\t\tcs35l56->sdw_irq_no_unmask = true;\n\t\tflush_work(&cs35l56->sdw_irq_work);\n\t\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_MASK_1, 0);\n\t\tsdw_read_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_STAT_1);\n\t\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_STAT_1, 0xFF);\n\t\tflush_work(&cs35l56->sdw_irq_work);\n\t}\n\n\tret = cs35l56_firmware_shutdown(&cs35l56->base);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = wm_adsp_power_up(&cs35l56->dsp, !!firmware_missing);\n\tif (ret) {\n\t\tdev_dbg(cs35l56->base.dev, \"%s: wm_adsp_power_up ret %d\\n\", __func__, ret);\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&cs35l56->base.irq_lock);\n\n\treinit_completion(&cs35l56->init_completion);\n\n\tcs35l56->soft_resetting = true;\n\tcs35l56_system_reset(&cs35l56->base, !!cs35l56->sdw_peripheral);\n\n\tif (cs35l56->sdw_peripheral) {\n\t\t \n\t\tif (!wait_for_completion_timeout(&cs35l56->init_completion,\n\t\t\t\t\t\t msecs_to_jiffies(5000))) {\n\t\t\tdev_err(cs35l56->base.dev, \"%s: init_completion timed out (SDW)\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto err_unlock;\n\t\t}\n\t} else if (cs35l56_init(cs35l56)) {\n\t\tgoto err_unlock;\n\t}\n\n\tregmap_clear_bits(cs35l56->base.regmap, CS35L56_PROTECTION_STATUS,\n\t\t\t  CS35L56_FIRMWARE_MISSING);\n\tcs35l56->base.fw_patched = true;\n\nerr_unlock:\n\tmutex_unlock(&cs35l56->base.irq_lock);\nerr:\n\t \n\tif (cs35l56->sdw_peripheral) {\n\t\tcs35l56->sdw_irq_no_unmask = false;\n\t\tsdw_write_no_pm(cs35l56->sdw_peripheral, CS35L56_SDW_GEN_INT_MASK_1,\n\t\t\t\tCS35L56_SDW_INT_MASK_CODEC_IRQ);\n\t}\n}\n\nstatic void cs35l56_dsp_work(struct work_struct *work)\n{\n\tstruct cs35l56_private *cs35l56 = container_of(work,\n\t\t\t\t\t\t       struct cs35l56_private,\n\t\t\t\t\t\t       dsp_work);\n\n\tif (!cs35l56->base.init_done)\n\t\treturn;\n\n\tpm_runtime_get_sync(cs35l56->base.dev);\n\n\t \n\tif (cs35l56->base.secured)\n\t\tcs35l56_secure_patch(cs35l56);\n\telse\n\t\tcs35l56_patch(cs35l56);\n\n\tpm_runtime_mark_last_busy(cs35l56->base.dev);\n\tpm_runtime_put_autosuspend(cs35l56->base.dev);\n}\n\nstatic int cs35l56_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\tstruct dentry *debugfs_root = component->debugfs_root;\n\tunsigned short vendor, device;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs35l56_tx_input_texts) != ARRAY_SIZE(cs35l56_tx_input_values));\n\n\tif (!cs35l56->dsp.system_name &&\n\t    (snd_soc_card_get_pci_ssid(component->card, &vendor, &device) == 0)) {\n\t\tcs35l56->dsp.system_name = devm_kasprintf(cs35l56->base.dev,\n\t\t\t\t\t\t\t  GFP_KERNEL,\n\t\t\t\t\t\t\t  \"%04x%04x\",\n\t\t\t\t\t\t\t  vendor, device);\n\t\tif (!cs35l56->dsp.system_name)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!wait_for_completion_timeout(&cs35l56->init_completion,\n\t\t\t\t\t msecs_to_jiffies(5000))) {\n\t\tdev_err(cs35l56->base.dev, \"%s: init_completion timed out\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tcs35l56->component = component;\n\twm_adsp2_component_probe(&cs35l56->dsp, component);\n\n\tdebugfs_create_bool(\"init_done\", 0444, debugfs_root, &cs35l56->base.init_done);\n\tdebugfs_create_bool(\"can_hibernate\", 0444, debugfs_root, &cs35l56->base.can_hibernate);\n\tdebugfs_create_bool(\"fw_patched\", 0444, debugfs_root, &cs35l56->base.fw_patched);\n\n\tqueue_work(cs35l56->dsp_wq, &cs35l56->dsp_work);\n\n\treturn 0;\n}\n\nstatic void cs35l56_component_remove(struct snd_soc_component *component)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\n\tcancel_work_sync(&cs35l56->dsp_work);\n}\n\nstatic int cs35l56_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct cs35l56_private *cs35l56 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF)\n\t\t\tcs35l56_wait_dsp_ready(cs35l56);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs35l56 = {\n\t.probe = cs35l56_component_probe,\n\t.remove = cs35l56_component_remove,\n\n\t.dapm_widgets = cs35l56_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(cs35l56_dapm_widgets),\n\t.dapm_routes = cs35l56_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(cs35l56_audio_map),\n\t.controls = cs35l56_controls,\n\t.num_controls = ARRAY_SIZE(cs35l56_controls),\n\n\t.set_bias_level = cs35l56_set_bias_level,\n\n\t.suspend_bias_off = 1,  \n};\n\nstatic int __maybe_unused cs35l56_runtime_suspend_i2c_spi(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\treturn cs35l56_runtime_suspend_common(&cs35l56->base);\n}\n\nstatic int __maybe_unused cs35l56_runtime_resume_i2c_spi(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\treturn cs35l56_runtime_resume_common(&cs35l56->base, false);\n}\n\nint cs35l56_system_suspend(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"system_suspend\\n\");\n\n\tif (cs35l56->component)\n\t\tflush_work(&cs35l56->dsp_work);\n\n\t \n\tif (cs35l56->base.irq)\n\t\tdisable_irq(cs35l56->base.irq);\n\n\treturn pm_runtime_force_suspend(dev);\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_suspend);\n\nint cs35l56_system_suspend_late(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"system_suspend_late\\n\");\n\n\t \n\tif (cs35l56->base.reset_gpio) {\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\t}\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs35l56->supplies), cs35l56->supplies);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_suspend_late);\n\nint cs35l56_system_suspend_no_irq(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"system_suspend_no_irq\\n\");\n\n\t \n\tif (cs35l56->base.irq)\n\t\tenable_irq(cs35l56->base.irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_suspend_no_irq);\n\nint cs35l56_system_resume_no_irq(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"system_resume_no_irq\\n\");\n\n\t \n\tif (cs35l56->base.irq)\n\t\tdisable_irq(cs35l56->base.irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_resume_no_irq);\n\nint cs35l56_system_resume_early(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"system_resume_early\\n\");\n\n\t \n\tif (cs35l56->base.reset_gpio) {\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\t}\n\n\t \n\tret = regulator_bulk_enable(ARRAY_SIZE(cs35l56->supplies), cs35l56->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"system_resume_early failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_resume_early);\n\nint cs35l56_system_resume(struct device *dev)\n{\n\tstruct cs35l56_private *cs35l56 = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"system_resume\\n\");\n\n\t \n\tcs35l56_wait_control_port_ready();\n\n\t \n\tret = pm_runtime_force_resume(dev);\n\tif (cs35l56->base.irq)\n\t\tenable_irq(cs35l56->base.irq);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!cs35l56->component)\n\t\treturn 0;\n\n\tret = cs35l56_is_fw_reload_needed(&cs35l56->base);\n\tdev_dbg(cs35l56->base.dev, \"fw_reload_needed: %d\\n\", ret);\n\tif (ret < 1)\n\t\treturn ret;\n\n\tcs35l56->base.fw_patched = false;\n\twm_adsp_power_down(&cs35l56->dsp);\n\tqueue_work(cs35l56->dsp_wq, &cs35l56->dsp_work);\n\n\t \n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cs35l56_system_resume);\n\nstatic int cs35l56_dsp_init(struct cs35l56_private *cs35l56)\n{\n\tstruct wm_adsp *dsp;\n\tint ret;\n\n\tcs35l56->dsp_wq = create_singlethread_workqueue(\"cs35l56-dsp\");\n\tif (!cs35l56->dsp_wq)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&cs35l56->dsp_work, cs35l56_dsp_work);\n\n\tdsp = &cs35l56->dsp;\n\tcs35l56_init_cs_dsp(&cs35l56->base, &dsp->cs_dsp);\n\tdsp->part = \"cs35l56\";\n\tdsp->fw = 12;\n\tdsp->wmfw_optional = true;\n\n\tdev_dbg(cs35l56->base.dev, \"DSP system name: '%s'\\n\", dsp->system_name);\n\n\tret = wm_halo_init(dsp);\n\tif (ret != 0) {\n\t\tdev_err(cs35l56->base.dev, \"wm_halo_init failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs35l56_get_firmware_uid(struct cs35l56_private *cs35l56)\n{\n\tstruct device *dev = cs35l56->base.dev;\n\tconst char *prop;\n\tint ret;\n\n\tret = device_property_read_string(dev, \"cirrus,firmware-uid\", &prop);\n\t \n\tif (ret < 0)\n\t\treturn 0;\n\n\tcs35l56->dsp.system_name = devm_kstrdup(dev, prop, GFP_KERNEL);\n\tif (cs35l56->dsp.system_name == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"Firmware UID: %s\\n\", cs35l56->dsp.system_name);\n\n\treturn 0;\n}\n\nint cs35l56_common_probe(struct cs35l56_private *cs35l56)\n{\n\tint ret;\n\n\tinit_completion(&cs35l56->init_completion);\n\tmutex_init(&cs35l56->base.irq_lock);\n\n\tdev_set_drvdata(cs35l56->base.dev, cs35l56);\n\n\tcs35l56_fill_supply_names(cs35l56->supplies);\n\tret = devm_regulator_bulk_get(cs35l56->base.dev, ARRAY_SIZE(cs35l56->supplies),\n\t\t\t\t      cs35l56->supplies);\n\tif (ret != 0)\n\t\treturn dev_err_probe(cs35l56->base.dev, ret, \"Failed to request supplies\\n\");\n\n\t \n\tcs35l56->base.reset_gpio = devm_gpiod_get_optional(cs35l56->base.dev, \"reset\",\n\t\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(cs35l56->base.reset_gpio)) {\n\t\tret = PTR_ERR(cs35l56->base.reset_gpio);\n\t\t \n\t\tif (ret != -EBUSY)\n\t\t\treturn dev_err_probe(cs35l56->base.dev, ret, \"Failed to get reset GPIO\\n\");\n\n\t\tdev_info(cs35l56->base.dev, \"Reset GPIO busy, assume shared reset\\n\");\n\t\tcs35l56->base.reset_gpio = NULL;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs35l56->supplies), cs35l56->supplies);\n\tif (ret != 0)\n\t\treturn dev_err_probe(cs35l56->base.dev, ret, \"Failed to enable supplies\\n\");\n\n\tif (cs35l56->base.reset_gpio) {\n\t\t \n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\t\tcs35l56_wait_min_reset_pulse();\n\t\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 1);\n\t}\n\n\tret = cs35l56_get_firmware_uid(cs35l56);\n\tif (ret != 0)\n\t\tgoto err;\n\n\tret = cs35l56_dsp_init(cs35l56);\n\tif (ret < 0) {\n\t\tdev_err_probe(cs35l56->base.dev, ret, \"DSP init failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = devm_snd_soc_register_component(cs35l56->base.dev,\n\t\t\t\t\t      &soc_component_dev_cs35l56,\n\t\t\t\t\t      cs35l56_dai, ARRAY_SIZE(cs35l56_dai));\n\tif (ret < 0) {\n\t\tdev_err_probe(cs35l56->base.dev, ret, \"Register codec failed\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(cs35l56->supplies), cs35l56->supplies);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_common_probe, SND_SOC_CS35L56_CORE);\n\nint cs35l56_init(struct cs35l56_private *cs35l56)\n{\n\tint ret;\n\n\t \n\tif (cs35l56->soft_resetting)\n\t\tgoto post_soft_reset;\n\n\tif (cs35l56->base.init_done)\n\t\treturn 0;\n\n\tpm_runtime_set_autosuspend_delay(cs35l56->base.dev, 100);\n\tpm_runtime_use_autosuspend(cs35l56->base.dev);\n\tpm_runtime_set_active(cs35l56->base.dev);\n\tpm_runtime_enable(cs35l56->base.dev);\n\n\tret = cs35l56_hw_init(&cs35l56->base);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tcs35l56->dsp.part = devm_kasprintf(cs35l56->base.dev, GFP_KERNEL, \"cs35l56%s-%02x\",\n\t\t\t\t\t   cs35l56->base.secured ? \"s\" : \"\", cs35l56->base.rev);\n\tif (!cs35l56->dsp.part)\n\t\treturn -ENOMEM;\n\n\tif (!cs35l56->base.reset_gpio) {\n\t\tdev_dbg(cs35l56->base.dev, \"No reset gpio: using soft reset\\n\");\n\t\tcs35l56->soft_resetting = true;\n\t\tcs35l56_system_reset(&cs35l56->base, !!cs35l56->sdw_peripheral);\n\t\tif (cs35l56->sdw_peripheral) {\n\t\t\t \n\t\t\tpm_runtime_get_noresume(cs35l56->base.dev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\npost_soft_reset:\n\tif (cs35l56->soft_resetting) {\n\t\tcs35l56->soft_resetting = false;\n\n\t\t \n\t\tif (cs35l56->sdw_peripheral && !cs35l56->base.init_done)\n\t\t\tpm_runtime_put_noidle(cs35l56->base.dev);\n\n\t\tregcache_mark_dirty(cs35l56->base.regmap);\n\t\tret = cs35l56_wait_for_firmware_boot(&cs35l56->base);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(cs35l56->base.dev, \"Firmware rebooted after soft reset\\n\");\n\t}\n\n\t \n\tret = cs35l56_mbox_send(&cs35l56->base, CS35L56_MBOX_CMD_PREVENT_AUTO_HIBERNATE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cs35l56_set_patch(&cs35l56->base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregcache_sync(cs35l56->base.regmap);\n\n\t \n\tret = regmap_set_bits(cs35l56->base.regmap, CS35L56_ASP1_CONTROL3,\n\t\t\t      CS35L56_ASP1_DOUT_HIZ_CTRL_MASK);\n\tif (ret)\n\t\treturn dev_err_probe(cs35l56->base.dev, ret, \"Failed to write ASP1_CONTROL3\\n\");\n\n\tcs35l56->base.init_done = true;\n\tcomplete(&cs35l56->init_completion);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_init, SND_SOC_CS35L56_CORE);\n\nvoid cs35l56_remove(struct cs35l56_private *cs35l56)\n{\n\tcs35l56->base.init_done = false;\n\n\t \n\tif (cs35l56->base.irq)\n\t\tdevm_free_irq(cs35l56->base.dev, cs35l56->base.irq, &cs35l56->base);\n\n\tflush_workqueue(cs35l56->dsp_wq);\n\tdestroy_workqueue(cs35l56->dsp_wq);\n\n\tpm_runtime_dont_use_autosuspend(cs35l56->base.dev);\n\tpm_runtime_suspend(cs35l56->base.dev);\n\tpm_runtime_disable(cs35l56->base.dev);\n\n\tregcache_cache_only(cs35l56->base.regmap, true);\n\n\tgpiod_set_value_cansleep(cs35l56->base.reset_gpio, 0);\n\tregulator_bulk_disable(ARRAY_SIZE(cs35l56->supplies), cs35l56->supplies);\n}\nEXPORT_SYMBOL_NS_GPL(cs35l56_remove, SND_SOC_CS35L56_CORE);\n\nconst struct dev_pm_ops cs35l56_pm_ops_i2c_spi = {\n\tSET_RUNTIME_PM_OPS(cs35l56_runtime_suspend_i2c_spi, cs35l56_runtime_resume_i2c_spi, NULL)\n\tSYSTEM_SLEEP_PM_OPS(cs35l56_system_suspend, cs35l56_system_resume)\n\tLATE_SYSTEM_SLEEP_PM_OPS(cs35l56_system_suspend_late, cs35l56_system_resume_early)\n\tNOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l56_system_suspend_no_irq, cs35l56_system_resume_no_irq)\n};\nEXPORT_SYMBOL_NS_GPL(cs35l56_pm_ops_i2c_spi, SND_SOC_CS35L56_CORE);\n\nMODULE_DESCRIPTION(\"ASoC CS35L56 driver\");\nMODULE_IMPORT_NS(SND_SOC_CS35L56_SHARED);\nMODULE_AUTHOR(\"Richard Fitzgerald <rf@opensource.cirrus.com>\");\nMODULE_AUTHOR(\"Simon Trimmer <simont@opensource.cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}