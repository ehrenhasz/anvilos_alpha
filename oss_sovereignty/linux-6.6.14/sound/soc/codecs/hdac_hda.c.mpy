{
  "module_name": "hdac_hda.c",
  "hash_id": "114056c644eb32b622a2c1f749707b75d2c15b258c5793f83038c8f696a23b31",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/hdac_hda.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/hdaudio_ext.h>\n#include <sound/hda_i915.h>\n#include <sound/hda_codec.h>\n#include <sound/hda_register.h>\n\n#include \"hdac_hda.h\"\n\n#define STUB_FORMATS\t(SNDRV_PCM_FMTBIT_S8 | \\\n\t\t\tSNDRV_PCM_FMTBIT_U8 | \\\n\t\t\tSNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U24_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S32_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_U32_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)\n\n#define STUB_HDMI_RATES\t(SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\\\n\t\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 |\\\n\t\t\t\t SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 |\\\n\t\t\t\t SNDRV_PCM_RATE_192000)\n\nstatic int hdac_hda_dai_open(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai);\nstatic void hdac_hda_dai_close(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai);\nstatic int hdac_hda_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai);\nstatic int hdac_hda_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai);\nstatic int hdac_hda_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai);\nstatic int hdac_hda_dai_set_stream(struct snd_soc_dai *dai, void *stream,\n\t\t\t\t   int direction);\nstatic struct hda_pcm *snd_soc_find_pcm_from_dai(struct hdac_hda_priv *hda_pvt,\n\t\t\t\t\t\t struct snd_soc_dai *dai);\n\nstatic const struct snd_soc_dai_ops hdac_hda_dai_ops = {\n\t.startup = hdac_hda_dai_open,\n\t.shutdown = hdac_hda_dai_close,\n\t.prepare = hdac_hda_dai_prepare,\n\t.hw_params = hdac_hda_dai_hw_params,\n\t.hw_free = hdac_hda_dai_hw_free,\n\t.set_stream = hdac_hda_dai_set_stream,\n};\n\nstatic struct snd_soc_dai_driver hdac_hda_dais[] = {\n{\n\t.id = HDAC_ANALOG_DAI_ID,\n\t.name = \"Analog Codec DAI\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name\t= \"Analog Codec Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 16,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= STUB_FORMATS,\n\t\t.sig_bits\t= 24,\n\t},\n\t.capture = {\n\t\t.stream_name    = \"Analog Codec Capture\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 16,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n{\n\t.id = HDAC_DIGITAL_DAI_ID,\n\t.name = \"Digital Codec DAI\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name    = \"Digital Codec Playback\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 16,\n\t\t.rates          = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats        = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n\t.capture = {\n\t\t.stream_name    = \"Digital Codec Capture\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 16,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n{\n\t.id = HDAC_ALT_ANALOG_DAI_ID,\n\t.name = \"Alt Analog Codec DAI\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name\t= \"Alt Analog Codec Playback\",\n\t\t.channels_min\t= 1,\n\t\t.channels_max\t= 16,\n\t\t.rates\t\t= SNDRV_PCM_RATE_8000_192000,\n\t\t.formats\t= STUB_FORMATS,\n\t\t.sig_bits\t= 24,\n\t},\n\t.capture = {\n\t\t.stream_name    = \"Alt Analog Codec Capture\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 16,\n\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t.formats = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n};\n\nstatic struct snd_soc_dai_driver hdac_hda_hdmi_dais[] = {\n{\n\t.id = HDAC_HDMI_0_DAI_ID,\n\t.name = \"intel-hdmi-hifi1\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name    = \"hifi1\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 32,\n\t\t.rates          = STUB_HDMI_RATES,\n\t\t.formats        = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n{\n\t.id = HDAC_HDMI_1_DAI_ID,\n\t.name = \"intel-hdmi-hifi2\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name    = \"hifi2\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 32,\n\t\t.rates          = STUB_HDMI_RATES,\n\t\t.formats        = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n{\n\t.id = HDAC_HDMI_2_DAI_ID,\n\t.name = \"intel-hdmi-hifi3\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name    = \"hifi3\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 32,\n\t\t.rates          = STUB_HDMI_RATES,\n\t\t.formats        = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n{\n\t.id = HDAC_HDMI_3_DAI_ID,\n\t.name = \"intel-hdmi-hifi4\",\n\t.ops = &hdac_hda_dai_ops,\n\t.playback = {\n\t\t.stream_name    = \"hifi4\",\n\t\t.channels_min   = 1,\n\t\t.channels_max   = 32,\n\t\t.rates          = STUB_HDMI_RATES,\n\t\t.formats        = STUB_FORMATS,\n\t\t.sig_bits = 24,\n\t},\n},\n\n};\n\nstatic int hdac_hda_dai_set_stream(struct snd_soc_dai *dai,\n\t\t\t\t   void *stream, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct hdac_hda_pcm *pcm;\n\tstruct hdac_stream *hstream;\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\tpcm = &hda_pvt->pcm[dai->id];\n\thstream = (struct hdac_stream *)stream;\n\n\tpcm->stream_tag[direction] = hstream->stream_tag;\n\n\treturn 0;\n}\n\nstatic int hdac_hda_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params *params,\n\t\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hda_priv *hda_pvt;\n\tunsigned int format_val;\n\tunsigned int maxbps;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tmaxbps = dai->driver->playback.sig_bits;\n\telse\n\t\tmaxbps = dai->driver->capture.sig_bits;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\tformat_val = snd_hdac_calc_stream_format(params_rate(params),\n\t\t\t\t\t\t params_channels(params),\n\t\t\t\t\t\t params_format(params),\n\t\t\t\t\t\t maxbps,\n\t\t\t\t\t\t 0);\n\tif (!format_val) {\n\t\tdev_err(dai->dev,\n\t\t\t\"invalid format_val, rate=%d, ch=%d, format=%d, maxbps=%d\\n\",\n\t\t\tparams_rate(params), params_channels(params),\n\t\t\tparams_format(params), maxbps);\n\n\t\treturn -EINVAL;\n\t}\n\n\thda_pvt->pcm[dai->id].format_val[substream->stream] = format_val;\n\treturn 0;\n}\n\nstatic int hdac_hda_dai_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct hda_pcm_stream *hda_stream;\n\tstruct hda_pcm *pcm;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\tpcm = snd_soc_find_pcm_from_dai(hda_pvt, dai);\n\tif (!pcm)\n\t\treturn -EINVAL;\n\n\thda_stream = &pcm->stream[substream->stream];\n\tsnd_hda_codec_cleanup(hda_pvt->codec, hda_stream, substream);\n\n\treturn 0;\n}\n\nstatic int hdac_hda_dai_prepare(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hda_pcm_stream *hda_stream;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct hdac_device *hdev;\n\tunsigned int format_val;\n\tstruct hda_pcm *pcm;\n\tunsigned int stream;\n\tint ret = 0;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\thdev = &hda_pvt->codec->core;\n\tpcm = snd_soc_find_pcm_from_dai(hda_pvt, dai);\n\tif (!pcm)\n\t\treturn -EINVAL;\n\n\thda_stream = &pcm->stream[substream->stream];\n\n\tstream = hda_pvt->pcm[dai->id].stream_tag[substream->stream];\n\tformat_val = hda_pvt->pcm[dai->id].format_val[substream->stream];\n\n\tret = snd_hda_codec_prepare(hda_pvt->codec, hda_stream,\n\t\t\t\t    stream, format_val, substream);\n\tif (ret < 0)\n\t\tdev_err(&hdev->dev, \"codec prepare failed %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int hdac_hda_dai_open(struct snd_pcm_substream *substream,\n\t\t\t     struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct hda_pcm_stream *hda_stream;\n\tstruct hda_pcm *pcm;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\tpcm = snd_soc_find_pcm_from_dai(hda_pvt, dai);\n\tif (!pcm)\n\t\treturn -EINVAL;\n\n\tsnd_hda_codec_pcm_get(pcm);\n\n\thda_stream = &pcm->stream[substream->stream];\n\n\treturn hda_stream->ops.open(hda_stream, hda_pvt->codec, substream);\n}\n\nstatic void hdac_hda_dai_close(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct hdac_hda_priv *hda_pvt;\n\tstruct hda_pcm_stream *hda_stream;\n\tstruct hda_pcm *pcm;\n\n\thda_pvt = snd_soc_component_get_drvdata(component);\n\tpcm = snd_soc_find_pcm_from_dai(hda_pvt, dai);\n\tif (!pcm)\n\t\treturn;\n\n\thda_stream = &pcm->stream[substream->stream];\n\n\thda_stream->ops.close(hda_stream, hda_pvt->codec, substream);\n\n\tsnd_hda_codec_pcm_put(pcm);\n}\n\nstatic struct hda_pcm *snd_soc_find_pcm_from_dai(struct hdac_hda_priv *hda_pvt,\n\t\t\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct hda_codec *hcodec = hda_pvt->codec;\n\tstruct hda_pcm *cpcm;\n\tconst char *pcm_name;\n\n\t \n\n\tswitch (dai->id) {\n\tcase HDAC_ANALOG_DAI_ID:\n\t\tpcm_name = \"Analog\";\n\t\tbreak;\n\tcase HDAC_DIGITAL_DAI_ID:\n\t\tpcm_name = \"Digital\";\n\t\tbreak;\n\tcase HDAC_ALT_ANALOG_DAI_ID:\n\t\tpcm_name = \"Alt Analog\";\n\t\tbreak;\n\tcase HDAC_HDMI_0_DAI_ID:\n\t\tpcm_name = \"HDMI 0\";\n\t\tbreak;\n\tcase HDAC_HDMI_1_DAI_ID:\n\t\tpcm_name = \"HDMI 1\";\n\t\tbreak;\n\tcase HDAC_HDMI_2_DAI_ID:\n\t\tpcm_name = \"HDMI 2\";\n\t\tbreak;\n\tcase HDAC_HDMI_3_DAI_ID:\n\t\tpcm_name = \"HDMI 3\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hcodec->core.dev, \"invalid dai id %d\\n\", dai->id);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(cpcm, &hcodec->pcm_list_head, list) {\n\t\tif (strstr(cpcm->name, pcm_name)) {\n\t\t\tif (strcmp(pcm_name, \"Analog\") == 0) {\n\t\t\t\tif (strstr(cpcm->name, \"Alt Analog\"))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn cpcm;\n\t\t}\n\t}\n\n\tdev_err(&hcodec->core.dev, \"didn't find PCM for DAI %s\\n\", dai->name);\n\treturn NULL;\n}\n\nstatic bool is_hdmi_codec(struct hda_codec *hcodec)\n{\n\tstruct hda_pcm *cpcm;\n\n\tlist_for_each_entry(cpcm, &hcodec->pcm_list_head, list) {\n\t\tif (cpcm->pcm_type == HDA_PCM_TYPE_HDMI)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int hdac_hda_codec_probe(struct snd_soc_component *component)\n{\n\tstruct hdac_hda_priv *hda_pvt =\n\t\t\tsnd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm =\n\t\t\tsnd_soc_component_get_dapm(component);\n\tstruct hdac_device *hdev = &hda_pvt->codec->core;\n\tstruct hda_codec *hcodec = hda_pvt->codec;\n\tstruct hdac_ext_link *hlink;\n\thda_codec_patch_t patch;\n\tint ret;\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_name(hdev->bus, dev_name(&hdev->dev));\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tsnd_hdac_ext_bus_link_get(hdev->bus, hlink);\n\n\t \n\tif (hda_pvt->need_display_power)\n\t\tsnd_hdac_display_power(hdev->bus,\n\t\t\t\t       HDA_CODEC_IDX_CONTROLLER, true);\n\n\tret = snd_hda_codec_device_new(hcodec->bus, component->card->snd_card,\n\t\t\t\t       hdev->addr, hcodec, true);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to create hda codec %d\\n\", ret);\n\t\tgoto error_no_pm;\n\t}\n\t \n\thdev->type = HDA_DEV_ASOC;\n\n\t \n\tpm_runtime_get_noresume(&hdev->dev);\n\n\thcodec->bus->card = dapm->card->snd_card;\n\n\tret = snd_hda_codec_set_name(hcodec, hcodec->preset->name);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"name failed %s\\n\", hcodec->preset->name);\n\t\tgoto error_pm;\n\t}\n\n\tret = snd_hdac_regmap_init(&hcodec->core);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"regmap init failed\\n\");\n\t\tgoto error_pm;\n\t}\n\n\tpatch = (hda_codec_patch_t)hcodec->preset->driver_data;\n\tif (patch) {\n\t\tret = patch(hcodec);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"patch failed %d\\n\", ret);\n\t\t\tgoto error_regmap;\n\t\t}\n\t} else {\n\t\tdev_dbg(&hdev->dev, \"no patch file found\\n\");\n\t}\n\n\tret = snd_hda_codec_parse_pcms(hcodec);\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"unable to map pcms to dai %d\\n\", ret);\n\t\tgoto error_patch;\n\t}\n\n\t \n\tif (!is_hdmi_codec(hcodec)) {\n\t\tret = snd_hda_codec_build_controls(hcodec);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&hdev->dev, \"unable to create controls %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error_patch;\n\t\t}\n\t}\n\n\thcodec->core.lazy_cache = true;\n\n\tif (hda_pvt->need_display_power)\n\t\tsnd_hdac_display_power(hdev->bus,\n\t\t\t\t       HDA_CODEC_IDX_CONTROLLER, false);\n\n\t \n\tpm_runtime_allow(&hdev->dev);\n\n\t \n\tpm_runtime_put(&hdev->dev);\n\tpm_runtime_suspend(&hdev->dev);\n\n\treturn 0;\n\nerror_patch:\n\tif (hcodec->patch_ops.free)\n\t\thcodec->patch_ops.free(hcodec);\nerror_regmap:\n\tsnd_hdac_regmap_exit(hdev);\nerror_pm:\n\tpm_runtime_put(&hdev->dev);\nerror_no_pm:\n\tsnd_hdac_ext_bus_link_put(hdev->bus, hlink);\n\treturn ret;\n}\n\nstatic void hdac_hda_codec_remove(struct snd_soc_component *component)\n{\n\tstruct hdac_hda_priv *hda_pvt =\n\t\t      snd_soc_component_get_drvdata(component);\n\tstruct hdac_device *hdev = &hda_pvt->codec->core;\n\tstruct hda_codec *codec = hda_pvt->codec;\n\tstruct hdac_ext_link *hlink = NULL;\n\n\thlink = snd_hdac_ext_bus_get_hlink_by_name(hdev->bus, dev_name(&hdev->dev));\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn;\n\t}\n\n\tpm_runtime_disable(&hdev->dev);\n\tsnd_hdac_ext_bus_link_put(hdev->bus, hlink);\n\n\tif (codec->patch_ops.free)\n\t\tcodec->patch_ops.free(codec);\n\n\tsnd_hda_codec_cleanup_for_unbind(codec);\n}\n\nstatic const struct snd_soc_dapm_route hdac_hda_dapm_routes[] = {\n\t{\"AIF1TX\", NULL, \"Codec Input Pin1\"},\n\t{\"AIF2TX\", NULL, \"Codec Input Pin2\"},\n\t{\"AIF3TX\", NULL, \"Codec Input Pin3\"},\n\n\t{\"Codec Output Pin1\", NULL, \"AIF1RX\"},\n\t{\"Codec Output Pin2\", NULL, \"AIF2RX\"},\n\t{\"Codec Output Pin3\", NULL, \"AIF3RX\"},\n};\n\nstatic const struct snd_soc_dapm_widget hdac_hda_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"AIF1RX\", \"Analog Codec Playback\", 0,\n\t\t\t    SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF2RX\", \"Digital Codec Playback\", 0,\n\t\t\t    SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIF3RX\", \"Alt Analog Codec Playback\", 0,\n\t\t\t    SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF1TX\", \"Analog Codec Capture\", 0,\n\t\t\t     SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF2TX\", \"Digital Codec Capture\", 0,\n\t\t\t     SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"AIF3TX\", \"Alt Analog Codec Capture\", 0,\n\t\t\t     SND_SOC_NOPM, 0, 0),\n\n\t \n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin1\"),\n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin2\"),\n\tSND_SOC_DAPM_INPUT(\"Codec Input Pin3\"),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin1\"),\n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin2\"),\n\tSND_SOC_DAPM_OUTPUT(\"Codec Output Pin3\"),\n};\n\nstatic const struct snd_soc_component_driver hdac_hda_codec = {\n\t.probe\t\t\t= hdac_hda_codec_probe,\n\t.remove\t\t\t= hdac_hda_codec_remove,\n\t.dapm_widgets\t\t= hdac_hda_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(hdac_hda_dapm_widgets),\n\t.dapm_routes\t\t= hdac_hda_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(hdac_hda_dapm_routes),\n\t.idle_bias_on\t\t= false,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_component_driver hdac_hda_hdmi_codec = {\n\t.probe\t\t\t= hdac_hda_codec_probe,\n\t.remove\t\t\t= hdac_hda_codec_remove,\n\t.idle_bias_on\t\t= false,\n\t.endianness\t\t= 1,\n};\n\nstatic int hdac_hda_dev_probe(struct hdac_device *hdev)\n{\n\tstruct hdac_hda_priv *hda_pvt = dev_get_drvdata(&hdev->dev);\n\tstruct hdac_ext_link *hlink;\n\tint ret;\n\n\t \n\thlink = snd_hdac_ext_bus_get_hlink_by_name(hdev->bus, dev_name(&hdev->dev));\n\tif (!hlink) {\n\t\tdev_err(&hdev->dev, \"hdac link not found\\n\");\n\t\treturn -EIO;\n\t}\n\tsnd_hdac_ext_bus_link_get(hdev->bus, hlink);\n\n\t \n\tif (hda_pvt->need_display_power)\n\t\tret = devm_snd_soc_register_component(&hdev->dev,\n\t\t\t\t\t\t&hdac_hda_hdmi_codec, hdac_hda_hdmi_dais,\n\t\t\t\t\t\tARRAY_SIZE(hdac_hda_hdmi_dais));\n\telse\n\t\tret = devm_snd_soc_register_component(&hdev->dev,\n\t\t\t\t\t\t&hdac_hda_codec, hdac_hda_dais,\n\t\t\t\t\t\tARRAY_SIZE(hdac_hda_dais));\n\n\tif (ret < 0) {\n\t\tdev_err(&hdev->dev, \"failed to register HDA codec %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsnd_hdac_ext_bus_link_put(hdev->bus, hlink);\n\n\treturn ret;\n}\n\nstatic int hdac_hda_dev_remove(struct hdac_device *hdev)\n{\n\t \n\treturn 0;\n}\n\nstatic struct hdac_ext_bus_ops hdac_ops = {\n\t.hdev_attach = hdac_hda_dev_probe,\n\t.hdev_detach = hdac_hda_dev_remove,\n};\n\nstruct hdac_ext_bus_ops *snd_soc_hdac_hda_get_ops(void)\n{\n\treturn &hdac_ops;\n}\nEXPORT_SYMBOL_GPL(snd_soc_hdac_hda_get_ops);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"ASoC Extensions for legacy HDA Drivers\");\nMODULE_AUTHOR(\"Rakesh Ughreja<rakesh.a.ughreja@intel.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}