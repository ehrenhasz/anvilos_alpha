{
  "module_name": "msm8916-wcd-analog.c",
  "hash_id": "21b901aa004831f395b145e0e6c6921a4b1eb2dbd5dfd27f83a54484915866d1",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/msm8916-wcd-analog.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <sound/soc.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/tlv.h>\n#include <sound/jack.h>\n\n#define CDC_D_REVISION1\t\t\t(0xf000)\n#define CDC_D_PERPH_SUBTYPE\t\t(0xf005)\n#define CDC_D_INT_EN_SET\t\t(0xf015)\n#define CDC_D_INT_EN_CLR\t\t(0xf016)\n#define MBHC_SWITCH_INT\t\t\tBIT(7)\n#define MBHC_MIC_ELECTRICAL_INS_REM_DET\tBIT(6)\n#define MBHC_BUTTON_PRESS_DET\t\tBIT(5)\n#define MBHC_BUTTON_RELEASE_DET\t\tBIT(4)\n#define CDC_D_CDC_RST_CTL\t\t(0xf046)\n#define RST_CTL_DIG_SW_RST_N_MASK\tBIT(7)\n#define RST_CTL_DIG_SW_RST_N_RESET\t0\n#define RST_CTL_DIG_SW_RST_N_REMOVE_RESET BIT(7)\n\n#define CDC_D_CDC_TOP_CLK_CTL\t\t(0xf048)\n#define TOP_CLK_CTL_A_MCLK_MCLK2_EN_MASK (BIT(2) | BIT(3))\n#define TOP_CLK_CTL_A_MCLK_EN_ENABLE\t BIT(2)\n#define TOP_CLK_CTL_A_MCLK2_EN_ENABLE\tBIT(3)\n\n#define CDC_D_CDC_ANA_CLK_CTL\t\t(0xf049)\n#define ANA_CLK_CTL_EAR_HPHR_CLK_EN_MASK BIT(0)\n#define ANA_CLK_CTL_EAR_HPHR_CLK_EN\tBIT(0)\n#define ANA_CLK_CTL_EAR_HPHL_CLK_EN\tBIT(1)\n#define ANA_CLK_CTL_SPKR_CLK_EN_MASK\tBIT(4)\n#define ANA_CLK_CTL_SPKR_CLK_EN\tBIT(4)\n#define ANA_CLK_CTL_TXA_CLK25_EN\tBIT(5)\n\n#define CDC_D_CDC_DIG_CLK_CTL\t\t(0xf04A)\n#define DIG_CLK_CTL_RXD1_CLK_EN\t\tBIT(0)\n#define DIG_CLK_CTL_RXD2_CLK_EN\t\tBIT(1)\n#define DIG_CLK_CTL_RXD3_CLK_EN\t\tBIT(2)\n#define DIG_CLK_CTL_D_MBHC_CLK_EN_MASK\tBIT(3)\n#define DIG_CLK_CTL_D_MBHC_CLK_EN\tBIT(3)\n#define DIG_CLK_CTL_TXD_CLK_EN\t\tBIT(4)\n#define DIG_CLK_CTL_NCP_CLK_EN_MASK\tBIT(6)\n#define DIG_CLK_CTL_NCP_CLK_EN\t\tBIT(6)\n#define DIG_CLK_CTL_RXD_PDM_CLK_EN_MASK\tBIT(7)\n#define DIG_CLK_CTL_RXD_PDM_CLK_EN\tBIT(7)\n\n#define CDC_D_CDC_CONN_TX1_CTL\t\t(0xf050)\n#define CONN_TX1_SERIAL_TX1_MUX\t\tGENMASK(1, 0)\n#define CONN_TX1_SERIAL_TX1_ADC_1\t0x0\n#define CONN_TX1_SERIAL_TX1_RX_PDM_LB\t0x1\n#define CONN_TX1_SERIAL_TX1_ZERO\t0x2\n\n#define CDC_D_CDC_CONN_TX2_CTL\t\t(0xf051)\n#define CONN_TX2_SERIAL_TX2_MUX\t\tGENMASK(1, 0)\n#define CONN_TX2_SERIAL_TX2_ADC_2\t0x0\n#define CONN_TX2_SERIAL_TX2_RX_PDM_LB\t0x1\n#define CONN_TX2_SERIAL_TX2_ZERO\t0x2\n#define CDC_D_CDC_CONN_HPHR_DAC_CTL\t(0xf052)\n#define CDC_D_CDC_CONN_RX1_CTL\t\t(0xf053)\n#define CDC_D_CDC_CONN_RX2_CTL\t\t(0xf054)\n#define CDC_D_CDC_CONN_RX3_CTL\t\t(0xf055)\n#define CDC_D_CDC_CONN_RX_LB_CTL\t(0xf056)\n#define CDC_D_SEC_ACCESS\t\t(0xf0D0)\n#define CDC_D_PERPH_RESET_CTL3\t\t(0xf0DA)\n#define CDC_D_PERPH_RESET_CTL4\t\t(0xf0DB)\n#define CDC_A_REVISION1\t\t\t(0xf100)\n#define CDC_A_REVISION2\t\t\t(0xf101)\n#define CDC_A_REVISION3\t\t\t(0xf102)\n#define CDC_A_REVISION4\t\t\t(0xf103)\n#define CDC_A_PERPH_TYPE\t\t(0xf104)\n#define CDC_A_PERPH_SUBTYPE\t\t(0xf105)\n#define CDC_A_INT_RT_STS\t\t(0xf110)\n#define CDC_A_INT_SET_TYPE\t\t(0xf111)\n#define CDC_A_INT_POLARITY_HIGH\t\t(0xf112)\n#define CDC_A_INT_POLARITY_LOW\t\t(0xf113)\n#define CDC_A_INT_LATCHED_CLR\t\t(0xf114)\n#define CDC_A_INT_EN_SET\t\t(0xf115)\n#define CDC_A_INT_EN_CLR\t\t(0xf116)\n#define CDC_A_INT_LATCHED_STS\t\t(0xf118)\n#define CDC_A_INT_PENDING_STS\t\t(0xf119)\n#define CDC_A_INT_MID_SEL\t\t(0xf11A)\n#define CDC_A_INT_PRIORITY\t\t(0xf11B)\n#define CDC_A_MICB_1_EN\t\t\t(0xf140)\n#define MICB_1_EN_MICB_ENABLE\t\tBIT(7)\n#define MICB_1_EN_BYP_CAP_MASK\t\tBIT(6)\n#define MICB_1_EN_NO_EXT_BYP_CAP\tBIT(6)\n#define MICB_1_EN_EXT_BYP_CAP\t\t0\n#define MICB_1_EN_PULL_DOWN_EN_MASK\tBIT(5)\n#define MICB_1_EN_PULL_DOWN_EN_ENABLE\tBIT(5)\n#define MICB_1_EN_OPA_STG2_TAIL_CURR_MASK GENMASK(3, 1)\n#define MICB_1_EN_OPA_STG2_TAIL_CURR_1_60UA\t(0x4)\n#define MICB_1_EN_PULL_UP_EN_MASK\tBIT(4)\n#define MICB_1_EN_TX3_GND_SEL_MASK\tBIT(0)\n#define MICB_1_EN_TX3_GND_SEL_TX_GND\t0\n\n#define CDC_A_MICB_1_VAL\t\t(0xf141)\n#define MICB_MIN_VAL 1600\n#define MICB_STEP_SIZE 50\n#define MICB_VOLTAGE_REGVAL(v)\t\t(((v - MICB_MIN_VAL)/MICB_STEP_SIZE) << 3)\n#define MICB_1_VAL_MICB_OUT_VAL_MASK\tGENMASK(7, 3)\n#define MICB_1_VAL_MICB_OUT_VAL_V2P70V\t((0x16)  << 3)\n#define MICB_1_VAL_MICB_OUT_VAL_V1P80V\t((0x4)  << 3)\n#define CDC_A_MICB_1_CTL\t\t(0xf142)\n\n#define MICB_1_CTL_CFILT_REF_SEL_MASK\t\tBIT(1)\n#define MICB_1_CTL_CFILT_REF_SEL_HPF_REF\tBIT(1)\n#define MICB_1_CTL_EXT_PRECHARG_EN_MASK\t\tBIT(5)\n#define MICB_1_CTL_EXT_PRECHARG_EN_ENABLE\tBIT(5)\n#define MICB_1_CTL_INT_PRECHARG_BYP_MASK\tBIT(6)\n#define MICB_1_CTL_INT_PRECHARG_BYP_EXT_PRECHRG_SEL\tBIT(6)\n\n#define CDC_A_MICB_1_INT_RBIAS\t\t\t(0xf143)\n#define MICB_1_INT_TX1_INT_RBIAS_EN_MASK\tBIT(7)\n#define MICB_1_INT_TX1_INT_RBIAS_EN_ENABLE\tBIT(7)\n#define MICB_1_INT_TX1_INT_RBIAS_EN_DISABLE\t0\n\n#define MICB_1_INT_TX1_INT_PULLUP_EN_MASK\tBIT(6)\n#define MICB_1_INT_TX1_INT_PULLUP_EN_TX1N_TO_MICBIAS BIT(6)\n#define MICB_1_INT_TX1_INT_PULLUP_EN_TX1N_TO_GND\t0\n\n#define MICB_1_INT_TX2_INT_RBIAS_EN_MASK\tBIT(4)\n#define MICB_1_INT_TX2_INT_RBIAS_EN_ENABLE\tBIT(4)\n#define MICB_1_INT_TX2_INT_RBIAS_EN_DISABLE\t0\n#define MICB_1_INT_TX2_INT_PULLUP_EN_MASK\tBIT(3)\n#define MICB_1_INT_TX2_INT_PULLUP_EN_TX1N_TO_MICBIAS BIT(3)\n#define MICB_1_INT_TX2_INT_PULLUP_EN_TX1N_TO_GND\t0\n\n#define MICB_1_INT_TX3_INT_RBIAS_EN_MASK\tBIT(1)\n#define MICB_1_INT_TX3_INT_RBIAS_EN_ENABLE\tBIT(1)\n#define MICB_1_INT_TX3_INT_RBIAS_EN_DISABLE\t0\n#define MICB_1_INT_TX3_INT_PULLUP_EN_MASK\tBIT(0)\n#define MICB_1_INT_TX3_INT_PULLUP_EN_TX1N_TO_MICBIAS BIT(0)\n#define MICB_1_INT_TX3_INT_PULLUP_EN_TX1N_TO_GND\t0\n\n#define CDC_A_MICB_2_EN\t\t\t(0xf144)\n#define CDC_A_MICB_2_EN_ENABLE\t\tBIT(7)\n#define CDC_A_MICB_2_PULL_DOWN_EN_MASK\tBIT(5)\n#define CDC_A_MICB_2_PULL_DOWN_EN\tBIT(5)\n#define CDC_A_TX_1_2_ATEST_CTL_2\t(0xf145)\n#define CDC_A_MASTER_BIAS_CTL\t\t(0xf146)\n#define CDC_A_MBHC_DET_CTL_1\t\t(0xf147)\n#define CDC_A_MBHC_DET_CTL_L_DET_EN\t\t\tBIT(7)\n#define CDC_A_MBHC_DET_CTL_GND_DET_EN\t\t\tBIT(6)\n#define CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_INSERTION\tBIT(5)\n#define CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_REMOVAL\t(0)\n#define CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK\t\tBIT(5)\n#define CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_SHIFT\t\t(5)\n#define CDC_A_MBHC_DET_CTL_MIC_CLAMP_CTL_AUTO\t\tBIT(4)\n#define CDC_A_MBHC_DET_CTL_MIC_CLAMP_CTL_MANUAL\t\tBIT(3)\n#define CDC_A_MBHC_DET_CTL_MIC_CLAMP_CTL_MASK\t\tGENMASK(4, 3)\n#define CDC_A_MBHC_DET_CTL_MBHC_BIAS_EN\t\t\tBIT(2)\n#define CDC_A_MBHC_DET_CTL_2\t\t(0xf150)\n#define CDC_A_MBHC_DET_CTL_HS_L_DET_PULL_UP_CTRL_I_3P0\t(BIT(7) | BIT(6))\n#define CDC_A_MBHC_DET_CTL_HS_L_DET_COMPA_CTRL_V0P9_VDD\tBIT(5)\n#define CDC_A_PLUG_TYPE_MASK\t\t\t\tGENMASK(4, 3)\n#define CDC_A_HPHL_PLUG_TYPE_NO\t\t\t\tBIT(4)\n#define CDC_A_GND_PLUG_TYPE_NO\t\t\t\tBIT(3)\n#define CDC_A_MBHC_DET_CTL_HPHL_100K_TO_GND_EN_MASK\tBIT(0)\n#define CDC_A_MBHC_DET_CTL_HPHL_100K_TO_GND_EN\t\tBIT(0)\n#define CDC_A_MBHC_FSM_CTL\t\t(0xf151)\n#define CDC_A_MBHC_FSM_CTL_MBHC_FSM_EN\t\t\tBIT(7)\n#define CDC_A_MBHC_FSM_CTL_MBHC_FSM_EN_MASK\t\tBIT(7)\n#define CDC_A_MBHC_FSM_CTL_BTN_ISRC_CTRL_I_100UA\t(0x3 << 4)\n#define CDC_A_MBHC_FSM_CTL_BTN_ISRC_CTRL_MASK\t\tGENMASK(6, 4)\n#define CDC_A_MBHC_DBNC_TIMER\t\t(0xf152)\n#define CDC_A_MBHC_DBNC_TIMER_BTN_DBNC_T_16MS\t\tBIT(3)\n#define CDC_A_MBHC_DBNC_TIMER_INSREM_DBNC_T_256_MS\t(0x9 << 4)\n#define CDC_A_MBHC_BTN0_ZDET_CTL_0\t(0xf153)\n#define CDC_A_MBHC_BTN1_ZDET_CTL_1\t(0xf154)\n#define CDC_A_MBHC_BTN2_ZDET_CTL_2\t(0xf155)\n#define CDC_A_MBHC_BTN3_CTL\t\t(0xf156)\n#define CDC_A_MBHC_BTN4_CTL\t\t(0xf157)\n#define CDC_A_MBHC_BTN_VREF_FINE_SHIFT\t(2)\n#define CDC_A_MBHC_BTN_VREF_FINE_MASK\tGENMASK(4, 2)\n#define CDC_A_MBHC_BTN_VREF_COARSE_MASK\tGENMASK(7, 5)\n#define CDC_A_MBHC_BTN_VREF_COARSE_SHIFT (5)\n#define CDC_A_MBHC_BTN_VREF_MASK\t(CDC_A_MBHC_BTN_VREF_COARSE_MASK | \\\n\t\t\t\t\tCDC_A_MBHC_BTN_VREF_FINE_MASK)\n#define CDC_A_MBHC_RESULT_1\t\t(0xf158)\n#define CDC_A_MBHC_RESULT_1_BTN_RESULT_MASK\tGENMASK(4, 0)\n#define CDC_A_TX_1_EN\t\t\t(0xf160)\n#define CDC_A_TX_2_EN\t\t\t(0xf161)\n#define CDC_A_TX_1_2_TEST_CTL_1\t\t(0xf162)\n#define CDC_A_TX_1_2_TEST_CTL_2\t\t(0xf163)\n#define CDC_A_TX_1_2_ATEST_CTL\t\t(0xf164)\n#define CDC_A_TX_1_2_OPAMP_BIAS\t\t(0xf165)\n#define CDC_A_TX_3_EN\t\t\t(0xf167)\n#define CDC_A_NCP_EN\t\t\t(0xf180)\n#define CDC_A_NCP_CLK\t\t\t(0xf181)\n#define CDC_A_NCP_FBCTRL\t\t(0xf183)\n#define CDC_A_NCP_FBCTRL_FB_CLK_INV_MASK\tBIT(5)\n#define CDC_A_NCP_FBCTRL_FB_CLK_INV\t\tBIT(5)\n#define CDC_A_NCP_BIAS\t\t\t(0xf184)\n#define CDC_A_NCP_VCTRL\t\t\t(0xf185)\n#define CDC_A_NCP_TEST\t\t\t(0xf186)\n#define CDC_A_NCP_CLIM_ADDR\t\t(0xf187)\n#define CDC_A_RX_CLOCK_DIVIDER\t\t(0xf190)\n#define CDC_A_RX_COM_OCP_CTL\t\t(0xf191)\n#define CDC_A_RX_COM_OCP_COUNT\t\t(0xf192)\n#define CDC_A_RX_COM_BIAS_DAC\t\t(0xf193)\n#define RX_COM_BIAS_DAC_RX_BIAS_EN_MASK\t\tBIT(7)\n#define RX_COM_BIAS_DAC_RX_BIAS_EN_ENABLE\tBIT(7)\n#define RX_COM_BIAS_DAC_DAC_REF_EN_MASK\t\tBIT(0)\n#define RX_COM_BIAS_DAC_DAC_REF_EN_ENABLE\tBIT(0)\n\n#define CDC_A_RX_HPH_BIAS_PA\t\t(0xf194)\n#define CDC_A_RX_HPH_BIAS_LDO_OCP\t(0xf195)\n#define CDC_A_RX_HPH_BIAS_CNP\t\t(0xf196)\n#define CDC_A_RX_HPH_CNP_EN\t\t(0xf197)\n#define CDC_A_RX_HPH_L_PA_DAC_CTL\t(0xf19B)\n#define RX_HPA_L_PA_DAC_CTL_DATA_RESET_MASK\tBIT(1)\n#define RX_HPA_L_PA_DAC_CTL_DATA_RESET_RESET\tBIT(1)\n#define CDC_A_RX_HPH_R_PA_DAC_CTL\t(0xf19D)\n#define RX_HPH_R_PA_DAC_CTL_DATA_RESET\tBIT(1)\n#define RX_HPH_R_PA_DAC_CTL_DATA_RESET_MASK BIT(1)\n\n#define CDC_A_RX_EAR_CTL\t\t\t(0xf19E)\n#define RX_EAR_CTL_SPK_VBAT_LDO_EN_MASK\t\tBIT(0)\n#define RX_EAR_CTL_SPK_VBAT_LDO_EN_ENABLE\tBIT(0)\n#define RX_EAR_CTL_PA_EAR_PA_EN_MASK\t\tBIT(6)\n#define RX_EAR_CTL_PA_EAR_PA_EN_ENABLE\t\tBIT(6)\n#define RX_EAR_CTL_PA_SEL_MASK\t\t\tBIT(7)\n#define RX_EAR_CTL_PA_SEL\t\t\tBIT(7)\n\n#define CDC_A_SPKR_DAC_CTL\t\t(0xf1B0)\n#define SPKR_DAC_CTL_DAC_RESET_MASK\tBIT(4)\n#define SPKR_DAC_CTL_DAC_RESET_NORMAL\t0\n\n#define CDC_A_SPKR_DRV_CTL\t\t(0xf1B2)\n#define SPKR_DRV_CTL_DEF_MASK\t\t0xEF\n#define SPKR_DRV_CLASSD_PA_EN_MASK\tBIT(7)\n#define SPKR_DRV_CLASSD_PA_EN_ENABLE\tBIT(7)\n#define SPKR_DRV_CAL_EN\t\t\tBIT(6)\n#define SPKR_DRV_SETTLE_EN\t\tBIT(5)\n#define SPKR_DRV_FW_EN\t\t\tBIT(3)\n#define SPKR_DRV_BOOST_SET\t\tBIT(2)\n#define SPKR_DRV_CMFB_SET\t\tBIT(1)\n#define SPKR_DRV_GAIN_SET\t\tBIT(0)\n#define SPKR_DRV_CTL_DEF_VAL (SPKR_DRV_CLASSD_PA_EN_ENABLE | \\\n\t\tSPKR_DRV_CAL_EN | SPKR_DRV_SETTLE_EN | \\\n\t\tSPKR_DRV_FW_EN | SPKR_DRV_BOOST_SET | \\\n\t\tSPKR_DRV_CMFB_SET | SPKR_DRV_GAIN_SET)\n#define CDC_A_SPKR_OCP_CTL\t\t(0xf1B4)\n#define CDC_A_SPKR_PWRSTG_CTL\t\t(0xf1B5)\n#define SPKR_PWRSTG_CTL_DAC_EN_MASK\tBIT(0)\n#define SPKR_PWRSTG_CTL_DAC_EN\t\tBIT(0)\n#define SPKR_PWRSTG_CTL_MASK\t\t0xE0\n#define SPKR_PWRSTG_CTL_BBM_MASK\tBIT(7)\n#define SPKR_PWRSTG_CTL_BBM_EN\t\tBIT(7)\n#define SPKR_PWRSTG_CTL_HBRDGE_EN_MASK\tBIT(6)\n#define SPKR_PWRSTG_CTL_HBRDGE_EN\tBIT(6)\n#define SPKR_PWRSTG_CTL_CLAMP_EN_MASK\tBIT(5)\n#define SPKR_PWRSTG_CTL_CLAMP_EN\tBIT(5)\n\n#define CDC_A_SPKR_DRV_DBG\t\t(0xf1B7)\n#define CDC_A_CURRENT_LIMIT\t\t(0xf1C0)\n#define CDC_A_BOOST_EN_CTL\t\t(0xf1C3)\n#define CDC_A_SLOPE_COMP_IP_ZERO\t(0xf1C4)\n#define CDC_A_SEC_ACCESS\t\t(0xf1D0)\n#define CDC_A_PERPH_RESET_CTL3\t\t(0xf1DA)\n#define CDC_A_PERPH_RESET_CTL4\t\t(0xf1DB)\n\n#define MSM8916_WCD_ANALOG_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\\\n\t\t\tSNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000)\n#define MSM8916_WCD_ANALOG_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t\t    SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic int btn_mask = SND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t       SND_JACK_BTN_2 | SND_JACK_BTN_3 | SND_JACK_BTN_4;\nstatic int hs_jack_mask = SND_JACK_HEADPHONE | SND_JACK_HEADSET;\n\nstatic const char * const supply_names[] = {\n\t\"vdd-cdc-io\",\n\t\"vdd-cdc-tx-rx-cx\",\n};\n\n#define MBHC_MAX_BUTTONS\t(5)\n\nstruct pm8916_wcd_analog_priv {\n\tu16 pmic_rev;\n\tu16 codec_version;\n\tbool\tmbhc_btn_enabled;\n\t \n\tint\tmbhc_btn0_released;\n\tbool\tdetect_accessory_type;\n\tstruct clk *mclk;\n\tstruct snd_soc_component *component;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(supply_names)];\n\tstruct snd_soc_jack *jack;\n\tbool hphl_jack_type_normally_open;\n\tbool gnd_jack_type_normally_open;\n\t \n\tu32 vref_btn_cs[MBHC_MAX_BUTTONS];\n\t \n\tu32 vref_btn_micb[MBHC_MAX_BUTTONS];\n\tunsigned int micbias1_cap_mode;\n\tunsigned int micbias2_cap_mode;\n\tunsigned int micbias_mv;\n};\n\nstatic const char *const adc2_mux_text[] = { \"ZERO\", \"INP2\", \"INP3\" };\nstatic const char *const rdac2_mux_text[] = { \"RX1\", \"RX2\" };\nstatic const char *const hph_text[] = { \"ZERO\", \"Switch\", };\n\nstatic const struct soc_enum hph_enum = SOC_ENUM_SINGLE_VIRT(\n\t\t\t\t\tARRAY_SIZE(hph_text), hph_text);\n\nstatic const struct snd_kcontrol_new ear_mux = SOC_DAPM_ENUM(\"EAR_S\", hph_enum);\nstatic const struct snd_kcontrol_new hphl_mux = SOC_DAPM_ENUM(\"HPHL\", hph_enum);\nstatic const struct snd_kcontrol_new hphr_mux = SOC_DAPM_ENUM(\"HPHR\", hph_enum);\n\n \nstatic const struct soc_enum adc2_enum = SOC_ENUM_SINGLE_VIRT(\n\t\t\tARRAY_SIZE(adc2_mux_text), adc2_mux_text);\n\n \nstatic const struct soc_enum rdac2_mux_enum = SOC_ENUM_SINGLE(\n\t\t\tCDC_D_CDC_CONN_HPHR_DAC_CTL, 0, 2, rdac2_mux_text);\n\nstatic const struct snd_kcontrol_new spkr_switch[] = {\n\tSOC_DAPM_SINGLE(\"Switch\", CDC_A_SPKR_DAC_CTL, 7, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new rdac2_mux = SOC_DAPM_ENUM(\n\t\t\t\t\t\"RDAC2 MUX Mux\", rdac2_mux_enum);\nstatic const struct snd_kcontrol_new tx_adc2_mux = SOC_DAPM_ENUM(\n\t\t\t\t\t\"ADC2 MUX Mux\", adc2_enum);\n\n \nstatic const DECLARE_TLV_DB_SCALE(analog_gain, 0, 600, 0);\n\nstatic const struct snd_kcontrol_new pm8916_wcd_analog_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"ADC1 Volume\", CDC_A_TX_1_EN, 3, 8, 0, analog_gain),\n\tSOC_SINGLE_TLV(\"ADC2 Volume\", CDC_A_TX_2_EN, 3, 8, 0, analog_gain),\n\tSOC_SINGLE_TLV(\"ADC3 Volume\", CDC_A_TX_3_EN, 3, 8, 0, analog_gain),\n};\n\nstatic void pm8916_wcd_analog_micbias_enable(struct snd_soc_component *component)\n{\n\tstruct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);\n\n\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_CTL,\n\t\t\t    MICB_1_CTL_EXT_PRECHARG_EN_MASK |\n\t\t\t    MICB_1_CTL_INT_PRECHARG_BYP_MASK,\n\t\t\t    MICB_1_CTL_INT_PRECHARG_BYP_EXT_PRECHRG_SEL\n\t\t\t    | MICB_1_CTL_EXT_PRECHARG_EN_ENABLE);\n\n\tif (wcd->micbias_mv) {\n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_VAL,\n\t\t\t\t    MICB_1_VAL_MICB_OUT_VAL_MASK,\n\t\t\t\t    MICB_VOLTAGE_REGVAL(wcd->micbias_mv));\n\t\t \n\t\tif (wcd->micbias_mv >= 2700)\n\t\t\tmsleep(50);\n\t}\n\n\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_CTL,\n\t\t\t    MICB_1_CTL_EXT_PRECHARG_EN_MASK |\n\t\t\t    MICB_1_CTL_INT_PRECHARG_BYP_MASK, 0);\n\n}\n\nstatic int pm8916_wcd_analog_enable_micbias(struct snd_soc_component *component,\n\t\t\t\t\t    int event, unsigned int cap_mode)\n{\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tpm8916_wcd_analog_micbias_enable(component);\n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_EN,\n\t\t\t\t    MICB_1_EN_BYP_CAP_MASK, cap_mode);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8916_wcd_analog_enable_micbias_int(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t\tstruct snd_kcontrol *kcontrol,\n\t\t\t\t\t\tint event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_EN,\n\t\t\t\t    MICB_1_EN_OPA_STG2_TAIL_CURR_MASK,\n\t\t\t\t    MICB_1_EN_OPA_STG2_TAIL_CURR_1_60UA);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int pm8916_wcd_analog_enable_micbias1(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t     struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);\n\n\treturn pm8916_wcd_analog_enable_micbias(component, event,\n\t\t\t\t\t\twcd->micbias1_cap_mode);\n}\n\nstatic int pm8916_wcd_analog_enable_micbias2(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t     struct snd_kcontrol *kcontrol,\n\t\t\t\t\t     int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);\n\n\treturn pm8916_wcd_analog_enable_micbias(component, event,\n\t\t\t\t\t\twcd->micbias2_cap_mode);\n\n}\n\nstatic int pm8916_mbhc_configure_bias(struct pm8916_wcd_analog_priv *priv,\n\t\t\t\t      bool micbias2_enabled)\n{\n\tstruct snd_soc_component *component = priv->component;\n\tu32 coarse, fine, reg_val, reg_addr;\n\tint *vrefs, i;\n\n\tif (!micbias2_enabled) {  \n\t\t \n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_INT_RBIAS,\n\t\t\t\t    MICB_1_INT_TX2_INT_RBIAS_EN_MASK,\n\t\t\t\t    MICB_1_INT_TX2_INT_RBIAS_EN_ENABLE);\n\t\t \n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_2_EN,\n\t\t\t\t   CDC_A_MICB_2_PULL_DOWN_EN_MASK,\n\t\t\t\t   0);\n\t\t \n\t\tsnd_soc_component_update_bits(component, CDC_A_MBHC_FSM_CTL,\n\t\t\t\t    CDC_A_MBHC_FSM_CTL_BTN_ISRC_CTRL_MASK,\n\t\t\t\t    CDC_A_MBHC_FSM_CTL_BTN_ISRC_CTRL_I_100UA);\n\t}\n\tsnd_soc_component_update_bits(component, CDC_A_MBHC_FSM_CTL,\n\t\t\tCDC_A_MBHC_FSM_CTL_MBHC_FSM_EN_MASK,\n\t\t\tCDC_A_MBHC_FSM_CTL_MBHC_FSM_EN);\n\n\tif (micbias2_enabled)\n\t\tvrefs = &priv->vref_btn_micb[0];\n\telse\n\t\tvrefs = &priv->vref_btn_cs[0];\n\n\t \n\treg_addr = CDC_A_MBHC_BTN0_ZDET_CTL_0;\n\tfor (i = 0; i <  MBHC_MAX_BUTTONS; i++) {\n\t\t \n\t\tcoarse = (vrefs[i] / 100);\n\t\tfine = ((vrefs[i] % 100) / 12);\n\t\treg_val = (coarse << CDC_A_MBHC_BTN_VREF_COARSE_SHIFT) |\n\t\t\t (fine << CDC_A_MBHC_BTN_VREF_FINE_SHIFT);\n\t\tsnd_soc_component_update_bits(component, reg_addr,\n\t\t\t       CDC_A_MBHC_BTN_VREF_MASK,\n\t\t\t       reg_val);\n\t\treg_addr++;\n\t}\n\n\treturn 0;\n}\n\nstatic void pm8916_wcd_setup_mbhc(struct pm8916_wcd_analog_priv *wcd)\n{\n\tstruct snd_soc_component *component = wcd->component;\n\tbool micbias_enabled = false;\n\tu32 plug_type = 0;\n\tu32 int_en_mask;\n\n\tsnd_soc_component_write(component, CDC_A_MBHC_DET_CTL_1,\n\t\t      CDC_A_MBHC_DET_CTL_L_DET_EN |\n\t\t      CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_INSERTION |\n\t\t      CDC_A_MBHC_DET_CTL_MIC_CLAMP_CTL_AUTO |\n\t\t      CDC_A_MBHC_DET_CTL_MBHC_BIAS_EN);\n\n\tif (wcd->hphl_jack_type_normally_open)\n\t\tplug_type |= CDC_A_HPHL_PLUG_TYPE_NO;\n\n\tif (wcd->gnd_jack_type_normally_open)\n\t\tplug_type |= CDC_A_GND_PLUG_TYPE_NO;\n\n\tsnd_soc_component_write(component, CDC_A_MBHC_DET_CTL_2,\n\t\t      CDC_A_MBHC_DET_CTL_HS_L_DET_PULL_UP_CTRL_I_3P0 |\n\t\t      CDC_A_MBHC_DET_CTL_HS_L_DET_COMPA_CTRL_V0P9_VDD |\n\t\t      plug_type |\n\t\t      CDC_A_MBHC_DET_CTL_HPHL_100K_TO_GND_EN);\n\n\n\tsnd_soc_component_write(component, CDC_A_MBHC_DBNC_TIMER,\n\t\t      CDC_A_MBHC_DBNC_TIMER_INSREM_DBNC_T_256_MS |\n\t\t      CDC_A_MBHC_DBNC_TIMER_BTN_DBNC_T_16MS);\n\n\t \n\tsnd_soc_component_update_bits(component, CDC_D_CDC_DIG_CLK_CTL,\n\t\t\t    DIG_CLK_CTL_D_MBHC_CLK_EN_MASK,\n\t\t\t    DIG_CLK_CTL_D_MBHC_CLK_EN);\n\n\tif (snd_soc_component_read(component, CDC_A_MICB_2_EN) & CDC_A_MICB_2_EN_ENABLE)\n\t\tmicbias_enabled = true;\n\n\tpm8916_mbhc_configure_bias(wcd, micbias_enabled);\n\n\tint_en_mask = MBHC_SWITCH_INT;\n\tif (wcd->mbhc_btn_enabled)\n\t\tint_en_mask |= MBHC_BUTTON_PRESS_DET | MBHC_BUTTON_RELEASE_DET;\n\n\tsnd_soc_component_update_bits(component, CDC_D_INT_EN_CLR, int_en_mask, 0);\n\tsnd_soc_component_update_bits(component, CDC_D_INT_EN_SET, int_en_mask, int_en_mask);\n\twcd->mbhc_btn0_released = false;\n\twcd->detect_accessory_type = true;\n}\n\nstatic int pm8916_wcd_analog_enable_micbias_int2(struct\n\t\t\t\t\t\t  snd_soc_dapm_widget\n\t\t\t\t\t\t  *w, struct snd_kcontrol\n\t\t\t\t\t\t  *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_2_EN,\n\t\t\t\t\t      CDC_A_MICB_2_PULL_DOWN_EN_MASK, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tpm8916_mbhc_configure_bias(wcd, true);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tpm8916_mbhc_configure_bias(wcd, false);\n\t\tbreak;\n\t}\n\n\treturn pm8916_wcd_analog_enable_micbias_int(w, kcontrol, event);\n}\n\nstatic int pm8916_wcd_analog_enable_adc(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t struct snd_kcontrol *kcontrol,\n\t\t\t\t\t int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tu16 adc_reg = CDC_A_TX_1_2_TEST_CTL_2;\n\tu8 init_bit_shift;\n\n\tif (w->reg == CDC_A_TX_1_EN)\n\t\tinit_bit_shift = 5;\n\telse\n\t\tinit_bit_shift = 4;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tif (w->reg == CDC_A_TX_2_EN)\n\t\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_CTL,\n\t\t\t\t\t    MICB_1_CTL_CFILT_REF_SEL_MASK,\n\t\t\t\t\t    MICB_1_CTL_CFILT_REF_SEL_HPF_REF);\n\t\t \n\t\tusleep_range(10000, 10010);\n\t\tsnd_soc_component_update_bits(component, adc_reg, 1 << init_bit_shift,\n\t\t\t\t    1 << init_bit_shift);\n\t\tswitch (w->reg) {\n\t\tcase CDC_A_TX_1_EN:\n\t\t\tsnd_soc_component_update_bits(component, CDC_D_CDC_CONN_TX1_CTL,\n\t\t\t\t\t    CONN_TX1_SERIAL_TX1_MUX,\n\t\t\t\t\t    CONN_TX1_SERIAL_TX1_ADC_1);\n\t\t\tbreak;\n\t\tcase CDC_A_TX_2_EN:\n\t\tcase CDC_A_TX_3_EN:\n\t\t\tsnd_soc_component_update_bits(component, CDC_D_CDC_CONN_TX2_CTL,\n\t\t\t\t\t    CONN_TX2_SERIAL_TX2_MUX,\n\t\t\t\t\t    CONN_TX2_SERIAL_TX2_ADC_2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tusleep_range(12000, 12010);\n\t\tsnd_soc_component_update_bits(component, adc_reg, 1 << init_bit_shift, 0x00);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tswitch (w->reg) {\n\t\tcase CDC_A_TX_1_EN:\n\t\t\tsnd_soc_component_update_bits(component, CDC_D_CDC_CONN_TX1_CTL,\n\t\t\t\t\t    CONN_TX1_SERIAL_TX1_MUX,\n\t\t\t\t\t    CONN_TX1_SERIAL_TX1_ZERO);\n\t\t\tbreak;\n\t\tcase CDC_A_TX_2_EN:\n\t\t\tsnd_soc_component_update_bits(component, CDC_A_MICB_1_CTL,\n\t\t\t\t\t    MICB_1_CTL_CFILT_REF_SEL_MASK, 0);\n\t\t\tfallthrough;\n\t\tcase CDC_A_TX_3_EN:\n\t\t\tsnd_soc_component_update_bits(component, CDC_D_CDC_CONN_TX2_CTL,\n\t\t\t\t\t    CONN_TX2_SERIAL_TX2_MUX,\n\t\t\t\t\t    CONN_TX2_SERIAL_TX2_ZERO);\n\t\t\tbreak;\n\t\t}\n\n\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int pm8916_wcd_analog_enable_spk_pa(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_SPKR_PWRSTG_CTL,\n\t\t\t\t    SPKR_PWRSTG_CTL_DAC_EN_MASK |\n\t\t\t\t    SPKR_PWRSTG_CTL_BBM_MASK |\n\t\t\t\t    SPKR_PWRSTG_CTL_HBRDGE_EN_MASK |\n\t\t\t\t    SPKR_PWRSTG_CTL_CLAMP_EN_MASK,\n\t\t\t\t    SPKR_PWRSTG_CTL_DAC_EN|\n\t\t\t\t    SPKR_PWRSTG_CTL_BBM_EN |\n\t\t\t\t    SPKR_PWRSTG_CTL_HBRDGE_EN |\n\t\t\t\t    SPKR_PWRSTG_CTL_CLAMP_EN);\n\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_SPK_VBAT_LDO_EN_MASK,\n\t\t\t\t    RX_EAR_CTL_SPK_VBAT_LDO_EN_ENABLE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_SPKR_DRV_CTL,\n\t\t\t\t    SPKR_DRV_CTL_DEF_MASK,\n\t\t\t\t    SPKR_DRV_CTL_DEF_VAL);\n\t\tsnd_soc_component_update_bits(component, w->reg,\n\t\t\t\t    SPKR_DRV_CLASSD_PA_EN_MASK,\n\t\t\t\t    SPKR_DRV_CLASSD_PA_EN_ENABLE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, CDC_A_SPKR_PWRSTG_CTL,\n\t\t\t\t    SPKR_PWRSTG_CTL_DAC_EN_MASK|\n\t\t\t\t    SPKR_PWRSTG_CTL_BBM_MASK |\n\t\t\t\t    SPKR_PWRSTG_CTL_HBRDGE_EN_MASK |\n\t\t\t\t    SPKR_PWRSTG_CTL_CLAMP_EN_MASK, 0);\n\n\t\tsnd_soc_component_update_bits(component, CDC_A_SPKR_DAC_CTL,\n\t\t\t\t    SPKR_DAC_CTL_DAC_RESET_MASK,\n\t\t\t\t    SPKR_DAC_CTL_DAC_RESET_NORMAL);\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_SPK_VBAT_LDO_EN_MASK, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int pm8916_wcd_analog_enable_ear_pa(struct snd_soc_dapm_widget *w,\n\t\t\t\t\t    struct snd_kcontrol *kcontrol,\n\t\t\t\t\t    int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_PA_SEL_MASK, RX_EAR_CTL_PA_SEL);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_PA_EAR_PA_EN_MASK,\n\t\t\t\t    RX_EAR_CTL_PA_EAR_PA_EN_ENABLE);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_PA_EAR_PA_EN_MASK, 0);\n\t\t \n\t\tusleep_range(7000, 7100);\n\t\tsnd_soc_component_update_bits(component, CDC_A_RX_EAR_CTL,\n\t\t\t\t    RX_EAR_CTL_PA_SEL_MASK, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct reg_default wcd_reg_defaults_2_0[] = {\n\t{CDC_A_RX_COM_OCP_CTL, 0xD1},\n\t{CDC_A_RX_COM_OCP_COUNT, 0xFF},\n\t{CDC_D_SEC_ACCESS, 0xA5},\n\t{CDC_D_PERPH_RESET_CTL3, 0x0F},\n\t{CDC_A_TX_1_2_OPAMP_BIAS, 0x4F},\n\t{CDC_A_NCP_FBCTRL, 0x28},\n\t{CDC_A_SPKR_DRV_CTL, 0x69},\n\t{CDC_A_SPKR_DRV_DBG, 0x01},\n\t{CDC_A_BOOST_EN_CTL, 0x5F},\n\t{CDC_A_SLOPE_COMP_IP_ZERO, 0x88},\n\t{CDC_A_SEC_ACCESS, 0xA5},\n\t{CDC_A_PERPH_RESET_CTL3, 0x0F},\n\t{CDC_A_CURRENT_LIMIT, 0x82},\n\t{CDC_A_SPKR_DAC_CTL, 0x03},\n\t{CDC_A_SPKR_OCP_CTL, 0xE1},\n\t{CDC_A_MASTER_BIAS_CTL, 0x30},\n};\n\nstatic int pm8916_wcd_analog_probe(struct snd_soc_component *component)\n{\n\tstruct pm8916_wcd_analog_priv *priv = dev_get_drvdata(component->dev);\n\tint err, reg;\n\n\terr = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\n\tif (err != 0) {\n\t\tdev_err(component->dev, \"failed to enable regulators (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tsnd_soc_component_init_regmap(component,\n\t\t\t\t  dev_get_regmap(component->dev->parent, NULL));\n\tsnd_soc_component_set_drvdata(component, priv);\n\tpriv->pmic_rev = snd_soc_component_read(component, CDC_D_REVISION1);\n\tpriv->codec_version = snd_soc_component_read(component, CDC_D_PERPH_SUBTYPE);\n\n\tdev_info(component->dev, \"PMIC REV: %d\\t CODEC Version: %d\\n\",\n\t\t priv->pmic_rev, priv->codec_version);\n\n\tsnd_soc_component_write(component, CDC_D_PERPH_RESET_CTL4, 0x01);\n\tsnd_soc_component_write(component, CDC_A_PERPH_RESET_CTL4, 0x01);\n\n\tfor (reg = 0; reg < ARRAY_SIZE(wcd_reg_defaults_2_0); reg++)\n\t\tsnd_soc_component_write(component, wcd_reg_defaults_2_0[reg].reg,\n\t\t\t      wcd_reg_defaults_2_0[reg].def);\n\n\tpriv->component = component;\n\n\tsnd_soc_component_update_bits(component, CDC_D_CDC_RST_CTL,\n\t\t\t    RST_CTL_DIG_SW_RST_N_MASK,\n\t\t\t    RST_CTL_DIG_SW_RST_N_REMOVE_RESET);\n\n\tpm8916_wcd_setup_mbhc(priv);\n\n\treturn 0;\n}\n\nstatic void pm8916_wcd_analog_remove(struct snd_soc_component *component)\n{\n\tstruct pm8916_wcd_analog_priv *priv = dev_get_drvdata(component->dev);\n\n\tsnd_soc_component_update_bits(component, CDC_D_CDC_RST_CTL,\n\t\t\t    RST_CTL_DIG_SW_RST_N_MASK, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(priv->supplies),\n\t\t\t\t      priv->supplies);\n}\n\nstatic const struct snd_soc_dapm_route pm8916_wcd_analog_audio_map[] = {\n\n\t{\"PDM_RX1\", NULL, \"PDM Playback\"},\n\t{\"PDM_RX2\", NULL, \"PDM Playback\"},\n\t{\"PDM_RX3\", NULL, \"PDM Playback\"},\n\t{\"PDM Capture\", NULL, \"PDM_TX\"},\n\n\t \n\t{\"PDM_TX\", NULL, \"ADC2\"},\n\t{\"PDM_TX\", NULL, \"ADC3\"},\n\t{\"ADC2\", NULL, \"ADC2 MUX\"},\n\t{\"ADC3\", NULL, \"ADC2 MUX\"},\n\t{\"ADC2 MUX\", \"INP2\", \"ADC2_INP2\"},\n\t{\"ADC2 MUX\", \"INP3\", \"ADC2_INP3\"},\n\n\t{\"PDM_TX\", NULL, \"ADC1\"},\n\t{\"ADC1\", NULL, \"AMIC1\"},\n\t{\"ADC2_INP2\", NULL, \"AMIC2\"},\n\t{\"ADC2_INP3\", NULL, \"AMIC3\"},\n\n\t \n\t{\"HPHR DAC\", NULL, \"RDAC2 MUX\"},\n\t{\"RDAC2 MUX\", \"RX1\", \"PDM_RX1\"},\n\t{\"RDAC2 MUX\", \"RX2\", \"PDM_RX2\"},\n\t{\"HPHL DAC\", NULL, \"PDM_RX1\"},\n\t{\"PDM_RX1\", NULL, \"RXD1_CLK\"},\n\t{\"PDM_RX2\", NULL, \"RXD2_CLK\"},\n\t{\"PDM_RX3\", NULL, \"RXD3_CLK\"},\n\n\t{\"PDM_RX1\", NULL, \"RXD_PDM_CLK\"},\n\t{\"PDM_RX2\", NULL, \"RXD_PDM_CLK\"},\n\t{\"PDM_RX3\", NULL, \"RXD_PDM_CLK\"},\n\n\t{\"ADC1\", NULL, \"TXD_CLK\"},\n\t{\"ADC2\", NULL, \"TXD_CLK\"},\n\t{\"ADC3\", NULL, \"TXD_CLK\"},\n\n\t{\"ADC1\", NULL, \"TXA_CLK25\"},\n\t{\"ADC2\", NULL, \"TXA_CLK25\"},\n\t{\"ADC3\", NULL, \"TXA_CLK25\"},\n\n\t{\"PDM_RX1\", NULL, \"A_MCLK2\"},\n\t{\"PDM_RX2\", NULL, \"A_MCLK2\"},\n\t{\"PDM_RX3\", NULL, \"A_MCLK2\"},\n\n\t{\"PDM_TX\", NULL, \"A_MCLK2\"},\n\t{\"A_MCLK2\", NULL, \"A_MCLK\"},\n\n\t \n\t{\"EAR\", NULL, \"EAR_S\"},\n\t{\"EAR_S\", \"Switch\", \"EAR PA\"},\n\t{\"EAR PA\", NULL, \"RX_BIAS\"},\n\t{\"EAR PA\", NULL, \"HPHL DAC\"},\n\t{\"EAR PA\", NULL, \"HPHR DAC\"},\n\t{\"EAR PA\", NULL, \"EAR CP\"},\n\n\t \n\t{\"HPH_L\", NULL, \"HPHL PA\"},\n\t{\"HPH_R\", NULL, \"HPHR PA\"},\n\n\t{\"HPHL DAC\", NULL, \"EAR_HPHL_CLK\"},\n\t{\"HPHR DAC\", NULL, \"EAR_HPHR_CLK\"},\n\n\t{\"CP\", NULL, \"NCP_CLK\"},\n\n\t{\"HPHL PA\", NULL, \"HPHL\"},\n\t{\"HPHR PA\", NULL, \"HPHR\"},\n\t{\"HPHL PA\", NULL, \"CP\"},\n\t{\"HPHL PA\", NULL, \"RX_BIAS\"},\n\t{\"HPHR PA\", NULL, \"CP\"},\n\t{\"HPHR PA\", NULL, \"RX_BIAS\"},\n\t{\"HPHL\", \"Switch\", \"HPHL DAC\"},\n\t{\"HPHR\", \"Switch\", \"HPHR DAC\"},\n\n\t{\"RX_BIAS\", NULL, \"DAC_REF\"},\n\n\t{\"SPK_OUT\", NULL, \"SPK PA\"},\n\t{\"SPK PA\", NULL, \"RX_BIAS\"},\n\t{\"SPK PA\", NULL, \"SPKR_CLK\"},\n\t{\"SPK PA\", NULL, \"SPK DAC\"},\n\t{\"SPK DAC\", \"Switch\", \"PDM_RX3\"},\n\n\t{\"MIC_BIAS1\", NULL, \"INT_LDO_H\"},\n\t{\"MIC_BIAS2\", NULL, \"INT_LDO_H\"},\n\t{\"MIC_BIAS1\", NULL, \"vdd-micbias\"},\n\t{\"MIC_BIAS2\", NULL, \"vdd-micbias\"},\n\n\t{\"MIC BIAS External1\", NULL, \"MIC_BIAS1\"},\n\t{\"MIC BIAS Internal1\", NULL, \"MIC_BIAS1\"},\n\t{\"MIC BIAS External2\", NULL, \"MIC_BIAS2\"},\n\t{\"MIC BIAS Internal2\", NULL, \"MIC_BIAS2\"},\n\t{\"MIC BIAS Internal3\", NULL, \"MIC_BIAS1\"},\n};\n\nstatic const struct snd_soc_dapm_widget pm8916_wcd_analog_dapm_widgets[] = {\n\n\tSND_SOC_DAPM_AIF_IN(\"PDM_RX1\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"PDM_RX2\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"PDM_RX3\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"PDM_TX\", NULL, 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_INPUT(\"AMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"AMIC3\"),\n\tSND_SOC_DAPM_INPUT(\"AMIC2\"),\n\tSND_SOC_DAPM_OUTPUT(\"EAR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPH_L\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPH_R\"),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"INT_LDO_H\", SND_SOC_NOPM, 1, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA_E(\"EAR PA\", SND_SOC_NOPM,\n\t\t\t   0, 0, NULL, 0,\n\t\t\t   pm8916_wcd_analog_enable_ear_pa,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_MUX(\"EAR_S\", SND_SOC_NOPM, 0, 0, &ear_mux),\n\tSND_SOC_DAPM_SUPPLY(\"EAR CP\", CDC_A_NCP_EN, 4, 0, NULL, 0),\n\n\tSND_SOC_DAPM_PGA(\"HPHL PA\", CDC_A_RX_HPH_CNP_EN, 5, 0, NULL, 0),\n\tSND_SOC_DAPM_MUX(\"HPHL\", SND_SOC_NOPM, 0, 0, &hphl_mux),\n\tSND_SOC_DAPM_MIXER(\"HPHL DAC\", CDC_A_RX_HPH_L_PA_DAC_CTL, 3, 0, NULL,\n\t\t\t   0),\n\tSND_SOC_DAPM_PGA(\"HPHR PA\", CDC_A_RX_HPH_CNP_EN, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_MUX(\"HPHR\", SND_SOC_NOPM, 0, 0, &hphr_mux),\n\tSND_SOC_DAPM_MIXER(\"HPHR DAC\", CDC_A_RX_HPH_R_PA_DAC_CTL, 3, 0, NULL,\n\t\t\t   0),\n\tSND_SOC_DAPM_MIXER(\"SPK DAC\", SND_SOC_NOPM, 0, 0,\n\t\t\t   spkr_switch, ARRAY_SIZE(spkr_switch)),\n\n\t \n\tSND_SOC_DAPM_OUTPUT(\"SPK_OUT\"),\n\tSND_SOC_DAPM_PGA_E(\"SPK PA\", CDC_A_SPKR_DRV_CTL,\n\t\t\t   6, 0, NULL, 0,\n\t\t\t   pm8916_wcd_analog_enable_spk_pa,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_REGULATOR_SUPPLY(\"vdd-micbias\", 0, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CP\", CDC_A_NCP_EN, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"DAC_REF\", CDC_A_RX_COM_BIAS_DAC, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"RX_BIAS\", CDC_A_RX_COM_BIAS_DAC, 7, 0, NULL, 0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"MIC_BIAS1\", CDC_A_MICB_1_EN, 7, 0,\n\t\t\t    pm8916_wcd_analog_enable_micbias1,\n\t\t\t    SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_SUPPLY(\"MIC_BIAS2\", CDC_A_MICB_2_EN, 7, 0,\n\t\t\t    pm8916_wcd_analog_enable_micbias2,\n\t\t\t    SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_SUPPLY(\"MIC BIAS External1\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC BIAS External2\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"MIC BIAS Internal1\", CDC_A_MICB_1_INT_RBIAS, 7, 0,\n\t\t\t    pm8916_wcd_analog_enable_micbias_int,\n\t\t\t    SND_SOC_DAPM_PRE_PMU),\n\tSND_SOC_DAPM_SUPPLY(\"MIC BIAS Internal2\", CDC_A_MICB_1_INT_RBIAS, 4, 0,\n\t\t\t    pm8916_wcd_analog_enable_micbias_int2,\n\t\t\t    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t    SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"MIC BIAS Internal3\", CDC_A_MICB_1_INT_RBIAS, 1, 0,\n\t\t\t    pm8916_wcd_analog_enable_micbias_int,\n\t\t\t    SND_SOC_DAPM_PRE_PMU),\n\n\tSND_SOC_DAPM_ADC_E(\"ADC1\", NULL, CDC_A_TX_1_EN, 7, 0,\n\t\t\t   pm8916_wcd_analog_enable_adc,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC2_INP2\", NULL, CDC_A_TX_2_EN, 7, 0,\n\t\t\t   pm8916_wcd_analog_enable_adc,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_ADC_E(\"ADC2_INP3\", NULL, CDC_A_TX_3_EN, 7, 0,\n\t\t\t   pm8916_wcd_analog_enable_adc,\n\t\t\t   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t   SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MIXER(\"ADC2\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"ADC3\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"ADC2 MUX\", SND_SOC_NOPM, 0, 0, &tx_adc2_mux),\n\tSND_SOC_DAPM_MUX(\"RDAC2 MUX\", SND_SOC_NOPM, 0, 0, &rdac2_mux),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"EAR_HPHR_CLK\", CDC_D_CDC_ANA_CLK_CTL, 0, 0, NULL,\n\t\t\t    0),\n\tSND_SOC_DAPM_SUPPLY(\"EAR_HPHL_CLK\", CDC_D_CDC_ANA_CLK_CTL, 1, 0, NULL,\n\t\t\t    0),\n\tSND_SOC_DAPM_SUPPLY(\"SPKR_CLK\", CDC_D_CDC_ANA_CLK_CTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"TXA_CLK25\", CDC_D_CDC_ANA_CLK_CTL, 5, 0, NULL, 0),\n\n\t \n\n\tSND_SOC_DAPM_SUPPLY(\"RXD1_CLK\", CDC_D_CDC_DIG_CLK_CTL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"RXD2_CLK\", CDC_D_CDC_DIG_CLK_CTL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"RXD3_CLK\", CDC_D_CDC_DIG_CLK_CTL, 2, 0, NULL, 0),\n\n\tSND_SOC_DAPM_SUPPLY(\"TXD_CLK\", CDC_D_CDC_DIG_CLK_CTL, 4, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"NCP_CLK\", CDC_D_CDC_DIG_CLK_CTL, 6, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"RXD_PDM_CLK\", CDC_D_CDC_DIG_CLK_CTL, 7, 0, NULL,\n\t\t\t    0),\n\n\t \n\tSND_SOC_DAPM_SUPPLY(\"A_MCLK\", CDC_D_CDC_TOP_CLK_CTL, 2, 0, NULL, 0),\n\t \n\tSND_SOC_DAPM_SUPPLY(\"A_MCLK2\", CDC_D_CDC_TOP_CLK_CTL, 3, 0, NULL, 0),\n};\n\nstatic int pm8916_wcd_analog_set_jack(struct snd_soc_component *component,\n\t\t\t\t      struct snd_soc_jack *jack,\n\t\t\t\t      void *data)\n{\n\tstruct pm8916_wcd_analog_priv *wcd = snd_soc_component_get_drvdata(component);\n\n\twcd->jack = jack;\n\n\treturn 0;\n}\n\nstatic irqreturn_t mbhc_btn_release_irq_handler(int irq, void *arg)\n{\n\tstruct pm8916_wcd_analog_priv *priv = arg;\n\n\tif (priv->detect_accessory_type) {\n\t\tstruct snd_soc_component *component = priv->component;\n\t\tu32 val = snd_soc_component_read(component, CDC_A_MBHC_RESULT_1);\n\n\t\t \n\t\tif ((val != -1) && !(val & CDC_A_MBHC_RESULT_1_BTN_RESULT_MASK))\n\t\t\tpriv->mbhc_btn0_released = true;\n\n\t} else {\n\t\tsnd_soc_jack_report(priv->jack, 0, btn_mask);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mbhc_btn_press_irq_handler(int irq, void *arg)\n{\n\tstruct pm8916_wcd_analog_priv *priv = arg;\n\tstruct snd_soc_component *component = priv->component;\n\tu32 btn_result;\n\n\tbtn_result = snd_soc_component_read(component, CDC_A_MBHC_RESULT_1) &\n\t\t\t\t  CDC_A_MBHC_RESULT_1_BTN_RESULT_MASK;\n\n\tswitch (btn_result) {\n\tcase 0xf:\n\t\tsnd_soc_jack_report(priv->jack, SND_JACK_BTN_4, btn_mask);\n\t\tbreak;\n\tcase 0x7:\n\t\tsnd_soc_jack_report(priv->jack, SND_JACK_BTN_3, btn_mask);\n\t\tbreak;\n\tcase 0x3:\n\t\tsnd_soc_jack_report(priv->jack, SND_JACK_BTN_2, btn_mask);\n\t\tbreak;\n\tcase 0x1:\n\t\tsnd_soc_jack_report(priv->jack, SND_JACK_BTN_1, btn_mask);\n\t\tbreak;\n\tcase 0x0:\n\t\t \n\t\tif (!priv->detect_accessory_type)\n\t\t\tsnd_soc_jack_report(priv->jack,\n\t\t\t\t\t    SND_JACK_BTN_0, btn_mask);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"Unexpected button press result (%x)\", btn_result);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t pm8916_mbhc_switch_irq_handler(int irq, void *arg)\n{\n\tstruct pm8916_wcd_analog_priv *priv = arg;\n\tstruct snd_soc_component *component = priv->component;\n\tbool ins = false;\n\n\tif (snd_soc_component_read(component, CDC_A_MBHC_DET_CTL_1) &\n\t\t\t\tCDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK)\n\t\tins = true;\n\n\t \n\tsnd_soc_component_update_bits(component, CDC_A_MBHC_DET_CTL_1,\n\t\t\t    CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_MASK,\n\t\t\t    (!ins << CDC_A_MBHC_DET_CTL_MECH_DET_TYPE_SHIFT));\n\n\n\tif (ins) {  \n\t\tbool micbias_enabled = false;\n\n\t\tif (snd_soc_component_read(component, CDC_A_MICB_2_EN) &\n\t\t\t\tCDC_A_MICB_2_EN_ENABLE)\n\t\t\tmicbias_enabled = true;\n\n\t\tpm8916_mbhc_configure_bias(priv, micbias_enabled);\n\n\t\t \n\t\tif (priv->mbhc_btn0_released)\n\t\t\tsnd_soc_jack_report(priv->jack,\n\t\t\t\t\t    SND_JACK_HEADSET, hs_jack_mask);\n\t\telse\n\t\t\tsnd_soc_jack_report(priv->jack,\n\t\t\t\t\t    SND_JACK_HEADPHONE, hs_jack_mask);\n\n\t\tpriv->detect_accessory_type = false;\n\n\t} else {  \n\t\tsnd_soc_jack_report(priv->jack, 0, hs_jack_mask);\n\t\tpriv->detect_accessory_type = true;\n\t\tpriv->mbhc_btn0_released = false;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct snd_soc_dai_driver pm8916_wcd_analog_dai[] = {\n\t[0] = {\n\t       .name = \"pm8916_wcd_analog_pdm_rx\",\n\t       .id = 0,\n\t       .playback = {\n\t\t\t    .stream_name = \"PDM Playback\",\n\t\t\t    .rates = MSM8916_WCD_ANALOG_RATES,\n\t\t\t    .formats = MSM8916_WCD_ANALOG_FORMATS,\n\t\t\t    .channels_min = 1,\n\t\t\t    .channels_max = 3,\n\t\t\t    },\n\t       },\n\t[1] = {\n\t       .name = \"pm8916_wcd_analog_pdm_tx\",\n\t       .id = 1,\n\t       .capture = {\n\t\t\t   .stream_name = \"PDM Capture\",\n\t\t\t   .rates = MSM8916_WCD_ANALOG_RATES,\n\t\t\t   .formats = MSM8916_WCD_ANALOG_FORMATS,\n\t\t\t   .channels_min = 1,\n\t\t\t   .channels_max = 4,\n\t\t\t   },\n\t       },\n};\n\nstatic const struct snd_soc_component_driver pm8916_wcd_analog = {\n\t.probe\t\t\t= pm8916_wcd_analog_probe,\n\t.remove\t\t\t= pm8916_wcd_analog_remove,\n\t.set_jack\t\t= pm8916_wcd_analog_set_jack,\n\t.controls\t\t= pm8916_wcd_analog_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(pm8916_wcd_analog_snd_controls),\n\t.dapm_widgets\t\t= pm8916_wcd_analog_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(pm8916_wcd_analog_dapm_widgets),\n\t.dapm_routes\t\t= pm8916_wcd_analog_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(pm8916_wcd_analog_audio_map),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int pm8916_wcd_analog_parse_dt(struct device *dev,\n\t\t\t\t       struct pm8916_wcd_analog_priv *priv)\n{\n\tint rval;\n\n\tif (of_property_read_bool(dev->of_node, \"qcom,micbias1-ext-cap\"))\n\t\tpriv->micbias1_cap_mode = MICB_1_EN_EXT_BYP_CAP;\n\telse\n\t\tpriv->micbias1_cap_mode = MICB_1_EN_NO_EXT_BYP_CAP;\n\n\tif (of_property_read_bool(dev->of_node, \"qcom,micbias2-ext-cap\"))\n\t\tpriv->micbias2_cap_mode = MICB_1_EN_EXT_BYP_CAP;\n\telse\n\t\tpriv->micbias2_cap_mode = MICB_1_EN_NO_EXT_BYP_CAP;\n\n\tof_property_read_u32(dev->of_node, \"qcom,micbias-lvl\",\n\t\t\t     &priv->micbias_mv);\n\n\tif (of_property_read_bool(dev->of_node,\n\t\t\t\t  \"qcom,hphl-jack-type-normally-open\"))\n\t\tpriv->hphl_jack_type_normally_open = true;\n\telse\n\t\tpriv->hphl_jack_type_normally_open = false;\n\n\tif (of_property_read_bool(dev->of_node,\n\t\t\t\t  \"qcom,gnd-jack-type-normally-open\"))\n\t\tpriv->gnd_jack_type_normally_open = true;\n\telse\n\t\tpriv->gnd_jack_type_normally_open = false;\n\n\tpriv->mbhc_btn_enabled = true;\n\trval = of_property_read_u32_array(dev->of_node,\n\t\t\t\t\t  \"qcom,mbhc-vthreshold-low\",\n\t\t\t\t\t  &priv->vref_btn_cs[0],\n\t\t\t\t\t  MBHC_MAX_BUTTONS);\n\tif (rval < 0) {\n\t\tpriv->mbhc_btn_enabled = false;\n\t} else {\n\t\trval = of_property_read_u32_array(dev->of_node,\n\t\t\t\t\t\t  \"qcom,mbhc-vthreshold-high\",\n\t\t\t\t\t\t  &priv->vref_btn_micb[0],\n\t\t\t\t\t\t  MBHC_MAX_BUTTONS);\n\t\tif (rval < 0)\n\t\t\tpriv->mbhc_btn_enabled = false;\n\t}\n\n\tif (!priv->mbhc_btn_enabled)\n\t\tdev_err(dev,\n\t\t\t\"DT property missing, MBHC btn detection disabled\\n\");\n\n\n\treturn 0;\n}\n\nstatic int pm8916_wcd_analog_spmi_probe(struct platform_device *pdev)\n{\n\tstruct pm8916_wcd_analog_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tint ret, i, irq;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = pm8916_wcd_analog_parse_dt(dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tpriv->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\n\t\t\t\t    priv->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get regulator supplies %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq_byname(pdev, \"mbhc_switch_int\");\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t       pm8916_mbhc_switch_irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\n\t\t\t       IRQF_ONESHOT,\n\t\t\t       \"mbhc switch irq\", priv);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot request mbhc switch irq\\n\");\n\t\treturn ret;\n\t}\n\n\tif (priv->mbhc_btn_enabled) {\n\t\tirq = platform_get_irq_byname(pdev, \"mbhc_but_press_det\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t       mbhc_btn_press_irq_handler,\n\t\t\t\t       IRQF_TRIGGER_RISING |\n\t\t\t\t       IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t       \"mbhc btn press irq\", priv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"cannot request mbhc button press irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tirq = platform_get_irq_byname(pdev, \"mbhc_but_rel_det\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t       mbhc_btn_release_irq_handler,\n\t\t\t\t       IRQF_TRIGGER_RISING |\n\t\t\t\t       IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t       \"mbhc btn release irq\", priv);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"cannot request mbhc button release irq\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdev_set_drvdata(dev, priv);\n\n\treturn devm_snd_soc_register_component(dev, &pm8916_wcd_analog,\n\t\t\t\t      pm8916_wcd_analog_dai,\n\t\t\t\t      ARRAY_SIZE(pm8916_wcd_analog_dai));\n}\n\nstatic const struct of_device_id pm8916_wcd_analog_spmi_match_table[] = {\n\t{ .compatible = \"qcom,pm8916-wcd-analog-codec\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, pm8916_wcd_analog_spmi_match_table);\n\nstatic struct platform_driver pm8916_wcd_analog_spmi_driver = {\n\t.driver = {\n\t\t   .name = \"qcom,pm8916-wcd-spmi-codec\",\n\t\t   .of_match_table = pm8916_wcd_analog_spmi_match_table,\n\t},\n\t.probe = pm8916_wcd_analog_spmi_probe,\n};\n\nmodule_platform_driver(pm8916_wcd_analog_spmi_driver);\n\nMODULE_AUTHOR(\"Srinivas Kandagatla <srinivas.kandagatla@linaro.org>\");\nMODULE_DESCRIPTION(\"PMIC PM8916 WCD Analog Codec driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}