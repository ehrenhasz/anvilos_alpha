{
  "module_name": "sti-sas.c",
  "hash_id": "3dcc08f6cd88cf34cb18772115f663a43acf29b78ca187dae07bb900143a2d23",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sti-sas.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/mfd/syscon.h>\n\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n\n \n\n \n \n#define STIH407_AUDIO_GLUE_CTRL 0x000000A4\n \n#define STIH407_AUDIO_DAC_CTRL 0x000000A8\n\n \n#define STIH407_DAC_SOFTMUTE\t\t0x0\n#define STIH407_DAC_STANDBY_ANA\t\t0x1\n#define STIH407_DAC_STANDBY\t\t0x2\n\n#define STIH407_DAC_SOFTMUTE_MASK\tBIT(STIH407_DAC_SOFTMUTE)\n#define STIH407_DAC_STANDBY_ANA_MASK    BIT(STIH407_DAC_STANDBY_ANA)\n#define STIH407_DAC_STANDBY_MASK        BIT(STIH407_DAC_STANDBY)\n\n \n#define SPDIF_BIPHASE_ENABLE\t\t0x6\n#define SPDIF_BIPHASE_IDLE\t\t0x7\n\n#define SPDIF_BIPHASE_ENABLE_MASK\tBIT(SPDIF_BIPHASE_ENABLE)\n#define SPDIF_BIPHASE_IDLE_MASK\t\tBIT(SPDIF_BIPHASE_IDLE)\n\nenum {\n\tSTI_SAS_DAI_SPDIF_OUT,\n\tSTI_SAS_DAI_ANALOG_OUT,\n};\n\nstatic const struct reg_default stih407_sas_reg_defaults[] = {\n\t{ STIH407_AUDIO_DAC_CTRL, 0x000000000 },\n\t{ STIH407_AUDIO_GLUE_CTRL, 0x00000040 },\n};\n\nstruct sti_dac_audio {\n\tstruct regmap *regmap;\n\tstruct regmap *virt_regmap;\n\tint mclk;\n};\n\nstruct sti_spdif_audio {\n\tstruct regmap *regmap;\n\tint mclk;\n};\n\n \nstruct sti_sas_dev_data {\n\tconst struct regmap_config *regmap;\n\tconst struct snd_soc_dai_ops *dac_ops;   \n\tconst struct snd_soc_dapm_widget *dapm_widgets;  \n\tconst int num_dapm_widgets;  \n\tconst struct snd_soc_dapm_route *dapm_routes;  \n\tconst int num_dapm_routes;  \n};\n\n \nstruct sti_sas_data {\n\tstruct device *dev;\n\tconst struct sti_sas_dev_data *dev_data;\n\tstruct sti_dac_audio dac;\n\tstruct sti_spdif_audio spdif;\n};\n\n \nstatic int sti_sas_read_reg(void *context, unsigned int reg,\n\t\t\t    unsigned int *value)\n{\n\tstruct sti_sas_data *drvdata = context;\n\tint status;\n\tu32 val;\n\n\tstatus = regmap_read(drvdata->dac.regmap, reg, &val);\n\t*value = (unsigned int)val;\n\n\treturn status;\n}\n\n \nstatic int sti_sas_write_reg(void *context, unsigned int reg,\n\t\t\t     unsigned int value)\n{\n\tstruct sti_sas_data *drvdata = context;\n\n\treturn regmap_write(drvdata->dac.regmap, reg, value);\n}\n\nstatic int  sti_sas_init_sas_registers(struct snd_soc_component *component,\n\t\t\t\t       struct sti_sas_data *data)\n{\n\tint ret;\n\t \n\n\t \n\tret = snd_soc_component_update_bits(component, STIH407_AUDIO_GLUE_CTRL,\n\t\t\t\t  SPDIF_BIPHASE_ENABLE_MASK, 0);\n\n\tif (!ret)\n\t\t \n\t\tret = snd_soc_component_update_bits(component, STIH407_AUDIO_GLUE_CTRL,\n\t\t\t\t\t  SPDIF_BIPHASE_IDLE_MASK, 0);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to update SPDIF registers\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\t \n\tret =  snd_soc_component_update_bits(component, STIH407_AUDIO_DAC_CTRL,\n\t\t\t\t   STIH407_DAC_STANDBY_MASK,\n\t\t\t\t   STIH407_DAC_STANDBY_MASK);\n\n\tif (!ret)\n\t\tret = snd_soc_component_update_bits(component, STIH407_AUDIO_DAC_CTRL,\n\t\t\t\t\t  STIH407_DAC_STANDBY_ANA_MASK,\n\t\t\t\t\t  STIH407_DAC_STANDBY_ANA_MASK);\n\tif (!ret)\n\t\tret = snd_soc_component_update_bits(component, STIH407_AUDIO_DAC_CTRL,\n\t\t\t\t\t  STIH407_DAC_SOFTMUTE_MASK,\n\t\t\t\t\t  STIH407_DAC_SOFTMUTE_MASK);\n\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to update DAC registers\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int sti_sas_dac_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\t \n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC) {\n\t\tdev_err(dai->component->dev,\n\t\t\t\"%s: ERROR: Unsupported clocking 0x%x\\n\",\n\t\t\t__func__, fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget stih407_sas_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUT_DRV(\"DAC standby ana\", STIH407_AUDIO_DAC_CTRL,\n\t\t\t     STIH407_DAC_STANDBY_ANA, 1, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"DAC standby\",  \"dac_p\", STIH407_AUDIO_DAC_CTRL,\n\t\t\t STIH407_DAC_STANDBY, 1),\n\tSND_SOC_DAPM_OUTPUT(\"DAC Output\"),\n};\n\nstatic const struct snd_soc_dapm_route stih407_sas_route[] = {\n\t{\"DAC Output\", NULL, \"DAC standby ana\"},\n\t{\"DAC standby ana\", NULL, \"DAC standby\"},\n};\n\n\nstatic int stih407_sas_dac_mute(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tif (mute) {\n\t\treturn snd_soc_component_update_bits(component, STIH407_AUDIO_DAC_CTRL,\n\t\t\t\t\t    STIH407_DAC_SOFTMUTE_MASK,\n\t\t\t\t\t    STIH407_DAC_SOFTMUTE_MASK);\n\t} else {\n\t\treturn snd_soc_component_update_bits(component, STIH407_AUDIO_DAC_CTRL,\n\t\t\t\t\t    STIH407_DAC_SOFTMUTE_MASK,\n\t\t\t\t\t    0);\n\t}\n}\n\n \nstatic int sti_sas_spdif_set_fmt(struct snd_soc_dai *dai,\n\t\t\t\t unsigned int fmt)\n{\n\tif ((fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) != SND_SOC_DAIFMT_CBC_CFC) {\n\t\tdev_err(dai->component->dev,\n\t\t\t\"%s: ERROR: Unsupported clocking mask 0x%x\\n\",\n\t\t\t__func__, fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sti_sas_spdif_trigger(struct snd_pcm_substream *substream, int cmd,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\n\t\treturn snd_soc_component_update_bits(component, STIH407_AUDIO_GLUE_CTRL,\n\t\t\t\t\t    SPDIF_BIPHASE_ENABLE_MASK,\n\t\t\t\t\t    SPDIF_BIPHASE_ENABLE_MASK);\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\tcase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\treturn snd_soc_component_update_bits(component, STIH407_AUDIO_GLUE_CTRL,\n\t\t\t\t\t    SPDIF_BIPHASE_ENABLE_MASK,\n\t\t\t\t\t    0);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool sti_sas_volatile_register(struct device *dev, unsigned int reg)\n{\n\tif (reg == STIH407_AUDIO_GLUE_CTRL)\n\t\treturn true;\n\n\treturn false;\n}\n\n \n\n \nstatic int sti_sas_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t      unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sti_sas_data *drvdata = dev_get_drvdata(component->dev);\n\n\tif (dir == SND_SOC_CLOCK_OUT)\n\t\treturn 0;\n\n\tif (clk_id != 0)\n\t\treturn -EINVAL;\n\n\tswitch (dai->id) {\n\tcase STI_SAS_DAI_SPDIF_OUT:\n\t\tdrvdata->spdif.mclk = freq;\n\t\tbreak;\n\n\tcase STI_SAS_DAI_ANALOG_OUT:\n\t\tdrvdata->dac.mclk = freq;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sti_sas_prepare(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sti_sas_data *drvdata = dev_get_drvdata(component->dev);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tswitch (dai->id) {\n\tcase STI_SAS_DAI_SPDIF_OUT:\n\t\tif ((drvdata->spdif.mclk / runtime->rate) != 128) {\n\t\t\tdev_err(component->dev, \"unexpected mclk-fs ratio\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase STI_SAS_DAI_ANALOG_OUT:\n\t\tif ((drvdata->dac.mclk / runtime->rate) != 256) {\n\t\t\tdev_err(component->dev, \"unexpected mclk-fs ratio\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops stih407_dac_ops = {\n\t.set_fmt = sti_sas_dac_set_fmt,\n\t.mute_stream = stih407_sas_dac_mute,\n\t.prepare = sti_sas_prepare,\n\t.set_sysclk = sti_sas_set_sysclk,\n};\n\nstatic const struct regmap_config stih407_sas_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.fast_io = true,\n\t.max_register = STIH407_AUDIO_DAC_CTRL,\n\t.reg_defaults = stih407_sas_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(stih407_sas_reg_defaults),\n\t.volatile_reg = sti_sas_volatile_register,\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_read = sti_sas_read_reg,\n\t.reg_write = sti_sas_write_reg,\n};\n\nstatic const struct sti_sas_dev_data stih407_data = {\n\t.regmap = &stih407_sas_regmap,\n\t.dac_ops = &stih407_dac_ops,\n\t.dapm_widgets = stih407_sas_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(stih407_sas_dapm_widgets),\n\t.dapm_routes =\tstih407_sas_route,\n\t.num_dapm_routes = ARRAY_SIZE(stih407_sas_route),\n};\n\nstatic struct snd_soc_dai_driver sti_sas_dai[] = {\n\t{\n\t\t.name = \"sas-dai-spdif-out\",\n\t\t.id = STI_SAS_DAI_SPDIF_OUT,\n\t\t.playback = {\n\t\t\t.stream_name = \"spdif_p\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\n\t\t\t\t SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 |\n\t\t\t\t SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 |\n\t\t\t\t SNDRV_PCM_RATE_192000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t\t.ops = (struct snd_soc_dai_ops[]) {\n\t\t\t{\n\t\t\t\t.set_fmt = sti_sas_spdif_set_fmt,\n\t\t\t\t.trigger = sti_sas_spdif_trigger,\n\t\t\t\t.set_sysclk = sti_sas_set_sysclk,\n\t\t\t\t.prepare = sti_sas_prepare,\n\t\t\t}\n\t\t},\n\t},\n\t{\n\t\t.name = \"sas-dai-dac\",\n\t\t.id = STI_SAS_DAI_ANALOG_OUT,\n\t\t.playback = {\n\t\t\t.stream_name = \"dac_p\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = SNDRV_PCM_FMTBIT_S16_LE |\n\t\t\t\t   SNDRV_PCM_FMTBIT_S32_LE,\n\t\t},\n\t},\n};\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sti_sas_resume(struct snd_soc_component *component)\n{\n\tstruct sti_sas_data *drvdata = dev_get_drvdata(component->dev);\n\n\treturn sti_sas_init_sas_registers(component, drvdata);\n}\n#else\n#define sti_sas_resume NULL\n#endif\n\nstatic int sti_sas_component_probe(struct snd_soc_component *component)\n{\n\tstruct sti_sas_data *drvdata = dev_get_drvdata(component->dev);\n\n\treturn sti_sas_init_sas_registers(component, drvdata);\n}\n\nstatic struct snd_soc_component_driver sti_sas_driver = {\n\t.probe\t\t\t= sti_sas_component_probe,\n\t.resume\t\t\t= sti_sas_resume,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id sti_sas_dev_match[] = {\n\t{\n\t\t.compatible = \"st,stih407-sas-codec\",\n\t\t.data = &stih407_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sti_sas_dev_match);\n\nstatic int sti_sas_driver_probe(struct platform_device *pdev)\n{\n\tstruct device_node *pnode = pdev->dev.of_node;\n\tstruct sti_sas_data *drvdata;\n\tconst struct of_device_id *of_id;\n\n\t \n\tdrvdata = devm_kzalloc(&pdev->dev, sizeof(struct sti_sas_data),\n\t\t\t       GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\n\t \n\tof_id = of_match_node(sti_sas_dev_match, pnode);\n\tif (!of_id->data) {\n\t\tdev_err(&pdev->dev, \"data associated to device is missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdrvdata->dev_data = (struct sti_sas_dev_data *)of_id->data;\n\n\t \n\tdrvdata->dev = &pdev->dev;\n\n\t \n\tdrvdata->dac.virt_regmap = devm_regmap_init(&pdev->dev, NULL, drvdata,\n\t\t\t\t\t\t    drvdata->dev_data->regmap);\n\tif (IS_ERR(drvdata->dac.virt_regmap)) {\n\t\tdev_err(&pdev->dev, \"audio registers not enabled\\n\");\n\t\treturn PTR_ERR(drvdata->dac.virt_regmap);\n\t}\n\n\t \n\tdrvdata->dac.regmap =\n\t\tsyscon_regmap_lookup_by_phandle(pnode, \"st,syscfg\");\n\tif (IS_ERR(drvdata->dac.regmap)) {\n\t\tdev_err(&pdev->dev, \"syscon registers not available\\n\");\n\t\treturn PTR_ERR(drvdata->dac.regmap);\n\t}\n\tdrvdata->spdif.regmap = drvdata->dac.regmap;\n\n\tsti_sas_dai[STI_SAS_DAI_ANALOG_OUT].ops = drvdata->dev_data->dac_ops;\n\n\t \n\tsti_sas_driver.dapm_widgets = drvdata->dev_data->dapm_widgets;\n\tsti_sas_driver.num_dapm_widgets = drvdata->dev_data->num_dapm_widgets;\n\n\tsti_sas_driver.dapm_routes = drvdata->dev_data->dapm_routes;\n\tsti_sas_driver.num_dapm_routes = drvdata->dev_data->num_dapm_routes;\n\n\t \n\tdev_set_drvdata(&pdev->dev, drvdata);\n\n\treturn devm_snd_soc_register_component(&pdev->dev, &sti_sas_driver,\n\t\t\t\t\tsti_sas_dai,\n\t\t\t\t\tARRAY_SIZE(sti_sas_dai));\n}\n\nstatic struct platform_driver sti_sas_platform_driver = {\n\t.driver = {\n\t\t.name = \"sti-sas-codec\",\n\t\t.of_match_table = sti_sas_dev_match,\n\t},\n\t.probe = sti_sas_driver_probe,\n};\n\nmodule_platform_driver(sti_sas_platform_driver);\n\nMODULE_DESCRIPTION(\"audio codec for STMicroelectronics sti platforms\");\nMODULE_AUTHOR(\"Arnaud.pouliquen@st.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}