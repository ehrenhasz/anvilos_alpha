{
  "module_name": "wm8741.c",
  "hash_id": "f0b9f2f1770889709ce0ea594ea73b614470e18b30798769e467da97ce3a8019",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8741.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8741.h\"\n\n#define WM8741_NUM_SUPPLIES 2\nstatic const char *wm8741_supply_names[WM8741_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"DVDD\",\n};\n\n \nstruct wm8741_priv {\n\tstruct wm8741_platform_data pdata;\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8741_NUM_SUPPLIES];\n\tunsigned int sysclk;\n\tconst struct snd_pcm_hw_constraint_list *sysclk_constraints;\n};\n\nstatic const struct reg_default wm8741_reg_defaults[] = {\n\t{  0, 0x0000 },      \n\t{  1, 0x0000 },      \n\t{  2, 0x0000 },      \n\t{  3, 0x0000 },      \n\t{  4, 0x0000 },      \n\t{  5, 0x000A },      \n\t{  6, 0x0000 },      \n\t{  7, 0x0000 },      \n\t{  8, 0x0002 },      \n\t{ 32, 0x0002 },      \n};\n\nstatic int wm8741_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8741_RESET, 0);\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv_fine, -12700, 13, 0);\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12700, 400, 0);\n\nstatic const struct snd_kcontrol_new wm8741_snd_controls_stereo[] = {\nSOC_DOUBLE_R_TLV(\"Fine Playback Volume\", WM8741_DACLLSB_ATTENUATION,\n\t\t WM8741_DACRLSB_ATTENUATION, 1, 255, 1, dac_tlv_fine),\nSOC_DOUBLE_R_TLV(\"Playback Volume\", WM8741_DACLMSB_ATTENUATION,\n\t\t WM8741_DACRMSB_ATTENUATION, 0, 511, 1, dac_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm8741_snd_controls_mono_left[] = {\nSOC_SINGLE_TLV(\"Fine Playback Volume\", WM8741_DACLLSB_ATTENUATION,\n\t\t 1, 255, 1, dac_tlv_fine),\nSOC_SINGLE_TLV(\"Playback Volume\", WM8741_DACLMSB_ATTENUATION,\n\t\t 0, 511, 1, dac_tlv),\n};\n\nstatic const struct snd_kcontrol_new wm8741_snd_controls_mono_right[] = {\nSOC_SINGLE_TLV(\"Fine Playback Volume\", WM8741_DACRLSB_ATTENUATION,\n\t\t1, 255, 1, dac_tlv_fine),\nSOC_SINGLE_TLV(\"Playback Volume\", WM8741_DACRMSB_ATTENUATION,\n\t\t0, 511, 1, dac_tlv),\n};\n\nstatic const struct snd_soc_dapm_widget wm8741_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DACL\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_DAC(\"DACR\", \"Playback\", SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"VOUTLP\"),\nSND_SOC_DAPM_OUTPUT(\"VOUTLN\"),\nSND_SOC_DAPM_OUTPUT(\"VOUTRP\"),\nSND_SOC_DAPM_OUTPUT(\"VOUTRN\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8741_dapm_routes[] = {\n\t{ \"VOUTLP\", NULL, \"DACL\" },\n\t{ \"VOUTLN\", NULL, \"DACL\" },\n\t{ \"VOUTRP\", NULL, \"DACR\" },\n\t{ \"VOUTRN\", NULL, \"DACR\" },\n};\n\nstatic const unsigned int rates_11289[] = {\n\t44100, 88200,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_11289 = {\n\t.count\t= ARRAY_SIZE(rates_11289),\n\t.list\t= rates_11289,\n};\n\nstatic const unsigned int rates_12288[] = {\n\t32000, 48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_12288 = {\n\t.count\t= ARRAY_SIZE(rates_12288),\n\t.list\t= rates_12288,\n};\n\nstatic const unsigned int rates_16384[] = {\n\t32000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_16384 = {\n\t.count\t= ARRAY_SIZE(rates_16384),\n\t.list\t= rates_16384,\n};\n\nstatic const unsigned int rates_16934[] = {\n\t44100, 88200,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_16934 = {\n\t.count\t= ARRAY_SIZE(rates_16934),\n\t.list\t= rates_16934,\n};\n\nstatic const unsigned int rates_18432[] = {\n\t48000, 96000,\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_18432 = {\n\t.count\t= ARRAY_SIZE(rates_18432),\n\t.list\t= rates_18432,\n};\n\nstatic const unsigned int rates_22579[] = {\n\t44100, 88200, 176400\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_22579 = {\n\t.count\t= ARRAY_SIZE(rates_22579),\n\t.list\t= rates_22579,\n};\n\nstatic const unsigned int rates_24576[] = {\n\t32000, 48000, 96000, 192000\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_24576 = {\n\t.count\t= ARRAY_SIZE(rates_24576),\n\t.list\t= rates_24576,\n};\n\nstatic const unsigned int rates_36864[] = {\n\t48000, 96000, 192000\n};\n\nstatic const struct snd_pcm_hw_constraint_list constraints_36864 = {\n\t.count\t= ARRAY_SIZE(rates_36864),\n\t.list\t= rates_36864,\n};\n\nstatic int wm8741_startup(struct snd_pcm_substream *substream,\n\t\t\t  struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\n\tif (wm8741->sysclk)\n\t\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\tSNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\twm8741->sysclk_constraints);\n\n\treturn 0;\n}\n\nstatic int wm8741_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\tunsigned int iface, mode;\n\tint i;\n\n\t \n\tif (!wm8741->sysclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"No MCLK configured, call set_sysclk() on init or in hw_params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < wm8741->sysclk_constraints->count; i++) {\n\t\tif (wm8741->sysclk_constraints->list[i] == params_rate(params))\n\t\t\tbreak;\n\t}\n\n\tif (i == wm8741->sysclk_constraints->count) {\n\t\tdev_err(component->dev, \"LRCLK %d unsupported with MCLK %d\\n\",\n\t\t\tparams_rate(params), wm8741->sysclk);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tiface = 0x0;\n\t\tbreak;\n\tcase 20:\n\t\tiface = 0x1;\n\t\tbreak;\n\tcase 24:\n\t\tiface = 0x2;\n\t\tbreak;\n\tcase 32:\n\t\tiface = 0x3;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(component->dev, \"wm8741_hw_params:    Unsupported bit size param = %d\",\n\t\t\tparams_width(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (params_rate(params) > 96000)\n\t\tmode = 0x40;\n\telse if (params_rate(params) > 48000)\n\t\tmode = 0x20;\n\telse\n\t\tmode = 0x00;\n\n\tdev_dbg(component->dev, \"wm8741_hw_params:    bit size param = %d, rate param = %d\",\n\t\tparams_width(params), params_rate(params));\n\n\tsnd_soc_component_update_bits(component, WM8741_FORMAT_CONTROL, WM8741_IWL_MASK,\n\t\t\t    iface);\n\tsnd_soc_component_update_bits(component, WM8741_MODE_CONTROL_1, WM8741_OSR_MASK,\n\t\t\t    mode);\n\n\treturn 0;\n}\n\nstatic int wm8741_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"wm8741_set_dai_sysclk info: freq=%dHz\\n\", freq);\n\n\tswitch (freq) {\n\tcase 0:\n\t\twm8741->sysclk_constraints = NULL;\n\t\tbreak;\n\tcase 11289600:\n\t\twm8741->sysclk_constraints = &constraints_11289;\n\t\tbreak;\n\tcase 12288000:\n\t\twm8741->sysclk_constraints = &constraints_12288;\n\t\tbreak;\n\tcase 16384000:\n\t\twm8741->sysclk_constraints = &constraints_16384;\n\t\tbreak;\n\tcase 16934400:\n\t\twm8741->sysclk_constraints = &constraints_16934;\n\t\tbreak;\n\tcase 18432000:\n\t\twm8741->sysclk_constraints = &constraints_18432;\n\t\tbreak;\n\tcase 22579200:\n\tcase 33868800:\n\t\twm8741->sysclk_constraints = &constraints_22579;\n\t\tbreak;\n\tcase 24576000:\n\t\twm8741->sysclk_constraints = &constraints_24576;\n\t\tbreak;\n\tcase 36864000:\n\t\twm8741->sysclk_constraints = &constraints_36864;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\twm8741->sysclk = freq;\n\treturn 0;\n}\n\nstatic int wm8741_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int iface;\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tiface = 0x08;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tiface = 0x00;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tiface = 0x04;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tiface = 0x0C;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tiface = 0x1C;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tiface |= 0x10;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tiface |= 0x20;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tiface |= 0x30;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\n\tdev_dbg(component->dev, \"wm8741_set_dai_fmt:    Format=%x, Clock Inv=%x\\n\",\n\t\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK,\n\t\t\t\t((fmt & SND_SOC_DAIFMT_INV_MASK)));\n\n\tsnd_soc_component_update_bits(component, WM8741_FORMAT_CONTROL,\n\t\t\t    WM8741_BCP_MASK | WM8741_LRP_MASK | WM8741_FMT_MASK,\n\t\t\t    iface);\n\n\treturn 0;\n}\n\nstatic int wm8741_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tsnd_soc_component_update_bits(component, WM8741_VOLUME_CONTROL,\n\t\t\tWM8741_SOFT_MASK, !!mute << WM8741_SOFT_SHIFT);\n\treturn 0;\n}\n\n#define WM8741_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\t\t\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \\\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_176400 | \\\n\t\t\tSNDRV_PCM_RATE_192000)\n\n#define WM8741_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8741_dai_ops = {\n\t.startup\t= wm8741_startup,\n\t.hw_params\t= wm8741_hw_params,\n\t.set_sysclk\t= wm8741_set_dai_sysclk,\n\t.set_fmt\t= wm8741_set_dai_fmt,\n\t.mute_stream\t= wm8741_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver wm8741_dai = {\n\t.name = \"wm8741\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = WM8741_RATES,\n\t\t.formats = WM8741_FORMATS,\n\t},\n\t.ops = &wm8741_dai_ops,\n};\n\n#ifdef CONFIG_PM\nstatic int wm8741_resume(struct snd_soc_component *component)\n{\n\tsnd_soc_component_cache_sync(component);\n\treturn 0;\n}\n#else\n#define wm8741_resume NULL\n#endif\n\nstatic int wm8741_configure(struct snd_soc_component *component)\n{\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\n\t \n\tswitch (wm8741->pdata.diff_mode) {\n\tcase WM8741_DIFF_MODE_STEREO:\n\tcase WM8741_DIFF_MODE_STEREO_REVERSED:\n\tcase WM8741_DIFF_MODE_MONO_LEFT:\n\tcase WM8741_DIFF_MODE_MONO_RIGHT:\n\t\tsnd_soc_component_update_bits(component, WM8741_MODE_CONTROL_2,\n\t\t\t\tWM8741_DIFF_MASK,\n\t\t\t\twm8741->pdata.diff_mode << WM8741_DIFF_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsnd_soc_component_update_bits(component, WM8741_DACLLSB_ATTENUATION,\n\t\t\tWM8741_UPDATELL, WM8741_UPDATELL);\n\tsnd_soc_component_update_bits(component, WM8741_DACLMSB_ATTENUATION,\n\t\t\tWM8741_UPDATELM, WM8741_UPDATELM);\n\tsnd_soc_component_update_bits(component, WM8741_DACRLSB_ATTENUATION,\n\t\t\tWM8741_UPDATERL, WM8741_UPDATERL);\n\tsnd_soc_component_update_bits(component, WM8741_DACRMSB_ATTENUATION,\n\t\t\tWM8741_UPDATERM, WM8741_UPDATERM);\n\n\treturn 0;\n}\n\nstatic int wm8741_add_controls(struct snd_soc_component *component)\n{\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\n\tswitch (wm8741->pdata.diff_mode) {\n\tcase WM8741_DIFF_MODE_STEREO:\n\tcase WM8741_DIFF_MODE_STEREO_REVERSED:\n\t\tsnd_soc_add_component_controls(component,\n\t\t\t\twm8741_snd_controls_stereo,\n\t\t\t\tARRAY_SIZE(wm8741_snd_controls_stereo));\n\t\tbreak;\n\tcase WM8741_DIFF_MODE_MONO_LEFT:\n\t\tsnd_soc_add_component_controls(component,\n\t\t\t\twm8741_snd_controls_mono_left,\n\t\t\t\tARRAY_SIZE(wm8741_snd_controls_mono_left));\n\t\tbreak;\n\tcase WM8741_DIFF_MODE_MONO_RIGHT:\n\t\tsnd_soc_add_component_controls(component,\n\t\t\t\twm8741_snd_controls_mono_right,\n\t\t\t\tARRAY_SIZE(wm8741_snd_controls_mono_right));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8741_probe(struct snd_soc_component *component)\n{\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\tint ret = 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8741->supplies),\n\t\t\t\t    wm8741->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_get;\n\t}\n\n\tret = wm8741_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tret = wm8741_configure(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to change default settings\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tret = wm8741_add_controls(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to add controls\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tdev_dbg(component->dev, \"Successful registration\\n\");\n\treturn ret;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8741->supplies), wm8741->supplies);\nerr_get:\n\treturn ret;\n}\n\nstatic void wm8741_remove(struct snd_soc_component *component)\n{\n\tstruct wm8741_priv *wm8741 = snd_soc_component_get_drvdata(component);\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8741->supplies), wm8741->supplies);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8741 = {\n\t.probe\t\t\t= wm8741_probe,\n\t.remove\t\t\t= wm8741_remove,\n\t.resume\t\t\t= wm8741_resume,\n\t.dapm_widgets\t\t= wm8741_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8741_dapm_widgets),\n\t.dapm_routes\t\t= wm8741_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8741_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8741_of_match[] = {\n\t{ .compatible = \"wlf,wm8741\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, wm8741_of_match);\n\nstatic const struct regmap_config wm8741_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8741_MAX_REGISTER,\n\n\t.reg_defaults = wm8741_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8741_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic int wm8741_set_pdata(struct device *dev, struct wm8741_priv *wm8741)\n{\n\tconst struct wm8741_platform_data *pdata = dev_get_platdata(dev);\n\tu32 diff_mode;\n\n\tif (dev->of_node) {\n\t\tif (of_property_read_u32(dev->of_node, \"diff-mode\", &diff_mode)\n\t\t\t\t>= 0)\n\t\t\twm8741->pdata.diff_mode = diff_mode;\n\t} else {\n\t\tif (pdata != NULL)\n\t\t\tmemcpy(&wm8741->pdata, pdata, sizeof(wm8741->pdata));\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8741_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8741_priv *wm8741;\n\tint ret, i;\n\n\twm8741 = devm_kzalloc(&i2c->dev, sizeof(struct wm8741_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8741 == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8741->supplies); i++)\n\t\twm8741->supplies[i].supply = wm8741_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8741->supplies),\n\t\t\t\t      wm8741->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8741->regmap = devm_regmap_init_i2c(i2c, &wm8741_regmap);\n\tif (IS_ERR(wm8741->regmap)) {\n\t\tret = PTR_ERR(wm8741->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8741_set_pdata(&i2c->dev, wm8741);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to set pdata: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8741);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t     &soc_component_dev_wm8741, &wm8741_dai, 1);\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8741_i2c_id[] = {\n\t{ \"wm8741\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8741_i2c_id);\n\nstatic struct i2c_driver wm8741_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8741\",\n\t\t.of_match_table = wm8741_of_match,\n\t},\n\t.probe = wm8741_i2c_probe,\n\t.id_table = wm8741_i2c_id,\n};\n#endif\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8741_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8741_priv *wm8741;\n\tint ret, i;\n\n\twm8741 = devm_kzalloc(&spi->dev, sizeof(struct wm8741_priv),\n\t\t\t     GFP_KERNEL);\n\tif (wm8741 == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8741->supplies); i++)\n\t\twm8741->supplies[i].supply = wm8741_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8741->supplies),\n\t\t\t\t      wm8741->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&spi->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8741->regmap = devm_regmap_init_spi(spi, &wm8741_regmap);\n\tif (IS_ERR(wm8741->regmap)) {\n\t\tret = PTR_ERR(wm8741->regmap);\n\t\tdev_err(&spi->dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wm8741_set_pdata(&spi->dev, wm8741);\n\tif (ret != 0) {\n\t\tdev_err(&spi->dev, \"Failed to set pdata: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspi_set_drvdata(spi, wm8741);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&soc_component_dev_wm8741, &wm8741_dai, 1);\n\treturn ret;\n}\n\nstatic struct spi_driver wm8741_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8741\",\n\t\t.of_match_table = wm8741_of_match,\n\t},\n\t.probe\t\t= wm8741_spi_probe,\n};\n#endif  \n\nstatic int __init wm8741_modinit(void)\n{\n\tint ret = 0;\n\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8741_i2c_driver);\n\tif (ret != 0)\n\t\tpr_err(\"Failed to register WM8741 I2C driver: %d\\n\", ret);\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8741_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register wm8741 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\n\treturn ret;\n}\nmodule_init(wm8741_modinit);\n\nstatic void __exit wm8741_exit(void)\n{\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8741_spi_driver);\n#endif\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8741_i2c_driver);\n#endif\n}\nmodule_exit(wm8741_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8741 driver\");\nMODULE_AUTHOR(\"Ian Lartey <ian@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}