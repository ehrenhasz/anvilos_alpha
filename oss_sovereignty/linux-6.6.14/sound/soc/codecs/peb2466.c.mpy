{
  "module_name": "peb2466.c",
  "hash_id": "276f5cdbd42c6c6fa385486ad0a872101176d693d2462fa5d467f58b6d94f2cd",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/peb2466.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <asm/unaligned.h>\n#include <linux/clk.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#define PEB2466_NB_CHANNEL\t4\n\nstruct peb2466_lookup {\n\tu8 (*table)[4];\n\tunsigned int count;\n};\n\n#define PEB2466_TLV_SIZE  (sizeof((unsigned int []){TLV_DB_SCALE_ITEM(0, 0, 0)}) / \\\n\t\t\t   sizeof(unsigned int))\n\nstruct peb2466_lkup_ctrl {\n\tint reg;\n\tunsigned int index;\n\tconst struct peb2466_lookup *lookup;\n\tunsigned int tlv_array[PEB2466_TLV_SIZE];\n};\n\nstruct peb2466 {\n\tstruct spi_device *spi;\n\tstruct clk *mclk;\n\tstruct gpio_desc *reset_gpio;\n\tu8 spi_tx_buf[2 + 8];  \n\tu8 spi_rx_buf[2 + 8];  \n\tstruct regmap *regmap;\n\tstruct {\n\t\tstruct peb2466_lookup ax_lookup;\n\t\tstruct peb2466_lookup ar_lookup;\n\t\tstruct peb2466_lkup_ctrl ax_lkup_ctrl;\n\t\tstruct peb2466_lkup_ctrl ar_lkup_ctrl;\n\t\tunsigned int tg1_freq_item;\n\t\tunsigned int tg2_freq_item;\n\t} ch[PEB2466_NB_CHANNEL];\n\tint max_chan_playback;\n\tint max_chan_capture;\n\tstruct {\n\t\tstruct gpio_chip gpio_chip;\n\t\tstruct mutex lock;\n\t\tstruct {\n\t\t\tunsigned int xr0;\n\t\t\tunsigned int xr1;\n\t\t\tunsigned int xr2;\n\t\t\tunsigned int xr3;\n\t\t} cache;\n\t} gpio;\n};\n\n#define PEB2466_CMD_R\t(1 << 5)\n#define PEB2466_CMD_W\t(0 << 5)\n\n#define PEB2466_CMD_MASK 0x18\n#define PEB2466_CMD_XOP  0x18   \n#define PEB2466_CMD_SOP  0x10   \n#define PEB2466_CMD_COP  0x00   \n#define PEB2466_CMD_COP1 0x08   \n\n#define PEB2466_MAKE_XOP(_lsel)      (PEB2466_CMD_XOP | (_lsel))\n#define PEB2466_MAKE_SOP(_ad, _lsel) (PEB2466_CMD_SOP | ((_ad) << 6) | (_lsel))\n#define PEB2466_MAKE_COP(_ad, _code) (PEB2466_CMD_COP | ((_ad) << 6) | (_code))\n\n#define PEB2466_CR0(_ch)\tPEB2466_MAKE_SOP(_ch, 0x0)\n#define   PEB2466_CR0_TH\t\t(1 << 7)\n#define   PEB2466_CR0_IMR1\t\t(1 << 6)\n#define   PEB2466_CR0_FRX\t\t(1 << 5)\n#define   PEB2466_CR0_FRR\t\t(1 << 4)\n#define   PEB2466_CR0_AX\t\t(1 << 3)\n#define   PEB2466_CR0_AR\t\t(1 << 2)\n#define   PEB2466_CR0_THSEL_MASK\t(0x3 << 0)\n#define   PEB2466_CR0_THSEL(_set)\t((_set) << 0)\n\n#define PEB2466_CR1(_ch)\tPEB2466_MAKE_SOP(_ch, 0x1)\n#define   PEB2466_CR1_ETG2\t\t(1 << 7)\n#define   PEB2466_CR1_ETG1\t\t(1 << 6)\n#define   PEB2466_CR1_PTG2\t\t(1 << 5)\n#define   PEB2466_CR1_PTG1\t\t(1 << 4)\n#define   PEB2466_CR1_LAW_MASK\t\t(1 << 3)\n#define   PEB2466_CR1_LAW_ALAW\t\t(0 << 3)\n#define   PEB2466_CR1_LAW_MULAW\t\t(1 << 3)\n#define   PEB2466_CR1_PU\t\t(1 << 0)\n\n#define PEB2466_CR2(_ch)\tPEB2466_MAKE_SOP(_ch, 0x2)\n#define PEB2466_CR3(_ch)\tPEB2466_MAKE_SOP(_ch, 0x3)\n#define PEB2466_CR4(_ch)\tPEB2466_MAKE_SOP(_ch, 0x4)\n#define PEB2466_CR5(_ch)\tPEB2466_MAKE_SOP(_ch, 0x5)\n\n#define PEB2466_XR0\t\tPEB2466_MAKE_XOP(0x0)\n#define PEB2466_XR1\t\tPEB2466_MAKE_XOP(0x1)\n#define PEB2466_XR2\t\tPEB2466_MAKE_XOP(0x2)\n#define PEB2466_XR3\t\tPEB2466_MAKE_XOP(0x3)\n#define PEB2466_XR4\t\tPEB2466_MAKE_XOP(0x4)\n#define PEB2466_XR5\t\tPEB2466_MAKE_XOP(0x5)\n#define   PEB2466_XR5_MCLK_1536\t\t(0x0 << 6)\n#define   PEB2466_XR5_MCLK_2048\t\t(0x1 << 6)\n#define   PEB2466_XR5_MCLK_4096\t\t(0x2 << 6)\n#define   PEB2466_XR5_MCLK_8192\t\t(0x3 << 6)\n\n#define PEB2466_XR6\t\tPEB2466_MAKE_XOP(0x6)\n#define   PEB2466_XR6_PCM_OFFSET(_off)\t((_off) << 0)\n\n#define PEB2466_XR7\t\tPEB2466_MAKE_XOP(0x7)\n\n#define PEB2466_TH_FILTER_P1(_ch)\tPEB2466_MAKE_COP(_ch, 0x0)\n#define PEB2466_TH_FILTER_P2(_ch)\tPEB2466_MAKE_COP(_ch, 0x1)\n#define PEB2466_TH_FILTER_P3(_ch)\tPEB2466_MAKE_COP(_ch, 0x2)\n#define PEB2466_IMR1_FILTER_P1(_ch)\tPEB2466_MAKE_COP(_ch, 0x4)\n#define PEB2466_IMR1_FILTER_P2(_ch)\tPEB2466_MAKE_COP(_ch, 0x5)\n#define PEB2466_FRX_FILTER(_ch)\t\tPEB2466_MAKE_COP(_ch, 0x6)\n#define PEB2466_FRR_FILTER(_ch)\t\tPEB2466_MAKE_COP(_ch, 0x7)\n#define PEB2466_AX_FILTER(_ch)\t\tPEB2466_MAKE_COP(_ch, 0x8)\n#define PEB2466_AR_FILTER(_ch)\t\tPEB2466_MAKE_COP(_ch, 0x9)\n#define PEB2466_TG1(_ch)\t\tPEB2466_MAKE_COP(_ch, 0xc)\n#define PEB2466_TG2(_ch)\t\tPEB2466_MAKE_COP(_ch, 0xd)\n\nstatic int peb2466_write_byte(struct peb2466 *peb2466, u8 cmd, u8 val)\n{\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf = &peb2466->spi_tx_buf,\n\t\t.len = 2,\n\t};\n\n\tpeb2466->spi_tx_buf[0] = cmd | PEB2466_CMD_W;\n\tpeb2466->spi_tx_buf[1] = val;\n\n\tdev_dbg(&peb2466->spi->dev, \"write byte (cmd %02x) %02x\\n\",\n\t\tpeb2466->spi_tx_buf[0], peb2466->spi_tx_buf[1]);\n\n\treturn spi_sync_transfer(peb2466->spi, &xfer, 1);\n}\n\nstatic int peb2466_read_byte(struct peb2466 *peb2466, u8 cmd, u8 *val)\n{\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf = &peb2466->spi_tx_buf,\n\t\t.rx_buf = &peb2466->spi_rx_buf,\n\t\t.len = 3,\n\t};\n\tint ret;\n\n\tpeb2466->spi_tx_buf[0] = cmd | PEB2466_CMD_R;\n\n\tret = spi_sync_transfer(peb2466->spi, &xfer, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (peb2466->spi_rx_buf[1] != 0x81) {\n\t\tdev_err(&peb2466->spi->dev,\n\t\t\t\"spi xfer rd (cmd %02x) invalid ident byte (0x%02x)\\n\",\n\t\t\tpeb2466->spi_tx_buf[0], peb2466->spi_rx_buf[1]);\n\t\treturn -EILSEQ;\n\t}\n\n\t*val = peb2466->spi_rx_buf[2];\n\n\tdev_dbg(&peb2466->spi->dev, \"read byte (cmd %02x) %02x\\n\",\n\t\tpeb2466->spi_tx_buf[0], *val);\n\n\treturn 0;\n}\n\nstatic int peb2466_write_buf(struct peb2466 *peb2466, u8 cmd, const u8 *buf, unsigned int len)\n{\n\tstruct spi_transfer xfer = {\n\t\t.tx_buf = &peb2466->spi_tx_buf,\n\t\t.len = len + 1,\n\t};\n\n\tif (len > 8)\n\t\treturn -EINVAL;\n\n\tpeb2466->spi_tx_buf[0] = cmd | PEB2466_CMD_W;\n\tmemcpy(&peb2466->spi_tx_buf[1], buf, len);\n\n\tdev_dbg(&peb2466->spi->dev, \"write buf (cmd %02x, %u) %*ph\\n\",\n\t\tpeb2466->spi_tx_buf[0], len, len, &peb2466->spi_tx_buf[1]);\n\n\treturn spi_sync_transfer(peb2466->spi, &xfer, 1);\n}\n\nstatic int peb2466_reg_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct peb2466 *peb2466 = context;\n\tint ret;\n\n\t \n\tswitch (reg & PEB2466_CMD_MASK) {\n\tcase PEB2466_CMD_XOP:\n\tcase PEB2466_CMD_SOP:\n\t\tret = peb2466_write_byte(peb2466, reg, val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&peb2466->spi->dev, \"Not a XOP or SOP command\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int peb2466_reg_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct peb2466 *peb2466 = context;\n\tint ret;\n\tu8 tmp;\n\n\t \n\tswitch (reg & PEB2466_CMD_MASK) {\n\tcase PEB2466_CMD_XOP:\n\tcase PEB2466_CMD_SOP:\n\t\tret = peb2466_read_byte(peb2466, reg, &tmp);\n\t\t*val = tmp;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&peb2466->spi->dev, \"Not a XOP or SOP command\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic const struct regmap_config peb2466_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xFF,\n\t.reg_write = peb2466_reg_write,\n\t.reg_read = peb2466_reg_read,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic int peb2466_lkup_ctrl_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_info *uinfo)\n{\n\tstruct peb2466_lkup_ctrl *lkup_ctrl =\n\t\t(struct peb2466_lkup_ctrl *)kcontrol->private_value;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = lkup_ctrl->lookup->count - 1;\n\treturn 0;\n}\n\nstatic int peb2466_lkup_ctrl_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct peb2466_lkup_ctrl *lkup_ctrl =\n\t\t(struct peb2466_lkup_ctrl *)kcontrol->private_value;\n\n\tucontrol->value.integer.value[0] = lkup_ctrl->index;\n\treturn 0;\n}\n\nstatic int peb2466_lkup_ctrl_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct peb2466_lkup_ctrl *lkup_ctrl =\n\t\t(struct peb2466_lkup_ctrl *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tunsigned int index;\n\tint ret;\n\n\tindex = ucontrol->value.integer.value[0];\n\tif (index >= lkup_ctrl->lookup->count)\n\t\treturn -EINVAL;\n\n\tif (index == lkup_ctrl->index)\n\t\treturn 0;\n\n\tret = peb2466_write_buf(peb2466, lkup_ctrl->reg,\n\t\t\t\tlkup_ctrl->lookup->table[index], 4);\n\tif (ret)\n\t\treturn ret;\n\n\tlkup_ctrl->index = index;\n\treturn 1;  \n}\n\nstatic int peb2466_add_lkup_ctrl(struct snd_soc_component *component,\n\t\t\t\t struct peb2466_lkup_ctrl *lkup_ctrl,\n\t\t\t\t const char *name, int min_val, int step)\n{\n\tDECLARE_TLV_DB_SCALE(tlv_array, min_val, step, 0);\n\tstruct snd_kcontrol_new control = {0};\n\n\tBUILD_BUG_ON(sizeof(lkup_ctrl->tlv_array) < sizeof(tlv_array));\n\tmemcpy(lkup_ctrl->tlv_array, tlv_array, sizeof(tlv_array));\n\n\tcontrol.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\n\tcontrol.name = name;\n\tcontrol.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE;\n\tcontrol.tlv.p = lkup_ctrl->tlv_array;\n\tcontrol.info = peb2466_lkup_ctrl_info;\n\tcontrol.get = peb2466_lkup_ctrl_get;\n\tcontrol.put = peb2466_lkup_ctrl_put;\n\tcontrol.private_value = (unsigned long)lkup_ctrl;\n\n\treturn snd_soc_add_component_controls(component, &control, 1);\n}\n\nenum peb2466_tone_freq {\n\tPEB2466_TONE_697HZ,\n\tPEB2466_TONE_800HZ,\n\tPEB2466_TONE_950HZ,\n\tPEB2466_TONE_1000HZ,\n\tPEB2466_TONE_1008HZ,\n\tPEB2466_TONE_2000HZ,\n};\n\nstatic const u8 peb2466_tone_lookup[][4] = {\n\t[PEB2466_TONE_697HZ] = {0x0a, 0x33, 0x5a, 0x2c},\n\t[PEB2466_TONE_800HZ] = {0x12, 0xD6, 0x5a, 0xc0},\n\t[PEB2466_TONE_950HZ] = {0x1c, 0xf0, 0x5c, 0xc0},\n\t[PEB2466_TONE_1000HZ] = {0},  \n\t[PEB2466_TONE_1008HZ] = {0x1a, 0xae, 0x57, 0x70},\n\t[PEB2466_TONE_2000HZ] = {0x00, 0x80, 0x50, 0x09},\n};\n\nstatic const char * const peb2466_tone_freq_txt[] = {\n\t[PEB2466_TONE_697HZ] = \"697Hz\",\n\t[PEB2466_TONE_800HZ] = \"800Hz\",\n\t[PEB2466_TONE_950HZ] = \"950Hz\",\n\t[PEB2466_TONE_1000HZ] = \"1000Hz\",\n\t[PEB2466_TONE_1008HZ] = \"1008Hz\",\n\t[PEB2466_TONE_2000HZ] = \"2000Hz\"\n};\n\nstatic const struct soc_enum peb2466_tg_freq[][2] = {\n\t[0] = {\n\t\tSOC_ENUM_SINGLE(PEB2466_TG1(0), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt),\n\t\tSOC_ENUM_SINGLE(PEB2466_TG2(0), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt)\n\t},\n\t[1] = {\n\t\tSOC_ENUM_SINGLE(PEB2466_TG1(1), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt),\n\t\tSOC_ENUM_SINGLE(PEB2466_TG2(1), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt)\n\t},\n\t[2] = {\n\t\tSOC_ENUM_SINGLE(PEB2466_TG1(2), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt),\n\t\tSOC_ENUM_SINGLE(PEB2466_TG2(2), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt)\n\t},\n\t[3] = {\n\t\tSOC_ENUM_SINGLE(PEB2466_TG1(3), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt),\n\t\tSOC_ENUM_SINGLE(PEB2466_TG2(3), 0, ARRAY_SIZE(peb2466_tone_freq_txt),\n\t\t\t\tpeb2466_tone_freq_txt)\n\t}\n};\n\nstatic int peb2466_tg_freq_get(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\n\tswitch (e->reg) {\n\tcase PEB2466_TG1(0):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[0].tg1_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG2(0):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[0].tg2_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG1(1):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[1].tg1_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG2(1):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[1].tg2_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG1(2):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[2].tg1_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG2(2):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[2].tg2_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG1(3):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[3].tg1_freq_item;\n\t\tbreak;\n\tcase PEB2466_TG2(3):\n\t\tucontrol->value.enumerated.item[0] = peb2466->ch[3].tg2_freq_item;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_tg_freq_put(struct snd_kcontrol *kcontrol,\n\t\t\t       struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *tg_freq_item;\n\tu8 cr1_reg, cr1_mask;\n\tunsigned int index;\n\tint ret;\n\n\tindex = ucontrol->value.enumerated.item[0];\n\n\tif (index >= ARRAY_SIZE(peb2466_tone_lookup))\n\t\treturn -EINVAL;\n\n\tswitch (e->reg) {\n\tcase PEB2466_TG1(0):\n\t\ttg_freq_item = &peb2466->ch[0].tg1_freq_item;\n\t\tcr1_reg = PEB2466_CR1(0);\n\t\tcr1_mask = PEB2466_CR1_PTG1;\n\t\tbreak;\n\tcase PEB2466_TG2(0):\n\t\ttg_freq_item = &peb2466->ch[0].tg2_freq_item;\n\t\tcr1_reg = PEB2466_CR1(0);\n\t\tcr1_mask = PEB2466_CR1_PTG2;\n\t\tbreak;\n\tcase PEB2466_TG1(1):\n\t\ttg_freq_item = &peb2466->ch[1].tg1_freq_item;\n\t\tcr1_reg = PEB2466_CR1(1);\n\t\tcr1_mask = PEB2466_CR1_PTG1;\n\t\tbreak;\n\tcase PEB2466_TG2(1):\n\t\ttg_freq_item = &peb2466->ch[1].tg2_freq_item;\n\t\tcr1_reg = PEB2466_CR1(1);\n\t\tcr1_mask = PEB2466_CR1_PTG2;\n\t\tbreak;\n\tcase PEB2466_TG1(2):\n\t\ttg_freq_item = &peb2466->ch[2].tg1_freq_item;\n\t\tcr1_reg = PEB2466_CR1(2);\n\t\tcr1_mask = PEB2466_CR1_PTG1;\n\t\tbreak;\n\tcase PEB2466_TG2(2):\n\t\ttg_freq_item = &peb2466->ch[2].tg2_freq_item;\n\t\tcr1_reg = PEB2466_CR1(2);\n\t\tcr1_mask = PEB2466_CR1_PTG2;\n\t\tbreak;\n\tcase PEB2466_TG1(3):\n\t\ttg_freq_item = &peb2466->ch[3].tg1_freq_item;\n\t\tcr1_reg = PEB2466_CR1(3);\n\t\tcr1_mask = PEB2466_CR1_PTG1;\n\t\tbreak;\n\tcase PEB2466_TG2(3):\n\t\ttg_freq_item = &peb2466->ch[3].tg2_freq_item;\n\t\tcr1_reg = PEB2466_CR1(3);\n\t\tcr1_mask = PEB2466_CR1_PTG2;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (index == *tg_freq_item)\n\t\treturn 0;\n\n\tif (index == PEB2466_TONE_1000HZ) {\n\t\tret = regmap_update_bits(peb2466->regmap, cr1_reg, cr1_mask, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = peb2466_write_buf(peb2466, e->reg, peb2466_tone_lookup[index], 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = regmap_update_bits(peb2466->regmap, cr1_reg, cr1_mask, cr1_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*tg_freq_item = index;\n\treturn 1;  \n}\n\nstatic const struct snd_kcontrol_new peb2466_ch0_out_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"TG1 Switch\", PEB2466_CR1(0), 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"TG2 Switch\", PEB2466_CR1(0), 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Voice Switch\", PEB2466_CR2(0), 0, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new peb2466_ch1_out_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"TG1 Switch\", PEB2466_CR1(1), 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"TG2 Switch\", PEB2466_CR1(1), 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Voice Switch\", PEB2466_CR2(1), 0, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new peb2466_ch2_out_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"TG1 Switch\", PEB2466_CR1(2), 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"TG2 Switch\", PEB2466_CR1(2), 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Voice Switch\", PEB2466_CR2(2), 0, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new peb2466_ch3_out_mix_controls[] = {\n\tSOC_DAPM_SINGLE(\"TG1 Switch\", PEB2466_CR1(3), 6, 1, 0),\n\tSOC_DAPM_SINGLE(\"TG2 Switch\", PEB2466_CR1(3), 7, 1, 0),\n\tSOC_DAPM_SINGLE(\"Voice Switch\", PEB2466_CR2(3), 0, 1, 0)\n};\n\nstatic const struct snd_kcontrol_new peb2466_controls[] = {\n\t \n\tSOC_SINGLE(\"DAC0 -6dB Playback Switch\", PEB2466_CR3(0), 2, 1, 0),\n\tSOC_SINGLE(\"DAC1 -6dB Playback Switch\", PEB2466_CR3(1), 2, 1, 0),\n\tSOC_SINGLE(\"DAC2 -6dB Playback Switch\", PEB2466_CR3(2), 2, 1, 0),\n\tSOC_SINGLE(\"DAC3 -6dB Playback Switch\", PEB2466_CR3(3), 2, 1, 0),\n\n\t \n\tSOC_SINGLE(\"ADC0 +6dB Capture Switch\", PEB2466_CR3(0), 3, 1, 0),\n\tSOC_SINGLE(\"ADC1 +6dB Capture Switch\", PEB2466_CR3(1), 3, 1, 0),\n\tSOC_SINGLE(\"ADC2 +6dB Capture Switch\", PEB2466_CR3(2), 3, 1, 0),\n\tSOC_SINGLE(\"ADC3 +6dB Capture Switch\", PEB2466_CR3(3), 3, 1, 0),\n\n\t \n\tSOC_ENUM_EXT(\"DAC0 TG1 Freq\", peb2466_tg_freq[0][0],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC1 TG1 Freq\", peb2466_tg_freq[1][0],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC2 TG1 Freq\", peb2466_tg_freq[2][0],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC3 TG1 Freq\", peb2466_tg_freq[3][0],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\n\tSOC_ENUM_EXT(\"DAC0 TG2 Freq\", peb2466_tg_freq[0][1],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC1 TG2 Freq\", peb2466_tg_freq[1][1],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC2 TG2 Freq\", peb2466_tg_freq[2][1],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n\tSOC_ENUM_EXT(\"DAC3 TG2 Freq\", peb2466_tg_freq[3][1],\n\t\t     peb2466_tg_freq_get, peb2466_tg_freq_put),\n};\n\nstatic const struct snd_soc_dapm_widget peb2466_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"CH0 PWR\", PEB2466_CR1(0), 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CH1 PWR\", PEB2466_CR1(1), 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CH2 PWR\", PEB2466_CR1(2), 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"CH3 PWR\", PEB2466_CR1(3), 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_DAC(\"CH0 DIN\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"CH1 DIN\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"CH2 DIN\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"CH3 DIN\", \"Playback\", SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_SIGGEN(\"CH0 TG1\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH1 TG1\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH2 TG1\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH3 TG1\"),\n\n\tSND_SOC_DAPM_SIGGEN(\"CH0 TG2\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH1 TG2\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH2 TG2\"),\n\tSND_SOC_DAPM_SIGGEN(\"CH3 TG2\"),\n\n\tSND_SOC_DAPM_MIXER(\"DAC0 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   peb2466_ch0_out_mix_controls,\n\t\t\t   ARRAY_SIZE(peb2466_ch0_out_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"DAC1 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   peb2466_ch1_out_mix_controls,\n\t\t\t   ARRAY_SIZE(peb2466_ch1_out_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"DAC2 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   peb2466_ch2_out_mix_controls,\n\t\t\t   ARRAY_SIZE(peb2466_ch2_out_mix_controls)),\n\tSND_SOC_DAPM_MIXER(\"DAC3 Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   peb2466_ch3_out_mix_controls,\n\t\t\t   ARRAY_SIZE(peb2466_ch3_out_mix_controls)),\n\n\tSND_SOC_DAPM_PGA(\"DAC0 PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"DAC1 PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"DAC2 PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"DAC3 PGA\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"OUT0\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT1\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT2\"),\n\tSND_SOC_DAPM_OUTPUT(\"OUT3\"),\n\n\tSND_SOC_DAPM_INPUT(\"IN0\"),\n\tSND_SOC_DAPM_INPUT(\"IN1\"),\n\tSND_SOC_DAPM_INPUT(\"IN2\"),\n\tSND_SOC_DAPM_INPUT(\"IN3\"),\n\n\tSND_SOC_DAPM_DAC(\"ADC0\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"ADC1\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"ADC2\", \"Capture\", SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC(\"ADC3\", \"Capture\", SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route peb2466_dapm_routes[] = {\n\t{ \"CH0 DIN\", NULL, \"CH0 PWR\" },\n\t{ \"CH1 DIN\", NULL, \"CH1 PWR\" },\n\t{ \"CH2 DIN\", NULL, \"CH2 PWR\" },\n\t{ \"CH3 DIN\", NULL, \"CH3 PWR\" },\n\n\t{ \"CH0 TG1\", NULL, \"CH0 PWR\" },\n\t{ \"CH1 TG1\", NULL, \"CH1 PWR\" },\n\t{ \"CH2 TG1\", NULL, \"CH2 PWR\" },\n\t{ \"CH3 TG1\", NULL, \"CH3 PWR\" },\n\n\t{ \"CH0 TG2\", NULL, \"CH0 PWR\" },\n\t{ \"CH1 TG2\", NULL, \"CH1 PWR\" },\n\t{ \"CH2 TG2\", NULL, \"CH2 PWR\" },\n\t{ \"CH3 TG2\", NULL, \"CH3 PWR\" },\n\n\t{ \"DAC0 Mixer\", \"TG1 Switch\", \"CH0 TG1\" },\n\t{ \"DAC0 Mixer\", \"TG2 Switch\", \"CH0 TG2\" },\n\t{ \"DAC0 Mixer\", \"Voice Switch\", \"CH0 DIN\" },\n\t{ \"DAC0 Mixer\", NULL, \"CH0 DIN\" },\n\n\t{ \"DAC1 Mixer\", \"TG1 Switch\", \"CH1 TG1\" },\n\t{ \"DAC1 Mixer\", \"TG2 Switch\", \"CH1 TG2\" },\n\t{ \"DAC1 Mixer\", \"Voice Switch\", \"CH1 DIN\" },\n\t{ \"DAC1 Mixer\", NULL, \"CH1 DIN\" },\n\n\t{ \"DAC2 Mixer\", \"TG1 Switch\", \"CH2 TG1\" },\n\t{ \"DAC2 Mixer\", \"TG2 Switch\", \"CH2 TG2\" },\n\t{ \"DAC2 Mixer\", \"Voice Switch\", \"CH2 DIN\" },\n\t{ \"DAC2 Mixer\", NULL, \"CH2 DIN\" },\n\n\t{ \"DAC3 Mixer\", \"TG1 Switch\", \"CH3 TG1\" },\n\t{ \"DAC3 Mixer\", \"TG2 Switch\", \"CH3 TG2\" },\n\t{ \"DAC3 Mixer\", \"Voice Switch\", \"CH3 DIN\" },\n\t{ \"DAC3 Mixer\", NULL, \"CH3 DIN\" },\n\n\t{ \"DAC0 PGA\", NULL, \"DAC0 Mixer\" },\n\t{ \"DAC1 PGA\", NULL, \"DAC1 Mixer\" },\n\t{ \"DAC2 PGA\", NULL, \"DAC2 Mixer\" },\n\t{ \"DAC3 PGA\", NULL, \"DAC3 Mixer\" },\n\n\t{ \"OUT0\", NULL, \"DAC0 PGA\" },\n\t{ \"OUT1\", NULL, \"DAC1 PGA\" },\n\t{ \"OUT2\", NULL, \"DAC2 PGA\" },\n\t{ \"OUT3\", NULL, \"DAC3 PGA\" },\n\n\t{ \"ADC0\", NULL, \"IN0\" },\n\t{ \"ADC1\", NULL, \"IN1\" },\n\t{ \"ADC2\", NULL, \"IN2\" },\n\t{ \"ADC3\", NULL, \"IN3\" },\n\n\t{ \"ADC0\", NULL, \"CH0 PWR\" },\n\t{ \"ADC1\", NULL, \"CH1 PWR\" },\n\t{ \"ADC2\", NULL, \"CH2 PWR\" },\n\t{ \"ADC3\", NULL, \"CH3 PWR\" },\n};\n\nstatic int peb2466_dai_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\n\t\t\t\t    unsigned int rx_mask, int slots, int width)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int chan;\n\tunsigned int mask;\n\tu8 slot;\n\tint ret;\n\n\tswitch (width) {\n\tcase 0:\n\t\t \n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"tdm slot width %d not supported\\n\", width);\n\t\treturn -EINVAL;\n\t}\n\n\tmask = tx_mask;\n\tslot = 0;\n\tchan = 0;\n\twhile (mask && chan < PEB2466_NB_CHANNEL) {\n\t\tif (mask & 0x1) {\n\t\t\tret = regmap_write(peb2466->regmap, PEB2466_CR5(chan), slot);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dai->dev, \"chan %d set tx tdm slot failed (%d)\\n\",\n\t\t\t\t\tchan, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tchan++;\n\t\t}\n\t\tmask >>= 1;\n\t\tslot++;\n\t}\n\tif (mask) {\n\t\tdev_err(dai->dev, \"too much tx slots defined (mask = 0x%x) support max %d\\n\",\n\t\t\ttx_mask, PEB2466_NB_CHANNEL);\n\t\treturn -EINVAL;\n\t}\n\tpeb2466->max_chan_playback = chan;\n\n\tmask = rx_mask;\n\tslot = 0;\n\tchan = 0;\n\twhile (mask && chan < PEB2466_NB_CHANNEL) {\n\t\tif (mask & 0x1) {\n\t\t\tret = regmap_write(peb2466->regmap, PEB2466_CR4(chan), slot);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dai->dev, \"chan %d set rx tdm slot failed (%d)\\n\",\n\t\t\t\t\tchan, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tchan++;\n\t\t}\n\t\tmask >>= 1;\n\t\tslot++;\n\t}\n\tif (mask) {\n\t\tdev_err(dai->dev, \"too much rx slots defined (mask = 0x%x) support max %d\\n\",\n\t\t\trx_mask, PEB2466_NB_CHANNEL);\n\t\treturn -EINVAL;\n\t}\n\tpeb2466->max_chan_capture = chan;\n\n\treturn 0;\n}\n\nstatic int peb2466_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(dai->component);\n\tu8 xr6;\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\txr6 = PEB2466_XR6_PCM_OFFSET(1);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\txr6 = PEB2466_XR6_PCM_OFFSET(0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dai->dev, \"Unsupported format 0x%x\\n\",\n\t\t\tfmt & SND_SOC_DAIFMT_FORMAT_MASK);\n\t\treturn -EINVAL;\n\t}\n\treturn regmap_write(peb2466->regmap, PEB2466_XR6, xr6);\n}\n\nstatic int peb2466_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int ch;\n\tint ret;\n\tu8 cr1;\n\n\tswitch (params_format(params)) {\n\tcase SNDRV_PCM_FORMAT_MU_LAW:\n\t\tcr1 = PEB2466_CR1_LAW_MULAW;\n\t\tbreak;\n\tcase SNDRV_PCM_FORMAT_A_LAW:\n\t\tcr1 = PEB2466_CR1_LAW_ALAW;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&peb2466->spi->dev, \"Unsupported format 0x%x\\n\",\n\t\t\tparams_format(params));\n\t\treturn -EINVAL;\n\t}\n\n\tfor (ch = 0; ch < PEB2466_NB_CHANNEL; ch++) {\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR1(ch),\n\t\t\t\t\t PEB2466_CR1_LAW_MASK, cr1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const unsigned int peb2466_sample_bits[] = {8};\n\nstatic struct snd_pcm_hw_constraint_list peb2466_sample_bits_constr = {\n\t.list = peb2466_sample_bits,\n\t.count = ARRAY_SIZE(peb2466_sample_bits),\n};\n\nstatic int peb2466_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int max_ch;\n\tint ret;\n\n\tmax_ch = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\n\t\tpeb2466->max_chan_playback : peb2466->max_chan_capture;\n\n\t \n\tret = snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t   SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\t\t\t   max_ch ? 1 : 0, max_ch);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_SAMPLE_BITS,\n\t\t\t\t\t  &peb2466_sample_bits_constr);\n}\n\nstatic u64 peb2466_dai_formats[] = {\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_A\t|\n\tSND_SOC_POSSIBLE_DAIFMT_DSP_B,\n};\n\nstatic const struct snd_soc_dai_ops peb2466_dai_ops = {\n\t.startup = peb2466_dai_startup,\n\t.hw_params = peb2466_dai_hw_params,\n\t.set_tdm_slot = peb2466_dai_set_tdm_slot,\n\t.set_fmt = peb2466_dai_set_fmt,\n\t.auto_selectable_formats     = peb2466_dai_formats,\n\t.num_auto_selectable_formats = ARRAY_SIZE(peb2466_dai_formats),\n};\n\nstatic struct snd_soc_dai_driver peb2466_dai_driver = {\n\t.name = \"peb2466\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = PEB2466_NB_CHANNEL,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = PEB2466_NB_CHANNEL,\n\t\t.rates = SNDRV_PCM_RATE_8000,\n\t\t.formats = SNDRV_PCM_FMTBIT_MU_LAW | SNDRV_PCM_FMTBIT_A_LAW,\n\t},\n\t.ops = &peb2466_dai_ops,\n};\n\nstatic int peb2466_reset_audio(struct peb2466 *peb2466)\n{\n\tstatic const struct reg_sequence reg_reset[] = {\n\t\t{  .reg = PEB2466_XR6,    .def = 0x00 },\n\n\t\t{  .reg = PEB2466_CR5(0), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR4(0), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR3(0), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR2(0), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR1(0), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR0(0), .def = PEB2466_CR0_IMR1 },\n\n\t\t{  .reg = PEB2466_CR5(1), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR4(1), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR3(1), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR2(1), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR1(1), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR0(1), .def = PEB2466_CR0_IMR1 },\n\n\t\t{  .reg = PEB2466_CR5(2), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR4(2), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR3(2), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR2(2), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR1(2), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR0(2), .def = PEB2466_CR0_IMR1 },\n\n\t\t{  .reg = PEB2466_CR5(3), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR4(3), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR3(3), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR2(3), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR1(3), .def = 0x00 },\n\t\t{  .reg = PEB2466_CR0(3), .def = PEB2466_CR0_IMR1 },\n\t};\n\tstatic const u8 imr1_p1[8] = {0x00, 0x90, 0x09, 0x00, 0x90, 0x09, 0x00, 0x00};\n\tstatic const u8 imr1_p2[8] = {0x7F, 0xFF, 0x00, 0x00, 0x90, 0x14, 0x40, 0x08};\n\tstatic const u8 zero[8] = {0};\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tpeb2466->ch[i].tg1_freq_item = PEB2466_TONE_1000HZ;\n\t\tpeb2466->ch[i].tg2_freq_item = PEB2466_TONE_1000HZ;\n\n\t\t \n\t\tret = peb2466_write_buf(peb2466, PEB2466_IMR1_FILTER_P1(i), imr1_p1, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_IMR1_FILTER_P2(i), imr1_p2, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P1(i), zero, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P2(i), zero, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P3(i), zero, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_FRX_FILTER(i), zero, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_FRR_FILTER(i), zero, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AX_FILTER(i), zero, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AR_FILTER(i), zero, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn regmap_multi_reg_write(peb2466->regmap, reg_reset, ARRAY_SIZE(reg_reset));\n}\n\nstatic int peb2466_fw_parse_thfilter(struct snd_soc_component *component,\n\t\t\t\t     u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw TH filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_TH, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P1(i), data + 1, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P2(i), data + 9, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_TH_FILTER_P3(i), data + 17, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_TH | PEB2466_CR0_THSEL_MASK,\n\t\t\t\t\t PEB2466_CR0_TH | PEB2466_CR0_THSEL(i));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_fw_parse_imr1filter(struct snd_soc_component *component,\n\t\t\t\t       u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw IM/R1 filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_IMR1, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_IMR1_FILTER_P1(i), data + 1, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_IMR1_FILTER_P2(i), data + 9, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_IMR1, PEB2466_CR0_IMR1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_fw_parse_frxfilter(struct snd_soc_component *component,\n\t\t\t\t      u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw FRX filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_FRX, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_FRX_FILTER(i), data + 1, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_FRX, PEB2466_CR0_FRX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_fw_parse_frrfilter(struct snd_soc_component *component,\n\t\t\t\t      u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw FRR filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_FRR, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_FRR_FILTER(i), data + 1, 8);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_FRR, PEB2466_CR0_FRR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_fw_parse_axfilter(struct snd_soc_component *component,\n\t\t\t\t     u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw AX filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AX, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AX_FILTER(i), data + 1, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AX, PEB2466_CR0_AX);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_fw_parse_arfilter(struct snd_soc_component *component,\n\t\t\t\t     u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\tdev_info(component->dev, \"fw AR filter: mask %x, %*phN\\n\", *data,\n\t\t lng - 1, data + 1);\n\n\t \n\tmask = *data;\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AR, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AR_FILTER(i), data + 1, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AR, PEB2466_CR0_AR);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const char * const peb2466_ax_ctrl_names[] = {\n\t\"ADC0 Capture Volume\",\n\t\"ADC1 Capture Volume\",\n\t\"ADC2 Capture Volume\",\n\t\"ADC3 Capture Volume\",\n};\n\nstatic int peb2466_fw_parse_axtable(struct snd_soc_component *component,\n\t\t\t\t    u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tstruct peb2466_lkup_ctrl *lkup_ctrl;\n\tstruct peb2466_lookup *lookup;\n\tu8 (*table)[4];\n\tu32 table_size;\n\tu32 init_index;\n\ts32 min_val;\n\ts32 step;\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\t \n\n\t \n\tif (lng < 13 || ((lng - 13) % 4)) {\n\t\tdev_err(component->dev, \"fw AX table lng %u invalid\\n\", lng);\n\t\treturn -EINVAL;\n\t}\n\ttable_size = lng - 13;\n\n\tmin_val = get_unaligned_be32(data + 1);\n\tstep = get_unaligned_be32(data + 5);\n\tinit_index = get_unaligned_be32(data + 9);\n\tif (init_index >= (table_size / 4)) {\n\t\tdev_err(component->dev, \"fw AX table index %u out of table[%u]\\n\",\n\t\t\tinit_index, table_size / 4);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(component->dev,\n\t\t \"fw AX table: mask %x, min %d, step %d, %u items, tbl[%u] %*phN\\n\",\n\t\t *data, min_val, step, table_size / 4, init_index,\n\t\t 4, data + 13 + (init_index * 4));\n\n\tBUILD_BUG_ON(sizeof(*table) != 4);\n\ttable = devm_kzalloc(&peb2466->spi->dev, table_size, GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\tmemcpy(table, data + 13, table_size);\n\n\tmask = *data;\n\tBUILD_BUG_ON(ARRAY_SIZE(peb2466_ax_ctrl_names) != ARRAY_SIZE(peb2466->ch));\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tlookup = &peb2466->ch[i].ax_lookup;\n\t\tlookup->table = table;\n\t\tlookup->count = table_size / 4;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AX, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AX_FILTER(i),\n\t\t\t\t\tlookup->table[init_index], 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AX, PEB2466_CR0_AX);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlkup_ctrl = &peb2466->ch[i].ax_lkup_ctrl;\n\t\tlkup_ctrl->lookup = lookup;\n\t\tlkup_ctrl->reg = PEB2466_AX_FILTER(i);\n\t\tlkup_ctrl->index = init_index;\n\n\t\tret = peb2466_add_lkup_ctrl(component, lkup_ctrl,\n\t\t\t\t\t    peb2466_ax_ctrl_names[i],\n\t\t\t\t\t    min_val, step);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic const char * const peb2466_ar_ctrl_names[] = {\n\t\"DAC0 Playback Volume\",\n\t\"DAC1 Playback Volume\",\n\t\"DAC2 Playback Volume\",\n\t\"DAC3 Playback Volume\",\n};\n\nstatic int peb2466_fw_parse_artable(struct snd_soc_component *component,\n\t\t\t\t    u16 tag, u32 lng, const u8 *data)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tstruct peb2466_lkup_ctrl *lkup_ctrl;\n\tstruct peb2466_lookup *lookup;\n\tu8 (*table)[4];\n\tu32 table_size;\n\tu32 init_index;\n\ts32 min_val;\n\ts32 step;\n\tu8 mask;\n\tint ret;\n\tint i;\n\n\t \n\n\t \n\tif (lng < 13 || ((lng - 13) % 4)) {\n\t\tdev_err(component->dev, \"fw AR table lng %u invalid\\n\", lng);\n\t\treturn -EINVAL;\n\t}\n\ttable_size = lng - 13;\n\n\tmin_val = get_unaligned_be32(data + 1);\n\tstep = get_unaligned_be32(data + 5);\n\tinit_index = get_unaligned_be32(data + 9);\n\tif (init_index >= (table_size / 4)) {\n\t\tdev_err(component->dev, \"fw AR table index %u out of table[%u]\\n\",\n\t\t\tinit_index, table_size / 4);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(component->dev,\n\t\t \"fw AR table: mask %x, min %d, step %d, %u items, tbl[%u] %*phN\\n\",\n\t\t *data, min_val, step, table_size / 4, init_index,\n\t\t 4, data + 13 + (init_index * 4));\n\n\tBUILD_BUG_ON(sizeof(*table) != 4);\n\ttable = devm_kzalloc(&peb2466->spi->dev, table_size, GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\tmemcpy(table, data + 13, table_size);\n\n\tmask = *data;\n\tBUILD_BUG_ON(ARRAY_SIZE(peb2466_ar_ctrl_names) != ARRAY_SIZE(peb2466->ch));\n\tfor (i = 0; i < ARRAY_SIZE(peb2466->ch); i++) {\n\t\tif (!(mask & (1 << i)))\n\t\t\tcontinue;\n\n\t\tlookup = &peb2466->ch[i].ar_lookup;\n\t\tlookup->table = table;\n\t\tlookup->count = table_size / 4;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AR, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = peb2466_write_buf(peb2466, PEB2466_AR_FILTER(i),\n\t\t\t\t\tlookup->table[init_index], 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_update_bits(peb2466->regmap, PEB2466_CR0(i),\n\t\t\t\t\t PEB2466_CR0_AR, PEB2466_CR0_AR);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlkup_ctrl = &peb2466->ch[i].ar_lkup_ctrl;\n\t\tlkup_ctrl->lookup = lookup;\n\t\tlkup_ctrl->reg = PEB2466_AR_FILTER(i);\n\t\tlkup_ctrl->index = init_index;\n\n\t\tret = peb2466_add_lkup_ctrl(component, lkup_ctrl,\n\t\t\t\t\t    peb2466_ar_ctrl_names[i],\n\t\t\t\t\t    min_val, step);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstruct peb2466_fw_tag_def {\n\tu16 tag;\n\tu32 lng_min;\n\tu32 lng_max;\n\tint (*parse)(struct snd_soc_component *component,\n\t\t     u16 tag, u32 lng, const u8 *data);\n};\n\n#define PEB2466_TAG_DEF_LNG_EQ(__tag, __lng, __parse) { \\\n\t.tag = __tag,\t\t\\\n\t.lng_min = __lng,\t\\\n\t.lng_max = __lng,\t\\\n\t.parse = __parse,\t\\\n}\n\n#define PEB2466_TAG_DEF_LNG_MIN(__tag, __lng_min, __parse) { \\\n\t.tag = __tag,\t\t\\\n\t.lng_min = __lng_min,\t\\\n\t.lng_max = U32_MAX,\t\\\n\t.parse = __parse,\t\\\n}\n\nstatic const struct peb2466_fw_tag_def peb2466_fw_tag_defs[] = {\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0001, 1 + 3 * 8, peb2466_fw_parse_thfilter),\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0002, 1 + 2 * 8, peb2466_fw_parse_imr1filter),\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0003, 1 + 8, peb2466_fw_parse_frxfilter),\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0004, 1 + 8, peb2466_fw_parse_frrfilter),\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0005, 1 + 4, peb2466_fw_parse_axfilter),\n\t \n\tPEB2466_TAG_DEF_LNG_EQ(0x0006, 1 + 4, peb2466_fw_parse_arfilter),\n\t \n\tPEB2466_TAG_DEF_LNG_MIN(0x0105, 1 + 3 * 4, peb2466_fw_parse_axtable),\n\t \n\tPEB2466_TAG_DEF_LNG_MIN(0x0106, 1 + 3 * 4, peb2466_fw_parse_artable),\n};\n\nstatic const struct peb2466_fw_tag_def *peb2466_fw_get_tag_def(u16 tag)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(peb2466_fw_tag_defs); i++) {\n\t\tif (peb2466_fw_tag_defs[i].tag == tag)\n\t\t\treturn &peb2466_fw_tag_defs[i];\n\t}\n\treturn NULL;\n}\n\nstatic int peb2466_fw_parse(struct snd_soc_component *component,\n\t\t\t    const u8 *data, size_t size)\n{\n\tconst struct peb2466_fw_tag_def *tag_def;\n\tsize_t left;\n\tconst u8 *buf;\n\tu16 val16;\n\tu16 tag;\n\tu32 lng;\n\tint ret;\n\n\t \n\n\tleft = size;\n\tbuf = data;\n\n\tif (left < 4) {\n\t\tdev_err(component->dev, \"fw size %zu, exp at least 4\\n\", left);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval16 = get_unaligned_be16(buf);\n\tif (val16 != 0x2466) {\n\t\tdev_err(component->dev, \"fw magic 0x%04x exp 0x2466\\n\", val16);\n\t\treturn -EINVAL;\n\t}\n\tbuf += 2;\n\tleft -= 2;\n\n\t \n\tval16 = get_unaligned_be16(buf);\n\tif (val16 != 0x0100) {\n\t\tdev_err(component->dev, \"fw magic 0x%04x exp 0x0100\\n\", val16);\n\t\treturn -EINVAL;\n\t}\n\tbuf += 2;\n\tleft -= 2;\n\n\twhile (left) {\n\t\tif (left < 6) {\n\t\t\tdev_err(component->dev, \"fw %td/%zu left %zu, exp at least 6\\n\",\n\t\t\t\tbuf - data, size, left);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\ttag = get_unaligned_be16(buf);\n\t\tlng = get_unaligned_be32(buf + 2);\n\t\ttag_def = peb2466_fw_get_tag_def(tag);\n\t\tif (!tag_def) {\n\t\t\tdev_err(component->dev, \"fw %td/%zu tag 0x%04x unknown\\n\",\n\t\t\t\tbuf - data, size, tag);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (lng < tag_def->lng_min || lng > tag_def->lng_max) {\n\t\t\tdev_err(component->dev, \"fw %td/%zu tag 0x%04x lng %u, exp [%u;%u]\\n\",\n\t\t\t\tbuf - data, size, tag, lng, tag_def->lng_min, tag_def->lng_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbuf += 6;\n\t\tleft -= 6;\n\t\tif (left < lng) {\n\t\t\tdev_err(component->dev, \"fw %td/%zu tag 0x%04x lng %u, left %zu\\n\",\n\t\t\t\tbuf - data, size, tag, lng, left);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = tag_def->parse(component, tag, lng, buf);\n\t\tif (ret) {\n\t\t\tdev_err(component->dev, \"fw %td/%zu tag 0x%04x lng %u parse failed\\n\",\n\t\t\t\tbuf - data, size, tag, lng);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbuf += lng;\n\t\tleft -= lng;\n\t}\n\treturn 0;\n}\n\nstatic int peb2466_load_coeffs(struct snd_soc_component *component, const char *fw_name)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, fw_name, component->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = peb2466_fw_parse(component, fw->data, fw->size);\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int peb2466_component_probe(struct snd_soc_component *component)\n{\n\tstruct peb2466 *peb2466 = snd_soc_component_get_drvdata(component);\n\tconst char *firmware_name;\n\tint ret;\n\n\t \n\tret = peb2466_reset_audio(peb2466);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_string(peb2466->spi->dev.of_node,\n\t\t\t\t      \"firmware-name\", &firmware_name);\n\tif (ret)\n\t\treturn (ret == -EINVAL) ? 0 : ret;\n\n\treturn peb2466_load_coeffs(component, firmware_name);\n}\n\nstatic const struct snd_soc_component_driver peb2466_component_driver = {\n\t.probe\t\t\t= peb2466_component_probe,\n\t.controls\t\t= peb2466_controls,\n\t.num_controls\t\t= ARRAY_SIZE(peb2466_controls),\n\t.dapm_widgets\t\t= peb2466_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(peb2466_dapm_widgets),\n\t.dapm_routes\t\t= peb2466_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(peb2466_dapm_routes),\n\t.endianness\t\t= 1,\n};\n\n \n\nstatic int peb2466_chip_gpio_offset_to_data_regmask(unsigned int offset,\n\t\t\t\t\t\t    unsigned int *xr_reg,\n\t\t\t\t\t\t    unsigned int *mask)\n{\n\tif (offset < 16) {\n\t\t \n\t\t*xr_reg = PEB2466_XR0;\n\t\t*mask = (1 << (offset % 8));\n\t\treturn 0;\n\t}\n\tif (offset < 24) {\n\t\t \n\t\t*xr_reg = PEB2466_XR1;\n\t\t*mask = (1 << (offset - 16));\n\t\treturn 0;\n\t}\n\tif (offset < 28) {\n\t\t \n\t\t*xr_reg = PEB2466_XR3;\n\t\t*mask = (1 << (offset - 24 + 4));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int peb2466_chip_gpio_offset_to_dir_regmask(unsigned int offset,\n\t\t\t\t\t\t   unsigned int *xr_reg,\n\t\t\t\t\t\t   unsigned int *mask)\n{\n\tif (offset < 16) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\tif (offset < 24) {\n\t\t*xr_reg = PEB2466_XR2;\n\t\t*mask = (1 << (offset - 16));\n\t\treturn 0;\n\t}\n\tif (offset < 28) {\n\t\t*xr_reg = PEB2466_XR3;\n\t\t*mask = (1 << (offset - 24));\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic unsigned int *peb2466_chip_gpio_get_cache(struct peb2466 *peb2466,\n\t\t\t\t\t\t unsigned int xr_reg)\n{\n\tunsigned int *cache;\n\n\tswitch (xr_reg) {\n\tcase PEB2466_XR0:\n\t\tcache = &peb2466->gpio.cache.xr0;\n\t\tbreak;\n\tcase PEB2466_XR1:\n\t\tcache = &peb2466->gpio.cache.xr1;\n\t\tbreak;\n\tcase PEB2466_XR2:\n\t\tcache = &peb2466->gpio.cache.xr2;\n\t\tbreak;\n\tcase PEB2466_XR3:\n\t\tcache = &peb2466->gpio.cache.xr3;\n\t\tbreak;\n\tdefault:\n\t\tcache = NULL;\n\t\tbreak;\n\t}\n\treturn cache;\n}\n\nstatic int peb2466_chip_gpio_update_bits(struct peb2466 *peb2466, unsigned int xr_reg,\n\t\t\t\t\t unsigned int mask, unsigned int val)\n{\n\tunsigned int tmp;\n\tunsigned int *cache;\n\tint ret;\n\n\t \n\n\tmutex_lock(&peb2466->gpio.lock);\n\n\tcache = peb2466_chip_gpio_get_cache(peb2466, xr_reg);\n\tif (!cache) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\ttmp = *cache;\n\ttmp &= ~mask;\n\ttmp |= val;\n\n\tret = regmap_write(peb2466->regmap, xr_reg, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\t*cache = tmp;\n\tret = 0;\n\nend:\n\tmutex_unlock(&peb2466->gpio.lock);\n\treturn ret;\n}\n\nstatic void peb2466_chip_gpio_set(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tstruct peb2466 *peb2466 = gpiochip_get_data(c);\n\tunsigned int xr_reg;\n\tunsigned int mask;\n\tint ret;\n\n\tif (offset < 8) {\n\t\t \n\t\tdev_warn(&peb2466->spi->dev, \"cannot set gpio %d (read-only)\\n\",\n\t\t\t offset);\n\t\treturn;\n\t}\n\n\tret = peb2466_chip_gpio_offset_to_data_regmask(offset, &xr_reg, &mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"cannot set gpio %d (%d)\\n\",\n\t\t\toffset, ret);\n\t\treturn;\n\t}\n\n\tret = peb2466_chip_gpio_update_bits(peb2466, xr_reg, mask, val ? mask : 0);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"set gpio %d (0x%x, 0x%x) failed (%d)\\n\",\n\t\t\toffset, xr_reg, mask, ret);\n\t}\n}\n\nstatic int peb2466_chip_gpio_get(struct gpio_chip *c, unsigned int offset)\n{\n\tstruct peb2466 *peb2466 = gpiochip_get_data(c);\n\tbool use_cache = false;\n\tunsigned int *cache;\n\tunsigned int xr_reg;\n\tunsigned int mask;\n\tunsigned int val;\n\tint ret;\n\n\tif (offset >= 8 && offset < 16) {\n\t\t \n\t\tuse_cache = true;\n\t}\n\n\tret = peb2466_chip_gpio_offset_to_data_regmask(offset, &xr_reg, &mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"cannot get gpio %d (%d)\\n\",\n\t\t\toffset, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_cache) {\n\t\tcache = peb2466_chip_gpio_get_cache(peb2466, xr_reg);\n\t\tif (!cache)\n\t\t\treturn -EINVAL;\n\t\tval = *cache;\n\t} else {\n\t\tret = regmap_read(peb2466->regmap, xr_reg, &val);\n\t\tif (ret) {\n\t\t\tdev_err(&peb2466->spi->dev, \"get gpio %d (0x%x, 0x%x) failed (%d)\\n\",\n\t\t\t\toffset, xr_reg, mask, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn !!(val & mask);\n}\n\nstatic int peb2466_chip_get_direction(struct gpio_chip *c, unsigned int offset)\n{\n\tstruct peb2466 *peb2466 = gpiochip_get_data(c);\n\tunsigned int xr_reg;\n\tunsigned int mask;\n\tunsigned int val;\n\tint ret;\n\n\tif (offset < 8) {\n\t\t \n\t\treturn GPIO_LINE_DIRECTION_IN;\n\t}\n\tif (offset < 16) {\n\t\t \n\t\treturn GPIO_LINE_DIRECTION_OUT;\n\t}\n\n\tret = peb2466_chip_gpio_offset_to_dir_regmask(offset, &xr_reg, &mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"cannot get gpio %d direction (%d)\\n\",\n\t\t\toffset, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(peb2466->regmap, xr_reg, &val);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"get dir gpio %d (0x%x, 0x%x) failed (%d)\\n\",\n\t\t\toffset, xr_reg, mask, ret);\n\t\treturn ret;\n\t}\n\n\treturn val & mask ? GPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int peb2466_chip_direction_input(struct gpio_chip *c, unsigned int offset)\n{\n\tstruct peb2466 *peb2466 = gpiochip_get_data(c);\n\tunsigned int xr_reg;\n\tunsigned int mask;\n\tint ret;\n\n\tif (offset < 8) {\n\t\t \n\t\treturn 0;\n\t}\n\tif (offset < 16) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tret = peb2466_chip_gpio_offset_to_dir_regmask(offset, &xr_reg, &mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"cannot set gpio %d direction (%d)\\n\",\n\t\t\toffset, ret);\n\t\treturn ret;\n\t}\n\n\tret = peb2466_chip_gpio_update_bits(peb2466, xr_reg, mask, 0);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"Set dir in gpio %d (0x%x, 0x%x) failed (%d)\\n\",\n\t\t\toffset, xr_reg, mask, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int peb2466_chip_direction_output(struct gpio_chip *c, unsigned int offset, int val)\n{\n\tstruct peb2466 *peb2466 = gpiochip_get_data(c);\n\tunsigned int xr_reg;\n\tunsigned int mask;\n\tint ret;\n\n\tif (offset < 8) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tpeb2466_chip_gpio_set(c, offset, val);\n\n\tif (offset < 16) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tret = peb2466_chip_gpio_offset_to_dir_regmask(offset, &xr_reg, &mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"cannot set gpio %d direction (%d)\\n\",\n\t\t\toffset, ret);\n\t\treturn ret;\n\t}\n\n\tret = peb2466_chip_gpio_update_bits(peb2466, xr_reg, mask, mask);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"Set dir in gpio %d (0x%x, 0x%x) failed (%d)\\n\",\n\t\t\toffset, xr_reg, mask, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int peb2466_reset_gpio(struct peb2466 *peb2466)\n{\n\tstatic const struct reg_sequence reg_reset[] = {\n\t\t \n\t\t{  .reg = PEB2466_XR0, .def = 0 },\n\t\t{  .reg = PEB2466_XR1, .def = 0 },\n\t\t{  .reg = PEB2466_XR2, .def = 0 },\n\t\t{  .reg = PEB2466_XR3, .def = 0 },\n\t};\n\n\tpeb2466->gpio.cache.xr0 = 0;\n\tpeb2466->gpio.cache.xr1 = 0;\n\tpeb2466->gpio.cache.xr2 = 0;\n\tpeb2466->gpio.cache.xr3 = 0;\n\n\treturn regmap_multi_reg_write(peb2466->regmap, reg_reset, ARRAY_SIZE(reg_reset));\n}\n\nstatic int peb2466_gpio_init(struct peb2466 *peb2466)\n{\n\tint ret;\n\n\tmutex_init(&peb2466->gpio.lock);\n\n\tret = peb2466_reset_gpio(peb2466);\n\tif (ret)\n\t\treturn ret;\n\n\tpeb2466->gpio.gpio_chip.owner = THIS_MODULE;\n\tpeb2466->gpio.gpio_chip.label = dev_name(&peb2466->spi->dev);\n\tpeb2466->gpio.gpio_chip.parent = &peb2466->spi->dev;\n\tpeb2466->gpio.gpio_chip.base = -1;\n\tpeb2466->gpio.gpio_chip.ngpio = 28;\n\tpeb2466->gpio.gpio_chip.get_direction = peb2466_chip_get_direction;\n\tpeb2466->gpio.gpio_chip.direction_input = peb2466_chip_direction_input;\n\tpeb2466->gpio.gpio_chip.direction_output = peb2466_chip_direction_output;\n\tpeb2466->gpio.gpio_chip.get = peb2466_chip_gpio_get;\n\tpeb2466->gpio.gpio_chip.set = peb2466_chip_gpio_set;\n\tpeb2466->gpio.gpio_chip.can_sleep = true;\n\n\treturn devm_gpiochip_add_data(&peb2466->spi->dev, &peb2466->gpio.gpio_chip,\n\t\t\t\t      peb2466);\n}\n\nstatic int peb2466_spi_probe(struct spi_device *spi)\n{\n\tstruct peb2466 *peb2466;\n\tunsigned long mclk_rate;\n\tint ret;\n\tu8 xr5;\n\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpeb2466 = devm_kzalloc(&spi->dev, sizeof(*peb2466), GFP_KERNEL);\n\tif (!peb2466)\n\t\treturn -ENOMEM;\n\n\tpeb2466->spi = spi;\n\n\tpeb2466->regmap = devm_regmap_init(&peb2466->spi->dev, NULL, peb2466,\n\t\t\t\t\t   &peb2466_regmap_config);\n\tif (IS_ERR(peb2466->regmap))\n\t\treturn PTR_ERR(peb2466->regmap);\n\n\tpeb2466->reset_gpio = devm_gpiod_get_optional(&peb2466->spi->dev,\n\t\t\t\t\t\t      \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(peb2466->reset_gpio))\n\t\treturn PTR_ERR(peb2466->reset_gpio);\n\n\tpeb2466->mclk = devm_clk_get(&peb2466->spi->dev, \"mclk\");\n\tif (IS_ERR(peb2466->mclk))\n\t\treturn PTR_ERR(peb2466->mclk);\n\tret = clk_prepare_enable(peb2466->mclk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (peb2466->reset_gpio) {\n\t\tgpiod_set_value_cansleep(peb2466->reset_gpio, 1);\n\t\tudelay(4);\n\t\tgpiod_set_value_cansleep(peb2466->reset_gpio, 0);\n\t\tudelay(4);\n\t}\n\n\tspi_set_drvdata(spi, peb2466);\n\n\tmclk_rate = clk_get_rate(peb2466->mclk);\n\tswitch (mclk_rate) {\n\tcase 1536000:\n\t\txr5 = PEB2466_XR5_MCLK_1536;\n\t\tbreak;\n\tcase 2048000:\n\t\txr5 = PEB2466_XR5_MCLK_2048;\n\t\tbreak;\n\tcase 4096000:\n\t\txr5 = PEB2466_XR5_MCLK_4096;\n\t\tbreak;\n\tcase 8192000:\n\t\txr5 = PEB2466_XR5_MCLK_8192;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&peb2466->spi->dev, \"Unsupported clock rate %lu\\n\",\n\t\t\tmclk_rate);\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\tret = regmap_write(peb2466->regmap, PEB2466_XR5, xr5);\n\tif (ret) {\n\t\tdev_err(&peb2466->spi->dev, \"Setting MCLK failed (%d)\\n\", ret);\n\t\tgoto failed;\n\t}\n\n\tret = devm_snd_soc_register_component(&spi->dev, &peb2466_component_driver,\n\t\t\t\t\t      &peb2466_dai_driver, 1);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (IS_ENABLED(CONFIG_GPIOLIB)) {\n\t\tret = peb2466_gpio_init(peb2466);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t}\n\n\treturn 0;\n\nfailed:\n\tclk_disable_unprepare(peb2466->mclk);\n\treturn ret;\n}\n\nstatic void peb2466_spi_remove(struct spi_device *spi)\n{\n\tstruct peb2466 *peb2466 = spi_get_drvdata(spi);\n\n\tclk_disable_unprepare(peb2466->mclk);\n}\n\nstatic const struct of_device_id peb2466_of_match[] = {\n\t{ .compatible = \"infineon,peb2466\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, peb2466_of_match);\n\nstatic const struct spi_device_id peb2466_id_table[] = {\n\t{ \"peb2466\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, peb2466_id_table);\n\nstatic struct spi_driver peb2466_spi_driver = {\n\t.driver  = {\n\t\t.name   = \"peb2466\",\n\t\t.of_match_table = peb2466_of_match,\n\t},\n\t.id_table = peb2466_id_table,\n\t.probe  = peb2466_spi_probe,\n\t.remove = peb2466_spi_remove,\n};\n\nmodule_spi_driver(peb2466_spi_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"PEB2466 ALSA SoC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}