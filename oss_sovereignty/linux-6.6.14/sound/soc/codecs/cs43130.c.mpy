{
  "module_name": "cs43130.c",
  "hash_id": "1d066f0a6297b9fbd8901568823102d5f5b21a8136d888e1bcb93f0779696731",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs43130.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/of_irq.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <sound/jack.h>\n\n#include \"cs43130.h\"\n#include \"cirrus_legacy.h\"\n\nstatic const struct reg_default cs43130_reg_defaults[] = {\n\t{CS43130_SYS_CLK_CTL_1, 0x06},\n\t{CS43130_SP_SRATE, 0x01},\n\t{CS43130_SP_BITSIZE, 0x05},\n\t{CS43130_PAD_INT_CFG, 0x03},\n\t{CS43130_PWDN_CTL, 0xFE},\n\t{CS43130_CRYSTAL_SET, 0x04},\n\t{CS43130_PLL_SET_1, 0x00},\n\t{CS43130_PLL_SET_2, 0x00},\n\t{CS43130_PLL_SET_3, 0x00},\n\t{CS43130_PLL_SET_4, 0x00},\n\t{CS43130_PLL_SET_5, 0x40},\n\t{CS43130_PLL_SET_6, 0x10},\n\t{CS43130_PLL_SET_7, 0x80},\n\t{CS43130_PLL_SET_8, 0x03},\n\t{CS43130_PLL_SET_9, 0x02},\n\t{CS43130_PLL_SET_10, 0x02},\n\t{CS43130_CLKOUT_CTL, 0x00},\n\t{CS43130_ASP_NUM_1, 0x01},\n\t{CS43130_ASP_NUM_2, 0x00},\n\t{CS43130_ASP_DEN_1, 0x08},\n\t{CS43130_ASP_DEN_2, 0x00},\n\t{CS43130_ASP_LRCK_HI_TIME_1, 0x1F},\n\t{CS43130_ASP_LRCK_HI_TIME_2, 0x00},\n\t{CS43130_ASP_LRCK_PERIOD_1, 0x3F},\n\t{CS43130_ASP_LRCK_PERIOD_2, 0x00},\n\t{CS43130_ASP_CLOCK_CONF, 0x0C},\n\t{CS43130_ASP_FRAME_CONF, 0x0A},\n\t{CS43130_XSP_NUM_1, 0x01},\n\t{CS43130_XSP_NUM_2, 0x00},\n\t{CS43130_XSP_DEN_1, 0x02},\n\t{CS43130_XSP_DEN_2, 0x00},\n\t{CS43130_XSP_LRCK_HI_TIME_1, 0x1F},\n\t{CS43130_XSP_LRCK_HI_TIME_2, 0x00},\n\t{CS43130_XSP_LRCK_PERIOD_1, 0x3F},\n\t{CS43130_XSP_LRCK_PERIOD_2, 0x00},\n\t{CS43130_XSP_CLOCK_CONF, 0x0C},\n\t{CS43130_XSP_FRAME_CONF, 0x0A},\n\t{CS43130_ASP_CH_1_LOC, 0x00},\n\t{CS43130_ASP_CH_2_LOC, 0x00},\n\t{CS43130_ASP_CH_1_SZ_EN, 0x06},\n\t{CS43130_ASP_CH_2_SZ_EN, 0x0E},\n\t{CS43130_XSP_CH_1_LOC, 0x00},\n\t{CS43130_XSP_CH_2_LOC, 0x00},\n\t{CS43130_XSP_CH_1_SZ_EN, 0x06},\n\t{CS43130_XSP_CH_2_SZ_EN, 0x0E},\n\t{CS43130_DSD_VOL_B, 0x78},\n\t{CS43130_DSD_VOL_A, 0x78},\n\t{CS43130_DSD_PATH_CTL_1, 0xA8},\n\t{CS43130_DSD_INT_CFG, 0x00},\n\t{CS43130_DSD_PATH_CTL_2, 0x02},\n\t{CS43130_DSD_PCM_MIX_CTL, 0x00},\n\t{CS43130_DSD_PATH_CTL_3, 0x40},\n\t{CS43130_HP_OUT_CTL_1, 0x30},\n\t{CS43130_PCM_FILT_OPT, 0x02},\n\t{CS43130_PCM_VOL_B, 0x78},\n\t{CS43130_PCM_VOL_A, 0x78},\n\t{CS43130_PCM_PATH_CTL_1, 0xA8},\n\t{CS43130_PCM_PATH_CTL_2, 0x00},\n\t{CS43130_CLASS_H_CTL, 0x1E},\n\t{CS43130_HP_DETECT, 0x04},\n\t{CS43130_HP_LOAD_1, 0x00},\n\t{CS43130_HP_MEAS_LOAD_1, 0x00},\n\t{CS43130_HP_MEAS_LOAD_2, 0x00},\n\t{CS43130_INT_MASK_1, 0xFF},\n\t{CS43130_INT_MASK_2, 0xFF},\n\t{CS43130_INT_MASK_3, 0xFF},\n\t{CS43130_INT_MASK_4, 0xFF},\n\t{CS43130_INT_MASK_5, 0xFF},\n};\n\nstatic bool cs43130_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS43130_INT_STATUS_1 ... CS43130_INT_STATUS_5:\n\tcase CS43130_HP_DC_STAT_1 ... CS43130_HP_DC_STAT_2:\n\tcase CS43130_HP_AC_STAT_1 ... CS43130_HP_AC_STAT_2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs43130_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS43130_DEVID_AB ... CS43130_SYS_CLK_CTL_1:\n\tcase CS43130_SP_SRATE ... CS43130_PAD_INT_CFG:\n\tcase CS43130_PWDN_CTL:\n\tcase CS43130_CRYSTAL_SET:\n\tcase CS43130_PLL_SET_1 ... CS43130_PLL_SET_5:\n\tcase CS43130_PLL_SET_6:\n\tcase CS43130_PLL_SET_7:\n\tcase CS43130_PLL_SET_8:\n\tcase CS43130_PLL_SET_9:\n\tcase CS43130_PLL_SET_10:\n\tcase CS43130_CLKOUT_CTL:\n\tcase CS43130_ASP_NUM_1 ... CS43130_ASP_FRAME_CONF:\n\tcase CS43130_XSP_NUM_1 ... CS43130_XSP_FRAME_CONF:\n\tcase CS43130_ASP_CH_1_LOC:\n\tcase CS43130_ASP_CH_2_LOC:\n\tcase CS43130_ASP_CH_1_SZ_EN:\n\tcase CS43130_ASP_CH_2_SZ_EN:\n\tcase CS43130_XSP_CH_1_LOC:\n\tcase CS43130_XSP_CH_2_LOC:\n\tcase CS43130_XSP_CH_1_SZ_EN:\n\tcase CS43130_XSP_CH_2_SZ_EN:\n\tcase CS43130_DSD_VOL_B ... CS43130_DSD_PATH_CTL_3:\n\tcase CS43130_HP_OUT_CTL_1:\n\tcase CS43130_PCM_FILT_OPT ... CS43130_PCM_PATH_CTL_2:\n\tcase CS43130_CLASS_H_CTL:\n\tcase CS43130_HP_DETECT:\n\tcase CS43130_HP_STATUS:\n\tcase CS43130_HP_LOAD_1:\n\tcase CS43130_HP_MEAS_LOAD_1:\n\tcase CS43130_HP_MEAS_LOAD_2:\n\tcase CS43130_HP_DC_STAT_1:\n\tcase CS43130_HP_DC_STAT_2:\n\tcase CS43130_HP_AC_STAT_1:\n\tcase CS43130_HP_AC_STAT_2:\n\tcase CS43130_HP_LOAD_STAT:\n\tcase CS43130_INT_STATUS_1 ... CS43130_INT_STATUS_5:\n\tcase CS43130_INT_MASK_1 ... CS43130_INT_MASK_5:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool cs43130_precious_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS43130_INT_STATUS_1 ... CS43130_INT_STATUS_5:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct cs43130_pll_params {\n\tunsigned int pll_in;\n\tu8 sclk_prediv;\n\tu8 pll_div_int;\n\tu32 pll_div_frac;\n\tu8 pll_mode;\n\tu8 pll_divout;\n\tunsigned int pll_out;\n\tu8 pll_cal_ratio;\n};\n\nstatic const struct cs43130_pll_params pll_ratio_table[] = {\n\t{9600000, 0x02, 0x49, 0x800000, 0x00, 0x08, 22579200, 151},\n\t{9600000, 0x02, 0x50, 0x000000, 0x00, 0x08, 24576000, 164},\n\n\t{11289600, 0x02, 0X40, 0, 0x01, 0x08, 22579200, 128},\n\t{11289600, 0x02, 0x44, 0x06F700, 0x0, 0x08, 24576000, 139},\n\n\t{12000000, 0x02, 0x49, 0x800000, 0x00, 0x0A, 22579200, 120},\n\t{12000000, 0x02, 0x40, 0x000000, 0x00, 0x08, 24576000, 131},\n\n\t{12288000, 0x02, 0x49, 0x800000, 0x01, 0x0A, 22579200, 118},\n\t{12288000, 0x02, 0x40, 0x000000, 0x01, 0x08, 24576000, 128},\n\n\t{13000000, 0x02, 0x45, 0x797680, 0x01, 0x0A, 22579200, 111},\n\t{13000000, 0x02, 0x3C, 0x7EA940, 0x01, 0x08, 24576000, 121},\n\n\t{19200000, 0x03, 0x49, 0x800000, 0x00, 0x08, 22579200, 151},\n\t{19200000, 0x03, 0x50, 0x000000, 0x00, 0x08, 24576000, 164},\n\n\t{22579200, 0, 0, 0, 0, 0, 22579200, 0},\n\t{22579200, 0x03, 0x44, 0x06F700, 0x00, 0x08, 24576000, 139},\n\n\t{24000000, 0x03, 0x49, 0x800000, 0x00, 0x0A, 22579200, 120},\n\t{24000000, 0x03, 0x40, 0x000000, 0x00, 0x08, 24576000, 131},\n\n\t{24576000, 0x03, 0x49, 0x800000, 0x01, 0x0A, 22579200, 118},\n\t{24576000, 0, 0, 0, 0, 0, 24576000, 0},\n\n\t{26000000, 0x03, 0x45, 0x797680, 0x01, 0x0A, 22579200, 111},\n\t{26000000, 0x03, 0x3C, 0x7EA940, 0x01, 0x08, 24576000, 121},\n};\n\nstatic const struct cs43130_pll_params *cs43130_get_pll_table(\n\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(pll_ratio_table); i++) {\n\t\tif (pll_ratio_table[i].pll_in == freq_in &&\n\t\t    pll_ratio_table[i].pll_out == freq_out)\n\t\t\treturn &pll_ratio_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int cs43130_pll_config(struct snd_soc_component *component)\n{\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tconst struct cs43130_pll_params *pll_entry;\n\n\tdev_dbg(component->dev, \"cs43130->mclk = %u, cs43130->mclk_int = %u\\n\",\n\t\tcs43130->mclk, cs43130->mclk_int);\n\n\tpll_entry = cs43130_get_pll_table(cs43130->mclk, cs43130->mclk_int);\n\tif (!pll_entry)\n\t\treturn -EINVAL;\n\n\tif (pll_entry->pll_cal_ratio == 0) {\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_1,\n\t\t\t\t   CS43130_PLL_START_MASK, 0);\n\n\t\tcs43130->pll_bypass = true;\n\t\treturn 0;\n\t}\n\n\tcs43130->pll_bypass = false;\n\n\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_2,\n\t\t\t   CS43130_PLL_DIV_DATA_MASK,\n\t\t\t   pll_entry->pll_div_frac >>\n\t\t\t   CS43130_PLL_DIV_FRAC_0_DATA_SHIFT);\n\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_3,\n\t\t\t   CS43130_PLL_DIV_DATA_MASK,\n\t\t\t   pll_entry->pll_div_frac >>\n\t\t\t   CS43130_PLL_DIV_FRAC_1_DATA_SHIFT);\n\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_4,\n\t\t\t   CS43130_PLL_DIV_DATA_MASK,\n\t\t\t   pll_entry->pll_div_frac >>\n\t\t\t   CS43130_PLL_DIV_FRAC_2_DATA_SHIFT);\n\tregmap_write(cs43130->regmap, CS43130_PLL_SET_5,\n\t\t     pll_entry->pll_div_int);\n\tregmap_write(cs43130->regmap, CS43130_PLL_SET_6, pll_entry->pll_divout);\n\tregmap_write(cs43130->regmap, CS43130_PLL_SET_7,\n\t\t     pll_entry->pll_cal_ratio);\n\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_8,\n\t\t\t   CS43130_PLL_MODE_MASK,\n\t\t\t   pll_entry->pll_mode << CS43130_PLL_MODE_SHIFT);\n\tregmap_write(cs43130->regmap, CS43130_PLL_SET_9,\n\t\t     pll_entry->sclk_prediv);\n\tregmap_update_bits(cs43130->regmap, CS43130_PLL_SET_1,\n\t\t\t   CS43130_PLL_START_MASK, 1);\n\n\treturn 0;\n}\n\nstatic int cs43130_set_pll(struct snd_soc_component *component, int pll_id, int source,\n\t\t\t   unsigned int freq_in, unsigned int freq_out)\n{\n\tint ret = 0;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (freq_in) {\n\tcase 9600000:\n\tcase 11289600:\n\tcase 12000000:\n\tcase 12288000:\n\tcase 13000000:\n\tcase 19200000:\n\tcase 22579200:\n\tcase 24000000:\n\tcase 24576000:\n\tcase 26000000:\n\t\tcs43130->mclk = freq_in;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"unsupported pll input reference clock:%d\\n\", freq_in);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (freq_out) {\n\tcase 22579200:\n\t\tcs43130->mclk_int = freq_out;\n\t\tbreak;\n\tcase 24576000:\n\t\tcs43130->mclk_int = freq_out;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"unsupported pll output ref clock: %u\\n\", freq_out);\n\t\treturn -EINVAL;\n\t}\n\n\tret = cs43130_pll_config(component);\n\tdev_dbg(component->dev, \"cs43130->pll_bypass = %d\", cs43130->pll_bypass);\n\treturn ret;\n}\n\nstatic int cs43130_change_clksrc(struct snd_soc_component *component,\n\t\t\t\t enum cs43130_mclk_src_sel src)\n{\n\tint ret;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tint mclk_int_decoded;\n\n\tif (src == cs43130->mclk_int_src) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tswitch (cs43130->mclk_int) {\n\tcase CS43130_MCLK_22M:\n\t\tmclk_int_decoded = CS43130_MCLK_22P5;\n\t\tbreak;\n\tcase CS43130_MCLK_24M:\n\t\tmclk_int_decoded = CS43130_MCLK_24P5;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid MCLK INT freq: %u\\n\", cs43130->mclk_int);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (src) {\n\tcase CS43130_MCLK_SRC_EXT:\n\t\tcs43130->pll_bypass = true;\n\t\tcs43130->mclk_int_src = CS43130_MCLK_SRC_EXT;\n\t\tif (cs43130->xtal_ibias == CS43130_XTAL_UNUSED) {\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t\t   CS43130_PDN_XTAL_MASK,\n\t\t\t\t\t   1 << CS43130_PDN_XTAL_SHIFT);\n\t\t} else {\n\t\t\treinit_completion(&cs43130->xtal_rdy);\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t\t   CS43130_XTAL_RDY_INT_MASK, 0);\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t\t   CS43130_PDN_XTAL_MASK, 0);\n\t\t\tret = wait_for_completion_timeout(&cs43130->xtal_rdy,\n\t\t\t\t\t\t\t  msecs_to_jiffies(100));\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t\t   CS43130_XTAL_RDY_INT_MASK,\n\t\t\t\t\t   1 << CS43130_XTAL_RDY_INT_SHIFT);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_err(component->dev, \"Timeout waiting for XTAL_READY interrupt\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_SRC_SEL_MASK,\n\t\t\t\t   src << CS43130_MCLK_SRC_SEL_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_INT_MASK,\n\t\t\t\t   mclk_int_decoded << CS43130_MCLK_INT_SHIFT);\n\t\tusleep_range(150, 200);\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t   CS43130_PDN_PLL_MASK,\n\t\t\t\t   1 << CS43130_PDN_PLL_SHIFT);\n\t\tbreak;\n\tcase CS43130_MCLK_SRC_PLL:\n\t\tcs43130->pll_bypass = false;\n\t\tcs43130->mclk_int_src = CS43130_MCLK_SRC_PLL;\n\t\tif (cs43130->xtal_ibias == CS43130_XTAL_UNUSED) {\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t\t   CS43130_PDN_XTAL_MASK,\n\t\t\t\t\t   1 << CS43130_PDN_XTAL_SHIFT);\n\t\t} else {\n\t\t\treinit_completion(&cs43130->xtal_rdy);\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t\t   CS43130_XTAL_RDY_INT_MASK, 0);\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t\t   CS43130_PDN_XTAL_MASK, 0);\n\t\t\tret = wait_for_completion_timeout(&cs43130->xtal_rdy,\n\t\t\t\t\t\t\t  msecs_to_jiffies(100));\n\t\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t\t   CS43130_XTAL_RDY_INT_MASK,\n\t\t\t\t\t   1 << CS43130_XTAL_RDY_INT_SHIFT);\n\t\t\tif (ret == 0) {\n\t\t\t\tdev_err(component->dev, \"Timeout waiting for XTAL_READY interrupt\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\treinit_completion(&cs43130->pll_rdy);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_PLL_RDY_INT_MASK, 0);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t   CS43130_PDN_PLL_MASK, 0);\n\t\tret = wait_for_completion_timeout(&cs43130->pll_rdy,\n\t\t\t\t\t\t  msecs_to_jiffies(100));\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_PLL_RDY_INT_MASK,\n\t\t\t\t   1 << CS43130_PLL_RDY_INT_SHIFT);\n\t\tif (ret == 0) {\n\t\t\tdev_err(component->dev, \"Timeout waiting for PLL_READY interrupt\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_SRC_SEL_MASK,\n\t\t\t\t   src << CS43130_MCLK_SRC_SEL_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_INT_MASK,\n\t\t\t\t   mclk_int_decoded << CS43130_MCLK_INT_SHIFT);\n\t\tusleep_range(150, 200);\n\t\tbreak;\n\tcase CS43130_MCLK_SRC_RCO:\n\t\tcs43130->mclk_int_src = CS43130_MCLK_SRC_RCO;\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_SRC_SEL_MASK,\n\t\t\t\t   src << CS43130_MCLK_SRC_SEL_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_SYS_CLK_CTL_1,\n\t\t\t\t   CS43130_MCLK_INT_MASK,\n\t\t\t\t   CS43130_MCLK_22P5 << CS43130_MCLK_INT_SHIFT);\n\t\tusleep_range(150, 200);\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t   CS43130_PDN_XTAL_MASK,\n\t\t\t\t   1 << CS43130_PDN_XTAL_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PWDN_CTL,\n\t\t\t\t   CS43130_PDN_PLL_MASK,\n\t\t\t\t   1 << CS43130_PDN_PLL_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid MCLK source value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct cs43130_bitwidth_map cs43130_bitwidth_table[] = {\n\t{8,\tCS43130_SP_BIT_SIZE_8,\tCS43130_CH_BIT_SIZE_8},\n\t{16,\tCS43130_SP_BIT_SIZE_16, CS43130_CH_BIT_SIZE_16},\n\t{24,\tCS43130_SP_BIT_SIZE_24, CS43130_CH_BIT_SIZE_24},\n\t{32,\tCS43130_SP_BIT_SIZE_32, CS43130_CH_BIT_SIZE_32},\n};\n\nstatic const struct cs43130_bitwidth_map *cs43130_get_bitwidth_table(\n\t\t\t\tunsigned int bitwidth)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs43130_bitwidth_table); i++) {\n\t\tif (cs43130_bitwidth_table[i].bitwidth == bitwidth)\n\t\t\treturn &cs43130_bitwidth_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int cs43130_set_bitwidth(int dai_id, unsigned int bitwidth_dai,\n\t\t\t  struct regmap *regmap)\n{\n\tconst struct cs43130_bitwidth_map *bw_map;\n\n\tbw_map = cs43130_get_bitwidth_table(bitwidth_dai);\n\tif (!bw_map)\n\t\treturn -EINVAL;\n\n\tswitch (dai_id) {\n\tcase CS43130_ASP_PCM_DAI:\n\tcase CS43130_ASP_DOP_DAI:\n\t\tregmap_update_bits(regmap, CS43130_ASP_CH_1_SZ_EN,\n\t\t\t\t   CS43130_CH_BITSIZE_MASK, bw_map->ch_bit);\n\t\tregmap_update_bits(regmap, CS43130_ASP_CH_2_SZ_EN,\n\t\t\t\t   CS43130_CH_BITSIZE_MASK, bw_map->ch_bit);\n\t\tregmap_update_bits(regmap, CS43130_SP_BITSIZE,\n\t\t\t\t   CS43130_ASP_BITSIZE_MASK, bw_map->sp_bit);\n\t\tbreak;\n\tcase CS43130_XSP_DOP_DAI:\n\t\tregmap_update_bits(regmap, CS43130_XSP_CH_1_SZ_EN,\n\t\t\t\t   CS43130_CH_BITSIZE_MASK, bw_map->ch_bit);\n\t\tregmap_update_bits(regmap, CS43130_XSP_CH_2_SZ_EN,\n\t\t\t\t   CS43130_CH_BITSIZE_MASK, bw_map->ch_bit);\n\t\tregmap_update_bits(regmap, CS43130_SP_BITSIZE,\n\t\t\t\t   CS43130_XSP_BITSIZE_MASK, bw_map->sp_bit <<\n\t\t\t\t   CS43130_XSP_BITSIZE_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct cs43130_rate_map cs43130_rate_table[] = {\n\t{32000,\t\tCS43130_ASP_SPRATE_32K},\n\t{44100,\t\tCS43130_ASP_SPRATE_44_1K},\n\t{48000,\t\tCS43130_ASP_SPRATE_48K},\n\t{88200,\t\tCS43130_ASP_SPRATE_88_2K},\n\t{96000,\t\tCS43130_ASP_SPRATE_96K},\n\t{176400,\tCS43130_ASP_SPRATE_176_4K},\n\t{192000,\tCS43130_ASP_SPRATE_192K},\n\t{352800,\tCS43130_ASP_SPRATE_352_8K},\n\t{384000,\tCS43130_ASP_SPRATE_384K},\n};\n\nstatic const struct cs43130_rate_map *cs43130_get_rate_table(int fs)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs43130_rate_table); i++) {\n\t\tif (cs43130_rate_table[i].fs == fs)\n\t\t\treturn &cs43130_rate_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct cs43130_clk_gen *cs43130_get_clk_gen(int mclk_int, int fs,\n\t\tconst struct cs43130_clk_gen *clk_gen_table, int len_clk_gen_table)\n{\n\tint i;\n\n\tfor (i = 0; i < len_clk_gen_table; i++) {\n\t\tif (clk_gen_table[i].mclk_int == mclk_int &&\n\t\t    clk_gen_table[i].fs == fs)\n\t\t\treturn &clk_gen_table[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int cs43130_set_sp_fmt(int dai_id, unsigned int bitwidth_sclk,\n\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t      struct cs43130_private *cs43130)\n{\n\tu16 frm_size;\n\tu16 hi_size;\n\tu8 frm_delay;\n\tu8 frm_phase;\n\tu8 frm_data;\n\tu8 sclk_edge;\n\tu8 lrck_edge;\n\tu8 clk_data;\n\tu8 loc_ch1;\n\tu8 loc_ch2;\n\tu8 dai_mode_val;\n\tconst struct cs43130_clk_gen *clk_gen;\n\n\tswitch (cs43130->dais[dai_id].dai_format) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\thi_size = bitwidth_sclk;\n\t\tfrm_delay = 2;\n\t\tfrm_phase = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\thi_size = bitwidth_sclk;\n\t\tfrm_delay = 0;\n\t\tfrm_phase = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\thi_size = 1;\n\t\tfrm_delay = 2;\n\t\tfrm_phase = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\thi_size = 1;\n\t\tfrm_delay = 0;\n\t\tfrm_phase = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cs43130->dais[dai_id].dai_mode) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tdai_mode_val = 0;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tdai_mode_val = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfrm_size = bitwidth_sclk * params_channels(params);\n\tsclk_edge = 1;\n\tlrck_edge = 0;\n\tloc_ch1 = 0;\n\tloc_ch2 = bitwidth_sclk * (params_channels(params) - 1);\n\n\tfrm_data = frm_delay & CS43130_SP_FSD_MASK;\n\tfrm_data |= (frm_phase << CS43130_SP_STP_SHIFT) & CS43130_SP_STP_MASK;\n\n\tclk_data = lrck_edge & CS43130_SP_LCPOL_IN_MASK;\n\tclk_data |= (lrck_edge << CS43130_SP_LCPOL_OUT_SHIFT) &\n\t\t    CS43130_SP_LCPOL_OUT_MASK;\n\tclk_data |= (sclk_edge << CS43130_SP_SCPOL_IN_SHIFT) &\n\t\t    CS43130_SP_SCPOL_IN_MASK;\n\tclk_data |= (sclk_edge << CS43130_SP_SCPOL_OUT_SHIFT) &\n\t\t    CS43130_SP_SCPOL_OUT_MASK;\n\tclk_data |= (dai_mode_val << CS43130_SP_MODE_SHIFT) &\n\t\t    CS43130_SP_MODE_MASK;\n\n\tswitch (dai_id) {\n\tcase CS43130_ASP_PCM_DAI:\n\tcase CS43130_ASP_DOP_DAI:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_LRCK_PERIOD_1,\n\t\t\tCS43130_SP_LCPR_DATA_MASK, (frm_size - 1) >>\n\t\t\tCS43130_SP_LCPR_LSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_LRCK_PERIOD_2,\n\t\t\tCS43130_SP_LCPR_DATA_MASK, (frm_size - 1) >>\n\t\t\tCS43130_SP_LCPR_MSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_LRCK_HI_TIME_1,\n\t\t\tCS43130_SP_LCHI_DATA_MASK, (hi_size - 1) >>\n\t\t\tCS43130_SP_LCHI_LSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_LRCK_HI_TIME_2,\n\t\t\tCS43130_SP_LCHI_DATA_MASK, (hi_size - 1) >>\n\t\t\tCS43130_SP_LCHI_MSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_FRAME_CONF, frm_data);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_CH_1_LOC, loc_ch1);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_CH_2_LOC, loc_ch2);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_CH_1_SZ_EN,\n\t\t\tCS43130_CH_EN_MASK, 1 << CS43130_CH_EN_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_ASP_CH_2_SZ_EN,\n\t\t\tCS43130_CH_EN_MASK, 1 << CS43130_CH_EN_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_CLOCK_CONF, clk_data);\n\t\tbreak;\n\tcase CS43130_XSP_DOP_DAI:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_LRCK_PERIOD_1,\n\t\t\tCS43130_SP_LCPR_DATA_MASK, (frm_size - 1) >>\n\t\t\tCS43130_SP_LCPR_LSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_LRCK_PERIOD_2,\n\t\t\tCS43130_SP_LCPR_DATA_MASK, (frm_size - 1) >>\n\t\t\tCS43130_SP_LCPR_MSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_LRCK_HI_TIME_1,\n\t\t\tCS43130_SP_LCHI_DATA_MASK, (hi_size - 1) >>\n\t\t\tCS43130_SP_LCHI_LSB_DATA_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_LRCK_HI_TIME_2,\n\t\t\tCS43130_SP_LCHI_DATA_MASK, (hi_size - 1) >>\n\t\t\tCS43130_SP_LCHI_MSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_FRAME_CONF, frm_data);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_CH_1_LOC, loc_ch1);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_CH_2_LOC, loc_ch2);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_CH_1_SZ_EN,\n\t\t\tCS43130_CH_EN_MASK, 1 << CS43130_CH_EN_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_XSP_CH_2_SZ_EN,\n\t\t\tCS43130_CH_EN_MASK, 1 << CS43130_CH_EN_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_CLOCK_CONF, clk_data);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (frm_size) {\n\tcase 16:\n\t\tclk_gen = cs43130_get_clk_gen(cs43130->mclk_int,\n\t\t\t\t\t      params_rate(params),\n\t\t\t\t\t      cs43130_16_clk_gen,\n\t\t\t\t\t      ARRAY_SIZE(cs43130_16_clk_gen));\n\t\tbreak;\n\tcase 32:\n\t\tclk_gen = cs43130_get_clk_gen(cs43130->mclk_int,\n\t\t\t\t\t      params_rate(params),\n\t\t\t\t\t      cs43130_32_clk_gen,\n\t\t\t\t\t      ARRAY_SIZE(cs43130_32_clk_gen));\n\t\tbreak;\n\tcase 48:\n\t\tclk_gen = cs43130_get_clk_gen(cs43130->mclk_int,\n\t\t\t\t\t      params_rate(params),\n\t\t\t\t\t      cs43130_48_clk_gen,\n\t\t\t\t\t      ARRAY_SIZE(cs43130_48_clk_gen));\n\t\tbreak;\n\tcase 64:\n\t\tclk_gen = cs43130_get_clk_gen(cs43130->mclk_int,\n\t\t\t\t\t      params_rate(params),\n\t\t\t\t\t      cs43130_64_clk_gen,\n\t\t\t\t\t      ARRAY_SIZE(cs43130_64_clk_gen));\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!clk_gen)\n\t\treturn -EINVAL;\n\n\tswitch (dai_id) {\n\tcase CS43130_ASP_PCM_DAI:\n\tcase CS43130_ASP_DOP_DAI:\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_DEN_1,\n\t\t\t     (clk_gen->v.denominator & CS43130_SP_M_LSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_M_LSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_DEN_2,\n\t\t\t     (clk_gen->v.denominator & CS43130_SP_M_MSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_M_MSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_NUM_1,\n\t\t\t     (clk_gen->v.numerator & CS43130_SP_N_LSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_N_LSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_ASP_NUM_2,\n\t\t\t     (clk_gen->v.numerator & CS43130_SP_N_MSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_N_MSB_DATA_SHIFT);\n\t\tbreak;\n\tcase CS43130_XSP_DOP_DAI:\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_DEN_1,\n\t\t\t     (clk_gen->v.denominator & CS43130_SP_M_LSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_M_LSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_DEN_2,\n\t\t\t     (clk_gen->v.denominator & CS43130_SP_M_MSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_M_MSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_NUM_1,\n\t\t\t     (clk_gen->v.numerator & CS43130_SP_N_LSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_N_LSB_DATA_SHIFT);\n\t\tregmap_write(cs43130->regmap, CS43130_XSP_NUM_2,\n\t\t\t     (clk_gen->v.numerator & CS43130_SP_N_MSB_DATA_MASK) >>\n\t\t\t     CS43130_SP_N_MSB_DATA_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs43130_pcm_dsd_mix(bool en, struct regmap *regmap)\n{\n\tif (en) {\n\t\tregmap_update_bits(regmap, CS43130_DSD_PCM_MIX_CTL,\n\t\t\t\t   CS43130_MIX_PCM_PREP_MASK,\n\t\t\t\t   1 << CS43130_MIX_PCM_PREP_SHIFT);\n\t\tusleep_range(6000, 6050);\n\t\tregmap_update_bits(regmap, CS43130_DSD_PCM_MIX_CTL,\n\t\t\t\t   CS43130_MIX_PCM_DSD_MASK,\n\t\t\t\t   1 << CS43130_MIX_PCM_DSD_SHIFT);\n\t} else {\n\t\tregmap_update_bits(regmap, CS43130_DSD_PCM_MIX_CTL,\n\t\t\t\t   CS43130_MIX_PCM_DSD_MASK,\n\t\t\t\t   0 << CS43130_MIX_PCM_DSD_SHIFT);\n\t\tusleep_range(1600, 1650);\n\t\tregmap_update_bits(regmap, CS43130_DSD_PCM_MIX_CTL,\n\t\t\t\t   CS43130_MIX_PCM_PREP_MASK,\n\t\t\t\t   0 << CS43130_MIX_PCM_PREP_SHIFT);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs43130_dsd_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tunsigned int required_clk;\n\tu8 dsd_speed;\n\n\tmutex_lock(&cs43130->clk_mutex);\n\tif (!cs43130->clk_req) {\n\t\t \n\t\tif (!(CS43130_MCLK_22M % params_rate(params)))\n\t\t\trequired_clk = CS43130_MCLK_22M;\n\t\telse\n\t\t\trequired_clk = CS43130_MCLK_24M;\n\n\t\tcs43130_set_pll(component, 0, 0, cs43130->mclk, required_clk);\n\t\tif (cs43130->pll_bypass)\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_EXT);\n\t\telse\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_PLL);\n\t}\n\n\tcs43130->clk_req++;\n\tif (cs43130->clk_req == 2)\n\t\tcs43130_pcm_dsd_mix(true, cs43130->regmap);\n\tmutex_unlock(&cs43130->clk_mutex);\n\n\tswitch (params_rate(params)) {\n\tcase 176400:\n\t\tdsd_speed = 0;\n\t\tbreak;\n\tcase 352800:\n\t\tdsd_speed = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate(%u) not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tif (cs43130->dais[dai->id].dai_mode == SND_SOC_DAIFMT_CBM_CFM)\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_INT_CFG,\n\t\t\t\t   CS43130_DSD_MASTER, CS43130_DSD_MASTER);\n\telse\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_INT_CFG,\n\t\t\t\t   CS43130_DSD_MASTER, 0);\n\n\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_2,\n\t\t\t   CS43130_DSD_SPEED_MASK,\n\t\t\t   dsd_speed << CS43130_DSD_SPEED_SHIFT);\n\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_2,\n\t\t\t   CS43130_DSD_SRC_MASK, CS43130_DSD_SRC_DSD <<\n\t\t\t   CS43130_DSD_SRC_SHIFT);\n\n\treturn 0;\n}\n\nstatic int cs43130_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tconst struct cs43130_rate_map *rate_map;\n\tunsigned int sclk = cs43130->dais[dai->id].sclk;\n\tunsigned int bitwidth_sclk;\n\tunsigned int bitwidth_dai = (unsigned int)(params_width(params));\n\tunsigned int required_clk;\n\tu8 dsd_speed;\n\n\tmutex_lock(&cs43130->clk_mutex);\n\tif (!cs43130->clk_req) {\n\t\t \n\t\tif (!(CS43130_MCLK_22M % params_rate(params)))\n\t\t\trequired_clk = CS43130_MCLK_22M;\n\t\telse\n\t\t\trequired_clk = CS43130_MCLK_24M;\n\n\t\tcs43130_set_pll(component, 0, 0, cs43130->mclk, required_clk);\n\t\tif (cs43130->pll_bypass)\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_EXT);\n\t\telse\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_PLL);\n\t}\n\n\tcs43130->clk_req++;\n\tif (cs43130->clk_req == 2)\n\t\tcs43130_pcm_dsd_mix(true, cs43130->regmap);\n\tmutex_unlock(&cs43130->clk_mutex);\n\n\tswitch (dai->id) {\n\tcase CS43130_ASP_DOP_DAI:\n\tcase CS43130_XSP_DOP_DAI:\n\t\t \n\t\tbitwidth_dai = 24;\n\t\tsclk = params_rate(params) * bitwidth_dai *\n\t\t       params_channels(params);\n\n\t\tswitch (params_rate(params)) {\n\t\tcase 176400:\n\t\t\tdsd_speed = 0;\n\t\t\tbreak;\n\t\tcase 352800:\n\t\t\tdsd_speed = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Rate(%u) not supported\\n\",\n\t\t\t\tparams_rate(params));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_2,\n\t\t\t\t   CS43130_DSD_SPEED_MASK,\n\t\t\t\t   dsd_speed << CS43130_DSD_SPEED_SHIFT);\n\t\tbreak;\n\tcase CS43130_ASP_PCM_DAI:\n\t\trate_map = cs43130_get_rate_table(params_rate(params));\n\t\tif (!rate_map)\n\t\t\treturn -EINVAL;\n\n\t\tregmap_write(cs43130->regmap, CS43130_SP_SRATE, rate_map->val);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI (%d)\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dai->id) {\n\tcase CS43130_ASP_DOP_DAI:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_2,\n\t\t\t\t   CS43130_DSD_SRC_MASK, CS43130_DSD_SRC_ASP <<\n\t\t\t\t   CS43130_DSD_SRC_SHIFT);\n\t\tbreak;\n\tcase CS43130_XSP_DOP_DAI:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_2,\n\t\t\t\t   CS43130_DSD_SRC_MASK, CS43130_DSD_SRC_XSP <<\n\t\t\t\t   CS43130_DSD_SRC_SHIFT);\n\t\tbreak;\n\t}\n\n\tif (!sclk && cs43130->dais[dai->id].dai_mode == SND_SOC_DAIFMT_CBM_CFM)\n\t\t \n\t\tsclk = params_rate(params) * bitwidth_dai *\n\t\t       params_channels(params);\n\n\tif (!sclk) {\n\t\t \n\t\tdev_err(component->dev, \"SCLK freq is not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitwidth_sclk = (sclk / params_rate(params)) / params_channels(params);\n\tif (bitwidth_sclk < bitwidth_dai) {\n\t\tdev_err(component->dev, \"Format not supported: SCLK freq is too low\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev,\n\t\t\"sclk = %u, fs = %d, bitwidth_dai = %u\\n\",\n\t\tsclk, params_rate(params), bitwidth_dai);\n\n\tdev_dbg(component->dev,\n\t\t\"bitwidth_sclk = %u, num_ch = %u\\n\",\n\t\tbitwidth_sclk, params_channels(params));\n\n\tcs43130_set_bitwidth(dai->id, bitwidth_dai, cs43130->regmap);\n\tcs43130_set_sp_fmt(dai->id, bitwidth_sclk, params, cs43130);\n\n\treturn 0;\n}\n\nstatic int cs43130_hw_free(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&cs43130->clk_mutex);\n\tcs43130->clk_req--;\n\tif (!cs43130->clk_req) {\n\t\t \n\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_RCO);\n\t\tcs43130_pcm_dsd_mix(false, cs43130->regmap);\n\t}\n\tmutex_unlock(&cs43130->clk_mutex);\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(pcm_vol_tlv, -12750, 50, 1);\n\nstatic const char * const pcm_ch_text[] = {\n\t\"Left-Right Ch\",\n\t\"Left-Left Ch\",\n\t\"Right-Left Ch\",\n\t\"Right-Right Ch\",\n};\n\nstatic const struct reg_sequence pcm_ch_en_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{0x180005, 0x8C},\n\t{0x180007, 0xAB},\n\t{0x180015, 0x31},\n\t{0x180017, 0xB2},\n\t{0x180025, 0x30},\n\t{0x180027, 0x84},\n\t{0x180035, 0x9C},\n\t{0x180037, 0xAE},\n\t{0x18000D, 0x24},\n\t{0x18000F, 0xA3},\n\t{0x18001D, 0x05},\n\t{0x18001F, 0xD4},\n\t{0x18002D, 0x0B},\n\t{0x18002F, 0xC7},\n\t{0x18003D, 0x71},\n\t{0x18003F, 0xE7},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence pcm_ch_dis_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{0x180005, 0x24},\n\t{0x180007, 0xA3},\n\t{0x180015, 0x05},\n\t{0x180017, 0xD4},\n\t{0x180025, 0x0B},\n\t{0x180027, 0xC7},\n\t{0x180035, 0x71},\n\t{0x180037, 0xE7},\n\t{0x18000D, 0x8C},\n\t{0x18000F, 0xAB},\n\t{0x18001D, 0x31},\n\t{0x18001F, 0xB2},\n\t{0x18002D, 0x30},\n\t{0x18002F, 0x84},\n\t{0x18003D, 0x9C},\n\t{0x18003F, 0xAE},\n\t{CS43130_DXD1, 0},\n};\n\nstatic int cs43130_pcm_ch_get(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\treturn snd_soc_get_enum_double(kcontrol, ucontrol);\n}\n\nstatic int cs43130_pcm_ch_put(struct snd_kcontrol *kcontrol,\n\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\tswitch (cs43130->dev_id) {\n\tcase CS43131_CHIP_ID:\n\tcase CS43198_CHIP_ID:\n\t\tif (val >= 2)\n\t\t\tregmap_multi_reg_write(cs43130->regmap, pcm_ch_en_seq,\n\t\t\t\t\t       ARRAY_SIZE(pcm_ch_en_seq));\n\t\telse\n\t\t\tregmap_multi_reg_write(cs43130->regmap, pcm_ch_dis_seq,\n\t\t\t\t\t       ARRAY_SIZE(pcm_ch_dis_seq));\n\t\tbreak;\n\t}\n\n\treturn snd_soc_put_enum_double(kcontrol, ucontrol);\n}\n\nstatic SOC_ENUM_SINGLE_DECL(pcm_ch_enum, CS43130_PCM_PATH_CTL_2, 0,\n\t\t\t    pcm_ch_text);\n\nstatic const char * const pcm_spd_texts[] = {\n\t\"Fast\",\n\t\"Slow\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(pcm_spd_enum, CS43130_PCM_FILT_OPT, 7,\n\t\t\t    pcm_spd_texts);\n\nstatic const char * const dsd_texts[] = {\n\t\"Off\",\n\t\"BCKA Mode\",\n\t\"BCKD Mode\",\n};\n\nstatic const unsigned int dsd_values[] = {\n\tCS43130_DSD_SRC_DSD,\n\tCS43130_DSD_SRC_ASP,\n\tCS43130_DSD_SRC_XSP,\n};\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(dsd_enum, CS43130_DSD_INT_CFG, 0, 0x03,\n\t\t\t\t  dsd_texts, dsd_values);\n\nstatic const struct snd_kcontrol_new cs43130_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\",\n\t\t\t CS43130_PCM_VOL_A, CS43130_PCM_VOL_B, 0, 0xFF, 1,\n\t\t\t pcm_vol_tlv),\n\tSOC_DOUBLE_R_TLV(\"Master DSD Playback Volume\",\n\t\t\t CS43130_DSD_VOL_A, CS43130_DSD_VOL_B, 0, 0xFF, 1,\n\t\t\t pcm_vol_tlv),\n\tSOC_ENUM_EXT(\"PCM Ch Select\", pcm_ch_enum, cs43130_pcm_ch_get,\n\t\t     cs43130_pcm_ch_put),\n\tSOC_ENUM(\"PCM Filter Speed\", pcm_spd_enum),\n\tSOC_SINGLE(\"PCM Phase Compensation\", CS43130_PCM_FILT_OPT, 6, 1, 0),\n\tSOC_SINGLE(\"PCM Nonoversample Emulate\", CS43130_PCM_FILT_OPT, 5, 1, 0),\n\tSOC_SINGLE(\"PCM High-pass Filter\", CS43130_PCM_FILT_OPT, 1, 1, 0),\n\tSOC_SINGLE(\"PCM De-emphasis Filter\", CS43130_PCM_FILT_OPT, 0, 1, 0),\n\tSOC_ENUM(\"DSD Phase Modulation\", dsd_enum),\n};\n\nstatic const struct reg_sequence pcm_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD7, 0x01},\n\t{CS43130_DXD8, 0},\n\t{CS43130_DXD9, 0x01},\n\t{CS43130_DXD3, 0x12},\n\t{CS43130_DXD4, 0},\n\t{CS43130_DXD10, 0x28},\n\t{CS43130_DXD11, 0x28},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence dsd_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD7, 0x01},\n\t{CS43130_DXD8, 0},\n\t{CS43130_DXD9, 0x01},\n\t{CS43130_DXD3, 0x12},\n\t{CS43130_DXD4, 0},\n\t{CS43130_DXD10, 0x1E},\n\t{CS43130_DXD11, 0x20},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence pop_free_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD12, 0x0A},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence pop_free_seq2[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD13, 0x20},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence mute_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD3, 0x12},\n\t{CS43130_DXD5, 0x02},\n\t{CS43130_DXD4, 0x12},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence unmute_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD3, 0x10},\n\t{CS43130_DXD5, 0},\n\t{CS43130_DXD4, 0x16},\n\t{CS43130_DXD1, 0},\n};\n\nstatic int cs43130_dsd_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, dsd_seq,\n\t\t\t\t\t       ARRAY_SIZE(dsd_seq));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_DSD_PATH_CTL_1,\n\t\t\t\t   CS43130_MUTE_MASK, 0);\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, unmute_seq,\n\t\t\t\t\t       ARRAY_SIZE(unmute_seq));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, mute_seq,\n\t\t\t\t\t       ARRAY_SIZE(mute_seq));\n\t\t\tregmap_update_bits(cs43130->regmap,\n\t\t\t\t\t   CS43130_DSD_PATH_CTL_1,\n\t\t\t\t\t   CS43130_MUTE_MASK, CS43130_MUTE_EN);\n\t\t\t \n\t\t\tmsleep(130);\n\t\t\tbreak;\n\t\tcase CS43131_CHIP_ID:\n\t\tcase CS43198_CHIP_ID:\n\t\t\tregmap_update_bits(cs43130->regmap,\n\t\t\t\t\t   CS43130_DSD_PATH_CTL_1,\n\t\t\t\t\t   CS43130_MUTE_MASK, CS43130_MUTE_EN);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int cs43130_pcm_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, pcm_seq,\n\t\t\t\t\t       ARRAY_SIZE(pcm_seq));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(cs43130->regmap, CS43130_PCM_PATH_CTL_1,\n\t\t\t\t   CS43130_MUTE_MASK, 0);\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, unmute_seq,\n\t\t\t\t\t       ARRAY_SIZE(unmute_seq));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, mute_seq,\n\t\t\t\t\t       ARRAY_SIZE(mute_seq));\n\t\t\tregmap_update_bits(cs43130->regmap,\n\t\t\t\t\t   CS43130_PCM_PATH_CTL_1,\n\t\t\t\t\t   CS43130_MUTE_MASK, CS43130_MUTE_EN);\n\t\t\t \n\t\t\tmsleep(130);\n\t\t\tbreak;\n\t\tcase CS43131_CHIP_ID:\n\t\tcase CS43198_CHIP_ID:\n\t\t\tregmap_update_bits(cs43130->regmap,\n\t\t\t\t\t   CS43130_PCM_PATH_CTL_1,\n\t\t\t\t\t   CS43130_MUTE_MASK, CS43130_MUTE_EN);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct reg_sequence dac_postpmu_seq[] = {\n\t{CS43130_DXD9, 0x0C},\n\t{CS43130_DXD3, 0x10},\n\t{CS43130_DXD4, 0x20},\n};\n\nstatic const struct reg_sequence dac_postpmd_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD6, 0x01},\n\t{CS43130_DXD1, 0},\n};\n\nstatic int cs43130_dac_event(struct snd_soc_dapm_widget *w,\n\t\t\t     struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, pop_free_seq,\n\t\t\t\t\t       ARRAY_SIZE(pop_free_seq));\n\t\t\tbreak;\n\t\tcase CS43131_CHIP_ID:\n\t\tcase CS43198_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, pop_free_seq2,\n\t\t\t\t\t       ARRAY_SIZE(pop_free_seq2));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tusleep_range(10000, 10050);\n\n\t\tregmap_write(cs43130->regmap, CS43130_DXD1, 0x99);\n\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, dac_postpmu_seq,\n\t\t\t\t\t       ARRAY_SIZE(dac_postpmu_seq));\n\t\t\t \n\t\t\tmsleep(1000);\n\t\t\tregmap_write(cs43130->regmap, CS43130_DXD12, 0);\n\t\t\tbreak;\n\t\tcase CS43131_CHIP_ID:\n\t\tcase CS43198_CHIP_ID:\n\t\t\tusleep_range(12000, 12010);\n\t\t\tregmap_write(cs43130->regmap, CS43130_DXD13, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tregmap_write(cs43130->regmap, CS43130_DXD1, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tswitch (cs43130->dev_id) {\n\t\tcase CS43130_CHIP_ID:\n\t\tcase CS4399_CHIP_ID:\n\t\t\tregmap_multi_reg_write(cs43130->regmap, dac_postpmd_seq,\n\t\t\t\t\t       ARRAY_SIZE(dac_postpmd_seq));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAC event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct reg_sequence hpin_prepmd_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD15, 0x64},\n\t{CS43130_DXD14, 0},\n\t{CS43130_DXD2, 0},\n\t{CS43130_DXD1, 0},\n};\n\nstatic const struct reg_sequence hpin_postpmu_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD2, 1},\n\t{CS43130_DXD14, 0xDC},\n\t{CS43130_DXD15, 0xE4},\n\t{CS43130_DXD1, 0},\n};\n\nstatic int cs43130_hpin_event(struct snd_soc_dapm_widget *w,\n\t\t\t      struct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_multi_reg_write(cs43130->regmap, hpin_prepmd_seq,\n\t\t\t\t       ARRAY_SIZE(hpin_prepmd_seq));\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_multi_reg_write(cs43130->regmap, hpin_postpmu_seq,\n\t\t\t\t       ARRAY_SIZE(hpin_postpmu_seq));\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid HPIN event = 0x%x\\n\", event);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget digital_hp_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTA\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOUTB\"),\n\n\tSND_SOC_DAPM_AIF_IN_E(\"ASPIN PCM\", NULL, 0, CS43130_PWDN_CTL,\n\t\t\t      CS43130_PDN_ASP_SHIFT, 1, cs43130_pcm_event,\n\t\t\t      (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_PRE_PMD)),\n\n\tSND_SOC_DAPM_AIF_IN_E(\"ASPIN DoP\", NULL, 0, CS43130_PWDN_CTL,\n\t\t\t      CS43130_PDN_ASP_SHIFT, 1, cs43130_dsd_event,\n\t\t\t      (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_PRE_PMD)),\n\n\tSND_SOC_DAPM_AIF_IN_E(\"XSPIN DoP\", NULL, 0, CS43130_PWDN_CTL,\n\t\t\t      CS43130_PDN_XSP_SHIFT, 1, cs43130_dsd_event,\n\t\t\t      (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_PRE_PMD)),\n\n\tSND_SOC_DAPM_AIF_IN_E(\"XSPIN DSD\", NULL, 0, CS43130_PWDN_CTL,\n\t\t\t      CS43130_PDN_DSDIF_SHIFT, 1, cs43130_dsd_event,\n\t\t\t      (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t       SND_SOC_DAPM_PRE_PMD)),\n\n\tSND_SOC_DAPM_DAC(\"DSD\", NULL, CS43130_DSD_PATH_CTL_2,\n\t\t\t CS43130_DSD_EN_SHIFT, 0),\n\n\tSND_SOC_DAPM_DAC_E(\"HiFi DAC\", NULL, CS43130_PWDN_CTL,\n\t\t\t   CS43130_PDN_HP_SHIFT, 1, cs43130_dac_event,\n\t\t\t   (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |\n\t\t\t    SND_SOC_DAPM_POST_PMD)),\n};\n\nstatic const struct snd_soc_dapm_widget analog_hp_widgets[] = {\n\tSND_SOC_DAPM_DAC_E(\"Analog Playback\", NULL, CS43130_HP_OUT_CTL_1,\n\t\t\t   CS43130_HP_IN_EN_SHIFT, 0, cs43130_hpin_event,\n\t\t\t   (SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)),\n};\n\nstatic struct snd_soc_dapm_widget all_hp_widgets[\n\t\t\tARRAY_SIZE(digital_hp_widgets) +\n\t\t\tARRAY_SIZE(analog_hp_widgets)];\n\nstatic const struct snd_soc_dapm_route digital_hp_routes[] = {\n\t{\"ASPIN PCM\", NULL, \"ASP PCM Playback\"},\n\t{\"ASPIN DoP\", NULL, \"ASP DoP Playback\"},\n\t{\"XSPIN DoP\", NULL, \"XSP DoP Playback\"},\n\t{\"XSPIN DSD\", NULL, \"XSP DSD Playback\"},\n\t{\"DSD\", NULL, \"ASPIN DoP\"},\n\t{\"DSD\", NULL, \"XSPIN DoP\"},\n\t{\"DSD\", NULL, \"XSPIN DSD\"},\n\t{\"HiFi DAC\", NULL, \"ASPIN PCM\"},\n\t{\"HiFi DAC\", NULL, \"DSD\"},\n\t{\"HPOUTA\", NULL, \"HiFi DAC\"},\n\t{\"HPOUTB\", NULL, \"HiFi DAC\"},\n};\n\nstatic const struct snd_soc_dapm_route analog_hp_routes[] = {\n\t{\"HPOUTA\", NULL, \"Analog Playback\"},\n\t{\"HPOUTB\", NULL, \"Analog Playback\"},\n};\n\nstatic struct snd_soc_dapm_route all_hp_routes[\n\t\t\tARRAY_SIZE(digital_hp_routes) +\n\t\t\tARRAY_SIZE(analog_hp_routes)];\n\nstatic const unsigned int cs43130_asp_src_rates[] = {\n\t32000, 44100, 48000, 88200, 96000, 176400, 192000, 352800, 384000\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs43130_asp_constraints = {\n\t.count\t= ARRAY_SIZE(cs43130_asp_src_rates),\n\t.list\t= cs43130_asp_src_rates,\n};\n\nstatic int cs43130_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &cs43130_asp_constraints);\n}\n\nstatic const unsigned int cs43130_dop_src_rates[] = {\n\t176400, 352800,\n};\n\nstatic const struct snd_pcm_hw_constraint_list cs43130_dop_constraints = {\n\t.count\t= ARRAY_SIZE(cs43130_dop_src_rates),\n\t.list\t= cs43130_dop_src_rates,\n};\n\nstatic int cs43130_dop_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\treturn snd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t\t  SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t  &cs43130_dop_constraints);\n}\n\nstatic int cs43130_pcm_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs43130->dais[codec_dai->id].dai_mode = SND_SOC_DAIFMT_CBS_CFS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs43130->dais[codec_dai->id].dai_mode = SND_SOC_DAIFMT_CBM_CFM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"unsupported mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcs43130->dais[codec_dai->id].dai_format = SND_SOC_DAIFMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcs43130->dais[codec_dai->id].dai_format = SND_SOC_DAIFMT_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcs43130->dais[codec_dai->id].dai_format = SND_SOC_DAIFMT_DSP_A;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tcs43130->dais[codec_dai->id].dai_format = SND_SOC_DAIFMT_DSP_B;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev,\n\t\t\t\"unsupported audio format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"dai_id = %d,  dai_mode = %u, dai_format = %u\\n\",\n\t\tcodec_dai->id,\n\t\tcs43130->dais[codec_dai->id].dai_mode,\n\t\tcs43130->dais[codec_dai->id].dai_format);\n\n\treturn 0;\n}\n\nstatic int cs43130_dsd_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs43130->dais[codec_dai->id].dai_mode = SND_SOC_DAIFMT_CBS_CFS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs43130->dais[codec_dai->id].dai_mode = SND_SOC_DAIFMT_CBM_CFM;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported DAI format.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"dai_mode = 0x%x\\n\",\n\t\tcs43130->dais[codec_dai->id].dai_mode);\n\n\treturn 0;\n}\n\nstatic int cs43130_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t  int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tcs43130->dais[codec_dai->id].sclk = freq;\n\tdev_dbg(component->dev, \"dai_id = %d,  sclk = %u\\n\", codec_dai->id,\n\t\tcs43130->dais[codec_dai->id].sclk);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops cs43130_pcm_ops = {\n\t.startup\t= cs43130_pcm_startup,\n\t.hw_params\t= cs43130_hw_params,\n\t.hw_free\t= cs43130_hw_free,\n\t.set_sysclk\t= cs43130_set_sysclk,\n\t.set_fmt\t= cs43130_pcm_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops cs43130_dop_ops = {\n\t.startup\t= cs43130_dop_startup,\n\t.hw_params\t= cs43130_hw_params,\n\t.hw_free\t= cs43130_hw_free,\n\t.set_sysclk\t= cs43130_set_sysclk,\n\t.set_fmt\t= cs43130_pcm_set_fmt,\n};\n\nstatic const struct snd_soc_dai_ops cs43130_dsd_ops = {\n\t.startup        = cs43130_dop_startup,\n\t.hw_params\t= cs43130_dsd_hw_params,\n\t.hw_free\t= cs43130_hw_free,\n\t.set_fmt\t= cs43130_dsd_set_fmt,\n};\n\nstatic struct snd_soc_dai_driver cs43130_dai[] = {\n\t{\n\t\t.name = \"cs43130-asp-pcm\",\n\t\t.id = CS43130_ASP_PCM_DAI,\n\t\t.playback = {\n\t\t\t.stream_name = \"ASP PCM Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS43130_PCM_FORMATS,\n\t\t},\n\t\t.ops = &cs43130_pcm_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{\n\t\t.name = \"cs43130-asp-dop\",\n\t\t.id = CS43130_ASP_DOP_DAI,\n\t\t.playback = {\n\t\t\t.stream_name = \"ASP DoP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS43130_DOP_FORMATS,\n\t\t},\n\t\t.ops = &cs43130_dop_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{\n\t\t.name = \"cs43130-xsp-dop\",\n\t\t.id = CS43130_XSP_DOP_DAI,\n\t\t.playback = {\n\t\t\t.stream_name = \"XSP DoP Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS43130_DOP_FORMATS,\n\t\t},\n\t\t.ops = &cs43130_dop_ops,\n\t\t.symmetric_rate = 1,\n\t},\n\t{\n\t\t.name = \"cs43130-xsp-dsd\",\n\t\t.id = CS43130_XSP_DSD_DAI,\n\t\t.playback = {\n\t\t\t.stream_name = \"XSP DSD Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_KNOT,\n\t\t\t.formats = CS43130_DOP_FORMATS,\n\t\t},\n\t\t.ops = &cs43130_dsd_ops,\n\t},\n\n};\n\nstatic int cs43130_component_set_sysclk(struct snd_soc_component *component,\n\t\t\t\t    int clk_id, int source, unsigned int freq,\n\t\t\t\t    int dir)\n{\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"clk_id = %d, source = %d, freq = %d, dir = %d\\n\",\n\t\tclk_id, source, freq, dir);\n\n\tswitch (freq) {\n\tcase CS43130_MCLK_22M:\n\tcase CS43130_MCLK_24M:\n\t\tcs43130->mclk = freq;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid MCLK INT freq: %u\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\tif (source == CS43130_MCLK_SRC_EXT) {\n\t\tcs43130->pll_bypass = true;\n\t} else {\n\t\tdev_err(component->dev, \"Invalid MCLK source\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u16 cs43130_get_ac_reg_val(u16 ac_freq)\n{\n\t \n\treturn ac_freq / 6;\n}\n\nstatic int cs43130_show_dc(struct device *dev, char *buf, u8 ch)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cs43130_private *cs43130 = i2c_get_clientdata(client);\n\n\tif (!cs43130->hpload_done)\n\t\treturn sysfs_emit(buf, \"NO_HPLOAD\\n\");\n\telse\n\t\treturn sysfs_emit(buf, \"%u\\n\", cs43130->hpload_dc[ch]);\n}\n\nstatic ssize_t hpload_dc_l_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn cs43130_show_dc(dev, buf, HP_LEFT);\n}\n\nstatic ssize_t hpload_dc_r_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn cs43130_show_dc(dev, buf, HP_RIGHT);\n}\n\nstatic const u16 cs43130_ac_freq[CS43130_AC_FREQ] = {\n\t24,\n\t43,\n\t93,\n\t200,\n\t431,\n\t928,\n\t2000,\n\t4309,\n\t9283,\n\t20000,\n};\n\nstatic int cs43130_show_ac(struct device *dev, char *buf, u8 ch)\n{\n\tint i, j = 0, tmp;\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct cs43130_private *cs43130 = i2c_get_clientdata(client);\n\n\tif (cs43130->hpload_done && cs43130->ac_meas) {\n\t\tfor (i = 0; i < ARRAY_SIZE(cs43130_ac_freq); i++) {\n\t\t\ttmp = sysfs_emit_at(buf, j, \"%u\\n\",\n\t\t\t\t\t    cs43130->hpload_ac[i][ch]);\n\t\t\tif (!tmp)\n\t\t\t\tbreak;\n\n\t\t\tj += tmp;\n\t\t}\n\n\t\treturn j;\n\t} else {\n\t\treturn sysfs_emit(buf, \"NO_HPLOAD\\n\");\n\t}\n}\n\nstatic ssize_t hpload_ac_l_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn cs43130_show_ac(dev, buf, HP_LEFT);\n}\n\nstatic ssize_t hpload_ac_r_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn cs43130_show_ac(dev, buf, HP_RIGHT);\n}\n\nstatic DEVICE_ATTR_RO(hpload_dc_l);\nstatic DEVICE_ATTR_RO(hpload_dc_r);\nstatic DEVICE_ATTR_RO(hpload_ac_l);\nstatic DEVICE_ATTR_RO(hpload_ac_r);\n\nstatic struct attribute *hpload_attrs[] = {\n\t&dev_attr_hpload_dc_l.attr,\n\t&dev_attr_hpload_dc_r.attr,\n\t&dev_attr_hpload_ac_l.attr,\n\t&dev_attr_hpload_ac_r.attr,\n};\nATTRIBUTE_GROUPS(hpload);\n\nstatic struct reg_sequence hp_en_cal_seq[] = {\n\t{CS43130_INT_MASK_4, CS43130_INT_MASK_ALL},\n\t{CS43130_HP_MEAS_LOAD_1, 0},\n\t{CS43130_HP_MEAS_LOAD_2, 0},\n\t{CS43130_INT_MASK_4, 0},\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD16, 0xBB},\n\t{CS43130_DXD12, 0x01},\n\t{CS43130_DXD19, 0xCB},\n\t{CS43130_DXD17, 0x95},\n\t{CS43130_DXD18, 0x0B},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0x80},\n};\n\nstatic struct reg_sequence hp_en_cal_seq2[] = {\n\t{CS43130_INT_MASK_4, CS43130_INT_MASK_ALL},\n\t{CS43130_HP_MEAS_LOAD_1, 0},\n\t{CS43130_HP_MEAS_LOAD_2, 0},\n\t{CS43130_INT_MASK_4, 0},\n\t{CS43130_HP_LOAD_1, 0x80},\n};\n\nstatic struct reg_sequence hp_dis_cal_seq[] = {\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD12, 0},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0},\n};\n\nstatic struct reg_sequence hp_dis_cal_seq2[] = {\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_HP_LOAD_1, 0},\n};\n\nstatic struct reg_sequence hp_dc_ch_l_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD19, 0x0A},\n\t{CS43130_DXD17, 0x93},\n\t{CS43130_DXD18, 0x0A},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_HP_LOAD_1, 0x81},\n};\n\nstatic struct reg_sequence hp_dc_ch_l_seq2[] = {\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_HP_LOAD_1, 0x81},\n};\n\nstatic struct reg_sequence hp_dc_ch_r_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD19, 0x8A},\n\t{CS43130_DXD17, 0x15},\n\t{CS43130_DXD18, 0x06},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0x90},\n\t{CS43130_HP_LOAD_1, 0x91},\n};\n\nstatic struct reg_sequence hp_dc_ch_r_seq2[] = {\n\t{CS43130_HP_LOAD_1, 0x90},\n\t{CS43130_HP_LOAD_1, 0x91},\n};\n\nstatic struct reg_sequence hp_ac_ch_l_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD19, 0x0A},\n\t{CS43130_DXD17, 0x93},\n\t{CS43130_DXD18, 0x0A},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_HP_LOAD_1, 0x82},\n};\n\nstatic struct reg_sequence hp_ac_ch_l_seq2[] = {\n\t{CS43130_HP_LOAD_1, 0x80},\n\t{CS43130_HP_LOAD_1, 0x82},\n};\n\nstatic struct reg_sequence hp_ac_ch_r_seq[] = {\n\t{CS43130_DXD1, 0x99},\n\t{CS43130_DXD19, 0x8A},\n\t{CS43130_DXD17, 0x15},\n\t{CS43130_DXD18, 0x06},\n\t{CS43130_DXD1, 0},\n\t{CS43130_HP_LOAD_1, 0x90},\n\t{CS43130_HP_LOAD_1, 0x92},\n};\n\nstatic struct reg_sequence hp_ac_ch_r_seq2[] = {\n\t{CS43130_HP_LOAD_1, 0x90},\n\t{CS43130_HP_LOAD_1, 0x92},\n};\n\nstatic struct reg_sequence hp_cln_seq[] = {\n\t{CS43130_INT_MASK_4, CS43130_INT_MASK_ALL},\n\t{CS43130_HP_MEAS_LOAD_1, 0},\n\t{CS43130_HP_MEAS_LOAD_2, 0},\n};\n\nstruct reg_sequences {\n\tstruct reg_sequence\t*seq;\n\tint\t\t\tsize;\n\tunsigned int\t\tmsk;\n};\n\nstatic struct reg_sequences hpload_seq1[] = {\n\t{\n\t\t.seq\t= hp_en_cal_seq,\n\t\t.size\t= ARRAY_SIZE(hp_en_cal_seq),\n\t\t.msk\t= CS43130_HPLOAD_ON_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dc_ch_l_seq,\n\t\t.size\t= ARRAY_SIZE(hp_dc_ch_l_seq),\n\t\t.msk\t= CS43130_HPLOAD_DC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_ac_ch_l_seq,\n\t\t.size\t= ARRAY_SIZE(hp_ac_ch_l_seq),\n\t\t.msk\t= CS43130_HPLOAD_AC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dis_cal_seq,\n\t\t.size\t= ARRAY_SIZE(hp_dis_cal_seq),\n\t\t.msk\t= CS43130_HPLOAD_OFF_INT,\n\t},\n\t{\n\t\t.seq\t= hp_en_cal_seq,\n\t\t.size\t= ARRAY_SIZE(hp_en_cal_seq),\n\t\t.msk\t= CS43130_HPLOAD_ON_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dc_ch_r_seq,\n\t\t.size\t= ARRAY_SIZE(hp_dc_ch_r_seq),\n\t\t.msk\t= CS43130_HPLOAD_DC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_ac_ch_r_seq,\n\t\t.size\t= ARRAY_SIZE(hp_ac_ch_r_seq),\n\t\t.msk\t= CS43130_HPLOAD_AC_INT,\n\t},\n};\n\nstatic struct reg_sequences hpload_seq2[] = {\n\t{\n\t\t.seq\t= hp_en_cal_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_en_cal_seq2),\n\t\t.msk\t= CS43130_HPLOAD_ON_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dc_ch_l_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_dc_ch_l_seq2),\n\t\t.msk\t= CS43130_HPLOAD_DC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_ac_ch_l_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_ac_ch_l_seq2),\n\t\t.msk\t= CS43130_HPLOAD_AC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dis_cal_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_dis_cal_seq2),\n\t\t.msk\t= CS43130_HPLOAD_OFF_INT,\n\t},\n\t{\n\t\t.seq\t= hp_en_cal_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_en_cal_seq2),\n\t\t.msk\t= CS43130_HPLOAD_ON_INT,\n\t},\n\t{\n\t\t.seq\t= hp_dc_ch_r_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_dc_ch_r_seq2),\n\t\t.msk\t= CS43130_HPLOAD_DC_INT,\n\t},\n\t{\n\t\t.seq\t= hp_ac_ch_r_seq2,\n\t\t.size\t= ARRAY_SIZE(hp_ac_ch_r_seq2),\n\t\t.msk\t= CS43130_HPLOAD_AC_INT,\n\t},\n};\n\nstatic int cs43130_update_hpload(unsigned int msk, int ac_idx,\n\t\t\t\t struct cs43130_private *cs43130)\n{\n\tbool left_ch = true;\n\tunsigned int reg;\n\tu32 addr;\n\tu16 impedance;\n\tstruct snd_soc_component *component = cs43130->component;\n\n\tswitch (msk) {\n\tcase CS43130_HPLOAD_DC_INT:\n\tcase CS43130_HPLOAD_AC_INT:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tregmap_read(cs43130->regmap, CS43130_HP_LOAD_1, &reg);\n\tif (reg & CS43130_HPLOAD_CHN_SEL)\n\t\tleft_ch = false;\n\n\tif (msk == CS43130_HPLOAD_DC_INT)\n\t\taddr = CS43130_HP_DC_STAT_1;\n\telse\n\t\taddr = CS43130_HP_AC_STAT_1;\n\n\tregmap_read(cs43130->regmap, addr, &reg);\n\timpedance = reg >> 3;\n\tregmap_read(cs43130->regmap, addr + 1, &reg);\n\timpedance |= reg << 5;\n\n\tif (msk == CS43130_HPLOAD_DC_INT) {\n\t\tif (left_ch)\n\t\t\tcs43130->hpload_dc[HP_LEFT] = impedance;\n\t\telse\n\t\t\tcs43130->hpload_dc[HP_RIGHT] = impedance;\n\n\t\tdev_dbg(component->dev, \"HP DC impedance (Ch %u): %u\\n\", !left_ch,\n\t\t\timpedance);\n\t} else {\n\t\tif (left_ch)\n\t\t\tcs43130->hpload_ac[ac_idx][HP_LEFT] = impedance;\n\t\telse\n\t\t\tcs43130->hpload_ac[ac_idx][HP_RIGHT] = impedance;\n\n\t\tdev_dbg(component->dev, \"HP AC (%u Hz) impedance (Ch %u): %u\\n\",\n\t\t\tcs43130->ac_freq[ac_idx], !left_ch, impedance);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs43130_hpload_proc(struct cs43130_private *cs43130,\n\t\t\t       struct reg_sequence *seq, int seq_size,\n\t\t\t       unsigned int rslt_msk, int ac_idx)\n{\n\tint ret;\n\tunsigned int msk;\n\tu16 ac_reg_val;\n\tstruct snd_soc_component *component = cs43130->component;\n\n\treinit_completion(&cs43130->hpload_evt);\n\n\tif (rslt_msk == CS43130_HPLOAD_AC_INT) {\n\t\tac_reg_val = cs43130_get_ac_reg_val(cs43130->ac_freq[ac_idx]);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_HP_LOAD_1,\n\t\t\t\t   CS43130_HPLOAD_AC_START, 0);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_HP_MEAS_LOAD_1,\n\t\t\t\t   CS43130_HP_MEAS_LOAD_MASK,\n\t\t\t\t   ac_reg_val >> CS43130_HP_MEAS_LOAD_1_SHIFT);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_HP_MEAS_LOAD_2,\n\t\t\t\t   CS43130_HP_MEAS_LOAD_MASK,\n\t\t\t\t   ac_reg_val >> CS43130_HP_MEAS_LOAD_2_SHIFT);\n\t}\n\n\tregmap_multi_reg_write(cs43130->regmap, seq,\n\t\t\t       seq_size);\n\n\tret = wait_for_completion_timeout(&cs43130->hpload_evt,\n\t\t\t\t\t  msecs_to_jiffies(1000));\n\tregmap_read(cs43130->regmap, CS43130_INT_MASK_4, &msk);\n\tif (!ret) {\n\t\tdev_err(component->dev, \"Timeout waiting for HPLOAD interrupt\\n\");\n\t\treturn -1;\n\t}\n\n\tdev_dbg(component->dev, \"HP load stat: %x, INT_MASK_4: %x\\n\",\n\t\tcs43130->hpload_stat, msk);\n\tif ((cs43130->hpload_stat & (CS43130_HPLOAD_NO_DC_INT |\n\t\t\t\t     CS43130_HPLOAD_UNPLUG_INT |\n\t\t\t\t     CS43130_HPLOAD_OOR_INT)) ||\n\t    !(cs43130->hpload_stat & rslt_msk)) {\n\t\tdev_dbg(component->dev, \"HP load measure failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct reg_sequence hv_seq[][2] = {\n\t{\n\t\t{CS43130_CLASS_H_CTL, 0x1C},\n\t\t{CS43130_HP_OUT_CTL_1, 0x10},\n\t},\n\t{\n\t\t{CS43130_CLASS_H_CTL, 0x1E},\n\t\t{CS43130_HP_OUT_CTL_1, 0x20},\n\t},\n\t{\n\t\t{CS43130_CLASS_H_CTL, 0x1E},\n\t\t{CS43130_HP_OUT_CTL_1, 0x30},\n\t},\n};\n\nstatic int cs43130_set_hv(struct regmap *regmap, u16 hpload_dc,\n\t\t\t  const u16 *dc_threshold)\n{\n\tint i;\n\n\tfor (i = 0; i < CS43130_DC_THRESHOLD; i++) {\n\t\tif (hpload_dc <= dc_threshold[i])\n\t\t\tbreak;\n\t}\n\n\tregmap_multi_reg_write(regmap, hv_seq[i], ARRAY_SIZE(hv_seq[i]));\n\n\treturn 0;\n}\n\nstatic void cs43130_imp_meas(struct work_struct *wk)\n{\n\tunsigned int reg, seq_size;\n\tint i, ret, ac_idx;\n\tstruct cs43130_private *cs43130;\n\tstruct snd_soc_component *component;\n\tstruct reg_sequences *hpload_seq;\n\n\tcs43130 = container_of(wk, struct cs43130_private, work);\n\tcomponent = cs43130->component;\n\n\tif (!cs43130->mclk)\n\t\treturn;\n\n\tcs43130->hpload_done = false;\n\n\tmutex_lock(&cs43130->clk_mutex);\n\tif (!cs43130->clk_req) {\n\t\t \n\t\tcs43130_set_pll(component, 0, 0, cs43130->mclk, CS43130_MCLK_22M);\n\t\tif (cs43130->pll_bypass)\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_EXT);\n\t\telse\n\t\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_PLL);\n\t}\n\n\tcs43130->clk_req++;\n\tmutex_unlock(&cs43130->clk_mutex);\n\n\tregmap_read(cs43130->regmap, CS43130_INT_STATUS_4, &reg);\n\n\tswitch (cs43130->dev_id) {\n\tcase CS43130_CHIP_ID:\n\t\thpload_seq = hpload_seq1;\n\t\tseq_size = ARRAY_SIZE(hpload_seq1);\n\t\tbreak;\n\tcase CS43131_CHIP_ID:\n\t\thpload_seq = hpload_seq2;\n\t\tseq_size = ARRAY_SIZE(hpload_seq2);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid dev_id for meas: %d\", cs43130->dev_id);\n\t\treturn;\n\t}\n\n\ti = 0;\n\tac_idx = 0;\n\twhile (i < seq_size) {\n\t\tret = cs43130_hpload_proc(cs43130, hpload_seq[i].seq,\n\t\t\t\t\t  hpload_seq[i].size,\n\t\t\t\t\t  hpload_seq[i].msk, ac_idx);\n\t\tif (ret < 0)\n\t\t\tgoto exit;\n\n\t\tcs43130_update_hpload(hpload_seq[i].msk, ac_idx, cs43130);\n\n\t\tif (cs43130->ac_meas &&\n\t\t    hpload_seq[i].msk == CS43130_HPLOAD_AC_INT &&\n\t\t    ac_idx < CS43130_AC_FREQ - 1) {\n\t\t\tac_idx++;\n\t\t} else {\n\t\t\tac_idx = 0;\n\t\t\ti++;\n\t\t}\n\t}\n\tcs43130->hpload_done = true;\n\n\tif (cs43130->hpload_dc[HP_LEFT] >= CS43130_LINEOUT_LOAD)\n\t\tsnd_soc_jack_report(&cs43130->jack, CS43130_JACK_LINEOUT,\n\t\t\t\t    CS43130_JACK_MASK);\n\telse\n\t\tsnd_soc_jack_report(&cs43130->jack, CS43130_JACK_HEADPHONE,\n\t\t\t\t    CS43130_JACK_MASK);\n\n\tdev_dbg(component->dev, \"Set HP output control. DC threshold\\n\");\n\tfor (i = 0; i < CS43130_DC_THRESHOLD; i++)\n\t\tdev_dbg(component->dev, \"DC threshold[%d]: %u.\\n\", i,\n\t\t\tcs43130->dc_threshold[i]);\n\n\tcs43130_set_hv(cs43130->regmap, cs43130->hpload_dc[HP_LEFT],\n\t\t       cs43130->dc_threshold);\n\nexit:\n\tswitch (cs43130->dev_id) {\n\tcase CS43130_CHIP_ID:\n\t\tcs43130_hpload_proc(cs43130, hp_dis_cal_seq,\n\t\t\t\t    ARRAY_SIZE(hp_dis_cal_seq),\n\t\t\t\t    CS43130_HPLOAD_OFF_INT, ac_idx);\n\t\tbreak;\n\tcase CS43131_CHIP_ID:\n\t\tcs43130_hpload_proc(cs43130, hp_dis_cal_seq2,\n\t\t\t\t    ARRAY_SIZE(hp_dis_cal_seq2),\n\t\t\t\t    CS43130_HPLOAD_OFF_INT, ac_idx);\n\t\tbreak;\n\t}\n\n\tregmap_multi_reg_write(cs43130->regmap, hp_cln_seq,\n\t\t\t       ARRAY_SIZE(hp_cln_seq));\n\n\tmutex_lock(&cs43130->clk_mutex);\n\tcs43130->clk_req--;\n\t \n\tif (!cs43130->clk_req)\n\t\tcs43130_change_clksrc(component, CS43130_MCLK_SRC_RCO);\n\tmutex_unlock(&cs43130->clk_mutex);\n}\n\nstatic irqreturn_t cs43130_irq_thread(int irq, void *data)\n{\n\tstruct cs43130_private *cs43130 = (struct cs43130_private *)data;\n\tstruct snd_soc_component *component = cs43130->component;\n\tunsigned int stickies[CS43130_NUM_INT];\n\tunsigned int irq_occurrence = 0;\n\tunsigned int masks[CS43130_NUM_INT];\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(stickies); i++) {\n\t\tregmap_read(cs43130->regmap, CS43130_INT_STATUS_1 + i,\n\t\t\t    &stickies[i]);\n\t\tregmap_read(cs43130->regmap, CS43130_INT_MASK_1 + i,\n\t\t\t    &masks[i]);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(stickies); i++) {\n\t\tstickies[i] = stickies[i] & (~masks[i]);\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tirq_occurrence += (stickies[i] >> j) & 1;\n\t}\n\tdev_dbg(component->dev, \"number of interrupts occurred (%u)\\n\",\n\t\tirq_occurrence);\n\n\tif (!irq_occurrence)\n\t\treturn IRQ_NONE;\n\n\tif (stickies[0] & CS43130_XTAL_RDY_INT) {\n\t\tcomplete(&cs43130->xtal_rdy);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[0] & CS43130_PLL_RDY_INT) {\n\t\tcomplete(&cs43130->pll_rdy);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_NO_DC_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_err(component->dev,\n\t\t\t\"DC load has not completed before AC load (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_UNPLUG_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_err(component->dev, \"HP unplugged during measurement (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_OOR_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_err(component->dev, \"HP load out of range (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_AC_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_dbg(component->dev, \"HP AC load measurement done (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_DC_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_dbg(component->dev, \"HP DC load measurement done (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_ON_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_dbg(component->dev, \"HP load state machine on done (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[3] & CS43130_HPLOAD_OFF_INT) {\n\t\tcs43130->hpload_stat = stickies[3];\n\t\tdev_dbg(component->dev, \"HP load state machine off done (%x)\\n\",\n\t\t\tcs43130->hpload_stat);\n\t\tcomplete(&cs43130->hpload_evt);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[0] & CS43130_XTAL_ERR_INT) {\n\t\tdev_err(component->dev, \"Crystal err: clock is not running\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[0] & CS43130_HP_UNPLUG_INT) {\n\t\tdev_dbg(component->dev, \"HP unplugged\\n\");\n\t\tcs43130->hpload_done = false;\n\t\tsnd_soc_jack_report(&cs43130->jack, 0, CS43130_JACK_MASK);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (stickies[0] & CS43130_HP_PLUG_INT) {\n\t\tif (cs43130->dc_meas && !cs43130->hpload_done &&\n\t\t    !work_busy(&cs43130->work)) {\n\t\t\tdev_dbg(component->dev, \"HP load queue work\\n\");\n\t\t\tqueue_work(cs43130->wq, &cs43130->work);\n\t\t}\n\n\t\tsnd_soc_jack_report(&cs43130->jack, SND_JACK_MECHANICAL,\n\t\t\t\t    CS43130_JACK_MASK);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int cs43130_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\tstruct cs43130_private *cs43130 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_card *card = component->card;\n\tunsigned int reg;\n\n\tcs43130->component = component;\n\n\tif (cs43130->xtal_ibias != CS43130_XTAL_UNUSED) {\n\t\tregmap_update_bits(cs43130->regmap, CS43130_CRYSTAL_SET,\n\t\t\t\t   CS43130_XTAL_IBIAS_MASK,\n\t\t\t\t   cs43130->xtal_ibias);\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_XTAL_ERR_INT, 0);\n\t}\n\n\tret = snd_soc_card_jack_new(card, \"Headphone\", CS43130_JACK_MASK,\n\t\t\t\t    &cs43130->jack);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Cannot create jack\\n\");\n\t\treturn ret;\n\t}\n\n\tcs43130->hpload_done = false;\n\tif (cs43130->dc_meas) {\n\t\tret = sysfs_create_groups(&component->dev->kobj, hpload_groups);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tcs43130->wq = create_singlethread_workqueue(\"cs43130_hp\");\n\t\tif (!cs43130->wq) {\n\t\t\tsysfs_remove_groups(&component->dev->kobj, hpload_groups);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tINIT_WORK(&cs43130->work, cs43130_imp_meas);\n\t}\n\n\tregmap_read(cs43130->regmap, CS43130_INT_STATUS_1, &reg);\n\tregmap_read(cs43130->regmap, CS43130_HP_STATUS, &reg);\n\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t   CS43130_HP_PLUG_INT | CS43130_HP_UNPLUG_INT, 0);\n\tregmap_update_bits(cs43130->regmap, CS43130_HP_DETECT,\n\t\t\t   CS43130_HP_DETECT_CTRL_MASK, 0);\n\tregmap_update_bits(cs43130->regmap, CS43130_HP_DETECT,\n\t\t\t   CS43130_HP_DETECT_CTRL_MASK,\n\t\t\t   CS43130_HP_DETECT_CTRL_MASK);\n\n\treturn 0;\n}\n\nstatic struct snd_soc_component_driver soc_component_dev_cs43130 = {\n\t.probe\t\t\t= cs43130_probe,\n\t.controls\t\t= cs43130_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs43130_snd_controls),\n\t.set_sysclk\t\t= cs43130_component_set_sysclk,\n\t.set_pll\t\t= cs43130_set_pll,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config cs43130_regmap = {\n\t.reg_bits\t\t= 24,\n\t.pad_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\n\t.max_register\t\t= CS43130_LASTREG,\n\t.reg_defaults\t\t= cs43130_reg_defaults,\n\t.num_reg_defaults\t= ARRAY_SIZE(cs43130_reg_defaults),\n\t.readable_reg\t\t= cs43130_readable_register,\n\t.precious_reg\t\t= cs43130_precious_register,\n\t.volatile_reg\t\t= cs43130_volatile_register,\n\t.cache_type\t\t= REGCACHE_MAPLE,\n\t \n\t.use_single_read\t= true,\n\t.use_single_write\t= true,\n};\n\nstatic const u16 cs43130_dc_threshold[CS43130_DC_THRESHOLD] = {\n\t50,\n\t120,\n};\n\nstatic int cs43130_handle_device_data(struct i2c_client *i2c_client,\n\t\t\t\t      struct cs43130_private *cs43130)\n{\n\tstruct device_node *np = i2c_client->dev.of_node;\n\tunsigned int val;\n\tint i;\n\n\tif (of_property_read_u32(np, \"cirrus,xtal-ibias\", &val) < 0) {\n\t\t \n\t\tcs43130->xtal_ibias = CS43130_XTAL_UNUSED;\n\t\treturn 0;\n\t}\n\n\tswitch (val) {\n\tcase 1:\n\t\tcs43130->xtal_ibias = CS43130_XTAL_IBIAS_7_5UA;\n\t\tbreak;\n\tcase 2:\n\t\tcs43130->xtal_ibias = CS43130_XTAL_IBIAS_12_5UA;\n\t\tbreak;\n\tcase 3:\n\t\tcs43130->xtal_ibias = CS43130_XTAL_IBIAS_15UA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&i2c_client->dev,\n\t\t\t\"Invalid cirrus,xtal-ibias value: %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tcs43130->dc_meas = of_property_read_bool(np, \"cirrus,dc-measure\");\n\tcs43130->ac_meas = of_property_read_bool(np, \"cirrus,ac-measure\");\n\n\tif (of_property_read_u16_array(np, \"cirrus,ac-freq\", cs43130->ac_freq,\n\t\t\t\t\tCS43130_AC_FREQ) < 0) {\n\t\tfor (i = 0; i < CS43130_AC_FREQ; i++)\n\t\t\tcs43130->ac_freq[i] = cs43130_ac_freq[i];\n\t}\n\n\tif (of_property_read_u16_array(np, \"cirrus,dc-threshold\",\n\t\t\t\t       cs43130->dc_threshold,\n\t\t\t\t       CS43130_DC_THRESHOLD) < 0) {\n\t\tfor (i = 0; i < CS43130_DC_THRESHOLD; i++)\n\t\t\tcs43130->dc_threshold[i] = cs43130_dc_threshold[i];\n\t}\n\n\treturn 0;\n}\n\nstatic int cs43130_i2c_probe(struct i2c_client *client)\n{\n\tstruct cs43130_private *cs43130;\n\tint ret;\n\tunsigned int reg;\n\tint i, devid;\n\n\tcs43130 = devm_kzalloc(&client->dev, sizeof(*cs43130), GFP_KERNEL);\n\tif (!cs43130)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, cs43130);\n\n\tcs43130->regmap = devm_regmap_init_i2c(client, &cs43130_regmap);\n\tif (IS_ERR(cs43130->regmap)) {\n\t\tret = PTR_ERR(cs43130->regmap);\n\t\treturn ret;\n\t}\n\n\tif (client->dev.of_node) {\n\t\tret = cs43130_handle_device_data(client, cs43130);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(cs43130->supplies); i++)\n\t\tcs43130->supplies[i].supply = cs43130_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&client->dev,\n\t\t\t\t      ARRAY_SIZE(cs43130->supplies),\n\t\t\t\t      cs43130->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs43130->supplies),\n\t\t\t\t    cs43130->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcs43130->reset_gpio = devm_gpiod_get_optional(&client->dev,\n\t\t\t\t\t\t      \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(cs43130->reset_gpio)) {\n\t\tret = PTR_ERR(cs43130->reset_gpio);\n\t\tgoto err_supplies;\n\t}\n\n\tgpiod_set_value_cansleep(cs43130->reset_gpio, 1);\n\n\tusleep_range(2000, 2050);\n\n\tdevid = cirrus_read_device_id(cs43130->regmap, CS43130_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(&client->dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tswitch (devid) {\n\tcase CS43130_CHIP_ID:\n\tcase CS4399_CHIP_ID:\n\tcase CS43131_CHIP_ID:\n\tcase CS43198_CHIP_ID:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&client->dev,\n\t\t\t\"CS43130 Device ID %X. Expected ID %X, %X, %X or %X\\n\",\n\t\t\tdevid, CS43130_CHIP_ID, CS4399_CHIP_ID,\n\t\t\tCS43131_CHIP_ID, CS43198_CHIP_ID);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tcs43130->dev_id = devid;\n\tret = regmap_read(cs43130->regmap, CS43130_REV_ID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"Get Revision ID failed\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_info(&client->dev,\n\t\t \"Cirrus Logic CS43130 (%x), Revision: %02X\\n\", devid,\n\t\t reg & 0xFF);\n\n\tmutex_init(&cs43130->clk_mutex);\n\n\tinit_completion(&cs43130->xtal_rdy);\n\tinit_completion(&cs43130->pll_rdy);\n\tinit_completion(&cs43130->hpload_evt);\n\n\tret = devm_request_threaded_irq(&client->dev, client->irq,\n\t\t\t\t\tNULL, cs43130_irq_thread,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\t\t\"cs43130\", cs43130);\n\tif (ret != 0) {\n\t\tdev_err(&client->dev, \"Failed to request IRQ: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tcs43130->mclk_int_src = CS43130_MCLK_SRC_RCO;\n\n\tpm_runtime_set_autosuspend_delay(&client->dev, 100);\n\tpm_runtime_use_autosuspend(&client->dev);\n\tpm_runtime_set_active(&client->dev);\n\tpm_runtime_enable(&client->dev);\n\n\tswitch (cs43130->dev_id) {\n\tcase CS43130_CHIP_ID:\n\tcase CS43131_CHIP_ID:\n\t\tmemcpy(all_hp_widgets, digital_hp_widgets,\n\t\t       sizeof(digital_hp_widgets));\n\t\tmemcpy(all_hp_widgets + ARRAY_SIZE(digital_hp_widgets),\n\t\t       analog_hp_widgets, sizeof(analog_hp_widgets));\n\t\tmemcpy(all_hp_routes, digital_hp_routes,\n\t\t       sizeof(digital_hp_routes));\n\t\tmemcpy(all_hp_routes + ARRAY_SIZE(digital_hp_routes),\n\t\t       analog_hp_routes, sizeof(analog_hp_routes));\n\n\t\tsoc_component_dev_cs43130.dapm_widgets =\n\t\t\tall_hp_widgets;\n\t\tsoc_component_dev_cs43130.num_dapm_widgets =\n\t\t\tARRAY_SIZE(all_hp_widgets);\n\t\tsoc_component_dev_cs43130.dapm_routes =\n\t\t\tall_hp_routes;\n\t\tsoc_component_dev_cs43130.num_dapm_routes =\n\t\t\tARRAY_SIZE(all_hp_routes);\n\t\tbreak;\n\tcase CS43198_CHIP_ID:\n\tcase CS4399_CHIP_ID:\n\t\tsoc_component_dev_cs43130.dapm_widgets =\n\t\t\tdigital_hp_widgets;\n\t\tsoc_component_dev_cs43130.num_dapm_widgets =\n\t\t\tARRAY_SIZE(digital_hp_widgets);\n\t\tsoc_component_dev_cs43130.dapm_routes =\n\t\t\tdigital_hp_routes;\n\t\tsoc_component_dev_cs43130.num_dapm_routes =\n\t\t\tARRAY_SIZE(digital_hp_routes);\n\t\tbreak;\n\t}\n\n\tret = devm_snd_soc_register_component(&client->dev,\n\t\t\t\t     &soc_component_dev_cs43130,\n\t\t\t\t     cs43130_dai, ARRAY_SIZE(cs43130_dai));\n\tif (ret < 0) {\n\t\tdev_err(&client->dev,\n\t\t\t\"snd_soc_register_component failed with ret = %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tregmap_update_bits(cs43130->regmap, CS43130_PAD_INT_CFG,\n\t\t\t   CS43130_ASP_3ST_MASK, 0);\n\tregmap_update_bits(cs43130->regmap, CS43130_PAD_INT_CFG,\n\t\t\t   CS43130_XSP_3ST_MASK, 0);\n\n\treturn 0;\n\nerr:\n\tgpiod_set_value_cansleep(cs43130->reset_gpio, 0);\nerr_supplies:\n\tregulator_bulk_disable(ARRAY_SIZE(cs43130->supplies),\n\t\t\t       cs43130->supplies);\n\n\treturn ret;\n}\n\nstatic void cs43130_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs43130_private *cs43130 = i2c_get_clientdata(client);\n\n\tif (cs43130->xtal_ibias != CS43130_XTAL_UNUSED)\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_XTAL_ERR_INT,\n\t\t\t\t   1 << CS43130_XTAL_ERR_INT_SHIFT);\n\n\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t   CS43130_HP_PLUG_INT | CS43130_HP_UNPLUG_INT,\n\t\t\t   CS43130_HP_PLUG_INT | CS43130_HP_UNPLUG_INT);\n\n\tif (cs43130->dc_meas) {\n\t\tcancel_work_sync(&cs43130->work);\n\t\tflush_workqueue(cs43130->wq);\n\n\t\tdevice_remove_file(&client->dev, &dev_attr_hpload_dc_l);\n\t\tdevice_remove_file(&client->dev, &dev_attr_hpload_dc_r);\n\t\tdevice_remove_file(&client->dev, &dev_attr_hpload_ac_l);\n\t\tdevice_remove_file(&client->dev, &dev_attr_hpload_ac_r);\n\t}\n\n\tgpiod_set_value_cansleep(cs43130->reset_gpio, 0);\n\n\tpm_runtime_disable(&client->dev);\n\tregulator_bulk_disable(CS43130_NUM_SUPPLIES, cs43130->supplies);\n}\n\nstatic int __maybe_unused cs43130_runtime_suspend(struct device *dev)\n{\n\tstruct cs43130_private *cs43130 = dev_get_drvdata(dev);\n\n\tif (cs43130->xtal_ibias != CS43130_XTAL_UNUSED)\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_XTAL_ERR_INT,\n\t\t\t\t   1 << CS43130_XTAL_ERR_INT_SHIFT);\n\n\tregcache_cache_only(cs43130->regmap, true);\n\tregcache_mark_dirty(cs43130->regmap);\n\n\tgpiod_set_value_cansleep(cs43130->reset_gpio, 0);\n\n\tregulator_bulk_disable(CS43130_NUM_SUPPLIES, cs43130->supplies);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused cs43130_runtime_resume(struct device *dev)\n{\n\tstruct cs43130_private *cs43130 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(CS43130_NUM_SUPPLIES, cs43130->supplies);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tregcache_cache_only(cs43130->regmap, false);\n\n\tgpiod_set_value_cansleep(cs43130->reset_gpio, 1);\n\n\tusleep_range(2000, 2050);\n\n\tret = regcache_sync(cs43130->regmap);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"Failed to restore register cache\\n\");\n\t\tgoto err;\n\t}\n\n\tif (cs43130->xtal_ibias != CS43130_XTAL_UNUSED)\n\t\tregmap_update_bits(cs43130->regmap, CS43130_INT_MASK_1,\n\t\t\t\t   CS43130_XTAL_ERR_INT, 0);\n\n\treturn 0;\nerr:\n\tregcache_cache_only(cs43130->regmap, true);\n\tregulator_bulk_disable(CS43130_NUM_SUPPLIES, cs43130->supplies);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops cs43130_runtime_pm = {\n\tSET_RUNTIME_PM_OPS(cs43130_runtime_suspend, cs43130_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id cs43130_of_match[] = {\n\t{.compatible = \"cirrus,cs43130\",},\n\t{.compatible = \"cirrus,cs4399\",},\n\t{.compatible = \"cirrus,cs43131\",},\n\t{.compatible = \"cirrus,cs43198\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cs43130_of_match);\n\nstatic const struct i2c_device_id cs43130_i2c_id[] = {\n\t{\"cs43130\", 0},\n\t{\"cs4399\", 0},\n\t{\"cs43131\", 0},\n\t{\"cs43198\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs43130_i2c_id);\n\nstatic struct i2c_driver cs43130_i2c_driver = {\n\t.driver = {\n\t\t.name\t\t= \"cs43130\",\n\t\t.of_match_table\t= cs43130_of_match,\n\t\t.pm             = &cs43130_runtime_pm,\n\t},\n\t.id_table\t= cs43130_i2c_id,\n\t.probe\t\t= cs43130_i2c_probe,\n\t.remove\t\t= cs43130_i2c_remove,\n};\n\nmodule_i2c_driver(cs43130_i2c_driver);\n\nMODULE_AUTHOR(\"Li Xu <li.xu@cirrus.com>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS43130 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}