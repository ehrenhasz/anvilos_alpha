{
  "module_name": "rt715-sdca.c",
  "hash_id": "687fc7ec67ef578bffe3bf6dedb193cdc6946337778f7eaf22b68def3749442d",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt715-sdca.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/sdw.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <linux/soundwire/sdw_registers.h>\n\n#include \"rt715-sdca.h\"\n\nstatic int rt715_sdca_index_write(struct rt715_sdca_priv *rt715,\n\t\tunsigned int nid, unsigned int reg, unsigned int value)\n{\n\tstruct regmap *regmap = rt715->mbq_regmap;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = (nid << 20) | reg;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt715->slave->dev,\n\t\t\t\t\"Failed to set private value: %08x <= %04x %d\\n\", ret, addr,\n\t\t\t\tvalue);\n\n\treturn ret;\n}\n\nstatic int rt715_sdca_index_read(struct rt715_sdca_priv *rt715,\n\t\tunsigned int nid, unsigned int reg, unsigned int *value)\n{\n\tstruct regmap *regmap = rt715->mbq_regmap;\n\tunsigned int addr;\n\tint ret;\n\n\taddr = (nid << 20) | reg;\n\n\tret = regmap_read(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt715->slave->dev,\n\t\t\t\t\"Failed to get private value: %06x => %04x ret=%d\\n\",\n\t\t\t\taddr, *value, ret);\n\n\treturn ret;\n}\n\nstatic int rt715_sdca_index_update_bits(struct rt715_sdca_priv *rt715,\n\tunsigned int nid, unsigned int reg, unsigned int mask, unsigned int val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = rt715_sdca_index_read(rt715, nid, reg, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_mask_bits(&tmp, mask, val);\n\n\treturn rt715_sdca_index_write(rt715, nid, reg, tmp);\n}\n\nstatic inline unsigned int rt715_sdca_vol_gain(unsigned int u_ctrl_val,\n\t\tunsigned int vol_max, unsigned int vol_gain_sft)\n{\n\tunsigned int val;\n\n\tif (u_ctrl_val > vol_max)\n\t\tu_ctrl_val = vol_max;\n\tval = u_ctrl_val;\n\tu_ctrl_val =\n\t\t((abs(u_ctrl_val - vol_gain_sft) * RT715_SDCA_DB_STEP) << 8) / 1000;\n\tif (val <= vol_gain_sft) {\n\t\tu_ctrl_val = ~u_ctrl_val;\n\t\tu_ctrl_val += 1;\n\t}\n\tu_ctrl_val &= 0xffff;\n\n\treturn u_ctrl_val;\n}\n\nstatic inline unsigned int rt715_sdca_boost_gain(unsigned int u_ctrl_val,\n\t\tunsigned int b_max, unsigned int b_gain_sft)\n{\n\tif (u_ctrl_val > b_max)\n\t\tu_ctrl_val = b_max;\n\n\treturn (u_ctrl_val * 10) << b_gain_sft;\n}\n\nstatic inline unsigned int rt715_sdca_get_gain(unsigned int reg_val,\n\t\tunsigned int gain_sft)\n{\n\tunsigned int neg_flag = 0;\n\n\tif (reg_val & BIT(15)) {\n\t\treg_val = ~(reg_val - 1) & 0xffff;\n\t\tneg_flag = 1;\n\t}\n\treg_val *= 1000;\n\treg_val >>= 8;\n\tif (neg_flag)\n\t\treg_val = gain_sft - reg_val / RT715_SDCA_DB_STEP;\n\telse\n\t\treg_val = gain_sft + reg_val / RT715_SDCA_DB_STEP;\n\n\treturn reg_val;\n}\n\n \nstatic int rt715_sdca_set_amp_gain_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tunsigned int gain_val, i, k_changed = 0;\n\tint ret;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_2ch_orig[i]) {\n\t\t\tk_changed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\trt715->kctl_2ch_orig[i] = ucontrol->value.integer.value[i];\n\t\tgain_val =\n\t\t\trt715_sdca_vol_gain(ucontrol->value.integer.value[i], mc->max,\n\t\t\t\tmc->shift);\n\t\tret = regmap_write(rt715->mbq_regmap, mc->reg + i, gain_val);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to write 0x%x=0x%x\\n\",\n\t\t\t\tmc->reg + i, gain_val);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn k_changed;\n}\n\nstatic int rt715_sdca_set_amp_gain_4ch_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int reg_base = p->reg_base, k_changed = 0;\n\tconst unsigned int gain_sft = 0x2f;\n\tunsigned int gain_val, i;\n\tint ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_4ch_orig[i]) {\n\t\t\tk_changed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\trt715->kctl_4ch_orig[i] = ucontrol->value.integer.value[i];\n\t\tgain_val =\n\t\t\trt715_sdca_vol_gain(ucontrol->value.integer.value[i], p->max,\n\t\t\t\tgain_sft);\n\t\tret = regmap_write(rt715->mbq_regmap, reg_base + i,\n\t\t\t\tgain_val);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to write 0x%x=0x%x\\n\",\n\t\t\t\treg_base + i, gain_val);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn k_changed;\n}\n\nstatic int rt715_sdca_set_amp_gain_8ch_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int reg_base = p->reg_base, i, k_changed = 0;\n\tconst unsigned int gain_sft = 8;\n\tunsigned int gain_val, reg;\n\tint ret;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_8ch_orig[i]) {\n\t\t\tk_changed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\trt715->kctl_8ch_orig[i] = ucontrol->value.integer.value[i];\n\t\tgain_val =\n\t\t\trt715_sdca_boost_gain(ucontrol->value.integer.value[i], p->max,\n\t\t\t\tgain_sft);\n\t\treg = i < 7 ? reg_base + i : (reg_base - 1) | BIT(15);\n\t\tret = regmap_write(rt715->mbq_regmap, reg, gain_val);\n\t\tif (ret != 0) {\n\t\t\tdev_err(component->dev, \"Failed to write 0x%x=0x%x\\n\",\n\t\t\t\treg, gain_val);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn k_changed;\n}\n\nstatic int rt715_sdca_set_amp_gain_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tunsigned int val, i;\n\tint ret;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tret = regmap_read(rt715->mbq_regmap, mc->reg + i, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to read 0x%x, ret=%d\\n\",\n\t\t\t\tmc->reg + i, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tucontrol->value.integer.value[i] = rt715_sdca_get_gain(val, mc->shift);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt715_sdca_set_amp_gain_4ch_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int reg_base = p->reg_base, i;\n\tconst unsigned int gain_sft = 0x2f;\n\tunsigned int val;\n\tint ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = regmap_read(rt715->mbq_regmap, reg_base + i, &val);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to read 0x%x, ret=%d\\n\",\n\t\t\t\treg_base + i, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tucontrol->value.integer.value[i] = rt715_sdca_get_gain(val, gain_sft);\n\t}\n\n\treturn 0;\n}\n\nstatic int rt715_sdca_set_amp_gain_8ch_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int reg_base = p->reg_base;\n\tconst unsigned int gain_sft = 8;\n\tunsigned int val_l, val_r;\n\tunsigned int i, reg;\n\tint ret;\n\n\tfor (i = 0; i < 8; i += 2) {\n\t\tret = regmap_read(rt715->mbq_regmap, reg_base + i, &val_l);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to read 0x%x, ret=%d\\n\",\n\t\t\t\t\treg_base + i, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tucontrol->value.integer.value[i] = (val_l >> gain_sft) / 10;\n\n\t\treg = (i == 6) ? (reg_base - 1) | BIT(15) : reg_base + 1 + i;\n\t\tret = regmap_read(rt715->mbq_regmap, reg, &val_r);\n\t\tif (ret < 0) {\n\t\t\tdev_err(component->dev, \"Failed to read 0x%x, ret=%d\\n\",\n\t\t\t\t\treg, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tucontrol->value.integer.value[i + 1] = (val_r >> gain_sft) / 10;\n\t}\n\n\treturn 0;\n}\n\nstatic const DECLARE_TLV_DB_SCALE(in_vol_tlv, -17625, 375, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 1000, 0);\n\nstatic int rt715_sdca_get_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int reg_base = p->reg_base;\n\tunsigned int invert = p->invert, i;\n\tint val;\n\n\tfor (i = 0; i < p->count; i += 2) {\n\t\tval = snd_soc_component_read(component, reg_base + i);\n\t\tif (val < 0)\n\t\t\treturn -EINVAL;\n\t\tucontrol->value.integer.value[i] = invert ? p->max - val : val;\n\n\t\tval = snd_soc_component_read(component, reg_base + 1 + i);\n\t\tif (val < 0)\n\t\t\treturn -EINVAL;\n\t\tucontrol->value.integer.value[i + 1] =\n\t\t\tinvert ? p->max - val : val;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt715_sdca_put_volsw(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\tunsigned int val[4] = {0}, val_mask, i, k_changed = 0;\n\tunsigned int reg = p->reg_base;\n\tunsigned int shift = p->shift;\n\tunsigned int max = p->max;\n\tunsigned int mask = (1 << fls(max)) - 1;\n\tunsigned int invert = p->invert;\n\tint err;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (ucontrol->value.integer.value[i] != rt715->kctl_switch_orig[i]) {\n\t\t\tk_changed = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\trt715->kctl_switch_orig[i * 2] = ucontrol->value.integer.value[i * 2];\n\t\tval[i * 2] = ucontrol->value.integer.value[i * 2] & mask;\n\t\tif (invert)\n\t\t\tval[i * 2] = max - val[i * 2];\n\t\tval_mask = mask << shift;\n\t\tval[i * 2] <<= shift;\n\n\t\trt715->kctl_switch_orig[i * 2 + 1] =\n\t\t\tucontrol->value.integer.value[i * 2 + 1];\n\t\tval[i * 2 + 1] =\n\t\t\tucontrol->value.integer.value[i * 2 + 1] & mask;\n\t\tif (invert)\n\t\t\tval[i * 2 + 1] = max - val[i * 2 + 1];\n\n\t\tval[i * 2 + 1] <<=  shift;\n\n\t\terr = snd_soc_component_update_bits(component, reg + i * 2, val_mask,\n\t\t\t\tval[i * 2]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = snd_soc_component_update_bits(component, reg + 1 + i * 2,\n\t\t\tval_mask, val[i * 2 + 1]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn k_changed;\n}\n\nstatic int rt715_sdca_fu_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct rt715_sdca_kcontrol_private *p =\n\t\t(struct rt715_sdca_kcontrol_private *)kcontrol->private_value;\n\n\tif (p->max == 1)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = p->count;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = p->max;\n\treturn 0;\n}\n\n#define RT715_SDCA_PR_VALUE(xreg_base, xcount, xmax, xshift, xinvert) \\\n\t((unsigned long)&(struct rt715_sdca_kcontrol_private) \\\n\t\t{.reg_base = xreg_base, .count = xcount, .max = xmax, \\\n\t\t.shift = xshift, .invert = xinvert})\n\n#define RT715_SDCA_FU_CTRL(xname, reg_base, xshift, xmax, xinvert, xcount) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = rt715_sdca_fu_info, \\\n\t.get = rt715_sdca_get_volsw, \\\n\t.put = rt715_sdca_put_volsw, \\\n\t.private_value = RT715_SDCA_PR_VALUE(reg_base, xcount, xmax, \\\n\t\t\t\t\txshift, xinvert)}\n\n#define SOC_DOUBLE_R_EXT(xname, reg_left, reg_right, xshift, xmax, xinvert,\\\n\t xhandler_get, xhandler_put) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = snd_soc_info_volsw, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = SOC_DOUBLE_R_VALUE(reg_left, reg_right, xshift, \\\n\t\t\t\t\t    xmax, xinvert) }\n\n#define RT715_SDCA_EXT_TLV(xname, reg_base, xhandler_get,\\\n\t xhandler_put, tlv_array, xcount, xmax) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = rt715_sdca_fu_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = RT715_SDCA_PR_VALUE(reg_base, xcount, xmax, 0, 0) }\n\n#define RT715_SDCA_BOOST_EXT_TLV(xname, reg_base, xhandler_get,\\\n\t xhandler_put, tlv_array, xcount, xmax) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = rt715_sdca_fu_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = RT715_SDCA_PR_VALUE(reg_base, xcount, xmax, 0, 0) }\n\nstatic const struct snd_kcontrol_new rt715_sdca_snd_controls[] = {\n\t \n\tSOC_DOUBLE_R(\"FU0A Capture Switch\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC7_27_VOL,\n\t\t\tRT715_SDCA_FU_MUTE_CTRL, CH_01),\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC7_27_VOL,\n\t\t\tRT715_SDCA_FU_MUTE_CTRL, CH_02),\n\t\t\t0, 1, 1),\n\tRT715_SDCA_FU_CTRL(\"FU02 Capture Switch\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC8_9_VOL,\n\t\t\tRT715_SDCA_FU_MUTE_CTRL, CH_01),\n\t\t\t0, 1, 1, 4),\n\tRT715_SDCA_FU_CTRL(\"FU06 Capture Switch\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC10_11_VOL,\n\t\t\tRT715_SDCA_FU_MUTE_CTRL, CH_01),\n\t\t\t0, 1, 1, 4),\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"FU0A Capture Volume\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC7_27_VOL,\n\t\t\tRT715_SDCA_FU_VOL_CTRL, CH_01),\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC7_27_VOL,\n\t\t\tRT715_SDCA_FU_VOL_CTRL, CH_02),\n\t\t\t0x2f, 0x7f, 0,\n\t\trt715_sdca_set_amp_gain_get, rt715_sdca_set_amp_gain_put,\n\t\tin_vol_tlv),\n\tRT715_SDCA_EXT_TLV(\"FU02 Capture Volume\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC8_9_VOL,\n\t\t\tRT715_SDCA_FU_VOL_CTRL, CH_01),\n\t\trt715_sdca_set_amp_gain_4ch_get,\n\t\trt715_sdca_set_amp_gain_4ch_put,\n\t\tin_vol_tlv, 4, 0x7f),\n\tRT715_SDCA_EXT_TLV(\"FU06 Capture Volume\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_ADC10_11_VOL,\n\t\t\tRT715_SDCA_FU_VOL_CTRL, CH_01),\n\t\trt715_sdca_set_amp_gain_4ch_get,\n\t\trt715_sdca_set_amp_gain_4ch_put,\n\t\tin_vol_tlv, 4, 0x7f),\n\t \n\tRT715_SDCA_BOOST_EXT_TLV(\"FU0E Boost\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_DMIC_GAIN_EN,\n\t\t\tRT715_SDCA_FU_DMIC_GAIN_CTRL, CH_01),\n\t\t\trt715_sdca_set_amp_gain_8ch_get,\n\t\t\trt715_sdca_set_amp_gain_8ch_put,\n\t\t\tmic_vol_tlv, 8, 3),\n\tRT715_SDCA_BOOST_EXT_TLV(\"FU0C Boost\",\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_FU_AMIC_GAIN_EN,\n\t\t\tRT715_SDCA_FU_DMIC_GAIN_CTRL, CH_01),\n\t\t\trt715_sdca_set_amp_gain_8ch_get,\n\t\t\trt715_sdca_set_amp_gain_8ch_put,\n\t\t\tmic_vol_tlv, 8, 3),\n};\n\nstatic int rt715_sdca_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tunsigned int val, mask_sft;\n\n\tif (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tmask_sft = 12;\n\telse if (strstr(ucontrol->id.name, \"ADC 23 Mux\"))\n\t\tmask_sft = 8;\n\telse if (strstr(ucontrol->id.name, \"ADC 24 Mux\"))\n\t\tmask_sft = 4;\n\telse if (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 0;\n\telse\n\t\treturn -EINVAL;\n\n\trt715_sdca_index_read(rt715, RT715_VENDOR_HDA_CTL,\n\t\tRT715_HDA_LEGACY_MUX_CTL1, &val);\n\tval = (val >> mask_sft) & 0xf;\n\n\t \n\tif ((strstr(ucontrol->id.name, \"ADC 24 Mux\") ||\n\t\tstrstr(ucontrol->id.name, \"ADC 25 Mux\")) && val > 0)\n\t\tval -= 1;\n\tucontrol->value.enumerated.item[0] = val;\n\n\treturn 0;\n}\n\nstatic int rt715_sdca_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\t\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, val2 = 0, change, mask_sft;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tif (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tmask_sft = 12;\n\telse if (strstr(ucontrol->id.name, \"ADC 23 Mux\"))\n\t\tmask_sft = 8;\n\telse if (strstr(ucontrol->id.name, \"ADC 24 Mux\"))\n\t\tmask_sft = 4;\n\telse if (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 0;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\trt715_sdca_index_read(rt715, RT715_VENDOR_HDA_CTL,\n\t\tRT715_HDA_LEGACY_MUX_CTL1, &val2);\n\tval2 = (val2 >> mask_sft) & 0xf;\n\n\tchange = val != val2;\n\n\tif (change)\n\t\trt715_sdca_index_update_bits(rt715, RT715_VENDOR_HDA_CTL,\n\t\t\tRT715_HDA_LEGACY_MUX_CTL1, 0xf << mask_sft, val << mask_sft);\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol, item[0], e, NULL);\n\n\treturn change;\n}\n\nstatic const char * const adc_22_23_mux_text[] = {\n\t\"MIC1\",\n\t\"MIC2\",\n\t\"LINE1\",\n\t\"LINE2\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\n \nstatic int rt715_adc_24_25_values[] = {\n\t0,\n\t2,\n\t3,\n\t4,\n\t5,\n};\n\nstatic const char * const adc_24_mux_text[] = {\n\t\"MIC2\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\nstatic const char * const adc_25_mux_text[] = {\n\t\"MIC1\",\n\t\"DMIC1\",\n\t\"DMIC2\",\n\t\"DMIC3\",\n\t\"DMIC4\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt715_adc22_enum, SND_SOC_NOPM, 0,\n\tadc_22_23_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(rt715_adc23_enum, SND_SOC_NOPM, 0,\n\tadc_22_23_mux_text);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(rt715_adc24_enum,\n\tSND_SOC_NOPM, 0, 0xf,\n\tadc_24_mux_text, rt715_adc_24_25_values);\nstatic SOC_VALUE_ENUM_SINGLE_DECL(rt715_adc25_enum,\n\tSND_SOC_NOPM, 0, 0xf,\n\tadc_25_mux_text, rt715_adc_24_25_values);\n\nstatic const struct snd_kcontrol_new rt715_adc22_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 22 Mux\", rt715_adc22_enum,\n\t\t\trt715_sdca_mux_get, rt715_sdca_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc23_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 23 Mux\", rt715_adc23_enum,\n\t\t\trt715_sdca_mux_get, rt715_sdca_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc24_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 24 Mux\", rt715_adc24_enum,\n\t\t\trt715_sdca_mux_get, rt715_sdca_mux_put);\n\nstatic const struct snd_kcontrol_new rt715_adc25_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 25 Mux\", rt715_adc25_enum,\n\t\t\trt715_sdca_mux_get, rt715_sdca_mux_put);\n\nstatic int rt715_sdca_pde23_24_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt715->regmap,\n\t\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_CREQ_POW_EN,\n\t\t\t\tRT715_SDCA_REQ_POW_CTRL,\n\t\t\t\tCH_00), 0x00);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt715->regmap,\n\t\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_CREQ_POW_EN,\n\t\t\t\tRT715_SDCA_REQ_POW_CTRL,\n\t\t\t\tCH_00), 0x03);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt715_sdca_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC3\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC4\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PDE23_24\", SND_SOC_NOPM, 0, 0,\n\t\trt715_sdca_pde23_24_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_ADC(\"ADC 07\", NULL, SND_SOC_NOPM, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 08\", NULL, SND_SOC_NOPM, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 09\", NULL, SND_SOC_NOPM, 4, 0),\n\tSND_SOC_DAPM_ADC(\"ADC 27\", NULL, SND_SOC_NOPM, 4, 0),\n\tSND_SOC_DAPM_MUX(\"ADC 22 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc22_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 23 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc23_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 24 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc24_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 25 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt715_adc25_mux),\n\tSND_SOC_DAPM_AIF_OUT(\"DP4TX\", \"DP4 Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP6TX\", \"DP6 Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route rt715_sdca_audio_map[] = {\n\t{\"DP6TX\", NULL, \"ADC 09\"},\n\t{\"DP6TX\", NULL, \"ADC 08\"},\n\t{\"DP4TX\", NULL, \"ADC 07\"},\n\t{\"DP4TX\", NULL, \"ADC 27\"},\n\t{\"DP4TX\", NULL, \"ADC 09\"},\n\t{\"DP4TX\", NULL, \"ADC 08\"},\n\n\t{\"LINE1\", NULL, \"PDE23_24\"},\n\t{\"LINE2\", NULL, \"PDE23_24\"},\n\t{\"MIC1\", NULL, \"PDE23_24\"},\n\t{\"MIC2\", NULL, \"PDE23_24\"},\n\t{\"DMIC1\", NULL, \"PDE23_24\"},\n\t{\"DMIC2\", NULL, \"PDE23_24\"},\n\t{\"DMIC3\", NULL, \"PDE23_24\"},\n\t{\"DMIC4\", NULL, \"PDE23_24\"},\n\n\t{\"ADC 09\", NULL, \"ADC 22 Mux\"},\n\t{\"ADC 08\", NULL, \"ADC 23 Mux\"},\n\t{\"ADC 07\", NULL, \"ADC 24 Mux\"},\n\t{\"ADC 27\", NULL, \"ADC 25 Mux\"},\n\t{\"ADC 22 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 22 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 22 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 22 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 22 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 22 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 22 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 22 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 23 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 23 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 23 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 23 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 23 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 23 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 23 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 23 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 24 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 24 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 24 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 24 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 24 Mux\", \"DMIC4\", \"DMIC4\"},\n\t{\"ADC 25 Mux\", \"MIC1\", \"MIC1\"},\n\t{\"ADC 25 Mux\", \"DMIC1\", \"DMIC1\"},\n\t{\"ADC 25 Mux\", \"DMIC2\", \"DMIC2\"},\n\t{\"ADC 25 Mux\", \"DMIC3\", \"DMIC3\"},\n\t{\"ADC 25 Mux\", \"DMIC4\", \"DMIC4\"},\n};\n\nstatic int rt715_sdca_probe(struct snd_soc_component *component)\n{\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tif (!rt715->first_hw_init)\n\t\treturn 0;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_codec_dev_rt715_sdca = {\n\t.probe = rt715_sdca_probe,\n\t.controls = rt715_sdca_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt715_sdca_snd_controls),\n\t.dapm_widgets = rt715_sdca_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt715_sdca_dapm_widgets),\n\t.dapm_routes = rt715_sdca_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rt715_sdca_audio_map),\n\t.endianness = 1,\n};\n\nstatic int rt715_sdca_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt715_sdca_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt715_sdca_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config = {0};\n\tstruct sdw_port_config port_config = {0};\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval;\n\tunsigned int val;\n\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt715->slave)\n\t\treturn -EINVAL;\n\n\tsnd_sdw_params_to_config(substream, params, &stream_config, &port_config);\n\n\tswitch (dai->id) {\n\tcase RT715_AIF1:\n\t\tport_config.num = 6;\n\t\trt715_sdca_index_write(rt715, RT715_VENDOR_REG, RT715_SDW_INPUT_SEL,\n\t\t\t0xa500);\n\t\tbreak;\n\tcase RT715_AIF2:\n\t\tport_config.num = 4;\n\t\trt715_sdca_index_write(rt715, RT715_VENDOR_REG, RT715_SDW_INPUT_SEL,\n\t\t\t0xaf00);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI id %d\\n\", dai->id);\n\t\treturn -EINVAL;\n\t}\n\n\tretval = sdw_stream_add_slave(rt715->slave, &stream_config,\n\t\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(component->dev, \"Unable to configure port, retval:%d\\n\",\n\t\t\tretval);\n\t\treturn retval;\n\t}\n\n\tswitch (params_rate(params)) {\n\tcase 8000:\n\t\tval = 0x1;\n\t\tbreak;\n\tcase 11025:\n\t\tval = 0x2;\n\t\tbreak;\n\tcase 12000:\n\t\tval = 0x3;\n\t\tbreak;\n\tcase 16000:\n\t\tval = 0x4;\n\t\tbreak;\n\tcase 22050:\n\t\tval = 0x5;\n\t\tbreak;\n\tcase 24000:\n\t\tval = 0x6;\n\t\tbreak;\n\tcase 32000:\n\t\tval = 0x7;\n\t\tbreak;\n\tcase 44100:\n\t\tval = 0x8;\n\t\tbreak;\n\tcase 48000:\n\t\tval = 0x9;\n\t\tbreak;\n\tcase 88200:\n\t\tval = 0xa;\n\t\tbreak;\n\tcase 96000:\n\t\tval = 0xb;\n\t\tbreak;\n\tcase 176400:\n\t\tval = 0xc;\n\t\tbreak;\n\tcase 192000:\n\t\tval = 0xd;\n\t\tbreak;\n\tcase 384000:\n\t\tval = 0xe;\n\t\tbreak;\n\tcase 768000:\n\t\tval = 0xf;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unsupported sample rate %d\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_write(rt715->regmap,\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_CS_FREQ_IND_EN,\n\t\t\tRT715_SDCA_FREQ_IND_CTRL, CH_00), val);\n\n\treturn 0;\n}\n\nstatic int rt715_sdca_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt715_sdca_priv *rt715 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt715->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt715->slave, sdw_stream);\n\treturn 0;\n}\n\n#define RT715_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)\n#define RT715_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt715_sdca_ops = {\n\t.hw_params\t= rt715_sdca_pcm_hw_params,\n\t.hw_free\t= rt715_sdca_pcm_hw_free,\n\t.set_stream\t= rt715_sdca_set_sdw_stream,\n\t.shutdown\t= rt715_sdca_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt715_sdca_dai[] = {\n\t{\n\t\t.name = \"rt715-aif1\",\n\t\t.id = RT715_AIF1,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP6 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT715_STEREO_RATES,\n\t\t\t.formats = RT715_FORMATS,\n\t\t},\n\t\t.ops = &rt715_sdca_ops,\n\t},\n\t{\n\t\t.name = \"rt715-aif2\",\n\t\t.id = RT715_AIF2,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP4 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT715_STEREO_RATES,\n\t\t\t.formats = RT715_FORMATS,\n\t\t},\n\t\t.ops = &rt715_sdca_ops,\n\t},\n};\n\n \n#define RT715_CLK_FREQ_9600000HZ 9600000\n#define RT715_CLK_FREQ_12000000HZ 12000000\n#define RT715_CLK_FREQ_6000000HZ 6000000\n#define RT715_CLK_FREQ_4800000HZ 4800000\n#define RT715_CLK_FREQ_2400000HZ 2400000\n#define RT715_CLK_FREQ_12288000HZ 12288000\n\nint rt715_sdca_init(struct device *dev, struct regmap *mbq_regmap,\n\tstruct regmap *regmap, struct sdw_slave *slave)\n{\n\tstruct rt715_sdca_priv *rt715;\n\tint ret;\n\n\trt715 = devm_kzalloc(dev, sizeof(*rt715), GFP_KERNEL);\n\tif (!rt715)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt715);\n\trt715->slave = slave;\n\trt715->regmap = regmap;\n\trt715->mbq_regmap = mbq_regmap;\n\trt715->hw_sdw_ver = slave->id.sdw_version;\n\n\tregcache_cache_only(rt715->regmap, true);\n\tregcache_cache_only(rt715->mbq_regmap, true);\n\n\t \n\trt715->hw_init = false;\n\trt715->first_hw_init = false;\n\n\tret = devm_snd_soc_register_component(dev,\n\t\t\t&soc_codec_dev_rt715_sdca,\n\t\t\trt715_sdca_dai,\n\t\t\tARRAY_SIZE(rt715_sdca_dai));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\treturn ret;\n}\n\nint rt715_sdca_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt715_sdca_priv *rt715 = dev_get_drvdata(dev);\n\tunsigned int hw_ver;\n\n\tif (rt715->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt715->regmap, false);\n\tregcache_cache_only(rt715->mbq_regmap, false);\n\n\t \n\tif (!rt715->first_hw_init) {\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\t\trt715->first_hw_init = true;\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\trt715_sdca_index_read(rt715, RT715_VENDOR_REG,\n\t\tRT715_PRODUCT_NUM, &hw_ver);\n\thw_ver = hw_ver & 0x000f;\n\n\t \n\tregmap_write(rt715->regmap,\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_CX_CLK_SEL_EN,\n\t\t\tRT715_SDCA_CX_CLK_SEL_CTRL, CH_00), 0x1);\n\t \n\tif (hw_ver == 0x0)\n\t\trt715_sdca_index_update_bits(rt715, RT715_VENDOR_REG,\n\t\t\tRT715_AD_FUNC_EN, 0x54, 0x54);\n\telse if (hw_ver == 0x1) {\n\t\trt715_sdca_index_update_bits(rt715, RT715_VENDOR_REG,\n\t\t\tRT715_AD_FUNC_EN, 0x55, 0x55);\n\t\trt715_sdca_index_update_bits(rt715, RT715_VENDOR_REG,\n\t\t\tRT715_REV_1, 0x40, 0x40);\n\t}\n\t \n\trt715_sdca_index_update_bits(rt715, RT715_VENDOR_REG,\n\t\t\tRT715_DFLL_VAD, 0x1, 0x1);\n\t \n\tregmap_write(rt715->regmap,\n\t\tSDW_SDCA_CTL(FUN_MIC_ARRAY, RT715_SDCA_SMPU_TRIG_ST_EN,\n\t\t\tRT715_SDCA_SMPU_TRIG_EN_CTRL, CH_00), 0x2);\n\t \n\tregmap_update_bits(rt715->regmap, RT715_INT_MASK, 0x1, 0x1);\n\n\t \n\trt715->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"ASoC rt715 driver SDW SDCA\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}