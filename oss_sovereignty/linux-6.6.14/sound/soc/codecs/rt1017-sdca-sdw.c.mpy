{
  "module_name": "rt1017-sdca-sdw.c",
  "hash_id": "1d6b40342bd4c5adc4eb11c1deb4cb3ea7011edef60c0fd328883c2cc660a7fc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1017-sdca-sdw.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/pm_runtime.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"rt1017-sdca-sdw.h\"\n\nstatic bool rt1017_sdca_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f55:\n\tcase 0x3206:\n\tcase 0xc000:\n\tcase 0xc001:\n\tcase 0xc022:\n\tcase 0xc030:\n\tcase 0xc104:\n\tcase 0xc10b:\n\tcase 0xc10c:\n\tcase 0xc110:\n\tcase 0xc112:\n\tcase 0xc300:\n\tcase 0xc301:\n\tcase 0xc318:\n\tcase 0xc325 ... 0xc328:\n\tcase 0xc331:\n\tcase 0xc340:\n\tcase 0xc350 ... 0xc351:\n\tcase 0xc500:\n\tcase 0xc502:\n\tcase 0xc504:\n\tcase 0xc507:\n\tcase 0xc509:\n\tcase 0xc510:\n\tcase 0xc512:\n\tcase 0xc518:\n\tcase 0xc51b:\n\tcase 0xc51d:\n\tcase 0xc520:\n\tcase 0xc540 ... 0xc542:\n\tcase 0xc550 ... 0xc552:\n\tcase 0xc600:\n\tcase 0xc602:\n\tcase 0xc612:\n\tcase 0xc622:\n\tcase 0xc632:\n\tcase 0xc642:\n\tcase 0xc651:\n\tcase 0xca00:\n\tcase 0xca09 ... 0xca0c:\n\tcase 0xca0e ... 0xca0f:\n\tcase 0xca10 ... 0xca11:\n\tcase 0xca16 ... 0xca17:\n\tcase 0xcb00:\n\tcase 0xcc00:\n\tcase 0xcc02:\n\tcase 0xd017:\n\tcase 0xd01a ... 0xd01c:\n\tcase 0xd101:\n\tcase 0xd20c:\n\tcase 0xd300:\n\tcase 0xd370:\n\tcase 0xd500:\n\tcase 0xd545 ... 0xd548:\n\tcase 0xd5a5 ... 0xd5a8:\n\tcase 0xd5aa ... 0xd5ad:\n\tcase 0xda04 ... 0xda07:\n\tcase 0xda09 ... 0xda0a:\n\tcase 0xda0c ... 0xda0f:\n\tcase 0xda11 ... 0xda14:\n\tcase 0xda16 ... 0xda19:\n\tcase 0xdab6 ... 0xdabb:\n\tcase 0xdb09 ... 0xdb0a:\n\tcase 0xdb14:\n\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_UDMPU21,\n\t\t\tRT1017_SDCA_CTL_UDMPU_CLUSTER, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_FU,\n\t\t\tRT1017_SDCA_CTL_FU_MUTE, 0x01):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_XU22,\n\t\t\tRT1017_SDCA_CTL_BYPASS, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_SAPU29,\n\t\t\tRT1017_SDCA_CTL_PROT_STAT, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_CS21,\n\t\t\tRT1017_SDCA_CTL_FS_INDEX, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_PDE23,\n\t\t\tRT1017_SDCA_CTL_REQ_POWER_STATE, 0):\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_PDE22,\n\t\t\tRT1017_SDCA_CTL_REQ_POWER_STATE, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1017_sdca_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase 0x2f55:\n\tcase 0xc000:\n\tcase 0xc022:\n\tcase 0xc351:\n\tcase 0xc518:\n\tcase SDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_SAPU29,\n\t\t\tRT1017_SDCA_CTL_PROT_STAT, 0):\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct reg_sequence rt1017_blind_write[] = {\n\t{ 0xc001, 0x43 },\n\t{ 0x2f55, 0x02 },\n\t{ 0x3206, 0x80 },\n\t{ 0x005f, 0x7f },\n\t{ 0xd101, 0xa0 },\n\t{ 0xc112, 0xc0 },\n\t{ 0xc104, 0xaa },\n\t{ 0xc110, 0x59 },\n\t{ 0xc112, 0xc0 },\n\t{ 0xc340, 0x80 },\n\t{ 0xd017, 0x2c },\n\t{ 0xd01a, 0xc8 },\n\t{ 0xd01b, 0xcf },\n\t{ 0xd01c, 0x0c },\n\t{ 0xd20c, 0x14 },\n\t{ 0xdb09, 0x0f },\n\t{ 0xdb0a, 0x7f },\n\t{ 0xdb14, 0x03 },\n\t{ 0xcb00, 0x31 },\n\t{ 0xc318, 0x44 },\n\t{ 0xc325, 0xce },\n\t{ 0xc326, 0x13 },\n\t{ 0xc327, 0x5f },\n\t{ 0xc328, 0xf3 },\n\t{ 0xc350, 0xe1 },\n\t{ 0xc351, 0x88 },\n\t{ 0xc030, 0x14 },\n\t{ 0xc331, 0xf2 },\n\t{ 0xc551, 0x0f },\n\t{ 0xc552, 0xff },\n\t{ 0xc651, 0xc0 },\n\t{ 0xc550, 0xd0 },\n\t{ 0xc612, 0x00 },\n\t{ 0xc622, 0x00 },\n\t{ 0xc632, 0x00 },\n\t{ 0xc642, 0x00 },\n\t{ 0xc602, 0xf0 },\n\t{ 0xc600, 0xd0 },\n\t{ 0xcc02, 0x78 },\n\t{ 0xcc00, 0x90 },\n\t{ 0xc300, 0x3f },\n\t{ 0xc301, 0x1d },\n\t{ 0xc10b, 0x2e },\n\t{ 0xc10c, 0x36 },\n\n\t{ 0xd5a5, 0x00 },\n\t{ 0xd5a6, 0x6a },\n\t{ 0xd5a7, 0xaa },\n\t{ 0xd5a8, 0xaa },\n\t{ 0xd5aa, 0x00 },\n\t{ 0xd5ab, 0x16 },\n\t{ 0xd5ac, 0xdb },\n\t{ 0xd5ad, 0x6d },\n\t{ 0xd545, 0x09 },\n\t{ 0xd546, 0x30 },\n\t{ 0xd547, 0xf0 },\n\t{ 0xd548, 0xf0 },\n\t{ 0xd500, 0x20 },\n\t{ 0xc504, 0x3f },\n\t{ 0xc540, 0x00 },\n\t{ 0xc541, 0x0a },\n\t{ 0xc542, 0x1a },\n\t{ 0xc512, 0x00 },\n\t{ 0xc520, 0x40 },\n\t{ 0xc51b, 0x7f },\n\t{ 0xc51d, 0x0f },\n\t{ 0xc500, 0x40 },\n\t{ 0xc502, 0xde },\n\t{ 0xc507, 0x05 },\n\t{ 0xc509, 0x05 },\n\t{ 0xc510, 0x40 },\n\t{ 0xc518, 0xc0 },\n\t{ 0xc500, 0xc0 },\n\n\t{ 0xda0c, 0x00 },\n\t{ 0xda0d, 0x0b },\n\t{ 0xda0e, 0x55 },\n\t{ 0xda0f, 0x55 },\n\t{ 0xda04, 0x00 },\n\t{ 0xda05, 0x51 },\n\t{ 0xda06, 0xeb },\n\t{ 0xda07, 0x85 },\n\t{ 0xca16, 0x0f },\n\t{ 0xca17, 0x00 },\n\t{ 0xda09, 0x5d },\n\t{ 0xda0a, 0xc0 },\n\t{ 0xda11, 0x26 },\n\t{ 0xda12, 0x66 },\n\t{ 0xda13, 0x66 },\n\t{ 0xda14, 0x66 },\n\t{ 0xda16, 0x79 },\n\t{ 0xda17, 0x99 },\n\t{ 0xda18, 0x99 },\n\t{ 0xda19, 0x99 },\n\t{ 0xca09, 0x00 },\n\t{ 0xca0a, 0x07 },\n\t{ 0xca0b, 0x89 },\n\t{ 0xca0c, 0x61 },\n\t{ 0xca0e, 0x00 },\n\t{ 0xca0f, 0x03 },\n\t{ 0xca10, 0xc4 },\n\t{ 0xca11, 0xb0 },\n\t{ 0xdab6, 0x00 },\n\t{ 0xdab7, 0x01 },\n\t{ 0xdab8, 0x00 },\n\t{ 0xdab9, 0x00 },\n\t{ 0xdaba, 0x00 },\n\t{ 0xdabb, 0x00 },\n\t{ 0xd017, 0x0e },\n\t{ 0xca00, 0xcd },\n\t{ 0xc022, 0x84 },\n};\n\n#define RT1017_MAX_REG_NUM 0x4108ffff\n\nstatic const struct regmap_config rt1017_sdca_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.readable_reg = rt1017_sdca_readable_register,\n\t.volatile_reg = rt1017_sdca_volatile_register,\n\t.max_register = RT1017_MAX_REG_NUM,\n\t.reg_defaults = rt1017_sdca_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(rt1017_sdca_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int rt1017_sdca_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval;\n\tint i, j;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\tprop->quirks = SDW_SLAVE_QUIRKS_INVALID_INITIAL_PARITY;\n\n\tprop->paging_support = true;\n\n\t \n\tprop->source_ports = BIT(2);  \n\tprop->sink_ports = BIT(1);    \n\n\tnval = hweight32(prop->source_ports);\n\tprop->src_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->src_dpn_prop), GFP_KERNEL);\n\tif (!prop->src_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->src_dpn_prop;\n\taddr = prop->source_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\t \n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\tsizeof(*prop->sink_dpn_prop), GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\tj = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[j].num = bit;\n\t\tdpn[j].type = SDW_DPN_FULL;\n\t\tdpn[j].simple_ch_prep_sm = true;\n\t\tdpn[j].ch_prep_timeout = 10;\n\t\tj++;\n\t}\n\n\t \n\tprop->clk_stop_timeout = 64;\n\n\treturn 0;\n}\n\nstatic int rt1017_sdca_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt1017_sdca_priv *rt1017 = dev_get_drvdata(dev);\n\n\tif (rt1017->hw_init)\n\t\treturn 0;\n\n\tif (rt1017->first_hw_init) {\n\t\tregcache_cache_only(rt1017->regmap, false);\n\t\tregcache_cache_bypass(rt1017->regmap, true);\n\t} else {\n\t\t \n\n\t\t \n\t\tpm_runtime_set_autosuspend_delay(&slave->dev, 3000);\n\t\tpm_runtime_use_autosuspend(&slave->dev);\n\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\t\t \n\t\tpm_runtime_mark_last_busy(&slave->dev);\n\n\t\tpm_runtime_enable(&slave->dev);\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\t \n\tregmap_write(rt1017->regmap, 0xc000, 0x02);\n\n\t \n\tregmap_multi_reg_write(rt1017->regmap, rt1017_blind_write,\n\t\tARRAY_SIZE(rt1017_blind_write));\n\n\tif (rt1017->first_hw_init) {\n\t\tregcache_cache_bypass(rt1017->regmap, false);\n\t\tregcache_mark_dirty(rt1017->regmap);\n\t} else\n\t\trt1017->first_hw_init = true;\n\n\t \n\trt1017->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"hw_init complete\\n\");\n\treturn 0;\n}\n\nstatic int rt1017_sdca_update_status(struct sdw_slave *slave,\n\t\t\t\tenum sdw_slave_status status)\n{\n\tstruct  rt1017_sdca_priv *rt1017 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\trt1017->hw_init = false;\n\n\t \n\tif (rt1017->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn rt1017_sdca_io_init(&slave->dev, slave);\n}\n\nstatic const char * const rt1017_rx_data_ch_select[] = {\n\t\"Bypass\",\n\t\"CN1\",\n\t\"CN2\",\n\t\"CN3\",\n\t\"CN4\",\n\t\"(1+2)/2\",\n\t\"(1+3)/2\",\n\t\"(1+4)/2\",\n\t\"(2+3)/2\",\n\t\"(2+4)/2\",\n\t\"(3+4)/2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1017_rx_data_ch_enum,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_UDMPU21,\n\t\t\t\tRT1017_SDCA_CTL_UDMPU_CLUSTER, 0),\n\t\t\t0, rt1017_rx_data_ch_select);\n\nstatic const struct snd_kcontrol_new rt1017_sdca_controls[] = {\n\t \n\tSOC_ENUM(\"RX Channel Select\", rt1017_rx_data_ch_enum),\n};\n\nstatic const struct snd_kcontrol_new rt1017_sto_dac =\n\tSOC_DAPM_SINGLE(\"Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_FU, RT1017_SDCA_CTL_FU_MUTE, 0x1),\n\t\t0, 1, 1);\n\nstatic int rt1017_sdca_pde23_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt1017->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_PDE23,\n\t\t\t\tRT1017_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt1017->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_PDE23,\n\t\t\t\tRT1017_SDCA_CTL_REQ_POWER_STATE, 0),\n\t\t\t\tps3);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt1017_sdca_classd_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_update_bits(rt1017->regmap, RT1017_PWM_TRIM_1,\n\t\t\tRT1017_PWM_FREQ_CTL_SRC_SEL_MASK, RT1017_PWM_FREQ_CTL_SRC_SEL_REG);\n\t\tregmap_write(rt1017->regmap, RT1017_CLASSD_INT_1, 0x10);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt1017_sdca_feedback_event(struct snd_soc_dapm_widget *w,\n\t\t\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_update_bits(rt1017->regmap, 0xd017, 0x1f, 0x08);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(rt1017->regmap, 0xd017, 0x1f, 0x09);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt1017_sdca_dapm_widgets[] = {\n\t \n\tSND_SOC_DAPM_AIF_IN(\"DP1RX\", \"DP1 Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT_E(\"DP2TX\", \"DP2 Capture\", 0, SND_SOC_NOPM, 0, 0,\n\t\trt1017_sdca_feedback_event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\t \n\tSND_SOC_DAPM_SWITCH(\"DAC\", SND_SOC_NOPM, 0, 0, &rt1017_sto_dac),\n\n\t \n\tSND_SOC_DAPM_PGA_E(\"CLASS D\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\trt1017_sdca_classd_event, SND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPO\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PDE23\", SND_SOC_NOPM, 0, 0,\n\t\trt1017_sdca_pde23_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_PGA(\"I Sense\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"V Sense\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SIGGEN(\"I Gen\"),\n\tSND_SOC_DAPM_SIGGEN(\"V Gen\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1017_sdca_dapm_routes[] = {\n\n\t{ \"DAC\", \"Switch\", \"DP1RX\" },\n\t{ \"CLASS D\", NULL, \"DAC\" },\n\t{ \"CLASS D\", NULL, \"PDE23\" },\n\t{ \"SPO\", NULL, \"CLASS D\" },\n\n\t{ \"I Sense\", NULL, \"I Gen\" },\n\t{ \"V Sense\", NULL, \"V Gen\" },\n\t{ \"I Sense\", NULL, \"PDE23\" },\n\t{ \"V Sense\", NULL, \"PDE23\" },\n\t{ \"DP2TX\", NULL, \"I Sense\" },\n\t{ \"DP2TX\", NULL, \"V Sense\" },\n};\n\nstatic struct sdw_slave_ops rt1017_sdca_slave_ops = {\n\t.read_prop = rt1017_sdca_read_prop,\n\t.update_status = rt1017_sdca_update_status,\n};\n\nstatic int rt1017_sdca_component_probe(struct snd_soc_component *component)\n{\n\tint ret;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void rt1017_sdca_component_remove(struct snd_soc_component *component)\n{\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1017->regmap, true);\n}\n\nstatic const struct snd_soc_component_driver soc_sdca_component_rt1017 = {\n\t.probe = rt1017_sdca_component_probe,\n\t.remove = rt1017_sdca_component_remove,\n\t.controls = rt1017_sdca_controls,\n\t.num_controls = ARRAY_SIZE(rt1017_sdca_controls),\n\t.dapm_widgets = rt1017_sdca_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1017_sdca_dapm_widgets),\n\t.dapm_routes = rt1017_sdca_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1017_sdca_dapm_routes),\n\t.endianness = 1,\n};\n\nstatic int rt1017_sdca_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt1017_sdca_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt1017_sdca_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config;\n\tstruct sdw_port_config port_config;\n\tenum sdw_data_direction direction;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval, port, num_channels, ch_mask;\n\tunsigned int sampling_rate;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt1017->sdw_slave)\n\t\treturn -EINVAL;\n\n\t \n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdirection = SDW_DATA_DIR_RX;\n\t\tport = 1;\n\t} else {\n\t\tdirection = SDW_DATA_DIR_TX;\n\t\tport = 2;\n\t}\n\n\tnum_channels = params_channels(params);\n\tch_mask = (1 << num_channels) - 1;\n\n\tstream_config.frame_rate = params_rate(params);\n\tstream_config.ch_count = num_channels;\n\tstream_config.bps = snd_pcm_format_width(params_format(params));\n\tstream_config.direction = direction;\n\n\tport_config.ch_mask = ch_mask;\n\tport_config.num = port;\n\n\tdev_dbg(dai->dev, \"frame_rate %d, ch_count %d, bps %d, direction %d, ch_mask %d, port: %d\\n\",\n\t\tparams_rate(params), num_channels, snd_pcm_format_width(params_format(params)),\n\t\tdirection, ch_mask, port);\n\n\tretval = sdw_stream_add_slave(rt1017->sdw_slave, &stream_config,\n\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 44100:\n\t\tsampling_rate = RT1017_SDCA_RATE_44100HZ;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = RT1017_SDCA_RATE_48000HZ;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = RT1017_SDCA_RATE_96000HZ;\n\t\tbreak;\n\tcase 192000:\n\t\tsampling_rate = RT1017_SDCA_RATE_192000HZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(rt1017->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_SMART_AMP, RT1017_SDCA_ENT_CS21,\n\t\t\tRT1017_SDCA_CTL_FS_INDEX, 0),\n\t\tsampling_rate);\n\n\treturn 0;\n}\n\nstatic int rt1017_sdca_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1017_sdca_priv *rt1017 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt1017->sdw_slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt1017->sdw_slave, sdw_stream);\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops rt1017_sdca_ops = {\n\t.hw_params\t= rt1017_sdca_pcm_hw_params,\n\t.hw_free\t= rt1017_sdca_pcm_hw_free,\n\t.set_stream\t= rt1017_sdca_set_sdw_stream,\n\t.shutdown\t= rt1017_sdca_shutdown,\n};\n\n#define RT1017_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \\\n\t\t\t     SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)\n#define RT1017_FORMATS (SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver rt1017_sdca_dai[] = {\n\t{\n\t\t.name = \"rt1017-aif\",\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rates = RT1017_STEREO_RATES,\n\t\t\t.formats = RT1017_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rates = RT1017_STEREO_RATES,\n\t\t\t.formats = RT1017_FORMATS,\n\t\t},\n\t\t.ops = &rt1017_sdca_ops,\n\t},\n};\n\nstatic int rt1017_sdca_init(struct device *dev, struct regmap *regmap,\n\t\t\tstruct sdw_slave *slave)\n{\n\tstruct rt1017_sdca_priv *rt1017;\n\tint ret;\n\n\trt1017 = devm_kzalloc(dev, sizeof(*rt1017), GFP_KERNEL);\n\tif (!rt1017)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt1017);\n\trt1017->sdw_slave = slave;\n\trt1017->regmap = regmap;\n\n\t \n\trt1017->hw_init = false;\n\trt1017->first_hw_init = false;\n\n\tret =  devm_snd_soc_register_component(dev,\n\t\t\t\t&soc_sdca_component_rt1017,\n\t\t\t\trt1017_sdca_dai,\n\t\t\t\tARRAY_SIZE(rt1017_sdca_dai));\n\n\treturn ret;\n}\n\nstatic int rt1017_sdca_sdw_probe(struct sdw_slave *slave,\n\t\t\t\tconst struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &rt1017_sdca_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn rt1017_sdca_init(&slave->dev, regmap, slave);\n}\n\nstatic int rt1017_sdca_sdw_remove(struct sdw_slave *slave)\n{\n\tstruct rt1017_sdca_priv *rt1017 = dev_get_drvdata(&slave->dev);\n\n\tif (rt1017->first_hw_init)\n\t\tpm_runtime_disable(&slave->dev);\n\n\treturn 0;\n}\n\nstatic const struct sdw_device_id rt1017_sdca_id[] = {\n\tSDW_SLAVE_ENTRY_EXT(0x025d, 0x1017, 0x3, 0x1, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, rt1017_sdca_id);\n\nstatic int __maybe_unused rt1017_sdca_dev_suspend(struct device *dev)\n{\n\tstruct rt1017_sdca_priv *rt1017 = dev_get_drvdata(dev);\n\n\tif (!rt1017->hw_init)\n\t\treturn 0;\n\n\tregcache_cache_only(rt1017->regmap, true);\n\n\treturn 0;\n}\n\n#define RT1017_PROBE_TIMEOUT 5000\n\nstatic int __maybe_unused rt1017_sdca_dev_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct rt1017_sdca_priv *rt1017 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!rt1017->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\tmsecs_to_jiffies(RT1017_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(&slave->dev, \"Initialization not complete, timed out\\n\");\n\t\tsdw_show_ping_status(slave->bus, true);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\tslave->unattach_request = 0;\n\tregcache_cache_only(rt1017->regmap, false);\n\tregcache_sync(rt1017->regmap);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops rt1017_sdca_pm = {\n\tSET_SYSTEM_SLEEP_PM_OPS(rt1017_sdca_dev_suspend, rt1017_sdca_dev_resume)\n\tSET_RUNTIME_PM_OPS(rt1017_sdca_dev_suspend, rt1017_sdca_dev_resume, NULL)\n};\n\nstatic struct sdw_driver rt1017_sdca_sdw_driver = {\n\t.driver = {\n\t\t.name = \"rt1017-sdca\",\n\t\t.owner = THIS_MODULE,\n\t\t.pm = &rt1017_sdca_pm,\n\t},\n\t.probe = rt1017_sdca_sdw_probe,\n\t.remove = rt1017_sdca_sdw_remove,\n\t.ops = &rt1017_sdca_slave_ops,\n\t.id_table = rt1017_sdca_id,\n};\nmodule_sdw_driver(rt1017_sdca_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1017 driver SDCA SDW\");\nMODULE_AUTHOR(\"Derek Fang <derek.fang@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}