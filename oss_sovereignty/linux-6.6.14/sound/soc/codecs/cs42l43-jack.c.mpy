{
  "module_name": "cs42l43-jack.c",
  "hash_id": "608808666b1b56b832234fc110cf0a9b96a650d165e823b2a531edfe575ea9ac",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs42l43-jack.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/build_bug.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n#include <linux/mfd/cs42l43.h>\n#include <linux/mfd/cs42l43-regs.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <sound/control.h>\n#include <sound/jack.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc-component.h>\n#include <sound/soc.h>\n\n#include \"cs42l43.h\"\n\nstatic const unsigned int cs42l43_accdet_us[] = {\n\t20, 100, 1000, 10000, 50000, 75000, 100000, 200000\n};\n\nstatic const unsigned int cs42l43_accdet_db_ms[] = {\n\t0, 125, 250, 500, 750, 1000, 1250, 1500\n};\n\nstatic const unsigned int cs42l43_accdet_ramp_ms[] = { 10, 40, 90, 170 };\n\nstatic const unsigned int cs42l43_accdet_bias_sense[] = {\n\t14, 24, 43, 52, 61, 71, 90, 99, 0,\n};\n\nstatic int cs42l43_find_index(struct cs42l43_codec *priv, const char * const prop,\n\t\t\t      unsigned int defval, unsigned int *val,\n\t\t\t      const unsigned int *values, const int nvalues)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tint i, ret;\n\n\tret = device_property_read_u32(cs42l43->dev, prop, &defval);\n\tif (ret != -EINVAL && ret < 0) {\n\t\tdev_err(priv->dev, \"Property %s malformed: %d\\n\", prop, ret);\n\t\treturn ret;\n\t}\n\n\tif (val)\n\t\t*val = defval;\n\n\tfor (i = 0; i < nvalues; i++)\n\t\tif (defval == values[i])\n\t\t\treturn i;\n\n\tdev_err(priv->dev, \"Invalid value for property %s: %d\\n\", prop, defval);\n\treturn -EINVAL;\n}\n\nint cs42l43_set_jack(struct snd_soc_component *component,\n\t\t     struct snd_soc_jack *jack, void *d)\n{\n\tstruct cs42l43_codec *priv = snd_soc_component_get_drvdata(component);\n\tstruct cs42l43 *cs42l43 = priv->core;\n\t \n\tunsigned int tip_deb = CS42L43_TIPSENSE_INV_MASK;\n\tunsigned int hs2 = 0x2 << CS42L43_HSDET_MODE_SHIFT;\n\tunsigned int autocontrol = 0, pdncntl = 0;\n\tint ret;\n\n\tdev_dbg(priv->dev, \"Configure accessory detect\\n\");\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for jack config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->jack_lock);\n\n\tpriv->jack_hp = jack;\n\n\tif (!jack)\n\t\tgoto done;\n\n\tret = device_property_count_u32(cs42l43->dev, \"cirrus,buttons-ohms\");\n\tif (ret != -EINVAL) {\n\t\tif (ret < 0) {\n\t\t\tdev_err(priv->dev, \"Property cirrus,buttons-ohms malformed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (ret > CS42L43_N_BUTTONS) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(priv->dev, \"Property cirrus,buttons-ohms too many entries\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tdevice_property_read_u32_array(cs42l43->dev, \"cirrus,buttons-ohms\",\n\t\t\t\t\t       priv->buttons, ret);\n\t} else {\n\t\tpriv->buttons[0] = 70;\n\t\tpriv->buttons[1] = 185;\n\t\tpriv->buttons[2] = 355;\n\t\tpriv->buttons[3] = 735;\n\t}\n\n\tret = cs42l43_find_index(priv, \"cirrus,detect-us\", 10000, &priv->detect_us,\n\t\t\t\t cs42l43_accdet_us, ARRAY_SIZE(cs42l43_accdet_us));\n\tif (ret < 0)\n\t\tgoto error;\n\n\ths2 |= ret << CS42L43_AUTO_HSDET_TIME_SHIFT;\n\n\tpriv->bias_low = device_property_read_bool(cs42l43->dev, \"cirrus,bias-low\");\n\n\tret = cs42l43_find_index(priv, \"cirrus,bias-ramp-ms\", 170,\n\t\t\t\t &priv->bias_ramp_ms, cs42l43_accdet_ramp_ms,\n\t\t\t\t ARRAY_SIZE(cs42l43_accdet_ramp_ms));\n\tif (ret < 0)\n\t\tgoto error;\n\n\ths2 |= ret << CS42L43_HSBIAS_RAMP_SHIFT;\n\n\tret = cs42l43_find_index(priv, \"cirrus,bias-sense-microamp\", 0,\n\t\t\t\t &priv->bias_sense_ua, cs42l43_accdet_bias_sense,\n\t\t\t\t ARRAY_SIZE(cs42l43_accdet_bias_sense));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tif (priv->bias_sense_ua)\n\t\tautocontrol |= ret << CS42L43_HSBIAS_SENSE_TRIP_SHIFT;\n\n\tif (!device_property_read_bool(cs42l43->dev, \"cirrus,button-automute\"))\n\t\tautocontrol |= CS42L43_S0_AUTO_ADCMUTE_DISABLE_MASK;\n\n\tret = device_property_read_u32(cs42l43->dev, \"cirrus,tip-debounce-ms\",\n\t\t\t\t       &priv->tip_debounce_ms);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(priv->dev, \"Property cirrus,tip-debounce-ms malformed: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\t \n\tif (device_property_read_bool(cs42l43->dev, \"cirrus,tip-invert\"))\n\t\tautocontrol |= 0x1 << CS42L43_JACKDET_INV_SHIFT;\n\n\tif (device_property_read_bool(cs42l43->dev, \"cirrus,tip-disable-pullup\"))\n\t\tautocontrol |= 0x1 << CS42L43_JACKDET_MODE_SHIFT;\n\telse\n\t\tautocontrol |= 0x3 << CS42L43_JACKDET_MODE_SHIFT;\n\n\tret = cs42l43_find_index(priv, \"cirrus,tip-fall-db-ms\", 500,\n\t\t\t\t NULL, cs42l43_accdet_db_ms,\n\t\t\t\t ARRAY_SIZE(cs42l43_accdet_db_ms));\n\tif (ret < 0)\n\t\tgoto error;\n\n\ttip_deb |= ret << CS42L43_TIPSENSE_FALLING_DB_TIME_SHIFT;\n\n\tret = cs42l43_find_index(priv, \"cirrus,tip-rise-db-ms\", 500,\n\t\t\t\t NULL, cs42l43_accdet_db_ms,\n\t\t\t\t ARRAY_SIZE(cs42l43_accdet_db_ms));\n\tif (ret < 0)\n\t\tgoto error;\n\n\ttip_deb |= ret << CS42L43_TIPSENSE_RISING_DB_TIME_SHIFT;\n\n\tif (device_property_read_bool(cs42l43->dev, \"cirrus,use-ring-sense\")) {\n\t\tunsigned int ring_deb = 0;\n\n\t\tpriv->use_ring_sense = true;\n\n\t\t \n\t\tif (!device_property_read_bool(cs42l43->dev, \"cirrus,ring-invert\"))\n\t\t\tring_deb |= CS42L43_RINGSENSE_INV_MASK;\n\n\t\tif (!device_property_read_bool(cs42l43->dev,\n\t\t\t\t\t       \"cirrus,ring-disable-pullup\"))\n\t\t\tring_deb |= CS42L43_RINGSENSE_PULLUP_PDNB_MASK;\n\n\t\tret = cs42l43_find_index(priv, \"cirrus,ring-fall-db-ms\", 500,\n\t\t\t\t\t NULL, cs42l43_accdet_db_ms,\n\t\t\t\t\t ARRAY_SIZE(cs42l43_accdet_db_ms));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tring_deb |= ret << CS42L43_RINGSENSE_FALLING_DB_TIME_SHIFT;\n\n\t\tret = cs42l43_find_index(priv, \"cirrus,ring-rise-db-ms\", 500,\n\t\t\t\t\t NULL, cs42l43_accdet_db_ms,\n\t\t\t\t\t ARRAY_SIZE(cs42l43_accdet_db_ms));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tring_deb |= ret << CS42L43_RINGSENSE_RISING_DB_TIME_SHIFT;\n\t\tpdncntl |= CS42L43_RING_SENSE_EN_MASK;\n\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_RINGSENSE_DEB_CTRL,\n\t\t\t\t   CS42L43_RINGSENSE_INV_MASK |\n\t\t\t\t   CS42L43_RINGSENSE_PULLUP_PDNB_MASK |\n\t\t\t\t   CS42L43_RINGSENSE_FALLING_DB_TIME_MASK |\n\t\t\t\t   CS42L43_RINGSENSE_RISING_DB_TIME_MASK,\n\t\t\t\t   ring_deb);\n\t}\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_TIPSENSE_DEB_CTRL,\n\t\t\t   CS42L43_TIPSENSE_INV_MASK |\n\t\t\t   CS42L43_TIPSENSE_FALLING_DB_TIME_MASK |\n\t\t\t   CS42L43_TIPSENSE_RISING_DB_TIME_MASK, tip_deb);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HSBIAS_RAMP_MASK | CS42L43_HSDET_MODE_MASK |\n\t\t\t   CS42L43_AUTO_HSDET_TIME_MASK, hs2);\n\ndone:\n\tret = 0;\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS_BIAS_SENSE_AND_CLAMP_AUTOCONTROL,\n\t\t\t   CS42L43_JACKDET_MODE_MASK | CS42L43_S0_AUTO_ADCMUTE_DISABLE_MASK |\n\t\t\t   CS42L43_HSBIAS_SENSE_TRIP_MASK, autocontrol);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_PDNCNTL,\n\t\t\t   CS42L43_RING_SENSE_EN_MASK, pdncntl);\n\n\tdev_dbg(priv->dev, \"Successfully configured accessory detect\\n\");\n\nerror:\n\tmutex_unlock(&priv->jack_lock);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n\n\treturn ret;\n}\n\nstatic void cs42l43_start_hs_bias(struct cs42l43_codec *priv, bool force_high)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int val = 0x3 << CS42L43_HSBIAS_MODE_SHIFT;\n\n\tdev_dbg(priv->dev, \"Start headset bias\\n\");\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HS_CLAMP_DISABLE_MASK, CS42L43_HS_CLAMP_DISABLE_MASK);\n\n\tif (!force_high && priv->bias_low)\n\t\tval = 0x2 << CS42L43_HSBIAS_MODE_SHIFT;\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_HSBIAS_MODE_MASK, val);\n\n\tmsleep(priv->bias_ramp_ms);\n}\n\nstatic void cs42l43_stop_hs_bias(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\n\tdev_dbg(priv->dev, \"Stop headset bias\\n\");\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_HSBIAS_MODE_MASK, 0x1 << CS42L43_HSBIAS_MODE_SHIFT);\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HS_CLAMP_DISABLE_MASK, 0);\n}\n\nirqreturn_t cs42l43_bias_detect_clamp(int irq, void *data)\n{\n\tstruct cs42l43_codec *priv = data;\n\n\tqueue_delayed_work(system_wq, &priv->bias_sense_timeout,\n\t\t\t   msecs_to_jiffies(250));\n\n\treturn IRQ_HANDLED;\n}\n\n#define CS42L43_JACK_PRESENT 0x3\n#define CS42L43_JACK_ABSENT 0x0\n\n#define CS42L43_JACK_OPTICAL (SND_JACK_MECHANICAL | SND_JACK_AVOUT)\n#define CS42L43_JACK_HEADPHONE (SND_JACK_MECHANICAL | SND_JACK_HEADPHONE)\n#define CS42L43_JACK_HEADSET (SND_JACK_MECHANICAL | SND_JACK_HEADSET)\n#define CS42L43_JACK_LINEOUT (SND_JACK_MECHANICAL | SND_JACK_LINEOUT)\n#define CS42L43_JACK_LINEIN (SND_JACK_MECHANICAL | SND_JACK_LINEIN)\n#define CS42L43_JACK_EXTENSION (SND_JACK_MECHANICAL)\n#define CS42L43_JACK_BUTTONS (SND_JACK_BTN_0 | SND_JACK_BTN_1 | SND_JACK_BTN_2 | \\\n\t\t\t      SND_JACK_BTN_3 | SND_JACK_BTN_4 | SND_JACK_BTN_5)\n\nstatic inline bool cs42l43_jack_present(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int sts = 0;\n\n\tregmap_read(cs42l43->regmap, CS42L43_TIP_RING_SENSE_INTERRUPT_STATUS, &sts);\n\n\tsts = (sts >> CS42L43_TIPSENSE_PLUG_DB_STS_SHIFT) & CS42L43_JACK_PRESENT;\n\n\treturn sts == CS42L43_JACK_PRESENT;\n}\n\nstatic void cs42l43_start_button_detect(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int val = 0x3 << CS42L43_BUTTON_DETECT_MODE_SHIFT;\n\n\tdev_dbg(priv->dev, \"Start button detect\\n\");\n\n\tpriv->button_detect_running = true;\n\n\tif (priv->bias_low)\n\t\tval = 0x1 << CS42L43_BUTTON_DETECT_MODE_SHIFT;\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_BUTTON_DETECT_MODE_MASK |\n\t\t\t   CS42L43_MIC_LVL_DET_DISABLE_MASK, val);\n\n\tif (priv->bias_sense_ua) {\n\t\tregmap_update_bits(cs42l43->regmap,\n\t\t\t\t   CS42L43_HS_BIAS_SENSE_AND_CLAMP_AUTOCONTROL,\n\t\t\t\t   CS42L43_HSBIAS_SENSE_EN_MASK |\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK,\n\t\t\t\t   CS42L43_HSBIAS_SENSE_EN_MASK |\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK);\n\t}\n}\n\nstatic void cs42l43_stop_button_detect(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\n\tdev_dbg(priv->dev, \"Stop button detect\\n\");\n\n\tif (priv->bias_sense_ua) {\n\t\tregmap_update_bits(cs42l43->regmap,\n\t\t\t\t   CS42L43_HS_BIAS_SENSE_AND_CLAMP_AUTOCONTROL,\n\t\t\t\t   CS42L43_HSBIAS_SENSE_EN_MASK |\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK, 0);\n\t}\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_BUTTON_DETECT_MODE_MASK |\n\t\t\t   CS42L43_MIC_LVL_DET_DISABLE_MASK,\n\t\t\t   CS42L43_MIC_LVL_DET_DISABLE_MASK);\n\n\tpriv->button_detect_running = false;\n}\n\n#define CS42L43_BUTTON_COMB_MAX 512\n#define CS42L43_BUTTON_ROUT 2210\n\nvoid cs42l43_button_press_work(struct work_struct *work)\n{\n\tstruct cs42l43_codec *priv = container_of(work, struct cs42l43_codec,\n\t\t\t\t\t\t  button_press_work.work);\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int buttons = 0;\n\tunsigned int val = 0;\n\tint i, ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for button press: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->jack_lock);\n\n\tif (!priv->button_detect_running) {\n\t\tdev_dbg(priv->dev, \"Spurious button press IRQ\\n\");\n\t\tgoto error;\n\t}\n\n\tregmap_read(cs42l43->regmap, CS42L43_DETECT_STATUS_1, &val);\n\n\t \n\tif (!cs42l43_jack_present(priv)) {\n\t\tdev_dbg(priv->dev, \"Button ignored due to removal\\n\");\n\t\tgoto error;\n\t}\n\n\tif (val & CS42L43_HSBIAS_CLAMP_STS_MASK) {\n\t\tdev_dbg(priv->dev, \"Button ignored due to bias sense\\n\");\n\t\tgoto error;\n\t}\n\n\tval = (val & CS42L43_HSDET_DC_STS_MASK) >> CS42L43_HSDET_DC_STS_SHIFT;\n\tval = ((CS42L43_BUTTON_COMB_MAX << 20) / (val + 1)) - (1 << 20);\n\tif (val)\n\t\tval = (CS42L43_BUTTON_ROUT << 20) / val;\n\telse\n\t\tval = UINT_MAX;\n\n\tfor (i = 0; i < CS42L43_N_BUTTONS; i++) {\n\t\tif (val < priv->buttons[i]) {\n\t\t\tbuttons = SND_JACK_BTN_0 >> i;\n\t\t\tdev_dbg(priv->dev, \"Detected button %d at %d Ohms\\n\", i, val);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!buttons)\n\t\tdev_dbg(priv->dev, \"Unrecognised button: %d Ohms\\n\", val);\n\n\tsnd_soc_jack_report(priv->jack_hp, buttons, CS42L43_JACK_BUTTONS);\n\nerror:\n\tmutex_unlock(&priv->jack_lock);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n}\n\nirqreturn_t cs42l43_button_press(int irq, void *data)\n{\n\tstruct cs42l43_codec *priv = data;\n\n\t\n\tqueue_delayed_work(system_wq, &priv->button_press_work,\n\t\t\t   msecs_to_jiffies(10));\n\n\treturn IRQ_HANDLED;\n}\n\nvoid cs42l43_button_release_work(struct work_struct *work)\n{\n\tstruct cs42l43_codec *priv = container_of(work, struct cs42l43_codec,\n\t\t\t\t\t\t  button_release_work);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for button release: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->jack_lock);\n\n\tif (priv->button_detect_running) {\n\t\tdev_dbg(priv->dev, \"Button release IRQ\\n\");\n\n\t\tsnd_soc_jack_report(priv->jack_hp, 0, CS42L43_JACK_BUTTONS);\n\t} else {\n\t\tdev_dbg(priv->dev, \"Spurious button release IRQ\\n\");\n\t}\n\n\tmutex_unlock(&priv->jack_lock);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n}\n\nirqreturn_t cs42l43_button_release(int irq, void *data)\n{\n\tstruct cs42l43_codec *priv = data;\n\n\tqueue_work(system_wq, &priv->button_release_work);\n\n\treturn IRQ_HANDLED;\n}\n\nvoid cs42l43_bias_sense_timeout(struct work_struct *work)\n{\n\tstruct cs42l43_codec *priv = container_of(work, struct cs42l43_codec,\n\t\t\t\t\t\t  bias_sense_timeout.work);\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for bias sense: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->jack_lock);\n\n\tif (cs42l43_jack_present(priv) && priv->button_detect_running) {\n\t\tdev_dbg(priv->dev, \"Bias sense timeout out, restore bias\\n\");\n\n\t\tregmap_update_bits(cs42l43->regmap,\n\t\t\t\t   CS42L43_HS_BIAS_SENSE_AND_CLAMP_AUTOCONTROL,\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK, 0);\n\t\tregmap_update_bits(cs42l43->regmap,\n\t\t\t\t   CS42L43_HS_BIAS_SENSE_AND_CLAMP_AUTOCONTROL,\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK,\n\t\t\t\t   CS42L43_AUTO_HSBIAS_CLAMP_EN_MASK);\n\t}\n\n\tmutex_unlock(&priv->jack_lock);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n}\n\nstatic void cs42l43_start_load_detect(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\n\tdev_dbg(priv->dev, \"Start load detect\\n\");\n\n\tsnd_soc_dapm_mutex_lock(snd_soc_component_get_dapm(priv->component));\n\n\tpriv->load_detect_running = true;\n\n\tif (priv->hp_ena) {\n\t\tunsigned long time_left;\n\n\t\treinit_completion(&priv->hp_shutdown);\n\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_BLOCK_EN8,\n\t\t\t\t   CS42L43_HP_EN_MASK, 0);\n\n\t\ttime_left = wait_for_completion_timeout(&priv->hp_shutdown,\n\t\t\t\t\t\t\tmsecs_to_jiffies(CS42L43_HP_TIMEOUT_MS));\n\t\tif (!time_left)\n\t\t\tdev_err(priv->dev, \"Load detect HP power down timed out\\n\");\n\t}\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_BLOCK_EN3,\n\t\t\t   CS42L43_ADC1_EN_MASK | CS42L43_ADC2_EN_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_DACCNFG2, CS42L43_HP_HPF_EN_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_HSBIAS_MODE_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_CTRL,\n\t\t\t   CS42L43_ADPTPWR_MODE_MASK, 0x4 << CS42L43_ADPTPWR_MODE_SHIFT);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_PGAVOL,\n\t\t\t   CS42L43_HP_DIG_VOL_RAMP_MASK | CS42L43_HP_ANA_VOL_RAMP_MASK, 0x6);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_DACCNFG1,\n\t\t\t   CS42L43_HP_MSTR_VOL_CTRL_EN_MASK, 0);\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HS_CLAMP_DISABLE_MASK, CS42L43_HS_CLAMP_DISABLE_MASK);\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_LOADDETENA,\n\t\t\t   CS42L43_HPLOAD_DET_EN_MASK,\n\t\t\t   CS42L43_HPLOAD_DET_EN_MASK);\n\n\tsnd_soc_dapm_mutex_unlock(snd_soc_component_get_dapm(priv->component));\n}\n\nstatic void cs42l43_stop_load_detect(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\n\tdev_dbg(priv->dev, \"Stop load detect\\n\");\n\n\tsnd_soc_dapm_mutex_lock(snd_soc_component_get_dapm(priv->component));\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_LOADDETENA,\n\t\t\t   CS42L43_HPLOAD_DET_EN_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HS_CLAMP_DISABLE_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_DACCNFG1,\n\t\t\t   CS42L43_HP_MSTR_VOL_CTRL_EN_MASK,\n\t\t\t   CS42L43_HP_MSTR_VOL_CTRL_EN_MASK);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_PGAVOL,\n\t\t\t   CS42L43_HP_DIG_VOL_RAMP_MASK | CS42L43_HP_ANA_VOL_RAMP_MASK,\n\t\t\t   0x4 << CS42L43_HP_DIG_VOL_RAMP_SHIFT);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_CTRL,\n\t\t\t   CS42L43_ADPTPWR_MODE_MASK, 0x7 << CS42L43_ADPTPWR_MODE_SHIFT);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_MIC_DETECT_CONTROL_1,\n\t\t\t   CS42L43_HSBIAS_MODE_MASK, 0x1 << CS42L43_HSBIAS_MODE_SHIFT);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_DACCNFG2,\n\t\t\t   CS42L43_HP_HPF_EN_MASK, CS42L43_HP_HPF_EN_MASK);\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_BLOCK_EN3,\n\t\t\t   CS42L43_ADC1_EN_MASK | CS42L43_ADC2_EN_MASK,\n\t\t\t   priv->adc_ena);\n\n\tif (priv->hp_ena) {\n\t\tunsigned long time_left;\n\n\t\treinit_completion(&priv->hp_startup);\n\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_BLOCK_EN8,\n\t\t\t\t   CS42L43_HP_EN_MASK, priv->hp_ena);\n\n\t\ttime_left = wait_for_completion_timeout(&priv->hp_startup,\n\t\t\t\t\t\t\tmsecs_to_jiffies(CS42L43_HP_TIMEOUT_MS));\n\t\tif (!time_left)\n\t\t\tdev_err(priv->dev, \"Load detect HP restore timed out\\n\");\n\t}\n\n\tpriv->load_detect_running = false;\n\n\tsnd_soc_dapm_mutex_unlock(snd_soc_component_get_dapm(priv->component));\n}\n\nstatic int cs42l43_run_load_detect(struct cs42l43_codec *priv, bool mic)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int val = 0;\n\tunsigned long time_left;\n\n\treinit_completion(&priv->load_detect);\n\n\tcs42l43_start_load_detect(priv);\n\ttime_left = wait_for_completion_timeout(&priv->load_detect,\n\t\t\t\t\t\tmsecs_to_jiffies(CS42L43_LOAD_TIMEOUT_MS));\n\tcs42l43_stop_load_detect(priv);\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\tregmap_read(cs42l43->regmap, CS42L43_LOADDETRESULTS, &val);\n\n\tdev_dbg(priv->dev, \"Headphone load detect: 0x%x\\n\", val);\n\n\t \n\tif (!cs42l43_jack_present(priv))\n\t\treturn -ENODEV;\n\n\tif (mic) {\n\t\tcs42l43_start_hs_bias(priv, false);\n\t\tcs42l43_start_button_detect(priv);\n\n\t\treturn CS42L43_JACK_HEADSET;\n\t}\n\n\tswitch (val & CS42L43_AMP3_RES_DET_MASK) {\n\tcase 0x0: \n\tcase 0x1: \n\t\treturn CS42L43_JACK_HEADPHONE;\n\tcase 0x2: \n\tcase 0x3: \n\t\treturn CS42L43_JACK_LINEOUT;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cs42l43_run_type_detect(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tint timeout_ms = ((2 * priv->detect_us) / 1000) + 200;\n\tunsigned int type = 0xff;\n\tunsigned long time_left;\n\n\treinit_completion(&priv->type_detect);\n\n\tcs42l43_start_hs_bias(priv, true);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HSDET_MODE_MASK, 0x3 << CS42L43_HSDET_MODE_SHIFT);\n\n\ttime_left = wait_for_completion_timeout(&priv->type_detect,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout_ms));\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HSDET_MODE_MASK, 0x2 << CS42L43_HSDET_MODE_SHIFT);\n\tcs42l43_stop_hs_bias(priv);\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\tregmap_read(cs42l43->regmap, CS42L43_HS_STAT, &type);\n\n\tdev_dbg(priv->dev, \"Type detect: 0x%x\\n\", type);\n\n\t \n\tif (!cs42l43_jack_present(priv))\n\t\treturn -ENODEV;\n\n\tswitch (type & CS42L43_HSDET_TYPE_STS_MASK) {\n\tcase 0x0: \n\tcase 0x1: \n\t\treturn cs42l43_run_load_detect(priv, true);\n\tcase 0x2: \n\t\treturn cs42l43_run_load_detect(priv, false);\n\tcase 0x3: \n\t\treturn CS42L43_JACK_EXTENSION;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void cs42l43_clear_jack(struct cs42l43_codec *priv)\n{\n\tstruct cs42l43 *cs42l43 = priv->core;\n\n\tcs42l43_stop_button_detect(priv);\n\tcs42l43_stop_hs_bias(priv);\n\n\tregmap_update_bits(cs42l43->regmap, CS42L43_ADC_B_CTRL1,\n\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_ADC_B_CTRL2,\n\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_STEREO_MIC_CTRL,\n\t\t\t   CS42L43_JACK_STEREO_CONFIG_MASK, 0);\n\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t   CS42L43_HSDET_MODE_MASK | CS42L43_HSDET_MANUAL_MODE_MASK,\n\t\t\t   0x2 << CS42L43_HSDET_MODE_SHIFT);\n\n\tsnd_soc_jack_report(priv->jack_hp, 0, 0xFFFF);\n}\n\nvoid cs42l43_tip_sense_work(struct work_struct *work)\n{\n\tstruct cs42l43_codec *priv = container_of(work, struct cs42l43_codec,\n\t\t\t\t\t\t  tip_sense_work.work);\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tunsigned int sts = 0;\n\tunsigned int tip, ring;\n\tint ret, report;\n\n\tret = pm_runtime_resume_and_get(priv->dev);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to resume for tip work: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->jack_lock);\n\n\tregmap_read(cs42l43->regmap, CS42L43_TIP_RING_SENSE_INTERRUPT_STATUS, &sts);\n\n\tdev_dbg(priv->dev, \"Tip sense: 0x%x\\n\", sts);\n\n\ttip = (sts >> CS42L43_TIPSENSE_PLUG_DB_STS_SHIFT) & CS42L43_JACK_PRESENT;\n\tring = (sts >> CS42L43_RINGSENSE_PLUG_DB_STS_SHIFT) & CS42L43_JACK_PRESENT;\n\n\tif (tip == CS42L43_JACK_PRESENT) {\n\t\tif (cs42l43->sdw && !priv->jack_present) {\n\t\t\tpriv->jack_present = true;\n\t\t\tpm_runtime_get(priv->dev);\n\t\t}\n\n\t\tif (priv->use_ring_sense && ring == CS42L43_JACK_ABSENT) {\n\t\t\treport = CS42L43_JACK_OPTICAL;\n\t\t} else {\n\t\t\treport = cs42l43_run_type_detect(priv);\n\t\t\tif (report < 0) {\n\t\t\t\tdev_err(priv->dev, \"Jack detect failed: %d\\n\", report);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tsnd_soc_jack_report(priv->jack_hp, report, report);\n\t} else {\n\t\tpriv->jack_override = 0;\n\n\t\tcs42l43_clear_jack(priv);\n\n\t\tif (cs42l43->sdw && priv->jack_present) {\n\t\t\tpm_runtime_put(priv->dev);\n\t\t\tpriv->jack_present = false;\n\t\t}\n\t}\n\nerror:\n\tmutex_unlock(&priv->jack_lock);\n\n\tpm_runtime_mark_last_busy(priv->dev);\n\tpm_runtime_put_autosuspend(priv->dev);\n}\n\nirqreturn_t cs42l43_tip_sense(int irq, void *data)\n{\n\tstruct cs42l43_codec *priv = data;\n\n\tcancel_delayed_work(&priv->bias_sense_timeout);\n\tcancel_delayed_work(&priv->tip_sense_work);\n\tcancel_delayed_work(&priv->button_press_work);\n\tcancel_work(&priv->button_release_work);\n\n\tqueue_delayed_work(system_long_wq, &priv->tip_sense_work,\n\t\t\t   msecs_to_jiffies(priv->tip_debounce_ms));\n\n\treturn IRQ_HANDLED;\n}\n\nenum cs42l43_raw_jack {\n\tCS42L43_JACK_RAW_CTIA = 0,\n\tCS42L43_JACK_RAW_OMTP,\n\tCS42L43_JACK_RAW_HEADPHONE,\n\tCS42L43_JACK_RAW_LINE_OUT,\n\tCS42L43_JACK_RAW_LINE_IN,\n\tCS42L43_JACK_RAW_MICROPHONE,\n\tCS42L43_JACK_RAW_OPTICAL,\n};\n\n#define CS42L43_JACK_3_POLE_SWITCHES ((0x2 << CS42L43_HSDET_MANUAL_MODE_SHIFT) | \\\n\t\t\t\t      CS42L43_AMP3_4_GNDREF_HS3_SEL_MASK | \\\n\t\t\t\t      CS42L43_AMP3_4_GNDREF_HS4_SEL_MASK | \\\n\t\t\t\t      CS42L43_HSBIAS_GNDREF_HS3_SEL_MASK | \\\n\t\t\t\t      CS42L43_HSBIAS_GNDREF_HS4_SEL_MASK | \\\n\t\t\t\t      CS42L43_HSGND_HS3_SEL_MASK | \\\n\t\t\t\t      CS42L43_HSGND_HS4_SEL_MASK)\n\nstatic const struct cs42l43_jack_override_mode {\n\tunsigned int hsdet_mode;\n\tunsigned int mic_ctrl;\n\tunsigned int clamp_ctrl;\n\tint report;\n} cs42l43_jack_override_modes[] = {\n\t[CS42L43_JACK_RAW_CTIA] = {\n\t\t.hsdet_mode = CS42L43_AMP3_4_GNDREF_HS3_SEL_MASK |\n\t\t\t      CS42L43_HSBIAS_GNDREF_HS3_SEL_MASK |\n\t\t\t      CS42L43_HSBIAS_OUT_HS4_SEL_MASK |\n\t\t\t      CS42L43_HSGND_HS3_SEL_MASK,\n\t\t.clamp_ctrl = CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t.report = CS42L43_JACK_HEADSET,\n\t},\n\t[CS42L43_JACK_RAW_OMTP] = {\n\t\t.hsdet_mode = (0x1 << CS42L43_HSDET_MANUAL_MODE_SHIFT) |\n\t\t\t       CS42L43_AMP3_4_GNDREF_HS4_SEL_MASK |\n\t\t\t       CS42L43_HSBIAS_GNDREF_HS4_SEL_MASK |\n\t\t\t       CS42L43_HSBIAS_OUT_HS3_SEL_MASK |\n\t\t\t       CS42L43_HSGND_HS4_SEL_MASK,\n\t\t.clamp_ctrl = CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t.report = CS42L43_JACK_HEADSET,\n\t},\n\t[CS42L43_JACK_RAW_HEADPHONE] = {\n\t\t.hsdet_mode = CS42L43_JACK_3_POLE_SWITCHES,\n\t\t.clamp_ctrl = CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t.report = CS42L43_JACK_HEADPHONE,\n\t},\n\t[CS42L43_JACK_RAW_LINE_OUT] = {\n\t\t.hsdet_mode = CS42L43_JACK_3_POLE_SWITCHES,\n\t\t.clamp_ctrl = CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t.report = CS42L43_JACK_LINEOUT,\n\t},\n\t[CS42L43_JACK_RAW_LINE_IN] = {\n\t\t.hsdet_mode = CS42L43_JACK_3_POLE_SWITCHES,\n\t\t.mic_ctrl = 0x2 << CS42L43_JACK_STEREO_CONFIG_SHIFT,\n\t\t.report = CS42L43_JACK_LINEIN,\n\t},\n\t[CS42L43_JACK_RAW_MICROPHONE] = {\n\t\t.hsdet_mode = CS42L43_JACK_3_POLE_SWITCHES,\n\t\t.mic_ctrl = (0x3 << CS42L43_JACK_STEREO_CONFIG_SHIFT) |\n\t\t\t    CS42L43_HS1_BIAS_EN_MASK | CS42L43_HS2_BIAS_EN_MASK,\n\t\t.report = CS42L43_JACK_LINEIN,\n\t},\n\t[CS42L43_JACK_RAW_OPTICAL] = {\n\t\t.hsdet_mode = CS42L43_JACK_3_POLE_SWITCHES,\n\t\t.clamp_ctrl = CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t.report = CS42L43_JACK_OPTICAL,\n\t},\n};\n\nstatic const char * const cs42l43_jack_text[] = {\n\t\"None\", \"CTIA\", \"OMTP\", \"Headphone\", \"Line-Out\",\n\t\"Line-In\", \"Microphone\", \"Optical\",\n};\n\nSOC_ENUM_SINGLE_VIRT_DECL(cs42l43_jack_enum, cs42l43_jack_text);\n\nint cs42l43_jack_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs42l43_codec *priv = snd_soc_component_get_drvdata(component);\n\n\tmutex_lock(&priv->jack_lock);\n\tucontrol->value.integer.value[0] = priv->jack_override;\n\tmutex_unlock(&priv->jack_lock);\n\n\treturn 0;\n}\n\nint cs42l43_jack_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs42l43_codec *priv = snd_soc_component_get_drvdata(component);\n\tstruct cs42l43 *cs42l43 = priv->core;\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int override = ucontrol->value.integer.value[0];\n\n\tBUILD_BUG_ON(ARRAY_SIZE(cs42l43_jack_override_modes) !=\n\t\t     ARRAY_SIZE(cs42l43_jack_text) - 1);\n\n\tif (override >= e->items)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->jack_lock);\n\n\tif (!cs42l43_jack_present(priv)) {\n\t\tmutex_unlock(&priv->jack_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (override == priv->jack_override) {\n\t\tmutex_unlock(&priv->jack_lock);\n\t\treturn 0;\n\t}\n\n\tpriv->jack_override = override;\n\n\tcs42l43_clear_jack(priv);\n\n\tif (!override) {\n\t\tqueue_delayed_work(system_long_wq, &priv->tip_sense_work, 0);\n\t} else {\n\t\toverride--;\n\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_HS2,\n\t\t\t\t   CS42L43_HSDET_MODE_MASK |\n\t\t\t\t   CS42L43_HSDET_MANUAL_MODE_MASK |\n\t\t\t\t   CS42L43_AMP3_4_GNDREF_HS3_SEL_MASK |\n\t\t\t\t   CS42L43_AMP3_4_GNDREF_HS4_SEL_MASK |\n\t\t\t\t   CS42L43_HSBIAS_GNDREF_HS3_SEL_MASK |\n\t\t\t\t   CS42L43_HSBIAS_GNDREF_HS4_SEL_MASK |\n\t\t\t\t   CS42L43_HSBIAS_OUT_HS3_SEL_MASK |\n\t\t\t\t   CS42L43_HSBIAS_OUT_HS4_SEL_MASK |\n\t\t\t\t   CS42L43_HSGND_HS3_SEL_MASK |\n\t\t\t\t   CS42L43_HSGND_HS4_SEL_MASK,\n\t\t\t\t   cs42l43_jack_override_modes[override].hsdet_mode);\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_STEREO_MIC_CTRL,\n\t\t\t\t   CS42L43_HS2_BIAS_EN_MASK | CS42L43_HS1_BIAS_EN_MASK |\n\t\t\t\t   CS42L43_JACK_STEREO_CONFIG_MASK,\n\t\t\t\t   cs42l43_jack_override_modes[override].mic_ctrl);\n\t\tregmap_update_bits(cs42l43->regmap, CS42L43_STEREO_MIC_CLAMP_CTRL,\n\t\t\t\t   CS42L43_SMIC_HPAMP_CLAMP_DIS_FRC_MASK,\n\t\t\t\t   cs42l43_jack_override_modes[override].clamp_ctrl);\n\n\t\tswitch (override) {\n\t\tcase CS42L43_JACK_RAW_CTIA:\n\t\tcase CS42L43_JACK_RAW_OMTP:\n\t\t\tcs42l43_start_hs_bias(priv, false);\n\t\t\tcs42l43_start_button_detect(priv);\n\t\t\tbreak;\n\t\tcase CS42L43_JACK_RAW_LINE_IN:\n\t\t\tregmap_update_bits(cs42l43->regmap, CS42L43_ADC_B_CTRL1,\n\t\t\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK,\n\t\t\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK);\n\t\t\tregmap_update_bits(cs42l43->regmap, CS42L43_ADC_B_CTRL2,\n\t\t\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK,\n\t\t\t\t\t   CS42L43_PGA_WIDESWING_MODE_EN_MASK);\n\t\t\tbreak;\n\t\tcase CS42L43_JACK_RAW_MICROPHONE:\n\t\t\tcs42l43_start_hs_bias(priv, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tsnd_soc_jack_report(priv->jack_hp,\n\t\t\t\t    cs42l43_jack_override_modes[override].report,\n\t\t\t\t    cs42l43_jack_override_modes[override].report);\n\t}\n\n\tmutex_unlock(&priv->jack_lock);\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}