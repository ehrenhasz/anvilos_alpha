{
  "module_name": "rt1015.c",
  "hash_id": "61b54e429f5c9ee092dc3f704274ff564332d746ba1e7d66604f31d99fcc0c9b",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt1015.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/fs.h>\n#include <linux/i2c.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/rt1015.h>\n#include <sound/soc-dapm.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"rl6231.h\"\n#include \"rt1015.h\"\n\nstatic const struct rt1015_platform_data i2s_default_platform_data = {\n\t.power_up_delay_ms = 50,\n};\n\nstatic const struct reg_default rt1015_reg[] = {\n\t{ 0x0000, 0x0000 },\n\t{ 0x0004, 0xa000 },\n\t{ 0x0006, 0x0003 },\n\t{ 0x000a, 0x081e },\n\t{ 0x000c, 0x0006 },\n\t{ 0x000e, 0x0000 },\n\t{ 0x0010, 0x0000 },\n\t{ 0x0012, 0x0000 },\n\t{ 0x0014, 0x0000 },\n\t{ 0x0016, 0x0000 },\n\t{ 0x0018, 0x0000 },\n\t{ 0x0020, 0x8000 },\n\t{ 0x0022, 0x8043 },\n\t{ 0x0076, 0x0000 },\n\t{ 0x0078, 0x0000 },\n\t{ 0x007a, 0x0002 },\n\t{ 0x007c, 0x10ec },\n\t{ 0x007d, 0x1015 },\n\t{ 0x00f0, 0x5000 },\n\t{ 0x00f2, 0x004c },\n\t{ 0x00f3, 0xecfe },\n\t{ 0x00f4, 0x0000 },\n\t{ 0x00f6, 0x0400 },\n\t{ 0x0100, 0x0028 },\n\t{ 0x0102, 0xff02 },\n\t{ 0x0104, 0xa213 },\n\t{ 0x0106, 0x200c },\n\t{ 0x010c, 0x0000 },\n\t{ 0x010e, 0x0058 },\n\t{ 0x0111, 0x0200 },\n\t{ 0x0112, 0x0400 },\n\t{ 0x0114, 0x0022 },\n\t{ 0x0116, 0x0000 },\n\t{ 0x0118, 0x0000 },\n\t{ 0x011a, 0x0123 },\n\t{ 0x011c, 0x4567 },\n\t{ 0x0300, 0x203d },\n\t{ 0x0302, 0x001e },\n\t{ 0x0311, 0x0000 },\n\t{ 0x0313, 0x6014 },\n\t{ 0x0314, 0x00a2 },\n\t{ 0x031a, 0x00a0 },\n\t{ 0x031c, 0x001f },\n\t{ 0x031d, 0xffff },\n\t{ 0x031e, 0x0000 },\n\t{ 0x031f, 0x0000 },\n\t{ 0x0320, 0x0000 },\n\t{ 0x0321, 0x0000 },\n\t{ 0x0322, 0xd7df },\n\t{ 0x0328, 0x10b2 },\n\t{ 0x0329, 0x0175 },\n\t{ 0x032a, 0x36ad },\n\t{ 0x032b, 0x7e55 },\n\t{ 0x032c, 0x0520 },\n\t{ 0x032d, 0xaa00 },\n\t{ 0x032e, 0x570e },\n\t{ 0x0330, 0xe180 },\n\t{ 0x0332, 0x0034 },\n\t{ 0x0334, 0x0001 },\n\t{ 0x0336, 0x0010 },\n\t{ 0x0338, 0x0000 },\n\t{ 0x04fa, 0x0030 },\n\t{ 0x04fc, 0x35c8 },\n\t{ 0x04fe, 0x0800 },\n\t{ 0x0500, 0x0400 },\n\t{ 0x0502, 0x1000 },\n\t{ 0x0504, 0x0000 },\n\t{ 0x0506, 0x04ff },\n\t{ 0x0508, 0x0010 },\n\t{ 0x050a, 0x001a },\n\t{ 0x0519, 0x1c68 },\n\t{ 0x051a, 0x0ccc },\n\t{ 0x051b, 0x0666 },\n\t{ 0x051d, 0x0000 },\n\t{ 0x051f, 0x0000 },\n\t{ 0x0536, 0x061c },\n\t{ 0x0538, 0x0000 },\n\t{ 0x053a, 0x0000 },\n\t{ 0x053c, 0x0000 },\n\t{ 0x053d, 0x0000 },\n\t{ 0x053e, 0x0000 },\n\t{ 0x053f, 0x0000 },\n\t{ 0x0540, 0x0000 },\n\t{ 0x0541, 0x0000 },\n\t{ 0x0542, 0x0000 },\n\t{ 0x0543, 0x0000 },\n\t{ 0x0544, 0x0000 },\n\t{ 0x0568, 0x0000 },\n\t{ 0x056a, 0x0000 },\n\t{ 0x1000, 0x0040 },\n\t{ 0x1002, 0x5405 },\n\t{ 0x1006, 0x5515 },\n\t{ 0x1007, 0x05f7 },\n\t{ 0x1009, 0x0b0a },\n\t{ 0x100a, 0x00ef },\n\t{ 0x100d, 0x0003 },\n\t{ 0x1010, 0xa433 },\n\t{ 0x1020, 0x0000 },\n\t{ 0x1200, 0x5a01 },\n\t{ 0x1202, 0x6524 },\n\t{ 0x1204, 0x1f00 },\n\t{ 0x1206, 0x0000 },\n\t{ 0x1208, 0x0000 },\n\t{ 0x120a, 0x0000 },\n\t{ 0x120c, 0x0000 },\n\t{ 0x120e, 0x0000 },\n\t{ 0x1210, 0x0000 },\n\t{ 0x1212, 0x0000 },\n\t{ 0x1300, 0x10a1 },\n\t{ 0x1302, 0x12ff },\n\t{ 0x1304, 0x0400 },\n\t{ 0x1305, 0x0844 },\n\t{ 0x1306, 0x4611 },\n\t{ 0x1308, 0x555e },\n\t{ 0x130a, 0x0000 },\n\t{ 0x130c, 0x2000 },\n\t{ 0x130e, 0x0100 },\n\t{ 0x130f, 0x0001 },\n\t{ 0x1310, 0x0000 },\n\t{ 0x1312, 0x0000 },\n\t{ 0x1314, 0x0000 },\n\t{ 0x1316, 0x0000 },\n\t{ 0x1318, 0x0000 },\n\t{ 0x131a, 0x0000 },\n\t{ 0x1322, 0x0029 },\n\t{ 0x1323, 0x4a52 },\n\t{ 0x1324, 0x002c },\n\t{ 0x1325, 0x0b02 },\n\t{ 0x1326, 0x002d },\n\t{ 0x1327, 0x6b5a },\n\t{ 0x1328, 0x002e },\n\t{ 0x1329, 0xcbb2 },\n\t{ 0x132a, 0x0030 },\n\t{ 0x132b, 0x2c0b },\n\t{ 0x1330, 0x0031 },\n\t{ 0x1331, 0x8c63 },\n\t{ 0x1332, 0x0032 },\n\t{ 0x1333, 0xecbb },\n\t{ 0x1334, 0x0034 },\n\t{ 0x1335, 0x4d13 },\n\t{ 0x1336, 0x0037 },\n\t{ 0x1337, 0x0dc3 },\n\t{ 0x1338, 0x003d },\n\t{ 0x1339, 0xef7b },\n\t{ 0x133a, 0x0044 },\n\t{ 0x133b, 0xd134 },\n\t{ 0x133c, 0x0047 },\n\t{ 0x133d, 0x91e4 },\n\t{ 0x133e, 0x004d },\n\t{ 0x133f, 0xc370 },\n\t{ 0x1340, 0x0053 },\n\t{ 0x1341, 0xf4fd },\n\t{ 0x1342, 0x0060 },\n\t{ 0x1343, 0x5816 },\n\t{ 0x1344, 0x006c },\n\t{ 0x1345, 0xbb2e },\n\t{ 0x1346, 0x0072 },\n\t{ 0x1347, 0xecbb },\n\t{ 0x1348, 0x0076 },\n\t{ 0x1349, 0x5d97 },\n};\n\nstatic bool rt1015_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1015_RESET:\n\tcase RT1015_CLK_DET:\n\tcase RT1015_SIL_DET:\n\tcase RT1015_VER_ID:\n\tcase RT1015_VENDOR_ID:\n\tcase RT1015_DEVICE_ID:\n\tcase RT1015_PRO_ALT:\n\tcase RT1015_MAN_I2C:\n\tcase RT1015_DAC3:\n\tcase RT1015_VBAT_TEST_OUT1:\n\tcase RT1015_VBAT_TEST_OUT2:\n\tcase RT1015_VBAT_PROT_ATT:\n\tcase RT1015_VBAT_DET_CODE:\n\tcase RT1015_SMART_BST_CTRL1:\n\tcase RT1015_SPK_DC_DETECT1:\n\tcase RT1015_SPK_DC_DETECT4:\n\tcase RT1015_SPK_DC_DETECT5:\n\tcase RT1015_DC_CALIB_CLSD1:\n\tcase RT1015_DC_CALIB_CLSD5:\n\tcase RT1015_DC_CALIB_CLSD6:\n\tcase RT1015_DC_CALIB_CLSD7:\n\tcase RT1015_DC_CALIB_CLSD8:\n\tcase RT1015_S_BST_TIMING_INTER1:\n\tcase RT1015_OSCK_STA:\n\tcase RT1015_MONO_DYNA_CTRL1:\n\tcase RT1015_MONO_DYNA_CTRL5:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool rt1015_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RT1015_RESET:\n\tcase RT1015_CLK2:\n\tcase RT1015_CLK3:\n\tcase RT1015_PLL1:\n\tcase RT1015_PLL2:\n\tcase RT1015_DUM_RW1:\n\tcase RT1015_DUM_RW2:\n\tcase RT1015_DUM_RW3:\n\tcase RT1015_DUM_RW4:\n\tcase RT1015_DUM_RW5:\n\tcase RT1015_DUM_RW6:\n\tcase RT1015_CLK_DET:\n\tcase RT1015_SIL_DET:\n\tcase RT1015_CUSTOMER_ID:\n\tcase RT1015_PCODE_FWVER:\n\tcase RT1015_VER_ID:\n\tcase RT1015_VENDOR_ID:\n\tcase RT1015_DEVICE_ID:\n\tcase RT1015_PAD_DRV1:\n\tcase RT1015_PAD_DRV2:\n\tcase RT1015_GAT_BOOST:\n\tcase RT1015_PRO_ALT:\n\tcase RT1015_OSCK_STA:\n\tcase RT1015_MAN_I2C:\n\tcase RT1015_DAC1:\n\tcase RT1015_DAC2:\n\tcase RT1015_DAC3:\n\tcase RT1015_ADC1:\n\tcase RT1015_ADC2:\n\tcase RT1015_TDM_MASTER:\n\tcase RT1015_TDM_TCON:\n\tcase RT1015_TDM1_1:\n\tcase RT1015_TDM1_2:\n\tcase RT1015_TDM1_3:\n\tcase RT1015_TDM1_4:\n\tcase RT1015_TDM1_5:\n\tcase RT1015_MIXER1:\n\tcase RT1015_MIXER2:\n\tcase RT1015_ANA_PROTECT1:\n\tcase RT1015_ANA_CTRL_SEQ1:\n\tcase RT1015_ANA_CTRL_SEQ2:\n\tcase RT1015_VBAT_DET_DEB:\n\tcase RT1015_VBAT_VOLT_DET1:\n\tcase RT1015_VBAT_VOLT_DET2:\n\tcase RT1015_VBAT_TEST_OUT1:\n\tcase RT1015_VBAT_TEST_OUT2:\n\tcase RT1015_VBAT_PROT_ATT:\n\tcase RT1015_VBAT_DET_CODE:\n\tcase RT1015_PWR1:\n\tcase RT1015_PWR4:\n\tcase RT1015_PWR5:\n\tcase RT1015_PWR6:\n\tcase RT1015_PWR7:\n\tcase RT1015_PWR8:\n\tcase RT1015_PWR9:\n\tcase RT1015_CLASSD_SEQ:\n\tcase RT1015_SMART_BST_CTRL1:\n\tcase RT1015_SMART_BST_CTRL2:\n\tcase RT1015_ANA_CTRL1:\n\tcase RT1015_ANA_CTRL2:\n\tcase RT1015_PWR_STATE_CTRL:\n\tcase RT1015_MONO_DYNA_CTRL:\n\tcase RT1015_MONO_DYNA_CTRL1:\n\tcase RT1015_MONO_DYNA_CTRL2:\n\tcase RT1015_MONO_DYNA_CTRL3:\n\tcase RT1015_MONO_DYNA_CTRL4:\n\tcase RT1015_MONO_DYNA_CTRL5:\n\tcase RT1015_SPK_VOL:\n\tcase RT1015_SHORT_DETTOP1:\n\tcase RT1015_SHORT_DETTOP2:\n\tcase RT1015_SPK_DC_DETECT1:\n\tcase RT1015_SPK_DC_DETECT2:\n\tcase RT1015_SPK_DC_DETECT3:\n\tcase RT1015_SPK_DC_DETECT4:\n\tcase RT1015_SPK_DC_DETECT5:\n\tcase RT1015_BAT_RPO_STEP1:\n\tcase RT1015_BAT_RPO_STEP2:\n\tcase RT1015_BAT_RPO_STEP3:\n\tcase RT1015_BAT_RPO_STEP4:\n\tcase RT1015_BAT_RPO_STEP5:\n\tcase RT1015_BAT_RPO_STEP6:\n\tcase RT1015_BAT_RPO_STEP7:\n\tcase RT1015_BAT_RPO_STEP8:\n\tcase RT1015_BAT_RPO_STEP9:\n\tcase RT1015_BAT_RPO_STEP10:\n\tcase RT1015_BAT_RPO_STEP11:\n\tcase RT1015_BAT_RPO_STEP12:\n\tcase RT1015_SPREAD_SPEC1:\n\tcase RT1015_SPREAD_SPEC2:\n\tcase RT1015_PAD_STATUS:\n\tcase RT1015_PADS_PULLING_CTRL1:\n\tcase RT1015_PADS_DRIVING:\n\tcase RT1015_SYS_RST1:\n\tcase RT1015_SYS_RST2:\n\tcase RT1015_SYS_GATING1:\n\tcase RT1015_TEST_MODE1:\n\tcase RT1015_TEST_MODE2:\n\tcase RT1015_TIMING_CTRL1:\n\tcase RT1015_PLL_INT:\n\tcase RT1015_TEST_OUT1:\n\tcase RT1015_DC_CALIB_CLSD1:\n\tcase RT1015_DC_CALIB_CLSD2:\n\tcase RT1015_DC_CALIB_CLSD3:\n\tcase RT1015_DC_CALIB_CLSD4:\n\tcase RT1015_DC_CALIB_CLSD5:\n\tcase RT1015_DC_CALIB_CLSD6:\n\tcase RT1015_DC_CALIB_CLSD7:\n\tcase RT1015_DC_CALIB_CLSD8:\n\tcase RT1015_DC_CALIB_CLSD9:\n\tcase RT1015_DC_CALIB_CLSD10:\n\tcase RT1015_CLSD_INTERNAL1:\n\tcase RT1015_CLSD_INTERNAL2:\n\tcase RT1015_CLSD_INTERNAL3:\n\tcase RT1015_CLSD_INTERNAL4:\n\tcase RT1015_CLSD_INTERNAL5:\n\tcase RT1015_CLSD_INTERNAL6:\n\tcase RT1015_CLSD_INTERNAL7:\n\tcase RT1015_CLSD_INTERNAL8:\n\tcase RT1015_CLSD_INTERNAL9:\n\tcase RT1015_CLSD_OCP_CTRL:\n\tcase RT1015_VREF_LV:\n\tcase RT1015_MBIAS1:\n\tcase RT1015_MBIAS2:\n\tcase RT1015_MBIAS3:\n\tcase RT1015_MBIAS4:\n\tcase RT1015_VREF_LV1:\n\tcase RT1015_S_BST_TIMING_INTER1:\n\tcase RT1015_S_BST_TIMING_INTER2:\n\tcase RT1015_S_BST_TIMING_INTER3:\n\tcase RT1015_S_BST_TIMING_INTER4:\n\tcase RT1015_S_BST_TIMING_INTER5:\n\tcase RT1015_S_BST_TIMING_INTER6:\n\tcase RT1015_S_BST_TIMING_INTER7:\n\tcase RT1015_S_BST_TIMING_INTER8:\n\tcase RT1015_S_BST_TIMING_INTER9:\n\tcase RT1015_S_BST_TIMING_INTER10:\n\tcase RT1015_S_BST_TIMING_INTER11:\n\tcase RT1015_S_BST_TIMING_INTER12:\n\tcase RT1015_S_BST_TIMING_INTER13:\n\tcase RT1015_S_BST_TIMING_INTER14:\n\tcase RT1015_S_BST_TIMING_INTER15:\n\tcase RT1015_S_BST_TIMING_INTER16:\n\tcase RT1015_S_BST_TIMING_INTER17:\n\tcase RT1015_S_BST_TIMING_INTER18:\n\tcase RT1015_S_BST_TIMING_INTER19:\n\tcase RT1015_S_BST_TIMING_INTER20:\n\tcase RT1015_S_BST_TIMING_INTER21:\n\tcase RT1015_S_BST_TIMING_INTER22:\n\tcase RT1015_S_BST_TIMING_INTER23:\n\tcase RT1015_S_BST_TIMING_INTER24:\n\tcase RT1015_S_BST_TIMING_INTER25:\n\tcase RT1015_S_BST_TIMING_INTER26:\n\tcase RT1015_S_BST_TIMING_INTER27:\n\tcase RT1015_S_BST_TIMING_INTER28:\n\tcase RT1015_S_BST_TIMING_INTER29:\n\tcase RT1015_S_BST_TIMING_INTER30:\n\tcase RT1015_S_BST_TIMING_INTER31:\n\tcase RT1015_S_BST_TIMING_INTER32:\n\tcase RT1015_S_BST_TIMING_INTER33:\n\tcase RT1015_S_BST_TIMING_INTER34:\n\tcase RT1015_S_BST_TIMING_INTER35:\n\tcase RT1015_S_BST_TIMING_INTER36:\n\t\treturn true;\n\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const DECLARE_TLV_DB_SCALE(dac_vol_tlv, -9525, 75, 0);\n\nstatic const char * const rt1015_din_source_select[] = {\n\t\"Left\",\n\t\"Right\",\n\t\"Left + Right average\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1015_mono_lr_sel, RT1015_PAD_DRV2, 4,\n\trt1015_din_source_select);\n\nstatic const char * const rt1015_boost_mode[] = {\n\t\"Bypass\", \"Adaptive\", \"Fixed Adaptive\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rt1015_boost_mode_enum, 0, 0,\n\trt1015_boost_mode);\n\nstatic int rt1015_boost_mode_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct rt1015_priv *rt1015 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = rt1015->boost_mode;\n\n\treturn 0;\n}\n\nstatic int rt1015_boost_mode_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct rt1015_priv *rt1015 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tint boost_mode = ucontrol->value.integer.value[0];\n\n\tswitch (boost_mode) {\n\tcase BYPASS:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1015_SMART_BST_CTRL1, RT1015_ABST_AUTO_EN_MASK |\n\t\t\tRT1015_ABST_FIX_TGT_MASK | RT1015_BYPASS_SWR_REG_MASK,\n\t\t\tRT1015_ABST_REG_MODE | RT1015_ABST_FIX_TGT_DIS |\n\t\t\tRT1015_BYPASS_SWRREG_BYPASS);\n\t\tbreak;\n\tcase ADAPTIVE:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1015_SMART_BST_CTRL1, RT1015_ABST_AUTO_EN_MASK |\n\t\t\tRT1015_ABST_FIX_TGT_MASK | RT1015_BYPASS_SWR_REG_MASK,\n\t\t\tRT1015_ABST_AUTO_MODE | RT1015_ABST_FIX_TGT_DIS |\n\t\t\tRT1015_BYPASS_SWRREG_PASS);\n\t\tbreak;\n\tcase FIXED_ADAPTIVE:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1015_SMART_BST_CTRL1, RT1015_ABST_AUTO_EN_MASK |\n\t\t\tRT1015_ABST_FIX_TGT_MASK | RT1015_BYPASS_SWR_REG_MASK,\n\t\t\tRT1015_ABST_AUTO_MODE | RT1015_ABST_FIX_TGT_EN |\n\t\t\tRT1015_BYPASS_SWRREG_PASS);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown boost control.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trt1015->boost_mode = boost_mode;\n\n\treturn 0;\n}\n\nstatic int rt1015_bypass_boost_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct rt1015_priv *rt1015 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = rt1015->bypass_boost;\n\n\treturn 0;\n}\n\nstatic void rt1015_calibrate(struct rt1015_priv *rt1015)\n{\n\tstruct snd_soc_component *component = rt1015->component;\n\tstruct regmap *regmap = rt1015->regmap;\n\n\tsnd_soc_dapm_mutex_lock(&component->dapm);\n\tregcache_cache_bypass(regmap, true);\n\n\tregmap_write(regmap, RT1015_CLK_DET, 0x0000);\n\tregmap_write(regmap, RT1015_PWR4, 0x00B2);\n\tregmap_write(regmap, RT1015_PWR_STATE_CTRL, 0x0009);\n\tmsleep(100);\n\tregmap_write(regmap, RT1015_PWR_STATE_CTRL, 0x000A);\n\tmsleep(100);\n\tregmap_write(regmap, RT1015_PWR_STATE_CTRL, 0x000C);\n\tmsleep(100);\n\tregmap_write(regmap, RT1015_CLSD_INTERNAL8, 0x2028);\n\tregmap_write(regmap, RT1015_CLSD_INTERNAL9, 0x0140);\n\tregmap_write(regmap, RT1015_PWR_STATE_CTRL, 0x000D);\n\tmsleep(300);\n\tregmap_write(regmap, RT1015_PWR_STATE_CTRL, 0x0008);\n\tregmap_write(regmap, RT1015_SYS_RST1, 0x05F5);\n\tregmap_write(regmap, RT1015_CLK_DET, 0x8000);\n\n\tregcache_cache_bypass(regmap, false);\n\tregcache_mark_dirty(regmap);\n\tregcache_sync(regmap);\n\tsnd_soc_dapm_mutex_unlock(&component->dapm);\n}\n\nstatic int rt1015_bypass_boost_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_kcontrol_component(kcontrol);\n\tstruct rt1015_priv *rt1015 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tif (rt1015->dac_is_used) {\n\t\tdev_err(component->dev, \"DAC is being used!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\trt1015->bypass_boost = ucontrol->value.integer.value[0];\n\tif (rt1015->bypass_boost == RT1015_Bypass_Boost &&\n\t\t\t!rt1015->cali_done) {\n\t\trt1015_calibrate(rt1015);\n\t\trt1015->cali_done = 1;\n\n\t\tregmap_write(rt1015->regmap, RT1015_MONO_DYNA_CTRL, 0x0010);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new rt1015_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"DAC Playback Volume\", RT1015_DAC1, RT1015_DAC_VOL_SFT,\n\t\t127, 0, dac_vol_tlv),\n\tSOC_DOUBLE(\"DAC Playback Switch\", RT1015_DAC3,\n\t\tRT1015_DA_MUTE_SFT, RT1015_DVOL_MUTE_FLAG_SFT, 1, 1),\n\tSOC_ENUM_EXT(\"Boost Mode\", rt1015_boost_mode_enum,\n\t\trt1015_boost_mode_get, rt1015_boost_mode_put),\n\tSOC_ENUM(\"Mono LR Select\", rt1015_mono_lr_sel),\n\tSOC_SINGLE_EXT(\"Bypass Boost\", SND_SOC_NOPM, 0, 1, 0,\n\t\trt1015_bypass_boost_get, rt1015_bypass_boost_put),\n};\n\nstatic int rt1015_is_sys_clk_from_pll(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(source->dapm);\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\n\tif (rt1015->sysclk_src == RT1015_SCLK_S_PLL)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int r1015_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\trt1015->dac_is_used = 1;\n\t\tif (rt1015->bypass_boost == RT1015_Enable_Boost) {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST1, 0x05f7);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST2, 0x0b0a);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_GAT_BOOST, 0xacfe);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_PWR9, 0xaa00);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_GAT_BOOST, 0xecfe);\n\t\t} else {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\t0x032d, 0xaa60);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST1, 0x05f7);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST2, 0x0b0a);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_PWR_STATE_CTRL, 0x008e);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tif (rt1015->bypass_boost == RT1015_Enable_Boost) {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_PWR9, 0xa800);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST1, 0x05f5);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST2, 0x0b9a);\n\t\t} else {\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\t0x032d, 0xaa60);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_PWR_STATE_CTRL, 0x0088);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST1, 0x05f5);\n\t\t\tsnd_soc_component_write(component,\n\t\t\t\tRT1015_SYS_RST2, 0x0b9a);\n\t\t}\n\t\trt1015->dac_is_used = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt1015_amp_drv_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\tunsigned int ret, ret2;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tret = snd_soc_component_read(component, RT1015_CLK_DET);\n\t\tret2 = snd_soc_component_read(component, RT1015_SPK_DC_DETECT1);\n\t\tif (!((ret >> 15) & 0x1)) {\n\t\t\tsnd_soc_component_update_bits(component, RT1015_CLK_DET,\n\t\t\t\tRT1015_EN_BCLK_DET_MASK, RT1015_EN_BCLK_DET);\n\t\t\tdev_dbg(component->dev, \"BCLK Detection Enabled.\\n\");\n\t\t}\n\t\tif (!((ret2 >> 12) & 0x1)) {\n\t\t\tsnd_soc_component_update_bits(component, RT1015_SPK_DC_DETECT1,\n\t\t\t\tRT1015_EN_CLA_D_DC_DET_MASK, RT1015_EN_CLA_D_DC_DET);\n\t\t\tdev_dbg(component->dev, \"Class-D DC Detection Enabled.\\n\");\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tmsleep(rt1015->pdata.power_up_delay_ms);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt1015_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"PLL\", RT1015_PWR1, RT1015_PWR_PLL_BIT, 0,\n\t\tNULL, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"AIF Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_DAC_E(\"DAC\", NULL, SND_SOC_NOPM, 0, 0,\n\t\tr1015_dac_event, SND_SOC_DAPM_PRE_PMU |\n\t\tSND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_OUT_DRV_E(\"Amp Drv\", SND_SOC_NOPM, 0, 0, NULL, 0,\n\t\t\trt1015_amp_drv_event, SND_SOC_DAPM_PRE_PMU |\n\t\t\tSND_SOC_DAPM_POST_PMU),\n\tSND_SOC_DAPM_OUTPUT(\"SPO\"),\n};\n\nstatic const struct snd_soc_dapm_route rt1015_dapm_routes[] = {\n\t{ \"DAC\", NULL, \"AIFRX\" },\n\t{ \"DAC\", NULL, \"PLL\", rt1015_is_sys_clk_from_pll},\n\t{ \"Amp Drv\", NULL, \"DAC\" },\n\t{ \"SPO\", NULL, \"Amp Drv\" },\n};\n\nstatic int rt1015_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\tint pre_div, frame_size, lrck;\n\tunsigned int val_len = 0;\n\n\tlrck = params_rate(params);\n\tpre_div = rl6231_get_clk_info(rt1015->sysclk, lrck);\n\tif (pre_div < 0) {\n\t\tdev_err(component->dev, \"Unsupported clock rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tframe_size = snd_soc_params_to_frame_size(params);\n\tif (frame_size < 0) {\n\t\tdev_err(component->dev, \"Unsupported frame size: %d\\n\",\n\t\t\tframe_size);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(component->dev, \"pre_div is %d for iis %d\\n\", pre_div, dai->id);\n\n\tdev_dbg(component->dev, \"lrck is %dHz and pre_div is %d for iis %d\\n\",\n\t\t\t\tlrck, pre_div, dai->id);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\tval_len = RT1015_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len = RT1015_I2S_DL_24;\n\t\tbreak;\n\tcase 8:\n\t\tval_len = RT1015_I2S_DL_8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1015_TDM_MASTER,\n\t\tRT1015_I2S_DL_MASK, val_len);\n\tsnd_soc_component_update_bits(component, RT1015_CLK2,\n\t\tRT1015_FS_PD_MASK, pre_div << RT1015_FS_PD_SFT);\n\n\treturn 0;\n}\n\nstatic int rt1015_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int reg_val = 0, reg_val2 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\treg_val |= RT1015_TCON_TDM_MS_M;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\treg_val |= RT1015_TCON_TDM_MS_S;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\treg_val2 |= RT1015_TDM_INV_BCLK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\treg_val |= RT1015_I2S_M_DF_LEFT;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\treg_val |= RT1015_I2S_M_DF_PCM_A;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\treg_val |= RT1015_I2S_M_DF_PCM_B;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1015_TDM_MASTER,\n\t\t\tRT1015_TCON_TDM_MS_MASK | RT1015_I2S_M_DF_MASK,\n\t\t\treg_val);\n\tsnd_soc_component_update_bits(component, RT1015_TDM1_1,\n\t\t\tRT1015_TDM_INV_BCLK_MASK, reg_val2);\n\n\treturn 0;\n}\n\nstatic int rt1015_set_component_sysclk(struct snd_soc_component *component,\n\t\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg_val = 0;\n\n\tif (freq == rt1015->sysclk && clk_id == rt1015->sysclk_src)\n\t\treturn 0;\n\n\tswitch (clk_id) {\n\tcase RT1015_SCLK_S_MCLK:\n\t\treg_val |= RT1015_CLK_SYS_PRE_SEL_MCLK;\n\t\tbreak;\n\n\tcase RT1015_SCLK_S_PLL:\n\t\treg_val |= RT1015_CLK_SYS_PRE_SEL_PLL;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\trt1015->sysclk = freq;\n\trt1015->sysclk_src = clk_id;\n\n\tdev_dbg(component->dev, \"Sysclk is %dHz and clock id is %d\\n\",\n\t\tfreq, clk_id);\n\n\tsnd_soc_component_update_bits(component, RT1015_CLK2,\n\t\t\tRT1015_CLK_SYS_PRE_SEL_MASK, reg_val);\n\n\treturn 0;\n}\n\nstatic int rt1015_set_component_pll(struct snd_soc_component *component,\n\t\tint pll_id, int source, unsigned int freq_in,\n\t\tunsigned int freq_out)\n{\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\tstruct rl6231_pll_code pll_code;\n\tint ret;\n\n\tif (!freq_in || !freq_out) {\n\t\tdev_dbg(component->dev, \"PLL disabled\\n\");\n\n\t\trt1015->pll_in = 0;\n\t\trt1015->pll_out = 0;\n\n\t\treturn 0;\n\t}\n\n\tif (source == rt1015->pll_src && freq_in == rt1015->pll_in &&\n\t\tfreq_out == rt1015->pll_out)\n\t\treturn 0;\n\n\tswitch (source) {\n\tcase RT1015_PLL_S_MCLK:\n\t\tsnd_soc_component_update_bits(component, RT1015_CLK2,\n\t\t\tRT1015_PLL_SEL_MASK, RT1015_PLL_SEL_PLL_SRC2);\n\t\tbreak;\n\n\tcase RT1015_PLL_S_BCLK:\n\t\tsnd_soc_component_update_bits(component, RT1015_CLK2,\n\t\t\tRT1015_PLL_SEL_MASK, RT1015_PLL_SEL_BCLK);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown PLL Source %d\\n\", source);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rl6231_pll_calc(freq_in, freq_out, &pll_code);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"bypass=%d m=%d n=%d k=%d\\n\",\n\t\tpll_code.m_bp, (pll_code.m_bp ? 0 : pll_code.m_code),\n\t\tpll_code.n_code, pll_code.k_code);\n\n\tsnd_soc_component_write(component, RT1015_PLL1,\n\t\t((pll_code.m_bp ? 0 : pll_code.m_code) << RT1015_PLL_M_SFT) |\n\t\t(pll_code.m_bp << RT1015_PLL_M_BP_SFT) |\n\t\tpll_code.n_code);\n\tsnd_soc_component_write(component, RT1015_PLL2,\n\t\tpll_code.k_code);\n\n\trt1015->pll_in = freq_in;\n\trt1015->pll_out = freq_out;\n\trt1015->pll_src = source;\n\n\treturn 0;\n}\n\nstatic int rt1015_set_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tunsigned int val = 0, rx_slotnum, tx_slotnum;\n\tint ret = 0, first_bit;\n\n\tswitch (slots) {\n\tcase 2:\n\t\tval |= RT1015_I2S_TX_2CH;\n\t\tbreak;\n\tcase 4:\n\t\tval |= RT1015_I2S_TX_4CH;\n\t\tbreak;\n\tcase 6:\n\t\tval |= RT1015_I2S_TX_6CH;\n\t\tbreak;\n\tcase 8:\n\t\tval |= RT1015_I2S_TX_8CH;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto _set_tdm_err_;\n\t}\n\n\tswitch (slot_width) {\n\tcase 16:\n\t\tval |= RT1015_I2S_CH_TX_LEN_16B;\n\t\tbreak;\n\tcase 20:\n\t\tval |= RT1015_I2S_CH_TX_LEN_20B;\n\t\tbreak;\n\tcase 24:\n\t\tval |= RT1015_I2S_CH_TX_LEN_24B;\n\t\tbreak;\n\tcase 32:\n\t\tval |= RT1015_I2S_CH_TX_LEN_32B;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto _set_tdm_err_;\n\t}\n\n\t \n\trx_slotnum = hweight_long(rx_mask);\n\tif (rx_slotnum != 1) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"too many rx slots or zero slot\\n\");\n\t\tgoto _set_tdm_err_;\n\t}\n\n\t \n\tfirst_bit = __ffs(rx_mask);\n\tswitch (first_bit) {\n\tcase 0:\n\tcase 2:\n\tcase 4:\n\tcase 6:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1015_TDM1_4,\n\t\t\tRT1015_TDM_I2S_TX_L_DAC1_1_MASK |\n\t\t\tRT1015_TDM_I2S_TX_R_DAC1_1_MASK,\n\t\t\t(first_bit << RT1015_TDM_I2S_TX_L_DAC1_1_SFT) |\n\t\t\t((first_bit+1) << RT1015_TDM_I2S_TX_R_DAC1_1_SFT));\n\t\tbreak;\n\tcase 1:\n\tcase 3:\n\tcase 5:\n\tcase 7:\n\t\tsnd_soc_component_update_bits(component,\n\t\t\tRT1015_TDM1_4,\n\t\t\tRT1015_TDM_I2S_TX_L_DAC1_1_MASK |\n\t\t\tRT1015_TDM_I2S_TX_R_DAC1_1_MASK,\n\t\t\t((first_bit-1) << RT1015_TDM_I2S_TX_L_DAC1_1_SFT) |\n\t\t\t(first_bit << RT1015_TDM_I2S_TX_R_DAC1_1_SFT));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto _set_tdm_err_;\n\t}\n\n\t \n\ttx_slotnum = hweight_long(tx_mask);\n\tif (tx_slotnum) {\n\t\tret = -EINVAL;\n\t\tdev_err(component->dev, \"doesn't need to support tx slots\\n\");\n\t\tgoto _set_tdm_err_;\n\t}\n\n\tsnd_soc_component_update_bits(component, RT1015_TDM1_1,\n\t\tRT1015_I2S_CH_TX_MASK | RT1015_I2S_CH_RX_MASK |\n\t\tRT1015_I2S_CH_TX_LEN_MASK | RT1015_I2S_CH_RX_LEN_MASK, val);\n\n_set_tdm_err_:\n\treturn ret;\n}\n\nstatic int rt1015_probe(struct snd_soc_component *component)\n{\n\tstruct rt1015_priv *rt1015 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\trt1015->component = component;\n\n\treturn 0;\n}\n\nstatic void rt1015_remove(struct snd_soc_component *component)\n{\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\n\tregmap_write(rt1015->regmap, RT1015_RESET, 0);\n}\n\n#define RT1015_STEREO_RATES SNDRV_PCM_RATE_8000_192000\n#define RT1015_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S8)\n\nstatic const struct snd_soc_dai_ops rt1015_aif_dai_ops = {\n\t.hw_params = rt1015_hw_params,\n\t.set_fmt = rt1015_set_dai_fmt,\n\t.set_tdm_slot = rt1015_set_tdm_slot,\n};\n\nstatic struct snd_soc_dai_driver rt1015_dai[] = {\n\t{\n\t\t.name = \"rt1015-aif\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"AIF Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 4,\n\t\t\t.rates = RT1015_STEREO_RATES,\n\t\t\t.formats = RT1015_FORMATS,\n\t\t},\n\t\t.ops = &rt1015_aif_dai_ops,\n\t}\n};\n\n#ifdef CONFIG_PM\nstatic int rt1015_suspend(struct snd_soc_component *component)\n{\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1015->regmap, true);\n\tregcache_mark_dirty(rt1015->regmap);\n\n\treturn 0;\n}\n\nstatic int rt1015_resume(struct snd_soc_component *component)\n{\n\tstruct rt1015_priv *rt1015 = snd_soc_component_get_drvdata(component);\n\n\tregcache_cache_only(rt1015->regmap, false);\n\tregcache_sync(rt1015->regmap);\n\n\tif (rt1015->cali_done)\n\t\trt1015_calibrate(rt1015);\n\n\treturn 0;\n}\n#else\n#define rt1015_suspend NULL\n#define rt1015_resume NULL\n#endif\n\nstatic const struct snd_soc_component_driver soc_component_dev_rt1015 = {\n\t.probe = rt1015_probe,\n\t.remove = rt1015_remove,\n\t.suspend = rt1015_suspend,\n\t.resume = rt1015_resume,\n\t.controls = rt1015_snd_controls,\n\t.num_controls = ARRAY_SIZE(rt1015_snd_controls),\n\t.dapm_widgets = rt1015_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt1015_dapm_widgets),\n\t.dapm_routes = rt1015_dapm_routes,\n\t.num_dapm_routes = ARRAY_SIZE(rt1015_dapm_routes),\n\t.set_sysclk = rt1015_set_component_sysclk,\n\t.set_pll = rt1015_set_component_pll,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config rt1015_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n\t.max_register = RT1015_S_BST_TIMING_INTER36,\n\t.volatile_reg = rt1015_volatile_register,\n\t.readable_reg = rt1015_readable_register,\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = rt1015_reg,\n\t.num_reg_defaults = ARRAY_SIZE(rt1015_reg),\n};\n\nstatic const struct i2c_device_id rt1015_i2c_id[] = {\n\t{ \"rt1015\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1015_i2c_id);\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id rt1015_of_match[] = {\n\t{ .compatible = \"realtek,rt1015\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt1015_of_match);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id rt1015_acpi_match[] = {\n\t{\"10EC1015\", 0,},\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, rt1015_acpi_match);\n#endif\n\nstatic void rt1015_parse_dt(struct rt1015_priv *rt1015, struct device *dev)\n{\n\tdevice_property_read_u32(dev, \"realtek,power-up-delay-ms\",\n\t\t&rt1015->pdata.power_up_delay_ms);\n}\n\nstatic int rt1015_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct rt1015_platform_data *pdata = dev_get_platdata(&i2c->dev);\n\tstruct rt1015_priv *rt1015;\n\tint ret;\n\tunsigned int val;\n\n\trt1015 = devm_kzalloc(&i2c->dev, sizeof(*rt1015), GFP_KERNEL);\n\tif (!rt1015)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, rt1015);\n\n\trt1015->pdata = i2s_default_platform_data;\n\n\tif (pdata)\n\t\trt1015->pdata = *pdata;\n\telse\n\t\trt1015_parse_dt(rt1015, &i2c->dev);\n\n\trt1015->regmap = devm_regmap_init_i2c(i2c, &rt1015_regmap);\n\tif (IS_ERR(rt1015->regmap)) {\n\t\tret = PTR_ERR(rt1015->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(rt1015->regmap, RT1015_DEVICE_ID, &val);\n\tif (ret) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Failed to read device register: %d\\n\", ret);\n\t\treturn ret;\n\t} else if ((val != RT1015_DEVICE_ID_VAL) &&\n\t\t\t(val != RT1015_DEVICE_ID_VAL2)) {\n\t\tdev_err(&i2c->dev,\n\t\t\t\"Device with ID register %x is not rt1015\\n\", val);\n\t\treturn -ENODEV;\n\t}\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t&soc_component_dev_rt1015,\n\t\trt1015_dai, ARRAY_SIZE(rt1015_dai));\n}\n\nstatic void rt1015_i2c_shutdown(struct i2c_client *client)\n{\n\tstruct rt1015_priv *rt1015 = i2c_get_clientdata(client);\n\n\tregmap_write(rt1015->regmap, RT1015_RESET, 0);\n}\n\nstatic struct i2c_driver rt1015_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1015\",\n\t\t.of_match_table = of_match_ptr(rt1015_of_match),\n\t\t.acpi_match_table = ACPI_PTR(rt1015_acpi_match),\n\t},\n\t.probe = rt1015_i2c_probe,\n\t.shutdown = rt1015_i2c_shutdown,\n\t.id_table = rt1015_i2c_id,\n};\nmodule_i2c_driver(rt1015_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC RT1015 driver\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}