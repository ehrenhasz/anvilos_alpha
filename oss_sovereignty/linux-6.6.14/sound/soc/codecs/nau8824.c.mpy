{
  "module_name": "nau8824.c",
  "hash_id": "a12fda781f518c79ec01692d76eb43de5fa24c72c81a3b19c2ae9da527851d73",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/nau8824.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n#include <linux/init.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/acpi.h>\n#include <linux/math64.h>\n#include <linux/semaphore.h>\n\n#include <sound/initval.h>\n#include <sound/tlv.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/jack.h>\n\n#include \"nau8824.h\"\n\n#define NAU8824_JD_ACTIVE_HIGH\t\t\tBIT(0)\n#define NAU8824_MONO_SPEAKER\t\t\tBIT(1)\n\nstatic int nau8824_quirk;\nstatic int quirk_override = -1;\nmodule_param_named(quirk, quirk_override, uint, 0444);\nMODULE_PARM_DESC(quirk, \"Board-specific quirk override\");\n\nstatic int nau8824_config_sysclk(struct nau8824 *nau8824,\n\tint clk_id, unsigned int freq);\nstatic bool nau8824_is_jack_inserted(struct nau8824 *nau8824);\n\n \n#define DMIC_CLK 3072000\n\n \n#define HEADSET_SARADC_THD 0x80\n\n \n#define NAU_FREF_MAX 13500000\n#define NAU_FVCO_MAX 100000000\n#define NAU_FVCO_MIN 90000000\n\n \nstatic const struct nau8824_fll_attr mclk_src_scaling[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x2 },\n\t{ 4, 0x3 },\n\t{ 8, 0x4 },\n\t{ 16, 0x5 },\n\t{ 32, 0x6 },\n\t{ 3, 0x7 },\n\t{ 6, 0xa },\n\t{ 12, 0xb },\n\t{ 24, 0xc },\n};\n\n \nstatic const struct nau8824_fll_attr fll_ratio[] = {\n\t{ 512000, 0x01 },\n\t{ 256000, 0x02 },\n\t{ 128000, 0x04 },\n\t{ 64000, 0x08 },\n\t{ 32000, 0x10 },\n\t{ 8000, 0x20 },\n\t{ 4000, 0x40 },\n};\n\nstatic const struct nau8824_fll_attr fll_pre_scalar[] = {\n\t{ 1, 0x0 },\n\t{ 2, 0x1 },\n\t{ 4, 0x2 },\n\t{ 8, 0x3 },\n};\n\n \n#define CLK_DA_AD_MAX 6144000\n\n \nstatic const struct nau8824_osr_attr osr_dac_sel[] = {\n\t{ 64, 2 },\t \n\t{ 256, 0 },\t \n\t{ 128, 1 },\t \n\t{ 0, 0 },\n\t{ 32, 3 },\t \n};\n\nstatic const struct nau8824_osr_attr osr_adc_sel[] = {\n\t{ 32, 3 },\t \n\t{ 64, 2 },\t \n\t{ 128, 1 },\t \n\t{ 256, 0 },\t \n};\n\nstatic const struct reg_default nau8824_reg_defaults[] = {\n\t{ NAU8824_REG_ENA_CTRL, 0x0000 },\n\t{ NAU8824_REG_CLK_GATING_ENA, 0x0000 },\n\t{ NAU8824_REG_CLK_DIVIDER, 0x0000 },\n\t{ NAU8824_REG_FLL1, 0x0000 },\n\t{ NAU8824_REG_FLL2, 0x3126 },\n\t{ NAU8824_REG_FLL3, 0x0008 },\n\t{ NAU8824_REG_FLL4, 0x0010 },\n\t{ NAU8824_REG_FLL5, 0xC000 },\n\t{ NAU8824_REG_FLL6, 0x6000 },\n\t{ NAU8824_REG_FLL_VCO_RSV, 0xF13C },\n\t{ NAU8824_REG_JACK_DET_CTRL, 0x0000 },\n\t{ NAU8824_REG_INTERRUPT_SETTING_1, 0x0000 },\n\t{ NAU8824_REG_IRQ, 0x0000 },\n\t{ NAU8824_REG_CLEAR_INT_REG, 0x0000 },\n\t{ NAU8824_REG_INTERRUPT_SETTING, 0x1000 },\n\t{ NAU8824_REG_SAR_ADC, 0x0015 },\n\t{ NAU8824_REG_VDET_COEFFICIENT, 0x0110 },\n\t{ NAU8824_REG_VDET_THRESHOLD_1, 0x0000 },\n\t{ NAU8824_REG_VDET_THRESHOLD_2, 0x0000 },\n\t{ NAU8824_REG_VDET_THRESHOLD_3, 0x0000 },\n\t{ NAU8824_REG_VDET_THRESHOLD_4, 0x0000 },\n\t{ NAU8824_REG_GPIO_SEL, 0x0000 },\n\t{ NAU8824_REG_PORT0_I2S_PCM_CTRL_1, 0x000B },\n\t{ NAU8824_REG_PORT0_I2S_PCM_CTRL_2, 0x0010 },\n\t{ NAU8824_REG_PORT0_LEFT_TIME_SLOT, 0x0000 },\n\t{ NAU8824_REG_PORT0_RIGHT_TIME_SLOT, 0x0000 },\n\t{ NAU8824_REG_TDM_CTRL, 0x0000 },\n\t{ NAU8824_REG_ADC_HPF_FILTER, 0x0000 },\n\t{ NAU8824_REG_ADC_FILTER_CTRL, 0x0002 },\n\t{ NAU8824_REG_DAC_FILTER_CTRL_1, 0x0000 },\n\t{ NAU8824_REG_DAC_FILTER_CTRL_2, 0x0000 },\n\t{ NAU8824_REG_NOTCH_FILTER_1, 0x0000 },\n\t{ NAU8824_REG_NOTCH_FILTER_2, 0x0000 },\n\t{ NAU8824_REG_EQ1_LOW, 0x112C },\n\t{ NAU8824_REG_EQ2_EQ3, 0x2C2C },\n\t{ NAU8824_REG_EQ4_EQ5, 0x2C2C },\n\t{ NAU8824_REG_ADC_CH0_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_ADC_CH1_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_ADC_CH2_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_ADC_CH3_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_DAC_MUTE_CTRL, 0x0000 },\n\t{ NAU8824_REG_DAC_CH0_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_DAC_CH1_DGAIN_CTRL, 0x0100 },\n\t{ NAU8824_REG_ADC_TO_DAC_ST, 0x0000 },\n\t{ NAU8824_REG_DRC_KNEE_IP12_ADC_CH01, 0x1486 },\n\t{ NAU8824_REG_DRC_KNEE_IP34_ADC_CH01, 0x0F12 },\n\t{ NAU8824_REG_DRC_SLOPE_ADC_CH01, 0x25FF },\n\t{ NAU8824_REG_DRC_ATKDCY_ADC_CH01, 0x3457 },\n\t{ NAU8824_REG_DRC_KNEE_IP12_ADC_CH23, 0x1486 },\n\t{ NAU8824_REG_DRC_KNEE_IP34_ADC_CH23, 0x0F12 },\n\t{ NAU8824_REG_DRC_SLOPE_ADC_CH23, 0x25FF },\n\t{ NAU8824_REG_DRC_ATKDCY_ADC_CH23, 0x3457 },\n\t{ NAU8824_REG_DRC_GAINL_ADC0, 0x0200 },\n\t{ NAU8824_REG_DRC_GAINL_ADC1, 0x0200 },\n\t{ NAU8824_REG_DRC_GAINL_ADC2, 0x0200 },\n\t{ NAU8824_REG_DRC_GAINL_ADC3, 0x0200 },\n\t{ NAU8824_REG_DRC_KNEE_IP12_DAC, 0x1486 },\n\t{ NAU8824_REG_DRC_KNEE_IP34_DAC, 0x0F12 },\n\t{ NAU8824_REG_DRC_SLOPE_DAC, 0x25F9 },\n\t{ NAU8824_REG_DRC_ATKDCY_DAC, 0x3457 },\n\t{ NAU8824_REG_DRC_GAIN_DAC_CH0, 0x0200 },\n\t{ NAU8824_REG_DRC_GAIN_DAC_CH1, 0x0200 },\n\t{ NAU8824_REG_MODE, 0x0000 },\n\t{ NAU8824_REG_MODE1, 0x0000 },\n\t{ NAU8824_REG_MODE2, 0x0000 },\n\t{ NAU8824_REG_CLASSG, 0x0000 },\n\t{ NAU8824_REG_OTP_EFUSE, 0x0000 },\n\t{ NAU8824_REG_OTPDOUT_1, 0x0000 },\n\t{ NAU8824_REG_OTPDOUT_2, 0x0000 },\n\t{ NAU8824_REG_MISC_CTRL, 0x0000 },\n\t{ NAU8824_REG_I2C_TIMEOUT, 0xEFFF },\n\t{ NAU8824_REG_TEST_MODE, 0x0000 },\n\t{ NAU8824_REG_I2C_DEVICE_ID, 0x1AF1 },\n\t{ NAU8824_REG_SAR_ADC_DATA_OUT, 0x00FF },\n\t{ NAU8824_REG_BIAS_ADJ, 0x0000 },\n\t{ NAU8824_REG_PGA_GAIN, 0x0000 },\n\t{ NAU8824_REG_TRIM_SETTINGS, 0x0000 },\n\t{ NAU8824_REG_ANALOG_CONTROL_1, 0x0000 },\n\t{ NAU8824_REG_ANALOG_CONTROL_2, 0x0000 },\n\t{ NAU8824_REG_ENABLE_LO, 0x0000 },\n\t{ NAU8824_REG_GAIN_LO, 0x0000 },\n\t{ NAU8824_REG_CLASSD_GAIN_1, 0x0000 },\n\t{ NAU8824_REG_CLASSD_GAIN_2, 0x0000 },\n\t{ NAU8824_REG_ANALOG_ADC_1, 0x0011 },\n\t{ NAU8824_REG_ANALOG_ADC_2, 0x0020 },\n\t{ NAU8824_REG_RDAC, 0x0008 },\n\t{ NAU8824_REG_MIC_BIAS, 0x0006 },\n\t{ NAU8824_REG_HS_VOLUME_CONTROL, 0x0000 },\n\t{ NAU8824_REG_BOOST, 0x0000 },\n\t{ NAU8824_REG_FEPGA, 0x0000 },\n\t{ NAU8824_REG_FEPGA_II, 0x0000 },\n\t{ NAU8824_REG_FEPGA_SE, 0x0000 },\n\t{ NAU8824_REG_FEPGA_ATTENUATION, 0x0000 },\n\t{ NAU8824_REG_ATT_PORT0, 0x0000 },\n\t{ NAU8824_REG_ATT_PORT1, 0x0000 },\n\t{ NAU8824_REG_POWER_UP_CONTROL, 0x0000 },\n\t{ NAU8824_REG_CHARGE_PUMP_CONTROL, 0x0300 },\n\t{ NAU8824_REG_CHARGE_PUMP_INPUT, 0x0013 },\n};\n\nstatic int nau8824_sema_acquire(struct nau8824 *nau8824, long timeout)\n{\n\tint ret;\n\n\tif (timeout) {\n\t\tret = down_timeout(&nau8824->jd_sem, timeout);\n\t\tif (ret < 0)\n\t\t\tdev_warn(nau8824->dev, \"Acquire semaphore timeout\\n\");\n\t} else {\n\t\tret = down_interruptible(&nau8824->jd_sem);\n\t\tif (ret < 0)\n\t\t\tdev_warn(nau8824->dev, \"Acquire semaphore fail\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic inline void nau8824_sema_release(struct nau8824 *nau8824)\n{\n\tup(&nau8824->jd_sem);\n}\n\nstatic bool nau8824_readable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8824_REG_ENA_CTRL ... NAU8824_REG_FLL_VCO_RSV:\n\tcase NAU8824_REG_JACK_DET_CTRL:\n\tcase NAU8824_REG_INTERRUPT_SETTING_1:\n\tcase NAU8824_REG_IRQ:\n\tcase NAU8824_REG_CLEAR_INT_REG ... NAU8824_REG_VDET_THRESHOLD_4:\n\tcase NAU8824_REG_GPIO_SEL:\n\tcase NAU8824_REG_PORT0_I2S_PCM_CTRL_1 ... NAU8824_REG_TDM_CTRL:\n\tcase NAU8824_REG_ADC_HPF_FILTER ... NAU8824_REG_EQ4_EQ5:\n\tcase NAU8824_REG_ADC_CH0_DGAIN_CTRL ... NAU8824_REG_ADC_TO_DAC_ST:\n\tcase NAU8824_REG_DRC_KNEE_IP12_ADC_CH01 ... NAU8824_REG_DRC_GAINL_ADC3:\n\tcase NAU8824_REG_DRC_KNEE_IP12_DAC ... NAU8824_REG_DRC_GAIN_DAC_CH1:\n\tcase NAU8824_REG_CLASSG ... NAU8824_REG_OTP_EFUSE:\n\tcase NAU8824_REG_OTPDOUT_1 ... NAU8824_REG_OTPDOUT_2:\n\tcase NAU8824_REG_I2C_TIMEOUT:\n\tcase NAU8824_REG_I2C_DEVICE_ID ... NAU8824_REG_SAR_ADC_DATA_OUT:\n\tcase NAU8824_REG_BIAS_ADJ ... NAU8824_REG_CLASSD_GAIN_2:\n\tcase NAU8824_REG_ANALOG_ADC_1 ... NAU8824_REG_ATT_PORT1:\n\tcase NAU8824_REG_POWER_UP_CONTROL ... NAU8824_REG_CHARGE_PUMP_INPUT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n\n}\n\nstatic bool nau8824_writeable_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8824_REG_RESET ... NAU8824_REG_FLL_VCO_RSV:\n\tcase NAU8824_REG_JACK_DET_CTRL:\n\tcase NAU8824_REG_INTERRUPT_SETTING_1:\n\tcase NAU8824_REG_CLEAR_INT_REG ... NAU8824_REG_VDET_THRESHOLD_4:\n\tcase NAU8824_REG_GPIO_SEL:\n\tcase NAU8824_REG_PORT0_I2S_PCM_CTRL_1 ... NAU8824_REG_TDM_CTRL:\n\tcase NAU8824_REG_ADC_HPF_FILTER ... NAU8824_REG_EQ4_EQ5:\n\tcase NAU8824_REG_ADC_CH0_DGAIN_CTRL ... NAU8824_REG_ADC_TO_DAC_ST:\n\tcase NAU8824_REG_DRC_KNEE_IP12_ADC_CH01:\n\tcase NAU8824_REG_DRC_KNEE_IP34_ADC_CH01:\n\tcase NAU8824_REG_DRC_SLOPE_ADC_CH01:\n\tcase NAU8824_REG_DRC_ATKDCY_ADC_CH01:\n\tcase NAU8824_REG_DRC_KNEE_IP12_ADC_CH23:\n\tcase NAU8824_REG_DRC_KNEE_IP34_ADC_CH23:\n\tcase NAU8824_REG_DRC_SLOPE_ADC_CH23:\n\tcase NAU8824_REG_DRC_ATKDCY_ADC_CH23:\n\tcase NAU8824_REG_DRC_KNEE_IP12_DAC ... NAU8824_REG_DRC_ATKDCY_DAC:\n\tcase NAU8824_REG_CLASSG ... NAU8824_REG_OTP_EFUSE:\n\tcase NAU8824_REG_I2C_TIMEOUT:\n\tcase NAU8824_REG_BIAS_ADJ ... NAU8824_REG_CLASSD_GAIN_2:\n\tcase NAU8824_REG_ANALOG_ADC_1 ... NAU8824_REG_ATT_PORT1:\n\tcase NAU8824_REG_POWER_UP_CONTROL ... NAU8824_REG_CHARGE_PUMP_CONTROL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool nau8824_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase NAU8824_REG_RESET:\n\tcase NAU8824_REG_IRQ ... NAU8824_REG_CLEAR_INT_REG:\n\tcase NAU8824_REG_DRC_GAINL_ADC0 ... NAU8824_REG_DRC_GAINL_ADC3:\n\tcase NAU8824_REG_DRC_GAIN_DAC_CH0 ... NAU8824_REG_DRC_GAIN_DAC_CH1:\n\tcase NAU8824_REG_OTPDOUT_1 ... NAU8824_REG_OTPDOUT_2:\n\tcase NAU8824_REG_I2C_DEVICE_ID ... NAU8824_REG_SAR_ADC_DATA_OUT:\n\tcase NAU8824_REG_CHARGE_PUMP_INPUT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const char * const nau8824_companding[] = {\n\t\"Off\", \"NC\", \"u-law\", \"A-law\" };\n\nstatic const struct soc_enum nau8824_companding_adc_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_PORT0_I2S_PCM_CTRL_1, 12,\n\t\tARRAY_SIZE(nau8824_companding), nau8824_companding);\n\nstatic const struct soc_enum nau8824_companding_dac_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_PORT0_I2S_PCM_CTRL_1, 14,\n\t\tARRAY_SIZE(nau8824_companding), nau8824_companding);\n\nstatic const char * const nau8824_adc_decimation[] = {\n\t\"32\", \"64\", \"128\", \"256\" };\n\nstatic const struct soc_enum nau8824_adc_decimation_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_ADC_FILTER_CTRL, 0,\n\t\tARRAY_SIZE(nau8824_adc_decimation), nau8824_adc_decimation);\n\nstatic const char * const nau8824_dac_oversampl[] = {\n\t\"64\", \"256\", \"128\", \"\", \"32\" };\n\nstatic const struct soc_enum nau8824_dac_oversampl_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_DAC_FILTER_CTRL_1, 0,\n\t\tARRAY_SIZE(nau8824_dac_oversampl), nau8824_dac_oversampl);\n\nstatic const char * const nau8824_input_channel[] = {\n\t\"Input CH0\", \"Input CH1\", \"Input CH2\", \"Input CH3\" };\n\nstatic const struct soc_enum nau8824_adc_ch0_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_ADC_CH0_DGAIN_CTRL, 9,\n\t\tARRAY_SIZE(nau8824_input_channel), nau8824_input_channel);\n\nstatic const struct soc_enum nau8824_adc_ch1_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_ADC_CH1_DGAIN_CTRL, 9,\n\t\tARRAY_SIZE(nau8824_input_channel), nau8824_input_channel);\n\nstatic const struct soc_enum nau8824_adc_ch2_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_ADC_CH2_DGAIN_CTRL, 9,\n\t\tARRAY_SIZE(nau8824_input_channel), nau8824_input_channel);\n\nstatic const struct soc_enum nau8824_adc_ch3_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_ADC_CH3_DGAIN_CTRL, 9,\n\t\tARRAY_SIZE(nau8824_input_channel), nau8824_input_channel);\n\nstatic const char * const nau8824_tdm_slot[] = {\n\t\"Slot 0\", \"Slot 1\", \"Slot 2\", \"Slot 3\" };\n\nstatic const struct soc_enum nau8824_dac_left_sel_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_TDM_CTRL, 6,\n\t\tARRAY_SIZE(nau8824_tdm_slot), nau8824_tdm_slot);\n\nstatic const struct soc_enum nau8824_dac_right_sel_enum =\n\tSOC_ENUM_SINGLE(NAU8824_REG_TDM_CTRL, 4,\n\t\tARRAY_SIZE(nau8824_tdm_slot), nau8824_tdm_slot);\n\nstatic const DECLARE_TLV_DB_MINMAX_MUTE(spk_vol_tlv, 0, 2400);\nstatic const DECLARE_TLV_DB_MINMAX(hp_vol_tlv, -3000, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, 0, 200, 0);\nstatic const DECLARE_TLV_DB_SCALE(dmic_vol_tlv, -12800, 50, 0);\n\nstatic const struct snd_kcontrol_new nau8824_snd_controls[] = {\n\tSOC_ENUM(\"ADC Companding\", nau8824_companding_adc_enum),\n\tSOC_ENUM(\"DAC Companding\", nau8824_companding_dac_enum),\n\n\tSOC_ENUM(\"ADC Decimation Rate\", nau8824_adc_decimation_enum),\n\tSOC_ENUM(\"DAC Oversampling Rate\", nau8824_dac_oversampl_enum),\n\n\tSOC_SINGLE_TLV(\"Speaker Right DACR Volume\",\n\t\tNAU8824_REG_CLASSD_GAIN_1, 8, 0x1f, 0, spk_vol_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Left DACL Volume\",\n\t\tNAU8824_REG_CLASSD_GAIN_2, 0, 0x1f, 0, spk_vol_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Left DACR Volume\",\n\t\tNAU8824_REG_CLASSD_GAIN_1, 0, 0x1f, 0, spk_vol_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Right DACL Volume\",\n\t\tNAU8824_REG_CLASSD_GAIN_2, 8, 0x1f, 0, spk_vol_tlv),\n\n\tSOC_SINGLE_TLV(\"Headphone Right DACR Volume\",\n\t\tNAU8824_REG_ATT_PORT0, 8, 0x1f, 0, hp_vol_tlv),\n\tSOC_SINGLE_TLV(\"Headphone Left DACL Volume\",\n\t\tNAU8824_REG_ATT_PORT0, 0, 0x1f, 0, hp_vol_tlv),\n\tSOC_SINGLE_TLV(\"Headphone Right DACL Volume\",\n\t\tNAU8824_REG_ATT_PORT1, 8, 0x1f, 0, hp_vol_tlv),\n\tSOC_SINGLE_TLV(\"Headphone Left DACR Volume\",\n\t\tNAU8824_REG_ATT_PORT1, 0, 0x1f, 0, hp_vol_tlv),\n\n\tSOC_SINGLE_TLV(\"MIC1 Volume\", NAU8824_REG_FEPGA_II,\n\t\tNAU8824_FEPGA_GAINL_SFT, 0x12, 0, mic_vol_tlv),\n\tSOC_SINGLE_TLV(\"MIC2 Volume\", NAU8824_REG_FEPGA_II,\n\t\tNAU8824_FEPGA_GAINR_SFT, 0x12, 0, mic_vol_tlv),\n\n\tSOC_SINGLE_TLV(\"DMIC1 Volume\", NAU8824_REG_ADC_CH0_DGAIN_CTRL,\n\t\t0, 0x164, 0, dmic_vol_tlv),\n\tSOC_SINGLE_TLV(\"DMIC2 Volume\", NAU8824_REG_ADC_CH1_DGAIN_CTRL,\n\t\t0, 0x164, 0, dmic_vol_tlv),\n\tSOC_SINGLE_TLV(\"DMIC3 Volume\", NAU8824_REG_ADC_CH2_DGAIN_CTRL,\n\t\t0, 0x164, 0, dmic_vol_tlv),\n\tSOC_SINGLE_TLV(\"DMIC4 Volume\", NAU8824_REG_ADC_CH3_DGAIN_CTRL,\n\t\t0, 0x164, 0, dmic_vol_tlv),\n\n\tSOC_ENUM(\"ADC CH0 Select\", nau8824_adc_ch0_enum),\n\tSOC_ENUM(\"ADC CH1 Select\", nau8824_adc_ch1_enum),\n\tSOC_ENUM(\"ADC CH2 Select\", nau8824_adc_ch2_enum),\n\tSOC_ENUM(\"ADC CH3 Select\", nau8824_adc_ch3_enum),\n\n\tSOC_SINGLE(\"ADC CH0 TX Switch\", NAU8824_REG_TDM_CTRL, 0, 1, 0),\n\tSOC_SINGLE(\"ADC CH1 TX Switch\", NAU8824_REG_TDM_CTRL, 1, 1, 0),\n\tSOC_SINGLE(\"ADC CH2 TX Switch\", NAU8824_REG_TDM_CTRL, 2, 1, 0),\n\tSOC_SINGLE(\"ADC CH3 TX Switch\", NAU8824_REG_TDM_CTRL, 3, 1, 0),\n\n\tSOC_ENUM(\"DACL Channel Source\", nau8824_dac_left_sel_enum),\n\tSOC_ENUM(\"DACR Channel Source\", nau8824_dac_right_sel_enum),\n\n\tSOC_SINGLE(\"DACL LR Mix\", NAU8824_REG_DAC_MUTE_CTRL, 0, 1, 0),\n\tSOC_SINGLE(\"DACR LR Mix\", NAU8824_REG_DAC_MUTE_CTRL, 1, 1, 0),\n\n\tSOC_SINGLE(\"THD for key media\",\n\t\tNAU8824_REG_VDET_THRESHOLD_1, 8, 0xff, 0),\n\tSOC_SINGLE(\"THD for key voice command\",\n\t\tNAU8824_REG_VDET_THRESHOLD_1, 0, 0xff, 0),\n\tSOC_SINGLE(\"THD for key volume up\",\n\t\tNAU8824_REG_VDET_THRESHOLD_2, 8, 0xff, 0),\n\tSOC_SINGLE(\"THD for key volume down\",\n\t\tNAU8824_REG_VDET_THRESHOLD_2, 0, 0xff, 0),\n};\n\nstatic int nau8824_output_dac_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\t \n\t\tregmap_update_bits(nau8824->regmap, NAU8824_REG_ENABLE_LO,\n\t\t\tNAU8824_TEST_DAC_EN, 0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8824->regmap, NAU8824_REG_ENABLE_LO,\n\t\t\tNAU8824_TEST_DAC_EN, NAU8824_TEST_DAC_EN);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8824_spk_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_ANALOG_CONTROL_2,\n\t\t\tNAU8824_CLASSD_CLAMP_DIS, NAU8824_CLASSD_CLAMP_DIS);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_ANALOG_CONTROL_2,\n\t\t\tNAU8824_CLASSD_CLAMP_DIS, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8824_pump_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\t \n\t\tmsleep(10);\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\t\tNAU8824_JAMNODCLOW, NAU8824_JAMNODCLOW);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\t\tNAU8824_JAMNODCLOW, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int system_clock_control(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tstruct regmap *regmap = nau8824->regmap;\n\tunsigned int value;\n\tbool clk_fll, error;\n\n\tif (SND_SOC_DAPM_EVENT_OFF(event)) {\n\t\tdev_dbg(nau8824->dev, \"system clock control : POWER OFF\\n\");\n\t\t \n\t\tif (nau8824_is_jack_inserted(nau8824)) {\n\t\t\tnau8824_config_sysclk(nau8824,\n\t\t\t\tNAU8824_CLK_INTERNAL, 0);\n\t\t} else {\n\t\t\tnau8824_config_sysclk(nau8824, NAU8824_CLK_DIS, 0);\n\t\t}\n\t} else {\n\t\tdev_dbg(nau8824->dev, \"system clock control : POWER ON\\n\");\n\t\t \n\t\tregmap_read(regmap, NAU8824_REG_FLL1, &value);\n\t\tclk_fll = value & NAU8824_FLL_RATIO_MASK;\n\t\t \n\t\tregmap_read(regmap, NAU8824_REG_FLL6, &value);\n\t\terror = value & NAU8824_DCO_EN;\n\t\tif (!error) {\n\t\t\t \n\t\t\tregmap_read(regmap, NAU8824_REG_CLK_DIVIDER, &value);\n\t\t\tif (clk_fll)\n\t\t\t\terror = !(value & NAU8824_CLK_SRC_VCO);\n\t\t\telse\n\t\t\t\terror = value & NAU8824_CLK_SRC_VCO;\n\t\t}\n\t\t \n\t\tif (error) {\n\t\t\tif (clk_fll) {\n\t\t\t\tregmap_update_bits(regmap,\n\t\t\t\t\tNAU8824_REG_FLL6, NAU8824_DCO_EN, 0);\n\t\t\t\tregmap_update_bits(regmap,\n\t\t\t\t\tNAU8824_REG_CLK_DIVIDER,\n\t\t\t\t\tNAU8824_CLK_SRC_MASK,\n\t\t\t\t\tNAU8824_CLK_SRC_VCO);\n\t\t\t} else {\n\t\t\t\tnau8824_config_sysclk(nau8824,\n\t\t\t\t\tNAU8824_CLK_MCLK, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dmic_clock_control(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *k, int  event)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tint src;\n\n\t \n\tfor (src = 0; src < 5; src++) {\n\t\tif ((0x1 << (8 - src)) * nau8824->fs <= DMIC_CLK)\n\t\t\tbreak;\n\t}\n\tdev_dbg(nau8824->dev, \"dmic src %d for mclk %d\\n\", src, nau8824->fs * 256);\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_CLK_DIVIDER,\n\t\tNAU8824_CLK_DMIC_SRC_MASK, (src << NAU8824_CLK_DMIC_SRC_SFT));\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new nau8824_adc_ch0_dmic =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_ADC_CH0_DMIC_SFT, 1, 0);\n\nstatic const struct snd_kcontrol_new nau8824_adc_ch1_dmic =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_ADC_CH1_DMIC_SFT, 1, 0);\n\nstatic const struct snd_kcontrol_new nau8824_adc_ch2_dmic =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_ADC_CH2_DMIC_SFT, 1, 0);\n\nstatic const struct snd_kcontrol_new nau8824_adc_ch3_dmic =\n\tSOC_DAPM_SINGLE(\"Switch\", NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_ADC_CH3_DMIC_SFT, 1, 0);\n\nstatic const struct snd_kcontrol_new nau8824_adc_left_mixer[] = {\n\tSOC_DAPM_SINGLE(\"MIC Switch\", NAU8824_REG_FEPGA,\n\t\tNAU8824_FEPGA_MODEL_MIC1_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"HSMIC Switch\", NAU8824_REG_FEPGA,\n\t\tNAU8824_FEPGA_MODEL_HSMIC_SFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8824_adc_right_mixer[] = {\n\tSOC_DAPM_SINGLE(\"MIC Switch\", NAU8824_REG_FEPGA,\n\t\tNAU8824_FEPGA_MODER_MIC2_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"HSMIC Switch\", NAU8824_REG_FEPGA,\n\t\tNAU8824_FEPGA_MODER_HSMIC_SFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8824_hp_left_mixer[] = {\n\tSOC_DAPM_SINGLE(\"DAC Right Switch\", NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_DACR_HPL_EN_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"DAC Left Switch\", NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_DACL_HPL_EN_SFT, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new nau8824_hp_right_mixer[] = {\n\tSOC_DAPM_SINGLE(\"DAC Left Switch\", NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_DACL_HPR_EN_SFT, 1, 0),\n\tSOC_DAPM_SINGLE(\"DAC Right Switch\", NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_DACR_HPR_EN_SFT, 1, 0),\n};\n\nstatic const char * const nau8824_dac_src[] = { \"DACL\", \"DACR\" };\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tnau8824_dacl_enum, NAU8824_REG_DAC_CH0_DGAIN_CTRL,\n\tNAU8824_DAC_CH0_SEL_SFT, nau8824_dac_src);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\tnau8824_dacr_enum, NAU8824_REG_DAC_CH1_DGAIN_CTRL,\n\tNAU8824_DAC_CH1_SEL_SFT, nau8824_dac_src);\n\nstatic const struct snd_kcontrol_new nau8824_dacl_mux =\n\tSOC_DAPM_ENUM(\"DACL Source\", nau8824_dacl_enum);\n\nstatic const struct snd_kcontrol_new nau8824_dacr_mux =\n\tSOC_DAPM_ENUM(\"DACR Source\", nau8824_dacr_enum);\n\n\nstatic const struct snd_soc_dapm_widget nau8824_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"System Clock\", SND_SOC_NOPM, 0, 0,\n\t\tsystem_clock_control, SND_SOC_DAPM_POST_PMD |\n\t\tSND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_INPUT(\"HSMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"HSMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"MIC1\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC3\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC4\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"SAR\", NAU8824_REG_SAR_ADC,\n\t\tNAU8824_SAR_ADC_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", NAU8824_REG_MIC_BIAS,\n\t\tNAU8824_MICBIAS_POWERUP_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC12 Power\", NAU8824_REG_BIAS_ADJ,\n\t\tNAU8824_DMIC1_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC34 Power\", NAU8824_REG_BIAS_ADJ,\n\t\tNAU8824_DMIC2_EN_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DMIC Clock\", SND_SOC_NOPM, 0, 0,\n\t\tdmic_clock_control, SND_SOC_DAPM_POST_PMU),\n\n\tSND_SOC_DAPM_SWITCH(\"DMIC1 Enable\", SND_SOC_NOPM,\n\t\t0, 0, &nau8824_adc_ch0_dmic),\n\tSND_SOC_DAPM_SWITCH(\"DMIC2 Enable\", SND_SOC_NOPM,\n\t\t0, 0, &nau8824_adc_ch1_dmic),\n\tSND_SOC_DAPM_SWITCH(\"DMIC3 Enable\", SND_SOC_NOPM,\n\t\t0, 0, &nau8824_adc_ch2_dmic),\n\tSND_SOC_DAPM_SWITCH(\"DMIC4 Enable\", SND_SOC_NOPM,\n\t\t0, 0, &nau8824_adc_ch3_dmic),\n\n\tSND_SOC_DAPM_MIXER(\"Left ADC\", NAU8824_REG_POWER_UP_CONTROL,\n\t\t12, 0, nau8824_adc_left_mixer,\n\t\tARRAY_SIZE(nau8824_adc_left_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right ADC\", NAU8824_REG_POWER_UP_CONTROL,\n\t\t13, 0, nau8824_adc_right_mixer,\n\t\tARRAY_SIZE(nau8824_adc_right_mixer)),\n\n\tSND_SOC_DAPM_ADC(\"ADCL\", NULL, NAU8824_REG_ANALOG_ADC_2,\n\t\tNAU8824_ADCL_EN_SFT, 0),\n\tSND_SOC_DAPM_ADC(\"ADCR\", NULL, NAU8824_REG_ANALOG_ADC_2,\n\t\tNAU8824_ADCR_EN_SFT, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIFTX\", \"Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFRX\", \"Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_DAC(\"DACL\", NULL, NAU8824_REG_RDAC,\n\t\tNAU8824_DACL_EN_SFT, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DACL Clock\", NAU8824_REG_RDAC,\n\t\tNAU8824_DACL_CLK_SFT, 0, NULL, 0),\n\tSND_SOC_DAPM_DAC(\"DACR\", NULL, NAU8824_REG_RDAC,\n\t\tNAU8824_DACR_EN_SFT, 0),\n\tSND_SOC_DAPM_SUPPLY(\"DACR Clock\", NAU8824_REG_RDAC,\n\t\tNAU8824_DACR_CLK_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_MUX(\"DACL Mux\", SND_SOC_NOPM, 0, 0, &nau8824_dacl_mux),\n\tSND_SOC_DAPM_MUX(\"DACR Mux\", SND_SOC_NOPM, 0, 0, &nau8824_dacr_mux),\n\n\tSND_SOC_DAPM_PGA_S(\"Output DACL\", 0, NAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\t8, 1, nau8824_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_PGA_S(\"Output DACR\", 0, NAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\t9, 1, nau8824_output_dac_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_PGA_S(\"ClassD\", 0, NAU8824_REG_CLASSD_GAIN_1,\n\t\tNAU8824_CLASSD_EN_SFT, 0, nau8824_spk_event,\n\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\n\tSND_SOC_DAPM_MIXER(\"Left Headphone\", NAU8824_REG_CLASSG,\n\t\tNAU8824_CLASSG_LDAC_EN_SFT, 0, nau8824_hp_left_mixer,\n\t\tARRAY_SIZE(nau8824_hp_left_mixer)),\n\tSND_SOC_DAPM_MIXER(\"Right Headphone\", NAU8824_REG_CLASSG,\n\t\tNAU8824_CLASSG_RDAC_EN_SFT, 0, nau8824_hp_right_mixer,\n\t\tARRAY_SIZE(nau8824_hp_right_mixer)),\n\tSND_SOC_DAPM_PGA_S(\"Charge Pump\", 1, NAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\tNAU8824_CHARGE_PUMP_EN_SFT, 0, nau8824_pump_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_PGA(\"Output Driver L\",\n\t\tNAU8824_REG_POWER_UP_CONTROL, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Output Driver R\",\n\t\tNAU8824_REG_POWER_UP_CONTROL, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Main Driver L\",\n\t\tNAU8824_REG_POWER_UP_CONTROL, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Main Driver R\",\n\t\tNAU8824_REG_POWER_UP_CONTROL, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"HP Boost Driver\", NAU8824_REG_BOOST,\n\t\tNAU8824_HP_BOOST_DIS_SFT, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Class G\", NAU8824_REG_CLASSG,\n\t\tNAU8824_CLASSG_EN_SFT, 0, NULL, 0),\n\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTL\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPKOUTR\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOL\"),\n\tSND_SOC_DAPM_OUTPUT(\"HPOR\"),\n};\n\nstatic const struct snd_soc_dapm_route nau8824_dapm_routes[] = {\n\t{\"DMIC1 Enable\", \"Switch\", \"DMIC1\"},\n\t{\"DMIC2 Enable\", \"Switch\", \"DMIC2\"},\n\t{\"DMIC3 Enable\", \"Switch\", \"DMIC3\"},\n\t{\"DMIC4 Enable\", \"Switch\", \"DMIC4\"},\n\n\t{\"DMIC1\", NULL, \"DMIC12 Power\"},\n\t{\"DMIC2\", NULL, \"DMIC12 Power\"},\n\t{\"DMIC3\", NULL, \"DMIC34 Power\"},\n\t{\"DMIC4\", NULL, \"DMIC34 Power\"},\n\t{\"DMIC12 Power\", NULL, \"DMIC Clock\"},\n\t{\"DMIC34 Power\", NULL, \"DMIC Clock\"},\n\n\t{\"Left ADC\", \"MIC Switch\", \"MIC1\"},\n\t{\"Left ADC\", \"HSMIC Switch\", \"HSMIC1\"},\n\t{\"Right ADC\", \"MIC Switch\", \"MIC2\"},\n\t{\"Right ADC\", \"HSMIC Switch\", \"HSMIC2\"},\n\n\t{\"ADCL\", NULL, \"Left ADC\"},\n\t{\"ADCR\", NULL, \"Right ADC\"},\n\n\t{\"AIFTX\", NULL, \"MICBIAS\"},\n\t{\"AIFTX\", NULL, \"ADCL\"},\n\t{\"AIFTX\", NULL, \"ADCR\"},\n\t{\"AIFTX\", NULL, \"DMIC1 Enable\"},\n\t{\"AIFTX\", NULL, \"DMIC2 Enable\"},\n\t{\"AIFTX\", NULL, \"DMIC3 Enable\"},\n\t{\"AIFTX\", NULL, \"DMIC4 Enable\"},\n\n\t{\"AIFTX\", NULL, \"System Clock\"},\n\t{\"AIFRX\", NULL, \"System Clock\"},\n\n\t{\"DACL\", NULL, \"AIFRX\"},\n\t{\"DACL\", NULL, \"DACL Clock\"},\n\t{\"DACR\", NULL, \"AIFRX\"},\n\t{\"DACR\", NULL, \"DACR Clock\"},\n\n\t{\"DACL Mux\", \"DACL\", \"DACL\"},\n\t{\"DACL Mux\", \"DACR\", \"DACR\"},\n\t{\"DACR Mux\", \"DACL\", \"DACL\"},\n\t{\"DACR Mux\", \"DACR\", \"DACR\"},\n\n\t{\"Output DACL\", NULL, \"DACL Mux\"},\n\t{\"Output DACR\", NULL, \"DACR Mux\"},\n\n\t{\"ClassD\", NULL, \"Output DACL\"},\n\t{\"ClassD\", NULL, \"Output DACR\"},\n\n\t{\"Left Headphone\", \"DAC Left Switch\", \"Output DACL\"},\n\t{\"Left Headphone\", \"DAC Right Switch\", \"Output DACR\"},\n\t{\"Right Headphone\", \"DAC Left Switch\", \"Output DACL\"},\n\t{\"Right Headphone\", \"DAC Right Switch\", \"Output DACR\"},\n\n\t{\"Charge Pump\", NULL, \"Left Headphone\"},\n\t{\"Charge Pump\", NULL, \"Right Headphone\"},\n\t{\"Output Driver L\", NULL, \"Charge Pump\"},\n\t{\"Output Driver R\", NULL, \"Charge Pump\"},\n\t{\"Main Driver L\", NULL, \"Output Driver L\"},\n\t{\"Main Driver R\", NULL, \"Output Driver R\"},\n\t{\"Class G\", NULL, \"Main Driver L\"},\n\t{\"Class G\", NULL, \"Main Driver R\"},\n\t{\"HP Boost Driver\", NULL, \"Class G\"},\n\n\t{\"SPKOUTL\", NULL, \"ClassD\"},\n\t{\"SPKOUTR\", NULL, \"ClassD\"},\n\t{\"HPOL\", NULL, \"HP Boost Driver\"},\n\t{\"HPOR\", NULL, \"HP Boost Driver\"},\n};\n\nstatic bool nau8824_is_jack_inserted(struct nau8824 *nau8824)\n{\n\tstruct snd_soc_jack *jack = nau8824->jack;\n\tbool insert = false;\n\n\tif (nau8824->irq && jack)\n\t\tinsert = jack->status & SND_JACK_HEADPHONE;\n\n\treturn insert;\n}\n\nstatic void nau8824_int_status_clear_all(struct regmap *regmap)\n{\n\tint active_irq, clear_irq, i;\n\n\t \n\tregmap_read(regmap, NAU8824_REG_IRQ, &active_irq);\n\tfor (i = 0; i < NAU8824_REG_DATA_LEN; i++) {\n\t\tclear_irq = (0x1 << i);\n\t\tif (active_irq & clear_irq)\n\t\t\tregmap_write(regmap,\n\t\t\t\tNAU8824_REG_CLEAR_INT_REG, clear_irq);\n\t}\n}\n\nstatic void nau8824_eject_jack(struct nau8824 *nau8824)\n{\n\tstruct snd_soc_dapm_context *dapm = nau8824->dapm;\n\tstruct regmap *regmap = nau8824->regmap;\n\n\t \n\tnau8824_int_status_clear_all(regmap);\n\n\tsnd_soc_dapm_disable_pin(dapm, \"SAR\");\n\tsnd_soc_dapm_disable_pin(dapm, \"MICBIAS\");\n\tsnd_soc_dapm_sync(dapm);\n\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_INTERRUPT_SETTING,\n\t\tNAU8824_IRQ_KEY_RELEASE_DIS | NAU8824_IRQ_KEY_SHORT_PRESS_DIS |\n\t\tNAU8824_IRQ_EJECT_DIS | NAU8824_IRQ_INSERT_DIS,\n\t\tNAU8824_IRQ_KEY_RELEASE_DIS | NAU8824_IRQ_KEY_SHORT_PRESS_DIS |\n\t\tNAU8824_IRQ_EJECT_DIS);\n\tregmap_update_bits(regmap, NAU8824_REG_INTERRUPT_SETTING_1,\n\t\tNAU8824_IRQ_INSERT_EN | NAU8824_IRQ_EJECT_EN,\n\t\tNAU8824_IRQ_INSERT_EN);\n\tregmap_update_bits(regmap, NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_JD_SLEEP_MODE, NAU8824_JD_SLEEP_MODE);\n\n\t \n\tif (dapm->bias_level < SND_SOC_BIAS_PREPARE)\n\t\tnau8824_config_sysclk(nau8824, NAU8824_CLK_DIS, 0);\n}\n\nstatic void nau8824_jdet_work(struct work_struct *work)\n{\n\tstruct nau8824 *nau8824 = container_of(\n\t\twork, struct nau8824, jdet_work);\n\tstruct snd_soc_dapm_context *dapm = nau8824->dapm;\n\tstruct regmap *regmap = nau8824->regmap;\n\tint adc_value, event = 0, event_mask = 0;\n\n\tsnd_soc_dapm_force_enable_pin(dapm, \"MICBIAS\");\n\tsnd_soc_dapm_force_enable_pin(dapm, \"SAR\");\n\tsnd_soc_dapm_sync(dapm);\n\n\tmsleep(100);\n\n\tregmap_read(regmap, NAU8824_REG_SAR_ADC_DATA_OUT, &adc_value);\n\tadc_value = adc_value & NAU8824_SAR_ADC_DATA_MASK;\n\tdev_dbg(nau8824->dev, \"SAR ADC data 0x%02x\\n\", adc_value);\n\tif (adc_value < HEADSET_SARADC_THD) {\n\t\tevent |= SND_JACK_HEADPHONE;\n\n\t\tsnd_soc_dapm_disable_pin(dapm, \"SAR\");\n\t\tsnd_soc_dapm_disable_pin(dapm, \"MICBIAS\");\n\t\tsnd_soc_dapm_sync(dapm);\n\t} else {\n\t\tevent |= SND_JACK_HEADSET;\n\t}\n\tevent_mask |= SND_JACK_HEADSET;\n\tsnd_soc_jack_report(nau8824->jack, event, event_mask);\n\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_INTERRUPT_SETTING,\n\t\tNAU8824_IRQ_KEY_RELEASE_DIS |\n\t\tNAU8824_IRQ_KEY_SHORT_PRESS_DIS, 0);\n\n\tif (nau8824->resume_lock) {\n\t\tnau8824_sema_release(nau8824);\n\t\tnau8824->resume_lock = false;\n\t}\n}\n\nstatic void nau8824_setup_auto_irq(struct nau8824 *nau8824)\n{\n\tstruct regmap *regmap = nau8824->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_INTERRUPT_SETTING_1,\n\t\tNAU8824_IRQ_INSERT_EN | NAU8824_IRQ_EJECT_EN,\n\t\tNAU8824_IRQ_EJECT_EN);\n\tregmap_update_bits(regmap, NAU8824_REG_INTERRUPT_SETTING,\n\t\tNAU8824_IRQ_EJECT_DIS, 0);\n\t \n\tif (nau8824->dapm->bias_level < SND_SOC_BIAS_PREPARE)\n\t\tnau8824_config_sysclk(nau8824, NAU8824_CLK_INTERNAL, 0);\n\tregmap_update_bits(regmap, NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_JD_SLEEP_MODE, 0);\n}\n\nstatic int nau8824_button_decode(int value)\n{\n\tint buttons = 0;\n\n\t \n\tif (value & BIT(0))\n\t\tbuttons |= SND_JACK_BTN_0;\n\tif (value & BIT(1))\n\t\tbuttons |= SND_JACK_BTN_1;\n\tif (value & BIT(2))\n\t\tbuttons |= SND_JACK_BTN_2;\n\tif (value & BIT(3))\n\t\tbuttons |= SND_JACK_BTN_3;\n\tif (value & BIT(4))\n\t\tbuttons |= SND_JACK_BTN_4;\n\tif (value & BIT(5))\n\t\tbuttons |= SND_JACK_BTN_5;\n\n\treturn buttons;\n}\n\n#define NAU8824_BUTTONS (SND_JACK_BTN_0 | SND_JACK_BTN_1 | \\\n\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3)\n\nstatic irqreturn_t nau8824_interrupt(int irq, void *data)\n{\n\tstruct nau8824 *nau8824 = (struct nau8824 *)data;\n\tstruct regmap *regmap = nau8824->regmap;\n\tint active_irq, clear_irq = 0, event = 0, event_mask = 0;\n\n\tif (regmap_read(regmap, NAU8824_REG_IRQ, &active_irq)) {\n\t\tdev_err(nau8824->dev, \"failed to read irq status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\tdev_dbg(nau8824->dev, \"IRQ %x\\n\", active_irq);\n\n\tif (active_irq & NAU8824_JACK_EJECTION_DETECTED) {\n\t\tnau8824_eject_jack(nau8824);\n\t\tevent_mask |= SND_JACK_HEADSET;\n\t\tclear_irq = NAU8824_JACK_EJECTION_DETECTED;\n\t\t \n\t\tif (nau8824->resume_lock) {\n\t\t\tnau8824_sema_release(nau8824);\n\t\t\tnau8824->resume_lock = false;\n\t\t}\n\t\tcancel_work_sync(&nau8824->jdet_work);\n\t} else if (active_irq & NAU8824_KEY_SHORT_PRESS_IRQ) {\n\t\tint key_status, button_pressed;\n\n\t\tregmap_read(regmap, NAU8824_REG_CLEAR_INT_REG,\n\t\t\t&key_status);\n\n\t\t \n\t\tbutton_pressed = nau8824_button_decode(key_status);\n\n\t\tevent |= button_pressed;\n\t\tdev_dbg(nau8824->dev, \"button %x pressed\\n\", event);\n\t\tevent_mask |= NAU8824_BUTTONS;\n\t\tclear_irq = NAU8824_KEY_SHORT_PRESS_IRQ;\n\t} else if (active_irq & NAU8824_KEY_RELEASE_IRQ) {\n\t\tevent_mask = NAU8824_BUTTONS;\n\t\tclear_irq = NAU8824_KEY_RELEASE_IRQ;\n\t} else if (active_irq & NAU8824_JACK_INSERTION_DETECTED) {\n\t\t \n\t\tregmap_update_bits(regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING,\n\t\t\tNAU8824_IRQ_INSERT_DIS,\n\t\t\tNAU8824_IRQ_INSERT_DIS);\n\t\tregmap_update_bits(regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING_1,\n\t\t\tNAU8824_IRQ_INSERT_EN, 0);\n\t\t \n\t\tcancel_work_sync(&nau8824->jdet_work);\n\t\tschedule_work(&nau8824->jdet_work);\n\n\t\t \n\t\tnau8824_setup_auto_irq(nau8824);\n\t}\n\n\tif (!clear_irq)\n\t\tclear_irq = active_irq;\n\t \n\tregmap_write(regmap, NAU8824_REG_CLEAR_INT_REG, clear_irq);\n\n\tif (event_mask)\n\t\tsnd_soc_jack_report(nau8824->jack, event, event_mask);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct nau8824_osr_attr *\nnau8824_get_osr(struct nau8824 *nau8824, int stream)\n{\n\tunsigned int osr;\n\n\tif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tregmap_read(nau8824->regmap,\n\t\t\t    NAU8824_REG_DAC_FILTER_CTRL_1, &osr);\n\t\tosr &= NAU8824_DAC_OVERSAMPLE_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_dac_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_dac_sel[osr];\n\t} else {\n\t\tregmap_read(nau8824->regmap,\n\t\t\t    NAU8824_REG_ADC_FILTER_CTRL, &osr);\n\t\tosr &= NAU8824_ADC_SYNC_DOWN_MASK;\n\t\tif (osr >= ARRAY_SIZE(osr_adc_sel))\n\t\t\treturn NULL;\n\t\treturn &osr_adc_sel[osr];\n\t}\n}\n\nstatic int nau8824_dai_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tconst struct nau8824_osr_attr *osr;\n\n\tosr = nau8824_get_osr(nau8824, substream->stream);\n\tif (!osr || !osr->osr)\n\t\treturn -EINVAL;\n\n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\t\t\t\t    SNDRV_PCM_HW_PARAM_RATE,\n\t\t\t\t\t    0, CLK_DA_AD_MAX / osr->osr);\n}\n\nstatic int nau8824_hw_params(struct snd_pcm_substream *substream,\n\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tunsigned int val_len = 0, ctrl_val, bclk_fs, bclk_div;\n\tconst struct nau8824_osr_attr *osr;\n\tint err = -EINVAL;\n\n\tnau8824_sema_acquire(nau8824, HZ);\n\n\t \n\tnau8824->fs = params_rate(params);\n\tosr = nau8824_get_osr(nau8824, substream->stream);\n\tif (!osr || !osr->osr)\n\t\tgoto error;\n\tif (nau8824->fs * osr->osr > CLK_DA_AD_MAX)\n\t\tgoto error;\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tregmap_update_bits(nau8824->regmap, NAU8824_REG_CLK_DIVIDER,\n\t\t\tNAU8824_CLK_DAC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8824_CLK_DAC_SRC_SFT);\n\telse\n\t\tregmap_update_bits(nau8824->regmap, NAU8824_REG_CLK_DIVIDER,\n\t\t\tNAU8824_CLK_ADC_SRC_MASK,\n\t\t\tosr->clk_src << NAU8824_CLK_ADC_SRC_SFT);\n\n\t \n\tregmap_read(nau8824->regmap,\n\t\tNAU8824_REG_PORT0_I2S_PCM_CTRL_2, &ctrl_val);\n\tif (ctrl_val & NAU8824_I2S_MS_MASTER) {\n\t\t \n\t\tbclk_fs = snd_soc_params_to_bclk(params) / nau8824->fs;\n\t\tif (bclk_fs <= 32)\n\t\t\tbclk_div = 0x3;\n\t\telse if (bclk_fs <= 64)\n\t\t\tbclk_div = 0x2;\n\t\telse if (bclk_fs <= 128)\n\t\t\tbclk_div = 0x1;\n\t\telse if (bclk_fs <= 256)\n\t\t\tbclk_div = 0;\n\t\telse\n\t\t\tgoto error;\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_PORT0_I2S_PCM_CTRL_2,\n\t\t\tNAU8824_I2S_LRC_DIV_MASK | NAU8824_I2S_BLK_DIV_MASK,\n\t\t\t(bclk_div << NAU8824_I2S_LRC_DIV_SFT) | bclk_div);\n\t}\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval_len |= NAU8824_I2S_DL_16;\n\t\tbreak;\n\tcase 20:\n\t\tval_len |= NAU8824_I2S_DL_20;\n\t\tbreak;\n\tcase 24:\n\t\tval_len |= NAU8824_I2S_DL_24;\n\t\tbreak;\n\tcase 32:\n\t\tval_len |= NAU8824_I2S_DL_32;\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_PORT0_I2S_PCM_CTRL_1,\n\t\tNAU8824_I2S_DL_MASK, val_len);\n\terr = 0;\n\n error:\n\tnau8824_sema_release(nau8824);\n\n\treturn err;\n}\n\nstatic int nau8824_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tunsigned int ctrl1_val = 0, ctrl2_val = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tctrl2_val |= NAU8824_I2S_MS_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tctrl1_val |= NAU8824_I2S_BP_INV;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tctrl1_val |= NAU8824_I2S_DF_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tctrl1_val |= NAU8824_I2S_DF_LEFT;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tctrl1_val |= NAU8824_I2S_DF_RIGTH;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tctrl1_val |= NAU8824_I2S_DF_PCM_AB;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tctrl1_val |= NAU8824_I2S_DF_PCM_AB;\n\t\tctrl1_val |= NAU8824_I2S_PCMB_EN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnau8824_sema_acquire(nau8824, HZ);\n\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_PORT0_I2S_PCM_CTRL_1,\n\t\tNAU8824_I2S_DF_MASK | NAU8824_I2S_BP_MASK |\n\t\tNAU8824_I2S_PCMB_EN, ctrl1_val);\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_PORT0_I2S_PCM_CTRL_2,\n\t\tNAU8824_I2S_MS_MASK, ctrl2_val);\n\n\tnau8824_sema_release(nau8824);\n\n\treturn 0;\n}\n\n \nstatic int nau8824_set_tdm_slot(struct snd_soc_dai *dai,\n\tunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tunsigned int tslot_l = 0, ctrl_val = 0;\n\n\tif (slots > 4 || ((tx_mask & 0xf0) && (tx_mask & 0xf)) ||\n\t\t((rx_mask & 0xf0) && (rx_mask & 0xf)) ||\n\t\t((rx_mask & 0xf0) && (tx_mask & 0xf)) ||\n\t\t((rx_mask & 0xf) && (tx_mask & 0xf0)))\n\t\treturn -EINVAL;\n\n\tctrl_val |= (NAU8824_TDM_MODE | NAU8824_TDM_OFFSET_EN);\n\tif (tx_mask & 0xf0) {\n\t\ttslot_l = 4 * slot_width;\n\t\tctrl_val |= (tx_mask >> 4);\n\t} else {\n\t\tctrl_val |= tx_mask;\n\t}\n\tif (rx_mask & 0xf0)\n\t\tctrl_val |= ((rx_mask >> 4) << NAU8824_TDM_DACR_RX_SFT);\n\telse\n\t\tctrl_val |= (rx_mask << NAU8824_TDM_DACR_RX_SFT);\n\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_TDM_CTRL,\n\t\tNAU8824_TDM_MODE | NAU8824_TDM_OFFSET_EN |\n\t\tNAU8824_TDM_DACL_RX_MASK | NAU8824_TDM_DACR_RX_MASK |\n\t\tNAU8824_TDM_TX_MASK, ctrl_val);\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_PORT0_LEFT_TIME_SLOT,\n\t\tNAU8824_TSLOT_L_MASK, tslot_l);\n\n\treturn 0;\n}\n\n \nstatic int nau8824_calc_fll_param(unsigned int fll_in,\n\tunsigned int fs, struct nau8824_fll *fll_param)\n{\n\tu64 fvco, fvco_max;\n\tunsigned int fref, i, fvco_sel;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_pre_scalar); i++) {\n\t\tfref = fll_in / fll_pre_scalar[i].param;\n\t\tif (fref <= NAU_FREF_MAX)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_pre_scalar))\n\t\treturn -EINVAL;\n\tfll_param->clk_ref_div = fll_pre_scalar[i].val;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fll_ratio); i++) {\n\t\tif (fref >= fll_ratio[i].param)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fll_ratio))\n\t\treturn -EINVAL;\n\tfll_param->ratio = fll_ratio[i].val;\n\n\t \n\tfvco_max = 0;\n\tfvco_sel = ARRAY_SIZE(mclk_src_scaling);\n\tfor (i = 0; i < ARRAY_SIZE(mclk_src_scaling); i++) {\n\t\tfvco = 256ULL * fs * 2 * mclk_src_scaling[i].param;\n\t\tif (fvco > NAU_FVCO_MIN && fvco < NAU_FVCO_MAX &&\n\t\t\tfvco_max < fvco) {\n\t\t\tfvco_max = fvco;\n\t\t\tfvco_sel = i;\n\t\t}\n\t}\n\tif (ARRAY_SIZE(mclk_src_scaling) == fvco_sel)\n\t\treturn -EINVAL;\n\tfll_param->mclk_src = mclk_src_scaling[fvco_sel].val;\n\n\t \n\tfvco = div_u64(fvco_max << 16, fref * fll_param->ratio);\n\tfll_param->fll_int = (fvco >> 16) & 0x3FF;\n\tfll_param->fll_frac = fvco & 0xFFFF;\n\treturn 0;\n}\n\nstatic void nau8824_fll_apply(struct regmap *regmap,\n\tstruct nau8824_fll *fll_param)\n{\n\tregmap_update_bits(regmap, NAU8824_REG_CLK_DIVIDER,\n\t\tNAU8824_CLK_SRC_MASK | NAU8824_CLK_MCLK_SRC_MASK,\n\t\tNAU8824_CLK_SRC_MCLK | fll_param->mclk_src);\n\tregmap_update_bits(regmap, NAU8824_REG_FLL1,\n\t\tNAU8824_FLL_RATIO_MASK, fll_param->ratio);\n\t \n\tregmap_write(regmap, NAU8824_REG_FLL2, fll_param->fll_frac);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_FLL3,\n\t\tNAU8824_FLL_INTEGER_MASK, fll_param->fll_int);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_FLL4,\n\t\tNAU8824_FLL_REF_DIV_MASK,\n\t\tfll_param->clk_ref_div << NAU8824_FLL_REF_DIV_SFT);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_FLL5,\n\t\tNAU8824_FLL_CLK_SW_MASK, NAU8824_FLL_CLK_SW_REF);\n\t \n\tregmap_update_bits(regmap,\n\t\tNAU8824_REG_FLL6, NAU8824_DCO_EN, 0);\n\tif (fll_param->fll_frac) {\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL5,\n\t\t\tNAU8824_FLL_PDB_DAC_EN | NAU8824_FLL_LOOP_FTR_EN |\n\t\t\tNAU8824_FLL_FTR_SW_MASK,\n\t\t\tNAU8824_FLL_PDB_DAC_EN | NAU8824_FLL_LOOP_FTR_EN |\n\t\t\tNAU8824_FLL_FTR_SW_FILTER);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL6,\n\t\t\tNAU8824_SDM_EN, NAU8824_SDM_EN);\n\t} else {\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL5,\n\t\t\tNAU8824_FLL_PDB_DAC_EN | NAU8824_FLL_LOOP_FTR_EN |\n\t\t\tNAU8824_FLL_FTR_SW_MASK, NAU8824_FLL_FTR_SW_ACCU);\n\t\tregmap_update_bits(regmap,\n\t\t\tNAU8824_REG_FLL6, NAU8824_SDM_EN, 0);\n\t}\n}\n\n \nstatic int nau8824_set_pll(struct snd_soc_component *component, int pll_id, int source,\n\t\tunsigned int freq_in, unsigned int freq_out)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tstruct nau8824_fll fll_param;\n\tint ret, fs;\n\n\tfs = freq_out / 256;\n\tret = nau8824_calc_fll_param(freq_in, fs, &fll_param);\n\tif (ret < 0) {\n\t\tdev_err(nau8824->dev, \"Unsupported input clock %d\\n\", freq_in);\n\t\treturn ret;\n\t}\n\tdev_dbg(nau8824->dev, \"mclk_src=%x ratio=%x fll_frac=%x fll_int=%x clk_ref_div=%x\\n\",\n\t\tfll_param.mclk_src, fll_param.ratio, fll_param.fll_frac,\n\t\tfll_param.fll_int, fll_param.clk_ref_div);\n\n\tnau8824_fll_apply(nau8824->regmap, &fll_param);\n\tmdelay(2);\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_CLK_DIVIDER,\n\t\tNAU8824_CLK_SRC_MASK, NAU8824_CLK_SRC_VCO);\n\n\treturn 0;\n}\n\nstatic int nau8824_config_sysclk(struct nau8824 *nau8824,\n\tint clk_id, unsigned int freq)\n{\n\tstruct regmap *regmap = nau8824->regmap;\n\n\tswitch (clk_id) {\n\tcase NAU8824_CLK_DIS:\n\t\tregmap_update_bits(regmap, NAU8824_REG_CLK_DIVIDER,\n\t\t\tNAU8824_CLK_SRC_MASK, NAU8824_CLK_SRC_MCLK);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL6,\n\t\t\tNAU8824_DCO_EN, 0);\n\t\tbreak;\n\n\tcase NAU8824_CLK_MCLK:\n\t\tnau8824_sema_acquire(nau8824, HZ);\n\t\tregmap_update_bits(regmap, NAU8824_REG_CLK_DIVIDER,\n\t\t\tNAU8824_CLK_SRC_MASK, NAU8824_CLK_SRC_MCLK);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL6,\n\t\t\tNAU8824_DCO_EN, 0);\n\t\tnau8824_sema_release(nau8824);\n\t\tbreak;\n\n\tcase NAU8824_CLK_INTERNAL:\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL6,\n\t\t\tNAU8824_DCO_EN, NAU8824_DCO_EN);\n\t\tregmap_update_bits(regmap, NAU8824_REG_CLK_DIVIDER,\n\t\t\tNAU8824_CLK_SRC_MASK, NAU8824_CLK_SRC_VCO);\n\t\tbreak;\n\n\tcase NAU8824_CLK_FLL_MCLK:\n\t\tnau8824_sema_acquire(nau8824, HZ);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL3,\n\t\t\tNAU8824_FLL_CLK_SRC_MASK, NAU8824_FLL_CLK_SRC_MCLK);\n\t\tnau8824_sema_release(nau8824);\n\t\tbreak;\n\n\tcase NAU8824_CLK_FLL_BLK:\n\t\tnau8824_sema_acquire(nau8824, HZ);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL3,\n\t\t\tNAU8824_FLL_CLK_SRC_MASK, NAU8824_FLL_CLK_SRC_BLK);\n\t\tnau8824_sema_release(nau8824);\n\t\tbreak;\n\n\tcase NAU8824_CLK_FLL_FS:\n\t\tnau8824_sema_acquire(nau8824, HZ);\n\t\tregmap_update_bits(regmap, NAU8824_REG_FLL3,\n\t\t\tNAU8824_FLL_CLK_SRC_MASK, NAU8824_FLL_CLK_SRC_FS);\n\t\tnau8824_sema_release(nau8824);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(nau8824->dev, \"Invalid clock id (%d)\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(nau8824->dev, \"Sysclk is %dHz and clock id is %d\\n\", freq,\n\t\tclk_id);\n\n\treturn 0;\n}\n\nstatic int nau8824_set_sysclk(struct snd_soc_component *component,\n\tint clk_id, int source, unsigned int freq, int dir)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\treturn nau8824_config_sysclk(nau8824, clk_id, freq);\n}\n\nstatic void nau8824_resume_setup(struct nau8824 *nau8824)\n{\n\tnau8824_config_sysclk(nau8824, NAU8824_CLK_DIS, 0);\n\tif (nau8824->irq) {\n\t\t \n\t\tnau8824_int_status_clear_all(nau8824->regmap);\n\t\t \n\t\tregmap_update_bits(nau8824->regmap, NAU8824_REG_ENA_CTRL,\n\t\t\tNAU8824_JD_SLEEP_MODE, NAU8824_JD_SLEEP_MODE);\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING_1,\n\t\t\tNAU8824_IRQ_EJECT_EN | NAU8824_IRQ_INSERT_EN,\n\t\t\tNAU8824_IRQ_EJECT_EN | NAU8824_IRQ_INSERT_EN);\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING,\n\t\t\tNAU8824_IRQ_EJECT_DIS | NAU8824_IRQ_INSERT_DIS, 0);\n\t}\n}\n\nstatic int nau8824_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tnau8824_resume_setup(nau8824);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING, 0x3ff, 0x3ff);\n\t\tregmap_update_bits(nau8824->regmap,\n\t\t\tNAU8824_REG_INTERRUPT_SETTING_1,\n\t\t\tNAU8824_IRQ_EJECT_EN | NAU8824_IRQ_INSERT_EN, 0);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nau8824_component_probe(struct snd_soc_component *component)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tnau8824->dapm = dapm;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8824_suspend(struct snd_soc_component *component)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\n\tif (nau8824->irq) {\n\t\tdisable_irq(nau8824->irq);\n\t\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);\n\t}\n\tregcache_cache_only(nau8824->regmap, true);\n\tregcache_mark_dirty(nau8824->regmap);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused nau8824_resume(struct snd_soc_component *component)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tregcache_cache_only(nau8824->regmap, false);\n\tregcache_sync(nau8824->regmap);\n\tif (nau8824->irq) {\n\t\t \n\t\tnau8824->resume_lock = true;\n\t\tret = nau8824_sema_acquire(nau8824, 0);\n\t\tif (ret)\n\t\t\tnau8824->resume_lock = false;\n\t\tenable_irq(nau8824->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver nau8824_component_driver = {\n\t.probe\t\t\t= nau8824_component_probe,\n\t.set_sysclk\t\t= nau8824_set_sysclk,\n\t.set_pll\t\t= nau8824_set_pll,\n\t.set_bias_level\t\t= nau8824_set_bias_level,\n\t.suspend\t\t= nau8824_suspend,\n\t.resume\t\t\t= nau8824_resume,\n\t.controls\t\t= nau8824_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(nau8824_snd_controls),\n\t.dapm_widgets\t\t= nau8824_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(nau8824_dapm_widgets),\n\t.dapm_routes\t\t= nau8824_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(nau8824_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct snd_soc_dai_ops nau8824_dai_ops = {\n\t.startup = nau8824_dai_startup,\n\t.hw_params = nau8824_hw_params,\n\t.set_fmt = nau8824_set_fmt,\n\t.set_tdm_slot = nau8824_set_tdm_slot,\n};\n\n#define NAU8824_RATES SNDRV_PCM_RATE_8000_192000\n#define NAU8824_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE \\\n\t | SNDRV_PCM_FMTBIT_S24_3LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic struct snd_soc_dai_driver nau8824_dai = {\n\t.name = NAU8824_CODEC_DAI,\n\t.playback = {\n\t\t.stream_name\t = \"Playback\",\n\t\t.channels_min\t = 1,\n\t\t.channels_max\t = 2,\n\t\t.rates\t\t = NAU8824_RATES,\n\t\t.formats\t = NAU8824_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name\t = \"Capture\",\n\t\t.channels_min\t = 1,\n\t\t.channels_max\t = 2,\n\t\t.rates\t\t = NAU8824_RATES,\n\t\t.formats\t = NAU8824_FORMATS,\n\t},\n\t.ops = &nau8824_dai_ops,\n};\n\nstatic const struct regmap_config nau8824_regmap_config = {\n\t.val_bits = NAU8824_REG_ADDR_LEN,\n\t.reg_bits = NAU8824_REG_DATA_LEN,\n\n\t.max_register = NAU8824_REG_MAX,\n\t.readable_reg = nau8824_readable_reg,\n\t.writeable_reg = nau8824_writeable_reg,\n\t.volatile_reg = nau8824_volatile_reg,\n\n\t.cache_type = REGCACHE_RBTREE,\n\t.reg_defaults = nau8824_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(nau8824_reg_defaults),\n};\n\n \nint nau8824_enable_jack_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *jack)\n{\n\tstruct nau8824 *nau8824 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tnau8824->jack = jack;\n\t \n\tINIT_WORK(&nau8824->jdet_work, nau8824_jdet_work);\n\tret = devm_request_threaded_irq(nau8824->dev, nau8824->irq, NULL,\n\t\tnau8824_interrupt, IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\"nau8824\", nau8824);\n\tif (ret) {\n\t\tdev_err(nau8824->dev, \"Cannot request irq %d (%d)\\n\",\n\t\t\tnau8824->irq, ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(nau8824_enable_jack_detect);\n\nstatic void nau8824_reset_chip(struct regmap *regmap)\n{\n\tregmap_write(regmap, NAU8824_REG_RESET, 0x00);\n\tregmap_write(regmap, NAU8824_REG_RESET, 0x00);\n}\n\nstatic void nau8824_setup_buttons(struct nau8824 *nau8824)\n{\n\tstruct regmap *regmap = nau8824->regmap;\n\n\tregmap_update_bits(regmap, NAU8824_REG_SAR_ADC,\n\t\tNAU8824_SAR_TRACKING_GAIN_MASK,\n\t\tnau8824->sar_voltage << NAU8824_SAR_TRACKING_GAIN_SFT);\n\tregmap_update_bits(regmap, NAU8824_REG_SAR_ADC,\n\t\tNAU8824_SAR_COMPARE_TIME_MASK,\n\t\tnau8824->sar_compare_time << NAU8824_SAR_COMPARE_TIME_SFT);\n\tregmap_update_bits(regmap, NAU8824_REG_SAR_ADC,\n\t\tNAU8824_SAR_SAMPLING_TIME_MASK,\n\t\tnau8824->sar_sampling_time << NAU8824_SAR_SAMPLING_TIME_SFT);\n\n\tregmap_update_bits(regmap, NAU8824_REG_VDET_COEFFICIENT,\n\t\tNAU8824_LEVELS_NR_MASK,\n\t\t(nau8824->sar_threshold_num - 1) << NAU8824_LEVELS_NR_SFT);\n\tregmap_update_bits(regmap, NAU8824_REG_VDET_COEFFICIENT,\n\t\tNAU8824_HYSTERESIS_MASK,\n\t\tnau8824->sar_hysteresis << NAU8824_HYSTERESIS_SFT);\n\tregmap_update_bits(regmap, NAU8824_REG_VDET_COEFFICIENT,\n\t\tNAU8824_SHORTKEY_DEBOUNCE_MASK,\n\t\tnau8824->key_debounce << NAU8824_SHORTKEY_DEBOUNCE_SFT);\n\n\tregmap_write(regmap, NAU8824_REG_VDET_THRESHOLD_1,\n\t\t(nau8824->sar_threshold[0] << 8) | nau8824->sar_threshold[1]);\n\tregmap_write(regmap, NAU8824_REG_VDET_THRESHOLD_2,\n\t\t(nau8824->sar_threshold[2] << 8) | nau8824->sar_threshold[3]);\n\tregmap_write(regmap, NAU8824_REG_VDET_THRESHOLD_3,\n\t\t(nau8824->sar_threshold[4] << 8) | nau8824->sar_threshold[5]);\n\tregmap_write(regmap, NAU8824_REG_VDET_THRESHOLD_4,\n\t\t(nau8824->sar_threshold[6] << 8) | nau8824->sar_threshold[7]);\n}\n\nstatic void nau8824_init_regs(struct nau8824 *nau8824)\n{\n\tstruct regmap *regmap = nau8824->regmap;\n\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_BIAS_ADJ,\n\t\tNAU8824_VMID | NAU8824_VMID_SEL_MASK, NAU8824_VMID |\n\t\t(nau8824->vref_impedance << NAU8824_VMID_SEL_SFT));\n\tregmap_update_bits(regmap, NAU8824_REG_BOOST,\n\t\tNAU8824_GLOBAL_BIAS_EN, NAU8824_GLOBAL_BIAS_EN);\n\tmdelay(2);\n\tregmap_update_bits(regmap, NAU8824_REG_MIC_BIAS,\n\t\tNAU8824_MICBIAS_VOLTAGE_MASK, nau8824->micbias_voltage);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_BOOST,\n\t\tNAU8824_PRECHARGE_DIS | NAU8824_HP_BOOST_DIS |\n\t\tNAU8824_HP_BOOST_G_DIS | NAU8824_SHORT_SHUTDOWN_EN,\n\t\tNAU8824_PRECHARGE_DIS | NAU8824_HP_BOOST_DIS |\n\t\tNAU8824_HP_BOOST_G_DIS | NAU8824_SHORT_SHUTDOWN_EN);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_CLK_DIVIDER,\n\t\tNAU8824_CLK_ADC_SRC_MASK | NAU8824_CLK_DAC_SRC_MASK,\n\t\t(0x1 << NAU8824_CLK_ADC_SRC_SFT) |\n\t\t(0x1 << NAU8824_CLK_DAC_SRC_SFT));\n\tregmap_update_bits(regmap, NAU8824_REG_DAC_MUTE_CTRL,\n\t\tNAU8824_DAC_ZC_EN, NAU8824_DAC_ZC_EN);\n\tregmap_update_bits(regmap, NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_DAC_CH1_EN | NAU8824_DAC_CH0_EN |\n\t\tNAU8824_ADC_CH0_EN | NAU8824_ADC_CH1_EN |\n\t\tNAU8824_ADC_CH2_EN | NAU8824_ADC_CH3_EN,\n\t\tNAU8824_DAC_CH1_EN | NAU8824_DAC_CH0_EN |\n\t\tNAU8824_ADC_CH0_EN | NAU8824_ADC_CH1_EN |\n\t\tNAU8824_ADC_CH2_EN | NAU8824_ADC_CH3_EN);\n\tregmap_update_bits(regmap, NAU8824_REG_CLK_GATING_ENA,\n\t\tNAU8824_CLK_ADC_CH23_EN | NAU8824_CLK_ADC_CH01_EN |\n\t\tNAU8824_CLK_DAC_CH1_EN | NAU8824_CLK_DAC_CH0_EN |\n\t\tNAU8824_CLK_I2S_EN | NAU8824_CLK_GAIN_EN |\n\t\tNAU8824_CLK_SAR_EN | NAU8824_CLK_DMIC_CH23_EN,\n\t\tNAU8824_CLK_ADC_CH23_EN | NAU8824_CLK_ADC_CH01_EN |\n\t\tNAU8824_CLK_DAC_CH1_EN | NAU8824_CLK_DAC_CH0_EN |\n\t\tNAU8824_CLK_I2S_EN | NAU8824_CLK_GAIN_EN |\n\t\tNAU8824_CLK_SAR_EN | NAU8824_CLK_DMIC_CH23_EN);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_CLASSG,\n\t\tNAU8824_CLASSG_TIMER_MASK,\n\t\t0x20 << NAU8824_CLASSG_TIMER_SFT);\n\tregmap_update_bits(regmap, NAU8824_REG_TRIM_SETTINGS,\n\t\tNAU8824_DRV_CURR_INC, NAU8824_DRV_CURR_INC);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_CHARGE_PUMP_CONTROL,\n\t\tNAU8824_SPKR_PULL_DOWN | NAU8824_SPKL_PULL_DOWN |\n\t\tNAU8824_POWER_DOWN_DACR | NAU8824_POWER_DOWN_DACL,\n\t\tNAU8824_SPKR_PULL_DOWN | NAU8824_SPKL_PULL_DOWN |\n\t\tNAU8824_POWER_DOWN_DACR | NAU8824_POWER_DOWN_DACL);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_TEST_DAC_EN, NAU8824_TEST_DAC_EN);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_DAC_CH0_DGAIN_CTRL,\n\t\tNAU8824_DAC_CH0_SEL_MASK, NAU8824_DAC_CH0_SEL_I2S0);\n\tregmap_update_bits(regmap, NAU8824_REG_DAC_CH1_DGAIN_CTRL,\n\t\tNAU8824_DAC_CH1_SEL_MASK, NAU8824_DAC_CH1_SEL_I2S1);\n\tregmap_update_bits(regmap, NAU8824_REG_ENABLE_LO,\n\t\tNAU8824_DACR_HPR_EN | NAU8824_DACL_HPL_EN,\n\t\tNAU8824_DACR_HPR_EN | NAU8824_DACL_HPL_EN);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_ADC_FILTER_CTRL,\n\t\tNAU8824_ADC_SYNC_DOWN_MASK, NAU8824_ADC_SYNC_DOWN_64);\n\tregmap_update_bits(regmap, NAU8824_REG_DAC_FILTER_CTRL_1,\n\t\tNAU8824_DAC_CICCLP_OFF | NAU8824_DAC_OVERSAMPLE_MASK,\n\t\tNAU8824_DAC_CICCLP_OFF | NAU8824_DAC_OVERSAMPLE_64);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_RDAC,\n\t\tNAU8824_RDAC_CLK_DELAY_MASK | NAU8824_RDAC_VREF_MASK,\n\t\t(0x2 << NAU8824_RDAC_CLK_DELAY_SFT) |\n\t\t(0x3 << NAU8824_RDAC_VREF_SFT));\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_FEPGA,\n\t\tNAU8824_FEPGA_MODEL_SHORT_EN | NAU8824_FEPGA_MODER_SHORT_EN,\n\t\tNAU8824_FEPGA_MODEL_SHORT_EN | NAU8824_FEPGA_MODER_SHORT_EN);\n\t \n\tregmap_update_bits(regmap, NAU8824_REG_ANALOG_CONTROL_1,\n\t\tNAU8824_DMIC_CLK_DRV_STRG | NAU8824_DMIC_CLK_SLEW_FAST,\n\t\tNAU8824_DMIC_CLK_DRV_STRG | NAU8824_DMIC_CLK_SLEW_FAST);\n\tregmap_update_bits(regmap, NAU8824_REG_JACK_DET_CTRL,\n\t\tNAU8824_JACK_LOGIC,\n\t\t \n\t\tnau8824->jkdet_polarity ? 0 : NAU8824_JACK_LOGIC);\n\tregmap_update_bits(regmap,\n\t\tNAU8824_REG_JACK_DET_CTRL, NAU8824_JACK_EJECT_DT_MASK,\n\t\t(nau8824->jack_eject_debounce << NAU8824_JACK_EJECT_DT_SFT));\n\tif (nau8824->sar_threshold_num)\n\t\tnau8824_setup_buttons(nau8824);\n}\n\nstatic int nau8824_setup_irq(struct nau8824 *nau8824)\n{\n\t \n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_ENA_CTRL,\n\t\tNAU8824_JD_SLEEP_MODE, NAU8824_JD_SLEEP_MODE);\n\tregmap_update_bits(nau8824->regmap,\n\t\tNAU8824_REG_INTERRUPT_SETTING, 0x3ff, 0x3ff);\n\tregmap_update_bits(nau8824->regmap, NAU8824_REG_INTERRUPT_SETTING_1,\n\t\tNAU8824_IRQ_EJECT_EN | NAU8824_IRQ_INSERT_EN, 0);\n\n\treturn 0;\n}\n\nstatic void nau8824_print_device_properties(struct nau8824 *nau8824)\n{\n\tstruct device *dev = nau8824->dev;\n\tint i;\n\n\tdev_dbg(dev, \"jkdet-polarity:       %d\\n\", nau8824->jkdet_polarity);\n\tdev_dbg(dev, \"micbias-voltage:      %d\\n\", nau8824->micbias_voltage);\n\tdev_dbg(dev, \"vref-impedance:       %d\\n\", nau8824->vref_impedance);\n\n\tdev_dbg(dev, \"sar-threshold-num:    %d\\n\", nau8824->sar_threshold_num);\n\tfor (i = 0; i < nau8824->sar_threshold_num; i++)\n\t\tdev_dbg(dev, \"sar-threshold[%d]=%x\\n\", i,\n\t\t\t\tnau8824->sar_threshold[i]);\n\n\tdev_dbg(dev, \"sar-hysteresis:       %d\\n\", nau8824->sar_hysteresis);\n\tdev_dbg(dev, \"sar-voltage:          %d\\n\", nau8824->sar_voltage);\n\tdev_dbg(dev, \"sar-compare-time:     %d\\n\", nau8824->sar_compare_time);\n\tdev_dbg(dev, \"sar-sampling-time:    %d\\n\", nau8824->sar_sampling_time);\n\tdev_dbg(dev, \"short-key-debounce:   %d\\n\", nau8824->key_debounce);\n\tdev_dbg(dev, \"jack-eject-debounce:  %d\\n\",\n\t\t\tnau8824->jack_eject_debounce);\n}\n\nstatic int nau8824_read_device_properties(struct device *dev,\n\tstruct nau8824 *nau8824) {\n\tint ret;\n\n\tret = device_property_read_u32(dev, \"nuvoton,jkdet-polarity\",\n\t\t&nau8824->jkdet_polarity);\n\tif (ret)\n\t\tnau8824->jkdet_polarity = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,micbias-voltage\",\n\t\t&nau8824->micbias_voltage);\n\tif (ret)\n\t\tnau8824->micbias_voltage = 6;\n\tret = device_property_read_u32(dev, \"nuvoton,vref-impedance\",\n\t\t&nau8824->vref_impedance);\n\tif (ret)\n\t\tnau8824->vref_impedance = 2;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-threshold-num\",\n\t\t&nau8824->sar_threshold_num);\n\tif (ret)\n\t\tnau8824->sar_threshold_num = 4;\n\tret = device_property_read_u32_array(dev, \"nuvoton,sar-threshold\",\n\t\tnau8824->sar_threshold, nau8824->sar_threshold_num);\n\tif (ret) {\n\t\tnau8824->sar_threshold[0] = 0x0a;\n\t\tnau8824->sar_threshold[1] = 0x14;\n\t\tnau8824->sar_threshold[2] = 0x26;\n\t\tnau8824->sar_threshold[3] = 0x73;\n\t}\n\tret = device_property_read_u32(dev, \"nuvoton,sar-hysteresis\",\n\t\t&nau8824->sar_hysteresis);\n\tif (ret)\n\t\tnau8824->sar_hysteresis = 0;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-voltage\",\n\t\t&nau8824->sar_voltage);\n\tif (ret)\n\t\tnau8824->sar_voltage = 6;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-compare-time\",\n\t\t&nau8824->sar_compare_time);\n\tif (ret)\n\t\tnau8824->sar_compare_time = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,sar-sampling-time\",\n\t\t&nau8824->sar_sampling_time);\n\tif (ret)\n\t\tnau8824->sar_sampling_time = 1;\n\tret = device_property_read_u32(dev, \"nuvoton,short-key-debounce\",\n\t\t&nau8824->key_debounce);\n\tif (ret)\n\t\tnau8824->key_debounce = 0;\n\tret = device_property_read_u32(dev, \"nuvoton,jack-eject-debounce\",\n\t\t&nau8824->jack_eject_debounce);\n\tif (ret)\n\t\tnau8824->jack_eject_debounce = 1;\n\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id nau8824_quirk_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR, \"Default string\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Cherry Trail CR\"),\n\t\t\tDMI_EXACT_MATCH(DMI_PRODUCT_SKU, \"20170531\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_JD_ACTIVE_HIGH |\n\t\t\t\t\tNAU8824_MONO_SPEAKER),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"cube\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"i1-TF\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Cherry Trail CR\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_MONO_SPEAKER),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"PIPO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"W2S\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_MONO_SPEAKER),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Positivo Tecnologia SA\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"CW14Q01P\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_JD_ACTIVE_HIGH),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Positivo Tecnologia SA\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"K1424G\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_JD_ACTIVE_HIGH),\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Positivo Tecnologia SA\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"N14ZP74G\"),\n\t\t},\n\t\t.driver_data = (void *)(NAU8824_JD_ACTIVE_HIGH),\n\t},\n\t{}\n};\n\nstatic void nau8824_check_quirks(void)\n{\n\tconst struct dmi_system_id *dmi_id;\n\n\tif (quirk_override != -1) {\n\t\tnau8824_quirk = quirk_override;\n\t\treturn;\n\t}\n\n\tdmi_id = dmi_first_match(nau8824_quirk_table);\n\tif (dmi_id)\n\t\tnau8824_quirk = (unsigned long)dmi_id->driver_data;\n}\n\nconst char *nau8824_components(void)\n{\n\tnau8824_check_quirks();\n\n\tif (nau8824_quirk & NAU8824_MONO_SPEAKER)\n\t\treturn \"cfg-spk:1\";\n\telse\n\t\treturn \"cfg-spk:2\";\n}\nEXPORT_SYMBOL_GPL(nau8824_components);\n\nstatic int nau8824_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct nau8824 *nau8824 = dev_get_platdata(dev);\n\tint ret, value;\n\n\tif (!nau8824) {\n\t\tnau8824 = devm_kzalloc(dev, sizeof(*nau8824), GFP_KERNEL);\n\t\tif (!nau8824)\n\t\t\treturn -ENOMEM;\n\t\tret = nau8824_read_device_properties(dev, nau8824);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\ti2c_set_clientdata(i2c, nau8824);\n\n\tnau8824->regmap = devm_regmap_init_i2c(i2c, &nau8824_regmap_config);\n\tif (IS_ERR(nau8824->regmap))\n\t\treturn PTR_ERR(nau8824->regmap);\n\tnau8824->resume_lock = false;\n\tnau8824->dev = dev;\n\tnau8824->irq = i2c->irq;\n\tsema_init(&nau8824->jd_sem, 1);\n\n\tnau8824_check_quirks();\n\n\tif (nau8824_quirk & NAU8824_JD_ACTIVE_HIGH)\n\t\tnau8824->jkdet_polarity = 0;\n\n\tnau8824_print_device_properties(nau8824);\n\n\tret = regmap_read(nau8824->regmap, NAU8824_REG_I2C_DEVICE_ID, &value);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to read device id from the NAU8824: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\tnau8824_reset_chip(nau8824->regmap);\n\tnau8824_init_regs(nau8824);\n\n\tif (i2c->irq)\n\t\tnau8824_setup_irq(nau8824);\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t&nau8824_component_driver, &nau8824_dai, 1);\n}\n\nstatic const struct i2c_device_id nau8824_i2c_ids[] = {\n\t{ \"nau8824\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nau8824_i2c_ids);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nau8824_of_ids[] = {\n\t{ .compatible = \"nuvoton,nau8824\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, nau8824_of_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id nau8824_acpi_match[] = {\n\t{ \"10508824\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(acpi, nau8824_acpi_match);\n#endif\n\nstatic struct i2c_driver nau8824_i2c_driver = {\n\t.driver = {\n\t\t.name = \"nau8824\",\n\t\t.of_match_table = of_match_ptr(nau8824_of_ids),\n\t\t.acpi_match_table = ACPI_PTR(nau8824_acpi_match),\n\t},\n\t.probe = nau8824_i2c_probe,\n\t.id_table = nau8824_i2c_ids,\n};\nmodule_i2c_driver(nau8824_i2c_driver);\n\n\nMODULE_DESCRIPTION(\"ASoC NAU88L24 driver\");\nMODULE_AUTHOR(\"John Hsu <KCHSU0@nuvoton.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}