{
  "module_name": "max98363.c",
  "hash_id": "61009e20252f8b2eea4e34fbb82d798de92a2f8b7e2696407deab119ff2fb8bc",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98363.c",
  "human_readable_source": "\n\n\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/soundwire/sdw.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/soundwire/sdw_type.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"max98363.h\"\n\nstatic struct reg_default max98363_reg[] = {\n\t{MAX98363_R2021_ERR_MON_CTRL, 0x0},\n\t{MAX98363_R2022_SPK_MON_THRESH, 0x0},\n\t{MAX98363_R2023_SPK_MON_DURATION, 0x0},\n\t{MAX98363_R2030_TONE_GEN_CFG, 0x0},\n\t{MAX98363_R203F_TONE_GEN_EN, 0x0},\n\t{MAX98363_R2040_AMP_VOL, 0x0},\n\t{MAX98363_R2041_AMP_GAIN, 0x5},\n\t{MAX98363_R2042_DSP_CFG, 0x0},\n};\n\nstatic bool max98363_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98363_R2001_INTR_RAW:\n\tcase MAX98363_R2003_INTR_STATE:\n\tcase MAX98363_R2005_INTR_FALG:\n\tcase MAX98363_R2007_INTR_EN:\n\tcase MAX98363_R2009_INTR_CLR:\n\tcase MAX98363_R2021_ERR_MON_CTRL ... MAX98363_R2023_SPK_MON_DURATION:\n\tcase MAX98363_R2030_TONE_GEN_CFG:\n\tcase MAX98363_R203F_TONE_GEN_EN:\n\tcase MAX98363_R2040_AMP_VOL:\n\tcase MAX98363_R2041_AMP_GAIN:\n\tcase MAX98363_R2042_DSP_CFG:\n\tcase MAX98363_R21FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n};\n\nstatic bool max98363_volatile_reg(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98363_R2001_INTR_RAW:\n\tcase MAX98363_R2003_INTR_STATE:\n\tcase MAX98363_R2005_INTR_FALG:\n\tcase MAX98363_R2007_INTR_EN:\n\tcase MAX98363_R2009_INTR_CLR:\n\tcase MAX98363_R21FF_REV_ID:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config max98363_sdw_regmap = {\n\t.reg_bits = 32,\n\t.val_bits = 8,\n\t.max_register = MAX98363_R21FF_REV_ID,\n\t.reg_defaults  = max98363_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98363_reg),\n\t.readable_reg = max98363_readable_register,\n\t.volatile_reg = max98363_volatile_reg,\n\t.cache_type = REGCACHE_RBTREE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int max98363_suspend(struct device *dev)\n{\n\tstruct max98363_priv *max98363 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(max98363->regmap, true);\n\tregcache_mark_dirty(max98363->regmap);\n\n\treturn 0;\n}\n\n#define MAX98363_PROBE_TIMEOUT 5000\n\nstatic int max98363_resume(struct device *dev)\n{\n\tstruct sdw_slave *slave = dev_to_sdw_dev(dev);\n\tstruct max98363_priv *max98363 = dev_get_drvdata(dev);\n\tunsigned long time;\n\n\tif (!max98363->first_hw_init)\n\t\treturn 0;\n\n\tif (!slave->unattach_request)\n\t\tgoto regmap_sync;\n\n\ttime = wait_for_completion_timeout(&slave->initialization_complete,\n\t\t\t\t\t   msecs_to_jiffies(MAX98363_PROBE_TIMEOUT));\n\tif (!time) {\n\t\tdev_err(dev, \"Initialization not complete, timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\nregmap_sync:\n\n\tslave->unattach_request = 0;\n\tregcache_cache_only(max98363->regmap, false);\n\tregcache_sync(max98363->regmap);\n\n\treturn 0;\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(max98363_pm, max98363_suspend, max98363_resume, NULL);\n\nstatic int max98363_read_prop(struct sdw_slave *slave)\n{\n\tstruct sdw_slave_prop *prop = &slave->prop;\n\tint nval, i;\n\tu32 bit;\n\tunsigned long addr;\n\tstruct sdw_dpn_prop *dpn;\n\n\tprop->scp_int1_mask = SDW_SCP_INT1_BUS_CLASH | SDW_SCP_INT1_PARITY;\n\n\t \n\tprop->sink_ports = BIT(1);\n\tprop->paging_support = true;\n\tprop->clk_stop_timeout = 20;\n\tprop->simple_clk_stop_capable = true;\n\tprop->clock_reg_supported = true;\n\n\tnval = hweight32(prop->sink_ports);\n\tprop->sink_dpn_prop = devm_kcalloc(&slave->dev, nval,\n\t\t\t\t\t   sizeof(*prop->sink_dpn_prop),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!prop->sink_dpn_prop)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tdpn = prop->sink_dpn_prop;\n\taddr = prop->sink_ports;\n\tfor_each_set_bit(bit, &addr, 32) {\n\t\tdpn[i].num = bit;\n\t\tdpn[i].type = SDW_DPN_FULL;\n\t\tdpn[i].simple_ch_prep_sm = true;\n\t\tdpn[i].ch_prep_timeout = 10;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int max98363_io_init(struct sdw_slave *slave)\n{\n\tstruct device *dev = &slave->dev;\n\tstruct max98363_priv *max98363 = dev_get_drvdata(dev);\n\tint ret, reg;\n\n\tregcache_cache_only(max98363->regmap, false);\n\tif (max98363->first_hw_init)\n\t\tregcache_cache_bypass(max98363->regmap, true);\n\n\t \n\tif (!max98363->first_hw_init)\n\t\t \n\t\tpm_runtime_set_active(dev);\n\n\tpm_runtime_get_noresume(dev);\n\n\tret = regmap_read(max98363->regmap, MAX98363_R21FF_REV_ID, &reg);\n\tif (!ret)\n\t\tdev_info(dev, \"Revision ID: %X\\n\", reg);\n\telse\n\t\tgoto out;\n\n\tif (max98363->first_hw_init) {\n\t\tregcache_cache_bypass(max98363->regmap, false);\n\t\tregcache_mark_dirty(max98363->regmap);\n\t}\n\n\tmax98363->first_hw_init = true;\n\tmax98363->hw_init = true;\n\nout:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\n#define MAX98363_RATES SNDRV_PCM_RATE_8000_192000\n#define MAX98363_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic int max98363_sdw_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t      struct snd_pcm_hw_params *params,\n\t\t\t\t      struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98363_priv *max98363 =\n\t\tsnd_soc_component_get_drvdata(component);\n\n\tstruct sdw_stream_config stream_config;\n\tstruct sdw_port_config port_config;\n\tenum sdw_data_direction direction;\n\tstruct sdw_stream_runtime *stream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\n\tint ret;\n\n\tstream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!stream)\n\t\treturn -EINVAL;\n\n\tif (!max98363->slave)\n\t\treturn -EINVAL;\n\n\tif (substream->stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn -EINVAL;\n\n\tdirection = SDW_DATA_DIR_RX;\n\tport_config.num = 1;\n\n\tstream_config.frame_rate = params_rate(params);\n\tstream_config.bps = snd_pcm_format_width(params_format(params));\n\tstream_config.direction = direction;\n\tstream_config.ch_count = 1;\n\n\tif (stream_config.ch_count > runtime->hw.channels_max) {\n\t\tstream_config.ch_count = runtime->hw.channels_max;\n\t\tdev_info(dai->dev, \"Number of channels: %d (requested: %d)\\n\",\n\t\t\t stream_config.ch_count, params_channels(params));\n\t}\n\tport_config.ch_mask = GENMASK((int)stream_config.ch_count - 1, 0);\n\n\tret = sdw_stream_add_slave(max98363->slave, &stream_config,\n\t\t\t\t   &port_config, 1, stream);\n\tif (ret) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(component->dev, \"Format supported %d\", params_format(params));\n\n\treturn 0;\n}\n\nstatic int max98363_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98363_priv *max98363 =\n\t\tsnd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!max98363->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(max98363->slave, stream);\n\n\treturn 0;\n}\n\nstatic int max98363_set_sdw_stream(struct snd_soc_dai *dai,\n\t\t\t\t   void *sdw_stream, int direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops max98363_dai_sdw_ops = {\n\t.hw_params = max98363_sdw_dai_hw_params,\n\t.hw_free = max98363_pcm_hw_free,\n\t.set_stream = max98363_set_sdw_stream,\n};\n\nstatic struct snd_soc_dai_driver max98363_dai[] = {\n\t{\n\t\t.name = \"max98363-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 1,\n\t\t\t.rates = MAX98363_RATES,\n\t\t\t.formats = MAX98363_FORMATS,\n\t\t},\n\t\t.ops = &max98363_dai_sdw_ops,\n\t}\n};\n\nstatic int max98363_update_status(struct sdw_slave *slave,\n\t\t\t\t  enum sdw_slave_status status)\n{\n\tstruct max98363_priv *max98363 = dev_get_drvdata(&slave->dev);\n\n\tif (status == SDW_SLAVE_UNATTACHED)\n\t\tmax98363->hw_init = false;\n\n\t \n\tif (max98363->hw_init || status != SDW_SLAVE_ATTACHED)\n\t\treturn 0;\n\n\t \n\treturn max98363_io_init(slave);\n}\n\nstatic struct sdw_slave_ops max98363_slave_ops = {\n\t.read_prop = max98363_read_prop,\n\t.update_status = max98363_update_status,\n};\n\nstatic DECLARE_TLV_DB_SCALE(max98363_digital_tlv, -6350, 50, 1);\nstatic const DECLARE_TLV_DB_RANGE(max98363_spk_tlv,\n\t0, 5, TLV_DB_SCALE_ITEM(-300, 300, 0),\n);\n\nstatic const char * const max98363_tone_cfg_text[] = {\n\t\"Reserved\", \"0\", \"+FS/2\", \"-FS/2\", \"1KHz\",\n\t\"12KHz\", \"8KHz\", \"6KHz\", \"4KHz\", \"3KHz\",\n\t\"2KHz\",\t\"1.5KHz\", \"Reserved\", \"500Hz\", \"250Hz\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98363_tone_cfg_enum,\n\t\t\t    MAX98363_R2030_TONE_GEN_CFG, 0,\n\t\t\t    max98363_tone_cfg_text);\n\nstatic const char * const max98363_spkmon_duration_text[] = {\n\t\"8ms\", \"20ms\", \"40ms\", \"60ms\",\n\t\"80ms\", \"160ms\", \"240ms\", \"320ms\",\n\t\"400ms\", \"480ms\", \"560ms\", \"640ms\",\n\t\"720ms\", \"800ms\", \"880ms\", \"960ms\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98363_spkmon_duration_enum,\n\t\t\t    MAX98363_R2023_SPK_MON_DURATION, 0,\n\t\t\t    max98363_spkmon_duration_text);\n\nstatic const struct snd_kcontrol_new max98363_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Digital Volume\", MAX98363_R2040_AMP_VOL,\n\t\t       0, 0x7F, 1, max98363_digital_tlv),\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98363_R2041_AMP_GAIN,\n\t\t       0, 10, 0, max98363_spk_tlv),\n\tSOC_SINGLE(\"Tone Generator Switch\", MAX98363_R203F_TONE_GEN_EN,\n\t\t   0, 1, 0),\n\tSOC_ENUM(\"Tone Config\", max98363_tone_cfg_enum),\n\tSOC_SINGLE(\"Ramp Switch\", MAX98363_R2042_DSP_CFG,\n\t\t   MAX98363_AMP_DSP_CFG_RMP_SHIFT, 1, 0),\n\tSOC_SINGLE(\"CLK Monitor Switch\", MAX98363_R2021_ERR_MON_CTRL,\n\t\t   MAX98363_CLOCK_MON_SHIFT, 1, 0),\n\tSOC_SINGLE(\"SPKMON Monitor Switch\", MAX98363_R2021_ERR_MON_CTRL,\n\t\t   MAX98363_SPKMON_SHIFT, 1, 0),\n\tSOC_SINGLE(\"SPKMON Thresh\", MAX98363_R2022_SPK_MON_THRESH, 0, 0xFF, 0),\n\tSOC_ENUM(\"SPKMON Duration\", max98363_spkmon_duration_enum),\n};\n\nstatic const struct snd_soc_dapm_widget max98363_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"AIFIN\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route max98363_audio_map[] = {\n\t \n\t{\"BE_OUT\", NULL, \"AIFIN\"},\n};\n\nstatic const struct snd_soc_component_driver soc_codec_dev_max98363 = {\n\t.controls\t\t= max98363_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98363_snd_controls),\n\t.dapm_widgets\t\t= max98363_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98363_dapm_widgets),\n\t.dapm_routes\t\t= max98363_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98363_audio_map),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int max98363_init(struct sdw_slave *slave, struct regmap *regmap)\n{\n\tstruct max98363_priv *max98363;\n\tint ret;\n\tstruct device *dev = &slave->dev;\n\n\t \n\tmax98363 = devm_kzalloc(dev, sizeof(*max98363), GFP_KERNEL);\n\tif (!max98363)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, max98363);\n\tmax98363->regmap = regmap;\n\tmax98363->slave = slave;\n\n\tregcache_cache_only(max98363->regmap, true);\n\n\tmax98363->hw_init = false;\n\tmax98363->first_hw_init = false;\n\n\t \n\tret = devm_snd_soc_register_component(dev, &soc_codec_dev_max98363,\n\t\t\t\t\t      max98363_dai,\n\t\t\t\t\t      ARRAY_SIZE(max98363_dai));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to register codec: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 3000);\n\tpm_runtime_use_autosuspend(dev);\n\n\t \n\tpm_runtime_mark_last_busy(dev);\n\n\tpm_runtime_enable(dev);\n\n\t \n\treturn 0;\n}\n\nstatic int max98363_sdw_probe(struct sdw_slave *slave,\n\t\t\t      const struct sdw_device_id *id)\n{\n\tstruct regmap *regmap;\n\n\t \n\tregmap = devm_regmap_init_sdw(slave, &max98363_sdw_regmap);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\treturn max98363_init(slave, regmap);\n}\n\nstatic const struct sdw_device_id max98363_id[] = {\n\tSDW_SLAVE_ENTRY(0x019F, 0x8363, 0),\n\t{},\n};\nMODULE_DEVICE_TABLE(sdw, max98363_id);\n\nstatic struct sdw_driver max98363_sdw_driver = {\n\t.driver = {\n\t\t.name = \"max98363\",\n\t\t.pm = pm_ptr(&max98363_pm),\n\t},\n\t.probe = max98363_sdw_probe,\n\t.ops = &max98363_slave_ops,\n\t.id_table = max98363_id,\n};\n\nmodule_sdw_driver(max98363_sdw_driver);\n\nMODULE_DESCRIPTION(\"ASoC MAX98363 driver SDW\");\nMODULE_AUTHOR(\"Ryan Lee <ryans.lee@analog.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}