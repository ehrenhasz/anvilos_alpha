{
  "module_name": "ml26124.c",
  "hash_id": "ad55ef0ab74845819d92cf8a9cff898ab3effa54f6cf52ff79e03961af15dde4",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/ml26124.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"ml26124.h\"\n\n#define DVOL_CTL_DVMUTE_ON\t\tBIT(4)\t \n#define DVOL_CTL_DVMUTE_OFF\t\t0\t \n#define ML26124_SAI_NO_DELAY\tBIT(1)\n#define ML26124_SAI_FRAME_SYNC\t(BIT(5) | BIT(0))  \n#define ML26134_CACHESIZE 212\n#define ML26124_VMID\tBIT(1)\n#define ML26124_RATES (SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 |\\\n\t\t       SNDRV_PCM_RATE_48000)\n#define ML26124_FORMATS (SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S32_LE)\n#define ML26124_NUM_REGISTER ML26134_CACHESIZE\n\nstruct ml26124_priv {\n\tu32 mclk;\n\tu32 rate;\n\tstruct regmap *regmap;\n\tint clk_in;\n\tstruct snd_pcm_substream *substream;\n};\n\nstruct clk_coeff {\n\tu32 mclk;\n\tu32 rate;\n\tu8 pllnl;\n\tu8 pllnh;\n\tu8 pllml;\n\tu8 pllmh;\n\tu8 plldiv;\n};\n\n \nstatic const DECLARE_TLV_DB_SCALE(digital_tlv, -7150, 50, 0);\n\nstatic const DECLARE_TLV_DB_SCALE(alclvl, -2250, 150, 0);\nstatic const DECLARE_TLV_DB_SCALE(mingain, -1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(maxgain, -675, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_vol, -1200, 75, 0);\n\nstatic const char * const ml26124_companding[] = {\"16bit PCM\", \"u-law\",\n\t\t\t\t\t\t  \"A-law\"};\n\nstatic SOC_ENUM_SINGLE_DECL(ml26124_adc_companding_enum,\n\t\t\t    ML26124_SAI_TRANS_CTL, 6, ml26124_companding);\n\nstatic SOC_ENUM_SINGLE_DECL(ml26124_dac_companding_enum,\n\t\t\t    ML26124_SAI_RCV_CTL, 6, ml26124_companding);\n\nstatic const struct snd_kcontrol_new ml26124_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Capture Digital Volume\", ML26124_RECORD_DIG_VOL, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"Playback Digital Volume\", ML26124_PLBAK_DIG_VOL, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"Digital Boost Volume\", ML26124_DIGI_BOOST_VOL, 0,\n\t\t\t0x3f, 0, boost_vol),\n\tSOC_SINGLE_TLV(\"EQ Band0 Volume\", ML26124_EQ_GAIN_BRAND0, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"EQ Band1 Volume\", ML26124_EQ_GAIN_BRAND1, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"EQ Band2 Volume\", ML26124_EQ_GAIN_BRAND2, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"EQ Band3 Volume\", ML26124_EQ_GAIN_BRAND3, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"EQ Band4 Volume\", ML26124_EQ_GAIN_BRAND4, 0,\n\t\t\t0xff, 1, digital_tlv),\n\tSOC_SINGLE_TLV(\"ALC Target Level\", ML26124_ALC_TARGET_LEV, 0,\n\t\t\t0xf, 1, alclvl),\n\tSOC_SINGLE_TLV(\"ALC Min Input Volume\", ML26124_ALC_MAXMIN_GAIN, 0,\n\t\t\t7, 0, mingain),\n\tSOC_SINGLE_TLV(\"ALC Max Input Volume\", ML26124_ALC_MAXMIN_GAIN, 4,\n\t\t\t7, 1, maxgain),\n\tSOC_SINGLE_TLV(\"Playback Limiter Min Input Volume\",\n\t\t\tML26124_PL_MAXMIN_GAIN, 0, 7, 0, mingain),\n\tSOC_SINGLE_TLV(\"Playback Limiter Max Input Volume\",\n\t\t\tML26124_PL_MAXMIN_GAIN, 4, 7, 1, maxgain),\n\tSOC_SINGLE_TLV(\"Playback Boost Volume\", ML26124_PLYBAK_BOST_VOL, 0,\n\t\t\t0x3f, 0, boost_vol),\n\tSOC_SINGLE(\"DC High Pass Filter Switch\", ML26124_FILTER_EN, 0, 1, 0),\n\tSOC_SINGLE(\"Noise High Pass Filter Switch\", ML26124_FILTER_EN, 1, 1, 0),\n\tSOC_SINGLE(\"ZC Switch\", ML26124_PW_ZCCMP_PW_MNG, 1,\n\t\t    1, 0),\n\tSOC_SINGLE(\"EQ Band0 Switch\", ML26124_FILTER_EN, 2, 1, 0),\n\tSOC_SINGLE(\"EQ Band1 Switch\", ML26124_FILTER_EN, 3, 1, 0),\n\tSOC_SINGLE(\"EQ Band2 Switch\", ML26124_FILTER_EN, 4, 1, 0),\n\tSOC_SINGLE(\"EQ Band3 Switch\", ML26124_FILTER_EN, 5, 1, 0),\n\tSOC_SINGLE(\"EQ Band4 Switch\", ML26124_FILTER_EN, 6, 1, 0),\n\tSOC_SINGLE(\"Play Limiter\", ML26124_DVOL_CTL, 0, 1, 0),\n\tSOC_SINGLE(\"Capture Limiter\", ML26124_DVOL_CTL, 1, 1, 0),\n\tSOC_SINGLE(\"Digital Volume Fade Switch\", ML26124_DVOL_CTL, 3, 1, 0),\n\tSOC_SINGLE(\"Digital Switch\", ML26124_DVOL_CTL, 4, 1, 0),\n\tSOC_ENUM(\"DAC Companding\", ml26124_dac_companding_enum),\n\tSOC_ENUM(\"ADC Companding\", ml26124_adc_companding_enum),\n};\n\nstatic const struct snd_kcontrol_new ml26124_output_mixer_controls[] = {\n\tSOC_DAPM_SINGLE(\"DAC Switch\", ML26124_SPK_AMP_OUT, 1, 1, 0),\n\tSOC_DAPM_SINGLE(\"Line in loopback Switch\", ML26124_SPK_AMP_OUT, 3, 1,\n\t\t\t 0),\n\tSOC_DAPM_SINGLE(\"PGA Switch\", ML26124_SPK_AMP_OUT, 5, 1, 0),\n};\n\n \nstatic const char * const ml26124_input_select[] = {\"Analog MIC SingleEnded in\",\n\t\t\t\t\"Digital MIC in\", \"Analog MIC Differential in\"};\n\nstatic SOC_ENUM_SINGLE_DECL(ml26124_insel_enum,\n\t\t\t    ML26124_MIC_IF_CTL, 0, ml26124_input_select);\n\nstatic const struct snd_kcontrol_new ml26124_input_mux_controls =\n\tSOC_DAPM_ENUM(\"Input Select\", ml26124_insel_enum);\n\nstatic const struct snd_kcontrol_new ml26124_line_control =\n\tSOC_DAPM_SINGLE(\"Switch\", ML26124_PW_LOUT_PW_MNG, 1, 1, 0);\n\nstatic const struct snd_soc_dapm_widget ml26124_dapm_widgets[] = {\n\tSND_SOC_DAPM_SUPPLY(\"MCLKEN\", ML26124_CLK_EN, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLLEN\", ML26124_CLK_EN, 1, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLLOE\", ML26124_CLK_EN, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MICBIAS\", ML26124_PW_REF_PW_MNG, 2, 0, NULL, 0),\n\tSND_SOC_DAPM_MIXER(\"Output Mixer\", SND_SOC_NOPM, 0, 0,\n\t\t\t   &ml26124_output_mixer_controls[0],\n\t\t\t   ARRAY_SIZE(ml26124_output_mixer_controls)),\n\tSND_SOC_DAPM_DAC(\"DAC\", \"Playback\", ML26124_PW_DAC_PW_MNG, 1, 0),\n\tSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", ML26124_PW_IN_PW_MNG, 1, 0),\n\tSND_SOC_DAPM_PGA(\"PGA\", ML26124_PW_IN_PW_MNG, 3, 0, NULL, 0),\n\tSND_SOC_DAPM_MUX(\"Input Mux\", SND_SOC_NOPM, 0, 0,\n\t\t\t  &ml26124_input_mux_controls),\n\tSND_SOC_DAPM_SWITCH(\"Line Out Enable\", SND_SOC_NOPM, 0, 0,\n\t\t\t     &ml26124_line_control),\n\tSND_SOC_DAPM_INPUT(\"MDIN\"),\n\tSND_SOC_DAPM_INPUT(\"MIN\"),\n\tSND_SOC_DAPM_INPUT(\"LIN\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPOUT\"),\n\tSND_SOC_DAPM_OUTPUT(\"LOUT\"),\n};\n\nstatic const struct snd_soc_dapm_route ml26124_intercon[] = {\n\t \n\t{\"DAC\", NULL, \"MCLKEN\"},\n\t{\"ADC\", NULL, \"MCLKEN\"},\n\t{\"DAC\", NULL, \"PLLEN\"},\n\t{\"ADC\", NULL, \"PLLEN\"},\n\t{\"DAC\", NULL, \"PLLOE\"},\n\t{\"ADC\", NULL, \"PLLOE\"},\n\n\t \n\t{\"Output Mixer\", \"DAC Switch\", \"DAC\"},\n\t{\"Output Mixer\", \"Line in loopback Switch\", \"LIN\"},\n\n\t \n\t{\"LOUT\", NULL, \"Output Mixer\"},\n\t{\"SPOUT\", NULL, \"Output Mixer\"},\n\t{\"Line Out Enable\", NULL, \"LOUT\"},\n\n\t \n\t{\"ADC\", NULL, \"Input Mux\"},\n\t{\"Input Mux\", \"Analog MIC SingleEnded in\", \"PGA\"},\n\t{\"Input Mux\", \"Analog MIC Differential in\", \"PGA\"},\n\t{\"PGA\", NULL, \"MIN\"},\n};\n\n \nstatic const struct clk_coeff coeff_div[] = {\n\t{12288000, 16000, 0xc, 0x0, 0x20, 0x0, 0x4},\n\t{12288000, 32000, 0xc, 0x0, 0x20, 0x0, 0x4},\n\t{12288000, 48000, 0xc, 0x0, 0x30, 0x0, 0x4},\n};\n\nstatic const struct reg_default ml26124_reg[] = {\n\t \n\t{0x00, 0x00 },\t \n\t{0x02, 0x00},\t \n\t{0x04, 0x00},\t \n\t{0x06, 0x00},\t \n\t{0x08, 0x00},\t \n\t{0x0a, 0x00},\t \n\t{0x0c, 0x00},\t \n\t{0x0e, 0x00},\t \n\n\t \n\t{0x10, 0x00},\t \n\t{0x12, 0x00},\t \n\t{0x14, 0x00},\t \n\n\t \n\t{0x20, 0x00},\t \n\t{0x22, 0x00},\t \n\t{0x24, 0x00},\t \n\t{0x26, 0x00},\t \n\t{0x28, 0x00},\t \n\t{0x2a, 0x00},\t \n\t{0x2e, 0x00},\t \n\n\t \n\t{0x30, 0x04},\t \n\n\t \n\t{0x32, 0x10},\t \n\t{0x38, 0x00},\t \n\t{0x3a, 0x33},\t \n\t{0x48, 0x00},\t \n\t{0x4a, 0x00},\t \n\n\t \n\t{0x54, 0x00},\t \n\t{0x5a, 0x00},\t \n\t{0xe8, 0x01},\t \n\n\t \n\t{0x60, 0x00},\t \n\t{0x62, 0x00},\t \n\t{0x64, 0x00},\t \n\n\t \n\t{0x66, 0x01},\t \n\t{0x68, 0x00},\t \n\t{0x6A, 0x00},\t \n\t{0x6C, 0xff},\t \n\t{0x70, 0xff},\t \n\t{0x72, 0x10},\t \n\t{0x74, 0xe7},\t \n\t{0x76, 0xe7},\t \n\t{0x78, 0xe7},\t \n\t{0x7A, 0xe7},\t \n\t{0x7C, 0xe7},\t \n\t{0x7E, 0x00},\t \n\t{0x80, 0x00},\t \n\t{0x82, 0x00},\t \n\t{0x84, 0x00},\t \n\t{0x86, 0x00},\t \n\t{0x88, 0x00},\t \n\t{0x8A, 0x00},\t \n\t{0x8C, 0x00},\t \n\t{0x8E, 0x00},\t \n\t{0x90, 0x00},\t \n\t{0x92, 0x00},\t \n\t{0x94, 0x00},\t \n\t{0x96, 0x00},\t \n\t{0x98, 0x00},\t \n\t{0x9A, 0x00},\t \n\t{0x9C, 0x00},\t \n\t{0x9E, 0x00},\t \n\t{0xA0, 0x00},\t \n\t{0xA2, 0x00},\t \n\t{0xA4, 0x00},\t \n\t{0xA6, 0x00},\t \n\n\t \n\t{0xb0, 0x00},\t \n\t{0xb2, 0x02},\t \n\t{0xb4, 0x03},\t \n\t{0xb6, 0x00},\t \n\t{0xb8, 0x0b},\t \n\t{0xba, 0x70},\t \n\t{0xbc, 0x00},\t \n\t{0xbe, 0x00},\t \n\n\t \n\t{0xc0, 0x04},\t \n\t{0xc2, 0x05},\t \n\t{0xc4, 0x0d},\t \n\t{0xc6, 0x70},\t \n\t{0xc8, 0x10},\t \n\t{0xca, 0x00},\t \n\n\t \n\t{0xd0, 0x01},\t \n\t{0xd2, 0x01},\t \n\t{0xd4, 0x01},\t \n};\n\n \nstatic inline int get_srate(int rate)\n{\n\tint srate;\n\n\tswitch (rate) {\n\tcase 16000:\n\t\tsrate = 3;\n\t\tbreak;\n\tcase 32000:\n\t\tsrate = 6;\n\t\tbreak;\n\tcase 48000:\n\t\tsrate = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn srate;\n}\n\nstatic inline int get_coeff(int mclk, int rate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int ml26124_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *hw_params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ml26124_priv *priv = snd_soc_component_get_drvdata(component);\n\tint i = get_coeff(priv->mclk, params_rate(hw_params));\n\tint srate;\n\n\tif (i < 0)\n\t\treturn i;\n\tpriv->substream = substream;\n\tpriv->rate = params_rate(hw_params);\n\n\tif (priv->clk_in) {\n\t\tswitch (priv->mclk / params_rate(hw_params)) {\n\t\tcase 256:\n\t\t\tsnd_soc_component_update_bits(component, ML26124_CLK_CTL,\n\t\t\t\t\t    BIT(0) | BIT(1), 1);\n\t\t\tbreak;\n\t\tcase 512:\n\t\t\tsnd_soc_component_update_bits(component, ML26124_CLK_CTL,\n\t\t\t\t\t    BIT(0) | BIT(1), 2);\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\tsnd_soc_component_update_bits(component, ML26124_CLK_CTL,\n\t\t\t\t\t    BIT(0) | BIT(1), 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(component->dev, \"Unsupported MCLKI\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tsnd_soc_component_update_bits(component, ML26124_CLK_CTL,\n\t\t\t\t    BIT(0) | BIT(1), 0);\n\t}\n\n\tsrate = get_srate(params_rate(hw_params));\n\tif (srate < 0)\n\t\treturn srate;\n\n\tsnd_soc_component_update_bits(component, ML26124_SMPLING_RATE, 0xf, srate);\n\tsnd_soc_component_update_bits(component, ML26124_PLLNL, 0xff, coeff_div[i].pllnl);\n\tsnd_soc_component_update_bits(component, ML26124_PLLNH, 0x1, coeff_div[i].pllnh);\n\tsnd_soc_component_update_bits(component, ML26124_PLLML, 0xff, coeff_div[i].pllml);\n\tsnd_soc_component_update_bits(component, ML26124_PLLMH, 0x3f, coeff_div[i].pllmh);\n\tsnd_soc_component_update_bits(component, ML26124_PLLDIV, 0x1f, coeff_div[i].plldiv);\n\n\treturn 0;\n}\n\nstatic int ml26124_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct ml26124_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (priv->substream->stream) {\n\tcase SNDRV_PCM_STREAM_CAPTURE:\n\t\tsnd_soc_component_update_bits(component, ML26124_REC_PLYBAK_RUN, BIT(0), 1);\n\t\tbreak;\n\tcase SNDRV_PCM_STREAM_PLAYBACK:\n\t\tsnd_soc_component_update_bits(component, ML26124_REC_PLYBAK_RUN, BIT(1), 2);\n\t\tbreak;\n\t}\n\n\tif (mute)\n\t\tsnd_soc_component_update_bits(component, ML26124_DVOL_CTL, BIT(4),\n\t\t\t\t    DVOL_CTL_DVMUTE_ON);\n\telse\n\t\tsnd_soc_component_update_bits(component, ML26124_DVOL_CTL, BIT(4),\n\t\t\t\t    DVOL_CTL_DVMUTE_OFF);\n\n\treturn 0;\n}\n\nstatic int ml26124_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tunsigned char mode;\n\tstruct snd_soc_component *component = codec_dai->component;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tmode = 1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tmode = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tsnd_soc_component_update_bits(component, ML26124_SAI_MODE_SEL, BIT(0), mode);\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ml26124_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\tint clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct ml26124_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase ML26124_USE_PLLOUT:\n\t\tpriv->clk_in = ML26124_USE_PLLOUT;\n\t\tbreak;\n\tcase ML26124_USE_MCLKI:\n\t\tpriv->clk_in = ML26124_USE_MCLKI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->mclk = freq;\n\n\treturn 0;\n}\n\nstatic int ml26124_set_bias_level(struct snd_soc_component *component,\n\t\tenum snd_soc_bias_level level)\n{\n\tstruct ml26124_priv *priv = snd_soc_component_get_drvdata(component);\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tsnd_soc_component_update_bits(component, ML26124_PW_SPAMP_PW_MNG,\n\t\t\t\t    ML26124_R26_MASK, ML26124_BLT_PREAMP_ON);\n\t\tmsleep(100);\n\t\tsnd_soc_component_update_bits(component, ML26124_PW_SPAMP_PW_MNG,\n\t\t\t\t    ML26124_R26_MASK,\n\t\t\t\t    ML26124_MICBEN_ON | ML26124_BLT_ALL_ON);\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\t \n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tsnd_soc_component_update_bits(component, ML26124_PW_REF_PW_MNG,\n\t\t\t\t\t    ML26124_VMID, ML26124_VMID);\n\t\t\tmsleep(500);\n\t\t\tregcache_sync(priv->regmap);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tsnd_soc_component_update_bits(component, ML26124_PW_REF_PW_MNG,\n\t\t\t\t    ML26124_VMID, 0);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops ml26124_dai_ops = {\n\t.hw_params\t= ml26124_hw_params,\n\t.mute_stream\t= ml26124_mute,\n\t.set_fmt\t= ml26124_set_dai_fmt,\n\t.set_sysclk\t= ml26124_set_dai_sysclk,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver ml26124_dai = {\n\t.name = \"ml26124-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = ML26124_RATES,\n\t\t.formats = ML26124_FORMATS,},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 2,\n\t\t.rates = ML26124_RATES,\n\t\t.formats = ML26124_FORMATS,},\n\t.ops = &ml26124_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int ml26124_probe(struct snd_soc_component *component)\n{\n\t \n\tsnd_soc_component_update_bits(component, ML26124_SW_RST, 0x01, 1);\n\tsnd_soc_component_update_bits(component, ML26124_SW_RST, 0x01, 0);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_ml26124 = {\n\t.probe\t\t\t= ml26124_probe,\n\t.set_bias_level\t\t= ml26124_set_bias_level,\n\t.controls\t\t= ml26124_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(ml26124_snd_controls),\n\t.dapm_widgets\t\t= ml26124_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(ml26124_dapm_widgets),\n\t.dapm_routes\t\t= ml26124_intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(ml26124_intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config ml26124_i2c_regmap = {\n\t.val_bits = 8,\n\t.reg_bits = 8,\n\t.max_register = ML26124_NUM_REGISTER,\n\t.reg_defaults = ml26124_reg,\n\t.num_reg_defaults = ARRAY_SIZE(ml26124_reg),\n\t.cache_type = REGCACHE_RBTREE,\n\t.write_flag_mask = 0x01,\n};\n\nstatic int ml26124_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct ml26124_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&i2c->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tpriv->regmap = devm_regmap_init_i2c(i2c, &ml26124_i2c_regmap);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"regmap_init_i2c() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_ml26124, &ml26124_dai, 1);\n}\n\nstatic const struct i2c_device_id ml26124_i2c_id[] = {\n\t{ \"ml26124\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, ml26124_i2c_id);\n\nstatic struct i2c_driver ml26124_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ml26124\",\n\t},\n\t.probe = ml26124_i2c_probe,\n\t.id_table = ml26124_i2c_id,\n};\n\nmodule_i2c_driver(ml26124_i2c_driver);\n\nMODULE_AUTHOR(\"Tomoya MORINAGA <tomoya.rohm@gmail.com>\");\nMODULE_DESCRIPTION(\"LAPIS Semiconductor ML26124 ALSA SoC codec driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}