{
  "module_name": "cs4271.c",
  "hash_id": "bf1567c806d801cf3b2e170e6182cb90fab1660ab9c668b71bc1fb9e5ea01935",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs4271.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/gpio.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/cs4271.h>\n#include \"cs4271.h\"\n\n#define CS4271_PCM_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S24_LE | \\\n\t\t\t    SNDRV_PCM_FMTBIT_S32_LE)\n#define CS4271_PCM_RATES SNDRV_PCM_RATE_8000_192000\n\n \n#define CS4271_MODE1\t0x01\t \n#define CS4271_DACCTL\t0x02\t \n#define CS4271_DACVOL\t0x03\t \n#define CS4271_VOLA\t0x04\t \n#define CS4271_VOLB\t0x05\t \n#define CS4271_ADCCTL\t0x06\t \n#define CS4271_MODE2\t0x07\t \n#define CS4271_CHIPID\t0x08\t \n\n#define CS4271_FIRSTREG\tCS4271_MODE1\n#define CS4271_LASTREG\tCS4271_MODE2\n#define CS4271_NR_REGS\t((CS4271_LASTREG & 0xFF) + 1)\n\n \n#define CS4271_MODE1_MODE_MASK\t0xC0\n#define CS4271_MODE1_MODE_1X\t0x00\n#define CS4271_MODE1_MODE_2X\t0x80\n#define CS4271_MODE1_MODE_4X\t0xC0\n\n#define CS4271_MODE1_DIV_MASK\t0x30\n#define CS4271_MODE1_DIV_1\t0x00\n#define CS4271_MODE1_DIV_15\t0x10\n#define CS4271_MODE1_DIV_2\t0x20\n#define CS4271_MODE1_DIV_3\t0x30\n\n#define CS4271_MODE1_MASTER\t0x08\n\n#define CS4271_MODE1_DAC_DIF_MASK\t0x07\n#define CS4271_MODE1_DAC_DIF_LJ\t\t0x00\n#define CS4271_MODE1_DAC_DIF_I2S\t0x01\n#define CS4271_MODE1_DAC_DIF_RJ16\t0x02\n#define CS4271_MODE1_DAC_DIF_RJ24\t0x03\n#define CS4271_MODE1_DAC_DIF_RJ20\t0x04\n#define CS4271_MODE1_DAC_DIF_RJ18\t0x05\n\n#define CS4271_DACCTL_AMUTE\t0x80\n#define CS4271_DACCTL_IF_SLOW\t0x40\n\n#define CS4271_DACCTL_DEM_MASK\t0x30\n#define CS4271_DACCTL_DEM_DIS\t0x00\n#define CS4271_DACCTL_DEM_441\t0x10\n#define CS4271_DACCTL_DEM_48\t0x20\n#define CS4271_DACCTL_DEM_32\t0x30\n\n#define CS4271_DACCTL_SVRU\t0x08\n#define CS4271_DACCTL_SRD\t0x04\n#define CS4271_DACCTL_INVA\t0x02\n#define CS4271_DACCTL_INVB\t0x01\n\n#define CS4271_DACVOL_BEQUA\t0x40\n#define CS4271_DACVOL_SOFT\t0x20\n#define CS4271_DACVOL_ZEROC\t0x10\n\n#define CS4271_DACVOL_ATAPI_MASK\t0x0F\n#define CS4271_DACVOL_ATAPI_M_M\t\t0x00\n#define CS4271_DACVOL_ATAPI_M_BR\t0x01\n#define CS4271_DACVOL_ATAPI_M_BL\t0x02\n#define CS4271_DACVOL_ATAPI_M_BLR2\t0x03\n#define CS4271_DACVOL_ATAPI_AR_M\t0x04\n#define CS4271_DACVOL_ATAPI_AR_BR\t0x05\n#define CS4271_DACVOL_ATAPI_AR_BL\t0x06\n#define CS4271_DACVOL_ATAPI_AR_BLR2\t0x07\n#define CS4271_DACVOL_ATAPI_AL_M\t0x08\n#define CS4271_DACVOL_ATAPI_AL_BR\t0x09\n#define CS4271_DACVOL_ATAPI_AL_BL\t0x0A\n#define CS4271_DACVOL_ATAPI_AL_BLR2\t0x0B\n#define CS4271_DACVOL_ATAPI_ALR2_M\t0x0C\n#define CS4271_DACVOL_ATAPI_ALR2_BR\t0x0D\n#define CS4271_DACVOL_ATAPI_ALR2_BL\t0x0E\n#define CS4271_DACVOL_ATAPI_ALR2_BLR2\t0x0F\n\n#define CS4271_VOLA_MUTE\t0x80\n#define CS4271_VOLA_VOL_MASK\t0x7F\n#define CS4271_VOLB_MUTE\t0x80\n#define CS4271_VOLB_VOL_MASK\t0x7F\n\n#define CS4271_ADCCTL_DITHER16\t0x20\n\n#define CS4271_ADCCTL_ADC_DIF_MASK\t0x10\n#define CS4271_ADCCTL_ADC_DIF_LJ\t0x00\n#define CS4271_ADCCTL_ADC_DIF_I2S\t0x10\n\n#define CS4271_ADCCTL_MUTEA\t0x08\n#define CS4271_ADCCTL_MUTEB\t0x04\n#define CS4271_ADCCTL_HPFDA\t0x02\n#define CS4271_ADCCTL_HPFDB\t0x01\n\n#define CS4271_MODE2_LOOP\t0x10\n#define CS4271_MODE2_MUTECAEQUB\t0x08\n#define CS4271_MODE2_FREEZE\t0x04\n#define CS4271_MODE2_CPEN\t0x02\n#define CS4271_MODE2_PDN\t0x01\n\n#define CS4271_CHIPID_PART_MASK\t0xF0\n#define CS4271_CHIPID_REV_MASK\t0x0F\n\n \nstatic const struct reg_default cs4271_reg_defaults[] = {\n\t{ CS4271_MODE1,\t\t0, },\n\t{ CS4271_DACCTL,\tCS4271_DACCTL_AMUTE, },\n\t{ CS4271_DACVOL,\tCS4271_DACVOL_SOFT | CS4271_DACVOL_ATAPI_AL_BR, },\n\t{ CS4271_VOLA,\t\t0, },\n\t{ CS4271_VOLB,\t\t0, },\n\t{ CS4271_ADCCTL,\t0, },\n\t{ CS4271_MODE2,\t\t0, },\n};\n\nstatic bool cs4271_volatile_reg(struct device *dev, unsigned int reg)\n{\n\treturn reg == CS4271_CHIPID;\n}\n\nstatic const char * const supply_names[] = {\n\t\"vd\", \"vl\", \"va\"\n};\n\nstruct cs4271_private {\n\tunsigned int\t\t\tmclk;\n\tbool\t\t\t\tmaster;\n\tbool\t\t\t\tdeemph;\n\tstruct regmap\t\t\t*regmap;\n\t \n\tint\t\t\t\trate;\n\t \n\tint\t\t\t\tgpio_nreset;\n\t \n\tint\t\t\t\tgpio_disable;\n\t \n\tbool\t\t\t\tenable_soft_reset;\n\tstruct regulator_bulk_data      supplies[ARRAY_SIZE(supply_names)];\n};\n\nstatic const struct snd_soc_dapm_widget cs4271_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"AINA\"),\nSND_SOC_DAPM_INPUT(\"AINB\"),\n\nSND_SOC_DAPM_OUTPUT(\"AOUTA+\"),\nSND_SOC_DAPM_OUTPUT(\"AOUTA-\"),\nSND_SOC_DAPM_OUTPUT(\"AOUTB+\"),\nSND_SOC_DAPM_OUTPUT(\"AOUTB-\"),\n};\n\nstatic const struct snd_soc_dapm_route cs4271_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"AINA\" },\n\t{ \"Capture\", NULL, \"AINB\" },\n\n\t{ \"AOUTA+\", NULL, \"Playback\" },\n\t{ \"AOUTA-\", NULL, \"Playback\" },\n\t{ \"AOUTB+\", NULL, \"Playback\" },\n\t{ \"AOUTB-\", NULL, \"Playback\" },\n};\n\n \nstatic int cs4271_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tcs4271->mclk = freq;\n\treturn 0;\n}\n\nstatic int cs4271_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int format)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0;\n\tint ret;\n\n\tswitch (format & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tcs4271->master = false;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\tcs4271->master = true;\n\t\tval |= CS4271_MODE1_MASTER;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tval |= CS4271_MODE1_DAC_DIF_LJ;\n\t\tret = regmap_update_bits(cs4271->regmap, CS4271_ADCCTL,\n\t\t\tCS4271_ADCCTL_ADC_DIF_MASK, CS4271_ADCCTL_ADC_DIF_LJ);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tval |= CS4271_MODE1_DAC_DIF_I2S;\n\t\tret = regmap_update_bits(cs4271->regmap, CS4271_ADCCTL,\n\t\t\tCS4271_ADCCTL_ADC_DIF_MASK, CS4271_ADCCTL_ADC_DIF_I2S);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Invalid DAI format\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE1,\n\t\tCS4271_MODE1_DAC_DIF_MASK | CS4271_MODE1_MASTER, val);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int cs4271_deemph[] = {0, 44100, 48000, 32000};\n\nstatic int cs4271_set_deemph(struct snd_soc_component *component)\n{\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\tint i, ret;\n\tint val = CS4271_DACCTL_DEM_DIS;\n\n\tif (cs4271->deemph) {\n\t\t \n\t\tval = 1;\n\t\tfor (i = 2; i < ARRAY_SIZE(cs4271_deemph); i++)\n\t\t\tif (abs(cs4271_deemph[i] - cs4271->rate) <\n\t\t\t    abs(cs4271_deemph[val] - cs4271->rate))\n\t\t\t\tval = i;\n\t\tval <<= 4;\n\t}\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_DACCTL,\n\t\tCS4271_DACCTL_DEM_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int cs4271_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = cs4271->deemph;\n\treturn 0;\n}\n\nstatic int cs4271_put_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t     struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tcs4271->deemph = ucontrol->value.integer.value[0];\n\treturn cs4271_set_deemph(component);\n}\n\nstruct cs4271_clk_cfg {\n\tbool\t\tmaster;\t\t \n\tu8\t\tspeed_mode;\t \n\tunsigned short\tratio;\t\t \n\tu8\t\tratio_mask;\t \n};\n\nstatic struct cs4271_clk_cfg cs4271_clk_tab[] = {\n\t{1, CS4271_MODE1_MODE_1X, 256,  CS4271_MODE1_DIV_1},\n\t{1, CS4271_MODE1_MODE_1X, 384,  CS4271_MODE1_DIV_15},\n\t{1, CS4271_MODE1_MODE_1X, 512,  CS4271_MODE1_DIV_2},\n\t{1, CS4271_MODE1_MODE_1X, 768,  CS4271_MODE1_DIV_3},\n\t{1, CS4271_MODE1_MODE_2X, 128,  CS4271_MODE1_DIV_1},\n\t{1, CS4271_MODE1_MODE_2X, 192,  CS4271_MODE1_DIV_15},\n\t{1, CS4271_MODE1_MODE_2X, 256,  CS4271_MODE1_DIV_2},\n\t{1, CS4271_MODE1_MODE_2X, 384,  CS4271_MODE1_DIV_3},\n\t{1, CS4271_MODE1_MODE_4X, 64,   CS4271_MODE1_DIV_1},\n\t{1, CS4271_MODE1_MODE_4X, 96,   CS4271_MODE1_DIV_15},\n\t{1, CS4271_MODE1_MODE_4X, 128,  CS4271_MODE1_DIV_2},\n\t{1, CS4271_MODE1_MODE_4X, 192,  CS4271_MODE1_DIV_3},\n\t{0, CS4271_MODE1_MODE_1X, 256,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_1X, 384,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_1X, 512,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_1X, 768,  CS4271_MODE1_DIV_2},\n\t{0, CS4271_MODE1_MODE_1X, 1024, CS4271_MODE1_DIV_2},\n\t{0, CS4271_MODE1_MODE_2X, 128,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_2X, 192,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_2X, 256,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_2X, 384,  CS4271_MODE1_DIV_2},\n\t{0, CS4271_MODE1_MODE_2X, 512,  CS4271_MODE1_DIV_2},\n\t{0, CS4271_MODE1_MODE_4X, 64,   CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_4X, 96,   CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_4X, 128,  CS4271_MODE1_DIV_1},\n\t{0, CS4271_MODE1_MODE_4X, 192,  CS4271_MODE1_DIV_2},\n\t{0, CS4271_MODE1_MODE_4X, 256,  CS4271_MODE1_DIV_2},\n};\n\n#define CS4271_NR_RATIOS ARRAY_SIZE(cs4271_clk_tab)\n\nstatic int cs4271_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\tint i, ret;\n\tunsigned int ratio, val;\n\n\tif (cs4271->enable_soft_reset) {\n\t\t \n\n\t\tif ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&\n\t\t     !snd_soc_dai_stream_active(dai, SNDRV_PCM_STREAM_CAPTURE)) ||\n\t\t    (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&\n\t\t     !snd_soc_dai_stream_active(dai, SNDRV_PCM_STREAM_PLAYBACK))) {\n\t\t\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t\t\t CS4271_MODE2_PDN,\n\t\t\t\t\t\t CS4271_MODE2_PDN);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t\t\t CS4271_MODE2_PDN, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcs4271->rate = params_rate(params);\n\n\t \n\tif (cs4271->rate < 50000)\n\t\tval = CS4271_MODE1_MODE_1X;\n\telse if (cs4271->rate < 100000)\n\t\tval = CS4271_MODE1_MODE_2X;\n\telse\n\t\tval = CS4271_MODE1_MODE_4X;\n\n\tratio = cs4271->mclk / cs4271->rate;\n\tfor (i = 0; i < CS4271_NR_RATIOS; i++)\n\t\tif ((cs4271_clk_tab[i].master == cs4271->master) &&\n\t\t    (cs4271_clk_tab[i].speed_mode == val) &&\n\t\t    (cs4271_clk_tab[i].ratio == ratio))\n\t\t\tbreak;\n\n\tif (i == CS4271_NR_RATIOS) {\n\t\tdev_err(component->dev, \"Invalid sample rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval |= cs4271_clk_tab[i].ratio_mask;\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE1,\n\t\tCS4271_MODE1_MODE_MASK | CS4271_MODE1_DIV_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn cs4271_set_deemph(component);\n}\n\nstatic int cs4271_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\tint val_a = 0;\n\tint val_b = 0;\n\n\tif (stream != SNDRV_PCM_STREAM_PLAYBACK)\n\t\treturn 0;\n\n\tif (mute) {\n\t\tval_a = CS4271_VOLA_MUTE;\n\t\tval_b = CS4271_VOLB_MUTE;\n\t}\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_VOLA,\n\t\t\t\t CS4271_VOLA_MUTE, val_a);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_VOLB,\n\t\t\t\t CS4271_VOLB_MUTE, val_b);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic DECLARE_TLV_DB_SCALE(cs4271_dac_tlv, -12700, 100, 0);\n\nstatic const struct snd_kcontrol_new cs4271_snd_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\", CS4271_VOLA, CS4271_VOLB,\n\t\t0, 0x7F, 1, cs4271_dac_tlv),\n\tSOC_SINGLE(\"Digital Loopback Switch\", CS4271_MODE2, 4, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp Switch\", CS4271_DACVOL, 5, 1, 0),\n\tSOC_SINGLE(\"Zero Cross Switch\", CS4271_DACVOL, 4, 1, 0),\n\tSOC_SINGLE_BOOL_EXT(\"De-emphasis Switch\", 0,\n\t\tcs4271_get_deemph, cs4271_put_deemph),\n\tSOC_SINGLE(\"Auto-Mute Switch\", CS4271_DACCTL, 7, 1, 0),\n\tSOC_SINGLE(\"Slow Roll Off Filter Switch\", CS4271_DACCTL, 6, 1, 0),\n\tSOC_SINGLE(\"Soft Volume Ramp-Up Switch\", CS4271_DACCTL, 3, 1, 0),\n\tSOC_SINGLE(\"Soft Ramp-Down Switch\", CS4271_DACCTL, 2, 1, 0),\n\tSOC_SINGLE(\"Left Channel Inversion Switch\", CS4271_DACCTL, 1, 1, 0),\n\tSOC_SINGLE(\"Right Channel Inversion Switch\", CS4271_DACCTL, 0, 1, 0),\n\tSOC_DOUBLE(\"Master Capture Switch\", CS4271_ADCCTL, 3, 2, 1, 1),\n\tSOC_SINGLE(\"Dither 16-Bit Data Switch\", CS4271_ADCCTL, 5, 1, 0),\n\tSOC_DOUBLE(\"High Pass Filter Switch\", CS4271_ADCCTL, 1, 0, 1, 1),\n\tSOC_DOUBLE_R(\"Master Playback Switch\", CS4271_VOLA, CS4271_VOLB,\n\t\t7, 1, 1),\n};\n\nstatic const struct snd_soc_dai_ops cs4271_dai_ops = {\n\t.hw_params\t= cs4271_hw_params,\n\t.set_sysclk\t= cs4271_set_dai_sysclk,\n\t.set_fmt\t= cs4271_set_dai_fmt,\n\t.mute_stream\t= cs4271_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver cs4271_dai = {\n\t.name = \"cs4271-hifi\",\n\t.playback = {\n\t\t.stream_name\t= \"Playback\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= CS4271_PCM_RATES,\n\t\t.formats\t= CS4271_PCM_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name\t= \"Capture\",\n\t\t.channels_min\t= 2,\n\t\t.channels_max\t= 2,\n\t\t.rates\t\t= CS4271_PCM_RATES,\n\t\t.formats\t= CS4271_PCM_FORMATS,\n\t},\n\t.ops = &cs4271_dai_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int cs4271_reset(struct snd_soc_component *component)\n{\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tif (gpio_is_valid(cs4271->gpio_nreset)) {\n\t\tgpio_direction_output(cs4271->gpio_nreset, 0);\n\t\tmdelay(1);\n\t\tgpio_set_value(cs4271->gpio_nreset, 1);\n\t\tmdelay(1);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int cs4271_soc_suspend(struct snd_soc_component *component)\n{\n\tint ret;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\t \n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t CS4271_MODE2_PDN, CS4271_MODE2_PDN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tregcache_mark_dirty(cs4271->regmap);\n\tregulator_bulk_disable(ARRAY_SIZE(cs4271->supplies), cs4271->supplies);\n\n\treturn 0;\n}\n\nstatic int cs4271_soc_resume(struct snd_soc_component *component)\n{\n\tint ret;\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs4271->supplies),\n\t\t\t\t    cs4271->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs4271_reset(component);\n\n\t \n\tret = regcache_sync(cs4271->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t CS4271_MODE2_PDN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\n#define cs4271_soc_suspend\tNULL\n#define cs4271_soc_resume\tNULL\n#endif  \n\n#ifdef CONFIG_OF\nconst struct of_device_id cs4271_dt_ids[] = {\n\t{ .compatible = \"cirrus,cs4271\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, cs4271_dt_ids);\nEXPORT_SYMBOL_GPL(cs4271_dt_ids);\n#endif\n\nstatic int cs4271_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\tstruct cs4271_platform_data *cs4271plat = component->dev->platform_data;\n\tint ret;\n\tbool amutec_eq_bmutec = false;\n\n#ifdef CONFIG_OF\n\tif (of_match_device(cs4271_dt_ids, component->dev)) {\n\t\tif (of_get_property(component->dev->of_node,\n\t\t\t\t     \"cirrus,amutec-eq-bmutec\", NULL))\n\t\t\tamutec_eq_bmutec = true;\n\n\t\tif (of_get_property(component->dev->of_node,\n\t\t\t\t     \"cirrus,enable-soft-reset\", NULL))\n\t\t\tcs4271->enable_soft_reset = true;\n\t}\n#endif\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs4271->supplies),\n\t\t\t\t    cs4271->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (cs4271plat) {\n\t\tamutec_eq_bmutec = cs4271plat->amutec_eq_bmutec;\n\t\tcs4271->enable_soft_reset = cs4271plat->enable_soft_reset;\n\t}\n\n\t \n\tcs4271_reset(component);\n\n\tret = regcache_sync(cs4271->regmap);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t CS4271_MODE2_PDN | CS4271_MODE2_CPEN,\n\t\t\t\t CS4271_MODE2_PDN | CS4271_MODE2_CPEN);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = regmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t CS4271_MODE2_PDN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tudelay(85);\n\n\tif (amutec_eq_bmutec)\n\t\tregmap_update_bits(cs4271->regmap, CS4271_MODE2,\n\t\t\t\t   CS4271_MODE2_MUTECAEQUB,\n\t\t\t\t   CS4271_MODE2_MUTECAEQUB);\n\n\treturn 0;\n}\n\nstatic void cs4271_component_remove(struct snd_soc_component *component)\n{\n\tstruct cs4271_private *cs4271 = snd_soc_component_get_drvdata(component);\n\n\tif (gpio_is_valid(cs4271->gpio_nreset))\n\t\t \n\t\tgpio_set_value(cs4271->gpio_nreset, 0);\n\n\tregcache_mark_dirty(cs4271->regmap);\n\tregulator_bulk_disable(ARRAY_SIZE(cs4271->supplies), cs4271->supplies);\n};\n\nstatic const struct snd_soc_component_driver soc_component_dev_cs4271 = {\n\t.probe\t\t\t= cs4271_component_probe,\n\t.remove\t\t\t= cs4271_component_remove,\n\t.suspend\t\t= cs4271_soc_suspend,\n\t.resume\t\t\t= cs4271_soc_resume,\n\t.controls\t\t= cs4271_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs4271_snd_controls),\n\t.dapm_widgets\t\t= cs4271_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs4271_dapm_widgets),\n\t.dapm_routes\t\t= cs4271_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs4271_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic int cs4271_common_probe(struct device *dev,\n\t\t\t       struct cs4271_private **c)\n{\n\tstruct cs4271_platform_data *cs4271plat = dev->platform_data;\n\tstruct cs4271_private *cs4271;\n\tint i, ret;\n\n\tcs4271 = devm_kzalloc(dev, sizeof(*cs4271), GFP_KERNEL);\n\tif (!cs4271)\n\t\treturn -ENOMEM;\n\n\tif (of_match_device(cs4271_dt_ids, dev))\n\t\tcs4271->gpio_nreset =\n\t\t\tof_get_named_gpio(dev->of_node, \"reset-gpio\", 0);\n\n\tif (cs4271plat)\n\t\tcs4271->gpio_nreset = cs4271plat->gpio_nreset;\n\n\tif (gpio_is_valid(cs4271->gpio_nreset)) {\n\t\tret = devm_gpio_request(dev, cs4271->gpio_nreset,\n\t\t\t\t\t\"CS4271 Reset\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\n\t\tcs4271->supplies[i].supply = supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(cs4271->supplies),\n\t\t\t\t\tcs4271->supplies);\n\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to get regulators: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*c = cs4271;\n\treturn 0;\n}\n\nconst struct regmap_config cs4271_regmap_config = {\n\t.max_register = CS4271_LASTREG,\n\n\t.reg_defaults = cs4271_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs4271_reg_defaults),\n\t.cache_type = REGCACHE_FLAT,\n\t.val_bits = 8,\n\t.volatile_reg = cs4271_volatile_reg,\n};\nEXPORT_SYMBOL_GPL(cs4271_regmap_config);\n\nint cs4271_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct cs4271_private *cs4271;\n\tint ret;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = cs4271_common_probe(dev, &cs4271);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_set_drvdata(dev, cs4271);\n\tcs4271->regmap = regmap;\n\n\treturn devm_snd_soc_register_component(dev, &soc_component_dev_cs4271,\n\t\t\t\t\t       &cs4271_dai, 1);\n}\nEXPORT_SYMBOL_GPL(cs4271_probe);\n\nMODULE_AUTHOR(\"Alexander Sverdlin <subaparts@yandex.ru>\");\nMODULE_DESCRIPTION(\"Cirrus Logic CS4271 ALSA SoC Codec Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}