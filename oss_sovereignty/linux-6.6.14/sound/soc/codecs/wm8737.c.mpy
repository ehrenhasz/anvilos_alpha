{
  "module_name": "wm8737.c",
  "hash_id": "ad143db71b839f847a8d87a0c6e6f5574eda852f3681429d7d83cc848ab3ccad",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8737.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include \"wm8737.h\"\n\n#define WM8737_NUM_SUPPLIES 4\nstatic const char *wm8737_supply_names[WM8737_NUM_SUPPLIES] = {\n\t\"DCVDD\",\n\t\"DBVDD\",\n\t\"AVDD\",\n\t\"MVDD\",\n};\n\n \nstruct wm8737_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8737_NUM_SUPPLIES];\n\tunsigned int mclk;\n};\n\nstatic const struct reg_default wm8737_reg_defaults[] = {\n\t{  0, 0x00C3 },      \n\t{  1, 0x00C3 },      \n\t{  2, 0x0007 },      \n\t{  3, 0x0007 },      \n\t{  4, 0x0000 },      \n\t{  5, 0x0000 },      \n\t{  6, 0x0000 },      \n\t{  7, 0x000A },      \n\t{  8, 0x0000 },      \n\t{  9, 0x000F },      \n\t{ 10, 0x0003 },      \n\t{ 11, 0x0000 },      \n\t{ 12, 0x007C },      \n\t{ 13, 0x0000 },      \n\t{ 14, 0x0032 },      \n};\n\nstatic bool wm8737_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8737_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int wm8737_reset(struct snd_soc_component *component)\n{\n\treturn snd_soc_component_write(component, WM8737_RESET, 0);\n}\n\nstatic const DECLARE_TLV_DB_RANGE(micboost_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(1300, 0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(1800, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(2800, 0, 0),\n\t3, 3, TLV_DB_SCALE_ITEM(3300, 0, 0)\n);\nstatic const DECLARE_TLV_DB_SCALE(pga_tlv, -9750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(adc_tlv, -600, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(ng_tlv, -7800, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_max_tlv, -1200, 600, 0);\nstatic const DECLARE_TLV_DB_SCALE(alc_target_tlv, -1800, 100, 0);\n\nstatic const char *micbias_enum_text[] = {\n\t\"25%\",\n\t\"50%\",\n\t\"75%\",\n\t\"100%\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(micbias_enum,\n\t\t\t    WM8737_MIC_PREAMP_CONTROL, 0, micbias_enum_text);\n\nstatic const char *low_cutoff_text[] = {\n\t\"Low\", \"High\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(low_3d,\n\t\t\t    WM8737_3D_ENHANCE, 6, low_cutoff_text);\n\nstatic const char *high_cutoff_text[] = {\n\t\"High\", \"Low\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(high_3d,\n\t\t\t    WM8737_3D_ENHANCE, 5, high_cutoff_text);\n\nstatic const char *alc_fn_text[] = {\n\t\"Disabled\", \"Right\", \"Left\", \"Stereo\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(alc_fn,\n\t\t\t    WM8737_ALC1, 7, alc_fn_text);\n\nstatic const char *alc_hold_text[] = {\n\t\"0\", \"2.67ms\", \"5.33ms\", \"10.66ms\", \"21.32ms\", \"42.64ms\", \"85.28ms\",\n\t\"170.56ms\", \"341.12ms\", \"682.24ms\", \"1.364s\", \"2.728s\", \"5.458s\",\n\t\"10.916s\", \"21.832s\", \"43.691s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(alc_hold,\n\t\t\t    WM8737_ALC2, 0, alc_hold_text);\n\nstatic const char *alc_atk_text[] = {\n\t\"8.4ms\", \"16.8ms\", \"33.6ms\", \"67.2ms\", \"134.4ms\", \"268.8ms\", \"537.6ms\",\n\t\"1.075s\", \"2.15s\", \"4.3s\", \"8.6s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(alc_atk,\n\t\t\t    WM8737_ALC3, 0, alc_atk_text);\n\nstatic const char *alc_dcy_text[] = {\n\t\"33.6ms\", \"67.2ms\", \"134.4ms\", \"268.8ms\", \"537.6ms\", \"1.075s\", \"2.15s\",\n\t\"4.3s\", \"8.6s\", \"17.2s\", \"34.41s\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(alc_dcy,\n\t\t\t    WM8737_ALC3, 4, alc_dcy_text);\n\nstatic const struct snd_kcontrol_new wm8737_snd_controls[] = {\nSOC_DOUBLE_R_TLV(\"Mic Boost Volume\", WM8737_AUDIO_PATH_L, WM8737_AUDIO_PATH_R,\n\t\t 6, 3, 0, micboost_tlv),\nSOC_DOUBLE_R(\"Mic Boost Switch\", WM8737_AUDIO_PATH_L, WM8737_AUDIO_PATH_R,\n\t     4, 1, 0),\nSOC_DOUBLE(\"Mic ZC Switch\", WM8737_AUDIO_PATH_L, WM8737_AUDIO_PATH_R,\n\t   3, 1, 0),\n\nSOC_DOUBLE_R_TLV(\"Capture Volume\", WM8737_LEFT_PGA_VOLUME,\n\t\t WM8737_RIGHT_PGA_VOLUME, 0, 255, 0, pga_tlv),\nSOC_DOUBLE(\"Capture ZC Switch\", WM8737_AUDIO_PATH_L, WM8737_AUDIO_PATH_R,\n\t   2, 1, 0),\n\nSOC_DOUBLE(\"INPUT1 DC Bias Switch\", WM8737_MISC_BIAS_CONTROL, 0, 1, 1, 0),\n\nSOC_ENUM(\"Mic PGA Bias\", micbias_enum),\nSOC_SINGLE(\"ADC Low Power Switch\", WM8737_ADC_CONTROL, 2, 1, 0),\nSOC_SINGLE(\"High Pass Filter Switch\", WM8737_ADC_CONTROL, 0, 1, 1),\nSOC_DOUBLE(\"Polarity Invert Switch\", WM8737_ADC_CONTROL, 5, 6, 1, 0),\n\nSOC_SINGLE(\"3D Switch\", WM8737_3D_ENHANCE, 0, 1, 0),\nSOC_SINGLE(\"3D Depth\", WM8737_3D_ENHANCE, 1, 15, 0),\nSOC_ENUM(\"3D Low Cut-off\", low_3d),\nSOC_ENUM(\"3D High Cut-off\", high_3d),\nSOC_SINGLE_TLV(\"3D ADC Volume\", WM8737_3D_ENHANCE, 7, 1, 1, adc_tlv),\n\nSOC_SINGLE(\"Noise Gate Switch\", WM8737_NOISE_GATE, 0, 1, 0),\nSOC_SINGLE_TLV(\"Noise Gate Threshold Volume\", WM8737_NOISE_GATE, 2, 7, 0,\n\t       ng_tlv),\n\nSOC_ENUM(\"ALC\", alc_fn),\nSOC_SINGLE_TLV(\"ALC Max Gain Volume\", WM8737_ALC1, 4, 7, 0, alc_max_tlv),\nSOC_SINGLE_TLV(\"ALC Target Volume\", WM8737_ALC1, 0, 15, 0, alc_target_tlv),\nSOC_ENUM(\"ALC Hold Time\", alc_hold),\nSOC_SINGLE(\"ALC ZC Switch\", WM8737_ALC2, 4, 1, 0),\nSOC_ENUM(\"ALC Attack Time\", alc_atk),\nSOC_ENUM(\"ALC Decay Time\", alc_dcy),\n};\n\nstatic const char *linsel_text[] = {\n\t\"LINPUT1\", \"LINPUT2\", \"LINPUT3\", \"LINPUT1 DC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(linsel_enum,\n\t\t\t    WM8737_AUDIO_PATH_L, 7, linsel_text);\n\nstatic const struct snd_kcontrol_new linsel_mux =\n\tSOC_DAPM_ENUM(\"LINSEL\", linsel_enum);\n\n\nstatic const char *rinsel_text[] = {\n\t\"RINPUT1\", \"RINPUT2\", \"RINPUT3\", \"RINPUT1 DC\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(rinsel_enum,\n\t\t\t    WM8737_AUDIO_PATH_R, 7, rinsel_text);\n\nstatic const struct snd_kcontrol_new rinsel_mux =\n\tSOC_DAPM_ENUM(\"RINSEL\", rinsel_enum);\n\nstatic const char *bypass_text[] = {\n\t\"Direct\", \"Preamp\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(lbypass_enum,\n\t\t\t    WM8737_MIC_PREAMP_CONTROL, 2, bypass_text);\n\nstatic const struct snd_kcontrol_new lbypass_mux =\n\tSOC_DAPM_ENUM(\"Left Bypass\", lbypass_enum);\n\n\nstatic SOC_ENUM_SINGLE_DECL(rbypass_enum,\n\t\t\t    WM8737_MIC_PREAMP_CONTROL, 3, bypass_text);\n\nstatic const struct snd_kcontrol_new rbypass_mux =\n\tSOC_DAPM_ENUM(\"Left Bypass\", rbypass_enum);\n\nstatic const struct snd_soc_dapm_widget wm8737_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"LINPUT1\"),\nSND_SOC_DAPM_INPUT(\"LINPUT2\"),\nSND_SOC_DAPM_INPUT(\"LINPUT3\"),\nSND_SOC_DAPM_INPUT(\"RINPUT1\"),\nSND_SOC_DAPM_INPUT(\"RINPUT2\"),\nSND_SOC_DAPM_INPUT(\"RINPUT3\"),\nSND_SOC_DAPM_INPUT(\"LACIN\"),\nSND_SOC_DAPM_INPUT(\"RACIN\"),\n\nSND_SOC_DAPM_MUX(\"LINSEL\", SND_SOC_NOPM, 0, 0, &linsel_mux),\nSND_SOC_DAPM_MUX(\"RINSEL\", SND_SOC_NOPM, 0, 0, &rinsel_mux),\n\nSND_SOC_DAPM_MUX(\"Left Preamp Mux\", SND_SOC_NOPM, 0, 0, &lbypass_mux),\nSND_SOC_DAPM_MUX(\"Right Preamp Mux\", SND_SOC_NOPM, 0, 0, &rbypass_mux),\n\nSND_SOC_DAPM_PGA(\"PGAL\", WM8737_POWER_MANAGEMENT, 5, 0, NULL, 0),\nSND_SOC_DAPM_PGA(\"PGAR\", WM8737_POWER_MANAGEMENT, 4, 0, NULL, 0),\n\nSND_SOC_DAPM_DAC(\"ADCL\", NULL, WM8737_POWER_MANAGEMENT, 3, 0),\nSND_SOC_DAPM_DAC(\"ADCR\", NULL, WM8737_POWER_MANAGEMENT, 2, 0),\n\nSND_SOC_DAPM_AIF_OUT(\"AIF\", \"Capture\", 0, WM8737_POWER_MANAGEMENT, 6, 0),\n};\n\nstatic const struct snd_soc_dapm_route intercon[] = {\n\t{ \"LINSEL\", \"LINPUT1\", \"LINPUT1\" },\n\t{ \"LINSEL\", \"LINPUT2\", \"LINPUT2\" },\n\t{ \"LINSEL\", \"LINPUT3\", \"LINPUT3\" },\n\t{ \"LINSEL\", \"LINPUT1 DC\", \"LINPUT1\" },\n\n\t{ \"RINSEL\", \"RINPUT1\", \"RINPUT1\" },\n\t{ \"RINSEL\", \"RINPUT2\", \"RINPUT2\" },\n\t{ \"RINSEL\", \"RINPUT3\", \"RINPUT3\" },\n\t{ \"RINSEL\", \"RINPUT1 DC\", \"RINPUT1\" },\n\n\t{ \"Left Preamp Mux\", \"Preamp\", \"LINSEL\" },\n\t{ \"Left Preamp Mux\", \"Direct\", \"LACIN\" },\n\n\t{ \"Right Preamp Mux\", \"Preamp\", \"RINSEL\" },\n\t{ \"Right Preamp Mux\", \"Direct\", \"RACIN\" },\n\n\t{ \"PGAL\", NULL, \"Left Preamp Mux\" },\n\t{ \"PGAR\", NULL, \"Right Preamp Mux\" },\n\n\t{ \"ADCL\", NULL, \"PGAL\" },\n\t{ \"ADCR\", NULL, \"PGAR\" },\n\n\t{ \"AIF\", NULL, \"ADCL\" },\n\t{ \"AIF\", NULL, \"ADCR\" },\n};\n\n \nstatic const struct {\n\tu32 mclk;\n\tu32 rate;\n\tu8 usb;\n\tu8 sr;\n} coeff_div[] = {\n\t{ 12288000,  8000, 0,  0x4 },\n\t{ 12288000, 12000, 0,  0x8 },\n\t{ 12288000, 16000, 0,  0xa },\n\t{ 12288000, 24000, 0, 0x1c },\n\t{ 12288000, 32000, 0,  0xc },\n\t{ 12288000, 48000, 0,    0 },\n\t{ 12288000, 96000, 0,  0xe },\n\n\t{ 11289600,  8000, 0, 0x14 },\n\t{ 11289600, 11025, 0, 0x18 },\n\t{ 11289600, 22050, 0, 0x1a },\n\t{ 11289600, 44100, 0, 0x10 },\n\t{ 11289600, 88200, 0, 0x1e },\n\n\t{ 18432000,  8000, 0,  0x5 },\n\t{ 18432000, 12000, 0,  0x9 },\n\t{ 18432000, 16000, 0,  0xb },\n\t{ 18432000, 24000, 0, 0x1b },\n\t{ 18432000, 32000, 0,  0xd },\n\t{ 18432000, 48000, 0,  0x1 },\n\t{ 18432000, 96000, 0, 0x1f },\n\n\t{ 16934400,  8000, 0, 0x15 },\n\t{ 16934400, 11025, 0, 0x19 },\n\t{ 16934400, 22050, 0, 0x1b },\n\t{ 16934400, 44100, 0, 0x11 },\n\t{ 16934400, 88200, 0, 0x1f },\n\n\t{ 12000000,  8000, 1,  0x4 },\n\t{ 12000000, 11025, 1, 0x19 },\n\t{ 12000000, 12000, 1,  0x8 },\n\t{ 12000000, 16000, 1,  0xa },\n\t{ 12000000, 22050, 1, 0x1b },\n\t{ 12000000, 24000, 1, 0x1c },\n\t{ 12000000, 32000, 1,  0xc },\n\t{ 12000000, 44100, 1, 0x11 },\n\t{ 12000000, 48000, 1,  0x0 },\n\t{ 12000000, 88200, 1, 0x1f },\n\t{ 12000000, 96000, 1,  0xe },\n};\n\nstatic int wm8737_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8737_priv *wm8737 = snd_soc_component_get_drvdata(component);\n\tint i;\n\tu16 clocking = 0;\n\tu16 af = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (coeff_div[i].rate != params_rate(params))\n\t\t\tcontinue;\n\n\t\tif (coeff_div[i].mclk == wm8737->mclk)\n\t\t\tbreak;\n\n\t\tif (coeff_div[i].mclk == wm8737->mclk * 2) {\n\t\t\tclocking |= WM8737_CLKDIV2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(coeff_div)) {\n\t\tdev_err(component->dev, \"%dHz MCLK can't support %dHz\\n\",\n\t\t\twm8737->mclk, params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\tclocking |= coeff_div[i].usb | (coeff_div[i].sr << WM8737_SR_SHIFT);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tbreak;\n\tcase 20:\n\t\taf |= 0x8;\n\t\tbreak;\n\tcase 24:\n\t\taf |= 0x10;\n\t\tbreak;\n\tcase 32:\n\t\taf |= 0x18;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8737_AUDIO_FORMAT, WM8737_WL_MASK, af);\n\tsnd_soc_component_update_bits(component, WM8737_CLOCKING,\n\t\t\t    WM8737_USB_MODE | WM8737_CLKDIV2 | WM8737_SR_MASK,\n\t\t\t    clocking);\n\n\treturn 0;\n}\n\nstatic int wm8737_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8737_priv *wm8737 = snd_soc_component_get_drvdata(component);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\n\t\tif (freq == coeff_div[i].mclk ||\n\t\t    freq == coeff_div[i].mclk * 2) {\n\t\t\twm8737->mclk = freq;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(component->dev, \"MCLK rate %dHz not supported\\n\", freq);\n\n\treturn -EINVAL;\n}\n\n\nstatic int wm8737_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\tunsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tu16 af = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taf |= WM8737_MS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\taf |= 0x2;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\taf |= 0x1;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\taf |= 0x3;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\taf |= 0x13;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\taf |= WM8737_LRP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8737_AUDIO_FORMAT,\n\t\t\t    WM8737_FORMAT_MASK | WM8737_LRP | WM8737_MS, af);\n\n\treturn 0;\n}\n\nstatic int wm8737_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct wm8737_priv *wm8737 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8737_MISC_BIAS_CONTROL,\n\t\t\t\t    WM8737_VMIDSEL_MASK, 0);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(ARRAY_SIZE(wm8737->supplies),\n\t\t\t\t\t\t    wm8737->supplies);\n\t\t\tif (ret != 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tregcache_sync(wm8737->regmap);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8737_MISC_BIAS_CONTROL,\n\t\t\t\t\t    WM8737_VMIDSEL_MASK,\n\t\t\t\t\t    2 << WM8737_VMIDSEL_SHIFT);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8737_POWER_MANAGEMENT,\n\t\t\t\t\t    WM8737_VMID_MASK |\n\t\t\t\t\t    WM8737_VREF_MASK,\n\t\t\t\t\t    WM8737_VMID_MASK |\n\t\t\t\t\t    WM8737_VREF_MASK);\n\n\t\t\tmsleep(500);\n\t\t}\n\n\t\t \n\t\tsnd_soc_component_update_bits(component, WM8737_MISC_BIAS_CONTROL,\n\t\t\t\t    WM8737_VMIDSEL_MASK,\n\t\t\t\t    1 << WM8737_VMIDSEL_SHIFT);\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8737_POWER_MANAGEMENT,\n\t\t\t\t    WM8737_VMID_MASK | WM8737_VREF_MASK, 0);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(wm8737->supplies),\n\t\t\t\t       wm8737->supplies);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define WM8737_RATES SNDRV_PCM_RATE_8000_96000\n\n#define WM8737_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8737_dai_ops = {\n\t.hw_params\t= wm8737_hw_params,\n\t.set_sysclk\t= wm8737_set_dai_sysclk,\n\t.set_fmt\t= wm8737_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver wm8737_dai = {\n\t.name = \"wm8737\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,   \n\t\t.channels_max = 2,\n\t\t.rates = WM8737_RATES,\n\t\t.formats = WM8737_FORMATS,\n\t},\n\t.ops = &wm8737_dai_ops,\n};\n\nstatic int wm8737_probe(struct snd_soc_component *component)\n{\n\tstruct wm8737_priv *wm8737 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8737->supplies),\n\t\t\t\t    wm8737->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_get;\n\t}\n\n\tret = wm8737_reset(component);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to issue reset\\n\");\n\t\tgoto err_enable;\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8737_LEFT_PGA_VOLUME, WM8737_LVU,\n\t\t\t    WM8737_LVU);\n\tsnd_soc_component_update_bits(component, WM8737_RIGHT_PGA_VOLUME, WM8737_RVU,\n\t\t\t    WM8737_RVU);\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(wm8737->supplies), wm8737->supplies);\n\n\treturn 0;\n\nerr_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8737->supplies), wm8737->supplies);\nerr_get:\n\treturn ret;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8737 = {\n\t.probe\t\t\t= wm8737_probe,\n\t.set_bias_level\t\t= wm8737_set_bias_level,\n\t.controls\t\t= wm8737_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8737_snd_controls),\n\t.dapm_widgets\t\t= wm8737_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8737_dapm_widgets),\n\t.dapm_routes\t\t= intercon,\n\t.num_dapm_routes\t= ARRAY_SIZE(intercon),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct of_device_id wm8737_of_match[] = {\n\t{ .compatible = \"wlf,wm8737\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, wm8737_of_match);\n\nstatic const struct regmap_config wm8737_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8737_MAX_REGISTER,\n\n\t.reg_defaults = wm8737_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8737_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8737_volatile,\n};\n\n#if IS_ENABLED(CONFIG_I2C)\nstatic int wm8737_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct wm8737_priv *wm8737;\n\tint ret, i;\n\n\twm8737 = devm_kzalloc(&i2c->dev, sizeof(struct wm8737_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8737 == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8737->supplies); i++)\n\t\twm8737->supplies[i].supply = wm8737_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8737->supplies),\n\t\t\t\t      wm8737->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8737->regmap = devm_regmap_init_i2c(i2c, &wm8737_regmap);\n\tif (IS_ERR(wm8737->regmap))\n\t\treturn PTR_ERR(wm8737->regmap);\n\n\ti2c_set_clientdata(i2c, wm8737);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t\t&soc_component_dev_wm8737, &wm8737_dai, 1);\n\n\treturn ret;\n\n}\n\nstatic const struct i2c_device_id wm8737_i2c_id[] = {\n\t{ \"wm8737\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8737_i2c_id);\n\nstatic struct i2c_driver wm8737_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8737\",\n\t\t.of_match_table = wm8737_of_match,\n\t},\n\t.probe = wm8737_i2c_probe,\n\t.id_table = wm8737_i2c_id,\n};\n#endif\n\n#if defined(CONFIG_SPI_MASTER)\nstatic int wm8737_spi_probe(struct spi_device *spi)\n{\n\tstruct wm8737_priv *wm8737;\n\tint ret, i;\n\n\twm8737 = devm_kzalloc(&spi->dev, sizeof(struct wm8737_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8737 == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8737->supplies); i++)\n\t\twm8737->supplies[i].supply = wm8737_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&spi->dev, ARRAY_SIZE(wm8737->supplies),\n\t\t\t\t      wm8737->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&spi->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\twm8737->regmap = devm_regmap_init_spi(spi, &wm8737_regmap);\n\tif (IS_ERR(wm8737->regmap))\n\t\treturn PTR_ERR(wm8737->regmap);\n\n\tspi_set_drvdata(spi, wm8737);\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t\t&soc_component_dev_wm8737, &wm8737_dai, 1);\n\n\treturn ret;\n}\n\nstatic struct spi_driver wm8737_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"wm8737\",\n\t\t.of_match_table = wm8737_of_match,\n\t},\n\t.probe\t\t= wm8737_spi_probe,\n};\n#endif  \n\nstatic int __init wm8737_modinit(void)\n{\n\tint ret;\n#if IS_ENABLED(CONFIG_I2C)\n\tret = i2c_add_driver(&wm8737_i2c_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8737 I2C driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n#if defined(CONFIG_SPI_MASTER)\n\tret = spi_register_driver(&wm8737_spi_driver);\n\tif (ret != 0) {\n\t\tprintk(KERN_ERR \"Failed to register WM8737 SPI driver: %d\\n\",\n\t\t       ret);\n\t}\n#endif\n\treturn 0;\n}\nmodule_init(wm8737_modinit);\n\nstatic void __exit wm8737_exit(void)\n{\n#if defined(CONFIG_SPI_MASTER)\n\tspi_unregister_driver(&wm8737_spi_driver);\n#endif\n#if IS_ENABLED(CONFIG_I2C)\n\ti2c_del_driver(&wm8737_i2c_driver);\n#endif\n}\nmodule_exit(wm8737_exit);\n\nMODULE_DESCRIPTION(\"ASoC WM8737 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}