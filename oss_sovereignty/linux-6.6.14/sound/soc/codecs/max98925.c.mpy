{
  "module_name": "max98925.c",
  "hash_id": "12055d10bc45ba01862b6121bcea638f73e9aee20df168ac2bd8b6acb3559aa2",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/max98925.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/cdev.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include \"max98925.h\"\n\nstatic const char *const dai_text[] = {\n\t\"Left\", \"Right\", \"LeftRight\", \"LeftRightDiv2\",\n};\n\nstatic const char * const max98925_boost_voltage_text[] = {\n\t\"8.5V\", \"8.25V\", \"8.0V\", \"7.75V\", \"7.5V\", \"7.25V\", \"7.0V\", \"6.75V\",\n\t\"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\", \"6.5V\",\t\"6.5V\", \"6.5V\"\n};\n\nstatic SOC_ENUM_SINGLE_DECL(max98925_boost_voltage,\n\tMAX98925_CONFIGURATION, M98925_BST_VOUT_SHIFT,\n\tmax98925_boost_voltage_text);\n\nstatic const char *const hpf_text[] = {\n\t\"Disable\", \"DC Block\", \"100Hz\",\t\"200Hz\", \"400Hz\", \"800Hz\",\n};\n\nstatic const struct reg_default max98925_reg[] = {\n\t{ 0x0B, 0x00 },  \n\t{ 0x0C, 0x00 },  \n\t{ 0x0D, 0x00 },  \n\t{ 0x0E, 0x00 },  \n\t{ 0x0F, 0x00 },  \n\t{ 0x10, 0x00 },  \n\t{ 0x11, 0xC0 },  \n\t{ 0x12, 0x00 },  \n\t{ 0x13, 0x00 },  \n\t{ 0x14, 0xF0 },  \n\t{ 0x15, 0x00 },  \n\t{ 0x16, 0xAB },  \n\t{ 0x17, 0x89 },  \n\t{ 0x18, 0x00 },  \n\t{ 0x19, 0x00 },  \n\t{ 0x1A, 0x06 },  \n\t{ 0x1B, 0xC0 },  \n\t{ 0x1C, 0x00 },  \n\t{ 0x1D, 0x00 },  \n\t{ 0x1E, 0xF0 },  \n\t{ 0x1F, 0x00 },  \n\t{ 0x20, 0x50 },  \n\t{ 0x21, 0x00 },  \n\t{ 0x22, 0x00 },  \n\t{ 0x23, 0x00 },  \n\t{ 0x24, 0x00 },  \n\t{ 0x25, 0x00 },  \n\t{ 0x26, 0x00 },  \n\t{ 0x27, 0xFF },  \n\t{ 0x28, 0xFF },  \n\t{ 0x29, 0xFF },  \n\t{ 0x2A, 0xFF },  \n\t{ 0x2B, 0x02 },  \n\t{ 0x2C, 0x90 },  \n\t{ 0x2D, 0x00 },  \n\t{ 0x2E, 0x02 },  \n\t{ 0x2F, 0x00 },  \n\t{ 0x30, 0x0A },  \n\t{ 0x31, 0x00 },  \n\t{ 0x32, 0x80 },  \n\t{ 0x33, 0x00 },  \n\t{ 0x34, 0x92 },  \n\t{ 0x35, 0x01 },  \n\t{ 0x36, 0x00 },  \n\t{ 0x37, 0x00 },  \n\t{ 0x38, 0x00 },  \n\t{ 0x3A, 0x00 },  \n};\n\nstatic const struct soc_enum max98925_dai_enum =\n\tSOC_ENUM_SINGLE(MAX98925_GAIN, 5, ARRAY_SIZE(dai_text), dai_text);\n\nstatic const struct soc_enum max98925_hpf_enum =\n\tSOC_ENUM_SINGLE(MAX98925_FILTERS, 0, ARRAY_SIZE(hpf_text), hpf_text);\n\nstatic const struct snd_kcontrol_new max98925_hpf_sel_mux =\n\tSOC_DAPM_ENUM(\"Rc Filter MUX Mux\", max98925_hpf_enum);\n\nstatic const struct snd_kcontrol_new max98925_dai_sel_mux =\n\tSOC_DAPM_ENUM(\"DAI IN MUX Mux\", max98925_dai_enum);\n\nstatic int max98925_dac_event(struct snd_soc_dapm_widget *w,\n\t\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct max98925_priv *max98925 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_PRE_PMU:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_BLOCK_ENABLE,\n\t\t\tM98925_BST_EN_MASK |\n\t\t\tM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK,\n\t\t\tM98925_BST_EN_MASK |\n\t\t\tM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK);\n\t\tbreak;\n\tcase SND_SOC_DAPM_POST_PMD:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_BLOCK_ENABLE, M98925_BST_EN_MASK |\n\t\t\tM98925_ADC_IMON_EN_MASK | M98925_ADC_VMON_EN_MASK, 0);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget max98925_dapm_widgets[] = {\n\tSND_SOC_DAPM_AIF_IN(\"DAI_OUT\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_MUX(\"DAI IN MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t\t&max98925_dai_sel_mux),\n\tSND_SOC_DAPM_MUX(\"Rc Filter MUX\", SND_SOC_NOPM, 0, 0,\n\t\t\t\t&max98925_hpf_sel_mux),\n\tSND_SOC_DAPM_DAC_E(\"Amp Enable\", NULL, MAX98925_BLOCK_ENABLE,\n\t\t\tM98925_SPK_EN_SHIFT, 0, max98925_dac_event,\n\t\t\tSND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"Global Enable\", MAX98925_GLOBAL_ENABLE,\n\t\t\tM98925_EN_SHIFT, 0, NULL, 0),\n\tSND_SOC_DAPM_OUTPUT(\"BE_OUT\"),\n};\n\nstatic const struct snd_soc_dapm_route max98925_audio_map[] = {\n\t{\"DAI IN MUX\", \"Left\", \"DAI_OUT\"},\n\t{\"DAI IN MUX\", \"Right\", \"DAI_OUT\"},\n\t{\"DAI IN MUX\", \"LeftRight\", \"DAI_OUT\"},\n\t{\"DAI IN MUX\", \"LeftRightDiv2\", \"DAI_OUT\"},\n\t{\"Rc Filter MUX\", \"Disable\", \"DAI IN MUX\"},\n\t{\"Rc Filter MUX\", \"DC Block\", \"DAI IN MUX\"},\n\t{\"Rc Filter MUX\", \"100Hz\", \"DAI IN MUX\"},\n\t{\"Rc Filter MUX\", \"200Hz\", \"DAI IN MUX\"},\n\t{\"Rc Filter MUX\", \"400Hz\", \"DAI IN MUX\"},\n\t{\"Rc Filter MUX\", \"800Hz\", \"DAI IN MUX\"},\n\t{\"Amp Enable\", NULL, \"Rc Filter MUX\"},\n\t{\"BE_OUT\", NULL, \"Amp Enable\"},\n\t{\"BE_OUT\", NULL, \"Global Enable\"},\n};\n\nstatic bool max98925_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98925_VBAT_DATA:\n\tcase MAX98925_VBST_DATA:\n\tcase MAX98925_LIVE_STATUS0:\n\tcase MAX98925_LIVE_STATUS1:\n\tcase MAX98925_LIVE_STATUS2:\n\tcase MAX98925_STATE0:\n\tcase MAX98925_STATE1:\n\tcase MAX98925_STATE2:\n\tcase MAX98925_FLAG0:\n\tcase MAX98925_FLAG1:\n\tcase MAX98925_FLAG2:\n\tcase MAX98925_REV_VERSION:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool max98925_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase MAX98925_IRQ_CLEAR0:\n\tcase MAX98925_IRQ_CLEAR1:\n\tcase MAX98925_IRQ_CLEAR2:\n\tcase MAX98925_ALC_HOLD_RLS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(max98925_spk_tlv, -600, 100, 0);\n\nstatic const struct snd_kcontrol_new max98925_snd_controls[] = {\n\tSOC_SINGLE_TLV(\"Speaker Volume\", MAX98925_GAIN,\n\t\tM98925_SPK_GAIN_SHIFT, (1<<M98925_SPK_GAIN_WIDTH)-1, 0,\n\t\tmax98925_spk_tlv),\n\tSOC_SINGLE(\"Ramp Switch\", MAX98925_GAIN_RAMPING,\n\t\t\t\tM98925_SPK_RMP_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ZCD Switch\", MAX98925_GAIN_RAMPING,\n\t\t\t\tM98925_SPK_ZCD_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Switch\", MAX98925_THRESHOLD,\n\t\t\t\tM98925_ALC_EN_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ALC Threshold\", MAX98925_THRESHOLD, M98925_ALC_TH_SHIFT,\n\t\t\t\t(1<<M98925_ALC_TH_WIDTH)-1, 0),\n\tSOC_ENUM(\"Boost Output Voltage\", max98925_boost_voltage),\n};\n\n \nstatic const struct {\n\tint rate;\n\tint  sr;\n\tint divisors[3][2];\n} rate_table[] = {\n\t{\n\t\t.rate = 8000,\n\t\t.sr = 0,\n\t\t.divisors = { {1, 375}, {5, 1764}, {1, 384} }\n\t},\n\t{\n\t\t.rate = 11025,\n\t\t.sr = 1,\n\t\t.divisors = { {147, 40000}, {1, 256}, {147, 40960} }\n\t},\n\t{\n\t\t.rate = 12000,\n\t\t.sr = 2,\n\t\t.divisors = { {1, 250}, {5, 1176}, {1, 256} }\n\t},\n\t{\n\t\t.rate = 16000,\n\t\t.sr = 3,\n\t\t.divisors = { {2, 375}, {5, 882}, {1, 192} }\n\t},\n\t{\n\t\t.rate = 22050,\n\t\t.sr = 4,\n\t\t.divisors = { {147, 20000}, {1, 128}, {147, 20480} }\n\t},\n\t{\n\t\t.rate = 24000,\n\t\t.sr = 5,\n\t\t.divisors = { {1, 125}, {5, 588}, {1, 128} }\n\t},\n\t{\n\t\t.rate = 32000,\n\t\t.sr = 6,\n\t\t.divisors = { {4, 375}, {5, 441}, {1, 96} }\n\t},\n\t{\n\t\t.rate = 44100,\n\t\t.sr = 7,\n\t\t.divisors = { {147, 10000}, {1, 64}, {147, 10240} }\n\t},\n\t{\n\t\t.rate = 48000,\n\t\t.sr = 8,\n\t\t.divisors = { {2, 125}, {5, 294}, {1, 64} }\n\t},\n};\n\nstatic inline int max98925_rate_value(struct snd_soc_component *component,\n\t\tint rate, int clock, int *value, int *n, int *m)\n{\n\tint ret = -EINVAL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\n\t\tif (rate_table[i].rate >= rate) {\n\t\t\t*value = rate_table[i].sr;\n\t\t\t*n = rate_table[i].divisors[clock][0];\n\t\t\t*m = rate_table[i].divisors[clock][1];\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic void max98925_set_sense_data(struct max98925_priv *max98925)\n{\n\t \n\tregmap_update_bits(max98925->regmap,\n\t\tMAX98925_DOUT_CFG_VMON,\n\t\tM98925_DAI_VMON_EN_MASK, M98925_DAI_VMON_EN_MASK);\n\tregmap_update_bits(max98925->regmap,\n\t\tMAX98925_DOUT_CFG_VMON,\n\t\tM98925_DAI_VMON_SLOT_MASK,\n\t\tmax98925->v_slot << M98925_DAI_VMON_SLOT_SHIFT);\n\t \n\tregmap_update_bits(max98925->regmap,\n\t\tMAX98925_DOUT_CFG_IMON,\n\t\tM98925_DAI_IMON_EN_MASK, M98925_DAI_IMON_EN_MASK);\n\tregmap_update_bits(max98925->regmap,\n\t\tMAX98925_DOUT_CFG_IMON,\n\t\tM98925_DAI_IMON_SLOT_MASK,\n\t\tmax98925->i_slot << M98925_DAI_IMON_SLOT_SHIFT);\n}\n\nstatic int max98925_dai_set_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct max98925_priv *max98925 = snd_soc_component_get_drvdata(component);\n\tunsigned int invert = 0;\n\n\tdev_dbg(component->dev, \"%s: fmt 0x%08X\\n\", __func__, fmt);\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_MAS_MASK, 0);\n\t\tmax98925_set_sense_data(max98925);\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\t \n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_MAS_MASK, M98925_DAI_MAS_MASK);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI clock mode unsupported\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tinvert = M98925_DAI_WCI_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\tinvert = M98925_DAI_BCI_MASK;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tinvert = M98925_DAI_BCI_MASK | M98925_DAI_WCI_MASK;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"DAI invert mode unsupported\");\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(max98925->regmap, MAX98925_FORMAT,\n\t\t\tM98925_DAI_BCI_MASK | M98925_DAI_WCI_MASK, invert);\n\treturn 0;\n}\n\nstatic int max98925_set_clock(struct max98925_priv *max98925,\n\t\tstruct snd_pcm_hw_params *params)\n{\n\tunsigned int dai_sr = 0, clock, mdll, n, m;\n\tstruct snd_soc_component *component = max98925->component;\n\tint rate = params_rate(params);\n\t \n\tint blr_clk_ratio = params_channels(params) * max98925->ch_size;\n\n\tswitch (blr_clk_ratio) {\n\tcase 32:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_32);\n\t\tbreak;\n\tcase 48:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_48);\n\t\tbreak;\n\tcase 64:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_BSEL_MASK, M98925_DAI_BSEL_64);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (max98925->sysclk) {\n\tcase 6000000:\n\t\tclock = 0;\n\t\tmdll  = M98925_MDLL_MULT_MCLKx16;\n\t\tbreak;\n\tcase 11289600:\n\t\tclock = 1;\n\t\tmdll  = M98925_MDLL_MULT_MCLKx8;\n\t\tbreak;\n\tcase 12000000:\n\t\tclock = 0;\n\t\tmdll  = M98925_MDLL_MULT_MCLKx8;\n\t\tbreak;\n\tcase 12288000:\n\t\tclock = 2;\n\t\tmdll  = M98925_MDLL_MULT_MCLKx8;\n\t\tbreak;\n\tdefault:\n\t\tdev_info(max98925->component->dev, \"unsupported sysclk %d\\n\",\n\t\t\t\t\tmax98925->sysclk);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max98925_rate_value(component, rate, clock, &dai_sr, &n, &m))\n\t\treturn -EINVAL;\n\n\t \n\tregmap_update_bits(max98925->regmap,\n\t\t\tMAX98925_DAI_CLK_MODE2,\n\t\t\tM98925_DAI_SR_MASK, dai_sr << M98925_DAI_SR_SHIFT);\n\t \n\tregmap_write(max98925->regmap,\n\t\tMAX98925_DAI_CLK_DIV_M_MSBS, m >> 8);\n\tregmap_write(max98925->regmap,\n\t\tMAX98925_DAI_CLK_DIV_M_LSBS, m & 0xFF);\n\t \n\tregmap_write(max98925->regmap,\n\t\tMAX98925_DAI_CLK_DIV_N_MSBS, n >> 8);\n\tregmap_write(max98925->regmap,\n\t\tMAX98925_DAI_CLK_DIV_N_LSBS, n & 0xFF);\n\t \n\tregmap_update_bits(max98925->regmap, MAX98925_DAI_CLK_MODE1,\n\t\t\tM98925_MDLL_MULT_MASK, mdll << M98925_MDLL_MULT_SHIFT);\n\treturn 0;\n}\n\nstatic int max98925_dai_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98925_priv *max98925 = snd_soc_component_get_drvdata(component);\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\t\tMAX98925_FORMAT,\n\t\t\t\tM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_16);\n\t\tmax98925->ch_size = 16;\n\t\tbreak;\n\tcase 24:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\t\tMAX98925_FORMAT,\n\t\t\t\tM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_24);\n\t\tmax98925->ch_size = 24;\n\t\tbreak;\n\tcase 32:\n\t\tregmap_update_bits(max98925->regmap,\n\t\t\t\tMAX98925_FORMAT,\n\t\t\t\tM98925_DAI_CHANSZ_MASK, M98925_DAI_CHANSZ_32);\n\t\tmax98925->ch_size = 32;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: format unsupported %d\",\n\t\t\t\t__func__, params_format(params));\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(component->dev, \"%s: format supported %d\",\n\t\t\t\t__func__, params_format(params));\n\treturn max98925_set_clock(max98925, params);\n}\n\nstatic int max98925_dai_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t\t   int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct max98925_priv *max98925 = snd_soc_component_get_drvdata(component);\n\n\tswitch (clk_id) {\n\tcase 0:\n\t\t \n\t\tregmap_update_bits(max98925->regmap,\n\t\t\t\tMAX98925_DAI_CLK_MODE1,\n\t\t\t\tM98925_DAI_CLK_SOURCE_MASK, 0);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tregmap_update_bits(max98925->regmap,\n\t\t\t\tMAX98925_DAI_CLK_MODE1,\n\t\t\t\tM98925_DAI_CLK_SOURCE_MASK,\n\t\t\t\tM98925_DAI_CLK_SOURCE_MASK);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmax98925->sysclk = freq;\n\treturn 0;\n}\n\n#define MAX98925_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops max98925_dai_ops = {\n\t.set_sysclk = max98925_dai_set_sysclk,\n\t.set_fmt = max98925_dai_set_fmt,\n\t.hw_params = max98925_dai_hw_params,\n};\n\nstatic struct snd_soc_dai_driver max98925_dai[] = {\n\t{\n\t\t.name = \"max98925-aif1\",\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = MAX98925_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_48000,\n\t\t\t.formats = MAX98925_FORMATS,\n\t\t},\n\t\t.ops = &max98925_dai_ops,\n\t}\n};\n\nstatic int max98925_probe(struct snd_soc_component *component)\n{\n\tstruct max98925_priv *max98925 = snd_soc_component_get_drvdata(component);\n\n\tmax98925->component = component;\n\tregmap_write(max98925->regmap, MAX98925_GLOBAL_ENABLE, 0x00);\n\t \n\tregmap_write(max98925->regmap,\n\t\t\tMAX98925_FORMAT, M98925_DAI_DLY_MASK);\n\tregmap_write(max98925->regmap, MAX98925_TDM_SLOT_SELECT, 0xC8);\n\tregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG1, 0xFF);\n\tregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG2, 0xFF);\n\tregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG3, 0xFF);\n\tregmap_write(max98925->regmap, MAX98925_DOUT_HIZ_CFG4, 0xF0);\n\tregmap_write(max98925->regmap, MAX98925_FILTERS, 0xD8);\n\tregmap_write(max98925->regmap, MAX98925_ALC_CONFIGURATION, 0xF8);\n\tregmap_write(max98925->regmap, MAX98925_CONFIGURATION, 0xF0);\n\t \n\tregmap_write(max98925->regmap, MAX98925_BOOST_LIMITER, 0xF8);\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_max98925 = {\n\t.probe\t\t\t= max98925_probe,\n\t.controls\t\t= max98925_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(max98925_snd_controls),\n\t.dapm_routes\t\t= max98925_audio_map,\n\t.num_dapm_routes\t= ARRAY_SIZE(max98925_audio_map),\n\t.dapm_widgets\t\t= max98925_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(max98925_dapm_widgets),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config max98925_regmap = {\n\t.reg_bits         = 8,\n\t.val_bits         = 8,\n\t.max_register     = MAX98925_REV_VERSION,\n\t.reg_defaults     = max98925_reg,\n\t.num_reg_defaults = ARRAY_SIZE(max98925_reg),\n\t.volatile_reg     = max98925_volatile_register,\n\t.readable_reg     = max98925_readable_register,\n\t.cache_type       = REGCACHE_RBTREE,\n};\n\nstatic int max98925_i2c_probe(struct i2c_client *i2c)\n{\n\tint ret, reg;\n\tu32 value;\n\tstruct max98925_priv *max98925;\n\n\tmax98925 = devm_kzalloc(&i2c->dev,\n\t\t\tsizeof(*max98925), GFP_KERNEL);\n\tif (!max98925)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, max98925);\n\tmax98925->regmap = devm_regmap_init_i2c(i2c, &max98925_regmap);\n\tif (IS_ERR(max98925->regmap)) {\n\t\tret = PTR_ERR(max98925->regmap);\n\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to allocate regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!of_property_read_u32(i2c->dev.of_node, \"vmon-slot-no\", &value)) {\n\t\tif (value > M98925_DAI_VMON_SLOT_1E_1F) {\n\t\t\tdev_err(&i2c->dev, \"vmon slot number is wrong:\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax98925->v_slot = value;\n\t}\n\tif (!of_property_read_u32(i2c->dev.of_node, \"imon-slot-no\", &value)) {\n\t\tif (value > M98925_DAI_IMON_SLOT_1E_1F) {\n\t\t\tdev_err(&i2c->dev, \"imon slot number is wrong:\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmax98925->i_slot = value;\n\t}\n\n\tret = regmap_read(max98925->regmap, MAX98925_REV_VERSION, &reg);\n\tif (ret < 0) {\n\t\tdev_err(&i2c->dev, \"Read revision failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((reg != MAX98925_VERSION) && (reg != MAX98925_VERSION1)) {\n\t\tret = -ENODEV;\n\t\tdev_err(&i2c->dev, \"Invalid revision (%d 0x%02X)\\n\",\n\t\t\tret, reg);\n\t\treturn ret;\n\t}\n\n\tdev_info(&i2c->dev, \"device version 0x%02X\\n\", reg);\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_max98925,\n\t\t\tmax98925_dai, ARRAY_SIZE(max98925_dai));\n\tif (ret < 0)\n\t\tdev_err(&i2c->dev,\n\t\t\t\t\"Failed to register component: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic const struct i2c_device_id max98925_i2c_id[] = {\n\t{ \"max98925\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max98925_i2c_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max98925_of_match[] = {\n\t{ .compatible = \"maxim,max98925\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, max98925_of_match);\n#endif\n\nstatic struct i2c_driver max98925_i2c_driver = {\n\t.driver = {\n\t\t.name = \"max98925\",\n\t\t.of_match_table = of_match_ptr(max98925_of_match),\n\t},\n\t.probe = max98925_i2c_probe,\n\t.id_table = max98925_i2c_id,\n};\n\nmodule_i2c_driver(max98925_i2c_driver)\n\nMODULE_DESCRIPTION(\"ALSA SoC MAX98925 driver\");\nMODULE_AUTHOR(\"Ralph Birt <rdbirt@gmail.com>, Anish kumar <anish.kumar@maximintegrated.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}