{
  "module_name": "adav80x.c",
  "hash_id": "b7ae9f0b4098383cc2c5ddd42c3c0429b03ea87d6f2a10ad606c91e5c7fe65b0",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/adav80x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"adav80x.h\"\n\n#define ADAV80X_PLAYBACK_CTRL\t0x04\n#define ADAV80X_AUX_IN_CTRL\t0x05\n#define ADAV80X_REC_CTRL\t0x06\n#define ADAV80X_AUX_OUT_CTRL\t0x07\n#define ADAV80X_DPATH_CTRL1\t0x62\n#define ADAV80X_DPATH_CTRL2\t0x63\n#define ADAV80X_DAC_CTRL1\t0x64\n#define ADAV80X_DAC_CTRL2\t0x65\n#define ADAV80X_DAC_CTRL3\t0x66\n#define ADAV80X_DAC_L_VOL\t0x68\n#define ADAV80X_DAC_R_VOL\t0x69\n#define ADAV80X_PGA_L_VOL\t0x6c\n#define ADAV80X_PGA_R_VOL\t0x6d\n#define ADAV80X_ADC_CTRL1\t0x6e\n#define ADAV80X_ADC_CTRL2\t0x6f\n#define ADAV80X_ADC_L_VOL\t0x70\n#define ADAV80X_ADC_R_VOL\t0x71\n#define ADAV80X_PLL_CTRL1\t0x74\n#define ADAV80X_PLL_CTRL2\t0x75\n#define ADAV80X_ICLK_CTRL1\t0x76\n#define ADAV80X_ICLK_CTRL2\t0x77\n#define ADAV80X_PLL_CLK_SRC\t0x78\n#define ADAV80X_PLL_OUTE\t0x7a\n\n#define ADAV80X_PLL_CLK_SRC_PLL_XIN(pll)\t0x00\n#define ADAV80X_PLL_CLK_SRC_PLL_MCLKI(pll)\t(0x40 << (pll))\n#define ADAV80X_PLL_CLK_SRC_PLL_MASK(pll)\t(0x40 << (pll))\n\n#define ADAV80X_ICLK_CTRL1_DAC_SRC(src)\t\t((src) << 5)\n#define ADAV80X_ICLK_CTRL1_ADC_SRC(src)\t\t((src) << 2)\n#define ADAV80X_ICLK_CTRL1_ICLK2_SRC(src)\t(src)\n#define ADAV80X_ICLK_CTRL2_ICLK1_SRC(src)\t((src) << 3)\n\n#define ADAV80X_PLL_CTRL1_PLLDIV\t\t0x10\n#define ADAV80X_PLL_CTRL1_PLLPD(pll)\t\t(0x04 << (pll))\n#define ADAV80X_PLL_CTRL1_XTLPD\t\t\t0x02\n\n#define ADAV80X_PLL_CTRL2_FIELD(pll, x)\t\t((x) << ((pll) * 4))\n\n#define ADAV80X_PLL_CTRL2_FS_48(pll)\tADAV80X_PLL_CTRL2_FIELD((pll), 0x00)\n#define ADAV80X_PLL_CTRL2_FS_32(pll)\tADAV80X_PLL_CTRL2_FIELD((pll), 0x08)\n#define ADAV80X_PLL_CTRL2_FS_44(pll)\tADAV80X_PLL_CTRL2_FIELD((pll), 0x0c)\n\n#define ADAV80X_PLL_CTRL2_SEL(pll)\tADAV80X_PLL_CTRL2_FIELD((pll), 0x02)\n#define ADAV80X_PLL_CTRL2_DOUB(pll)\tADAV80X_PLL_CTRL2_FIELD((pll), 0x01)\n#define ADAV80X_PLL_CTRL2_PLL_MASK(pll) ADAV80X_PLL_CTRL2_FIELD((pll), 0x0f)\n\n#define ADAV80X_ADC_CTRL1_MODULATOR_MASK\t0x80\n#define ADAV80X_ADC_CTRL1_MODULATOR_128FS\t0x00\n#define ADAV80X_ADC_CTRL1_MODULATOR_64FS\t0x80\n\n#define ADAV80X_DAC_CTRL1_PD\t\t\t0x80\n\n#define ADAV80X_DAC_CTRL2_DIV1\t\t\t0x00\n#define ADAV80X_DAC_CTRL2_DIV1_5\t\t0x10\n#define ADAV80X_DAC_CTRL2_DIV2\t\t\t0x20\n#define ADAV80X_DAC_CTRL2_DIV3\t\t\t0x30\n#define ADAV80X_DAC_CTRL2_DIV_MASK\t\t0x30\n\n#define ADAV80X_DAC_CTRL2_INTERPOL_256FS\t0x00\n#define ADAV80X_DAC_CTRL2_INTERPOL_128FS\t0x40\n#define ADAV80X_DAC_CTRL2_INTERPOL_64FS\t\t0x80\n#define ADAV80X_DAC_CTRL2_INTERPOL_MASK\t\t0xc0\n\n#define ADAV80X_DAC_CTRL2_DEEMPH_NONE\t\t0x00\n#define ADAV80X_DAC_CTRL2_DEEMPH_44\t\t0x01\n#define ADAV80X_DAC_CTRL2_DEEMPH_32\t\t0x02\n#define ADAV80X_DAC_CTRL2_DEEMPH_48\t\t0x03\n#define ADAV80X_DAC_CTRL2_DEEMPH_MASK\t\t0x01\n\n#define ADAV80X_CAPTURE_MODE_MASTER\t\t0x20\n#define ADAV80X_CAPTURE_WORD_LEN24\t\t0x00\n#define ADAV80X_CAPTURE_WORD_LEN20\t\t0x04\n#define ADAV80X_CAPTRUE_WORD_LEN18\t\t0x08\n#define ADAV80X_CAPTURE_WORD_LEN16\t\t0x0c\n#define ADAV80X_CAPTURE_WORD_LEN_MASK\t\t0x0c\n\n#define ADAV80X_CAPTURE_MODE_LEFT_J\t\t0x00\n#define ADAV80X_CAPTURE_MODE_I2S\t\t0x01\n#define ADAV80X_CAPTURE_MODE_RIGHT_J\t\t0x03\n#define ADAV80X_CAPTURE_MODE_MASK\t\t0x03\n\n#define ADAV80X_PLAYBACK_MODE_MASTER\t\t0x10\n#define ADAV80X_PLAYBACK_MODE_LEFT_J\t\t0x00\n#define ADAV80X_PLAYBACK_MODE_I2S\t\t0x01\n#define ADAV80X_PLAYBACK_MODE_RIGHT_J_24\t0x04\n#define ADAV80X_PLAYBACK_MODE_RIGHT_J_20\t0x05\n#define ADAV80X_PLAYBACK_MODE_RIGHT_J_18\t0x06\n#define ADAV80X_PLAYBACK_MODE_RIGHT_J_16\t0x07\n#define ADAV80X_PLAYBACK_MODE_MASK\t\t0x07\n\n#define ADAV80X_PLL_OUTE_SYSCLKPD(x)\t\tBIT(2 - (x))\n\nstatic const struct reg_default adav80x_reg_defaults[] = {\n\t{ ADAV80X_PLAYBACK_CTRL,\t0x01 },\n\t{ ADAV80X_AUX_IN_CTRL,\t\t0x01 },\n\t{ ADAV80X_REC_CTRL,\t\t0x02 },\n\t{ ADAV80X_AUX_OUT_CTRL,\t\t0x01 },\n\t{ ADAV80X_DPATH_CTRL1,\t\t0xc0 },\n\t{ ADAV80X_DPATH_CTRL2,\t\t0x11 },\n\t{ ADAV80X_DAC_CTRL1,\t\t0x00 },\n\t{ ADAV80X_DAC_CTRL2,\t\t0x00 },\n\t{ ADAV80X_DAC_CTRL3,\t\t0x00 },\n\t{ ADAV80X_DAC_L_VOL,\t\t0xff },\n\t{ ADAV80X_DAC_R_VOL,\t\t0xff },\n\t{ ADAV80X_PGA_L_VOL,\t\t0x00 },\n\t{ ADAV80X_PGA_R_VOL,\t\t0x00 },\n\t{ ADAV80X_ADC_CTRL1,\t\t0x00 },\n\t{ ADAV80X_ADC_CTRL2,\t\t0x00 },\n\t{ ADAV80X_ADC_L_VOL,\t\t0xff },\n\t{ ADAV80X_ADC_R_VOL,\t\t0xff },\n\t{ ADAV80X_PLL_CTRL1,\t\t0x00 },\n\t{ ADAV80X_PLL_CTRL2,\t\t0x00 },\n\t{ ADAV80X_ICLK_CTRL1,\t\t0x00 },\n\t{ ADAV80X_ICLK_CTRL2,\t\t0x00 },\n\t{ ADAV80X_PLL_CLK_SRC,\t\t0x00 },\n\t{ ADAV80X_PLL_OUTE,\t\t0x00 },\n};\n\nstruct adav80x {\n\tstruct regmap *regmap;\n\n\tenum adav80x_clk_src clk_src;\n\tunsigned int sysclk;\n\tenum adav80x_pll_src pll_src;\n\n\tunsigned int dai_fmt[2];\n\tunsigned int rate;\n\tbool deemph;\n\tbool sysclk_pd[3];\n};\n\nstatic const char *adav80x_mux_text[] = {\n\t\"ADC\",\n\t\"Playback\",\n\t\"Aux Playback\",\n};\n\nstatic const unsigned int adav80x_mux_values[] = {\n\t0, 2, 3,\n};\n\n#define ADAV80X_MUX_ENUM_DECL(name, reg, shift) \\\n\tSOC_VALUE_ENUM_DOUBLE_DECL(name, reg, shift, 7, \\\n\t\tARRAY_SIZE(adav80x_mux_text), adav80x_mux_text, \\\n\t\tadav80x_mux_values)\n\nstatic ADAV80X_MUX_ENUM_DECL(adav80x_aux_capture_enum, ADAV80X_DPATH_CTRL1, 0);\nstatic ADAV80X_MUX_ENUM_DECL(adav80x_capture_enum, ADAV80X_DPATH_CTRL1, 3);\nstatic ADAV80X_MUX_ENUM_DECL(adav80x_dac_enum, ADAV80X_DPATH_CTRL2, 3);\n\nstatic const struct snd_kcontrol_new adav80x_aux_capture_mux_ctrl =\n\tSOC_DAPM_ENUM(\"Route\", adav80x_aux_capture_enum);\nstatic const struct snd_kcontrol_new adav80x_capture_mux_ctrl =\n\tSOC_DAPM_ENUM(\"Route\", adav80x_capture_enum);\nstatic const struct snd_kcontrol_new adav80x_dac_mux_ctrl =\n\tSOC_DAPM_ENUM(\"Route\", adav80x_dac_enum);\n\n#define ADAV80X_MUX(name, ctrl) \\\n\tSND_SOC_DAPM_MUX(name, SND_SOC_NOPM, 0, 0, ctrl)\n\nstatic const struct snd_soc_dapm_widget adav80x_dapm_widgets[] = {\n\tSND_SOC_DAPM_DAC(\"DAC\", NULL, ADAV80X_DAC_CTRL1, 7, 1),\n\tSND_SOC_DAPM_ADC(\"ADC\", NULL, ADAV80X_ADC_CTRL1, 5, 1),\n\n\tSND_SOC_DAPM_PGA(\"Right PGA\", ADAV80X_ADC_CTRL1, 0, 1, NULL, 0),\n\tSND_SOC_DAPM_PGA(\"Left PGA\", ADAV80X_ADC_CTRL1, 1, 1, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIFOUT\", \"HiFi Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFIN\", \"HiFi Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"AIFAUXOUT\", \"Aux Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"AIFAUXIN\", \"Aux Playback\", 0, SND_SOC_NOPM, 0, 0),\n\n\tADAV80X_MUX(\"Aux Capture Select\", &adav80x_aux_capture_mux_ctrl),\n\tADAV80X_MUX(\"Capture Select\", &adav80x_capture_mux_ctrl),\n\tADAV80X_MUX(\"DAC Select\", &adav80x_dac_mux_ctrl),\n\n\tSND_SOC_DAPM_INPUT(\"VINR\"),\n\tSND_SOC_DAPM_INPUT(\"VINL\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTR\"),\n\tSND_SOC_DAPM_OUTPUT(\"VOUTL\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"SYSCLK\", SND_SOC_NOPM, 0, 0, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL1\", ADAV80X_PLL_CTRL1, 2, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"PLL2\", ADAV80X_PLL_CTRL1, 3, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"OSC\", ADAV80X_PLL_CTRL1, 1, 1, NULL, 0),\n};\n\nstatic int adav80x_dapm_sysclk_check(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tconst char *clk;\n\n\tswitch (adav80x->clk_src) {\n\tcase ADAV80X_CLK_PLL1:\n\t\tclk = \"PLL1\";\n\t\tbreak;\n\tcase ADAV80X_CLK_PLL2:\n\t\tclk = \"PLL2\";\n\t\tbreak;\n\tcase ADAV80X_CLK_XTAL:\n\t\tclk = \"OSC\";\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn strcmp(source->name, clk) == 0;\n}\n\nstatic int adav80x_dapm_pll_check(struct snd_soc_dapm_widget *source,\n\t\t\t struct snd_soc_dapm_widget *sink)\n{\n\tstruct snd_soc_component *component = snd_soc_dapm_to_component(source->dapm);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\treturn adav80x->pll_src == ADAV80X_PLL_SRC_XTAL;\n}\n\n\nstatic const struct snd_soc_dapm_route adav80x_dapm_routes[] = {\n\t{ \"DAC Select\", \"ADC\", \"ADC\" },\n\t{ \"DAC Select\", \"Playback\", \"AIFIN\" },\n\t{ \"DAC Select\", \"Aux Playback\", \"AIFAUXIN\" },\n\t{ \"DAC\", NULL,  \"DAC Select\" },\n\n\t{ \"Capture Select\", \"ADC\", \"ADC\" },\n\t{ \"Capture Select\", \"Playback\", \"AIFIN\" },\n\t{ \"Capture Select\", \"Aux Playback\", \"AIFAUXIN\" },\n\t{ \"AIFOUT\", NULL,  \"Capture Select\" },\n\n\t{ \"Aux Capture Select\", \"ADC\", \"ADC\" },\n\t{ \"Aux Capture Select\", \"Playback\", \"AIFIN\" },\n\t{ \"Aux Capture Select\", \"Aux Playback\", \"AIFAUXIN\" },\n\t{ \"AIFAUXOUT\", NULL,  \"Aux Capture Select\" },\n\n\t{ \"VOUTR\",  NULL, \"DAC\" },\n\t{ \"VOUTL\",  NULL, \"DAC\" },\n\n\t{ \"Left PGA\", NULL, \"VINL\" },\n\t{ \"Right PGA\", NULL, \"VINR\" },\n\t{ \"ADC\", NULL, \"Left PGA\" },\n\t{ \"ADC\", NULL, \"Right PGA\" },\n\n\t{ \"SYSCLK\", NULL, \"PLL1\", adav80x_dapm_sysclk_check },\n\t{ \"SYSCLK\", NULL, \"PLL2\", adav80x_dapm_sysclk_check },\n\t{ \"SYSCLK\", NULL, \"OSC\", adav80x_dapm_sysclk_check },\n\t{ \"PLL1\", NULL, \"OSC\", adav80x_dapm_pll_check },\n\t{ \"PLL2\", NULL, \"OSC\", adav80x_dapm_pll_check },\n\n\t{ \"ADC\", NULL, \"SYSCLK\" },\n\t{ \"DAC\", NULL, \"SYSCLK\" },\n\t{ \"AIFOUT\", NULL, \"SYSCLK\" },\n\t{ \"AIFAUXOUT\", NULL, \"SYSCLK\" },\n\t{ \"AIFIN\", NULL, \"SYSCLK\" },\n\t{ \"AIFAUXIN\", NULL, \"SYSCLK\" },\n};\n\nstatic int adav80x_set_deemph(struct snd_soc_component *component)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (adav80x->deemph) {\n\t\tswitch (adav80x->rate) {\n\t\tcase 32000:\n\t\t\tval = ADAV80X_DAC_CTRL2_DEEMPH_32;\n\t\t\tbreak;\n\t\tcase 44100:\n\t\t\tval = ADAV80X_DAC_CTRL2_DEEMPH_44;\n\t\t\tbreak;\n\t\tcase 48000:\n\t\tcase 64000:\n\t\tcase 88200:\n\t\tcase 96000:\n\t\t\tval = ADAV80X_DAC_CTRL2_DEEMPH_48;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tval = ADAV80X_DAC_CTRL2_DEEMPH_NONE;\n\t}\n\n\treturn regmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL2,\n\t\tADAV80X_DAC_CTRL2_DEEMPH_MASK, val);\n}\n\nstatic int adav80x_put_deemph(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int deemph = ucontrol->value.integer.value[0];\n\n\tif (deemph > 1)\n\t\treturn -EINVAL;\n\n\tadav80x->deemph = deemph;\n\n\treturn adav80x_set_deemph(component);\n}\n\nstatic int adav80x_get_deemph(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = adav80x->deemph;\n\treturn 0;\n};\n\nstatic const DECLARE_TLV_DB_SCALE(adav80x_inpga_tlv, 0, 50, 0);\nstatic const DECLARE_TLV_DB_MINMAX(adav80x_digital_tlv, -9563, 0);\n\nstatic const struct snd_kcontrol_new adav80x_controls[] = {\n\tSOC_DOUBLE_R_TLV(\"Master Playback Volume\", ADAV80X_DAC_L_VOL,\n\t\tADAV80X_DAC_R_VOL, 0, 0xff, 0, adav80x_digital_tlv),\n\tSOC_DOUBLE_R_TLV(\"Master Capture Volume\", ADAV80X_ADC_L_VOL,\n\t\t\tADAV80X_ADC_R_VOL, 0, 0xff, 0, adav80x_digital_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"PGA Capture Volume\", ADAV80X_PGA_L_VOL,\n\t\t\tADAV80X_PGA_R_VOL, 0, 0x30, 0, adav80x_inpga_tlv),\n\n\tSOC_DOUBLE(\"Master Playback Switch\", ADAV80X_DAC_CTRL1, 0, 1, 1, 0),\n\tSOC_DOUBLE(\"Master Capture Switch\", ADAV80X_ADC_CTRL1, 2, 3, 1, 1),\n\n\tSOC_SINGLE(\"ADC High Pass Filter Switch\", ADAV80X_ADC_CTRL1, 6, 1, 0),\n\n\tSOC_SINGLE_BOOL_EXT(\"Playback De-emphasis Switch\", 0,\n\t\t\tadav80x_get_deemph, adav80x_put_deemph),\n};\n\nstatic unsigned int adav80x_port_ctrl_regs[2][2] = {\n\t{ ADAV80X_REC_CTRL, ADAV80X_PLAYBACK_CTRL, },\n\t{ ADAV80X_AUX_OUT_CTRL, ADAV80X_AUX_IN_CTRL },\n};\n\nstatic int adav80x_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int capture = 0x00;\n\tunsigned int playback = 0x00;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP:\n\t\tcapture |= ADAV80X_CAPTURE_MODE_MASTER;\n\t\tplayback |= ADAV80X_PLAYBACK_MODE_MASTER;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcapture |= ADAV80X_CAPTURE_MODE_I2S;\n\t\tplayback |= ADAV80X_PLAYBACK_MODE_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcapture |= ADAV80X_CAPTURE_MODE_LEFT_J;\n\t\tplayback |= ADAV80X_PLAYBACK_MODE_LEFT_J;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcapture |= ADAV80X_CAPTURE_MODE_RIGHT_J;\n\t\tplayback |= ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][0],\n\t\tADAV80X_CAPTURE_MODE_MASK | ADAV80X_CAPTURE_MODE_MASTER,\n\t\tcapture);\n\tregmap_write(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][1],\n\t\tplayback);\n\n\tadav80x->dai_fmt[dai->id] = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\n\treturn 0;\n}\n\nstatic int adav80x_set_adc_clock(struct snd_soc_component *component,\n\t\tunsigned int sample_rate)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (sample_rate <= 48000)\n\t\tval = ADAV80X_ADC_CTRL1_MODULATOR_128FS;\n\telse\n\t\tval = ADAV80X_ADC_CTRL1_MODULATOR_64FS;\n\n\tregmap_update_bits(adav80x->regmap, ADAV80X_ADC_CTRL1,\n\t\tADAV80X_ADC_CTRL1_MODULATOR_MASK, val);\n\n\treturn 0;\n}\n\nstatic int adav80x_set_dac_clock(struct snd_soc_component *component,\n\t\tunsigned int sample_rate)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (sample_rate <= 48000)\n\t\tval = ADAV80X_DAC_CTRL2_DIV1 | ADAV80X_DAC_CTRL2_INTERPOL_256FS;\n\telse\n\t\tval = ADAV80X_DAC_CTRL2_DIV2 | ADAV80X_DAC_CTRL2_INTERPOL_128FS;\n\n\tregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL2,\n\t\tADAV80X_DAC_CTRL2_DIV_MASK | ADAV80X_DAC_CTRL2_INTERPOL_MASK,\n\t\tval);\n\n\treturn 0;\n}\n\nstatic int adav80x_set_capture_pcm_format(struct snd_soc_component *component,\n\t\tstruct snd_soc_dai *dai, struct snd_pcm_hw_params *params)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval = ADAV80X_CAPTURE_WORD_LEN16;\n\t\tbreak;\n\tcase 18:\n\t\tval = ADAV80X_CAPTRUE_WORD_LEN18;\n\t\tbreak;\n\tcase 20:\n\t\tval = ADAV80X_CAPTURE_WORD_LEN20;\n\t\tbreak;\n\tcase 24:\n\t\tval = ADAV80X_CAPTURE_WORD_LEN24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][0],\n\t\tADAV80X_CAPTURE_WORD_LEN_MASK, val);\n\n\treturn 0;\n}\n\nstatic int adav80x_set_playback_pcm_format(struct snd_soc_component *component,\n\t\tstruct snd_soc_dai *dai, struct snd_pcm_hw_params *params)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int val;\n\n\tif (adav80x->dai_fmt[dai->id] != SND_SOC_DAIFMT_RIGHT_J)\n\t\treturn 0;\n\n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tval = ADAV80X_PLAYBACK_MODE_RIGHT_J_16;\n\t\tbreak;\n\tcase 18:\n\t\tval = ADAV80X_PLAYBACK_MODE_RIGHT_J_18;\n\t\tbreak;\n\tcase 20:\n\t\tval = ADAV80X_PLAYBACK_MODE_RIGHT_J_20;\n\t\tbreak;\n\tcase 24:\n\t\tval = ADAV80X_PLAYBACK_MODE_RIGHT_J_24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adav80x->regmap, adav80x_port_ctrl_regs[dai->id][1],\n\t\tADAV80X_PLAYBACK_MODE_MASK, val);\n\n\treturn 0;\n}\n\nstatic int adav80x_hw_params(struct snd_pcm_substream *substream,\n\t\tstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int rate = params_rate(params);\n\n\tif (rate * 256 != adav80x->sysclk)\n\t\treturn -EINVAL;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tadav80x_set_playback_pcm_format(component, dai, params);\n\t\tadav80x_set_dac_clock(component, rate);\n\t} else {\n\t\tadav80x_set_capture_pcm_format(component, dai, params);\n\t\tadav80x_set_adc_clock(component, rate);\n\t}\n\tadav80x->rate = rate;\n\tadav80x_set_deemph(component);\n\n\treturn 0;\n}\n\nstatic int adav80x_set_sysclk(struct snd_soc_component *component,\n\t\t\t      int clk_id, int source,\n\t\t\t      unsigned int freq, int dir)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tif (dir == SND_SOC_CLOCK_IN) {\n\t\tswitch (clk_id) {\n\t\tcase ADAV80X_CLK_XIN:\n\t\tcase ADAV80X_CLK_XTAL:\n\t\tcase ADAV80X_CLK_MCLKI:\n\t\tcase ADAV80X_CLK_PLL1:\n\t\tcase ADAV80X_CLK_PLL2:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tadav80x->sysclk = freq;\n\n\t\tif (adav80x->clk_src != clk_id) {\n\t\t\tunsigned int iclk_ctrl1, iclk_ctrl2;\n\n\t\t\tadav80x->clk_src = clk_id;\n\t\t\tif (clk_id == ADAV80X_CLK_XTAL)\n\t\t\t\tclk_id = ADAV80X_CLK_XIN;\n\n\t\t\ticlk_ctrl1 = ADAV80X_ICLK_CTRL1_DAC_SRC(clk_id) |\n\t\t\t\t\tADAV80X_ICLK_CTRL1_ADC_SRC(clk_id) |\n\t\t\t\t\tADAV80X_ICLK_CTRL1_ICLK2_SRC(clk_id);\n\t\t\ticlk_ctrl2 = ADAV80X_ICLK_CTRL2_ICLK1_SRC(clk_id);\n\n\t\t\tregmap_write(adav80x->regmap, ADAV80X_ICLK_CTRL1,\n\t\t\t\ticlk_ctrl1);\n\t\t\tregmap_write(adav80x->regmap, ADAV80X_ICLK_CTRL2,\n\t\t\t\ticlk_ctrl2);\n\n\t\t\tsnd_soc_dapm_sync(dapm);\n\t\t}\n\t} else {\n\t\tunsigned int mask;\n\n\t\tswitch (clk_id) {\n\t\tcase ADAV80X_CLK_SYSCLK1:\n\t\tcase ADAV80X_CLK_SYSCLK2:\n\t\tcase ADAV80X_CLK_SYSCLK3:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tclk_id -= ADAV80X_CLK_SYSCLK1;\n\t\tmask = ADAV80X_PLL_OUTE_SYSCLKPD(clk_id);\n\n\t\tif (freq == 0) {\n\t\t\tregmap_update_bits(adav80x->regmap, ADAV80X_PLL_OUTE,\n\t\t\t\tmask, mask);\n\t\t\tadav80x->sysclk_pd[clk_id] = true;\n\t\t} else {\n\t\t\tregmap_update_bits(adav80x->regmap, ADAV80X_PLL_OUTE,\n\t\t\t\tmask, 0);\n\t\t\tadav80x->sysclk_pd[clk_id] = false;\n\t\t}\n\n\t\tsnd_soc_dapm_mutex_lock(dapm);\n\n\t\tif (adav80x->sysclk_pd[0])\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"PLL1\");\n\t\telse\n\t\t\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"PLL1\");\n\n\t\tif (adav80x->sysclk_pd[1] || adav80x->sysclk_pd[2])\n\t\t\tsnd_soc_dapm_disable_pin_unlocked(dapm, \"PLL2\");\n\t\telse\n\t\t\tsnd_soc_dapm_force_enable_pin_unlocked(dapm, \"PLL2\");\n\n\t\tsnd_soc_dapm_sync_unlocked(dapm);\n\n\t\tsnd_soc_dapm_mutex_unlock(dapm);\n\t}\n\n\treturn 0;\n}\n\nstatic int adav80x_set_pll(struct snd_soc_component *component, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int pll_ctrl1 = 0;\n\tunsigned int pll_ctrl2 = 0;\n\tunsigned int pll_src;\n\n\tswitch (source) {\n\tcase ADAV80X_PLL_SRC_XTAL:\n\tcase ADAV80X_PLL_SRC_XIN:\n\tcase ADAV80X_PLL_SRC_MCLKI:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!freq_out)\n\t\treturn 0;\n\n\tswitch (freq_in) {\n\tcase 27000000:\n\t\tbreak;\n\tcase 54000000:\n\t\tif (source == ADAV80X_PLL_SRC_XIN) {\n\t\t\tpll_ctrl1 |= ADAV80X_PLL_CTRL1_PLLDIV;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (freq_out > 12288000) {\n\t\tpll_ctrl2 |= ADAV80X_PLL_CTRL2_DOUB(pll_id);\n\t\tfreq_out /= 2;\n\t}\n\n\t \n\tswitch (freq_out) {\n\tcase 8192000:\n\t\tpll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_32(pll_id);\n\t\tbreak;\n\tcase 11289600:\n\t\tpll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_44(pll_id);\n\t\tbreak;\n\tcase 12288000:\n\t\tpll_ctrl2 |= ADAV80X_PLL_CTRL2_FS_48(pll_id);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CTRL1,\n\t\t\tADAV80X_PLL_CTRL1_PLLDIV, pll_ctrl1);\n\tregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CTRL2,\n\t\t\tADAV80X_PLL_CTRL2_PLL_MASK(pll_id), pll_ctrl2);\n\n\tif (source != adav80x->pll_src) {\n\t\tif (source == ADAV80X_PLL_SRC_MCLKI)\n\t\t\tpll_src = ADAV80X_PLL_CLK_SRC_PLL_MCLKI(pll_id);\n\t\telse\n\t\t\tpll_src = ADAV80X_PLL_CLK_SRC_PLL_XIN(pll_id);\n\n\t\tregmap_update_bits(adav80x->regmap, ADAV80X_PLL_CLK_SRC,\n\t\t\t\tADAV80X_PLL_CLK_SRC_PLL_MASK(pll_id), pll_src);\n\n\t\tadav80x->pll_src = source;\n\n\t\tsnd_soc_dapm_sync(dapm);\n\t}\n\n\treturn 0;\n}\n\nstatic int adav80x_set_bias_level(struct snd_soc_component *component,\n\t\tenum snd_soc_bias_level level)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\tunsigned int mask = ADAV80X_DAC_CTRL1_PD;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL1, mask,\n\t\t\t0x00);\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_update_bits(adav80x->regmap, ADAV80X_DAC_CTRL1, mask,\n\t\t\tmask);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int adav80x_dai_startup(struct snd_pcm_substream *substream,\n\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\tif (!snd_soc_component_active(component) || !adav80x->rate)\n\t\treturn 0;\n\n\treturn snd_pcm_hw_constraint_single(substream->runtime,\n\t\t\tSNDRV_PCM_HW_PARAM_RATE, adav80x->rate);\n}\n\nstatic void adav80x_dai_shutdown(struct snd_pcm_substream *substream,\n\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\tif (!snd_soc_component_active(component))\n\t\tadav80x->rate = 0;\n}\n\nstatic const struct snd_soc_dai_ops adav80x_dai_ops = {\n\t.set_fmt = adav80x_set_dai_fmt,\n\t.hw_params = adav80x_hw_params,\n\t.startup = adav80x_dai_startup,\n\t.shutdown = adav80x_dai_shutdown,\n};\n\n#define ADAV80X_PLAYBACK_RATES (SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \\\n\tSNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_64000 | SNDRV_PCM_RATE_88200 | \\\n\tSNDRV_PCM_RATE_96000)\n\n#define ADAV80X_CAPTURE_RATES (SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000)\n\n#define ADAV80X_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\tSNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_LE)\n\nstatic struct snd_soc_dai_driver adav80x_dais[] = {\n\t{\n\t\t.name = \"adav80x-hifi\",\n\t\t.id = 0,\n\t\t.playback = {\n\t\t\t.stream_name = \"HiFi Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = ADAV80X_PLAYBACK_RATES,\n\t\t\t.formats = ADAV80X_FORMATS,\n\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"HiFi Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = ADAV80X_CAPTURE_RATES,\n\t\t\t.formats = ADAV80X_FORMATS,\n\t\t},\n\t\t.ops = &adav80x_dai_ops,\n\t},\n\t{\n\t\t.name = \"adav80x-aux\",\n\t\t.id = 1,\n\t\t.playback = {\n\t\t\t.stream_name = \"Aux Playback\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = ADAV80X_PLAYBACK_RATES,\n\t\t\t.formats = ADAV80X_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"Aux Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = ADAV80X_CAPTURE_RATES,\n\t\t\t.formats = ADAV80X_FORMATS,\n\t\t},\n\t\t.ops = &adav80x_dai_ops,\n\t},\n};\n\nstatic int adav80x_probe(struct snd_soc_component *component)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\t \n\tsnd_soc_dapm_force_enable_pin(dapm, \"PLL1\");\n\tsnd_soc_dapm_force_enable_pin(dapm, \"PLL2\");\n\n\t \n\tregmap_write(adav80x->regmap, ADAV80X_PLL_OUTE, 0x20);\n\t \n\tregmap_write(adav80x->regmap, ADAV80X_DAC_CTRL3, 0x6);\n\n\treturn 0;\n}\n\nstatic int adav80x_resume(struct snd_soc_component *component)\n{\n\tstruct adav80x *adav80x = snd_soc_component_get_drvdata(component);\n\n\tregcache_sync(adav80x->regmap);\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver adav80x_component_driver = {\n\t.probe\t\t\t= adav80x_probe,\n\t.resume\t\t\t= adav80x_resume,\n\t.set_bias_level\t\t= adav80x_set_bias_level,\n\t.set_pll\t\t= adav80x_set_pll,\n\t.set_sysclk\t\t= adav80x_set_sysclk,\n\t.controls\t\t= adav80x_controls,\n\t.num_controls\t\t= ARRAY_SIZE(adav80x_controls),\n\t.dapm_widgets\t\t= adav80x_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(adav80x_dapm_widgets),\n\t.dapm_routes\t\t= adav80x_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(adav80x_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nint adav80x_bus_probe(struct device *dev, struct regmap *regmap)\n{\n\tstruct adav80x *adav80x;\n\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tadav80x = devm_kzalloc(dev, sizeof(*adav80x), GFP_KERNEL);\n\tif (!adav80x)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, adav80x);\n\tadav80x->regmap = regmap;\n\n\treturn devm_snd_soc_register_component(dev, &adav80x_component_driver,\n\t\tadav80x_dais, ARRAY_SIZE(adav80x_dais));\n}\nEXPORT_SYMBOL_GPL(adav80x_bus_probe);\n\nconst struct regmap_config adav80x_regmap_config = {\n\t.val_bits = 8,\n\t.pad_bits = 1,\n\t.reg_bits = 7,\n\n\t.max_register = ADAV80X_PLL_OUTE,\n\n\t.cache_type = REGCACHE_MAPLE,\n\t.reg_defaults = adav80x_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(adav80x_reg_defaults),\n};\nEXPORT_SYMBOL_GPL(adav80x_regmap_config);\n\nMODULE_DESCRIPTION(\"ASoC ADAV80x driver\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\nMODULE_AUTHOR(\"Yi Li <yi.li@analog.com>>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}