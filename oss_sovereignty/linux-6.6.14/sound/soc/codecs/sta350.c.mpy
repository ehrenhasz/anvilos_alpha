{
  "module_name": "sta350.c",
  "hash_id": "b474fac567408ce2b413a33b48b626caad590a1b673004791a72b753503fe517",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/sta350.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \":%s:%d: \" fmt, __func__, __LINE__\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/soc-dapm.h>\n#include <sound/initval.h>\n#include <sound/tlv.h>\n\n#include <sound/sta350.h>\n#include \"sta350.h\"\n\n#define STA350_RATES (SNDRV_PCM_RATE_32000 | \\\n\t\t      SNDRV_PCM_RATE_44100 | \\\n\t\t      SNDRV_PCM_RATE_48000 | \\\n\t\t      SNDRV_PCM_RATE_88200 | \\\n\t\t      SNDRV_PCM_RATE_96000 | \\\n\t\t      SNDRV_PCM_RATE_176400 | \\\n\t\t      SNDRV_PCM_RATE_192000)\n\n#define STA350_FORMATS \\\n\t(SNDRV_PCM_FMTBIT_S16_LE  | SNDRV_PCM_FMTBIT_S18_3LE | \\\n\t SNDRV_PCM_FMTBIT_S20_3LE | SNDRV_PCM_FMTBIT_S24_3LE | \\\n\t SNDRV_PCM_FMTBIT_S24_LE  | SNDRV_PCM_FMTBIT_S32_LE)\n\n \nstatic const struct reg_default sta350_regs[] = {\n\t{  0x0, 0x63 },\n\t{  0x1, 0x80 },\n\t{  0x2, 0xdf },\n\t{  0x3, 0x40 },\n\t{  0x4, 0xc2 },\n\t{  0x5, 0x5c },\n\t{  0x6, 0x00 },\n\t{  0x7, 0xff },\n\t{  0x8, 0x60 },\n\t{  0x9, 0x60 },\n\t{  0xa, 0x60 },\n\t{  0xb, 0x00 },\n\t{  0xc, 0x00 },\n\t{  0xd, 0x00 },\n\t{  0xe, 0x00 },\n\t{  0xf, 0x40 },\n\t{ 0x10, 0x80 },\n\t{ 0x11, 0x77 },\n\t{ 0x12, 0x6a },\n\t{ 0x13, 0x69 },\n\t{ 0x14, 0x6a },\n\t{ 0x15, 0x69 },\n\t{ 0x16, 0x00 },\n\t{ 0x17, 0x00 },\n\t{ 0x18, 0x00 },\n\t{ 0x19, 0x00 },\n\t{ 0x1a, 0x00 },\n\t{ 0x1b, 0x00 },\n\t{ 0x1c, 0x00 },\n\t{ 0x1d, 0x00 },\n\t{ 0x1e, 0x00 },\n\t{ 0x1f, 0x00 },\n\t{ 0x20, 0x00 },\n\t{ 0x21, 0x00 },\n\t{ 0x22, 0x00 },\n\t{ 0x23, 0x00 },\n\t{ 0x24, 0x00 },\n\t{ 0x25, 0x00 },\n\t{ 0x26, 0x00 },\n\t{ 0x27, 0x2a },\n\t{ 0x28, 0xc0 },\n\t{ 0x29, 0xf3 },\n\t{ 0x2a, 0x33 },\n\t{ 0x2b, 0x00 },\n\t{ 0x2c, 0x0c },\n\t{ 0x31, 0x00 },\n\t{ 0x36, 0x00 },\n\t{ 0x37, 0x00 },\n\t{ 0x38, 0x00 },\n\t{ 0x39, 0x01 },\n\t{ 0x3a, 0xee },\n\t{ 0x3b, 0xff },\n\t{ 0x3c, 0x7e },\n\t{ 0x3d, 0xc0 },\n\t{ 0x3e, 0x26 },\n\t{ 0x3f, 0x00 },\n\t{ 0x48, 0x00 },\n\t{ 0x49, 0x00 },\n\t{ 0x4a, 0x00 },\n\t{ 0x4b, 0x04 },\n\t{ 0x4c, 0x00 },\n};\n\nstatic const struct regmap_range sta350_write_regs_range[] = {\n\tregmap_reg_range(STA350_CONFA,  STA350_AUTO2),\n\tregmap_reg_range(STA350_C1CFG,  STA350_FDRC2),\n\tregmap_reg_range(STA350_EQCFG,  STA350_EVOLRES),\n\tregmap_reg_range(STA350_NSHAPE, STA350_MISC2),\n};\n\nstatic const struct regmap_range sta350_read_regs_range[] = {\n\tregmap_reg_range(STA350_CONFA,  STA350_AUTO2),\n\tregmap_reg_range(STA350_C1CFG,  STA350_STATUS),\n\tregmap_reg_range(STA350_EQCFG,  STA350_EVOLRES),\n\tregmap_reg_range(STA350_NSHAPE, STA350_MISC2),\n};\n\nstatic const struct regmap_range sta350_volatile_regs_range[] = {\n\tregmap_reg_range(STA350_CFADDR2, STA350_CFUD),\n\tregmap_reg_range(STA350_STATUS,  STA350_STATUS),\n};\n\nstatic const struct regmap_access_table sta350_write_regs = {\n\t.yes_ranges =\tsta350_write_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta350_write_regs_range),\n};\n\nstatic const struct regmap_access_table sta350_read_regs = {\n\t.yes_ranges =\tsta350_read_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta350_read_regs_range),\n};\n\nstatic const struct regmap_access_table sta350_volatile_regs = {\n\t.yes_ranges =\tsta350_volatile_regs_range,\n\t.n_yes_ranges =\tARRAY_SIZE(sta350_volatile_regs_range),\n};\n\n \nstatic const char * const sta350_supply_names[] = {\n\t\"vdd-dig\",\t \n\t\"vdd-pll\",\t \n\t\"vcc\"\t\t \n};\n\n \nstruct sta350_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[ARRAY_SIZE(sta350_supply_names)];\n\tstruct sta350_platform_data *pdata;\n\n\tunsigned int mclk;\n\tunsigned int format;\n\n\tu32 coef_shadow[STA350_COEF_COUNT];\n\tint shutdown;\n\n\tstruct gpio_desc *gpiod_nreset;\n\tstruct gpio_desc *gpiod_power_down;\n\n\tstruct mutex coeff_lock;\n};\n\nstatic const DECLARE_TLV_DB_SCALE(mvol_tlv, -12750, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(chvol_tlv, -7950, 50, 1);\nstatic const DECLARE_TLV_DB_SCALE(tone_tlv, -1200, 200, 0);\n\nstatic const char * const sta350_drc_ac[] = {\n\t\"Anti-Clipping\", \"Dynamic Range Compression\"\n};\nstatic const char * const sta350_auto_gc_mode[] = {\n\t\"User\", \"AC no clipping\", \"AC limited clipping (10%)\",\n\t\"DRC nighttime listening mode\"\n};\nstatic const char * const sta350_auto_xo_mode[] = {\n\t\"User\", \"80Hz\", \"100Hz\", \"120Hz\", \"140Hz\", \"160Hz\", \"180Hz\",\n\t\"200Hz\", \"220Hz\", \"240Hz\", \"260Hz\", \"280Hz\", \"300Hz\", \"320Hz\",\n\t\"340Hz\", \"360Hz\"\n};\nstatic const char * const sta350_binary_output[] = {\n\t\"FFX 3-state output - normal operation\", \"Binary output\"\n};\nstatic const char * const sta350_limiter_select[] = {\n\t\"Limiter Disabled\", \"Limiter #1\", \"Limiter #2\"\n};\nstatic const char * const sta350_limiter_attack_rate[] = {\n\t\"3.1584\", \"2.7072\", \"2.2560\", \"1.8048\", \"1.3536\", \"0.9024\",\n\t\"0.4512\", \"0.2256\", \"0.1504\", \"0.1123\", \"0.0902\", \"0.0752\",\n\t\"0.0645\", \"0.0564\", \"0.0501\", \"0.0451\"\n};\nstatic const char * const sta350_limiter_release_rate[] = {\n\t\"0.5116\", \"0.1370\", \"0.0744\", \"0.0499\", \"0.0360\", \"0.0299\",\n\t\"0.0264\", \"0.0208\", \"0.0198\", \"0.0172\", \"0.0147\", \"0.0137\",\n\t\"0.0134\", \"0.0117\", \"0.0110\", \"0.0104\"\n};\nstatic const char * const sta350_noise_shaper_type[] = {\n\t\"Third order\", \"Fourth order\"\n};\n\nstatic DECLARE_TLV_DB_RANGE(sta350_limiter_ac_attack_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-1200, 200, 0),\n\t8, 16, TLV_DB_SCALE_ITEM(300, 100, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta350_limiter_ac_release_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),\n\t1, 1, TLV_DB_SCALE_ITEM(-2900, 0, 0),\n\t2, 2, TLV_DB_SCALE_ITEM(-2000, 0, 0),\n\t3, 8, TLV_DB_SCALE_ITEM(-1400, 200, 0),\n\t8, 16, TLV_DB_SCALE_ITEM(-700, 100, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta350_limiter_drc_attack_tlv,\n\t0, 7, TLV_DB_SCALE_ITEM(-3100, 200, 0),\n\t8, 13, TLV_DB_SCALE_ITEM(-1600, 100, 0),\n\t14, 16, TLV_DB_SCALE_ITEM(-1000, 300, 0),\n);\n\nstatic DECLARE_TLV_DB_RANGE(sta350_limiter_drc_release_tlv,\n\t0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 0),\n\t1, 2, TLV_DB_SCALE_ITEM(-3800, 200, 0),\n\t3, 4, TLV_DB_SCALE_ITEM(-3300, 200, 0),\n\t5, 12, TLV_DB_SCALE_ITEM(-3000, 200, 0),\n\t13, 16, TLV_DB_SCALE_ITEM(-1500, 300, 0),\n);\n\nstatic SOC_ENUM_SINGLE_DECL(sta350_drc_ac_enum,\n\t\t\t    STA350_CONFD, STA350_CONFD_DRC_SHIFT,\n\t\t\t    sta350_drc_ac);\nstatic SOC_ENUM_SINGLE_DECL(sta350_noise_shaper_enum,\n\t\t\t    STA350_CONFE, STA350_CONFE_NSBW_SHIFT,\n\t\t\t    sta350_noise_shaper_type);\nstatic SOC_ENUM_SINGLE_DECL(sta350_auto_gc_enum,\n\t\t\t    STA350_AUTO1, STA350_AUTO1_AMGC_SHIFT,\n\t\t\t    sta350_auto_gc_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta350_auto_xo_enum,\n\t\t\t    STA350_AUTO2, STA350_AUTO2_XO_SHIFT,\n\t\t\t    sta350_auto_xo_mode);\nstatic SOC_ENUM_SINGLE_DECL(sta350_binary_output_ch1_enum,\n\t\t\t    STA350_C1CFG, STA350_CxCFG_BO_SHIFT,\n\t\t\t    sta350_binary_output);\nstatic SOC_ENUM_SINGLE_DECL(sta350_binary_output_ch2_enum,\n\t\t\t    STA350_C2CFG, STA350_CxCFG_BO_SHIFT,\n\t\t\t    sta350_binary_output);\nstatic SOC_ENUM_SINGLE_DECL(sta350_binary_output_ch3_enum,\n\t\t\t    STA350_C3CFG, STA350_CxCFG_BO_SHIFT,\n\t\t\t    sta350_binary_output);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter_ch1_enum,\n\t\t\t    STA350_C1CFG, STA350_CxCFG_LS_SHIFT,\n\t\t\t    sta350_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter_ch2_enum,\n\t\t\t    STA350_C2CFG, STA350_CxCFG_LS_SHIFT,\n\t\t\t    sta350_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter_ch3_enum,\n\t\t\t    STA350_C3CFG, STA350_CxCFG_LS_SHIFT,\n\t\t\t    sta350_limiter_select);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter1_attack_rate_enum,\n\t\t\t    STA350_L1AR, STA350_LxA_SHIFT,\n\t\t\t    sta350_limiter_attack_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter2_attack_rate_enum,\n\t\t\t    STA350_L2AR, STA350_LxA_SHIFT,\n\t\t\t    sta350_limiter_attack_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter1_release_rate_enum,\n\t\t\t    STA350_L1AR, STA350_LxR_SHIFT,\n\t\t\t    sta350_limiter_release_rate);\nstatic SOC_ENUM_SINGLE_DECL(sta350_limiter2_release_rate_enum,\n\t\t\t    STA350_L2AR, STA350_LxR_SHIFT,\n\t\t\t    sta350_limiter_release_rate);\n\n \n\nstatic int sta350_coefficient_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tint numcoef = kcontrol->private_value >> 16;\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\n\tuinfo->count = 3 * numcoef;\n\treturn 0;\n}\n\nstatic int sta350_coefficient_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\tunsigned int cfud, val;\n\tint i, ret = 0;\n\n\tmutex_lock(&sta350->coeff_lock);\n\n\t \n\tregmap_read(sta350->regmap, STA350_CFUD, &cfud);\n\tcfud &= 0xf0;\n\t \n\tregmap_write(sta350->regmap, STA350_CFUD, cfud);\n\n\tregmap_write(sta350->regmap, STA350_CFADDR2, index);\n\tif (numcoef == 1) {\n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x04);\n\t} else if (numcoef == 5) {\n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x08);\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto exit_unlock;\n\t}\n\n\tfor (i = 0; i < 3 * numcoef; i++) {\n\t\tregmap_read(sta350->regmap, STA350_B1CF1 + i, &val);\n\t\tucontrol->value.bytes.data[i] = val;\n\t}\n\nexit_unlock:\n\tmutex_unlock(&sta350->coeff_lock);\n\n\treturn ret;\n}\n\nstatic int sta350_coefficient_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tint numcoef = kcontrol->private_value >> 16;\n\tint index = kcontrol->private_value & 0xffff;\n\tunsigned int cfud;\n\tint i;\n\n\t \n\tregmap_read(sta350->regmap, STA350_CFUD, &cfud);\n\tcfud &= 0xf0;\n\t \n\tregmap_write(sta350->regmap, STA350_CFUD, cfud);\n\n\tregmap_write(sta350->regmap, STA350_CFADDR2, index);\n\tfor (i = 0; i < numcoef && (index + i < STA350_COEF_COUNT); i++)\n\t\tsta350->coef_shadow[index + i] =\n\t\t\t  (ucontrol->value.bytes.data[3 * i] << 16)\n\t\t\t| (ucontrol->value.bytes.data[3 * i + 1] << 8)\n\t\t\t| (ucontrol->value.bytes.data[3 * i + 2]);\n\tfor (i = 0; i < 3 * numcoef; i++)\n\t\tregmap_write(sta350->regmap, STA350_B1CF1 + i,\n\t\t\t     ucontrol->value.bytes.data[i]);\n\tif (numcoef == 1)\n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x01);\n\telse if (numcoef == 5)\n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x02);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int sta350_sync_coef_shadow(struct snd_soc_component *component)\n{\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tunsigned int cfud;\n\tint i;\n\n\t \n\tregmap_read(sta350->regmap, STA350_CFUD, &cfud);\n\tcfud &= 0xf0;\n\n\tfor (i = 0; i < STA350_COEF_COUNT; i++) {\n\t\tregmap_write(sta350->regmap, STA350_CFADDR2, i);\n\t\tregmap_write(sta350->regmap, STA350_B1CF1,\n\t\t\t     (sta350->coef_shadow[i] >> 16) & 0xff);\n\t\tregmap_write(sta350->regmap, STA350_B1CF2,\n\t\t\t     (sta350->coef_shadow[i] >> 8) & 0xff);\n\t\tregmap_write(sta350->regmap, STA350_B1CF3,\n\t\t\t     (sta350->coef_shadow[i]) & 0xff);\n\t\t \n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud);\n\t\tregmap_write(sta350->regmap, STA350_CFUD, cfud | 0x01);\n\t}\n\treturn 0;\n}\n\nstatic int sta350_cache_sync(struct snd_soc_component *component)\n{\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tunsigned int mute;\n\tint rc;\n\n\t \n\tregmap_read(sta350->regmap, STA350_CFUD, &mute);\n\tregmap_write(sta350->regmap, STA350_MMUTE, mute | STA350_MMUTE_MMUTE);\n\tsta350_sync_coef_shadow(component);\n\trc = regcache_sync(sta350->regmap);\n\tregmap_write(sta350->regmap, STA350_MMUTE, mute);\n\treturn rc;\n}\n\n#define SINGLE_COEF(xname, index) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = sta350_coefficient_info, \\\n\t.get = sta350_coefficient_get,\\\n\t.put = sta350_coefficient_put, \\\n\t.private_value = index | (1 << 16) }\n\n#define BIQUAD_COEFS(xname, index) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\\n\t.info = sta350_coefficient_info, \\\n\t.get = sta350_coefficient_get,\\\n\t.put = sta350_coefficient_put, \\\n\t.private_value = index | (5 << 16) }\n\nstatic const struct snd_kcontrol_new sta350_snd_controls[] = {\nSOC_SINGLE_TLV(\"Master Volume\", STA350_MVOL, 0, 0xff, 1, mvol_tlv),\n \nSOC_SINGLE_TLV(\"Ch1 Volume\", STA350_C1VOL, 0, 0xff, 1, chvol_tlv),\nSOC_SINGLE_TLV(\"Ch2 Volume\", STA350_C2VOL, 0, 0xff, 1, chvol_tlv),\nSOC_SINGLE_TLV(\"Ch3 Volume\", STA350_C3VOL, 0, 0xff, 1, chvol_tlv),\n \nSOC_SINGLE(\"High Pass Filter Bypass Switch\",\n\t   STA350_CONFD, STA350_CONFD_HPB_SHIFT, 1, 1),\nSOC_SINGLE(\"De-emphasis Filter Switch\",\n\t   STA350_CONFD, STA350_CONFD_DEMP_SHIFT, 1, 0),\nSOC_SINGLE(\"DSP Bypass Switch\",\n\t   STA350_CONFD, STA350_CONFD_DSPB_SHIFT, 1, 0),\nSOC_SINGLE(\"Post-scale Link Switch\",\n\t   STA350_CONFD, STA350_CONFD_PSL_SHIFT, 1, 0),\nSOC_SINGLE(\"Biquad Coefficient Link Switch\",\n\t   STA350_CONFD, STA350_CONFD_BQL_SHIFT, 1, 0),\nSOC_ENUM(\"Compressor/Limiter Switch\", sta350_drc_ac_enum),\nSOC_ENUM(\"Noise Shaper Bandwidth\", sta350_noise_shaper_enum),\nSOC_SINGLE(\"Zero-detect Mute Enable Switch\",\n\t   STA350_CONFD, STA350_CONFD_ZDE_SHIFT, 1, 0),\nSOC_SINGLE(\"Submix Mode Switch\",\n\t   STA350_CONFD, STA350_CONFD_SME_SHIFT, 1, 0),\n \nSOC_SINGLE(\"Zero Cross Switch\", STA350_CONFE, STA350_CONFE_ZCE_SHIFT, 1, 0),\nSOC_SINGLE(\"Soft Ramp Switch\", STA350_CONFE, STA350_CONFE_SVE_SHIFT, 1, 0),\n \nSOC_SINGLE(\"Master Switch\", STA350_MMUTE, STA350_MMUTE_MMUTE_SHIFT, 1, 1),\nSOC_SINGLE(\"Ch1 Switch\", STA350_MMUTE, STA350_MMUTE_C1M_SHIFT, 1, 1),\nSOC_SINGLE(\"Ch2 Switch\", STA350_MMUTE, STA350_MMUTE_C2M_SHIFT, 1, 1),\nSOC_SINGLE(\"Ch3 Switch\", STA350_MMUTE, STA350_MMUTE_C3M_SHIFT, 1, 1),\n \nSOC_ENUM(\"Automode GC\", sta350_auto_gc_enum),\nSOC_ENUM(\"Automode XO\", sta350_auto_xo_enum),\n \nSOC_SINGLE(\"Ch1 Tone Control Bypass Switch\",\n\t   STA350_C1CFG, STA350_CxCFG_TCB_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 Tone Control Bypass Switch\",\n\t   STA350_C2CFG, STA350_CxCFG_TCB_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch1 EQ Bypass Switch\",\n\t   STA350_C1CFG, STA350_CxCFG_EQBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 EQ Bypass Switch\",\n\t   STA350_C2CFG, STA350_CxCFG_EQBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch1 Master Volume Bypass Switch\",\n\t   STA350_C1CFG, STA350_CxCFG_VBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch2 Master Volume Bypass Switch\",\n\t   STA350_C1CFG, STA350_CxCFG_VBP_SHIFT, 1, 0),\nSOC_SINGLE(\"Ch3 Master Volume Bypass Switch\",\n\t   STA350_C1CFG, STA350_CxCFG_VBP_SHIFT, 1, 0),\nSOC_ENUM(\"Ch1 Binary Output Select\", sta350_binary_output_ch1_enum),\nSOC_ENUM(\"Ch2 Binary Output Select\", sta350_binary_output_ch2_enum),\nSOC_ENUM(\"Ch3 Binary Output Select\", sta350_binary_output_ch3_enum),\nSOC_ENUM(\"Ch1 Limiter Select\", sta350_limiter_ch1_enum),\nSOC_ENUM(\"Ch2 Limiter Select\", sta350_limiter_ch2_enum),\nSOC_ENUM(\"Ch3 Limiter Select\", sta350_limiter_ch3_enum),\n \nSOC_SINGLE_RANGE_TLV(\"Bass Tone Control Volume\",\n\t\t     STA350_TONE, STA350_TONE_BTC_SHIFT, 1, 13, 0, tone_tlv),\nSOC_SINGLE_RANGE_TLV(\"Treble Tone Control Volume\",\n\t\t     STA350_TONE, STA350_TONE_TTC_SHIFT, 1, 13, 0, tone_tlv),\nSOC_ENUM(\"Limiter1 Attack Rate (dB/ms)\", sta350_limiter1_attack_rate_enum),\nSOC_ENUM(\"Limiter2 Attack Rate (dB/ms)\", sta350_limiter2_attack_rate_enum),\nSOC_ENUM(\"Limiter1 Release Rate (dB/ms)\", sta350_limiter1_release_rate_enum),\nSOC_ENUM(\"Limiter2 Release Rate (dB/ms)\", sta350_limiter2_release_rate_enum),\n\n \nSOC_SINGLE_TLV(\"Limiter1 Attack Threshold (AC Mode)\",\n\t       STA350_L1ATRT, STA350_LxA_SHIFT,\n\t       16, 0, sta350_limiter_ac_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Attack Threshold (AC Mode)\",\n\t       STA350_L2ATRT, STA350_LxA_SHIFT,\n\t       16, 0, sta350_limiter_ac_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Release Threshold (AC Mode)\",\n\t       STA350_L1ATRT, STA350_LxR_SHIFT,\n\t       16, 0, sta350_limiter_ac_release_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Release Threshold (AC Mode)\",\n\t       STA350_L2ATRT, STA350_LxR_SHIFT,\n\t       16, 0, sta350_limiter_ac_release_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Attack Threshold (DRC Mode)\",\n\t       STA350_L1ATRT, STA350_LxA_SHIFT,\n\t       16, 0, sta350_limiter_drc_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Attack Threshold (DRC Mode)\",\n\t       STA350_L2ATRT, STA350_LxA_SHIFT,\n\t       16, 0, sta350_limiter_drc_attack_tlv),\nSOC_SINGLE_TLV(\"Limiter1 Release Threshold (DRC Mode)\",\n\t       STA350_L1ATRT, STA350_LxR_SHIFT,\n\t       16, 0, sta350_limiter_drc_release_tlv),\nSOC_SINGLE_TLV(\"Limiter2 Release Threshold (DRC Mode)\",\n\t       STA350_L2ATRT, STA350_LxR_SHIFT,\n\t       16, 0, sta350_limiter_drc_release_tlv),\n\nBIQUAD_COEFS(\"Ch1 - Biquad 1\", 0),\nBIQUAD_COEFS(\"Ch1 - Biquad 2\", 5),\nBIQUAD_COEFS(\"Ch1 - Biquad 3\", 10),\nBIQUAD_COEFS(\"Ch1 - Biquad 4\", 15),\nBIQUAD_COEFS(\"Ch2 - Biquad 1\", 20),\nBIQUAD_COEFS(\"Ch2 - Biquad 2\", 25),\nBIQUAD_COEFS(\"Ch2 - Biquad 3\", 30),\nBIQUAD_COEFS(\"Ch2 - Biquad 4\", 35),\nBIQUAD_COEFS(\"High-pass\", 40),\nBIQUAD_COEFS(\"Low-pass\", 45),\nSINGLE_COEF(\"Ch1 - Prescale\", 50),\nSINGLE_COEF(\"Ch2 - Prescale\", 51),\nSINGLE_COEF(\"Ch1 - Postscale\", 52),\nSINGLE_COEF(\"Ch2 - Postscale\", 53),\nSINGLE_COEF(\"Ch3 - Postscale\", 54),\nSINGLE_COEF(\"Thermal warning - Postscale\", 55),\nSINGLE_COEF(\"Ch1 - Mix 1\", 56),\nSINGLE_COEF(\"Ch1 - Mix 2\", 57),\nSINGLE_COEF(\"Ch2 - Mix 1\", 58),\nSINGLE_COEF(\"Ch2 - Mix 2\", 59),\nSINGLE_COEF(\"Ch3 - Mix 1\", 60),\nSINGLE_COEF(\"Ch3 - Mix 2\", 61),\n};\n\nstatic const struct snd_soc_dapm_widget sta350_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC\", NULL, SND_SOC_NOPM, 0, 0),\nSND_SOC_DAPM_OUTPUT(\"LEFT\"),\nSND_SOC_DAPM_OUTPUT(\"RIGHT\"),\nSND_SOC_DAPM_OUTPUT(\"SUB\"),\n};\n\nstatic const struct snd_soc_dapm_route sta350_dapm_routes[] = {\n\t{ \"LEFT\", NULL, \"DAC\" },\n\t{ \"RIGHT\", NULL, \"DAC\" },\n\t{ \"SUB\", NULL, \"DAC\" },\n\t{ \"DAC\", NULL, \"Playback\" },\n};\n\n \nstatic struct {\n\tint fs;\n\tint ir;\n} interpolation_ratios[] = {\n\t{ 32000, 0 },\n\t{ 44100, 0 },\n\t{ 48000, 0 },\n\t{ 88200, 1 },\n\t{ 96000, 1 },\n\t{ 176400, 2 },\n\t{ 192000, 2 },\n};\n\n \nstatic int mcs_ratio_table[3][6] = {\n\t{ 768, 512, 384, 256, 128, 576 },\n\t{ 384, 256, 192, 128,  64,   0 },\n\t{ 192, 128,  96,  64,  32,   0 },\n};\n\n \nstatic int sta350_set_dai_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t\t int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(component->dev, \"mclk=%u\\n\", freq);\n\tsta350->mclk = freq;\n\n\treturn 0;\n}\n\n \nstatic int sta350_set_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tunsigned int confb = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBC_CFC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tsta350->format = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tconfb |= STA350_CONFB_C2IM;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tconfb |= STA350_CONFB_C1IM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(sta350->regmap, STA350_CONFB,\n\t\t\t\t  STA350_CONFB_C1IM | STA350_CONFB_C2IM, confb);\n}\n\n \nstatic int sta350_hw_params(struct snd_pcm_substream *substream,\n\t\t\t    struct snd_pcm_hw_params *params,\n\t\t\t    struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tint i, mcs = -EINVAL, ir = -EINVAL;\n\tunsigned int confa, confb;\n\tunsigned int rate, ratio;\n\tint ret;\n\n\tif (!sta350->mclk) {\n\t\tdev_err(component->dev,\n\t\t\t\"sta350->mclk is unset. Unable to determine ratio\\n\");\n\t\treturn -EIO;\n\t}\n\n\trate = params_rate(params);\n\tratio = sta350->mclk / rate;\n\tdev_dbg(component->dev, \"rate: %u, ratio: %u\\n\", rate, ratio);\n\n\tfor (i = 0; i < ARRAY_SIZE(interpolation_ratios); i++) {\n\t\tif (interpolation_ratios[i].fs == rate) {\n\t\t\tir = interpolation_ratios[i].ir;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ir < 0) {\n\t\tdev_err(component->dev, \"Unsupported samplerate: %u\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mcs_ratio_table[ir][i] == ratio) {\n\t\t\tmcs = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mcs < 0) {\n\t\tdev_err(component->dev, \"Unresolvable ratio: %u\\n\", ratio);\n\t\treturn -EINVAL;\n\t}\n\n\tconfa = (ir << STA350_CONFA_IR_SHIFT) |\n\t\t(mcs << STA350_CONFA_MCS_SHIFT);\n\tconfb = 0;\n\n\tswitch (params_width(params)) {\n\tcase 24:\n\t\tdev_dbg(component->dev, \"24bit\\n\");\n\t\tfallthrough;\n\tcase 32:\n\t\tdev_dbg(component->dev, \"24bit or 32bit\\n\");\n\t\tswitch (sta350->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x0;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x1;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0x2;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 20:\n\t\tdev_dbg(component->dev, \"20bit\\n\");\n\t\tswitch (sta350->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x4;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x5;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0x6;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 18:\n\t\tdev_dbg(component->dev, \"18bit\\n\");\n\t\tswitch (sta350->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x8;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0x9;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0xa;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase 16:\n\t\tdev_dbg(component->dev, \"16bit\\n\");\n\t\tswitch (sta350->format) {\n\t\tcase SND_SOC_DAIFMT_I2S:\n\t\t\tconfb |= 0x0;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\t\tconfb |= 0xd;\n\t\t\tbreak;\n\t\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\t\tconfb |= 0xe;\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_update_bits(sta350->regmap, STA350_CONFA,\n\t\t\t\t STA350_CONFA_MCS_MASK | STA350_CONFA_IR_MASK,\n\t\t\t\t confa);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(sta350->regmap, STA350_CONFB,\n\t\t\t\t STA350_CONFB_SAI_MASK | STA350_CONFB_SAIFB,\n\t\t\t\t confb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int sta350_startup_sequence(struct sta350_priv *sta350)\n{\n\tif (sta350->gpiod_power_down)\n\t\tgpiod_set_value(sta350->gpiod_power_down, 1);\n\n\tif (sta350->gpiod_nreset) {\n\t\tgpiod_set_value(sta350->gpiod_nreset, 0);\n\t\tmdelay(1);\n\t\tgpiod_set_value(sta350->gpiod_nreset, 1);\n\t\tmdelay(1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sta350_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t enum snd_soc_bias_level level)\n{\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\tdev_dbg(component->dev, \"level = %d\\n\", level);\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_PREPARE:\n\t\t \n\t\tregmap_update_bits(sta350->regmap, STA350_CONFF,\n\t\t\t\t   STA350_CONFF_PWDN | STA350_CONFF_EAPD,\n\t\t\t\t   STA350_CONFF_PWDN | STA350_CONFF_EAPD);\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\tret = regulator_bulk_enable(\n\t\t\t\tARRAY_SIZE(sta350->supplies),\n\t\t\t\tsta350->supplies);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"Failed to enable supplies: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tsta350_startup_sequence(sta350);\n\t\t\tsta350_cache_sync(component);\n\t\t}\n\n\t\t \n\t\tregmap_update_bits(sta350->regmap, STA350_CONFF,\n\t\t\t\t   STA350_CONFF_PWDN | STA350_CONFF_EAPD,\n\t\t\t\t   0);\n\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\t \n\t\tregmap_update_bits(sta350->regmap, STA350_CONFF,\n\t\t\t\t   STA350_CONFF_PWDN | STA350_CONFF_EAPD, 0);\n\n\t\t \n\t\tif (sta350->gpiod_power_down)\n\t\t\tgpiod_set_value(sta350->gpiod_power_down, 0);\n\n\t\tif (sta350->gpiod_nreset)\n\t\t\tgpiod_set_value(sta350->gpiod_nreset, 0);\n\n\t\tregulator_bulk_disable(ARRAY_SIZE(sta350->supplies),\n\t\t\t\t       sta350->supplies);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dai_ops sta350_dai_ops = {\n\t.hw_params\t= sta350_hw_params,\n\t.set_sysclk\t= sta350_set_dai_sysclk,\n\t.set_fmt\t= sta350_set_dai_fmt,\n};\n\nstatic struct snd_soc_dai_driver sta350_dai = {\n\t.name = \"sta350-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = STA350_RATES,\n\t\t.formats = STA350_FORMATS,\n\t},\n\t.ops = &sta350_dai_ops,\n};\n\nstatic int sta350_probe(struct snd_soc_component *component)\n{\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\tstruct sta350_platform_data *pdata = sta350->pdata;\n\tint i, ret = 0, thermal = 0;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(sta350->supplies),\n\t\t\t\t    sta350->supplies);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sta350_startup_sequence(sta350);\n\tif (ret < 0) {\n\t\tdev_err(component->dev, \"Failed to startup device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!pdata->thermal_warning_recovery)\n\t\tthermal |= STA350_CONFA_TWAB;\n\tif (!pdata->thermal_warning_adjustment)\n\t\tthermal |= STA350_CONFA_TWRB;\n\tif (!pdata->fault_detect_recovery)\n\t\tthermal |= STA350_CONFA_FDRB;\n\tregmap_update_bits(sta350->regmap, STA350_CONFA,\n\t\t\t   STA350_CONFA_TWAB | STA350_CONFA_TWRB |\n\t\t\t   STA350_CONFA_FDRB,\n\t\t\t   thermal);\n\n\t \n\tregmap_update_bits(sta350->regmap, STA350_CONFC,\n\t\t\t   STA350_CONFC_OM_MASK,\n\t\t\t   pdata->ffx_power_output_mode\n\t\t\t\t<< STA350_CONFC_OM_SHIFT);\n\tregmap_update_bits(sta350->regmap, STA350_CONFC,\n\t\t\t   STA350_CONFC_CSZ_MASK,\n\t\t\t   pdata->drop_compensation_ns\n\t\t\t\t<< STA350_CONFC_CSZ_SHIFT);\n\tregmap_update_bits(sta350->regmap,\n\t\t\t   STA350_CONFC,\n\t\t\t   STA350_CONFC_OCRB,\n\t\t\t   pdata->oc_warning_adjustment ?\n\t\t\t\tSTA350_CONFC_OCRB : 0);\n\n\t \n\tregmap_update_bits(sta350->regmap, STA350_CONFE,\n\t\t\t   STA350_CONFE_MPCV,\n\t\t\t   pdata->max_power_use_mpcc ?\n\t\t\t\tSTA350_CONFE_MPCV : 0);\n\tregmap_update_bits(sta350->regmap, STA350_CONFE,\n\t\t\t   STA350_CONFE_MPC,\n\t\t\t   pdata->max_power_correction ?\n\t\t\t\tSTA350_CONFE_MPC : 0);\n\tregmap_update_bits(sta350->regmap, STA350_CONFE,\n\t\t\t   STA350_CONFE_AME,\n\t\t\t   pdata->am_reduction_mode ?\n\t\t\t\tSTA350_CONFE_AME : 0);\n\tregmap_update_bits(sta350->regmap, STA350_CONFE,\n\t\t\t   STA350_CONFE_PWMS,\n\t\t\t   pdata->odd_pwm_speed_mode ?\n\t\t\t\tSTA350_CONFE_PWMS : 0);\n\tregmap_update_bits(sta350->regmap, STA350_CONFE,\n\t\t\t   STA350_CONFE_DCCV,\n\t\t\t   pdata->distortion_compensation ?\n\t\t\t\tSTA350_CONFE_DCCV : 0);\n\t \n\tregmap_update_bits(sta350->regmap, STA350_CONFF,\n\t\t\t   STA350_CONFF_IDE,\n\t\t\t   pdata->invalid_input_detect_mute ?\n\t\t\t\tSTA350_CONFF_IDE : 0);\n\tregmap_update_bits(sta350->regmap, STA350_CONFF,\n\t\t\t   STA350_CONFF_OCFG_MASK,\n\t\t\t   pdata->output_conf\n\t\t\t\t<< STA350_CONFF_OCFG_SHIFT);\n\n\t \n\tregmap_update_bits(sta350->regmap, STA350_C1CFG,\n\t\t\t   STA350_CxCFG_OM_MASK,\n\t\t\t   pdata->ch1_output_mapping\n\t\t\t\t<< STA350_CxCFG_OM_SHIFT);\n\tregmap_update_bits(sta350->regmap, STA350_C2CFG,\n\t\t\t   STA350_CxCFG_OM_MASK,\n\t\t\t   pdata->ch2_output_mapping\n\t\t\t\t<< STA350_CxCFG_OM_SHIFT);\n\tregmap_update_bits(sta350->regmap, STA350_C3CFG,\n\t\t\t   STA350_CxCFG_OM_MASK,\n\t\t\t   pdata->ch3_output_mapping\n\t\t\t\t<< STA350_CxCFG_OM_SHIFT);\n\n\t \n\tregmap_update_bits(sta350->regmap, STA350_MISC1,\n\t\t\t   STA350_MISC1_CPWMEN,\n\t\t\t   pdata->activate_mute_output ?\n\t\t\t\tSTA350_MISC1_CPWMEN : 0);\n\tregmap_update_bits(sta350->regmap, STA350_MISC1,\n\t\t\t   STA350_MISC1_BRIDGOFF,\n\t\t\t   pdata->bridge_immediate_off ?\n\t\t\t\tSTA350_MISC1_BRIDGOFF : 0);\n\tregmap_update_bits(sta350->regmap, STA350_MISC1,\n\t\t\t   STA350_MISC1_NSHHPEN,\n\t\t\t   pdata->noise_shape_dc_cut ?\n\t\t\t\tSTA350_MISC1_NSHHPEN : 0);\n\tregmap_update_bits(sta350->regmap, STA350_MISC1,\n\t\t\t   STA350_MISC1_RPDNEN,\n\t\t\t   pdata->powerdown_master_vol ?\n\t\t\t\tSTA350_MISC1_RPDNEN: 0);\n\n\tregmap_update_bits(sta350->regmap, STA350_MISC2,\n\t\t\t   STA350_MISC2_PNDLSL_MASK,\n\t\t\t   pdata->powerdown_delay_divider\n\t\t\t\t<< STA350_MISC2_PNDLSL_SHIFT);\n\n\t \n\tfor (i = 4; i <= 49; i += 5)\n\t\tsta350->coef_shadow[i] = 0x400000;\n\tfor (i = 50; i <= 54; i++)\n\t\tsta350->coef_shadow[i] = 0x7fffff;\n\tsta350->coef_shadow[55] = 0x5a9df7;\n\tsta350->coef_shadow[56] = 0x7fffff;\n\tsta350->coef_shadow[59] = 0x7fffff;\n\tsta350->coef_shadow[60] = 0x400000;\n\tsta350->coef_shadow[61] = 0x400000;\n\n\tsnd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);\n\t \n\tregulator_bulk_disable(ARRAY_SIZE(sta350->supplies), sta350->supplies);\n\n\treturn 0;\n}\n\nstatic void sta350_remove(struct snd_soc_component *component)\n{\n\tstruct sta350_priv *sta350 = snd_soc_component_get_drvdata(component);\n\n\tregulator_bulk_disable(ARRAY_SIZE(sta350->supplies), sta350->supplies);\n}\n\nstatic const struct snd_soc_component_driver sta350_component = {\n\t.probe\t\t\t= sta350_probe,\n\t.remove\t\t\t= sta350_remove,\n\t.set_bias_level\t\t= sta350_set_bias_level,\n\t.controls\t\t= sta350_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(sta350_snd_controls),\n\t.dapm_widgets\t\t= sta350_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(sta350_dapm_widgets),\n\t.dapm_routes\t\t= sta350_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(sta350_dapm_routes),\n\t.suspend_bias_off\t= 1,\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config sta350_regmap = {\n\t.reg_bits =\t\t8,\n\t.val_bits =\t\t8,\n\t.max_register =\t\tSTA350_MISC2,\n\t.reg_defaults =\t\tsta350_regs,\n\t.num_reg_defaults =\tARRAY_SIZE(sta350_regs),\n\t.cache_type =\t\tREGCACHE_MAPLE,\n\t.wr_table =\t\t&sta350_write_regs,\n\t.rd_table =\t\t&sta350_read_regs,\n\t.volatile_table =\t&sta350_volatile_regs,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id st350_dt_ids[] = {\n\t{ .compatible = \"st,sta350\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, st350_dt_ids);\n\nstatic const char * const sta350_ffx_modes[] = {\n\t[STA350_FFX_PM_DROP_COMP]\t\t= \"drop-compensation\",\n\t[STA350_FFX_PM_TAPERED_COMP]\t\t= \"tapered-compensation\",\n\t[STA350_FFX_PM_FULL_POWER]\t\t= \"full-power-mode\",\n\t[STA350_FFX_PM_VARIABLE_DROP_COMP]\t= \"variable-drop-compensation\",\n};\n\nstatic int sta350_probe_dt(struct device *dev, struct sta350_priv *sta350)\n{\n\tstruct device_node *np = dev->of_node;\n\tstruct sta350_platform_data *pdata;\n\tconst char *ffx_power_mode;\n\tu16 tmp;\n\tu8 tmp8;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tof_property_read_u8(np, \"st,output-conf\",\n\t\t\t    &pdata->output_conf);\n\tof_property_read_u8(np, \"st,ch1-output-mapping\",\n\t\t\t    &pdata->ch1_output_mapping);\n\tof_property_read_u8(np, \"st,ch2-output-mapping\",\n\t\t\t    &pdata->ch2_output_mapping);\n\tof_property_read_u8(np, \"st,ch3-output-mapping\",\n\t\t\t    &pdata->ch3_output_mapping);\n\n\tpdata->thermal_warning_recovery =\n\t\tof_property_read_bool(np, \"st,thermal-warning-recovery\");\n\tpdata->thermal_warning_adjustment =\n\t\tof_property_read_bool(np, \"st,thermal-warning-adjustment\");\n\tpdata->fault_detect_recovery =\n\t\tof_property_read_bool(np, \"st,fault-detect-recovery\");\n\n\tpdata->ffx_power_output_mode = STA350_FFX_PM_VARIABLE_DROP_COMP;\n\tif (!of_property_read_string(np, \"st,ffx-power-output-mode\",\n\t\t\t\t     &ffx_power_mode)) {\n\t\tint i, mode = -EINVAL;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta350_ffx_modes); i++)\n\t\t\tif (!strcasecmp(ffx_power_mode, sta350_ffx_modes[i]))\n\t\t\t\tmode = i;\n\n\t\tif (mode < 0)\n\t\t\tdev_warn(dev, \"Unsupported ffx output mode: %s\\n\",\n\t\t\t\t ffx_power_mode);\n\t\telse\n\t\t\tpdata->ffx_power_output_mode = mode;\n\t}\n\n\ttmp = 140;\n\tof_property_read_u16(np, \"st,drop-compensation-ns\", &tmp);\n\tpdata->drop_compensation_ns = clamp_t(u16, tmp, 0, 300) / 20;\n\n\tpdata->oc_warning_adjustment =\n\t\tof_property_read_bool(np, \"st,overcurrent-warning-adjustment\");\n\n\t \n\tpdata->max_power_use_mpcc =\n\t\tof_property_read_bool(np, \"st,max-power-use-mpcc\");\n\tpdata->max_power_correction =\n\t\tof_property_read_bool(np, \"st,max-power-correction\");\n\tpdata->am_reduction_mode =\n\t\tof_property_read_bool(np, \"st,am-reduction-mode\");\n\tpdata->odd_pwm_speed_mode =\n\t\tof_property_read_bool(np, \"st,odd-pwm-speed-mode\");\n\tpdata->distortion_compensation =\n\t\tof_property_read_bool(np, \"st,distortion-compensation\");\n\n\t \n\tpdata->invalid_input_detect_mute =\n\t\tof_property_read_bool(np, \"st,invalid-input-detect-mute\");\n\n\t \n\tpdata->activate_mute_output =\n\t\tof_property_read_bool(np, \"st,activate-mute-output\");\n\tpdata->bridge_immediate_off =\n\t\tof_property_read_bool(np, \"st,bridge-immediate-off\");\n\tpdata->noise_shape_dc_cut =\n\t\tof_property_read_bool(np, \"st,noise-shape-dc-cut\");\n\tpdata->powerdown_master_vol =\n\t\tof_property_read_bool(np, \"st,powerdown-master-volume\");\n\n\tif (!of_property_read_u8(np, \"st,powerdown-delay-divider\", &tmp8)) {\n\t\tif (is_power_of_2(tmp8) && tmp8 >= 1 && tmp8 <= 128)\n\t\t\tpdata->powerdown_delay_divider = ilog2(tmp8);\n\t\telse\n\t\t\tdev_warn(dev, \"Unsupported powerdown delay divider %d\\n\",\n\t\t\t\t tmp8);\n\t}\n\n\tsta350->pdata = pdata;\n\n\treturn 0;\n}\n#endif\n\nstatic int sta350_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct device *dev = &i2c->dev;\n\tstruct sta350_priv *sta350;\n\tint ret, i;\n\n\tsta350 = devm_kzalloc(dev, sizeof(struct sta350_priv), GFP_KERNEL);\n\tif (!sta350)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sta350->coeff_lock);\n\tsta350->pdata = dev_get_platdata(dev);\n\n#ifdef CONFIG_OF\n\tif (dev->of_node) {\n\t\tret = sta350_probe_dt(dev, sta350);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n#endif\n\n\t \n\tsta350->gpiod_nreset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(sta350->gpiod_nreset))\n\t\treturn PTR_ERR(sta350->gpiod_nreset);\n\n\tsta350->gpiod_power_down = devm_gpiod_get_optional(dev, \"power-down\",\n\t\t\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(sta350->gpiod_power_down))\n\t\treturn PTR_ERR(sta350->gpiod_power_down);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(sta350->supplies); i++)\n\t\tsta350->supplies[i].supply = sta350_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(sta350->supplies),\n\t\t\t\t      sta350->supplies);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsta350->regmap = devm_regmap_init_i2c(i2c, &sta350_regmap);\n\tif (IS_ERR(sta350->regmap)) {\n\t\tret = PTR_ERR(sta350->regmap);\n\t\tdev_err(dev, \"Failed to init regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, sta350);\n\n\tret = devm_snd_soc_register_component(dev, &sta350_component, &sta350_dai, 1);\n\tif (ret < 0)\n\t\tdev_err(dev, \"Failed to register component (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void sta350_i2c_remove(struct i2c_client *client)\n{}\n\nstatic const struct i2c_device_id sta350_i2c_id[] = {\n\t{ \"sta350\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, sta350_i2c_id);\n\nstatic struct i2c_driver sta350_i2c_driver = {\n\t.driver = {\n\t\t.name = \"sta350\",\n\t\t.of_match_table = of_match_ptr(st350_dt_ids),\n\t},\n\t.probe =    sta350_i2c_probe,\n\t.remove =   sta350_i2c_remove,\n\t.id_table = sta350_i2c_id,\n};\n\nmodule_i2c_driver(sta350_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC STA350 driver\");\nMODULE_AUTHOR(\"Sven Brandau <info@brandau.biz>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}