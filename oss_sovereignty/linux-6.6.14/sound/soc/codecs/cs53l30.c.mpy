{
  "module_name": "cs53l30.c",
  "hash_id": "ab1372e2b38270acdf285c0ad388aa85b0408223a4cab3d0824f4753ffec845f",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/cs53l30.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of_gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n\n#include \"cs53l30.h\"\n#include \"cirrus_legacy.h\"\n\n#define CS53L30_NUM_SUPPLIES 2\nstatic const char *const cs53l30_supply_names[CS53L30_NUM_SUPPLIES] = {\n\t\"VA\",\n\t\"VP\",\n};\n\nstruct cs53l30_private {\n\tstruct regulator_bulk_data\tsupplies[CS53L30_NUM_SUPPLIES];\n\tstruct regmap\t\t\t*regmap;\n\tstruct gpio_desc\t\t*reset_gpio;\n\tstruct gpio_desc\t\t*mute_gpio;\n\tstruct clk\t\t\t*mclk;\n\tbool\t\t\t\tuse_sdout2;\n\tu32\t\t\t\tmclk_rate;\n};\n\nstatic const struct reg_default cs53l30_reg_defaults[] = {\n\t{ CS53L30_PWRCTL,\t\tCS53L30_PWRCTL_DEFAULT },\n\t{ CS53L30_MCLKCTL,\t\tCS53L30_MCLKCTL_DEFAULT },\n\t{ CS53L30_INT_SR_CTL,\t\tCS53L30_INT_SR_CTL_DEFAULT },\n\t{ CS53L30_MICBIAS_CTL,\t\tCS53L30_MICBIAS_CTL_DEFAULT },\n\t{ CS53L30_ASPCFG_CTL,\t\tCS53L30_ASPCFG_CTL_DEFAULT },\n\t{ CS53L30_ASP_CTL1,\t\tCS53L30_ASP_CTL1_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_CTL1,\tCS53L30_ASP_TDMTX_CTLx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_CTL2,\tCS53L30_ASP_TDMTX_CTLx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_CTL3,\tCS53L30_ASP_TDMTX_CTLx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_CTL4,\tCS53L30_ASP_TDMTX_CTLx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN1,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN2,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN3,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN4,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN5,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_TDMTX_EN6,\tCS53L30_ASP_TDMTX_ENx_DEFAULT },\n\t{ CS53L30_ASP_CTL2,\t\tCS53L30_ASP_CTL2_DEFAULT },\n\t{ CS53L30_SFT_RAMP,\t\tCS53L30_SFT_RMP_DEFAULT },\n\t{ CS53L30_LRCK_CTL1,\t\tCS53L30_LRCK_CTLx_DEFAULT },\n\t{ CS53L30_LRCK_CTL2,\t\tCS53L30_LRCK_CTLx_DEFAULT },\n\t{ CS53L30_MUTEP_CTL1,\t\tCS53L30_MUTEP_CTL1_DEFAULT },\n\t{ CS53L30_MUTEP_CTL2,\t\tCS53L30_MUTEP_CTL2_DEFAULT },\n\t{ CS53L30_INBIAS_CTL1,\t\tCS53L30_INBIAS_CTL1_DEFAULT },\n\t{ CS53L30_INBIAS_CTL2,\t\tCS53L30_INBIAS_CTL2_DEFAULT },\n\t{ CS53L30_DMIC1_STR_CTL,\tCS53L30_DMIC1_STR_CTL_DEFAULT },\n\t{ CS53L30_DMIC2_STR_CTL,\tCS53L30_DMIC2_STR_CTL_DEFAULT },\n\t{ CS53L30_ADCDMIC1_CTL1,\tCS53L30_ADCDMICx_CTL1_DEFAULT },\n\t{ CS53L30_ADCDMIC1_CTL2,\tCS53L30_ADCDMIC1_CTL2_DEFAULT },\n\t{ CS53L30_ADC1_CTL3,\t\tCS53L30_ADCx_CTL3_DEFAULT },\n\t{ CS53L30_ADC1_NG_CTL,\t\tCS53L30_ADCx_NG_CTL_DEFAULT },\n\t{ CS53L30_ADC1A_AFE_CTL,\tCS53L30_ADCxy_AFE_CTL_DEFAULT },\n\t{ CS53L30_ADC1B_AFE_CTL,\tCS53L30_ADCxy_AFE_CTL_DEFAULT },\n\t{ CS53L30_ADC1A_DIG_VOL,\tCS53L30_ADCxy_DIG_VOL_DEFAULT },\n\t{ CS53L30_ADC1B_DIG_VOL,\tCS53L30_ADCxy_DIG_VOL_DEFAULT },\n\t{ CS53L30_ADCDMIC2_CTL1,\tCS53L30_ADCDMICx_CTL1_DEFAULT },\n\t{ CS53L30_ADCDMIC2_CTL2,\tCS53L30_ADCDMIC1_CTL2_DEFAULT },\n\t{ CS53L30_ADC2_CTL3,\t\tCS53L30_ADCx_CTL3_DEFAULT },\n\t{ CS53L30_ADC2_NG_CTL,\t\tCS53L30_ADCx_NG_CTL_DEFAULT },\n\t{ CS53L30_ADC2A_AFE_CTL,\tCS53L30_ADCxy_AFE_CTL_DEFAULT },\n\t{ CS53L30_ADC2B_AFE_CTL,\tCS53L30_ADCxy_AFE_CTL_DEFAULT },\n\t{ CS53L30_ADC2A_DIG_VOL,\tCS53L30_ADCxy_DIG_VOL_DEFAULT },\n\t{ CS53L30_ADC2B_DIG_VOL,\tCS53L30_ADCxy_DIG_VOL_DEFAULT },\n\t{ CS53L30_INT_MASK,\t\tCS53L30_DEVICE_INT_MASK },\n};\n\nstatic bool cs53l30_volatile_register(struct device *dev, unsigned int reg)\n{\n\tif (reg == CS53L30_IS)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic bool cs53l30_writeable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS53L30_DEVID_AB:\n\tcase CS53L30_DEVID_CD:\n\tcase CS53L30_DEVID_E:\n\tcase CS53L30_REVID:\n\tcase CS53L30_IS:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic bool cs53l30_readable_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase CS53L30_DEVID_AB:\n\tcase CS53L30_DEVID_CD:\n\tcase CS53L30_DEVID_E:\n\tcase CS53L30_REVID:\n\tcase CS53L30_PWRCTL:\n\tcase CS53L30_MCLKCTL:\n\tcase CS53L30_INT_SR_CTL:\n\tcase CS53L30_MICBIAS_CTL:\n\tcase CS53L30_ASPCFG_CTL:\n\tcase CS53L30_ASP_CTL1:\n\tcase CS53L30_ASP_TDMTX_CTL1:\n\tcase CS53L30_ASP_TDMTX_CTL2:\n\tcase CS53L30_ASP_TDMTX_CTL3:\n\tcase CS53L30_ASP_TDMTX_CTL4:\n\tcase CS53L30_ASP_TDMTX_EN1:\n\tcase CS53L30_ASP_TDMTX_EN2:\n\tcase CS53L30_ASP_TDMTX_EN3:\n\tcase CS53L30_ASP_TDMTX_EN4:\n\tcase CS53L30_ASP_TDMTX_EN5:\n\tcase CS53L30_ASP_TDMTX_EN6:\n\tcase CS53L30_ASP_CTL2:\n\tcase CS53L30_SFT_RAMP:\n\tcase CS53L30_LRCK_CTL1:\n\tcase CS53L30_LRCK_CTL2:\n\tcase CS53L30_MUTEP_CTL1:\n\tcase CS53L30_MUTEP_CTL2:\n\tcase CS53L30_INBIAS_CTL1:\n\tcase CS53L30_INBIAS_CTL2:\n\tcase CS53L30_DMIC1_STR_CTL:\n\tcase CS53L30_DMIC2_STR_CTL:\n\tcase CS53L30_ADCDMIC1_CTL1:\n\tcase CS53L30_ADCDMIC1_CTL2:\n\tcase CS53L30_ADC1_CTL3:\n\tcase CS53L30_ADC1_NG_CTL:\n\tcase CS53L30_ADC1A_AFE_CTL:\n\tcase CS53L30_ADC1B_AFE_CTL:\n\tcase CS53L30_ADC1A_DIG_VOL:\n\tcase CS53L30_ADC1B_DIG_VOL:\n\tcase CS53L30_ADCDMIC2_CTL1:\n\tcase CS53L30_ADCDMIC2_CTL2:\n\tcase CS53L30_ADC2_CTL3:\n\tcase CS53L30_ADC2_NG_CTL:\n\tcase CS53L30_ADC2A_AFE_CTL:\n\tcase CS53L30_ADC2B_AFE_CTL:\n\tcase CS53L30_ADC2A_DIG_VOL:\n\tcase CS53L30_ADC2B_DIG_VOL:\n\tcase CS53L30_INT_MASK:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic DECLARE_TLV_DB_SCALE(adc_boost_tlv, 0, 2000, 0);\nstatic DECLARE_TLV_DB_SCALE(adc_ng_boost_tlv, 0, 3000, 0);\nstatic DECLARE_TLV_DB_SCALE(pga_tlv, -600, 50, 0);\nstatic DECLARE_TLV_DB_SCALE(dig_tlv, -9600, 100, 1);\nstatic DECLARE_TLV_DB_SCALE(pga_preamp_tlv, 0, 10000, 0);\n\nstatic const char * const input1_sel_text[] = {\n\t\"DMIC1 On AB In\",\n\t\"DMIC1 On A In\",\n\t\"DMIC1 On B In\",\n\t\"ADC1 On AB In\",\n\t\"ADC1 On A In\",\n\t\"ADC1 On B In\",\n\t\"DMIC1 Off ADC1 Off\",\n};\n\nstatic unsigned int const input1_sel_values[] = {\n\tCS53L30_CH_TYPE,\n\tCS53L30_ADCxB_PDN | CS53L30_CH_TYPE,\n\tCS53L30_ADCxA_PDN | CS53L30_CH_TYPE,\n\tCS53L30_DMICx_PDN,\n\tCS53L30_ADCxB_PDN | CS53L30_DMICx_PDN,\n\tCS53L30_ADCxA_PDN | CS53L30_DMICx_PDN,\n\tCS53L30_ADCxA_PDN | CS53L30_ADCxB_PDN | CS53L30_DMICx_PDN,\n};\n\nstatic const char * const input2_sel_text[] = {\n\t\"DMIC2 On AB In\",\n\t\"DMIC2 On A In\",\n\t\"DMIC2 On B In\",\n\t\"ADC2 On AB In\",\n\t\"ADC2 On A In\",\n\t\"ADC2 On B In\",\n\t\"DMIC2 Off ADC2 Off\",\n};\n\nstatic unsigned int const input2_sel_values[] = {\n\t0x0,\n\tCS53L30_ADCxB_PDN,\n\tCS53L30_ADCxA_PDN,\n\tCS53L30_DMICx_PDN,\n\tCS53L30_ADCxB_PDN | CS53L30_DMICx_PDN,\n\tCS53L30_ADCxA_PDN | CS53L30_DMICx_PDN,\n\tCS53L30_ADCxA_PDN | CS53L30_ADCxB_PDN | CS53L30_DMICx_PDN,\n};\n\nstatic const char * const input1_route_sel_text[] = {\n\t\"ADC1_SEL\", \"DMIC1_SEL\",\n};\n\nstatic const struct soc_enum input1_route_sel_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADCDMIC1_CTL1, CS53L30_CH_TYPE_SHIFT,\n\t\t\tARRAY_SIZE(input1_route_sel_text),\n\t\t\tinput1_route_sel_text);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(input1_sel_enum, CS53L30_ADCDMIC1_CTL1, 0,\n\t\t\t\t  CS53L30_ADCDMICx_PDN_MASK, input1_sel_text,\n\t\t\t\t  input1_sel_values);\n\nstatic const struct snd_kcontrol_new input1_route_sel_mux =\n\tSOC_DAPM_ENUM(\"Input 1 Route\", input1_route_sel_enum);\n\nstatic const char * const input2_route_sel_text[] = {\n\t\"ADC2_SEL\", \"DMIC2_SEL\",\n};\n\n \nstatic const struct soc_enum input2_route_sel_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADCDMIC1_CTL1, 0,\n\t\t\tARRAY_SIZE(input2_route_sel_text),\n\t\t\tinput2_route_sel_text);\n\nstatic SOC_VALUE_ENUM_SINGLE_DECL(input2_sel_enum, CS53L30_ADCDMIC2_CTL1, 0,\n\t\t\t\t  CS53L30_ADCDMICx_PDN_MASK, input2_sel_text,\n\t\t\t\t  input2_sel_values);\n\nstatic const struct snd_kcontrol_new input2_route_sel_mux =\n\tSOC_DAPM_ENUM(\"Input 2 Route\", input2_route_sel_enum);\n\n \nstatic const char * const cs53l30_ng_delay_text[] = {\n\t\"TB*50ms\", \"TB*100ms\", \"TB*150ms\", \"TB*200ms\",\n};\n\nstatic const struct soc_enum adc1_ng_delay_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC1_NG_CTL, CS53L30_ADCx_NG_DELAY_SHIFT,\n\t\t\tARRAY_SIZE(cs53l30_ng_delay_text),\n\t\t\tcs53l30_ng_delay_text);\n\nstatic const struct soc_enum adc2_ng_delay_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC2_NG_CTL, CS53L30_ADCx_NG_DELAY_SHIFT,\n\t\t\tARRAY_SIZE(cs53l30_ng_delay_text),\n\t\t\tcs53l30_ng_delay_text);\n\n \nstatic const char * const cs53l30_ng_thres_text[] = {\n\t\"-64dB/-34dB\", \"-66dB/-36dB\", \"-70dB/-40dB\", \"-73dB/-43dB\",\n\t\"-76dB/-46dB\", \"-82dB/-52dB\", \"-58dB\", \"-64dB\",\n};\n\nstatic const struct soc_enum adc1_ng_thres_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC1_NG_CTL, CS53L30_ADCx_NG_THRESH_SHIFT,\n\t\t\tARRAY_SIZE(cs53l30_ng_thres_text),\n\t\t\tcs53l30_ng_thres_text);\n\nstatic const struct soc_enum adc2_ng_thres_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC2_NG_CTL, CS53L30_ADCx_NG_THRESH_SHIFT,\n\t\t\tARRAY_SIZE(cs53l30_ng_thres_text),\n\t\t\tcs53l30_ng_thres_text);\n\n \nstatic const char * const hpf_corner_freq_text[] = {\n\t\"1.86Hz\", \"120Hz\", \"235Hz\", \"466Hz\",\n};\n\nstatic const struct soc_enum adc1_hpf_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC1_CTL3, CS53L30_ADCx_HPF_CF_SHIFT,\n\t\t\tARRAY_SIZE(hpf_corner_freq_text), hpf_corner_freq_text);\n\nstatic const struct soc_enum adc2_hpf_enum =\n\tSOC_ENUM_SINGLE(CS53L30_ADC2_CTL3, CS53L30_ADCx_HPF_CF_SHIFT,\n\t\t\tARRAY_SIZE(hpf_corner_freq_text), hpf_corner_freq_text);\n\nstatic const struct snd_kcontrol_new cs53l30_snd_controls[] = {\n\tSOC_SINGLE(\"Digital Soft-Ramp Switch\", CS53L30_SFT_RAMP,\n\t\t   CS53L30_DIGSFT_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC1 Noise Gate Ganging Switch\", CS53L30_ADC1_CTL3,\n\t\t   CS53L30_ADCx_NG_ALL_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2 Noise Gate Ganging Switch\", CS53L30_ADC2_CTL3,\n\t\t   CS53L30_ADCx_NG_ALL_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC1A Noise Gate Enable Switch\", CS53L30_ADC1_NG_CTL,\n\t\t   CS53L30_ADCxA_NG_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC1B Noise Gate Enable Switch\", CS53L30_ADC1_NG_CTL,\n\t\t   CS53L30_ADCxB_NG_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2A Noise Gate Enable Switch\", CS53L30_ADC2_NG_CTL,\n\t\t   CS53L30_ADCxA_NG_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2B Noise Gate Enable Switch\", CS53L30_ADC2_NG_CTL,\n\t\t   CS53L30_ADCxB_NG_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC1 Notch Filter Switch\", CS53L30_ADCDMIC1_CTL2,\n\t\t   CS53L30_ADCx_NOTCH_DIS_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC2 Notch Filter Switch\", CS53L30_ADCDMIC2_CTL2,\n\t\t   CS53L30_ADCx_NOTCH_DIS_SHIFT, 1, 1),\n\tSOC_SINGLE(\"ADC1A Invert Switch\", CS53L30_ADCDMIC1_CTL2,\n\t\t   CS53L30_ADCxA_INV_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC1B Invert Switch\", CS53L30_ADCDMIC1_CTL2,\n\t\t   CS53L30_ADCxB_INV_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2A Invert Switch\", CS53L30_ADCDMIC2_CTL2,\n\t\t   CS53L30_ADCxA_INV_SHIFT, 1, 0),\n\tSOC_SINGLE(\"ADC2B Invert Switch\", CS53L30_ADCDMIC2_CTL2,\n\t\t   CS53L30_ADCxB_INV_SHIFT, 1, 0),\n\n\tSOC_SINGLE_TLV(\"ADC1A Digital Boost Volume\", CS53L30_ADCDMIC1_CTL2,\n\t\t       CS53L30_ADCxA_DIG_BOOST_SHIFT, 1, 0, adc_boost_tlv),\n\tSOC_SINGLE_TLV(\"ADC1B Digital Boost Volume\", CS53L30_ADCDMIC1_CTL2,\n\t\t       CS53L30_ADCxB_DIG_BOOST_SHIFT, 1, 0, adc_boost_tlv),\n\tSOC_SINGLE_TLV(\"ADC2A Digital Boost Volume\", CS53L30_ADCDMIC2_CTL2,\n\t\t       CS53L30_ADCxA_DIG_BOOST_SHIFT, 1, 0, adc_boost_tlv),\n\tSOC_SINGLE_TLV(\"ADC2B Digital Boost Volume\", CS53L30_ADCDMIC2_CTL2,\n\t\t       CS53L30_ADCxB_DIG_BOOST_SHIFT, 1, 0, adc_boost_tlv),\n\tSOC_SINGLE_TLV(\"ADC1 NG Boost Volume\", CS53L30_ADC1_NG_CTL,\n\t\t       CS53L30_ADCx_NG_BOOST_SHIFT, 1, 0, adc_ng_boost_tlv),\n\tSOC_SINGLE_TLV(\"ADC2 NG Boost Volume\", CS53L30_ADC2_NG_CTL,\n\t\t       CS53L30_ADCx_NG_BOOST_SHIFT, 1, 0, adc_ng_boost_tlv),\n\n\tSOC_DOUBLE_R_TLV(\"ADC1 Preamplifier Volume\", CS53L30_ADC1A_AFE_CTL,\n\t\t\t CS53L30_ADC1B_AFE_CTL, CS53L30_ADCxy_PREAMP_SHIFT,\n\t\t\t 2, 0, pga_preamp_tlv),\n\tSOC_DOUBLE_R_TLV(\"ADC2 Preamplifier Volume\", CS53L30_ADC2A_AFE_CTL,\n\t\t\t CS53L30_ADC2B_AFE_CTL, CS53L30_ADCxy_PREAMP_SHIFT,\n\t\t\t 2, 0, pga_preamp_tlv),\n\n\tSOC_ENUM(\"Input 1 Channel Select\", input1_sel_enum),\n\tSOC_ENUM(\"Input 2 Channel Select\", input2_sel_enum),\n\n\tSOC_ENUM(\"ADC1 HPF Select\", adc1_hpf_enum),\n\tSOC_ENUM(\"ADC2 HPF Select\", adc2_hpf_enum),\n\tSOC_ENUM(\"ADC1 NG Threshold\", adc1_ng_thres_enum),\n\tSOC_ENUM(\"ADC2 NG Threshold\", adc2_ng_thres_enum),\n\tSOC_ENUM(\"ADC1 NG Delay\", adc1_ng_delay_enum),\n\tSOC_ENUM(\"ADC2 NG Delay\", adc2_ng_delay_enum),\n\n\tSOC_SINGLE_SX_TLV(\"ADC1A PGA Volume\",\n\t\t    CS53L30_ADC1A_AFE_CTL, 0, 0x34, 0x24, pga_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC1B PGA Volume\",\n\t\t    CS53L30_ADC1B_AFE_CTL, 0, 0x34, 0x24, pga_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC2A PGA Volume\",\n\t\t    CS53L30_ADC2A_AFE_CTL, 0, 0x34, 0x24, pga_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC2B PGA Volume\",\n\t\t    CS53L30_ADC2B_AFE_CTL, 0, 0x34, 0x24, pga_tlv),\n\n\tSOC_SINGLE_SX_TLV(\"ADC1A Digital Volume\",\n\t\t    CS53L30_ADC1A_DIG_VOL, 0, 0xA0, 0x6C, dig_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC1B Digital Volume\",\n\t\t    CS53L30_ADC1B_DIG_VOL, 0, 0xA0, 0x6C, dig_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC2A Digital Volume\",\n\t\t    CS53L30_ADC2A_DIG_VOL, 0, 0xA0, 0x6C, dig_tlv),\n\tSOC_SINGLE_SX_TLV(\"ADC2B Digital Volume\",\n\t\t    CS53L30_ADC2B_DIG_VOL, 0, 0xA0, 0x6C, dig_tlv),\n};\n\nstatic const struct snd_soc_dapm_widget cs53l30_dapm_widgets[] = {\n\tSND_SOC_DAPM_INPUT(\"IN1_DMIC1\"),\n\tSND_SOC_DAPM_INPUT(\"IN2\"),\n\tSND_SOC_DAPM_INPUT(\"IN3_DMIC2\"),\n\tSND_SOC_DAPM_INPUT(\"IN4\"),\n\tSND_SOC_DAPM_SUPPLY(\"MIC1 Bias\", CS53L30_MICBIAS_CTL,\n\t\t\t    CS53L30_MIC1_BIAS_PDN_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC2 Bias\", CS53L30_MICBIAS_CTL,\n\t\t\t    CS53L30_MIC2_BIAS_PDN_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC3 Bias\", CS53L30_MICBIAS_CTL,\n\t\t\t    CS53L30_MIC3_BIAS_PDN_SHIFT, 1, NULL, 0),\n\tSND_SOC_DAPM_SUPPLY(\"MIC4 Bias\", CS53L30_MICBIAS_CTL,\n\t\t\t    CS53L30_MIC4_BIAS_PDN_SHIFT, 1, NULL, 0),\n\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_SDOUT1\", NULL, 0, CS53L30_ASP_CTL1,\n\t\t\t     CS53L30_ASP_SDOUTx_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_AIF_OUT(\"ASP_SDOUT2\", NULL, 0, CS53L30_ASP_CTL2,\n\t\t\t     CS53L30_ASP_SDOUTx_PDN_SHIFT, 1),\n\n\tSND_SOC_DAPM_MUX(\"Input Mux 1\", SND_SOC_NOPM, 0, 0,\n\t\t\t &input1_route_sel_mux),\n\tSND_SOC_DAPM_MUX(\"Input Mux 2\", SND_SOC_NOPM, 0, 0,\n\t\t\t &input2_route_sel_mux),\n\n\tSND_SOC_DAPM_ADC(\"ADC1A\", NULL, CS53L30_ADCDMIC1_CTL1,\n\t\t\t CS53L30_ADCxA_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC1B\", NULL, CS53L30_ADCDMIC1_CTL1,\n\t\t\t CS53L30_ADCxB_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC2A\", NULL, CS53L30_ADCDMIC2_CTL1,\n\t\t\t CS53L30_ADCxA_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"ADC2B\", NULL, CS53L30_ADCDMIC2_CTL1,\n\t\t\t CS53L30_ADCxB_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"DMIC1\", NULL, CS53L30_ADCDMIC1_CTL1,\n\t\t\t CS53L30_DMICx_PDN_SHIFT, 1),\n\tSND_SOC_DAPM_ADC(\"DMIC2\", NULL, CS53L30_ADCDMIC2_CTL1,\n\t\t\t CS53L30_DMICx_PDN_SHIFT, 1),\n};\n\nstatic const struct snd_soc_dapm_route cs53l30_dapm_routes[] = {\n\t \n\t{\"ADC1A\", NULL, \"IN1_DMIC1\"},\n\t{\"Input Mux 1\", \"ADC1_SEL\", \"ADC1A\"},\n\t{\"ADC1B\", NULL, \"IN2\"},\n\n\t{\"ADC2A\", NULL, \"IN3_DMIC2\"},\n\t{\"Input Mux 2\", \"ADC2_SEL\", \"ADC2A\"},\n\t{\"ADC2B\", NULL, \"IN4\"},\n\n\t \n\t{\"ADC1A\", NULL, \"MIC1 Bias\"},\n\t{\"ADC1B\", NULL, \"MIC2 Bias\"},\n\t{\"ADC2A\", NULL, \"MIC3 Bias\"},\n\t{\"ADC2B\", NULL, \"MIC4 Bias\"},\n\n\t \n\t{\"DMIC1\", NULL, \"IN1_DMIC1\"},\n\t{\"Input Mux 1\", \"DMIC1_SEL\", \"DMIC1\"},\n\n\t{\"DMIC2\", NULL, \"IN3_DMIC2\"},\n\t{\"Input Mux 2\", \"DMIC2_SEL\", \"DMIC2\"},\n};\n\nstatic const struct snd_soc_dapm_route cs53l30_dapm_routes_sdout1[] = {\n\t \n\t{\"ASP_SDOUT1\", NULL, \"ADC1A\" },\n\t{\"ASP_SDOUT1\", NULL, \"Input Mux 1\"},\n\t{\"ASP_SDOUT1\", NULL, \"ADC1B\"},\n\n\t{\"ASP_SDOUT1\", NULL, \"ADC2A\"},\n\t{\"ASP_SDOUT1\", NULL, \"Input Mux 2\"},\n\t{\"ASP_SDOUT1\", NULL, \"ADC2B\"},\n\n\t{\"Capture\", NULL, \"ASP_SDOUT1\"},\n};\n\nstatic const struct snd_soc_dapm_route cs53l30_dapm_routes_sdout2[] = {\n\t \n\t{\"ASP_SDOUT1\", NULL, \"ADC1A\" },\n\t{\"ASP_SDOUT1\", NULL, \"Input Mux 1\"},\n\t{\"ASP_SDOUT1\", NULL, \"ADC1B\"},\n\n\t{\"ASP_SDOUT2\", NULL, \"ADC2A\"},\n\t{\"ASP_SDOUT2\", NULL, \"Input Mux 2\"},\n\t{\"ASP_SDOUT2\", NULL, \"ADC2B\"},\n\n\t{\"Capture\", NULL, \"ASP_SDOUT1\"},\n\t{\"Capture\", NULL, \"ASP_SDOUT2\"},\n};\n\nstruct cs53l30_mclk_div {\n\tu32 mclk_rate;\n\tu32 srate;\n\tu8 asp_rate;\n\tu8 internal_fs_ratio;\n\tu8 mclk_int_scale;\n};\n\nstatic const struct cs53l30_mclk_div cs53l30_mclk_coeffs[] = {\n\t \n\n\t \n\t{5644800, 11025, 0x4, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{5644800, 22050, 0x8, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{5644800, 44100, 0xC, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\n\t{6000000,  8000, 0x1, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 11025, 0x2, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 12000, 0x4, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 16000, 0x5, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 22050, 0x6, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 24000, 0x8, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 32000, 0x9, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 44100, 0xA, 0, CS53L30_MCLK_INT_SCALE},\n\t{6000000, 48000, 0xC, 0, CS53L30_MCLK_INT_SCALE},\n\n\t{6144000,  8000, 0x1, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 11025, 0x2, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 12000, 0x4, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 16000, 0x5, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 22050, 0x6, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 24000, 0x8, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 32000, 0x9, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 44100, 0xA, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6144000, 48000, 0xC, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\n\t{6400000,  8000, 0x1, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 11025, 0x2, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 12000, 0x4, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 16000, 0x5, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 22050, 0x6, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 24000, 0x8, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 32000, 0x9, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 44100, 0xA, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n\t{6400000, 48000, 0xC, CS53L30_INTRNL_FS_RATIO, CS53L30_MCLK_INT_SCALE},\n};\n\nstruct cs53l30_mclkx_div {\n\tu32 mclkx;\n\tu8 ratio;\n\tu8 mclkdiv;\n};\n\nstatic const struct cs53l30_mclkx_div cs53l30_mclkx_coeffs[] = {\n\t{5644800,  1, CS53L30_MCLK_DIV_BY_1},\n\t{6000000,  1, CS53L30_MCLK_DIV_BY_1},\n\t{6144000,  1, CS53L30_MCLK_DIV_BY_1},\n\t{11289600, 2, CS53L30_MCLK_DIV_BY_2},\n\t{12288000, 2, CS53L30_MCLK_DIV_BY_2},\n\t{12000000, 2, CS53L30_MCLK_DIV_BY_2},\n\t{19200000, 3, CS53L30_MCLK_DIV_BY_3},\n};\n\nstatic int cs53l30_get_mclkx_coeff(int mclkx)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs53l30_mclkx_coeffs); i++) {\n\t\tif (cs53l30_mclkx_coeffs[i].mclkx == mclkx)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cs53l30_get_mclk_coeff(int mclk_rate, int srate)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs53l30_mclk_coeffs); i++) {\n\t\tif (cs53l30_mclk_coeffs[i].mclk_rate == mclk_rate &&\n\t\t    cs53l30_mclk_coeffs[i].srate == srate)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cs53l30_set_sysclk(struct snd_soc_dai *dai,\n\t\t\t      int clk_id, unsigned int freq, int dir)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tint mclkx_coeff;\n\tu32 mclk_rate;\n\n\t \n\tmclkx_coeff = cs53l30_get_mclkx_coeff(freq);\n\tif (mclkx_coeff < 0)\n\t\treturn mclkx_coeff;\n\n\tmclk_rate = cs53l30_mclkx_coeffs[mclkx_coeff].mclkx /\n\t\t    cs53l30_mclkx_coeffs[mclkx_coeff].ratio;\n\n\tregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\n\t\t\t   CS53L30_MCLK_DIV_MASK,\n\t\t\t   cs53l30_mclkx_coeffs[mclkx_coeff].mclkdiv);\n\n\tpriv->mclk_rate = mclk_rate;\n\n\treturn 0;\n}\n\nstatic int cs53l30_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tu8 aspcfg = 0, aspctl1 = 0;\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taspcfg |= CS53L30_ASP_MS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\t \n\t\taspctl1 |= CS53L30_ASP_TDM_PDN;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\t \n\t\taspctl1 |= CS53L30_SHIFT_LEFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_IB_NF:\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\taspcfg ^= CS53L30_ASP_SCLK_INV;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tregmap_update_bits(priv->regmap, CS53L30_ASPCFG_CTL,\n\t\t\t   CS53L30_ASP_MS | CS53L30_ASP_SCLK_INV, aspcfg);\n\n\tregmap_update_bits(priv->regmap, CS53L30_ASP_CTL1,\n\t\t\t   CS53L30_ASP_TDM_PDN | CS53L30_SHIFT_LEFT, aspctl1);\n\n\treturn 0;\n}\n\nstatic int cs53l30_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tint srate = params_rate(params);\n\tint mclk_coeff;\n\n\t \n\tmclk_coeff = cs53l30_get_mclk_coeff(priv->mclk_rate, srate);\n\tif (mclk_coeff < 0)\n\t\treturn -EINVAL;\n\n\tregmap_update_bits(priv->regmap, CS53L30_INT_SR_CTL,\n\t\t\t   CS53L30_INTRNL_FS_RATIO_MASK,\n\t\t\t   cs53l30_mclk_coeffs[mclk_coeff].internal_fs_ratio);\n\n\tregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\n\t\t\t   CS53L30_MCLK_INT_SCALE_MASK,\n\t\t\t   cs53l30_mclk_coeffs[mclk_coeff].mclk_int_scale);\n\n\tregmap_update_bits(priv->regmap, CS53L30_ASPCFG_CTL,\n\t\t\t   CS53L30_ASP_RATE_MASK,\n\t\t\t   cs53l30_mclk_coeffs[mclk_coeff].asp_rate);\n\n\treturn 0;\n}\n\nstatic int cs53l30_set_bias_level(struct snd_soc_component *component,\n\t\t\t\t  enum snd_soc_bias_level level)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(component);\n\tunsigned int reg;\n\tint i, inter_max_check, ret;\n\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\t\tbreak;\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tif (dapm->bias_level == SND_SOC_BIAS_STANDBY)\n\t\t\tregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\n\t\t\t\t\t   CS53L30_PDN_LP_MASK, 0);\n\t\tbreak;\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (dapm->bias_level == SND_SOC_BIAS_OFF) {\n\t\t\tret = clk_prepare_enable(priv->mclk);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(component->dev,\n\t\t\t\t\t\"failed to enable MCLK: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\n\t\t\t\t\t   CS53L30_MCLK_DIS_MASK, 0);\n\t\t\tregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\n\t\t\t\t\t   CS53L30_PDN_ULP_MASK, 0);\n\t\t\tmsleep(50);\n\t\t} else {\n\t\t\tregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\n\t\t\t\t\t   CS53L30_PDN_ULP_MASK,\n\t\t\t\t\t   CS53L30_PDN_ULP);\n\t\t}\n\t\tbreak;\n\tcase SND_SOC_BIAS_OFF:\n\t\tregmap_update_bits(priv->regmap, CS53L30_INT_MASK,\n\t\t\t\t   CS53L30_PDN_DONE, 0);\n\t\t \n\n\t\t \n\t\tregmap_read(priv->regmap, CS53L30_SFT_RAMP, &reg);\n\t\tif (reg & CS53L30_DIGSFT_MASK)\n\t\t\tinter_max_check = CS53L30_PDN_POLL_MAX;\n\t\telse\n\t\t\tinter_max_check = 10;\n\n\t\tregmap_update_bits(priv->regmap, CS53L30_PWRCTL,\n\t\t\t\t   CS53L30_PDN_ULP_MASK,\n\t\t\t\t   CS53L30_PDN_ULP);\n\t\t \n\t\tmsleep(20);\n\t\t \n\t\tregmap_read(priv->regmap, CS53L30_IS, &reg);\n\t\tfor (i = 0; i < inter_max_check; i++) {\n\t\t\tif (inter_max_check < 10) {\n\t\t\t\tusleep_range(1000, 1100);\n\t\t\t\tregmap_read(priv->regmap, CS53L30_IS, &reg);\n\t\t\t\tif (reg & CS53L30_PDN_DONE)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tusleep_range(10000, 10100);\n\t\t\t\tregmap_read(priv->regmap, CS53L30_IS, &reg);\n\t\t\t\tif (reg & CS53L30_PDN_DONE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tregmap_update_bits(priv->regmap, CS53L30_INT_MASK,\n\t\t\t\t   CS53L30_PDN_DONE, CS53L30_PDN_DONE);\n\t\tregmap_update_bits(priv->regmap, CS53L30_MCLKCTL,\n\t\t\t\t   CS53L30_MCLK_DIS_MASK,\n\t\t\t\t   CS53L30_MCLK_DIS);\n\t\tclk_disable_unprepare(priv->mclk);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int cs53l30_set_tristate(struct snd_soc_dai *dai, int tristate)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tu8 val = tristate ? CS53L30_ASP_3ST : 0;\n\n\treturn regmap_update_bits(priv->regmap, CS53L30_ASP_CTL1,\n\t\t\t\t  CS53L30_ASP_3ST_MASK, val);\n}\n\nstatic unsigned int const cs53l30_src_rates[] = {\n\t8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000\n};\n\nstatic const struct snd_pcm_hw_constraint_list src_constraints = {\n\t.count = ARRAY_SIZE(cs53l30_src_rates),\n\t.list = cs53l30_src_rates,\n};\n\nstatic int cs53l30_pcm_startup(struct snd_pcm_substream *substream,\n\t\t\t       struct snd_soc_dai *dai)\n{\n\tsnd_pcm_hw_constraint_list(substream->runtime, 0,\n\t\t\t\t   SNDRV_PCM_HW_PARAM_RATE, &src_constraints);\n\n\treturn 0;\n}\n\n \nstatic int cs53l30_set_dai_tdm_slot(struct snd_soc_dai *dai,\n\t\t\t\t    unsigned int tx_mask, unsigned int rx_mask,\n\t\t\t\t    int slots, int slot_width)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\tunsigned int loc[CS53L30_TDM_SLOT_MAX] = {48, 48, 48, 48};\n\tunsigned int slot_next, slot_step;\n\tu64 tx_enable = 0;\n\tint i;\n\n\tif (!rx_mask) {\n\t\tdev_err(dai->dev, \"rx masks must not be 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (slots <= 0 || slot_width <= 0 || slot_width > 64) {\n\t\tdev_err(dai->dev, \"invalid slot number or slot width\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (slot_width & 0x7) {\n\t\tdev_err(dai->dev, \"slot width must count in byte\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tslot_step = slot_width >> 3;\n\n\tfor (i = 0; rx_mask && i < CS53L30_TDM_SLOT_MAX; i++) {\n\t\t \n\t\tslot_next = __ffs(rx_mask);\n\t\t \n\t\tloc[i] = slot_next * slot_step;\n\t\t \n\t\ttx_enable |= (u64)((u64)(1 << slot_step) - 1) << (u64)loc[i];\n\t\t \n\t\trx_mask &= ~(1 << slot_next);\n\t}\n\n\t \n\tif (rx_mask && i == CS53L30_TDM_SLOT_MAX) {\n\t\tdev_err(dai->dev, \"rx_mask exceeds max slot number: %d\\n\",\n\t\t\tCS53L30_TDM_SLOT_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tslot_next = loc[i - 1] + slot_step - 1;\n\tif (slot_next > 47) {\n\t\tdev_err(dai->dev, \"slot selection out of bounds: %u\\n\",\n\t\t\tslot_next);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < CS53L30_TDM_SLOT_MAX && loc[i] != 48; i++) {\n\t\tregmap_update_bits(priv->regmap, CS53L30_ASP_TDMTX_CTL(i),\n\t\t\t\t   CS53L30_ASP_CHx_TX_LOC_MASK, loc[i]);\n\t\tdev_dbg(dai->dev, \"loc[%d]=%x\\n\", i, loc[i]);\n\t}\n\n\tfor (i = 0; i < CS53L30_ASP_TDMTX_ENx_MAX && tx_enable; i++) {\n\t\tregmap_write(priv->regmap, CS53L30_ASP_TDMTX_ENx(i),\n\t\t\t     tx_enable & 0xff);\n\t\ttx_enable >>= 8;\n\t\tdev_dbg(dai->dev, \"en_reg=%x, tx_enable=%llx\\n\",\n\t\t\tCS53L30_ASP_TDMTX_ENx(i), tx_enable & 0xff);\n\t}\n\n\treturn 0;\n}\n\nstatic int cs53l30_mute_stream(struct snd_soc_dai *dai, int mute, int stream)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(dai->component);\n\n\tgpiod_set_value_cansleep(priv->mute_gpio, mute);\n\n\treturn 0;\n}\n\n \n#define CS53L30_RATES (SNDRV_PCM_RATE_8000_48000 | SNDRV_PCM_RATE_KNOT)\n\n#define CS53L30_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops cs53l30_ops = {\n\t.startup = cs53l30_pcm_startup,\n\t.hw_params = cs53l30_pcm_hw_params,\n\t.set_fmt = cs53l30_set_dai_fmt,\n\t.set_sysclk = cs53l30_set_sysclk,\n\t.set_tristate = cs53l30_set_tristate,\n\t.set_tdm_slot = cs53l30_set_dai_tdm_slot,\n\t.mute_stream = cs53l30_mute_stream,\n};\n\nstatic struct snd_soc_dai_driver cs53l30_dai = {\n\t.name = \"cs53l30\",\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 1,\n\t\t.channels_max = 4,\n\t\t.rates = CS53L30_RATES,\n\t\t.formats = CS53L30_FORMATS,\n\t},\n\t.ops = &cs53l30_ops,\n\t.symmetric_rate = 1,\n};\n\nstatic int cs53l30_component_probe(struct snd_soc_component *component)\n{\n\tstruct cs53l30_private *priv = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\n\tif (priv->use_sdout2)\n\t\tsnd_soc_dapm_add_routes(dapm, cs53l30_dapm_routes_sdout2,\n\t\t\t\t\tARRAY_SIZE(cs53l30_dapm_routes_sdout2));\n\telse\n\t\tsnd_soc_dapm_add_routes(dapm, cs53l30_dapm_routes_sdout1,\n\t\t\t\t\tARRAY_SIZE(cs53l30_dapm_routes_sdout1));\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver cs53l30_driver = {\n\t.probe\t\t\t= cs53l30_component_probe,\n\t.set_bias_level\t\t= cs53l30_set_bias_level,\n\t.controls\t\t= cs53l30_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(cs53l30_snd_controls),\n\t.dapm_widgets\t\t= cs53l30_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(cs53l30_dapm_widgets),\n\t.dapm_routes\t\t= cs53l30_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(cs53l30_dapm_routes),\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic struct regmap_config cs53l30_regmap = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = CS53L30_MAX_REGISTER,\n\t.reg_defaults = cs53l30_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(cs53l30_reg_defaults),\n\t.volatile_reg = cs53l30_volatile_register,\n\t.writeable_reg = cs53l30_writeable_register,\n\t.readable_reg = cs53l30_readable_register,\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.use_single_read = true,\n\t.use_single_write = true,\n};\n\nstatic int cs53l30_i2c_probe(struct i2c_client *client)\n{\n\tconst struct device_node *np = client->dev.of_node;\n\tstruct device *dev = &client->dev;\n\tstruct cs53l30_private *cs53l30;\n\tunsigned int reg;\n\tint ret = 0, i, devid;\n\tu8 val;\n\n\tcs53l30 = devm_kzalloc(dev, sizeof(*cs53l30), GFP_KERNEL);\n\tif (!cs53l30)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(cs53l30->supplies); i++)\n\t\tcs53l30->supplies[i].supply = cs53l30_supply_names[i];\n\n\tret = devm_regulator_bulk_get(dev, ARRAY_SIZE(cs53l30->supplies),\n\t\t\t\t      cs53l30->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs53l30->supplies),\n\t\t\t\t    cs53l30->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tcs53l30->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(cs53l30->reset_gpio)) {\n\t\tret = PTR_ERR(cs53l30->reset_gpio);\n\t\tgoto error_supplies;\n\t}\n\n\tgpiod_set_value_cansleep(cs53l30->reset_gpio, 1);\n\n\ti2c_set_clientdata(client, cs53l30);\n\n\tcs53l30->mclk_rate = 0;\n\n\tcs53l30->regmap = devm_regmap_init_i2c(client, &cs53l30_regmap);\n\tif (IS_ERR(cs53l30->regmap)) {\n\t\tret = PTR_ERR(cs53l30->regmap);\n\t\tdev_err(dev, \"regmap_init() failed: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\t \n\tdevid = cirrus_read_device_id(cs53l30->regmap, CS53L30_DEVID_AB);\n\tif (devid < 0) {\n\t\tret = devid;\n\t\tdev_err(dev, \"Failed to read device ID: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\tif (devid != CS53L30_DEVID) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"Device ID (%X). Expected %X\\n\",\n\t\t\tdevid, CS53L30_DEVID);\n\t\tgoto error;\n\t}\n\n\tret = regmap_read(cs53l30->regmap, CS53L30_REVID, &reg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get Revision ID: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\t \n\tcs53l30->mclk = devm_clk_get_optional(dev, \"mclk\");\n\tif (IS_ERR(cs53l30->mclk)) {\n\t\tret = PTR_ERR(cs53l30->mclk);\n\t\tgoto error;\n\t}\n\n\t \n\tcs53l30->mute_gpio = devm_gpiod_get_optional(dev, \"mute\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(cs53l30->mute_gpio)) {\n\t\tret = PTR_ERR(cs53l30->mute_gpio);\n\t\tgoto error;\n\t}\n\n\tif (cs53l30->mute_gpio) {\n\t\t \n\t\tregmap_write(cs53l30->regmap, CS53L30_MUTEP_CTL1,\n\t\t\t     CS53L30_MUTEP_CTL1_MUTEALL);\n\t\t \n\t\tif (gpiod_is_active_low(cs53l30->mute_gpio))\n\t\t\tregmap_update_bits(cs53l30->regmap, CS53L30_MUTEP_CTL2,\n\t\t\t\t\t   CS53L30_MUTE_PIN_POLARITY, 0);\n\t}\n\n\tif (!of_property_read_u8(np, \"cirrus,micbias-lvl\", &val))\n\t\tregmap_update_bits(cs53l30->regmap, CS53L30_MICBIAS_CTL,\n\t\t\t\t   CS53L30_MIC_BIAS_CTRL_MASK, val);\n\n\tif (of_property_read_bool(np, \"cirrus,use-sdout2\"))\n\t\tcs53l30->use_sdout2 = true;\n\n\tdev_info(dev, \"Cirrus Logic CS53L30, Revision: %02X\\n\", reg & 0xFF);\n\n\tret = devm_snd_soc_register_component(dev, &cs53l30_driver, &cs53l30_dai, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register component: %d\\n\", ret);\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tgpiod_set_value_cansleep(cs53l30->reset_gpio, 0);\nerror_supplies:\n\tregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\n\t\t\t       cs53l30->supplies);\n\treturn ret;\n}\n\nstatic void cs53l30_i2c_remove(struct i2c_client *client)\n{\n\tstruct cs53l30_private *cs53l30 = i2c_get_clientdata(client);\n\n\t \n\tgpiod_set_value_cansleep(cs53l30->reset_gpio, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\n\t\t\t       cs53l30->supplies);\n}\n\n#ifdef CONFIG_PM\nstatic int cs53l30_runtime_suspend(struct device *dev)\n{\n\tstruct cs53l30_private *cs53l30 = dev_get_drvdata(dev);\n\n\tregcache_cache_only(cs53l30->regmap, true);\n\n\t \n\tgpiod_set_value_cansleep(cs53l30->reset_gpio, 0);\n\n\tregulator_bulk_disable(ARRAY_SIZE(cs53l30->supplies),\n\t\t\t       cs53l30->supplies);\n\n\treturn 0;\n}\n\nstatic int cs53l30_runtime_resume(struct device *dev)\n{\n\tstruct cs53l30_private *cs53l30 = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(cs53l30->supplies),\n\t\t\t\t    cs53l30->supplies);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tgpiod_set_value_cansleep(cs53l30->reset_gpio, 1);\n\n\tregcache_cache_only(cs53l30->regmap, false);\n\tret = regcache_sync(cs53l30->regmap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to synchronize regcache: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops cs53l30_runtime_pm = {\n\tSET_RUNTIME_PM_OPS(cs53l30_runtime_suspend, cs53l30_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id cs53l30_of_match[] = {\n\t{ .compatible = \"cirrus,cs53l30\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, cs53l30_of_match);\n\nstatic const struct i2c_device_id cs53l30_id[] = {\n\t{ \"cs53l30\", 0 },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, cs53l30_id);\n\nstatic struct i2c_driver cs53l30_i2c_driver = {\n\t.driver = {\n\t\t.name = \"cs53l30\",\n\t\t.of_match_table = cs53l30_of_match,\n\t\t.pm = &cs53l30_runtime_pm,\n\t},\n\t.id_table = cs53l30_id,\n\t.probe = cs53l30_i2c_probe,\n\t.remove = cs53l30_i2c_remove,\n};\n\nmodule_i2c_driver(cs53l30_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC CS53L30 driver\");\nMODULE_AUTHOR(\"Paul Handrigan, Cirrus Logic Inc, <Paul.Handrigan@cirrus.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}