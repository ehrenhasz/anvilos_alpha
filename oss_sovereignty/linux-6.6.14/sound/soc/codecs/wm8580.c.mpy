{
  "module_name": "wm8580.c",
  "hash_id": "4636283d8ce654bc48cd810fc168eb905893fef9158c393180f1afbaa2eff55c",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/wm8580.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/i2c.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/tlv.h>\n#include <sound/initval.h>\n#include <asm/div64.h>\n\n#include \"wm8580.h\"\n\n \n#define WM8580_PLLA1                         0x00\n#define WM8580_PLLA2                         0x01\n#define WM8580_PLLA3                         0x02\n#define WM8580_PLLA4                         0x03\n#define WM8580_PLLB1                         0x04\n#define WM8580_PLLB2                         0x05\n#define WM8580_PLLB3                         0x06\n#define WM8580_PLLB4                         0x07\n#define WM8580_CLKSEL                        0x08\n#define WM8580_PAIF1                         0x09\n#define WM8580_PAIF2                         0x0A\n#define WM8580_SAIF1                         0x0B\n#define WM8580_PAIF3                         0x0C\n#define WM8580_PAIF4                         0x0D\n#define WM8580_SAIF2                         0x0E\n#define WM8580_DAC_CONTROL1                  0x0F\n#define WM8580_DAC_CONTROL2                  0x10\n#define WM8580_DAC_CONTROL3                  0x11\n#define WM8580_DAC_CONTROL4                  0x12\n#define WM8580_DAC_CONTROL5                  0x13\n#define WM8580_DIGITAL_ATTENUATION_DACL1     0x14\n#define WM8580_DIGITAL_ATTENUATION_DACR1     0x15\n#define WM8580_DIGITAL_ATTENUATION_DACL2     0x16\n#define WM8580_DIGITAL_ATTENUATION_DACR2     0x17\n#define WM8580_DIGITAL_ATTENUATION_DACL3     0x18\n#define WM8580_DIGITAL_ATTENUATION_DACR3     0x19\n#define WM8581_DIGITAL_ATTENUATION_DACL4     0x1A\n#define WM8581_DIGITAL_ATTENUATION_DACR4     0x1B\n#define WM8580_MASTER_DIGITAL_ATTENUATION    0x1C\n#define WM8580_ADC_CONTROL1                  0x1D\n#define WM8580_SPDTXCHAN0                    0x1E\n#define WM8580_SPDTXCHAN1                    0x1F\n#define WM8580_SPDTXCHAN2                    0x20\n#define WM8580_SPDTXCHAN3                    0x21\n#define WM8580_SPDTXCHAN4                    0x22\n#define WM8580_SPDTXCHAN5                    0x23\n#define WM8580_SPDMODE                       0x24\n#define WM8580_INTMASK                       0x25\n#define WM8580_GPO1                          0x26\n#define WM8580_GPO2                          0x27\n#define WM8580_GPO3                          0x28\n#define WM8580_GPO4                          0x29\n#define WM8580_GPO5                          0x2A\n#define WM8580_INTSTAT                       0x2B\n#define WM8580_SPDRXCHAN1                    0x2C\n#define WM8580_SPDRXCHAN2                    0x2D\n#define WM8580_SPDRXCHAN3                    0x2E\n#define WM8580_SPDRXCHAN4                    0x2F\n#define WM8580_SPDRXCHAN5                    0x30\n#define WM8580_SPDSTAT                       0x31\n#define WM8580_PWRDN1                        0x32\n#define WM8580_PWRDN2                        0x33\n#define WM8580_READBACK                      0x34\n#define WM8580_RESET                         0x35\n\n#define WM8580_MAX_REGISTER                  0x35\n\n#define WM8580_DACOSR 0x40\n\n \n#define WM8580_PLLB4_MCLKOUTSRC_MASK   0x60\n#define WM8580_PLLB4_MCLKOUTSRC_PLLA   0x20\n#define WM8580_PLLB4_MCLKOUTSRC_PLLB   0x40\n#define WM8580_PLLB4_MCLKOUTSRC_OSC    0x60\n\n#define WM8580_PLLB4_CLKOUTSRC_MASK    0x180\n#define WM8580_PLLB4_CLKOUTSRC_PLLACLK 0x080\n#define WM8580_PLLB4_CLKOUTSRC_PLLBCLK 0x100\n#define WM8580_PLLB4_CLKOUTSRC_OSCCLK  0x180\n\n \n#define WM8580_CLKSEL_DAC_CLKSEL_MASK 0x03\n#define WM8580_CLKSEL_DAC_CLKSEL_PLLA 0x01\n#define WM8580_CLKSEL_DAC_CLKSEL_PLLB 0x02\n\n \n#define WM8580_AIF_RATE_MASK       0x7\n#define WM8580_AIF_BCLKSEL_MASK   0x18\n\n#define WM8580_AIF_MS             0x20\n\n#define WM8580_AIF_CLKSRC_MASK    0xc0\n#define WM8580_AIF_CLKSRC_PLLA    0x40\n#define WM8580_AIF_CLKSRC_PLLB    0x40\n#define WM8580_AIF_CLKSRC_MCLK    0xc0\n\n \n#define WM8580_AIF_FMT_MASK    0x03\n#define WM8580_AIF_FMT_RIGHTJ  0x00\n#define WM8580_AIF_FMT_LEFTJ   0x01\n#define WM8580_AIF_FMT_I2S     0x02\n#define WM8580_AIF_FMT_DSP     0x03\n\n#define WM8580_AIF_LENGTH_MASK   0x0c\n#define WM8580_AIF_LENGTH_16     0x00\n#define WM8580_AIF_LENGTH_20     0x04\n#define WM8580_AIF_LENGTH_24     0x08\n#define WM8580_AIF_LENGTH_32     0x0c\n\n#define WM8580_AIF_LRP         0x10\n#define WM8580_AIF_BCP         0x20\n\n \n#define WM8580_PWRDN1_PWDN     0x001\n#define WM8580_PWRDN1_ALLDACPD 0x040\n\n \n#define WM8580_PWRDN2_OSSCPD   0x001\n#define WM8580_PWRDN2_PLLAPD   0x002\n#define WM8580_PWRDN2_PLLBPD   0x004\n#define WM8580_PWRDN2_SPDIFPD  0x008\n#define WM8580_PWRDN2_SPDIFTXD 0x010\n#define WM8580_PWRDN2_SPDIFRXD 0x020\n\n#define WM8580_DAC_CONTROL5_MUTEALL 0x10\n\n \nstatic const struct reg_default wm8580_reg_defaults[] = {\n\t{  0, 0x0121 },\n\t{  1, 0x017e },\n\t{  2, 0x007d },\n\t{  3, 0x0014 },\n\t{  4, 0x0121 },\n\t{  5, 0x017e },\n\t{  6, 0x007d },\n\t{  7, 0x0194 },\n\t{  8, 0x0010 },\n\t{  9, 0x0002 },\n\t{ 10, 0x0002 },\n\t{ 11, 0x00c2 },\n\t{ 12, 0x0182 },\n\t{ 13, 0x0082 },\n\t{ 14, 0x000a },\n\t{ 15, 0x0024 },\n\t{ 16, 0x0009 },\n\t{ 17, 0x0000 },\n\t{ 18, 0x00ff },\n\t{ 19, 0x0000 },\n\t{ 20, 0x00ff },\n\t{ 21, 0x00ff },\n\t{ 22, 0x00ff },\n\t{ 23, 0x00ff },\n\t{ 24, 0x00ff },\n\t{ 25, 0x00ff },\n\t{ 26, 0x00ff },\n\t{ 27, 0x00ff },\n\t{ 28, 0x01f0 },\n\t{ 29, 0x0040 },\n\t{ 30, 0x0000 },\n\t{ 31, 0x0000 },\n\t{ 32, 0x0000 },\n\t{ 33, 0x0000 },\n\t{ 34, 0x0031 },\n\t{ 35, 0x000b },\n\t{ 36, 0x0039 },\n\t{ 37, 0x0000 },\n\t{ 38, 0x0010 },\n\t{ 39, 0x0032 },\n\t{ 40, 0x0054 },\n\t{ 41, 0x0076 },\n\t{ 42, 0x0098 },\n\t{ 43, 0x0000 },\n\t{ 44, 0x0000 },\n\t{ 45, 0x0000 },\n\t{ 46, 0x0000 },\n\t{ 47, 0x0000 },\n\t{ 48, 0x0000 },\n\t{ 49, 0x0000 },\n\t{ 50, 0x005e },\n\t{ 51, 0x003e },\n\t{ 52, 0x0000 },\n};\n\nstatic bool wm8580_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WM8580_RESET:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstruct pll_state {\n\tunsigned int in;\n\tunsigned int out;\n};\n\n#define WM8580_NUM_SUPPLIES 3\nstatic const char *wm8580_supply_names[WM8580_NUM_SUPPLIES] = {\n\t\"AVDD\",\n\t\"DVDD\",\n\t\"PVDD\",\n};\n\nstruct wm8580_driver_data {\n\tint num_dacs;\n};\n\n \nstruct wm8580_priv {\n\tstruct regmap *regmap;\n\tstruct regulator_bulk_data supplies[WM8580_NUM_SUPPLIES];\n\tstruct pll_state a;\n\tstruct pll_state b;\n\tconst struct wm8580_driver_data *drvdata;\n\tint sysclk[2];\n};\n\nstatic const DECLARE_TLV_DB_SCALE(dac_tlv, -12750, 50, 1);\n\nstatic int wm8580_out_vu(struct snd_kcontrol *kcontrol,\n\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\tunsigned int reg = mc->reg;\n\tunsigned int reg2 = mc->rreg;\n\tint ret;\n\n\t \n\tregcache_cache_only(wm8580->regmap, true);\n\tregmap_update_bits(wm8580->regmap, reg, 0x100, 0x000);\n\tregmap_update_bits(wm8580->regmap, reg2, 0x100, 0x000);\n\tregcache_cache_only(wm8580->regmap, false);\n\n\tret = snd_soc_put_volsw(kcontrol, ucontrol);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tsnd_soc_component_update_bits(component, reg, 0x100, 0x100);\n\tsnd_soc_component_update_bits(component, reg2, 0x100, 0x100);\n\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new wm8580_snd_controls[] = {\nSOC_DOUBLE_R_EXT_TLV(\"DAC1 Playback Volume\",\n\t\t     WM8580_DIGITAL_ATTENUATION_DACL1,\n\t\t     WM8580_DIGITAL_ATTENUATION_DACR1,\n\t\t     0, 0xff, 0, snd_soc_get_volsw, wm8580_out_vu, dac_tlv),\nSOC_DOUBLE_R_EXT_TLV(\"DAC2 Playback Volume\",\n\t\t     WM8580_DIGITAL_ATTENUATION_DACL2,\n\t\t     WM8580_DIGITAL_ATTENUATION_DACR2,\n\t\t     0, 0xff, 0, snd_soc_get_volsw, wm8580_out_vu, dac_tlv),\nSOC_DOUBLE_R_EXT_TLV(\"DAC3 Playback Volume\",\n\t\t     WM8580_DIGITAL_ATTENUATION_DACL3,\n\t\t     WM8580_DIGITAL_ATTENUATION_DACR3,\n\t\t     0, 0xff, 0, snd_soc_get_volsw, wm8580_out_vu, dac_tlv),\n\nSOC_SINGLE(\"DAC1 Deemphasis Switch\", WM8580_DAC_CONTROL3, 0, 1, 0),\nSOC_SINGLE(\"DAC2 Deemphasis Switch\", WM8580_DAC_CONTROL3, 1, 1, 0),\nSOC_SINGLE(\"DAC3 Deemphasis Switch\", WM8580_DAC_CONTROL3, 2, 1, 0),\n\nSOC_DOUBLE(\"DAC1 Invert Switch\", WM8580_DAC_CONTROL4,  0, 1, 1, 0),\nSOC_DOUBLE(\"DAC2 Invert Switch\", WM8580_DAC_CONTROL4,  2, 3, 1, 0),\nSOC_DOUBLE(\"DAC3 Invert Switch\", WM8580_DAC_CONTROL4,  4, 5, 1, 0),\n\nSOC_SINGLE(\"DAC ZC Switch\", WM8580_DAC_CONTROL5, 5, 1, 0),\nSOC_SINGLE(\"DAC1 Switch\", WM8580_DAC_CONTROL5, 0, 1, 1),\nSOC_SINGLE(\"DAC2 Switch\", WM8580_DAC_CONTROL5, 1, 1, 1),\nSOC_SINGLE(\"DAC3 Switch\", WM8580_DAC_CONTROL5, 2, 1, 1),\n\nSOC_DOUBLE(\"Capture Switch\", WM8580_ADC_CONTROL1, 0, 1, 1, 1),\nSOC_SINGLE(\"Capture High-Pass Filter Switch\", WM8580_ADC_CONTROL1, 4, 1, 0),\n};\n\nstatic const struct snd_kcontrol_new wm8581_snd_controls[] = {\nSOC_DOUBLE_R_EXT_TLV(\"DAC4 Playback Volume\",\n\t\t     WM8581_DIGITAL_ATTENUATION_DACL4,\n\t\t     WM8581_DIGITAL_ATTENUATION_DACR4,\n\t\t     0, 0xff, 0, snd_soc_get_volsw, wm8580_out_vu, dac_tlv),\n\nSOC_SINGLE(\"DAC4 Deemphasis Switch\", WM8580_DAC_CONTROL3, 3, 1, 0),\n\nSOC_DOUBLE(\"DAC4 Invert Switch\", WM8580_DAC_CONTROL4,  8, 7, 1, 0),\n\nSOC_SINGLE(\"DAC4 Switch\", WM8580_DAC_CONTROL5, 3, 1, 1),\n};\n\nstatic const struct snd_soc_dapm_widget wm8580_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC1\", \"Playback\", WM8580_PWRDN1, 2, 1),\nSND_SOC_DAPM_DAC(\"DAC2\", \"Playback\", WM8580_PWRDN1, 3, 1),\nSND_SOC_DAPM_DAC(\"DAC3\", \"Playback\", WM8580_PWRDN1, 4, 1),\n\nSND_SOC_DAPM_OUTPUT(\"VOUT1L\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT1R\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT2L\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT2R\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT3L\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT3R\"),\n\nSND_SOC_DAPM_ADC(\"ADC\", \"Capture\", WM8580_PWRDN1, 1, 1),\n\nSND_SOC_DAPM_INPUT(\"AINL\"),\nSND_SOC_DAPM_INPUT(\"AINR\"),\n};\n\nstatic const struct snd_soc_dapm_widget wm8581_dapm_widgets[] = {\nSND_SOC_DAPM_DAC(\"DAC4\", \"Playback\", WM8580_PWRDN1, 5, 1),\n\nSND_SOC_DAPM_OUTPUT(\"VOUT4L\"),\nSND_SOC_DAPM_OUTPUT(\"VOUT4R\"),\n};\n\nstatic const struct snd_soc_dapm_route wm8580_dapm_routes[] = {\n\t{ \"VOUT1L\", NULL, \"DAC1\" },\n\t{ \"VOUT1R\", NULL, \"DAC1\" },\n\n\t{ \"VOUT2L\", NULL, \"DAC2\" },\n\t{ \"VOUT2R\", NULL, \"DAC2\" },\n\n\t{ \"VOUT3L\", NULL, \"DAC3\" },\n\t{ \"VOUT3R\", NULL, \"DAC3\" },\n\n\t{ \"ADC\", NULL, \"AINL\" },\n\t{ \"ADC\", NULL, \"AINR\" },\n};\n\nstatic const struct snd_soc_dapm_route wm8581_dapm_routes[] = {\n\t{ \"VOUT4L\", NULL, \"DAC4\" },\n\t{ \"VOUT4R\", NULL, \"DAC4\" },\n};\n\n \nstruct _pll_div {\n\tu32 prescale:1;\n\tu32 postscale:1;\n\tu32 freqmode:2;\n\tu32 n:4;\n\tu32 k:24;\n};\n\n \n#define FIXED_PLL_SIZE (1 << 22)\n\n \nstatic struct {\n\tunsigned int div;\n\tunsigned int freqmode;\n\tunsigned int postscale;\n} post_table[] = {\n\t{  2,  0, 0 },\n\t{  4,  0, 1 },\n\t{  4,  1, 0 },\n\t{  8,  1, 1 },\n\t{  8,  2, 0 },\n\t{ 16,  2, 1 },\n\t{ 12,  3, 0 },\n\t{ 24,  3, 1 }\n};\n\nstatic int pll_factors(struct _pll_div *pll_div, unsigned int target,\n\t\t       unsigned int source)\n{\n\tu64 Kpart;\n\tunsigned int K, Ndiv, Nmod;\n\tint i;\n\n\tpr_debug(\"wm8580: PLL %uHz->%uHz\\n\", source, target);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(post_table); i++) {\n\t\tif (target * post_table[i].div >=  90000000 &&\n\t\t    target * post_table[i].div <= 100000000) {\n\t\t\tpll_div->freqmode = post_table[i].freqmode;\n\t\t\tpll_div->postscale = post_table[i].postscale;\n\t\t\ttarget *= post_table[i].div;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(post_table)) {\n\t\tprintk(KERN_ERR \"wm8580: Unable to scale output frequency \"\n\t\t       \"%u\\n\", target);\n\t\treturn -EINVAL;\n\t}\n\n\tNdiv = target / source;\n\n\tif (Ndiv < 5) {\n\t\tsource /= 2;\n\t\tpll_div->prescale = 1;\n\t\tNdiv = target / source;\n\t} else\n\t\tpll_div->prescale = 0;\n\n\tif ((Ndiv < 5) || (Ndiv > 13)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"WM8580 N=%u outside supported range\\n\", Ndiv);\n\t\treturn -EINVAL;\n\t}\n\n\tpll_div->n = Ndiv;\n\tNmod = target % source;\n\tKpart = FIXED_PLL_SIZE * (long long)Nmod;\n\n\tdo_div(Kpart, source);\n\n\tK = Kpart & 0xFFFFFFFF;\n\n\tpll_div->k = K;\n\n\tpr_debug(\"PLL %x.%x prescale %d freqmode %d postscale %d\\n\",\n\t\t pll_div->n, pll_div->k, pll_div->prescale, pll_div->freqmode,\n\t\t pll_div->postscale);\n\n\treturn 0;\n}\n\nstatic int wm8580_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\n\t\tint source, unsigned int freq_in, unsigned int freq_out)\n{\n\tint offset;\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\tstruct pll_state *state;\n\tstruct _pll_div pll_div;\n\tunsigned int reg;\n\tunsigned int pwr_mask;\n\tint ret;\n\n\t \n\tmemset(&pll_div, 0, sizeof(pll_div));\n\n\tswitch (pll_id) {\n\tcase WM8580_PLLA:\n\t\tstate = &wm8580->a;\n\t\toffset = 0;\n\t\tpwr_mask = WM8580_PWRDN2_PLLAPD;\n\t\tbreak;\n\tcase WM8580_PLLB:\n\t\tstate = &wm8580->b;\n\t\toffset = 4;\n\t\tpwr_mask = WM8580_PWRDN2_PLLBPD;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tif (freq_in && freq_out) {\n\t\tret = pll_factors(&pll_div, freq_out, freq_in);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tstate->in = freq_in;\n\tstate->out = freq_out;\n\n\t \n\tsnd_soc_component_update_bits(component, WM8580_PWRDN2, pwr_mask, pwr_mask);\n\n\tif (!freq_in || !freq_out)\n\t\treturn 0;\n\n\tsnd_soc_component_write(component, WM8580_PLLA1 + offset, pll_div.k & 0x1ff);\n\tsnd_soc_component_write(component, WM8580_PLLA2 + offset, (pll_div.k >> 9) & 0x1ff);\n\tsnd_soc_component_write(component, WM8580_PLLA3 + offset,\n\t\t     (pll_div.k >> 18 & 0xf) | (pll_div.n << 4));\n\n\treg = snd_soc_component_read(component, WM8580_PLLA4 + offset);\n\treg &= ~0x1b;\n\treg |= pll_div.prescale | pll_div.postscale << 1 |\n\t\tpll_div.freqmode << 3;\n\n\tsnd_soc_component_write(component, WM8580_PLLA4 + offset, reg);\n\n\t \n\tsnd_soc_component_update_bits(component, WM8580_PWRDN2, pwr_mask, 0);\n\n\treturn 0;\n}\n\nstatic const int wm8580_sysclk_ratios[] = {\n\t128, 192, 256, 384, 512, 768, 1152,\n};\n\n \nstatic int wm8580_paif_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\t struct snd_pcm_hw_params *params,\n\t\t\t\t struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\tu16 paifa = 0;\n\tu16 paifb = 0;\n\tint i, ratio, osr;\n\n\t \n\tswitch (params_width(params)) {\n\tcase 16:\n\t\tpaifa |= 0x8;\n\t\tbreak;\n\tcase 20:\n\t\tpaifa |= 0x0;\n\t\tpaifb |= WM8580_AIF_LENGTH_20;\n\t\tbreak;\n\tcase 24:\n\t\tpaifa |= 0x0;\n\t\tpaifb |= WM8580_AIF_LENGTH_24;\n\t\tbreak;\n\tcase 32:\n\t\tpaifa |= 0x0;\n\t\tpaifb |= WM8580_AIF_LENGTH_32;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tratio = wm8580->sysclk[dai->driver->id] / params_rate(params);\n\tfor (i = 0; i < ARRAY_SIZE(wm8580_sysclk_ratios); i++)\n\t\tif (ratio == wm8580_sysclk_ratios[i])\n\t\t\tbreak;\n\tif (i == ARRAY_SIZE(wm8580_sysclk_ratios)) {\n\t\tdev_err(component->dev, \"Invalid clock ratio %d/%d\\n\",\n\t\t\twm8580->sysclk[dai->driver->id], params_rate(params));\n\t\treturn -EINVAL;\n\t}\n\tpaifa |= i;\n\tdev_dbg(component->dev, \"Running at %dfs with %dHz clock\\n\",\n\t\twm8580_sysclk_ratios[i], wm8580->sysclk[dai->driver->id]);\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tswitch (ratio) {\n\t\tcase 128:\n\t\tcase 192:\n\t\t\tosr = WM8580_DACOSR;\n\t\t\tdev_dbg(component->dev, \"Selecting 64x OSR\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tosr = 0;\n\t\t\tdev_dbg(component->dev, \"Selecting 128x OSR\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsnd_soc_component_update_bits(component, WM8580_PAIF3, WM8580_DACOSR, osr);\n\t}\n\n\tsnd_soc_component_update_bits(component, WM8580_PAIF1 + dai->driver->id,\n\t\t\t    WM8580_AIF_RATE_MASK | WM8580_AIF_BCLKSEL_MASK,\n\t\t\t    paifa);\n\tsnd_soc_component_update_bits(component, WM8580_PAIF3 + dai->driver->id,\n\t\t\t    WM8580_AIF_LENGTH_MASK, paifb);\n\treturn 0;\n}\n\nstatic int wm8580_set_paif_dai_fmt(struct snd_soc_dai *codec_dai,\n\t\t\t\t      unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int aifa;\n\tunsigned int aifb;\n\tint can_invert_lrclk;\n\n\taifa = snd_soc_component_read(component, WM8580_PAIF1 + codec_dai->driver->id);\n\taifb = snd_soc_component_read(component, WM8580_PAIF3 + codec_dai->driver->id);\n\n\taifb &= ~(WM8580_AIF_FMT_MASK | WM8580_AIF_LRP | WM8580_AIF_BCP);\n\n\tswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\n\tcase SND_SOC_DAIFMT_CBS_CFS:\n\t\taifa &= ~WM8580_AIF_MS;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_CBM_CFM:\n\t\taifa |= WM8580_AIF_MS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tcan_invert_lrclk = 1;\n\t\taifb |= WM8580_AIF_FMT_I2S;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tcan_invert_lrclk = 1;\n\t\taifb |= WM8580_AIF_FMT_RIGHTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tcan_invert_lrclk = 1;\n\t\taifb |= WM8580_AIF_FMT_LEFTJ;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tcan_invert_lrclk = 0;\n\t\taifb |= WM8580_AIF_FMT_DSP;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tcan_invert_lrclk = 0;\n\t\taifb |= WM8580_AIF_FMT_DSP;\n\t\taifb |= WM8580_AIF_LRP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\n\tcase SND_SOC_DAIFMT_NB_NF:\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_IF:\n\t\tif (!can_invert_lrclk)\n\t\t\treturn -EINVAL;\n\t\taifb |= WM8580_AIF_BCP;\n\t\taifb |= WM8580_AIF_LRP;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_IB_NF:\n\t\taifb |= WM8580_AIF_BCP;\n\t\tbreak;\n\n\tcase SND_SOC_DAIFMT_NB_IF:\n\t\tif (!can_invert_lrclk)\n\t\t\treturn -EINVAL;\n\t\taifb |= WM8580_AIF_LRP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8580_PAIF1 + codec_dai->driver->id, aifa);\n\tsnd_soc_component_write(component, WM8580_PAIF3 + codec_dai->driver->id, aifb);\n\n\treturn 0;\n}\n\nstatic int wm8580_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\n\t\t\t\t int div_id, int div)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int reg;\n\n\tswitch (div_id) {\n\tcase WM8580_MCLK:\n\t\treg = snd_soc_component_read(component, WM8580_PLLB4);\n\t\treg &= ~WM8580_PLLB4_MCLKOUTSRC_MASK;\n\n\t\tswitch (div) {\n\t\tcase WM8580_CLKSRC_MCLK:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase WM8580_CLKSRC_PLLA:\n\t\t\treg |= WM8580_PLLB4_MCLKOUTSRC_PLLA;\n\t\t\tbreak;\n\t\tcase WM8580_CLKSRC_PLLB:\n\t\t\treg |= WM8580_PLLB4_MCLKOUTSRC_PLLB;\n\t\t\tbreak;\n\n\t\tcase WM8580_CLKSRC_OSC:\n\t\t\treg |= WM8580_PLLB4_MCLKOUTSRC_OSC;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_write(component, WM8580_PLLB4, reg);\n\t\tbreak;\n\n\tcase WM8580_CLKOUTSRC:\n\t\treg = snd_soc_component_read(component, WM8580_PLLB4);\n\t\treg &= ~WM8580_PLLB4_CLKOUTSRC_MASK;\n\n\t\tswitch (div) {\n\t\tcase WM8580_CLKSRC_NONE:\n\t\t\tbreak;\n\n\t\tcase WM8580_CLKSRC_PLLA:\n\t\t\treg |= WM8580_PLLB4_CLKOUTSRC_PLLACLK;\n\t\t\tbreak;\n\n\t\tcase WM8580_CLKSRC_PLLB:\n\t\t\treg |= WM8580_PLLB4_CLKOUTSRC_PLLBCLK;\n\t\t\tbreak;\n\n\t\tcase WM8580_CLKSRC_OSC:\n\t\t\treg |= WM8580_PLLB4_CLKOUTSRC_OSCCLK;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsnd_soc_component_write(component, WM8580_PLLB4, reg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int wm8580_set_sysclk(struct snd_soc_dai *dai, int clk_id,\n\t\t\t     unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\tint ret, sel, sel_mask, sel_shift;\n\n\tswitch (dai->driver->id) {\n\tcase WM8580_DAI_PAIFRX:\n\t\tsel_mask = 0x3;\n\t\tsel_shift = 0;\n\t\tbreak;\n\n\tcase WM8580_DAI_PAIFTX:\n\t\tsel_mask = 0xc;\n\t\tsel_shift = 2;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Unknown DAI driver ID\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (clk_id) {\n\tcase WM8580_CLKSRC_ADCMCLK:\n\t\tif (dai->driver->id != WM8580_DAI_PAIFTX)\n\t\t\treturn -EINVAL;\n\t\tsel = 0 << sel_shift;\n\t\tbreak;\n\tcase WM8580_CLKSRC_PLLA:\n\t\tsel = 1 << sel_shift;\n\t\tbreak;\n\tcase WM8580_CLKSRC_PLLB:\n\t\tsel = 2 << sel_shift;\n\t\tbreak;\n\tcase WM8580_CLKSRC_MCLK:\n\t\tsel = 3 << sel_shift;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Unknown clock %d\\n\", clk_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twm8580->sysclk[dai->driver->id] = freq;\n\n\tret = snd_soc_component_update_bits(component, WM8580_CLKSEL, sel_mask, sel);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int wm8580_mute(struct snd_soc_dai *codec_dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tunsigned int reg;\n\n\treg = snd_soc_component_read(component, WM8580_DAC_CONTROL5);\n\n\tif (mute)\n\t\treg |= WM8580_DAC_CONTROL5_MUTEALL;\n\telse\n\t\treg &= ~WM8580_DAC_CONTROL5_MUTEALL;\n\n\tsnd_soc_component_write(component, WM8580_DAC_CONTROL5, reg);\n\n\treturn 0;\n}\n\nstatic int wm8580_set_bias_level(struct snd_soc_component *component,\n\tenum snd_soc_bias_level level)\n{\n\tswitch (level) {\n\tcase SND_SOC_BIAS_ON:\n\tcase SND_SOC_BIAS_PREPARE:\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_STANDBY:\n\t\tif (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8580_PWRDN1,\n\t\t\t\t\t    WM8580_PWRDN1_PWDN |\n\t\t\t\t\t    WM8580_PWRDN1_ALLDACPD, 0);\n\n\t\t\t \n\t\t\tsnd_soc_component_update_bits(component, WM8580_ADC_CONTROL1,\n\t\t\t\t\t    0x100, 0);\n\t\t}\n\t\tbreak;\n\n\tcase SND_SOC_BIAS_OFF:\n\t\tsnd_soc_component_update_bits(component, WM8580_PWRDN1,\n\t\t\t\t    WM8580_PWRDN1_PWDN, WM8580_PWRDN1_PWDN);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int wm8580_playback_startup(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\n\treturn snd_pcm_hw_constraint_minmax(substream->runtime,\n\t\tSNDRV_PCM_HW_PARAM_CHANNELS, 1, wm8580->drvdata->num_dacs * 2);\n}\n\n#define WM8580_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)\n\nstatic const struct snd_soc_dai_ops wm8580_dai_ops_playback = {\n\t.startup\t= wm8580_playback_startup,\n\t.set_sysclk\t= wm8580_set_sysclk,\n\t.hw_params\t= wm8580_paif_hw_params,\n\t.set_fmt\t= wm8580_set_paif_dai_fmt,\n\t.set_clkdiv\t= wm8580_set_dai_clkdiv,\n\t.set_pll\t= wm8580_set_dai_pll,\n\t.mute_stream\t= wm8580_mute,\n\t.no_capture_mute = 1,\n};\n\nstatic const struct snd_soc_dai_ops wm8580_dai_ops_capture = {\n\t.set_sysclk\t= wm8580_set_sysclk,\n\t.hw_params\t= wm8580_paif_hw_params,\n\t.set_fmt\t= wm8580_set_paif_dai_fmt,\n\t.set_clkdiv\t= wm8580_set_dai_clkdiv,\n\t.set_pll\t= wm8580_set_dai_pll,\n};\n\nstatic struct snd_soc_dai_driver wm8580_dai[] = {\n\t{\n\t\t.name = \"wm8580-hifi-playback\",\n\t\t.id\t= WM8580_DAI_PAIFRX,\n\t\t.playback = {\n\t\t\t.stream_name = \"Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = WM8580_FORMATS,\n\t\t},\n\t\t.ops = &wm8580_dai_ops_playback,\n\t},\n\t{\n\t\t.name = \"wm8580-hifi-capture\",\n\t\t.id\t=\tWM8580_DAI_PAIFTX,\n\t\t.capture = {\n\t\t\t.stream_name = \"Capture\",\n\t\t\t.channels_min = 2,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = SNDRV_PCM_RATE_8000_192000,\n\t\t\t.formats = WM8580_FORMATS,\n\t\t},\n\t\t.ops = &wm8580_dai_ops_capture,\n\t},\n};\n\nstatic int wm8580_probe(struct snd_soc_component *component)\n{\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\tstruct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);\n\tint ret = 0;\n\n\tswitch (wm8580->drvdata->num_dacs) {\n\tcase 4:\n\t\tsnd_soc_add_component_controls(component, wm8581_snd_controls,\n\t\t\t\t\tARRAY_SIZE(wm8581_snd_controls));\n\t\tsnd_soc_dapm_new_controls(dapm, wm8581_dapm_widgets,\n\t\t\t\t\tARRAY_SIZE(wm8581_dapm_widgets));\n\t\tsnd_soc_dapm_add_routes(dapm, wm8581_dapm_routes,\n\t\t\t\t\tARRAY_SIZE(wm8581_dapm_routes));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(wm8580->supplies),\n\t\t\t\t    wm8580->supplies);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to enable supplies: %d\\n\", ret);\n\t\tgoto err_regulator_get;\n\t}\n\n\t \n\tret = snd_soc_component_write(component, WM8580_RESET, 0);\n\tif (ret != 0) {\n\t\tdev_err(component->dev, \"Failed to reset component: %d\\n\", ret);\n\t\tgoto err_regulator_enable;\n\t}\n\n\treturn 0;\n\nerr_regulator_enable:\n\tregulator_bulk_disable(ARRAY_SIZE(wm8580->supplies), wm8580->supplies);\nerr_regulator_get:\n\treturn ret;\n}\n\n \nstatic void wm8580_remove(struct snd_soc_component *component)\n{\n\tstruct wm8580_priv *wm8580 = snd_soc_component_get_drvdata(component);\n\n\tregulator_bulk_disable(ARRAY_SIZE(wm8580->supplies), wm8580->supplies);\n}\n\nstatic const struct snd_soc_component_driver soc_component_dev_wm8580 = {\n\t.probe\t\t\t= wm8580_probe,\n\t.remove\t\t\t= wm8580_remove,\n\t.set_bias_level\t\t= wm8580_set_bias_level,\n\t.controls\t\t= wm8580_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(wm8580_snd_controls),\n\t.dapm_widgets\t\t= wm8580_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(wm8580_dapm_widgets),\n\t.dapm_routes\t\t= wm8580_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(wm8580_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config wm8580_regmap = {\n\t.reg_bits = 7,\n\t.val_bits = 9,\n\t.max_register = WM8580_MAX_REGISTER,\n\n\t.reg_defaults = wm8580_reg_defaults,\n\t.num_reg_defaults = ARRAY_SIZE(wm8580_reg_defaults),\n\t.cache_type = REGCACHE_MAPLE,\n\n\t.volatile_reg = wm8580_volatile,\n};\n\nstatic const struct wm8580_driver_data wm8580_data = {\n\t.num_dacs = 3,\n};\n\nstatic const struct wm8580_driver_data wm8581_data = {\n\t.num_dacs = 4,\n};\n\nstatic const struct of_device_id wm8580_of_match[] = {\n\t{ .compatible = \"wlf,wm8580\", .data = &wm8580_data },\n\t{ .compatible = \"wlf,wm8581\", .data = &wm8581_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, wm8580_of_match);\n\nstatic int wm8580_i2c_probe(struct i2c_client *i2c)\n{\n\tconst struct of_device_id *of_id;\n\tstruct wm8580_priv *wm8580;\n\tint ret, i;\n\n\twm8580 = devm_kzalloc(&i2c->dev, sizeof(struct wm8580_priv),\n\t\t\t      GFP_KERNEL);\n\tif (wm8580 == NULL)\n\t\treturn -ENOMEM;\n\n\twm8580->regmap = devm_regmap_init_i2c(i2c, &wm8580_regmap);\n\tif (IS_ERR(wm8580->regmap))\n\t\treturn PTR_ERR(wm8580->regmap);\n\n\tfor (i = 0; i < ARRAY_SIZE(wm8580->supplies); i++)\n\t\twm8580->supplies[i].supply = wm8580_supply_names[i];\n\n\tret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8580->supplies),\n\t\t\t\t      wm8580->supplies);\n\tif (ret != 0) {\n\t\tdev_err(&i2c->dev, \"Failed to request supplies: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, wm8580);\n\n\tof_id = of_match_device(wm8580_of_match, &i2c->dev);\n\tif (of_id)\n\t\twm8580->drvdata = of_id->data;\n\n\tif (!wm8580->drvdata) {\n\t\tdev_err(&i2c->dev, \"failed to find driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = devm_snd_soc_register_component(&i2c->dev,\n\t\t\t&soc_component_dev_wm8580, wm8580_dai, ARRAY_SIZE(wm8580_dai));\n\n\treturn ret;\n}\n\nstatic const struct i2c_device_id wm8580_i2c_id[] = {\n\t{ \"wm8580\", (kernel_ulong_t)&wm8580_data },\n\t{ \"wm8581\", (kernel_ulong_t)&wm8581_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, wm8580_i2c_id);\n\nstatic struct i2c_driver wm8580_i2c_driver = {\n\t.driver = {\n\t\t.name = \"wm8580\",\n\t\t.of_match_table = wm8580_of_match,\n\t},\n\t.probe = wm8580_i2c_probe,\n\t.id_table = wm8580_i2c_id,\n};\n\nmodule_i2c_driver(wm8580_i2c_driver);\n\nMODULE_DESCRIPTION(\"ASoC WM8580 driver\");\nMODULE_AUTHOR(\"Mark Brown <broonie@opensource.wolfsonmicro.com>\");\nMODULE_AUTHOR(\"Matt Flax <flatmax@flatmax.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}