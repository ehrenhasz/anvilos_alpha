{
  "module_name": "tlv320aic26.c",
  "hash_id": "73de659b3e37b4946e9d8c5f9c9b2cb983125621b403e1700be943f4d8f04384",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/tlv320aic26.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/spi/spi.h>\n#include <linux/slab.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/soc.h>\n#include <sound/initval.h>\n\n#include \"tlv320aic26.h\"\n\nMODULE_DESCRIPTION(\"ASoC TLV320AIC26 codec driver\");\nMODULE_AUTHOR(\"Grant Likely <grant.likely@secretlab.ca>\");\nMODULE_LICENSE(\"GPL\");\n\n \nstruct aic26 {\n\tstruct spi_device *spi;\n\tstruct regmap *regmap;\n\tstruct snd_soc_component *component;\n\tint clock_provider;\n\tint datfm;\n\tint mclk;\n\n\t \n\tint keyclick_amplitude;\n\tint keyclick_freq;\n\tint keyclick_len;\n};\n\nstatic const struct snd_soc_dapm_widget tlv320aic26_dapm_widgets[] = {\nSND_SOC_DAPM_INPUT(\"MICIN\"),\nSND_SOC_DAPM_INPUT(\"AUX\"),\n\nSND_SOC_DAPM_OUTPUT(\"HPL\"),\nSND_SOC_DAPM_OUTPUT(\"HPR\"),\n};\n\nstatic const struct snd_soc_dapm_route tlv320aic26_dapm_routes[] = {\n\t{ \"Capture\", NULL, \"MICIN\" },\n\t{ \"Capture\", NULL, \"AUX\" },\n\n\t{ \"HPL\", NULL, \"Playback\" },\n\t{ \"HPR\", NULL, \"Playback\" },\n};\n\n \nstatic int aic26_hw_params(struct snd_pcm_substream *substream,\n\t\t\t   struct snd_pcm_hw_params *params,\n\t\t\t   struct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic26 *aic26 = snd_soc_component_get_drvdata(component);\n\tint fsref, divisor, wlen, pval, jval, dval, qval;\n\tu16 reg;\n\n\tdev_dbg(&aic26->spi->dev, \"aic26_hw_params(substream=%p, params=%p)\\n\",\n\t\tsubstream, params);\n\tdev_dbg(&aic26->spi->dev, \"rate=%i width=%d\\n\", params_rate(params),\n\t\tparams_width(params));\n\n\tswitch (params_rate(params)) {\n\tcase 8000:  fsref = 48000; divisor = AIC26_DIV_6; break;\n\tcase 11025: fsref = 44100; divisor = AIC26_DIV_4; break;\n\tcase 12000: fsref = 48000; divisor = AIC26_DIV_4; break;\n\tcase 16000: fsref = 48000; divisor = AIC26_DIV_3; break;\n\tcase 22050: fsref = 44100; divisor = AIC26_DIV_2; break;\n\tcase 24000: fsref = 48000; divisor = AIC26_DIV_2; break;\n\tcase 32000: fsref = 48000; divisor = AIC26_DIV_1_5; break;\n\tcase 44100: fsref = 44100; divisor = AIC26_DIV_1; break;\n\tcase 48000: fsref = 48000; divisor = AIC26_DIV_1; break;\n\tdefault:\n\t\tdev_dbg(&aic26->spi->dev, \"bad rate\\n\"); return -EINVAL;\n\t}\n\n\t \n\tswitch (params_width(params)) {\n\tcase 8:  wlen = AIC26_WLEN_16; break;\n\tcase 16: wlen = AIC26_WLEN_16; break;\n\tcase 24: wlen = AIC26_WLEN_24; break;\n\tcase 32: wlen = AIC26_WLEN_32; break;\n\tdefault:\n\t\tdev_dbg(&aic26->spi->dev, \"bad format\\n\"); return -EINVAL;\n\t}\n\n\t \n\tpval = 1;\n\t \n\tjval = fsref / (aic26->mclk / 2048);\n\t \n\tdval = fsref - (jval * (aic26->mclk / 2048));\n\tdval = (10000 * dval) / (aic26->mclk / 2048);\n\tdev_dbg(&aic26->spi->dev, \"Setting PLLM to %d.%04d\\n\", jval, dval);\n\tqval = 0;\n\treg = 0x8000 | qval << 11 | pval << 8 | jval << 2;\n\tsnd_soc_component_write(component, AIC26_REG_PLL_PROG1, reg);\n\treg = dval << 2;\n\tsnd_soc_component_write(component, AIC26_REG_PLL_PROG2, reg);\n\n\t \n\tif (aic26->clock_provider)\n\t\treg = 0x0800;\n\tif (fsref == 48000)\n\t\treg = 0x2000;\n\tsnd_soc_component_update_bits(component, AIC26_REG_AUDIO_CTRL3, 0xf800, reg);\n\n\t \n\treg = wlen | aic26->datfm | (divisor << 3) | divisor;\n\tsnd_soc_component_update_bits(component, AIC26_REG_AUDIO_CTRL1, 0xfff, reg);\n\n\treturn 0;\n}\n\n \nstatic int aic26_mute(struct snd_soc_dai *dai, int mute, int direction)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct aic26 *aic26 = snd_soc_component_get_drvdata(component);\n\tu16 reg;\n\n\tdev_dbg(&aic26->spi->dev, \"aic26_mute(dai=%p, mute=%i)\\n\",\n\t\tdai, mute);\n\n\tif (mute)\n\t\treg = 0x8080;\n\telse\n\t\treg = 0;\n\tsnd_soc_component_update_bits(component, AIC26_REG_DAC_GAIN, 0x8000, reg);\n\n\treturn 0;\n}\n\nstatic int aic26_set_sysclk(struct snd_soc_dai *codec_dai,\n\t\t\t    int clk_id, unsigned int freq, int dir)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic26 *aic26 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(&aic26->spi->dev, \"aic26_set_sysclk(dai=%p, clk_id==%i,\"\n\t\t\" freq=%i, dir=%i)\\n\",\n\t\tcodec_dai, clk_id, freq, dir);\n\n\t \n\tif ((freq < 2000000) || (freq > 50000000))\n\t\treturn -EINVAL;\n\n\taic26->mclk = freq;\n\treturn 0;\n}\n\nstatic int aic26_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\n{\n\tstruct snd_soc_component *component = codec_dai->component;\n\tstruct aic26 *aic26 = snd_soc_component_get_drvdata(component);\n\n\tdev_dbg(&aic26->spi->dev, \"aic26_set_fmt(dai=%p, fmt==%i)\\n\",\n\t\tcodec_dai, fmt);\n\n\tswitch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {\n\tcase SND_SOC_DAIFMT_CBP_CFP: aic26->clock_provider = 1; break;\n\tcase SND_SOC_DAIFMT_CBC_CFC: aic26->clock_provider = 0; break;\n\tdefault:\n\t\tdev_dbg(&aic26->spi->dev, \"bad master\\n\"); return -EINVAL;\n\t}\n\n\t \n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:     aic26->datfm = AIC26_DATFM_I2S; break;\n\tcase SND_SOC_DAIFMT_DSP_A:   aic26->datfm = AIC26_DATFM_DSP; break;\n\tcase SND_SOC_DAIFMT_RIGHT_J: aic26->datfm = AIC26_DATFM_RIGHTJ; break;\n\tcase SND_SOC_DAIFMT_LEFT_J:  aic26->datfm = AIC26_DATFM_LEFTJ; break;\n\tdefault:\n\t\tdev_dbg(&aic26->spi->dev, \"bad format\\n\"); return -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \n#define AIC26_RATES\t(SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 |\\\n\t\t\t SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\\\n\t\t\t SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 |\\\n\t\t\t SNDRV_PCM_RATE_48000)\n#define AIC26_FORMATS\t(SNDRV_PCM_FMTBIT_S8     | SNDRV_PCM_FMTBIT_S16_BE |\\\n\t\t\t SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE)\n\nstatic const struct snd_soc_dai_ops aic26_dai_ops = {\n\t.hw_params\t= aic26_hw_params,\n\t.mute_stream\t= aic26_mute,\n\t.set_sysclk\t= aic26_set_sysclk,\n\t.set_fmt\t= aic26_set_fmt,\n\t.no_capture_mute = 1,\n};\n\nstatic struct snd_soc_dai_driver aic26_dai = {\n\t.name = \"tlv320aic26-hifi\",\n\t.playback = {\n\t\t.stream_name = \"Playback\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = AIC26_RATES,\n\t\t.formats = AIC26_FORMATS,\n\t},\n\t.capture = {\n\t\t.stream_name = \"Capture\",\n\t\t.channels_min = 2,\n\t\t.channels_max = 2,\n\t\t.rates = AIC26_RATES,\n\t\t.formats = AIC26_FORMATS,\n\t},\n\t.ops = &aic26_dai_ops,\n};\n\n \nstatic const char *aic26_capture_src_text[] = {\"Mic\", \"Aux\"};\nstatic SOC_ENUM_SINGLE_DECL(aic26_capture_src_enum,\n\t\t\t    AIC26_REG_AUDIO_CTRL1, 12,\n\t\t\t    aic26_capture_src_text);\n\nstatic const struct snd_kcontrol_new aic26_snd_controls[] = {\n\t \n\tSOC_DOUBLE(\"PCM Playback Volume\", AIC26_REG_DAC_GAIN, 8, 0, 0x7f, 1),\n\tSOC_DOUBLE(\"PCM Playback Switch\", AIC26_REG_DAC_GAIN, 15, 7, 1, 1),\n\tSOC_SINGLE(\"PCM Capture Volume\", AIC26_REG_ADC_GAIN, 8, 0x7f, 0),\n\tSOC_SINGLE(\"PCM Capture Mute\", AIC26_REG_ADC_GAIN, 15, 1, 1),\n\tSOC_SINGLE(\"Keyclick activate\", AIC26_REG_AUDIO_CTRL2, 15, 0x1, 0),\n\tSOC_SINGLE(\"Keyclick amplitude\", AIC26_REG_AUDIO_CTRL2, 12, 0x7, 0),\n\tSOC_SINGLE(\"Keyclick frequency\", AIC26_REG_AUDIO_CTRL2, 8, 0x7, 0),\n\tSOC_SINGLE(\"Keyclick period\", AIC26_REG_AUDIO_CTRL2, 4, 0xf, 0),\n\tSOC_ENUM(\"Capture Source\", aic26_capture_src_enum),\n};\n\n \n\nstatic ssize_t keyclick_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct aic26 *aic26 = dev_get_drvdata(dev);\n\tint val, amp, freq, len;\n\n\tval = snd_soc_component_read(aic26->component, AIC26_REG_AUDIO_CTRL2);\n\tamp = (val >> 12) & 0x7;\n\tfreq = (125 << ((val >> 8) & 0x7)) >> 1;\n\tlen = 2 * (1 + ((val >> 4) & 0xf));\n\n\treturn sysfs_emit(buf, \"amp=%x freq=%iHz len=%iclks\\n\", amp, freq, len);\n}\n\n \nstatic ssize_t keyclick_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct aic26 *aic26 = dev_get_drvdata(dev);\n\n\tsnd_soc_component_update_bits(aic26->component, AIC26_REG_AUDIO_CTRL2,\n\t\t\t    0x8000, 0x800);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(keyclick);\n\n \nstatic int aic26_probe(struct snd_soc_component *component)\n{\n\tstruct aic26 *aic26 = dev_get_drvdata(component->dev);\n\tint ret, reg;\n\n\taic26->component = component;\n\n\t \n\tsnd_soc_component_write(component, AIC26_REG_RESET, 0xBB00);\n\n\t \n\tsnd_soc_component_write(component, AIC26_REG_POWER_CTRL, 0);\n\n\t \n\treg = snd_soc_component_read(component, AIC26_REG_AUDIO_CTRL3);\n\treg &= ~0xf800;\n\treg |= 0x0800;  \n\tsnd_soc_component_write(component, AIC26_REG_AUDIO_CTRL3, reg);\n\n\t \n\t \n\tret = device_create_file(component->dev, &dev_attr_keyclick);\n\tif (ret)\n\t\tdev_info(component->dev, \"error creating sysfs files\\n\");\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver aic26_soc_component_dev = {\n\t.probe\t\t\t= aic26_probe,\n\t.controls\t\t= aic26_snd_controls,\n\t.num_controls\t\t= ARRAY_SIZE(aic26_snd_controls),\n\t.dapm_widgets\t\t= tlv320aic26_dapm_widgets,\n\t.num_dapm_widgets\t= ARRAY_SIZE(tlv320aic26_dapm_widgets),\n\t.dapm_routes\t\t= tlv320aic26_dapm_routes,\n\t.num_dapm_routes\t= ARRAY_SIZE(tlv320aic26_dapm_routes),\n\t.idle_bias_on\t\t= 1,\n\t.use_pmdown_time\t= 1,\n\t.endianness\t\t= 1,\n};\n\nstatic const struct regmap_config aic26_regmap = {\n\t.reg_bits = 16,\n\t.val_bits = 16,\n};\n\n \nstatic int aic26_spi_probe(struct spi_device *spi)\n{\n\tstruct aic26 *aic26;\n\tint ret;\n\n\tdev_dbg(&spi->dev, \"probing tlv320aic26 spi device\\n\");\n\n\t \n\taic26 = devm_kzalloc(&spi->dev, sizeof *aic26, GFP_KERNEL);\n\tif (!aic26)\n\t\treturn -ENOMEM;\n\n\taic26->regmap = devm_regmap_init_spi(spi, &aic26_regmap);\n\tif (IS_ERR(aic26->regmap))\n\t\treturn PTR_ERR(aic26->regmap);\n\n\t \n\taic26->spi = spi;\n\tdev_set_drvdata(&spi->dev, aic26);\n\taic26->clock_provider = 1;\n\n\tret = devm_snd_soc_register_component(&spi->dev,\n\t\t\t&aic26_soc_component_dev, &aic26_dai, 1);\n\treturn ret;\n}\n\nstatic struct spi_driver aic26_spi = {\n\t.driver = {\n\t\t.name = \"tlv320aic26-codec\",\n\t},\n\t.probe = aic26_spi_probe,\n};\n\nmodule_spi_driver(aic26_spi);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}