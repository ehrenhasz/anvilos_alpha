{
  "module_name": "rt722-sdca.c",
  "hash_id": "2cf854892027176dca07fcace45f46a1ba7ef223a2f58e254179dbdfdbb0d79a",
  "original_prompt": "Ingested from linux-6.6.14/sound/soc/codecs/rt722-sdca.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include <linux/bitops.h>\n#include <sound/core.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <sound/initval.h>\n#include <sound/jack.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <sound/pcm.h>\n#include <linux/pm_runtime.h>\n#include <sound/pcm_params.h>\n#include <linux/soundwire/sdw_registers.h>\n#include <linux/slab.h>\n#include <sound/soc-dapm.h>\n#include <sound/tlv.h>\n\n#include \"rt722-sdca.h\"\n\nint rt722_sdca_index_write(struct rt722_sdca_priv *rt722,\n\t\tunsigned int nid, unsigned int reg, unsigned int value)\n{\n\tstruct regmap *regmap = rt722->mbq_regmap;\n\tunsigned int addr = (nid << 20) | reg;\n\tint ret;\n\n\tret = regmap_write(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt722->slave->dev,\n\t\t\t\"Failed to set private value: %06x <= %04x ret=%d\\n\",\n\t\t\taddr, value, ret);\n\n\treturn ret;\n}\n\nint rt722_sdca_index_read(struct rt722_sdca_priv *rt722,\n\t\tunsigned int nid, unsigned int reg, unsigned int *value)\n{\n\tint ret;\n\tstruct regmap *regmap = rt722->mbq_regmap;\n\tunsigned int addr = (nid << 20) | reg;\n\n\tret = regmap_read(regmap, addr, value);\n\tif (ret < 0)\n\t\tdev_err(&rt722->slave->dev,\n\t\t\t\"Failed to get private value: %06x => %04x ret=%d\\n\",\n\t\t\taddr, *value, ret);\n\n\treturn ret;\n}\n\nstatic int rt722_sdca_index_update_bits(struct rt722_sdca_priv *rt722,\n\tunsigned int nid, unsigned int reg, unsigned int mask, unsigned int val)\n{\n\tunsigned int tmp;\n\tint ret;\n\n\tret = rt722_sdca_index_read(rt722, nid, reg, &tmp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_mask_bits(&tmp, mask, val);\n\treturn rt722_sdca_index_write(rt722, nid, reg, tmp);\n}\n\nstatic int rt722_sdca_btn_type(unsigned char *buffer)\n{\n\tif ((*buffer & 0xf0) == 0x10 || (*buffer & 0x0f) == 0x01 || (*(buffer + 1) == 0x01) ||\n\t\t(*(buffer + 1) == 0x10))\n\t\treturn SND_JACK_BTN_2;\n\telse if ((*buffer & 0xf0) == 0x20 || (*buffer & 0x0f) == 0x02 || (*(buffer + 1) == 0x02) ||\n\t\t(*(buffer + 1) == 0x20))\n\t\treturn SND_JACK_BTN_3;\n\telse if ((*buffer & 0xf0) == 0x40 || (*buffer & 0x0f) == 0x04 || (*(buffer + 1) == 0x04) ||\n\t\t(*(buffer + 1) == 0x40))\n\t\treturn SND_JACK_BTN_0;\n\telse if ((*buffer & 0xf0) == 0x80 || (*buffer & 0x0f) == 0x08 || (*(buffer + 1) == 0x08) ||\n\t\t(*(buffer + 1) == 0x80))\n\t\treturn SND_JACK_BTN_1;\n\n\treturn 0;\n}\n\nstatic unsigned int rt722_sdca_button_detect(struct rt722_sdca_priv *rt722)\n{\n\tunsigned int btn_type = 0, offset, idx, val, owner;\n\tint ret;\n\tunsigned char buf[3];\n\n\t \n\tret = regmap_read(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\tRT722_SDCA_CTL_HIDTX_CURRENT_OWNER, 0), &owner);\n\tif (ret < 0)\n\t\treturn 0;\n\n\t \n\tif (owner == 1)\n\t\treturn 0;\n\n\t \n\tret = regmap_read(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\tRT722_SDCA_CTL_HIDTX_MESSAGE_OFFSET, 0), &offset);\n\tif (ret < 0)\n\t\tgoto _end_btn_det_;\n\n\tfor (idx = 0; idx < sizeof(buf); idx++) {\n\t\tret = regmap_read(rt722->regmap,\n\t\t\tRT722_BUF_ADDR_HID1 + offset + idx, &val);\n\t\tif (ret < 0)\n\t\t\tgoto _end_btn_det_;\n\t\tbuf[idx] = val & 0xff;\n\t}\n\n\tif (buf[0] == 0x11)\n\t\tbtn_type = rt722_sdca_btn_type(&buf[1]);\n\n_end_btn_det_:\n\t \n\tif (owner == 0)\n\t\t \n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\t\tRT722_SDCA_CTL_HIDTX_CURRENT_OWNER, 0), 0x01);\n\n\treturn btn_type;\n}\n\nstatic int rt722_sdca_headset_detect(struct rt722_sdca_priv *rt722)\n{\n\tunsigned int det_mode;\n\tint ret;\n\n\t \n\tret = regmap_read(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49,\n\t\t\tRT722_SDCA_CTL_DETECTED_MODE, 0), &det_mode);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\tswitch (det_mode) {\n\tcase 0x00:\n\t\trt722->jack_type = 0;\n\t\tbreak;\n\tcase 0x03:\n\t\trt722->jack_type = SND_JACK_HEADPHONE;\n\t\tbreak;\n\tcase 0x05:\n\t\trt722->jack_type = SND_JACK_HEADSET;\n\t\tbreak;\n\t}\n\n\t \n\tif (det_mode) {\n\t\tret = regmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49,\n\t\t\t\tRT722_SDCA_CTL_SELECTED_MODE, 0), det_mode);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\t}\n\n\tdev_dbg(&rt722->slave->dev,\n\t\t\"%s, detected_mode=0x%x\\n\", __func__, det_mode);\n\n\treturn 0;\n\nio_error:\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void rt722_sdca_jack_detect_handler(struct work_struct *work)\n{\n\tstruct rt722_sdca_priv *rt722 =\n\t\tcontainer_of(work, struct rt722_sdca_priv, jack_detect_work.work);\n\tint btn_type = 0, ret;\n\n\tif (!rt722->hs_jack)\n\t\treturn;\n\n\tif (!rt722->component->card || !rt722->component->card->instantiated)\n\t\treturn;\n\n\t \n\tif (rt722->scp_sdca_stat1 & SDW_SCP_SDCA_INT_SDCA_6) {\n\t\tret = rt722_sdca_headset_detect(rt722);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t}\n\n\t \n\tif (rt722->scp_sdca_stat2 & SDW_SCP_SDCA_INT_SDCA_8)\n\t\tbtn_type = rt722_sdca_button_detect(rt722);\n\n\tif (rt722->jack_type == 0)\n\t\tbtn_type = 0;\n\n\tdev_dbg(&rt722->slave->dev,\n\t\t\"in %s, jack_type=%d\\n\", __func__, rt722->jack_type);\n\tdev_dbg(&rt722->slave->dev,\n\t\t\"in %s, btn_type=0x%x\\n\", __func__, btn_type);\n\tdev_dbg(&rt722->slave->dev,\n\t\t\"in %s, scp_sdca_stat1=0x%x, scp_sdca_stat2=0x%x\\n\", __func__,\n\t\trt722->scp_sdca_stat1, rt722->scp_sdca_stat2);\n\n\tsnd_soc_jack_report(rt722->hs_jack, rt722->jack_type | btn_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\tif (btn_type) {\n\t\t \n\t\tsnd_soc_jack_report(rt722->hs_jack, rt722->jack_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt722->jack_btn_check_work, msecs_to_jiffies(200));\n\t}\n}\n\nstatic void rt722_sdca_btn_check_handler(struct work_struct *work)\n{\n\tstruct rt722_sdca_priv *rt722 =\n\t\tcontainer_of(work, struct rt722_sdca_priv, jack_btn_check_work.work);\n\tint btn_type = 0, ret, idx;\n\tunsigned int det_mode, offset, val;\n\tunsigned char buf[3];\n\n\tret = regmap_read(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_GE49,\n\t\t\tRT722_SDCA_CTL_DETECTED_MODE, 0), &det_mode);\n\tif (ret < 0)\n\t\tgoto io_error;\n\n\t \n\tif (det_mode) {\n\t\t \n\t\tret = regmap_read(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_HID, RT722_SDCA_ENT_HID01,\n\t\t\t\tRT722_SDCA_CTL_HIDTX_MESSAGE_OFFSET, 0), &offset);\n\t\tif (ret < 0)\n\t\t\tgoto io_error;\n\n\t\tfor (idx = 0; idx < sizeof(buf); idx++) {\n\t\t\tret = regmap_read(rt722->regmap,\n\t\t\t\tRT722_BUF_ADDR_HID1 + offset + idx, &val);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto io_error;\n\t\t\tbuf[idx] = val & 0xff;\n\t\t}\n\n\t\tif (buf[0] == 0x11)\n\t\t\tbtn_type = rt722_sdca_btn_type(&buf[1]);\n\t} else\n\t\trt722->jack_type = 0;\n\n\tdev_dbg(&rt722->slave->dev, \"%s, btn_type=0x%x\\n\",\t__func__, btn_type);\n\tsnd_soc_jack_report(rt722->hs_jack, rt722->jack_type | btn_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\tif (btn_type) {\n\t\t \n\t\tsnd_soc_jack_report(rt722->hs_jack, rt722->jack_type,\n\t\t\tSND_JACK_HEADSET |\n\t\t\tSND_JACK_BTN_0 | SND_JACK_BTN_1 |\n\t\t\tSND_JACK_BTN_2 | SND_JACK_BTN_3);\n\n\t\tmod_delayed_work(system_power_efficient_wq,\n\t\t\t&rt722->jack_btn_check_work, msecs_to_jiffies(200));\n\t}\n\n\treturn;\n\nio_error:\n\tpr_err_ratelimited(\"IO error in %s, ret %d\\n\", __func__, ret);\n}\n\nstatic void rt722_sdca_jack_init(struct rt722_sdca_priv *rt722)\n{\n\tmutex_lock(&rt722->calibrate_mutex);\n\tif (rt722->hs_jack) {\n\t\t \n\t\tsdw_write_no_pm(rt722->slave, SDW_SCP_SDCA_INTMASK1,\n\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_0 | SDW_SCP_SDCA_INTMASK_SDCA_6);\n\t\t \n\t\tsdw_write_no_pm(rt722->slave, SDW_SCP_SDCA_INTMASK2,\n\t\t\tSDW_SCP_SDCA_INTMASK_SDCA_8);\n\t\tdev_dbg(&rt722->slave->dev, \"in %s enable\\n\", __func__);\n\t\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\t\tRT722_HDA_LEGACY_UNSOL_CTL, 0x016E);\n\t\t \n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_XU03,\n\t\t\t\tRT722_SDCA_CTL_SELECTED_MODE, 0), 0);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_XU0D,\n\t\t\t\tRT722_SDCA_CTL_SELECTED_MODE, 0), 0);\n\t\t \n\t\trt722_sdca_index_update_bits(rt722, RT722_VENDOR_HDA_CTL,\n\t\t\tRT722_GE_RELATED_CTL2, 0x4000, 0x4000);\n\t}\n\tmutex_unlock(&rt722->calibrate_mutex);\n}\n\nstatic int rt722_sdca_set_jack_detect(struct snd_soc_component *component,\n\tstruct snd_soc_jack *hs_jack, void *data)\n{\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt722->hs_jack = hs_jack;\n\n\tret = pm_runtime_resume_and_get(component->dev);\n\tif (ret < 0) {\n\t\tif (ret != -EACCES) {\n\t\t\tdev_err(component->dev, \"%s: failed to resume %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tdev_dbg(component->dev,\t\"%s: skipping jack init for now\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\trt722_sdca_jack_init(rt722);\n\n\tpm_runtime_mark_last_busy(component->dev);\n\tpm_runtime_put_autosuspend(component->dev);\n\n\treturn 0;\n}\n\n \nstatic int rt722_sdca_set_gain_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned int read_l, read_r, gain_l_val, gain_r_val;\n\tunsigned int adc_vol_flag = 0, changed = 0;\n\tunsigned int lvalue, rvalue;\n\tconst unsigned int interval_offset = 0xc0;\n\tconst unsigned int tendB = 0xa00;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\") ||\n\t\tstrstr(ucontrol->id.name, \"FU0F Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\tregmap_read(rt722->mbq_regmap, mc->reg, &lvalue);\n\tregmap_read(rt722->mbq_regmap, mc->rreg, &rvalue);\n\n\t \n\tgain_l_val = ucontrol->value.integer.value[0];\n\tif (gain_l_val > mc->max)\n\t\tgain_l_val = mc->max;\n\n\tif (mc->shift == 8)  \n\t\tgain_l_val = gain_l_val * tendB;\n\telse {\n\t\t \n\t\tif (adc_vol_flag)\n\t\t\tgain_l_val = 0x1e00 - ((mc->max - gain_l_val) * interval_offset);\n\t\telse\n\t\t\tgain_l_val = 0 - ((mc->max - gain_l_val) * interval_offset);\n\t\tgain_l_val &= 0xffff;\n\t}\n\n\t \n\tgain_r_val = ucontrol->value.integer.value[1];\n\tif (gain_r_val > mc->max)\n\t\tgain_r_val = mc->max;\n\n\tif (mc->shift == 8)  \n\t\tgain_r_val = gain_r_val * tendB;\n\telse {\n\t\t \n\t\tif (adc_vol_flag)\n\t\t\tgain_r_val = 0x1e00 - ((mc->max - gain_r_val) * interval_offset);\n\t\telse\n\t\t\tgain_r_val = 0 - ((mc->max - gain_r_val) * interval_offset);\n\t\tgain_r_val &= 0xffff;\n\t}\n\n\tif (lvalue != gain_l_val || rvalue != gain_r_val)\n\t\tchanged = 1;\n\telse\n\t\treturn 0;\n\n\t \n\tregmap_write(rt722->mbq_regmap, mc->reg, gain_l_val);\n\n\t \n\tregmap_write(rt722->mbq_regmap, mc->rreg, gain_r_val);\n\n\tregmap_read(rt722->mbq_regmap, mc->reg, &read_l);\n\tregmap_read(rt722->mbq_regmap, mc->rreg, &read_r);\n\tif (read_r == gain_r_val && read_l == gain_l_val)\n\t\treturn changed;\n\n\treturn -EIO;\n}\n\nstatic int rt722_sdca_set_gain_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct soc_mixer_control *mc =\n\t\t(struct soc_mixer_control *)kcontrol->private_value;\n\tunsigned int read_l, read_r, ctl_l = 0, ctl_r = 0;\n\tunsigned int adc_vol_flag = 0;\n\tconst unsigned int interval_offset = 0xc0;\n\tconst unsigned int tendB = 0xa00;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\") ||\n\t\tstrstr(ucontrol->id.name, \"FU0F Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\tregmap_read(rt722->mbq_regmap, mc->reg, &read_l);\n\tregmap_read(rt722->mbq_regmap, mc->rreg, &read_r);\n\n\tif (mc->shift == 8)  \n\t\tctl_l = read_l / tendB;\n\telse {\n\t\tif (adc_vol_flag)\n\t\t\tctl_l = mc->max - (((0x1e00 - read_l) & 0xffff) / interval_offset);\n\t\telse\n\t\t\tctl_l = mc->max - (((0 - read_l) & 0xffff) / interval_offset);\n\t}\n\n\tif (read_l != read_r) {\n\t\tif (mc->shift == 8)  \n\t\t\tctl_r = read_r / tendB;\n\t\telse {  \n\t\t\tif (adc_vol_flag)\n\t\t\t\tctl_r = mc->max - (((0x1e00 - read_r) & 0xffff) / interval_offset);\n\t\t\telse\n\t\t\t\tctl_r = mc->max - (((0 - read_r) & 0xffff) / interval_offset);\n\t\t}\n\t} else {\n\t\tctl_r = ctl_l;\n\t}\n\n\tucontrol->value.integer.value[0] = ctl_l;\n\tucontrol->value.integer.value[1] = ctl_r;\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_set_fu1e_capture_ctl(struct rt722_sdca_priv *rt722)\n{\n\tint err, i;\n\tunsigned int ch_mute;\n\n\tfor (i = 0; i < ARRAY_SIZE(rt722->fu1e_mixer_mute); i++) {\n\t\tch_mute = rt722->fu1e_dapm_mute || rt722->fu1e_mixer_mute[i];\n\t\terr = regmap_write(rt722->regmap,\n\t\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_01) + i, ch_mute);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu1e_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct rt722_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt722_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tunsigned int i;\n\n\tfor (i = 0; i < p->count; i++)\n\t\tucontrol->value.integer.value[i] = !rt722->fu1e_mixer_mute[i];\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu1e_capture_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct rt722_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt722_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tint err, changed = 0, i;\n\n\tfor (i = 0; i < p->count; i++) {\n\t\tif (rt722->fu1e_mixer_mute[i] != !ucontrol->value.integer.value[i])\n\t\t\tchanged = 1;\n\t\trt722->fu1e_mixer_mute[i] = !ucontrol->value.integer.value[i];\n\t}\n\n\terr = rt722_sdca_set_fu1e_capture_ctl(rt722);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn changed;\n}\n\nstatic int rt722_sdca_set_fu0f_capture_ctl(struct rt722_sdca_priv *rt722)\n{\n\tint err;\n\tunsigned int ch_l, ch_r;\n\n\tch_l = (rt722->fu0f_dapm_mute || rt722->fu0f_mixer_l_mute) ? 0x01 : 0x00;\n\tch_r = (rt722->fu0f_dapm_mute || rt722->fu0f_mixer_r_mute) ? 0x01 : 0x00;\n\n\terr = regmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F,\n\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_L), ch_l);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = regmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F,\n\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_R), ch_r);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu0f_capture_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\n\tucontrol->value.integer.value[0] = !rt722->fu0f_mixer_l_mute;\n\tucontrol->value.integer.value[1] = !rt722->fu0f_mixer_r_mute;\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu0f_capture_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tint err, changed = 0;\n\n\tif (rt722->fu0f_mixer_l_mute != !ucontrol->value.integer.value[0] ||\n\t\trt722->fu0f_mixer_r_mute != !ucontrol->value.integer.value[1])\n\t\tchanged = 1;\n\n\trt722->fu0f_mixer_l_mute = !ucontrol->value.integer.value[0];\n\trt722->fu0f_mixer_r_mute = !ucontrol->value.integer.value[1];\n\terr = rt722_sdca_set_fu0f_capture_ctl(rt722);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn changed;\n}\n\nstatic int rt722_sdca_fu_info(struct snd_kcontrol *kcontrol,\n\tstruct snd_ctl_elem_info *uinfo)\n{\n\tstruct rt722_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt722_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\n\tif (p->max == 1)\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\telse\n\t\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = p->count;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = p->max;\n\treturn 0;\n}\n\nstatic int rt722_sdca_dmic_set_gain_get(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct rt722_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt722_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tunsigned int boost_step = 0x0a00;\n\tunsigned int vol_max = 0x1e00;\n\tunsigned int regvalue, ctl, i;\n\tunsigned int adc_vol_flag = 0;\n\tconst unsigned int interval_offset = 0xc0;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\t \n\tfor (i = 0; i < p->count; i++) {\n\t\tregmap_read(rt722->mbq_regmap, p->reg_base + i, &regvalue);\n\n\t\tif (!adc_vol_flag)  \n\t\t\tctl = regvalue / boost_step;\n\t\telse {  \n\t\t\tif (adc_vol_flag)\n\t\t\t\tctl = p->max - (((vol_max - regvalue) & 0xffff) / interval_offset);\n\t\t\telse\n\t\t\t\tctl = p->max - (((0 - regvalue) & 0xffff) / interval_offset);\n\t\t}\n\n\t\tucontrol->value.integer.value[i] = ctl;\n\t}\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_dmic_set_gain_put(struct snd_kcontrol *kcontrol,\n\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\n\tstruct rt722_sdca_dmic_kctrl_priv *p =\n\t\t(struct rt722_sdca_dmic_kctrl_priv *)kcontrol->private_value;\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned int boost_step = 0x0a00;\n\tunsigned int vol_max = 0x1e00;\n\tunsigned int gain_val[4];\n\tunsigned int i, adc_vol_flag = 0, changed = 0;\n\tunsigned int regvalue[4];\n\tconst unsigned int interval_offset = 0xc0;\n\tint err;\n\n\tif (strstr(ucontrol->id.name, \"FU1E Capture Volume\"))\n\t\tadc_vol_flag = 1;\n\n\t \n\tfor (i = 0; i < p->count; i++) {\n\t\tregmap_read(rt722->mbq_regmap, p->reg_base + i, &regvalue[i]);\n\n\t\tgain_val[i] = ucontrol->value.integer.value[i];\n\t\tif (gain_val[i] > p->max)\n\t\t\tgain_val[i] = p->max;\n\n\t\tif (!adc_vol_flag)  \n\t\t\tgain_val[i] = gain_val[i] * boost_step;\n\t\telse {  \n\t\t\tgain_val[i] = vol_max - ((p->max - gain_val[i]) * interval_offset);\n\t\t\tgain_val[i] &= 0xffff;\n\t\t}\n\n\t\tif (regvalue[i] != gain_val[i])\n\t\t\tchanged = 1;\n\t}\n\n\tif (!changed)\n\t\treturn 0;\n\n\tfor (i = 0; i < p->count; i++) {\n\t\terr = regmap_write(rt722->mbq_regmap, p->reg_base + i, gain_val[i]);\n\t\tif (err < 0)\n\t\t\tdev_err(&rt722->slave->dev, \"%#08x can't be set\\n\", p->reg_base + i);\n\t}\n\n\treturn changed;\n}\n\n#define RT722_SDCA_PR_VALUE(xreg_base, xcount, xmax, xinvert) \\\n\t((unsigned long)&(struct rt722_sdca_dmic_kctrl_priv) \\\n\t\t{.reg_base = xreg_base, .count = xcount, .max = xmax, \\\n\t\t.invert = xinvert})\n\n#define RT722_SDCA_FU_CTRL(xname, reg_base, xmax, xinvert, xcount) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.info = rt722_sdca_fu_info, \\\n\t.get = rt722_sdca_fu1e_capture_get, \\\n\t.put = rt722_sdca_fu1e_capture_put, \\\n\t.private_value = RT722_SDCA_PR_VALUE(reg_base, xcount, xmax, xinvert)}\n\n#define RT722_SDCA_EXT_TLV(xname, reg_base, xhandler_get,\\\n\t xhandler_put, xcount, xmax, tlv_array) \\\n{\t.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \\\n\t.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \\\n\t\t SNDRV_CTL_ELEM_ACCESS_READWRITE, \\\n\t.tlv.p = (tlv_array), \\\n\t.info = rt722_sdca_fu_info, \\\n\t.get = xhandler_get, .put = xhandler_put, \\\n\t.private_value = RT722_SDCA_PR_VALUE(reg_base, xcount, xmax, 0) }\n\nstatic const DECLARE_TLV_DB_SCALE(out_vol_tlv, -6525, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(mic_vol_tlv, -1725, 75, 0);\nstatic const DECLARE_TLV_DB_SCALE(boost_vol_tlv, 0, 1000, 0);\n\nstatic const struct snd_kcontrol_new rt722_sdca_controls[] = {\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"FU05 Playback Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_R), 0, 0x57, 0,\n\t\trt722_sdca_set_gain_get, rt722_sdca_set_gain_put, out_vol_tlv),\n\t \n\tSOC_DOUBLE_EXT(\"FU0F Capture Switch\", SND_SOC_NOPM, 0, 1, 1, 0,\n\t\trt722_sdca_fu0f_capture_get, rt722_sdca_fu0f_capture_put),\n\tSOC_DOUBLE_R_EXT_TLV(\"FU0F Capture Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU0F,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_R), 0, 0x3f, 0,\n\t\trt722_sdca_set_gain_get, rt722_sdca_set_gain_put, mic_vol_tlv),\n\tSOC_DOUBLE_R_EXT_TLV(\"FU33 Boost Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PLATFORM_FU44,\n\t\t\tRT722_SDCA_CTL_FU_CH_GAIN, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PLATFORM_FU44,\n\t\t\tRT722_SDCA_CTL_FU_CH_GAIN, CH_R), 8, 3, 0,\n\t\trt722_sdca_set_gain_get, rt722_sdca_set_gain_put, boost_vol_tlv),\n\t \n\tSOC_DOUBLE_R_EXT_TLV(\"FU06 Playback Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_L),\n\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_R), 0, 0x57, 0,\n\t\trt722_sdca_set_gain_get, rt722_sdca_set_gain_put, out_vol_tlv),\n\t \n\tRT722_SDCA_FU_CTRL(\"FU1E Capture Switch\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E,\n\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_01), 1, 1, 4),\n\tRT722_SDCA_EXT_TLV(\"FU1E Capture Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_USER_FU1E,\n\t\t\tRT722_SDCA_CTL_FU_VOLUME, CH_01),\n\t\trt722_sdca_dmic_set_gain_get, rt722_sdca_dmic_set_gain_put,\n\t\t\t4, 0x3f, mic_vol_tlv),\n\tRT722_SDCA_EXT_TLV(\"FU15 Boost Volume\",\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_FU15,\n\t\t\tRT722_SDCA_CTL_FU_CH_GAIN, CH_01),\n\t\trt722_sdca_dmic_set_gain_get, rt722_sdca_dmic_set_gain_put,\n\t\t\t4, 3, boost_vol_tlv),\n};\n\nstatic int rt722_sdca_adc_mux_get(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned int val = 0, mask_sft;\n\n\tif (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tmask_sft = 12;\n\telse if (strstr(ucontrol->id.name, \"ADC 24 Mux\"))\n\t\tmask_sft = 4;\n\telse if (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 0;\n\telse\n\t\treturn -EINVAL;\n\n\trt722_sdca_index_read(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_HDA_LEGACY_MUX_CTL0, &val);\n\n\tucontrol->value.enumerated.item[0] = (val >> mask_sft) & 0x7;\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_adc_mux_put(struct snd_kcontrol *kcontrol,\n\t\t\tstruct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_kcontrol_component(kcontrol);\n\tstruct snd_soc_dapm_context *dapm =\n\t\tsnd_soc_dapm_kcontrol_dapm(kcontrol);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\n\tunsigned int *item = ucontrol->value.enumerated.item;\n\tunsigned int val, val2 = 0, change, mask_sft;\n\n\tif (item[0] >= e->items)\n\t\treturn -EINVAL;\n\n\tif (strstr(ucontrol->id.name, \"ADC 22 Mux\"))\n\t\tmask_sft = 12;\n\telse if (strstr(ucontrol->id.name, \"ADC 24 Mux\"))\n\t\tmask_sft = 4;\n\telse if (strstr(ucontrol->id.name, \"ADC 25 Mux\"))\n\t\tmask_sft = 0;\n\telse\n\t\treturn -EINVAL;\n\n\tval = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;\n\n\trt722_sdca_index_read(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_HDA_LEGACY_MUX_CTL0, &val2);\n\tval2 = (0x7 << mask_sft) & val2;\n\n\tif (val == val2)\n\t\tchange = 0;\n\telse\n\t\tchange = 1;\n\n\tif (change)\n\t\trt722_sdca_index_update_bits(rt722, RT722_VENDOR_HDA_CTL,\n\t\t\tRT722_HDA_LEGACY_MUX_CTL0, 0x7 << mask_sft,\n\t\t\tval << mask_sft);\n\n\tsnd_soc_dapm_mux_update_power(dapm, kcontrol,\n\t\titem[0], e, NULL);\n\n\treturn change;\n}\n\nstatic const char * const adc22_mux_text[] = {\n\t\"MIC2\",\n\t\"LINE1\",\n\t\"LINE2\",\n};\n\nstatic const char * const adc07_10_mux_text[] = {\n\t\"DMIC1\",\n\t\"DMIC2\",\n};\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt722_adc22_enum, SND_SOC_NOPM, 0, adc22_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt722_adc24_enum, SND_SOC_NOPM, 0, adc07_10_mux_text);\n\nstatic SOC_ENUM_SINGLE_DECL(\n\trt722_adc25_enum, SND_SOC_NOPM, 0, adc07_10_mux_text);\n\nstatic const struct snd_kcontrol_new rt722_sdca_adc22_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 22 Mux\", rt722_adc22_enum,\n\t\t\trt722_sdca_adc_mux_get, rt722_sdca_adc_mux_put);\n\nstatic const struct snd_kcontrol_new rt722_sdca_adc24_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 24 Mux\", rt722_adc24_enum,\n\t\t\trt722_sdca_adc_mux_get, rt722_sdca_adc_mux_put);\n\nstatic const struct snd_kcontrol_new rt722_sdca_adc25_mux =\n\tSOC_DAPM_ENUM_EXT(\"ADC 25 Mux\", rt722_adc25_enum,\n\t\t\trt722_sdca_adc_mux_get, rt722_sdca_adc_mux_put);\n\nstatic int rt722_sdca_fu42_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char unmute = 0x0, mute = 0x1;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_L), unmute);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_R), unmute);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_L), mute);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_USER_FU05,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_R), mute);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu21_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char unmute = 0x0, mute = 0x1;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_L), unmute);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_R), unmute);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_L), mute);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_USER_FU06,\n\t\t\t\tRT722_SDCA_CTL_FU_MUTE, CH_R), mute);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu113_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\trt722->fu1e_dapm_mute = false;\n\t\trt722_sdca_set_fu1e_capture_ctl(rt722);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\trt722->fu1e_dapm_mute = true;\n\t\trt722_sdca_set_fu1e_capture_ctl(rt722);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_fu36_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\trt722->fu0f_dapm_mute = false;\n\t\trt722_sdca_set_fu0f_capture_ctl(rt722);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\trt722->fu0f_dapm_mute = true;\n\t\trt722_sdca_set_fu0f_capture_ctl(rt722);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_pde47_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PDE40,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PDE40,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_pde23_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_PDE23,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_PDE23,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_pde11_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_PDE2A,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_PDE2A,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rt722_sdca_pde12_event(struct snd_soc_dapm_widget *w,\n\tstruct snd_kcontrol *kcontrol, int event)\n{\n\tstruct snd_soc_component *component =\n\t\tsnd_soc_dapm_to_component(w->dapm);\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tunsigned char ps0 = 0x0, ps3 = 0x3;\n\n\tswitch (event) {\n\tcase SND_SOC_DAPM_POST_PMU:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PDE12,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps0);\n\t\tbreak;\n\tcase SND_SOC_DAPM_PRE_PMD:\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_PDE12,\n\t\t\t\tRT722_SDCA_CTL_REQ_POWER_STATE, 0), ps3);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic const struct snd_soc_dapm_widget rt722_sdca_dapm_widgets[] = {\n\tSND_SOC_DAPM_OUTPUT(\"HP\"),\n\tSND_SOC_DAPM_OUTPUT(\"SPK\"),\n\tSND_SOC_DAPM_INPUT(\"MIC2\"),\n\tSND_SOC_DAPM_INPUT(\"LINE1\"),\n\tSND_SOC_DAPM_INPUT(\"LINE2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC1_2\"),\n\tSND_SOC_DAPM_INPUT(\"DMIC3_4\"),\n\n\tSND_SOC_DAPM_SUPPLY(\"PDE 23\", SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_pde23_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"PDE 47\", SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_pde47_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"PDE 11\", SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_pde11_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_SUPPLY(\"PDE 12\", SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_pde12_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\n\tSND_SOC_DAPM_DAC_E(\"FU 21\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_fu21_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_DAC_E(\"FU 42\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_fu42_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"FU 36\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_fu36_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_ADC_E(\"FU 113\", NULL, SND_SOC_NOPM, 0, 0,\n\t\trt722_sdca_fu113_event,\n\t\tSND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),\n\tSND_SOC_DAPM_MUX(\"ADC 22 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt722_sdca_adc22_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 24 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt722_sdca_adc24_mux),\n\tSND_SOC_DAPM_MUX(\"ADC 25 Mux\", SND_SOC_NOPM, 0, 0,\n\t\t&rt722_sdca_adc25_mux),\n\n\tSND_SOC_DAPM_AIF_IN(\"DP1RX\", \"DP1 Headphone Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP2TX\", \"DP2 Headset Capture\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_IN(\"DP3RX\", \"DP3 Speaker Playback\", 0, SND_SOC_NOPM, 0, 0),\n\tSND_SOC_DAPM_AIF_OUT(\"DP6TX\", \"DP6 DMic Capture\", 0, SND_SOC_NOPM, 0, 0),\n};\n\nstatic const struct snd_soc_dapm_route rt722_sdca_audio_map[] = {\n\t{\"FU 42\", NULL, \"DP1RX\"},\n\t{\"FU 21\", NULL, \"DP3RX\"},\n\n\t{\"ADC 22 Mux\", \"MIC2\", \"MIC2\"},\n\t{\"ADC 22 Mux\", \"LINE1\", \"LINE1\"},\n\t{\"ADC 22 Mux\", \"LINE2\", \"LINE2\"},\n\t{\"ADC 24 Mux\", \"DMIC1\", \"DMIC1_2\"},\n\t{\"ADC 24 Mux\", \"DMIC2\", \"DMIC3_4\"},\n\t{\"ADC 25 Mux\", \"DMIC1\", \"DMIC1_2\"},\n\t{\"ADC 25 Mux\", \"DMIC2\", \"DMIC3_4\"},\n\t{\"FU 36\", NULL, \"PDE 12\"},\n\t{\"FU 36\", NULL, \"ADC 22 Mux\"},\n\t{\"FU 113\", NULL, \"PDE 11\"},\n\t{\"FU 113\", NULL, \"ADC 24 Mux\"},\n\t{\"FU 113\", NULL, \"ADC 25 Mux\"},\n\t{\"DP2TX\", NULL, \"FU 36\"},\n\t{\"DP6TX\", NULL, \"FU 113\"},\n\n\t{\"HP\", NULL, \"PDE 47\"},\n\t{\"HP\", NULL, \"FU 42\"},\n\t{\"SPK\", NULL, \"PDE 23\"},\n\t{\"SPK\", NULL, \"FU 21\"},\n};\n\nstatic int rt722_sdca_parse_dt(struct rt722_sdca_priv *rt722, struct device *dev)\n{\n\tdevice_property_read_u32(dev, \"realtek,jd-src\", &rt722->jd_src);\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_probe(struct snd_soc_component *component)\n{\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tint ret;\n\n\trt722_sdca_parse_dt(rt722, &rt722->slave->dev);\n\trt722->component = component;\n\n\tret = pm_runtime_resume(component->dev);\n\tif (ret < 0 && ret != -EACCES)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct snd_soc_component_driver soc_sdca_dev_rt722 = {\n\t.probe = rt722_sdca_probe,\n\t.controls = rt722_sdca_controls,\n\t.num_controls = ARRAY_SIZE(rt722_sdca_controls),\n\t.dapm_widgets = rt722_sdca_dapm_widgets,\n\t.num_dapm_widgets = ARRAY_SIZE(rt722_sdca_dapm_widgets),\n\t.dapm_routes = rt722_sdca_audio_map,\n\t.num_dapm_routes = ARRAY_SIZE(rt722_sdca_audio_map),\n\t.set_jack = rt722_sdca_set_jack_detect,\n\t.endianness = 1,\n};\n\nstatic int rt722_sdca_set_sdw_stream(struct snd_soc_dai *dai, void *sdw_stream,\n\t\t\t\tint direction)\n{\n\tsnd_soc_dai_dma_data_set(dai, direction, sdw_stream);\n\n\treturn 0;\n}\n\nstatic void rt722_sdca_shutdown(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tsnd_soc_dai_set_dma_data(dai, substream, NULL);\n}\n\nstatic int rt722_sdca_pcm_hw_params(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_pcm_hw_params *params,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_config stream_config;\n\tstruct sdw_port_config port_config;\n\tenum sdw_data_direction direction;\n\tstruct sdw_stream_runtime *sdw_stream;\n\tint retval, port, num_channels;\n\tunsigned int sampling_rate;\n\n\tdev_dbg(dai->dev, \"%s %s\", __func__, dai->name);\n\tsdw_stream = snd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!sdw_stream)\n\t\treturn -EINVAL;\n\n\tif (!rt722->slave)\n\t\treturn -EINVAL;\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tdirection = SDW_DATA_DIR_RX;\n\t\tif (dai->id == RT722_AIF1)\n\t\t\tport = 1;\n\t\telse if (dai->id == RT722_AIF2)\n\t\t\tport = 3;\n\t\telse\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tdirection = SDW_DATA_DIR_TX;\n\t\tif (dai->id == RT722_AIF1)\n\t\t\tport = 2;\n\t\telse if (dai->id == RT722_AIF3)\n\t\t\tport = 6;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\tstream_config.frame_rate = params_rate(params);\n\tstream_config.ch_count = params_channels(params);\n\tstream_config.bps = snd_pcm_format_width(params_format(params));\n\tstream_config.direction = direction;\n\n\tnum_channels = params_channels(params);\n\tport_config.ch_mask = GENMASK(num_channels - 1, 0);\n\tport_config.num = port;\n\n\tretval = sdw_stream_add_slave(rt722->slave, &stream_config,\n\t\t\t\t\t&port_config, 1, sdw_stream);\n\tif (retval) {\n\t\tdev_err(dai->dev, \"Unable to configure port\\n\");\n\t\treturn retval;\n\t}\n\n\tif (params_channels(params) > 16) {\n\t\tdev_err(component->dev, \"Unsupported channels %d\\n\",\n\t\t\tparams_channels(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (params_rate(params)) {\n\tcase 44100:\n\t\tsampling_rate = RT722_SDCA_RATE_44100HZ;\n\t\tbreak;\n\tcase 48000:\n\t\tsampling_rate = RT722_SDCA_RATE_48000HZ;\n\t\tbreak;\n\tcase 96000:\n\t\tsampling_rate = RT722_SDCA_RATE_96000HZ;\n\t\tbreak;\n\tcase 192000:\n\t\tsampling_rate = RT722_SDCA_RATE_192000HZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(component->dev, \"Rate %d is not supported\\n\",\n\t\t\tparams_rate(params));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (dai->id == RT722_AIF1) {\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_CS01,\n\t\t\t\tRT722_SDCA_CTL_SAMPLE_FREQ_INDEX, 0), sampling_rate);\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_JACK_CODEC, RT722_SDCA_ENT_CS11,\n\t\t\t\tRT722_SDCA_CTL_SAMPLE_FREQ_INDEX, 0), sampling_rate);\n\t}\n\n\tif (dai->id == RT722_AIF2)\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_CS31,\n\t\t\t\tRT722_SDCA_CTL_SAMPLE_FREQ_INDEX, 0), sampling_rate);\n\n\tif (dai->id == RT722_AIF3)\n\t\tregmap_write(rt722->regmap,\n\t\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_CS1F,\n\t\t\t\tRT722_SDCA_CTL_SAMPLE_FREQ_INDEX, 0), sampling_rate);\n\n\treturn 0;\n}\n\nstatic int rt722_sdca_pcm_hw_free(struct snd_pcm_substream *substream,\n\t\t\t\tstruct snd_soc_dai *dai)\n{\n\tstruct snd_soc_component *component = dai->component;\n\tstruct rt722_sdca_priv *rt722 = snd_soc_component_get_drvdata(component);\n\tstruct sdw_stream_runtime *sdw_stream =\n\t\tsnd_soc_dai_get_dma_data(dai, substream);\n\n\tif (!rt722->slave)\n\t\treturn -EINVAL;\n\n\tsdw_stream_remove_slave(rt722->slave, sdw_stream);\n\treturn 0;\n}\n\n#define RT722_STEREO_RATES (SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | \\\n\t\t\tSNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000)\n#define RT722_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \\\n\t\t\tSNDRV_PCM_FMTBIT_S24_LE)\n\nstatic const struct snd_soc_dai_ops rt722_sdca_ops = {\n\t.hw_params\t= rt722_sdca_pcm_hw_params,\n\t.hw_free\t= rt722_sdca_pcm_hw_free,\n\t.set_stream\t= rt722_sdca_set_sdw_stream,\n\t.shutdown\t= rt722_sdca_shutdown,\n};\n\nstatic struct snd_soc_dai_driver rt722_sdca_dai[] = {\n\t{\n\t\t.name = \"rt722-sdca-aif1\",\n\t\t.id = RT722_AIF1,\n\t\t.playback = {\n\t\t\t.stream_name = \"DP1 Headphone Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT722_STEREO_RATES,\n\t\t\t.formats = RT722_FORMATS,\n\t\t},\n\t\t.capture = {\n\t\t\t.stream_name = \"DP2 Headset Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT722_STEREO_RATES,\n\t\t\t.formats = RT722_FORMATS,\n\t\t},\n\t\t.ops = &rt722_sdca_ops,\n\t},\n\t{\n\t\t.name = \"rt722-sdca-aif2\",\n\t\t.id = RT722_AIF2,\n\t\t.playback = {\n\t\t\t.stream_name = \"DP3 Speaker Playback\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT722_STEREO_RATES,\n\t\t\t.formats = RT722_FORMATS,\n\t\t},\n\t\t.ops = &rt722_sdca_ops,\n\t},\n\t{\n\t\t.name = \"rt722-sdca-aif3\",\n\t\t.id = RT722_AIF3,\n\t\t.capture = {\n\t\t\t.stream_name = \"DP6 DMic Capture\",\n\t\t\t.channels_min = 1,\n\t\t\t.channels_max = 2,\n\t\t\t.rates = RT722_STEREO_RATES,\n\t\t\t.formats = RT722_FORMATS,\n\t\t},\n\t\t.ops = &rt722_sdca_ops,\n\t}\n};\n\nint rt722_sdca_init(struct device *dev, struct regmap *regmap,\n\t\t\tstruct regmap *mbq_regmap, struct sdw_slave *slave)\n{\n\tstruct rt722_sdca_priv *rt722;\n\n\trt722 = devm_kzalloc(dev, sizeof(*rt722), GFP_KERNEL);\n\tif (!rt722)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(dev, rt722);\n\trt722->slave = slave;\n\trt722->regmap = regmap;\n\trt722->mbq_regmap = mbq_regmap;\n\n\tmutex_init(&rt722->calibrate_mutex);\n\tmutex_init(&rt722->disable_irq_lock);\n\n\tINIT_DELAYED_WORK(&rt722->jack_detect_work, rt722_sdca_jack_detect_handler);\n\tINIT_DELAYED_WORK(&rt722->jack_btn_check_work, rt722_sdca_btn_check_handler);\n\n\t \n\trt722->hw_init = false;\n\trt722->first_hw_init = false;\n\trt722->fu1e_dapm_mute = true;\n\trt722->fu0f_dapm_mute = true;\n\trt722->fu0f_mixer_l_mute = rt722->fu0f_mixer_r_mute = true;\n\trt722->fu1e_mixer_mute[0] = rt722->fu1e_mixer_mute[1] =\n\t\trt722->fu1e_mixer_mute[2] = rt722->fu1e_mixer_mute[3] = true;\n\n\treturn devm_snd_soc_register_component(dev,\n\t\t\t&soc_sdca_dev_rt722, rt722_sdca_dai, ARRAY_SIZE(rt722_sdca_dai));\n}\n\nstatic void rt722_sdca_dmic_preset(struct rt722_sdca_priv *rt722)\n{\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_ADC0A_08_PDE_FLOAT_CTL, 0x2a29);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_ADC10_PDE_FLOAT_CTL, 0x2a00);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_DMIC1_2_PDE_FLOAT_CTL, 0x2a2a);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_DMIC_ENT_FLOAT_CTL, 0x2626);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_ADC_ENT_FLOAT_CTL, 0x1e00);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_DMIC_GAIN_ENT_FLOAT_CTL0, 0x1515);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_ADC_VOL_CH_FLOAT_CTL, 0x0304);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_DMIC_GAIN_ENT_FLOAT_CTL2, 0x0304);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL,\n\t\tRT722_HDA_LEGACY_CONFIG_CTL0, 0x0000);\n\t \n\tregmap_write(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_MIC_ARRAY, RT722_SDCA_ENT_IT26,\n\t\t\tRT722_SDCA_CTL_VENDOR_DEF, 0), 0x01);\n\t \n\tregmap_write(rt722->regmap, 0x2f5c, 0x25);\n}\n\nstatic void rt722_sdca_amp_preset(struct rt722_sdca_priv *rt722)\n{\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_REG, RT722_CLSD_CTRL6,\n\t\t0xc215);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_CALI, RT722_DC_CALIB_CTRL,\n\t\t0x702c);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_CALI, RT722_DC_CALIB_CTRL,\n\t\t0xf02d);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_AMP_PDE_FLOAT_CTL,\n\t\t0x2323);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_EAPD_CTL,\n\t\t0x0002);\n\t \n\tregmap_write(rt722->regmap,\n\t\tSDW_SDCA_CTL(FUNC_NUM_AMP, RT722_SDCA_ENT_OT23,\n\t\t\tRT722_SDCA_CTL_VENDOR_DEF, CH_08), 0x04);\n}\n\nstatic void rt722_sdca_jack_preset(struct rt722_sdca_priv *rt722)\n{\n\tint loop_check, chk_cnt = 100, ret;\n\tunsigned int calib_status = 0;\n\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_SPK_EFUSE, RT722_DC_CALIB_CTRL,\n\t\t0x4808);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_UMP_HID_CTL4,\n\t\t0xcf00);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_UMP_HID_CTL5,\n\t\t0x000f);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_UMP_HID_CTL0,\n\t\t0x1100);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_UMP_HID_CTL7,\n\t\t0x0c12);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_REG, RT722_JD_CTRL1,\n\t\t0x7002);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_REG, RT722_CLSD_CTRL6,\n\t\t0xc215);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_REG, RT722_FSM_CTL,\n\t\t0x4100);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_CALI, RT722_DAC_DC_CALI_CTL3,\n\t\t0x008d);\n\t \n\tfor (loop_check = 0; loop_check < chk_cnt; loop_check++) {\n\t\tret = rt722_sdca_index_read(rt722, RT722_VENDOR_CALI,\n\t\t\tRT722_DAC_DC_CALI_CTL3, &calib_status);\n\t\tif (ret < 0 || loop_check == chk_cnt)\n\t\t\tdev_dbg(&rt722->slave->dev, \"calibration failed!, ret=%d\\n\", ret);\n\t\tif ((calib_status & 0x0040) == 0x0)\n\t\t\tbreak;\n\t}\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_REG, RT722_DIGITAL_MISC_CTRL4,\n\t\t0x0010);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_ADC0A_08_PDE_FLOAT_CTL,\n\t\t0x2a12);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_MIC2_LINE2_PDE_FLOAT_CTL,\n\t\t0x3429);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_ET41_LINE2_PDE_FLOAT_CTL,\n\t\t0x4112);\n\t \n\trt722_sdca_index_write(rt722, RT722_VENDOR_HDA_CTL, RT722_DAC03_HP_PDE_FLOAT_CTL,\n\t\t0x4040);\n\t \n\tregmap_write(rt722->regmap, 0x2f58, 0x07);\n}\n\nint rt722_sdca_io_init(struct device *dev, struct sdw_slave *slave)\n{\n\tstruct rt722_sdca_priv *rt722 = dev_get_drvdata(dev);\n\n\trt722->disable_irq = false;\n\n\tif (rt722->hw_init)\n\t\treturn 0;\n\n\tif (rt722->first_hw_init) {\n\t\tregcache_cache_only(rt722->regmap, false);\n\t\tregcache_cache_bypass(rt722->regmap, true);\n\t\tregcache_cache_only(rt722->mbq_regmap, false);\n\t\tregcache_cache_bypass(rt722->mbq_regmap, true);\n\t} else {\n\t\t \n\n\t\t \n\t\tpm_runtime_set_autosuspend_delay(&slave->dev, 3000);\n\t\tpm_runtime_use_autosuspend(&slave->dev);\n\n\t\t \n\t\tpm_runtime_set_active(&slave->dev);\n\n\t\t \n\t\tpm_runtime_mark_last_busy(&slave->dev);\n\n\t\tpm_runtime_enable(&slave->dev);\n\t}\n\n\tpm_runtime_get_noresume(&slave->dev);\n\n\trt722_sdca_dmic_preset(rt722);\n\trt722_sdca_amp_preset(rt722);\n\trt722_sdca_jack_preset(rt722);\n\n\tif (rt722->first_hw_init) {\n\t\tregcache_cache_bypass(rt722->regmap, false);\n\t\tregcache_mark_dirty(rt722->regmap);\n\t\tregcache_cache_bypass(rt722->mbq_regmap, false);\n\t\tregcache_mark_dirty(rt722->mbq_regmap);\n\t} else\n\t\trt722->first_hw_init = true;\n\n\t \n\trt722->hw_init = true;\n\n\tpm_runtime_mark_last_busy(&slave->dev);\n\tpm_runtime_put_autosuspend(&slave->dev);\n\n\tdev_dbg(&slave->dev, \"%s hw_init complete\\n\", __func__);\n\treturn 0;\n}\n\nMODULE_DESCRIPTION(\"ASoC RT722 SDCA SDW driver\");\nMODULE_AUTHOR(\"Jack Yu <jack.yu@realtek.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}